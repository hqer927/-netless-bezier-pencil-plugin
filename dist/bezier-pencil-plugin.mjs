import { toJS as vl, autorun as xt, ApplianceNames as _i, isRoom as Oi, InvisiblePlugin as ns, RoomPhase as es, isPlayer as Xs } from "white-web-sdk";
import { decompress as os, compress as as } from "lz-string";
import "lineclip";
import * as cl from "react";
import hi, { useContext as hl, useState as Xl, useMemo as zl, useEffect as Ul } from "react";
import Gd from "react-draggable";
import Vd from "eventemitter2";
import { debounce as Ws, isEqual as us, cloneDeep as Gs } from "lodash";
import { Resizable as Vs } from "re-resizable";
import { WindowManager as hs } from "@netless/window-manager";
var nl;
(function(m) {
  m[m.pedding = 0] = "pedding", m[m.mounted = 1] = "mounted", m[m.update = 2] = "update", m[m.unmounted = 3] = "unmounted";
})(nl || (nl = {}));
var ml;
(function(m) {
  m[m.Normal = 0] = "Normal", m[m.Stroke = 1] = "Stroke", m[m.Dotted = 2] = "Dotted", m[m.LongDotted = 3] = "LongDotted";
})(ml || (ml = {}));
var Wi;
(function(m) {
  m.ShowFloatBar = "ShowFloatBar", m.ZIndexFloatBar = "ZIndexFloatBar", m.DeleteNode = "DeleteNode", m.CopyNode = "CopyNode", m.ZIndexActive = "ZIndexActive", m.ZIndexNode = "ZIndexNode", m.RotateNode = "RotateNode", m.SetColorNode = "SetColorNode", m.TranslateNode = "TranslateNode", m.ScaleNode = "ScaleNode", m.OriginalEvent = "OriginalEvent", m.CreateScene = "createScene", m.ActiveCursor = "ActiveCursor", m.MoveCursor = "MoveCursor";
})(Wi || (Wi = {}));
var ui;
(function(m) {
  m.DisplayState = "DisplayState", m.FloatBar = "FloatBar", m.CanvasSelector = "CanvasSelector", m.MainEngine = "MainEngine", m.DisplayContainer = "DisplayContainer", m.Cursor = "Cursor";
})(ui || (ui = {}));
var ri;
(function(m) {
  m[m.Pencil = 1] = "Pencil", m[m.Eraser = 2] = "Eraser", m[m.Selector = 3] = "Selector", m[m.Clicker = 4] = "Clicker", m[m.Arrow = 5] = "Arrow", m[m.Hand = 6] = "Hand", m[m.LaserPen = 7] = "LaserPen";
})(ri || (ri = {}));
var Jd;
(function(m) {
  m[m.Path = 0] = "Path", m[m.Rect = 1] = "Rect";
})(Jd || (Jd = {}));
var Ti;
(function(m) {
  m[m.Local = 1] = "Local", m[m.Service = 2] = "Service";
})(Ti || (Ti = {}));
var Ii;
(function(m) {
  m[m.Pending = 0] = "Pending", m[m.Start = 1] = "Start", m[m.Doing = 2] = "Doing", m[m.Done = 3] = "Done", m[m.Freeze = 4] = "Freeze", m[m.Unwritable = 5] = "Unwritable";
})(Ii || (Ii = {}));
var pi;
(function(m) {
  m[m.Init = 0] = "Init", m[m.UpdateCamera = 1] = "UpdateCamera", m[m.UpdateTools = 2] = "UpdateTools", m[m.CreateWork = 3] = "CreateWork", m[m.DrawWork = 4] = "DrawWork", m[m.FullWork = 5] = "FullWork", m[m.UpdateNode = 6] = "UpdateNode", m[m.RemoveNode = 7] = "RemoveNode", m[m.Clear = 8] = "Clear", m[m.Select = 9] = "Select", m[m.Destroy = 10] = "Destroy", m[m.None = 11] = "None", m[m.Snapshot = 12] = "Snapshot", m[m.BoundingBox = 13] = "BoundingBox", m[m.Cursor = 14] = "Cursor";
})(pi || (pi = {}));
var Fd;
(function(m) {
  m[m.Path = 0] = "Path", m[m.Rect = 1] = "Rect", m[m.Texture = 2] = "Texture";
})(Fd || (Fd = {}));
var ed;
(function(m) {
  m.Webgl2 = "webgl2", m.Webgl = "webgl", m.Canvas2d = "2d";
})(ed || (ed = {}));
var Sl;
(function(m) {
  m[m.Float = 1] = "Float", m[m.Bg = 2] = "Bg", m[m.Selector = 3] = "Selector", m[m.None = 4] = "None";
})(Sl || (Sl = {}));
var Td;
(function(m) {
  m.LT = "topLeft", m.LC = "left", m.LB = "bottomLeft", m.TC = "top", m.RT = "topRight", m.RC = "right", m.RB = "bottomRight", m.BC = "bottom";
})(Td || (Td = {}));
var Ll;
(function(m) {
  m[m.Cursor = 1] = "Cursor";
})(Ll || (Ll = {}));
var ul;
(function(m) {
  m[m.Top = 1] = "Top", m[m.Bottom = 2] = "Bottom";
})(ul || (ul = {}));
const Gl = "++", Ci = "selector";
var Ql = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Dl(m) {
  return m && m.__esModule && Object.prototype.hasOwnProperty.call(m, "default") ? m.default : m;
}
function Is() {
  this.__data__ = [], this.size = 0;
}
var ps = Is;
function ys(m, l) {
  return m === l || m !== m && l !== l;
}
var hd = ys, Ls = hd;
function rs(m, l) {
  for (var i = m.length; i--; )
    if (Ls(m[i][0], l))
      return i;
  return -1;
}
var Al = rs, Ys = Al, xs = Array.prototype, Ss = xs.splice;
function Rs(m) {
  var l = this.__data__, i = Ys(l, m);
  if (i < 0)
    return !1;
  var d = l.length - 1;
  return i == d ? l.pop() : Ss.call(l, i, 1), --this.size, !0;
}
var Ks = Rs, Cs = Al;
function Js(m) {
  var l = this.__data__, i = Cs(l, m);
  return i < 0 ? void 0 : l[i][1];
}
var Fs = Js, Ts = Al;
function Ns(m) {
  return Ts(this.__data__, m) > -1;
}
var gs = Ns, Hs = Al;
function Ms(m, l) {
  var i = this.__data__, d = Hs(i, m);
  return d < 0 ? (++this.size, i.push([m, l])) : i[d][1] = l, this;
}
var zs = Ms, ks = ps, vs = Ks, Us = Fs, fs = gs, Qs = zs;
function Rl(m) {
  var l = -1, i = m == null ? 0 : m.length;
  for (this.clear(); ++l < i; ) {
    var d = m[l];
    this.set(d[0], d[1]);
  }
}
Rl.prototype.clear = ks;
Rl.prototype.delete = vs;
Rl.prototype.get = Us;
Rl.prototype.has = fs;
Rl.prototype.set = Qs;
var ql = Rl, Ps = ql;
function ws() {
  this.__data__ = new Ps(), this.size = 0;
}
var Es = ws;
function js(m) {
  var l = this.__data__, i = l.delete(m);
  return this.size = l.size, i;
}
var Bs = js;
function Os(m) {
  return this.__data__.get(m);
}
var Ds = Os;
function As(m) {
  return this.__data__.has(m);
}
var qs = As, $s = typeof Ql == "object" && Ql && Ql.Object === Object && Ql, St = $s, _s = St, ib = typeof self == "object" && self && self.Object === Object && self, lb = _s || ib || Function("return this")(), Zl = lb, db = Zl, tb = db.Symbol, $l = tb, Nd = $l, Rt = Object.prototype, sb = Rt.hasOwnProperty, bb = Rt.toString, Hl = Nd ? Nd.toStringTag : void 0;
function cb(m) {
  var l = sb.call(m, Hl), i = m[Hl];
  try {
    m[Hl] = void 0;
    var d = !0;
  } catch {
  }
  var s = bb.call(m);
  return d && (l ? m[Hl] = i : delete m[Hl]), s;
}
var mb = cb, Zb = Object.prototype, nb = Zb.toString;
function eb(m) {
  return nb.call(m);
}
var Xb = eb, gd = $l, ob = mb, ab = Xb, Wb = "[object Null]", ub = "[object Undefined]", Hd = gd ? gd.toStringTag : void 0;
function Gb(m) {
  return m == null ? m === void 0 ? ub : Wb : Hd && Hd in Object(m) ? ob(m) : ab(m);
}
var Kl = Gb;
function Vb(m) {
  var l = typeof m;
  return m != null && (l == "object" || l == "function");
}
var Il = Vb, hb = Kl, Ib = Il, pb = "[object AsyncFunction]", yb = "[object Function]", Lb = "[object GeneratorFunction]", rb = "[object Proxy]";
function Yb(m) {
  if (!Ib(m))
    return !1;
  var l = hb(m);
  return l == yb || l == Lb || l == pb || l == rb;
}
var Kt = Yb, xb = Zl, Sb = xb["__core-js_shared__"], Rb = Sb, cd = Rb, Md = function() {
  var m = /[^.]+$/.exec(cd && cd.keys && cd.keys.IE_PROTO || "");
  return m ? "Symbol(src)_1." + m : "";
}();
function Kb(m) {
  return !!Md && Md in m;
}
var Cb = Kb, Jb = Function.prototype, Fb = Jb.toString;
function Tb(m) {
  if (m != null) {
    try {
      return Fb.call(m);
    } catch {
    }
    try {
      return m + "";
    } catch {
    }
  }
  return "";
}
var Ct = Tb, Nb = Kt, gb = Cb, Hb = Il, Mb = Ct, zb = /[\\^$.*+?()[\]{}|]/g, kb = /^\[object .+?Constructor\]$/, vb = Function.prototype, Ub = Object.prototype, fb = vb.toString, Qb = Ub.hasOwnProperty, Pb = RegExp(
  "^" + fb.call(Qb).replace(zb, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function wb(m) {
  if (!Hb(m) || gb(m))
    return !1;
  var l = Nb(m) ? Pb : kb;
  return l.test(Mb(m));
}
var Eb = wb;
function jb(m, l) {
  return m == null ? void 0 : m[l];
}
var Bb = jb, Ob = Eb, Db = Bb;
function Ab(m, l) {
  var i = Db(m, l);
  return Ob(i) ? i : void 0;
}
var Yl = Ab, qb = Yl, $b = Zl, _b = qb($b, "Map"), Id = _b, ic = Yl, lc = ic(Object, "create"), _l = lc, zd = _l;
function dc() {
  this.__data__ = zd ? zd(null) : {}, this.size = 0;
}
var tc = dc;
function sc(m) {
  var l = this.has(m) && delete this.__data__[m];
  return this.size -= l ? 1 : 0, l;
}
var bc = sc, cc = _l, mc = "__lodash_hash_undefined__", Zc = Object.prototype, nc = Zc.hasOwnProperty;
function ec(m) {
  var l = this.__data__;
  if (cc) {
    var i = l[m];
    return i === mc ? void 0 : i;
  }
  return nc.call(l, m) ? l[m] : void 0;
}
var Xc = ec, oc = _l, ac = Object.prototype, Wc = ac.hasOwnProperty;
function uc(m) {
  var l = this.__data__;
  return oc ? l[m] !== void 0 : Wc.call(l, m);
}
var Gc = uc, Vc = _l, hc = "__lodash_hash_undefined__";
function Ic(m, l) {
  var i = this.__data__;
  return this.size += this.has(m) ? 0 : 1, i[m] = Vc && l === void 0 ? hc : l, this;
}
var pc = Ic, yc = tc, Lc = bc, rc = Xc, Yc = Gc, xc = pc;
function Cl(m) {
  var l = -1, i = m == null ? 0 : m.length;
  for (this.clear(); ++l < i; ) {
    var d = m[l];
    this.set(d[0], d[1]);
  }
}
Cl.prototype.clear = yc;
Cl.prototype.delete = Lc;
Cl.prototype.get = rc;
Cl.prototype.has = Yc;
Cl.prototype.set = xc;
var Sc = Cl, kd = Sc, Rc = ql, Kc = Id;
function Cc() {
  this.size = 0, this.__data__ = {
    hash: new kd(),
    map: new (Kc || Rc)(),
    string: new kd()
  };
}
var Jc = Cc;
function Fc(m) {
  var l = typeof m;
  return l == "string" || l == "number" || l == "symbol" || l == "boolean" ? m !== "__proto__" : m === null;
}
var Tc = Fc, Nc = Tc;
function gc(m, l) {
  var i = m.__data__;
  return Nc(l) ? i[typeof l == "string" ? "string" : "hash"] : i.map;
}
var id = gc, Hc = id;
function Mc(m) {
  var l = Hc(this, m).delete(m);
  return this.size -= l ? 1 : 0, l;
}
var zc = Mc, kc = id;
function vc(m) {
  return kc(this, m).get(m);
}
var Uc = vc, fc = id;
function Qc(m) {
  return fc(this, m).has(m);
}
var Pc = Qc, wc = id;
function Ec(m, l) {
  var i = wc(this, m), d = i.size;
  return i.set(m, l), this.size += i.size == d ? 0 : 1, this;
}
var jc = Ec, Bc = Jc, Oc = zc, Dc = Uc, Ac = Pc, qc = jc;
function Jl(m) {
  var l = -1, i = m == null ? 0 : m.length;
  for (this.clear(); ++l < i; ) {
    var d = m[l];
    this.set(d[0], d[1]);
  }
}
Jl.prototype.clear = Bc;
Jl.prototype.delete = Oc;
Jl.prototype.get = Dc;
Jl.prototype.has = Ac;
Jl.prototype.set = qc;
var Jt = Jl, $c = ql, _c = Id, im = Jt, lm = 200;
function dm(m, l) {
  var i = this.__data__;
  if (i instanceof $c) {
    var d = i.__data__;
    if (!_c || d.length < lm - 1)
      return d.push([m, l]), this.size = ++i.size, this;
    i = this.__data__ = new im(d);
  }
  return i.set(m, l), this.size = i.size, this;
}
var tm = dm, sm = ql, bm = Es, cm = Bs, mm = Ds, Zm = qs, nm = tm;
function Fl(m) {
  var l = this.__data__ = new sm(m);
  this.size = l.size;
}
Fl.prototype.clear = bm;
Fl.prototype.delete = cm;
Fl.prototype.get = mm;
Fl.prototype.has = Zm;
Fl.prototype.set = nm;
var Ft = Fl;
function em(m, l) {
  for (var i = -1, d = m == null ? 0 : m.length; ++i < d && l(m[i], i, m) !== !1; )
    ;
  return m;
}
var Xm = em, om = Yl, am = function() {
  try {
    var m = om(Object, "defineProperty");
    return m({}, "", {}), m;
  } catch {
  }
}(), Wm = am, vd = Wm;
function um(m, l, i) {
  l == "__proto__" && vd ? vd(m, l, {
    configurable: !0,
    enumerable: !0,
    value: i,
    writable: !0
  }) : m[l] = i;
}
var Tt = um, Gm = Tt, Vm = hd, hm = Object.prototype, Im = hm.hasOwnProperty;
function pm(m, l, i) {
  var d = m[l];
  (!(Im.call(m, l) && Vm(d, i)) || i === void 0 && !(l in m)) && Gm(m, l, i);
}
var Nt = pm, ym = Nt, Lm = Tt;
function rm(m, l, i, d) {
  var s = !i;
  i || (i = {});
  for (var X = -1, a = l.length; ++X < a; ) {
    var e = l[X], n = d ? d(i[e], m[e], e, i, m) : void 0;
    n === void 0 && (n = m[e]), s ? Lm(i, e, n) : ym(i, e, n);
  }
  return i;
}
var ld = rm;
function Ym(m, l) {
  for (var i = -1, d = Array(m); ++i < m; )
    d[i] = l(i);
  return d;
}
var xm = Ym;
function Sm(m) {
  return m != null && typeof m == "object";
}
var pl = Sm, Rm = Kl, Km = pl, Cm = "[object Arguments]";
function Jm(m) {
  return Km(m) && Rm(m) == Cm;
}
var Fm = Jm, Ud = Fm, Tm = pl, gt = Object.prototype, Nm = gt.hasOwnProperty, gm = gt.propertyIsEnumerable, Hm = Ud(/* @__PURE__ */ function() {
  return arguments;
}()) ? Ud : function(m) {
  return Tm(m) && Nm.call(m, "callee") && !gm.call(m, "callee");
}, Mm = Hm, zm = Array.isArray, dd = zm, El = { exports: {} };
function km() {
  return !1;
}
var vm = km;
El.exports;
(function(m, l) {
  var i = Zl, d = vm, s = l && !l.nodeType && l, X = s && !0 && m && !m.nodeType && m, a = X && X.exports === s, e = a ? i.Buffer : void 0, n = e ? e.isBuffer : void 0, G = n || d;
  m.exports = G;
})(El, El.exports);
var pd = El.exports, Um = 9007199254740991, fm = /^(?:0|[1-9]\d*)$/;
function Qm(m, l) {
  var i = typeof m;
  return l = l ?? Um, !!l && (i == "number" || i != "symbol" && fm.test(m)) && m > -1 && m % 1 == 0 && m < l;
}
var Pm = Qm, wm = 9007199254740991;
function Em(m) {
  return typeof m == "number" && m > -1 && m % 1 == 0 && m <= wm;
}
var Ht = Em, jm = Kl, Bm = Ht, Om = pl, Dm = "[object Arguments]", Am = "[object Array]", qm = "[object Boolean]", $m = "[object Date]", _m = "[object Error]", iZ = "[object Function]", lZ = "[object Map]", dZ = "[object Number]", tZ = "[object Object]", sZ = "[object RegExp]", bZ = "[object Set]", cZ = "[object String]", mZ = "[object WeakMap]", ZZ = "[object ArrayBuffer]", nZ = "[object DataView]", eZ = "[object Float32Array]", XZ = "[object Float64Array]", oZ = "[object Int8Array]", aZ = "[object Int16Array]", WZ = "[object Int32Array]", uZ = "[object Uint8Array]", GZ = "[object Uint8ClampedArray]", VZ = "[object Uint16Array]", hZ = "[object Uint32Array]", zi = {};
zi[eZ] = zi[XZ] = zi[oZ] = zi[aZ] = zi[WZ] = zi[uZ] = zi[GZ] = zi[VZ] = zi[hZ] = !0;
zi[Dm] = zi[Am] = zi[ZZ] = zi[qm] = zi[nZ] = zi[$m] = zi[_m] = zi[iZ] = zi[lZ] = zi[dZ] = zi[tZ] = zi[sZ] = zi[bZ] = zi[cZ] = zi[mZ] = !1;
function IZ(m) {
  return Om(m) && Bm(m.length) && !!zi[jm(m)];
}
var pZ = IZ;
function yZ(m) {
  return function(l) {
    return m(l);
  };
}
var yd = yZ, jl = { exports: {} };
jl.exports;
(function(m, l) {
  var i = St, d = l && !l.nodeType && l, s = d && !0 && m && !m.nodeType && m, X = s && s.exports === d, a = X && i.process, e = function() {
    try {
      var n = s && s.require && s.require("util").types;
      return n || a && a.binding && a.binding("util");
    } catch {
    }
  }();
  m.exports = e;
})(jl, jl.exports);
var Ld = jl.exports, LZ = pZ, rZ = yd, fd = Ld, Qd = fd && fd.isTypedArray, YZ = Qd ? rZ(Qd) : LZ, Mt = YZ, xZ = xm, SZ = Mm, RZ = dd, KZ = pd, CZ = Pm, JZ = Mt, FZ = Object.prototype, TZ = FZ.hasOwnProperty;
function NZ(m, l) {
  var i = RZ(m), d = !i && SZ(m), s = !i && !d && KZ(m), X = !i && !d && !s && JZ(m), a = i || d || s || X, e = a ? xZ(m.length, String) : [], n = e.length;
  for (var G in m)
    (l || TZ.call(m, G)) && !(a && // Safari 9 has enumerable `arguments.length` in strict mode.
    (G == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    s && (G == "offset" || G == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    X && (G == "buffer" || G == "byteLength" || G == "byteOffset") || // Skip index properties.
    CZ(G, n))) && e.push(G);
  return e;
}
var zt = NZ, gZ = Object.prototype;
function HZ(m) {
  var l = m && m.constructor, i = typeof l == "function" && l.prototype || gZ;
  return m === i;
}
var rd = HZ;
function MZ(m, l) {
  return function(i) {
    return m(l(i));
  };
}
var kt = MZ, zZ = kt, kZ = zZ(Object.keys, Object), vZ = kZ, UZ = rd, fZ = vZ, QZ = Object.prototype, PZ = QZ.hasOwnProperty;
function wZ(m) {
  if (!UZ(m))
    return fZ(m);
  var l = [];
  for (var i in Object(m))
    PZ.call(m, i) && i != "constructor" && l.push(i);
  return l;
}
var EZ = wZ, jZ = Kt, BZ = Ht;
function OZ(m) {
  return m != null && BZ(m.length) && !jZ(m);
}
var vt = OZ, DZ = zt, AZ = EZ, qZ = vt;
function $Z(m) {
  return qZ(m) ? DZ(m) : AZ(m);
}
var Yd = $Z, _Z = ld, i0 = Yd;
function l0(m, l) {
  return m && _Z(l, i0(l), m);
}
var d0 = l0;
function t0(m) {
  var l = [];
  if (m != null)
    for (var i in Object(m))
      l.push(i);
  return l;
}
var s0 = t0, b0 = Il, c0 = rd, m0 = s0, Z0 = Object.prototype, n0 = Z0.hasOwnProperty;
function e0(m) {
  if (!b0(m))
    return m0(m);
  var l = c0(m), i = [];
  for (var d in m)
    d == "constructor" && (l || !n0.call(m, d)) || i.push(d);
  return i;
}
var X0 = e0, o0 = zt, a0 = X0, W0 = vt;
function u0(m) {
  return W0(m) ? o0(m, !0) : a0(m);
}
var xd = u0, G0 = ld, V0 = xd;
function h0(m, l) {
  return m && G0(l, V0(l), m);
}
var I0 = h0, Bl = { exports: {} };
Bl.exports;
(function(m, l) {
  var i = Zl, d = l && !l.nodeType && l, s = d && !0 && m && !m.nodeType && m, X = s && s.exports === d, a = X ? i.Buffer : void 0, e = a ? a.allocUnsafe : void 0;
  function n(G, y) {
    if (y)
      return G.slice();
    var o = G.length, h = e ? e(o) : new G.constructor(o);
    return G.copy(h), h;
  }
  m.exports = n;
})(Bl, Bl.exports);
var p0 = Bl.exports;
function y0(m, l) {
  var i = -1, d = m.length;
  for (l || (l = Array(d)); ++i < d; )
    l[i] = m[i];
  return l;
}
var L0 = y0;
function r0(m, l) {
  for (var i = -1, d = m == null ? 0 : m.length, s = 0, X = []; ++i < d; ) {
    var a = m[i];
    l(a, i, m) && (X[s++] = a);
  }
  return X;
}
var Y0 = r0;
function x0() {
  return [];
}
var Ut = x0, S0 = Y0, R0 = Ut, K0 = Object.prototype, C0 = K0.propertyIsEnumerable, Pd = Object.getOwnPropertySymbols, J0 = Pd ? function(m) {
  return m == null ? [] : (m = Object(m), S0(Pd(m), function(l) {
    return C0.call(m, l);
  }));
} : R0, Sd = J0, F0 = ld, T0 = Sd;
function N0(m, l) {
  return F0(m, T0(m), l);
}
var g0 = N0;
function H0(m, l) {
  for (var i = -1, d = l.length, s = m.length; ++i < d; )
    m[s + i] = l[i];
  return m;
}
var ft = H0, M0 = kt, z0 = M0(Object.getPrototypeOf, Object), Qt = z0, k0 = ft, v0 = Qt, U0 = Sd, f0 = Ut, Q0 = Object.getOwnPropertySymbols, P0 = Q0 ? function(m) {
  for (var l = []; m; )
    k0(l, U0(m)), m = v0(m);
  return l;
} : f0, Pt = P0, w0 = ld, E0 = Pt;
function j0(m, l) {
  return w0(m, E0(m), l);
}
var B0 = j0, O0 = ft, D0 = dd;
function A0(m, l, i) {
  var d = l(m);
  return D0(m) ? d : O0(d, i(m));
}
var wt = A0, q0 = wt, $0 = Sd, _0 = Yd;
function ln(m) {
  return q0(m, _0, $0);
}
var Et = ln, dn = wt, tn = Pt, sn = xd;
function bn(m) {
  return dn(m, sn, tn);
}
var cn = bn, mn = Yl, Zn = Zl, nn = mn(Zn, "DataView"), en = nn, Xn = Yl, on = Zl, an = Xn(on, "Promise"), Wn = an, un = Yl, Gn = Zl, Vn = un(Gn, "Set"), hn = Vn, In = Yl, pn = Zl, yn = In(pn, "WeakMap"), Ln = yn, Xd = en, od = Id, ad = Wn, Wd = hn, ud = Ln, jt = Kl, Tl = Ct, wd = "[object Map]", rn = "[object Object]", Ed = "[object Promise]", jd = "[object Set]", Bd = "[object WeakMap]", Od = "[object DataView]", Yn = Tl(Xd), xn = Tl(od), Sn = Tl(ad), Rn = Tl(Wd), Kn = Tl(ud), yl = jt;
(Xd && yl(new Xd(new ArrayBuffer(1))) != Od || od && yl(new od()) != wd || ad && yl(ad.resolve()) != Ed || Wd && yl(new Wd()) != jd || ud && yl(new ud()) != Bd) && (yl = function(m) {
  var l = jt(m), i = l == rn ? m.constructor : void 0, d = i ? Tl(i) : "";
  if (d)
    switch (d) {
      case Yn:
        return Od;
      case xn:
        return wd;
      case Sn:
        return Ed;
      case Rn:
        return jd;
      case Kn:
        return Bd;
    }
  return l;
});
var td = yl, Cn = Object.prototype, Jn = Cn.hasOwnProperty;
function Fn(m) {
  var l = m.length, i = new m.constructor(l);
  return l && typeof m[0] == "string" && Jn.call(m, "index") && (i.index = m.index, i.input = m.input), i;
}
var Tn = Fn, Nn = Zl, gn = Nn.Uint8Array, Bt = gn, Dd = Bt;
function Hn(m) {
  var l = new m.constructor(m.byteLength);
  return new Dd(l).set(new Dd(m)), l;
}
var Rd = Hn, Mn = Rd;
function zn(m, l) {
  var i = l ? Mn(m.buffer) : m.buffer;
  return new m.constructor(i, m.byteOffset, m.byteLength);
}
var kn = zn, vn = /\w*$/;
function Un(m) {
  var l = new m.constructor(m.source, vn.exec(m));
  return l.lastIndex = m.lastIndex, l;
}
var fn = Un, Ad = $l, qd = Ad ? Ad.prototype : void 0, $d = qd ? qd.valueOf : void 0;
function Qn(m) {
  return $d ? Object($d.call(m)) : {};
}
var Pn = Qn, wn = Rd;
function En(m, l) {
  var i = l ? wn(m.buffer) : m.buffer;
  return new m.constructor(i, m.byteOffset, m.length);
}
var jn = En, Bn = Rd, On = kn, Dn = fn, An = Pn, qn = jn, $n = "[object Boolean]", _n = "[object Date]", ie = "[object Map]", le = "[object Number]", de = "[object RegExp]", te = "[object Set]", se = "[object String]", be = "[object Symbol]", ce = "[object ArrayBuffer]", me = "[object DataView]", Ze = "[object Float32Array]", ne = "[object Float64Array]", ee = "[object Int8Array]", Xe = "[object Int16Array]", oe = "[object Int32Array]", ae = "[object Uint8Array]", We = "[object Uint8ClampedArray]", ue = "[object Uint16Array]", Ge = "[object Uint32Array]";
function Ve(m, l, i) {
  var d = m.constructor;
  switch (l) {
    case ce:
      return Bn(m);
    case $n:
    case _n:
      return new d(+m);
    case me:
      return On(m, i);
    case Ze:
    case ne:
    case ee:
    case Xe:
    case oe:
    case ae:
    case We:
    case ue:
    case Ge:
      return qn(m, i);
    case ie:
      return new d();
    case le:
    case se:
      return new d(m);
    case de:
      return Dn(m);
    case te:
      return new d();
    case be:
      return An(m);
  }
}
var he = Ve, Ie = Il, _d = Object.create, pe = /* @__PURE__ */ function() {
  function m() {
  }
  return function(l) {
    if (!Ie(l))
      return {};
    if (_d)
      return _d(l);
    m.prototype = l;
    var i = new m();
    return m.prototype = void 0, i;
  };
}(), ye = pe, Le = ye, re = Qt, Ye = rd;
function xe(m) {
  return typeof m.constructor == "function" && !Ye(m) ? Le(re(m)) : {};
}
var Se = xe, Re = td, Ke = pl, Ce = "[object Map]";
function Je(m) {
  return Ke(m) && Re(m) == Ce;
}
var Fe = Je, Te = Fe, Ne = yd, it = Ld, lt = it && it.isMap, ge = lt ? Ne(lt) : Te, He = ge, Me = td, ze = pl, ke = "[object Set]";
function ve(m) {
  return ze(m) && Me(m) == ke;
}
var Ue = ve, fe = Ue, Qe = yd, dt = Ld, tt = dt && dt.isSet, Pe = tt ? Qe(tt) : fe, we = Pe, Ee = Ft, je = Xm, Be = Nt, Oe = d0, De = I0, Ae = p0, qe = L0, $e = g0, _e = B0, iX = Et, lX = cn, dX = td, tX = Tn, sX = he, bX = Se, cX = dd, mX = pd, ZX = He, nX = Il, eX = we, XX = Yd, oX = xd, aX = 1, WX = 2, uX = 4, Ot = "[object Arguments]", GX = "[object Array]", VX = "[object Boolean]", hX = "[object Date]", IX = "[object Error]", Dt = "[object Function]", pX = "[object GeneratorFunction]", yX = "[object Map]", LX = "[object Number]", At = "[object Object]", rX = "[object RegExp]", YX = "[object Set]", xX = "[object String]", SX = "[object Symbol]", RX = "[object WeakMap]", KX = "[object ArrayBuffer]", CX = "[object DataView]", JX = "[object Float32Array]", FX = "[object Float64Array]", TX = "[object Int8Array]", NX = "[object Int16Array]", gX = "[object Int32Array]", HX = "[object Uint8Array]", MX = "[object Uint8ClampedArray]", zX = "[object Uint16Array]", kX = "[object Uint32Array]", Mi = {};
Mi[Ot] = Mi[GX] = Mi[KX] = Mi[CX] = Mi[VX] = Mi[hX] = Mi[JX] = Mi[FX] = Mi[TX] = Mi[NX] = Mi[gX] = Mi[yX] = Mi[LX] = Mi[At] = Mi[rX] = Mi[YX] = Mi[xX] = Mi[SX] = Mi[HX] = Mi[MX] = Mi[zX] = Mi[kX] = !0;
Mi[IX] = Mi[Dt] = Mi[RX] = !1;
function wl(m, l, i, d, s, X) {
  var a, e = l & aX, n = l & WX, G = l & uX;
  if (i && (a = s ? i(m, d, s, X) : i(m)), a !== void 0)
    return a;
  if (!nX(m))
    return m;
  var y = cX(m);
  if (y) {
    if (a = tX(m), !e)
      return qe(m, a);
  } else {
    var o = dX(m), h = o == Dt || o == pX;
    if (mX(m))
      return Ae(m, e);
    if (o == At || o == Ot || h && !s) {
      if (a = n || h ? {} : bX(m), !e)
        return n ? _e(m, De(a, m)) : $e(m, Oe(a, m));
    } else {
      if (!Mi[o])
        return s ? m : {};
      a = sX(m, o, e);
    }
  }
  X || (X = new Ee());
  var I = X.get(m);
  if (I)
    return I;
  X.set(m, a), eX(m) ? m.forEach(function(W) {
    a.add(wl(W, l, i, W, m, X));
  }) : ZX(m) && m.forEach(function(W, V) {
    a.set(V, wl(W, l, i, V, m, X));
  });
  var x = G ? n ? lX : iX : n ? oX : XX, p = y ? void 0 : x(m);
  return je(p || m, function(W, V) {
    p && (V = W, W = m[V]), Be(a, V, wl(W, l, i, V, m, X));
  }), a;
}
var vX = wl, UX = vX, fX = 1, QX = 4;
function PX(m) {
  return UX(m, fX | QX);
}
var wX = PX;
const tl = /* @__PURE__ */ Dl(wX);
class qt {
  setNamespace(l) {
    this.namespace = l, this.serviceStorage = this.getNamespaceData(l), this.storage = tl(this.serviceStorage);
  }
  getNamespaceData(l) {
    var i;
    return vl((i = this.plugin) == null ? void 0 : i.attributes[l || this.namespace]) || {};
  }
  getUidFromKey(l) {
    return l.split(Gl).length === 2 && l.split(Gl)[0] || this.uid;
  }
  isLocalId(l) {
    return l.split(Gl).length === 1;
  }
  getLocalId(l) {
    return l.split(Gl)[1];
  }
  hasSelector() {
    return !!(this.storage && Object.keys(this.storage).find((l) => this.isOwn(l) && this.getLocalId(l) === Ci));
  }
  isSelector(l) {
    return this.getLocalId(l) === Ci;
  }
}
function $t(m) {
  return JSON.parse(os(m));
}
function _t(m) {
  return as(JSON.stringify(m));
}
const Ml = Object.keys;
var EX = "__lodash_hash_undefined__";
function jX(m) {
  return this.__data__.set(m, EX), this;
}
var BX = jX;
function OX(m) {
  return this.__data__.has(m);
}
var DX = OX, AX = Jt, qX = BX, $X = DX;
function Ol(m) {
  var l = -1, i = m == null ? 0 : m.length;
  for (this.__data__ = new AX(); ++l < i; )
    this.add(m[l]);
}
Ol.prototype.add = Ol.prototype.push = qX;
Ol.prototype.has = $X;
var _X = Ol;
function io(m, l) {
  for (var i = -1, d = m == null ? 0 : m.length; ++i < d; )
    if (l(m[i], i, m))
      return !0;
  return !1;
}
var lo = io;
function to(m, l) {
  return m.has(l);
}
var so = to, bo = _X, co = lo, mo = so, Zo = 1, no = 2;
function eo(m, l, i, d, s, X) {
  var a = i & Zo, e = m.length, n = l.length;
  if (e != n && !(a && n > e))
    return !1;
  var G = X.get(m), y = X.get(l);
  if (G && y)
    return G == l && y == m;
  var o = -1, h = !0, I = i & no ? new bo() : void 0;
  for (X.set(m, l), X.set(l, m); ++o < e; ) {
    var x = m[o], p = l[o];
    if (d)
      var W = a ? d(p, x, o, l, m, X) : d(x, p, o, m, l, X);
    if (W !== void 0) {
      if (W)
        continue;
      h = !1;
      break;
    }
    if (I) {
      if (!co(l, function(V, t) {
        if (!mo(I, t) && (x === V || s(x, V, i, d, X)))
          return I.push(t);
      })) {
        h = !1;
        break;
      }
    } else if (!(x === p || s(x, p, i, d, X))) {
      h = !1;
      break;
    }
  }
  return X.delete(m), X.delete(l), h;
}
var is = eo;
function Xo(m) {
  var l = -1, i = Array(m.size);
  return m.forEach(function(d, s) {
    i[++l] = [s, d];
  }), i;
}
var oo = Xo;
function ao(m) {
  var l = -1, i = Array(m.size);
  return m.forEach(function(d) {
    i[++l] = d;
  }), i;
}
var Wo = ao, st = $l, bt = Bt, uo = hd, Go = is, Vo = oo, ho = Wo, Io = 1, po = 2, yo = "[object Boolean]", Lo = "[object Date]", ro = "[object Error]", Yo = "[object Map]", xo = "[object Number]", So = "[object RegExp]", Ro = "[object Set]", Ko = "[object String]", Co = "[object Symbol]", Jo = "[object ArrayBuffer]", Fo = "[object DataView]", ct = st ? st.prototype : void 0, md = ct ? ct.valueOf : void 0;
function To(m, l, i, d, s, X, a) {
  switch (i) {
    case Fo:
      if (m.byteLength != l.byteLength || m.byteOffset != l.byteOffset)
        return !1;
      m = m.buffer, l = l.buffer;
    case Jo:
      return !(m.byteLength != l.byteLength || !X(new bt(m), new bt(l)));
    case yo:
    case Lo:
    case xo:
      return uo(+m, +l);
    case ro:
      return m.name == l.name && m.message == l.message;
    case So:
    case Ko:
      return m == l + "";
    case Yo:
      var e = Vo;
    case Ro:
      var n = d & Io;
      if (e || (e = ho), m.size != l.size && !n)
        return !1;
      var G = a.get(m);
      if (G)
        return G == l;
      d |= po, a.set(m, l);
      var y = Go(e(m), e(l), d, s, X, a);
      return a.delete(m), y;
    case Co:
      if (md)
        return md.call(m) == md.call(l);
  }
  return !1;
}
var No = To, mt = Et, go = 1, Ho = Object.prototype, Mo = Ho.hasOwnProperty;
function zo(m, l, i, d, s, X) {
  var a = i & go, e = mt(m), n = e.length, G = mt(l), y = G.length;
  if (n != y && !a)
    return !1;
  for (var o = n; o--; ) {
    var h = e[o];
    if (!(a ? h in l : Mo.call(l, h)))
      return !1;
  }
  var I = X.get(m), x = X.get(l);
  if (I && x)
    return I == l && x == m;
  var p = !0;
  X.set(m, l), X.set(l, m);
  for (var W = a; ++o < n; ) {
    h = e[o];
    var V = m[h], t = l[h];
    if (d)
      var c = a ? d(t, V, h, l, m, X) : d(V, t, h, m, l, X);
    if (!(c === void 0 ? V === t || s(V, t, i, d, X) : c)) {
      p = !1;
      break;
    }
    W || (W = h == "constructor");
  }
  if (p && !W) {
    var b = m.constructor, Z = l.constructor;
    b != Z && "constructor" in m && "constructor" in l && !(typeof b == "function" && b instanceof b && typeof Z == "function" && Z instanceof Z) && (p = !1);
  }
  return X.delete(m), X.delete(l), p;
}
var ko = zo, Zd = Ft, vo = is, Uo = No, fo = ko, Zt = td, nt = dd, et = pd, Qo = Mt, Po = 1, Xt = "[object Arguments]", ot = "[object Array]", Pl = "[object Object]", wo = Object.prototype, at = wo.hasOwnProperty;
function Eo(m, l, i, d, s, X) {
  var a = nt(m), e = nt(l), n = a ? ot : Zt(m), G = e ? ot : Zt(l);
  n = n == Xt ? Pl : n, G = G == Xt ? Pl : G;
  var y = n == Pl, o = G == Pl, h = n == G;
  if (h && et(m)) {
    if (!et(l))
      return !1;
    a = !0, y = !1;
  }
  if (h && !y)
    return X || (X = new Zd()), a || Qo(m) ? vo(m, l, i, d, s, X) : Uo(m, l, n, i, d, s, X);
  if (!(i & Po)) {
    var I = y && at.call(m, "__wrapped__"), x = o && at.call(l, "__wrapped__");
    if (I || x) {
      var p = I ? m.value() : m, W = x ? l.value() : l;
      return X || (X = new Zd()), s(p, W, i, d, X);
    }
  }
  return h ? (X || (X = new Zd()), fo(m, l, i, d, s, X)) : !1;
}
var jo = Eo, Bo = jo, Wt = pl;
function ls(m, l, i, d, s) {
  return m === l ? !0 : m == null || l == null || !Wt(m) && !Wt(l) ? m !== m && l !== l : Bo(m, l, i, d, ls, s);
}
var Oo = ls, Do = Oo;
function Ao(m, l) {
  return Do(m, l);
}
var qo = Ao;
const fl = /* @__PURE__ */ Dl(qo);
class $o {
  constructor(l, i) {
    Object.defineProperty(this, "syncUnitTime", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 1e3
    }), Object.defineProperty(this, "drawLayer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "fullLayer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "workId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.fullLayer = l, this.drawLayer = i;
  }
  setWorkId(l) {
    this.workId = l;
  }
  getWorkId() {
    return this.workId;
  }
  getWorkOptions() {
    return this.workOptions;
  }
  setWorkOptions(l) {
    this.workOptions = l, this.syncUnitTime = l.syncUnitTime || this.syncUnitTime;
  }
}
var Hi = (
  /******/
  function(m) {
    var l = {};
    function i(d) {
      if (l[d])
        return l[d].exports;
      var s = l[d] = {
        /******/
        i: d,
        /******/
        l: !1,
        /******/
        exports: {}
        /******/
      };
      return m[d].call(s.exports, s, s.exports, i), s.l = !0, s.exports;
    }
    return i.m = m, i.c = l, i.d = function(d, s, X) {
      i.o(d, s) || Object.defineProperty(d, s, { enumerable: !0, get: X });
    }, i.r = function(d) {
      typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(d, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(d, "__esModule", { value: !0 });
    }, i.t = function(d, s) {
      if (s & 1 && (d = i(d)), s & 8 || s & 4 && typeof d == "object" && d && d.__esModule)
        return d;
      var X = /* @__PURE__ */ Object.create(null);
      if (i.r(X), Object.defineProperty(X, "default", { enumerable: !0, value: d }), s & 2 && typeof d != "string")
        for (var a in d)
          i.d(X, a, (function(e) {
            return d[e];
          }).bind(null, a));
      return X;
    }, i.n = function(d) {
      var s = d && d.__esModule ? (
        /******/
        function() {
          return d.default;
        }
      ) : (
        /******/
        function() {
          return d;
        }
      );
      return i.d(s, "a", s), s;
    }, i.o = function(d, s) {
      return Object.prototype.hasOwnProperty.call(d, s);
    }, i.p = "/js/", i(i.s = 0);
  }([
    /* 0 */
    /***/
    function(m, l, i) {
      i.r(l), i.d(l, "version", function() {
        return w;
      }), i.d(l, "helpers", function() {
        return H;
      }), i.d(l, "createElement", function() {
        return T;
      }), i.d(l, "isSpriteNode", function() {
        return K;
      }), i.d(l, "registerNode", function() {
        return R;
      });
      var d = i(12);
      i.d(l, "ENV", function() {
        return d.ENV;
      });
      var s = i(68);
      i.d(l, "requestAnimationFrame", function() {
        return s.requestAnimationFrame;
      }), i.d(l, "cancelAnimationFrame", function() {
        return s.cancelAnimationFrame;
      });
      var X = i(70);
      i.d(l, "Node", function() {
        return X.default;
      });
      var a = i(217);
      i.d(l, "Cloud", function() {
        return a.default;
      });
      var e = i(219);
      i.d(l, "Block", function() {
        return e.default;
      });
      var n = i(224);
      i.d(l, "Sprite", function() {
        return n.default;
      });
      var G = i(226);
      i.d(l, "Path", function() {
        return G.default;
      });
      var y = i(229);
      i.d(l, "Rect", function() {
        return y.default;
      });
      var o = i(231);
      i.d(l, "Triangle", function() {
        return o.default;
      });
      var h = i(236);
      i.d(l, "Parallel", function() {
        return h.default;
      });
      var I = i(238);
      i.d(l, "Regular", function() {
        return I.default;
      });
      var x = i(240);
      i.d(l, "Star", function() {
        return x.default;
      });
      var p = i(242);
      i.d(l, "Ellipse", function() {
        return p.default;
      });
      var W = i(244);
      i.d(l, "Arc", function() {
        return W.default;
      });
      var V = i(246);
      i.d(l, "Ring", function() {
        return V.default;
      });
      var t = i(232);
      i.d(l, "Polyline", function() {
        return t.default;
      });
      var c = i(248);
      i.d(l, "Label", function() {
        return c.default;
      });
      var b = i(250);
      i.d(l, "Group", function() {
        return b.default;
      });
      var Z = i(286);
      i.d(l, "Layer", function() {
        return Z.default;
      });
      var r = i(287);
      i.d(l, "SpriteSvg", function() {
        return r.default;
      });
      var S = i(289);
      i.d(l, "LayerWorker", function() {
        return S.default;
      });
      var C = i(290);
      i.d(l, "Scene", function() {
        return C.default;
      });
      var F = i(213), Y = i(221);
      i.d(l, "Color", function() {
        return Y.Color;
      }), i.d(l, "Gradient", function() {
        return Y.Gradient;
      });
      var J = i(72);
      i(1).glMatrix.setMatrixArrayType(Array);
      const T = F.default.createElement, K = F.default.isSpriteNode, R = F.default.registerNode, H = {
        parseColor: Y.parseColor,
        sizeToPixel: J.sizeToPixel,
        toArray: J.toArray,
        toString: J.toString,
        toNumber: J.toNumber
      };
      let f;
      f = "3.8.3";
      const w = f;
    },
    /* 1 */
    /***/
    function(m, l, i) {
      i.r(l);
      var d = i(2);
      i.d(l, "glMatrix", function() {
        return d;
      });
      var s = i(3);
      i.d(l, "mat2", function() {
        return s;
      });
      var X = i(4);
      i.d(l, "mat2d", function() {
        return X;
      });
      var a = i(5);
      i.d(l, "mat3", function() {
        return a;
      });
      var e = i(6);
      i.d(l, "mat4", function() {
        return e;
      });
      var n = i(7);
      i.d(l, "quat", function() {
        return n;
      });
      var G = i(10);
      i.d(l, "quat2", function() {
        return G;
      });
      var y = i(11);
      i.d(l, "vec2", function() {
        return y;
      });
      var o = i(8);
      i.d(l, "vec3", function() {
        return o;
      });
      var h = i(9);
      i.d(l, "vec4", function() {
        return h;
      });
    },
    /* 2 */
    /***/
    function(m, l, i) {
      i.r(l), i.d(l, "EPSILON", function() {
        return d;
      }), i.d(l, "ARRAY_TYPE", function() {
        return s;
      }), i.d(l, "RANDOM", function() {
        return X;
      }), i.d(l, "setMatrixArrayType", function() {
        return a;
      }), i.d(l, "toRadian", function() {
        return n;
      }), i.d(l, "equals", function() {
        return G;
      });
      var d = 1e-6, s = typeof Float32Array < "u" ? Float32Array : Array, X = Math.random;
      function a(y) {
        s = y;
      }
      var e = Math.PI / 180;
      function n(y) {
        return y * e;
      }
      function G(y, o) {
        return Math.abs(y - o) <= d * Math.max(1, Math.abs(y), Math.abs(o));
      }
      Math.hypot || (Math.hypot = function() {
        for (var y = 0, o = arguments.length; o--; )
          y += arguments[o] * arguments[o];
        return Math.sqrt(y);
      });
    },
    /* 3 */
    /***/
    function(m, l, i) {
      i.r(l), i.d(l, "create", function() {
        return s;
      }), i.d(l, "clone", function() {
        return X;
      }), i.d(l, "copy", function() {
        return a;
      }), i.d(l, "identity", function() {
        return e;
      }), i.d(l, "fromValues", function() {
        return n;
      }), i.d(l, "set", function() {
        return G;
      }), i.d(l, "transpose", function() {
        return y;
      }), i.d(l, "invert", function() {
        return o;
      }), i.d(l, "adjoint", function() {
        return h;
      }), i.d(l, "determinant", function() {
        return I;
      }), i.d(l, "multiply", function() {
        return x;
      }), i.d(l, "rotate", function() {
        return p;
      }), i.d(l, "scale", function() {
        return W;
      }), i.d(l, "fromRotation", function() {
        return V;
      }), i.d(l, "fromScaling", function() {
        return t;
      }), i.d(l, "str", function() {
        return c;
      }), i.d(l, "frob", function() {
        return b;
      }), i.d(l, "LDU", function() {
        return Z;
      }), i.d(l, "add", function() {
        return r;
      }), i.d(l, "subtract", function() {
        return S;
      }), i.d(l, "exactEquals", function() {
        return C;
      }), i.d(l, "equals", function() {
        return F;
      }), i.d(l, "multiplyScalar", function() {
        return Y;
      }), i.d(l, "multiplyScalarAndAdd", function() {
        return J;
      }), i.d(l, "mul", function() {
        return T;
      }), i.d(l, "sub", function() {
        return K;
      });
      var d = i(2);
      function s() {
        var R = new d.ARRAY_TYPE(4);
        return d.ARRAY_TYPE != Float32Array && (R[1] = 0, R[2] = 0), R[0] = 1, R[3] = 1, R;
      }
      function X(R) {
        var H = new d.ARRAY_TYPE(4);
        return H[0] = R[0], H[1] = R[1], H[2] = R[2], H[3] = R[3], H;
      }
      function a(R, H) {
        return R[0] = H[0], R[1] = H[1], R[2] = H[2], R[3] = H[3], R;
      }
      function e(R) {
        return R[0] = 1, R[1] = 0, R[2] = 0, R[3] = 1, R;
      }
      function n(R, H, f, w) {
        var O = new d.ARRAY_TYPE(4);
        return O[0] = R, O[1] = H, O[2] = f, O[3] = w, O;
      }
      function G(R, H, f, w, O) {
        return R[0] = H, R[1] = f, R[2] = w, R[3] = O, R;
      }
      function y(R, H) {
        if (R === H) {
          var f = H[1];
          R[1] = H[2], R[2] = f;
        } else
          R[0] = H[0], R[1] = H[2], R[2] = H[1], R[3] = H[3];
        return R;
      }
      function o(R, H) {
        var f = H[0], w = H[1], O = H[2], q = H[3], k = f * q - O * w;
        return k ? (k = 1 / k, R[0] = q * k, R[1] = -w * k, R[2] = -O * k, R[3] = f * k, R) : null;
      }
      function h(R, H) {
        var f = H[0];
        return R[0] = H[3], R[1] = -H[1], R[2] = -H[2], R[3] = f, R;
      }
      function I(R) {
        return R[0] * R[3] - R[2] * R[1];
      }
      function x(R, H, f) {
        var w = H[0], O = H[1], q = H[2], k = H[3], Q = f[0], D = f[1], ii = f[2], _ = f[3];
        return R[0] = w * Q + q * D, R[1] = O * Q + k * D, R[2] = w * ii + q * _, R[3] = O * ii + k * _, R;
      }
      function p(R, H, f) {
        var w = H[0], O = H[1], q = H[2], k = H[3], Q = Math.sin(f), D = Math.cos(f);
        return R[0] = w * D + q * Q, R[1] = O * D + k * Q, R[2] = w * -Q + q * D, R[3] = O * -Q + k * D, R;
      }
      function W(R, H, f) {
        var w = H[0], O = H[1], q = H[2], k = H[3], Q = f[0], D = f[1];
        return R[0] = w * Q, R[1] = O * Q, R[2] = q * D, R[3] = k * D, R;
      }
      function V(R, H) {
        var f = Math.sin(H), w = Math.cos(H);
        return R[0] = w, R[1] = f, R[2] = -f, R[3] = w, R;
      }
      function t(R, H) {
        return R[0] = H[0], R[1] = 0, R[2] = 0, R[3] = H[1], R;
      }
      function c(R) {
        return "mat2(" + R[0] + ", " + R[1] + ", " + R[2] + ", " + R[3] + ")";
      }
      function b(R) {
        return Math.hypot(R[0], R[1], R[2], R[3]);
      }
      function Z(R, H, f, w) {
        return R[2] = w[2] / w[0], f[0] = w[0], f[1] = w[1], f[3] = w[3] - R[2] * f[1], [R, H, f];
      }
      function r(R, H, f) {
        return R[0] = H[0] + f[0], R[1] = H[1] + f[1], R[2] = H[2] + f[2], R[3] = H[3] + f[3], R;
      }
      function S(R, H, f) {
        return R[0] = H[0] - f[0], R[1] = H[1] - f[1], R[2] = H[2] - f[2], R[3] = H[3] - f[3], R;
      }
      function C(R, H) {
        return R[0] === H[0] && R[1] === H[1] && R[2] === H[2] && R[3] === H[3];
      }
      function F(R, H) {
        var f = R[0], w = R[1], O = R[2], q = R[3], k = H[0], Q = H[1], D = H[2], ii = H[3];
        return Math.abs(f - k) <= d.EPSILON * Math.max(1, Math.abs(f), Math.abs(k)) && Math.abs(w - Q) <= d.EPSILON * Math.max(1, Math.abs(w), Math.abs(Q)) && Math.abs(O - D) <= d.EPSILON * Math.max(1, Math.abs(O), Math.abs(D)) && Math.abs(q - ii) <= d.EPSILON * Math.max(1, Math.abs(q), Math.abs(ii));
      }
      function Y(R, H, f) {
        return R[0] = H[0] * f, R[1] = H[1] * f, R[2] = H[2] * f, R[3] = H[3] * f, R;
      }
      function J(R, H, f, w) {
        return R[0] = H[0] + f[0] * w, R[1] = H[1] + f[1] * w, R[2] = H[2] + f[2] * w, R[3] = H[3] + f[3] * w, R;
      }
      var T = x, K = S;
    },
    /* 4 */
    /***/
    function(m, l, i) {
      i.r(l), i.d(l, "create", function() {
        return s;
      }), i.d(l, "clone", function() {
        return X;
      }), i.d(l, "copy", function() {
        return a;
      }), i.d(l, "identity", function() {
        return e;
      }), i.d(l, "fromValues", function() {
        return n;
      }), i.d(l, "set", function() {
        return G;
      }), i.d(l, "invert", function() {
        return y;
      }), i.d(l, "determinant", function() {
        return o;
      }), i.d(l, "multiply", function() {
        return h;
      }), i.d(l, "rotate", function() {
        return I;
      }), i.d(l, "scale", function() {
        return x;
      }), i.d(l, "translate", function() {
        return p;
      }), i.d(l, "fromRotation", function() {
        return W;
      }), i.d(l, "fromScaling", function() {
        return V;
      }), i.d(l, "fromTranslation", function() {
        return t;
      }), i.d(l, "str", function() {
        return c;
      }), i.d(l, "frob", function() {
        return b;
      }), i.d(l, "add", function() {
        return Z;
      }), i.d(l, "subtract", function() {
        return r;
      }), i.d(l, "multiplyScalar", function() {
        return S;
      }), i.d(l, "multiplyScalarAndAdd", function() {
        return C;
      }), i.d(l, "exactEquals", function() {
        return F;
      }), i.d(l, "equals", function() {
        return Y;
      }), i.d(l, "mul", function() {
        return J;
      }), i.d(l, "sub", function() {
        return T;
      });
      var d = i(2);
      function s() {
        var K = new d.ARRAY_TYPE(6);
        return d.ARRAY_TYPE != Float32Array && (K[1] = 0, K[2] = 0, K[4] = 0, K[5] = 0), K[0] = 1, K[3] = 1, K;
      }
      function X(K) {
        var R = new d.ARRAY_TYPE(6);
        return R[0] = K[0], R[1] = K[1], R[2] = K[2], R[3] = K[3], R[4] = K[4], R[5] = K[5], R;
      }
      function a(K, R) {
        return K[0] = R[0], K[1] = R[1], K[2] = R[2], K[3] = R[3], K[4] = R[4], K[5] = R[5], K;
      }
      function e(K) {
        return K[0] = 1, K[1] = 0, K[2] = 0, K[3] = 1, K[4] = 0, K[5] = 0, K;
      }
      function n(K, R, H, f, w, O) {
        var q = new d.ARRAY_TYPE(6);
        return q[0] = K, q[1] = R, q[2] = H, q[3] = f, q[4] = w, q[5] = O, q;
      }
      function G(K, R, H, f, w, O, q) {
        return K[0] = R, K[1] = H, K[2] = f, K[3] = w, K[4] = O, K[5] = q, K;
      }
      function y(K, R) {
        var H = R[0], f = R[1], w = R[2], O = R[3], q = R[4], k = R[5], Q = H * O - f * w;
        return Q ? (Q = 1 / Q, K[0] = O * Q, K[1] = -f * Q, K[2] = -w * Q, K[3] = H * Q, K[4] = (w * k - O * q) * Q, K[5] = (f * q - H * k) * Q, K) : null;
      }
      function o(K) {
        return K[0] * K[3] - K[1] * K[2];
      }
      function h(K, R, H) {
        var f = R[0], w = R[1], O = R[2], q = R[3], k = R[4], Q = R[5], D = H[0], ii = H[1], _ = H[2], bi = H[3], $ = H[4], Xi = H[5];
        return K[0] = f * D + O * ii, K[1] = w * D + q * ii, K[2] = f * _ + O * bi, K[3] = w * _ + q * bi, K[4] = f * $ + O * Xi + k, K[5] = w * $ + q * Xi + Q, K;
      }
      function I(K, R, H) {
        var f = R[0], w = R[1], O = R[2], q = R[3], k = R[4], Q = R[5], D = Math.sin(H), ii = Math.cos(H);
        return K[0] = f * ii + O * D, K[1] = w * ii + q * D, K[2] = f * -D + O * ii, K[3] = w * -D + q * ii, K[4] = k, K[5] = Q, K;
      }
      function x(K, R, H) {
        var f = R[0], w = R[1], O = R[2], q = R[3], k = R[4], Q = R[5], D = H[0], ii = H[1];
        return K[0] = f * D, K[1] = w * D, K[2] = O * ii, K[3] = q * ii, K[4] = k, K[5] = Q, K;
      }
      function p(K, R, H) {
        var f = R[0], w = R[1], O = R[2], q = R[3], k = R[4], Q = R[5], D = H[0], ii = H[1];
        return K[0] = f, K[1] = w, K[2] = O, K[3] = q, K[4] = f * D + O * ii + k, K[5] = w * D + q * ii + Q, K;
      }
      function W(K, R) {
        var H = Math.sin(R), f = Math.cos(R);
        return K[0] = f, K[1] = H, K[2] = -H, K[3] = f, K[4] = 0, K[5] = 0, K;
      }
      function V(K, R) {
        return K[0] = R[0], K[1] = 0, K[2] = 0, K[3] = R[1], K[4] = 0, K[5] = 0, K;
      }
      function t(K, R) {
        return K[0] = 1, K[1] = 0, K[2] = 0, K[3] = 1, K[4] = R[0], K[5] = R[1], K;
      }
      function c(K) {
        return "mat2d(" + K[0] + ", " + K[1] + ", " + K[2] + ", " + K[3] + ", " + K[4] + ", " + K[5] + ")";
      }
      function b(K) {
        return Math.hypot(K[0], K[1], K[2], K[3], K[4], K[5], 1);
      }
      function Z(K, R, H) {
        return K[0] = R[0] + H[0], K[1] = R[1] + H[1], K[2] = R[2] + H[2], K[3] = R[3] + H[3], K[4] = R[4] + H[4], K[5] = R[5] + H[5], K;
      }
      function r(K, R, H) {
        return K[0] = R[0] - H[0], K[1] = R[1] - H[1], K[2] = R[2] - H[2], K[3] = R[3] - H[3], K[4] = R[4] - H[4], K[5] = R[5] - H[5], K;
      }
      function S(K, R, H) {
        return K[0] = R[0] * H, K[1] = R[1] * H, K[2] = R[2] * H, K[3] = R[3] * H, K[4] = R[4] * H, K[5] = R[5] * H, K;
      }
      function C(K, R, H, f) {
        return K[0] = R[0] + H[0] * f, K[1] = R[1] + H[1] * f, K[2] = R[2] + H[2] * f, K[3] = R[3] + H[3] * f, K[4] = R[4] + H[4] * f, K[5] = R[5] + H[5] * f, K;
      }
      function F(K, R) {
        return K[0] === R[0] && K[1] === R[1] && K[2] === R[2] && K[3] === R[3] && K[4] === R[4] && K[5] === R[5];
      }
      function Y(K, R) {
        var H = K[0], f = K[1], w = K[2], O = K[3], q = K[4], k = K[5], Q = R[0], D = R[1], ii = R[2], _ = R[3], bi = R[4], $ = R[5];
        return Math.abs(H - Q) <= d.EPSILON * Math.max(1, Math.abs(H), Math.abs(Q)) && Math.abs(f - D) <= d.EPSILON * Math.max(1, Math.abs(f), Math.abs(D)) && Math.abs(w - ii) <= d.EPSILON * Math.max(1, Math.abs(w), Math.abs(ii)) && Math.abs(O - _) <= d.EPSILON * Math.max(1, Math.abs(O), Math.abs(_)) && Math.abs(q - bi) <= d.EPSILON * Math.max(1, Math.abs(q), Math.abs(bi)) && Math.abs(k - $) <= d.EPSILON * Math.max(1, Math.abs(k), Math.abs($));
      }
      var J = h, T = r;
    },
    /* 5 */
    /***/
    function(m, l, i) {
      i.r(l), i.d(l, "create", function() {
        return s;
      }), i.d(l, "fromMat4", function() {
        return X;
      }), i.d(l, "clone", function() {
        return a;
      }), i.d(l, "copy", function() {
        return e;
      }), i.d(l, "fromValues", function() {
        return n;
      }), i.d(l, "set", function() {
        return G;
      }), i.d(l, "identity", function() {
        return y;
      }), i.d(l, "transpose", function() {
        return o;
      }), i.d(l, "invert", function() {
        return h;
      }), i.d(l, "adjoint", function() {
        return I;
      }), i.d(l, "determinant", function() {
        return x;
      }), i.d(l, "multiply", function() {
        return p;
      }), i.d(l, "translate", function() {
        return W;
      }), i.d(l, "rotate", function() {
        return V;
      }), i.d(l, "scale", function() {
        return t;
      }), i.d(l, "fromTranslation", function() {
        return c;
      }), i.d(l, "fromRotation", function() {
        return b;
      }), i.d(l, "fromScaling", function() {
        return Z;
      }), i.d(l, "fromMat2d", function() {
        return r;
      }), i.d(l, "fromQuat", function() {
        return S;
      }), i.d(l, "normalFromMat4", function() {
        return C;
      }), i.d(l, "projection", function() {
        return F;
      }), i.d(l, "str", function() {
        return Y;
      }), i.d(l, "frob", function() {
        return J;
      }), i.d(l, "add", function() {
        return T;
      }), i.d(l, "subtract", function() {
        return K;
      }), i.d(l, "multiplyScalar", function() {
        return R;
      }), i.d(l, "multiplyScalarAndAdd", function() {
        return H;
      }), i.d(l, "exactEquals", function() {
        return f;
      }), i.d(l, "equals", function() {
        return w;
      }), i.d(l, "mul", function() {
        return O;
      }), i.d(l, "sub", function() {
        return q;
      });
      var d = i(2);
      function s() {
        var k = new d.ARRAY_TYPE(9);
        return d.ARRAY_TYPE != Float32Array && (k[1] = 0, k[2] = 0, k[3] = 0, k[5] = 0, k[6] = 0, k[7] = 0), k[0] = 1, k[4] = 1, k[8] = 1, k;
      }
      function X(k, Q) {
        return k[0] = Q[0], k[1] = Q[1], k[2] = Q[2], k[3] = Q[4], k[4] = Q[5], k[5] = Q[6], k[6] = Q[8], k[7] = Q[9], k[8] = Q[10], k;
      }
      function a(k) {
        var Q = new d.ARRAY_TYPE(9);
        return Q[0] = k[0], Q[1] = k[1], Q[2] = k[2], Q[3] = k[3], Q[4] = k[4], Q[5] = k[5], Q[6] = k[6], Q[7] = k[7], Q[8] = k[8], Q;
      }
      function e(k, Q) {
        return k[0] = Q[0], k[1] = Q[1], k[2] = Q[2], k[3] = Q[3], k[4] = Q[4], k[5] = Q[5], k[6] = Q[6], k[7] = Q[7], k[8] = Q[8], k;
      }
      function n(k, Q, D, ii, _, bi, $, Xi, ni) {
        var M = new d.ARRAY_TYPE(9);
        return M[0] = k, M[1] = Q, M[2] = D, M[3] = ii, M[4] = _, M[5] = bi, M[6] = $, M[7] = Xi, M[8] = ni, M;
      }
      function G(k, Q, D, ii, _, bi, $, Xi, ni, M) {
        return k[0] = Q, k[1] = D, k[2] = ii, k[3] = _, k[4] = bi, k[5] = $, k[6] = Xi, k[7] = ni, k[8] = M, k;
      }
      function y(k) {
        return k[0] = 1, k[1] = 0, k[2] = 0, k[3] = 0, k[4] = 1, k[5] = 0, k[6] = 0, k[7] = 0, k[8] = 1, k;
      }
      function o(k, Q) {
        if (k === Q) {
          var D = Q[1], ii = Q[2], _ = Q[5];
          k[1] = Q[3], k[2] = Q[6], k[3] = D, k[5] = Q[7], k[6] = ii, k[7] = _;
        } else
          k[0] = Q[0], k[1] = Q[3], k[2] = Q[6], k[3] = Q[1], k[4] = Q[4], k[5] = Q[7], k[6] = Q[2], k[7] = Q[5], k[8] = Q[8];
        return k;
      }
      function h(k, Q) {
        var D = Q[0], ii = Q[1], _ = Q[2], bi = Q[3], $ = Q[4], Xi = Q[5], ni = Q[6], M = Q[7], z = Q[8], E = z * $ - Xi * M, B = -z * bi + Xi * ni, g = M * bi - $ * ni, U = D * E + ii * B + _ * g;
        return U ? (U = 1 / U, k[0] = E * U, k[1] = (-z * ii + _ * M) * U, k[2] = (Xi * ii - _ * $) * U, k[3] = B * U, k[4] = (z * D - _ * ni) * U, k[5] = (-Xi * D + _ * bi) * U, k[6] = g * U, k[7] = (-M * D + ii * ni) * U, k[8] = ($ * D - ii * bi) * U, k) : null;
      }
      function I(k, Q) {
        var D = Q[0], ii = Q[1], _ = Q[2], bi = Q[3], $ = Q[4], Xi = Q[5], ni = Q[6], M = Q[7], z = Q[8];
        return k[0] = $ * z - Xi * M, k[1] = _ * M - ii * z, k[2] = ii * Xi - _ * $, k[3] = Xi * ni - bi * z, k[4] = D * z - _ * ni, k[5] = _ * bi - D * Xi, k[6] = bi * M - $ * ni, k[7] = ii * ni - D * M, k[8] = D * $ - ii * bi, k;
      }
      function x(k) {
        var Q = k[0], D = k[1], ii = k[2], _ = k[3], bi = k[4], $ = k[5], Xi = k[6], ni = k[7], M = k[8];
        return Q * (M * bi - $ * ni) + D * (-M * _ + $ * Xi) + ii * (ni * _ - bi * Xi);
      }
      function p(k, Q, D) {
        var ii = Q[0], _ = Q[1], bi = Q[2], $ = Q[3], Xi = Q[4], ni = Q[5], M = Q[6], z = Q[7], E = Q[8], B = D[0], g = D[1], U = D[2], u = D[3], L = D[4], N = D[5], v = D[6], P = D[7], j = D[8];
        return k[0] = B * ii + g * $ + U * M, k[1] = B * _ + g * Xi + U * z, k[2] = B * bi + g * ni + U * E, k[3] = u * ii + L * $ + N * M, k[4] = u * _ + L * Xi + N * z, k[5] = u * bi + L * ni + N * E, k[6] = v * ii + P * $ + j * M, k[7] = v * _ + P * Xi + j * z, k[8] = v * bi + P * ni + j * E, k;
      }
      function W(k, Q, D) {
        var ii = Q[0], _ = Q[1], bi = Q[2], $ = Q[3], Xi = Q[4], ni = Q[5], M = Q[6], z = Q[7], E = Q[8], B = D[0], g = D[1];
        return k[0] = ii, k[1] = _, k[2] = bi, k[3] = $, k[4] = Xi, k[5] = ni, k[6] = B * ii + g * $ + M, k[7] = B * _ + g * Xi + z, k[8] = B * bi + g * ni + E, k;
      }
      function V(k, Q, D) {
        var ii = Q[0], _ = Q[1], bi = Q[2], $ = Q[3], Xi = Q[4], ni = Q[5], M = Q[6], z = Q[7], E = Q[8], B = Math.sin(D), g = Math.cos(D);
        return k[0] = g * ii + B * $, k[1] = g * _ + B * Xi, k[2] = g * bi + B * ni, k[3] = g * $ - B * ii, k[4] = g * Xi - B * _, k[5] = g * ni - B * bi, k[6] = M, k[7] = z, k[8] = E, k;
      }
      function t(k, Q, D) {
        var ii = D[0], _ = D[1];
        return k[0] = ii * Q[0], k[1] = ii * Q[1], k[2] = ii * Q[2], k[3] = _ * Q[3], k[4] = _ * Q[4], k[5] = _ * Q[5], k[6] = Q[6], k[7] = Q[7], k[8] = Q[8], k;
      }
      function c(k, Q) {
        return k[0] = 1, k[1] = 0, k[2] = 0, k[3] = 0, k[4] = 1, k[5] = 0, k[6] = Q[0], k[7] = Q[1], k[8] = 1, k;
      }
      function b(k, Q) {
        var D = Math.sin(Q), ii = Math.cos(Q);
        return k[0] = ii, k[1] = D, k[2] = 0, k[3] = -D, k[4] = ii, k[5] = 0, k[6] = 0, k[7] = 0, k[8] = 1, k;
      }
      function Z(k, Q) {
        return k[0] = Q[0], k[1] = 0, k[2] = 0, k[3] = 0, k[4] = Q[1], k[5] = 0, k[6] = 0, k[7] = 0, k[8] = 1, k;
      }
      function r(k, Q) {
        return k[0] = Q[0], k[1] = Q[1], k[2] = 0, k[3] = Q[2], k[4] = Q[3], k[5] = 0, k[6] = Q[4], k[7] = Q[5], k[8] = 1, k;
      }
      function S(k, Q) {
        var D = Q[0], ii = Q[1], _ = Q[2], bi = Q[3], $ = D + D, Xi = ii + ii, ni = _ + _, M = D * $, z = ii * $, E = ii * Xi, B = _ * $, g = _ * Xi, U = _ * ni, u = bi * $, L = bi * Xi, N = bi * ni;
        return k[0] = 1 - E - U, k[3] = z - N, k[6] = B + L, k[1] = z + N, k[4] = 1 - M - U, k[7] = g - u, k[2] = B - L, k[5] = g + u, k[8] = 1 - M - E, k;
      }
      function C(k, Q) {
        var D = Q[0], ii = Q[1], _ = Q[2], bi = Q[3], $ = Q[4], Xi = Q[5], ni = Q[6], M = Q[7], z = Q[8], E = Q[9], B = Q[10], g = Q[11], U = Q[12], u = Q[13], L = Q[14], N = Q[15], v = D * Xi - ii * $, P = D * ni - _ * $, j = D * M - bi * $, A = ii * ni - _ * Xi, li = ii * M - bi * Xi, di = _ * M - bi * ni, ci = z * u - E * U, Zi = z * L - B * U, si = z * N - g * U, ti = E * L - B * u, mi = E * N - g * u, oi = B * N - g * L, ai = v * oi - P * mi + j * ti + A * si - li * Zi + di * ci;
        return ai ? (ai = 1 / ai, k[0] = (Xi * oi - ni * mi + M * ti) * ai, k[1] = (ni * si - $ * oi - M * Zi) * ai, k[2] = ($ * mi - Xi * si + M * ci) * ai, k[3] = (_ * mi - ii * oi - bi * ti) * ai, k[4] = (D * oi - _ * si + bi * Zi) * ai, k[5] = (ii * si - D * mi - bi * ci) * ai, k[6] = (u * di - L * li + N * A) * ai, k[7] = (L * j - U * di - N * P) * ai, k[8] = (U * li - u * j + N * v) * ai, k) : null;
      }
      function F(k, Q, D) {
        return k[0] = 2 / Q, k[1] = 0, k[2] = 0, k[3] = 0, k[4] = -2 / D, k[5] = 0, k[6] = -1, k[7] = 1, k[8] = 1, k;
      }
      function Y(k) {
        return "mat3(" + k[0] + ", " + k[1] + ", " + k[2] + ", " + k[3] + ", " + k[4] + ", " + k[5] + ", " + k[6] + ", " + k[7] + ", " + k[8] + ")";
      }
      function J(k) {
        return Math.hypot(k[0], k[1], k[2], k[3], k[4], k[5], k[6], k[7], k[8]);
      }
      function T(k, Q, D) {
        return k[0] = Q[0] + D[0], k[1] = Q[1] + D[1], k[2] = Q[2] + D[2], k[3] = Q[3] + D[3], k[4] = Q[4] + D[4], k[5] = Q[5] + D[5], k[6] = Q[6] + D[6], k[7] = Q[7] + D[7], k[8] = Q[8] + D[8], k;
      }
      function K(k, Q, D) {
        return k[0] = Q[0] - D[0], k[1] = Q[1] - D[1], k[2] = Q[2] - D[2], k[3] = Q[3] - D[3], k[4] = Q[4] - D[4], k[5] = Q[5] - D[5], k[6] = Q[6] - D[6], k[7] = Q[7] - D[7], k[8] = Q[8] - D[8], k;
      }
      function R(k, Q, D) {
        return k[0] = Q[0] * D, k[1] = Q[1] * D, k[2] = Q[2] * D, k[3] = Q[3] * D, k[4] = Q[4] * D, k[5] = Q[5] * D, k[6] = Q[6] * D, k[7] = Q[7] * D, k[8] = Q[8] * D, k;
      }
      function H(k, Q, D, ii) {
        return k[0] = Q[0] + D[0] * ii, k[1] = Q[1] + D[1] * ii, k[2] = Q[2] + D[2] * ii, k[3] = Q[3] + D[3] * ii, k[4] = Q[4] + D[4] * ii, k[5] = Q[5] + D[5] * ii, k[6] = Q[6] + D[6] * ii, k[7] = Q[7] + D[7] * ii, k[8] = Q[8] + D[8] * ii, k;
      }
      function f(k, Q) {
        return k[0] === Q[0] && k[1] === Q[1] && k[2] === Q[2] && k[3] === Q[3] && k[4] === Q[4] && k[5] === Q[5] && k[6] === Q[6] && k[7] === Q[7] && k[8] === Q[8];
      }
      function w(k, Q) {
        var D = k[0], ii = k[1], _ = k[2], bi = k[3], $ = k[4], Xi = k[5], ni = k[6], M = k[7], z = k[8], E = Q[0], B = Q[1], g = Q[2], U = Q[3], u = Q[4], L = Q[5], N = Q[6], v = Q[7], P = Q[8];
        return Math.abs(D - E) <= d.EPSILON * Math.max(1, Math.abs(D), Math.abs(E)) && Math.abs(ii - B) <= d.EPSILON * Math.max(1, Math.abs(ii), Math.abs(B)) && Math.abs(_ - g) <= d.EPSILON * Math.max(1, Math.abs(_), Math.abs(g)) && Math.abs(bi - U) <= d.EPSILON * Math.max(1, Math.abs(bi), Math.abs(U)) && Math.abs($ - u) <= d.EPSILON * Math.max(1, Math.abs($), Math.abs(u)) && Math.abs(Xi - L) <= d.EPSILON * Math.max(1, Math.abs(Xi), Math.abs(L)) && Math.abs(ni - N) <= d.EPSILON * Math.max(1, Math.abs(ni), Math.abs(N)) && Math.abs(M - v) <= d.EPSILON * Math.max(1, Math.abs(M), Math.abs(v)) && Math.abs(z - P) <= d.EPSILON * Math.max(1, Math.abs(z), Math.abs(P));
      }
      var O = p, q = K;
    },
    /* 6 */
    /***/
    function(m, l, i) {
      i.r(l), i.d(l, "create", function() {
        return s;
      }), i.d(l, "clone", function() {
        return X;
      }), i.d(l, "copy", function() {
        return a;
      }), i.d(l, "fromValues", function() {
        return e;
      }), i.d(l, "set", function() {
        return n;
      }), i.d(l, "identity", function() {
        return G;
      }), i.d(l, "transpose", function() {
        return y;
      }), i.d(l, "invert", function() {
        return o;
      }), i.d(l, "adjoint", function() {
        return h;
      }), i.d(l, "determinant", function() {
        return I;
      }), i.d(l, "multiply", function() {
        return x;
      }), i.d(l, "translate", function() {
        return p;
      }), i.d(l, "scale", function() {
        return W;
      }), i.d(l, "rotate", function() {
        return V;
      }), i.d(l, "rotateX", function() {
        return t;
      }), i.d(l, "rotateY", function() {
        return c;
      }), i.d(l, "rotateZ", function() {
        return b;
      }), i.d(l, "fromTranslation", function() {
        return Z;
      }), i.d(l, "fromScaling", function() {
        return r;
      }), i.d(l, "fromRotation", function() {
        return S;
      }), i.d(l, "fromXRotation", function() {
        return C;
      }), i.d(l, "fromYRotation", function() {
        return F;
      }), i.d(l, "fromZRotation", function() {
        return Y;
      }), i.d(l, "fromRotationTranslation", function() {
        return J;
      }), i.d(l, "fromQuat2", function() {
        return T;
      }), i.d(l, "getTranslation", function() {
        return K;
      }), i.d(l, "getScaling", function() {
        return R;
      }), i.d(l, "getRotation", function() {
        return H;
      }), i.d(l, "fromRotationTranslationScale", function() {
        return f;
      }), i.d(l, "fromRotationTranslationScaleOrigin", function() {
        return w;
      }), i.d(l, "fromQuat", function() {
        return O;
      }), i.d(l, "frustum", function() {
        return q;
      }), i.d(l, "perspective", function() {
        return k;
      }), i.d(l, "perspectiveFromFieldOfView", function() {
        return Q;
      }), i.d(l, "ortho", function() {
        return D;
      }), i.d(l, "lookAt", function() {
        return ii;
      }), i.d(l, "targetTo", function() {
        return _;
      }), i.d(l, "str", function() {
        return bi;
      }), i.d(l, "frob", function() {
        return $;
      }), i.d(l, "add", function() {
        return Xi;
      }), i.d(l, "subtract", function() {
        return ni;
      }), i.d(l, "multiplyScalar", function() {
        return M;
      }), i.d(l, "multiplyScalarAndAdd", function() {
        return z;
      }), i.d(l, "exactEquals", function() {
        return E;
      }), i.d(l, "equals", function() {
        return B;
      }), i.d(l, "mul", function() {
        return g;
      }), i.d(l, "sub", function() {
        return U;
      });
      var d = i(2);
      function s() {
        var u = new d.ARRAY_TYPE(16);
        return d.ARRAY_TYPE != Float32Array && (u[1] = 0, u[2] = 0, u[3] = 0, u[4] = 0, u[6] = 0, u[7] = 0, u[8] = 0, u[9] = 0, u[11] = 0, u[12] = 0, u[13] = 0, u[14] = 0), u[0] = 1, u[5] = 1, u[10] = 1, u[15] = 1, u;
      }
      function X(u) {
        var L = new d.ARRAY_TYPE(16);
        return L[0] = u[0], L[1] = u[1], L[2] = u[2], L[3] = u[3], L[4] = u[4], L[5] = u[5], L[6] = u[6], L[7] = u[7], L[8] = u[8], L[9] = u[9], L[10] = u[10], L[11] = u[11], L[12] = u[12], L[13] = u[13], L[14] = u[14], L[15] = u[15], L;
      }
      function a(u, L) {
        return u[0] = L[0], u[1] = L[1], u[2] = L[2], u[3] = L[3], u[4] = L[4], u[5] = L[5], u[6] = L[6], u[7] = L[7], u[8] = L[8], u[9] = L[9], u[10] = L[10], u[11] = L[11], u[12] = L[12], u[13] = L[13], u[14] = L[14], u[15] = L[15], u;
      }
      function e(u, L, N, v, P, j, A, li, di, ci, Zi, si, ti, mi, oi, ai) {
        var ei = new d.ARRAY_TYPE(16);
        return ei[0] = u, ei[1] = L, ei[2] = N, ei[3] = v, ei[4] = P, ei[5] = j, ei[6] = A, ei[7] = li, ei[8] = di, ei[9] = ci, ei[10] = Zi, ei[11] = si, ei[12] = ti, ei[13] = mi, ei[14] = oi, ei[15] = ai, ei;
      }
      function n(u, L, N, v, P, j, A, li, di, ci, Zi, si, ti, mi, oi, ai, ei) {
        return u[0] = L, u[1] = N, u[2] = v, u[3] = P, u[4] = j, u[5] = A, u[6] = li, u[7] = di, u[8] = ci, u[9] = Zi, u[10] = si, u[11] = ti, u[12] = mi, u[13] = oi, u[14] = ai, u[15] = ei, u;
      }
      function G(u) {
        return u[0] = 1, u[1] = 0, u[2] = 0, u[3] = 0, u[4] = 0, u[5] = 1, u[6] = 0, u[7] = 0, u[8] = 0, u[9] = 0, u[10] = 1, u[11] = 0, u[12] = 0, u[13] = 0, u[14] = 0, u[15] = 1, u;
      }
      function y(u, L) {
        if (u === L) {
          var N = L[1], v = L[2], P = L[3], j = L[6], A = L[7], li = L[11];
          u[1] = L[4], u[2] = L[8], u[3] = L[12], u[4] = N, u[6] = L[9], u[7] = L[13], u[8] = v, u[9] = j, u[11] = L[14], u[12] = P, u[13] = A, u[14] = li;
        } else
          u[0] = L[0], u[1] = L[4], u[2] = L[8], u[3] = L[12], u[4] = L[1], u[5] = L[5], u[6] = L[9], u[7] = L[13], u[8] = L[2], u[9] = L[6], u[10] = L[10], u[11] = L[14], u[12] = L[3], u[13] = L[7], u[14] = L[11], u[15] = L[15];
        return u;
      }
      function o(u, L) {
        var N = L[0], v = L[1], P = L[2], j = L[3], A = L[4], li = L[5], di = L[6], ci = L[7], Zi = L[8], si = L[9], ti = L[10], mi = L[11], oi = L[12], ai = L[13], ei = L[14], Vi = L[15], Ji = N * li - v * A, Yi = N * di - P * A, xi = N * ci - j * A, Si = v * di - P * li, Ri = v * ci - j * li, Pi = P * ci - j * di, Ui = Zi * ai - si * oi, fi = Zi * ei - ti * oi, Qi = Zi * Vi - mi * oi, wi = si * ei - ti * ai, Ei = si * Vi - mi * ai, Bi = ti * Vi - mi * ei, Ni = Ji * Bi - Yi * Ei + xi * wi + Si * Qi - Ri * fi + Pi * Ui;
        return Ni ? (Ni = 1 / Ni, u[0] = (li * Bi - di * Ei + ci * wi) * Ni, u[1] = (P * Ei - v * Bi - j * wi) * Ni, u[2] = (ai * Pi - ei * Ri + Vi * Si) * Ni, u[3] = (ti * Ri - si * Pi - mi * Si) * Ni, u[4] = (di * Qi - A * Bi - ci * fi) * Ni, u[5] = (N * Bi - P * Qi + j * fi) * Ni, u[6] = (ei * xi - oi * Pi - Vi * Yi) * Ni, u[7] = (Zi * Pi - ti * xi + mi * Yi) * Ni, u[8] = (A * Ei - li * Qi + ci * Ui) * Ni, u[9] = (v * Qi - N * Ei - j * Ui) * Ni, u[10] = (oi * Ri - ai * xi + Vi * Ji) * Ni, u[11] = (si * xi - Zi * Ri - mi * Ji) * Ni, u[12] = (li * fi - A * wi - di * Ui) * Ni, u[13] = (N * wi - v * fi + P * Ui) * Ni, u[14] = (ai * Yi - oi * Si - ei * Ji) * Ni, u[15] = (Zi * Si - si * Yi + ti * Ji) * Ni, u) : null;
      }
      function h(u, L) {
        var N = L[0], v = L[1], P = L[2], j = L[3], A = L[4], li = L[5], di = L[6], ci = L[7], Zi = L[8], si = L[9], ti = L[10], mi = L[11], oi = L[12], ai = L[13], ei = L[14], Vi = L[15];
        return u[0] = li * (ti * Vi - mi * ei) - si * (di * Vi - ci * ei) + ai * (di * mi - ci * ti), u[1] = -(v * (ti * Vi - mi * ei) - si * (P * Vi - j * ei) + ai * (P * mi - j * ti)), u[2] = v * (di * Vi - ci * ei) - li * (P * Vi - j * ei) + ai * (P * ci - j * di), u[3] = -(v * (di * mi - ci * ti) - li * (P * mi - j * ti) + si * (P * ci - j * di)), u[4] = -(A * (ti * Vi - mi * ei) - Zi * (di * Vi - ci * ei) + oi * (di * mi - ci * ti)), u[5] = N * (ti * Vi - mi * ei) - Zi * (P * Vi - j * ei) + oi * (P * mi - j * ti), u[6] = -(N * (di * Vi - ci * ei) - A * (P * Vi - j * ei) + oi * (P * ci - j * di)), u[7] = N * (di * mi - ci * ti) - A * (P * mi - j * ti) + Zi * (P * ci - j * di), u[8] = A * (si * Vi - mi * ai) - Zi * (li * Vi - ci * ai) + oi * (li * mi - ci * si), u[9] = -(N * (si * Vi - mi * ai) - Zi * (v * Vi - j * ai) + oi * (v * mi - j * si)), u[10] = N * (li * Vi - ci * ai) - A * (v * Vi - j * ai) + oi * (v * ci - j * li), u[11] = -(N * (li * mi - ci * si) - A * (v * mi - j * si) + Zi * (v * ci - j * li)), u[12] = -(A * (si * ei - ti * ai) - Zi * (li * ei - di * ai) + oi * (li * ti - di * si)), u[13] = N * (si * ei - ti * ai) - Zi * (v * ei - P * ai) + oi * (v * ti - P * si), u[14] = -(N * (li * ei - di * ai) - A * (v * ei - P * ai) + oi * (v * di - P * li)), u[15] = N * (li * ti - di * si) - A * (v * ti - P * si) + Zi * (v * di - P * li), u;
      }
      function I(u) {
        var L = u[0], N = u[1], v = u[2], P = u[3], j = u[4], A = u[5], li = u[6], di = u[7], ci = u[8], Zi = u[9], si = u[10], ti = u[11], mi = u[12], oi = u[13], ai = u[14], ei = u[15], Vi = L * A - N * j, Ji = L * li - v * j, Yi = L * di - P * j, xi = N * li - v * A, Si = N * di - P * A, Ri = v * di - P * li, Pi = ci * oi - Zi * mi, Ui = ci * ai - si * mi, fi = ci * ei - ti * mi, Qi = Zi * ai - si * oi, wi = Zi * ei - ti * oi, Ei = si * ei - ti * ai;
        return Vi * Ei - Ji * wi + Yi * Qi + xi * fi - Si * Ui + Ri * Pi;
      }
      function x(u, L, N) {
        var v = L[0], P = L[1], j = L[2], A = L[3], li = L[4], di = L[5], ci = L[6], Zi = L[7], si = L[8], ti = L[9], mi = L[10], oi = L[11], ai = L[12], ei = L[13], Vi = L[14], Ji = L[15], Yi = N[0], xi = N[1], Si = N[2], Ri = N[3];
        return u[0] = Yi * v + xi * li + Si * si + Ri * ai, u[1] = Yi * P + xi * di + Si * ti + Ri * ei, u[2] = Yi * j + xi * ci + Si * mi + Ri * Vi, u[3] = Yi * A + xi * Zi + Si * oi + Ri * Ji, Yi = N[4], xi = N[5], Si = N[6], Ri = N[7], u[4] = Yi * v + xi * li + Si * si + Ri * ai, u[5] = Yi * P + xi * di + Si * ti + Ri * ei, u[6] = Yi * j + xi * ci + Si * mi + Ri * Vi, u[7] = Yi * A + xi * Zi + Si * oi + Ri * Ji, Yi = N[8], xi = N[9], Si = N[10], Ri = N[11], u[8] = Yi * v + xi * li + Si * si + Ri * ai, u[9] = Yi * P + xi * di + Si * ti + Ri * ei, u[10] = Yi * j + xi * ci + Si * mi + Ri * Vi, u[11] = Yi * A + xi * Zi + Si * oi + Ri * Ji, Yi = N[12], xi = N[13], Si = N[14], Ri = N[15], u[12] = Yi * v + xi * li + Si * si + Ri * ai, u[13] = Yi * P + xi * di + Si * ti + Ri * ei, u[14] = Yi * j + xi * ci + Si * mi + Ri * Vi, u[15] = Yi * A + xi * Zi + Si * oi + Ri * Ji, u;
      }
      function p(u, L, N) {
        var v = N[0], P = N[1], j = N[2], A, li, di, ci, Zi, si, ti, mi, oi, ai, ei, Vi;
        return L === u ? (u[12] = L[0] * v + L[4] * P + L[8] * j + L[12], u[13] = L[1] * v + L[5] * P + L[9] * j + L[13], u[14] = L[2] * v + L[6] * P + L[10] * j + L[14], u[15] = L[3] * v + L[7] * P + L[11] * j + L[15]) : (A = L[0], li = L[1], di = L[2], ci = L[3], Zi = L[4], si = L[5], ti = L[6], mi = L[7], oi = L[8], ai = L[9], ei = L[10], Vi = L[11], u[0] = A, u[1] = li, u[2] = di, u[3] = ci, u[4] = Zi, u[5] = si, u[6] = ti, u[7] = mi, u[8] = oi, u[9] = ai, u[10] = ei, u[11] = Vi, u[12] = A * v + Zi * P + oi * j + L[12], u[13] = li * v + si * P + ai * j + L[13], u[14] = di * v + ti * P + ei * j + L[14], u[15] = ci * v + mi * P + Vi * j + L[15]), u;
      }
      function W(u, L, N) {
        var v = N[0], P = N[1], j = N[2];
        return u[0] = L[0] * v, u[1] = L[1] * v, u[2] = L[2] * v, u[3] = L[3] * v, u[4] = L[4] * P, u[5] = L[5] * P, u[6] = L[6] * P, u[7] = L[7] * P, u[8] = L[8] * j, u[9] = L[9] * j, u[10] = L[10] * j, u[11] = L[11] * j, u[12] = L[12], u[13] = L[13], u[14] = L[14], u[15] = L[15], u;
      }
      function V(u, L, N, v) {
        var P = v[0], j = v[1], A = v[2], li = Math.hypot(P, j, A), di, ci, Zi, si, ti, mi, oi, ai, ei, Vi, Ji, Yi, xi, Si, Ri, Pi, Ui, fi, Qi, wi, Ei, Bi, Ni, sl;
        return li < d.EPSILON ? null : (li = 1 / li, P *= li, j *= li, A *= li, di = Math.sin(N), ci = Math.cos(N), Zi = 1 - ci, si = L[0], ti = L[1], mi = L[2], oi = L[3], ai = L[4], ei = L[5], Vi = L[6], Ji = L[7], Yi = L[8], xi = L[9], Si = L[10], Ri = L[11], Pi = P * P * Zi + ci, Ui = j * P * Zi + A * di, fi = A * P * Zi - j * di, Qi = P * j * Zi - A * di, wi = j * j * Zi + ci, Ei = A * j * Zi + P * di, Bi = P * A * Zi + j * di, Ni = j * A * Zi - P * di, sl = A * A * Zi + ci, u[0] = si * Pi + ai * Ui + Yi * fi, u[1] = ti * Pi + ei * Ui + xi * fi, u[2] = mi * Pi + Vi * Ui + Si * fi, u[3] = oi * Pi + Ji * Ui + Ri * fi, u[4] = si * Qi + ai * wi + Yi * Ei, u[5] = ti * Qi + ei * wi + xi * Ei, u[6] = mi * Qi + Vi * wi + Si * Ei, u[7] = oi * Qi + Ji * wi + Ri * Ei, u[8] = si * Bi + ai * Ni + Yi * sl, u[9] = ti * Bi + ei * Ni + xi * sl, u[10] = mi * Bi + Vi * Ni + Si * sl, u[11] = oi * Bi + Ji * Ni + Ri * sl, L !== u && (u[12] = L[12], u[13] = L[13], u[14] = L[14], u[15] = L[15]), u);
      }
      function t(u, L, N) {
        var v = Math.sin(N), P = Math.cos(N), j = L[4], A = L[5], li = L[6], di = L[7], ci = L[8], Zi = L[9], si = L[10], ti = L[11];
        return L !== u && (u[0] = L[0], u[1] = L[1], u[2] = L[2], u[3] = L[3], u[12] = L[12], u[13] = L[13], u[14] = L[14], u[15] = L[15]), u[4] = j * P + ci * v, u[5] = A * P + Zi * v, u[6] = li * P + si * v, u[7] = di * P + ti * v, u[8] = ci * P - j * v, u[9] = Zi * P - A * v, u[10] = si * P - li * v, u[11] = ti * P - di * v, u;
      }
      function c(u, L, N) {
        var v = Math.sin(N), P = Math.cos(N), j = L[0], A = L[1], li = L[2], di = L[3], ci = L[8], Zi = L[9], si = L[10], ti = L[11];
        return L !== u && (u[4] = L[4], u[5] = L[5], u[6] = L[6], u[7] = L[7], u[12] = L[12], u[13] = L[13], u[14] = L[14], u[15] = L[15]), u[0] = j * P - ci * v, u[1] = A * P - Zi * v, u[2] = li * P - si * v, u[3] = di * P - ti * v, u[8] = j * v + ci * P, u[9] = A * v + Zi * P, u[10] = li * v + si * P, u[11] = di * v + ti * P, u;
      }
      function b(u, L, N) {
        var v = Math.sin(N), P = Math.cos(N), j = L[0], A = L[1], li = L[2], di = L[3], ci = L[4], Zi = L[5], si = L[6], ti = L[7];
        return L !== u && (u[8] = L[8], u[9] = L[9], u[10] = L[10], u[11] = L[11], u[12] = L[12], u[13] = L[13], u[14] = L[14], u[15] = L[15]), u[0] = j * P + ci * v, u[1] = A * P + Zi * v, u[2] = li * P + si * v, u[3] = di * P + ti * v, u[4] = ci * P - j * v, u[5] = Zi * P - A * v, u[6] = si * P - li * v, u[7] = ti * P - di * v, u;
      }
      function Z(u, L) {
        return u[0] = 1, u[1] = 0, u[2] = 0, u[3] = 0, u[4] = 0, u[5] = 1, u[6] = 0, u[7] = 0, u[8] = 0, u[9] = 0, u[10] = 1, u[11] = 0, u[12] = L[0], u[13] = L[1], u[14] = L[2], u[15] = 1, u;
      }
      function r(u, L) {
        return u[0] = L[0], u[1] = 0, u[2] = 0, u[3] = 0, u[4] = 0, u[5] = L[1], u[6] = 0, u[7] = 0, u[8] = 0, u[9] = 0, u[10] = L[2], u[11] = 0, u[12] = 0, u[13] = 0, u[14] = 0, u[15] = 1, u;
      }
      function S(u, L, N) {
        var v = N[0], P = N[1], j = N[2], A = Math.hypot(v, P, j), li, di, ci;
        return A < d.EPSILON ? null : (A = 1 / A, v *= A, P *= A, j *= A, li = Math.sin(L), di = Math.cos(L), ci = 1 - di, u[0] = v * v * ci + di, u[1] = P * v * ci + j * li, u[2] = j * v * ci - P * li, u[3] = 0, u[4] = v * P * ci - j * li, u[5] = P * P * ci + di, u[6] = j * P * ci + v * li, u[7] = 0, u[8] = v * j * ci + P * li, u[9] = P * j * ci - v * li, u[10] = j * j * ci + di, u[11] = 0, u[12] = 0, u[13] = 0, u[14] = 0, u[15] = 1, u);
      }
      function C(u, L) {
        var N = Math.sin(L), v = Math.cos(L);
        return u[0] = 1, u[1] = 0, u[2] = 0, u[3] = 0, u[4] = 0, u[5] = v, u[6] = N, u[7] = 0, u[8] = 0, u[9] = -N, u[10] = v, u[11] = 0, u[12] = 0, u[13] = 0, u[14] = 0, u[15] = 1, u;
      }
      function F(u, L) {
        var N = Math.sin(L), v = Math.cos(L);
        return u[0] = v, u[1] = 0, u[2] = -N, u[3] = 0, u[4] = 0, u[5] = 1, u[6] = 0, u[7] = 0, u[8] = N, u[9] = 0, u[10] = v, u[11] = 0, u[12] = 0, u[13] = 0, u[14] = 0, u[15] = 1, u;
      }
      function Y(u, L) {
        var N = Math.sin(L), v = Math.cos(L);
        return u[0] = v, u[1] = N, u[2] = 0, u[3] = 0, u[4] = -N, u[5] = v, u[6] = 0, u[7] = 0, u[8] = 0, u[9] = 0, u[10] = 1, u[11] = 0, u[12] = 0, u[13] = 0, u[14] = 0, u[15] = 1, u;
      }
      function J(u, L, N) {
        var v = L[0], P = L[1], j = L[2], A = L[3], li = v + v, di = P + P, ci = j + j, Zi = v * li, si = v * di, ti = v * ci, mi = P * di, oi = P * ci, ai = j * ci, ei = A * li, Vi = A * di, Ji = A * ci;
        return u[0] = 1 - (mi + ai), u[1] = si + Ji, u[2] = ti - Vi, u[3] = 0, u[4] = si - Ji, u[5] = 1 - (Zi + ai), u[6] = oi + ei, u[7] = 0, u[8] = ti + Vi, u[9] = oi - ei, u[10] = 1 - (Zi + mi), u[11] = 0, u[12] = N[0], u[13] = N[1], u[14] = N[2], u[15] = 1, u;
      }
      function T(u, L) {
        var N = new d.ARRAY_TYPE(3), v = -L[0], P = -L[1], j = -L[2], A = L[3], li = L[4], di = L[5], ci = L[6], Zi = L[7], si = v * v + P * P + j * j + A * A;
        return si > 0 ? (N[0] = (li * A + Zi * v + di * j - ci * P) * 2 / si, N[1] = (di * A + Zi * P + ci * v - li * j) * 2 / si, N[2] = (ci * A + Zi * j + li * P - di * v) * 2 / si) : (N[0] = (li * A + Zi * v + di * j - ci * P) * 2, N[1] = (di * A + Zi * P + ci * v - li * j) * 2, N[2] = (ci * A + Zi * j + li * P - di * v) * 2), J(u, L, N), u;
      }
      function K(u, L) {
        return u[0] = L[12], u[1] = L[13], u[2] = L[14], u;
      }
      function R(u, L) {
        var N = L[0], v = L[1], P = L[2], j = L[4], A = L[5], li = L[6], di = L[8], ci = L[9], Zi = L[10];
        return u[0] = Math.hypot(N, v, P), u[1] = Math.hypot(j, A, li), u[2] = Math.hypot(di, ci, Zi), u;
      }
      function H(u, L) {
        var N = new d.ARRAY_TYPE(3);
        R(N, L);
        var v = 1 / N[0], P = 1 / N[1], j = 1 / N[2], A = L[0] * v, li = L[1] * P, di = L[2] * j, ci = L[4] * v, Zi = L[5] * P, si = L[6] * j, ti = L[8] * v, mi = L[9] * P, oi = L[10] * j, ai = A + Zi + oi, ei = 0;
        return ai > 0 ? (ei = Math.sqrt(ai + 1) * 2, u[3] = 0.25 * ei, u[0] = (si - mi) / ei, u[1] = (ti - di) / ei, u[2] = (li - ci) / ei) : A > Zi && A > oi ? (ei = Math.sqrt(1 + A - Zi - oi) * 2, u[3] = (si - mi) / ei, u[0] = 0.25 * ei, u[1] = (li + ci) / ei, u[2] = (ti + di) / ei) : Zi > oi ? (ei = Math.sqrt(1 + Zi - A - oi) * 2, u[3] = (ti - di) / ei, u[0] = (li + ci) / ei, u[1] = 0.25 * ei, u[2] = (si + mi) / ei) : (ei = Math.sqrt(1 + oi - A - Zi) * 2, u[3] = (li - ci) / ei, u[0] = (ti + di) / ei, u[1] = (si + mi) / ei, u[2] = 0.25 * ei), u;
      }
      function f(u, L, N, v) {
        var P = L[0], j = L[1], A = L[2], li = L[3], di = P + P, ci = j + j, Zi = A + A, si = P * di, ti = P * ci, mi = P * Zi, oi = j * ci, ai = j * Zi, ei = A * Zi, Vi = li * di, Ji = li * ci, Yi = li * Zi, xi = v[0], Si = v[1], Ri = v[2];
        return u[0] = (1 - (oi + ei)) * xi, u[1] = (ti + Yi) * xi, u[2] = (mi - Ji) * xi, u[3] = 0, u[4] = (ti - Yi) * Si, u[5] = (1 - (si + ei)) * Si, u[6] = (ai + Vi) * Si, u[7] = 0, u[8] = (mi + Ji) * Ri, u[9] = (ai - Vi) * Ri, u[10] = (1 - (si + oi)) * Ri, u[11] = 0, u[12] = N[0], u[13] = N[1], u[14] = N[2], u[15] = 1, u;
      }
      function w(u, L, N, v, P) {
        var j = L[0], A = L[1], li = L[2], di = L[3], ci = j + j, Zi = A + A, si = li + li, ti = j * ci, mi = j * Zi, oi = j * si, ai = A * Zi, ei = A * si, Vi = li * si, Ji = di * ci, Yi = di * Zi, xi = di * si, Si = v[0], Ri = v[1], Pi = v[2], Ui = P[0], fi = P[1], Qi = P[2], wi = (1 - (ai + Vi)) * Si, Ei = (mi + xi) * Si, Bi = (oi - Yi) * Si, Ni = (mi - xi) * Ri, sl = (1 - (ti + Vi)) * Ri, Nl = (ei + Ji) * Ri, gl = (oi + Yi) * Pi, Kd = (ei - Ji) * Pi, Cd = (1 - (ti + ai)) * Pi;
        return u[0] = wi, u[1] = Ei, u[2] = Bi, u[3] = 0, u[4] = Ni, u[5] = sl, u[6] = Nl, u[7] = 0, u[8] = gl, u[9] = Kd, u[10] = Cd, u[11] = 0, u[12] = N[0] + Ui - (wi * Ui + Ni * fi + gl * Qi), u[13] = N[1] + fi - (Ei * Ui + sl * fi + Kd * Qi), u[14] = N[2] + Qi - (Bi * Ui + Nl * fi + Cd * Qi), u[15] = 1, u;
      }
      function O(u, L) {
        var N = L[0], v = L[1], P = L[2], j = L[3], A = N + N, li = v + v, di = P + P, ci = N * A, Zi = v * A, si = v * li, ti = P * A, mi = P * li, oi = P * di, ai = j * A, ei = j * li, Vi = j * di;
        return u[0] = 1 - si - oi, u[1] = Zi + Vi, u[2] = ti - ei, u[3] = 0, u[4] = Zi - Vi, u[5] = 1 - ci - oi, u[6] = mi + ai, u[7] = 0, u[8] = ti + ei, u[9] = mi - ai, u[10] = 1 - ci - si, u[11] = 0, u[12] = 0, u[13] = 0, u[14] = 0, u[15] = 1, u;
      }
      function q(u, L, N, v, P, j, A) {
        var li = 1 / (N - L), di = 1 / (P - v), ci = 1 / (j - A);
        return u[0] = j * 2 * li, u[1] = 0, u[2] = 0, u[3] = 0, u[4] = 0, u[5] = j * 2 * di, u[6] = 0, u[7] = 0, u[8] = (N + L) * li, u[9] = (P + v) * di, u[10] = (A + j) * ci, u[11] = -1, u[12] = 0, u[13] = 0, u[14] = A * j * 2 * ci, u[15] = 0, u;
      }
      function k(u, L, N, v, P) {
        var j = 1 / Math.tan(L / 2), A;
        return u[0] = j / N, u[1] = 0, u[2] = 0, u[3] = 0, u[4] = 0, u[5] = j, u[6] = 0, u[7] = 0, u[8] = 0, u[9] = 0, u[11] = -1, u[12] = 0, u[13] = 0, u[15] = 0, P != null && P !== 1 / 0 ? (A = 1 / (v - P), u[10] = (P + v) * A, u[14] = 2 * P * v * A) : (u[10] = -1, u[14] = -2 * v), u;
      }
      function Q(u, L, N, v) {
        var P = Math.tan(L.upDegrees * Math.PI / 180), j = Math.tan(L.downDegrees * Math.PI / 180), A = Math.tan(L.leftDegrees * Math.PI / 180), li = Math.tan(L.rightDegrees * Math.PI / 180), di = 2 / (A + li), ci = 2 / (P + j);
        return u[0] = di, u[1] = 0, u[2] = 0, u[3] = 0, u[4] = 0, u[5] = ci, u[6] = 0, u[7] = 0, u[8] = -((A - li) * di * 0.5), u[9] = (P - j) * ci * 0.5, u[10] = v / (N - v), u[11] = -1, u[12] = 0, u[13] = 0, u[14] = v * N / (N - v), u[15] = 0, u;
      }
      function D(u, L, N, v, P, j, A) {
        var li = 1 / (L - N), di = 1 / (v - P), ci = 1 / (j - A);
        return u[0] = -2 * li, u[1] = 0, u[2] = 0, u[3] = 0, u[4] = 0, u[5] = -2 * di, u[6] = 0, u[7] = 0, u[8] = 0, u[9] = 0, u[10] = 2 * ci, u[11] = 0, u[12] = (L + N) * li, u[13] = (P + v) * di, u[14] = (A + j) * ci, u[15] = 1, u;
      }
      function ii(u, L, N, v) {
        var P, j, A, li, di, ci, Zi, si, ti, mi, oi = L[0], ai = L[1], ei = L[2], Vi = v[0], Ji = v[1], Yi = v[2], xi = N[0], Si = N[1], Ri = N[2];
        return Math.abs(oi - xi) < d.EPSILON && Math.abs(ai - Si) < d.EPSILON && Math.abs(ei - Ri) < d.EPSILON ? G(u) : (Zi = oi - xi, si = ai - Si, ti = ei - Ri, mi = 1 / Math.hypot(Zi, si, ti), Zi *= mi, si *= mi, ti *= mi, P = Ji * ti - Yi * si, j = Yi * Zi - Vi * ti, A = Vi * si - Ji * Zi, mi = Math.hypot(P, j, A), mi ? (mi = 1 / mi, P *= mi, j *= mi, A *= mi) : (P = 0, j = 0, A = 0), li = si * A - ti * j, di = ti * P - Zi * A, ci = Zi * j - si * P, mi = Math.hypot(li, di, ci), mi ? (mi = 1 / mi, li *= mi, di *= mi, ci *= mi) : (li = 0, di = 0, ci = 0), u[0] = P, u[1] = li, u[2] = Zi, u[3] = 0, u[4] = j, u[5] = di, u[6] = si, u[7] = 0, u[8] = A, u[9] = ci, u[10] = ti, u[11] = 0, u[12] = -(P * oi + j * ai + A * ei), u[13] = -(li * oi + di * ai + ci * ei), u[14] = -(Zi * oi + si * ai + ti * ei), u[15] = 1, u);
      }
      function _(u, L, N, v) {
        var P = L[0], j = L[1], A = L[2], li = v[0], di = v[1], ci = v[2], Zi = P - N[0], si = j - N[1], ti = A - N[2], mi = Zi * Zi + si * si + ti * ti;
        mi > 0 && (mi = 1 / Math.sqrt(mi), Zi *= mi, si *= mi, ti *= mi);
        var oi = di * ti - ci * si, ai = ci * Zi - li * ti, ei = li * si - di * Zi;
        return mi = oi * oi + ai * ai + ei * ei, mi > 0 && (mi = 1 / Math.sqrt(mi), oi *= mi, ai *= mi, ei *= mi), u[0] = oi, u[1] = ai, u[2] = ei, u[3] = 0, u[4] = si * ei - ti * ai, u[5] = ti * oi - Zi * ei, u[6] = Zi * ai - si * oi, u[7] = 0, u[8] = Zi, u[9] = si, u[10] = ti, u[11] = 0, u[12] = P, u[13] = j, u[14] = A, u[15] = 1, u;
      }
      function bi(u) {
        return "mat4(" + u[0] + ", " + u[1] + ", " + u[2] + ", " + u[3] + ", " + u[4] + ", " + u[5] + ", " + u[6] + ", " + u[7] + ", " + u[8] + ", " + u[9] + ", " + u[10] + ", " + u[11] + ", " + u[12] + ", " + u[13] + ", " + u[14] + ", " + u[15] + ")";
      }
      function $(u) {
        return Math.hypot(u[0], u[1], u[2], u[3], u[4], u[5], u[6], u[7], u[8], u[9], u[10], u[11], u[12], u[13], u[14], u[15]);
      }
      function Xi(u, L, N) {
        return u[0] = L[0] + N[0], u[1] = L[1] + N[1], u[2] = L[2] + N[2], u[3] = L[3] + N[3], u[4] = L[4] + N[4], u[5] = L[5] + N[5], u[6] = L[6] + N[6], u[7] = L[7] + N[7], u[8] = L[8] + N[8], u[9] = L[9] + N[9], u[10] = L[10] + N[10], u[11] = L[11] + N[11], u[12] = L[12] + N[12], u[13] = L[13] + N[13], u[14] = L[14] + N[14], u[15] = L[15] + N[15], u;
      }
      function ni(u, L, N) {
        return u[0] = L[0] - N[0], u[1] = L[1] - N[1], u[2] = L[2] - N[2], u[3] = L[3] - N[3], u[4] = L[4] - N[4], u[5] = L[5] - N[5], u[6] = L[6] - N[6], u[7] = L[7] - N[7], u[8] = L[8] - N[8], u[9] = L[9] - N[9], u[10] = L[10] - N[10], u[11] = L[11] - N[11], u[12] = L[12] - N[12], u[13] = L[13] - N[13], u[14] = L[14] - N[14], u[15] = L[15] - N[15], u;
      }
      function M(u, L, N) {
        return u[0] = L[0] * N, u[1] = L[1] * N, u[2] = L[2] * N, u[3] = L[3] * N, u[4] = L[4] * N, u[5] = L[5] * N, u[6] = L[6] * N, u[7] = L[7] * N, u[8] = L[8] * N, u[9] = L[9] * N, u[10] = L[10] * N, u[11] = L[11] * N, u[12] = L[12] * N, u[13] = L[13] * N, u[14] = L[14] * N, u[15] = L[15] * N, u;
      }
      function z(u, L, N, v) {
        return u[0] = L[0] + N[0] * v, u[1] = L[1] + N[1] * v, u[2] = L[2] + N[2] * v, u[3] = L[3] + N[3] * v, u[4] = L[4] + N[4] * v, u[5] = L[5] + N[5] * v, u[6] = L[6] + N[6] * v, u[7] = L[7] + N[7] * v, u[8] = L[8] + N[8] * v, u[9] = L[9] + N[9] * v, u[10] = L[10] + N[10] * v, u[11] = L[11] + N[11] * v, u[12] = L[12] + N[12] * v, u[13] = L[13] + N[13] * v, u[14] = L[14] + N[14] * v, u[15] = L[15] + N[15] * v, u;
      }
      function E(u, L) {
        return u[0] === L[0] && u[1] === L[1] && u[2] === L[2] && u[3] === L[3] && u[4] === L[4] && u[5] === L[5] && u[6] === L[6] && u[7] === L[7] && u[8] === L[8] && u[9] === L[9] && u[10] === L[10] && u[11] === L[11] && u[12] === L[12] && u[13] === L[13] && u[14] === L[14] && u[15] === L[15];
      }
      function B(u, L) {
        var N = u[0], v = u[1], P = u[2], j = u[3], A = u[4], li = u[5], di = u[6], ci = u[7], Zi = u[8], si = u[9], ti = u[10], mi = u[11], oi = u[12], ai = u[13], ei = u[14], Vi = u[15], Ji = L[0], Yi = L[1], xi = L[2], Si = L[3], Ri = L[4], Pi = L[5], Ui = L[6], fi = L[7], Qi = L[8], wi = L[9], Ei = L[10], Bi = L[11], Ni = L[12], sl = L[13], Nl = L[14], gl = L[15];
        return Math.abs(N - Ji) <= d.EPSILON * Math.max(1, Math.abs(N), Math.abs(Ji)) && Math.abs(v - Yi) <= d.EPSILON * Math.max(1, Math.abs(v), Math.abs(Yi)) && Math.abs(P - xi) <= d.EPSILON * Math.max(1, Math.abs(P), Math.abs(xi)) && Math.abs(j - Si) <= d.EPSILON * Math.max(1, Math.abs(j), Math.abs(Si)) && Math.abs(A - Ri) <= d.EPSILON * Math.max(1, Math.abs(A), Math.abs(Ri)) && Math.abs(li - Pi) <= d.EPSILON * Math.max(1, Math.abs(li), Math.abs(Pi)) && Math.abs(di - Ui) <= d.EPSILON * Math.max(1, Math.abs(di), Math.abs(Ui)) && Math.abs(ci - fi) <= d.EPSILON * Math.max(1, Math.abs(ci), Math.abs(fi)) && Math.abs(Zi - Qi) <= d.EPSILON * Math.max(1, Math.abs(Zi), Math.abs(Qi)) && Math.abs(si - wi) <= d.EPSILON * Math.max(1, Math.abs(si), Math.abs(wi)) && Math.abs(ti - Ei) <= d.EPSILON * Math.max(1, Math.abs(ti), Math.abs(Ei)) && Math.abs(mi - Bi) <= d.EPSILON * Math.max(1, Math.abs(mi), Math.abs(Bi)) && Math.abs(oi - Ni) <= d.EPSILON * Math.max(1, Math.abs(oi), Math.abs(Ni)) && Math.abs(ai - sl) <= d.EPSILON * Math.max(1, Math.abs(ai), Math.abs(sl)) && Math.abs(ei - Nl) <= d.EPSILON * Math.max(1, Math.abs(ei), Math.abs(Nl)) && Math.abs(Vi - gl) <= d.EPSILON * Math.max(1, Math.abs(Vi), Math.abs(gl));
      }
      var g = x, U = ni;
    },
    /* 7 */
    /***/
    function(m, l, i) {
      i.r(l), i.d(l, "create", function() {
        return e;
      }), i.d(l, "identity", function() {
        return n;
      }), i.d(l, "setAxisAngle", function() {
        return G;
      }), i.d(l, "getAxisAngle", function() {
        return y;
      }), i.d(l, "getAngle", function() {
        return o;
      }), i.d(l, "multiply", function() {
        return h;
      }), i.d(l, "rotateX", function() {
        return I;
      }), i.d(l, "rotateY", function() {
        return x;
      }), i.d(l, "rotateZ", function() {
        return p;
      }), i.d(l, "calculateW", function() {
        return W;
      }), i.d(l, "exp", function() {
        return V;
      }), i.d(l, "ln", function() {
        return t;
      }), i.d(l, "pow", function() {
        return c;
      }), i.d(l, "slerp", function() {
        return b;
      }), i.d(l, "random", function() {
        return Z;
      }), i.d(l, "invert", function() {
        return r;
      }), i.d(l, "conjugate", function() {
        return S;
      }), i.d(l, "fromMat3", function() {
        return C;
      }), i.d(l, "fromEuler", function() {
        return F;
      }), i.d(l, "str", function() {
        return Y;
      }), i.d(l, "clone", function() {
        return J;
      }), i.d(l, "fromValues", function() {
        return T;
      }), i.d(l, "copy", function() {
        return K;
      }), i.d(l, "set", function() {
        return R;
      }), i.d(l, "add", function() {
        return H;
      }), i.d(l, "mul", function() {
        return f;
      }), i.d(l, "scale", function() {
        return w;
      }), i.d(l, "dot", function() {
        return O;
      }), i.d(l, "lerp", function() {
        return q;
      }), i.d(l, "length", function() {
        return k;
      }), i.d(l, "len", function() {
        return Q;
      }), i.d(l, "squaredLength", function() {
        return D;
      }), i.d(l, "sqrLen", function() {
        return ii;
      }), i.d(l, "normalize", function() {
        return _;
      }), i.d(l, "exactEquals", function() {
        return bi;
      }), i.d(l, "equals", function() {
        return $;
      }), i.d(l, "rotationTo", function() {
        return Xi;
      }), i.d(l, "sqlerp", function() {
        return ni;
      }), i.d(l, "setAxes", function() {
        return M;
      });
      var d = i(2), s = i(5), X = i(8), a = i(9);
      function e() {
        var z = new d.ARRAY_TYPE(4);
        return d.ARRAY_TYPE != Float32Array && (z[0] = 0, z[1] = 0, z[2] = 0), z[3] = 1, z;
      }
      function n(z) {
        return z[0] = 0, z[1] = 0, z[2] = 0, z[3] = 1, z;
      }
      function G(z, E, B) {
        B = B * 0.5;
        var g = Math.sin(B);
        return z[0] = g * E[0], z[1] = g * E[1], z[2] = g * E[2], z[3] = Math.cos(B), z;
      }
      function y(z, E) {
        var B = Math.acos(E[3]) * 2, g = Math.sin(B / 2);
        return g > d.EPSILON ? (z[0] = E[0] / g, z[1] = E[1] / g, z[2] = E[2] / g) : (z[0] = 1, z[1] = 0, z[2] = 0), B;
      }
      function o(z, E) {
        var B = O(z, E);
        return Math.acos(2 * B * B - 1);
      }
      function h(z, E, B) {
        var g = E[0], U = E[1], u = E[2], L = E[3], N = B[0], v = B[1], P = B[2], j = B[3];
        return z[0] = g * j + L * N + U * P - u * v, z[1] = U * j + L * v + u * N - g * P, z[2] = u * j + L * P + g * v - U * N, z[3] = L * j - g * N - U * v - u * P, z;
      }
      function I(z, E, B) {
        B *= 0.5;
        var g = E[0], U = E[1], u = E[2], L = E[3], N = Math.sin(B), v = Math.cos(B);
        return z[0] = g * v + L * N, z[1] = U * v + u * N, z[2] = u * v - U * N, z[3] = L * v - g * N, z;
      }
      function x(z, E, B) {
        B *= 0.5;
        var g = E[0], U = E[1], u = E[2], L = E[3], N = Math.sin(B), v = Math.cos(B);
        return z[0] = g * v - u * N, z[1] = U * v + L * N, z[2] = u * v + g * N, z[3] = L * v - U * N, z;
      }
      function p(z, E, B) {
        B *= 0.5;
        var g = E[0], U = E[1], u = E[2], L = E[3], N = Math.sin(B), v = Math.cos(B);
        return z[0] = g * v + U * N, z[1] = U * v - g * N, z[2] = u * v + L * N, z[3] = L * v - u * N, z;
      }
      function W(z, E) {
        var B = E[0], g = E[1], U = E[2];
        return z[0] = B, z[1] = g, z[2] = U, z[3] = Math.sqrt(Math.abs(1 - B * B - g * g - U * U)), z;
      }
      function V(z, E) {
        var B = E[0], g = E[1], U = E[2], u = E[3], L = Math.sqrt(B * B + g * g + U * U), N = Math.exp(u), v = L > 0 ? N * Math.sin(L) / L : 0;
        return z[0] = B * v, z[1] = g * v, z[2] = U * v, z[3] = N * Math.cos(L), z;
      }
      function t(z, E) {
        var B = E[0], g = E[1], U = E[2], u = E[3], L = Math.sqrt(B * B + g * g + U * U), N = L > 0 ? Math.atan2(L, u) / L : 0;
        return z[0] = B * N, z[1] = g * N, z[2] = U * N, z[3] = 0.5 * Math.log(B * B + g * g + U * U + u * u), z;
      }
      function c(z, E, B) {
        return t(z, E), w(z, z, B), V(z, z), z;
      }
      function b(z, E, B, g) {
        var U = E[0], u = E[1], L = E[2], N = E[3], v = B[0], P = B[1], j = B[2], A = B[3], li, di, ci, Zi, si;
        return di = U * v + u * P + L * j + N * A, di < 0 && (di = -di, v = -v, P = -P, j = -j, A = -A), 1 - di > d.EPSILON ? (li = Math.acos(di), ci = Math.sin(li), Zi = Math.sin((1 - g) * li) / ci, si = Math.sin(g * li) / ci) : (Zi = 1 - g, si = g), z[0] = Zi * U + si * v, z[1] = Zi * u + si * P, z[2] = Zi * L + si * j, z[3] = Zi * N + si * A, z;
      }
      function Z(z) {
        var E = d.RANDOM(), B = d.RANDOM(), g = d.RANDOM(), U = Math.sqrt(1 - E), u = Math.sqrt(E);
        return z[0] = U * Math.sin(2 * Math.PI * B), z[1] = U * Math.cos(2 * Math.PI * B), z[2] = u * Math.sin(2 * Math.PI * g), z[3] = u * Math.cos(2 * Math.PI * g), z;
      }
      function r(z, E) {
        var B = E[0], g = E[1], U = E[2], u = E[3], L = B * B + g * g + U * U + u * u, N = L ? 1 / L : 0;
        return z[0] = -B * N, z[1] = -g * N, z[2] = -U * N, z[3] = u * N, z;
      }
      function S(z, E) {
        return z[0] = -E[0], z[1] = -E[1], z[2] = -E[2], z[3] = E[3], z;
      }
      function C(z, E) {
        var B = E[0] + E[4] + E[8], g;
        if (B > 0)
          g = Math.sqrt(B + 1), z[3] = 0.5 * g, g = 0.5 / g, z[0] = (E[5] - E[7]) * g, z[1] = (E[6] - E[2]) * g, z[2] = (E[1] - E[3]) * g;
        else {
          var U = 0;
          E[4] > E[0] && (U = 1), E[8] > E[U * 3 + U] && (U = 2);
          var u = (U + 1) % 3, L = (U + 2) % 3;
          g = Math.sqrt(E[U * 3 + U] - E[u * 3 + u] - E[L * 3 + L] + 1), z[U] = 0.5 * g, g = 0.5 / g, z[3] = (E[u * 3 + L] - E[L * 3 + u]) * g, z[u] = (E[u * 3 + U] + E[U * 3 + u]) * g, z[L] = (E[L * 3 + U] + E[U * 3 + L]) * g;
        }
        return z;
      }
      function F(z, E, B, g) {
        var U = 0.5 * Math.PI / 180;
        E *= U, B *= U, g *= U;
        var u = Math.sin(E), L = Math.cos(E), N = Math.sin(B), v = Math.cos(B), P = Math.sin(g), j = Math.cos(g);
        return z[0] = u * v * j - L * N * P, z[1] = L * N * j + u * v * P, z[2] = L * v * P - u * N * j, z[3] = L * v * j + u * N * P, z;
      }
      function Y(z) {
        return "quat(" + z[0] + ", " + z[1] + ", " + z[2] + ", " + z[3] + ")";
      }
      var J = a.clone, T = a.fromValues, K = a.copy, R = a.set, H = a.add, f = h, w = a.scale, O = a.dot, q = a.lerp, k = a.length, Q = k, D = a.squaredLength, ii = D, _ = a.normalize, bi = a.exactEquals, $ = a.equals, Xi = function() {
        var z = X.create(), E = X.fromValues(1, 0, 0), B = X.fromValues(0, 1, 0);
        return function(g, U, u) {
          var L = X.dot(U, u);
          return L < -0.999999 ? (X.cross(z, E, U), X.len(z) < 1e-6 && X.cross(z, B, U), X.normalize(z, z), G(g, z, Math.PI), g) : L > 0.999999 ? (g[0] = 0, g[1] = 0, g[2] = 0, g[3] = 1, g) : (X.cross(z, U, u), g[0] = z[0], g[1] = z[1], g[2] = z[2], g[3] = 1 + L, _(g, g));
        };
      }(), ni = function() {
        var z = e(), E = e();
        return function(B, g, U, u, L, N) {
          return b(z, g, L, N), b(E, U, u, N), b(B, z, E, 2 * N * (1 - N)), B;
        };
      }(), M = function() {
        var z = s.create();
        return function(E, B, g, U) {
          return z[0] = g[0], z[3] = g[1], z[6] = g[2], z[1] = U[0], z[4] = U[1], z[7] = U[2], z[2] = -B[0], z[5] = -B[1], z[8] = -B[2], _(E, C(E, z));
        };
      }();
    },
    /* 8 */
    /***/
    function(m, l, i) {
      i.r(l), i.d(l, "create", function() {
        return s;
      }), i.d(l, "clone", function() {
        return X;
      }), i.d(l, "length", function() {
        return a;
      }), i.d(l, "fromValues", function() {
        return e;
      }), i.d(l, "copy", function() {
        return n;
      }), i.d(l, "set", function() {
        return G;
      }), i.d(l, "add", function() {
        return y;
      }), i.d(l, "subtract", function() {
        return o;
      }), i.d(l, "multiply", function() {
        return h;
      }), i.d(l, "divide", function() {
        return I;
      }), i.d(l, "ceil", function() {
        return x;
      }), i.d(l, "floor", function() {
        return p;
      }), i.d(l, "min", function() {
        return W;
      }), i.d(l, "max", function() {
        return V;
      }), i.d(l, "round", function() {
        return t;
      }), i.d(l, "scale", function() {
        return c;
      }), i.d(l, "scaleAndAdd", function() {
        return b;
      }), i.d(l, "distance", function() {
        return Z;
      }), i.d(l, "squaredDistance", function() {
        return r;
      }), i.d(l, "squaredLength", function() {
        return S;
      }), i.d(l, "negate", function() {
        return C;
      }), i.d(l, "inverse", function() {
        return F;
      }), i.d(l, "normalize", function() {
        return Y;
      }), i.d(l, "dot", function() {
        return J;
      }), i.d(l, "cross", function() {
        return T;
      }), i.d(l, "lerp", function() {
        return K;
      }), i.d(l, "hermite", function() {
        return R;
      }), i.d(l, "bezier", function() {
        return H;
      }), i.d(l, "random", function() {
        return f;
      }), i.d(l, "transformMat4", function() {
        return w;
      }), i.d(l, "transformMat3", function() {
        return O;
      }), i.d(l, "transformQuat", function() {
        return q;
      }), i.d(l, "rotateX", function() {
        return k;
      }), i.d(l, "rotateY", function() {
        return Q;
      }), i.d(l, "rotateZ", function() {
        return D;
      }), i.d(l, "angle", function() {
        return ii;
      }), i.d(l, "zero", function() {
        return _;
      }), i.d(l, "str", function() {
        return bi;
      }), i.d(l, "exactEquals", function() {
        return $;
      }), i.d(l, "equals", function() {
        return Xi;
      }), i.d(l, "sub", function() {
        return ni;
      }), i.d(l, "mul", function() {
        return M;
      }), i.d(l, "div", function() {
        return z;
      }), i.d(l, "dist", function() {
        return E;
      }), i.d(l, "sqrDist", function() {
        return B;
      }), i.d(l, "len", function() {
        return g;
      }), i.d(l, "sqrLen", function() {
        return U;
      }), i.d(l, "forEach", function() {
        return u;
      });
      var d = i(2);
      function s() {
        var L = new d.ARRAY_TYPE(3);
        return d.ARRAY_TYPE != Float32Array && (L[0] = 0, L[1] = 0, L[2] = 0), L;
      }
      function X(L) {
        var N = new d.ARRAY_TYPE(3);
        return N[0] = L[0], N[1] = L[1], N[2] = L[2], N;
      }
      function a(L) {
        var N = L[0], v = L[1], P = L[2];
        return Math.hypot(N, v, P);
      }
      function e(L, N, v) {
        var P = new d.ARRAY_TYPE(3);
        return P[0] = L, P[1] = N, P[2] = v, P;
      }
      function n(L, N) {
        return L[0] = N[0], L[1] = N[1], L[2] = N[2], L;
      }
      function G(L, N, v, P) {
        return L[0] = N, L[1] = v, L[2] = P, L;
      }
      function y(L, N, v) {
        return L[0] = N[0] + v[0], L[1] = N[1] + v[1], L[2] = N[2] + v[2], L;
      }
      function o(L, N, v) {
        return L[0] = N[0] - v[0], L[1] = N[1] - v[1], L[2] = N[2] - v[2], L;
      }
      function h(L, N, v) {
        return L[0] = N[0] * v[0], L[1] = N[1] * v[1], L[2] = N[2] * v[2], L;
      }
      function I(L, N, v) {
        return L[0] = N[0] / v[0], L[1] = N[1] / v[1], L[2] = N[2] / v[2], L;
      }
      function x(L, N) {
        return L[0] = Math.ceil(N[0]), L[1] = Math.ceil(N[1]), L[2] = Math.ceil(N[2]), L;
      }
      function p(L, N) {
        return L[0] = Math.floor(N[0]), L[1] = Math.floor(N[1]), L[2] = Math.floor(N[2]), L;
      }
      function W(L, N, v) {
        return L[0] = Math.min(N[0], v[0]), L[1] = Math.min(N[1], v[1]), L[2] = Math.min(N[2], v[2]), L;
      }
      function V(L, N, v) {
        return L[0] = Math.max(N[0], v[0]), L[1] = Math.max(N[1], v[1]), L[2] = Math.max(N[2], v[2]), L;
      }
      function t(L, N) {
        return L[0] = Math.round(N[0]), L[1] = Math.round(N[1]), L[2] = Math.round(N[2]), L;
      }
      function c(L, N, v) {
        return L[0] = N[0] * v, L[1] = N[1] * v, L[2] = N[2] * v, L;
      }
      function b(L, N, v, P) {
        return L[0] = N[0] + v[0] * P, L[1] = N[1] + v[1] * P, L[2] = N[2] + v[2] * P, L;
      }
      function Z(L, N) {
        var v = N[0] - L[0], P = N[1] - L[1], j = N[2] - L[2];
        return Math.hypot(v, P, j);
      }
      function r(L, N) {
        var v = N[0] - L[0], P = N[1] - L[1], j = N[2] - L[2];
        return v * v + P * P + j * j;
      }
      function S(L) {
        var N = L[0], v = L[1], P = L[2];
        return N * N + v * v + P * P;
      }
      function C(L, N) {
        return L[0] = -N[0], L[1] = -N[1], L[2] = -N[2], L;
      }
      function F(L, N) {
        return L[0] = 1 / N[0], L[1] = 1 / N[1], L[2] = 1 / N[2], L;
      }
      function Y(L, N) {
        var v = N[0], P = N[1], j = N[2], A = v * v + P * P + j * j;
        return A > 0 && (A = 1 / Math.sqrt(A)), L[0] = N[0] * A, L[1] = N[1] * A, L[2] = N[2] * A, L;
      }
      function J(L, N) {
        return L[0] * N[0] + L[1] * N[1] + L[2] * N[2];
      }
      function T(L, N, v) {
        var P = N[0], j = N[1], A = N[2], li = v[0], di = v[1], ci = v[2];
        return L[0] = j * ci - A * di, L[1] = A * li - P * ci, L[2] = P * di - j * li, L;
      }
      function K(L, N, v, P) {
        var j = N[0], A = N[1], li = N[2];
        return L[0] = j + P * (v[0] - j), L[1] = A + P * (v[1] - A), L[2] = li + P * (v[2] - li), L;
      }
      function R(L, N, v, P, j, A) {
        var li = A * A, di = li * (2 * A - 3) + 1, ci = li * (A - 2) + A, Zi = li * (A - 1), si = li * (3 - 2 * A);
        return L[0] = N[0] * di + v[0] * ci + P[0] * Zi + j[0] * si, L[1] = N[1] * di + v[1] * ci + P[1] * Zi + j[1] * si, L[2] = N[2] * di + v[2] * ci + P[2] * Zi + j[2] * si, L;
      }
      function H(L, N, v, P, j, A) {
        var li = 1 - A, di = li * li, ci = A * A, Zi = di * li, si = 3 * A * di, ti = 3 * ci * li, mi = ci * A;
        return L[0] = N[0] * Zi + v[0] * si + P[0] * ti + j[0] * mi, L[1] = N[1] * Zi + v[1] * si + P[1] * ti + j[1] * mi, L[2] = N[2] * Zi + v[2] * si + P[2] * ti + j[2] * mi, L;
      }
      function f(L, N) {
        N = N || 1;
        var v = d.RANDOM() * 2 * Math.PI, P = d.RANDOM() * 2 - 1, j = Math.sqrt(1 - P * P) * N;
        return L[0] = Math.cos(v) * j, L[1] = Math.sin(v) * j, L[2] = P * N, L;
      }
      function w(L, N, v) {
        var P = N[0], j = N[1], A = N[2], li = v[3] * P + v[7] * j + v[11] * A + v[15];
        return li = li || 1, L[0] = (v[0] * P + v[4] * j + v[8] * A + v[12]) / li, L[1] = (v[1] * P + v[5] * j + v[9] * A + v[13]) / li, L[2] = (v[2] * P + v[6] * j + v[10] * A + v[14]) / li, L;
      }
      function O(L, N, v) {
        var P = N[0], j = N[1], A = N[2];
        return L[0] = P * v[0] + j * v[3] + A * v[6], L[1] = P * v[1] + j * v[4] + A * v[7], L[2] = P * v[2] + j * v[5] + A * v[8], L;
      }
      function q(L, N, v) {
        var P = v[0], j = v[1], A = v[2], li = v[3], di = N[0], ci = N[1], Zi = N[2], si = j * Zi - A * ci, ti = A * di - P * Zi, mi = P * ci - j * di, oi = j * mi - A * ti, ai = A * si - P * mi, ei = P * ti - j * si, Vi = li * 2;
        return si *= Vi, ti *= Vi, mi *= Vi, oi *= 2, ai *= 2, ei *= 2, L[0] = di + si + oi, L[1] = ci + ti + ai, L[2] = Zi + mi + ei, L;
      }
      function k(L, N, v, P) {
        var j = [], A = [];
        return j[0] = N[0] - v[0], j[1] = N[1] - v[1], j[2] = N[2] - v[2], A[0] = j[0], A[1] = j[1] * Math.cos(P) - j[2] * Math.sin(P), A[2] = j[1] * Math.sin(P) + j[2] * Math.cos(P), L[0] = A[0] + v[0], L[1] = A[1] + v[1], L[2] = A[2] + v[2], L;
      }
      function Q(L, N, v, P) {
        var j = [], A = [];
        return j[0] = N[0] - v[0], j[1] = N[1] - v[1], j[2] = N[2] - v[2], A[0] = j[2] * Math.sin(P) + j[0] * Math.cos(P), A[1] = j[1], A[2] = j[2] * Math.cos(P) - j[0] * Math.sin(P), L[0] = A[0] + v[0], L[1] = A[1] + v[1], L[2] = A[2] + v[2], L;
      }
      function D(L, N, v, P) {
        var j = [], A = [];
        return j[0] = N[0] - v[0], j[1] = N[1] - v[1], j[2] = N[2] - v[2], A[0] = j[0] * Math.cos(P) - j[1] * Math.sin(P), A[1] = j[0] * Math.sin(P) + j[1] * Math.cos(P), A[2] = j[2], L[0] = A[0] + v[0], L[1] = A[1] + v[1], L[2] = A[2] + v[2], L;
      }
      function ii(L, N) {
        var v = L[0], P = L[1], j = L[2], A = N[0], li = N[1], di = N[2], ci = Math.sqrt(v * v + P * P + j * j), Zi = Math.sqrt(A * A + li * li + di * di), si = ci * Zi, ti = si && J(L, N) / si;
        return Math.acos(Math.min(Math.max(ti, -1), 1));
      }
      function _(L) {
        return L[0] = 0, L[1] = 0, L[2] = 0, L;
      }
      function bi(L) {
        return "vec3(" + L[0] + ", " + L[1] + ", " + L[2] + ")";
      }
      function $(L, N) {
        return L[0] === N[0] && L[1] === N[1] && L[2] === N[2];
      }
      function Xi(L, N) {
        var v = L[0], P = L[1], j = L[2], A = N[0], li = N[1], di = N[2];
        return Math.abs(v - A) <= d.EPSILON * Math.max(1, Math.abs(v), Math.abs(A)) && Math.abs(P - li) <= d.EPSILON * Math.max(1, Math.abs(P), Math.abs(li)) && Math.abs(j - di) <= d.EPSILON * Math.max(1, Math.abs(j), Math.abs(di));
      }
      var ni = o, M = h, z = I, E = Z, B = r, g = a, U = S, u = function() {
        var L = s();
        return function(N, v, P, j, A, li) {
          var di, ci;
          for (v || (v = 3), P || (P = 0), j ? ci = Math.min(j * v + P, N.length) : ci = N.length, di = P; di < ci; di += v)
            L[0] = N[di], L[1] = N[di + 1], L[2] = N[di + 2], A(L, L, li), N[di] = L[0], N[di + 1] = L[1], N[di + 2] = L[2];
          return N;
        };
      }();
    },
    /* 9 */
    /***/
    function(m, l, i) {
      i.r(l), i.d(l, "create", function() {
        return s;
      }), i.d(l, "clone", function() {
        return X;
      }), i.d(l, "fromValues", function() {
        return a;
      }), i.d(l, "copy", function() {
        return e;
      }), i.d(l, "set", function() {
        return n;
      }), i.d(l, "add", function() {
        return G;
      }), i.d(l, "subtract", function() {
        return y;
      }), i.d(l, "multiply", function() {
        return o;
      }), i.d(l, "divide", function() {
        return h;
      }), i.d(l, "ceil", function() {
        return I;
      }), i.d(l, "floor", function() {
        return x;
      }), i.d(l, "min", function() {
        return p;
      }), i.d(l, "max", function() {
        return W;
      }), i.d(l, "round", function() {
        return V;
      }), i.d(l, "scale", function() {
        return t;
      }), i.d(l, "scaleAndAdd", function() {
        return c;
      }), i.d(l, "distance", function() {
        return b;
      }), i.d(l, "squaredDistance", function() {
        return Z;
      }), i.d(l, "length", function() {
        return r;
      }), i.d(l, "squaredLength", function() {
        return S;
      }), i.d(l, "negate", function() {
        return C;
      }), i.d(l, "inverse", function() {
        return F;
      }), i.d(l, "normalize", function() {
        return Y;
      }), i.d(l, "dot", function() {
        return J;
      }), i.d(l, "cross", function() {
        return T;
      }), i.d(l, "lerp", function() {
        return K;
      }), i.d(l, "random", function() {
        return R;
      }), i.d(l, "transformMat4", function() {
        return H;
      }), i.d(l, "transformQuat", function() {
        return f;
      }), i.d(l, "zero", function() {
        return w;
      }), i.d(l, "str", function() {
        return O;
      }), i.d(l, "exactEquals", function() {
        return q;
      }), i.d(l, "equals", function() {
        return k;
      }), i.d(l, "sub", function() {
        return Q;
      }), i.d(l, "mul", function() {
        return D;
      }), i.d(l, "div", function() {
        return ii;
      }), i.d(l, "dist", function() {
        return _;
      }), i.d(l, "sqrDist", function() {
        return bi;
      }), i.d(l, "len", function() {
        return $;
      }), i.d(l, "sqrLen", function() {
        return Xi;
      }), i.d(l, "forEach", function() {
        return ni;
      });
      var d = i(2);
      function s() {
        var M = new d.ARRAY_TYPE(4);
        return d.ARRAY_TYPE != Float32Array && (M[0] = 0, M[1] = 0, M[2] = 0, M[3] = 0), M;
      }
      function X(M) {
        var z = new d.ARRAY_TYPE(4);
        return z[0] = M[0], z[1] = M[1], z[2] = M[2], z[3] = M[3], z;
      }
      function a(M, z, E, B) {
        var g = new d.ARRAY_TYPE(4);
        return g[0] = M, g[1] = z, g[2] = E, g[3] = B, g;
      }
      function e(M, z) {
        return M[0] = z[0], M[1] = z[1], M[2] = z[2], M[3] = z[3], M;
      }
      function n(M, z, E, B, g) {
        return M[0] = z, M[1] = E, M[2] = B, M[3] = g, M;
      }
      function G(M, z, E) {
        return M[0] = z[0] + E[0], M[1] = z[1] + E[1], M[2] = z[2] + E[2], M[3] = z[3] + E[3], M;
      }
      function y(M, z, E) {
        return M[0] = z[0] - E[0], M[1] = z[1] - E[1], M[2] = z[2] - E[2], M[3] = z[3] - E[3], M;
      }
      function o(M, z, E) {
        return M[0] = z[0] * E[0], M[1] = z[1] * E[1], M[2] = z[2] * E[2], M[3] = z[3] * E[3], M;
      }
      function h(M, z, E) {
        return M[0] = z[0] / E[0], M[1] = z[1] / E[1], M[2] = z[2] / E[2], M[3] = z[3] / E[3], M;
      }
      function I(M, z) {
        return M[0] = Math.ceil(z[0]), M[1] = Math.ceil(z[1]), M[2] = Math.ceil(z[2]), M[3] = Math.ceil(z[3]), M;
      }
      function x(M, z) {
        return M[0] = Math.floor(z[0]), M[1] = Math.floor(z[1]), M[2] = Math.floor(z[2]), M[3] = Math.floor(z[3]), M;
      }
      function p(M, z, E) {
        return M[0] = Math.min(z[0], E[0]), M[1] = Math.min(z[1], E[1]), M[2] = Math.min(z[2], E[2]), M[3] = Math.min(z[3], E[3]), M;
      }
      function W(M, z, E) {
        return M[0] = Math.max(z[0], E[0]), M[1] = Math.max(z[1], E[1]), M[2] = Math.max(z[2], E[2]), M[3] = Math.max(z[3], E[3]), M;
      }
      function V(M, z) {
        return M[0] = Math.round(z[0]), M[1] = Math.round(z[1]), M[2] = Math.round(z[2]), M[3] = Math.round(z[3]), M;
      }
      function t(M, z, E) {
        return M[0] = z[0] * E, M[1] = z[1] * E, M[2] = z[2] * E, M[3] = z[3] * E, M;
      }
      function c(M, z, E, B) {
        return M[0] = z[0] + E[0] * B, M[1] = z[1] + E[1] * B, M[2] = z[2] + E[2] * B, M[3] = z[3] + E[3] * B, M;
      }
      function b(M, z) {
        var E = z[0] - M[0], B = z[1] - M[1], g = z[2] - M[2], U = z[3] - M[3];
        return Math.hypot(E, B, g, U);
      }
      function Z(M, z) {
        var E = z[0] - M[0], B = z[1] - M[1], g = z[2] - M[2], U = z[3] - M[3];
        return E * E + B * B + g * g + U * U;
      }
      function r(M) {
        var z = M[0], E = M[1], B = M[2], g = M[3];
        return Math.hypot(z, E, B, g);
      }
      function S(M) {
        var z = M[0], E = M[1], B = M[2], g = M[3];
        return z * z + E * E + B * B + g * g;
      }
      function C(M, z) {
        return M[0] = -z[0], M[1] = -z[1], M[2] = -z[2], M[3] = -z[3], M;
      }
      function F(M, z) {
        return M[0] = 1 / z[0], M[1] = 1 / z[1], M[2] = 1 / z[2], M[3] = 1 / z[3], M;
      }
      function Y(M, z) {
        var E = z[0], B = z[1], g = z[2], U = z[3], u = E * E + B * B + g * g + U * U;
        return u > 0 && (u = 1 / Math.sqrt(u)), M[0] = E * u, M[1] = B * u, M[2] = g * u, M[3] = U * u, M;
      }
      function J(M, z) {
        return M[0] * z[0] + M[1] * z[1] + M[2] * z[2] + M[3] * z[3];
      }
      function T(M, z, E, B) {
        var g = E[0] * B[1] - E[1] * B[0], U = E[0] * B[2] - E[2] * B[0], u = E[0] * B[3] - E[3] * B[0], L = E[1] * B[2] - E[2] * B[1], N = E[1] * B[3] - E[3] * B[1], v = E[2] * B[3] - E[3] * B[2], P = z[0], j = z[1], A = z[2], li = z[3];
        return M[0] = j * v - A * N + li * L, M[1] = -(P * v) + A * u - li * U, M[2] = P * N - j * u + li * g, M[3] = -(P * L) + j * U - A * g, M;
      }
      function K(M, z, E, B) {
        var g = z[0], U = z[1], u = z[2], L = z[3];
        return M[0] = g + B * (E[0] - g), M[1] = U + B * (E[1] - U), M[2] = u + B * (E[2] - u), M[3] = L + B * (E[3] - L), M;
      }
      function R(M, z) {
        z = z || 1;
        var E, B, g, U, u, L;
        do
          E = d.RANDOM() * 2 - 1, B = d.RANDOM() * 2 - 1, u = E * E + B * B;
        while (u >= 1);
        do
          g = d.RANDOM() * 2 - 1, U = d.RANDOM() * 2 - 1, L = g * g + U * U;
        while (L >= 1);
        var N = Math.sqrt((1 - u) / L);
        return M[0] = z * E, M[1] = z * B, M[2] = z * g * N, M[3] = z * U * N, M;
      }
      function H(M, z, E) {
        var B = z[0], g = z[1], U = z[2], u = z[3];
        return M[0] = E[0] * B + E[4] * g + E[8] * U + E[12] * u, M[1] = E[1] * B + E[5] * g + E[9] * U + E[13] * u, M[2] = E[2] * B + E[6] * g + E[10] * U + E[14] * u, M[3] = E[3] * B + E[7] * g + E[11] * U + E[15] * u, M;
      }
      function f(M, z, E) {
        var B = z[0], g = z[1], U = z[2], u = E[0], L = E[1], N = E[2], v = E[3], P = v * B + L * U - N * g, j = v * g + N * B - u * U, A = v * U + u * g - L * B, li = -u * B - L * g - N * U;
        return M[0] = P * v + li * -u + j * -N - A * -L, M[1] = j * v + li * -L + A * -u - P * -N, M[2] = A * v + li * -N + P * -L - j * -u, M[3] = z[3], M;
      }
      function w(M) {
        return M[0] = 0, M[1] = 0, M[2] = 0, M[3] = 0, M;
      }
      function O(M) {
        return "vec4(" + M[0] + ", " + M[1] + ", " + M[2] + ", " + M[3] + ")";
      }
      function q(M, z) {
        return M[0] === z[0] && M[1] === z[1] && M[2] === z[2] && M[3] === z[3];
      }
      function k(M, z) {
        var E = M[0], B = M[1], g = M[2], U = M[3], u = z[0], L = z[1], N = z[2], v = z[3];
        return Math.abs(E - u) <= d.EPSILON * Math.max(1, Math.abs(E), Math.abs(u)) && Math.abs(B - L) <= d.EPSILON * Math.max(1, Math.abs(B), Math.abs(L)) && Math.abs(g - N) <= d.EPSILON * Math.max(1, Math.abs(g), Math.abs(N)) && Math.abs(U - v) <= d.EPSILON * Math.max(1, Math.abs(U), Math.abs(v));
      }
      var Q = y, D = o, ii = h, _ = b, bi = Z, $ = r, Xi = S, ni = function() {
        var M = s();
        return function(z, E, B, g, U, u) {
          var L, N;
          for (E || (E = 4), B || (B = 0), g ? N = Math.min(g * E + B, z.length) : N = z.length, L = B; L < N; L += E)
            M[0] = z[L], M[1] = z[L + 1], M[2] = z[L + 2], M[3] = z[L + 3], U(M, M, u), z[L] = M[0], z[L + 1] = M[1], z[L + 2] = M[2], z[L + 3] = M[3];
          return z;
        };
      }();
    },
    /* 10 */
    /***/
    function(m, l, i) {
      i.r(l), i.d(l, "create", function() {
        return a;
      }), i.d(l, "clone", function() {
        return e;
      }), i.d(l, "fromValues", function() {
        return n;
      }), i.d(l, "fromRotationTranslationValues", function() {
        return G;
      }), i.d(l, "fromRotationTranslation", function() {
        return y;
      }), i.d(l, "fromTranslation", function() {
        return o;
      }), i.d(l, "fromRotation", function() {
        return h;
      }), i.d(l, "fromMat4", function() {
        return I;
      }), i.d(l, "copy", function() {
        return x;
      }), i.d(l, "identity", function() {
        return p;
      }), i.d(l, "set", function() {
        return W;
      }), i.d(l, "getReal", function() {
        return V;
      }), i.d(l, "getDual", function() {
        return t;
      }), i.d(l, "setReal", function() {
        return c;
      }), i.d(l, "setDual", function() {
        return b;
      }), i.d(l, "getTranslation", function() {
        return Z;
      }), i.d(l, "translate", function() {
        return r;
      }), i.d(l, "rotateX", function() {
        return S;
      }), i.d(l, "rotateY", function() {
        return C;
      }), i.d(l, "rotateZ", function() {
        return F;
      }), i.d(l, "rotateByQuatAppend", function() {
        return Y;
      }), i.d(l, "rotateByQuatPrepend", function() {
        return J;
      }), i.d(l, "rotateAroundAxis", function() {
        return T;
      }), i.d(l, "add", function() {
        return K;
      }), i.d(l, "multiply", function() {
        return R;
      }), i.d(l, "mul", function() {
        return H;
      }), i.d(l, "scale", function() {
        return f;
      }), i.d(l, "dot", function() {
        return w;
      }), i.d(l, "lerp", function() {
        return O;
      }), i.d(l, "invert", function() {
        return q;
      }), i.d(l, "conjugate", function() {
        return k;
      }), i.d(l, "length", function() {
        return Q;
      }), i.d(l, "len", function() {
        return D;
      }), i.d(l, "squaredLength", function() {
        return ii;
      }), i.d(l, "sqrLen", function() {
        return _;
      }), i.d(l, "normalize", function() {
        return bi;
      }), i.d(l, "str", function() {
        return $;
      }), i.d(l, "exactEquals", function() {
        return Xi;
      }), i.d(l, "equals", function() {
        return ni;
      });
      var d = i(2), s = i(7), X = i(6);
      function a() {
        var M = new d.ARRAY_TYPE(8);
        return d.ARRAY_TYPE != Float32Array && (M[0] = 0, M[1] = 0, M[2] = 0, M[4] = 0, M[5] = 0, M[6] = 0, M[7] = 0), M[3] = 1, M;
      }
      function e(M) {
        var z = new d.ARRAY_TYPE(8);
        return z[0] = M[0], z[1] = M[1], z[2] = M[2], z[3] = M[3], z[4] = M[4], z[5] = M[5], z[6] = M[6], z[7] = M[7], z;
      }
      function n(M, z, E, B, g, U, u, L) {
        var N = new d.ARRAY_TYPE(8);
        return N[0] = M, N[1] = z, N[2] = E, N[3] = B, N[4] = g, N[5] = U, N[6] = u, N[7] = L, N;
      }
      function G(M, z, E, B, g, U, u) {
        var L = new d.ARRAY_TYPE(8);
        L[0] = M, L[1] = z, L[2] = E, L[3] = B;
        var N = g * 0.5, v = U * 0.5, P = u * 0.5;
        return L[4] = N * B + v * E - P * z, L[5] = v * B + P * M - N * E, L[6] = P * B + N * z - v * M, L[7] = -N * M - v * z - P * E, L;
      }
      function y(M, z, E) {
        var B = E[0] * 0.5, g = E[1] * 0.5, U = E[2] * 0.5, u = z[0], L = z[1], N = z[2], v = z[3];
        return M[0] = u, M[1] = L, M[2] = N, M[3] = v, M[4] = B * v + g * N - U * L, M[5] = g * v + U * u - B * N, M[6] = U * v + B * L - g * u, M[7] = -B * u - g * L - U * N, M;
      }
      function o(M, z) {
        return M[0] = 0, M[1] = 0, M[2] = 0, M[3] = 1, M[4] = z[0] * 0.5, M[5] = z[1] * 0.5, M[6] = z[2] * 0.5, M[7] = 0, M;
      }
      function h(M, z) {
        return M[0] = z[0], M[1] = z[1], M[2] = z[2], M[3] = z[3], M[4] = 0, M[5] = 0, M[6] = 0, M[7] = 0, M;
      }
      function I(M, z) {
        var E = s.create();
        X.getRotation(E, z);
        var B = new d.ARRAY_TYPE(3);
        return X.getTranslation(B, z), y(M, E, B), M;
      }
      function x(M, z) {
        return M[0] = z[0], M[1] = z[1], M[2] = z[2], M[3] = z[3], M[4] = z[4], M[5] = z[5], M[6] = z[6], M[7] = z[7], M;
      }
      function p(M) {
        return M[0] = 0, M[1] = 0, M[2] = 0, M[3] = 1, M[4] = 0, M[5] = 0, M[6] = 0, M[7] = 0, M;
      }
      function W(M, z, E, B, g, U, u, L, N) {
        return M[0] = z, M[1] = E, M[2] = B, M[3] = g, M[4] = U, M[5] = u, M[6] = L, M[7] = N, M;
      }
      var V = s.copy;
      function t(M, z) {
        return M[0] = z[4], M[1] = z[5], M[2] = z[6], M[3] = z[7], M;
      }
      var c = s.copy;
      function b(M, z) {
        return M[4] = z[0], M[5] = z[1], M[6] = z[2], M[7] = z[3], M;
      }
      function Z(M, z) {
        var E = z[4], B = z[5], g = z[6], U = z[7], u = -z[0], L = -z[1], N = -z[2], v = z[3];
        return M[0] = (E * v + U * u + B * N - g * L) * 2, M[1] = (B * v + U * L + g * u - E * N) * 2, M[2] = (g * v + U * N + E * L - B * u) * 2, M;
      }
      function r(M, z, E) {
        var B = z[0], g = z[1], U = z[2], u = z[3], L = E[0] * 0.5, N = E[1] * 0.5, v = E[2] * 0.5, P = z[4], j = z[5], A = z[6], li = z[7];
        return M[0] = B, M[1] = g, M[2] = U, M[3] = u, M[4] = u * L + g * v - U * N + P, M[5] = u * N + U * L - B * v + j, M[6] = u * v + B * N - g * L + A, M[7] = -B * L - g * N - U * v + li, M;
      }
      function S(M, z, E) {
        var B = -z[0], g = -z[1], U = -z[2], u = z[3], L = z[4], N = z[5], v = z[6], P = z[7], j = L * u + P * B + N * U - v * g, A = N * u + P * g + v * B - L * U, li = v * u + P * U + L * g - N * B, di = P * u - L * B - N * g - v * U;
        return s.rotateX(M, z, E), B = M[0], g = M[1], U = M[2], u = M[3], M[4] = j * u + di * B + A * U - li * g, M[5] = A * u + di * g + li * B - j * U, M[6] = li * u + di * U + j * g - A * B, M[7] = di * u - j * B - A * g - li * U, M;
      }
      function C(M, z, E) {
        var B = -z[0], g = -z[1], U = -z[2], u = z[3], L = z[4], N = z[5], v = z[6], P = z[7], j = L * u + P * B + N * U - v * g, A = N * u + P * g + v * B - L * U, li = v * u + P * U + L * g - N * B, di = P * u - L * B - N * g - v * U;
        return s.rotateY(M, z, E), B = M[0], g = M[1], U = M[2], u = M[3], M[4] = j * u + di * B + A * U - li * g, M[5] = A * u + di * g + li * B - j * U, M[6] = li * u + di * U + j * g - A * B, M[7] = di * u - j * B - A * g - li * U, M;
      }
      function F(M, z, E) {
        var B = -z[0], g = -z[1], U = -z[2], u = z[3], L = z[4], N = z[5], v = z[6], P = z[7], j = L * u + P * B + N * U - v * g, A = N * u + P * g + v * B - L * U, li = v * u + P * U + L * g - N * B, di = P * u - L * B - N * g - v * U;
        return s.rotateZ(M, z, E), B = M[0], g = M[1], U = M[2], u = M[3], M[4] = j * u + di * B + A * U - li * g, M[5] = A * u + di * g + li * B - j * U, M[6] = li * u + di * U + j * g - A * B, M[7] = di * u - j * B - A * g - li * U, M;
      }
      function Y(M, z, E) {
        var B = E[0], g = E[1], U = E[2], u = E[3], L = z[0], N = z[1], v = z[2], P = z[3];
        return M[0] = L * u + P * B + N * U - v * g, M[1] = N * u + P * g + v * B - L * U, M[2] = v * u + P * U + L * g - N * B, M[3] = P * u - L * B - N * g - v * U, L = z[4], N = z[5], v = z[6], P = z[7], M[4] = L * u + P * B + N * U - v * g, M[5] = N * u + P * g + v * B - L * U, M[6] = v * u + P * U + L * g - N * B, M[7] = P * u - L * B - N * g - v * U, M;
      }
      function J(M, z, E) {
        var B = z[0], g = z[1], U = z[2], u = z[3], L = E[0], N = E[1], v = E[2], P = E[3];
        return M[0] = B * P + u * L + g * v - U * N, M[1] = g * P + u * N + U * L - B * v, M[2] = U * P + u * v + B * N - g * L, M[3] = u * P - B * L - g * N - U * v, L = E[4], N = E[5], v = E[6], P = E[7], M[4] = B * P + u * L + g * v - U * N, M[5] = g * P + u * N + U * L - B * v, M[6] = U * P + u * v + B * N - g * L, M[7] = u * P - B * L - g * N - U * v, M;
      }
      function T(M, z, E, B) {
        if (Math.abs(B) < d.EPSILON)
          return x(M, z);
        var g = Math.hypot(E[0], E[1], E[2]);
        B = B * 0.5;
        var U = Math.sin(B), u = U * E[0] / g, L = U * E[1] / g, N = U * E[2] / g, v = Math.cos(B), P = z[0], j = z[1], A = z[2], li = z[3];
        M[0] = P * v + li * u + j * N - A * L, M[1] = j * v + li * L + A * u - P * N, M[2] = A * v + li * N + P * L - j * u, M[3] = li * v - P * u - j * L - A * N;
        var di = z[4], ci = z[5], Zi = z[6], si = z[7];
        return M[4] = di * v + si * u + ci * N - Zi * L, M[5] = ci * v + si * L + Zi * u - di * N, M[6] = Zi * v + si * N + di * L - ci * u, M[7] = si * v - di * u - ci * L - Zi * N, M;
      }
      function K(M, z, E) {
        return M[0] = z[0] + E[0], M[1] = z[1] + E[1], M[2] = z[2] + E[2], M[3] = z[3] + E[3], M[4] = z[4] + E[4], M[5] = z[5] + E[5], M[6] = z[6] + E[6], M[7] = z[7] + E[7], M;
      }
      function R(M, z, E) {
        var B = z[0], g = z[1], U = z[2], u = z[3], L = E[4], N = E[5], v = E[6], P = E[7], j = z[4], A = z[5], li = z[6], di = z[7], ci = E[0], Zi = E[1], si = E[2], ti = E[3];
        return M[0] = B * ti + u * ci + g * si - U * Zi, M[1] = g * ti + u * Zi + U * ci - B * si, M[2] = U * ti + u * si + B * Zi - g * ci, M[3] = u * ti - B * ci - g * Zi - U * si, M[4] = B * P + u * L + g * v - U * N + j * ti + di * ci + A * si - li * Zi, M[5] = g * P + u * N + U * L - B * v + A * ti + di * Zi + li * ci - j * si, M[6] = U * P + u * v + B * N - g * L + li * ti + di * si + j * Zi - A * ci, M[7] = u * P - B * L - g * N - U * v + di * ti - j * ci - A * Zi - li * si, M;
      }
      var H = R;
      function f(M, z, E) {
        return M[0] = z[0] * E, M[1] = z[1] * E, M[2] = z[2] * E, M[3] = z[3] * E, M[4] = z[4] * E, M[5] = z[5] * E, M[6] = z[6] * E, M[7] = z[7] * E, M;
      }
      var w = s.dot;
      function O(M, z, E, B) {
        var g = 1 - B;
        return w(z, E) < 0 && (B = -B), M[0] = z[0] * g + E[0] * B, M[1] = z[1] * g + E[1] * B, M[2] = z[2] * g + E[2] * B, M[3] = z[3] * g + E[3] * B, M[4] = z[4] * g + E[4] * B, M[5] = z[5] * g + E[5] * B, M[6] = z[6] * g + E[6] * B, M[7] = z[7] * g + E[7] * B, M;
      }
      function q(M, z) {
        var E = ii(z);
        return M[0] = -z[0] / E, M[1] = -z[1] / E, M[2] = -z[2] / E, M[3] = z[3] / E, M[4] = -z[4] / E, M[5] = -z[5] / E, M[6] = -z[6] / E, M[7] = z[7] / E, M;
      }
      function k(M, z) {
        return M[0] = -z[0], M[1] = -z[1], M[2] = -z[2], M[3] = z[3], M[4] = -z[4], M[5] = -z[5], M[6] = -z[6], M[7] = z[7], M;
      }
      var Q = s.length, D = Q, ii = s.squaredLength, _ = ii;
      function bi(M, z) {
        var E = ii(z);
        if (E > 0) {
          E = Math.sqrt(E);
          var B = z[0] / E, g = z[1] / E, U = z[2] / E, u = z[3] / E, L = z[4], N = z[5], v = z[6], P = z[7], j = B * L + g * N + U * v + u * P;
          M[0] = B, M[1] = g, M[2] = U, M[3] = u, M[4] = (L - B * j) / E, M[5] = (N - g * j) / E, M[6] = (v - U * j) / E, M[7] = (P - u * j) / E;
        }
        return M;
      }
      function $(M) {
        return "quat2(" + M[0] + ", " + M[1] + ", " + M[2] + ", " + M[3] + ", " + M[4] + ", " + M[5] + ", " + M[6] + ", " + M[7] + ")";
      }
      function Xi(M, z) {
        return M[0] === z[0] && M[1] === z[1] && M[2] === z[2] && M[3] === z[3] && M[4] === z[4] && M[5] === z[5] && M[6] === z[6] && M[7] === z[7];
      }
      function ni(M, z) {
        var E = M[0], B = M[1], g = M[2], U = M[3], u = M[4], L = M[5], N = M[6], v = M[7], P = z[0], j = z[1], A = z[2], li = z[3], di = z[4], ci = z[5], Zi = z[6], si = z[7];
        return Math.abs(E - P) <= d.EPSILON * Math.max(1, Math.abs(E), Math.abs(P)) && Math.abs(B - j) <= d.EPSILON * Math.max(1, Math.abs(B), Math.abs(j)) && Math.abs(g - A) <= d.EPSILON * Math.max(1, Math.abs(g), Math.abs(A)) && Math.abs(U - li) <= d.EPSILON * Math.max(1, Math.abs(U), Math.abs(li)) && Math.abs(u - di) <= d.EPSILON * Math.max(1, Math.abs(u), Math.abs(di)) && Math.abs(L - ci) <= d.EPSILON * Math.max(1, Math.abs(L), Math.abs(ci)) && Math.abs(N - Zi) <= d.EPSILON * Math.max(1, Math.abs(N), Math.abs(Zi)) && Math.abs(v - si) <= d.EPSILON * Math.max(1, Math.abs(v), Math.abs(si));
      }
    },
    /* 11 */
    /***/
    function(m, l, i) {
      i.r(l), i.d(l, "create", function() {
        return s;
      }), i.d(l, "clone", function() {
        return X;
      }), i.d(l, "fromValues", function() {
        return a;
      }), i.d(l, "copy", function() {
        return e;
      }), i.d(l, "set", function() {
        return n;
      }), i.d(l, "add", function() {
        return G;
      }), i.d(l, "subtract", function() {
        return y;
      }), i.d(l, "multiply", function() {
        return o;
      }), i.d(l, "divide", function() {
        return h;
      }), i.d(l, "ceil", function() {
        return I;
      }), i.d(l, "floor", function() {
        return x;
      }), i.d(l, "min", function() {
        return p;
      }), i.d(l, "max", function() {
        return W;
      }), i.d(l, "round", function() {
        return V;
      }), i.d(l, "scale", function() {
        return t;
      }), i.d(l, "scaleAndAdd", function() {
        return c;
      }), i.d(l, "distance", function() {
        return b;
      }), i.d(l, "squaredDistance", function() {
        return Z;
      }), i.d(l, "length", function() {
        return r;
      }), i.d(l, "squaredLength", function() {
        return S;
      }), i.d(l, "negate", function() {
        return C;
      }), i.d(l, "inverse", function() {
        return F;
      }), i.d(l, "normalize", function() {
        return Y;
      }), i.d(l, "dot", function() {
        return J;
      }), i.d(l, "cross", function() {
        return T;
      }), i.d(l, "lerp", function() {
        return K;
      }), i.d(l, "random", function() {
        return R;
      }), i.d(l, "transformMat2", function() {
        return H;
      }), i.d(l, "transformMat2d", function() {
        return f;
      }), i.d(l, "transformMat3", function() {
        return w;
      }), i.d(l, "transformMat4", function() {
        return O;
      }), i.d(l, "rotate", function() {
        return q;
      }), i.d(l, "angle", function() {
        return k;
      }), i.d(l, "zero", function() {
        return Q;
      }), i.d(l, "str", function() {
        return D;
      }), i.d(l, "exactEquals", function() {
        return ii;
      }), i.d(l, "equals", function() {
        return _;
      }), i.d(l, "len", function() {
        return bi;
      }), i.d(l, "sub", function() {
        return $;
      }), i.d(l, "mul", function() {
        return Xi;
      }), i.d(l, "div", function() {
        return ni;
      }), i.d(l, "dist", function() {
        return M;
      }), i.d(l, "sqrDist", function() {
        return z;
      }), i.d(l, "sqrLen", function() {
        return E;
      }), i.d(l, "forEach", function() {
        return B;
      });
      var d = i(2);
      function s() {
        var g = new d.ARRAY_TYPE(2);
        return d.ARRAY_TYPE != Float32Array && (g[0] = 0, g[1] = 0), g;
      }
      function X(g) {
        var U = new d.ARRAY_TYPE(2);
        return U[0] = g[0], U[1] = g[1], U;
      }
      function a(g, U) {
        var u = new d.ARRAY_TYPE(2);
        return u[0] = g, u[1] = U, u;
      }
      function e(g, U) {
        return g[0] = U[0], g[1] = U[1], g;
      }
      function n(g, U, u) {
        return g[0] = U, g[1] = u, g;
      }
      function G(g, U, u) {
        return g[0] = U[0] + u[0], g[1] = U[1] + u[1], g;
      }
      function y(g, U, u) {
        return g[0] = U[0] - u[0], g[1] = U[1] - u[1], g;
      }
      function o(g, U, u) {
        return g[0] = U[0] * u[0], g[1] = U[1] * u[1], g;
      }
      function h(g, U, u) {
        return g[0] = U[0] / u[0], g[1] = U[1] / u[1], g;
      }
      function I(g, U) {
        return g[0] = Math.ceil(U[0]), g[1] = Math.ceil(U[1]), g;
      }
      function x(g, U) {
        return g[0] = Math.floor(U[0]), g[1] = Math.floor(U[1]), g;
      }
      function p(g, U, u) {
        return g[0] = Math.min(U[0], u[0]), g[1] = Math.min(U[1], u[1]), g;
      }
      function W(g, U, u) {
        return g[0] = Math.max(U[0], u[0]), g[1] = Math.max(U[1], u[1]), g;
      }
      function V(g, U) {
        return g[0] = Math.round(U[0]), g[1] = Math.round(U[1]), g;
      }
      function t(g, U, u) {
        return g[0] = U[0] * u, g[1] = U[1] * u, g;
      }
      function c(g, U, u, L) {
        return g[0] = U[0] + u[0] * L, g[1] = U[1] + u[1] * L, g;
      }
      function b(g, U) {
        var u = U[0] - g[0], L = U[1] - g[1];
        return Math.hypot(u, L);
      }
      function Z(g, U) {
        var u = U[0] - g[0], L = U[1] - g[1];
        return u * u + L * L;
      }
      function r(g) {
        var U = g[0], u = g[1];
        return Math.hypot(U, u);
      }
      function S(g) {
        var U = g[0], u = g[1];
        return U * U + u * u;
      }
      function C(g, U) {
        return g[0] = -U[0], g[1] = -U[1], g;
      }
      function F(g, U) {
        return g[0] = 1 / U[0], g[1] = 1 / U[1], g;
      }
      function Y(g, U) {
        var u = U[0], L = U[1], N = u * u + L * L;
        return N > 0 && (N = 1 / Math.sqrt(N)), g[0] = U[0] * N, g[1] = U[1] * N, g;
      }
      function J(g, U) {
        return g[0] * U[0] + g[1] * U[1];
      }
      function T(g, U, u) {
        var L = U[0] * u[1] - U[1] * u[0];
        return g[0] = g[1] = 0, g[2] = L, g;
      }
      function K(g, U, u, L) {
        var N = U[0], v = U[1];
        return g[0] = N + L * (u[0] - N), g[1] = v + L * (u[1] - v), g;
      }
      function R(g, U) {
        U = U || 1;
        var u = d.RANDOM() * 2 * Math.PI;
        return g[0] = Math.cos(u) * U, g[1] = Math.sin(u) * U, g;
      }
      function H(g, U, u) {
        var L = U[0], N = U[1];
        return g[0] = u[0] * L + u[2] * N, g[1] = u[1] * L + u[3] * N, g;
      }
      function f(g, U, u) {
        var L = U[0], N = U[1];
        return g[0] = u[0] * L + u[2] * N + u[4], g[1] = u[1] * L + u[3] * N + u[5], g;
      }
      function w(g, U, u) {
        var L = U[0], N = U[1];
        return g[0] = u[0] * L + u[3] * N + u[6], g[1] = u[1] * L + u[4] * N + u[7], g;
      }
      function O(g, U, u) {
        var L = U[0], N = U[1];
        return g[0] = u[0] * L + u[4] * N + u[12], g[1] = u[1] * L + u[5] * N + u[13], g;
      }
      function q(g, U, u, L) {
        var N = U[0] - u[0], v = U[1] - u[1], P = Math.sin(L), j = Math.cos(L);
        return g[0] = N * j - v * P + u[0], g[1] = N * P + v * j + u[1], g;
      }
      function k(g, U) {
        var u = g[0], L = g[1], N = U[0], v = U[1], P = Math.sqrt(u * u + L * L) * Math.sqrt(N * N + v * v), j = P && (u * N + L * v) / P;
        return Math.acos(Math.min(Math.max(j, -1), 1));
      }
      function Q(g) {
        return g[0] = 0, g[1] = 0, g;
      }
      function D(g) {
        return "vec2(" + g[0] + ", " + g[1] + ")";
      }
      function ii(g, U) {
        return g[0] === U[0] && g[1] === U[1];
      }
      function _(g, U) {
        var u = g[0], L = g[1], N = U[0], v = U[1];
        return Math.abs(u - N) <= d.EPSILON * Math.max(1, Math.abs(u), Math.abs(N)) && Math.abs(L - v) <= d.EPSILON * Math.max(1, Math.abs(L), Math.abs(v));
      }
      var bi = r, $ = y, Xi = o, ni = h, M = b, z = Z, E = S, B = function() {
        var g = s();
        return function(U, u, L, N, v, P) {
          var j, A;
          for (u || (u = 2), L || (L = 0), N ? A = Math.min(N * u + L, U.length) : A = U.length, j = L; j < A; j += u)
            g[0] = U[j], g[1] = U[j + 1], v(g, g, P), U[j] = g[0], U[j + 1] = g[1];
          return U;
        };
      }();
    },
    /* 12 */
    /***/
    function(m, l, i) {
      i.r(l);
      var d = i(13);
      i.d(l, "Renderer", function() {
        return d.default;
      });
      var s = i(40);
      i.d(l, "Figure2D", function() {
        return s.default;
      });
      var X = i(56);
      i.d(l, "Mesh2D", function() {
        return X.default;
      });
      var a = i(29);
      i.d(l, "MeshCloud", function() {
        return a.default;
      });
      var e = i(23);
      i.d(l, "parseFont", function() {
        return e.default;
      });
      var n = i(31);
      i.d(l, "parseColor", function() {
        return n.default;
      });
      var G = i(21);
      i.d(l, "ENV", function() {
        return G.default;
      }), i(1).glMatrix.setMatrixArrayType(Array);
    },
    /* 13 */
    /***/
    function(m, l, i) {
      i.r(l), i.d(l, "default", function() {
        return F;
      });
      var d = i(14), s = i(1), X = i(20), a = i(27), e = i(25), n = i(40), G = i(56), y = i(29), o = i(59), h = i(21), I = i(63);
      i(1).glMatrix.setMatrixArrayType(Array);
      const x = {
        autoUpdate: !1,
        // premultipliedAlpha: true,
        preserveDrawingBuffer: !1,
        // depth: false,
        // antialias: false,
        bufferSize: 1500
      }, p = `attribute vec3 a_vertexPosition;
attribute vec3 a_vertexTextureCoord;
varying vec3 vTextureCoord;
uniform mat3 viewMatrix;
uniform mat3 projectionMatrix;

void main() {
  gl_PointSize = 1.0;
  vec3 pos = projectionMatrix * viewMatrix * vec3(a_vertexPosition.xy, 1.0);
  gl_Position = vec4(pos.xy, 1.0, 1.0);    
  vTextureCoord = a_vertexTextureCoord;              
}
`, W = `precision mediump float;
varying vec3 vTextureCoord;
uniform sampler2D u_texSampler;
void main() {
  gl_FragColor = texture2D(u_texSampler, vTextureCoord.xy);
}
`, V = Symbol("glRenderer"), t = Symbol("canvasRenderer"), c = Symbol("options"), b = Symbol("globalTransform"), Z = Symbol("applyGlobalTransform"), r = Symbol("canvas");
      function S(Y) {
        const J = Y.gl, T = Y.fbo;
        T && J.bindFramebuffer(J.FRAMEBUFFER, T), Y._draw(), T && J.bindFramebuffer(J.FRAMEBUFFER, null);
      }
      function C(Y, J, T, K) {
        const R = Y.createTexture(J.canvas), H = [[[0, 0], [T, 0], [T, K], [0, K], [0, 0]]];
        H.closed = !0;
        const f = new G.default({
          contours: H
        });
        f.setTexture(R), Y.setMeshData([f.meshData]), S(Y), R.delete(), J.clearRect(0, 0, T, K), delete J._filter;
      }
      class F {
        constructor(J, T = {}) {
          let K = T.contextType;
          if (K || (typeof WebGL2RenderingContext == "function" ? K = "webgl2" : typeof WebGLRenderingContext == "function" ? K = "webgl" : K = "2d"), !J.getContext) {
            const R = J;
            J = {
              getContext() {
                return R;
              },
              width: T.width,
              height: T.height
            }, R.canvas = J, K = "2d";
          }
          if (this[r] = J, K !== "webgl" && K !== "webgl2" && K !== "2d")
            throw new Error(`Unknown context type ${K}`);
          if (T.contextType = K, this[c] = Object.assign({}, x, T), K === "webgl" || K === "webgl2") {
            K === "webgl2" && (this[c].webgl2 = !0);
            const R = new d.default(J, this[c]);
            K === "webgl2" && !R.isWebGL2 && (T.contextType = "webgl"), Object(I.createShaders)(R), Object(I.applyShader)(R), Object(I.createCloudShaders)(R);
            const H = R.gl;
            H.clearColor(0, 0, 0, 0), H.blendFuncSeparate(H.SRC_ALPHA, H.ONE_MINUS_SRC_ALPHA, H.ONE, H.ONE_MINUS_SRC_ALPHA), this[V] = R;
          } else
            this[t] = new X.default(J, this[c]);
          this[b] = [1, 0, 0, 0, 1, 0, 0, 0, 1], this.updateResolution();
        }
        get canvas() {
          return this[r];
        }
        get canvasRenderer() {
          return this[t];
        }
        get glRenderer() {
          return this[V];
        }
        get isWebGL2() {
          return this[V] && this[V].isWebGL2;
        }
        get options() {
          return this[c];
        }
        get globalTransformMatrix() {
          const J = this[b];
          return [J[0], J[1], J[3], J[4], J[6], J[7]];
        }
        get viewMatrix() {
          return this[b];
        }
        [Z]() {
          const J = this[V] || this[t];
          if (this[V]) {
            const {
              width: T,
              height: K
            } = this.canvas;
            J.uniforms.viewMatrix = this.viewMatrix, J.uniforms.projectionMatrix = this.projectionMatrix, J.uniforms.u_resolution = [T, K];
          }
        }
        updateResolution() {
          const {
            width: J,
            height: T
          } = this.canvas, K = [
            // translation
            1,
            0,
            0,
            0,
            1,
            0,
            -J / 2,
            -T / 2,
            1
          ], R = [
            // scale
            2 / J,
            0,
            0,
            0,
            -2 / T,
            0,
            0,
            0,
            1
          ], H = s.mat3.multiply(Array.of(0, 0, 0, 0, 0, 0, 0, 0, 0), R, K);
          this.projectionMatrix = H, this[V] && this[V].gl.viewport(0, 0, J, T);
        }
        createTexture(J, T) {
          return (this[V] || this[t]).createTexture(J, T);
        }
        /* async */
        loadTexture(J, {
          useImageBitmap: T = !1
        } = {}) {
          return (this[V] || this[t]).loadTexture(J, {
            useImageBitmap: T
          });
        }
        createText(J, {
          font: T = "16px arial",
          fillColor: K = null,
          strokeColor: R = null,
          strokeWidth: H = 1
        } = {}) {
          if (this[V]) {
            const f = h.default.createText(J, {
              font: T,
              fillColor: K,
              strokeColor: R,
              strokeWidth: H
            });
            return {
              image: this.createTexture(f.image),
              rect: f.rect
            };
          }
          return {
            _img: {
              font: T,
              fillColor: K,
              strokeColor: R,
              strokeWidth: H,
              text: J
            }
          };
        }
        createProgram({
          vertex: J,
          fragment: T,
          options: K
        } = {}) {
          if (this[V]) {
            const R = this[V].compileSync(T, J);
            return R._attribOpts = K, R;
          }
          throw new Error("Context 2D cannot create webgl program.");
        }
        createPassProgram({
          vertex: J = p,
          fragment: T = W,
          options: K
        } = {}) {
          return this.createProgram({
            vertex: J,
            fragment: T,
            options: K
          });
        }
        useProgram(J, T = {}) {
          if (this[V]) {
            const K = Object.assign({}, J._attribOpts, T);
            return this[V].useProgram(J, K);
          }
          throw new Error("Context 2D cannot use webgl program.");
        }
        deleteTexture(J) {
          return (this[V] || this[t]).deleteTexture(J);
        }
        clear(...J) {
          if (this[V]) {
            const T = this[V].gl;
            T.clear(T.COLOR_BUFFER_BIT);
          } else
            this[t].clear(...J);
        }
        drawMeshCloud(J, {
          clear: T = !1,
          program: K = null
        } = {}) {
          const R = this[V] || this[t], H = K || J.program;
          if (this[V]) {
            const f = R.gl;
            if (T && f.clear(f.COLOR_BUFFER_BIT), H)
              R.program !== H && this.useProgram(H, {
                a_color: {
                  type: "UNSIGNED_BYTE",
                  normalize: !0
                },
                a_fillCloudColor: {
                  type: "UNSIGNED_BYTE",
                  normalize: !0
                },
                a_strokeCloudColor: {
                  type: "UNSIGNED_BYTE",
                  normalize: !0
                },
                a_frameIndex: {
                  type: "UNSIGNED_BYTE",
                  normalize: !1
                }
              });
            else {
              const w = J.mesh.meshData, O = !!w.uniforms.u_texSampler, q = !!w.uniforms.u_filterFlag, k = !!w.uniforms.u_radialGradientVector, Q = J.hasCloudColor, D = J.hasCloudFilter, ii = !!w.uniforms.u_clipSampler;
              Object(I.applyCloudShader)(R, {
                hasTexture: O,
                hasFilter: q,
                hasGradient: k,
                hasCloudColor: Q,
                hasCloudFilter: D,
                hasClipPath: ii
              });
            }
            this[Z](), R.setMeshData([J.meshData]), J.beforeRender && J.beforeRender(f, J), S(R), J.afterRender && J.afterRender(f, J);
          } else
            R.setTransform(this.globalTransformMatrix), R.drawMeshCloud(J, {
              clear: T,
              hook: !1
            });
        }
        drawMeshes(J, {
          clear: T = !1,
          program: K = null
        } = {}) {
          const R = this[V] || this[t];
          if (this[V]) {
            const H = R.fbo, f = Object(a.default)(this, J, K == null), w = R.gl;
            T && w.clear(w.COLOR_BUFFER_BIT);
            const O = !Object(o.isUnitTransform)(this.globalTransformMatrix);
            this._drawCalls = 0;
            for (const q of f) {
              this._drawCalls++;
              const k = K || q.program;
              if (q instanceof y.default)
                this.drawMeshCloud(q, {
                  clear: T,
                  program: k
                });
              else {
                const {
                  width: Q,
                  height: D
                } = this.canvas;
                if (q.beforeRender && q.beforeRender(w, q), q.pass.length && ((!this.fbo || this.fbo.width !== Q || this.fbo.height !== D) && (this.fbo = {
                  width: Q,
                  height: D,
                  target: R.createFBO(),
                  buffer: R.createFBO(),
                  swap() {
                    [this.target, this.buffer] = [this.buffer, this.target];
                  }
                }), R.bindFBO(this.fbo.target)), !k && q.filterCanvas) {
                  Object(I.applyShader)(R, {
                    hasTexture: !0
                  });
                  let ii = this.filterContext;
                  ii || (ii = h.default.createCanvas(Q, D).getContext("2d"), this.filterContext = ii);
                  const _ = J[q.packIndex], bi = _.filter, $ = J[q.packIndex + 1], Xi = J[q.packIndex - 1];
                  (!Xi || !Xi.filterCanvas || Xi.filter !== bi) && (!$ || !$.filterCanvas || $.filter !== bi) ? (O ? (ii.save(), Object(e.drawMesh2D)(_, ii, !1), ii.restore(), Object(e.applyFilter)(ii, bi)) : Object(e.drawMesh2D)(_, ii, !0), this[Z](), C(R, ii, Q, D)) : (O && ii.save(), Object(e.drawMesh2D)(_, ii, !1), O && ii.restore(), (!$ || !$.filterCanvas || _.filter !== $.filter) && (Object(e.applyFilter)(ii, bi), this[Z](), C(R, ii, Q, D)));
                } else {
                  if (k)
                    R.program !== k && this.useProgram(k, {
                      a_color: {
                        type: "UNSIGNED_BYTE",
                        normalize: !0
                      }
                    });
                  else {
                    const ii = !!q.uniforms.u_texSampler, _ = !!q.uniforms.u_filterFlag, bi = !!q.uniforms.u_radialGradientVector, $ = !!q.uniforms.u_clipSampler;
                    Object(I.applyShader)(R, {
                      hasTexture: ii,
                      hasFilter: _,
                      hasGradient: bi,
                      hasClipPath: $
                    });
                  }
                  q.filterCanvas && console.warn("User program ignored some filter effects."), this[Z](), R.setMeshData([q]), S(R);
                }
                if (q.pass.length) {
                  const ii = q.pass.length;
                  q.pass.forEach((_, bi) => {
                    _.blend = q.enableBlend, _.setTexture(R.fbo.texture), bi === ii - 1 ? R.bindFBO(H) : (this.fbo.swap(), R.bindFBO(this.fbo.target)), _.program ? R.useProgram(_.program) : (this.defaultPassProgram = this.defaultPassProgram || this.createPassProgram(), R.useProgram(this.defaultPassProgram)), R.setMeshData([_.meshData]), w.clear(w.COLOR_BUFFER_BIT), S(R);
                  });
                }
                q.afterRender && q.afterRender(w, q);
              }
            }
          } else
            R.setTransform(this.globalTransformMatrix), R.drawMeshes(J, {
              clear: T
            });
        }
        drawImage(J, ...T) {
          const K = T.length;
          if (K < 2)
            throw new TypeError(`Failed to execute 'drawImage' on 'Renderer': 3 arguments required, but only ${T.length + 1} present.`);
          if (K !== 2 && K !== 4 && K !== 8)
            throw new TypeError(`Failed to execute 'drawImage' on 'Renderer': Valid arities are: [3, 5, 9], but ${T.length + 1} arguments provided.`);
          let R = null, H = null;
          K === 2 ? R = [T[0], T[1], J.width, J.height] : K === 4 ? R = T : K === 8 && (H = T.slice(0, 4), R = T.slice(4));
          const f = this.createTexture(J), {
            width: w,
            height: O
          } = this.canvas, q = new n.default();
          q.rect(R[0], R[1], w, O);
          const k = new G.default(q, {
            width: w,
            height: O
          });
          k.setTexture(f, {
            rect: R,
            srcRect: H
          }), this.drawMeshes([k]), this.deleteTexture(f);
        }
        setGlobalTransform(...J) {
          return this[b] = [J[0], J[1], 0, J[2], J[3], 0, J[4], J[5], 1], this;
        }
        globalTransform(...J) {
          const T = this[b];
          return this[b] = s.mat3.multiply(Array.of(0, 0, 0, 0, 0, 0, 0, 0, 0), T, J), this;
        }
        globalTranslate(J, T) {
          let K = s.mat3.create();
          return K = s.mat3.translate(Array.of(0, 0, 0, 0, 0, 0, 0, 0, 0), K, [J, T]), this.globalTransform(...K);
        }
        globalRotate(J, [T, K] = [0, 0]) {
          let R = s.mat3.create();
          return R = s.mat3.translate(Array.of(0, 0, 0, 0, 0, 0, 0, 0, 0), R, [T, K]), R = s.mat3.rotate(Array.of(0, 0, 0, 0, 0, 0, 0, 0, 0), R, J), R = s.mat3.translate(Array.of(0, 0, 0, 0, 0, 0, 0, 0, 0), R, [-T, -K]), this.globalTransform(...R);
        }
        globalScale(J, T = J, [K, R] = [0, 0]) {
          let H = s.mat3.create();
          return H = s.mat3.translate(Array.of(0, 0, 0, 0, 0, 0, 0, 0, 0), H, [K, R]), H = s.mat3.scale(Array.of(0, 0, 0, 0, 0, 0, 0, 0, 0), H, [J, T]), H = s.mat3.translate(Array.of(0, 0, 0, 0, 0, 0, 0, 0, 0), H, [-K, -R]), this.globalTransform(...H);
        }
        globalSkew(J, T = J, [K, R] = [0, 0]) {
          let H = s.mat3.create();
          return H = s.mat3.translate(Array.of(0, 0, 0, 0, 0, 0, 0, 0, 0), H, [K, R]), H = s.mat3.multiply(Array.of(0, 0, 0, 0, 0, 0, 0, 0, 0), H, s.mat3.fromValues(1, Math.tan(T), Math.tan(J), 1, 0, 0)), H = s.mat3.translate(Array.of(0, 0, 0, 0, 0, 0, 0, 0, 0), H, [-K, -R]), this.globalTransform(...H);
        }
        transformPoint(J, T, K) {
          let R = this.globalTransformMatrix;
          K && (R = s.mat3.multiply(Array.of(0, 0, 0, 0, 0, 0, 0, 0, 0), R, K));
          const H = J * R[0] + T * R[2] + R[4], f = J * R[1] + T * R[3] + R[5];
          return [H, f];
        }
      }
    },
    /* 14 */
    /***/
    function(m, l, i) {
      i.r(l);
      var d = i(15);
      i(1).glMatrix.setMatrixArrayType(Array), l.default = d.default;
    },
    /* 15 */
    /***/
    function(m, l, i) {
      i.r(l), i.d(l, "default", function() {
        return I;
      });
      var d = i(16), s = i(17), X = i(18), a = i(19);
      i(1).glMatrix.setMatrixArrayType(Array);
      function e(x, p, W) {
        return p in x ? Object.defineProperty(x, p, { value: W, enumerable: !0, configurable: !0, writable: !0 }) : x[p] = W, x;
      }
      const n = {};
      function G(x, p = 3) {
        const W = [], V = x.length;
        for (let t = 0; t < V; t++)
          t % p < 2 && W.push(0.5 * (x[t] + 1));
        return W;
      }
      function y(x, p) {
        const W = p._buffers;
        Object.values(W).forEach((V) => {
          x.deleteBuffer(V);
        }), p._buffers = {};
      }
      function o(x, p, W) {
        return x.activeTexture(x.TEXTURE0 + W), Array.isArray(p._img) ? x.bindTexture(x.TEXTURE_CUBE_MAP, p) : x.bindTexture(x.TEXTURE_2D, p), p;
      }
      const h = {
        int: "1i",
        ivec2: "2i",
        ivec3: "3i",
        ivec4: "4i",
        float: "1f",
        vec2: "2f",
        vec3: "3f",
        vec4: "4f",
        mat2: "Matrix2fv",
        mat3: "Matrix3fv",
        mat4: "Matrix4fv",
        sampler1D: "sampler1D",
        sampler2D: "sampler2D",
        sampler3D: "sampler3D",
        samplerCube: "samplerCube",
        sampler1DShadow: "sampler1DShadow",
        sampler2DShadow: "sampler2DShadow",
        sampler2DRect: "sampler2DRect",
        sampler2DRectShadow: "sampler2DRectShadow"
      };
      class I {
        static addLibs(p = {}) {
          Object.assign(n, p);
        }
        static FLOAT(p, W) {
          return Object(d.pointsToBuffer)(p, Float32Array, W);
        }
        static UNSIGNED_BYTE(p, W) {
          return Object(d.pointsToBuffer)(p, Uint8Array, W);
        }
        static UNSIGNED_SHORT(p, W) {
          return Object(d.pointsToBuffer)(p, Uint16Array, W);
        }
        static BYTE(p, W) {
          return Object(d.pointsToBuffer)(p, Int8Array, W);
        }
        static SHORT(p, W) {
          return Object(d.pointsToBuffer)(p, Int16Array, W);
        }
        constructor(p, W = {}) {
          this.options = Object.assign({}, I.defaultOptions, W), this.canvas = p;
          let V;
          this.options.webgl2 && (V = p.getContext("webgl2", this.options)), V == null && (V = Object(d.setupWebGL)(p, this.options), this.aia_ext = V.getExtension("ANGLE_instanced_arrays")), this.gl = V, V.viewport(0, 0, p.width, p.height), V.clearColor(0, 0, 0, 0), V.blendFuncSeparate(V.SRC_ALPHA, V.ONE_MINUS_SRC_ALPHA, V.ONE, V.ONE_MINUS_SRC_ALPHA), this.programs = [], this._events = {};
        }
        get program() {
          const p = this.gl;
          return p.getParameter(p.CURRENT_PROGRAM);
        }
        // WebGLRenderingContext.uniform[1234][fi][v]()
        // WebGLRenderingContext.uniformMatrix[234]fv()
        _declareUniform(p, W, V = "1f") {
          const t = this.gl, c = t.getUniformLocation(p, W);
          let b;
          const Z = this;
          if (/^sampler/.test(V)) {
            const r = p._samplerMap, S = p._bindTextures;
            Object.defineProperty(p.uniforms, W, {
              get() {
                return b;
              },
              set(C) {
                b = C;
                const F = r[W] != null ? r[W] : S.length;
                S[F] = C, o(t, C, F), r[W] || (r[W] = F, t.uniform1i(c, F)), Z.options.autoUpdate && Z.update();
              },
              configurable: !1,
              enumerable: !0
            });
          } else {
            const r = V.indexOf("Matrix") === 0, S = !r && /v$/.test(V), C = t[`uniform${V}`].bind(t);
            Object.defineProperty(p.uniforms, W, {
              get() {
                return b;
              },
              set(F) {
                b = F, typeof F == "number" && (F = [F]), r ? C(c, !1, F) : S ? C(c, F) : C(c, ...F), Z.options.autoUpdate && Z.update();
              },
              configurable: !1,
              enumerable: !0
            });
          }
        }
        _draw() {
          const p = this.program;
          p.meshData.forEach((W, V) => {
            const {
              positions: t,
              cells: c,
              instanceCount: b,
              cellsCount: Z,
              attributes: r,
              uniforms: S,
              textureCoord: C,
              enableBlend: F
            } = W, Y = this.gl;
            let J = W.mode != null ? W.mode : Y.TRIANGLES;
            typeof J == "string" && (J = Y[J]), F ? Y.enable(Y.BLEND) : Y.disable(Y.BLEND), Y.bindBuffer(Y.ARRAY_BUFFER, p._buffers.verticesBuffer), Y.bufferData(Y.ARRAY_BUFFER, t, Y.STATIC_DRAW), c && (Y.bindBuffer(Y.ELEMENT_ARRAY_BUFFER, p._buffers.cellsBuffer), Y.bufferData(Y.ELEMENT_ARRAY_BUFFER, c, Y.STATIC_DRAW));
            const T = [];
            r && Object.values(r).forEach(({
              name: R,
              data: H,
              divisor: f
            }) => {
              if (Y.bindBuffer(Y.ARRAY_BUFFER, p._buffers[R]), Y.bufferData(Y.ARRAY_BUFFER, H, Y.STATIC_DRAW), f != null) {
                const w = Y.getAttribLocation(p, R);
                w >= 0 && (Y.enableVertexAttribArray(w), T.push(w), Y.vertexAttribDivisor ? Y.vertexAttribDivisor(w, f) : this.aia_ext && this.aia_ext.vertexAttribDivisorANGLE(w, f));
              }
            }), S && Object.entries(S).forEach(([R, H]) => {
              this.uniforms[R] = H;
            });
            let K;
            if (!c) {
              const R = p._dimension;
              K = t.length / R;
            }
            if (p._enableTextures && p._buffers.texCoordBuffer) {
              const R = C || G(t, p._dimension);
              Y.bindBuffer(Y.ARRAY_BUFFER, p._buffers.texCoordBuffer), Y.bufferData(Y.ARRAY_BUFFER, I.FLOAT(R), Y.STATIC_DRAW);
            }
            b != null ? (c ? Y.drawElementsInstanced ? Y.drawElementsInstanced(J, Z, Y.UNSIGNED_SHORT, 0, b) : this.aia_ext && this.aia_ext.drawElementsInstancedANGLE(J, Z, Y.UNSIGNED_SHORT, 0, b) : Y.drawArraysInstanced ? Y.drawArraysInstanced(J, 0, K, b) : this.aia_ext.drawArraysInstancedANGLE(J, 0, K, b), T.forEach((R) => {
              Y.vertexAttribDivisor ? Y.vertexAttribDivisor(R, null) : this.aia_ext && this.aia_ext.vertexAttribDivisorANGLE(R, null);
            })) : c ? Y.drawElements(J, Z, Y.UNSIGNED_SHORT, 0) : Y.drawArrays(J, 0, K);
          });
        }
        get isWebGL2() {
          return typeof WebGL2RenderingContext < "u" && this.gl instanceof WebGL2RenderingContext;
        }
        get enableTextures() {
          return this.program && this.program._enableTextures;
        }
        get uniforms() {
          const p = this.program;
          if (!p || !p.uniforms)
            throw Error("No avaliable program.");
          return p.uniforms;
        }
        deleteProgram(p) {
          const W = this.gl;
          this.program === p && (this.startRender = !1, this._renderFrameID && (cancelAnimationFrame(this._renderFrameID), delete this._renderFrameID), W.useProgram(null));
          const V = this.programs.indexOf(p);
          V >= 0 && this.programs.splice(V, 1), y(W, p), W.deleteProgram(p);
        }
        /**
          [{
            positions: ...
            cells: ...
            textureCoord: ...
            attributes: {name: {data:..., normalize: true}},
            uniforms: ...
          }]
         */
        setMeshData(p) {
          Array.isArray(p) || (p = [p]);
          const W = this.program;
          W.meshData = p.map(({
            mode: V,
            positions: t,
            instanceCount: c,
            cells: b,
            cellsCount: Z,
            attributes: r,
            uniforms: S,
            textureCoord: C,
            enableBlend: F
          }) => {
            const Y = {
              positions: I.FLOAT(t),
              uniforms: S,
              enableBlend: !!F,
              textureCoord: I.FLOAT(C)
            };
            if (b && (Y.cells = I.USHORT(b), Y.cellsCount = Z || Y.cells.length), V != null && (Y.mode = V), c != null) {
              if (!this.isWebGL2 && !this.aia_ext)
                throw new Error("Cannot use instanceCount in this rendering context, use webgl2 context instead.");
              Y.instanceCount = c;
            }
            if (r) {
              const J = {};
              Object.entries(r).forEach(([T, K]) => {
                if (!W._attribute[T])
                  W._attribute[T] = "ignored";
                else if (W._attribute[T] !== "ignored") {
                  const {
                    name: R,
                    type: H
                  } = W._attribute[T];
                  let f = K.data || K;
                  if (Array.isArray(f) && (f = I[H](f)), J[T] = {
                    name: R,
                    data: f
                  }, K.divisor != null) {
                    if (!this.isWebGL2 && !this.aia_ext)
                      throw new Error("Cannot use divisor in this rendering context, use webgl2 context instead.");
                    J[T].divisor = K.divisor;
                  }
                }
              }), Y.attributes = J;
            }
            return Y;
          }), this.options.autoUpdate && this.update();
        }
        createProgram(p, W) {
          const V = /^\s*uniform\s+sampler/mg.test(p);
          p == null && (p = X.default), W == null && (W = V ? a.default : s.default);
          const t = this.gl, c = Object(d.createProgram)(t, W, p);
          c.shaderText = {
            vertexShader: W,
            fragmentShader: p
          }, c._buffers = {}, c._attribute = {}, c.uniforms = {}, c._samplerMap = {}, c._bindTextures = [];
          const b = new RegExp(`(?:attribute|in) vec(\\d) ${this.options.vertexPosition}`, "im");
          let Z = W.match(b);
          Z && (c._dimension = Number(Z[1]));
          const r = new RegExp(`(?:attribute|in) vec(\\d) ${this.options.vertexTextureCoord}`, "im");
          Z = W.match(r), Z && (c._texCoordSize = Number(Z[1]));
          const S = /^\s*(?:attribute|in) (\w+?)(\d*) (\w+)/gim;
          if (Z = W.match(S), Z)
            for (let Y = 0; Y < Z.length; Y++) {
              const J = /^\s*(?:attribute|in) (\w+?)(\d*) (\w+)/im, T = Z[Y].match(J);
              if (T && T[3] !== this.options.vertexPosition && T[3] !== this.options.vertexTextureCoord) {
                let [, K, R, H] = T;
                K === "mat" && (R **= 2), c._buffers[H] = t.createBuffer(), c._attribute[H] = {
                  name: H,
                  type: K,
                  size: Number(R) || 1
                };
              }
            }
          const C = /^\s*uniform\s+(\w+)\s+(\w+)(\[\d+\])?/mg;
          Z = W.match(C) || [], Z = Z.concat(p.match(C) || []), Z.forEach((Y) => {
            const J = Y.match(/^\s*uniform\s+(\w+)\s+(\w+)(\[\d+\])?/);
            let [T, K, R] = J.slice(1);
            T = h[T], R = !!R, T.indexOf("Matrix") !== 0 && R && (T += "v"), this._declareUniform(c, K, T);
          }), c._buffers.verticesBuffer = t.createBuffer(), c._buffers.cellsBuffer = t.createBuffer();
          const F = t.getAttribLocation(c, this.options.vertexTextureCoord);
          return c._enableTextures = F >= 0, c._enableTextures && (c._buffers.texCoordBuffer = t.createBuffer()), this.programs.push(c), c;
        }
        useProgram(p, W = {}) {
          this.startRender = !1, this._renderFrameID && (cancelAnimationFrame(this._renderFrameID), delete this._renderFrameID);
          const V = this.gl;
          V.useProgram(p);
          const t = p._dimension;
          V.bindBuffer(V.ARRAY_BUFFER, p._buffers.verticesBuffer);
          const c = V.getAttribLocation(p, this.options.vertexPosition);
          if (V.vertexAttribPointer(c, t, V.FLOAT, !1, 0, 0), V.enableVertexAttribArray(c), p._enableTextures) {
            V.bindBuffer(V.ARRAY_BUFFER, p._buffers.texCoordBuffer);
            const b = V.getAttribLocation(p, this.options.vertexTextureCoord);
            V.vertexAttribPointer(b, p._texCoordSize || 2, V.FLOAT, !1, 0, 0), V.enableVertexAttribArray(b);
          }
          if (Object.entries(p._attribute).forEach(([b, Z]) => {
            if (Z !== "ignored") {
              const r = Z.size, S = W[b] || {}, C = !!S.normalize;
              let F = S.type || "FLOAT";
              const Y = S.key || b;
              F === "UBYTE" && (F = "UNSIGNED_BYTE"), F === "USHORT" && (F = "UNSIGNED_SHORT"), Z.type = F, Y && Y !== b && (p._attribute[Y] = Z), V.bindBuffer(V.ARRAY_BUFFER, p._buffers[b]);
              const J = V.getAttribLocation(p, b);
              J >= 0 && (V.vertexAttribPointer(J, r, V[F], C, 0, 0), V.enableVertexAttribArray(J));
            }
          }), !p.meshData) {
            const b = [[-1, -1, 0, 1].slice(0, t), [1, -1, 0, 1].slice(0, t), [1, 1, 0, 1].slice(0, t), [-1, 1, 0, 1].slice(0, t)], Z = [[0, 1, 3], [3, 1, 2]];
            this.setMeshData({
              positions: b,
              cells: Z
            });
          }
          return p;
        }
        compileSync(p, W) {
          p = p || X.default;
          const V = {};
          function t(r) {
            r = r.replace(/^\s*/mg, "");
            const S = [], C = r.match(/^#pragma\s+include\s+.*/mg);
            if (C) {
              for (let F = 0; F < C.length; F++) {
                const J = C[F].match(/(?:<|")(.*)(?:>|")/);
                if (J) {
                  const T = J[0].indexOf("<") === 0 ? "lib" : "link";
                  let K = J[1];
                  if (K === "graph" && (K = "graphics"), V[K])
                    S.push(`/* included ${K} */`);
                  else if (V[K] = !0, T === "lib") {
                    const R = t(n[K]);
                    S.push(R);
                  } else if (T === "link")
                    throw new Error("Cannot load external links synchronously. Use compile instead of compileSync.");
                }
              }
              S.forEach((F) => {
                r = r.replace(/^#pragma\s+include\s+.*/m, F);
              });
            }
            return r;
          }
          const c = t(p), b = W ? t(W) : null;
          return this.createProgram(c, b);
        }
        async compile(p, W) {
          p = p || X.default;
          const V = {};
          async function t(r) {
            r = r.replace(/^\s*/mg, "");
            const S = [], C = r.match(/^#pragma\s+include\s+.*/mg);
            if (C) {
              for (let F = 0; F < C.length; F++) {
                const J = C[F].match(/(?:<|")(.*)(?:>|")/);
                if (J) {
                  const T = J[0].indexOf("<") === 0 ? "lib" : "link";
                  let K = J[1];
                  if (K === "graph" && (K = "graphics"), V[K])
                    S.push(`/* included ${K} */`);
                  else if (V[K] = !0, T === "lib") {
                    const R = await t(n[K]);
                    S.push(R);
                  } else if (T === "link") {
                    let R = await I.fetchShader(K);
                    R = await t(R), S.push(R);
                  }
                }
              }
              S.forEach((F) => {
                r = r.replace(/^#pragma\s+include\s+.*/m, F);
              });
            }
            return r;
          }
          const c = await t(p), b = W ? await t(W) : null;
          return this.createProgram(c, b);
        }
        async load(p, W = null) {
          return p = await I.fetchShader(p), W && (W = await I.fetchShader(W)), this.compile(p, W);
        }
        createTexture(p = null, {
          wrapS: W = this.gl.CLAMP_TO_EDGE,
          wrapT: V = this.gl.CLAMP_TO_EDGE,
          minFilter: t = this.gl.LINEAR,
          magFilter: c = this.gl.LINEAR
        } = {}) {
          const b = this.gl, Z = Array.isArray(p) ? b.TEXTURE_CUBE_MAP : b.TEXTURE_2D;
          this._max_texture_image_units = this._max_texture_image_units || b.getParameter(b.MAX_COMBINED_TEXTURE_IMAGE_UNITS), b.activeTexture(b.TEXTURE0 + this._max_texture_image_units - 1);
          const r = b.createTexture();
          b.bindTexture(Z, r), b.pixelStorei(b.UNPACK_FLIP_Y_WEBGL, !0);
          const {
            width: S,
            height: C
          } = this.canvas;
          if (p)
            if (Z === b.TEXTURE_CUBE_MAP)
              for (let F = 0; F < 6; F++)
                b.texImage2D(b.TEXTURE_CUBE_MAP_POSITIVE_X + F, 0, b.RGBA, b.RGBA, b.UNSIGNED_BYTE, p[F]);
            else
              b.texImage2D(Z, 0, b.RGBA, b.RGBA, b.UNSIGNED_BYTE, p);
          else if (Z === b.TEXTURE_CUBE_MAP)
            for (let F = 0; F < 6; F++)
              this.gl.texImage2D(this.gl.TEXTURE_CUBE_MAP_POSITIVE_X + F, 0, b.RGBA, S, C, 0, b.RGBA, b.UNSIGNED_BYTE, null);
          else
            b.texImage2D(Z, 0, b.RGBA, S, C, 0, b.RGBA, b.UNSIGNED_BYTE, null);
          return b.texParameteri(Z, b.TEXTURE_MIN_FILTER, t), b.texParameteri(Z, b.TEXTURE_MAG_FILTER, c), b.texParameteri(Z, b.TEXTURE_WRAP_S, W), b.texParameteri(Z, b.TEXTURE_WRAP_T, V), Z === b.TEXTURE_CUBE_MAP && (p.width = p[0].width, p.height = p[0].height), b.bindTexture(Z, null), r._img = p || {
            width: S,
            height: C
          }, r.delete = () => {
            this.deleteTexture(r);
          }, r;
        }
        deleteTexture(p) {
          const W = p._img;
          this.gl.deleteTexture(p), typeof W.close == "function" && W.close();
        }
        async loadTexture(p, {
          useImageBitmap: W = !0
        } = {}) {
          const V = await I.loadImage(p, {
            useImageBitmap: W
          });
          return this.createTexture(V);
        }
        createFBO({
          color: p = 1,
          blend: W = !1,
          depth: V = this.options.depth !== !1,
          stencil: t = !!this.options.stencil
        } = {}) {
          const c = this.gl, b = c.createFramebuffer();
          c.bindFramebuffer(c.FRAMEBUFFER, b);
          const Z = [];
          for (let C = 0; C < p; C++) {
            const F = this.createTexture();
            c.framebufferTexture2D(
              c.FRAMEBUFFER,
              c.COLOR_ATTACHMENT0 + C,
              c.TEXTURE_2D,
              F,
              0
              /* level */
            ), Z.push(F);
          }
          b.textures = Z, b.texture = Z[0], b.blend = W;
          const {
            width: r,
            height: S
          } = this.canvas;
          return V && !t && (b.depthBuffer = c.createRenderbuffer(), c.bindRenderbuffer(c.RENDERBUFFER, b.depthBuffer), c.renderbufferStorage(c.RENDERBUFFER, c.DEPTH_COMPONENT16, r, S), c.framebufferRenderbuffer(c.FRAMEBUFFER, c.DEPTH_ATTACHMENT, c.RENDERBUFFER, b.depthBuffer)), t && !V && (b.stencilBuffer = c.createRenderbuffer(), c.bindRenderbuffer(c.RENDERBUFFER, b.stencilBuffer), c.renderbufferStorage(c.RENDERBUFFER, c.STENCIL_INDEX8, r, S), c.framebufferRenderbuffer(c.FRAMEBUFFER, c.STENCIL_ATTACHMENT, c.RENDERBUFFER, b.stencilBuffer)), V && t && (b.depthStencilBuffer = c.createRenderbuffer(), c.bindRenderbuffer(c.RENDERBUFFER, b.depthStencilBuffer), c.renderbufferStorage(c.RENDERBUFFER, c.DEPTH_STENCIL, r, S), c.framebufferRenderbuffer(c.FRAMEBUFFER, c.DEPTH_STENCIL_ATTACHMENT, c.RENDERBUFFER, b.depthStencilBuffer)), c.bindFramebuffer(c.FRAMEBUFFER, null), b;
        }
        bindFBO(p = null) {
          this.fbo = p;
        }
        render({
          clearBuffer: p = !0
        } = {}) {
          this.startRender = !0;
          const W = this.gl;
          let V = this.program;
          V || (V = this.createProgram(), this.useProgram(V)), this.fbo && W.bindFramebuffer(W.FRAMEBUFFER, this.fbo);
          const t = this.options.depth;
          t && W.enable(W.DEPTH_TEST), this.gl.clear(this.gl.COLOR_BUFFER_BIT | (t ? this.gl.DEPTH_BUFFER_BIT : 0) | (this.options.stencil ? this.gl.STENCIL_BUFFER_BIT : 0));
          const c = this._renderFrameID;
          this._draw(), this.fbo && W.bindFramebuffer(W.FRAMEBUFFER, null), this._renderFrameID === c && (this._renderFrameID = null);
        }
        update() {
          this.startRender && this._renderFrameID == null && (this._renderFrameID = requestAnimationFrame(this.render.bind(this)));
        }
      }
      e(I, "defaultOptions", {
        preserveDrawingBuffer: !0,
        autoUpdate: !0,
        vertexPosition: "a_vertexPosition",
        vertexTextureCoord: "a_vertexTextureCoord",
        webgl2: !1
      }), e(I, "UBYTE", I.UNSIGNED_BYTE), e(I, "USHORT", I.UNSIGNED_SHORT), e(I, "fetchShader", d.fetchShader), e(I, "loadImage", d.loadImage);
    },
    /* 16 */
    /***/
    function(m, l, i) {
      i.r(l), i.d(l, "setupWebGL", function() {
        return s;
      }), i.d(l, "createProgram", function() {
        return X;
      }), i.d(l, "pointsToBuffer", function() {
        return a;
      }), i.d(l, "loadImage", function() {
        return n;
      }), i.d(l, "fetchShader", function() {
        return y;
      }), i(1).glMatrix.setMatrixArrayType(Array);
      function d(o, h) {
        const I = ["webgl", "experimental-webgl", "webkit-3d", "moz-webgl"];
        let x = null;
        for (let p = 0; p < I.length; ++p) {
          try {
            x = o.getContext(I[p], h);
          } catch {
          }
          if (x)
            break;
        }
        return x;
      }
      function s(o, h) {
        const I = d(o, h);
        if (!I)
          throw new Error("Sorry, your browser doesn't support WebGL.");
        return I;
      }
      function X(o, h, I) {
        const x = o.createShader(o.VERTEX_SHADER);
        if (o.shaderSource(x, h), o.compileShader(x), !o.getShaderParameter(x, o.COMPILE_STATUS)) {
          const V = `Vertex shader failed to compile.  The error log is:${o.getShaderInfoLog(x)}`;
          throw new Error(V);
        }
        const p = o.createShader(o.FRAGMENT_SHADER);
        if (o.shaderSource(p, I), o.compileShader(p), !o.getShaderParameter(p, o.COMPILE_STATUS)) {
          const V = `Fragment shader failed to compile.  The error log is:${o.getShaderInfoLog(p)}`;
          throw new Error(V);
        }
        const W = o.createProgram();
        if (o.attachShader(W, x), o.attachShader(W, p), o.linkProgram(W), !o.getProgramParameter(W, o.LINK_STATUS)) {
          const V = `Shader program failed to link.  The error log is:${o.getProgramInfoLog(W)}`;
          throw new Error(V);
        }
        return o.deleteShader(x), o.deleteShader(p), W;
      }
      function a(o, h = Float32Array, I = null) {
        if (I && !(I instanceof h))
          throw new TypeError("Wrong buffer type.");
        if (o == null || o instanceof h)
          return o;
        if (o[0] == null || o[0].length == null)
          return I ? (I.set(o, 0), I) : new h(o);
        const x = o[0].length, p = o.length;
        I || (I = new h(x * p));
        let W = 0;
        for (let V = 0; V < p; V++)
          for (let t = 0; t < x; t++)
            I[W++] = o[V][t];
        return I;
      }
      const e = {};
      function n(o, {
        useImageBitmap: h = !0,
        alias: I = null
      } = {}) {
        if (!e[o]) {
          if (typeof Image == "function") {
            const x = new Image();
            typeof o == "string" && !(typeof location == "object" && /^file:/.test(location.href)) && !/^data:/.test(o) && (x.crossOrigin = "anonymous"), e[o] = new Promise((p) => {
              x.onload = function() {
                h && typeof createImageBitmap == "function" ? createImageBitmap(x, {
                  imageOrientation: "flipY"
                }).then((W) => {
                  e[o] = W, I && (e[I] = W), p(W);
                }) : (e[o] = x, I && (e[I] = x), p(x));
              }, x.src = o;
            }), I && (e[I] = e[o]);
          } else if (typeof fetch == "function")
            return fetch(o, {
              method: "GET",
              mode: "cors",
              cache: "default"
            }).then((x) => x.blob()).then((x) => createImageBitmap(x, {
              imageOrientation: "flipY"
            }).then((p) => (e[o] = p, I && (e[I] = p), p)));
        }
        return e[o];
      }
      const G = {};
      async function y(o) {
        if (G[o])
          return G[o];
        const h = await fetch(o);
        if (h.status >= 200 && h.status < 300) {
          const I = await h.text();
          return G[o] = I, I;
        }
        throw new Error("Shader loaded error.");
      }
    },
    /* 17 */
    /***/
    function(m, l, i) {
      i.r(l), l.default = `attribute vec3 a_vertexPosition;

void main() {
  gl_PointSize = 1.0;
  gl_Position = vec4(a_vertexPosition, 1);
}`;
    },
    /* 18 */
    /***/
    function(m, l, i) {
      i.r(l), l.default = `#ifdef GL_ES
precision mediump float;
#endif

void main() {
  gl_FragColor = vec4(0.0, 0.0, 0.0, 0.1);
}`;
    },
    /* 19 */
    /***/
    function(m, l, i) {
      i.r(l), l.default = `attribute vec4 a_vertexPosition;
attribute vec2 a_vertexTextureCoord;
varying vec2 vTextureCoord;

void main() {
  gl_PointSize = 1.0;
  gl_Position = a_vertexPosition;
  vTextureCoord = a_vertexTextureCoord;
}`;
    },
    /* 20 */
    /***/
    function(m, l, i) {
      i.r(l), i.d(l, "default", function() {
        return a;
      });
      var d = i(21), s = i(25);
      i(1).glMatrix.setMatrixArrayType(Array);
      const X = Symbol("transform");
      class a {
        constructor(n, G) {
          this.context = n.getContext("2d"), this.options = G, this[X] = [1, 0, 0, 1, 0, 0];
        }
        createTexture(n) {
          return {
            _img: n
          };
        }
        async loadTexture(n) {
          const G = await d.default.loadImage(n, {
            useImageBitmap: !1
          });
          return this.createTexture(G);
        }
        deleteTexture(n) {
          return n;
        }
        clear(n, G, y, o) {
          const h = this.context;
          n = n || 0, G = G || 0, y = y || h.canvas.width - n, o = o || h.canvas.height - G, h.clearRect(n, G, y, o);
        }
        drawMeshCloud(n, {
          clear: G = !1
        } = {}) {
          const y = [];
          for (let o = 0; o < n.amount; o++) {
            const h = n.getTransform(o);
            let I = n.getTextureFrame(o);
            I && (I = I._img);
            const x = n.getFilter(o), {
              fill: p,
              stroke: W
            } = n.getCloudRGBA(o);
            y.push({
              mesh: n.mesh,
              _cloudOptions: [p, W, I, h, x]
            });
          }
          n.beforeRender && n.beforeRender(this.context, n), this.drawMeshes(y, {
            clear: G,
            hook: !1
          }), n.afterRender && n.afterRender(this.context, n);
        }
        drawMeshes(n, {
          clear: G = !1,
          hook: y = !0
        } = {}) {
          const o = this.context;
          G && o.clearRect(0, 0, o.canvas.width, o.canvas.height);
          let h = null;
          const {
            width: I,
            height: x
          } = o.canvas, p = n.length;
          n.forEach((W, V) => {
            let t, c, b, Z, r;
            y && W.beforeRender && W.beforeRender(o, W), W._cloudOptions && ([t, c, b, Z, r] = W._cloudOptions, W = W.mesh);
            let S = W.filter;
            if (r && (S = S ? `${S} ${r}` : r), S && !this.filterBuffer && this.filterBuffer !== !1) {
              const C = d.default.createCanvas(I, x);
              C ? this.filterBuffer = C.getContext("2d") : this.filterBuffer = !1;
            }
            h && h !== S && (Object(s.applyFilter)(this.filterBuffer, h), o.drawImage(this.filterBuffer.canvas, 0, 0, I, x), this.filterBuffer.clearRect(0, 0, I, x), h = null), S && this.filterBuffer ? (this.filterBuffer.save(), this.filterBuffer.transform(...this[X]), Object(s.drawMesh2D)(W, this.filterBuffer, !1, t, c, b, Z), this.filterBuffer.restore(), V === p - 1 ? (Object(s.applyFilter)(this.filterBuffer, S), o.drawImage(this.filterBuffer.canvas, 0, 0, I, x), this.filterBuffer.clearRect(0, 0, I, x)) : h = S) : (o.save(), o.transform(...this[X]), Object(s.drawMesh2D)(W, o, !1, t, c, b, Z), o.restore()), y && W.afterRender && W.afterRender(o, W);
          });
        }
        setTransform(n) {
          this[X] = n;
        }
      }
    },
    /* 21 */
    /***/
    function(m, l, i) {
      i.r(l), (function(d) {
        var s = i(14), X = i(23), a = i(24);
        i(1).glMatrix.setMatrixArrayType(Array);
        const e = {};
        function n(I, x) {
          const {
            style: p,
            variant: W,
            weight: V,
            stretch: t,
            size: c,
            pxLineHeight: b,
            family: Z
          } = I;
          return t === "normal" ? `${p} ${W} ${V} ${c * x}px/${b * x}px ${Z}` : `${p} ${W} ${V} ${t} ${c * x}px/${b * x}px ${Z}`;
        }
        function G(I, {
          font: x,
          fillColor: p,
          strokeColor: W,
          strokeWidth: V,
          ratio: t = 1,
          textCanvas: c,
          cachable: b = !1
        }) {
          let Z;
          if (b) {
            Z = [I, x, String(p), String(W), String(V)].join("###");
            const f = e[Z];
            if (f)
              return f;
          }
          c || (c = o(1, 1));
          const r = c.getContext("2d");
          r.save(), r.font = x;
          let {
            width: S
          } = r.measureText(I);
          r.restore();
          const C = Object(X.default)(x), F = Math.max(C.pxLineHeight, C.pxHeight * 1.13);
          /italic|oblique/.test(x) && (S += F * Math.tan(15 * Math.PI / 180)), !p && !W && (p = "#000");
          const Y = r.canvas, J = Math.ceil(S), T = Math.ceil(F);
          Y.width = Math.round(J * t), Y.height = Math.round(T * t), r.save(), r.font = n(C, t), r.textAlign = "center", r.textBaseline = "middle";
          const K = Y.height * 0.5 + C.pxHeight * 0.05 * t, R = Y.width * 0.5;
          if (p) {
            if (Array.isArray(p))
              p = Object(a.default)(p);
            else if (p.vector) {
              let f;
              const {
                vector: w,
                colors: O
              } = p;
              w.length === 6 ? f = r.createRadialGradient(...w) : f = r.createLinearGradient(...w), O.forEach(({
                offset: q,
                color: k
              }) => {
                f.addColorStop(q, k);
              }), p = f;
            }
            r.fillStyle = p, r.fillText(I, R, K);
          }
          if (W) {
            if (r.lineWidth = V * t, Array.isArray(W))
              W = Object(a.default)(W);
            else if (W.vector) {
              let f;
              const {
                vector: w,
                colors: O
              } = W;
              w.length === 6 ? f = r.createRadialGradient(...w) : f = r.createLinearGradient(...w), O.forEach(({
                offset: q,
                color: k
              }) => {
                f.addColorStop(q, k);
              }), W = f;
            }
            r.strokeStyle = W, r.strokeText(I, R, K);
          }
          r.restore();
          const H = {
            image: c,
            rect: [0, 0, J, T]
          };
          return b && (e[Z] = H), H;
        }
        let y = !1;
        if (typeof navigator == "object" && typeof navigator.userAgent == "string") {
          const I = navigator.userAgent.toLowerCase().match(/chrome\/(\d+)/);
          I && (y = Number(I[1]) < 70);
        }
        function o(I, x, p = {}) {
          const W = p.offscreen || !y && p.offscreen !== !1;
          let V;
          return typeof d < "u" && typeof d.createCanvas == "function" ? V = d.createCanvas(I, x, p) : W && typeof OffscreenCanvas == "function" ? V = new OffscreenCanvas(I, x) : (V = document.createElement("canvas"), V.width = I, V.height = x), V;
        }
        const h = {
          createCanvas: o,
          createText: G,
          loadImage: s.default.loadImage
        };
        l.default = h;
      }).call(this, i(22));
    },
    /* 22 */
    /***/
    function(m, l) {
      var i;
      i = /* @__PURE__ */ function() {
        return this;
      }();
      try {
        i = i || new Function("return this")();
      } catch {
        typeof window == "object" && (i = window);
      }
      m.exports = i;
    },
    /* 23 */
    /***/
    function(m, l, i) {
      i.r(l), i.d(l, "default", function() {
        return p;
      }), i(1).glMatrix.setMatrixArrayType(Array);
      function d(W, V) {
        if (typeof W == "string") {
          const b = W.trim().match(/^([\d.]+)(px|pt|pc|in|cm|mm|em|ex|rem|q|vw|vh|vmax|vmin|%)$/);
          b ? W = {
            size: parseFloat(b[1]),
            unit: b[2]
          } : W = {
            size: parseInt(W, 10),
            unit: "px"
          };
        }
        let {
          size: t,
          unit: c
        } = W;
        if (c === "pt")
          t /= 0.75;
        else if (c === "pc")
          t *= 16;
        else if (c === "in")
          t *= 96;
        else if (c === "cm")
          t *= 96 / 2.54;
        else if (c === "mm")
          t *= 96 / 25.4;
        else if (c === "em" || c === "rem" || c === "ex") {
          if (!V && typeof getComputedStyle == "function" && typeof document < "u") {
            const b = getComputedStyle(document.documentElement).fontSize;
            V = d(b, 16);
          }
          t *= V, c === "ex" && (t /= 2);
        } else if (c === "q")
          t *= 96 / 25.4 / 4;
        else if (c === "vw" || c === "vh") {
          if (typeof document < "u") {
            const b = c === "vw" ? document.documentElement.clientWidth : document.documentElement.clientHeight;
            t *= b / 100;
          }
        } else if ((c === "vmax" || c === "vmin") && typeof document < "u") {
          const b = document.documentElement.clientWidth, Z = document.documentElement.clientHeight;
          c === "vmax" ? t *= Math.max(b, Z) / 100 : t *= Math.min(b, Z) / 100;
        }
        return t;
      }
      const s = "bold|bolder|lighter|[1-9]00", X = "italic|oblique", a = "small-caps", e = "ultra-condensed|extra-condensed|condensed|semi-condensed|semi-expanded|expanded|extra-expanded|ultra-expanded", n = "px|pt|pc|in|cm|mm|em|ex|rem|q|vw|vh|vmax|vmin|%", G = `'([^']+)'|"([^"]+)"|([\\w-]|[一-龥])+`, y = new RegExp(`(${s}) +`, "i"), o = new RegExp(`(${X}) +`, "i"), h = new RegExp(`(${a}) +`, "i"), I = new RegExp(`(${e}) +`, "i"), x = new RegExp("([\\d\\.]+)(" + n + ")(?:\\/([\\d\\.]+)(" + n + "))? *((?:" + G + ")( *, *(?:" + G + "))*)");
      function p(W, V) {
        const t = x.exec(W);
        if (!t)
          return;
        const c = parseFloat(t[3]), b = {
          weight: "normal",
          style: "normal",
          stretch: "normal",
          variant: "normal",
          size: parseFloat(t[1]),
          unit: t[2],
          lineHeight: Number.isFinite(c) ? c : void 0,
          lineHeightUnit: t[4],
          family: t[5].replace(/ *, */g, ",")
        }, Z = W.substring(0, t.index), r = y.exec(Z), S = o.exec(Z), C = h.exec(Z), F = I.exec(Z);
        return r && (b.weight = r[1]), S && (b.style = S[1]), C && (b.variant = C[1]), F && (b.stretch = F[1]), b.pxHeight = d({
          size: b.size,
          unit: b.unit
        }, V), b.pxLineHeight = d({
          size: b.lineHeight || b.size,
          unit: b.lineHeightUnit || b.unit
        }, V), b;
      }
    },
    /* 24 */
    /***/
    function(m, l, i) {
      i.r(l), i.d(l, "default", function() {
        return d;
      }), i(1).glMatrix.setMatrixArrayType(Array);
      function d(s) {
        return `rgba(${s.map((X, a) => a < 3 ? Math.round(X * 255) : X).join()})`;
      }
    },
    /* 25 */
    /***/
    function(m, l, i) {
      i.r(l), i.d(l, "applyFilter", function() {
        return e;
      }), i.d(l, "drawMesh2D", function() {
        return G;
      });
      var d = i(1), s = i(24), X = i(23), a = i(26);
      i(1).glMatrix.setMatrixArrayType(Array);
      function e(y, o) {
        const h = y.canvas;
        y.save(), y.filter = o, y.drawImage(h, 0, 0, h.width, h.height), y.restore();
      }
      function n(y, o) {
        const h = /rgba\((\d+),(\d+),(\d+),(\d+)\)/;
        y = y.match(h).slice(1, 5).map(Number), o = o.match(h).slice(1, 5).map(Number);
        const I = [], x = o[3];
        for (let p = 0; p < 4; p++)
          I[p] = Object(a.mix)(y[p], o[p], x);
        return `rgba(${I.join()})`;
      }
      function G(y, o, h = !0, I = null, x = null, p = null, W = null) {
        o.save();
        let V = !1, t = !1;
        if (o.globalAlpha = y.getOpacity(), y._updateMatrix && y.transformScale / y.contours.scale > 1.5 && y.accurate(y.transformScale), y.lineWidth) {
          let Z = y.gradient && y.gradient.stroke;
          if (Z) {
            const {
              vector: r,
              colors: S
            } = Z;
            if (r.length === 6)
              Z = o.createRadialGradient(...r);
            else if (r.length === 4)
              Z = o.createLinearGradient(...r);
            else if (r.length === 3)
              Z = o.createCircularGradient(...r);
            else
              throw new TypeError("Invalid vector dimension.");
            S.forEach(({
              offset: C,
              color: F
            }) => {
              let Y = Object(s.default)(F);
              x && (Y = n(Y, x)), Z.addColorStop(C, Y);
            }), o.strokeStyle = Z, V = !0;
          } else
            y.strokeStyle && (x ? o.strokeStyle = n(y.strokeStyle, x) : o.strokeStyle = y.strokeStyle, V = !0);
        }
        V && (o.lineWidth = y.lineWidth, o.lineJoin = y.lineJoin, o.lineCap = y.lineCap, o.miterLimit = y.miterLimit, y.lineDash && (o.setLineDash(y.lineDash), y.lineDashOffset && (o.lineDashOffset = y.lineDashOffset)));
        let c = y.gradient && y.gradient.fill;
        if (c) {
          const {
            vector: Z,
            colors: r
          } = c;
          if (Z.length === 6)
            c = o.createRadialGradient(...Z);
          else if (Z.length === 4)
            c = o.createLinearGradient(...Z);
          else if (Z.length === 3)
            c = o.createCircularGradient(...Z);
          else
            throw new TypeError("Invalid vector dimension.");
          r.forEach(({
            offset: S,
            color: C
          }) => {
            let F = Object(s.default)(C);
            x && (F = n(F, x)), c.addColorStop(S, F);
          }), o.fillStyle = c, t = !0;
        } else
          y.fillStyle && (I ? o.fillStyle = n(y.fillStyle, I) : o.fillStyle = y.fillStyle, t = !0);
        if (W && o.transform(...W), o.transform(...y.transformMatrix), y.clipPath) {
          const Z = y.clipPath, r = new Path2D(Z);
          o.clip(r);
        }
        const b = y.contours.length;
        if (y.contours.forEach((Z, r) => {
          const S = Z.length, C = S > 1 && d.vec2.equals(Z[0], Z[S - 1]), F = r === b - 1 && y.texture;
          if (Z && S > 0) {
            if (t || V || F) {
              o.beginPath(), o.moveTo(...Z[0]);
              for (let Y = 1; Y < S; Y++)
                Y === S - 1 && C ? o.closePath() : o.lineTo(...Z[Y]);
            }
            if (t && o.fill(y.fillRule), F) {
              o.save(), o.clip();
              let {
                image: Y,
                options: J
              } = y.texture;
              if (p && (Y = p), J.repeat && console.warn("Context 2D not supported image repeat yet."), Y.font) {
                J.scale && console.warn("Context 2D not supported text scale yet."), J.srcRect && console.warn("Context 2D not supported text srcRect yet.");
                let {
                  font: T,
                  fillColor: K,
                  strokeColor: R,
                  strokeWidth: H,
                  text: f
                } = Y;
                !K && !R && (K = "#000"), Array.isArray(K) && (K = Object(s.default)(K)), Array.isArray(R) && (R = Object(s.default)(R)), o.font = T;
                const {
                  width: w
                } = o.measureText(f), O = Object(X.default)(T), q = Math.max(O.pxLineHeight, O.pxHeight * 1.13);
                o.textAlign = "center", o.textBaseline = "middle";
                const k = J.rect, Q = k[0] + q * 0.5 + O.pxHeight * 0.06, D = k[1] + w * 0.5;
                k[2] != null && o.scale(k[2] / w, k[3] / q), K && (o.fillStyle = K, o.fillText(f, D, Q)), R && (o.lineWidth = H, o.strokeStyle = R, o.strokeText(f, D, Q));
              } else {
                let T = J.rect;
                const K = J.srcRect;
                J.scale && (T = [0, 0, o.canvas.width, o.canvas.height]), J.rotated && T && (T = [-T[1], T[0], T[3], T[2]]), K && (T = T || [0, 0, K[2], K[3]]), J.rotated && (o.translate(0, T ? T[2] : Y.width), o.rotate(-0.5 * Math.PI)), K ? o.drawImage(Y, ...K, ...T) : T ? o.drawImage(Y, ...T) : o.drawImage(Y, 0, 0);
              }
              o.restore();
            }
            V && o.stroke();
          }
        }), o.restore(), h) {
          const Z = y.filter;
          Z && e(o, Z);
        }
      }
    },
    /* 26 */
    /***/
    function(m, l, i) {
      i.r(l), i.d(l, "clamp", function() {
        return d;
      }), i.d(l, "mix", function() {
        return s;
      }), i.d(l, "transformPoint", function() {
        return X;
      }), i(1).glMatrix.setMatrixArrayType(Array);
      function d(a, e, n) {
        return e > n && ([e, n] = [n, e]), a < e ? e : a > n ? n : a;
      }
      function s(a, e, n) {
        return a * (1 - n) + e * n;
      }
      function X(a, e) {
        const [n, G] = a;
        return [n * e[0] + G * e[2] + e[4], n * e[1] + G * e[3] + e[5]];
      }
    },
    /* 27 */
    /***/
    function(m, l, i) {
      i.r(l), i.d(l, "default", function() {
        return n;
      });
      var d = i(28), s = i(29);
      i(1).glMatrix.setMatrixArrayType(Array);
      function X(G, y, o) {
        const h = G.uniforms || {}, I = y.uniforms || {};
        if (h.u_texSampler && I.u_texSampler && h.u_texSampler !== I.u_texSampler)
          return !1;
        const x = Object.keys(h), p = Object.keys(I), W = x.indexOf("u_texSampler"), V = p.indexOf("u_texSampler");
        if (W >= 0 && x.splice(W, 1), V >= 0 && p.splice(V, 1), x.length !== p.length)
          return !1;
        const t = x.every((c) => {
          const b = h[c], Z = I[c];
          if (b === Z)
            return !0;
          if (b.length && Z.length && b.length === Z.length) {
            for (let r = 0; r < b.length; r++)
              if (b[r] !== Z[r])
                return !1;
            return !0;
          }
          return !1;
        });
        if (t) {
          if (h.u_texSampler && !I.u_texSampler)
            y.setTexture(h.u_texSampler, {
              hidden: !0
            });
          else if (!h.u_texSampler && I.u_texSampler)
            for (let c = 0; c < o.length; c++)
              o[c].setTexture(I.u_texSampler, {
                hidden: !0
              });
        }
        return t;
      }
      const a = {};
      function e(G, y) {
        if (G.length) {
          const o = Object(d.default)(G, a);
          return o.enableBlend = y, G[0].filterCanvas && (o.filterCanvas = !0), o.packIndex = G[0].packIndex, o.packLength = G.length, o.beforeRender = G[0].beforeRender, o.pass = G[0].pass, o.afterRender = G[G.length - 1].afterRender, G.length = 0, o;
        }
      }
      function* n(G, y, o = !1) {
        const h = [], I = G.options.bufferSize;
        let x = 0, p = !1;
        for (let W = 0; W < y.length; W++) {
          const V = y[W];
          if (V instanceof s.default)
            h.length && (yield e(h, p)), x = 0, p = !1, yield V;
          else {
            const t = V.meshData;
            if (t.clipPath && !t.uniforms.u_clipSampler) {
              const b = G.createTexture(t.clipPath);
              t.uniforms.u_clipSampler = b;
            }
            let c = 0;
            if ((!o || !V.canIgnore()) && t && t.positions.length) {
              V.packIndex = W;
              const b = V.filterCanvas;
              if (c = t.positions.length, b || x + c > I)
                h.length && (yield e(h, p)), x = 0, p = !1;
              else if (x) {
                const Z = h[h.length - 1];
                Z && (Z.filterCanvas || Z.afterRender || V.beforeRender || Z.pass.length || V.pass.length || Z.program !== V.program || !X(Z, V, h)) && (yield e(h, p), x = 0, p = !1);
              }
              h.push(V), p = p || V.enableBlend, x += c;
            }
            W === y.length - 1 && h.length && (yield e(h, p));
          }
        }
      }
    },
    /* 28 */
    /***/
    function(m, l, i) {
      i.r(l), i.d(l, "default", function() {
        return X;
      }), i(1).glMatrix.setMatrixArrayType(Array);
      const d = {
        UNSIGNED_BYTE: Uint8Array,
        UNSIGNED_SHORT: Uint16Array,
        BYTE: Int8Array,
        SHORT: Int16Array,
        FLOAT: Float32Array
      };
      function s(a, e) {
        let n = 0, G = 0, y = 0, o = 0, h = 0, I = 0, x = 0;
        const p = a[0].program;
        for (let W = 0; W < a.length; W++) {
          const V = a[W].meshData;
          if (V) {
            x += V.positions.length;
            const t = V.positions[0].length;
            n += V.positions.length * t, G += V.cells.length * 3, I += V.attributes.a_color.length * 4;
            const c = V.textureCoord;
            c && (y += c.length * c[0].length);
            const b = V.attributes.a_sourceRect;
            b && (o += b.length * 4);
            const Z = V.attributes.a_clipUV;
            Z && (h += Z.length * 2);
          }
        }
        if ((!e.positions || e.positions.length < n) && (e.positions = new Float32Array(n)), (!e.cells || e.cells.length < G) && (e.cells = new Uint16Array(G)), y && (!e.textureCoord || e.textureCoord.length < y) && (e.textureCoord = new Float32Array(y)), (!e.a_color || e.a_color.length < I) && (e.a_color = new Uint8Array(I)), o && (!e.a_sourceRect || e.a_sourceRect.length < o) && (e.a_sourceRect = new Float32Array(o)), h && (!e.a_clipUV || e.a_clipUV.length < h) && (e.a_clipUV = new Float32Array(h)), p) {
          const W = Object.entries(p._attribute), V = p._attribOpts || {};
          for (let t = 0; t < W.length; t++) {
            const [c, b] = W[t];
            if (c !== "a_color" && c !== "a_sourceRect" && b !== "ignored") {
              const Z = V[c] ? V[c].type : "FLOAT", r = d[Z], S = b.size * x;
              (!e[c] || e[c].length < S) && (e[c] = new r(S));
            }
          }
        }
        return e;
      }
      function X(a, e) {
        let n = [], G = [], y = [], o = [], h = [], I = [], x = 0, p = 0;
        const W = a[0] ? a[0].uniforms || {} : {}, V = a[0] ? a[0].program : null;
        e && (s(a, e), G = e.cells, n = e.positions, y = e.textureCoord, o = e.a_color, h = e.a_sourceRect, I = e.a_clipUV);
        let t = !1, c = !1;
        const b = {};
        for (let r = 0; r < a.length; r++) {
          let S = a[r];
          if (S) {
            if (S.meshData && (S = S.meshData), e) {
              const F = S.positions;
              for (let Y = 0; Y < F.length; Y++) {
                const J = F[Y], T = 3 * (x + Y);
                for (let K = 0; K < J.length; K++)
                  n[T + K] = J[K];
              }
            } else
              n.push(...S.positions);
            const C = S.cells;
            for (let F = 0; F < C.length; F++) {
              const Y = C[F];
              if (e) {
                const J = 3 * (p + F);
                G[J] = Y[0] + x, G[J + 1] = Y[1] + x, G[J + 2] = Y[2] + x;
              } else
                G.push([Y[0] + x, Y[1] + x, Y[2] + x]);
            }
            if (e) {
              const F = S.attributes.a_color;
              for (let Y = 0; Y < F.length; Y++) {
                const J = F[Y], T = 4 * (x + Y);
                o[T] = J[0], o[T + 1] = J[1], o[T + 2] = J[2], o[T + 3] = J[3];
              }
            } else
              o.push(...S.attributes.a_color);
            if (S.attributes.a_sourceRect)
              if (t = !0, e) {
                const F = S.attributes.a_sourceRect;
                for (let Y = 0; Y < F.length; Y++) {
                  const J = F[Y], T = 4 * (x + Y);
                  h[T] = J[0], h[T + 1] = J[1], h[T + 2] = J[2], h[T + 3] = J[3];
                }
              } else
                h.push(...S.attributes.a_sourceRect);
            if (S.attributes.a_clipUV)
              if (c = !0, e) {
                const F = S.attributes.a_clipUV;
                for (let Y = 0; Y < F.length; Y++) {
                  const J = F[Y], T = 2 * (x + Y);
                  I[T] = J[0], I[T + 1] = J[1];
                }
              } else
                I.push(...S.attributes.a_clipUV);
            if (S.textureCoord)
              if (e) {
                const F = S.textureCoord;
                for (let Y = 0; Y < F.length; Y++) {
                  const J = F[Y], T = 3 * (x + Y);
                  for (let K = 0; K < J.length; K++)
                    y[T + K] = J[K];
                }
              } else
                y.push(...S.textureCoord);
            if (V) {
              const F = Object.entries(V._attribute);
              for (let Y = 0; Y < F.length; Y++) {
                const [J, T] = F[Y];
                if (J !== "a_color" && J !== "a_sourceRect" && T !== "ignored")
                  if (b[J] = [], e) {
                    b[J] = e[J];
                    const K = S.attributes[J], R = K[0].length;
                    for (let H = 0; H < K.length; H++) {
                      const f = K[H], w = R * (x + H);
                      for (let O = 0; O < f.length; O++)
                        b[J][w + O] = f[O];
                    }
                  } else
                    b[J].push(...S.attributes[J]);
              }
            }
            x += S.positions.length, p += S.cells.length;
          }
        }
        b.a_color = o, t && h && h.length > 0 && (b.a_sourceRect = h);
        const Z = {
          positions: n,
          cells: G,
          attributes: b,
          uniforms: W,
          cellsCount: p * 3,
          program: V
        };
        return y && y.length && (Z.textureCoord = y), c && I.length > 0 && (b.a_clipUV = I), Z;
      }
    },
    /* 29 */
    /***/
    function(m, l, i) {
      i.r(l);
      var d = i(1), s = i(30), X = i(26), a = i(31);
      i(1).glMatrix.setMatrixArrayType(Array);
      function e(b, Z) {
        var r = Object.keys(b);
        if (Object.getOwnPropertySymbols) {
          var S = Object.getOwnPropertySymbols(b);
          Z && (S = S.filter(function(C) {
            return Object.getOwnPropertyDescriptor(b, C).enumerable;
          })), r.push.apply(r, S);
        }
        return r;
      }
      function n(b) {
        for (var Z = 1; Z < arguments.length; Z++) {
          var r = arguments[Z] != null ? arguments[Z] : {};
          Z % 2 ? e(Object(r), !0).forEach(function(S) {
            G(b, S, r[S]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(b, Object.getOwnPropertyDescriptors(r)) : e(Object(r)).forEach(function(S) {
            Object.defineProperty(b, S, Object.getOwnPropertyDescriptor(r, S));
          });
        }
        return b;
      }
      function G(b, Z, r) {
        return Z in b ? Object.defineProperty(b, Z, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : b[Z] = r, b;
      }
      const y = Symbol("mesh"), o = Symbol("count"), h = Symbol("blend"), I = Symbol("filter"), x = Symbol("textures"), p = Symbol("textureOptions"), W = Symbol("cloudColor"), V = Symbol("cloudFilter"), t = Symbol("buffer");
      function c(b, Z = null) {
        const r = new Float32Array(3 * b), S = new Float32Array(3 * b), C = new Float32Array(4 * b), F = new Float32Array(4 * b), Y = new Float32Array(4 * b), J = new Float32Array(4 * b), T = new Float32Array(4 * b), K = new Uint8Array(b), R = new Uint8Array(4 * b), H = new Uint8Array(4 * b);
        return Z && (r.set(Z.transform0, 0), S.set(Z.transform1, 0), C.set(Z.color0, 0), F.set(Z.color1, 0), Y.set(Z.color2, 0), J.set(Z.color3, 0), T.set(Z.color4, 0), K.set(Z.frameIndex, 0), R.set(Z.fillColor, 0), H.set(Z.strokeColor, 0)), {
          bufferSize: b,
          transform0: r,
          transform1: S,
          color0: C,
          color1: F,
          color2: Y,
          color3: J,
          color4: T,
          frameIndex: K,
          fillColor: R,
          strokeColor: H
        };
      }
      l.default = class {
        constructor(b, Z = 1, {
          buffer: r = 1e3
        } = {}) {
          r = Math.max(r, Z), this[o] = Z, this[y] = b, this[t] = c(r), this[x] = [], this[I] = [], this[W] = !1, this[V] = !1, this[h] = !1, this.initBuffer();
        }
        initBuffer(b = 0) {
          const Z = this[o];
          for (let r = b; r < Z; r++)
            this[t].transform0.set([1, 0, 0], r * 3), this[t].transform1.set([0, 1, 0], r * 3), this[t].frameIndex.set([-1], r), this[t].fillColor.set([0, 0, 0, 0], r * 4), this[t].strokeColor.set([0, 0, 0, 0], r * 4), this.setColorTransform(r, null);
        }
        get bufferSize() {
          return this[t].bufferSize;
        }
        get mesh() {
          return this[y];
        }
        set mesh(b) {
          this[y] = b, this[x] && this.setTextureFrames(this[x], this[p]);
        }
        get hasCloudColor() {
          return this[W];
        }
        get hasCloudFilter() {
          return this[V];
        }
        _getFilter(b) {
          return this[I][b] = this[I][b] || [], this[I][b];
        }
        getFilter(b) {
          return this._getFilter(b).join(" ");
        }
        get enableBlend() {
          return this[y].enableBlend || this[h];
        }
        canIgnore() {
          return this[y].canIgnore();
        }
        delete(b) {
          if (b >= this[o] || b < 0)
            throw new Error("Out of range.");
          const {
            transform0: Z,
            transform1: r,
            color0: S,
            color1: C,
            color2: F,
            color3: Y,
            color4: J,
            frameIndex: T,
            fillColor: K,
            strokeColor: R
          } = this[t];
          Z.set(Z.subarray(3 * (b + 1)), 3 * b), r.set(r.subarray(3 * (b + 1)), 3 * b), S.set(S.subarray(4 * (b + 1)), 4 * b), C.set(C.subarray(4 * (b + 1)), 4 * b), F.set(F.subarray(4 * (b + 1)), 4 * b), Y.set(Y.subarray(4 * (b + 1)), 4 * b), J.set(J.subarray(4 * (b + 1)), 4 * b), T.set(T.subarray(b + 1), b), K.set(K.subarray(4 * (b + 1)), 4 * b), R.set(R.subarray(4 * (b + 1)), 4 * b);
          for (const H in this[I])
            H === b ? delete this[I][H] : H > b && (this[I][H - 1] = this[I][H], delete this[I][H]);
          this[o]--;
        }
        setColorTransform(b, Z) {
          if (b >= this[o] || b < 0)
            throw new Error("Out of range.");
          b *= 4;
          const {
            color0: r,
            color1: S,
            color2: C,
            color3: F,
            color4: Y
          } = this[t];
          return Z != null ? (r.set([Z[0], Z[5], Z[10], Z[15]], b), S.set([Z[1], Z[6], Z[11], Z[16]], b), C.set([Z[2], Z[7], Z[12], Z[17]], b), F.set([Z[3], Z[8], Z[13], Z[18]], b), Y.set([Z[4], Z[9], Z[14], Z[19]], b), this[h] = this[h] || Z[18] < 1, this[V] = !0) : (r.set([1, 0, 0, 0], b), S.set([0, 1, 0, 0], b), C.set([0, 0, 1, 0], b), F.set([0, 0, 0, 1], b), Y.set([0, 0, 0, 0], b)), this;
        }
        getColorTransform(b) {
          if (b >= this[o] || b < 0)
            throw new Error("Out of range.");
          b *= 4;
          const {
            color0: Z,
            color1: r,
            color2: S,
            color3: C,
            color4: F
          } = this[t];
          return [Z[b], r[b], S[b], C[b], F[b], Z[b + 1], r[b + 1], S[b + 1], C[b + 1], F[b + 1], Z[b + 2], r[b + 2], S[b + 2], C[b + 2], F[b + 2], Z[b + 3], r[b + 3], S[b + 3], C[b + 3], F[b + 3]];
        }
        transformColor(b, Z) {
          let r = this.getColorTransform(b);
          return r = Object(s.multiply)(r, Z), this.setColorTransform(b, r), this;
        }
        setFillColor(b, Z) {
          if (b >= this[o] || b < 0)
            throw new Error("Out of range.");
          typeof Z == "string" && (Z = Object(a.default)(Z)), Z[3] > 0 && (this[W] = !0), this[t].fillColor.set(Z.map((r) => Math.round(255 * r)), 4 * b);
        }
        setStrokeColor(b, Z) {
          if (b >= this[o] || b < 0)
            throw new Error("Out of range.");
          typeof Z == "string" && (Z = Object(a.default)(Z)), Z[3] > 0 && (this[W] = !0), this[t].strokeColor.set(Z.map((r) => Math.round(255 * r)), 4 * b);
        }
        getCloudRGBA(b) {
          if (b >= this[o] || b < 0)
            throw new Error("Out of range.");
          b *= 4;
          const {
            fillColor: Z,
            strokeColor: r
          } = this[t], S = [Z[b], Z[b + 1], Z[b + 2], Z[b + 3]], C = [r[b], r[b + 1], r[b + 2], r[b + 3]];
          return S[3] /= 255, C[3] /= 255, {
            fill: `rgba(${S.join()})`,
            stroke: `rgba(${C.join()})`
          };
        }
        grayscale(b, Z) {
          this.transformColor(b, Object(s.grayscale)(Z)), this._getFilter(b).push(`grayscale(${100 * Z}%)`);
        }
        brightness(b, Z) {
          this.transformColor(b, Object(s.brightness)(Z)), this._getFilter(b).push(`brightness(${100 * Z}%)`);
        }
        saturate(b, Z) {
          this.transformColor(b, Object(s.saturate)(Z)), this._getFilter(b).push(`saturate(${100 * Z}%)`);
        }
        contrast(b, Z) {
          this.transformColor(b, Object(s.contrast)(Z)), this._getFilter(b).push(`contrast(${100 * Z}%)`);
        }
        invert(b, Z) {
          this.transformColor(b, Object(s.invert)(Z)), this._getFilter(b).push(`invert(${100 * Z}%)`);
        }
        sepia(b, Z) {
          this.transformColor(b, Object(s.sepia)(Z)), this._getFilter(b).push(`sepia(${100 * Z}%)`);
        }
        opacity(b, Z) {
          this.transformColor(b, Object(s.opacity)(Z)), this._getFilter(b).push(`opacity(${100 * Z}%)`);
        }
        hueRotate(b, Z) {
          this.transformColor(b, Object(s.hueRotate)(Z)), this._getFilter(b).push(`hue-rotate(${Z}deg)`);
        }
        setTransform(b, Z) {
          if (b >= this[o] || b < 0)
            throw new Error("Out of range.");
          b *= 3, Z == null && (Z = [1, 0, 0, 1, 0, 0]);
          const {
            transform0: r,
            transform1: S
          } = this[t];
          return r.set([Z[0], Z[2], Z[4]], b), S.set([Z[1], Z[3], Z[5]], b), this;
        }
        getTransform(b) {
          if (b >= this[o] || b < 0)
            throw new Error("Out of range.");
          b *= 3;
          const {
            transform0: Z,
            transform1: r
          } = this[t];
          return [Z[b], r[b], Z[b + 1], r[b + 1], Z[b + 2], r[b + 2]];
        }
        getTextureFrame(b) {
          return this[x][this[t].frameIndex[b]];
        }
        setTextureFrames(b = [], Z = {}) {
          if (b.length > 12)
            throw new Error("Max frames exceed. Allow 12 frames.");
          b.length && this[y].setTexture(b[0], Z), this[x] = b, this[p] = Z;
        }
        setFrameIndex(b, Z) {
          if (b >= this[o] || b < 0)
            throw new Error("Out of range.");
          const r = this[x].length;
          if (r <= 0)
            throw new Error("No frames");
          this[t].frameIndex[b] = Z % r;
        }
        get amount() {
          return this[o];
        }
        set amount(b) {
          const Z = this[o];
          b !== Z && (b > this[t].bufferSize && (this[t] = c(Math.max(b, this[t].bufferSize + 1e3), this[t])), this[o] = b, b > Z && this.initBuffer(Z));
        }
        get meshData() {
          const {
            attributes: b,
            cells: Z,
            positions: r,
            textureCoord: S,
            uniforms: C
          } = this[y].meshData, F = this[x], Y = {
            attributes: n({}, b),
            cells: Z,
            positions: r,
            textureCoord: S,
            uniforms: n({}, C),
            instanceCount: this[o],
            enableBlend: this.enableBlend
          };
          F.length && F.forEach((Q, D) => {
            Y.uniforms[`u_texFrame${D}`] = Q;
          });
          const {
            transform0: J,
            transform1: T,
            color0: K,
            color1: R,
            color2: H,
            color3: f,
            color4: w,
            fillColor: O,
            strokeColor: q,
            frameIndex: k
          } = this[t];
          return this[y].uniforms.u_texSampler && (Y.attributes.a_frameIndex = {
            data: k,
            divisor: 1
          }), Y.attributes.a_transform0 = {
            data: J,
            divisor: 1
          }, Y.attributes.a_transform1 = {
            data: T,
            divisor: 1
          }, Y.attributes.a_colorCloud0 = {
            data: K,
            divisor: 1
          }, Y.attributes.a_colorCloud1 = {
            data: R,
            divisor: 1
          }, Y.attributes.a_colorCloud2 = {
            data: H,
            divisor: 1
          }, Y.attributes.a_colorCloud3 = {
            data: f,
            divisor: 1
          }, Y.attributes.a_colorCloud4 = {
            data: w,
            divisor: 1
          }, this.hasCloudColor && (Y.attributes.a_fillCloudColor = {
            data: O,
            divisor: 1
          }, Y.attributes.a_strokeCloudColor = {
            data: q,
            divisor: 1
          }), Y;
        }
        setProgram(b) {
          this[y].setProgram(b);
        }
        get program() {
          return this[y].program;
        }
        transform(b, Z) {
          const r = this.getTransform(b);
          return Z = d.mat2d.multiply(Array.of(0, 0, 0, 0, 0, 0), r, Z), this.setTransform(b, Z), this;
        }
        translate(b, [Z, r]) {
          let S = d.mat2d.create();
          return S = d.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), S, [Z, r]), this.transform(b, S);
        }
        rotate(b, Z, [r, S] = [0, 0]) {
          let C = d.mat2d.create();
          return C = d.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), C, [r, S]), C = d.mat2d.rotate(Array.of(0, 0, 0, 0, 0, 0), C, Z), C = d.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), C, [-r, -S]), this.transform(b, C);
        }
        scale(b, [Z, r = Z], [S, C] = [0, 0]) {
          let F = d.mat2d.create();
          return F = d.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), F, [S, C]), F = d.mat2d.scale(Array.of(0, 0, 0, 0, 0, 0), F, [Z, r]), F = d.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), F, [-S, -C]), this.transform(b, F);
        }
        skew(b, [Z, r = Z], [S, C] = [0, 0]) {
          let F = d.mat2d.create();
          return F = d.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), F, [S, C]), F = d.mat2d.multiply(Array.of(0, 0, 0, 0, 0, 0), F, d.mat2d.fromValues(1, Math.tan(r), Math.tan(Z), 1, 0, 0)), F = d.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), F, [-S, -C]), this.transform(b, F);
        }
        isPointCollision(b, [Z, r], S = "both") {
          const C = this.getTransform(b), F = Object(X.transformPoint)([Z, r], d.mat2d.invert(Array.of(0, 0, 0, 0, 0, 0), C));
          return this[y].isPointCollision(...F, S);
        }
        isPointInFill(b, [Z, r]) {
          return this.isPointCollision(b, [Z, r], "fill");
        }
        isPointInStroke(b, [Z, r]) {
          return this.isPointCollision(b, [Z, r], "stroke");
        }
      };
    },
    /* 30 */
    /***/
    function(m, l, i) {
      i.r(l), i.d(l, "multiply", function() {
        return s;
      }), i.d(l, "grayscale", function() {
        return X;
      }), i.d(l, "brightness", function() {
        return a;
      }), i.d(l, "saturate", function() {
        return e;
      }), i.d(l, "contrast", function() {
        return n;
      }), i.d(l, "invert", function() {
        return G;
      }), i.d(l, "sepia", function() {
        return y;
      }), i.d(l, "opacity", function() {
        return o;
      }), i.d(l, "hueRotate", function() {
        return h;
      });
      var d = i(26);
      i(1).glMatrix.setMatrixArrayType(Array);
      function s(I, x) {
        const p = [], W = I[0], V = I[1], t = I[2], c = I[3], b = I[4], Z = I[5], r = I[6], S = I[7], C = I[8], F = I[9], Y = I[10], J = I[11], T = I[12], K = I[13], R = I[14], H = I[15], f = I[16], w = I[17], O = I[18], q = I[19];
        let k = x[0], Q = x[1], D = x[2], ii = x[3], _ = x[4];
        return p[0] = k * W + Q * Z + D * Y + ii * H, p[1] = k * V + Q * r + D * J + ii * f, p[2] = k * t + Q * S + D * T + ii * w, p[3] = k * c + Q * C + D * K + ii * O, p[4] = k * b + Q * F + D * R + ii * q + _, k = x[5], Q = x[6], D = x[7], ii = x[8], _ = x[9], p[5] = k * W + Q * Z + D * Y + ii * H, p[6] = k * V + Q * r + D * J + ii * f, p[7] = k * t + Q * S + D * T + ii * w, p[8] = k * c + Q * C + D * K + ii * O, p[9] = k * b + Q * F + D * R + ii * q + _, k = x[10], Q = x[11], D = x[12], ii = x[13], _ = x[14], p[10] = k * W + Q * Z + D * Y + ii * H, p[11] = k * V + Q * r + D * J + ii * f, p[12] = k * t + Q * S + D * T + ii * w, p[13] = k * c + Q * C + D * K + ii * O, p[14] = k * b + Q * F + D * R + ii * q + _, k = x[15], Q = x[16], D = x[17], ii = x[18], _ = x[19], p[15] = k * W + Q * Z + D * Y + ii * H, p[16] = k * V + Q * r + D * J + ii * f, p[17] = k * t + Q * S + D * T + ii * w, p[18] = k * c + Q * C + D * K + ii * O, p[19] = k * b + Q * F + D * R + ii * q + _, p;
      }
      function X(I) {
        I = Object(d.clamp)(0, 1, I);
        const x = 0.2126 * I, p = 0.7152 * I, W = 0.0722 * I;
        return [x + 1 - I, p, W, 0, 0, x, p + 1 - I, W, 0, 0, x, p, W + 1 - I, 0, 0, 0, 0, 0, 1, 0];
      }
      function a(I) {
        return [I, 0, 0, 0, 0, 0, I, 0, 0, 0, 0, 0, I, 0, 0, 0, 0, 0, 1, 0];
      }
      function e(I) {
        const x = 0.2126 * (1 - I), p = 0.7152 * (1 - I), W = 0.0722 * (1 - I);
        return [x + I, p, W, 0, 0, x, p + I, W, 0, 0, x, p, W + I, 0, 0, 0, 0, 0, 1, 0];
      }
      function n(I) {
        const x = 0.5 * (1 - I);
        return [I, 0, 0, 0, x, 0, I, 0, 0, x, 0, 0, I, 0, x, 0, 0, 0, 1, 0];
      }
      function G(I) {
        const x = 1 - 2 * I;
        return [x, 0, 0, 0, I, 0, x, 0, 0, I, 0, 0, x, 0, I, 0, 0, 0, 1, 0];
      }
      function y(I) {
        return [1 - 0.607 * I, 0.769 * I, 0.189 * I, 0, 0, 0.349 * I, 1 - 0.314 * I, 0.168 * I, 0, 0, 0.272 * I, 0.534 * I, 1 - 0.869 * I, 0, 0, 0, 0, 0, 1, 0];
      }
      function o(I) {
        return [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, I, 0];
      }
      function h(I) {
        const x = I / 180 * Math.PI, p = Math.cos(x), W = Math.sin(x), V = 0.2126, t = 0.7152, c = 0.0722;
        return [V + p * (1 - V) + W * -V, t + p * -t + W * -t, c + p * -c + W * (1 - c), 0, 0, V + p * -V + W * 0.143, t + p * (1 - t) + W * 0.14, c + p * -c + W * -0.283, 0, 0, V + p * -V + W * -(1 - V), t + p * -t + W * t, c + p * (1 - c) + W * c, 0, 0, 0, 0, 0, 1, 0];
      }
    },
    /* 31 */
    /***/
    function(m, l, i) {
      i.r(l), i.d(l, "default", function() {
        return X;
      });
      var d = i(32), s = /* @__PURE__ */ i.n(d);
      i(1).glMatrix.setMatrixArrayType(Array);
      function X(a) {
        const e = s()(a);
        if (!e || !e.length)
          throw new TypeError("Invalid color value.");
        return [e[0] / 255, e[1] / 255, e[2] / 255, e[3]];
      }
    },
    /* 32 */
    /***/
    function(m, l, i) {
      var d = i(33), s = i(37), X = i(39);
      m.exports = function(e) {
        var n, G = d(e);
        return G.space ? (n = Array(3), n[0] = X(G.values[0], 0, 255), n[1] = X(G.values[1], 0, 255), n[2] = X(G.values[2], 0, 255), G.space[0] === "h" && (n = s.rgb(n)), n.push(X(G.alpha, 0, 1)), n) : [];
      };
    },
    /* 33 */
    /***/
    function(m, l, i) {
      (function(d) {
        var s = i(34), X = i(35), a = i(36);
        m.exports = n;
        var e = {
          red: 0,
          orange: 60,
          yellow: 120,
          green: 180,
          blue: 240,
          purple: 300
        };
        function n(G) {
          var y, o = [], h = 1, I;
          if (typeof G == "string")
            if (s[G])
              o = s[G].slice(), I = "rgb";
            else if (G === "transparent")
              h = 0, I = "rgb", o = [0, 0, 0];
            else if (/^#[A-Fa-f0-9]+$/.test(G)) {
              var x = G.slice(1), p = x.length, W = p <= 4;
              h = 1, W ? (o = [
                parseInt(x[0] + x[0], 16),
                parseInt(x[1] + x[1], 16),
                parseInt(x[2] + x[2], 16)
              ], p === 4 && (h = parseInt(x[3] + x[3], 16) / 255)) : (o = [
                parseInt(x[0] + x[1], 16),
                parseInt(x[2] + x[3], 16),
                parseInt(x[4] + x[5], 16)
              ], p === 8 && (h = parseInt(x[6] + x[7], 16) / 255)), o[0] || (o[0] = 0), o[1] || (o[1] = 0), o[2] || (o[2] = 0), I = "rgb";
            } else if (y = /^((?:rgb|hs[lvb]|hwb|cmyk?|xy[zy]|gray|lab|lchu?v?|[ly]uv|lms)a?)\s*\(([^\)]*)\)/.exec(G)) {
              var V = y[1], t = V === "rgb", x = V.replace(/a$/, "");
              I = x;
              var p = x === "cmyk" ? 4 : x === "gray" ? 1 : 3;
              o = y[2].trim().split(/\s*,\s*/).map(function(r, S) {
                if (/%$/.test(r))
                  return S === p ? parseFloat(r) / 100 : x === "rgb" ? parseFloat(r) * 255 / 100 : parseFloat(r);
                if (x[S] === "h") {
                  if (/deg$/.test(r))
                    return parseFloat(r);
                  if (e[r] !== void 0)
                    return e[r];
                }
                return parseFloat(r);
              }), V === x && o.push(1), h = t || o[p] === void 0 ? 1 : o[p], o = o.slice(0, p);
            } else
              G.length > 10 && /[0-9](?:\s|\/)/.test(G) && (o = G.match(/([0-9]+)/g).map(function(b) {
                return parseFloat(b);
              }), I = G.match(/([a-z])/ig).join("").toLowerCase());
          else if (!isNaN(G))
            I = "rgb", o = [G >>> 16, (G & 65280) >>> 8, G & 255];
          else if (X(G)) {
            var c = a(G.r, G.red, G.R, null);
            c !== null ? (I = "rgb", o = [
              c,
              a(G.g, G.green, G.G),
              a(G.b, G.blue, G.B)
            ]) : (I = "hsl", o = [
              a(G.h, G.hue, G.H),
              a(G.s, G.saturation, G.S),
              a(G.l, G.lightness, G.L, G.b, G.brightness)
            ]), h = a(G.a, G.alpha, G.opacity, 1), G.opacity != null && (h /= 100);
          } else
            (Array.isArray(G) || d.ArrayBuffer && ArrayBuffer.isView && ArrayBuffer.isView(G)) && (o = [G[0], G[1], G[2]], I = "rgb", h = G.length === 4 ? G[3] : 1);
          return {
            space: I,
            values: o,
            alpha: h
          };
        }
      }).call(this, i(22));
    },
    /* 34 */
    /***/
    function(m, l, i) {
      m.exports = {
        aliceblue: [240, 248, 255],
        antiquewhite: [250, 235, 215],
        aqua: [0, 255, 255],
        aquamarine: [127, 255, 212],
        azure: [240, 255, 255],
        beige: [245, 245, 220],
        bisque: [255, 228, 196],
        black: [0, 0, 0],
        blanchedalmond: [255, 235, 205],
        blue: [0, 0, 255],
        blueviolet: [138, 43, 226],
        brown: [165, 42, 42],
        burlywood: [222, 184, 135],
        cadetblue: [95, 158, 160],
        chartreuse: [127, 255, 0],
        chocolate: [210, 105, 30],
        coral: [255, 127, 80],
        cornflowerblue: [100, 149, 237],
        cornsilk: [255, 248, 220],
        crimson: [220, 20, 60],
        cyan: [0, 255, 255],
        darkblue: [0, 0, 139],
        darkcyan: [0, 139, 139],
        darkgoldenrod: [184, 134, 11],
        darkgray: [169, 169, 169],
        darkgreen: [0, 100, 0],
        darkgrey: [169, 169, 169],
        darkkhaki: [189, 183, 107],
        darkmagenta: [139, 0, 139],
        darkolivegreen: [85, 107, 47],
        darkorange: [255, 140, 0],
        darkorchid: [153, 50, 204],
        darkred: [139, 0, 0],
        darksalmon: [233, 150, 122],
        darkseagreen: [143, 188, 143],
        darkslateblue: [72, 61, 139],
        darkslategray: [47, 79, 79],
        darkslategrey: [47, 79, 79],
        darkturquoise: [0, 206, 209],
        darkviolet: [148, 0, 211],
        deeppink: [255, 20, 147],
        deepskyblue: [0, 191, 255],
        dimgray: [105, 105, 105],
        dimgrey: [105, 105, 105],
        dodgerblue: [30, 144, 255],
        firebrick: [178, 34, 34],
        floralwhite: [255, 250, 240],
        forestgreen: [34, 139, 34],
        fuchsia: [255, 0, 255],
        gainsboro: [220, 220, 220],
        ghostwhite: [248, 248, 255],
        gold: [255, 215, 0],
        goldenrod: [218, 165, 32],
        gray: [128, 128, 128],
        green: [0, 128, 0],
        greenyellow: [173, 255, 47],
        grey: [128, 128, 128],
        honeydew: [240, 255, 240],
        hotpink: [255, 105, 180],
        indianred: [205, 92, 92],
        indigo: [75, 0, 130],
        ivory: [255, 255, 240],
        khaki: [240, 230, 140],
        lavender: [230, 230, 250],
        lavenderblush: [255, 240, 245],
        lawngreen: [124, 252, 0],
        lemonchiffon: [255, 250, 205],
        lightblue: [173, 216, 230],
        lightcoral: [240, 128, 128],
        lightcyan: [224, 255, 255],
        lightgoldenrodyellow: [250, 250, 210],
        lightgray: [211, 211, 211],
        lightgreen: [144, 238, 144],
        lightgrey: [211, 211, 211],
        lightpink: [255, 182, 193],
        lightsalmon: [255, 160, 122],
        lightseagreen: [32, 178, 170],
        lightskyblue: [135, 206, 250],
        lightslategray: [119, 136, 153],
        lightslategrey: [119, 136, 153],
        lightsteelblue: [176, 196, 222],
        lightyellow: [255, 255, 224],
        lime: [0, 255, 0],
        limegreen: [50, 205, 50],
        linen: [250, 240, 230],
        magenta: [255, 0, 255],
        maroon: [128, 0, 0],
        mediumaquamarine: [102, 205, 170],
        mediumblue: [0, 0, 205],
        mediumorchid: [186, 85, 211],
        mediumpurple: [147, 112, 219],
        mediumseagreen: [60, 179, 113],
        mediumslateblue: [123, 104, 238],
        mediumspringgreen: [0, 250, 154],
        mediumturquoise: [72, 209, 204],
        mediumvioletred: [199, 21, 133],
        midnightblue: [25, 25, 112],
        mintcream: [245, 255, 250],
        mistyrose: [255, 228, 225],
        moccasin: [255, 228, 181],
        navajowhite: [255, 222, 173],
        navy: [0, 0, 128],
        oldlace: [253, 245, 230],
        olive: [128, 128, 0],
        olivedrab: [107, 142, 35],
        orange: [255, 165, 0],
        orangered: [255, 69, 0],
        orchid: [218, 112, 214],
        palegoldenrod: [238, 232, 170],
        palegreen: [152, 251, 152],
        paleturquoise: [175, 238, 238],
        palevioletred: [219, 112, 147],
        papayawhip: [255, 239, 213],
        peachpuff: [255, 218, 185],
        peru: [205, 133, 63],
        pink: [255, 192, 203],
        plum: [221, 160, 221],
        powderblue: [176, 224, 230],
        purple: [128, 0, 128],
        rebeccapurple: [102, 51, 153],
        red: [255, 0, 0],
        rosybrown: [188, 143, 143],
        royalblue: [65, 105, 225],
        saddlebrown: [139, 69, 19],
        salmon: [250, 128, 114],
        sandybrown: [244, 164, 96],
        seagreen: [46, 139, 87],
        seashell: [255, 245, 238],
        sienna: [160, 82, 45],
        silver: [192, 192, 192],
        skyblue: [135, 206, 235],
        slateblue: [106, 90, 205],
        slategray: [112, 128, 144],
        slategrey: [112, 128, 144],
        snow: [255, 250, 250],
        springgreen: [0, 255, 127],
        steelblue: [70, 130, 180],
        tan: [210, 180, 140],
        teal: [0, 128, 128],
        thistle: [216, 191, 216],
        tomato: [255, 99, 71],
        turquoise: [64, 224, 208],
        violet: [238, 130, 238],
        wheat: [245, 222, 179],
        white: [255, 255, 255],
        whitesmoke: [245, 245, 245],
        yellow: [255, 255, 0],
        yellowgreen: [154, 205, 50]
      };
    },
    /* 35 */
    /***/
    function(m, l, i) {
      var d = Object.prototype.toString;
      m.exports = function(s) {
        var X;
        return d.call(s) === "[object Object]" && (X = Object.getPrototypeOf(s), X === null || X === Object.getPrototypeOf({}));
      };
    },
    /* 36 */
    /***/
    function(m, l) {
      m.exports = function() {
        for (var i = 0; i < arguments.length; i++)
          if (arguments[i] !== void 0)
            return arguments[i];
      };
    },
    /* 37 */
    /***/
    function(m, l, i) {
      var d = i(38);
      m.exports = {
        name: "hsl",
        min: [0, 0, 0],
        max: [360, 100, 100],
        channel: ["hue", "saturation", "lightness"],
        alias: ["HSL"],
        rgb: function(s) {
          var X = s[0] / 360, a = s[1] / 100, e = s[2] / 100, n, G, y, o, h;
          if (a === 0)
            return h = e * 255, [h, h, h];
          e < 0.5 ? G = e * (1 + a) : G = e + a - e * a, n = 2 * e - G, o = [0, 0, 0];
          for (var I = 0; I < 3; I++)
            y = X + 1 / 3 * -(I - 1), y < 0 ? y++ : y > 1 && y--, 6 * y < 1 ? h = n + (G - n) * 6 * y : 2 * y < 1 ? h = G : 3 * y < 2 ? h = n + (G - n) * (2 / 3 - y) * 6 : h = n, o[I] = h * 255;
          return o;
        }
      }, d.hsl = function(s) {
        var X = s[0] / 255, a = s[1] / 255, e = s[2] / 255, n = Math.min(X, a, e), G = Math.max(X, a, e), y = G - n, o, h, I;
        return G === n ? o = 0 : X === G ? o = (a - e) / y : a === G ? o = 2 + (e - X) / y : e === G && (o = 4 + (X - a) / y), o = Math.min(o * 60, 360), o < 0 && (o += 360), I = (n + G) / 2, G === n ? h = 0 : I <= 0.5 ? h = y / (G + n) : h = y / (2 - G - n), [o, h * 100, I * 100];
      };
    },
    /* 38 */
    /***/
    function(m, l, i) {
      m.exports = {
        name: "rgb",
        min: [0, 0, 0],
        max: [255, 255, 255],
        channel: ["red", "green", "blue"],
        alias: ["RGB"]
      };
    },
    /* 39 */
    /***/
    function(m, l) {
      m.exports = i;
      function i(d, s, X) {
        return s < X ? d < s ? s : d > X ? X : d : d < X ? X : d > s ? s : d;
      }
    },
    /* 40 */
    /***/
    function(m, l, i) {
      i.r(l), i.d(l, "default", function() {
        return c;
      });
      var d = i(41), s = /* @__PURE__ */ i.n(d), X = i(42), a = /* @__PURE__ */ i.n(X), e = i(43), n = /* @__PURE__ */ i.n(e), G = i(44), y = i(46), o = /* @__PURE__ */ i.n(y), h = i(53), I = i(55);
      i(1).glMatrix.setMatrixArrayType(Array);
      const x = Symbol("contours"), p = Symbol("path"), W = Symbol("simplify"), V = Symbol("scale"), t = 2 * Math.PI;
      class c {
        constructor(Z = {}) {
          typeof Z == "string" && (Z = {
            path: Z
          }), Z.path ? this[p] = s()(Z.path) : this[p] = [], this[x] = null, this[W] = Z.simplify != null ? Z.simplify : 0, this[V] = Z.scale != null ? Z.scale : 2;
        }
        get contours() {
          let Z = null;
          if (!this[x] && this[p]) {
            const r = Object(G.default)(n()(this[p]));
            this[x] = o()(r, this[V], this[W]), this[x].path = r, this[x].simplify = this[W], this[x].scale = this[V];
          }
          return this[x] && (Z = this[x].map((r) => [...r]), Z.path = this[x].path, Z.simplify = this[x].simplify, Z.scale = this[x].scale), Z;
        }
        get path() {
          return this[p];
        }
        get simplify() {
          return this[W];
        }
        get boundingBox() {
          const Z = this.contours;
          if (Z && Z.length) {
            const r = Z.reduce((S, C) => [...S, ...C]);
            return a()(r);
          }
          return [[0, 0], [0, 0]];
        }
        get boundingCenter() {
          const Z = this.boundingBox;
          return Z ? [0.5 * (Z[0][0] + Z[1][0]), 0.5 * (Z[0][1] + Z[1][1])] : [0, 0];
        }
        normalize(Z = 0, r = 0) {
          const S = Object(G.default)(n()(this[p])).map(([C, ...F]) => {
            const Y = [C];
            for (let J = 0; J < F.length; J += 2) {
              const T = F[J] - Z, K = F[J + 1] - r;
              Y.push(T, K);
            }
            return Y;
          });
          return this.beginPath(), this[p].push(...S), this;
        }
        getPointAtLength(Z) {
          return this.contours ? Object(h.getPointAtLength)(this[x], Z) : null;
        }
        getTotalLength() {
          return this.contours ? Object(h.getTotalLength)(this[x]) : 0;
        }
        addPath(Z) {
          this[x] = null, typeof Z == "string" && (Z = s()(Z)), this[p].push(...Z);
        }
        beginPath() {
          this[p] = [], this[x] = null;
        }
        clear() {
          this.beginPath();
        }
        ellipse(Z, r, S, C, F, Y, J, T = 0) {
          if (Y += F, J += F, S <= 0 || C <= 0 || J === Y)
            return;
          J < Y && (J = Y + t + (J - Y) % t), J - Y > t && (J = Y + t);
          const K = J - Y;
          K >= t && (J -= 1e-3);
          let R = this[p].length > 0 && K < t ? "L" : "M";
          const H = Object(I.getPoint)(Z, r, S, C, Y), f = Object(I.getPoint)(Z, r, S, C, J), w = +!T;
          let O = K > Math.PI ? 1 : 0;
          T && (O = 1 - O), R += H.join(" "), R += `A${S} ${C} 0 ${O} ${w} ${f.join(" ")}`, K >= t && (R += "Z"), this.addPath(R);
        }
        arc(Z, r, S, C, F, Y = 0) {
          return this.ellipse(Z, r, S, S, 0, C, F, Y);
        }
        arcTo(Z, r, S, C, F, Y, J) {
          this[x] = null, this[p].push(["A", Z, r, S, C, F, Y, J]);
        }
        moveTo(Z, r) {
          this[x] = null, this[p].push(["M", Z, r]);
        }
        lineTo(Z, r) {
          this[x] = null, this[p].push(["L", Z, r]);
        }
        bezierCurveTo(Z, r, S, C, F, Y) {
          this[x] = null, this[p].push(["C", Z, r, S, C, F, Y]);
        }
        quadraticCurveTo(Z, r, S, C) {
          this[x] = null, this[p].push(["Q", Z, r, S, C]);
        }
        rect(Z, r, S, C) {
          const F = `M${Z} ${r}L${Z + S} ${r}L${Z + S} ${r + C}L${Z} ${r + C}Z`;
          this.addPath(F);
        }
        closePath() {
          this[x] = null;
          let Z = [];
          const r = this[p].length;
          r > 0 && (Z = this[p][r - 1]), Z[0] !== "Z" && Z[0] !== "z" && this[p].push(["Z"]);
        }
      }
    },
    /* 41 */
    /***/
    function(m, l) {
      m.exports = s;
      var i = { a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0 }, d = /([astvzqmhlc])([^astvzqmhlc]*)/ig;
      function s(e) {
        var n = [];
        return e.replace(d, function(G, y, o) {
          var h = y.toLowerCase();
          for (o = a(o), h == "m" && o.length > 2 && (n.push([y].concat(o.splice(0, 2))), h = "l", y = y == "m" ? "l" : "L"); ; ) {
            if (o.length == i[h])
              return o.unshift(y), n.push(o);
            if (o.length < i[h])
              throw new Error("malformed path data");
            n.push([y].concat(o.splice(0, i[h])));
          }
        }), n;
      }
      var X = /-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/ig;
      function a(e) {
        var n = e.match(X);
        return n ? n.map(Number) : [];
      }
    },
    /* 42 */
    /***/
    function(m, l, i) {
      m.exports = d;
      function d(s) {
        var X = s.length;
        if (X === 0)
          return [[], []];
        for (var a = s[0].length, e = s[0].slice(), n = s[0].slice(), G = 1; G < X; ++G)
          for (var y = s[G], o = 0; o < a; ++o) {
            var h = y[o];
            e[o] = Math.min(e[o], h), n[o] = Math.max(n[o], h);
          }
        return [e, n];
      }
    },
    /* 43 */
    /***/
    function(m, l) {
      m.exports = i;
      function i(d) {
        var s = 0, X = 0, a = 0, e = 0;
        return d.map(function(n) {
          n = n.slice();
          var G = n[0], y = G.toUpperCase();
          if (G != y)
            switch (n[0] = y, G) {
              case "a":
                n[6] += a, n[7] += e;
                break;
              case "v":
                n[1] += e;
                break;
              case "h":
                n[1] += a;
                break;
              default:
                for (var o = 1; o < n.length; )
                  n[o++] += a, n[o++] += e;
            }
          switch (y) {
            case "Z":
              a = s, e = X;
              break;
            case "H":
              a = n[1];
              break;
            case "V":
              e = n[1];
              break;
            case "M":
              a = s = n[1], e = X = n[2];
              break;
            default:
              a = n[n.length - 2], e = n[n.length - 1];
          }
          return n;
        });
      }
    },
    /* 44 */
    /***/
    function(m, l, i) {
      i.r(l), i.d(l, "default", function() {
        return s;
      });
      var d = i(45);
      i(1).glMatrix.setMatrixArrayType(Array);
      function s(e) {
        for (var n, G = [], y = 0, o = 0, h = 0, I = 0, x = null, p = null, W = 0, V = 0, t = 0, c = e.length; t < c; t++) {
          var b = e[t], Z = b[0];
          switch (Z) {
            case "M":
              h = b[1], I = b[2];
              break;
            case "A":
              var r = Object(d.default)(W, V, b[6], b[7], b[4], b[5], b[1], b[2], b[3]);
              if (!r.length)
                continue;
              r = r.map((J) => {
                const [T, K, R, H, f, w, O, q] = J;
                return {
                  x1: R,
                  y1: H,
                  x2: f,
                  y2: w,
                  x: O,
                  y: q
                };
              });
              for (var S = 0, C; S < r.length; S++)
                C = r[S], b = ["C", C.x1, C.y1, C.x2, C.y2, C.x, C.y], S < r.length - 1 && G.push(b);
              break;
            case "S":
              var F = W, Y = V;
              (n == "C" || n == "S") && (F += F - y, Y += Y - o), b = ["C", F, Y, b[1], b[2], b[3], b[4]];
              break;
            case "T":
              n == "Q" || n == "T" ? (x = W * 2 - x, p = V * 2 - p) : (x = W, p = V), b = a(W, V, x, p, b[1], b[2]);
              break;
            case "Q":
              x = b[1], p = b[2], b = a(W, V, b[1], b[2], b[3], b[4]);
              break;
            case "L":
              b = X(W, V, b[1], b[2]);
              break;
            case "H":
              b = X(W, V, b[1], V);
              break;
            case "V":
              b = X(W, V, W, b[1]);
              break;
            case "Z":
              b = X(W, V, h, I);
              break;
          }
          n = Z, W = b[b.length - 2], V = b[b.length - 1], b.length > 4 ? (y = b[b.length - 4], o = b[b.length - 3]) : (y = W, o = V), G.push(b);
        }
        return G;
      }
      function X(e, n, G, y) {
        return ["C", e, n, G, y, G, y];
      }
      function a(e, n, G, y, o, h) {
        return ["C", e / 3 + 2 / 3 * G, n / 3 + 2 / 3 * y, o / 3 + 2 / 3 * G, h / 3 + 2 / 3 * y, o, h];
      }
    },
    /* 45 */
    /***/
    function(m, l, i) {
      i.r(l), i.d(l, "default", function() {
        return e;
      }), i(1).glMatrix.setMatrixArrayType(Array);
      const d = Math.PI * 2;
      function s(n, G, y, o) {
        const h = n * o - G * y < 0 ? -1 : 1;
        let I = n * y + G * o;
        return I > 1 && (I = 1), I < -1 && (I = -1), h * Math.acos(I);
      }
      function X(n, G, y, o, h, I, x, p, W, V) {
        const t = V * (n - y) / 2 + W * (G - o) / 2, c = -W * (n - y) / 2 + V * (G - o) / 2, b = x * x, Z = p * p, r = t * t, S = c * c;
        let C = b * Z - b * S - Z * r;
        C < 0 && (C = 0), C /= b * S + Z * r, C = Math.sqrt(C) * (h === I ? -1 : 1);
        const F = C * x / p * c, Y = C * -p / x * t, J = V * F - W * Y + (n + y) / 2, T = W * F + V * Y + (G + o) / 2, K = (t - F) / x, R = (c - Y) / p, H = (-t - F) / x, f = (-c - Y) / p, w = s(1, 0, K, R);
        let O = s(K, R, H, f);
        return I === 0 && O > 0 && (O -= d), I === 1 && O < 0 && (O += d), [J, T, w, O];
      }
      function a(n, G) {
        const y = 1.3333333333333333 * Math.tan(G / 4), o = Math.cos(n), h = Math.sin(n), I = Math.cos(n + G), x = Math.sin(n + G);
        return [o, h, o - h * y, h + o * y, I + x * y, x - I * y, I, x];
      }
      function e(n, G, y, o, h, I, x, p, W) {
        const V = Math.sin(W * d / 360), t = Math.cos(W * d / 360), c = t * (n - y) / 2 + V * (G - o) / 2, b = -V * (n - y) / 2 + t * (G - o) / 2;
        if (c === 0 && b === 0)
          return [];
        if (x === 0 || p === 0)
          return [];
        x = Math.abs(x), p = Math.abs(p);
        const Z = c * c / (x * x) + b * b / (p * p);
        Z > 1 && (x *= Math.sqrt(Z), p *= Math.sqrt(Z));
        const r = X(n, G, y, o, h, I, x, p, V, t), S = [];
        let C = r[2], F = r[3];
        const Y = Math.max(Math.ceil(Math.abs(F) / (d / 4)), 1);
        F /= Y;
        for (let J = 0; J < Y; J++)
          S.push(a(C, F)), C += F;
        return S.map((J) => {
          for (let T = 0; T < J.length; T += 2) {
            let K = J[T + 0], R = J[T + 1];
            K *= x, R *= p;
            const H = t * K - V * R, f = V * K + t * R;
            J[T + 0] = H + r[0], J[T + 1] = f + r[1];
          }
          return J;
        });
      }
    },
    /* 46 */
    /***/
    function(m, l, i) {
      i(1).glMatrix.setMatrixArrayType(Array);
      var d = i(47), {
        copy: s
      } = i(49), X = i(50);
      function a(o, h, I) {
        return o[0] = h, o[1] = I, o;
      }
      var e = [0, 0], n = [0, 0], G = [0, 0];
      function y(o, h, I, x) {
        d(I, a(e, x[1], x[2]), a(n, x[3], x[4]), a(G, x[5], x[6]), h, o);
      }
      m.exports = function(h, I, x) {
        var p = [], W = [], V = [0, 0];
        return h.forEach(function(t, c, b) {
          if (t[0] === "M")
            s(V, t.slice(1)), W.length > 0 && (p.push(W), W = []);
          else if (t[0] === "C")
            y(W, I, V, t), a(V, t[5], t[6]);
          else
            throw new Error("illegal type in SVG: " + t[0]);
        }), W.length > 0 && p.push(W), p.map(function(t) {
          return X(t, x || 0);
        });
      };
    },
    /* 47 */
    /***/
    function(m, l, i) {
      m.exports = i(48)();
    },
    /* 48 */
    /***/
    function(m, l) {
      function i(s) {
        return [s[0], s[1]];
      }
      function d(s, X) {
        return [s, X];
      }
      m.exports = function(X) {
        X = X || {};
        var a = typeof X.recursion == "number" ? X.recursion : 8, e = typeof X.epsilon == "number" ? X.epsilon : 11920929e-14, n = typeof X.pathEpsilon == "number" ? X.pathEpsilon : 1, G = typeof X.angleEpsilon == "number" ? X.angleEpsilon : 0.01, y = X.angleTolerance || 0, o = X.cuspLimit || 0;
        return function(p, W, V, t, c, b) {
          b || (b = []), c = typeof c == "number" ? c : 1;
          var Z = n / c;
          return Z *= Z, h(p, W, V, t, b, Z), b;
        };
        function h(x, p, W, V, t, c) {
          t.push(i(x));
          var b = x[0], Z = x[1], r = p[0], S = p[1], C = W[0], F = W[1], Y = V[0], J = V[1];
          I(b, Z, r, S, C, F, Y, J, t, c, 0), t.push(i(V));
        }
        function I(x, p, W, V, t, c, b, Z, r, S, C) {
          if (!(C > a)) {
            var F = Math.PI, Y = (x + W) / 2, J = (p + V) / 2, T = (W + t) / 2, K = (V + c) / 2, R = (t + b) / 2, H = (c + Z) / 2, f = (Y + T) / 2, w = (J + K) / 2, O = (T + R) / 2, q = (K + H) / 2, k = (f + O) / 2, Q = (w + q) / 2;
            if (C > 0) {
              var D = b - x, ii = Z - p, _ = Math.abs((W - b) * ii - (V - Z) * D), bi = Math.abs((t - b) * ii - (c - Z) * D), $, Xi;
              if (_ > e && bi > e) {
                if ((_ + bi) * (_ + bi) <= S * (D * D + ii * ii)) {
                  if (y < G) {
                    r.push(d(k, Q));
                    return;
                  }
                  var ni = Math.atan2(c - V, t - W);
                  if ($ = Math.abs(ni - Math.atan2(V - p, W - x)), Xi = Math.abs(Math.atan2(Z - c, b - t) - ni), $ >= F && ($ = 2 * F - $), Xi >= F && (Xi = 2 * F - Xi), $ + Xi < y) {
                    r.push(d(k, Q));
                    return;
                  }
                  if (o !== 0) {
                    if ($ > o) {
                      r.push(d(W, V));
                      return;
                    }
                    if (Xi > o) {
                      r.push(d(t, c));
                      return;
                    }
                  }
                }
              } else if (_ > e) {
                if (_ * _ <= S * (D * D + ii * ii)) {
                  if (y < G) {
                    r.push(d(k, Q));
                    return;
                  }
                  if ($ = Math.abs(Math.atan2(c - V, t - W) - Math.atan2(V - p, W - x)), $ >= F && ($ = 2 * F - $), $ < y) {
                    r.push(d(W, V)), r.push(d(t, c));
                    return;
                  }
                  if (o !== 0 && $ > o) {
                    r.push(d(W, V));
                    return;
                  }
                }
              } else if (bi > e) {
                if (bi * bi <= S * (D * D + ii * ii)) {
                  if (y < G) {
                    r.push(d(k, Q));
                    return;
                  }
                  if ($ = Math.abs(Math.atan2(Z - c, b - t) - Math.atan2(c - V, t - W)), $ >= F && ($ = 2 * F - $), $ < y) {
                    r.push(d(W, V)), r.push(d(t, c));
                    return;
                  }
                  if (o !== 0 && $ > o) {
                    r.push(d(t, c));
                    return;
                  }
                }
              } else if (D = k - (x + b) / 2, ii = Q - (p + Z) / 2, D * D + ii * ii <= S) {
                r.push(d(k, Q));
                return;
              }
            }
            I(x, p, Y, J, f, w, k, Q, r, S, C + 1), I(k, Q, O, q, R, H, b, Z, r, S, C + 1);
          }
        }
      };
    },
    /* 49 */
    /***/
    function(m, l, i) {
      i.r(l), i.d(l, "create", function() {
        return X;
      }), i.d(l, "clone", function() {
        return s;
      }), i.d(l, "copy", function() {
        return a;
      }), i.d(l, "scaleAndAdd", function() {
        return e;
      }), i.d(l, "dot", function() {
        return n;
      }), i.d(l, "rotate", function() {
        return G;
      }), i.d(l, "cross", function() {
        return y;
      }), i.d(l, "sub", function() {
        return o;
      }), i.d(l, "add", function() {
        return h;
      }), i.d(l, "computeMiter", function() {
        return W;
      }), i.d(l, "normal", function() {
        return V;
      }), i.d(l, "direction", function() {
        return t;
      });
      var d = i(1);
      i(1).glMatrix.setMatrixArrayType(Array);
      function s(c) {
        return [c[0], c[1]];
      }
      function X() {
        return [0, 0];
      }
      const a = d.vec2.copy, e = d.vec2.scaleAndAdd, n = d.vec2.dot, G = d.vec2.rotate, y = d.vec2.cross, o = d.vec2.sub, h = d.vec2.add, I = d.vec2.normalize, x = d.vec2.set, p = X();
      function W(c, b, Z, r, S) {
        h(c, Z, r), I(c, c), x(b, -c[1], c[0]), x(p, -Z[1], Z[0]);
        const C = S / n(b, p);
        return Math.abs(C);
      }
      function V(c, b) {
        return x(c, -b[1], b[0]), c;
      }
      function t(c, b, Z) {
        return o(c, b, Z), I(c, c), c;
      }
    },
    /* 50 */
    /***/
    function(m, l, i) {
      var d = i(51), s = i(52);
      m.exports = function(a, e) {
        return a = d(a, e), a = s(a, e), a;
      }, m.exports.radialDistance = d, m.exports.douglasPeucker = s;
    },
    /* 51 */
    /***/
    function(m, l) {
      function i(d, s) {
        var X = d[0] - s[0], a = d[1] - s[1];
        return X * X + a * a;
      }
      m.exports = function(s, X) {
        if (s.length <= 1)
          return s;
        X = typeof X == "number" ? X : 1;
        for (var a = X * X, e = s[0], n = [e], G, y = 1, o = s.length; y < o; y++)
          G = s[y], i(G, e) > a && (n.push(G), e = G);
        return e !== G && n.push(G), n;
      };
    },
    /* 52 */
    /***/
    function(m, l) {
      function i(s, X, a) {
        var e = X[0], n = X[1], G = a[0] - e, y = a[1] - n;
        if (G !== 0 || y !== 0) {
          var o = ((s[0] - e) * G + (s[1] - n) * y) / (G * G + y * y);
          o > 1 ? (e = a[0], n = a[1]) : o > 0 && (e += G * o, n += y * o);
        }
        return G = s[0] - e, y = s[1] - n, G * G + y * y;
      }
      function d(s, X, a, e, n) {
        for (var G = e, y, o = X + 1; o < a; o++) {
          var h = i(s[o], s[X], s[a]);
          h > G && (y = o, G = h);
        }
        G > e && (y - X > 1 && d(s, X, y, e, n), n.push(s[y]), a - y > 1 && d(s, y, a, e, n));
      }
      m.exports = function(X, a) {
        if (X.length <= 1)
          return X;
        a = typeof a == "number" ? a : 1;
        var e = a * a, n = X.length - 1, G = [X[0]];
        return d(X, 0, n, e, G), G.push(X[n]), G;
      };
    },
    /* 53 */
    /***/
    function(m, l, i) {
      i.r(l), i.d(l, "getTotalLength", function() {
        return s;
      }), i.d(l, "getPointAtLength", function() {
        return a;
      }), i.d(l, "getDashContours", function() {
        return e;
      });
      var d = i(54);
      i(1).glMatrix.setMatrixArrayType(Array);
      function s(n) {
        if (n.totalLength != null)
          return n.totalLength;
        let G = 0;
        return n.forEach((y) => {
          let o = y[0];
          for (let h = 1; h < y.length; h++) {
            const I = y[h];
            G += Object(d.distance)(o, I), o = I;
          }
        }), n.totalLength = G, G;
      }
      function X(n, G, y = !0) {
        if (G = Number(G), !Number.isFinite(G))
          throw new TypeError("Failed to execute 'getPointAtLength' on figure: The provided float value is non-finite.");
        if (G <= 0)
          throw new TypeError("Length must > 0");
        const o = s(n);
        if (G >= o) {
          const I = n[n.length - 1], x = I[I.length - 2], p = I[I.length - 1], W = Math.atan2(p[1] - x[1], p[0] - x[0]);
          return {
            current: n.map((V) => [...V]),
            point: {
              x: p[0],
              y: p[1],
              angle: W
            }
          };
        }
        const h = [];
        for (let I = 0; I < n.length; I++) {
          h[I] = [];
          const x = n[I];
          let p = x[0];
          for (let W = 1; W < x.length; W++) {
            const V = x[W], t = Object(d.distance)(p, V);
            if (G < t) {
              const c = G / t, b = Math.atan2(V[1] - p[1], V[0] - p[0]), Z = {
                x: p[0] * (1 - c) + V[0] * c,
                y: p[1] * (1 - c) + V[1] * c,
                angle: b
              };
              if (h[I].push(p), G > 0 && h[I].push([Z.x, Z.y]), !y)
                return {
                  current: h,
                  point: Z
                };
              const r = [], S = I;
              for (; I < n.length; I++) {
                for (r[I - S] = [], I === S && r[0].push([Z.x, Z.y]); W < x.length; W++)
                  r[I - S].push(x[W]);
                W = 0;
              }
              return {
                current: h,
                point: Z,
                rest: r
              };
            }
            G -= t, h[I].push(p), p = V;
          }
        }
      }
      function a(n, G) {
        if (G = Number(G), !Number.isFinite(G))
          throw new TypeError("Failed to execute 'getPointAtLength' on figure: The provided float value is non-finite.");
        if (n.length <= 0)
          return {
            x: 0,
            y: 0,
            angle: 0
          };
        if (G <= 0) {
          const y = n[0][0], o = n[0][1], h = Math.atan2(o[1] - y[1], o[0] - y[0]);
          return {
            x: y[0],
            y: y[1],
            angle: h
          };
        }
        return X(n, G, !1).point;
      }
      function e(n, G, y) {
        let o = 0, h = G[0], I = n;
        const x = [], p = G.length;
        if (y > 0) {
          do
            y -= G[o % p], o++;
          while (y > 0);
          y < 0 && (h = -y, o--);
        } else if (y < 0) {
          o = -1;
          do
            y += G[o % p + p - 1], o--;
          while (y < 0);
          y >= 0 && (o++, h = G[o % p + p - 1] - y);
        }
        do {
          const W = X(I, h);
          I = W.rest, ++o % 2 && x.push(...W.current);
          let V = o % p;
          V < 0 && (V += p), h = G[V];
        } while (I);
        return x;
      }
    },
    /* 54 */
    /***/
    function(m, l, i) {
      i.r(l), i.d(l, "normalize", function() {
        return d;
      }), i.d(l, "distance", function() {
        return s;
      }), i(1).glMatrix.setMatrixArrayType(Array);
      function d([X, a, e], n, G, y) {
        return X = X * 2 / n - 1, a = 1 - a * 2 / G, Number.isFinite(y) ? (e = e * 2 / y - 1, [X, a, e]) : [X, a];
      }
      function s([X, a, e = 0], [n, G, y = 0]) {
        return Math.hypot(n - X, G - a, y - e);
      }
    },
    /* 55 */
    /***/
    function(m, l, i) {
      i.r(l), i.d(l, "getPoint", function() {
        return s;
      }), i(1).glMatrix.setMatrixArrayType(Array);
      const d = Math.PI * 2;
      function s(X, a, e, n, G) {
        G %= d, G < 0 && (G += d);
        const y = Math.tan(G);
        if (Math.abs(y) < 1e5) {
          const o = a - y * X, h = 1 / e ** 2 + y ** 2 / n ** 2;
          let I = -1;
          (G <= Math.PI / 2 || G > 3 * Math.PI / 2) && (I = 1);
          const x = I * Math.sqrt(1 / h) + X, p = y * x + o;
          return [x, p];
        }
        return G < Math.PI ? [X, a + n] : [X, a - n];
      }
    },
    /* 56 */
    /***/
    function(m, l, i) {
      i.r(l), i.d(l, "default", function() {
        return E;
      });
      var d = i(1), s = i(42), X = /* @__PURE__ */ i.n(s), a = i(57), e = i(28), n = i(24), G = i(30), y = i(59), o = i(53), h = i(60), I = /* @__PURE__ */ i.n(h), x = i(46), p = /* @__PURE__ */ i.n(x), W = i(31), V = i(40), t = i(21);
      i(1).glMatrix.setMatrixArrayType(Array);
      function c(B, g) {
        if (B == null)
          return {};
        var U = b(B, g), u, L;
        if (Object.getOwnPropertySymbols) {
          var N = Object.getOwnPropertySymbols(B);
          for (L = 0; L < N.length; L++)
            u = N[L], !(g.indexOf(u) >= 0) && Object.prototype.propertyIsEnumerable.call(B, u) && (U[u] = B[u]);
        }
        return U;
      }
      function b(B, g) {
        if (B == null)
          return {};
        var U = {}, u = Object.keys(B), L, N;
        for (N = 0; N < u.length; N++)
          L = u[N], !(g.indexOf(L) >= 0) && (U[L] = B[L]);
        return U;
      }
      const Z = Symbol("mesh"), r = Symbol("contours"), S = Symbol("stroke"), C = Symbol("fill"), F = Symbol("strokeColor"), Y = Symbol("fillColor"), J = Symbol("transform"), T = Symbol("invertTransform"), K = Symbol("uniforms"), R = Symbol("texOptions"), H = Symbol("blend"), f = Symbol("applyTexture"), w = Symbol("applyTransform"), O = Symbol("applyGradientTransform"), q = Symbol("applyProgram"), k = Symbol("gradient"), Q = Symbol("filter"), D = Symbol("opacity"), ii = Symbol("program"), _ = Symbol("attributes"), bi = Symbol("pass"), $ = Symbol("clipContext"), Xi = Symbol("applyClipPath");
      function ni(B, g) {
        const [U, u] = [B[1][0] - B[0][0], B[1][1] - B[0][1]], L = [];
        for (let N = 0; N < g.length; N++) {
          const v = g[N], P = [(v[0] - B[0][0]) / U, 1 - (v[1] - B[0][1]) / u];
          L.push(P);
        }
        return L;
      }
      function M([B, g], [U, u, L, N], {
        scale: v
      }) {
        return v || (B /= L, g = 1 - g / N, B -= U, g += u), [B, g, 0];
      }
      function z(B, g, U) {
        const u = p()(B, g, U);
        return u.path = B, u.simplify = U, u.scale = g, u;
      }
      class E {
        constructor(g) {
          this[S] = null, this[C] = null, this[J] = [1, 0, 0, 1, 0, 0], this[D] = 1, this[K] = {}, this[Q] = [], this[H] = null, this[R] = {}, this.contours = g.contours, this[ii] = null, this[_] = {}, this[bi] = [];
        }
        get contours() {
          return this[r];
        }
        set contours(g) {
          this[Z] = null, this[r] = g;
          const U = g.scale;
          this.transformScale / U > 1.5 && this.accurate(this.transformScale);
        }
        setProgram(g) {
          this[ii] = g, this[Z] && this[q](g);
        }
        get program() {
          return this[ii];
        }
        setAttribute(g, U) {
          U == null ? delete this[_][g] : this[_][g] = U;
        }
        getOpacity() {
          return this[D];
        }
        setOpacity(g) {
          if (g < 0 || g > 1)
            throw new TypeError("Invalid opacity value.");
          this[Z] && this[Z].positions.forEach((U) => {
            U[2] = 1 / U[2] > 0 ? g : -g;
          }), this[D] = g;
        }
        setClipPath(g) {
          this.clipPath = g, this[K].u_clipSampler && this[K].u_clipSampler.delete(), this.setUniforms({
            u_clipSampler: null
          }), this[Z] && delete this[Z].attributes.a_clipUV, g && this[Z] && this[Xi]();
        }
        [Xi]() {
          if (this.clipPath) {
            this[$] || (this[$] = t.default.createCanvas(1, 1));
            const [[g, U], [u, L]] = this.boundingBox;
            u && L && (this[$].width = u - g, this[$].height = L - U);
            const N = this[$].getContext("2d"), v = new Path2D(this.clipPath);
            N.clearRect(0, 0, this[$].width, this[$].height), N.save(), N.translate(-g, -U), N.fillStyle = "white", N.fill(v), N.restore(), this[Z].clipPath = this[$];
            const P = ni(this.boundingBox, this[Z].position0);
            this[Z].attributes.a_clipUV = P;
          }
        }
        getPointAtLength(g) {
          return Object(o.getPointAtLength)(this[r], g);
        }
        getTotalLength() {
          return Object(o.getTotalLength)(this[r]);
        }
        get blend() {
          return this[H] == null ? "auto" : this[H];
        }
        set blend(g) {
          this[H] = g, this[Z] && (this[Z].enableBlend = this.enableBlend);
        }
        get boundingBox() {
          if (this[Z] && this[Z].boundingBox)
            return this[Z].boundingBox;
          const g = this.meshData;
          if (g) {
            const U = g.position0;
            if (U.length)
              g.boundingBox = X()(U);
            else
              return [[0, 0], [0, 0]];
            return g.boundingBox;
          }
          return [[0, 0], [0, 0]];
        }
        get boundingCenter() {
          const g = this.boundingBox;
          return g ? [0.5 * (g[0][0] + g[1][0]), 0.5 * (g[0][1] + g[1][1])] : [0, 0];
        }
        get fillRule() {
          return this[C] ? this[C].rule : "nonzero";
        }
        get lineWidth() {
          return this[S] ? this[S].lineWidth : 0;
        }
        get lineCap() {
          return this[S] ? this[S].lineCap : "";
        }
        get lineJoin() {
          return this[S] ? this[S].lineJoin : "";
        }
        get miterLimit() {
          return this[S] ? this[S].miterLimit : 0;
        }
        get strokeStyle() {
          return this[F] && this[F][3] !== 0 ? Object(n.default)(this[F]) : "";
        }
        get lineDash() {
          return this[S] ? this[S].lineDash : null;
        }
        get lineDashOffset() {
          return this[S] ? this[S].lineDashOffset : 0;
        }
        get fillStyle() {
          return this[Y] && this[Y][3] !== 0 ? Object(n.default)(this[Y]) : "";
        }
        get gradient() {
          return this[k];
        }
        get texture() {
          return this[K].u_texSampler ? {
            image: this[K].u_texSampler._img,
            options: this[R]
          } : null;
        }
        get enableBlend() {
          return this[H] === !0 || this[H] === !1 ? this[H] : this[D] < 1 || this[F] != null && this[F][3] < 1 || this[Y] != null && this[Y][3] < 1 || this[K].u_colorMatrix != null && this[K].u_colorMatrix[18] < 1 || this[K].u_radialGradientVector != null || this.beforeRender || this.afterRender;
        }
        get filterCanvas() {
          return /blur|drop-shadow|url/.test(this.filter);
        }
        get filter() {
          return this[Q].join(" ");
        }
        get transformMatrix() {
          return this[J];
        }
        get invertMatrix() {
          if (!this[T]) {
            const g = d.mat2d.invert(Array.of(0, 0, 0, 0, 0, 0), this[J]);
            this[T] = g;
          }
          return this[T];
        }
        get transformScale() {
          const g = this[J];
          return Math.max(Math.hypot(g[0], g[1]), Math.hypot(g[2], g[3]));
        }
        get uniforms() {
          return this[K];
        }
        get pass() {
          return this[bi];
        }
        [q](g) {
          const U = this[_], u = this[Z].position0, L = Object.entries(g._attribute);
          for (let N = 0; N < L.length; N++) {
            const [v, P] = L[N];
            if (v !== "a_color" && v !== "a_sourceRect" && P !== "ignored") {
              const j = U[v];
              if (v === "uv" && !j) {
                const A = this[Z].boundingBox || X()(u);
                this[Z].attributes[v] = ni(A, u);
              } else {
                this[Z].attributes[v] = [];
                for (let A = 0; A < u.length; A++) {
                  const li = u[A];
                  this[Z].attributes[v].push(j ? j(li, N, u) : Array(P.size).fill(0));
                }
              }
            }
          }
        }
        // {stroke, fill}
        get meshData() {
          if (this._updateMatrix && this.transformScale / this.contours.scale > 1.5 && this.accurate(this.transformScale), !this[Z]) {
            !this[C] && !this[S] && this.setFill();
            const g = this[r], U = {};
            if (g && g.length) {
              if (this[C])
                try {
                  const N = I()(g, this[C]);
                  N.positions = N.positions.map((v) => (v.push(this[D]), v)), N.attributes = {
                    a_color: Array.from({
                      length: N.positions.length
                    }).map(() => this[Y].map((v) => Math.round(255 * v)))
                    // a_sourceRect: Array.from({length: mesh.positions.length}).map(() => [0, 0, 0, 0]),
                  }, U.fill = N;
                } catch {
                }
              if (this[S]) {
                const N = this[S].lineDash;
                let v = g;
                if (N) {
                  const j = this[S].lineDashOffset;
                  v = Object(o.getDashContours)(g, N, j);
                }
                const P = v.map((j, A) => {
                  const li = j.length > 1 && d.vec2.equals(j[0], j[j.length - 1]), di = this[S].build(j, li);
                  return I()([di]);
                });
                P.forEach((j) => {
                  j.positions = j.positions.map((A) => (A.push(-this[D]), A)), j.attributes = {
                    a_color: Array.from({
                      length: j.positions.length
                    }).map(() => this[F].map((A) => Math.round(255 * A)))
                  };
                }), U.stroke = Object(e.default)(P);
              }
            }
            const u = Object(e.default)([U.fill, U.stroke]);
            u.fillPointCount = U.fill ? U.fill.positions.length : 0, u.enableBlend = this.enableBlend, u.position0 = u.positions.map(([N, v, P]) => [N, v, P]), u.uniforms = this[K], this[Z] = u, this[K].u_texSampler && this[f](u, this[R]);
            const L = this[J];
            Object(y.isUnitTransform)(L) || (this[w](u, L), this[K].u_radialGradientVector && this[O]()), this.clipPath && this[Xi](), this[ii] && this[q](this[ii]);
          }
          return this._updateMatrix && (this[Z].matrix = this[J], this[w](this[Z], this[J]), this[K].u_radialGradientVector && this[O]()), this[Z];
        }
        [w](g, U) {
          const {
            positions: u,
            position0: L
          } = g;
          for (let N = 0; N < u.length; N++) {
            const [v, P] = L[N], j = u[N];
            j[0] = v * U[0] + P * U[2] + U[4], j[1] = v * U[1] + P * U[3] + U[5];
          }
          this._updateMatrix = !1;
        }
        [O]() {
          const g = this[J], U = [...this._radialGradientVector];
          if (U) {
            const [u, L, , N, v] = U;
            U[0] = u * g[0] + L * g[2] + g[4], U[1] = u * g[1] + L * g[3] + g[5], U[3] = N * g[0] + v * g[2] + g[4], U[4] = N * g[1] + v * g[3] + g[5], this[K].u_radialGradientVector = U;
          }
        }
        [f](g, U) {
          function u(A, li) {
            return A == null && li == null ? !0 : A == null || li == null ? !1 : A[0] === li[0] && A[1] === li[1] && A[2] === li[2] && A[3] === li[3];
          }
          const L = this[K].u_texSampler;
          if (!L)
            return;
          const {
            width: N,
            height: v
          } = L._img, P = U.srcRect;
          let j = U.rect || [0, 0];
          if (U.rotated && (j = [-j[1], j[0], j[3], j[2]]), j[2] == null && (j[2] = P ? P[2] : N), j[3] == null && (j[3] = P ? P[3] : v), U.hidden)
            g.textureCoord = g.positions.map(() => [-1, -1, -1]);
          else if (!g.textureCoord || !u(this[R].rect, U.rect) || this[R].hidden !== U.hidden || this[R].rotated !== U.rotated) {
            let A = null;
            U.rotated && (A = d.mat2d.rotate(Array.of(0, 0, 0, 0, 0, 0), d.mat2d.fromValues(1, 0, 0, 1, 0, 0), 0.5 * Math.PI), A = d.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), A, [0, -j[2]])), g.textureCoord = g.position0.map(([li, di, ci]) => {
              if (1 / ci > 0) {
                if (U.rotated) {
                  const si = li * A[0] + di * A[2] + A[4], ti = li * A[1] + di * A[3] + A[5];
                  [li, di] = [si, ti];
                }
                const Zi = M([li, di], [j[0] / j[2], j[1] / j[3], j[2], j[3]], U);
                return U.repeat && (Zi[2] = 1), Zi;
              }
              return [-1, -1, -1];
            });
          }
          if (P) {
            const A = [P[0] / N, P[1] / v, P[2] / N, P[3] / v];
            g.attributes.a_sourceRect = g.positions.map(() => [...A]);
          } else
            g.attributes.a_sourceRect = g.positions.map(() => [0, 0, 0, 0]);
        }
        accurate(g) {
          if (!this.contours)
            return;
          if (this.contours.path) {
            const u = this.contours.simplify, L = z(this.contours.path, 2 * g, u);
            this[Z] = null, this[r] = L;
          }
        }
        canIgnore() {
          const g = this[S] == null || this[S].lineWidth === 0 || this[F][3] === 0, U = this[C] == null || this[Y][3] === 0, u = this[K].u_radialGradientVector == null, L = this[K].u_texSampler == null;
          return this[D] === 0 || this[ii] == null && g && U && u && L && !this.beforeRender && !this.afterRender;
        }
        // join: 'miter' or 'bevel'
        // cap: 'butt' or 'square'
        // lineDash: null
        // lineDashOffset: 0
        setStroke({
          thickness: g = 1,
          cap: U = "butt",
          join: u = "miter",
          miterLimit: L = 10,
          color: N = [0, 0, 0, 0],
          lineDash: v = null,
          lineDashOffset: P = 0,
          roundSegments: j = 20
        } = {}) {
          return this[Z] = null, this[S] = new a.default({
            lineWidth: g,
            lineCap: U,
            lineJoin: u,
            miterLimit: L,
            roundSegments: j
          }), typeof N == "string" && (N = Object(W.default)(N)), this[F] = N, this[S].lineDash = v, this[S].lineDashOffset = P, this;
        }
        setFill({
          rule: g = this.fillRule,
          color: U = [0, 0, 0, 0]
        } = {}) {
          return this[Z] = null, this[C] = {
            rule: g
          }, typeof U == "string" && (U = Object(W.default)(U)), this[Y] = U, this;
        }
        /**
          options: {
            scale: false,
            repeat: false,
            rotated: false,
            rect: [10, 10],
            srcRect: [...],
            hidden: false,
          }
         */
        setTexture(g, U = {}) {
          if (g && g.image) {
            const {
              image: u,
              rect: L
            } = g;
            if (g = u, U.rect)
              for (let N = 0; N < U.rect.length; N++)
                L[N] = U.rect[N];
            U.rect = L;
          }
          return this[C] || this.setFill(), this.setUniforms({
            u_texSampler: g
          }), this[Z] && this[f](this[Z], U), this[R] = U, this;
        }
        setCircularGradient({
          vector: g,
          colors: U,
          type: u = "fill"
        } = {}) {
          if (g.length !== 3)
            throw new TypeError("Invalid linearGradient.");
          this.setGradient({
            vector: g,
            colors: U,
            type: u
          });
        }
        setLinearGradient({
          vector: g,
          colors: U,
          type: u = "fill"
        } = {}) {
          if (g.length !== 4)
            throw new TypeError("Invalid linearGradient.");
          this.setGradient({
            vector: g,
            colors: U,
            type: u
          });
        }
        setRadialGradient({
          vector: g,
          colors: U,
          type: u = "fill"
        } = {}) {
          if (g.length !== 6)
            throw new TypeError("Invalid radialGradient.");
          this.setGradient({
            vector: g,
            colors: U,
            type: u
          });
        }
        /**
          vector: [x0, y0, r0, x1, y1, r1],
          colors: [{offset:0, color}, {offset:1, color}, ...],
         */
        setGradient({
          vector: g,
          colors: U,
          type: u = "fill"
        } = {}) {
          U = U.map(({
            offset: v,
            color: P
          }) => (typeof P == "string" && (P = Object(W.default)(P)), {
            offset: v,
            color: P
          })), this[k] = this[k] || {}, this[k][u] = {
            vector: g,
            colors: U
          }, U.sort((v, P) => v.offset - P.offset);
          const L = [];
          U.forEach(({
            offset: v,
            color: P
          }) => {
            L.push(v, ...P);
          });
          let N;
          if (g.length === 4 ? N = [g[0], g[1], 0, g[2], g[3], 0] : N = [...g], L.length < 40 && L.push(-1), L.length > 40)
            throw new Error("Too many colors, should be less than 8 colors");
          return this._radialGradientVector = N, this[K].u_colorSteps = L, u === "fill" ? this[K].u_gradientType = 1 : this[K].u_gradientType = 0, this[O](), this;
        }
        setUniforms(g = {}) {
          return Object.assign(this[K], g), this;
        }
        setTransform(...g) {
          const U = this[J];
          return d.mat2d.equals(g, U) || (this[J] = g, delete this[T], this._updateMatrix = !0), this;
        }
        transform(...g) {
          const U = this[J];
          return this[J] = d.mat2d.multiply(Array.of(0, 0, 0, 0, 0, 0), U, g), delete this[T], this._updateMatrix = !0, this;
        }
        translate(g, U) {
          let u = d.mat2d.create();
          return u = d.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), u, [g, U]), this.transform(...u);
        }
        rotate(g, [U, u] = [0, 0]) {
          let L = d.mat2d.create();
          return L = d.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), L, [U, u]), L = d.mat2d.rotate(Array.of(0, 0, 0, 0, 0, 0), L, g), L = d.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), L, [-U, -u]), this.transform(...L);
        }
        scale(g, U = g, [u, L] = [0, 0]) {
          let N = d.mat2d.create();
          return N = d.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), N, [u, L]), N = d.mat2d.scale(Array.of(0, 0, 0, 0, 0, 0), N, [g, U]), N = d.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), N, [-u, -L]), this.transform(...N);
        }
        skew(g, U = g, [u, L] = [0, 0]) {
          let N = d.mat2d.create();
          return N = d.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), N, [u, L]), N = d.mat2d.multiply(Array.of(0, 0, 0, 0, 0, 0), N, d.mat2d.fromValues(1, Math.tan(U), Math.tan(g), 1, 0, 0)), N = d.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), N, [-u, -L]), this.transform(...N);
        }
        clearFilter() {
          return this.setColorTransform(null), this[Q].length = 0, this;
        }
        setColorTransform(...g) {
          return g[0] === null ? this.setUniforms({
            u_filterFlag: 0,
            u_colorMatrix: 0
          }) : this.setUniforms({
            u_filterFlag: 1,
            u_colorMatrix: g
          }), this;
        }
        // apply linear color transform
        transformColor(...g) {
          let U = this.uniforms.u_colorMatrix;
          return U ? U = Object(G.multiply)(U, g) : U = g, this.setColorTransform(...U), this;
        }
        blur(g) {
          return this[Q].push(`blur(${g}px)`), this;
        }
        brightness(g = 1) {
          return this[Q].push(`brightness(${100 * g}%)`), this.transformColor(...Object(G.brightness)(g));
        }
        contrast(g = 1) {
          return this[Q].push(`contrast(${100 * g}%)`), this.transformColor(...Object(G.contrast)(g));
        }
        dropShadow(g, U, u = 0, L = [0, 0, 0, 1]) {
          return Array.isArray(L) && (L = Object(n.default)(L)), this[Q].push(`drop-shadow(${g}px ${U}px ${u}px ${L})`), this;
        }
        grayscale(g = 1) {
          return this[Q].push(`grayscale(${100 * g}%)`), this.transformColor(...Object(G.grayscale)(g));
        }
        // https://github.com/phoboslab/WebGLImageFilter/blob/master/webgl-image-filter.js#L371
        hueRotate(g = 0) {
          return this[Q].push(`hue-rotate(${g}deg)`), this.transformColor(...Object(G.hueRotate)(g));
        }
        invert(g = 1) {
          return this[Q].push(`invert(${100 * g}%)`), this.transformColor(...Object(G.invert)(g));
        }
        opacity(g = 1) {
          return this[Q].push(`opacity(${100 * g}%)`), this.transformColor(...Object(G.opacity)(g));
        }
        saturate(g = 1) {
          return this[Q].push(`saturate(${100 * g}%)`), this.transformColor(...Object(G.saturate)(g));
        }
        sepia(g = 1) {
          return this[Q].push(`sepia(${100 * g}%)`), this.transformColor(...Object(G.sepia)(g));
        }
        url(g) {
          return this[Q].push(`url(${g})`), this;
        }
        isPointCollision(g, U, u = "both") {
          const L = this.meshData, {
            positions: N,
            cells: v
          } = L, P = this.invertMatrix, j = P[0] * g + P[2] * U + P[4], A = P[1] * g + P[3] * U + P[5], li = this.boundingBox;
          if (j < li[0][0] || j > li[1][0] || A < li[0][1] || A > li[1][1])
            return !1;
          function di([ci, Zi], [si, ti], [mi, oi]) {
            const ai = mi - si, ei = oi - ti, Vi = ((ci - si) * ai + (Zi - ti) * ei) / (ai ** 2 + ei ** 2);
            return Vi >= 0 && Vi <= 1;
          }
          for (let ci = 0; ci < v.length; ci++) {
            const Zi = v[ci];
            if (u === "fill" && Zi[0] >= L.fillPointCount)
              break;
            if (u === "stroke" && Zi[0] < L.fillPointCount)
              continue;
            const [[si, ti], [mi, oi], [ai, ei]] = Zi.map((xi) => N[xi]), Vi = Math.sign((g - si) * (oi - ti) - (mi - si) * (U - ti));
            if (Vi === 0 && di([g, U], [si, ti], [mi, oi]))
              return !0;
            const Ji = Math.sign((g - mi) * (ei - oi) - (ai - mi) * (U - oi));
            if (Ji === 0 && di([g, U], [mi, oi], [ai, ei]))
              return !0;
            const Yi = Math.sign((g - ai) * (ti - ei) - (si - ai) * (U - ei));
            if (Yi === 0 && di([g, U], [ai, ei], [si, ti]) || Vi === 1 && Ji === 1 && Yi === 1 || Vi === -1 && Ji === -1 && Yi === -1)
              return !0;
          }
          return !1;
        }
        isPointInFill(g, U) {
          return this.isPointCollision(g, U, "fill");
        }
        isPointInStroke(g, U) {
          return this.isPointCollision(g, U, "stroke");
        }
        addPass(g, U = {}) {
          let {
            width: u,
            height: L
          } = U, N = c(U, ["width", "height"]);
          const v = new V.default();
          v.rect(0, 0, u, L);
          const P = new E(v, {
            width: u,
            height: L
          });
          P.setUniforms(N), P.setProgram(g), this[bi].push(P);
        }
      }
    },
    /* 57 */
    /***/
    function(m, l, i) {
      i.r(l);
      var d = i(58);
      i(1).glMatrix.setMatrixArrayType(Array), l.default = d.Stroke;
    },
    /* 58 */
    /***/
    function(m, l, i) {
      i.r(l), i.d(l, "Stroke", function() {
        return y;
      });
      var d = i(49);
      i(1).glMatrix.setMatrixArrayType(Array);
      const s = Object(d.create)(), X = Object(d.create)(), a = Object(d.create)(), e = Object(d.create)(), n = Object(d.create)(), G = 1e20;
      class y {
        constructor({
          lineWidth: p = 1,
          lineJoin: W = "miter",
          miterLimit: V = 10,
          lineCap: t = "butt",
          roundSegments: c = 20
        } = {}) {
          this.lineWidth = p, this.lineJoin = W, this.miterLimit = V, this.lineCap = t, this.roundSegments = c, this._normal = null;
        }
        build(p, W = !1) {
          let V = p.length;
          if (p = [...p], V < 2)
            return p;
          W && ((p[0][0] !== p[V - 1][0] || p[0][1] !== p[V - 1][1]) && p.push([...p[0]]), p.push([...p[1]])), V = p.length, this._normal = null;
          const t = {
            left: [],
            right: []
          }, c = this.lineWidth / 2, b = this.lineCap;
          if (!W && b === "square") {
            Object(d.direction)(X, p[0], p[1]), Object(d.scaleAndAdd)(p[0], p[0], X, c);
            const r = p.length - 1;
            Object(d.direction)(X, p[r], p[r - 1]), Object(d.scaleAndAdd)(p[r], p[r], X, c);
          }
          for (let r = 1; r < V; r++) {
            const S = p[r - 1], C = p[r], F = p[r + 1];
            this._seg(t, S, C, F, c, W);
          }
          return !W && b === "round" && I(t, this.roundSegments), [...t.left, ...t.right.reverse()];
        }
        _seg(p, W, V, t, c, b) {
          const Z = this.lineJoin === "bevel", r = this.lineJoin === "round";
          if (Object(d.direction)(X, V, W), this._normal || (this._normal = Object(d.create)(), Object(d.normal)(this._normal, X)), p.left.length || h(p, W, this._normal, c), !t)
            Object(d.normal)(this._normal, X), b ? h(p, W, this._normal, c) : h(p, V, this._normal, c);
          else {
            Object(d.direction)(a, t, V);
            let S = Object(d.computeMiter)(e, n, X, a, c);
            S = Math.min(S, G);
            const C = Object(d.dot)(e, this._normal) < 0 ? -1 : 1;
            let F = Z || r;
            if (!F && this.lineJoin === "miter" && S / c > this.miterLimit && (F = !0), F) {
              Object(d.scaleAndAdd)(s, V, this._normal, -c * C), o(p, s, C);
              let Y = 1 / 0;
              W && (Y = Math.min(Y, Math.hypot(V[0] - W[0], V[1] - W[1]))), t && (Y = Math.min(Y, Math.hypot(t[0] - V[0], t[1] - V[1])));
              const J = Math.max(c, Math.min(S, Y));
              if (Object(d.scaleAndAdd)(s, V, n, J * C), o(p, s, -C), t)
                if (Object(d.normal)(s, a), Object(d.copy)(this._normal, s), Object(d.scaleAndAdd)(s, V, s, -c * C), r) {
                  const T = Object(d.clone)(s), K = C > 0 ? p.left[p.left.length - 1] : p.right[p.right.length - 1], R = Object(d.clone)(V), H = Object(d.sub)(Object(d.create)(), K, R), f = Object(d.sub)(Object(d.create)(), T, R), w = Math.PI / this.roundSegments;
                  for (let O = 0; O < this.roundSegments && (Object(d.rotate)(H, H, [0, 0], C * w), Math.sign(Object(d.cross)(s, H, f)[2]) === C); O++)
                    Object(d.add)(s, H, R), o(p, s, C);
                  o(p, T, C);
                } else
                  o(p, s, C);
            } else
              h(p, V, n, S), Object(d.copy)(this._normal, n);
          }
        }
      }
      function o(x, p, W) {
        W > 0 ? x.left.push(Object(d.clone)(p)) : x.right.push(Object(d.clone)(p));
      }
      function h(x, p, W, V, t = -1) {
        Object(d.scaleAndAdd)(s, p, W, -V), o(x, s, -t), Object(d.scaleAndAdd)(s, p, W, V), o(x, s, t);
      }
      function I({
        left: x,
        right: p
      }, W) {
        const V = Object(d.create)(), t = Object(d.create)();
        let c = x[0], b = p[0], Z = [0.5 * (c[0] + b[0]), 0.5 * (c[1] + b[1])];
        Object(d.sub)(t, c, Z);
        for (let r = 1; r <= W; r++) {
          const S = -1 * Math.PI * r / W;
          Object(d.rotate)(V, t, [0, 0], S), Object(d.add)(s, Z, V), x.unshift(Object(d.clone)(s));
        }
        c = p[p.length - 1], b = x[x.length - 1], Z = [0.5 * (c[0] + b[0]), 0.5 * (c[1] + b[1])], Object(d.sub)(t, c, Z);
        for (let r = 1; r <= W; r++) {
          const S = -1 * Math.PI * r / W;
          Object(d.rotate)(V, t, [0, 0], S), Object(d.add)(s, Z, V), p.push(Object(d.clone)(s));
        }
      }
    },
    /* 59 */
    /***/
    function(m, l, i) {
      i.r(l), i.d(l, "isUnitTransform", function() {
        return d;
      }), i(1).glMatrix.setMatrixArrayType(Array);
      function d(s) {
        return s[0] === 1 && s[1] === 0 && s[2] === 0 && s[3] === 1 && s[4] === 0 && s[5] === 0;
      }
    },
    /* 60 */
    /***/
    function(m, l, i) {
      i(1).glMatrix.setMatrixArrayType(Array);
      var d = i(61), s = i(62);
      m.exports = function(X, a) {
        if (a = a || {}, X = X.filter(function(W) {
          return W.length > 2;
        }), X.length === 0)
          return {
            positions: [],
            cells: []
          };
        typeof a.vertexSize != "number" && (a.vertexSize = X[0][0].length), X = X.map(function(W) {
          return W.reduce(function(V, t) {
            return V.concat(t);
          });
        });
        const e = a.rule === "evenodd" ? d.WINDING_ODD : d.WINDING_NONZERO;
        for (var n = d.tesselate(s({
          contours: X,
          windingRule: e,
          elementType: d.POLYGONS,
          polySize: 3,
          vertexSize: 2
        }, a)), G = [], y = 0; y < n.vertices.length; y += a.vertexSize) {
          var o = n.vertices.slice(y, y + a.vertexSize);
          G.push(o);
        }
        var h = [];
        for (y = 0; y < n.elements.length; y += 3) {
          var I = n.elements[y], x = n.elements[y + 1], p = n.elements[y + 2];
          h.push([I, x, p]);
        }
        return {
          positions: G,
          cells: h
        };
      };
    },
    /* 61 */
    /***/
    function(m, l, i) {
      i(1).glMatrix.setMatrixArrayType(Array);
      var d = {}, s = {};
      m.exports = d, d.WINDING_ODD = 0, d.WINDING_NONZERO = 1, d.WINDING_POSITIVE = 2, d.WINDING_NEGATIVE = 3, d.WINDING_ABS_GEQ_TWO = 4, d.POLYGONS = 0, d.CONNECTED_POLYGONS = 1, d.BOUNDARY_CONTOURS = 2, d.tesselate = function(t) {
        for (var c = t.debug || !1, b = new V(), Z = 0; Z < t.contours.length; Z++)
          b.addContour(t.vertexSize || 2, t.contours[Z]);
        return b.tesselate(t.windingRule || d.WINDING_ODD, t.elementType || d.POLYGONS, t.polySize || 3, t.vertexSize || 2, t.normal || [0, 0, 1]), {
          vertices: b.vertices,
          vertexIndices: b.vertexIndices,
          vertexCount: b.vertexCount,
          elements: b.elements,
          elementCount: b.elementCount,
          mesh: c ? b.mesh : void 0
        };
      };
      var X = function(t) {
        if (!t)
          throw "Assertion Failed!";
      };
      function a() {
        this.next = null, this.prev = null, this.anEdge = null, this.coords = [0, 0, 0], this.s = 0, this.t = 0, this.pqHandle = 0, this.n = 0, this.idx = 0;
      }
      function e() {
        this.next = null, this.prev = null, this.anEdge = null, this.trail = null, this.n = 0, this.marked = !1, this.inside = !1;
      }
      function n(t) {
        this.next = null, this.Sym = null, this.Onext = null, this.Lnext = null, this.Org = null, this.Lface = null, this.activeRegion = null, this.winding = 0, this.side = t;
      }
      n.prototype = {
        get Rface() {
          return this.Sym.Lface;
        },
        set Rface(t) {
          this.Sym.Lface = t;
        },
        get Dst() {
          return this.Sym.Org;
        },
        set Dst(t) {
          this.Sym.Org = t;
        },
        get Oprev() {
          return this.Sym.Lnext;
        },
        set Oprev(t) {
          this.Sym.Lnext = t;
        },
        get Lprev() {
          return this.Onext.Sym;
        },
        set Lprev(t) {
          this.Onext.Sym = t;
        },
        get Dprev() {
          return this.Lnext.Sym;
        },
        set Dprev(t) {
          this.Lnext.Sym = t;
        },
        get Rprev() {
          return this.Sym.Onext;
        },
        set Rprev(t) {
          this.Sym.Onext = t;
        },
        get Dnext() {
          return (
            /*this.Rprev*/
            this.Sym.Onext.Sym
          );
        },
        /* 3 pointers */
        set Dnext(t) {
          this.Sym.Onext.Sym = t;
        },
        /* 3 pointers */
        get Rnext() {
          return (
            /*this.Oprev*/
            this.Sym.Lnext.Sym
          );
        },
        /* 3 pointers */
        set Rnext(t) {
          this.Sym.Lnext.Sym = t;
        }
        /* 3 pointers */
      };
      function G() {
        var t = new a(), c = new e(), b = new n(0), Z = new n(1);
        t.next = t.prev = t, t.anEdge = null, c.next = c.prev = c, c.anEdge = null, c.trail = null, c.marked = !1, c.inside = !1, b.next = b, b.Sym = Z, b.Onext = null, b.Lnext = null, b.Org = null, b.Lface = null, b.winding = 0, b.activeRegion = null, Z.next = Z, Z.Sym = b, Z.Onext = null, Z.Lnext = null, Z.Org = null, Z.Lface = null, Z.winding = 0, Z.activeRegion = null, this.vHead = t, this.fHead = c, this.eHead = b, this.eHeadSym = Z;
      }
      G.prototype = {
        /* MakeEdge creates a new pair of half-edges which form their own loop.
        * No vertex or face structures are allocated, but these must be assigned
        * before the current edge operation is completed.
        */
        //static TESShalfEdge *MakeEdge( TESSmesh* mesh, TESShalfEdge *eNext )
        makeEdge_: function(t) {
          var c = new n(0), b = new n(1);
          t.Sym.side < t.side && (t = t.Sym);
          var Z = t.Sym.next;
          return b.next = Z, Z.Sym.next = c, c.next = t, t.Sym.next = b, c.Sym = b, c.Onext = c, c.Lnext = b, c.Org = null, c.Lface = null, c.winding = 0, c.activeRegion = null, b.Sym = c, b.Onext = b, b.Lnext = c, b.Org = null, b.Lface = null, b.winding = 0, b.activeRegion = null, c;
        },
        /* Splice( a, b ) is best described by the Guibas/Stolfi paper or the
        * CS348a notes (see mesh.h).  Basically it modifies the mesh so that
        * a->Onext and b->Onext are exchanged.  This can have various effects
        * depending on whether a and b belong to different face or vertex rings.
        * For more explanation see tessMeshSplice() below.
        */
        // static void Splice( TESShalfEdge *a, TESShalfEdge *b )
        splice_: function(t, c) {
          var b = t.Onext, Z = c.Onext;
          b.Sym.Lnext = c, Z.Sym.Lnext = t, t.Onext = Z, c.Onext = b;
        },
        /* MakeVertex( newVertex, eOrig, vNext ) attaches a new vertex and makes it the
        * origin of all edges in the vertex loop to which eOrig belongs. "vNext" gives
        * a place to insert the new vertex in the global vertex list.  We insert
        * the new vertex *before* vNext so that algorithms which walk the vertex
        * list will not see the newly created vertices.
        */
        //static void MakeVertex( TESSvertex *newVertex, TESShalfEdge *eOrig, TESSvertex *vNext )
        makeVertex_: function(t, c, b) {
          var Z = t;
          X(Z !== null);
          var r = b.prev;
          Z.prev = r, r.next = Z, Z.next = b, b.prev = Z, Z.anEdge = c;
          var S = c;
          do
            S.Org = Z, S = S.Onext;
          while (S !== c);
        },
        /* MakeFace( newFace, eOrig, fNext ) attaches a new face and makes it the left
        * face of all edges in the face loop to which eOrig belongs.  "fNext" gives
        * a place to insert the new face in the global face list.  We insert
        * the new face *before* fNext so that algorithms which walk the face
        * list will not see the newly created faces.
        */
        // static void MakeFace( TESSface *newFace, TESShalfEdge *eOrig, TESSface *fNext )
        makeFace_: function(t, c, b) {
          var Z = t;
          X(Z !== null);
          var r = b.prev;
          Z.prev = r, r.next = Z, Z.next = b, b.prev = Z, Z.anEdge = c, Z.trail = null, Z.marked = !1, Z.inside = b.inside;
          var S = c;
          do
            S.Lface = Z, S = S.Lnext;
          while (S !== c);
        },
        /* KillEdge( eDel ) destroys an edge (the half-edges eDel and eDel->Sym),
        * and removes from the global edge list.
        */
        //static void KillEdge( TESSmesh *mesh, TESShalfEdge *eDel )
        killEdge_: function(t) {
          t.Sym.side < t.side && (t = t.Sym);
          var c = t.next, b = t.Sym.next;
          c.Sym.next = b, b.Sym.next = c;
        },
        /* KillVertex( vDel ) destroys a vertex and removes it from the global
        * vertex list.  It updates the vertex loop to point to a given new vertex.
        */
        //static void KillVertex( TESSmesh *mesh, TESSvertex *vDel, TESSvertex *newOrg )
        killVertex_: function(t, c) {
          var b = t.anEdge, Z = b;
          do
            Z.Org = c, Z = Z.Onext;
          while (Z !== b);
          var r = t.prev, S = t.next;
          S.prev = r, r.next = S;
        },
        /* KillFace( fDel ) destroys a face and removes it from the global face
        * list.  It updates the face loop to point to a given new face.
        */
        //static void KillFace( TESSmesh *mesh, TESSface *fDel, TESSface *newLface )
        killFace_: function(t, c) {
          var b = t.anEdge, Z = b;
          do
            Z.Lface = c, Z = Z.Lnext;
          while (Z !== b);
          var r = t.prev, S = t.next;
          S.prev = r, r.next = S;
        },
        /****************** Basic Edge Operations **********************/
        /* tessMeshMakeEdge creates one edge, two vertices, and a loop (face).
        * The loop consists of the two new half-edges.
        */
        //TESShalfEdge *tessMeshMakeEdge( TESSmesh *mesh )
        makeEdge: function() {
          var t = new a(), c = new a(), b = new e(), Z = this.makeEdge_(this.eHead);
          return this.makeVertex_(t, Z, this.vHead), this.makeVertex_(c, Z.Sym, this.vHead), this.makeFace_(b, Z, this.fHead), Z;
        },
        /* tessMeshSplice( eOrg, eDst ) is the basic operation for changing the
        * mesh connectivity and topology.  It changes the mesh so that
        *	eOrg->Onext <- OLD( eDst->Onext )
        *	eDst->Onext <- OLD( eOrg->Onext )
        * where OLD(...) means the value before the meshSplice operation.
        *
        * This can have two effects on the vertex structure:
        *  - if eOrg->Org != eDst->Org, the two vertices are merged together
        *  - if eOrg->Org == eDst->Org, the origin is split into two vertices
        * In both cases, eDst->Org is changed and eOrg->Org is untouched.
        *
        * Similarly (and independently) for the face structure,
        *  - if eOrg->Lface == eDst->Lface, one loop is split into two
        *  - if eOrg->Lface != eDst->Lface, two distinct loops are joined into one
        * In both cases, eDst->Lface is changed and eOrg->Lface is unaffected.
        *
        * Some special cases:
        * If eDst == eOrg, the operation has no effect.
        * If eDst == eOrg->Lnext, the new face will have a single edge.
        * If eDst == eOrg->Lprev, the old face will have a single edge.
        * If eDst == eOrg->Onext, the new vertex will have a single edge.
        * If eDst == eOrg->Oprev, the old vertex will have a single edge.
        */
        //int tessMeshSplice( TESSmesh* mesh, TESShalfEdge *eOrg, TESShalfEdge *eDst )
        splice: function(t, c) {
          var b = !1, Z = !1;
          if (t !== c) {
            if (c.Org !== t.Org && (Z = !0, this.killVertex_(c.Org, t.Org)), c.Lface !== t.Lface && (b = !0, this.killFace_(c.Lface, t.Lface)), this.splice_(c, t), !Z) {
              var r = new a();
              this.makeVertex_(r, c, t.Org), t.Org.anEdge = t;
            }
            if (!b) {
              var S = new e();
              this.makeFace_(S, c, t.Lface), t.Lface.anEdge = t;
            }
          }
        },
        /* tessMeshDelete( eDel ) removes the edge eDel.  There are several cases:
        * if (eDel->Lface != eDel->Rface), we join two loops into one; the loop
        * eDel->Lface is deleted.  Otherwise, we are splitting one loop into two;
        * the newly created loop will contain eDel->Dst.  If the deletion of eDel
        * would create isolated vertices, those are deleted as well.
        *
        * This function could be implemented as two calls to tessMeshSplice
        * plus a few calls to memFree, but this would allocate and delete
        * unnecessary vertices and faces.
        */
        //int tessMeshDelete( TESSmesh *mesh, TESShalfEdge *eDel )
        delete: function(t) {
          var c = t.Sym, b = !1;
          if (t.Lface !== t.Rface && (b = !0, this.killFace_(t.Lface, t.Rface)), t.Onext === t)
            this.killVertex_(t.Org, null);
          else if (t.Rface.anEdge = t.Oprev, t.Org.anEdge = t.Onext, this.splice_(t, t.Oprev), !b) {
            var Z = new e();
            this.makeFace_(Z, t, t.Lface);
          }
          c.Onext === c ? (this.killVertex_(c.Org, null), this.killFace_(c.Lface, null)) : (t.Lface.anEdge = c.Oprev, c.Org.anEdge = c.Onext, this.splice_(c, c.Oprev)), this.killEdge_(t);
        },
        /******************** Other Edge Operations **********************/
        /* All these routines can be implemented with the basic edge
        * operations above.  They are provided for convenience and efficiency.
        */
        /* tessMeshAddEdgeVertex( eOrg ) creates a new edge eNew such that
        * eNew == eOrg->Lnext, and eNew->Dst is a newly created vertex.
        * eOrg and eNew will have the same left face.
        */
        // TESShalfEdge *tessMeshAddEdgeVertex( TESSmesh *mesh, TESShalfEdge *eOrg );
        addEdgeVertex: function(t) {
          var c = this.makeEdge_(t), b = c.Sym;
          this.splice_(c, t.Lnext), c.Org = t.Dst;
          var Z = new a();
          return this.makeVertex_(Z, b, c.Org), c.Lface = b.Lface = t.Lface, c;
        },
        /* tessMeshSplitEdge( eOrg ) splits eOrg into two edges eOrg and eNew,
        * such that eNew == eOrg->Lnext.  The new vertex is eOrg->Dst == eNew->Org.
        * eOrg and eNew will have the same left face.
        */
        // TESShalfEdge *tessMeshSplitEdge( TESSmesh *mesh, TESShalfEdge *eOrg );
        splitEdge: function(t, c) {
          var b = this.addEdgeVertex(t), Z = b.Sym;
          return this.splice_(t.Sym, t.Sym.Oprev), this.splice_(t.Sym, Z), t.Dst = Z.Org, Z.Dst.anEdge = Z.Sym, Z.Rface = t.Rface, Z.winding = t.winding, Z.Sym.winding = t.Sym.winding, Z;
        },
        /* tessMeshConnect( eOrg, eDst ) creates a new edge from eOrg->Dst
        * to eDst->Org, and returns the corresponding half-edge eNew.
        * If eOrg->Lface == eDst->Lface, this splits one loop into two,
        * and the newly created loop is eNew->Lface.  Otherwise, two disjoint
        * loops are merged into one, and the loop eDst->Lface is destroyed.
        *
        * If (eOrg == eDst), the new face will have only two edges.
        * If (eOrg->Lnext == eDst), the old face is reduced to a single edge.
        * If (eOrg->Lnext->Lnext == eDst), the old face is reduced to two edges.
        */
        // TESShalfEdge *tessMeshConnect( TESSmesh *mesh, TESShalfEdge *eOrg, TESShalfEdge *eDst );
        connect: function(t, c) {
          var b = !1, Z = this.makeEdge_(t), r = Z.Sym;
          if (c.Lface !== t.Lface && (b = !0, this.killFace_(c.Lface, t.Lface)), this.splice_(Z, t.Lnext), this.splice_(r, c), Z.Org = t.Dst, r.Org = c.Org, Z.Lface = r.Lface = t.Lface, t.Lface.anEdge = r, !b) {
            var S = new e();
            this.makeFace_(S, Z, t.Lface);
          }
          return Z;
        },
        /* tessMeshZapFace( fZap ) destroys a face and removes it from the
        * global face list.  All edges of fZap will have a NULL pointer as their
        * left face.  Any edges which also have a NULL pointer as their right face
        * are deleted entirely (along with any isolated vertices this produces).
        * An entire mesh can be deleted by zapping its faces, one at a time,
        * in any order.  Zapped faces cannot be used in further mesh operations!
        */
        zapFace: function(t) {
          var c = t.anEdge, b, Z, r, S, C;
          Z = c.Lnext;
          do
            b = Z, Z = b.Lnext, b.Lface = null, b.Rface === null && (b.Onext === b ? this.killVertex_(b.Org, null) : (b.Org.anEdge = b.Onext, this.splice_(b, b.Oprev)), r = b.Sym, r.Onext === r ? this.killVertex_(r.Org, null) : (r.Org.anEdge = r.Onext, this.splice_(r, r.Oprev)), this.killEdge_(b));
          while (b != c);
          S = t.prev, C = t.next, C.prev = S, S.next = C;
        },
        countFaceVerts_: function(t) {
          var c = t.anEdge, b = 0;
          do
            b++, c = c.Lnext;
          while (c !== t.anEdge);
          return b;
        },
        //int tessMeshMergeConvexFaces( TESSmesh *mesh, int maxVertsPerFace )
        mergeConvexFaces: function(t) {
          var c, b, Z, r, S, C, F;
          for (c = this.fHead.next; c !== this.fHead; c = c.next)
            if (c.inside)
              for (b = c.anEdge, S = b.Org; Z = b.Lnext, r = b.Sym, r && r.Lface && r.Lface.inside && (C = this.countFaceVerts_(c), F = this.countFaceVerts_(r.Lface), C + F - 2 <= t && s.vertCCW(b.Lprev.Org, b.Org, r.Lnext.Lnext.Org) && s.vertCCW(r.Lprev.Org, r.Org, b.Lnext.Lnext.Org) && (Z = r.Lnext, this.delete(r), b = null, r = null)), !(b && b.Lnext.Org === S); )
                b = Z;
          return !0;
        },
        /* tessMeshCheckMesh( mesh ) checks a mesh for self-consistency.
        */
        check: function() {
          var t = this.fHead, c = this.vHead, b = this.eHead, Z, r, S, C, F, Y;
          for (r = t, r = t; (Z = r.next) !== t; r = Z) {
            X(Z.prev === r), F = Z.anEdge;
            do
              X(F.Sym !== F), X(F.Sym.Sym === F), X(F.Lnext.Onext.Sym === F), X(F.Onext.Sym.Lnext === F), X(F.Lface === Z), F = F.Lnext;
            while (F !== Z.anEdge);
          }
          for (X(Z.prev === r && Z.anEdge === null), C = c, C = c; (S = C.next) !== c; C = S) {
            X(S.prev === C), F = S.anEdge;
            do
              X(F.Sym !== F), X(F.Sym.Sym === F), X(F.Lnext.Onext.Sym === F), X(F.Onext.Sym.Lnext === F), X(F.Org === S), F = F.Onext;
            while (F !== S.anEdge);
          }
          for (X(S.prev === C && S.anEdge === null), Y = b, Y = b; (F = Y.next) !== b; Y = F)
            X(F.Sym.next === Y.Sym), X(F.Sym !== F), X(F.Sym.Sym === F), X(F.Org !== null), X(F.Dst !== null), X(F.Lnext.Onext.Sym === F), X(F.Onext.Sym.Lnext === F);
          X(F.Sym.next === Y.Sym && F.Sym === this.eHeadSym && F.Sym.Sym === F && F.Org === null && F.Dst === null && F.Lface === null && F.Rface === null);
        }
      }, s.vertEq = function(t, c) {
        return t.s === c.s && t.t === c.t;
      }, s.vertLeq = function(t, c) {
        return t.s < c.s || t.s === c.s && t.t <= c.t;
      }, s.transLeq = function(t, c) {
        return t.t < c.t || t.t === c.t && t.s <= c.s;
      }, s.edgeGoesLeft = function(t) {
        return s.vertLeq(t.Dst, t.Org);
      }, s.edgeGoesRight = function(t) {
        return s.vertLeq(t.Org, t.Dst);
      }, s.vertL1dist = function(t, c) {
        return Math.abs(t.s - c.s) + Math.abs(t.t - c.t);
      }, s.edgeEval = function(t, c, b) {
        X(s.vertLeq(t, c) && s.vertLeq(c, b));
        var Z = c.s - t.s, r = b.s - c.s;
        return Z + r > 0 ? Z < r ? c.t - t.t + (t.t - b.t) * (Z / (Z + r)) : c.t - b.t + (b.t - t.t) * (r / (Z + r)) : 0;
      }, s.edgeSign = function(t, c, b) {
        X(s.vertLeq(t, c) && s.vertLeq(c, b));
        var Z = c.s - t.s, r = b.s - c.s;
        return Z + r > 0 ? (c.t - b.t) * Z + (c.t - t.t) * r : 0;
      }, s.transEval = function(t, c, b) {
        X(s.transLeq(t, c) && s.transLeq(c, b));
        var Z = c.t - t.t, r = b.t - c.t;
        return Z + r > 0 ? Z < r ? c.s - t.s + (t.s - b.s) * (Z / (Z + r)) : c.s - b.s + (b.s - t.s) * (r / (Z + r)) : 0;
      }, s.transSign = function(t, c, b) {
        X(s.transLeq(t, c) && s.transLeq(c, b));
        var Z = c.t - t.t, r = b.t - c.t;
        return Z + r > 0 ? (c.s - b.s) * Z + (c.s - t.s) * r : 0;
      }, s.vertCCW = function(t, c, b) {
        return t.s * (c.t - b.t) + c.s * (b.t - t.t) + b.s * (t.t - c.t) >= 0;
      }, s.interpolate = function(t, c, b, Z) {
        return t = t < 0 ? 0 : t, b = b < 0 ? 0 : b, t <= b ? b === 0 ? (c + Z) / 2 : c + (Z - c) * (t / (t + b)) : Z + (c - Z) * (b / (t + b));
      }, s.intersect = function(t, c, b, Z, r) {
        var S, C, F;
        s.vertLeq(t, c) || (F = t, t = c, c = F), s.vertLeq(b, Z) || (F = b, b = Z, Z = F), s.vertLeq(t, b) || (F = t, t = b, b = F, F = c, c = Z, Z = F), s.vertLeq(b, c) ? s.vertLeq(c, Z) ? (S = s.edgeEval(t, b, c), C = s.edgeEval(b, c, Z), S + C < 0 && (S = -S, C = -C), r.s = s.interpolate(S, b.s, C, c.s)) : (S = s.edgeSign(t, b, c), C = -s.edgeSign(t, Z, c), S + C < 0 && (S = -S, C = -C), r.s = s.interpolate(S, b.s, C, Z.s)) : r.s = (b.s + c.s) / 2, s.transLeq(t, c) || (F = t, t = c, c = F), s.transLeq(b, Z) || (F = b, b = Z, Z = F), s.transLeq(t, b) || (F = t, t = b, b = F, F = c, c = Z, Z = F), s.transLeq(b, c) ? s.transLeq(c, Z) ? (S = s.transEval(t, b, c), C = s.transEval(b, c, Z), S + C < 0 && (S = -S, C = -C), r.t = s.interpolate(S, b.t, C, c.t)) : (S = s.transSign(t, b, c), C = -s.transSign(t, Z, c), S + C < 0 && (S = -S, C = -C), r.t = s.interpolate(S, b.t, C, Z.t)) : r.t = (b.t + c.t) / 2;
      };
      function y() {
        this.key = null, this.next = null, this.prev = null;
      }
      function o(t, c) {
        this.head = new y(), this.head.next = this.head, this.head.prev = this.head, this.frame = t, this.leq = c;
      }
      o.prototype = {
        min: function() {
          return this.head.next;
        },
        max: function() {
          return this.head.prev;
        },
        insert: function(t) {
          return this.insertBefore(this.head, t);
        },
        search: function(t) {
          var c = this.head;
          do
            c = c.next;
          while (c.key !== null && !this.leq(this.frame, t, c.key));
          return c;
        },
        insertBefore: function(t, c) {
          do
            t = t.prev;
          while (t.key !== null && !this.leq(this.frame, t.key, c));
          var b = new y();
          return b.key = c, b.next = t.next, t.next.prev = b, b.prev = t, t.next = b, b;
        },
        delete: function(t) {
          t.next.prev = t.prev, t.prev.next = t.next;
        }
      };
      function h() {
        this.handle = null;
      }
      function I() {
        this.key = null, this.node = null;
      }
      function x(t, c) {
        this.size = 0, this.max = t, this.nodes = [], this.nodes.length = t + 1;
        var b;
        for (b = 0; b < this.nodes.length; b++)
          this.nodes[b] = new h();
        for (this.handles = [], this.handles.length = t + 1, b = 0; b < this.handles.length; b++)
          this.handles[b] = new I();
        this.initialized = !1, this.freeList = 0, this.leq = c, this.nodes[1].handle = 1, this.handles[1].key = null;
      }
      x.prototype = {
        floatDown_: function(t) {
          var c = this.nodes, b = this.handles, Z, r, S;
          for (Z = c[t].handle; ; ) {
            if (S = t << 1, S < this.size && this.leq(b[c[S + 1].handle].key, b[c[S].handle].key) && ++S, X(S <= this.max), r = c[S].handle, S > this.size || this.leq(b[Z].key, b[r].key)) {
              c[t].handle = Z, b[Z].node = t;
              break;
            }
            c[t].handle = r, b[r].node = t, t = S;
          }
        },
        floatUp_: function(t) {
          var c = this.nodes, b = this.handles, Z, r, S;
          for (Z = c[t].handle; ; ) {
            if (S = t >> 1, r = c[S].handle, S === 0 || this.leq(b[r].key, b[Z].key)) {
              c[t].handle = Z, b[Z].node = t;
              break;
            }
            c[t].handle = r, b[r].node = t, t = S;
          }
        },
        init: function() {
          for (var t = this.size; t >= 1; --t)
            this.floatDown_(t);
          this.initialized = !0;
        },
        min: function() {
          return this.handles[this.nodes[1].handle].key;
        },
        /* really pqHeapInsert */
        /* returns INV_HANDLE iff out of memory */
        //PQhandle pqHeapInsert( TESSalloc* alloc, PriorityQHeap *pq, PQkey keyNew )
        insert: function(t) {
          var c, b;
          if (c = ++this.size, c * 2 > this.max) {
            this.max *= 2;
            var Z, r;
            for (r = this.nodes.length, this.nodes.length = this.max + 1, Z = r; Z < this.nodes.length; Z++)
              this.nodes[Z] = new h();
            for (r = this.handles.length, this.handles.length = this.max + 1, Z = r; Z < this.handles.length; Z++)
              this.handles[Z] = new I();
          }
          return this.freeList === 0 ? b = c : (b = this.freeList, this.freeList = this.handles[b].node), this.nodes[c].handle = b, this.handles[b].node = c, this.handles[b].key = t, this.initialized && this.floatUp_(c), b;
        },
        //PQkey pqHeapExtractMin( PriorityQHeap *pq )
        extractMin: function() {
          var t = this.nodes, c = this.handles, b = t[1].handle, Z = c[b].key;
          return this.size > 0 && (t[1].handle = t[this.size].handle, c[t[1].handle].node = 1, c[b].key = null, c[b].node = this.freeList, this.freeList = b, --this.size, this.size > 0 && this.floatDown_(1)), Z;
        },
        delete: function(t) {
          var c = this.nodes, b = this.handles, Z;
          X(t >= 1 && t <= this.max && b[t].key !== null), Z = b[t].node, c[Z].handle = c[this.size].handle, b[c[Z].handle].node = Z, --this.size, Z <= this.size && (Z <= 1 || this.leq(b[c[Z >> 1].handle].key, b[c[Z].handle].key) ? this.floatDown_(Z) : this.floatUp_(Z)), b[t].key = null, b[t].node = this.freeList, this.freeList = t;
        }
      };
      function p() {
        this.eUp = null, this.nodeUp = null, this.windingNumber = 0, this.inside = !1, this.sentinel = !1, this.dirty = !1, this.fixUpperEdge = !1;
      }
      var W = {};
      W.regionBelow = function(t) {
        return t.nodeUp.prev.key;
      }, W.regionAbove = function(t) {
        return t.nodeUp.next.key;
      }, W.debugEvent = function(t) {
      }, W.addWinding = function(t, c) {
        t.winding += c.winding, t.Sym.winding += c.Sym.winding;
      }, W.edgeLeq = function(t, c, b) {
        var Z = t.event, C, F, r = c.eUp, S = b.eUp;
        if (r.Dst === Z)
          return S.Dst === Z ? s.vertLeq(r.Org, S.Org) ? s.edgeSign(S.Dst, r.Org, S.Org) <= 0 : s.edgeSign(r.Dst, S.Org, r.Org) >= 0 : s.edgeSign(S.Dst, Z, S.Org) <= 0;
        if (S.Dst === Z)
          return s.edgeSign(r.Dst, Z, r.Org) >= 0;
        var C = s.edgeEval(r.Dst, Z, r.Org), F = s.edgeEval(S.Dst, Z, S.Org);
        return C >= F;
      }, W.deleteRegion = function(t, c) {
        c.fixUpperEdge && X(c.eUp.winding === 0), c.eUp.activeRegion = null, t.dict.delete(c.nodeUp);
      }, W.fixUpperEdge = function(t, c, b) {
        X(c.fixUpperEdge), t.mesh.delete(c.eUp), c.fixUpperEdge = !1, c.eUp = b, b.activeRegion = c;
      }, W.topLeftRegion = function(t, c) {
        var b = c.eUp.Org, Z;
        do
          c = W.regionAbove(c);
        while (c.eUp.Org === b);
        if (c.fixUpperEdge) {
          if (Z = t.mesh.connect(W.regionBelow(c).eUp.Sym, c.eUp.Lnext), Z === null)
            return null;
          W.fixUpperEdge(t, c, Z), c = W.regionAbove(c);
        }
        return c;
      }, W.topRightRegion = function(t) {
        var c = t.eUp.Dst;
        do
          t = W.regionAbove(t);
        while (t.eUp.Dst === c);
        return t;
      }, W.addRegionBelow = function(t, c, b) {
        var Z = new p();
        return Z.eUp = b, Z.nodeUp = t.dict.insertBefore(c.nodeUp, Z), Z.fixUpperEdge = !1, Z.sentinel = !1, Z.dirty = !1, b.activeRegion = Z, Z;
      }, W.isWindingInside = function(t, c) {
        switch (t.windingRule) {
          case d.WINDING_ODD:
            return (c & 1) !== 0;
          case d.WINDING_NONZERO:
            return c !== 0;
          case d.WINDING_POSITIVE:
            return c > 0;
          case d.WINDING_NEGATIVE:
            return c < 0;
          case d.WINDING_ABS_GEQ_TWO:
            return c >= 2 || c <= -2;
        }
        return X(!1), !1;
      }, W.computeWinding = function(t, c) {
        c.windingNumber = W.regionAbove(c).windingNumber + c.eUp.winding, c.inside = W.isWindingInside(t, c.windingNumber);
      }, W.finishRegion = function(t, c) {
        var b = c.eUp, Z = b.Lface;
        Z.inside = c.inside, Z.anEdge = b, W.deleteRegion(t, c);
      }, W.finishLeftRegions = function(t, c, b) {
        for (var Z, C, r = null, S = c, C = c.eUp; S !== b; ) {
          if (S.fixUpperEdge = !1, r = W.regionBelow(S), Z = r.eUp, Z.Org != C.Org) {
            if (!r.fixUpperEdge) {
              W.finishRegion(t, S);
              break;
            }
            Z = t.mesh.connect(C.Lprev, Z.Sym), W.fixUpperEdge(t, r, Z);
          }
          C.Onext !== Z && (t.mesh.splice(Z.Oprev, Z), t.mesh.splice(C, Z)), W.finishRegion(t, S), C = r.eUp, S = r;
        }
        return C;
      }, W.addRightEdges = function(t, c, b, Z, r, S) {
        var C, F, Y, J, T = !0;
        Y = b;
        do
          X(s.vertLeq(Y.Org, Y.Dst)), W.addRegionBelow(t, c, Y.Sym), Y = Y.Onext;
        while (Y !== Z);
        for (r === null && (r = W.regionBelow(c).eUp.Rprev), F = c, J = r; C = W.regionBelow(F), Y = C.eUp.Sym, Y.Org === J.Org; )
          Y.Onext !== J && (t.mesh.splice(Y.Oprev, Y), t.mesh.splice(J.Oprev, Y)), C.windingNumber = F.windingNumber - Y.winding, C.inside = W.isWindingInside(t, C.windingNumber), F.dirty = !0, !T && W.checkForRightSplice(t, F) && (W.addWinding(Y, J), W.deleteRegion(t, F), t.mesh.delete(J)), T = !1, F = C, J = Y;
        F.dirty = !0, X(F.windingNumber - Y.winding === C.windingNumber), S && W.walkDirtyRegions(t, F);
      }, W.spliceMergeVertices = function(t, c, b) {
        t.mesh.splice(c, b);
      }, W.vertexWeights = function(t, c, b) {
        var Z = s.vertL1dist(c, t), r = s.vertL1dist(b, t), S = 0.5 * r / (Z + r), C = 0.5 * Z / (Z + r);
        t.coords[0] += S * c.coords[0] + C * b.coords[0], t.coords[1] += S * c.coords[1] + C * b.coords[1], t.coords[2] += S * c.coords[2] + C * b.coords[2];
      }, W.getIntersectData = function(t, c, b, Z, r, S) {
        c.coords[0] = c.coords[1] = c.coords[2] = 0, c.idx = -1, W.vertexWeights(c, b, Z), W.vertexWeights(c, r, S);
      }, W.checkForRightSplice = function(t, c) {
        var b = W.regionBelow(c), Z = c.eUp, r = b.eUp;
        if (s.vertLeq(Z.Org, r.Org)) {
          if (s.edgeSign(r.Dst, Z.Org, r.Org) > 0)
            return !1;
          s.vertEq(Z.Org, r.Org) ? Z.Org !== r.Org && (t.pq.delete(Z.Org.pqHandle), W.spliceMergeVertices(t, r.Oprev, Z)) : (t.mesh.splitEdge(r.Sym), t.mesh.splice(Z, r.Oprev), c.dirty = b.dirty = !0);
        } else {
          if (s.edgeSign(Z.Dst, r.Org, Z.Org) < 0)
            return !1;
          W.regionAbove(c).dirty = c.dirty = !0, t.mesh.splitEdge(Z.Sym), t.mesh.splice(r.Oprev, Z);
        }
        return !0;
      }, W.checkForLeftSplice = function(t, c) {
        var b = W.regionBelow(c), Z = c.eUp, r = b.eUp, S;
        if (X(!s.vertEq(Z.Dst, r.Dst)), s.vertLeq(Z.Dst, r.Dst)) {
          if (s.edgeSign(Z.Dst, r.Dst, Z.Org) < 0)
            return !1;
          W.regionAbove(c).dirty = c.dirty = !0, S = t.mesh.splitEdge(Z), t.mesh.splice(r.Sym, S), S.Lface.inside = c.inside;
        } else {
          if (s.edgeSign(r.Dst, Z.Dst, r.Org) > 0)
            return !1;
          c.dirty = b.dirty = !0, S = t.mesh.splitEdge(r), t.mesh.splice(Z.Lnext, r.Sym), S.Rface.inside = c.inside;
        }
        return !0;
      }, W.checkForIntersect = function(t, c) {
        var b = W.regionBelow(c), Z = c.eUp, r = b.eUp, S = Z.Org, C = r.Org, F = Z.Dst, Y = r.Dst, J, T, K = new a(), R, H;
        if (X(!s.vertEq(Y, F)), X(s.edgeSign(F, t.event, S) <= 0), X(s.edgeSign(Y, t.event, C) >= 0), X(S !== t.event && C !== t.event), X(!c.fixUpperEdge && !b.fixUpperEdge), S === C || (J = Math.min(S.t, F.t), T = Math.max(C.t, Y.t), J > T))
          return !1;
        if (s.vertLeq(S, C)) {
          if (s.edgeSign(Y, S, C) > 0)
            return !1;
        } else if (s.edgeSign(F, C, S) < 0)
          return !1;
        return W.debugEvent(t), s.intersect(F, S, Y, C, K), X(Math.min(S.t, F.t) <= K.t), X(K.t <= Math.max(C.t, Y.t)), X(Math.min(Y.s, F.s) <= K.s), X(K.s <= Math.max(C.s, S.s)), s.vertLeq(K, t.event) && (K.s = t.event.s, K.t = t.event.t), R = s.vertLeq(S, C) ? S : C, s.vertLeq(R, K) && (K.s = R.s, K.t = R.t), s.vertEq(K, S) || s.vertEq(K, C) ? (W.checkForRightSplice(t, c), !1) : !s.vertEq(F, t.event) && s.edgeSign(F, t.event, K) >= 0 || !s.vertEq(Y, t.event) && s.edgeSign(Y, t.event, K) <= 0 ? Y === t.event ? (t.mesh.splitEdge(Z.Sym), t.mesh.splice(r.Sym, Z), c = W.topLeftRegion(t, c), Z = W.regionBelow(c).eUp, W.finishLeftRegions(t, W.regionBelow(c), b), W.addRightEdges(t, c, Z.Oprev, Z, Z, !0), !0) : F === t.event ? (t.mesh.splitEdge(r.Sym), t.mesh.splice(Z.Lnext, r.Oprev), b = c, c = W.topRightRegion(c), H = W.regionBelow(c).eUp.Rprev, b.eUp = r.Oprev, r = W.finishLeftRegions(t, b, null), W.addRightEdges(t, c, r.Onext, Z.Rprev, H, !0), !0) : (s.edgeSign(F, t.event, K) >= 0 && (W.regionAbove(c).dirty = c.dirty = !0, t.mesh.splitEdge(Z.Sym), Z.Org.s = t.event.s, Z.Org.t = t.event.t), s.edgeSign(Y, t.event, K) <= 0 && (c.dirty = b.dirty = !0, t.mesh.splitEdge(r.Sym), r.Org.s = t.event.s, r.Org.t = t.event.t), !1) : (t.mesh.splitEdge(Z.Sym), t.mesh.splitEdge(r.Sym), t.mesh.splice(r.Oprev, Z), Z.Org.s = K.s, Z.Org.t = K.t, Z.Org.pqHandle = t.pq.insert(Z.Org), W.getIntersectData(t, Z.Org, S, F, C, Y), W.regionAbove(c).dirty = c.dirty = b.dirty = !0, !1);
      }, W.walkDirtyRegions = function(t, c) {
        for (var b = W.regionBelow(c), Z, r; ; ) {
          for (; b.dirty; )
            c = b, b = W.regionBelow(b);
          if (!c.dirty && (b = c, c = W.regionAbove(c), c === null || !c.dirty))
            return;
          if (c.dirty = !1, Z = c.eUp, r = b.eUp, Z.Dst !== r.Dst && W.checkForLeftSplice(t, c) && (b.fixUpperEdge ? (W.deleteRegion(t, b), t.mesh.delete(r), b = W.regionBelow(c), r = b.eUp) : c.fixUpperEdge && (W.deleteRegion(t, c), t.mesh.delete(Z), c = W.regionAbove(b), Z = c.eUp)), Z.Org !== r.Org)
            if (Z.Dst !== r.Dst && !c.fixUpperEdge && !b.fixUpperEdge && (Z.Dst === t.event || r.Dst === t.event)) {
              if (W.checkForIntersect(t, c))
                return;
            } else
              W.checkForRightSplice(t, c);
          Z.Org === r.Org && Z.Dst === r.Dst && (W.addWinding(r, Z), W.deleteRegion(t, c), t.mesh.delete(Z), c = W.regionAbove(b));
        }
      }, W.connectRightVertex = function(t, c, b) {
        var Z, r = b.Onext, S = W.regionBelow(c), C = c.eUp, F = S.eUp, Y = !1;
        if (C.Dst !== F.Dst && W.checkForIntersect(t, c), s.vertEq(C.Org, t.event) && (t.mesh.splice(r.Oprev, C), c = W.topLeftRegion(t, c), r = W.regionBelow(c).eUp, W.finishLeftRegions(t, W.regionBelow(c), S), Y = !0), s.vertEq(F.Org, t.event) && (t.mesh.splice(b, F.Oprev), b = W.finishLeftRegions(t, S, null), Y = !0), Y) {
          W.addRightEdges(t, c, b.Onext, r, r, !0);
          return;
        }
        s.vertLeq(F.Org, C.Org) ? Z = F.Oprev : Z = C, Z = t.mesh.connect(b.Lprev, Z), W.addRightEdges(t, c, Z, Z.Onext, Z.Onext, !1), Z.Sym.activeRegion.fixUpperEdge = !0, W.walkDirtyRegions(t, c);
      }, W.connectLeftDegenerate = function(t, c, b) {
        var Z, r, S, C, F;
        if (Z = c.eUp, s.vertEq(Z.Org, b)) {
          X(
            !1
            /*TOLERANCE_NONZERO*/
          ), W.spliceMergeVertices(t, Z, b.anEdge);
          return;
        }
        if (!s.vertEq(Z.Dst, b)) {
          t.mesh.splitEdge(Z.Sym), c.fixUpperEdge && (t.mesh.delete(Z.Onext), c.fixUpperEdge = !1), t.mesh.splice(b.anEdge, Z), W.sweepEvent(t, b);
          return;
        }
        X(
          !1
          /*TOLERANCE_NONZERO*/
        ), c = W.topRightRegion(c), F = W.regionBelow(c), S = F.eUp.Sym, r = C = S.Onext, F.fixUpperEdge && (X(r !== S), W.deleteRegion(t, F), t.mesh.delete(S), S = r.Oprev), t.mesh.splice(b.anEdge, S), s.edgeGoesLeft(r) || (r = null), W.addRightEdges(t, c, S.Onext, C, r, !0);
      }, W.connectLeftVertex = function(t, c) {
        var b, Z, r, S, C, F, Y = new p();
        if (Y.eUp = c.anEdge.Sym, b = t.dict.search(Y).key, Z = W.regionBelow(b), !!Z) {
          if (S = b.eUp, C = Z.eUp, s.edgeSign(S.Dst, c, S.Org) === 0) {
            W.connectLeftDegenerate(t, b, c);
            return;
          }
          if (r = s.vertLeq(C.Dst, S.Dst) ? b : Z, b.inside || r.fixUpperEdge) {
            if (r === b)
              F = t.mesh.connect(c.anEdge.Sym, S.Lnext);
            else {
              var J = t.mesh.connect(C.Dnext, c.anEdge);
              F = J.Sym;
            }
            r.fixUpperEdge ? W.fixUpperEdge(t, r, F) : W.computeWinding(t, W.addRegionBelow(t, b, F)), W.sweepEvent(t, c);
          } else
            W.addRightEdges(t, b, c.anEdge, c.anEdge, null, !0);
        }
      }, W.sweepEvent = function(t, c) {
        t.event = c, W.debugEvent(t);
        for (var b = c.anEdge; b.activeRegion === null; )
          if (b = b.Onext, b === c.anEdge) {
            W.connectLeftVertex(t, c);
            return;
          }
        var Z = W.topLeftRegion(t, b.activeRegion);
        X(Z !== null);
        var r = W.regionBelow(Z), S = r.eUp, C = W.finishLeftRegions(t, r, null);
        C.Onext === S ? W.connectRightVertex(t, Z, C) : W.addRightEdges(t, Z, C.Onext, S, S, !0);
      }, W.addSentinel = function(t, c, b, Z) {
        var r = new p(), S = t.mesh.makeEdge();
        S.Org.s = b, S.Org.t = Z, S.Dst.s = c, S.Dst.t = Z, t.event = S.Dst, r.eUp = S, r.windingNumber = 0, r.inside = !1, r.fixUpperEdge = !1, r.sentinel = !0, r.dirty = !1, r.nodeUp = t.dict.insert(r);
      }, W.initEdgeDict = function(t) {
        t.dict = new o(t, W.edgeLeq);
        var c = t.bmax[0] - t.bmin[0], b = t.bmax[1] - t.bmin[1], Z = t.bmin[0] - c, r = t.bmax[0] + c, S = t.bmin[1] - b, C = t.bmax[1] + b;
        W.addSentinel(t, Z, r, S), W.addSentinel(t, Z, r, C);
      }, W.doneEdgeDict = function(t) {
        for (var c, b = 0; (c = t.dict.min().key) !== null; )
          c.sentinel || (X(c.fixUpperEdge), X(++b === 1)), X(c.windingNumber === 0), W.deleteRegion(t, c);
      }, W.removeDegenerateEdges = function(t) {
        var c, b, Z, r = t.mesh.eHead;
        for (c = r.next; c !== r; c = b)
          b = c.next, Z = c.Lnext, s.vertEq(c.Org, c.Dst) && c.Lnext.Lnext !== c && (W.spliceMergeVertices(t, Z, c), t.mesh.delete(c), c = Z, Z = c.Lnext), Z.Lnext === c && (Z !== c && ((Z === b || Z === b.Sym) && (b = b.next), t.mesh.delete(Z)), (c === b || c === b.Sym) && (b = b.next), t.mesh.delete(c));
      }, W.initPriorityQ = function(t) {
        var c, b, Z, r = 0;
        for (Z = t.mesh.vHead, b = Z.next; b !== Z; b = b.next)
          r++;
        for (r += 8, c = t.pq = new x(r, s.vertLeq), Z = t.mesh.vHead, b = Z.next; b !== Z; b = b.next)
          b.pqHandle = c.insert(b);
        return b !== Z ? !1 : (c.init(), !0);
      }, W.donePriorityQ = function(t) {
        t.pq = null;
      }, W.removeDegenerateFaces = function(t, c) {
        var b, Z, r;
        for (b = c.fHead.next; b !== c.fHead; b = Z)
          Z = b.next, r = b.anEdge, X(r.Lnext !== r), r.Lnext.Lnext === r && (W.addWinding(r.Onext, r), t.mesh.delete(r));
        return !0;
      }, W.computeInterior = function(t) {
        var c, b;
        if (W.removeDegenerateEdges(t), !W.initPriorityQ(t))
          return !1;
        for (W.initEdgeDict(t); (c = t.pq.extractMin()) !== null; ) {
          for (; b = t.pq.min(), !(b === null || !s.vertEq(b, c)); )
            b = t.pq.extractMin(), W.spliceMergeVertices(t, c.anEdge, b.anEdge);
          W.sweepEvent(t, c);
        }
        return t.event = t.dict.min().key.eUp.Org, W.debugEvent(t), W.doneEdgeDict(t), W.donePriorityQ(t), W.removeDegenerateFaces(t, t.mesh) ? (t.mesh.check(), !0) : !1;
      };
      function V() {
        this.mesh = null, this.normal = [0, 0, 0], this.sUnit = [0, 0, 0], this.tUnit = [0, 0, 0], this.bmin = [0, 0], this.bmax = [0, 0], this.windingRule = d.WINDING_ODD, this.dict = null, this.pq = null, this.event = null, this.vertexIndexCounter = 0, this.vertices = [], this.vertexIndices = [], this.vertexCount = 0, this.elements = [], this.elementCount = 0;
      }
      V.prototype = {
        dot_: function(t, c) {
          return t[0] * c[0] + t[1] * c[1] + t[2] * c[2];
        },
        normalize_: function(t) {
          var c = t[0] * t[0] + t[1] * t[1] + t[2] * t[2];
          X(c > 0), c = Math.sqrt(c), t[0] /= c, t[1] /= c, t[2] /= c;
        },
        longAxis_: function(t) {
          var c = 0;
          return Math.abs(t[1]) > Math.abs(t[0]) && (c = 1), Math.abs(t[2]) > Math.abs(t[c]) && (c = 2), c;
        },
        computeNormal_: function(t) {
          var c, b, Z, r, S, C, F = [0, 0, 0], Y = [0, 0, 0], J = [0, 0, 0], T = [0, 0, 0], K = [0, 0, 0], R = [null, null, null], H = [null, null, null], f = this.mesh.vHead, w;
          for (c = f.next, w = 0; w < 3; ++w)
            r = c.coords[w], Y[w] = r, H[w] = c, F[w] = r, R[w] = c;
          for (c = f.next; c !== f; c = c.next)
            for (w = 0; w < 3; ++w)
              r = c.coords[w], r < Y[w] && (Y[w] = r, H[w] = c), r > F[w] && (F[w] = r, R[w] = c);
          if (w = 0, F[1] - Y[1] > F[0] - Y[0] && (w = 1), F[2] - Y[2] > F[w] - Y[w] && (w = 2), Y[w] >= F[w]) {
            t[0] = 0, t[1] = 0, t[2] = 1;
            return;
          }
          for (C = 0, b = H[w], Z = R[w], J[0] = b.coords[0] - Z.coords[0], J[1] = b.coords[1] - Z.coords[1], J[2] = b.coords[2] - Z.coords[2], c = f.next; c !== f; c = c.next)
            T[0] = c.coords[0] - Z.coords[0], T[1] = c.coords[1] - Z.coords[1], T[2] = c.coords[2] - Z.coords[2], K[0] = J[1] * T[2] - J[2] * T[1], K[1] = J[2] * T[0] - J[0] * T[2], K[2] = J[0] * T[1] - J[1] * T[0], S = K[0] * K[0] + K[1] * K[1] + K[2] * K[2], S > C && (C = S, t[0] = K[0], t[1] = K[1], t[2] = K[2]);
          C <= 0 && (t[0] = t[1] = t[2] = 0, t[this.longAxis_(J)] = 1);
        },
        checkOrientation_: function() {
          var t, c, b = this.mesh.fHead, Z, r = this.mesh.vHead, S;
          for (t = 0, c = b.next; c !== b; c = c.next)
            if (S = c.anEdge, !(S.winding <= 0))
              do
                t += (S.Org.s - S.Dst.s) * (S.Org.t + S.Dst.t), S = S.Lnext;
              while (S !== c.anEdge);
          if (t < 0) {
            for (Z = r.next; Z !== r; Z = Z.next)
              Z.t = -Z.t;
            this.tUnit[0] = -this.tUnit[0], this.tUnit[1] = -this.tUnit[1], this.tUnit[2] = -this.tUnit[2];
          }
        },
        /*	#ifdef FOR_TRITE_TEST_PROGRAM
          #include <stdlib.h>
          extern int RandomSweep;
          #define S_UNIT_X	(RandomSweep ? (2*drand48()-1) : 1.0)
          #define S_UNIT_Y	(RandomSweep ? (2*drand48()-1) : 0.0)
          #else
          #if defined(SLANTED_SWEEP) */
        /* The "feature merging" is not intended to be complete.  There are
        * special cases where edges are nearly parallel to the sweep line
        * which are not implemented.  The algorithm should still behave
        * robustly (ie. produce a reasonable tesselation) in the presence
        * of such edges, however it may miss features which could have been
        * merged.  We could minimize this effect by choosing the sweep line
        * direction to be something unusual (ie. not parallel to one of the
        * coordinate axes).
        */
        /*	#define S_UNIT_X	(TESSreal)0.50941539564955385	// Pre-normalized
          #define S_UNIT_Y	(TESSreal)0.86052074622010633
          #else
          #define S_UNIT_X	(TESSreal)1.0
          #define S_UNIT_Y	(TESSreal)0.0
          #endif
          #endif*/
        /* Determine the polygon normal and project vertices onto the plane
        * of the polygon.
        */
        projectPolygon_: function() {
          var t, c = this.mesh.vHead, b = [0, 0, 0], Z, r, S, C, F = !1;
          for (b[0] = this.normal[0], b[1] = this.normal[1], b[2] = this.normal[2], b[0] === 0 && b[1] === 0 && b[2] === 0 && (this.computeNormal_(b), F = !0), Z = this.sUnit, r = this.tUnit, S = this.longAxis_(b), Z[S] = 0, Z[(S + 1) % 3] = 1, Z[(S + 2) % 3] = 0, r[S] = 0, r[(S + 1) % 3] = 0, r[(S + 2) % 3] = b[S] > 0 ? 1 : -1, t = c.next; t !== c; t = t.next)
            t.s = this.dot_(t.coords, Z), t.t = this.dot_(t.coords, r);
          for (F && this.checkOrientation_(), C = !0, t = c.next; t !== c; t = t.next)
            C ? (this.bmin[0] = this.bmax[0] = t.s, this.bmin[1] = this.bmax[1] = t.t, C = !1) : (t.s < this.bmin[0] && (this.bmin[0] = t.s), t.s > this.bmax[0] && (this.bmax[0] = t.s), t.t < this.bmin[1] && (this.bmin[1] = t.t), t.t > this.bmax[1] && (this.bmax[1] = t.t));
        },
        addWinding_: function(t, c) {
          t.winding += c.winding, t.Sym.winding += c.Sym.winding;
        },
        /* tessMeshTessellateMonoRegion( face ) tessellates a monotone region
        * (what else would it do??)  The region must consist of a single
        * loop of half-edges (see mesh.h) oriented CCW.  "Monotone" in this
        * case means that any vertical line intersects the interior of the
        * region in a single interval.  
        *
        * Tessellation consists of adding interior edges (actually pairs of
        * half-edges), to split the region into non-overlapping triangles.
        *
        * The basic idea is explained in Preparata and Shamos (which I don''t
        * have handy right now), although their implementation is more
        * complicated than this one.  The are two edge chains, an upper chain
        * and a lower chain.  We process all vertices from both chains in order,
        * from right to left.
        *
        * The algorithm ensures that the following invariant holds after each
        * vertex is processed: the untessellated region consists of two
        * chains, where one chain (say the upper) is a single edge, and
        * the other chain is concave.  The left vertex of the single edge
        * is always to the left of all vertices in the concave chain.
        *
        * Each step consists of adding the rightmost unprocessed vertex to one
        * of the two chains, and forming a fan of triangles from the rightmost
        * of two chain endpoints.  Determining whether we can add each triangle
        * to the fan is a simple orientation test.  By making the fan as large
        * as possible, we restore the invariant (check it yourself).
        */
        //	int tessMeshTessellateMonoRegion( TESSmesh *mesh, TESSface *face )
        tessellateMonoRegion_: function(t, c) {
          var b, Z;
          for (b = c.anEdge, X(b.Lnext !== b && b.Lnext.Lnext !== b); s.vertLeq(b.Dst, b.Org); b = b.Lprev)
            ;
          for (; s.vertLeq(b.Org, b.Dst); b = b.Lnext)
            ;
          for (Z = b.Lprev; b.Lnext !== Z; )
            if (s.vertLeq(b.Dst, Z.Org)) {
              for (; Z.Lnext !== b && (s.edgeGoesLeft(Z.Lnext) || s.edgeSign(Z.Org, Z.Dst, Z.Lnext.Dst) <= 0); ) {
                var r = t.connect(Z.Lnext, Z);
                Z = r.Sym;
              }
              Z = Z.Lprev;
            } else {
              for (; Z.Lnext !== b && (s.edgeGoesRight(b.Lprev) || s.edgeSign(b.Dst, b.Org, b.Lprev.Org) >= 0); ) {
                var r = t.connect(b, b.Lprev);
                b = r.Sym;
              }
              b = b.Lnext;
            }
          for (X(Z.Lnext !== b); Z.Lnext.Lnext !== b; ) {
            var r = t.connect(Z.Lnext, Z);
            Z = r.Sym;
          }
          return !0;
        },
        /* tessMeshTessellateInterior( mesh ) tessellates each region of
        * the mesh which is marked "inside" the polygon.  Each such region
        * must be monotone.
        */
        //int tessMeshTessellateInterior( TESSmesh *mesh )
        tessellateInterior_: function(t) {
          var c, b;
          for (c = t.fHead.next; c !== t.fHead; c = b)
            if (b = c.next, c.inside && !this.tessellateMonoRegion_(t, c))
              return !1;
          return !0;
        },
        /* tessMeshDiscardExterior( mesh ) zaps (ie. sets to NULL) all faces
        * which are not marked "inside" the polygon.  Since further mesh operations
        * on NULL faces are not allowed, the main purpose is to clean up the
        * mesh so that exterior loops are not represented in the data structure.
        */
        //void tessMeshDiscardExterior( TESSmesh *mesh )
        discardExterior_: function(t) {
          var c, b;
          for (c = t.fHead.next; c !== t.fHead; c = b)
            b = c.next, c.inside || t.zapFace(c);
        },
        /* tessMeshSetWindingNumber( mesh, value, keepOnlyBoundary ) resets the
        * winding numbers on all edges so that regions marked "inside" the
        * polygon have a winding number of "value", and regions outside
        * have a winding number of 0.
        *
        * If keepOnlyBoundary is TRUE, it also deletes all edges which do not
        * separate an interior region from an exterior one.
        */
        //	int tessMeshSetWindingNumber( TESSmesh *mesh, int value, int keepOnlyBoundary )
        setWindingNumber_: function(t, c, b) {
          var Z, r;
          for (Z = t.eHead.next; Z !== t.eHead; Z = r)
            r = Z.next, Z.Rface.inside !== Z.Lface.inside ? Z.winding = Z.Lface.inside ? c : -c : b ? t.delete(Z) : Z.winding = 0;
        },
        getNeighbourFace_: function(t) {
          return !t.Rface || !t.Rface.inside ? -1 : t.Rface.n;
        },
        outputPolymesh_: function(t, c, b, Z) {
          var r, S, C, F = 0, Y = 0, J, T;
          for (b > 3 && t.mergeConvexFaces(b), r = t.vHead.next; r !== t.vHead; r = r.next)
            r.n = -1;
          for (S = t.fHead.next; S !== t.fHead; S = S.next)
            if (S.n = -1, !!S.inside) {
              C = S.anEdge, J = 0;
              do
                r = C.Org, r.n === -1 && (r.n = Y, Y++), J++, C = C.Lnext;
              while (C !== S.anEdge);
              X(J <= b), S.n = F, ++F;
            }
          for (this.elementCount = F, c === d.CONNECTED_POLYGONS && (F *= 2), this.elements = [], this.elements.length = F * b, this.vertexCount = Y, this.vertices = [], this.vertices.length = Y * Z, this.vertexIndices = [], this.vertexIndices.length = Y, r = t.vHead.next; r !== t.vHead; r = r.next)
            if (r.n !== -1) {
              var K = r.n * Z;
              this.vertices[K + 0] = r.coords[0], this.vertices[K + 1] = r.coords[1], Z > 2 && (this.vertices[K + 2] = r.coords[2]), this.vertexIndices[r.n] = r.idx;
            }
          var R = 0;
          for (S = t.fHead.next; S !== t.fHead; S = S.next)
            if (S.inside) {
              C = S.anEdge, J = 0;
              do
                r = C.Org, this.elements[R++] = r.n, J++, C = C.Lnext;
              while (C !== S.anEdge);
              for (T = J; T < b; ++T)
                this.elements[R++] = -1;
              if (c === d.CONNECTED_POLYGONS) {
                C = S.anEdge;
                do
                  this.elements[R++] = this.getNeighbourFace_(C), C = C.Lnext;
                while (C !== S.anEdge);
                for (T = J; T < b; ++T)
                  this.elements[R++] = -1;
              }
            }
        },
        //	void OutputContours( TESStesselator *tess, TESSmesh *mesh, int vertexSize )
        outputContours_: function(t, c) {
          var b, Z, r, S = 0, C = 0;
          for (this.vertexCount = 0, this.elementCount = 0, b = t.fHead.next; b !== t.fHead; b = b.next)
            if (b.inside) {
              r = Z = b.anEdge;
              do
                this.vertexCount++, Z = Z.Lnext;
              while (Z !== r);
              this.elementCount++;
            }
          this.elements = [], this.elements.length = this.elementCount * 2, this.vertices = [], this.vertices.length = this.vertexCount * c, this.vertexIndices = [], this.vertexIndices.length = this.vertexCount;
          var F = 0, Y = 0, J = 0;
          for (S = 0, b = t.fHead.next; b !== t.fHead; b = b.next)
            if (b.inside) {
              C = 0, r = Z = b.anEdge;
              do
                this.vertices[F++] = Z.Org.coords[0], this.vertices[F++] = Z.Org.coords[1], c > 2 && (this.vertices[F++] = Z.Org.coords[2]), this.vertexIndices[Y++] = Z.Org.idx, C++, Z = Z.Lnext;
              while (Z !== r);
              this.elements[J++] = S, this.elements[J++] = C, S += C;
            }
        },
        addContour: function(t, c) {
          var b, Z;
          for (this.mesh === null && (this.mesh = new G()), t < 2 && (t = 2), t > 3 && (t = 3), b = null, Z = 0; Z < c.length; Z += t)
            b === null ? (b = this.mesh.makeEdge(), this.mesh.splice(b, b.Sym)) : (this.mesh.splitEdge(b), b = b.Lnext), b.Org.coords[0] = c[Z + 0], b.Org.coords[1] = c[Z + 1], t > 2 ? b.Org.coords[2] = c[Z + 2] : b.Org.coords[2] = 0, b.Org.idx = this.vertexIndexCounter++, b.winding = 1, b.Sym.winding = -1;
        },
        //	int tessTesselate( TESStesselator *tess, int windingRule, int elementType, int polySize, int vertexSize, const TESSreal* normal )
        tesselate: function(t, c, b, Z, r) {
          if (this.vertices = [], this.elements = [], this.vertexIndices = [], this.vertexIndexCounter = 0, r && (this.normal[0] = r[0], this.normal[1] = r[1], this.normal[2] = r[2]), this.windingRule = t, Z < 2 && (Z = 2), Z > 3 && (Z = 3), !this.mesh)
            return !1;
          this.projectPolygon_(), W.computeInterior(this);
          var S = this.mesh;
          return c === d.BOUNDARY_CONTOURS ? this.setWindingNumber_(S, 1, !0) : this.tessellateInterior_(S), S.check(), c === d.BOUNDARY_CONTOURS ? this.outputContours_(S, Z) : this.outputPolymesh_(S, c, b, Z), !0;
        }
      };
    },
    /* 62 */
    /***/
    function(m, l) {
      m.exports = d;
      var i = Object.prototype.hasOwnProperty;
      function d() {
        for (var s = {}, X = 0; X < arguments.length; X++) {
          var a = arguments[X];
          for (var e in a)
            i.call(a, e) && (s[e] = a[e]);
        }
        return s;
      }
    },
    /* 63 */
    /***/
    function(m, l, i) {
      i.r(l), i.d(l, "createShaders", function() {
        return n;
      }), i.d(l, "applyShader", function() {
        return G;
      }), i.d(l, "createCloudShaders", function() {
        return o;
      }), i.d(l, "applyCloudShader", function() {
        return h;
      });
      var d = i(64), s = i(65), X = i(66), a = i(67);
      i(1).glMatrix.setMatrixArrayType(Array);
      const e = Symbol("shaders");
      function n(I) {
        I[e] = [];
        for (let x = 0; x < 16; x++) {
          const p = [], W = !!(x & 1), V = !!(x & 2), t = !!(x & 4), c = !!(x & 8);
          W && p.push("#define TEXTURE 1"), V && p.push("#define FILTER 1"), t && p.push("#define GRADIENT 1"), c && p.push("#define CLIPPATH 1");
          const b = `${p.join(`
`)}
`, Z = [];
          W && Z.push("uniform sampler2D u_texSampler;"), c && Z.push("uniform sampler2D u_clipSampler;"), I[e][x] = [b + Z.join(`
`) + s.default, b + d.default];
        }
      }
      function G(I, {
        hasTexture: x = !1,
        hasFilter: p = !1,
        hasGradient: W = !1,
        hasClipPath: V = !1
      } = {}) {
        const t = x | p << 1 | W << 2 | V << 3;
        let c = I[e][t];
        Array.isArray(c) && (c = I.createProgram(...c), I[e][t] = c), I.program !== c && I.useProgram(c, {
          a_color: {
            type: "UNSIGNED_BYTE",
            normalize: !0
          }
        });
      }
      const y = [];
      function o(I) {
        for (let x = 0; x < 64; x++) {
          const p = [], W = !!(x & 1), V = !!(x & 2), t = !!(x & 4), c = !!(x & 8), b = !!(x & 16), Z = !!(x & 32);
          W && p.push("#define TEXTURE 1"), V && p.push("#define FILTER 1"), t && p.push("#define GRADIENT 1"), c && p.push("#define CLOUDCOLOR 1"), b && p.push("#define CLOUDFILTER 1"), Z && p.push("#define CLIPPATH 1");
          const r = `${p.join(`
`)}
`, S = [];
          if (W) {
            S.push("uniform sampler2D u_texSampler;");
            for (let C = 0; C < 12; C++)
              S.push(`uniform sampler2D u_texFrame${C};`);
          }
          Z && S.push("uniform sampler2D u_clipSampler;"), y[x] = [r + S.join(`
`) + a.default, r + X.default];
        }
      }
      function h(I, {
        hasTexture: x = !1,
        hasFilter: p = !1,
        hasGradient: W = !1,
        hasCloudColor: V = !1,
        hasCloudFilter: t = !1,
        hasClipPath: c = !1
      } = {}) {
        const b = x | p << 1 | W << 2 | V << 3 | t << 4 | c << 5;
        let Z = y[b];
        Array.isArray(Z) && (Z = I.createProgram(...Z), y[b] = Z), I.program !== Z && I.useProgram(Z, {
          a_color: {
            type: "UNSIGNED_BYTE",
            normalize: !0
          },
          a_fillCloudColor: {
            type: "UNSIGNED_BYTE",
            normalize: !0
          },
          a_strokeCloudColor: {
            type: "UNSIGNED_BYTE",
            normalize: !0
          },
          a_frameIndex: {
            type: "UNSIGNED_BYTE",
            normalize: !1
          }
        });
      }
    },
    /* 64 */
    /***/
    function(m, l, i) {
      i.r(l), l.default = `attribute vec3 a_vertexPosition;
attribute vec4 a_color;
varying vec4 vColor;
varying float flagBackground;
uniform vec2 u_resolution;
uniform mat3 viewMatrix;
uniform mat3 projectionMatrix;

#ifdef TEXTURE
attribute vec3 a_vertexTextureCoord;
varying vec3 vTextureCoord;
attribute vec4 a_sourceRect;
varying vec4 vSourceRect;
#endif

#ifdef CLIPPATH
attribute vec2 a_clipUV;
varying vec2 vClipUV;
#endif

#ifdef GRADIENT
uniform float u_radialGradientVector[6];
varying vec3 vGradientVector1;
varying vec3 vGradientVector2;
#endif

void main() {
  gl_PointSize = 1.0;

  vec3 pos = projectionMatrix * viewMatrix * vec3(a_vertexPosition.xy, 1.0);
  gl_Position = vec4(pos.xy, 1.0, 1.0);

#ifdef GRADIENT
  vec3 vg1 = viewMatrix * vec3(u_radialGradientVector[0], u_radialGradientVector[1], 1.0);
  vec3 vg2 = viewMatrix * vec3(u_radialGradientVector[3], u_radialGradientVector[4], 1.0);
  float h = u_resolution.y;
  vg1.y = h - vg1.y;
  vg2.y = h - vg2.y;
  vGradientVector1 = vec3(vg1.xy, u_radialGradientVector[2]);
  vGradientVector2 = vec3(vg2.xy, u_radialGradientVector[5]);
#endif
  
  flagBackground = a_vertexPosition.z;
  vColor = a_color;

#ifdef TEXTURE
  vTextureCoord = a_vertexTextureCoord;
  vSourceRect = a_sourceRect;
#endif

#ifdef CLIPPATH
  vClipUV = a_clipUV;
#endif
}`;
    },
    /* 65 */
    /***/
    function(m, l, i) {
      i.r(l), l.default = `precision mediump float;

varying vec4 vColor;
varying float flagBackground;

#ifdef TEXTURE
varying vec3 vTextureCoord;
varying vec4 vSourceRect;
#endif

#ifdef CLIPPATH
varying vec2 vClipUV;
#endif

#ifdef FILTER
uniform int u_filterFlag;
uniform float u_colorMatrix[20];
#endif

#ifdef GRADIENT
varying vec3 vGradientVector1;
varying vec3 vGradientVector2;
uniform float u_colorSteps[40];
uniform int u_gradientType;
// uniform float u_radialGradientVector[6];

void gradient(inout vec4 color, vec3 gv1, vec3 gv2, float colorSteps[40]) {
  float t;
  // center circle radius
  float cr = gv1.z;
  // focal circle radius
  float fr = gv2.z;

  if(cr > 0.0 || fr > 0.0) {
    // radial gradient
    vec2 center = gv1.xy;
    vec2 focal = gv2.xy;
    float x = focal.x - gl_FragCoord.x;
    float y = focal.y - gl_FragCoord.y;
    float dx = focal.x - center.x;
    float dy = focal.y - center.y;
    float dr = cr - fr;
    float a = dx * dx + dy * dy - dr * dr;
    float b = -2.0 * (y * dy + x * dx + fr * dr);
    float c = x * x + y * y - fr * fr;
    t = 1.0 - 0.5 * (1.0 / a) * (-b + sqrt(b * b - 4.0 * a * c));
  } else {
    // linear gradient
    vec2 v1 = gl_FragCoord.xy - gv1.xy;
    vec2 v2 = gv2.xy - gv1.xy;
    t = (v1.x * v2.x + v1.y * v2.y) / (v2.x * v2.x + v2.y * v2.y);
  }

  vec4 colors[8];
  colors[0] = vec4(colorSteps[1], colorSteps[2], colorSteps[3], colorSteps[4]);
  colors[1] = vec4(colorSteps[6], colorSteps[7], colorSteps[8], colorSteps[9]);
  colors[2] = vec4(colorSteps[11], colorSteps[12], colorSteps[13], colorSteps[14]);
  colors[3] = vec4(colorSteps[16], colorSteps[17], colorSteps[18], colorSteps[19]);
  colors[4] = vec4(colorSteps[21], colorSteps[22], colorSteps[23], colorSteps[24]);
  colors[5] = vec4(colorSteps[26], colorSteps[27], colorSteps[28], colorSteps[29]);
  colors[6] = vec4(colorSteps[31], colorSteps[32], colorSteps[33], colorSteps[34]);
  colors[7] = vec4(colorSteps[36], colorSteps[37], colorSteps[38], colorSteps[39]);
  
  float steps[8];
  steps[0] = colorSteps[0];
  steps[1] = colorSteps[5];
  steps[2] = colorSteps[10];
  steps[3] = colorSteps[15];
  steps[4] = colorSteps[20];
  steps[5] = colorSteps[25];
  steps[6] = colorSteps[30];
  steps[7] = colorSteps[35];

  color = colors[0];
  for (int i = 1; i < 8; i++) {
    if (steps[i] < 0.0 || steps[i] > 1.0) {
      break;
    }
    if(steps[i] == steps[i - 1]) {
      color = colors[i];
    } else {
      color = mix(color, colors[i], clamp((t - steps[i - 1]) / (steps[i] - steps[i - 1]), 0.0, 1.0));
    }
    if (steps[i] >= t) {
      break;
    }
  }
}
#endif

#ifdef FILTER
void transformColor(inout vec4 color, in float colorMatrix[20]) {
  float r = color.r, g = color.g, b = color.b, a = color.a;
  color[0] = colorMatrix[0] * r + colorMatrix[1] * g + colorMatrix[2] * b + colorMatrix[3] * a + colorMatrix[4];
  color[1] = colorMatrix[5] * r + colorMatrix[6] * g + colorMatrix[7] * b + colorMatrix[8] * a + colorMatrix[9];
  color[2] = colorMatrix[10] * r + colorMatrix[11] * g + colorMatrix[12] * b + colorMatrix[13] * a + colorMatrix[14];
  color[3] = colorMatrix[15] * r + colorMatrix[16] * g + colorMatrix[17] * b + colorMatrix[18] * a + colorMatrix[19];
}
#endif

void main() {
  vec4 color = vColor;
  float opacity = abs(flagBackground);

#ifdef GRADIENT
  if(u_gradientType > 0 && flagBackground > 0.0 || u_gradientType == 0 && flagBackground <= 0.0) {
    gradient(color, vGradientVector1, vGradientVector2, u_colorSteps);
  }
#endif

  if(opacity < 1.0) {
    color.a *= opacity;
  }

#ifdef TEXTURE
  if(flagBackground > 0.0) {
    vec3 texCoord = vTextureCoord;

    if(texCoord.z == 1.0) {
      texCoord = fract(texCoord);
    }

    if(texCoord.x <= 1.0 && texCoord.x >= 0.0
      && texCoord.y <= 1.0 && texCoord.y >= 0.0) {
      if(vSourceRect.z > 0.0) {
        texCoord.x = vSourceRect.x + texCoord.x * vSourceRect.z;
        texCoord.y = 1.0 - (vSourceRect.y + (1.0 - texCoord.y) * vSourceRect.w);
      }
      vec4 texColor = texture2D(u_texSampler, texCoord.xy);
      float alpha = texColor.a;
      if(opacity < 1.0) {
        texColor.a *= opacity;
        alpha *= mix(0.465, 1.0, opacity);
      }
      // color = mix(color, texColor, texColor.a);
      color.rgb = mix(color.rgb, texColor.rgb, alpha);
      // color.rgb = mix(texColor.rgb, color.rgb, color.a);
      color.rgb = mix(texColor.rgb, color.rgb, clamp(color.a / max(0.0001, texColor.a), 0.0, 1.0));
      color.a = texColor.a + (1.0 - texColor.a) * color.a;
    }
  }
#endif

#ifdef FILTER
  if(u_filterFlag > 0) {
    transformColor(color, u_colorMatrix);
  }
#endif

#ifdef CLIPPATH
  float clip = texture2D(u_clipSampler, vClipUV).r;
  color *= clip;
#endif

  gl_FragColor = color;
}`;
    },
    /* 66 */
    /***/
    function(m, l, i) {
      i.r(l), l.default = `attribute vec3 a_vertexPosition;
attribute vec4 a_color;
varying vec4 vColor;
varying float flagBackground;
attribute vec3 a_transform0;
attribute vec3 a_transform1;
uniform vec2 u_resolution;
uniform mat3 viewMatrix;
uniform mat3 projectionMatrix;

#ifdef TEXTURE
attribute vec3 a_vertexTextureCoord;
varying vec3 vTextureCoord;
attribute float a_frameIndex;
varying float frameIndex;
attribute vec4 a_sourceRect;
varying vec4 vSourceRect;
#endif

#ifdef CLIPPATH
attribute vec2 a_clipUV;
varying vec2 vClipUV;
#endif

#ifdef CLOUDFILTER
attribute vec4 a_colorCloud0;
attribute vec4 a_colorCloud1;
attribute vec4 a_colorCloud2;
attribute vec4 a_colorCloud3;
attribute vec4 a_colorCloud4;
varying vec4 colorCloud0;
varying vec4 colorCloud1;
varying vec4 colorCloud2;
varying vec4 colorCloud3;
varying vec4 colorCloud4;
#endif

#ifdef CLOUDCOLOR
attribute vec4 a_fillCloudColor;
attribute vec4 a_strokeCloudColor;
#endif

#ifdef GRADIENT
uniform float u_radialGradientVector[6];
varying vec3 vGradientVector1;
varying vec3 vGradientVector2;
#endif

void main() {
  gl_PointSize = 1.0;

  mat3 modelMatrix = mat3(
    a_transform0.x, a_transform1.x, 0, 
    a_transform0.y, a_transform1.y, 0,
    a_transform0.z, a_transform1.z, 1
  );

  vec3 pos = projectionMatrix * viewMatrix * modelMatrix * vec3(a_vertexPosition.xy, 1.0);
  gl_Position = vec4(pos.xy, 1.0, 1.0);

#ifdef GRADIENT
  vec3 vg1 = viewMatrix * vec3(u_radialGradientVector[0], u_radialGradientVector[1], 1.0);
  vec3 vg2 = viewMatrix * vec3(u_radialGradientVector[3], u_radialGradientVector[4], 1.0);
  float h = u_resolution.y;
  vg1.y = h - vg1.y;
  vg2.y = h - vg2.y;
  vGradientVector1 = vec3(vg1.xy, u_radialGradientVector[2]);
  vGradientVector2 = vec3(vg2.xy, u_radialGradientVector[5]);
#endif
  
  flagBackground = a_vertexPosition.z;

#ifdef CLOUDCOLOR
  if(flagBackground > 0.0) {
    vColor = mix(a_color, a_fillCloudColor, a_fillCloudColor.a);
  } else {
    vColor = mix(a_color, a_strokeCloudColor, a_strokeCloudColor.a);
  }
#else
  vColor = a_color;
#endif

#ifdef TEXTURE
  vTextureCoord = a_vertexTextureCoord;
  frameIndex = a_frameIndex;
  vSourceRect = a_sourceRect;
#endif

#ifdef CLIPPATH
  vClipUV = a_clipUV;
#endif

#ifdef CLOUDFILTER
  colorCloud0 = a_colorCloud0;
  colorCloud1 = a_colorCloud1;
  colorCloud2 = a_colorCloud2;
  colorCloud3 = a_colorCloud3;
  colorCloud4 = a_colorCloud4;
#endif
}`;
    },
    /* 67 */
    /***/
    function(m, l, i) {
      i.r(l), l.default = `precision mediump float;

varying vec4 vColor;
varying float flagBackground;

#ifdef TEXTURE
varying float frameIndex;
varying vec3 vTextureCoord;
varying vec4 vSourceRect;
#endif

#ifdef CLIPPATH
varying vec2 vClipUV;
#endif

#ifdef FILTER
uniform int u_filterFlag;
uniform float u_colorMatrix[20];
#endif

#ifdef CLOUDFILTER
varying vec4 colorCloud0;
varying vec4 colorCloud1;
varying vec4 colorCloud2;
varying vec4 colorCloud3;
varying vec4 colorCloud4;
#endif

#ifdef GRADIENT
varying vec3 vGradientVector1;
varying vec3 vGradientVector2;
uniform float u_colorSteps[40];
uniform int u_gradientType;

void gradient(inout vec4 color, vec3 gv1, vec3 gv2, float colorSteps[40]) {
  float t;
  // center circle radius
  float cr = gv1.z;
  // focal circle radius
  float fr = gv2.z;

  if(cr > 0.0 || fr > 0.0) {
    // radial gradient
    vec2 center = gv1.xy;
    vec2 focal = gv2.xy;
    float x = focal.x - gl_FragCoord.x;
    float y = focal.y - gl_FragCoord.y;
    float dx = focal.x - center.x;
    float dy = focal.y - center.y;
    float dr = cr - fr;
    float a = dx * dx + dy * dy - dr * dr;
    float b = -2.0 * (y * dy + x * dx + fr * dr);
    float c = x * x + y * y - fr * fr;
    t = 1.0 - 0.5 * (1.0 / a) * (-b + sqrt(b * b - 4.0 * a * c));
  } else {
    // linear gradient
    vec2 v1 = gl_FragCoord.xy - gv1.xy;
    vec2 v2 = gv2.xy - gv1.xy;
    t = (v1.x * v2.x + v1.y * v2.y) / (v2.x * v2.x + v2.y * v2.y);
  }

  vec4 colors[8];
  colors[0] = vec4(colorSteps[1], colorSteps[2], colorSteps[3], colorSteps[4]);
  colors[1] = vec4(colorSteps[6], colorSteps[7], colorSteps[8], colorSteps[9]);
  colors[2] = vec4(colorSteps[11], colorSteps[12], colorSteps[13], colorSteps[14]);
  colors[3] = vec4(colorSteps[16], colorSteps[17], colorSteps[18], colorSteps[19]);
  colors[4] = vec4(colorSteps[21], colorSteps[22], colorSteps[23], colorSteps[24]);
  colors[5] = vec4(colorSteps[26], colorSteps[27], colorSteps[28], colorSteps[29]);
  colors[6] = vec4(colorSteps[31], colorSteps[32], colorSteps[33], colorSteps[34]);
  colors[7] = vec4(colorSteps[36], colorSteps[37], colorSteps[38], colorSteps[39]);
  
  float steps[8];
  steps[0] = colorSteps[0];
  steps[1] = colorSteps[5];
  steps[2] = colorSteps[10];
  steps[3] = colorSteps[15];
  steps[4] = colorSteps[20];
  steps[5] = colorSteps[25];
  steps[6] = colorSteps[30];
  steps[7] = colorSteps[35];

  color = colors[0];
  for (int i = 1; i < 8; i++) {
    if (steps[i] < 0.0 || steps[i] > 1.0) {
      break;
    }
    if(steps[i] == steps[i - 1]) {
      color = colors[i];
    } else {
      color = mix(color, colors[i], clamp((t - steps[i - 1]) / (steps[i] - steps[i - 1]), 0.0, 1.0));
    }
    if (steps[i] >= t) {
      break;
    }
  }
}
#endif

void transformColor(inout vec4 color, in float colorMatrix[20]) {
  float r = color.r, g = color.g, b = color.b, a = color.a;
  color[0] = colorMatrix[0] * r + colorMatrix[1] * g + colorMatrix[2] * b + colorMatrix[3] * a + colorMatrix[4];
  color[1] = colorMatrix[5] * r + colorMatrix[6] * g + colorMatrix[7] * b + colorMatrix[8] * a + colorMatrix[9];
  color[2] = colorMatrix[10] * r + colorMatrix[11] * g + colorMatrix[12] * b + colorMatrix[13] * a + colorMatrix[14];
  color[3] = colorMatrix[15] * r + colorMatrix[16] * g + colorMatrix[17] * b + colorMatrix[18] * a + colorMatrix[19];
}

#ifdef CLOUDFILTER
void buildCloudColor(inout float colorCloudMatrix[20]) {
  colorCloudMatrix[0] = colorCloud0[0];
  colorCloudMatrix[1] = colorCloud1[0];
  colorCloudMatrix[2] = colorCloud2[0];
  colorCloudMatrix[3] = colorCloud3[0];
  colorCloudMatrix[4] = colorCloud4[0];

  colorCloudMatrix[5] = colorCloud0[1];
  colorCloudMatrix[6] = colorCloud1[1];
  colorCloudMatrix[7] = colorCloud2[1];
  colorCloudMatrix[8] = colorCloud3[1];
  colorCloudMatrix[9] = colorCloud4[1];

  colorCloudMatrix[10] = colorCloud0[2];
  colorCloudMatrix[11] = colorCloud1[2];
  colorCloudMatrix[12] = colorCloud2[2];
  colorCloudMatrix[13] = colorCloud3[2];
  colorCloudMatrix[14] = colorCloud4[2];

  colorCloudMatrix[15] = colorCloud0[3];
  colorCloudMatrix[16] = colorCloud1[3];
  colorCloudMatrix[17] = colorCloud2[3];
  colorCloudMatrix[18] = colorCloud3[3];
  colorCloudMatrix[19] = colorCloud4[3];
}
#endif

void main() {
  vec4 color = vColor;
  float opacity = abs(flagBackground);

#ifdef GRADIENT
  if(u_gradientType > 0 && flagBackground > 0.0 || u_gradientType == 0 && flagBackground <= 0.0) {
    gradient(color, vGradientVector1, vGradientVector2, u_colorSteps);
  }
#endif

  if(opacity < 1.0) {
    color.a *= opacity;
  }

#ifdef TEXTURE
  if(flagBackground > 0.0) {
    vec3 texCoord = vTextureCoord;

    if(texCoord.z == 1.0) {
      texCoord = fract(texCoord);
    }

    if(texCoord.x <= 1.0 && texCoord.x >= 0.0
      && texCoord.y <= 1.0 && texCoord.y >= 0.0) {
      if(vSourceRect.z > 0.0) {
        texCoord.x = vSourceRect.x + texCoord.x * vSourceRect.z;
        texCoord.y = 1.0 - (vSourceRect.y + (1.0 - texCoord.y) * vSourceRect.w);
      }
      if(frameIndex < 0.0) {
        vec4 texColor = texture2D(u_texSampler, texCoord.xy);
        color = mix(color, texColor, texColor.a);
      } else {
        int index = int(floor(clamp(0.0, 11.0, frameIndex)));
        vec4 texColor;
        if(index == 0) texColor = texture2D(u_texFrame0, texCoord.xy);
        else if(index == 1) texColor = texture2D(u_texFrame1, texCoord.xy);
        else if(index == 2) texColor = texture2D(u_texFrame2, texCoord.xy);
        else if(index == 3) texColor = texture2D(u_texFrame3, texCoord.xy);
        else if(index == 4) texColor = texture2D(u_texFrame4, texCoord.xy);
        else if(index == 5) texColor = texture2D(u_texFrame5, texCoord.xy);
        else if(index == 6) texColor = texture2D(u_texFrame6, texCoord.xy);
        else if(index == 7) texColor = texture2D(u_texFrame7, texCoord.xy);
        else if(index == 8) texColor = texture2D(u_texFrame8, texCoord.xy);
        else if(index == 9) texColor = texture2D(u_texFrame9, texCoord.xy);
        else if(index == 10) texColor = texture2D(u_texFrame10, texCoord.xy);
        else texColor = texture2D(u_texFrame11, texCoord.xy);
        float alpha = texColor.a;
        if(opacity < 1.0) {
          texColor.a *= opacity;
          alpha *= mix(0.465, 1.0, opacity);
        }
        // color = mix(color, texColor, texColor.a);
        color.rgb = mix(color.rgb, texColor.rgb, alpha);
        // color.rgb = mix(texColor.rgb, color.rgb, color.a);
        color.rgb = mix(texColor.rgb, color.rgb, clamp(color.a / max(0.0001, texColor.a), 0.0, 1.0));
        color.a = texColor.a + (1.0 - texColor.a) * color.a;
      }
    }
  }
#endif

#ifdef FILTER
  if(u_filterFlag > 0) {
    transformColor(color, u_colorMatrix);
  }
#endif

#ifdef CLOUDFILTER
  float colorCloudMatrix[20];
  buildCloudColor(colorCloudMatrix);
  transformColor(color, colorCloudMatrix);
#endif

#ifdef CLIPPATH
  float clip = texture2D(u_clipSampler, vClipUV).r;
  color *= clip;
#endif

  gl_FragColor = color;
}`;
    },
    /* 68 */
    /***/
    function(m, l, i) {
      i.r(l), (function(d, s) {
        i.d(l, "requestAnimationFrame", function() {
          return a;
        }), i.d(l, "cancelAnimationFrame", function() {
          return e;
        }), i(1).glMatrix.setMatrixArrayType(Array);
        function X() {
          if (typeof performance < "u" && performance.now)
            return performance.now();
          if (typeof d < "u" && d.hrtime) {
            const [n, G] = d.hrtime();
            return n * 1e3 + G * 1e-6;
          }
          return Date.now ? Date.now() : (/* @__PURE__ */ new Date()).getTime();
        }
        let a, e;
        typeof s < "u" && typeof s.requestAnimationFrame == "function" ? (a = s.requestAnimationFrame, e = s.cancelAnimationFrame) : (a = function(n) {
          return setTimeout(() => {
            n(X());
          }, 16);
        }, e = function(n) {
          return clearTimeout(n);
        });
      }).call(this, i(69), i(22));
    },
    /* 69 */
    /***/
    function(m, l) {
      var i = m.exports = {}, d, s;
      function X() {
        throw new Error("setTimeout has not been defined");
      }
      function a() {
        throw new Error("clearTimeout has not been defined");
      }
      (function() {
        try {
          typeof setTimeout == "function" ? d = setTimeout : d = X;
        } catch {
          d = X;
        }
        try {
          typeof clearTimeout == "function" ? s = clearTimeout : s = a;
        } catch {
          s = a;
        }
      })();
      function e(V) {
        if (d === setTimeout)
          return setTimeout(V, 0);
        if ((d === X || !d) && setTimeout)
          return d = setTimeout, setTimeout(V, 0);
        try {
          return d(V, 0);
        } catch {
          try {
            return d.call(null, V, 0);
          } catch {
            return d.call(this, V, 0);
          }
        }
      }
      function n(V) {
        if (s === clearTimeout)
          return clearTimeout(V);
        if ((s === a || !s) && clearTimeout)
          return s = clearTimeout, clearTimeout(V);
        try {
          return s(V);
        } catch {
          try {
            return s.call(null, V);
          } catch {
            return s.call(this, V);
          }
        }
      }
      var G = [], y = !1, o, h = -1;
      function I() {
        !y || !o || (y = !1, o.length ? G = o.concat(G) : h = -1, G.length && x());
      }
      function x() {
        if (!y) {
          var V = e(I);
          y = !0;
          for (var t = G.length; t; ) {
            for (o = G, G = []; ++h < t; )
              o && o[h].run();
            h = -1, t = G.length;
          }
          o = null, y = !1, n(V);
        }
      }
      i.nextTick = function(V) {
        var t = new Array(arguments.length - 1);
        if (arguments.length > 1)
          for (var c = 1; c < arguments.length; c++)
            t[c - 1] = arguments[c];
        G.push(new p(V, t)), G.length === 1 && !y && e(x);
      };
      function p(V, t) {
        this.fun = V, this.array = t;
      }
      p.prototype.run = function() {
        this.fun.apply(null, this.array);
      }, i.title = "browser", i.browser = !0, i.env = {}, i.argv = [], i.version = "", i.versions = {};
      function W() {
      }
      i.on = W, i.addListener = W, i.once = W, i.off = W, i.removeListener = W, i.removeAllListeners = W, i.emit = W, i.prependListener = W, i.prependOnceListener = W, i.listeners = function(V) {
        return [];
      }, i.binding = function(V) {
        throw new Error("process.binding is not supported");
      }, i.cwd = function() {
        return "/";
      }, i.chdir = function(V) {
        throw new Error("process.chdir is not supported");
      }, i.umask = function() {
        return 0;
      };
    },
    /* 70 */
    /***/
    function(m, l, i) {
      i.r(l), i.d(l, "default", function() {
        return C;
      });
      var d = i(1), s = i(71), X = i(73), a = i(213), e = i(214), n = i(215), G = i(216);
      i(1).glMatrix.setMatrixArrayType(Array);
      function y(F, Y) {
        var J = Object.keys(F);
        if (Object.getOwnPropertySymbols) {
          var T = Object.getOwnPropertySymbols(F);
          Y && (T = T.filter(function(K) {
            return Object.getOwnPropertyDescriptor(F, K).enumerable;
          })), J.push.apply(J, T);
        }
        return J;
      }
      function o(F) {
        for (var Y = 1; Y < arguments.length; Y++) {
          var J = arguments[Y] != null ? arguments[Y] : {};
          Y % 2 ? y(Object(J), !0).forEach(function(T) {
            h(F, T, J[T]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(F, Object.getOwnPropertyDescriptors(J)) : y(Object(J)).forEach(function(T) {
            Object.defineProperty(F, T, Object.getOwnPropertyDescriptor(J, T));
          });
        }
        return F;
      }
      function h(F, Y, J) {
        return Y in F ? Object.defineProperty(F, Y, { value: J, enumerable: !0, configurable: !0, writable: !0 }) : F[Y] = J, F;
      }
      const I = Symbol.for("spritejs_changedAttrs"), x = Symbol.for("spritejs_attributes"), p = Symbol("resolution"), W = Symbol("animations"), V = Symbol("eventListeners"), t = Symbol("captureEventListeners"), c = Symbol("filters"), b = Symbol("display"), Z = Symbol("program"), r = Symbol("shaderAttrs"), S = Symbol("uniforms");
      class C {
        constructor(Y = {}) {
          this.attributes = new this.constructor.Attr(this), this[p] = {
            width: 300,
            height: 150
          }, Object.assign(this.attributes, Y), this[W] = /* @__PURE__ */ new Set(), this[V] = {}, this[t] = {};
        }
        get ancestors() {
          let Y = this.parent;
          const J = [];
          for (; Y; )
            J.push(Y), Y = Y.parent;
          return J;
        }
        get animations() {
          return this[W];
        }
        get filters() {
          return this[c] || this.parent && this.parent.filters;
        }
        get isVisible() {
          return !1;
        }
        get layer() {
          return this.parent ? this.parent.layer : null;
        }
        get localMatrix() {
          const Y = this.transformMatrix, {
            x: J,
            y: T
          } = this.attributes;
          return Y[4] += J, Y[5] += T, Y;
        }
        get opacity() {
          let Y = this.attributes.opacity;
          return this.parent && this.parent.opacity != null && (Y *= this.parent.opacity), Y;
        }
        get parentNode() {
          return this.parent;
        }
        get nextSibling() {
          return this.getNodeNearBy(1);
        }
        get previousSibling() {
          return this.getNodeNearBy(-1);
        }
        get program() {
          return this[Z];
        }
        /* get parent defined by connect method */
        get renderer() {
          return this.parent ? this.parent.renderer : null;
        }
        get renderMatrix() {
          if (this.__cacheRenderMatrix)
            return this.__cacheRenderMatrix;
          let Y = this.localMatrix;
          const J = this.parent;
          if (J) {
            const T = J.__cacheRenderMatrix || J.renderMatrix;
            T && (Y = d.mat2d.multiply(Array.of(0, 0, 0, 0, 0, 0), T, Y));
          }
          return Y;
        }
        get worldScaling() {
          const Y = this.renderMatrix;
          return [Math.hypot(Y[0], Y[1]), Math.hypot(Y[2], Y[3])];
        }
        get worldRotation() {
          const Y = this.renderMatrix;
          return Math.atan2(Y[1], Y[3]);
        }
        get worldPosition() {
          const Y = this.renderMatrix;
          return [Y[4], Y[5]];
        }
        get uniforms() {
          return this[S];
        }
        /* get zOrder defined by connect method */
        /* attributes */
        get className() {
          return this.attributes.className;
        }
        set className(Y) {
          this.attributes.className = Y;
        }
        get id() {
          return this.attributes.id;
        }
        set id(Y) {
          this.attributes.id = Y;
        }
        get name() {
          return this.attributes.name;
        }
        set name(Y) {
          this.attributes.name = Y;
        }
        get zIndex() {
          return this.attributes.zIndex;
        }
        set zIndex(Y) {
          this.attributes.zIndex = Y;
        }
        get mesh() {
          return null;
        }
        get shaderAttrs() {
          return this[r] || {};
        }
        activateAnimations() {
          const Y = this.layer;
          if (Y) {
            const J = this[W];
            J.forEach((K) => {
              K.baseTimeline = Y.timeline, K.play(), K.finished.then(() => {
                J.delete(K);
              });
            });
            const T = this.children;
            T && T.forEach((K) => {
              K.activateAnimations && K.activateAnimations();
            });
          }
        }
        addEventListener(Y, J, T = {}) {
          Y === "mousewheel" && (Y = "wheel"), typeof T == "boolean" && (T = {
            capture: T
          });
          const {
            capture: K,
            once: R
          } = T, H = K ? t : V;
          return this[H][Y] = this[H][Y] || [], this[H][Y].push({
            listener: J,
            once: R
          }), this;
        }
        animate(Y, J) {
          const T = new X.default(this, Y, J);
          return this.effects && T.applyEffects(this.effects), this.layer && (T.baseTimeline = this.layer.timeline, T.play(), T.finished.then(() => {
            this[W].delete(T);
          })), this[W].add(T), T;
        }
        attr(...Y) {
          if (Y.length === 0)
            return this.attributes[x];
          if (Y.length > 1) {
            let [J, T] = Y;
            return typeof T == "function" && (T = T(this.attr(J))), this.setAttribute(J, T), this;
          }
          return typeof Y[0] == "string" ? this.getAttribute(Y[0]) : (Object.assign(this.attributes, Y[0]), this);
        }
        cloneNode() {
          const Y = new this.constructor(), J = this.attributes[I];
          return Y.attr(J), Y;
        }
        connect(Y, J) {
          Object.defineProperty(this, "parent", {
            value: Y,
            writable: !1,
            configurable: !0
          }), Object.defineProperty(this, "zOrder", {
            value: J,
            writable: !1,
            configurable: !0
          }), Y.timeline && this.activateAnimations(), this.setResolution(Y.getResolution()), this.forceUpdate(), this.dispatchEvent({
            type: "append",
            detail: {
              parent: Y,
              zOrder: J
            }
          });
        }
        contains(Y) {
          for (; Y && this !== Y; )
            Y = Y.parent;
          return !!Y;
        }
        deactivateAnimations() {
          this[W].forEach((J) => J.cancel());
          const Y = this.children;
          Y && Y.forEach((J) => {
            J.deactivateAnimations && J.deactivateAnimations();
          });
        }
        disconnect() {
          const {
            parent: Y,
            zOrder: J
          } = this;
          delete this.parent, delete this.zOrder, this.deactivateAnimations(), this.dispatchEvent({
            type: "remove",
            detail: {
              parent: Y,
              zOrder: J
            }
          }), Y && Y.forceUpdate();
        }
        dispatchEvent(Y) {
          Y instanceof e.default || (Y = new e.default(Y)), Y.target = this;
          let J = Y.type;
          J === "mousewheel" && (J = "wheel");
          const T = [this];
          let K = this.parent;
          for (; Y.bubbles && K; )
            T.push(K), K = K.parent;
          for (let R = T.length - 1; R >= 0; R--) {
            const H = T[R], f = H[t] && H[t][J];
            if (f && f.length && (Y.currentTarget = H, f.forEach(({
              listener: w,
              once: O
            }) => {
              w.call(this, Y), O && T.removeEventListener(w);
            }), delete Y.currentTarget), !Y.bubbles && Y.cancelBubble)
              break;
          }
          if (!Y.cancelBubble)
            for (let R = 0; R < T.length; R++) {
              const H = T[R], f = H[V] && H[V][J];
              if (f && f.length && (Y.currentTarget = H, f.forEach(({
                listener: w,
                once: O
              }) => {
                w.call(this, Y), O && T.removeEventListener(w);
              }), delete Y.currentTarget), !Y.bubbles || Y.cancelBubble)
                break;
            }
        }
        dispatchPointerEvent(Y) {
          const {
            layerX: J,
            layerY: T
          } = Y;
          return this.isPointCollision(J, T) ? (this.dispatchEvent(Y), !0) : !1;
        }
        draw(Y = []) {
          const J = this.mesh;
          if (J) {
            if (Object(n.applyFilters)(J, this.filters), Y.push(J), this[Z]) {
              J.setProgram(this[Z]);
              const T = this[r];
              T && Object.entries(T).forEach(([R, H]) => {
                J.setAttribute(R, H);
              });
              const K = this[S];
              if (this[S]) {
                const R = {};
                Object.entries(K).forEach(([H, f]) => {
                  typeof f == "function" && (f = f(this, H)), R[H] = f;
                }), J.setUniforms(R);
              }
            }
            Object(G.default)(this, J);
          }
          return Y;
        }
        forceUpdate() {
          this.parent && this.parent.forceUpdate();
        }
        getAttribute(Y) {
          return this.attributes[Y];
        }
        getListeners(Y, {
          capture: J = !1
        } = {}) {
          return [...this[J ? t : V][Y] || []];
        }
        getNodeNearBy(Y = 1) {
          if (!this.parent)
            return null;
          if (Y === 0)
            return this;
          const J = this.parent.children, T = J.indexOf(this);
          return J[T + Y];
        }
        getWorldPosition(Y, J) {
          const T = this.renderMatrix, K = Y * T[0] + J * T[2] + T[4], R = Y * T[1] + J * T[3] + T[5];
          return [K, R];
        }
        getOffsetPosition(Y, J) {
          const T = d.mat2d.invert(Array.of(0, 0, 0, 0, 0, 0), this.renderMatrix), K = Y * T[0] + J * T[2] + T[4], R = Y * T[1] + J * T[3] + T[5];
          return [K, R];
        }
        getResolution() {
          return o({}, this[p]);
        }
        isPointCollision(Y, J) {
          if (!this.mesh)
            return !1;
          const T = this.attributes.pointerEvents;
          if (T === "none" || T !== "all" && !this.isVisible)
            return !1;
          let K = "both";
          return T === "visibleFill" && (K = "fill"), T === "visibleStroke" && (K = "stroke"), this.mesh.isPointCollision(Y, J, K);
        }
        onPropertyChange(Y, J, T) {
          Y !== "id" && Y !== "name" && Y !== "className" && Y !== "pointerEvents" && Y !== "passEvents" && this.forceUpdate(), Y === "filter" && (this[c] = Object(n.parseFilterString)(J)), Y === "zIndex" && this.parent && this.parent.reorder();
        }
        setAttribute(Y, J) {
          Y === "attrs" && this.attr(J), this.attributes[Y] = J;
        }
        setMouseCapture() {
          this.layer && (this.layer.__mouseCapturedTarget = this);
        }
        // layer.renderer.createProgram(fragmentShader, vertexShader, attributeOptions)
        setProgram(Y) {
          this[Z] = Y, this.forceUpdate();
        }
        setShaderAttribute(Y, J) {
          this[r] = this[r] || {}, this[r][Y] = J, this.forceUpdate();
        }
        setUniforms(Y) {
          this[S] = this[S] || {}, Object.assign(this[S], Y), this.forceUpdate();
        }
        setResolution({
          width: Y,
          height: J
        }) {
          const {
            width: T,
            height: K
          } = this[p];
          (T !== Y || K !== J) && (this[p] = {
            width: Y,
            height: J
          }, this.forceUpdate(), this.dispatchEvent({
            type: "resolutionchange",
            detail: {
              width: Y,
              height: J
            }
          }));
        }
        show() {
          this.attributes.display === "none" && (this.attributes.display = this[b] || "");
        }
        hide() {
          this.attributes.display !== "none" && (this[b] = this.attributes.display, this.attributes.display = "none");
        }
        releaseMouseCapture() {
          this.layer && this.layer.__mouseCapturedTarget === this && (this.layer.__mouseCapturedTarget = null);
        }
        remove() {
          return this.parent && this.parent.removeChild ? (this.parent.removeChild(this), !0) : !1;
        }
        removeAllListeners(Y, J = {}) {
          typeof J == "boolean" && (J = {
            capture: J
          });
          const K = J.capture ? t : V;
          return this[K][Y] && (this[K][Y] = []), this;
        }
        removeAttribute(Y) {
          this.setAttribute(Y, null);
        }
        removeEventListener(Y, J, T = {}) {
          typeof T == "boolean" && (T = {
            capture: T
          });
          const R = T.capture ? t : V;
          if (this[R][Y]) {
            const H = this[R][Y];
            if (H)
              for (let f = 0; f < H.length; f++) {
                const {
                  listener: w
                } = H[f];
                if (w === J) {
                  this[R][Y].splice(f, 1);
                  break;
                }
              }
          }
          return this;
        }
        transition(Y, J = "linear") {
          const T = this, K = Symbol("animation");
          J = J || "linear";
          let R = 0;
          return typeof Y == "object" && (R = Y.delay || 0, Y = Y.duration), {
            [K]: null,
            cancel(H = !1) {
              const f = this[K];
              f && f.cancel(H);
            },
            end() {
              const H = this[K];
              H && (H.playState === "running" || H.playState === "pending") && H.finish();
            },
            reverse() {
              const H = this[K];
              if (H)
                if (H.playState === "running" || H.playState === "pending")
                  H.playbackRate = -H.playbackRate;
                else {
                  const f = H.timing.direction;
                  H.timing.direction = f === "reverse" ? "normal" : "reverse", H.play();
                }
              return H.finished;
            },
            attr(H, f) {
              return this.end(), typeof H == "string" && (H = {
                [H]: f
              }), Object.entries(H).forEach(([w, O]) => {
                typeof O == "function" && (H[w] = O(T.attr(w)));
              }), this[K] = T.animate([H], {
                duration: Y * 1e3,
                delay: R * 1e3,
                fill: "forwards",
                easing: J
              }), this[K].finished;
            }
          };
        }
        updateContours() {
        }
      }
      h(C, "Attr", s.default), a.default.registerNode(C, "node");
    },
    /* 71 */
    /***/
    function(m, l, i) {
      i.r(l), i.d(l, "default", function() {
        return C;
      });
      var d = i(1), s = i(12), X = i(72);
      i(1).glMatrix.setMatrixArrayType(Array);
      const a = Symbol.for("spritejs_setAttributeDefault"), e = Symbol.for("spritejs_declareAlias"), n = Symbol.for("spritejs_setAttribute"), G = Symbol.for("spritejs_getAttribute"), y = Symbol.for("spritejs_attributes"), o = Symbol.for("spritejs_changedAttrs"), h = Symbol("subject"), I = Symbol("attr"), x = Symbol("default"), p = Symbol("alias");
      function W(F, [Y, J]) {
        let T = d.mat2d.fromValues(1, 0, 0, 1, 0, 0);
        return [...F].forEach(([K, R]) => {
          if ((Y || J) && (T = d.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), T, [Y, J])), K === "matrix")
            T = d.mat2d.multiply(T, T, R);
          else if (K === "offsetTranslate")
            T[4] += R[0], T[5] += R[1];
          else if (K === "offsetRotate")
            T = d.mat2d.rotate(Array.of(0, 0, 0, 0, 0, 0), T, R);
          else if (K === "skew") {
            const [H, f] = R;
            T = d.mat2d.multiply(T, T, d.mat2d.fromValues(1, Math.tan(f), Math.tan(H), 1, 0, 0));
          } else
            d.mat2d[K](T, T, R);
          (Y || J) && (T = d.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), T, [-Y, -J]));
        }), T;
      }
      const V = Symbol("transformMatrix"), t = Symbol("transforms"), c = Symbol("changedAttrs"), b = Symbol("lastChangedAttr"), Z = Symbol("offsetFigure");
      function r(F, Y, J) {
        const T = F[I][Y];
        if (F[n](Y, J, !1) || F[b] !== Y) {
          const R = F[t];
          R.has(Y) && R.delete(Y), J && (Y === "rotate" && (J = Math.PI * J / 180), Y === "scale" && (J = J.map((H) => Math.abs(H) > 1e-5 ? H : 1 / H > 0 ? 1e-5 : -1e-5)), R.set(Y, J)), F[V] = null, F[h].onPropertyChange(Y, J, T, F);
        }
      }
      function S(F) {
        const Y = F[Z], J = F.offsetDistance * Y.getTotalLength(), T = Y.getPointAtLength(J);
        if (T) {
          const K = F[t];
          let R = F.offsetRotate;
          R === "auto" ? R = T.angle : R === "reverse" ? R = Math.PI + T.angle : R = Math.PI * R / 180, K.set("offsetRotate", R), K.set("offsetTranslate", [T.x, T.y]), F[V] = null;
        }
      }
      class C {
        static setDefault(Y, ...J) {
          return Y[a](...J);
        }
        static declareAlias(Y, ...J) {
          return Y[e](...J);
        }
        static setAttribute(Y, ...J) {
          return Y[n](...J);
        }
        static getAttribute(Y, ...J) {
          return Y[G](...J);
        }
        static getAttributes(Y) {
          return Y[y];
        }
        static getChangedAttributes(Y) {
          return Y[o];
        }
        constructor(Y) {
          this[h] = Y, this[I] = {}, this[V] = d.mat2d.fromValues(1, 0, 0, 1, 0, 0), this[t] = /* @__PURE__ */ new Map(), this[x] = {}, this[p] = [], Object.defineProperty(Y, "transformMatrix", {
            get: () => (this[V] || (this[V] = W(this[t], this.transformOrigin)), [...this[V]])
          }), this[a]({
            id: "",
            name: "",
            className: "",
            /* class */
            x: 0,
            y: 0,
            /* pos */
            transformOrigin: [0, 0],
            transform: "",
            translate: [0, 0],
            rotate: 0,
            scale: [1, 1],
            skew: [0, 0],
            opacity: 1,
            zIndex: 0,
            offsetPath: void 0,
            offsetDistance: 0,
            offsetRotate: "auto",
            pointerEvents: "visible",
            // none | visible | visibleFill | visibleStroke | all
            filter: "none",
            display: ""
          }), this[e]("class", "pos"), this[c] = /* @__PURE__ */ new Set(), this[Z] = new s.Figure2D({
            scale: 5,
            simplify: 0
          });
        }
        get [o]() {
          const Y = {};
          return [...this[c]].forEach((J) => {
            Y[J] = this[I][J];
          }), Y;
        }
        get [y]() {
          const Y = Object.assign({}, this[I]);
          for (let J = 0; J < this[p].length; J++) {
            const T = this[p][J];
            Y[T] = this[T];
          }
          return Y;
        }
        [a](Y) {
          Object.assign(this[x], Y), Object.assign(this[I], Y);
        }
        [e](...Y) {
          this[p].push(...Y);
        }
        [n](Y, J, T = !0) {
          const K = this[I][Y], R = this[h];
          return J == null && (J = this[x][Y]), Object(X.compareValue)(K, J) ? !1 : (this[I][Y] = J, this[c].has(Y) && this[c].delete(Y), this[c].add(Y), this[b] = Y, T && R.onPropertyChange(Y, J, K, this), !0);
        }
        [G](Y) {
          return this[I][Y];
        }
        set id(Y) {
          this[n]("id", Y);
        }
        get id() {
          return this[G]("id");
        }
        set name(Y) {
          this[n]("name", Y);
        }
        get name() {
          return this[G]("name");
        }
        set className(Y) {
          this[n]("className", Y);
        }
        get className() {
          return this[G]("className");
        }
        set class(Y) {
          this.className = Y;
        }
        get class() {
          return this.className;
        }
        get x() {
          return this[G]("x");
        }
        set x(Y) {
          this[n]("x", Object(X.toNumber)(Y));
        }
        get y() {
          return this[G]("y");
        }
        set y(Y) {
          this[n]("y", Object(X.toNumber)(Y));
        }
        get pos() {
          return [this.x, this.y];
        }
        set pos(Y) {
          Y = Object(X.toArray)(Y), Array.isArray(Y) || (Y = [Y, Y]), this.x = Y[0], this.y = Y[1];
        }
        get transform() {
          return this[G]("transform");
        }
        set transform(Y) {
          let J = null;
          if (Array.isArray(Y) && (J = Y, Y = `matrix(${Y.map(X.toNumber).join()})`), typeof Y == "string")
            Y = Y.replace(/\s*,\s*/g, ",");
          else if (Y != null)
            throw new TypeError("Invalid transform value.");
          const T = this[I].transform;
          if (this[n]("transform", Y, !1)) {
            const K = this[t];
            if (K.has("matrix") && K.delete("matrix"), J)
              K.set("matrix", J);
            else if (Y) {
              const R = Y.match(/(matrix|translate|rotate|scale|skew)\([^()]+\)/g);
              if (R) {
                let H = d.mat2d.fromValues(1, 0, 0, 1, 0, 0);
                for (let f = 0; f < R.length; f++) {
                  const O = R[f].match(/^(matrix|translate|rotate|scale|skew)\(([^()]+)\)/);
                  if (O) {
                    let [, q, k] = O;
                    q === "rotate" ? k = Math.PI * parseFloat(k) / 180 : k = k.trim().split(/[\s,]+/).map((Q) => Object(X.toNumber)(Q)), q === "matrix" ? H = d.mat2d.multiply(H, H, k) : q === "skew" ? H = d.mat2d.multiply(H, H, d.mat2d.fromValues(1, Math.tan(k[1]), Math.tan(k[0]), 1, 0, 0)) : d.mat2d[q](H, H, k), K.set("matrix", H);
                  }
                }
              } else
                throw new TypeError("Invalid transform value.");
            }
            this[V] = null, this[h].onPropertyChange("transform", Y, T, this);
          }
        }
        get transformOrigin() {
          return this[G]("transformOrigin");
        }
        set transformOrigin(Y) {
          Y = Object(X.toArray)(Y, !0), Y != null && !Array.isArray(Y) && (Y = [Y, Y]), this[n]("transformOrigin", Y) && (this[V] = null);
        }
        get rotate() {
          return this[G]("rotate");
        }
        set rotate(Y) {
          r(this, "rotate", Y);
        }
        get translate() {
          return this[G]("translate");
        }
        set translate(Y) {
          Y = Object(X.toArray)(Y, !0), Y != null && !Array.isArray(Y) && (Y = [Y, Y]), r(this, "translate", Y);
        }
        get scale() {
          return this[G]("scale");
        }
        set scale(Y) {
          Y = Object(X.toArray)(Y, !0), Y != null && !Array.isArray(Y) && (Y = [Y, Y]), r(this, "scale", Y);
        }
        get skew() {
          return this[G]("skew");
        }
        set skew(Y) {
          Y = Object(X.toArray)(Y, !0), Y != null && !Array.isArray(Y) && (Y = [Y, Y]), r(this, "skew", Y);
        }
        get opacity() {
          return this[G]("opacity");
        }
        set opacity(Y) {
          Y != null && (Y = Number(Y)), this[n]("opacity", Y);
        }
        get zIndex() {
          return this[G]("zIndex");
        }
        set zIndex(Y) {
          Y != null && (Y = Number(Y)), this[n]("zIndex", Y);
        }
        get offsetPath() {
          return this[G]("offsetPath");
        }
        set offsetPath(Y) {
          this[n]("offsetPath", Y) && (this[Z].beginPath(), Y != null && this[Z].addPath(Y), S(this));
        }
        get offsetDistance() {
          return this[G]("offsetDistance");
        }
        set offsetDistance(Y) {
          this[n]("offsetDistance", Object(X.toNumber)(Y)) && S(this);
        }
        get offsetRotate() {
          return this[G]("offsetRotate");
        }
        set offsetRotate(Y) {
          this[n]("offsetRotate", Y), S(this);
        }
        get pointerEvents() {
          return this[G]("pointerEvents");
        }
        set pointerEvents(Y) {
          if (Y != null && Y !== "none" && Y !== "visible" && Y !== "visibleFill" && Y !== "visibleStroke" && Y !== "all")
            throw new TypeError("Invalid pointerEvents type.");
          this[n]("pointerEvents", Y);
        }
        get filter() {
          return this[G]("filter");
        }
        set filter(Y) {
          this[n]("filter", Y);
        }
        get display() {
          return this[G]("display");
        }
        set display(Y) {
          this[n]("display", Y);
        }
        /* istanbul ignore next */
        set offset(Y) {
        }
      }
    },
    /* 72 */
    /***/
    function(m, l, i) {
      i.r(l), i.d(l, "sizeToPixel", function() {
        return d;
      }), i.d(l, "toString", function() {
        return s;
      }), i.d(l, "toNumber", function() {
        return X;
      }), i.d(l, "toArray", function() {
        return a;
      }), i.d(l, "compareValue", function() {
        return e;
      }), i(1).glMatrix.setMatrixArrayType(Array);
      function d(n, G) {
        const y = n.trim().match(/^([\d.]+)(px|pt|pc|in|cm|mm|em|ex|rem|q|vw|vh|vmax|vmin)$/);
        y ? n = {
          size: parseFloat(y[1]),
          unit: y[2]
        } : n = {
          size: parseFloat(n),
          unit: "px"
        };
        let {
          size: o,
          unit: h
        } = n;
        if (h === "pt")
          o /= 0.75;
        else if (h === "pc")
          o *= 16;
        else if (h === "in")
          o *= 96;
        else if (h === "cm")
          o *= 96 / 2.54;
        else if (h === "mm")
          o *= 96 / 25.4;
        else if (h === "em" || h === "rem" || h === "ex") {
          if (!G && typeof getComputedStyle == "function" && typeof document < "u") {
            const I = getComputedStyle(document.documentElement).fontSize;
            I ? G = d(I, 16) : G = 16;
          }
          o *= G, h === "ex" && (o /= 2);
        } else if (h === "q")
          o *= 96 / 25.4 / 4;
        else if (h === "vw" || h === "vh") {
          if (typeof document < "u") {
            const I = h === "vw" ? window.innerWidth || document.documentElement.clientWidth : window.innerHeight || document.documentElement.clientHeight;
            o *= I / 100;
          }
        } else if ((h === "vmax" || h === "vmin") && typeof document < "u") {
          const I = window.innerWidth || document.documentElement.clientWidth, x = window.innerHeight || document.documentElement.clientHeight;
          h === "vmax" ? o *= Math.max(I, x) / 100 : o *= Math.min(I, x) / 100;
        }
        return o;
      }
      function s(n) {
        return n == null ? n : String(n);
      }
      function X(n) {
        if (n == null)
          return n;
        if (typeof n == "string" && (n = d(n)), !Number.isFinite(n))
          throw new TypeError("Invalid value");
        return n;
      }
      function a(n, G = !1) {
        return n === "" ? null : (typeof n == "string" && (n = n.split(/[\s,]+/g)), Array.isArray(n) && (G && (n = n.map(X)), n.length === 1) ? n[0] : n);
      }
      function e(n, G) {
        if (Array.isArray(n) && Array.isArray(G)) {
          if (n.length !== G.length)
            return !1;
          for (let y = 0; y < n.length; y++)
            if (n[y] !== G[y])
              return !1;
          return !0;
        }
        return n == null && G == null || n === G;
      }
    },
    /* 73 */
    /***/
    function(m, l, i) {
      i.r(l), i.d(l, "default", function() {
        return h;
      });
      var d = i(74), s = i(32), X = /* @__PURE__ */ i.n(s), a = i(68), e = i(72);
      i(1).glMatrix.setMatrixArrayType(Array);
      function n() {
        return n = Object.assign || function(I) {
          for (var x = 1; x < arguments.length; x++) {
            var p = arguments[x];
            for (var W in p)
              Object.prototype.hasOwnProperty.call(p, W) && (I[W] = p[W]);
          }
          return I;
        }, n.apply(this, arguments);
      }
      function G(I) {
        if (typeof I == "string") {
          if (I = I.trim(), /^[0-9.]+%$/.test(I))
            return parseFloat(I) / 100;
          if (/^([\d.]+)(px|pt|pc|in|cm|mm|em|ex|rem|q|vw|vh|vmax|vmin)$/.test(I))
            return Object(e.sizeToPixel)(I);
        }
        return I;
      }
      function y(I, x, p, W, V) {
        return typeof I == "string" && (I = X()(I)), typeof x == "string" && (x = X()(x)), d.Effects.default(I, x, p, W, V);
      }
      function o(I, x, p, W, V) {
        return d.Effects.default(I, x, p, W, V);
      }
      d.Effects.default = function(I, x, p, W, V) {
        return Array.isArray(I) && Array.isArray(x) ? I.map((t, c) => t + (p - W) / (V - W) * (x[c] - t)) : typeof I == "number" && typeof x == "number" ? I + (p - W) / (V - W) * (x - I) : p - W > V - p ? x : I;
      }, d.Effects.fillColor = y, d.Effects.strokeColor = y, d.Effects.bgcolor = y, d.Effects.borderColor = y, d.Effects.text = o;
      class h extends d.Animator {
        constructor(x, p, W) {
          const V = x.attr();
          Object.entries(V).forEach(([t, c]) => {
            V[t] = d.Effects[t] ? c : G(c);
          }), p = p.map((t) => {
            let c = n({}, t);
            const b = {};
            return Object.entries(c).forEach(([Z, r]) => {
              b[Z] = d.Effects[Z] ? r : G(r);
            }), b;
          }), super(V, p, W), this.target = x, this.setter = function(t, c) {
            c.attr(t);
          };
        }
        get playState() {
          return this.target.parent ? super.playState : "idle";
        }
        get finished() {
          return super.finished.then(() => {
            const x = this;
            return new Promise((p) => {
              function W() {
                x.setter(x.frame, x.target);
                const V = x.playState;
                V === "finished" || V === "idle" ? (Object(a.cancelAnimationFrame)(x.requestId), p()) : Object(a.requestAnimationFrame)(W);
              }
              W();
            });
          });
        }
        finish() {
          super.finish(), Object(a.cancelAnimationFrame)(this.requestId), this.setter(this.frame, this.target);
        }
        play() {
          if (!this.target.parent || this.playState === "running")
            return;
          super.play(), this.setter(this.frame, this.target);
          const x = this;
          this.ready.then(() => {
            x.setter(x.frame, x.target), x.requestId = Object(a.requestAnimationFrame)(function p() {
              const W = x.target;
              if (typeof document < "u" && document.documentElement && document.documentElement.contains && W.layer && W.layer.canvas && !document.documentElement.contains(W.layer.canvas)) {
                x.cancel();
                return;
              }
              const V = x.playState;
              x.setter(x.frame, x.target), V !== "idle" && (V === "running" ? x.requestId = Object(a.requestAnimationFrame)(p) : (V === "paused" || V === "pending" && x.timeline.currentTime < 0) && x.ready.then(() => {
                x.setter(x.frame, x.target), x.requestId = Object(a.requestAnimationFrame)(p);
              }));
            });
          });
        }
        cancel(x = !1) {
          Object(a.cancelAnimationFrame)(this.requestId), x ? (this.setter(this.frame, this.target), super.cancel()) : (super.cancel(), this.setter(this.frame, this.target));
        }
      }
    },
    /* 74 */
    /***/
    function(m, l, i) {
      Object.defineProperty(l, "__esModule", {
        value: !0
      }), l.Timeline = l.Effects = l.Easings = l.Animator = void 0;
      var d = i(75), s = y(d), X = i(187), a = y(X), e = i(188), n = i(190), G = y(n);
      function y(o) {
        return o && o.__esModule ? o : { default: o };
      }
      l.Animator = G.default, l.Easings = e.Easings, l.Effects = a.default, l.Timeline = s.default;
    },
    /* 75 */
    /***/
    function(m, l, i) {
      Object.defineProperty(l, "__esModule", {
        value: !0
      });
      var d = i(76), s = t(d), X = i(133), a = t(X), e = i(141), n = t(e), G = i(164), y = t(G), o = i(170), h = t(o), I = i(171), x = t(I), p = i(175), W = t(p), V = i(186);
      function t(T) {
        return T && T.__esModule ? T : { default: T };
      }
      var c = (0, V.createNowTime)(), b = {
        originTime: 0,
        playbackRate: 1
      }, Z = (0, W.default)("timeMark"), r = (0, W.default)("playbackRate"), S = (0, W.default)("timers"), C = (0, W.default)("originTime"), F = (0, W.default)("setTimer"), Y = (0, W.default)("parent"), J = function() {
        function T(K, R) {
          (0, h.default)(this, T), K instanceof T && (R = K, K = {}), K = (0, y.default)({}, b, K), R && (this[Y] = R);
          var H = K.nowtime || c;
          if (R)
            Object.defineProperty(this, "globalTime", {
              get: function() {
                return R.currentTime;
              }
            });
          else {
            var f = H();
            Object.defineProperty(this, "globalTime", {
              get: function() {
                return H() - f;
              }
            });
          }
          this[Z] = [{
            globalTime: this.globalTime,
            localTime: -K.originTime,
            entropy: -K.originTime,
            playbackRate: K.playbackRate,
            globalEntropy: 0
          }], this[Y] && (this[Z][0].globalEntropy = this[Y].entropy), this[C] = K.originTime, this[r] = K.playbackRate, this[S] = new n.default();
        }
        return (0, x.default)(T, [{
          key: "markTime",
          value: function() {
            var R = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, H = R.time, f = H === void 0 ? this.currentTime : H, w = R.entropy, O = w === void 0 ? this.entropy : w, q = R.playbackRate, k = q === void 0 ? this.playbackRate : q, Q = {
              globalTime: this.globalTime,
              localTime: f,
              entropy: O,
              playbackRate: k,
              globalEntropy: this.globalEntropy
            };
            this[Z].push(Q);
          }
        }, {
          key: "fork",
          value: function(R) {
            return new T(R, this);
          }
        }, {
          key: "seekGlobalTime",
          value: function(R) {
            var H = this.seekTimeMark(R), f = this[Z][H], w = f.entropy, O = f.playbackRate, q = f.globalTime;
            return q + (R - w) / Math.abs(O);
          }
        }, {
          key: "seekLocalTime",
          value: function(R) {
            var H = this.seekTimeMark(R), f = this[Z][H], w = f.localTime, O = f.entropy, q = f.playbackRate;
            return q > 0 ? w + (R - O) : w - (R - O);
          }
        }, {
          key: "seekTimeMark",
          value: function(R) {
            var H = this[Z], f = 0, w = H.length - 1;
            if (R <= H[f].entropy)
              return f;
            if (R >= H[w].entropy)
              return w;
            for (var O = Math.floor((f + w) / 2); O > f && O < w; ) {
              if (R === H[O].entropy)
                return O;
              R < H[O].entropy ? w = O : R > H[O].entropy && (f = O), O = Math.floor((f + w) / 2);
            }
            return f;
          }
        }, {
          key: "updateTimers",
          value: function() {
            var R = this, H = [].concat((0, a.default)(this[S]));
            H.forEach(function(f) {
              var w = (0, s.default)(f, 2), O = w[0], q = w[1];
              R[F](q.handler, q.time, O);
            });
          }
        }, {
          key: "clearTimeout",
          value: function(K) {
            function R(H) {
              return K.apply(this, arguments);
            }
            return R.toString = function() {
              return K.toString();
            }, R;
          }(function(K) {
            var R = this[S].get(K);
            R && R.timerID != null && (this[Y] ? this[Y].clearTimeout(R.timerID) : clearTimeout(R.timerID)), this[S].delete(K);
          })
        }, {
          key: "clearInterval",
          value: function(R) {
            return this.clearTimeout(R);
          }
        }, {
          key: "clear",
          value: function() {
            var R = this, H = this[S];
            [].concat((0, a.default)(H.keys())).forEach(function(f) {
              R.clearTimeout(f);
            });
          }
          /*
            setTimeout(func, {delay: 100, isEntropy: true})
            setTimeout(func, {entropy: 100})
            setTimeout(func, 100})
           */
        }, {
          key: "setTimeout",
          value: function(R) {
            var H = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : { delay: 0 };
            return this[F](R, H);
          }
        }, {
          key: "setInterval",
          value: function(R) {
            var H = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : { delay: 0 }, f = this, w = this[F](function O() {
              f[F](O, H, w), R();
            }, H);
            return w;
          }
        }, {
          key: F,
          value: function(R, H) {
            var f = this, w = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : (0, W.default)("timerID");
            H = (0, V.formatDelay)(H);
            var O = this[S].get(w), q = void 0, k = null, Q = void 0, D = void 0;
            O ? (this.clearTimeout(w), H.isEntropy ? q = (H.delay - (this.entropy - O.startEntropy)) / Math.abs(this.playbackRate) : q = (H.delay - (this.currentTime - O.startTime)) / this.playbackRate, Q = O.startTime, D = O.startEntropy) : (q = H.delay / (H.isEntropy ? Math.abs(this.playbackRate) : this.playbackRate), Q = this.currentTime, D = this.entropy);
            var ii = this[Y], _ = ii ? ii.setTimeout.bind(ii) : setTimeout, bi = H.heading;
            return !ii && bi === !1 && q < 0 && (q = 1 / 0), (isFinite(q) || ii) && (q = Math.ceil(q), _ !== setTimeout && (q = { delay: q, heading: bi }), k = _(function() {
              f[S].delete(w), R();
            }, q)), this[S].set(w, {
              timerID: k,
              handler: R,
              time: H,
              startTime: Q,
              startEntropy: D
            }), w;
          }
        }, {
          key: "parent",
          get: function() {
            return this[Y];
          }
        }, {
          key: "lastTimeMark",
          get: function() {
            return this[Z][this[Z].length - 1];
          }
        }, {
          key: "currentTime",
          get: function() {
            var R = this.lastTimeMark, H = R.localTime, f = R.globalTime;
            return H + (this.globalTime - f) * this.playbackRate;
          },
          set: function(R) {
            var H = this, f = this.currentTime, w = R, O = this[S];
            this.markTime({ time: R }), [].concat((0, a.default)(O)).forEach(function(q) {
              var k = (0, s.default)(q, 2), Q = k[0], D = k[1];
              if (O.has(Q)) {
                var ii = D.time, _ = ii.isEntropy, bi = ii.delay, $ = ii.heading, Xi = D.handler, ni = D.startTime;
                if (_)
                  bi === 0 && (Xi(), H.clearTimeout(Q));
                else {
                  var M = ni + bi;
                  (bi === 0 || $ !== !1 && (w - f) * bi <= 0 || f <= M && M <= w || f >= M && M >= w) && (Xi(), H.clearTimeout(Q));
                }
              }
            }), this.updateTimers();
          }
          // Both currentTime and entropy should be influenced by playbackRate.
          // If current playbackRate is negative, the currentTime should go backwards
          // while the entropy remain to go forwards.
          // Both of the initial values is set to -originTime
        }, {
          key: "entropy",
          get: function() {
            var R = this.lastTimeMark, H = R.entropy, f = R.globalEntropy;
            return H + Math.abs((this.globalEntropy - f) * this.playbackRate);
          },
          // get globalTime() {
          //   if(this[_parent]) {
          //     return this[_parent].currentTime;
          //   }
          //   return nowtime();
          // }
          // change entropy will NOT cause currentTime changing but may influence the pass
          // and the future of the timeline. (It may change the result of seek***Time)
          // While entropy is set, all the marks behind will be droped
          set: function(R) {
            if (this.entropy > R) {
              var H = this.seekTimeMark(R);
              this[Z].length = H + 1;
            }
            this.markTime({ entropy: R }), this.updateTimers();
          }
        }, {
          key: "globalEntropy",
          get: function() {
            return this[Y] ? this[Y].entropy : this.globalTime;
          }
        }, {
          key: "playbackRate",
          get: function() {
            return this[r];
          },
          set: function(R) {
            R !== this.playbackRate && (this.markTime({ playbackRate: R }), this[r] = R, this.updateTimers());
          }
        }, {
          key: "paused",
          get: function() {
            if (this.playbackRate === 0)
              return !0;
            for (var R = this.parent; R; ) {
              if (R.playbackRate === 0)
                return !0;
              R = R.parent;
            }
            return !1;
          }
        }]), T;
      }();
      l.default = J;
    },
    /* 76 */
    /***/
    function(m, l, i) {
      l.__esModule = !0;
      var d = i(77), s = e(d), X = i(129), a = e(X);
      function e(n) {
        return n && n.__esModule ? n : { default: n };
      }
      l.default = /* @__PURE__ */ function() {
        function n(G, y) {
          var o = [], h = !0, I = !1, x = void 0;
          try {
            for (var p = (0, a.default)(G), W; !(h = (W = p.next()).done) && (o.push(W.value), !(y && o.length === y)); h = !0)
              ;
          } catch (V) {
            I = !0, x = V;
          } finally {
            try {
              !h && p.return && p.return();
            } finally {
              if (I)
                throw x;
            }
          }
          return o;
        }
        return function(G, y) {
          if (Array.isArray(G))
            return G;
          if ((0, s.default)(Object(G)))
            return n(G, y);
          throw new TypeError("Invalid attempt to destructure non-iterable instance");
        };
      }();
    },
    /* 77 */
    /***/
    function(m, l, i) {
      m.exports = { default: i(78), __esModule: !0 };
    },
    /* 78 */
    /***/
    function(m, l, i) {
      i(79), i(125), m.exports = i(127);
    },
    /* 79 */
    /***/
    function(m, l, i) {
      i(80);
      for (var d = i(91), s = i(95), X = i(83), a = i(122)("toStringTag"), e = "CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,TextTrackList,TouchList".split(","), n = 0; n < e.length; n++) {
        var G = e[n], y = d[G], o = y && y.prototype;
        o && !o[a] && s(o, a, G), X[G] = X.Array;
      }
    },
    /* 80 */
    /***/
    function(m, l, i) {
      var d = i(81), s = i(82), X = i(83), a = i(84);
      m.exports = i(88)(Array, "Array", function(e, n) {
        this._t = a(e), this._i = 0, this._k = n;
      }, function() {
        var e = this._t, n = this._k, G = this._i++;
        return !e || G >= e.length ? (this._t = void 0, s(1)) : n == "keys" ? s(0, G) : n == "values" ? s(0, e[G]) : s(0, [G, e[G]]);
      }, "values"), X.Arguments = X.Array, d("keys"), d("values"), d("entries");
    },
    /* 81 */
    /***/
    function(m, l) {
      m.exports = function() {
      };
    },
    /* 82 */
    /***/
    function(m, l) {
      m.exports = function(i, d) {
        return { value: d, done: !!i };
      };
    },
    /* 83 */
    /***/
    function(m, l) {
      m.exports = {};
    },
    /* 84 */
    /***/
    function(m, l, i) {
      var d = i(85), s = i(87);
      m.exports = function(X) {
        return d(s(X));
      };
    },
    /* 85 */
    /***/
    function(m, l, i) {
      var d = i(86);
      m.exports = Object("z").propertyIsEnumerable(0) ? Object : function(s) {
        return d(s) == "String" ? s.split("") : Object(s);
      };
    },
    /* 86 */
    /***/
    function(m, l) {
      var i = {}.toString;
      m.exports = function(d) {
        return i.call(d).slice(8, -1);
      };
    },
    /* 87 */
    /***/
    function(m, l) {
      m.exports = function(i) {
        if (i == null)
          throw TypeError("Can't call method on  " + i);
        return i;
      };
    },
    /* 88 */
    /***/
    function(m, l, i) {
      var d = i(89), s = i(90), X = i(106), a = i(95), e = i(83), n = i(107), G = i(121), y = i(123), o = i(122)("iterator"), h = !([].keys && "next" in [].keys()), I = "@@iterator", x = "keys", p = "values", W = function() {
        return this;
      };
      m.exports = function(V, t, c, b, Z, r, S) {
        n(c, t, b);
        var C = function(k) {
          if (!h && k in T)
            return T[k];
          switch (k) {
            case x:
              return function() {
                return new c(this, k);
              };
            case p:
              return function() {
                return new c(this, k);
              };
          }
          return function() {
            return new c(this, k);
          };
        }, F = t + " Iterator", Y = Z == p, J = !1, T = V.prototype, K = T[o] || T[I] || Z && T[Z], R = K || C(Z), H = Z ? Y ? C("entries") : R : void 0, f = t == "Array" && T.entries || K, w, O, q;
        if (f && (q = y(f.call(new V())), q !== Object.prototype && q.next && (G(q, F, !0), !d && typeof q[o] != "function" && a(q, o, W))), Y && K && K.name !== p && (J = !0, R = function() {
          return K.call(this);
        }), (!d || S) && (h || J || !T[o]) && a(T, o, R), e[t] = R, e[F] = W, Z)
          if (w = {
            values: Y ? R : C(p),
            keys: r ? R : C(x),
            entries: H
          }, S)
            for (O in w)
              O in T || X(T, O, w[O]);
          else
            s(s.P + s.F * (h || J), t, w);
        return w;
      };
    },
    /* 89 */
    /***/
    function(m, l) {
      m.exports = !0;
    },
    /* 90 */
    /***/
    function(m, l, i) {
      var d = i(91), s = i(92), X = i(93), a = i(95), e = i(105), n = "prototype", G = function(y, o, h) {
        var I = y & G.F, x = y & G.G, p = y & G.S, W = y & G.P, V = y & G.B, t = y & G.W, c = x ? s : s[o] || (s[o] = {}), b = c[n], Z = x ? d : p ? d[o] : (d[o] || {})[n], r, S, C;
        x && (h = o);
        for (r in h)
          S = !I && Z && Z[r] !== void 0, !(S && e(c, r)) && (C = S ? Z[r] : h[r], c[r] = x && typeof Z[r] != "function" ? h[r] : V && S ? X(C, d) : t && Z[r] == C ? function(F) {
            var Y = function(J, T, K) {
              if (this instanceof F) {
                switch (arguments.length) {
                  case 0:
                    return new F();
                  case 1:
                    return new F(J);
                  case 2:
                    return new F(J, T);
                }
                return new F(J, T, K);
              }
              return F.apply(this, arguments);
            };
            return Y[n] = F[n], Y;
          }(C) : W && typeof C == "function" ? X(Function.call, C) : C, W && ((c.virtual || (c.virtual = {}))[r] = C, y & G.R && b && !b[r] && a(b, r, C)));
      };
      G.F = 1, G.G = 2, G.S = 4, G.P = 8, G.B = 16, G.W = 32, G.U = 64, G.R = 128, m.exports = G;
    },
    /* 91 */
    /***/
    function(m, l) {
      var i = m.exports = typeof window < "u" && window.Math == Math ? window : typeof self < "u" && self.Math == Math ? self : Function("return this")();
      typeof __g == "number" && (__g = i);
    },
    /* 92 */
    /***/
    function(m, l) {
      var i = m.exports = { version: "2.6.11" };
      typeof __e == "number" && (__e = i);
    },
    /* 93 */
    /***/
    function(m, l, i) {
      var d = i(94);
      m.exports = function(s, X, a) {
        if (d(s), X === void 0)
          return s;
        switch (a) {
          case 1:
            return function(e) {
              return s.call(X, e);
            };
          case 2:
            return function(e, n) {
              return s.call(X, e, n);
            };
          case 3:
            return function(e, n, G) {
              return s.call(X, e, n, G);
            };
        }
        return function() {
          return s.apply(X, arguments);
        };
      };
    },
    /* 94 */
    /***/
    function(m, l) {
      m.exports = function(i) {
        if (typeof i != "function")
          throw TypeError(i + " is not a function!");
        return i;
      };
    },
    /* 95 */
    /***/
    function(m, l, i) {
      var d = i(96), s = i(104);
      m.exports = i(100) ? function(X, a, e) {
        return d.f(X, a, s(1, e));
      } : function(X, a, e) {
        return X[a] = e, X;
      };
    },
    /* 96 */
    /***/
    function(m, l, i) {
      var d = i(97), s = i(99), X = i(103), a = Object.defineProperty;
      l.f = i(100) ? Object.defineProperty : function(n, G, y) {
        if (d(n), G = X(G, !0), d(y), s)
          try {
            return a(n, G, y);
          } catch {
          }
        if ("get" in y || "set" in y)
          throw TypeError("Accessors not supported!");
        return "value" in y && (n[G] = y.value), n;
      };
    },
    /* 97 */
    /***/
    function(m, l, i) {
      var d = i(98);
      m.exports = function(s) {
        if (!d(s))
          throw TypeError(s + " is not an object!");
        return s;
      };
    },
    /* 98 */
    /***/
    function(m, l) {
      m.exports = function(i) {
        return typeof i == "object" ? i !== null : typeof i == "function";
      };
    },
    /* 99 */
    /***/
    function(m, l, i) {
      m.exports = !i(100) && !i(101)(function() {
        return Object.defineProperty(i(102)("div"), "a", { get: function() {
          return 7;
        } }).a != 7;
      });
    },
    /* 100 */
    /***/
    function(m, l, i) {
      m.exports = !i(101)(function() {
        return Object.defineProperty({}, "a", { get: function() {
          return 7;
        } }).a != 7;
      });
    },
    /* 101 */
    /***/
    function(m, l) {
      m.exports = function(i) {
        try {
          return !!i();
        } catch {
          return !0;
        }
      };
    },
    /* 102 */
    /***/
    function(m, l, i) {
      var d = i(98), s = i(91).document, X = d(s) && d(s.createElement);
      m.exports = function(a) {
        return X ? s.createElement(a) : {};
      };
    },
    /* 103 */
    /***/
    function(m, l, i) {
      var d = i(98);
      m.exports = function(s, X) {
        if (!d(s))
          return s;
        var a, e;
        if (X && typeof (a = s.toString) == "function" && !d(e = a.call(s)) || typeof (a = s.valueOf) == "function" && !d(e = a.call(s)) || !X && typeof (a = s.toString) == "function" && !d(e = a.call(s)))
          return e;
        throw TypeError("Can't convert object to primitive value");
      };
    },
    /* 104 */
    /***/
    function(m, l) {
      m.exports = function(i, d) {
        return {
          enumerable: !(i & 1),
          configurable: !(i & 2),
          writable: !(i & 4),
          value: d
        };
      };
    },
    /* 105 */
    /***/
    function(m, l) {
      var i = {}.hasOwnProperty;
      m.exports = function(d, s) {
        return i.call(d, s);
      };
    },
    /* 106 */
    /***/
    function(m, l, i) {
      m.exports = i(95);
    },
    /* 107 */
    /***/
    function(m, l, i) {
      var d = i(108), s = i(104), X = i(121), a = {};
      i(95)(a, i(122)("iterator"), function() {
        return this;
      }), m.exports = function(e, n, G) {
        e.prototype = d(a, { next: s(1, G) }), X(e, n + " Iterator");
      };
    },
    /* 108 */
    /***/
    function(m, l, i) {
      var d = i(97), s = i(109), X = i(119), a = i(116)("IE_PROTO"), e = function() {
      }, n = "prototype", G = function() {
        var y = i(102)("iframe"), o = X.length, h = "<", I = ">", x;
        for (y.style.display = "none", i(120).appendChild(y), y.src = "javascript:", x = y.contentWindow.document, x.open(), x.write(h + "script" + I + "document.F=Object" + h + "/script" + I), x.close(), G = x.F; o--; )
          delete G[n][X[o]];
        return G();
      };
      m.exports = Object.create || function(o, h) {
        var I;
        return o !== null ? (e[n] = d(o), I = new e(), e[n] = null, I[a] = o) : I = G(), h === void 0 ? I : s(I, h);
      };
    },
    /* 109 */
    /***/
    function(m, l, i) {
      var d = i(96), s = i(97), X = i(110);
      m.exports = i(100) ? Object.defineProperties : function(e, n) {
        s(e);
        for (var G = X(n), y = G.length, o = 0, h; y > o; )
          d.f(e, h = G[o++], n[h]);
        return e;
      };
    },
    /* 110 */
    /***/
    function(m, l, i) {
      var d = i(111), s = i(119);
      m.exports = Object.keys || function(a) {
        return d(a, s);
      };
    },
    /* 111 */
    /***/
    function(m, l, i) {
      var d = i(105), s = i(84), X = i(112)(!1), a = i(116)("IE_PROTO");
      m.exports = function(e, n) {
        var G = s(e), y = 0, o = [], h;
        for (h in G)
          h != a && d(G, h) && o.push(h);
        for (; n.length > y; )
          d(G, h = n[y++]) && (~X(o, h) || o.push(h));
        return o;
      };
    },
    /* 112 */
    /***/
    function(m, l, i) {
      var d = i(84), s = i(113), X = i(115);
      m.exports = function(a) {
        return function(e, n, G) {
          var y = d(e), o = s(y.length), h = X(G, o), I;
          if (a && n != n) {
            for (; o > h; )
              if (I = y[h++], I != I)
                return !0;
          } else
            for (; o > h; h++)
              if ((a || h in y) && y[h] === n)
                return a || h || 0;
          return !a && -1;
        };
      };
    },
    /* 113 */
    /***/
    function(m, l, i) {
      var d = i(114), s = Math.min;
      m.exports = function(X) {
        return X > 0 ? s(d(X), 9007199254740991) : 0;
      };
    },
    /* 114 */
    /***/
    function(m, l) {
      var i = Math.ceil, d = Math.floor;
      m.exports = function(s) {
        return isNaN(s = +s) ? 0 : (s > 0 ? d : i)(s);
      };
    },
    /* 115 */
    /***/
    function(m, l, i) {
      var d = i(114), s = Math.max, X = Math.min;
      m.exports = function(a, e) {
        return a = d(a), a < 0 ? s(a + e, 0) : X(a, e);
      };
    },
    /* 116 */
    /***/
    function(m, l, i) {
      var d = i(117)("keys"), s = i(118);
      m.exports = function(X) {
        return d[X] || (d[X] = s(X));
      };
    },
    /* 117 */
    /***/
    function(m, l, i) {
      var d = i(92), s = i(91), X = "__core-js_shared__", a = s[X] || (s[X] = {});
      (m.exports = function(e, n) {
        return a[e] || (a[e] = n !== void 0 ? n : {});
      })("versions", []).push({
        version: d.version,
        mode: i(89) ? "pure" : "global",
        copyright: "© 2019 Denis Pushkarev (zloirock.ru)"
      });
    },
    /* 118 */
    /***/
    function(m, l) {
      var i = 0, d = Math.random();
      m.exports = function(s) {
        return "Symbol(".concat(s === void 0 ? "" : s, ")_", (++i + d).toString(36));
      };
    },
    /* 119 */
    /***/
    function(m, l) {
      m.exports = "constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",");
    },
    /* 120 */
    /***/
    function(m, l, i) {
      var d = i(91).document;
      m.exports = d && d.documentElement;
    },
    /* 121 */
    /***/
    function(m, l, i) {
      var d = i(96).f, s = i(105), X = i(122)("toStringTag");
      m.exports = function(a, e, n) {
        a && !s(a = n ? a : a.prototype, X) && d(a, X, { configurable: !0, value: e });
      };
    },
    /* 122 */
    /***/
    function(m, l, i) {
      var d = i(117)("wks"), s = i(118), X = i(91).Symbol, a = typeof X == "function", e = m.exports = function(n) {
        return d[n] || (d[n] = a && X[n] || (a ? X : s)("Symbol." + n));
      };
      e.store = d;
    },
    /* 123 */
    /***/
    function(m, l, i) {
      var d = i(105), s = i(124), X = i(116)("IE_PROTO"), a = Object.prototype;
      m.exports = Object.getPrototypeOf || function(e) {
        return e = s(e), d(e, X) ? e[X] : typeof e.constructor == "function" && e instanceof e.constructor ? e.constructor.prototype : e instanceof Object ? a : null;
      };
    },
    /* 124 */
    /***/
    function(m, l, i) {
      var d = i(87);
      m.exports = function(s) {
        return Object(d(s));
      };
    },
    /* 125 */
    /***/
    function(m, l, i) {
      var d = i(126)(!0);
      i(88)(String, "String", function(s) {
        this._t = String(s), this._i = 0;
      }, function() {
        var s = this._t, X = this._i, a;
        return X >= s.length ? { value: void 0, done: !0 } : (a = d(s, X), this._i += a.length, { value: a, done: !1 });
      });
    },
    /* 126 */
    /***/
    function(m, l, i) {
      var d = i(114), s = i(87);
      m.exports = function(X) {
        return function(a, e) {
          var n = String(s(a)), G = d(e), y = n.length, o, h;
          return G < 0 || G >= y ? X ? "" : void 0 : (o = n.charCodeAt(G), o < 55296 || o > 56319 || G + 1 === y || (h = n.charCodeAt(G + 1)) < 56320 || h > 57343 ? X ? n.charAt(G) : o : X ? n.slice(G, G + 2) : (o - 55296 << 10) + (h - 56320) + 65536);
        };
      };
    },
    /* 127 */
    /***/
    function(m, l, i) {
      var d = i(128), s = i(122)("iterator"), X = i(83);
      m.exports = i(92).isIterable = function(a) {
        var e = Object(a);
        return e[s] !== void 0 || "@@iterator" in e || X.hasOwnProperty(d(e));
      };
    },
    /* 128 */
    /***/
    function(m, l, i) {
      var d = i(86), s = i(122)("toStringTag"), X = d(/* @__PURE__ */ function() {
        return arguments;
      }()) == "Arguments", a = function(e, n) {
        try {
          return e[n];
        } catch {
        }
      };
      m.exports = function(e) {
        var n, G, y;
        return e === void 0 ? "Undefined" : e === null ? "Null" : typeof (G = a(n = Object(e), s)) == "string" ? G : X ? d(n) : (y = d(n)) == "Object" && typeof n.callee == "function" ? "Arguments" : y;
      };
    },
    /* 129 */
    /***/
    function(m, l, i) {
      m.exports = { default: i(130), __esModule: !0 };
    },
    /* 130 */
    /***/
    function(m, l, i) {
      i(79), i(125), m.exports = i(131);
    },
    /* 131 */
    /***/
    function(m, l, i) {
      var d = i(97), s = i(132);
      m.exports = i(92).getIterator = function(X) {
        var a = s(X);
        if (typeof a != "function")
          throw TypeError(X + " is not iterable!");
        return d(a.call(X));
      };
    },
    /* 132 */
    /***/
    function(m, l, i) {
      var d = i(128), s = i(122)("iterator"), X = i(83);
      m.exports = i(92).getIteratorMethod = function(a) {
        if (a != null)
          return a[s] || a["@@iterator"] || X[d(a)];
      };
    },
    /* 133 */
    /***/
    function(m, l, i) {
      l.__esModule = !0;
      var d = i(134), s = X(d);
      function X(a) {
        return a && a.__esModule ? a : { default: a };
      }
      l.default = function(a) {
        if (Array.isArray(a)) {
          for (var e = 0, n = Array(a.length); e < a.length; e++)
            n[e] = a[e];
          return n;
        } else
          return (0, s.default)(a);
      };
    },
    /* 134 */
    /***/
    function(m, l, i) {
      m.exports = { default: i(135), __esModule: !0 };
    },
    /* 135 */
    /***/
    function(m, l, i) {
      i(125), i(136), m.exports = i(92).Array.from;
    },
    /* 136 */
    /***/
    function(m, l, i) {
      var d = i(93), s = i(90), X = i(124), a = i(137), e = i(138), n = i(113), G = i(139), y = i(132);
      s(s.S + s.F * !i(140)(function(o) {
        Array.from(o);
      }), "Array", {
        // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
        from: function(h) {
          var I = X(h), x = typeof this == "function" ? this : Array, p = arguments.length, W = p > 1 ? arguments[1] : void 0, V = W !== void 0, t = 0, c = y(I), b, Z, r, S;
          if (V && (W = d(W, p > 2 ? arguments[2] : void 0, 2)), c != null && !(x == Array && e(c)))
            for (S = c.call(I), Z = new x(); !(r = S.next()).done; t++)
              G(Z, t, V ? a(S, W, [r.value, t], !0) : r.value);
          else
            for (b = n(I.length), Z = new x(b); b > t; t++)
              G(Z, t, V ? W(I[t], t) : I[t]);
          return Z.length = t, Z;
        }
      });
    },
    /* 137 */
    /***/
    function(m, l, i) {
      var d = i(97);
      m.exports = function(s, X, a, e) {
        try {
          return e ? X(d(a)[0], a[1]) : X(a);
        } catch (G) {
          var n = s.return;
          throw n !== void 0 && d(n.call(s)), G;
        }
      };
    },
    /* 138 */
    /***/
    function(m, l, i) {
      var d = i(83), s = i(122)("iterator"), X = Array.prototype;
      m.exports = function(a) {
        return a !== void 0 && (d.Array === a || X[s] === a);
      };
    },
    /* 139 */
    /***/
    function(m, l, i) {
      var d = i(96), s = i(104);
      m.exports = function(X, a, e) {
        a in X ? d.f(X, a, s(0, e)) : X[a] = e;
      };
    },
    /* 140 */
    /***/
    function(m, l, i) {
      var d = i(122)("iterator"), s = !1;
      try {
        var X = [7][d]();
        X.return = function() {
          s = !0;
        }, Array.from(X, function() {
          throw 2;
        });
      } catch {
      }
      m.exports = function(a, e) {
        if (!e && !s)
          return !1;
        var n = !1;
        try {
          var G = [7], y = G[d]();
          y.next = function() {
            return { done: n = !0 };
          }, G[d] = function() {
            return y;
          }, a(G);
        } catch {
        }
        return n;
      };
    },
    /* 141 */
    /***/
    function(m, l, i) {
      m.exports = { default: i(142), __esModule: !0 };
    },
    /* 142 */
    /***/
    function(m, l, i) {
      i(143), i(125), i(79), i(144), i(157), i(160), i(162), m.exports = i(92).Map;
    },
    /* 143 */
    /***/
    function(m, l) {
    },
    /* 144 */
    /***/
    function(m, l, i) {
      var d = i(145), s = i(151), X = "Map";
      m.exports = i(152)(X, function(a) {
        return function() {
          return a(this, arguments.length > 0 ? arguments[0] : void 0);
        };
      }, {
        // 23.1.3.6 Map.prototype.get(key)
        get: function(e) {
          var n = d.getEntry(s(this, X), e);
          return n && n.v;
        },
        // 23.1.3.9 Map.prototype.set(key, value)
        set: function(e, n) {
          return d.def(s(this, X), e === 0 ? 0 : e, n);
        }
      }, d, !0);
    },
    /* 145 */
    /***/
    function(m, l, i) {
      var d = i(96).f, s = i(108), X = i(146), a = i(93), e = i(147), n = i(148), G = i(88), y = i(82), o = i(149), h = i(100), I = i(150).fastKey, x = i(151), p = h ? "_s" : "size", W = function(V, t) {
        var c = I(t), b;
        if (c !== "F")
          return V._i[c];
        for (b = V._f; b; b = b.n)
          if (b.k == t)
            return b;
      };
      m.exports = {
        getConstructor: function(V, t, c, b) {
          var Z = V(function(r, S) {
            e(r, Z, t, "_i"), r._t = t, r._i = s(null), r._f = void 0, r._l = void 0, r[p] = 0, S != null && n(S, c, r[b], r);
          });
          return X(Z.prototype, {
            // 23.1.3.1 Map.prototype.clear()
            // 23.2.3.2 Set.prototype.clear()
            clear: function() {
              for (var S = x(this, t), C = S._i, F = S._f; F; F = F.n)
                F.r = !0, F.p && (F.p = F.p.n = void 0), delete C[F.i];
              S._f = S._l = void 0, S[p] = 0;
            },
            // 23.1.3.3 Map.prototype.delete(key)
            // 23.2.3.4 Set.prototype.delete(value)
            delete: function(r) {
              var S = x(this, t), C = W(S, r);
              if (C) {
                var F = C.n, Y = C.p;
                delete S._i[C.i], C.r = !0, Y && (Y.n = F), F && (F.p = Y), S._f == C && (S._f = F), S._l == C && (S._l = Y), S[p]--;
              }
              return !!C;
            },
            // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
            // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
            forEach: function(S) {
              x(this, t);
              for (var C = a(S, arguments.length > 1 ? arguments[1] : void 0, 3), F; F = F ? F.n : this._f; )
                for (C(F.v, F.k, this); F && F.r; )
                  F = F.p;
            },
            // 23.1.3.7 Map.prototype.has(key)
            // 23.2.3.7 Set.prototype.has(value)
            has: function(S) {
              return !!W(x(this, t), S);
            }
          }), h && d(Z.prototype, "size", {
            get: function() {
              return x(this, t)[p];
            }
          }), Z;
        },
        def: function(V, t, c) {
          var b = W(V, t), Z, r;
          return b ? b.v = c : (V._l = b = {
            i: r = I(t, !0),
            // <- index
            k: t,
            // <- key
            v: c,
            // <- value
            p: Z = V._l,
            // <- previous entry
            n: void 0,
            // <- next entry
            r: !1
            // <- removed
          }, V._f || (V._f = b), Z && (Z.n = b), V[p]++, r !== "F" && (V._i[r] = b)), V;
        },
        getEntry: W,
        setStrong: function(V, t, c) {
          G(V, t, function(b, Z) {
            this._t = x(b, t), this._k = Z, this._l = void 0;
          }, function() {
            for (var b = this, Z = b._k, r = b._l; r && r.r; )
              r = r.p;
            return !b._t || !(b._l = r = r ? r.n : b._t._f) ? (b._t = void 0, y(1)) : Z == "keys" ? y(0, r.k) : Z == "values" ? y(0, r.v) : y(0, [r.k, r.v]);
          }, c ? "entries" : "values", !c, !0), o(t);
        }
      };
    },
    /* 146 */
    /***/
    function(m, l, i) {
      var d = i(95);
      m.exports = function(s, X, a) {
        for (var e in X)
          a && s[e] ? s[e] = X[e] : d(s, e, X[e]);
        return s;
      };
    },
    /* 147 */
    /***/
    function(m, l) {
      m.exports = function(i, d, s, X) {
        if (!(i instanceof d) || X !== void 0 && X in i)
          throw TypeError(s + ": incorrect invocation!");
        return i;
      };
    },
    /* 148 */
    /***/
    function(m, o, i) {
      var d = i(93), s = i(137), X = i(138), a = i(97), e = i(113), n = i(132), G = {}, y = {}, o = m.exports = function(h, I, x, p, W) {
        var V = W ? function() {
          return h;
        } : n(h), t = d(x, p, I ? 2 : 1), c = 0, b, Z, r, S;
        if (typeof V != "function")
          throw TypeError(h + " is not iterable!");
        if (X(V)) {
          for (b = e(h.length); b > c; c++)
            if (S = I ? t(a(Z = h[c])[0], Z[1]) : t(h[c]), S === G || S === y)
              return S;
        } else
          for (r = V.call(h); !(Z = r.next()).done; )
            if (S = s(r, t, Z.value, I), S === G || S === y)
              return S;
      };
      o.BREAK = G, o.RETURN = y;
    },
    /* 149 */
    /***/
    function(m, l, i) {
      var d = i(91), s = i(92), X = i(96), a = i(100), e = i(122)("species");
      m.exports = function(n) {
        var G = typeof s[n] == "function" ? s[n] : d[n];
        a && G && !G[e] && X.f(G, e, {
          configurable: !0,
          get: function() {
            return this;
          }
        });
      };
    },
    /* 150 */
    /***/
    function(m, l, i) {
      var d = i(118)("meta"), s = i(98), X = i(105), a = i(96).f, e = 0, n = Object.isExtensible || function() {
        return !0;
      }, G = !i(101)(function() {
        return n(Object.preventExtensions({}));
      }), y = function(p) {
        a(p, d, { value: {
          i: "O" + ++e,
          // object ID
          w: {}
          // weak collections IDs
        } });
      }, o = function(p, W) {
        if (!s(p))
          return typeof p == "symbol" ? p : (typeof p == "string" ? "S" : "P") + p;
        if (!X(p, d)) {
          if (!n(p))
            return "F";
          if (!W)
            return "E";
          y(p);
        }
        return p[d].i;
      }, h = function(p, W) {
        if (!X(p, d)) {
          if (!n(p))
            return !0;
          if (!W)
            return !1;
          y(p);
        }
        return p[d].w;
      }, I = function(p) {
        return G && x.NEED && n(p) && !X(p, d) && y(p), p;
      }, x = m.exports = {
        KEY: d,
        NEED: !1,
        fastKey: o,
        getWeak: h,
        onFreeze: I
      };
    },
    /* 151 */
    /***/
    function(m, l, i) {
      var d = i(98);
      m.exports = function(s, X) {
        if (!d(s) || s._t !== X)
          throw TypeError("Incompatible receiver, " + X + " required!");
        return s;
      };
    },
    /* 152 */
    /***/
    function(m, l, i) {
      var d = i(91), s = i(90), X = i(150), a = i(101), e = i(95), n = i(146), G = i(148), y = i(147), o = i(98), h = i(121), I = i(96).f, x = i(153)(0), p = i(100);
      m.exports = function(W, V, t, c, b, Z) {
        var r = d[W], S = r, C = b ? "set" : "add", F = S && S.prototype, Y = {};
        return !p || typeof S != "function" || !(Z || F.forEach && !a(function() {
          new S().entries().next();
        })) ? (S = c.getConstructor(V, W, b, C), n(S.prototype, t), X.NEED = !0) : (S = V(function(J, T) {
          y(J, S, W, "_c"), J._c = new r(), T != null && G(T, b, J[C], J);
        }), x("add,clear,delete,forEach,get,has,set,keys,values,entries,toJSON".split(","), function(J) {
          var T = J == "add" || J == "set";
          J in F && !(Z && J == "clear") && e(S.prototype, J, function(K, R) {
            if (y(this, S, J), !T && Z && !o(K))
              return J == "get" ? void 0 : !1;
            var H = this._c[J](K === 0 ? 0 : K, R);
            return T ? this : H;
          });
        }), Z || I(S.prototype, "size", {
          get: function() {
            return this._c.size;
          }
        })), h(S, W), Y[W] = S, s(s.G + s.W + s.F, Y), Z || c.setStrong(S, W, b), S;
      };
    },
    /* 153 */
    /***/
    function(m, l, i) {
      var d = i(93), s = i(85), X = i(124), a = i(113), e = i(154);
      m.exports = function(n, G) {
        var y = n == 1, o = n == 2, h = n == 3, I = n == 4, x = n == 6, p = n == 5 || x, W = G || e;
        return function(V, t, c) {
          for (var b = X(V), Z = s(b), r = d(t, c, 3), S = a(Z.length), C = 0, F = y ? W(V, S) : o ? W(V, 0) : void 0, Y, J; S > C; C++)
            if ((p || C in Z) && (Y = Z[C], J = r(Y, C, b), n)) {
              if (y)
                F[C] = J;
              else if (J)
                switch (n) {
                  case 3:
                    return !0;
                  case 5:
                    return Y;
                  case 6:
                    return C;
                  case 2:
                    F.push(Y);
                }
              else if (I)
                return !1;
            }
          return x ? -1 : h || I ? I : F;
        };
      };
    },
    /* 154 */
    /***/
    function(m, l, i) {
      var d = i(155);
      m.exports = function(s, X) {
        return new (d(s))(X);
      };
    },
    /* 155 */
    /***/
    function(m, l, i) {
      var d = i(98), s = i(156), X = i(122)("species");
      m.exports = function(a) {
        var e;
        return s(a) && (e = a.constructor, typeof e == "function" && (e === Array || s(e.prototype)) && (e = void 0), d(e) && (e = e[X], e === null && (e = void 0))), e === void 0 ? Array : e;
      };
    },
    /* 156 */
    /***/
    function(m, l, i) {
      var d = i(86);
      m.exports = Array.isArray || function(X) {
        return d(X) == "Array";
      };
    },
    /* 157 */
    /***/
    function(m, l, i) {
      var d = i(90);
      d(d.P + d.R, "Map", { toJSON: i(158)("Map") });
    },
    /* 158 */
    /***/
    function(m, l, i) {
      var d = i(128), s = i(159);
      m.exports = function(X) {
        return function() {
          if (d(this) != X)
            throw TypeError(X + "#toJSON isn't generic");
          return s(this);
        };
      };
    },
    /* 159 */
    /***/
    function(m, l, i) {
      var d = i(148);
      m.exports = function(s, X) {
        var a = [];
        return d(s, !1, a.push, a, X), a;
      };
    },
    /* 160 */
    /***/
    function(m, l, i) {
      i(161)("Map");
    },
    /* 161 */
    /***/
    function(m, l, i) {
      var d = i(90);
      m.exports = function(s) {
        d(d.S, s, { of: function() {
          for (var a = arguments.length, e = new Array(a); a--; )
            e[a] = arguments[a];
          return new this(e);
        } });
      };
    },
    /* 162 */
    /***/
    function(m, l, i) {
      i(163)("Map");
    },
    /* 163 */
    /***/
    function(m, l, i) {
      var d = i(90), s = i(94), X = i(93), a = i(148);
      m.exports = function(e) {
        d(d.S, e, { from: function(G) {
          var y = arguments[1], o, h, I, x;
          return s(this), o = y !== void 0, o && s(y), G == null ? new this() : (h = [], o ? (I = 0, x = X(y, arguments[2], 2), a(G, !1, function(p) {
            h.push(x(p, I++));
          })) : a(G, !1, h.push, h), new this(h));
        } });
      };
    },
    /* 164 */
    /***/
    function(m, l, i) {
      m.exports = { default: i(165), __esModule: !0 };
    },
    /* 165 */
    /***/
    function(m, l, i) {
      i(166), m.exports = i(92).Object.assign;
    },
    /* 166 */
    /***/
    function(m, l, i) {
      var d = i(90);
      d(d.S + d.F, "Object", { assign: i(167) });
    },
    /* 167 */
    /***/
    function(m, l, i) {
      var d = i(100), s = i(110), X = i(168), a = i(169), e = i(124), n = i(85), G = Object.assign;
      m.exports = !G || i(101)(function() {
        var y = {}, o = {}, h = Symbol(), I = "abcdefghijklmnopqrst";
        return y[h] = 7, I.split("").forEach(function(x) {
          o[x] = x;
        }), G({}, y)[h] != 7 || Object.keys(G({}, o)).join("") != I;
      }) ? function(o, h) {
        for (var I = e(o), x = arguments.length, p = 1, W = X.f, V = a.f; x > p; )
          for (var t = n(arguments[p++]), c = W ? s(t).concat(W(t)) : s(t), b = c.length, Z = 0, r; b > Z; )
            r = c[Z++], (!d || V.call(t, r)) && (I[r] = t[r]);
        return I;
      } : G;
    },
    /* 168 */
    /***/
    function(m, l) {
      l.f = Object.getOwnPropertySymbols;
    },
    /* 169 */
    /***/
    function(m, l) {
      l.f = {}.propertyIsEnumerable;
    },
    /* 170 */
    /***/
    function(m, l, i) {
      l.__esModule = !0, l.default = function(d, s) {
        if (!(d instanceof s))
          throw new TypeError("Cannot call a class as a function");
      };
    },
    /* 171 */
    /***/
    function(m, l, i) {
      l.__esModule = !0;
      var d = i(172), s = X(d);
      function X(a) {
        return a && a.__esModule ? a : { default: a };
      }
      l.default = /* @__PURE__ */ function() {
        function a(e, n) {
          for (var G = 0; G < n.length; G++) {
            var y = n[G];
            y.enumerable = y.enumerable || !1, y.configurable = !0, "value" in y && (y.writable = !0), (0, s.default)(e, y.key, y);
          }
        }
        return function(e, n, G) {
          return n && a(e.prototype, n), G && a(e, G), e;
        };
      }();
    },
    /* 172 */
    /***/
    function(m, l, i) {
      m.exports = { default: i(173), __esModule: !0 };
    },
    /* 173 */
    /***/
    function(m, l, i) {
      i(174);
      var d = i(92).Object;
      m.exports = function(X, a, e) {
        return d.defineProperty(X, a, e);
      };
    },
    /* 174 */
    /***/
    function(m, l, i) {
      var d = i(90);
      d(d.S + d.F * !i(100), "Object", { defineProperty: i(96).f });
    },
    /* 175 */
    /***/
    function(m, l, i) {
      m.exports = { default: i(176), __esModule: !0 };
    },
    /* 176 */
    /***/
    function(m, l, i) {
      i(177), i(143), i(184), i(185), m.exports = i(92).Symbol;
    },
    /* 177 */
    /***/
    function(m, l, i) {
      var d = i(91), s = i(105), X = i(100), a = i(90), e = i(106), n = i(150).KEY, G = i(101), y = i(117), o = i(121), h = i(118), I = i(122), x = i(178), p = i(179), W = i(180), V = i(156), t = i(97), c = i(98), b = i(124), Z = i(84), r = i(103), S = i(104), C = i(108), F = i(181), Y = i(183), J = i(168), T = i(96), K = i(110), R = Y.f, H = T.f, f = F.f, w = d.Symbol, O = d.JSON, q = O && O.stringify, k = "prototype", Q = I("_hidden"), D = I("toPrimitive"), ii = {}.propertyIsEnumerable, _ = y("symbol-registry"), bi = y("symbols"), $ = y("op-symbols"), Xi = Object[k], ni = typeof w == "function" && !!J.f, M = d.QObject, z = !M || !M[k] || !M[k].findChild, E = X && G(function() {
        return C(H({}, "a", {
          get: function() {
            return H(this, "a", { value: 7 }).a;
          }
        })).a != 7;
      }) ? function(si, ti, mi) {
        var oi = R(Xi, ti);
        oi && delete Xi[ti], H(si, ti, mi), oi && si !== Xi && H(Xi, ti, oi);
      } : H, B = function(si) {
        var ti = bi[si] = C(w[k]);
        return ti._k = si, ti;
      }, g = ni && typeof w.iterator == "symbol" ? function(si) {
        return typeof si == "symbol";
      } : function(si) {
        return si instanceof w;
      }, U = function(ti, mi, oi) {
        return ti === Xi && U($, mi, oi), t(ti), mi = r(mi, !0), t(oi), s(bi, mi) ? (oi.enumerable ? (s(ti, Q) && ti[Q][mi] && (ti[Q][mi] = !1), oi = C(oi, { enumerable: S(0, !1) })) : (s(ti, Q) || H(ti, Q, S(1, {})), ti[Q][mi] = !0), E(ti, mi, oi)) : H(ti, mi, oi);
      }, u = function(ti, mi) {
        t(ti);
        for (var oi = W(mi = Z(mi)), ai = 0, ei = oi.length, Vi; ei > ai; )
          U(ti, Vi = oi[ai++], mi[Vi]);
        return ti;
      }, L = function(ti, mi) {
        return mi === void 0 ? C(ti) : u(C(ti), mi);
      }, N = function(ti) {
        var mi = ii.call(this, ti = r(ti, !0));
        return this === Xi && s(bi, ti) && !s($, ti) ? !1 : mi || !s(this, ti) || !s(bi, ti) || s(this, Q) && this[Q][ti] ? mi : !0;
      }, v = function(ti, mi) {
        if (ti = Z(ti), mi = r(mi, !0), !(ti === Xi && s(bi, mi) && !s($, mi))) {
          var oi = R(ti, mi);
          return oi && s(bi, mi) && !(s(ti, Q) && ti[Q][mi]) && (oi.enumerable = !0), oi;
        }
      }, P = function(ti) {
        for (var mi = f(Z(ti)), oi = [], ai = 0, ei; mi.length > ai; )
          !s(bi, ei = mi[ai++]) && ei != Q && ei != n && oi.push(ei);
        return oi;
      }, j = function(ti) {
        for (var mi = ti === Xi, oi = f(mi ? $ : Z(ti)), ai = [], ei = 0, Vi; oi.length > ei; )
          s(bi, Vi = oi[ei++]) && (!mi || s(Xi, Vi)) && ai.push(bi[Vi]);
        return ai;
      };
      ni || (w = function() {
        if (this instanceof w)
          throw TypeError("Symbol is not a constructor!");
        var ti = h(arguments.length > 0 ? arguments[0] : void 0), mi = function(oi) {
          this === Xi && mi.call($, oi), s(this, Q) && s(this[Q], ti) && (this[Q][ti] = !1), E(this, ti, S(1, oi));
        };
        return X && z && E(Xi, ti, { configurable: !0, set: mi }), B(ti);
      }, e(w[k], "toString", function() {
        return this._k;
      }), Y.f = v, T.f = U, i(182).f = F.f = P, i(169).f = N, J.f = j, X && !i(89) && e(Xi, "propertyIsEnumerable", N, !0), x.f = function(si) {
        return B(I(si));
      }), a(a.G + a.W + a.F * !ni, { Symbol: w });
      for (var A = (
        // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
        "hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(",")
      ), li = 0; A.length > li; )
        I(A[li++]);
      for (var di = K(I.store), ci = 0; di.length > ci; )
        p(di[ci++]);
      a(a.S + a.F * !ni, "Symbol", {
        // 19.4.2.1 Symbol.for(key)
        for: function(si) {
          return s(_, si += "") ? _[si] : _[si] = w(si);
        },
        // 19.4.2.5 Symbol.keyFor(sym)
        keyFor: function(ti) {
          if (!g(ti))
            throw TypeError(ti + " is not a symbol!");
          for (var mi in _)
            if (_[mi] === ti)
              return mi;
        },
        useSetter: function() {
          z = !0;
        },
        useSimple: function() {
          z = !1;
        }
      }), a(a.S + a.F * !ni, "Object", {
        // 19.1.2.2 Object.create(O [, Properties])
        create: L,
        // 19.1.2.4 Object.defineProperty(O, P, Attributes)
        defineProperty: U,
        // 19.1.2.3 Object.defineProperties(O, Properties)
        defineProperties: u,
        // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
        getOwnPropertyDescriptor: v,
        // 19.1.2.7 Object.getOwnPropertyNames(O)
        getOwnPropertyNames: P,
        // 19.1.2.8 Object.getOwnPropertySymbols(O)
        getOwnPropertySymbols: j
      });
      var Zi = G(function() {
        J.f(1);
      });
      a(a.S + a.F * Zi, "Object", {
        getOwnPropertySymbols: function(ti) {
          return J.f(b(ti));
        }
      }), O && a(a.S + a.F * (!ni || G(function() {
        var si = w();
        return q([si]) != "[null]" || q({ a: si }) != "{}" || q(Object(si)) != "{}";
      })), "JSON", {
        stringify: function(ti) {
          for (var mi = [ti], oi = 1, ai, ei; arguments.length > oi; )
            mi.push(arguments[oi++]);
          if (ei = ai = mi[1], !(!c(ai) && ti === void 0 || g(ti)))
            return V(ai) || (ai = function(Vi, Ji) {
              if (typeof ei == "function" && (Ji = ei.call(this, Vi, Ji)), !g(Ji))
                return Ji;
            }), mi[1] = ai, q.apply(O, mi);
        }
      }), w[k][D] || i(95)(w[k], D, w[k].valueOf), o(w, "Symbol"), o(Math, "Math", !0), o(d.JSON, "JSON", !0);
    },
    /* 178 */
    /***/
    function(m, l, i) {
      l.f = i(122);
    },
    /* 179 */
    /***/
    function(m, l, i) {
      var d = i(91), s = i(92), X = i(89), a = i(178), e = i(96).f;
      m.exports = function(n) {
        var G = s.Symbol || (s.Symbol = X ? {} : d.Symbol || {});
        n.charAt(0) != "_" && !(n in G) && e(G, n, { value: a.f(n) });
      };
    },
    /* 180 */
    /***/
    function(m, l, i) {
      var d = i(110), s = i(168), X = i(169);
      m.exports = function(a) {
        var e = d(a), n = s.f;
        if (n)
          for (var G = n(a), y = X.f, o = 0, h; G.length > o; )
            y.call(a, h = G[o++]) && e.push(h);
        return e;
      };
    },
    /* 181 */
    /***/
    function(m, l, i) {
      var d = i(84), s = i(182).f, X = {}.toString, a = typeof window == "object" && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [], e = function(n) {
        try {
          return s(n);
        } catch {
          return a.slice();
        }
      };
      m.exports.f = function(G) {
        return a && X.call(G) == "[object Window]" ? e(G) : s(d(G));
      };
    },
    /* 182 */
    /***/
    function(m, l, i) {
      var d = i(111), s = i(119).concat("length", "prototype");
      l.f = Object.getOwnPropertyNames || function(a) {
        return d(a, s);
      };
    },
    /* 183 */
    /***/
    function(m, l, i) {
      var d = i(169), s = i(104), X = i(84), a = i(103), e = i(105), n = i(99), G = Object.getOwnPropertyDescriptor;
      l.f = i(100) ? G : function(o, h) {
        if (o = X(o), h = a(h, !0), n)
          try {
            return G(o, h);
          } catch {
          }
        if (e(o, h))
          return s(!d.f.call(o, h), o[h]);
      };
    },
    /* 184 */
    /***/
    function(m, l, i) {
      i(179)("asyncIterator");
    },
    /* 185 */
    /***/
    function(m, l, i) {
      i(179)("observable");
    },
    /* 186 */
    /***/
    function(m, l, i) {
      Object.defineProperty(l, "__esModule", {
        value: !0
      }), l.createNowTime = d, l.formatDelay = s;
      function d() {
        var X = null;
        return Date.now ? X = Date.now : X = function() {
          return (/* @__PURE__ */ new Date()).getTime();
        }, X;
      }
      function s(X) {
        return typeof X == "number" ? X = { delay: X } : "entropy" in X && (X = { delay: X.entropy, isEntropy: !0 }), X;
      }
    },
    /* 187 */
    /***/
    function(m, l, i) {
      Object.defineProperty(l, "__esModule", {
        value: !0
      }), l.default = {
        // s - startFrame, e - endFrame
        default: function(s, X, a, e, n) {
          return typeof s == "number" && typeof X == "number" ? s + (a - e) / (n - e) * (X - s) : a - e > n - a ? X : s;
        }
      };
    },
    /* 188 */
    /***/
    function(m, l, i) {
      Object.defineProperty(l, "__esModule", {
        value: !0
      }), l.parseEasing = l.Easings = void 0;
      var d = i(76), s = G(d), X = i(133), a = G(X), e = i(141), n = G(e);
      function G(V) {
        return V && V.__esModule ? V : { default: V };
      }
      var y = i(189), o = new n.default();
      function h() {
        for (var V = arguments.length, t = Array(V), c = 0; c < V; c++)
          t[c] = arguments[c];
        var b = o.get(t);
        return b || (b = y.apply(void 0, t), o.set(t, b), b);
      }
      function I(V) {
        var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "end";
        return function(c, b) {
          for (var Z = 1; Z < b.length; Z++) {
            var r = b[Z].offset;
            if (c <= r) {
              var S = b[Z - 1].offset, C = r, F = (c - S) / (C - S), Y = 1 / V, J = F / Y;
              return t === "end" ? J = Math.floor(J) : J = Math.ceil(J), Y * J * (C - S) + S;
            }
          }
          return 0;
        };
      }
      function x(V) {
        var t = /^cubic-bezier\((.*)\)/, c = V.match(t);
        if (c) {
          var b = c[1].trim();
          return b = b.split(",").map(function(Y) {
            return parseFloat(Y.trim());
          }), h.apply(void 0, (0, a.default)(b));
        }
        if (t = /^steps\((.*)\)/, c = V.match(t), c) {
          var Z = c[1].trim();
          Z = Z.split(",").map(function(Y) {
            return Y.trim();
          });
          var r = Z, S = (0, s.default)(r, 2), C = S[0], F = S[1];
          return I(parseInt(C, 10), F);
        }
        return V;
      }
      var p = {
        linear: function(t) {
          return t;
        },
        ease: h(0.25, 0.1, 0.25, 1),
        "ease-in": h(0.42, 0, 1, 1),
        "ease-out": h(0, 0, 0.58, 1),
        "ease-in-out": h(0.42, 0, 0.58, 1),
        // 'step-start': function(p, frames){
        //   let ret = 0
        //   for(let i = 0; i < frames.length; i++){
        //     const {offset} = frames[i]
        //     ret = offset
        //     if(p < offset){
        //       break
        //     }
        //   }
        //   return ret
        // },
        // 'step-end': function(p, frames){
        //   let ret = 0
        //   for(let i = 0; i < frames.length; i++){
        //     const {offset} = frames[i]
        //     if(p < offset){
        //       break
        //     }
        //     ret = offset
        //   }
        //   return ret
        // }
        "step-start": I(1, "start"),
        "step-end": I(1, "end")
      };
      function W(V) {
        return typeof V == "string" ? p[V] ? V = p[V] : V = x(V) : V.type === "cubic-bezier" ? V = h.apply(void 0, (0, a.default)(V.value)) : V.type === "steps" && (V = I(V.step, V.pos)), V;
      }
      l.Easings = p, l.parseEasing = W;
    },
    /* 189 */
    /***/
    function(m, l) {
      var i = 4, d = 1e-3, s = 1e-7, X = 10, a = 11, e = 1 / (a - 1), n = typeof Float32Array == "function";
      function G(V, t) {
        return 1 - 3 * t + 3 * V;
      }
      function y(V, t) {
        return 3 * t - 6 * V;
      }
      function o(V) {
        return 3 * V;
      }
      function h(V, t, c) {
        return ((G(t, c) * V + y(t, c)) * V + o(t)) * V;
      }
      function I(V, t, c) {
        return 3 * G(t, c) * V * V + 2 * y(t, c) * V + o(t);
      }
      function x(V, t, c, b, Z) {
        var r, S, C = 0;
        do
          S = t + (c - t) / 2, r = h(S, b, Z) - V, r > 0 ? c = S : t = S;
        while (Math.abs(r) > s && ++C < X);
        return S;
      }
      function p(V, t, c, b) {
        for (var Z = 0; Z < i; ++Z) {
          var r = I(t, c, b);
          if (r === 0)
            return t;
          var S = h(t, c, b) - V;
          t -= S / r;
        }
        return t;
      }
      function W(V) {
        return V;
      }
      m.exports = function(t, c, b, Z) {
        if (!(0 <= t && t <= 1 && 0 <= b && b <= 1))
          throw new Error("bezier x values must be in [0, 1] range");
        if (t === c && b === Z)
          return W;
        for (var r = n ? new Float32Array(a) : new Array(a), S = 0; S < a; ++S)
          r[S] = h(S * e, t, b);
        function C(F) {
          for (var Y = 0, J = 1, T = a - 1; J !== T && r[J] <= F; ++J)
            Y += e;
          --J;
          var K = (F - r[J]) / (r[J + 1] - r[J]), R = Y + K * e, H = I(R, t, b);
          return H >= d ? p(F, R, t, b) : H === 0 ? R : x(F, Y, Y + e, t, b);
        }
        return function(Y) {
          return Y === 0 ? 0 : Y === 1 ? 1 : h(C(Y), c, Z);
        };
      };
    },
    /* 190 */
    /***/
    function(m, l, i) {
      Object.defineProperty(l, "__esModule", {
        value: !0
      });
      var d = i(191), s = c(d), X = i(204), a = c(X), e = i(164), n = c(e), G = i(170), y = c(G), o = i(171), h = c(o), I = i(175), x = c(I), p = i(75), W = c(p), V = i(208), t = i(188);
      function c(H) {
        return H && H.__esModule ? H : { default: H };
      }
      var b = (0, x.default)("timing"), Z = (0, x.default)("keyframes"), r = (0, x.default)("initState"), S = (0, x.default)("readyDefer"), C = (0, x.default)("finishedDefer"), F = (0, x.default)("effects"), Y = (0, x.default)("activeReadyTimer"), J = (0, x.default)("activeFinishTimer"), T = (0, x.default)("removeDefer"), K = {
        delay: 0,
        endDelay: 0,
        fill: "auto",
        iterations: 1,
        playbackRate: 1,
        direction: "normal",
        easing: "linear",
        effect: null
      }, R = function() {
        function H(f, w, O) {
          var q = this;
          if ((0, y.default)(this, H), Array.isArray(f)) {
            var k = [f[0], f, w];
            f = k[0], w = k[1], O = k[2];
          }
          typeof O == "number" && (O = { duration: O }), this[b] = (0, n.default)({}, K, O), this[b].easing = (0, t.parseEasing)(this[b].easing), this[Z] = (0, V.calculateFramesOffset)(w);
          var Q = this[Z][this[Z].length - 1];
          this[r] = {}, (0, a.default)(Q).forEach(function(D) {
            Object.prototype.hasOwnProperty.call(f, D) && D !== "easing" && D !== "offset" && (q[r][D] = f[D]);
          }), this[Z] = this[Z].map(function(D) {
            return (0, n.default)({}, q[r], D);
          }), this[Z][0].offset !== 0 && this[Z].unshift((0, n.default)({}, this[r], { offset: 0 })), Q.offset < 1 && this[Z].push((0, n.default)({}, Q, { offset: 1 })), this[F] = {}, this.timeline = null;
        }
        return (0, h.default)(H, [{
          key: "pause",
          value: function() {
            this.timeline.playbackRate = 0;
          }
        }, {
          key: Y,
          value: function() {
            var w = this;
            this[S] && !this[S].timerID && (this.timeline.currentTime < 0 ? this[S].timerID = this.timeline.setTimeout(function() {
              w[S].resolve(), delete w[S];
            }, { delay: -this.timeline.currentTime, heading: !1 }) : this[S].timerID = this.timeline.setTimeout(function() {
              w[S].resolve(), delete w[S];
            }, { delay: 0, isEntropy: !0 }));
          }
        }, {
          key: J,
          value: function() {
            var w = this, O = this[b], q = O.duration, k = O.iterations, Q = O.endDelay, D = Math.ceil(q * k + Q - this.timeline.currentTime) + 1;
            this[C] && !this[C].timerID && (this[C].timerID = this.timeline.setTimeout(function() {
              w[C].resolve(), w[T](S), w[T](C);
            }, { delay: D, heading: !1 }), this[C].reverseTimerID = this.timeline.setTimeout(function() {
              w[C].resolve(), w[T](S), w[T](C), w.timeline = null;
            }, { delay: -this[b].delay - 1, heading: !1 }));
          }
        }, {
          key: "play",
          value: function() {
            if (this.playState === "finished" && this.cancel(), this.playState === "idle") {
              if (this.playbackRate <= 0)
                return;
              var w = this[b], O = w.delay, q = w.playbackRate, k = w.timeline;
              this.timeline = new W.default({
                originTime: O,
                playbackRate: q
              }, k), this[Y](), this[J]();
            } else
              this.playState === "paused" && (this.timeline.playbackRate = this.playbackRate, this[Y]());
          }
        }, {
          key: T,
          value: function(w) {
            var O = this[w], q = this.timeline;
            O && q && (q.clearTimeout(O.timerID), O.reverseTimerID && q.clearTimeout(O.reverseTimerID)), delete this[w];
          }
        }, {
          key: "cancel",
          value: function() {
            this[T](S), this[T](C), this.timeline = null;
          }
        }, {
          key: "finish",
          value: function() {
            this.timeline && (this.timeline.currentTime = 1 / 0 / this.playbackRate), this[T](S), this[T](C);
          }
        }, {
          key: "applyEffects",
          value: function(w) {
            return (0, n.default)(this[F], w);
          }
        }, {
          key: "playbackRate",
          get: function() {
            return this[b].playbackRate;
          },
          set: function(w) {
            this.timeline && (this.timeline.playbackRate = w), this[b].playbackRate = w;
          }
        }, {
          key: "playState",
          get: function() {
            var w = this.timeline, O = this[b], q = O.iterations, k = O.duration, Q = O.endDelay, D = "running";
            if (w == null)
              D = "idle";
            else if (w.paused)
              D = "paused";
            else if (w.currentTime < 0)
              D = "pending";
            else {
              var ii = w.currentTime - q * k;
              ii > 0 && ii < Q ? D = "pending" : ii >= Q && (D = "finished");
            }
            return D;
          }
        }, {
          key: "progress",
          get: function() {
            if (!this.timeline)
              return 0;
            var w = this[b], O = w.duration, q = w.iterations, k = this.timeline, Q = this.playState, D = void 0;
            if (Q === "idle")
              D = 0;
            else if (Q === "paused" && k.currentTime < 0)
              D = 0;
            else if (Q === "pending")
              if (k.currentTime < 0)
                D = 0;
              else {
                var ii = k.seekLocalTime(q * O);
                D = (0, V.periodicity)(ii, O)[1] / O;
              }
            else
              (Q === "running" || Q === "paused") && (D = (0, V.periodicity)(k.currentTime, O)[1] / O);
            return Q === "finished" && (D = (0, V.periodicity)(q, 1)[1]), D;
          }
        }, {
          key: "frame",
          get: function() {
            var w = this.playState, O = this[r], q = this[b].fill;
            if (w === "idle")
              return O;
            var k = this.timeline.currentTime, Q = this[Z].slice(0), D = (0, V.getProgress)(this.timeline, this[b], this.progress), ii = D.p, _ = D.inverted, bi = O;
            return k < 0 && w === "pending" ? (q === "backwards" || q === "both") && (bi = _ ? Q[Q.length - 1] : Q[0]) : (w !== "pending" && w !== "finished" || q === "forwards" || q === "both") && (bi = (0, V.getCurrentFrame)(this[b], Q, this[F], ii)), bi;
          }
        }, {
          key: "timing",
          get: function() {
            return this[b];
          }
        }, {
          key: "effects",
          get: function() {
            return this[F];
          }
        }, {
          key: "baseTimeline",
          set: function(w) {
            this[b].timeline = w;
          },
          get: function() {
            return this[b].timeline;
          }
        }, {
          key: "ready",
          get: function() {
            return this[S] ? this[S].promise : this.timeline && this.timeline.currentTime >= 0 && this.playState !== "paused" ? s.default.resolve() : (this[S] = (0, V.defer)(), this.timeline && this[Y](), this[S] ? this[S].promise : s.default.resolve());
          }
        }, {
          key: "finished",
          get: function() {
            return this.playState === "finished" ? s.default.resolve() : (this[C] || (this[C] = (0, V.defer)(), this.timeline && this[J]()), this[C].promise);
          }
        }]), H;
      }();
      l.default = R;
    },
    /* 191 */
    /***/
    function(m, l, i) {
      m.exports = { default: i(192), __esModule: !0 };
    },
    /* 192 */
    /***/
    function(m, l, i) {
      i(143), i(125), i(79), i(193), i(202), i(203), m.exports = i(92).Promise;
    },
    /* 193 */
    /***/
    function(m, l, i) {
      var d = i(89), s = i(91), X = i(93), a = i(128), e = i(90), n = i(98), G = i(94), y = i(147), o = i(148), h = i(194), I = i(195).set, x = i(197)(), p = i(198), W = i(199), V = i(200), t = i(201), c = "Promise", b = s.TypeError, Z = s.process, r = Z && Z.versions, S = r && r.v8 || "", C = s[c], F = a(Z) == "process", Y = function() {
      }, J, T, K, R, H = T = p.f, f = !!function() {
        try {
          var _ = C.resolve(1), bi = (_.constructor = {})[i(122)("species")] = function($) {
            $(Y, Y);
          };
          return (F || typeof PromiseRejectionEvent == "function") && _.then(Y) instanceof bi && S.indexOf("6.6") !== 0 && V.indexOf("Chrome/66") === -1;
        } catch {
        }
      }(), w = function(_) {
        var bi;
        return n(_) && typeof (bi = _.then) == "function" ? bi : !1;
      }, O = function(_, bi) {
        if (!_._n) {
          _._n = !0;
          var $ = _._c;
          x(function() {
            for (var Xi = _._v, ni = _._s == 1, M = 0, z = function(E) {
              var B = ni ? E.ok : E.fail, g = E.resolve, U = E.reject, u = E.domain, L, N, v;
              try {
                B ? (ni || (_._h == 2 && Q(_), _._h = 1), B === !0 ? L = Xi : (u && u.enter(), L = B(Xi), u && (u.exit(), v = !0)), L === E.promise ? U(b("Promise-chain cycle")) : (N = w(L)) ? N.call(L, g, U) : g(L)) : U(Xi);
              } catch (P) {
                u && !v && u.exit(), U(P);
              }
            }; $.length > M; )
              z($[M++]);
            _._c = [], _._n = !1, bi && !_._h && q(_);
          });
        }
      }, q = function(_) {
        I.call(s, function() {
          var bi = _._v, $ = k(_), Xi, ni, M;
          if ($ && (Xi = W(function() {
            F ? Z.emit("unhandledRejection", bi, _) : (ni = s.onunhandledrejection) ? ni({ promise: _, reason: bi }) : (M = s.console) && M.error && M.error("Unhandled promise rejection", bi);
          }), _._h = F || k(_) ? 2 : 1), _._a = void 0, $ && Xi.e)
            throw Xi.v;
        });
      }, k = function(_) {
        return _._h !== 1 && (_._a || _._c).length === 0;
      }, Q = function(_) {
        I.call(s, function() {
          var bi;
          F ? Z.emit("rejectionHandled", _) : (bi = s.onrejectionhandled) && bi({ promise: _, reason: _._v });
        });
      }, D = function(_) {
        var bi = this;
        bi._d || (bi._d = !0, bi = bi._w || bi, bi._v = _, bi._s = 2, bi._a || (bi._a = bi._c.slice()), O(bi, !0));
      }, ii = function(_) {
        var bi = this, $;
        if (!bi._d) {
          bi._d = !0, bi = bi._w || bi;
          try {
            if (bi === _)
              throw b("Promise can't be resolved itself");
            ($ = w(_)) ? x(function() {
              var Xi = { _w: bi, _d: !1 };
              try {
                $.call(_, X(ii, Xi, 1), X(D, Xi, 1));
              } catch (ni) {
                D.call(Xi, ni);
              }
            }) : (bi._v = _, bi._s = 1, O(bi, !1));
          } catch (Xi) {
            D.call({ _w: bi, _d: !1 }, Xi);
          }
        }
      };
      f || (C = function(bi) {
        y(this, C, c, "_h"), G(bi), J.call(this);
        try {
          bi(X(ii, this, 1), X(D, this, 1));
        } catch ($) {
          D.call(this, $);
        }
      }, J = function(bi) {
        this._c = [], this._a = void 0, this._s = 0, this._d = !1, this._v = void 0, this._h = 0, this._n = !1;
      }, J.prototype = i(146)(C.prototype, {
        // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
        then: function(bi, $) {
          var Xi = H(h(this, C));
          return Xi.ok = typeof bi == "function" ? bi : !0, Xi.fail = typeof $ == "function" && $, Xi.domain = F ? Z.domain : void 0, this._c.push(Xi), this._a && this._a.push(Xi), this._s && O(this, !1), Xi.promise;
        },
        // 25.4.5.1 Promise.prototype.catch(onRejected)
        catch: function(_) {
          return this.then(void 0, _);
        }
      }), K = function() {
        var _ = new J();
        this.promise = _, this.resolve = X(ii, _, 1), this.reject = X(D, _, 1);
      }, p.f = H = function(_) {
        return _ === C || _ === R ? new K(_) : T(_);
      }), e(e.G + e.W + e.F * !f, { Promise: C }), i(121)(C, c), i(149)(c), R = i(92)[c], e(e.S + e.F * !f, c, {
        // 25.4.4.5 Promise.reject(r)
        reject: function(bi) {
          var $ = H(this), Xi = $.reject;
          return Xi(bi), $.promise;
        }
      }), e(e.S + e.F * (d || !f), c, {
        // 25.4.4.6 Promise.resolve(x)
        resolve: function(bi) {
          return t(d && this === R ? C : this, bi);
        }
      }), e(e.S + e.F * !(f && i(140)(function(_) {
        C.all(_).catch(Y);
      })), c, {
        // 25.4.4.1 Promise.all(iterable)
        all: function(bi) {
          var $ = this, Xi = H($), ni = Xi.resolve, M = Xi.reject, z = W(function() {
            var E = [], B = 0, g = 1;
            o(bi, !1, function(U) {
              var u = B++, L = !1;
              E.push(void 0), g++, $.resolve(U).then(function(N) {
                L || (L = !0, E[u] = N, --g || ni(E));
              }, M);
            }), --g || ni(E);
          });
          return z.e && M(z.v), Xi.promise;
        },
        // 25.4.4.4 Promise.race(iterable)
        race: function(bi) {
          var $ = this, Xi = H($), ni = Xi.reject, M = W(function() {
            o(bi, !1, function(z) {
              $.resolve(z).then(Xi.resolve, ni);
            });
          });
          return M.e && ni(M.v), Xi.promise;
        }
      });
    },
    /* 194 */
    /***/
    function(m, l, i) {
      var d = i(97), s = i(94), X = i(122)("species");
      m.exports = function(a, e) {
        var n = d(a).constructor, G;
        return n === void 0 || (G = d(n)[X]) == null ? e : s(G);
      };
    },
    /* 195 */
    /***/
    function(m, l, i) {
      var d = i(93), s = i(196), X = i(120), a = i(102), e = i(91), n = e.process, G = e.setImmediate, y = e.clearImmediate, o = e.MessageChannel, h = e.Dispatch, I = 0, x = {}, p = "onreadystatechange", W, V, t, c = function() {
        var Z = +this;
        if (x.hasOwnProperty(Z)) {
          var r = x[Z];
          delete x[Z], r();
        }
      }, b = function(Z) {
        c.call(Z.data);
      };
      (!G || !y) && (G = function(r) {
        for (var S = [], C = 1; arguments.length > C; )
          S.push(arguments[C++]);
        return x[++I] = function() {
          s(typeof r == "function" ? r : Function(r), S);
        }, W(I), I;
      }, y = function(r) {
        delete x[r];
      }, i(86)(n) == "process" ? W = function(Z) {
        n.nextTick(d(c, Z, 1));
      } : h && h.now ? W = function(Z) {
        h.now(d(c, Z, 1));
      } : o ? (V = new o(), t = V.port2, V.port1.onmessage = b, W = d(t.postMessage, t, 1)) : e.addEventListener && typeof postMessage == "function" && !e.importScripts ? (W = function(Z) {
        e.postMessage(Z + "", "*");
      }, e.addEventListener("message", b, !1)) : p in a("script") ? W = function(Z) {
        X.appendChild(a("script"))[p] = function() {
          X.removeChild(this), c.call(Z);
        };
      } : W = function(Z) {
        setTimeout(d(c, Z, 1), 0);
      }), m.exports = {
        set: G,
        clear: y
      };
    },
    /* 196 */
    /***/
    function(m, l) {
      m.exports = function(i, d, s) {
        var X = s === void 0;
        switch (d.length) {
          case 0:
            return X ? i() : i.call(s);
          case 1:
            return X ? i(d[0]) : i.call(s, d[0]);
          case 2:
            return X ? i(d[0], d[1]) : i.call(s, d[0], d[1]);
          case 3:
            return X ? i(d[0], d[1], d[2]) : i.call(s, d[0], d[1], d[2]);
          case 4:
            return X ? i(d[0], d[1], d[2], d[3]) : i.call(s, d[0], d[1], d[2], d[3]);
        }
        return i.apply(s, d);
      };
    },
    /* 197 */
    /***/
    function(m, l, i) {
      var d = i(91), s = i(195).set, X = d.MutationObserver || d.WebKitMutationObserver, a = d.process, e = d.Promise, n = i(86)(a) == "process";
      m.exports = function() {
        var G, y, o, h = function() {
          var W, V;
          for (n && (W = a.domain) && W.exit(); G; ) {
            V = G.fn, G = G.next;
            try {
              V();
            } catch (t) {
              throw G ? o() : y = void 0, t;
            }
          }
          y = void 0, W && W.enter();
        };
        if (n)
          o = function() {
            a.nextTick(h);
          };
        else if (X && !(d.navigator && d.navigator.standalone)) {
          var I = !0, x = document.createTextNode("");
          new X(h).observe(x, { characterData: !0 }), o = function() {
            x.data = I = !I;
          };
        } else if (e && e.resolve) {
          var p = e.resolve(void 0);
          o = function() {
            p.then(h);
          };
        } else
          o = function() {
            s.call(d, h);
          };
        return function(W) {
          var V = { fn: W, next: void 0 };
          y && (y.next = V), G || (G = V, o()), y = V;
        };
      };
    },
    /* 198 */
    /***/
    function(m, l, i) {
      var d = i(94);
      function s(X) {
        var a, e;
        this.promise = new X(function(n, G) {
          if (a !== void 0 || e !== void 0)
            throw TypeError("Bad Promise constructor");
          a = n, e = G;
        }), this.resolve = d(a), this.reject = d(e);
      }
      m.exports.f = function(X) {
        return new s(X);
      };
    },
    /* 199 */
    /***/
    function(m, l) {
      m.exports = function(i) {
        try {
          return { e: !1, v: i() };
        } catch (d) {
          return { e: !0, v: d };
        }
      };
    },
    /* 200 */
    /***/
    function(m, l, i) {
      var d = i(91), s = d.navigator;
      m.exports = s && s.userAgent || "";
    },
    /* 201 */
    /***/
    function(m, l, i) {
      var d = i(97), s = i(98), X = i(198);
      m.exports = function(a, e) {
        if (d(a), s(e) && e.constructor === a)
          return e;
        var n = X.f(a), G = n.resolve;
        return G(e), n.promise;
      };
    },
    /* 202 */
    /***/
    function(m, l, i) {
      var d = i(90), s = i(92), X = i(91), a = i(194), e = i(201);
      d(d.P + d.R, "Promise", { finally: function(n) {
        var G = a(this, s.Promise || X.Promise), y = typeof n == "function";
        return this.then(
          y ? function(o) {
            return e(G, n()).then(function() {
              return o;
            });
          } : n,
          y ? function(o) {
            return e(G, n()).then(function() {
              throw o;
            });
          } : n
        );
      } });
    },
    /* 203 */
    /***/
    function(m, l, i) {
      var d = i(90), s = i(198), X = i(199);
      d(d.S, "Promise", { try: function(a) {
        var e = s.f(this), n = X(a);
        return (n.e ? e.reject : e.resolve)(n.v), e.promise;
      } });
    },
    /* 204 */
    /***/
    function(m, l, i) {
      m.exports = { default: i(205), __esModule: !0 };
    },
    /* 205 */
    /***/
    function(m, l, i) {
      i(206), m.exports = i(92).Object.keys;
    },
    /* 206 */
    /***/
    function(m, l, i) {
      var d = i(124), s = i(110);
      i(207)("keys", function() {
        return function(a) {
          return s(d(a));
        };
      });
    },
    /* 207 */
    /***/
    function(m, l, i) {
      var d = i(90), s = i(92), X = i(101);
      m.exports = function(a, e) {
        var n = (s.Object || {})[a] || Object[a], G = {};
        G[a] = e(n), d(d.S + d.F * X(function() {
          n(1);
        }), "Object", G);
      };
    },
    /* 208 */
    /***/
    function(m, l, i) {
      Object.defineProperty(l, "__esModule", {
        value: !0
      });
      var d = i(76), s = x(d), X = i(209), a = x(X), e = i(164), n = x(e), G = i(191), y = x(G);
      l.defer = p, l.periodicity = W, l.calculateFramesOffset = V, l.getProgress = t, l.getCurrentFrame = b;
      var o = i(188), h = i(187), I = x(h);
      function x(Z) {
        return Z && Z.__esModule ? Z : { default: Z };
      }
      function p() {
        var Z = {};
        return Z.promise = new y.default(function(r, S) {
          Z.resolve = r, Z.reject = S;
        }), Z;
      }
      function W(Z, r) {
        var S = Math.floor(Z / r), C = Z - S * r;
        return C === 0 && S > 0 && (C = r, S--), [S, C];
      }
      function V(Z) {
        Z = Z.slice(0);
        var r = Z[0], S = Z[Z.length - 1];
        S.offset = S.offset || 1, r.offset = r.offset || 0;
        for (var C = 0, F = -1, Y = 0; Y < Z.length; Y++) {
          var J = Z[Y];
          if (J.offset != null) {
            var T = Y - F;
            if (T > 1)
              for (var K = (J.offset - C) / T, R = 0; R < T - 1; R++)
                Z[F + R + 1].offset = C + K * (R + 1);
            C = J.offset, F = Y;
          }
          if (J.easing != null && (J.easing = (0, o.parseEasing)(J.easing)), Y > 0) {
            var H = Z[Y].easing != null;
            Z[Y] = (0, n.default)({}, Z[Y - 1], Z[Y]), H || delete Z[Y].easing;
          }
        }
        return Z;
      }
      function t(Z, r, S) {
        var C = Z.currentTime, F = r.direction, Y = r.duration, J = !1;
        if (F === "reverse")
          S = 1 - S, J = !0;
        else if (F === "alternate" || F === "alternate-reverse") {
          var T = Math.floor(C / Y);
          S === 1 && T--, T % 2 ^ F === "alternate-reverse" && (S = 1 - S, J = !0);
        }
        return { p: S, inverted: J };
      }
      function c(Z, r, S, C) {
        var F = {};
        return (0, a.default)(r).forEach(function(Y) {
          var J = (0, s.default)(Y, 2), T = J[0], K = J[1];
          if (T !== "offset" && T !== "easing") {
            var R = S[T] || S.default, H = R(Z[T], K, C, Z.offset, r.offset);
            H != null && (F[T] = H);
          }
        }), F;
      }
      function b(Z, r, S, C) {
        var F = Z.easing, Y = Z.effect;
        Y || (S = (0, n.default)({}, I.default, S));
        var J = {};
        C = F(C, r);
        for (var T = 1; T < r.length; T++) {
          var K = r[T], R = K.offset;
          if (R >= C || T === r.length - 1) {
            var H = r[T - 1], f = H.offset, w = H.easing, O = C;
            if (w) {
              var q = R - f;
              O = w((C - f) / q) * q + f;
            }
            Y ? J = Y(H, K, O, f, R) : J = c(H, K, S, O);
            break;
          }
        }
        return J;
      }
    },
    /* 209 */
    /***/
    function(m, l, i) {
      m.exports = { default: i(210), __esModule: !0 };
    },
    /* 210 */
    /***/
    function(m, l, i) {
      i(211), m.exports = i(92).Object.entries;
    },
    /* 211 */
    /***/
    function(m, l, i) {
      var d = i(90), s = i(212)(!0);
      d(d.S, "Object", {
        entries: function(a) {
          return s(a);
        }
      });
    },
    /* 212 */
    /***/
    function(m, l, i) {
      var d = i(100), s = i(110), X = i(84), a = i(169).f;
      m.exports = function(e) {
        return function(n) {
          for (var G = X(n), y = s(G), o = y.length, h = 0, I = [], x; o > h; )
            x = y[h++], (!d || a.call(G, x)) && I.push(e ? [x, G[x]] : G[x]);
          return I;
        };
      };
    },
    /* 213 */
    /***/
    function(m, l, i) {
      i.r(l), i(1).glMatrix.setMatrixArrayType(Array);
      const d = /* @__PURE__ */ new Map();
      function s(a, e = {}, n = []) {
        a = a.toLowerCase();
        const G = d.get(a);
        if (!G)
          throw new TypeError(`Invalid node: ${a}`);
        const y = new G(e);
        return n.forEach((o) => {
          y.appendChild(o);
        }), y;
      }
      const X = {
        registerNode(a, e, n = 100) {
          if (e = e.toLowerCase(), d.has(e))
            throw new TypeError(`Cannot registerNode, ${e} has been taken.`);
          d.set(e, a), Object.defineProperties(a.prototype, {
            nodeType: {
              value: n
            },
            tagName: {
              value: e.toUpperCase()
            },
            nodeName: {
              value: e
            },
            ownerDocument: {
              value: X
            },
            namespaceURI: {
              value: `http://spritejs.com/${e}`
            }
          });
        },
        createElement: s,
        createElementNS(a, e) {
          return s(e);
        },
        isSpriteNode(a) {
          return d.has(a.toLowerCase());
        }
      };
      l.default = X;
    },
    /* 214 */
    /***/
    function(m, l, i) {
      i.r(l), i.d(l, "default", function() {
        return e;
      }), i(1).glMatrix.setMatrixArrayType(Array);
      const d = Symbol("type"), s = Symbol("bubbles"), X = Symbol("originalEvent"), a = Symbol("detail");
      class e {
        constructor(G, {
          bubbles: y = null
        } = {}) {
          if (typeof G == "string" ? (this[d] = G, this[s] = !!y) : (this[d] = G.type, this[X] = G, this[s] = y != null ? !!y : !!G.bubbles, G.detail && (this[a] = G.detail)), !this[d])
            throw new TypeError("Invalid event type.");
          this.cancelBubble = !1;
        }
        setOriginalEvent(G) {
          this[X] = G;
        }
        get originalEvent() {
          return this[X];
        }
        get type() {
          return this[d];
        }
        get bubbles() {
          return this[s];
        }
        get detail() {
          return this[a];
        }
        stopPropagation() {
          this.cancelBubble = !0;
        }
      }
    },
    /* 215 */
    /***/
    function(m, l, i) {
      i.r(l), i.d(l, "parseFilterString", function() {
        return s;
      }), i.d(l, "applyFilters", function() {
        return X;
      });
      var d = i(72);
      i(1).glMatrix.setMatrixArrayType(Array);
      function s(a) {
        if (a = a.trim(), !a || a === "none")
          return null;
        const e = /^(?:(url|blur|brightness|contrast|drop-shadow|grayscale|hue-rotate|invert|opacity|saturate|sepia)\(([^()]*(?:\(.*\))*[^()]*)\))+$/i, n = a.match(/(?:(url|blur|brightness|contrast|drop-shadow|grayscale|hue-rotate|invert|opacity|saturate|sepia)\(([^()]*(?:\(.*\))*[^()]*)\))+?/ig), G = [];
        return n && n.forEach((y) => {
          const o = y.match(e);
          if (!o)
            throw new TypeError("Invalid fitler string.");
          let [, h, I] = o;
          h = h.toLowerCase(), I = I.trim().match(/([^( )]+|([^( )]+\(.*\)))(?=\s|$)/g).map((x, p) => {
            let W;
            return h === "url" || h === "drop-shadow" && p === 3 ? W = x : W = Object(d.toNumber)(x), /%$/.test(x) && (W /= 100), W;
          }), G.push({
            type: h,
            args: I
          });
        }), G;
      }
      function X(a, e) {
        a.clearFilter(), e && e.forEach(({
          type: n,
          args: G
        }) => {
          let y = n;
          y === "drop-shadow" ? y = "dropShadow" : y === "hue-rotate" && (y = "hueRotate"), a[y](...G);
        });
      }
    },
    /* 216 */
    /***/
    function(m, l, i) {
      i.r(l), i.d(l, "default", function() {
        return d;
      }), i(1).glMatrix.setMatrixArrayType(Array);
      function d(s, X) {
        if (!X)
          return;
        const a = s.getListeners("beforerender"), e = s.getListeners("afterrender");
        a.length && !X.beforeRender ? X.beforeRender = (n) => {
          s.dispatchEvent({
            type: "beforerender",
            detail: {
              context: n
            }
          });
        } : a.length || (X.beforeRender = null), e.length && !X.afterRender ? X.afterRender = (n) => {
          s.dispatchEvent({
            type: "afterrender",
            detail: {
              context: n
            }
          });
        } : e.length || (X.afterRender = null);
      }
    },
    /* 217 */
    /***/
    function(m, l, i) {
      i.r(l), i.d(l, "default", function() {
        return G;
      });
      var d = i(12), s = i(218), X = i(70), a = i(213);
      i(1).glMatrix.setMatrixArrayType(Array);
      const e = Symbol("amount"), n = Symbol("meshCloud");
      class G extends X.default {
        constructor(o, h = 1) {
          super(), this.meshNode = o, o.connect(this), this[e] = h, this[n] = null;
        }
        get meshCloud() {
          const o = this.meshNode, h = this[e];
          return !this[n] && o.mesh && (this[n] = new d.MeshCloud(o.mesh, h)), this[n];
        }
        /* override */
        get isVisible() {
          return !!this.meshNode && this.meshNode.isVisible;
        }
        get amount() {
          return this[e];
        }
        set amount(o) {
          this[e] = o, this[n] && (this[n].amount = o);
        }
        brightness(o, h) {
          this.meshCloud && (this.meshCloud.brightness(o, h), this.forceUpdate());
        }
        contrast(o, h) {
          this.meshCloud && (this.meshCloud.contrast(o, h), this.forceUpdate());
        }
        delete(o) {
          this.meshCloud && (this.meshCloud.delete(o), this[e]--, this.forceUpdate());
        }
        /* override */
        draw(o = []) {
          if (super.draw(o), this.meshCloud) {
            if (this.program) {
              this.meshCloud.setProgram(this.program);
              const h = this.shaderAttrs;
              h && Object.entries(h).forEach(([x, p]) => {
                this.meshCloud.mesh.setAttribute(x, p);
              });
              const I = this.uniforms;
              if (this.uniforms) {
                const x = {};
                Object.entries(I).forEach(([p, W]) => {
                  typeof W == "function" && (W = W(this, p)), x[p] = W;
                }), this.meshCloud.mesh.setUniforms(x);
              }
            }
            this.meshNode.textureImage && Object(s.drawTexture)(this.meshNode, this.meshNode.mesh), o.push(this.meshCloud);
          }
          return o;
        }
        getTransform(o) {
          if (this.meshCloud)
            return this.meshCloud.getTransform(o);
        }
        grayscale(o, h) {
          this.meshCloud && (this.meshCloud.grayscale(o, h), this.forceUpdate());
        }
        hueRotate(o, h) {
          this.meshCloud && (this.meshCloud.hueRotate(o, h), this.forceUpdate());
        }
        invert(o, h) {
          this.meshCloud && (this.meshCloud.invert(o, h), this.forceUpdate());
        }
        /* override */
        isPointCollision(o, h) {
          if (!this.meshCloud)
            return !1;
          const I = this.attributes.pointerEvents;
          if (I === "none" || I !== "all" && !this.isVisible)
            return !1;
          let x = "both";
          I === "visibleFill" && (x = "fill"), I === "visibleStroke" && (x = "stroke");
          for (let p = 0; p < this[e]; p++)
            if (!this.meshCloud.isPointCollision(p, [o, h], x))
              return !1;
          return !0;
        }
        setOpacity(o, h) {
          this.meshCloud && (this.meshCloud.opacity(o, h), this.forceUpdate());
        }
        rotate(o, h, [I, x] = [0, 0]) {
          const p = Math.PI * h / 180;
          if (this.meshCloud) {
            const {
              x: W,
              y: V
            } = this.meshNode.attributes;
            this.meshCloud.rotate(o, p, [I + W, x + V]), this.forceUpdate();
          }
        }
        saturate(o, h) {
          this.meshCloud && (this.meshCloud.saturate(o, h), this.forceUpdate());
        }
        scale(o, [h, I = h], [x, p] = [0, 0]) {
          if (this.meshCloud) {
            const {
              x: W,
              y: V
            } = this.meshNode.attributes, t = 1e-5;
            Math.abs(h) < t && (h = 1 / h > 0 ? t : -t), Math.abs(I) < t && (I = 1 / I > 0 ? t : -t), this.meshCloud.scale(o, [h, I], [x + W, p + V]), this.forceUpdate();
          }
        }
        setColorTransform(o, h) {
          this.meshCloud && (this.meshCloud.setColorTransform(o, h), this.forceUpdate());
        }
        setFillColor(o, h) {
          this.meshCloud && (Array.isArray(h) && (h = [...h], h[0] /= 255, h[1] /= 255, h[2] /= 255), this.meshCloud.setFillColor(o, h), this.forceUpdate());
        }
        sepia(o, h) {
          this.meshCloud && (this.meshCloud.sepia(o, h), this.forceUpdate());
        }
        /* override */
        setResolution({
          width: o,
          height: h
        }) {
          super.setResolution({
            width: o,
            height: h
          }), this.meshNode.setResolution({
            width: o,
            height: h
          });
        }
        setStrokeColor(o, h) {
          this.meshCloud && (Array.isArray(h) && (h = [...h], h[0] /= 255, h[1] /= 255, h[2] /= 255), this.meshCloud.setStrokeColor(o, h), this.forceUpdate());
        }
        setTransform(o, h) {
          this.meshCloud && (this.meshCloud.setTransform(o, h), this.forceUpdate());
        }
        skew(o, [h, I = h], [x, p] = [0, 0]) {
          if (this.meshCloud) {
            const {
              x: W,
              y: V
            } = this.meshNode.attributes;
            this.meshCloud.skew(o, [h, I], [x + W, p + V]), this.forceUpdate();
          }
        }
        transform(o, h) {
          this.meshCloud && (this.meshCloud.transform(o, h), this.forceUpdate());
        }
        transformColor(o, h) {
          this.meshCloud && (this.meshCloud.transformColor(o, h), this.forceUpdate());
        }
        translate(o, [h, I]) {
          this.meshCloud && (this.meshCloud.translate(o, [h, I]), this.forceUpdate());
        }
        updateMesh() {
          this[n] && (this[n].mesh = this.meshNode.mesh, this.forceUpdate());
        }
      }
      a.default.registerNode(G, "cloud");
    },
    /* 218 */
    /***/
    function(m, l, i) {
      i.r(l), i.d(l, "loadTexture", function() {
        return a;
      }), i.d(l, "applyTexture", function() {
        return e;
      }), i.d(l, "createTexture", function() {
        return G;
      }), i.d(l, "deleteTexture", function() {
        return y;
      }), i.d(l, "drawTexture", function() {
        return h;
      }), i.d(l, "loadFrames", function() {
        return I;
      });
      var d = i(12), s = i(72);
      i(1).glMatrix.setMatrixArrayType(Array);
      const X = {};
      function a(x, p) {
        if (X[x])
          return X[x];
        const W = d.ENV.loadImage(x, {
          alias: p,
          useImageBitmap: !1
        });
        return W ?? x;
      }
      async function e(x, p, W) {
        let V = p;
        if (typeof p == "string" && (V = a(p)), V && typeof V.then == "function" && (V = await V), p === x.attributes.texture) {
          V && V.image && (V.sourceRect && (x.attributes.sourceRect = V.sourceRect), x.textureImageRotated = !!V.rotated, V = V.image);
          const {
            width: t,
            height: c,
            textureRect: b
          } = x.attributes, Z = x.textureImage;
          x.textureImage = V, W && Z !== V && !b && (t == null || c == null) && x.updateContours(), x.forceUpdate();
        }
        return V;
      }
      const n = Symbol("textureMap");
      function G(x, p) {
        if (p[n] = p[n] || /* @__PURE__ */ new Map(), p[n].has(x))
          return p[n].get(x);
        const W = p.createTexture(x);
        return !/^blob:/.test(x.src) && typeof x.getContext != "function" && p[n].set(x, W), W;
      }
      function y(x, p) {
        if (p[n] && p[n].has(x)) {
          const W = p[n].get(x);
          return p.deleteTexture(W), p[n].delete(x), !0;
        }
        return !1;
      }
      const o = Symbol("textureContext");
      function h(x, p) {
        const W = x.textureImage instanceof String ? String(x.textureImage) : x.textureImage, V = x.textureImageRotated, t = p.texture, c = x.renderer;
        if (W) {
          const b = x.originalContentRect;
          let Z = x.attributes.textureRect;
          const r = x.attributes.textureRepeat, S = x.attributes.sourceRect;
          if (!t || x[o] && x[o] !== c || t.image !== W || t.options.repeat !== r || !Object(s.compareValue)(t.options.rect, Z) || !Object(s.compareValue)(t.options.srcRect, S)) {
            const C = G(W, c);
            Z ? (Z[0] += b[0], Z[1] += b[1]) : Z = b;
            let F = null;
            t && !c[n].has(t.image) && (!t.options || !t.options.hidden) && (F = p.uniforms.u_texSampler), p.setTexture(C, {
              rect: Z,
              repeat: r,
              srcRect: S,
              rotated: V
            }), F && F.delete && F.delete(), x[o] = c;
          }
        } else if (t) {
          let b = null;
          !c[n].has(t.image) && (!t.options || !t.options.hidden) && (b = p.uniforms.u_texSampler), p.setTexture(null), b && b.delete && b.delete();
        }
      }
      async function I(x, p) {
        typeof p == "string" && (p = await (await fetch(p, {
          method: "GET",
          mode: "cors",
          cache: "default"
        })).json());
        const W = await a(x), V = p.frames;
        return Object.entries(V).forEach(([t, c]) => {
          const {
            x: b,
            y: Z,
            w: r,
            h: S
          } = c.frame;
          let C = [b, Z, r, S];
          const F = c.rotated;
          F && (C = [C[0], C[1], C[3], C[2]]), X[t] = {
            image: W,
            sourceRect: C,
            rotated: F
          };
        }), W;
      }
    },
    /* 219 */
    /***/
    function(m, l, i) {
      i.r(l), i.d(l, "default", function() {
        return I;
      });
      var d = i(1), s = i(12), X = i(70), a = i(220), e = i(221), n = i(222), G = i(213), y = i(223);
      i(1).glMatrix.setMatrixArrayType(Array);
      function o(x, p, W) {
        return p in x ? Object.defineProperty(x, p, { value: W, enumerable: !0, configurable: !0, writable: !0 }) : x[p] = W, x;
      }
      const h = Symbol("mesh");
      class I extends X.default {
        constructor(p = {}) {
          super(p);
        }
        get borderSize() {
          const {
            paddingTop: p,
            paddingRight: W,
            paddingBottom: V,
            paddingLeft: t,
            borderWidth: c
          } = this.attributes, [b, Z] = this.contentSize;
          return [t + b + W + c, p + Z + V + c];
        }
        // content + padding
        get clientSize() {
          const {
            paddingTop: p,
            paddingRight: W,
            paddingBottom: V,
            paddingLeft: t
          } = this.attributes, [c, b] = this.contentSize;
          return [t + c + W, p + b + V];
        }
        get contentSize() {
          let {
            width: p,
            height: W,
            boxSizing: V,
            paddingTop: t,
            paddingRight: c,
            paddingBottom: b,
            paddingLeft: Z
          } = this.attributes;
          if (p = p || 0, W = W || 0, V === "border-box") {
            const r = 2 * this.attributes.borderWidth;
            p -= r + c + Z, W -= r + t + b, p = Math.max(0, p), W = Math.max(0, W);
          }
          return [p, W];
        }
        get hasBorder() {
          return this.attributes.borderWidth > 0;
        }
        /* override */
        get isVisible() {
          const [p, W] = this.borderSize;
          return p > 0 && W > 0;
        }
        get mesh() {
          if (this.attributes.display === "none")
            return null;
          const p = this.clientBox;
          if (p) {
            let W = this[h];
            if (W)
              W.box !== p && (W.contours = p.contours, W.box = p);
            else {
              W = new s.Mesh2D(p), W.box = p;
              const t = this.attributes.bgcolor;
              if (Object(e.setFillColor)(W, {
                color: t
              }), this.hasBorder) {
                const {
                  borderColor: b,
                  borderWidth: Z,
                  borderDash: r,
                  borderDashOffset: S
                } = this.attributes;
                Object(e.setStrokeColor)(W, {
                  color: b,
                  lineWidth: Z,
                  lineDash: r,
                  lineDashOffset: S
                });
              }
              this[h] = W;
              const c = this.attributes.clipPath;
              c && this[h].setClipPath(c);
            }
            const V = this.opacity;
            return W.getOpacity() !== V && W.setOpacity(V), W.setTransform(...this.renderMatrix), W;
          }
          return null;
        }
        // content + padding + border
        get offsetSize() {
          const {
            paddingTop: p,
            paddingRight: W,
            paddingBottom: V,
            paddingLeft: t,
            borderWidth: c
          } = this.attributes, [b, Z] = this.contentSize, r = 2 * c;
          return [t + b + W + r, p + Z + V + r];
        }
        get originalClientRect() {
          if (this.mesh) {
            const p = this.mesh.boundingBox;
            return [p[0][0], p[0][1], p[1][0] - p[0][0], p[1][1] - p[0][1]];
          }
          return [0, 0, 0, 0];
        }
        get originalContentRect() {
          const [p, W, V, t] = this.originalClientRect, c = this.attributes.padding;
          return [p + c[0], W + c[1], V - c[0] - c[2], t - c[1] - c[3]];
        }
        getBoundingClientRect() {
          let p = this.renderMatrix;
          this.layer && this.layer.layerTransformInvert && (p = d.mat2d.multiply(Array.of(0, 0, 0, 0, 0, 0), this.layer.transformMatrix, p));
          let W = null;
          if (this.mesh) {
            W = [...this.mesh.boundingBox];
            const V = this.attributes.borderWidth;
            V && (W[0] = [W[0][0] - V, W[0][1] - V], W[1] = [W[1][0] + V, W[1][1] + V]);
          }
          return Object(y.default)(W, p);
        }
        // transformPoint(x, y) {
        //   const m = mat2d.invert(this.renderMatrix);
        //   const newX = x * m[0] + y * m[2] + m[4];
        //   const newY = x * m[1] + y * m[3] + m[5];
        //   return [newX, newY];
        // }
        /* override */
        onPropertyChange(p, W, V) {
          if (super.onPropertyChange(p, W, V), (p === "anchorX" || p === "anchorY" || p === "boxSizing" || p === "width" || p === "height" || p === "borderWidth" || p === "paddingLeft" || p === "paddingRight" || p === "paddingTop" || p === "paddingBottom" || /^border(TopLeft|TopRight|BottomRight|BottomLeft)Radius$/.test(p)) && this.updateContours(), this[h] && p === "clipPath" && this[h].setClipPath(W), this[h] && p === "bgcolor" && Object(e.setFillColor)(this[h], {
            color: W
          }), this[h] && (p === "borderColor" || p === "borderWidth" || p === "borderDash" || p === "borderDashOffset")) {
            const {
              borderColor: t,
              borderWidth: c,
              borderDash: b,
              borderDashOffset: Z
            } = this.attributes;
            Object(e.setStrokeColor)(this[h], {
              color: t,
              lineWidth: c,
              lineDash: c ? b : 0,
              lineDashOffset: Z
            });
          }
        }
        /* override */
        updateContours() {
          const {
            anchorX: p,
            anchorY: W,
            borderWidth: V,
            borderRadius: t
          } = this.attributes, [c, b] = this.borderSize, Z = this.offsetSize, r = 0.5 * V, S = -p * Z[0] + r, C = -W * Z[1] + r;
          this.clientBox = new s.Figure2D(), Object(n.createRadiusBox)(this.clientBox, [S, C, c, b], t);
        }
      }
      o(I, "Attr", a.default), G.default.registerNode(I, "block");
    },
    /* 220 */
    /***/
    function(m, l, i) {
      i.r(l), i.d(l, "default", function() {
        return y;
      });
      var d = i(71), s = i(72), X = i(221);
      i(1).glMatrix.setMatrixArrayType(Array);
      const a = Symbol.for("spritejs_setAttribute"), e = Symbol.for("spritejs_getAttribute"), n = Symbol.for("spritejs_setAttributeDefault"), G = Symbol.for("spritejs_declareAlias");
      class y extends d.default {
        constructor(h) {
          super(h), this[n]({
            anchorX: 0,
            anchorY: 0,
            /* anchor */
            width: void 0,
            height: void 0,
            /* size */
            borderWidth: 0,
            borderColor: "rgba(0,0,0,1)",
            /* border */
            borderDash: void 0,
            borderDashOffset: 0,
            borderTopLeftRadius: [0, 0],
            borderTopRightRadius: [0, 0],
            borderBottomRightRadius: [0, 0],
            borderBottomLeftRadius: [0, 0],
            /* borderRadius */
            bgcolor: "rgba(0,0,0,0)",
            paddingTop: 0,
            paddingRight: 0,
            paddingBottom: 0,
            paddingLeft: 0,
            /* padding */
            boxSizing: "content-box",
            clipPath: void 0
          }), this[G]("anchor", "size", "border", "borderRadius", "padding");
        }
        get anchorX() {
          return this[e]("anchorX");
        }
        set anchorX(h) {
          this[a]("anchorX", Object(s.toNumber)(h));
        }
        get anchorY() {
          return this[e]("anchorY");
        }
        set anchorY(h) {
          this[a]("anchorY", Object(s.toNumber)(h));
        }
        get anchor() {
          return [this.anchorX, this.anchorY];
        }
        set anchor(h) {
          h = Object(s.toArray)(h), Array.isArray(h) || (h = [h, h]), this.anchorX = h[0], this.anchorY = h[1];
        }
        get width() {
          return this[e]("width");
        }
        set width(h) {
          this[a]("width", Object(s.toNumber)(h));
        }
        get height() {
          return this[e]("height");
        }
        set height(h) {
          this[a]("height", Object(s.toNumber)(h));
        }
        get size() {
          return [this.width, this.height];
        }
        set size(h) {
          h = Object(s.toArray)(h), Array.isArray(h) || (h = [h, h]), this.width = h[0], this.height = h[1];
        }
        get borderWidth() {
          return this[e]("borderWidth");
        }
        set borderWidth(h) {
          this[a]("borderWidth", Object(s.toNumber)(h));
        }
        get borderColor() {
          return this[e]("borderColor");
        }
        set borderColor(h) {
          this[a]("borderColor", Object(X.parseColor)(h));
        }
        get border() {
          return [this.borderWidth, this.borderColor];
        }
        set border(h) {
          h = Object(s.toArray)(h), Array.isArray(h) || (h = [h]), this.borderWidth = h[0], h[1] != null && (this.borderColor = h[1]);
        }
        get borderDash() {
          return this[e]("borderDash");
        }
        set borderDash(h) {
          h = Object(s.toArray)(h, !0), h != null && !Array.isArray(h) && (h = [h]), this[a]("borderDash", h ? h.map(s.toNumber) : null);
        }
        get borderDashOffset() {
          return this[e]("borderDashOffset");
        }
        set borderDashOffset(h) {
          this[a]("borderDashOffset", Object(s.toNumber)(h));
        }
        get borderTopLeftRadius() {
          return this[e]("borderTopLeftRadius");
        }
        set borderTopLeftRadius(h) {
          h = Object(s.toArray)(h, !0), Array.isArray(h) || (h = [h, h]), this[a]("borderTopLeftRadius", h.map(s.toNumber));
        }
        get borderTopRightRadius() {
          return this[e]("borderTopRightRadius");
        }
        set borderTopRightRadius(h) {
          h = Object(s.toArray)(h, !0), Array.isArray(h) || (h = [h, h]), this[a]("borderTopRightRadius", h.map(s.toNumber));
        }
        get borderBottomRightRadius() {
          return this[e]("borderBottomRightRadius");
        }
        set borderBottomRightRadius(h) {
          h = Object(s.toArray)(h, !0), Array.isArray(h) || (h = [h, h]), this[a]("borderBottomRightRadius", h.map(s.toNumber));
        }
        get borderBottomLeftRadius() {
          return this[e]("borderBottomLeftRadius");
        }
        set borderBottomLeftRadius(h) {
          h = Object(s.toArray)(h, !0), Array.isArray(h) || (h = [h, h]), this[a]("borderBottomLeftRadius", h.map(s.toNumber));
        }
        get borderRadius() {
          return [...this.borderTopLeftRadius, ...this.borderTopRightRadius, ...this.borderBottomRightRadius, ...this.borderBottomLeftRadius];
        }
        set borderRadius(h) {
          if (h = Object(s.toArray)(h), !Array.isArray(h))
            h = Array(8).fill(h);
          else if (h.length === 2)
            h = [h[0], h[1], h[0], h[1], h[0], h[1], h[0], h[1]];
          else if (h.length === 4)
            h = [h[0], h[1], h[2], h[3], h[0], h[1], h[2], h[3]];
          else if (h.length === 6)
            h = [h[0], h[1], h[2], h[3], h[4], h[5], h[2], h[3]];
          else if (h.length !== 8)
            throw new TypeError("Invalid borderRadius value.");
          this.borderTopLeftRadius = [h[0], h[1]], this.borderTopRightRadius = [h[2], h[3]], this.borderBottomRightRadius = [h[4], h[5]], this.borderBottomLeftRadius = [h[6], h[7]];
        }
        get bgcolor() {
          return this[e]("bgcolor");
        }
        set bgcolor(h) {
          this[a]("bgcolor", Object(X.parseColor)(h));
        }
        get paddingTop() {
          return this[e]("paddingTop");
        }
        set paddingTop(h) {
          this[a]("paddingTop", Object(s.toNumber)(h));
        }
        get paddingRight() {
          return this[e]("paddingRight");
        }
        set paddingRight(h) {
          this[a]("paddingRight", Object(s.toNumber)(h));
        }
        get paddingBottom() {
          return this[e]("paddingBottom");
        }
        set paddingBottom(h) {
          this[a]("paddingBottom", Object(s.toNumber)(h));
        }
        get paddingLeft() {
          return this[e]("paddingLeft");
        }
        set paddingLeft(h) {
          this[a]("paddingLeft", Object(s.toNumber)(h));
        }
        get padding() {
          return [this.paddingTop, this.paddingRight, this.paddingBottom, this.paddingLeft];
        }
        set padding(h) {
          h = Object(s.toArray)(h), Array.isArray(h) ? h.length === 2 ? h = [h[0], h[1], h[0], h[1]] : h.length === 3 && (h = [h[0], h[1], h[2], h[1]]) : h = [h, h, h, h], this.paddingTop = h[0], this.paddingRight = h[1], this.paddingBottom = h[2], this.paddingLeft = h[3];
        }
        get clipPath() {
          return this[e]("clipPath");
        }
        set clipPath(h) {
          this[a]("clipPath", h);
        }
        get boxSizing() {
          return this[e]("boxSizing");
        }
        set boxSizing(h) {
          if (h != null && h !== "border-box" && h !== "content-box")
            throw new TypeError("Invalid boxSizing type.");
          this[a]("boxSizing", h);
        }
      }
    },
    /* 221 */
    /***/
    function(m, l, i) {
      i.r(l), i.d(l, "Gradient", function() {
        return X;
      }), i.d(l, "isTransparent", function() {
        return a;
      }), i.d(l, "parseColor", function() {
        return e;
      }), i.d(l, "setFillColor", function() {
        return G;
      }), i.d(l, "setStrokeColor", function() {
        return y;
      }), i.d(l, "Color", function() {
        return o;
      });
      var d = i(32), s = /* @__PURE__ */ i.n(d);
      i(1).glMatrix.setMatrixArrayType(Array);
      class X {
        constructor({
          vector: I,
          colors: x
        }) {
          if (!Array.isArray(I) || I.length !== 4 && I.length !== 6 && I.length !== 3)
            throw new TypeError("Invalid gradient");
          this.vector = I, this.colors = x.map(({
            offset: p,
            color: W
          }) => ({
            offset: p,
            color: e(W)
          }));
        }
        toString() {
          return JSON.stringify({
            vector: this.vector,
            colors: this.colors
          });
        }
      }
      function a(h) {
        return h instanceof X ? !1 : h == null ? !0 : s()(h)[3] === 0;
      }
      function e(h) {
        if (h == null || (h || (h = "transparent"), h instanceof X))
          return h;
        const I = s()(h);
        if (!I || !I.length)
          throw new TypeError("Invalid color value.");
        return `rgba(${I.join()})`;
      }
      function n(h, I, x) {
        const p = h.boundingBox[0];
        if (x.vector) {
          let {
            vector: W,
            colors: V
          } = x;
          W.length === 4 ? (W = [W[0] + p[0], W[1] + p[1], W[2] + p[0], W[3] + p[1]], h.setLinearGradient({
            vector: W,
            colors: V,
            type: I
          })) : W.length === 3 ? (W = [W[0] + p[0], W[1] + p[1], W[2]], h.setCircularGradient({
            vector: W,
            colors: V,
            type: I
          })) : (W = [W[0] + p[0], W[1] + p[1], W[2], W[3] + p[0], W[4] + p[1], W[5]], h.setRadialGradient({
            vector: W,
            colors: V,
            type: I
          }));
        } else
          h.gradient && h.gradient[I] && (delete h.gradient[I], delete h.uniforms.u_radialGradientVector);
      }
      function G(h, {
        color: I,
        rule: x = "nonzero"
      }) {
        return n(h, "fill", I), I.vector || h.setFill({
          color: I,
          rule: x
        }), h;
      }
      function y(h, {
        color: I,
        lineWidth: x,
        lineCap: p,
        lineJoin: W,
        lineDash: V,
        lineDashOffset: t,
        miterLimit: c,
        roundSegments: b
      }) {
        n(h, "stroke", I), I.vector && (I = [0, 0, 0, 1]), h.setStroke({
          color: I,
          thickness: x,
          cap: p,
          join: W,
          miterLimit: c,
          lineDash: V,
          lineDashOffset: t,
          roundSegments: b
        });
      }
      class o extends Array {
        constructor(I = 0, x = 0, p = 0, W = 0) {
          return Array.isArray(I) && ([I, x, p, W] = I), typeof I == "string" && ([I, x, p, W] = s()(I), I /= 255, x /= 255, p /= 255), super(I, x, p, W), this;
        }
        get r() {
          return Math.round(this[0] * 255);
        }
        set r(I) {
          this[0] = I / 255;
        }
        get g() {
          return Math.round(this[1] * 255);
        }
        set g(I) {
          this[1] = I / 255;
        }
        get b() {
          return Math.round(this[2] * 255);
        }
        set b(I) {
          this[2] = I / 255;
        }
        get a() {
          return this[3];
        }
        set a(I) {
          this[3] = I;
        }
        get hex() {
          const I = `0${this.r.toString(16)}`.slice(-2), x = `0${this.g.toString(16)}`.slice(-2), p = `0${this.b.toString(16)}`.slice(-2);
          let W;
          return this.a < 1 && (W = Math.round(this[3] * 255), W = `0${W.toString(16)}`.slice(-2)), `#${I}${x}${p}${W || ""}`;
        }
        get rgba() {
          return `rgba(${this.r},${this.g},${this.b},${this.a})`;
        }
        fromColor(I) {
          return typeof I == "string" && (I = s()(I), I[0] /= 255, I[1] /= 255, I[2] /= 255), this[0] = I[0], this[1] = I[1], this[2] = I[2], this[3] = I[3], this;
        }
      }
    },
    /* 222 */
    /***/
    function(m, l, i) {
      i.r(l), i.d(l, "createRadiusBox", function() {
        return s;
      }), i(1).glMatrix.setMatrixArrayType(Array);
      function d(X, a, e, n, G, y = "leftTop") {
        const o = 0.5522848, h = n / 2 * o, I = G / 2 * o, x = a + n, p = e + G, W = a + n / 2, V = e + G / 2;
        y === "leftTop" ? (X.moveTo(a, V), X.bezierCurveTo(a, V - I, W - h, e, W, e)) : y === "rightTop" ? X.bezierCurveTo(W + h, e, x, V - I, x, V) : y === "rightBottom" ? X.bezierCurveTo(x, V + I, W + h, p, W, p) : y === "leftBottom" && X.bezierCurveTo(W - h, p, a, V + I, a, V);
      }
      function s(X, [a, e, n, G], y) {
        if (!y || Array.isArray(y) && y.every((o) => o === 0))
          X.beginPath(), X.rect(a, e, n, G);
        else {
          typeof y == "number" && (y = Array(8).fill(y));
          const [o, h, I, x, p, W, V, t] = y.map((c, b) => b % 2 ? Math.min(c, G / 2) : Math.min(c, n / 2));
          X.beginPath(), X.moveTo(a, e + h), d(X, a, e, o * 2, h * 2, "leftTop"), X.lineTo(a + n - I, e), d(X, a + n - I * 2, e, I * 2, x * 2, "rightTop"), X.lineTo(a + n, e + G - W), d(X, a + n - p * 2, e + G - W * 2, p * 2, W * 2, "rightBottom"), X.lineTo(a + V, e + G), d(X, a, e + G - t * 2, V * 2, t * 2, "leftBottom"), X.closePath();
        }
        return X;
      }
    },
    /* 223 */
    /***/
    function(m, l, i) {
      i.r(l), i(1).glMatrix.setMatrixArrayType(Array), l.default = function(d, s) {
        if (!d)
          return {
            x: 0,
            y: 0,
            width: 0,
            height: 0,
            left: 0,
            top: 0,
            right: 0,
            bottom: 0
          };
        const [[X, a], [e, n]] = d, G = X * s[0] + a * s[2] + s[4], y = X * s[1] + a * s[3] + s[5], o = e * s[0] + a * s[2] + s[4], h = e * s[1] + a * s[3] + s[5], I = e * s[0] + n * s[2] + s[4], x = e * s[1] + n * s[3] + s[5], p = X * s[0] + n * s[2] + s[4], W = X * s[1] + n * s[3] + s[5], V = Math.min(G, o, I, p), t = Math.min(y, h, x, W), c = Math.max(G, o, I, p), b = Math.max(y, h, x, W);
        return {
          x: V,
          y: t,
          width: c - V,
          height: b - t,
          left: V,
          top: t,
          right: c,
          bottom: b
        };
      };
    },
    /* 224 */
    /***/
    function(m, l, i) {
      i.r(l), i.d(l, "default", function() {
        return G;
      });
      var d = i(218), s = i(219), X = i(225), a = i(213);
      i(1).glMatrix.setMatrixArrayType(Array);
      function e(y, o, h) {
        return o in y ? Object.defineProperty(y, o, { value: h, enumerable: !0, configurable: !0, writable: !0 }) : y[o] = h, y;
      }
      const n = Symbol("textureTask");
      class G extends s.default {
        constructor(o = {}) {
          typeof o == "string" && (o = {
            texture: o
          }), super(o);
        }
        /* override */
        get contentSize() {
          let [o, h] = super.contentSize;
          const {
            width: I,
            height: x
          } = this.attributes;
          if (I == null || x == null) {
            const p = this.textureImage, W = this.attributes.textureRect, V = this.attributes.sourceRect;
            if (W)
              I == null && (o = W[0] + W[2]), x == null && (h = W[1] + W[3]);
            else if (V) {
              const t = this.layer ? this.layer.displayRatio : 1;
              I == null && (o = V[2] / t), x == null && (h = V[3] / t);
            } else if (p) {
              const t = this.layer ? this.layer.displayRatio : 1;
              I == null && (o = p.width / t), x == null && (h = p.height / t);
            }
          }
          return [o, h];
        }
        get textureImageReady() {
          return this[n] || Promise.resolve();
        }
        /* override */
        draw(o = []) {
          super.draw(o);
          const h = this.mesh;
          return h && Object(d.drawTexture)(this, h), o;
        }
        /* override */
        onPropertyChange(o, h, I) {
          if (super.onPropertyChange(o, h, I), o === "texture" && (this[n] = Object(d.applyTexture)(this, h, !0)), o === "textureRect") {
            const {
              width: x,
              height: p
            } = this.attributes;
            (x == null || p == null) && this.updateContours();
          }
        }
      }
      e(G, "Attr", X.default), a.default.registerNode(G, "sprite");
    },
    /* 225 */
    /***/
    function(m, l, i) {
      i.r(l), i.d(l, "default", function() {
        return e;
      });
      var d = i(220);
      i(1).glMatrix.setMatrixArrayType(Array);
      const s = Symbol.for("spritejs_setAttributeDefault"), X = Symbol.for("spritejs_setAttribute"), a = Symbol.for("spritejs_getAttribute");
      class e extends d.default {
        constructor(G) {
          super(G), this[s]({
            texture: void 0,
            textureRect: void 0,
            textureRepeat: !1,
            sourceRect: void 0
          });
        }
        get texture() {
          return this[a]("texture");
        }
        set texture(G) {
          this[X]("texture", G);
        }
        get textureRect() {
          return this[a]("textureRect");
        }
        set textureRect(G) {
          this[X]("textureRect", G);
        }
        get sourceRect() {
          return this[a]("sourceRect");
        }
        set sourceRect(G) {
          this[X]("sourceRect", G);
        }
        get textureRepeat() {
          return this[a]("textureRepeat");
        }
        set textureRepeat(G) {
          this[X]("textureRepeat", !!G);
        }
      }
    },
    /* 226 */
    /***/
    function(m, l, i) {
      i.r(l), i.d(l, "default", function() {
        return x;
      });
      var d = i(12), s = i(227), X = /* @__PURE__ */ i.n(s), a = i(70), e = i(228), n = i(221), G = i(218), y = i(213), o = i(223);
      i(1).glMatrix.setMatrixArrayType(Array);
      function h(p, W, V) {
        return W in p ? Object.defineProperty(p, W, { value: V, enumerable: !0, configurable: !0, writable: !0 }) : p[W] = V, p;
      }
      const I = Symbol("mesh");
      class x extends a.default {
        constructor(W = {}) {
          typeof W == "string" && (W = {
            d: W
          }), super(W), this.effects = {
            d(V, t, c, b, Z) {
              const r = (c - b) / (Z - b);
              if (r <= 0)
                return V;
              if (r >= 1)
                return t;
              const S = X.a._preprocessing(X.a.path2shapes(V), X.a.path2shapes(t)), C = X.a._lerp(...S, r)[0];
              return C.reduce((Y, J) => `${Y}${J.slice(2).join(" ")} `, `M${C[0][0]} ${C[0][1]}C`).trim();
            }
          };
        }
        /* override */
        get isVisible() {
          return !!this.d;
        }
        get mesh() {
          if (this.attributes.display === "none")
            return null;
          const W = this.path;
          if (W) {
            let V = this[I];
            if (V)
              V.path !== W && (V.contours = W.contours, V.path = W);
            else {
              V = new d.Mesh2D(this.path), V.path = W;
              const c = this.attributes.fillColor, b = this.attributes.fillRule;
              c && Object(n.setFillColor)(V, {
                color: c,
                rule: b
              });
              const Z = this.attributes.lineWidth, r = this.attributes.strokeColor;
              if (r && Z > 0) {
                const {
                  lineCap: C,
                  lineJoin: F,
                  miterLimit: Y,
                  lineDash: J,
                  lineDashOffset: T,
                  roundSegments: K
                } = this.attributes;
                Object(n.setStrokeColor)(V, {
                  color: r,
                  lineWidth: Z,
                  lineCap: C,
                  lineJoin: F,
                  miterLimit: Y,
                  lineDash: J,
                  lineDashOffset: T,
                  roundSegments: K
                });
              }
              this[I] = V;
              const S = this.attributes.clipPath;
              S && this[I].setClipPath(S);
            }
            const t = this.opacity;
            return V.getOpacity() !== t && V.setOpacity(t), V.setTransform(...this.renderMatrix), V;
          }
          return null;
        }
        get originalContentRect() {
          if (this.path) {
            const W = this.path.boundingBox;
            return [W[0][0], W[0][1], W[1][0] - W[0][0], W[1][1] - W[0][1]];
          }
          return [0, 0, 0, 0];
        }
        get originalClientRect() {
          if (this.mesh) {
            const W = this.mesh.boundingBox;
            return [W[0][0], W[0][1], W[1][0] - W[0][0], W[1][1] - W[0][1]];
          }
          return [0, 0, 0, 0];
        }
        get originalClientCenter() {
          return this.mesh ? this.mesh.boundingCenter : [0, 0];
        }
        set d(W) {
          this.attributes.d = W;
        }
        get d() {
          return this.attributes.d;
        }
        /* override */
        draw(W = []) {
          super.draw(W);
          const V = this.mesh;
          return V && Object(G.drawTexture)(this, V), W;
        }
        getBoundingClientRect() {
          let W = null;
          return this.mesh && (W = this.mesh.boundingBox), Object(o.default)(W, this.renderMatrix);
        }
        getPathLength() {
          return this.mesh ? this.mesh.getTotalLength() : 0;
        }
        getPointAtLength(W) {
          if (this.mesh) {
            const V = this.mesh.getPointAtLength(W);
            if (V)
              return [V.x, V.y];
          }
          return [0, 0];
        }
        /* override */
        onPropertyChange(W, V, t) {
          if (super.onPropertyChange(W, V, t), (W === "d" || W === "normalize") && this.updateContours(), this[I] && (W === "fillColor" || W === "fillRule")) {
            const {
              fillColor: c,
              fillRule: b
            } = this.attributes;
            Object(n.setFillColor)(this[I], {
              color: c,
              rule: b
            });
          }
          if (this[I] && (W === "strokeColor" || W === "lineWidth" || W === "lineCap" || W === "lineJoin" || W === "lineDash" || W === "lineDashOffset" || W === "roundSegments")) {
            const {
              strokeColor: c,
              lineWidth: b
            } = this.attributes;
            if (c && b > 0) {
              const {
                lineCap: Z,
                lineJoin: r,
                lineDash: S,
                lineDashOffset: C,
                miterLimit: F,
                roundSegments: Y
              } = this.attributes;
              Object(n.setStrokeColor)(this[I], {
                color: c,
                lineCap: Z,
                lineJoin: r,
                lineWidth: b,
                lineDash: S,
                lineDashOffset: C,
                miterLimit: F,
                roundSegments: Y
              });
            }
          }
          this[I] && W === "clipPath" && this[I].setClipPath(V), W === "texture" && Object(G.applyTexture)(this, V);
        }
        /* override */
        updateContours() {
          this.path = new d.Figure2D(), this.path.addPath(this.attributes.d), this.attributes.normalize && this.path.normalize(...this.path.boundingCenter);
        }
      }
      h(x, "Attr", e.default), y.default.registerNode(x, "path");
    },
    /* 227 */
    /***/
    function(m, l, i) {
      (function(d, s) {
        m.exports = s();
      })(this, function() {
        var d = /* @__PURE__ */ function() {
          function J(T, K) {
            var R = [], H = !0, f = !1, w = void 0;
            try {
              for (var O = T[Symbol.iterator](), q; !(H = (q = O.next()).done) && (R.push(q.value), !(K && R.length === K)); H = !0)
                ;
            } catch (k) {
              f = !0, w = k;
            } finally {
              try {
                !H && O.return && O.return();
              } finally {
                if (f)
                  throw w;
              }
            }
            return R;
          }
          return function(T, K) {
            if (Array.isArray(T))
              return T;
            if (Symbol.iterator in Object(T))
              return J(T, K);
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          };
        }(), s = Math.PI * 2, X = function(T, K, R, H, f, w, O) {
          var q = T.x, k = T.y;
          q *= K, k *= R;
          var Q = H * q - f * k, D = f * q + H * k;
          return {
            x: Q + w,
            y: D + O
          };
        }, a = function(T, K) {
          var R = 1.3333333333333333 * Math.tan(K / 4), H = Math.cos(T), f = Math.sin(T), w = Math.cos(T + K), O = Math.sin(T + K);
          return [{
            x: H - f * R,
            y: f + H * R
          }, {
            x: w + O * R,
            y: O - w * R
          }, {
            x: w,
            y: O
          }];
        }, e = function(T, K, R, H) {
          var f = T * H - K * R < 0 ? -1 : 1, w = Math.sqrt(T * T + K * K), O = Math.sqrt(T * T + K * K), q = T * R + K * H, k = q / (w * O);
          return k > 1 && (k = 1), k < -1 && (k = -1), f * Math.acos(k);
        }, n = function(T, K, R, H, f, w, O, q, k, Q, D, ii) {
          var _ = Math.pow(f, 2), bi = Math.pow(w, 2), $ = Math.pow(D, 2), Xi = Math.pow(ii, 2), ni = _ * bi - _ * Xi - bi * $;
          ni < 0 && (ni = 0), ni /= _ * Xi + bi * $, ni = Math.sqrt(ni) * (O === q ? -1 : 1);
          var M = ni * f / w * ii, z = ni * -w / f * D, E = Q * M - k * z + (T + R) / 2, B = k * M + Q * z + (K + H) / 2, g = (D - M) / f, U = (ii - z) / w, u = (-D - M) / f, L = (-ii - z) / w, N = e(1, 0, g, U), v = e(g, U, u, L);
          return q === 0 && v > 0 && (v -= s), q === 1 && v < 0 && (v += s), [E, B, N, v];
        }, G = function(T) {
          var K = T.px, R = T.py, H = T.cx, f = T.cy, w = T.rx, O = T.ry, q = T.xAxisRotation, k = q === void 0 ? 0 : q, Q = T.largeArcFlag, D = Q === void 0 ? 0 : Q, ii = T.sweepFlag, _ = ii === void 0 ? 0 : ii, bi = [];
          if (w === 0 || O === 0)
            return [];
          var $ = Math.sin(k * s / 360), Xi = Math.cos(k * s / 360), ni = Xi * (K - H) / 2 + $ * (R - f) / 2, M = -$ * (K - H) / 2 + Xi * (R - f) / 2;
          if (ni === 0 && M === 0)
            return [];
          w = Math.abs(w), O = Math.abs(O);
          var z = Math.pow(ni, 2) / Math.pow(w, 2) + Math.pow(M, 2) / Math.pow(O, 2);
          z > 1 && (w *= Math.sqrt(z), O *= Math.sqrt(z));
          var E = n(K, R, H, f, w, O, D, _, $, Xi, ni, M), B = d(E, 4), g = B[0], U = B[1], u = B[2], L = B[3], N = Math.max(Math.ceil(Math.abs(L) / (s / 4)), 1);
          L /= N;
          for (var v = 0; v < N; v++)
            bi.push(a(u, L)), u += L;
          return bi.map(function(P) {
            var j = X(P[0], w, O, Xi, $, g, U), A = j.x, li = j.y, di = X(P[1], w, O, Xi, $, g, U), ci = di.x, Zi = di.y, si = X(P[2], w, O, Xi, $, g, U), ti = si.x, mi = si.y;
            return { x1: A, y1: li, x2: ci, y2: Zi, x: ti, y: mi };
          });
        }, y = {
          a: 7,
          c: 6,
          h: 1,
          l: 2,
          m: 2,
          q: 4,
          s: 4,
          t: 2,
          v: 1,
          z: 0
          /**
           * segment pattern
           * @type {RegExp}
           */
        }, o = /([astvzqmhlc])([^astvzqmhlc]*)/ig;
        function h(J) {
          var T = [];
          return J.replace(o, function(K, R, H) {
            var f = R.toLowerCase();
            for (H = x(H), f == "m" && H.length > 2 && (T.push([R].concat(H.splice(0, 2))), f = "l", R = R == "m" ? "l" : "L"); ; ) {
              if (H.length == y[f])
                return H.unshift(R), T.push(H);
              if (H.length < y[f])
                throw new Error("malformed path data");
              T.push([R].concat(H.splice(0, y[f])));
            }
          }), T;
        }
        var I = /-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/ig;
        function x(J) {
          var T = J.match(I);
          return T ? T.map(Number) : [];
        }
        function p(J) {
          var T = J[0][0], K = J[0][1], R = T, H = K;
          return J.forEach(function(f) {
            var w = f[0], O = f[2], q = f[4], k = f[6], Q = f[1], D = f[3], ii = f[5], _ = f[7];
            T = Math.min(T, w, O, q, k), K = Math.min(K, Q, D, ii, _), R = Math.max(R, w, O, q, k), H = Math.max(H, Q, D, ii, _);
          }), [T, K, R, H];
        }
        function W(J, T) {
          return Math.sqrt(Math.pow(J[0] - T[0], 2) + Math.pow(J[1] - T[1], 2)) + Math.sqrt(Math.pow(J[2] - T[2], 2) + Math.pow(J[3] - T[3], 2));
        }
        function V(J, T) {
          var K = J[0], R = J[2], H = J[4], f = J[6], w = J[1], O = J[3], q = J[5], k = J[7], Q = T[0], D = T[2], ii = T[4], _ = T[6], bi = T[1], $ = T[3], Xi = T[5], ni = T[7];
          return Math.sqrt(Math.pow(Q - K, 2) + Math.pow(bi - w, 2)) + Math.sqrt(Math.pow(D - R, 2) + Math.pow($ - O, 2)) + Math.sqrt(Math.pow(ii - H, 2) + Math.pow(Xi - q, 2)) + Math.sqrt(Math.pow(_ - f, 2) + Math.pow(ni - k, 2));
        }
        function t(J, T) {
          var K = b(J.length), R = [];
          K.forEach(function(f) {
            var w = 0, O = 0;
            f.forEach(function(q) {
              w += V(J[q], T[O++]);
            }), R.push({ index: f, distance: w });
          }), R.sort(function(f, w) {
            return f.distance - w.distance;
          });
          var H = [];
          return R[0].index.forEach(function(f) {
            H.push(J[f]);
          }), H;
        }
        function c(J, T) {
          var K = Z(J.length), R = [];
          K.forEach(function(f) {
            var w = 0;
            f.forEach(function(O) {
              w += W(p(J[O]), p(T[O]));
            }), R.push({ index: f, distance: w });
          }), R.sort(function(f, w) {
            return f.distance - w.distance;
          });
          var H = [];
          return R[0].index.forEach(function(f) {
            H.push(J[f]);
          }), H;
        }
        function b(J) {
          for (var T = [], K = 0; K < J; K++) {
            for (var R = [], H = 0; H < J; H++) {
              var f = H + K;
              f > J - 1 && (f -= J), R[f] = H;
            }
            T.push(R);
          }
          return T;
        }
        function Z(J) {
          for (var T = [], K = 0; K < J; K++)
            T.push(K);
          return r(T);
        }
        function r(J) {
          var T = [], K = [];
          function R(H) {
            var f, w;
            for (f = 0; f < H.length; f++)
              w = H.splice(f, 1)[0], K.push(w), H.length == 0 && T.push(K.slice()), R(H), H.splice(f, 0, w), K.pop();
            return T;
          }
          return R(J);
        }
        var S = {};
        S.parser = h, S.lerpCurve = function(J, T, K) {
          return S.lerpPoints(J[0], J[1], T[0], T[1], K).concat(S.lerpPoints(J[2], J[3], T[2], T[3], K)).concat(S.lerpPoints(J[4], J[5], T[4], T[5], K)).concat(S.lerpPoints(J[6], J[7], T[6], T[7], K));
        }, S.lerpPoints = function(J, T, K, R, H) {
          return [J + (K - J) * H, T + (R - T) * H];
        }, S.q2b = function(J, T, K, R, H, f) {
          return [J, T, (J + 2 * K) / 3, (T + 2 * R) / 3, (H + 2 * K) / 3, (f + 2 * R) / 3, H, f];
        }, S.path2shapes = function(J) {
          for (var T = S.parser(J), K = 0, R = 0, H = 0, f = T.length, w = [], O = null, q = void 0, k = void 0, Q = void 0, D = void 0, ii = void 0, _ = void 0, bi = void 0; H < f; H++) {
            var $ = T[H], Xi = $[0], ni = T[H - 1];
            switch (Xi) {
              case "m":
                ii = w.length, w[ii] = [], O = w[ii], K = K + $[1], R = R + $[2];
                break;
              case "M":
                ii = w.length, w[ii] = [], O = w[ii], K = $[1], R = $[2];
                break;
              case "l":
                O.push([K, R, K, R, K, R, K + $[1], R + $[2]]), K += $[1], R += $[2];
                break;
              case "L":
                O.push([K, R, $[1], $[2], $[1], $[2], $[1], $[2]]), K = $[1], R = $[2];
                break;
              case "h":
                O.push([K, R, K, R, K, R, K + $[1], R]), K += $[1];
                break;
              case "H":
                O.push([K, R, $[1], R, $[1], R, $[1], R]), K = $[1];
                break;
              case "v":
                O.push([K, R, K, R, K, R, K, R + $[1]]), R += $[1];
                break;
              case "V":
                O.push([K, R, K, $[1], K, $[1], K, $[1]]), R = $[1];
                break;
              case "C":
                O.push([K, R, $[1], $[2], $[3], $[4], $[5], $[6]]), K = $[5], R = $[6];
                break;
              case "S":
                ni[0] === "C" || ni[0] === "c" ? O.push([K, R, K + ni[5] - ni[3], R + ni[6] - ni[4], $[1], $[2], $[3], $[4]]) : (ni[0] === "S" || ni[0] === "s") && O.push([K, R, K + ni[3] - ni[1], R + ni[4] - ni[2], $[1], $[2], $[3], $[4]]), K = $[3], R = $[4];
                break;
              case "c":
                O.push([K, R, K + $[1], R + $[2], K + $[3], R + $[4], K + $[5], R + $[6]]), K = K + $[5], R = R + $[6];
                break;
              case "s":
                ni[0] === "C" || ni[0] === "c" ? O.push([K, R, K + ni[5] - ni[3], R + ni[6] - ni[4], K + $[1], R + $[2], K + $[3], R + $[4]]) : (ni[0] === "S" || ni[0] === "s") && O.push([K, R, K + ni[3] - ni[1], R + ni[4] - ni[2], K + $[1], R + $[2], K + $[3], R + $[4]]), K = K + $[3], R = R + $[4];
                break;
              case "a":
                _ = G({
                  rx: $[1],
                  ry: $[2],
                  px: K,
                  py: R,
                  xAxisRotation: $[3],
                  largeArcFlag: $[4],
                  sweepFlag: $[5],
                  cx: K + $[6],
                  cy: R + $[7]
                }), bi = _[_.length - 1], _.forEach(function(M, z) {
                  z === 0 ? O.push([K, R, M.x1, M.y1, M.x2, M.y2, M.x, M.y]) : O.push([_[z - 1].x, _[z - 1].y, M.x1, M.y1, M.x2, M.y2, M.x, M.y]);
                }), K = bi.x, R = bi.y;
                break;
              case "A":
                _ = G({
                  rx: $[1],
                  ry: $[2],
                  px: K,
                  py: R,
                  xAxisRotation: $[3],
                  largeArcFlag: $[4],
                  sweepFlag: $[5],
                  cx: $[6],
                  cy: $[7]
                }), bi = _[_.length - 1], _.forEach(function(M, z) {
                  z === 0 ? O.push([K, R, M.x1, M.y1, M.x2, M.y2, M.x, M.y]) : O.push([_[z - 1].x, _[z - 1].y, M.x1, M.y1, M.x2, M.y2, M.x, M.y]);
                }), K = bi.x, R = bi.y;
                break;
              case "Q":
                O.push(S.q2b(K, R, $[1], $[2], $[3], $[4])), K = $[3], R = $[4];
                break;
              case "q":
                O.push(S.q2b(K, R, K + $[1], R + $[2], $[3] + K, $[4] + R)), K += $[3], R += $[4];
                break;
              case "T":
                ni[0] === "Q" || ni[0] === "q" ? (Q = K + ni[3] - ni[1], D = R + ni[4] - ni[2], O.push(S.q2b(K, R, Q, D, $[1], $[2]))) : (ni[0] === "T" || ni[0] === "t") && (O.push(S.q2b(K, R, K + K - Q, R + R - D, $[1], $[2])), Q = K + K - Q, D = R + R - D), K = $[1], R = $[2];
                break;
              case "t":
                ni[0] === "Q" || ni[0] === "q" ? (Q = K + ni[3] - ni[1], D = R + ni[4] - ni[2], O.push(S.q2b(K, R, Q, D, K + $[1], R + $[2]))) : (ni[0] === "T" || ni[0] === "t") && (O.push(S.q2b(K, R, K + K - Q, R + R - D, K + $[1], R + $[2])), Q = K + K - Q, D = R + R - D), K += $[1], R += $[2];
                break;
              case "Z":
                q = O[0][0], k = O[0][1], O.push([K, R, q, k, q, k, q, k]);
                break;
              case "z":
                q = O[0][0], k = O[0][1], O.push([K, R, q, k, q, k, q, k]);
                break;
            }
          }
          return w;
        }, S._upCurves = function(J, T) {
          for (var K = 0, R = 0, H = J.length; K < T; K++)
            J.push(J[R].slice(0)), R++, R > H - 1 && (R -= H);
        };
        function C(J, T, K, R, H, f, w, O, q) {
          return {
            left: F(J, T, K, R, H, f, w, O, q),
            right: F(w, O, H, f, K, R, J, T, 1 - q, !0)
          };
        }
        function F(J, T, K, R, H, f, w, O, q, k) {
          var Q = (K - J) * q + J, D = (R - T) * q + T, ii = (H - K) * q + K, _ = (f - R) * q + R, bi = (w - H) * q + H, $ = (O - f) * q + f, Xi = (ii - Q) * q + Q, ni = (_ - D) * q + D, M = (bi - ii) * q + ii, z = ($ - _) * q + _, E = (M - Xi) * q + Xi, B = (z - ni) * q + ni;
          return k ? [E, B, Xi, ni, Q, D, J, T] : [J, T, Q, D, Xi, ni, E, B];
        }
        S._splitCurves = function(J, T) {
          for (var K = 0, R = 0; K < T; K++) {
            var H = J[R], f = C(H[0], H[1], H[2], H[3], H[4], H[5], H[6], H[7], 0.5);
            J.splice(R, 1), J.splice(R, 0, f.left, f.right), R += 2, R >= J.length - 1 && (R = 0);
          }
        };
        function Y(J, T) {
          for (var K = function(f) {
            var w = J[J.length - 1], O = [];
            w.forEach(function(q) {
              O.push(q.slice(0));
            }), J.push(O);
          }, R = 0; R < T; R++)
            K();
        }
        return S.lerp = function(J, T, K) {
          return S._lerp(S.path2shapes(J), S.path2shapes(T), K);
        }, S.MIM_CURVES_COUNT = 100, S._preprocessing = function(J, T) {
          var K = J.length, R = T.length, H = JSON.parse(JSON.stringify(J)), f = JSON.parse(JSON.stringify(T));
          return K > R ? Y(f, K - R) : K < R && Y(H, R - K), H = c(H, f), H.forEach(function(w, O) {
            var q = w.length, k = f[O].length;
            q > k ? q < S.MIM_CURVES_COUNT ? (S._splitCurves(w, S.MIM_CURVES_COUNT - q), S._splitCurves(f[O], S.MIM_CURVES_COUNT - k)) : S._splitCurves(f[O], q - k) : q < k && (k < S.MIM_CURVES_COUNT ? (S._splitCurves(w, S.MIM_CURVES_COUNT - q), S._splitCurves(f[O], S.MIM_CURVES_COUNT - k)) : S._splitCurves(w, k - q));
          }), H.forEach(function(w, O) {
            H[O] = t(w, f[O]);
          }), [H, f];
        }, S._lerp = function(J, T, K) {
          var R = [];
          return J.forEach(function(H, f) {
            var w = [];
            H.forEach(function(O, q) {
              w.push(S.lerpCurve(O, T[f][q], K));
            }), R.push(w);
          }), R;
        }, S.animate = function(J) {
          var T = S.path2shapes(J.from), K = S.path2shapes(J.to), R = S._preprocessing(T, K), H = /* @__PURE__ */ new Date(), f = J.end || function() {
          }, w = J.progress || function() {
          }, O = J.begin || function() {
          }, q = J.easing || function(_) {
            return _;
          }, k = null, Q = null, D = J.time;
          O(T);
          var ii = function _() {
            var bi = /* @__PURE__ */ new Date() - H;
            if (bi >= D) {
              Q = K, w(Q, 1), f(Q), cancelAnimationFrame(k);
              return;
            }
            var $ = q(bi / D);
            Q = S._lerp(R[0], R[1], $), w(Q, $), k = requestAnimationFrame(_);
          };
          ii();
        }, S;
      });
    },
    /* 228 */
    /***/
    function(m, l, i) {
      i.r(l), i.d(l, "default", function() {
        return G;
      });
      var d = i(71), s = i(221), X = i(72);
      i(1).glMatrix.setMatrixArrayType(Array);
      const a = Symbol.for("spritejs_setAttributeDefault"), e = Symbol.for("spritejs_setAttribute"), n = Symbol.for("spritejs_getAttribute");
      class G extends d.default {
        constructor(o) {
          super(o), this[a]({
            d: "",
            normalize: !1,
            fillColor: void 0,
            fillRule: "nonzero",
            strokeColor: void 0,
            lineWidth: 1,
            lineJoin: "miter",
            // 'miter' or 'bevel' or 'round'
            lineCap: "butt",
            // 'butt' or 'square' or 'round'
            roundSegments: 20,
            // default roundSegment if lineJoin or lineCap is round
            lineDash: void 0,
            lineDashOffset: 0,
            miterLimit: 10,
            texture: void 0,
            textureRect: void 0,
            textureRepeat: !1,
            sourceRect: void 0,
            clipPath: void 0
          });
        }
        get d() {
          return this[n]("d");
        }
        set d(o) {
          this[e]("d", o);
        }
        get normalize() {
          return this[n]("normalize");
        }
        set normalize(o) {
          this[e]("normalize", !!o);
        }
        get fillColor() {
          return this[n]("fillColor");
        }
        set fillColor(o) {
          this[e]("fillColor", Object(s.parseColor)(o));
        }
        get fillRule() {
          return this[n]("fillRule");
        }
        set fillRule(o) {
          if (o != null && o !== "nonzero" && o !== "evenodd")
            throw new TypeError("Invalid fill rule.");
          this[e]("fillRule", o);
        }
        get strokeColor() {
          return this[n]("strokeColor");
        }
        set strokeColor(o) {
          this[e]("strokeColor", Object(s.parseColor)(o));
        }
        get lineWidth() {
          return this[n]("lineWidth");
        }
        set lineWidth(o) {
          this[e]("lineWidth", Object(X.toNumber)(o));
        }
        get lineJoin() {
          return this[n]("lineJoin");
        }
        set lineJoin(o) {
          if (o != null && o !== "miter" && o !== "bevel" && o !== "round")
            throw new TypeError("Invalid lineJoin type.");
          this[e]("lineJoin", o);
        }
        get lineCap() {
          return this[n]("lineCap");
        }
        set lineCap(o) {
          if (o != null && o !== "butt" && o !== "square" && o !== "round")
            throw new TypeError("Invalid lineCap type.");
          this[e]("lineCap", o);
        }
        get lineDash() {
          return this[n]("lineDash");
        }
        set lineDash(o) {
          o = Object(X.toArray)(o, !0), o != null && !Array.isArray(o) && (o = [o]), this[e]("lineDash", o ? o.map(X.toNumber) : null);
        }
        get lineDashOffset() {
          return this[n]("lineDashOffset");
        }
        set lineDashOffset(o) {
          this[e]("lineDashOffset", Object(X.toNumber)(o));
        }
        get miterLimit() {
          return this[n]("miterLimit");
        }
        set miterLimit(o) {
          this[e]("miterLimit", Object(X.toNumber)(o));
        }
        get roundSegments() {
          return this[n]("roundSegments");
        }
        set roundSegments(o) {
          this[e]("roundSegments", o);
        }
        get texture() {
          return this[n]("texture");
        }
        set texture(o) {
          this[e]("texture", o);
        }
        get textureRect() {
          return this[n]("textureRect");
        }
        set textureRect(o) {
          this[e]("textureRect", o);
        }
        get sourceRect() {
          return this[n]("sourceRect");
        }
        set sourceRect(o) {
          this[e]("sourceRect", o);
        }
        get textureRepeat() {
          return this[n]("textureRepeat");
        }
        set textureRepeat(o) {
          this[e]("textureRepeat", !!o);
        }
        get clipPath() {
          return this[n]("clipPath");
        }
        set clipPath(o) {
          this[e]("clipPath", o);
        }
      }
    },
    /* 229 */
    /***/
    function(m, l, i) {
      i.r(l), i.d(l, "default", function() {
        return e;
      });
      var d = i(226), s = i(213), X = i(230);
      i(1).glMatrix.setMatrixArrayType(Array);
      function a(n, G, y) {
        return G in n ? Object.defineProperty(n, G, { value: y, enumerable: !0, configurable: !0, writable: !0 }) : n[G] = y, n;
      }
      class e extends d.default {
        /* override */
        get isVisible() {
          const {
            width: G,
            height: y
          } = this.attributes;
          return G > 0 && y > 0 && super.isVisible;
        }
      }
      a(e, "Attr", X.default), s.default.registerNode(e, "rect");
    },
    /* 230 */
    /***/
    function(m, l, i) {
      i.r(l), i.d(l, "default", function() {
        return y;
      });
      var d = i(228), s = i(72);
      i(1).glMatrix.setMatrixArrayType(Array);
      const X = Symbol.for("spritejs_setAttributeDefault"), a = Symbol.for("spritejs_setAttribute"), e = Symbol.for("spritejs_getAttribute"), n = Symbol.for("spritejs_declareAlias");
      function G(o) {
        const {
          width: h,
          height: I
        } = o;
        return `M0 0L${h} 0L${h} ${I}L0 ${I}Z`;
      }
      class y extends d.default {
        constructor(h) {
          super(h), this[X]({
            width: 0,
            height: 0
            /* size */
          }), this[n]("size");
        }
        // readonly
        get d() {
          return this[e]("d");
        }
        set d(h) {
        }
        // eslint-disable-line no-empty-function
        get width() {
          return this[e]("width");
        }
        set width(h) {
          if (h = Object(s.toNumber)(h), this[a]("width", h)) {
            const I = G(this);
            this[a]("d", I);
          }
        }
        get height() {
          return this[e]("height");
        }
        set height(h) {
          if (h = Object(s.toNumber)(h), this[a]("height", h)) {
            const I = G(this);
            this[a]("d", I);
          }
        }
        get size() {
          return [this.width, this.height];
        }
        set size(h) {
          h = Object(s.toArray)(h), Array.isArray(h) || (h = [h, h]), this.width = h[0], this.height = h[1];
        }
      }
    },
    /* 231 */
    /***/
    function(m, l, i) {
      i.r(l), i.d(l, "default", function() {
        return e;
      });
      var d = i(232), s = i(213), X = i(235);
      i(1).glMatrix.setMatrixArrayType(Array);
      function a(n, G, y) {
        return G in n ? Object.defineProperty(n, G, { value: y, enumerable: !0, configurable: !0, writable: !0 }) : n[G] = y, n;
      }
      class e extends d.default {
        get isVisible() {
          const {
            sides: G
          } = this.attributes;
          return G[0] > 0 && G[1] > 0 && super.isVisible;
        }
      }
      a(e, "Attr", X.default), s.default.registerNode(e, "triangle");
    },
    /* 232 */
    /***/
    function(m, l, i) {
      i.r(l), i.d(l, "default", function() {
        return e;
      });
      var d = i(226), s = i(213), X = i(233);
      i(1).glMatrix.setMatrixArrayType(Array);
      function a(n, G, y) {
        return G in n ? Object.defineProperty(n, G, { value: y, enumerable: !0, configurable: !0, writable: !0 }) : n[G] = y, n;
      }
      class e extends d.default {
        /* override */
        get isVisible() {
          const {
            points: G
          } = this.attributes;
          return G.length > 0 && super.isVisible;
        }
      }
      a(e, "Attr", X.default), s.default.registerNode(e, "polyline");
    },
    /* 233 */
    /***/
    function(m, l, i) {
      i.r(l), i.d(l, "default", function() {
        return o;
      });
      var d = i(228), s = i(72), X = i(234);
      i(1).glMatrix.setMatrixArrayType(Array);
      const a = Symbol.for("spritejs_setAttributeDefault"), e = Symbol.for("spritejs_setAttribute"), n = Symbol.for("spritejs_getAttribute"), G = Symbol.for("spritejs_declareAlias");
      function y(h) {
        const {
          points: I,
          smooth: x,
          smoothRange: p,
          close: W
        } = h, V = [];
        for (let c = 0; c < I.length; c += 2)
          V.push([I[c], I[c + 1]]);
        let t = "";
        return x ? t = Object(X.makeSmoothCurveLine)(V, p) : V.length && (t = `M${V.map((c) => c.join(" ")).join("L")}`), t && W && (t += "Z"), t;
      }
      class o extends d.default {
        constructor(I) {
          super(I), this[a]({
            points: [],
            smooth: !1,
            smoothRange: [0],
            closeType: "none"
            // none | normal
            /* close */
          }), this[G]("close");
        }
        // readonly
        get d() {
          return this[n]("d");
        }
        set d(I) {
        }
        // eslint-disable-line no-empty-function
        get close() {
          return this.closeType !== "none";
        }
        set close(I) {
          I = I ? "normal" : "none", this.closeType = I;
        }
        get closeType() {
          return this[n]("closeType");
        }
        set closeType(I) {
          if (I != null && I !== "none" && I !== "normal")
            throw new TypeError("Invalid closeType type.");
          if (this[e]("closeType", I)) {
            const x = y(this);
            this[e]("d", x);
          }
        }
        get smooth() {
          return this[n]("smooth");
        }
        set smooth(I) {
          if (this[e]("smooth", I)) {
            const x = y(this);
            this[e]("d", x);
          }
        }
        get smoothRange() {
          return this[n]("smoothRange");
        }
        set smoothRange(I) {
          if (I && !Array.isArray(I) && (I = [I]), this[e]("smoothRange", I) && this.smooth) {
            const x = y(this);
            this[e]("d", x);
          }
        }
        get points() {
          return this[n]("points");
        }
        set points(I) {
          if (I = Object(s.toArray)(I), Array.isArray(I) && (I = I.reduce((x, p) => Array.isArray(p) ? [...x, ...p.map((W) => Object(s.toNumber)(W))] : [...x, Object(s.toNumber)(p)], [])), this[e]("points", I)) {
            const x = y(this);
            this[e]("d", x);
          }
        }
      }
    },
    /* 234 */
    /***/
    function(m, l, i) {
      i.r(l), i.d(l, "makeSmoothCurveLine", function() {
        return d;
      }), i(1).glMatrix.setMatrixArrayType(Array);
      function d(s, X = [0]) {
        function a(G, y = 0.168, o = 0.168) {
          let h, I, x, p;
          if ((s[G].x === s[G + 1].x || s[G].y === s[G + 1].y) && (y = 0, o = 0), G < 1 ? (h = s[0].x + (s[1].x - s[0].x) * y, I = s[0].y + (s[1].y - s[0].y) * y) : (h = s[G].x + (s[G + 1].x - s[G - 1].x) * y, I = s[G].y + (s[G + 1].y - s[G - 1].y) * y), G > s.length - 3) {
            const W = s.length - 1;
            x = s[W].x - (s[W].x - s[W - 1].x) * o, p = s[W].y - (s[W].y - s[W - 1].y) * o;
          } else
            x = s[G + 1].x - (s[G + 2].x - s[G].x) * o, p = s[G + 1].y - (s[G + 2].y - s[G].y) * o;
          return [{
            x: h,
            y: I
          }, {
            x,
            y: p
          }];
        }
        s = s.map(([G, y]) => ({
          x: G,
          y
        }));
        let e = "", n = 0;
        return s.forEach((G, y) => {
          if (y === 0)
            e += `M${G.x} ${G.y}`;
          else {
            for (; y > X[n]; )
              n++;
            if (n % 2) {
              const [o, h] = a(y - 1);
              e += `C${[o.x, o.y, h.x, h.y, G.x, G.y].join(" ")}`;
            } else
              e += `L${G.x} ${G.y}`;
          }
        }), e;
      }
    },
    /* 235 */
    /***/
    function(m, l, i) {
      i.r(l), i.d(l, "default", function() {
        return G;
      });
      var d = i(233), s = i(72);
      i(1).glMatrix.setMatrixArrayType(Array);
      const X = Symbol.for("spritejs_setAttributeDefault"), a = Symbol.for("spritejs_setAttribute"), e = Symbol.for("spritejs_getAttribute");
      function n(y) {
        const [o, h] = y.sides;
        let I = y.angle % 360;
        return I < 0 && (I += 360), I = Math.PI * I / 180, [0, 0, o, 0, h * Math.cos(I), h * Math.sin(I)];
      }
      class G extends d.default {
        constructor(o) {
          super(o), this[X]({
            sides: [0, 0],
            angle: 60,
            closeType: "normal"
          });
        }
        // readonly
        get points() {
          return super.points;
        }
        set points(o) {
        }
        // eslint-disable-line no-empty-function
        get sides() {
          return this[e]("sides");
        }
        set sides(o) {
          if (o = Object(s.toArray)(o, !0), o != null && !Array.isArray(o) && (o = [o, o]), this[a]("sides", o)) {
            const h = n(this);
            super.points = h;
          }
        }
        get angle() {
          return this[e]("angle");
        }
        set angle(o) {
          if (o = Object(s.toNumber)(o), this[a]("angle", o)) {
            const h = n(this);
            super.points = h;
          }
        }
      }
    },
    /* 236 */
    /***/
    function(m, l, i) {
      i.r(l), i.d(l, "default", function() {
        return e;
      });
      var d = i(232), s = i(213), X = i(237);
      i(1).glMatrix.setMatrixArrayType(Array);
      function a(n, G, y) {
        return G in n ? Object.defineProperty(n, G, { value: y, enumerable: !0, configurable: !0, writable: !0 }) : n[G] = y, n;
      }
      class e extends d.default {
        /* override */
        get isVisible() {
          const {
            sides: G
          } = this.attributes;
          return G[0] > 0 && G[1] > 0 && super.isVisible;
        }
      }
      a(e, "Attr", X.default), s.default.registerNode(e, "parallel");
    },
    /* 237 */
    /***/
    function(m, l, i) {
      i.r(l), i.d(l, "default", function() {
        return G;
      });
      var d = i(233), s = i(72);
      i(1).glMatrix.setMatrixArrayType(Array);
      const X = Symbol.for("spritejs_setAttributeDefault"), a = Symbol.for("spritejs_setAttribute"), e = Symbol.for("spritejs_getAttribute");
      function n(y) {
        const [o, h] = y.sides;
        let I = y.angle % 360;
        I < 0 && (I += 360), I = Math.PI * I / 180;
        const x = h * Math.cos(I), p = h * Math.sin(I);
        return [0, 0, o, 0, x + o, p, x, p];
      }
      class G extends d.default {
        constructor(o) {
          super(o), this[X]({
            sides: [0, 0],
            angle: 90,
            closeType: "normal"
          });
        }
        // readonly
        get points() {
          return super.points;
        }
        set points(o) {
        }
        // eslint-disable-line no-empty-function
        get sides() {
          return this[e]("sides");
        }
        set sides(o) {
          if (o = Object(s.toArray)(o, !0), o != null && !Array.isArray(o) && (o = [o, o]), this[a]("sides", o)) {
            const h = n(this);
            super.points = h;
          }
        }
        get angle() {
          return this[e]("angle");
        }
        set angle(o) {
          if (o = Object(s.toNumber)(o), this[a]("angle", o)) {
            const h = n(this);
            super.points = h;
          }
        }
      }
    },
    /* 238 */
    /***/
    function(m, l, i) {
      i.r(l), i.d(l, "default", function() {
        return e;
      });
      var d = i(232), s = i(213), X = i(239);
      i(1).glMatrix.setMatrixArrayType(Array);
      function a(n, G, y) {
        return G in n ? Object.defineProperty(n, G, { value: y, enumerable: !0, configurable: !0, writable: !0 }) : n[G] = y, n;
      }
      class e extends d.default {
      }
      a(e, "Attr", X.default), s.default.registerNode(e, "regular");
    },
    /* 239 */
    /***/
    function(m, l, i) {
      i.r(l), i.d(l, "default", function() {
        return G;
      });
      var d = i(233), s = i(72);
      i(1).glMatrix.setMatrixArrayType(Array);
      const X = Symbol.for("spritejs_setAttributeDefault"), a = Symbol.for("spritejs_setAttribute"), e = Symbol.for("spritejs_getAttribute");
      function n(y) {
        const {
          edges: o,
          radius: h,
          offsetAngle: I
        } = y, x = Math.PI * I / 180 - 0.5 * Math.PI;
        if (o < 3 || h <= 0)
          return [];
        const p = [];
        for (let W = 0; W < o; W++) {
          const V = W * 2 * Math.PI / o + x, t = h * Math.cos(V), c = h * Math.sin(V);
          p.push(t, c);
        }
        return p;
      }
      class G extends d.default {
        constructor(o) {
          super(o), this[X]({
            edges: 3,
            radius: 0,
            offsetAngle: 0,
            closeType: "normal"
          });
        }
        // readonly
        get points() {
          return super.points;
        }
        set points(o) {
        }
        // eslint-disable-line no-empty-function
        get edges() {
          return this[e]("edges");
        }
        set edges(o) {
          if (o = Object(s.toNumber)(o), this[a]("edges", o)) {
            const h = n(this);
            super.points = h;
          }
        }
        get radius() {
          return this[e]("radius");
        }
        set radius(o) {
          if (o = Object(s.toNumber)(o), this[a]("radius", o)) {
            const h = n(this);
            super.points = h;
          }
        }
        get offsetAngle() {
          return this[e]("offsetAngle");
        }
        set offsetAngle(o) {
          if (o = Object(s.toNumber)(o), this[a]("offsetAngle", o)) {
            const h = n(this);
            super.points = h;
          }
        }
      }
    },
    /* 240 */
    /***/
    function(m, l, i) {
      i.r(l), i.d(l, "default", function() {
        return e;
      });
      var d = i(232), s = i(213), X = i(241);
      i(1).glMatrix.setMatrixArrayType(Array);
      function a(n, G, y) {
        return G in n ? Object.defineProperty(n, G, { value: y, enumerable: !0, configurable: !0, writable: !0 }) : n[G] = y, n;
      }
      class e extends d.default {
      }
      a(e, "Attr", X.default), s.default.registerNode(e, "star");
    },
    /* 241 */
    /***/
    function(m, l, i) {
      i.r(l), i.d(l, "default", function() {
        return G;
      });
      var d = i(233), s = i(72);
      i(1).glMatrix.setMatrixArrayType(Array);
      const X = Symbol.for("spritejs_setAttributeDefault"), a = Symbol.for("spritejs_setAttribute"), e = Symbol.for("spritejs_getAttribute");
      function n(y) {
        const {
          angles: o,
          innerRadius: h,
          outerRadius: I,
          offsetAngle: x
        } = y, p = Math.PI * x / 180 - 0.5 * Math.PI;
        if (o < 3 || h <= 0 || I <= 0)
          return [];
        const W = [];
        for (let V = 0; V < o * 2; V++) {
          const t = V * Math.PI / o + p, c = V % 2 ? h : I, b = c * Math.cos(t), Z = c * Math.sin(t);
          W.push(b, Z);
        }
        return W;
      }
      class G extends d.default {
        constructor(o) {
          super(o), this[X]({
            angles: 5,
            innerRadius: 0,
            outerRadius: 0,
            /* radius */
            offsetAngle: 0,
            closeType: "normal"
          });
        }
        // readonly
        get points() {
          return super.points;
        }
        set points(o) {
        }
        // eslint-disable-line no-empty-function
        get angles() {
          return this[e]("angles");
        }
        set angles(o) {
          if (o = Object(s.toNumber)(o), this[a]("angles", o)) {
            const h = n(this);
            super.points = h;
          }
        }
        get innerRadius() {
          return this[e]("innerRadius");
        }
        set innerRadius(o) {
          if (o = Object(s.toNumber)(o), this[a]("innerRadius", o)) {
            const h = n(this);
            super.points = h;
          }
        }
        get outerRadius() {
          return this[e]("outerRadius");
        }
        set outerRadius(o) {
          if (o = Object(s.toNumber)(o), this[a]("outerRadius", o)) {
            const h = n(this);
            super.points = h;
          }
        }
        get radius() {
          return [this.innerRadius, this.outerRadius];
        }
        set radius(o) {
          o = Object(s.toArray)(o, !0), Array.isArray(o) || (o = [o, o]), this.innerRadius = o[0], this.outerRadius = o[1];
        }
        get offsetAngle() {
          return this[e]("offsetAngle");
        }
        set offsetAngle(o) {
          if (o = Object(s.toNumber)(o), this[a]("offsetAngle", o)) {
            const h = n(this);
            super.points = h;
          }
        }
      }
    },
    /* 242 */
    /***/
    function(m, l, i) {
      i.r(l), i.d(l, "default", function() {
        return e;
      });
      var d = i(226), s = i(213), X = i(243);
      i(1).glMatrix.setMatrixArrayType(Array);
      function a(n, G, y) {
        return G in n ? Object.defineProperty(n, G, { value: y, enumerable: !0, configurable: !0, writable: !0 }) : n[G] = y, n;
      }
      class e extends d.default {
        /* override */
        get isVisible() {
          const {
            radiusX: G,
            radiusY: y,
            startAngle: o,
            endAngle: h
          } = this.attributes;
          return G > 0 && y > 0 && o !== h && super.isVisible;
        }
      }
      a(e, "Attr", X.default), s.default.registerNode(e, "ellipse");
    },
    /* 243 */
    /***/
    function(m, l, i) {
      i.r(l), i.d(l, "default", function() {
        return o;
      });
      var d = i(12), s = i(228), X = i(72);
      i(1).glMatrix.setMatrixArrayType(Array);
      const a = Symbol.for("spritejs_setAttributeDefault"), e = Symbol.for("spritejs_setAttribute"), n = Symbol.for("spritejs_getAttribute"), G = Symbol.for("spritejs_declareAlias");
      function y(h) {
        const {
          radiusX: I,
          radiusY: x,
          startAngle: p,
          endAngle: W,
          direction: V,
          closeType: t
        } = h, c = V === "anitclockwise", b = new d.Figure2D();
        return t === "sector" && b.moveTo(0, 0), b.ellipse(0, 0, I, x, 0, Math.PI * p / 180, Math.PI * W / 180, c), t !== "none" && b.closePath(), b.path.reduce((S, C) => S + C.join(" "), "");
      }
      class o extends s.default {
        constructor(I) {
          super(I), this[a]({
            radiusX: 0,
            radiusY: 0,
            /* radius */
            startAngle: 0,
            endAngle: 360,
            /* angle */
            direction: "clockwise",
            // clockwise | anticlockwise
            closeType: "none"
            // none | sector | normal
          }), this[G]("radius", "angle");
        }
        // readonly
        get d() {
          return this[n]("d");
        }
        set d(I) {
        }
        // eslint-disable-line no-empty-function
        get radiusX() {
          return this[n]("radiusX");
        }
        set radiusX(I) {
          if (I = Object(X.toNumber)(I), this[e]("radiusX", I)) {
            const x = y(this);
            this[e]("d", x);
          }
        }
        get radiusY() {
          return this[n]("radiusY");
        }
        set radiusY(I) {
          if (I = Object(X.toNumber)(I), this[e]("radiusY", I)) {
            const x = y(this);
            this[e]("d", x);
          }
        }
        get radius() {
          return [this.radiusX, this.radiusY];
        }
        set radius(I) {
          I = Object(X.toArray)(I, !0), Array.isArray(I) || (I = [I, I]), this.radiusX = I[0], this.radiusY = I[1];
        }
        get angle() {
          return [this.startAngle, this.endAngle];
        }
        set angle(I) {
          I = Object(X.toArray)(I), Array.isArray(I) || (I = [I, I]), this.startAngle = I[0], this.endAngle = I[1];
        }
        get direction() {
          return this[n]("direction");
        }
        set direction(I) {
          if (I != null && I !== "clockwise" && I !== "anticlockwise")
            throw new TypeError("Invalid direction type.");
          this[e]("direction", I);
        }
        get startAngle() {
          return this[n]("startAngle");
        }
        set startAngle(I) {
          if (I = Object(X.toNumber)(I), this[e]("startAngle", I)) {
            const x = y(this);
            this[e]("d", x);
          }
        }
        get endAngle() {
          return this[n]("endAngle");
        }
        set endAngle(I) {
          if (I = Object(X.toNumber)(I), this[e]("endAngle", I)) {
            const x = y(this);
            this[e]("d", x);
          }
        }
        get closeType() {
          return this[n]("closeType");
        }
        set closeType(I) {
          if (I != null && I !== "none" && I !== "sector" && I !== "normal")
            throw new TypeError("Invalid closeType type.");
          if (this[e]("closeType", I)) {
            const x = y(this);
            this[e]("d", x);
          }
        }
      }
    },
    /* 244 */
    /***/
    function(m, l, i) {
      i.r(l), i.d(l, "default", function() {
        return e;
      });
      var d = i(242), s = i(213), X = i(245);
      i(1).glMatrix.setMatrixArrayType(Array);
      function a(n, G, y) {
        return G in n ? Object.defineProperty(n, G, { value: y, enumerable: !0, configurable: !0, writable: !0 }) : n[G] = y, n;
      }
      class e extends d.default {
      }
      a(e, "Attr", X.default), s.default.registerNode(e, "arc");
    },
    /* 245 */
    /***/
    function(m, l, i) {
      i.r(l), i.d(l, "default", function() {
        return X;
      });
      var d = i(243), s = i(72);
      i(1).glMatrix.setMatrixArrayType(Array);
      class X extends d.default {
        get radius() {
          return super.radiusX;
        }
        set radius(e) {
          e = Object(s.toNumber)(e), super.radiusX = e, super.radiusY = e;
        }
      }
    },
    /* 246 */
    /***/
    function(m, l, i) {
      i.r(l), i.d(l, "default", function() {
        return e;
      });
      var d = i(226), s = i(213), X = i(247);
      i(1).glMatrix.setMatrixArrayType(Array);
      function a(n, G, y) {
        return G in n ? Object.defineProperty(n, G, { value: y, enumerable: !0, configurable: !0, writable: !0 }) : n[G] = y, n;
      }
      class e extends d.default {
        /* override */
        get isVisible() {
          const {
            innerRadius: G,
            outerRadius: y,
            startAngle: o,
            endAngle: h
          } = this.attributes;
          return (G > 0 || y > 0) && o !== h && super.isVisible;
        }
      }
      a(e, "Attr", X.default), s.default.registerNode(e, "ring");
    },
    /* 247 */
    /***/
    function(m, l, i) {
      i.r(l), i.d(l, "default", function() {
        return o;
      });
      var d = i(12), s = i(228), X = i(72);
      i(1).glMatrix.setMatrixArrayType(Array);
      const a = Symbol.for("spritejs_setAttributeDefault"), e = Symbol.for("spritejs_setAttribute"), n = Symbol.for("spritejs_getAttribute"), G = Symbol.for("spritejs_declareAlias");
      function y(h) {
        let {
          innerRadius: I,
          outerRadius: x,
          startAngle: p,
          endAngle: W
        } = h;
        const V = new d.Figure2D();
        if (p = Math.PI * p / 180, W = Math.PI * W / 180, I > x && ([I, x] = [x, I]), I <= 0 && V.moveTo(0, 0), V.arc(0, 0, x, p, W, !1), I > 0) {
          const b = Math.PI * 2;
          W < p && (W = p + b + (W - p) % b), W - p >= b && (W = p + b - 1e-6), V.arc(0, 0, I, W, p, !0);
        }
        return V.closePath(), V.path.reduce((b, Z) => b + Z.join(" "), "");
      }
      class o extends s.default {
        constructor(I) {
          super(I), this[a]({
            innerRadius: 0,
            outerRadius: 0,
            /* radius */
            startAngle: 0,
            endAngle: 360
            /* angle */
          }), this[G]("radius", "angle");
        }
        // readonly
        get d() {
          return this[n]("d");
        }
        set d(I) {
        }
        // eslint-disable-line no-empty-function
        get innerRadius() {
          return this[n]("innerRadius");
        }
        set innerRadius(I) {
          if (I = Object(X.toNumber)(I), this[e]("innerRadius", I)) {
            const x = y(this);
            this[e]("d", x);
          }
        }
        get outerRadius() {
          return this[n]("outerRadius");
        }
        set outerRadius(I) {
          if (I = Object(X.toNumber)(I), this[e]("outerRadius", I)) {
            const x = y(this);
            this[e]("d", x);
          }
        }
        get radius() {
          return [this.innerRadius, this.outerRadius];
        }
        set radius(I) {
          I = Object(X.toArray)(I, !0), Array.isArray(I) || (I = [I, I]), this.innerRadius = I[0], this.outerRadius = I[1];
        }
        get startAngle() {
          return this[n]("startAngle");
        }
        set startAngle(I) {
          if (I = Object(X.toNumber)(I), this[e]("startAngle", I)) {
            const x = y(this);
            this[e]("d", x);
          }
        }
        get endAngle() {
          return this[n]("endAngle");
        }
        set endAngle(I) {
          if (I = Object(X.toNumber)(I), this[e]("endAngle", I)) {
            const x = y(this);
            this[e]("d", x);
          }
        }
        get angle() {
          return [this.startAngle, this.endAngle];
        }
        set angle(I) {
          I = Object(X.toArray)(I), Array.isArray(I) || (I = [I, I]), this.startAngle = I[0], this.endAngle = I[1];
        }
      }
    },
    /* 248 */
    /***/
    function(m, l, i) {
      i.r(l), i.d(l, "default", function() {
        return x;
      });
      var d = i(12), s = i(218), X = i(219), a = i(249), e = i(213);
      i(1).glMatrix.setMatrixArrayType(Array);
      function n(p, W, V) {
        return W in p ? Object.defineProperty(p, W, { value: V, enumerable: !0, configurable: !0, writable: !0 }) : p[W] = V, p;
      }
      const G = Symbol("textImage"), y = Symbol("textImageTask"), o = Symbol("textureContext"), h = Symbol("updateTextureRect"), I = Symbol("textCanvas");
      class x extends X.default {
        constructor(W = {}) {
          typeof W == "string" && (W = {
            text: W
          }), super(W);
        }
        /* override */
        get contentSize() {
          let [W, V] = super.contentSize;
          const {
            width: t,
            height: c
          } = this.attributes;
          if (t == null || c == null) {
            const b = this[G];
            b && (t == null && (W = b.rect[2]), c == null && (V = b.rect[3]));
          }
          return [W, V];
        }
        get text() {
          return this.attributes.text;
        }
        set text(W) {
          this.attributes.text = W;
        }
        get textContent() {
          return this.attributes.text;
        }
        set textContent(W) {
          this.attributes.text = W;
        }
        get textImage() {
          return this[G] || {};
        }
        get textImageReady() {
          return this[y] || Promise.resolve();
        }
        /* override */
        draw(W) {
          super.draw(W);
          const V = this.mesh;
          if (V) {
            const t = this[G];
            if (t) {
              let c = V.texture;
              if (!c || this[o] && this[o] !== this.renderer || t.needsUpdate ? (t.needsUpdate = !1, Object(s.deleteTexture)(t.image, this.renderer), c = Object(s.createTexture)(t.image, this.renderer), this[h] = !0) : c = V.uniforms.u_texSampler, this[h]) {
                const [b, Z] = t.rect.slice(2), [r, S] = this.contentSize, C = this.attributes.textAlign, F = this.attributes.verticalAlign;
                let Y = 0;
                C === "center" ? Y = (r - b) / 2 : (C === "right" || C === "end") && (Y = r - b);
                const J = this.attributes.fontSize, T = this.attributes.lineHeight;
                let K = 0;
                F === "top" ? K = (J - T) / 2 : F === "bottom" && (K = (T - J) / 2);
                const {
                  paddingLeft: R,
                  paddingTop: H
                } = this.attributes, {
                  borderWidth: f
                } = this.attributes;
                Y += R + f, K += H + f;
                const {
                  anchorX: w,
                  anchorY: O
                } = this.attributes;
                Y -= this.offsetSize[0] * w, K -= this.offsetSize[1] * O, V.setTexture(c, {
                  rect: [Y, K, b, Z]
                }), this[h] = !1, this[o] = this.renderer;
              }
            }
          }
          return W;
        }
        /* override */
        onPropertyChange(W, V, t) {
          W === "text" || W === "fontSize" || W === "fontFamily" || W === "fontStyle" || W === "fontVariant" || W === "fontWeight" || W === "fontStretch" || W === "lineHeight" || W === "strokeColor" || W === "fillColor" || W === "strokeWidth" ? this.updateText() : ((W === "textAlign" || W === "verticalAlign") && (this[h] = !0), super.onPropertyChange(W, V, t));
        }
        /* override */
        updateContours() {
          super.updateContours(), this[h] = !0;
        }
        updateText() {
          this[y] || (this[y] = Promise.resolve().then(() => {
            this[y] = null;
            const {
              text: W,
              font: V,
              fillColor: t,
              strokeColor: c,
              strokeWidth: b
            } = this.attributes, Z = this.layer ? this.layer.displayRatio : 1;
            return this[I] = this[I] || d.ENV.createCanvas(1, 1), this[G] = d.ENV.createText(W, {
              font: V,
              fillColor: t,
              strokeColor: c,
              strokeWidth: b,
              parseFont: d.parseFont,
              ratio: Z,
              textCanvas: this[I]
            }), this[G].needsUpdate = !0, this.updateContours(), this.forceUpdate(), this[G];
          }));
        }
      }
      n(x, "Attr", a.default), e.default.registerNode(x, "label");
    },
    /* 249 */
    /***/
    function(m, l, i) {
      i.r(l), i.d(l, "default", function() {
        return o;
      });
      var d = i(12), s = i(72), X = i(221), a = i(220);
      i(1).glMatrix.setMatrixArrayType(Array);
      const e = Symbol.for("spritejs_setAttributeDefault"), n = Symbol.for("spritejs_setAttribute"), G = Symbol.for("spritejs_getAttribute"), y = Symbol.for("spritejs_declareAlias");
      class o extends a.default {
        constructor(I) {
          super(I), this[e]({
            text: "",
            fontSize: 16,
            fontFamily: "Helvetica,Arial,sans-serif",
            fontStyle: "normal",
            fontVariant: "normal",
            fontWeight: "normal",
            fontStretch: "normal",
            lineHeight: "",
            /* font */
            textAlign: "left",
            strokeColor: void 0,
            strokeWidth: 1,
            fillColor: void 0,
            verticalAlign: "middle"
          }), this[y]("font");
        }
        get text() {
          return this[G]("text") || " ";
        }
        set text(I) {
          this[n]("text", I);
        }
        get fontSize() {
          return this[G]("fontSize");
        }
        set fontSize(I) {
          this[n]("fontSize", Object(s.toNumber)(I));
        }
        get fontFamily() {
          return this[G]("fontFamily");
        }
        set fontFamily(I) {
          this[n]("fontFamily", I);
        }
        get fontStyle() {
          return this[G]("fontStyle");
        }
        set fontStyle(I) {
          this[n]("fontStyle", I);
        }
        get fontVariant() {
          return this[G]("fontVariant");
        }
        set fontVariant(I) {
          this[n]("fontVariant", I);
        }
        get fontWeight() {
          return this[G]("fontWeight");
        }
        set fontWeight(I) {
          this[n]("fontWeight", I);
        }
        get fontStretch() {
          return this[G]("fontStretch");
        }
        set fontStretch(I) {
          this[n]("fontStretch", I);
        }
        get lineHeight() {
          return this[G]("lineHeight") || this.fontSize;
        }
        set lineHeight(I) {
          this[n]("lineHeight", Object(s.toNumber)(I));
        }
        get textAlign() {
          return this[G]("textAlign");
        }
        set textAlign(I) {
          this[n]("textAlign", I);
        }
        get strokeColor() {
          return this[G]("strokeColor");
        }
        set strokeColor(I) {
          this[n]("strokeColor", Object(X.parseColor)(I));
        }
        get strokeWidth() {
          return this[G]("strokeWidth");
        }
        set strokeWidth(I) {
          this[n]("strokeWidth", Object(s.toNumber)(I));
        }
        get verticalAlign() {
          return this[G]("verticalAlign");
        }
        set verticalAlign(I) {
          this[n]("verticalAlign", I);
        }
        get fillColor() {
          return this[G]("fillColor");
        }
        set fillColor(I) {
          this[n]("fillColor", Object(X.parseColor)(I));
        }
        get font() {
          const {
            fontStyle: I,
            fontVariant: x,
            fontWeight: p,
            fontStretch: W,
            fontSize: V,
            lineHeight: t,
            fontFamily: c
          } = this;
          return `${I} ${x} ${p} ${W} ${V}px/${t}px ${c}`;
        }
        set font(I) {
          if (I == null)
            this.fontStyle = null, this.fontVariant = null, this.fontWeight = null, this.fontStretch = null, this.fontSize = null, this.lineHeight = null, this.fontFamily = null;
          else {
            const x = Object(d.parseFont)(I);
            this.fontStyle = x.style, this.fontVariant = x.variant, this.fontWeight = x.weight, this.fontStretch = x.stretch, this.fontSize = Object(s.toNumber)(`${x.size}${x.unit}`), x.lineHeight && (this.lineHeight = x.pxLineHeight), this.fontFamily = x.family;
          }
        }
      }
    },
    /* 250 */
    /***/
    function(m, l, i) {
      i.r(l), i.d(l, "default", function() {
        return I;
      });
      var d = i(12), s = i(219), X = i(251), a = i(213), e = i(252);
      i(1).glMatrix.setMatrixArrayType(Array);
      function n(x, p, W) {
        return p in x ? Object.defineProperty(x, p, { value: W, enumerable: !0, configurable: !0, writable: !0 }) : x[p] = W, x;
      }
      const G = Symbol("zOrder"), y = Symbol("ordered"), o = Symbol("children"), h = Symbol("sealed");
      class I extends s.default {
        constructor(p = {}) {
          super(p), this[o] = [], this[y] = null, this[G] = 0;
        }
        get childNodes() {
          return this[o];
        }
        get children() {
          return this[o];
        }
        get orderedChildren() {
          return this[y] || (this[y] = [...this[o]], this[y].sort((p, W) => p.zIndex - W.zIndex || p.zOrder - W.zOrder)), this[y];
        }
        append(...p) {
          return p.map((W) => this.appendChild(W));
        }
        appendChild(p) {
          return p.remove(), this[o].push(p), p.connect(this, this[G]++), this[y] && (this[y].length && p.zIndex < this[y][this[y].length - 1].zIndex ? this.reorder() : this[y].push(p)), p;
        }
        /* override */
        // get isVisible() {
        //   return this.attributes.opacity > 0 && this[_children].length > 0;
        // }
        /* override */
        cloneNode(p = !1) {
          const W = super.cloneNode();
          return p && this[o].forEach((V) => {
            const t = V.cloneNode(p);
            W.appendChild(t);
          }), W;
        }
        /* override */
        dispatchPointerEvent(p) {
          const W = this.orderedChildren;
          for (let V = W.length - 1; V >= 0; V--)
            if (W[V].dispatchPointerEvent(p))
              return !0;
          return super.dispatchPointerEvent(p);
        }
        /* override */
        draw(p = []) {
          if (this.__cacheRenderMatrix = this.renderMatrix, super.draw(p), !this[h] && this.attributes.display !== "none") {
            const W = this.orderedChildren;
            for (let V = 0; V < W.length; V++)
              W[V].draw(p);
          }
          return this.__cacheRenderMatrix = null, p;
        }
        getElementById(p) {
          return Object(e.querySelector)(`#${p}`, this);
        }
        getElementsByClassName(p) {
          return Object(e.querySelectorAll)(`.${p}`, this);
        }
        getElementsByName(p) {
          return Object(e.querySelectorAll)(`[name="${p}"]`, this);
        }
        getElementsByTagName(p) {
          return Object(e.querySelectorAll)(p, this);
        }
        insertBefore(p, W) {
          if (W == null)
            return this.appendChild(p);
          p.remove();
          const V = this[o].indexOf(W);
          if (V < 0)
            throw new Error("Invalid reference node.");
          const t = W.zOrder;
          for (let c = V; c < this[o].length; c++) {
            const b = this[o][c].zOrder, Z = this[o][c];
            delete Z.zOrder, Object.defineProperty(Z, "zOrder", {
              value: b + 1,
              writable: !1,
              configurable: !0
            });
          }
          if (this[o].splice(V, 0, p), p.connect(this, t), this[y])
            if (p.zIndex !== W.zIndex)
              this.reorder();
            else {
              const c = this[y].indexOf(W);
              this[y].splice(c, 0, p);
            }
          return p;
        }
        querySelector(p) {
          return Object(e.querySelector)(p, this);
        }
        querySelectorAll(p) {
          return Object(e.querySelectorAll)(p, this);
        }
        replaceChild(p, W) {
          p.remove();
          const V = this[o].indexOf(W);
          if (V < 0)
            throw new Error("Invalid reference node.");
          if (this[o][V] = p, p.connect(this, W.zOrder), this[y])
            if (p.zIndex !== W.zIndex)
              this.reorder();
            else {
              const t = this[y].indexOf(W);
              this[y][t] = p;
            }
          return W.disconnect(this), p;
        }
        removeAllChildren() {
          const p = this[o];
          for (let W = p.length - 1; W >= 0; W--)
            p[W].remove();
        }
        removeChild(p) {
          const W = this[o].indexOf(p);
          if (W >= 0) {
            if (this[o].splice(W, 1), this[y]) {
              const V = this[y].indexOf(p);
              this[y].splice(V, 1);
            }
            return p.disconnect(this), p;
          }
          return null;
        }
        reorder() {
          this[y] = null;
        }
        seal() {
          function p(c, b) {
            const Z = [];
            for (let r = 0; r < c.length; r++) {
              const S = [...c[r]];
              for (let C = 1; C < S.length; C += 2) {
                const F = S[C], Y = S[C + 1];
                S[C] = F * b[0] + Y * b[2] + b[4], S[C + 1] = F * b[1] + Y * b[3] + b[5];
              }
              Z.push(S);
            }
            return Z;
          }
          const W = this.orderedChildren, V = new d.Figure2D(), t = this.localMatrix;
          for (let c = 0; c < W.length; c++) {
            let b = W[c];
            if (b instanceof I && (b = b.seal()), b.clientBox) {
              let Z = b.clientBox.contours.path;
              Z = p(Z, b.localMatrix), V.addPath(Z);
            }
            if (b.path) {
              let Z = b.path.contours.path;
              Z = p(Z, b.localMatrix), V.addPath(Z);
            }
          }
          return this[h] = !0, this.clientBox = V, {
            clientBox: V,
            localMatrix: t
          };
        }
        /* override */
        setResolution({
          width: p,
          height: W
        }) {
          super.setResolution({
            width: p,
            height: W
          }), this[o].forEach((V) => {
            V.setResolution({
              width: p,
              height: W
            });
          });
        }
        /* override */
        updateContours() {
          this[h] || super.updateContours();
        }
      }
      n(I, "Attr", X.default), a.default.registerNode(I, "group");
    },
    /* 251 */
    /***/
    function(m, l, i) {
      i.r(l), i.d(l, "default", function() {
        return s;
      });
      var d = i(220);
      i(1).glMatrix.setMatrixArrayType(Array);
      class s extends d.default {
        // constructor(subject) {
        //   super(subject);
        //   this[setDefault]({
        //     pointerEvents: 'all',
        //   });
        // }
      }
    },
    /* 252 */
    /***/
    function(m, l, i) {
      i.r(l), i.d(l, "querySelectorAll", function() {
        return h;
      }), i.d(l, "querySelector", function() {
        return I;
      }), i.d(l, "isMatched", function() {
        return x;
      }), i.d(l, "compile", function() {
        return p;
      });
      var d = i(221), s = i(213);
      i(1).glMatrix.setMatrixArrayType(Array);
      const X = i(253);
      function a(W) {
        return W.nodeType === 1 || s.default.isSpriteNode(W.nodeName);
      }
      function e(W) {
        return Array.from(W.childNodes || []);
      }
      function n(W) {
        return s.default.isSpriteNode(W.nodeName) ? W.parent || W.canvas || W.container : W.parentElement;
      }
      function G(W) {
        let V = W.length, t, c, b;
        for (; --V > -1; ) {
          for (t = c = W[V], W[V] = null, b = !0; c; ) {
            if (W.indexOf(c) > -1) {
              b = !1, W.splice(V, 1);
              break;
            }
            c = n(c);
          }
          b && (W[V] = t);
        }
        return W;
      }
      const y = {
        isTag: a,
        existsOne(W, V) {
          return V.some((t) => a(t) ? W(t) || y.existsOne(W, e(t)) : !1);
        },
        getSiblings(W) {
          const V = n(W);
          return V && e(V);
        },
        getChildren: e,
        getParent: n,
        getAttributeValue(W, V) {
          if (W.nodeType === 1 && V === "class" || V === "id")
            return W[V];
          if (this.hasAttrib(W, V)) {
            let t = W.attributes[V];
            return Array.isArray(t) && (t = `[${t.join()}]`), String(t);
          }
        },
        hasAttrib(W, V) {
          return W.attributes[V] != null;
        },
        removeSubsets: G,
        getName(W) {
          return W.tagName ? W.tagName.toLowerCase() : null;
        },
        findOne: function W(V, t) {
          let c = null;
          for (let b = 0, Z = t.length; b < Z && !c; b++)
            if (V(t[b]))
              c = t[b];
            else {
              const r = e(t[b]);
              r && r.length > 0 && (c = W(V, r));
            }
          return c;
        },
        findAll: function W(V, t) {
          let c = [];
          for (let b = 0, Z = t.length; b < Z; b++) {
            if (!a(t[b]))
              continue;
            V(t[b]) && c.push(t[b]);
            const r = e(t[b]);
            r && (c = c.concat(W(V, r)));
          }
          return c;
        },
        getText: function W(V) {
          return Array.isArray(V) ? V.map(W).join("") : a(V) ? W(e(V)) : V.nodeType === 3 ? V.nodeValue : s.default.isSpriteNode(V.nodeName) ? V.text : "";
        }
      };
      function o(W) {
        if (typeof W != "string")
          return W;
        let V = W.match(/\[(bgcolor|fillColor|strokeColor|color)\s*=\s*['"]?\w+['"]?\]/g);
        return V && (V = V.map((t) => {
          const c = t.slice(1, -1).split("="), b = Object(d.parseColor)(c[1].replace(/['"]/g, ""));
          return [t, `[${c[0]}="${b}"]`];
        }), V.forEach(([t, c]) => {
          W = W.replace(t, c);
        })), V = W.match(/\[\w+\s*=\s*['"]\[.+?\]['"]\]/g), V && (V = V.map((t) => {
          const c = t.slice(1, -1).split("="), b = c[1].slice(2, -2).split(/,/g).map((Z) => Z.trim());
          return [t, `[${c[0]}="[${b}]"]`];
        }), V.forEach(([t, c]) => {
          W = W.replace(t, c);
        })), W;
      }
      function h(W, V) {
        return X.selectAll(o(W), V, {
          adapter: y
        });
      }
      function I(W, V) {
        return X.selectOne(o(W), V, {
          adapter: y
        });
      }
      function x(W, V) {
        return X.is(W, o(V), {
          adapter: y
        });
      }
      function p(W) {
        return X.compile(o(W), {
          adapter: y
        });
      }
    },
    /* 253 */
    /***/
    function(m, l, i) {
      m.exports = p;
      var d = i(254), s = i(273).falseFunc, X = i(274);
      function a(W) {
        return function(t, c, b) {
          return c = c || {}, c.adapter = c.adapter || d, W(t, c, b);
        };
      }
      var e = a(X), n = a(X.compileUnsafe);
      function G(W) {
        return function(t, c, b) {
          return b = b || {}, b.adapter = b.adapter || d, typeof t != "function" && (t = n(t, b, c)), t.shouldTestNextSiblings && (c = o(b && b.context || c, b.adapter)), Array.isArray(c) ? c = b.adapter.removeSubsets(c) : c = b.adapter.getChildren(c), W(t, c, b);
        };
      }
      function y(W, V) {
        var t = V.getSiblings(W);
        if (!Array.isArray(t))
          return [];
        for (t = t.slice(0); t.shift() !== W; )
          ;
        return t;
      }
      function o(W, V) {
        Array.isArray(W) || (W = [W]);
        for (var t = W.slice(0), c = 0, b = W.length; c < b; c++) {
          var Z = y(t[c], V);
          t.push.apply(t, Z);
        }
        return t;
      }
      var h = G(function(V, t, c) {
        return V === s || !t || t.length === 0 ? [] : c.adapter.findAll(V, t);
      }), I = G(function(V, t, c) {
        return V === s || !t || t.length === 0 ? null : c.adapter.findOne(V, t);
      });
      function x(W, V, t) {
        return t = t || {}, t.adapter = t.adapter || d, (typeof V == "function" ? V : e(V, t))(W);
      }
      function p(W, V, t) {
        return h(W, V, t);
      }
      p.compile = e, p.filters = X.Pseudos.filters, p.pseudos = X.Pseudos.pseudos, p.selectAll = h, p.selectOne = I, p.is = x, p.parse = e, p.iterate = h, p._compileUnsafe = n, p._compileToken = X.compileToken;
    },
    /* 254 */
    /***/
    function(m, l, i) {
      var d = m.exports;
      [
        i(255),
        i(268),
        i(269),
        i(270),
        i(271),
        i(272)
      ].forEach(function(s) {
        Object.keys(s).forEach(function(X) {
          d[X] = s[X].bind(d);
        });
      });
    },
    /* 255 */
    /***/
    function(m, l, i) {
      var d = i(256), s = i(257), X = d.isTag;
      m.exports = {
        getInnerHTML: a,
        getOuterHTML: s,
        getText: e
      };
      function a(n, G) {
        return n.children ? n.children.map(function(y) {
          return s(y, G);
        }).join("") : "";
      }
      function e(n) {
        return Array.isArray(n) ? n.map(e).join("") : X(n) ? n.name === "br" ? `
` : e(n.children) : n.type === d.CDATA ? e(n.children) : n.type === d.Text ? n.data : "";
      }
    },
    /* 256 */
    /***/
    function(m, l) {
      m.exports = {
        Text: "text",
        //Text
        Directive: "directive",
        //<? ... ?>
        Comment: "comment",
        //<!-- ... -->
        Script: "script",
        //<script> tags
        Style: "style",
        //<style> tags
        Tag: "tag",
        //Any tag
        CDATA: "cdata",
        //<![CDATA[ ... ]]>
        Doctype: "doctype",
        isTag: function(i) {
          return i.type === "tag" || i.type === "script" || i.type === "style";
        }
      };
    },
    /* 257 */
    /***/
    function(m, l, i) {
      var d = i(258), s = i(259), X = i(267);
      X.elementNames.__proto__ = null, X.attributeNames.__proto__ = null;
      var a = {
        __proto__: null,
        style: !0,
        script: !0,
        xmp: !0,
        iframe: !0,
        noembed: !0,
        noframes: !0,
        plaintext: !0,
        noscript: !0
      };
      function e(W, V) {
        if (W) {
          var t = "", c;
          for (var b in W)
            c = W[b], t && (t += " "), V.xmlMode === "foreign" && (b = X.attributeNames[b] || b), t += b, (c !== null && c !== "" || V.xmlMode) && (t += '="' + (V.decodeEntities ? s.encodeXML(c) : c.replace(/\"/g, "&quot;")) + '"');
          return t;
        }
      }
      var n = {
        __proto__: null,
        area: !0,
        base: !0,
        basefont: !0,
        br: !0,
        col: !0,
        command: !0,
        embed: !0,
        frame: !0,
        hr: !0,
        img: !0,
        input: !0,
        isindex: !0,
        keygen: !0,
        link: !0,
        meta: !0,
        param: !0,
        source: !0,
        track: !0,
        wbr: !0
      }, G = m.exports = function(W, V) {
        !Array.isArray(W) && !W.cheerio && (W = [W]), V = V || {};
        for (var t = "", c = 0; c < W.length; c++) {
          var b = W[c];
          b.type === "root" ? t += G(b.children, V) : d.isTag(b) ? t += o(b, V) : b.type === d.Directive ? t += h(b) : b.type === d.Comment ? t += p(b) : b.type === d.CDATA ? t += x(b) : t += I(b, V);
        }
        return t;
      }, y = [
        "mi",
        "mo",
        "mn",
        "ms",
        "mtext",
        "annotation-xml",
        "foreignObject",
        "desc",
        "title"
      ];
      function o(W, V) {
        V.xmlMode === "foreign" && (W.name = X.elementNames[W.name] || W.name, W.parent && y.indexOf(W.parent.name) >= 0 && (V = Object.assign({}, V, { xmlMode: !1 }))), !V.xmlMode && ["svg", "math"].indexOf(W.name) >= 0 && (V = Object.assign({}, V, { xmlMode: "foreign" }));
        var t = "<" + W.name, c = e(W.attribs, V);
        return c && (t += " " + c), V.xmlMode && (!W.children || W.children.length === 0) ? t += "/>" : (t += ">", W.children && (t += G(W.children, V)), (!n[W.name] || V.xmlMode) && (t += "</" + W.name + ">")), t;
      }
      function h(W) {
        return "<" + W.data + ">";
      }
      function I(W, V) {
        var t = W.data || "";
        return V.decodeEntities && !(W.parent && W.parent.name in a) && (t = s.encodeXML(t)), t;
      }
      function x(W) {
        return "<![CDATA[" + W.children[0].data + "]]>";
      }
      function p(W) {
        return "<!--" + W.data + "-->";
      }
    },
    /* 258 */
    /***/
    function(m, l, i) {
      Object.defineProperty(l, "__esModule", { value: !0 });
      function d(s) {
        return s.type === "tag" || s.type === "script" || s.type === "style";
      }
      l.isTag = d, l.Text = "text", l.Directive = "directive", l.Comment = "comment", l.Script = "script", l.Style = "style", l.Tag = "tag", l.CDATA = "cdata", l.Doctype = "doctype";
    },
    /* 259 */
    /***/
    function(m, l, i) {
      Object.defineProperty(l, "__esModule", { value: !0 }), l.encode = l.decodeStrict = l.decode = void 0;
      var d = i(260), s = i(266);
      function X(y, o) {
        return (!o || o <= 0 ? d.decodeXML : d.decodeHTML)(y);
      }
      l.decode = X;
      function a(y, o) {
        return (!o || o <= 0 ? d.decodeXML : d.decodeHTMLStrict)(y);
      }
      l.decodeStrict = a;
      function e(y, o) {
        return (!o || o <= 0 ? s.encodeXML : s.encodeHTML)(y);
      }
      l.encode = e;
      var n = i(266);
      Object.defineProperty(l, "encodeXML", { enumerable: !0, get: function() {
        return n.encodeXML;
      } }), Object.defineProperty(l, "encodeHTML", { enumerable: !0, get: function() {
        return n.encodeHTML;
      } }), Object.defineProperty(l, "escape", { enumerable: !0, get: function() {
        return n.escape;
      } }), Object.defineProperty(l, "encodeHTML4", { enumerable: !0, get: function() {
        return n.encodeHTML;
      } }), Object.defineProperty(l, "encodeHTML5", { enumerable: !0, get: function() {
        return n.encodeHTML;
      } });
      var G = i(260);
      Object.defineProperty(l, "decodeXML", { enumerable: !0, get: function() {
        return G.decodeXML;
      } }), Object.defineProperty(l, "decodeHTML", { enumerable: !0, get: function() {
        return G.decodeHTML;
      } }), Object.defineProperty(l, "decodeHTMLStrict", { enumerable: !0, get: function() {
        return G.decodeHTMLStrict;
      } }), Object.defineProperty(l, "decodeHTML4", { enumerable: !0, get: function() {
        return G.decodeHTML;
      } }), Object.defineProperty(l, "decodeHTML5", { enumerable: !0, get: function() {
        return G.decodeHTML;
      } }), Object.defineProperty(l, "decodeHTML4Strict", { enumerable: !0, get: function() {
        return G.decodeHTMLStrict;
      } }), Object.defineProperty(l, "decodeHTML5Strict", { enumerable: !0, get: function() {
        return G.decodeHTMLStrict;
      } }), Object.defineProperty(l, "decodeXMLStrict", { enumerable: !0, get: function() {
        return G.decodeXML;
      } });
    },
    /* 260 */
    /***/
    function(m, l, i) {
      var d = this && this.__importDefault || function(o) {
        return o && o.__esModule ? o : { default: o };
      };
      Object.defineProperty(l, "__esModule", { value: !0 }), l.decodeHTML = l.decodeHTMLStrict = l.decodeXML = void 0;
      var s = d(i(261)), X = d(i(262)), a = d(i(263)), e = d(i(264));
      l.decodeXML = n(a.default), l.decodeHTMLStrict = n(s.default);
      function n(o) {
        var h = Object.keys(o).join("|"), I = y(o);
        h += "|#[xX][\\da-fA-F]+|#\\d+";
        var x = new RegExp("&(?:" + h + ");", "g");
        return function(p) {
          return String(p).replace(x, I);
        };
      }
      var G = function(o, h) {
        return o < h ? 1 : -1;
      };
      l.decodeHTML = function() {
        for (var o = Object.keys(X.default).sort(G), h = Object.keys(s.default).sort(G), I = 0, x = 0; I < h.length; I++)
          o[x] === h[I] ? (h[I] += ";?", x++) : h[I] += ";";
        var p = new RegExp("&(?:" + h.join("|") + "|#[xX][\\da-fA-F]+;?|#\\d+;?)", "g"), W = y(s.default);
        function V(t) {
          return t.substr(-1) !== ";" && (t += ";"), W(t);
        }
        return function(t) {
          return String(t).replace(p, V);
        };
      }();
      function y(o) {
        return function(I) {
          if (I.charAt(1) === "#") {
            var x = I.charAt(2);
            return x === "X" || x === "x" ? e.default(parseInt(I.substr(3), 16)) : e.default(parseInt(I.substr(2), 10));
          }
          return o[I.slice(1, -1)];
        };
      }
    },
    /* 261 */
    /***/
    function(m) {
      m.exports = JSON.parse('{"Aacute":"Á","aacute":"á","Abreve":"Ă","abreve":"ă","ac":"∾","acd":"∿","acE":"∾̳","Acirc":"Â","acirc":"â","acute":"´","Acy":"А","acy":"а","AElig":"Æ","aelig":"æ","af":"⁡","Afr":"𝔄","afr":"𝔞","Agrave":"À","agrave":"à","alefsym":"ℵ","aleph":"ℵ","Alpha":"Α","alpha":"α","Amacr":"Ā","amacr":"ā","amalg":"⨿","amp":"&","AMP":"&","andand":"⩕","And":"⩓","and":"∧","andd":"⩜","andslope":"⩘","andv":"⩚","ang":"∠","ange":"⦤","angle":"∠","angmsdaa":"⦨","angmsdab":"⦩","angmsdac":"⦪","angmsdad":"⦫","angmsdae":"⦬","angmsdaf":"⦭","angmsdag":"⦮","angmsdah":"⦯","angmsd":"∡","angrt":"∟","angrtvb":"⊾","angrtvbd":"⦝","angsph":"∢","angst":"Å","angzarr":"⍼","Aogon":"Ą","aogon":"ą","Aopf":"𝔸","aopf":"𝕒","apacir":"⩯","ap":"≈","apE":"⩰","ape":"≊","apid":"≋","apos":"\'","ApplyFunction":"⁡","approx":"≈","approxeq":"≊","Aring":"Å","aring":"å","Ascr":"𝒜","ascr":"𝒶","Assign":"≔","ast":"*","asymp":"≈","asympeq":"≍","Atilde":"Ã","atilde":"ã","Auml":"Ä","auml":"ä","awconint":"∳","awint":"⨑","backcong":"≌","backepsilon":"϶","backprime":"‵","backsim":"∽","backsimeq":"⋍","Backslash":"∖","Barv":"⫧","barvee":"⊽","barwed":"⌅","Barwed":"⌆","barwedge":"⌅","bbrk":"⎵","bbrktbrk":"⎶","bcong":"≌","Bcy":"Б","bcy":"б","bdquo":"„","becaus":"∵","because":"∵","Because":"∵","bemptyv":"⦰","bepsi":"϶","bernou":"ℬ","Bernoullis":"ℬ","Beta":"Β","beta":"β","beth":"ℶ","between":"≬","Bfr":"𝔅","bfr":"𝔟","bigcap":"⋂","bigcirc":"◯","bigcup":"⋃","bigodot":"⨀","bigoplus":"⨁","bigotimes":"⨂","bigsqcup":"⨆","bigstar":"★","bigtriangledown":"▽","bigtriangleup":"△","biguplus":"⨄","bigvee":"⋁","bigwedge":"⋀","bkarow":"⤍","blacklozenge":"⧫","blacksquare":"▪","blacktriangle":"▴","blacktriangledown":"▾","blacktriangleleft":"◂","blacktriangleright":"▸","blank":"␣","blk12":"▒","blk14":"░","blk34":"▓","block":"█","bne":"=⃥","bnequiv":"≡⃥","bNot":"⫭","bnot":"⌐","Bopf":"𝔹","bopf":"𝕓","bot":"⊥","bottom":"⊥","bowtie":"⋈","boxbox":"⧉","boxdl":"┐","boxdL":"╕","boxDl":"╖","boxDL":"╗","boxdr":"┌","boxdR":"╒","boxDr":"╓","boxDR":"╔","boxh":"─","boxH":"═","boxhd":"┬","boxHd":"╤","boxhD":"╥","boxHD":"╦","boxhu":"┴","boxHu":"╧","boxhU":"╨","boxHU":"╩","boxminus":"⊟","boxplus":"⊞","boxtimes":"⊠","boxul":"┘","boxuL":"╛","boxUl":"╜","boxUL":"╝","boxur":"└","boxuR":"╘","boxUr":"╙","boxUR":"╚","boxv":"│","boxV":"║","boxvh":"┼","boxvH":"╪","boxVh":"╫","boxVH":"╬","boxvl":"┤","boxvL":"╡","boxVl":"╢","boxVL":"╣","boxvr":"├","boxvR":"╞","boxVr":"╟","boxVR":"╠","bprime":"‵","breve":"˘","Breve":"˘","brvbar":"¦","bscr":"𝒷","Bscr":"ℬ","bsemi":"⁏","bsim":"∽","bsime":"⋍","bsolb":"⧅","bsol":"\\\\","bsolhsub":"⟈","bull":"•","bullet":"•","bump":"≎","bumpE":"⪮","bumpe":"≏","Bumpeq":"≎","bumpeq":"≏","Cacute":"Ć","cacute":"ć","capand":"⩄","capbrcup":"⩉","capcap":"⩋","cap":"∩","Cap":"⋒","capcup":"⩇","capdot":"⩀","CapitalDifferentialD":"ⅅ","caps":"∩︀","caret":"⁁","caron":"ˇ","Cayleys":"ℭ","ccaps":"⩍","Ccaron":"Č","ccaron":"č","Ccedil":"Ç","ccedil":"ç","Ccirc":"Ĉ","ccirc":"ĉ","Cconint":"∰","ccups":"⩌","ccupssm":"⩐","Cdot":"Ċ","cdot":"ċ","cedil":"¸","Cedilla":"¸","cemptyv":"⦲","cent":"¢","centerdot":"·","CenterDot":"·","cfr":"𝔠","Cfr":"ℭ","CHcy":"Ч","chcy":"ч","check":"✓","checkmark":"✓","Chi":"Χ","chi":"χ","circ":"ˆ","circeq":"≗","circlearrowleft":"↺","circlearrowright":"↻","circledast":"⊛","circledcirc":"⊚","circleddash":"⊝","CircleDot":"⊙","circledR":"®","circledS":"Ⓢ","CircleMinus":"⊖","CirclePlus":"⊕","CircleTimes":"⊗","cir":"○","cirE":"⧃","cire":"≗","cirfnint":"⨐","cirmid":"⫯","cirscir":"⧂","ClockwiseContourIntegral":"∲","CloseCurlyDoubleQuote":"”","CloseCurlyQuote":"’","clubs":"♣","clubsuit":"♣","colon":":","Colon":"∷","Colone":"⩴","colone":"≔","coloneq":"≔","comma":",","commat":"@","comp":"∁","compfn":"∘","complement":"∁","complexes":"ℂ","cong":"≅","congdot":"⩭","Congruent":"≡","conint":"∮","Conint":"∯","ContourIntegral":"∮","copf":"𝕔","Copf":"ℂ","coprod":"∐","Coproduct":"∐","copy":"©","COPY":"©","copysr":"℗","CounterClockwiseContourIntegral":"∳","crarr":"↵","cross":"✗","Cross":"⨯","Cscr":"𝒞","cscr":"𝒸","csub":"⫏","csube":"⫑","csup":"⫐","csupe":"⫒","ctdot":"⋯","cudarrl":"⤸","cudarrr":"⤵","cuepr":"⋞","cuesc":"⋟","cularr":"↶","cularrp":"⤽","cupbrcap":"⩈","cupcap":"⩆","CupCap":"≍","cup":"∪","Cup":"⋓","cupcup":"⩊","cupdot":"⊍","cupor":"⩅","cups":"∪︀","curarr":"↷","curarrm":"⤼","curlyeqprec":"⋞","curlyeqsucc":"⋟","curlyvee":"⋎","curlywedge":"⋏","curren":"¤","curvearrowleft":"↶","curvearrowright":"↷","cuvee":"⋎","cuwed":"⋏","cwconint":"∲","cwint":"∱","cylcty":"⌭","dagger":"†","Dagger":"‡","daleth":"ℸ","darr":"↓","Darr":"↡","dArr":"⇓","dash":"‐","Dashv":"⫤","dashv":"⊣","dbkarow":"⤏","dblac":"˝","Dcaron":"Ď","dcaron":"ď","Dcy":"Д","dcy":"д","ddagger":"‡","ddarr":"⇊","DD":"ⅅ","dd":"ⅆ","DDotrahd":"⤑","ddotseq":"⩷","deg":"°","Del":"∇","Delta":"Δ","delta":"δ","demptyv":"⦱","dfisht":"⥿","Dfr":"𝔇","dfr":"𝔡","dHar":"⥥","dharl":"⇃","dharr":"⇂","DiacriticalAcute":"´","DiacriticalDot":"˙","DiacriticalDoubleAcute":"˝","DiacriticalGrave":"`","DiacriticalTilde":"˜","diam":"⋄","diamond":"⋄","Diamond":"⋄","diamondsuit":"♦","diams":"♦","die":"¨","DifferentialD":"ⅆ","digamma":"ϝ","disin":"⋲","div":"÷","divide":"÷","divideontimes":"⋇","divonx":"⋇","DJcy":"Ђ","djcy":"ђ","dlcorn":"⌞","dlcrop":"⌍","dollar":"$","Dopf":"𝔻","dopf":"𝕕","Dot":"¨","dot":"˙","DotDot":"⃜","doteq":"≐","doteqdot":"≑","DotEqual":"≐","dotminus":"∸","dotplus":"∔","dotsquare":"⊡","doublebarwedge":"⌆","DoubleContourIntegral":"∯","DoubleDot":"¨","DoubleDownArrow":"⇓","DoubleLeftArrow":"⇐","DoubleLeftRightArrow":"⇔","DoubleLeftTee":"⫤","DoubleLongLeftArrow":"⟸","DoubleLongLeftRightArrow":"⟺","DoubleLongRightArrow":"⟹","DoubleRightArrow":"⇒","DoubleRightTee":"⊨","DoubleUpArrow":"⇑","DoubleUpDownArrow":"⇕","DoubleVerticalBar":"∥","DownArrowBar":"⤓","downarrow":"↓","DownArrow":"↓","Downarrow":"⇓","DownArrowUpArrow":"⇵","DownBreve":"̑","downdownarrows":"⇊","downharpoonleft":"⇃","downharpoonright":"⇂","DownLeftRightVector":"⥐","DownLeftTeeVector":"⥞","DownLeftVectorBar":"⥖","DownLeftVector":"↽","DownRightTeeVector":"⥟","DownRightVectorBar":"⥗","DownRightVector":"⇁","DownTeeArrow":"↧","DownTee":"⊤","drbkarow":"⤐","drcorn":"⌟","drcrop":"⌌","Dscr":"𝒟","dscr":"𝒹","DScy":"Ѕ","dscy":"ѕ","dsol":"⧶","Dstrok":"Đ","dstrok":"đ","dtdot":"⋱","dtri":"▿","dtrif":"▾","duarr":"⇵","duhar":"⥯","dwangle":"⦦","DZcy":"Џ","dzcy":"џ","dzigrarr":"⟿","Eacute":"É","eacute":"é","easter":"⩮","Ecaron":"Ě","ecaron":"ě","Ecirc":"Ê","ecirc":"ê","ecir":"≖","ecolon":"≕","Ecy":"Э","ecy":"э","eDDot":"⩷","Edot":"Ė","edot":"ė","eDot":"≑","ee":"ⅇ","efDot":"≒","Efr":"𝔈","efr":"𝔢","eg":"⪚","Egrave":"È","egrave":"è","egs":"⪖","egsdot":"⪘","el":"⪙","Element":"∈","elinters":"⏧","ell":"ℓ","els":"⪕","elsdot":"⪗","Emacr":"Ē","emacr":"ē","empty":"∅","emptyset":"∅","EmptySmallSquare":"◻","emptyv":"∅","EmptyVerySmallSquare":"▫","emsp13":" ","emsp14":" ","emsp":" ","ENG":"Ŋ","eng":"ŋ","ensp":" ","Eogon":"Ę","eogon":"ę","Eopf":"𝔼","eopf":"𝕖","epar":"⋕","eparsl":"⧣","eplus":"⩱","epsi":"ε","Epsilon":"Ε","epsilon":"ε","epsiv":"ϵ","eqcirc":"≖","eqcolon":"≕","eqsim":"≂","eqslantgtr":"⪖","eqslantless":"⪕","Equal":"⩵","equals":"=","EqualTilde":"≂","equest":"≟","Equilibrium":"⇌","equiv":"≡","equivDD":"⩸","eqvparsl":"⧥","erarr":"⥱","erDot":"≓","escr":"ℯ","Escr":"ℰ","esdot":"≐","Esim":"⩳","esim":"≂","Eta":"Η","eta":"η","ETH":"Ð","eth":"ð","Euml":"Ë","euml":"ë","euro":"€","excl":"!","exist":"∃","Exists":"∃","expectation":"ℰ","exponentiale":"ⅇ","ExponentialE":"ⅇ","fallingdotseq":"≒","Fcy":"Ф","fcy":"ф","female":"♀","ffilig":"ﬃ","fflig":"ﬀ","ffllig":"ﬄ","Ffr":"𝔉","ffr":"𝔣","filig":"ﬁ","FilledSmallSquare":"◼","FilledVerySmallSquare":"▪","fjlig":"fj","flat":"♭","fllig":"ﬂ","fltns":"▱","fnof":"ƒ","Fopf":"𝔽","fopf":"𝕗","forall":"∀","ForAll":"∀","fork":"⋔","forkv":"⫙","Fouriertrf":"ℱ","fpartint":"⨍","frac12":"½","frac13":"⅓","frac14":"¼","frac15":"⅕","frac16":"⅙","frac18":"⅛","frac23":"⅔","frac25":"⅖","frac34":"¾","frac35":"⅗","frac38":"⅜","frac45":"⅘","frac56":"⅚","frac58":"⅝","frac78":"⅞","frasl":"⁄","frown":"⌢","fscr":"𝒻","Fscr":"ℱ","gacute":"ǵ","Gamma":"Γ","gamma":"γ","Gammad":"Ϝ","gammad":"ϝ","gap":"⪆","Gbreve":"Ğ","gbreve":"ğ","Gcedil":"Ģ","Gcirc":"Ĝ","gcirc":"ĝ","Gcy":"Г","gcy":"г","Gdot":"Ġ","gdot":"ġ","ge":"≥","gE":"≧","gEl":"⪌","gel":"⋛","geq":"≥","geqq":"≧","geqslant":"⩾","gescc":"⪩","ges":"⩾","gesdot":"⪀","gesdoto":"⪂","gesdotol":"⪄","gesl":"⋛︀","gesles":"⪔","Gfr":"𝔊","gfr":"𝔤","gg":"≫","Gg":"⋙","ggg":"⋙","gimel":"ℷ","GJcy":"Ѓ","gjcy":"ѓ","gla":"⪥","gl":"≷","glE":"⪒","glj":"⪤","gnap":"⪊","gnapprox":"⪊","gne":"⪈","gnE":"≩","gneq":"⪈","gneqq":"≩","gnsim":"⋧","Gopf":"𝔾","gopf":"𝕘","grave":"`","GreaterEqual":"≥","GreaterEqualLess":"⋛","GreaterFullEqual":"≧","GreaterGreater":"⪢","GreaterLess":"≷","GreaterSlantEqual":"⩾","GreaterTilde":"≳","Gscr":"𝒢","gscr":"ℊ","gsim":"≳","gsime":"⪎","gsiml":"⪐","gtcc":"⪧","gtcir":"⩺","gt":">","GT":">","Gt":"≫","gtdot":"⋗","gtlPar":"⦕","gtquest":"⩼","gtrapprox":"⪆","gtrarr":"⥸","gtrdot":"⋗","gtreqless":"⋛","gtreqqless":"⪌","gtrless":"≷","gtrsim":"≳","gvertneqq":"≩︀","gvnE":"≩︀","Hacek":"ˇ","hairsp":" ","half":"½","hamilt":"ℋ","HARDcy":"Ъ","hardcy":"ъ","harrcir":"⥈","harr":"↔","hArr":"⇔","harrw":"↭","Hat":"^","hbar":"ℏ","Hcirc":"Ĥ","hcirc":"ĥ","hearts":"♥","heartsuit":"♥","hellip":"…","hercon":"⊹","hfr":"𝔥","Hfr":"ℌ","HilbertSpace":"ℋ","hksearow":"⤥","hkswarow":"⤦","hoarr":"⇿","homtht":"∻","hookleftarrow":"↩","hookrightarrow":"↪","hopf":"𝕙","Hopf":"ℍ","horbar":"―","HorizontalLine":"─","hscr":"𝒽","Hscr":"ℋ","hslash":"ℏ","Hstrok":"Ħ","hstrok":"ħ","HumpDownHump":"≎","HumpEqual":"≏","hybull":"⁃","hyphen":"‐","Iacute":"Í","iacute":"í","ic":"⁣","Icirc":"Î","icirc":"î","Icy":"И","icy":"и","Idot":"İ","IEcy":"Е","iecy":"е","iexcl":"¡","iff":"⇔","ifr":"𝔦","Ifr":"ℑ","Igrave":"Ì","igrave":"ì","ii":"ⅈ","iiiint":"⨌","iiint":"∭","iinfin":"⧜","iiota":"℩","IJlig":"Ĳ","ijlig":"ĳ","Imacr":"Ī","imacr":"ī","image":"ℑ","ImaginaryI":"ⅈ","imagline":"ℐ","imagpart":"ℑ","imath":"ı","Im":"ℑ","imof":"⊷","imped":"Ƶ","Implies":"⇒","incare":"℅","in":"∈","infin":"∞","infintie":"⧝","inodot":"ı","intcal":"⊺","int":"∫","Int":"∬","integers":"ℤ","Integral":"∫","intercal":"⊺","Intersection":"⋂","intlarhk":"⨗","intprod":"⨼","InvisibleComma":"⁣","InvisibleTimes":"⁢","IOcy":"Ё","iocy":"ё","Iogon":"Į","iogon":"į","Iopf":"𝕀","iopf":"𝕚","Iota":"Ι","iota":"ι","iprod":"⨼","iquest":"¿","iscr":"𝒾","Iscr":"ℐ","isin":"∈","isindot":"⋵","isinE":"⋹","isins":"⋴","isinsv":"⋳","isinv":"∈","it":"⁢","Itilde":"Ĩ","itilde":"ĩ","Iukcy":"І","iukcy":"і","Iuml":"Ï","iuml":"ï","Jcirc":"Ĵ","jcirc":"ĵ","Jcy":"Й","jcy":"й","Jfr":"𝔍","jfr":"𝔧","jmath":"ȷ","Jopf":"𝕁","jopf":"𝕛","Jscr":"𝒥","jscr":"𝒿","Jsercy":"Ј","jsercy":"ј","Jukcy":"Є","jukcy":"є","Kappa":"Κ","kappa":"κ","kappav":"ϰ","Kcedil":"Ķ","kcedil":"ķ","Kcy":"К","kcy":"к","Kfr":"𝔎","kfr":"𝔨","kgreen":"ĸ","KHcy":"Х","khcy":"х","KJcy":"Ќ","kjcy":"ќ","Kopf":"𝕂","kopf":"𝕜","Kscr":"𝒦","kscr":"𝓀","lAarr":"⇚","Lacute":"Ĺ","lacute":"ĺ","laemptyv":"⦴","lagran":"ℒ","Lambda":"Λ","lambda":"λ","lang":"⟨","Lang":"⟪","langd":"⦑","langle":"⟨","lap":"⪅","Laplacetrf":"ℒ","laquo":"«","larrb":"⇤","larrbfs":"⤟","larr":"←","Larr":"↞","lArr":"⇐","larrfs":"⤝","larrhk":"↩","larrlp":"↫","larrpl":"⤹","larrsim":"⥳","larrtl":"↢","latail":"⤙","lAtail":"⤛","lat":"⪫","late":"⪭","lates":"⪭︀","lbarr":"⤌","lBarr":"⤎","lbbrk":"❲","lbrace":"{","lbrack":"[","lbrke":"⦋","lbrksld":"⦏","lbrkslu":"⦍","Lcaron":"Ľ","lcaron":"ľ","Lcedil":"Ļ","lcedil":"ļ","lceil":"⌈","lcub":"{","Lcy":"Л","lcy":"л","ldca":"⤶","ldquo":"“","ldquor":"„","ldrdhar":"⥧","ldrushar":"⥋","ldsh":"↲","le":"≤","lE":"≦","LeftAngleBracket":"⟨","LeftArrowBar":"⇤","leftarrow":"←","LeftArrow":"←","Leftarrow":"⇐","LeftArrowRightArrow":"⇆","leftarrowtail":"↢","LeftCeiling":"⌈","LeftDoubleBracket":"⟦","LeftDownTeeVector":"⥡","LeftDownVectorBar":"⥙","LeftDownVector":"⇃","LeftFloor":"⌊","leftharpoondown":"↽","leftharpoonup":"↼","leftleftarrows":"⇇","leftrightarrow":"↔","LeftRightArrow":"↔","Leftrightarrow":"⇔","leftrightarrows":"⇆","leftrightharpoons":"⇋","leftrightsquigarrow":"↭","LeftRightVector":"⥎","LeftTeeArrow":"↤","LeftTee":"⊣","LeftTeeVector":"⥚","leftthreetimes":"⋋","LeftTriangleBar":"⧏","LeftTriangle":"⊲","LeftTriangleEqual":"⊴","LeftUpDownVector":"⥑","LeftUpTeeVector":"⥠","LeftUpVectorBar":"⥘","LeftUpVector":"↿","LeftVectorBar":"⥒","LeftVector":"↼","lEg":"⪋","leg":"⋚","leq":"≤","leqq":"≦","leqslant":"⩽","lescc":"⪨","les":"⩽","lesdot":"⩿","lesdoto":"⪁","lesdotor":"⪃","lesg":"⋚︀","lesges":"⪓","lessapprox":"⪅","lessdot":"⋖","lesseqgtr":"⋚","lesseqqgtr":"⪋","LessEqualGreater":"⋚","LessFullEqual":"≦","LessGreater":"≶","lessgtr":"≶","LessLess":"⪡","lesssim":"≲","LessSlantEqual":"⩽","LessTilde":"≲","lfisht":"⥼","lfloor":"⌊","Lfr":"𝔏","lfr":"𝔩","lg":"≶","lgE":"⪑","lHar":"⥢","lhard":"↽","lharu":"↼","lharul":"⥪","lhblk":"▄","LJcy":"Љ","ljcy":"љ","llarr":"⇇","ll":"≪","Ll":"⋘","llcorner":"⌞","Lleftarrow":"⇚","llhard":"⥫","lltri":"◺","Lmidot":"Ŀ","lmidot":"ŀ","lmoustache":"⎰","lmoust":"⎰","lnap":"⪉","lnapprox":"⪉","lne":"⪇","lnE":"≨","lneq":"⪇","lneqq":"≨","lnsim":"⋦","loang":"⟬","loarr":"⇽","lobrk":"⟦","longleftarrow":"⟵","LongLeftArrow":"⟵","Longleftarrow":"⟸","longleftrightarrow":"⟷","LongLeftRightArrow":"⟷","Longleftrightarrow":"⟺","longmapsto":"⟼","longrightarrow":"⟶","LongRightArrow":"⟶","Longrightarrow":"⟹","looparrowleft":"↫","looparrowright":"↬","lopar":"⦅","Lopf":"𝕃","lopf":"𝕝","loplus":"⨭","lotimes":"⨴","lowast":"∗","lowbar":"_","LowerLeftArrow":"↙","LowerRightArrow":"↘","loz":"◊","lozenge":"◊","lozf":"⧫","lpar":"(","lparlt":"⦓","lrarr":"⇆","lrcorner":"⌟","lrhar":"⇋","lrhard":"⥭","lrm":"‎","lrtri":"⊿","lsaquo":"‹","lscr":"𝓁","Lscr":"ℒ","lsh":"↰","Lsh":"↰","lsim":"≲","lsime":"⪍","lsimg":"⪏","lsqb":"[","lsquo":"‘","lsquor":"‚","Lstrok":"Ł","lstrok":"ł","ltcc":"⪦","ltcir":"⩹","lt":"<","LT":"<","Lt":"≪","ltdot":"⋖","lthree":"⋋","ltimes":"⋉","ltlarr":"⥶","ltquest":"⩻","ltri":"◃","ltrie":"⊴","ltrif":"◂","ltrPar":"⦖","lurdshar":"⥊","luruhar":"⥦","lvertneqq":"≨︀","lvnE":"≨︀","macr":"¯","male":"♂","malt":"✠","maltese":"✠","Map":"⤅","map":"↦","mapsto":"↦","mapstodown":"↧","mapstoleft":"↤","mapstoup":"↥","marker":"▮","mcomma":"⨩","Mcy":"М","mcy":"м","mdash":"—","mDDot":"∺","measuredangle":"∡","MediumSpace":" ","Mellintrf":"ℳ","Mfr":"𝔐","mfr":"𝔪","mho":"℧","micro":"µ","midast":"*","midcir":"⫰","mid":"∣","middot":"·","minusb":"⊟","minus":"−","minusd":"∸","minusdu":"⨪","MinusPlus":"∓","mlcp":"⫛","mldr":"…","mnplus":"∓","models":"⊧","Mopf":"𝕄","mopf":"𝕞","mp":"∓","mscr":"𝓂","Mscr":"ℳ","mstpos":"∾","Mu":"Μ","mu":"μ","multimap":"⊸","mumap":"⊸","nabla":"∇","Nacute":"Ń","nacute":"ń","nang":"∠⃒","nap":"≉","napE":"⩰̸","napid":"≋̸","napos":"ŉ","napprox":"≉","natural":"♮","naturals":"ℕ","natur":"♮","nbsp":" ","nbump":"≎̸","nbumpe":"≏̸","ncap":"⩃","Ncaron":"Ň","ncaron":"ň","Ncedil":"Ņ","ncedil":"ņ","ncong":"≇","ncongdot":"⩭̸","ncup":"⩂","Ncy":"Н","ncy":"н","ndash":"–","nearhk":"⤤","nearr":"↗","neArr":"⇗","nearrow":"↗","ne":"≠","nedot":"≐̸","NegativeMediumSpace":"​","NegativeThickSpace":"​","NegativeThinSpace":"​","NegativeVeryThinSpace":"​","nequiv":"≢","nesear":"⤨","nesim":"≂̸","NestedGreaterGreater":"≫","NestedLessLess":"≪","NewLine":"\\n","nexist":"∄","nexists":"∄","Nfr":"𝔑","nfr":"𝔫","ngE":"≧̸","nge":"≱","ngeq":"≱","ngeqq":"≧̸","ngeqslant":"⩾̸","nges":"⩾̸","nGg":"⋙̸","ngsim":"≵","nGt":"≫⃒","ngt":"≯","ngtr":"≯","nGtv":"≫̸","nharr":"↮","nhArr":"⇎","nhpar":"⫲","ni":"∋","nis":"⋼","nisd":"⋺","niv":"∋","NJcy":"Њ","njcy":"њ","nlarr":"↚","nlArr":"⇍","nldr":"‥","nlE":"≦̸","nle":"≰","nleftarrow":"↚","nLeftarrow":"⇍","nleftrightarrow":"↮","nLeftrightarrow":"⇎","nleq":"≰","nleqq":"≦̸","nleqslant":"⩽̸","nles":"⩽̸","nless":"≮","nLl":"⋘̸","nlsim":"≴","nLt":"≪⃒","nlt":"≮","nltri":"⋪","nltrie":"⋬","nLtv":"≪̸","nmid":"∤","NoBreak":"⁠","NonBreakingSpace":" ","nopf":"𝕟","Nopf":"ℕ","Not":"⫬","not":"¬","NotCongruent":"≢","NotCupCap":"≭","NotDoubleVerticalBar":"∦","NotElement":"∉","NotEqual":"≠","NotEqualTilde":"≂̸","NotExists":"∄","NotGreater":"≯","NotGreaterEqual":"≱","NotGreaterFullEqual":"≧̸","NotGreaterGreater":"≫̸","NotGreaterLess":"≹","NotGreaterSlantEqual":"⩾̸","NotGreaterTilde":"≵","NotHumpDownHump":"≎̸","NotHumpEqual":"≏̸","notin":"∉","notindot":"⋵̸","notinE":"⋹̸","notinva":"∉","notinvb":"⋷","notinvc":"⋶","NotLeftTriangleBar":"⧏̸","NotLeftTriangle":"⋪","NotLeftTriangleEqual":"⋬","NotLess":"≮","NotLessEqual":"≰","NotLessGreater":"≸","NotLessLess":"≪̸","NotLessSlantEqual":"⩽̸","NotLessTilde":"≴","NotNestedGreaterGreater":"⪢̸","NotNestedLessLess":"⪡̸","notni":"∌","notniva":"∌","notnivb":"⋾","notnivc":"⋽","NotPrecedes":"⊀","NotPrecedesEqual":"⪯̸","NotPrecedesSlantEqual":"⋠","NotReverseElement":"∌","NotRightTriangleBar":"⧐̸","NotRightTriangle":"⋫","NotRightTriangleEqual":"⋭","NotSquareSubset":"⊏̸","NotSquareSubsetEqual":"⋢","NotSquareSuperset":"⊐̸","NotSquareSupersetEqual":"⋣","NotSubset":"⊂⃒","NotSubsetEqual":"⊈","NotSucceeds":"⊁","NotSucceedsEqual":"⪰̸","NotSucceedsSlantEqual":"⋡","NotSucceedsTilde":"≿̸","NotSuperset":"⊃⃒","NotSupersetEqual":"⊉","NotTilde":"≁","NotTildeEqual":"≄","NotTildeFullEqual":"≇","NotTildeTilde":"≉","NotVerticalBar":"∤","nparallel":"∦","npar":"∦","nparsl":"⫽⃥","npart":"∂̸","npolint":"⨔","npr":"⊀","nprcue":"⋠","nprec":"⊀","npreceq":"⪯̸","npre":"⪯̸","nrarrc":"⤳̸","nrarr":"↛","nrArr":"⇏","nrarrw":"↝̸","nrightarrow":"↛","nRightarrow":"⇏","nrtri":"⋫","nrtrie":"⋭","nsc":"⊁","nsccue":"⋡","nsce":"⪰̸","Nscr":"𝒩","nscr":"𝓃","nshortmid":"∤","nshortparallel":"∦","nsim":"≁","nsime":"≄","nsimeq":"≄","nsmid":"∤","nspar":"∦","nsqsube":"⋢","nsqsupe":"⋣","nsub":"⊄","nsubE":"⫅̸","nsube":"⊈","nsubset":"⊂⃒","nsubseteq":"⊈","nsubseteqq":"⫅̸","nsucc":"⊁","nsucceq":"⪰̸","nsup":"⊅","nsupE":"⫆̸","nsupe":"⊉","nsupset":"⊃⃒","nsupseteq":"⊉","nsupseteqq":"⫆̸","ntgl":"≹","Ntilde":"Ñ","ntilde":"ñ","ntlg":"≸","ntriangleleft":"⋪","ntrianglelefteq":"⋬","ntriangleright":"⋫","ntrianglerighteq":"⋭","Nu":"Ν","nu":"ν","num":"#","numero":"№","numsp":" ","nvap":"≍⃒","nvdash":"⊬","nvDash":"⊭","nVdash":"⊮","nVDash":"⊯","nvge":"≥⃒","nvgt":">⃒","nvHarr":"⤄","nvinfin":"⧞","nvlArr":"⤂","nvle":"≤⃒","nvlt":"<⃒","nvltrie":"⊴⃒","nvrArr":"⤃","nvrtrie":"⊵⃒","nvsim":"∼⃒","nwarhk":"⤣","nwarr":"↖","nwArr":"⇖","nwarrow":"↖","nwnear":"⤧","Oacute":"Ó","oacute":"ó","oast":"⊛","Ocirc":"Ô","ocirc":"ô","ocir":"⊚","Ocy":"О","ocy":"о","odash":"⊝","Odblac":"Ő","odblac":"ő","odiv":"⨸","odot":"⊙","odsold":"⦼","OElig":"Œ","oelig":"œ","ofcir":"⦿","Ofr":"𝔒","ofr":"𝔬","ogon":"˛","Ograve":"Ò","ograve":"ò","ogt":"⧁","ohbar":"⦵","ohm":"Ω","oint":"∮","olarr":"↺","olcir":"⦾","olcross":"⦻","oline":"‾","olt":"⧀","Omacr":"Ō","omacr":"ō","Omega":"Ω","omega":"ω","Omicron":"Ο","omicron":"ο","omid":"⦶","ominus":"⊖","Oopf":"𝕆","oopf":"𝕠","opar":"⦷","OpenCurlyDoubleQuote":"“","OpenCurlyQuote":"‘","operp":"⦹","oplus":"⊕","orarr":"↻","Or":"⩔","or":"∨","ord":"⩝","order":"ℴ","orderof":"ℴ","ordf":"ª","ordm":"º","origof":"⊶","oror":"⩖","orslope":"⩗","orv":"⩛","oS":"Ⓢ","Oscr":"𝒪","oscr":"ℴ","Oslash":"Ø","oslash":"ø","osol":"⊘","Otilde":"Õ","otilde":"õ","otimesas":"⨶","Otimes":"⨷","otimes":"⊗","Ouml":"Ö","ouml":"ö","ovbar":"⌽","OverBar":"‾","OverBrace":"⏞","OverBracket":"⎴","OverParenthesis":"⏜","para":"¶","parallel":"∥","par":"∥","parsim":"⫳","parsl":"⫽","part":"∂","PartialD":"∂","Pcy":"П","pcy":"п","percnt":"%","period":".","permil":"‰","perp":"⊥","pertenk":"‱","Pfr":"𝔓","pfr":"𝔭","Phi":"Φ","phi":"φ","phiv":"ϕ","phmmat":"ℳ","phone":"☎","Pi":"Π","pi":"π","pitchfork":"⋔","piv":"ϖ","planck":"ℏ","planckh":"ℎ","plankv":"ℏ","plusacir":"⨣","plusb":"⊞","pluscir":"⨢","plus":"+","plusdo":"∔","plusdu":"⨥","pluse":"⩲","PlusMinus":"±","plusmn":"±","plussim":"⨦","plustwo":"⨧","pm":"±","Poincareplane":"ℌ","pointint":"⨕","popf":"𝕡","Popf":"ℙ","pound":"£","prap":"⪷","Pr":"⪻","pr":"≺","prcue":"≼","precapprox":"⪷","prec":"≺","preccurlyeq":"≼","Precedes":"≺","PrecedesEqual":"⪯","PrecedesSlantEqual":"≼","PrecedesTilde":"≾","preceq":"⪯","precnapprox":"⪹","precneqq":"⪵","precnsim":"⋨","pre":"⪯","prE":"⪳","precsim":"≾","prime":"′","Prime":"″","primes":"ℙ","prnap":"⪹","prnE":"⪵","prnsim":"⋨","prod":"∏","Product":"∏","profalar":"⌮","profline":"⌒","profsurf":"⌓","prop":"∝","Proportional":"∝","Proportion":"∷","propto":"∝","prsim":"≾","prurel":"⊰","Pscr":"𝒫","pscr":"𝓅","Psi":"Ψ","psi":"ψ","puncsp":" ","Qfr":"𝔔","qfr":"𝔮","qint":"⨌","qopf":"𝕢","Qopf":"ℚ","qprime":"⁗","Qscr":"𝒬","qscr":"𝓆","quaternions":"ℍ","quatint":"⨖","quest":"?","questeq":"≟","quot":"\\"","QUOT":"\\"","rAarr":"⇛","race":"∽̱","Racute":"Ŕ","racute":"ŕ","radic":"√","raemptyv":"⦳","rang":"⟩","Rang":"⟫","rangd":"⦒","range":"⦥","rangle":"⟩","raquo":"»","rarrap":"⥵","rarrb":"⇥","rarrbfs":"⤠","rarrc":"⤳","rarr":"→","Rarr":"↠","rArr":"⇒","rarrfs":"⤞","rarrhk":"↪","rarrlp":"↬","rarrpl":"⥅","rarrsim":"⥴","Rarrtl":"⤖","rarrtl":"↣","rarrw":"↝","ratail":"⤚","rAtail":"⤜","ratio":"∶","rationals":"ℚ","rbarr":"⤍","rBarr":"⤏","RBarr":"⤐","rbbrk":"❳","rbrace":"}","rbrack":"]","rbrke":"⦌","rbrksld":"⦎","rbrkslu":"⦐","Rcaron":"Ř","rcaron":"ř","Rcedil":"Ŗ","rcedil":"ŗ","rceil":"⌉","rcub":"}","Rcy":"Р","rcy":"р","rdca":"⤷","rdldhar":"⥩","rdquo":"”","rdquor":"”","rdsh":"↳","real":"ℜ","realine":"ℛ","realpart":"ℜ","reals":"ℝ","Re":"ℜ","rect":"▭","reg":"®","REG":"®","ReverseElement":"∋","ReverseEquilibrium":"⇋","ReverseUpEquilibrium":"⥯","rfisht":"⥽","rfloor":"⌋","rfr":"𝔯","Rfr":"ℜ","rHar":"⥤","rhard":"⇁","rharu":"⇀","rharul":"⥬","Rho":"Ρ","rho":"ρ","rhov":"ϱ","RightAngleBracket":"⟩","RightArrowBar":"⇥","rightarrow":"→","RightArrow":"→","Rightarrow":"⇒","RightArrowLeftArrow":"⇄","rightarrowtail":"↣","RightCeiling":"⌉","RightDoubleBracket":"⟧","RightDownTeeVector":"⥝","RightDownVectorBar":"⥕","RightDownVector":"⇂","RightFloor":"⌋","rightharpoondown":"⇁","rightharpoonup":"⇀","rightleftarrows":"⇄","rightleftharpoons":"⇌","rightrightarrows":"⇉","rightsquigarrow":"↝","RightTeeArrow":"↦","RightTee":"⊢","RightTeeVector":"⥛","rightthreetimes":"⋌","RightTriangleBar":"⧐","RightTriangle":"⊳","RightTriangleEqual":"⊵","RightUpDownVector":"⥏","RightUpTeeVector":"⥜","RightUpVectorBar":"⥔","RightUpVector":"↾","RightVectorBar":"⥓","RightVector":"⇀","ring":"˚","risingdotseq":"≓","rlarr":"⇄","rlhar":"⇌","rlm":"‏","rmoustache":"⎱","rmoust":"⎱","rnmid":"⫮","roang":"⟭","roarr":"⇾","robrk":"⟧","ropar":"⦆","ropf":"𝕣","Ropf":"ℝ","roplus":"⨮","rotimes":"⨵","RoundImplies":"⥰","rpar":")","rpargt":"⦔","rppolint":"⨒","rrarr":"⇉","Rrightarrow":"⇛","rsaquo":"›","rscr":"𝓇","Rscr":"ℛ","rsh":"↱","Rsh":"↱","rsqb":"]","rsquo":"’","rsquor":"’","rthree":"⋌","rtimes":"⋊","rtri":"▹","rtrie":"⊵","rtrif":"▸","rtriltri":"⧎","RuleDelayed":"⧴","ruluhar":"⥨","rx":"℞","Sacute":"Ś","sacute":"ś","sbquo":"‚","scap":"⪸","Scaron":"Š","scaron":"š","Sc":"⪼","sc":"≻","sccue":"≽","sce":"⪰","scE":"⪴","Scedil":"Ş","scedil":"ş","Scirc":"Ŝ","scirc":"ŝ","scnap":"⪺","scnE":"⪶","scnsim":"⋩","scpolint":"⨓","scsim":"≿","Scy":"С","scy":"с","sdotb":"⊡","sdot":"⋅","sdote":"⩦","searhk":"⤥","searr":"↘","seArr":"⇘","searrow":"↘","sect":"§","semi":";","seswar":"⤩","setminus":"∖","setmn":"∖","sext":"✶","Sfr":"𝔖","sfr":"𝔰","sfrown":"⌢","sharp":"♯","SHCHcy":"Щ","shchcy":"щ","SHcy":"Ш","shcy":"ш","ShortDownArrow":"↓","ShortLeftArrow":"←","shortmid":"∣","shortparallel":"∥","ShortRightArrow":"→","ShortUpArrow":"↑","shy":"­","Sigma":"Σ","sigma":"σ","sigmaf":"ς","sigmav":"ς","sim":"∼","simdot":"⩪","sime":"≃","simeq":"≃","simg":"⪞","simgE":"⪠","siml":"⪝","simlE":"⪟","simne":"≆","simplus":"⨤","simrarr":"⥲","slarr":"←","SmallCircle":"∘","smallsetminus":"∖","smashp":"⨳","smeparsl":"⧤","smid":"∣","smile":"⌣","smt":"⪪","smte":"⪬","smtes":"⪬︀","SOFTcy":"Ь","softcy":"ь","solbar":"⌿","solb":"⧄","sol":"/","Sopf":"𝕊","sopf":"𝕤","spades":"♠","spadesuit":"♠","spar":"∥","sqcap":"⊓","sqcaps":"⊓︀","sqcup":"⊔","sqcups":"⊔︀","Sqrt":"√","sqsub":"⊏","sqsube":"⊑","sqsubset":"⊏","sqsubseteq":"⊑","sqsup":"⊐","sqsupe":"⊒","sqsupset":"⊐","sqsupseteq":"⊒","square":"□","Square":"□","SquareIntersection":"⊓","SquareSubset":"⊏","SquareSubsetEqual":"⊑","SquareSuperset":"⊐","SquareSupersetEqual":"⊒","SquareUnion":"⊔","squarf":"▪","squ":"□","squf":"▪","srarr":"→","Sscr":"𝒮","sscr":"𝓈","ssetmn":"∖","ssmile":"⌣","sstarf":"⋆","Star":"⋆","star":"☆","starf":"★","straightepsilon":"ϵ","straightphi":"ϕ","strns":"¯","sub":"⊂","Sub":"⋐","subdot":"⪽","subE":"⫅","sube":"⊆","subedot":"⫃","submult":"⫁","subnE":"⫋","subne":"⊊","subplus":"⪿","subrarr":"⥹","subset":"⊂","Subset":"⋐","subseteq":"⊆","subseteqq":"⫅","SubsetEqual":"⊆","subsetneq":"⊊","subsetneqq":"⫋","subsim":"⫇","subsub":"⫕","subsup":"⫓","succapprox":"⪸","succ":"≻","succcurlyeq":"≽","Succeeds":"≻","SucceedsEqual":"⪰","SucceedsSlantEqual":"≽","SucceedsTilde":"≿","succeq":"⪰","succnapprox":"⪺","succneqq":"⪶","succnsim":"⋩","succsim":"≿","SuchThat":"∋","sum":"∑","Sum":"∑","sung":"♪","sup1":"¹","sup2":"²","sup3":"³","sup":"⊃","Sup":"⋑","supdot":"⪾","supdsub":"⫘","supE":"⫆","supe":"⊇","supedot":"⫄","Superset":"⊃","SupersetEqual":"⊇","suphsol":"⟉","suphsub":"⫗","suplarr":"⥻","supmult":"⫂","supnE":"⫌","supne":"⊋","supplus":"⫀","supset":"⊃","Supset":"⋑","supseteq":"⊇","supseteqq":"⫆","supsetneq":"⊋","supsetneqq":"⫌","supsim":"⫈","supsub":"⫔","supsup":"⫖","swarhk":"⤦","swarr":"↙","swArr":"⇙","swarrow":"↙","swnwar":"⤪","szlig":"ß","Tab":"\\t","target":"⌖","Tau":"Τ","tau":"τ","tbrk":"⎴","Tcaron":"Ť","tcaron":"ť","Tcedil":"Ţ","tcedil":"ţ","Tcy":"Т","tcy":"т","tdot":"⃛","telrec":"⌕","Tfr":"𝔗","tfr":"𝔱","there4":"∴","therefore":"∴","Therefore":"∴","Theta":"Θ","theta":"θ","thetasym":"ϑ","thetav":"ϑ","thickapprox":"≈","thicksim":"∼","ThickSpace":"  ","ThinSpace":" ","thinsp":" ","thkap":"≈","thksim":"∼","THORN":"Þ","thorn":"þ","tilde":"˜","Tilde":"∼","TildeEqual":"≃","TildeFullEqual":"≅","TildeTilde":"≈","timesbar":"⨱","timesb":"⊠","times":"×","timesd":"⨰","tint":"∭","toea":"⤨","topbot":"⌶","topcir":"⫱","top":"⊤","Topf":"𝕋","topf":"𝕥","topfork":"⫚","tosa":"⤩","tprime":"‴","trade":"™","TRADE":"™","triangle":"▵","triangledown":"▿","triangleleft":"◃","trianglelefteq":"⊴","triangleq":"≜","triangleright":"▹","trianglerighteq":"⊵","tridot":"◬","trie":"≜","triminus":"⨺","TripleDot":"⃛","triplus":"⨹","trisb":"⧍","tritime":"⨻","trpezium":"⏢","Tscr":"𝒯","tscr":"𝓉","TScy":"Ц","tscy":"ц","TSHcy":"Ћ","tshcy":"ћ","Tstrok":"Ŧ","tstrok":"ŧ","twixt":"≬","twoheadleftarrow":"↞","twoheadrightarrow":"↠","Uacute":"Ú","uacute":"ú","uarr":"↑","Uarr":"↟","uArr":"⇑","Uarrocir":"⥉","Ubrcy":"Ў","ubrcy":"ў","Ubreve":"Ŭ","ubreve":"ŭ","Ucirc":"Û","ucirc":"û","Ucy":"У","ucy":"у","udarr":"⇅","Udblac":"Ű","udblac":"ű","udhar":"⥮","ufisht":"⥾","Ufr":"𝔘","ufr":"𝔲","Ugrave":"Ù","ugrave":"ù","uHar":"⥣","uharl":"↿","uharr":"↾","uhblk":"▀","ulcorn":"⌜","ulcorner":"⌜","ulcrop":"⌏","ultri":"◸","Umacr":"Ū","umacr":"ū","uml":"¨","UnderBar":"_","UnderBrace":"⏟","UnderBracket":"⎵","UnderParenthesis":"⏝","Union":"⋃","UnionPlus":"⊎","Uogon":"Ų","uogon":"ų","Uopf":"𝕌","uopf":"𝕦","UpArrowBar":"⤒","uparrow":"↑","UpArrow":"↑","Uparrow":"⇑","UpArrowDownArrow":"⇅","updownarrow":"↕","UpDownArrow":"↕","Updownarrow":"⇕","UpEquilibrium":"⥮","upharpoonleft":"↿","upharpoonright":"↾","uplus":"⊎","UpperLeftArrow":"↖","UpperRightArrow":"↗","upsi":"υ","Upsi":"ϒ","upsih":"ϒ","Upsilon":"Υ","upsilon":"υ","UpTeeArrow":"↥","UpTee":"⊥","upuparrows":"⇈","urcorn":"⌝","urcorner":"⌝","urcrop":"⌎","Uring":"Ů","uring":"ů","urtri":"◹","Uscr":"𝒰","uscr":"𝓊","utdot":"⋰","Utilde":"Ũ","utilde":"ũ","utri":"▵","utrif":"▴","uuarr":"⇈","Uuml":"Ü","uuml":"ü","uwangle":"⦧","vangrt":"⦜","varepsilon":"ϵ","varkappa":"ϰ","varnothing":"∅","varphi":"ϕ","varpi":"ϖ","varpropto":"∝","varr":"↕","vArr":"⇕","varrho":"ϱ","varsigma":"ς","varsubsetneq":"⊊︀","varsubsetneqq":"⫋︀","varsupsetneq":"⊋︀","varsupsetneqq":"⫌︀","vartheta":"ϑ","vartriangleleft":"⊲","vartriangleright":"⊳","vBar":"⫨","Vbar":"⫫","vBarv":"⫩","Vcy":"В","vcy":"в","vdash":"⊢","vDash":"⊨","Vdash":"⊩","VDash":"⊫","Vdashl":"⫦","veebar":"⊻","vee":"∨","Vee":"⋁","veeeq":"≚","vellip":"⋮","verbar":"|","Verbar":"‖","vert":"|","Vert":"‖","VerticalBar":"∣","VerticalLine":"|","VerticalSeparator":"❘","VerticalTilde":"≀","VeryThinSpace":" ","Vfr":"𝔙","vfr":"𝔳","vltri":"⊲","vnsub":"⊂⃒","vnsup":"⊃⃒","Vopf":"𝕍","vopf":"𝕧","vprop":"∝","vrtri":"⊳","Vscr":"𝒱","vscr":"𝓋","vsubnE":"⫋︀","vsubne":"⊊︀","vsupnE":"⫌︀","vsupne":"⊋︀","Vvdash":"⊪","vzigzag":"⦚","Wcirc":"Ŵ","wcirc":"ŵ","wedbar":"⩟","wedge":"∧","Wedge":"⋀","wedgeq":"≙","weierp":"℘","Wfr":"𝔚","wfr":"𝔴","Wopf":"𝕎","wopf":"𝕨","wp":"℘","wr":"≀","wreath":"≀","Wscr":"𝒲","wscr":"𝓌","xcap":"⋂","xcirc":"◯","xcup":"⋃","xdtri":"▽","Xfr":"𝔛","xfr":"𝔵","xharr":"⟷","xhArr":"⟺","Xi":"Ξ","xi":"ξ","xlarr":"⟵","xlArr":"⟸","xmap":"⟼","xnis":"⋻","xodot":"⨀","Xopf":"𝕏","xopf":"𝕩","xoplus":"⨁","xotime":"⨂","xrarr":"⟶","xrArr":"⟹","Xscr":"𝒳","xscr":"𝓍","xsqcup":"⨆","xuplus":"⨄","xutri":"△","xvee":"⋁","xwedge":"⋀","Yacute":"Ý","yacute":"ý","YAcy":"Я","yacy":"я","Ycirc":"Ŷ","ycirc":"ŷ","Ycy":"Ы","ycy":"ы","yen":"¥","Yfr":"𝔜","yfr":"𝔶","YIcy":"Ї","yicy":"ї","Yopf":"𝕐","yopf":"𝕪","Yscr":"𝒴","yscr":"𝓎","YUcy":"Ю","yucy":"ю","yuml":"ÿ","Yuml":"Ÿ","Zacute":"Ź","zacute":"ź","Zcaron":"Ž","zcaron":"ž","Zcy":"З","zcy":"з","Zdot":"Ż","zdot":"ż","zeetrf":"ℨ","ZeroWidthSpace":"​","Zeta":"Ζ","zeta":"ζ","zfr":"𝔷","Zfr":"ℨ","ZHcy":"Ж","zhcy":"ж","zigrarr":"⇝","zopf":"𝕫","Zopf":"ℤ","Zscr":"𝒵","zscr":"𝓏","zwj":"‍","zwnj":"‌"}');
    },
    /* 262 */
    /***/
    function(m) {
      m.exports = JSON.parse('{"Aacute":"Á","aacute":"á","Acirc":"Â","acirc":"â","acute":"´","AElig":"Æ","aelig":"æ","Agrave":"À","agrave":"à","amp":"&","AMP":"&","Aring":"Å","aring":"å","Atilde":"Ã","atilde":"ã","Auml":"Ä","auml":"ä","brvbar":"¦","Ccedil":"Ç","ccedil":"ç","cedil":"¸","cent":"¢","copy":"©","COPY":"©","curren":"¤","deg":"°","divide":"÷","Eacute":"É","eacute":"é","Ecirc":"Ê","ecirc":"ê","Egrave":"È","egrave":"è","ETH":"Ð","eth":"ð","Euml":"Ë","euml":"ë","frac12":"½","frac14":"¼","frac34":"¾","gt":">","GT":">","Iacute":"Í","iacute":"í","Icirc":"Î","icirc":"î","iexcl":"¡","Igrave":"Ì","igrave":"ì","iquest":"¿","Iuml":"Ï","iuml":"ï","laquo":"«","lt":"<","LT":"<","macr":"¯","micro":"µ","middot":"·","nbsp":" ","not":"¬","Ntilde":"Ñ","ntilde":"ñ","Oacute":"Ó","oacute":"ó","Ocirc":"Ô","ocirc":"ô","Ograve":"Ò","ograve":"ò","ordf":"ª","ordm":"º","Oslash":"Ø","oslash":"ø","Otilde":"Õ","otilde":"õ","Ouml":"Ö","ouml":"ö","para":"¶","plusmn":"±","pound":"£","quot":"\\"","QUOT":"\\"","raquo":"»","reg":"®","REG":"®","sect":"§","shy":"­","sup1":"¹","sup2":"²","sup3":"³","szlig":"ß","THORN":"Þ","thorn":"þ","times":"×","Uacute":"Ú","uacute":"ú","Ucirc":"Û","ucirc":"û","Ugrave":"Ù","ugrave":"ù","uml":"¨","Uuml":"Ü","uuml":"ü","Yacute":"Ý","yacute":"ý","yen":"¥","yuml":"ÿ"}');
    },
    /* 263 */
    /***/
    function(m) {
      m.exports = JSON.parse(`{"amp":"&","apos":"'","gt":">","lt":"<","quot":"\\""}`);
    },
    /* 264 */
    /***/
    function(m, l, i) {
      var d = this && this.__importDefault || function(a) {
        return a && a.__esModule ? a : { default: a };
      };
      Object.defineProperty(l, "__esModule", { value: !0 });
      var s = d(i(265));
      function X(a) {
        if (a >= 55296 && a <= 57343 || a > 1114111)
          return "�";
        a in s.default && (a = s.default[a]);
        var e = "";
        return a > 65535 && (a -= 65536, e += String.fromCharCode(a >>> 10 & 1023 | 55296), a = 56320 | a & 1023), e += String.fromCharCode(a), e;
      }
      l.default = X;
    },
    /* 265 */
    /***/
    function(m) {
      m.exports = JSON.parse('{"0":65533,"128":8364,"130":8218,"131":402,"132":8222,"133":8230,"134":8224,"135":8225,"136":710,"137":8240,"138":352,"139":8249,"140":338,"142":381,"145":8216,"146":8217,"147":8220,"148":8221,"149":8226,"150":8211,"151":8212,"152":732,"153":8482,"154":353,"155":8250,"156":339,"158":382,"159":376}');
    },
    /* 266 */
    /***/
    function(m, l, i) {
      var d = this && this.__importDefault || function(V) {
        return V && V.__esModule ? V : { default: V };
      };
      Object.defineProperty(l, "__esModule", { value: !0 }), l.escape = l.encodeHTML = l.encodeXML = void 0;
      var s = d(i(263)), X = y(s.default), a = o(X);
      l.encodeXML = x(X, a);
      var e = d(i(261)), n = y(e.default), G = o(n);
      l.encodeHTML = x(n, G);
      function y(V) {
        return Object.keys(V).sort().reduce(function(t, c) {
          return t[V[c]] = "&" + c + ";", t;
        }, {});
      }
      function o(V) {
        for (var t = [], c = [], b = 0, Z = Object.keys(V); b < Z.length; b++) {
          var r = Z[b];
          r.length === 1 ? t.push("\\" + r) : c.push(r);
        }
        t.sort();
        for (var S = 0; S < t.length - 1; S++) {
          for (var C = S; C < t.length - 1 && t[C].charCodeAt(1) + 1 === t[C + 1].charCodeAt(1); )
            C += 1;
          var F = 1 + C - S;
          F < 3 || t.splice(S, F, t[S] + "-" + t[C]);
        }
        return c.unshift("[" + t.join("") + "]"), new RegExp(c.join("|"), "g");
      }
      var h = /(?:[\x80-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/g;
      function I(V) {
        return "&#x" + V.codePointAt(0).toString(16).toUpperCase() + ";";
      }
      function x(V, t) {
        return function(c) {
          return c.replace(t, function(b) {
            return V[b];
          }).replace(h, I);
        };
      }
      var p = o(X);
      function W(V) {
        return V.replace(p, I).replace(h, I);
      }
      l.escape = W;
    },
    /* 267 */
    /***/
    function(m) {
      m.exports = JSON.parse('{"elementNames":{"altglyph":"altGlyph","altglyphdef":"altGlyphDef","altglyphitem":"altGlyphItem","animatecolor":"animateColor","animatemotion":"animateMotion","animatetransform":"animateTransform","clippath":"clipPath","feblend":"feBlend","fecolormatrix":"feColorMatrix","fecomponenttransfer":"feComponentTransfer","fecomposite":"feComposite","feconvolvematrix":"feConvolveMatrix","fediffuselighting":"feDiffuseLighting","fedisplacementmap":"feDisplacementMap","fedistantlight":"feDistantLight","fedropshadow":"feDropShadow","feflood":"feFlood","fefunca":"feFuncA","fefuncb":"feFuncB","fefuncg":"feFuncG","fefuncr":"feFuncR","fegaussianblur":"feGaussianBlur","feimage":"feImage","femerge":"feMerge","femergenode":"feMergeNode","femorphology":"feMorphology","feoffset":"feOffset","fepointlight":"fePointLight","fespecularlighting":"feSpecularLighting","fespotlight":"feSpotLight","fetile":"feTile","feturbulence":"feTurbulence","foreignobject":"foreignObject","glyphref":"glyphRef","lineargradient":"linearGradient","radialgradient":"radialGradient","textpath":"textPath"},"attributeNames":{"definitionurl":"definitionURL","attributename":"attributeName","attributetype":"attributeType","basefrequency":"baseFrequency","baseprofile":"baseProfile","calcmode":"calcMode","clippathunits":"clipPathUnits","diffuseconstant":"diffuseConstant","edgemode":"edgeMode","filterunits":"filterUnits","glyphref":"glyphRef","gradienttransform":"gradientTransform","gradientunits":"gradientUnits","kernelmatrix":"kernelMatrix","kernelunitlength":"kernelUnitLength","keypoints":"keyPoints","keysplines":"keySplines","keytimes":"keyTimes","lengthadjust":"lengthAdjust","limitingconeangle":"limitingConeAngle","markerheight":"markerHeight","markerunits":"markerUnits","markerwidth":"markerWidth","maskcontentunits":"maskContentUnits","maskunits":"maskUnits","numoctaves":"numOctaves","pathlength":"pathLength","patterncontentunits":"patternContentUnits","patterntransform":"patternTransform","patternunits":"patternUnits","pointsatx":"pointsAtX","pointsaty":"pointsAtY","pointsatz":"pointsAtZ","preservealpha":"preserveAlpha","preserveaspectratio":"preserveAspectRatio","primitiveunits":"primitiveUnits","refx":"refX","refy":"refY","repeatcount":"repeatCount","repeatdur":"repeatDur","requiredextensions":"requiredExtensions","requiredfeatures":"requiredFeatures","specularconstant":"specularConstant","specularexponent":"specularExponent","spreadmethod":"spreadMethod","startoffset":"startOffset","stddeviation":"stdDeviation","stitchtiles":"stitchTiles","surfacescale":"surfaceScale","systemlanguage":"systemLanguage","tablevalues":"tableValues","targetx":"targetX","targety":"targetY","textlength":"textLength","viewbox":"viewBox","viewtarget":"viewTarget","xchannelselector":"xChannelSelector","ychannelselector":"yChannelSelector","zoomandpan":"zoomAndPan"}}');
    },
    /* 268 */
    /***/
    function(m, l) {
      var i = l.getChildren = function(s) {
        return s.children;
      }, d = l.getParent = function(s) {
        return s.parent;
      };
      l.getSiblings = function(s) {
        var X = d(s);
        return X ? i(X) : [s];
      }, l.getAttributeValue = function(s, X) {
        return s.attribs && s.attribs[X];
      }, l.hasAttrib = function(s, X) {
        return !!s.attribs && hasOwnProperty.call(s.attribs, X);
      }, l.getName = function(s) {
        return s.name;
      };
    },
    /* 269 */
    /***/
    function(m, l) {
      l.removeElement = function(i) {
        if (i.prev && (i.prev.next = i.next), i.next && (i.next.prev = i.prev), i.parent) {
          var d = i.parent.children;
          d.splice(d.lastIndexOf(i), 1);
        }
      }, l.replaceElement = function(i, d) {
        var s = d.prev = i.prev;
        s && (s.next = d);
        var X = d.next = i.next;
        X && (X.prev = d);
        var a = d.parent = i.parent;
        if (a) {
          var e = a.children;
          e[e.lastIndexOf(i)] = d;
        }
      }, l.appendChild = function(i, d) {
        if (d.parent = i, i.children.push(d) !== 1) {
          var s = i.children[i.children.length - 2];
          s.next = d, d.prev = s, d.next = null;
        }
      }, l.append = function(i, d) {
        var s = i.parent, X = i.next;
        if (d.next = X, d.prev = i, i.next = d, d.parent = s, X) {
          if (X.prev = d, s) {
            var a = s.children;
            a.splice(a.lastIndexOf(X), 0, d);
          }
        } else
          s && s.children.push(d);
      }, l.prepend = function(i, d) {
        var s = i.parent;
        if (s) {
          var X = s.children;
          X.splice(X.lastIndexOf(i), 0, d);
        }
        i.prev && (i.prev.next = d), d.parent = s, d.prev = i.prev, d.next = i, i.prev = d;
      };
    },
    /* 270 */
    /***/
    function(m, l, i) {
      var d = i(256).isTag;
      m.exports = {
        filter: s,
        find: X,
        findOneChild: a,
        findOne: e,
        existsOne: n,
        findAll: G
      };
      function s(y, o, h, I) {
        return Array.isArray(o) || (o = [o]), (typeof I != "number" || !isFinite(I)) && (I = 1 / 0), X(y, o, h !== !1, I);
      }
      function X(y, o, h, I) {
        for (var x = [], p, W = 0, V = o.length; W < V && !(y(o[W]) && (x.push(o[W]), --I <= 0) || (p = o[W].children, h && p && p.length > 0 && (p = X(y, p, h, I), x = x.concat(p), I -= p.length, I <= 0))); W++)
          ;
        return x;
      }
      function a(y, o) {
        for (var h = 0, I = o.length; h < I; h++)
          if (y(o[h]))
            return o[h];
        return null;
      }
      function e(y, o) {
        for (var h = null, I = 0, x = o.length; I < x && !h; I++)
          if (d(o[I]))
            y(o[I]) ? h = o[I] : o[I].children.length > 0 && (h = e(y, o[I].children));
          else
            continue;
        return h;
      }
      function n(y, o) {
        for (var h = 0, I = o.length; h < I; h++)
          if (d(o[h]) && (y(o[h]) || o[h].children.length > 0 && n(y, o[h].children)))
            return !0;
        return !1;
      }
      function G(y, o) {
        for (var h = [], I = o.slice(); I.length; ) {
          var x = I.shift();
          d(x) && (x.children && x.children.length > 0 && I.unshift.apply(I, x.children), y(x) && h.push(x));
        }
        return h;
      }
    },
    /* 271 */
    /***/
    function(m, l, i) {
      var d = i(256), s = l.isTag = d.isTag;
      l.testElement = function(n, G) {
        for (var y in n)
          if (n.hasOwnProperty(y)) {
            if (y === "tag_name") {
              if (!s(G) || !n.tag_name(G.name))
                return !1;
            } else if (y === "tag_type") {
              if (!n.tag_type(G.type))
                return !1;
            } else if (y === "tag_contains") {
              if (s(G) || !n.tag_contains(G.data))
                return !1;
            } else if (!G.attribs || !n[y](G.attribs[y]))
              return !1;
          }
        return !0;
      };
      var X = {
        tag_name: function(n) {
          return typeof n == "function" ? function(G) {
            return s(G) && n(G.name);
          } : n === "*" ? s : function(G) {
            return s(G) && G.name === n;
          };
        },
        tag_type: function(n) {
          return typeof n == "function" ? function(G) {
            return n(G.type);
          } : function(G) {
            return G.type === n;
          };
        },
        tag_contains: function(n) {
          return typeof n == "function" ? function(G) {
            return !s(G) && n(G.data);
          } : function(G) {
            return !s(G) && G.data === n;
          };
        }
      };
      function a(n, G) {
        return typeof G == "function" ? function(y) {
          return y.attribs && G(y.attribs[n]);
        } : function(y) {
          return y.attribs && y.attribs[n] === G;
        };
      }
      function e(n, G) {
        return function(y) {
          return n(y) || G(y);
        };
      }
      l.getElements = function(n, G, y, o) {
        var h = Object.keys(n).map(function(I) {
          var x = n[I];
          return I in X ? X[I](x) : a(I, x);
        });
        return h.length === 0 ? [] : this.filter(
          h.reduce(e),
          G,
          y,
          o
        );
      }, l.getElementById = function(n, G, y) {
        return Array.isArray(G) || (G = [G]), this.findOne(a("id", n), G, y !== !1);
      }, l.getElementsByTagName = function(n, G, y, o) {
        return this.filter(X.tag_name(n), G, y, o);
      }, l.getElementsByTagType = function(n, G, y, o) {
        return this.filter(X.tag_type(n), G, y, o);
      };
    },
    /* 272 */
    /***/
    function(m, l) {
      l.removeSubsets = function(s) {
        for (var X = s.length, a, e, n; --X > -1; ) {
          for (a = e = s[X], s[X] = null, n = !0; e; ) {
            if (s.indexOf(e) > -1) {
              n = !1, s.splice(X, 1);
              break;
            }
            e = e.parent;
          }
          n && (s[X] = a);
        }
        return s;
      };
      var i = {
        DISCONNECTED: 1,
        PRECEDING: 2,
        FOLLOWING: 4,
        CONTAINS: 8,
        CONTAINED_BY: 16
      }, d = l.compareDocumentPosition = function(s, X) {
        var a = [], e = [], n, G, y, o, h, I;
        if (s === X)
          return 0;
        for (n = s; n; )
          a.unshift(n), n = n.parent;
        for (n = X; n; )
          e.unshift(n), n = n.parent;
        for (I = 0; a[I] === e[I]; )
          I++;
        return I === 0 ? i.DISCONNECTED : (G = a[I - 1], y = G.children, o = a[I], h = e[I], y.indexOf(o) > y.indexOf(h) ? G === X ? i.FOLLOWING | i.CONTAINED_BY : i.FOLLOWING : G === s ? i.PRECEDING | i.CONTAINS : i.PRECEDING);
      };
      l.uniqueSort = function(s) {
        var X = s.length, a, e;
        for (s = s.slice(); --X > -1; )
          a = s[X], e = s.indexOf(a), e > -1 && e < X && s.splice(X, 1);
        return s.sort(function(n, G) {
          var y = d(n, G);
          return y & i.PRECEDING ? -1 : y & i.FOLLOWING ? 1 : 0;
        }), s;
      };
    },
    /* 273 */
    /***/
    function(m, l) {
      m.exports = {
        trueFunc: function() {
          return !0;
        },
        falseFunc: function() {
          return !1;
        }
      };
    },
    /* 274 */
    /***/
    function(m, l, i) {
      m.exports = h;
      var d = i(275).parse, s = i(273), X = i(278), a = i(279), e = i(280), n = i(282), G = s.trueFunc, y = s.falseFunc, o = n.filters;
      function h(Y, J, T) {
        var K = x(Y, J, T);
        return I(K, J);
      }
      function I(Y, J) {
        var T = J.adapter;
        return function(R) {
          return T.isTag(R) && Y(R);
        };
      }
      function x(Y, J, T) {
        var K = d(Y, J);
        return Z(K, J, T);
      }
      function p(Y) {
        return Y.type === "pseudo" && (Y.name === "scope" || Array.isArray(Y.data) && Y.data.some(function(J) {
          return J.some(p);
        }));
      }
      var W = { type: "descendant" }, V = { type: "_flexibleDescendant" }, t = { type: "pseudo", name: "scope" }, c = {};
      function b(Y, J, T) {
        var K = J.adapter, R = !!T && !!T.length && T.every(function(H) {
          return H === c || !!K.getParent(H);
        });
        Y.forEach(function(H) {
          if (!(H.length > 0 && r(H[0]) && H[0].type !== "descendant"))
            if (R && !(Array.isArray(H) ? H.some(p) : p(H)))
              H.unshift(W);
            else
              return;
          H.unshift(t);
        });
      }
      function Z(Y, J, T) {
        Y = Y.filter(function(f) {
          return f.length > 0;
        }), Y.forEach(X);
        var K = Array.isArray(T);
        T = J && J.context || T, T && !K && (T = [T]), b(Y, J, T);
        var R = !1, H = Y.map(function(f) {
          if (f[0] && f[1] && f[0].name === "scope") {
            var w = f[1].type;
            K && w === "descendant" ? f[1] = V : (w === "adjacent" || w === "sibling") && (R = !0);
          }
          return S(f, J, T);
        }).reduce(C, y);
        return H.shouldTestNextSiblings = R, H;
      }
      function r(Y) {
        return a[Y.type] < 0;
      }
      function S(Y, J, T) {
        return Y.reduce(function(K, R) {
          if (K === y)
            return K;
          if (!(R.type in e))
            throw new Error("Rule type " + R.type + " is not supported by css-select");
          return e[R.type](K, R, J, T);
        }, J && J.rootFunc || G);
      }
      function C(Y, J) {
        return J === y || Y === G ? Y : Y === y || J === G ? J : function(K) {
          return Y(K) || J(K);
        };
      }
      function F(Y) {
        return Y.some(r);
      }
      o.not = function(Y, J, T, K) {
        var R = {
          xmlMode: !!(T && T.xmlMode),
          strict: !!(T && T.strict),
          adapter: T.adapter
        };
        if (R.strict && (J.length > 1 || J.some(F)))
          throw new Error("complex selectors in :not aren't allowed in strict mode");
        var H = Z(J, R, K);
        return H === y ? Y : H === G ? y : function(w) {
          return !H(w) && Y(w);
        };
      }, o.has = function(Y, J, T) {
        var K = T.adapter, R = {
          xmlMode: !!(T && T.xmlMode),
          strict: !!(T && T.strict),
          adapter: K
        }, H = J.some(F) ? [c] : null, f = Z(J, R, H);
        return f === y ? y : f === G ? function(O) {
          return K.getChildren(O).some(K.isTag) && Y(O);
        } : (f = I(f, T), H ? function(O) {
          return Y(O) && (H[0] = O, K.existsOne(f, K.getChildren(O)));
        } : function(O) {
          return Y(O) && K.existsOne(f, K.getChildren(O));
        });
      }, o.matches = function(Y, J, T, K) {
        var R = {
          xmlMode: !!(T && T.xmlMode),
          strict: !!(T && T.strict),
          rootFunc: Y,
          adapter: T.adapter
        };
        return Z(J, R, K);
      }, h.compileToken = Z, h.compileUnsafe = x, h.Pseudos = n;
    },
    /* 275 */
    /***/
    function(m, l, i) {
      var d = this && this.__createBinding || (Object.create ? function(e, n, G, y) {
        y === void 0 && (y = G), Object.defineProperty(e, y, { enumerable: !0, get: function() {
          return n[G];
        } });
      } : function(e, n, G, y) {
        y === void 0 && (y = G), e[y] = n[G];
      }), s = this && this.__exportStar || function(e, n) {
        for (var G in e)
          G !== "default" && !n.hasOwnProperty(G) && d(n, e, G);
      };
      Object.defineProperty(l, "__esModule", { value: !0 }), s(i(276), l);
      var X = i(276);
      Object.defineProperty(l, "parse", { enumerable: !0, get: function() {
        return X.default;
      } });
      var a = i(277);
      Object.defineProperty(l, "stringify", { enumerable: !0, get: function() {
        return a.default;
      } });
    },
    /* 276 */
    /***/
    function(m, l, i) {
      Object.defineProperty(l, "__esModule", { value: !0 }), l.default = p;
      var d = /^[^\\]?(?:\\(?:[\da-f]{1,6}\s?|.)|[\w\-\u00b0-\uFFFF])+/, s = /\\([\da-f]{1,6}\s?|(\s)|.)/gi, X = /^\s*((?:\\.|[\w\u00b0-\uFFFF-])+)\s*(?:(\S?)=\s*(?:(['"])([^]*?)\3|(#?(?:\\.|[\w\u00b0-\uFFFF-])*)|)|)\s*(i)?\]/, a = {
        undefined: "exists",
        "": "equals",
        "~": "element",
        "^": "start",
        $: "end",
        "*": "any",
        "!": "not",
        "|": "hyphen"
      }, e = {
        ">": "child",
        "<": "parent",
        "~": "sibling",
        "+": "adjacent"
      }, n = {
        "#": ["id", "equals"],
        ".": ["class", "element"]
      }, G = /* @__PURE__ */ new Set(["has", "not", "matches"]), y = /* @__PURE__ */ new Set(["contains", "icontains"]), o = /* @__PURE__ */ new Set(['"', "'"]);
      function h(t, c, b) {
        var Z = parseInt(c, 16) - 65536;
        return Z !== Z || b ? c : Z < 0 ? (
          // BMP codepoint
          String.fromCharCode(Z + 65536)
        ) : (
          // Supplemental Plane codepoint (surrogate pair)
          String.fromCharCode(Z >> 10 | 55296, Z & 1023 | 56320)
        );
      }
      function I(t) {
        return t.replace(s, h);
      }
      function x(t) {
        return t === " " || t === `
` || t === "	" || t === "\f" || t === "\r";
      }
      function p(t, c) {
        var b = [];
        if (t = W(b, "" + t, c), t !== "")
          throw new Error("Unmatched selector: " + t);
        return b;
      }
      function W(t, c, b) {
        var Z = [], r = !1;
        function S() {
          var D = c.match(d);
          if (!D)
            throw new Error("Expected name, found " + c);
          var ii = D[0];
          return c = c.substr(ii.length), I(ii);
        }
        function C(D) {
          for (; x(c.charAt(D)); )
            D++;
          c = c.substr(D);
        }
        function F(D) {
          for (var ii = 0; c.charAt(--D) === "\\"; )
            ii++;
          return (ii & 1) === 1;
        }
        for (C(0); c !== ""; ) {
          var Y = c.charAt(0);
          if (x(Y))
            r = !0, C(1);
          else if (Y in e)
            Z.push({ type: e[Y] }), r = !1, C(1);
          else if (Y === ",") {
            if (Z.length === 0)
              throw new Error("Empty sub-selector");
            t.push(Z), Z = [], r = !1, C(1);
          } else if (r && (Z.length > 0 && Z.push({ type: "descendant" }), r = !1), Y === "*")
            c = c.substr(1), Z.push({ type: "universal" });
          else if (Y in n) {
            var J = n[Y], T = J[0], K = J[1];
            c = c.substr(1), Z.push({
              type: "attribute",
              name: T,
              action: K,
              value: S(),
              ignoreCase: !1
            });
          } else if (Y === "[") {
            c = c.substr(1);
            var R = c.match(X);
            if (!R)
              throw new Error("Malformed attribute selector: " + c);
            c = c.substr(R[0].length);
            var H = I(R[1]);
            (!b || ("lowerCaseAttributeNames" in b ? b.lowerCaseAttributeNames : !b.xmlMode)) && (H = H.toLowerCase()), Z.push({
              type: "attribute",
              name: H,
              action: a[R[2]],
              value: I(R[4] || R[5] || ""),
              ignoreCase: !!R[6]
            });
          } else if (Y === ":") {
            if (c.charAt(1) === ":") {
              c = c.substr(2), Z.push({
                type: "pseudo-element",
                name: S().toLowerCase()
              });
              continue;
            }
            c = c.substr(1);
            var f = S().toLowerCase(), R = null;
            if (c.charAt(0) === "(")
              if (G.has(f)) {
                var w = c.charAt(1), O = o.has(w);
                if (c = c.substr(O ? 2 : 1), R = [], c = W(R, c, b), O) {
                  if (c.charAt(0) !== w)
                    throw new Error("Unmatched quotes in :" + f);
                  c = c.substr(1);
                }
                if (c.charAt(0) !== ")")
                  throw new Error("Missing closing parenthesis in :" + f + " (" + c + ")");
                c = c.substr(1);
              } else {
                for (var q = 1, k = 1; k > 0 && q < c.length; q++)
                  c.charAt(q) === "(" && !F(q) ? k++ : c.charAt(q) === ")" && !F(q) && k--;
                if (k)
                  throw new Error("Parenthesis not matched");
                if (R = c.substr(1, q - 2), c = c.substr(q), y.has(f)) {
                  var w = R.charAt(0);
                  w === R.slice(-1) && o.has(w) && (R = R.slice(1, -1)), R = I(R);
                }
              }
            Z.push({ type: "pseudo", name: f, data: R });
          } else if (d.test(c)) {
            var Q = S();
            (!b || ("lowerCaseTags" in b ? b.lowerCaseTags : !b.xmlMode)) && (Q = Q.toLowerCase()), Z.push({ type: "tag", name: Q });
          } else
            return Z.length && Z[Z.length - 1].type === "descendant" && Z.pop(), V(t, Z), c;
        }
        return V(t, Z), c;
      }
      function V(t, c) {
        if (t.length > 0 && c.length === 0)
          throw new Error("Empty sub-selector");
        t.push(c);
      }
    },
    /* 277 */
    /***/
    function(m, l, i) {
      Object.defineProperty(l, "__esModule", { value: !0 });
      var d = {
        equals: "",
        element: "~",
        start: "^",
        end: "$",
        any: "*",
        not: "!",
        hyphen: "|"
      };
      function s(n) {
        return n.map(X).join(", ");
      }
      l.default = s;
      function X(n) {
        return n.map(a).join("");
      }
      function a(n) {
        switch (n.type) {
          case "child":
            return " > ";
          case "parent":
            return " < ";
          case "sibling":
            return " ~ ";
          case "adjacent":
            return " + ";
          case "descendant":
            return " ";
          case "universal":
            return "*";
          case "tag":
            return n.name;
          case "pseudo-element":
            return "::" + n.name;
          case "pseudo":
            return n.data === null ? ":" + n.name : typeof n.data == "string" ? ":" + n.name + "(" + n.data + ")" : ":" + n.name + "(" + s(n.data) + ")";
          case "attribute":
            return n.action === "exists" ? "[" + n.name + "]" : n.name === "id" && n.action === "equals" && !n.ignoreCase ? "#" + n.value : n.name === "class" && n.action === "element" && !n.ignoreCase ? "." + n.value : "[" + n.name + d[n.action] + "='" + n.value + "'" + (n.ignoreCase ? "i" : "") + "]";
          default:
            throw new Error("Unknown type");
        }
      }
      function e(n) {
        return n;
      }
    },
    /* 278 */
    /***/
    function(m, l, i) {
      m.exports = X;
      var d = i(279), s = {
        __proto__: null,
        exists: 10,
        equals: 8,
        not: 7,
        start: 6,
        end: 6,
        any: 5,
        hyphen: 4,
        element: 4
      };
      function X(e) {
        for (var n = e.map(a), G = 1; G < e.length; G++) {
          var y = n[G];
          if (!(y < 0))
            for (var o = G - 1; o >= 0 && y < n[o]; o--) {
              var h = e[o + 1];
              e[o + 1] = e[o], e[o] = h, n[o + 1] = n[o], n[o] = y;
            }
        }
      }
      function a(e) {
        var n = d[e.type];
        if (n === d.attribute)
          n = s[e.action], n === s.equals && e.name === "id" && (n = 9), e.ignoreCase && (n >>= 1);
        else if (n === d.pseudo)
          if (!e.data)
            n = 3;
          else if (e.name === "has" || e.name === "contains")
            n = 0;
          else if (e.name === "matches" || e.name === "not") {
            n = 0;
            for (var G = 0; G < e.data.length; G++)
              if (e.data[G].length === 1) {
                var y = a(e.data[G][0]);
                if (y === 0) {
                  n = 0;
                  break;
                }
                y > n && (n = y);
              }
            e.data.length > 1 && n > 0 && (n -= 1);
          } else
            n = 1;
        return n;
      }
    },
    /* 279 */
    /***/
    function(m) {
      m.exports = JSON.parse('{"universal":50,"tag":30,"attribute":1,"pseudo":0,"descendant":-1,"child":-1,"parent":-1,"sibling":-1,"adjacent":-1}');
    },
    /* 280 */
    /***/
    function(m, l, i) {
      var d = i(281), s = i(282);
      m.exports = {
        __proto__: null,
        attribute: d.compile,
        pseudo: s.compile,
        //tags
        tag: function(X, a, e) {
          var n = a.name, G = e.adapter;
          return function(o) {
            return G.getName(o) === n && X(o);
          };
        },
        //traversal
        descendant: function(X, a, e) {
          var n = typeof WeakSet < "u" ? /* @__PURE__ */ new WeakSet() : null, G = e.adapter;
          return function(o) {
            for (var h = !1; !h && (o = G.getParent(o)); )
              (!n || !n.has(o)) && (h = X(o), !h && n && n.add(o));
            return h;
          };
        },
        _flexibleDescendant: function(X, a, e) {
          var n = e.adapter;
          return function(y) {
            for (var o = X(y); !o && (y = n.getParent(y)); )
              o = X(y);
            return o;
          };
        },
        parent: function(X, a, e) {
          if (e && e.strict)
            throw new Error("Parent selector isn't part of CSS3");
          var n = e.adapter;
          return function(o) {
            return n.getChildren(o).some(G);
          };
          function G(y) {
            return n.isTag(y) && X(y);
          }
        },
        child: function(X, a, e) {
          var n = e.adapter;
          return function(y) {
            var o = n.getParent(y);
            return !!o && X(o);
          };
        },
        sibling: function(X, a, e) {
          var n = e.adapter;
          return function(y) {
            for (var o = n.getSiblings(y), h = 0; h < o.length; h++)
              if (n.isTag(o[h])) {
                if (o[h] === y)
                  break;
                if (X(o[h]))
                  return !0;
              }
            return !1;
          };
        },
        adjacent: function(X, a, e) {
          var n = e.adapter;
          return function(y) {
            for (var o = n.getSiblings(y), h, I = 0; I < o.length; I++)
              if (n.isTag(o[I])) {
                if (o[I] === y)
                  break;
                h = o[I];
              }
            return !!h && X(h);
          };
        },
        universal: function(X) {
          return X;
        }
      };
    },
    /* 281 */
    /***/
    function(m, l, i) {
      var d = i(273).falseFunc, s = /[-[\]{}()*+?.,\\^$|#\s]/g, X = {
        __proto__: null,
        equals: function(a, e, n) {
          var G = e.name, y = e.value, o = n.adapter;
          return e.ignoreCase ? (y = y.toLowerCase(), function(I) {
            var x = o.getAttributeValue(I, G);
            return x != null && x.toLowerCase() === y && a(I);
          }) : function(I) {
            return o.getAttributeValue(I, G) === y && a(I);
          };
        },
        hyphen: function(a, e, n) {
          var G = e.name, y = e.value, o = y.length, h = n.adapter;
          return e.ignoreCase ? (y = y.toLowerCase(), function(x) {
            var p = h.getAttributeValue(x, G);
            return p != null && (p.length === o || p.charAt(o) === "-") && p.substr(0, o).toLowerCase() === y && a(x);
          }) : function(x) {
            var p = h.getAttributeValue(x, G);
            return p != null && p.substr(0, o) === y && (p.length === o || p.charAt(o) === "-") && a(x);
          };
        },
        element: function(a, e, n) {
          var G = e.name, y = e.value, o = n.adapter;
          if (/\s/.test(y))
            return d;
          y = y.replace(s, "\\$&");
          var h = "(?:^|\\s)" + y + "(?:$|\\s)", I = e.ignoreCase ? "i" : "", x = new RegExp(h, I);
          return function(W) {
            var V = o.getAttributeValue(W, G);
            return V != null && x.test(V) && a(W);
          };
        },
        exists: function(a, e, n) {
          var G = e.name, y = n.adapter;
          return function(h) {
            return y.hasAttrib(h, G) && a(h);
          };
        },
        start: function(a, e, n) {
          var G = e.name, y = e.value, o = y.length, h = n.adapter;
          return o === 0 ? d : e.ignoreCase ? (y = y.toLowerCase(), function(x) {
            var p = h.getAttributeValue(x, G);
            return p != null && p.substr(0, o).toLowerCase() === y && a(x);
          }) : function(x) {
            var p = h.getAttributeValue(x, G);
            return p != null && p.substr(0, o) === y && a(x);
          };
        },
        end: function(a, e, n) {
          var G = e.name, y = e.value, o = -y.length, h = n.adapter;
          return o === 0 ? d : e.ignoreCase ? (y = y.toLowerCase(), function(x) {
            var p = h.getAttributeValue(x, G);
            return p != null && p.substr(o).toLowerCase() === y && a(x);
          }) : function(x) {
            var p = h.getAttributeValue(x, G);
            return p != null && p.substr(o) === y && a(x);
          };
        },
        any: function(a, e, n) {
          var G = e.name, y = e.value, o = n.adapter;
          if (y === "")
            return d;
          if (e.ignoreCase) {
            var h = new RegExp(y.replace(s, "\\$&"), "i");
            return function(x) {
              var p = o.getAttributeValue(x, G);
              return p != null && h.test(p) && a(x);
            };
          }
          return function(x) {
            var p = o.getAttributeValue(x, G);
            return p != null && p.indexOf(y) >= 0 && a(x);
          };
        },
        not: function(a, e, n) {
          var G = e.name, y = e.value, o = n.adapter;
          return y === "" ? function(I) {
            return !!o.getAttributeValue(I, G) && a(I);
          } : e.ignoreCase ? (y = y.toLowerCase(), function(I) {
            var x = o.getAttributeValue(I, G);
            return x != null && x.toLowerCase() !== y && a(I);
          }) : function(I) {
            return o.getAttributeValue(I, G) !== y && a(I);
          };
        }
      };
      m.exports = {
        compile: function(a, e, n) {
          if (n && n.strict && (e.ignoreCase || e.action === "not"))
            throw new Error("Unsupported attribute selector");
          return X[e.action](a, e, n);
        },
        rules: X
      };
    },
    /* 282 */
    /***/
    function(m, l, i) {
      var d = i(283), s = i(273), X = i(281), a = s.trueFunc, e = s.falseFunc, n = X.rules.equals;
      function G(V, t) {
        var c = { name: V, value: t };
        return function(Z, r, S) {
          return n(Z, c, S);
        };
      }
      function y(V, t) {
        return function(c) {
          return !!t.getParent(c) && V(c);
        };
      }
      var o = {
        contains: function(V, t, c) {
          var b = c.adapter;
          return function(r) {
            return V(r) && b.getText(r).indexOf(t) >= 0;
          };
        },
        icontains: function(V, t, c) {
          var b = t.toLowerCase(), Z = c.adapter;
          return function(S) {
            return V(S) && Z.getText(S).toLowerCase().indexOf(b) >= 0;
          };
        },
        //location specific methods
        "nth-child": function(V, t, c) {
          var b = d(t), Z = c.adapter;
          return b === e ? b : b === a ? y(V, Z) : function(S) {
            for (var C = Z.getSiblings(S), F = 0, Y = 0; F < C.length; F++)
              if (Z.isTag(C[F])) {
                if (C[F] === S)
                  break;
                Y++;
              }
            return b(Y) && V(S);
          };
        },
        "nth-last-child": function(V, t, c) {
          var b = d(t), Z = c.adapter;
          return b === e ? b : b === a ? y(V, Z) : function(S) {
            for (var C = Z.getSiblings(S), F = 0, Y = C.length - 1; Y >= 0; Y--)
              if (Z.isTag(C[Y])) {
                if (C[Y] === S)
                  break;
                F++;
              }
            return b(F) && V(S);
          };
        },
        "nth-of-type": function(V, t, c) {
          var b = d(t), Z = c.adapter;
          return b === e ? b : b === a ? y(V, Z) : function(S) {
            for (var C = Z.getSiblings(S), F = 0, Y = 0; Y < C.length; Y++)
              if (Z.isTag(C[Y])) {
                if (C[Y] === S)
                  break;
                Z.getName(C[Y]) === Z.getName(S) && F++;
              }
            return b(F) && V(S);
          };
        },
        "nth-last-of-type": function(V, t, c) {
          var b = d(t), Z = c.adapter;
          return b === e ? b : b === a ? y(V, Z) : function(S) {
            for (var C = Z.getSiblings(S), F = 0, Y = C.length - 1; Y >= 0; Y--)
              if (Z.isTag(C[Y])) {
                if (C[Y] === S)
                  break;
                Z.getName(C[Y]) === Z.getName(S) && F++;
              }
            return b(F) && V(S);
          };
        },
        //TODO determine the actual root element
        root: function(V, t, c) {
          var b = c.adapter;
          return function(Z) {
            return !b.getParent(Z) && V(Z);
          };
        },
        scope: function(V, t, c, b) {
          var Z = c.adapter;
          if (!b || b.length === 0)
            return o.root(V, t, c);
          function r(S, C) {
            return typeof Z.equals == "function" ? Z.equals(S, C) : S === C;
          }
          return b.length === 1 ? function(S) {
            return r(b[0], S) && V(S);
          } : function(S) {
            return b.indexOf(S) >= 0 && V(S);
          };
        },
        //jQuery extensions (others follow as pseudos)
        checkbox: G("type", "checkbox"),
        file: G("type", "file"),
        password: G("type", "password"),
        radio: G("type", "radio"),
        reset: G("type", "reset"),
        image: G("type", "image"),
        submit: G("type", "submit"),
        //dynamic state pseudos. These depend on optional Adapter methods.
        hover: function(V, t, c) {
          var b = c.adapter;
          return typeof b.isHovered == "function" ? function(r) {
            return V(r) && b.isHovered(r);
          } : e;
        },
        visited: function(V, t, c) {
          var b = c.adapter;
          return typeof b.isVisited == "function" ? function(r) {
            return V(r) && b.isVisited(r);
          } : e;
        },
        active: function(V, t, c) {
          var b = c.adapter;
          return typeof b.isActive == "function" ? function(r) {
            return V(r) && b.isActive(r);
          } : e;
        }
      };
      function h(V, t) {
        for (var c = 0; V && c < V.length; c++)
          if (t.isTag(V[c]))
            return V[c];
      }
      var I = {
        empty: function(V, t) {
          return !t.getChildren(V).some(function(c) {
            return t.isTag(c) || c.type === "text";
          });
        },
        "first-child": function(V, t) {
          return h(t.getSiblings(V), t) === V;
        },
        "last-child": function(V, t) {
          for (var c = t.getSiblings(V), b = c.length - 1; b >= 0; b--) {
            if (c[b] === V)
              return !0;
            if (t.isTag(c[b]))
              break;
          }
          return !1;
        },
        "first-of-type": function(V, t) {
          for (var c = t.getSiblings(V), b = 0; b < c.length; b++)
            if (t.isTag(c[b])) {
              if (c[b] === V)
                return !0;
              if (t.getName(c[b]) === t.getName(V))
                break;
            }
          return !1;
        },
        "last-of-type": function(V, t) {
          for (var c = t.getSiblings(V), b = c.length - 1; b >= 0; b--)
            if (t.isTag(c[b])) {
              if (c[b] === V)
                return !0;
              if (t.getName(c[b]) === t.getName(V))
                break;
            }
          return !1;
        },
        "only-of-type": function(V, t) {
          for (var c = t.getSiblings(V), b = 0, Z = c.length; b < Z; b++)
            if (t.isTag(c[b])) {
              if (c[b] === V)
                continue;
              if (t.getName(c[b]) === t.getName(V))
                return !1;
            }
          return !0;
        },
        "only-child": function(V, t) {
          for (var c = t.getSiblings(V), b = 0; b < c.length; b++)
            if (t.isTag(c[b]) && c[b] !== V)
              return !1;
          return !0;
        },
        //:matches(a, area, link)[href]
        link: function(V, t) {
          return t.hasAttrib(V, "href");
        },
        //TODO: :any-link once the name is finalized (as an alias of :link)
        //forms
        //to consider: :target
        //:matches([selected], select:not([multiple]):not(> option[selected]) > option:first-of-type)
        selected: function(V, t) {
          if (t.hasAttrib(V, "selected"))
            return !0;
          if (t.getName(V) !== "option")
            return !1;
          var c = t.getParent(V);
          if (!c || t.getName(c) !== "select" || t.hasAttrib(c, "multiple"))
            return !1;
          for (var b = t.getChildren(c), Z = !1, r = 0; r < b.length; r++)
            if (t.isTag(b[r]))
              if (b[r] === V)
                Z = !0;
              else if (Z) {
                if (t.hasAttrib(b[r], "selected"))
                  return !1;
              } else
                return !1;
          return Z;
        },
        //https://html.spec.whatwg.org/multipage/scripting.html#disabled-elements
        //:matches(
        //  :matches(button, input, select, textarea, menuitem, optgroup, option)[disabled],
        //  optgroup[disabled] > option),
        // fieldset[disabled] * //TODO not child of first <legend>
        //)
        disabled: function(V, t) {
          return t.hasAttrib(V, "disabled");
        },
        enabled: function(V, t) {
          return !t.hasAttrib(V, "disabled");
        },
        //:matches(:matches(:radio, :checkbox)[checked], :selected) (TODO menuitem)
        checked: function(V, t) {
          return t.hasAttrib(V, "checked") || I.selected(V, t);
        },
        //:matches(input, select, textarea)[required]
        required: function(V, t) {
          return t.hasAttrib(V, "required");
        },
        //:matches(input, select, textarea):not([required])
        optional: function(V, t) {
          return !t.hasAttrib(V, "required");
        },
        //jQuery extensions
        //:not(:empty)
        parent: function(V, t) {
          return !I.empty(V, t);
        },
        //:matches(h1, h2, h3, h4, h5, h6)
        header: x(["h1", "h2", "h3", "h4", "h5", "h6"]),
        //:matches(button, input[type=button])
        button: function(V, t) {
          var c = t.getName(V);
          return c === "button" || c === "input" && t.getAttributeValue(V, "type") === "button";
        },
        //:matches(input, textarea, select, button)
        input: x(["input", "textarea", "select", "button"]),
        //input:matches(:not([type!='']), [type='text' i])
        text: function(V, t) {
          var c;
          return t.getName(V) === "input" && (!(c = t.getAttributeValue(V, "type")) || c.toLowerCase() === "text");
        }
      };
      function x(V) {
        if (typeof Set < "u") {
          var t = new Set(V);
          return function(c, b) {
            return t.has(b.getName(c));
          };
        }
        return function(c, b) {
          return V.indexOf(b.getName(c)) >= 0;
        };
      }
      function p(V, t, c) {
        if (c === null) {
          if (V.length > 2 && t !== "scope")
            throw new Error("pseudo-selector :" + t + " requires an argument");
        } else if (V.length === 2)
          throw new Error("pseudo-selector :" + t + " doesn't have any arguments");
      }
      var W = /^(?:(?:nth|last|first|only)-(?:child|of-type)|root|empty|(?:en|dis)abled|checked|not)$/;
      m.exports = {
        compile: function(V, t, c, b) {
          var Z = t.name, r = t.data, S = c.adapter;
          if (c && c.strict && !W.test(Z))
            throw new Error(":" + Z + " isn't part of CSS3");
          if (typeof o[Z] == "function")
            return o[Z](V, r, c, b);
          if (typeof I[Z] == "function") {
            var C = I[Z];
            return p(C, Z, r), C === e ? C : V === a ? function(Y) {
              return C(Y, S, r);
            } : function(Y) {
              return C(Y, S, r) && V(Y);
            };
          } else
            throw new Error("unmatched pseudo-class :" + Z);
        },
        filters: o,
        pseudos: I
      };
    },
    /* 283 */
    /***/
    function(m, l, i) {
      var d = i(284), s = i(285);
      m.exports = function(a) {
        return s(d(a));
      }, m.exports.parse = d, m.exports.compile = s;
    },
    /* 284 */
    /***/
    function(m, l) {
      m.exports = d;
      var i = /^([+\-]?\d*n)?\s*(?:([+\-]?)\s*(\d+))?$/;
      function d(s) {
        if (s = s.trim().toLowerCase(), s === "even")
          return [2, 0];
        if (s === "odd")
          return [2, 1];
        var X = s.match(i);
        if (!X)
          throw new SyntaxError("n-th rule couldn't be parsed ('" + s + "')");
        var a;
        return X[1] ? (a = parseInt(X[1], 10), isNaN(a) && (X[1].charAt(0) === "-" ? a = -1 : a = 1)) : a = 0, [
          a,
          X[3] ? parseInt((X[2] || "") + X[3], 10) : 0
        ];
      }
    },
    /* 285 */
    /***/
    function(m, l, i) {
      m.exports = a;
      var d = i(273), s = d.trueFunc, X = d.falseFunc;
      function a(e) {
        var n = e[0], G = e[1] - 1;
        if (G < 0 && n <= 0)
          return X;
        if (n === -1)
          return function(o) {
            return o <= G;
          };
        if (n === 0)
          return function(o) {
            return o === G;
          };
        if (n === 1)
          return G < 0 ? s : function(o) {
            return o >= G;
          };
        var y = G % n;
        return y < 0 && (y += n), n > 1 ? function(o) {
          return o >= G && o % n === y;
        } : (n *= -1, function(o) {
          return o <= G && o % n === y;
        });
      }
    },
    /* 286 */
    /***/
    function(m, l, i) {
      i.r(l), i.d(l, "default", function() {
        return r;
      });
      var d = i(12), s = i(74), X = i(1), a = i(68), e = i(250), n = i(213), G = i(218);
      i(1).glMatrix.setMatrixArrayType(Array);
      function y(S, C) {
        if (S == null)
          return {};
        var F = o(S, C), Y, J;
        if (Object.getOwnPropertySymbols) {
          var T = Object.getOwnPropertySymbols(S);
          for (J = 0; J < T.length; J++)
            Y = T[J], !(C.indexOf(Y) >= 0) && Object.prototype.propertyIsEnumerable.call(S, Y) && (F[Y] = S[Y]);
        }
        return F;
      }
      function o(S, C) {
        if (S == null)
          return {};
        var F = {}, Y = Object.keys(S), J, T;
        for (T = 0; T < Y.length; T++)
          J = Y[T], !(C.indexOf(J) >= 0) && (F[J] = S[J]);
        return F;
      }
      const h = {
        antialias: !0,
        autoRender: !0,
        alpha: !0
        // for wx-miniprogram
      }, I = Symbol("autoRender"), x = Symbol("renderer"), p = Symbol("timeline"), W = Symbol("prepareRender"), V = Symbol("tickRender"), t = Symbol("pass"), c = Symbol("fbo"), b = Symbol("tickers"), Z = Symbol("layerTransformInvert");
      class r extends e.default {
        constructor(C = {}) {
          if (super(), !C.canvas) {
            const {
              width: T,
              height: K
            } = this.getResolution(), R = d.ENV.createCanvas(T, K, {
              offscreen: !!C.offscreen,
              id: C.id,
              extra: C.extra
            });
            R.style && (R.style.position = "absolute"), R.dataset && (R.dataset.layerId = C.id), R.contextType && (C.contextType = R.contextType), C.canvas = R;
          }
          const F = C.canvas, Y = Object.assign({}, h, C);
          this[I] = Y.autoRender, delete C.autoRender;
          const J = Y.Renderer || d.Renderer;
          this[x] = new J(F, Y), this.options = C, this.id = C.id, this[t] = [], this.setResolution(F), this.canvas = F, this[p] = new s.Timeline(), this.__mouseCapturedTarget = null, this[Z] = null;
        }
        get autoRender() {
          return this[I];
        }
        get displayRatio() {
          return this.parent && this.parent.options ? this.parent.options.displayRatio : 1;
        }
        get height() {
          const {
            height: C
          } = this.getResolution();
          return C / this.displayRatio;
        }
        get gl() {
          return this.renderer.glRenderer ? this.renderer.glRenderer.gl : null;
        }
        /* override */
        get layer() {
          return this;
        }
        get offscreen() {
          return !!this.options.offscreen || this.canvas._offscreen;
        }
        get pass() {
          return this[t];
        }
        get prepareRender() {
          return this[W] ? this[W] : Promise.resolve();
        }
        /* override */
        get renderer() {
          return this[x];
        }
        get renderOffset() {
          if (this.parent && this.parent.options) {
            const {
              left: C,
              top: F
            } = this.parent.options;
            return [C, F];
          }
          return [this.options.left | 0, this.options.top | 0];
        }
        get timeline() {
          return this[p];
        }
        get width() {
          const {
            width: C
          } = this.getResolution();
          return C / this.displayRatio;
        }
        get localMatrix() {
          const {
            x: C,
            y: F
          } = this.attributes;
          return [1, 0, 0, 1, C, F];
        }
        get layerTransformInvert() {
          if (this[Z])
            return this[Z];
          const C = this.transformMatrix;
          return C[0] === 1 && C[1] === 0 && C[2] === 0 && C[3] === 1 && C[4] === 0 && C[5] === 0 ? null : (this[Z] = X.mat2d.invert(Array.of(0, 0, 0, 0, 0, 0), C), this[Z]);
        }
        forceContextLoss() {
          const C = this.renderer.glRenderer;
          if (C) {
            const F = C.getExtension("WEBGL_lose_context");
            if (F)
              return F.loseContext(), !0;
          }
          return !1;
        }
        // isPointCollision(x, y) {
        //   return true;
        // }
        addPass({
          vertex: C,
          fragment: F,
          options: Y,
          uniforms: J
        } = {}) {
          if (this.renderer.glRenderer) {
            const {
              width: T,
              height: K
            } = this.getResolution(), R = this.renderer.createPassProgram({
              vertex: C,
              fragment: F,
              options: Y
            }), H = new d.Figure2D();
            H.rect(0, 0, T / this.displayRatio, K / this.displayRatio);
            const f = new d.Mesh2D(H);
            return f.setUniforms(J), f.setProgram(R), this[t].push(f), this.forceUpdate(), f;
          }
          return null;
        }
        // delete unused texture to release memory.
        deleteTexture(C) {
          return Object(G.deleteTexture)(C, this.renderer);
        }
        /* override */
        dispatchPointerEvent(C) {
          const F = C.type;
          if (F === "mousedown" || F === "mouseup" || F === "mousemove") {
            const R = this.__mouseCapturedTarget;
            if (R) {
              if (R.layer === this)
                return R.dispatchEvent(C), !0;
              this.__mouseCapturedTarget = null;
            }
          }
          let Y, J;
          const T = this.layerTransformInvert;
          if (T) {
            Y = C.x, J = C.y;
            const R = T, H = R[0] * Y + R[2] * J + R[4], f = R[1] * Y + R[3] * J + R[5];
            delete C.x, delete C.y, delete C.layerX, delete C.layerY, Object.defineProperties(C, {
              layerX: {
                value: H,
                configurable: !0
              },
              layerY: {
                value: f,
                configurable: !0
              },
              x: {
                value: H,
                configurable: !0
              },
              y: {
                value: f,
                configurable: !0
              }
            });
          }
          const K = super.dispatchPointerEvent(C);
          return T && Object.defineProperties(C, {
            layerX: {
              value: Y,
              configurable: !0
            },
            layerY: {
              value: J,
              configurable: !0
            },
            x: {
              value: Y,
              configurable: !0
            },
            y: {
              value: J,
              configurable: !0
            }
          }), K;
        }
        /* override */
        forceUpdate() {
          if (!this[W])
            if (this.parent && this.parent.hasOffscreenCanvas) {
              this.parent.forceUpdate();
              let C = null;
              const F = new Promise((Y) => {
                C = Y;
              });
              F._resolve = C, this[W] = F;
            } else {
              let C = null, F = null;
              const Y = new Promise((J) => {
                C = J, this[I] && (F = Object(a.requestAnimationFrame)(() => {
                  delete Y._requestID, this.render();
                }));
              });
              Y._resolve = C, Y._requestID = F, this[W] = Y;
            }
        }
        getFBO() {
          const C = this.renderer.glRenderer, {
            width: F,
            height: Y
          } = this.getResolution();
          return C && (!this[c] || this[c].width !== F || this[c].height !== Y) ? (this[c] = {
            width: F,
            height: Y,
            target: C.createFBO(),
            buffer: C.createFBO(),
            swap() {
              [this.target, this.buffer] = [this.buffer, this.target];
            }
          }, this[c]) : this[c] ? this[c] : null;
        }
        updateGlobalTransform() {
          if (this.layerTransformInvert) {
            const C = this.renderer, F = C.__globalTransformMatrix || C.globalTransformMatrix;
            C.__globalTransformMatrix = F;
            const Y = X.mat2d.fromValues(1, 0, 0, 1, 0, 0);
            C.setGlobalTransform(...X.mat2d.multiply(Y, F, this.transformMatrix));
          }
        }
        /* override */
        onPropertyChange(C, F, Y) {
          if (super.onPropertyChange(C, F, Y), C === "zIndex" && (this.canvas.style.zIndex = F), C === "transform" || C === "translate" || C === "rotate" || C === "scale" || C === "skew") {
            const J = this[Z];
            if (this[Z] = null, this.updateGlobalTransform(), J && !this.layerTransformInvert) {
              const T = this.renderer, K = T.__globalTransformMatrix || T.globalTransformMatrix;
              T.setGlobalTransform(...K);
            }
          }
        }
        _prepareRenderFinished() {
          this[W] && (this[W]._requestID && Object(a.cancelAnimationFrame)(this[W]._requestID), this[W]._resolve(), delete this[W]);
        }
        render({
          clear: C = !0
        } = {}) {
          const F = this[t].length ? this.getFBO() : null;
          F && this.renderer.glRenderer.bindFBO(F.target), C && this[x].clear();
          const Y = this.draw();
          if (Y && Y.length && (this.renderer.drawMeshes(Y), this.canvas.draw && this.canvas.draw()), F) {
            const J = this.renderer.glRenderer, T = this[t].length, {
              width: K,
              height: R
            } = this.getResolution(), H = [0, 0, K / this.displayRatio, R / this.displayRatio];
            this[t].forEach((f, w) => {
              f.blend = !0, f.setTexture(F.target.texture, {
                rect: H
              }), w === T - 1 ? J.bindFBO(null) : (F.swap(), J.bindFBO(F.target)), this[x].clear(), this.renderer.drawMeshes([f]);
            });
          }
          this._prepareRenderFinished();
        }
        /* override */
        setResolution({
          width: C,
          height: F
        }) {
          const Y = this.renderer, J = Y.__globalTransformMatrix || Y.globalTransformMatrix, T = J[4], K = J[5], R = J[0], {
            width: H,
            height: f
          } = this.getResolution();
          (H !== C || f !== F) && (super.setResolution({
            width: C,
            height: F
          }), this.canvas && (this.canvas.width = C, this.canvas.height = F, Y.updateResolution && Y.updateResolution()), this.attributes.size = [C, F], this[t].length && this[t].forEach((k) => {
            const Q = new d.Figure2D();
            Q.rect(0, 0, C / this.displayRatio, F / this.displayRatio), k.contours = Q.contours;
          }));
          const [w, O] = this.renderOffset, q = this.displayRatio;
          (T !== w || K !== O || R !== q) && (Y.setGlobalTransform(q, 0, 0, q, w, O), Y.__globalTransformMatrix = null, this[Z] = null, this.updateGlobalTransform(), this.forceUpdate());
        }
        /**
         * tick(handler, {originTime = 0, playbackRate = 1.0, duration = Infinity})
         * @param {*} handler
         * @param {*} options
         */
        tick(C = null, F = {}) {
          let {
            duration: Y = 1 / 0
          } = F, J = y(F, ["duration"]);
          const T = this.timeline.fork(J), K = this;
          this[b] = this[b] || [], this[b].push({
            handler: C,
            duration: Y
          });
          const R = () => {
            let H = null, f = null;
            const w = () => {
              const O = this[b].map(({
                handler: q,
                duration: k
              }) => {
                const Q = Math.min(1, T.currentTime / k);
                return {
                  value: q ? q(T.currentTime, Q) : null,
                  p: Q
                };
              });
              K[V] || (K[V] = Promise.resolve().then(() => {
                K[I] && K.render(), delete K[V];
                for (let q = O.length - 1; q >= 0; q--) {
                  const {
                    value: k,
                    p: Q
                  } = O[q];
                  (k === !1 || Q >= 1) && this[b].splice(q, 1);
                }
                this[b].length > 0 && R();
              }));
            };
            if (this[W] && this[W]._type !== "ticker" && (Object(a.cancelAnimationFrame)(this[W]._requestID), delete this[W]), !this[W]) {
              const O = new Promise((q) => {
                H = q, f = Object(a.requestAnimationFrame)(w);
              });
              O._resolve = H, O._requestID = f, O._type = "ticker", this[W] = O;
            }
          };
          R();
        }
        toGlobalPos(C, F) {
          if (this.layerTransformInvert) {
            const H = this.transformMatrix;
            C = H[0] * C + H[2] * F + H[4], F = H[1] * C + H[3] * F + H[5];
          }
          const {
            width: Y,
            height: J
          } = this.getResolution(), T = this.renderOffset, K = [this.canvas.clientWidth, this.canvas.clientHeight];
          C = C * K[0] / Y + T[0], F = F * K[1] / J + T[1];
          const R = this.displayRatio;
          return C *= R, F *= R, [C, F];
        }
        toLocalPos(C, F) {
          const {
            width: Y,
            height: J
          } = this.getResolution(), T = this.renderOffset, K = [this.canvas.clientWidth, this.canvas.clientHeight];
          C = C * Y / K[0] - T[0], F = F * J / K[1] - T[1];
          const R = this.displayRatio;
          C /= R, F /= R;
          const H = this.layerTransformInvert;
          return H && (C = H[0] * C + H[2] * F + H[4], F = H[1] * C + H[3] * F + H[5]), [C, F];
        }
      }
      n.default.registerNode(r, "layer");
    },
    /* 287 */
    /***/
    function(m, l, i) {
      i.r(l), i.d(l, "default", function() {
        return W;
      });
      var d = i(224), s = i(288), X = i(213), a = i(252), e = i(72);
      i(1).glMatrix.setMatrixArrayType(Array);
      function n(V, t) {
        if (V == null)
          return {};
        var c = G(V, t), b, Z;
        if (Object.getOwnPropertySymbols) {
          var r = Object.getOwnPropertySymbols(V);
          for (Z = 0; Z < r.length; Z++)
            b = r[Z], !(t.indexOf(b) >= 0) && Object.prototype.propertyIsEnumerable.call(V, b) && (c[b] = V[b]);
        }
        return c;
      }
      function G(V, t) {
        if (V == null)
          return {};
        var c = {}, b = Object.keys(V), Z, r;
        for (r = 0; r < b.length; r++)
          Z = b[r], !(t.indexOf(Z) >= 0) && (c[Z] = V[Z]);
        return c;
      }
      function y(V, t, c) {
        return t in V ? Object.defineProperty(V, t, { value: c, enumerable: !0, configurable: !0, writable: !0 }) : V[t] = c, V;
      }
      const o = "http://www.w3.org/2000/svg", h = Symbol.for("spritejs_setAttribute"), I = Symbol("root"), x = Symbol("task");
      function p(V, t = !0) {
        const c = V[I];
        if (c && c.children[0]) {
          const b = V.svg, Z = V.layer ? V.layer.displayRatio : 1;
          if (!b.hasAttribute("data-original-width")) {
            let C = b.getAttribute("width");
            C = C ? Object(e.sizeToPixel)(C) : 300;
            let F = b.getAttribute("height");
            F = F ? Object(e.sizeToPixel)(F) : 150, b.hasAttribute("viewBox") || b.setAttribute("viewBox", `0 0 ${Math.round(C)} ${Math.round(F)}`), b.setAttribute("data-original-width", C), b.setAttribute("data-original-height", F);
          }
          let r = V.attributes.width || Number(b.getAttribute("data-original-width")), S = V.attributes.height || Number(b.getAttribute("data-original-height"));
          if (r *= Z, S *= Z, t && V.attributes.flexible) {
            const C = V.attributes.scale[0];
            if (r *= C, S *= C, b.setAttribute("width", r), b.setAttribute("height", S), r && S && V.textureImage) {
              const F = V.textureImage.width, Y = V.textureImage.height, J = V.clientSize;
              V.attributes.textureRect = [0, 0, Math.round(J[0] * F / r), Math.round(J[1] * Y / S)];
            }
          } else
            V[x] || (b.setAttribute("width", r), b.setAttribute("height", S), V[x] = Promise.resolve().then(() => {
              delete V[x];
              const C = c.innerHTML, F = new Blob([C], {
                type: "image/svg+xml"
              }), Y = URL.createObjectURL(F), J = new Image();
              J.onload = function() {
                J.width && J.height ? (V.attributes[h]("texture", J), V.attributes.flexible && (V.attributes.textureRect = null)) : V.attributes[h]("texture", null);
              }, J.src = Y;
            }));
        }
      }
      class W extends d.default {
        constructor(t = {}) {
          typeof t == "string" && (t = {
            svgText: t
          });
          let {
            svgText: c
          } = t, b = n(t, ["svgText"]);
          if (super(b), this[I] = document.createElement("div"), c) {
            this[I].innerHTML = c;
            const Z = this[I].children[0];
            Z ? Z.setAttribute("xmlns", o) : (fetch(c).then((r) => r.text()).then((r) => {
              this[I].innerHTML = r, (!this.observer || this.attributes.flexible) && p(this);
            }), c = null);
          }
          if (!c) {
            const Z = document.createElementNS(o, "svg");
            Z.setAttribute("xmlns", o), this[I].appendChild(Z);
          }
          if (typeof MutationObserver == "function") {
            const Z = new MutationObserver((r) => {
              p(this, !1);
            });
            Z.observe(this[I], {
              attributes: !0,
              subtree: !0,
              characterData: !0,
              childList: !0
            }), this.observer = Z;
          }
        }
        get children() {
          return [this.svg];
        }
        get childNodes() {
          return [this.svg];
        }
        get svg() {
          return this[I] ? this[I].children[0] : null;
        }
        /* override */
        setResolution({
          width: t,
          height: c
        }) {
          super.setResolution({
            width: t,
            height: c
          }), p(this);
        }
        /* override */
        dispatchPointerEvent(t) {
          const c = super.dispatchPointerEvent(t);
          if (c && this.attributes.passEvents && typeof MouseEvent == "function") {
            const {
              x: b,
              y: Z
            } = t;
            let [r, S] = this.getOffsetPosition(b, Z);
            const C = t.originalEvent, F = this.attributes.anchor, Y = this.clientSize;
            r = (r + F[0] * Y[0]) / 2, S = (S + F[1] * Y[1]) / 2;
            const J = t.type;
            if (J === C.type) {
              let T = null;
              if (C instanceof MouseEvent)
                T = new MouseEvent(J, {
                  screenX: r,
                  screenY: S,
                  clientX: r,
                  clientY: S,
                  bubbles: C.bubbles,
                  button: C.button,
                  buttons: C.buttons,
                  cancelBubble: C.cancelBubble,
                  cancelable: C.cancelable,
                  currentTarget: C.currentTarget,
                  fromElement: C.fromElement,
                  relatedTarget: C.relatedTarget,
                  returnValue: C.returnValue,
                  srcElement: C.srcElement,
                  target: C.target,
                  toElement: C.toElement,
                  // view: originalEvent.view,
                  which: C.witch
                });
              else if (C instanceof TouchEvent) {
                let K = null;
                const R = C.changedTouches || [C];
                for (let H = 0; H < R.length; H++) {
                  const f = R[H];
                  if (t.identifier === f.identifier) {
                    K = f;
                    break;
                  }
                }
                if (K) {
                  const H = new Touch({
                    identifier: K.identifier,
                    target: K.target,
                    clientX: r,
                    clientY: S,
                    screenX: r,
                    screenY: S,
                    pageX: r,
                    pageY: S,
                    radiusX: K.radiusX,
                    radiusY: K.radiusY,
                    rotationAngle: K.rotationAngle,
                    force: K.force
                  });
                  T = new TouchEvent(J, {
                    cancelable: C.cancelable,
                    bubbles: C.bubbles,
                    composed: C.composed,
                    touches: [H],
                    targetTouches: [H],
                    changedTouches: [H]
                  });
                }
              } else
                T = C;
              T && this.svg.dispatchEvent(T);
            }
          }
          return c;
        }
        getElementById(t) {
          return Object(a.querySelector)(`#${t}`, this);
        }
        getElementsByClassName(t) {
          return Object(a.querySelectorAll)(`.${t}`, this);
        }
        getElementsByName(t) {
          return Object(a.querySelectorAll)(`[name="${t}"]`, this);
        }
        getElementsByTagName(t) {
          return Object(a.querySelectorAll)(t, this);
        }
        querySelector(t) {
          return Object(a.querySelector)(t, this);
        }
        querySelectorAll(t) {
          return Object(a.querySelectorAll)(t, this);
        }
        /* override */
        onPropertyChange(t, c, b) {
          super.onPropertyChange(t, c, b), t === "flexible" && p(this), this.attributes.flexible && (t === "width" || t === "height" || t === "scale" || t === "transform") && p(this);
        }
      }
      y(W, "Attr", s.default), X.default.registerNode(W, "spritesvg");
    },
    /* 288 */
    /***/
    function(m, l, i) {
      i.r(l), i.d(l, "default", function() {
        return e;
      });
      var d = i(225);
      i(1).glMatrix.setMatrixArrayType(Array);
      const s = Symbol.for("spritejs_getAttribute"), X = Symbol.for("spritejs_setAttribute"), a = Symbol.for("spritejs_setAttributeDefault");
      class e extends d.default {
        constructor(G) {
          super(G), this[a]({
            passEvents: !1,
            flexible: !1
          });
        }
        // readonly
        get texture() {
          return this[s]("texture");
        }
        set texture(G) {
        }
        // eslint-disable-line no-empty-function
        get passEvents() {
          return this[s]("passEvents");
        }
        set passEvents(G) {
          return this[X]("passEvents", G);
        }
        get flexible() {
          return this[s]("flexible");
        }
        set flexible(G) {
          return this[X]("flexible", G);
        }
      }
    },
    /* 289 */
    /***/
    function(m, l, i) {
      i.r(l);
      var d = i(12);
      i(1).glMatrix.setMatrixArrayType(Array);
      function s(G, y) {
        var o = Object.keys(G);
        if (Object.getOwnPropertySymbols) {
          var h = Object.getOwnPropertySymbols(G);
          y && (h = h.filter(function(I) {
            return Object.getOwnPropertyDescriptor(G, I).enumerable;
          })), o.push.apply(o, h);
        }
        return o;
      }
      function X(G) {
        for (var y = 1; y < arguments.length; y++) {
          var o = arguments[y] != null ? arguments[y] : {};
          y % 2 ? s(Object(o), !0).forEach(function(h) {
            a(G, h, o[h]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(G, Object.getOwnPropertyDescriptors(o)) : s(Object(o)).forEach(function(h) {
            Object.defineProperty(G, h, Object.getOwnPropertyDescriptor(o, h));
          });
        }
        return G;
      }
      function a(G, y, o) {
        return y in G ? Object.defineProperty(G, y, { value: o, enumerable: !0, configurable: !0, writable: !0 }) : G[y] = o, G;
      }
      const e = Symbol("inited");
      let n = null;
      typeof Worker == "function" && (n = class extends Worker {
        constructor(G) {
          if (G.worker === !0 && (G.worker = `./${G.id}.worker.js`), super(G.worker), this.options = G, !G.canvas) {
            const {
              width: y,
              height: o
            } = this.getResolution(), h = d.ENV.createCanvas(y, o, {
              offscreen: !1
            });
            h.style && (h.style.position = "absolute"), h.dataset && (h.dataset.layerId = G.id), G.canvas = h;
          }
          this.canvas = G.canvas;
        }
        get id() {
          return this.options.id;
        }
        setResolution({
          width: G,
          height: y
        }) {
          if (this[e])
            this.postMessage({
              type: "resolution_change",
              width: G,
              height: y
            });
          else {
            this.canvas.width = G, this.canvas.height = y;
            const o = this.options, h = o.canvas.transferControlToOffscreen(), I = X({}, o);
            delete I.container, I.canvas = h, this.postMessage({
              type: "create",
              options: I
            }, [h]), this[e] = !0;
          }
        }
        getResolution() {
          if (this.canvas) {
            const {
              width: G,
              height: y
            } = this.canvas;
            return {
              width: G,
              height: y
            };
          }
          return {
            width: 300,
            height: 150
          };
        }
        remove() {
          return this.parent && this.parent.removeChild ? (this.parent.removeChild(this), !0) : !1;
        }
        connect(G, y) {
          Object.defineProperty(this, "parent", {
            value: G,
            writable: !1,
            configurable: !0
          }), Object.defineProperty(this, "zOrder", {
            value: y,
            writable: !1,
            configurable: !0
          });
        }
        disconnect() {
          delete this.parent, delete this.zOrder;
        }
        dispatchPointerEvent(G) {
          this.postMessage({
            type: "event",
            event: {
              cancelBubble: G.cancelBubble,
              bubbles: G.bubbles,
              detail: G.detail,
              identifier: G.identifier,
              layerX: G.layerX,
              layerY: G.layerY,
              originalX: G.originalX,
              originalY: G.originalY,
              type: G.type,
              x: G.x,
              y: G.y
            }
          });
        }
      }), l.default = n;
    },
    /* 290 */
    /***/
    function(m, l, i) {
      i.r(l), (function(d) {
        i.d(l, "default", function() {
          return r;
        });
        var s = i(12), X = i(68), a = i(70), e = i(286), n = i(289), G = i(250), y = i(291), o = i(214), h = i(218), I = i(213);
        i(1).glMatrix.setMatrixArrayType(Array);
        const x = Symbol("enteredTargets");
        function p(S) {
          return S.id = S.id || `_layer${Math.random().toString(36).slice(2, 12)}`, S.dataset || (S.dataset = {}), S.dataset.layerId = S.id, S.connect = (C, F) => {
            S.parent = C, Object.defineProperty(S, "zOrder", {
              value: F,
              writable: !1,
              configurable: !0
            });
          }, S.disconnect = (C) => {
            delete S.zOrder;
          }, S.canvas = S, S.getResolution = () => ({
            width: 0,
            height: 0
          }), S.setResolution = () => !1, S.options = {
            handleEvent: !1
          }, S;
        }
        function W(S, C) {
          const F = S.children;
          let Y = null;
          for (let J = 0; J < F.length; J++) {
            const T = F[J];
            if ((C === T || Y != null) && (Y = T), Y && Y !== C && !Y.offscreen)
              return Y.canvas;
          }
          return null;
        }
        function V(S, C) {
          const [F, Y] = S.renderOffset, {
            width: J,
            height: T
          } = S.getResolution(), K = S.displayRatio;
          S.renderer.drawImage(C.canvas, -F / K, -Y / K, J / K, T / K);
        }
        const t = {};
        function c(S) {
          const C = ["mousedown", "mouseup", "mousemove", "mousewheel", "wheel", "touchstart", "touchend", "touchmove", "touchcancel", "click", "dblclick", "longpress", "tap", "contextmenu"], F = S.container;
          F.addEventListener("mouseleave", (Y) => {
            const J = S[x];
            if (J.size) {
              const T = new o.default("mouseleave");
              T.setOriginalEvent(Y), [...J].forEach((K) => {
                K.dispatchEvent(T);
              }), S[x].clear();
            }
          }, {
            passive: !0
          }), C.forEach((Y) => {
            F.addEventListener(Y, (J) => {
              const {
                left: T,
                top: K,
                displayRatio: R
              } = S.options, H = S.orderedChildren;
              Object(y.default)(J, {
                offsetLeft: T,
                offsetTop: K,
                displayRatio: R
              }).forEach((w) => {
                const O = w.identifier;
                if (w.type === "touchmove" || w.type === "touchend") {
                  const k = t[O];
                  k && k.dispatchEvent(w), w.type === "touchend" && delete t[O];
                } else {
                  for (let k = H.length - 1; k >= 0; k--) {
                    const Q = H[k];
                    if (Q.options.handleEvent !== !1) {
                      if (Q.dispatchPointerEvent(w) && w.target !== Q)
                        break;
                      w.cancelBubble = !1;
                    }
                  }
                  if (w.target === H[0])
                    for (let k = H.length - 1; k >= 0; k--) {
                      const Q = H[k];
                      if (Q.options.handleEvent !== !1) {
                        w.target = Q;
                        break;
                      }
                    }
                }
                const q = w.target;
                if (w.type === "touchstart" && (t[O] = w.target), w.type === "mousemove") {
                  const k = S[x];
                  let Q;
                  if (q) {
                    const _ = q.ancestors || [];
                    Q = /* @__PURE__ */ new Set([q, ..._]);
                  } else
                    Q = /* @__PURE__ */ new Set();
                  const D = Object.entries(J);
                  if (!k.has(q) && q) {
                    const _ = new o.default("mouseenter");
                    _.setOriginalEvent(J), D.forEach(([$, Xi]) => {
                      _[$] = Xi;
                    }), k.add(q), q.dispatchEvent(_);
                    const bi = q.ancestors;
                    bi && bi.forEach(($) => {
                      $ instanceof a.default && !k.has($) && (k.add($), $.dispatchEvent(_));
                    });
                  }
                  const ii = new o.default("mouseleave");
                  ii.setOriginalEvent(J), D.forEach(([_, bi]) => {
                    ii[_] = bi;
                  }), [...k].forEach((_) => {
                    Q.has(_) || (k.delete(_), _.dispatchEvent(ii));
                  });
                }
              });
            }, {
              passive: Y !== "contextmenu"
            });
          });
        }
        function b(S, C) {
          if (C && C.style) {
            let {
              width: F,
              height: Y,
              mode: J,
              container: T
            } = S;
            const {
              clientWidth: K,
              clientHeight: R
            } = T;
            F = F || K, Y = Y || R, J === "static" ? (C.style.width = `${F}px`, C.style.height = `${Y}px`) : (C.style.top = "0", C.style.left = "0", C.style.width = `${K}px`, C.style.height = `${R}px`, C.style.transform = "", C.style.webkitTransform = "");
          }
        }
        const Z = Symbol("offscreenLayerCount");
        class r extends G.default {
          /**
            width
            height
            mode: 'static', 'scale', 'stickyWidth', 'stickyHeight', 'stickyTop', 'stickyBottom', 'stickyLeft', 'stickyRight'
           */
          constructor(C = {}) {
            if (super(), !C.container)
              if (typeof s.ENV.Container == "function")
                C.container = new s.ENV.Container(C.width || 300, C.height || 150);
              else
                throw new Error("No container specified.");
            if (this.container = C.container, this.container.style && (this.container.style.overflow || (this.container.style.overflow = "hidden"), this.container.style.position || (this.container.style.position = "relative")), this.options = C, C.displayRatio = C.displayRatio || 1, C.mode = C.mode || "scale", C.left = 0, C.top = 0, C.autoResize = C.autoResize !== !1, C.autoResize) {
              let F;
              if (typeof globalThis < "u" ? F = globalThis : F = typeof window < "u" ? window : d, F.addEventListener) {
                const Y = this;
                F.addEventListener("resize", function J() {
                  typeof document < "u" && document.contains(Y.container) ? Y.resize() : F.removeEventListener("resize", J);
                });
              }
            }
            this[x] = /* @__PURE__ */ new Set(), this.setResolution(C), c(this), this[Z] = 0;
          }
          get hasOffscreenCanvas() {
            return this[Z] > 0;
          }
          set displayRatio(C) {
            this.options.displayRatio !== C && (this.options.displayRatio = C, this.resize());
          }
          get displayRatio() {
            return this.options.displayRatio;
          }
          set height(C) {
            this.options.height !== C && (this.options.height = C, this.resize());
          }
          get height() {
            return this.options.height;
          }
          set mode(C) {
            this.options.mode !== C && (this.options.mode = C, this.resize());
          }
          get mode() {
            return this.options.mode;
          }
          set width(C) {
            this.options.width !== C && (this.options.width = C, this.resize());
          }
          get width() {
            return this.options.width;
          }
          /* override */
          appendChild(C) {
            !(C instanceof e.default) && !(C instanceof n.default) && p(C);
            const F = super.appendChild(C), Y = C.canvas;
            return C.offscreen ? this[Z]++ : this.container.appendChild(Y), b(this.options, Y), C.setResolution(this.getResolution()), F;
          }
          /* override */
          forceUpdate() {
            this.hasOffscreenCanvas && !this._requestID && (this._requestID = Object(X.requestAnimationFrame)(() => {
              delete this._requestID, this.render();
            }));
          }
          /* override */
          insertBefore(C, F) {
            !(C instanceof e.default) && !(C instanceof n.default) && p(C);
            const Y = super.insertBefore(C, F), J = C.canvas;
            if (!C.offscreen) {
              const T = W(this, C);
              this.container.insertBefore(J, T);
            }
            return b(this.options, J), C.setResolution(this.getResolution()), Y;
          }
          layer(C = "default", F = {}) {
            F = Object.assign({}, this.options, F), F.id = C;
            const Y = this.orderedChildren;
            for (let K = 0; K < Y.length; K++)
              if (Y[K].id === C)
                return Y[K];
            const J = F.worker;
            let T;
            return J ? T = new n.default(F) : T = new e.default(F), this.appendChild(T), T;
          }
          async preload(...C) {
            const F = [], Y = [], J = [];
            for (let T = 0; T < C.length; T++) {
              const K = C[T];
              let R;
              if (typeof K == "string")
                R = Object(h.loadTexture)(K);
              else if (Array.isArray(K))
                R = Object(h.loadFrames)(...K);
              else {
                const {
                  id: H,
                  src: f
                } = K;
                R = Object(h.loadTexture)(f, H);
              }
              R instanceof Promise || (R = Promise.resolve(R)), Y.push(R.then((H) => {
                F.push(H), J[T] = H;
                const f = new o.default({
                  type: "preload",
                  detail: {
                    current: H,
                    loaded: F,
                    resources: C
                  }
                });
                this.dispatchEvent(f);
              }));
            }
            return await Promise.all(Y), J;
          }
          /* override */
          removeChild(C) {
            const F = super.removeChild(C);
            if (F) {
              C._prepareRenderFinished && C._prepareRenderFinished();
              const Y = C.canvas;
              Y && Y.remove && Y.remove(), C.offscreen && this[Z]--;
            }
            return F;
          }
          // for offscreen mode rendering
          render() {
            const C = this.orderedChildren;
            let F = null;
            const Y = [];
            for (let J = 0; J < C.length; J++) {
              const T = C[J], K = Y.length > 0;
              if (T instanceof e.default && !T.offscreen)
                if (!T.autoRender)
                  K && (console.warn("Some offscreen canvas will not be rendered."), Y.length = 0);
                else if (F = T, K) {
                  T.renderer.clear();
                  for (let R = 0; R < Y.length; R++) {
                    const H = Y[R];
                    H.render(), V(T, H);
                  }
                  Y.length = 0, T.render({
                    clear: !1
                  });
                } else
                  T.prepareRender && T.render();
              else
                T.offscreen ? F ? (T.prepareRender && T.render(), V(F, T)) : Y.push(T) : T instanceof n.default && K && (console.warn("Some offscreen canvas will not be rendered."), Y.length = 0);
            }
          }
          /* override */
          replaceChild(C, F) {
            const Y = super.replaceChild(C, F);
            F.canvas.remove && F.canvas.remove(), F.offscreen && this[Z]--;
            const J = C.canvas;
            if (!C.offscreen) {
              const T = W(this, C);
              this.container.insertBefore(J, T);
            }
            return b(this.options, J), C.setResolution(this.getResolution()), Y;
          }
          resize() {
            const C = this.options;
            this.children.forEach((F) => {
              b(C, F.canvas);
            }), this.setResolution(C), this.dispatchEvent({
              type: "resize"
            });
          }
          /* override */
          setResolution({
            width: C,
            height: F
          } = {}) {
            const Y = this.container, {
              clientWidth: J,
              clientHeight: T
            } = Y;
            (C == null || F == null) && (C = C ?? J, F = F ?? T);
            const {
              mode: K,
              displayRatio: R
            } = this.options;
            if (C *= R, F *= R, this.options.left = 0, this.options.top = 0, K === "stickyHeight" || K === "stickyLeft" || K === "stickyRight") {
              const H = C;
              C = J * F / T, K === "stickyHeight" && (this.options.left = 0.5 * (C - H)), K === "stickyRight" && (this.options.left = C - H);
            } else if (K === "stickyWidth" || K === "stickyTop" || K === "stickyBottom") {
              const H = F;
              F = T * C / J, K === "stickyWidth" && (this.options.top = 0.5 * (F - H)), K === "stickyBottom" && (this.options.top = F - H);
            }
            super.setResolution({
              width: C,
              height: F
            });
          }
          snapshot({
            offscreen: C = !1,
            layers: F
          } = {}) {
            const Y = C ? "snapshotOffScreenCanvas" : "snapshotCanvas", {
              width: J,
              height: T
            } = this.getResolution();
            this[Y] = this[Y] || s.ENV.createCanvas(J, T, {
              offscreen: C
            });
            const K = this[Y].getContext("2d");
            F = F || this.orderedChildren, this[Y].width = J, this[Y].height = T;
            for (let R = 0; R < F.length; R++) {
              const H = F[R];
              if (!H.options.ignoreSnapshot) {
                H.render && H.render();
                const f = H.canvas;
                f && f !== H && K.drawImage(f, 0, 0, J, T);
              }
            }
            return this[Y];
          }
        }
        typeof document < "u" && (r.prototype.layer3d = function(S, C = {}) {
          const F = C.url || "https://unpkg.com/sprite-extend-3d/dist/sprite-extend-3d.min.js";
          return new Promise((Y, J) => {
            const T = document.createElement("script");
            T.async = !1, T.src = F, T.onload = () => {
              try {
                Y(this.layer3d(S, C));
              } catch (K) {
                J(K);
              }
            }, document.documentElement.appendChild(T);
          });
        }), I.default.registerNode(r, "scene");
      }).call(this, i(22));
    },
    /* 291 */
    /***/
    function(m, l, i) {
      i.r(l), i.d(l, "default", function() {
        return s;
      });
      var d = i(214);
      i(1).glMatrix.setMatrixArrayType(Array);
      function s(X, {
        offsetTop: a = 0,
        offsetLeft: e = 0,
        displayRatio: n = 1
      } = {}) {
        let G, y;
        const o = [], {
          left: h,
          top: I,
          width: x,
          height: p
        } = X.target.getBoundingClientRect(), W = X.target.width, V = X.target.height, t = X.changedTouches || [X];
        for (let b = 0; b < t.length; b++) {
          const Z = t[b], r = Z.identifier, {
            clientX: S,
            clientY: C
          } = Z;
          S != null && C != null && o.push({
            x: Math.round((S | 0) - h),
            y: Math.round((C | 0) - I),
            identifier: r
          });
        }
        o.length <= 0 && o.push({
          x: G,
          y
        });
        const c = [];
        return o.forEach((b) => {
          b.x != null && b.y != null && (G = (b.x * W / x - e) / n, y = (b.y * V / p - a) / n);
          const Z = new d.default(X);
          Object.defineProperties(Z, {
            layerX: {
              value: G,
              configurable: !0
            },
            layerY: {
              value: y,
              configurable: !0
            },
            originalX: {
              value: b.x
            },
            originalY: {
              value: b.y
            },
            x: {
              value: G,
              configurable: !0
            },
            y: {
              value: y,
              configurable: !0
            },
            identifier: {
              value: b.identifier
            }
          }), c.push(Z);
        }), c;
      }
    }
    /******/
  ])
);
Hi.version;
Hi.Arc;
Hi.Block;
Hi.Cloud;
Hi.Color;
Hi.Ellipse;
Hi.Gradient;
const _o = Hi.Group;
Hi.Label;
Hi.Layer;
Hi.LayerWorker;
Hi.Node;
Hi.Parallel;
Hi.Path;
Hi.Polyline;
const ut = Hi.Rect;
Hi.Regular;
Hi.Ring;
Hi.Scene;
Hi.Sprite;
Hi.SpriteSvg;
Hi.Star;
Hi.Triangle;
Hi.helpers;
Hi.createElement;
Hi.isSpriteNode;
Hi.registerNode;
Hi.requestAnimationFrame;
Hi.cancelAnimationFrame;
Hi.ENV;
const ia = {
  linear: (m) => m,
  easeInQuad: (m) => m * m,
  easeOutQuad: (m) => m * (2 - m),
  easeInOutQuad: (m) => m < 0.5 ? 2 * m * m : -1 + (4 - 2 * m) * m,
  easeInCubic: (m) => m * m * m,
  easeOutCubic: (m) => --m * m * m + 1,
  easeInOutCubic: (m) => m < 0.5 ? 4 * m * m * m : (m - 1) * (2 * m - 2) * (2 * m - 2) + 1,
  easeInQuart: (m) => m * m * m * m,
  easeOutQuart: (m) => 1 - --m * m * m * m,
  easeInOutQuart: (m) => m < 0.5 ? 8 * m * m * m * m : 1 - 8 * --m * m * m * m,
  easeInQuint: (m) => m * m * m * m * m,
  easeOutQuint: (m) => 1 + --m * m * m * m * m,
  easeInOutQuint: (m) => m < 0.5 ? 16 * m * m * m * m * m : 1 + 16 * --m * m * m * m * m,
  easeInSine: (m) => 1 - Math.cos(m * Math.PI / 2),
  easeOutSine: (m) => Math.sin(m * Math.PI / 2),
  easeInOutSine: (m) => -(Math.cos(Math.PI * m) - 1) / 2,
  easeInExpo: (m) => m <= 0 ? 0 : Math.pow(2, 10 * m - 10),
  easeOutExpo: (m) => m >= 1 ? 1 : 1 - Math.pow(2, -10 * m),
  easeInOutExpo: (m) => m <= 0 ? 0 : m >= 1 ? 1 : m < 0.5 ? Math.pow(2, 20 * m - 10) / 2 : (2 - Math.pow(2, -20 * m + 10)) / 2
};
class Gi {
  constructor(l = 0, i = 0, d = 1) {
    Object.defineProperty(this, "x", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: l
    }), Object.defineProperty(this, "y", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: i
    }), Object.defineProperty(this, "z", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: d
    });
  }
  get XY() {
    return [this.x, this.y];
  }
  setz(l) {
    return this.z = l, this;
  }
  setXY(l = this.x, i = this.y) {
    return this.x = l, this.y = i, this;
  }
  set(l = this.x, i = this.y, d = this.z) {
    return this.x = l, this.y = i, this.z = d, this;
  }
  setTo({ x: l = 0, y: i = 0, z: d = 1 }) {
    return this.x = l, this.y = i, this.z = d, this;
  }
  rot(l) {
    if (l === 0)
      return this;
    const { x: i, y: d } = this, s = Math.sin(l), X = Math.cos(l);
    return this.x = i * X - d * s, this.y = i * s + d * X, this;
  }
  rotWith(l, i) {
    if (i === 0)
      return this;
    const d = this.x - l.x, s = this.y - l.y, X = Math.sin(i), a = Math.cos(i);
    return this.x = l.x + (d * a - s * X), this.y = l.y + (d * X + s * a), this;
  }
  clone() {
    const { x: l, y: i, z: d } = this;
    return new Gi(l, i, d);
  }
  sub(l) {
    return this.x -= l.x, this.y -= l.y, this;
  }
  subXY(l, i) {
    return this.x -= l, this.y -= i, this;
  }
  subScalar(l) {
    return this.x -= l, this.y -= l, this;
  }
  add(l) {
    return this.x += l.x, this.y += l.y, this;
  }
  addXY(l, i) {
    return this.x += l, this.y += i, this;
  }
  addScalar(l) {
    return this.x += l, this.y += l, this;
  }
  clamp(l, i) {
    return this.x = Math.max(this.x, l), this.y = Math.max(this.y, l), i !== void 0 && (this.x = Math.min(this.x, i), this.y = Math.min(this.y, i)), this;
  }
  div(l) {
    return this.x /= l, this.y /= l, this;
  }
  divV(l) {
    return this.x /= l.x, this.y /= l.y, this;
  }
  mul(l) {
    return this.x *= l, this.y *= l, this;
  }
  mulV(l) {
    return this.x *= l.x, this.y *= l.y, this;
  }
  abs() {
    return this.x = Math.abs(this.x), this.y = Math.abs(this.y), this;
  }
  nudge(l, i) {
    const d = Gi.Tan(l, this);
    return this.add(d.mul(i));
  }
  neg() {
    return this.x *= -1, this.y *= -1, this;
  }
  cross(l) {
    return this.x = this.y * l.z - this.z * l.y, this.y = this.z * l.x - this.x * l.z, this;
  }
  dpr(l) {
    return Gi.Dpr(this, l);
  }
  cpr(l) {
    return Gi.Cpr(this, l);
  }
  len2() {
    return Gi.Len2(this);
  }
  len() {
    return Gi.Len(this);
  }
  pry(l) {
    return Gi.Pry(this, l);
  }
  per() {
    const { x: l, y: i } = this;
    return this.x = i, this.y = -l, this;
  }
  uni() {
    return Gi.Uni(this);
  }
  tan(l) {
    return Gi.Tan(this, l);
  }
  dist(l) {
    return Gi.Dist(this, l);
  }
  distanceToLineSegment(l, i) {
    return Gi.DistanceToLineSegment(l, i, this);
  }
  slope(l) {
    return Gi.Slope(this, l);
  }
  snapToGrid(l) {
    return this.x = Math.round(this.x / l) * l, this.y = Math.round(this.y / l) * l, this;
  }
  angle(l) {
    return Gi.Angle(this, l);
  }
  toAngle() {
    return Gi.ToAngle(this);
  }
  lrp(l, i) {
    return this.x = this.x + (l.x - this.x) * i, this.y = this.y + (l.y - this.y) * i, this;
  }
  equals(l, i) {
    return Gi.Equals(this, l, i);
  }
  equalsXY(l, i) {
    return Gi.EqualsXY(this, l, i);
  }
  norm() {
    const l = this.len();
    return this.x = l === 0 ? 0 : this.x / l, this.y = l === 0 ? 0 : this.y / l, this;
  }
  toFixed() {
    return Gi.ToFixed(this);
  }
  toString() {
    return Gi.ToString(Gi.ToFixed(this));
  }
  toJson() {
    return Gi.ToJson(this);
  }
  toArray() {
    return Gi.ToArray(this);
  }
  static Add(l, i) {
    return new Gi(l.x + i.x, l.y + i.y);
  }
  static AddXY(l, i, d) {
    return new Gi(l.x + i, l.y + d);
  }
  static Sub(l, i) {
    return new Gi(l.x - i.x, l.y - i.y);
  }
  static SubXY(l, i, d) {
    return new Gi(l.x - i, l.y - d);
  }
  static AddScalar(l, i) {
    return new Gi(l.x + i, l.y + i);
  }
  static SubScalar(l, i) {
    return new Gi(l.x - i, l.y - i);
  }
  static Div(l, i) {
    return new Gi(l.x / i, l.y / i);
  }
  static Mul(l, i) {
    return new Gi(l.x * i, l.y * i);
  }
  static DivV(l, i) {
    return new Gi(l.x / i.x, l.y / i.y);
  }
  static MulV(l, i) {
    return new Gi(l.x * i.x, l.y * i.y);
  }
  static Neg(l) {
    return new Gi(-l.x, -l.y);
  }
  static Per(l) {
    return new Gi(l.y, -l.x);
  }
  static Dist2(l, i) {
    return Gi.Sub(l, i).len2();
  }
  static Abs(l) {
    return new Gi(Math.abs(l.x), Math.abs(l.y));
  }
  static Dist(l, i) {
    return Math.hypot(l.y - i.y, l.x - i.x);
  }
  static Dpr(l, i) {
    return l.x * i.x + l.y * i.y;
  }
  static Cross(l, i) {
    return new Gi(
      l.y * i.z - l.z * i.y,
      l.z * i.x - l.x * i.z
      // A.z = A.x * V.y - A.y * V.x
    );
  }
  static Cpr(l, i) {
    return l.x * i.y - i.x * l.y;
  }
  static Len2(l) {
    return l.x * l.x + l.y * l.y;
  }
  static Len(l) {
    return Math.hypot(l.x, l.y);
  }
  static Pry(l, i) {
    return Gi.Dpr(l, i) / Gi.Len(i);
  }
  static Uni(l) {
    return Gi.Div(l, Gi.Len(l));
  }
  static Tan(l, i) {
    return Gi.Uni(Gi.Sub(l, i));
  }
  static Min(l, i) {
    return new Gi(Math.min(l.x, i.x), Math.min(l.y, i.y));
  }
  static Max(l, i) {
    return new Gi(Math.max(l.x, i.x), Math.max(l.y, i.y));
  }
  static From(l) {
    return new Gi().add(l);
  }
  static FromArray(l) {
    return new Gi(l[0], l[1]);
  }
  static Rot(l, i = 0) {
    const d = Math.sin(i), s = Math.cos(i);
    return new Gi(l.x * s - l.y * d, l.x * d + l.y * s);
  }
  static RotWith(l, i, d) {
    const s = l.x - i.x, X = l.y - i.y, a = Math.sin(d), e = Math.cos(d);
    return new Gi(i.x + (s * e - X * a), i.y + (s * a + X * e));
  }
  /**
   * Get the nearest point on a line with a known unit vector that passes through point A
   *
   * ```ts
   * Vec.nearestPointOnLineThroughPoint(A, u, Point)
   * ```
   *
   * @param A - Any point on the line
   * @param u - The unit vector for the line.
   * @param P - A point not on the line to test.
   */
  static NearestPointOnLineThroughPoint(l, i, d) {
    return Gi.Mul(i, Gi.Sub(d, l).pry(i)).add(l);
  }
  static NearestPointOnLineSegment(l, i, d, s = !0) {
    const X = Gi.Tan(i, l), a = Gi.Add(l, Gi.Mul(X, Gi.Sub(d, l).pry(X)));
    if (s) {
      if (a.x < Math.min(l.x, i.x))
        return Gi.Cast(l.x < i.x ? l : i);
      if (a.x > Math.max(l.x, i.x))
        return Gi.Cast(l.x > i.x ? l : i);
      if (a.y < Math.min(l.y, i.y))
        return Gi.Cast(l.y < i.y ? l : i);
      if (a.y > Math.max(l.y, i.y))
        return Gi.Cast(l.y > i.y ? l : i);
    }
    return a;
  }
  static DistanceToLineThroughPoint(l, i, d) {
    return Gi.Dist(d, Gi.NearestPointOnLineThroughPoint(l, i, d));
  }
  static DistanceToLineSegment(l, i, d, s = !0) {
    return Gi.Dist(d, Gi.NearestPointOnLineSegment(l, i, d, s));
  }
  static Snap(l, i = 1) {
    return new Gi(Math.round(l.x / i) * i, Math.round(l.y / i) * i);
  }
  static Cast(l) {
    return l instanceof Gi ? l : Gi.From(l);
  }
  static Slope(l, i) {
    return l.x === i.y ? NaN : (l.y - i.y) / (l.x - i.x);
  }
  static Angle(l, i) {
    return Math.atan2(i.y - l.y, i.x - l.x);
  }
  static Lrp(l, i, d) {
    return Gi.Sub(i, l).mul(d).add(l);
  }
  static Med(l, i) {
    return new Gi((l.x + i.x) / 2, (l.y + i.y) / 2);
  }
  static Equals(l, i, d = 1e-4) {
    return Math.abs(l.x - i.x) < d && Math.abs(l.y - i.y) < d;
  }
  static EqualsXY(l, i, d) {
    return l.x === i && l.y === d;
  }
  static EqualsXYZ(l, i, d = 1e-4) {
    return Gi.Equals(l, i, d) && Math.abs((l.z || 0) - (i.z || 0)) < d;
  }
  static Clockwise(l, i, d) {
    return (d.x - l.x) * (i.y - l.y) - (i.x - l.x) * (d.y - l.y) < 0;
  }
  static Rescale(l, i) {
    const d = Gi.Len(l);
    return new Gi(i * l.x / d, i * l.y / d);
  }
  static ScaleWithOrigin(l, i, d) {
    return Gi.Sub(l, d).mul(i).add(d);
  }
  static ScaleWOrigin(l, i, d) {
    return Gi.Sub(l, d).mulV(i).add(d);
  }
  static ToFixed(l, i = 2) {
    return new Gi(+l.x.toFixed(i), +l.y.toFixed(i), +l.z.toFixed(i));
  }
  static Nudge(l, i, d) {
    return Gi.Add(l, Gi.Tan(i, l).mul(d));
  }
  static ToString(l) {
    return `${l.x}, ${l.y}`;
  }
  static ToAngle(l) {
    let i = Math.atan2(l.y, l.x);
    return i < 0 && (i += Math.PI * 2), i;
  }
  static FromAngle(l, i = 1) {
    return new Gi(Math.cos(l) * i, Math.sin(l) * i);
  }
  static ToArray(l) {
    return [l.x, l.y, l.z];
  }
  static ToJson(l) {
    const { x: i, y: d, z: s } = l;
    return { x: i, y: d, z: s };
  }
  static Average(l) {
    const i = l.length, d = new Gi(0, 0);
    for (let s = 0; s < i; s++)
      d.add(l[s]);
    return d.div(i);
  }
  static Clamp(l, i, d) {
    return d === void 0 ? new Gi(Math.min(Math.max(l.x, i)), Math.min(Math.max(l.y, i))) : new Gi(Math.min(Math.max(l.x, i), d), Math.min(Math.max(l.y, i), d));
  }
  /**
   * Get an array of points (with simulated pressure) between two points.
   *
   * @param A - The first point.
   * @param B - The second point.
   * @param steps - The number of points to return.
   */
  static PointsBetween(l, i, d = 6) {
    const s = [];
    for (let X = 0; X < d; X++) {
      const a = ia.easeInQuad(X / (d - 1)), e = Gi.Lrp(l, i, a);
      e.z = Math.min(1, 0.5 + Math.abs(0.5 - la(a)) * 0.65), s.push(e);
    }
    return s;
  }
  static SnapToGrid(l, i = 8) {
    return new Gi(Math.round(l.x / i) * i, Math.round(l.y / i) * i);
  }
}
const la = (m) => m < 0.5 ? 2 * m * m : -1 + (4 - 2 * m) * m;
class ki extends Gi {
  constructor(l = 0, i = 0, d = 0, s = { x: 0, y: 0 }, X = 0, a = 0) {
    super(l, i, d), Object.defineProperty(this, "x", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: l
    }), Object.defineProperty(this, "y", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: i
    }), Object.defineProperty(this, "z", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: d
    }), Object.defineProperty(this, "v", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: s
    }), Object.defineProperty(this, "t", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: X
    }), Object.defineProperty(this, "a", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: a
    });
  }
  get timestamp() {
    return this.t;
  }
  get pressure() {
    return this.z;
  }
  get angleNum() {
    return this.a;
  }
  get XY() {
    return [this.x, this.y];
  }
  setA(l) {
    this.a = l;
  }
  setT(l) {
    this.t = l;
  }
  setv(l) {
    return this.v = { x: l.x, y: l.y }, this;
  }
  set(l = this.x, i = this.y, d = this.z, s = this.v, X = this.t, a = this.a) {
    return this.x = l, this.y = i, this.z = d, this.v = s, this.t = X, this.a = a, this;
  }
  clone() {
    const { x: l, y: i, z: d, v: s, t: X, a } = this, e = { x: s.x, y: s.y };
    return new ki(l, i, d, e, X, a);
  }
  distance(l) {
    return ki.GetDistance(this, l);
  }
  isNear(l, i) {
    return ki.IsNear(this, l, i);
  }
  getAngleByPoints(l, i) {
    return ki.GetAngleByPoints(l, this, i);
  }
  static Sub(l, i) {
    return new ki(l.x - i.x, l.y - i.y);
  }
  static Add(l, i) {
    return new ki(l.x + i.x, l.y + i.y);
  }
  static GetDistance(l, i) {
    return ki.Len(l.clone().sub(i));
  }
  static GetAngleByPoints(l, i, d) {
    const s = i.x - l.x, X = d.x - i.x, a = i.y - l.y, e = d.y - i.y;
    let n = 0;
    const G = Math.sqrt(s * s + a * a), y = Math.sqrt(X * X + e * e);
    if (G && y) {
      const o = s * X + a * e;
      n = Math.acos(o / (G * y)), n = n / Math.PI * 180;
      let h = s * e - a * X;
      h = h > 0 ? 1 : -1, n = 180 + h * n;
    }
    return n;
  }
  static IsNear(l, i, d) {
    return ki.Len(l.clone().sub(i)) < d;
  }
  static RotWith(l, i, d, s = 2) {
    const X = l.x - i.x, a = l.y - i.y, e = Math.sin(d), n = Math.cos(d), G = Math.pow(10, s), y = Math.floor((i.x + (X * n - a * e)) * G) / G, o = Math.floor((i.y + (X * e + a * n)) * G) / G;
    return new ki(y, o);
  }
  /**
   * 根据圆心和半径，获取圆上的等份点
   * @param o 圆心
   * @param radius 半径
   * @param average 均分数
   * @returns
   */
  static GetDotStroke(l, i, d = 16) {
    const s = new Gi(1, 1), X = Math.PI + 1e-3, a = ki.Add(l, ki.Sub(l, s).uni().per().mul(-i)), e = [];
    for (let n = 1 / d, G = n; G <= 1; G += n)
      e.push(ki.RotWith(a, l, X * 2 * G));
    return e;
  }
  /**
   * 根据圆心和园上的起始点，获取半圆上的等份点
   * @param o 圆心
   * @param p 圆弧起始点
   * @param radian 1，逆时针180度 -1，顺时针
   * @param average 均分数
   * @returns
   */
  static GetSemicircleStroke(l, i, d = -1, s = 8) {
    const X = d * (Math.PI + 1e-3), a = [];
    for (let e = 1 / s, n = e; n <= 1; n += e)
      a.push(ki.RotWith(i, l, X * n));
    return a;
  }
}
function Di(m, l) {
  if (m && l) {
    const i = Math.min(m.x, l.x), d = Math.min(m.y, l.y), s = Math.max(m.x + m.w, l.x + l.w), X = Math.max(m.y + m.h, l.y + l.h), a = s - i, e = X - d;
    return { x: i, y: d, w: a, h: e };
  }
  return l || m;
}
function Gt(m, l) {
  if (m && l) {
    const i = Math.min(m.originX, l.originX), d = Math.min(m.originY, l.originY), s = Math.max(m.originX + m.width, l.originX + l.width), X = Math.max(m.originY + m.height, l.originY + l.height), a = s - i, e = X - d;
    return { originX: i, originY: d, width: a, height: e };
  }
  return l || m;
}
function da(m, l = 0) {
  const i = { x: 0, y: 0, w: 0, h: 0 };
  let d = 1 / 0, s = 1 / 0, X = -1 / 0, a = -1 / 0;
  return m.forEach((e) => {
    const [n, G] = e.XY;
    d = Math.min(d, n - l), s = Math.min(s, G - l), X = Math.max(X, n + l), a = Math.max(a, G + l);
  }), i.x = d, i.y = s, i.w = X - d, i.h = a - s, i;
}
function ta(m, l) {
  return !(m.x + m.w < l.x || m.x > l.x + l.w || m.y + m.h < l.y || m.y > l.y + l.h);
}
function sa(m, l) {
  return m.length === l.length && m.sort().toString() === l.sort().toString();
}
function Vt(m, l) {
  let i;
  return l == null || l.getElementsByName(m).forEach((d) => {
    if (d.tagName === "PATH") {
      const s = d == null ? void 0 : d.getBoundingClientRect();
      s && (i = Di(i, {
        x: Math.floor(s.x),
        y: Math.floor(s.y),
        w: Math.round(s.width),
        h: Math.round(s.height)
      }));
    } else if (d.tagName === "GROUP") {
      const s = d.className.split(",");
      if (s.length === 3 && Number(s[2]) === ml.Stroke) {
        const X = d == null ? void 0 : d.getBoundingClientRect();
        X && (i = Di(i, {
          x: Math.floor(X.x),
          y: Math.floor(X.y),
          w: Math.round(X.width),
          h: Math.round(X.height)
        }));
      } else
        d.children.forEach((X) => {
          if (X.tagName === "PATH") {
            const a = X == null ? void 0 : X.getBoundingClientRect();
            a && (i = Di(i, {
              x: Math.floor(a.x),
              y: Math.floor(a.y),
              w: Math.round(a.width),
              h: Math.round(a.height)
            }));
          }
        });
    }
  }), i;
}
const sd = (m, l) => new Promise(function(i) {
  window.requestIdleCallback ? requestIdleCallback(() => {
    i(1);
  }, { timeout: l }) : setTimeout(() => {
    i(2);
  }, l);
}).then(function() {
  m();
}, () => {
  m();
});
function bd(m, l, i) {
  return "#" + ((m << 16) + (l << 8) + i).toString(16).padStart(6, "0");
}
function kl(m, l = 1) {
  return "rgba(" + parseInt("0x" + m.slice(1, 3)) + "," + parseInt("0x" + m.slice(3, 5)) + "," + parseInt("0x" + m.slice(5, 7)) + "," + l + ")";
}
function ba(m) {
  const l = m.split(","), i = parseInt(l[0].split("(")[1]), d = parseInt(l[1]), s = parseInt(l[2]), X = parseInt(l[3].split(")")[0]);
  return [bd(i, d, s), X];
}
var ca = Kl, ma = pl, Za = "[object Number]";
function na(m) {
  return typeof m == "number" || ma(m) && ca(m) == Za;
}
var ea = na;
const bl = /* @__PURE__ */ Dl(ea);
class Li extends $o {
  updataOptService() {
  }
  constructor(l, i, d) {
    super(i, d), Object.defineProperty(this, "tmpPoints", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "toolsType", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ri.Selector
    }), Object.defineProperty(this, "workOptions", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "syncTimestamp", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "curNodeMap", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: /* @__PURE__ */ new Map()
    }), Object.defineProperty(this, "selectIds", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "oldRect", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "nodeColor", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "nodeOpactiy", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "oldSelectRect", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.workOptions = l, this.syncTimestamp = 0;
  }
  computNodeMap(l) {
    this.curNodeMap.clear(), l.forEach((i) => {
      var s;
      const d = this.fullLayer.getElementsByName(i.name)[0] || ((s = this.drawLayer) == null ? void 0 : s.getElementsByName(i.name)[0]);
      if (d) {
        const X = d.worldPosition;
        let a = d.getAttribute("strokeColor");
        const e = d.className.split(",");
        d.tagName === "GROUP" && (Number(e[2]) === ml.Stroke ? a = d.getAttribute("bgcolor") : a = d.children[0].getAttribute("strokeColor")), this.curNodeMap.set(i.name, {
          name: i.name,
          rect: i.rect,
          color: ba(a)[0],
          pos: X,
          rotate: d.getAttribute("rotate") || 0,
          scale: d.getAttribute("scale") || [1, 1],
          opactiy: d.getAttribute("opacity") || 1
        });
      }
    });
  }
  computSelector() {
    let l;
    const i = [], d = /* @__PURE__ */ new Map(), s = /* @__PURE__ */ new Set(), X = /* @__PURE__ */ new Set(), a = /* @__PURE__ */ new Map();
    if (this.tmpPoints.length && this.curNodeMap.size) {
      const e = da(this.tmpPoints);
      this.curNodeMap.forEach((n, G) => {
        const y = {
          x: n.rect.x,
          y: n.rect.y,
          w: n.rect.w,
          h: n.rect.h
        }, o = {
          x: e.x,
          y: e.y,
          w: e.w,
          h: e.h
        };
        ta(o, y) && (i.push(G), l = Di(l, y), d.set(G, y), s.add(n.color), a.set(G, [...n.pos, n.rotate]), X.add(n.opactiy));
      });
    }
    return {
      selectIds: i,
      intersectRect: l,
      subRects: d,
      nodeColors: s,
      subPos: a,
      opactiys: X
    };
  }
  updateTempPoints(l) {
    const i = this.tmpPoints.length, d = l.length;
    if (d > 1) {
      const s = new ki(l[d - 2] * this.fullLayer.worldScaling[0] + this.fullLayer.worldPosition[0], l[d - 1] * this.fullLayer.worldScaling[0] + this.fullLayer.worldPosition[1]);
      i === 2 ? this.tmpPoints.splice(1, 1, s) : this.tmpPoints.push(s);
    }
  }
  draw(l) {
    var X, a, e;
    const { intersectRect: i, subRects: d, subPos: s } = l;
    (e = (a = (X = this.drawLayer) == null ? void 0 : X.parent) == null ? void 0 : a.getElementById(Li.selectorId)) == null || e.remove(), i && this.drawLayer && this.drawSelector({
      drawRect: i,
      subRects: d,
      subPos: s,
      selectorId: Li.selectorId,
      layer: this.drawLayer
    });
  }
  consume(l) {
    const { op: i, workState: d } = l.data;
    if (d === Ii.Start && l.nodeMaps && (this.computNodeMap(l.nodeMaps), this.oldRect = this.backToFullLayer(l.nodeMaps)), !(i != null && i.length) || !this.curNodeMap.size)
      return { type: pi.None };
    this.updateTempPoints(i);
    const s = this.computSelector();
    if (this.selectIds && sa(this.selectIds, s.selectIds))
      return { type: pi.None };
    this.selectIds = s.selectIds;
    const X = this.drawLayer && this.getSelectorRect(this.drawLayer, Li.selectorId, !0), a = s.intersectRect && {
      x: s.intersectRect.x - Li.SelectBorderPadding,
      y: s.intersectRect.y - Li.SelectBorderPadding,
      w: s.intersectRect.w + Li.SelectBorderPadding * 2,
      h: s.intersectRect.h + Li.SelectBorderPadding * 2
    } || void 0;
    return this.oldRect = Di(X, a), this.draw(s), this.nodeColor = s.nodeColors.size === 1 ? s.nodeColors.values().next().value : void 0, this.nodeOpactiy = s.opactiys.size === 1 ? s.opactiys.values().next().value : 1, this.oldSelectRect = a, {
      type: pi.Select,
      dataType: Ti.Local,
      rect: this.oldRect,
      selectIds: s.selectIds,
      opt: this.workOptions,
      padding: Li.SelectBorderPadding,
      selectRect: a,
      nodeColor: this.nodeColor,
      nodeOpactiy: this.nodeOpactiy,
      willSyncService: !0
    };
  }
  consumeAll() {
    var l;
    return (l = this.selectIds) != null && l.length && this.sealToDrawLayer(this.selectIds), this.oldSelectRect ? {
      type: pi.Select,
      dataType: Ti.Local,
      rect: this.oldRect,
      selectIds: this.selectIds,
      opt: this.workOptions,
      padding: Li.SelectBorderPadding,
      selectRect: this.oldSelectRect,
      nodeColor: this.nodeColor,
      nodeOpactiy: this.nodeOpactiy,
      willSyncService: !1
    } : {
      type: pi.None
    };
  }
  consumeService() {
  }
  combineConsume() {
  }
  clearTmpPoints() {
    this.tmpPoints.length = 0;
  }
  clearSelectData() {
    this.selectIds = void 0, this.oldRect = void 0, this.oldSelectRect = void 0;
  }
  backToFullLayer(l = /* @__PURE__ */ new Map(), i) {
    var a, e;
    let d;
    const s = [], X = [];
    for (const n of ((a = this.drawLayer) == null ? void 0 : a.children) || [])
      if (!(i != null && i.length && !i.includes(n.id)) && n.id !== Li.selectorId) {
        const G = n.cloneNode(!0);
        if (G.tagName === "GROUP") {
          const o = n.className.split(",");
          o.length === 3 && Number(o[2]) === ml.Stroke && G.seal();
        }
        this.fullLayer.getElementsByName(n.name).length || s.push(G), X.push(n);
        const y = ((e = l.get(n.name)) == null ? void 0 : e.rect) || Vt(n.name, this.drawLayer);
        y && (d = Di(d, y));
      }
    return X.forEach((n) => n.remove()), s.length && this.fullLayer.append(...s), d && (d.x -= Li.SelectBorderPadding, d.y -= Li.SelectBorderPadding, d.w += Li.SelectBorderPadding * 2, d.h += Li.SelectBorderPadding * 2), d;
  }
  sealToDrawLayer(l) {
    var s;
    const i = [], d = [];
    l.forEach((X) => {
      this.fullLayer.getElementsByName(X.toString()).forEach((a) => {
        var n;
        const e = a.cloneNode(!0);
        if (e.tagName === "GROUP") {
          const G = a.className.split(",");
          G.length === 3 && Number(G[2]) === ml.Stroke && e.seal();
        }
        (n = this.drawLayer) != null && n.getElementsByName(a.name).length || i.push(e), d.push(a);
      });
    }), d.forEach((X) => X.remove()), i && ((s = this.drawLayer) == null || s.append(...i));
  }
  updateSelectorSize(l, i, d) {
    const s = /* @__PURE__ */ new Map(), X = l.getAttribute("pos"), a = l.className.split(","), e = i - Li.SelectBorderPadding * 2, n = d - Li.SelectBorderPadding * 2, G = a.length === 2 && [e / Number(a[0]), n / Number(a[1])] || [1, 1];
    return l.setAttribute("size", [e, n]), l.children.forEach((y) => {
      if (y.id === Li.selectorBorderId)
        y.setAttribute("pos", [e / 2, n / 2]), y.setAttribute("width", e), y.setAttribute("height", n);
      else if (G) {
        const o = y.className.split(","), h = [Number(o[0]) * G[0], Number(o[1]) * G[1]], I = y.getAttribute("width"), x = y.getAttribute("height"), p = Number(o[2]) * G[0], W = Number(o[3]) * G[1];
        y.setAttribute("pos", h), y.setAttribute("width", p), y.setAttribute("height", W);
        const V = y.id.split("selector-")[1];
        if (V) {
          const t = [h[0] + X[0], h[1] + X[1]], c = [
            p / I,
            W / x
          ];
          s.set(V, [
            t[0],
            t[1],
            c[0],
            c[1]
          ]);
        }
      }
    }), s;
  }
  updateSelectorRect(l, i) {
    const { w: d, h: s, x: X, y: a } = i, e = d - Li.SelectBorderPadding * 2, n = s - Li.SelectBorderPadding * 2, G = X + Li.SelectBorderPadding, y = a + Li.SelectBorderPadding;
    l.setAttribute("size", [d, s]), l.setAttribute("pos", [G, y]), l.setAttribute("className", `${i.w},${i.h}`), l.children.forEach((o) => {
      if (o.setAttribute("pos", [e / 2, n / 2]), o.setAttribute("width", e), o.setAttribute("height", n), o.id === Li.selectorBorderId)
        o.setAttribute("className", `${i.w / 2},${i.h / 2},${i.w},${i.h}`);
      else {
        const h = o.className.split(","), I = h && Number(h[4]) || 0;
        o.setAttribute("className", `${e / 2},${n / 2},${i.w},${i.h},${I}`);
      }
    });
  }
  getSelectorRect(l, i, d) {
    var n;
    let s;
    const X = (n = l.parent) == null ? void 0 : n.getElementById(i), a = X == null ? void 0 : X.getElementById(Li.selectorBorderId), e = a == null ? void 0 : a.getBoundingClientRect();
    return e && (s = Di(s, {
      x: Math.floor(e.x),
      y: Math.floor(e.y),
      w: Math.round(e.width),
      h: Math.round(e.height)
    })), s && d ? {
      x: s.x - Li.SelectBorderPadding,
      y: s.y - Li.SelectBorderPadding,
      w: s.w + Li.SelectBorderPadding * 2,
      h: s.h + Li.SelectBorderPadding * 2
    } : s;
  }
  updateSelector(l) {
    var G, y, o;
    const { updateSelectorOpt: i, selectIds: d, selectStore: s } = l;
    let X;
    const a = /* @__PURE__ */ new Map();
    let e;
    const n = (y = (G = this.drawLayer) == null ? void 0 : G.parent) == null ? void 0 : y.getElementById(Li.selectorId);
    if (n) {
      let h;
      if (i.pos) {
        const I = [
          i.pos[0] * this.fullLayer.worldScaling[0] + this.fullLayer.worldPosition[0],
          i.pos[1] * this.fullLayer.worldScaling[1] + this.fullLayer.worldPosition[1]
        ], x = n.getAttribute("pos");
        h = [I[0] - x[0], I[1] - x[1]], n.setAttribute("pos", I);
      }
      if (i.selectorColor && ((o = n.getElementById(Li.selectorBorderId)) == null || o.setAttribute("strokeColor", i.selectorColor)), i.size && (e = this.updateSelectorSize(n, i.size.width, i.size.height)), i.angle)
        d == null || d.forEach((I) => {
          var x;
          (x = this.drawLayer) == null || x.getElementsByName(I).forEach((p) => {
            if (p) {
              const W = {
                useAnimation: !1
              };
              i.angle && (W.angle = i.angle, W.originPos = p.className.split(",").map((t) => Number(t)), p.setAttribute("rotate", W.angle)), a.set(p.name, W);
              const V = Vt(p.name, this.drawLayer);
              X = Di(X, V);
            }
          });
        }, this);
      else {
        d == null || d.forEach((p) => {
          var W;
          (W = this.drawLayer) == null || W.getElementsByName(p).forEach((V) => {
            var t, c;
            if (V) {
              const b = {
                useAnimation: !1
              };
              if (i.pos && h) {
                const r = V.getAttribute("pos");
                b.pos = [h[0] / this.fullLayer.worldScaling[0] + r[0], h[1] / this.fullLayer.worldScaling[0] + r[1]], b.originPos = V.className.split(",").map((S) => Number(S)), V.setAttribute("pos", b.pos);
              }
              if (i.zIndexLayer && (s != null && s.has(p))) {
                const r = (c = (t = s.get(p)) == null ? void 0 : t.updateNodeOpt) == null ? void 0 : c.zIndex;
                bl(r) && (b.zIndex = r, V.setAttribute("zIndex", b.zIndex));
              }
              if (i.zIndex && (b.zIndex = i.zIndex, V.setAttribute("zIndex", b.zIndex)), i.color) {
                b.color = i.color;
                const r = V.className.split(",");
                V.tagName === "GROUP" ? Number(r[2]) === ml.Stroke ? V.setAttribute("bgcolor", b.color) : V.children.forEach((S) => {
                  S.setAttribute("strokeColor", b.color);
                }) : V.tagName === "PATH" && (V.setAttribute("strokeColor", b.color), V.getAttribute("fillColor") && V.setAttribute("fillColor", b.color));
              }
              i.opacity && (b.opacity = i.opacity, V.setAttribute("opacity", b.opacity));
              const Z = e == null ? void 0 : e.get(V.name);
              if (Z) {
                const r = V.getAttribute("scale"), S = [
                  Z[2] * r[0],
                  Z[3] * r[1]
                ];
                b.originPos = V.className.split(",").map((C) => Number(C)), b.pos = [(Z[0] - this.fullLayer.worldPosition[0]) / this.fullLayer.worldScaling[0], (Z[1] - this.fullLayer.worldPosition[1]) / this.fullLayer.worldScaling[1]], b.scale = S, V.setAttribute("pos", b.pos), V.setAttribute("scale", b.scale);
              }
              a.set(V.name, b);
            }
          });
        }, this);
        const I = n.getElementById(Li.selectorBorderId), x = I == null ? void 0 : I.getBoundingClientRect();
        x && (X = Di(X, {
          x: Math.floor(x.x),
          y: Math.floor(x.y),
          w: Math.round(x.width),
          h: Math.round(x.height)
        }));
      }
    }
    if (X)
      return X.x -= Li.SelectBorderPadding, X.y -= Li.SelectBorderPadding, X.w += Li.SelectBorderPadding * 2, X.h += Li.SelectBorderPadding * 2, i.angle && this.updateSelectorRect(n, X), this.oldRect = Di(this.oldRect, X), this.oldSelectRect = X, {
        type: pi.UpdateNode,
        dataType: Ti.Local,
        rect: X,
        updateNodeOpts: a
      };
  }
  blurSelector(l) {
    const i = this.backToFullLayer(l);
    return {
      type: pi.Select,
      dataType: Ti.Local,
      rect: i,
      selectIds: [],
      willSyncService: !0
    };
  }
  getRightServiceId(l) {
    return l.replace("++", "-");
  }
  drawSelector(l) {
    const { drawRect: i, subRects: d, subPos: s, selectorId: X, layer: a } = l, e = new _o({
      pos: [i.x, i.y],
      anchor: [0, 0],
      size: [i.w, i.h],
      className: `${i.w},${i.h}`,
      id: X,
      name: Li.selectorId,
      zIndex: 1e3
    }), n = [], G = new ut({
      normalize: !0,
      pos: [i.w / 2, i.h / 2],
      lineWidth: 1,
      strokeColor: this.workOptions.color,
      width: i.w,
      height: i.h,
      className: `${i.w / 2},${i.h / 2},${i.w},${i.h}`,
      id: Li.selectorBorderId
    });
    n.push(G), d.forEach((y, o) => {
      const h = s == null ? void 0 : s.get(o);
      if (h) {
        const I = [h[0] - i.x, h[1] - i.y], x = `${I[0]},${I[1]},${y.w},${y.h},${h[2]}`, p = new ut({
          normalize: !0,
          pos: I,
          lineWidth: 1,
          strokeColor: d.size > 1 ? this.workOptions.color : void 0,
          width: y.w,
          height: y.h,
          className: x,
          id: `selector-${o}`,
          name: `selector-${o}`
        });
        n.push(p);
      }
    }), n && e.append(...n), (a == null ? void 0 : a.parent).appendChild(e);
  }
  selectServiceNode(l, i, d) {
    var y;
    const { selectIds: s } = i, X = this.getRightServiceId(l), a = this.getSelectorRect(this.fullLayer, X, !0);
    (y = this.fullLayer.parent.getElementById(X)) == null || y.remove();
    let e;
    const n = /* @__PURE__ */ new Map(), G = /* @__PURE__ */ new Map();
    return s == null || s.forEach((o) => {
      var x;
      const h = d.get(o), I = this.fullLayer.getElementsByName(o)[0];
      if (h && I) {
        e = Di(e, h.rect), n.set(o, h.rect);
        const p = I.worldPosition, W = ((x = h.opt) == null ? void 0 : x.rotate) || I.getAttribute("rotate") || 0;
        G.set(o, [...p, W]);
      }
    }), e && this.fullLayer && this.drawSelector({
      drawRect: e,
      subRects: n,
      subPos: G,
      selectorId: X,
      layer: this.fullLayer
    }), e = Di(e, a), e && (e.x -= Li.SelectBorderPadding, e.y -= Li.SelectBorderPadding, e.w += Li.SelectBorderPadding * 2, e.h += Li.SelectBorderPadding * 2), e;
  }
  removeService() {
    throw new Error("Method not implemented.");
  }
  getSelector(l) {
    var X;
    let i;
    const d = /* @__PURE__ */ new Map(), s = /* @__PURE__ */ new Map();
    return (X = this.selectIds) == null || X.forEach((a) => {
      var G;
      const e = l.get(a), n = (G = this.drawLayer) == null ? void 0 : G.getElementsByName(a)[0];
      if (e && n) {
        const y = n.worldPosition, o = n.getAttribute("rotate") || 0;
        i = Di(i, e.rect), d.set(a, e.rect), s.set(a, [...y, o]);
      }
    }, this), this.oldRect = Di(i, this.oldRect), this.draw({
      intersectRect: i,
      subRects: d,
      subPos: s
    }), i && (i.x -= Li.SelectBorderPadding, i.y -= Li.SelectBorderPadding, i.w += Li.SelectBorderPadding * 2, i.h += Li.SelectBorderPadding * 2), this.oldSelectRect = i, i;
  }
  updateSelectIds(l, i) {
    var e, n;
    let d;
    const s = (e = this.selectIds) == null ? void 0 : e.filter((G) => !l.includes(G)), X = l.filter((G) => {
      var y;
      return !((y = this.selectIds) != null && y.includes(G));
    });
    if (s != null && s.length && (d = this.backToFullLayer(i, s)), X.length) {
      this.sealToDrawLayer(X);
      for (const G of X) {
        const y = (n = i.get(G)) == null ? void 0 : n.rect;
        y && (d = Di(d, y));
      }
      d && (d.x -= Li.SelectBorderPadding, d.y -= Li.SelectBorderPadding, d.w += Li.SelectBorderPadding * 2, d.h += Li.SelectBorderPadding * 2);
    }
    this.selectIds = l;
    const a = this.getSelector(i);
    return {
      bgRect: d,
      selectRect: a
    };
  }
}
Object.defineProperty(Li, "selectorId", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: Ci
});
Object.defineProperty(Li, "selectorBorderId", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "selector-border"
});
Object.defineProperty(Li, "SelectBorderPadding", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 2
});
class Vl extends qt {
  constructor(l, i) {
    super(), Object.defineProperty(this, "serviceStorage", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "storage", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "uid", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "plugin", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "namespace", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ""
    }), Object.defineProperty(this, "stateDisposer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "asyncClockState", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Vl.syncInterval = (i || Vl.syncInterval) * 0.5, this.plugin = l, this.uid = l.displayer.uid;
    const d = l.displayer.state.sceneState.scenePath;
    this.setNamespace(d);
  }
  addStorageStateListener(l) {
    this.stateDisposer = xt(async () => {
      const i = this.getNamespaceData(this.namespace), d = this.diffFun(this.serviceStorage, i);
      this.serviceStorage = i;
      for (const [s, X] of Object.entries(d))
        (X == null ? void 0 : X.newValue) === void 0 ? delete this.storage[s] : this.storage[s] = tl(X == null ? void 0 : X.newValue);
      Object.keys(d).length > 0 && l(d);
    });
  }
  removeStorageStateListener() {
    this.stateDisposer && this.stateDisposer();
  }
  diffFun(l, i) {
    const d = Ml(l), s = Ml(i), X = {};
    for (const a of d) {
      if (s.includes(a)) {
        if (fl(l[a], i[a]))
          continue;
        X[a] = {
          oldValue: l[a],
          newValue: i[a]
        };
        continue;
      }
      X[a] = {
        oldValue: l[a],
        newValue: void 0
      };
    }
    for (const a of s)
      d.includes(a) || (X[a] = {
        oldValue: void 0,
        newValue: i[a]
      });
    return X;
  }
  transformKey(l) {
    return this.uid + Gl + l;
  }
  isOwn(l) {
    return l.split(Gl)[0] === this.uid;
  }
  dispatch(l) {
    const { type: i, workId: d, ops: s, index: X, opt: a, toolsType: e, removeIds: n, updateNodeOpt: G, op: y, selectIds: o, isSync: h } = l;
    switch (i) {
      case pi.Clear:
        const I = {};
        Object.keys(this.storage).map((t) => {
          I[t] = void 0;
        }), this.setState(I, { isSync: h });
        break;
      case pi.CreateWork:
        if (d && e && a) {
          const t = this.isLocalId(d.toString()) ? this.transformKey(d) : d;
          this.updateValue(t.toString(), {
            type: pi.CreateWork,
            workId: d,
            toolsType: e,
            opt: a
          }, { isSync: h });
        }
        break;
      case pi.DrawWork:
        if (d && typeof X == "number" && (y != null && y.length)) {
          const t = this.isLocalId(d.toString()) ? this.transformKey(d) : d, c = this.storage[t], b = ((c == null ? void 0 : c.op) || []).slice(0, X).concat(y);
          c && b && this.updateValue(t.toString(), {
            ...c,
            type: pi.DrawWork,
            op: b,
            index: X
          }, { isSync: h });
        }
        break;
      case pi.FullWork:
        if (d) {
          const t = this.isLocalId(d.toString()) ? this.transformKey(d) : d, c = this.storage[t], b = G || (c == null ? void 0 : c.updateNodeOpt), Z = e || (c == null ? void 0 : c.toolsType), r = a || (c == null ? void 0 : c.opt), S = s || (c == null ? void 0 : c.ops);
          Z && r && S && this.updateValue(t.toString(), {
            type: pi.FullWork,
            updateNodeOpt: b,
            workId: t,
            toolsType: Z,
            opt: r,
            ops: S
          }, { isSync: h });
        }
        break;
      case pi.RemoveNode:
        if (n != null && n.length) {
          const t = n.map((c) => this.isLocalId(c + "") ? this.transformKey(c) : c);
          Object.keys(this.storage).map((c) => {
            t != null && t.includes(c) && this.updateValue(c, void 0, { isSync: h });
          });
        }
        break;
      case pi.UpdateNode:
        if (d && (G || s || a)) {
          const t = this.isLocalId(d.toString()) ? this.transformKey(d) : d, c = this.storage[t];
          c && (c.updateNodeOpt = G, s && (c.ops = s), G && (c.updateNodeOpt = G), a && (c.opt = a), this.updateValue(t.toString(), c, { isSync: h }));
        }
        break;
      case pi.Select:
        let x;
        o != null && o.length && (x = o.map((t) => this.isLocalId(t + "") ? this.transformKey(t) : t));
        const p = this.transformKey(Li.selectorId), W = this.storage[p], V = a || (W == null ? void 0 : W.opt);
        x && this.checkOtherSelector(p, x, { isSync: h }), this.updateValue(p, x && {
          type: pi.Select,
          toolsType: ri.Selector,
          opt: V,
          selectIds: x
        }, { isSync: h });
        break;
    }
  }
  checkOtherSelector(l, i, d) {
    for (const s of Object.keys(this.storage))
      if (s !== l && this.getLocalId(s) === Ci) {
        const X = this.storage[s];
        if (X && X.selectIds) {
          const a = X.selectIds.filter((e) => !i.includes(e));
          a.length > 0 && (X.selectIds = a), this.updateValue(s, a.length && X || void 0, d);
        }
      }
  }
  setState(l, i) {
    const d = Ml(l);
    for (let s = 0; s < d.length; s++) {
      const X = d[s], a = l[X];
      typeof a < "u" ? this.storage[X] = a : delete this.storage[X];
    }
    this.runSyncService(i);
  }
  updateValue(l, i, d) {
    i === void 0 ? delete this.storage[l] : this.storage[l] = i, this.runSyncService(d);
  }
  runSyncService(l) {
    this.asyncClockState || (this.asyncClockState = !0, setTimeout(() => {
      l != null && l.isSync ? (this.asyncClockState = !1, this.syncSerivice(l == null ? void 0 : l.isAfterUpdate)) : sd(() => {
        this.asyncClockState = !1, this.syncSerivice(l == null ? void 0 : l.isAfterUpdate);
      }, Vl.syncInterval);
    }, l != null && l.isSync ? 0 : Vl.syncInterval));
  }
  syncSerivice(l = !1) {
    const i = Ml(this.serviceStorage), d = Ml(this.storage), s = /* @__PURE__ */ new Map();
    let X = 0;
    for (const a of i) {
      const e = this.serviceStorage[a], n = this.storage[a];
      if (d.includes(a)) {
        if (fl(e, n))
          continue;
        s.set(a, n), X++;
        continue;
      }
      s.set(a, void 0);
    }
    for (const a of d) {
      const e = this.storage[a];
      i.includes(a) || (s.set(a, e), X++);
    }
    if (X > 5)
      this.syncStorage(this.storage, l);
    else if (s.size > 0)
      for (const [a, e] of s.entries())
        this.syncUpdata(a, e, l);
  }
  syncUpdata(l, i, d = !1) {
    var X;
    Object.keys(this.serviceStorage).length ? (d || (i === void 0 ? delete this.serviceStorage[l] : this.serviceStorage[l] = i), (X = this.plugin) == null || X.updateAttributes([this.namespace, l], i)) : this.syncStorage(this.storage, d);
  }
  syncStorage(l, i = !1) {
    var d;
    i || (this.serviceStorage = tl(l)), (d = this.plugin) == null || d.updateAttributes(this.namespace, l);
  }
  transformToSerializableData(l) {
    return _t(l);
  }
  transformToNormalData(l) {
    return $t(l);
  }
  keyTransformWorkId(l) {
    const i = l.split(Gl);
    return i.length === 2 ? i[1] : l;
  }
  destroy() {
    this.removeStorageStateListener(), this.plugin = void 0, this.serviceStorage = {}, this.storage = {}, this.namespace = "";
  }
}
Object.defineProperty(Vl, "syncInterval", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 500
});
class Xa {
  constructor(l, i) {
    Object.defineProperty(this, "collector", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "displayer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "dustbin", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: /* @__PURE__ */ new Set()
    }), this.displayer = l, this.collector = i;
  }
  /** 设置当前选中的工具配置数据 */
  setCurrentToolsData(l) {
    this.currentToolsData = l;
  }
  /** 设置当前绘制任务数据 */
  setCurrentLocalWorkData(l) {
    this.currentLocalWorkData = l;
  }
  /** 设置相机参数 */
  setCameraOpt(l) {
    this.cameraOpt = l;
  }
  /** 获取当前绘制任务id */
  getWorkId() {
    return this.currentLocalWorkData.workId;
  }
}
const ds = "dmFyIEVoPU9iamVjdC5kZWZpbmVQcm9wZXJ0eTt2YXIgT2g9KEF0LFl0LFN0KT0+WXQgaW4gQXQ/RWgoQXQsWXQse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOlN0fSk6QXRbWXRdPVN0O3ZhciBWdD0oQXQsWXQsU3QpPT4oT2goQXQsdHlwZW9mIFl0IT0ic3ltYm9sIj9ZdCsiIjpZdCxTdCksU3QpOyhmdW5jdGlvbigpeyJ1c2Ugc3RyaWN0Ijt2YXIgQXQ7KGZ1bmN0aW9uKGgpe2hbaC5QZW5jaWw9MV09IlBlbmNpbCIsaFtoLkVyYXNlcj0yXT0iRXJhc2VyIixoW2guU2VsZWN0b3I9M109IlNlbGVjdG9yIixoW2guQ2xpY2tlcj00XT0iQ2xpY2tlciIsaFtoLkFycm93PTVdPSJBcnJvdyIsaFtoLkhhbmQ9Nl09IkhhbmQiLGhbaC5MYXNlclBlbj03XT0iTGFzZXJQZW4ifSkoQXR8fChBdD17fSkpO3ZhciBZdDsoZnVuY3Rpb24oaCl7aFtoLlBhdGg9MF09IlBhdGgiLGhbaC5SZWN0PTFdPSJSZWN0In0pKFl0fHwoWXQ9e30pKTt2YXIgU3Q7KGZ1bmN0aW9uKGgpe2hbaC5Mb2NhbD0xXT0iTG9jYWwiLGhbaC5TZXJ2aWNlPTJdPSJTZXJ2aWNlIn0pKFN0fHwoU3Q9e30pKTt2YXIgR3Q7KGZ1bmN0aW9uKGgpe2hbaC5QZW5kaW5nPTBdPSJQZW5kaW5nIixoW2guU3RhcnQ9MV09IlN0YXJ0IixoW2guRG9pbmc9Ml09IkRvaW5nIixoW2guRG9uZT0zXT0iRG9uZSIsaFtoLkZyZWV6ZT00XT0iRnJlZXplIixoW2guVW53cml0YWJsZT01XT0iVW53cml0YWJsZSJ9KShHdHx8KEd0PXt9KSk7dmFyIHB0OyhmdW5jdGlvbihoKXtoW2guSW5pdD0wXT0iSW5pdCIsaFtoLlVwZGF0ZUNhbWVyYT0xXT0iVXBkYXRlQ2FtZXJhIixoW2guVXBkYXRlVG9vbHM9Ml09IlVwZGF0ZVRvb2xzIixoW2guQ3JlYXRlV29yaz0zXT0iQ3JlYXRlV29yayIsaFtoLkRyYXdXb3JrPTRdPSJEcmF3V29yayIsaFtoLkZ1bGxXb3JrPTVdPSJGdWxsV29yayIsaFtoLlVwZGF0ZU5vZGU9Nl09IlVwZGF0ZU5vZGUiLGhbaC5SZW1vdmVOb2RlPTddPSJSZW1vdmVOb2RlIixoW2guQ2xlYXI9OF09IkNsZWFyIixoW2guU2VsZWN0PTldPSJTZWxlY3QiLGhbaC5EZXN0cm95PTEwXT0iRGVzdHJveSIsaFtoLk5vbmU9MTFdPSJOb25lIixoW2guU25hcHNob3Q9MTJdPSJTbmFwc2hvdCIsaFtoLkJvdW5kaW5nQm94PTEzXT0iQm91bmRpbmdCb3giLGhbaC5DdXJzb3I9MTRdPSJDdXJzb3IifSkocHR8fChwdD17fSkpO3ZhciB0cjsoZnVuY3Rpb24oaCl7aFtoLlBhdGg9MF09IlBhdGgiLGhbaC5SZWN0PTFdPSJSZWN0IixoW2guVGV4dHVyZT0yXT0iVGV4dHVyZSJ9KSh0cnx8KHRyPXt9KSk7dmFyIGVyOyhmdW5jdGlvbihoKXtoLldlYmdsMj0id2ViZ2wyIixoLldlYmdsPSJ3ZWJnbCIsaC5DYW52YXMyZD0iMmQifSkoZXJ8fChlcj17fSkpO3ZhciB5dDsoZnVuY3Rpb24oaCl7aFtoLkZsb2F0PTFdPSJGbG9hdCIsaFtoLkJnPTJdPSJCZyIsaFtoLlNlbGVjdG9yPTNdPSJTZWxlY3RvciIsaFtoLk5vbmU9NF09Ik5vbmUifSkoeXR8fCh5dD17fSkpO3ZhciBycjsoZnVuY3Rpb24oaCl7aC5MVD0idG9wTGVmdCIsaC5MQz0ibGVmdCIsaC5MQj0iYm90dG9tTGVmdCIsaC5UQz0idG9wIixoLlJUPSJ0b3BSaWdodCIsaC5SQz0icmlnaHQiLGguUkI9ImJvdHRvbVJpZ2h0IixoLkJDPSJib3R0b20ifSkocnJ8fChycj17fSkpO3ZhciBucjsoZnVuY3Rpb24oaCl7aFtoLkN1cnNvcj0xXT0iQ3Vyc29yIn0pKG5yfHwobnI9e30pKTt2YXIgaXI7KGZ1bmN0aW9uKGgpe2hbaC5Ub3A9MV09IlRvcCIsaFtoLkJvdHRvbT0yXT0iQm90dG9tIn0pKGlyfHwoaXI9e30pKTtjbGFzcyBnZXtjb25zdHJ1Y3RvcihlLHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzeW5jVW5pdFRpbWUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZToxZTN9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiZHJhd0xheWVyIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImZ1bGxMYXllciIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ3b3JrSWQiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSx0aGlzLmZ1bGxMYXllcj1lLHRoaXMuZHJhd0xheWVyPXR9c2V0V29ya0lkKGUpe3RoaXMud29ya0lkPWV9Z2V0V29ya0lkKCl7cmV0dXJuIHRoaXMud29ya0lkfWdldFdvcmtPcHRpb25zKCl7cmV0dXJuIHRoaXMud29ya09wdGlvbnN9c2V0V29ya09wdGlvbnMoZSl7dGhpcy53b3JrT3B0aW9ucz1lLHRoaXMuc3luY1VuaXRUaW1lPWUuc3luY1VuaXRUaW1lfHx0aGlzLnN5bmNVbml0VGltZX19dmFyIFJ0PWZ1bmN0aW9uKGgpe3ZhciBlPXt9O2Z1bmN0aW9uIHQocil7aWYoZVtyXSlyZXR1cm4gZVtyXS5leHBvcnRzO3ZhciBuPWVbcl09e2k6cixsOiExLGV4cG9ydHM6e319O3JldHVybiBoW3JdLmNhbGwobi5leHBvcnRzLG4sbi5leHBvcnRzLHQpLG4ubD0hMCxuLmV4cG9ydHN9cmV0dXJuIHQubT1oLHQuYz1lLHQuZD1mdW5jdGlvbihyLG4sZCl7dC5vKHIsbil8fE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyLG4se2VudW1lcmFibGU6ITAsZ2V0OmR9KX0sdC5yPWZ1bmN0aW9uKHIpe3R5cGVvZiBTeW1ib2w8InUiJiZTeW1ib2wudG9TdHJpbmdUYWcmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eShyLFN5bWJvbC50b1N0cmluZ1RhZyx7dmFsdWU6Ik1vZHVsZSJ9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkociwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSl9LHQudD1mdW5jdGlvbihyLG4pe2lmKG4mMSYmKHI9dChyKSksbiY4fHxuJjQmJnR5cGVvZiByPT0ib2JqZWN0IiYmciYmci5fX2VzTW9kdWxlKXJldHVybiByO3ZhciBkPU9iamVjdC5jcmVhdGUobnVsbCk7aWYodC5yKGQpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkLCJkZWZhdWx0Iix7ZW51bWVyYWJsZTohMCx2YWx1ZTpyfSksbiYyJiZ0eXBlb2YgciE9InN0cmluZyIpZm9yKHZhciBnIGluIHIpdC5kKGQsZywoZnVuY3Rpb24odSl7cmV0dXJuIHJbdV19KS5iaW5kKG51bGwsZykpO3JldHVybiBkfSx0Lm49ZnVuY3Rpb24ocil7dmFyIG49ciYmci5fX2VzTW9kdWxlP2Z1bmN0aW9uKCl7cmV0dXJuIHIuZGVmYXVsdH06ZnVuY3Rpb24oKXtyZXR1cm4gcn07cmV0dXJuIHQuZChuLCJhIixuKSxufSx0Lm89ZnVuY3Rpb24ocixuKXtyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHIsbil9LHQucD0iL2pzLyIsdCh0LnM9MCl9KFtmdW5jdGlvbihoLGUsdCl7dC5yKGUpLHQuZChlLCJ2ZXJzaW9uIixmdW5jdGlvbigpe3JldHVybiBIfSksdC5kKGUsImhlbHBlcnMiLGZ1bmN0aW9uKCl7cmV0dXJuIEJ9KSx0LmQoZSwiY3JlYXRlRWxlbWVudCIsZnVuY3Rpb24oKXtyZXR1cm4gRH0pLHQuZChlLCJpc1Nwcml0ZU5vZGUiLGZ1bmN0aW9uKCl7cmV0dXJuIEN9KSx0LmQoZSwicmVnaXN0ZXJOb2RlIixmdW5jdGlvbigpe3JldHVybiBTfSk7dmFyIHI9dCgxMik7dC5kKGUsIkVOViIsZnVuY3Rpb24oKXtyZXR1cm4gci5FTlZ9KTt2YXIgbj10KDY4KTt0LmQoZSwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIixmdW5jdGlvbigpe3JldHVybiBuLnJlcXVlc3RBbmltYXRpb25GcmFtZX0pLHQuZChlLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsZnVuY3Rpb24oKXtyZXR1cm4gbi5jYW5jZWxBbmltYXRpb25GcmFtZX0pO3ZhciBkPXQoNzApO3QuZChlLCJOb2RlIixmdW5jdGlvbigpe3JldHVybiBkLmRlZmF1bHR9KTt2YXIgZz10KDIxNyk7dC5kKGUsIkNsb3VkIixmdW5jdGlvbigpe3JldHVybiBnLmRlZmF1bHR9KTt2YXIgdT10KDIxOSk7dC5kKGUsIkJsb2NrIixmdW5jdGlvbigpe3JldHVybiB1LmRlZmF1bHR9KTt2YXIgbz10KDIyNCk7dC5kKGUsIlNwcml0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gby5kZWZhdWx0fSk7dmFyIGY9dCgyMjYpO3QuZChlLCJQYXRoIixmdW5jdGlvbigpe3JldHVybiBmLmRlZmF1bHR9KTt2YXIgeD10KDIyOSk7dC5kKGUsIlJlY3QiLGZ1bmN0aW9uKCl7cmV0dXJuIHguZGVmYXVsdH0pO3ZhciBjPXQoMjMxKTt0LmQoZSwiVHJpYW5nbGUiLGZ1bmN0aW9uKCl7cmV0dXJuIGMuZGVmYXVsdH0pO3ZhciB2PXQoMjM2KTt0LmQoZSwiUGFyYWxsZWwiLGZ1bmN0aW9uKCl7cmV0dXJuIHYuZGVmYXVsdH0pO3ZhciBwPXQoMjM4KTt0LmQoZSwiUmVndWxhciIsZnVuY3Rpb24oKXtyZXR1cm4gcC5kZWZhdWx0fSk7dmFyIGI9dCgyNDApO3QuZChlLCJTdGFyIixmdW5jdGlvbigpe3JldHVybiBiLmRlZmF1bHR9KTt2YXIgRT10KDI0Mik7dC5kKGUsIkVsbGlwc2UiLGZ1bmN0aW9uKCl7cmV0dXJuIEUuZGVmYXVsdH0pO3ZhciB5PXQoMjQ0KTt0LmQoZSwiQXJjIixmdW5jdGlvbigpe3JldHVybiB5LmRlZmF1bHR9KTt2YXIgTT10KDI0Nik7dC5kKGUsIlJpbmciLGZ1bmN0aW9uKCl7cmV0dXJuIE0uZGVmYXVsdH0pO3ZhciBpPXQoMjMyKTt0LmQoZSwiUG9seWxpbmUiLGZ1bmN0aW9uKCl7cmV0dXJuIGkuZGVmYXVsdH0pO3ZhciBhPXQoMjQ4KTt0LmQoZSwiTGFiZWwiLGZ1bmN0aW9uKCl7cmV0dXJuIGEuZGVmYXVsdH0pO3ZhciBzPXQoMjUwKTt0LmQoZSwiR3JvdXAiLGZ1bmN0aW9uKCl7cmV0dXJuIHMuZGVmYXVsdH0pO3ZhciBsPXQoMjg2KTt0LmQoZSwiTGF5ZXIiLGZ1bmN0aW9uKCl7cmV0dXJuIGwuZGVmYXVsdH0pO3ZhciBPPXQoMjg3KTt0LmQoZSwiU3ByaXRlU3ZnIixmdW5jdGlvbigpe3JldHVybiBPLmRlZmF1bHR9KTt2YXIgQT10KDI4OSk7dC5kKGUsIkxheWVyV29ya2VyIixmdW5jdGlvbigpe3JldHVybiBBLmRlZmF1bHR9KTt2YXIgUj10KDI5MCk7dC5kKGUsIlNjZW5lIixmdW5jdGlvbigpe3JldHVybiBSLmRlZmF1bHR9KTt2YXIgST10KDIxMyksUD10KDIyMSk7dC5kKGUsIkNvbG9yIixmdW5jdGlvbigpe3JldHVybiBQLkNvbG9yfSksdC5kKGUsIkdyYWRpZW50IixmdW5jdGlvbigpe3JldHVybiBQLkdyYWRpZW50fSk7dmFyIEw9dCg3Mik7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IEQ9SS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQsQz1JLmRlZmF1bHQuaXNTcHJpdGVOb2RlLFM9SS5kZWZhdWx0LnJlZ2lzdGVyTm9kZSxCPXtwYXJzZUNvbG9yOlAucGFyc2VDb2xvcixzaXplVG9QaXhlbDpMLnNpemVUb1BpeGVsLHRvQXJyYXk6TC50b0FycmF5LHRvU3RyaW5nOkwudG9TdHJpbmcsdG9OdW1iZXI6TC50b051bWJlcn07bGV0IHc7dz0iMy44LjMiO2NvbnN0IEg9d30sZnVuY3Rpb24oaCxlLHQpe3QucihlKTt2YXIgcj10KDIpO3QuZChlLCJnbE1hdHJpeCIsZnVuY3Rpb24oKXtyZXR1cm4gcn0pO3ZhciBuPXQoMyk7dC5kKGUsIm1hdDIiLGZ1bmN0aW9uKCl7cmV0dXJuIG59KTt2YXIgZD10KDQpO3QuZChlLCJtYXQyZCIsZnVuY3Rpb24oKXtyZXR1cm4gZH0pO3ZhciBnPXQoNSk7dC5kKGUsIm1hdDMiLGZ1bmN0aW9uKCl7cmV0dXJuIGd9KTt2YXIgdT10KDYpO3QuZChlLCJtYXQ0IixmdW5jdGlvbigpe3JldHVybiB1fSk7dmFyIG89dCg3KTt0LmQoZSwicXVhdCIsZnVuY3Rpb24oKXtyZXR1cm4gb30pO3ZhciBmPXQoMTApO3QuZChlLCJxdWF0MiIsZnVuY3Rpb24oKXtyZXR1cm4gZn0pO3ZhciB4PXQoMTEpO3QuZChlLCJ2ZWMyIixmdW5jdGlvbigpe3JldHVybiB4fSk7dmFyIGM9dCg4KTt0LmQoZSwidmVjMyIsZnVuY3Rpb24oKXtyZXR1cm4gY30pO3ZhciB2PXQoOSk7dC5kKGUsInZlYzQiLGZ1bmN0aW9uKCl7cmV0dXJuIHZ9KX0sZnVuY3Rpb24oaCxlLHQpe3QucihlKSx0LmQoZSwiRVBTSUxPTiIsZnVuY3Rpb24oKXtyZXR1cm4gcn0pLHQuZChlLCJBUlJBWV9UWVBFIixmdW5jdGlvbigpe3JldHVybiBufSksdC5kKGUsIlJBTkRPTSIsZnVuY3Rpb24oKXtyZXR1cm4gZH0pLHQuZChlLCJzZXRNYXRyaXhBcnJheVR5cGUiLGZ1bmN0aW9uKCl7cmV0dXJuIGd9KSx0LmQoZSwidG9SYWRpYW4iLGZ1bmN0aW9uKCl7cmV0dXJuIG99KSx0LmQoZSwiZXF1YWxzIixmdW5jdGlvbigpe3JldHVybiBmfSk7dmFyIHI9MWUtNixuPXR5cGVvZiBGbG9hdDMyQXJyYXk8InUiP0Zsb2F0MzJBcnJheTpBcnJheSxkPU1hdGgucmFuZG9tO2Z1bmN0aW9uIGcoeCl7bj14fXZhciB1PU1hdGguUEkvMTgwO2Z1bmN0aW9uIG8oeCl7cmV0dXJuIHgqdX1mdW5jdGlvbiBmKHgsYyl7cmV0dXJuIE1hdGguYWJzKHgtYyk8PXIqTWF0aC5tYXgoMSxNYXRoLmFicyh4KSxNYXRoLmFicyhjKSl9TWF0aC5oeXBvdHx8KE1hdGguaHlwb3Q9ZnVuY3Rpb24oKXtmb3IodmFyIHg9MCxjPWFyZ3VtZW50cy5sZW5ndGg7Yy0tOyl4Kz1hcmd1bWVudHNbY10qYXJndW1lbnRzW2NdO3JldHVybiBNYXRoLnNxcnQoeCl9KX0sZnVuY3Rpb24oaCxlLHQpe3QucihlKSx0LmQoZSwiY3JlYXRlIixmdW5jdGlvbigpe3JldHVybiBufSksdC5kKGUsImNsb25lIixmdW5jdGlvbigpe3JldHVybiBkfSksdC5kKGUsImNvcHkiLGZ1bmN0aW9uKCl7cmV0dXJuIGd9KSx0LmQoZSwiaWRlbnRpdHkiLGZ1bmN0aW9uKCl7cmV0dXJuIHV9KSx0LmQoZSwiZnJvbVZhbHVlcyIsZnVuY3Rpb24oKXtyZXR1cm4gb30pLHQuZChlLCJzZXQiLGZ1bmN0aW9uKCl7cmV0dXJuIGZ9KSx0LmQoZSwidHJhbnNwb3NlIixmdW5jdGlvbigpe3JldHVybiB4fSksdC5kKGUsImludmVydCIsZnVuY3Rpb24oKXtyZXR1cm4gY30pLHQuZChlLCJhZGpvaW50IixmdW5jdGlvbigpe3JldHVybiB2fSksdC5kKGUsImRldGVybWluYW50IixmdW5jdGlvbigpe3JldHVybiBwfSksdC5kKGUsIm11bHRpcGx5IixmdW5jdGlvbigpe3JldHVybiBifSksdC5kKGUsInJvdGF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gRX0pLHQuZChlLCJzY2FsZSIsZnVuY3Rpb24oKXtyZXR1cm4geX0pLHQuZChlLCJmcm9tUm90YXRpb24iLGZ1bmN0aW9uKCl7cmV0dXJuIE19KSx0LmQoZSwiZnJvbVNjYWxpbmciLGZ1bmN0aW9uKCl7cmV0dXJuIGl9KSx0LmQoZSwic3RyIixmdW5jdGlvbigpe3JldHVybiBhfSksdC5kKGUsImZyb2IiLGZ1bmN0aW9uKCl7cmV0dXJuIHN9KSx0LmQoZSwiTERVIixmdW5jdGlvbigpe3JldHVybiBsfSksdC5kKGUsImFkZCIsZnVuY3Rpb24oKXtyZXR1cm4gT30pLHQuZChlLCJzdWJ0cmFjdCIsZnVuY3Rpb24oKXtyZXR1cm4gQX0pLHQuZChlLCJleGFjdEVxdWFscyIsZnVuY3Rpb24oKXtyZXR1cm4gUn0pLHQuZChlLCJlcXVhbHMiLGZ1bmN0aW9uKCl7cmV0dXJuIEl9KSx0LmQoZSwibXVsdGlwbHlTY2FsYXIiLGZ1bmN0aW9uKCl7cmV0dXJuIFB9KSx0LmQoZSwibXVsdGlwbHlTY2FsYXJBbmRBZGQiLGZ1bmN0aW9uKCl7cmV0dXJuIEx9KSx0LmQoZSwibXVsIixmdW5jdGlvbigpe3JldHVybiBEfSksdC5kKGUsInN1YiIsZnVuY3Rpb24oKXtyZXR1cm4gQ30pO3ZhciByPXQoMik7ZnVuY3Rpb24gbigpe3ZhciBTPW5ldyByLkFSUkFZX1RZUEUoNCk7cmV0dXJuIHIuQVJSQVlfVFlQRSE9RmxvYXQzMkFycmF5JiYoU1sxXT0wLFNbMl09MCksU1swXT0xLFNbM109MSxTfWZ1bmN0aW9uIGQoUyl7dmFyIEI9bmV3IHIuQVJSQVlfVFlQRSg0KTtyZXR1cm4gQlswXT1TWzBdLEJbMV09U1sxXSxCWzJdPVNbMl0sQlszXT1TWzNdLEJ9ZnVuY3Rpb24gZyhTLEIpe3JldHVybiBTWzBdPUJbMF0sU1sxXT1CWzFdLFNbMl09QlsyXSxTWzNdPUJbM10sU31mdW5jdGlvbiB1KFMpe3JldHVybiBTWzBdPTEsU1sxXT0wLFNbMl09MCxTWzNdPTEsU31mdW5jdGlvbiBvKFMsQix3LEgpe3ZhciBKPW5ldyByLkFSUkFZX1RZUEUoNCk7cmV0dXJuIEpbMF09UyxKWzFdPUIsSlsyXT13LEpbM109SCxKfWZ1bmN0aW9uIGYoUyxCLHcsSCxKKXtyZXR1cm4gU1swXT1CLFNbMV09dyxTWzJdPUgsU1szXT1KLFN9ZnVuY3Rpb24geChTLEIpe2lmKFM9PT1CKXt2YXIgdz1CWzFdO1NbMV09QlsyXSxTWzJdPXd9ZWxzZSBTWzBdPUJbMF0sU1sxXT1CWzJdLFNbMl09QlsxXSxTWzNdPUJbM107cmV0dXJuIFN9ZnVuY3Rpb24gYyhTLEIpe3ZhciB3PUJbMF0sSD1CWzFdLEo9QlsyXSxxPUJbM10sVT13KnEtSipIO3JldHVybiBVPyhVPTEvVSxTWzBdPXEqVSxTWzFdPS1IKlUsU1syXT0tSipVLFNbM109dypVLFMpOm51bGx9ZnVuY3Rpb24gdihTLEIpe3ZhciB3PUJbMF07cmV0dXJuIFNbMF09QlszXSxTWzFdPS1CWzFdLFNbMl09LUJbMl0sU1szXT13LFN9ZnVuY3Rpb24gcChTKXtyZXR1cm4gU1swXSpTWzNdLVNbMl0qU1sxXX1mdW5jdGlvbiBiKFMsQix3KXt2YXIgSD1CWzBdLEo9QlsxXSxxPUJbMl0sVT1CWzNdLEc9d1swXSxaPXdbMV0sdHQ9d1syXSxfPXdbM107cmV0dXJuIFNbMF09SCpHK3EqWixTWzFdPUoqRytVKlosU1syXT1IKnR0K3EqXyxTWzNdPUoqdHQrVSpfLFN9ZnVuY3Rpb24gRShTLEIsdyl7dmFyIEg9QlswXSxKPUJbMV0scT1CWzJdLFU9QlszXSxHPU1hdGguc2luKHcpLFo9TWF0aC5jb3Modyk7cmV0dXJuIFNbMF09SCpaK3EqRyxTWzFdPUoqWitVKkcsU1syXT1IKi1HK3EqWixTWzNdPUoqLUcrVSpaLFN9ZnVuY3Rpb24geShTLEIsdyl7dmFyIEg9QlswXSxKPUJbMV0scT1CWzJdLFU9QlszXSxHPXdbMF0sWj13WzFdO3JldHVybiBTWzBdPUgqRyxTWzFdPUoqRyxTWzJdPXEqWixTWzNdPVUqWixTfWZ1bmN0aW9uIE0oUyxCKXt2YXIgdz1NYXRoLnNpbihCKSxIPU1hdGguY29zKEIpO3JldHVybiBTWzBdPUgsU1sxXT13LFNbMl09LXcsU1szXT1ILFN9ZnVuY3Rpb24gaShTLEIpe3JldHVybiBTWzBdPUJbMF0sU1sxXT0wLFNbMl09MCxTWzNdPUJbMV0sU31mdW5jdGlvbiBhKFMpe3JldHVybiJtYXQyKCIrU1swXSsiLCAiK1NbMV0rIiwgIitTWzJdKyIsICIrU1szXSsiKSJ9ZnVuY3Rpb24gcyhTKXtyZXR1cm4gTWF0aC5oeXBvdChTWzBdLFNbMV0sU1syXSxTWzNdKX1mdW5jdGlvbiBsKFMsQix3LEgpe3JldHVybiBTWzJdPUhbMl0vSFswXSx3WzBdPUhbMF0sd1sxXT1IWzFdLHdbM109SFszXS1TWzJdKndbMV0sW1MsQix3XX1mdW5jdGlvbiBPKFMsQix3KXtyZXR1cm4gU1swXT1CWzBdK3dbMF0sU1sxXT1CWzFdK3dbMV0sU1syXT1CWzJdK3dbMl0sU1szXT1CWzNdK3dbM10sU31mdW5jdGlvbiBBKFMsQix3KXtyZXR1cm4gU1swXT1CWzBdLXdbMF0sU1sxXT1CWzFdLXdbMV0sU1syXT1CWzJdLXdbMl0sU1szXT1CWzNdLXdbM10sU31mdW5jdGlvbiBSKFMsQil7cmV0dXJuIFNbMF09PT1CWzBdJiZTWzFdPT09QlsxXSYmU1syXT09PUJbMl0mJlNbM109PT1CWzNdfWZ1bmN0aW9uIEkoUyxCKXt2YXIgdz1TWzBdLEg9U1sxXSxKPVNbMl0scT1TWzNdLFU9QlswXSxHPUJbMV0sWj1CWzJdLHR0PUJbM107cmV0dXJuIE1hdGguYWJzKHctVSk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKHcpLE1hdGguYWJzKFUpKSYmTWF0aC5hYnMoSC1HKTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoSCksTWF0aC5hYnMoRykpJiZNYXRoLmFicyhKLVopPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhKKSxNYXRoLmFicyhaKSkmJk1hdGguYWJzKHEtdHQpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhxKSxNYXRoLmFicyh0dCkpfWZ1bmN0aW9uIFAoUyxCLHcpe3JldHVybiBTWzBdPUJbMF0qdyxTWzFdPUJbMV0qdyxTWzJdPUJbMl0qdyxTWzNdPUJbM10qdyxTfWZ1bmN0aW9uIEwoUyxCLHcsSCl7cmV0dXJuIFNbMF09QlswXSt3WzBdKkgsU1sxXT1CWzFdK3dbMV0qSCxTWzJdPUJbMl0rd1syXSpILFNbM109QlszXSt3WzNdKkgsU312YXIgRD1iLEM9QX0sZnVuY3Rpb24oaCxlLHQpe3QucihlKSx0LmQoZSwiY3JlYXRlIixmdW5jdGlvbigpe3JldHVybiBufSksdC5kKGUsImNsb25lIixmdW5jdGlvbigpe3JldHVybiBkfSksdC5kKGUsImNvcHkiLGZ1bmN0aW9uKCl7cmV0dXJuIGd9KSx0LmQoZSwiaWRlbnRpdHkiLGZ1bmN0aW9uKCl7cmV0dXJuIHV9KSx0LmQoZSwiZnJvbVZhbHVlcyIsZnVuY3Rpb24oKXtyZXR1cm4gb30pLHQuZChlLCJzZXQiLGZ1bmN0aW9uKCl7cmV0dXJuIGZ9KSx0LmQoZSwiaW52ZXJ0IixmdW5jdGlvbigpe3JldHVybiB4fSksdC5kKGUsImRldGVybWluYW50IixmdW5jdGlvbigpe3JldHVybiBjfSksdC5kKGUsIm11bHRpcGx5IixmdW5jdGlvbigpe3JldHVybiB2fSksdC5kKGUsInJvdGF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gcH0pLHQuZChlLCJzY2FsZSIsZnVuY3Rpb24oKXtyZXR1cm4gYn0pLHQuZChlLCJ0cmFuc2xhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIEV9KSx0LmQoZSwiZnJvbVJvdGF0aW9uIixmdW5jdGlvbigpe3JldHVybiB5fSksdC5kKGUsImZyb21TY2FsaW5nIixmdW5jdGlvbigpe3JldHVybiBNfSksdC5kKGUsImZyb21UcmFuc2xhdGlvbiIsZnVuY3Rpb24oKXtyZXR1cm4gaX0pLHQuZChlLCJzdHIiLGZ1bmN0aW9uKCl7cmV0dXJuIGF9KSx0LmQoZSwiZnJvYiIsZnVuY3Rpb24oKXtyZXR1cm4gc30pLHQuZChlLCJhZGQiLGZ1bmN0aW9uKCl7cmV0dXJuIGx9KSx0LmQoZSwic3VidHJhY3QiLGZ1bmN0aW9uKCl7cmV0dXJuIE99KSx0LmQoZSwibXVsdGlwbHlTY2FsYXIiLGZ1bmN0aW9uKCl7cmV0dXJuIEF9KSx0LmQoZSwibXVsdGlwbHlTY2FsYXJBbmRBZGQiLGZ1bmN0aW9uKCl7cmV0dXJuIFJ9KSx0LmQoZSwiZXhhY3RFcXVhbHMiLGZ1bmN0aW9uKCl7cmV0dXJuIEl9KSx0LmQoZSwiZXF1YWxzIixmdW5jdGlvbigpe3JldHVybiBQfSksdC5kKGUsIm11bCIsZnVuY3Rpb24oKXtyZXR1cm4gTH0pLHQuZChlLCJzdWIiLGZ1bmN0aW9uKCl7cmV0dXJuIER9KTt2YXIgcj10KDIpO2Z1bmN0aW9uIG4oKXt2YXIgQz1uZXcgci5BUlJBWV9UWVBFKDYpO3JldHVybiByLkFSUkFZX1RZUEUhPUZsb2F0MzJBcnJheSYmKENbMV09MCxDWzJdPTAsQ1s0XT0wLENbNV09MCksQ1swXT0xLENbM109MSxDfWZ1bmN0aW9uIGQoQyl7dmFyIFM9bmV3IHIuQVJSQVlfVFlQRSg2KTtyZXR1cm4gU1swXT1DWzBdLFNbMV09Q1sxXSxTWzJdPUNbMl0sU1szXT1DWzNdLFNbNF09Q1s0XSxTWzVdPUNbNV0sU31mdW5jdGlvbiBnKEMsUyl7cmV0dXJuIENbMF09U1swXSxDWzFdPVNbMV0sQ1syXT1TWzJdLENbM109U1szXSxDWzRdPVNbNF0sQ1s1XT1TWzVdLEN9ZnVuY3Rpb24gdShDKXtyZXR1cm4gQ1swXT0xLENbMV09MCxDWzJdPTAsQ1szXT0xLENbNF09MCxDWzVdPTAsQ31mdW5jdGlvbiBvKEMsUyxCLHcsSCxKKXt2YXIgcT1uZXcgci5BUlJBWV9UWVBFKDYpO3JldHVybiBxWzBdPUMscVsxXT1TLHFbMl09QixxWzNdPXcscVs0XT1ILHFbNV09SixxfWZ1bmN0aW9uIGYoQyxTLEIsdyxILEoscSl7cmV0dXJuIENbMF09UyxDWzFdPUIsQ1syXT13LENbM109SCxDWzRdPUosQ1s1XT1xLEN9ZnVuY3Rpb24geChDLFMpe3ZhciBCPVNbMF0sdz1TWzFdLEg9U1syXSxKPVNbM10scT1TWzRdLFU9U1s1XSxHPUIqSi13Kkg7cmV0dXJuIEc/KEc9MS9HLENbMF09SipHLENbMV09LXcqRyxDWzJdPS1IKkcsQ1szXT1CKkcsQ1s0XT0oSCpVLUoqcSkqRyxDWzVdPSh3KnEtQipVKSpHLEMpOm51bGx9ZnVuY3Rpb24gYyhDKXtyZXR1cm4gQ1swXSpDWzNdLUNbMV0qQ1syXX1mdW5jdGlvbiB2KEMsUyxCKXt2YXIgdz1TWzBdLEg9U1sxXSxKPVNbMl0scT1TWzNdLFU9U1s0XSxHPVNbNV0sWj1CWzBdLHR0PUJbMV0sXz1CWzJdLHN0PUJbM10saz1CWzRdLGh0PUJbNV07cmV0dXJuIENbMF09dypaK0oqdHQsQ1sxXT1IKlorcSp0dCxDWzJdPXcqXytKKnN0LENbM109SCpfK3Eqc3QsQ1s0XT13KmsrSipodCtVLENbNV09SCprK3EqaHQrRyxDfWZ1bmN0aW9uIHAoQyxTLEIpe3ZhciB3PVNbMF0sSD1TWzFdLEo9U1syXSxxPVNbM10sVT1TWzRdLEc9U1s1XSxaPU1hdGguc2luKEIpLHR0PU1hdGguY29zKEIpO3JldHVybiBDWzBdPXcqdHQrSipaLENbMV09SCp0dCtxKlosQ1syXT13Ki1aK0oqdHQsQ1szXT1IKi1aK3EqdHQsQ1s0XT1VLENbNV09RyxDfWZ1bmN0aW9uIGIoQyxTLEIpe3ZhciB3PVNbMF0sSD1TWzFdLEo9U1syXSxxPVNbM10sVT1TWzRdLEc9U1s1XSxaPUJbMF0sdHQ9QlsxXTtyZXR1cm4gQ1swXT13KlosQ1sxXT1IKlosQ1syXT1KKnR0LENbM109cSp0dCxDWzRdPVUsQ1s1XT1HLEN9ZnVuY3Rpb24gRShDLFMsQil7dmFyIHc9U1swXSxIPVNbMV0sSj1TWzJdLHE9U1szXSxVPVNbNF0sRz1TWzVdLFo9QlswXSx0dD1CWzFdO3JldHVybiBDWzBdPXcsQ1sxXT1ILENbMl09SixDWzNdPXEsQ1s0XT13KlorSip0dCtVLENbNV09SCpaK3EqdHQrRyxDfWZ1bmN0aW9uIHkoQyxTKXt2YXIgQj1NYXRoLnNpbihTKSx3PU1hdGguY29zKFMpO3JldHVybiBDWzBdPXcsQ1sxXT1CLENbMl09LUIsQ1szXT13LENbNF09MCxDWzVdPTAsQ31mdW5jdGlvbiBNKEMsUyl7cmV0dXJuIENbMF09U1swXSxDWzFdPTAsQ1syXT0wLENbM109U1sxXSxDWzRdPTAsQ1s1XT0wLEN9ZnVuY3Rpb24gaShDLFMpe3JldHVybiBDWzBdPTEsQ1sxXT0wLENbMl09MCxDWzNdPTEsQ1s0XT1TWzBdLENbNV09U1sxXSxDfWZ1bmN0aW9uIGEoQyl7cmV0dXJuIm1hdDJkKCIrQ1swXSsiLCAiK0NbMV0rIiwgIitDWzJdKyIsICIrQ1szXSsiLCAiK0NbNF0rIiwgIitDWzVdKyIpIn1mdW5jdGlvbiBzKEMpe3JldHVybiBNYXRoLmh5cG90KENbMF0sQ1sxXSxDWzJdLENbM10sQ1s0XSxDWzVdLDEpfWZ1bmN0aW9uIGwoQyxTLEIpe3JldHVybiBDWzBdPVNbMF0rQlswXSxDWzFdPVNbMV0rQlsxXSxDWzJdPVNbMl0rQlsyXSxDWzNdPVNbM10rQlszXSxDWzRdPVNbNF0rQls0XSxDWzVdPVNbNV0rQls1XSxDfWZ1bmN0aW9uIE8oQyxTLEIpe3JldHVybiBDWzBdPVNbMF0tQlswXSxDWzFdPVNbMV0tQlsxXSxDWzJdPVNbMl0tQlsyXSxDWzNdPVNbM10tQlszXSxDWzRdPVNbNF0tQls0XSxDWzVdPVNbNV0tQls1XSxDfWZ1bmN0aW9uIEEoQyxTLEIpe3JldHVybiBDWzBdPVNbMF0qQixDWzFdPVNbMV0qQixDWzJdPVNbMl0qQixDWzNdPVNbM10qQixDWzRdPVNbNF0qQixDWzVdPVNbNV0qQixDfWZ1bmN0aW9uIFIoQyxTLEIsdyl7cmV0dXJuIENbMF09U1swXStCWzBdKncsQ1sxXT1TWzFdK0JbMV0qdyxDWzJdPVNbMl0rQlsyXSp3LENbM109U1szXStCWzNdKncsQ1s0XT1TWzRdK0JbNF0qdyxDWzVdPVNbNV0rQls1XSp3LEN9ZnVuY3Rpb24gSShDLFMpe3JldHVybiBDWzBdPT09U1swXSYmQ1sxXT09PVNbMV0mJkNbMl09PT1TWzJdJiZDWzNdPT09U1szXSYmQ1s0XT09PVNbNF0mJkNbNV09PT1TWzVdfWZ1bmN0aW9uIFAoQyxTKXt2YXIgQj1DWzBdLHc9Q1sxXSxIPUNbMl0sSj1DWzNdLHE9Q1s0XSxVPUNbNV0sRz1TWzBdLFo9U1sxXSx0dD1TWzJdLF89U1szXSxzdD1TWzRdLGs9U1s1XTtyZXR1cm4gTWF0aC5hYnMoQi1HKTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoQiksTWF0aC5hYnMoRykpJiZNYXRoLmFicyh3LVopPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyh3KSxNYXRoLmFicyhaKSkmJk1hdGguYWJzKEgtdHQpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhIKSxNYXRoLmFicyh0dCkpJiZNYXRoLmFicyhKLV8pPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhKKSxNYXRoLmFicyhfKSkmJk1hdGguYWJzKHEtc3QpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhxKSxNYXRoLmFicyhzdCkpJiZNYXRoLmFicyhVLWspPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhVKSxNYXRoLmFicyhrKSl9dmFyIEw9dixEPU99LGZ1bmN0aW9uKGgsZSx0KXt0LnIoZSksdC5kKGUsImNyZWF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gbn0pLHQuZChlLCJmcm9tTWF0NCIsZnVuY3Rpb24oKXtyZXR1cm4gZH0pLHQuZChlLCJjbG9uZSIsZnVuY3Rpb24oKXtyZXR1cm4gZ30pLHQuZChlLCJjb3B5IixmdW5jdGlvbigpe3JldHVybiB1fSksdC5kKGUsImZyb21WYWx1ZXMiLGZ1bmN0aW9uKCl7cmV0dXJuIG99KSx0LmQoZSwic2V0IixmdW5jdGlvbigpe3JldHVybiBmfSksdC5kKGUsImlkZW50aXR5IixmdW5jdGlvbigpe3JldHVybiB4fSksdC5kKGUsInRyYW5zcG9zZSIsZnVuY3Rpb24oKXtyZXR1cm4gY30pLHQuZChlLCJpbnZlcnQiLGZ1bmN0aW9uKCl7cmV0dXJuIHZ9KSx0LmQoZSwiYWRqb2ludCIsZnVuY3Rpb24oKXtyZXR1cm4gcH0pLHQuZChlLCJkZXRlcm1pbmFudCIsZnVuY3Rpb24oKXtyZXR1cm4gYn0pLHQuZChlLCJtdWx0aXBseSIsZnVuY3Rpb24oKXtyZXR1cm4gRX0pLHQuZChlLCJ0cmFuc2xhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIHl9KSx0LmQoZSwicm90YXRlIixmdW5jdGlvbigpe3JldHVybiBNfSksdC5kKGUsInNjYWxlIixmdW5jdGlvbigpe3JldHVybiBpfSksdC5kKGUsImZyb21UcmFuc2xhdGlvbiIsZnVuY3Rpb24oKXtyZXR1cm4gYX0pLHQuZChlLCJmcm9tUm90YXRpb24iLGZ1bmN0aW9uKCl7cmV0dXJuIHN9KSx0LmQoZSwiZnJvbVNjYWxpbmciLGZ1bmN0aW9uKCl7cmV0dXJuIGx9KSx0LmQoZSwiZnJvbU1hdDJkIixmdW5jdGlvbigpe3JldHVybiBPfSksdC5kKGUsImZyb21RdWF0IixmdW5jdGlvbigpe3JldHVybiBBfSksdC5kKGUsIm5vcm1hbEZyb21NYXQ0IixmdW5jdGlvbigpe3JldHVybiBSfSksdC5kKGUsInByb2plY3Rpb24iLGZ1bmN0aW9uKCl7cmV0dXJuIEl9KSx0LmQoZSwic3RyIixmdW5jdGlvbigpe3JldHVybiBQfSksdC5kKGUsImZyb2IiLGZ1bmN0aW9uKCl7cmV0dXJuIEx9KSx0LmQoZSwiYWRkIixmdW5jdGlvbigpe3JldHVybiBEfSksdC5kKGUsInN1YnRyYWN0IixmdW5jdGlvbigpe3JldHVybiBDfSksdC5kKGUsIm11bHRpcGx5U2NhbGFyIixmdW5jdGlvbigpe3JldHVybiBTfSksdC5kKGUsIm11bHRpcGx5U2NhbGFyQW5kQWRkIixmdW5jdGlvbigpe3JldHVybiBCfSksdC5kKGUsImV4YWN0RXF1YWxzIixmdW5jdGlvbigpe3JldHVybiB3fSksdC5kKGUsImVxdWFscyIsZnVuY3Rpb24oKXtyZXR1cm4gSH0pLHQuZChlLCJtdWwiLGZ1bmN0aW9uKCl7cmV0dXJuIEp9KSx0LmQoZSwic3ViIixmdW5jdGlvbigpe3JldHVybiBxfSk7dmFyIHI9dCgyKTtmdW5jdGlvbiBuKCl7dmFyIFU9bmV3IHIuQVJSQVlfVFlQRSg5KTtyZXR1cm4gci5BUlJBWV9UWVBFIT1GbG9hdDMyQXJyYXkmJihVWzFdPTAsVVsyXT0wLFVbM109MCxVWzVdPTAsVVs2XT0wLFVbN109MCksVVswXT0xLFVbNF09MSxVWzhdPTEsVX1mdW5jdGlvbiBkKFUsRyl7cmV0dXJuIFVbMF09R1swXSxVWzFdPUdbMV0sVVsyXT1HWzJdLFVbM109R1s0XSxVWzRdPUdbNV0sVVs1XT1HWzZdLFVbNl09R1s4XSxVWzddPUdbOV0sVVs4XT1HWzEwXSxVfWZ1bmN0aW9uIGcoVSl7dmFyIEc9bmV3IHIuQVJSQVlfVFlQRSg5KTtyZXR1cm4gR1swXT1VWzBdLEdbMV09VVsxXSxHWzJdPVVbMl0sR1szXT1VWzNdLEdbNF09VVs0XSxHWzVdPVVbNV0sR1s2XT1VWzZdLEdbN109VVs3XSxHWzhdPVVbOF0sR31mdW5jdGlvbiB1KFUsRyl7cmV0dXJuIFVbMF09R1swXSxVWzFdPUdbMV0sVVsyXT1HWzJdLFVbM109R1szXSxVWzRdPUdbNF0sVVs1XT1HWzVdLFVbNl09R1s2XSxVWzddPUdbN10sVVs4XT1HWzhdLFV9ZnVuY3Rpb24gbyhVLEcsWix0dCxfLHN0LGssaHQsZnQpe3ZhciBXPW5ldyByLkFSUkFZX1RZUEUoOSk7cmV0dXJuIFdbMF09VSxXWzFdPUcsV1syXT1aLFdbM109dHQsV1s0XT1fLFdbNV09c3QsV1s2XT1rLFdbN109aHQsV1s4XT1mdCxXfWZ1bmN0aW9uIGYoVSxHLFosdHQsXyxzdCxrLGh0LGZ0LFcpe3JldHVybiBVWzBdPUcsVVsxXT1aLFVbMl09dHQsVVszXT1fLFVbNF09c3QsVVs1XT1rLFVbNl09aHQsVVs3XT1mdCxVWzhdPVcsVX1mdW5jdGlvbiB4KFUpe3JldHVybiBVWzBdPTEsVVsxXT0wLFVbMl09MCxVWzNdPTAsVVs0XT0xLFVbNV09MCxVWzZdPTAsVVs3XT0wLFVbOF09MSxVfWZ1bmN0aW9uIGMoVSxHKXtpZihVPT09Ryl7dmFyIFo9R1sxXSx0dD1HWzJdLF89R1s1XTtVWzFdPUdbM10sVVsyXT1HWzZdLFVbM109WixVWzVdPUdbN10sVVs2XT10dCxVWzddPV99ZWxzZSBVWzBdPUdbMF0sVVsxXT1HWzNdLFVbMl09R1s2XSxVWzNdPUdbMV0sVVs0XT1HWzRdLFVbNV09R1s3XSxVWzZdPUdbMl0sVVs3XT1HWzVdLFVbOF09R1s4XTtyZXR1cm4gVX1mdW5jdGlvbiB2KFUsRyl7dmFyIFo9R1swXSx0dD1HWzFdLF89R1syXSxzdD1HWzNdLGs9R1s0XSxodD1HWzVdLGZ0PUdbNl0sVz1HWzddLEY9R1s4XSxWPUYqay1odCpXLFg9LUYqc3QraHQqZnQsaj1XKnN0LWsqZnQsej1aKlYrdHQqWCtfKmo7cmV0dXJuIHo/KHo9MS96LFVbMF09Vip6LFVbMV09KC1GKnR0K18qVykqeixVWzJdPShodCp0dC1fKmspKnosVVszXT1YKnosVVs0XT0oRipaLV8qZnQpKnosVVs1XT0oLWh0KlorXypzdCkqeixVWzZdPWoqeixVWzddPSgtVypaK3R0KmZ0KSp6LFVbOF09KGsqWi10dCpzdCkqeixVKTpudWxsfWZ1bmN0aW9uIHAoVSxHKXt2YXIgWj1HWzBdLHR0PUdbMV0sXz1HWzJdLHN0PUdbM10saz1HWzRdLGh0PUdbNV0sZnQ9R1s2XSxXPUdbN10sRj1HWzhdO3JldHVybiBVWzBdPWsqRi1odCpXLFVbMV09XypXLXR0KkYsVVsyXT10dCpodC1fKmssVVszXT1odCpmdC1zdCpGLFVbNF09WipGLV8qZnQsVVs1XT1fKnN0LVoqaHQsVVs2XT1zdCpXLWsqZnQsVVs3XT10dCpmdC1aKlcsVVs4XT1aKmstdHQqc3QsVX1mdW5jdGlvbiBiKFUpe3ZhciBHPVVbMF0sWj1VWzFdLHR0PVVbMl0sXz1VWzNdLHN0PVVbNF0saz1VWzVdLGh0PVVbNl0sZnQ9VVs3XSxXPVVbOF07cmV0dXJuIEcqKFcqc3QtaypmdCkrWiooLVcqXytrKmh0KSt0dCooZnQqXy1zdCpodCl9ZnVuY3Rpb24gRShVLEcsWil7dmFyIHR0PUdbMF0sXz1HWzFdLHN0PUdbMl0saz1HWzNdLGh0PUdbNF0sZnQ9R1s1XSxXPUdbNl0sRj1HWzddLFY9R1s4XSxYPVpbMF0saj1aWzFdLHo9WlsyXSxtPVpbM10sVD1aWzRdLE49Wls1XSwkPVpbNl0sSz1aWzddLFk9Wls4XTtyZXR1cm4gVVswXT1YKnR0K2oqayt6KlcsVVsxXT1YKl8raipodCt6KkYsVVsyXT1YKnN0K2oqZnQreipWLFVbM109bSp0dCtUKmsrTipXLFVbNF09bSpfK1QqaHQrTipGLFVbNV09bSpzdCtUKmZ0K04qVixVWzZdPSQqdHQrSyprK1kqVyxVWzddPSQqXytLKmh0K1kqRixVWzhdPSQqc3QrSypmdCtZKlYsVX1mdW5jdGlvbiB5KFUsRyxaKXt2YXIgdHQ9R1swXSxfPUdbMV0sc3Q9R1syXSxrPUdbM10saHQ9R1s0XSxmdD1HWzVdLFc9R1s2XSxGPUdbN10sVj1HWzhdLFg9WlswXSxqPVpbMV07cmV0dXJuIFVbMF09dHQsVVsxXT1fLFVbMl09c3QsVVszXT1rLFVbNF09aHQsVVs1XT1mdCxVWzZdPVgqdHQraiprK1csVVs3XT1YKl8raipodCtGLFVbOF09WCpzdCtqKmZ0K1YsVX1mdW5jdGlvbiBNKFUsRyxaKXt2YXIgdHQ9R1swXSxfPUdbMV0sc3Q9R1syXSxrPUdbM10saHQ9R1s0XSxmdD1HWzVdLFc9R1s2XSxGPUdbN10sVj1HWzhdLFg9TWF0aC5zaW4oWiksaj1NYXRoLmNvcyhaKTtyZXR1cm4gVVswXT1qKnR0K1gqayxVWzFdPWoqXytYKmh0LFVbMl09aipzdCtYKmZ0LFVbM109aiprLVgqdHQsVVs0XT1qKmh0LVgqXyxVWzVdPWoqZnQtWCpzdCxVWzZdPVcsVVs3XT1GLFVbOF09VixVfWZ1bmN0aW9uIGkoVSxHLFope3ZhciB0dD1aWzBdLF89WlsxXTtyZXR1cm4gVVswXT10dCpHWzBdLFVbMV09dHQqR1sxXSxVWzJdPXR0KkdbMl0sVVszXT1fKkdbM10sVVs0XT1fKkdbNF0sVVs1XT1fKkdbNV0sVVs2XT1HWzZdLFVbN109R1s3XSxVWzhdPUdbOF0sVX1mdW5jdGlvbiBhKFUsRyl7cmV0dXJuIFVbMF09MSxVWzFdPTAsVVsyXT0wLFVbM109MCxVWzRdPTEsVVs1XT0wLFVbNl09R1swXSxVWzddPUdbMV0sVVs4XT0xLFV9ZnVuY3Rpb24gcyhVLEcpe3ZhciBaPU1hdGguc2luKEcpLHR0PU1hdGguY29zKEcpO3JldHVybiBVWzBdPXR0LFVbMV09WixVWzJdPTAsVVszXT0tWixVWzRdPXR0LFVbNV09MCxVWzZdPTAsVVs3XT0wLFVbOF09MSxVfWZ1bmN0aW9uIGwoVSxHKXtyZXR1cm4gVVswXT1HWzBdLFVbMV09MCxVWzJdPTAsVVszXT0wLFVbNF09R1sxXSxVWzVdPTAsVVs2XT0wLFVbN109MCxVWzhdPTEsVX1mdW5jdGlvbiBPKFUsRyl7cmV0dXJuIFVbMF09R1swXSxVWzFdPUdbMV0sVVsyXT0wLFVbM109R1syXSxVWzRdPUdbM10sVVs1XT0wLFVbNl09R1s0XSxVWzddPUdbNV0sVVs4XT0xLFV9ZnVuY3Rpb24gQShVLEcpe3ZhciBaPUdbMF0sdHQ9R1sxXSxfPUdbMl0sc3Q9R1szXSxrPVorWixodD10dCt0dCxmdD1fK18sVz1aKmssRj10dCprLFY9dHQqaHQsWD1fKmssaj1fKmh0LHo9XypmdCxtPXN0KmssVD1zdCpodCxOPXN0KmZ0O3JldHVybiBVWzBdPTEtVi16LFVbM109Ri1OLFVbNl09WCtULFVbMV09RitOLFVbNF09MS1XLXosVVs3XT1qLW0sVVsyXT1YLVQsVVs1XT1qK20sVVs4XT0xLVctVixVfWZ1bmN0aW9uIFIoVSxHKXt2YXIgWj1HWzBdLHR0PUdbMV0sXz1HWzJdLHN0PUdbM10saz1HWzRdLGh0PUdbNV0sZnQ9R1s2XSxXPUdbN10sRj1HWzhdLFY9R1s5XSxYPUdbMTBdLGo9R1sxMV0sej1HWzEyXSxtPUdbMTNdLFQ9R1sxNF0sTj1HWzE1XSwkPVoqaHQtdHQqayxLPVoqZnQtXyprLFk9WipXLXN0KmssUT10dCpmdC1fKmh0LGV0PXR0Klctc3QqaHQscnQ9XypXLXN0KmZ0LG90PUYqbS1WKnosbHQ9RipULVgqeixpdD1GKk4taip6LG50PVYqVC1YKm0sYXQ9VipOLWoqbSxkdD1YKk4taipULGd0PSQqZHQtSyphdCtZKm50K1EqaXQtZXQqbHQrcnQqb3Q7cmV0dXJuIGd0PyhndD0xL2d0LFVbMF09KGh0KmR0LWZ0KmF0K1cqbnQpKmd0LFVbMV09KGZ0Kml0LWsqZHQtVypsdCkqZ3QsVVsyXT0oayphdC1odCppdCtXKm90KSpndCxVWzNdPShfKmF0LXR0KmR0LXN0Km50KSpndCxVWzRdPShaKmR0LV8qaXQrc3QqbHQpKmd0LFVbNV09KHR0Kml0LVoqYXQtc3Qqb3QpKmd0LFVbNl09KG0qcnQtVCpldCtOKlEpKmd0LFVbN109KFQqWS16KnJ0LU4qSykqZ3QsVVs4XT0oeipldC1tKlkrTiokKSpndCxVKTpudWxsfWZ1bmN0aW9uIEkoVSxHLFope3JldHVybiBVWzBdPTIvRyxVWzFdPTAsVVsyXT0wLFVbM109MCxVWzRdPS0yL1osVVs1XT0wLFVbNl09LTEsVVs3XT0xLFVbOF09MSxVfWZ1bmN0aW9uIFAoVSl7cmV0dXJuIm1hdDMoIitVWzBdKyIsICIrVVsxXSsiLCAiK1VbMl0rIiwgIitVWzNdKyIsICIrVVs0XSsiLCAiK1VbNV0rIiwgIitVWzZdKyIsICIrVVs3XSsiLCAiK1VbOF0rIikifWZ1bmN0aW9uIEwoVSl7cmV0dXJuIE1hdGguaHlwb3QoVVswXSxVWzFdLFVbMl0sVVszXSxVWzRdLFVbNV0sVVs2XSxVWzddLFVbOF0pfWZ1bmN0aW9uIEQoVSxHLFope3JldHVybiBVWzBdPUdbMF0rWlswXSxVWzFdPUdbMV0rWlsxXSxVWzJdPUdbMl0rWlsyXSxVWzNdPUdbM10rWlszXSxVWzRdPUdbNF0rWls0XSxVWzVdPUdbNV0rWls1XSxVWzZdPUdbNl0rWls2XSxVWzddPUdbN10rWls3XSxVWzhdPUdbOF0rWls4XSxVfWZ1bmN0aW9uIEMoVSxHLFope3JldHVybiBVWzBdPUdbMF0tWlswXSxVWzFdPUdbMV0tWlsxXSxVWzJdPUdbMl0tWlsyXSxVWzNdPUdbM10tWlszXSxVWzRdPUdbNF0tWls0XSxVWzVdPUdbNV0tWls1XSxVWzZdPUdbNl0tWls2XSxVWzddPUdbN10tWls3XSxVWzhdPUdbOF0tWls4XSxVfWZ1bmN0aW9uIFMoVSxHLFope3JldHVybiBVWzBdPUdbMF0qWixVWzFdPUdbMV0qWixVWzJdPUdbMl0qWixVWzNdPUdbM10qWixVWzRdPUdbNF0qWixVWzVdPUdbNV0qWixVWzZdPUdbNl0qWixVWzddPUdbN10qWixVWzhdPUdbOF0qWixVfWZ1bmN0aW9uIEIoVSxHLFosdHQpe3JldHVybiBVWzBdPUdbMF0rWlswXSp0dCxVWzFdPUdbMV0rWlsxXSp0dCxVWzJdPUdbMl0rWlsyXSp0dCxVWzNdPUdbM10rWlszXSp0dCxVWzRdPUdbNF0rWls0XSp0dCxVWzVdPUdbNV0rWls1XSp0dCxVWzZdPUdbNl0rWls2XSp0dCxVWzddPUdbN10rWls3XSp0dCxVWzhdPUdbOF0rWls4XSp0dCxVfWZ1bmN0aW9uIHcoVSxHKXtyZXR1cm4gVVswXT09PUdbMF0mJlVbMV09PT1HWzFdJiZVWzJdPT09R1syXSYmVVszXT09PUdbM10mJlVbNF09PT1HWzRdJiZVWzVdPT09R1s1XSYmVVs2XT09PUdbNl0mJlVbN109PT1HWzddJiZVWzhdPT09R1s4XX1mdW5jdGlvbiBIKFUsRyl7dmFyIFo9VVswXSx0dD1VWzFdLF89VVsyXSxzdD1VWzNdLGs9VVs0XSxodD1VWzVdLGZ0PVVbNl0sVz1VWzddLEY9VVs4XSxWPUdbMF0sWD1HWzFdLGo9R1syXSx6PUdbM10sbT1HWzRdLFQ9R1s1XSxOPUdbNl0sJD1HWzddLEs9R1s4XTtyZXR1cm4gTWF0aC5hYnMoWi1WKTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoWiksTWF0aC5hYnMoVikpJiZNYXRoLmFicyh0dC1YKTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnModHQpLE1hdGguYWJzKFgpKSYmTWF0aC5hYnMoXy1qKTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoXyksTWF0aC5hYnMoaikpJiZNYXRoLmFicyhzdC16KTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoc3QpLE1hdGguYWJzKHopKSYmTWF0aC5hYnMoay1tKTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoayksTWF0aC5hYnMobSkpJiZNYXRoLmFicyhodC1UKTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoaHQpLE1hdGguYWJzKFQpKSYmTWF0aC5hYnMoZnQtTik8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKGZ0KSxNYXRoLmFicyhOKSkmJk1hdGguYWJzKFctJCk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKFcpLE1hdGguYWJzKCQpKSYmTWF0aC5hYnMoRi1LKTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoRiksTWF0aC5hYnMoSykpfXZhciBKPUUscT1DfSxmdW5jdGlvbihoLGUsdCl7dC5yKGUpLHQuZChlLCJjcmVhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIG59KSx0LmQoZSwiY2xvbmUiLGZ1bmN0aW9uKCl7cmV0dXJuIGR9KSx0LmQoZSwiY29weSIsZnVuY3Rpb24oKXtyZXR1cm4gZ30pLHQuZChlLCJmcm9tVmFsdWVzIixmdW5jdGlvbigpe3JldHVybiB1fSksdC5kKGUsInNldCIsZnVuY3Rpb24oKXtyZXR1cm4gb30pLHQuZChlLCJpZGVudGl0eSIsZnVuY3Rpb24oKXtyZXR1cm4gZn0pLHQuZChlLCJ0cmFuc3Bvc2UiLGZ1bmN0aW9uKCl7cmV0dXJuIHh9KSx0LmQoZSwiaW52ZXJ0IixmdW5jdGlvbigpe3JldHVybiBjfSksdC5kKGUsImFkam9pbnQiLGZ1bmN0aW9uKCl7cmV0dXJuIHZ9KSx0LmQoZSwiZGV0ZXJtaW5hbnQiLGZ1bmN0aW9uKCl7cmV0dXJuIHB9KSx0LmQoZSwibXVsdGlwbHkiLGZ1bmN0aW9uKCl7cmV0dXJuIGJ9KSx0LmQoZSwidHJhbnNsYXRlIixmdW5jdGlvbigpe3JldHVybiBFfSksdC5kKGUsInNjYWxlIixmdW5jdGlvbigpe3JldHVybiB5fSksdC5kKGUsInJvdGF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gTX0pLHQuZChlLCJyb3RhdGVYIixmdW5jdGlvbigpe3JldHVybiBpfSksdC5kKGUsInJvdGF0ZVkiLGZ1bmN0aW9uKCl7cmV0dXJuIGF9KSx0LmQoZSwicm90YXRlWiIsZnVuY3Rpb24oKXtyZXR1cm4gc30pLHQuZChlLCJmcm9tVHJhbnNsYXRpb24iLGZ1bmN0aW9uKCl7cmV0dXJuIGx9KSx0LmQoZSwiZnJvbVNjYWxpbmciLGZ1bmN0aW9uKCl7cmV0dXJuIE99KSx0LmQoZSwiZnJvbVJvdGF0aW9uIixmdW5jdGlvbigpe3JldHVybiBBfSksdC5kKGUsImZyb21YUm90YXRpb24iLGZ1bmN0aW9uKCl7cmV0dXJuIFJ9KSx0LmQoZSwiZnJvbVlSb3RhdGlvbiIsZnVuY3Rpb24oKXtyZXR1cm4gSX0pLHQuZChlLCJmcm9tWlJvdGF0aW9uIixmdW5jdGlvbigpe3JldHVybiBQfSksdC5kKGUsImZyb21Sb3RhdGlvblRyYW5zbGF0aW9uIixmdW5jdGlvbigpe3JldHVybiBMfSksdC5kKGUsImZyb21RdWF0MiIsZnVuY3Rpb24oKXtyZXR1cm4gRH0pLHQuZChlLCJnZXRUcmFuc2xhdGlvbiIsZnVuY3Rpb24oKXtyZXR1cm4gQ30pLHQuZChlLCJnZXRTY2FsaW5nIixmdW5jdGlvbigpe3JldHVybiBTfSksdC5kKGUsImdldFJvdGF0aW9uIixmdW5jdGlvbigpe3JldHVybiBCfSksdC5kKGUsImZyb21Sb3RhdGlvblRyYW5zbGF0aW9uU2NhbGUiLGZ1bmN0aW9uKCl7cmV0dXJuIHd9KSx0LmQoZSwiZnJvbVJvdGF0aW9uVHJhbnNsYXRpb25TY2FsZU9yaWdpbiIsZnVuY3Rpb24oKXtyZXR1cm4gSH0pLHQuZChlLCJmcm9tUXVhdCIsZnVuY3Rpb24oKXtyZXR1cm4gSn0pLHQuZChlLCJmcnVzdHVtIixmdW5jdGlvbigpe3JldHVybiBxfSksdC5kKGUsInBlcnNwZWN0aXZlIixmdW5jdGlvbigpe3JldHVybiBVfSksdC5kKGUsInBlcnNwZWN0aXZlRnJvbUZpZWxkT2ZWaWV3IixmdW5jdGlvbigpe3JldHVybiBHfSksdC5kKGUsIm9ydGhvIixmdW5jdGlvbigpe3JldHVybiBafSksdC5kKGUsImxvb2tBdCIsZnVuY3Rpb24oKXtyZXR1cm4gdHR9KSx0LmQoZSwidGFyZ2V0VG8iLGZ1bmN0aW9uKCl7cmV0dXJuIF99KSx0LmQoZSwic3RyIixmdW5jdGlvbigpe3JldHVybiBzdH0pLHQuZChlLCJmcm9iIixmdW5jdGlvbigpe3JldHVybiBrfSksdC5kKGUsImFkZCIsZnVuY3Rpb24oKXtyZXR1cm4gaHR9KSx0LmQoZSwic3VidHJhY3QiLGZ1bmN0aW9uKCl7cmV0dXJuIGZ0fSksdC5kKGUsIm11bHRpcGx5U2NhbGFyIixmdW5jdGlvbigpe3JldHVybiBXfSksdC5kKGUsIm11bHRpcGx5U2NhbGFyQW5kQWRkIixmdW5jdGlvbigpe3JldHVybiBGfSksdC5kKGUsImV4YWN0RXF1YWxzIixmdW5jdGlvbigpe3JldHVybiBWfSksdC5kKGUsImVxdWFscyIsZnVuY3Rpb24oKXtyZXR1cm4gWH0pLHQuZChlLCJtdWwiLGZ1bmN0aW9uKCl7cmV0dXJuIGp9KSx0LmQoZSwic3ViIixmdW5jdGlvbigpe3JldHVybiB6fSk7dmFyIHI9dCgyKTtmdW5jdGlvbiBuKCl7dmFyIG09bmV3IHIuQVJSQVlfVFlQRSgxNik7cmV0dXJuIHIuQVJSQVlfVFlQRSE9RmxvYXQzMkFycmF5JiYobVsxXT0wLG1bMl09MCxtWzNdPTAsbVs0XT0wLG1bNl09MCxtWzddPTAsbVs4XT0wLG1bOV09MCxtWzExXT0wLG1bMTJdPTAsbVsxM109MCxtWzE0XT0wKSxtWzBdPTEsbVs1XT0xLG1bMTBdPTEsbVsxNV09MSxtfWZ1bmN0aW9uIGQobSl7dmFyIFQ9bmV3IHIuQVJSQVlfVFlQRSgxNik7cmV0dXJuIFRbMF09bVswXSxUWzFdPW1bMV0sVFsyXT1tWzJdLFRbM109bVszXSxUWzRdPW1bNF0sVFs1XT1tWzVdLFRbNl09bVs2XSxUWzddPW1bN10sVFs4XT1tWzhdLFRbOV09bVs5XSxUWzEwXT1tWzEwXSxUWzExXT1tWzExXSxUWzEyXT1tWzEyXSxUWzEzXT1tWzEzXSxUWzE0XT1tWzE0XSxUWzE1XT1tWzE1XSxUfWZ1bmN0aW9uIGcobSxUKXtyZXR1cm4gbVswXT1UWzBdLG1bMV09VFsxXSxtWzJdPVRbMl0sbVszXT1UWzNdLG1bNF09VFs0XSxtWzVdPVRbNV0sbVs2XT1UWzZdLG1bN109VFs3XSxtWzhdPVRbOF0sbVs5XT1UWzldLG1bMTBdPVRbMTBdLG1bMTFdPVRbMTFdLG1bMTJdPVRbMTJdLG1bMTNdPVRbMTNdLG1bMTRdPVRbMTRdLG1bMTVdPVRbMTVdLG19ZnVuY3Rpb24gdShtLFQsTiwkLEssWSxRLGV0LHJ0LG90LGx0LGl0LG50LGF0LGR0LGd0KXt2YXIgdXQ9bmV3IHIuQVJSQVlfVFlQRSgxNik7cmV0dXJuIHV0WzBdPW0sdXRbMV09VCx1dFsyXT1OLHV0WzNdPSQsdXRbNF09Syx1dFs1XT1ZLHV0WzZdPVEsdXRbN109ZXQsdXRbOF09cnQsdXRbOV09b3QsdXRbMTBdPWx0LHV0WzExXT1pdCx1dFsxMl09bnQsdXRbMTNdPWF0LHV0WzE0XT1kdCx1dFsxNV09Z3QsdXR9ZnVuY3Rpb24gbyhtLFQsTiwkLEssWSxRLGV0LHJ0LG90LGx0LGl0LG50LGF0LGR0LGd0LHV0KXtyZXR1cm4gbVswXT1ULG1bMV09TixtWzJdPSQsbVszXT1LLG1bNF09WSxtWzVdPVEsbVs2XT1ldCxtWzddPXJ0LG1bOF09b3QsbVs5XT1sdCxtWzEwXT1pdCxtWzExXT1udCxtWzEyXT1hdCxtWzEzXT1kdCxtWzE0XT1ndCxtWzE1XT11dCxtfWZ1bmN0aW9uIGYobSl7cmV0dXJuIG1bMF09MSxtWzFdPTAsbVsyXT0wLG1bM109MCxtWzRdPTAsbVs1XT0xLG1bNl09MCxtWzddPTAsbVs4XT0wLG1bOV09MCxtWzEwXT0xLG1bMTFdPTAsbVsxMl09MCxtWzEzXT0wLG1bMTRdPTAsbVsxNV09MSxtfWZ1bmN0aW9uIHgobSxUKXtpZihtPT09VCl7dmFyIE49VFsxXSwkPVRbMl0sSz1UWzNdLFk9VFs2XSxRPVRbN10sZXQ9VFsxMV07bVsxXT1UWzRdLG1bMl09VFs4XSxtWzNdPVRbMTJdLG1bNF09TixtWzZdPVRbOV0sbVs3XT1UWzEzXSxtWzhdPSQsbVs5XT1ZLG1bMTFdPVRbMTRdLG1bMTJdPUssbVsxM109USxtWzE0XT1ldH1lbHNlIG1bMF09VFswXSxtWzFdPVRbNF0sbVsyXT1UWzhdLG1bM109VFsxMl0sbVs0XT1UWzFdLG1bNV09VFs1XSxtWzZdPVRbOV0sbVs3XT1UWzEzXSxtWzhdPVRbMl0sbVs5XT1UWzZdLG1bMTBdPVRbMTBdLG1bMTFdPVRbMTRdLG1bMTJdPVRbM10sbVsxM109VFs3XSxtWzE0XT1UWzExXSxtWzE1XT1UWzE1XTtyZXR1cm4gbX1mdW5jdGlvbiBjKG0sVCl7dmFyIE49VFswXSwkPVRbMV0sSz1UWzJdLFk9VFszXSxRPVRbNF0sZXQ9VFs1XSxydD1UWzZdLG90PVRbN10sbHQ9VFs4XSxpdD1UWzldLG50PVRbMTBdLGF0PVRbMTFdLGR0PVRbMTJdLGd0PVRbMTNdLHV0PVRbMTRdLG10PVRbMTVdLFB0PU4qZXQtJCpRLHh0PU4qcnQtSypRLE10PU4qb3QtWSpRLEV0PSQqcnQtSypldCxPdD0kKm90LVkqZXQsVXQ9SypvdC1ZKnJ0LGp0PWx0Kmd0LWl0KmR0LFd0PWx0KnV0LW50KmR0LEZ0PWx0Km10LWF0KmR0LCR0PWl0KnV0LW50Kmd0LHp0PWl0Km10LWF0Kmd0LHd0PW50Km10LWF0KnV0LEN0PVB0Knd0LXh0Knp0K010KiR0K0V0KkZ0LU90Kld0K1V0Kmp0O3JldHVybiBDdD8oQ3Q9MS9DdCxtWzBdPShldCp3dC1ydCp6dCtvdCokdCkqQ3QsbVsxXT0oSyp6dC0kKnd0LVkqJHQpKkN0LG1bMl09KGd0KlV0LXV0Kk90K210KkV0KSpDdCxtWzNdPShudCpPdC1pdCpVdC1hdCpFdCkqQ3QsbVs0XT0ocnQqRnQtUSp3dC1vdCpXdCkqQ3QsbVs1XT0oTip3dC1LKkZ0K1kqV3QpKkN0LG1bNl09KHV0Kk10LWR0KlV0LW10Knh0KSpDdCxtWzddPShsdCpVdC1udCpNdCthdCp4dCkqQ3QsbVs4XT0oUSp6dC1ldCpGdCtvdCpqdCkqQ3QsbVs5XT0oJCpGdC1OKnp0LVkqanQpKkN0LG1bMTBdPShkdCpPdC1ndCpNdCttdCpQdCkqQ3QsbVsxMV09KGl0Kk10LWx0Kk90LWF0KlB0KSpDdCxtWzEyXT0oZXQqV3QtUSokdC1ydCpqdCkqQ3QsbVsxM109KE4qJHQtJCpXdCtLKmp0KSpDdCxtWzE0XT0oZ3QqeHQtZHQqRXQtdXQqUHQpKkN0LG1bMTVdPShsdCpFdC1pdCp4dCtudCpQdCkqQ3QsbSk6bnVsbH1mdW5jdGlvbiB2KG0sVCl7dmFyIE49VFswXSwkPVRbMV0sSz1UWzJdLFk9VFszXSxRPVRbNF0sZXQ9VFs1XSxydD1UWzZdLG90PVRbN10sbHQ9VFs4XSxpdD1UWzldLG50PVRbMTBdLGF0PVRbMTFdLGR0PVRbMTJdLGd0PVRbMTNdLHV0PVRbMTRdLG10PVRbMTVdO3JldHVybiBtWzBdPWV0KihudCptdC1hdCp1dCktaXQqKHJ0Km10LW90KnV0KStndCoocnQqYXQtb3QqbnQpLG1bMV09LSgkKihudCptdC1hdCp1dCktaXQqKEsqbXQtWSp1dCkrZ3QqKEsqYXQtWSpudCkpLG1bMl09JCoocnQqbXQtb3QqdXQpLWV0KihLKm10LVkqdXQpK2d0KihLKm90LVkqcnQpLG1bM109LSgkKihydCphdC1vdCpudCktZXQqKEsqYXQtWSpudCkraXQqKEsqb3QtWSpydCkpLG1bNF09LShRKihudCptdC1hdCp1dCktbHQqKHJ0Km10LW90KnV0KStkdCoocnQqYXQtb3QqbnQpKSxtWzVdPU4qKG50Km10LWF0KnV0KS1sdCooSyptdC1ZKnV0KStkdCooSyphdC1ZKm50KSxtWzZdPS0oTioocnQqbXQtb3QqdXQpLVEqKEsqbXQtWSp1dCkrZHQqKEsqb3QtWSpydCkpLG1bN109TioocnQqYXQtb3QqbnQpLVEqKEsqYXQtWSpudCkrbHQqKEsqb3QtWSpydCksbVs4XT1RKihpdCptdC1hdCpndCktbHQqKGV0Km10LW90Kmd0KStkdCooZXQqYXQtb3QqaXQpLG1bOV09LShOKihpdCptdC1hdCpndCktbHQqKCQqbXQtWSpndCkrZHQqKCQqYXQtWSppdCkpLG1bMTBdPU4qKGV0Km10LW90Kmd0KS1RKigkKm10LVkqZ3QpK2R0KigkKm90LVkqZXQpLG1bMTFdPS0oTiooZXQqYXQtb3QqaXQpLVEqKCQqYXQtWSppdCkrbHQqKCQqb3QtWSpldCkpLG1bMTJdPS0oUSooaXQqdXQtbnQqZ3QpLWx0KihldCp1dC1ydCpndCkrZHQqKGV0Km50LXJ0Kml0KSksbVsxM109TiooaXQqdXQtbnQqZ3QpLWx0KigkKnV0LUsqZ3QpK2R0KigkKm50LUsqaXQpLG1bMTRdPS0oTiooZXQqdXQtcnQqZ3QpLVEqKCQqdXQtSypndCkrZHQqKCQqcnQtSypldCkpLG1bMTVdPU4qKGV0Km50LXJ0Kml0KS1RKigkKm50LUsqaXQpK2x0KigkKnJ0LUsqZXQpLG19ZnVuY3Rpb24gcChtKXt2YXIgVD1tWzBdLE49bVsxXSwkPW1bMl0sSz1tWzNdLFk9bVs0XSxRPW1bNV0sZXQ9bVs2XSxydD1tWzddLG90PW1bOF0sbHQ9bVs5XSxpdD1tWzEwXSxudD1tWzExXSxhdD1tWzEyXSxkdD1tWzEzXSxndD1tWzE0XSx1dD1tWzE1XSxtdD1UKlEtTipZLFB0PVQqZXQtJCpZLHh0PVQqcnQtSypZLE10PU4qZXQtJCpRLEV0PU4qcnQtSypRLE90PSQqcnQtSypldCxVdD1vdCpkdC1sdCphdCxqdD1vdCpndC1pdCphdCxXdD1vdCp1dC1udCphdCxGdD1sdCpndC1pdCpkdCwkdD1sdCp1dC1udCpkdCx6dD1pdCp1dC1udCpndDtyZXR1cm4gbXQqenQtUHQqJHQreHQqRnQrTXQqV3QtRXQqanQrT3QqVXR9ZnVuY3Rpb24gYihtLFQsTil7dmFyICQ9VFswXSxLPVRbMV0sWT1UWzJdLFE9VFszXSxldD1UWzRdLHJ0PVRbNV0sb3Q9VFs2XSxsdD1UWzddLGl0PVRbOF0sbnQ9VFs5XSxhdD1UWzEwXSxkdD1UWzExXSxndD1UWzEyXSx1dD1UWzEzXSxtdD1UWzE0XSxQdD1UWzE1XSx4dD1OWzBdLE10PU5bMV0sRXQ9TlsyXSxPdD1OWzNdO3JldHVybiBtWzBdPXh0KiQrTXQqZXQrRXQqaXQrT3QqZ3QsbVsxXT14dCpLK010KnJ0K0V0Km50K090KnV0LG1bMl09eHQqWStNdCpvdCtFdCphdCtPdCptdCxtWzNdPXh0KlErTXQqbHQrRXQqZHQrT3QqUHQseHQ9Tls0XSxNdD1OWzVdLEV0PU5bNl0sT3Q9Tls3XSxtWzRdPXh0KiQrTXQqZXQrRXQqaXQrT3QqZ3QsbVs1XT14dCpLK010KnJ0K0V0Km50K090KnV0LG1bNl09eHQqWStNdCpvdCtFdCphdCtPdCptdCxtWzddPXh0KlErTXQqbHQrRXQqZHQrT3QqUHQseHQ9Tls4XSxNdD1OWzldLEV0PU5bMTBdLE90PU5bMTFdLG1bOF09eHQqJCtNdCpldCtFdCppdCtPdCpndCxtWzldPXh0KksrTXQqcnQrRXQqbnQrT3QqdXQsbVsxMF09eHQqWStNdCpvdCtFdCphdCtPdCptdCxtWzExXT14dCpRK010Kmx0K0V0KmR0K090KlB0LHh0PU5bMTJdLE10PU5bMTNdLEV0PU5bMTRdLE90PU5bMTVdLG1bMTJdPXh0KiQrTXQqZXQrRXQqaXQrT3QqZ3QsbVsxM109eHQqSytNdCpydCtFdCpudCtPdCp1dCxtWzE0XT14dCpZK010Km90K0V0KmF0K090Km10LG1bMTVdPXh0KlErTXQqbHQrRXQqZHQrT3QqUHQsbX1mdW5jdGlvbiBFKG0sVCxOKXt2YXIgJD1OWzBdLEs9TlsxXSxZPU5bMl0sUSxldCxydCxvdCxsdCxpdCxudCxhdCxkdCxndCx1dCxtdDtyZXR1cm4gVD09PW0/KG1bMTJdPVRbMF0qJCtUWzRdKksrVFs4XSpZK1RbMTJdLG1bMTNdPVRbMV0qJCtUWzVdKksrVFs5XSpZK1RbMTNdLG1bMTRdPVRbMl0qJCtUWzZdKksrVFsxMF0qWStUWzE0XSxtWzE1XT1UWzNdKiQrVFs3XSpLK1RbMTFdKlkrVFsxNV0pOihRPVRbMF0sZXQ9VFsxXSxydD1UWzJdLG90PVRbM10sbHQ9VFs0XSxpdD1UWzVdLG50PVRbNl0sYXQ9VFs3XSxkdD1UWzhdLGd0PVRbOV0sdXQ9VFsxMF0sbXQ9VFsxMV0sbVswXT1RLG1bMV09ZXQsbVsyXT1ydCxtWzNdPW90LG1bNF09bHQsbVs1XT1pdCxtWzZdPW50LG1bN109YXQsbVs4XT1kdCxtWzldPWd0LG1bMTBdPXV0LG1bMTFdPW10LG1bMTJdPVEqJCtsdCpLK2R0KlkrVFsxMl0sbVsxM109ZXQqJCtpdCpLK2d0KlkrVFsxM10sbVsxNF09cnQqJCtudCpLK3V0KlkrVFsxNF0sbVsxNV09b3QqJCthdCpLK210KlkrVFsxNV0pLG19ZnVuY3Rpb24geShtLFQsTil7dmFyICQ9TlswXSxLPU5bMV0sWT1OWzJdO3JldHVybiBtWzBdPVRbMF0qJCxtWzFdPVRbMV0qJCxtWzJdPVRbMl0qJCxtWzNdPVRbM10qJCxtWzRdPVRbNF0qSyxtWzVdPVRbNV0qSyxtWzZdPVRbNl0qSyxtWzddPVRbN10qSyxtWzhdPVRbOF0qWSxtWzldPVRbOV0qWSxtWzEwXT1UWzEwXSpZLG1bMTFdPVRbMTFdKlksbVsxMl09VFsxMl0sbVsxM109VFsxM10sbVsxNF09VFsxNF0sbVsxNV09VFsxNV0sbX1mdW5jdGlvbiBNKG0sVCxOLCQpe3ZhciBLPSRbMF0sWT0kWzFdLFE9JFsyXSxldD1NYXRoLmh5cG90KEssWSxRKSxydCxvdCxsdCxpdCxudCxhdCxkdCxndCx1dCxtdCxQdCx4dCxNdCxFdCxPdCxVdCxqdCxXdCxGdCwkdCx6dCx3dCxDdCxIdDtyZXR1cm4gZXQ8ci5FUFNJTE9OP251bGw6KGV0PTEvZXQsSyo9ZXQsWSo9ZXQsUSo9ZXQscnQ9TWF0aC5zaW4oTiksb3Q9TWF0aC5jb3MoTiksbHQ9MS1vdCxpdD1UWzBdLG50PVRbMV0sYXQ9VFsyXSxkdD1UWzNdLGd0PVRbNF0sdXQ9VFs1XSxtdD1UWzZdLFB0PVRbN10seHQ9VFs4XSxNdD1UWzldLEV0PVRbMTBdLE90PVRbMTFdLFV0PUsqSypsdCtvdCxqdD1ZKksqbHQrUSpydCxXdD1RKksqbHQtWSpydCxGdD1LKlkqbHQtUSpydCwkdD1ZKlkqbHQrb3QsenQ9USpZKmx0K0sqcnQsd3Q9SypRKmx0K1kqcnQsQ3Q9WSpRKmx0LUsqcnQsSHQ9USpRKmx0K290LG1bMF09aXQqVXQrZ3QqanQreHQqV3QsbVsxXT1udCpVdCt1dCpqdCtNdCpXdCxtWzJdPWF0KlV0K210Kmp0K0V0Kld0LG1bM109ZHQqVXQrUHQqanQrT3QqV3QsbVs0XT1pdCpGdCtndCokdCt4dCp6dCxtWzVdPW50KkZ0K3V0KiR0K010Knp0LG1bNl09YXQqRnQrbXQqJHQrRXQqenQsbVs3XT1kdCpGdCtQdCokdCtPdCp6dCxtWzhdPWl0Knd0K2d0KkN0K3h0Kkh0LG1bOV09bnQqd3QrdXQqQ3QrTXQqSHQsbVsxMF09YXQqd3QrbXQqQ3QrRXQqSHQsbVsxMV09ZHQqd3QrUHQqQ3QrT3QqSHQsVCE9PW0mJihtWzEyXT1UWzEyXSxtWzEzXT1UWzEzXSxtWzE0XT1UWzE0XSxtWzE1XT1UWzE1XSksbSl9ZnVuY3Rpb24gaShtLFQsTil7dmFyICQ9TWF0aC5zaW4oTiksSz1NYXRoLmNvcyhOKSxZPVRbNF0sUT1UWzVdLGV0PVRbNl0scnQ9VFs3XSxvdD1UWzhdLGx0PVRbOV0saXQ9VFsxMF0sbnQ9VFsxMV07cmV0dXJuIFQhPT1tJiYobVswXT1UWzBdLG1bMV09VFsxXSxtWzJdPVRbMl0sbVszXT1UWzNdLG1bMTJdPVRbMTJdLG1bMTNdPVRbMTNdLG1bMTRdPVRbMTRdLG1bMTVdPVRbMTVdKSxtWzRdPVkqSytvdCokLG1bNV09USpLK2x0KiQsbVs2XT1ldCpLK2l0KiQsbVs3XT1ydCpLK250KiQsbVs4XT1vdCpLLVkqJCxtWzldPWx0KkstUSokLG1bMTBdPWl0KkstZXQqJCxtWzExXT1udCpLLXJ0KiQsbX1mdW5jdGlvbiBhKG0sVCxOKXt2YXIgJD1NYXRoLnNpbihOKSxLPU1hdGguY29zKE4pLFk9VFswXSxRPVRbMV0sZXQ9VFsyXSxydD1UWzNdLG90PVRbOF0sbHQ9VFs5XSxpdD1UWzEwXSxudD1UWzExXTtyZXR1cm4gVCE9PW0mJihtWzRdPVRbNF0sbVs1XT1UWzVdLG1bNl09VFs2XSxtWzddPVRbN10sbVsxMl09VFsxMl0sbVsxM109VFsxM10sbVsxNF09VFsxNF0sbVsxNV09VFsxNV0pLG1bMF09WSpLLW90KiQsbVsxXT1RKkstbHQqJCxtWzJdPWV0KkstaXQqJCxtWzNdPXJ0KkstbnQqJCxtWzhdPVkqJCtvdCpLLG1bOV09USokK2x0KkssbVsxMF09ZXQqJCtpdCpLLG1bMTFdPXJ0KiQrbnQqSyxtfWZ1bmN0aW9uIHMobSxULE4pe3ZhciAkPU1hdGguc2luKE4pLEs9TWF0aC5jb3MoTiksWT1UWzBdLFE9VFsxXSxldD1UWzJdLHJ0PVRbM10sb3Q9VFs0XSxsdD1UWzVdLGl0PVRbNl0sbnQ9VFs3XTtyZXR1cm4gVCE9PW0mJihtWzhdPVRbOF0sbVs5XT1UWzldLG1bMTBdPVRbMTBdLG1bMTFdPVRbMTFdLG1bMTJdPVRbMTJdLG1bMTNdPVRbMTNdLG1bMTRdPVRbMTRdLG1bMTVdPVRbMTVdKSxtWzBdPVkqSytvdCokLG1bMV09USpLK2x0KiQsbVsyXT1ldCpLK2l0KiQsbVszXT1ydCpLK250KiQsbVs0XT1vdCpLLVkqJCxtWzVdPWx0KkstUSokLG1bNl09aXQqSy1ldCokLG1bN109bnQqSy1ydCokLG19ZnVuY3Rpb24gbChtLFQpe3JldHVybiBtWzBdPTEsbVsxXT0wLG1bMl09MCxtWzNdPTAsbVs0XT0wLG1bNV09MSxtWzZdPTAsbVs3XT0wLG1bOF09MCxtWzldPTAsbVsxMF09MSxtWzExXT0wLG1bMTJdPVRbMF0sbVsxM109VFsxXSxtWzE0XT1UWzJdLG1bMTVdPTEsbX1mdW5jdGlvbiBPKG0sVCl7cmV0dXJuIG1bMF09VFswXSxtWzFdPTAsbVsyXT0wLG1bM109MCxtWzRdPTAsbVs1XT1UWzFdLG1bNl09MCxtWzddPTAsbVs4XT0wLG1bOV09MCxtWzEwXT1UWzJdLG1bMTFdPTAsbVsxMl09MCxtWzEzXT0wLG1bMTRdPTAsbVsxNV09MSxtfWZ1bmN0aW9uIEEobSxULE4pe3ZhciAkPU5bMF0sSz1OWzFdLFk9TlsyXSxRPU1hdGguaHlwb3QoJCxLLFkpLGV0LHJ0LG90O3JldHVybiBRPHIuRVBTSUxPTj9udWxsOihRPTEvUSwkKj1RLEsqPVEsWSo9USxldD1NYXRoLnNpbihUKSxydD1NYXRoLmNvcyhUKSxvdD0xLXJ0LG1bMF09JCokKm90K3J0LG1bMV09SyokKm90K1kqZXQsbVsyXT1ZKiQqb3QtSypldCxtWzNdPTAsbVs0XT0kKksqb3QtWSpldCxtWzVdPUsqSypvdCtydCxtWzZdPVkqSypvdCskKmV0LG1bN109MCxtWzhdPSQqWSpvdCtLKmV0LG1bOV09SypZKm90LSQqZXQsbVsxMF09WSpZKm90K3J0LG1bMTFdPTAsbVsxMl09MCxtWzEzXT0wLG1bMTRdPTAsbVsxNV09MSxtKX1mdW5jdGlvbiBSKG0sVCl7dmFyIE49TWF0aC5zaW4oVCksJD1NYXRoLmNvcyhUKTtyZXR1cm4gbVswXT0xLG1bMV09MCxtWzJdPTAsbVszXT0wLG1bNF09MCxtWzVdPSQsbVs2XT1OLG1bN109MCxtWzhdPTAsbVs5XT0tTixtWzEwXT0kLG1bMTFdPTAsbVsxMl09MCxtWzEzXT0wLG1bMTRdPTAsbVsxNV09MSxtfWZ1bmN0aW9uIEkobSxUKXt2YXIgTj1NYXRoLnNpbihUKSwkPU1hdGguY29zKFQpO3JldHVybiBtWzBdPSQsbVsxXT0wLG1bMl09LU4sbVszXT0wLG1bNF09MCxtWzVdPTEsbVs2XT0wLG1bN109MCxtWzhdPU4sbVs5XT0wLG1bMTBdPSQsbVsxMV09MCxtWzEyXT0wLG1bMTNdPTAsbVsxNF09MCxtWzE1XT0xLG19ZnVuY3Rpb24gUChtLFQpe3ZhciBOPU1hdGguc2luKFQpLCQ9TWF0aC5jb3MoVCk7cmV0dXJuIG1bMF09JCxtWzFdPU4sbVsyXT0wLG1bM109MCxtWzRdPS1OLG1bNV09JCxtWzZdPTAsbVs3XT0wLG1bOF09MCxtWzldPTAsbVsxMF09MSxtWzExXT0wLG1bMTJdPTAsbVsxM109MCxtWzE0XT0wLG1bMTVdPTEsbX1mdW5jdGlvbiBMKG0sVCxOKXt2YXIgJD1UWzBdLEs9VFsxXSxZPVRbMl0sUT1UWzNdLGV0PSQrJCxydD1LK0ssb3Q9WStZLGx0PSQqZXQsaXQ9JCpydCxudD0kKm90LGF0PUsqcnQsZHQ9SypvdCxndD1ZKm90LHV0PVEqZXQsbXQ9USpydCxQdD1RKm90O3JldHVybiBtWzBdPTEtKGF0K2d0KSxtWzFdPWl0K1B0LG1bMl09bnQtbXQsbVszXT0wLG1bNF09aXQtUHQsbVs1XT0xLShsdCtndCksbVs2XT1kdCt1dCxtWzddPTAsbVs4XT1udCttdCxtWzldPWR0LXV0LG1bMTBdPTEtKGx0K2F0KSxtWzExXT0wLG1bMTJdPU5bMF0sbVsxM109TlsxXSxtWzE0XT1OWzJdLG1bMTVdPTEsbX1mdW5jdGlvbiBEKG0sVCl7dmFyIE49bmV3IHIuQVJSQVlfVFlQRSgzKSwkPS1UWzBdLEs9LVRbMV0sWT0tVFsyXSxRPVRbM10sZXQ9VFs0XSxydD1UWzVdLG90PVRbNl0sbHQ9VFs3XSxpdD0kKiQrSypLK1kqWStRKlE7cmV0dXJuIGl0PjA/KE5bMF09KGV0KlErbHQqJCtydCpZLW90KkspKjIvaXQsTlsxXT0ocnQqUStsdCpLK290KiQtZXQqWSkqMi9pdCxOWzJdPShvdCpRK2x0KlkrZXQqSy1ydCokKSoyL2l0KTooTlswXT0oZXQqUStsdCokK3J0Klktb3QqSykqMixOWzFdPShydCpRK2x0Kksrb3QqJC1ldCpZKSoyLE5bMl09KG90KlErbHQqWStldCpLLXJ0KiQpKjIpLEwobSxULE4pLG19ZnVuY3Rpb24gQyhtLFQpe3JldHVybiBtWzBdPVRbMTJdLG1bMV09VFsxM10sbVsyXT1UWzE0XSxtfWZ1bmN0aW9uIFMobSxUKXt2YXIgTj1UWzBdLCQ9VFsxXSxLPVRbMl0sWT1UWzRdLFE9VFs1XSxldD1UWzZdLHJ0PVRbOF0sb3Q9VFs5XSxsdD1UWzEwXTtyZXR1cm4gbVswXT1NYXRoLmh5cG90KE4sJCxLKSxtWzFdPU1hdGguaHlwb3QoWSxRLGV0KSxtWzJdPU1hdGguaHlwb3QocnQsb3QsbHQpLG19ZnVuY3Rpb24gQihtLFQpe3ZhciBOPW5ldyByLkFSUkFZX1RZUEUoMyk7UyhOLFQpO3ZhciAkPTEvTlswXSxLPTEvTlsxXSxZPTEvTlsyXSxRPVRbMF0qJCxldD1UWzFdKksscnQ9VFsyXSpZLG90PVRbNF0qJCxsdD1UWzVdKkssaXQ9VFs2XSpZLG50PVRbOF0qJCxhdD1UWzldKkssZHQ9VFsxMF0qWSxndD1RK2x0K2R0LHV0PTA7cmV0dXJuIGd0PjA/KHV0PU1hdGguc3FydChndCsxKSoyLG1bM109LjI1KnV0LG1bMF09KGl0LWF0KS91dCxtWzFdPShudC1ydCkvdXQsbVsyXT0oZXQtb3QpL3V0KTpRPmx0JiZRPmR0Pyh1dD1NYXRoLnNxcnQoMStRLWx0LWR0KSoyLG1bM109KGl0LWF0KS91dCxtWzBdPS4yNSp1dCxtWzFdPShldCtvdCkvdXQsbVsyXT0obnQrcnQpL3V0KTpsdD5kdD8odXQ9TWF0aC5zcXJ0KDErbHQtUS1kdCkqMixtWzNdPShudC1ydCkvdXQsbVswXT0oZXQrb3QpL3V0LG1bMV09LjI1KnV0LG1bMl09KGl0K2F0KS91dCk6KHV0PU1hdGguc3FydCgxK2R0LVEtbHQpKjIsbVszXT0oZXQtb3QpL3V0LG1bMF09KG50K3J0KS91dCxtWzFdPShpdCthdCkvdXQsbVsyXT0uMjUqdXQpLG19ZnVuY3Rpb24gdyhtLFQsTiwkKXt2YXIgSz1UWzBdLFk9VFsxXSxRPVRbMl0sZXQ9VFszXSxydD1LK0ssb3Q9WStZLGx0PVErUSxpdD1LKnJ0LG50PUsqb3QsYXQ9SypsdCxkdD1ZKm90LGd0PVkqbHQsdXQ9USpsdCxtdD1ldCpydCxQdD1ldCpvdCx4dD1ldCpsdCxNdD0kWzBdLEV0PSRbMV0sT3Q9JFsyXTtyZXR1cm4gbVswXT0oMS0oZHQrdXQpKSpNdCxtWzFdPShudCt4dCkqTXQsbVsyXT0oYXQtUHQpKk10LG1bM109MCxtWzRdPShudC14dCkqRXQsbVs1XT0oMS0oaXQrdXQpKSpFdCxtWzZdPShndCttdCkqRXQsbVs3XT0wLG1bOF09KGF0K1B0KSpPdCxtWzldPShndC1tdCkqT3QsbVsxMF09KDEtKGl0K2R0KSkqT3QsbVsxMV09MCxtWzEyXT1OWzBdLG1bMTNdPU5bMV0sbVsxNF09TlsyXSxtWzE1XT0xLG19ZnVuY3Rpb24gSChtLFQsTiwkLEspe3ZhciBZPVRbMF0sUT1UWzFdLGV0PVRbMl0scnQ9VFszXSxvdD1ZK1ksbHQ9UStRLGl0PWV0K2V0LG50PVkqb3QsYXQ9WSpsdCxkdD1ZKml0LGd0PVEqbHQsdXQ9USppdCxtdD1ldCppdCxQdD1ydCpvdCx4dD1ydCpsdCxNdD1ydCppdCxFdD0kWzBdLE90PSRbMV0sVXQ9JFsyXSxqdD1LWzBdLFd0PUtbMV0sRnQ9S1syXSwkdD0oMS0oZ3QrbXQpKSpFdCx6dD0oYXQrTXQpKkV0LHd0PShkdC14dCkqRXQsQ3Q9KGF0LU10KSpPdCxIdD0oMS0obnQrbXQpKSpPdCxoZT0odXQrUHQpKk90LGRlPShkdCt4dCkqVXQsbm49KHV0LVB0KSpVdCxzbj0oMS0obnQrZ3QpKSpVdDtyZXR1cm4gbVswXT0kdCxtWzFdPXp0LG1bMl09d3QsbVszXT0wLG1bNF09Q3QsbVs1XT1IdCxtWzZdPWhlLG1bN109MCxtWzhdPWRlLG1bOV09bm4sbVsxMF09c24sbVsxMV09MCxtWzEyXT1OWzBdK2p0LSgkdCpqdCtDdCpXdCtkZSpGdCksbVsxM109TlsxXStXdC0oenQqanQrSHQqV3Qrbm4qRnQpLG1bMTRdPU5bMl0rRnQtKHd0Kmp0K2hlKld0K3NuKkZ0KSxtWzE1XT0xLG19ZnVuY3Rpb24gSihtLFQpe3ZhciBOPVRbMF0sJD1UWzFdLEs9VFsyXSxZPVRbM10sUT1OK04sZXQ9JCskLHJ0PUsrSyxvdD1OKlEsbHQ9JCpRLGl0PSQqZXQsbnQ9SypRLGF0PUsqZXQsZHQ9SypydCxndD1ZKlEsdXQ9WSpldCxtdD1ZKnJ0O3JldHVybiBtWzBdPTEtaXQtZHQsbVsxXT1sdCttdCxtWzJdPW50LXV0LG1bM109MCxtWzRdPWx0LW10LG1bNV09MS1vdC1kdCxtWzZdPWF0K2d0LG1bN109MCxtWzhdPW50K3V0LG1bOV09YXQtZ3QsbVsxMF09MS1vdC1pdCxtWzExXT0wLG1bMTJdPTAsbVsxM109MCxtWzE0XT0wLG1bMTVdPTEsbX1mdW5jdGlvbiBxKG0sVCxOLCQsSyxZLFEpe3ZhciBldD0xLyhOLVQpLHJ0PTEvKEstJCksb3Q9MS8oWS1RKTtyZXR1cm4gbVswXT1ZKjIqZXQsbVsxXT0wLG1bMl09MCxtWzNdPTAsbVs0XT0wLG1bNV09WSoyKnJ0LG1bNl09MCxtWzddPTAsbVs4XT0oTitUKSpldCxtWzldPShLKyQpKnJ0LG1bMTBdPShRK1kpKm90LG1bMTFdPS0xLG1bMTJdPTAsbVsxM109MCxtWzE0XT1RKlkqMipvdCxtWzE1XT0wLG19ZnVuY3Rpb24gVShtLFQsTiwkLEspe3ZhciBZPTEvTWF0aC50YW4oVC8yKSxRO3JldHVybiBtWzBdPVkvTixtWzFdPTAsbVsyXT0wLG1bM109MCxtWzRdPTAsbVs1XT1ZLG1bNl09MCxtWzddPTAsbVs4XT0wLG1bOV09MCxtWzExXT0tMSxtWzEyXT0wLG1bMTNdPTAsbVsxNV09MCxLIT1udWxsJiZLIT09MS8wPyhRPTEvKCQtSyksbVsxMF09KEsrJCkqUSxtWzE0XT0yKksqJCpRKToobVsxMF09LTEsbVsxNF09LTIqJCksbX1mdW5jdGlvbiBHKG0sVCxOLCQpe3ZhciBLPU1hdGgudGFuKFQudXBEZWdyZWVzKk1hdGguUEkvMTgwKSxZPU1hdGgudGFuKFQuZG93bkRlZ3JlZXMqTWF0aC5QSS8xODApLFE9TWF0aC50YW4oVC5sZWZ0RGVncmVlcypNYXRoLlBJLzE4MCksZXQ9TWF0aC50YW4oVC5yaWdodERlZ3JlZXMqTWF0aC5QSS8xODApLHJ0PTIvKFErZXQpLG90PTIvKEsrWSk7cmV0dXJuIG1bMF09cnQsbVsxXT0wLG1bMl09MCxtWzNdPTAsbVs0XT0wLG1bNV09b3QsbVs2XT0wLG1bN109MCxtWzhdPS0oKFEtZXQpKnJ0Ki41KSxtWzldPShLLVkpKm90Ki41LG1bMTBdPSQvKE4tJCksbVsxMV09LTEsbVsxMl09MCxtWzEzXT0wLG1bMTRdPSQqTi8oTi0kKSxtWzE1XT0wLG19ZnVuY3Rpb24gWihtLFQsTiwkLEssWSxRKXt2YXIgZXQ9MS8oVC1OKSxydD0xLygkLUspLG90PTEvKFktUSk7cmV0dXJuIG1bMF09LTIqZXQsbVsxXT0wLG1bMl09MCxtWzNdPTAsbVs0XT0wLG1bNV09LTIqcnQsbVs2XT0wLG1bN109MCxtWzhdPTAsbVs5XT0wLG1bMTBdPTIqb3QsbVsxMV09MCxtWzEyXT0oVCtOKSpldCxtWzEzXT0oSyskKSpydCxtWzE0XT0oUStZKSpvdCxtWzE1XT0xLG19ZnVuY3Rpb24gdHQobSxULE4sJCl7dmFyIEssWSxRLGV0LHJ0LG90LGx0LGl0LG50LGF0LGR0PVRbMF0sZ3Q9VFsxXSx1dD1UWzJdLG10PSRbMF0sUHQ9JFsxXSx4dD0kWzJdLE10PU5bMF0sRXQ9TlsxXSxPdD1OWzJdO3JldHVybiBNYXRoLmFicyhkdC1NdCk8ci5FUFNJTE9OJiZNYXRoLmFicyhndC1FdCk8ci5FUFNJTE9OJiZNYXRoLmFicyh1dC1PdCk8ci5FUFNJTE9OP2YobSk6KGx0PWR0LU10LGl0PWd0LUV0LG50PXV0LU90LGF0PTEvTWF0aC5oeXBvdChsdCxpdCxudCksbHQqPWF0LGl0Kj1hdCxudCo9YXQsSz1QdCpudC14dCppdCxZPXh0Kmx0LW10Km50LFE9bXQqaXQtUHQqbHQsYXQ9TWF0aC5oeXBvdChLLFksUSksYXQ/KGF0PTEvYXQsSyo9YXQsWSo9YXQsUSo9YXQpOihLPTAsWT0wLFE9MCksZXQ9aXQqUS1udCpZLHJ0PW50KkstbHQqUSxvdD1sdCpZLWl0KkssYXQ9TWF0aC5oeXBvdChldCxydCxvdCksYXQ/KGF0PTEvYXQsZXQqPWF0LHJ0Kj1hdCxvdCo9YXQpOihldD0wLHJ0PTAsb3Q9MCksbVswXT1LLG1bMV09ZXQsbVsyXT1sdCxtWzNdPTAsbVs0XT1ZLG1bNV09cnQsbVs2XT1pdCxtWzddPTAsbVs4XT1RLG1bOV09b3QsbVsxMF09bnQsbVsxMV09MCxtWzEyXT0tKEsqZHQrWSpndCtRKnV0KSxtWzEzXT0tKGV0KmR0K3J0Kmd0K290KnV0KSxtWzE0XT0tKGx0KmR0K2l0Kmd0K250KnV0KSxtWzE1XT0xLG0pfWZ1bmN0aW9uIF8obSxULE4sJCl7dmFyIEs9VFswXSxZPVRbMV0sUT1UWzJdLGV0PSRbMF0scnQ9JFsxXSxvdD0kWzJdLGx0PUstTlswXSxpdD1ZLU5bMV0sbnQ9US1OWzJdLGF0PWx0Kmx0K2l0Kml0K250Km50O2F0PjAmJihhdD0xL01hdGguc3FydChhdCksbHQqPWF0LGl0Kj1hdCxudCo9YXQpO3ZhciBkdD1ydCpudC1vdCppdCxndD1vdCpsdC1ldCpudCx1dD1ldCppdC1ydCpsdDtyZXR1cm4gYXQ9ZHQqZHQrZ3QqZ3QrdXQqdXQsYXQ+MCYmKGF0PTEvTWF0aC5zcXJ0KGF0KSxkdCo9YXQsZ3QqPWF0LHV0Kj1hdCksbVswXT1kdCxtWzFdPWd0LG1bMl09dXQsbVszXT0wLG1bNF09aXQqdXQtbnQqZ3QsbVs1XT1udCpkdC1sdCp1dCxtWzZdPWx0Kmd0LWl0KmR0LG1bN109MCxtWzhdPWx0LG1bOV09aXQsbVsxMF09bnQsbVsxMV09MCxtWzEyXT1LLG1bMTNdPVksbVsxNF09USxtWzE1XT0xLG19ZnVuY3Rpb24gc3QobSl7cmV0dXJuIm1hdDQoIittWzBdKyIsICIrbVsxXSsiLCAiK21bMl0rIiwgIittWzNdKyIsICIrbVs0XSsiLCAiK21bNV0rIiwgIittWzZdKyIsICIrbVs3XSsiLCAiK21bOF0rIiwgIittWzldKyIsICIrbVsxMF0rIiwgIittWzExXSsiLCAiK21bMTJdKyIsICIrbVsxM10rIiwgIittWzE0XSsiLCAiK21bMTVdKyIpIn1mdW5jdGlvbiBrKG0pe3JldHVybiBNYXRoLmh5cG90KG1bMF0sbVsxXSxtWzJdLG1bM10sbVs0XSxtWzVdLG1bNl0sbVs3XSxtWzhdLG1bOV0sbVsxMF0sbVsxMV0sbVsxMl0sbVsxM10sbVsxNF0sbVsxNV0pfWZ1bmN0aW9uIGh0KG0sVCxOKXtyZXR1cm4gbVswXT1UWzBdK05bMF0sbVsxXT1UWzFdK05bMV0sbVsyXT1UWzJdK05bMl0sbVszXT1UWzNdK05bM10sbVs0XT1UWzRdK05bNF0sbVs1XT1UWzVdK05bNV0sbVs2XT1UWzZdK05bNl0sbVs3XT1UWzddK05bN10sbVs4XT1UWzhdK05bOF0sbVs5XT1UWzldK05bOV0sbVsxMF09VFsxMF0rTlsxMF0sbVsxMV09VFsxMV0rTlsxMV0sbVsxMl09VFsxMl0rTlsxMl0sbVsxM109VFsxM10rTlsxM10sbVsxNF09VFsxNF0rTlsxNF0sbVsxNV09VFsxNV0rTlsxNV0sbX1mdW5jdGlvbiBmdChtLFQsTil7cmV0dXJuIG1bMF09VFswXS1OWzBdLG1bMV09VFsxXS1OWzFdLG1bMl09VFsyXS1OWzJdLG1bM109VFszXS1OWzNdLG1bNF09VFs0XS1OWzRdLG1bNV09VFs1XS1OWzVdLG1bNl09VFs2XS1OWzZdLG1bN109VFs3XS1OWzddLG1bOF09VFs4XS1OWzhdLG1bOV09VFs5XS1OWzldLG1bMTBdPVRbMTBdLU5bMTBdLG1bMTFdPVRbMTFdLU5bMTFdLG1bMTJdPVRbMTJdLU5bMTJdLG1bMTNdPVRbMTNdLU5bMTNdLG1bMTRdPVRbMTRdLU5bMTRdLG1bMTVdPVRbMTVdLU5bMTVdLG19ZnVuY3Rpb24gVyhtLFQsTil7cmV0dXJuIG1bMF09VFswXSpOLG1bMV09VFsxXSpOLG1bMl09VFsyXSpOLG1bM109VFszXSpOLG1bNF09VFs0XSpOLG1bNV09VFs1XSpOLG1bNl09VFs2XSpOLG1bN109VFs3XSpOLG1bOF09VFs4XSpOLG1bOV09VFs5XSpOLG1bMTBdPVRbMTBdKk4sbVsxMV09VFsxMV0qTixtWzEyXT1UWzEyXSpOLG1bMTNdPVRbMTNdKk4sbVsxNF09VFsxNF0qTixtWzE1XT1UWzE1XSpOLG19ZnVuY3Rpb24gRihtLFQsTiwkKXtyZXR1cm4gbVswXT1UWzBdK05bMF0qJCxtWzFdPVRbMV0rTlsxXSokLG1bMl09VFsyXStOWzJdKiQsbVszXT1UWzNdK05bM10qJCxtWzRdPVRbNF0rTls0XSokLG1bNV09VFs1XStOWzVdKiQsbVs2XT1UWzZdK05bNl0qJCxtWzddPVRbN10rTls3XSokLG1bOF09VFs4XStOWzhdKiQsbVs5XT1UWzldK05bOV0qJCxtWzEwXT1UWzEwXStOWzEwXSokLG1bMTFdPVRbMTFdK05bMTFdKiQsbVsxMl09VFsxMl0rTlsxMl0qJCxtWzEzXT1UWzEzXStOWzEzXSokLG1bMTRdPVRbMTRdK05bMTRdKiQsbVsxNV09VFsxNV0rTlsxNV0qJCxtfWZ1bmN0aW9uIFYobSxUKXtyZXR1cm4gbVswXT09PVRbMF0mJm1bMV09PT1UWzFdJiZtWzJdPT09VFsyXSYmbVszXT09PVRbM10mJm1bNF09PT1UWzRdJiZtWzVdPT09VFs1XSYmbVs2XT09PVRbNl0mJm1bN109PT1UWzddJiZtWzhdPT09VFs4XSYmbVs5XT09PVRbOV0mJm1bMTBdPT09VFsxMF0mJm1bMTFdPT09VFsxMV0mJm1bMTJdPT09VFsxMl0mJm1bMTNdPT09VFsxM10mJm1bMTRdPT09VFsxNF0mJm1bMTVdPT09VFsxNV19ZnVuY3Rpb24gWChtLFQpe3ZhciBOPW1bMF0sJD1tWzFdLEs9bVsyXSxZPW1bM10sUT1tWzRdLGV0PW1bNV0scnQ9bVs2XSxvdD1tWzddLGx0PW1bOF0saXQ9bVs5XSxudD1tWzEwXSxhdD1tWzExXSxkdD1tWzEyXSxndD1tWzEzXSx1dD1tWzE0XSxtdD1tWzE1XSxQdD1UWzBdLHh0PVRbMV0sTXQ9VFsyXSxFdD1UWzNdLE90PVRbNF0sVXQ9VFs1XSxqdD1UWzZdLFd0PVRbN10sRnQ9VFs4XSwkdD1UWzldLHp0PVRbMTBdLHd0PVRbMTFdLEN0PVRbMTJdLEh0PVRbMTNdLGhlPVRbMTRdLGRlPVRbMTVdO3JldHVybiBNYXRoLmFicyhOLVB0KTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoTiksTWF0aC5hYnMoUHQpKSYmTWF0aC5hYnMoJC14dCk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKCQpLE1hdGguYWJzKHh0KSkmJk1hdGguYWJzKEstTXQpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhLKSxNYXRoLmFicyhNdCkpJiZNYXRoLmFicyhZLUV0KTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoWSksTWF0aC5hYnMoRXQpKSYmTWF0aC5hYnMoUS1PdCk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKFEpLE1hdGguYWJzKE90KSkmJk1hdGguYWJzKGV0LVV0KTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoZXQpLE1hdGguYWJzKFV0KSkmJk1hdGguYWJzKHJ0LWp0KTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMocnQpLE1hdGguYWJzKGp0KSkmJk1hdGguYWJzKG90LVd0KTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMob3QpLE1hdGguYWJzKFd0KSkmJk1hdGguYWJzKGx0LUZ0KTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMobHQpLE1hdGguYWJzKEZ0KSkmJk1hdGguYWJzKGl0LSR0KTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoaXQpLE1hdGguYWJzKCR0KSkmJk1hdGguYWJzKG50LXp0KTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMobnQpLE1hdGguYWJzKHp0KSkmJk1hdGguYWJzKGF0LXd0KTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoYXQpLE1hdGguYWJzKHd0KSkmJk1hdGguYWJzKGR0LUN0KTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoZHQpLE1hdGguYWJzKEN0KSkmJk1hdGguYWJzKGd0LUh0KTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoZ3QpLE1hdGguYWJzKEh0KSkmJk1hdGguYWJzKHV0LWhlKTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnModXQpLE1hdGguYWJzKGhlKSkmJk1hdGguYWJzKG10LWRlKTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMobXQpLE1hdGguYWJzKGRlKSl9dmFyIGo9Yix6PWZ0fSxmdW5jdGlvbihoLGUsdCl7dC5yKGUpLHQuZChlLCJjcmVhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIHV9KSx0LmQoZSwiaWRlbnRpdHkiLGZ1bmN0aW9uKCl7cmV0dXJuIG99KSx0LmQoZSwic2V0QXhpc0FuZ2xlIixmdW5jdGlvbigpe3JldHVybiBmfSksdC5kKGUsImdldEF4aXNBbmdsZSIsZnVuY3Rpb24oKXtyZXR1cm4geH0pLHQuZChlLCJnZXRBbmdsZSIsZnVuY3Rpb24oKXtyZXR1cm4gY30pLHQuZChlLCJtdWx0aXBseSIsZnVuY3Rpb24oKXtyZXR1cm4gdn0pLHQuZChlLCJyb3RhdGVYIixmdW5jdGlvbigpe3JldHVybiBwfSksdC5kKGUsInJvdGF0ZVkiLGZ1bmN0aW9uKCl7cmV0dXJuIGJ9KSx0LmQoZSwicm90YXRlWiIsZnVuY3Rpb24oKXtyZXR1cm4gRX0pLHQuZChlLCJjYWxjdWxhdGVXIixmdW5jdGlvbigpe3JldHVybiB5fSksdC5kKGUsImV4cCIsZnVuY3Rpb24oKXtyZXR1cm4gTX0pLHQuZChlLCJsbiIsZnVuY3Rpb24oKXtyZXR1cm4gaX0pLHQuZChlLCJwb3ciLGZ1bmN0aW9uKCl7cmV0dXJuIGF9KSx0LmQoZSwic2xlcnAiLGZ1bmN0aW9uKCl7cmV0dXJuIHN9KSx0LmQoZSwicmFuZG9tIixmdW5jdGlvbigpe3JldHVybiBsfSksdC5kKGUsImludmVydCIsZnVuY3Rpb24oKXtyZXR1cm4gT30pLHQuZChlLCJjb25qdWdhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIEF9KSx0LmQoZSwiZnJvbU1hdDMiLGZ1bmN0aW9uKCl7cmV0dXJuIFJ9KSx0LmQoZSwiZnJvbUV1bGVyIixmdW5jdGlvbigpe3JldHVybiBJfSksdC5kKGUsInN0ciIsZnVuY3Rpb24oKXtyZXR1cm4gUH0pLHQuZChlLCJjbG9uZSIsZnVuY3Rpb24oKXtyZXR1cm4gTH0pLHQuZChlLCJmcm9tVmFsdWVzIixmdW5jdGlvbigpe3JldHVybiBEfSksdC5kKGUsImNvcHkiLGZ1bmN0aW9uKCl7cmV0dXJuIEN9KSx0LmQoZSwic2V0IixmdW5jdGlvbigpe3JldHVybiBTfSksdC5kKGUsImFkZCIsZnVuY3Rpb24oKXtyZXR1cm4gQn0pLHQuZChlLCJtdWwiLGZ1bmN0aW9uKCl7cmV0dXJuIHd9KSx0LmQoZSwic2NhbGUiLGZ1bmN0aW9uKCl7cmV0dXJuIEh9KSx0LmQoZSwiZG90IixmdW5jdGlvbigpe3JldHVybiBKfSksdC5kKGUsImxlcnAiLGZ1bmN0aW9uKCl7cmV0dXJuIHF9KSx0LmQoZSwibGVuZ3RoIixmdW5jdGlvbigpe3JldHVybiBVfSksdC5kKGUsImxlbiIsZnVuY3Rpb24oKXtyZXR1cm4gR30pLHQuZChlLCJzcXVhcmVkTGVuZ3RoIixmdW5jdGlvbigpe3JldHVybiBafSksdC5kKGUsInNxckxlbiIsZnVuY3Rpb24oKXtyZXR1cm4gdHR9KSx0LmQoZSwibm9ybWFsaXplIixmdW5jdGlvbigpe3JldHVybiBffSksdC5kKGUsImV4YWN0RXF1YWxzIixmdW5jdGlvbigpe3JldHVybiBzdH0pLHQuZChlLCJlcXVhbHMiLGZ1bmN0aW9uKCl7cmV0dXJuIGt9KSx0LmQoZSwicm90YXRpb25UbyIsZnVuY3Rpb24oKXtyZXR1cm4gaHR9KSx0LmQoZSwic3FsZXJwIixmdW5jdGlvbigpe3JldHVybiBmdH0pLHQuZChlLCJzZXRBeGVzIixmdW5jdGlvbigpe3JldHVybiBXfSk7dmFyIHI9dCgyKSxuPXQoNSksZD10KDgpLGc9dCg5KTtmdW5jdGlvbiB1KCl7dmFyIEY9bmV3IHIuQVJSQVlfVFlQRSg0KTtyZXR1cm4gci5BUlJBWV9UWVBFIT1GbG9hdDMyQXJyYXkmJihGWzBdPTAsRlsxXT0wLEZbMl09MCksRlszXT0xLEZ9ZnVuY3Rpb24gbyhGKXtyZXR1cm4gRlswXT0wLEZbMV09MCxGWzJdPTAsRlszXT0xLEZ9ZnVuY3Rpb24gZihGLFYsWCl7WD1YKi41O3ZhciBqPU1hdGguc2luKFgpO3JldHVybiBGWzBdPWoqVlswXSxGWzFdPWoqVlsxXSxGWzJdPWoqVlsyXSxGWzNdPU1hdGguY29zKFgpLEZ9ZnVuY3Rpb24geChGLFYpe3ZhciBYPU1hdGguYWNvcyhWWzNdKSoyLGo9TWF0aC5zaW4oWC8yKTtyZXR1cm4gaj5yLkVQU0lMT04/KEZbMF09VlswXS9qLEZbMV09VlsxXS9qLEZbMl09VlsyXS9qKTooRlswXT0xLEZbMV09MCxGWzJdPTApLFh9ZnVuY3Rpb24gYyhGLFYpe3ZhciBYPUooRixWKTtyZXR1cm4gTWF0aC5hY29zKDIqWCpYLTEpfWZ1bmN0aW9uIHYoRixWLFgpe3ZhciBqPVZbMF0sej1WWzFdLG09VlsyXSxUPVZbM10sTj1YWzBdLCQ9WFsxXSxLPVhbMl0sWT1YWzNdO3JldHVybiBGWzBdPWoqWStUKk4reipLLW0qJCxGWzFdPXoqWStUKiQrbSpOLWoqSyxGWzJdPW0qWStUKksraiokLXoqTixGWzNdPVQqWS1qKk4teiokLW0qSyxGfWZ1bmN0aW9uIHAoRixWLFgpe1gqPS41O3ZhciBqPVZbMF0sej1WWzFdLG09VlsyXSxUPVZbM10sTj1NYXRoLnNpbihYKSwkPU1hdGguY29zKFgpO3JldHVybiBGWzBdPWoqJCtUKk4sRlsxXT16KiQrbSpOLEZbMl09bSokLXoqTixGWzNdPVQqJC1qKk4sRn1mdW5jdGlvbiBiKEYsVixYKXtYKj0uNTt2YXIgaj1WWzBdLHo9VlsxXSxtPVZbMl0sVD1WWzNdLE49TWF0aC5zaW4oWCksJD1NYXRoLmNvcyhYKTtyZXR1cm4gRlswXT1qKiQtbSpOLEZbMV09eiokK1QqTixGWzJdPW0qJCtqKk4sRlszXT1UKiQteipOLEZ9ZnVuY3Rpb24gRShGLFYsWCl7WCo9LjU7dmFyIGo9VlswXSx6PVZbMV0sbT1WWzJdLFQ9VlszXSxOPU1hdGguc2luKFgpLCQ9TWF0aC5jb3MoWCk7cmV0dXJuIEZbMF09aiokK3oqTixGWzFdPXoqJC1qKk4sRlsyXT1tKiQrVCpOLEZbM109VCokLW0qTixGfWZ1bmN0aW9uIHkoRixWKXt2YXIgWD1WWzBdLGo9VlsxXSx6PVZbMl07cmV0dXJuIEZbMF09WCxGWzFdPWosRlsyXT16LEZbM109TWF0aC5zcXJ0KE1hdGguYWJzKDEtWCpYLWoqai16KnopKSxGfWZ1bmN0aW9uIE0oRixWKXt2YXIgWD1WWzBdLGo9VlsxXSx6PVZbMl0sbT1WWzNdLFQ9TWF0aC5zcXJ0KFgqWCtqKmoreip6KSxOPU1hdGguZXhwKG0pLCQ9VD4wP04qTWF0aC5zaW4oVCkvVDowO3JldHVybiBGWzBdPVgqJCxGWzFdPWoqJCxGWzJdPXoqJCxGWzNdPU4qTWF0aC5jb3MoVCksRn1mdW5jdGlvbiBpKEYsVil7dmFyIFg9VlswXSxqPVZbMV0sej1WWzJdLG09VlszXSxUPU1hdGguc3FydChYKlgraipqK3oqeiksTj1UPjA/TWF0aC5hdGFuMihULG0pL1Q6MDtyZXR1cm4gRlswXT1YKk4sRlsxXT1qKk4sRlsyXT16Kk4sRlszXT0uNSpNYXRoLmxvZyhYKlgraipqK3oqeittKm0pLEZ9ZnVuY3Rpb24gYShGLFYsWCl7cmV0dXJuIGkoRixWKSxIKEYsRixYKSxNKEYsRiksRn1mdW5jdGlvbiBzKEYsVixYLGope3ZhciB6PVZbMF0sbT1WWzFdLFQ9VlsyXSxOPVZbM10sJD1YWzBdLEs9WFsxXSxZPVhbMl0sUT1YWzNdLGV0LHJ0LG90LGx0LGl0O3JldHVybiBydD16KiQrbSpLK1QqWStOKlEscnQ8MCYmKHJ0PS1ydCwkPS0kLEs9LUssWT0tWSxRPS1RKSwxLXJ0PnIuRVBTSUxPTj8oZXQ9TWF0aC5hY29zKHJ0KSxvdD1NYXRoLnNpbihldCksbHQ9TWF0aC5zaW4oKDEtaikqZXQpL290LGl0PU1hdGguc2luKGoqZXQpL290KToobHQ9MS1qLGl0PWopLEZbMF09bHQqeitpdCokLEZbMV09bHQqbStpdCpLLEZbMl09bHQqVCtpdCpZLEZbM109bHQqTitpdCpRLEZ9ZnVuY3Rpb24gbChGKXt2YXIgVj1yLlJBTkRPTSgpLFg9ci5SQU5ET00oKSxqPXIuUkFORE9NKCksej1NYXRoLnNxcnQoMS1WKSxtPU1hdGguc3FydChWKTtyZXR1cm4gRlswXT16Kk1hdGguc2luKDIqTWF0aC5QSSpYKSxGWzFdPXoqTWF0aC5jb3MoMipNYXRoLlBJKlgpLEZbMl09bSpNYXRoLnNpbigyKk1hdGguUEkqaiksRlszXT1tKk1hdGguY29zKDIqTWF0aC5QSSpqKSxGfWZ1bmN0aW9uIE8oRixWKXt2YXIgWD1WWzBdLGo9VlsxXSx6PVZbMl0sbT1WWzNdLFQ9WCpYK2oqait6KnorbSptLE49VD8xL1Q6MDtyZXR1cm4gRlswXT0tWCpOLEZbMV09LWoqTixGWzJdPS16Kk4sRlszXT1tKk4sRn1mdW5jdGlvbiBBKEYsVil7cmV0dXJuIEZbMF09LVZbMF0sRlsxXT0tVlsxXSxGWzJdPS1WWzJdLEZbM109VlszXSxGfWZ1bmN0aW9uIFIoRixWKXt2YXIgWD1WWzBdK1ZbNF0rVls4XSxqO2lmKFg+MClqPU1hdGguc3FydChYKzEpLEZbM109LjUqaixqPS41L2osRlswXT0oVls1XS1WWzddKSpqLEZbMV09KFZbNl0tVlsyXSkqaixGWzJdPShWWzFdLVZbM10pKmo7ZWxzZXt2YXIgej0wO1ZbNF0+VlswXSYmKHo9MSksVls4XT5WW3oqMyt6XSYmKHo9Mik7dmFyIG09KHorMSklMyxUPSh6KzIpJTM7aj1NYXRoLnNxcnQoVlt6KjMrel0tVlttKjMrbV0tVltUKjMrVF0rMSksRlt6XT0uNSpqLGo9LjUvaixGWzNdPShWW20qMytUXS1WW1QqMyttXSkqaixGW21dPShWW20qMyt6XStWW3oqMyttXSkqaixGW1RdPShWW1QqMyt6XStWW3oqMytUXSkqan1yZXR1cm4gRn1mdW5jdGlvbiBJKEYsVixYLGope3ZhciB6PS41Kk1hdGguUEkvMTgwO1YqPXosWCo9eixqKj16O3ZhciBtPU1hdGguc2luKFYpLFQ9TWF0aC5jb3MoViksTj1NYXRoLnNpbihYKSwkPU1hdGguY29zKFgpLEs9TWF0aC5zaW4oaiksWT1NYXRoLmNvcyhqKTtyZXR1cm4gRlswXT1tKiQqWS1UKk4qSyxGWzFdPVQqTipZK20qJCpLLEZbMl09VCokKkstbSpOKlksRlszXT1UKiQqWSttKk4qSyxGfWZ1bmN0aW9uIFAoRil7cmV0dXJuInF1YXQoIitGWzBdKyIsICIrRlsxXSsiLCAiK0ZbMl0rIiwgIitGWzNdKyIpIn12YXIgTD1nLmNsb25lLEQ9Zy5mcm9tVmFsdWVzLEM9Zy5jb3B5LFM9Zy5zZXQsQj1nLmFkZCx3PXYsSD1nLnNjYWxlLEo9Zy5kb3QscT1nLmxlcnAsVT1nLmxlbmd0aCxHPVUsWj1nLnNxdWFyZWRMZW5ndGgsdHQ9WixfPWcubm9ybWFsaXplLHN0PWcuZXhhY3RFcXVhbHMsaz1nLmVxdWFscyxodD1mdW5jdGlvbigpe3ZhciBGPWQuY3JlYXRlKCksVj1kLmZyb21WYWx1ZXMoMSwwLDApLFg9ZC5mcm9tVmFsdWVzKDAsMSwwKTtyZXR1cm4gZnVuY3Rpb24oaix6LG0pe3ZhciBUPWQuZG90KHosbSk7cmV0dXJuIFQ8LS45OTk5OTk/KGQuY3Jvc3MoRixWLHopLGQubGVuKEYpPDFlLTYmJmQuY3Jvc3MoRixYLHopLGQubm9ybWFsaXplKEYsRiksZihqLEYsTWF0aC5QSSksaik6VD4uOTk5OTk5PyhqWzBdPTAsalsxXT0wLGpbMl09MCxqWzNdPTEsaik6KGQuY3Jvc3MoRix6LG0pLGpbMF09RlswXSxqWzFdPUZbMV0salsyXT1GWzJdLGpbM109MStULF8oaixqKSl9fSgpLGZ0PWZ1bmN0aW9uKCl7dmFyIEY9dSgpLFY9dSgpO3JldHVybiBmdW5jdGlvbihYLGoseixtLFQsTil7cmV0dXJuIHMoRixqLFQsTikscyhWLHosbSxOKSxzKFgsRixWLDIqTiooMS1OKSksWH19KCksVz1mdW5jdGlvbigpe3ZhciBGPW4uY3JlYXRlKCk7cmV0dXJuIGZ1bmN0aW9uKFYsWCxqLHope3JldHVybiBGWzBdPWpbMF0sRlszXT1qWzFdLEZbNl09alsyXSxGWzFdPXpbMF0sRls0XT16WzFdLEZbN109elsyXSxGWzJdPS1YWzBdLEZbNV09LVhbMV0sRls4XT0tWFsyXSxfKFYsUihWLEYpKX19KCl9LGZ1bmN0aW9uKGgsZSx0KXt0LnIoZSksdC5kKGUsImNyZWF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gbn0pLHQuZChlLCJjbG9uZSIsZnVuY3Rpb24oKXtyZXR1cm4gZH0pLHQuZChlLCJsZW5ndGgiLGZ1bmN0aW9uKCl7cmV0dXJuIGd9KSx0LmQoZSwiZnJvbVZhbHVlcyIsZnVuY3Rpb24oKXtyZXR1cm4gdX0pLHQuZChlLCJjb3B5IixmdW5jdGlvbigpe3JldHVybiBvfSksdC5kKGUsInNldCIsZnVuY3Rpb24oKXtyZXR1cm4gZn0pLHQuZChlLCJhZGQiLGZ1bmN0aW9uKCl7cmV0dXJuIHh9KSx0LmQoZSwic3VidHJhY3QiLGZ1bmN0aW9uKCl7cmV0dXJuIGN9KSx0LmQoZSwibXVsdGlwbHkiLGZ1bmN0aW9uKCl7cmV0dXJuIHZ9KSx0LmQoZSwiZGl2aWRlIixmdW5jdGlvbigpe3JldHVybiBwfSksdC5kKGUsImNlaWwiLGZ1bmN0aW9uKCl7cmV0dXJuIGJ9KSx0LmQoZSwiZmxvb3IiLGZ1bmN0aW9uKCl7cmV0dXJuIEV9KSx0LmQoZSwibWluIixmdW5jdGlvbigpe3JldHVybiB5fSksdC5kKGUsIm1heCIsZnVuY3Rpb24oKXtyZXR1cm4gTX0pLHQuZChlLCJyb3VuZCIsZnVuY3Rpb24oKXtyZXR1cm4gaX0pLHQuZChlLCJzY2FsZSIsZnVuY3Rpb24oKXtyZXR1cm4gYX0pLHQuZChlLCJzY2FsZUFuZEFkZCIsZnVuY3Rpb24oKXtyZXR1cm4gc30pLHQuZChlLCJkaXN0YW5jZSIsZnVuY3Rpb24oKXtyZXR1cm4gbH0pLHQuZChlLCJzcXVhcmVkRGlzdGFuY2UiLGZ1bmN0aW9uKCl7cmV0dXJuIE99KSx0LmQoZSwic3F1YXJlZExlbmd0aCIsZnVuY3Rpb24oKXtyZXR1cm4gQX0pLHQuZChlLCJuZWdhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIFJ9KSx0LmQoZSwiaW52ZXJzZSIsZnVuY3Rpb24oKXtyZXR1cm4gSX0pLHQuZChlLCJub3JtYWxpemUiLGZ1bmN0aW9uKCl7cmV0dXJuIFB9KSx0LmQoZSwiZG90IixmdW5jdGlvbigpe3JldHVybiBMfSksdC5kKGUsImNyb3NzIixmdW5jdGlvbigpe3JldHVybiBEfSksdC5kKGUsImxlcnAiLGZ1bmN0aW9uKCl7cmV0dXJuIEN9KSx0LmQoZSwiaGVybWl0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gU30pLHQuZChlLCJiZXppZXIiLGZ1bmN0aW9uKCl7cmV0dXJuIEJ9KSx0LmQoZSwicmFuZG9tIixmdW5jdGlvbigpe3JldHVybiB3fSksdC5kKGUsInRyYW5zZm9ybU1hdDQiLGZ1bmN0aW9uKCl7cmV0dXJuIEh9KSx0LmQoZSwidHJhbnNmb3JtTWF0MyIsZnVuY3Rpb24oKXtyZXR1cm4gSn0pLHQuZChlLCJ0cmFuc2Zvcm1RdWF0IixmdW5jdGlvbigpe3JldHVybiBxfSksdC5kKGUsInJvdGF0ZVgiLGZ1bmN0aW9uKCl7cmV0dXJuIFV9KSx0LmQoZSwicm90YXRlWSIsZnVuY3Rpb24oKXtyZXR1cm4gR30pLHQuZChlLCJyb3RhdGVaIixmdW5jdGlvbigpe3JldHVybiBafSksdC5kKGUsImFuZ2xlIixmdW5jdGlvbigpe3JldHVybiB0dH0pLHQuZChlLCJ6ZXJvIixmdW5jdGlvbigpe3JldHVybiBffSksdC5kKGUsInN0ciIsZnVuY3Rpb24oKXtyZXR1cm4gc3R9KSx0LmQoZSwiZXhhY3RFcXVhbHMiLGZ1bmN0aW9uKCl7cmV0dXJuIGt9KSx0LmQoZSwiZXF1YWxzIixmdW5jdGlvbigpe3JldHVybiBodH0pLHQuZChlLCJzdWIiLGZ1bmN0aW9uKCl7cmV0dXJuIGZ0fSksdC5kKGUsIm11bCIsZnVuY3Rpb24oKXtyZXR1cm4gV30pLHQuZChlLCJkaXYiLGZ1bmN0aW9uKCl7cmV0dXJuIEZ9KSx0LmQoZSwiZGlzdCIsZnVuY3Rpb24oKXtyZXR1cm4gVn0pLHQuZChlLCJzcXJEaXN0IixmdW5jdGlvbigpe3JldHVybiBYfSksdC5kKGUsImxlbiIsZnVuY3Rpb24oKXtyZXR1cm4gan0pLHQuZChlLCJzcXJMZW4iLGZ1bmN0aW9uKCl7cmV0dXJuIHp9KSx0LmQoZSwiZm9yRWFjaCIsZnVuY3Rpb24oKXtyZXR1cm4gbX0pO3ZhciByPXQoMik7ZnVuY3Rpb24gbigpe3ZhciBUPW5ldyByLkFSUkFZX1RZUEUoMyk7cmV0dXJuIHIuQVJSQVlfVFlQRSE9RmxvYXQzMkFycmF5JiYoVFswXT0wLFRbMV09MCxUWzJdPTApLFR9ZnVuY3Rpb24gZChUKXt2YXIgTj1uZXcgci5BUlJBWV9UWVBFKDMpO3JldHVybiBOWzBdPVRbMF0sTlsxXT1UWzFdLE5bMl09VFsyXSxOfWZ1bmN0aW9uIGcoVCl7dmFyIE49VFswXSwkPVRbMV0sSz1UWzJdO3JldHVybiBNYXRoLmh5cG90KE4sJCxLKX1mdW5jdGlvbiB1KFQsTiwkKXt2YXIgSz1uZXcgci5BUlJBWV9UWVBFKDMpO3JldHVybiBLWzBdPVQsS1sxXT1OLEtbMl09JCxLfWZ1bmN0aW9uIG8oVCxOKXtyZXR1cm4gVFswXT1OWzBdLFRbMV09TlsxXSxUWzJdPU5bMl0sVH1mdW5jdGlvbiBmKFQsTiwkLEspe3JldHVybiBUWzBdPU4sVFsxXT0kLFRbMl09SyxUfWZ1bmN0aW9uIHgoVCxOLCQpe3JldHVybiBUWzBdPU5bMF0rJFswXSxUWzFdPU5bMV0rJFsxXSxUWzJdPU5bMl0rJFsyXSxUfWZ1bmN0aW9uIGMoVCxOLCQpe3JldHVybiBUWzBdPU5bMF0tJFswXSxUWzFdPU5bMV0tJFsxXSxUWzJdPU5bMl0tJFsyXSxUfWZ1bmN0aW9uIHYoVCxOLCQpe3JldHVybiBUWzBdPU5bMF0qJFswXSxUWzFdPU5bMV0qJFsxXSxUWzJdPU5bMl0qJFsyXSxUfWZ1bmN0aW9uIHAoVCxOLCQpe3JldHVybiBUWzBdPU5bMF0vJFswXSxUWzFdPU5bMV0vJFsxXSxUWzJdPU5bMl0vJFsyXSxUfWZ1bmN0aW9uIGIoVCxOKXtyZXR1cm4gVFswXT1NYXRoLmNlaWwoTlswXSksVFsxXT1NYXRoLmNlaWwoTlsxXSksVFsyXT1NYXRoLmNlaWwoTlsyXSksVH1mdW5jdGlvbiBFKFQsTil7cmV0dXJuIFRbMF09TWF0aC5mbG9vcihOWzBdKSxUWzFdPU1hdGguZmxvb3IoTlsxXSksVFsyXT1NYXRoLmZsb29yKE5bMl0pLFR9ZnVuY3Rpb24geShULE4sJCl7cmV0dXJuIFRbMF09TWF0aC5taW4oTlswXSwkWzBdKSxUWzFdPU1hdGgubWluKE5bMV0sJFsxXSksVFsyXT1NYXRoLm1pbihOWzJdLCRbMl0pLFR9ZnVuY3Rpb24gTShULE4sJCl7cmV0dXJuIFRbMF09TWF0aC5tYXgoTlswXSwkWzBdKSxUWzFdPU1hdGgubWF4KE5bMV0sJFsxXSksVFsyXT1NYXRoLm1heChOWzJdLCRbMl0pLFR9ZnVuY3Rpb24gaShULE4pe3JldHVybiBUWzBdPU1hdGgucm91bmQoTlswXSksVFsxXT1NYXRoLnJvdW5kKE5bMV0pLFRbMl09TWF0aC5yb3VuZChOWzJdKSxUfWZ1bmN0aW9uIGEoVCxOLCQpe3JldHVybiBUWzBdPU5bMF0qJCxUWzFdPU5bMV0qJCxUWzJdPU5bMl0qJCxUfWZ1bmN0aW9uIHMoVCxOLCQsSyl7cmV0dXJuIFRbMF09TlswXSskWzBdKkssVFsxXT1OWzFdKyRbMV0qSyxUWzJdPU5bMl0rJFsyXSpLLFR9ZnVuY3Rpb24gbChULE4pe3ZhciAkPU5bMF0tVFswXSxLPU5bMV0tVFsxXSxZPU5bMl0tVFsyXTtyZXR1cm4gTWF0aC5oeXBvdCgkLEssWSl9ZnVuY3Rpb24gTyhULE4pe3ZhciAkPU5bMF0tVFswXSxLPU5bMV0tVFsxXSxZPU5bMl0tVFsyXTtyZXR1cm4gJCokK0sqSytZKll9ZnVuY3Rpb24gQShUKXt2YXIgTj1UWzBdLCQ9VFsxXSxLPVRbMl07cmV0dXJuIE4qTiskKiQrSypLfWZ1bmN0aW9uIFIoVCxOKXtyZXR1cm4gVFswXT0tTlswXSxUWzFdPS1OWzFdLFRbMl09LU5bMl0sVH1mdW5jdGlvbiBJKFQsTil7cmV0dXJuIFRbMF09MS9OWzBdLFRbMV09MS9OWzFdLFRbMl09MS9OWzJdLFR9ZnVuY3Rpb24gUChULE4pe3ZhciAkPU5bMF0sSz1OWzFdLFk9TlsyXSxRPSQqJCtLKksrWSpZO3JldHVybiBRPjAmJihRPTEvTWF0aC5zcXJ0KFEpKSxUWzBdPU5bMF0qUSxUWzFdPU5bMV0qUSxUWzJdPU5bMl0qUSxUfWZ1bmN0aW9uIEwoVCxOKXtyZXR1cm4gVFswXSpOWzBdK1RbMV0qTlsxXStUWzJdKk5bMl19ZnVuY3Rpb24gRChULE4sJCl7dmFyIEs9TlswXSxZPU5bMV0sUT1OWzJdLGV0PSRbMF0scnQ9JFsxXSxvdD0kWzJdO3JldHVybiBUWzBdPVkqb3QtUSpydCxUWzFdPVEqZXQtSypvdCxUWzJdPUsqcnQtWSpldCxUfWZ1bmN0aW9uIEMoVCxOLCQsSyl7dmFyIFk9TlswXSxRPU5bMV0sZXQ9TlsyXTtyZXR1cm4gVFswXT1ZK0sqKCRbMF0tWSksVFsxXT1RK0sqKCRbMV0tUSksVFsyXT1ldCtLKigkWzJdLWV0KSxUfWZ1bmN0aW9uIFMoVCxOLCQsSyxZLFEpe3ZhciBldD1RKlEscnQ9ZXQqKDIqUS0zKSsxLG90PWV0KihRLTIpK1EsbHQ9ZXQqKFEtMSksaXQ9ZXQqKDMtMipRKTtyZXR1cm4gVFswXT1OWzBdKnJ0KyRbMF0qb3QrS1swXSpsdCtZWzBdKml0LFRbMV09TlsxXSpydCskWzFdKm90K0tbMV0qbHQrWVsxXSppdCxUWzJdPU5bMl0qcnQrJFsyXSpvdCtLWzJdKmx0K1lbMl0qaXQsVH1mdW5jdGlvbiBCKFQsTiwkLEssWSxRKXt2YXIgZXQ9MS1RLHJ0PWV0KmV0LG90PVEqUSxsdD1ydCpldCxpdD0zKlEqcnQsbnQ9MypvdCpldCxhdD1vdCpRO3JldHVybiBUWzBdPU5bMF0qbHQrJFswXSppdCtLWzBdKm50K1lbMF0qYXQsVFsxXT1OWzFdKmx0KyRbMV0qaXQrS1sxXSpudCtZWzFdKmF0LFRbMl09TlsyXSpsdCskWzJdKml0K0tbMl0qbnQrWVsyXSphdCxUfWZ1bmN0aW9uIHcoVCxOKXtOPU58fDE7dmFyICQ9ci5SQU5ET00oKSoyKk1hdGguUEksSz1yLlJBTkRPTSgpKjItMSxZPU1hdGguc3FydCgxLUsqSykqTjtyZXR1cm4gVFswXT1NYXRoLmNvcygkKSpZLFRbMV09TWF0aC5zaW4oJCkqWSxUWzJdPUsqTixUfWZ1bmN0aW9uIEgoVCxOLCQpe3ZhciBLPU5bMF0sWT1OWzFdLFE9TlsyXSxldD0kWzNdKksrJFs3XSpZKyRbMTFdKlErJFsxNV07cmV0dXJuIGV0PWV0fHwxLFRbMF09KCRbMF0qSyskWzRdKlkrJFs4XSpRKyRbMTJdKS9ldCxUWzFdPSgkWzFdKksrJFs1XSpZKyRbOV0qUSskWzEzXSkvZXQsVFsyXT0oJFsyXSpLKyRbNl0qWSskWzEwXSpRKyRbMTRdKS9ldCxUfWZ1bmN0aW9uIEooVCxOLCQpe3ZhciBLPU5bMF0sWT1OWzFdLFE9TlsyXTtyZXR1cm4gVFswXT1LKiRbMF0rWSokWzNdK1EqJFs2XSxUWzFdPUsqJFsxXStZKiRbNF0rUSokWzddLFRbMl09SyokWzJdK1kqJFs1XStRKiRbOF0sVH1mdW5jdGlvbiBxKFQsTiwkKXt2YXIgSz0kWzBdLFk9JFsxXSxRPSRbMl0sZXQ9JFszXSxydD1OWzBdLG90PU5bMV0sbHQ9TlsyXSxpdD1ZKmx0LVEqb3QsbnQ9USpydC1LKmx0LGF0PUsqb3QtWSpydCxkdD1ZKmF0LVEqbnQsZ3Q9USppdC1LKmF0LHV0PUsqbnQtWSppdCxtdD1ldCoyO3JldHVybiBpdCo9bXQsbnQqPW10LGF0Kj1tdCxkdCo9MixndCo9Mix1dCo9MixUWzBdPXJ0K2l0K2R0LFRbMV09b3QrbnQrZ3QsVFsyXT1sdCthdCt1dCxUfWZ1bmN0aW9uIFUoVCxOLCQsSyl7dmFyIFk9W10sUT1bXTtyZXR1cm4gWVswXT1OWzBdLSRbMF0sWVsxXT1OWzFdLSRbMV0sWVsyXT1OWzJdLSRbMl0sUVswXT1ZWzBdLFFbMV09WVsxXSpNYXRoLmNvcyhLKS1ZWzJdKk1hdGguc2luKEspLFFbMl09WVsxXSpNYXRoLnNpbihLKStZWzJdKk1hdGguY29zKEspLFRbMF09UVswXSskWzBdLFRbMV09UVsxXSskWzFdLFRbMl09UVsyXSskWzJdLFR9ZnVuY3Rpb24gRyhULE4sJCxLKXt2YXIgWT1bXSxRPVtdO3JldHVybiBZWzBdPU5bMF0tJFswXSxZWzFdPU5bMV0tJFsxXSxZWzJdPU5bMl0tJFsyXSxRWzBdPVlbMl0qTWF0aC5zaW4oSykrWVswXSpNYXRoLmNvcyhLKSxRWzFdPVlbMV0sUVsyXT1ZWzJdKk1hdGguY29zKEspLVlbMF0qTWF0aC5zaW4oSyksVFswXT1RWzBdKyRbMF0sVFsxXT1RWzFdKyRbMV0sVFsyXT1RWzJdKyRbMl0sVH1mdW5jdGlvbiBaKFQsTiwkLEspe3ZhciBZPVtdLFE9W107cmV0dXJuIFlbMF09TlswXS0kWzBdLFlbMV09TlsxXS0kWzFdLFlbMl09TlsyXS0kWzJdLFFbMF09WVswXSpNYXRoLmNvcyhLKS1ZWzFdKk1hdGguc2luKEspLFFbMV09WVswXSpNYXRoLnNpbihLKStZWzFdKk1hdGguY29zKEspLFFbMl09WVsyXSxUWzBdPVFbMF0rJFswXSxUWzFdPVFbMV0rJFsxXSxUWzJdPVFbMl0rJFsyXSxUfWZ1bmN0aW9uIHR0KFQsTil7dmFyICQ9VFswXSxLPVRbMV0sWT1UWzJdLFE9TlswXSxldD1OWzFdLHJ0PU5bMl0sb3Q9TWF0aC5zcXJ0KCQqJCtLKksrWSpZKSxsdD1NYXRoLnNxcnQoUSpRK2V0KmV0K3J0KnJ0KSxpdD1vdCpsdCxudD1pdCYmTChULE4pL2l0O3JldHVybiBNYXRoLmFjb3MoTWF0aC5taW4oTWF0aC5tYXgobnQsLTEpLDEpKX1mdW5jdGlvbiBfKFQpe3JldHVybiBUWzBdPTAsVFsxXT0wLFRbMl09MCxUfWZ1bmN0aW9uIHN0KFQpe3JldHVybiJ2ZWMzKCIrVFswXSsiLCAiK1RbMV0rIiwgIitUWzJdKyIpIn1mdW5jdGlvbiBrKFQsTil7cmV0dXJuIFRbMF09PT1OWzBdJiZUWzFdPT09TlsxXSYmVFsyXT09PU5bMl19ZnVuY3Rpb24gaHQoVCxOKXt2YXIgJD1UWzBdLEs9VFsxXSxZPVRbMl0sUT1OWzBdLGV0PU5bMV0scnQ9TlsyXTtyZXR1cm4gTWF0aC5hYnMoJC1RKTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoJCksTWF0aC5hYnMoUSkpJiZNYXRoLmFicyhLLWV0KTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoSyksTWF0aC5hYnMoZXQpKSYmTWF0aC5hYnMoWS1ydCk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKFkpLE1hdGguYWJzKHJ0KSl9dmFyIGZ0PWMsVz12LEY9cCxWPWwsWD1PLGo9Zyx6PUEsbT1mdW5jdGlvbigpe3ZhciBUPW4oKTtyZXR1cm4gZnVuY3Rpb24oTiwkLEssWSxRLGV0KXt2YXIgcnQsb3Q7Zm9yKCR8fCgkPTMpLEt8fChLPTApLFk/b3Q9TWF0aC5taW4oWSokK0ssTi5sZW5ndGgpOm90PU4ubGVuZ3RoLHJ0PUs7cnQ8b3Q7cnQrPSQpVFswXT1OW3J0XSxUWzFdPU5bcnQrMV0sVFsyXT1OW3J0KzJdLFEoVCxULGV0KSxOW3J0XT1UWzBdLE5bcnQrMV09VFsxXSxOW3J0KzJdPVRbMl07cmV0dXJuIE59fSgpfSxmdW5jdGlvbihoLGUsdCl7dC5yKGUpLHQuZChlLCJjcmVhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIG59KSx0LmQoZSwiY2xvbmUiLGZ1bmN0aW9uKCl7cmV0dXJuIGR9KSx0LmQoZSwiZnJvbVZhbHVlcyIsZnVuY3Rpb24oKXtyZXR1cm4gZ30pLHQuZChlLCJjb3B5IixmdW5jdGlvbigpe3JldHVybiB1fSksdC5kKGUsInNldCIsZnVuY3Rpb24oKXtyZXR1cm4gb30pLHQuZChlLCJhZGQiLGZ1bmN0aW9uKCl7cmV0dXJuIGZ9KSx0LmQoZSwic3VidHJhY3QiLGZ1bmN0aW9uKCl7cmV0dXJuIHh9KSx0LmQoZSwibXVsdGlwbHkiLGZ1bmN0aW9uKCl7cmV0dXJuIGN9KSx0LmQoZSwiZGl2aWRlIixmdW5jdGlvbigpe3JldHVybiB2fSksdC5kKGUsImNlaWwiLGZ1bmN0aW9uKCl7cmV0dXJuIHB9KSx0LmQoZSwiZmxvb3IiLGZ1bmN0aW9uKCl7cmV0dXJuIGJ9KSx0LmQoZSwibWluIixmdW5jdGlvbigpe3JldHVybiBFfSksdC5kKGUsIm1heCIsZnVuY3Rpb24oKXtyZXR1cm4geX0pLHQuZChlLCJyb3VuZCIsZnVuY3Rpb24oKXtyZXR1cm4gTX0pLHQuZChlLCJzY2FsZSIsZnVuY3Rpb24oKXtyZXR1cm4gaX0pLHQuZChlLCJzY2FsZUFuZEFkZCIsZnVuY3Rpb24oKXtyZXR1cm4gYX0pLHQuZChlLCJkaXN0YW5jZSIsZnVuY3Rpb24oKXtyZXR1cm4gc30pLHQuZChlLCJzcXVhcmVkRGlzdGFuY2UiLGZ1bmN0aW9uKCl7cmV0dXJuIGx9KSx0LmQoZSwibGVuZ3RoIixmdW5jdGlvbigpe3JldHVybiBPfSksdC5kKGUsInNxdWFyZWRMZW5ndGgiLGZ1bmN0aW9uKCl7cmV0dXJuIEF9KSx0LmQoZSwibmVnYXRlIixmdW5jdGlvbigpe3JldHVybiBSfSksdC5kKGUsImludmVyc2UiLGZ1bmN0aW9uKCl7cmV0dXJuIEl9KSx0LmQoZSwibm9ybWFsaXplIixmdW5jdGlvbigpe3JldHVybiBQfSksdC5kKGUsImRvdCIsZnVuY3Rpb24oKXtyZXR1cm4gTH0pLHQuZChlLCJjcm9zcyIsZnVuY3Rpb24oKXtyZXR1cm4gRH0pLHQuZChlLCJsZXJwIixmdW5jdGlvbigpe3JldHVybiBDfSksdC5kKGUsInJhbmRvbSIsZnVuY3Rpb24oKXtyZXR1cm4gU30pLHQuZChlLCJ0cmFuc2Zvcm1NYXQ0IixmdW5jdGlvbigpe3JldHVybiBCfSksdC5kKGUsInRyYW5zZm9ybVF1YXQiLGZ1bmN0aW9uKCl7cmV0dXJuIHd9KSx0LmQoZSwiemVybyIsZnVuY3Rpb24oKXtyZXR1cm4gSH0pLHQuZChlLCJzdHIiLGZ1bmN0aW9uKCl7cmV0dXJuIEp9KSx0LmQoZSwiZXhhY3RFcXVhbHMiLGZ1bmN0aW9uKCl7cmV0dXJuIHF9KSx0LmQoZSwiZXF1YWxzIixmdW5jdGlvbigpe3JldHVybiBVfSksdC5kKGUsInN1YiIsZnVuY3Rpb24oKXtyZXR1cm4gR30pLHQuZChlLCJtdWwiLGZ1bmN0aW9uKCl7cmV0dXJuIFp9KSx0LmQoZSwiZGl2IixmdW5jdGlvbigpe3JldHVybiB0dH0pLHQuZChlLCJkaXN0IixmdW5jdGlvbigpe3JldHVybiBffSksdC5kKGUsInNxckRpc3QiLGZ1bmN0aW9uKCl7cmV0dXJuIHN0fSksdC5kKGUsImxlbiIsZnVuY3Rpb24oKXtyZXR1cm4ga30pLHQuZChlLCJzcXJMZW4iLGZ1bmN0aW9uKCl7cmV0dXJuIGh0fSksdC5kKGUsImZvckVhY2giLGZ1bmN0aW9uKCl7cmV0dXJuIGZ0fSk7dmFyIHI9dCgyKTtmdW5jdGlvbiBuKCl7dmFyIFc9bmV3IHIuQVJSQVlfVFlQRSg0KTtyZXR1cm4gci5BUlJBWV9UWVBFIT1GbG9hdDMyQXJyYXkmJihXWzBdPTAsV1sxXT0wLFdbMl09MCxXWzNdPTApLFd9ZnVuY3Rpb24gZChXKXt2YXIgRj1uZXcgci5BUlJBWV9UWVBFKDQpO3JldHVybiBGWzBdPVdbMF0sRlsxXT1XWzFdLEZbMl09V1syXSxGWzNdPVdbM10sRn1mdW5jdGlvbiBnKFcsRixWLFgpe3ZhciBqPW5ldyByLkFSUkFZX1RZUEUoNCk7cmV0dXJuIGpbMF09VyxqWzFdPUYsalsyXT1WLGpbM109WCxqfWZ1bmN0aW9uIHUoVyxGKXtyZXR1cm4gV1swXT1GWzBdLFdbMV09RlsxXSxXWzJdPUZbMl0sV1szXT1GWzNdLFd9ZnVuY3Rpb24gbyhXLEYsVixYLGope3JldHVybiBXWzBdPUYsV1sxXT1WLFdbMl09WCxXWzNdPWosV31mdW5jdGlvbiBmKFcsRixWKXtyZXR1cm4gV1swXT1GWzBdK1ZbMF0sV1sxXT1GWzFdK1ZbMV0sV1syXT1GWzJdK1ZbMl0sV1szXT1GWzNdK1ZbM10sV31mdW5jdGlvbiB4KFcsRixWKXtyZXR1cm4gV1swXT1GWzBdLVZbMF0sV1sxXT1GWzFdLVZbMV0sV1syXT1GWzJdLVZbMl0sV1szXT1GWzNdLVZbM10sV31mdW5jdGlvbiBjKFcsRixWKXtyZXR1cm4gV1swXT1GWzBdKlZbMF0sV1sxXT1GWzFdKlZbMV0sV1syXT1GWzJdKlZbMl0sV1szXT1GWzNdKlZbM10sV31mdW5jdGlvbiB2KFcsRixWKXtyZXR1cm4gV1swXT1GWzBdL1ZbMF0sV1sxXT1GWzFdL1ZbMV0sV1syXT1GWzJdL1ZbMl0sV1szXT1GWzNdL1ZbM10sV31mdW5jdGlvbiBwKFcsRil7cmV0dXJuIFdbMF09TWF0aC5jZWlsKEZbMF0pLFdbMV09TWF0aC5jZWlsKEZbMV0pLFdbMl09TWF0aC5jZWlsKEZbMl0pLFdbM109TWF0aC5jZWlsKEZbM10pLFd9ZnVuY3Rpb24gYihXLEYpe3JldHVybiBXWzBdPU1hdGguZmxvb3IoRlswXSksV1sxXT1NYXRoLmZsb29yKEZbMV0pLFdbMl09TWF0aC5mbG9vcihGWzJdKSxXWzNdPU1hdGguZmxvb3IoRlszXSksV31mdW5jdGlvbiBFKFcsRixWKXtyZXR1cm4gV1swXT1NYXRoLm1pbihGWzBdLFZbMF0pLFdbMV09TWF0aC5taW4oRlsxXSxWWzFdKSxXWzJdPU1hdGgubWluKEZbMl0sVlsyXSksV1szXT1NYXRoLm1pbihGWzNdLFZbM10pLFd9ZnVuY3Rpb24geShXLEYsVil7cmV0dXJuIFdbMF09TWF0aC5tYXgoRlswXSxWWzBdKSxXWzFdPU1hdGgubWF4KEZbMV0sVlsxXSksV1syXT1NYXRoLm1heChGWzJdLFZbMl0pLFdbM109TWF0aC5tYXgoRlszXSxWWzNdKSxXfWZ1bmN0aW9uIE0oVyxGKXtyZXR1cm4gV1swXT1NYXRoLnJvdW5kKEZbMF0pLFdbMV09TWF0aC5yb3VuZChGWzFdKSxXWzJdPU1hdGgucm91bmQoRlsyXSksV1szXT1NYXRoLnJvdW5kKEZbM10pLFd9ZnVuY3Rpb24gaShXLEYsVil7cmV0dXJuIFdbMF09RlswXSpWLFdbMV09RlsxXSpWLFdbMl09RlsyXSpWLFdbM109RlszXSpWLFd9ZnVuY3Rpb24gYShXLEYsVixYKXtyZXR1cm4gV1swXT1GWzBdK1ZbMF0qWCxXWzFdPUZbMV0rVlsxXSpYLFdbMl09RlsyXStWWzJdKlgsV1szXT1GWzNdK1ZbM10qWCxXfWZ1bmN0aW9uIHMoVyxGKXt2YXIgVj1GWzBdLVdbMF0sWD1GWzFdLVdbMV0saj1GWzJdLVdbMl0sej1GWzNdLVdbM107cmV0dXJuIE1hdGguaHlwb3QoVixYLGoseil9ZnVuY3Rpb24gbChXLEYpe3ZhciBWPUZbMF0tV1swXSxYPUZbMV0tV1sxXSxqPUZbMl0tV1syXSx6PUZbM10tV1szXTtyZXR1cm4gVipWK1gqWCtqKmoreip6fWZ1bmN0aW9uIE8oVyl7dmFyIEY9V1swXSxWPVdbMV0sWD1XWzJdLGo9V1szXTtyZXR1cm4gTWF0aC5oeXBvdChGLFYsWCxqKX1mdW5jdGlvbiBBKFcpe3ZhciBGPVdbMF0sVj1XWzFdLFg9V1syXSxqPVdbM107cmV0dXJuIEYqRitWKlYrWCpYK2oqan1mdW5jdGlvbiBSKFcsRil7cmV0dXJuIFdbMF09LUZbMF0sV1sxXT0tRlsxXSxXWzJdPS1GWzJdLFdbM109LUZbM10sV31mdW5jdGlvbiBJKFcsRil7cmV0dXJuIFdbMF09MS9GWzBdLFdbMV09MS9GWzFdLFdbMl09MS9GWzJdLFdbM109MS9GWzNdLFd9ZnVuY3Rpb24gUChXLEYpe3ZhciBWPUZbMF0sWD1GWzFdLGo9RlsyXSx6PUZbM10sbT1WKlYrWCpYK2oqait6Kno7cmV0dXJuIG0+MCYmKG09MS9NYXRoLnNxcnQobSkpLFdbMF09ViptLFdbMV09WCptLFdbMl09aiptLFdbM109eiptLFd9ZnVuY3Rpb24gTChXLEYpe3JldHVybiBXWzBdKkZbMF0rV1sxXSpGWzFdK1dbMl0qRlsyXStXWzNdKkZbM119ZnVuY3Rpb24gRChXLEYsVixYKXt2YXIgaj1WWzBdKlhbMV0tVlsxXSpYWzBdLHo9VlswXSpYWzJdLVZbMl0qWFswXSxtPVZbMF0qWFszXS1WWzNdKlhbMF0sVD1WWzFdKlhbMl0tVlsyXSpYWzFdLE49VlsxXSpYWzNdLVZbM10qWFsxXSwkPVZbMl0qWFszXS1WWzNdKlhbMl0sSz1GWzBdLFk9RlsxXSxRPUZbMl0sZXQ9RlszXTtyZXR1cm4gV1swXT1ZKiQtUSpOK2V0KlQsV1sxXT0tKEsqJCkrUSptLWV0KnosV1syXT1LKk4tWSptK2V0KmosV1szXT0tKEsqVCkrWSp6LVEqaixXfWZ1bmN0aW9uIEMoVyxGLFYsWCl7dmFyIGo9RlswXSx6PUZbMV0sbT1GWzJdLFQ9RlszXTtyZXR1cm4gV1swXT1qK1gqKFZbMF0taiksV1sxXT16K1gqKFZbMV0teiksV1syXT1tK1gqKFZbMl0tbSksV1szXT1UK1gqKFZbM10tVCksV31mdW5jdGlvbiBTKFcsRil7Rj1GfHwxO3ZhciBWLFgsaix6LG0sVDtkbyBWPXIuUkFORE9NKCkqMi0xLFg9ci5SQU5ET00oKSoyLTEsbT1WKlYrWCpYO3doaWxlKG0+PTEpO2RvIGo9ci5SQU5ET00oKSoyLTEsej1yLlJBTkRPTSgpKjItMSxUPWoqait6Kno7d2hpbGUoVD49MSk7dmFyIE49TWF0aC5zcXJ0KCgxLW0pL1QpO3JldHVybiBXWzBdPUYqVixXWzFdPUYqWCxXWzJdPUYqaipOLFdbM109Rip6Kk4sV31mdW5jdGlvbiBCKFcsRixWKXt2YXIgWD1GWzBdLGo9RlsxXSx6PUZbMl0sbT1GWzNdO3JldHVybiBXWzBdPVZbMF0qWCtWWzRdKmorVls4XSp6K1ZbMTJdKm0sV1sxXT1WWzFdKlgrVls1XSpqK1ZbOV0qeitWWzEzXSptLFdbMl09VlsyXSpYK1ZbNl0qaitWWzEwXSp6K1ZbMTRdKm0sV1szXT1WWzNdKlgrVls3XSpqK1ZbMTFdKnorVlsxNV0qbSxXfWZ1bmN0aW9uIHcoVyxGLFYpe3ZhciBYPUZbMF0saj1GWzFdLHo9RlsyXSxtPVZbMF0sVD1WWzFdLE49VlsyXSwkPVZbM10sSz0kKlgrVCp6LU4qaixZPSQqaitOKlgtbSp6LFE9JCp6K20qai1UKlgsZXQ9LW0qWC1UKmotTip6O3JldHVybiBXWzBdPUsqJCtldCotbStZKi1OLVEqLVQsV1sxXT1ZKiQrZXQqLVQrUSotbS1LKi1OLFdbMl09USokK2V0Ki1OK0sqLVQtWSotbSxXWzNdPUZbM10sV31mdW5jdGlvbiBIKFcpe3JldHVybiBXWzBdPTAsV1sxXT0wLFdbMl09MCxXWzNdPTAsV31mdW5jdGlvbiBKKFcpe3JldHVybiJ2ZWM0KCIrV1swXSsiLCAiK1dbMV0rIiwgIitXWzJdKyIsICIrV1szXSsiKSJ9ZnVuY3Rpb24gcShXLEYpe3JldHVybiBXWzBdPT09RlswXSYmV1sxXT09PUZbMV0mJldbMl09PT1GWzJdJiZXWzNdPT09RlszXX1mdW5jdGlvbiBVKFcsRil7dmFyIFY9V1swXSxYPVdbMV0saj1XWzJdLHo9V1szXSxtPUZbMF0sVD1GWzFdLE49RlsyXSwkPUZbM107cmV0dXJuIE1hdGguYWJzKFYtbSk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKFYpLE1hdGguYWJzKG0pKSYmTWF0aC5hYnMoWC1UKTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoWCksTWF0aC5hYnMoVCkpJiZNYXRoLmFicyhqLU4pPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhqKSxNYXRoLmFicyhOKSkmJk1hdGguYWJzKHotJCk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKHopLE1hdGguYWJzKCQpKX12YXIgRz14LFo9Yyx0dD12LF89cyxzdD1sLGs9TyxodD1BLGZ0PWZ1bmN0aW9uKCl7dmFyIFc9bigpO3JldHVybiBmdW5jdGlvbihGLFYsWCxqLHosbSl7dmFyIFQsTjtmb3IoVnx8KFY9NCksWHx8KFg9MCksaj9OPU1hdGgubWluKGoqVitYLEYubGVuZ3RoKTpOPUYubGVuZ3RoLFQ9WDtUPE47VCs9VilXWzBdPUZbVF0sV1sxXT1GW1QrMV0sV1syXT1GW1QrMl0sV1szXT1GW1QrM10seihXLFcsbSksRltUXT1XWzBdLEZbVCsxXT1XWzFdLEZbVCsyXT1XWzJdLEZbVCszXT1XWzNdO3JldHVybiBGfX0oKX0sZnVuY3Rpb24oaCxlLHQpe3QucihlKSx0LmQoZSwiY3JlYXRlIixmdW5jdGlvbigpe3JldHVybiBnfSksdC5kKGUsImNsb25lIixmdW5jdGlvbigpe3JldHVybiB1fSksdC5kKGUsImZyb21WYWx1ZXMiLGZ1bmN0aW9uKCl7cmV0dXJuIG99KSx0LmQoZSwiZnJvbVJvdGF0aW9uVHJhbnNsYXRpb25WYWx1ZXMiLGZ1bmN0aW9uKCl7cmV0dXJuIGZ9KSx0LmQoZSwiZnJvbVJvdGF0aW9uVHJhbnNsYXRpb24iLGZ1bmN0aW9uKCl7cmV0dXJuIHh9KSx0LmQoZSwiZnJvbVRyYW5zbGF0aW9uIixmdW5jdGlvbigpe3JldHVybiBjfSksdC5kKGUsImZyb21Sb3RhdGlvbiIsZnVuY3Rpb24oKXtyZXR1cm4gdn0pLHQuZChlLCJmcm9tTWF0NCIsZnVuY3Rpb24oKXtyZXR1cm4gcH0pLHQuZChlLCJjb3B5IixmdW5jdGlvbigpe3JldHVybiBifSksdC5kKGUsImlkZW50aXR5IixmdW5jdGlvbigpe3JldHVybiBFfSksdC5kKGUsInNldCIsZnVuY3Rpb24oKXtyZXR1cm4geX0pLHQuZChlLCJnZXRSZWFsIixmdW5jdGlvbigpe3JldHVybiBNfSksdC5kKGUsImdldER1YWwiLGZ1bmN0aW9uKCl7cmV0dXJuIGl9KSx0LmQoZSwic2V0UmVhbCIsZnVuY3Rpb24oKXtyZXR1cm4gYX0pLHQuZChlLCJzZXREdWFsIixmdW5jdGlvbigpe3JldHVybiBzfSksdC5kKGUsImdldFRyYW5zbGF0aW9uIixmdW5jdGlvbigpe3JldHVybiBsfSksdC5kKGUsInRyYW5zbGF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gT30pLHQuZChlLCJyb3RhdGVYIixmdW5jdGlvbigpe3JldHVybiBBfSksdC5kKGUsInJvdGF0ZVkiLGZ1bmN0aW9uKCl7cmV0dXJuIFJ9KSx0LmQoZSwicm90YXRlWiIsZnVuY3Rpb24oKXtyZXR1cm4gSX0pLHQuZChlLCJyb3RhdGVCeVF1YXRBcHBlbmQiLGZ1bmN0aW9uKCl7cmV0dXJuIFB9KSx0LmQoZSwicm90YXRlQnlRdWF0UHJlcGVuZCIsZnVuY3Rpb24oKXtyZXR1cm4gTH0pLHQuZChlLCJyb3RhdGVBcm91bmRBeGlzIixmdW5jdGlvbigpe3JldHVybiBEfSksdC5kKGUsImFkZCIsZnVuY3Rpb24oKXtyZXR1cm4gQ30pLHQuZChlLCJtdWx0aXBseSIsZnVuY3Rpb24oKXtyZXR1cm4gU30pLHQuZChlLCJtdWwiLGZ1bmN0aW9uKCl7cmV0dXJuIEJ9KSx0LmQoZSwic2NhbGUiLGZ1bmN0aW9uKCl7cmV0dXJuIHd9KSx0LmQoZSwiZG90IixmdW5jdGlvbigpe3JldHVybiBIfSksdC5kKGUsImxlcnAiLGZ1bmN0aW9uKCl7cmV0dXJuIEp9KSx0LmQoZSwiaW52ZXJ0IixmdW5jdGlvbigpe3JldHVybiBxfSksdC5kKGUsImNvbmp1Z2F0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gVX0pLHQuZChlLCJsZW5ndGgiLGZ1bmN0aW9uKCl7cmV0dXJuIEd9KSx0LmQoZSwibGVuIixmdW5jdGlvbigpe3JldHVybiBafSksdC5kKGUsInNxdWFyZWRMZW5ndGgiLGZ1bmN0aW9uKCl7cmV0dXJuIHR0fSksdC5kKGUsInNxckxlbiIsZnVuY3Rpb24oKXtyZXR1cm4gX30pLHQuZChlLCJub3JtYWxpemUiLGZ1bmN0aW9uKCl7cmV0dXJuIHN0fSksdC5kKGUsInN0ciIsZnVuY3Rpb24oKXtyZXR1cm4ga30pLHQuZChlLCJleGFjdEVxdWFscyIsZnVuY3Rpb24oKXtyZXR1cm4gaHR9KSx0LmQoZSwiZXF1YWxzIixmdW5jdGlvbigpe3JldHVybiBmdH0pO3ZhciByPXQoMiksbj10KDcpLGQ9dCg2KTtmdW5jdGlvbiBnKCl7dmFyIFc9bmV3IHIuQVJSQVlfVFlQRSg4KTtyZXR1cm4gci5BUlJBWV9UWVBFIT1GbG9hdDMyQXJyYXkmJihXWzBdPTAsV1sxXT0wLFdbMl09MCxXWzRdPTAsV1s1XT0wLFdbNl09MCxXWzddPTApLFdbM109MSxXfWZ1bmN0aW9uIHUoVyl7dmFyIEY9bmV3IHIuQVJSQVlfVFlQRSg4KTtyZXR1cm4gRlswXT1XWzBdLEZbMV09V1sxXSxGWzJdPVdbMl0sRlszXT1XWzNdLEZbNF09V1s0XSxGWzVdPVdbNV0sRls2XT1XWzZdLEZbN109V1s3XSxGfWZ1bmN0aW9uIG8oVyxGLFYsWCxqLHosbSxUKXt2YXIgTj1uZXcgci5BUlJBWV9UWVBFKDgpO3JldHVybiBOWzBdPVcsTlsxXT1GLE5bMl09VixOWzNdPVgsTls0XT1qLE5bNV09eixOWzZdPW0sTls3XT1ULE59ZnVuY3Rpb24gZihXLEYsVixYLGoseixtKXt2YXIgVD1uZXcgci5BUlJBWV9UWVBFKDgpO1RbMF09VyxUWzFdPUYsVFsyXT1WLFRbM109WDt2YXIgTj1qKi41LCQ9eiouNSxLPW0qLjU7cmV0dXJuIFRbNF09TipYKyQqVi1LKkYsVFs1XT0kKlgrSypXLU4qVixUWzZdPUsqWCtOKkYtJCpXLFRbN109LU4qVy0kKkYtSypWLFR9ZnVuY3Rpb24geChXLEYsVil7dmFyIFg9VlswXSouNSxqPVZbMV0qLjUsej1WWzJdKi41LG09RlswXSxUPUZbMV0sTj1GWzJdLCQ9RlszXTtyZXR1cm4gV1swXT1tLFdbMV09VCxXWzJdPU4sV1szXT0kLFdbNF09WCokK2oqTi16KlQsV1s1XT1qKiQreiptLVgqTixXWzZdPXoqJCtYKlQtaiptLFdbN109LVgqbS1qKlQteipOLFd9ZnVuY3Rpb24gYyhXLEYpe3JldHVybiBXWzBdPTAsV1sxXT0wLFdbMl09MCxXWzNdPTEsV1s0XT1GWzBdKi41LFdbNV09RlsxXSouNSxXWzZdPUZbMl0qLjUsV1s3XT0wLFd9ZnVuY3Rpb24gdihXLEYpe3JldHVybiBXWzBdPUZbMF0sV1sxXT1GWzFdLFdbMl09RlsyXSxXWzNdPUZbM10sV1s0XT0wLFdbNV09MCxXWzZdPTAsV1s3XT0wLFd9ZnVuY3Rpb24gcChXLEYpe3ZhciBWPW4uY3JlYXRlKCk7ZC5nZXRSb3RhdGlvbihWLEYpO3ZhciBYPW5ldyByLkFSUkFZX1RZUEUoMyk7cmV0dXJuIGQuZ2V0VHJhbnNsYXRpb24oWCxGKSx4KFcsVixYKSxXfWZ1bmN0aW9uIGIoVyxGKXtyZXR1cm4gV1swXT1GWzBdLFdbMV09RlsxXSxXWzJdPUZbMl0sV1szXT1GWzNdLFdbNF09Rls0XSxXWzVdPUZbNV0sV1s2XT1GWzZdLFdbN109Rls3XSxXfWZ1bmN0aW9uIEUoVyl7cmV0dXJuIFdbMF09MCxXWzFdPTAsV1syXT0wLFdbM109MSxXWzRdPTAsV1s1XT0wLFdbNl09MCxXWzddPTAsV31mdW5jdGlvbiB5KFcsRixWLFgsaix6LG0sVCxOKXtyZXR1cm4gV1swXT1GLFdbMV09VixXWzJdPVgsV1szXT1qLFdbNF09eixXWzVdPW0sV1s2XT1ULFdbN109TixXfXZhciBNPW4uY29weTtmdW5jdGlvbiBpKFcsRil7cmV0dXJuIFdbMF09Rls0XSxXWzFdPUZbNV0sV1syXT1GWzZdLFdbM109Rls3XSxXfXZhciBhPW4uY29weTtmdW5jdGlvbiBzKFcsRil7cmV0dXJuIFdbNF09RlswXSxXWzVdPUZbMV0sV1s2XT1GWzJdLFdbN109RlszXSxXfWZ1bmN0aW9uIGwoVyxGKXt2YXIgVj1GWzRdLFg9Rls1XSxqPUZbNl0sej1GWzddLG09LUZbMF0sVD0tRlsxXSxOPS1GWzJdLCQ9RlszXTtyZXR1cm4gV1swXT0oViokK3oqbStYKk4taipUKSoyLFdbMV09KFgqJCt6KlQraiptLVYqTikqMixXWzJdPShqKiQreipOK1YqVC1YKm0pKjIsV31mdW5jdGlvbiBPKFcsRixWKXt2YXIgWD1GWzBdLGo9RlsxXSx6PUZbMl0sbT1GWzNdLFQ9VlswXSouNSxOPVZbMV0qLjUsJD1WWzJdKi41LEs9Rls0XSxZPUZbNV0sUT1GWzZdLGV0PUZbN107cmV0dXJuIFdbMF09WCxXWzFdPWosV1syXT16LFdbM109bSxXWzRdPW0qVCtqKiQteipOK0ssV1s1XT1tKk4reipULVgqJCtZLFdbNl09bSokK1gqTi1qKlQrUSxXWzddPS1YKlQtaipOLXoqJCtldCxXfWZ1bmN0aW9uIEEoVyxGLFYpe3ZhciBYPS1GWzBdLGo9LUZbMV0sej0tRlsyXSxtPUZbM10sVD1GWzRdLE49Rls1XSwkPUZbNl0sSz1GWzddLFk9VCptK0sqWCtOKnotJCpqLFE9TiptK0sqaiskKlgtVCp6LGV0PSQqbStLKnorVCpqLU4qWCxydD1LKm0tVCpYLU4qai0kKno7cmV0dXJuIG4ucm90YXRlWChXLEYsViksWD1XWzBdLGo9V1sxXSx6PVdbMl0sbT1XWzNdLFdbNF09WSptK3J0KlgrUSp6LWV0KmosV1s1XT1RKm0rcnQqaitldCpYLVkqeixXWzZdPWV0Km0rcnQqeitZKmotUSpYLFdbN109cnQqbS1ZKlgtUSpqLWV0KnosV31mdW5jdGlvbiBSKFcsRixWKXt2YXIgWD0tRlswXSxqPS1GWzFdLHo9LUZbMl0sbT1GWzNdLFQ9Rls0XSxOPUZbNV0sJD1GWzZdLEs9Rls3XSxZPVQqbStLKlgrTip6LSQqaixRPU4qbStLKmorJCpYLVQqeixldD0kKm0rSyp6K1Qqai1OKlgscnQ9SyptLVQqWC1OKmotJCp6O3JldHVybiBuLnJvdGF0ZVkoVyxGLFYpLFg9V1swXSxqPVdbMV0sej1XWzJdLG09V1szXSxXWzRdPVkqbStydCpYK1Eqei1ldCpqLFdbNV09USptK3J0KmorZXQqWC1ZKnosV1s2XT1ldCptK3J0KnorWSpqLVEqWCxXWzddPXJ0Km0tWSpYLVEqai1ldCp6LFd9ZnVuY3Rpb24gSShXLEYsVil7dmFyIFg9LUZbMF0saj0tRlsxXSx6PS1GWzJdLG09RlszXSxUPUZbNF0sTj1GWzVdLCQ9Rls2XSxLPUZbN10sWT1UKm0rSypYK04qei0kKmosUT1OKm0rSypqKyQqWC1UKnosZXQ9JCptK0sqeitUKmotTipYLHJ0PUsqbS1UKlgtTipqLSQqejtyZXR1cm4gbi5yb3RhdGVaKFcsRixWKSxYPVdbMF0saj1XWzFdLHo9V1syXSxtPVdbM10sV1s0XT1ZKm0rcnQqWCtRKnotZXQqaixXWzVdPVEqbStydCpqK2V0KlgtWSp6LFdbNl09ZXQqbStydCp6K1kqai1RKlgsV1s3XT1ydCptLVkqWC1RKmotZXQqeixXfWZ1bmN0aW9uIFAoVyxGLFYpe3ZhciBYPVZbMF0saj1WWzFdLHo9VlsyXSxtPVZbM10sVD1GWzBdLE49RlsxXSwkPUZbMl0sSz1GWzNdO3JldHVybiBXWzBdPVQqbStLKlgrTip6LSQqaixXWzFdPU4qbStLKmorJCpYLVQqeixXWzJdPSQqbStLKnorVCpqLU4qWCxXWzNdPUsqbS1UKlgtTipqLSQqeixUPUZbNF0sTj1GWzVdLCQ9Rls2XSxLPUZbN10sV1s0XT1UKm0rSypYK04qei0kKmosV1s1XT1OKm0rSypqKyQqWC1UKnosV1s2XT0kKm0rSyp6K1Qqai1OKlgsV1s3XT1LKm0tVCpYLU4qai0kKnosV31mdW5jdGlvbiBMKFcsRixWKXt2YXIgWD1GWzBdLGo9RlsxXSx6PUZbMl0sbT1GWzNdLFQ9VlswXSxOPVZbMV0sJD1WWzJdLEs9VlszXTtyZXR1cm4gV1swXT1YKksrbSpUK2oqJC16Kk4sV1sxXT1qKksrbSpOK3oqVC1YKiQsV1syXT16KksrbSokK1gqTi1qKlQsV1szXT1tKkstWCpULWoqTi16KiQsVD1WWzRdLE49Vls1XSwkPVZbNl0sSz1WWzddLFdbNF09WCpLK20qVCtqKiQteipOLFdbNV09aipLK20qTit6KlQtWCokLFdbNl09eipLK20qJCtYKk4taipULFdbN109bSpLLVgqVC1qKk4teiokLFd9ZnVuY3Rpb24gRChXLEYsVixYKXtpZihNYXRoLmFicyhYKTxyLkVQU0lMT04pcmV0dXJuIGIoVyxGKTt2YXIgaj1NYXRoLmh5cG90KFZbMF0sVlsxXSxWWzJdKTtYPVgqLjU7dmFyIHo9TWF0aC5zaW4oWCksbT16KlZbMF0vaixUPXoqVlsxXS9qLE49eipWWzJdL2osJD1NYXRoLmNvcyhYKSxLPUZbMF0sWT1GWzFdLFE9RlsyXSxldD1GWzNdO1dbMF09SyokK2V0Km0rWSpOLVEqVCxXWzFdPVkqJCtldCpUK1EqbS1LKk4sV1syXT1RKiQrZXQqTitLKlQtWSptLFdbM109ZXQqJC1LKm0tWSpULVEqTjt2YXIgcnQ9Rls0XSxvdD1GWzVdLGx0PUZbNl0saXQ9Rls3XTtyZXR1cm4gV1s0XT1ydCokK2l0Km0rb3QqTi1sdCpULFdbNV09b3QqJCtpdCpUK2x0Km0tcnQqTixXWzZdPWx0KiQraXQqTitydCpULW90Km0sV1s3XT1pdCokLXJ0Km0tb3QqVC1sdCpOLFd9ZnVuY3Rpb24gQyhXLEYsVil7cmV0dXJuIFdbMF09RlswXStWWzBdLFdbMV09RlsxXStWWzFdLFdbMl09RlsyXStWWzJdLFdbM109RlszXStWWzNdLFdbNF09Rls0XStWWzRdLFdbNV09Rls1XStWWzVdLFdbNl09Rls2XStWWzZdLFdbN109Rls3XStWWzddLFd9ZnVuY3Rpb24gUyhXLEYsVil7dmFyIFg9RlswXSxqPUZbMV0sej1GWzJdLG09RlszXSxUPVZbNF0sTj1WWzVdLCQ9Vls2XSxLPVZbN10sWT1GWzRdLFE9Rls1XSxldD1GWzZdLHJ0PUZbN10sb3Q9VlswXSxsdD1WWzFdLGl0PVZbMl0sbnQ9VlszXTtyZXR1cm4gV1swXT1YKm50K20qb3QraippdC16Kmx0LFdbMV09aipudCttKmx0K3oqb3QtWCppdCxXWzJdPXoqbnQrbSppdCtYKmx0LWoqb3QsV1szXT1tKm50LVgqb3QtaipsdC16Kml0LFdbNF09WCpLK20qVCtqKiQteipOK1kqbnQrcnQqb3QrUSppdC1ldCpsdCxXWzVdPWoqSyttKk4reipULVgqJCtRKm50K3J0Kmx0K2V0Km90LVkqaXQsV1s2XT16KksrbSokK1gqTi1qKlQrZXQqbnQrcnQqaXQrWSpsdC1RKm90LFdbN109bSpLLVgqVC1qKk4teiokK3J0Km50LVkqb3QtUSpsdC1ldCppdCxXfXZhciBCPVM7ZnVuY3Rpb24gdyhXLEYsVil7cmV0dXJuIFdbMF09RlswXSpWLFdbMV09RlsxXSpWLFdbMl09RlsyXSpWLFdbM109RlszXSpWLFdbNF09Rls0XSpWLFdbNV09Rls1XSpWLFdbNl09Rls2XSpWLFdbN109Rls3XSpWLFd9dmFyIEg9bi5kb3Q7ZnVuY3Rpb24gSihXLEYsVixYKXt2YXIgaj0xLVg7cmV0dXJuIEgoRixWKTwwJiYoWD0tWCksV1swXT1GWzBdKmorVlswXSpYLFdbMV09RlsxXSpqK1ZbMV0qWCxXWzJdPUZbMl0qaitWWzJdKlgsV1szXT1GWzNdKmorVlszXSpYLFdbNF09Rls0XSpqK1ZbNF0qWCxXWzVdPUZbNV0qaitWWzVdKlgsV1s2XT1GWzZdKmorVls2XSpYLFdbN109Rls3XSpqK1ZbN10qWCxXfWZ1bmN0aW9uIHEoVyxGKXt2YXIgVj10dChGKTtyZXR1cm4gV1swXT0tRlswXS9WLFdbMV09LUZbMV0vVixXWzJdPS1GWzJdL1YsV1szXT1GWzNdL1YsV1s0XT0tRls0XS9WLFdbNV09LUZbNV0vVixXWzZdPS1GWzZdL1YsV1s3XT1GWzddL1YsV31mdW5jdGlvbiBVKFcsRil7cmV0dXJuIFdbMF09LUZbMF0sV1sxXT0tRlsxXSxXWzJdPS1GWzJdLFdbM109RlszXSxXWzRdPS1GWzRdLFdbNV09LUZbNV0sV1s2XT0tRls2XSxXWzddPUZbN10sV312YXIgRz1uLmxlbmd0aCxaPUcsdHQ9bi5zcXVhcmVkTGVuZ3RoLF89dHQ7ZnVuY3Rpb24gc3QoVyxGKXt2YXIgVj10dChGKTtpZihWPjApe1Y9TWF0aC5zcXJ0KFYpO3ZhciBYPUZbMF0vVixqPUZbMV0vVix6PUZbMl0vVixtPUZbM10vVixUPUZbNF0sTj1GWzVdLCQ9Rls2XSxLPUZbN10sWT1YKlQraipOK3oqJCttKks7V1swXT1YLFdbMV09aixXWzJdPXosV1szXT1tLFdbNF09KFQtWCpZKS9WLFdbNV09KE4taipZKS9WLFdbNl09KCQteipZKS9WLFdbN109KEstbSpZKS9WfXJldHVybiBXfWZ1bmN0aW9uIGsoVyl7cmV0dXJuInF1YXQyKCIrV1swXSsiLCAiK1dbMV0rIiwgIitXWzJdKyIsICIrV1szXSsiLCAiK1dbNF0rIiwgIitXWzVdKyIsICIrV1s2XSsiLCAiK1dbN10rIikifWZ1bmN0aW9uIGh0KFcsRil7cmV0dXJuIFdbMF09PT1GWzBdJiZXWzFdPT09RlsxXSYmV1syXT09PUZbMl0mJldbM109PT1GWzNdJiZXWzRdPT09Rls0XSYmV1s1XT09PUZbNV0mJldbNl09PT1GWzZdJiZXWzddPT09Rls3XX1mdW5jdGlvbiBmdChXLEYpe3ZhciBWPVdbMF0sWD1XWzFdLGo9V1syXSx6PVdbM10sbT1XWzRdLFQ9V1s1XSxOPVdbNl0sJD1XWzddLEs9RlswXSxZPUZbMV0sUT1GWzJdLGV0PUZbM10scnQ9Rls0XSxvdD1GWzVdLGx0PUZbNl0saXQ9Rls3XTtyZXR1cm4gTWF0aC5hYnMoVi1LKTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoViksTWF0aC5hYnMoSykpJiZNYXRoLmFicyhYLVkpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhYKSxNYXRoLmFicyhZKSkmJk1hdGguYWJzKGotUSk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKGopLE1hdGguYWJzKFEpKSYmTWF0aC5hYnMoei1ldCk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKHopLE1hdGguYWJzKGV0KSkmJk1hdGguYWJzKG0tcnQpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhtKSxNYXRoLmFicyhydCkpJiZNYXRoLmFicyhULW90KTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoVCksTWF0aC5hYnMob3QpKSYmTWF0aC5hYnMoTi1sdCk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKE4pLE1hdGguYWJzKGx0KSkmJk1hdGguYWJzKCQtaXQpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicygkKSxNYXRoLmFicyhpdCkpfX0sZnVuY3Rpb24oaCxlLHQpe3QucihlKSx0LmQoZSwiY3JlYXRlIixmdW5jdGlvbigpe3JldHVybiBufSksdC5kKGUsImNsb25lIixmdW5jdGlvbigpe3JldHVybiBkfSksdC5kKGUsImZyb21WYWx1ZXMiLGZ1bmN0aW9uKCl7cmV0dXJuIGd9KSx0LmQoZSwiY29weSIsZnVuY3Rpb24oKXtyZXR1cm4gdX0pLHQuZChlLCJzZXQiLGZ1bmN0aW9uKCl7cmV0dXJuIG99KSx0LmQoZSwiYWRkIixmdW5jdGlvbigpe3JldHVybiBmfSksdC5kKGUsInN1YnRyYWN0IixmdW5jdGlvbigpe3JldHVybiB4fSksdC5kKGUsIm11bHRpcGx5IixmdW5jdGlvbigpe3JldHVybiBjfSksdC5kKGUsImRpdmlkZSIsZnVuY3Rpb24oKXtyZXR1cm4gdn0pLHQuZChlLCJjZWlsIixmdW5jdGlvbigpe3JldHVybiBwfSksdC5kKGUsImZsb29yIixmdW5jdGlvbigpe3JldHVybiBifSksdC5kKGUsIm1pbiIsZnVuY3Rpb24oKXtyZXR1cm4gRX0pLHQuZChlLCJtYXgiLGZ1bmN0aW9uKCl7cmV0dXJuIHl9KSx0LmQoZSwicm91bmQiLGZ1bmN0aW9uKCl7cmV0dXJuIE19KSx0LmQoZSwic2NhbGUiLGZ1bmN0aW9uKCl7cmV0dXJuIGl9KSx0LmQoZSwic2NhbGVBbmRBZGQiLGZ1bmN0aW9uKCl7cmV0dXJuIGF9KSx0LmQoZSwiZGlzdGFuY2UiLGZ1bmN0aW9uKCl7cmV0dXJuIHN9KSx0LmQoZSwic3F1YXJlZERpc3RhbmNlIixmdW5jdGlvbigpe3JldHVybiBsfSksdC5kKGUsImxlbmd0aCIsZnVuY3Rpb24oKXtyZXR1cm4gT30pLHQuZChlLCJzcXVhcmVkTGVuZ3RoIixmdW5jdGlvbigpe3JldHVybiBBfSksdC5kKGUsIm5lZ2F0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gUn0pLHQuZChlLCJpbnZlcnNlIixmdW5jdGlvbigpe3JldHVybiBJfSksdC5kKGUsIm5vcm1hbGl6ZSIsZnVuY3Rpb24oKXtyZXR1cm4gUH0pLHQuZChlLCJkb3QiLGZ1bmN0aW9uKCl7cmV0dXJuIEx9KSx0LmQoZSwiY3Jvc3MiLGZ1bmN0aW9uKCl7cmV0dXJuIER9KSx0LmQoZSwibGVycCIsZnVuY3Rpb24oKXtyZXR1cm4gQ30pLHQuZChlLCJyYW5kb20iLGZ1bmN0aW9uKCl7cmV0dXJuIFN9KSx0LmQoZSwidHJhbnNmb3JtTWF0MiIsZnVuY3Rpb24oKXtyZXR1cm4gQn0pLHQuZChlLCJ0cmFuc2Zvcm1NYXQyZCIsZnVuY3Rpb24oKXtyZXR1cm4gd30pLHQuZChlLCJ0cmFuc2Zvcm1NYXQzIixmdW5jdGlvbigpe3JldHVybiBIfSksdC5kKGUsInRyYW5zZm9ybU1hdDQiLGZ1bmN0aW9uKCl7cmV0dXJuIEp9KSx0LmQoZSwicm90YXRlIixmdW5jdGlvbigpe3JldHVybiBxfSksdC5kKGUsImFuZ2xlIixmdW5jdGlvbigpe3JldHVybiBVfSksdC5kKGUsInplcm8iLGZ1bmN0aW9uKCl7cmV0dXJuIEd9KSx0LmQoZSwic3RyIixmdW5jdGlvbigpe3JldHVybiBafSksdC5kKGUsImV4YWN0RXF1YWxzIixmdW5jdGlvbigpe3JldHVybiB0dH0pLHQuZChlLCJlcXVhbHMiLGZ1bmN0aW9uKCl7cmV0dXJuIF99KSx0LmQoZSwibGVuIixmdW5jdGlvbigpe3JldHVybiBzdH0pLHQuZChlLCJzdWIiLGZ1bmN0aW9uKCl7cmV0dXJuIGt9KSx0LmQoZSwibXVsIixmdW5jdGlvbigpe3JldHVybiBodH0pLHQuZChlLCJkaXYiLGZ1bmN0aW9uKCl7cmV0dXJuIGZ0fSksdC5kKGUsImRpc3QiLGZ1bmN0aW9uKCl7cmV0dXJuIFd9KSx0LmQoZSwic3FyRGlzdCIsZnVuY3Rpb24oKXtyZXR1cm4gRn0pLHQuZChlLCJzcXJMZW4iLGZ1bmN0aW9uKCl7cmV0dXJuIFZ9KSx0LmQoZSwiZm9yRWFjaCIsZnVuY3Rpb24oKXtyZXR1cm4gWH0pO3ZhciByPXQoMik7ZnVuY3Rpb24gbigpe3ZhciBqPW5ldyByLkFSUkFZX1RZUEUoMik7cmV0dXJuIHIuQVJSQVlfVFlQRSE9RmxvYXQzMkFycmF5JiYoalswXT0wLGpbMV09MCksan1mdW5jdGlvbiBkKGope3ZhciB6PW5ldyByLkFSUkFZX1RZUEUoMik7cmV0dXJuIHpbMF09alswXSx6WzFdPWpbMV0sen1mdW5jdGlvbiBnKGoseil7dmFyIG09bmV3IHIuQVJSQVlfVFlQRSgyKTtyZXR1cm4gbVswXT1qLG1bMV09eixtfWZ1bmN0aW9uIHUoaix6KXtyZXR1cm4galswXT16WzBdLGpbMV09elsxXSxqfWZ1bmN0aW9uIG8oaix6LG0pe3JldHVybiBqWzBdPXosalsxXT1tLGp9ZnVuY3Rpb24gZihqLHosbSl7cmV0dXJuIGpbMF09elswXSttWzBdLGpbMV09elsxXSttWzFdLGp9ZnVuY3Rpb24geChqLHosbSl7cmV0dXJuIGpbMF09elswXS1tWzBdLGpbMV09elsxXS1tWzFdLGp9ZnVuY3Rpb24gYyhqLHosbSl7cmV0dXJuIGpbMF09elswXSptWzBdLGpbMV09elsxXSptWzFdLGp9ZnVuY3Rpb24gdihqLHosbSl7cmV0dXJuIGpbMF09elswXS9tWzBdLGpbMV09elsxXS9tWzFdLGp9ZnVuY3Rpb24gcChqLHope3JldHVybiBqWzBdPU1hdGguY2VpbCh6WzBdKSxqWzFdPU1hdGguY2VpbCh6WzFdKSxqfWZ1bmN0aW9uIGIoaix6KXtyZXR1cm4galswXT1NYXRoLmZsb29yKHpbMF0pLGpbMV09TWF0aC5mbG9vcih6WzFdKSxqfWZ1bmN0aW9uIEUoaix6LG0pe3JldHVybiBqWzBdPU1hdGgubWluKHpbMF0sbVswXSksalsxXT1NYXRoLm1pbih6WzFdLG1bMV0pLGp9ZnVuY3Rpb24geShqLHosbSl7cmV0dXJuIGpbMF09TWF0aC5tYXgoelswXSxtWzBdKSxqWzFdPU1hdGgubWF4KHpbMV0sbVsxXSksan1mdW5jdGlvbiBNKGoseil7cmV0dXJuIGpbMF09TWF0aC5yb3VuZCh6WzBdKSxqWzFdPU1hdGgucm91bmQoelsxXSksan1mdW5jdGlvbiBpKGoseixtKXtyZXR1cm4galswXT16WzBdKm0salsxXT16WzFdKm0san1mdW5jdGlvbiBhKGoseixtLFQpe3JldHVybiBqWzBdPXpbMF0rbVswXSpULGpbMV09elsxXSttWzFdKlQsan1mdW5jdGlvbiBzKGoseil7dmFyIG09elswXS1qWzBdLFQ9elsxXS1qWzFdO3JldHVybiBNYXRoLmh5cG90KG0sVCl9ZnVuY3Rpb24gbChqLHope3ZhciBtPXpbMF0talswXSxUPXpbMV0talsxXTtyZXR1cm4gbSptK1QqVH1mdW5jdGlvbiBPKGope3ZhciB6PWpbMF0sbT1qWzFdO3JldHVybiBNYXRoLmh5cG90KHosbSl9ZnVuY3Rpb24gQShqKXt2YXIgej1qWzBdLG09alsxXTtyZXR1cm4geip6K20qbX1mdW5jdGlvbiBSKGoseil7cmV0dXJuIGpbMF09LXpbMF0salsxXT0telsxXSxqfWZ1bmN0aW9uIEkoaix6KXtyZXR1cm4galswXT0xL3pbMF0salsxXT0xL3pbMV0san1mdW5jdGlvbiBQKGoseil7dmFyIG09elswXSxUPXpbMV0sTj1tKm0rVCpUO3JldHVybiBOPjAmJihOPTEvTWF0aC5zcXJ0KE4pKSxqWzBdPXpbMF0qTixqWzFdPXpbMV0qTixqfWZ1bmN0aW9uIEwoaix6KXtyZXR1cm4galswXSp6WzBdK2pbMV0qelsxXX1mdW5jdGlvbiBEKGoseixtKXt2YXIgVD16WzBdKm1bMV0telsxXSptWzBdO3JldHVybiBqWzBdPWpbMV09MCxqWzJdPVQsan1mdW5jdGlvbiBDKGoseixtLFQpe3ZhciBOPXpbMF0sJD16WzFdO3JldHVybiBqWzBdPU4rVCoobVswXS1OKSxqWzFdPSQrVCoobVsxXS0kKSxqfWZ1bmN0aW9uIFMoaix6KXt6PXp8fDE7dmFyIG09ci5SQU5ET00oKSoyKk1hdGguUEk7cmV0dXJuIGpbMF09TWF0aC5jb3MobSkqeixqWzFdPU1hdGguc2luKG0pKnosan1mdW5jdGlvbiBCKGoseixtKXt2YXIgVD16WzBdLE49elsxXTtyZXR1cm4galswXT1tWzBdKlQrbVsyXSpOLGpbMV09bVsxXSpUK21bM10qTixqfWZ1bmN0aW9uIHcoaix6LG0pe3ZhciBUPXpbMF0sTj16WzFdO3JldHVybiBqWzBdPW1bMF0qVCttWzJdKk4rbVs0XSxqWzFdPW1bMV0qVCttWzNdKk4rbVs1XSxqfWZ1bmN0aW9uIEgoaix6LG0pe3ZhciBUPXpbMF0sTj16WzFdO3JldHVybiBqWzBdPW1bMF0qVCttWzNdKk4rbVs2XSxqWzFdPW1bMV0qVCttWzRdKk4rbVs3XSxqfWZ1bmN0aW9uIEooaix6LG0pe3ZhciBUPXpbMF0sTj16WzFdO3JldHVybiBqWzBdPW1bMF0qVCttWzRdKk4rbVsxMl0salsxXT1tWzFdKlQrbVs1XSpOK21bMTNdLGp9ZnVuY3Rpb24gcShqLHosbSxUKXt2YXIgTj16WzBdLW1bMF0sJD16WzFdLW1bMV0sSz1NYXRoLnNpbihUKSxZPU1hdGguY29zKFQpO3JldHVybiBqWzBdPU4qWS0kKksrbVswXSxqWzFdPU4qSyskKlkrbVsxXSxqfWZ1bmN0aW9uIFUoaix6KXt2YXIgbT1qWzBdLFQ9alsxXSxOPXpbMF0sJD16WzFdLEs9TWF0aC5zcXJ0KG0qbStUKlQpKk1hdGguc3FydChOKk4rJCokKSxZPUsmJihtKk4rVCokKS9LO3JldHVybiBNYXRoLmFjb3MoTWF0aC5taW4oTWF0aC5tYXgoWSwtMSksMSkpfWZ1bmN0aW9uIEcoail7cmV0dXJuIGpbMF09MCxqWzFdPTAsan1mdW5jdGlvbiBaKGope3JldHVybiJ2ZWMyKCIralswXSsiLCAiK2pbMV0rIikifWZ1bmN0aW9uIHR0KGoseil7cmV0dXJuIGpbMF09PT16WzBdJiZqWzFdPT09elsxXX1mdW5jdGlvbiBfKGoseil7dmFyIG09alswXSxUPWpbMV0sTj16WzBdLCQ9elsxXTtyZXR1cm4gTWF0aC5hYnMobS1OKTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMobSksTWF0aC5hYnMoTikpJiZNYXRoLmFicyhULSQpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhUKSxNYXRoLmFicygkKSl9dmFyIHN0PU8saz14LGh0PWMsZnQ9dixXPXMsRj1sLFY9QSxYPWZ1bmN0aW9uKCl7dmFyIGo9bigpO3JldHVybiBmdW5jdGlvbih6LG0sVCxOLCQsSyl7dmFyIFksUTtmb3IobXx8KG09MiksVHx8KFQ9MCksTj9RPU1hdGgubWluKE4qbStULHoubGVuZ3RoKTpRPXoubGVuZ3RoLFk9VDtZPFE7WSs9bSlqWzBdPXpbWV0salsxXT16W1krMV0sJChqLGosSykseltZXT1qWzBdLHpbWSsxXT1qWzFdO3JldHVybiB6fX0oKX0sZnVuY3Rpb24oaCxlLHQpe3QucihlKTt2YXIgcj10KDEzKTt0LmQoZSwiUmVuZGVyZXIiLGZ1bmN0aW9uKCl7cmV0dXJuIHIuZGVmYXVsdH0pO3ZhciBuPXQoNDApO3QuZChlLCJGaWd1cmUyRCIsZnVuY3Rpb24oKXtyZXR1cm4gbi5kZWZhdWx0fSk7dmFyIGQ9dCg1Nik7dC5kKGUsIk1lc2gyRCIsZnVuY3Rpb24oKXtyZXR1cm4gZC5kZWZhdWx0fSk7dmFyIGc9dCgyOSk7dC5kKGUsIk1lc2hDbG91ZCIsZnVuY3Rpb24oKXtyZXR1cm4gZy5kZWZhdWx0fSk7dmFyIHU9dCgyMyk7dC5kKGUsInBhcnNlRm9udCIsZnVuY3Rpb24oKXtyZXR1cm4gdS5kZWZhdWx0fSk7dmFyIG89dCgzMSk7dC5kKGUsInBhcnNlQ29sb3IiLGZ1bmN0aW9uKCl7cmV0dXJuIG8uZGVmYXVsdH0pO3ZhciBmPXQoMjEpO3QuZChlLCJFTlYiLGZ1bmN0aW9uKCl7cmV0dXJuIGYuZGVmYXVsdH0pLHQoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KX0sZnVuY3Rpb24oaCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gSX0pO3ZhciByPXQoMTQpLG49dCgxKSxkPXQoMjApLGc9dCgyNyksdT10KDI1KSxvPXQoNDApLGY9dCg1NikseD10KDI5KSxjPXQoNTkpLHY9dCgyMSkscD10KDYzKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3QgYj17YXV0b1VwZGF0ZTohMSxwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6ITEsYnVmZmVyU2l6ZToxNTAwfSxFPWBhdHRyaWJ1dGUgdmVjMyBhX3ZlcnRleFBvc2l0aW9uOwphdHRyaWJ1dGUgdmVjMyBhX3ZlcnRleFRleHR1cmVDb29yZDsKdmFyeWluZyB2ZWMzIHZUZXh0dXJlQ29vcmQ7CnVuaWZvcm0gbWF0MyB2aWV3TWF0cml4Owp1bmlmb3JtIG1hdDMgcHJvamVjdGlvbk1hdHJpeDsKCnZvaWQgbWFpbigpIHsKICBnbF9Qb2ludFNpemUgPSAxLjA7CiAgdmVjMyBwb3MgPSBwcm9qZWN0aW9uTWF0cml4ICogdmlld01hdHJpeCAqIHZlYzMoYV92ZXJ0ZXhQb3NpdGlvbi54eSwgMS4wKTsKICBnbF9Qb3NpdGlvbiA9IHZlYzQocG9zLnh5LCAxLjAsIDEuMCk7ICAgIAogIHZUZXh0dXJlQ29vcmQgPSBhX3ZlcnRleFRleHR1cmVDb29yZDsgICAgICAgICAgICAgIAp9CmAseT1gcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7CnZhcnlpbmcgdmVjMyB2VGV4dHVyZUNvb3JkOwp1bmlmb3JtIHNhbXBsZXIyRCB1X3RleFNhbXBsZXI7CnZvaWQgbWFpbigpIHsKICBnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQodV90ZXhTYW1wbGVyLCB2VGV4dHVyZUNvb3JkLnh5KTsKfQpgLE09U3ltYm9sKCJnbFJlbmRlcmVyIiksaT1TeW1ib2woImNhbnZhc1JlbmRlcmVyIiksYT1TeW1ib2woIm9wdGlvbnMiKSxzPVN5bWJvbCgiZ2xvYmFsVHJhbnNmb3JtIiksbD1TeW1ib2woImFwcGx5R2xvYmFsVHJhbnNmb3JtIiksTz1TeW1ib2woImNhbnZhcyIpO2Z1bmN0aW9uIEEoUCl7Y29uc3QgTD1QLmdsLEQ9UC5mYm87RCYmTC5iaW5kRnJhbWVidWZmZXIoTC5GUkFNRUJVRkZFUixEKSxQLl9kcmF3KCksRCYmTC5iaW5kRnJhbWVidWZmZXIoTC5GUkFNRUJVRkZFUixudWxsKX1mdW5jdGlvbiBSKFAsTCxELEMpe2NvbnN0IFM9UC5jcmVhdGVUZXh0dXJlKEwuY2FudmFzKSxCPVtbWzAsMF0sW0QsMF0sW0QsQ10sWzAsQ10sWzAsMF1dXTtCLmNsb3NlZD0hMDtjb25zdCB3PW5ldyBmLmRlZmF1bHQoe2NvbnRvdXJzOkJ9KTt3LnNldFRleHR1cmUoUyksUC5zZXRNZXNoRGF0YShbdy5tZXNoRGF0YV0pLEEoUCksUy5kZWxldGUoKSxMLmNsZWFyUmVjdCgwLDAsRCxDKSxkZWxldGUgTC5fZmlsdGVyfWNsYXNzIEl7Y29uc3RydWN0b3IoTCxEPXt9KXtsZXQgQz1ELmNvbnRleHRUeXBlO2lmKEN8fCh0eXBlb2YgV2ViR0wyUmVuZGVyaW5nQ29udGV4dD09ImZ1bmN0aW9uIj9DPSJ3ZWJnbDIiOnR5cGVvZiBXZWJHTFJlbmRlcmluZ0NvbnRleHQ9PSJmdW5jdGlvbiI/Qz0id2ViZ2wiOkM9IjJkIiksIUwuZ2V0Q29udGV4dCl7Y29uc3QgUz1MO0w9e2dldENvbnRleHQoKXtyZXR1cm4gU30sd2lkdGg6RC53aWR0aCxoZWlnaHQ6RC5oZWlnaHR9LFMuY2FudmFzPUwsQz0iMmQifWlmKHRoaXNbT109TCxDIT09IndlYmdsIiYmQyE9PSJ3ZWJnbDIiJiZDIT09IjJkIil0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gY29udGV4dCB0eXBlICR7Q31gKTtpZihELmNvbnRleHRUeXBlPUMsdGhpc1thXT1PYmplY3QuYXNzaWduKHt9LGIsRCksQz09PSJ3ZWJnbCJ8fEM9PT0id2ViZ2wyIil7Qz09PSJ3ZWJnbDIiJiYodGhpc1thXS53ZWJnbDI9ITApO2NvbnN0IFM9bmV3IHIuZGVmYXVsdChMLHRoaXNbYV0pO0M9PT0id2ViZ2wyIiYmIVMuaXNXZWJHTDImJihELmNvbnRleHRUeXBlPSJ3ZWJnbCIpLE9iamVjdChwLmNyZWF0ZVNoYWRlcnMpKFMpLE9iamVjdChwLmFwcGx5U2hhZGVyKShTKSxPYmplY3QocC5jcmVhdGVDbG91ZFNoYWRlcnMpKFMpO2NvbnN0IEI9Uy5nbDtCLmNsZWFyQ29sb3IoMCwwLDAsMCksQi5ibGVuZEZ1bmNTZXBhcmF0ZShCLlNSQ19BTFBIQSxCLk9ORV9NSU5VU19TUkNfQUxQSEEsQi5PTkUsQi5PTkVfTUlOVVNfU1JDX0FMUEhBKSx0aGlzW01dPVN9ZWxzZSB0aGlzW2ldPW5ldyBkLmRlZmF1bHQoTCx0aGlzW2FdKTt0aGlzW3NdPVsxLDAsMCwwLDEsMCwwLDAsMV0sdGhpcy51cGRhdGVSZXNvbHV0aW9uKCl9Z2V0IGNhbnZhcygpe3JldHVybiB0aGlzW09dfWdldCBjYW52YXNSZW5kZXJlcigpe3JldHVybiB0aGlzW2ldfWdldCBnbFJlbmRlcmVyKCl7cmV0dXJuIHRoaXNbTV19Z2V0IGlzV2ViR0wyKCl7cmV0dXJuIHRoaXNbTV0mJnRoaXNbTV0uaXNXZWJHTDJ9Z2V0IG9wdGlvbnMoKXtyZXR1cm4gdGhpc1thXX1nZXQgZ2xvYmFsVHJhbnNmb3JtTWF0cml4KCl7Y29uc3QgTD10aGlzW3NdO3JldHVybltMWzBdLExbMV0sTFszXSxMWzRdLExbNl0sTFs3XV19Z2V0IHZpZXdNYXRyaXgoKXtyZXR1cm4gdGhpc1tzXX1bbF0oKXtjb25zdCBMPXRoaXNbTV18fHRoaXNbaV07aWYodGhpc1tNXSl7Y29uc3R7d2lkdGg6RCxoZWlnaHQ6Q309dGhpcy5jYW52YXM7TC51bmlmb3Jtcy52aWV3TWF0cml4PXRoaXMudmlld01hdHJpeCxMLnVuaWZvcm1zLnByb2plY3Rpb25NYXRyaXg9dGhpcy5wcm9qZWN0aW9uTWF0cml4LEwudW5pZm9ybXMudV9yZXNvbHV0aW9uPVtELENdfX11cGRhdGVSZXNvbHV0aW9uKCl7Y29uc3R7d2lkdGg6TCxoZWlnaHQ6RH09dGhpcy5jYW52YXMsQz1bMSwwLDAsMCwxLDAsLUwvMiwtRC8yLDFdLFM9WzIvTCwwLDAsMCwtMi9ELDAsMCwwLDFdLEI9bi5tYXQzLm11bHRpcGx5KEFycmF5Lm9mKDAsMCwwLDAsMCwwLDAsMCwwKSxTLEMpO3RoaXMucHJvamVjdGlvbk1hdHJpeD1CLHRoaXNbTV0mJnRoaXNbTV0uZ2wudmlld3BvcnQoMCwwLEwsRCl9Y3JlYXRlVGV4dHVyZShMLEQpe3JldHVybih0aGlzW01dfHx0aGlzW2ldKS5jcmVhdGVUZXh0dXJlKEwsRCl9bG9hZFRleHR1cmUoTCx7dXNlSW1hZ2VCaXRtYXA6RD0hMX09e30pe3JldHVybih0aGlzW01dfHx0aGlzW2ldKS5sb2FkVGV4dHVyZShMLHt1c2VJbWFnZUJpdG1hcDpEfSl9Y3JlYXRlVGV4dChMLHtmb250OkQ9IjE2cHggYXJpYWwiLGZpbGxDb2xvcjpDPW51bGwsc3Ryb2tlQ29sb3I6Uz1udWxsLHN0cm9rZVdpZHRoOkI9MX09e30pe2lmKHRoaXNbTV0pe2NvbnN0IHc9di5kZWZhdWx0LmNyZWF0ZVRleHQoTCx7Zm9udDpELGZpbGxDb2xvcjpDLHN0cm9rZUNvbG9yOlMsc3Ryb2tlV2lkdGg6Qn0pO3JldHVybntpbWFnZTp0aGlzLmNyZWF0ZVRleHR1cmUody5pbWFnZSkscmVjdDp3LnJlY3R9fXJldHVybntfaW1nOntmb250OkQsZmlsbENvbG9yOkMsc3Ryb2tlQ29sb3I6UyxzdHJva2VXaWR0aDpCLHRleHQ6TH19fWNyZWF0ZVByb2dyYW0oe3ZlcnRleDpMLGZyYWdtZW50OkQsb3B0aW9uczpDfT17fSl7aWYodGhpc1tNXSl7Y29uc3QgUz10aGlzW01dLmNvbXBpbGVTeW5jKEQsTCk7cmV0dXJuIFMuX2F0dHJpYk9wdHM9QyxTfXRocm93IG5ldyBFcnJvcigiQ29udGV4dCAyRCBjYW5ub3QgY3JlYXRlIHdlYmdsIHByb2dyYW0uIil9Y3JlYXRlUGFzc1Byb2dyYW0oe3ZlcnRleDpMPUUsZnJhZ21lbnQ6RD15LG9wdGlvbnM6Q309e30pe3JldHVybiB0aGlzLmNyZWF0ZVByb2dyYW0oe3ZlcnRleDpMLGZyYWdtZW50OkQsb3B0aW9uczpDfSl9dXNlUHJvZ3JhbShMLEQ9e30pe2lmKHRoaXNbTV0pe2NvbnN0IEM9T2JqZWN0LmFzc2lnbih7fSxMLl9hdHRyaWJPcHRzLEQpO3JldHVybiB0aGlzW01dLnVzZVByb2dyYW0oTCxDKX10aHJvdyBuZXcgRXJyb3IoIkNvbnRleHQgMkQgY2Fubm90IHVzZSB3ZWJnbCBwcm9ncmFtLiIpfWRlbGV0ZVRleHR1cmUoTCl7cmV0dXJuKHRoaXNbTV18fHRoaXNbaV0pLmRlbGV0ZVRleHR1cmUoTCl9Y2xlYXIoLi4uTCl7aWYodGhpc1tNXSl7Y29uc3QgRD10aGlzW01dLmdsO0QuY2xlYXIoRC5DT0xPUl9CVUZGRVJfQklUKX1lbHNlIHRoaXNbaV0uY2xlYXIoLi4uTCl9ZHJhd01lc2hDbG91ZChMLHtjbGVhcjpEPSExLHByb2dyYW06Qz1udWxsfT17fSl7Y29uc3QgUz10aGlzW01dfHx0aGlzW2ldLEI9Q3x8TC5wcm9ncmFtO2lmKHRoaXNbTV0pe2NvbnN0IHc9Uy5nbDtpZihEJiZ3LmNsZWFyKHcuQ09MT1JfQlVGRkVSX0JJVCksQilTLnByb2dyYW0hPT1CJiZ0aGlzLnVzZVByb2dyYW0oQix7YV9jb2xvcjp7dHlwZToiVU5TSUdORURfQllURSIsbm9ybWFsaXplOiEwfSxhX2ZpbGxDbG91ZENvbG9yOnt0eXBlOiJVTlNJR05FRF9CWVRFIixub3JtYWxpemU6ITB9LGFfc3Ryb2tlQ2xvdWRDb2xvcjp7dHlwZToiVU5TSUdORURfQllURSIsbm9ybWFsaXplOiEwfSxhX2ZyYW1lSW5kZXg6e3R5cGU6IlVOU0lHTkVEX0JZVEUiLG5vcm1hbGl6ZTohMX19KTtlbHNle2NvbnN0IEg9TC5tZXNoLm1lc2hEYXRhLEo9ISFILnVuaWZvcm1zLnVfdGV4U2FtcGxlcixxPSEhSC51bmlmb3Jtcy51X2ZpbHRlckZsYWcsVT0hIUgudW5pZm9ybXMudV9yYWRpYWxHcmFkaWVudFZlY3RvcixHPUwuaGFzQ2xvdWRDb2xvcixaPUwuaGFzQ2xvdWRGaWx0ZXIsdHQ9ISFILnVuaWZvcm1zLnVfY2xpcFNhbXBsZXI7T2JqZWN0KHAuYXBwbHlDbG91ZFNoYWRlcikoUyx7aGFzVGV4dHVyZTpKLGhhc0ZpbHRlcjpxLGhhc0dyYWRpZW50OlUsaGFzQ2xvdWRDb2xvcjpHLGhhc0Nsb3VkRmlsdGVyOlosaGFzQ2xpcFBhdGg6dHR9KX10aGlzW2xdKCksUy5zZXRNZXNoRGF0YShbTC5tZXNoRGF0YV0pLEwuYmVmb3JlUmVuZGVyJiZMLmJlZm9yZVJlbmRlcih3LEwpLEEoUyksTC5hZnRlclJlbmRlciYmTC5hZnRlclJlbmRlcih3LEwpfWVsc2UgUy5zZXRUcmFuc2Zvcm0odGhpcy5nbG9iYWxUcmFuc2Zvcm1NYXRyaXgpLFMuZHJhd01lc2hDbG91ZChMLHtjbGVhcjpELGhvb2s6ITF9KX1kcmF3TWVzaGVzKEwse2NsZWFyOkQ9ITEscHJvZ3JhbTpDPW51bGx9PXt9KXtjb25zdCBTPXRoaXNbTV18fHRoaXNbaV07aWYodGhpc1tNXSl7Y29uc3QgQj1TLmZibyx3PU9iamVjdChnLmRlZmF1bHQpKHRoaXMsTCxDPT1udWxsKSxIPVMuZ2w7RCYmSC5jbGVhcihILkNPTE9SX0JVRkZFUl9CSVQpO2NvbnN0IEo9IU9iamVjdChjLmlzVW5pdFRyYW5zZm9ybSkodGhpcy5nbG9iYWxUcmFuc2Zvcm1NYXRyaXgpO3RoaXMuX2RyYXdDYWxscz0wO2Zvcihjb25zdCBxIG9mIHcpe3RoaXMuX2RyYXdDYWxscysrO2NvbnN0IFU9Q3x8cS5wcm9ncmFtO2lmKHEgaW5zdGFuY2VvZiB4LmRlZmF1bHQpdGhpcy5kcmF3TWVzaENsb3VkKHEse2NsZWFyOkQscHJvZ3JhbTpVfSk7ZWxzZXtjb25zdHt3aWR0aDpHLGhlaWdodDpafT10aGlzLmNhbnZhcztpZihxLmJlZm9yZVJlbmRlciYmcS5iZWZvcmVSZW5kZXIoSCxxKSxxLnBhc3MubGVuZ3RoJiYoKCF0aGlzLmZib3x8dGhpcy5mYm8ud2lkdGghPT1HfHx0aGlzLmZiby5oZWlnaHQhPT1aKSYmKHRoaXMuZmJvPXt3aWR0aDpHLGhlaWdodDpaLHRhcmdldDpTLmNyZWF0ZUZCTygpLGJ1ZmZlcjpTLmNyZWF0ZUZCTygpLHN3YXAoKXtbdGhpcy50YXJnZXQsdGhpcy5idWZmZXJdPVt0aGlzLmJ1ZmZlcix0aGlzLnRhcmdldF19fSksUy5iaW5kRkJPKHRoaXMuZmJvLnRhcmdldCkpLCFVJiZxLmZpbHRlckNhbnZhcyl7T2JqZWN0KHAuYXBwbHlTaGFkZXIpKFMse2hhc1RleHR1cmU6ITB9KTtsZXQgdHQ9dGhpcy5maWx0ZXJDb250ZXh0O3R0fHwodHQ9di5kZWZhdWx0LmNyZWF0ZUNhbnZhcyhHLFopLmdldENvbnRleHQoIjJkIiksdGhpcy5maWx0ZXJDb250ZXh0PXR0KTtjb25zdCBfPUxbcS5wYWNrSW5kZXhdLHN0PV8uZmlsdGVyLGs9TFtxLnBhY2tJbmRleCsxXSxodD1MW3EucGFja0luZGV4LTFdOyghaHR8fCFodC5maWx0ZXJDYW52YXN8fGh0LmZpbHRlciE9PXN0KSYmKCFrfHwhay5maWx0ZXJDYW52YXN8fGsuZmlsdGVyIT09c3QpPyhKPyh0dC5zYXZlKCksT2JqZWN0KHUuZHJhd01lc2gyRCkoXyx0dCwhMSksdHQucmVzdG9yZSgpLE9iamVjdCh1LmFwcGx5RmlsdGVyKSh0dCxzdCkpOk9iamVjdCh1LmRyYXdNZXNoMkQpKF8sdHQsITApLHRoaXNbbF0oKSxSKFMsdHQsRyxaKSk6KEomJnR0LnNhdmUoKSxPYmplY3QodS5kcmF3TWVzaDJEKShfLHR0LCExKSxKJiZ0dC5yZXN0b3JlKCksKCFrfHwhay5maWx0ZXJDYW52YXN8fF8uZmlsdGVyIT09ay5maWx0ZXIpJiYoT2JqZWN0KHUuYXBwbHlGaWx0ZXIpKHR0LHN0KSx0aGlzW2xdKCksUihTLHR0LEcsWikpKX1lbHNle2lmKFUpUy5wcm9ncmFtIT09VSYmdGhpcy51c2VQcm9ncmFtKFUse2FfY29sb3I6e3R5cGU6IlVOU0lHTkVEX0JZVEUiLG5vcm1hbGl6ZTohMH19KTtlbHNle2NvbnN0IHR0PSEhcS51bmlmb3Jtcy51X3RleFNhbXBsZXIsXz0hIXEudW5pZm9ybXMudV9maWx0ZXJGbGFnLHN0PSEhcS51bmlmb3Jtcy51X3JhZGlhbEdyYWRpZW50VmVjdG9yLGs9ISFxLnVuaWZvcm1zLnVfY2xpcFNhbXBsZXI7T2JqZWN0KHAuYXBwbHlTaGFkZXIpKFMse2hhc1RleHR1cmU6dHQsaGFzRmlsdGVyOl8saGFzR3JhZGllbnQ6c3QsaGFzQ2xpcFBhdGg6a30pfXEuZmlsdGVyQ2FudmFzJiZjb25zb2xlLndhcm4oIlVzZXIgcHJvZ3JhbSBpZ25vcmVkIHNvbWUgZmlsdGVyIGVmZmVjdHMuIiksdGhpc1tsXSgpLFMuc2V0TWVzaERhdGEoW3FdKSxBKFMpfWlmKHEucGFzcy5sZW5ndGgpe2NvbnN0IHR0PXEucGFzcy5sZW5ndGg7cS5wYXNzLmZvckVhY2goKF8sc3QpPT57Xy5ibGVuZD1xLmVuYWJsZUJsZW5kLF8uc2V0VGV4dHVyZShTLmZiby50ZXh0dXJlKSxzdD09PXR0LTE/Uy5iaW5kRkJPKEIpOih0aGlzLmZiby5zd2FwKCksUy5iaW5kRkJPKHRoaXMuZmJvLnRhcmdldCkpLF8ucHJvZ3JhbT9TLnVzZVByb2dyYW0oXy5wcm9ncmFtKToodGhpcy5kZWZhdWx0UGFzc1Byb2dyYW09dGhpcy5kZWZhdWx0UGFzc1Byb2dyYW18fHRoaXMuY3JlYXRlUGFzc1Byb2dyYW0oKSxTLnVzZVByb2dyYW0odGhpcy5kZWZhdWx0UGFzc1Byb2dyYW0pKSxTLnNldE1lc2hEYXRhKFtfLm1lc2hEYXRhXSksSC5jbGVhcihILkNPTE9SX0JVRkZFUl9CSVQpLEEoUyl9KX1xLmFmdGVyUmVuZGVyJiZxLmFmdGVyUmVuZGVyKEgscSl9fX1lbHNlIFMuc2V0VHJhbnNmb3JtKHRoaXMuZ2xvYmFsVHJhbnNmb3JtTWF0cml4KSxTLmRyYXdNZXNoZXMoTCx7Y2xlYXI6RH0pfWRyYXdJbWFnZShMLC4uLkQpe2NvbnN0IEM9RC5sZW5ndGg7aWYoQzwyKXRocm93IG5ldyBUeXBlRXJyb3IoYEZhaWxlZCB0byBleGVjdXRlICdkcmF3SW1hZ2UnIG9uICdSZW5kZXJlcic6IDMgYXJndW1lbnRzIHJlcXVpcmVkLCBidXQgb25seSAke0QubGVuZ3RoKzF9IHByZXNlbnQuYCk7aWYoQyE9PTImJkMhPT00JiZDIT09OCl0aHJvdyBuZXcgVHlwZUVycm9yKGBGYWlsZWQgdG8gZXhlY3V0ZSAnZHJhd0ltYWdlJyBvbiAnUmVuZGVyZXInOiBWYWxpZCBhcml0aWVzIGFyZTogWzMsIDUsIDldLCBidXQgJHtELmxlbmd0aCsxfSBhcmd1bWVudHMgcHJvdmlkZWQuYCk7bGV0IFM9bnVsbCxCPW51bGw7Qz09PTI/Uz1bRFswXSxEWzFdLEwud2lkdGgsTC5oZWlnaHRdOkM9PT00P1M9RDpDPT09OCYmKEI9RC5zbGljZSgwLDQpLFM9RC5zbGljZSg0KSk7Y29uc3Qgdz10aGlzLmNyZWF0ZVRleHR1cmUoTCkse3dpZHRoOkgsaGVpZ2h0Okp9PXRoaXMuY2FudmFzLHE9bmV3IG8uZGVmYXVsdDtxLnJlY3QoU1swXSxTWzFdLEgsSik7Y29uc3QgVT1uZXcgZi5kZWZhdWx0KHEse3dpZHRoOkgsaGVpZ2h0Okp9KTtVLnNldFRleHR1cmUodyx7cmVjdDpTLHNyY1JlY3Q6Qn0pLHRoaXMuZHJhd01lc2hlcyhbVV0pLHRoaXMuZGVsZXRlVGV4dHVyZSh3KX1zZXRHbG9iYWxUcmFuc2Zvcm0oLi4uTCl7cmV0dXJuIHRoaXNbc109W0xbMF0sTFsxXSwwLExbMl0sTFszXSwwLExbNF0sTFs1XSwxXSx0aGlzfWdsb2JhbFRyYW5zZm9ybSguLi5MKXtjb25zdCBEPXRoaXNbc107cmV0dXJuIHRoaXNbc109bi5tYXQzLm11bHRpcGx5KEFycmF5Lm9mKDAsMCwwLDAsMCwwLDAsMCwwKSxELEwpLHRoaXN9Z2xvYmFsVHJhbnNsYXRlKEwsRCl7bGV0IEM9bi5tYXQzLmNyZWF0ZSgpO3JldHVybiBDPW4ubWF0My50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDAsMCwwLDApLEMsW0wsRF0pLHRoaXMuZ2xvYmFsVHJhbnNmb3JtKC4uLkMpfWdsb2JhbFJvdGF0ZShMLFtELENdPVswLDBdKXtsZXQgUz1uLm1hdDMuY3JlYXRlKCk7cmV0dXJuIFM9bi5tYXQzLnRyYW5zbGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCwwLDAsMCksUyxbRCxDXSksUz1uLm1hdDMucm90YXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwLDAsMCwwKSxTLEwpLFM9bi5tYXQzLnRyYW5zbGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCwwLDAsMCksUyxbLUQsLUNdKSx0aGlzLmdsb2JhbFRyYW5zZm9ybSguLi5TKX1nbG9iYWxTY2FsZShMLEQ9TCxbQyxTXT1bMCwwXSl7bGV0IEI9bi5tYXQzLmNyZWF0ZSgpO3JldHVybiBCPW4ubWF0My50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDAsMCwwLDApLEIsW0MsU10pLEI9bi5tYXQzLnNjYWxlKEFycmF5Lm9mKDAsMCwwLDAsMCwwLDAsMCwwKSxCLFtMLERdKSxCPW4ubWF0My50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDAsMCwwLDApLEIsWy1DLC1TXSksdGhpcy5nbG9iYWxUcmFuc2Zvcm0oLi4uQil9Z2xvYmFsU2tldyhMLEQ9TCxbQyxTXT1bMCwwXSl7bGV0IEI9bi5tYXQzLmNyZWF0ZSgpO3JldHVybiBCPW4ubWF0My50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDAsMCwwLDApLEIsW0MsU10pLEI9bi5tYXQzLm11bHRpcGx5KEFycmF5Lm9mKDAsMCwwLDAsMCwwLDAsMCwwKSxCLG4ubWF0My5mcm9tVmFsdWVzKDEsTWF0aC50YW4oRCksTWF0aC50YW4oTCksMSwwLDApKSxCPW4ubWF0My50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDAsMCwwLDApLEIsWy1DLC1TXSksdGhpcy5nbG9iYWxUcmFuc2Zvcm0oLi4uQil9dHJhbnNmb3JtUG9pbnQoTCxELEMpe2xldCBTPXRoaXMuZ2xvYmFsVHJhbnNmb3JtTWF0cml4O0MmJihTPW4ubWF0My5tdWx0aXBseShBcnJheS5vZigwLDAsMCwwLDAsMCwwLDAsMCksUyxDKSk7Y29uc3QgQj1MKlNbMF0rRCpTWzJdK1NbNF0sdz1MKlNbMV0rRCpTWzNdK1NbNV07cmV0dXJuW0Isd119fX0sZnVuY3Rpb24oaCxlLHQpe3QucihlKTt2YXIgcj10KDE1KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSksZS5kZWZhdWx0PXIuZGVmYXVsdH0sZnVuY3Rpb24oaCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gcH0pO3ZhciByPXQoMTYpLG49dCgxNyksZD10KDE4KSxnPXQoMTkpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiB1KGIsRSx5KXtyZXR1cm4gRSBpbiBiP09iamVjdC5kZWZpbmVQcm9wZXJ0eShiLEUse3ZhbHVlOnksZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTpiW0VdPXksYn1jb25zdCBvPXt9O2Z1bmN0aW9uIGYoYixFPTMpe2NvbnN0IHk9W10sTT1iLmxlbmd0aDtmb3IobGV0IGk9MDtpPE07aSsrKWklRTwyJiZ5LnB1c2goLjUqKGJbaV0rMSkpO3JldHVybiB5fWZ1bmN0aW9uIHgoYixFKXtjb25zdCB5PUUuX2J1ZmZlcnM7T2JqZWN0LnZhbHVlcyh5KS5mb3JFYWNoKE09PntiLmRlbGV0ZUJ1ZmZlcihNKX0pLEUuX2J1ZmZlcnM9e319ZnVuY3Rpb24gYyhiLEUseSl7cmV0dXJuIGIuYWN0aXZlVGV4dHVyZShiLlRFWFRVUkUwK3kpLEFycmF5LmlzQXJyYXkoRS5faW1nKT9iLmJpbmRUZXh0dXJlKGIuVEVYVFVSRV9DVUJFX01BUCxFKTpiLmJpbmRUZXh0dXJlKGIuVEVYVFVSRV8yRCxFKSxFfWNvbnN0IHY9e2ludDoiMWkiLGl2ZWMyOiIyaSIsaXZlYzM6IjNpIixpdmVjNDoiNGkiLGZsb2F0OiIxZiIsdmVjMjoiMmYiLHZlYzM6IjNmIix2ZWM0OiI0ZiIsbWF0MjoiTWF0cml4MmZ2IixtYXQzOiJNYXRyaXgzZnYiLG1hdDQ6Ik1hdHJpeDRmdiIsc2FtcGxlcjFEOiJzYW1wbGVyMUQiLHNhbXBsZXIyRDoic2FtcGxlcjJEIixzYW1wbGVyM0Q6InNhbXBsZXIzRCIsc2FtcGxlckN1YmU6InNhbXBsZXJDdWJlIixzYW1wbGVyMURTaGFkb3c6InNhbXBsZXIxRFNoYWRvdyIsc2FtcGxlcjJEU2hhZG93OiJzYW1wbGVyMkRTaGFkb3ciLHNhbXBsZXIyRFJlY3Q6InNhbXBsZXIyRFJlY3QiLHNhbXBsZXIyRFJlY3RTaGFkb3c6InNhbXBsZXIyRFJlY3RTaGFkb3cifTtjbGFzcyBwe3N0YXRpYyBhZGRMaWJzKEU9e30pe09iamVjdC5hc3NpZ24obyxFKX1zdGF0aWMgRkxPQVQoRSx5KXtyZXR1cm4gT2JqZWN0KHIucG9pbnRzVG9CdWZmZXIpKEUsRmxvYXQzMkFycmF5LHkpfXN0YXRpYyBVTlNJR05FRF9CWVRFKEUseSl7cmV0dXJuIE9iamVjdChyLnBvaW50c1RvQnVmZmVyKShFLFVpbnQ4QXJyYXkseSl9c3RhdGljIFVOU0lHTkVEX1NIT1JUKEUseSl7cmV0dXJuIE9iamVjdChyLnBvaW50c1RvQnVmZmVyKShFLFVpbnQxNkFycmF5LHkpfXN0YXRpYyBCWVRFKEUseSl7cmV0dXJuIE9iamVjdChyLnBvaW50c1RvQnVmZmVyKShFLEludDhBcnJheSx5KX1zdGF0aWMgU0hPUlQoRSx5KXtyZXR1cm4gT2JqZWN0KHIucG9pbnRzVG9CdWZmZXIpKEUsSW50MTZBcnJheSx5KX1jb25zdHJ1Y3RvcihFLHk9e30pe3RoaXMub3B0aW9ucz1PYmplY3QuYXNzaWduKHt9LHAuZGVmYXVsdE9wdGlvbnMseSksdGhpcy5jYW52YXM9RTtsZXQgTTt0aGlzLm9wdGlvbnMud2ViZ2wyJiYoTT1FLmdldENvbnRleHQoIndlYmdsMiIsdGhpcy5vcHRpb25zKSksTT09bnVsbCYmKE09T2JqZWN0KHIuc2V0dXBXZWJHTCkoRSx0aGlzLm9wdGlvbnMpLHRoaXMuYWlhX2V4dD1NLmdldEV4dGVuc2lvbigiQU5HTEVfaW5zdGFuY2VkX2FycmF5cyIpKSx0aGlzLmdsPU0sTS52aWV3cG9ydCgwLDAsRS53aWR0aCxFLmhlaWdodCksTS5jbGVhckNvbG9yKDAsMCwwLDApLE0uYmxlbmRGdW5jU2VwYXJhdGUoTS5TUkNfQUxQSEEsTS5PTkVfTUlOVVNfU1JDX0FMUEhBLE0uT05FLE0uT05FX01JTlVTX1NSQ19BTFBIQSksdGhpcy5wcm9ncmFtcz1bXSx0aGlzLl9ldmVudHM9e319Z2V0IHByb2dyYW0oKXtjb25zdCBFPXRoaXMuZ2w7cmV0dXJuIEUuZ2V0UGFyYW1ldGVyKEUuQ1VSUkVOVF9QUk9HUkFNKX1fZGVjbGFyZVVuaWZvcm0oRSx5LE09IjFmIil7Y29uc3QgaT10aGlzLmdsLGE9aS5nZXRVbmlmb3JtTG9jYXRpb24oRSx5KTtsZXQgcztjb25zdCBsPXRoaXM7aWYoL15zYW1wbGVyLy50ZXN0KE0pKXtjb25zdCBPPUUuX3NhbXBsZXJNYXAsQT1FLl9iaW5kVGV4dHVyZXM7T2JqZWN0LmRlZmluZVByb3BlcnR5KEUudW5pZm9ybXMseSx7Z2V0KCl7cmV0dXJuIHN9LHNldChSKXtzPVI7Y29uc3QgST1PW3ldIT1udWxsP09beV06QS5sZW5ndGg7QVtJXT1SLGMoaSxSLEkpLE9beV18fChPW3ldPUksaS51bmlmb3JtMWkoYSxJKSksbC5vcHRpb25zLmF1dG9VcGRhdGUmJmwudXBkYXRlKCl9LGNvbmZpZ3VyYWJsZTohMSxlbnVtZXJhYmxlOiEwfSl9ZWxzZXtjb25zdCBPPU0uaW5kZXhPZigiTWF0cml4Iik9PT0wLEE9IU8mJi92JC8udGVzdChNKSxSPWlbYHVuaWZvcm0ke019YF0uYmluZChpKTtPYmplY3QuZGVmaW5lUHJvcGVydHkoRS51bmlmb3Jtcyx5LHtnZXQoKXtyZXR1cm4gc30sc2V0KEkpe3M9SSx0eXBlb2YgST09Im51bWJlciImJihJPVtJXSksTz9SKGEsITEsSSk6QT9SKGEsSSk6UihhLC4uLkkpLGwub3B0aW9ucy5hdXRvVXBkYXRlJiZsLnVwZGF0ZSgpfSxjb25maWd1cmFibGU6ITEsZW51bWVyYWJsZTohMH0pfX1fZHJhdygpe2NvbnN0IEU9dGhpcy5wcm9ncmFtO0UubWVzaERhdGEuZm9yRWFjaCgoeSxNKT0+e2NvbnN0e3Bvc2l0aW9uczppLGNlbGxzOmEsaW5zdGFuY2VDb3VudDpzLGNlbGxzQ291bnQ6bCxhdHRyaWJ1dGVzOk8sdW5pZm9ybXM6QSx0ZXh0dXJlQ29vcmQ6UixlbmFibGVCbGVuZDpJfT15LFA9dGhpcy5nbDtsZXQgTD15Lm1vZGUhPW51bGw/eS5tb2RlOlAuVFJJQU5HTEVTO3R5cGVvZiBMPT0ic3RyaW5nIiYmKEw9UFtMXSksST9QLmVuYWJsZShQLkJMRU5EKTpQLmRpc2FibGUoUC5CTEVORCksUC5iaW5kQnVmZmVyKFAuQVJSQVlfQlVGRkVSLEUuX2J1ZmZlcnMudmVydGljZXNCdWZmZXIpLFAuYnVmZmVyRGF0YShQLkFSUkFZX0JVRkZFUixpLFAuU1RBVElDX0RSQVcpLGEmJihQLmJpbmRCdWZmZXIoUC5FTEVNRU5UX0FSUkFZX0JVRkZFUixFLl9idWZmZXJzLmNlbGxzQnVmZmVyKSxQLmJ1ZmZlckRhdGEoUC5FTEVNRU5UX0FSUkFZX0JVRkZFUixhLFAuU1RBVElDX0RSQVcpKTtjb25zdCBEPVtdO08mJk9iamVjdC52YWx1ZXMoTykuZm9yRWFjaCgoe25hbWU6UyxkYXRhOkIsZGl2aXNvcjp3fSk9PntpZihQLmJpbmRCdWZmZXIoUC5BUlJBWV9CVUZGRVIsRS5fYnVmZmVyc1tTXSksUC5idWZmZXJEYXRhKFAuQVJSQVlfQlVGRkVSLEIsUC5TVEFUSUNfRFJBVyksdyE9bnVsbCl7Y29uc3QgSD1QLmdldEF0dHJpYkxvY2F0aW9uKEUsUyk7SD49MCYmKFAuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoSCksRC5wdXNoKEgpLFAudmVydGV4QXR0cmliRGl2aXNvcj9QLnZlcnRleEF0dHJpYkRpdmlzb3IoSCx3KTp0aGlzLmFpYV9leHQmJnRoaXMuYWlhX2V4dC52ZXJ0ZXhBdHRyaWJEaXZpc29yQU5HTEUoSCx3KSl9fSksQSYmT2JqZWN0LmVudHJpZXMoQSkuZm9yRWFjaCgoW1MsQl0pPT57dGhpcy51bmlmb3Jtc1tTXT1CfSk7bGV0IEM7aWYoIWEpe2NvbnN0IFM9RS5fZGltZW5zaW9uO0M9aS5sZW5ndGgvU31pZihFLl9lbmFibGVUZXh0dXJlcyYmRS5fYnVmZmVycy50ZXhDb29yZEJ1ZmZlcil7Y29uc3QgUz1SfHxmKGksRS5fZGltZW5zaW9uKTtQLmJpbmRCdWZmZXIoUC5BUlJBWV9CVUZGRVIsRS5fYnVmZmVycy50ZXhDb29yZEJ1ZmZlciksUC5idWZmZXJEYXRhKFAuQVJSQVlfQlVGRkVSLHAuRkxPQVQoUyksUC5TVEFUSUNfRFJBVyl9cyE9bnVsbD8oYT9QLmRyYXdFbGVtZW50c0luc3RhbmNlZD9QLmRyYXdFbGVtZW50c0luc3RhbmNlZChMLGwsUC5VTlNJR05FRF9TSE9SVCwwLHMpOnRoaXMuYWlhX2V4dCYmdGhpcy5haWFfZXh0LmRyYXdFbGVtZW50c0luc3RhbmNlZEFOR0xFKEwsbCxQLlVOU0lHTkVEX1NIT1JULDAscyk6UC5kcmF3QXJyYXlzSW5zdGFuY2VkP1AuZHJhd0FycmF5c0luc3RhbmNlZChMLDAsQyxzKTp0aGlzLmFpYV9leHQuZHJhd0FycmF5c0luc3RhbmNlZEFOR0xFKEwsMCxDLHMpLEQuZm9yRWFjaChTPT57UC52ZXJ0ZXhBdHRyaWJEaXZpc29yP1AudmVydGV4QXR0cmliRGl2aXNvcihTLG51bGwpOnRoaXMuYWlhX2V4dCYmdGhpcy5haWFfZXh0LnZlcnRleEF0dHJpYkRpdmlzb3JBTkdMRShTLG51bGwpfSkpOmE/UC5kcmF3RWxlbWVudHMoTCxsLFAuVU5TSUdORURfU0hPUlQsMCk6UC5kcmF3QXJyYXlzKEwsMCxDKX0pfWdldCBpc1dlYkdMMigpe3JldHVybiB0eXBlb2YgV2ViR0wyUmVuZGVyaW5nQ29udGV4dDwidSImJnRoaXMuZ2wgaW5zdGFuY2VvZiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0fWdldCBlbmFibGVUZXh0dXJlcygpe3JldHVybiB0aGlzLnByb2dyYW0mJnRoaXMucHJvZ3JhbS5fZW5hYmxlVGV4dHVyZXN9Z2V0IHVuaWZvcm1zKCl7Y29uc3QgRT10aGlzLnByb2dyYW07aWYoIUV8fCFFLnVuaWZvcm1zKXRocm93IEVycm9yKCJObyBhdmFsaWFibGUgcHJvZ3JhbS4iKTtyZXR1cm4gRS51bmlmb3Jtc31kZWxldGVQcm9ncmFtKEUpe2NvbnN0IHk9dGhpcy5nbDt0aGlzLnByb2dyYW09PT1FJiYodGhpcy5zdGFydFJlbmRlcj0hMSx0aGlzLl9yZW5kZXJGcmFtZUlEJiYoY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5fcmVuZGVyRnJhbWVJRCksZGVsZXRlIHRoaXMuX3JlbmRlckZyYW1lSUQpLHkudXNlUHJvZ3JhbShudWxsKSk7Y29uc3QgTT10aGlzLnByb2dyYW1zLmluZGV4T2YoRSk7TT49MCYmdGhpcy5wcm9ncmFtcy5zcGxpY2UoTSwxKSx4KHksRSkseS5kZWxldGVQcm9ncmFtKEUpfXNldE1lc2hEYXRhKEUpe0FycmF5LmlzQXJyYXkoRSl8fChFPVtFXSk7Y29uc3QgeT10aGlzLnByb2dyYW07eS5tZXNoRGF0YT1FLm1hcCgoe21vZGU6TSxwb3NpdGlvbnM6aSxpbnN0YW5jZUNvdW50OmEsY2VsbHM6cyxjZWxsc0NvdW50OmwsYXR0cmlidXRlczpPLHVuaWZvcm1zOkEsdGV4dHVyZUNvb3JkOlIsZW5hYmxlQmxlbmQ6SX0pPT57Y29uc3QgUD17cG9zaXRpb25zOnAuRkxPQVQoaSksdW5pZm9ybXM6QSxlbmFibGVCbGVuZDohIUksdGV4dHVyZUNvb3JkOnAuRkxPQVQoUil9O2lmKHMmJihQLmNlbGxzPXAuVVNIT1JUKHMpLFAuY2VsbHNDb3VudD1sfHxQLmNlbGxzLmxlbmd0aCksTSE9bnVsbCYmKFAubW9kZT1NKSxhIT1udWxsKXtpZighdGhpcy5pc1dlYkdMMiYmIXRoaXMuYWlhX2V4dCl0aHJvdyBuZXcgRXJyb3IoIkNhbm5vdCB1c2UgaW5zdGFuY2VDb3VudCBpbiB0aGlzIHJlbmRlcmluZyBjb250ZXh0LCB1c2Ugd2ViZ2wyIGNvbnRleHQgaW5zdGVhZC4iKTtQLmluc3RhbmNlQ291bnQ9YX1pZihPKXtjb25zdCBMPXt9O09iamVjdC5lbnRyaWVzKE8pLmZvckVhY2goKFtELENdKT0+e2lmKCF5Ll9hdHRyaWJ1dGVbRF0peS5fYXR0cmlidXRlW0RdPSJpZ25vcmVkIjtlbHNlIGlmKHkuX2F0dHJpYnV0ZVtEXSE9PSJpZ25vcmVkIil7Y29uc3R7bmFtZTpTLHR5cGU6Qn09eS5fYXR0cmlidXRlW0RdO2xldCB3PUMuZGF0YXx8QztpZihBcnJheS5pc0FycmF5KHcpJiYodz1wW0JdKHcpKSxMW0RdPXtuYW1lOlMsZGF0YTp3fSxDLmRpdmlzb3IhPW51bGwpe2lmKCF0aGlzLmlzV2ViR0wyJiYhdGhpcy5haWFfZXh0KXRocm93IG5ldyBFcnJvcigiQ2Fubm90IHVzZSBkaXZpc29yIGluIHRoaXMgcmVuZGVyaW5nIGNvbnRleHQsIHVzZSB3ZWJnbDIgY29udGV4dCBpbnN0ZWFkLiIpO0xbRF0uZGl2aXNvcj1DLmRpdmlzb3J9fX0pLFAuYXR0cmlidXRlcz1MfXJldHVybiBQfSksdGhpcy5vcHRpb25zLmF1dG9VcGRhdGUmJnRoaXMudXBkYXRlKCl9Y3JlYXRlUHJvZ3JhbShFLHkpe2NvbnN0IE09L15ccyp1bmlmb3JtXHMrc2FtcGxlci9tZy50ZXN0KEUpO0U9PW51bGwmJihFPWQuZGVmYXVsdCkseT09bnVsbCYmKHk9TT9nLmRlZmF1bHQ6bi5kZWZhdWx0KTtjb25zdCBpPXRoaXMuZ2wsYT1PYmplY3Qoci5jcmVhdGVQcm9ncmFtKShpLHksRSk7YS5zaGFkZXJUZXh0PXt2ZXJ0ZXhTaGFkZXI6eSxmcmFnbWVudFNoYWRlcjpFfSxhLl9idWZmZXJzPXt9LGEuX2F0dHJpYnV0ZT17fSxhLnVuaWZvcm1zPXt9LGEuX3NhbXBsZXJNYXA9e30sYS5fYmluZFRleHR1cmVzPVtdO2NvbnN0IHM9bmV3IFJlZ0V4cChgKD86YXR0cmlidXRlfGluKSB2ZWMoXFxkKSAke3RoaXMub3B0aW9ucy52ZXJ0ZXhQb3NpdGlvbn1gLCJpbSIpO2xldCBsPXkubWF0Y2gocyk7bCYmKGEuX2RpbWVuc2lvbj1OdW1iZXIobFsxXSkpO2NvbnN0IE89bmV3IFJlZ0V4cChgKD86YXR0cmlidXRlfGluKSB2ZWMoXFxkKSAke3RoaXMub3B0aW9ucy52ZXJ0ZXhUZXh0dXJlQ29vcmR9YCwiaW0iKTtsPXkubWF0Y2goTyksbCYmKGEuX3RleENvb3JkU2l6ZT1OdW1iZXIobFsxXSkpO2NvbnN0IEE9L15ccyooPzphdHRyaWJ1dGV8aW4pIChcdys/KShcZCopIChcdyspL2dpbTtpZihsPXkubWF0Y2goQSksbClmb3IobGV0IFA9MDtQPGwubGVuZ3RoO1ArKyl7Y29uc3QgTD0vXlxzKig/OmF0dHJpYnV0ZXxpbikgKFx3Kz8pKFxkKikgKFx3KykvaW0sRD1sW1BdLm1hdGNoKEwpO2lmKEQmJkRbM10hPT10aGlzLm9wdGlvbnMudmVydGV4UG9zaXRpb24mJkRbM10hPT10aGlzLm9wdGlvbnMudmVydGV4VGV4dHVyZUNvb3JkKXtsZXRbLEMsUyxCXT1EO0M9PT0ibWF0IiYmKFMqKj0yKSxhLl9idWZmZXJzW0JdPWkuY3JlYXRlQnVmZmVyKCksYS5fYXR0cmlidXRlW0JdPXtuYW1lOkIsdHlwZTpDLHNpemU6TnVtYmVyKFMpfHwxfX19Y29uc3QgUj0vXlxzKnVuaWZvcm1ccysoXHcrKVxzKyhcdyspKFxbXGQrXF0pPy9tZztsPXkubWF0Y2goUil8fFtdLGw9bC5jb25jYXQoRS5tYXRjaChSKXx8W10pLGwuZm9yRWFjaChQPT57Y29uc3QgTD1QLm1hdGNoKC9eXHMqdW5pZm9ybVxzKyhcdyspXHMrKFx3KykoXFtcZCtcXSk/Lyk7bGV0W0QsQyxTXT1MLnNsaWNlKDEpO0Q9dltEXSxTPSEhUyxELmluZGV4T2YoIk1hdHJpeCIpIT09MCYmUyYmKEQrPSJ2IiksdGhpcy5fZGVjbGFyZVVuaWZvcm0oYSxDLEQpfSksYS5fYnVmZmVycy52ZXJ0aWNlc0J1ZmZlcj1pLmNyZWF0ZUJ1ZmZlcigpLGEuX2J1ZmZlcnMuY2VsbHNCdWZmZXI9aS5jcmVhdGVCdWZmZXIoKTtjb25zdCBJPWkuZ2V0QXR0cmliTG9jYXRpb24oYSx0aGlzLm9wdGlvbnMudmVydGV4VGV4dHVyZUNvb3JkKTtyZXR1cm4gYS5fZW5hYmxlVGV4dHVyZXM9ST49MCxhLl9lbmFibGVUZXh0dXJlcyYmKGEuX2J1ZmZlcnMudGV4Q29vcmRCdWZmZXI9aS5jcmVhdGVCdWZmZXIoKSksdGhpcy5wcm9ncmFtcy5wdXNoKGEpLGF9dXNlUHJvZ3JhbShFLHk9e30pe3RoaXMuc3RhcnRSZW5kZXI9ITEsdGhpcy5fcmVuZGVyRnJhbWVJRCYmKGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuX3JlbmRlckZyYW1lSUQpLGRlbGV0ZSB0aGlzLl9yZW5kZXJGcmFtZUlEKTtjb25zdCBNPXRoaXMuZ2w7TS51c2VQcm9ncmFtKEUpO2NvbnN0IGk9RS5fZGltZW5zaW9uO00uYmluZEJ1ZmZlcihNLkFSUkFZX0JVRkZFUixFLl9idWZmZXJzLnZlcnRpY2VzQnVmZmVyKTtjb25zdCBhPU0uZ2V0QXR0cmliTG9jYXRpb24oRSx0aGlzLm9wdGlvbnMudmVydGV4UG9zaXRpb24pO2lmKE0udmVydGV4QXR0cmliUG9pbnRlcihhLGksTS5GTE9BVCwhMSwwLDApLE0uZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoYSksRS5fZW5hYmxlVGV4dHVyZXMpe00uYmluZEJ1ZmZlcihNLkFSUkFZX0JVRkZFUixFLl9idWZmZXJzLnRleENvb3JkQnVmZmVyKTtjb25zdCBzPU0uZ2V0QXR0cmliTG9jYXRpb24oRSx0aGlzLm9wdGlvbnMudmVydGV4VGV4dHVyZUNvb3JkKTtNLnZlcnRleEF0dHJpYlBvaW50ZXIocyxFLl90ZXhDb29yZFNpemV8fDIsTS5GTE9BVCwhMSwwLDApLE0uZW5hYmxlVmVydGV4QXR0cmliQXJyYXkocyl9aWYoT2JqZWN0LmVudHJpZXMoRS5fYXR0cmlidXRlKS5mb3JFYWNoKChbcyxsXSk9PntpZihsIT09Imlnbm9yZWQiKXtjb25zdCBPPWwuc2l6ZSxBPXlbc118fHt9LFI9ISFBLm5vcm1hbGl6ZTtsZXQgST1BLnR5cGV8fCJGTE9BVCI7Y29uc3QgUD1BLmtleXx8cztJPT09IlVCWVRFIiYmKEk9IlVOU0lHTkVEX0JZVEUiKSxJPT09IlVTSE9SVCImJihJPSJVTlNJR05FRF9TSE9SVCIpLGwudHlwZT1JLFAmJlAhPT1zJiYoRS5fYXR0cmlidXRlW1BdPWwpLE0uYmluZEJ1ZmZlcihNLkFSUkFZX0JVRkZFUixFLl9idWZmZXJzW3NdKTtjb25zdCBMPU0uZ2V0QXR0cmliTG9jYXRpb24oRSxzKTtMPj0wJiYoTS52ZXJ0ZXhBdHRyaWJQb2ludGVyKEwsTyxNW0ldLFIsMCwwKSxNLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KEwpKX19KSwhRS5tZXNoRGF0YSl7Y29uc3Qgcz1bWy0xLC0xLDAsMV0uc2xpY2UoMCxpKSxbMSwtMSwwLDFdLnNsaWNlKDAsaSksWzEsMSwwLDFdLnNsaWNlKDAsaSksWy0xLDEsMCwxXS5zbGljZSgwLGkpXSxsPVtbMCwxLDNdLFszLDEsMl1dO3RoaXMuc2V0TWVzaERhdGEoe3Bvc2l0aW9uczpzLGNlbGxzOmx9KX1yZXR1cm4gRX1jb21waWxlU3luYyhFLHkpe0U9RXx8ZC5kZWZhdWx0O2NvbnN0IE09e307ZnVuY3Rpb24gaShPKXtPPU8ucmVwbGFjZSgvXlxzKi9tZywiIik7Y29uc3QgQT1bXSxSPU8ubWF0Y2goL14jcHJhZ21hXHMraW5jbHVkZVxzKy4qL21nKTtpZihSKXtmb3IobGV0IEk9MDtJPFIubGVuZ3RoO0krKyl7Y29uc3QgTD1SW0ldLm1hdGNoKC8oPzo8fCIpKC4qKSg/Oj58IikvKTtpZihMKXtjb25zdCBEPUxbMF0uaW5kZXhPZigiPCIpPT09MD8ibGliIjoibGluayI7bGV0IEM9TFsxXTtpZihDPT09ImdyYXBoIiYmKEM9ImdyYXBoaWNzIiksTVtDXSlBLnB1c2goYC8qIGluY2x1ZGVkICR7Q30gKi9gKTtlbHNlIGlmKE1bQ109ITAsRD09PSJsaWIiKXtjb25zdCBTPWkob1tDXSk7QS5wdXNoKFMpfWVsc2UgaWYoRD09PSJsaW5rIil0aHJvdyBuZXcgRXJyb3IoIkNhbm5vdCBsb2FkIGV4dGVybmFsIGxpbmtzIHN5bmNocm9ub3VzbHkuIFVzZSBjb21waWxlIGluc3RlYWQgb2YgY29tcGlsZVN5bmMuIil9fUEuZm9yRWFjaChJPT57Tz1PLnJlcGxhY2UoL14jcHJhZ21hXHMraW5jbHVkZVxzKy4qL20sSSl9KX1yZXR1cm4gT31jb25zdCBhPWkoRSkscz15P2koeSk6bnVsbDtyZXR1cm4gdGhpcy5jcmVhdGVQcm9ncmFtKGEscyl9YXN5bmMgY29tcGlsZShFLHkpe0U9RXx8ZC5kZWZhdWx0O2NvbnN0IE09e307YXN5bmMgZnVuY3Rpb24gaShPKXtPPU8ucmVwbGFjZSgvXlxzKi9tZywiIik7Y29uc3QgQT1bXSxSPU8ubWF0Y2goL14jcHJhZ21hXHMraW5jbHVkZVxzKy4qL21nKTtpZihSKXtmb3IobGV0IEk9MDtJPFIubGVuZ3RoO0krKyl7Y29uc3QgTD1SW0ldLm1hdGNoKC8oPzo8fCIpKC4qKSg/Oj58IikvKTtpZihMKXtjb25zdCBEPUxbMF0uaW5kZXhPZigiPCIpPT09MD8ibGliIjoibGluayI7bGV0IEM9TFsxXTtpZihDPT09ImdyYXBoIiYmKEM9ImdyYXBoaWNzIiksTVtDXSlBLnB1c2goYC8qIGluY2x1ZGVkICR7Q30gKi9gKTtlbHNlIGlmKE1bQ109ITAsRD09PSJsaWIiKXtjb25zdCBTPWF3YWl0IGkob1tDXSk7QS5wdXNoKFMpfWVsc2UgaWYoRD09PSJsaW5rIil7bGV0IFM9YXdhaXQgcC5mZXRjaFNoYWRlcihDKTtTPWF3YWl0IGkoUyksQS5wdXNoKFMpfX19QS5mb3JFYWNoKEk9PntPPU8ucmVwbGFjZSgvXiNwcmFnbWFccytpbmNsdWRlXHMrLiovbSxJKX0pfXJldHVybiBPfWNvbnN0IGE9YXdhaXQgaShFKSxzPXk/YXdhaXQgaSh5KTpudWxsO3JldHVybiB0aGlzLmNyZWF0ZVByb2dyYW0oYSxzKX1hc3luYyBsb2FkKEUseT1udWxsKXtyZXR1cm4gRT1hd2FpdCBwLmZldGNoU2hhZGVyKEUpLHkmJih5PWF3YWl0IHAuZmV0Y2hTaGFkZXIoeSkpLHRoaXMuY29tcGlsZShFLHkpfWNyZWF0ZVRleHR1cmUoRT1udWxsLHt3cmFwUzp5PXRoaXMuZ2wuQ0xBTVBfVE9fRURHRSx3cmFwVDpNPXRoaXMuZ2wuQ0xBTVBfVE9fRURHRSxtaW5GaWx0ZXI6aT10aGlzLmdsLkxJTkVBUixtYWdGaWx0ZXI6YT10aGlzLmdsLkxJTkVBUn09e30pe2NvbnN0IHM9dGhpcy5nbCxsPUFycmF5LmlzQXJyYXkoRSk/cy5URVhUVVJFX0NVQkVfTUFQOnMuVEVYVFVSRV8yRDt0aGlzLl9tYXhfdGV4dHVyZV9pbWFnZV91bml0cz10aGlzLl9tYXhfdGV4dHVyZV9pbWFnZV91bml0c3x8cy5nZXRQYXJhbWV0ZXIocy5NQVhfQ09NQklORURfVEVYVFVSRV9JTUFHRV9VTklUUykscy5hY3RpdmVUZXh0dXJlKHMuVEVYVFVSRTArdGhpcy5fbWF4X3RleHR1cmVfaW1hZ2VfdW5pdHMtMSk7Y29uc3QgTz1zLmNyZWF0ZVRleHR1cmUoKTtzLmJpbmRUZXh0dXJlKGwsTykscy5waXhlbFN0b3JlaShzLlVOUEFDS19GTElQX1lfV0VCR0wsITApO2NvbnN0e3dpZHRoOkEsaGVpZ2h0OlJ9PXRoaXMuY2FudmFzO2lmKEUpaWYobD09PXMuVEVYVFVSRV9DVUJFX01BUClmb3IobGV0IEk9MDtJPDY7SSsrKXMudGV4SW1hZ2UyRChzLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCtJLDAscy5SR0JBLHMuUkdCQSxzLlVOU0lHTkVEX0JZVEUsRVtJXSk7ZWxzZSBzLnRleEltYWdlMkQobCwwLHMuUkdCQSxzLlJHQkEscy5VTlNJR05FRF9CWVRFLEUpO2Vsc2UgaWYobD09PXMuVEVYVFVSRV9DVUJFX01BUClmb3IobGV0IEk9MDtJPDY7SSsrKXRoaXMuZ2wudGV4SW1hZ2UyRCh0aGlzLmdsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCtJLDAscy5SR0JBLEEsUiwwLHMuUkdCQSxzLlVOU0lHTkVEX0JZVEUsbnVsbCk7ZWxzZSBzLnRleEltYWdlMkQobCwwLHMuUkdCQSxBLFIsMCxzLlJHQkEscy5VTlNJR05FRF9CWVRFLG51bGwpO3JldHVybiBzLnRleFBhcmFtZXRlcmkobCxzLlRFWFRVUkVfTUlOX0ZJTFRFUixpKSxzLnRleFBhcmFtZXRlcmkobCxzLlRFWFRVUkVfTUFHX0ZJTFRFUixhKSxzLnRleFBhcmFtZXRlcmkobCxzLlRFWFRVUkVfV1JBUF9TLHkpLHMudGV4UGFyYW1ldGVyaShsLHMuVEVYVFVSRV9XUkFQX1QsTSksbD09PXMuVEVYVFVSRV9DVUJFX01BUCYmKEUud2lkdGg9RVswXS53aWR0aCxFLmhlaWdodD1FWzBdLmhlaWdodCkscy5iaW5kVGV4dHVyZShsLG51bGwpLE8uX2ltZz1FfHx7d2lkdGg6QSxoZWlnaHQ6Un0sTy5kZWxldGU9KCk9Pnt0aGlzLmRlbGV0ZVRleHR1cmUoTyl9LE99ZGVsZXRlVGV4dHVyZShFKXtjb25zdCB5PUUuX2ltZzt0aGlzLmdsLmRlbGV0ZVRleHR1cmUoRSksdHlwZW9mIHkuY2xvc2U9PSJmdW5jdGlvbiImJnkuY2xvc2UoKX1hc3luYyBsb2FkVGV4dHVyZShFLHt1c2VJbWFnZUJpdG1hcDp5PSEwfT17fSl7Y29uc3QgTT1hd2FpdCBwLmxvYWRJbWFnZShFLHt1c2VJbWFnZUJpdG1hcDp5fSk7cmV0dXJuIHRoaXMuY3JlYXRlVGV4dHVyZShNKX1jcmVhdGVGQk8oe2NvbG9yOkU9MSxibGVuZDp5PSExLGRlcHRoOk09dGhpcy5vcHRpb25zLmRlcHRoIT09ITEsc3RlbmNpbDppPSEhdGhpcy5vcHRpb25zLnN0ZW5jaWx9PXt9KXtjb25zdCBhPXRoaXMuZ2wscz1hLmNyZWF0ZUZyYW1lYnVmZmVyKCk7YS5iaW5kRnJhbWVidWZmZXIoYS5GUkFNRUJVRkZFUixzKTtjb25zdCBsPVtdO2ZvcihsZXQgUj0wO1I8RTtSKyspe2NvbnN0IEk9dGhpcy5jcmVhdGVUZXh0dXJlKCk7YS5mcmFtZWJ1ZmZlclRleHR1cmUyRChhLkZSQU1FQlVGRkVSLGEuQ09MT1JfQVRUQUNITUVOVDArUixhLlRFWFRVUkVfMkQsSSwwKSxsLnB1c2goSSl9cy50ZXh0dXJlcz1sLHMudGV4dHVyZT1sWzBdLHMuYmxlbmQ9eTtjb25zdHt3aWR0aDpPLGhlaWdodDpBfT10aGlzLmNhbnZhcztyZXR1cm4gTSYmIWkmJihzLmRlcHRoQnVmZmVyPWEuY3JlYXRlUmVuZGVyYnVmZmVyKCksYS5iaW5kUmVuZGVyYnVmZmVyKGEuUkVOREVSQlVGRkVSLHMuZGVwdGhCdWZmZXIpLGEucmVuZGVyYnVmZmVyU3RvcmFnZShhLlJFTkRFUkJVRkZFUixhLkRFUFRIX0NPTVBPTkVOVDE2LE8sQSksYS5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlcihhLkZSQU1FQlVGRkVSLGEuREVQVEhfQVRUQUNITUVOVCxhLlJFTkRFUkJVRkZFUixzLmRlcHRoQnVmZmVyKSksaSYmIU0mJihzLnN0ZW5jaWxCdWZmZXI9YS5jcmVhdGVSZW5kZXJidWZmZXIoKSxhLmJpbmRSZW5kZXJidWZmZXIoYS5SRU5ERVJCVUZGRVIscy5zdGVuY2lsQnVmZmVyKSxhLnJlbmRlcmJ1ZmZlclN0b3JhZ2UoYS5SRU5ERVJCVUZGRVIsYS5TVEVOQ0lMX0lOREVYOCxPLEEpLGEuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoYS5GUkFNRUJVRkZFUixhLlNURU5DSUxfQVRUQUNITUVOVCxhLlJFTkRFUkJVRkZFUixzLnN0ZW5jaWxCdWZmZXIpKSxNJiZpJiYocy5kZXB0aFN0ZW5jaWxCdWZmZXI9YS5jcmVhdGVSZW5kZXJidWZmZXIoKSxhLmJpbmRSZW5kZXJidWZmZXIoYS5SRU5ERVJCVUZGRVIscy5kZXB0aFN0ZW5jaWxCdWZmZXIpLGEucmVuZGVyYnVmZmVyU3RvcmFnZShhLlJFTkRFUkJVRkZFUixhLkRFUFRIX1NURU5DSUwsTyxBKSxhLmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKGEuRlJBTUVCVUZGRVIsYS5ERVBUSF9TVEVOQ0lMX0FUVEFDSE1FTlQsYS5SRU5ERVJCVUZGRVIscy5kZXB0aFN0ZW5jaWxCdWZmZXIpKSxhLmJpbmRGcmFtZWJ1ZmZlcihhLkZSQU1FQlVGRkVSLG51bGwpLHN9YmluZEZCTyhFPW51bGwpe3RoaXMuZmJvPUV9cmVuZGVyKHtjbGVhckJ1ZmZlcjpFPSEwfT17fSl7dGhpcy5zdGFydFJlbmRlcj0hMDtjb25zdCB5PXRoaXMuZ2w7bGV0IE09dGhpcy5wcm9ncmFtO018fChNPXRoaXMuY3JlYXRlUHJvZ3JhbSgpLHRoaXMudXNlUHJvZ3JhbShNKSksdGhpcy5mYm8mJnkuYmluZEZyYW1lYnVmZmVyKHkuRlJBTUVCVUZGRVIsdGhpcy5mYm8pO2NvbnN0IGk9dGhpcy5vcHRpb25zLmRlcHRoO2kmJnkuZW5hYmxlKHkuREVQVEhfVEVTVCksdGhpcy5nbC5jbGVhcih0aGlzLmdsLkNPTE9SX0JVRkZFUl9CSVR8KGk/dGhpcy5nbC5ERVBUSF9CVUZGRVJfQklUOjApfCh0aGlzLm9wdGlvbnMuc3RlbmNpbD90aGlzLmdsLlNURU5DSUxfQlVGRkVSX0JJVDowKSk7Y29uc3QgYT10aGlzLl9yZW5kZXJGcmFtZUlEO3RoaXMuX2RyYXcoKSx0aGlzLmZibyYmeS5iaW5kRnJhbWVidWZmZXIoeS5GUkFNRUJVRkZFUixudWxsKSx0aGlzLl9yZW5kZXJGcmFtZUlEPT09YSYmKHRoaXMuX3JlbmRlckZyYW1lSUQ9bnVsbCl9dXBkYXRlKCl7dGhpcy5zdGFydFJlbmRlciYmdGhpcy5fcmVuZGVyRnJhbWVJRD09bnVsbCYmKHRoaXMuX3JlbmRlckZyYW1lSUQ9cmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMucmVuZGVyLmJpbmQodGhpcykpKX19dShwLCJkZWZhdWx0T3B0aW9ucyIse3ByZXNlcnZlRHJhd2luZ0J1ZmZlcjohMCxhdXRvVXBkYXRlOiEwLHZlcnRleFBvc2l0aW9uOiJhX3ZlcnRleFBvc2l0aW9uIix2ZXJ0ZXhUZXh0dXJlQ29vcmQ6ImFfdmVydGV4VGV4dHVyZUNvb3JkIix3ZWJnbDI6ITF9KSx1KHAsIlVCWVRFIixwLlVOU0lHTkVEX0JZVEUpLHUocCwiVVNIT1JUIixwLlVOU0lHTkVEX1NIT1JUKSx1KHAsImZldGNoU2hhZGVyIixyLmZldGNoU2hhZGVyKSx1KHAsImxvYWRJbWFnZSIsci5sb2FkSW1hZ2UpfSxmdW5jdGlvbihoLGUsdCl7dC5yKGUpLHQuZChlLCJzZXR1cFdlYkdMIixmdW5jdGlvbigpe3JldHVybiBufSksdC5kKGUsImNyZWF0ZVByb2dyYW0iLGZ1bmN0aW9uKCl7cmV0dXJuIGR9KSx0LmQoZSwicG9pbnRzVG9CdWZmZXIiLGZ1bmN0aW9uKCl7cmV0dXJuIGd9KSx0LmQoZSwibG9hZEltYWdlIixmdW5jdGlvbigpe3JldHVybiBvfSksdC5kKGUsImZldGNoU2hhZGVyIixmdW5jdGlvbigpe3JldHVybiB4fSksdCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIHIoYyx2KXtjb25zdCBwPVsid2ViZ2wiLCJleHBlcmltZW50YWwtd2ViZ2wiLCJ3ZWJraXQtM2QiLCJtb3otd2ViZ2wiXTtsZXQgYj1udWxsO2ZvcihsZXQgRT0wO0U8cC5sZW5ndGg7KytFKXt0cnl7Yj1jLmdldENvbnRleHQocFtFXSx2KX1jYXRjaHt9aWYoYilicmVha31yZXR1cm4gYn1mdW5jdGlvbiBuKGMsdil7Y29uc3QgcD1yKGMsdik7aWYoIXApdGhyb3cgbmV3IEVycm9yKCJTb3JyeSwgeW91ciBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCBXZWJHTC4iKTtyZXR1cm4gcH1mdW5jdGlvbiBkKGMsdixwKXtjb25zdCBiPWMuY3JlYXRlU2hhZGVyKGMuVkVSVEVYX1NIQURFUik7aWYoYy5zaGFkZXJTb3VyY2UoYix2KSxjLmNvbXBpbGVTaGFkZXIoYiksIWMuZ2V0U2hhZGVyUGFyYW1ldGVyKGIsYy5DT01QSUxFX1NUQVRVUykpe2NvbnN0IE09YFZlcnRleCBzaGFkZXIgZmFpbGVkIHRvIGNvbXBpbGUuICBUaGUgZXJyb3IgbG9nIGlzOiR7Yy5nZXRTaGFkZXJJbmZvTG9nKGIpfWA7dGhyb3cgbmV3IEVycm9yKE0pfWNvbnN0IEU9Yy5jcmVhdGVTaGFkZXIoYy5GUkFHTUVOVF9TSEFERVIpO2lmKGMuc2hhZGVyU291cmNlKEUscCksYy5jb21waWxlU2hhZGVyKEUpLCFjLmdldFNoYWRlclBhcmFtZXRlcihFLGMuQ09NUElMRV9TVEFUVVMpKXtjb25zdCBNPWBGcmFnbWVudCBzaGFkZXIgZmFpbGVkIHRvIGNvbXBpbGUuICBUaGUgZXJyb3IgbG9nIGlzOiR7Yy5nZXRTaGFkZXJJbmZvTG9nKEUpfWA7dGhyb3cgbmV3IEVycm9yKE0pfWNvbnN0IHk9Yy5jcmVhdGVQcm9ncmFtKCk7aWYoYy5hdHRhY2hTaGFkZXIoeSxiKSxjLmF0dGFjaFNoYWRlcih5LEUpLGMubGlua1Byb2dyYW0oeSksIWMuZ2V0UHJvZ3JhbVBhcmFtZXRlcih5LGMuTElOS19TVEFUVVMpKXtjb25zdCBNPWBTaGFkZXIgcHJvZ3JhbSBmYWlsZWQgdG8gbGluay4gIFRoZSBlcnJvciBsb2cgaXM6JHtjLmdldFByb2dyYW1JbmZvTG9nKHkpfWA7dGhyb3cgbmV3IEVycm9yKE0pfXJldHVybiBjLmRlbGV0ZVNoYWRlcihiKSxjLmRlbGV0ZVNoYWRlcihFKSx5fWZ1bmN0aW9uIGcoYyx2PUZsb2F0MzJBcnJheSxwPW51bGwpe2lmKHAmJiEocCBpbnN0YW5jZW9mIHYpKXRocm93IG5ldyBUeXBlRXJyb3IoIldyb25nIGJ1ZmZlciB0eXBlLiIpO2lmKGM9PW51bGx8fGMgaW5zdGFuY2VvZiB2KXJldHVybiBjO2lmKGNbMF09PW51bGx8fGNbMF0ubGVuZ3RoPT1udWxsKXJldHVybiBwPyhwLnNldChjLDApLHApOm5ldyB2KGMpO2NvbnN0IGI9Y1swXS5sZW5ndGgsRT1jLmxlbmd0aDtwfHwocD1uZXcgdihiKkUpKTtsZXQgeT0wO2ZvcihsZXQgTT0wO008RTtNKyspZm9yKGxldCBpPTA7aTxiO2krKylwW3krK109Y1tNXVtpXTtyZXR1cm4gcH1jb25zdCB1PXt9O2Z1bmN0aW9uIG8oYyx7dXNlSW1hZ2VCaXRtYXA6dj0hMCxhbGlhczpwPW51bGx9PXt9KXtpZighdVtjXSl7aWYodHlwZW9mIEltYWdlPT0iZnVuY3Rpb24iKXtjb25zdCBiPW5ldyBJbWFnZTt0eXBlb2YgYz09InN0cmluZyImJiEodHlwZW9mIGxvY2F0aW9uPT0ib2JqZWN0IiYmL15maWxlOi8udGVzdChsb2NhdGlvbi5ocmVmKSkmJiEvXmRhdGE6Ly50ZXN0KGMpJiYoYi5jcm9zc09yaWdpbj0iYW5vbnltb3VzIiksdVtjXT1uZXcgUHJvbWlzZShFPT57Yi5vbmxvYWQ9ZnVuY3Rpb24oKXt2JiZ0eXBlb2YgY3JlYXRlSW1hZ2VCaXRtYXA9PSJmdW5jdGlvbiI/Y3JlYXRlSW1hZ2VCaXRtYXAoYix7aW1hZ2VPcmllbnRhdGlvbjoiZmxpcFkifSkudGhlbih5PT57dVtjXT15LHAmJih1W3BdPXkpLEUoeSl9KToodVtjXT1iLHAmJih1W3BdPWIpLEUoYikpfSxiLnNyYz1jfSkscCYmKHVbcF09dVtjXSl9ZWxzZSBpZih0eXBlb2YgZmV0Y2g9PSJmdW5jdGlvbiIpcmV0dXJuIGZldGNoKGMse21ldGhvZDoiR0VUIixtb2RlOiJjb3JzIixjYWNoZToiZGVmYXVsdCJ9KS50aGVuKGI9PmIuYmxvYigpKS50aGVuKGI9PmNyZWF0ZUltYWdlQml0bWFwKGIse2ltYWdlT3JpZW50YXRpb246ImZsaXBZIn0pLnRoZW4oRT0+KHVbY109RSxwJiYodVtwXT1FKSxFKSkpfXJldHVybiB1W2NdfWNvbnN0IGY9e307YXN5bmMgZnVuY3Rpb24geChjKXtpZihmW2NdKXJldHVybiBmW2NdO2NvbnN0IHY9YXdhaXQgZmV0Y2goYyk7aWYodi5zdGF0dXM+PTIwMCYmdi5zdGF0dXM8MzAwKXtjb25zdCBwPWF3YWl0IHYudGV4dCgpO3JldHVybiBmW2NdPXAscH10aHJvdyBuZXcgRXJyb3IoIlNoYWRlciBsb2FkZWQgZXJyb3IuIil9fSxmdW5jdGlvbihoLGUsdCl7dC5yKGUpLGUuZGVmYXVsdD1gYXR0cmlidXRlIHZlYzMgYV92ZXJ0ZXhQb3NpdGlvbjsKCnZvaWQgbWFpbigpIHsKICBnbF9Qb2ludFNpemUgPSAxLjA7CiAgZ2xfUG9zaXRpb24gPSB2ZWM0KGFfdmVydGV4UG9zaXRpb24sIDEpOwp9YH0sZnVuY3Rpb24oaCxlLHQpe3QucihlKSxlLmRlZmF1bHQ9YCNpZmRlZiBHTF9FUwpwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDsKI2VuZGlmCgp2b2lkIG1haW4oKSB7CiAgZ2xfRnJhZ0NvbG9yID0gdmVjNCgwLjAsIDAuMCwgMC4wLCAwLjEpOwp9YH0sZnVuY3Rpb24oaCxlLHQpe3QucihlKSxlLmRlZmF1bHQ9YGF0dHJpYnV0ZSB2ZWM0IGFfdmVydGV4UG9zaXRpb247CmF0dHJpYnV0ZSB2ZWMyIGFfdmVydGV4VGV4dHVyZUNvb3JkOwp2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDsKCnZvaWQgbWFpbigpIHsKICBnbF9Qb2ludFNpemUgPSAxLjA7CiAgZ2xfUG9zaXRpb24gPSBhX3ZlcnRleFBvc2l0aW9uOwogIHZUZXh0dXJlQ29vcmQgPSBhX3ZlcnRleFRleHR1cmVDb29yZDsKfWB9LGZ1bmN0aW9uKGgsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIGd9KTt2YXIgcj10KDIxKSxuPXQoMjUpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCBkPVN5bWJvbCgidHJhbnNmb3JtIik7Y2xhc3MgZ3tjb25zdHJ1Y3RvcihvLGYpe3RoaXMuY29udGV4dD1vLmdldENvbnRleHQoIjJkIiksdGhpcy5vcHRpb25zPWYsdGhpc1tkXT1bMSwwLDAsMSwwLDBdfWNyZWF0ZVRleHR1cmUobyl7cmV0dXJue19pbWc6b319YXN5bmMgbG9hZFRleHR1cmUobyl7Y29uc3QgZj1hd2FpdCByLmRlZmF1bHQubG9hZEltYWdlKG8se3VzZUltYWdlQml0bWFwOiExfSk7cmV0dXJuIHRoaXMuY3JlYXRlVGV4dHVyZShmKX1kZWxldGVUZXh0dXJlKG8pe3JldHVybiBvfWNsZWFyKG8sZix4LGMpe2NvbnN0IHY9dGhpcy5jb250ZXh0O289b3x8MCxmPWZ8fDAseD14fHx2LmNhbnZhcy53aWR0aC1vLGM9Y3x8di5jYW52YXMuaGVpZ2h0LWYsdi5jbGVhclJlY3QobyxmLHgsYyl9ZHJhd01lc2hDbG91ZChvLHtjbGVhcjpmPSExfT17fSl7Y29uc3QgeD1bXTtmb3IobGV0IGM9MDtjPG8uYW1vdW50O2MrKyl7Y29uc3Qgdj1vLmdldFRyYW5zZm9ybShjKTtsZXQgcD1vLmdldFRleHR1cmVGcmFtZShjKTtwJiYocD1wLl9pbWcpO2NvbnN0IGI9by5nZXRGaWx0ZXIoYykse2ZpbGw6RSxzdHJva2U6eX09by5nZXRDbG91ZFJHQkEoYyk7eC5wdXNoKHttZXNoOm8ubWVzaCxfY2xvdWRPcHRpb25zOltFLHkscCx2LGJdfSl9by5iZWZvcmVSZW5kZXImJm8uYmVmb3JlUmVuZGVyKHRoaXMuY29udGV4dCxvKSx0aGlzLmRyYXdNZXNoZXMoeCx7Y2xlYXI6Zixob29rOiExfSksby5hZnRlclJlbmRlciYmby5hZnRlclJlbmRlcih0aGlzLmNvbnRleHQsbyl9ZHJhd01lc2hlcyhvLHtjbGVhcjpmPSExLGhvb2s6eD0hMH09e30pe2NvbnN0IGM9dGhpcy5jb250ZXh0O2YmJmMuY2xlYXJSZWN0KDAsMCxjLmNhbnZhcy53aWR0aCxjLmNhbnZhcy5oZWlnaHQpO2xldCB2PW51bGw7Y29uc3R7d2lkdGg6cCxoZWlnaHQ6Yn09Yy5jYW52YXMsRT1vLmxlbmd0aDtvLmZvckVhY2goKHksTSk9PntsZXQgaSxhLHMsbCxPO3gmJnkuYmVmb3JlUmVuZGVyJiZ5LmJlZm9yZVJlbmRlcihjLHkpLHkuX2Nsb3VkT3B0aW9ucyYmKFtpLGEscyxsLE9dPXkuX2Nsb3VkT3B0aW9ucyx5PXkubWVzaCk7bGV0IEE9eS5maWx0ZXI7aWYoTyYmKEE9QT9gJHtBfSAke099YDpPKSxBJiYhdGhpcy5maWx0ZXJCdWZmZXImJnRoaXMuZmlsdGVyQnVmZmVyIT09ITEpe2NvbnN0IFI9ci5kZWZhdWx0LmNyZWF0ZUNhbnZhcyhwLGIpO1I/dGhpcy5maWx0ZXJCdWZmZXI9Ui5nZXRDb250ZXh0KCIyZCIpOnRoaXMuZmlsdGVyQnVmZmVyPSExfXYmJnYhPT1BJiYoT2JqZWN0KG4uYXBwbHlGaWx0ZXIpKHRoaXMuZmlsdGVyQnVmZmVyLHYpLGMuZHJhd0ltYWdlKHRoaXMuZmlsdGVyQnVmZmVyLmNhbnZhcywwLDAscCxiKSx0aGlzLmZpbHRlckJ1ZmZlci5jbGVhclJlY3QoMCwwLHAsYiksdj1udWxsKSxBJiZ0aGlzLmZpbHRlckJ1ZmZlcj8odGhpcy5maWx0ZXJCdWZmZXIuc2F2ZSgpLHRoaXMuZmlsdGVyQnVmZmVyLnRyYW5zZm9ybSguLi50aGlzW2RdKSxPYmplY3Qobi5kcmF3TWVzaDJEKSh5LHRoaXMuZmlsdGVyQnVmZmVyLCExLGksYSxzLGwpLHRoaXMuZmlsdGVyQnVmZmVyLnJlc3RvcmUoKSxNPT09RS0xPyhPYmplY3Qobi5hcHBseUZpbHRlcikodGhpcy5maWx0ZXJCdWZmZXIsQSksYy5kcmF3SW1hZ2UodGhpcy5maWx0ZXJCdWZmZXIuY2FudmFzLDAsMCxwLGIpLHRoaXMuZmlsdGVyQnVmZmVyLmNsZWFyUmVjdCgwLDAscCxiKSk6dj1BKTooYy5zYXZlKCksYy50cmFuc2Zvcm0oLi4udGhpc1tkXSksT2JqZWN0KG4uZHJhd01lc2gyRCkoeSxjLCExLGksYSxzLGwpLGMucmVzdG9yZSgpKSx4JiZ5LmFmdGVyUmVuZGVyJiZ5LmFmdGVyUmVuZGVyKGMseSl9KX1zZXRUcmFuc2Zvcm0obyl7dGhpc1tkXT1vfX19LGZ1bmN0aW9uKGgsZSx0KXt0LnIoZSksKGZ1bmN0aW9uKHIpe3ZhciBuPXQoMTQpLGQ9dCgyMyksZz10KDI0KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3QgdT17fTtmdW5jdGlvbiBvKHAsYil7Y29uc3R7c3R5bGU6RSx2YXJpYW50Onksd2VpZ2h0Ok0sc3RyZXRjaDppLHNpemU6YSxweExpbmVIZWlnaHQ6cyxmYW1pbHk6bH09cDtyZXR1cm4gaT09PSJub3JtYWwiP2Ake0V9ICR7eX0gJHtNfSAke2EqYn1weC8ke3MqYn1weCAke2x9YDpgJHtFfSAke3l9ICR7TX0gJHtpfSAke2EqYn1weC8ke3MqYn1weCAke2x9YH1mdW5jdGlvbiBmKHAse2ZvbnQ6YixmaWxsQ29sb3I6RSxzdHJva2VDb2xvcjp5LHN0cm9rZVdpZHRoOk0scmF0aW86aT0xLHRleHRDYW52YXM6YSxjYWNoYWJsZTpzPSExfSl7bGV0IGw7aWYocyl7bD1bcCxiLFN0cmluZyhFKSxTdHJpbmcoeSksU3RyaW5nKE0pXS5qb2luKCIjIyMiKTtjb25zdCB3PXVbbF07aWYodylyZXR1cm4gd31hfHwoYT1jKDEsMSkpO2NvbnN0IE89YS5nZXRDb250ZXh0KCIyZCIpO08uc2F2ZSgpLE8uZm9udD1iO2xldHt3aWR0aDpBfT1PLm1lYXN1cmVUZXh0KHApO08ucmVzdG9yZSgpO2NvbnN0IFI9T2JqZWN0KGQuZGVmYXVsdCkoYiksST1NYXRoLm1heChSLnB4TGluZUhlaWdodCxSLnB4SGVpZ2h0KjEuMTMpOy9pdGFsaWN8b2JsaXF1ZS8udGVzdChiKSYmKEErPUkqTWF0aC50YW4oMTUqTWF0aC5QSS8xODApKSwhRSYmIXkmJihFPSIjMDAwIik7Y29uc3QgUD1PLmNhbnZhcyxMPU1hdGguY2VpbChBKSxEPU1hdGguY2VpbChJKTtQLndpZHRoPU1hdGgucm91bmQoTCppKSxQLmhlaWdodD1NYXRoLnJvdW5kKEQqaSksTy5zYXZlKCksTy5mb250PW8oUixpKSxPLnRleHRBbGlnbj0iY2VudGVyIixPLnRleHRCYXNlbGluZT0ibWlkZGxlIjtjb25zdCBDPVAuaGVpZ2h0Ki41K1IucHhIZWlnaHQqLjA1KmksUz1QLndpZHRoKi41O2lmKEUpe2lmKEFycmF5LmlzQXJyYXkoRSkpRT1PYmplY3QoZy5kZWZhdWx0KShFKTtlbHNlIGlmKEUudmVjdG9yKXtsZXQgdztjb25zdHt2ZWN0b3I6SCxjb2xvcnM6Sn09RTtILmxlbmd0aD09PTY/dz1PLmNyZWF0ZVJhZGlhbEdyYWRpZW50KC4uLkgpOnc9Ty5jcmVhdGVMaW5lYXJHcmFkaWVudCguLi5IKSxKLmZvckVhY2goKHtvZmZzZXQ6cSxjb2xvcjpVfSk9Pnt3LmFkZENvbG9yU3RvcChxLFUpfSksRT13fU8uZmlsbFN0eWxlPUUsTy5maWxsVGV4dChwLFMsQyl9aWYoeSl7aWYoTy5saW5lV2lkdGg9TSppLEFycmF5LmlzQXJyYXkoeSkpeT1PYmplY3QoZy5kZWZhdWx0KSh5KTtlbHNlIGlmKHkudmVjdG9yKXtsZXQgdztjb25zdHt2ZWN0b3I6SCxjb2xvcnM6Sn09eTtILmxlbmd0aD09PTY/dz1PLmNyZWF0ZVJhZGlhbEdyYWRpZW50KC4uLkgpOnc9Ty5jcmVhdGVMaW5lYXJHcmFkaWVudCguLi5IKSxKLmZvckVhY2goKHtvZmZzZXQ6cSxjb2xvcjpVfSk9Pnt3LmFkZENvbG9yU3RvcChxLFUpfSkseT13fU8uc3Ryb2tlU3R5bGU9eSxPLnN0cm9rZVRleHQocCxTLEMpfU8ucmVzdG9yZSgpO2NvbnN0IEI9e2ltYWdlOmEscmVjdDpbMCwwLEwsRF19O3JldHVybiBzJiYodVtsXT1CKSxCfWxldCB4PSExO2lmKHR5cGVvZiBuYXZpZ2F0b3I9PSJvYmplY3QiJiZ0eXBlb2YgbmF2aWdhdG9yLnVzZXJBZ2VudD09InN0cmluZyIpe2NvbnN0IHA9bmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9jaHJvbWVcLyhcZCspLyk7cCYmKHg9TnVtYmVyKHBbMV0pPDcwKX1mdW5jdGlvbiBjKHAsYixFPXt9KXtjb25zdCB5PUUub2Zmc2NyZWVufHwheCYmRS5vZmZzY3JlZW4hPT0hMTtsZXQgTTtyZXR1cm4gdHlwZW9mIHI8InUiJiZ0eXBlb2Ygci5jcmVhdGVDYW52YXM9PSJmdW5jdGlvbiI/TT1yLmNyZWF0ZUNhbnZhcyhwLGIsRSk6eSYmdHlwZW9mIE9mZnNjcmVlbkNhbnZhcz09ImZ1bmN0aW9uIj9NPW5ldyBPZmZzY3JlZW5DYW52YXMocCxiKTooTT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJjYW52YXMiKSxNLndpZHRoPXAsTS5oZWlnaHQ9YiksTX1jb25zdCB2PXtjcmVhdGVDYW52YXM6YyxjcmVhdGVUZXh0OmYsbG9hZEltYWdlOm4uZGVmYXVsdC5sb2FkSW1hZ2V9O2UuZGVmYXVsdD12fSkuY2FsbCh0aGlzLHQoMjIpKX0sZnVuY3Rpb24oaCxlKXt2YXIgdDt0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9KCk7dHJ5e3Q9dHx8bmV3IEZ1bmN0aW9uKCJyZXR1cm4gdGhpcyIpKCl9Y2F0Y2h7dHlwZW9mIHdpbmRvdz09Im9iamVjdCImJih0PXdpbmRvdyl9aC5leHBvcnRzPXR9LGZ1bmN0aW9uKGgsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIEV9KSx0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gcih5LE0pe2lmKHR5cGVvZiB5PT0ic3RyaW5nIil7Y29uc3Qgcz15LnRyaW0oKS5tYXRjaCgvXihbXGQuXSspKHB4fHB0fHBjfGlufGNtfG1tfGVtfGV4fHJlbXxxfHZ3fHZofHZtYXh8dm1pbnwlKSQvKTtzP3k9e3NpemU6cGFyc2VGbG9hdChzWzFdKSx1bml0OnNbMl19Onk9e3NpemU6cGFyc2VJbnQoeSwxMCksdW5pdDoicHgifX1sZXR7c2l6ZTppLHVuaXQ6YX09eTtpZihhPT09InB0IilpLz0uNzU7ZWxzZSBpZihhPT09InBjIilpKj0xNjtlbHNlIGlmKGE9PT0iaW4iKWkqPTk2O2Vsc2UgaWYoYT09PSJjbSIpaSo9OTYvMi41NDtlbHNlIGlmKGE9PT0ibW0iKWkqPTk2LzI1LjQ7ZWxzZSBpZihhPT09ImVtInx8YT09PSJyZW0ifHxhPT09ImV4Iil7aWYoIU0mJnR5cGVvZiBnZXRDb21wdXRlZFN0eWxlPT0iZnVuY3Rpb24iJiZ0eXBlb2YgZG9jdW1lbnQ8InUiKXtjb25zdCBzPWdldENvbXB1dGVkU3R5bGUoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KS5mb250U2l6ZTtNPXIocywxNil9aSo9TSxhPT09ImV4IiYmKGkvPTIpfWVsc2UgaWYoYT09PSJxIilpKj05Ni8yNS40LzQ7ZWxzZSBpZihhPT09InZ3Inx8YT09PSJ2aCIpe2lmKHR5cGVvZiBkb2N1bWVudDwidSIpe2NvbnN0IHM9YT09PSJ2dyI/ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoOmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQ7aSo9cy8xMDB9fWVsc2UgaWYoKGE9PT0idm1heCJ8fGE9PT0idm1pbiIpJiZ0eXBlb2YgZG9jdW1lbnQ8InUiKXtjb25zdCBzPWRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCxsPWRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQ7YT09PSJ2bWF4Ij9pKj1NYXRoLm1heChzLGwpLzEwMDppKj1NYXRoLm1pbihzLGwpLzEwMH1yZXR1cm4gaX1jb25zdCBuPSJib2xkfGJvbGRlcnxsaWdodGVyfFsxLTldMDAiLGQ9Iml0YWxpY3xvYmxpcXVlIixnPSJzbWFsbC1jYXBzIix1PSJ1bHRyYS1jb25kZW5zZWR8ZXh0cmEtY29uZGVuc2VkfGNvbmRlbnNlZHxzZW1pLWNvbmRlbnNlZHxzZW1pLWV4cGFuZGVkfGV4cGFuZGVkfGV4dHJhLWV4cGFuZGVkfHVsdHJhLWV4cGFuZGVkIixvPSJweHxwdHxwY3xpbnxjbXxtbXxlbXxleHxyZW18cXx2d3x2aHx2bWF4fHZtaW58JSIsZj1gJyhbXiddKyknfCIoW14iXSspInwoW1xcdy1dfFvkuIAt6b6lXSkrYCx4PW5ldyBSZWdFeHAoYCgke259KSArYCwiaSIpLGM9bmV3IFJlZ0V4cChgKCR7ZH0pICtgLCJpIiksdj1uZXcgUmVnRXhwKGAoJHtnfSkgK2AsImkiKSxwPW5ldyBSZWdFeHAoYCgke3V9KSArYCwiaSIpLGI9bmV3IFJlZ0V4cCgiKFtcXGRcXC5dKykoIitvKyIpKD86XFwvKFtcXGRcXC5dKykoIitvKyIpKT8gKigoPzoiK2YrIikoICosICooPzoiK2YrIikpKikiKTtmdW5jdGlvbiBFKHksTSl7Y29uc3QgaT1iLmV4ZWMoeSk7aWYoIWkpcmV0dXJuO2NvbnN0IGE9cGFyc2VGbG9hdChpWzNdKSxzPXt3ZWlnaHQ6Im5vcm1hbCIsc3R5bGU6Im5vcm1hbCIsc3RyZXRjaDoibm9ybWFsIix2YXJpYW50OiJub3JtYWwiLHNpemU6cGFyc2VGbG9hdChpWzFdKSx1bml0OmlbMl0sbGluZUhlaWdodDpOdW1iZXIuaXNGaW5pdGUoYSk/YTp2b2lkIDAsbGluZUhlaWdodFVuaXQ6aVs0XSxmYW1pbHk6aVs1XS5yZXBsYWNlKC8gKiwgKi9nLCIsIil9LGw9eS5zdWJzdHJpbmcoMCxpLmluZGV4KSxPPXguZXhlYyhsKSxBPWMuZXhlYyhsKSxSPXYuZXhlYyhsKSxJPXAuZXhlYyhsKTtyZXR1cm4gTyYmKHMud2VpZ2h0PU9bMV0pLEEmJihzLnN0eWxlPUFbMV0pLFImJihzLnZhcmlhbnQ9UlsxXSksSSYmKHMuc3RyZXRjaD1JWzFdKSxzLnB4SGVpZ2h0PXIoe3NpemU6cy5zaXplLHVuaXQ6cy51bml0fSxNKSxzLnB4TGluZUhlaWdodD1yKHtzaXplOnMubGluZUhlaWdodHx8cy5zaXplLHVuaXQ6cy5saW5lSGVpZ2h0VW5pdHx8cy51bml0fSxNKSxzfX0sZnVuY3Rpb24oaCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gcn0pLHQoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiByKG4pe3JldHVybmByZ2JhKCR7bi5tYXAoKGQsZyk9Pmc8Mz9NYXRoLnJvdW5kKGQqMjU1KTpkKS5qb2luKCl9KWB9fSxmdW5jdGlvbihoLGUsdCl7dC5yKGUpLHQuZChlLCJhcHBseUZpbHRlciIsZnVuY3Rpb24oKXtyZXR1cm4gdX0pLHQuZChlLCJkcmF3TWVzaDJEIixmdW5jdGlvbigpe3JldHVybiBmfSk7dmFyIHI9dCgxKSxuPXQoMjQpLGQ9dCgyMyksZz10KDI2KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gdSh4LGMpe2NvbnN0IHY9eC5jYW52YXM7eC5zYXZlKCkseC5maWx0ZXI9Yyx4LmRyYXdJbWFnZSh2LDAsMCx2LndpZHRoLHYuaGVpZ2h0KSx4LnJlc3RvcmUoKX1mdW5jdGlvbiBvKHgsYyl7Y29uc3Qgdj0vcmdiYVwoKFxkKyksKFxkKyksKFxkKyksKFxkKylcKS87eD14Lm1hdGNoKHYpLnNsaWNlKDEsNSkubWFwKE51bWJlciksYz1jLm1hdGNoKHYpLnNsaWNlKDEsNSkubWFwKE51bWJlcik7Y29uc3QgcD1bXSxiPWNbM107Zm9yKGxldCBFPTA7RTw0O0UrKylwW0VdPU9iamVjdChnLm1peCkoeFtFXSxjW0VdLGIpO3JldHVybmByZ2JhKCR7cC5qb2luKCl9KWB9ZnVuY3Rpb24gZih4LGMsdj0hMCxwPW51bGwsYj1udWxsLEU9bnVsbCx5PW51bGwpe2Muc2F2ZSgpO2xldCBNPSExLGk9ITE7aWYoYy5nbG9iYWxBbHBoYT14LmdldE9wYWNpdHkoKSx4Ll91cGRhdGVNYXRyaXgmJngudHJhbnNmb3JtU2NhbGUveC5jb250b3Vycy5zY2FsZT4xLjUmJnguYWNjdXJhdGUoeC50cmFuc2Zvcm1TY2FsZSkseC5saW5lV2lkdGgpe2xldCBsPXguZ3JhZGllbnQmJnguZ3JhZGllbnQuc3Ryb2tlO2lmKGwpe2NvbnN0e3ZlY3RvcjpPLGNvbG9yczpBfT1sO2lmKE8ubGVuZ3RoPT09NilsPWMuY3JlYXRlUmFkaWFsR3JhZGllbnQoLi4uTyk7ZWxzZSBpZihPLmxlbmd0aD09PTQpbD1jLmNyZWF0ZUxpbmVhckdyYWRpZW50KC4uLk8pO2Vsc2UgaWYoTy5sZW5ndGg9PT0zKWw9Yy5jcmVhdGVDaXJjdWxhckdyYWRpZW50KC4uLk8pO2Vsc2UgdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCB2ZWN0b3IgZGltZW5zaW9uLiIpO0EuZm9yRWFjaCgoe29mZnNldDpSLGNvbG9yOkl9KT0+e2xldCBQPU9iamVjdChuLmRlZmF1bHQpKEkpO2ImJihQPW8oUCxiKSksbC5hZGRDb2xvclN0b3AoUixQKX0pLGMuc3Ryb2tlU3R5bGU9bCxNPSEwfWVsc2UgeC5zdHJva2VTdHlsZSYmKGI/Yy5zdHJva2VTdHlsZT1vKHguc3Ryb2tlU3R5bGUsYik6Yy5zdHJva2VTdHlsZT14LnN0cm9rZVN0eWxlLE09ITApfU0mJihjLmxpbmVXaWR0aD14LmxpbmVXaWR0aCxjLmxpbmVKb2luPXgubGluZUpvaW4sYy5saW5lQ2FwPXgubGluZUNhcCxjLm1pdGVyTGltaXQ9eC5taXRlckxpbWl0LHgubGluZURhc2gmJihjLnNldExpbmVEYXNoKHgubGluZURhc2gpLHgubGluZURhc2hPZmZzZXQmJihjLmxpbmVEYXNoT2Zmc2V0PXgubGluZURhc2hPZmZzZXQpKSk7bGV0IGE9eC5ncmFkaWVudCYmeC5ncmFkaWVudC5maWxsO2lmKGEpe2NvbnN0e3ZlY3RvcjpsLGNvbG9yczpPfT1hO2lmKGwubGVuZ3RoPT09NilhPWMuY3JlYXRlUmFkaWFsR3JhZGllbnQoLi4ubCk7ZWxzZSBpZihsLmxlbmd0aD09PTQpYT1jLmNyZWF0ZUxpbmVhckdyYWRpZW50KC4uLmwpO2Vsc2UgaWYobC5sZW5ndGg9PT0zKWE9Yy5jcmVhdGVDaXJjdWxhckdyYWRpZW50KC4uLmwpO2Vsc2UgdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCB2ZWN0b3IgZGltZW5zaW9uLiIpO08uZm9yRWFjaCgoe29mZnNldDpBLGNvbG9yOlJ9KT0+e2xldCBJPU9iamVjdChuLmRlZmF1bHQpKFIpO2ImJihJPW8oSSxiKSksYS5hZGRDb2xvclN0b3AoQSxJKX0pLGMuZmlsbFN0eWxlPWEsaT0hMH1lbHNlIHguZmlsbFN0eWxlJiYocD9jLmZpbGxTdHlsZT1vKHguZmlsbFN0eWxlLHApOmMuZmlsbFN0eWxlPXguZmlsbFN0eWxlLGk9ITApO2lmKHkmJmMudHJhbnNmb3JtKC4uLnkpLGMudHJhbnNmb3JtKC4uLngudHJhbnNmb3JtTWF0cml4KSx4LmNsaXBQYXRoKXtjb25zdCBsPXguY2xpcFBhdGgsTz1uZXcgUGF0aDJEKGwpO2MuY2xpcChPKX1jb25zdCBzPXguY29udG91cnMubGVuZ3RoO2lmKHguY29udG91cnMuZm9yRWFjaCgobCxPKT0+e2NvbnN0IEE9bC5sZW5ndGgsUj1BPjEmJnIudmVjMi5lcXVhbHMobFswXSxsW0EtMV0pLEk9Tz09PXMtMSYmeC50ZXh0dXJlO2lmKGwmJkE+MCl7aWYoaXx8TXx8SSl7Yy5iZWdpblBhdGgoKSxjLm1vdmVUbyguLi5sWzBdKTtmb3IobGV0IFA9MTtQPEE7UCsrKVA9PT1BLTEmJlI/Yy5jbG9zZVBhdGgoKTpjLmxpbmVUbyguLi5sW1BdKX1pZihpJiZjLmZpbGwoeC5maWxsUnVsZSksSSl7Yy5zYXZlKCksYy5jbGlwKCk7bGV0e2ltYWdlOlAsb3B0aW9uczpMfT14LnRleHR1cmU7aWYoRSYmKFA9RSksTC5yZXBlYXQmJmNvbnNvbGUud2FybigiQ29udGV4dCAyRCBub3Qgc3VwcG9ydGVkIGltYWdlIHJlcGVhdCB5ZXQuIiksUC5mb250KXtMLnNjYWxlJiZjb25zb2xlLndhcm4oIkNvbnRleHQgMkQgbm90IHN1cHBvcnRlZCB0ZXh0IHNjYWxlIHlldC4iKSxMLnNyY1JlY3QmJmNvbnNvbGUud2FybigiQ29udGV4dCAyRCBub3Qgc3VwcG9ydGVkIHRleHQgc3JjUmVjdCB5ZXQuIik7bGV0e2ZvbnQ6RCxmaWxsQ29sb3I6QyxzdHJva2VDb2xvcjpTLHN0cm9rZVdpZHRoOkIsdGV4dDp3fT1QOyFDJiYhUyYmKEM9IiMwMDAiKSxBcnJheS5pc0FycmF5KEMpJiYoQz1PYmplY3Qobi5kZWZhdWx0KShDKSksQXJyYXkuaXNBcnJheShTKSYmKFM9T2JqZWN0KG4uZGVmYXVsdCkoUykpLGMuZm9udD1EO2NvbnN0e3dpZHRoOkh9PWMubWVhc3VyZVRleHQodyksSj1PYmplY3QoZC5kZWZhdWx0KShEKSxxPU1hdGgubWF4KEoucHhMaW5lSGVpZ2h0LEoucHhIZWlnaHQqMS4xMyk7Yy50ZXh0QWxpZ249ImNlbnRlciIsYy50ZXh0QmFzZWxpbmU9Im1pZGRsZSI7Y29uc3QgVT1MLnJlY3QsRz1VWzBdK3EqLjUrSi5weEhlaWdodCouMDYsWj1VWzFdK0gqLjU7VVsyXSE9bnVsbCYmYy5zY2FsZShVWzJdL0gsVVszXS9xKSxDJiYoYy5maWxsU3R5bGU9QyxjLmZpbGxUZXh0KHcsWixHKSksUyYmKGMubGluZVdpZHRoPUIsYy5zdHJva2VTdHlsZT1TLGMuc3Ryb2tlVGV4dCh3LFosRykpfWVsc2V7bGV0IEQ9TC5yZWN0O2NvbnN0IEM9TC5zcmNSZWN0O0wuc2NhbGUmJihEPVswLDAsYy5jYW52YXMud2lkdGgsYy5jYW52YXMuaGVpZ2h0XSksTC5yb3RhdGVkJiZEJiYoRD1bLURbMV0sRFswXSxEWzNdLERbMl1dKSxDJiYoRD1EfHxbMCwwLENbMl0sQ1szXV0pLEwucm90YXRlZCYmKGMudHJhbnNsYXRlKDAsRD9EWzJdOlAud2lkdGgpLGMucm90YXRlKC0uNSpNYXRoLlBJKSksQz9jLmRyYXdJbWFnZShQLC4uLkMsLi4uRCk6RD9jLmRyYXdJbWFnZShQLC4uLkQpOmMuZHJhd0ltYWdlKFAsMCwwKX1jLnJlc3RvcmUoKX1NJiZjLnN0cm9rZSgpfX0pLGMucmVzdG9yZSgpLHYpe2NvbnN0IGw9eC5maWx0ZXI7bCYmdShjLGwpfX19LGZ1bmN0aW9uKGgsZSx0KXt0LnIoZSksdC5kKGUsImNsYW1wIixmdW5jdGlvbigpe3JldHVybiByfSksdC5kKGUsIm1peCIsZnVuY3Rpb24oKXtyZXR1cm4gbn0pLHQuZChlLCJ0cmFuc2Zvcm1Qb2ludCIsZnVuY3Rpb24oKXtyZXR1cm4gZH0pLHQoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiByKGcsdSxvKXtyZXR1cm4gdT5vJiYoW3Usb109W28sdV0pLGc8dT91Omc+bz9vOmd9ZnVuY3Rpb24gbihnLHUsbyl7cmV0dXJuIGcqKDEtbykrdSpvfWZ1bmN0aW9uIGQoZyx1KXtjb25zdFtvLGZdPWc7cmV0dXJuW28qdVswXStmKnVbMl0rdVs0XSxvKnVbMV0rZip1WzNdK3VbNV1dfX0sZnVuY3Rpb24oaCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gb30pO3ZhciByPXQoMjgpLG49dCgyOSk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIGQoZix4LGMpe2NvbnN0IHY9Zi51bmlmb3Jtc3x8e30scD14LnVuaWZvcm1zfHx7fTtpZih2LnVfdGV4U2FtcGxlciYmcC51X3RleFNhbXBsZXImJnYudV90ZXhTYW1wbGVyIT09cC51X3RleFNhbXBsZXIpcmV0dXJuITE7Y29uc3QgYj1PYmplY3Qua2V5cyh2KSxFPU9iamVjdC5rZXlzKHApLHk9Yi5pbmRleE9mKCJ1X3RleFNhbXBsZXIiKSxNPUUuaW5kZXhPZigidV90ZXhTYW1wbGVyIik7aWYoeT49MCYmYi5zcGxpY2UoeSwxKSxNPj0wJiZFLnNwbGljZShNLDEpLGIubGVuZ3RoIT09RS5sZW5ndGgpcmV0dXJuITE7Y29uc3QgaT1iLmV2ZXJ5KGE9Pntjb25zdCBzPXZbYV0sbD1wW2FdO2lmKHM9PT1sKXJldHVybiEwO2lmKHMubGVuZ3RoJiZsLmxlbmd0aCYmcy5sZW5ndGg9PT1sLmxlbmd0aCl7Zm9yKGxldCBPPTA7TzxzLmxlbmd0aDtPKyspaWYoc1tPXSE9PWxbT10pcmV0dXJuITE7cmV0dXJuITB9cmV0dXJuITF9KTtpZihpKXtpZih2LnVfdGV4U2FtcGxlciYmIXAudV90ZXhTYW1wbGVyKXguc2V0VGV4dHVyZSh2LnVfdGV4U2FtcGxlcix7aGlkZGVuOiEwfSk7ZWxzZSBpZighdi51X3RleFNhbXBsZXImJnAudV90ZXhTYW1wbGVyKWZvcihsZXQgYT0wO2E8Yy5sZW5ndGg7YSsrKWNbYV0uc2V0VGV4dHVyZShwLnVfdGV4U2FtcGxlcix7aGlkZGVuOiEwfSl9cmV0dXJuIGl9Y29uc3QgZz17fTtmdW5jdGlvbiB1KGYseCl7aWYoZi5sZW5ndGgpe2NvbnN0IGM9T2JqZWN0KHIuZGVmYXVsdCkoZixnKTtyZXR1cm4gYy5lbmFibGVCbGVuZD14LGZbMF0uZmlsdGVyQ2FudmFzJiYoYy5maWx0ZXJDYW52YXM9ITApLGMucGFja0luZGV4PWZbMF0ucGFja0luZGV4LGMucGFja0xlbmd0aD1mLmxlbmd0aCxjLmJlZm9yZVJlbmRlcj1mWzBdLmJlZm9yZVJlbmRlcixjLnBhc3M9ZlswXS5wYXNzLGMuYWZ0ZXJSZW5kZXI9ZltmLmxlbmd0aC0xXS5hZnRlclJlbmRlcixmLmxlbmd0aD0wLGN9fWZ1bmN0aW9uKm8oZix4LGM9ITEpe2NvbnN0IHY9W10scD1mLm9wdGlvbnMuYnVmZmVyU2l6ZTtsZXQgYj0wLEU9ITE7Zm9yKGxldCB5PTA7eTx4Lmxlbmd0aDt5Kyspe2NvbnN0IE09eFt5XTtpZihNIGluc3RhbmNlb2Ygbi5kZWZhdWx0KXYubGVuZ3RoJiYoeWllbGQgdSh2LEUpKSxiPTAsRT0hMSx5aWVsZCBNO2Vsc2V7Y29uc3QgaT1NLm1lc2hEYXRhO2lmKGkuY2xpcFBhdGgmJiFpLnVuaWZvcm1zLnVfY2xpcFNhbXBsZXIpe2NvbnN0IHM9Zi5jcmVhdGVUZXh0dXJlKGkuY2xpcFBhdGgpO2kudW5pZm9ybXMudV9jbGlwU2FtcGxlcj1zfWxldCBhPTA7aWYoKCFjfHwhTS5jYW5JZ25vcmUoKSkmJmkmJmkucG9zaXRpb25zLmxlbmd0aCl7TS5wYWNrSW5kZXg9eTtjb25zdCBzPU0uZmlsdGVyQ2FudmFzO2lmKGE9aS5wb3NpdGlvbnMubGVuZ3RoLHN8fGIrYT5wKXYubGVuZ3RoJiYoeWllbGQgdSh2LEUpKSxiPTAsRT0hMTtlbHNlIGlmKGIpe2NvbnN0IGw9dlt2Lmxlbmd0aC0xXTtsJiYobC5maWx0ZXJDYW52YXN8fGwuYWZ0ZXJSZW5kZXJ8fE0uYmVmb3JlUmVuZGVyfHxsLnBhc3MubGVuZ3RofHxNLnBhc3MubGVuZ3RofHxsLnByb2dyYW0hPT1NLnByb2dyYW18fCFkKGwsTSx2KSkmJih5aWVsZCB1KHYsRSksYj0wLEU9ITEpfXYucHVzaChNKSxFPUV8fE0uZW5hYmxlQmxlbmQsYis9YX15PT09eC5sZW5ndGgtMSYmdi5sZW5ndGgmJih5aWVsZCB1KHYsRSkpfX19fSxmdW5jdGlvbihoLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBkfSksdCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IHI9e1VOU0lHTkVEX0JZVEU6VWludDhBcnJheSxVTlNJR05FRF9TSE9SVDpVaW50MTZBcnJheSxCWVRFOkludDhBcnJheSxTSE9SVDpJbnQxNkFycmF5LEZMT0FUOkZsb2F0MzJBcnJheX07ZnVuY3Rpb24gbihnLHUpe2xldCBvPTAsZj0wLHg9MCxjPTAsdj0wLHA9MCxiPTA7Y29uc3QgRT1nWzBdLnByb2dyYW07Zm9yKGxldCB5PTA7eTxnLmxlbmd0aDt5Kyspe2NvbnN0IE09Z1t5XS5tZXNoRGF0YTtpZihNKXtiKz1NLnBvc2l0aW9ucy5sZW5ndGg7Y29uc3QgaT1NLnBvc2l0aW9uc1swXS5sZW5ndGg7bys9TS5wb3NpdGlvbnMubGVuZ3RoKmksZis9TS5jZWxscy5sZW5ndGgqMyxwKz1NLmF0dHJpYnV0ZXMuYV9jb2xvci5sZW5ndGgqNDtjb25zdCBhPU0udGV4dHVyZUNvb3JkO2EmJih4Kz1hLmxlbmd0aCphWzBdLmxlbmd0aCk7Y29uc3Qgcz1NLmF0dHJpYnV0ZXMuYV9zb3VyY2VSZWN0O3MmJihjKz1zLmxlbmd0aCo0KTtjb25zdCBsPU0uYXR0cmlidXRlcy5hX2NsaXBVVjtsJiYodis9bC5sZW5ndGgqMil9fWlmKCghdS5wb3NpdGlvbnN8fHUucG9zaXRpb25zLmxlbmd0aDxvKSYmKHUucG9zaXRpb25zPW5ldyBGbG9hdDMyQXJyYXkobykpLCghdS5jZWxsc3x8dS5jZWxscy5sZW5ndGg8ZikmJih1LmNlbGxzPW5ldyBVaW50MTZBcnJheShmKSkseCYmKCF1LnRleHR1cmVDb29yZHx8dS50ZXh0dXJlQ29vcmQubGVuZ3RoPHgpJiYodS50ZXh0dXJlQ29vcmQ9bmV3IEZsb2F0MzJBcnJheSh4KSksKCF1LmFfY29sb3J8fHUuYV9jb2xvci5sZW5ndGg8cCkmJih1LmFfY29sb3I9bmV3IFVpbnQ4QXJyYXkocCkpLGMmJighdS5hX3NvdXJjZVJlY3R8fHUuYV9zb3VyY2VSZWN0Lmxlbmd0aDxjKSYmKHUuYV9zb3VyY2VSZWN0PW5ldyBGbG9hdDMyQXJyYXkoYykpLHYmJighdS5hX2NsaXBVVnx8dS5hX2NsaXBVVi5sZW5ndGg8dikmJih1LmFfY2xpcFVWPW5ldyBGbG9hdDMyQXJyYXkodikpLEUpe2NvbnN0IHk9T2JqZWN0LmVudHJpZXMoRS5fYXR0cmlidXRlKSxNPUUuX2F0dHJpYk9wdHN8fHt9O2ZvcihsZXQgaT0wO2k8eS5sZW5ndGg7aSsrKXtjb25zdFthLHNdPXlbaV07aWYoYSE9PSJhX2NvbG9yIiYmYSE9PSJhX3NvdXJjZVJlY3QiJiZzIT09Imlnbm9yZWQiKXtjb25zdCBsPU1bYV0/TVthXS50eXBlOiJGTE9BVCIsTz1yW2xdLEE9cy5zaXplKmI7KCF1W2FdfHx1W2FdLmxlbmd0aDxBKSYmKHVbYV09bmV3IE8oQSkpfX19cmV0dXJuIHV9ZnVuY3Rpb24gZChnLHUpe2xldCBvPVtdLGY9W10seD1bXSxjPVtdLHY9W10scD1bXSxiPTAsRT0wO2NvbnN0IHk9Z1swXT9nWzBdLnVuaWZvcm1zfHx7fTp7fSxNPWdbMF0/Z1swXS5wcm9ncmFtOm51bGw7dSYmKG4oZyx1KSxmPXUuY2VsbHMsbz11LnBvc2l0aW9ucyx4PXUudGV4dHVyZUNvb3JkLGM9dS5hX2NvbG9yLHY9dS5hX3NvdXJjZVJlY3QscD11LmFfY2xpcFVWKTtsZXQgaT0hMSxhPSExO2NvbnN0IHM9e307Zm9yKGxldCBPPTA7TzxnLmxlbmd0aDtPKyspe2xldCBBPWdbT107aWYoQSl7aWYoQS5tZXNoRGF0YSYmKEE9QS5tZXNoRGF0YSksdSl7Y29uc3QgST1BLnBvc2l0aW9ucztmb3IobGV0IFA9MDtQPEkubGVuZ3RoO1ArKyl7Y29uc3QgTD1JW1BdLEQ9MyooYitQKTtmb3IobGV0IEM9MDtDPEwubGVuZ3RoO0MrKylvW0QrQ109TFtDXX19ZWxzZSBvLnB1c2goLi4uQS5wb3NpdGlvbnMpO2NvbnN0IFI9QS5jZWxscztmb3IobGV0IEk9MDtJPFIubGVuZ3RoO0krKyl7Y29uc3QgUD1SW0ldO2lmKHUpe2NvbnN0IEw9MyooRStJKTtmW0xdPVBbMF0rYixmW0wrMV09UFsxXStiLGZbTCsyXT1QWzJdK2J9ZWxzZSBmLnB1c2goW1BbMF0rYixQWzFdK2IsUFsyXStiXSl9aWYodSl7Y29uc3QgST1BLmF0dHJpYnV0ZXMuYV9jb2xvcjtmb3IobGV0IFA9MDtQPEkubGVuZ3RoO1ArKyl7Y29uc3QgTD1JW1BdLEQ9NCooYitQKTtjW0RdPUxbMF0sY1tEKzFdPUxbMV0sY1tEKzJdPUxbMl0sY1tEKzNdPUxbM119fWVsc2UgYy5wdXNoKC4uLkEuYXR0cmlidXRlcy5hX2NvbG9yKTtpZihBLmF0dHJpYnV0ZXMuYV9zb3VyY2VSZWN0KWlmKGk9ITAsdSl7Y29uc3QgST1BLmF0dHJpYnV0ZXMuYV9zb3VyY2VSZWN0O2ZvcihsZXQgUD0wO1A8SS5sZW5ndGg7UCsrKXtjb25zdCBMPUlbUF0sRD00KihiK1ApO3ZbRF09TFswXSx2W0QrMV09TFsxXSx2W0QrMl09TFsyXSx2W0QrM109TFszXX19ZWxzZSB2LnB1c2goLi4uQS5hdHRyaWJ1dGVzLmFfc291cmNlUmVjdCk7aWYoQS5hdHRyaWJ1dGVzLmFfY2xpcFVWKWlmKGE9ITAsdSl7Y29uc3QgST1BLmF0dHJpYnV0ZXMuYV9jbGlwVVY7Zm9yKGxldCBQPTA7UDxJLmxlbmd0aDtQKyspe2NvbnN0IEw9SVtQXSxEPTIqKGIrUCk7cFtEXT1MWzBdLHBbRCsxXT1MWzFdfX1lbHNlIHAucHVzaCguLi5BLmF0dHJpYnV0ZXMuYV9jbGlwVVYpO2lmKEEudGV4dHVyZUNvb3JkKWlmKHUpe2NvbnN0IEk9QS50ZXh0dXJlQ29vcmQ7Zm9yKGxldCBQPTA7UDxJLmxlbmd0aDtQKyspe2NvbnN0IEw9SVtQXSxEPTMqKGIrUCk7Zm9yKGxldCBDPTA7QzxMLmxlbmd0aDtDKyspeFtEK0NdPUxbQ119fWVsc2UgeC5wdXNoKC4uLkEudGV4dHVyZUNvb3JkKTtpZihNKXtjb25zdCBJPU9iamVjdC5lbnRyaWVzKE0uX2F0dHJpYnV0ZSk7Zm9yKGxldCBQPTA7UDxJLmxlbmd0aDtQKyspe2NvbnN0W0wsRF09SVtQXTtpZihMIT09ImFfY29sb3IiJiZMIT09ImFfc291cmNlUmVjdCImJkQhPT0iaWdub3JlZCIpaWYoc1tMXT1bXSx1KXtzW0xdPXVbTF07Y29uc3QgQz1BLmF0dHJpYnV0ZXNbTF0sUz1DWzBdLmxlbmd0aDtmb3IobGV0IEI9MDtCPEMubGVuZ3RoO0IrKyl7Y29uc3Qgdz1DW0JdLEg9UyooYitCKTtmb3IobGV0IEo9MDtKPHcubGVuZ3RoO0orKylzW0xdW0grSl09d1tKXX19ZWxzZSBzW0xdLnB1c2goLi4uQS5hdHRyaWJ1dGVzW0xdKX19Yis9QS5wb3NpdGlvbnMubGVuZ3RoLEUrPUEuY2VsbHMubGVuZ3RofX1zLmFfY29sb3I9YyxpJiZ2JiZ2Lmxlbmd0aD4wJiYocy5hX3NvdXJjZVJlY3Q9dik7Y29uc3QgbD17cG9zaXRpb25zOm8sY2VsbHM6ZixhdHRyaWJ1dGVzOnMsdW5pZm9ybXM6eSxjZWxsc0NvdW50OkUqMyxwcm9ncmFtOk19O3JldHVybiB4JiZ4Lmxlbmd0aCYmKGwudGV4dHVyZUNvb3JkPXgpLGEmJnAubGVuZ3RoPjAmJihzLmFfY2xpcFVWPXApLGx9fSxmdW5jdGlvbihoLGUsdCl7dC5yKGUpO3ZhciByPXQoMSksbj10KDMwKSxkPXQoMjYpLGc9dCgzMSk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIHUocyxsKXt2YXIgTz1PYmplY3Qua2V5cyhzKTtpZihPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKXt2YXIgQT1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpO2wmJihBPUEuZmlsdGVyKGZ1bmN0aW9uKFIpe3JldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHMsUikuZW51bWVyYWJsZX0pKSxPLnB1c2guYXBwbHkoTyxBKX1yZXR1cm4gT31mdW5jdGlvbiBvKHMpe2Zvcih2YXIgbD0xO2w8YXJndW1lbnRzLmxlbmd0aDtsKyspe3ZhciBPPWFyZ3VtZW50c1tsXSE9bnVsbD9hcmd1bWVudHNbbF06e307bCUyP3UoT2JqZWN0KE8pLCEwKS5mb3JFYWNoKGZ1bmN0aW9uKEEpe2YocyxBLE9bQV0pfSk6T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnM/T2JqZWN0LmRlZmluZVByb3BlcnRpZXMocyxPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhPKSk6dShPYmplY3QoTykpLmZvckVhY2goZnVuY3Rpb24oQSl7T2JqZWN0LmRlZmluZVByb3BlcnR5KHMsQSxPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sQSkpfSl9cmV0dXJuIHN9ZnVuY3Rpb24gZihzLGwsTyl7cmV0dXJuIGwgaW4gcz9PYmplY3QuZGVmaW5lUHJvcGVydHkocyxsLHt2YWx1ZTpPLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6c1tsXT1PLHN9Y29uc3QgeD1TeW1ib2woIm1lc2giKSxjPVN5bWJvbCgiY291bnQiKSx2PVN5bWJvbCgiYmxlbmQiKSxwPVN5bWJvbCgiZmlsdGVyIiksYj1TeW1ib2woInRleHR1cmVzIiksRT1TeW1ib2woInRleHR1cmVPcHRpb25zIikseT1TeW1ib2woImNsb3VkQ29sb3IiKSxNPVN5bWJvbCgiY2xvdWRGaWx0ZXIiKSxpPVN5bWJvbCgiYnVmZmVyIik7ZnVuY3Rpb24gYShzLGw9bnVsbCl7Y29uc3QgTz1uZXcgRmxvYXQzMkFycmF5KDMqcyksQT1uZXcgRmxvYXQzMkFycmF5KDMqcyksUj1uZXcgRmxvYXQzMkFycmF5KDQqcyksST1uZXcgRmxvYXQzMkFycmF5KDQqcyksUD1uZXcgRmxvYXQzMkFycmF5KDQqcyksTD1uZXcgRmxvYXQzMkFycmF5KDQqcyksRD1uZXcgRmxvYXQzMkFycmF5KDQqcyksQz1uZXcgVWludDhBcnJheShzKSxTPW5ldyBVaW50OEFycmF5KDQqcyksQj1uZXcgVWludDhBcnJheSg0KnMpO3JldHVybiBsJiYoTy5zZXQobC50cmFuc2Zvcm0wLDApLEEuc2V0KGwudHJhbnNmb3JtMSwwKSxSLnNldChsLmNvbG9yMCwwKSxJLnNldChsLmNvbG9yMSwwKSxQLnNldChsLmNvbG9yMiwwKSxMLnNldChsLmNvbG9yMywwKSxELnNldChsLmNvbG9yNCwwKSxDLnNldChsLmZyYW1lSW5kZXgsMCksUy5zZXQobC5maWxsQ29sb3IsMCksQi5zZXQobC5zdHJva2VDb2xvciwwKSkse2J1ZmZlclNpemU6cyx0cmFuc2Zvcm0wOk8sdHJhbnNmb3JtMTpBLGNvbG9yMDpSLGNvbG9yMTpJLGNvbG9yMjpQLGNvbG9yMzpMLGNvbG9yNDpELGZyYW1lSW5kZXg6QyxmaWxsQ29sb3I6UyxzdHJva2VDb2xvcjpCfX1lLmRlZmF1bHQ9Y2xhc3N7Y29uc3RydWN0b3IocyxsPTEse2J1ZmZlcjpPPTFlM309e30pe089TWF0aC5tYXgoTyxsKSx0aGlzW2NdPWwsdGhpc1t4XT1zLHRoaXNbaV09YShPKSx0aGlzW2JdPVtdLHRoaXNbcF09W10sdGhpc1t5XT0hMSx0aGlzW01dPSExLHRoaXNbdl09ITEsdGhpcy5pbml0QnVmZmVyKCl9aW5pdEJ1ZmZlcihzPTApe2NvbnN0IGw9dGhpc1tjXTtmb3IobGV0IE89cztPPGw7TysrKXRoaXNbaV0udHJhbnNmb3JtMC5zZXQoWzEsMCwwXSxPKjMpLHRoaXNbaV0udHJhbnNmb3JtMS5zZXQoWzAsMSwwXSxPKjMpLHRoaXNbaV0uZnJhbWVJbmRleC5zZXQoWy0xXSxPKSx0aGlzW2ldLmZpbGxDb2xvci5zZXQoWzAsMCwwLDBdLE8qNCksdGhpc1tpXS5zdHJva2VDb2xvci5zZXQoWzAsMCwwLDBdLE8qNCksdGhpcy5zZXRDb2xvclRyYW5zZm9ybShPLG51bGwpfWdldCBidWZmZXJTaXplKCl7cmV0dXJuIHRoaXNbaV0uYnVmZmVyU2l6ZX1nZXQgbWVzaCgpe3JldHVybiB0aGlzW3hdfXNldCBtZXNoKHMpe3RoaXNbeF09cyx0aGlzW2JdJiZ0aGlzLnNldFRleHR1cmVGcmFtZXModGhpc1tiXSx0aGlzW0VdKX1nZXQgaGFzQ2xvdWRDb2xvcigpe3JldHVybiB0aGlzW3ldfWdldCBoYXNDbG91ZEZpbHRlcigpe3JldHVybiB0aGlzW01dfV9nZXRGaWx0ZXIocyl7cmV0dXJuIHRoaXNbcF1bc109dGhpc1twXVtzXXx8W10sdGhpc1twXVtzXX1nZXRGaWx0ZXIocyl7cmV0dXJuIHRoaXMuX2dldEZpbHRlcihzKS5qb2luKCIgIil9Z2V0IGVuYWJsZUJsZW5kKCl7cmV0dXJuIHRoaXNbeF0uZW5hYmxlQmxlbmR8fHRoaXNbdl19Y2FuSWdub3JlKCl7cmV0dXJuIHRoaXNbeF0uY2FuSWdub3JlKCl9ZGVsZXRlKHMpe2lmKHM+PXRoaXNbY118fHM8MCl0aHJvdyBuZXcgRXJyb3IoIk91dCBvZiByYW5nZS4iKTtjb25zdHt0cmFuc2Zvcm0wOmwsdHJhbnNmb3JtMTpPLGNvbG9yMDpBLGNvbG9yMTpSLGNvbG9yMjpJLGNvbG9yMzpQLGNvbG9yNDpMLGZyYW1lSW5kZXg6RCxmaWxsQ29sb3I6QyxzdHJva2VDb2xvcjpTfT10aGlzW2ldO2wuc2V0KGwuc3ViYXJyYXkoMyoocysxKSksMypzKSxPLnNldChPLnN1YmFycmF5KDMqKHMrMSkpLDMqcyksQS5zZXQoQS5zdWJhcnJheSg0KihzKzEpKSw0KnMpLFIuc2V0KFIuc3ViYXJyYXkoNCoocysxKSksNCpzKSxJLnNldChJLnN1YmFycmF5KDQqKHMrMSkpLDQqcyksUC5zZXQoUC5zdWJhcnJheSg0KihzKzEpKSw0KnMpLEwuc2V0KEwuc3ViYXJyYXkoNCoocysxKSksNCpzKSxELnNldChELnN1YmFycmF5KHMrMSkscyksQy5zZXQoQy5zdWJhcnJheSg0KihzKzEpKSw0KnMpLFMuc2V0KFMuc3ViYXJyYXkoNCoocysxKSksNCpzKTtmb3IoY29uc3QgQiBpbiB0aGlzW3BdKUI9PT1zP2RlbGV0ZSB0aGlzW3BdW0JdOkI+cyYmKHRoaXNbcF1bQi0xXT10aGlzW3BdW0JdLGRlbGV0ZSB0aGlzW3BdW0JdKTt0aGlzW2NdLS19c2V0Q29sb3JUcmFuc2Zvcm0ocyxsKXtpZihzPj10aGlzW2NdfHxzPDApdGhyb3cgbmV3IEVycm9yKCJPdXQgb2YgcmFuZ2UuIik7cyo9NDtjb25zdHtjb2xvcjA6Tyxjb2xvcjE6QSxjb2xvcjI6Uixjb2xvcjM6SSxjb2xvcjQ6UH09dGhpc1tpXTtyZXR1cm4gbCE9bnVsbD8oTy5zZXQoW2xbMF0sbFs1XSxsWzEwXSxsWzE1XV0scyksQS5zZXQoW2xbMV0sbFs2XSxsWzExXSxsWzE2XV0scyksUi5zZXQoW2xbMl0sbFs3XSxsWzEyXSxsWzE3XV0scyksSS5zZXQoW2xbM10sbFs4XSxsWzEzXSxsWzE4XV0scyksUC5zZXQoW2xbNF0sbFs5XSxsWzE0XSxsWzE5XV0scyksdGhpc1t2XT10aGlzW3ZdfHxsWzE4XTwxLHRoaXNbTV09ITApOihPLnNldChbMSwwLDAsMF0scyksQS5zZXQoWzAsMSwwLDBdLHMpLFIuc2V0KFswLDAsMSwwXSxzKSxJLnNldChbMCwwLDAsMV0scyksUC5zZXQoWzAsMCwwLDBdLHMpKSx0aGlzfWdldENvbG9yVHJhbnNmb3JtKHMpe2lmKHM+PXRoaXNbY118fHM8MCl0aHJvdyBuZXcgRXJyb3IoIk91dCBvZiByYW5nZS4iKTtzKj00O2NvbnN0e2NvbG9yMDpsLGNvbG9yMTpPLGNvbG9yMjpBLGNvbG9yMzpSLGNvbG9yNDpJfT10aGlzW2ldO3JldHVybltsW3NdLE9bc10sQVtzXSxSW3NdLElbc10sbFtzKzFdLE9bcysxXSxBW3MrMV0sUltzKzFdLElbcysxXSxsW3MrMl0sT1tzKzJdLEFbcysyXSxSW3MrMl0sSVtzKzJdLGxbcyszXSxPW3MrM10sQVtzKzNdLFJbcyszXSxJW3MrM11dfXRyYW5zZm9ybUNvbG9yKHMsbCl7bGV0IE89dGhpcy5nZXRDb2xvclRyYW5zZm9ybShzKTtyZXR1cm4gTz1PYmplY3Qobi5tdWx0aXBseSkoTyxsKSx0aGlzLnNldENvbG9yVHJhbnNmb3JtKHMsTyksdGhpc31zZXRGaWxsQ29sb3IocyxsKXtpZihzPj10aGlzW2NdfHxzPDApdGhyb3cgbmV3IEVycm9yKCJPdXQgb2YgcmFuZ2UuIik7dHlwZW9mIGw9PSJzdHJpbmciJiYobD1PYmplY3QoZy5kZWZhdWx0KShsKSksbFszXT4wJiYodGhpc1t5XT0hMCksdGhpc1tpXS5maWxsQ29sb3Iuc2V0KGwubWFwKE89Pk1hdGgucm91bmQoMjU1Kk8pKSw0KnMpfXNldFN0cm9rZUNvbG9yKHMsbCl7aWYocz49dGhpc1tjXXx8czwwKXRocm93IG5ldyBFcnJvcigiT3V0IG9mIHJhbmdlLiIpO3R5cGVvZiBsPT0ic3RyaW5nIiYmKGw9T2JqZWN0KGcuZGVmYXVsdCkobCkpLGxbM10+MCYmKHRoaXNbeV09ITApLHRoaXNbaV0uc3Ryb2tlQ29sb3Iuc2V0KGwubWFwKE89Pk1hdGgucm91bmQoMjU1Kk8pKSw0KnMpfWdldENsb3VkUkdCQShzKXtpZihzPj10aGlzW2NdfHxzPDApdGhyb3cgbmV3IEVycm9yKCJPdXQgb2YgcmFuZ2UuIik7cyo9NDtjb25zdHtmaWxsQ29sb3I6bCxzdHJva2VDb2xvcjpPfT10aGlzW2ldLEE9W2xbc10sbFtzKzFdLGxbcysyXSxsW3MrM11dLFI9W09bc10sT1tzKzFdLE9bcysyXSxPW3MrM11dO3JldHVybiBBWzNdLz0yNTUsUlszXS89MjU1LHtmaWxsOmByZ2JhKCR7QS5qb2luKCl9KWAsc3Ryb2tlOmByZ2JhKCR7Ui5qb2luKCl9KWB9fWdyYXlzY2FsZShzLGwpe3RoaXMudHJhbnNmb3JtQ29sb3IocyxPYmplY3Qobi5ncmF5c2NhbGUpKGwpKSx0aGlzLl9nZXRGaWx0ZXIocykucHVzaChgZ3JheXNjYWxlKCR7MTAwKmx9JSlgKX1icmlnaHRuZXNzKHMsbCl7dGhpcy50cmFuc2Zvcm1Db2xvcihzLE9iamVjdChuLmJyaWdodG5lc3MpKGwpKSx0aGlzLl9nZXRGaWx0ZXIocykucHVzaChgYnJpZ2h0bmVzcygkezEwMCpsfSUpYCl9c2F0dXJhdGUocyxsKXt0aGlzLnRyYW5zZm9ybUNvbG9yKHMsT2JqZWN0KG4uc2F0dXJhdGUpKGwpKSx0aGlzLl9nZXRGaWx0ZXIocykucHVzaChgc2F0dXJhdGUoJHsxMDAqbH0lKWApfWNvbnRyYXN0KHMsbCl7dGhpcy50cmFuc2Zvcm1Db2xvcihzLE9iamVjdChuLmNvbnRyYXN0KShsKSksdGhpcy5fZ2V0RmlsdGVyKHMpLnB1c2goYGNvbnRyYXN0KCR7MTAwKmx9JSlgKX1pbnZlcnQocyxsKXt0aGlzLnRyYW5zZm9ybUNvbG9yKHMsT2JqZWN0KG4uaW52ZXJ0KShsKSksdGhpcy5fZ2V0RmlsdGVyKHMpLnB1c2goYGludmVydCgkezEwMCpsfSUpYCl9c2VwaWEocyxsKXt0aGlzLnRyYW5zZm9ybUNvbG9yKHMsT2JqZWN0KG4uc2VwaWEpKGwpKSx0aGlzLl9nZXRGaWx0ZXIocykucHVzaChgc2VwaWEoJHsxMDAqbH0lKWApfW9wYWNpdHkocyxsKXt0aGlzLnRyYW5zZm9ybUNvbG9yKHMsT2JqZWN0KG4ub3BhY2l0eSkobCkpLHRoaXMuX2dldEZpbHRlcihzKS5wdXNoKGBvcGFjaXR5KCR7MTAwKmx9JSlgKX1odWVSb3RhdGUocyxsKXt0aGlzLnRyYW5zZm9ybUNvbG9yKHMsT2JqZWN0KG4uaHVlUm90YXRlKShsKSksdGhpcy5fZ2V0RmlsdGVyKHMpLnB1c2goYGh1ZS1yb3RhdGUoJHtsfWRlZylgKX1zZXRUcmFuc2Zvcm0ocyxsKXtpZihzPj10aGlzW2NdfHxzPDApdGhyb3cgbmV3IEVycm9yKCJPdXQgb2YgcmFuZ2UuIik7cyo9MyxsPT1udWxsJiYobD1bMSwwLDAsMSwwLDBdKTtjb25zdHt0cmFuc2Zvcm0wOk8sdHJhbnNmb3JtMTpBfT10aGlzW2ldO3JldHVybiBPLnNldChbbFswXSxsWzJdLGxbNF1dLHMpLEEuc2V0KFtsWzFdLGxbM10sbFs1XV0scyksdGhpc31nZXRUcmFuc2Zvcm0ocyl7aWYocz49dGhpc1tjXXx8czwwKXRocm93IG5ldyBFcnJvcigiT3V0IG9mIHJhbmdlLiIpO3MqPTM7Y29uc3R7dHJhbnNmb3JtMDpsLHRyYW5zZm9ybTE6T309dGhpc1tpXTtyZXR1cm5bbFtzXSxPW3NdLGxbcysxXSxPW3MrMV0sbFtzKzJdLE9bcysyXV19Z2V0VGV4dHVyZUZyYW1lKHMpe3JldHVybiB0aGlzW2JdW3RoaXNbaV0uZnJhbWVJbmRleFtzXV19c2V0VGV4dHVyZUZyYW1lcyhzPVtdLGw9e30pe2lmKHMubGVuZ3RoPjEyKXRocm93IG5ldyBFcnJvcigiTWF4IGZyYW1lcyBleGNlZWQuIEFsbG93IDEyIGZyYW1lcy4iKTtzLmxlbmd0aCYmdGhpc1t4XS5zZXRUZXh0dXJlKHNbMF0sbCksdGhpc1tiXT1zLHRoaXNbRV09bH1zZXRGcmFtZUluZGV4KHMsbCl7aWYocz49dGhpc1tjXXx8czwwKXRocm93IG5ldyBFcnJvcigiT3V0IG9mIHJhbmdlLiIpO2NvbnN0IE89dGhpc1tiXS5sZW5ndGg7aWYoTzw9MCl0aHJvdyBuZXcgRXJyb3IoIk5vIGZyYW1lcyIpO3RoaXNbaV0uZnJhbWVJbmRleFtzXT1sJU99Z2V0IGFtb3VudCgpe3JldHVybiB0aGlzW2NdfXNldCBhbW91bnQocyl7Y29uc3QgbD10aGlzW2NdO3MhPT1sJiYocz50aGlzW2ldLmJ1ZmZlclNpemUmJih0aGlzW2ldPWEoTWF0aC5tYXgocyx0aGlzW2ldLmJ1ZmZlclNpemUrMWUzKSx0aGlzW2ldKSksdGhpc1tjXT1zLHM+bCYmdGhpcy5pbml0QnVmZmVyKGwpKX1nZXQgbWVzaERhdGEoKXtjb25zdHthdHRyaWJ1dGVzOnMsY2VsbHM6bCxwb3NpdGlvbnM6Tyx0ZXh0dXJlQ29vcmQ6QSx1bmlmb3JtczpSfT10aGlzW3hdLm1lc2hEYXRhLEk9dGhpc1tiXSxQPXthdHRyaWJ1dGVzOm8oe30scyksY2VsbHM6bCxwb3NpdGlvbnM6Tyx0ZXh0dXJlQ29vcmQ6QSx1bmlmb3JtczpvKHt9LFIpLGluc3RhbmNlQ291bnQ6dGhpc1tjXSxlbmFibGVCbGVuZDp0aGlzLmVuYWJsZUJsZW5kfTtJLmxlbmd0aCYmSS5mb3JFYWNoKChHLFopPT57UC51bmlmb3Jtc1tgdV90ZXhGcmFtZSR7Wn1gXT1HfSk7Y29uc3R7dHJhbnNmb3JtMDpMLHRyYW5zZm9ybTE6RCxjb2xvcjA6Qyxjb2xvcjE6Uyxjb2xvcjI6Qixjb2xvcjM6dyxjb2xvcjQ6SCxmaWxsQ29sb3I6SixzdHJva2VDb2xvcjpxLGZyYW1lSW5kZXg6VX09dGhpc1tpXTtyZXR1cm4gdGhpc1t4XS51bmlmb3Jtcy51X3RleFNhbXBsZXImJihQLmF0dHJpYnV0ZXMuYV9mcmFtZUluZGV4PXtkYXRhOlUsZGl2aXNvcjoxfSksUC5hdHRyaWJ1dGVzLmFfdHJhbnNmb3JtMD17ZGF0YTpMLGRpdmlzb3I6MX0sUC5hdHRyaWJ1dGVzLmFfdHJhbnNmb3JtMT17ZGF0YTpELGRpdmlzb3I6MX0sUC5hdHRyaWJ1dGVzLmFfY29sb3JDbG91ZDA9e2RhdGE6QyxkaXZpc29yOjF9LFAuYXR0cmlidXRlcy5hX2NvbG9yQ2xvdWQxPXtkYXRhOlMsZGl2aXNvcjoxfSxQLmF0dHJpYnV0ZXMuYV9jb2xvckNsb3VkMj17ZGF0YTpCLGRpdmlzb3I6MX0sUC5hdHRyaWJ1dGVzLmFfY29sb3JDbG91ZDM9e2RhdGE6dyxkaXZpc29yOjF9LFAuYXR0cmlidXRlcy5hX2NvbG9yQ2xvdWQ0PXtkYXRhOkgsZGl2aXNvcjoxfSx0aGlzLmhhc0Nsb3VkQ29sb3ImJihQLmF0dHJpYnV0ZXMuYV9maWxsQ2xvdWRDb2xvcj17ZGF0YTpKLGRpdmlzb3I6MX0sUC5hdHRyaWJ1dGVzLmFfc3Ryb2tlQ2xvdWRDb2xvcj17ZGF0YTpxLGRpdmlzb3I6MX0pLFB9c2V0UHJvZ3JhbShzKXt0aGlzW3hdLnNldFByb2dyYW0ocyl9Z2V0IHByb2dyYW0oKXtyZXR1cm4gdGhpc1t4XS5wcm9ncmFtfXRyYW5zZm9ybShzLGwpe2NvbnN0IE89dGhpcy5nZXRUcmFuc2Zvcm0ocyk7cmV0dXJuIGw9ci5tYXQyZC5tdWx0aXBseShBcnJheS5vZigwLDAsMCwwLDAsMCksTyxsKSx0aGlzLnNldFRyYW5zZm9ybShzLGwpLHRoaXN9dHJhbnNsYXRlKHMsW2wsT10pe2xldCBBPXIubWF0MmQuY3JlYXRlKCk7cmV0dXJuIEE9ci5tYXQyZC50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDApLEEsW2wsT10pLHRoaXMudHJhbnNmb3JtKHMsQSl9cm90YXRlKHMsbCxbTyxBXT1bMCwwXSl7bGV0IFI9ci5tYXQyZC5jcmVhdGUoKTtyZXR1cm4gUj1yLm1hdDJkLnRyYW5zbGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCksUixbTyxBXSksUj1yLm1hdDJkLnJvdGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCksUixsKSxSPXIubWF0MmQudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxSLFstTywtQV0pLHRoaXMudHJhbnNmb3JtKHMsUil9c2NhbGUocyxbbCxPPWxdLFtBLFJdPVswLDBdKXtsZXQgST1yLm1hdDJkLmNyZWF0ZSgpO3JldHVybiBJPXIubWF0MmQudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxJLFtBLFJdKSxJPXIubWF0MmQuc2NhbGUoQXJyYXkub2YoMCwwLDAsMCwwLDApLEksW2wsT10pLEk9ci5tYXQyZC50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDApLEksWy1BLC1SXSksdGhpcy50cmFuc2Zvcm0ocyxJKX1za2V3KHMsW2wsTz1sXSxbQSxSXT1bMCwwXSl7bGV0IEk9ci5tYXQyZC5jcmVhdGUoKTtyZXR1cm4gST1yLm1hdDJkLnRyYW5zbGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCksSSxbQSxSXSksST1yLm1hdDJkLm11bHRpcGx5KEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxJLHIubWF0MmQuZnJvbVZhbHVlcygxLE1hdGgudGFuKE8pLE1hdGgudGFuKGwpLDEsMCwwKSksST1yLm1hdDJkLnRyYW5zbGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCksSSxbLUEsLVJdKSx0aGlzLnRyYW5zZm9ybShzLEkpfWlzUG9pbnRDb2xsaXNpb24ocyxbbCxPXSxBPSJib3RoIil7Y29uc3QgUj10aGlzLmdldFRyYW5zZm9ybShzKSxJPU9iamVjdChkLnRyYW5zZm9ybVBvaW50KShbbCxPXSxyLm1hdDJkLmludmVydChBcnJheS5vZigwLDAsMCwwLDAsMCksUikpO3JldHVybiB0aGlzW3hdLmlzUG9pbnRDb2xsaXNpb24oLi4uSSxBKX1pc1BvaW50SW5GaWxsKHMsW2wsT10pe3JldHVybiB0aGlzLmlzUG9pbnRDb2xsaXNpb24ocyxbbCxPXSwiZmlsbCIpfWlzUG9pbnRJblN0cm9rZShzLFtsLE9dKXtyZXR1cm4gdGhpcy5pc1BvaW50Q29sbGlzaW9uKHMsW2wsT10sInN0cm9rZSIpfX19LGZ1bmN0aW9uKGgsZSx0KXt0LnIoZSksdC5kKGUsIm11bHRpcGx5IixmdW5jdGlvbigpe3JldHVybiBufSksdC5kKGUsImdyYXlzY2FsZSIsZnVuY3Rpb24oKXtyZXR1cm4gZH0pLHQuZChlLCJicmlnaHRuZXNzIixmdW5jdGlvbigpe3JldHVybiBnfSksdC5kKGUsInNhdHVyYXRlIixmdW5jdGlvbigpe3JldHVybiB1fSksdC5kKGUsImNvbnRyYXN0IixmdW5jdGlvbigpe3JldHVybiBvfSksdC5kKGUsImludmVydCIsZnVuY3Rpb24oKXtyZXR1cm4gZn0pLHQuZChlLCJzZXBpYSIsZnVuY3Rpb24oKXtyZXR1cm4geH0pLHQuZChlLCJvcGFjaXR5IixmdW5jdGlvbigpe3JldHVybiBjfSksdC5kKGUsImh1ZVJvdGF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gdn0pO3ZhciByPXQoMjYpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBuKHAsYil7Y29uc3QgRT1bXSx5PXBbMF0sTT1wWzFdLGk9cFsyXSxhPXBbM10scz1wWzRdLGw9cFs1XSxPPXBbNl0sQT1wWzddLFI9cFs4XSxJPXBbOV0sUD1wWzEwXSxMPXBbMTFdLEQ9cFsxMl0sQz1wWzEzXSxTPXBbMTRdLEI9cFsxNV0sdz1wWzE2XSxIPXBbMTddLEo9cFsxOF0scT1wWzE5XTtsZXQgVT1iWzBdLEc9YlsxXSxaPWJbMl0sdHQ9YlszXSxfPWJbNF07cmV0dXJuIEVbMF09VSp5K0cqbCtaKlArdHQqQixFWzFdPVUqTStHKk8rWipMK3R0KncsRVsyXT1VKmkrRypBK1oqRCt0dCpILEVbM109VSphK0cqUitaKkMrdHQqSixFWzRdPVUqcytHKkkrWipTK3R0KnErXyxVPWJbNV0sRz1iWzZdLFo9Yls3XSx0dD1iWzhdLF89Yls5XSxFWzVdPVUqeStHKmwrWipQK3R0KkIsRVs2XT1VKk0rRypPK1oqTCt0dCp3LEVbN109VSppK0cqQStaKkQrdHQqSCxFWzhdPVUqYStHKlIrWipDK3R0KkosRVs5XT1VKnMrRypJK1oqUyt0dCpxK18sVT1iWzEwXSxHPWJbMTFdLFo9YlsxMl0sdHQ9YlsxM10sXz1iWzE0XSxFWzEwXT1VKnkrRypsK1oqUCt0dCpCLEVbMTFdPVUqTStHKk8rWipMK3R0KncsRVsxMl09VSppK0cqQStaKkQrdHQqSCxFWzEzXT1VKmErRypSK1oqQyt0dCpKLEVbMTRdPVUqcytHKkkrWipTK3R0KnErXyxVPWJbMTVdLEc9YlsxNl0sWj1iWzE3XSx0dD1iWzE4XSxfPWJbMTldLEVbMTVdPVUqeStHKmwrWipQK3R0KkIsRVsxNl09VSpNK0cqTytaKkwrdHQqdyxFWzE3XT1VKmkrRypBK1oqRCt0dCpILEVbMThdPVUqYStHKlIrWipDK3R0KkosRVsxOV09VSpzK0cqSStaKlMrdHQqcStfLEV9ZnVuY3Rpb24gZChwKXtwPU9iamVjdChyLmNsYW1wKSgwLDEscCk7Y29uc3QgYj0uMjEyNipwLEU9LjcxNTIqcCx5PS4wNzIyKnA7cmV0dXJuW2IrMS1wLEUseSwwLDAsYixFKzEtcCx5LDAsMCxiLEUseSsxLXAsMCwwLDAsMCwwLDEsMF19ZnVuY3Rpb24gZyhwKXtyZXR1cm5bcCwwLDAsMCwwLDAscCwwLDAsMCwwLDAscCwwLDAsMCwwLDAsMSwwXX1mdW5jdGlvbiB1KHApe2NvbnN0IGI9LjIxMjYqKDEtcCksRT0uNzE1MiooMS1wKSx5PS4wNzIyKigxLXApO3JldHVybltiK3AsRSx5LDAsMCxiLEUrcCx5LDAsMCxiLEUseStwLDAsMCwwLDAsMCwxLDBdfWZ1bmN0aW9uIG8ocCl7Y29uc3QgYj0uNSooMS1wKTtyZXR1cm5bcCwwLDAsMCxiLDAscCwwLDAsYiwwLDAscCwwLGIsMCwwLDAsMSwwXX1mdW5jdGlvbiBmKHApe2NvbnN0IGI9MS0yKnA7cmV0dXJuW2IsMCwwLDAscCwwLGIsMCwwLHAsMCwwLGIsMCxwLDAsMCwwLDEsMF19ZnVuY3Rpb24geChwKXtyZXR1cm5bMS0uNjA3KnAsLjc2OSpwLC4xODkqcCwwLDAsLjM0OSpwLDEtLjMxNCpwLC4xNjgqcCwwLDAsLjI3MipwLC41MzQqcCwxLS44NjkqcCwwLDAsMCwwLDAsMSwwXX1mdW5jdGlvbiBjKHApe3JldHVyblsxLDAsMCwwLDAsMCwxLDAsMCwwLDAsMCwxLDAsMCwwLDAsMCxwLDBdfWZ1bmN0aW9uIHYocCl7Y29uc3QgYj1wLzE4MCpNYXRoLlBJLEU9TWF0aC5jb3MoYikseT1NYXRoLnNpbihiKSxNPS4yMTI2LGk9LjcxNTIsYT0uMDcyMjtyZXR1cm5bTStFKigxLU0pK3kqLU0saStFKi1pK3kqLWksYStFKi1hK3kqKDEtYSksMCwwLE0rRSotTSt5Ki4xNDMsaStFKigxLWkpK3kqLjE0LGErRSotYSt5Ki0uMjgzLDAsMCxNK0UqLU0reSotKDEtTSksaStFKi1pK3kqaSxhK0UqKDEtYSkreSphLDAsMCwwLDAsMCwxLDBdfX0sZnVuY3Rpb24oaCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gZH0pO3ZhciByPXQoMzIpLG49dC5uKHIpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBkKGcpe2NvbnN0IHU9bigpKGcpO2lmKCF1fHwhdS5sZW5ndGgpdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCBjb2xvciB2YWx1ZS4iKTtyZXR1cm5bdVswXS8yNTUsdVsxXS8yNTUsdVsyXS8yNTUsdVszXV19fSxmdW5jdGlvbihoLGUsdCl7dmFyIHI9dCgzMyksbj10KDM3KSxkPXQoMzkpO2guZXhwb3J0cz1mdW5jdGlvbih1KXt2YXIgbyxmPXIodSk7cmV0dXJuIGYuc3BhY2U/KG89QXJyYXkoMyksb1swXT1kKGYudmFsdWVzWzBdLDAsMjU1KSxvWzFdPWQoZi52YWx1ZXNbMV0sMCwyNTUpLG9bMl09ZChmLnZhbHVlc1syXSwwLDI1NSksZi5zcGFjZVswXT09PSJoIiYmKG89bi5yZ2IobykpLG8ucHVzaChkKGYuYWxwaGEsMCwxKSksbyk6W119fSxmdW5jdGlvbihoLGUsdCl7KGZ1bmN0aW9uKHIpe3ZhciBuPXQoMzQpLGQ9dCgzNSksZz10KDM2KTtoLmV4cG9ydHM9bzt2YXIgdT17cmVkOjAsb3JhbmdlOjYwLHllbGxvdzoxMjAsZ3JlZW46MTgwLGJsdWU6MjQwLHB1cnBsZTozMDB9O2Z1bmN0aW9uIG8oZil7dmFyIHgsYz1bXSx2PTEscDtpZih0eXBlb2YgZj09InN0cmluZyIpaWYobltmXSljPW5bZl0uc2xpY2UoKSxwPSJyZ2IiO2Vsc2UgaWYoZj09PSJ0cmFuc3BhcmVudCIpdj0wLHA9InJnYiIsYz1bMCwwLDBdO2Vsc2UgaWYoL14jW0EtRmEtZjAtOV0rJC8udGVzdChmKSl7dmFyIGI9Zi5zbGljZSgxKSxFPWIubGVuZ3RoLHk9RTw9NDt2PTEseT8oYz1bcGFyc2VJbnQoYlswXStiWzBdLDE2KSxwYXJzZUludChiWzFdK2JbMV0sMTYpLHBhcnNlSW50KGJbMl0rYlsyXSwxNildLEU9PT00JiYodj1wYXJzZUludChiWzNdK2JbM10sMTYpLzI1NSkpOihjPVtwYXJzZUludChiWzBdK2JbMV0sMTYpLHBhcnNlSW50KGJbMl0rYlszXSwxNikscGFyc2VJbnQoYls0XStiWzVdLDE2KV0sRT09PTgmJih2PXBhcnNlSW50KGJbNl0rYls3XSwxNikvMjU1KSksY1swXXx8KGNbMF09MCksY1sxXXx8KGNbMV09MCksY1syXXx8KGNbMl09MCkscD0icmdiIn1lbHNlIGlmKHg9L14oKD86cmdifGhzW2x2Yl18aHdifGNteWs/fHh5W3p5XXxncmF5fGxhYnxsY2h1P3Y/fFtseV11dnxsbXMpYT8pXHMqXCgoW15cKV0qKVwpLy5leGVjKGYpKXt2YXIgTT14WzFdLGk9TT09PSJyZ2IiLGI9TS5yZXBsYWNlKC9hJC8sIiIpO3A9Yjt2YXIgRT1iPT09ImNteWsiPzQ6Yj09PSJncmF5Ij8xOjM7Yz14WzJdLnRyaW0oKS5zcGxpdCgvXHMqLFxzKi8pLm1hcChmdW5jdGlvbihPLEEpe2lmKC8lJC8udGVzdChPKSlyZXR1cm4gQT09PUU/cGFyc2VGbG9hdChPKS8xMDA6Yj09PSJyZ2IiP3BhcnNlRmxvYXQoTykqMjU1LzEwMDpwYXJzZUZsb2F0KE8pO2lmKGJbQV09PT0iaCIpe2lmKC9kZWckLy50ZXN0KE8pKXJldHVybiBwYXJzZUZsb2F0KE8pO2lmKHVbT10hPT12b2lkIDApcmV0dXJuIHVbT119cmV0dXJuIHBhcnNlRmxvYXQoTyl9KSxNPT09YiYmYy5wdXNoKDEpLHY9aXx8Y1tFXT09PXZvaWQgMD8xOmNbRV0sYz1jLnNsaWNlKDAsRSl9ZWxzZSBmLmxlbmd0aD4xMCYmL1swLTldKD86XHN8XC8pLy50ZXN0KGYpJiYoYz1mLm1hdGNoKC8oWzAtOV0rKS9nKS5tYXAoZnVuY3Rpb24ocyl7cmV0dXJuIHBhcnNlRmxvYXQocyl9KSxwPWYubWF0Y2goLyhbYS16XSkvaWcpLmpvaW4oIiIpLnRvTG93ZXJDYXNlKCkpO2Vsc2UgaWYoIWlzTmFOKGYpKXA9InJnYiIsYz1bZj4+PjE2LChmJjY1MjgwKT4+PjgsZiYyNTVdO2Vsc2UgaWYoZChmKSl7dmFyIGE9ZyhmLnIsZi5yZWQsZi5SLG51bGwpO2EhPT1udWxsPyhwPSJyZ2IiLGM9W2EsZyhmLmcsZi5ncmVlbixmLkcpLGcoZi5iLGYuYmx1ZSxmLkIpXSk6KHA9ImhzbCIsYz1bZyhmLmgsZi5odWUsZi5IKSxnKGYucyxmLnNhdHVyYXRpb24sZi5TKSxnKGYubCxmLmxpZ2h0bmVzcyxmLkwsZi5iLGYuYnJpZ2h0bmVzcyldKSx2PWcoZi5hLGYuYWxwaGEsZi5vcGFjaXR5LDEpLGYub3BhY2l0eSE9bnVsbCYmKHYvPTEwMCl9ZWxzZShBcnJheS5pc0FycmF5KGYpfHxyLkFycmF5QnVmZmVyJiZBcnJheUJ1ZmZlci5pc1ZpZXcmJkFycmF5QnVmZmVyLmlzVmlldyhmKSkmJihjPVtmWzBdLGZbMV0sZlsyXV0scD0icmdiIix2PWYubGVuZ3RoPT09ND9mWzNdOjEpO3JldHVybntzcGFjZTpwLHZhbHVlczpjLGFscGhhOnZ9fX0pLmNhbGwodGhpcyx0KDIyKSl9LGZ1bmN0aW9uKGgsZSx0KXtoLmV4cG9ydHM9e2FsaWNlYmx1ZTpbMjQwLDI0OCwyNTVdLGFudGlxdWV3aGl0ZTpbMjUwLDIzNSwyMTVdLGFxdWE6WzAsMjU1LDI1NV0sYXF1YW1hcmluZTpbMTI3LDI1NSwyMTJdLGF6dXJlOlsyNDAsMjU1LDI1NV0sYmVpZ2U6WzI0NSwyNDUsMjIwXSxiaXNxdWU6WzI1NSwyMjgsMTk2XSxibGFjazpbMCwwLDBdLGJsYW5jaGVkYWxtb25kOlsyNTUsMjM1LDIwNV0sYmx1ZTpbMCwwLDI1NV0sYmx1ZXZpb2xldDpbMTM4LDQzLDIyNl0sYnJvd246WzE2NSw0Miw0Ml0sYnVybHl3b29kOlsyMjIsMTg0LDEzNV0sY2FkZXRibHVlOls5NSwxNTgsMTYwXSxjaGFydHJldXNlOlsxMjcsMjU1LDBdLGNob2NvbGF0ZTpbMjEwLDEwNSwzMF0sY29yYWw6WzI1NSwxMjcsODBdLGNvcm5mbG93ZXJibHVlOlsxMDAsMTQ5LDIzN10sY29ybnNpbGs6WzI1NSwyNDgsMjIwXSxjcmltc29uOlsyMjAsMjAsNjBdLGN5YW46WzAsMjU1LDI1NV0sZGFya2JsdWU6WzAsMCwxMzldLGRhcmtjeWFuOlswLDEzOSwxMzldLGRhcmtnb2xkZW5yb2Q6WzE4NCwxMzQsMTFdLGRhcmtncmF5OlsxNjksMTY5LDE2OV0sZGFya2dyZWVuOlswLDEwMCwwXSxkYXJrZ3JleTpbMTY5LDE2OSwxNjldLGRhcmtraGFraTpbMTg5LDE4MywxMDddLGRhcmttYWdlbnRhOlsxMzksMCwxMzldLGRhcmtvbGl2ZWdyZWVuOls4NSwxMDcsNDddLGRhcmtvcmFuZ2U6WzI1NSwxNDAsMF0sZGFya29yY2hpZDpbMTUzLDUwLDIwNF0sZGFya3JlZDpbMTM5LDAsMF0sZGFya3NhbG1vbjpbMjMzLDE1MCwxMjJdLGRhcmtzZWFncmVlbjpbMTQzLDE4OCwxNDNdLGRhcmtzbGF0ZWJsdWU6WzcyLDYxLDEzOV0sZGFya3NsYXRlZ3JheTpbNDcsNzksNzldLGRhcmtzbGF0ZWdyZXk6WzQ3LDc5LDc5XSxkYXJrdHVycXVvaXNlOlswLDIwNiwyMDldLGRhcmt2aW9sZXQ6WzE0OCwwLDIxMV0sZGVlcHBpbms6WzI1NSwyMCwxNDddLGRlZXBza3libHVlOlswLDE5MSwyNTVdLGRpbWdyYXk6WzEwNSwxMDUsMTA1XSxkaW1ncmV5OlsxMDUsMTA1LDEwNV0sZG9kZ2VyYmx1ZTpbMzAsMTQ0LDI1NV0sZmlyZWJyaWNrOlsxNzgsMzQsMzRdLGZsb3JhbHdoaXRlOlsyNTUsMjUwLDI0MF0sZm9yZXN0Z3JlZW46WzM0LDEzOSwzNF0sZnVjaHNpYTpbMjU1LDAsMjU1XSxnYWluc2Jvcm86WzIyMCwyMjAsMjIwXSxnaG9zdHdoaXRlOlsyNDgsMjQ4LDI1NV0sZ29sZDpbMjU1LDIxNSwwXSxnb2xkZW5yb2Q6WzIxOCwxNjUsMzJdLGdyYXk6WzEyOCwxMjgsMTI4XSxncmVlbjpbMCwxMjgsMF0sZ3JlZW55ZWxsb3c6WzE3MywyNTUsNDddLGdyZXk6WzEyOCwxMjgsMTI4XSxob25leWRldzpbMjQwLDI1NSwyNDBdLGhvdHBpbms6WzI1NSwxMDUsMTgwXSxpbmRpYW5yZWQ6WzIwNSw5Miw5Ml0saW5kaWdvOls3NSwwLDEzMF0saXZvcnk6WzI1NSwyNTUsMjQwXSxraGFraTpbMjQwLDIzMCwxNDBdLGxhdmVuZGVyOlsyMzAsMjMwLDI1MF0sbGF2ZW5kZXJibHVzaDpbMjU1LDI0MCwyNDVdLGxhd25ncmVlbjpbMTI0LDI1MiwwXSxsZW1vbmNoaWZmb246WzI1NSwyNTAsMjA1XSxsaWdodGJsdWU6WzE3MywyMTYsMjMwXSxsaWdodGNvcmFsOlsyNDAsMTI4LDEyOF0sbGlnaHRjeWFuOlsyMjQsMjU1LDI1NV0sbGlnaHRnb2xkZW5yb2R5ZWxsb3c6WzI1MCwyNTAsMjEwXSxsaWdodGdyYXk6WzIxMSwyMTEsMjExXSxsaWdodGdyZWVuOlsxNDQsMjM4LDE0NF0sbGlnaHRncmV5OlsyMTEsMjExLDIxMV0sbGlnaHRwaW5rOlsyNTUsMTgyLDE5M10sbGlnaHRzYWxtb246WzI1NSwxNjAsMTIyXSxsaWdodHNlYWdyZWVuOlszMiwxNzgsMTcwXSxsaWdodHNreWJsdWU6WzEzNSwyMDYsMjUwXSxsaWdodHNsYXRlZ3JheTpbMTE5LDEzNiwxNTNdLGxpZ2h0c2xhdGVncmV5OlsxMTksMTM2LDE1M10sbGlnaHRzdGVlbGJsdWU6WzE3NiwxOTYsMjIyXSxsaWdodHllbGxvdzpbMjU1LDI1NSwyMjRdLGxpbWU6WzAsMjU1LDBdLGxpbWVncmVlbjpbNTAsMjA1LDUwXSxsaW5lbjpbMjUwLDI0MCwyMzBdLG1hZ2VudGE6WzI1NSwwLDI1NV0sbWFyb29uOlsxMjgsMCwwXSxtZWRpdW1hcXVhbWFyaW5lOlsxMDIsMjA1LDE3MF0sbWVkaXVtYmx1ZTpbMCwwLDIwNV0sbWVkaXVtb3JjaGlkOlsxODYsODUsMjExXSxtZWRpdW1wdXJwbGU6WzE0NywxMTIsMjE5XSxtZWRpdW1zZWFncmVlbjpbNjAsMTc5LDExM10sbWVkaXVtc2xhdGVibHVlOlsxMjMsMTA0LDIzOF0sbWVkaXVtc3ByaW5nZ3JlZW46WzAsMjUwLDE1NF0sbWVkaXVtdHVycXVvaXNlOls3MiwyMDksMjA0XSxtZWRpdW12aW9sZXRyZWQ6WzE5OSwyMSwxMzNdLG1pZG5pZ2h0Ymx1ZTpbMjUsMjUsMTEyXSxtaW50Y3JlYW06WzI0NSwyNTUsMjUwXSxtaXN0eXJvc2U6WzI1NSwyMjgsMjI1XSxtb2NjYXNpbjpbMjU1LDIyOCwxODFdLG5hdmFqb3doaXRlOlsyNTUsMjIyLDE3M10sbmF2eTpbMCwwLDEyOF0sb2xkbGFjZTpbMjUzLDI0NSwyMzBdLG9saXZlOlsxMjgsMTI4LDBdLG9saXZlZHJhYjpbMTA3LDE0MiwzNV0sb3JhbmdlOlsyNTUsMTY1LDBdLG9yYW5nZXJlZDpbMjU1LDY5LDBdLG9yY2hpZDpbMjE4LDExMiwyMTRdLHBhbGVnb2xkZW5yb2Q6WzIzOCwyMzIsMTcwXSxwYWxlZ3JlZW46WzE1MiwyNTEsMTUyXSxwYWxldHVycXVvaXNlOlsxNzUsMjM4LDIzOF0scGFsZXZpb2xldHJlZDpbMjE5LDExMiwxNDddLHBhcGF5YXdoaXA6WzI1NSwyMzksMjEzXSxwZWFjaHB1ZmY6WzI1NSwyMTgsMTg1XSxwZXJ1OlsyMDUsMTMzLDYzXSxwaW5rOlsyNTUsMTkyLDIwM10scGx1bTpbMjIxLDE2MCwyMjFdLHBvd2RlcmJsdWU6WzE3NiwyMjQsMjMwXSxwdXJwbGU6WzEyOCwwLDEyOF0scmViZWNjYXB1cnBsZTpbMTAyLDUxLDE1M10scmVkOlsyNTUsMCwwXSxyb3N5YnJvd246WzE4OCwxNDMsMTQzXSxyb3lhbGJsdWU6WzY1LDEwNSwyMjVdLHNhZGRsZWJyb3duOlsxMzksNjksMTldLHNhbG1vbjpbMjUwLDEyOCwxMTRdLHNhbmR5YnJvd246WzI0NCwxNjQsOTZdLHNlYWdyZWVuOls0NiwxMzksODddLHNlYXNoZWxsOlsyNTUsMjQ1LDIzOF0sc2llbm5hOlsxNjAsODIsNDVdLHNpbHZlcjpbMTkyLDE5MiwxOTJdLHNreWJsdWU6WzEzNSwyMDYsMjM1XSxzbGF0ZWJsdWU6WzEwNiw5MCwyMDVdLHNsYXRlZ3JheTpbMTEyLDEyOCwxNDRdLHNsYXRlZ3JleTpbMTEyLDEyOCwxNDRdLHNub3c6WzI1NSwyNTAsMjUwXSxzcHJpbmdncmVlbjpbMCwyNTUsMTI3XSxzdGVlbGJsdWU6WzcwLDEzMCwxODBdLHRhbjpbMjEwLDE4MCwxNDBdLHRlYWw6WzAsMTI4LDEyOF0sdGhpc3RsZTpbMjE2LDE5MSwyMTZdLHRvbWF0bzpbMjU1LDk5LDcxXSx0dXJxdW9pc2U6WzY0LDIyNCwyMDhdLHZpb2xldDpbMjM4LDEzMCwyMzhdLHdoZWF0OlsyNDUsMjIyLDE3OV0sd2hpdGU6WzI1NSwyNTUsMjU1XSx3aGl0ZXNtb2tlOlsyNDUsMjQ1LDI0NV0seWVsbG93OlsyNTUsMjU1LDBdLHllbGxvd2dyZWVuOlsxNTQsMjA1LDUwXX19LGZ1bmN0aW9uKGgsZSx0KXt2YXIgcj1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO2guZXhwb3J0cz1mdW5jdGlvbihuKXt2YXIgZDtyZXR1cm4gci5jYWxsKG4pPT09IltvYmplY3QgT2JqZWN0XSImJihkPU9iamVjdC5nZXRQcm90b3R5cGVPZihuKSxkPT09bnVsbHx8ZD09PU9iamVjdC5nZXRQcm90b3R5cGVPZih7fSkpfX0sZnVuY3Rpb24oaCxlKXtoLmV4cG9ydHM9ZnVuY3Rpb24oKXtmb3IodmFyIHQ9MDt0PGFyZ3VtZW50cy5sZW5ndGg7dCsrKWlmKGFyZ3VtZW50c1t0XSE9PXZvaWQgMClyZXR1cm4gYXJndW1lbnRzW3RdfX0sZnVuY3Rpb24oaCxlLHQpe3ZhciByPXQoMzgpO2guZXhwb3J0cz17bmFtZToiaHNsIixtaW46WzAsMCwwXSxtYXg6WzM2MCwxMDAsMTAwXSxjaGFubmVsOlsiaHVlIiwic2F0dXJhdGlvbiIsImxpZ2h0bmVzcyJdLGFsaWFzOlsiSFNMIl0scmdiOmZ1bmN0aW9uKG4pe3ZhciBkPW5bMF0vMzYwLGc9blsxXS8xMDAsdT1uWzJdLzEwMCxvLGYseCxjLHY7aWYoZz09PTApcmV0dXJuIHY9dSoyNTUsW3Ysdix2XTt1PC41P2Y9dSooMStnKTpmPXUrZy11Kmcsbz0yKnUtZixjPVswLDAsMF07Zm9yKHZhciBwPTA7cDwzO3ArKyl4PWQrMS8zKi0ocC0xKSx4PDA/eCsrOng+MSYmeC0tLDYqeDwxP3Y9bysoZi1vKSo2Kng6Mip4PDE/dj1mOjMqeDwyP3Y9bysoZi1vKSooMi8zLXgpKjY6dj1vLGNbcF09dioyNTU7cmV0dXJuIGN9fSxyLmhzbD1mdW5jdGlvbihuKXt2YXIgZD1uWzBdLzI1NSxnPW5bMV0vMjU1LHU9blsyXS8yNTUsbz1NYXRoLm1pbihkLGcsdSksZj1NYXRoLm1heChkLGcsdSkseD1mLW8sYyx2LHA7cmV0dXJuIGY9PT1vP2M9MDpkPT09Zj9jPShnLXUpL3g6Zz09PWY/Yz0yKyh1LWQpL3g6dT09PWYmJihjPTQrKGQtZykveCksYz1NYXRoLm1pbihjKjYwLDM2MCksYzwwJiYoYys9MzYwKSxwPShvK2YpLzIsZj09PW8/dj0wOnA8PS41P3Y9eC8oZitvKTp2PXgvKDItZi1vKSxbYyx2KjEwMCxwKjEwMF19fSxmdW5jdGlvbihoLGUsdCl7aC5leHBvcnRzPXtuYW1lOiJyZ2IiLG1pbjpbMCwwLDBdLG1heDpbMjU1LDI1NSwyNTVdLGNoYW5uZWw6WyJyZWQiLCJncmVlbiIsImJsdWUiXSxhbGlhczpbIlJHQiJdfX0sZnVuY3Rpb24oaCxlKXtoLmV4cG9ydHM9dDtmdW5jdGlvbiB0KHIsbixkKXtyZXR1cm4gbjxkP3I8bj9uOnI+ZD9kOnI6cjxkP2Q6cj5uP246cn19LGZ1bmN0aW9uKGgsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIGF9KTt2YXIgcj10KDQxKSxuPXQubihyKSxkPXQoNDIpLGc9dC5uKGQpLHU9dCg0Myksbz10Lm4odSksZj10KDQ0KSx4PXQoNDYpLGM9dC5uKHgpLHY9dCg1MykscD10KDU1KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3QgYj1TeW1ib2woImNvbnRvdXJzIiksRT1TeW1ib2woInBhdGgiKSx5PVN5bWJvbCgic2ltcGxpZnkiKSxNPVN5bWJvbCgic2NhbGUiKSxpPTIqTWF0aC5QSTtjbGFzcyBhe2NvbnN0cnVjdG9yKGw9e30pe3R5cGVvZiBsPT0ic3RyaW5nIiYmKGw9e3BhdGg6bH0pLGwucGF0aD90aGlzW0VdPW4oKShsLnBhdGgpOnRoaXNbRV09W10sdGhpc1tiXT1udWxsLHRoaXNbeV09bC5zaW1wbGlmeSE9bnVsbD9sLnNpbXBsaWZ5OjAsdGhpc1tNXT1sLnNjYWxlIT1udWxsP2wuc2NhbGU6Mn1nZXQgY29udG91cnMoKXtsZXQgbD1udWxsO2lmKCF0aGlzW2JdJiZ0aGlzW0VdKXtjb25zdCBPPU9iamVjdChmLmRlZmF1bHQpKG8oKSh0aGlzW0VdKSk7dGhpc1tiXT1jKCkoTyx0aGlzW01dLHRoaXNbeV0pLHRoaXNbYl0ucGF0aD1PLHRoaXNbYl0uc2ltcGxpZnk9dGhpc1t5XSx0aGlzW2JdLnNjYWxlPXRoaXNbTV19cmV0dXJuIHRoaXNbYl0mJihsPXRoaXNbYl0ubWFwKE89PlsuLi5PXSksbC5wYXRoPXRoaXNbYl0ucGF0aCxsLnNpbXBsaWZ5PXRoaXNbYl0uc2ltcGxpZnksbC5zY2FsZT10aGlzW2JdLnNjYWxlKSxsfWdldCBwYXRoKCl7cmV0dXJuIHRoaXNbRV19Z2V0IHNpbXBsaWZ5KCl7cmV0dXJuIHRoaXNbeV19Z2V0IGJvdW5kaW5nQm94KCl7Y29uc3QgbD10aGlzLmNvbnRvdXJzO2lmKGwmJmwubGVuZ3RoKXtjb25zdCBPPWwucmVkdWNlKChBLFIpPT5bLi4uQSwuLi5SXSk7cmV0dXJuIGcoKShPKX1yZXR1cm5bWzAsMF0sWzAsMF1dfWdldCBib3VuZGluZ0NlbnRlcigpe2NvbnN0IGw9dGhpcy5ib3VuZGluZ0JveDtyZXR1cm4gbD9bLjUqKGxbMF1bMF0rbFsxXVswXSksLjUqKGxbMF1bMV0rbFsxXVsxXSldOlswLDBdfW5vcm1hbGl6ZShsPTAsTz0wKXtjb25zdCBBPU9iamVjdChmLmRlZmF1bHQpKG8oKSh0aGlzW0VdKSkubWFwKChbUiwuLi5JXSk9Pntjb25zdCBQPVtSXTtmb3IobGV0IEw9MDtMPEkubGVuZ3RoO0wrPTIpe2NvbnN0IEQ9SVtMXS1sLEM9SVtMKzFdLU87UC5wdXNoKEQsQyl9cmV0dXJuIFB9KTtyZXR1cm4gdGhpcy5iZWdpblBhdGgoKSx0aGlzW0VdLnB1c2goLi4uQSksdGhpc31nZXRQb2ludEF0TGVuZ3RoKGwpe3JldHVybiB0aGlzLmNvbnRvdXJzP09iamVjdCh2LmdldFBvaW50QXRMZW5ndGgpKHRoaXNbYl0sbCk6bnVsbH1nZXRUb3RhbExlbmd0aCgpe3JldHVybiB0aGlzLmNvbnRvdXJzP09iamVjdCh2LmdldFRvdGFsTGVuZ3RoKSh0aGlzW2JdKTowfWFkZFBhdGgobCl7dGhpc1tiXT1udWxsLHR5cGVvZiBsPT0ic3RyaW5nIiYmKGw9bigpKGwpKSx0aGlzW0VdLnB1c2goLi4ubCl9YmVnaW5QYXRoKCl7dGhpc1tFXT1bXSx0aGlzW2JdPW51bGx9Y2xlYXIoKXt0aGlzLmJlZ2luUGF0aCgpfWVsbGlwc2UobCxPLEEsUixJLFAsTCxEPTApe2lmKFArPUksTCs9SSxBPD0wfHxSPD0wfHxMPT09UClyZXR1cm47TDxQJiYoTD1QK2krKEwtUCklaSksTC1QPmkmJihMPVAraSk7Y29uc3QgQz1MLVA7Qz49aSYmKEwtPS4wMDEpO2xldCBTPXRoaXNbRV0ubGVuZ3RoPjAmJkM8aT8iTCI6Ik0iO2NvbnN0IEI9T2JqZWN0KHAuZ2V0UG9pbnQpKGwsTyxBLFIsUCksdz1PYmplY3QocC5nZXRQb2ludCkobCxPLEEsUixMKSxIPSshRDtsZXQgSj1DPk1hdGguUEk/MTowO0QmJihKPTEtSiksUys9Qi5qb2luKCIgIiksUys9YEEke0F9ICR7Un0gMCAke0p9ICR7SH0gJHt3LmpvaW4oIiAiKX1gLEM+PWkmJihTKz0iWiIpLHRoaXMuYWRkUGF0aChTKX1hcmMobCxPLEEsUixJLFA9MCl7cmV0dXJuIHRoaXMuZWxsaXBzZShsLE8sQSxBLDAsUixJLFApfWFyY1RvKGwsTyxBLFIsSSxQLEwpe3RoaXNbYl09bnVsbCx0aGlzW0VdLnB1c2goWyJBIixsLE8sQSxSLEksUCxMXSl9bW92ZVRvKGwsTyl7dGhpc1tiXT1udWxsLHRoaXNbRV0ucHVzaChbIk0iLGwsT10pfWxpbmVUbyhsLE8pe3RoaXNbYl09bnVsbCx0aGlzW0VdLnB1c2goWyJMIixsLE9dKX1iZXppZXJDdXJ2ZVRvKGwsTyxBLFIsSSxQKXt0aGlzW2JdPW51bGwsdGhpc1tFXS5wdXNoKFsiQyIsbCxPLEEsUixJLFBdKX1xdWFkcmF0aWNDdXJ2ZVRvKGwsTyxBLFIpe3RoaXNbYl09bnVsbCx0aGlzW0VdLnB1c2goWyJRIixsLE8sQSxSXSl9cmVjdChsLE8sQSxSKXtjb25zdCBJPWBNJHtsfSAke099TCR7bCtBfSAke099TCR7bCtBfSAke08rUn1MJHtsfSAke08rUn1aYDt0aGlzLmFkZFBhdGgoSSl9Y2xvc2VQYXRoKCl7dGhpc1tiXT1udWxsO2xldCBsPVtdO2NvbnN0IE89dGhpc1tFXS5sZW5ndGg7Tz4wJiYobD10aGlzW0VdW08tMV0pLGxbMF0hPT0iWiImJmxbMF0hPT0ieiImJnRoaXNbRV0ucHVzaChbIloiXSl9fX0sZnVuY3Rpb24oaCxlKXtoLmV4cG9ydHM9bjt2YXIgdD17YTo3LGM6NixoOjEsbDoyLG06MixxOjQsczo0LHQ6Mix2OjEsejowfSxyPS8oW2FzdHZ6cW1obGNdKShbXmFzdHZ6cW1obGNdKikvaWc7ZnVuY3Rpb24gbih1KXt2YXIgbz1bXTtyZXR1cm4gdS5yZXBsYWNlKHIsZnVuY3Rpb24oZix4LGMpe3ZhciB2PXgudG9Mb3dlckNhc2UoKTtmb3IoYz1nKGMpLHY9PSJtIiYmYy5sZW5ndGg+MiYmKG8ucHVzaChbeF0uY29uY2F0KGMuc3BsaWNlKDAsMikpKSx2PSJsIix4PXg9PSJtIj8ibCI6IkwiKTs7KXtpZihjLmxlbmd0aD09dFt2XSlyZXR1cm4gYy51bnNoaWZ0KHgpLG8ucHVzaChjKTtpZihjLmxlbmd0aDx0W3ZdKXRocm93IG5ldyBFcnJvcigibWFsZm9ybWVkIHBhdGggZGF0YSIpO28ucHVzaChbeF0uY29uY2F0KGMuc3BsaWNlKDAsdFt2XSkpKX19KSxvfXZhciBkPS8tP1swLTldKlwuP1swLTldKyg/OmVbLStdP1xkKyk/L2lnO2Z1bmN0aW9uIGcodSl7dmFyIG89dS5tYXRjaChkKTtyZXR1cm4gbz9vLm1hcChOdW1iZXIpOltdfX0sZnVuY3Rpb24oaCxlLHQpe2guZXhwb3J0cz1yO2Z1bmN0aW9uIHIobil7dmFyIGQ9bi5sZW5ndGg7aWYoZD09PTApcmV0dXJuW1tdLFtdXTtmb3IodmFyIGc9blswXS5sZW5ndGgsdT1uWzBdLnNsaWNlKCksbz1uWzBdLnNsaWNlKCksZj0xO2Y8ZDsrK2YpZm9yKHZhciB4PW5bZl0sYz0wO2M8ZzsrK2Mpe3ZhciB2PXhbY107dVtjXT1NYXRoLm1pbih1W2NdLHYpLG9bY109TWF0aC5tYXgob1tjXSx2KX1yZXR1cm5bdSxvXX19LGZ1bmN0aW9uKGgsZSl7aC5leHBvcnRzPXQ7ZnVuY3Rpb24gdChyKXt2YXIgbj0wLGQ9MCxnPTAsdT0wO3JldHVybiByLm1hcChmdW5jdGlvbihvKXtvPW8uc2xpY2UoKTt2YXIgZj1vWzBdLHg9Zi50b1VwcGVyQ2FzZSgpO2lmKGYhPXgpc3dpdGNoKG9bMF09eCxmKXtjYXNlImEiOm9bNl0rPWcsb1s3XSs9dTticmVhaztjYXNlInYiOm9bMV0rPXU7YnJlYWs7Y2FzZSJoIjpvWzFdKz1nO2JyZWFrO2RlZmF1bHQ6Zm9yKHZhciBjPTE7YzxvLmxlbmd0aDspb1tjKytdKz1nLG9bYysrXSs9dX1zd2l0Y2goeCl7Y2FzZSJaIjpnPW4sdT1kO2JyZWFrO2Nhc2UiSCI6Zz1vWzFdO2JyZWFrO2Nhc2UiViI6dT1vWzFdO2JyZWFrO2Nhc2UiTSI6Zz1uPW9bMV0sdT1kPW9bMl07YnJlYWs7ZGVmYXVsdDpnPW9bby5sZW5ndGgtMl0sdT1vW28ubGVuZ3RoLTFdfXJldHVybiBvfSl9fSxmdW5jdGlvbihoLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBufSk7dmFyIHI9dCg0NSk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIG4odSl7Zm9yKHZhciBvLGY9W10seD0wLGM9MCx2PTAscD0wLGI9bnVsbCxFPW51bGwseT0wLE09MCxpPTAsYT11Lmxlbmd0aDtpPGE7aSsrKXt2YXIgcz11W2ldLGw9c1swXTtzd2l0Y2gobCl7Y2FzZSJNIjp2PXNbMV0scD1zWzJdO2JyZWFrO2Nhc2UiQSI6dmFyIE89T2JqZWN0KHIuZGVmYXVsdCkoeSxNLHNbNl0sc1s3XSxzWzRdLHNbNV0sc1sxXSxzWzJdLHNbM10pO2lmKCFPLmxlbmd0aCljb250aW51ZTtPPU8ubWFwKEw9Pntjb25zdFtELEMsUyxCLHcsSCxKLHFdPUw7cmV0dXJue3gxOlMseTE6Qix4Mjp3LHkyOkgseDpKLHk6cX19KTtmb3IodmFyIEE9MCxSO0E8Ty5sZW5ndGg7QSsrKVI9T1tBXSxzPVsiQyIsUi54MSxSLnkxLFIueDIsUi55MixSLngsUi55XSxBPE8ubGVuZ3RoLTEmJmYucHVzaChzKTticmVhaztjYXNlIlMiOnZhciBJPXksUD1NOyhvPT0iQyJ8fG89PSJTIikmJihJKz1JLXgsUCs9UC1jKSxzPVsiQyIsSSxQLHNbMV0sc1syXSxzWzNdLHNbNF1dO2JyZWFrO2Nhc2UiVCI6bz09IlEifHxvPT0iVCI/KGI9eSoyLWIsRT1NKjItRSk6KGI9eSxFPU0pLHM9Zyh5LE0sYixFLHNbMV0sc1syXSk7YnJlYWs7Y2FzZSJRIjpiPXNbMV0sRT1zWzJdLHM9Zyh5LE0sc1sxXSxzWzJdLHNbM10sc1s0XSk7YnJlYWs7Y2FzZSJMIjpzPWQoeSxNLHNbMV0sc1syXSk7YnJlYWs7Y2FzZSJIIjpzPWQoeSxNLHNbMV0sTSk7YnJlYWs7Y2FzZSJWIjpzPWQoeSxNLHksc1sxXSk7YnJlYWs7Y2FzZSJaIjpzPWQoeSxNLHYscCk7YnJlYWt9bz1sLHk9c1tzLmxlbmd0aC0yXSxNPXNbcy5sZW5ndGgtMV0scy5sZW5ndGg+ND8oeD1zW3MubGVuZ3RoLTRdLGM9c1tzLmxlbmd0aC0zXSk6KHg9eSxjPU0pLGYucHVzaChzKX1yZXR1cm4gZn1mdW5jdGlvbiBkKHUsbyxmLHgpe3JldHVyblsiQyIsdSxvLGYseCxmLHhdfWZ1bmN0aW9uIGcodSxvLGYseCxjLHYpe3JldHVyblsiQyIsdS8zKzIvMypmLG8vMysyLzMqeCxjLzMrMi8zKmYsdi8zKzIvMyp4LGMsdl19fSxmdW5jdGlvbihoLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiB1fSksdCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IHI9TWF0aC5QSSoyO2Z1bmN0aW9uIG4obyxmLHgsYyl7Y29uc3Qgdj1vKmMtZip4PDA/LTE6MTtsZXQgcD1vKngrZipjO3JldHVybiBwPjEmJihwPTEpLHA8LTEmJihwPS0xKSx2Kk1hdGguYWNvcyhwKX1mdW5jdGlvbiBkKG8sZix4LGMsdixwLGIsRSx5LE0pe2NvbnN0IGk9TSooby14KS8yK3kqKGYtYykvMixhPS15KihvLXgpLzIrTSooZi1jKS8yLHM9YipiLGw9RSpFLE89aSppLEE9YSphO2xldCBSPXMqbC1zKkEtbCpPO1I8MCYmKFI9MCksUi89cypBK2wqTyxSPU1hdGguc3FydChSKSoodj09PXA/LTE6MSk7Y29uc3QgST1SKmIvRSphLFA9UiotRS9iKmksTD1NKkkteSpQKyhvK3gpLzIsRD15KkkrTSpQKyhmK2MpLzIsQz0oaS1JKS9iLFM9KGEtUCkvRSxCPSgtaS1JKS9iLHc9KC1hLVApL0UsSD1uKDEsMCxDLFMpO2xldCBKPW4oQyxTLEIsdyk7cmV0dXJuIHA9PT0wJiZKPjAmJihKLT1yKSxwPT09MSYmSjwwJiYoSis9ciksW0wsRCxILEpdfWZ1bmN0aW9uIGcobyxmKXtjb25zdCB4PTEuMzMzMzMzMzMzMzMzMzMzMypNYXRoLnRhbihmLzQpLGM9TWF0aC5jb3Mobyksdj1NYXRoLnNpbihvKSxwPU1hdGguY29zKG8rZiksYj1NYXRoLnNpbihvK2YpO3JldHVybltjLHYsYy12KngsditjKngscCtiKngsYi1wKngscCxiXX1mdW5jdGlvbiB1KG8sZix4LGMsdixwLGIsRSx5KXtjb25zdCBNPU1hdGguc2luKHkqci8zNjApLGk9TWF0aC5jb3MoeSpyLzM2MCksYT1pKihvLXgpLzIrTSooZi1jKS8yLHM9LU0qKG8teCkvMitpKihmLWMpLzI7aWYoYT09PTAmJnM9PT0wKXJldHVybltdO2lmKGI9PT0wfHxFPT09MClyZXR1cm5bXTtiPU1hdGguYWJzKGIpLEU9TWF0aC5hYnMoRSk7Y29uc3QgbD1hKmEvKGIqYikrcypzLyhFKkUpO2w+MSYmKGIqPU1hdGguc3FydChsKSxFKj1NYXRoLnNxcnQobCkpO2NvbnN0IE89ZChvLGYseCxjLHYscCxiLEUsTSxpKSxBPVtdO2xldCBSPU9bMl0sST1PWzNdO2NvbnN0IFA9TWF0aC5tYXgoTWF0aC5jZWlsKE1hdGguYWJzKEkpLyhyLzQpKSwxKTtJLz1QO2ZvcihsZXQgTD0wO0w8UDtMKyspQS5wdXNoKGcoUixJKSksUis9STtyZXR1cm4gQS5tYXAoTD0+e2ZvcihsZXQgRD0wO0Q8TC5sZW5ndGg7RCs9Mil7bGV0IEM9TFtEKzBdLFM9TFtEKzFdO0MqPWIsUyo9RTtjb25zdCBCPWkqQy1NKlMsdz1NKkMraSpTO0xbRCswXT1CK09bMF0sTFtEKzFdPXcrT1sxXX1yZXR1cm4gTH0pfX0sZnVuY3Rpb24oaCxlLHQpe3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTt2YXIgcj10KDQ3KSx7Y29weTpufT10KDQ5KSxkPXQoNTApO2Z1bmN0aW9uIGcoYyx2LHApe3JldHVybiBjWzBdPXYsY1sxXT1wLGN9dmFyIHU9WzAsMF0sbz1bMCwwXSxmPVswLDBdO2Z1bmN0aW9uIHgoYyx2LHAsYil7cihwLGcodSxiWzFdLGJbMl0pLGcobyxiWzNdLGJbNF0pLGcoZixiWzVdLGJbNl0pLHYsYyl9aC5leHBvcnRzPWZ1bmN0aW9uKHYscCxiKXt2YXIgRT1bXSx5PVtdLE09WzAsMF07cmV0dXJuIHYuZm9yRWFjaChmdW5jdGlvbihpLGEscyl7aWYoaVswXT09PSJNIiluKE0saS5zbGljZSgxKSkseS5sZW5ndGg+MCYmKEUucHVzaCh5KSx5PVtdKTtlbHNlIGlmKGlbMF09PT0iQyIpeCh5LHAsTSxpKSxnKE0saVs1XSxpWzZdKTtlbHNlIHRocm93IG5ldyBFcnJvcigiaWxsZWdhbCB0eXBlIGluIFNWRzogIitpWzBdKX0pLHkubGVuZ3RoPjAmJkUucHVzaCh5KSxFLm1hcChmdW5jdGlvbihpKXtyZXR1cm4gZChpLGJ8fDApfSl9fSxmdW5jdGlvbihoLGUsdCl7aC5leHBvcnRzPXQoNDgpKCl9LGZ1bmN0aW9uKGgsZSl7ZnVuY3Rpb24gdChuKXtyZXR1cm5bblswXSxuWzFdXX1mdW5jdGlvbiByKG4sZCl7cmV0dXJuW24sZF19aC5leHBvcnRzPWZ1bmN0aW9uKGQpe2Q9ZHx8e307dmFyIGc9dHlwZW9mIGQucmVjdXJzaW9uPT0ibnVtYmVyIj9kLnJlY3Vyc2lvbjo4LHU9dHlwZW9mIGQuZXBzaWxvbj09Im51bWJlciI/ZC5lcHNpbG9uOjExOTIwOTI5ZS0xNCxvPXR5cGVvZiBkLnBhdGhFcHNpbG9uPT0ibnVtYmVyIj9kLnBhdGhFcHNpbG9uOjEsZj10eXBlb2YgZC5hbmdsZUVwc2lsb249PSJudW1iZXIiP2QuYW5nbGVFcHNpbG9uOi4wMSx4PWQuYW5nbGVUb2xlcmFuY2V8fDAsYz1kLmN1c3BMaW1pdHx8MDtyZXR1cm4gZnVuY3Rpb24oRSx5LE0saSxhLHMpe3N8fChzPVtdKSxhPXR5cGVvZiBhPT0ibnVtYmVyIj9hOjE7dmFyIGw9by9hO3JldHVybiBsKj1sLHYoRSx5LE0saSxzLGwpLHN9O2Z1bmN0aW9uIHYoYixFLHksTSxpLGEpe2kucHVzaCh0KGIpKTt2YXIgcz1iWzBdLGw9YlsxXSxPPUVbMF0sQT1FWzFdLFI9eVswXSxJPXlbMV0sUD1NWzBdLEw9TVsxXTtwKHMsbCxPLEEsUixJLFAsTCxpLGEsMCksaS5wdXNoKHQoTSkpfWZ1bmN0aW9uIHAoYixFLHksTSxpLGEscyxsLE8sQSxSKXtpZighKFI+Zykpe3ZhciBJPU1hdGguUEksUD0oYit5KS8yLEw9KEUrTSkvMixEPSh5K2kpLzIsQz0oTSthKS8yLFM9KGkrcykvMixCPShhK2wpLzIsdz0oUCtEKS8yLEg9KEwrQykvMixKPShEK1MpLzIscT0oQytCKS8yLFU9KHcrSikvMixHPShIK3EpLzI7aWYoUj4wKXt2YXIgWj1zLWIsdHQ9bC1FLF89TWF0aC5hYnMoKHktcykqdHQtKE0tbCkqWiksc3Q9TWF0aC5hYnMoKGktcykqdHQtKGEtbCkqWiksayxodDtpZihfPnUmJnN0PnUpe2lmKChfK3N0KSooXytzdCk8PUEqKFoqWit0dCp0dCkpe2lmKHg8Zil7Ty5wdXNoKHIoVSxHKSk7cmV0dXJufXZhciBmdD1NYXRoLmF0YW4yKGEtTSxpLXkpO2lmKGs9TWF0aC5hYnMoZnQtTWF0aC5hdGFuMihNLUUseS1iKSksaHQ9TWF0aC5hYnMoTWF0aC5hdGFuMihsLWEscy1pKS1mdCksaz49SSYmKGs9MipJLWspLGh0Pj1JJiYoaHQ9MipJLWh0KSxrK2h0PHgpe08ucHVzaChyKFUsRykpO3JldHVybn1pZihjIT09MCl7aWYoaz5jKXtPLnB1c2gocih5LE0pKTtyZXR1cm59aWYoaHQ+Yyl7Ty5wdXNoKHIoaSxhKSk7cmV0dXJufX19fWVsc2UgaWYoXz51KXtpZihfKl88PUEqKFoqWit0dCp0dCkpe2lmKHg8Zil7Ty5wdXNoKHIoVSxHKSk7cmV0dXJufWlmKGs9TWF0aC5hYnMoTWF0aC5hdGFuMihhLU0saS15KS1NYXRoLmF0YW4yKE0tRSx5LWIpKSxrPj1JJiYoaz0yKkktayksazx4KXtPLnB1c2gocih5LE0pKSxPLnB1c2gocihpLGEpKTtyZXR1cm59aWYoYyE9PTAmJms+Yyl7Ty5wdXNoKHIoeSxNKSk7cmV0dXJufX19ZWxzZSBpZihzdD51KXtpZihzdCpzdDw9QSooWipaK3R0KnR0KSl7aWYoeDxmKXtPLnB1c2gocihVLEcpKTtyZXR1cm59aWYoaz1NYXRoLmFicyhNYXRoLmF0YW4yKGwtYSxzLWkpLU1hdGguYXRhbjIoYS1NLGkteSkpLGs+PUkmJihrPTIqSS1rKSxrPHgpe08ucHVzaChyKHksTSkpLE8ucHVzaChyKGksYSkpO3JldHVybn1pZihjIT09MCYmaz5jKXtPLnB1c2gocihpLGEpKTtyZXR1cm59fX1lbHNlIGlmKFo9VS0oYitzKS8yLHR0PUctKEUrbCkvMixaKlordHQqdHQ8PUEpe08ucHVzaChyKFUsRykpO3JldHVybn19cChiLEUsUCxMLHcsSCxVLEcsTyxBLFIrMSkscChVLEcsSixxLFMsQixzLGwsTyxBLFIrMSl9fX19LGZ1bmN0aW9uKGgsZSx0KXt0LnIoZSksdC5kKGUsImNyZWF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gZH0pLHQuZChlLCJjbG9uZSIsZnVuY3Rpb24oKXtyZXR1cm4gbn0pLHQuZChlLCJjb3B5IixmdW5jdGlvbigpe3JldHVybiBnfSksdC5kKGUsInNjYWxlQW5kQWRkIixmdW5jdGlvbigpe3JldHVybiB1fSksdC5kKGUsImRvdCIsZnVuY3Rpb24oKXtyZXR1cm4gb30pLHQuZChlLCJyb3RhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIGZ9KSx0LmQoZSwiY3Jvc3MiLGZ1bmN0aW9uKCl7cmV0dXJuIHh9KSx0LmQoZSwic3ViIixmdW5jdGlvbigpe3JldHVybiBjfSksdC5kKGUsImFkZCIsZnVuY3Rpb24oKXtyZXR1cm4gdn0pLHQuZChlLCJjb21wdXRlTWl0ZXIiLGZ1bmN0aW9uKCl7cmV0dXJuIHl9KSx0LmQoZSwibm9ybWFsIixmdW5jdGlvbigpe3JldHVybiBNfSksdC5kKGUsImRpcmVjdGlvbiIsZnVuY3Rpb24oKXtyZXR1cm4gaX0pO3ZhciByPXQoMSk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIG4oYSl7cmV0dXJuW2FbMF0sYVsxXV19ZnVuY3Rpb24gZCgpe3JldHVyblswLDBdfWNvbnN0IGc9ci52ZWMyLmNvcHksdT1yLnZlYzIuc2NhbGVBbmRBZGQsbz1yLnZlYzIuZG90LGY9ci52ZWMyLnJvdGF0ZSx4PXIudmVjMi5jcm9zcyxjPXIudmVjMi5zdWIsdj1yLnZlYzIuYWRkLHA9ci52ZWMyLm5vcm1hbGl6ZSxiPXIudmVjMi5zZXQsRT1kKCk7ZnVuY3Rpb24geShhLHMsbCxPLEEpe3YoYSxsLE8pLHAoYSxhKSxiKHMsLWFbMV0sYVswXSksYihFLC1sWzFdLGxbMF0pO2NvbnN0IFI9QS9vKHMsRSk7cmV0dXJuIE1hdGguYWJzKFIpfWZ1bmN0aW9uIE0oYSxzKXtyZXR1cm4gYihhLC1zWzFdLHNbMF0pLGF9ZnVuY3Rpb24gaShhLHMsbCl7cmV0dXJuIGMoYSxzLGwpLHAoYSxhKSxhfX0sZnVuY3Rpb24oaCxlLHQpe3ZhciByPXQoNTEpLG49dCg1Mik7aC5leHBvcnRzPWZ1bmN0aW9uKGcsdSl7cmV0dXJuIGc9cihnLHUpLGc9bihnLHUpLGd9LGguZXhwb3J0cy5yYWRpYWxEaXN0YW5jZT1yLGguZXhwb3J0cy5kb3VnbGFzUGV1Y2tlcj1ufSxmdW5jdGlvbihoLGUpe2Z1bmN0aW9uIHQocixuKXt2YXIgZD1yWzBdLW5bMF0sZz1yWzFdLW5bMV07cmV0dXJuIGQqZCtnKmd9aC5leHBvcnRzPWZ1bmN0aW9uKG4sZCl7aWYobi5sZW5ndGg8PTEpcmV0dXJuIG47ZD10eXBlb2YgZD09Im51bWJlciI/ZDoxO2Zvcih2YXIgZz1kKmQsdT1uWzBdLG89W3VdLGYseD0xLGM9bi5sZW5ndGg7eDxjO3grKylmPW5beF0sdChmLHUpPmcmJihvLnB1c2goZiksdT1mKTtyZXR1cm4gdSE9PWYmJm8ucHVzaChmKSxvfX0sZnVuY3Rpb24oaCxlKXtmdW5jdGlvbiB0KG4sZCxnKXt2YXIgdT1kWzBdLG89ZFsxXSxmPWdbMF0tdSx4PWdbMV0tbztpZihmIT09MHx8eCE9PTApe3ZhciBjPSgoblswXS11KSpmKyhuWzFdLW8pKngpLyhmKmYreCp4KTtjPjE/KHU9Z1swXSxvPWdbMV0pOmM+MCYmKHUrPWYqYyxvKz14KmMpfXJldHVybiBmPW5bMF0tdSx4PW5bMV0tbyxmKmYreCp4fWZ1bmN0aW9uIHIobixkLGcsdSxvKXtmb3IodmFyIGY9dSx4LGM9ZCsxO2M8ZztjKyspe3ZhciB2PXQobltjXSxuW2RdLG5bZ10pO3Y+ZiYmKHg9YyxmPXYpfWY+dSYmKHgtZD4xJiZyKG4sZCx4LHUsbyksby5wdXNoKG5beF0pLGcteD4xJiZyKG4seCxnLHUsbykpfWguZXhwb3J0cz1mdW5jdGlvbihkLGcpe2lmKGQubGVuZ3RoPD0xKXJldHVybiBkO2c9dHlwZW9mIGc9PSJudW1iZXIiP2c6MTt2YXIgdT1nKmcsbz1kLmxlbmd0aC0xLGY9W2RbMF1dO3JldHVybiByKGQsMCxvLHUsZiksZi5wdXNoKGRbb10pLGZ9fSxmdW5jdGlvbihoLGUsdCl7dC5yKGUpLHQuZChlLCJnZXRUb3RhbExlbmd0aCIsZnVuY3Rpb24oKXtyZXR1cm4gbn0pLHQuZChlLCJnZXRQb2ludEF0TGVuZ3RoIixmdW5jdGlvbigpe3JldHVybiBnfSksdC5kKGUsImdldERhc2hDb250b3VycyIsZnVuY3Rpb24oKXtyZXR1cm4gdX0pO3ZhciByPXQoNTQpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBuKG8pe2lmKG8udG90YWxMZW5ndGghPW51bGwpcmV0dXJuIG8udG90YWxMZW5ndGg7bGV0IGY9MDtyZXR1cm4gby5mb3JFYWNoKHg9PntsZXQgYz14WzBdO2ZvcihsZXQgdj0xO3Y8eC5sZW5ndGg7disrKXtjb25zdCBwPXhbdl07Zis9T2JqZWN0KHIuZGlzdGFuY2UpKGMscCksYz1wfX0pLG8udG90YWxMZW5ndGg9ZixmfWZ1bmN0aW9uIGQobyxmLHg9ITApe2lmKGY9TnVtYmVyKGYpLCFOdW1iZXIuaXNGaW5pdGUoZikpdGhyb3cgbmV3IFR5cGVFcnJvcigiRmFpbGVkIHRvIGV4ZWN1dGUgJ2dldFBvaW50QXRMZW5ndGgnIG9uIGZpZ3VyZTogVGhlIHByb3ZpZGVkIGZsb2F0IHZhbHVlIGlzIG5vbi1maW5pdGUuIik7aWYoZjw9MCl0aHJvdyBuZXcgVHlwZUVycm9yKCJMZW5ndGggbXVzdCA+IDAiKTtjb25zdCBjPW4obyk7aWYoZj49Yyl7Y29uc3QgcD1vW28ubGVuZ3RoLTFdLGI9cFtwLmxlbmd0aC0yXSxFPXBbcC5sZW5ndGgtMV0seT1NYXRoLmF0YW4yKEVbMV0tYlsxXSxFWzBdLWJbMF0pO3JldHVybntjdXJyZW50Om8ubWFwKE09PlsuLi5NXSkscG9pbnQ6e3g6RVswXSx5OkVbMV0sYW5nbGU6eX19fWNvbnN0IHY9W107Zm9yKGxldCBwPTA7cDxvLmxlbmd0aDtwKyspe3ZbcF09W107Y29uc3QgYj1vW3BdO2xldCBFPWJbMF07Zm9yKGxldCB5PTE7eTxiLmxlbmd0aDt5Kyspe2NvbnN0IE09Ylt5XSxpPU9iamVjdChyLmRpc3RhbmNlKShFLE0pO2lmKGY8aSl7Y29uc3QgYT1mL2kscz1NYXRoLmF0YW4yKE1bMV0tRVsxXSxNWzBdLUVbMF0pLGw9e3g6RVswXSooMS1hKStNWzBdKmEseTpFWzFdKigxLWEpK01bMV0qYSxhbmdsZTpzfTtpZih2W3BdLnB1c2goRSksZj4wJiZ2W3BdLnB1c2goW2wueCxsLnldKSwheClyZXR1cm57Y3VycmVudDp2LHBvaW50Omx9O2NvbnN0IE89W10sQT1wO2Zvcig7cDxvLmxlbmd0aDtwKyspe2ZvcihPW3AtQV09W10scD09PUEmJk9bMF0ucHVzaChbbC54LGwueV0pO3k8Yi5sZW5ndGg7eSsrKU9bcC1BXS5wdXNoKGJbeV0pO3k9MH1yZXR1cm57Y3VycmVudDp2LHBvaW50OmwscmVzdDpPfX1mLT1pLHZbcF0ucHVzaChFKSxFPU19fX1mdW5jdGlvbiBnKG8sZil7aWYoZj1OdW1iZXIoZiksIU51bWJlci5pc0Zpbml0ZShmKSl0aHJvdyBuZXcgVHlwZUVycm9yKCJGYWlsZWQgdG8gZXhlY3V0ZSAnZ2V0UG9pbnRBdExlbmd0aCcgb24gZmlndXJlOiBUaGUgcHJvdmlkZWQgZmxvYXQgdmFsdWUgaXMgbm9uLWZpbml0ZS4iKTtpZihvLmxlbmd0aDw9MClyZXR1cm57eDowLHk6MCxhbmdsZTowfTtpZihmPD0wKXtjb25zdCB4PW9bMF1bMF0sYz1vWzBdWzFdLHY9TWF0aC5hdGFuMihjWzFdLXhbMV0sY1swXS14WzBdKTtyZXR1cm57eDp4WzBdLHk6eFsxXSxhbmdsZTp2fX1yZXR1cm4gZChvLGYsITEpLnBvaW50fWZ1bmN0aW9uIHUobyxmLHgpe2xldCBjPTAsdj1mWzBdLHA9bztjb25zdCBiPVtdLEU9Zi5sZW5ndGg7aWYoeD4wKXtkbyB4LT1mW2MlRV0sYysrO3doaWxlKHg+MCk7eDwwJiYodj0teCxjLS0pfWVsc2UgaWYoeDwwKXtjPS0xO2RvIHgrPWZbYyVFK0UtMV0sYy0tO3doaWxlKHg8MCk7eD49MCYmKGMrKyx2PWZbYyVFK0UtMV0teCl9ZG97Y29uc3QgeT1kKHAsdik7cD15LnJlc3QsKytjJTImJmIucHVzaCguLi55LmN1cnJlbnQpO2xldCBNPWMlRTtNPDAmJihNKz1FKSx2PWZbTV19d2hpbGUocCk7cmV0dXJuIGJ9fSxmdW5jdGlvbihoLGUsdCl7dC5yKGUpLHQuZChlLCJub3JtYWxpemUiLGZ1bmN0aW9uKCl7cmV0dXJuIHJ9KSx0LmQoZSwiZGlzdGFuY2UiLGZ1bmN0aW9uKCl7cmV0dXJuIG59KSx0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gcihbZCxnLHVdLG8sZix4KXtyZXR1cm4gZD1kKjIvby0xLGc9MS1nKjIvZixOdW1iZXIuaXNGaW5pdGUoeCk/KHU9dSoyL3gtMSxbZCxnLHVdKTpbZCxnXX1mdW5jdGlvbiBuKFtkLGcsdT0wXSxbbyxmLHg9MF0pe3JldHVybiBNYXRoLmh5cG90KG8tZCxmLWcseC11KX19LGZ1bmN0aW9uKGgsZSx0KXt0LnIoZSksdC5kKGUsImdldFBvaW50IixmdW5jdGlvbigpe3JldHVybiBufSksdCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IHI9TWF0aC5QSSoyO2Z1bmN0aW9uIG4oZCxnLHUsbyxmKXtmJT1yLGY8MCYmKGYrPXIpO2NvbnN0IHg9TWF0aC50YW4oZik7aWYoTWF0aC5hYnMoeCk8MWU1KXtjb25zdCBjPWcteCpkLHY9MS91KioyK3gqKjIvbyoqMjtsZXQgcD0tMTsoZjw9TWF0aC5QSS8yfHxmPjMqTWF0aC5QSS8yKSYmKHA9MSk7Y29uc3QgYj1wKk1hdGguc3FydCgxL3YpK2QsRT14KmIrYztyZXR1cm5bYixFXX1yZXR1cm4gZjxNYXRoLlBJP1tkLGcrb106W2QsZy1vXX19LGZ1bmN0aW9uKGgsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIFZ9KTt2YXIgcj10KDEpLG49dCg0MiksZD10Lm4obiksZz10KDU3KSx1PXQoMjgpLG89dCgyNCksZj10KDMwKSx4PXQoNTkpLGM9dCg1Myksdj10KDYwKSxwPXQubih2KSxiPXQoNDYpLEU9dC5uKGIpLHk9dCgzMSksTT10KDQwKSxpPXQoMjEpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBhKFgsail7aWYoWD09bnVsbClyZXR1cm57fTt2YXIgej1zKFgsaiksbSxUO2lmKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpe3ZhciBOPU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoWCk7Zm9yKFQ9MDtUPE4ubGVuZ3RoO1QrKyltPU5bVF0sIShqLmluZGV4T2YobSk+PTApJiZPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoWCxtKSYmKHpbbV09WFttXSl9cmV0dXJuIHp9ZnVuY3Rpb24gcyhYLGope2lmKFg9PW51bGwpcmV0dXJue307dmFyIHo9e30sbT1PYmplY3Qua2V5cyhYKSxULE47Zm9yKE49MDtOPG0ubGVuZ3RoO04rKylUPW1bTl0sIShqLmluZGV4T2YoVCk+PTApJiYoeltUXT1YW1RdKTtyZXR1cm4gen1jb25zdCBsPVN5bWJvbCgibWVzaCIpLE89U3ltYm9sKCJjb250b3VycyIpLEE9U3ltYm9sKCJzdHJva2UiKSxSPVN5bWJvbCgiZmlsbCIpLEk9U3ltYm9sKCJzdHJva2VDb2xvciIpLFA9U3ltYm9sKCJmaWxsQ29sb3IiKSxMPVN5bWJvbCgidHJhbnNmb3JtIiksRD1TeW1ib2woImludmVydFRyYW5zZm9ybSIpLEM9U3ltYm9sKCJ1bmlmb3JtcyIpLFM9U3ltYm9sKCJ0ZXhPcHRpb25zIiksQj1TeW1ib2woImJsZW5kIiksdz1TeW1ib2woImFwcGx5VGV4dHVyZSIpLEg9U3ltYm9sKCJhcHBseVRyYW5zZm9ybSIpLEo9U3ltYm9sKCJhcHBseUdyYWRpZW50VHJhbnNmb3JtIikscT1TeW1ib2woImFwcGx5UHJvZ3JhbSIpLFU9U3ltYm9sKCJncmFkaWVudCIpLEc9U3ltYm9sKCJmaWx0ZXIiKSxaPVN5bWJvbCgib3BhY2l0eSIpLHR0PVN5bWJvbCgicHJvZ3JhbSIpLF89U3ltYm9sKCJhdHRyaWJ1dGVzIiksc3Q9U3ltYm9sKCJwYXNzIiksaz1TeW1ib2woImNsaXBDb250ZXh0IiksaHQ9U3ltYm9sKCJhcHBseUNsaXBQYXRoIik7ZnVuY3Rpb24gZnQoWCxqKXtjb25zdFt6LG1dPVtYWzFdWzBdLVhbMF1bMF0sWFsxXVsxXS1YWzBdWzFdXSxUPVtdO2ZvcihsZXQgTj0wO048ai5sZW5ndGg7TisrKXtjb25zdCAkPWpbTl0sSz1bKCRbMF0tWFswXVswXSkveiwxLSgkWzFdLVhbMF1bMV0pL21dO1QucHVzaChLKX1yZXR1cm4gVH1mdW5jdGlvbiBXKFtYLGpdLFt6LG0sVCxOXSx7c2NhbGU6JH0pe3JldHVybiAkfHwoWC89VCxqPTEtai9OLFgtPXosais9bSksW1gsaiwwXX1mdW5jdGlvbiBGKFgsaix6KXtjb25zdCBtPUUoKShYLGoseik7cmV0dXJuIG0ucGF0aD1YLG0uc2ltcGxpZnk9eixtLnNjYWxlPWosbX1jbGFzcyBWe2NvbnN0cnVjdG9yKGope3RoaXNbQV09bnVsbCx0aGlzW1JdPW51bGwsdGhpc1tMXT1bMSwwLDAsMSwwLDBdLHRoaXNbWl09MSx0aGlzW0NdPXt9LHRoaXNbR109W10sdGhpc1tCXT1udWxsLHRoaXNbU109e30sdGhpcy5jb250b3Vycz1qLmNvbnRvdXJzLHRoaXNbdHRdPW51bGwsdGhpc1tfXT17fSx0aGlzW3N0XT1bXX1nZXQgY29udG91cnMoKXtyZXR1cm4gdGhpc1tPXX1zZXQgY29udG91cnMoail7dGhpc1tsXT1udWxsLHRoaXNbT109ajtjb25zdCB6PWouc2NhbGU7dGhpcy50cmFuc2Zvcm1TY2FsZS96PjEuNSYmdGhpcy5hY2N1cmF0ZSh0aGlzLnRyYW5zZm9ybVNjYWxlKX1zZXRQcm9ncmFtKGope3RoaXNbdHRdPWosdGhpc1tsXSYmdGhpc1txXShqKX1nZXQgcHJvZ3JhbSgpe3JldHVybiB0aGlzW3R0XX1zZXRBdHRyaWJ1dGUoaix6KXt6PT1udWxsP2RlbGV0ZSB0aGlzW19dW2pdOnRoaXNbX11bal09en1nZXRPcGFjaXR5KCl7cmV0dXJuIHRoaXNbWl19c2V0T3BhY2l0eShqKXtpZihqPDB8fGo+MSl0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIG9wYWNpdHkgdmFsdWUuIik7dGhpc1tsXSYmdGhpc1tsXS5wb3NpdGlvbnMuZm9yRWFjaCh6PT57elsyXT0xL3pbMl0+MD9qOi1qfSksdGhpc1taXT1qfXNldENsaXBQYXRoKGope3RoaXMuY2xpcFBhdGg9aix0aGlzW0NdLnVfY2xpcFNhbXBsZXImJnRoaXNbQ10udV9jbGlwU2FtcGxlci5kZWxldGUoKSx0aGlzLnNldFVuaWZvcm1zKHt1X2NsaXBTYW1wbGVyOm51bGx9KSx0aGlzW2xdJiZkZWxldGUgdGhpc1tsXS5hdHRyaWJ1dGVzLmFfY2xpcFVWLGomJnRoaXNbbF0mJnRoaXNbaHRdKCl9W2h0XSgpe2lmKHRoaXMuY2xpcFBhdGgpe3RoaXNba118fCh0aGlzW2tdPWkuZGVmYXVsdC5jcmVhdGVDYW52YXMoMSwxKSk7Y29uc3RbW2osel0sW20sVF1dPXRoaXMuYm91bmRpbmdCb3g7bSYmVCYmKHRoaXNba10ud2lkdGg9bS1qLHRoaXNba10uaGVpZ2h0PVQteik7Y29uc3QgTj10aGlzW2tdLmdldENvbnRleHQoIjJkIiksJD1uZXcgUGF0aDJEKHRoaXMuY2xpcFBhdGgpO04uY2xlYXJSZWN0KDAsMCx0aGlzW2tdLndpZHRoLHRoaXNba10uaGVpZ2h0KSxOLnNhdmUoKSxOLnRyYW5zbGF0ZSgtaiwteiksTi5maWxsU3R5bGU9IndoaXRlIixOLmZpbGwoJCksTi5yZXN0b3JlKCksdGhpc1tsXS5jbGlwUGF0aD10aGlzW2tdO2NvbnN0IEs9ZnQodGhpcy5ib3VuZGluZ0JveCx0aGlzW2xdLnBvc2l0aW9uMCk7dGhpc1tsXS5hdHRyaWJ1dGVzLmFfY2xpcFVWPUt9fWdldFBvaW50QXRMZW5ndGgoail7cmV0dXJuIE9iamVjdChjLmdldFBvaW50QXRMZW5ndGgpKHRoaXNbT10sail9Z2V0VG90YWxMZW5ndGgoKXtyZXR1cm4gT2JqZWN0KGMuZ2V0VG90YWxMZW5ndGgpKHRoaXNbT10pfWdldCBibGVuZCgpe3JldHVybiB0aGlzW0JdPT1udWxsPyJhdXRvIjp0aGlzW0JdfXNldCBibGVuZChqKXt0aGlzW0JdPWosdGhpc1tsXSYmKHRoaXNbbF0uZW5hYmxlQmxlbmQ9dGhpcy5lbmFibGVCbGVuZCl9Z2V0IGJvdW5kaW5nQm94KCl7aWYodGhpc1tsXSYmdGhpc1tsXS5ib3VuZGluZ0JveClyZXR1cm4gdGhpc1tsXS5ib3VuZGluZ0JveDtjb25zdCBqPXRoaXMubWVzaERhdGE7aWYoail7Y29uc3Qgej1qLnBvc2l0aW9uMDtpZih6Lmxlbmd0aClqLmJvdW5kaW5nQm94PWQoKSh6KTtlbHNlIHJldHVybltbMCwwXSxbMCwwXV07cmV0dXJuIGouYm91bmRpbmdCb3h9cmV0dXJuW1swLDBdLFswLDBdXX1nZXQgYm91bmRpbmdDZW50ZXIoKXtjb25zdCBqPXRoaXMuYm91bmRpbmdCb3g7cmV0dXJuIGo/Wy41KihqWzBdWzBdK2pbMV1bMF0pLC41KihqWzBdWzFdK2pbMV1bMV0pXTpbMCwwXX1nZXQgZmlsbFJ1bGUoKXtyZXR1cm4gdGhpc1tSXT90aGlzW1JdLnJ1bGU6Im5vbnplcm8ifWdldCBsaW5lV2lkdGgoKXtyZXR1cm4gdGhpc1tBXT90aGlzW0FdLmxpbmVXaWR0aDowfWdldCBsaW5lQ2FwKCl7cmV0dXJuIHRoaXNbQV0/dGhpc1tBXS5saW5lQ2FwOiIifWdldCBsaW5lSm9pbigpe3JldHVybiB0aGlzW0FdP3RoaXNbQV0ubGluZUpvaW46IiJ9Z2V0IG1pdGVyTGltaXQoKXtyZXR1cm4gdGhpc1tBXT90aGlzW0FdLm1pdGVyTGltaXQ6MH1nZXQgc3Ryb2tlU3R5bGUoKXtyZXR1cm4gdGhpc1tJXSYmdGhpc1tJXVszXSE9PTA/T2JqZWN0KG8uZGVmYXVsdCkodGhpc1tJXSk6IiJ9Z2V0IGxpbmVEYXNoKCl7cmV0dXJuIHRoaXNbQV0/dGhpc1tBXS5saW5lRGFzaDpudWxsfWdldCBsaW5lRGFzaE9mZnNldCgpe3JldHVybiB0aGlzW0FdP3RoaXNbQV0ubGluZURhc2hPZmZzZXQ6MH1nZXQgZmlsbFN0eWxlKCl7cmV0dXJuIHRoaXNbUF0mJnRoaXNbUF1bM10hPT0wP09iamVjdChvLmRlZmF1bHQpKHRoaXNbUF0pOiIifWdldCBncmFkaWVudCgpe3JldHVybiB0aGlzW1VdfWdldCB0ZXh0dXJlKCl7cmV0dXJuIHRoaXNbQ10udV90ZXhTYW1wbGVyP3tpbWFnZTp0aGlzW0NdLnVfdGV4U2FtcGxlci5faW1nLG9wdGlvbnM6dGhpc1tTXX06bnVsbH1nZXQgZW5hYmxlQmxlbmQoKXtyZXR1cm4gdGhpc1tCXT09PSEwfHx0aGlzW0JdPT09ITE/dGhpc1tCXTp0aGlzW1pdPDF8fHRoaXNbSV0hPW51bGwmJnRoaXNbSV1bM108MXx8dGhpc1tQXSE9bnVsbCYmdGhpc1tQXVszXTwxfHx0aGlzW0NdLnVfY29sb3JNYXRyaXghPW51bGwmJnRoaXNbQ10udV9jb2xvck1hdHJpeFsxOF08MXx8dGhpc1tDXS51X3JhZGlhbEdyYWRpZW50VmVjdG9yIT1udWxsfHx0aGlzLmJlZm9yZVJlbmRlcnx8dGhpcy5hZnRlclJlbmRlcn1nZXQgZmlsdGVyQ2FudmFzKCl7cmV0dXJuL2JsdXJ8ZHJvcC1zaGFkb3d8dXJsLy50ZXN0KHRoaXMuZmlsdGVyKX1nZXQgZmlsdGVyKCl7cmV0dXJuIHRoaXNbR10uam9pbigiICIpfWdldCB0cmFuc2Zvcm1NYXRyaXgoKXtyZXR1cm4gdGhpc1tMXX1nZXQgaW52ZXJ0TWF0cml4KCl7aWYoIXRoaXNbRF0pe2NvbnN0IGo9ci5tYXQyZC5pbnZlcnQoQXJyYXkub2YoMCwwLDAsMCwwLDApLHRoaXNbTF0pO3RoaXNbRF09an1yZXR1cm4gdGhpc1tEXX1nZXQgdHJhbnNmb3JtU2NhbGUoKXtjb25zdCBqPXRoaXNbTF07cmV0dXJuIE1hdGgubWF4KE1hdGguaHlwb3QoalswXSxqWzFdKSxNYXRoLmh5cG90KGpbMl0salszXSkpfWdldCB1bmlmb3Jtcygpe3JldHVybiB0aGlzW0NdfWdldCBwYXNzKCl7cmV0dXJuIHRoaXNbc3RdfVtxXShqKXtjb25zdCB6PXRoaXNbX10sbT10aGlzW2xdLnBvc2l0aW9uMCxUPU9iamVjdC5lbnRyaWVzKGouX2F0dHJpYnV0ZSk7Zm9yKGxldCBOPTA7TjxULmxlbmd0aDtOKyspe2NvbnN0WyQsS109VFtOXTtpZigkIT09ImFfY29sb3IiJiYkIT09ImFfc291cmNlUmVjdCImJkshPT0iaWdub3JlZCIpe2NvbnN0IFk9elskXTtpZigkPT09InV2IiYmIVkpe2NvbnN0IFE9dGhpc1tsXS5ib3VuZGluZ0JveHx8ZCgpKG0pO3RoaXNbbF0uYXR0cmlidXRlc1skXT1mdChRLG0pfWVsc2V7dGhpc1tsXS5hdHRyaWJ1dGVzWyRdPVtdO2ZvcihsZXQgUT0wO1E8bS5sZW5ndGg7USsrKXtjb25zdCBldD1tW1FdO3RoaXNbbF0uYXR0cmlidXRlc1skXS5wdXNoKFk/WShldCxOLG0pOkFycmF5KEsuc2l6ZSkuZmlsbCgwKSl9fX19fWdldCBtZXNoRGF0YSgpe2lmKHRoaXMuX3VwZGF0ZU1hdHJpeCYmdGhpcy50cmFuc2Zvcm1TY2FsZS90aGlzLmNvbnRvdXJzLnNjYWxlPjEuNSYmdGhpcy5hY2N1cmF0ZSh0aGlzLnRyYW5zZm9ybVNjYWxlKSwhdGhpc1tsXSl7IXRoaXNbUl0mJiF0aGlzW0FdJiZ0aGlzLnNldEZpbGwoKTtjb25zdCBqPXRoaXNbT10sej17fTtpZihqJiZqLmxlbmd0aCl7aWYodGhpc1tSXSl0cnl7Y29uc3QgTj1wKCkoaix0aGlzW1JdKTtOLnBvc2l0aW9ucz1OLnBvc2l0aW9ucy5tYXAoJD0+KCQucHVzaCh0aGlzW1pdKSwkKSksTi5hdHRyaWJ1dGVzPXthX2NvbG9yOkFycmF5LmZyb20oe2xlbmd0aDpOLnBvc2l0aW9ucy5sZW5ndGh9KS5tYXAoKCk9PnRoaXNbUF0ubWFwKCQ9Pk1hdGgucm91bmQoMjU1KiQpKSl9LHouZmlsbD1OfWNhdGNoe31pZih0aGlzW0FdKXtjb25zdCBOPXRoaXNbQV0ubGluZURhc2g7bGV0ICQ9ajtpZihOKXtjb25zdCBZPXRoaXNbQV0ubGluZURhc2hPZmZzZXQ7JD1PYmplY3QoYy5nZXREYXNoQ29udG91cnMpKGosTixZKX1jb25zdCBLPSQubWFwKChZLFEpPT57Y29uc3QgZXQ9WS5sZW5ndGg+MSYmci52ZWMyLmVxdWFscyhZWzBdLFlbWS5sZW5ndGgtMV0pLHJ0PXRoaXNbQV0uYnVpbGQoWSxldCk7cmV0dXJuIHAoKShbcnRdKX0pO0suZm9yRWFjaChZPT57WS5wb3NpdGlvbnM9WS5wb3NpdGlvbnMubWFwKFE9PihRLnB1c2goLXRoaXNbWl0pLFEpKSxZLmF0dHJpYnV0ZXM9e2FfY29sb3I6QXJyYXkuZnJvbSh7bGVuZ3RoOlkucG9zaXRpb25zLmxlbmd0aH0pLm1hcCgoKT0+dGhpc1tJXS5tYXAoUT0+TWF0aC5yb3VuZCgyNTUqUSkpKX19KSx6LnN0cm9rZT1PYmplY3QodS5kZWZhdWx0KShLKX19Y29uc3QgbT1PYmplY3QodS5kZWZhdWx0KShbei5maWxsLHouc3Ryb2tlXSk7bS5maWxsUG9pbnRDb3VudD16LmZpbGw/ei5maWxsLnBvc2l0aW9ucy5sZW5ndGg6MCxtLmVuYWJsZUJsZW5kPXRoaXMuZW5hYmxlQmxlbmQsbS5wb3NpdGlvbjA9bS5wb3NpdGlvbnMubWFwKChbTiwkLEtdKT0+W04sJCxLXSksbS51bmlmb3Jtcz10aGlzW0NdLHRoaXNbbF09bSx0aGlzW0NdLnVfdGV4U2FtcGxlciYmdGhpc1t3XShtLHRoaXNbU10pO2NvbnN0IFQ9dGhpc1tMXTtPYmplY3QoeC5pc1VuaXRUcmFuc2Zvcm0pKFQpfHwodGhpc1tIXShtLFQpLHRoaXNbQ10udV9yYWRpYWxHcmFkaWVudFZlY3RvciYmdGhpc1tKXSgpKSx0aGlzLmNsaXBQYXRoJiZ0aGlzW2h0XSgpLHRoaXNbdHRdJiZ0aGlzW3FdKHRoaXNbdHRdKX1yZXR1cm4gdGhpcy5fdXBkYXRlTWF0cml4JiYodGhpc1tsXS5tYXRyaXg9dGhpc1tMXSx0aGlzW0hdKHRoaXNbbF0sdGhpc1tMXSksdGhpc1tDXS51X3JhZGlhbEdyYWRpZW50VmVjdG9yJiZ0aGlzW0pdKCkpLHRoaXNbbF19W0hdKGoseil7Y29uc3R7cG9zaXRpb25zOm0scG9zaXRpb24wOlR9PWo7Zm9yKGxldCBOPTA7TjxtLmxlbmd0aDtOKyspe2NvbnN0WyQsS109VFtOXSxZPW1bTl07WVswXT0kKnpbMF0rSyp6WzJdK3pbNF0sWVsxXT0kKnpbMV0rSyp6WzNdK3pbNV19dGhpcy5fdXBkYXRlTWF0cml4PSExfVtKXSgpe2NvbnN0IGo9dGhpc1tMXSx6PVsuLi50aGlzLl9yYWRpYWxHcmFkaWVudFZlY3Rvcl07aWYoeil7Y29uc3RbbSxULCxOLCRdPXo7elswXT1tKmpbMF0rVCpqWzJdK2pbNF0selsxXT1tKmpbMV0rVCpqWzNdK2pbNV0selszXT1OKmpbMF0rJCpqWzJdK2pbNF0sels0XT1OKmpbMV0rJCpqWzNdK2pbNV0sdGhpc1tDXS51X3JhZGlhbEdyYWRpZW50VmVjdG9yPXp9fVt3XShqLHope2Z1bmN0aW9uIG0oUSxldCl7cmV0dXJuIFE9PW51bGwmJmV0PT1udWxsPyEwOlE9PW51bGx8fGV0PT1udWxsPyExOlFbMF09PT1ldFswXSYmUVsxXT09PWV0WzFdJiZRWzJdPT09ZXRbMl0mJlFbM109PT1ldFszXX1jb25zdCBUPXRoaXNbQ10udV90ZXhTYW1wbGVyO2lmKCFUKXJldHVybjtjb25zdHt3aWR0aDpOLGhlaWdodDokfT1ULl9pbWcsSz16LnNyY1JlY3Q7bGV0IFk9ei5yZWN0fHxbMCwwXTtpZih6LnJvdGF0ZWQmJihZPVstWVsxXSxZWzBdLFlbM10sWVsyXV0pLFlbMl09PW51bGwmJihZWzJdPUs/S1syXTpOKSxZWzNdPT1udWxsJiYoWVszXT1LP0tbM106JCksei5oaWRkZW4pai50ZXh0dXJlQ29vcmQ9ai5wb3NpdGlvbnMubWFwKCgpPT5bLTEsLTEsLTFdKTtlbHNlIGlmKCFqLnRleHR1cmVDb29yZHx8IW0odGhpc1tTXS5yZWN0LHoucmVjdCl8fHRoaXNbU10uaGlkZGVuIT09ei5oaWRkZW58fHRoaXNbU10ucm90YXRlZCE9PXoucm90YXRlZCl7bGV0IFE9bnVsbDt6LnJvdGF0ZWQmJihRPXIubWF0MmQucm90YXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxyLm1hdDJkLmZyb21WYWx1ZXMoMSwwLDAsMSwwLDApLC41Kk1hdGguUEkpLFE9ci5tYXQyZC50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDApLFEsWzAsLVlbMl1dKSksai50ZXh0dXJlQ29vcmQ9ai5wb3NpdGlvbjAubWFwKChbZXQscnQsb3RdKT0+e2lmKDEvb3Q+MCl7aWYoei5yb3RhdGVkKXtjb25zdCBpdD1ldCpRWzBdK3J0KlFbMl0rUVs0XSxudD1ldCpRWzFdK3J0KlFbM10rUVs1XTtbZXQscnRdPVtpdCxudF19Y29uc3QgbHQ9VyhbZXQscnRdLFtZWzBdL1lbMl0sWVsxXS9ZWzNdLFlbMl0sWVszXV0seik7cmV0dXJuIHoucmVwZWF0JiYobHRbMl09MSksbHR9cmV0dXJuWy0xLC0xLC0xXX0pfWlmKEspe2NvbnN0IFE9W0tbMF0vTixLWzFdLyQsS1syXS9OLEtbM10vJF07ai5hdHRyaWJ1dGVzLmFfc291cmNlUmVjdD1qLnBvc2l0aW9ucy5tYXAoKCk9PlsuLi5RXSl9ZWxzZSBqLmF0dHJpYnV0ZXMuYV9zb3VyY2VSZWN0PWoucG9zaXRpb25zLm1hcCgoKT0+WzAsMCwwLDBdKX1hY2N1cmF0ZShqKXtpZighdGhpcy5jb250b3VycylyZXR1cm47aWYodGhpcy5jb250b3Vycy5wYXRoKXtjb25zdCBtPXRoaXMuY29udG91cnMuc2ltcGxpZnksVD1GKHRoaXMuY29udG91cnMucGF0aCwyKmosbSk7dGhpc1tsXT1udWxsLHRoaXNbT109VH19Y2FuSWdub3JlKCl7Y29uc3Qgaj10aGlzW0FdPT1udWxsfHx0aGlzW0FdLmxpbmVXaWR0aD09PTB8fHRoaXNbSV1bM109PT0wLHo9dGhpc1tSXT09bnVsbHx8dGhpc1tQXVszXT09PTAsbT10aGlzW0NdLnVfcmFkaWFsR3JhZGllbnRWZWN0b3I9PW51bGwsVD10aGlzW0NdLnVfdGV4U2FtcGxlcj09bnVsbDtyZXR1cm4gdGhpc1taXT09PTB8fHRoaXNbdHRdPT1udWxsJiZqJiZ6JiZtJiZUJiYhdGhpcy5iZWZvcmVSZW5kZXImJiF0aGlzLmFmdGVyUmVuZGVyfXNldFN0cm9rZSh7dGhpY2tuZXNzOmo9MSxjYXA6ej0iYnV0dCIsam9pbjptPSJtaXRlciIsbWl0ZXJMaW1pdDpUPTEwLGNvbG9yOk49WzAsMCwwLDBdLGxpbmVEYXNoOiQ9bnVsbCxsaW5lRGFzaE9mZnNldDpLPTAscm91bmRTZWdtZW50czpZPTIwfT17fSl7cmV0dXJuIHRoaXNbbF09bnVsbCx0aGlzW0FdPW5ldyBnLmRlZmF1bHQoe2xpbmVXaWR0aDpqLGxpbmVDYXA6eixsaW5lSm9pbjptLG1pdGVyTGltaXQ6VCxyb3VuZFNlZ21lbnRzOll9KSx0eXBlb2YgTj09InN0cmluZyImJihOPU9iamVjdCh5LmRlZmF1bHQpKE4pKSx0aGlzW0ldPU4sdGhpc1tBXS5saW5lRGFzaD0kLHRoaXNbQV0ubGluZURhc2hPZmZzZXQ9Syx0aGlzfXNldEZpbGwoe3J1bGU6aj10aGlzLmZpbGxSdWxlLGNvbG9yOno9WzAsMCwwLDBdfT17fSl7cmV0dXJuIHRoaXNbbF09bnVsbCx0aGlzW1JdPXtydWxlOmp9LHR5cGVvZiB6PT0ic3RyaW5nIiYmKHo9T2JqZWN0KHkuZGVmYXVsdCkoeikpLHRoaXNbUF09eix0aGlzfXNldFRleHR1cmUoaix6PXt9KXtpZihqJiZqLmltYWdlKXtjb25zdHtpbWFnZTptLHJlY3Q6VH09ajtpZihqPW0sei5yZWN0KWZvcihsZXQgTj0wO048ei5yZWN0Lmxlbmd0aDtOKyspVFtOXT16LnJlY3RbTl07ei5yZWN0PVR9cmV0dXJuIHRoaXNbUl18fHRoaXMuc2V0RmlsbCgpLHRoaXMuc2V0VW5pZm9ybXMoe3VfdGV4U2FtcGxlcjpqfSksdGhpc1tsXSYmdGhpc1t3XSh0aGlzW2xdLHopLHRoaXNbU109eix0aGlzfXNldENpcmN1bGFyR3JhZGllbnQoe3ZlY3RvcjpqLGNvbG9yczp6LHR5cGU6bT0iZmlsbCJ9PXt9KXtpZihqLmxlbmd0aCE9PTMpdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCBsaW5lYXJHcmFkaWVudC4iKTt0aGlzLnNldEdyYWRpZW50KHt2ZWN0b3I6aixjb2xvcnM6eix0eXBlOm19KX1zZXRMaW5lYXJHcmFkaWVudCh7dmVjdG9yOmosY29sb3JzOnosdHlwZTptPSJmaWxsIn09e30pe2lmKGoubGVuZ3RoIT09NCl0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIGxpbmVhckdyYWRpZW50LiIpO3RoaXMuc2V0R3JhZGllbnQoe3ZlY3RvcjpqLGNvbG9yczp6LHR5cGU6bX0pfXNldFJhZGlhbEdyYWRpZW50KHt2ZWN0b3I6aixjb2xvcnM6eix0eXBlOm09ImZpbGwifT17fSl7aWYoai5sZW5ndGghPT02KXRocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgcmFkaWFsR3JhZGllbnQuIik7dGhpcy5zZXRHcmFkaWVudCh7dmVjdG9yOmosY29sb3JzOnosdHlwZTptfSl9c2V0R3JhZGllbnQoe3ZlY3RvcjpqLGNvbG9yczp6LHR5cGU6bT0iZmlsbCJ9PXt9KXt6PXoubWFwKCh7b2Zmc2V0OiQsY29sb3I6S30pPT4odHlwZW9mIEs9PSJzdHJpbmciJiYoSz1PYmplY3QoeS5kZWZhdWx0KShLKSkse29mZnNldDokLGNvbG9yOkt9KSksdGhpc1tVXT10aGlzW1VdfHx7fSx0aGlzW1VdW21dPXt2ZWN0b3I6aixjb2xvcnM6en0sei5zb3J0KCgkLEspPT4kLm9mZnNldC1LLm9mZnNldCk7Y29uc3QgVD1bXTt6LmZvckVhY2goKHtvZmZzZXQ6JCxjb2xvcjpLfSk9PntULnB1c2goJCwuLi5LKX0pO2xldCBOO2lmKGoubGVuZ3RoPT09ND9OPVtqWzBdLGpbMV0sMCxqWzJdLGpbM10sMF06Tj1bLi4ual0sVC5sZW5ndGg8NDAmJlQucHVzaCgtMSksVC5sZW5ndGg+NDApdGhyb3cgbmV3IEVycm9yKCJUb28gbWFueSBjb2xvcnMsIHNob3VsZCBiZSBsZXNzIHRoYW4gOCBjb2xvcnMiKTtyZXR1cm4gdGhpcy5fcmFkaWFsR3JhZGllbnRWZWN0b3I9Tix0aGlzW0NdLnVfY29sb3JTdGVwcz1ULG09PT0iZmlsbCI/dGhpc1tDXS51X2dyYWRpZW50VHlwZT0xOnRoaXNbQ10udV9ncmFkaWVudFR5cGU9MCx0aGlzW0pdKCksdGhpc31zZXRVbmlmb3JtcyhqPXt9KXtyZXR1cm4gT2JqZWN0LmFzc2lnbih0aGlzW0NdLGopLHRoaXN9c2V0VHJhbnNmb3JtKC4uLmope2NvbnN0IHo9dGhpc1tMXTtyZXR1cm4gci5tYXQyZC5lcXVhbHMoaix6KXx8KHRoaXNbTF09aixkZWxldGUgdGhpc1tEXSx0aGlzLl91cGRhdGVNYXRyaXg9ITApLHRoaXN9dHJhbnNmb3JtKC4uLmope2NvbnN0IHo9dGhpc1tMXTtyZXR1cm4gdGhpc1tMXT1yLm1hdDJkLm11bHRpcGx5KEFycmF5Lm9mKDAsMCwwLDAsMCwwKSx6LGopLGRlbGV0ZSB0aGlzW0RdLHRoaXMuX3VwZGF0ZU1hdHJpeD0hMCx0aGlzfXRyYW5zbGF0ZShqLHope2xldCBtPXIubWF0MmQuY3JlYXRlKCk7cmV0dXJuIG09ci5tYXQyZC50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDApLG0sW2osel0pLHRoaXMudHJhbnNmb3JtKC4uLm0pfXJvdGF0ZShqLFt6LG1dPVswLDBdKXtsZXQgVD1yLm1hdDJkLmNyZWF0ZSgpO3JldHVybiBUPXIubWF0MmQudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxULFt6LG1dKSxUPXIubWF0MmQucm90YXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxULGopLFQ9ci5tYXQyZC50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDApLFQsWy16LC1tXSksdGhpcy50cmFuc2Zvcm0oLi4uVCl9c2NhbGUoaix6PWosW20sVF09WzAsMF0pe2xldCBOPXIubWF0MmQuY3JlYXRlKCk7cmV0dXJuIE49ci5tYXQyZC50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDApLE4sW20sVF0pLE49ci5tYXQyZC5zY2FsZShBcnJheS5vZigwLDAsMCwwLDAsMCksTixbaix6XSksTj1yLm1hdDJkLnRyYW5zbGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCksTixbLW0sLVRdKSx0aGlzLnRyYW5zZm9ybSguLi5OKX1za2V3KGosej1qLFttLFRdPVswLDBdKXtsZXQgTj1yLm1hdDJkLmNyZWF0ZSgpO3JldHVybiBOPXIubWF0MmQudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxOLFttLFRdKSxOPXIubWF0MmQubXVsdGlwbHkoQXJyYXkub2YoMCwwLDAsMCwwLDApLE4sci5tYXQyZC5mcm9tVmFsdWVzKDEsTWF0aC50YW4oeiksTWF0aC50YW4oaiksMSwwLDApKSxOPXIubWF0MmQudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxOLFstbSwtVF0pLHRoaXMudHJhbnNmb3JtKC4uLk4pfWNsZWFyRmlsdGVyKCl7cmV0dXJuIHRoaXMuc2V0Q29sb3JUcmFuc2Zvcm0obnVsbCksdGhpc1tHXS5sZW5ndGg9MCx0aGlzfXNldENvbG9yVHJhbnNmb3JtKC4uLmope3JldHVybiBqWzBdPT09bnVsbD90aGlzLnNldFVuaWZvcm1zKHt1X2ZpbHRlckZsYWc6MCx1X2NvbG9yTWF0cml4OjB9KTp0aGlzLnNldFVuaWZvcm1zKHt1X2ZpbHRlckZsYWc6MSx1X2NvbG9yTWF0cml4Omp9KSx0aGlzfXRyYW5zZm9ybUNvbG9yKC4uLmope2xldCB6PXRoaXMudW5pZm9ybXMudV9jb2xvck1hdHJpeDtyZXR1cm4gej96PU9iamVjdChmLm11bHRpcGx5KSh6LGopOno9aix0aGlzLnNldENvbG9yVHJhbnNmb3JtKC4uLnopLHRoaXN9Ymx1cihqKXtyZXR1cm4gdGhpc1tHXS5wdXNoKGBibHVyKCR7an1weClgKSx0aGlzfWJyaWdodG5lc3Moaj0xKXtyZXR1cm4gdGhpc1tHXS5wdXNoKGBicmlnaHRuZXNzKCR7MTAwKmp9JSlgKSx0aGlzLnRyYW5zZm9ybUNvbG9yKC4uLk9iamVjdChmLmJyaWdodG5lc3MpKGopKX1jb250cmFzdChqPTEpe3JldHVybiB0aGlzW0ddLnB1c2goYGNvbnRyYXN0KCR7MTAwKmp9JSlgKSx0aGlzLnRyYW5zZm9ybUNvbG9yKC4uLk9iamVjdChmLmNvbnRyYXN0KShqKSl9ZHJvcFNoYWRvdyhqLHosbT0wLFQ9WzAsMCwwLDFdKXtyZXR1cm4gQXJyYXkuaXNBcnJheShUKSYmKFQ9T2JqZWN0KG8uZGVmYXVsdCkoVCkpLHRoaXNbR10ucHVzaChgZHJvcC1zaGFkb3coJHtqfXB4ICR7en1weCAke219cHggJHtUfSlgKSx0aGlzfWdyYXlzY2FsZShqPTEpe3JldHVybiB0aGlzW0ddLnB1c2goYGdyYXlzY2FsZSgkezEwMCpqfSUpYCksdGhpcy50cmFuc2Zvcm1Db2xvciguLi5PYmplY3QoZi5ncmF5c2NhbGUpKGopKX1odWVSb3RhdGUoaj0wKXtyZXR1cm4gdGhpc1tHXS5wdXNoKGBodWUtcm90YXRlKCR7an1kZWcpYCksdGhpcy50cmFuc2Zvcm1Db2xvciguLi5PYmplY3QoZi5odWVSb3RhdGUpKGopKX1pbnZlcnQoaj0xKXtyZXR1cm4gdGhpc1tHXS5wdXNoKGBpbnZlcnQoJHsxMDAqan0lKWApLHRoaXMudHJhbnNmb3JtQ29sb3IoLi4uT2JqZWN0KGYuaW52ZXJ0KShqKSl9b3BhY2l0eShqPTEpe3JldHVybiB0aGlzW0ddLnB1c2goYG9wYWNpdHkoJHsxMDAqan0lKWApLHRoaXMudHJhbnNmb3JtQ29sb3IoLi4uT2JqZWN0KGYub3BhY2l0eSkoaikpfXNhdHVyYXRlKGo9MSl7cmV0dXJuIHRoaXNbR10ucHVzaChgc2F0dXJhdGUoJHsxMDAqan0lKWApLHRoaXMudHJhbnNmb3JtQ29sb3IoLi4uT2JqZWN0KGYuc2F0dXJhdGUpKGopKX1zZXBpYShqPTEpe3JldHVybiB0aGlzW0ddLnB1c2goYHNlcGlhKCR7MTAwKmp9JSlgKSx0aGlzLnRyYW5zZm9ybUNvbG9yKC4uLk9iamVjdChmLnNlcGlhKShqKSl9dXJsKGope3JldHVybiB0aGlzW0ddLnB1c2goYHVybCgke2p9KWApLHRoaXN9aXNQb2ludENvbGxpc2lvbihqLHosbT0iYm90aCIpe2NvbnN0IFQ9dGhpcy5tZXNoRGF0YSx7cG9zaXRpb25zOk4sY2VsbHM6JH09VCxLPXRoaXMuaW52ZXJ0TWF0cml4LFk9S1swXSpqK0tbMl0qeitLWzRdLFE9S1sxXSpqK0tbM10qeitLWzVdLGV0PXRoaXMuYm91bmRpbmdCb3g7aWYoWTxldFswXVswXXx8WT5ldFsxXVswXXx8UTxldFswXVsxXXx8UT5ldFsxXVsxXSlyZXR1cm4hMTtmdW5jdGlvbiBydChbb3QsbHRdLFtpdCxudF0sW2F0LGR0XSl7Y29uc3QgZ3Q9YXQtaXQsdXQ9ZHQtbnQsbXQ9KChvdC1pdCkqZ3QrKGx0LW50KSp1dCkvKGd0KioyK3V0KioyKTtyZXR1cm4gbXQ+PTAmJm10PD0xfWZvcihsZXQgb3Q9MDtvdDwkLmxlbmd0aDtvdCsrKXtjb25zdCBsdD0kW290XTtpZihtPT09ImZpbGwiJiZsdFswXT49VC5maWxsUG9pbnRDb3VudClicmVhaztpZihtPT09InN0cm9rZSImJmx0WzBdPFQuZmlsbFBvaW50Q291bnQpY29udGludWU7Y29uc3RbW2l0LG50XSxbYXQsZHRdLFtndCx1dF1dPWx0Lm1hcChNdD0+TltNdF0pLG10PU1hdGguc2lnbigoai1pdCkqKGR0LW50KS0oYXQtaXQpKih6LW50KSk7aWYobXQ9PT0wJiZydChbaix6XSxbaXQsbnRdLFthdCxkdF0pKXJldHVybiEwO2NvbnN0IFB0PU1hdGguc2lnbigoai1hdCkqKHV0LWR0KS0oZ3QtYXQpKih6LWR0KSk7aWYoUHQ9PT0wJiZydChbaix6XSxbYXQsZHRdLFtndCx1dF0pKXJldHVybiEwO2NvbnN0IHh0PU1hdGguc2lnbigoai1ndCkqKG50LXV0KS0oaXQtZ3QpKih6LXV0KSk7aWYoeHQ9PT0wJiZydChbaix6XSxbZ3QsdXRdLFtpdCxudF0pfHxtdD09PTEmJlB0PT09MSYmeHQ9PT0xfHxtdD09PS0xJiZQdD09PS0xJiZ4dD09PS0xKXJldHVybiEwfXJldHVybiExfWlzUG9pbnRJbkZpbGwoaix6KXtyZXR1cm4gdGhpcy5pc1BvaW50Q29sbGlzaW9uKGoseiwiZmlsbCIpfWlzUG9pbnRJblN0cm9rZShqLHope3JldHVybiB0aGlzLmlzUG9pbnRDb2xsaXNpb24oaix6LCJzdHJva2UiKX1hZGRQYXNzKGosej17fSl7bGV0e3dpZHRoOm0saGVpZ2h0OlR9PXosTj1hKHosWyJ3aWR0aCIsImhlaWdodCJdKTtjb25zdCAkPW5ldyBNLmRlZmF1bHQ7JC5yZWN0KDAsMCxtLFQpO2NvbnN0IEs9bmV3IFYoJCx7d2lkdGg6bSxoZWlnaHQ6VH0pO0suc2V0VW5pZm9ybXMoTiksSy5zZXRQcm9ncmFtKGopLHRoaXNbc3RdLnB1c2goSyl9fX0sZnVuY3Rpb24oaCxlLHQpe3QucihlKTt2YXIgcj10KDU4KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSksZS5kZWZhdWx0PXIuU3Ryb2tlfSxmdW5jdGlvbihoLGUsdCl7dC5yKGUpLHQuZChlLCJTdHJva2UiLGZ1bmN0aW9uKCl7cmV0dXJuIHh9KTt2YXIgcj10KDQ5KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3Qgbj1PYmplY3Qoci5jcmVhdGUpKCksZD1PYmplY3Qoci5jcmVhdGUpKCksZz1PYmplY3Qoci5jcmVhdGUpKCksdT1PYmplY3Qoci5jcmVhdGUpKCksbz1PYmplY3Qoci5jcmVhdGUpKCksZj0xZTIwO2NsYXNzIHh7Y29uc3RydWN0b3Ioe2xpbmVXaWR0aDpFPTEsbGluZUpvaW46eT0ibWl0ZXIiLG1pdGVyTGltaXQ6TT0xMCxsaW5lQ2FwOmk9ImJ1dHQiLHJvdW5kU2VnbWVudHM6YT0yMH09e30pe3RoaXMubGluZVdpZHRoPUUsdGhpcy5saW5lSm9pbj15LHRoaXMubWl0ZXJMaW1pdD1NLHRoaXMubGluZUNhcD1pLHRoaXMucm91bmRTZWdtZW50cz1hLHRoaXMuX25vcm1hbD1udWxsfWJ1aWxkKEUseT0hMSl7bGV0IE09RS5sZW5ndGg7aWYoRT1bLi4uRV0sTTwyKXJldHVybiBFO3kmJigoRVswXVswXSE9PUVbTS0xXVswXXx8RVswXVsxXSE9PUVbTS0xXVsxXSkmJkUucHVzaChbLi4uRVswXV0pLEUucHVzaChbLi4uRVsxXV0pKSxNPUUubGVuZ3RoLHRoaXMuX25vcm1hbD1udWxsO2NvbnN0IGk9e2xlZnQ6W10scmlnaHQ6W119LGE9dGhpcy5saW5lV2lkdGgvMixzPXRoaXMubGluZUNhcDtpZigheSYmcz09PSJzcXVhcmUiKXtPYmplY3Qoci5kaXJlY3Rpb24pKGQsRVswXSxFWzFdKSxPYmplY3Qoci5zY2FsZUFuZEFkZCkoRVswXSxFWzBdLGQsYSk7Y29uc3QgTz1FLmxlbmd0aC0xO09iamVjdChyLmRpcmVjdGlvbikoZCxFW09dLEVbTy0xXSksT2JqZWN0KHIuc2NhbGVBbmRBZGQpKEVbT10sRVtPXSxkLGEpfWZvcihsZXQgTz0xO088TTtPKyspe2NvbnN0IEE9RVtPLTFdLFI9RVtPXSxJPUVbTysxXTt0aGlzLl9zZWcoaSxBLFIsSSxhLHkpfXJldHVybiF5JiZzPT09InJvdW5kIiYmcChpLHRoaXMucm91bmRTZWdtZW50cyksWy4uLmkubGVmdCwuLi5pLnJpZ2h0LnJldmVyc2UoKV19X3NlZyhFLHksTSxpLGEscyl7Y29uc3QgbD10aGlzLmxpbmVKb2luPT09ImJldmVsIixPPXRoaXMubGluZUpvaW49PT0icm91bmQiO2lmKE9iamVjdChyLmRpcmVjdGlvbikoZCxNLHkpLHRoaXMuX25vcm1hbHx8KHRoaXMuX25vcm1hbD1PYmplY3Qoci5jcmVhdGUpKCksT2JqZWN0KHIubm9ybWFsKSh0aGlzLl9ub3JtYWwsZCkpLEUubGVmdC5sZW5ndGh8fHYoRSx5LHRoaXMuX25vcm1hbCxhKSwhaSlPYmplY3Qoci5ub3JtYWwpKHRoaXMuX25vcm1hbCxkKSxzP3YoRSx5LHRoaXMuX25vcm1hbCxhKTp2KEUsTSx0aGlzLl9ub3JtYWwsYSk7ZWxzZXtPYmplY3Qoci5kaXJlY3Rpb24pKGcsaSxNKTtsZXQgQT1PYmplY3Qoci5jb21wdXRlTWl0ZXIpKHUsbyxkLGcsYSk7QT1NYXRoLm1pbihBLGYpO2NvbnN0IFI9T2JqZWN0KHIuZG90KSh1LHRoaXMuX25vcm1hbCk8MD8tMToxO2xldCBJPWx8fE87aWYoIUkmJnRoaXMubGluZUpvaW49PT0ibWl0ZXIiJiZBL2E+dGhpcy5taXRlckxpbWl0JiYoST0hMCksSSl7T2JqZWN0KHIuc2NhbGVBbmRBZGQpKG4sTSx0aGlzLl9ub3JtYWwsLWEqUiksYyhFLG4sUik7bGV0IFA9MS8wO3kmJihQPU1hdGgubWluKFAsTWF0aC5oeXBvdChNWzBdLXlbMF0sTVsxXS15WzFdKSkpLGkmJihQPU1hdGgubWluKFAsTWF0aC5oeXBvdChpWzBdLU1bMF0saVsxXS1NWzFdKSkpO2NvbnN0IEw9TWF0aC5tYXgoYSxNYXRoLm1pbihBLFApKTtpZihPYmplY3Qoci5zY2FsZUFuZEFkZCkobixNLG8sTCpSKSxjKEUsbiwtUiksaSlpZihPYmplY3Qoci5ub3JtYWwpKG4sZyksT2JqZWN0KHIuY29weSkodGhpcy5fbm9ybWFsLG4pLE9iamVjdChyLnNjYWxlQW5kQWRkKShuLE0sbiwtYSpSKSxPKXtjb25zdCBEPU9iamVjdChyLmNsb25lKShuKSxDPVI+MD9FLmxlZnRbRS5sZWZ0Lmxlbmd0aC0xXTpFLnJpZ2h0W0UucmlnaHQubGVuZ3RoLTFdLFM9T2JqZWN0KHIuY2xvbmUpKE0pLEI9T2JqZWN0KHIuc3ViKShPYmplY3Qoci5jcmVhdGUpKCksQyxTKSx3PU9iamVjdChyLnN1YikoT2JqZWN0KHIuY3JlYXRlKSgpLEQsUyksSD1NYXRoLlBJL3RoaXMucm91bmRTZWdtZW50cztmb3IobGV0IEo9MDtKPHRoaXMucm91bmRTZWdtZW50cyYmKE9iamVjdChyLnJvdGF0ZSkoQixCLFswLDBdLFIqSCksTWF0aC5zaWduKE9iamVjdChyLmNyb3NzKShuLEIsdylbMl0pPT09Uik7SisrKU9iamVjdChyLmFkZCkobixCLFMpLGMoRSxuLFIpO2MoRSxELFIpfWVsc2UgYyhFLG4sUil9ZWxzZSB2KEUsTSxvLEEpLE9iamVjdChyLmNvcHkpKHRoaXMuX25vcm1hbCxvKX19fWZ1bmN0aW9uIGMoYixFLHkpe3k+MD9iLmxlZnQucHVzaChPYmplY3Qoci5jbG9uZSkoRSkpOmIucmlnaHQucHVzaChPYmplY3Qoci5jbG9uZSkoRSkpfWZ1bmN0aW9uIHYoYixFLHksTSxpPS0xKXtPYmplY3Qoci5zY2FsZUFuZEFkZCkobixFLHksLU0pLGMoYixuLC1pKSxPYmplY3Qoci5zY2FsZUFuZEFkZCkobixFLHksTSksYyhiLG4saSl9ZnVuY3Rpb24gcCh7bGVmdDpiLHJpZ2h0OkV9LHkpe2NvbnN0IE09T2JqZWN0KHIuY3JlYXRlKSgpLGk9T2JqZWN0KHIuY3JlYXRlKSgpO2xldCBhPWJbMF0scz1FWzBdLGw9Wy41KihhWzBdK3NbMF0pLC41KihhWzFdK3NbMV0pXTtPYmplY3Qoci5zdWIpKGksYSxsKTtmb3IobGV0IE89MTtPPD15O08rKyl7Y29uc3QgQT0tMSpNYXRoLlBJKk8veTtPYmplY3Qoci5yb3RhdGUpKE0saSxbMCwwXSxBKSxPYmplY3Qoci5hZGQpKG4sbCxNKSxiLnVuc2hpZnQoT2JqZWN0KHIuY2xvbmUpKG4pKX1hPUVbRS5sZW5ndGgtMV0scz1iW2IubGVuZ3RoLTFdLGw9Wy41KihhWzBdK3NbMF0pLC41KihhWzFdK3NbMV0pXSxPYmplY3Qoci5zdWIpKGksYSxsKTtmb3IobGV0IE89MTtPPD15O08rKyl7Y29uc3QgQT0tMSpNYXRoLlBJKk8veTtPYmplY3Qoci5yb3RhdGUpKE0saSxbMCwwXSxBKSxPYmplY3Qoci5hZGQpKG4sbCxNKSxFLnB1c2goT2JqZWN0KHIuY2xvbmUpKG4pKX19fSxmdW5jdGlvbihoLGUsdCl7dC5yKGUpLHQuZChlLCJpc1VuaXRUcmFuc2Zvcm0iLGZ1bmN0aW9uKCl7cmV0dXJuIHJ9KSx0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gcihuKXtyZXR1cm4gblswXT09PTEmJm5bMV09PT0wJiZuWzJdPT09MCYmblszXT09PTEmJm5bNF09PT0wJiZuWzVdPT09MH19LGZ1bmN0aW9uKGgsZSx0KXt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7dmFyIHI9dCg2MSksbj10KDYyKTtoLmV4cG9ydHM9ZnVuY3Rpb24oZCxnKXtpZihnPWd8fHt9LGQ9ZC5maWx0ZXIoZnVuY3Rpb24oeSl7cmV0dXJuIHkubGVuZ3RoPjJ9KSxkLmxlbmd0aD09PTApcmV0dXJue3Bvc2l0aW9uczpbXSxjZWxsczpbXX07dHlwZW9mIGcudmVydGV4U2l6ZSE9Im51bWJlciImJihnLnZlcnRleFNpemU9ZFswXVswXS5sZW5ndGgpLGQ9ZC5tYXAoZnVuY3Rpb24oeSl7cmV0dXJuIHkucmVkdWNlKGZ1bmN0aW9uKE0saSl7cmV0dXJuIE0uY29uY2F0KGkpfSl9KTtjb25zdCB1PWcucnVsZT09PSJldmVub2RkIj9yLldJTkRJTkdfT0REOnIuV0lORElOR19OT05aRVJPO2Zvcih2YXIgbz1yLnRlc3NlbGF0ZShuKHtjb250b3VyczpkLHdpbmRpbmdSdWxlOnUsZWxlbWVudFR5cGU6ci5QT0xZR09OUyxwb2x5U2l6ZTozLHZlcnRleFNpemU6Mn0sZykpLGY9W10seD0wO3g8by52ZXJ0aWNlcy5sZW5ndGg7eCs9Zy52ZXJ0ZXhTaXplKXt2YXIgYz1vLnZlcnRpY2VzLnNsaWNlKHgseCtnLnZlcnRleFNpemUpO2YucHVzaChjKX12YXIgdj1bXTtmb3IoeD0wO3g8by5lbGVtZW50cy5sZW5ndGg7eCs9Myl7dmFyIHA9by5lbGVtZW50c1t4XSxiPW8uZWxlbWVudHNbeCsxXSxFPW8uZWxlbWVudHNbeCsyXTt2LnB1c2goW3AsYixFXSl9cmV0dXJue3Bvc2l0aW9uczpmLGNlbGxzOnZ9fX0sZnVuY3Rpb24oaCxlLHQpe3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTt2YXIgcj17fSxuPXt9O2guZXhwb3J0cz1yLHIuV0lORElOR19PREQ9MCxyLldJTkRJTkdfTk9OWkVSTz0xLHIuV0lORElOR19QT1NJVElWRT0yLHIuV0lORElOR19ORUdBVElWRT0zLHIuV0lORElOR19BQlNfR0VRX1RXTz00LHIuUE9MWUdPTlM9MCxyLkNPTk5FQ1RFRF9QT0xZR09OUz0xLHIuQk9VTkRBUllfQ09OVE9VUlM9MixyLnRlc3NlbGF0ZT1mdW5jdGlvbihpKXtmb3IodmFyIGE9aS5kZWJ1Z3x8ITEscz1uZXcgTSxsPTA7bDxpLmNvbnRvdXJzLmxlbmd0aDtsKyspcy5hZGRDb250b3VyKGkudmVydGV4U2l6ZXx8MixpLmNvbnRvdXJzW2xdKTtyZXR1cm4gcy50ZXNzZWxhdGUoaS53aW5kaW5nUnVsZXx8ci5XSU5ESU5HX09ERCxpLmVsZW1lbnRUeXBlfHxyLlBPTFlHT05TLGkucG9seVNpemV8fDMsaS52ZXJ0ZXhTaXplfHwyLGkubm9ybWFsfHxbMCwwLDFdKSx7dmVydGljZXM6cy52ZXJ0aWNlcyx2ZXJ0ZXhJbmRpY2VzOnMudmVydGV4SW5kaWNlcyx2ZXJ0ZXhDb3VudDpzLnZlcnRleENvdW50LGVsZW1lbnRzOnMuZWxlbWVudHMsZWxlbWVudENvdW50OnMuZWxlbWVudENvdW50LG1lc2g6YT9zLm1lc2g6dm9pZCAwfX07dmFyIGQ9ZnVuY3Rpb24oaSl7aWYoIWkpdGhyb3ciQXNzZXJ0aW9uIEZhaWxlZCEifTtmdW5jdGlvbiBnKCl7dGhpcy5uZXh0PW51bGwsdGhpcy5wcmV2PW51bGwsdGhpcy5hbkVkZ2U9bnVsbCx0aGlzLmNvb3Jkcz1bMCwwLDBdLHRoaXMucz0wLHRoaXMudD0wLHRoaXMucHFIYW5kbGU9MCx0aGlzLm49MCx0aGlzLmlkeD0wfWZ1bmN0aW9uIHUoKXt0aGlzLm5leHQ9bnVsbCx0aGlzLnByZXY9bnVsbCx0aGlzLmFuRWRnZT1udWxsLHRoaXMudHJhaWw9bnVsbCx0aGlzLm49MCx0aGlzLm1hcmtlZD0hMSx0aGlzLmluc2lkZT0hMX1mdW5jdGlvbiBvKGkpe3RoaXMubmV4dD1udWxsLHRoaXMuU3ltPW51bGwsdGhpcy5PbmV4dD1udWxsLHRoaXMuTG5leHQ9bnVsbCx0aGlzLk9yZz1udWxsLHRoaXMuTGZhY2U9bnVsbCx0aGlzLmFjdGl2ZVJlZ2lvbj1udWxsLHRoaXMud2luZGluZz0wLHRoaXMuc2lkZT1pfW8ucHJvdG90eXBlPXtnZXQgUmZhY2UoKXtyZXR1cm4gdGhpcy5TeW0uTGZhY2V9LHNldCBSZmFjZShpKXt0aGlzLlN5bS5MZmFjZT1pfSxnZXQgRHN0KCl7cmV0dXJuIHRoaXMuU3ltLk9yZ30sc2V0IERzdChpKXt0aGlzLlN5bS5Pcmc9aX0sZ2V0IE9wcmV2KCl7cmV0dXJuIHRoaXMuU3ltLkxuZXh0fSxzZXQgT3ByZXYoaSl7dGhpcy5TeW0uTG5leHQ9aX0sZ2V0IExwcmV2KCl7cmV0dXJuIHRoaXMuT25leHQuU3ltfSxzZXQgTHByZXYoaSl7dGhpcy5PbmV4dC5TeW09aX0sZ2V0IERwcmV2KCl7cmV0dXJuIHRoaXMuTG5leHQuU3ltfSxzZXQgRHByZXYoaSl7dGhpcy5MbmV4dC5TeW09aX0sZ2V0IFJwcmV2KCl7cmV0dXJuIHRoaXMuU3ltLk9uZXh0fSxzZXQgUnByZXYoaSl7dGhpcy5TeW0uT25leHQ9aX0sZ2V0IERuZXh0KCl7cmV0dXJuIHRoaXMuU3ltLk9uZXh0LlN5bX0sc2V0IERuZXh0KGkpe3RoaXMuU3ltLk9uZXh0LlN5bT1pfSxnZXQgUm5leHQoKXtyZXR1cm4gdGhpcy5TeW0uTG5leHQuU3ltfSxzZXQgUm5leHQoaSl7dGhpcy5TeW0uTG5leHQuU3ltPWl9fTtmdW5jdGlvbiBmKCl7dmFyIGk9bmV3IGcsYT1uZXcgdSxzPW5ldyBvKDApLGw9bmV3IG8oMSk7aS5uZXh0PWkucHJldj1pLGkuYW5FZGdlPW51bGwsYS5uZXh0PWEucHJldj1hLGEuYW5FZGdlPW51bGwsYS50cmFpbD1udWxsLGEubWFya2VkPSExLGEuaW5zaWRlPSExLHMubmV4dD1zLHMuU3ltPWwscy5PbmV4dD1udWxsLHMuTG5leHQ9bnVsbCxzLk9yZz1udWxsLHMuTGZhY2U9bnVsbCxzLndpbmRpbmc9MCxzLmFjdGl2ZVJlZ2lvbj1udWxsLGwubmV4dD1sLGwuU3ltPXMsbC5PbmV4dD1udWxsLGwuTG5leHQ9bnVsbCxsLk9yZz1udWxsLGwuTGZhY2U9bnVsbCxsLndpbmRpbmc9MCxsLmFjdGl2ZVJlZ2lvbj1udWxsLHRoaXMudkhlYWQ9aSx0aGlzLmZIZWFkPWEsdGhpcy5lSGVhZD1zLHRoaXMuZUhlYWRTeW09bH1mLnByb3RvdHlwZT17bWFrZUVkZ2VfOmZ1bmN0aW9uKGkpe3ZhciBhPW5ldyBvKDApLHM9bmV3IG8oMSk7aS5TeW0uc2lkZTxpLnNpZGUmJihpPWkuU3ltKTt2YXIgbD1pLlN5bS5uZXh0O3JldHVybiBzLm5leHQ9bCxsLlN5bS5uZXh0PWEsYS5uZXh0PWksaS5TeW0ubmV4dD1zLGEuU3ltPXMsYS5PbmV4dD1hLGEuTG5leHQ9cyxhLk9yZz1udWxsLGEuTGZhY2U9bnVsbCxhLndpbmRpbmc9MCxhLmFjdGl2ZVJlZ2lvbj1udWxsLHMuU3ltPWEscy5PbmV4dD1zLHMuTG5leHQ9YSxzLk9yZz1udWxsLHMuTGZhY2U9bnVsbCxzLndpbmRpbmc9MCxzLmFjdGl2ZVJlZ2lvbj1udWxsLGF9LHNwbGljZV86ZnVuY3Rpb24oaSxhKXt2YXIgcz1pLk9uZXh0LGw9YS5PbmV4dDtzLlN5bS5MbmV4dD1hLGwuU3ltLkxuZXh0PWksaS5PbmV4dD1sLGEuT25leHQ9c30sbWFrZVZlcnRleF86ZnVuY3Rpb24oaSxhLHMpe3ZhciBsPWk7ZChsIT09bnVsbCk7dmFyIE89cy5wcmV2O2wucHJldj1PLE8ubmV4dD1sLGwubmV4dD1zLHMucHJldj1sLGwuYW5FZGdlPWE7dmFyIEE9YTtkbyBBLk9yZz1sLEE9QS5PbmV4dDt3aGlsZShBIT09YSl9LG1ha2VGYWNlXzpmdW5jdGlvbihpLGEscyl7dmFyIGw9aTtkKGwhPT1udWxsKTt2YXIgTz1zLnByZXY7bC5wcmV2PU8sTy5uZXh0PWwsbC5uZXh0PXMscy5wcmV2PWwsbC5hbkVkZ2U9YSxsLnRyYWlsPW51bGwsbC5tYXJrZWQ9ITEsbC5pbnNpZGU9cy5pbnNpZGU7dmFyIEE9YTtkbyBBLkxmYWNlPWwsQT1BLkxuZXh0O3doaWxlKEEhPT1hKX0sa2lsbEVkZ2VfOmZ1bmN0aW9uKGkpe2kuU3ltLnNpZGU8aS5zaWRlJiYoaT1pLlN5bSk7dmFyIGE9aS5uZXh0LHM9aS5TeW0ubmV4dDthLlN5bS5uZXh0PXMscy5TeW0ubmV4dD1hfSxraWxsVmVydGV4XzpmdW5jdGlvbihpLGEpe3ZhciBzPWkuYW5FZGdlLGw9cztkbyBsLk9yZz1hLGw9bC5PbmV4dDt3aGlsZShsIT09cyk7dmFyIE89aS5wcmV2LEE9aS5uZXh0O0EucHJldj1PLE8ubmV4dD1BfSxraWxsRmFjZV86ZnVuY3Rpb24oaSxhKXt2YXIgcz1pLmFuRWRnZSxsPXM7ZG8gbC5MZmFjZT1hLGw9bC5MbmV4dDt3aGlsZShsIT09cyk7dmFyIE89aS5wcmV2LEE9aS5uZXh0O0EucHJldj1PLE8ubmV4dD1BfSxtYWtlRWRnZTpmdW5jdGlvbigpe3ZhciBpPW5ldyBnLGE9bmV3IGcscz1uZXcgdSxsPXRoaXMubWFrZUVkZ2VfKHRoaXMuZUhlYWQpO3JldHVybiB0aGlzLm1ha2VWZXJ0ZXhfKGksbCx0aGlzLnZIZWFkKSx0aGlzLm1ha2VWZXJ0ZXhfKGEsbC5TeW0sdGhpcy52SGVhZCksdGhpcy5tYWtlRmFjZV8ocyxsLHRoaXMuZkhlYWQpLGx9LHNwbGljZTpmdW5jdGlvbihpLGEpe3ZhciBzPSExLGw9ITE7aWYoaSE9PWEpe2lmKGEuT3JnIT09aS5PcmcmJihsPSEwLHRoaXMua2lsbFZlcnRleF8oYS5PcmcsaS5PcmcpKSxhLkxmYWNlIT09aS5MZmFjZSYmKHM9ITAsdGhpcy5raWxsRmFjZV8oYS5MZmFjZSxpLkxmYWNlKSksdGhpcy5zcGxpY2VfKGEsaSksIWwpe3ZhciBPPW5ldyBnO3RoaXMubWFrZVZlcnRleF8oTyxhLGkuT3JnKSxpLk9yZy5hbkVkZ2U9aX1pZighcyl7dmFyIEE9bmV3IHU7dGhpcy5tYWtlRmFjZV8oQSxhLGkuTGZhY2UpLGkuTGZhY2UuYW5FZGdlPWl9fX0sZGVsZXRlOmZ1bmN0aW9uKGkpe3ZhciBhPWkuU3ltLHM9ITE7aWYoaS5MZmFjZSE9PWkuUmZhY2UmJihzPSEwLHRoaXMua2lsbEZhY2VfKGkuTGZhY2UsaS5SZmFjZSkpLGkuT25leHQ9PT1pKXRoaXMua2lsbFZlcnRleF8oaS5PcmcsbnVsbCk7ZWxzZSBpZihpLlJmYWNlLmFuRWRnZT1pLk9wcmV2LGkuT3JnLmFuRWRnZT1pLk9uZXh0LHRoaXMuc3BsaWNlXyhpLGkuT3ByZXYpLCFzKXt2YXIgbD1uZXcgdTt0aGlzLm1ha2VGYWNlXyhsLGksaS5MZmFjZSl9YS5PbmV4dD09PWE/KHRoaXMua2lsbFZlcnRleF8oYS5PcmcsbnVsbCksdGhpcy5raWxsRmFjZV8oYS5MZmFjZSxudWxsKSk6KGkuTGZhY2UuYW5FZGdlPWEuT3ByZXYsYS5PcmcuYW5FZGdlPWEuT25leHQsdGhpcy5zcGxpY2VfKGEsYS5PcHJldikpLHRoaXMua2lsbEVkZ2VfKGkpfSxhZGRFZGdlVmVydGV4OmZ1bmN0aW9uKGkpe3ZhciBhPXRoaXMubWFrZUVkZ2VfKGkpLHM9YS5TeW07dGhpcy5zcGxpY2VfKGEsaS5MbmV4dCksYS5Pcmc9aS5Ec3Q7dmFyIGw9bmV3IGc7cmV0dXJuIHRoaXMubWFrZVZlcnRleF8obCxzLGEuT3JnKSxhLkxmYWNlPXMuTGZhY2U9aS5MZmFjZSxhfSxzcGxpdEVkZ2U6ZnVuY3Rpb24oaSxhKXt2YXIgcz10aGlzLmFkZEVkZ2VWZXJ0ZXgoaSksbD1zLlN5bTtyZXR1cm4gdGhpcy5zcGxpY2VfKGkuU3ltLGkuU3ltLk9wcmV2KSx0aGlzLnNwbGljZV8oaS5TeW0sbCksaS5Ec3Q9bC5PcmcsbC5Ec3QuYW5FZGdlPWwuU3ltLGwuUmZhY2U9aS5SZmFjZSxsLndpbmRpbmc9aS53aW5kaW5nLGwuU3ltLndpbmRpbmc9aS5TeW0ud2luZGluZyxsfSxjb25uZWN0OmZ1bmN0aW9uKGksYSl7dmFyIHM9ITEsbD10aGlzLm1ha2VFZGdlXyhpKSxPPWwuU3ltO2lmKGEuTGZhY2UhPT1pLkxmYWNlJiYocz0hMCx0aGlzLmtpbGxGYWNlXyhhLkxmYWNlLGkuTGZhY2UpKSx0aGlzLnNwbGljZV8obCxpLkxuZXh0KSx0aGlzLnNwbGljZV8oTyxhKSxsLk9yZz1pLkRzdCxPLk9yZz1hLk9yZyxsLkxmYWNlPU8uTGZhY2U9aS5MZmFjZSxpLkxmYWNlLmFuRWRnZT1PLCFzKXt2YXIgQT1uZXcgdTt0aGlzLm1ha2VGYWNlXyhBLGwsaS5MZmFjZSl9cmV0dXJuIGx9LHphcEZhY2U6ZnVuY3Rpb24oaSl7dmFyIGE9aS5hbkVkZ2UscyxsLE8sQSxSO2w9YS5MbmV4dDtkbyBzPWwsbD1zLkxuZXh0LHMuTGZhY2U9bnVsbCxzLlJmYWNlPT09bnVsbCYmKHMuT25leHQ9PT1zP3RoaXMua2lsbFZlcnRleF8ocy5PcmcsbnVsbCk6KHMuT3JnLmFuRWRnZT1zLk9uZXh0LHRoaXMuc3BsaWNlXyhzLHMuT3ByZXYpKSxPPXMuU3ltLE8uT25leHQ9PT1PP3RoaXMua2lsbFZlcnRleF8oTy5PcmcsbnVsbCk6KE8uT3JnLmFuRWRnZT1PLk9uZXh0LHRoaXMuc3BsaWNlXyhPLE8uT3ByZXYpKSx0aGlzLmtpbGxFZGdlXyhzKSk7d2hpbGUocyE9YSk7QT1pLnByZXYsUj1pLm5leHQsUi5wcmV2PUEsQS5uZXh0PVJ9LGNvdW50RmFjZVZlcnRzXzpmdW5jdGlvbihpKXt2YXIgYT1pLmFuRWRnZSxzPTA7ZG8gcysrLGE9YS5MbmV4dDt3aGlsZShhIT09aS5hbkVkZ2UpO3JldHVybiBzfSxtZXJnZUNvbnZleEZhY2VzOmZ1bmN0aW9uKGkpe3ZhciBhLHMsbCxPLEEsUixJO2ZvcihhPXRoaXMuZkhlYWQubmV4dDthIT09dGhpcy5mSGVhZDthPWEubmV4dClpZihhLmluc2lkZSlmb3Iocz1hLmFuRWRnZSxBPXMuT3JnO2w9cy5MbmV4dCxPPXMuU3ltLE8mJk8uTGZhY2UmJk8uTGZhY2UuaW5zaWRlJiYoUj10aGlzLmNvdW50RmFjZVZlcnRzXyhhKSxJPXRoaXMuY291bnRGYWNlVmVydHNfKE8uTGZhY2UpLFIrSS0yPD1pJiZuLnZlcnRDQ1cocy5McHJldi5Pcmcscy5PcmcsTy5MbmV4dC5MbmV4dC5PcmcpJiZuLnZlcnRDQ1coTy5McHJldi5PcmcsTy5Pcmcscy5MbmV4dC5MbmV4dC5PcmcpJiYobD1PLkxuZXh0LHRoaXMuZGVsZXRlKE8pLHM9bnVsbCxPPW51bGwpKSwhKHMmJnMuTG5leHQuT3JnPT09QSk7KXM9bDtyZXR1cm4hMH0sY2hlY2s6ZnVuY3Rpb24oKXt2YXIgaT10aGlzLmZIZWFkLGE9dGhpcy52SGVhZCxzPXRoaXMuZUhlYWQsbCxPLEEsUixJLFA7Zm9yKE89aSxPPWk7KGw9Ty5uZXh0KSE9PWk7Tz1sKXtkKGwucHJldj09PU8pLEk9bC5hbkVkZ2U7ZG8gZChJLlN5bSE9PUkpLGQoSS5TeW0uU3ltPT09SSksZChJLkxuZXh0Lk9uZXh0LlN5bT09PUkpLGQoSS5PbmV4dC5TeW0uTG5leHQ9PT1JKSxkKEkuTGZhY2U9PT1sKSxJPUkuTG5leHQ7d2hpbGUoSSE9PWwuYW5FZGdlKX1mb3IoZChsLnByZXY9PT1PJiZsLmFuRWRnZT09PW51bGwpLFI9YSxSPWE7KEE9Ui5uZXh0KSE9PWE7Uj1BKXtkKEEucHJldj09PVIpLEk9QS5hbkVkZ2U7ZG8gZChJLlN5bSE9PUkpLGQoSS5TeW0uU3ltPT09SSksZChJLkxuZXh0Lk9uZXh0LlN5bT09PUkpLGQoSS5PbmV4dC5TeW0uTG5leHQ9PT1JKSxkKEkuT3JnPT09QSksST1JLk9uZXh0O3doaWxlKEkhPT1BLmFuRWRnZSl9Zm9yKGQoQS5wcmV2PT09UiYmQS5hbkVkZ2U9PT1udWxsKSxQPXMsUD1zOyhJPVAubmV4dCkhPT1zO1A9SSlkKEkuU3ltLm5leHQ9PT1QLlN5bSksZChJLlN5bSE9PUkpLGQoSS5TeW0uU3ltPT09SSksZChJLk9yZyE9PW51bGwpLGQoSS5Ec3QhPT1udWxsKSxkKEkuTG5leHQuT25leHQuU3ltPT09SSksZChJLk9uZXh0LlN5bS5MbmV4dD09PUkpO2QoSS5TeW0ubmV4dD09PVAuU3ltJiZJLlN5bT09PXRoaXMuZUhlYWRTeW0mJkkuU3ltLlN5bT09PUkmJkkuT3JnPT09bnVsbCYmSS5Ec3Q9PT1udWxsJiZJLkxmYWNlPT09bnVsbCYmSS5SZmFjZT09PW51bGwpfX0sbi52ZXJ0RXE9ZnVuY3Rpb24oaSxhKXtyZXR1cm4gaS5zPT09YS5zJiZpLnQ9PT1hLnR9LG4udmVydExlcT1mdW5jdGlvbihpLGEpe3JldHVybiBpLnM8YS5zfHxpLnM9PT1hLnMmJmkudDw9YS50fSxuLnRyYW5zTGVxPWZ1bmN0aW9uKGksYSl7cmV0dXJuIGkudDxhLnR8fGkudD09PWEudCYmaS5zPD1hLnN9LG4uZWRnZUdvZXNMZWZ0PWZ1bmN0aW9uKGkpe3JldHVybiBuLnZlcnRMZXEoaS5Ec3QsaS5PcmcpfSxuLmVkZ2VHb2VzUmlnaHQ9ZnVuY3Rpb24oaSl7cmV0dXJuIG4udmVydExlcShpLk9yZyxpLkRzdCl9LG4udmVydEwxZGlzdD1mdW5jdGlvbihpLGEpe3JldHVybiBNYXRoLmFicyhpLnMtYS5zKStNYXRoLmFicyhpLnQtYS50KX0sbi5lZGdlRXZhbD1mdW5jdGlvbihpLGEscyl7ZChuLnZlcnRMZXEoaSxhKSYmbi52ZXJ0TGVxKGEscykpO3ZhciBsPWEucy1pLnMsTz1zLnMtYS5zO3JldHVybiBsK08+MD9sPE8/YS50LWkudCsoaS50LXMudCkqKGwvKGwrTykpOmEudC1zLnQrKHMudC1pLnQpKihPLyhsK08pKTowfSxuLmVkZ2VTaWduPWZ1bmN0aW9uKGksYSxzKXtkKG4udmVydExlcShpLGEpJiZuLnZlcnRMZXEoYSxzKSk7dmFyIGw9YS5zLWkucyxPPXMucy1hLnM7cmV0dXJuIGwrTz4wPyhhLnQtcy50KSpsKyhhLnQtaS50KSpPOjB9LG4udHJhbnNFdmFsPWZ1bmN0aW9uKGksYSxzKXtkKG4udHJhbnNMZXEoaSxhKSYmbi50cmFuc0xlcShhLHMpKTt2YXIgbD1hLnQtaS50LE89cy50LWEudDtyZXR1cm4gbCtPPjA/bDxPP2Eucy1pLnMrKGkucy1zLnMpKihsLyhsK08pKTphLnMtcy5zKyhzLnMtaS5zKSooTy8obCtPKSk6MH0sbi50cmFuc1NpZ249ZnVuY3Rpb24oaSxhLHMpe2Qobi50cmFuc0xlcShpLGEpJiZuLnRyYW5zTGVxKGEscykpO3ZhciBsPWEudC1pLnQsTz1zLnQtYS50O3JldHVybiBsK08+MD8oYS5zLXMucykqbCsoYS5zLWkucykqTzowfSxuLnZlcnRDQ1c9ZnVuY3Rpb24oaSxhLHMpe3JldHVybiBpLnMqKGEudC1zLnQpK2Eucyoocy50LWkudCkrcy5zKihpLnQtYS50KT49MH0sbi5pbnRlcnBvbGF0ZT1mdW5jdGlvbihpLGEscyxsKXtyZXR1cm4gaT1pPDA/MDppLHM9czwwPzA6cyxpPD1zP3M9PT0wPyhhK2wpLzI6YSsobC1hKSooaS8oaStzKSk6bCsoYS1sKSoocy8oaStzKSl9LG4uaW50ZXJzZWN0PWZ1bmN0aW9uKGksYSxzLGwsTyl7dmFyIEEsUixJO24udmVydExlcShpLGEpfHwoST1pLGk9YSxhPUkpLG4udmVydExlcShzLGwpfHwoST1zLHM9bCxsPUkpLG4udmVydExlcShpLHMpfHwoST1pLGk9cyxzPUksST1hLGE9bCxsPUkpLG4udmVydExlcShzLGEpP24udmVydExlcShhLGwpPyhBPW4uZWRnZUV2YWwoaSxzLGEpLFI9bi5lZGdlRXZhbChzLGEsbCksQStSPDAmJihBPS1BLFI9LVIpLE8ucz1uLmludGVycG9sYXRlKEEscy5zLFIsYS5zKSk6KEE9bi5lZGdlU2lnbihpLHMsYSksUj0tbi5lZGdlU2lnbihpLGwsYSksQStSPDAmJihBPS1BLFI9LVIpLE8ucz1uLmludGVycG9sYXRlKEEscy5zLFIsbC5zKSk6Ty5zPShzLnMrYS5zKS8yLG4udHJhbnNMZXEoaSxhKXx8KEk9aSxpPWEsYT1JKSxuLnRyYW5zTGVxKHMsbCl8fChJPXMscz1sLGw9SSksbi50cmFuc0xlcShpLHMpfHwoST1pLGk9cyxzPUksST1hLGE9bCxsPUkpLG4udHJhbnNMZXEocyxhKT9uLnRyYW5zTGVxKGEsbCk/KEE9bi50cmFuc0V2YWwoaSxzLGEpLFI9bi50cmFuc0V2YWwocyxhLGwpLEErUjwwJiYoQT0tQSxSPS1SKSxPLnQ9bi5pbnRlcnBvbGF0ZShBLHMudCxSLGEudCkpOihBPW4udHJhbnNTaWduKGkscyxhKSxSPS1uLnRyYW5zU2lnbihpLGwsYSksQStSPDAmJihBPS1BLFI9LVIpLE8udD1uLmludGVycG9sYXRlKEEscy50LFIsbC50KSk6Ty50PShzLnQrYS50KS8yfTtmdW5jdGlvbiB4KCl7dGhpcy5rZXk9bnVsbCx0aGlzLm5leHQ9bnVsbCx0aGlzLnByZXY9bnVsbH1mdW5jdGlvbiBjKGksYSl7dGhpcy5oZWFkPW5ldyB4LHRoaXMuaGVhZC5uZXh0PXRoaXMuaGVhZCx0aGlzLmhlYWQucHJldj10aGlzLmhlYWQsdGhpcy5mcmFtZT1pLHRoaXMubGVxPWF9Yy5wcm90b3R5cGU9e21pbjpmdW5jdGlvbigpe3JldHVybiB0aGlzLmhlYWQubmV4dH0sbWF4OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaGVhZC5wcmV2fSxpbnNlcnQ6ZnVuY3Rpb24oaSl7cmV0dXJuIHRoaXMuaW5zZXJ0QmVmb3JlKHRoaXMuaGVhZCxpKX0sc2VhcmNoOmZ1bmN0aW9uKGkpe3ZhciBhPXRoaXMuaGVhZDtkbyBhPWEubmV4dDt3aGlsZShhLmtleSE9PW51bGwmJiF0aGlzLmxlcSh0aGlzLmZyYW1lLGksYS5rZXkpKTtyZXR1cm4gYX0saW5zZXJ0QmVmb3JlOmZ1bmN0aW9uKGksYSl7ZG8gaT1pLnByZXY7d2hpbGUoaS5rZXkhPT1udWxsJiYhdGhpcy5sZXEodGhpcy5mcmFtZSxpLmtleSxhKSk7dmFyIHM9bmV3IHg7cmV0dXJuIHMua2V5PWEscy5uZXh0PWkubmV4dCxpLm5leHQucHJldj1zLHMucHJldj1pLGkubmV4dD1zLHN9LGRlbGV0ZTpmdW5jdGlvbihpKXtpLm5leHQucHJldj1pLnByZXYsaS5wcmV2Lm5leHQ9aS5uZXh0fX07ZnVuY3Rpb24gdigpe3RoaXMuaGFuZGxlPW51bGx9ZnVuY3Rpb24gcCgpe3RoaXMua2V5PW51bGwsdGhpcy5ub2RlPW51bGx9ZnVuY3Rpb24gYihpLGEpe3RoaXMuc2l6ZT0wLHRoaXMubWF4PWksdGhpcy5ub2Rlcz1bXSx0aGlzLm5vZGVzLmxlbmd0aD1pKzE7dmFyIHM7Zm9yKHM9MDtzPHRoaXMubm9kZXMubGVuZ3RoO3MrKyl0aGlzLm5vZGVzW3NdPW5ldyB2O2Zvcih0aGlzLmhhbmRsZXM9W10sdGhpcy5oYW5kbGVzLmxlbmd0aD1pKzEscz0wO3M8dGhpcy5oYW5kbGVzLmxlbmd0aDtzKyspdGhpcy5oYW5kbGVzW3NdPW5ldyBwO3RoaXMuaW5pdGlhbGl6ZWQ9ITEsdGhpcy5mcmVlTGlzdD0wLHRoaXMubGVxPWEsdGhpcy5ub2Rlc1sxXS5oYW5kbGU9MSx0aGlzLmhhbmRsZXNbMV0ua2V5PW51bGx9Yi5wcm90b3R5cGU9e2Zsb2F0RG93bl86ZnVuY3Rpb24oaSl7dmFyIGE9dGhpcy5ub2RlcyxzPXRoaXMuaGFuZGxlcyxsLE8sQTtmb3IobD1hW2ldLmhhbmRsZTs7KXtpZihBPWk8PDEsQTx0aGlzLnNpemUmJnRoaXMubGVxKHNbYVtBKzFdLmhhbmRsZV0ua2V5LHNbYVtBXS5oYW5kbGVdLmtleSkmJisrQSxkKEE8PXRoaXMubWF4KSxPPWFbQV0uaGFuZGxlLEE+dGhpcy5zaXplfHx0aGlzLmxlcShzW2xdLmtleSxzW09dLmtleSkpe2FbaV0uaGFuZGxlPWwsc1tsXS5ub2RlPWk7YnJlYWt9YVtpXS5oYW5kbGU9TyxzW09dLm5vZGU9aSxpPUF9fSxmbG9hdFVwXzpmdW5jdGlvbihpKXt2YXIgYT10aGlzLm5vZGVzLHM9dGhpcy5oYW5kbGVzLGwsTyxBO2ZvcihsPWFbaV0uaGFuZGxlOzspe2lmKEE9aT4+MSxPPWFbQV0uaGFuZGxlLEE9PT0wfHx0aGlzLmxlcShzW09dLmtleSxzW2xdLmtleSkpe2FbaV0uaGFuZGxlPWwsc1tsXS5ub2RlPWk7YnJlYWt9YVtpXS5oYW5kbGU9TyxzW09dLm5vZGU9aSxpPUF9fSxpbml0OmZ1bmN0aW9uKCl7Zm9yKHZhciBpPXRoaXMuc2l6ZTtpPj0xOy0taSl0aGlzLmZsb2F0RG93bl8oaSk7dGhpcy5pbml0aWFsaXplZD0hMH0sbWluOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaGFuZGxlc1t0aGlzLm5vZGVzWzFdLmhhbmRsZV0ua2V5fSxpbnNlcnQ6ZnVuY3Rpb24oaSl7dmFyIGEscztpZihhPSsrdGhpcy5zaXplLGEqMj50aGlzLm1heCl7dGhpcy5tYXgqPTI7dmFyIGwsTztmb3IoTz10aGlzLm5vZGVzLmxlbmd0aCx0aGlzLm5vZGVzLmxlbmd0aD10aGlzLm1heCsxLGw9TztsPHRoaXMubm9kZXMubGVuZ3RoO2wrKyl0aGlzLm5vZGVzW2xdPW5ldyB2O2ZvcihPPXRoaXMuaGFuZGxlcy5sZW5ndGgsdGhpcy5oYW5kbGVzLmxlbmd0aD10aGlzLm1heCsxLGw9TztsPHRoaXMuaGFuZGxlcy5sZW5ndGg7bCsrKXRoaXMuaGFuZGxlc1tsXT1uZXcgcH1yZXR1cm4gdGhpcy5mcmVlTGlzdD09PTA/cz1hOihzPXRoaXMuZnJlZUxpc3QsdGhpcy5mcmVlTGlzdD10aGlzLmhhbmRsZXNbc10ubm9kZSksdGhpcy5ub2Rlc1thXS5oYW5kbGU9cyx0aGlzLmhhbmRsZXNbc10ubm9kZT1hLHRoaXMuaGFuZGxlc1tzXS5rZXk9aSx0aGlzLmluaXRpYWxpemVkJiZ0aGlzLmZsb2F0VXBfKGEpLHN9LGV4dHJhY3RNaW46ZnVuY3Rpb24oKXt2YXIgaT10aGlzLm5vZGVzLGE9dGhpcy5oYW5kbGVzLHM9aVsxXS5oYW5kbGUsbD1hW3NdLmtleTtyZXR1cm4gdGhpcy5zaXplPjAmJihpWzFdLmhhbmRsZT1pW3RoaXMuc2l6ZV0uaGFuZGxlLGFbaVsxXS5oYW5kbGVdLm5vZGU9MSxhW3NdLmtleT1udWxsLGFbc10ubm9kZT10aGlzLmZyZWVMaXN0LHRoaXMuZnJlZUxpc3Q9cywtLXRoaXMuc2l6ZSx0aGlzLnNpemU+MCYmdGhpcy5mbG9hdERvd25fKDEpKSxsfSxkZWxldGU6ZnVuY3Rpb24oaSl7dmFyIGE9dGhpcy5ub2RlcyxzPXRoaXMuaGFuZGxlcyxsO2QoaT49MSYmaTw9dGhpcy5tYXgmJnNbaV0ua2V5IT09bnVsbCksbD1zW2ldLm5vZGUsYVtsXS5oYW5kbGU9YVt0aGlzLnNpemVdLmhhbmRsZSxzW2FbbF0uaGFuZGxlXS5ub2RlPWwsLS10aGlzLnNpemUsbDw9dGhpcy5zaXplJiYobDw9MXx8dGhpcy5sZXEoc1thW2w+PjFdLmhhbmRsZV0ua2V5LHNbYVtsXS5oYW5kbGVdLmtleSk/dGhpcy5mbG9hdERvd25fKGwpOnRoaXMuZmxvYXRVcF8obCkpLHNbaV0ua2V5PW51bGwsc1tpXS5ub2RlPXRoaXMuZnJlZUxpc3QsdGhpcy5mcmVlTGlzdD1pfX07ZnVuY3Rpb24gRSgpe3RoaXMuZVVwPW51bGwsdGhpcy5ub2RlVXA9bnVsbCx0aGlzLndpbmRpbmdOdW1iZXI9MCx0aGlzLmluc2lkZT0hMSx0aGlzLnNlbnRpbmVsPSExLHRoaXMuZGlydHk9ITEsdGhpcy5maXhVcHBlckVkZ2U9ITF9dmFyIHk9e307eS5yZWdpb25CZWxvdz1mdW5jdGlvbihpKXtyZXR1cm4gaS5ub2RlVXAucHJldi5rZXl9LHkucmVnaW9uQWJvdmU9ZnVuY3Rpb24oaSl7cmV0dXJuIGkubm9kZVVwLm5leHQua2V5fSx5LmRlYnVnRXZlbnQ9ZnVuY3Rpb24oaSl7fSx5LmFkZFdpbmRpbmc9ZnVuY3Rpb24oaSxhKXtpLndpbmRpbmcrPWEud2luZGluZyxpLlN5bS53aW5kaW5nKz1hLlN5bS53aW5kaW5nfSx5LmVkZ2VMZXE9ZnVuY3Rpb24oaSxhLHMpe3ZhciBsPWkuZXZlbnQsUixJLE89YS5lVXAsQT1zLmVVcDtpZihPLkRzdD09PWwpcmV0dXJuIEEuRHN0PT09bD9uLnZlcnRMZXEoTy5PcmcsQS5PcmcpP24uZWRnZVNpZ24oQS5Ec3QsTy5PcmcsQS5PcmcpPD0wOm4uZWRnZVNpZ24oTy5Ec3QsQS5PcmcsTy5PcmcpPj0wOm4uZWRnZVNpZ24oQS5Ec3QsbCxBLk9yZyk8PTA7aWYoQS5Ec3Q9PT1sKXJldHVybiBuLmVkZ2VTaWduKE8uRHN0LGwsTy5PcmcpPj0wO3ZhciBSPW4uZWRnZUV2YWwoTy5Ec3QsbCxPLk9yZyksST1uLmVkZ2VFdmFsKEEuRHN0LGwsQS5PcmcpO3JldHVybiBSPj1JfSx5LmRlbGV0ZVJlZ2lvbj1mdW5jdGlvbihpLGEpe2EuZml4VXBwZXJFZGdlJiZkKGEuZVVwLndpbmRpbmc9PT0wKSxhLmVVcC5hY3RpdmVSZWdpb249bnVsbCxpLmRpY3QuZGVsZXRlKGEubm9kZVVwKX0seS5maXhVcHBlckVkZ2U9ZnVuY3Rpb24oaSxhLHMpe2QoYS5maXhVcHBlckVkZ2UpLGkubWVzaC5kZWxldGUoYS5lVXApLGEuZml4VXBwZXJFZGdlPSExLGEuZVVwPXMscy5hY3RpdmVSZWdpb249YX0seS50b3BMZWZ0UmVnaW9uPWZ1bmN0aW9uKGksYSl7dmFyIHM9YS5lVXAuT3JnLGw7ZG8gYT15LnJlZ2lvbkFib3ZlKGEpO3doaWxlKGEuZVVwLk9yZz09PXMpO2lmKGEuZml4VXBwZXJFZGdlKXtpZihsPWkubWVzaC5jb25uZWN0KHkucmVnaW9uQmVsb3coYSkuZVVwLlN5bSxhLmVVcC5MbmV4dCksbD09PW51bGwpcmV0dXJuIG51bGw7eS5maXhVcHBlckVkZ2UoaSxhLGwpLGE9eS5yZWdpb25BYm92ZShhKX1yZXR1cm4gYX0seS50b3BSaWdodFJlZ2lvbj1mdW5jdGlvbihpKXt2YXIgYT1pLmVVcC5Ec3Q7ZG8gaT15LnJlZ2lvbkFib3ZlKGkpO3doaWxlKGkuZVVwLkRzdD09PWEpO3JldHVybiBpfSx5LmFkZFJlZ2lvbkJlbG93PWZ1bmN0aW9uKGksYSxzKXt2YXIgbD1uZXcgRTtyZXR1cm4gbC5lVXA9cyxsLm5vZGVVcD1pLmRpY3QuaW5zZXJ0QmVmb3JlKGEubm9kZVVwLGwpLGwuZml4VXBwZXJFZGdlPSExLGwuc2VudGluZWw9ITEsbC5kaXJ0eT0hMSxzLmFjdGl2ZVJlZ2lvbj1sLGx9LHkuaXNXaW5kaW5nSW5zaWRlPWZ1bmN0aW9uKGksYSl7c3dpdGNoKGkud2luZGluZ1J1bGUpe2Nhc2Ugci5XSU5ESU5HX09ERDpyZXR1cm4oYSYxKSE9PTA7Y2FzZSByLldJTkRJTkdfTk9OWkVSTzpyZXR1cm4gYSE9PTA7Y2FzZSByLldJTkRJTkdfUE9TSVRJVkU6cmV0dXJuIGE+MDtjYXNlIHIuV0lORElOR19ORUdBVElWRTpyZXR1cm4gYTwwO2Nhc2Ugci5XSU5ESU5HX0FCU19HRVFfVFdPOnJldHVybiBhPj0yfHxhPD0tMn1yZXR1cm4gZCghMSksITF9LHkuY29tcHV0ZVdpbmRpbmc9ZnVuY3Rpb24oaSxhKXthLndpbmRpbmdOdW1iZXI9eS5yZWdpb25BYm92ZShhKS53aW5kaW5nTnVtYmVyK2EuZVVwLndpbmRpbmcsYS5pbnNpZGU9eS5pc1dpbmRpbmdJbnNpZGUoaSxhLndpbmRpbmdOdW1iZXIpfSx5LmZpbmlzaFJlZ2lvbj1mdW5jdGlvbihpLGEpe3ZhciBzPWEuZVVwLGw9cy5MZmFjZTtsLmluc2lkZT1hLmluc2lkZSxsLmFuRWRnZT1zLHkuZGVsZXRlUmVnaW9uKGksYSl9LHkuZmluaXNoTGVmdFJlZ2lvbnM9ZnVuY3Rpb24oaSxhLHMpe2Zvcih2YXIgbCxSLE89bnVsbCxBPWEsUj1hLmVVcDtBIT09czspe2lmKEEuZml4VXBwZXJFZGdlPSExLE89eS5yZWdpb25CZWxvdyhBKSxsPU8uZVVwLGwuT3JnIT1SLk9yZyl7aWYoIU8uZml4VXBwZXJFZGdlKXt5LmZpbmlzaFJlZ2lvbihpLEEpO2JyZWFrfWw9aS5tZXNoLmNvbm5lY3QoUi5McHJldixsLlN5bSkseS5maXhVcHBlckVkZ2UoaSxPLGwpfVIuT25leHQhPT1sJiYoaS5tZXNoLnNwbGljZShsLk9wcmV2LGwpLGkubWVzaC5zcGxpY2UoUixsKSkseS5maW5pc2hSZWdpb24oaSxBKSxSPU8uZVVwLEE9T31yZXR1cm4gUn0seS5hZGRSaWdodEVkZ2VzPWZ1bmN0aW9uKGksYSxzLGwsTyxBKXt2YXIgUixJLFAsTCxEPSEwO1A9cztkbyBkKG4udmVydExlcShQLk9yZyxQLkRzdCkpLHkuYWRkUmVnaW9uQmVsb3coaSxhLFAuU3ltKSxQPVAuT25leHQ7d2hpbGUoUCE9PWwpO2ZvcihPPT09bnVsbCYmKE89eS5yZWdpb25CZWxvdyhhKS5lVXAuUnByZXYpLEk9YSxMPU87Uj15LnJlZ2lvbkJlbG93KEkpLFA9Ui5lVXAuU3ltLFAuT3JnPT09TC5Pcmc7KVAuT25leHQhPT1MJiYoaS5tZXNoLnNwbGljZShQLk9wcmV2LFApLGkubWVzaC5zcGxpY2UoTC5PcHJldixQKSksUi53aW5kaW5nTnVtYmVyPUkud2luZGluZ051bWJlci1QLndpbmRpbmcsUi5pbnNpZGU9eS5pc1dpbmRpbmdJbnNpZGUoaSxSLndpbmRpbmdOdW1iZXIpLEkuZGlydHk9ITAsIUQmJnkuY2hlY2tGb3JSaWdodFNwbGljZShpLEkpJiYoeS5hZGRXaW5kaW5nKFAsTCkseS5kZWxldGVSZWdpb24oaSxJKSxpLm1lc2guZGVsZXRlKEwpKSxEPSExLEk9UixMPVA7SS5kaXJ0eT0hMCxkKEkud2luZGluZ051bWJlci1QLndpbmRpbmc9PT1SLndpbmRpbmdOdW1iZXIpLEEmJnkud2Fsa0RpcnR5UmVnaW9ucyhpLEkpfSx5LnNwbGljZU1lcmdlVmVydGljZXM9ZnVuY3Rpb24oaSxhLHMpe2kubWVzaC5zcGxpY2UoYSxzKX0seS52ZXJ0ZXhXZWlnaHRzPWZ1bmN0aW9uKGksYSxzKXt2YXIgbD1uLnZlcnRMMWRpc3QoYSxpKSxPPW4udmVydEwxZGlzdChzLGkpLEE9LjUqTy8obCtPKSxSPS41KmwvKGwrTyk7aS5jb29yZHNbMF0rPUEqYS5jb29yZHNbMF0rUipzLmNvb3Jkc1swXSxpLmNvb3Jkc1sxXSs9QSphLmNvb3Jkc1sxXStSKnMuY29vcmRzWzFdLGkuY29vcmRzWzJdKz1BKmEuY29vcmRzWzJdK1Iqcy5jb29yZHNbMl19LHkuZ2V0SW50ZXJzZWN0RGF0YT1mdW5jdGlvbihpLGEscyxsLE8sQSl7YS5jb29yZHNbMF09YS5jb29yZHNbMV09YS5jb29yZHNbMl09MCxhLmlkeD0tMSx5LnZlcnRleFdlaWdodHMoYSxzLGwpLHkudmVydGV4V2VpZ2h0cyhhLE8sQSl9LHkuY2hlY2tGb3JSaWdodFNwbGljZT1mdW5jdGlvbihpLGEpe3ZhciBzPXkucmVnaW9uQmVsb3coYSksbD1hLmVVcCxPPXMuZVVwO2lmKG4udmVydExlcShsLk9yZyxPLk9yZykpe2lmKG4uZWRnZVNpZ24oTy5Ec3QsbC5PcmcsTy5PcmcpPjApcmV0dXJuITE7bi52ZXJ0RXEobC5PcmcsTy5PcmcpP2wuT3JnIT09Ty5PcmcmJihpLnBxLmRlbGV0ZShsLk9yZy5wcUhhbmRsZSkseS5zcGxpY2VNZXJnZVZlcnRpY2VzKGksTy5PcHJldixsKSk6KGkubWVzaC5zcGxpdEVkZ2UoTy5TeW0pLGkubWVzaC5zcGxpY2UobCxPLk9wcmV2KSxhLmRpcnR5PXMuZGlydHk9ITApfWVsc2V7aWYobi5lZGdlU2lnbihsLkRzdCxPLk9yZyxsLk9yZyk8MClyZXR1cm4hMTt5LnJlZ2lvbkFib3ZlKGEpLmRpcnR5PWEuZGlydHk9ITAsaS5tZXNoLnNwbGl0RWRnZShsLlN5bSksaS5tZXNoLnNwbGljZShPLk9wcmV2LGwpfXJldHVybiEwfSx5LmNoZWNrRm9yTGVmdFNwbGljZT1mdW5jdGlvbihpLGEpe3ZhciBzPXkucmVnaW9uQmVsb3coYSksbD1hLmVVcCxPPXMuZVVwLEE7aWYoZCghbi52ZXJ0RXEobC5Ec3QsTy5Ec3QpKSxuLnZlcnRMZXEobC5Ec3QsTy5Ec3QpKXtpZihuLmVkZ2VTaWduKGwuRHN0LE8uRHN0LGwuT3JnKTwwKXJldHVybiExO3kucmVnaW9uQWJvdmUoYSkuZGlydHk9YS5kaXJ0eT0hMCxBPWkubWVzaC5zcGxpdEVkZ2UobCksaS5tZXNoLnNwbGljZShPLlN5bSxBKSxBLkxmYWNlLmluc2lkZT1hLmluc2lkZX1lbHNle2lmKG4uZWRnZVNpZ24oTy5Ec3QsbC5Ec3QsTy5PcmcpPjApcmV0dXJuITE7YS5kaXJ0eT1zLmRpcnR5PSEwLEE9aS5tZXNoLnNwbGl0RWRnZShPKSxpLm1lc2guc3BsaWNlKGwuTG5leHQsTy5TeW0pLEEuUmZhY2UuaW5zaWRlPWEuaW5zaWRlfXJldHVybiEwfSx5LmNoZWNrRm9ySW50ZXJzZWN0PWZ1bmN0aW9uKGksYSl7dmFyIHM9eS5yZWdpb25CZWxvdyhhKSxsPWEuZVVwLE89cy5lVXAsQT1sLk9yZyxSPU8uT3JnLEk9bC5Ec3QsUD1PLkRzdCxMLEQsQz1uZXcgZyxTLEI7aWYoZCghbi52ZXJ0RXEoUCxJKSksZChuLmVkZ2VTaWduKEksaS5ldmVudCxBKTw9MCksZChuLmVkZ2VTaWduKFAsaS5ldmVudCxSKT49MCksZChBIT09aS5ldmVudCYmUiE9PWkuZXZlbnQpLGQoIWEuZml4VXBwZXJFZGdlJiYhcy5maXhVcHBlckVkZ2UpLEE9PT1SfHwoTD1NYXRoLm1pbihBLnQsSS50KSxEPU1hdGgubWF4KFIudCxQLnQpLEw+RCkpcmV0dXJuITE7aWYobi52ZXJ0TGVxKEEsUikpe2lmKG4uZWRnZVNpZ24oUCxBLFIpPjApcmV0dXJuITF9ZWxzZSBpZihuLmVkZ2VTaWduKEksUixBKTwwKXJldHVybiExO3JldHVybiB5LmRlYnVnRXZlbnQoaSksbi5pbnRlcnNlY3QoSSxBLFAsUixDKSxkKE1hdGgubWluKEEudCxJLnQpPD1DLnQpLGQoQy50PD1NYXRoLm1heChSLnQsUC50KSksZChNYXRoLm1pbihQLnMsSS5zKTw9Qy5zKSxkKEMuczw9TWF0aC5tYXgoUi5zLEEucykpLG4udmVydExlcShDLGkuZXZlbnQpJiYoQy5zPWkuZXZlbnQucyxDLnQ9aS5ldmVudC50KSxTPW4udmVydExlcShBLFIpP0E6UixuLnZlcnRMZXEoUyxDKSYmKEMucz1TLnMsQy50PVMudCksbi52ZXJ0RXEoQyxBKXx8bi52ZXJ0RXEoQyxSKT8oeS5jaGVja0ZvclJpZ2h0U3BsaWNlKGksYSksITEpOiFuLnZlcnRFcShJLGkuZXZlbnQpJiZuLmVkZ2VTaWduKEksaS5ldmVudCxDKT49MHx8IW4udmVydEVxKFAsaS5ldmVudCkmJm4uZWRnZVNpZ24oUCxpLmV2ZW50LEMpPD0wP1A9PT1pLmV2ZW50PyhpLm1lc2guc3BsaXRFZGdlKGwuU3ltKSxpLm1lc2guc3BsaWNlKE8uU3ltLGwpLGE9eS50b3BMZWZ0UmVnaW9uKGksYSksbD15LnJlZ2lvbkJlbG93KGEpLmVVcCx5LmZpbmlzaExlZnRSZWdpb25zKGkseS5yZWdpb25CZWxvdyhhKSxzKSx5LmFkZFJpZ2h0RWRnZXMoaSxhLGwuT3ByZXYsbCxsLCEwKSwhMCk6ST09PWkuZXZlbnQ/KGkubWVzaC5zcGxpdEVkZ2UoTy5TeW0pLGkubWVzaC5zcGxpY2UobC5MbmV4dCxPLk9wcmV2KSxzPWEsYT15LnRvcFJpZ2h0UmVnaW9uKGEpLEI9eS5yZWdpb25CZWxvdyhhKS5lVXAuUnByZXYscy5lVXA9Ty5PcHJldixPPXkuZmluaXNoTGVmdFJlZ2lvbnMoaSxzLG51bGwpLHkuYWRkUmlnaHRFZGdlcyhpLGEsTy5PbmV4dCxsLlJwcmV2LEIsITApLCEwKToobi5lZGdlU2lnbihJLGkuZXZlbnQsQyk+PTAmJih5LnJlZ2lvbkFib3ZlKGEpLmRpcnR5PWEuZGlydHk9ITAsaS5tZXNoLnNwbGl0RWRnZShsLlN5bSksbC5Pcmcucz1pLmV2ZW50LnMsbC5PcmcudD1pLmV2ZW50LnQpLG4uZWRnZVNpZ24oUCxpLmV2ZW50LEMpPD0wJiYoYS5kaXJ0eT1zLmRpcnR5PSEwLGkubWVzaC5zcGxpdEVkZ2UoTy5TeW0pLE8uT3JnLnM9aS5ldmVudC5zLE8uT3JnLnQ9aS5ldmVudC50KSwhMSk6KGkubWVzaC5zcGxpdEVkZ2UobC5TeW0pLGkubWVzaC5zcGxpdEVkZ2UoTy5TeW0pLGkubWVzaC5zcGxpY2UoTy5PcHJldixsKSxsLk9yZy5zPUMucyxsLk9yZy50PUMudCxsLk9yZy5wcUhhbmRsZT1pLnBxLmluc2VydChsLk9yZykseS5nZXRJbnRlcnNlY3REYXRhKGksbC5PcmcsQSxJLFIsUCkseS5yZWdpb25BYm92ZShhKS5kaXJ0eT1hLmRpcnR5PXMuZGlydHk9ITAsITEpfSx5LndhbGtEaXJ0eVJlZ2lvbnM9ZnVuY3Rpb24oaSxhKXtmb3IodmFyIHM9eS5yZWdpb25CZWxvdyhhKSxsLE87Oyl7Zm9yKDtzLmRpcnR5OylhPXMscz15LnJlZ2lvbkJlbG93KHMpO2lmKCFhLmRpcnR5JiYocz1hLGE9eS5yZWdpb25BYm92ZShhKSxhPT09bnVsbHx8IWEuZGlydHkpKXJldHVybjtpZihhLmRpcnR5PSExLGw9YS5lVXAsTz1zLmVVcCxsLkRzdCE9PU8uRHN0JiZ5LmNoZWNrRm9yTGVmdFNwbGljZShpLGEpJiYocy5maXhVcHBlckVkZ2U/KHkuZGVsZXRlUmVnaW9uKGkscyksaS5tZXNoLmRlbGV0ZShPKSxzPXkucmVnaW9uQmVsb3coYSksTz1zLmVVcCk6YS5maXhVcHBlckVkZ2UmJih5LmRlbGV0ZVJlZ2lvbihpLGEpLGkubWVzaC5kZWxldGUobCksYT15LnJlZ2lvbkFib3ZlKHMpLGw9YS5lVXApKSxsLk9yZyE9PU8uT3JnKWlmKGwuRHN0IT09Ty5Ec3QmJiFhLmZpeFVwcGVyRWRnZSYmIXMuZml4VXBwZXJFZGdlJiYobC5Ec3Q9PT1pLmV2ZW50fHxPLkRzdD09PWkuZXZlbnQpKXtpZih5LmNoZWNrRm9ySW50ZXJzZWN0KGksYSkpcmV0dXJufWVsc2UgeS5jaGVja0ZvclJpZ2h0U3BsaWNlKGksYSk7bC5Pcmc9PT1PLk9yZyYmbC5Ec3Q9PT1PLkRzdCYmKHkuYWRkV2luZGluZyhPLGwpLHkuZGVsZXRlUmVnaW9uKGksYSksaS5tZXNoLmRlbGV0ZShsKSxhPXkucmVnaW9uQWJvdmUocykpfX0seS5jb25uZWN0UmlnaHRWZXJ0ZXg9ZnVuY3Rpb24oaSxhLHMpe3ZhciBsLE89cy5PbmV4dCxBPXkucmVnaW9uQmVsb3coYSksUj1hLmVVcCxJPUEuZVVwLFA9ITE7aWYoUi5Ec3QhPT1JLkRzdCYmeS5jaGVja0ZvckludGVyc2VjdChpLGEpLG4udmVydEVxKFIuT3JnLGkuZXZlbnQpJiYoaS5tZXNoLnNwbGljZShPLk9wcmV2LFIpLGE9eS50b3BMZWZ0UmVnaW9uKGksYSksTz15LnJlZ2lvbkJlbG93KGEpLmVVcCx5LmZpbmlzaExlZnRSZWdpb25zKGkseS5yZWdpb25CZWxvdyhhKSxBKSxQPSEwKSxuLnZlcnRFcShJLk9yZyxpLmV2ZW50KSYmKGkubWVzaC5zcGxpY2UocyxJLk9wcmV2KSxzPXkuZmluaXNoTGVmdFJlZ2lvbnMoaSxBLG51bGwpLFA9ITApLFApe3kuYWRkUmlnaHRFZGdlcyhpLGEscy5PbmV4dCxPLE8sITApO3JldHVybn1uLnZlcnRMZXEoSS5PcmcsUi5PcmcpP2w9SS5PcHJldjpsPVIsbD1pLm1lc2guY29ubmVjdChzLkxwcmV2LGwpLHkuYWRkUmlnaHRFZGdlcyhpLGEsbCxsLk9uZXh0LGwuT25leHQsITEpLGwuU3ltLmFjdGl2ZVJlZ2lvbi5maXhVcHBlckVkZ2U9ITAseS53YWxrRGlydHlSZWdpb25zKGksYSl9LHkuY29ubmVjdExlZnREZWdlbmVyYXRlPWZ1bmN0aW9uKGksYSxzKXt2YXIgbCxPLEEsUixJO2lmKGw9YS5lVXAsbi52ZXJ0RXEobC5Pcmcscykpe2QoITEpLHkuc3BsaWNlTWVyZ2VWZXJ0aWNlcyhpLGwscy5hbkVkZ2UpO3JldHVybn1pZighbi52ZXJ0RXEobC5Ec3Qscykpe2kubWVzaC5zcGxpdEVkZ2UobC5TeW0pLGEuZml4VXBwZXJFZGdlJiYoaS5tZXNoLmRlbGV0ZShsLk9uZXh0KSxhLmZpeFVwcGVyRWRnZT0hMSksaS5tZXNoLnNwbGljZShzLmFuRWRnZSxsKSx5LnN3ZWVwRXZlbnQoaSxzKTtyZXR1cm59ZCghMSksYT15LnRvcFJpZ2h0UmVnaW9uKGEpLEk9eS5yZWdpb25CZWxvdyhhKSxBPUkuZVVwLlN5bSxPPVI9QS5PbmV4dCxJLmZpeFVwcGVyRWRnZSYmKGQoTyE9PUEpLHkuZGVsZXRlUmVnaW9uKGksSSksaS5tZXNoLmRlbGV0ZShBKSxBPU8uT3ByZXYpLGkubWVzaC5zcGxpY2Uocy5hbkVkZ2UsQSksbi5lZGdlR29lc0xlZnQoTyl8fChPPW51bGwpLHkuYWRkUmlnaHRFZGdlcyhpLGEsQS5PbmV4dCxSLE8sITApfSx5LmNvbm5lY3RMZWZ0VmVydGV4PWZ1bmN0aW9uKGksYSl7dmFyIHMsbCxPLEEsUixJLFA9bmV3IEU7aWYoUC5lVXA9YS5hbkVkZ2UuU3ltLHM9aS5kaWN0LnNlYXJjaChQKS5rZXksbD15LnJlZ2lvbkJlbG93KHMpLCEhbCl7aWYoQT1zLmVVcCxSPWwuZVVwLG4uZWRnZVNpZ24oQS5Ec3QsYSxBLk9yZyk9PT0wKXt5LmNvbm5lY3RMZWZ0RGVnZW5lcmF0ZShpLHMsYSk7cmV0dXJufWlmKE89bi52ZXJ0TGVxKFIuRHN0LEEuRHN0KT9zOmwscy5pbnNpZGV8fE8uZml4VXBwZXJFZGdlKXtpZihPPT09cylJPWkubWVzaC5jb25uZWN0KGEuYW5FZGdlLlN5bSxBLkxuZXh0KTtlbHNle3ZhciBMPWkubWVzaC5jb25uZWN0KFIuRG5leHQsYS5hbkVkZ2UpO0k9TC5TeW19Ty5maXhVcHBlckVkZ2U/eS5maXhVcHBlckVkZ2UoaSxPLEkpOnkuY29tcHV0ZVdpbmRpbmcoaSx5LmFkZFJlZ2lvbkJlbG93KGkscyxJKSkseS5zd2VlcEV2ZW50KGksYSl9ZWxzZSB5LmFkZFJpZ2h0RWRnZXMoaSxzLGEuYW5FZGdlLGEuYW5FZGdlLG51bGwsITApfX0seS5zd2VlcEV2ZW50PWZ1bmN0aW9uKGksYSl7aS5ldmVudD1hLHkuZGVidWdFdmVudChpKTtmb3IodmFyIHM9YS5hbkVkZ2U7cy5hY3RpdmVSZWdpb249PT1udWxsOylpZihzPXMuT25leHQscz09PWEuYW5FZGdlKXt5LmNvbm5lY3RMZWZ0VmVydGV4KGksYSk7cmV0dXJufXZhciBsPXkudG9wTGVmdFJlZ2lvbihpLHMuYWN0aXZlUmVnaW9uKTtkKGwhPT1udWxsKTt2YXIgTz15LnJlZ2lvbkJlbG93KGwpLEE9Ty5lVXAsUj15LmZpbmlzaExlZnRSZWdpb25zKGksTyxudWxsKTtSLk9uZXh0PT09QT95LmNvbm5lY3RSaWdodFZlcnRleChpLGwsUik6eS5hZGRSaWdodEVkZ2VzKGksbCxSLk9uZXh0LEEsQSwhMCl9LHkuYWRkU2VudGluZWw9ZnVuY3Rpb24oaSxhLHMsbCl7dmFyIE89bmV3IEUsQT1pLm1lc2gubWFrZUVkZ2UoKTtBLk9yZy5zPXMsQS5PcmcudD1sLEEuRHN0LnM9YSxBLkRzdC50PWwsaS5ldmVudD1BLkRzdCxPLmVVcD1BLE8ud2luZGluZ051bWJlcj0wLE8uaW5zaWRlPSExLE8uZml4VXBwZXJFZGdlPSExLE8uc2VudGluZWw9ITAsTy5kaXJ0eT0hMSxPLm5vZGVVcD1pLmRpY3QuaW5zZXJ0KE8pfSx5LmluaXRFZGdlRGljdD1mdW5jdGlvbihpKXtpLmRpY3Q9bmV3IGMoaSx5LmVkZ2VMZXEpO3ZhciBhPWkuYm1heFswXS1pLmJtaW5bMF0scz1pLmJtYXhbMV0taS5ibWluWzFdLGw9aS5ibWluWzBdLWEsTz1pLmJtYXhbMF0rYSxBPWkuYm1pblsxXS1zLFI9aS5ibWF4WzFdK3M7eS5hZGRTZW50aW5lbChpLGwsTyxBKSx5LmFkZFNlbnRpbmVsKGksbCxPLFIpfSx5LmRvbmVFZGdlRGljdD1mdW5jdGlvbihpKXtmb3IodmFyIGEscz0wOyhhPWkuZGljdC5taW4oKS5rZXkpIT09bnVsbDspYS5zZW50aW5lbHx8KGQoYS5maXhVcHBlckVkZ2UpLGQoKytzPT09MSkpLGQoYS53aW5kaW5nTnVtYmVyPT09MCkseS5kZWxldGVSZWdpb24oaSxhKX0seS5yZW1vdmVEZWdlbmVyYXRlRWRnZXM9ZnVuY3Rpb24oaSl7dmFyIGEscyxsLE89aS5tZXNoLmVIZWFkO2ZvcihhPU8ubmV4dDthIT09TzthPXMpcz1hLm5leHQsbD1hLkxuZXh0LG4udmVydEVxKGEuT3JnLGEuRHN0KSYmYS5MbmV4dC5MbmV4dCE9PWEmJih5LnNwbGljZU1lcmdlVmVydGljZXMoaSxsLGEpLGkubWVzaC5kZWxldGUoYSksYT1sLGw9YS5MbmV4dCksbC5MbmV4dD09PWEmJihsIT09YSYmKChsPT09c3x8bD09PXMuU3ltKSYmKHM9cy5uZXh0KSxpLm1lc2guZGVsZXRlKGwpKSwoYT09PXN8fGE9PT1zLlN5bSkmJihzPXMubmV4dCksaS5tZXNoLmRlbGV0ZShhKSl9LHkuaW5pdFByaW9yaXR5UT1mdW5jdGlvbihpKXt2YXIgYSxzLGwsTz0wO2ZvcihsPWkubWVzaC52SGVhZCxzPWwubmV4dDtzIT09bDtzPXMubmV4dClPKys7Zm9yKE8rPTgsYT1pLnBxPW5ldyBiKE8sbi52ZXJ0TGVxKSxsPWkubWVzaC52SGVhZCxzPWwubmV4dDtzIT09bDtzPXMubmV4dClzLnBxSGFuZGxlPWEuaW5zZXJ0KHMpO3JldHVybiBzIT09bD8hMTooYS5pbml0KCksITApfSx5LmRvbmVQcmlvcml0eVE9ZnVuY3Rpb24oaSl7aS5wcT1udWxsfSx5LnJlbW92ZURlZ2VuZXJhdGVGYWNlcz1mdW5jdGlvbihpLGEpe3ZhciBzLGwsTztmb3Iocz1hLmZIZWFkLm5leHQ7cyE9PWEuZkhlYWQ7cz1sKWw9cy5uZXh0LE89cy5hbkVkZ2UsZChPLkxuZXh0IT09TyksTy5MbmV4dC5MbmV4dD09PU8mJih5LmFkZFdpbmRpbmcoTy5PbmV4dCxPKSxpLm1lc2guZGVsZXRlKE8pKTtyZXR1cm4hMH0seS5jb21wdXRlSW50ZXJpb3I9ZnVuY3Rpb24oaSl7dmFyIGEscztpZih5LnJlbW92ZURlZ2VuZXJhdGVFZGdlcyhpKSwheS5pbml0UHJpb3JpdHlRKGkpKXJldHVybiExO2Zvcih5LmluaXRFZGdlRGljdChpKTsoYT1pLnBxLmV4dHJhY3RNaW4oKSkhPT1udWxsOyl7Zm9yKDtzPWkucHEubWluKCksIShzPT09bnVsbHx8IW4udmVydEVxKHMsYSkpOylzPWkucHEuZXh0cmFjdE1pbigpLHkuc3BsaWNlTWVyZ2VWZXJ0aWNlcyhpLGEuYW5FZGdlLHMuYW5FZGdlKTt5LnN3ZWVwRXZlbnQoaSxhKX1yZXR1cm4gaS5ldmVudD1pLmRpY3QubWluKCkua2V5LmVVcC5PcmcseS5kZWJ1Z0V2ZW50KGkpLHkuZG9uZUVkZ2VEaWN0KGkpLHkuZG9uZVByaW9yaXR5UShpKSx5LnJlbW92ZURlZ2VuZXJhdGVGYWNlcyhpLGkubWVzaCk/KGkubWVzaC5jaGVjaygpLCEwKTohMX07ZnVuY3Rpb24gTSgpe3RoaXMubWVzaD1udWxsLHRoaXMubm9ybWFsPVswLDAsMF0sdGhpcy5zVW5pdD1bMCwwLDBdLHRoaXMudFVuaXQ9WzAsMCwwXSx0aGlzLmJtaW49WzAsMF0sdGhpcy5ibWF4PVswLDBdLHRoaXMud2luZGluZ1J1bGU9ci5XSU5ESU5HX09ERCx0aGlzLmRpY3Q9bnVsbCx0aGlzLnBxPW51bGwsdGhpcy5ldmVudD1udWxsLHRoaXMudmVydGV4SW5kZXhDb3VudGVyPTAsdGhpcy52ZXJ0aWNlcz1bXSx0aGlzLnZlcnRleEluZGljZXM9W10sdGhpcy52ZXJ0ZXhDb3VudD0wLHRoaXMuZWxlbWVudHM9W10sdGhpcy5lbGVtZW50Q291bnQ9MH1NLnByb3RvdHlwZT17ZG90XzpmdW5jdGlvbihpLGEpe3JldHVybiBpWzBdKmFbMF0raVsxXSphWzFdK2lbMl0qYVsyXX0sbm9ybWFsaXplXzpmdW5jdGlvbihpKXt2YXIgYT1pWzBdKmlbMF0raVsxXSppWzFdK2lbMl0qaVsyXTtkKGE+MCksYT1NYXRoLnNxcnQoYSksaVswXS89YSxpWzFdLz1hLGlbMl0vPWF9LGxvbmdBeGlzXzpmdW5jdGlvbihpKXt2YXIgYT0wO3JldHVybiBNYXRoLmFicyhpWzFdKT5NYXRoLmFicyhpWzBdKSYmKGE9MSksTWF0aC5hYnMoaVsyXSk+TWF0aC5hYnMoaVthXSkmJihhPTIpLGF9LGNvbXB1dGVOb3JtYWxfOmZ1bmN0aW9uKGkpe3ZhciBhLHMsbCxPLEEsUixJPVswLDAsMF0sUD1bMCwwLDBdLEw9WzAsMCwwXSxEPVswLDAsMF0sQz1bMCwwLDBdLFM9W251bGwsbnVsbCxudWxsXSxCPVtudWxsLG51bGwsbnVsbF0sdz10aGlzLm1lc2gudkhlYWQsSDtmb3IoYT13Lm5leHQsSD0wO0g8MzsrK0gpTz1hLmNvb3Jkc1tIXSxQW0hdPU8sQltIXT1hLElbSF09TyxTW0hdPWE7Zm9yKGE9dy5uZXh0O2EhPT13O2E9YS5uZXh0KWZvcihIPTA7SDwzOysrSClPPWEuY29vcmRzW0hdLE88UFtIXSYmKFBbSF09TyxCW0hdPWEpLE8+SVtIXSYmKElbSF09TyxTW0hdPWEpO2lmKEg9MCxJWzFdLVBbMV0+SVswXS1QWzBdJiYoSD0xKSxJWzJdLVBbMl0+SVtIXS1QW0hdJiYoSD0yKSxQW0hdPj1JW0hdKXtpWzBdPTAsaVsxXT0wLGlbMl09MTtyZXR1cm59Zm9yKFI9MCxzPUJbSF0sbD1TW0hdLExbMF09cy5jb29yZHNbMF0tbC5jb29yZHNbMF0sTFsxXT1zLmNvb3Jkc1sxXS1sLmNvb3Jkc1sxXSxMWzJdPXMuY29vcmRzWzJdLWwuY29vcmRzWzJdLGE9dy5uZXh0O2EhPT13O2E9YS5uZXh0KURbMF09YS5jb29yZHNbMF0tbC5jb29yZHNbMF0sRFsxXT1hLmNvb3Jkc1sxXS1sLmNvb3Jkc1sxXSxEWzJdPWEuY29vcmRzWzJdLWwuY29vcmRzWzJdLENbMF09TFsxXSpEWzJdLUxbMl0qRFsxXSxDWzFdPUxbMl0qRFswXS1MWzBdKkRbMl0sQ1syXT1MWzBdKkRbMV0tTFsxXSpEWzBdLEE9Q1swXSpDWzBdK0NbMV0qQ1sxXStDWzJdKkNbMl0sQT5SJiYoUj1BLGlbMF09Q1swXSxpWzFdPUNbMV0saVsyXT1DWzJdKTtSPD0wJiYoaVswXT1pWzFdPWlbMl09MCxpW3RoaXMubG9uZ0F4aXNfKEwpXT0xKX0sY2hlY2tPcmllbnRhdGlvbl86ZnVuY3Rpb24oKXt2YXIgaSxhLHM9dGhpcy5tZXNoLmZIZWFkLGwsTz10aGlzLm1lc2gudkhlYWQsQTtmb3IoaT0wLGE9cy5uZXh0O2EhPT1zO2E9YS5uZXh0KWlmKEE9YS5hbkVkZ2UsIShBLndpbmRpbmc8PTApKWRvIGkrPShBLk9yZy5zLUEuRHN0LnMpKihBLk9yZy50K0EuRHN0LnQpLEE9QS5MbmV4dDt3aGlsZShBIT09YS5hbkVkZ2UpO2lmKGk8MCl7Zm9yKGw9Ty5uZXh0O2whPT1PO2w9bC5uZXh0KWwudD0tbC50O3RoaXMudFVuaXRbMF09LXRoaXMudFVuaXRbMF0sdGhpcy50VW5pdFsxXT0tdGhpcy50VW5pdFsxXSx0aGlzLnRVbml0WzJdPS10aGlzLnRVbml0WzJdfX0scHJvamVjdFBvbHlnb25fOmZ1bmN0aW9uKCl7dmFyIGksYT10aGlzLm1lc2gudkhlYWQscz1bMCwwLDBdLGwsTyxBLFIsST0hMTtmb3Ioc1swXT10aGlzLm5vcm1hbFswXSxzWzFdPXRoaXMubm9ybWFsWzFdLHNbMl09dGhpcy5ub3JtYWxbMl0sc1swXT09PTAmJnNbMV09PT0wJiZzWzJdPT09MCYmKHRoaXMuY29tcHV0ZU5vcm1hbF8ocyksST0hMCksbD10aGlzLnNVbml0LE89dGhpcy50VW5pdCxBPXRoaXMubG9uZ0F4aXNfKHMpLGxbQV09MCxsWyhBKzEpJTNdPTEsbFsoQSsyKSUzXT0wLE9bQV09MCxPWyhBKzEpJTNdPTAsT1soQSsyKSUzXT1zW0FdPjA/MTotMSxpPWEubmV4dDtpIT09YTtpPWkubmV4dClpLnM9dGhpcy5kb3RfKGkuY29vcmRzLGwpLGkudD10aGlzLmRvdF8oaS5jb29yZHMsTyk7Zm9yKEkmJnRoaXMuY2hlY2tPcmllbnRhdGlvbl8oKSxSPSEwLGk9YS5uZXh0O2khPT1hO2k9aS5uZXh0KVI/KHRoaXMuYm1pblswXT10aGlzLmJtYXhbMF09aS5zLHRoaXMuYm1pblsxXT10aGlzLmJtYXhbMV09aS50LFI9ITEpOihpLnM8dGhpcy5ibWluWzBdJiYodGhpcy5ibWluWzBdPWkucyksaS5zPnRoaXMuYm1heFswXSYmKHRoaXMuYm1heFswXT1pLnMpLGkudDx0aGlzLmJtaW5bMV0mJih0aGlzLmJtaW5bMV09aS50KSxpLnQ+dGhpcy5ibWF4WzFdJiYodGhpcy5ibWF4WzFdPWkudCkpfSxhZGRXaW5kaW5nXzpmdW5jdGlvbihpLGEpe2kud2luZGluZys9YS53aW5kaW5nLGkuU3ltLndpbmRpbmcrPWEuU3ltLndpbmRpbmd9LHRlc3NlbGxhdGVNb25vUmVnaW9uXzpmdW5jdGlvbihpLGEpe3ZhciBzLGw7Zm9yKHM9YS5hbkVkZ2UsZChzLkxuZXh0IT09cyYmcy5MbmV4dC5MbmV4dCE9PXMpO24udmVydExlcShzLkRzdCxzLk9yZyk7cz1zLkxwcmV2KTtmb3IoO24udmVydExlcShzLk9yZyxzLkRzdCk7cz1zLkxuZXh0KTtmb3IobD1zLkxwcmV2O3MuTG5leHQhPT1sOylpZihuLnZlcnRMZXEocy5Ec3QsbC5PcmcpKXtmb3IoO2wuTG5leHQhPT1zJiYobi5lZGdlR29lc0xlZnQobC5MbmV4dCl8fG4uZWRnZVNpZ24obC5PcmcsbC5Ec3QsbC5MbmV4dC5Ec3QpPD0wKTspe3ZhciBPPWkuY29ubmVjdChsLkxuZXh0LGwpO2w9Ty5TeW19bD1sLkxwcmV2fWVsc2V7Zm9yKDtsLkxuZXh0IT09cyYmKG4uZWRnZUdvZXNSaWdodChzLkxwcmV2KXx8bi5lZGdlU2lnbihzLkRzdCxzLk9yZyxzLkxwcmV2Lk9yZyk+PTApOyl7dmFyIE89aS5jb25uZWN0KHMscy5McHJldik7cz1PLlN5bX1zPXMuTG5leHR9Zm9yKGQobC5MbmV4dCE9PXMpO2wuTG5leHQuTG5leHQhPT1zOyl7dmFyIE89aS5jb25uZWN0KGwuTG5leHQsbCk7bD1PLlN5bX1yZXR1cm4hMH0sdGVzc2VsbGF0ZUludGVyaW9yXzpmdW5jdGlvbihpKXt2YXIgYSxzO2ZvcihhPWkuZkhlYWQubmV4dDthIT09aS5mSGVhZDthPXMpaWYocz1hLm5leHQsYS5pbnNpZGUmJiF0aGlzLnRlc3NlbGxhdGVNb25vUmVnaW9uXyhpLGEpKXJldHVybiExO3JldHVybiEwfSxkaXNjYXJkRXh0ZXJpb3JfOmZ1bmN0aW9uKGkpe3ZhciBhLHM7Zm9yKGE9aS5mSGVhZC5uZXh0O2EhPT1pLmZIZWFkO2E9cylzPWEubmV4dCxhLmluc2lkZXx8aS56YXBGYWNlKGEpfSxzZXRXaW5kaW5nTnVtYmVyXzpmdW5jdGlvbihpLGEscyl7dmFyIGwsTztmb3IobD1pLmVIZWFkLm5leHQ7bCE9PWkuZUhlYWQ7bD1PKU89bC5uZXh0LGwuUmZhY2UuaW5zaWRlIT09bC5MZmFjZS5pbnNpZGU/bC53aW5kaW5nPWwuTGZhY2UuaW5zaWRlP2E6LWE6cz9pLmRlbGV0ZShsKTpsLndpbmRpbmc9MH0sZ2V0TmVpZ2hib3VyRmFjZV86ZnVuY3Rpb24oaSl7cmV0dXJuIWkuUmZhY2V8fCFpLlJmYWNlLmluc2lkZT8tMTppLlJmYWNlLm59LG91dHB1dFBvbHltZXNoXzpmdW5jdGlvbihpLGEscyxsKXt2YXIgTyxBLFIsST0wLFA9MCxMLEQ7Zm9yKHM+MyYmaS5tZXJnZUNvbnZleEZhY2VzKHMpLE89aS52SGVhZC5uZXh0O08hPT1pLnZIZWFkO089Ty5uZXh0KU8ubj0tMTtmb3IoQT1pLmZIZWFkLm5leHQ7QSE9PWkuZkhlYWQ7QT1BLm5leHQpaWYoQS5uPS0xLCEhQS5pbnNpZGUpe1I9QS5hbkVkZ2UsTD0wO2RvIE89Ui5PcmcsTy5uPT09LTEmJihPLm49UCxQKyspLEwrKyxSPVIuTG5leHQ7d2hpbGUoUiE9PUEuYW5FZGdlKTtkKEw8PXMpLEEubj1JLCsrSX1mb3IodGhpcy5lbGVtZW50Q291bnQ9SSxhPT09ci5DT05ORUNURURfUE9MWUdPTlMmJihJKj0yKSx0aGlzLmVsZW1lbnRzPVtdLHRoaXMuZWxlbWVudHMubGVuZ3RoPUkqcyx0aGlzLnZlcnRleENvdW50PVAsdGhpcy52ZXJ0aWNlcz1bXSx0aGlzLnZlcnRpY2VzLmxlbmd0aD1QKmwsdGhpcy52ZXJ0ZXhJbmRpY2VzPVtdLHRoaXMudmVydGV4SW5kaWNlcy5sZW5ndGg9UCxPPWkudkhlYWQubmV4dDtPIT09aS52SGVhZDtPPU8ubmV4dClpZihPLm4hPT0tMSl7dmFyIEM9Ty5uKmw7dGhpcy52ZXJ0aWNlc1tDKzBdPU8uY29vcmRzWzBdLHRoaXMudmVydGljZXNbQysxXT1PLmNvb3Jkc1sxXSxsPjImJih0aGlzLnZlcnRpY2VzW0MrMl09Ty5jb29yZHNbMl0pLHRoaXMudmVydGV4SW5kaWNlc1tPLm5dPU8uaWR4fXZhciBTPTA7Zm9yKEE9aS5mSGVhZC5uZXh0O0EhPT1pLmZIZWFkO0E9QS5uZXh0KWlmKEEuaW5zaWRlKXtSPUEuYW5FZGdlLEw9MDtkbyBPPVIuT3JnLHRoaXMuZWxlbWVudHNbUysrXT1PLm4sTCsrLFI9Ui5MbmV4dDt3aGlsZShSIT09QS5hbkVkZ2UpO2ZvcihEPUw7RDxzOysrRCl0aGlzLmVsZW1lbnRzW1MrK109LTE7aWYoYT09PXIuQ09OTkVDVEVEX1BPTFlHT05TKXtSPUEuYW5FZGdlO2RvIHRoaXMuZWxlbWVudHNbUysrXT10aGlzLmdldE5laWdoYm91ckZhY2VfKFIpLFI9Ui5MbmV4dDt3aGlsZShSIT09QS5hbkVkZ2UpO2ZvcihEPUw7RDxzOysrRCl0aGlzLmVsZW1lbnRzW1MrK109LTF9fX0sb3V0cHV0Q29udG91cnNfOmZ1bmN0aW9uKGksYSl7dmFyIHMsbCxPLEE9MCxSPTA7Zm9yKHRoaXMudmVydGV4Q291bnQ9MCx0aGlzLmVsZW1lbnRDb3VudD0wLHM9aS5mSGVhZC5uZXh0O3MhPT1pLmZIZWFkO3M9cy5uZXh0KWlmKHMuaW5zaWRlKXtPPWw9cy5hbkVkZ2U7ZG8gdGhpcy52ZXJ0ZXhDb3VudCsrLGw9bC5MbmV4dDt3aGlsZShsIT09Tyk7dGhpcy5lbGVtZW50Q291bnQrK310aGlzLmVsZW1lbnRzPVtdLHRoaXMuZWxlbWVudHMubGVuZ3RoPXRoaXMuZWxlbWVudENvdW50KjIsdGhpcy52ZXJ0aWNlcz1bXSx0aGlzLnZlcnRpY2VzLmxlbmd0aD10aGlzLnZlcnRleENvdW50KmEsdGhpcy52ZXJ0ZXhJbmRpY2VzPVtdLHRoaXMudmVydGV4SW5kaWNlcy5sZW5ndGg9dGhpcy52ZXJ0ZXhDb3VudDt2YXIgST0wLFA9MCxMPTA7Zm9yKEE9MCxzPWkuZkhlYWQubmV4dDtzIT09aS5mSGVhZDtzPXMubmV4dClpZihzLmluc2lkZSl7Uj0wLE89bD1zLmFuRWRnZTtkbyB0aGlzLnZlcnRpY2VzW0krK109bC5PcmcuY29vcmRzWzBdLHRoaXMudmVydGljZXNbSSsrXT1sLk9yZy5jb29yZHNbMV0sYT4yJiYodGhpcy52ZXJ0aWNlc1tJKytdPWwuT3JnLmNvb3Jkc1syXSksdGhpcy52ZXJ0ZXhJbmRpY2VzW1ArK109bC5PcmcuaWR4LFIrKyxsPWwuTG5leHQ7d2hpbGUobCE9PU8pO3RoaXMuZWxlbWVudHNbTCsrXT1BLHRoaXMuZWxlbWVudHNbTCsrXT1SLEErPVJ9fSxhZGRDb250b3VyOmZ1bmN0aW9uKGksYSl7dmFyIHMsbDtmb3IodGhpcy5tZXNoPT09bnVsbCYmKHRoaXMubWVzaD1uZXcgZiksaTwyJiYoaT0yKSxpPjMmJihpPTMpLHM9bnVsbCxsPTA7bDxhLmxlbmd0aDtsKz1pKXM9PT1udWxsPyhzPXRoaXMubWVzaC5tYWtlRWRnZSgpLHRoaXMubWVzaC5zcGxpY2UocyxzLlN5bSkpOih0aGlzLm1lc2guc3BsaXRFZGdlKHMpLHM9cy5MbmV4dCkscy5PcmcuY29vcmRzWzBdPWFbbCswXSxzLk9yZy5jb29yZHNbMV09YVtsKzFdLGk+Mj9zLk9yZy5jb29yZHNbMl09YVtsKzJdOnMuT3JnLmNvb3Jkc1syXT0wLHMuT3JnLmlkeD10aGlzLnZlcnRleEluZGV4Q291bnRlcisrLHMud2luZGluZz0xLHMuU3ltLndpbmRpbmc9LTF9LHRlc3NlbGF0ZTpmdW5jdGlvbihpLGEscyxsLE8pe2lmKHRoaXMudmVydGljZXM9W10sdGhpcy5lbGVtZW50cz1bXSx0aGlzLnZlcnRleEluZGljZXM9W10sdGhpcy52ZXJ0ZXhJbmRleENvdW50ZXI9MCxPJiYodGhpcy5ub3JtYWxbMF09T1swXSx0aGlzLm5vcm1hbFsxXT1PWzFdLHRoaXMubm9ybWFsWzJdPU9bMl0pLHRoaXMud2luZGluZ1J1bGU9aSxsPDImJihsPTIpLGw+MyYmKGw9MyksIXRoaXMubWVzaClyZXR1cm4hMTt0aGlzLnByb2plY3RQb2x5Z29uXygpLHkuY29tcHV0ZUludGVyaW9yKHRoaXMpO3ZhciBBPXRoaXMubWVzaDtyZXR1cm4gYT09PXIuQk9VTkRBUllfQ09OVE9VUlM/dGhpcy5zZXRXaW5kaW5nTnVtYmVyXyhBLDEsITApOnRoaXMudGVzc2VsbGF0ZUludGVyaW9yXyhBKSxBLmNoZWNrKCksYT09PXIuQk9VTkRBUllfQ09OVE9VUlM/dGhpcy5vdXRwdXRDb250b3Vyc18oQSxsKTp0aGlzLm91dHB1dFBvbHltZXNoXyhBLGEscyxsKSwhMH19fSxmdW5jdGlvbihoLGUpe2guZXhwb3J0cz1yO3ZhciB0PU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7ZnVuY3Rpb24gcigpe2Zvcih2YXIgbj17fSxkPTA7ZDxhcmd1bWVudHMubGVuZ3RoO2QrKyl7dmFyIGc9YXJndW1lbnRzW2RdO2Zvcih2YXIgdSBpbiBnKXQuY2FsbChnLHUpJiYoblt1XT1nW3VdKX1yZXR1cm4gbn19LGZ1bmN0aW9uKGgsZSx0KXt0LnIoZSksdC5kKGUsImNyZWF0ZVNoYWRlcnMiLGZ1bmN0aW9uKCl7cmV0dXJuIG99KSx0LmQoZSwiYXBwbHlTaGFkZXIiLGZ1bmN0aW9uKCl7cmV0dXJuIGZ9KSx0LmQoZSwiY3JlYXRlQ2xvdWRTaGFkZXJzIixmdW5jdGlvbigpe3JldHVybiBjfSksdC5kKGUsImFwcGx5Q2xvdWRTaGFkZXIiLGZ1bmN0aW9uKCl7cmV0dXJuIHZ9KTt2YXIgcj10KDY0KSxuPXQoNjUpLGQ9dCg2NiksZz10KDY3KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3QgdT1TeW1ib2woInNoYWRlcnMiKTtmdW5jdGlvbiBvKHApe3BbdV09W107Zm9yKGxldCBiPTA7YjwxNjtiKyspe2NvbnN0IEU9W10seT0hIShiJjEpLE09ISEoYiYyKSxpPSEhKGImNCksYT0hIShiJjgpO3kmJkUucHVzaCgiI2RlZmluZSBURVhUVVJFIDEiKSxNJiZFLnB1c2goIiNkZWZpbmUgRklMVEVSIDEiKSxpJiZFLnB1c2goIiNkZWZpbmUgR1JBRElFTlQgMSIpLGEmJkUucHVzaCgiI2RlZmluZSBDTElQUEFUSCAxIik7Y29uc3Qgcz1gJHtFLmpvaW4oYApgKX0KYCxsPVtdO3kmJmwucHVzaCgidW5pZm9ybSBzYW1wbGVyMkQgdV90ZXhTYW1wbGVyOyIpLGEmJmwucHVzaCgidW5pZm9ybSBzYW1wbGVyMkQgdV9jbGlwU2FtcGxlcjsiKSxwW3VdW2JdPVtzK2wuam9pbihgCmApK24uZGVmYXVsdCxzK3IuZGVmYXVsdF19fWZ1bmN0aW9uIGYocCx7aGFzVGV4dHVyZTpiPSExLGhhc0ZpbHRlcjpFPSExLGhhc0dyYWRpZW50Onk9ITEsaGFzQ2xpcFBhdGg6TT0hMX09e30pe2NvbnN0IGk9YnxFPDwxfHk8PDJ8TTw8MztsZXQgYT1wW3VdW2ldO0FycmF5LmlzQXJyYXkoYSkmJihhPXAuY3JlYXRlUHJvZ3JhbSguLi5hKSxwW3VdW2ldPWEpLHAucHJvZ3JhbSE9PWEmJnAudXNlUHJvZ3JhbShhLHthX2NvbG9yOnt0eXBlOiJVTlNJR05FRF9CWVRFIixub3JtYWxpemU6ITB9fSl9Y29uc3QgeD1bXTtmdW5jdGlvbiBjKHApe2ZvcihsZXQgYj0wO2I8NjQ7YisrKXtjb25zdCBFPVtdLHk9ISEoYiYxKSxNPSEhKGImMiksaT0hIShiJjQpLGE9ISEoYiY4KSxzPSEhKGImMTYpLGw9ISEoYiYzMik7eSYmRS5wdXNoKCIjZGVmaW5lIFRFWFRVUkUgMSIpLE0mJkUucHVzaCgiI2RlZmluZSBGSUxURVIgMSIpLGkmJkUucHVzaCgiI2RlZmluZSBHUkFESUVOVCAxIiksYSYmRS5wdXNoKCIjZGVmaW5lIENMT1VEQ09MT1IgMSIpLHMmJkUucHVzaCgiI2RlZmluZSBDTE9VREZJTFRFUiAxIiksbCYmRS5wdXNoKCIjZGVmaW5lIENMSVBQQVRIIDEiKTtjb25zdCBPPWAke0Uuam9pbihgCmApfQpgLEE9W107aWYoeSl7QS5wdXNoKCJ1bmlmb3JtIHNhbXBsZXIyRCB1X3RleFNhbXBsZXI7Iik7Zm9yKGxldCBSPTA7UjwxMjtSKyspQS5wdXNoKGB1bmlmb3JtIHNhbXBsZXIyRCB1X3RleEZyYW1lJHtSfTtgKX1sJiZBLnB1c2goInVuaWZvcm0gc2FtcGxlcjJEIHVfY2xpcFNhbXBsZXI7IikseFtiXT1bTytBLmpvaW4oYApgKStnLmRlZmF1bHQsTytkLmRlZmF1bHRdfX1mdW5jdGlvbiB2KHAse2hhc1RleHR1cmU6Yj0hMSxoYXNGaWx0ZXI6RT0hMSxoYXNHcmFkaWVudDp5PSExLGhhc0Nsb3VkQ29sb3I6TT0hMSxoYXNDbG91ZEZpbHRlcjppPSExLGhhc0NsaXBQYXRoOmE9ITF9PXt9KXtjb25zdCBzPWJ8RTw8MXx5PDwyfE08PDN8aTw8NHxhPDw1O2xldCBsPXhbc107QXJyYXkuaXNBcnJheShsKSYmKGw9cC5jcmVhdGVQcm9ncmFtKC4uLmwpLHhbc109bCkscC5wcm9ncmFtIT09bCYmcC51c2VQcm9ncmFtKGwse2FfY29sb3I6e3R5cGU6IlVOU0lHTkVEX0JZVEUiLG5vcm1hbGl6ZTohMH0sYV9maWxsQ2xvdWRDb2xvcjp7dHlwZToiVU5TSUdORURfQllURSIsbm9ybWFsaXplOiEwfSxhX3N0cm9rZUNsb3VkQ29sb3I6e3R5cGU6IlVOU0lHTkVEX0JZVEUiLG5vcm1hbGl6ZTohMH0sYV9mcmFtZUluZGV4Ont0eXBlOiJVTlNJR05FRF9CWVRFIixub3JtYWxpemU6ITF9fSl9fSxmdW5jdGlvbihoLGUsdCl7dC5yKGUpLGUuZGVmYXVsdD1gYXR0cmlidXRlIHZlYzMgYV92ZXJ0ZXhQb3NpdGlvbjsKYXR0cmlidXRlIHZlYzQgYV9jb2xvcjsKdmFyeWluZyB2ZWM0IHZDb2xvcjsKdmFyeWluZyBmbG9hdCBmbGFnQmFja2dyb3VuZDsKdW5pZm9ybSB2ZWMyIHVfcmVzb2x1dGlvbjsKdW5pZm9ybSBtYXQzIHZpZXdNYXRyaXg7CnVuaWZvcm0gbWF0MyBwcm9qZWN0aW9uTWF0cml4OwoKI2lmZGVmIFRFWFRVUkUKYXR0cmlidXRlIHZlYzMgYV92ZXJ0ZXhUZXh0dXJlQ29vcmQ7CnZhcnlpbmcgdmVjMyB2VGV4dHVyZUNvb3JkOwphdHRyaWJ1dGUgdmVjNCBhX3NvdXJjZVJlY3Q7CnZhcnlpbmcgdmVjNCB2U291cmNlUmVjdDsKI2VuZGlmCgojaWZkZWYgQ0xJUFBBVEgKYXR0cmlidXRlIHZlYzIgYV9jbGlwVVY7CnZhcnlpbmcgdmVjMiB2Q2xpcFVWOwojZW5kaWYKCiNpZmRlZiBHUkFESUVOVAp1bmlmb3JtIGZsb2F0IHVfcmFkaWFsR3JhZGllbnRWZWN0b3JbNl07CnZhcnlpbmcgdmVjMyB2R3JhZGllbnRWZWN0b3IxOwp2YXJ5aW5nIHZlYzMgdkdyYWRpZW50VmVjdG9yMjsKI2VuZGlmCgp2b2lkIG1haW4oKSB7CiAgZ2xfUG9pbnRTaXplID0gMS4wOwoKICB2ZWMzIHBvcyA9IHByb2plY3Rpb25NYXRyaXggKiB2aWV3TWF0cml4ICogdmVjMyhhX3ZlcnRleFBvc2l0aW9uLnh5LCAxLjApOwogIGdsX1Bvc2l0aW9uID0gdmVjNChwb3MueHksIDEuMCwgMS4wKTsKCiNpZmRlZiBHUkFESUVOVAogIHZlYzMgdmcxID0gdmlld01hdHJpeCAqIHZlYzModV9yYWRpYWxHcmFkaWVudFZlY3RvclswXSwgdV9yYWRpYWxHcmFkaWVudFZlY3RvclsxXSwgMS4wKTsKICB2ZWMzIHZnMiA9IHZpZXdNYXRyaXggKiB2ZWMzKHVfcmFkaWFsR3JhZGllbnRWZWN0b3JbM10sIHVfcmFkaWFsR3JhZGllbnRWZWN0b3JbNF0sIDEuMCk7CiAgZmxvYXQgaCA9IHVfcmVzb2x1dGlvbi55OwogIHZnMS55ID0gaCAtIHZnMS55OwogIHZnMi55ID0gaCAtIHZnMi55OwogIHZHcmFkaWVudFZlY3RvcjEgPSB2ZWMzKHZnMS54eSwgdV9yYWRpYWxHcmFkaWVudFZlY3RvclsyXSk7CiAgdkdyYWRpZW50VmVjdG9yMiA9IHZlYzModmcyLnh5LCB1X3JhZGlhbEdyYWRpZW50VmVjdG9yWzVdKTsKI2VuZGlmCiAgCiAgZmxhZ0JhY2tncm91bmQgPSBhX3ZlcnRleFBvc2l0aW9uLno7CiAgdkNvbG9yID0gYV9jb2xvcjsKCiNpZmRlZiBURVhUVVJFCiAgdlRleHR1cmVDb29yZCA9IGFfdmVydGV4VGV4dHVyZUNvb3JkOwogIHZTb3VyY2VSZWN0ID0gYV9zb3VyY2VSZWN0OwojZW5kaWYKCiNpZmRlZiBDTElQUEFUSAogIHZDbGlwVVYgPSBhX2NsaXBVVjsKI2VuZGlmCn1gfSxmdW5jdGlvbihoLGUsdCl7dC5yKGUpLGUuZGVmYXVsdD1gcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7Cgp2YXJ5aW5nIHZlYzQgdkNvbG9yOwp2YXJ5aW5nIGZsb2F0IGZsYWdCYWNrZ3JvdW5kOwoKI2lmZGVmIFRFWFRVUkUKdmFyeWluZyB2ZWMzIHZUZXh0dXJlQ29vcmQ7CnZhcnlpbmcgdmVjNCB2U291cmNlUmVjdDsKI2VuZGlmCgojaWZkZWYgQ0xJUFBBVEgKdmFyeWluZyB2ZWMyIHZDbGlwVVY7CiNlbmRpZgoKI2lmZGVmIEZJTFRFUgp1bmlmb3JtIGludCB1X2ZpbHRlckZsYWc7CnVuaWZvcm0gZmxvYXQgdV9jb2xvck1hdHJpeFsyMF07CiNlbmRpZgoKI2lmZGVmIEdSQURJRU5UCnZhcnlpbmcgdmVjMyB2R3JhZGllbnRWZWN0b3IxOwp2YXJ5aW5nIHZlYzMgdkdyYWRpZW50VmVjdG9yMjsKdW5pZm9ybSBmbG9hdCB1X2NvbG9yU3RlcHNbNDBdOwp1bmlmb3JtIGludCB1X2dyYWRpZW50VHlwZTsKLy8gdW5pZm9ybSBmbG9hdCB1X3JhZGlhbEdyYWRpZW50VmVjdG9yWzZdOwoKdm9pZCBncmFkaWVudChpbm91dCB2ZWM0IGNvbG9yLCB2ZWMzIGd2MSwgdmVjMyBndjIsIGZsb2F0IGNvbG9yU3RlcHNbNDBdKSB7CiAgZmxvYXQgdDsKICAvLyBjZW50ZXIgY2lyY2xlIHJhZGl1cwogIGZsb2F0IGNyID0gZ3YxLno7CiAgLy8gZm9jYWwgY2lyY2xlIHJhZGl1cwogIGZsb2F0IGZyID0gZ3YyLno7CgogIGlmKGNyID4gMC4wIHx8IGZyID4gMC4wKSB7CiAgICAvLyByYWRpYWwgZ3JhZGllbnQKICAgIHZlYzIgY2VudGVyID0gZ3YxLnh5OwogICAgdmVjMiBmb2NhbCA9IGd2Mi54eTsKICAgIGZsb2F0IHggPSBmb2NhbC54IC0gZ2xfRnJhZ0Nvb3JkLng7CiAgICBmbG9hdCB5ID0gZm9jYWwueSAtIGdsX0ZyYWdDb29yZC55OwogICAgZmxvYXQgZHggPSBmb2NhbC54IC0gY2VudGVyLng7CiAgICBmbG9hdCBkeSA9IGZvY2FsLnkgLSBjZW50ZXIueTsKICAgIGZsb2F0IGRyID0gY3IgLSBmcjsKICAgIGZsb2F0IGEgPSBkeCAqIGR4ICsgZHkgKiBkeSAtIGRyICogZHI7CiAgICBmbG9hdCBiID0gLTIuMCAqICh5ICogZHkgKyB4ICogZHggKyBmciAqIGRyKTsKICAgIGZsb2F0IGMgPSB4ICogeCArIHkgKiB5IC0gZnIgKiBmcjsKICAgIHQgPSAxLjAgLSAwLjUgKiAoMS4wIC8gYSkgKiAoLWIgKyBzcXJ0KGIgKiBiIC0gNC4wICogYSAqIGMpKTsKICB9IGVsc2UgewogICAgLy8gbGluZWFyIGdyYWRpZW50CiAgICB2ZWMyIHYxID0gZ2xfRnJhZ0Nvb3JkLnh5IC0gZ3YxLnh5OwogICAgdmVjMiB2MiA9IGd2Mi54eSAtIGd2MS54eTsKICAgIHQgPSAodjEueCAqIHYyLnggKyB2MS55ICogdjIueSkgLyAodjIueCAqIHYyLnggKyB2Mi55ICogdjIueSk7CiAgfQoKICB2ZWM0IGNvbG9yc1s4XTsKICBjb2xvcnNbMF0gPSB2ZWM0KGNvbG9yU3RlcHNbMV0sIGNvbG9yU3RlcHNbMl0sIGNvbG9yU3RlcHNbM10sIGNvbG9yU3RlcHNbNF0pOwogIGNvbG9yc1sxXSA9IHZlYzQoY29sb3JTdGVwc1s2XSwgY29sb3JTdGVwc1s3XSwgY29sb3JTdGVwc1s4XSwgY29sb3JTdGVwc1s5XSk7CiAgY29sb3JzWzJdID0gdmVjNChjb2xvclN0ZXBzWzExXSwgY29sb3JTdGVwc1sxMl0sIGNvbG9yU3RlcHNbMTNdLCBjb2xvclN0ZXBzWzE0XSk7CiAgY29sb3JzWzNdID0gdmVjNChjb2xvclN0ZXBzWzE2XSwgY29sb3JTdGVwc1sxN10sIGNvbG9yU3RlcHNbMThdLCBjb2xvclN0ZXBzWzE5XSk7CiAgY29sb3JzWzRdID0gdmVjNChjb2xvclN0ZXBzWzIxXSwgY29sb3JTdGVwc1syMl0sIGNvbG9yU3RlcHNbMjNdLCBjb2xvclN0ZXBzWzI0XSk7CiAgY29sb3JzWzVdID0gdmVjNChjb2xvclN0ZXBzWzI2XSwgY29sb3JTdGVwc1syN10sIGNvbG9yU3RlcHNbMjhdLCBjb2xvclN0ZXBzWzI5XSk7CiAgY29sb3JzWzZdID0gdmVjNChjb2xvclN0ZXBzWzMxXSwgY29sb3JTdGVwc1szMl0sIGNvbG9yU3RlcHNbMzNdLCBjb2xvclN0ZXBzWzM0XSk7CiAgY29sb3JzWzddID0gdmVjNChjb2xvclN0ZXBzWzM2XSwgY29sb3JTdGVwc1szN10sIGNvbG9yU3RlcHNbMzhdLCBjb2xvclN0ZXBzWzM5XSk7CiAgCiAgZmxvYXQgc3RlcHNbOF07CiAgc3RlcHNbMF0gPSBjb2xvclN0ZXBzWzBdOwogIHN0ZXBzWzFdID0gY29sb3JTdGVwc1s1XTsKICBzdGVwc1syXSA9IGNvbG9yU3RlcHNbMTBdOwogIHN0ZXBzWzNdID0gY29sb3JTdGVwc1sxNV07CiAgc3RlcHNbNF0gPSBjb2xvclN0ZXBzWzIwXTsKICBzdGVwc1s1XSA9IGNvbG9yU3RlcHNbMjVdOwogIHN0ZXBzWzZdID0gY29sb3JTdGVwc1szMF07CiAgc3RlcHNbN10gPSBjb2xvclN0ZXBzWzM1XTsKCiAgY29sb3IgPSBjb2xvcnNbMF07CiAgZm9yIChpbnQgaSA9IDE7IGkgPCA4OyBpKyspIHsKICAgIGlmIChzdGVwc1tpXSA8IDAuMCB8fCBzdGVwc1tpXSA+IDEuMCkgewogICAgICBicmVhazsKICAgIH0KICAgIGlmKHN0ZXBzW2ldID09IHN0ZXBzW2kgLSAxXSkgewogICAgICBjb2xvciA9IGNvbG9yc1tpXTsKICAgIH0gZWxzZSB7CiAgICAgIGNvbG9yID0gbWl4KGNvbG9yLCBjb2xvcnNbaV0sIGNsYW1wKCh0IC0gc3RlcHNbaSAtIDFdKSAvIChzdGVwc1tpXSAtIHN0ZXBzW2kgLSAxXSksIDAuMCwgMS4wKSk7CiAgICB9CiAgICBpZiAoc3RlcHNbaV0gPj0gdCkgewogICAgICBicmVhazsKICAgIH0KICB9Cn0KI2VuZGlmCgojaWZkZWYgRklMVEVSCnZvaWQgdHJhbnNmb3JtQ29sb3IoaW5vdXQgdmVjNCBjb2xvciwgaW4gZmxvYXQgY29sb3JNYXRyaXhbMjBdKSB7CiAgZmxvYXQgciA9IGNvbG9yLnIsIGcgPSBjb2xvci5nLCBiID0gY29sb3IuYiwgYSA9IGNvbG9yLmE7CiAgY29sb3JbMF0gPSBjb2xvck1hdHJpeFswXSAqIHIgKyBjb2xvck1hdHJpeFsxXSAqIGcgKyBjb2xvck1hdHJpeFsyXSAqIGIgKyBjb2xvck1hdHJpeFszXSAqIGEgKyBjb2xvck1hdHJpeFs0XTsKICBjb2xvclsxXSA9IGNvbG9yTWF0cml4WzVdICogciArIGNvbG9yTWF0cml4WzZdICogZyArIGNvbG9yTWF0cml4WzddICogYiArIGNvbG9yTWF0cml4WzhdICogYSArIGNvbG9yTWF0cml4WzldOwogIGNvbG9yWzJdID0gY29sb3JNYXRyaXhbMTBdICogciArIGNvbG9yTWF0cml4WzExXSAqIGcgKyBjb2xvck1hdHJpeFsxMl0gKiBiICsgY29sb3JNYXRyaXhbMTNdICogYSArIGNvbG9yTWF0cml4WzE0XTsKICBjb2xvclszXSA9IGNvbG9yTWF0cml4WzE1XSAqIHIgKyBjb2xvck1hdHJpeFsxNl0gKiBnICsgY29sb3JNYXRyaXhbMTddICogYiArIGNvbG9yTWF0cml4WzE4XSAqIGEgKyBjb2xvck1hdHJpeFsxOV07Cn0KI2VuZGlmCgp2b2lkIG1haW4oKSB7CiAgdmVjNCBjb2xvciA9IHZDb2xvcjsKICBmbG9hdCBvcGFjaXR5ID0gYWJzKGZsYWdCYWNrZ3JvdW5kKTsKCiNpZmRlZiBHUkFESUVOVAogIGlmKHVfZ3JhZGllbnRUeXBlID4gMCAmJiBmbGFnQmFja2dyb3VuZCA+IDAuMCB8fCB1X2dyYWRpZW50VHlwZSA9PSAwICYmIGZsYWdCYWNrZ3JvdW5kIDw9IDAuMCkgewogICAgZ3JhZGllbnQoY29sb3IsIHZHcmFkaWVudFZlY3RvcjEsIHZHcmFkaWVudFZlY3RvcjIsIHVfY29sb3JTdGVwcyk7CiAgfQojZW5kaWYKCiAgaWYob3BhY2l0eSA8IDEuMCkgewogICAgY29sb3IuYSAqPSBvcGFjaXR5OwogIH0KCiNpZmRlZiBURVhUVVJFCiAgaWYoZmxhZ0JhY2tncm91bmQgPiAwLjApIHsKICAgIHZlYzMgdGV4Q29vcmQgPSB2VGV4dHVyZUNvb3JkOwoKICAgIGlmKHRleENvb3JkLnogPT0gMS4wKSB7CiAgICAgIHRleENvb3JkID0gZnJhY3QodGV4Q29vcmQpOwogICAgfQoKICAgIGlmKHRleENvb3JkLnggPD0gMS4wICYmIHRleENvb3JkLnggPj0gMC4wCiAgICAgICYmIHRleENvb3JkLnkgPD0gMS4wICYmIHRleENvb3JkLnkgPj0gMC4wKSB7CiAgICAgIGlmKHZTb3VyY2VSZWN0LnogPiAwLjApIHsKICAgICAgICB0ZXhDb29yZC54ID0gdlNvdXJjZVJlY3QueCArIHRleENvb3JkLnggKiB2U291cmNlUmVjdC56OwogICAgICAgIHRleENvb3JkLnkgPSAxLjAgLSAodlNvdXJjZVJlY3QueSArICgxLjAgLSB0ZXhDb29yZC55KSAqIHZTb3VyY2VSZWN0LncpOwogICAgICB9CiAgICAgIHZlYzQgdGV4Q29sb3IgPSB0ZXh0dXJlMkQodV90ZXhTYW1wbGVyLCB0ZXhDb29yZC54eSk7CiAgICAgIGZsb2F0IGFscGhhID0gdGV4Q29sb3IuYTsKICAgICAgaWYob3BhY2l0eSA8IDEuMCkgewogICAgICAgIHRleENvbG9yLmEgKj0gb3BhY2l0eTsKICAgICAgICBhbHBoYSAqPSBtaXgoMC40NjUsIDEuMCwgb3BhY2l0eSk7CiAgICAgIH0KICAgICAgLy8gY29sb3IgPSBtaXgoY29sb3IsIHRleENvbG9yLCB0ZXhDb2xvci5hKTsKICAgICAgY29sb3IucmdiID0gbWl4KGNvbG9yLnJnYiwgdGV4Q29sb3IucmdiLCBhbHBoYSk7CiAgICAgIC8vIGNvbG9yLnJnYiA9IG1peCh0ZXhDb2xvci5yZ2IsIGNvbG9yLnJnYiwgY29sb3IuYSk7CiAgICAgIGNvbG9yLnJnYiA9IG1peCh0ZXhDb2xvci5yZ2IsIGNvbG9yLnJnYiwgY2xhbXAoY29sb3IuYSAvIG1heCgwLjAwMDEsIHRleENvbG9yLmEpLCAwLjAsIDEuMCkpOwogICAgICBjb2xvci5hID0gdGV4Q29sb3IuYSArICgxLjAgLSB0ZXhDb2xvci5hKSAqIGNvbG9yLmE7CiAgICB9CiAgfQojZW5kaWYKCiNpZmRlZiBGSUxURVIKICBpZih1X2ZpbHRlckZsYWcgPiAwKSB7CiAgICB0cmFuc2Zvcm1Db2xvcihjb2xvciwgdV9jb2xvck1hdHJpeCk7CiAgfQojZW5kaWYKCiNpZmRlZiBDTElQUEFUSAogIGZsb2F0IGNsaXAgPSB0ZXh0dXJlMkQodV9jbGlwU2FtcGxlciwgdkNsaXBVVikucjsKICBjb2xvciAqPSBjbGlwOwojZW5kaWYKCiAgZ2xfRnJhZ0NvbG9yID0gY29sb3I7Cn1gfSxmdW5jdGlvbihoLGUsdCl7dC5yKGUpLGUuZGVmYXVsdD1gYXR0cmlidXRlIHZlYzMgYV92ZXJ0ZXhQb3NpdGlvbjsKYXR0cmlidXRlIHZlYzQgYV9jb2xvcjsKdmFyeWluZyB2ZWM0IHZDb2xvcjsKdmFyeWluZyBmbG9hdCBmbGFnQmFja2dyb3VuZDsKYXR0cmlidXRlIHZlYzMgYV90cmFuc2Zvcm0wOwphdHRyaWJ1dGUgdmVjMyBhX3RyYW5zZm9ybTE7CnVuaWZvcm0gdmVjMiB1X3Jlc29sdXRpb247CnVuaWZvcm0gbWF0MyB2aWV3TWF0cml4Owp1bmlmb3JtIG1hdDMgcHJvamVjdGlvbk1hdHJpeDsKCiNpZmRlZiBURVhUVVJFCmF0dHJpYnV0ZSB2ZWMzIGFfdmVydGV4VGV4dHVyZUNvb3JkOwp2YXJ5aW5nIHZlYzMgdlRleHR1cmVDb29yZDsKYXR0cmlidXRlIGZsb2F0IGFfZnJhbWVJbmRleDsKdmFyeWluZyBmbG9hdCBmcmFtZUluZGV4OwphdHRyaWJ1dGUgdmVjNCBhX3NvdXJjZVJlY3Q7CnZhcnlpbmcgdmVjNCB2U291cmNlUmVjdDsKI2VuZGlmCgojaWZkZWYgQ0xJUFBBVEgKYXR0cmlidXRlIHZlYzIgYV9jbGlwVVY7CnZhcnlpbmcgdmVjMiB2Q2xpcFVWOwojZW5kaWYKCiNpZmRlZiBDTE9VREZJTFRFUgphdHRyaWJ1dGUgdmVjNCBhX2NvbG9yQ2xvdWQwOwphdHRyaWJ1dGUgdmVjNCBhX2NvbG9yQ2xvdWQxOwphdHRyaWJ1dGUgdmVjNCBhX2NvbG9yQ2xvdWQyOwphdHRyaWJ1dGUgdmVjNCBhX2NvbG9yQ2xvdWQzOwphdHRyaWJ1dGUgdmVjNCBhX2NvbG9yQ2xvdWQ0Owp2YXJ5aW5nIHZlYzQgY29sb3JDbG91ZDA7CnZhcnlpbmcgdmVjNCBjb2xvckNsb3VkMTsKdmFyeWluZyB2ZWM0IGNvbG9yQ2xvdWQyOwp2YXJ5aW5nIHZlYzQgY29sb3JDbG91ZDM7CnZhcnlpbmcgdmVjNCBjb2xvckNsb3VkNDsKI2VuZGlmCgojaWZkZWYgQ0xPVURDT0xPUgphdHRyaWJ1dGUgdmVjNCBhX2ZpbGxDbG91ZENvbG9yOwphdHRyaWJ1dGUgdmVjNCBhX3N0cm9rZUNsb3VkQ29sb3I7CiNlbmRpZgoKI2lmZGVmIEdSQURJRU5UCnVuaWZvcm0gZmxvYXQgdV9yYWRpYWxHcmFkaWVudFZlY3Rvcls2XTsKdmFyeWluZyB2ZWMzIHZHcmFkaWVudFZlY3RvcjE7CnZhcnlpbmcgdmVjMyB2R3JhZGllbnRWZWN0b3IyOwojZW5kaWYKCnZvaWQgbWFpbigpIHsKICBnbF9Qb2ludFNpemUgPSAxLjA7CgogIG1hdDMgbW9kZWxNYXRyaXggPSBtYXQzKAogICAgYV90cmFuc2Zvcm0wLngsIGFfdHJhbnNmb3JtMS54LCAwLCAKICAgIGFfdHJhbnNmb3JtMC55LCBhX3RyYW5zZm9ybTEueSwgMCwKICAgIGFfdHJhbnNmb3JtMC56LCBhX3RyYW5zZm9ybTEueiwgMQogICk7CgogIHZlYzMgcG9zID0gcHJvamVjdGlvbk1hdHJpeCAqIHZpZXdNYXRyaXggKiBtb2RlbE1hdHJpeCAqIHZlYzMoYV92ZXJ0ZXhQb3NpdGlvbi54eSwgMS4wKTsKICBnbF9Qb3NpdGlvbiA9IHZlYzQocG9zLnh5LCAxLjAsIDEuMCk7CgojaWZkZWYgR1JBRElFTlQKICB2ZWMzIHZnMSA9IHZpZXdNYXRyaXggKiB2ZWMzKHVfcmFkaWFsR3JhZGllbnRWZWN0b3JbMF0sIHVfcmFkaWFsR3JhZGllbnRWZWN0b3JbMV0sIDEuMCk7CiAgdmVjMyB2ZzIgPSB2aWV3TWF0cml4ICogdmVjMyh1X3JhZGlhbEdyYWRpZW50VmVjdG9yWzNdLCB1X3JhZGlhbEdyYWRpZW50VmVjdG9yWzRdLCAxLjApOwogIGZsb2F0IGggPSB1X3Jlc29sdXRpb24ueTsKICB2ZzEueSA9IGggLSB2ZzEueTsKICB2ZzIueSA9IGggLSB2ZzIueTsKICB2R3JhZGllbnRWZWN0b3IxID0gdmVjMyh2ZzEueHksIHVfcmFkaWFsR3JhZGllbnRWZWN0b3JbMl0pOwogIHZHcmFkaWVudFZlY3RvcjIgPSB2ZWMzKHZnMi54eSwgdV9yYWRpYWxHcmFkaWVudFZlY3Rvcls1XSk7CiNlbmRpZgogIAogIGZsYWdCYWNrZ3JvdW5kID0gYV92ZXJ0ZXhQb3NpdGlvbi56OwoKI2lmZGVmIENMT1VEQ09MT1IKICBpZihmbGFnQmFja2dyb3VuZCA+IDAuMCkgewogICAgdkNvbG9yID0gbWl4KGFfY29sb3IsIGFfZmlsbENsb3VkQ29sb3IsIGFfZmlsbENsb3VkQ29sb3IuYSk7CiAgfSBlbHNlIHsKICAgIHZDb2xvciA9IG1peChhX2NvbG9yLCBhX3N0cm9rZUNsb3VkQ29sb3IsIGFfc3Ryb2tlQ2xvdWRDb2xvci5hKTsKICB9CiNlbHNlCiAgdkNvbG9yID0gYV9jb2xvcjsKI2VuZGlmCgojaWZkZWYgVEVYVFVSRQogIHZUZXh0dXJlQ29vcmQgPSBhX3ZlcnRleFRleHR1cmVDb29yZDsKICBmcmFtZUluZGV4ID0gYV9mcmFtZUluZGV4OwogIHZTb3VyY2VSZWN0ID0gYV9zb3VyY2VSZWN0OwojZW5kaWYKCiNpZmRlZiBDTElQUEFUSAogIHZDbGlwVVYgPSBhX2NsaXBVVjsKI2VuZGlmCgojaWZkZWYgQ0xPVURGSUxURVIKICBjb2xvckNsb3VkMCA9IGFfY29sb3JDbG91ZDA7CiAgY29sb3JDbG91ZDEgPSBhX2NvbG9yQ2xvdWQxOwogIGNvbG9yQ2xvdWQyID0gYV9jb2xvckNsb3VkMjsKICBjb2xvckNsb3VkMyA9IGFfY29sb3JDbG91ZDM7CiAgY29sb3JDbG91ZDQgPSBhX2NvbG9yQ2xvdWQ0OwojZW5kaWYKfWB9LGZ1bmN0aW9uKGgsZSx0KXt0LnIoZSksZS5kZWZhdWx0PWBwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDsKCnZhcnlpbmcgdmVjNCB2Q29sb3I7CnZhcnlpbmcgZmxvYXQgZmxhZ0JhY2tncm91bmQ7CgojaWZkZWYgVEVYVFVSRQp2YXJ5aW5nIGZsb2F0IGZyYW1lSW5kZXg7CnZhcnlpbmcgdmVjMyB2VGV4dHVyZUNvb3JkOwp2YXJ5aW5nIHZlYzQgdlNvdXJjZVJlY3Q7CiNlbmRpZgoKI2lmZGVmIENMSVBQQVRICnZhcnlpbmcgdmVjMiB2Q2xpcFVWOwojZW5kaWYKCiNpZmRlZiBGSUxURVIKdW5pZm9ybSBpbnQgdV9maWx0ZXJGbGFnOwp1bmlmb3JtIGZsb2F0IHVfY29sb3JNYXRyaXhbMjBdOwojZW5kaWYKCiNpZmRlZiBDTE9VREZJTFRFUgp2YXJ5aW5nIHZlYzQgY29sb3JDbG91ZDA7CnZhcnlpbmcgdmVjNCBjb2xvckNsb3VkMTsKdmFyeWluZyB2ZWM0IGNvbG9yQ2xvdWQyOwp2YXJ5aW5nIHZlYzQgY29sb3JDbG91ZDM7CnZhcnlpbmcgdmVjNCBjb2xvckNsb3VkNDsKI2VuZGlmCgojaWZkZWYgR1JBRElFTlQKdmFyeWluZyB2ZWMzIHZHcmFkaWVudFZlY3RvcjE7CnZhcnlpbmcgdmVjMyB2R3JhZGllbnRWZWN0b3IyOwp1bmlmb3JtIGZsb2F0IHVfY29sb3JTdGVwc1s0MF07CnVuaWZvcm0gaW50IHVfZ3JhZGllbnRUeXBlOwoKdm9pZCBncmFkaWVudChpbm91dCB2ZWM0IGNvbG9yLCB2ZWMzIGd2MSwgdmVjMyBndjIsIGZsb2F0IGNvbG9yU3RlcHNbNDBdKSB7CiAgZmxvYXQgdDsKICAvLyBjZW50ZXIgY2lyY2xlIHJhZGl1cwogIGZsb2F0IGNyID0gZ3YxLno7CiAgLy8gZm9jYWwgY2lyY2xlIHJhZGl1cwogIGZsb2F0IGZyID0gZ3YyLno7CgogIGlmKGNyID4gMC4wIHx8IGZyID4gMC4wKSB7CiAgICAvLyByYWRpYWwgZ3JhZGllbnQKICAgIHZlYzIgY2VudGVyID0gZ3YxLnh5OwogICAgdmVjMiBmb2NhbCA9IGd2Mi54eTsKICAgIGZsb2F0IHggPSBmb2NhbC54IC0gZ2xfRnJhZ0Nvb3JkLng7CiAgICBmbG9hdCB5ID0gZm9jYWwueSAtIGdsX0ZyYWdDb29yZC55OwogICAgZmxvYXQgZHggPSBmb2NhbC54IC0gY2VudGVyLng7CiAgICBmbG9hdCBkeSA9IGZvY2FsLnkgLSBjZW50ZXIueTsKICAgIGZsb2F0IGRyID0gY3IgLSBmcjsKICAgIGZsb2F0IGEgPSBkeCAqIGR4ICsgZHkgKiBkeSAtIGRyICogZHI7CiAgICBmbG9hdCBiID0gLTIuMCAqICh5ICogZHkgKyB4ICogZHggKyBmciAqIGRyKTsKICAgIGZsb2F0IGMgPSB4ICogeCArIHkgKiB5IC0gZnIgKiBmcjsKICAgIHQgPSAxLjAgLSAwLjUgKiAoMS4wIC8gYSkgKiAoLWIgKyBzcXJ0KGIgKiBiIC0gNC4wICogYSAqIGMpKTsKICB9IGVsc2UgewogICAgLy8gbGluZWFyIGdyYWRpZW50CiAgICB2ZWMyIHYxID0gZ2xfRnJhZ0Nvb3JkLnh5IC0gZ3YxLnh5OwogICAgdmVjMiB2MiA9IGd2Mi54eSAtIGd2MS54eTsKICAgIHQgPSAodjEueCAqIHYyLnggKyB2MS55ICogdjIueSkgLyAodjIueCAqIHYyLnggKyB2Mi55ICogdjIueSk7CiAgfQoKICB2ZWM0IGNvbG9yc1s4XTsKICBjb2xvcnNbMF0gPSB2ZWM0KGNvbG9yU3RlcHNbMV0sIGNvbG9yU3RlcHNbMl0sIGNvbG9yU3RlcHNbM10sIGNvbG9yU3RlcHNbNF0pOwogIGNvbG9yc1sxXSA9IHZlYzQoY29sb3JTdGVwc1s2XSwgY29sb3JTdGVwc1s3XSwgY29sb3JTdGVwc1s4XSwgY29sb3JTdGVwc1s5XSk7CiAgY29sb3JzWzJdID0gdmVjNChjb2xvclN0ZXBzWzExXSwgY29sb3JTdGVwc1sxMl0sIGNvbG9yU3RlcHNbMTNdLCBjb2xvclN0ZXBzWzE0XSk7CiAgY29sb3JzWzNdID0gdmVjNChjb2xvclN0ZXBzWzE2XSwgY29sb3JTdGVwc1sxN10sIGNvbG9yU3RlcHNbMThdLCBjb2xvclN0ZXBzWzE5XSk7CiAgY29sb3JzWzRdID0gdmVjNChjb2xvclN0ZXBzWzIxXSwgY29sb3JTdGVwc1syMl0sIGNvbG9yU3RlcHNbMjNdLCBjb2xvclN0ZXBzWzI0XSk7CiAgY29sb3JzWzVdID0gdmVjNChjb2xvclN0ZXBzWzI2XSwgY29sb3JTdGVwc1syN10sIGNvbG9yU3RlcHNbMjhdLCBjb2xvclN0ZXBzWzI5XSk7CiAgY29sb3JzWzZdID0gdmVjNChjb2xvclN0ZXBzWzMxXSwgY29sb3JTdGVwc1szMl0sIGNvbG9yU3RlcHNbMzNdLCBjb2xvclN0ZXBzWzM0XSk7CiAgY29sb3JzWzddID0gdmVjNChjb2xvclN0ZXBzWzM2XSwgY29sb3JTdGVwc1szN10sIGNvbG9yU3RlcHNbMzhdLCBjb2xvclN0ZXBzWzM5XSk7CiAgCiAgZmxvYXQgc3RlcHNbOF07CiAgc3RlcHNbMF0gPSBjb2xvclN0ZXBzWzBdOwogIHN0ZXBzWzFdID0gY29sb3JTdGVwc1s1XTsKICBzdGVwc1syXSA9IGNvbG9yU3RlcHNbMTBdOwogIHN0ZXBzWzNdID0gY29sb3JTdGVwc1sxNV07CiAgc3RlcHNbNF0gPSBjb2xvclN0ZXBzWzIwXTsKICBzdGVwc1s1XSA9IGNvbG9yU3RlcHNbMjVdOwogIHN0ZXBzWzZdID0gY29sb3JTdGVwc1szMF07CiAgc3RlcHNbN10gPSBjb2xvclN0ZXBzWzM1XTsKCiAgY29sb3IgPSBjb2xvcnNbMF07CiAgZm9yIChpbnQgaSA9IDE7IGkgPCA4OyBpKyspIHsKICAgIGlmIChzdGVwc1tpXSA8IDAuMCB8fCBzdGVwc1tpXSA+IDEuMCkgewogICAgICBicmVhazsKICAgIH0KICAgIGlmKHN0ZXBzW2ldID09IHN0ZXBzW2kgLSAxXSkgewogICAgICBjb2xvciA9IGNvbG9yc1tpXTsKICAgIH0gZWxzZSB7CiAgICAgIGNvbG9yID0gbWl4KGNvbG9yLCBjb2xvcnNbaV0sIGNsYW1wKCh0IC0gc3RlcHNbaSAtIDFdKSAvIChzdGVwc1tpXSAtIHN0ZXBzW2kgLSAxXSksIDAuMCwgMS4wKSk7CiAgICB9CiAgICBpZiAoc3RlcHNbaV0gPj0gdCkgewogICAgICBicmVhazsKICAgIH0KICB9Cn0KI2VuZGlmCgp2b2lkIHRyYW5zZm9ybUNvbG9yKGlub3V0IHZlYzQgY29sb3IsIGluIGZsb2F0IGNvbG9yTWF0cml4WzIwXSkgewogIGZsb2F0IHIgPSBjb2xvci5yLCBnID0gY29sb3IuZywgYiA9IGNvbG9yLmIsIGEgPSBjb2xvci5hOwogIGNvbG9yWzBdID0gY29sb3JNYXRyaXhbMF0gKiByICsgY29sb3JNYXRyaXhbMV0gKiBnICsgY29sb3JNYXRyaXhbMl0gKiBiICsgY29sb3JNYXRyaXhbM10gKiBhICsgY29sb3JNYXRyaXhbNF07CiAgY29sb3JbMV0gPSBjb2xvck1hdHJpeFs1XSAqIHIgKyBjb2xvck1hdHJpeFs2XSAqIGcgKyBjb2xvck1hdHJpeFs3XSAqIGIgKyBjb2xvck1hdHJpeFs4XSAqIGEgKyBjb2xvck1hdHJpeFs5XTsKICBjb2xvclsyXSA9IGNvbG9yTWF0cml4WzEwXSAqIHIgKyBjb2xvck1hdHJpeFsxMV0gKiBnICsgY29sb3JNYXRyaXhbMTJdICogYiArIGNvbG9yTWF0cml4WzEzXSAqIGEgKyBjb2xvck1hdHJpeFsxNF07CiAgY29sb3JbM10gPSBjb2xvck1hdHJpeFsxNV0gKiByICsgY29sb3JNYXRyaXhbMTZdICogZyArIGNvbG9yTWF0cml4WzE3XSAqIGIgKyBjb2xvck1hdHJpeFsxOF0gKiBhICsgY29sb3JNYXRyaXhbMTldOwp9CgojaWZkZWYgQ0xPVURGSUxURVIKdm9pZCBidWlsZENsb3VkQ29sb3IoaW5vdXQgZmxvYXQgY29sb3JDbG91ZE1hdHJpeFsyMF0pIHsKICBjb2xvckNsb3VkTWF0cml4WzBdID0gY29sb3JDbG91ZDBbMF07CiAgY29sb3JDbG91ZE1hdHJpeFsxXSA9IGNvbG9yQ2xvdWQxWzBdOwogIGNvbG9yQ2xvdWRNYXRyaXhbMl0gPSBjb2xvckNsb3VkMlswXTsKICBjb2xvckNsb3VkTWF0cml4WzNdID0gY29sb3JDbG91ZDNbMF07CiAgY29sb3JDbG91ZE1hdHJpeFs0XSA9IGNvbG9yQ2xvdWQ0WzBdOwoKICBjb2xvckNsb3VkTWF0cml4WzVdID0gY29sb3JDbG91ZDBbMV07CiAgY29sb3JDbG91ZE1hdHJpeFs2XSA9IGNvbG9yQ2xvdWQxWzFdOwogIGNvbG9yQ2xvdWRNYXRyaXhbN10gPSBjb2xvckNsb3VkMlsxXTsKICBjb2xvckNsb3VkTWF0cml4WzhdID0gY29sb3JDbG91ZDNbMV07CiAgY29sb3JDbG91ZE1hdHJpeFs5XSA9IGNvbG9yQ2xvdWQ0WzFdOwoKICBjb2xvckNsb3VkTWF0cml4WzEwXSA9IGNvbG9yQ2xvdWQwWzJdOwogIGNvbG9yQ2xvdWRNYXRyaXhbMTFdID0gY29sb3JDbG91ZDFbMl07CiAgY29sb3JDbG91ZE1hdHJpeFsxMl0gPSBjb2xvckNsb3VkMlsyXTsKICBjb2xvckNsb3VkTWF0cml4WzEzXSA9IGNvbG9yQ2xvdWQzWzJdOwogIGNvbG9yQ2xvdWRNYXRyaXhbMTRdID0gY29sb3JDbG91ZDRbMl07CgogIGNvbG9yQ2xvdWRNYXRyaXhbMTVdID0gY29sb3JDbG91ZDBbM107CiAgY29sb3JDbG91ZE1hdHJpeFsxNl0gPSBjb2xvckNsb3VkMVszXTsKICBjb2xvckNsb3VkTWF0cml4WzE3XSA9IGNvbG9yQ2xvdWQyWzNdOwogIGNvbG9yQ2xvdWRNYXRyaXhbMThdID0gY29sb3JDbG91ZDNbM107CiAgY29sb3JDbG91ZE1hdHJpeFsxOV0gPSBjb2xvckNsb3VkNFszXTsKfQojZW5kaWYKCnZvaWQgbWFpbigpIHsKICB2ZWM0IGNvbG9yID0gdkNvbG9yOwogIGZsb2F0IG9wYWNpdHkgPSBhYnMoZmxhZ0JhY2tncm91bmQpOwoKI2lmZGVmIEdSQURJRU5UCiAgaWYodV9ncmFkaWVudFR5cGUgPiAwICYmIGZsYWdCYWNrZ3JvdW5kID4gMC4wIHx8IHVfZ3JhZGllbnRUeXBlID09IDAgJiYgZmxhZ0JhY2tncm91bmQgPD0gMC4wKSB7CiAgICBncmFkaWVudChjb2xvciwgdkdyYWRpZW50VmVjdG9yMSwgdkdyYWRpZW50VmVjdG9yMiwgdV9jb2xvclN0ZXBzKTsKICB9CiNlbmRpZgoKICBpZihvcGFjaXR5IDwgMS4wKSB7CiAgICBjb2xvci5hICo9IG9wYWNpdHk7CiAgfQoKI2lmZGVmIFRFWFRVUkUKICBpZihmbGFnQmFja2dyb3VuZCA+IDAuMCkgewogICAgdmVjMyB0ZXhDb29yZCA9IHZUZXh0dXJlQ29vcmQ7CgogICAgaWYodGV4Q29vcmQueiA9PSAxLjApIHsKICAgICAgdGV4Q29vcmQgPSBmcmFjdCh0ZXhDb29yZCk7CiAgICB9CgogICAgaWYodGV4Q29vcmQueCA8PSAxLjAgJiYgdGV4Q29vcmQueCA+PSAwLjAKICAgICAgJiYgdGV4Q29vcmQueSA8PSAxLjAgJiYgdGV4Q29vcmQueSA+PSAwLjApIHsKICAgICAgaWYodlNvdXJjZVJlY3QueiA+IDAuMCkgewogICAgICAgIHRleENvb3JkLnggPSB2U291cmNlUmVjdC54ICsgdGV4Q29vcmQueCAqIHZTb3VyY2VSZWN0Lno7CiAgICAgICAgdGV4Q29vcmQueSA9IDEuMCAtICh2U291cmNlUmVjdC55ICsgKDEuMCAtIHRleENvb3JkLnkpICogdlNvdXJjZVJlY3Qudyk7CiAgICAgIH0KICAgICAgaWYoZnJhbWVJbmRleCA8IDAuMCkgewogICAgICAgIHZlYzQgdGV4Q29sb3IgPSB0ZXh0dXJlMkQodV90ZXhTYW1wbGVyLCB0ZXhDb29yZC54eSk7CiAgICAgICAgY29sb3IgPSBtaXgoY29sb3IsIHRleENvbG9yLCB0ZXhDb2xvci5hKTsKICAgICAgfSBlbHNlIHsKICAgICAgICBpbnQgaW5kZXggPSBpbnQoZmxvb3IoY2xhbXAoMC4wLCAxMS4wLCBmcmFtZUluZGV4KSkpOwogICAgICAgIHZlYzQgdGV4Q29sb3I7CiAgICAgICAgaWYoaW5kZXggPT0gMCkgdGV4Q29sb3IgPSB0ZXh0dXJlMkQodV90ZXhGcmFtZTAsIHRleENvb3JkLnh5KTsKICAgICAgICBlbHNlIGlmKGluZGV4ID09IDEpIHRleENvbG9yID0gdGV4dHVyZTJEKHVfdGV4RnJhbWUxLCB0ZXhDb29yZC54eSk7CiAgICAgICAgZWxzZSBpZihpbmRleCA9PSAyKSB0ZXhDb2xvciA9IHRleHR1cmUyRCh1X3RleEZyYW1lMiwgdGV4Q29vcmQueHkpOwogICAgICAgIGVsc2UgaWYoaW5kZXggPT0gMykgdGV4Q29sb3IgPSB0ZXh0dXJlMkQodV90ZXhGcmFtZTMsIHRleENvb3JkLnh5KTsKICAgICAgICBlbHNlIGlmKGluZGV4ID09IDQpIHRleENvbG9yID0gdGV4dHVyZTJEKHVfdGV4RnJhbWU0LCB0ZXhDb29yZC54eSk7CiAgICAgICAgZWxzZSBpZihpbmRleCA9PSA1KSB0ZXhDb2xvciA9IHRleHR1cmUyRCh1X3RleEZyYW1lNSwgdGV4Q29vcmQueHkpOwogICAgICAgIGVsc2UgaWYoaW5kZXggPT0gNikgdGV4Q29sb3IgPSB0ZXh0dXJlMkQodV90ZXhGcmFtZTYsIHRleENvb3JkLnh5KTsKICAgICAgICBlbHNlIGlmKGluZGV4ID09IDcpIHRleENvbG9yID0gdGV4dHVyZTJEKHVfdGV4RnJhbWU3LCB0ZXhDb29yZC54eSk7CiAgICAgICAgZWxzZSBpZihpbmRleCA9PSA4KSB0ZXhDb2xvciA9IHRleHR1cmUyRCh1X3RleEZyYW1lOCwgdGV4Q29vcmQueHkpOwogICAgICAgIGVsc2UgaWYoaW5kZXggPT0gOSkgdGV4Q29sb3IgPSB0ZXh0dXJlMkQodV90ZXhGcmFtZTksIHRleENvb3JkLnh5KTsKICAgICAgICBlbHNlIGlmKGluZGV4ID09IDEwKSB0ZXhDb2xvciA9IHRleHR1cmUyRCh1X3RleEZyYW1lMTAsIHRleENvb3JkLnh5KTsKICAgICAgICBlbHNlIHRleENvbG9yID0gdGV4dHVyZTJEKHVfdGV4RnJhbWUxMSwgdGV4Q29vcmQueHkpOwogICAgICAgIGZsb2F0IGFscGhhID0gdGV4Q29sb3IuYTsKICAgICAgICBpZihvcGFjaXR5IDwgMS4wKSB7CiAgICAgICAgICB0ZXhDb2xvci5hICo9IG9wYWNpdHk7CiAgICAgICAgICBhbHBoYSAqPSBtaXgoMC40NjUsIDEuMCwgb3BhY2l0eSk7CiAgICAgICAgfQogICAgICAgIC8vIGNvbG9yID0gbWl4KGNvbG9yLCB0ZXhDb2xvciwgdGV4Q29sb3IuYSk7CiAgICAgICAgY29sb3IucmdiID0gbWl4KGNvbG9yLnJnYiwgdGV4Q29sb3IucmdiLCBhbHBoYSk7CiAgICAgICAgLy8gY29sb3IucmdiID0gbWl4KHRleENvbG9yLnJnYiwgY29sb3IucmdiLCBjb2xvci5hKTsKICAgICAgICBjb2xvci5yZ2IgPSBtaXgodGV4Q29sb3IucmdiLCBjb2xvci5yZ2IsIGNsYW1wKGNvbG9yLmEgLyBtYXgoMC4wMDAxLCB0ZXhDb2xvci5hKSwgMC4wLCAxLjApKTsKICAgICAgICBjb2xvci5hID0gdGV4Q29sb3IuYSArICgxLjAgLSB0ZXhDb2xvci5hKSAqIGNvbG9yLmE7CiAgICAgIH0KICAgIH0KICB9CiNlbmRpZgoKI2lmZGVmIEZJTFRFUgogIGlmKHVfZmlsdGVyRmxhZyA+IDApIHsKICAgIHRyYW5zZm9ybUNvbG9yKGNvbG9yLCB1X2NvbG9yTWF0cml4KTsKICB9CiNlbmRpZgoKI2lmZGVmIENMT1VERklMVEVSCiAgZmxvYXQgY29sb3JDbG91ZE1hdHJpeFsyMF07CiAgYnVpbGRDbG91ZENvbG9yKGNvbG9yQ2xvdWRNYXRyaXgpOwogIHRyYW5zZm9ybUNvbG9yKGNvbG9yLCBjb2xvckNsb3VkTWF0cml4KTsKI2VuZGlmCgojaWZkZWYgQ0xJUFBBVEgKICBmbG9hdCBjbGlwID0gdGV4dHVyZTJEKHVfY2xpcFNhbXBsZXIsIHZDbGlwVVYpLnI7CiAgY29sb3IgKj0gY2xpcDsKI2VuZGlmCgogIGdsX0ZyYWdDb2xvciA9IGNvbG9yOwp9YH0sZnVuY3Rpb24oaCxlLHQpe3QucihlKSwoZnVuY3Rpb24ocixuKXt0LmQoZSwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIixmdW5jdGlvbigpe3JldHVybiBnfSksdC5kKGUsImNhbmNlbEFuaW1hdGlvbkZyYW1lIixmdW5jdGlvbigpe3JldHVybiB1fSksdCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIGQoKXtpZih0eXBlb2YgcGVyZm9ybWFuY2U8InUiJiZwZXJmb3JtYW5jZS5ub3cpcmV0dXJuIHBlcmZvcm1hbmNlLm5vdygpO2lmKHR5cGVvZiByPCJ1IiYmci5ocnRpbWUpe2NvbnN0W28sZl09ci5ocnRpbWUoKTtyZXR1cm4gbyoxZTMrZioxZS02fXJldHVybiBEYXRlLm5vdz9EYXRlLm5vdygpOm5ldyBEYXRlKCkuZ2V0VGltZSgpfWxldCBnLHU7dHlwZW9mIG48InUiJiZ0eXBlb2Ygbi5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU9PSJmdW5jdGlvbiI/KGc9bi5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUsdT1uLmNhbmNlbEFuaW1hdGlvbkZyYW1lKTooZz1mdW5jdGlvbihvKXtyZXR1cm4gc2V0VGltZW91dCgoKT0+e28oZCgpKX0sMTYpfSx1PWZ1bmN0aW9uKG8pe3JldHVybiBjbGVhclRpbWVvdXQobyl9KX0pLmNhbGwodGhpcyx0KDY5KSx0KDIyKSl9LGZ1bmN0aW9uKGgsZSl7dmFyIHQ9aC5leHBvcnRzPXt9LHIsbjtmdW5jdGlvbiBkKCl7dGhyb3cgbmV3IEVycm9yKCJzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkIil9ZnVuY3Rpb24gZygpe3Rocm93IG5ldyBFcnJvcigiY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkIil9KGZ1bmN0aW9uKCl7dHJ5e3R5cGVvZiBzZXRUaW1lb3V0PT0iZnVuY3Rpb24iP3I9c2V0VGltZW91dDpyPWR9Y2F0Y2h7cj1kfXRyeXt0eXBlb2YgY2xlYXJUaW1lb3V0PT0iZnVuY3Rpb24iP249Y2xlYXJUaW1lb3V0Om49Z31jYXRjaHtuPWd9fSkoKTtmdW5jdGlvbiB1KE0pe2lmKHI9PT1zZXRUaW1lb3V0KXJldHVybiBzZXRUaW1lb3V0KE0sMCk7aWYoKHI9PT1kfHwhcikmJnNldFRpbWVvdXQpcmV0dXJuIHI9c2V0VGltZW91dCxzZXRUaW1lb3V0KE0sMCk7dHJ5e3JldHVybiByKE0sMCl9Y2F0Y2h7dHJ5e3JldHVybiByLmNhbGwobnVsbCxNLDApfWNhdGNoe3JldHVybiByLmNhbGwodGhpcyxNLDApfX19ZnVuY3Rpb24gbyhNKXtpZihuPT09Y2xlYXJUaW1lb3V0KXJldHVybiBjbGVhclRpbWVvdXQoTSk7aWYoKG49PT1nfHwhbikmJmNsZWFyVGltZW91dClyZXR1cm4gbj1jbGVhclRpbWVvdXQsY2xlYXJUaW1lb3V0KE0pO3RyeXtyZXR1cm4gbihNKX1jYXRjaHt0cnl7cmV0dXJuIG4uY2FsbChudWxsLE0pfWNhdGNoe3JldHVybiBuLmNhbGwodGhpcyxNKX19fXZhciBmPVtdLHg9ITEsYyx2PS0xO2Z1bmN0aW9uIHAoKXsheHx8IWN8fCh4PSExLGMubGVuZ3RoP2Y9Yy5jb25jYXQoZik6dj0tMSxmLmxlbmd0aCYmYigpKX1mdW5jdGlvbiBiKCl7aWYoIXgpe3ZhciBNPXUocCk7eD0hMDtmb3IodmFyIGk9Zi5sZW5ndGg7aTspe2ZvcihjPWYsZj1bXTsrK3Y8aTspYyYmY1t2XS5ydW4oKTt2PS0xLGk9Zi5sZW5ndGh9Yz1udWxsLHg9ITEsbyhNKX19dC5uZXh0VGljaz1mdW5jdGlvbihNKXt2YXIgaT1uZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aC0xKTtpZihhcmd1bWVudHMubGVuZ3RoPjEpZm9yKHZhciBhPTE7YTxhcmd1bWVudHMubGVuZ3RoO2ErKylpW2EtMV09YXJndW1lbnRzW2FdO2YucHVzaChuZXcgRShNLGkpKSxmLmxlbmd0aD09PTEmJiF4JiZ1KGIpfTtmdW5jdGlvbiBFKE0saSl7dGhpcy5mdW49TSx0aGlzLmFycmF5PWl9RS5wcm90b3R5cGUucnVuPWZ1bmN0aW9uKCl7dGhpcy5mdW4uYXBwbHkobnVsbCx0aGlzLmFycmF5KX0sdC50aXRsZT0iYnJvd3NlciIsdC5icm93c2VyPSEwLHQuZW52PXt9LHQuYXJndj1bXSx0LnZlcnNpb249IiIsdC52ZXJzaW9ucz17fTtmdW5jdGlvbiB5KCl7fXQub249eSx0LmFkZExpc3RlbmVyPXksdC5vbmNlPXksdC5vZmY9eSx0LnJlbW92ZUxpc3RlbmVyPXksdC5yZW1vdmVBbGxMaXN0ZW5lcnM9eSx0LmVtaXQ9eSx0LnByZXBlbmRMaXN0ZW5lcj15LHQucHJlcGVuZE9uY2VMaXN0ZW5lcj15LHQubGlzdGVuZXJzPWZ1bmN0aW9uKE0pe3JldHVybltdfSx0LmJpbmRpbmc9ZnVuY3Rpb24oTSl7dGhyb3cgbmV3IEVycm9yKCJwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCIpfSx0LmN3ZD1mdW5jdGlvbigpe3JldHVybiIvIn0sdC5jaGRpcj1mdW5jdGlvbihNKXt0aHJvdyBuZXcgRXJyb3IoInByb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCIpfSx0LnVtYXNrPWZ1bmN0aW9uKCl7cmV0dXJuIDB9fSxmdW5jdGlvbihoLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBSfSk7dmFyIHI9dCgxKSxuPXQoNzEpLGQ9dCg3MyksZz10KDIxMyksdT10KDIxNCksbz10KDIxNSksZj10KDIxNik7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIHgoSSxQKXt2YXIgTD1PYmplY3Qua2V5cyhJKTtpZihPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKXt2YXIgRD1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKEkpO1AmJihEPUQuZmlsdGVyKGZ1bmN0aW9uKEMpe3JldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKEksQykuZW51bWVyYWJsZX0pKSxMLnB1c2guYXBwbHkoTCxEKX1yZXR1cm4gTH1mdW5jdGlvbiBjKEkpe2Zvcih2YXIgUD0xO1A8YXJndW1lbnRzLmxlbmd0aDtQKyspe3ZhciBMPWFyZ3VtZW50c1tQXSE9bnVsbD9hcmd1bWVudHNbUF06e307UCUyP3goT2JqZWN0KEwpLCEwKS5mb3JFYWNoKGZ1bmN0aW9uKEQpe3YoSSxELExbRF0pfSk6T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnM/T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoSSxPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhMKSk6eChPYmplY3QoTCkpLmZvckVhY2goZnVuY3Rpb24oRCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KEksRCxPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKEwsRCkpfSl9cmV0dXJuIEl9ZnVuY3Rpb24gdihJLFAsTCl7cmV0dXJuIFAgaW4gST9PYmplY3QuZGVmaW5lUHJvcGVydHkoSSxQLHt2YWx1ZTpMLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6SVtQXT1MLEl9Y29uc3QgcD1TeW1ib2wuZm9yKCJzcHJpdGVqc19jaGFuZ2VkQXR0cnMiKSxiPVN5bWJvbC5mb3IoInNwcml0ZWpzX2F0dHJpYnV0ZXMiKSxFPVN5bWJvbCgicmVzb2x1dGlvbiIpLHk9U3ltYm9sKCJhbmltYXRpb25zIiksTT1TeW1ib2woImV2ZW50TGlzdGVuZXJzIiksaT1TeW1ib2woImNhcHR1cmVFdmVudExpc3RlbmVycyIpLGE9U3ltYm9sKCJmaWx0ZXJzIikscz1TeW1ib2woImRpc3BsYXkiKSxsPVN5bWJvbCgicHJvZ3JhbSIpLE89U3ltYm9sKCJzaGFkZXJBdHRycyIpLEE9U3ltYm9sKCJ1bmlmb3JtcyIpO2NsYXNzIFJ7Y29uc3RydWN0b3IoUD17fSl7dGhpcy5hdHRyaWJ1dGVzPW5ldyB0aGlzLmNvbnN0cnVjdG9yLkF0dHIodGhpcyksdGhpc1tFXT17d2lkdGg6MzAwLGhlaWdodDoxNTB9LE9iamVjdC5hc3NpZ24odGhpcy5hdHRyaWJ1dGVzLFApLHRoaXNbeV09bmV3IFNldCx0aGlzW01dPXt9LHRoaXNbaV09e319Z2V0IGFuY2VzdG9ycygpe2xldCBQPXRoaXMucGFyZW50O2NvbnN0IEw9W107Zm9yKDtQOylMLnB1c2goUCksUD1QLnBhcmVudDtyZXR1cm4gTH1nZXQgYW5pbWF0aW9ucygpe3JldHVybiB0aGlzW3ldfWdldCBmaWx0ZXJzKCl7cmV0dXJuIHRoaXNbYV18fHRoaXMucGFyZW50JiZ0aGlzLnBhcmVudC5maWx0ZXJzfWdldCBpc1Zpc2libGUoKXtyZXR1cm4hMX1nZXQgbGF5ZXIoKXtyZXR1cm4gdGhpcy5wYXJlbnQ/dGhpcy5wYXJlbnQubGF5ZXI6bnVsbH1nZXQgbG9jYWxNYXRyaXgoKXtjb25zdCBQPXRoaXMudHJhbnNmb3JtTWF0cml4LHt4OkwseTpEfT10aGlzLmF0dHJpYnV0ZXM7cmV0dXJuIFBbNF0rPUwsUFs1XSs9RCxQfWdldCBvcGFjaXR5KCl7bGV0IFA9dGhpcy5hdHRyaWJ1dGVzLm9wYWNpdHk7cmV0dXJuIHRoaXMucGFyZW50JiZ0aGlzLnBhcmVudC5vcGFjaXR5IT1udWxsJiYoUCo9dGhpcy5wYXJlbnQub3BhY2l0eSksUH1nZXQgcGFyZW50Tm9kZSgpe3JldHVybiB0aGlzLnBhcmVudH1nZXQgbmV4dFNpYmxpbmcoKXtyZXR1cm4gdGhpcy5nZXROb2RlTmVhckJ5KDEpfWdldCBwcmV2aW91c1NpYmxpbmcoKXtyZXR1cm4gdGhpcy5nZXROb2RlTmVhckJ5KC0xKX1nZXQgcHJvZ3JhbSgpe3JldHVybiB0aGlzW2xdfWdldCByZW5kZXJlcigpe3JldHVybiB0aGlzLnBhcmVudD90aGlzLnBhcmVudC5yZW5kZXJlcjpudWxsfWdldCByZW5kZXJNYXRyaXgoKXtpZih0aGlzLl9fY2FjaGVSZW5kZXJNYXRyaXgpcmV0dXJuIHRoaXMuX19jYWNoZVJlbmRlck1hdHJpeDtsZXQgUD10aGlzLmxvY2FsTWF0cml4O2NvbnN0IEw9dGhpcy5wYXJlbnQ7aWYoTCl7Y29uc3QgRD1MLl9fY2FjaGVSZW5kZXJNYXRyaXh8fEwucmVuZGVyTWF0cml4O0QmJihQPXIubWF0MmQubXVsdGlwbHkoQXJyYXkub2YoMCwwLDAsMCwwLDApLEQsUCkpfXJldHVybiBQfWdldCB3b3JsZFNjYWxpbmcoKXtjb25zdCBQPXRoaXMucmVuZGVyTWF0cml4O3JldHVybltNYXRoLmh5cG90KFBbMF0sUFsxXSksTWF0aC5oeXBvdChQWzJdLFBbM10pXX1nZXQgd29ybGRSb3RhdGlvbigpe2NvbnN0IFA9dGhpcy5yZW5kZXJNYXRyaXg7cmV0dXJuIE1hdGguYXRhbjIoUFsxXSxQWzNdKX1nZXQgd29ybGRQb3NpdGlvbigpe2NvbnN0IFA9dGhpcy5yZW5kZXJNYXRyaXg7cmV0dXJuW1BbNF0sUFs1XV19Z2V0IHVuaWZvcm1zKCl7cmV0dXJuIHRoaXNbQV19Z2V0IGNsYXNzTmFtZSgpe3JldHVybiB0aGlzLmF0dHJpYnV0ZXMuY2xhc3NOYW1lfXNldCBjbGFzc05hbWUoUCl7dGhpcy5hdHRyaWJ1dGVzLmNsYXNzTmFtZT1QfWdldCBpZCgpe3JldHVybiB0aGlzLmF0dHJpYnV0ZXMuaWR9c2V0IGlkKFApe3RoaXMuYXR0cmlidXRlcy5pZD1QfWdldCBuYW1lKCl7cmV0dXJuIHRoaXMuYXR0cmlidXRlcy5uYW1lfXNldCBuYW1lKFApe3RoaXMuYXR0cmlidXRlcy5uYW1lPVB9Z2V0IHpJbmRleCgpe3JldHVybiB0aGlzLmF0dHJpYnV0ZXMuekluZGV4fXNldCB6SW5kZXgoUCl7dGhpcy5hdHRyaWJ1dGVzLnpJbmRleD1QfWdldCBtZXNoKCl7cmV0dXJuIG51bGx9Z2V0IHNoYWRlckF0dHJzKCl7cmV0dXJuIHRoaXNbT118fHt9fWFjdGl2YXRlQW5pbWF0aW9ucygpe2NvbnN0IFA9dGhpcy5sYXllcjtpZihQKXtjb25zdCBMPXRoaXNbeV07TC5mb3JFYWNoKEM9PntDLmJhc2VUaW1lbGluZT1QLnRpbWVsaW5lLEMucGxheSgpLEMuZmluaXNoZWQudGhlbigoKT0+e0wuZGVsZXRlKEMpfSl9KTtjb25zdCBEPXRoaXMuY2hpbGRyZW47RCYmRC5mb3JFYWNoKEM9PntDLmFjdGl2YXRlQW5pbWF0aW9ucyYmQy5hY3RpdmF0ZUFuaW1hdGlvbnMoKX0pfX1hZGRFdmVudExpc3RlbmVyKFAsTCxEPXt9KXtQPT09Im1vdXNld2hlZWwiJiYoUD0id2hlZWwiKSx0eXBlb2YgRD09ImJvb2xlYW4iJiYoRD17Y2FwdHVyZTpEfSk7Y29uc3R7Y2FwdHVyZTpDLG9uY2U6U309RCxCPUM/aTpNO3JldHVybiB0aGlzW0JdW1BdPXRoaXNbQl1bUF18fFtdLHRoaXNbQl1bUF0ucHVzaCh7bGlzdGVuZXI6TCxvbmNlOlN9KSx0aGlzfWFuaW1hdGUoUCxMKXtjb25zdCBEPW5ldyBkLmRlZmF1bHQodGhpcyxQLEwpO3JldHVybiB0aGlzLmVmZmVjdHMmJkQuYXBwbHlFZmZlY3RzKHRoaXMuZWZmZWN0cyksdGhpcy5sYXllciYmKEQuYmFzZVRpbWVsaW5lPXRoaXMubGF5ZXIudGltZWxpbmUsRC5wbGF5KCksRC5maW5pc2hlZC50aGVuKCgpPT57dGhpc1t5XS5kZWxldGUoRCl9KSksdGhpc1t5XS5hZGQoRCksRH1hdHRyKC4uLlApe2lmKFAubGVuZ3RoPT09MClyZXR1cm4gdGhpcy5hdHRyaWJ1dGVzW2JdO2lmKFAubGVuZ3RoPjEpe2xldFtMLERdPVA7cmV0dXJuIHR5cGVvZiBEPT0iZnVuY3Rpb24iJiYoRD1EKHRoaXMuYXR0cihMKSkpLHRoaXMuc2V0QXR0cmlidXRlKEwsRCksdGhpc31yZXR1cm4gdHlwZW9mIFBbMF09PSJzdHJpbmciP3RoaXMuZ2V0QXR0cmlidXRlKFBbMF0pOihPYmplY3QuYXNzaWduKHRoaXMuYXR0cmlidXRlcyxQWzBdKSx0aGlzKX1jbG9uZU5vZGUoKXtjb25zdCBQPW5ldyB0aGlzLmNvbnN0cnVjdG9yLEw9dGhpcy5hdHRyaWJ1dGVzW3BdO3JldHVybiBQLmF0dHIoTCksUH1jb25uZWN0KFAsTCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInBhcmVudCIse3ZhbHVlOlAsd3JpdGFibGU6ITEsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInpPcmRlciIse3ZhbHVlOkwsd3JpdGFibGU6ITEsY29uZmlndXJhYmxlOiEwfSksUC50aW1lbGluZSYmdGhpcy5hY3RpdmF0ZUFuaW1hdGlvbnMoKSx0aGlzLnNldFJlc29sdXRpb24oUC5nZXRSZXNvbHV0aW9uKCkpLHRoaXMuZm9yY2VVcGRhdGUoKSx0aGlzLmRpc3BhdGNoRXZlbnQoe3R5cGU6ImFwcGVuZCIsZGV0YWlsOntwYXJlbnQ6UCx6T3JkZXI6TH19KX1jb250YWlucyhQKXtmb3IoO1AmJnRoaXMhPT1QOylQPVAucGFyZW50O3JldHVybiEhUH1kZWFjdGl2YXRlQW5pbWF0aW9ucygpe3RoaXNbeV0uZm9yRWFjaChMPT5MLmNhbmNlbCgpKTtjb25zdCBQPXRoaXMuY2hpbGRyZW47UCYmUC5mb3JFYWNoKEw9PntMLmRlYWN0aXZhdGVBbmltYXRpb25zJiZMLmRlYWN0aXZhdGVBbmltYXRpb25zKCl9KX1kaXNjb25uZWN0KCl7Y29uc3R7cGFyZW50OlAsek9yZGVyOkx9PXRoaXM7ZGVsZXRlIHRoaXMucGFyZW50LGRlbGV0ZSB0aGlzLnpPcmRlcix0aGlzLmRlYWN0aXZhdGVBbmltYXRpb25zKCksdGhpcy5kaXNwYXRjaEV2ZW50KHt0eXBlOiJyZW1vdmUiLGRldGFpbDp7cGFyZW50OlAsek9yZGVyOkx9fSksUCYmUC5mb3JjZVVwZGF0ZSgpfWRpc3BhdGNoRXZlbnQoUCl7UCBpbnN0YW5jZW9mIHUuZGVmYXVsdHx8KFA9bmV3IHUuZGVmYXVsdChQKSksUC50YXJnZXQ9dGhpcztsZXQgTD1QLnR5cGU7TD09PSJtb3VzZXdoZWVsIiYmKEw9IndoZWVsIik7Y29uc3QgRD1bdGhpc107bGV0IEM9dGhpcy5wYXJlbnQ7Zm9yKDtQLmJ1YmJsZXMmJkM7KUQucHVzaChDKSxDPUMucGFyZW50O2ZvcihsZXQgUz1ELmxlbmd0aC0xO1M+PTA7Uy0tKXtjb25zdCBCPURbU10sdz1CW2ldJiZCW2ldW0xdO2lmKHcmJncubGVuZ3RoJiYoUC5jdXJyZW50VGFyZ2V0PUIsdy5mb3JFYWNoKCh7bGlzdGVuZXI6SCxvbmNlOkp9KT0+e0guY2FsbCh0aGlzLFApLEomJkQucmVtb3ZlRXZlbnRMaXN0ZW5lcihIKX0pLGRlbGV0ZSBQLmN1cnJlbnRUYXJnZXQpLCFQLmJ1YmJsZXMmJlAuY2FuY2VsQnViYmxlKWJyZWFrfWlmKCFQLmNhbmNlbEJ1YmJsZSlmb3IobGV0IFM9MDtTPEQubGVuZ3RoO1MrKyl7Y29uc3QgQj1EW1NdLHc9QltNXSYmQltNXVtMXTtpZih3JiZ3Lmxlbmd0aCYmKFAuY3VycmVudFRhcmdldD1CLHcuZm9yRWFjaCgoe2xpc3RlbmVyOkgsb25jZTpKfSk9PntILmNhbGwodGhpcyxQKSxKJiZELnJlbW92ZUV2ZW50TGlzdGVuZXIoSCl9KSxkZWxldGUgUC5jdXJyZW50VGFyZ2V0KSwhUC5idWJibGVzfHxQLmNhbmNlbEJ1YmJsZSlicmVha319ZGlzcGF0Y2hQb2ludGVyRXZlbnQoUCl7Y29uc3R7bGF5ZXJYOkwsbGF5ZXJZOkR9PVA7cmV0dXJuIHRoaXMuaXNQb2ludENvbGxpc2lvbihMLEQpPyh0aGlzLmRpc3BhdGNoRXZlbnQoUCksITApOiExfWRyYXcoUD1bXSl7Y29uc3QgTD10aGlzLm1lc2g7aWYoTCl7aWYoT2JqZWN0KG8uYXBwbHlGaWx0ZXJzKShMLHRoaXMuZmlsdGVycyksUC5wdXNoKEwpLHRoaXNbbF0pe0wuc2V0UHJvZ3JhbSh0aGlzW2xdKTtjb25zdCBEPXRoaXNbT107RCYmT2JqZWN0LmVudHJpZXMoRCkuZm9yRWFjaCgoW1MsQl0pPT57TC5zZXRBdHRyaWJ1dGUoUyxCKX0pO2NvbnN0IEM9dGhpc1tBXTtpZih0aGlzW0FdKXtjb25zdCBTPXt9O09iamVjdC5lbnRyaWVzKEMpLmZvckVhY2goKFtCLHddKT0+e3R5cGVvZiB3PT0iZnVuY3Rpb24iJiYodz13KHRoaXMsQikpLFNbQl09d30pLEwuc2V0VW5pZm9ybXMoUyl9fU9iamVjdChmLmRlZmF1bHQpKHRoaXMsTCl9cmV0dXJuIFB9Zm9yY2VVcGRhdGUoKXt0aGlzLnBhcmVudCYmdGhpcy5wYXJlbnQuZm9yY2VVcGRhdGUoKX1nZXRBdHRyaWJ1dGUoUCl7cmV0dXJuIHRoaXMuYXR0cmlidXRlc1tQXX1nZXRMaXN0ZW5lcnMoUCx7Y2FwdHVyZTpMPSExfT17fSl7cmV0dXJuWy4uLnRoaXNbTD9pOk1dW1BdfHxbXV19Z2V0Tm9kZU5lYXJCeShQPTEpe2lmKCF0aGlzLnBhcmVudClyZXR1cm4gbnVsbDtpZihQPT09MClyZXR1cm4gdGhpcztjb25zdCBMPXRoaXMucGFyZW50LmNoaWxkcmVuLEQ9TC5pbmRleE9mKHRoaXMpO3JldHVybiBMW0QrUF19Z2V0V29ybGRQb3NpdGlvbihQLEwpe2NvbnN0IEQ9dGhpcy5yZW5kZXJNYXRyaXgsQz1QKkRbMF0rTCpEWzJdK0RbNF0sUz1QKkRbMV0rTCpEWzNdK0RbNV07cmV0dXJuW0MsU119Z2V0T2Zmc2V0UG9zaXRpb24oUCxMKXtjb25zdCBEPXIubWF0MmQuaW52ZXJ0KEFycmF5Lm9mKDAsMCwwLDAsMCwwKSx0aGlzLnJlbmRlck1hdHJpeCksQz1QKkRbMF0rTCpEWzJdK0RbNF0sUz1QKkRbMV0rTCpEWzNdK0RbNV07cmV0dXJuW0MsU119Z2V0UmVzb2x1dGlvbigpe3JldHVybiBjKHt9LHRoaXNbRV0pfWlzUG9pbnRDb2xsaXNpb24oUCxMKXtpZighdGhpcy5tZXNoKXJldHVybiExO2NvbnN0IEQ9dGhpcy5hdHRyaWJ1dGVzLnBvaW50ZXJFdmVudHM7aWYoRD09PSJub25lInx8RCE9PSJhbGwiJiYhdGhpcy5pc1Zpc2libGUpcmV0dXJuITE7bGV0IEM9ImJvdGgiO3JldHVybiBEPT09InZpc2libGVGaWxsIiYmKEM9ImZpbGwiKSxEPT09InZpc2libGVTdHJva2UiJiYoQz0ic3Ryb2tlIiksdGhpcy5tZXNoLmlzUG9pbnRDb2xsaXNpb24oUCxMLEMpfW9uUHJvcGVydHlDaGFuZ2UoUCxMLEQpe1AhPT0iaWQiJiZQIT09Im5hbWUiJiZQIT09ImNsYXNzTmFtZSImJlAhPT0icG9pbnRlckV2ZW50cyImJlAhPT0icGFzc0V2ZW50cyImJnRoaXMuZm9yY2VVcGRhdGUoKSxQPT09ImZpbHRlciImJih0aGlzW2FdPU9iamVjdChvLnBhcnNlRmlsdGVyU3RyaW5nKShMKSksUD09PSJ6SW5kZXgiJiZ0aGlzLnBhcmVudCYmdGhpcy5wYXJlbnQucmVvcmRlcigpfXNldEF0dHJpYnV0ZShQLEwpe1A9PT0iYXR0cnMiJiZ0aGlzLmF0dHIoTCksdGhpcy5hdHRyaWJ1dGVzW1BdPUx9c2V0TW91c2VDYXB0dXJlKCl7dGhpcy5sYXllciYmKHRoaXMubGF5ZXIuX19tb3VzZUNhcHR1cmVkVGFyZ2V0PXRoaXMpfXNldFByb2dyYW0oUCl7dGhpc1tsXT1QLHRoaXMuZm9yY2VVcGRhdGUoKX1zZXRTaGFkZXJBdHRyaWJ1dGUoUCxMKXt0aGlzW09dPXRoaXNbT118fHt9LHRoaXNbT11bUF09TCx0aGlzLmZvcmNlVXBkYXRlKCl9c2V0VW5pZm9ybXMoUCl7dGhpc1tBXT10aGlzW0FdfHx7fSxPYmplY3QuYXNzaWduKHRoaXNbQV0sUCksdGhpcy5mb3JjZVVwZGF0ZSgpfXNldFJlc29sdXRpb24oe3dpZHRoOlAsaGVpZ2h0Okx9KXtjb25zdHt3aWR0aDpELGhlaWdodDpDfT10aGlzW0VdOyhEIT09UHx8QyE9PUwpJiYodGhpc1tFXT17d2lkdGg6UCxoZWlnaHQ6TH0sdGhpcy5mb3JjZVVwZGF0ZSgpLHRoaXMuZGlzcGF0Y2hFdmVudCh7dHlwZToicmVzb2x1dGlvbmNoYW5nZSIsZGV0YWlsOnt3aWR0aDpQLGhlaWdodDpMfX0pKX1zaG93KCl7dGhpcy5hdHRyaWJ1dGVzLmRpc3BsYXk9PT0ibm9uZSImJih0aGlzLmF0dHJpYnV0ZXMuZGlzcGxheT10aGlzW3NdfHwiIil9aGlkZSgpe3RoaXMuYXR0cmlidXRlcy5kaXNwbGF5IT09Im5vbmUiJiYodGhpc1tzXT10aGlzLmF0dHJpYnV0ZXMuZGlzcGxheSx0aGlzLmF0dHJpYnV0ZXMuZGlzcGxheT0ibm9uZSIpfXJlbGVhc2VNb3VzZUNhcHR1cmUoKXt0aGlzLmxheWVyJiZ0aGlzLmxheWVyLl9fbW91c2VDYXB0dXJlZFRhcmdldD09PXRoaXMmJih0aGlzLmxheWVyLl9fbW91c2VDYXB0dXJlZFRhcmdldD1udWxsKX1yZW1vdmUoKXtyZXR1cm4gdGhpcy5wYXJlbnQmJnRoaXMucGFyZW50LnJlbW92ZUNoaWxkPyh0aGlzLnBhcmVudC5yZW1vdmVDaGlsZCh0aGlzKSwhMCk6ITF9cmVtb3ZlQWxsTGlzdGVuZXJzKFAsTD17fSl7dHlwZW9mIEw9PSJib29sZWFuIiYmKEw9e2NhcHR1cmU6TH0pO2NvbnN0IEM9TC5jYXB0dXJlP2k6TTtyZXR1cm4gdGhpc1tDXVtQXSYmKHRoaXNbQ11bUF09W10pLHRoaXN9cmVtb3ZlQXR0cmlidXRlKFApe3RoaXMuc2V0QXR0cmlidXRlKFAsbnVsbCl9cmVtb3ZlRXZlbnRMaXN0ZW5lcihQLEwsRD17fSl7dHlwZW9mIEQ9PSJib29sZWFuIiYmKEQ9e2NhcHR1cmU6RH0pO2NvbnN0IFM9RC5jYXB0dXJlP2k6TTtpZih0aGlzW1NdW1BdKXtjb25zdCBCPXRoaXNbU11bUF07aWYoQilmb3IobGV0IHc9MDt3PEIubGVuZ3RoO3crKyl7Y29uc3R7bGlzdGVuZXI6SH09Qlt3XTtpZihIPT09TCl7dGhpc1tTXVtQXS5zcGxpY2UodywxKTticmVha319fXJldHVybiB0aGlzfXRyYW5zaXRpb24oUCxMPSJsaW5lYXIiKXtjb25zdCBEPXRoaXMsQz1TeW1ib2woImFuaW1hdGlvbiIpO0w9THx8ImxpbmVhciI7bGV0IFM9MDtyZXR1cm4gdHlwZW9mIFA9PSJvYmplY3QiJiYoUz1QLmRlbGF5fHwwLFA9UC5kdXJhdGlvbikse1tDXTpudWxsLGNhbmNlbChCPSExKXtjb25zdCB3PXRoaXNbQ107dyYmdy5jYW5jZWwoQil9LGVuZCgpe2NvbnN0IEI9dGhpc1tDXTtCJiYoQi5wbGF5U3RhdGU9PT0icnVubmluZyJ8fEIucGxheVN0YXRlPT09InBlbmRpbmciKSYmQi5maW5pc2goKX0scmV2ZXJzZSgpe2NvbnN0IEI9dGhpc1tDXTtpZihCKWlmKEIucGxheVN0YXRlPT09InJ1bm5pbmcifHxCLnBsYXlTdGF0ZT09PSJwZW5kaW5nIilCLnBsYXliYWNrUmF0ZT0tQi5wbGF5YmFja1JhdGU7ZWxzZXtjb25zdCB3PUIudGltaW5nLmRpcmVjdGlvbjtCLnRpbWluZy5kaXJlY3Rpb249dz09PSJyZXZlcnNlIj8ibm9ybWFsIjoicmV2ZXJzZSIsQi5wbGF5KCl9cmV0dXJuIEIuZmluaXNoZWR9LGF0dHIoQix3KXtyZXR1cm4gdGhpcy5lbmQoKSx0eXBlb2YgQj09InN0cmluZyImJihCPXtbQl06d30pLE9iamVjdC5lbnRyaWVzKEIpLmZvckVhY2goKFtILEpdKT0+e3R5cGVvZiBKPT0iZnVuY3Rpb24iJiYoQltIXT1KKEQuYXR0cihIKSkpfSksdGhpc1tDXT1ELmFuaW1hdGUoW0JdLHtkdXJhdGlvbjpQKjFlMyxkZWxheTpTKjFlMyxmaWxsOiJmb3J3YXJkcyIsZWFzaW5nOkx9KSx0aGlzW0NdLmZpbmlzaGVkfX19dXBkYXRlQ29udG91cnMoKXt9fXYoUiwiQXR0ciIsbi5kZWZhdWx0KSxnLmRlZmF1bHQucmVnaXN0ZXJOb2RlKFIsIm5vZGUiKX0sZnVuY3Rpb24oaCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gUn0pO3ZhciByPXQoMSksbj10KDEyKSxkPXQoNzIpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCBnPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZURlZmF1bHQiKSx1PVN5bWJvbC5mb3IoInNwcml0ZWpzX2RlY2xhcmVBbGlhcyIpLG89U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlIiksZj1TeW1ib2wuZm9yKCJzcHJpdGVqc19nZXRBdHRyaWJ1dGUiKSx4PVN5bWJvbC5mb3IoInNwcml0ZWpzX2F0dHJpYnV0ZXMiKSxjPVN5bWJvbC5mb3IoInNwcml0ZWpzX2NoYW5nZWRBdHRycyIpLHY9U3ltYm9sKCJzdWJqZWN0IikscD1TeW1ib2woImF0dHIiKSxiPVN5bWJvbCgiZGVmYXVsdCIpLEU9U3ltYm9sKCJhbGlhcyIpO2Z1bmN0aW9uIHkoSSxbUCxMXSl7bGV0IEQ9ci5tYXQyZC5mcm9tVmFsdWVzKDEsMCwwLDEsMCwwKTtyZXR1cm5bLi4uSV0uZm9yRWFjaCgoW0MsU10pPT57aWYoKFB8fEwpJiYoRD1yLm1hdDJkLnRyYW5zbGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCksRCxbUCxMXSkpLEM9PT0ibWF0cml4IilEPXIubWF0MmQubXVsdGlwbHkoRCxELFMpO2Vsc2UgaWYoQz09PSJvZmZzZXRUcmFuc2xhdGUiKURbNF0rPVNbMF0sRFs1XSs9U1sxXTtlbHNlIGlmKEM9PT0ib2Zmc2V0Um90YXRlIilEPXIubWF0MmQucm90YXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxELFMpO2Vsc2UgaWYoQz09PSJza2V3Iil7Y29uc3RbQix3XT1TO0Q9ci5tYXQyZC5tdWx0aXBseShELEQsci5tYXQyZC5mcm9tVmFsdWVzKDEsTWF0aC50YW4odyksTWF0aC50YW4oQiksMSwwLDApKX1lbHNlIHIubWF0MmRbQ10oRCxELFMpOyhQfHxMKSYmKEQ9ci5tYXQyZC50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDApLEQsWy1QLC1MXSkpfSksRH1jb25zdCBNPVN5bWJvbCgidHJhbnNmb3JtTWF0cml4IiksaT1TeW1ib2woInRyYW5zZm9ybXMiKSxhPVN5bWJvbCgiY2hhbmdlZEF0dHJzIikscz1TeW1ib2woImxhc3RDaGFuZ2VkQXR0ciIpLGw9U3ltYm9sKCJvZmZzZXRGaWd1cmUiKTtmdW5jdGlvbiBPKEksUCxMKXtjb25zdCBEPUlbcF1bUF07aWYoSVtvXShQLEwsITEpfHxJW3NdIT09UCl7Y29uc3QgUz1JW2ldO1MuaGFzKFApJiZTLmRlbGV0ZShQKSxMJiYoUD09PSJyb3RhdGUiJiYoTD1NYXRoLlBJKkwvMTgwKSxQPT09InNjYWxlIiYmKEw9TC5tYXAoQj0+TWF0aC5hYnMoQik+MWUtNT9COjEvQj4wPzFlLTU6LTFlLTUpKSxTLnNldChQLEwpKSxJW01dPW51bGwsSVt2XS5vblByb3BlcnR5Q2hhbmdlKFAsTCxELEkpfX1mdW5jdGlvbiBBKEkpe2NvbnN0IFA9SVtsXSxMPUkub2Zmc2V0RGlzdGFuY2UqUC5nZXRUb3RhbExlbmd0aCgpLEQ9UC5nZXRQb2ludEF0TGVuZ3RoKEwpO2lmKEQpe2NvbnN0IEM9SVtpXTtsZXQgUz1JLm9mZnNldFJvdGF0ZTtTPT09ImF1dG8iP1M9RC5hbmdsZTpTPT09InJldmVyc2UiP1M9TWF0aC5QSStELmFuZ2xlOlM9TWF0aC5QSSpTLzE4MCxDLnNldCgib2Zmc2V0Um90YXRlIixTKSxDLnNldCgib2Zmc2V0VHJhbnNsYXRlIixbRC54LEQueV0pLElbTV09bnVsbH19Y2xhc3MgUntzdGF0aWMgc2V0RGVmYXVsdChQLC4uLkwpe3JldHVybiBQW2ddKC4uLkwpfXN0YXRpYyBkZWNsYXJlQWxpYXMoUCwuLi5MKXtyZXR1cm4gUFt1XSguLi5MKX1zdGF0aWMgc2V0QXR0cmlidXRlKFAsLi4uTCl7cmV0dXJuIFBbb10oLi4uTCl9c3RhdGljIGdldEF0dHJpYnV0ZShQLC4uLkwpe3JldHVybiBQW2ZdKC4uLkwpfXN0YXRpYyBnZXRBdHRyaWJ1dGVzKFApe3JldHVybiBQW3hdfXN0YXRpYyBnZXRDaGFuZ2VkQXR0cmlidXRlcyhQKXtyZXR1cm4gUFtjXX1jb25zdHJ1Y3RvcihQKXt0aGlzW3ZdPVAsdGhpc1twXT17fSx0aGlzW01dPXIubWF0MmQuZnJvbVZhbHVlcygxLDAsMCwxLDAsMCksdGhpc1tpXT1uZXcgTWFwLHRoaXNbYl09e30sdGhpc1tFXT1bXSxPYmplY3QuZGVmaW5lUHJvcGVydHkoUCwidHJhbnNmb3JtTWF0cml4Iix7Z2V0OigpPT4odGhpc1tNXXx8KHRoaXNbTV09eSh0aGlzW2ldLHRoaXMudHJhbnNmb3JtT3JpZ2luKSksWy4uLnRoaXNbTV1dKX0pLHRoaXNbZ10oe2lkOiIiLG5hbWU6IiIsY2xhc3NOYW1lOiIiLHg6MCx5OjAsdHJhbnNmb3JtT3JpZ2luOlswLDBdLHRyYW5zZm9ybToiIix0cmFuc2xhdGU6WzAsMF0scm90YXRlOjAsc2NhbGU6WzEsMV0sc2tldzpbMCwwXSxvcGFjaXR5OjEsekluZGV4OjAsb2Zmc2V0UGF0aDp2b2lkIDAsb2Zmc2V0RGlzdGFuY2U6MCxvZmZzZXRSb3RhdGU6ImF1dG8iLHBvaW50ZXJFdmVudHM6InZpc2libGUiLGZpbHRlcjoibm9uZSIsZGlzcGxheToiIn0pLHRoaXNbdV0oImNsYXNzIiwicG9zIiksdGhpc1thXT1uZXcgU2V0LHRoaXNbbF09bmV3IG4uRmlndXJlMkQoe3NjYWxlOjUsc2ltcGxpZnk6MH0pfWdldFtjXSgpe2NvbnN0IFA9e307cmV0dXJuWy4uLnRoaXNbYV1dLmZvckVhY2goTD0+e1BbTF09dGhpc1twXVtMXX0pLFB9Z2V0W3hdKCl7Y29uc3QgUD1PYmplY3QuYXNzaWduKHt9LHRoaXNbcF0pO2ZvcihsZXQgTD0wO0w8dGhpc1tFXS5sZW5ndGg7TCsrKXtjb25zdCBEPXRoaXNbRV1bTF07UFtEXT10aGlzW0RdfXJldHVybiBQfVtnXShQKXtPYmplY3QuYXNzaWduKHRoaXNbYl0sUCksT2JqZWN0LmFzc2lnbih0aGlzW3BdLFApfVt1XSguLi5QKXt0aGlzW0VdLnB1c2goLi4uUCl9W29dKFAsTCxEPSEwKXtjb25zdCBDPXRoaXNbcF1bUF0sUz10aGlzW3ZdO3JldHVybiBMPT1udWxsJiYoTD10aGlzW2JdW1BdKSxPYmplY3QoZC5jb21wYXJlVmFsdWUpKEMsTCk/ITE6KHRoaXNbcF1bUF09TCx0aGlzW2FdLmhhcyhQKSYmdGhpc1thXS5kZWxldGUoUCksdGhpc1thXS5hZGQoUCksdGhpc1tzXT1QLEQmJlMub25Qcm9wZXJ0eUNoYW5nZShQLEwsQyx0aGlzKSwhMCl9W2ZdKFApe3JldHVybiB0aGlzW3BdW1BdfXNldCBpZChQKXt0aGlzW29dKCJpZCIsUCl9Z2V0IGlkKCl7cmV0dXJuIHRoaXNbZl0oImlkIil9c2V0IG5hbWUoUCl7dGhpc1tvXSgibmFtZSIsUCl9Z2V0IG5hbWUoKXtyZXR1cm4gdGhpc1tmXSgibmFtZSIpfXNldCBjbGFzc05hbWUoUCl7dGhpc1tvXSgiY2xhc3NOYW1lIixQKX1nZXQgY2xhc3NOYW1lKCl7cmV0dXJuIHRoaXNbZl0oImNsYXNzTmFtZSIpfXNldCBjbGFzcyhQKXt0aGlzLmNsYXNzTmFtZT1QfWdldCBjbGFzcygpe3JldHVybiB0aGlzLmNsYXNzTmFtZX1nZXQgeCgpe3JldHVybiB0aGlzW2ZdKCJ4Iil9c2V0IHgoUCl7dGhpc1tvXSgieCIsT2JqZWN0KGQudG9OdW1iZXIpKFApKX1nZXQgeSgpe3JldHVybiB0aGlzW2ZdKCJ5Iil9c2V0IHkoUCl7dGhpc1tvXSgieSIsT2JqZWN0KGQudG9OdW1iZXIpKFApKX1nZXQgcG9zKCl7cmV0dXJuW3RoaXMueCx0aGlzLnldfXNldCBwb3MoUCl7UD1PYmplY3QoZC50b0FycmF5KShQKSxBcnJheS5pc0FycmF5KFApfHwoUD1bUCxQXSksdGhpcy54PVBbMF0sdGhpcy55PVBbMV19Z2V0IHRyYW5zZm9ybSgpe3JldHVybiB0aGlzW2ZdKCJ0cmFuc2Zvcm0iKX1zZXQgdHJhbnNmb3JtKFApe2xldCBMPW51bGw7aWYoQXJyYXkuaXNBcnJheShQKSYmKEw9UCxQPWBtYXRyaXgoJHtQLm1hcChkLnRvTnVtYmVyKS5qb2luKCl9KWApLHR5cGVvZiBQPT0ic3RyaW5nIilQPVAucmVwbGFjZSgvXHMqLFxzKi9nLCIsIik7ZWxzZSBpZihQIT1udWxsKXRocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgdHJhbnNmb3JtIHZhbHVlLiIpO2NvbnN0IEQ9dGhpc1twXS50cmFuc2Zvcm07aWYodGhpc1tvXSgidHJhbnNmb3JtIixQLCExKSl7Y29uc3QgQz10aGlzW2ldO2lmKEMuaGFzKCJtYXRyaXgiKSYmQy5kZWxldGUoIm1hdHJpeCIpLEwpQy5zZXQoIm1hdHJpeCIsTCk7ZWxzZSBpZihQKXtjb25zdCBTPVAubWF0Y2goLyhtYXRyaXh8dHJhbnNsYXRlfHJvdGF0ZXxzY2FsZXxza2V3KVwoW14oKV0rXCkvZyk7aWYoUyl7bGV0IEI9ci5tYXQyZC5mcm9tVmFsdWVzKDEsMCwwLDEsMCwwKTtmb3IobGV0IHc9MDt3PFMubGVuZ3RoO3crKyl7Y29uc3QgSj1TW3ddLm1hdGNoKC9eKG1hdHJpeHx0cmFuc2xhdGV8cm90YXRlfHNjYWxlfHNrZXcpXCgoW14oKV0rKVwpLyk7aWYoSil7bGV0WyxxLFVdPUo7cT09PSJyb3RhdGUiP1U9TWF0aC5QSSpwYXJzZUZsb2F0KFUpLzE4MDpVPVUudHJpbSgpLnNwbGl0KC9bXHMsXSsvKS5tYXAoRz0+T2JqZWN0KGQudG9OdW1iZXIpKEcpKSxxPT09Im1hdHJpeCI/Qj1yLm1hdDJkLm11bHRpcGx5KEIsQixVKTpxPT09InNrZXciP0I9ci5tYXQyZC5tdWx0aXBseShCLEIsci5tYXQyZC5mcm9tVmFsdWVzKDEsTWF0aC50YW4oVVsxXSksTWF0aC50YW4oVVswXSksMSwwLDApKTpyLm1hdDJkW3FdKEIsQixVKSxDLnNldCgibWF0cml4IixCKX19fWVsc2UgdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCB0cmFuc2Zvcm0gdmFsdWUuIil9dGhpc1tNXT1udWxsLHRoaXNbdl0ub25Qcm9wZXJ0eUNoYW5nZSgidHJhbnNmb3JtIixQLEQsdGhpcyl9fWdldCB0cmFuc2Zvcm1PcmlnaW4oKXtyZXR1cm4gdGhpc1tmXSgidHJhbnNmb3JtT3JpZ2luIil9c2V0IHRyYW5zZm9ybU9yaWdpbihQKXtQPU9iamVjdChkLnRvQXJyYXkpKFAsITApLFAhPW51bGwmJiFBcnJheS5pc0FycmF5KFApJiYoUD1bUCxQXSksdGhpc1tvXSgidHJhbnNmb3JtT3JpZ2luIixQKSYmKHRoaXNbTV09bnVsbCl9Z2V0IHJvdGF0ZSgpe3JldHVybiB0aGlzW2ZdKCJyb3RhdGUiKX1zZXQgcm90YXRlKFApe08odGhpcywicm90YXRlIixQKX1nZXQgdHJhbnNsYXRlKCl7cmV0dXJuIHRoaXNbZl0oInRyYW5zbGF0ZSIpfXNldCB0cmFuc2xhdGUoUCl7UD1PYmplY3QoZC50b0FycmF5KShQLCEwKSxQIT1udWxsJiYhQXJyYXkuaXNBcnJheShQKSYmKFA9W1AsUF0pLE8odGhpcywidHJhbnNsYXRlIixQKX1nZXQgc2NhbGUoKXtyZXR1cm4gdGhpc1tmXSgic2NhbGUiKX1zZXQgc2NhbGUoUCl7UD1PYmplY3QoZC50b0FycmF5KShQLCEwKSxQIT1udWxsJiYhQXJyYXkuaXNBcnJheShQKSYmKFA9W1AsUF0pLE8odGhpcywic2NhbGUiLFApfWdldCBza2V3KCl7cmV0dXJuIHRoaXNbZl0oInNrZXciKX1zZXQgc2tldyhQKXtQPU9iamVjdChkLnRvQXJyYXkpKFAsITApLFAhPW51bGwmJiFBcnJheS5pc0FycmF5KFApJiYoUD1bUCxQXSksTyh0aGlzLCJza2V3IixQKX1nZXQgb3BhY2l0eSgpe3JldHVybiB0aGlzW2ZdKCJvcGFjaXR5Iil9c2V0IG9wYWNpdHkoUCl7UCE9bnVsbCYmKFA9TnVtYmVyKFApKSx0aGlzW29dKCJvcGFjaXR5IixQKX1nZXQgekluZGV4KCl7cmV0dXJuIHRoaXNbZl0oInpJbmRleCIpfXNldCB6SW5kZXgoUCl7UCE9bnVsbCYmKFA9TnVtYmVyKFApKSx0aGlzW29dKCJ6SW5kZXgiLFApfWdldCBvZmZzZXRQYXRoKCl7cmV0dXJuIHRoaXNbZl0oIm9mZnNldFBhdGgiKX1zZXQgb2Zmc2V0UGF0aChQKXt0aGlzW29dKCJvZmZzZXRQYXRoIixQKSYmKHRoaXNbbF0uYmVnaW5QYXRoKCksUCE9bnVsbCYmdGhpc1tsXS5hZGRQYXRoKFApLEEodGhpcykpfWdldCBvZmZzZXREaXN0YW5jZSgpe3JldHVybiB0aGlzW2ZdKCJvZmZzZXREaXN0YW5jZSIpfXNldCBvZmZzZXREaXN0YW5jZShQKXt0aGlzW29dKCJvZmZzZXREaXN0YW5jZSIsT2JqZWN0KGQudG9OdW1iZXIpKFApKSYmQSh0aGlzKX1nZXQgb2Zmc2V0Um90YXRlKCl7cmV0dXJuIHRoaXNbZl0oIm9mZnNldFJvdGF0ZSIpfXNldCBvZmZzZXRSb3RhdGUoUCl7dGhpc1tvXSgib2Zmc2V0Um90YXRlIixQKSxBKHRoaXMpfWdldCBwb2ludGVyRXZlbnRzKCl7cmV0dXJuIHRoaXNbZl0oInBvaW50ZXJFdmVudHMiKX1zZXQgcG9pbnRlckV2ZW50cyhQKXtpZihQIT1udWxsJiZQIT09Im5vbmUiJiZQIT09InZpc2libGUiJiZQIT09InZpc2libGVGaWxsIiYmUCE9PSJ2aXNpYmxlU3Ryb2tlIiYmUCE9PSJhbGwiKXRocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgcG9pbnRlckV2ZW50cyB0eXBlLiIpO3RoaXNbb10oInBvaW50ZXJFdmVudHMiLFApfWdldCBmaWx0ZXIoKXtyZXR1cm4gdGhpc1tmXSgiZmlsdGVyIil9c2V0IGZpbHRlcihQKXt0aGlzW29dKCJmaWx0ZXIiLFApfWdldCBkaXNwbGF5KCl7cmV0dXJuIHRoaXNbZl0oImRpc3BsYXkiKX1zZXQgZGlzcGxheShQKXt0aGlzW29dKCJkaXNwbGF5IixQKX1zZXQgb2Zmc2V0KFApe319fSxmdW5jdGlvbihoLGUsdCl7dC5yKGUpLHQuZChlLCJzaXplVG9QaXhlbCIsZnVuY3Rpb24oKXtyZXR1cm4gcn0pLHQuZChlLCJ0b1N0cmluZyIsZnVuY3Rpb24oKXtyZXR1cm4gbn0pLHQuZChlLCJ0b051bWJlciIsZnVuY3Rpb24oKXtyZXR1cm4gZH0pLHQuZChlLCJ0b0FycmF5IixmdW5jdGlvbigpe3JldHVybiBnfSksdC5kKGUsImNvbXBhcmVWYWx1ZSIsZnVuY3Rpb24oKXtyZXR1cm4gdX0pLHQoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiByKG8sZil7Y29uc3QgeD1vLnRyaW0oKS5tYXRjaCgvXihbXGQuXSspKHB4fHB0fHBjfGlufGNtfG1tfGVtfGV4fHJlbXxxfHZ3fHZofHZtYXh8dm1pbikkLyk7eD9vPXtzaXplOnBhcnNlRmxvYXQoeFsxXSksdW5pdDp4WzJdfTpvPXtzaXplOnBhcnNlRmxvYXQobyksdW5pdDoicHgifTtsZXR7c2l6ZTpjLHVuaXQ6dn09bztpZih2PT09InB0IiljLz0uNzU7ZWxzZSBpZih2PT09InBjIiljKj0xNjtlbHNlIGlmKHY9PT0iaW4iKWMqPTk2O2Vsc2UgaWYodj09PSJjbSIpYyo9OTYvMi41NDtlbHNlIGlmKHY9PT0ibW0iKWMqPTk2LzI1LjQ7ZWxzZSBpZih2PT09ImVtInx8dj09PSJyZW0ifHx2PT09ImV4Iil7aWYoIWYmJnR5cGVvZiBnZXRDb21wdXRlZFN0eWxlPT0iZnVuY3Rpb24iJiZ0eXBlb2YgZG9jdW1lbnQ8InUiKXtjb25zdCBwPWdldENvbXB1dGVkU3R5bGUoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KS5mb250U2l6ZTtwP2Y9cihwLDE2KTpmPTE2fWMqPWYsdj09PSJleCImJihjLz0yKX1lbHNlIGlmKHY9PT0icSIpYyo9OTYvMjUuNC80O2Vsc2UgaWYodj09PSJ2dyJ8fHY9PT0idmgiKXtpZih0eXBlb2YgZG9jdW1lbnQ8InUiKXtjb25zdCBwPXY9PT0idnciP3dpbmRvdy5pbm5lcldpZHRofHxkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGg6d2luZG93LmlubmVySGVpZ2h0fHxkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0O2MqPXAvMTAwfX1lbHNlIGlmKCh2PT09InZtYXgifHx2PT09InZtaW4iKSYmdHlwZW9mIGRvY3VtZW50PCJ1Iil7Y29uc3QgcD13aW5kb3cuaW5uZXJXaWR0aHx8ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoLGI9d2luZG93LmlubmVySGVpZ2h0fHxkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0O3Y9PT0idm1heCI/Yyo9TWF0aC5tYXgocCxiKS8xMDA6Yyo9TWF0aC5taW4ocCxiKS8xMDB9cmV0dXJuIGN9ZnVuY3Rpb24gbihvKXtyZXR1cm4gbz09bnVsbD9vOlN0cmluZyhvKX1mdW5jdGlvbiBkKG8pe2lmKG89PW51bGwpcmV0dXJuIG87aWYodHlwZW9mIG89PSJzdHJpbmciJiYobz1yKG8pKSwhTnVtYmVyLmlzRmluaXRlKG8pKXRocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgdmFsdWUiKTtyZXR1cm4gb31mdW5jdGlvbiBnKG8sZj0hMSl7cmV0dXJuIG89PT0iIj9udWxsOih0eXBlb2Ygbz09InN0cmluZyImJihvPW8uc3BsaXQoL1tccyxdKy9nKSksQXJyYXkuaXNBcnJheShvKSYmKGYmJihvPW8ubWFwKGQpKSxvLmxlbmd0aD09PTEpP29bMF06byl9ZnVuY3Rpb24gdShvLGYpe2lmKEFycmF5LmlzQXJyYXkobykmJkFycmF5LmlzQXJyYXkoZikpe2lmKG8ubGVuZ3RoIT09Zi5sZW5ndGgpcmV0dXJuITE7Zm9yKGxldCB4PTA7eDxvLmxlbmd0aDt4KyspaWYob1t4XSE9PWZbeF0pcmV0dXJuITE7cmV0dXJuITB9cmV0dXJuIG89PW51bGwmJmY9PW51bGx8fG89PT1mfX0sZnVuY3Rpb24oaCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gdn0pO3ZhciByPXQoNzQpLG49dCgzMiksZD10Lm4obiksZz10KDY4KSx1PXQoNzIpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBvKCl7cmV0dXJuIG89T2JqZWN0LmFzc2lnbnx8ZnVuY3Rpb24ocCl7Zm9yKHZhciBiPTE7Yjxhcmd1bWVudHMubGVuZ3RoO2IrKyl7dmFyIEU9YXJndW1lbnRzW2JdO2Zvcih2YXIgeSBpbiBFKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChFLHkpJiYocFt5XT1FW3ldKX1yZXR1cm4gcH0sby5hcHBseSh0aGlzLGFyZ3VtZW50cyl9ZnVuY3Rpb24gZihwKXtpZih0eXBlb2YgcD09InN0cmluZyIpe2lmKHA9cC50cmltKCksL15bMC05Ll0rJSQvLnRlc3QocCkpcmV0dXJuIHBhcnNlRmxvYXQocCkvMTAwO2lmKC9eKFtcZC5dKykocHh8cHR8cGN8aW58Y218bW18ZW18ZXh8cmVtfHF8dnd8dmh8dm1heHx2bWluKSQvLnRlc3QocCkpcmV0dXJuIE9iamVjdCh1LnNpemVUb1BpeGVsKShwKX1yZXR1cm4gcH1mdW5jdGlvbiB4KHAsYixFLHksTSl7cmV0dXJuIHR5cGVvZiBwPT0ic3RyaW5nIiYmKHA9ZCgpKHApKSx0eXBlb2YgYj09InN0cmluZyImJihiPWQoKShiKSksci5FZmZlY3RzLmRlZmF1bHQocCxiLEUseSxNKX1mdW5jdGlvbiBjKHAsYixFLHksTSl7cmV0dXJuIHIuRWZmZWN0cy5kZWZhdWx0KHAsYixFLHksTSl9ci5FZmZlY3RzLmRlZmF1bHQ9ZnVuY3Rpb24ocCxiLEUseSxNKXtyZXR1cm4gQXJyYXkuaXNBcnJheShwKSYmQXJyYXkuaXNBcnJheShiKT9wLm1hcCgoaSxhKT0+aSsoRS15KS8oTS15KSooYlthXS1pKSk6dHlwZW9mIHA9PSJudW1iZXIiJiZ0eXBlb2YgYj09Im51bWJlciI/cCsoRS15KS8oTS15KSooYi1wKTpFLXk+TS1FP2I6cH0sci5FZmZlY3RzLmZpbGxDb2xvcj14LHIuRWZmZWN0cy5zdHJva2VDb2xvcj14LHIuRWZmZWN0cy5iZ2NvbG9yPXgsci5FZmZlY3RzLmJvcmRlckNvbG9yPXgsci5FZmZlY3RzLnRleHQ9YztjbGFzcyB2IGV4dGVuZHMgci5BbmltYXRvcntjb25zdHJ1Y3RvcihiLEUseSl7Y29uc3QgTT1iLmF0dHIoKTtPYmplY3QuZW50cmllcyhNKS5mb3JFYWNoKChbaSxhXSk9PntNW2ldPXIuRWZmZWN0c1tpXT9hOmYoYSl9KSxFPUUubWFwKGk9PntsZXQgYT1vKHt9LGkpO2NvbnN0IHM9e307cmV0dXJuIE9iamVjdC5lbnRyaWVzKGEpLmZvckVhY2goKFtsLE9dKT0+e3NbbF09ci5FZmZlY3RzW2xdP086ZihPKX0pLHN9KSxzdXBlcihNLEUseSksdGhpcy50YXJnZXQ9Yix0aGlzLnNldHRlcj1mdW5jdGlvbihpLGEpe2EuYXR0cihpKX19Z2V0IHBsYXlTdGF0ZSgpe3JldHVybiB0aGlzLnRhcmdldC5wYXJlbnQ/c3VwZXIucGxheVN0YXRlOiJpZGxlIn1nZXQgZmluaXNoZWQoKXtyZXR1cm4gc3VwZXIuZmluaXNoZWQudGhlbigoKT0+e2NvbnN0IGI9dGhpcztyZXR1cm4gbmV3IFByb21pc2UoRT0+e2Z1bmN0aW9uIHkoKXtiLnNldHRlcihiLmZyYW1lLGIudGFyZ2V0KTtjb25zdCBNPWIucGxheVN0YXRlO009PT0iZmluaXNoZWQifHxNPT09ImlkbGUiPyhPYmplY3QoZy5jYW5jZWxBbmltYXRpb25GcmFtZSkoYi5yZXF1ZXN0SWQpLEUoKSk6T2JqZWN0KGcucmVxdWVzdEFuaW1hdGlvbkZyYW1lKSh5KX15KCl9KX0pfWZpbmlzaCgpe3N1cGVyLmZpbmlzaCgpLE9iamVjdChnLmNhbmNlbEFuaW1hdGlvbkZyYW1lKSh0aGlzLnJlcXVlc3RJZCksdGhpcy5zZXR0ZXIodGhpcy5mcmFtZSx0aGlzLnRhcmdldCl9cGxheSgpe2lmKCF0aGlzLnRhcmdldC5wYXJlbnR8fHRoaXMucGxheVN0YXRlPT09InJ1bm5pbmciKXJldHVybjtzdXBlci5wbGF5KCksdGhpcy5zZXR0ZXIodGhpcy5mcmFtZSx0aGlzLnRhcmdldCk7Y29uc3QgYj10aGlzO3RoaXMucmVhZHkudGhlbigoKT0+e2Iuc2V0dGVyKGIuZnJhbWUsYi50YXJnZXQpLGIucmVxdWVzdElkPU9iamVjdChnLnJlcXVlc3RBbmltYXRpb25GcmFtZSkoZnVuY3Rpb24gRSgpe2NvbnN0IHk9Yi50YXJnZXQ7aWYodHlwZW9mIGRvY3VtZW50PCJ1IiYmZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50JiZkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY29udGFpbnMmJnkubGF5ZXImJnkubGF5ZXIuY2FudmFzJiYhZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNvbnRhaW5zKHkubGF5ZXIuY2FudmFzKSl7Yi5jYW5jZWwoKTtyZXR1cm59Y29uc3QgTT1iLnBsYXlTdGF0ZTtiLnNldHRlcihiLmZyYW1lLGIudGFyZ2V0KSxNIT09ImlkbGUiJiYoTT09PSJydW5uaW5nIj9iLnJlcXVlc3RJZD1PYmplY3QoZy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpKEUpOihNPT09InBhdXNlZCJ8fE09PT0icGVuZGluZyImJmIudGltZWxpbmUuY3VycmVudFRpbWU8MCkmJmIucmVhZHkudGhlbigoKT0+e2Iuc2V0dGVyKGIuZnJhbWUsYi50YXJnZXQpLGIucmVxdWVzdElkPU9iamVjdChnLnJlcXVlc3RBbmltYXRpb25GcmFtZSkoRSl9KSl9KX0pfWNhbmNlbChiPSExKXtPYmplY3QoZy5jYW5jZWxBbmltYXRpb25GcmFtZSkodGhpcy5yZXF1ZXN0SWQpLGI/KHRoaXMuc2V0dGVyKHRoaXMuZnJhbWUsdGhpcy50YXJnZXQpLHN1cGVyLmNhbmNlbCgpKTooc3VwZXIuY2FuY2VsKCksdGhpcy5zZXR0ZXIodGhpcy5mcmFtZSx0aGlzLnRhcmdldCkpfX19LGZ1bmN0aW9uKGgsZSx0KXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksZS5UaW1lbGluZT1lLkVmZmVjdHM9ZS5FYXNpbmdzPWUuQW5pbWF0b3I9dm9pZCAwO3ZhciByPXQoNzUpLG49eChyKSxkPXQoMTg3KSxnPXgoZCksdT10KDE4OCksbz10KDE5MCksZj14KG8pO2Z1bmN0aW9uIHgoYyl7cmV0dXJuIGMmJmMuX19lc01vZHVsZT9jOntkZWZhdWx0OmN9fWUuQW5pbWF0b3I9Zi5kZWZhdWx0LGUuRWFzaW5ncz11LkVhc2luZ3MsZS5FZmZlY3RzPWcuZGVmYXVsdCxlLlRpbWVsaW5lPW4uZGVmYXVsdH0sZnVuY3Rpb24oaCxlLHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KTt2YXIgcj10KDc2KSxuPWkociksZD10KDEzMyksZz1pKGQpLHU9dCgxNDEpLG89aSh1KSxmPXQoMTY0KSx4PWkoZiksYz10KDE3MCksdj1pKGMpLHA9dCgxNzEpLGI9aShwKSxFPXQoMTc1KSx5PWkoRSksTT10KDE4Nik7ZnVuY3Rpb24gaShEKXtyZXR1cm4gRCYmRC5fX2VzTW9kdWxlP0Q6e2RlZmF1bHQ6RH19dmFyIGE9KDAsTS5jcmVhdGVOb3dUaW1lKSgpLHM9e29yaWdpblRpbWU6MCxwbGF5YmFja1JhdGU6MX0sbD0oMCx5LmRlZmF1bHQpKCJ0aW1lTWFyayIpLE89KDAseS5kZWZhdWx0KSgicGxheWJhY2tSYXRlIiksQT0oMCx5LmRlZmF1bHQpKCJ0aW1lcnMiKSxSPSgwLHkuZGVmYXVsdCkoIm9yaWdpblRpbWUiKSxJPSgwLHkuZGVmYXVsdCkoInNldFRpbWVyIiksUD0oMCx5LmRlZmF1bHQpKCJwYXJlbnQiKSxMPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gRChDLFMpeygwLHYuZGVmYXVsdCkodGhpcyxEKSxDIGluc3RhbmNlb2YgRCYmKFM9QyxDPXt9KSxDPSgwLHguZGVmYXVsdCkoe30scyxDKSxTJiYodGhpc1tQXT1TKTt2YXIgQj1DLm5vd3RpbWV8fGE7aWYoUylPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiZ2xvYmFsVGltZSIse2dldDpmdW5jdGlvbigpe3JldHVybiBTLmN1cnJlbnRUaW1lfX0pO2Vsc2V7dmFyIHc9QigpO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJnbG9iYWxUaW1lIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIEIoKS13fX0pfXRoaXNbbF09W3tnbG9iYWxUaW1lOnRoaXMuZ2xvYmFsVGltZSxsb2NhbFRpbWU6LUMub3JpZ2luVGltZSxlbnRyb3B5Oi1DLm9yaWdpblRpbWUscGxheWJhY2tSYXRlOkMucGxheWJhY2tSYXRlLGdsb2JhbEVudHJvcHk6MH1dLHRoaXNbUF0mJih0aGlzW2xdWzBdLmdsb2JhbEVudHJvcHk9dGhpc1tQXS5lbnRyb3B5KSx0aGlzW1JdPUMub3JpZ2luVGltZSx0aGlzW09dPUMucGxheWJhY2tSYXRlLHRoaXNbQV09bmV3IG8uZGVmYXVsdH1yZXR1cm4oMCxiLmRlZmF1bHQpKEQsW3trZXk6Im1hcmtUaW1lIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBTPWFyZ3VtZW50cy5sZW5ndGg+MCYmYXJndW1lbnRzWzBdIT09dm9pZCAwP2FyZ3VtZW50c1swXTp7fSxCPVMudGltZSx3PUI9PT12b2lkIDA/dGhpcy5jdXJyZW50VGltZTpCLEg9Uy5lbnRyb3B5LEo9SD09PXZvaWQgMD90aGlzLmVudHJvcHk6SCxxPVMucGxheWJhY2tSYXRlLFU9cT09PXZvaWQgMD90aGlzLnBsYXliYWNrUmF0ZTpxLEc9e2dsb2JhbFRpbWU6dGhpcy5nbG9iYWxUaW1lLGxvY2FsVGltZTp3LGVudHJvcHk6SixwbGF5YmFja1JhdGU6VSxnbG9iYWxFbnRyb3B5OnRoaXMuZ2xvYmFsRW50cm9weX07dGhpc1tsXS5wdXNoKEcpfX0se2tleToiZm9yayIsdmFsdWU6ZnVuY3Rpb24oUyl7cmV0dXJuIG5ldyBEKFMsdGhpcyl9fSx7a2V5OiJzZWVrR2xvYmFsVGltZSIsdmFsdWU6ZnVuY3Rpb24oUyl7dmFyIEI9dGhpcy5zZWVrVGltZU1hcmsoUyksdz10aGlzW2xdW0JdLEg9dy5lbnRyb3B5LEo9dy5wbGF5YmFja1JhdGUscT13Lmdsb2JhbFRpbWU7cmV0dXJuIHErKFMtSCkvTWF0aC5hYnMoSil9fSx7a2V5OiJzZWVrTG9jYWxUaW1lIix2YWx1ZTpmdW5jdGlvbihTKXt2YXIgQj10aGlzLnNlZWtUaW1lTWFyayhTKSx3PXRoaXNbbF1bQl0sSD13LmxvY2FsVGltZSxKPXcuZW50cm9weSxxPXcucGxheWJhY2tSYXRlO3JldHVybiBxPjA/SCsoUy1KKTpILShTLUopfX0se2tleToic2Vla1RpbWVNYXJrIix2YWx1ZTpmdW5jdGlvbihTKXt2YXIgQj10aGlzW2xdLHc9MCxIPUIubGVuZ3RoLTE7aWYoUzw9Qlt3XS5lbnRyb3B5KXJldHVybiB3O2lmKFM+PUJbSF0uZW50cm9weSlyZXR1cm4gSDtmb3IodmFyIEo9TWF0aC5mbG9vcigodytIKS8yKTtKPncmJko8SDspe2lmKFM9PT1CW0pdLmVudHJvcHkpcmV0dXJuIEo7UzxCW0pdLmVudHJvcHk/SD1KOlM+QltKXS5lbnRyb3B5JiYodz1KKSxKPU1hdGguZmxvb3IoKHcrSCkvMil9cmV0dXJuIHd9fSx7a2V5OiJ1cGRhdGVUaW1lcnMiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIFM9dGhpcyxCPVtdLmNvbmNhdCgoMCxnLmRlZmF1bHQpKHRoaXNbQV0pKTtCLmZvckVhY2goZnVuY3Rpb24odyl7dmFyIEg9KDAsbi5kZWZhdWx0KSh3LDIpLEo9SFswXSxxPUhbMV07U1tJXShxLmhhbmRsZXIscS50aW1lLEopfSl9fSx7a2V5OiJjbGVhclRpbWVvdXQiLHZhbHVlOmZ1bmN0aW9uKEMpe2Z1bmN0aW9uIFMoQil7cmV0dXJuIEMuYXBwbHkodGhpcyxhcmd1bWVudHMpfXJldHVybiBTLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIEMudG9TdHJpbmcoKX0sU30oZnVuY3Rpb24oQyl7dmFyIFM9dGhpc1tBXS5nZXQoQyk7UyYmUy50aW1lcklEIT1udWxsJiYodGhpc1tQXT90aGlzW1BdLmNsZWFyVGltZW91dChTLnRpbWVySUQpOmNsZWFyVGltZW91dChTLnRpbWVySUQpKSx0aGlzW0FdLmRlbGV0ZShDKX0pfSx7a2V5OiJjbGVhckludGVydmFsIix2YWx1ZTpmdW5jdGlvbihTKXtyZXR1cm4gdGhpcy5jbGVhclRpbWVvdXQoUyl9fSx7a2V5OiJjbGVhciIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgUz10aGlzLEI9dGhpc1tBXTtbXS5jb25jYXQoKDAsZy5kZWZhdWx0KShCLmtleXMoKSkpLmZvckVhY2goZnVuY3Rpb24odyl7Uy5jbGVhclRpbWVvdXQodyl9KX19LHtrZXk6InNldFRpbWVvdXQiLHZhbHVlOmZ1bmN0aW9uKFMpe3ZhciBCPWFyZ3VtZW50cy5sZW5ndGg+MSYmYXJndW1lbnRzWzFdIT09dm9pZCAwP2FyZ3VtZW50c1sxXTp7ZGVsYXk6MH07cmV0dXJuIHRoaXNbSV0oUyxCKX19LHtrZXk6InNldEludGVydmFsIix2YWx1ZTpmdW5jdGlvbihTKXt2YXIgQj1hcmd1bWVudHMubGVuZ3RoPjEmJmFyZ3VtZW50c1sxXSE9PXZvaWQgMD9hcmd1bWVudHNbMV06e2RlbGF5OjB9LHc9dGhpcyxIPXRoaXNbSV0oZnVuY3Rpb24gSigpe3dbSV0oSixCLEgpLFMoKX0sQik7cmV0dXJuIEh9fSx7a2V5OkksdmFsdWU6ZnVuY3Rpb24oUyxCKXt2YXIgdz10aGlzLEg9YXJndW1lbnRzLmxlbmd0aD4yJiZhcmd1bWVudHNbMl0hPT12b2lkIDA/YXJndW1lbnRzWzJdOigwLHkuZGVmYXVsdCkoInRpbWVySUQiKTtCPSgwLE0uZm9ybWF0RGVsYXkpKEIpO3ZhciBKPXRoaXNbQV0uZ2V0KEgpLHE9dm9pZCAwLFU9bnVsbCxHPXZvaWQgMCxaPXZvaWQgMDtKPyh0aGlzLmNsZWFyVGltZW91dChIKSxCLmlzRW50cm9weT9xPShCLmRlbGF5LSh0aGlzLmVudHJvcHktSi5zdGFydEVudHJvcHkpKS9NYXRoLmFicyh0aGlzLnBsYXliYWNrUmF0ZSk6cT0oQi5kZWxheS0odGhpcy5jdXJyZW50VGltZS1KLnN0YXJ0VGltZSkpL3RoaXMucGxheWJhY2tSYXRlLEc9Si5zdGFydFRpbWUsWj1KLnN0YXJ0RW50cm9weSk6KHE9Qi5kZWxheS8oQi5pc0VudHJvcHk/TWF0aC5hYnModGhpcy5wbGF5YmFja1JhdGUpOnRoaXMucGxheWJhY2tSYXRlKSxHPXRoaXMuY3VycmVudFRpbWUsWj10aGlzLmVudHJvcHkpO3ZhciB0dD10aGlzW1BdLF89dHQ/dHQuc2V0VGltZW91dC5iaW5kKHR0KTpzZXRUaW1lb3V0LHN0PUIuaGVhZGluZztyZXR1cm4hdHQmJnN0PT09ITEmJnE8MCYmKHE9MS8wKSwoaXNGaW5pdGUocSl8fHR0KSYmKHE9TWF0aC5jZWlsKHEpLF8hPT1zZXRUaW1lb3V0JiYocT17ZGVsYXk6cSxoZWFkaW5nOnN0fSksVT1fKGZ1bmN0aW9uKCl7d1tBXS5kZWxldGUoSCksUygpfSxxKSksdGhpc1tBXS5zZXQoSCx7dGltZXJJRDpVLGhhbmRsZXI6Uyx0aW1lOkIsc3RhcnRUaW1lOkcsc3RhcnRFbnRyb3B5Olp9KSxIfX0se2tleToicGFyZW50IixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc1tQXX19LHtrZXk6Imxhc3RUaW1lTWFyayIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXNbbF1bdGhpc1tsXS5sZW5ndGgtMV19fSx7a2V5OiJjdXJyZW50VGltZSIsZ2V0OmZ1bmN0aW9uKCl7dmFyIFM9dGhpcy5sYXN0VGltZU1hcmssQj1TLmxvY2FsVGltZSx3PVMuZ2xvYmFsVGltZTtyZXR1cm4gQisodGhpcy5nbG9iYWxUaW1lLXcpKnRoaXMucGxheWJhY2tSYXRlfSxzZXQ6ZnVuY3Rpb24oUyl7dmFyIEI9dGhpcyx3PXRoaXMuY3VycmVudFRpbWUsSD1TLEo9dGhpc1tBXTt0aGlzLm1hcmtUaW1lKHt0aW1lOlN9KSxbXS5jb25jYXQoKDAsZy5kZWZhdWx0KShKKSkuZm9yRWFjaChmdW5jdGlvbihxKXt2YXIgVT0oMCxuLmRlZmF1bHQpKHEsMiksRz1VWzBdLFo9VVsxXTtpZihKLmhhcyhHKSl7dmFyIHR0PVoudGltZSxfPXR0LmlzRW50cm9weSxzdD10dC5kZWxheSxrPXR0LmhlYWRpbmcsaHQ9Wi5oYW5kbGVyLGZ0PVouc3RhcnRUaW1lO2lmKF8pc3Q9PT0wJiYoaHQoKSxCLmNsZWFyVGltZW91dChHKSk7ZWxzZXt2YXIgVz1mdCtzdDsoc3Q9PT0wfHxrIT09ITEmJihILXcpKnN0PD0wfHx3PD1XJiZXPD1IfHx3Pj1XJiZXPj1IKSYmKGh0KCksQi5jbGVhclRpbWVvdXQoRykpfX19KSx0aGlzLnVwZGF0ZVRpbWVycygpfX0se2tleToiZW50cm9weSIsZ2V0OmZ1bmN0aW9uKCl7dmFyIFM9dGhpcy5sYXN0VGltZU1hcmssQj1TLmVudHJvcHksdz1TLmdsb2JhbEVudHJvcHk7cmV0dXJuIEIrTWF0aC5hYnMoKHRoaXMuZ2xvYmFsRW50cm9weS13KSp0aGlzLnBsYXliYWNrUmF0ZSl9LHNldDpmdW5jdGlvbihTKXtpZih0aGlzLmVudHJvcHk+Uyl7dmFyIEI9dGhpcy5zZWVrVGltZU1hcmsoUyk7dGhpc1tsXS5sZW5ndGg9QisxfXRoaXMubWFya1RpbWUoe2VudHJvcHk6U30pLHRoaXMudXBkYXRlVGltZXJzKCl9fSx7a2V5OiJnbG9iYWxFbnRyb3B5IixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc1tQXT90aGlzW1BdLmVudHJvcHk6dGhpcy5nbG9iYWxUaW1lfX0se2tleToicGxheWJhY2tSYXRlIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc1tPXX0sc2V0OmZ1bmN0aW9uKFMpe1MhPT10aGlzLnBsYXliYWNrUmF0ZSYmKHRoaXMubWFya1RpbWUoe3BsYXliYWNrUmF0ZTpTfSksdGhpc1tPXT1TLHRoaXMudXBkYXRlVGltZXJzKCkpfX0se2tleToicGF1c2VkIixnZXQ6ZnVuY3Rpb24oKXtpZih0aGlzLnBsYXliYWNrUmF0ZT09PTApcmV0dXJuITA7Zm9yKHZhciBTPXRoaXMucGFyZW50O1M7KXtpZihTLnBsYXliYWNrUmF0ZT09PTApcmV0dXJuITA7Uz1TLnBhcmVudH1yZXR1cm4hMX19XSksRH0oKTtlLmRlZmF1bHQ9TH0sZnVuY3Rpb24oaCxlLHQpe2UuX19lc01vZHVsZT0hMDt2YXIgcj10KDc3KSxuPXUociksZD10KDEyOSksZz11KGQpO2Z1bmN0aW9uIHUobyl7cmV0dXJuIG8mJm8uX19lc01vZHVsZT9vOntkZWZhdWx0Om99fWUuZGVmYXVsdD1mdW5jdGlvbigpe2Z1bmN0aW9uIG8oZix4KXt2YXIgYz1bXSx2PSEwLHA9ITEsYj12b2lkIDA7dHJ5e2Zvcih2YXIgRT0oMCxnLmRlZmF1bHQpKGYpLHk7ISh2PSh5PUUubmV4dCgpKS5kb25lKSYmKGMucHVzaCh5LnZhbHVlKSwhKHgmJmMubGVuZ3RoPT09eCkpO3Y9ITApO31jYXRjaChNKXtwPSEwLGI9TX1maW5hbGx5e3RyeXshdiYmRS5yZXR1cm4mJkUucmV0dXJuKCl9ZmluYWxseXtpZihwKXRocm93IGJ9fXJldHVybiBjfXJldHVybiBmdW5jdGlvbihmLHgpe2lmKEFycmF5LmlzQXJyYXkoZikpcmV0dXJuIGY7aWYoKDAsbi5kZWZhdWx0KShPYmplY3QoZikpKXJldHVybiBvKGYseCk7dGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZSIpfX0oKX0sZnVuY3Rpb24oaCxlLHQpe2guZXhwb3J0cz17ZGVmYXVsdDp0KDc4KSxfX2VzTW9kdWxlOiEwfX0sZnVuY3Rpb24oaCxlLHQpe3QoNzkpLHQoMTI1KSxoLmV4cG9ydHM9dCgxMjcpfSxmdW5jdGlvbihoLGUsdCl7dCg4MCk7Zm9yKHZhciByPXQoOTEpLG49dCg5NSksZD10KDgzKSxnPXQoMTIyKSgidG9TdHJpbmdUYWciKSx1PSJDU1NSdWxlTGlzdCxDU1NTdHlsZURlY2xhcmF0aW9uLENTU1ZhbHVlTGlzdCxDbGllbnRSZWN0TGlzdCxET01SZWN0TGlzdCxET01TdHJpbmdMaXN0LERPTVRva2VuTGlzdCxEYXRhVHJhbnNmZXJJdGVtTGlzdCxGaWxlTGlzdCxIVE1MQWxsQ29sbGVjdGlvbixIVE1MQ29sbGVjdGlvbixIVE1MRm9ybUVsZW1lbnQsSFRNTFNlbGVjdEVsZW1lbnQsTWVkaWFMaXN0LE1pbWVUeXBlQXJyYXksTmFtZWROb2RlTWFwLE5vZGVMaXN0LFBhaW50UmVxdWVzdExpc3QsUGx1Z2luLFBsdWdpbkFycmF5LFNWR0xlbmd0aExpc3QsU1ZHTnVtYmVyTGlzdCxTVkdQYXRoU2VnTGlzdCxTVkdQb2ludExpc3QsU1ZHU3RyaW5nTGlzdCxTVkdUcmFuc2Zvcm1MaXN0LFNvdXJjZUJ1ZmZlckxpc3QsU3R5bGVTaGVldExpc3QsVGV4dFRyYWNrQ3VlTGlzdCxUZXh0VHJhY2tMaXN0LFRvdWNoTGlzdCIuc3BsaXQoIiwiKSxvPTA7bzx1Lmxlbmd0aDtvKyspe3ZhciBmPXVbb10seD1yW2ZdLGM9eCYmeC5wcm90b3R5cGU7YyYmIWNbZ10mJm4oYyxnLGYpLGRbZl09ZC5BcnJheX19LGZ1bmN0aW9uKGgsZSx0KXt2YXIgcj10KDgxKSxuPXQoODIpLGQ9dCg4MyksZz10KDg0KTtoLmV4cG9ydHM9dCg4OCkoQXJyYXksIkFycmF5IixmdW5jdGlvbih1LG8pe3RoaXMuX3Q9Zyh1KSx0aGlzLl9pPTAsdGhpcy5faz1vfSxmdW5jdGlvbigpe3ZhciB1PXRoaXMuX3Qsbz10aGlzLl9rLGY9dGhpcy5faSsrO3JldHVybiF1fHxmPj11Lmxlbmd0aD8odGhpcy5fdD12b2lkIDAsbigxKSk6bz09ImtleXMiP24oMCxmKTpvPT0idmFsdWVzIj9uKDAsdVtmXSk6bigwLFtmLHVbZl1dKX0sInZhbHVlcyIpLGQuQXJndW1lbnRzPWQuQXJyYXkscigia2V5cyIpLHIoInZhbHVlcyIpLHIoImVudHJpZXMiKX0sZnVuY3Rpb24oaCxlKXtoLmV4cG9ydHM9ZnVuY3Rpb24oKXt9fSxmdW5jdGlvbihoLGUpe2guZXhwb3J0cz1mdW5jdGlvbih0LHIpe3JldHVybnt2YWx1ZTpyLGRvbmU6ISF0fX19LGZ1bmN0aW9uKGgsZSl7aC5leHBvcnRzPXt9fSxmdW5jdGlvbihoLGUsdCl7dmFyIHI9dCg4NSksbj10KDg3KTtoLmV4cG9ydHM9ZnVuY3Rpb24oZCl7cmV0dXJuIHIobihkKSl9fSxmdW5jdGlvbihoLGUsdCl7dmFyIHI9dCg4Nik7aC5leHBvcnRzPU9iamVjdCgieiIpLnByb3BlcnR5SXNFbnVtZXJhYmxlKDApP09iamVjdDpmdW5jdGlvbihuKXtyZXR1cm4gcihuKT09IlN0cmluZyI/bi5zcGxpdCgiIik6T2JqZWN0KG4pfX0sZnVuY3Rpb24oaCxlKXt2YXIgdD17fS50b1N0cmluZztoLmV4cG9ydHM9ZnVuY3Rpb24ocil7cmV0dXJuIHQuY2FsbChyKS5zbGljZSg4LC0xKX19LGZ1bmN0aW9uKGgsZSl7aC5leHBvcnRzPWZ1bmN0aW9uKHQpe2lmKHQ9PW51bGwpdGhyb3cgVHlwZUVycm9yKCJDYW4ndCBjYWxsIG1ldGhvZCBvbiAgIit0KTtyZXR1cm4gdH19LGZ1bmN0aW9uKGgsZSx0KXt2YXIgcj10KDg5KSxuPXQoOTApLGQ9dCgxMDYpLGc9dCg5NSksdT10KDgzKSxvPXQoMTA3KSxmPXQoMTIxKSx4PXQoMTIzKSxjPXQoMTIyKSgiaXRlcmF0b3IiKSx2PSEoW10ua2V5cyYmIm5leHQiaW5bXS5rZXlzKCkpLHA9IkBAaXRlcmF0b3IiLGI9ImtleXMiLEU9InZhbHVlcyIseT1mdW5jdGlvbigpe3JldHVybiB0aGlzfTtoLmV4cG9ydHM9ZnVuY3Rpb24oTSxpLGEscyxsLE8sQSl7byhhLGkscyk7dmFyIFI9ZnVuY3Rpb24oVSl7aWYoIXYmJlUgaW4gRClyZXR1cm4gRFtVXTtzd2l0Y2goVSl7Y2FzZSBiOnJldHVybiBmdW5jdGlvbigpe3JldHVybiBuZXcgYSh0aGlzLFUpfTtjYXNlIEU6cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBhKHRoaXMsVSl9fXJldHVybiBmdW5jdGlvbigpe3JldHVybiBuZXcgYSh0aGlzLFUpfX0sST1pKyIgSXRlcmF0b3IiLFA9bD09RSxMPSExLEQ9TS5wcm90b3R5cGUsQz1EW2NdfHxEW3BdfHxsJiZEW2xdLFM9Q3x8UihsKSxCPWw/UD9SKCJlbnRyaWVzIik6Uzp2b2lkIDAsdz1pPT0iQXJyYXkiJiZELmVudHJpZXN8fEMsSCxKLHE7aWYodyYmKHE9eCh3LmNhbGwobmV3IE0pKSxxIT09T2JqZWN0LnByb3RvdHlwZSYmcS5uZXh0JiYoZihxLEksITApLCFyJiZ0eXBlb2YgcVtjXSE9ImZ1bmN0aW9uIiYmZyhxLGMseSkpKSxQJiZDJiZDLm5hbWUhPT1FJiYoTD0hMCxTPWZ1bmN0aW9uKCl7cmV0dXJuIEMuY2FsbCh0aGlzKX0pLCghcnx8QSkmJih2fHxMfHwhRFtjXSkmJmcoRCxjLFMpLHVbaV09Uyx1W0ldPXksbClpZihIPXt2YWx1ZXM6UD9TOlIoRSksa2V5czpPP1M6UihiKSxlbnRyaWVzOkJ9LEEpZm9yKEogaW4gSClKIGluIER8fGQoRCxKLEhbSl0pO2Vsc2UgbihuLlArbi5GKih2fHxMKSxpLEgpO3JldHVybiBIfX0sZnVuY3Rpb24oaCxlKXtoLmV4cG9ydHM9ITB9LGZ1bmN0aW9uKGgsZSx0KXt2YXIgcj10KDkxKSxuPXQoOTIpLGQ9dCg5MyksZz10KDk1KSx1PXQoMTA1KSxvPSJwcm90b3R5cGUiLGY9ZnVuY3Rpb24oeCxjLHYpe3ZhciBwPXgmZi5GLGI9eCZmLkcsRT14JmYuUyx5PXgmZi5QLE09eCZmLkIsaT14JmYuVyxhPWI/bjpuW2NdfHwobltjXT17fSkscz1hW29dLGw9Yj9yOkU/cltjXToocltjXXx8e30pW29dLE8sQSxSO2ImJih2PWMpO2ZvcihPIGluIHYpQT0hcCYmbCYmbFtPXSE9PXZvaWQgMCwhKEEmJnUoYSxPKSkmJihSPUE/bFtPXTp2W09dLGFbT109YiYmdHlwZW9mIGxbT10hPSJmdW5jdGlvbiI/dltPXTpNJiZBP2QoUixyKTppJiZsW09dPT1SP2Z1bmN0aW9uKEkpe3ZhciBQPWZ1bmN0aW9uKEwsRCxDKXtpZih0aGlzIGluc3RhbmNlb2YgSSl7c3dpdGNoKGFyZ3VtZW50cy5sZW5ndGgpe2Nhc2UgMDpyZXR1cm4gbmV3IEk7Y2FzZSAxOnJldHVybiBuZXcgSShMKTtjYXNlIDI6cmV0dXJuIG5ldyBJKEwsRCl9cmV0dXJuIG5ldyBJKEwsRCxDKX1yZXR1cm4gSS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O3JldHVybiBQW29dPUlbb10sUH0oUik6eSYmdHlwZW9mIFI9PSJmdW5jdGlvbiI/ZChGdW5jdGlvbi5jYWxsLFIpOlIseSYmKChhLnZpcnR1YWx8fChhLnZpcnR1YWw9e30pKVtPXT1SLHgmZi5SJiZzJiYhc1tPXSYmZyhzLE8sUikpKX07Zi5GPTEsZi5HPTIsZi5TPTQsZi5QPTgsZi5CPTE2LGYuVz0zMixmLlU9NjQsZi5SPTEyOCxoLmV4cG9ydHM9Zn0sZnVuY3Rpb24oaCxlKXt2YXIgdD1oLmV4cG9ydHM9dHlwZW9mIHdpbmRvdzwidSImJndpbmRvdy5NYXRoPT1NYXRoP3dpbmRvdzp0eXBlb2Ygc2VsZjwidSImJnNlbGYuTWF0aD09TWF0aD9zZWxmOkZ1bmN0aW9uKCJyZXR1cm4gdGhpcyIpKCk7dHlwZW9mIF9fZz09Im51bWJlciImJihfX2c9dCl9LGZ1bmN0aW9uKGgsZSl7dmFyIHQ9aC5leHBvcnRzPXt2ZXJzaW9uOiIyLjYuMTEifTt0eXBlb2YgX19lPT0ibnVtYmVyIiYmKF9fZT10KX0sZnVuY3Rpb24oaCxlLHQpe3ZhciByPXQoOTQpO2guZXhwb3J0cz1mdW5jdGlvbihuLGQsZyl7aWYocihuKSxkPT09dm9pZCAwKXJldHVybiBuO3N3aXRjaChnKXtjYXNlIDE6cmV0dXJuIGZ1bmN0aW9uKHUpe3JldHVybiBuLmNhbGwoZCx1KX07Y2FzZSAyOnJldHVybiBmdW5jdGlvbih1LG8pe3JldHVybiBuLmNhbGwoZCx1LG8pfTtjYXNlIDM6cmV0dXJuIGZ1bmN0aW9uKHUsbyxmKXtyZXR1cm4gbi5jYWxsKGQsdSxvLGYpfX1yZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gbi5hcHBseShkLGFyZ3VtZW50cyl9fX0sZnVuY3Rpb24oaCxlKXtoLmV4cG9ydHM9ZnVuY3Rpb24odCl7aWYodHlwZW9mIHQhPSJmdW5jdGlvbiIpdGhyb3cgVHlwZUVycm9yKHQrIiBpcyBub3QgYSBmdW5jdGlvbiEiKTtyZXR1cm4gdH19LGZ1bmN0aW9uKGgsZSx0KXt2YXIgcj10KDk2KSxuPXQoMTA0KTtoLmV4cG9ydHM9dCgxMDApP2Z1bmN0aW9uKGQsZyx1KXtyZXR1cm4gci5mKGQsZyxuKDEsdSkpfTpmdW5jdGlvbihkLGcsdSl7cmV0dXJuIGRbZ109dSxkfX0sZnVuY3Rpb24oaCxlLHQpe3ZhciByPXQoOTcpLG49dCg5OSksZD10KDEwMyksZz1PYmplY3QuZGVmaW5lUHJvcGVydHk7ZS5mPXQoMTAwKT9PYmplY3QuZGVmaW5lUHJvcGVydHk6ZnVuY3Rpb24obyxmLHgpe2lmKHIobyksZj1kKGYsITApLHIoeCksbil0cnl7cmV0dXJuIGcobyxmLHgpfWNhdGNoe31pZigiZ2V0ImluIHh8fCJzZXQiaW4geCl0aHJvdyBUeXBlRXJyb3IoIkFjY2Vzc29ycyBub3Qgc3VwcG9ydGVkISIpO3JldHVybiJ2YWx1ZSJpbiB4JiYob1tmXT14LnZhbHVlKSxvfX0sZnVuY3Rpb24oaCxlLHQpe3ZhciByPXQoOTgpO2guZXhwb3J0cz1mdW5jdGlvbihuKXtpZighcihuKSl0aHJvdyBUeXBlRXJyb3IobisiIGlzIG5vdCBhbiBvYmplY3QhIik7cmV0dXJuIG59fSxmdW5jdGlvbihoLGUpe2guZXhwb3J0cz1mdW5jdGlvbih0KXtyZXR1cm4gdHlwZW9mIHQ9PSJvYmplY3QiP3QhPT1udWxsOnR5cGVvZiB0PT0iZnVuY3Rpb24ifX0sZnVuY3Rpb24oaCxlLHQpe2guZXhwb3J0cz0hdCgxMDApJiYhdCgxMDEpKGZ1bmN0aW9uKCl7cmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0KDEwMikoImRpdiIpLCJhIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIDd9fSkuYSE9N30pfSxmdW5jdGlvbihoLGUsdCl7aC5leHBvcnRzPSF0KDEwMSkoZnVuY3Rpb24oKXtyZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCJhIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIDd9fSkuYSE9N30pfSxmdW5jdGlvbihoLGUpe2guZXhwb3J0cz1mdW5jdGlvbih0KXt0cnl7cmV0dXJuISF0KCl9Y2F0Y2h7cmV0dXJuITB9fX0sZnVuY3Rpb24oaCxlLHQpe3ZhciByPXQoOTgpLG49dCg5MSkuZG9jdW1lbnQsZD1yKG4pJiZyKG4uY3JlYXRlRWxlbWVudCk7aC5leHBvcnRzPWZ1bmN0aW9uKGcpe3JldHVybiBkP24uY3JlYXRlRWxlbWVudChnKTp7fX19LGZ1bmN0aW9uKGgsZSx0KXt2YXIgcj10KDk4KTtoLmV4cG9ydHM9ZnVuY3Rpb24obixkKXtpZighcihuKSlyZXR1cm4gbjt2YXIgZyx1O2lmKGQmJnR5cGVvZihnPW4udG9TdHJpbmcpPT0iZnVuY3Rpb24iJiYhcih1PWcuY2FsbChuKSl8fHR5cGVvZihnPW4udmFsdWVPZik9PSJmdW5jdGlvbiImJiFyKHU9Zy5jYWxsKG4pKXx8IWQmJnR5cGVvZihnPW4udG9TdHJpbmcpPT0iZnVuY3Rpb24iJiYhcih1PWcuY2FsbChuKSkpcmV0dXJuIHU7dGhyb3cgVHlwZUVycm9yKCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWUiKX19LGZ1bmN0aW9uKGgsZSl7aC5leHBvcnRzPWZ1bmN0aW9uKHQscil7cmV0dXJue2VudW1lcmFibGU6ISh0JjEpLGNvbmZpZ3VyYWJsZTohKHQmMiksd3JpdGFibGU6ISh0JjQpLHZhbHVlOnJ9fX0sZnVuY3Rpb24oaCxlKXt2YXIgdD17fS5oYXNPd25Qcm9wZXJ0eTtoLmV4cG9ydHM9ZnVuY3Rpb24ocixuKXtyZXR1cm4gdC5jYWxsKHIsbil9fSxmdW5jdGlvbihoLGUsdCl7aC5leHBvcnRzPXQoOTUpfSxmdW5jdGlvbihoLGUsdCl7dmFyIHI9dCgxMDgpLG49dCgxMDQpLGQ9dCgxMjEpLGc9e307dCg5NSkoZyx0KDEyMikoIml0ZXJhdG9yIiksZnVuY3Rpb24oKXtyZXR1cm4gdGhpc30pLGguZXhwb3J0cz1mdW5jdGlvbih1LG8sZil7dS5wcm90b3R5cGU9cihnLHtuZXh0Om4oMSxmKX0pLGQodSxvKyIgSXRlcmF0b3IiKX19LGZ1bmN0aW9uKGgsZSx0KXt2YXIgcj10KDk3KSxuPXQoMTA5KSxkPXQoMTE5KSxnPXQoMTE2KSgiSUVfUFJPVE8iKSx1PWZ1bmN0aW9uKCl7fSxvPSJwcm90b3R5cGUiLGY9ZnVuY3Rpb24oKXt2YXIgeD10KDEwMikoImlmcmFtZSIpLGM9ZC5sZW5ndGgsdj0iPCIscD0iPiIsYjtmb3IoeC5zdHlsZS5kaXNwbGF5PSJub25lIix0KDEyMCkuYXBwZW5kQ2hpbGQoeCkseC5zcmM9ImphdmFzY3JpcHQ6IixiPXguY29udGVudFdpbmRvdy5kb2N1bWVudCxiLm9wZW4oKSxiLndyaXRlKHYrInNjcmlwdCIrcCsiZG9jdW1lbnQuRj1PYmplY3QiK3YrIi9zY3JpcHQiK3ApLGIuY2xvc2UoKSxmPWIuRjtjLS07KWRlbGV0ZSBmW29dW2RbY11dO3JldHVybiBmKCl9O2guZXhwb3J0cz1PYmplY3QuY3JlYXRlfHxmdW5jdGlvbihjLHYpe3ZhciBwO3JldHVybiBjIT09bnVsbD8odVtvXT1yKGMpLHA9bmV3IHUsdVtvXT1udWxsLHBbZ109Yyk6cD1mKCksdj09PXZvaWQgMD9wOm4ocCx2KX19LGZ1bmN0aW9uKGgsZSx0KXt2YXIgcj10KDk2KSxuPXQoOTcpLGQ9dCgxMTApO2guZXhwb3J0cz10KDEwMCk/T2JqZWN0LmRlZmluZVByb3BlcnRpZXM6ZnVuY3Rpb24odSxvKXtuKHUpO2Zvcih2YXIgZj1kKG8pLHg9Zi5sZW5ndGgsYz0wLHY7eD5jOylyLmYodSx2PWZbYysrXSxvW3ZdKTtyZXR1cm4gdX19LGZ1bmN0aW9uKGgsZSx0KXt2YXIgcj10KDExMSksbj10KDExOSk7aC5leHBvcnRzPU9iamVjdC5rZXlzfHxmdW5jdGlvbihnKXtyZXR1cm4gcihnLG4pfX0sZnVuY3Rpb24oaCxlLHQpe3ZhciByPXQoMTA1KSxuPXQoODQpLGQ9dCgxMTIpKCExKSxnPXQoMTE2KSgiSUVfUFJPVE8iKTtoLmV4cG9ydHM9ZnVuY3Rpb24odSxvKXt2YXIgZj1uKHUpLHg9MCxjPVtdLHY7Zm9yKHYgaW4gZil2IT1nJiZyKGYsdikmJmMucHVzaCh2KTtmb3IoO28ubGVuZ3RoPng7KXIoZix2PW9beCsrXSkmJih+ZChjLHYpfHxjLnB1c2godikpO3JldHVybiBjfX0sZnVuY3Rpb24oaCxlLHQpe3ZhciByPXQoODQpLG49dCgxMTMpLGQ9dCgxMTUpO2guZXhwb3J0cz1mdW5jdGlvbihnKXtyZXR1cm4gZnVuY3Rpb24odSxvLGYpe3ZhciB4PXIodSksYz1uKHgubGVuZ3RoKSx2PWQoZixjKSxwO2lmKGcmJm8hPW8pe2Zvcig7Yz52OylpZihwPXhbdisrXSxwIT1wKXJldHVybiEwfWVsc2UgZm9yKDtjPnY7disrKWlmKChnfHx2IGluIHgpJiZ4W3ZdPT09bylyZXR1cm4gZ3x8dnx8MDtyZXR1cm4hZyYmLTF9fX0sZnVuY3Rpb24oaCxlLHQpe3ZhciByPXQoMTE0KSxuPU1hdGgubWluO2guZXhwb3J0cz1mdW5jdGlvbihkKXtyZXR1cm4gZD4wP24ocihkKSw5MDA3MTk5MjU0NzQwOTkxKTowfX0sZnVuY3Rpb24oaCxlKXt2YXIgdD1NYXRoLmNlaWwscj1NYXRoLmZsb29yO2guZXhwb3J0cz1mdW5jdGlvbihuKXtyZXR1cm4gaXNOYU4obj0rbik/MDoobj4wP3I6dCkobil9fSxmdW5jdGlvbihoLGUsdCl7dmFyIHI9dCgxMTQpLG49TWF0aC5tYXgsZD1NYXRoLm1pbjtoLmV4cG9ydHM9ZnVuY3Rpb24oZyx1KXtyZXR1cm4gZz1yKGcpLGc8MD9uKGcrdSwwKTpkKGcsdSl9fSxmdW5jdGlvbihoLGUsdCl7dmFyIHI9dCgxMTcpKCJrZXlzIiksbj10KDExOCk7aC5leHBvcnRzPWZ1bmN0aW9uKGQpe3JldHVybiByW2RdfHwocltkXT1uKGQpKX19LGZ1bmN0aW9uKGgsZSx0KXt2YXIgcj10KDkyKSxuPXQoOTEpLGQ9Il9fY29yZS1qc19zaGFyZWRfXyIsZz1uW2RdfHwobltkXT17fSk7KGguZXhwb3J0cz1mdW5jdGlvbih1LG8pe3JldHVybiBnW3VdfHwoZ1t1XT1vIT09dm9pZCAwP286e30pfSkoInZlcnNpb25zIixbXSkucHVzaCh7dmVyc2lvbjpyLnZlcnNpb24sbW9kZTp0KDg5KT8icHVyZSI6Imdsb2JhbCIsY29weXJpZ2h0OiLCqSAyMDE5IERlbmlzIFB1c2hrYXJldiAoemxvaXJvY2sucnUpIn0pfSxmdW5jdGlvbihoLGUpe3ZhciB0PTAscj1NYXRoLnJhbmRvbSgpO2guZXhwb3J0cz1mdW5jdGlvbihuKXtyZXR1cm4iU3ltYm9sKCIuY29uY2F0KG49PT12b2lkIDA/IiI6biwiKV8iLCgrK3QrcikudG9TdHJpbmcoMzYpKX19LGZ1bmN0aW9uKGgsZSl7aC5leHBvcnRzPSJjb25zdHJ1Y3RvcixoYXNPd25Qcm9wZXJ0eSxpc1Byb3RvdHlwZU9mLHByb3BlcnR5SXNFbnVtZXJhYmxlLHRvTG9jYWxlU3RyaW5nLHRvU3RyaW5nLHZhbHVlT2YiLnNwbGl0KCIsIil9LGZ1bmN0aW9uKGgsZSx0KXt2YXIgcj10KDkxKS5kb2N1bWVudDtoLmV4cG9ydHM9ciYmci5kb2N1bWVudEVsZW1lbnR9LGZ1bmN0aW9uKGgsZSx0KXt2YXIgcj10KDk2KS5mLG49dCgxMDUpLGQ9dCgxMjIpKCJ0b1N0cmluZ1RhZyIpO2guZXhwb3J0cz1mdW5jdGlvbihnLHUsbyl7ZyYmIW4oZz1vP2c6Zy5wcm90b3R5cGUsZCkmJnIoZyxkLHtjb25maWd1cmFibGU6ITAsdmFsdWU6dX0pfX0sZnVuY3Rpb24oaCxlLHQpe3ZhciByPXQoMTE3KSgid2tzIiksbj10KDExOCksZD10KDkxKS5TeW1ib2wsZz10eXBlb2YgZD09ImZ1bmN0aW9uIix1PWguZXhwb3J0cz1mdW5jdGlvbihvKXtyZXR1cm4gcltvXXx8KHJbb109ZyYmZFtvXXx8KGc/ZDpuKSgiU3ltYm9sLiIrbykpfTt1LnN0b3JlPXJ9LGZ1bmN0aW9uKGgsZSx0KXt2YXIgcj10KDEwNSksbj10KDEyNCksZD10KDExNikoIklFX1BST1RPIiksZz1PYmplY3QucHJvdG90eXBlO2guZXhwb3J0cz1PYmplY3QuZ2V0UHJvdG90eXBlT2Z8fGZ1bmN0aW9uKHUpe3JldHVybiB1PW4odSkscih1LGQpP3VbZF06dHlwZW9mIHUuY29uc3RydWN0b3I9PSJmdW5jdGlvbiImJnUgaW5zdGFuY2VvZiB1LmNvbnN0cnVjdG9yP3UuY29uc3RydWN0b3IucHJvdG90eXBlOnUgaW5zdGFuY2VvZiBPYmplY3Q/ZzpudWxsfX0sZnVuY3Rpb24oaCxlLHQpe3ZhciByPXQoODcpO2guZXhwb3J0cz1mdW5jdGlvbihuKXtyZXR1cm4gT2JqZWN0KHIobikpfX0sZnVuY3Rpb24oaCxlLHQpe3ZhciByPXQoMTI2KSghMCk7dCg4OCkoU3RyaW5nLCJTdHJpbmciLGZ1bmN0aW9uKG4pe3RoaXMuX3Q9U3RyaW5nKG4pLHRoaXMuX2k9MH0sZnVuY3Rpb24oKXt2YXIgbj10aGlzLl90LGQ9dGhpcy5faSxnO3JldHVybiBkPj1uLmxlbmd0aD97dmFsdWU6dm9pZCAwLGRvbmU6ITB9OihnPXIobixkKSx0aGlzLl9pKz1nLmxlbmd0aCx7dmFsdWU6Zyxkb25lOiExfSl9KX0sZnVuY3Rpb24oaCxlLHQpe3ZhciByPXQoMTE0KSxuPXQoODcpO2guZXhwb3J0cz1mdW5jdGlvbihkKXtyZXR1cm4gZnVuY3Rpb24oZyx1KXt2YXIgbz1TdHJpbmcobihnKSksZj1yKHUpLHg9by5sZW5ndGgsYyx2O3JldHVybiBmPDB8fGY+PXg/ZD8iIjp2b2lkIDA6KGM9by5jaGFyQ29kZUF0KGYpLGM8NTUyOTZ8fGM+NTYzMTl8fGYrMT09PXh8fCh2PW8uY2hhckNvZGVBdChmKzEpKTw1NjMyMHx8dj41NzM0Mz9kP28uY2hhckF0KGYpOmM6ZD9vLnNsaWNlKGYsZisyKTooYy01NTI5Njw8MTApKyh2LTU2MzIwKSs2NTUzNil9fX0sZnVuY3Rpb24oaCxlLHQpe3ZhciByPXQoMTI4KSxuPXQoMTIyKSgiaXRlcmF0b3IiKSxkPXQoODMpO2guZXhwb3J0cz10KDkyKS5pc0l0ZXJhYmxlPWZ1bmN0aW9uKGcpe3ZhciB1PU9iamVjdChnKTtyZXR1cm4gdVtuXSE9PXZvaWQgMHx8IkBAaXRlcmF0b3IiaW4gdXx8ZC5oYXNPd25Qcm9wZXJ0eShyKHUpKX19LGZ1bmN0aW9uKGgsZSx0KXt2YXIgcj10KDg2KSxuPXQoMTIyKSgidG9TdHJpbmdUYWciKSxkPXIoZnVuY3Rpb24oKXtyZXR1cm4gYXJndW1lbnRzfSgpKT09IkFyZ3VtZW50cyIsZz1mdW5jdGlvbih1LG8pe3RyeXtyZXR1cm4gdVtvXX1jYXRjaHt9fTtoLmV4cG9ydHM9ZnVuY3Rpb24odSl7dmFyIG8sZix4O3JldHVybiB1PT09dm9pZCAwPyJVbmRlZmluZWQiOnU9PT1udWxsPyJOdWxsIjp0eXBlb2YoZj1nKG89T2JqZWN0KHUpLG4pKT09InN0cmluZyI/ZjpkP3Iobyk6KHg9cihvKSk9PSJPYmplY3QiJiZ0eXBlb2Ygby5jYWxsZWU9PSJmdW5jdGlvbiI/IkFyZ3VtZW50cyI6eH19LGZ1bmN0aW9uKGgsZSx0KXtoLmV4cG9ydHM9e2RlZmF1bHQ6dCgxMzApLF9fZXNNb2R1bGU6ITB9fSxmdW5jdGlvbihoLGUsdCl7dCg3OSksdCgxMjUpLGguZXhwb3J0cz10KDEzMSl9LGZ1bmN0aW9uKGgsZSx0KXt2YXIgcj10KDk3KSxuPXQoMTMyKTtoLmV4cG9ydHM9dCg5MikuZ2V0SXRlcmF0b3I9ZnVuY3Rpb24oZCl7dmFyIGc9bihkKTtpZih0eXBlb2YgZyE9ImZ1bmN0aW9uIil0aHJvdyBUeXBlRXJyb3IoZCsiIGlzIG5vdCBpdGVyYWJsZSEiKTtyZXR1cm4gcihnLmNhbGwoZCkpfX0sZnVuY3Rpb24oaCxlLHQpe3ZhciByPXQoMTI4KSxuPXQoMTIyKSgiaXRlcmF0b3IiKSxkPXQoODMpO2guZXhwb3J0cz10KDkyKS5nZXRJdGVyYXRvck1ldGhvZD1mdW5jdGlvbihnKXtpZihnIT1udWxsKXJldHVybiBnW25dfHxnWyJAQGl0ZXJhdG9yIl18fGRbcihnKV19fSxmdW5jdGlvbihoLGUsdCl7ZS5fX2VzTW9kdWxlPSEwO3ZhciByPXQoMTM0KSxuPWQocik7ZnVuY3Rpb24gZChnKXtyZXR1cm4gZyYmZy5fX2VzTW9kdWxlP2c6e2RlZmF1bHQ6Z319ZS5kZWZhdWx0PWZ1bmN0aW9uKGcpe2lmKEFycmF5LmlzQXJyYXkoZykpe2Zvcih2YXIgdT0wLG89QXJyYXkoZy5sZW5ndGgpO3U8Zy5sZW5ndGg7dSsrKW9bdV09Z1t1XTtyZXR1cm4gb31lbHNlIHJldHVybigwLG4uZGVmYXVsdCkoZyl9fSxmdW5jdGlvbihoLGUsdCl7aC5leHBvcnRzPXtkZWZhdWx0OnQoMTM1KSxfX2VzTW9kdWxlOiEwfX0sZnVuY3Rpb24oaCxlLHQpe3QoMTI1KSx0KDEzNiksaC5leHBvcnRzPXQoOTIpLkFycmF5LmZyb219LGZ1bmN0aW9uKGgsZSx0KXt2YXIgcj10KDkzKSxuPXQoOTApLGQ9dCgxMjQpLGc9dCgxMzcpLHU9dCgxMzgpLG89dCgxMTMpLGY9dCgxMzkpLHg9dCgxMzIpO24obi5TK24uRiohdCgxNDApKGZ1bmN0aW9uKGMpe0FycmF5LmZyb20oYyl9KSwiQXJyYXkiLHtmcm9tOmZ1bmN0aW9uKHYpe3ZhciBwPWQodiksYj10eXBlb2YgdGhpcz09ImZ1bmN0aW9uIj90aGlzOkFycmF5LEU9YXJndW1lbnRzLmxlbmd0aCx5PUU+MT9hcmd1bWVudHNbMV06dm9pZCAwLE09eSE9PXZvaWQgMCxpPTAsYT14KHApLHMsbCxPLEE7aWYoTSYmKHk9cih5LEU+Mj9hcmd1bWVudHNbMl06dm9pZCAwLDIpKSxhIT1udWxsJiYhKGI9PUFycmF5JiZ1KGEpKSlmb3IoQT1hLmNhbGwocCksbD1uZXcgYjshKE89QS5uZXh0KCkpLmRvbmU7aSsrKWYobCxpLE0/ZyhBLHksW08udmFsdWUsaV0sITApOk8udmFsdWUpO2Vsc2UgZm9yKHM9byhwLmxlbmd0aCksbD1uZXcgYihzKTtzPmk7aSsrKWYobCxpLE0/eShwW2ldLGkpOnBbaV0pO3JldHVybiBsLmxlbmd0aD1pLGx9fSl9LGZ1bmN0aW9uKGgsZSx0KXt2YXIgcj10KDk3KTtoLmV4cG9ydHM9ZnVuY3Rpb24obixkLGcsdSl7dHJ5e3JldHVybiB1P2QocihnKVswXSxnWzFdKTpkKGcpfWNhdGNoKGYpe3ZhciBvPW4ucmV0dXJuO3Rocm93IG8hPT12b2lkIDAmJnIoby5jYWxsKG4pKSxmfX19LGZ1bmN0aW9uKGgsZSx0KXt2YXIgcj10KDgzKSxuPXQoMTIyKSgiaXRlcmF0b3IiKSxkPUFycmF5LnByb3RvdHlwZTtoLmV4cG9ydHM9ZnVuY3Rpb24oZyl7cmV0dXJuIGchPT12b2lkIDAmJihyLkFycmF5PT09Z3x8ZFtuXT09PWcpfX0sZnVuY3Rpb24oaCxlLHQpe3ZhciByPXQoOTYpLG49dCgxMDQpO2guZXhwb3J0cz1mdW5jdGlvbihkLGcsdSl7ZyBpbiBkP3IuZihkLGcsbigwLHUpKTpkW2ddPXV9fSxmdW5jdGlvbihoLGUsdCl7dmFyIHI9dCgxMjIpKCJpdGVyYXRvciIpLG49ITE7dHJ5e3ZhciBkPVs3XVtyXSgpO2QucmV0dXJuPWZ1bmN0aW9uKCl7bj0hMH0sQXJyYXkuZnJvbShkLGZ1bmN0aW9uKCl7dGhyb3cgMn0pfWNhdGNoe31oLmV4cG9ydHM9ZnVuY3Rpb24oZyx1KXtpZighdSYmIW4pcmV0dXJuITE7dmFyIG89ITE7dHJ5e3ZhciBmPVs3XSx4PWZbcl0oKTt4Lm5leHQ9ZnVuY3Rpb24oKXtyZXR1cm57ZG9uZTpvPSEwfX0sZltyXT1mdW5jdGlvbigpe3JldHVybiB4fSxnKGYpfWNhdGNoe31yZXR1cm4gb319LGZ1bmN0aW9uKGgsZSx0KXtoLmV4cG9ydHM9e2RlZmF1bHQ6dCgxNDIpLF9fZXNNb2R1bGU6ITB9fSxmdW5jdGlvbihoLGUsdCl7dCgxNDMpLHQoMTI1KSx0KDc5KSx0KDE0NCksdCgxNTcpLHQoMTYwKSx0KDE2MiksaC5leHBvcnRzPXQoOTIpLk1hcH0sZnVuY3Rpb24oaCxlKXt9LGZ1bmN0aW9uKGgsZSx0KXt2YXIgcj10KDE0NSksbj10KDE1MSksZD0iTWFwIjtoLmV4cG9ydHM9dCgxNTIpKGQsZnVuY3Rpb24oZyl7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIGcodGhpcyxhcmd1bWVudHMubGVuZ3RoPjA/YXJndW1lbnRzWzBdOnZvaWQgMCl9fSx7Z2V0OmZ1bmN0aW9uKHUpe3ZhciBvPXIuZ2V0RW50cnkobih0aGlzLGQpLHUpO3JldHVybiBvJiZvLnZ9LHNldDpmdW5jdGlvbih1LG8pe3JldHVybiByLmRlZihuKHRoaXMsZCksdT09PTA/MDp1LG8pfX0sciwhMCl9LGZ1bmN0aW9uKGgsZSx0KXt2YXIgcj10KDk2KS5mLG49dCgxMDgpLGQ9dCgxNDYpLGc9dCg5MyksdT10KDE0Nyksbz10KDE0OCksZj10KDg4KSx4PXQoODIpLGM9dCgxNDkpLHY9dCgxMDApLHA9dCgxNTApLmZhc3RLZXksYj10KDE1MSksRT12PyJfcyI6InNpemUiLHk9ZnVuY3Rpb24oTSxpKXt2YXIgYT1wKGkpLHM7aWYoYSE9PSJGIilyZXR1cm4gTS5faVthXTtmb3Iocz1NLl9mO3M7cz1zLm4paWYocy5rPT1pKXJldHVybiBzfTtoLmV4cG9ydHM9e2dldENvbnN0cnVjdG9yOmZ1bmN0aW9uKE0saSxhLHMpe3ZhciBsPU0oZnVuY3Rpb24oTyxBKXt1KE8sbCxpLCJfaSIpLE8uX3Q9aSxPLl9pPW4obnVsbCksTy5fZj12b2lkIDAsTy5fbD12b2lkIDAsT1tFXT0wLEEhPW51bGwmJm8oQSxhLE9bc10sTyl9KTtyZXR1cm4gZChsLnByb3RvdHlwZSx7Y2xlYXI6ZnVuY3Rpb24oKXtmb3IodmFyIEE9Yih0aGlzLGkpLFI9QS5faSxJPUEuX2Y7STtJPUkubilJLnI9ITAsSS5wJiYoSS5wPUkucC5uPXZvaWQgMCksZGVsZXRlIFJbSS5pXTtBLl9mPUEuX2w9dm9pZCAwLEFbRV09MH0sZGVsZXRlOmZ1bmN0aW9uKE8pe3ZhciBBPWIodGhpcyxpKSxSPXkoQSxPKTtpZihSKXt2YXIgST1SLm4sUD1SLnA7ZGVsZXRlIEEuX2lbUi5pXSxSLnI9ITAsUCYmKFAubj1JKSxJJiYoSS5wPVApLEEuX2Y9PVImJihBLl9mPUkpLEEuX2w9PVImJihBLl9sPVApLEFbRV0tLX1yZXR1cm4hIVJ9LGZvckVhY2g6ZnVuY3Rpb24oQSl7Yih0aGlzLGkpO2Zvcih2YXIgUj1nKEEsYXJndW1lbnRzLmxlbmd0aD4xP2FyZ3VtZW50c1sxXTp2b2lkIDAsMyksSTtJPUk/SS5uOnRoaXMuX2Y7KWZvcihSKEkudixJLmssdGhpcyk7SSYmSS5yOylJPUkucH0saGFzOmZ1bmN0aW9uKEEpe3JldHVybiEheShiKHRoaXMsaSksQSl9fSksdiYmcihsLnByb3RvdHlwZSwic2l6ZSIse2dldDpmdW5jdGlvbigpe3JldHVybiBiKHRoaXMsaSlbRV19fSksbH0sZGVmOmZ1bmN0aW9uKE0saSxhKXt2YXIgcz15KE0saSksbCxPO3JldHVybiBzP3Mudj1hOihNLl9sPXM9e2k6Tz1wKGksITApLGs6aSx2OmEscDpsPU0uX2wsbjp2b2lkIDAscjohMX0sTS5fZnx8KE0uX2Y9cyksbCYmKGwubj1zKSxNW0VdKyssTyE9PSJGIiYmKE0uX2lbT109cykpLE19LGdldEVudHJ5Onksc2V0U3Ryb25nOmZ1bmN0aW9uKE0saSxhKXtmKE0saSxmdW5jdGlvbihzLGwpe3RoaXMuX3Q9YihzLGkpLHRoaXMuX2s9bCx0aGlzLl9sPXZvaWQgMH0sZnVuY3Rpb24oKXtmb3IodmFyIHM9dGhpcyxsPXMuX2ssTz1zLl9sO08mJk8ucjspTz1PLnA7cmV0dXJuIXMuX3R8fCEocy5fbD1PPU8/Ty5uOnMuX3QuX2YpPyhzLl90PXZvaWQgMCx4KDEpKTpsPT0ia2V5cyI/eCgwLE8uayk6bD09InZhbHVlcyI/eCgwLE8udik6eCgwLFtPLmssTy52XSl9LGE/ImVudHJpZXMiOiJ2YWx1ZXMiLCFhLCEwKSxjKGkpfX19LGZ1bmN0aW9uKGgsZSx0KXt2YXIgcj10KDk1KTtoLmV4cG9ydHM9ZnVuY3Rpb24obixkLGcpe2Zvcih2YXIgdSBpbiBkKWcmJm5bdV0/blt1XT1kW3VdOnIobix1LGRbdV0pO3JldHVybiBufX0sZnVuY3Rpb24oaCxlKXtoLmV4cG9ydHM9ZnVuY3Rpb24odCxyLG4sZCl7aWYoISh0IGluc3RhbmNlb2Ygcil8fGQhPT12b2lkIDAmJmQgaW4gdCl0aHJvdyBUeXBlRXJyb3IobisiOiBpbmNvcnJlY3QgaW52b2NhdGlvbiEiKTtyZXR1cm4gdH19LGZ1bmN0aW9uKGgsYyx0KXt2YXIgcj10KDkzKSxuPXQoMTM3KSxkPXQoMTM4KSxnPXQoOTcpLHU9dCgxMTMpLG89dCgxMzIpLGY9e30seD17fSxjPWguZXhwb3J0cz1mdW5jdGlvbih2LHAsYixFLHkpe3ZhciBNPXk/ZnVuY3Rpb24oKXtyZXR1cm4gdn06byh2KSxpPXIoYixFLHA/MjoxKSxhPTAscyxsLE8sQTtpZih0eXBlb2YgTSE9ImZ1bmN0aW9uIil0aHJvdyBUeXBlRXJyb3IodisiIGlzIG5vdCBpdGVyYWJsZSEiKTtpZihkKE0pKXtmb3Iocz11KHYubGVuZ3RoKTtzPmE7YSsrKWlmKEE9cD9pKGcobD12W2FdKVswXSxsWzFdKTppKHZbYV0pLEE9PT1mfHxBPT09eClyZXR1cm4gQX1lbHNlIGZvcihPPU0uY2FsbCh2KTshKGw9Ty5uZXh0KCkpLmRvbmU7KWlmKEE9bihPLGksbC52YWx1ZSxwKSxBPT09Znx8QT09PXgpcmV0dXJuIEF9O2MuQlJFQUs9ZixjLlJFVFVSTj14fSxmdW5jdGlvbihoLGUsdCl7dmFyIHI9dCg5MSksbj10KDkyKSxkPXQoOTYpLGc9dCgxMDApLHU9dCgxMjIpKCJzcGVjaWVzIik7aC5leHBvcnRzPWZ1bmN0aW9uKG8pe3ZhciBmPXR5cGVvZiBuW29dPT0iZnVuY3Rpb24iP25bb106cltvXTtnJiZmJiYhZlt1XSYmZC5mKGYsdSx7Y29uZmlndXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzfX0pfX0sZnVuY3Rpb24oaCxlLHQpe3ZhciByPXQoMTE4KSgibWV0YSIpLG49dCg5OCksZD10KDEwNSksZz10KDk2KS5mLHU9MCxvPU9iamVjdC5pc0V4dGVuc2libGV8fGZ1bmN0aW9uKCl7cmV0dXJuITB9LGY9IXQoMTAxKShmdW5jdGlvbigpe3JldHVybiBvKE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh7fSkpfSkseD1mdW5jdGlvbihFKXtnKEUscix7dmFsdWU6e2k6Ik8iKyArK3Usdzp7fX19KX0sYz1mdW5jdGlvbihFLHkpe2lmKCFuKEUpKXJldHVybiB0eXBlb2YgRT09InN5bWJvbCI/RToodHlwZW9mIEU9PSJzdHJpbmciPyJTIjoiUCIpK0U7aWYoIWQoRSxyKSl7aWYoIW8oRSkpcmV0dXJuIkYiO2lmKCF5KXJldHVybiJFIjt4KEUpfXJldHVybiBFW3JdLml9LHY9ZnVuY3Rpb24oRSx5KXtpZighZChFLHIpKXtpZighbyhFKSlyZXR1cm4hMDtpZigheSlyZXR1cm4hMTt4KEUpfXJldHVybiBFW3JdLnd9LHA9ZnVuY3Rpb24oRSl7cmV0dXJuIGYmJmIuTkVFRCYmbyhFKSYmIWQoRSxyKSYmeChFKSxFfSxiPWguZXhwb3J0cz17S0VZOnIsTkVFRDohMSxmYXN0S2V5OmMsZ2V0V2Vhazp2LG9uRnJlZXplOnB9fSxmdW5jdGlvbihoLGUsdCl7dmFyIHI9dCg5OCk7aC5leHBvcnRzPWZ1bmN0aW9uKG4sZCl7aWYoIXIobil8fG4uX3QhPT1kKXRocm93IFR5cGVFcnJvcigiSW5jb21wYXRpYmxlIHJlY2VpdmVyLCAiK2QrIiByZXF1aXJlZCEiKTtyZXR1cm4gbn19LGZ1bmN0aW9uKGgsZSx0KXt2YXIgcj10KDkxKSxuPXQoOTApLGQ9dCgxNTApLGc9dCgxMDEpLHU9dCg5NSksbz10KDE0NiksZj10KDE0OCkseD10KDE0NyksYz10KDk4KSx2PXQoMTIxKSxwPXQoOTYpLmYsYj10KDE1MykoMCksRT10KDEwMCk7aC5leHBvcnRzPWZ1bmN0aW9uKHksTSxpLGEscyxsKXt2YXIgTz1yW3ldLEE9TyxSPXM/InNldCI6ImFkZCIsST1BJiZBLnByb3RvdHlwZSxQPXt9O3JldHVybiFFfHx0eXBlb2YgQSE9ImZ1bmN0aW9uInx8IShsfHxJLmZvckVhY2gmJiFnKGZ1bmN0aW9uKCl7bmV3IEEoKS5lbnRyaWVzKCkubmV4dCgpfSkpPyhBPWEuZ2V0Q29uc3RydWN0b3IoTSx5LHMsUiksbyhBLnByb3RvdHlwZSxpKSxkLk5FRUQ9ITApOihBPU0oZnVuY3Rpb24oTCxEKXt4KEwsQSx5LCJfYyIpLEwuX2M9bmV3IE8sRCE9bnVsbCYmZihELHMsTFtSXSxMKX0pLGIoImFkZCxjbGVhcixkZWxldGUsZm9yRWFjaCxnZXQsaGFzLHNldCxrZXlzLHZhbHVlcyxlbnRyaWVzLHRvSlNPTiIuc3BsaXQoIiwiKSxmdW5jdGlvbihMKXt2YXIgRD1MPT0iYWRkInx8TD09InNldCI7TCBpbiBJJiYhKGwmJkw9PSJjbGVhciIpJiZ1KEEucHJvdG90eXBlLEwsZnVuY3Rpb24oQyxTKXtpZih4KHRoaXMsQSxMKSwhRCYmbCYmIWMoQykpcmV0dXJuIEw9PSJnZXQiP3ZvaWQgMDohMTt2YXIgQj10aGlzLl9jW0xdKEM9PT0wPzA6QyxTKTtyZXR1cm4gRD90aGlzOkJ9KX0pLGx8fHAoQS5wcm90b3R5cGUsInNpemUiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fYy5zaXplfX0pKSx2KEEseSksUFt5XT1BLG4obi5HK24uVytuLkYsUCksbHx8YS5zZXRTdHJvbmcoQSx5LHMpLEF9fSxmdW5jdGlvbihoLGUsdCl7dmFyIHI9dCg5Myksbj10KDg1KSxkPXQoMTI0KSxnPXQoMTEzKSx1PXQoMTU0KTtoLmV4cG9ydHM9ZnVuY3Rpb24obyxmKXt2YXIgeD1vPT0xLGM9bz09Mix2PW89PTMscD1vPT00LGI9bz09NixFPW89PTV8fGIseT1mfHx1O3JldHVybiBmdW5jdGlvbihNLGksYSl7Zm9yKHZhciBzPWQoTSksbD1uKHMpLE89cihpLGEsMyksQT1nKGwubGVuZ3RoKSxSPTAsST14P3koTSxBKTpjP3koTSwwKTp2b2lkIDAsUCxMO0E+UjtSKyspaWYoKEV8fFIgaW4gbCkmJihQPWxbUl0sTD1PKFAsUixzKSxvKSl7aWYoeClJW1JdPUw7ZWxzZSBpZihMKXN3aXRjaChvKXtjYXNlIDM6cmV0dXJuITA7Y2FzZSA1OnJldHVybiBQO2Nhc2UgNjpyZXR1cm4gUjtjYXNlIDI6SS5wdXNoKFApfWVsc2UgaWYocClyZXR1cm4hMX1yZXR1cm4gYj8tMTp2fHxwP3A6SX19fSxmdW5jdGlvbihoLGUsdCl7dmFyIHI9dCgxNTUpO2guZXhwb3J0cz1mdW5jdGlvbihuLGQpe3JldHVybiBuZXcocihuKSkoZCl9fSxmdW5jdGlvbihoLGUsdCl7dmFyIHI9dCg5OCksbj10KDE1NiksZD10KDEyMikoInNwZWNpZXMiKTtoLmV4cG9ydHM9ZnVuY3Rpb24oZyl7dmFyIHU7cmV0dXJuIG4oZykmJih1PWcuY29uc3RydWN0b3IsdHlwZW9mIHU9PSJmdW5jdGlvbiImJih1PT09QXJyYXl8fG4odS5wcm90b3R5cGUpKSYmKHU9dm9pZCAwKSxyKHUpJiYodT11W2RdLHU9PT1udWxsJiYodT12b2lkIDApKSksdT09PXZvaWQgMD9BcnJheTp1fX0sZnVuY3Rpb24oaCxlLHQpe3ZhciByPXQoODYpO2guZXhwb3J0cz1BcnJheS5pc0FycmF5fHxmdW5jdGlvbihkKXtyZXR1cm4gcihkKT09IkFycmF5In19LGZ1bmN0aW9uKGgsZSx0KXt2YXIgcj10KDkwKTtyKHIuUCtyLlIsIk1hcCIse3RvSlNPTjp0KDE1OCkoIk1hcCIpfSl9LGZ1bmN0aW9uKGgsZSx0KXt2YXIgcj10KDEyOCksbj10KDE1OSk7aC5leHBvcnRzPWZ1bmN0aW9uKGQpe3JldHVybiBmdW5jdGlvbigpe2lmKHIodGhpcykhPWQpdGhyb3cgVHlwZUVycm9yKGQrIiN0b0pTT04gaXNuJ3QgZ2VuZXJpYyIpO3JldHVybiBuKHRoaXMpfX19LGZ1bmN0aW9uKGgsZSx0KXt2YXIgcj10KDE0OCk7aC5leHBvcnRzPWZ1bmN0aW9uKG4sZCl7dmFyIGc9W107cmV0dXJuIHIobiwhMSxnLnB1c2gsZyxkKSxnfX0sZnVuY3Rpb24oaCxlLHQpe3QoMTYxKSgiTWFwIil9LGZ1bmN0aW9uKGgsZSx0KXt2YXIgcj10KDkwKTtoLmV4cG9ydHM9ZnVuY3Rpb24obil7cihyLlMsbix7b2Y6ZnVuY3Rpb24oKXtmb3IodmFyIGc9YXJndW1lbnRzLmxlbmd0aCx1PW5ldyBBcnJheShnKTtnLS07KXVbZ109YXJndW1lbnRzW2ddO3JldHVybiBuZXcgdGhpcyh1KX19KX19LGZ1bmN0aW9uKGgsZSx0KXt0KDE2MykoIk1hcCIpfSxmdW5jdGlvbihoLGUsdCl7dmFyIHI9dCg5MCksbj10KDk0KSxkPXQoOTMpLGc9dCgxNDgpO2guZXhwb3J0cz1mdW5jdGlvbih1KXtyKHIuUyx1LHtmcm9tOmZ1bmN0aW9uKGYpe3ZhciB4PWFyZ3VtZW50c1sxXSxjLHYscCxiO3JldHVybiBuKHRoaXMpLGM9eCE9PXZvaWQgMCxjJiZuKHgpLGY9PW51bGw/bmV3IHRoaXM6KHY9W10sYz8ocD0wLGI9ZCh4LGFyZ3VtZW50c1syXSwyKSxnKGYsITEsZnVuY3Rpb24oRSl7di5wdXNoKGIoRSxwKyspKX0pKTpnKGYsITEsdi5wdXNoLHYpLG5ldyB0aGlzKHYpKX19KX19LGZ1bmN0aW9uKGgsZSx0KXtoLmV4cG9ydHM9e2RlZmF1bHQ6dCgxNjUpLF9fZXNNb2R1bGU6ITB9fSxmdW5jdGlvbihoLGUsdCl7dCgxNjYpLGguZXhwb3J0cz10KDkyKS5PYmplY3QuYXNzaWdufSxmdW5jdGlvbihoLGUsdCl7dmFyIHI9dCg5MCk7cihyLlMrci5GLCJPYmplY3QiLHthc3NpZ246dCgxNjcpfSl9LGZ1bmN0aW9uKGgsZSx0KXt2YXIgcj10KDEwMCksbj10KDExMCksZD10KDE2OCksZz10KDE2OSksdT10KDEyNCksbz10KDg1KSxmPU9iamVjdC5hc3NpZ247aC5leHBvcnRzPSFmfHx0KDEwMSkoZnVuY3Rpb24oKXt2YXIgeD17fSxjPXt9LHY9U3ltYm9sKCkscD0iYWJjZGVmZ2hpamtsbW5vcHFyc3QiO3JldHVybiB4W3ZdPTcscC5zcGxpdCgiIikuZm9yRWFjaChmdW5jdGlvbihiKXtjW2JdPWJ9KSxmKHt9LHgpW3ZdIT03fHxPYmplY3Qua2V5cyhmKHt9LGMpKS5qb2luKCIiKSE9cH0pP2Z1bmN0aW9uKGMsdil7Zm9yKHZhciBwPXUoYyksYj1hcmd1bWVudHMubGVuZ3RoLEU9MSx5PWQuZixNPWcuZjtiPkU7KWZvcih2YXIgaT1vKGFyZ3VtZW50c1tFKytdKSxhPXk/bihpKS5jb25jYXQoeShpKSk6bihpKSxzPWEubGVuZ3RoLGw9MCxPO3M+bDspTz1hW2wrK10sKCFyfHxNLmNhbGwoaSxPKSkmJihwW09dPWlbT10pO3JldHVybiBwfTpmfSxmdW5jdGlvbihoLGUpe2UuZj1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzfSxmdW5jdGlvbihoLGUpe2UuZj17fS5wcm9wZXJ0eUlzRW51bWVyYWJsZX0sZnVuY3Rpb24oaCxlLHQpe2UuX19lc01vZHVsZT0hMCxlLmRlZmF1bHQ9ZnVuY3Rpb24ocixuKXtpZighKHIgaW5zdGFuY2VvZiBuKSl0aHJvdyBuZXcgVHlwZUVycm9yKCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24iKX19LGZ1bmN0aW9uKGgsZSx0KXtlLl9fZXNNb2R1bGU9ITA7dmFyIHI9dCgxNzIpLG49ZChyKTtmdW5jdGlvbiBkKGcpe3JldHVybiBnJiZnLl9fZXNNb2R1bGU/Zzp7ZGVmYXVsdDpnfX1lLmRlZmF1bHQ9ZnVuY3Rpb24oKXtmdW5jdGlvbiBnKHUsbyl7Zm9yKHZhciBmPTA7ZjxvLmxlbmd0aDtmKyspe3ZhciB4PW9bZl07eC5lbnVtZXJhYmxlPXguZW51bWVyYWJsZXx8ITEseC5jb25maWd1cmFibGU9ITAsInZhbHVlImluIHgmJih4LndyaXRhYmxlPSEwKSwoMCxuLmRlZmF1bHQpKHUseC5rZXkseCl9fXJldHVybiBmdW5jdGlvbih1LG8sZil7cmV0dXJuIG8mJmcodS5wcm90b3R5cGUsbyksZiYmZyh1LGYpLHV9fSgpfSxmdW5jdGlvbihoLGUsdCl7aC5leHBvcnRzPXtkZWZhdWx0OnQoMTczKSxfX2VzTW9kdWxlOiEwfX0sZnVuY3Rpb24oaCxlLHQpe3QoMTc0KTt2YXIgcj10KDkyKS5PYmplY3Q7aC5leHBvcnRzPWZ1bmN0aW9uKGQsZyx1KXtyZXR1cm4gci5kZWZpbmVQcm9wZXJ0eShkLGcsdSl9fSxmdW5jdGlvbihoLGUsdCl7dmFyIHI9dCg5MCk7cihyLlMrci5GKiF0KDEwMCksIk9iamVjdCIse2RlZmluZVByb3BlcnR5OnQoOTYpLmZ9KX0sZnVuY3Rpb24oaCxlLHQpe2guZXhwb3J0cz17ZGVmYXVsdDp0KDE3NiksX19lc01vZHVsZTohMH19LGZ1bmN0aW9uKGgsZSx0KXt0KDE3NyksdCgxNDMpLHQoMTg0KSx0KDE4NSksaC5leHBvcnRzPXQoOTIpLlN5bWJvbH0sZnVuY3Rpb24oaCxlLHQpe3ZhciByPXQoOTEpLG49dCgxMDUpLGQ9dCgxMDApLGc9dCg5MCksdT10KDEwNiksbz10KDE1MCkuS0VZLGY9dCgxMDEpLHg9dCgxMTcpLGM9dCgxMjEpLHY9dCgxMTgpLHA9dCgxMjIpLGI9dCgxNzgpLEU9dCgxNzkpLHk9dCgxODApLE09dCgxNTYpLGk9dCg5NyksYT10KDk4KSxzPXQoMTI0KSxsPXQoODQpLE89dCgxMDMpLEE9dCgxMDQpLFI9dCgxMDgpLEk9dCgxODEpLFA9dCgxODMpLEw9dCgxNjgpLEQ9dCg5NiksQz10KDExMCksUz1QLmYsQj1ELmYsdz1JLmYsSD1yLlN5bWJvbCxKPXIuSlNPTixxPUomJkouc3RyaW5naWZ5LFU9InByb3RvdHlwZSIsRz1wKCJfaGlkZGVuIiksWj1wKCJ0b1ByaW1pdGl2ZSIpLHR0PXt9LnByb3BlcnR5SXNFbnVtZXJhYmxlLF89eCgic3ltYm9sLXJlZ2lzdHJ5Iiksc3Q9eCgic3ltYm9scyIpLGs9eCgib3Atc3ltYm9scyIpLGh0PU9iamVjdFtVXSxmdD10eXBlb2YgSD09ImZ1bmN0aW9uIiYmISFMLmYsVz1yLlFPYmplY3QsRj0hV3x8IVdbVV18fCFXW1VdLmZpbmRDaGlsZCxWPWQmJmYoZnVuY3Rpb24oKXtyZXR1cm4gUihCKHt9LCJhIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIEIodGhpcywiYSIse3ZhbHVlOjd9KS5hfX0pKS5hIT03fSk/ZnVuY3Rpb24oaXQsbnQsYXQpe3ZhciBkdD1TKGh0LG50KTtkdCYmZGVsZXRlIGh0W250XSxCKGl0LG50LGF0KSxkdCYmaXQhPT1odCYmQihodCxudCxkdCl9OkIsWD1mdW5jdGlvbihpdCl7dmFyIG50PXN0W2l0XT1SKEhbVV0pO3JldHVybiBudC5faz1pdCxudH0saj1mdCYmdHlwZW9mIEguaXRlcmF0b3I9PSJzeW1ib2wiP2Z1bmN0aW9uKGl0KXtyZXR1cm4gdHlwZW9mIGl0PT0ic3ltYm9sIn06ZnVuY3Rpb24oaXQpe3JldHVybiBpdCBpbnN0YW5jZW9mIEh9LHo9ZnVuY3Rpb24obnQsYXQsZHQpe3JldHVybiBudD09PWh0JiZ6KGssYXQsZHQpLGkobnQpLGF0PU8oYXQsITApLGkoZHQpLG4oc3QsYXQpPyhkdC5lbnVtZXJhYmxlPyhuKG50LEcpJiZudFtHXVthdF0mJihudFtHXVthdF09ITEpLGR0PVIoZHQse2VudW1lcmFibGU6QSgwLCExKX0pKToobihudCxHKXx8QihudCxHLEEoMSx7fSkpLG50W0ddW2F0XT0hMCksVihudCxhdCxkdCkpOkIobnQsYXQsZHQpfSxtPWZ1bmN0aW9uKG50LGF0KXtpKG50KTtmb3IodmFyIGR0PXkoYXQ9bChhdCkpLGd0PTAsdXQ9ZHQubGVuZ3RoLG10O3V0Pmd0Oyl6KG50LG10PWR0W2d0KytdLGF0W210XSk7cmV0dXJuIG50fSxUPWZ1bmN0aW9uKG50LGF0KXtyZXR1cm4gYXQ9PT12b2lkIDA/UihudCk6bShSKG50KSxhdCl9LE49ZnVuY3Rpb24obnQpe3ZhciBhdD10dC5jYWxsKHRoaXMsbnQ9TyhudCwhMCkpO3JldHVybiB0aGlzPT09aHQmJm4oc3QsbnQpJiYhbihrLG50KT8hMTphdHx8IW4odGhpcyxudCl8fCFuKHN0LG50KXx8bih0aGlzLEcpJiZ0aGlzW0ddW250XT9hdDohMH0sJD1mdW5jdGlvbihudCxhdCl7aWYobnQ9bChudCksYXQ9TyhhdCwhMCksIShudD09PWh0JiZuKHN0LGF0KSYmIW4oayxhdCkpKXt2YXIgZHQ9UyhudCxhdCk7cmV0dXJuIGR0JiZuKHN0LGF0KSYmIShuKG50LEcpJiZudFtHXVthdF0pJiYoZHQuZW51bWVyYWJsZT0hMCksZHR9fSxLPWZ1bmN0aW9uKG50KXtmb3IodmFyIGF0PXcobChudCkpLGR0PVtdLGd0PTAsdXQ7YXQubGVuZ3RoPmd0OykhbihzdCx1dD1hdFtndCsrXSkmJnV0IT1HJiZ1dCE9byYmZHQucHVzaCh1dCk7cmV0dXJuIGR0fSxZPWZ1bmN0aW9uKG50KXtmb3IodmFyIGF0PW50PT09aHQsZHQ9dyhhdD9rOmwobnQpKSxndD1bXSx1dD0wLG10O2R0Lmxlbmd0aD51dDspbihzdCxtdD1kdFt1dCsrXSkmJighYXR8fG4oaHQsbXQpKSYmZ3QucHVzaChzdFttdF0pO3JldHVybiBndH07ZnR8fChIPWZ1bmN0aW9uKCl7aWYodGhpcyBpbnN0YW5jZW9mIEgpdGhyb3cgVHlwZUVycm9yKCJTeW1ib2wgaXMgbm90IGEgY29uc3RydWN0b3IhIik7dmFyIG50PXYoYXJndW1lbnRzLmxlbmd0aD4wP2FyZ3VtZW50c1swXTp2b2lkIDApLGF0PWZ1bmN0aW9uKGR0KXt0aGlzPT09aHQmJmF0LmNhbGwoayxkdCksbih0aGlzLEcpJiZuKHRoaXNbR10sbnQpJiYodGhpc1tHXVtudF09ITEpLFYodGhpcyxudCxBKDEsZHQpKX07cmV0dXJuIGQmJkYmJlYoaHQsbnQse2NvbmZpZ3VyYWJsZTohMCxzZXQ6YXR9KSxYKG50KX0sdShIW1VdLCJ0b1N0cmluZyIsZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fa30pLFAuZj0kLEQuZj16LHQoMTgyKS5mPUkuZj1LLHQoMTY5KS5mPU4sTC5mPVksZCYmIXQoODkpJiZ1KGh0LCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsTiwhMCksYi5mPWZ1bmN0aW9uKGl0KXtyZXR1cm4gWChwKGl0KSl9KSxnKGcuRytnLlcrZy5GKiFmdCx7U3ltYm9sOkh9KTtmb3IodmFyIFE9Imhhc0luc3RhbmNlLGlzQ29uY2F0U3ByZWFkYWJsZSxpdGVyYXRvcixtYXRjaCxyZXBsYWNlLHNlYXJjaCxzcGVjaWVzLHNwbGl0LHRvUHJpbWl0aXZlLHRvU3RyaW5nVGFnLHVuc2NvcGFibGVzIi5zcGxpdCgiLCIpLGV0PTA7US5sZW5ndGg+ZXQ7KXAoUVtldCsrXSk7Zm9yKHZhciBydD1DKHAuc3RvcmUpLG90PTA7cnQubGVuZ3RoPm90OylFKHJ0W290KytdKTtnKGcuUytnLkYqIWZ0LCJTeW1ib2wiLHtmb3I6ZnVuY3Rpb24oaXQpe3JldHVybiBuKF8saXQrPSIiKT9fW2l0XTpfW2l0XT1IKGl0KX0sa2V5Rm9yOmZ1bmN0aW9uKG50KXtpZighaihudCkpdGhyb3cgVHlwZUVycm9yKG50KyIgaXMgbm90IGEgc3ltYm9sISIpO2Zvcih2YXIgYXQgaW4gXylpZihfW2F0XT09PW50KXJldHVybiBhdH0sdXNlU2V0dGVyOmZ1bmN0aW9uKCl7Rj0hMH0sdXNlU2ltcGxlOmZ1bmN0aW9uKCl7Rj0hMX19KSxnKGcuUytnLkYqIWZ0LCJPYmplY3QiLHtjcmVhdGU6VCxkZWZpbmVQcm9wZXJ0eTp6LGRlZmluZVByb3BlcnRpZXM6bSxnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6JCxnZXRPd25Qcm9wZXJ0eU5hbWVzOkssZ2V0T3duUHJvcGVydHlTeW1ib2xzOll9KTt2YXIgbHQ9ZihmdW5jdGlvbigpe0wuZigxKX0pO2coZy5TK2cuRipsdCwiT2JqZWN0Iix7Z2V0T3duUHJvcGVydHlTeW1ib2xzOmZ1bmN0aW9uKG50KXtyZXR1cm4gTC5mKHMobnQpKX19KSxKJiZnKGcuUytnLkYqKCFmdHx8ZihmdW5jdGlvbigpe3ZhciBpdD1IKCk7cmV0dXJuIHEoW2l0XSkhPSJbbnVsbF0ifHxxKHthOml0fSkhPSJ7fSJ8fHEoT2JqZWN0KGl0KSkhPSJ7fSJ9KSksIkpTT04iLHtzdHJpbmdpZnk6ZnVuY3Rpb24obnQpe2Zvcih2YXIgYXQ9W250XSxkdD0xLGd0LHV0O2FyZ3VtZW50cy5sZW5ndGg+ZHQ7KWF0LnB1c2goYXJndW1lbnRzW2R0KytdKTtpZih1dD1ndD1hdFsxXSwhKCFhKGd0KSYmbnQ9PT12b2lkIDB8fGoobnQpKSlyZXR1cm4gTShndCl8fChndD1mdW5jdGlvbihtdCxQdCl7aWYodHlwZW9mIHV0PT0iZnVuY3Rpb24iJiYoUHQ9dXQuY2FsbCh0aGlzLG10LFB0KSksIWooUHQpKXJldHVybiBQdH0pLGF0WzFdPWd0LHEuYXBwbHkoSixhdCl9fSksSFtVXVtaXXx8dCg5NSkoSFtVXSxaLEhbVV0udmFsdWVPZiksYyhILCJTeW1ib2wiKSxjKE1hdGgsIk1hdGgiLCEwKSxjKHIuSlNPTiwiSlNPTiIsITApfSxmdW5jdGlvbihoLGUsdCl7ZS5mPXQoMTIyKX0sZnVuY3Rpb24oaCxlLHQpe3ZhciByPXQoOTEpLG49dCg5MiksZD10KDg5KSxnPXQoMTc4KSx1PXQoOTYpLmY7aC5leHBvcnRzPWZ1bmN0aW9uKG8pe3ZhciBmPW4uU3ltYm9sfHwobi5TeW1ib2w9ZD97fTpyLlN5bWJvbHx8e30pO28uY2hhckF0KDApIT0iXyImJiEobyBpbiBmKSYmdShmLG8se3ZhbHVlOmcuZihvKX0pfX0sZnVuY3Rpb24oaCxlLHQpe3ZhciByPXQoMTEwKSxuPXQoMTY4KSxkPXQoMTY5KTtoLmV4cG9ydHM9ZnVuY3Rpb24oZyl7dmFyIHU9cihnKSxvPW4uZjtpZihvKWZvcih2YXIgZj1vKGcpLHg9ZC5mLGM9MCx2O2YubGVuZ3RoPmM7KXguY2FsbChnLHY9ZltjKytdKSYmdS5wdXNoKHYpO3JldHVybiB1fX0sZnVuY3Rpb24oaCxlLHQpe3ZhciByPXQoODQpLG49dCgxODIpLmYsZD17fS50b1N0cmluZyxnPXR5cGVvZiB3aW5kb3c9PSJvYmplY3QiJiZ3aW5kb3cmJk9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzP09iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHdpbmRvdyk6W10sdT1mdW5jdGlvbihvKXt0cnl7cmV0dXJuIG4obyl9Y2F0Y2h7cmV0dXJuIGcuc2xpY2UoKX19O2guZXhwb3J0cy5mPWZ1bmN0aW9uKGYpe3JldHVybiBnJiZkLmNhbGwoZik9PSJbb2JqZWN0IFdpbmRvd10iP3UoZik6bihyKGYpKX19LGZ1bmN0aW9uKGgsZSx0KXt2YXIgcj10KDExMSksbj10KDExOSkuY29uY2F0KCJsZW5ndGgiLCJwcm90b3R5cGUiKTtlLmY9T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXN8fGZ1bmN0aW9uKGcpe3JldHVybiByKGcsbil9fSxmdW5jdGlvbihoLGUsdCl7dmFyIHI9dCgxNjkpLG49dCgxMDQpLGQ9dCg4NCksZz10KDEwMyksdT10KDEwNSksbz10KDk5KSxmPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7ZS5mPXQoMTAwKT9mOmZ1bmN0aW9uKGMsdil7aWYoYz1kKGMpLHY9Zyh2LCEwKSxvKXRyeXtyZXR1cm4gZihjLHYpfWNhdGNoe31pZih1KGMsdikpcmV0dXJuIG4oIXIuZi5jYWxsKGMsdiksY1t2XSl9fSxmdW5jdGlvbihoLGUsdCl7dCgxNzkpKCJhc3luY0l0ZXJhdG9yIil9LGZ1bmN0aW9uKGgsZSx0KXt0KDE3OSkoIm9ic2VydmFibGUiKX0sZnVuY3Rpb24oaCxlLHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxlLmNyZWF0ZU5vd1RpbWU9cixlLmZvcm1hdERlbGF5PW47ZnVuY3Rpb24gcigpe3ZhciBkPW51bGw7cmV0dXJuIERhdGUubm93P2Q9RGF0ZS5ub3c6ZD1mdW5jdGlvbigpe3JldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKX0sZH1mdW5jdGlvbiBuKGQpe3JldHVybiB0eXBlb2YgZD09Im51bWJlciI/ZD17ZGVsYXk6ZH06ImVudHJvcHkiaW4gZCYmKGQ9e2RlbGF5OmQuZW50cm9weSxpc0VudHJvcHk6ITB9KSxkfX0sZnVuY3Rpb24oaCxlLHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxlLmRlZmF1bHQ9e2RlZmF1bHQ6ZnVuY3Rpb24obixkLGcsdSxvKXtyZXR1cm4gdHlwZW9mIG49PSJudW1iZXIiJiZ0eXBlb2YgZD09Im51bWJlciI/bisoZy11KS8oby11KSooZC1uKTpnLXU+by1nP2Q6bn19fSxmdW5jdGlvbihoLGUsdCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLGUucGFyc2VFYXNpbmc9ZS5FYXNpbmdzPXZvaWQgMDt2YXIgcj10KDc2KSxuPWYociksZD10KDEzMyksZz1mKGQpLHU9dCgxNDEpLG89Zih1KTtmdW5jdGlvbiBmKE0pe3JldHVybiBNJiZNLl9fZXNNb2R1bGU/TTp7ZGVmYXVsdDpNfX12YXIgeD10KDE4OSksYz1uZXcgby5kZWZhdWx0O2Z1bmN0aW9uIHYoKXtmb3IodmFyIE09YXJndW1lbnRzLmxlbmd0aCxpPUFycmF5KE0pLGE9MDthPE07YSsrKWlbYV09YXJndW1lbnRzW2FdO3ZhciBzPWMuZ2V0KGkpO3JldHVybiBzfHwocz14LmFwcGx5KHZvaWQgMCxpKSxjLnNldChpLHMpLHMpfWZ1bmN0aW9uIHAoTSl7dmFyIGk9YXJndW1lbnRzLmxlbmd0aD4xJiZhcmd1bWVudHNbMV0hPT12b2lkIDA/YXJndW1lbnRzWzFdOiJlbmQiO3JldHVybiBmdW5jdGlvbihhLHMpe2Zvcih2YXIgbD0xO2w8cy5sZW5ndGg7bCsrKXt2YXIgTz1zW2xdLm9mZnNldDtpZihhPD1PKXt2YXIgQT1zW2wtMV0ub2Zmc2V0LFI9TyxJPShhLUEpLyhSLUEpLFA9MS9NLEw9SS9QO3JldHVybiBpPT09ImVuZCI/TD1NYXRoLmZsb29yKEwpOkw9TWF0aC5jZWlsKEwpLFAqTCooUi1BKStBfX1yZXR1cm4gMH19ZnVuY3Rpb24gYihNKXt2YXIgaT0vXmN1YmljLWJlemllclwoKC4qKVwpLyxhPU0ubWF0Y2goaSk7aWYoYSl7dmFyIHM9YVsxXS50cmltKCk7cmV0dXJuIHM9cy5zcGxpdCgiLCIpLm1hcChmdW5jdGlvbihQKXtyZXR1cm4gcGFyc2VGbG9hdChQLnRyaW0oKSl9KSx2LmFwcGx5KHZvaWQgMCwoMCxnLmRlZmF1bHQpKHMpKX1pZihpPS9ec3RlcHNcKCguKilcKS8sYT1NLm1hdGNoKGkpLGEpe3ZhciBsPWFbMV0udHJpbSgpO2w9bC5zcGxpdCgiLCIpLm1hcChmdW5jdGlvbihQKXtyZXR1cm4gUC50cmltKCl9KTt2YXIgTz1sLEE9KDAsbi5kZWZhdWx0KShPLDIpLFI9QVswXSxJPUFbMV07cmV0dXJuIHAocGFyc2VJbnQoUiwxMCksSSl9cmV0dXJuIE19dmFyIEU9e2xpbmVhcjpmdW5jdGlvbihpKXtyZXR1cm4gaX0sZWFzZTp2KC4yNSwuMSwuMjUsMSksImVhc2UtaW4iOnYoLjQyLDAsMSwxKSwiZWFzZS1vdXQiOnYoMCwwLC41OCwxKSwiZWFzZS1pbi1vdXQiOnYoLjQyLDAsLjU4LDEpLCJzdGVwLXN0YXJ0IjpwKDEsInN0YXJ0IiksInN0ZXAtZW5kIjpwKDEsImVuZCIpfTtmdW5jdGlvbiB5KE0pe3JldHVybiB0eXBlb2YgTT09InN0cmluZyI/RVtNXT9NPUVbTV06TT1iKE0pOk0udHlwZT09PSJjdWJpYy1iZXppZXIiP009di5hcHBseSh2b2lkIDAsKDAsZy5kZWZhdWx0KShNLnZhbHVlKSk6TS50eXBlPT09InN0ZXBzIiYmKE09cChNLnN0ZXAsTS5wb3MpKSxNfWUuRWFzaW5ncz1FLGUucGFyc2VFYXNpbmc9eX0sZnVuY3Rpb24oaCxlKXt2YXIgdD00LHI9LjAwMSxuPTFlLTcsZD0xMCxnPTExLHU9MS8oZy0xKSxvPXR5cGVvZiBGbG9hdDMyQXJyYXk9PSJmdW5jdGlvbiI7ZnVuY3Rpb24gZihNLGkpe3JldHVybiAxLTMqaSszKk19ZnVuY3Rpb24geChNLGkpe3JldHVybiAzKmktNipNfWZ1bmN0aW9uIGMoTSl7cmV0dXJuIDMqTX1mdW5jdGlvbiB2KE0saSxhKXtyZXR1cm4oKGYoaSxhKSpNK3goaSxhKSkqTStjKGkpKSpNfWZ1bmN0aW9uIHAoTSxpLGEpe3JldHVybiAzKmYoaSxhKSpNKk0rMip4KGksYSkqTStjKGkpfWZ1bmN0aW9uIGIoTSxpLGEscyxsKXt2YXIgTyxBLFI9MDtkbyBBPWkrKGEtaSkvMixPPXYoQSxzLGwpLU0sTz4wP2E9QTppPUE7d2hpbGUoTWF0aC5hYnMoTyk+biYmKytSPGQpO3JldHVybiBBfWZ1bmN0aW9uIEUoTSxpLGEscyl7Zm9yKHZhciBsPTA7bDx0OysrbCl7dmFyIE89cChpLGEscyk7aWYoTz09PTApcmV0dXJuIGk7dmFyIEE9dihpLGEscyktTTtpLT1BL099cmV0dXJuIGl9ZnVuY3Rpb24geShNKXtyZXR1cm4gTX1oLmV4cG9ydHM9ZnVuY3Rpb24oaSxhLHMsbCl7aWYoISgwPD1pJiZpPD0xJiYwPD1zJiZzPD0xKSl0aHJvdyBuZXcgRXJyb3IoImJlemllciB4IHZhbHVlcyBtdXN0IGJlIGluIFswLCAxXSByYW5nZSIpO2lmKGk9PT1hJiZzPT09bClyZXR1cm4geTtmb3IodmFyIE89bz9uZXcgRmxvYXQzMkFycmF5KGcpOm5ldyBBcnJheShnKSxBPTA7QTxnOysrQSlPW0FdPXYoQSp1LGkscyk7ZnVuY3Rpb24gUihJKXtmb3IodmFyIFA9MCxMPTEsRD1nLTE7TCE9PUQmJk9bTF08PUk7KytMKVArPXU7LS1MO3ZhciBDPShJLU9bTF0pLyhPW0wrMV0tT1tMXSksUz1QK0MqdSxCPXAoUyxpLHMpO3JldHVybiBCPj1yP0UoSSxTLGkscyk6Qj09PTA/UzpiKEksUCxQK3UsaSxzKX1yZXR1cm4gZnVuY3Rpb24oUCl7cmV0dXJuIFA9PT0wPzA6UD09PTE/MTp2KFIoUCksYSxsKX19fSxmdW5jdGlvbihoLGUsdCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pO3ZhciByPXQoMTkxKSxuPWEociksZD10KDIwNCksZz1hKGQpLHU9dCgxNjQpLG89YSh1KSxmPXQoMTcwKSx4PWEoZiksYz10KDE3MSksdj1hKGMpLHA9dCgxNzUpLGI9YShwKSxFPXQoNzUpLHk9YShFKSxNPXQoMjA4KSxpPXQoMTg4KTtmdW5jdGlvbiBhKEIpe3JldHVybiBCJiZCLl9fZXNNb2R1bGU/Qjp7ZGVmYXVsdDpCfX12YXIgcz0oMCxiLmRlZmF1bHQpKCJ0aW1pbmciKSxsPSgwLGIuZGVmYXVsdCkoImtleWZyYW1lcyIpLE89KDAsYi5kZWZhdWx0KSgiaW5pdFN0YXRlIiksQT0oMCxiLmRlZmF1bHQpKCJyZWFkeURlZmVyIiksUj0oMCxiLmRlZmF1bHQpKCJmaW5pc2hlZERlZmVyIiksST0oMCxiLmRlZmF1bHQpKCJlZmZlY3RzIiksUD0oMCxiLmRlZmF1bHQpKCJhY3RpdmVSZWFkeVRpbWVyIiksTD0oMCxiLmRlZmF1bHQpKCJhY3RpdmVGaW5pc2hUaW1lciIpLEQ9KDAsYi5kZWZhdWx0KSgicmVtb3ZlRGVmZXIiKSxDPXtkZWxheTowLGVuZERlbGF5OjAsZmlsbDoiYXV0byIsaXRlcmF0aW9uczoxLHBsYXliYWNrUmF0ZToxLGRpcmVjdGlvbjoibm9ybWFsIixlYXNpbmc6ImxpbmVhciIsZWZmZWN0Om51bGx9LFM9ZnVuY3Rpb24oKXtmdW5jdGlvbiBCKHcsSCxKKXt2YXIgcT10aGlzO2lmKCgwLHguZGVmYXVsdCkodGhpcyxCKSxBcnJheS5pc0FycmF5KHcpKXt2YXIgVT1bd1swXSx3LEhdO3c9VVswXSxIPVVbMV0sSj1VWzJdfXR5cGVvZiBKPT0ibnVtYmVyIiYmKEo9e2R1cmF0aW9uOkp9KSx0aGlzW3NdPSgwLG8uZGVmYXVsdCkoe30sQyxKKSx0aGlzW3NdLmVhc2luZz0oMCxpLnBhcnNlRWFzaW5nKSh0aGlzW3NdLmVhc2luZyksdGhpc1tsXT0oMCxNLmNhbGN1bGF0ZUZyYW1lc09mZnNldCkoSCk7dmFyIEc9dGhpc1tsXVt0aGlzW2xdLmxlbmd0aC0xXTt0aGlzW09dPXt9LCgwLGcuZGVmYXVsdCkoRykuZm9yRWFjaChmdW5jdGlvbihaKXtPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodyxaKSYmWiE9PSJlYXNpbmciJiZaIT09Im9mZnNldCImJihxW09dW1pdPXdbWl0pfSksdGhpc1tsXT10aGlzW2xdLm1hcChmdW5jdGlvbihaKXtyZXR1cm4oMCxvLmRlZmF1bHQpKHt9LHFbT10sWil9KSx0aGlzW2xdWzBdLm9mZnNldCE9PTAmJnRoaXNbbF0udW5zaGlmdCgoMCxvLmRlZmF1bHQpKHt9LHRoaXNbT10se29mZnNldDowfSkpLEcub2Zmc2V0PDEmJnRoaXNbbF0ucHVzaCgoMCxvLmRlZmF1bHQpKHt9LEcse29mZnNldDoxfSkpLHRoaXNbSV09e30sdGhpcy50aW1lbGluZT1udWxsfXJldHVybigwLHYuZGVmYXVsdCkoQixbe2tleToicGF1c2UiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy50aW1lbGluZS5wbGF5YmFja1JhdGU9MH19LHtrZXk6UCx2YWx1ZTpmdW5jdGlvbigpe3ZhciBIPXRoaXM7dGhpc1tBXSYmIXRoaXNbQV0udGltZXJJRCYmKHRoaXMudGltZWxpbmUuY3VycmVudFRpbWU8MD90aGlzW0FdLnRpbWVySUQ9dGhpcy50aW1lbGluZS5zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7SFtBXS5yZXNvbHZlKCksZGVsZXRlIEhbQV19LHtkZWxheTotdGhpcy50aW1lbGluZS5jdXJyZW50VGltZSxoZWFkaW5nOiExfSk6dGhpc1tBXS50aW1lcklEPXRoaXMudGltZWxpbmUuc2V0VGltZW91dChmdW5jdGlvbigpe0hbQV0ucmVzb2x2ZSgpLGRlbGV0ZSBIW0FdfSx7ZGVsYXk6MCxpc0VudHJvcHk6ITB9KSl9fSx7a2V5OkwsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgSD10aGlzLEo9dGhpc1tzXSxxPUouZHVyYXRpb24sVT1KLml0ZXJhdGlvbnMsRz1KLmVuZERlbGF5LFo9TWF0aC5jZWlsKHEqVStHLXRoaXMudGltZWxpbmUuY3VycmVudFRpbWUpKzE7dGhpc1tSXSYmIXRoaXNbUl0udGltZXJJRCYmKHRoaXNbUl0udGltZXJJRD10aGlzLnRpbWVsaW5lLnNldFRpbWVvdXQoZnVuY3Rpb24oKXtIW1JdLnJlc29sdmUoKSxIW0RdKEEpLEhbRF0oUil9LHtkZWxheTpaLGhlYWRpbmc6ITF9KSx0aGlzW1JdLnJldmVyc2VUaW1lcklEPXRoaXMudGltZWxpbmUuc2V0VGltZW91dChmdW5jdGlvbigpe0hbUl0ucmVzb2x2ZSgpLEhbRF0oQSksSFtEXShSKSxILnRpbWVsaW5lPW51bGx9LHtkZWxheTotdGhpc1tzXS5kZWxheS0xLGhlYWRpbmc6ITF9KSl9fSx7a2V5OiJwbGF5Iix2YWx1ZTpmdW5jdGlvbigpe2lmKHRoaXMucGxheVN0YXRlPT09ImZpbmlzaGVkIiYmdGhpcy5jYW5jZWwoKSx0aGlzLnBsYXlTdGF0ZT09PSJpZGxlIil7aWYodGhpcy5wbGF5YmFja1JhdGU8PTApcmV0dXJuO3ZhciBIPXRoaXNbc10sSj1ILmRlbGF5LHE9SC5wbGF5YmFja1JhdGUsVT1ILnRpbWVsaW5lO3RoaXMudGltZWxpbmU9bmV3IHkuZGVmYXVsdCh7b3JpZ2luVGltZTpKLHBsYXliYWNrUmF0ZTpxfSxVKSx0aGlzW1BdKCksdGhpc1tMXSgpfWVsc2UgdGhpcy5wbGF5U3RhdGU9PT0icGF1c2VkIiYmKHRoaXMudGltZWxpbmUucGxheWJhY2tSYXRlPXRoaXMucGxheWJhY2tSYXRlLHRoaXNbUF0oKSl9fSx7a2V5OkQsdmFsdWU6ZnVuY3Rpb24oSCl7dmFyIEo9dGhpc1tIXSxxPXRoaXMudGltZWxpbmU7SiYmcSYmKHEuY2xlYXJUaW1lb3V0KEoudGltZXJJRCksSi5yZXZlcnNlVGltZXJJRCYmcS5jbGVhclRpbWVvdXQoSi5yZXZlcnNlVGltZXJJRCkpLGRlbGV0ZSB0aGlzW0hdfX0se2tleToiY2FuY2VsIix2YWx1ZTpmdW5jdGlvbigpe3RoaXNbRF0oQSksdGhpc1tEXShSKSx0aGlzLnRpbWVsaW5lPW51bGx9fSx7a2V5OiJmaW5pc2giLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy50aW1lbGluZSYmKHRoaXMudGltZWxpbmUuY3VycmVudFRpbWU9MS8wL3RoaXMucGxheWJhY2tSYXRlKSx0aGlzW0RdKEEpLHRoaXNbRF0oUil9fSx7a2V5OiJhcHBseUVmZmVjdHMiLHZhbHVlOmZ1bmN0aW9uKEgpe3JldHVybigwLG8uZGVmYXVsdCkodGhpc1tJXSxIKX19LHtrZXk6InBsYXliYWNrUmF0ZSIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXNbc10ucGxheWJhY2tSYXRlfSxzZXQ6ZnVuY3Rpb24oSCl7dGhpcy50aW1lbGluZSYmKHRoaXMudGltZWxpbmUucGxheWJhY2tSYXRlPUgpLHRoaXNbc10ucGxheWJhY2tSYXRlPUh9fSx7a2V5OiJwbGF5U3RhdGUiLGdldDpmdW5jdGlvbigpe3ZhciBIPXRoaXMudGltZWxpbmUsSj10aGlzW3NdLHE9Si5pdGVyYXRpb25zLFU9Si5kdXJhdGlvbixHPUouZW5kRGVsYXksWj0icnVubmluZyI7aWYoSD09bnVsbClaPSJpZGxlIjtlbHNlIGlmKEgucGF1c2VkKVo9InBhdXNlZCI7ZWxzZSBpZihILmN1cnJlbnRUaW1lPDApWj0icGVuZGluZyI7ZWxzZXt2YXIgdHQ9SC5jdXJyZW50VGltZS1xKlU7dHQ+MCYmdHQ8Rz9aPSJwZW5kaW5nIjp0dD49RyYmKFo9ImZpbmlzaGVkIil9cmV0dXJuIFp9fSx7a2V5OiJwcm9ncmVzcyIsZ2V0OmZ1bmN0aW9uKCl7aWYoIXRoaXMudGltZWxpbmUpcmV0dXJuIDA7dmFyIEg9dGhpc1tzXSxKPUguZHVyYXRpb24scT1ILml0ZXJhdGlvbnMsVT10aGlzLnRpbWVsaW5lLEc9dGhpcy5wbGF5U3RhdGUsWj12b2lkIDA7aWYoRz09PSJpZGxlIilaPTA7ZWxzZSBpZihHPT09InBhdXNlZCImJlUuY3VycmVudFRpbWU8MClaPTA7ZWxzZSBpZihHPT09InBlbmRpbmciKWlmKFUuY3VycmVudFRpbWU8MClaPTA7ZWxzZXt2YXIgdHQ9VS5zZWVrTG9jYWxUaW1lKHEqSik7Wj0oMCxNLnBlcmlvZGljaXR5KSh0dCxKKVsxXS9KfWVsc2UoRz09PSJydW5uaW5nInx8Rz09PSJwYXVzZWQiKSYmKFo9KDAsTS5wZXJpb2RpY2l0eSkoVS5jdXJyZW50VGltZSxKKVsxXS9KKTtyZXR1cm4gRz09PSJmaW5pc2hlZCImJihaPSgwLE0ucGVyaW9kaWNpdHkpKHEsMSlbMV0pLFp9fSx7a2V5OiJmcmFtZSIsZ2V0OmZ1bmN0aW9uKCl7dmFyIEg9dGhpcy5wbGF5U3RhdGUsSj10aGlzW09dLHE9dGhpc1tzXS5maWxsO2lmKEg9PT0iaWRsZSIpcmV0dXJuIEo7dmFyIFU9dGhpcy50aW1lbGluZS5jdXJyZW50VGltZSxHPXRoaXNbbF0uc2xpY2UoMCksWj0oMCxNLmdldFByb2dyZXNzKSh0aGlzLnRpbWVsaW5lLHRoaXNbc10sdGhpcy5wcm9ncmVzcyksdHQ9Wi5wLF89Wi5pbnZlcnRlZCxzdD1KO3JldHVybiBVPDAmJkg9PT0icGVuZGluZyI/KHE9PT0iYmFja3dhcmRzInx8cT09PSJib3RoIikmJihzdD1fP0dbRy5sZW5ndGgtMV06R1swXSk6KEghPT0icGVuZGluZyImJkghPT0iZmluaXNoZWQifHxxPT09ImZvcndhcmRzInx8cT09PSJib3RoIikmJihzdD0oMCxNLmdldEN1cnJlbnRGcmFtZSkodGhpc1tzXSxHLHRoaXNbSV0sdHQpKSxzdH19LHtrZXk6InRpbWluZyIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXNbc119fSx7a2V5OiJlZmZlY3RzIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc1tJXX19LHtrZXk6ImJhc2VUaW1lbGluZSIsc2V0OmZ1bmN0aW9uKEgpe3RoaXNbc10udGltZWxpbmU9SH0sZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXNbc10udGltZWxpbmV9fSx7a2V5OiJyZWFkeSIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXNbQV0/dGhpc1tBXS5wcm9taXNlOnRoaXMudGltZWxpbmUmJnRoaXMudGltZWxpbmUuY3VycmVudFRpbWU+PTAmJnRoaXMucGxheVN0YXRlIT09InBhdXNlZCI/bi5kZWZhdWx0LnJlc29sdmUoKToodGhpc1tBXT0oMCxNLmRlZmVyKSgpLHRoaXMudGltZWxpbmUmJnRoaXNbUF0oKSx0aGlzW0FdP3RoaXNbQV0ucHJvbWlzZTpuLmRlZmF1bHQucmVzb2x2ZSgpKX19LHtrZXk6ImZpbmlzaGVkIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wbGF5U3RhdGU9PT0iZmluaXNoZWQiP24uZGVmYXVsdC5yZXNvbHZlKCk6KHRoaXNbUl18fCh0aGlzW1JdPSgwLE0uZGVmZXIpKCksdGhpcy50aW1lbGluZSYmdGhpc1tMXSgpKSx0aGlzW1JdLnByb21pc2UpfX1dKSxCfSgpO2UuZGVmYXVsdD1TfSxmdW5jdGlvbihoLGUsdCl7aC5leHBvcnRzPXtkZWZhdWx0OnQoMTkyKSxfX2VzTW9kdWxlOiEwfX0sZnVuY3Rpb24oaCxlLHQpe3QoMTQzKSx0KDEyNSksdCg3OSksdCgxOTMpLHQoMjAyKSx0KDIwMyksaC5leHBvcnRzPXQoOTIpLlByb21pc2V9LGZ1bmN0aW9uKGgsZSx0KXt2YXIgcj10KDg5KSxuPXQoOTEpLGQ9dCg5MyksZz10KDEyOCksdT10KDkwKSxvPXQoOTgpLGY9dCg5NCkseD10KDE0NyksYz10KDE0OCksdj10KDE5NCkscD10KDE5NSkuc2V0LGI9dCgxOTcpKCksRT10KDE5OCkseT10KDE5OSksTT10KDIwMCksaT10KDIwMSksYT0iUHJvbWlzZSIscz1uLlR5cGVFcnJvcixsPW4ucHJvY2VzcyxPPWwmJmwudmVyc2lvbnMsQT1PJiZPLnY4fHwiIixSPW5bYV0sST1nKGwpPT0icHJvY2VzcyIsUD1mdW5jdGlvbigpe30sTCxELEMsUyxCPUQ9RS5mLHc9ISFmdW5jdGlvbigpe3RyeXt2YXIgXz1SLnJlc29sdmUoMSksc3Q9KF8uY29uc3RydWN0b3I9e30pW3QoMTIyKSgic3BlY2llcyIpXT1mdW5jdGlvbihrKXtrKFAsUCl9O3JldHVybihJfHx0eXBlb2YgUHJvbWlzZVJlamVjdGlvbkV2ZW50PT0iZnVuY3Rpb24iKSYmXy50aGVuKFApaW5zdGFuY2VvZiBzdCYmQS5pbmRleE9mKCI2LjYiKSE9PTAmJk0uaW5kZXhPZigiQ2hyb21lLzY2Iik9PT0tMX1jYXRjaHt9fSgpLEg9ZnVuY3Rpb24oXyl7dmFyIHN0O3JldHVybiBvKF8pJiZ0eXBlb2Yoc3Q9Xy50aGVuKT09ImZ1bmN0aW9uIj9zdDohMX0sSj1mdW5jdGlvbihfLHN0KXtpZighXy5fbil7Xy5fbj0hMDt2YXIgaz1fLl9jO2IoZnVuY3Rpb24oKXtmb3IodmFyIGh0PV8uX3YsZnQ9Xy5fcz09MSxXPTAsRj1mdW5jdGlvbihWKXt2YXIgWD1mdD9WLm9rOlYuZmFpbCxqPVYucmVzb2x2ZSx6PVYucmVqZWN0LG09Vi5kb21haW4sVCxOLCQ7dHJ5e1g/KGZ0fHwoXy5faD09MiYmRyhfKSxfLl9oPTEpLFg9PT0hMD9UPWh0OihtJiZtLmVudGVyKCksVD1YKGh0KSxtJiYobS5leGl0KCksJD0hMCkpLFQ9PT1WLnByb21pc2U/eihzKCJQcm9taXNlLWNoYWluIGN5Y2xlIikpOihOPUgoVCkpP04uY2FsbChULGoseik6aihUKSk6eihodCl9Y2F0Y2goSyl7bSYmISQmJm0uZXhpdCgpLHooSyl9fTtrLmxlbmd0aD5XOylGKGtbVysrXSk7Xy5fYz1bXSxfLl9uPSExLHN0JiYhXy5faCYmcShfKX0pfX0scT1mdW5jdGlvbihfKXtwLmNhbGwobixmdW5jdGlvbigpe3ZhciBzdD1fLl92LGs9VShfKSxodCxmdCxXO2lmKGsmJihodD15KGZ1bmN0aW9uKCl7ST9sLmVtaXQoInVuaGFuZGxlZFJlamVjdGlvbiIsc3QsXyk6KGZ0PW4ub251bmhhbmRsZWRyZWplY3Rpb24pP2Z0KHtwcm9taXNlOl8scmVhc29uOnN0fSk6KFc9bi5jb25zb2xlKSYmVy5lcnJvciYmVy5lcnJvcigiVW5oYW5kbGVkIHByb21pc2UgcmVqZWN0aW9uIixzdCl9KSxfLl9oPUl8fFUoXyk/MjoxKSxfLl9hPXZvaWQgMCxrJiZodC5lKXRocm93IGh0LnZ9KX0sVT1mdW5jdGlvbihfKXtyZXR1cm4gXy5faCE9PTEmJihfLl9hfHxfLl9jKS5sZW5ndGg9PT0wfSxHPWZ1bmN0aW9uKF8pe3AuY2FsbChuLGZ1bmN0aW9uKCl7dmFyIHN0O0k/bC5lbWl0KCJyZWplY3Rpb25IYW5kbGVkIixfKTooc3Q9bi5vbnJlamVjdGlvbmhhbmRsZWQpJiZzdCh7cHJvbWlzZTpfLHJlYXNvbjpfLl92fSl9KX0sWj1mdW5jdGlvbihfKXt2YXIgc3Q9dGhpcztzdC5fZHx8KHN0Ll9kPSEwLHN0PXN0Ll93fHxzdCxzdC5fdj1fLHN0Ll9zPTIsc3QuX2F8fChzdC5fYT1zdC5fYy5zbGljZSgpKSxKKHN0LCEwKSl9LHR0PWZ1bmN0aW9uKF8pe3ZhciBzdD10aGlzLGs7aWYoIXN0Ll9kKXtzdC5fZD0hMCxzdD1zdC5fd3x8c3Q7dHJ5e2lmKHN0PT09Xyl0aHJvdyBzKCJQcm9taXNlIGNhbid0IGJlIHJlc29sdmVkIGl0c2VsZiIpOyhrPUgoXykpP2IoZnVuY3Rpb24oKXt2YXIgaHQ9e193OnN0LF9kOiExfTt0cnl7ay5jYWxsKF8sZCh0dCxodCwxKSxkKFosaHQsMSkpfWNhdGNoKGZ0KXtaLmNhbGwoaHQsZnQpfX0pOihzdC5fdj1fLHN0Ll9zPTEsSihzdCwhMSkpfWNhdGNoKGh0KXtaLmNhbGwoe193OnN0LF9kOiExfSxodCl9fX07d3x8KFI9ZnVuY3Rpb24oc3Qpe3godGhpcyxSLGEsIl9oIiksZihzdCksTC5jYWxsKHRoaXMpO3RyeXtzdChkKHR0LHRoaXMsMSksZChaLHRoaXMsMSkpfWNhdGNoKGspe1ouY2FsbCh0aGlzLGspfX0sTD1mdW5jdGlvbihzdCl7dGhpcy5fYz1bXSx0aGlzLl9hPXZvaWQgMCx0aGlzLl9zPTAsdGhpcy5fZD0hMSx0aGlzLl92PXZvaWQgMCx0aGlzLl9oPTAsdGhpcy5fbj0hMX0sTC5wcm90b3R5cGU9dCgxNDYpKFIucHJvdG90eXBlLHt0aGVuOmZ1bmN0aW9uKHN0LGspe3ZhciBodD1CKHYodGhpcyxSKSk7cmV0dXJuIGh0Lm9rPXR5cGVvZiBzdD09ImZ1bmN0aW9uIj9zdDohMCxodC5mYWlsPXR5cGVvZiBrPT0iZnVuY3Rpb24iJiZrLGh0LmRvbWFpbj1JP2wuZG9tYWluOnZvaWQgMCx0aGlzLl9jLnB1c2goaHQpLHRoaXMuX2EmJnRoaXMuX2EucHVzaChodCksdGhpcy5fcyYmSih0aGlzLCExKSxodC5wcm9taXNlfSxjYXRjaDpmdW5jdGlvbihfKXtyZXR1cm4gdGhpcy50aGVuKHZvaWQgMCxfKX19KSxDPWZ1bmN0aW9uKCl7dmFyIF89bmV3IEw7dGhpcy5wcm9taXNlPV8sdGhpcy5yZXNvbHZlPWQodHQsXywxKSx0aGlzLnJlamVjdD1kKFosXywxKX0sRS5mPUI9ZnVuY3Rpb24oXyl7cmV0dXJuIF89PT1SfHxfPT09Uz9uZXcgQyhfKTpEKF8pfSksdSh1LkcrdS5XK3UuRiohdyx7UHJvbWlzZTpSfSksdCgxMjEpKFIsYSksdCgxNDkpKGEpLFM9dCg5MilbYV0sdSh1LlMrdS5GKiF3LGEse3JlamVjdDpmdW5jdGlvbihzdCl7dmFyIGs9Qih0aGlzKSxodD1rLnJlamVjdDtyZXR1cm4gaHQoc3QpLGsucHJvbWlzZX19KSx1KHUuUyt1LkYqKHJ8fCF3KSxhLHtyZXNvbHZlOmZ1bmN0aW9uKHN0KXtyZXR1cm4gaShyJiZ0aGlzPT09Uz9SOnRoaXMsc3QpfX0pLHUodS5TK3UuRiohKHcmJnQoMTQwKShmdW5jdGlvbihfKXtSLmFsbChfKS5jYXRjaChQKX0pKSxhLHthbGw6ZnVuY3Rpb24oc3Qpe3ZhciBrPXRoaXMsaHQ9QihrKSxmdD1odC5yZXNvbHZlLFc9aHQucmVqZWN0LEY9eShmdW5jdGlvbigpe3ZhciBWPVtdLFg9MCxqPTE7YyhzdCwhMSxmdW5jdGlvbih6KXt2YXIgbT1YKyssVD0hMTtWLnB1c2godm9pZCAwKSxqKyssay5yZXNvbHZlKHopLnRoZW4oZnVuY3Rpb24oTil7VHx8KFQ9ITAsVlttXT1OLC0tanx8ZnQoVikpfSxXKX0pLC0tanx8ZnQoVil9KTtyZXR1cm4gRi5lJiZXKEYudiksaHQucHJvbWlzZX0scmFjZTpmdW5jdGlvbihzdCl7dmFyIGs9dGhpcyxodD1CKGspLGZ0PWh0LnJlamVjdCxXPXkoZnVuY3Rpb24oKXtjKHN0LCExLGZ1bmN0aW9uKEYpe2sucmVzb2x2ZShGKS50aGVuKGh0LnJlc29sdmUsZnQpfSl9KTtyZXR1cm4gVy5lJiZmdChXLnYpLGh0LnByb21pc2V9fSl9LGZ1bmN0aW9uKGgsZSx0KXt2YXIgcj10KDk3KSxuPXQoOTQpLGQ9dCgxMjIpKCJzcGVjaWVzIik7aC5leHBvcnRzPWZ1bmN0aW9uKGcsdSl7dmFyIG89cihnKS5jb25zdHJ1Y3RvcixmO3JldHVybiBvPT09dm9pZCAwfHwoZj1yKG8pW2RdKT09bnVsbD91Om4oZil9fSxmdW5jdGlvbihoLGUsdCl7dmFyIHI9dCg5Myksbj10KDE5NiksZD10KDEyMCksZz10KDEwMiksdT10KDkxKSxvPXUucHJvY2VzcyxmPXUuc2V0SW1tZWRpYXRlLHg9dS5jbGVhckltbWVkaWF0ZSxjPXUuTWVzc2FnZUNoYW5uZWwsdj11LkRpc3BhdGNoLHA9MCxiPXt9LEU9Im9ucmVhZHlzdGF0ZWNoYW5nZSIseSxNLGksYT1mdW5jdGlvbigpe3ZhciBsPSt0aGlzO2lmKGIuaGFzT3duUHJvcGVydHkobCkpe3ZhciBPPWJbbF07ZGVsZXRlIGJbbF0sTygpfX0scz1mdW5jdGlvbihsKXthLmNhbGwobC5kYXRhKX07KCFmfHwheCkmJihmPWZ1bmN0aW9uKE8pe2Zvcih2YXIgQT1bXSxSPTE7YXJndW1lbnRzLmxlbmd0aD5SOylBLnB1c2goYXJndW1lbnRzW1IrK10pO3JldHVybiBiWysrcF09ZnVuY3Rpb24oKXtuKHR5cGVvZiBPPT0iZnVuY3Rpb24iP086RnVuY3Rpb24oTyksQSl9LHkocCkscH0seD1mdW5jdGlvbihPKXtkZWxldGUgYltPXX0sdCg4Nikobyk9PSJwcm9jZXNzIj95PWZ1bmN0aW9uKGwpe28ubmV4dFRpY2socihhLGwsMSkpfTp2JiZ2Lm5vdz95PWZ1bmN0aW9uKGwpe3Yubm93KHIoYSxsLDEpKX06Yz8oTT1uZXcgYyxpPU0ucG9ydDIsTS5wb3J0MS5vbm1lc3NhZ2U9cyx5PXIoaS5wb3N0TWVzc2FnZSxpLDEpKTp1LmFkZEV2ZW50TGlzdGVuZXImJnR5cGVvZiBwb3N0TWVzc2FnZT09ImZ1bmN0aW9uIiYmIXUuaW1wb3J0U2NyaXB0cz8oeT1mdW5jdGlvbihsKXt1LnBvc3RNZXNzYWdlKGwrIiIsIioiKX0sdS5hZGRFdmVudExpc3RlbmVyKCJtZXNzYWdlIixzLCExKSk6RSBpbiBnKCJzY3JpcHQiKT95PWZ1bmN0aW9uKGwpe2QuYXBwZW5kQ2hpbGQoZygic2NyaXB0IikpW0VdPWZ1bmN0aW9uKCl7ZC5yZW1vdmVDaGlsZCh0aGlzKSxhLmNhbGwobCl9fTp5PWZ1bmN0aW9uKGwpe3NldFRpbWVvdXQocihhLGwsMSksMCl9KSxoLmV4cG9ydHM9e3NldDpmLGNsZWFyOnh9fSxmdW5jdGlvbihoLGUpe2guZXhwb3J0cz1mdW5jdGlvbih0LHIsbil7dmFyIGQ9bj09PXZvaWQgMDtzd2l0Y2goci5sZW5ndGgpe2Nhc2UgMDpyZXR1cm4gZD90KCk6dC5jYWxsKG4pO2Nhc2UgMTpyZXR1cm4gZD90KHJbMF0pOnQuY2FsbChuLHJbMF0pO2Nhc2UgMjpyZXR1cm4gZD90KHJbMF0sclsxXSk6dC5jYWxsKG4sclswXSxyWzFdKTtjYXNlIDM6cmV0dXJuIGQ/dChyWzBdLHJbMV0sclsyXSk6dC5jYWxsKG4sclswXSxyWzFdLHJbMl0pO2Nhc2UgNDpyZXR1cm4gZD90KHJbMF0sclsxXSxyWzJdLHJbM10pOnQuY2FsbChuLHJbMF0sclsxXSxyWzJdLHJbM10pfXJldHVybiB0LmFwcGx5KG4scil9fSxmdW5jdGlvbihoLGUsdCl7dmFyIHI9dCg5MSksbj10KDE5NSkuc2V0LGQ9ci5NdXRhdGlvbk9ic2VydmVyfHxyLldlYktpdE11dGF0aW9uT2JzZXJ2ZXIsZz1yLnByb2Nlc3MsdT1yLlByb21pc2Usbz10KDg2KShnKT09InByb2Nlc3MiO2guZXhwb3J0cz1mdW5jdGlvbigpe3ZhciBmLHgsYyx2PWZ1bmN0aW9uKCl7dmFyIHksTTtmb3IobyYmKHk9Zy5kb21haW4pJiZ5LmV4aXQoKTtmOyl7TT1mLmZuLGY9Zi5uZXh0O3RyeXtNKCl9Y2F0Y2goaSl7dGhyb3cgZj9jKCk6eD12b2lkIDAsaX19eD12b2lkIDAseSYmeS5lbnRlcigpfTtpZihvKWM9ZnVuY3Rpb24oKXtnLm5leHRUaWNrKHYpfTtlbHNlIGlmKGQmJiEoci5uYXZpZ2F0b3ImJnIubmF2aWdhdG9yLnN0YW5kYWxvbmUpKXt2YXIgcD0hMCxiPWRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCIiKTtuZXcgZCh2KS5vYnNlcnZlKGIse2NoYXJhY3RlckRhdGE6ITB9KSxjPWZ1bmN0aW9uKCl7Yi5kYXRhPXA9IXB9fWVsc2UgaWYodSYmdS5yZXNvbHZlKXt2YXIgRT11LnJlc29sdmUodm9pZCAwKTtjPWZ1bmN0aW9uKCl7RS50aGVuKHYpfX1lbHNlIGM9ZnVuY3Rpb24oKXtuLmNhbGwocix2KX07cmV0dXJuIGZ1bmN0aW9uKHkpe3ZhciBNPXtmbjp5LG5leHQ6dm9pZCAwfTt4JiYoeC5uZXh0PU0pLGZ8fChmPU0sYygpKSx4PU19fX0sZnVuY3Rpb24oaCxlLHQpe3ZhciByPXQoOTQpO2Z1bmN0aW9uIG4oZCl7dmFyIGcsdTt0aGlzLnByb21pc2U9bmV3IGQoZnVuY3Rpb24obyxmKXtpZihnIT09dm9pZCAwfHx1IT09dm9pZCAwKXRocm93IFR5cGVFcnJvcigiQmFkIFByb21pc2UgY29uc3RydWN0b3IiKTtnPW8sdT1mfSksdGhpcy5yZXNvbHZlPXIoZyksdGhpcy5yZWplY3Q9cih1KX1oLmV4cG9ydHMuZj1mdW5jdGlvbihkKXtyZXR1cm4gbmV3IG4oZCl9fSxmdW5jdGlvbihoLGUpe2guZXhwb3J0cz1mdW5jdGlvbih0KXt0cnl7cmV0dXJue2U6ITEsdjp0KCl9fWNhdGNoKHIpe3JldHVybntlOiEwLHY6cn19fX0sZnVuY3Rpb24oaCxlLHQpe3ZhciByPXQoOTEpLG49ci5uYXZpZ2F0b3I7aC5leHBvcnRzPW4mJm4udXNlckFnZW50fHwiIn0sZnVuY3Rpb24oaCxlLHQpe3ZhciByPXQoOTcpLG49dCg5OCksZD10KDE5OCk7aC5leHBvcnRzPWZ1bmN0aW9uKGcsdSl7aWYocihnKSxuKHUpJiZ1LmNvbnN0cnVjdG9yPT09ZylyZXR1cm4gdTt2YXIgbz1kLmYoZyksZj1vLnJlc29sdmU7cmV0dXJuIGYodSksby5wcm9taXNlfX0sZnVuY3Rpb24oaCxlLHQpe3ZhciByPXQoOTApLG49dCg5MiksZD10KDkxKSxnPXQoMTk0KSx1PXQoMjAxKTtyKHIuUCtyLlIsIlByb21pc2UiLHtmaW5hbGx5OmZ1bmN0aW9uKG8pe3ZhciBmPWcodGhpcyxuLlByb21pc2V8fGQuUHJvbWlzZSkseD10eXBlb2Ygbz09ImZ1bmN0aW9uIjtyZXR1cm4gdGhpcy50aGVuKHg/ZnVuY3Rpb24oYyl7cmV0dXJuIHUoZixvKCkpLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gY30pfTpvLHg/ZnVuY3Rpb24oYyl7cmV0dXJuIHUoZixvKCkpLnRoZW4oZnVuY3Rpb24oKXt0aHJvdyBjfSl9Om8pfX0pfSxmdW5jdGlvbihoLGUsdCl7dmFyIHI9dCg5MCksbj10KDE5OCksZD10KDE5OSk7cihyLlMsIlByb21pc2UiLHt0cnk6ZnVuY3Rpb24oZyl7dmFyIHU9bi5mKHRoaXMpLG89ZChnKTtyZXR1cm4oby5lP3UucmVqZWN0OnUucmVzb2x2ZSkoby52KSx1LnByb21pc2V9fSl9LGZ1bmN0aW9uKGgsZSx0KXtoLmV4cG9ydHM9e2RlZmF1bHQ6dCgyMDUpLF9fZXNNb2R1bGU6ITB9fSxmdW5jdGlvbihoLGUsdCl7dCgyMDYpLGguZXhwb3J0cz10KDkyKS5PYmplY3Qua2V5c30sZnVuY3Rpb24oaCxlLHQpe3ZhciByPXQoMTI0KSxuPXQoMTEwKTt0KDIwNykoImtleXMiLGZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKGcpe3JldHVybiBuKHIoZykpfX0pfSxmdW5jdGlvbihoLGUsdCl7dmFyIHI9dCg5MCksbj10KDkyKSxkPXQoMTAxKTtoLmV4cG9ydHM9ZnVuY3Rpb24oZyx1KXt2YXIgbz0obi5PYmplY3R8fHt9KVtnXXx8T2JqZWN0W2ddLGY9e307ZltnXT11KG8pLHIoci5TK3IuRipkKGZ1bmN0aW9uKCl7bygxKX0pLCJPYmplY3QiLGYpfX0sZnVuY3Rpb24oaCxlLHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KTt2YXIgcj10KDc2KSxuPWIociksZD10KDIwOSksZz1iKGQpLHU9dCgxNjQpLG89Yih1KSxmPXQoMTkxKSx4PWIoZik7ZS5kZWZlcj1FLGUucGVyaW9kaWNpdHk9eSxlLmNhbGN1bGF0ZUZyYW1lc09mZnNldD1NLGUuZ2V0UHJvZ3Jlc3M9aSxlLmdldEN1cnJlbnRGcmFtZT1zO3ZhciBjPXQoMTg4KSx2PXQoMTg3KSxwPWIodik7ZnVuY3Rpb24gYihsKXtyZXR1cm4gbCYmbC5fX2VzTW9kdWxlP2w6e2RlZmF1bHQ6bH19ZnVuY3Rpb24gRSgpe3ZhciBsPXt9O3JldHVybiBsLnByb21pc2U9bmV3IHguZGVmYXVsdChmdW5jdGlvbihPLEEpe2wucmVzb2x2ZT1PLGwucmVqZWN0PUF9KSxsfWZ1bmN0aW9uIHkobCxPKXt2YXIgQT1NYXRoLmZsb29yKGwvTyksUj1sLUEqTztyZXR1cm4gUj09PTAmJkE+MCYmKFI9TyxBLS0pLFtBLFJdfWZ1bmN0aW9uIE0obCl7bD1sLnNsaWNlKDApO3ZhciBPPWxbMF0sQT1sW2wubGVuZ3RoLTFdO0Eub2Zmc2V0PUEub2Zmc2V0fHwxLE8ub2Zmc2V0PU8ub2Zmc2V0fHwwO2Zvcih2YXIgUj0wLEk9LTEsUD0wO1A8bC5sZW5ndGg7UCsrKXt2YXIgTD1sW1BdO2lmKEwub2Zmc2V0IT1udWxsKXt2YXIgRD1QLUk7aWYoRD4xKWZvcih2YXIgQz0oTC5vZmZzZXQtUikvRCxTPTA7UzxELTE7UysrKWxbSStTKzFdLm9mZnNldD1SK0MqKFMrMSk7Uj1MLm9mZnNldCxJPVB9aWYoTC5lYXNpbmchPW51bGwmJihMLmVhc2luZz0oMCxjLnBhcnNlRWFzaW5nKShMLmVhc2luZykpLFA+MCl7dmFyIEI9bFtQXS5lYXNpbmchPW51bGw7bFtQXT0oMCxvLmRlZmF1bHQpKHt9LGxbUC0xXSxsW1BdKSxCfHxkZWxldGUgbFtQXS5lYXNpbmd9fXJldHVybiBsfWZ1bmN0aW9uIGkobCxPLEEpe3ZhciBSPWwuY3VycmVudFRpbWUsST1PLmRpcmVjdGlvbixQPU8uZHVyYXRpb24sTD0hMTtpZihJPT09InJldmVyc2UiKUE9MS1BLEw9ITA7ZWxzZSBpZihJPT09ImFsdGVybmF0ZSJ8fEk9PT0iYWx0ZXJuYXRlLXJldmVyc2UiKXt2YXIgRD1NYXRoLmZsb29yKFIvUCk7QT09PTEmJkQtLSxEJTJeST09PSJhbHRlcm5hdGUtcmV2ZXJzZSImJihBPTEtQSxMPSEwKX1yZXR1cm57cDpBLGludmVydGVkOkx9fWZ1bmN0aW9uIGEobCxPLEEsUil7dmFyIEk9e307cmV0dXJuKDAsZy5kZWZhdWx0KShPKS5mb3JFYWNoKGZ1bmN0aW9uKFApe3ZhciBMPSgwLG4uZGVmYXVsdCkoUCwyKSxEPUxbMF0sQz1MWzFdO2lmKEQhPT0ib2Zmc2V0IiYmRCE9PSJlYXNpbmciKXt2YXIgUz1BW0RdfHxBLmRlZmF1bHQsQj1TKGxbRF0sQyxSLGwub2Zmc2V0LE8ub2Zmc2V0KTtCIT1udWxsJiYoSVtEXT1CKX19KSxJfWZ1bmN0aW9uIHMobCxPLEEsUil7dmFyIEk9bC5lYXNpbmcsUD1sLmVmZmVjdDtQfHwoQT0oMCxvLmRlZmF1bHQpKHt9LHAuZGVmYXVsdCxBKSk7dmFyIEw9e307Uj1JKFIsTyk7Zm9yKHZhciBEPTE7RDxPLmxlbmd0aDtEKyspe3ZhciBDPU9bRF0sUz1DLm9mZnNldDtpZihTPj1SfHxEPT09Ty5sZW5ndGgtMSl7dmFyIEI9T1tELTFdLHc9Qi5vZmZzZXQsSD1CLmVhc2luZyxKPVI7aWYoSCl7dmFyIHE9Uy13O0o9SCgoUi13KS9xKSpxK3d9UD9MPVAoQixDLEosdyxTKTpMPWEoQixDLEEsSik7YnJlYWt9fXJldHVybiBMfX0sZnVuY3Rpb24oaCxlLHQpe2guZXhwb3J0cz17ZGVmYXVsdDp0KDIxMCksX19lc01vZHVsZTohMH19LGZ1bmN0aW9uKGgsZSx0KXt0KDIxMSksaC5leHBvcnRzPXQoOTIpLk9iamVjdC5lbnRyaWVzfSxmdW5jdGlvbihoLGUsdCl7dmFyIHI9dCg5MCksbj10KDIxMikoITApO3Ioci5TLCJPYmplY3QiLHtlbnRyaWVzOmZ1bmN0aW9uKGcpe3JldHVybiBuKGcpfX0pfSxmdW5jdGlvbihoLGUsdCl7dmFyIHI9dCgxMDApLG49dCgxMTApLGQ9dCg4NCksZz10KDE2OSkuZjtoLmV4cG9ydHM9ZnVuY3Rpb24odSl7cmV0dXJuIGZ1bmN0aW9uKG8pe2Zvcih2YXIgZj1kKG8pLHg9bihmKSxjPXgubGVuZ3RoLHY9MCxwPVtdLGI7Yz52OyliPXhbdisrXSwoIXJ8fGcuY2FsbChmLGIpKSYmcC5wdXNoKHU/W2IsZltiXV06ZltiXSk7cmV0dXJuIHB9fX0sZnVuY3Rpb24oaCxlLHQpe3QucihlKSx0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3Qgcj1uZXcgTWFwO2Z1bmN0aW9uIG4oZyx1PXt9LG89W10pe2c9Zy50b0xvd2VyQ2FzZSgpO2NvbnN0IGY9ci5nZXQoZyk7aWYoIWYpdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBub2RlOiAke2d9YCk7Y29uc3QgeD1uZXcgZih1KTtyZXR1cm4gby5mb3JFYWNoKGM9Pnt4LmFwcGVuZENoaWxkKGMpfSkseH1jb25zdCBkPXtyZWdpc3Rlck5vZGUoZyx1LG89MTAwKXtpZih1PXUudG9Mb3dlckNhc2UoKSxyLmhhcyh1KSl0aHJvdyBuZXcgVHlwZUVycm9yKGBDYW5ub3QgcmVnaXN0ZXJOb2RlLCAke3V9IGhhcyBiZWVuIHRha2VuLmApO3Iuc2V0KHUsZyksT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZy5wcm90b3R5cGUse25vZGVUeXBlOnt2YWx1ZTpvfSx0YWdOYW1lOnt2YWx1ZTp1LnRvVXBwZXJDYXNlKCl9LG5vZGVOYW1lOnt2YWx1ZTp1fSxvd25lckRvY3VtZW50Ont2YWx1ZTpkfSxuYW1lc3BhY2VVUkk6e3ZhbHVlOmBodHRwOi8vc3ByaXRlanMuY29tLyR7dX1gfX0pfSxjcmVhdGVFbGVtZW50Om4sY3JlYXRlRWxlbWVudE5TKGcsdSl7cmV0dXJuIG4odSl9LGlzU3ByaXRlTm9kZShnKXtyZXR1cm4gci5oYXMoZy50b0xvd2VyQ2FzZSgpKX19O2UuZGVmYXVsdD1kfSxmdW5jdGlvbihoLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiB1fSksdCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IHI9U3ltYm9sKCJ0eXBlIiksbj1TeW1ib2woImJ1YmJsZXMiKSxkPVN5bWJvbCgib3JpZ2luYWxFdmVudCIpLGc9U3ltYm9sKCJkZXRhaWwiKTtjbGFzcyB1e2NvbnN0cnVjdG9yKGYse2J1YmJsZXM6eD1udWxsfT17fSl7aWYodHlwZW9mIGY9PSJzdHJpbmciPyh0aGlzW3JdPWYsdGhpc1tuXT0hIXgpOih0aGlzW3JdPWYudHlwZSx0aGlzW2RdPWYsdGhpc1tuXT14IT1udWxsPyEheDohIWYuYnViYmxlcyxmLmRldGFpbCYmKHRoaXNbZ109Zi5kZXRhaWwpKSwhdGhpc1tyXSl0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIGV2ZW50IHR5cGUuIik7dGhpcy5jYW5jZWxCdWJibGU9ITF9c2V0T3JpZ2luYWxFdmVudChmKXt0aGlzW2RdPWZ9Z2V0IG9yaWdpbmFsRXZlbnQoKXtyZXR1cm4gdGhpc1tkXX1nZXQgdHlwZSgpe3JldHVybiB0aGlzW3JdfWdldCBidWJibGVzKCl7cmV0dXJuIHRoaXNbbl19Z2V0IGRldGFpbCgpe3JldHVybiB0aGlzW2ddfXN0b3BQcm9wYWdhdGlvbigpe3RoaXMuY2FuY2VsQnViYmxlPSEwfX19LGZ1bmN0aW9uKGgsZSx0KXt0LnIoZSksdC5kKGUsInBhcnNlRmlsdGVyU3RyaW5nIixmdW5jdGlvbigpe3JldHVybiBufSksdC5kKGUsImFwcGx5RmlsdGVycyIsZnVuY3Rpb24oKXtyZXR1cm4gZH0pO3ZhciByPXQoNzIpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBuKGcpe2lmKGc9Zy50cmltKCksIWd8fGc9PT0ibm9uZSIpcmV0dXJuIG51bGw7Y29uc3QgdT0vXig/Oih1cmx8Ymx1cnxicmlnaHRuZXNzfGNvbnRyYXN0fGRyb3Atc2hhZG93fGdyYXlzY2FsZXxodWUtcm90YXRlfGludmVydHxvcGFjaXR5fHNhdHVyYXRlfHNlcGlhKVwoKFteKCldKig/OlwoLipcKSkqW14oKV0qKVwpKSskL2ksbz1nLm1hdGNoKC8oPzoodXJsfGJsdXJ8YnJpZ2h0bmVzc3xjb250cmFzdHxkcm9wLXNoYWRvd3xncmF5c2NhbGV8aHVlLXJvdGF0ZXxpbnZlcnR8b3BhY2l0eXxzYXR1cmF0ZXxzZXBpYSlcKChbXigpXSooPzpcKC4qXCkpKlteKCldKilcKSkrPy9pZyksZj1bXTtyZXR1cm4gbyYmby5mb3JFYWNoKHg9Pntjb25zdCBjPXgubWF0Y2godSk7aWYoIWMpdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCBmaXRsZXIgc3RyaW5nLiIpO2xldFssdixwXT1jO3Y9di50b0xvd2VyQ2FzZSgpLHA9cC50cmltKCkubWF0Y2goLyhbXiggKV0rfChbXiggKV0rXCguKlwpKSkoPz1cc3wkKS9nKS5tYXAoKGIsRSk9PntsZXQgeTtyZXR1cm4gdj09PSJ1cmwifHx2PT09ImRyb3Atc2hhZG93IiYmRT09PTM/eT1iOnk9T2JqZWN0KHIudG9OdW1iZXIpKGIpLC8lJC8udGVzdChiKSYmKHkvPTEwMCkseX0pLGYucHVzaCh7dHlwZTp2LGFyZ3M6cH0pfSksZn1mdW5jdGlvbiBkKGcsdSl7Zy5jbGVhckZpbHRlcigpLHUmJnUuZm9yRWFjaCgoe3R5cGU6byxhcmdzOmZ9KT0+e2xldCB4PW87eD09PSJkcm9wLXNoYWRvdyI/eD0iZHJvcFNoYWRvdyI6eD09PSJodWUtcm90YXRlIiYmKHg9Imh1ZVJvdGF0ZSIpLGdbeF0oLi4uZil9KX19LGZ1bmN0aW9uKGgsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIHJ9KSx0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gcihuLGQpe2lmKCFkKXJldHVybjtjb25zdCBnPW4uZ2V0TGlzdGVuZXJzKCJiZWZvcmVyZW5kZXIiKSx1PW4uZ2V0TGlzdGVuZXJzKCJhZnRlcnJlbmRlciIpO2cubGVuZ3RoJiYhZC5iZWZvcmVSZW5kZXI/ZC5iZWZvcmVSZW5kZXI9bz0+e24uZGlzcGF0Y2hFdmVudCh7dHlwZToiYmVmb3JlcmVuZGVyIixkZXRhaWw6e2NvbnRleHQ6b319KX06Zy5sZW5ndGh8fChkLmJlZm9yZVJlbmRlcj1udWxsKSx1Lmxlbmd0aCYmIWQuYWZ0ZXJSZW5kZXI/ZC5hZnRlclJlbmRlcj1vPT57bi5kaXNwYXRjaEV2ZW50KHt0eXBlOiJhZnRlcnJlbmRlciIsZGV0YWlsOntjb250ZXh0Om99fSl9OnUubGVuZ3RofHwoZC5hZnRlclJlbmRlcj1udWxsKX19LGZ1bmN0aW9uKGgsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIGZ9KTt2YXIgcj10KDEyKSxuPXQoMjE4KSxkPXQoNzApLGc9dCgyMTMpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCB1PVN5bWJvbCgiYW1vdW50Iiksbz1TeW1ib2woIm1lc2hDbG91ZCIpO2NsYXNzIGYgZXh0ZW5kcyBkLmRlZmF1bHR7Y29uc3RydWN0b3IoYyx2PTEpe3N1cGVyKCksdGhpcy5tZXNoTm9kZT1jLGMuY29ubmVjdCh0aGlzKSx0aGlzW3VdPXYsdGhpc1tvXT1udWxsfWdldCBtZXNoQ2xvdWQoKXtjb25zdCBjPXRoaXMubWVzaE5vZGUsdj10aGlzW3VdO3JldHVybiF0aGlzW29dJiZjLm1lc2gmJih0aGlzW29dPW5ldyByLk1lc2hDbG91ZChjLm1lc2gsdikpLHRoaXNbb119Z2V0IGlzVmlzaWJsZSgpe3JldHVybiEhdGhpcy5tZXNoTm9kZSYmdGhpcy5tZXNoTm9kZS5pc1Zpc2libGV9Z2V0IGFtb3VudCgpe3JldHVybiB0aGlzW3VdfXNldCBhbW91bnQoYyl7dGhpc1t1XT1jLHRoaXNbb10mJih0aGlzW29dLmFtb3VudD1jKX1icmlnaHRuZXNzKGMsdil7dGhpcy5tZXNoQ2xvdWQmJih0aGlzLm1lc2hDbG91ZC5icmlnaHRuZXNzKGMsdiksdGhpcy5mb3JjZVVwZGF0ZSgpKX1jb250cmFzdChjLHYpe3RoaXMubWVzaENsb3VkJiYodGhpcy5tZXNoQ2xvdWQuY29udHJhc3QoYyx2KSx0aGlzLmZvcmNlVXBkYXRlKCkpfWRlbGV0ZShjKXt0aGlzLm1lc2hDbG91ZCYmKHRoaXMubWVzaENsb3VkLmRlbGV0ZShjKSx0aGlzW3VdLS0sdGhpcy5mb3JjZVVwZGF0ZSgpKX1kcmF3KGM9W10pe2lmKHN1cGVyLmRyYXcoYyksdGhpcy5tZXNoQ2xvdWQpe2lmKHRoaXMucHJvZ3JhbSl7dGhpcy5tZXNoQ2xvdWQuc2V0UHJvZ3JhbSh0aGlzLnByb2dyYW0pO2NvbnN0IHY9dGhpcy5zaGFkZXJBdHRyczt2JiZPYmplY3QuZW50cmllcyh2KS5mb3JFYWNoKChbYixFXSk9Pnt0aGlzLm1lc2hDbG91ZC5tZXNoLnNldEF0dHJpYnV0ZShiLEUpfSk7Y29uc3QgcD10aGlzLnVuaWZvcm1zO2lmKHRoaXMudW5pZm9ybXMpe2NvbnN0IGI9e307T2JqZWN0LmVudHJpZXMocCkuZm9yRWFjaCgoW0UseV0pPT57dHlwZW9mIHk9PSJmdW5jdGlvbiImJih5PXkodGhpcyxFKSksYltFXT15fSksdGhpcy5tZXNoQ2xvdWQubWVzaC5zZXRVbmlmb3JtcyhiKX19dGhpcy5tZXNoTm9kZS50ZXh0dXJlSW1hZ2UmJk9iamVjdChuLmRyYXdUZXh0dXJlKSh0aGlzLm1lc2hOb2RlLHRoaXMubWVzaE5vZGUubWVzaCksYy5wdXNoKHRoaXMubWVzaENsb3VkKX1yZXR1cm4gY31nZXRUcmFuc2Zvcm0oYyl7aWYodGhpcy5tZXNoQ2xvdWQpcmV0dXJuIHRoaXMubWVzaENsb3VkLmdldFRyYW5zZm9ybShjKX1ncmF5c2NhbGUoYyx2KXt0aGlzLm1lc2hDbG91ZCYmKHRoaXMubWVzaENsb3VkLmdyYXlzY2FsZShjLHYpLHRoaXMuZm9yY2VVcGRhdGUoKSl9aHVlUm90YXRlKGMsdil7dGhpcy5tZXNoQ2xvdWQmJih0aGlzLm1lc2hDbG91ZC5odWVSb3RhdGUoYyx2KSx0aGlzLmZvcmNlVXBkYXRlKCkpfWludmVydChjLHYpe3RoaXMubWVzaENsb3VkJiYodGhpcy5tZXNoQ2xvdWQuaW52ZXJ0KGMsdiksdGhpcy5mb3JjZVVwZGF0ZSgpKX1pc1BvaW50Q29sbGlzaW9uKGMsdil7aWYoIXRoaXMubWVzaENsb3VkKXJldHVybiExO2NvbnN0IHA9dGhpcy5hdHRyaWJ1dGVzLnBvaW50ZXJFdmVudHM7aWYocD09PSJub25lInx8cCE9PSJhbGwiJiYhdGhpcy5pc1Zpc2libGUpcmV0dXJuITE7bGV0IGI9ImJvdGgiO3A9PT0idmlzaWJsZUZpbGwiJiYoYj0iZmlsbCIpLHA9PT0idmlzaWJsZVN0cm9rZSImJihiPSJzdHJva2UiKTtmb3IobGV0IEU9MDtFPHRoaXNbdV07RSsrKWlmKCF0aGlzLm1lc2hDbG91ZC5pc1BvaW50Q29sbGlzaW9uKEUsW2Msdl0sYikpcmV0dXJuITE7cmV0dXJuITB9c2V0T3BhY2l0eShjLHYpe3RoaXMubWVzaENsb3VkJiYodGhpcy5tZXNoQ2xvdWQub3BhY2l0eShjLHYpLHRoaXMuZm9yY2VVcGRhdGUoKSl9cm90YXRlKGMsdixbcCxiXT1bMCwwXSl7Y29uc3QgRT1NYXRoLlBJKnYvMTgwO2lmKHRoaXMubWVzaENsb3VkKXtjb25zdHt4OnkseTpNfT10aGlzLm1lc2hOb2RlLmF0dHJpYnV0ZXM7dGhpcy5tZXNoQ2xvdWQucm90YXRlKGMsRSxbcCt5LGIrTV0pLHRoaXMuZm9yY2VVcGRhdGUoKX19c2F0dXJhdGUoYyx2KXt0aGlzLm1lc2hDbG91ZCYmKHRoaXMubWVzaENsb3VkLnNhdHVyYXRlKGMsdiksdGhpcy5mb3JjZVVwZGF0ZSgpKX1zY2FsZShjLFt2LHA9dl0sW2IsRV09WzAsMF0pe2lmKHRoaXMubWVzaENsb3VkKXtjb25zdHt4OnkseTpNfT10aGlzLm1lc2hOb2RlLmF0dHJpYnV0ZXMsaT0xZS01O01hdGguYWJzKHYpPGkmJih2PTEvdj4wP2k6LWkpLE1hdGguYWJzKHApPGkmJihwPTEvcD4wP2k6LWkpLHRoaXMubWVzaENsb3VkLnNjYWxlKGMsW3YscF0sW2IreSxFK01dKSx0aGlzLmZvcmNlVXBkYXRlKCl9fXNldENvbG9yVHJhbnNmb3JtKGMsdil7dGhpcy5tZXNoQ2xvdWQmJih0aGlzLm1lc2hDbG91ZC5zZXRDb2xvclRyYW5zZm9ybShjLHYpLHRoaXMuZm9yY2VVcGRhdGUoKSl9c2V0RmlsbENvbG9yKGMsdil7dGhpcy5tZXNoQ2xvdWQmJihBcnJheS5pc0FycmF5KHYpJiYodj1bLi4udl0sdlswXS89MjU1LHZbMV0vPTI1NSx2WzJdLz0yNTUpLHRoaXMubWVzaENsb3VkLnNldEZpbGxDb2xvcihjLHYpLHRoaXMuZm9yY2VVcGRhdGUoKSl9c2VwaWEoYyx2KXt0aGlzLm1lc2hDbG91ZCYmKHRoaXMubWVzaENsb3VkLnNlcGlhKGMsdiksdGhpcy5mb3JjZVVwZGF0ZSgpKX1zZXRSZXNvbHV0aW9uKHt3aWR0aDpjLGhlaWdodDp2fSl7c3VwZXIuc2V0UmVzb2x1dGlvbih7d2lkdGg6YyxoZWlnaHQ6dn0pLHRoaXMubWVzaE5vZGUuc2V0UmVzb2x1dGlvbih7d2lkdGg6YyxoZWlnaHQ6dn0pfXNldFN0cm9rZUNvbG9yKGMsdil7dGhpcy5tZXNoQ2xvdWQmJihBcnJheS5pc0FycmF5KHYpJiYodj1bLi4udl0sdlswXS89MjU1LHZbMV0vPTI1NSx2WzJdLz0yNTUpLHRoaXMubWVzaENsb3VkLnNldFN0cm9rZUNvbG9yKGMsdiksdGhpcy5mb3JjZVVwZGF0ZSgpKX1zZXRUcmFuc2Zvcm0oYyx2KXt0aGlzLm1lc2hDbG91ZCYmKHRoaXMubWVzaENsb3VkLnNldFRyYW5zZm9ybShjLHYpLHRoaXMuZm9yY2VVcGRhdGUoKSl9c2tldyhjLFt2LHA9dl0sW2IsRV09WzAsMF0pe2lmKHRoaXMubWVzaENsb3VkKXtjb25zdHt4OnkseTpNfT10aGlzLm1lc2hOb2RlLmF0dHJpYnV0ZXM7dGhpcy5tZXNoQ2xvdWQuc2tldyhjLFt2LHBdLFtiK3ksRStNXSksdGhpcy5mb3JjZVVwZGF0ZSgpfX10cmFuc2Zvcm0oYyx2KXt0aGlzLm1lc2hDbG91ZCYmKHRoaXMubWVzaENsb3VkLnRyYW5zZm9ybShjLHYpLHRoaXMuZm9yY2VVcGRhdGUoKSl9dHJhbnNmb3JtQ29sb3IoYyx2KXt0aGlzLm1lc2hDbG91ZCYmKHRoaXMubWVzaENsb3VkLnRyYW5zZm9ybUNvbG9yKGMsdiksdGhpcy5mb3JjZVVwZGF0ZSgpKX10cmFuc2xhdGUoYyxbdixwXSl7dGhpcy5tZXNoQ2xvdWQmJih0aGlzLm1lc2hDbG91ZC50cmFuc2xhdGUoYyxbdixwXSksdGhpcy5mb3JjZVVwZGF0ZSgpKX11cGRhdGVNZXNoKCl7dGhpc1tvXSYmKHRoaXNbb10ubWVzaD10aGlzLm1lc2hOb2RlLm1lc2gsdGhpcy5mb3JjZVVwZGF0ZSgpKX19Zy5kZWZhdWx0LnJlZ2lzdGVyTm9kZShmLCJjbG91ZCIpfSxmdW5jdGlvbihoLGUsdCl7dC5yKGUpLHQuZChlLCJsb2FkVGV4dHVyZSIsZnVuY3Rpb24oKXtyZXR1cm4gZ30pLHQuZChlLCJhcHBseVRleHR1cmUiLGZ1bmN0aW9uKCl7cmV0dXJuIHV9KSx0LmQoZSwiY3JlYXRlVGV4dHVyZSIsZnVuY3Rpb24oKXtyZXR1cm4gZn0pLHQuZChlLCJkZWxldGVUZXh0dXJlIixmdW5jdGlvbigpe3JldHVybiB4fSksdC5kKGUsImRyYXdUZXh0dXJlIixmdW5jdGlvbigpe3JldHVybiB2fSksdC5kKGUsImxvYWRGcmFtZXMiLGZ1bmN0aW9uKCl7cmV0dXJuIHB9KTt2YXIgcj10KDEyKSxuPXQoNzIpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCBkPXt9O2Z1bmN0aW9uIGcoYixFKXtpZihkW2JdKXJldHVybiBkW2JdO2NvbnN0IHk9ci5FTlYubG9hZEltYWdlKGIse2FsaWFzOkUsdXNlSW1hZ2VCaXRtYXA6ITF9KTtyZXR1cm4geT8/Yn1hc3luYyBmdW5jdGlvbiB1KGIsRSx5KXtsZXQgTT1FO2lmKHR5cGVvZiBFPT0ic3RyaW5nIiYmKE09ZyhFKSksTSYmdHlwZW9mIE0udGhlbj09ImZ1bmN0aW9uIiYmKE09YXdhaXQgTSksRT09PWIuYXR0cmlidXRlcy50ZXh0dXJlKXtNJiZNLmltYWdlJiYoTS5zb3VyY2VSZWN0JiYoYi5hdHRyaWJ1dGVzLnNvdXJjZVJlY3Q9TS5zb3VyY2VSZWN0KSxiLnRleHR1cmVJbWFnZVJvdGF0ZWQ9ISFNLnJvdGF0ZWQsTT1NLmltYWdlKTtjb25zdHt3aWR0aDppLGhlaWdodDphLHRleHR1cmVSZWN0OnN9PWIuYXR0cmlidXRlcyxsPWIudGV4dHVyZUltYWdlO2IudGV4dHVyZUltYWdlPU0seSYmbCE9PU0mJiFzJiYoaT09bnVsbHx8YT09bnVsbCkmJmIudXBkYXRlQ29udG91cnMoKSxiLmZvcmNlVXBkYXRlKCl9cmV0dXJuIE19Y29uc3Qgbz1TeW1ib2woInRleHR1cmVNYXAiKTtmdW5jdGlvbiBmKGIsRSl7aWYoRVtvXT1FW29dfHxuZXcgTWFwLEVbb10uaGFzKGIpKXJldHVybiBFW29dLmdldChiKTtjb25zdCB5PUUuY3JlYXRlVGV4dHVyZShiKTtyZXR1cm4hL15ibG9iOi8udGVzdChiLnNyYykmJnR5cGVvZiBiLmdldENvbnRleHQhPSJmdW5jdGlvbiImJkVbb10uc2V0KGIseSkseX1mdW5jdGlvbiB4KGIsRSl7aWYoRVtvXSYmRVtvXS5oYXMoYikpe2NvbnN0IHk9RVtvXS5nZXQoYik7cmV0dXJuIEUuZGVsZXRlVGV4dHVyZSh5KSxFW29dLmRlbGV0ZShiKSwhMH1yZXR1cm4hMX1jb25zdCBjPVN5bWJvbCgidGV4dHVyZUNvbnRleHQiKTtmdW5jdGlvbiB2KGIsRSl7Y29uc3QgeT1iLnRleHR1cmVJbWFnZSBpbnN0YW5jZW9mIFN0cmluZz9TdHJpbmcoYi50ZXh0dXJlSW1hZ2UpOmIudGV4dHVyZUltYWdlLE09Yi50ZXh0dXJlSW1hZ2VSb3RhdGVkLGk9RS50ZXh0dXJlLGE9Yi5yZW5kZXJlcjtpZih5KXtjb25zdCBzPWIub3JpZ2luYWxDb250ZW50UmVjdDtsZXQgbD1iLmF0dHJpYnV0ZXMudGV4dHVyZVJlY3Q7Y29uc3QgTz1iLmF0dHJpYnV0ZXMudGV4dHVyZVJlcGVhdCxBPWIuYXR0cmlidXRlcy5zb3VyY2VSZWN0O2lmKCFpfHxiW2NdJiZiW2NdIT09YXx8aS5pbWFnZSE9PXl8fGkub3B0aW9ucy5yZXBlYXQhPT1PfHwhT2JqZWN0KG4uY29tcGFyZVZhbHVlKShpLm9wdGlvbnMucmVjdCxsKXx8IU9iamVjdChuLmNvbXBhcmVWYWx1ZSkoaS5vcHRpb25zLnNyY1JlY3QsQSkpe2NvbnN0IFI9Zih5LGEpO2w/KGxbMF0rPXNbMF0sbFsxXSs9c1sxXSk6bD1zO2xldCBJPW51bGw7aSYmIWFbb10uaGFzKGkuaW1hZ2UpJiYoIWkub3B0aW9uc3x8IWkub3B0aW9ucy5oaWRkZW4pJiYoST1FLnVuaWZvcm1zLnVfdGV4U2FtcGxlciksRS5zZXRUZXh0dXJlKFIse3JlY3Q6bCxyZXBlYXQ6TyxzcmNSZWN0OkEscm90YXRlZDpNfSksSSYmSS5kZWxldGUmJkkuZGVsZXRlKCksYltjXT1hfX1lbHNlIGlmKGkpe2xldCBzPW51bGw7IWFbb10uaGFzKGkuaW1hZ2UpJiYoIWkub3B0aW9uc3x8IWkub3B0aW9ucy5oaWRkZW4pJiYocz1FLnVuaWZvcm1zLnVfdGV4U2FtcGxlciksRS5zZXRUZXh0dXJlKG51bGwpLHMmJnMuZGVsZXRlJiZzLmRlbGV0ZSgpfX1hc3luYyBmdW5jdGlvbiBwKGIsRSl7dHlwZW9mIEU9PSJzdHJpbmciJiYoRT1hd2FpdChhd2FpdCBmZXRjaChFLHttZXRob2Q6IkdFVCIsbW9kZToiY29ycyIsY2FjaGU6ImRlZmF1bHQifSkpLmpzb24oKSk7Y29uc3QgeT1hd2FpdCBnKGIpLE09RS5mcmFtZXM7cmV0dXJuIE9iamVjdC5lbnRyaWVzKE0pLmZvckVhY2goKFtpLGFdKT0+e2NvbnN0e3g6cyx5OmwsdzpPLGg6QX09YS5mcmFtZTtsZXQgUj1bcyxsLE8sQV07Y29uc3QgST1hLnJvdGF0ZWQ7SSYmKFI9W1JbMF0sUlsxXSxSWzNdLFJbMl1dKSxkW2ldPXtpbWFnZTp5LHNvdXJjZVJlY3Q6Uixyb3RhdGVkOkl9fSkseX19LGZ1bmN0aW9uKGgsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIHB9KTt2YXIgcj10KDEpLG49dCgxMiksZD10KDcwKSxnPXQoMjIwKSx1PXQoMjIxKSxvPXQoMjIyKSxmPXQoMjEzKSx4PXQoMjIzKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gYyhiLEUseSl7cmV0dXJuIEUgaW4gYj9PYmplY3QuZGVmaW5lUHJvcGVydHkoYixFLHt2YWx1ZTp5LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6YltFXT15LGJ9Y29uc3Qgdj1TeW1ib2woIm1lc2giKTtjbGFzcyBwIGV4dGVuZHMgZC5kZWZhdWx0e2NvbnN0cnVjdG9yKEU9e30pe3N1cGVyKEUpfWdldCBib3JkZXJTaXplKCl7Y29uc3R7cGFkZGluZ1RvcDpFLHBhZGRpbmdSaWdodDp5LHBhZGRpbmdCb3R0b206TSxwYWRkaW5nTGVmdDppLGJvcmRlcldpZHRoOmF9PXRoaXMuYXR0cmlidXRlcyxbcyxsXT10aGlzLmNvbnRlbnRTaXplO3JldHVybltpK3MreSthLEUrbCtNK2FdfWdldCBjbGllbnRTaXplKCl7Y29uc3R7cGFkZGluZ1RvcDpFLHBhZGRpbmdSaWdodDp5LHBhZGRpbmdCb3R0b206TSxwYWRkaW5nTGVmdDppfT10aGlzLmF0dHJpYnV0ZXMsW2Esc109dGhpcy5jb250ZW50U2l6ZTtyZXR1cm5baSthK3ksRStzK01dfWdldCBjb250ZW50U2l6ZSgpe2xldHt3aWR0aDpFLGhlaWdodDp5LGJveFNpemluZzpNLHBhZGRpbmdUb3A6aSxwYWRkaW5nUmlnaHQ6YSxwYWRkaW5nQm90dG9tOnMscGFkZGluZ0xlZnQ6bH09dGhpcy5hdHRyaWJ1dGVzO2lmKEU9RXx8MCx5PXl8fDAsTT09PSJib3JkZXItYm94Iil7Y29uc3QgTz0yKnRoaXMuYXR0cmlidXRlcy5ib3JkZXJXaWR0aDtFLT1PK2ErbCx5LT1PK2krcyxFPU1hdGgubWF4KDAsRSkseT1NYXRoLm1heCgwLHkpfXJldHVybltFLHldfWdldCBoYXNCb3JkZXIoKXtyZXR1cm4gdGhpcy5hdHRyaWJ1dGVzLmJvcmRlcldpZHRoPjB9Z2V0IGlzVmlzaWJsZSgpe2NvbnN0W0UseV09dGhpcy5ib3JkZXJTaXplO3JldHVybiBFPjAmJnk+MH1nZXQgbWVzaCgpe2lmKHRoaXMuYXR0cmlidXRlcy5kaXNwbGF5PT09Im5vbmUiKXJldHVybiBudWxsO2NvbnN0IEU9dGhpcy5jbGllbnRCb3g7aWYoRSl7bGV0IHk9dGhpc1t2XTtpZih5KXkuYm94IT09RSYmKHkuY29udG91cnM9RS5jb250b3Vycyx5LmJveD1FKTtlbHNle3k9bmV3IG4uTWVzaDJEKEUpLHkuYm94PUU7Y29uc3QgaT10aGlzLmF0dHJpYnV0ZXMuYmdjb2xvcjtpZihPYmplY3QodS5zZXRGaWxsQ29sb3IpKHkse2NvbG9yOml9KSx0aGlzLmhhc0JvcmRlcil7Y29uc3R7Ym9yZGVyQ29sb3I6cyxib3JkZXJXaWR0aDpsLGJvcmRlckRhc2g6Tyxib3JkZXJEYXNoT2Zmc2V0OkF9PXRoaXMuYXR0cmlidXRlcztPYmplY3QodS5zZXRTdHJva2VDb2xvcikoeSx7Y29sb3I6cyxsaW5lV2lkdGg6bCxsaW5lRGFzaDpPLGxpbmVEYXNoT2Zmc2V0OkF9KX10aGlzW3ZdPXk7Y29uc3QgYT10aGlzLmF0dHJpYnV0ZXMuY2xpcFBhdGg7YSYmdGhpc1t2XS5zZXRDbGlwUGF0aChhKX1jb25zdCBNPXRoaXMub3BhY2l0eTtyZXR1cm4geS5nZXRPcGFjaXR5KCkhPT1NJiZ5LnNldE9wYWNpdHkoTSkseS5zZXRUcmFuc2Zvcm0oLi4udGhpcy5yZW5kZXJNYXRyaXgpLHl9cmV0dXJuIG51bGx9Z2V0IG9mZnNldFNpemUoKXtjb25zdHtwYWRkaW5nVG9wOkUscGFkZGluZ1JpZ2h0OnkscGFkZGluZ0JvdHRvbTpNLHBhZGRpbmdMZWZ0OmksYm9yZGVyV2lkdGg6YX09dGhpcy5hdHRyaWJ1dGVzLFtzLGxdPXRoaXMuY29udGVudFNpemUsTz0yKmE7cmV0dXJuW2krcyt5K08sRStsK00rT119Z2V0IG9yaWdpbmFsQ2xpZW50UmVjdCgpe2lmKHRoaXMubWVzaCl7Y29uc3QgRT10aGlzLm1lc2guYm91bmRpbmdCb3g7cmV0dXJuW0VbMF1bMF0sRVswXVsxXSxFWzFdWzBdLUVbMF1bMF0sRVsxXVsxXS1FWzBdWzFdXX1yZXR1cm5bMCwwLDAsMF19Z2V0IG9yaWdpbmFsQ29udGVudFJlY3QoKXtjb25zdFtFLHksTSxpXT10aGlzLm9yaWdpbmFsQ2xpZW50UmVjdCxhPXRoaXMuYXR0cmlidXRlcy5wYWRkaW5nO3JldHVybltFK2FbMF0seSthWzFdLE0tYVswXS1hWzJdLGktYVsxXS1hWzNdXX1nZXRCb3VuZGluZ0NsaWVudFJlY3QoKXtsZXQgRT10aGlzLnJlbmRlck1hdHJpeDt0aGlzLmxheWVyJiZ0aGlzLmxheWVyLmxheWVyVHJhbnNmb3JtSW52ZXJ0JiYoRT1yLm1hdDJkLm11bHRpcGx5KEFycmF5Lm9mKDAsMCwwLDAsMCwwKSx0aGlzLmxheWVyLnRyYW5zZm9ybU1hdHJpeCxFKSk7bGV0IHk9bnVsbDtpZih0aGlzLm1lc2gpe3k9Wy4uLnRoaXMubWVzaC5ib3VuZGluZ0JveF07Y29uc3QgTT10aGlzLmF0dHJpYnV0ZXMuYm9yZGVyV2lkdGg7TSYmKHlbMF09W3lbMF1bMF0tTSx5WzBdWzFdLU1dLHlbMV09W3lbMV1bMF0rTSx5WzFdWzFdK01dKX1yZXR1cm4gT2JqZWN0KHguZGVmYXVsdCkoeSxFKX1vblByb3BlcnR5Q2hhbmdlKEUseSxNKXtpZihzdXBlci5vblByb3BlcnR5Q2hhbmdlKEUseSxNKSwoRT09PSJhbmNob3JYInx8RT09PSJhbmNob3JZInx8RT09PSJib3hTaXppbmcifHxFPT09IndpZHRoInx8RT09PSJoZWlnaHQifHxFPT09ImJvcmRlcldpZHRoInx8RT09PSJwYWRkaW5nTGVmdCJ8fEU9PT0icGFkZGluZ1JpZ2h0Inx8RT09PSJwYWRkaW5nVG9wInx8RT09PSJwYWRkaW5nQm90dG9tInx8L15ib3JkZXIoVG9wTGVmdHxUb3BSaWdodHxCb3R0b21SaWdodHxCb3R0b21MZWZ0KVJhZGl1cyQvLnRlc3QoRSkpJiZ0aGlzLnVwZGF0ZUNvbnRvdXJzKCksdGhpc1t2XSYmRT09PSJjbGlwUGF0aCImJnRoaXNbdl0uc2V0Q2xpcFBhdGgoeSksdGhpc1t2XSYmRT09PSJiZ2NvbG9yIiYmT2JqZWN0KHUuc2V0RmlsbENvbG9yKSh0aGlzW3ZdLHtjb2xvcjp5fSksdGhpc1t2XSYmKEU9PT0iYm9yZGVyQ29sb3IifHxFPT09ImJvcmRlcldpZHRoInx8RT09PSJib3JkZXJEYXNoInx8RT09PSJib3JkZXJEYXNoT2Zmc2V0Iikpe2NvbnN0e2JvcmRlckNvbG9yOmksYm9yZGVyV2lkdGg6YSxib3JkZXJEYXNoOnMsYm9yZGVyRGFzaE9mZnNldDpsfT10aGlzLmF0dHJpYnV0ZXM7T2JqZWN0KHUuc2V0U3Ryb2tlQ29sb3IpKHRoaXNbdl0se2NvbG9yOmksbGluZVdpZHRoOmEsbGluZURhc2g6YT9zOjAsbGluZURhc2hPZmZzZXQ6bH0pfX11cGRhdGVDb250b3Vycygpe2NvbnN0e2FuY2hvclg6RSxhbmNob3JZOnksYm9yZGVyV2lkdGg6TSxib3JkZXJSYWRpdXM6aX09dGhpcy5hdHRyaWJ1dGVzLFthLHNdPXRoaXMuYm9yZGVyU2l6ZSxsPXRoaXMub2Zmc2V0U2l6ZSxPPS41Kk0sQT0tRSpsWzBdK08sUj0teSpsWzFdK087dGhpcy5jbGllbnRCb3g9bmV3IG4uRmlndXJlMkQsT2JqZWN0KG8uY3JlYXRlUmFkaXVzQm94KSh0aGlzLmNsaWVudEJveCxbQSxSLGEsc10saSl9fWMocCwiQXR0ciIsZy5kZWZhdWx0KSxmLmRlZmF1bHQucmVnaXN0ZXJOb2RlKHAsImJsb2NrIil9LGZ1bmN0aW9uKGgsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIHh9KTt2YXIgcj10KDcxKSxuPXQoNzIpLGQ9dCgyMjEpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCBnPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZSIpLHU9U3ltYm9sLmZvcigic3ByaXRlanNfZ2V0QXR0cmlidXRlIiksbz1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGVEZWZhdWx0IiksZj1TeW1ib2wuZm9yKCJzcHJpdGVqc19kZWNsYXJlQWxpYXMiKTtjbGFzcyB4IGV4dGVuZHMgci5kZWZhdWx0e2NvbnN0cnVjdG9yKHYpe3N1cGVyKHYpLHRoaXNbb10oe2FuY2hvclg6MCxhbmNob3JZOjAsd2lkdGg6dm9pZCAwLGhlaWdodDp2b2lkIDAsYm9yZGVyV2lkdGg6MCxib3JkZXJDb2xvcjoicmdiYSgwLDAsMCwxKSIsYm9yZGVyRGFzaDp2b2lkIDAsYm9yZGVyRGFzaE9mZnNldDowLGJvcmRlclRvcExlZnRSYWRpdXM6WzAsMF0sYm9yZGVyVG9wUmlnaHRSYWRpdXM6WzAsMF0sYm9yZGVyQm90dG9tUmlnaHRSYWRpdXM6WzAsMF0sYm9yZGVyQm90dG9tTGVmdFJhZGl1czpbMCwwXSxiZ2NvbG9yOiJyZ2JhKDAsMCwwLDApIixwYWRkaW5nVG9wOjAscGFkZGluZ1JpZ2h0OjAscGFkZGluZ0JvdHRvbTowLHBhZGRpbmdMZWZ0OjAsYm94U2l6aW5nOiJjb250ZW50LWJveCIsY2xpcFBhdGg6dm9pZCAwfSksdGhpc1tmXSgiYW5jaG9yIiwic2l6ZSIsImJvcmRlciIsImJvcmRlclJhZGl1cyIsInBhZGRpbmciKX1nZXQgYW5jaG9yWCgpe3JldHVybiB0aGlzW3VdKCJhbmNob3JYIil9c2V0IGFuY2hvclgodil7dGhpc1tnXSgiYW5jaG9yWCIsT2JqZWN0KG4udG9OdW1iZXIpKHYpKX1nZXQgYW5jaG9yWSgpe3JldHVybiB0aGlzW3VdKCJhbmNob3JZIil9c2V0IGFuY2hvclkodil7dGhpc1tnXSgiYW5jaG9yWSIsT2JqZWN0KG4udG9OdW1iZXIpKHYpKX1nZXQgYW5jaG9yKCl7cmV0dXJuW3RoaXMuYW5jaG9yWCx0aGlzLmFuY2hvclldfXNldCBhbmNob3Iodil7dj1PYmplY3Qobi50b0FycmF5KSh2KSxBcnJheS5pc0FycmF5KHYpfHwodj1bdix2XSksdGhpcy5hbmNob3JYPXZbMF0sdGhpcy5hbmNob3JZPXZbMV19Z2V0IHdpZHRoKCl7cmV0dXJuIHRoaXNbdV0oIndpZHRoIil9c2V0IHdpZHRoKHYpe3RoaXNbZ10oIndpZHRoIixPYmplY3Qobi50b051bWJlcikodikpfWdldCBoZWlnaHQoKXtyZXR1cm4gdGhpc1t1XSgiaGVpZ2h0Iil9c2V0IGhlaWdodCh2KXt0aGlzW2ddKCJoZWlnaHQiLE9iamVjdChuLnRvTnVtYmVyKSh2KSl9Z2V0IHNpemUoKXtyZXR1cm5bdGhpcy53aWR0aCx0aGlzLmhlaWdodF19c2V0IHNpemUodil7dj1PYmplY3Qobi50b0FycmF5KSh2KSxBcnJheS5pc0FycmF5KHYpfHwodj1bdix2XSksdGhpcy53aWR0aD12WzBdLHRoaXMuaGVpZ2h0PXZbMV19Z2V0IGJvcmRlcldpZHRoKCl7cmV0dXJuIHRoaXNbdV0oImJvcmRlcldpZHRoIil9c2V0IGJvcmRlcldpZHRoKHYpe3RoaXNbZ10oImJvcmRlcldpZHRoIixPYmplY3Qobi50b051bWJlcikodikpfWdldCBib3JkZXJDb2xvcigpe3JldHVybiB0aGlzW3VdKCJib3JkZXJDb2xvciIpfXNldCBib3JkZXJDb2xvcih2KXt0aGlzW2ddKCJib3JkZXJDb2xvciIsT2JqZWN0KGQucGFyc2VDb2xvcikodikpfWdldCBib3JkZXIoKXtyZXR1cm5bdGhpcy5ib3JkZXJXaWR0aCx0aGlzLmJvcmRlckNvbG9yXX1zZXQgYm9yZGVyKHYpe3Y9T2JqZWN0KG4udG9BcnJheSkodiksQXJyYXkuaXNBcnJheSh2KXx8KHY9W3ZdKSx0aGlzLmJvcmRlcldpZHRoPXZbMF0sdlsxXSE9bnVsbCYmKHRoaXMuYm9yZGVyQ29sb3I9dlsxXSl9Z2V0IGJvcmRlckRhc2goKXtyZXR1cm4gdGhpc1t1XSgiYm9yZGVyRGFzaCIpfXNldCBib3JkZXJEYXNoKHYpe3Y9T2JqZWN0KG4udG9BcnJheSkodiwhMCksdiE9bnVsbCYmIUFycmF5LmlzQXJyYXkodikmJih2PVt2XSksdGhpc1tnXSgiYm9yZGVyRGFzaCIsdj92Lm1hcChuLnRvTnVtYmVyKTpudWxsKX1nZXQgYm9yZGVyRGFzaE9mZnNldCgpe3JldHVybiB0aGlzW3VdKCJib3JkZXJEYXNoT2Zmc2V0Iil9c2V0IGJvcmRlckRhc2hPZmZzZXQodil7dGhpc1tnXSgiYm9yZGVyRGFzaE9mZnNldCIsT2JqZWN0KG4udG9OdW1iZXIpKHYpKX1nZXQgYm9yZGVyVG9wTGVmdFJhZGl1cygpe3JldHVybiB0aGlzW3VdKCJib3JkZXJUb3BMZWZ0UmFkaXVzIil9c2V0IGJvcmRlclRvcExlZnRSYWRpdXModil7dj1PYmplY3Qobi50b0FycmF5KSh2LCEwKSxBcnJheS5pc0FycmF5KHYpfHwodj1bdix2XSksdGhpc1tnXSgiYm9yZGVyVG9wTGVmdFJhZGl1cyIsdi5tYXAobi50b051bWJlcikpfWdldCBib3JkZXJUb3BSaWdodFJhZGl1cygpe3JldHVybiB0aGlzW3VdKCJib3JkZXJUb3BSaWdodFJhZGl1cyIpfXNldCBib3JkZXJUb3BSaWdodFJhZGl1cyh2KXt2PU9iamVjdChuLnRvQXJyYXkpKHYsITApLEFycmF5LmlzQXJyYXkodil8fCh2PVt2LHZdKSx0aGlzW2ddKCJib3JkZXJUb3BSaWdodFJhZGl1cyIsdi5tYXAobi50b051bWJlcikpfWdldCBib3JkZXJCb3R0b21SaWdodFJhZGl1cygpe3JldHVybiB0aGlzW3VdKCJib3JkZXJCb3R0b21SaWdodFJhZGl1cyIpfXNldCBib3JkZXJCb3R0b21SaWdodFJhZGl1cyh2KXt2PU9iamVjdChuLnRvQXJyYXkpKHYsITApLEFycmF5LmlzQXJyYXkodil8fCh2PVt2LHZdKSx0aGlzW2ddKCJib3JkZXJCb3R0b21SaWdodFJhZGl1cyIsdi5tYXAobi50b051bWJlcikpfWdldCBib3JkZXJCb3R0b21MZWZ0UmFkaXVzKCl7cmV0dXJuIHRoaXNbdV0oImJvcmRlckJvdHRvbUxlZnRSYWRpdXMiKX1zZXQgYm9yZGVyQm90dG9tTGVmdFJhZGl1cyh2KXt2PU9iamVjdChuLnRvQXJyYXkpKHYsITApLEFycmF5LmlzQXJyYXkodil8fCh2PVt2LHZdKSx0aGlzW2ddKCJib3JkZXJCb3R0b21MZWZ0UmFkaXVzIix2Lm1hcChuLnRvTnVtYmVyKSl9Z2V0IGJvcmRlclJhZGl1cygpe3JldHVyblsuLi50aGlzLmJvcmRlclRvcExlZnRSYWRpdXMsLi4udGhpcy5ib3JkZXJUb3BSaWdodFJhZGl1cywuLi50aGlzLmJvcmRlckJvdHRvbVJpZ2h0UmFkaXVzLC4uLnRoaXMuYm9yZGVyQm90dG9tTGVmdFJhZGl1c119c2V0IGJvcmRlclJhZGl1cyh2KXtpZih2PU9iamVjdChuLnRvQXJyYXkpKHYpLCFBcnJheS5pc0FycmF5KHYpKXY9QXJyYXkoOCkuZmlsbCh2KTtlbHNlIGlmKHYubGVuZ3RoPT09Mil2PVt2WzBdLHZbMV0sdlswXSx2WzFdLHZbMF0sdlsxXSx2WzBdLHZbMV1dO2Vsc2UgaWYodi5sZW5ndGg9PT00KXY9W3ZbMF0sdlsxXSx2WzJdLHZbM10sdlswXSx2WzFdLHZbMl0sdlszXV07ZWxzZSBpZih2Lmxlbmd0aD09PTYpdj1bdlswXSx2WzFdLHZbMl0sdlszXSx2WzRdLHZbNV0sdlsyXSx2WzNdXTtlbHNlIGlmKHYubGVuZ3RoIT09OCl0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIGJvcmRlclJhZGl1cyB2YWx1ZS4iKTt0aGlzLmJvcmRlclRvcExlZnRSYWRpdXM9W3ZbMF0sdlsxXV0sdGhpcy5ib3JkZXJUb3BSaWdodFJhZGl1cz1bdlsyXSx2WzNdXSx0aGlzLmJvcmRlckJvdHRvbVJpZ2h0UmFkaXVzPVt2WzRdLHZbNV1dLHRoaXMuYm9yZGVyQm90dG9tTGVmdFJhZGl1cz1bdls2XSx2WzddXX1nZXQgYmdjb2xvcigpe3JldHVybiB0aGlzW3VdKCJiZ2NvbG9yIil9c2V0IGJnY29sb3Iodil7dGhpc1tnXSgiYmdjb2xvciIsT2JqZWN0KGQucGFyc2VDb2xvcikodikpfWdldCBwYWRkaW5nVG9wKCl7cmV0dXJuIHRoaXNbdV0oInBhZGRpbmdUb3AiKX1zZXQgcGFkZGluZ1RvcCh2KXt0aGlzW2ddKCJwYWRkaW5nVG9wIixPYmplY3Qobi50b051bWJlcikodikpfWdldCBwYWRkaW5nUmlnaHQoKXtyZXR1cm4gdGhpc1t1XSgicGFkZGluZ1JpZ2h0Iil9c2V0IHBhZGRpbmdSaWdodCh2KXt0aGlzW2ddKCJwYWRkaW5nUmlnaHQiLE9iamVjdChuLnRvTnVtYmVyKSh2KSl9Z2V0IHBhZGRpbmdCb3R0b20oKXtyZXR1cm4gdGhpc1t1XSgicGFkZGluZ0JvdHRvbSIpfXNldCBwYWRkaW5nQm90dG9tKHYpe3RoaXNbZ10oInBhZGRpbmdCb3R0b20iLE9iamVjdChuLnRvTnVtYmVyKSh2KSl9Z2V0IHBhZGRpbmdMZWZ0KCl7cmV0dXJuIHRoaXNbdV0oInBhZGRpbmdMZWZ0Iil9c2V0IHBhZGRpbmdMZWZ0KHYpe3RoaXNbZ10oInBhZGRpbmdMZWZ0IixPYmplY3Qobi50b051bWJlcikodikpfWdldCBwYWRkaW5nKCl7cmV0dXJuW3RoaXMucGFkZGluZ1RvcCx0aGlzLnBhZGRpbmdSaWdodCx0aGlzLnBhZGRpbmdCb3R0b20sdGhpcy5wYWRkaW5nTGVmdF19c2V0IHBhZGRpbmcodil7dj1PYmplY3Qobi50b0FycmF5KSh2KSxBcnJheS5pc0FycmF5KHYpP3YubGVuZ3RoPT09Mj92PVt2WzBdLHZbMV0sdlswXSx2WzFdXTp2Lmxlbmd0aD09PTMmJih2PVt2WzBdLHZbMV0sdlsyXSx2WzFdXSk6dj1bdix2LHYsdl0sdGhpcy5wYWRkaW5nVG9wPXZbMF0sdGhpcy5wYWRkaW5nUmlnaHQ9dlsxXSx0aGlzLnBhZGRpbmdCb3R0b209dlsyXSx0aGlzLnBhZGRpbmdMZWZ0PXZbM119Z2V0IGNsaXBQYXRoKCl7cmV0dXJuIHRoaXNbdV0oImNsaXBQYXRoIil9c2V0IGNsaXBQYXRoKHYpe3RoaXNbZ10oImNsaXBQYXRoIix2KX1nZXQgYm94U2l6aW5nKCl7cmV0dXJuIHRoaXNbdV0oImJveFNpemluZyIpfXNldCBib3hTaXppbmcodil7aWYodiE9bnVsbCYmdiE9PSJib3JkZXItYm94IiYmdiE9PSJjb250ZW50LWJveCIpdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCBib3hTaXppbmcgdHlwZS4iKTt0aGlzW2ddKCJib3hTaXppbmciLHYpfX19LGZ1bmN0aW9uKGgsZSx0KXt0LnIoZSksdC5kKGUsIkdyYWRpZW50IixmdW5jdGlvbigpe3JldHVybiBkfSksdC5kKGUsImlzVHJhbnNwYXJlbnQiLGZ1bmN0aW9uKCl7cmV0dXJuIGd9KSx0LmQoZSwicGFyc2VDb2xvciIsZnVuY3Rpb24oKXtyZXR1cm4gdX0pLHQuZChlLCJzZXRGaWxsQ29sb3IiLGZ1bmN0aW9uKCl7cmV0dXJuIGZ9KSx0LmQoZSwic2V0U3Ryb2tlQ29sb3IiLGZ1bmN0aW9uKCl7cmV0dXJuIHh9KSx0LmQoZSwiQ29sb3IiLGZ1bmN0aW9uKCl7cmV0dXJuIGN9KTt2YXIgcj10KDMyKSxuPXQubihyKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y2xhc3MgZHtjb25zdHJ1Y3Rvcih7dmVjdG9yOnAsY29sb3JzOmJ9KXtpZighQXJyYXkuaXNBcnJheShwKXx8cC5sZW5ndGghPT00JiZwLmxlbmd0aCE9PTYmJnAubGVuZ3RoIT09Myl0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIGdyYWRpZW50Iik7dGhpcy52ZWN0b3I9cCx0aGlzLmNvbG9ycz1iLm1hcCgoe29mZnNldDpFLGNvbG9yOnl9KT0+KHtvZmZzZXQ6RSxjb2xvcjp1KHkpfSkpfXRvU3RyaW5nKCl7cmV0dXJuIEpTT04uc3RyaW5naWZ5KHt2ZWN0b3I6dGhpcy52ZWN0b3IsY29sb3JzOnRoaXMuY29sb3JzfSl9fWZ1bmN0aW9uIGcodil7cmV0dXJuIHYgaW5zdGFuY2VvZiBkPyExOnY9PW51bGw/ITA6bigpKHYpWzNdPT09MH1mdW5jdGlvbiB1KHYpe2lmKHY9PW51bGx8fCh2fHwodj0idHJhbnNwYXJlbnQiKSx2IGluc3RhbmNlb2YgZCkpcmV0dXJuIHY7Y29uc3QgcD1uKCkodik7aWYoIXB8fCFwLmxlbmd0aCl0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIGNvbG9yIHZhbHVlLiIpO3JldHVybmByZ2JhKCR7cC5qb2luKCl9KWB9ZnVuY3Rpb24gbyh2LHAsYil7Y29uc3QgRT12LmJvdW5kaW5nQm94WzBdO2lmKGIudmVjdG9yKXtsZXR7dmVjdG9yOnksY29sb3JzOk19PWI7eS5sZW5ndGg9PT00Pyh5PVt5WzBdK0VbMF0seVsxXStFWzFdLHlbMl0rRVswXSx5WzNdK0VbMV1dLHYuc2V0TGluZWFyR3JhZGllbnQoe3ZlY3Rvcjp5LGNvbG9yczpNLHR5cGU6cH0pKTp5Lmxlbmd0aD09PTM/KHk9W3lbMF0rRVswXSx5WzFdK0VbMV0seVsyXV0sdi5zZXRDaXJjdWxhckdyYWRpZW50KHt2ZWN0b3I6eSxjb2xvcnM6TSx0eXBlOnB9KSk6KHk9W3lbMF0rRVswXSx5WzFdK0VbMV0seVsyXSx5WzNdK0VbMF0seVs0XStFWzFdLHlbNV1dLHYuc2V0UmFkaWFsR3JhZGllbnQoe3ZlY3Rvcjp5LGNvbG9yczpNLHR5cGU6cH0pKX1lbHNlIHYuZ3JhZGllbnQmJnYuZ3JhZGllbnRbcF0mJihkZWxldGUgdi5ncmFkaWVudFtwXSxkZWxldGUgdi51bmlmb3Jtcy51X3JhZGlhbEdyYWRpZW50VmVjdG9yKX1mdW5jdGlvbiBmKHYse2NvbG9yOnAscnVsZTpiPSJub256ZXJvIn0pe3JldHVybiBvKHYsImZpbGwiLHApLHAudmVjdG9yfHx2LnNldEZpbGwoe2NvbG9yOnAscnVsZTpifSksdn1mdW5jdGlvbiB4KHYse2NvbG9yOnAsbGluZVdpZHRoOmIsbGluZUNhcDpFLGxpbmVKb2luOnksbGluZURhc2g6TSxsaW5lRGFzaE9mZnNldDppLG1pdGVyTGltaXQ6YSxyb3VuZFNlZ21lbnRzOnN9KXtvKHYsInN0cm9rZSIscCkscC52ZWN0b3ImJihwPVswLDAsMCwxXSksdi5zZXRTdHJva2Uoe2NvbG9yOnAsdGhpY2tuZXNzOmIsY2FwOkUsam9pbjp5LG1pdGVyTGltaXQ6YSxsaW5lRGFzaDpNLGxpbmVEYXNoT2Zmc2V0Omkscm91bmRTZWdtZW50czpzfSl9Y2xhc3MgYyBleHRlbmRzIEFycmF5e2NvbnN0cnVjdG9yKHA9MCxiPTAsRT0wLHk9MCl7cmV0dXJuIEFycmF5LmlzQXJyYXkocCkmJihbcCxiLEUseV09cCksdHlwZW9mIHA9PSJzdHJpbmciJiYoW3AsYixFLHldPW4oKShwKSxwLz0yNTUsYi89MjU1LEUvPTI1NSksc3VwZXIocCxiLEUseSksdGhpc31nZXQgcigpe3JldHVybiBNYXRoLnJvdW5kKHRoaXNbMF0qMjU1KX1zZXQgcihwKXt0aGlzWzBdPXAvMjU1fWdldCBnKCl7cmV0dXJuIE1hdGgucm91bmQodGhpc1sxXSoyNTUpfXNldCBnKHApe3RoaXNbMV09cC8yNTV9Z2V0IGIoKXtyZXR1cm4gTWF0aC5yb3VuZCh0aGlzWzJdKjI1NSl9c2V0IGIocCl7dGhpc1syXT1wLzI1NX1nZXQgYSgpe3JldHVybiB0aGlzWzNdfXNldCBhKHApe3RoaXNbM109cH1nZXQgaGV4KCl7Y29uc3QgcD1gMCR7dGhpcy5yLnRvU3RyaW5nKDE2KX1gLnNsaWNlKC0yKSxiPWAwJHt0aGlzLmcudG9TdHJpbmcoMTYpfWAuc2xpY2UoLTIpLEU9YDAke3RoaXMuYi50b1N0cmluZygxNil9YC5zbGljZSgtMik7bGV0IHk7cmV0dXJuIHRoaXMuYTwxJiYoeT1NYXRoLnJvdW5kKHRoaXNbM10qMjU1KSx5PWAwJHt5LnRvU3RyaW5nKDE2KX1gLnNsaWNlKC0yKSksYCMke3B9JHtifSR7RX0ke3l8fCIifWB9Z2V0IHJnYmEoKXtyZXR1cm5gcmdiYSgke3RoaXMucn0sJHt0aGlzLmd9LCR7dGhpcy5ifSwke3RoaXMuYX0pYH1mcm9tQ29sb3IocCl7cmV0dXJuIHR5cGVvZiBwPT0ic3RyaW5nIiYmKHA9bigpKHApLHBbMF0vPTI1NSxwWzFdLz0yNTUscFsyXS89MjU1KSx0aGlzWzBdPXBbMF0sdGhpc1sxXT1wWzFdLHRoaXNbMl09cFsyXSx0aGlzWzNdPXBbM10sdGhpc319fSxmdW5jdGlvbihoLGUsdCl7dC5yKGUpLHQuZChlLCJjcmVhdGVSYWRpdXNCb3giLGZ1bmN0aW9uKCl7cmV0dXJuIG59KSx0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gcihkLGcsdSxvLGYseD0ibGVmdFRvcCIpe2NvbnN0IGM9LjU1MjI4NDgsdj1vLzIqYyxwPWYvMipjLGI9ZytvLEU9dStmLHk9ZytvLzIsTT11K2YvMjt4PT09ImxlZnRUb3AiPyhkLm1vdmVUbyhnLE0pLGQuYmV6aWVyQ3VydmVUbyhnLE0tcCx5LXYsdSx5LHUpKTp4PT09InJpZ2h0VG9wIj9kLmJlemllckN1cnZlVG8oeSt2LHUsYixNLXAsYixNKTp4PT09InJpZ2h0Qm90dG9tIj9kLmJlemllckN1cnZlVG8oYixNK3AseSt2LEUseSxFKTp4PT09ImxlZnRCb3R0b20iJiZkLmJlemllckN1cnZlVG8oeS12LEUsZyxNK3AsZyxNKX1mdW5jdGlvbiBuKGQsW2csdSxvLGZdLHgpe2lmKCF4fHxBcnJheS5pc0FycmF5KHgpJiZ4LmV2ZXJ5KGM9PmM9PT0wKSlkLmJlZ2luUGF0aCgpLGQucmVjdChnLHUsbyxmKTtlbHNle3R5cGVvZiB4PT0ibnVtYmVyIiYmKHg9QXJyYXkoOCkuZmlsbCh4KSk7Y29uc3RbYyx2LHAsYixFLHksTSxpXT14Lm1hcCgoYSxzKT0+cyUyP01hdGgubWluKGEsZi8yKTpNYXRoLm1pbihhLG8vMikpO2QuYmVnaW5QYXRoKCksZC5tb3ZlVG8oZyx1K3YpLHIoZCxnLHUsYyoyLHYqMiwibGVmdFRvcCIpLGQubGluZVRvKGcrby1wLHUpLHIoZCxnK28tcCoyLHUscCoyLGIqMiwicmlnaHRUb3AiKSxkLmxpbmVUbyhnK28sdStmLXkpLHIoZCxnK28tRSoyLHUrZi15KjIsRSoyLHkqMiwicmlnaHRCb3R0b20iKSxkLmxpbmVUbyhnK00sdStmKSxyKGQsZyx1K2YtaSoyLE0qMixpKjIsImxlZnRCb3R0b20iKSxkLmNsb3NlUGF0aCgpfXJldHVybiBkfX0sZnVuY3Rpb24oaCxlLHQpe3QucihlKSx0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSksZS5kZWZhdWx0PWZ1bmN0aW9uKHIsbil7aWYoIXIpcmV0dXJue3g6MCx5OjAsd2lkdGg6MCxoZWlnaHQ6MCxsZWZ0OjAsdG9wOjAscmlnaHQ6MCxib3R0b206MH07Y29uc3RbW2QsZ10sW3Usb11dPXIsZj1kKm5bMF0rZypuWzJdK25bNF0seD1kKm5bMV0rZypuWzNdK25bNV0sYz11Km5bMF0rZypuWzJdK25bNF0sdj11Km5bMV0rZypuWzNdK25bNV0scD11Km5bMF0rbypuWzJdK25bNF0sYj11Km5bMV0rbypuWzNdK25bNV0sRT1kKm5bMF0rbypuWzJdK25bNF0seT1kKm5bMV0rbypuWzNdK25bNV0sTT1NYXRoLm1pbihmLGMscCxFKSxpPU1hdGgubWluKHgsdixiLHkpLGE9TWF0aC5tYXgoZixjLHAsRSkscz1NYXRoLm1heCh4LHYsYix5KTtyZXR1cm57eDpNLHk6aSx3aWR0aDphLU0saGVpZ2h0OnMtaSxsZWZ0Ok0sdG9wOmkscmlnaHQ6YSxib3R0b206c319fSxmdW5jdGlvbihoLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBmfSk7dmFyIHI9dCgyMTgpLG49dCgyMTkpLGQ9dCgyMjUpLGc9dCgyMTMpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiB1KHgsYyx2KXtyZXR1cm4gYyBpbiB4P09iamVjdC5kZWZpbmVQcm9wZXJ0eSh4LGMse3ZhbHVlOnYsZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTp4W2NdPXYseH1jb25zdCBvPVN5bWJvbCgidGV4dHVyZVRhc2siKTtjbGFzcyBmIGV4dGVuZHMgbi5kZWZhdWx0e2NvbnN0cnVjdG9yKGM9e30pe3R5cGVvZiBjPT0ic3RyaW5nIiYmKGM9e3RleHR1cmU6Y30pLHN1cGVyKGMpfWdldCBjb250ZW50U2l6ZSgpe2xldFtjLHZdPXN1cGVyLmNvbnRlbnRTaXplO2NvbnN0e3dpZHRoOnAsaGVpZ2h0OmJ9PXRoaXMuYXR0cmlidXRlcztpZihwPT1udWxsfHxiPT1udWxsKXtjb25zdCBFPXRoaXMudGV4dHVyZUltYWdlLHk9dGhpcy5hdHRyaWJ1dGVzLnRleHR1cmVSZWN0LE09dGhpcy5hdHRyaWJ1dGVzLnNvdXJjZVJlY3Q7aWYoeSlwPT1udWxsJiYoYz15WzBdK3lbMl0pLGI9PW51bGwmJih2PXlbMV0reVszXSk7ZWxzZSBpZihNKXtjb25zdCBpPXRoaXMubGF5ZXI/dGhpcy5sYXllci5kaXNwbGF5UmF0aW86MTtwPT1udWxsJiYoYz1NWzJdL2kpLGI9PW51bGwmJih2PU1bM10vaSl9ZWxzZSBpZihFKXtjb25zdCBpPXRoaXMubGF5ZXI/dGhpcy5sYXllci5kaXNwbGF5UmF0aW86MTtwPT1udWxsJiYoYz1FLndpZHRoL2kpLGI9PW51bGwmJih2PUUuaGVpZ2h0L2kpfX1yZXR1cm5bYyx2XX1nZXQgdGV4dHVyZUltYWdlUmVhZHkoKXtyZXR1cm4gdGhpc1tvXXx8UHJvbWlzZS5yZXNvbHZlKCl9ZHJhdyhjPVtdKXtzdXBlci5kcmF3KGMpO2NvbnN0IHY9dGhpcy5tZXNoO3JldHVybiB2JiZPYmplY3Qoci5kcmF3VGV4dHVyZSkodGhpcyx2KSxjfW9uUHJvcGVydHlDaGFuZ2UoYyx2LHApe2lmKHN1cGVyLm9uUHJvcGVydHlDaGFuZ2UoYyx2LHApLGM9PT0idGV4dHVyZSImJih0aGlzW29dPU9iamVjdChyLmFwcGx5VGV4dHVyZSkodGhpcyx2LCEwKSksYz09PSJ0ZXh0dXJlUmVjdCIpe2NvbnN0e3dpZHRoOmIsaGVpZ2h0OkV9PXRoaXMuYXR0cmlidXRlczsoYj09bnVsbHx8RT09bnVsbCkmJnRoaXMudXBkYXRlQ29udG91cnMoKX19fXUoZiwiQXR0ciIsZC5kZWZhdWx0KSxnLmRlZmF1bHQucmVnaXN0ZXJOb2RlKGYsInNwcml0ZSIpfSxmdW5jdGlvbihoLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiB1fSk7dmFyIHI9dCgyMjApO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCBuPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZURlZmF1bHQiKSxkPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZSIpLGc9U3ltYm9sLmZvcigic3ByaXRlanNfZ2V0QXR0cmlidXRlIik7Y2xhc3MgdSBleHRlbmRzIHIuZGVmYXVsdHtjb25zdHJ1Y3RvcihmKXtzdXBlcihmKSx0aGlzW25dKHt0ZXh0dXJlOnZvaWQgMCx0ZXh0dXJlUmVjdDp2b2lkIDAsdGV4dHVyZVJlcGVhdDohMSxzb3VyY2VSZWN0OnZvaWQgMH0pfWdldCB0ZXh0dXJlKCl7cmV0dXJuIHRoaXNbZ10oInRleHR1cmUiKX1zZXQgdGV4dHVyZShmKXt0aGlzW2RdKCJ0ZXh0dXJlIixmKX1nZXQgdGV4dHVyZVJlY3QoKXtyZXR1cm4gdGhpc1tnXSgidGV4dHVyZVJlY3QiKX1zZXQgdGV4dHVyZVJlY3QoZil7dGhpc1tkXSgidGV4dHVyZVJlY3QiLGYpfWdldCBzb3VyY2VSZWN0KCl7cmV0dXJuIHRoaXNbZ10oInNvdXJjZVJlY3QiKX1zZXQgc291cmNlUmVjdChmKXt0aGlzW2RdKCJzb3VyY2VSZWN0IixmKX1nZXQgdGV4dHVyZVJlcGVhdCgpe3JldHVybiB0aGlzW2ddKCJ0ZXh0dXJlUmVwZWF0Iil9c2V0IHRleHR1cmVSZXBlYXQoZil7dGhpc1tkXSgidGV4dHVyZVJlcGVhdCIsISFmKX19fSxmdW5jdGlvbihoLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBifSk7dmFyIHI9dCgxMiksbj10KDIyNyksZD10Lm4obiksZz10KDcwKSx1PXQoMjI4KSxvPXQoMjIxKSxmPXQoMjE4KSx4PXQoMjEzKSxjPXQoMjIzKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gdihFLHksTSl7cmV0dXJuIHkgaW4gRT9PYmplY3QuZGVmaW5lUHJvcGVydHkoRSx5LHt2YWx1ZTpNLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6RVt5XT1NLEV9Y29uc3QgcD1TeW1ib2woIm1lc2giKTtjbGFzcyBiIGV4dGVuZHMgZy5kZWZhdWx0e2NvbnN0cnVjdG9yKHk9e30pe3R5cGVvZiB5PT0ic3RyaW5nIiYmKHk9e2Q6eX0pLHN1cGVyKHkpLHRoaXMuZWZmZWN0cz17ZChNLGksYSxzLGwpe2NvbnN0IE89KGEtcykvKGwtcyk7aWYoTzw9MClyZXR1cm4gTTtpZihPPj0xKXJldHVybiBpO2NvbnN0IEE9ZC5hLl9wcmVwcm9jZXNzaW5nKGQuYS5wYXRoMnNoYXBlcyhNKSxkLmEucGF0aDJzaGFwZXMoaSkpLFI9ZC5hLl9sZXJwKC4uLkEsTylbMF07cmV0dXJuIFIucmVkdWNlKChQLEwpPT5gJHtQfSR7TC5zbGljZSgyKS5qb2luKCIgIil9IGAsYE0ke1JbMF1bMF19ICR7UlswXVsxXX1DYCkudHJpbSgpfX19Z2V0IGlzVmlzaWJsZSgpe3JldHVybiEhdGhpcy5kfWdldCBtZXNoKCl7aWYodGhpcy5hdHRyaWJ1dGVzLmRpc3BsYXk9PT0ibm9uZSIpcmV0dXJuIG51bGw7Y29uc3QgeT10aGlzLnBhdGg7aWYoeSl7bGV0IE09dGhpc1twXTtpZihNKU0ucGF0aCE9PXkmJihNLmNvbnRvdXJzPXkuY29udG91cnMsTS5wYXRoPXkpO2Vsc2V7TT1uZXcgci5NZXNoMkQodGhpcy5wYXRoKSxNLnBhdGg9eTtjb25zdCBhPXRoaXMuYXR0cmlidXRlcy5maWxsQ29sb3Iscz10aGlzLmF0dHJpYnV0ZXMuZmlsbFJ1bGU7YSYmT2JqZWN0KG8uc2V0RmlsbENvbG9yKShNLHtjb2xvcjphLHJ1bGU6c30pO2NvbnN0IGw9dGhpcy5hdHRyaWJ1dGVzLmxpbmVXaWR0aCxPPXRoaXMuYXR0cmlidXRlcy5zdHJva2VDb2xvcjtpZihPJiZsPjApe2NvbnN0e2xpbmVDYXA6UixsaW5lSm9pbjpJLG1pdGVyTGltaXQ6UCxsaW5lRGFzaDpMLGxpbmVEYXNoT2Zmc2V0OkQscm91bmRTZWdtZW50czpDfT10aGlzLmF0dHJpYnV0ZXM7T2JqZWN0KG8uc2V0U3Ryb2tlQ29sb3IpKE0se2NvbG9yOk8sbGluZVdpZHRoOmwsbGluZUNhcDpSLGxpbmVKb2luOkksbWl0ZXJMaW1pdDpQLGxpbmVEYXNoOkwsbGluZURhc2hPZmZzZXQ6RCxyb3VuZFNlZ21lbnRzOkN9KX10aGlzW3BdPU07Y29uc3QgQT10aGlzLmF0dHJpYnV0ZXMuY2xpcFBhdGg7QSYmdGhpc1twXS5zZXRDbGlwUGF0aChBKX1jb25zdCBpPXRoaXMub3BhY2l0eTtyZXR1cm4gTS5nZXRPcGFjaXR5KCkhPT1pJiZNLnNldE9wYWNpdHkoaSksTS5zZXRUcmFuc2Zvcm0oLi4udGhpcy5yZW5kZXJNYXRyaXgpLE19cmV0dXJuIG51bGx9Z2V0IG9yaWdpbmFsQ29udGVudFJlY3QoKXtpZih0aGlzLnBhdGgpe2NvbnN0IHk9dGhpcy5wYXRoLmJvdW5kaW5nQm94O3JldHVyblt5WzBdWzBdLHlbMF1bMV0seVsxXVswXS15WzBdWzBdLHlbMV1bMV0teVswXVsxXV19cmV0dXJuWzAsMCwwLDBdfWdldCBvcmlnaW5hbENsaWVudFJlY3QoKXtpZih0aGlzLm1lc2gpe2NvbnN0IHk9dGhpcy5tZXNoLmJvdW5kaW5nQm94O3JldHVyblt5WzBdWzBdLHlbMF1bMV0seVsxXVswXS15WzBdWzBdLHlbMV1bMV0teVswXVsxXV19cmV0dXJuWzAsMCwwLDBdfWdldCBvcmlnaW5hbENsaWVudENlbnRlcigpe3JldHVybiB0aGlzLm1lc2g/dGhpcy5tZXNoLmJvdW5kaW5nQ2VudGVyOlswLDBdfXNldCBkKHkpe3RoaXMuYXR0cmlidXRlcy5kPXl9Z2V0IGQoKXtyZXR1cm4gdGhpcy5hdHRyaWJ1dGVzLmR9ZHJhdyh5PVtdKXtzdXBlci5kcmF3KHkpO2NvbnN0IE09dGhpcy5tZXNoO3JldHVybiBNJiZPYmplY3QoZi5kcmF3VGV4dHVyZSkodGhpcyxNKSx5fWdldEJvdW5kaW5nQ2xpZW50UmVjdCgpe2xldCB5PW51bGw7cmV0dXJuIHRoaXMubWVzaCYmKHk9dGhpcy5tZXNoLmJvdW5kaW5nQm94KSxPYmplY3QoYy5kZWZhdWx0KSh5LHRoaXMucmVuZGVyTWF0cml4KX1nZXRQYXRoTGVuZ3RoKCl7cmV0dXJuIHRoaXMubWVzaD90aGlzLm1lc2guZ2V0VG90YWxMZW5ndGgoKTowfWdldFBvaW50QXRMZW5ndGgoeSl7aWYodGhpcy5tZXNoKXtjb25zdCBNPXRoaXMubWVzaC5nZXRQb2ludEF0TGVuZ3RoKHkpO2lmKE0pcmV0dXJuW00ueCxNLnldfXJldHVyblswLDBdfW9uUHJvcGVydHlDaGFuZ2UoeSxNLGkpe2lmKHN1cGVyLm9uUHJvcGVydHlDaGFuZ2UoeSxNLGkpLCh5PT09ImQifHx5PT09Im5vcm1hbGl6ZSIpJiZ0aGlzLnVwZGF0ZUNvbnRvdXJzKCksdGhpc1twXSYmKHk9PT0iZmlsbENvbG9yInx8eT09PSJmaWxsUnVsZSIpKXtjb25zdHtmaWxsQ29sb3I6YSxmaWxsUnVsZTpzfT10aGlzLmF0dHJpYnV0ZXM7T2JqZWN0KG8uc2V0RmlsbENvbG9yKSh0aGlzW3BdLHtjb2xvcjphLHJ1bGU6c30pfWlmKHRoaXNbcF0mJih5PT09InN0cm9rZUNvbG9yInx8eT09PSJsaW5lV2lkdGgifHx5PT09ImxpbmVDYXAifHx5PT09ImxpbmVKb2luInx8eT09PSJsaW5lRGFzaCJ8fHk9PT0ibGluZURhc2hPZmZzZXQifHx5PT09InJvdW5kU2VnbWVudHMiKSl7Y29uc3R7c3Ryb2tlQ29sb3I6YSxsaW5lV2lkdGg6c309dGhpcy5hdHRyaWJ1dGVzO2lmKGEmJnM+MCl7Y29uc3R7bGluZUNhcDpsLGxpbmVKb2luOk8sbGluZURhc2g6QSxsaW5lRGFzaE9mZnNldDpSLG1pdGVyTGltaXQ6SSxyb3VuZFNlZ21lbnRzOlB9PXRoaXMuYXR0cmlidXRlcztPYmplY3Qoby5zZXRTdHJva2VDb2xvcikodGhpc1twXSx7Y29sb3I6YSxsaW5lQ2FwOmwsbGluZUpvaW46TyxsaW5lV2lkdGg6cyxsaW5lRGFzaDpBLGxpbmVEYXNoT2Zmc2V0OlIsbWl0ZXJMaW1pdDpJLHJvdW5kU2VnbWVudHM6UH0pfX10aGlzW3BdJiZ5PT09ImNsaXBQYXRoIiYmdGhpc1twXS5zZXRDbGlwUGF0aChNKSx5PT09InRleHR1cmUiJiZPYmplY3QoZi5hcHBseVRleHR1cmUpKHRoaXMsTSl9dXBkYXRlQ29udG91cnMoKXt0aGlzLnBhdGg9bmV3IHIuRmlndXJlMkQsdGhpcy5wYXRoLmFkZFBhdGgodGhpcy5hdHRyaWJ1dGVzLmQpLHRoaXMuYXR0cmlidXRlcy5ub3JtYWxpemUmJnRoaXMucGF0aC5ub3JtYWxpemUoLi4udGhpcy5wYXRoLmJvdW5kaW5nQ2VudGVyKX19dihiLCJBdHRyIix1LmRlZmF1bHQpLHguZGVmYXVsdC5yZWdpc3Rlck5vZGUoYiwicGF0aCIpfSxmdW5jdGlvbihoLGUsdCl7KGZ1bmN0aW9uKHIsbil7aC5leHBvcnRzPW4oKX0pKHRoaXMsZnVuY3Rpb24oKXt2YXIgcj1mdW5jdGlvbigpe2Z1bmN0aW9uIEwoRCxDKXt2YXIgUz1bXSxCPSEwLHc9ITEsSD12b2lkIDA7dHJ5e2Zvcih2YXIgSj1EW1N5bWJvbC5pdGVyYXRvcl0oKSxxOyEoQj0ocT1KLm5leHQoKSkuZG9uZSkmJihTLnB1c2gocS52YWx1ZSksIShDJiZTLmxlbmd0aD09PUMpKTtCPSEwKTt9Y2F0Y2goVSl7dz0hMCxIPVV9ZmluYWxseXt0cnl7IUImJkoucmV0dXJuJiZKLnJldHVybigpfWZpbmFsbHl7aWYodyl0aHJvdyBIfX1yZXR1cm4gU31yZXR1cm4gZnVuY3Rpb24oRCxDKXtpZihBcnJheS5pc0FycmF5KEQpKXJldHVybiBEO2lmKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoRCkpcmV0dXJuIEwoRCxDKTt0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlIil9fSgpLG49TWF0aC5QSSoyLGQ9ZnVuY3Rpb24oRCxDLFMsQix3LEgsSil7dmFyIHE9RC54LFU9RC55O3EqPUMsVSo9Uzt2YXIgRz1CKnEtdypVLFo9dypxK0IqVTtyZXR1cm57eDpHK0gseTpaK0p9fSxnPWZ1bmN0aW9uKEQsQyl7dmFyIFM9MS4zMzMzMzMzMzMzMzMzMzMzKk1hdGgudGFuKEMvNCksQj1NYXRoLmNvcyhEKSx3PU1hdGguc2luKEQpLEg9TWF0aC5jb3MoRCtDKSxKPU1hdGguc2luKEQrQyk7cmV0dXJuW3t4OkItdypTLHk6dytCKlN9LHt4OkgrSipTLHk6Si1IKlN9LHt4OkgseTpKfV19LHU9ZnVuY3Rpb24oRCxDLFMsQil7dmFyIHc9RCpCLUMqUzwwPy0xOjEsSD1NYXRoLnNxcnQoRCpEK0MqQyksSj1NYXRoLnNxcnQoRCpEK0MqQykscT1EKlMrQypCLFU9cS8oSCpKKTtyZXR1cm4gVT4xJiYoVT0xKSxVPC0xJiYoVT0tMSksdypNYXRoLmFjb3MoVSl9LG89ZnVuY3Rpb24oRCxDLFMsQix3LEgsSixxLFUsRyxaLHR0KXt2YXIgXz1NYXRoLnBvdyh3LDIpLHN0PU1hdGgucG93KEgsMiksaz1NYXRoLnBvdyhaLDIpLGh0PU1hdGgucG93KHR0LDIpLGZ0PV8qc3QtXypodC1zdCprO2Z0PDAmJihmdD0wKSxmdC89XypodCtzdCprLGZ0PU1hdGguc3FydChmdCkqKEo9PT1xPy0xOjEpO3ZhciBXPWZ0KncvSCp0dCxGPWZ0Ki1IL3cqWixWPUcqVy1VKkYrKEQrUykvMixYPVUqVytHKkYrKEMrQikvMixqPShaLVcpL3csej0odHQtRikvSCxtPSgtWi1XKS93LFQ9KC10dC1GKS9ILE49dSgxLDAsaix6KSwkPXUoaix6LG0sVCk7cmV0dXJuIHE9PT0wJiYkPjAmJigkLT1uKSxxPT09MSYmJDwwJiYoJCs9biksW1YsWCxOLCRdfSxmPWZ1bmN0aW9uKEQpe3ZhciBDPUQucHgsUz1ELnB5LEI9RC5jeCx3PUQuY3ksSD1ELnJ4LEo9RC5yeSxxPUQueEF4aXNSb3RhdGlvbixVPXE9PT12b2lkIDA/MDpxLEc9RC5sYXJnZUFyY0ZsYWcsWj1HPT09dm9pZCAwPzA6Ryx0dD1ELnN3ZWVwRmxhZyxfPXR0PT09dm9pZCAwPzA6dHQsc3Q9W107aWYoSD09PTB8fEo9PT0wKXJldHVybltdO3ZhciBrPU1hdGguc2luKFUqbi8zNjApLGh0PU1hdGguY29zKFUqbi8zNjApLGZ0PWh0KihDLUIpLzIrayooUy13KS8yLFc9LWsqKEMtQikvMitodCooUy13KS8yO2lmKGZ0PT09MCYmVz09PTApcmV0dXJuW107SD1NYXRoLmFicyhIKSxKPU1hdGguYWJzKEopO3ZhciBGPU1hdGgucG93KGZ0LDIpL01hdGgucG93KEgsMikrTWF0aC5wb3coVywyKS9NYXRoLnBvdyhKLDIpO0Y+MSYmKEgqPU1hdGguc3FydChGKSxKKj1NYXRoLnNxcnQoRikpO3ZhciBWPW8oQyxTLEIsdyxILEosWixfLGssaHQsZnQsVyksWD1yKFYsNCksaj1YWzBdLHo9WFsxXSxtPVhbMl0sVD1YWzNdLE49TWF0aC5tYXgoTWF0aC5jZWlsKE1hdGguYWJzKFQpLyhuLzQpKSwxKTtULz1OO2Zvcih2YXIgJD0wOyQ8TjskKyspc3QucHVzaChnKG0sVCkpLG0rPVQ7cmV0dXJuIHN0Lm1hcChmdW5jdGlvbihLKXt2YXIgWT1kKEtbMF0sSCxKLGh0LGssaix6KSxRPVkueCxldD1ZLnkscnQ9ZChLWzFdLEgsSixodCxrLGoseiksb3Q9cnQueCxsdD1ydC55LGl0PWQoS1syXSxILEosaHQsayxqLHopLG50PWl0LngsYXQ9aXQueTtyZXR1cm57eDE6USx5MTpldCx4MjpvdCx5MjpsdCx4Om50LHk6YXR9fSl9LHg9e2E6NyxjOjYsaDoxLGw6MixtOjIscTo0LHM6NCx0OjIsdjoxLHo6MH0sYz0vKFthc3R2enFtaGxjXSkoW15hc3R2enFtaGxjXSopL2lnO2Z1bmN0aW9uIHYoTCl7dmFyIEQ9W107cmV0dXJuIEwucmVwbGFjZShjLGZ1bmN0aW9uKEMsUyxCKXt2YXIgdz1TLnRvTG93ZXJDYXNlKCk7Zm9yKEI9YihCKSx3PT0ibSImJkIubGVuZ3RoPjImJihELnB1c2goW1NdLmNvbmNhdChCLnNwbGljZSgwLDIpKSksdz0ibCIsUz1TPT0ibSI/ImwiOiJMIik7Oyl7aWYoQi5sZW5ndGg9PXhbd10pcmV0dXJuIEIudW5zaGlmdChTKSxELnB1c2goQik7aWYoQi5sZW5ndGg8eFt3XSl0aHJvdyBuZXcgRXJyb3IoIm1hbGZvcm1lZCBwYXRoIGRhdGEiKTtELnB1c2goW1NdLmNvbmNhdChCLnNwbGljZSgwLHhbd10pKSl9fSksRH12YXIgcD0vLT9bMC05XSpcLj9bMC05XSsoPzplWy0rXT9cZCspPy9pZztmdW5jdGlvbiBiKEwpe3ZhciBEPUwubWF0Y2gocCk7cmV0dXJuIEQ/RC5tYXAoTnVtYmVyKTpbXX1mdW5jdGlvbiBFKEwpe3ZhciBEPUxbMF1bMF0sQz1MWzBdWzFdLFM9RCxCPUM7cmV0dXJuIEwuZm9yRWFjaChmdW5jdGlvbih3KXt2YXIgSD13WzBdLEo9d1syXSxxPXdbNF0sVT13WzZdLEc9d1sxXSxaPXdbM10sdHQ9d1s1XSxfPXdbN107RD1NYXRoLm1pbihELEgsSixxLFUpLEM9TWF0aC5taW4oQyxHLFosdHQsXyksUz1NYXRoLm1heChTLEgsSixxLFUpLEI9TWF0aC5tYXgoQixHLFosdHQsXyl9KSxbRCxDLFMsQl19ZnVuY3Rpb24geShMLEQpe3JldHVybiBNYXRoLnNxcnQoTWF0aC5wb3coTFswXS1EWzBdLDIpK01hdGgucG93KExbMV0tRFsxXSwyKSkrTWF0aC5zcXJ0KE1hdGgucG93KExbMl0tRFsyXSwyKStNYXRoLnBvdyhMWzNdLURbM10sMikpfWZ1bmN0aW9uIE0oTCxEKXt2YXIgQz1MWzBdLFM9TFsyXSxCPUxbNF0sdz1MWzZdLEg9TFsxXSxKPUxbM10scT1MWzVdLFU9TFs3XSxHPURbMF0sWj1EWzJdLHR0PURbNF0sXz1EWzZdLHN0PURbMV0saz1EWzNdLGh0PURbNV0sZnQ9RFs3XTtyZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KEctQywyKStNYXRoLnBvdyhzdC1ILDIpKStNYXRoLnNxcnQoTWF0aC5wb3coWi1TLDIpK01hdGgucG93KGstSiwyKSkrTWF0aC5zcXJ0KE1hdGgucG93KHR0LUIsMikrTWF0aC5wb3coaHQtcSwyKSkrTWF0aC5zcXJ0KE1hdGgucG93KF8tdywyKStNYXRoLnBvdyhmdC1VLDIpKX1mdW5jdGlvbiBpKEwsRCl7dmFyIEM9cyhMLmxlbmd0aCksUz1bXTtDLmZvckVhY2goZnVuY3Rpb24odyl7dmFyIEg9MCxKPTA7dy5mb3JFYWNoKGZ1bmN0aW9uKHEpe0grPU0oTFtxXSxEW0orK10pfSksUy5wdXNoKHtpbmRleDp3LGRpc3RhbmNlOkh9KX0pLFMuc29ydChmdW5jdGlvbih3LEgpe3JldHVybiB3LmRpc3RhbmNlLUguZGlzdGFuY2V9KTt2YXIgQj1bXTtyZXR1cm4gU1swXS5pbmRleC5mb3JFYWNoKGZ1bmN0aW9uKHcpe0IucHVzaChMW3ddKX0pLEJ9ZnVuY3Rpb24gYShMLEQpe3ZhciBDPWwoTC5sZW5ndGgpLFM9W107Qy5mb3JFYWNoKGZ1bmN0aW9uKHcpe3ZhciBIPTA7dy5mb3JFYWNoKGZ1bmN0aW9uKEope0grPXkoRShMW0pdKSxFKERbSl0pKX0pLFMucHVzaCh7aW5kZXg6dyxkaXN0YW5jZTpIfSl9KSxTLnNvcnQoZnVuY3Rpb24odyxIKXtyZXR1cm4gdy5kaXN0YW5jZS1ILmRpc3RhbmNlfSk7dmFyIEI9W107cmV0dXJuIFNbMF0uaW5kZXguZm9yRWFjaChmdW5jdGlvbih3KXtCLnB1c2goTFt3XSl9KSxCfWZ1bmN0aW9uIHMoTCl7Zm9yKHZhciBEPVtdLEM9MDtDPEw7QysrKXtmb3IodmFyIFM9W10sQj0wO0I8TDtCKyspe3ZhciB3PUIrQzt3PkwtMSYmKHctPUwpLFNbd109Qn1ELnB1c2goUyl9cmV0dXJuIER9ZnVuY3Rpb24gbChMKXtmb3IodmFyIEQ9W10sQz0wO0M8TDtDKyspRC5wdXNoKEMpO3JldHVybiBPKEQpfWZ1bmN0aW9uIE8oTCl7dmFyIEQ9W10sQz1bXTtmdW5jdGlvbiBTKEIpe3ZhciB3LEg7Zm9yKHc9MDt3PEIubGVuZ3RoO3crKylIPUIuc3BsaWNlKHcsMSlbMF0sQy5wdXNoKEgpLEIubGVuZ3RoPT0wJiZELnB1c2goQy5zbGljZSgpKSxTKEIpLEIuc3BsaWNlKHcsMCxIKSxDLnBvcCgpO3JldHVybiBEfXJldHVybiBTKEwpfXZhciBBPXt9O0EucGFyc2VyPXYsQS5sZXJwQ3VydmU9ZnVuY3Rpb24oTCxELEMpe3JldHVybiBBLmxlcnBQb2ludHMoTFswXSxMWzFdLERbMF0sRFsxXSxDKS5jb25jYXQoQS5sZXJwUG9pbnRzKExbMl0sTFszXSxEWzJdLERbM10sQykpLmNvbmNhdChBLmxlcnBQb2ludHMoTFs0XSxMWzVdLERbNF0sRFs1XSxDKSkuY29uY2F0KEEubGVycFBvaW50cyhMWzZdLExbN10sRFs2XSxEWzddLEMpKX0sQS5sZXJwUG9pbnRzPWZ1bmN0aW9uKEwsRCxDLFMsQil7cmV0dXJuW0wrKEMtTCkqQixEKyhTLUQpKkJdfSxBLnEyYj1mdW5jdGlvbihMLEQsQyxTLEIsdyl7cmV0dXJuW0wsRCwoTCsyKkMpLzMsKEQrMipTKS8zLChCKzIqQykvMywodysyKlMpLzMsQix3XX0sQS5wYXRoMnNoYXBlcz1mdW5jdGlvbihMKXtmb3IodmFyIEQ9QS5wYXJzZXIoTCksQz0wLFM9MCxCPTAsdz1ELmxlbmd0aCxIPVtdLEo9bnVsbCxxPXZvaWQgMCxVPXZvaWQgMCxHPXZvaWQgMCxaPXZvaWQgMCx0dD12b2lkIDAsXz12b2lkIDAsc3Q9dm9pZCAwO0I8dztCKyspe3ZhciBrPURbQl0saHQ9a1swXSxmdD1EW0ItMV07c3dpdGNoKGh0KXtjYXNlIm0iOnR0PUgubGVuZ3RoLEhbdHRdPVtdLEo9SFt0dF0sQz1DK2tbMV0sUz1TK2tbMl07YnJlYWs7Y2FzZSJNIjp0dD1ILmxlbmd0aCxIW3R0XT1bXSxKPUhbdHRdLEM9a1sxXSxTPWtbMl07YnJlYWs7Y2FzZSJsIjpKLnB1c2goW0MsUyxDLFMsQyxTLEMra1sxXSxTK2tbMl1dKSxDKz1rWzFdLFMrPWtbMl07YnJlYWs7Y2FzZSJMIjpKLnB1c2goW0MsUyxrWzFdLGtbMl0sa1sxXSxrWzJdLGtbMV0sa1syXV0pLEM9a1sxXSxTPWtbMl07YnJlYWs7Y2FzZSJoIjpKLnB1c2goW0MsUyxDLFMsQyxTLEMra1sxXSxTXSksQys9a1sxXTticmVhaztjYXNlIkgiOkoucHVzaChbQyxTLGtbMV0sUyxrWzFdLFMsa1sxXSxTXSksQz1rWzFdO2JyZWFrO2Nhc2UidiI6Si5wdXNoKFtDLFMsQyxTLEMsUyxDLFMra1sxXV0pLFMrPWtbMV07YnJlYWs7Y2FzZSJWIjpKLnB1c2goW0MsUyxDLGtbMV0sQyxrWzFdLEMsa1sxXV0pLFM9a1sxXTticmVhaztjYXNlIkMiOkoucHVzaChbQyxTLGtbMV0sa1syXSxrWzNdLGtbNF0sa1s1XSxrWzZdXSksQz1rWzVdLFM9a1s2XTticmVhaztjYXNlIlMiOmZ0WzBdPT09IkMifHxmdFswXT09PSJjIj9KLnB1c2goW0MsUyxDK2Z0WzVdLWZ0WzNdLFMrZnRbNl0tZnRbNF0sa1sxXSxrWzJdLGtbM10sa1s0XV0pOihmdFswXT09PSJTInx8ZnRbMF09PT0icyIpJiZKLnB1c2goW0MsUyxDK2Z0WzNdLWZ0WzFdLFMrZnRbNF0tZnRbMl0sa1sxXSxrWzJdLGtbM10sa1s0XV0pLEM9a1szXSxTPWtbNF07YnJlYWs7Y2FzZSJjIjpKLnB1c2goW0MsUyxDK2tbMV0sUytrWzJdLEMra1szXSxTK2tbNF0sQytrWzVdLFMra1s2XV0pLEM9QytrWzVdLFM9UytrWzZdO2JyZWFrO2Nhc2UicyI6ZnRbMF09PT0iQyJ8fGZ0WzBdPT09ImMiP0oucHVzaChbQyxTLEMrZnRbNV0tZnRbM10sUytmdFs2XS1mdFs0XSxDK2tbMV0sUytrWzJdLEMra1szXSxTK2tbNF1dKTooZnRbMF09PT0iUyJ8fGZ0WzBdPT09InMiKSYmSi5wdXNoKFtDLFMsQytmdFszXS1mdFsxXSxTK2Z0WzRdLWZ0WzJdLEMra1sxXSxTK2tbMl0sQytrWzNdLFMra1s0XV0pLEM9QytrWzNdLFM9UytrWzRdO2JyZWFrO2Nhc2UiYSI6Xz1mKHtyeDprWzFdLHJ5OmtbMl0scHg6QyxweTpTLHhBeGlzUm90YXRpb246a1szXSxsYXJnZUFyY0ZsYWc6a1s0XSxzd2VlcEZsYWc6a1s1XSxjeDpDK2tbNl0sY3k6UytrWzddfSksc3Q9X1tfLmxlbmd0aC0xXSxfLmZvckVhY2goZnVuY3Rpb24oVyxGKXtGPT09MD9KLnB1c2goW0MsUyxXLngxLFcueTEsVy54MixXLnkyLFcueCxXLnldKTpKLnB1c2goW19bRi0xXS54LF9bRi0xXS55LFcueDEsVy55MSxXLngyLFcueTIsVy54LFcueV0pfSksQz1zdC54LFM9c3QueTticmVhaztjYXNlIkEiOl89Zih7cng6a1sxXSxyeTprWzJdLHB4OkMscHk6Uyx4QXhpc1JvdGF0aW9uOmtbM10sbGFyZ2VBcmNGbGFnOmtbNF0sc3dlZXBGbGFnOmtbNV0sY3g6a1s2XSxjeTprWzddfSksc3Q9X1tfLmxlbmd0aC0xXSxfLmZvckVhY2goZnVuY3Rpb24oVyxGKXtGPT09MD9KLnB1c2goW0MsUyxXLngxLFcueTEsVy54MixXLnkyLFcueCxXLnldKTpKLnB1c2goW19bRi0xXS54LF9bRi0xXS55LFcueDEsVy55MSxXLngyLFcueTIsVy54LFcueV0pfSksQz1zdC54LFM9c3QueTticmVhaztjYXNlIlEiOkoucHVzaChBLnEyYihDLFMsa1sxXSxrWzJdLGtbM10sa1s0XSkpLEM9a1szXSxTPWtbNF07YnJlYWs7Y2FzZSJxIjpKLnB1c2goQS5xMmIoQyxTLEMra1sxXSxTK2tbMl0sa1szXStDLGtbNF0rUykpLEMrPWtbM10sUys9a1s0XTticmVhaztjYXNlIlQiOmZ0WzBdPT09IlEifHxmdFswXT09PSJxIj8oRz1DK2Z0WzNdLWZ0WzFdLFo9UytmdFs0XS1mdFsyXSxKLnB1c2goQS5xMmIoQyxTLEcsWixrWzFdLGtbMl0pKSk6KGZ0WzBdPT09IlQifHxmdFswXT09PSJ0IikmJihKLnB1c2goQS5xMmIoQyxTLEMrQy1HLFMrUy1aLGtbMV0sa1syXSkpLEc9QytDLUcsWj1TK1MtWiksQz1rWzFdLFM9a1syXTticmVhaztjYXNlInQiOmZ0WzBdPT09IlEifHxmdFswXT09PSJxIj8oRz1DK2Z0WzNdLWZ0WzFdLFo9UytmdFs0XS1mdFsyXSxKLnB1c2goQS5xMmIoQyxTLEcsWixDK2tbMV0sUytrWzJdKSkpOihmdFswXT09PSJUInx8ZnRbMF09PT0idCIpJiYoSi5wdXNoKEEucTJiKEMsUyxDK0MtRyxTK1MtWixDK2tbMV0sUytrWzJdKSksRz1DK0MtRyxaPVMrUy1aKSxDKz1rWzFdLFMrPWtbMl07YnJlYWs7Y2FzZSJaIjpxPUpbMF1bMF0sVT1KWzBdWzFdLEoucHVzaChbQyxTLHEsVSxxLFUscSxVXSk7YnJlYWs7Y2FzZSJ6IjpxPUpbMF1bMF0sVT1KWzBdWzFdLEoucHVzaChbQyxTLHEsVSxxLFUscSxVXSk7YnJlYWt9fXJldHVybiBIfSxBLl91cEN1cnZlcz1mdW5jdGlvbihMLEQpe2Zvcih2YXIgQz0wLFM9MCxCPUwubGVuZ3RoO0M8RDtDKyspTC5wdXNoKExbU10uc2xpY2UoMCkpLFMrKyxTPkItMSYmKFMtPUIpfTtmdW5jdGlvbiBSKEwsRCxDLFMsQix3LEgsSixxKXtyZXR1cm57bGVmdDpJKEwsRCxDLFMsQix3LEgsSixxKSxyaWdodDpJKEgsSixCLHcsQyxTLEwsRCwxLXEsITApfX1mdW5jdGlvbiBJKEwsRCxDLFMsQix3LEgsSixxLFUpe3ZhciBHPShDLUwpKnErTCxaPShTLUQpKnErRCx0dD0oQi1DKSpxK0MsXz0ody1TKSpxK1Msc3Q9KEgtQikqcStCLGs9KEotdykqcSt3LGh0PSh0dC1HKSpxK0csZnQ9KF8tWikqcStaLFc9KHN0LXR0KSpxK3R0LEY9KGstXykqcStfLFY9KFctaHQpKnEraHQsWD0oRi1mdCkqcStmdDtyZXR1cm4gVT9bVixYLGh0LGZ0LEcsWixMLERdOltMLEQsRyxaLGh0LGZ0LFYsWF19QS5fc3BsaXRDdXJ2ZXM9ZnVuY3Rpb24oTCxEKXtmb3IodmFyIEM9MCxTPTA7QzxEO0MrKyl7dmFyIEI9TFtTXSx3PVIoQlswXSxCWzFdLEJbMl0sQlszXSxCWzRdLEJbNV0sQls2XSxCWzddLC41KTtMLnNwbGljZShTLDEpLEwuc3BsaWNlKFMsMCx3LmxlZnQsdy5yaWdodCksUys9MixTPj1MLmxlbmd0aC0xJiYoUz0wKX19O2Z1bmN0aW9uIFAoTCxEKXtmb3IodmFyIEM9ZnVuY3Rpb24odyl7dmFyIEg9TFtMLmxlbmd0aC0xXSxKPVtdO0guZm9yRWFjaChmdW5jdGlvbihxKXtKLnB1c2gocS5zbGljZSgwKSl9KSxMLnB1c2goSil9LFM9MDtTPEQ7UysrKUMoKX1yZXR1cm4gQS5sZXJwPWZ1bmN0aW9uKEwsRCxDKXtyZXR1cm4gQS5fbGVycChBLnBhdGgyc2hhcGVzKEwpLEEucGF0aDJzaGFwZXMoRCksQyl9LEEuTUlNX0NVUlZFU19DT1VOVD0xMDAsQS5fcHJlcHJvY2Vzc2luZz1mdW5jdGlvbihMLEQpe3ZhciBDPUwubGVuZ3RoLFM9RC5sZW5ndGgsQj1KU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KEwpKSx3PUpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoRCkpO3JldHVybiBDPlM/UCh3LEMtUyk6QzxTJiZQKEIsUy1DKSxCPWEoQix3KSxCLmZvckVhY2goZnVuY3Rpb24oSCxKKXt2YXIgcT1ILmxlbmd0aCxVPXdbSl0ubGVuZ3RoO3E+VT9xPEEuTUlNX0NVUlZFU19DT1VOVD8oQS5fc3BsaXRDdXJ2ZXMoSCxBLk1JTV9DVVJWRVNfQ09VTlQtcSksQS5fc3BsaXRDdXJ2ZXMod1tKXSxBLk1JTV9DVVJWRVNfQ09VTlQtVSkpOkEuX3NwbGl0Q3VydmVzKHdbSl0scS1VKTpxPFUmJihVPEEuTUlNX0NVUlZFU19DT1VOVD8oQS5fc3BsaXRDdXJ2ZXMoSCxBLk1JTV9DVVJWRVNfQ09VTlQtcSksQS5fc3BsaXRDdXJ2ZXMod1tKXSxBLk1JTV9DVVJWRVNfQ09VTlQtVSkpOkEuX3NwbGl0Q3VydmVzKEgsVS1xKSl9KSxCLmZvckVhY2goZnVuY3Rpb24oSCxKKXtCW0pdPWkoSCx3W0pdKX0pLFtCLHddfSxBLl9sZXJwPWZ1bmN0aW9uKEwsRCxDKXt2YXIgUz1bXTtyZXR1cm4gTC5mb3JFYWNoKGZ1bmN0aW9uKEIsdyl7dmFyIEg9W107Qi5mb3JFYWNoKGZ1bmN0aW9uKEoscSl7SC5wdXNoKEEubGVycEN1cnZlKEosRFt3XVtxXSxDKSl9KSxTLnB1c2goSCl9KSxTfSxBLmFuaW1hdGU9ZnVuY3Rpb24oTCl7dmFyIEQ9QS5wYXRoMnNoYXBlcyhMLmZyb20pLEM9QS5wYXRoMnNoYXBlcyhMLnRvKSxTPUEuX3ByZXByb2Nlc3NpbmcoRCxDKSxCPW5ldyBEYXRlLHc9TC5lbmR8fGZ1bmN0aW9uKCl7fSxIPUwucHJvZ3Jlc3N8fGZ1bmN0aW9uKCl7fSxKPUwuYmVnaW58fGZ1bmN0aW9uKCl7fSxxPUwuZWFzaW5nfHxmdW5jdGlvbihfKXtyZXR1cm4gX30sVT1udWxsLEc9bnVsbCxaPUwudGltZTtKKEQpO3ZhciB0dD1mdW5jdGlvbiBfKCl7dmFyIHN0PW5ldyBEYXRlLUI7aWYoc3Q+PVope0c9QyxIKEcsMSksdyhHKSxjYW5jZWxBbmltYXRpb25GcmFtZShVKTtyZXR1cm59dmFyIGs9cShzdC9aKTtHPUEuX2xlcnAoU1swXSxTWzFdLGspLEgoRyxrKSxVPXJlcXVlc3RBbmltYXRpb25GcmFtZShfKX07dHQoKX0sQX0pfSxmdW5jdGlvbihoLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBmfSk7dmFyIHI9dCg3MSksbj10KDIyMSksZD10KDcyKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3QgZz1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGVEZWZhdWx0IiksdT1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGUiKSxvPVN5bWJvbC5mb3IoInNwcml0ZWpzX2dldEF0dHJpYnV0ZSIpO2NsYXNzIGYgZXh0ZW5kcyByLmRlZmF1bHR7Y29uc3RydWN0b3IoYyl7c3VwZXIoYyksdGhpc1tnXSh7ZDoiIixub3JtYWxpemU6ITEsZmlsbENvbG9yOnZvaWQgMCxmaWxsUnVsZToibm9uemVybyIsc3Ryb2tlQ29sb3I6dm9pZCAwLGxpbmVXaWR0aDoxLGxpbmVKb2luOiJtaXRlciIsbGluZUNhcDoiYnV0dCIscm91bmRTZWdtZW50czoyMCxsaW5lRGFzaDp2b2lkIDAsbGluZURhc2hPZmZzZXQ6MCxtaXRlckxpbWl0OjEwLHRleHR1cmU6dm9pZCAwLHRleHR1cmVSZWN0OnZvaWQgMCx0ZXh0dXJlUmVwZWF0OiExLHNvdXJjZVJlY3Q6dm9pZCAwLGNsaXBQYXRoOnZvaWQgMH0pfWdldCBkKCl7cmV0dXJuIHRoaXNbb10oImQiKX1zZXQgZChjKXt0aGlzW3VdKCJkIixjKX1nZXQgbm9ybWFsaXplKCl7cmV0dXJuIHRoaXNbb10oIm5vcm1hbGl6ZSIpfXNldCBub3JtYWxpemUoYyl7dGhpc1t1XSgibm9ybWFsaXplIiwhIWMpfWdldCBmaWxsQ29sb3IoKXtyZXR1cm4gdGhpc1tvXSgiZmlsbENvbG9yIil9c2V0IGZpbGxDb2xvcihjKXt0aGlzW3VdKCJmaWxsQ29sb3IiLE9iamVjdChuLnBhcnNlQ29sb3IpKGMpKX1nZXQgZmlsbFJ1bGUoKXtyZXR1cm4gdGhpc1tvXSgiZmlsbFJ1bGUiKX1zZXQgZmlsbFJ1bGUoYyl7aWYoYyE9bnVsbCYmYyE9PSJub256ZXJvIiYmYyE9PSJldmVub2RkIil0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIGZpbGwgcnVsZS4iKTt0aGlzW3VdKCJmaWxsUnVsZSIsYyl9Z2V0IHN0cm9rZUNvbG9yKCl7cmV0dXJuIHRoaXNbb10oInN0cm9rZUNvbG9yIil9c2V0IHN0cm9rZUNvbG9yKGMpe3RoaXNbdV0oInN0cm9rZUNvbG9yIixPYmplY3Qobi5wYXJzZUNvbG9yKShjKSl9Z2V0IGxpbmVXaWR0aCgpe3JldHVybiB0aGlzW29dKCJsaW5lV2lkdGgiKX1zZXQgbGluZVdpZHRoKGMpe3RoaXNbdV0oImxpbmVXaWR0aCIsT2JqZWN0KGQudG9OdW1iZXIpKGMpKX1nZXQgbGluZUpvaW4oKXtyZXR1cm4gdGhpc1tvXSgibGluZUpvaW4iKX1zZXQgbGluZUpvaW4oYyl7aWYoYyE9bnVsbCYmYyE9PSJtaXRlciImJmMhPT0iYmV2ZWwiJiZjIT09InJvdW5kIil0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIGxpbmVKb2luIHR5cGUuIik7dGhpc1t1XSgibGluZUpvaW4iLGMpfWdldCBsaW5lQ2FwKCl7cmV0dXJuIHRoaXNbb10oImxpbmVDYXAiKX1zZXQgbGluZUNhcChjKXtpZihjIT1udWxsJiZjIT09ImJ1dHQiJiZjIT09InNxdWFyZSImJmMhPT0icm91bmQiKXRocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgbGluZUNhcCB0eXBlLiIpO3RoaXNbdV0oImxpbmVDYXAiLGMpfWdldCBsaW5lRGFzaCgpe3JldHVybiB0aGlzW29dKCJsaW5lRGFzaCIpfXNldCBsaW5lRGFzaChjKXtjPU9iamVjdChkLnRvQXJyYXkpKGMsITApLGMhPW51bGwmJiFBcnJheS5pc0FycmF5KGMpJiYoYz1bY10pLHRoaXNbdV0oImxpbmVEYXNoIixjP2MubWFwKGQudG9OdW1iZXIpOm51bGwpfWdldCBsaW5lRGFzaE9mZnNldCgpe3JldHVybiB0aGlzW29dKCJsaW5lRGFzaE9mZnNldCIpfXNldCBsaW5lRGFzaE9mZnNldChjKXt0aGlzW3VdKCJsaW5lRGFzaE9mZnNldCIsT2JqZWN0KGQudG9OdW1iZXIpKGMpKX1nZXQgbWl0ZXJMaW1pdCgpe3JldHVybiB0aGlzW29dKCJtaXRlckxpbWl0Iil9c2V0IG1pdGVyTGltaXQoYyl7dGhpc1t1XSgibWl0ZXJMaW1pdCIsT2JqZWN0KGQudG9OdW1iZXIpKGMpKX1nZXQgcm91bmRTZWdtZW50cygpe3JldHVybiB0aGlzW29dKCJyb3VuZFNlZ21lbnRzIil9c2V0IHJvdW5kU2VnbWVudHMoYyl7dGhpc1t1XSgicm91bmRTZWdtZW50cyIsYyl9Z2V0IHRleHR1cmUoKXtyZXR1cm4gdGhpc1tvXSgidGV4dHVyZSIpfXNldCB0ZXh0dXJlKGMpe3RoaXNbdV0oInRleHR1cmUiLGMpfWdldCB0ZXh0dXJlUmVjdCgpe3JldHVybiB0aGlzW29dKCJ0ZXh0dXJlUmVjdCIpfXNldCB0ZXh0dXJlUmVjdChjKXt0aGlzW3VdKCJ0ZXh0dXJlUmVjdCIsYyl9Z2V0IHNvdXJjZVJlY3QoKXtyZXR1cm4gdGhpc1tvXSgic291cmNlUmVjdCIpfXNldCBzb3VyY2VSZWN0KGMpe3RoaXNbdV0oInNvdXJjZVJlY3QiLGMpfWdldCB0ZXh0dXJlUmVwZWF0KCl7cmV0dXJuIHRoaXNbb10oInRleHR1cmVSZXBlYXQiKX1zZXQgdGV4dHVyZVJlcGVhdChjKXt0aGlzW3VdKCJ0ZXh0dXJlUmVwZWF0IiwhIWMpfWdldCBjbGlwUGF0aCgpe3JldHVybiB0aGlzW29dKCJjbGlwUGF0aCIpfXNldCBjbGlwUGF0aChjKXt0aGlzW3VdKCJjbGlwUGF0aCIsYyl9fX0sZnVuY3Rpb24oaCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gdX0pO3ZhciByPXQoMjI2KSxuPXQoMjEzKSxkPXQoMjMwKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gZyhvLGYseCl7cmV0dXJuIGYgaW4gbz9PYmplY3QuZGVmaW5lUHJvcGVydHkobyxmLHt2YWx1ZTp4LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6b1tmXT14LG99Y2xhc3MgdSBleHRlbmRzIHIuZGVmYXVsdHtnZXQgaXNWaXNpYmxlKCl7Y29uc3R7d2lkdGg6ZixoZWlnaHQ6eH09dGhpcy5hdHRyaWJ1dGVzO3JldHVybiBmPjAmJng+MCYmc3VwZXIuaXNWaXNpYmxlfX1nKHUsIkF0dHIiLGQuZGVmYXVsdCksbi5kZWZhdWx0LnJlZ2lzdGVyTm9kZSh1LCJyZWN0Iil9LGZ1bmN0aW9uKGgsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIHh9KTt2YXIgcj10KDIyOCksbj10KDcyKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3QgZD1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGVEZWZhdWx0IiksZz1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGUiKSx1PVN5bWJvbC5mb3IoInNwcml0ZWpzX2dldEF0dHJpYnV0ZSIpLG89U3ltYm9sLmZvcigic3ByaXRlanNfZGVjbGFyZUFsaWFzIik7ZnVuY3Rpb24gZihjKXtjb25zdHt3aWR0aDp2LGhlaWdodDpwfT1jO3JldHVybmBNMCAwTCR7dn0gMEwke3Z9ICR7cH1MMCAke3B9WmB9Y2xhc3MgeCBleHRlbmRzIHIuZGVmYXVsdHtjb25zdHJ1Y3Rvcih2KXtzdXBlcih2KSx0aGlzW2RdKHt3aWR0aDowLGhlaWdodDowfSksdGhpc1tvXSgic2l6ZSIpfWdldCBkKCl7cmV0dXJuIHRoaXNbdV0oImQiKX1zZXQgZCh2KXt9Z2V0IHdpZHRoKCl7cmV0dXJuIHRoaXNbdV0oIndpZHRoIil9c2V0IHdpZHRoKHYpe2lmKHY9T2JqZWN0KG4udG9OdW1iZXIpKHYpLHRoaXNbZ10oIndpZHRoIix2KSl7Y29uc3QgcD1mKHRoaXMpO3RoaXNbZ10oImQiLHApfX1nZXQgaGVpZ2h0KCl7cmV0dXJuIHRoaXNbdV0oImhlaWdodCIpfXNldCBoZWlnaHQodil7aWYodj1PYmplY3Qobi50b051bWJlcikodiksdGhpc1tnXSgiaGVpZ2h0Iix2KSl7Y29uc3QgcD1mKHRoaXMpO3RoaXNbZ10oImQiLHApfX1nZXQgc2l6ZSgpe3JldHVyblt0aGlzLndpZHRoLHRoaXMuaGVpZ2h0XX1zZXQgc2l6ZSh2KXt2PU9iamVjdChuLnRvQXJyYXkpKHYpLEFycmF5LmlzQXJyYXkodil8fCh2PVt2LHZdKSx0aGlzLndpZHRoPXZbMF0sdGhpcy5oZWlnaHQ9dlsxXX19fSxmdW5jdGlvbihoLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiB1fSk7dmFyIHI9dCgyMzIpLG49dCgyMTMpLGQ9dCgyMzUpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBnKG8sZix4KXtyZXR1cm4gZiBpbiBvP09iamVjdC5kZWZpbmVQcm9wZXJ0eShvLGYse3ZhbHVlOngsZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTpvW2ZdPXgsb31jbGFzcyB1IGV4dGVuZHMgci5kZWZhdWx0e2dldCBpc1Zpc2libGUoKXtjb25zdHtzaWRlczpmfT10aGlzLmF0dHJpYnV0ZXM7cmV0dXJuIGZbMF0+MCYmZlsxXT4wJiZzdXBlci5pc1Zpc2libGV9fWcodSwiQXR0ciIsZC5kZWZhdWx0KSxuLmRlZmF1bHQucmVnaXN0ZXJOb2RlKHUsInRyaWFuZ2xlIil9LGZ1bmN0aW9uKGgsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIHV9KTt2YXIgcj10KDIyNiksbj10KDIxMyksZD10KDIzMyk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIGcobyxmLHgpe3JldHVybiBmIGluIG8/T2JqZWN0LmRlZmluZVByb3BlcnR5KG8sZix7dmFsdWU6eCxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOm9bZl09eCxvfWNsYXNzIHUgZXh0ZW5kcyByLmRlZmF1bHR7Z2V0IGlzVmlzaWJsZSgpe2NvbnN0e3BvaW50czpmfT10aGlzLmF0dHJpYnV0ZXM7cmV0dXJuIGYubGVuZ3RoPjAmJnN1cGVyLmlzVmlzaWJsZX19Zyh1LCJBdHRyIixkLmRlZmF1bHQpLG4uZGVmYXVsdC5yZWdpc3Rlck5vZGUodSwicG9seWxpbmUiKX0sZnVuY3Rpb24oaCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gY30pO3ZhciByPXQoMjI4KSxuPXQoNzIpLGQ9dCgyMzQpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCBnPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZURlZmF1bHQiKSx1PVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZSIpLG89U3ltYm9sLmZvcigic3ByaXRlanNfZ2V0QXR0cmlidXRlIiksZj1TeW1ib2wuZm9yKCJzcHJpdGVqc19kZWNsYXJlQWxpYXMiKTtmdW5jdGlvbiB4KHYpe2NvbnN0e3BvaW50czpwLHNtb290aDpiLHNtb290aFJhbmdlOkUsY2xvc2U6eX09dixNPVtdO2ZvcihsZXQgYT0wO2E8cC5sZW5ndGg7YSs9MilNLnB1c2goW3BbYV0scFthKzFdXSk7bGV0IGk9IiI7cmV0dXJuIGI/aT1PYmplY3QoZC5tYWtlU21vb3RoQ3VydmVMaW5lKShNLEUpOk0ubGVuZ3RoJiYoaT1gTSR7TS5tYXAoYT0+YS5qb2luKCIgIikpLmpvaW4oIkwiKX1gKSxpJiZ5JiYoaSs9IloiKSxpfWNsYXNzIGMgZXh0ZW5kcyByLmRlZmF1bHR7Y29uc3RydWN0b3IocCl7c3VwZXIocCksdGhpc1tnXSh7cG9pbnRzOltdLHNtb290aDohMSxzbW9vdGhSYW5nZTpbMF0sY2xvc2VUeXBlOiJub25lIn0pLHRoaXNbZl0oImNsb3NlIil9Z2V0IGQoKXtyZXR1cm4gdGhpc1tvXSgiZCIpfXNldCBkKHApe31nZXQgY2xvc2UoKXtyZXR1cm4gdGhpcy5jbG9zZVR5cGUhPT0ibm9uZSJ9c2V0IGNsb3NlKHApe3A9cD8ibm9ybWFsIjoibm9uZSIsdGhpcy5jbG9zZVR5cGU9cH1nZXQgY2xvc2VUeXBlKCl7cmV0dXJuIHRoaXNbb10oImNsb3NlVHlwZSIpfXNldCBjbG9zZVR5cGUocCl7aWYocCE9bnVsbCYmcCE9PSJub25lIiYmcCE9PSJub3JtYWwiKXRocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgY2xvc2VUeXBlIHR5cGUuIik7aWYodGhpc1t1XSgiY2xvc2VUeXBlIixwKSl7Y29uc3QgYj14KHRoaXMpO3RoaXNbdV0oImQiLGIpfX1nZXQgc21vb3RoKCl7cmV0dXJuIHRoaXNbb10oInNtb290aCIpfXNldCBzbW9vdGgocCl7aWYodGhpc1t1XSgic21vb3RoIixwKSl7Y29uc3QgYj14KHRoaXMpO3RoaXNbdV0oImQiLGIpfX1nZXQgc21vb3RoUmFuZ2UoKXtyZXR1cm4gdGhpc1tvXSgic21vb3RoUmFuZ2UiKX1zZXQgc21vb3RoUmFuZ2UocCl7aWYocCYmIUFycmF5LmlzQXJyYXkocCkmJihwPVtwXSksdGhpc1t1XSgic21vb3RoUmFuZ2UiLHApJiZ0aGlzLnNtb290aCl7Y29uc3QgYj14KHRoaXMpO3RoaXNbdV0oImQiLGIpfX1nZXQgcG9pbnRzKCl7cmV0dXJuIHRoaXNbb10oInBvaW50cyIpfXNldCBwb2ludHMocCl7aWYocD1PYmplY3Qobi50b0FycmF5KShwKSxBcnJheS5pc0FycmF5KHApJiYocD1wLnJlZHVjZSgoYixFKT0+QXJyYXkuaXNBcnJheShFKT9bLi4uYiwuLi5FLm1hcCh5PT5PYmplY3Qobi50b051bWJlcikoeSkpXTpbLi4uYixPYmplY3Qobi50b051bWJlcikoRSldLFtdKSksdGhpc1t1XSgicG9pbnRzIixwKSl7Y29uc3QgYj14KHRoaXMpO3RoaXNbdV0oImQiLGIpfX19fSxmdW5jdGlvbihoLGUsdCl7dC5yKGUpLHQuZChlLCJtYWtlU21vb3RoQ3VydmVMaW5lIixmdW5jdGlvbigpe3JldHVybiByfSksdCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIHIobixkPVswXSl7ZnVuY3Rpb24gZyhmLHg9LjE2OCxjPS4xNjgpe2xldCB2LHAsYixFO2lmKChuW2ZdLng9PT1uW2YrMV0ueHx8bltmXS55PT09bltmKzFdLnkpJiYoeD0wLGM9MCksZjwxPyh2PW5bMF0ueCsoblsxXS54LW5bMF0ueCkqeCxwPW5bMF0ueSsoblsxXS55LW5bMF0ueSkqeCk6KHY9bltmXS54KyhuW2YrMV0ueC1uW2YtMV0ueCkqeCxwPW5bZl0ueSsobltmKzFdLnktbltmLTFdLnkpKngpLGY+bi5sZW5ndGgtMyl7Y29uc3QgeT1uLmxlbmd0aC0xO2I9blt5XS54LShuW3ldLngtblt5LTFdLngpKmMsRT1uW3ldLnktKG5beV0ueS1uW3ktMV0ueSkqY31lbHNlIGI9bltmKzFdLngtKG5bZisyXS54LW5bZl0ueCkqYyxFPW5bZisxXS55LShuW2YrMl0ueS1uW2ZdLnkpKmM7cmV0dXJuW3t4OnYseTpwfSx7eDpiLHk6RX1dfW49bi5tYXAoKFtmLHhdKT0+KHt4OmYseTp4fSkpO2xldCB1PSIiLG89MDtyZXR1cm4gbi5mb3JFYWNoKChmLHgpPT57aWYoeD09PTApdSs9YE0ke2YueH0gJHtmLnl9YDtlbHNle2Zvcig7eD5kW29dOylvKys7aWYobyUyKXtjb25zdFtjLHZdPWcoeC0xKTt1Kz1gQyR7W2MueCxjLnksdi54LHYueSxmLngsZi55XS5qb2luKCIgIil9YH1lbHNlIHUrPWBMJHtmLnh9ICR7Zi55fWB9fSksdX19LGZ1bmN0aW9uKGgsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIGZ9KTt2YXIgcj10KDIzMyksbj10KDcyKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3QgZD1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGVEZWZhdWx0IiksZz1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGUiKSx1PVN5bWJvbC5mb3IoInNwcml0ZWpzX2dldEF0dHJpYnV0ZSIpO2Z1bmN0aW9uIG8oeCl7Y29uc3RbYyx2XT14LnNpZGVzO2xldCBwPXguYW5nbGUlMzYwO3JldHVybiBwPDAmJihwKz0zNjApLHA9TWF0aC5QSSpwLzE4MCxbMCwwLGMsMCx2Kk1hdGguY29zKHApLHYqTWF0aC5zaW4ocCldfWNsYXNzIGYgZXh0ZW5kcyByLmRlZmF1bHR7Y29uc3RydWN0b3IoYyl7c3VwZXIoYyksdGhpc1tkXSh7c2lkZXM6WzAsMF0sYW5nbGU6NjAsY2xvc2VUeXBlOiJub3JtYWwifSl9Z2V0IHBvaW50cygpe3JldHVybiBzdXBlci5wb2ludHN9c2V0IHBvaW50cyhjKXt9Z2V0IHNpZGVzKCl7cmV0dXJuIHRoaXNbdV0oInNpZGVzIil9c2V0IHNpZGVzKGMpe2lmKGM9T2JqZWN0KG4udG9BcnJheSkoYywhMCksYyE9bnVsbCYmIUFycmF5LmlzQXJyYXkoYykmJihjPVtjLGNdKSx0aGlzW2ddKCJzaWRlcyIsYykpe2NvbnN0IHY9byh0aGlzKTtzdXBlci5wb2ludHM9dn19Z2V0IGFuZ2xlKCl7cmV0dXJuIHRoaXNbdV0oImFuZ2xlIil9c2V0IGFuZ2xlKGMpe2lmKGM9T2JqZWN0KG4udG9OdW1iZXIpKGMpLHRoaXNbZ10oImFuZ2xlIixjKSl7Y29uc3Qgdj1vKHRoaXMpO3N1cGVyLnBvaW50cz12fX19fSxmdW5jdGlvbihoLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiB1fSk7dmFyIHI9dCgyMzIpLG49dCgyMTMpLGQ9dCgyMzcpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBnKG8sZix4KXtyZXR1cm4gZiBpbiBvP09iamVjdC5kZWZpbmVQcm9wZXJ0eShvLGYse3ZhbHVlOngsZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTpvW2ZdPXgsb31jbGFzcyB1IGV4dGVuZHMgci5kZWZhdWx0e2dldCBpc1Zpc2libGUoKXtjb25zdHtzaWRlczpmfT10aGlzLmF0dHJpYnV0ZXM7cmV0dXJuIGZbMF0+MCYmZlsxXT4wJiZzdXBlci5pc1Zpc2libGV9fWcodSwiQXR0ciIsZC5kZWZhdWx0KSxuLmRlZmF1bHQucmVnaXN0ZXJOb2RlKHUsInBhcmFsbGVsIil9LGZ1bmN0aW9uKGgsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIGZ9KTt2YXIgcj10KDIzMyksbj10KDcyKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3QgZD1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGVEZWZhdWx0IiksZz1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGUiKSx1PVN5bWJvbC5mb3IoInNwcml0ZWpzX2dldEF0dHJpYnV0ZSIpO2Z1bmN0aW9uIG8oeCl7Y29uc3RbYyx2XT14LnNpZGVzO2xldCBwPXguYW5nbGUlMzYwO3A8MCYmKHArPTM2MCkscD1NYXRoLlBJKnAvMTgwO2NvbnN0IGI9dipNYXRoLmNvcyhwKSxFPXYqTWF0aC5zaW4ocCk7cmV0dXJuWzAsMCxjLDAsYitjLEUsYixFXX1jbGFzcyBmIGV4dGVuZHMgci5kZWZhdWx0e2NvbnN0cnVjdG9yKGMpe3N1cGVyKGMpLHRoaXNbZF0oe3NpZGVzOlswLDBdLGFuZ2xlOjkwLGNsb3NlVHlwZToibm9ybWFsIn0pfWdldCBwb2ludHMoKXtyZXR1cm4gc3VwZXIucG9pbnRzfXNldCBwb2ludHMoYyl7fWdldCBzaWRlcygpe3JldHVybiB0aGlzW3VdKCJzaWRlcyIpfXNldCBzaWRlcyhjKXtpZihjPU9iamVjdChuLnRvQXJyYXkpKGMsITApLGMhPW51bGwmJiFBcnJheS5pc0FycmF5KGMpJiYoYz1bYyxjXSksdGhpc1tnXSgic2lkZXMiLGMpKXtjb25zdCB2PW8odGhpcyk7c3VwZXIucG9pbnRzPXZ9fWdldCBhbmdsZSgpe3JldHVybiB0aGlzW3VdKCJhbmdsZSIpfXNldCBhbmdsZShjKXtpZihjPU9iamVjdChuLnRvTnVtYmVyKShjKSx0aGlzW2ddKCJhbmdsZSIsYykpe2NvbnN0IHY9byh0aGlzKTtzdXBlci5wb2ludHM9dn19fX0sZnVuY3Rpb24oaCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gdX0pO3ZhciByPXQoMjMyKSxuPXQoMjEzKSxkPXQoMjM5KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gZyhvLGYseCl7cmV0dXJuIGYgaW4gbz9PYmplY3QuZGVmaW5lUHJvcGVydHkobyxmLHt2YWx1ZTp4LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6b1tmXT14LG99Y2xhc3MgdSBleHRlbmRzIHIuZGVmYXVsdHt9Zyh1LCJBdHRyIixkLmRlZmF1bHQpLG4uZGVmYXVsdC5yZWdpc3Rlck5vZGUodSwicmVndWxhciIpfSxmdW5jdGlvbihoLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBmfSk7dmFyIHI9dCgyMzMpLG49dCg3Mik7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IGQ9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlRGVmYXVsdCIpLGc9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlIiksdT1TeW1ib2wuZm9yKCJzcHJpdGVqc19nZXRBdHRyaWJ1dGUiKTtmdW5jdGlvbiBvKHgpe2NvbnN0e2VkZ2VzOmMscmFkaXVzOnYsb2Zmc2V0QW5nbGU6cH09eCxiPU1hdGguUEkqcC8xODAtLjUqTWF0aC5QSTtpZihjPDN8fHY8PTApcmV0dXJuW107Y29uc3QgRT1bXTtmb3IobGV0IHk9MDt5PGM7eSsrKXtjb25zdCBNPXkqMipNYXRoLlBJL2MrYixpPXYqTWF0aC5jb3MoTSksYT12Kk1hdGguc2luKE0pO0UucHVzaChpLGEpfXJldHVybiBFfWNsYXNzIGYgZXh0ZW5kcyByLmRlZmF1bHR7Y29uc3RydWN0b3IoYyl7c3VwZXIoYyksdGhpc1tkXSh7ZWRnZXM6MyxyYWRpdXM6MCxvZmZzZXRBbmdsZTowLGNsb3NlVHlwZToibm9ybWFsIn0pfWdldCBwb2ludHMoKXtyZXR1cm4gc3VwZXIucG9pbnRzfXNldCBwb2ludHMoYyl7fWdldCBlZGdlcygpe3JldHVybiB0aGlzW3VdKCJlZGdlcyIpfXNldCBlZGdlcyhjKXtpZihjPU9iamVjdChuLnRvTnVtYmVyKShjKSx0aGlzW2ddKCJlZGdlcyIsYykpe2NvbnN0IHY9byh0aGlzKTtzdXBlci5wb2ludHM9dn19Z2V0IHJhZGl1cygpe3JldHVybiB0aGlzW3VdKCJyYWRpdXMiKX1zZXQgcmFkaXVzKGMpe2lmKGM9T2JqZWN0KG4udG9OdW1iZXIpKGMpLHRoaXNbZ10oInJhZGl1cyIsYykpe2NvbnN0IHY9byh0aGlzKTtzdXBlci5wb2ludHM9dn19Z2V0IG9mZnNldEFuZ2xlKCl7cmV0dXJuIHRoaXNbdV0oIm9mZnNldEFuZ2xlIil9c2V0IG9mZnNldEFuZ2xlKGMpe2lmKGM9T2JqZWN0KG4udG9OdW1iZXIpKGMpLHRoaXNbZ10oIm9mZnNldEFuZ2xlIixjKSl7Y29uc3Qgdj1vKHRoaXMpO3N1cGVyLnBvaW50cz12fX19fSxmdW5jdGlvbihoLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiB1fSk7dmFyIHI9dCgyMzIpLG49dCgyMTMpLGQ9dCgyNDEpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBnKG8sZix4KXtyZXR1cm4gZiBpbiBvP09iamVjdC5kZWZpbmVQcm9wZXJ0eShvLGYse3ZhbHVlOngsZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTpvW2ZdPXgsb31jbGFzcyB1IGV4dGVuZHMgci5kZWZhdWx0e31nKHUsIkF0dHIiLGQuZGVmYXVsdCksbi5kZWZhdWx0LnJlZ2lzdGVyTm9kZSh1LCJzdGFyIil9LGZ1bmN0aW9uKGgsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIGZ9KTt2YXIgcj10KDIzMyksbj10KDcyKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3QgZD1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGVEZWZhdWx0IiksZz1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGUiKSx1PVN5bWJvbC5mb3IoInNwcml0ZWpzX2dldEF0dHJpYnV0ZSIpO2Z1bmN0aW9uIG8oeCl7Y29uc3R7YW5nbGVzOmMsaW5uZXJSYWRpdXM6dixvdXRlclJhZGl1czpwLG9mZnNldEFuZ2xlOmJ9PXgsRT1NYXRoLlBJKmIvMTgwLS41Kk1hdGguUEk7aWYoYzwzfHx2PD0wfHxwPD0wKXJldHVybltdO2NvbnN0IHk9W107Zm9yKGxldCBNPTA7TTxjKjI7TSsrKXtjb25zdCBpPU0qTWF0aC5QSS9jK0UsYT1NJTI/djpwLHM9YSpNYXRoLmNvcyhpKSxsPWEqTWF0aC5zaW4oaSk7eS5wdXNoKHMsbCl9cmV0dXJuIHl9Y2xhc3MgZiBleHRlbmRzIHIuZGVmYXVsdHtjb25zdHJ1Y3RvcihjKXtzdXBlcihjKSx0aGlzW2RdKHthbmdsZXM6NSxpbm5lclJhZGl1czowLG91dGVyUmFkaXVzOjAsb2Zmc2V0QW5nbGU6MCxjbG9zZVR5cGU6Im5vcm1hbCJ9KX1nZXQgcG9pbnRzKCl7cmV0dXJuIHN1cGVyLnBvaW50c31zZXQgcG9pbnRzKGMpe31nZXQgYW5nbGVzKCl7cmV0dXJuIHRoaXNbdV0oImFuZ2xlcyIpfXNldCBhbmdsZXMoYyl7aWYoYz1PYmplY3Qobi50b051bWJlcikoYyksdGhpc1tnXSgiYW5nbGVzIixjKSl7Y29uc3Qgdj1vKHRoaXMpO3N1cGVyLnBvaW50cz12fX1nZXQgaW5uZXJSYWRpdXMoKXtyZXR1cm4gdGhpc1t1XSgiaW5uZXJSYWRpdXMiKX1zZXQgaW5uZXJSYWRpdXMoYyl7aWYoYz1PYmplY3Qobi50b051bWJlcikoYyksdGhpc1tnXSgiaW5uZXJSYWRpdXMiLGMpKXtjb25zdCB2PW8odGhpcyk7c3VwZXIucG9pbnRzPXZ9fWdldCBvdXRlclJhZGl1cygpe3JldHVybiB0aGlzW3VdKCJvdXRlclJhZGl1cyIpfXNldCBvdXRlclJhZGl1cyhjKXtpZihjPU9iamVjdChuLnRvTnVtYmVyKShjKSx0aGlzW2ddKCJvdXRlclJhZGl1cyIsYykpe2NvbnN0IHY9byh0aGlzKTtzdXBlci5wb2ludHM9dn19Z2V0IHJhZGl1cygpe3JldHVyblt0aGlzLmlubmVyUmFkaXVzLHRoaXMub3V0ZXJSYWRpdXNdfXNldCByYWRpdXMoYyl7Yz1PYmplY3Qobi50b0FycmF5KShjLCEwKSxBcnJheS5pc0FycmF5KGMpfHwoYz1bYyxjXSksdGhpcy5pbm5lclJhZGl1cz1jWzBdLHRoaXMub3V0ZXJSYWRpdXM9Y1sxXX1nZXQgb2Zmc2V0QW5nbGUoKXtyZXR1cm4gdGhpc1t1XSgib2Zmc2V0QW5nbGUiKX1zZXQgb2Zmc2V0QW5nbGUoYyl7aWYoYz1PYmplY3Qobi50b051bWJlcikoYyksdGhpc1tnXSgib2Zmc2V0QW5nbGUiLGMpKXtjb25zdCB2PW8odGhpcyk7c3VwZXIucG9pbnRzPXZ9fX19LGZ1bmN0aW9uKGgsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIHV9KTt2YXIgcj10KDIyNiksbj10KDIxMyksZD10KDI0Myk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIGcobyxmLHgpe3JldHVybiBmIGluIG8/T2JqZWN0LmRlZmluZVByb3BlcnR5KG8sZix7dmFsdWU6eCxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOm9bZl09eCxvfWNsYXNzIHUgZXh0ZW5kcyByLmRlZmF1bHR7Z2V0IGlzVmlzaWJsZSgpe2NvbnN0e3JhZGl1c1g6ZixyYWRpdXNZOngsc3RhcnRBbmdsZTpjLGVuZEFuZ2xlOnZ9PXRoaXMuYXR0cmlidXRlcztyZXR1cm4gZj4wJiZ4PjAmJmMhPT12JiZzdXBlci5pc1Zpc2libGV9fWcodSwiQXR0ciIsZC5kZWZhdWx0KSxuLmRlZmF1bHQucmVnaXN0ZXJOb2RlKHUsImVsbGlwc2UiKX0sZnVuY3Rpb24oaCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gY30pO3ZhciByPXQoMTIpLG49dCgyMjgpLGQ9dCg3Mik7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IGc9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlRGVmYXVsdCIpLHU9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlIiksbz1TeW1ib2wuZm9yKCJzcHJpdGVqc19nZXRBdHRyaWJ1dGUiKSxmPVN5bWJvbC5mb3IoInNwcml0ZWpzX2RlY2xhcmVBbGlhcyIpO2Z1bmN0aW9uIHgodil7Y29uc3R7cmFkaXVzWDpwLHJhZGl1c1k6YixzdGFydEFuZ2xlOkUsZW5kQW5nbGU6eSxkaXJlY3Rpb246TSxjbG9zZVR5cGU6aX09dixhPU09PT0iYW5pdGNsb2Nrd2lzZSIscz1uZXcgci5GaWd1cmUyRDtyZXR1cm4gaT09PSJzZWN0b3IiJiZzLm1vdmVUbygwLDApLHMuZWxsaXBzZSgwLDAscCxiLDAsTWF0aC5QSSpFLzE4MCxNYXRoLlBJKnkvMTgwLGEpLGkhPT0ibm9uZSImJnMuY2xvc2VQYXRoKCkscy5wYXRoLnJlZHVjZSgoQSxSKT0+QStSLmpvaW4oIiAiKSwiIil9Y2xhc3MgYyBleHRlbmRzIG4uZGVmYXVsdHtjb25zdHJ1Y3RvcihwKXtzdXBlcihwKSx0aGlzW2ddKHtyYWRpdXNYOjAscmFkaXVzWTowLHN0YXJ0QW5nbGU6MCxlbmRBbmdsZTozNjAsZGlyZWN0aW9uOiJjbG9ja3dpc2UiLGNsb3NlVHlwZToibm9uZSJ9KSx0aGlzW2ZdKCJyYWRpdXMiLCJhbmdsZSIpfWdldCBkKCl7cmV0dXJuIHRoaXNbb10oImQiKX1zZXQgZChwKXt9Z2V0IHJhZGl1c1goKXtyZXR1cm4gdGhpc1tvXSgicmFkaXVzWCIpfXNldCByYWRpdXNYKHApe2lmKHA9T2JqZWN0KGQudG9OdW1iZXIpKHApLHRoaXNbdV0oInJhZGl1c1giLHApKXtjb25zdCBiPXgodGhpcyk7dGhpc1t1XSgiZCIsYil9fWdldCByYWRpdXNZKCl7cmV0dXJuIHRoaXNbb10oInJhZGl1c1kiKX1zZXQgcmFkaXVzWShwKXtpZihwPU9iamVjdChkLnRvTnVtYmVyKShwKSx0aGlzW3VdKCJyYWRpdXNZIixwKSl7Y29uc3QgYj14KHRoaXMpO3RoaXNbdV0oImQiLGIpfX1nZXQgcmFkaXVzKCl7cmV0dXJuW3RoaXMucmFkaXVzWCx0aGlzLnJhZGl1c1ldfXNldCByYWRpdXMocCl7cD1PYmplY3QoZC50b0FycmF5KShwLCEwKSxBcnJheS5pc0FycmF5KHApfHwocD1bcCxwXSksdGhpcy5yYWRpdXNYPXBbMF0sdGhpcy5yYWRpdXNZPXBbMV19Z2V0IGFuZ2xlKCl7cmV0dXJuW3RoaXMuc3RhcnRBbmdsZSx0aGlzLmVuZEFuZ2xlXX1zZXQgYW5nbGUocCl7cD1PYmplY3QoZC50b0FycmF5KShwKSxBcnJheS5pc0FycmF5KHApfHwocD1bcCxwXSksdGhpcy5zdGFydEFuZ2xlPXBbMF0sdGhpcy5lbmRBbmdsZT1wWzFdfWdldCBkaXJlY3Rpb24oKXtyZXR1cm4gdGhpc1tvXSgiZGlyZWN0aW9uIil9c2V0IGRpcmVjdGlvbihwKXtpZihwIT1udWxsJiZwIT09ImNsb2Nrd2lzZSImJnAhPT0iYW50aWNsb2Nrd2lzZSIpdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCBkaXJlY3Rpb24gdHlwZS4iKTt0aGlzW3VdKCJkaXJlY3Rpb24iLHApfWdldCBzdGFydEFuZ2xlKCl7cmV0dXJuIHRoaXNbb10oInN0YXJ0QW5nbGUiKX1zZXQgc3RhcnRBbmdsZShwKXtpZihwPU9iamVjdChkLnRvTnVtYmVyKShwKSx0aGlzW3VdKCJzdGFydEFuZ2xlIixwKSl7Y29uc3QgYj14KHRoaXMpO3RoaXNbdV0oImQiLGIpfX1nZXQgZW5kQW5nbGUoKXtyZXR1cm4gdGhpc1tvXSgiZW5kQW5nbGUiKX1zZXQgZW5kQW5nbGUocCl7aWYocD1PYmplY3QoZC50b051bWJlcikocCksdGhpc1t1XSgiZW5kQW5nbGUiLHApKXtjb25zdCBiPXgodGhpcyk7dGhpc1t1XSgiZCIsYil9fWdldCBjbG9zZVR5cGUoKXtyZXR1cm4gdGhpc1tvXSgiY2xvc2VUeXBlIil9c2V0IGNsb3NlVHlwZShwKXtpZihwIT1udWxsJiZwIT09Im5vbmUiJiZwIT09InNlY3RvciImJnAhPT0ibm9ybWFsIil0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIGNsb3NlVHlwZSB0eXBlLiIpO2lmKHRoaXNbdV0oImNsb3NlVHlwZSIscCkpe2NvbnN0IGI9eCh0aGlzKTt0aGlzW3VdKCJkIixiKX19fX0sZnVuY3Rpb24oaCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gdX0pO3ZhciByPXQoMjQyKSxuPXQoMjEzKSxkPXQoMjQ1KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gZyhvLGYseCl7cmV0dXJuIGYgaW4gbz9PYmplY3QuZGVmaW5lUHJvcGVydHkobyxmLHt2YWx1ZTp4LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6b1tmXT14LG99Y2xhc3MgdSBleHRlbmRzIHIuZGVmYXVsdHt9Zyh1LCJBdHRyIixkLmRlZmF1bHQpLG4uZGVmYXVsdC5yZWdpc3Rlck5vZGUodSwiYXJjIil9LGZ1bmN0aW9uKGgsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIGR9KTt2YXIgcj10KDI0Myksbj10KDcyKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y2xhc3MgZCBleHRlbmRzIHIuZGVmYXVsdHtnZXQgcmFkaXVzKCl7cmV0dXJuIHN1cGVyLnJhZGl1c1h9c2V0IHJhZGl1cyh1KXt1PU9iamVjdChuLnRvTnVtYmVyKSh1KSxzdXBlci5yYWRpdXNYPXUsc3VwZXIucmFkaXVzWT11fX19LGZ1bmN0aW9uKGgsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIHV9KTt2YXIgcj10KDIyNiksbj10KDIxMyksZD10KDI0Nyk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIGcobyxmLHgpe3JldHVybiBmIGluIG8/T2JqZWN0LmRlZmluZVByb3BlcnR5KG8sZix7dmFsdWU6eCxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOm9bZl09eCxvfWNsYXNzIHUgZXh0ZW5kcyByLmRlZmF1bHR7Z2V0IGlzVmlzaWJsZSgpe2NvbnN0e2lubmVyUmFkaXVzOmYsb3V0ZXJSYWRpdXM6eCxzdGFydEFuZ2xlOmMsZW5kQW5nbGU6dn09dGhpcy5hdHRyaWJ1dGVzO3JldHVybihmPjB8fHg+MCkmJmMhPT12JiZzdXBlci5pc1Zpc2libGV9fWcodSwiQXR0ciIsZC5kZWZhdWx0KSxuLmRlZmF1bHQucmVnaXN0ZXJOb2RlKHUsInJpbmciKX0sZnVuY3Rpb24oaCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gY30pO3ZhciByPXQoMTIpLG49dCgyMjgpLGQ9dCg3Mik7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IGc9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlRGVmYXVsdCIpLHU9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlIiksbz1TeW1ib2wuZm9yKCJzcHJpdGVqc19nZXRBdHRyaWJ1dGUiKSxmPVN5bWJvbC5mb3IoInNwcml0ZWpzX2RlY2xhcmVBbGlhcyIpO2Z1bmN0aW9uIHgodil7bGV0e2lubmVyUmFkaXVzOnAsb3V0ZXJSYWRpdXM6YixzdGFydEFuZ2xlOkUsZW5kQW5nbGU6eX09djtjb25zdCBNPW5ldyByLkZpZ3VyZTJEO2lmKEU9TWF0aC5QSSpFLzE4MCx5PU1hdGguUEkqeS8xODAscD5iJiYoW3AsYl09W2IscF0pLHA8PTAmJk0ubW92ZVRvKDAsMCksTS5hcmMoMCwwLGIsRSx5LCExKSxwPjApe2NvbnN0IHM9TWF0aC5QSSoyO3k8RSYmKHk9RStzKyh5LUUpJXMpLHktRT49cyYmKHk9RStzLTFlLTYpLE0uYXJjKDAsMCxwLHksRSwhMCl9cmV0dXJuIE0uY2xvc2VQYXRoKCksTS5wYXRoLnJlZHVjZSgocyxsKT0+cytsLmpvaW4oIiAiKSwiIil9Y2xhc3MgYyBleHRlbmRzIG4uZGVmYXVsdHtjb25zdHJ1Y3RvcihwKXtzdXBlcihwKSx0aGlzW2ddKHtpbm5lclJhZGl1czowLG91dGVyUmFkaXVzOjAsc3RhcnRBbmdsZTowLGVuZEFuZ2xlOjM2MH0pLHRoaXNbZl0oInJhZGl1cyIsImFuZ2xlIil9Z2V0IGQoKXtyZXR1cm4gdGhpc1tvXSgiZCIpfXNldCBkKHApe31nZXQgaW5uZXJSYWRpdXMoKXtyZXR1cm4gdGhpc1tvXSgiaW5uZXJSYWRpdXMiKX1zZXQgaW5uZXJSYWRpdXMocCl7aWYocD1PYmplY3QoZC50b051bWJlcikocCksdGhpc1t1XSgiaW5uZXJSYWRpdXMiLHApKXtjb25zdCBiPXgodGhpcyk7dGhpc1t1XSgiZCIsYil9fWdldCBvdXRlclJhZGl1cygpe3JldHVybiB0aGlzW29dKCJvdXRlclJhZGl1cyIpfXNldCBvdXRlclJhZGl1cyhwKXtpZihwPU9iamVjdChkLnRvTnVtYmVyKShwKSx0aGlzW3VdKCJvdXRlclJhZGl1cyIscCkpe2NvbnN0IGI9eCh0aGlzKTt0aGlzW3VdKCJkIixiKX19Z2V0IHJhZGl1cygpe3JldHVyblt0aGlzLmlubmVyUmFkaXVzLHRoaXMub3V0ZXJSYWRpdXNdfXNldCByYWRpdXMocCl7cD1PYmplY3QoZC50b0FycmF5KShwLCEwKSxBcnJheS5pc0FycmF5KHApfHwocD1bcCxwXSksdGhpcy5pbm5lclJhZGl1cz1wWzBdLHRoaXMub3V0ZXJSYWRpdXM9cFsxXX1nZXQgc3RhcnRBbmdsZSgpe3JldHVybiB0aGlzW29dKCJzdGFydEFuZ2xlIil9c2V0IHN0YXJ0QW5nbGUocCl7aWYocD1PYmplY3QoZC50b051bWJlcikocCksdGhpc1t1XSgic3RhcnRBbmdsZSIscCkpe2NvbnN0IGI9eCh0aGlzKTt0aGlzW3VdKCJkIixiKX19Z2V0IGVuZEFuZ2xlKCl7cmV0dXJuIHRoaXNbb10oImVuZEFuZ2xlIil9c2V0IGVuZEFuZ2xlKHApe2lmKHA9T2JqZWN0KGQudG9OdW1iZXIpKHApLHRoaXNbdV0oImVuZEFuZ2xlIixwKSl7Y29uc3QgYj14KHRoaXMpO3RoaXNbdV0oImQiLGIpfX1nZXQgYW5nbGUoKXtyZXR1cm5bdGhpcy5zdGFydEFuZ2xlLHRoaXMuZW5kQW5nbGVdfXNldCBhbmdsZShwKXtwPU9iamVjdChkLnRvQXJyYXkpKHApLEFycmF5LmlzQXJyYXkocCl8fChwPVtwLHBdKSx0aGlzLnN0YXJ0QW5nbGU9cFswXSx0aGlzLmVuZEFuZ2xlPXBbMV19fX0sZnVuY3Rpb24oaCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gYn0pO3ZhciByPXQoMTIpLG49dCgyMTgpLGQ9dCgyMTkpLGc9dCgyNDkpLHU9dCgyMTMpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBvKEUseSxNKXtyZXR1cm4geSBpbiBFP09iamVjdC5kZWZpbmVQcm9wZXJ0eShFLHkse3ZhbHVlOk0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTpFW3ldPU0sRX1jb25zdCBmPVN5bWJvbCgidGV4dEltYWdlIikseD1TeW1ib2woInRleHRJbWFnZVRhc2siKSxjPVN5bWJvbCgidGV4dHVyZUNvbnRleHQiKSx2PVN5bWJvbCgidXBkYXRlVGV4dHVyZVJlY3QiKSxwPVN5bWJvbCgidGV4dENhbnZhcyIpO2NsYXNzIGIgZXh0ZW5kcyBkLmRlZmF1bHR7Y29uc3RydWN0b3IoeT17fSl7dHlwZW9mIHk9PSJzdHJpbmciJiYoeT17dGV4dDp5fSksc3VwZXIoeSl9Z2V0IGNvbnRlbnRTaXplKCl7bGV0W3ksTV09c3VwZXIuY29udGVudFNpemU7Y29uc3R7d2lkdGg6aSxoZWlnaHQ6YX09dGhpcy5hdHRyaWJ1dGVzO2lmKGk9PW51bGx8fGE9PW51bGwpe2NvbnN0IHM9dGhpc1tmXTtzJiYoaT09bnVsbCYmKHk9cy5yZWN0WzJdKSxhPT1udWxsJiYoTT1zLnJlY3RbM10pKX1yZXR1cm5beSxNXX1nZXQgdGV4dCgpe3JldHVybiB0aGlzLmF0dHJpYnV0ZXMudGV4dH1zZXQgdGV4dCh5KXt0aGlzLmF0dHJpYnV0ZXMudGV4dD15fWdldCB0ZXh0Q29udGVudCgpe3JldHVybiB0aGlzLmF0dHJpYnV0ZXMudGV4dH1zZXQgdGV4dENvbnRlbnQoeSl7dGhpcy5hdHRyaWJ1dGVzLnRleHQ9eX1nZXQgdGV4dEltYWdlKCl7cmV0dXJuIHRoaXNbZl18fHt9fWdldCB0ZXh0SW1hZ2VSZWFkeSgpe3JldHVybiB0aGlzW3hdfHxQcm9taXNlLnJlc29sdmUoKX1kcmF3KHkpe3N1cGVyLmRyYXcoeSk7Y29uc3QgTT10aGlzLm1lc2g7aWYoTSl7Y29uc3QgaT10aGlzW2ZdO2lmKGkpe2xldCBhPU0udGV4dHVyZTtpZighYXx8dGhpc1tjXSYmdGhpc1tjXSE9PXRoaXMucmVuZGVyZXJ8fGkubmVlZHNVcGRhdGU/KGkubmVlZHNVcGRhdGU9ITEsT2JqZWN0KG4uZGVsZXRlVGV4dHVyZSkoaS5pbWFnZSx0aGlzLnJlbmRlcmVyKSxhPU9iamVjdChuLmNyZWF0ZVRleHR1cmUpKGkuaW1hZ2UsdGhpcy5yZW5kZXJlciksdGhpc1t2XT0hMCk6YT1NLnVuaWZvcm1zLnVfdGV4U2FtcGxlcix0aGlzW3ZdKXtjb25zdFtzLGxdPWkucmVjdC5zbGljZSgyKSxbTyxBXT10aGlzLmNvbnRlbnRTaXplLFI9dGhpcy5hdHRyaWJ1dGVzLnRleHRBbGlnbixJPXRoaXMuYXR0cmlidXRlcy52ZXJ0aWNhbEFsaWduO2xldCBQPTA7Uj09PSJjZW50ZXIiP1A9KE8tcykvMjooUj09PSJyaWdodCJ8fFI9PT0iZW5kIikmJihQPU8tcyk7Y29uc3QgTD10aGlzLmF0dHJpYnV0ZXMuZm9udFNpemUsRD10aGlzLmF0dHJpYnV0ZXMubGluZUhlaWdodDtsZXQgQz0wO0k9PT0idG9wIj9DPShMLUQpLzI6ST09PSJib3R0b20iJiYoQz0oRC1MKS8yKTtjb25zdHtwYWRkaW5nTGVmdDpTLHBhZGRpbmdUb3A6Qn09dGhpcy5hdHRyaWJ1dGVzLHtib3JkZXJXaWR0aDp3fT10aGlzLmF0dHJpYnV0ZXM7UCs9Uyt3LEMrPUIrdztjb25zdHthbmNob3JYOkgsYW5jaG9yWTpKfT10aGlzLmF0dHJpYnV0ZXM7UC09dGhpcy5vZmZzZXRTaXplWzBdKkgsQy09dGhpcy5vZmZzZXRTaXplWzFdKkosTS5zZXRUZXh0dXJlKGEse3JlY3Q6W1AsQyxzLGxdfSksdGhpc1t2XT0hMSx0aGlzW2NdPXRoaXMucmVuZGVyZXJ9fX1yZXR1cm4geX1vblByb3BlcnR5Q2hhbmdlKHksTSxpKXt5PT09InRleHQifHx5PT09ImZvbnRTaXplInx8eT09PSJmb250RmFtaWx5Inx8eT09PSJmb250U3R5bGUifHx5PT09ImZvbnRWYXJpYW50Inx8eT09PSJmb250V2VpZ2h0Inx8eT09PSJmb250U3RyZXRjaCJ8fHk9PT0ibGluZUhlaWdodCJ8fHk9PT0ic3Ryb2tlQ29sb3IifHx5PT09ImZpbGxDb2xvciJ8fHk9PT0ic3Ryb2tlV2lkdGgiP3RoaXMudXBkYXRlVGV4dCgpOigoeT09PSJ0ZXh0QWxpZ24ifHx5PT09InZlcnRpY2FsQWxpZ24iKSYmKHRoaXNbdl09ITApLHN1cGVyLm9uUHJvcGVydHlDaGFuZ2UoeSxNLGkpKX11cGRhdGVDb250b3Vycygpe3N1cGVyLnVwZGF0ZUNvbnRvdXJzKCksdGhpc1t2XT0hMH11cGRhdGVUZXh0KCl7dGhpc1t4XXx8KHRoaXNbeF09UHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKT0+e3RoaXNbeF09bnVsbDtjb25zdHt0ZXh0OnksZm9udDpNLGZpbGxDb2xvcjppLHN0cm9rZUNvbG9yOmEsc3Ryb2tlV2lkdGg6c309dGhpcy5hdHRyaWJ1dGVzLGw9dGhpcy5sYXllcj90aGlzLmxheWVyLmRpc3BsYXlSYXRpbzoxO3JldHVybiB0aGlzW3BdPXRoaXNbcF18fHIuRU5WLmNyZWF0ZUNhbnZhcygxLDEpLHRoaXNbZl09ci5FTlYuY3JlYXRlVGV4dCh5LHtmb250Ok0sZmlsbENvbG9yOmksc3Ryb2tlQ29sb3I6YSxzdHJva2VXaWR0aDpzLHBhcnNlRm9udDpyLnBhcnNlRm9udCxyYXRpbzpsLHRleHRDYW52YXM6dGhpc1twXX0pLHRoaXNbZl0ubmVlZHNVcGRhdGU9ITAsdGhpcy51cGRhdGVDb250b3VycygpLHRoaXMuZm9yY2VVcGRhdGUoKSx0aGlzW2ZdfSkpfX1vKGIsIkF0dHIiLGcuZGVmYXVsdCksdS5kZWZhdWx0LnJlZ2lzdGVyTm9kZShiLCJsYWJlbCIpfSxmdW5jdGlvbihoLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBjfSk7dmFyIHI9dCgxMiksbj10KDcyKSxkPXQoMjIxKSxnPXQoMjIwKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3QgdT1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGVEZWZhdWx0Iiksbz1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGUiKSxmPVN5bWJvbC5mb3IoInNwcml0ZWpzX2dldEF0dHJpYnV0ZSIpLHg9U3ltYm9sLmZvcigic3ByaXRlanNfZGVjbGFyZUFsaWFzIik7Y2xhc3MgYyBleHRlbmRzIGcuZGVmYXVsdHtjb25zdHJ1Y3RvcihwKXtzdXBlcihwKSx0aGlzW3VdKHt0ZXh0OiIiLGZvbnRTaXplOjE2LGZvbnRGYW1pbHk6IkhlbHZldGljYSxBcmlhbCxzYW5zLXNlcmlmIixmb250U3R5bGU6Im5vcm1hbCIsZm9udFZhcmlhbnQ6Im5vcm1hbCIsZm9udFdlaWdodDoibm9ybWFsIixmb250U3RyZXRjaDoibm9ybWFsIixsaW5lSGVpZ2h0OiIiLHRleHRBbGlnbjoibGVmdCIsc3Ryb2tlQ29sb3I6dm9pZCAwLHN0cm9rZVdpZHRoOjEsZmlsbENvbG9yOnZvaWQgMCx2ZXJ0aWNhbEFsaWduOiJtaWRkbGUifSksdGhpc1t4XSgiZm9udCIpfWdldCB0ZXh0KCl7cmV0dXJuIHRoaXNbZl0oInRleHQiKXx8IiAifXNldCB0ZXh0KHApe3RoaXNbb10oInRleHQiLHApfWdldCBmb250U2l6ZSgpe3JldHVybiB0aGlzW2ZdKCJmb250U2l6ZSIpfXNldCBmb250U2l6ZShwKXt0aGlzW29dKCJmb250U2l6ZSIsT2JqZWN0KG4udG9OdW1iZXIpKHApKX1nZXQgZm9udEZhbWlseSgpe3JldHVybiB0aGlzW2ZdKCJmb250RmFtaWx5Iil9c2V0IGZvbnRGYW1pbHkocCl7dGhpc1tvXSgiZm9udEZhbWlseSIscCl9Z2V0IGZvbnRTdHlsZSgpe3JldHVybiB0aGlzW2ZdKCJmb250U3R5bGUiKX1zZXQgZm9udFN0eWxlKHApe3RoaXNbb10oImZvbnRTdHlsZSIscCl9Z2V0IGZvbnRWYXJpYW50KCl7cmV0dXJuIHRoaXNbZl0oImZvbnRWYXJpYW50Iil9c2V0IGZvbnRWYXJpYW50KHApe3RoaXNbb10oImZvbnRWYXJpYW50IixwKX1nZXQgZm9udFdlaWdodCgpe3JldHVybiB0aGlzW2ZdKCJmb250V2VpZ2h0Iil9c2V0IGZvbnRXZWlnaHQocCl7dGhpc1tvXSgiZm9udFdlaWdodCIscCl9Z2V0IGZvbnRTdHJldGNoKCl7cmV0dXJuIHRoaXNbZl0oImZvbnRTdHJldGNoIil9c2V0IGZvbnRTdHJldGNoKHApe3RoaXNbb10oImZvbnRTdHJldGNoIixwKX1nZXQgbGluZUhlaWdodCgpe3JldHVybiB0aGlzW2ZdKCJsaW5lSGVpZ2h0Iil8fHRoaXMuZm9udFNpemV9c2V0IGxpbmVIZWlnaHQocCl7dGhpc1tvXSgibGluZUhlaWdodCIsT2JqZWN0KG4udG9OdW1iZXIpKHApKX1nZXQgdGV4dEFsaWduKCl7cmV0dXJuIHRoaXNbZl0oInRleHRBbGlnbiIpfXNldCB0ZXh0QWxpZ24ocCl7dGhpc1tvXSgidGV4dEFsaWduIixwKX1nZXQgc3Ryb2tlQ29sb3IoKXtyZXR1cm4gdGhpc1tmXSgic3Ryb2tlQ29sb3IiKX1zZXQgc3Ryb2tlQ29sb3IocCl7dGhpc1tvXSgic3Ryb2tlQ29sb3IiLE9iamVjdChkLnBhcnNlQ29sb3IpKHApKX1nZXQgc3Ryb2tlV2lkdGgoKXtyZXR1cm4gdGhpc1tmXSgic3Ryb2tlV2lkdGgiKX1zZXQgc3Ryb2tlV2lkdGgocCl7dGhpc1tvXSgic3Ryb2tlV2lkdGgiLE9iamVjdChuLnRvTnVtYmVyKShwKSl9Z2V0IHZlcnRpY2FsQWxpZ24oKXtyZXR1cm4gdGhpc1tmXSgidmVydGljYWxBbGlnbiIpfXNldCB2ZXJ0aWNhbEFsaWduKHApe3RoaXNbb10oInZlcnRpY2FsQWxpZ24iLHApfWdldCBmaWxsQ29sb3IoKXtyZXR1cm4gdGhpc1tmXSgiZmlsbENvbG9yIil9c2V0IGZpbGxDb2xvcihwKXt0aGlzW29dKCJmaWxsQ29sb3IiLE9iamVjdChkLnBhcnNlQ29sb3IpKHApKX1nZXQgZm9udCgpe2NvbnN0e2ZvbnRTdHlsZTpwLGZvbnRWYXJpYW50OmIsZm9udFdlaWdodDpFLGZvbnRTdHJldGNoOnksZm9udFNpemU6TSxsaW5lSGVpZ2h0OmksZm9udEZhbWlseTphfT10aGlzO3JldHVybmAke3B9ICR7Yn0gJHtFfSAke3l9ICR7TX1weC8ke2l9cHggJHthfWB9c2V0IGZvbnQocCl7aWYocD09bnVsbCl0aGlzLmZvbnRTdHlsZT1udWxsLHRoaXMuZm9udFZhcmlhbnQ9bnVsbCx0aGlzLmZvbnRXZWlnaHQ9bnVsbCx0aGlzLmZvbnRTdHJldGNoPW51bGwsdGhpcy5mb250U2l6ZT1udWxsLHRoaXMubGluZUhlaWdodD1udWxsLHRoaXMuZm9udEZhbWlseT1udWxsO2Vsc2V7Y29uc3QgYj1PYmplY3Qoci5wYXJzZUZvbnQpKHApO3RoaXMuZm9udFN0eWxlPWIuc3R5bGUsdGhpcy5mb250VmFyaWFudD1iLnZhcmlhbnQsdGhpcy5mb250V2VpZ2h0PWIud2VpZ2h0LHRoaXMuZm9udFN0cmV0Y2g9Yi5zdHJldGNoLHRoaXMuZm9udFNpemU9T2JqZWN0KG4udG9OdW1iZXIpKGAke2Iuc2l6ZX0ke2IudW5pdH1gKSxiLmxpbmVIZWlnaHQmJih0aGlzLmxpbmVIZWlnaHQ9Yi5weExpbmVIZWlnaHQpLHRoaXMuZm9udEZhbWlseT1iLmZhbWlseX19fX0sZnVuY3Rpb24oaCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gcH0pO3ZhciByPXQoMTIpLG49dCgyMTkpLGQ9dCgyNTEpLGc9dCgyMTMpLHU9dCgyNTIpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBvKGIsRSx5KXtyZXR1cm4gRSBpbiBiP09iamVjdC5kZWZpbmVQcm9wZXJ0eShiLEUse3ZhbHVlOnksZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTpiW0VdPXksYn1jb25zdCBmPVN5bWJvbCgiek9yZGVyIikseD1TeW1ib2woIm9yZGVyZWQiKSxjPVN5bWJvbCgiY2hpbGRyZW4iKSx2PVN5bWJvbCgic2VhbGVkIik7Y2xhc3MgcCBleHRlbmRzIG4uZGVmYXVsdHtjb25zdHJ1Y3RvcihFPXt9KXtzdXBlcihFKSx0aGlzW2NdPVtdLHRoaXNbeF09bnVsbCx0aGlzW2ZdPTB9Z2V0IGNoaWxkTm9kZXMoKXtyZXR1cm4gdGhpc1tjXX1nZXQgY2hpbGRyZW4oKXtyZXR1cm4gdGhpc1tjXX1nZXQgb3JkZXJlZENoaWxkcmVuKCl7cmV0dXJuIHRoaXNbeF18fCh0aGlzW3hdPVsuLi50aGlzW2NdXSx0aGlzW3hdLnNvcnQoKEUseSk9PkUuekluZGV4LXkuekluZGV4fHxFLnpPcmRlci15LnpPcmRlcikpLHRoaXNbeF19YXBwZW5kKC4uLkUpe3JldHVybiBFLm1hcCh5PT50aGlzLmFwcGVuZENoaWxkKHkpKX1hcHBlbmRDaGlsZChFKXtyZXR1cm4gRS5yZW1vdmUoKSx0aGlzW2NdLnB1c2goRSksRS5jb25uZWN0KHRoaXMsdGhpc1tmXSsrKSx0aGlzW3hdJiYodGhpc1t4XS5sZW5ndGgmJkUuekluZGV4PHRoaXNbeF1bdGhpc1t4XS5sZW5ndGgtMV0uekluZGV4P3RoaXMucmVvcmRlcigpOnRoaXNbeF0ucHVzaChFKSksRX1jbG9uZU5vZGUoRT0hMSl7Y29uc3QgeT1zdXBlci5jbG9uZU5vZGUoKTtyZXR1cm4gRSYmdGhpc1tjXS5mb3JFYWNoKE09Pntjb25zdCBpPU0uY2xvbmVOb2RlKEUpO3kuYXBwZW5kQ2hpbGQoaSl9KSx5fWRpc3BhdGNoUG9pbnRlckV2ZW50KEUpe2NvbnN0IHk9dGhpcy5vcmRlcmVkQ2hpbGRyZW47Zm9yKGxldCBNPXkubGVuZ3RoLTE7TT49MDtNLS0paWYoeVtNXS5kaXNwYXRjaFBvaW50ZXJFdmVudChFKSlyZXR1cm4hMDtyZXR1cm4gc3VwZXIuZGlzcGF0Y2hQb2ludGVyRXZlbnQoRSl9ZHJhdyhFPVtdKXtpZih0aGlzLl9fY2FjaGVSZW5kZXJNYXRyaXg9dGhpcy5yZW5kZXJNYXRyaXgsc3VwZXIuZHJhdyhFKSwhdGhpc1t2XSYmdGhpcy5hdHRyaWJ1dGVzLmRpc3BsYXkhPT0ibm9uZSIpe2NvbnN0IHk9dGhpcy5vcmRlcmVkQ2hpbGRyZW47Zm9yKGxldCBNPTA7TTx5Lmxlbmd0aDtNKyspeVtNXS5kcmF3KEUpfXJldHVybiB0aGlzLl9fY2FjaGVSZW5kZXJNYXRyaXg9bnVsbCxFfWdldEVsZW1lbnRCeUlkKEUpe3JldHVybiBPYmplY3QodS5xdWVyeVNlbGVjdG9yKShgIyR7RX1gLHRoaXMpfWdldEVsZW1lbnRzQnlDbGFzc05hbWUoRSl7cmV0dXJuIE9iamVjdCh1LnF1ZXJ5U2VsZWN0b3JBbGwpKGAuJHtFfWAsdGhpcyl9Z2V0RWxlbWVudHNCeU5hbWUoRSl7cmV0dXJuIE9iamVjdCh1LnF1ZXJ5U2VsZWN0b3JBbGwpKGBbbmFtZT0iJHtFfSJdYCx0aGlzKX1nZXRFbGVtZW50c0J5VGFnTmFtZShFKXtyZXR1cm4gT2JqZWN0KHUucXVlcnlTZWxlY3RvckFsbCkoRSx0aGlzKX1pbnNlcnRCZWZvcmUoRSx5KXtpZih5PT1udWxsKXJldHVybiB0aGlzLmFwcGVuZENoaWxkKEUpO0UucmVtb3ZlKCk7Y29uc3QgTT10aGlzW2NdLmluZGV4T2YoeSk7aWYoTTwwKXRocm93IG5ldyBFcnJvcigiSW52YWxpZCByZWZlcmVuY2Ugbm9kZS4iKTtjb25zdCBpPXkuek9yZGVyO2ZvcihsZXQgYT1NO2E8dGhpc1tjXS5sZW5ndGg7YSsrKXtjb25zdCBzPXRoaXNbY11bYV0uek9yZGVyLGw9dGhpc1tjXVthXTtkZWxldGUgbC56T3JkZXIsT2JqZWN0LmRlZmluZVByb3BlcnR5KGwsInpPcmRlciIse3ZhbHVlOnMrMSx3cml0YWJsZTohMSxjb25maWd1cmFibGU6ITB9KX1pZih0aGlzW2NdLnNwbGljZShNLDAsRSksRS5jb25uZWN0KHRoaXMsaSksdGhpc1t4XSlpZihFLnpJbmRleCE9PXkuekluZGV4KXRoaXMucmVvcmRlcigpO2Vsc2V7Y29uc3QgYT10aGlzW3hdLmluZGV4T2YoeSk7dGhpc1t4XS5zcGxpY2UoYSwwLEUpfXJldHVybiBFfXF1ZXJ5U2VsZWN0b3IoRSl7cmV0dXJuIE9iamVjdCh1LnF1ZXJ5U2VsZWN0b3IpKEUsdGhpcyl9cXVlcnlTZWxlY3RvckFsbChFKXtyZXR1cm4gT2JqZWN0KHUucXVlcnlTZWxlY3RvckFsbCkoRSx0aGlzKX1yZXBsYWNlQ2hpbGQoRSx5KXtFLnJlbW92ZSgpO2NvbnN0IE09dGhpc1tjXS5pbmRleE9mKHkpO2lmKE08MCl0aHJvdyBuZXcgRXJyb3IoIkludmFsaWQgcmVmZXJlbmNlIG5vZGUuIik7aWYodGhpc1tjXVtNXT1FLEUuY29ubmVjdCh0aGlzLHkuek9yZGVyKSx0aGlzW3hdKWlmKEUuekluZGV4IT09eS56SW5kZXgpdGhpcy5yZW9yZGVyKCk7ZWxzZXtjb25zdCBpPXRoaXNbeF0uaW5kZXhPZih5KTt0aGlzW3hdW2ldPUV9cmV0dXJuIHkuZGlzY29ubmVjdCh0aGlzKSxFfXJlbW92ZUFsbENoaWxkcmVuKCl7Y29uc3QgRT10aGlzW2NdO2ZvcihsZXQgeT1FLmxlbmd0aC0xO3k+PTA7eS0tKUVbeV0ucmVtb3ZlKCl9cmVtb3ZlQ2hpbGQoRSl7Y29uc3QgeT10aGlzW2NdLmluZGV4T2YoRSk7aWYoeT49MCl7aWYodGhpc1tjXS5zcGxpY2UoeSwxKSx0aGlzW3hdKXtjb25zdCBNPXRoaXNbeF0uaW5kZXhPZihFKTt0aGlzW3hdLnNwbGljZShNLDEpfXJldHVybiBFLmRpc2Nvbm5lY3QodGhpcyksRX1yZXR1cm4gbnVsbH1yZW9yZGVyKCl7dGhpc1t4XT1udWxsfXNlYWwoKXtmdW5jdGlvbiBFKGEscyl7Y29uc3QgbD1bXTtmb3IobGV0IE89MDtPPGEubGVuZ3RoO08rKyl7Y29uc3QgQT1bLi4uYVtPXV07Zm9yKGxldCBSPTE7UjxBLmxlbmd0aDtSKz0yKXtjb25zdCBJPUFbUl0sUD1BW1IrMV07QVtSXT1JKnNbMF0rUCpzWzJdK3NbNF0sQVtSKzFdPUkqc1sxXStQKnNbM10rc1s1XX1sLnB1c2goQSl9cmV0dXJuIGx9Y29uc3QgeT10aGlzLm9yZGVyZWRDaGlsZHJlbixNPW5ldyByLkZpZ3VyZTJELGk9dGhpcy5sb2NhbE1hdHJpeDtmb3IobGV0IGE9MDthPHkubGVuZ3RoO2ErKyl7bGV0IHM9eVthXTtpZihzIGluc3RhbmNlb2YgcCYmKHM9cy5zZWFsKCkpLHMuY2xpZW50Qm94KXtsZXQgbD1zLmNsaWVudEJveC5jb250b3Vycy5wYXRoO2w9RShsLHMubG9jYWxNYXRyaXgpLE0uYWRkUGF0aChsKX1pZihzLnBhdGgpe2xldCBsPXMucGF0aC5jb250b3Vycy5wYXRoO2w9RShsLHMubG9jYWxNYXRyaXgpLE0uYWRkUGF0aChsKX19cmV0dXJuIHRoaXNbdl09ITAsdGhpcy5jbGllbnRCb3g9TSx7Y2xpZW50Qm94Ok0sbG9jYWxNYXRyaXg6aX19c2V0UmVzb2x1dGlvbih7d2lkdGg6RSxoZWlnaHQ6eX0pe3N1cGVyLnNldFJlc29sdXRpb24oe3dpZHRoOkUsaGVpZ2h0Onl9KSx0aGlzW2NdLmZvckVhY2goTT0+e00uc2V0UmVzb2x1dGlvbih7d2lkdGg6RSxoZWlnaHQ6eX0pfSl9dXBkYXRlQ29udG91cnMoKXt0aGlzW3ZdfHxzdXBlci51cGRhdGVDb250b3VycygpfX1vKHAsIkF0dHIiLGQuZGVmYXVsdCksZy5kZWZhdWx0LnJlZ2lzdGVyTm9kZShwLCJncm91cCIpfSxmdW5jdGlvbihoLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBufSk7dmFyIHI9dCgyMjApO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjbGFzcyBuIGV4dGVuZHMgci5kZWZhdWx0e319LGZ1bmN0aW9uKGgsZSx0KXt0LnIoZSksdC5kKGUsInF1ZXJ5U2VsZWN0b3JBbGwiLGZ1bmN0aW9uKCl7cmV0dXJuIHZ9KSx0LmQoZSwicXVlcnlTZWxlY3RvciIsZnVuY3Rpb24oKXtyZXR1cm4gcH0pLHQuZChlLCJpc01hdGNoZWQiLGZ1bmN0aW9uKCl7cmV0dXJuIGJ9KSx0LmQoZSwiY29tcGlsZSIsZnVuY3Rpb24oKXtyZXR1cm4gRX0pO3ZhciByPXQoMjIxKSxuPXQoMjEzKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3QgZD10KDI1Myk7ZnVuY3Rpb24gZyh5KXtyZXR1cm4geS5ub2RlVHlwZT09PTF8fG4uZGVmYXVsdC5pc1Nwcml0ZU5vZGUoeS5ub2RlTmFtZSl9ZnVuY3Rpb24gdSh5KXtyZXR1cm4gQXJyYXkuZnJvbSh5LmNoaWxkTm9kZXN8fFtdKX1mdW5jdGlvbiBvKHkpe3JldHVybiBuLmRlZmF1bHQuaXNTcHJpdGVOb2RlKHkubm9kZU5hbWUpP3kucGFyZW50fHx5LmNhbnZhc3x8eS5jb250YWluZXI6eS5wYXJlbnRFbGVtZW50fWZ1bmN0aW9uIGYoeSl7bGV0IE09eS5sZW5ndGgsaSxhLHM7Zm9yKDstLU0+LTE7KXtmb3IoaT1hPXlbTV0seVtNXT1udWxsLHM9ITA7YTspe2lmKHkuaW5kZXhPZihhKT4tMSl7cz0hMSx5LnNwbGljZShNLDEpO2JyZWFrfWE9byhhKX1zJiYoeVtNXT1pKX1yZXR1cm4geX1jb25zdCB4PXtpc1RhZzpnLGV4aXN0c09uZSh5LE0pe3JldHVybiBNLnNvbWUoaT0+ZyhpKT95KGkpfHx4LmV4aXN0c09uZSh5LHUoaSkpOiExKX0sZ2V0U2libGluZ3MoeSl7Y29uc3QgTT1vKHkpO3JldHVybiBNJiZ1KE0pfSxnZXRDaGlsZHJlbjp1LGdldFBhcmVudDpvLGdldEF0dHJpYnV0ZVZhbHVlKHksTSl7aWYoeS5ub2RlVHlwZT09PTEmJk09PT0iY2xhc3MifHxNPT09ImlkIilyZXR1cm4geVtNXTtpZih0aGlzLmhhc0F0dHJpYih5LE0pKXtsZXQgaT15LmF0dHJpYnV0ZXNbTV07cmV0dXJuIEFycmF5LmlzQXJyYXkoaSkmJihpPWBbJHtpLmpvaW4oKX1dYCksU3RyaW5nKGkpfX0saGFzQXR0cmliKHksTSl7cmV0dXJuIHkuYXR0cmlidXRlc1tNXSE9bnVsbH0scmVtb3ZlU3Vic2V0czpmLGdldE5hbWUoeSl7cmV0dXJuIHkudGFnTmFtZT95LnRhZ05hbWUudG9Mb3dlckNhc2UoKTpudWxsfSxmaW5kT25lOmZ1bmN0aW9uIHkoTSxpKXtsZXQgYT1udWxsO2ZvcihsZXQgcz0wLGw9aS5sZW5ndGg7czxsJiYhYTtzKyspaWYoTShpW3NdKSlhPWlbc107ZWxzZXtjb25zdCBPPXUoaVtzXSk7TyYmTy5sZW5ndGg+MCYmKGE9eShNLE8pKX1yZXR1cm4gYX0sZmluZEFsbDpmdW5jdGlvbiB5KE0saSl7bGV0IGE9W107Zm9yKGxldCBzPTAsbD1pLmxlbmd0aDtzPGw7cysrKXtpZighZyhpW3NdKSljb250aW51ZTtNKGlbc10pJiZhLnB1c2goaVtzXSk7Y29uc3QgTz11KGlbc10pO08mJihhPWEuY29uY2F0KHkoTSxPKSkpfXJldHVybiBhfSxnZXRUZXh0OmZ1bmN0aW9uIHkoTSl7cmV0dXJuIEFycmF5LmlzQXJyYXkoTSk/TS5tYXAoeSkuam9pbigiIik6ZyhNKT95KHUoTSkpOk0ubm9kZVR5cGU9PT0zP00ubm9kZVZhbHVlOm4uZGVmYXVsdC5pc1Nwcml0ZU5vZGUoTS5ub2RlTmFtZSk/TS50ZXh0OiIifX07ZnVuY3Rpb24gYyh5KXtpZih0eXBlb2YgeSE9InN0cmluZyIpcmV0dXJuIHk7bGV0IE09eS5tYXRjaCgvXFsoYmdjb2xvcnxmaWxsQ29sb3J8c3Ryb2tlQ29sb3J8Y29sb3IpXHMqPVxzKlsnIl0/XHcrWyciXT9cXS9nKTtyZXR1cm4gTSYmKE09TS5tYXAoaT0+e2NvbnN0IGE9aS5zbGljZSgxLC0xKS5zcGxpdCgiPSIpLHM9T2JqZWN0KHIucGFyc2VDb2xvcikoYVsxXS5yZXBsYWNlKC9bJyJdL2csIiIpKTtyZXR1cm5baSxgWyR7YVswXX09IiR7c30iXWBdfSksTS5mb3JFYWNoKChbaSxhXSk9Pnt5PXkucmVwbGFjZShpLGEpfSkpLE09eS5tYXRjaCgvXFtcdytccyo9XHMqWyciXVxbLis/XF1bJyJdXF0vZyksTSYmKE09TS5tYXAoaT0+e2NvbnN0IGE9aS5zbGljZSgxLC0xKS5zcGxpdCgiPSIpLHM9YVsxXS5zbGljZSgyLC0yKS5zcGxpdCgvLC9nKS5tYXAobD0+bC50cmltKCkpO3JldHVybltpLGBbJHthWzBdfT0iWyR7c31dIl1gXX0pLE0uZm9yRWFjaCgoW2ksYV0pPT57eT15LnJlcGxhY2UoaSxhKX0pKSx5fWZ1bmN0aW9uIHYoeSxNKXtyZXR1cm4gZC5zZWxlY3RBbGwoYyh5KSxNLHthZGFwdGVyOnh9KX1mdW5jdGlvbiBwKHksTSl7cmV0dXJuIGQuc2VsZWN0T25lKGMoeSksTSx7YWRhcHRlcjp4fSl9ZnVuY3Rpb24gYih5LE0pe3JldHVybiBkLmlzKHksYyhNKSx7YWRhcHRlcjp4fSl9ZnVuY3Rpb24gRSh5KXtyZXR1cm4gZC5jb21waWxlKGMoeSkse2FkYXB0ZXI6eH0pfX0sZnVuY3Rpb24oaCxlLHQpe2guZXhwb3J0cz1FO3ZhciByPXQoMjU0KSxuPXQoMjczKS5mYWxzZUZ1bmMsZD10KDI3NCk7ZnVuY3Rpb24gZyh5KXtyZXR1cm4gZnVuY3Rpb24oaSxhLHMpe3JldHVybiBhPWF8fHt9LGEuYWRhcHRlcj1hLmFkYXB0ZXJ8fHIseShpLGEscyl9fXZhciB1PWcoZCksbz1nKGQuY29tcGlsZVVuc2FmZSk7ZnVuY3Rpb24gZih5KXtyZXR1cm4gZnVuY3Rpb24oaSxhLHMpe3JldHVybiBzPXN8fHt9LHMuYWRhcHRlcj1zLmFkYXB0ZXJ8fHIsdHlwZW9mIGkhPSJmdW5jdGlvbiImJihpPW8oaSxzLGEpKSxpLnNob3VsZFRlc3ROZXh0U2libGluZ3MmJihhPWMocyYmcy5jb250ZXh0fHxhLHMuYWRhcHRlcikpLEFycmF5LmlzQXJyYXkoYSk/YT1zLmFkYXB0ZXIucmVtb3ZlU3Vic2V0cyhhKTphPXMuYWRhcHRlci5nZXRDaGlsZHJlbihhKSx5KGksYSxzKX19ZnVuY3Rpb24geCh5LE0pe3ZhciBpPU0uZ2V0U2libGluZ3MoeSk7aWYoIUFycmF5LmlzQXJyYXkoaSkpcmV0dXJuW107Zm9yKGk9aS5zbGljZSgwKTtpLnNoaWZ0KCkhPT15Oyk7cmV0dXJuIGl9ZnVuY3Rpb24gYyh5LE0pe0FycmF5LmlzQXJyYXkoeSl8fCh5PVt5XSk7Zm9yKHZhciBpPXkuc2xpY2UoMCksYT0wLHM9eS5sZW5ndGg7YTxzO2ErKyl7dmFyIGw9eChpW2FdLE0pO2kucHVzaC5hcHBseShpLGwpfXJldHVybiBpfXZhciB2PWYoZnVuY3Rpb24oTSxpLGEpe3JldHVybiBNPT09bnx8IWl8fGkubGVuZ3RoPT09MD9bXTphLmFkYXB0ZXIuZmluZEFsbChNLGkpfSkscD1mKGZ1bmN0aW9uKE0saSxhKXtyZXR1cm4gTT09PW58fCFpfHxpLmxlbmd0aD09PTA/bnVsbDphLmFkYXB0ZXIuZmluZE9uZShNLGkpfSk7ZnVuY3Rpb24gYih5LE0saSl7cmV0dXJuIGk9aXx8e30saS5hZGFwdGVyPWkuYWRhcHRlcnx8ciwodHlwZW9mIE09PSJmdW5jdGlvbiI/TTp1KE0saSkpKHkpfWZ1bmN0aW9uIEUoeSxNLGkpe3JldHVybiB2KHksTSxpKX1FLmNvbXBpbGU9dSxFLmZpbHRlcnM9ZC5Qc2V1ZG9zLmZpbHRlcnMsRS5wc2V1ZG9zPWQuUHNldWRvcy5wc2V1ZG9zLEUuc2VsZWN0QWxsPXYsRS5zZWxlY3RPbmU9cCxFLmlzPWIsRS5wYXJzZT11LEUuaXRlcmF0ZT12LEUuX2NvbXBpbGVVbnNhZmU9byxFLl9jb21waWxlVG9rZW49ZC5jb21waWxlVG9rZW59LGZ1bmN0aW9uKGgsZSx0KXt2YXIgcj1oLmV4cG9ydHM7W3QoMjU1KSx0KDI2OCksdCgyNjkpLHQoMjcwKSx0KDI3MSksdCgyNzIpXS5mb3JFYWNoKGZ1bmN0aW9uKG4pe09iamVjdC5rZXlzKG4pLmZvckVhY2goZnVuY3Rpb24oZCl7cltkXT1uW2RdLmJpbmQocil9KX0pfSxmdW5jdGlvbihoLGUsdCl7dmFyIHI9dCgyNTYpLG49dCgyNTcpLGQ9ci5pc1RhZztoLmV4cG9ydHM9e2dldElubmVySFRNTDpnLGdldE91dGVySFRNTDpuLGdldFRleHQ6dX07ZnVuY3Rpb24gZyhvLGYpe3JldHVybiBvLmNoaWxkcmVuP28uY2hpbGRyZW4ubWFwKGZ1bmN0aW9uKHgpe3JldHVybiBuKHgsZil9KS5qb2luKCIiKToiIn1mdW5jdGlvbiB1KG8pe3JldHVybiBBcnJheS5pc0FycmF5KG8pP28ubWFwKHUpLmpvaW4oIiIpOmQobyk/by5uYW1lPT09ImJyIj9gCmA6dShvLmNoaWxkcmVuKTpvLnR5cGU9PT1yLkNEQVRBP3Uoby5jaGlsZHJlbik6by50eXBlPT09ci5UZXh0P28uZGF0YToiIn19LGZ1bmN0aW9uKGgsZSl7aC5leHBvcnRzPXtUZXh0OiJ0ZXh0IixEaXJlY3RpdmU6ImRpcmVjdGl2ZSIsQ29tbWVudDoiY29tbWVudCIsU2NyaXB0OiJzY3JpcHQiLFN0eWxlOiJzdHlsZSIsVGFnOiJ0YWciLENEQVRBOiJjZGF0YSIsRG9jdHlwZToiZG9jdHlwZSIsaXNUYWc6ZnVuY3Rpb24odCl7cmV0dXJuIHQudHlwZT09PSJ0YWcifHx0LnR5cGU9PT0ic2NyaXB0Inx8dC50eXBlPT09InN0eWxlIn19fSxmdW5jdGlvbihoLGUsdCl7dmFyIHI9dCgyNTgpLG49dCgyNTkpLGQ9dCgyNjcpO2QuZWxlbWVudE5hbWVzLl9fcHJvdG9fXz1udWxsLGQuYXR0cmlidXRlTmFtZXMuX19wcm90b19fPW51bGw7dmFyIGc9e19fcHJvdG9fXzpudWxsLHN0eWxlOiEwLHNjcmlwdDohMCx4bXA6ITAsaWZyYW1lOiEwLG5vZW1iZWQ6ITAsbm9mcmFtZXM6ITAscGxhaW50ZXh0OiEwLG5vc2NyaXB0OiEwfTtmdW5jdGlvbiB1KHksTSl7aWYoeSl7dmFyIGk9IiIsYTtmb3IodmFyIHMgaW4geSlhPXlbc10saSYmKGkrPSIgIiksTS54bWxNb2RlPT09ImZvcmVpZ24iJiYocz1kLmF0dHJpYnV0ZU5hbWVzW3NdfHxzKSxpKz1zLChhIT09bnVsbCYmYSE9PSIifHxNLnhtbE1vZGUpJiYoaSs9Jz0iJysoTS5kZWNvZGVFbnRpdGllcz9uLmVuY29kZVhNTChhKTphLnJlcGxhY2UoL1wiL2csIiZxdW90OyIpKSsnIicpO3JldHVybiBpfX12YXIgbz17X19wcm90b19fOm51bGwsYXJlYTohMCxiYXNlOiEwLGJhc2Vmb250OiEwLGJyOiEwLGNvbDohMCxjb21tYW5kOiEwLGVtYmVkOiEwLGZyYW1lOiEwLGhyOiEwLGltZzohMCxpbnB1dDohMCxpc2luZGV4OiEwLGtleWdlbjohMCxsaW5rOiEwLG1ldGE6ITAscGFyYW06ITAsc291cmNlOiEwLHRyYWNrOiEwLHdicjohMH0sZj1oLmV4cG9ydHM9ZnVuY3Rpb24oeSxNKXshQXJyYXkuaXNBcnJheSh5KSYmIXkuY2hlZXJpbyYmKHk9W3ldKSxNPU18fHt9O2Zvcih2YXIgaT0iIixhPTA7YTx5Lmxlbmd0aDthKyspe3ZhciBzPXlbYV07cy50eXBlPT09InJvb3QiP2krPWYocy5jaGlsZHJlbixNKTpyLmlzVGFnKHMpP2krPWMocyxNKTpzLnR5cGU9PT1yLkRpcmVjdGl2ZT9pKz12KHMpOnMudHlwZT09PXIuQ29tbWVudD9pKz1FKHMpOnMudHlwZT09PXIuQ0RBVEE/aSs9YihzKTppKz1wKHMsTSl9cmV0dXJuIGl9LHg9WyJtaSIsIm1vIiwibW4iLCJtcyIsIm10ZXh0IiwiYW5ub3RhdGlvbi14bWwiLCJmb3JlaWduT2JqZWN0IiwiZGVzYyIsInRpdGxlIl07ZnVuY3Rpb24gYyh5LE0pe00ueG1sTW9kZT09PSJmb3JlaWduIiYmKHkubmFtZT1kLmVsZW1lbnROYW1lc1t5Lm5hbWVdfHx5Lm5hbWUseS5wYXJlbnQmJnguaW5kZXhPZih5LnBhcmVudC5uYW1lKT49MCYmKE09T2JqZWN0LmFzc2lnbih7fSxNLHt4bWxNb2RlOiExfSkpKSwhTS54bWxNb2RlJiZbInN2ZyIsIm1hdGgiXS5pbmRleE9mKHkubmFtZSk+PTAmJihNPU9iamVjdC5hc3NpZ24oe30sTSx7eG1sTW9kZToiZm9yZWlnbiJ9KSk7dmFyIGk9IjwiK3kubmFtZSxhPXUoeS5hdHRyaWJzLE0pO3JldHVybiBhJiYoaSs9IiAiK2EpLE0ueG1sTW9kZSYmKCF5LmNoaWxkcmVufHx5LmNoaWxkcmVuLmxlbmd0aD09PTApP2krPSIvPiI6KGkrPSI+Iix5LmNoaWxkcmVuJiYoaSs9Zih5LmNoaWxkcmVuLE0pKSwoIW9beS5uYW1lXXx8TS54bWxNb2RlKSYmKGkrPSI8LyIreS5uYW1lKyI+IikpLGl9ZnVuY3Rpb24gdih5KXtyZXR1cm4iPCIreS5kYXRhKyI+In1mdW5jdGlvbiBwKHksTSl7dmFyIGk9eS5kYXRhfHwiIjtyZXR1cm4gTS5kZWNvZGVFbnRpdGllcyYmISh5LnBhcmVudCYmeS5wYXJlbnQubmFtZSBpbiBnKSYmKGk9bi5lbmNvZGVYTUwoaSkpLGl9ZnVuY3Rpb24gYih5KXtyZXR1cm4iPCFbQ0RBVEFbIit5LmNoaWxkcmVuWzBdLmRhdGErIl1dPiJ9ZnVuY3Rpb24gRSh5KXtyZXR1cm4iPCEtLSIreS5kYXRhKyItLT4ifX0sZnVuY3Rpb24oaCxlLHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KTtmdW5jdGlvbiByKG4pe3JldHVybiBuLnR5cGU9PT0idGFnInx8bi50eXBlPT09InNjcmlwdCJ8fG4udHlwZT09PSJzdHlsZSJ9ZS5pc1RhZz1yLGUuVGV4dD0idGV4dCIsZS5EaXJlY3RpdmU9ImRpcmVjdGl2ZSIsZS5Db21tZW50PSJjb21tZW50IixlLlNjcmlwdD0ic2NyaXB0IixlLlN0eWxlPSJzdHlsZSIsZS5UYWc9InRhZyIsZS5DREFUQT0iY2RhdGEiLGUuRG9jdHlwZT0iZG9jdHlwZSJ9LGZ1bmN0aW9uKGgsZSx0KXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksZS5lbmNvZGU9ZS5kZWNvZGVTdHJpY3Q9ZS5kZWNvZGU9dm9pZCAwO3ZhciByPXQoMjYwKSxuPXQoMjY2KTtmdW5jdGlvbiBkKHgsYyl7cmV0dXJuKCFjfHxjPD0wP3IuZGVjb2RlWE1MOnIuZGVjb2RlSFRNTCkoeCl9ZS5kZWNvZGU9ZDtmdW5jdGlvbiBnKHgsYyl7cmV0dXJuKCFjfHxjPD0wP3IuZGVjb2RlWE1MOnIuZGVjb2RlSFRNTFN0cmljdCkoeCl9ZS5kZWNvZGVTdHJpY3Q9ZztmdW5jdGlvbiB1KHgsYyl7cmV0dXJuKCFjfHxjPD0wP24uZW5jb2RlWE1MOm4uZW5jb2RlSFRNTCkoeCl9ZS5lbmNvZGU9dTt2YXIgbz10KDI2Nik7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsImVuY29kZVhNTCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIG8uZW5jb2RlWE1MfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJlbmNvZGVIVE1MIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gby5lbmNvZGVIVE1MfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJlc2NhcGUiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBvLmVzY2FwZX19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiZW5jb2RlSFRNTDQiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBvLmVuY29kZUhUTUx9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsImVuY29kZUhUTUw1Iix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gby5lbmNvZGVIVE1MfX0pO3ZhciBmPXQoMjYwKTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiZGVjb2RlWE1MIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gZi5kZWNvZGVYTUx9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsImRlY29kZUhUTUwiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBmLmRlY29kZUhUTUx9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsImRlY29kZUhUTUxTdHJpY3QiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBmLmRlY29kZUhUTUxTdHJpY3R9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsImRlY29kZUhUTUw0Iix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gZi5kZWNvZGVIVE1MfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJkZWNvZGVIVE1MNSIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGYuZGVjb2RlSFRNTH19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiZGVjb2RlSFRNTDRTdHJpY3QiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBmLmRlY29kZUhUTUxTdHJpY3R9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsImRlY29kZUhUTUw1U3RyaWN0Iix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gZi5kZWNvZGVIVE1MU3RyaWN0fX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJkZWNvZGVYTUxTdHJpY3QiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBmLmRlY29kZVhNTH19KX0sZnVuY3Rpb24oaCxlLHQpe3ZhciByPXRoaXMmJnRoaXMuX19pbXBvcnREZWZhdWx0fHxmdW5jdGlvbihjKXtyZXR1cm4gYyYmYy5fX2VzTW9kdWxlP2M6e2RlZmF1bHQ6Y319O09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxlLmRlY29kZUhUTUw9ZS5kZWNvZGVIVE1MU3RyaWN0PWUuZGVjb2RlWE1MPXZvaWQgMDt2YXIgbj1yKHQoMjYxKSksZD1yKHQoMjYyKSksZz1yKHQoMjYzKSksdT1yKHQoMjY0KSk7ZS5kZWNvZGVYTUw9byhnLmRlZmF1bHQpLGUuZGVjb2RlSFRNTFN0cmljdD1vKG4uZGVmYXVsdCk7ZnVuY3Rpb24gbyhjKXt2YXIgdj1PYmplY3Qua2V5cyhjKS5qb2luKCJ8IikscD14KGMpO3YrPSJ8I1t4WF1bXFxkYS1mQS1GXSt8I1xcZCsiO3ZhciBiPW5ldyBSZWdFeHAoIiYoPzoiK3YrIik7IiwiZyIpO3JldHVybiBmdW5jdGlvbihFKXtyZXR1cm4gU3RyaW5nKEUpLnJlcGxhY2UoYixwKX19dmFyIGY9ZnVuY3Rpb24oYyx2KXtyZXR1cm4gYzx2PzE6LTF9O2UuZGVjb2RlSFRNTD1mdW5jdGlvbigpe2Zvcih2YXIgYz1PYmplY3Qua2V5cyhkLmRlZmF1bHQpLnNvcnQoZiksdj1PYmplY3Qua2V5cyhuLmRlZmF1bHQpLnNvcnQoZikscD0wLGI9MDtwPHYubGVuZ3RoO3ArKyljW2JdPT09dltwXT8odltwXSs9Ijs/IixiKyspOnZbcF0rPSI7Ijt2YXIgRT1uZXcgUmVnRXhwKCImKD86Iit2LmpvaW4oInwiKSsifCNbeFhdW1xcZGEtZkEtRl0rOz98I1xcZCs7PykiLCJnIikseT14KG4uZGVmYXVsdCk7ZnVuY3Rpb24gTShpKXtyZXR1cm4gaS5zdWJzdHIoLTEpIT09IjsiJiYoaSs9IjsiKSx5KGkpfXJldHVybiBmdW5jdGlvbihpKXtyZXR1cm4gU3RyaW5nKGkpLnJlcGxhY2UoRSxNKX19KCk7ZnVuY3Rpb24geChjKXtyZXR1cm4gZnVuY3Rpb24ocCl7aWYocC5jaGFyQXQoMSk9PT0iIyIpe3ZhciBiPXAuY2hhckF0KDIpO3JldHVybiBiPT09IlgifHxiPT09IngiP3UuZGVmYXVsdChwYXJzZUludChwLnN1YnN0cigzKSwxNikpOnUuZGVmYXVsdChwYXJzZUludChwLnN1YnN0cigyKSwxMCkpfXJldHVybiBjW3Auc2xpY2UoMSwtMSldfX19LGZ1bmN0aW9uKGgpe2guZXhwb3J0cz1KU09OLnBhcnNlKCd7IkFhY3V0ZSI6IsOBIiwiYWFjdXRlIjoiw6EiLCJBYnJldmUiOiLEgiIsImFicmV2ZSI6IsSDIiwiYWMiOiLiiL4iLCJhY2QiOiLiiL8iLCJhY0UiOiLiiL7MsyIsIkFjaXJjIjoiw4IiLCJhY2lyYyI6IsOiIiwiYWN1dGUiOiLCtCIsIkFjeSI6ItCQIiwiYWN5Ijoi0LAiLCJBRWxpZyI6IsOGIiwiYWVsaWciOiLDpiIsImFmIjoi4oGhIiwiQWZyIjoi8J2UhCIsImFmciI6IvCdlJ4iLCJBZ3JhdmUiOiLDgCIsImFncmF2ZSI6IsOgIiwiYWxlZnN5bSI6IuKEtSIsImFsZXBoIjoi4oS1IiwiQWxwaGEiOiLOkSIsImFscGhhIjoizrEiLCJBbWFjciI6IsSAIiwiYW1hY3IiOiLEgSIsImFtYWxnIjoi4qi/IiwiYW1wIjoiJiIsIkFNUCI6IiYiLCJhbmRhbmQiOiLiqZUiLCJBbmQiOiLiqZMiLCJhbmQiOiLiiKciLCJhbmRkIjoi4qmcIiwiYW5kc2xvcGUiOiLiqZgiLCJhbmR2Ijoi4qmaIiwiYW5nIjoi4oigIiwiYW5nZSI6IuKmpCIsImFuZ2xlIjoi4oigIiwiYW5nbXNkYWEiOiLipqgiLCJhbmdtc2RhYiI6IuKmqSIsImFuZ21zZGFjIjoi4qaqIiwiYW5nbXNkYWQiOiLipqsiLCJhbmdtc2RhZSI6IuKmrCIsImFuZ21zZGFmIjoi4qatIiwiYW5nbXNkYWciOiLipq4iLCJhbmdtc2RhaCI6IuKmryIsImFuZ21zZCI6IuKIoSIsImFuZ3J0Ijoi4oifIiwiYW5ncnR2YiI6IuKKviIsImFuZ3J0dmJkIjoi4qadIiwiYW5nc3BoIjoi4oiiIiwiYW5nc3QiOiLDhSIsImFuZ3phcnIiOiLijbwiLCJBb2dvbiI6IsSEIiwiYW9nb24iOiLEhSIsIkFvcGYiOiLwnZS4IiwiYW9wZiI6IvCdlZIiLCJhcGFjaXIiOiLiqa8iLCJhcCI6IuKJiCIsImFwRSI6IuKpsCIsImFwZSI6IuKJiiIsImFwaWQiOiLiiYsiLCJhcG9zIjoiXCciLCJBcHBseUZ1bmN0aW9uIjoi4oGhIiwiYXBwcm94Ijoi4omIIiwiYXBwcm94ZXEiOiLiiYoiLCJBcmluZyI6IsOFIiwiYXJpbmciOiLDpSIsIkFzY3IiOiLwnZKcIiwiYXNjciI6IvCdkrYiLCJBc3NpZ24iOiLiiZQiLCJhc3QiOiIqIiwiYXN5bXAiOiLiiYgiLCJhc3ltcGVxIjoi4omNIiwiQXRpbGRlIjoiw4MiLCJhdGlsZGUiOiLDoyIsIkF1bWwiOiLDhCIsImF1bWwiOiLDpCIsImF3Y29uaW50Ijoi4oizIiwiYXdpbnQiOiLiqJEiLCJiYWNrY29uZyI6IuKJjCIsImJhY2tlcHNpbG9uIjoiz7YiLCJiYWNrcHJpbWUiOiLigLUiLCJiYWNrc2ltIjoi4oi9IiwiYmFja3NpbWVxIjoi4ouNIiwiQmFja3NsYXNoIjoi4oiWIiwiQmFydiI6IuKrpyIsImJhcnZlZSI6IuKKvSIsImJhcndlZCI6IuKMhSIsIkJhcndlZCI6IuKMhiIsImJhcndlZGdlIjoi4oyFIiwiYmJyayI6IuKOtSIsImJicmt0YnJrIjoi4o62IiwiYmNvbmciOiLiiYwiLCJCY3kiOiLQkSIsImJjeSI6ItCxIiwiYmRxdW8iOiLigJ4iLCJiZWNhdXMiOiLiiLUiLCJiZWNhdXNlIjoi4oi1IiwiQmVjYXVzZSI6IuKItSIsImJlbXB0eXYiOiLiprAiLCJiZXBzaSI6Is+2IiwiYmVybm91Ijoi4oSsIiwiQmVybm91bGxpcyI6IuKErCIsIkJldGEiOiLOkiIsImJldGEiOiLOsiIsImJldGgiOiLihLYiLCJiZXR3ZWVuIjoi4omsIiwiQmZyIjoi8J2UhSIsImJmciI6IvCdlJ8iLCJiaWdjYXAiOiLii4IiLCJiaWdjaXJjIjoi4pevIiwiYmlnY3VwIjoi4ouDIiwiYmlnb2RvdCI6IuKogCIsImJpZ29wbHVzIjoi4qiBIiwiYmlnb3RpbWVzIjoi4qiCIiwiYmlnc3FjdXAiOiLiqIYiLCJiaWdzdGFyIjoi4piFIiwiYmlndHJpYW5nbGVkb3duIjoi4pa9IiwiYmlndHJpYW5nbGV1cCI6IuKWsyIsImJpZ3VwbHVzIjoi4qiEIiwiYmlndmVlIjoi4ouBIiwiYmlnd2VkZ2UiOiLii4AiLCJia2Fyb3ciOiLipI0iLCJibGFja2xvemVuZ2UiOiLip6siLCJibGFja3NxdWFyZSI6IuKWqiIsImJsYWNrdHJpYW5nbGUiOiLilrQiLCJibGFja3RyaWFuZ2xlZG93biI6IuKWviIsImJsYWNrdHJpYW5nbGVsZWZ0Ijoi4peCIiwiYmxhY2t0cmlhbmdsZXJpZ2h0Ijoi4pa4IiwiYmxhbmsiOiLikKMiLCJibGsxMiI6IuKWkiIsImJsazE0Ijoi4paRIiwiYmxrMzQiOiLilpMiLCJibG9jayI6IuKWiCIsImJuZSI6Ij3ig6UiLCJibmVxdWl2Ijoi4omh4oOlIiwiYk5vdCI6IuKrrSIsImJub3QiOiLijJAiLCJCb3BmIjoi8J2UuSIsImJvcGYiOiLwnZWTIiwiYm90Ijoi4oqlIiwiYm90dG9tIjoi4oqlIiwiYm93dGllIjoi4ouIIiwiYm94Ym94Ijoi4qeJIiwiYm94ZGwiOiLilJAiLCJib3hkTCI6IuKVlSIsImJveERsIjoi4pWWIiwiYm94REwiOiLilZciLCJib3hkciI6IuKUjCIsImJveGRSIjoi4pWSIiwiYm94RHIiOiLilZMiLCJib3hEUiI6IuKVlCIsImJveGgiOiLilIAiLCJib3hIIjoi4pWQIiwiYm94aGQiOiLilKwiLCJib3hIZCI6IuKVpCIsImJveGhEIjoi4pWlIiwiYm94SEQiOiLilaYiLCJib3hodSI6IuKUtCIsImJveEh1Ijoi4pWnIiwiYm94aFUiOiLilagiLCJib3hIVSI6IuKVqSIsImJveG1pbnVzIjoi4oqfIiwiYm94cGx1cyI6IuKKniIsImJveHRpbWVzIjoi4oqgIiwiYm94dWwiOiLilJgiLCJib3h1TCI6IuKVmyIsImJveFVsIjoi4pWcIiwiYm94VUwiOiLilZ0iLCJib3h1ciI6IuKUlCIsImJveHVSIjoi4pWYIiwiYm94VXIiOiLilZkiLCJib3hVUiI6IuKVmiIsImJveHYiOiLilIIiLCJib3hWIjoi4pWRIiwiYm94dmgiOiLilLwiLCJib3h2SCI6IuKVqiIsImJveFZoIjoi4pWrIiwiYm94VkgiOiLilawiLCJib3h2bCI6IuKUpCIsImJveHZMIjoi4pWhIiwiYm94VmwiOiLilaIiLCJib3hWTCI6IuKVoyIsImJveHZyIjoi4pScIiwiYm94dlIiOiLilZ4iLCJib3hWciI6IuKVnyIsImJveFZSIjoi4pWgIiwiYnByaW1lIjoi4oC1IiwiYnJldmUiOiLLmCIsIkJyZXZlIjoiy5giLCJicnZiYXIiOiLCpiIsImJzY3IiOiLwnZK3IiwiQnNjciI6IuKErCIsImJzZW1pIjoi4oGPIiwiYnNpbSI6IuKIvSIsImJzaW1lIjoi4ouNIiwiYnNvbGIiOiLip4UiLCJic29sIjoiXFxcXCIsImJzb2xoc3ViIjoi4p+IIiwiYnVsbCI6IuKAoiIsImJ1bGxldCI6IuKAoiIsImJ1bXAiOiLiiY4iLCJidW1wRSI6IuKqriIsImJ1bXBlIjoi4omPIiwiQnVtcGVxIjoi4omOIiwiYnVtcGVxIjoi4omPIiwiQ2FjdXRlIjoixIYiLCJjYWN1dGUiOiLEhyIsImNhcGFuZCI6IuKphCIsImNhcGJyY3VwIjoi4qmJIiwiY2FwY2FwIjoi4qmLIiwiY2FwIjoi4oipIiwiQ2FwIjoi4ouSIiwiY2FwY3VwIjoi4qmHIiwiY2FwZG90Ijoi4qmAIiwiQ2FwaXRhbERpZmZlcmVudGlhbEQiOiLihYUiLCJjYXBzIjoi4oip77iAIiwiY2FyZXQiOiLigYEiLCJjYXJvbiI6IsuHIiwiQ2F5bGV5cyI6IuKErSIsImNjYXBzIjoi4qmNIiwiQ2Nhcm9uIjoixIwiLCJjY2Fyb24iOiLEjSIsIkNjZWRpbCI6IsOHIiwiY2NlZGlsIjoiw6ciLCJDY2lyYyI6IsSIIiwiY2NpcmMiOiLEiSIsIkNjb25pbnQiOiLiiLAiLCJjY3VwcyI6IuKpjCIsImNjdXBzc20iOiLiqZAiLCJDZG90IjoixIoiLCJjZG90IjoixIsiLCJjZWRpbCI6IsK4IiwiQ2VkaWxsYSI6IsK4IiwiY2VtcHR5diI6IuKmsiIsImNlbnQiOiLCoiIsImNlbnRlcmRvdCI6IsK3IiwiQ2VudGVyRG90IjoiwrciLCJjZnIiOiLwnZSgIiwiQ2ZyIjoi4oStIiwiQ0hjeSI6ItCnIiwiY2hjeSI6ItGHIiwiY2hlY2siOiLinJMiLCJjaGVja21hcmsiOiLinJMiLCJDaGkiOiLOpyIsImNoaSI6Is+HIiwiY2lyYyI6IsuGIiwiY2lyY2VxIjoi4omXIiwiY2lyY2xlYXJyb3dsZWZ0Ijoi4oa6IiwiY2lyY2xlYXJyb3dyaWdodCI6IuKGuyIsImNpcmNsZWRhc3QiOiLiipsiLCJjaXJjbGVkY2lyYyI6IuKKmiIsImNpcmNsZWRkYXNoIjoi4oqdIiwiQ2lyY2xlRG90Ijoi4oqZIiwiY2lyY2xlZFIiOiLCriIsImNpcmNsZWRTIjoi4pOIIiwiQ2lyY2xlTWludXMiOiLiipYiLCJDaXJjbGVQbHVzIjoi4oqVIiwiQ2lyY2xlVGltZXMiOiLiipciLCJjaXIiOiLil4siLCJjaXJFIjoi4qeDIiwiY2lyZSI6IuKJlyIsImNpcmZuaW50Ijoi4qiQIiwiY2lybWlkIjoi4quvIiwiY2lyc2NpciI6IuKngiIsIkNsb2Nrd2lzZUNvbnRvdXJJbnRlZ3JhbCI6IuKIsiIsIkNsb3NlQ3VybHlEb3VibGVRdW90ZSI6IuKAnSIsIkNsb3NlQ3VybHlRdW90ZSI6IuKAmSIsImNsdWJzIjoi4pmjIiwiY2x1YnN1aXQiOiLimaMiLCJjb2xvbiI6IjoiLCJDb2xvbiI6IuKItyIsIkNvbG9uZSI6IuKptCIsImNvbG9uZSI6IuKJlCIsImNvbG9uZXEiOiLiiZQiLCJjb21tYSI6IiwiLCJjb21tYXQiOiJAIiwiY29tcCI6IuKIgSIsImNvbXBmbiI6IuKImCIsImNvbXBsZW1lbnQiOiLiiIEiLCJjb21wbGV4ZXMiOiLihIIiLCJjb25nIjoi4omFIiwiY29uZ2RvdCI6IuKprSIsIkNvbmdydWVudCI6IuKJoSIsImNvbmludCI6IuKIriIsIkNvbmludCI6IuKIryIsIkNvbnRvdXJJbnRlZ3JhbCI6IuKIriIsImNvcGYiOiLwnZWUIiwiQ29wZiI6IuKEgiIsImNvcHJvZCI6IuKIkCIsIkNvcHJvZHVjdCI6IuKIkCIsImNvcHkiOiLCqSIsIkNPUFkiOiLCqSIsImNvcHlzciI6IuKElyIsIkNvdW50ZXJDbG9ja3dpc2VDb250b3VySW50ZWdyYWwiOiLiiLMiLCJjcmFyciI6IuKGtSIsImNyb3NzIjoi4pyXIiwiQ3Jvc3MiOiLiqK8iLCJDc2NyIjoi8J2SniIsImNzY3IiOiLwnZK4IiwiY3N1YiI6IuKrjyIsImNzdWJlIjoi4quRIiwiY3N1cCI6IuKrkCIsImNzdXBlIjoi4quSIiwiY3Rkb3QiOiLii68iLCJjdWRhcnJsIjoi4qS4IiwiY3VkYXJyciI6IuKktSIsImN1ZXByIjoi4oueIiwiY3Vlc2MiOiLii58iLCJjdWxhcnIiOiLihrYiLCJjdWxhcnJwIjoi4qS9IiwiY3VwYnJjYXAiOiLiqYgiLCJjdXBjYXAiOiLiqYYiLCJDdXBDYXAiOiLiiY0iLCJjdXAiOiLiiKoiLCJDdXAiOiLii5MiLCJjdXBjdXAiOiLiqYoiLCJjdXBkb3QiOiLiio0iLCJjdXBvciI6IuKphSIsImN1cHMiOiLiiKrvuIAiLCJjdXJhcnIiOiLihrciLCJjdXJhcnJtIjoi4qS8IiwiY3VybHllcXByZWMiOiLii54iLCJjdXJseWVxc3VjYyI6IuKLnyIsImN1cmx5dmVlIjoi4ouOIiwiY3VybHl3ZWRnZSI6IuKLjyIsImN1cnJlbiI6IsKkIiwiY3VydmVhcnJvd2xlZnQiOiLihrYiLCJjdXJ2ZWFycm93cmlnaHQiOiLihrciLCJjdXZlZSI6IuKLjiIsImN1d2VkIjoi4ouPIiwiY3djb25pbnQiOiLiiLIiLCJjd2ludCI6IuKIsSIsImN5bGN0eSI6IuKMrSIsImRhZ2dlciI6IuKAoCIsIkRhZ2dlciI6IuKAoSIsImRhbGV0aCI6IuKEuCIsImRhcnIiOiLihpMiLCJEYXJyIjoi4oahIiwiZEFyciI6IuKHkyIsImRhc2giOiLigJAiLCJEYXNodiI6IuKrpCIsImRhc2h2Ijoi4oqjIiwiZGJrYXJvdyI6IuKkjyIsImRibGFjIjoiy50iLCJEY2Fyb24iOiLEjiIsImRjYXJvbiI6IsSPIiwiRGN5Ijoi0JQiLCJkY3kiOiLQtCIsImRkYWdnZXIiOiLigKEiLCJkZGFyciI6IuKHiiIsIkREIjoi4oWFIiwiZGQiOiLihYYiLCJERG90cmFoZCI6IuKkkSIsImRkb3RzZXEiOiLiqbciLCJkZWciOiLCsCIsIkRlbCI6IuKIhyIsIkRlbHRhIjoizpQiLCJkZWx0YSI6Is60IiwiZGVtcHR5diI6IuKmsSIsImRmaXNodCI6IuKlvyIsIkRmciI6IvCdlIciLCJkZnIiOiLwnZShIiwiZEhhciI6IuKlpSIsImRoYXJsIjoi4oeDIiwiZGhhcnIiOiLih4IiLCJEaWFjcml0aWNhbEFjdXRlIjoiwrQiLCJEaWFjcml0aWNhbERvdCI6IsuZIiwiRGlhY3JpdGljYWxEb3VibGVBY3V0ZSI6IsudIiwiRGlhY3JpdGljYWxHcmF2ZSI6ImAiLCJEaWFjcml0aWNhbFRpbGRlIjoiy5wiLCJkaWFtIjoi4ouEIiwiZGlhbW9uZCI6IuKLhCIsIkRpYW1vbmQiOiLii4QiLCJkaWFtb25kc3VpdCI6IuKZpiIsImRpYW1zIjoi4pmmIiwiZGllIjoiwqgiLCJEaWZmZXJlbnRpYWxEIjoi4oWGIiwiZGlnYW1tYSI6Is+dIiwiZGlzaW4iOiLii7IiLCJkaXYiOiLDtyIsImRpdmlkZSI6IsO3IiwiZGl2aWRlb250aW1lcyI6IuKLhyIsImRpdm9ueCI6IuKLhyIsIkRKY3kiOiLQgiIsImRqY3kiOiLRkiIsImRsY29ybiI6IuKMniIsImRsY3JvcCI6IuKMjSIsImRvbGxhciI6IiQiLCJEb3BmIjoi8J2UuyIsImRvcGYiOiLwnZWVIiwiRG90IjoiwqgiLCJkb3QiOiLLmSIsIkRvdERvdCI6IuKDnCIsImRvdGVxIjoi4omQIiwiZG90ZXFkb3QiOiLiiZEiLCJEb3RFcXVhbCI6IuKJkCIsImRvdG1pbnVzIjoi4oi4IiwiZG90cGx1cyI6IuKIlCIsImRvdHNxdWFyZSI6IuKKoSIsImRvdWJsZWJhcndlZGdlIjoi4oyGIiwiRG91YmxlQ29udG91ckludGVncmFsIjoi4oivIiwiRG91YmxlRG90IjoiwqgiLCJEb3VibGVEb3duQXJyb3ciOiLih5MiLCJEb3VibGVMZWZ0QXJyb3ciOiLih5AiLCJEb3VibGVMZWZ0UmlnaHRBcnJvdyI6IuKHlCIsIkRvdWJsZUxlZnRUZWUiOiLiq6QiLCJEb3VibGVMb25nTGVmdEFycm93Ijoi4p+4IiwiRG91YmxlTG9uZ0xlZnRSaWdodEFycm93Ijoi4p+6IiwiRG91YmxlTG9uZ1JpZ2h0QXJyb3ciOiLin7kiLCJEb3VibGVSaWdodEFycm93Ijoi4oeSIiwiRG91YmxlUmlnaHRUZWUiOiLiiqgiLCJEb3VibGVVcEFycm93Ijoi4oeRIiwiRG91YmxlVXBEb3duQXJyb3ciOiLih5UiLCJEb3VibGVWZXJ0aWNhbEJhciI6IuKIpSIsIkRvd25BcnJvd0JhciI6IuKkkyIsImRvd25hcnJvdyI6IuKGkyIsIkRvd25BcnJvdyI6IuKGkyIsIkRvd25hcnJvdyI6IuKHkyIsIkRvd25BcnJvd1VwQXJyb3ciOiLih7UiLCJEb3duQnJldmUiOiLMkSIsImRvd25kb3duYXJyb3dzIjoi4oeKIiwiZG93bmhhcnBvb25sZWZ0Ijoi4oeDIiwiZG93bmhhcnBvb25yaWdodCI6IuKHgiIsIkRvd25MZWZ0UmlnaHRWZWN0b3IiOiLipZAiLCJEb3duTGVmdFRlZVZlY3RvciI6IuKlniIsIkRvd25MZWZ0VmVjdG9yQmFyIjoi4qWWIiwiRG93bkxlZnRWZWN0b3IiOiLihr0iLCJEb3duUmlnaHRUZWVWZWN0b3IiOiLipZ8iLCJEb3duUmlnaHRWZWN0b3JCYXIiOiLipZciLCJEb3duUmlnaHRWZWN0b3IiOiLih4EiLCJEb3duVGVlQXJyb3ciOiLihqciLCJEb3duVGVlIjoi4oqkIiwiZHJia2Fyb3ciOiLipJAiLCJkcmNvcm4iOiLijJ8iLCJkcmNyb3AiOiLijIwiLCJEc2NyIjoi8J2SnyIsImRzY3IiOiLwnZK5IiwiRFNjeSI6ItCFIiwiZHNjeSI6ItGVIiwiZHNvbCI6IuKntiIsIkRzdHJvayI6IsSQIiwiZHN0cm9rIjoixJEiLCJkdGRvdCI6IuKLsSIsImR0cmkiOiLilr8iLCJkdHJpZiI6IuKWviIsImR1YXJyIjoi4oe1IiwiZHVoYXIiOiLipa8iLCJkd2FuZ2xlIjoi4qamIiwiRFpjeSI6ItCPIiwiZHpjeSI6ItGfIiwiZHppZ3JhcnIiOiLin78iLCJFYWN1dGUiOiLDiSIsImVhY3V0ZSI6IsOpIiwiZWFzdGVyIjoi4qmuIiwiRWNhcm9uIjoixJoiLCJlY2Fyb24iOiLEmyIsIkVjaXJjIjoiw4oiLCJlY2lyYyI6IsOqIiwiZWNpciI6IuKJliIsImVjb2xvbiI6IuKJlSIsIkVjeSI6ItCtIiwiZWN5Ijoi0Y0iLCJlRERvdCI6IuKptyIsIkVkb3QiOiLEliIsImVkb3QiOiLElyIsImVEb3QiOiLiiZEiLCJlZSI6IuKFhyIsImVmRG90Ijoi4omSIiwiRWZyIjoi8J2UiCIsImVmciI6IvCdlKIiLCJlZyI6IuKqmiIsIkVncmF2ZSI6IsOIIiwiZWdyYXZlIjoiw6giLCJlZ3MiOiLiqpYiLCJlZ3Nkb3QiOiLiqpgiLCJlbCI6IuKqmSIsIkVsZW1lbnQiOiLiiIgiLCJlbGludGVycyI6IuKPpyIsImVsbCI6IuKEkyIsImVscyI6IuKqlSIsImVsc2RvdCI6IuKqlyIsIkVtYWNyIjoixJIiLCJlbWFjciI6IsSTIiwiZW1wdHkiOiLiiIUiLCJlbXB0eXNldCI6IuKIhSIsIkVtcHR5U21hbGxTcXVhcmUiOiLil7siLCJlbXB0eXYiOiLiiIUiLCJFbXB0eVZlcnlTbWFsbFNxdWFyZSI6IuKWqyIsImVtc3AxMyI6IuKAhCIsImVtc3AxNCI6IuKAhSIsImVtc3AiOiLigIMiLCJFTkciOiLFiiIsImVuZyI6IsWLIiwiZW5zcCI6IuKAgiIsIkVvZ29uIjoixJgiLCJlb2dvbiI6IsSZIiwiRW9wZiI6IvCdlLwiLCJlb3BmIjoi8J2VliIsImVwYXIiOiLii5UiLCJlcGFyc2wiOiLip6MiLCJlcGx1cyI6IuKpsSIsImVwc2kiOiLOtSIsIkVwc2lsb24iOiLOlSIsImVwc2lsb24iOiLOtSIsImVwc2l2Ijoiz7UiLCJlcWNpcmMiOiLiiZYiLCJlcWNvbG9uIjoi4omVIiwiZXFzaW0iOiLiiYIiLCJlcXNsYW50Z3RyIjoi4qqWIiwiZXFzbGFudGxlc3MiOiLiqpUiLCJFcXVhbCI6IuKptSIsImVxdWFscyI6Ij0iLCJFcXVhbFRpbGRlIjoi4omCIiwiZXF1ZXN0Ijoi4omfIiwiRXF1aWxpYnJpdW0iOiLih4wiLCJlcXVpdiI6IuKJoSIsImVxdWl2REQiOiLiqbgiLCJlcXZwYXJzbCI6IuKnpSIsImVyYXJyIjoi4qWxIiwiZXJEb3QiOiLiiZMiLCJlc2NyIjoi4oSvIiwiRXNjciI6IuKEsCIsImVzZG90Ijoi4omQIiwiRXNpbSI6IuKpsyIsImVzaW0iOiLiiYIiLCJFdGEiOiLOlyIsImV0YSI6Is63IiwiRVRIIjoiw5AiLCJldGgiOiLDsCIsIkV1bWwiOiLDiyIsImV1bWwiOiLDqyIsImV1cm8iOiLigqwiLCJleGNsIjoiISIsImV4aXN0Ijoi4oiDIiwiRXhpc3RzIjoi4oiDIiwiZXhwZWN0YXRpb24iOiLihLAiLCJleHBvbmVudGlhbGUiOiLihYciLCJFeHBvbmVudGlhbEUiOiLihYciLCJmYWxsaW5nZG90c2VxIjoi4omSIiwiRmN5Ijoi0KQiLCJmY3kiOiLRhCIsImZlbWFsZSI6IuKZgCIsImZmaWxpZyI6Iu+sgyIsImZmbGlnIjoi76yAIiwiZmZsbGlnIjoi76yEIiwiRmZyIjoi8J2UiSIsImZmciI6IvCdlKMiLCJmaWxpZyI6Iu+sgSIsIkZpbGxlZFNtYWxsU3F1YXJlIjoi4pe8IiwiRmlsbGVkVmVyeVNtYWxsU3F1YXJlIjoi4paqIiwiZmpsaWciOiJmaiIsImZsYXQiOiLima0iLCJmbGxpZyI6Iu+sgiIsImZsdG5zIjoi4paxIiwiZm5vZiI6IsaSIiwiRm9wZiI6IvCdlL0iLCJmb3BmIjoi8J2VlyIsImZvcmFsbCI6IuKIgCIsIkZvckFsbCI6IuKIgCIsImZvcmsiOiLii5QiLCJmb3JrdiI6IuKrmSIsIkZvdXJpZXJ0cmYiOiLihLEiLCJmcGFydGludCI6IuKojSIsImZyYWMxMiI6IsK9IiwiZnJhYzEzIjoi4oWTIiwiZnJhYzE0IjoiwrwiLCJmcmFjMTUiOiLihZUiLCJmcmFjMTYiOiLihZkiLCJmcmFjMTgiOiLihZsiLCJmcmFjMjMiOiLihZQiLCJmcmFjMjUiOiLihZYiLCJmcmFjMzQiOiLCviIsImZyYWMzNSI6IuKFlyIsImZyYWMzOCI6IuKFnCIsImZyYWM0NSI6IuKFmCIsImZyYWM1NiI6IuKFmiIsImZyYWM1OCI6IuKFnSIsImZyYWM3OCI6IuKFniIsImZyYXNsIjoi4oGEIiwiZnJvd24iOiLijKIiLCJmc2NyIjoi8J2SuyIsIkZzY3IiOiLihLEiLCJnYWN1dGUiOiLHtSIsIkdhbW1hIjoizpMiLCJnYW1tYSI6Is6zIiwiR2FtbWFkIjoiz5wiLCJnYW1tYWQiOiLPnSIsImdhcCI6IuKqhiIsIkdicmV2ZSI6IsSeIiwiZ2JyZXZlIjoixJ8iLCJHY2VkaWwiOiLEoiIsIkdjaXJjIjoixJwiLCJnY2lyYyI6IsSdIiwiR2N5Ijoi0JMiLCJnY3kiOiLQsyIsIkdkb3QiOiLEoCIsImdkb3QiOiLEoSIsImdlIjoi4omlIiwiZ0UiOiLiiaciLCJnRWwiOiLiqowiLCJnZWwiOiLii5siLCJnZXEiOiLiiaUiLCJnZXFxIjoi4omnIiwiZ2Vxc2xhbnQiOiLiqb4iLCJnZXNjYyI6IuKqqSIsImdlcyI6IuKpviIsImdlc2RvdCI6IuKqgCIsImdlc2RvdG8iOiLiqoIiLCJnZXNkb3RvbCI6IuKqhCIsImdlc2wiOiLii5vvuIAiLCJnZXNsZXMiOiLiqpQiLCJHZnIiOiLwnZSKIiwiZ2ZyIjoi8J2UpCIsImdnIjoi4omrIiwiR2ciOiLii5kiLCJnZ2ciOiLii5kiLCJnaW1lbCI6IuKEtyIsIkdKY3kiOiLQgyIsImdqY3kiOiLRkyIsImdsYSI6IuKqpSIsImdsIjoi4om3IiwiZ2xFIjoi4qqSIiwiZ2xqIjoi4qqkIiwiZ25hcCI6IuKqiiIsImduYXBwcm94Ijoi4qqKIiwiZ25lIjoi4qqIIiwiZ25FIjoi4ompIiwiZ25lcSI6IuKqiCIsImduZXFxIjoi4ompIiwiZ25zaW0iOiLii6ciLCJHb3BmIjoi8J2UviIsImdvcGYiOiLwnZWYIiwiZ3JhdmUiOiJgIiwiR3JlYXRlckVxdWFsIjoi4omlIiwiR3JlYXRlckVxdWFsTGVzcyI6IuKLmyIsIkdyZWF0ZXJGdWxsRXF1YWwiOiLiiaciLCJHcmVhdGVyR3JlYXRlciI6IuKqoiIsIkdyZWF0ZXJMZXNzIjoi4om3IiwiR3JlYXRlclNsYW50RXF1YWwiOiLiqb4iLCJHcmVhdGVyVGlsZGUiOiLiibMiLCJHc2NyIjoi8J2SoiIsImdzY3IiOiLihIoiLCJnc2ltIjoi4omzIiwiZ3NpbWUiOiLiqo4iLCJnc2ltbCI6IuKqkCIsImd0Y2MiOiLiqqciLCJndGNpciI6IuKpuiIsImd0IjoiPiIsIkdUIjoiPiIsIkd0Ijoi4omrIiwiZ3Rkb3QiOiLii5ciLCJndGxQYXIiOiLippUiLCJndHF1ZXN0Ijoi4qm8IiwiZ3RyYXBwcm94Ijoi4qqGIiwiZ3RyYXJyIjoi4qW4IiwiZ3RyZG90Ijoi4ouXIiwiZ3RyZXFsZXNzIjoi4oubIiwiZ3RyZXFxbGVzcyI6IuKqjCIsImd0cmxlc3MiOiLiibciLCJndHJzaW0iOiLiibMiLCJndmVydG5lcXEiOiLiianvuIAiLCJndm5FIjoi4omp77iAIiwiSGFjZWsiOiLLhyIsImhhaXJzcCI6IuKAiiIsImhhbGYiOiLCvSIsImhhbWlsdCI6IuKEiyIsIkhBUkRjeSI6ItCqIiwiaGFyZGN5Ijoi0YoiLCJoYXJyY2lyIjoi4qWIIiwiaGFyciI6IuKGlCIsImhBcnIiOiLih5QiLCJoYXJydyI6IuKGrSIsIkhhdCI6Il4iLCJoYmFyIjoi4oSPIiwiSGNpcmMiOiLEpCIsImhjaXJjIjoixKUiLCJoZWFydHMiOiLimaUiLCJoZWFydHN1aXQiOiLimaUiLCJoZWxsaXAiOiLigKYiLCJoZXJjb24iOiLiirkiLCJoZnIiOiLwnZSlIiwiSGZyIjoi4oSMIiwiSGlsYmVydFNwYWNlIjoi4oSLIiwiaGtzZWFyb3ciOiLipKUiLCJoa3N3YXJvdyI6IuKkpiIsImhvYXJyIjoi4oe/IiwiaG9tdGh0Ijoi4oi7IiwiaG9va2xlZnRhcnJvdyI6IuKGqSIsImhvb2tyaWdodGFycm93Ijoi4oaqIiwiaG9wZiI6IvCdlZkiLCJIb3BmIjoi4oSNIiwiaG9yYmFyIjoi4oCVIiwiSG9yaXpvbnRhbExpbmUiOiLilIAiLCJoc2NyIjoi8J2SvSIsIkhzY3IiOiLihIsiLCJoc2xhc2giOiLihI8iLCJIc3Ryb2siOiLEpiIsImhzdHJvayI6IsSnIiwiSHVtcERvd25IdW1wIjoi4omOIiwiSHVtcEVxdWFsIjoi4omPIiwiaHlidWxsIjoi4oGDIiwiaHlwaGVuIjoi4oCQIiwiSWFjdXRlIjoiw40iLCJpYWN1dGUiOiLDrSIsImljIjoi4oGjIiwiSWNpcmMiOiLDjiIsImljaXJjIjoiw64iLCJJY3kiOiLQmCIsImljeSI6ItC4IiwiSWRvdCI6IsSwIiwiSUVjeSI6ItCVIiwiaWVjeSI6ItC1IiwiaWV4Y2wiOiLCoSIsImlmZiI6IuKHlCIsImlmciI6IvCdlKYiLCJJZnIiOiLihJEiLCJJZ3JhdmUiOiLDjCIsImlncmF2ZSI6IsOsIiwiaWkiOiLihYgiLCJpaWlpbnQiOiLiqIwiLCJpaWludCI6IuKIrSIsImlpbmZpbiI6IuKnnCIsImlpb3RhIjoi4oSpIiwiSUpsaWciOiLEsiIsImlqbGlnIjoixLMiLCJJbWFjciI6IsSqIiwiaW1hY3IiOiLEqyIsImltYWdlIjoi4oSRIiwiSW1hZ2luYXJ5SSI6IuKFiCIsImltYWdsaW5lIjoi4oSQIiwiaW1hZ3BhcnQiOiLihJEiLCJpbWF0aCI6IsSxIiwiSW0iOiLihJEiLCJpbW9mIjoi4oq3IiwiaW1wZWQiOiLGtSIsIkltcGxpZXMiOiLih5IiLCJpbmNhcmUiOiLihIUiLCJpbiI6IuKIiCIsImluZmluIjoi4oieIiwiaW5maW50aWUiOiLip50iLCJpbm9kb3QiOiLEsSIsImludGNhbCI6IuKKuiIsImludCI6IuKIqyIsIkludCI6IuKIrCIsImludGVnZXJzIjoi4oSkIiwiSW50ZWdyYWwiOiLiiKsiLCJpbnRlcmNhbCI6IuKKuiIsIkludGVyc2VjdGlvbiI6IuKLgiIsImludGxhcmhrIjoi4qiXIiwiaW50cHJvZCI6IuKovCIsIkludmlzaWJsZUNvbW1hIjoi4oGjIiwiSW52aXNpYmxlVGltZXMiOiLigaIiLCJJT2N5Ijoi0IEiLCJpb2N5Ijoi0ZEiLCJJb2dvbiI6IsSuIiwiaW9nb24iOiLEryIsIklvcGYiOiLwnZWAIiwiaW9wZiI6IvCdlZoiLCJJb3RhIjoizpkiLCJpb3RhIjoizrkiLCJpcHJvZCI6IuKovCIsImlxdWVzdCI6IsK/IiwiaXNjciI6IvCdkr4iLCJJc2NyIjoi4oSQIiwiaXNpbiI6IuKIiCIsImlzaW5kb3QiOiLii7UiLCJpc2luRSI6IuKLuSIsImlzaW5zIjoi4ou0IiwiaXNpbnN2Ijoi4ouzIiwiaXNpbnYiOiLiiIgiLCJpdCI6IuKBoiIsIkl0aWxkZSI6IsSoIiwiaXRpbGRlIjoixKkiLCJJdWtjeSI6ItCGIiwiaXVrY3kiOiLRliIsIkl1bWwiOiLDjyIsIml1bWwiOiLDryIsIkpjaXJjIjoixLQiLCJqY2lyYyI6IsS1IiwiSmN5Ijoi0JkiLCJqY3kiOiLQuSIsIkpmciI6IvCdlI0iLCJqZnIiOiLwnZSnIiwiam1hdGgiOiLItyIsIkpvcGYiOiLwnZWBIiwiam9wZiI6IvCdlZsiLCJKc2NyIjoi8J2SpSIsImpzY3IiOiLwnZK/IiwiSnNlcmN5Ijoi0IgiLCJqc2VyY3kiOiLRmCIsIkp1a2N5Ijoi0IQiLCJqdWtjeSI6ItGUIiwiS2FwcGEiOiLOmiIsImthcHBhIjoizroiLCJrYXBwYXYiOiLPsCIsIktjZWRpbCI6IsS2Iiwia2NlZGlsIjoixLciLCJLY3kiOiLQmiIsImtjeSI6ItC6IiwiS2ZyIjoi8J2UjiIsImtmciI6IvCdlKgiLCJrZ3JlZW4iOiLEuCIsIktIY3kiOiLQpSIsImtoY3kiOiLRhSIsIktKY3kiOiLQjCIsImtqY3kiOiLRnCIsIktvcGYiOiLwnZWCIiwia29wZiI6IvCdlZwiLCJLc2NyIjoi8J2SpiIsImtzY3IiOiLwnZOAIiwibEFhcnIiOiLih5oiLCJMYWN1dGUiOiLEuSIsImxhY3V0ZSI6IsS6IiwibGFlbXB0eXYiOiLiprQiLCJsYWdyYW4iOiLihJIiLCJMYW1iZGEiOiLOmyIsImxhbWJkYSI6Is67IiwibGFuZyI6IuKfqCIsIkxhbmciOiLin6oiLCJsYW5nZCI6IuKmkSIsImxhbmdsZSI6IuKfqCIsImxhcCI6IuKqhSIsIkxhcGxhY2V0cmYiOiLihJIiLCJsYXF1byI6IsKrIiwibGFycmIiOiLih6QiLCJsYXJyYmZzIjoi4qSfIiwibGFyciI6IuKGkCIsIkxhcnIiOiLihp4iLCJsQXJyIjoi4oeQIiwibGFycmZzIjoi4qSdIiwibGFycmhrIjoi4oapIiwibGFycmxwIjoi4oarIiwibGFycnBsIjoi4qS5IiwibGFycnNpbSI6IuKlsyIsImxhcnJ0bCI6IuKGoiIsImxhdGFpbCI6IuKkmSIsImxBdGFpbCI6IuKkmyIsImxhdCI6IuKqqyIsImxhdGUiOiLiqq0iLCJsYXRlcyI6IuKqre+4gCIsImxiYXJyIjoi4qSMIiwibEJhcnIiOiLipI4iLCJsYmJyayI6IuKdsiIsImxicmFjZSI6InsiLCJsYnJhY2siOiJbIiwibGJya2UiOiLiposiLCJsYnJrc2xkIjoi4qaPIiwibGJya3NsdSI6IuKmjSIsIkxjYXJvbiI6IsS9IiwibGNhcm9uIjoixL4iLCJMY2VkaWwiOiLEuyIsImxjZWRpbCI6IsS8IiwibGNlaWwiOiLijIgiLCJsY3ViIjoieyIsIkxjeSI6ItCbIiwibGN5Ijoi0LsiLCJsZGNhIjoi4qS2IiwibGRxdW8iOiLigJwiLCJsZHF1b3IiOiLigJ4iLCJsZHJkaGFyIjoi4qWnIiwibGRydXNoYXIiOiLipYsiLCJsZHNoIjoi4oayIiwibGUiOiLiiaQiLCJsRSI6IuKJpiIsIkxlZnRBbmdsZUJyYWNrZXQiOiLin6giLCJMZWZ0QXJyb3dCYXIiOiLih6QiLCJsZWZ0YXJyb3ciOiLihpAiLCJMZWZ0QXJyb3ciOiLihpAiLCJMZWZ0YXJyb3ciOiLih5AiLCJMZWZ0QXJyb3dSaWdodEFycm93Ijoi4oeGIiwibGVmdGFycm93dGFpbCI6IuKGoiIsIkxlZnRDZWlsaW5nIjoi4oyIIiwiTGVmdERvdWJsZUJyYWNrZXQiOiLin6YiLCJMZWZ0RG93blRlZVZlY3RvciI6IuKloSIsIkxlZnREb3duVmVjdG9yQmFyIjoi4qWZIiwiTGVmdERvd25WZWN0b3IiOiLih4MiLCJMZWZ0Rmxvb3IiOiLijIoiLCJsZWZ0aGFycG9vbmRvd24iOiLihr0iLCJsZWZ0aGFycG9vbnVwIjoi4oa8IiwibGVmdGxlZnRhcnJvd3MiOiLih4ciLCJsZWZ0cmlnaHRhcnJvdyI6IuKGlCIsIkxlZnRSaWdodEFycm93Ijoi4oaUIiwiTGVmdHJpZ2h0YXJyb3ciOiLih5QiLCJsZWZ0cmlnaHRhcnJvd3MiOiLih4YiLCJsZWZ0cmlnaHRoYXJwb29ucyI6IuKHiyIsImxlZnRyaWdodHNxdWlnYXJyb3ciOiLihq0iLCJMZWZ0UmlnaHRWZWN0b3IiOiLipY4iLCJMZWZ0VGVlQXJyb3ciOiLihqQiLCJMZWZ0VGVlIjoi4oqjIiwiTGVmdFRlZVZlY3RvciI6IuKlmiIsImxlZnR0aHJlZXRpbWVzIjoi4ouLIiwiTGVmdFRyaWFuZ2xlQmFyIjoi4qePIiwiTGVmdFRyaWFuZ2xlIjoi4oqyIiwiTGVmdFRyaWFuZ2xlRXF1YWwiOiLiirQiLCJMZWZ0VXBEb3duVmVjdG9yIjoi4qWRIiwiTGVmdFVwVGVlVmVjdG9yIjoi4qWgIiwiTGVmdFVwVmVjdG9yQmFyIjoi4qWYIiwiTGVmdFVwVmVjdG9yIjoi4oa/IiwiTGVmdFZlY3RvckJhciI6IuKlkiIsIkxlZnRWZWN0b3IiOiLihrwiLCJsRWciOiLiqosiLCJsZWciOiLii5oiLCJsZXEiOiLiiaQiLCJsZXFxIjoi4ommIiwibGVxc2xhbnQiOiLiqb0iLCJsZXNjYyI6IuKqqCIsImxlcyI6IuKpvSIsImxlc2RvdCI6IuKpvyIsImxlc2RvdG8iOiLiqoEiLCJsZXNkb3RvciI6IuKqgyIsImxlc2ciOiLii5rvuIAiLCJsZXNnZXMiOiLiqpMiLCJsZXNzYXBwcm94Ijoi4qqFIiwibGVzc2RvdCI6IuKLliIsImxlc3NlcWd0ciI6IuKLmiIsImxlc3NlcXFndHIiOiLiqosiLCJMZXNzRXF1YWxHcmVhdGVyIjoi4ouaIiwiTGVzc0Z1bGxFcXVhbCI6IuKJpiIsIkxlc3NHcmVhdGVyIjoi4om2IiwibGVzc2d0ciI6IuKJtiIsIkxlc3NMZXNzIjoi4qqhIiwibGVzc3NpbSI6IuKJsiIsIkxlc3NTbGFudEVxdWFsIjoi4qm9IiwiTGVzc1RpbGRlIjoi4omyIiwibGZpc2h0Ijoi4qW8IiwibGZsb29yIjoi4oyKIiwiTGZyIjoi8J2UjyIsImxmciI6IvCdlKkiLCJsZyI6IuKJtiIsImxnRSI6IuKqkSIsImxIYXIiOiLipaIiLCJsaGFyZCI6IuKGvSIsImxoYXJ1Ijoi4oa8IiwibGhhcnVsIjoi4qWqIiwibGhibGsiOiLiloQiLCJMSmN5Ijoi0IkiLCJsamN5Ijoi0ZkiLCJsbGFyciI6IuKHhyIsImxsIjoi4omqIiwiTGwiOiLii5giLCJsbGNvcm5lciI6IuKMniIsIkxsZWZ0YXJyb3ciOiLih5oiLCJsbGhhcmQiOiLipasiLCJsbHRyaSI6IuKXuiIsIkxtaWRvdCI6IsS/IiwibG1pZG90IjoixYAiLCJsbW91c3RhY2hlIjoi4o6wIiwibG1vdXN0Ijoi4o6wIiwibG5hcCI6IuKqiSIsImxuYXBwcm94Ijoi4qqJIiwibG5lIjoi4qqHIiwibG5FIjoi4omoIiwibG5lcSI6IuKqhyIsImxuZXFxIjoi4omoIiwibG5zaW0iOiLii6YiLCJsb2FuZyI6IuKfrCIsImxvYXJyIjoi4oe9IiwibG9icmsiOiLin6YiLCJsb25nbGVmdGFycm93Ijoi4p+1IiwiTG9uZ0xlZnRBcnJvdyI6IuKftSIsIkxvbmdsZWZ0YXJyb3ciOiLin7giLCJsb25nbGVmdHJpZ2h0YXJyb3ciOiLin7ciLCJMb25nTGVmdFJpZ2h0QXJyb3ciOiLin7ciLCJMb25nbGVmdHJpZ2h0YXJyb3ciOiLin7oiLCJsb25nbWFwc3RvIjoi4p+8IiwibG9uZ3JpZ2h0YXJyb3ciOiLin7YiLCJMb25nUmlnaHRBcnJvdyI6IuKftiIsIkxvbmdyaWdodGFycm93Ijoi4p+5IiwibG9vcGFycm93bGVmdCI6IuKGqyIsImxvb3BhcnJvd3JpZ2h0Ijoi4oasIiwibG9wYXIiOiLipoUiLCJMb3BmIjoi8J2VgyIsImxvcGYiOiLwnZWdIiwibG9wbHVzIjoi4qitIiwibG90aW1lcyI6IuKotCIsImxvd2FzdCI6IuKIlyIsImxvd2JhciI6Il8iLCJMb3dlckxlZnRBcnJvdyI6IuKGmSIsIkxvd2VyUmlnaHRBcnJvdyI6IuKGmCIsImxveiI6IuKXiiIsImxvemVuZ2UiOiLil4oiLCJsb3pmIjoi4qerIiwibHBhciI6IigiLCJscGFybHQiOiLippMiLCJscmFyciI6IuKHhiIsImxyY29ybmVyIjoi4oyfIiwibHJoYXIiOiLih4siLCJscmhhcmQiOiLipa0iLCJscm0iOiLigI4iLCJscnRyaSI6IuKKvyIsImxzYXF1byI6IuKAuSIsImxzY3IiOiLwnZOBIiwiTHNjciI6IuKEkiIsImxzaCI6IuKGsCIsIkxzaCI6IuKGsCIsImxzaW0iOiLiibIiLCJsc2ltZSI6IuKqjSIsImxzaW1nIjoi4qqPIiwibHNxYiI6IlsiLCJsc3F1byI6IuKAmCIsImxzcXVvciI6IuKAmiIsIkxzdHJvayI6IsWBIiwibHN0cm9rIjoixYIiLCJsdGNjIjoi4qqmIiwibHRjaXIiOiLiqbkiLCJsdCI6IjwiLCJMVCI6IjwiLCJMdCI6IuKJqiIsImx0ZG90Ijoi4ouWIiwibHRocmVlIjoi4ouLIiwibHRpbWVzIjoi4ouJIiwibHRsYXJyIjoi4qW2IiwibHRxdWVzdCI6IuKpuyIsImx0cmkiOiLil4MiLCJsdHJpZSI6IuKKtCIsImx0cmlmIjoi4peCIiwibHRyUGFyIjoi4qaWIiwibHVyZHNoYXIiOiLipYoiLCJsdXJ1aGFyIjoi4qWmIiwibHZlcnRuZXFxIjoi4omo77iAIiwibHZuRSI6IuKJqO+4gCIsIm1hY3IiOiLCryIsIm1hbGUiOiLimYIiLCJtYWx0Ijoi4pygIiwibWFsdGVzZSI6IuKcoCIsIk1hcCI6IuKkhSIsIm1hcCI6IuKGpiIsIm1hcHN0byI6IuKGpiIsIm1hcHN0b2Rvd24iOiLihqciLCJtYXBzdG9sZWZ0Ijoi4oakIiwibWFwc3RvdXAiOiLihqUiLCJtYXJrZXIiOiLilq4iLCJtY29tbWEiOiLiqKkiLCJNY3kiOiLQnCIsIm1jeSI6ItC8IiwibWRhc2giOiLigJQiLCJtRERvdCI6IuKIuiIsIm1lYXN1cmVkYW5nbGUiOiLiiKEiLCJNZWRpdW1TcGFjZSI6IuKBnyIsIk1lbGxpbnRyZiI6IuKEsyIsIk1mciI6IvCdlJAiLCJtZnIiOiLwnZSqIiwibWhvIjoi4oSnIiwibWljcm8iOiLCtSIsIm1pZGFzdCI6IioiLCJtaWRjaXIiOiLiq7AiLCJtaWQiOiLiiKMiLCJtaWRkb3QiOiLCtyIsIm1pbnVzYiI6IuKKnyIsIm1pbnVzIjoi4oiSIiwibWludXNkIjoi4oi4IiwibWludXNkdSI6IuKoqiIsIk1pbnVzUGx1cyI6IuKIkyIsIm1sY3AiOiLiq5siLCJtbGRyIjoi4oCmIiwibW5wbHVzIjoi4oiTIiwibW9kZWxzIjoi4oqnIiwiTW9wZiI6IvCdlYQiLCJtb3BmIjoi8J2VniIsIm1wIjoi4oiTIiwibXNjciI6IvCdk4IiLCJNc2NyIjoi4oSzIiwibXN0cG9zIjoi4oi+IiwiTXUiOiLOnCIsIm11IjoizrwiLCJtdWx0aW1hcCI6IuKKuCIsIm11bWFwIjoi4oq4IiwibmFibGEiOiLiiIciLCJOYWN1dGUiOiLFgyIsIm5hY3V0ZSI6IsWEIiwibmFuZyI6IuKIoOKDkiIsIm5hcCI6IuKJiSIsIm5hcEUiOiLiqbDMuCIsIm5hcGlkIjoi4omLzLgiLCJuYXBvcyI6IsWJIiwibmFwcHJveCI6IuKJiSIsIm5hdHVyYWwiOiLima4iLCJuYXR1cmFscyI6IuKElSIsIm5hdHVyIjoi4pmuIiwibmJzcCI6IsKgIiwibmJ1bXAiOiLiiY7MuCIsIm5idW1wZSI6IuKJj8y4IiwibmNhcCI6IuKpgyIsIk5jYXJvbiI6IsWHIiwibmNhcm9uIjoixYgiLCJOY2VkaWwiOiLFhSIsIm5jZWRpbCI6IsWGIiwibmNvbmciOiLiiYciLCJuY29uZ2RvdCI6IuKprcy4IiwibmN1cCI6IuKpgiIsIk5jeSI6ItCdIiwibmN5Ijoi0L0iLCJuZGFzaCI6IuKAkyIsIm5lYXJoayI6IuKkpCIsIm5lYXJyIjoi4oaXIiwibmVBcnIiOiLih5ciLCJuZWFycm93Ijoi4oaXIiwibmUiOiLiiaAiLCJuZWRvdCI6IuKJkMy4IiwiTmVnYXRpdmVNZWRpdW1TcGFjZSI6IuKAiyIsIk5lZ2F0aXZlVGhpY2tTcGFjZSI6IuKAiyIsIk5lZ2F0aXZlVGhpblNwYWNlIjoi4oCLIiwiTmVnYXRpdmVWZXJ5VGhpblNwYWNlIjoi4oCLIiwibmVxdWl2Ijoi4omiIiwibmVzZWFyIjoi4qSoIiwibmVzaW0iOiLiiYLMuCIsIk5lc3RlZEdyZWF0ZXJHcmVhdGVyIjoi4omrIiwiTmVzdGVkTGVzc0xlc3MiOiLiiaoiLCJOZXdMaW5lIjoiXFxuIiwibmV4aXN0Ijoi4oiEIiwibmV4aXN0cyI6IuKIhCIsIk5mciI6IvCdlJEiLCJuZnIiOiLwnZSrIiwibmdFIjoi4omnzLgiLCJuZ2UiOiLiibEiLCJuZ2VxIjoi4omxIiwibmdlcXEiOiLiiafMuCIsIm5nZXFzbGFudCI6IuKpvsy4IiwibmdlcyI6IuKpvsy4IiwibkdnIjoi4ouZzLgiLCJuZ3NpbSI6IuKJtSIsIm5HdCI6IuKJq+KDkiIsIm5ndCI6IuKJryIsIm5ndHIiOiLiia8iLCJuR3R2Ijoi4omrzLgiLCJuaGFyciI6IuKGriIsIm5oQXJyIjoi4oeOIiwibmhwYXIiOiLiq7IiLCJuaSI6IuKIiyIsIm5pcyI6IuKLvCIsIm5pc2QiOiLii7oiLCJuaXYiOiLiiIsiLCJOSmN5Ijoi0IoiLCJuamN5Ijoi0ZoiLCJubGFyciI6IuKGmiIsIm5sQXJyIjoi4oeNIiwibmxkciI6IuKApSIsIm5sRSI6IuKJpsy4IiwibmxlIjoi4omwIiwibmxlZnRhcnJvdyI6IuKGmiIsIm5MZWZ0YXJyb3ciOiLih40iLCJubGVmdHJpZ2h0YXJyb3ciOiLihq4iLCJuTGVmdHJpZ2h0YXJyb3ciOiLih44iLCJubGVxIjoi4omwIiwibmxlcXEiOiLiiabMuCIsIm5sZXFzbGFudCI6IuKpvcy4IiwibmxlcyI6IuKpvcy4Iiwibmxlc3MiOiLiia4iLCJuTGwiOiLii5jMuCIsIm5sc2ltIjoi4om0Iiwibkx0Ijoi4omq4oOSIiwibmx0Ijoi4omuIiwibmx0cmkiOiLii6oiLCJubHRyaWUiOiLii6wiLCJuTHR2Ijoi4omqzLgiLCJubWlkIjoi4oikIiwiTm9CcmVhayI6IuKBoCIsIk5vbkJyZWFraW5nU3BhY2UiOiLCoCIsIm5vcGYiOiLwnZWfIiwiTm9wZiI6IuKElSIsIk5vdCI6IuKrrCIsIm5vdCI6IsKsIiwiTm90Q29uZ3J1ZW50Ijoi4omiIiwiTm90Q3VwQ2FwIjoi4omtIiwiTm90RG91YmxlVmVydGljYWxCYXIiOiLiiKYiLCJOb3RFbGVtZW50Ijoi4oiJIiwiTm90RXF1YWwiOiLiiaAiLCJOb3RFcXVhbFRpbGRlIjoi4omCzLgiLCJOb3RFeGlzdHMiOiLiiIQiLCJOb3RHcmVhdGVyIjoi4omvIiwiTm90R3JlYXRlckVxdWFsIjoi4omxIiwiTm90R3JlYXRlckZ1bGxFcXVhbCI6IuKJp8y4IiwiTm90R3JlYXRlckdyZWF0ZXIiOiLiiavMuCIsIk5vdEdyZWF0ZXJMZXNzIjoi4om5IiwiTm90R3JlYXRlclNsYW50RXF1YWwiOiLiqb7MuCIsIk5vdEdyZWF0ZXJUaWxkZSI6IuKJtSIsIk5vdEh1bXBEb3duSHVtcCI6IuKJjsy4IiwiTm90SHVtcEVxdWFsIjoi4omPzLgiLCJub3RpbiI6IuKIiSIsIm5vdGluZG90Ijoi4ou1zLgiLCJub3RpbkUiOiLii7nMuCIsIm5vdGludmEiOiLiiIkiLCJub3RpbnZiIjoi4ou3Iiwibm90aW52YyI6IuKLtiIsIk5vdExlZnRUcmlhbmdsZUJhciI6IuKnj8y4IiwiTm90TGVmdFRyaWFuZ2xlIjoi4ouqIiwiTm90TGVmdFRyaWFuZ2xlRXF1YWwiOiLii6wiLCJOb3RMZXNzIjoi4omuIiwiTm90TGVzc0VxdWFsIjoi4omwIiwiTm90TGVzc0dyZWF0ZXIiOiLiibgiLCJOb3RMZXNzTGVzcyI6IuKJqsy4IiwiTm90TGVzc1NsYW50RXF1YWwiOiLiqb3MuCIsIk5vdExlc3NUaWxkZSI6IuKJtCIsIk5vdE5lc3RlZEdyZWF0ZXJHcmVhdGVyIjoi4qqizLgiLCJOb3ROZXN0ZWRMZXNzTGVzcyI6IuKqocy4Iiwibm90bmkiOiLiiIwiLCJub3RuaXZhIjoi4oiMIiwibm90bml2YiI6IuKLviIsIm5vdG5pdmMiOiLii70iLCJOb3RQcmVjZWRlcyI6IuKKgCIsIk5vdFByZWNlZGVzRXF1YWwiOiLiqq/MuCIsIk5vdFByZWNlZGVzU2xhbnRFcXVhbCI6IuKLoCIsIk5vdFJldmVyc2VFbGVtZW50Ijoi4oiMIiwiTm90UmlnaHRUcmlhbmdsZUJhciI6IuKnkMy4IiwiTm90UmlnaHRUcmlhbmdsZSI6IuKLqyIsIk5vdFJpZ2h0VHJpYW5nbGVFcXVhbCI6IuKLrSIsIk5vdFNxdWFyZVN1YnNldCI6IuKKj8y4IiwiTm90U3F1YXJlU3Vic2V0RXF1YWwiOiLii6IiLCJOb3RTcXVhcmVTdXBlcnNldCI6IuKKkMy4IiwiTm90U3F1YXJlU3VwZXJzZXRFcXVhbCI6IuKLoyIsIk5vdFN1YnNldCI6IuKKguKDkiIsIk5vdFN1YnNldEVxdWFsIjoi4oqIIiwiTm90U3VjY2VlZHMiOiLiioEiLCJOb3RTdWNjZWVkc0VxdWFsIjoi4qqwzLgiLCJOb3RTdWNjZWVkc1NsYW50RXF1YWwiOiLii6EiLCJOb3RTdWNjZWVkc1RpbGRlIjoi4om/zLgiLCJOb3RTdXBlcnNldCI6IuKKg+KDkiIsIk5vdFN1cGVyc2V0RXF1YWwiOiLiiokiLCJOb3RUaWxkZSI6IuKJgSIsIk5vdFRpbGRlRXF1YWwiOiLiiYQiLCJOb3RUaWxkZUZ1bGxFcXVhbCI6IuKJhyIsIk5vdFRpbGRlVGlsZGUiOiLiiYkiLCJOb3RWZXJ0aWNhbEJhciI6IuKIpCIsIm5wYXJhbGxlbCI6IuKIpiIsIm5wYXIiOiLiiKYiLCJucGFyc2wiOiLiq73ig6UiLCJucGFydCI6IuKIgsy4IiwibnBvbGludCI6IuKolCIsIm5wciI6IuKKgCIsIm5wcmN1ZSI6IuKLoCIsIm5wcmVjIjoi4oqAIiwibnByZWNlcSI6IuKqr8y4IiwibnByZSI6IuKqr8y4IiwibnJhcnJjIjoi4qSzzLgiLCJucmFyciI6IuKGmyIsIm5yQXJyIjoi4oePIiwibnJhcnJ3Ijoi4oadzLgiLCJucmlnaHRhcnJvdyI6IuKGmyIsIm5SaWdodGFycm93Ijoi4oePIiwibnJ0cmkiOiLii6siLCJucnRyaWUiOiLii60iLCJuc2MiOiLiioEiLCJuc2NjdWUiOiLii6EiLCJuc2NlIjoi4qqwzLgiLCJOc2NyIjoi8J2SqSIsIm5zY3IiOiLwnZODIiwibnNob3J0bWlkIjoi4oikIiwibnNob3J0cGFyYWxsZWwiOiLiiKYiLCJuc2ltIjoi4omBIiwibnNpbWUiOiLiiYQiLCJuc2ltZXEiOiLiiYQiLCJuc21pZCI6IuKIpCIsIm5zcGFyIjoi4oimIiwibnNxc3ViZSI6IuKLoiIsIm5zcXN1cGUiOiLii6MiLCJuc3ViIjoi4oqEIiwibnN1YkUiOiLiq4XMuCIsIm5zdWJlIjoi4oqIIiwibnN1YnNldCI6IuKKguKDkiIsIm5zdWJzZXRlcSI6IuKKiCIsIm5zdWJzZXRlcXEiOiLiq4XMuCIsIm5zdWNjIjoi4oqBIiwibnN1Y2NlcSI6IuKqsMy4IiwibnN1cCI6IuKKhSIsIm5zdXBFIjoi4quGzLgiLCJuc3VwZSI6IuKKiSIsIm5zdXBzZXQiOiLiioPig5IiLCJuc3Vwc2V0ZXEiOiLiiokiLCJuc3Vwc2V0ZXFxIjoi4quGzLgiLCJudGdsIjoi4om5IiwiTnRpbGRlIjoiw5EiLCJudGlsZGUiOiLDsSIsIm50bGciOiLiibgiLCJudHJpYW5nbGVsZWZ0Ijoi4ouqIiwibnRyaWFuZ2xlbGVmdGVxIjoi4ousIiwibnRyaWFuZ2xlcmlnaHQiOiLii6siLCJudHJpYW5nbGVyaWdodGVxIjoi4outIiwiTnUiOiLOnSIsIm51Ijoizr0iLCJudW0iOiIjIiwibnVtZXJvIjoi4oSWIiwibnVtc3AiOiLigIciLCJudmFwIjoi4omN4oOSIiwibnZkYXNoIjoi4oqsIiwibnZEYXNoIjoi4oqtIiwiblZkYXNoIjoi4oquIiwiblZEYXNoIjoi4oqvIiwibnZnZSI6IuKJpeKDkiIsIm52Z3QiOiI+4oOSIiwibnZIYXJyIjoi4qSEIiwibnZpbmZpbiI6IuKnniIsIm52bEFyciI6IuKkgiIsIm52bGUiOiLiiaTig5IiLCJudmx0IjoiPOKDkiIsIm52bHRyaWUiOiLiirTig5IiLCJudnJBcnIiOiLipIMiLCJudnJ0cmllIjoi4oq14oOSIiwibnZzaW0iOiLiiLzig5IiLCJud2FyaGsiOiLipKMiLCJud2FyciI6IuKGliIsIm53QXJyIjoi4oeWIiwibndhcnJvdyI6IuKGliIsIm53bmVhciI6IuKkpyIsIk9hY3V0ZSI6IsOTIiwib2FjdXRlIjoiw7MiLCJvYXN0Ijoi4oqbIiwiT2NpcmMiOiLDlCIsIm9jaXJjIjoiw7QiLCJvY2lyIjoi4oqaIiwiT2N5Ijoi0J4iLCJvY3kiOiLQviIsIm9kYXNoIjoi4oqdIiwiT2RibGFjIjoixZAiLCJvZGJsYWMiOiLFkSIsIm9kaXYiOiLiqLgiLCJvZG90Ijoi4oqZIiwib2Rzb2xkIjoi4qa8IiwiT0VsaWciOiLFkiIsIm9lbGlnIjoixZMiLCJvZmNpciI6IuKmvyIsIk9mciI6IvCdlJIiLCJvZnIiOiLwnZSsIiwib2dvbiI6IsubIiwiT2dyYXZlIjoiw5IiLCJvZ3JhdmUiOiLDsiIsIm9ndCI6IuKngSIsIm9oYmFyIjoi4qa1Iiwib2htIjoizqkiLCJvaW50Ijoi4oiuIiwib2xhcnIiOiLihroiLCJvbGNpciI6IuKmviIsIm9sY3Jvc3MiOiLiprsiLCJvbGluZSI6IuKAviIsIm9sdCI6IuKngCIsIk9tYWNyIjoixYwiLCJvbWFjciI6IsWNIiwiT21lZ2EiOiLOqSIsIm9tZWdhIjoiz4kiLCJPbWljcm9uIjoizp8iLCJvbWljcm9uIjoizr8iLCJvbWlkIjoi4qa2Iiwib21pbnVzIjoi4oqWIiwiT29wZiI6IvCdlYYiLCJvb3BmIjoi8J2VoCIsIm9wYXIiOiLiprciLCJPcGVuQ3VybHlEb3VibGVRdW90ZSI6IuKAnCIsIk9wZW5DdXJseVF1b3RlIjoi4oCYIiwib3BlcnAiOiLiprkiLCJvcGx1cyI6IuKKlSIsIm9yYXJyIjoi4oa7IiwiT3IiOiLiqZQiLCJvciI6IuKIqCIsIm9yZCI6IuKpnSIsIm9yZGVyIjoi4oS0Iiwib3JkZXJvZiI6IuKEtCIsIm9yZGYiOiLCqiIsIm9yZG0iOiLCuiIsIm9yaWdvZiI6IuKKtiIsIm9yb3IiOiLiqZYiLCJvcnNsb3BlIjoi4qmXIiwib3J2Ijoi4qmbIiwib1MiOiLik4giLCJPc2NyIjoi8J2SqiIsIm9zY3IiOiLihLQiLCJPc2xhc2giOiLDmCIsIm9zbGFzaCI6IsO4Iiwib3NvbCI6IuKKmCIsIk90aWxkZSI6IsOVIiwib3RpbGRlIjoiw7UiLCJvdGltZXNhcyI6IuKotiIsIk90aW1lcyI6IuKotyIsIm90aW1lcyI6IuKKlyIsIk91bWwiOiLDliIsIm91bWwiOiLDtiIsIm92YmFyIjoi4oy9IiwiT3ZlckJhciI6IuKAviIsIk92ZXJCcmFjZSI6IuKPniIsIk92ZXJCcmFja2V0Ijoi4o60IiwiT3ZlclBhcmVudGhlc2lzIjoi4o+cIiwicGFyYSI6IsK2IiwicGFyYWxsZWwiOiLiiKUiLCJwYXIiOiLiiKUiLCJwYXJzaW0iOiLiq7MiLCJwYXJzbCI6IuKrvSIsInBhcnQiOiLiiIIiLCJQYXJ0aWFsRCI6IuKIgiIsIlBjeSI6ItCfIiwicGN5Ijoi0L8iLCJwZXJjbnQiOiIlIiwicGVyaW9kIjoiLiIsInBlcm1pbCI6IuKAsCIsInBlcnAiOiLiiqUiLCJwZXJ0ZW5rIjoi4oCxIiwiUGZyIjoi8J2UkyIsInBmciI6IvCdlK0iLCJQaGkiOiLOpiIsInBoaSI6Is+GIiwicGhpdiI6Is+VIiwicGhtbWF0Ijoi4oSzIiwicGhvbmUiOiLimI4iLCJQaSI6Is6gIiwicGkiOiLPgCIsInBpdGNoZm9yayI6IuKLlCIsInBpdiI6Is+WIiwicGxhbmNrIjoi4oSPIiwicGxhbmNraCI6IuKEjiIsInBsYW5rdiI6IuKEjyIsInBsdXNhY2lyIjoi4qijIiwicGx1c2IiOiLiip4iLCJwbHVzY2lyIjoi4qiiIiwicGx1cyI6IisiLCJwbHVzZG8iOiLiiJQiLCJwbHVzZHUiOiLiqKUiLCJwbHVzZSI6IuKpsiIsIlBsdXNNaW51cyI6IsKxIiwicGx1c21uIjoiwrEiLCJwbHVzc2ltIjoi4qimIiwicGx1c3R3byI6IuKopyIsInBtIjoiwrEiLCJQb2luY2FyZXBsYW5lIjoi4oSMIiwicG9pbnRpbnQiOiLiqJUiLCJwb3BmIjoi8J2VoSIsIlBvcGYiOiLihJkiLCJwb3VuZCI6IsKjIiwicHJhcCI6IuKqtyIsIlByIjoi4qq7IiwicHIiOiLiiboiLCJwcmN1ZSI6IuKJvCIsInByZWNhcHByb3giOiLiqrciLCJwcmVjIjoi4om6IiwicHJlY2N1cmx5ZXEiOiLiibwiLCJQcmVjZWRlcyI6IuKJuiIsIlByZWNlZGVzRXF1YWwiOiLiqq8iLCJQcmVjZWRlc1NsYW50RXF1YWwiOiLiibwiLCJQcmVjZWRlc1RpbGRlIjoi4om+IiwicHJlY2VxIjoi4qqvIiwicHJlY25hcHByb3giOiLiqrkiLCJwcmVjbmVxcSI6IuKqtSIsInByZWNuc2ltIjoi4ouoIiwicHJlIjoi4qqvIiwicHJFIjoi4qqzIiwicHJlY3NpbSI6IuKJviIsInByaW1lIjoi4oCyIiwiUHJpbWUiOiLigLMiLCJwcmltZXMiOiLihJkiLCJwcm5hcCI6IuKquSIsInBybkUiOiLiqrUiLCJwcm5zaW0iOiLii6giLCJwcm9kIjoi4oiPIiwiUHJvZHVjdCI6IuKIjyIsInByb2ZhbGFyIjoi4oyuIiwicHJvZmxpbmUiOiLijJIiLCJwcm9mc3VyZiI6IuKMkyIsInByb3AiOiLiiJ0iLCJQcm9wb3J0aW9uYWwiOiLiiJ0iLCJQcm9wb3J0aW9uIjoi4oi3IiwicHJvcHRvIjoi4oidIiwicHJzaW0iOiLiib4iLCJwcnVyZWwiOiLiirAiLCJQc2NyIjoi8J2SqyIsInBzY3IiOiLwnZOFIiwiUHNpIjoizqgiLCJwc2kiOiLPiCIsInB1bmNzcCI6IuKAiCIsIlFmciI6IvCdlJQiLCJxZnIiOiLwnZSuIiwicWludCI6IuKojCIsInFvcGYiOiLwnZWiIiwiUW9wZiI6IuKEmiIsInFwcmltZSI6IuKBlyIsIlFzY3IiOiLwnZKsIiwicXNjciI6IvCdk4YiLCJxdWF0ZXJuaW9ucyI6IuKEjSIsInF1YXRpbnQiOiLiqJYiLCJxdWVzdCI6Ij8iLCJxdWVzdGVxIjoi4omfIiwicXVvdCI6IlxcIiIsIlFVT1QiOiJcXCIiLCJyQWFyciI6IuKHmyIsInJhY2UiOiLiiL3MsSIsIlJhY3V0ZSI6IsWUIiwicmFjdXRlIjoixZUiLCJyYWRpYyI6IuKImiIsInJhZW1wdHl2Ijoi4qazIiwicmFuZyI6IuKfqSIsIlJhbmciOiLin6siLCJyYW5nZCI6IuKmkiIsInJhbmdlIjoi4qalIiwicmFuZ2xlIjoi4p+pIiwicmFxdW8iOiLCuyIsInJhcnJhcCI6IuKltSIsInJhcnJiIjoi4oelIiwicmFycmJmcyI6IuKkoCIsInJhcnJjIjoi4qSzIiwicmFyciI6IuKGkiIsIlJhcnIiOiLihqAiLCJyQXJyIjoi4oeSIiwicmFycmZzIjoi4qSeIiwicmFycmhrIjoi4oaqIiwicmFycmxwIjoi4oasIiwicmFycnBsIjoi4qWFIiwicmFycnNpbSI6IuKltCIsIlJhcnJ0bCI6IuKkliIsInJhcnJ0bCI6IuKGoyIsInJhcnJ3Ijoi4oadIiwicmF0YWlsIjoi4qSaIiwickF0YWlsIjoi4qScIiwicmF0aW8iOiLiiLYiLCJyYXRpb25hbHMiOiLihJoiLCJyYmFyciI6IuKkjSIsInJCYXJyIjoi4qSPIiwiUkJhcnIiOiLipJAiLCJyYmJyayI6IuKdsyIsInJicmFjZSI6In0iLCJyYnJhY2siOiJdIiwicmJya2UiOiLipowiLCJyYnJrc2xkIjoi4qaOIiwicmJya3NsdSI6IuKmkCIsIlJjYXJvbiI6IsWYIiwicmNhcm9uIjoixZkiLCJSY2VkaWwiOiLFliIsInJjZWRpbCI6IsWXIiwicmNlaWwiOiLijIkiLCJyY3ViIjoifSIsIlJjeSI6ItCgIiwicmN5Ijoi0YAiLCJyZGNhIjoi4qS3IiwicmRsZGhhciI6IuKlqSIsInJkcXVvIjoi4oCdIiwicmRxdW9yIjoi4oCdIiwicmRzaCI6IuKGsyIsInJlYWwiOiLihJwiLCJyZWFsaW5lIjoi4oSbIiwicmVhbHBhcnQiOiLihJwiLCJyZWFscyI6IuKEnSIsIlJlIjoi4oScIiwicmVjdCI6IuKWrSIsInJlZyI6IsKuIiwiUkVHIjoiwq4iLCJSZXZlcnNlRWxlbWVudCI6IuKIiyIsIlJldmVyc2VFcXVpbGlicml1bSI6IuKHiyIsIlJldmVyc2VVcEVxdWlsaWJyaXVtIjoi4qWvIiwicmZpc2h0Ijoi4qW9IiwicmZsb29yIjoi4oyLIiwicmZyIjoi8J2UryIsIlJmciI6IuKEnCIsInJIYXIiOiLipaQiLCJyaGFyZCI6IuKHgSIsInJoYXJ1Ijoi4oeAIiwicmhhcnVsIjoi4qWsIiwiUmhvIjoizqEiLCJyaG8iOiLPgSIsInJob3YiOiLPsSIsIlJpZ2h0QW5nbGVCcmFja2V0Ijoi4p+pIiwiUmlnaHRBcnJvd0JhciI6IuKHpSIsInJpZ2h0YXJyb3ciOiLihpIiLCJSaWdodEFycm93Ijoi4oaSIiwiUmlnaHRhcnJvdyI6IuKHkiIsIlJpZ2h0QXJyb3dMZWZ0QXJyb3ciOiLih4QiLCJyaWdodGFycm93dGFpbCI6IuKGoyIsIlJpZ2h0Q2VpbGluZyI6IuKMiSIsIlJpZ2h0RG91YmxlQnJhY2tldCI6IuKfpyIsIlJpZ2h0RG93blRlZVZlY3RvciI6IuKlnSIsIlJpZ2h0RG93blZlY3RvckJhciI6IuKllSIsIlJpZ2h0RG93blZlY3RvciI6IuKHgiIsIlJpZ2h0Rmxvb3IiOiLijIsiLCJyaWdodGhhcnBvb25kb3duIjoi4oeBIiwicmlnaHRoYXJwb29udXAiOiLih4AiLCJyaWdodGxlZnRhcnJvd3MiOiLih4QiLCJyaWdodGxlZnRoYXJwb29ucyI6IuKHjCIsInJpZ2h0cmlnaHRhcnJvd3MiOiLih4kiLCJyaWdodHNxdWlnYXJyb3ciOiLihp0iLCJSaWdodFRlZUFycm93Ijoi4oamIiwiUmlnaHRUZWUiOiLiiqIiLCJSaWdodFRlZVZlY3RvciI6IuKlmyIsInJpZ2h0dGhyZWV0aW1lcyI6IuKLjCIsIlJpZ2h0VHJpYW5nbGVCYXIiOiLip5AiLCJSaWdodFRyaWFuZ2xlIjoi4oqzIiwiUmlnaHRUcmlhbmdsZUVxdWFsIjoi4oq1IiwiUmlnaHRVcERvd25WZWN0b3IiOiLipY8iLCJSaWdodFVwVGVlVmVjdG9yIjoi4qWcIiwiUmlnaHRVcFZlY3RvckJhciI6IuKllCIsIlJpZ2h0VXBWZWN0b3IiOiLihr4iLCJSaWdodFZlY3RvckJhciI6IuKlkyIsIlJpZ2h0VmVjdG9yIjoi4oeAIiwicmluZyI6IsuaIiwicmlzaW5nZG90c2VxIjoi4omTIiwicmxhcnIiOiLih4QiLCJybGhhciI6IuKHjCIsInJsbSI6IuKAjyIsInJtb3VzdGFjaGUiOiLijrEiLCJybW91c3QiOiLijrEiLCJybm1pZCI6IuKrriIsInJvYW5nIjoi4p+tIiwicm9hcnIiOiLih74iLCJyb2JyayI6IuKfpyIsInJvcGFyIjoi4qaGIiwicm9wZiI6IvCdlaMiLCJSb3BmIjoi4oSdIiwicm9wbHVzIjoi4qiuIiwicm90aW1lcyI6IuKotSIsIlJvdW5kSW1wbGllcyI6IuKlsCIsInJwYXIiOiIpIiwicnBhcmd0Ijoi4qaUIiwicnBwb2xpbnQiOiLiqJIiLCJycmFyciI6IuKHiSIsIlJyaWdodGFycm93Ijoi4oebIiwicnNhcXVvIjoi4oC6IiwicnNjciI6IvCdk4ciLCJSc2NyIjoi4oSbIiwicnNoIjoi4oaxIiwiUnNoIjoi4oaxIiwicnNxYiI6Il0iLCJyc3F1byI6IuKAmSIsInJzcXVvciI6IuKAmSIsInJ0aHJlZSI6IuKLjCIsInJ0aW1lcyI6IuKLiiIsInJ0cmkiOiLilrkiLCJydHJpZSI6IuKKtSIsInJ0cmlmIjoi4pa4IiwicnRyaWx0cmkiOiLip44iLCJSdWxlRGVsYXllZCI6IuKntCIsInJ1bHVoYXIiOiLipagiLCJyeCI6IuKEniIsIlNhY3V0ZSI6IsWaIiwic2FjdXRlIjoixZsiLCJzYnF1byI6IuKAmiIsInNjYXAiOiLiqrgiLCJTY2Fyb24iOiLFoCIsInNjYXJvbiI6IsWhIiwiU2MiOiLiqrwiLCJzYyI6IuKJuyIsInNjY3VlIjoi4om9Iiwic2NlIjoi4qqwIiwic2NFIjoi4qq0IiwiU2NlZGlsIjoixZ4iLCJzY2VkaWwiOiLFnyIsIlNjaXJjIjoixZwiLCJzY2lyYyI6IsWdIiwic2NuYXAiOiLiqroiLCJzY25FIjoi4qq2Iiwic2Nuc2ltIjoi4oupIiwic2Nwb2xpbnQiOiLiqJMiLCJzY3NpbSI6IuKJvyIsIlNjeSI6ItChIiwic2N5Ijoi0YEiLCJzZG90YiI6IuKKoSIsInNkb3QiOiLii4UiLCJzZG90ZSI6IuKppiIsInNlYXJoayI6IuKkpSIsInNlYXJyIjoi4oaYIiwic2VBcnIiOiLih5giLCJzZWFycm93Ijoi4oaYIiwic2VjdCI6IsKnIiwic2VtaSI6IjsiLCJzZXN3YXIiOiLipKkiLCJzZXRtaW51cyI6IuKIliIsInNldG1uIjoi4oiWIiwic2V4dCI6IuKctiIsIlNmciI6IvCdlJYiLCJzZnIiOiLwnZSwIiwic2Zyb3duIjoi4oyiIiwic2hhcnAiOiLima8iLCJTSENIY3kiOiLQqSIsInNoY2hjeSI6ItGJIiwiU0hjeSI6ItCoIiwic2hjeSI6ItGIIiwiU2hvcnREb3duQXJyb3ciOiLihpMiLCJTaG9ydExlZnRBcnJvdyI6IuKGkCIsInNob3J0bWlkIjoi4oijIiwic2hvcnRwYXJhbGxlbCI6IuKIpSIsIlNob3J0UmlnaHRBcnJvdyI6IuKGkiIsIlNob3J0VXBBcnJvdyI6IuKGkSIsInNoeSI6IsKtIiwiU2lnbWEiOiLOoyIsInNpZ21hIjoiz4MiLCJzaWdtYWYiOiLPgiIsInNpZ21hdiI6Is+CIiwic2ltIjoi4oi8Iiwic2ltZG90Ijoi4qmqIiwic2ltZSI6IuKJgyIsInNpbWVxIjoi4omDIiwic2ltZyI6IuKqniIsInNpbWdFIjoi4qqgIiwic2ltbCI6IuKqnSIsInNpbWxFIjoi4qqfIiwic2ltbmUiOiLiiYYiLCJzaW1wbHVzIjoi4qikIiwic2ltcmFyciI6IuKlsiIsInNsYXJyIjoi4oaQIiwiU21hbGxDaXJjbGUiOiLiiJgiLCJzbWFsbHNldG1pbnVzIjoi4oiWIiwic21hc2hwIjoi4qizIiwic21lcGFyc2wiOiLip6QiLCJzbWlkIjoi4oijIiwic21pbGUiOiLijKMiLCJzbXQiOiLiqqoiLCJzbXRlIjoi4qqsIiwic210ZXMiOiLiqqzvuIAiLCJTT0ZUY3kiOiLQrCIsInNvZnRjeSI6ItGMIiwic29sYmFyIjoi4oy/Iiwic29sYiI6IuKnhCIsInNvbCI6Ii8iLCJTb3BmIjoi8J2ViiIsInNvcGYiOiLwnZWkIiwic3BhZGVzIjoi4pmgIiwic3BhZGVzdWl0Ijoi4pmgIiwic3BhciI6IuKIpSIsInNxY2FwIjoi4oqTIiwic3FjYXBzIjoi4oqT77iAIiwic3FjdXAiOiLiipQiLCJzcWN1cHMiOiLiipTvuIAiLCJTcXJ0Ijoi4oiaIiwic3FzdWIiOiLiio8iLCJzcXN1YmUiOiLiipEiLCJzcXN1YnNldCI6IuKKjyIsInNxc3Vic2V0ZXEiOiLiipEiLCJzcXN1cCI6IuKKkCIsInNxc3VwZSI6IuKKkiIsInNxc3Vwc2V0Ijoi4oqQIiwic3FzdXBzZXRlcSI6IuKKkiIsInNxdWFyZSI6IuKWoSIsIlNxdWFyZSI6IuKWoSIsIlNxdWFyZUludGVyc2VjdGlvbiI6IuKKkyIsIlNxdWFyZVN1YnNldCI6IuKKjyIsIlNxdWFyZVN1YnNldEVxdWFsIjoi4oqRIiwiU3F1YXJlU3VwZXJzZXQiOiLiipAiLCJTcXVhcmVTdXBlcnNldEVxdWFsIjoi4oqSIiwiU3F1YXJlVW5pb24iOiLiipQiLCJzcXVhcmYiOiLilqoiLCJzcXUiOiLilqEiLCJzcXVmIjoi4paqIiwic3JhcnIiOiLihpIiLCJTc2NyIjoi8J2SriIsInNzY3IiOiLwnZOIIiwic3NldG1uIjoi4oiWIiwic3NtaWxlIjoi4oyjIiwic3N0YXJmIjoi4ouGIiwiU3RhciI6IuKLhiIsInN0YXIiOiLimIYiLCJzdGFyZiI6IuKYhSIsInN0cmFpZ2h0ZXBzaWxvbiI6Is+1Iiwic3RyYWlnaHRwaGkiOiLPlSIsInN0cm5zIjoiwq8iLCJzdWIiOiLiioIiLCJTdWIiOiLii5AiLCJzdWJkb3QiOiLiqr0iLCJzdWJFIjoi4quFIiwic3ViZSI6IuKKhiIsInN1YmVkb3QiOiLiq4MiLCJzdWJtdWx0Ijoi4quBIiwic3VibkUiOiLiq4siLCJzdWJuZSI6IuKKiiIsInN1YnBsdXMiOiLiqr8iLCJzdWJyYXJyIjoi4qW5Iiwic3Vic2V0Ijoi4oqCIiwiU3Vic2V0Ijoi4ouQIiwic3Vic2V0ZXEiOiLiioYiLCJzdWJzZXRlcXEiOiLiq4UiLCJTdWJzZXRFcXVhbCI6IuKKhiIsInN1YnNldG5lcSI6IuKKiiIsInN1YnNldG5lcXEiOiLiq4siLCJzdWJzaW0iOiLiq4ciLCJzdWJzdWIiOiLiq5UiLCJzdWJzdXAiOiLiq5MiLCJzdWNjYXBwcm94Ijoi4qq4Iiwic3VjYyI6IuKJuyIsInN1Y2NjdXJseWVxIjoi4om9IiwiU3VjY2VlZHMiOiLiibsiLCJTdWNjZWVkc0VxdWFsIjoi4qqwIiwiU3VjY2VlZHNTbGFudEVxdWFsIjoi4om9IiwiU3VjY2VlZHNUaWxkZSI6IuKJvyIsInN1Y2NlcSI6IuKqsCIsInN1Y2NuYXBwcm94Ijoi4qq6Iiwic3VjY25lcXEiOiLiqrYiLCJzdWNjbnNpbSI6IuKLqSIsInN1Y2NzaW0iOiLiib8iLCJTdWNoVGhhdCI6IuKIiyIsInN1bSI6IuKIkSIsIlN1bSI6IuKIkSIsInN1bmciOiLimaoiLCJzdXAxIjoiwrkiLCJzdXAyIjoiwrIiLCJzdXAzIjoiwrMiLCJzdXAiOiLiioMiLCJTdXAiOiLii5EiLCJzdXBkb3QiOiLiqr4iLCJzdXBkc3ViIjoi4quYIiwic3VwRSI6IuKrhiIsInN1cGUiOiLiiociLCJzdXBlZG90Ijoi4quEIiwiU3VwZXJzZXQiOiLiioMiLCJTdXBlcnNldEVxdWFsIjoi4oqHIiwic3VwaHNvbCI6IuKfiSIsInN1cGhzdWIiOiLiq5ciLCJzdXBsYXJyIjoi4qW7Iiwic3VwbXVsdCI6IuKrgiIsInN1cG5FIjoi4quMIiwic3VwbmUiOiLiiosiLCJzdXBwbHVzIjoi4quAIiwic3Vwc2V0Ijoi4oqDIiwiU3Vwc2V0Ijoi4ouRIiwic3Vwc2V0ZXEiOiLiiociLCJzdXBzZXRlcXEiOiLiq4YiLCJzdXBzZXRuZXEiOiLiiosiLCJzdXBzZXRuZXFxIjoi4quMIiwic3Vwc2ltIjoi4quIIiwic3Vwc3ViIjoi4quUIiwic3Vwc3VwIjoi4quWIiwic3dhcmhrIjoi4qSmIiwic3dhcnIiOiLihpkiLCJzd0FyciI6IuKHmSIsInN3YXJyb3ciOiLihpkiLCJzd253YXIiOiLipKoiLCJzemxpZyI6IsOfIiwiVGFiIjoiXFx0IiwidGFyZ2V0Ijoi4oyWIiwiVGF1IjoizqQiLCJ0YXUiOiLPhCIsInRicmsiOiLijrQiLCJUY2Fyb24iOiLFpCIsInRjYXJvbiI6IsWlIiwiVGNlZGlsIjoixaIiLCJ0Y2VkaWwiOiLFoyIsIlRjeSI6ItCiIiwidGN5Ijoi0YIiLCJ0ZG90Ijoi4oObIiwidGVscmVjIjoi4oyVIiwiVGZyIjoi8J2UlyIsInRmciI6IvCdlLEiLCJ0aGVyZTQiOiLiiLQiLCJ0aGVyZWZvcmUiOiLiiLQiLCJUaGVyZWZvcmUiOiLiiLQiLCJUaGV0YSI6Is6YIiwidGhldGEiOiLOuCIsInRoZXRhc3ltIjoiz5EiLCJ0aGV0YXYiOiLPkSIsInRoaWNrYXBwcm94Ijoi4omIIiwidGhpY2tzaW0iOiLiiLwiLCJUaGlja1NwYWNlIjoi4oGf4oCKIiwiVGhpblNwYWNlIjoi4oCJIiwidGhpbnNwIjoi4oCJIiwidGhrYXAiOiLiiYgiLCJ0aGtzaW0iOiLiiLwiLCJUSE9STiI6IsOeIiwidGhvcm4iOiLDviIsInRpbGRlIjoiy5wiLCJUaWxkZSI6IuKIvCIsIlRpbGRlRXF1YWwiOiLiiYMiLCJUaWxkZUZ1bGxFcXVhbCI6IuKJhSIsIlRpbGRlVGlsZGUiOiLiiYgiLCJ0aW1lc2JhciI6IuKosSIsInRpbWVzYiI6IuKKoCIsInRpbWVzIjoiw5ciLCJ0aW1lc2QiOiLiqLAiLCJ0aW50Ijoi4oitIiwidG9lYSI6IuKkqCIsInRvcGJvdCI6IuKMtiIsInRvcGNpciI6IuKrsSIsInRvcCI6IuKKpCIsIlRvcGYiOiLwnZWLIiwidG9wZiI6IvCdlaUiLCJ0b3Bmb3JrIjoi4quaIiwidG9zYSI6IuKkqSIsInRwcmltZSI6IuKAtCIsInRyYWRlIjoi4oSiIiwiVFJBREUiOiLihKIiLCJ0cmlhbmdsZSI6IuKWtSIsInRyaWFuZ2xlZG93biI6IuKWvyIsInRyaWFuZ2xlbGVmdCI6IuKXgyIsInRyaWFuZ2xlbGVmdGVxIjoi4oq0IiwidHJpYW5nbGVxIjoi4omcIiwidHJpYW5nbGVyaWdodCI6IuKWuSIsInRyaWFuZ2xlcmlnaHRlcSI6IuKKtSIsInRyaWRvdCI6IuKXrCIsInRyaWUiOiLiiZwiLCJ0cmltaW51cyI6IuKouiIsIlRyaXBsZURvdCI6IuKDmyIsInRyaXBsdXMiOiLiqLkiLCJ0cmlzYiI6IuKnjSIsInRyaXRpbWUiOiLiqLsiLCJ0cnBleml1bSI6IuKPoiIsIlRzY3IiOiLwnZKvIiwidHNjciI6IvCdk4kiLCJUU2N5Ijoi0KYiLCJ0c2N5Ijoi0YYiLCJUU0hjeSI6ItCLIiwidHNoY3kiOiLRmyIsIlRzdHJvayI6IsWmIiwidHN0cm9rIjoixaciLCJ0d2l4dCI6IuKJrCIsInR3b2hlYWRsZWZ0YXJyb3ciOiLihp4iLCJ0d29oZWFkcmlnaHRhcnJvdyI6IuKGoCIsIlVhY3V0ZSI6IsOaIiwidWFjdXRlIjoiw7oiLCJ1YXJyIjoi4oaRIiwiVWFyciI6IuKGnyIsInVBcnIiOiLih5EiLCJVYXJyb2NpciI6IuKliSIsIlVicmN5Ijoi0I4iLCJ1YnJjeSI6ItGeIiwiVWJyZXZlIjoixawiLCJ1YnJldmUiOiLFrSIsIlVjaXJjIjoiw5siLCJ1Y2lyYyI6IsO7IiwiVWN5Ijoi0KMiLCJ1Y3kiOiLRgyIsInVkYXJyIjoi4oeFIiwiVWRibGFjIjoixbAiLCJ1ZGJsYWMiOiLFsSIsInVkaGFyIjoi4qWuIiwidWZpc2h0Ijoi4qW+IiwiVWZyIjoi8J2UmCIsInVmciI6IvCdlLIiLCJVZ3JhdmUiOiLDmSIsInVncmF2ZSI6IsO5IiwidUhhciI6IuKloyIsInVoYXJsIjoi4oa/IiwidWhhcnIiOiLihr4iLCJ1aGJsayI6IuKWgCIsInVsY29ybiI6IuKMnCIsInVsY29ybmVyIjoi4oycIiwidWxjcm9wIjoi4oyPIiwidWx0cmkiOiLil7giLCJVbWFjciI6IsWqIiwidW1hY3IiOiLFqyIsInVtbCI6IsKoIiwiVW5kZXJCYXIiOiJfIiwiVW5kZXJCcmFjZSI6IuKPnyIsIlVuZGVyQnJhY2tldCI6IuKOtSIsIlVuZGVyUGFyZW50aGVzaXMiOiLij50iLCJVbmlvbiI6IuKLgyIsIlVuaW9uUGx1cyI6IuKKjiIsIlVvZ29uIjoixbIiLCJ1b2dvbiI6IsWzIiwiVW9wZiI6IvCdlYwiLCJ1b3BmIjoi8J2VpiIsIlVwQXJyb3dCYXIiOiLipJIiLCJ1cGFycm93Ijoi4oaRIiwiVXBBcnJvdyI6IuKGkSIsIlVwYXJyb3ciOiLih5EiLCJVcEFycm93RG93bkFycm93Ijoi4oeFIiwidXBkb3duYXJyb3ciOiLihpUiLCJVcERvd25BcnJvdyI6IuKGlSIsIlVwZG93bmFycm93Ijoi4oeVIiwiVXBFcXVpbGlicml1bSI6IuKlriIsInVwaGFycG9vbmxlZnQiOiLihr8iLCJ1cGhhcnBvb25yaWdodCI6IuKGviIsInVwbHVzIjoi4oqOIiwiVXBwZXJMZWZ0QXJyb3ciOiLihpYiLCJVcHBlclJpZ2h0QXJyb3ciOiLihpciLCJ1cHNpIjoiz4UiLCJVcHNpIjoiz5IiLCJ1cHNpaCI6Is+SIiwiVXBzaWxvbiI6Is6lIiwidXBzaWxvbiI6Is+FIiwiVXBUZWVBcnJvdyI6IuKGpSIsIlVwVGVlIjoi4oqlIiwidXB1cGFycm93cyI6IuKHiCIsInVyY29ybiI6IuKMnSIsInVyY29ybmVyIjoi4oydIiwidXJjcm9wIjoi4oyOIiwiVXJpbmciOiLFriIsInVyaW5nIjoixa8iLCJ1cnRyaSI6IuKXuSIsIlVzY3IiOiLwnZKwIiwidXNjciI6IvCdk4oiLCJ1dGRvdCI6IuKLsCIsIlV0aWxkZSI6IsWoIiwidXRpbGRlIjoixakiLCJ1dHJpIjoi4pa1IiwidXRyaWYiOiLilrQiLCJ1dWFyciI6IuKHiCIsIlV1bWwiOiLDnCIsInV1bWwiOiLDvCIsInV3YW5nbGUiOiLipqciLCJ2YW5ncnQiOiLippwiLCJ2YXJlcHNpbG9uIjoiz7UiLCJ2YXJrYXBwYSI6Is+wIiwidmFybm90aGluZyI6IuKIhSIsInZhcnBoaSI6Is+VIiwidmFycGkiOiLPliIsInZhcnByb3B0byI6IuKInSIsInZhcnIiOiLihpUiLCJ2QXJyIjoi4oeVIiwidmFycmhvIjoiz7EiLCJ2YXJzaWdtYSI6Is+CIiwidmFyc3Vic2V0bmVxIjoi4oqK77iAIiwidmFyc3Vic2V0bmVxcSI6IuKri++4gCIsInZhcnN1cHNldG5lcSI6IuKKi++4gCIsInZhcnN1cHNldG5lcXEiOiLiq4zvuIAiLCJ2YXJ0aGV0YSI6Is+RIiwidmFydHJpYW5nbGVsZWZ0Ijoi4oqyIiwidmFydHJpYW5nbGVyaWdodCI6IuKKsyIsInZCYXIiOiLiq6giLCJWYmFyIjoi4qurIiwidkJhcnYiOiLiq6kiLCJWY3kiOiLQkiIsInZjeSI6ItCyIiwidmRhc2giOiLiiqIiLCJ2RGFzaCI6IuKKqCIsIlZkYXNoIjoi4oqpIiwiVkRhc2giOiLiiqsiLCJWZGFzaGwiOiLiq6YiLCJ2ZWViYXIiOiLiirsiLCJ2ZWUiOiLiiKgiLCJWZWUiOiLii4EiLCJ2ZWVlcSI6IuKJmiIsInZlbGxpcCI6IuKLriIsInZlcmJhciI6InwiLCJWZXJiYXIiOiLigJYiLCJ2ZXJ0IjoifCIsIlZlcnQiOiLigJYiLCJWZXJ0aWNhbEJhciI6IuKIoyIsIlZlcnRpY2FsTGluZSI6InwiLCJWZXJ0aWNhbFNlcGFyYXRvciI6IuKdmCIsIlZlcnRpY2FsVGlsZGUiOiLiiYAiLCJWZXJ5VGhpblNwYWNlIjoi4oCKIiwiVmZyIjoi8J2UmSIsInZmciI6IvCdlLMiLCJ2bHRyaSI6IuKKsiIsInZuc3ViIjoi4oqC4oOSIiwidm5zdXAiOiLiioPig5IiLCJWb3BmIjoi8J2VjSIsInZvcGYiOiLwnZWnIiwidnByb3AiOiLiiJ0iLCJ2cnRyaSI6IuKKsyIsIlZzY3IiOiLwnZKxIiwidnNjciI6IvCdk4siLCJ2c3VibkUiOiLiq4vvuIAiLCJ2c3VibmUiOiLiiorvuIAiLCJ2c3VwbkUiOiLiq4zvuIAiLCJ2c3VwbmUiOiLiiovvuIAiLCJWdmRhc2giOiLiiqoiLCJ2emlnemFnIjoi4qaaIiwiV2NpcmMiOiLFtCIsIndjaXJjIjoixbUiLCJ3ZWRiYXIiOiLiqZ8iLCJ3ZWRnZSI6IuKIpyIsIldlZGdlIjoi4ouAIiwid2VkZ2VxIjoi4omZIiwid2VpZXJwIjoi4oSYIiwiV2ZyIjoi8J2UmiIsIndmciI6IvCdlLQiLCJXb3BmIjoi8J2VjiIsIndvcGYiOiLwnZWoIiwid3AiOiLihJgiLCJ3ciI6IuKJgCIsIndyZWF0aCI6IuKJgCIsIldzY3IiOiLwnZKyIiwid3NjciI6IvCdk4wiLCJ4Y2FwIjoi4ouCIiwieGNpcmMiOiLil68iLCJ4Y3VwIjoi4ouDIiwieGR0cmkiOiLilr0iLCJYZnIiOiLwnZSbIiwieGZyIjoi8J2UtSIsInhoYXJyIjoi4p+3IiwieGhBcnIiOiLin7oiLCJYaSI6Is6eIiwieGkiOiLOviIsInhsYXJyIjoi4p+1IiwieGxBcnIiOiLin7giLCJ4bWFwIjoi4p+8IiwieG5pcyI6IuKLuyIsInhvZG90Ijoi4qiAIiwiWG9wZiI6IvCdlY8iLCJ4b3BmIjoi8J2VqSIsInhvcGx1cyI6IuKogSIsInhvdGltZSI6IuKogiIsInhyYXJyIjoi4p+2IiwieHJBcnIiOiLin7kiLCJYc2NyIjoi8J2SsyIsInhzY3IiOiLwnZONIiwieHNxY3VwIjoi4qiGIiwieHVwbHVzIjoi4qiEIiwieHV0cmkiOiLilrMiLCJ4dmVlIjoi4ouBIiwieHdlZGdlIjoi4ouAIiwiWWFjdXRlIjoiw50iLCJ5YWN1dGUiOiLDvSIsIllBY3kiOiLQryIsInlhY3kiOiLRjyIsIlljaXJjIjoixbYiLCJ5Y2lyYyI6IsW3IiwiWWN5Ijoi0KsiLCJ5Y3kiOiLRiyIsInllbiI6IsKlIiwiWWZyIjoi8J2UnCIsInlmciI6IvCdlLYiLCJZSWN5Ijoi0IciLCJ5aWN5Ijoi0ZciLCJZb3BmIjoi8J2VkCIsInlvcGYiOiLwnZWqIiwiWXNjciI6IvCdkrQiLCJ5c2NyIjoi8J2TjiIsIllVY3kiOiLQriIsInl1Y3kiOiLRjiIsInl1bWwiOiLDvyIsIll1bWwiOiLFuCIsIlphY3V0ZSI6IsW5IiwiemFjdXRlIjoixboiLCJaY2Fyb24iOiLFvSIsInpjYXJvbiI6IsW+IiwiWmN5Ijoi0JciLCJ6Y3kiOiLQtyIsIlpkb3QiOiLFuyIsInpkb3QiOiLFvCIsInplZXRyZiI6IuKEqCIsIlplcm9XaWR0aFNwYWNlIjoi4oCLIiwiWmV0YSI6Is6WIiwiemV0YSI6Is62IiwiemZyIjoi8J2UtyIsIlpmciI6IuKEqCIsIlpIY3kiOiLQliIsInpoY3kiOiLQtiIsInppZ3JhcnIiOiLih50iLCJ6b3BmIjoi8J2VqyIsIlpvcGYiOiLihKQiLCJac2NyIjoi8J2StSIsInpzY3IiOiLwnZOPIiwiendqIjoi4oCNIiwienduaiI6IuKAjCJ9Jyl9LGZ1bmN0aW9uKGgpe2guZXhwb3J0cz1KU09OLnBhcnNlKCd7IkFhY3V0ZSI6IsOBIiwiYWFjdXRlIjoiw6EiLCJBY2lyYyI6IsOCIiwiYWNpcmMiOiLDoiIsImFjdXRlIjoiwrQiLCJBRWxpZyI6IsOGIiwiYWVsaWciOiLDpiIsIkFncmF2ZSI6IsOAIiwiYWdyYXZlIjoiw6AiLCJhbXAiOiImIiwiQU1QIjoiJiIsIkFyaW5nIjoiw4UiLCJhcmluZyI6IsOlIiwiQXRpbGRlIjoiw4MiLCJhdGlsZGUiOiLDoyIsIkF1bWwiOiLDhCIsImF1bWwiOiLDpCIsImJydmJhciI6IsKmIiwiQ2NlZGlsIjoiw4ciLCJjY2VkaWwiOiLDpyIsImNlZGlsIjoiwrgiLCJjZW50IjoiwqIiLCJjb3B5IjoiwqkiLCJDT1BZIjoiwqkiLCJjdXJyZW4iOiLCpCIsImRlZyI6IsKwIiwiZGl2aWRlIjoiw7ciLCJFYWN1dGUiOiLDiSIsImVhY3V0ZSI6IsOpIiwiRWNpcmMiOiLDiiIsImVjaXJjIjoiw6oiLCJFZ3JhdmUiOiLDiCIsImVncmF2ZSI6IsOoIiwiRVRIIjoiw5AiLCJldGgiOiLDsCIsIkV1bWwiOiLDiyIsImV1bWwiOiLDqyIsImZyYWMxMiI6IsK9IiwiZnJhYzE0IjoiwrwiLCJmcmFjMzQiOiLCviIsImd0IjoiPiIsIkdUIjoiPiIsIklhY3V0ZSI6IsONIiwiaWFjdXRlIjoiw60iLCJJY2lyYyI6IsOOIiwiaWNpcmMiOiLDriIsImlleGNsIjoiwqEiLCJJZ3JhdmUiOiLDjCIsImlncmF2ZSI6IsOsIiwiaXF1ZXN0Ijoiwr8iLCJJdW1sIjoiw48iLCJpdW1sIjoiw68iLCJsYXF1byI6IsKrIiwibHQiOiI8IiwiTFQiOiI8IiwibWFjciI6IsKvIiwibWljcm8iOiLCtSIsIm1pZGRvdCI6IsK3IiwibmJzcCI6IsKgIiwibm90IjoiwqwiLCJOdGlsZGUiOiLDkSIsIm50aWxkZSI6IsOxIiwiT2FjdXRlIjoiw5MiLCJvYWN1dGUiOiLDsyIsIk9jaXJjIjoiw5QiLCJvY2lyYyI6IsO0IiwiT2dyYXZlIjoiw5IiLCJvZ3JhdmUiOiLDsiIsIm9yZGYiOiLCqiIsIm9yZG0iOiLCuiIsIk9zbGFzaCI6IsOYIiwib3NsYXNoIjoiw7giLCJPdGlsZGUiOiLDlSIsIm90aWxkZSI6IsO1IiwiT3VtbCI6IsOWIiwib3VtbCI6IsO2IiwicGFyYSI6IsK2IiwicGx1c21uIjoiwrEiLCJwb3VuZCI6IsKjIiwicXVvdCI6IlxcIiIsIlFVT1QiOiJcXCIiLCJyYXF1byI6IsK7IiwicmVnIjoiwq4iLCJSRUciOiLCriIsInNlY3QiOiLCpyIsInNoeSI6IsKtIiwic3VwMSI6IsK5Iiwic3VwMiI6IsKyIiwic3VwMyI6IsKzIiwic3psaWciOiLDnyIsIlRIT1JOIjoiw54iLCJ0aG9ybiI6IsO+IiwidGltZXMiOiLDlyIsIlVhY3V0ZSI6IsOaIiwidWFjdXRlIjoiw7oiLCJVY2lyYyI6IsObIiwidWNpcmMiOiLDuyIsIlVncmF2ZSI6IsOZIiwidWdyYXZlIjoiw7kiLCJ1bWwiOiLCqCIsIlV1bWwiOiLDnCIsInV1bWwiOiLDvCIsIllhY3V0ZSI6IsOdIiwieWFjdXRlIjoiw70iLCJ5ZW4iOiLCpSIsInl1bWwiOiLDvyJ9Jyl9LGZ1bmN0aW9uKGgpe2guZXhwb3J0cz1KU09OLnBhcnNlKGB7ImFtcCI6IiYiLCJhcG9zIjoiJyIsImd0IjoiPiIsImx0IjoiPCIsInF1b3QiOiJcXCIifWApfSxmdW5jdGlvbihoLGUsdCl7dmFyIHI9dGhpcyYmdGhpcy5fX2ltcG9ydERlZmF1bHR8fGZ1bmN0aW9uKGcpe3JldHVybiBnJiZnLl9fZXNNb2R1bGU/Zzp7ZGVmYXVsdDpnfX07T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pO3ZhciBuPXIodCgyNjUpKTtmdW5jdGlvbiBkKGcpe2lmKGc+PTU1Mjk2JiZnPD01NzM0M3x8Zz4xMTE0MTExKXJldHVybiLvv70iO2cgaW4gbi5kZWZhdWx0JiYoZz1uLmRlZmF1bHRbZ10pO3ZhciB1PSIiO3JldHVybiBnPjY1NTM1JiYoZy09NjU1MzYsdSs9U3RyaW5nLmZyb21DaGFyQ29kZShnPj4+MTAmMTAyM3w1NTI5NiksZz01NjMyMHxnJjEwMjMpLHUrPVN0cmluZy5mcm9tQ2hhckNvZGUoZyksdX1lLmRlZmF1bHQ9ZH0sZnVuY3Rpb24oaCl7aC5leHBvcnRzPUpTT04ucGFyc2UoJ3siMCI6NjU1MzMsIjEyOCI6ODM2NCwiMTMwIjo4MjE4LCIxMzEiOjQwMiwiMTMyIjo4MjIyLCIxMzMiOjgyMzAsIjEzNCI6ODIyNCwiMTM1Ijo4MjI1LCIxMzYiOjcxMCwiMTM3Ijo4MjQwLCIxMzgiOjM1MiwiMTM5Ijo4MjQ5LCIxNDAiOjMzOCwiMTQyIjozODEsIjE0NSI6ODIxNiwiMTQ2Ijo4MjE3LCIxNDciOjgyMjAsIjE0OCI6ODIyMSwiMTQ5Ijo4MjI2LCIxNTAiOjgyMTEsIjE1MSI6ODIxMiwiMTUyIjo3MzIsIjE1MyI6ODQ4MiwiMTU0IjozNTMsIjE1NSI6ODI1MCwiMTU2IjozMzksIjE1OCI6MzgyLCIxNTkiOjM3Nn0nKX0sZnVuY3Rpb24oaCxlLHQpe3ZhciByPXRoaXMmJnRoaXMuX19pbXBvcnREZWZhdWx0fHxmdW5jdGlvbihNKXtyZXR1cm4gTSYmTS5fX2VzTW9kdWxlP006e2RlZmF1bHQ6TX19O09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxlLmVzY2FwZT1lLmVuY29kZUhUTUw9ZS5lbmNvZGVYTUw9dm9pZCAwO3ZhciBuPXIodCgyNjMpKSxkPXgobi5kZWZhdWx0KSxnPWMoZCk7ZS5lbmNvZGVYTUw9YihkLGcpO3ZhciB1PXIodCgyNjEpKSxvPXgodS5kZWZhdWx0KSxmPWMobyk7ZS5lbmNvZGVIVE1MPWIobyxmKTtmdW5jdGlvbiB4KE0pe3JldHVybiBPYmplY3Qua2V5cyhNKS5zb3J0KCkucmVkdWNlKGZ1bmN0aW9uKGksYSl7cmV0dXJuIGlbTVthXV09IiYiK2ErIjsiLGl9LHt9KX1mdW5jdGlvbiBjKE0pe2Zvcih2YXIgaT1bXSxhPVtdLHM9MCxsPU9iamVjdC5rZXlzKE0pO3M8bC5sZW5ndGg7cysrKXt2YXIgTz1sW3NdO08ubGVuZ3RoPT09MT9pLnB1c2goIlxcIitPKTphLnB1c2goTyl9aS5zb3J0KCk7Zm9yKHZhciBBPTA7QTxpLmxlbmd0aC0xO0ErKyl7Zm9yKHZhciBSPUE7UjxpLmxlbmd0aC0xJiZpW1JdLmNoYXJDb2RlQXQoMSkrMT09PWlbUisxXS5jaGFyQ29kZUF0KDEpOylSKz0xO3ZhciBJPTErUi1BO0k8M3x8aS5zcGxpY2UoQSxJLGlbQV0rIi0iK2lbUl0pfXJldHVybiBhLnVuc2hpZnQoIlsiK2kuam9pbigiIikrIl0iKSxuZXcgUmVnRXhwKGEuam9pbigifCIpLCJnIil9dmFyIHY9Lyg/OltceDgwLVx1RDdGRlx1RTAwMC1cdUZGRkZdfFtcdUQ4MDAtXHVEQkZGXVtcdURDMDAtXHVERkZGXXxbXHVEODAwLVx1REJGRl0oPyFbXHVEQzAwLVx1REZGRl0pfCg/OlteXHVEODAwLVx1REJGRl18XilbXHVEQzAwLVx1REZGRl0pL2c7ZnVuY3Rpb24gcChNKXtyZXR1cm4iJiN4IitNLmNvZGVQb2ludEF0KDApLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpKyI7In1mdW5jdGlvbiBiKE0saSl7cmV0dXJuIGZ1bmN0aW9uKGEpe3JldHVybiBhLnJlcGxhY2UoaSxmdW5jdGlvbihzKXtyZXR1cm4gTVtzXX0pLnJlcGxhY2UodixwKX19dmFyIEU9YyhkKTtmdW5jdGlvbiB5KE0pe3JldHVybiBNLnJlcGxhY2UoRSxwKS5yZXBsYWNlKHYscCl9ZS5lc2NhcGU9eX0sZnVuY3Rpb24oaCl7aC5leHBvcnRzPUpTT04ucGFyc2UoJ3siZWxlbWVudE5hbWVzIjp7ImFsdGdseXBoIjoiYWx0R2x5cGgiLCJhbHRnbHlwaGRlZiI6ImFsdEdseXBoRGVmIiwiYWx0Z2x5cGhpdGVtIjoiYWx0R2x5cGhJdGVtIiwiYW5pbWF0ZWNvbG9yIjoiYW5pbWF0ZUNvbG9yIiwiYW5pbWF0ZW1vdGlvbiI6ImFuaW1hdGVNb3Rpb24iLCJhbmltYXRldHJhbnNmb3JtIjoiYW5pbWF0ZVRyYW5zZm9ybSIsImNsaXBwYXRoIjoiY2xpcFBhdGgiLCJmZWJsZW5kIjoiZmVCbGVuZCIsImZlY29sb3JtYXRyaXgiOiJmZUNvbG9yTWF0cml4IiwiZmVjb21wb25lbnR0cmFuc2ZlciI6ImZlQ29tcG9uZW50VHJhbnNmZXIiLCJmZWNvbXBvc2l0ZSI6ImZlQ29tcG9zaXRlIiwiZmVjb252b2x2ZW1hdHJpeCI6ImZlQ29udm9sdmVNYXRyaXgiLCJmZWRpZmZ1c2VsaWdodGluZyI6ImZlRGlmZnVzZUxpZ2h0aW5nIiwiZmVkaXNwbGFjZW1lbnRtYXAiOiJmZURpc3BsYWNlbWVudE1hcCIsImZlZGlzdGFudGxpZ2h0IjoiZmVEaXN0YW50TGlnaHQiLCJmZWRyb3BzaGFkb3ciOiJmZURyb3BTaGFkb3ciLCJmZWZsb29kIjoiZmVGbG9vZCIsImZlZnVuY2EiOiJmZUZ1bmNBIiwiZmVmdW5jYiI6ImZlRnVuY0IiLCJmZWZ1bmNnIjoiZmVGdW5jRyIsImZlZnVuY3IiOiJmZUZ1bmNSIiwiZmVnYXVzc2lhbmJsdXIiOiJmZUdhdXNzaWFuQmx1ciIsImZlaW1hZ2UiOiJmZUltYWdlIiwiZmVtZXJnZSI6ImZlTWVyZ2UiLCJmZW1lcmdlbm9kZSI6ImZlTWVyZ2VOb2RlIiwiZmVtb3JwaG9sb2d5IjoiZmVNb3JwaG9sb2d5IiwiZmVvZmZzZXQiOiJmZU9mZnNldCIsImZlcG9pbnRsaWdodCI6ImZlUG9pbnRMaWdodCIsImZlc3BlY3VsYXJsaWdodGluZyI6ImZlU3BlY3VsYXJMaWdodGluZyIsImZlc3BvdGxpZ2h0IjoiZmVTcG90TGlnaHQiLCJmZXRpbGUiOiJmZVRpbGUiLCJmZXR1cmJ1bGVuY2UiOiJmZVR1cmJ1bGVuY2UiLCJmb3JlaWdub2JqZWN0IjoiZm9yZWlnbk9iamVjdCIsImdseXBocmVmIjoiZ2x5cGhSZWYiLCJsaW5lYXJncmFkaWVudCI6ImxpbmVhckdyYWRpZW50IiwicmFkaWFsZ3JhZGllbnQiOiJyYWRpYWxHcmFkaWVudCIsInRleHRwYXRoIjoidGV4dFBhdGgifSwiYXR0cmlidXRlTmFtZXMiOnsiZGVmaW5pdGlvbnVybCI6ImRlZmluaXRpb25VUkwiLCJhdHRyaWJ1dGVuYW1lIjoiYXR0cmlidXRlTmFtZSIsImF0dHJpYnV0ZXR5cGUiOiJhdHRyaWJ1dGVUeXBlIiwiYmFzZWZyZXF1ZW5jeSI6ImJhc2VGcmVxdWVuY3kiLCJiYXNlcHJvZmlsZSI6ImJhc2VQcm9maWxlIiwiY2FsY21vZGUiOiJjYWxjTW9kZSIsImNsaXBwYXRodW5pdHMiOiJjbGlwUGF0aFVuaXRzIiwiZGlmZnVzZWNvbnN0YW50IjoiZGlmZnVzZUNvbnN0YW50IiwiZWRnZW1vZGUiOiJlZGdlTW9kZSIsImZpbHRlcnVuaXRzIjoiZmlsdGVyVW5pdHMiLCJnbHlwaHJlZiI6ImdseXBoUmVmIiwiZ3JhZGllbnR0cmFuc2Zvcm0iOiJncmFkaWVudFRyYW5zZm9ybSIsImdyYWRpZW50dW5pdHMiOiJncmFkaWVudFVuaXRzIiwia2VybmVsbWF0cml4Ijoia2VybmVsTWF0cml4Iiwia2VybmVsdW5pdGxlbmd0aCI6Imtlcm5lbFVuaXRMZW5ndGgiLCJrZXlwb2ludHMiOiJrZXlQb2ludHMiLCJrZXlzcGxpbmVzIjoia2V5U3BsaW5lcyIsImtleXRpbWVzIjoia2V5VGltZXMiLCJsZW5ndGhhZGp1c3QiOiJsZW5ndGhBZGp1c3QiLCJsaW1pdGluZ2NvbmVhbmdsZSI6ImxpbWl0aW5nQ29uZUFuZ2xlIiwibWFya2VyaGVpZ2h0IjoibWFya2VySGVpZ2h0IiwibWFya2VydW5pdHMiOiJtYXJrZXJVbml0cyIsIm1hcmtlcndpZHRoIjoibWFya2VyV2lkdGgiLCJtYXNrY29udGVudHVuaXRzIjoibWFza0NvbnRlbnRVbml0cyIsIm1hc2t1bml0cyI6Im1hc2tVbml0cyIsIm51bW9jdGF2ZXMiOiJudW1PY3RhdmVzIiwicGF0aGxlbmd0aCI6InBhdGhMZW5ndGgiLCJwYXR0ZXJuY29udGVudHVuaXRzIjoicGF0dGVybkNvbnRlbnRVbml0cyIsInBhdHRlcm50cmFuc2Zvcm0iOiJwYXR0ZXJuVHJhbnNmb3JtIiwicGF0dGVybnVuaXRzIjoicGF0dGVyblVuaXRzIiwicG9pbnRzYXR4IjoicG9pbnRzQXRYIiwicG9pbnRzYXR5IjoicG9pbnRzQXRZIiwicG9pbnRzYXR6IjoicG9pbnRzQXRaIiwicHJlc2VydmVhbHBoYSI6InByZXNlcnZlQWxwaGEiLCJwcmVzZXJ2ZWFzcGVjdHJhdGlvIjoicHJlc2VydmVBc3BlY3RSYXRpbyIsInByaW1pdGl2ZXVuaXRzIjoicHJpbWl0aXZlVW5pdHMiLCJyZWZ4IjoicmVmWCIsInJlZnkiOiJyZWZZIiwicmVwZWF0Y291bnQiOiJyZXBlYXRDb3VudCIsInJlcGVhdGR1ciI6InJlcGVhdER1ciIsInJlcXVpcmVkZXh0ZW5zaW9ucyI6InJlcXVpcmVkRXh0ZW5zaW9ucyIsInJlcXVpcmVkZmVhdHVyZXMiOiJyZXF1aXJlZEZlYXR1cmVzIiwic3BlY3VsYXJjb25zdGFudCI6InNwZWN1bGFyQ29uc3RhbnQiLCJzcGVjdWxhcmV4cG9uZW50Ijoic3BlY3VsYXJFeHBvbmVudCIsInNwcmVhZG1ldGhvZCI6InNwcmVhZE1ldGhvZCIsInN0YXJ0b2Zmc2V0Ijoic3RhcnRPZmZzZXQiLCJzdGRkZXZpYXRpb24iOiJzdGREZXZpYXRpb24iLCJzdGl0Y2h0aWxlcyI6InN0aXRjaFRpbGVzIiwic3VyZmFjZXNjYWxlIjoic3VyZmFjZVNjYWxlIiwic3lzdGVtbGFuZ3VhZ2UiOiJzeXN0ZW1MYW5ndWFnZSIsInRhYmxldmFsdWVzIjoidGFibGVWYWx1ZXMiLCJ0YXJnZXR4IjoidGFyZ2V0WCIsInRhcmdldHkiOiJ0YXJnZXRZIiwidGV4dGxlbmd0aCI6InRleHRMZW5ndGgiLCJ2aWV3Ym94Ijoidmlld0JveCIsInZpZXd0YXJnZXQiOiJ2aWV3VGFyZ2V0IiwieGNoYW5uZWxzZWxlY3RvciI6InhDaGFubmVsU2VsZWN0b3IiLCJ5Y2hhbm5lbHNlbGVjdG9yIjoieUNoYW5uZWxTZWxlY3RvciIsInpvb21hbmRwYW4iOiJ6b29tQW5kUGFuIn19Jyl9LGZ1bmN0aW9uKGgsZSl7dmFyIHQ9ZS5nZXRDaGlsZHJlbj1mdW5jdGlvbihuKXtyZXR1cm4gbi5jaGlsZHJlbn0scj1lLmdldFBhcmVudD1mdW5jdGlvbihuKXtyZXR1cm4gbi5wYXJlbnR9O2UuZ2V0U2libGluZ3M9ZnVuY3Rpb24obil7dmFyIGQ9cihuKTtyZXR1cm4gZD90KGQpOltuXX0sZS5nZXRBdHRyaWJ1dGVWYWx1ZT1mdW5jdGlvbihuLGQpe3JldHVybiBuLmF0dHJpYnMmJm4uYXR0cmlic1tkXX0sZS5oYXNBdHRyaWI9ZnVuY3Rpb24obixkKXtyZXR1cm4hIW4uYXR0cmlicyYmaGFzT3duUHJvcGVydHkuY2FsbChuLmF0dHJpYnMsZCl9LGUuZ2V0TmFtZT1mdW5jdGlvbihuKXtyZXR1cm4gbi5uYW1lfX0sZnVuY3Rpb24oaCxlKXtlLnJlbW92ZUVsZW1lbnQ9ZnVuY3Rpb24odCl7aWYodC5wcmV2JiYodC5wcmV2Lm5leHQ9dC5uZXh0KSx0Lm5leHQmJih0Lm5leHQucHJldj10LnByZXYpLHQucGFyZW50KXt2YXIgcj10LnBhcmVudC5jaGlsZHJlbjtyLnNwbGljZShyLmxhc3RJbmRleE9mKHQpLDEpfX0sZS5yZXBsYWNlRWxlbWVudD1mdW5jdGlvbih0LHIpe3ZhciBuPXIucHJldj10LnByZXY7biYmKG4ubmV4dD1yKTt2YXIgZD1yLm5leHQ9dC5uZXh0O2QmJihkLnByZXY9cik7dmFyIGc9ci5wYXJlbnQ9dC5wYXJlbnQ7aWYoZyl7dmFyIHU9Zy5jaGlsZHJlbjt1W3UubGFzdEluZGV4T2YodCldPXJ9fSxlLmFwcGVuZENoaWxkPWZ1bmN0aW9uKHQscil7aWYoci5wYXJlbnQ9dCx0LmNoaWxkcmVuLnB1c2gocikhPT0xKXt2YXIgbj10LmNoaWxkcmVuW3QuY2hpbGRyZW4ubGVuZ3RoLTJdO24ubmV4dD1yLHIucHJldj1uLHIubmV4dD1udWxsfX0sZS5hcHBlbmQ9ZnVuY3Rpb24odCxyKXt2YXIgbj10LnBhcmVudCxkPXQubmV4dDtpZihyLm5leHQ9ZCxyLnByZXY9dCx0Lm5leHQ9cixyLnBhcmVudD1uLGQpe2lmKGQucHJldj1yLG4pe3ZhciBnPW4uY2hpbGRyZW47Zy5zcGxpY2UoZy5sYXN0SW5kZXhPZihkKSwwLHIpfX1lbHNlIG4mJm4uY2hpbGRyZW4ucHVzaChyKX0sZS5wcmVwZW5kPWZ1bmN0aW9uKHQscil7dmFyIG49dC5wYXJlbnQ7aWYobil7dmFyIGQ9bi5jaGlsZHJlbjtkLnNwbGljZShkLmxhc3RJbmRleE9mKHQpLDAscil9dC5wcmV2JiYodC5wcmV2Lm5leHQ9ciksci5wYXJlbnQ9bixyLnByZXY9dC5wcmV2LHIubmV4dD10LHQucHJldj1yfX0sZnVuY3Rpb24oaCxlLHQpe3ZhciByPXQoMjU2KS5pc1RhZztoLmV4cG9ydHM9e2ZpbHRlcjpuLGZpbmQ6ZCxmaW5kT25lQ2hpbGQ6ZyxmaW5kT25lOnUsZXhpc3RzT25lOm8sZmluZEFsbDpmfTtmdW5jdGlvbiBuKHgsYyx2LHApe3JldHVybiBBcnJheS5pc0FycmF5KGMpfHwoYz1bY10pLCh0eXBlb2YgcCE9Im51bWJlciJ8fCFpc0Zpbml0ZShwKSkmJihwPTEvMCksZCh4LGMsdiE9PSExLHApfWZ1bmN0aW9uIGQoeCxjLHYscCl7Zm9yKHZhciBiPVtdLEUseT0wLE09Yy5sZW5ndGg7eTxNJiYhKHgoY1t5XSkmJihiLnB1c2goY1t5XSksLS1wPD0wKXx8KEU9Y1t5XS5jaGlsZHJlbix2JiZFJiZFLmxlbmd0aD4wJiYoRT1kKHgsRSx2LHApLGI9Yi5jb25jYXQoRSkscC09RS5sZW5ndGgscDw9MCkpKTt5KyspO3JldHVybiBifWZ1bmN0aW9uIGcoeCxjKXtmb3IodmFyIHY9MCxwPWMubGVuZ3RoO3Y8cDt2KyspaWYoeChjW3ZdKSlyZXR1cm4gY1t2XTtyZXR1cm4gbnVsbH1mdW5jdGlvbiB1KHgsYyl7Zm9yKHZhciB2PW51bGwscD0wLGI9Yy5sZW5ndGg7cDxiJiYhdjtwKyspaWYocihjW3BdKSl4KGNbcF0pP3Y9Y1twXTpjW3BdLmNoaWxkcmVuLmxlbmd0aD4wJiYodj11KHgsY1twXS5jaGlsZHJlbikpO2Vsc2UgY29udGludWU7cmV0dXJuIHZ9ZnVuY3Rpb24gbyh4LGMpe2Zvcih2YXIgdj0wLHA9Yy5sZW5ndGg7djxwO3YrKylpZihyKGNbdl0pJiYoeChjW3ZdKXx8Y1t2XS5jaGlsZHJlbi5sZW5ndGg+MCYmbyh4LGNbdl0uY2hpbGRyZW4pKSlyZXR1cm4hMDtyZXR1cm4hMX1mdW5jdGlvbiBmKHgsYyl7Zm9yKHZhciB2PVtdLHA9Yy5zbGljZSgpO3AubGVuZ3RoOyl7dmFyIGI9cC5zaGlmdCgpO3IoYikmJihiLmNoaWxkcmVuJiZiLmNoaWxkcmVuLmxlbmd0aD4wJiZwLnVuc2hpZnQuYXBwbHkocCxiLmNoaWxkcmVuKSx4KGIpJiZ2LnB1c2goYikpfXJldHVybiB2fX0sZnVuY3Rpb24oaCxlLHQpe3ZhciByPXQoMjU2KSxuPWUuaXNUYWc9ci5pc1RhZztlLnRlc3RFbGVtZW50PWZ1bmN0aW9uKG8sZil7Zm9yKHZhciB4IGluIG8paWYoby5oYXNPd25Qcm9wZXJ0eSh4KSl7aWYoeD09PSJ0YWdfbmFtZSIpe2lmKCFuKGYpfHwhby50YWdfbmFtZShmLm5hbWUpKXJldHVybiExfWVsc2UgaWYoeD09PSJ0YWdfdHlwZSIpe2lmKCFvLnRhZ190eXBlKGYudHlwZSkpcmV0dXJuITF9ZWxzZSBpZih4PT09InRhZ19jb250YWlucyIpe2lmKG4oZil8fCFvLnRhZ19jb250YWlucyhmLmRhdGEpKXJldHVybiExfWVsc2UgaWYoIWYuYXR0cmlic3x8IW9beF0oZi5hdHRyaWJzW3hdKSlyZXR1cm4hMX1yZXR1cm4hMH07dmFyIGQ9e3RhZ19uYW1lOmZ1bmN0aW9uKG8pe3JldHVybiB0eXBlb2Ygbz09ImZ1bmN0aW9uIj9mdW5jdGlvbihmKXtyZXR1cm4gbihmKSYmbyhmLm5hbWUpfTpvPT09IioiP246ZnVuY3Rpb24oZil7cmV0dXJuIG4oZikmJmYubmFtZT09PW99fSx0YWdfdHlwZTpmdW5jdGlvbihvKXtyZXR1cm4gdHlwZW9mIG89PSJmdW5jdGlvbiI/ZnVuY3Rpb24oZil7cmV0dXJuIG8oZi50eXBlKX06ZnVuY3Rpb24oZil7cmV0dXJuIGYudHlwZT09PW99fSx0YWdfY29udGFpbnM6ZnVuY3Rpb24obyl7cmV0dXJuIHR5cGVvZiBvPT0iZnVuY3Rpb24iP2Z1bmN0aW9uKGYpe3JldHVybiFuKGYpJiZvKGYuZGF0YSl9OmZ1bmN0aW9uKGYpe3JldHVybiFuKGYpJiZmLmRhdGE9PT1vfX19O2Z1bmN0aW9uIGcobyxmKXtyZXR1cm4gdHlwZW9mIGY9PSJmdW5jdGlvbiI/ZnVuY3Rpb24oeCl7cmV0dXJuIHguYXR0cmlicyYmZih4LmF0dHJpYnNbb10pfTpmdW5jdGlvbih4KXtyZXR1cm4geC5hdHRyaWJzJiZ4LmF0dHJpYnNbb109PT1mfX1mdW5jdGlvbiB1KG8sZil7cmV0dXJuIGZ1bmN0aW9uKHgpe3JldHVybiBvKHgpfHxmKHgpfX1lLmdldEVsZW1lbnRzPWZ1bmN0aW9uKG8sZix4LGMpe3ZhciB2PU9iamVjdC5rZXlzKG8pLm1hcChmdW5jdGlvbihwKXt2YXIgYj1vW3BdO3JldHVybiBwIGluIGQ/ZFtwXShiKTpnKHAsYil9KTtyZXR1cm4gdi5sZW5ndGg9PT0wP1tdOnRoaXMuZmlsdGVyKHYucmVkdWNlKHUpLGYseCxjKX0sZS5nZXRFbGVtZW50QnlJZD1mdW5jdGlvbihvLGYseCl7cmV0dXJuIEFycmF5LmlzQXJyYXkoZil8fChmPVtmXSksdGhpcy5maW5kT25lKGcoImlkIixvKSxmLHghPT0hMSl9LGUuZ2V0RWxlbWVudHNCeVRhZ05hbWU9ZnVuY3Rpb24obyxmLHgsYyl7cmV0dXJuIHRoaXMuZmlsdGVyKGQudGFnX25hbWUobyksZix4LGMpfSxlLmdldEVsZW1lbnRzQnlUYWdUeXBlPWZ1bmN0aW9uKG8sZix4LGMpe3JldHVybiB0aGlzLmZpbHRlcihkLnRhZ190eXBlKG8pLGYseCxjKX19LGZ1bmN0aW9uKGgsZSl7ZS5yZW1vdmVTdWJzZXRzPWZ1bmN0aW9uKG4pe2Zvcih2YXIgZD1uLmxlbmd0aCxnLHUsbzstLWQ+LTE7KXtmb3IoZz11PW5bZF0sbltkXT1udWxsLG89ITA7dTspe2lmKG4uaW5kZXhPZih1KT4tMSl7bz0hMSxuLnNwbGljZShkLDEpO2JyZWFrfXU9dS5wYXJlbnR9byYmKG5bZF09Zyl9cmV0dXJuIG59O3ZhciB0PXtESVNDT05ORUNURUQ6MSxQUkVDRURJTkc6MixGT0xMT1dJTkc6NCxDT05UQUlOUzo4LENPTlRBSU5FRF9CWToxNn0scj1lLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uPWZ1bmN0aW9uKG4sZCl7dmFyIGc9W10sdT1bXSxvLGYseCxjLHYscDtpZihuPT09ZClyZXR1cm4gMDtmb3Iobz1uO287KWcudW5zaGlmdChvKSxvPW8ucGFyZW50O2ZvcihvPWQ7bzspdS51bnNoaWZ0KG8pLG89by5wYXJlbnQ7Zm9yKHA9MDtnW3BdPT09dVtwXTspcCsrO3JldHVybiBwPT09MD90LkRJU0NPTk5FQ1RFRDooZj1nW3AtMV0seD1mLmNoaWxkcmVuLGM9Z1twXSx2PXVbcF0seC5pbmRleE9mKGMpPnguaW5kZXhPZih2KT9mPT09ZD90LkZPTExPV0lOR3x0LkNPTlRBSU5FRF9CWTp0LkZPTExPV0lORzpmPT09bj90LlBSRUNFRElOR3x0LkNPTlRBSU5TOnQuUFJFQ0VESU5HKX07ZS51bmlxdWVTb3J0PWZ1bmN0aW9uKG4pe3ZhciBkPW4ubGVuZ3RoLGcsdTtmb3Iobj1uLnNsaWNlKCk7LS1kPi0xOylnPW5bZF0sdT1uLmluZGV4T2YoZyksdT4tMSYmdTxkJiZuLnNwbGljZShkLDEpO3JldHVybiBuLnNvcnQoZnVuY3Rpb24obyxmKXt2YXIgeD1yKG8sZik7cmV0dXJuIHgmdC5QUkVDRURJTkc/LTE6eCZ0LkZPTExPV0lORz8xOjB9KSxufX0sZnVuY3Rpb24oaCxlKXtoLmV4cG9ydHM9e3RydWVGdW5jOmZ1bmN0aW9uKCl7cmV0dXJuITB9LGZhbHNlRnVuYzpmdW5jdGlvbigpe3JldHVybiExfX19LGZ1bmN0aW9uKGgsZSx0KXtoLmV4cG9ydHM9djt2YXIgcj10KDI3NSkucGFyc2Usbj10KDI3MyksZD10KDI3OCksZz10KDI3OSksdT10KDI4MCksbz10KDI4MiksZj1uLnRydWVGdW5jLHg9bi5mYWxzZUZ1bmMsYz1vLmZpbHRlcnM7ZnVuY3Rpb24gdihQLEwsRCl7dmFyIEM9YihQLEwsRCk7cmV0dXJuIHAoQyxMKX1mdW5jdGlvbiBwKFAsTCl7dmFyIEQ9TC5hZGFwdGVyO3JldHVybiBmdW5jdGlvbihTKXtyZXR1cm4gRC5pc1RhZyhTKSYmUChTKX19ZnVuY3Rpb24gYihQLEwsRCl7dmFyIEM9cihQLEwpO3JldHVybiBsKEMsTCxEKX1mdW5jdGlvbiBFKFApe3JldHVybiBQLnR5cGU9PT0icHNldWRvIiYmKFAubmFtZT09PSJzY29wZSJ8fEFycmF5LmlzQXJyYXkoUC5kYXRhKSYmUC5kYXRhLnNvbWUoZnVuY3Rpb24oTCl7cmV0dXJuIEwuc29tZShFKX0pKX12YXIgeT17dHlwZToiZGVzY2VuZGFudCJ9LE09e3R5cGU6Il9mbGV4aWJsZURlc2NlbmRhbnQifSxpPXt0eXBlOiJwc2V1ZG8iLG5hbWU6InNjb3BlIn0sYT17fTtmdW5jdGlvbiBzKFAsTCxEKXt2YXIgQz1MLmFkYXB0ZXIsUz0hIUQmJiEhRC5sZW5ndGgmJkQuZXZlcnkoZnVuY3Rpb24oQil7cmV0dXJuIEI9PT1hfHwhIUMuZ2V0UGFyZW50KEIpfSk7UC5mb3JFYWNoKGZ1bmN0aW9uKEIpe2lmKCEoQi5sZW5ndGg+MCYmTyhCWzBdKSYmQlswXS50eXBlIT09ImRlc2NlbmRhbnQiKSlpZihTJiYhKEFycmF5LmlzQXJyYXkoQik/Qi5zb21lKEUpOkUoQikpKUIudW5zaGlmdCh5KTtlbHNlIHJldHVybjtCLnVuc2hpZnQoaSl9KX1mdW5jdGlvbiBsKFAsTCxEKXtQPVAuZmlsdGVyKGZ1bmN0aW9uKHcpe3JldHVybiB3Lmxlbmd0aD4wfSksUC5mb3JFYWNoKGQpO3ZhciBDPUFycmF5LmlzQXJyYXkoRCk7RD1MJiZMLmNvbnRleHR8fEQsRCYmIUMmJihEPVtEXSkscyhQLEwsRCk7dmFyIFM9ITEsQj1QLm1hcChmdW5jdGlvbih3KXtpZih3WzBdJiZ3WzFdJiZ3WzBdLm5hbWU9PT0ic2NvcGUiKXt2YXIgSD13WzFdLnR5cGU7QyYmSD09PSJkZXNjZW5kYW50Ij93WzFdPU06KEg9PT0iYWRqYWNlbnQifHxIPT09InNpYmxpbmciKSYmKFM9ITApfXJldHVybiBBKHcsTCxEKX0pLnJlZHVjZShSLHgpO3JldHVybiBCLnNob3VsZFRlc3ROZXh0U2libGluZ3M9UyxCfWZ1bmN0aW9uIE8oUCl7cmV0dXJuIGdbUC50eXBlXTwwfWZ1bmN0aW9uIEEoUCxMLEQpe3JldHVybiBQLnJlZHVjZShmdW5jdGlvbihDLFMpe2lmKEM9PT14KXJldHVybiBDO2lmKCEoUy50eXBlIGluIHUpKXRocm93IG5ldyBFcnJvcigiUnVsZSB0eXBlICIrUy50eXBlKyIgaXMgbm90IHN1cHBvcnRlZCBieSBjc3Mtc2VsZWN0Iik7cmV0dXJuIHVbUy50eXBlXShDLFMsTCxEKX0sTCYmTC5yb290RnVuY3x8Zil9ZnVuY3Rpb24gUihQLEwpe3JldHVybiBMPT09eHx8UD09PWY/UDpQPT09eHx8TD09PWY/TDpmdW5jdGlvbihDKXtyZXR1cm4gUChDKXx8TChDKX19ZnVuY3Rpb24gSShQKXtyZXR1cm4gUC5zb21lKE8pfWMubm90PWZ1bmN0aW9uKFAsTCxELEMpe3ZhciBTPXt4bWxNb2RlOiEhKEQmJkQueG1sTW9kZSksc3RyaWN0OiEhKEQmJkQuc3RyaWN0KSxhZGFwdGVyOkQuYWRhcHRlcn07aWYoUy5zdHJpY3QmJihMLmxlbmd0aD4xfHxMLnNvbWUoSSkpKXRocm93IG5ldyBFcnJvcigiY29tcGxleCBzZWxlY3RvcnMgaW4gOm5vdCBhcmVuJ3QgYWxsb3dlZCBpbiBzdHJpY3QgbW9kZSIpO3ZhciBCPWwoTCxTLEMpO3JldHVybiBCPT09eD9QOkI9PT1mP3g6ZnVuY3Rpb24oSCl7cmV0dXJuIUIoSCkmJlAoSCl9fSxjLmhhcz1mdW5jdGlvbihQLEwsRCl7dmFyIEM9RC5hZGFwdGVyLFM9e3htbE1vZGU6ISEoRCYmRC54bWxNb2RlKSxzdHJpY3Q6ISEoRCYmRC5zdHJpY3QpLGFkYXB0ZXI6Q30sQj1MLnNvbWUoSSk/W2FdOm51bGwsdz1sKEwsUyxCKTtyZXR1cm4gdz09PXg/eDp3PT09Zj9mdW5jdGlvbihKKXtyZXR1cm4gQy5nZXRDaGlsZHJlbihKKS5zb21lKEMuaXNUYWcpJiZQKEopfToodz1wKHcsRCksQj9mdW5jdGlvbihKKXtyZXR1cm4gUChKKSYmKEJbMF09SixDLmV4aXN0c09uZSh3LEMuZ2V0Q2hpbGRyZW4oSikpKX06ZnVuY3Rpb24oSil7cmV0dXJuIFAoSikmJkMuZXhpc3RzT25lKHcsQy5nZXRDaGlsZHJlbihKKSl9KX0sYy5tYXRjaGVzPWZ1bmN0aW9uKFAsTCxELEMpe3ZhciBTPXt4bWxNb2RlOiEhKEQmJkQueG1sTW9kZSksc3RyaWN0OiEhKEQmJkQuc3RyaWN0KSxyb290RnVuYzpQLGFkYXB0ZXI6RC5hZGFwdGVyfTtyZXR1cm4gbChMLFMsQyl9LHYuY29tcGlsZVRva2VuPWwsdi5jb21waWxlVW5zYWZlPWIsdi5Qc2V1ZG9zPW99LGZ1bmN0aW9uKGgsZSx0KXt2YXIgcj10aGlzJiZ0aGlzLl9fY3JlYXRlQmluZGluZ3x8KE9iamVjdC5jcmVhdGU/ZnVuY3Rpb24odSxvLGYseCl7eD09PXZvaWQgMCYmKHg9ZiksT2JqZWN0LmRlZmluZVByb3BlcnR5KHUseCx7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gb1tmXX19KX06ZnVuY3Rpb24odSxvLGYseCl7eD09PXZvaWQgMCYmKHg9ZiksdVt4XT1vW2ZdfSksbj10aGlzJiZ0aGlzLl9fZXhwb3J0U3Rhcnx8ZnVuY3Rpb24odSxvKXtmb3IodmFyIGYgaW4gdSlmIT09ImRlZmF1bHQiJiYhby5oYXNPd25Qcm9wZXJ0eShmKSYmcihvLHUsZil9O09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxuKHQoMjc2KSxlKTt2YXIgZD10KDI3Nik7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsInBhcnNlIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gZC5kZWZhdWx0fX0pO3ZhciBnPXQoMjc3KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwic3RyaW5naWZ5Iix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gZy5kZWZhdWx0fX0pfSxmdW5jdGlvbihoLGUsdCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLGUuZGVmYXVsdD1FO3ZhciByPS9eW15cXF0/KD86XFwoPzpbXGRhLWZdezEsNn1ccz98Lil8W1x3XC1cdTAwYjAtXHVGRkZGXSkrLyxuPS9cXChbXGRhLWZdezEsNn1ccz98KFxzKXwuKS9naSxkPS9eXHMqKCg/OlxcLnxbXHdcdTAwYjAtXHVGRkZGLV0pKylccyooPzooXFM/KT1ccyooPzooWyciXSkoW15dKj8pXDN8KCM/KD86XFwufFtcd1x1MDBiMC1cdUZGRkYtXSkqKXwpfClccyooaSk/XF0vLGc9e3VuZGVmaW5lZDoiZXhpc3RzIiwiIjoiZXF1YWxzIiwifiI6ImVsZW1lbnQiLCJeIjoic3RhcnQiLCQ6ImVuZCIsIioiOiJhbnkiLCIhIjoibm90IiwifCI6Imh5cGhlbiJ9LHU9eyI+IjoiY2hpbGQiLCI8IjoicGFyZW50IiwifiI6InNpYmxpbmciLCIrIjoiYWRqYWNlbnQifSxvPXsiIyI6WyJpZCIsImVxdWFscyJdLCIuIjpbImNsYXNzIiwiZWxlbWVudCJdfSxmPW5ldyBTZXQoWyJoYXMiLCJub3QiLCJtYXRjaGVzIl0pLHg9bmV3IFNldChbImNvbnRhaW5zIiwiaWNvbnRhaW5zIl0pLGM9bmV3IFNldChbJyInLCInIl0pO2Z1bmN0aW9uIHYoaSxhLHMpe3ZhciBsPXBhcnNlSW50KGEsMTYpLTY1NTM2O3JldHVybiBsIT09bHx8cz9hOmw8MD9TdHJpbmcuZnJvbUNoYXJDb2RlKGwrNjU1MzYpOlN0cmluZy5mcm9tQ2hhckNvZGUobD4+MTB8NTUyOTYsbCYxMDIzfDU2MzIwKX1mdW5jdGlvbiBwKGkpe3JldHVybiBpLnJlcGxhY2Uobix2KX1mdW5jdGlvbiBiKGkpe3JldHVybiBpPT09IiAifHxpPT09YApgfHxpPT09IgkifHxpPT09IlxmInx8aT09PSJcciJ9ZnVuY3Rpb24gRShpLGEpe3ZhciBzPVtdO2lmKGk9eShzLCIiK2ksYSksaSE9PSIiKXRocm93IG5ldyBFcnJvcigiVW5tYXRjaGVkIHNlbGVjdG9yOiAiK2kpO3JldHVybiBzfWZ1bmN0aW9uIHkoaSxhLHMpe3ZhciBsPVtdLE89ITE7ZnVuY3Rpb24gQSgpe3ZhciBaPWEubWF0Y2gocik7aWYoIVopdGhyb3cgbmV3IEVycm9yKCJFeHBlY3RlZCBuYW1lLCBmb3VuZCAiK2EpO3ZhciB0dD1aWzBdO3JldHVybiBhPWEuc3Vic3RyKHR0Lmxlbmd0aCkscCh0dCl9ZnVuY3Rpb24gUihaKXtmb3IoO2IoYS5jaGFyQXQoWikpOylaKys7YT1hLnN1YnN0cihaKX1mdW5jdGlvbiBJKFope2Zvcih2YXIgdHQ9MDthLmNoYXJBdCgtLVopPT09IlxcIjspdHQrKztyZXR1cm4odHQmMSk9PT0xfWZvcihSKDApO2EhPT0iIjspe3ZhciBQPWEuY2hhckF0KDApO2lmKGIoUCkpTz0hMCxSKDEpO2Vsc2UgaWYoUCBpbiB1KWwucHVzaCh7dHlwZTp1W1BdfSksTz0hMSxSKDEpO2Vsc2UgaWYoUD09PSIsIil7aWYobC5sZW5ndGg9PT0wKXRocm93IG5ldyBFcnJvcigiRW1wdHkgc3ViLXNlbGVjdG9yIik7aS5wdXNoKGwpLGw9W10sTz0hMSxSKDEpfWVsc2UgaWYoTyYmKGwubGVuZ3RoPjAmJmwucHVzaCh7dHlwZToiZGVzY2VuZGFudCJ9KSxPPSExKSxQPT09IioiKWE9YS5zdWJzdHIoMSksbC5wdXNoKHt0eXBlOiJ1bml2ZXJzYWwifSk7ZWxzZSBpZihQIGluIG8pe3ZhciBMPW9bUF0sRD1MWzBdLEM9TFsxXTthPWEuc3Vic3RyKDEpLGwucHVzaCh7dHlwZToiYXR0cmlidXRlIixuYW1lOkQsYWN0aW9uOkMsdmFsdWU6QSgpLGlnbm9yZUNhc2U6ITF9KX1lbHNlIGlmKFA9PT0iWyIpe2E9YS5zdWJzdHIoMSk7dmFyIFM9YS5tYXRjaChkKTtpZighUyl0aHJvdyBuZXcgRXJyb3IoIk1hbGZvcm1lZCBhdHRyaWJ1dGUgc2VsZWN0b3I6ICIrYSk7YT1hLnN1YnN0cihTWzBdLmxlbmd0aCk7dmFyIEI9cChTWzFdKTsoIXN8fCgibG93ZXJDYXNlQXR0cmlidXRlTmFtZXMiaW4gcz9zLmxvd2VyQ2FzZUF0dHJpYnV0ZU5hbWVzOiFzLnhtbE1vZGUpKSYmKEI9Qi50b0xvd2VyQ2FzZSgpKSxsLnB1c2goe3R5cGU6ImF0dHJpYnV0ZSIsbmFtZTpCLGFjdGlvbjpnW1NbMl1dLHZhbHVlOnAoU1s0XXx8U1s1XXx8IiIpLGlnbm9yZUNhc2U6ISFTWzZdfSl9ZWxzZSBpZihQPT09IjoiKXtpZihhLmNoYXJBdCgxKT09PSI6Iil7YT1hLnN1YnN0cigyKSxsLnB1c2goe3R5cGU6InBzZXVkby1lbGVtZW50IixuYW1lOkEoKS50b0xvd2VyQ2FzZSgpfSk7Y29udGludWV9YT1hLnN1YnN0cigxKTt2YXIgdz1BKCkudG9Mb3dlckNhc2UoKSxTPW51bGw7aWYoYS5jaGFyQXQoMCk9PT0iKCIpaWYoZi5oYXModykpe3ZhciBIPWEuY2hhckF0KDEpLEo9Yy5oYXMoSCk7aWYoYT1hLnN1YnN0cihKPzI6MSksUz1bXSxhPXkoUyxhLHMpLEope2lmKGEuY2hhckF0KDApIT09SCl0aHJvdyBuZXcgRXJyb3IoIlVubWF0Y2hlZCBxdW90ZXMgaW4gOiIrdyk7YT1hLnN1YnN0cigxKX1pZihhLmNoYXJBdCgwKSE9PSIpIil0aHJvdyBuZXcgRXJyb3IoIk1pc3NpbmcgY2xvc2luZyBwYXJlbnRoZXNpcyBpbiA6Iit3KyIgKCIrYSsiKSIpO2E9YS5zdWJzdHIoMSl9ZWxzZXtmb3IodmFyIHE9MSxVPTE7VT4wJiZxPGEubGVuZ3RoO3ErKylhLmNoYXJBdChxKT09PSIoIiYmIUkocSk/VSsrOmEuY2hhckF0KHEpPT09IikiJiYhSShxKSYmVS0tO2lmKFUpdGhyb3cgbmV3IEVycm9yKCJQYXJlbnRoZXNpcyBub3QgbWF0Y2hlZCIpO2lmKFM9YS5zdWJzdHIoMSxxLTIpLGE9YS5zdWJzdHIocSkseC5oYXModykpe3ZhciBIPVMuY2hhckF0KDApO0g9PT1TLnNsaWNlKC0xKSYmYy5oYXMoSCkmJihTPVMuc2xpY2UoMSwtMSkpLFM9cChTKX19bC5wdXNoKHt0eXBlOiJwc2V1ZG8iLG5hbWU6dyxkYXRhOlN9KX1lbHNlIGlmKHIudGVzdChhKSl7dmFyIEc9QSgpOyghc3x8KCJsb3dlckNhc2VUYWdzImluIHM/cy5sb3dlckNhc2VUYWdzOiFzLnhtbE1vZGUpKSYmKEc9Ry50b0xvd2VyQ2FzZSgpKSxsLnB1c2goe3R5cGU6InRhZyIsbmFtZTpHfSl9ZWxzZSByZXR1cm4gbC5sZW5ndGgmJmxbbC5sZW5ndGgtMV0udHlwZT09PSJkZXNjZW5kYW50IiYmbC5wb3AoKSxNKGksbCksYX1yZXR1cm4gTShpLGwpLGF9ZnVuY3Rpb24gTShpLGEpe2lmKGkubGVuZ3RoPjAmJmEubGVuZ3RoPT09MCl0aHJvdyBuZXcgRXJyb3IoIkVtcHR5IHN1Yi1zZWxlY3RvciIpO2kucHVzaChhKX19LGZ1bmN0aW9uKGgsZSx0KXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSk7dmFyIHI9e2VxdWFsczoiIixlbGVtZW50OiJ+IixzdGFydDoiXiIsZW5kOiIkIixhbnk6IioiLG5vdDoiISIsaHlwaGVuOiJ8In07ZnVuY3Rpb24gbihvKXtyZXR1cm4gby5tYXAoZCkuam9pbigiLCAiKX1lLmRlZmF1bHQ9bjtmdW5jdGlvbiBkKG8pe3JldHVybiBvLm1hcChnKS5qb2luKCIiKX1mdW5jdGlvbiBnKG8pe3N3aXRjaChvLnR5cGUpe2Nhc2UiY2hpbGQiOnJldHVybiIgPiAiO2Nhc2UicGFyZW50IjpyZXR1cm4iIDwgIjtjYXNlInNpYmxpbmciOnJldHVybiIgfiAiO2Nhc2UiYWRqYWNlbnQiOnJldHVybiIgKyAiO2Nhc2UiZGVzY2VuZGFudCI6cmV0dXJuIiAiO2Nhc2UidW5pdmVyc2FsIjpyZXR1cm4iKiI7Y2FzZSJ0YWciOnJldHVybiBvLm5hbWU7Y2FzZSJwc2V1ZG8tZWxlbWVudCI6cmV0dXJuIjo6IitvLm5hbWU7Y2FzZSJwc2V1ZG8iOnJldHVybiBvLmRhdGE9PT1udWxsPyI6IitvLm5hbWU6dHlwZW9mIG8uZGF0YT09InN0cmluZyI/IjoiK28ubmFtZSsiKCIrby5kYXRhKyIpIjoiOiIrby5uYW1lKyIoIituKG8uZGF0YSkrIikiO2Nhc2UiYXR0cmlidXRlIjpyZXR1cm4gby5hY3Rpb249PT0iZXhpc3RzIj8iWyIrby5uYW1lKyJdIjpvLm5hbWU9PT0iaWQiJiZvLmFjdGlvbj09PSJlcXVhbHMiJiYhby5pZ25vcmVDYXNlPyIjIitvLnZhbHVlOm8ubmFtZT09PSJjbGFzcyImJm8uYWN0aW9uPT09ImVsZW1lbnQiJiYhby5pZ25vcmVDYXNlPyIuIitvLnZhbHVlOiJbIitvLm5hbWUrcltvLmFjdGlvbl0rIj0nIitvLnZhbHVlKyInIisoby5pZ25vcmVDYXNlPyJpIjoiIikrIl0iO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKCJVbmtub3duIHR5cGUiKX19ZnVuY3Rpb24gdShvKXtyZXR1cm4gb319LGZ1bmN0aW9uKGgsZSx0KXtoLmV4cG9ydHM9ZDt2YXIgcj10KDI3OSksbj17X19wcm90b19fOm51bGwsZXhpc3RzOjEwLGVxdWFsczo4LG5vdDo3LHN0YXJ0OjYsZW5kOjYsYW55OjUsaHlwaGVuOjQsZWxlbWVudDo0fTtmdW5jdGlvbiBkKHUpe2Zvcih2YXIgbz11Lm1hcChnKSxmPTE7Zjx1Lmxlbmd0aDtmKyspe3ZhciB4PW9bZl07aWYoISh4PDApKWZvcih2YXIgYz1mLTE7Yz49MCYmeDxvW2NdO2MtLSl7dmFyIHY9dVtjKzFdO3VbYysxXT11W2NdLHVbY109dixvW2MrMV09b1tjXSxvW2NdPXh9fX1mdW5jdGlvbiBnKHUpe3ZhciBvPXJbdS50eXBlXTtpZihvPT09ci5hdHRyaWJ1dGUpbz1uW3UuYWN0aW9uXSxvPT09bi5lcXVhbHMmJnUubmFtZT09PSJpZCImJihvPTkpLHUuaWdub3JlQ2FzZSYmKG8+Pj0xKTtlbHNlIGlmKG89PT1yLnBzZXVkbylpZighdS5kYXRhKW89MztlbHNlIGlmKHUubmFtZT09PSJoYXMifHx1Lm5hbWU9PT0iY29udGFpbnMiKW89MDtlbHNlIGlmKHUubmFtZT09PSJtYXRjaGVzInx8dS5uYW1lPT09Im5vdCIpe289MDtmb3IodmFyIGY9MDtmPHUuZGF0YS5sZW5ndGg7ZisrKWlmKHUuZGF0YVtmXS5sZW5ndGg9PT0xKXt2YXIgeD1nKHUuZGF0YVtmXVswXSk7aWYoeD09PTApe289MDticmVha314Pm8mJihvPXgpfXUuZGF0YS5sZW5ndGg+MSYmbz4wJiYoby09MSl9ZWxzZSBvPTE7cmV0dXJuIG99fSxmdW5jdGlvbihoKXtoLmV4cG9ydHM9SlNPTi5wYXJzZSgneyJ1bml2ZXJzYWwiOjUwLCJ0YWciOjMwLCJhdHRyaWJ1dGUiOjEsInBzZXVkbyI6MCwiZGVzY2VuZGFudCI6LTEsImNoaWxkIjotMSwicGFyZW50IjotMSwic2libGluZyI6LTEsImFkamFjZW50IjotMX0nKX0sZnVuY3Rpb24oaCxlLHQpe3ZhciByPXQoMjgxKSxuPXQoMjgyKTtoLmV4cG9ydHM9e19fcHJvdG9fXzpudWxsLGF0dHJpYnV0ZTpyLmNvbXBpbGUscHNldWRvOm4uY29tcGlsZSx0YWc6ZnVuY3Rpb24oZCxnLHUpe3ZhciBvPWcubmFtZSxmPXUuYWRhcHRlcjtyZXR1cm4gZnVuY3Rpb24oYyl7cmV0dXJuIGYuZ2V0TmFtZShjKT09PW8mJmQoYyl9fSxkZXNjZW5kYW50OmZ1bmN0aW9uKGQsZyx1KXt2YXIgbz10eXBlb2YgV2Vha1NldDwidSI/bmV3IFdlYWtTZXQ6bnVsbCxmPXUuYWRhcHRlcjtyZXR1cm4gZnVuY3Rpb24oYyl7Zm9yKHZhciB2PSExOyF2JiYoYz1mLmdldFBhcmVudChjKSk7KSghb3x8IW8uaGFzKGMpKSYmKHY9ZChjKSwhdiYmbyYmby5hZGQoYykpO3JldHVybiB2fX0sX2ZsZXhpYmxlRGVzY2VuZGFudDpmdW5jdGlvbihkLGcsdSl7dmFyIG89dS5hZGFwdGVyO3JldHVybiBmdW5jdGlvbih4KXtmb3IodmFyIGM9ZCh4KTshYyYmKHg9by5nZXRQYXJlbnQoeCkpOyljPWQoeCk7cmV0dXJuIGN9fSxwYXJlbnQ6ZnVuY3Rpb24oZCxnLHUpe2lmKHUmJnUuc3RyaWN0KXRocm93IG5ldyBFcnJvcigiUGFyZW50IHNlbGVjdG9yIGlzbid0IHBhcnQgb2YgQ1NTMyIpO3ZhciBvPXUuYWRhcHRlcjtyZXR1cm4gZnVuY3Rpb24oYyl7cmV0dXJuIG8uZ2V0Q2hpbGRyZW4oYykuc29tZShmKX07ZnVuY3Rpb24gZih4KXtyZXR1cm4gby5pc1RhZyh4KSYmZCh4KX19LGNoaWxkOmZ1bmN0aW9uKGQsZyx1KXt2YXIgbz11LmFkYXB0ZXI7cmV0dXJuIGZ1bmN0aW9uKHgpe3ZhciBjPW8uZ2V0UGFyZW50KHgpO3JldHVybiEhYyYmZChjKX19LHNpYmxpbmc6ZnVuY3Rpb24oZCxnLHUpe3ZhciBvPXUuYWRhcHRlcjtyZXR1cm4gZnVuY3Rpb24oeCl7Zm9yKHZhciBjPW8uZ2V0U2libGluZ3MoeCksdj0wO3Y8Yy5sZW5ndGg7disrKWlmKG8uaXNUYWcoY1t2XSkpe2lmKGNbdl09PT14KWJyZWFrO2lmKGQoY1t2XSkpcmV0dXJuITB9cmV0dXJuITF9fSxhZGphY2VudDpmdW5jdGlvbihkLGcsdSl7dmFyIG89dS5hZGFwdGVyO3JldHVybiBmdW5jdGlvbih4KXtmb3IodmFyIGM9by5nZXRTaWJsaW5ncyh4KSx2LHA9MDtwPGMubGVuZ3RoO3ArKylpZihvLmlzVGFnKGNbcF0pKXtpZihjW3BdPT09eClicmVhazt2PWNbcF19cmV0dXJuISF2JiZkKHYpfX0sdW5pdmVyc2FsOmZ1bmN0aW9uKGQpe3JldHVybiBkfX19LGZ1bmN0aW9uKGgsZSx0KXt2YXIgcj10KDI3MykuZmFsc2VGdW5jLG49L1stW1xde30oKSorPy4sXFxeJHwjXHNdL2csZD17X19wcm90b19fOm51bGwsZXF1YWxzOmZ1bmN0aW9uKGcsdSxvKXt2YXIgZj11Lm5hbWUseD11LnZhbHVlLGM9by5hZGFwdGVyO3JldHVybiB1Lmlnbm9yZUNhc2U/KHg9eC50b0xvd2VyQ2FzZSgpLGZ1bmN0aW9uKHApe3ZhciBiPWMuZ2V0QXR0cmlidXRlVmFsdWUocCxmKTtyZXR1cm4gYiE9bnVsbCYmYi50b0xvd2VyQ2FzZSgpPT09eCYmZyhwKX0pOmZ1bmN0aW9uKHApe3JldHVybiBjLmdldEF0dHJpYnV0ZVZhbHVlKHAsZik9PT14JiZnKHApfX0saHlwaGVuOmZ1bmN0aW9uKGcsdSxvKXt2YXIgZj11Lm5hbWUseD11LnZhbHVlLGM9eC5sZW5ndGgsdj1vLmFkYXB0ZXI7cmV0dXJuIHUuaWdub3JlQ2FzZT8oeD14LnRvTG93ZXJDYXNlKCksZnVuY3Rpb24oYil7dmFyIEU9di5nZXRBdHRyaWJ1dGVWYWx1ZShiLGYpO3JldHVybiBFIT1udWxsJiYoRS5sZW5ndGg9PT1jfHxFLmNoYXJBdChjKT09PSItIikmJkUuc3Vic3RyKDAsYykudG9Mb3dlckNhc2UoKT09PXgmJmcoYil9KTpmdW5jdGlvbihiKXt2YXIgRT12LmdldEF0dHJpYnV0ZVZhbHVlKGIsZik7cmV0dXJuIEUhPW51bGwmJkUuc3Vic3RyKDAsYyk9PT14JiYoRS5sZW5ndGg9PT1jfHxFLmNoYXJBdChjKT09PSItIikmJmcoYil9fSxlbGVtZW50OmZ1bmN0aW9uKGcsdSxvKXt2YXIgZj11Lm5hbWUseD11LnZhbHVlLGM9by5hZGFwdGVyO2lmKC9ccy8udGVzdCh4KSlyZXR1cm4gcjt4PXgucmVwbGFjZShuLCJcXCQmIik7dmFyIHY9Iig/Ol58XFxzKSIreCsiKD86JHxcXHMpIixwPXUuaWdub3JlQ2FzZT8iaSI6IiIsYj1uZXcgUmVnRXhwKHYscCk7cmV0dXJuIGZ1bmN0aW9uKHkpe3ZhciBNPWMuZ2V0QXR0cmlidXRlVmFsdWUoeSxmKTtyZXR1cm4gTSE9bnVsbCYmYi50ZXN0KE0pJiZnKHkpfX0sZXhpc3RzOmZ1bmN0aW9uKGcsdSxvKXt2YXIgZj11Lm5hbWUseD1vLmFkYXB0ZXI7cmV0dXJuIGZ1bmN0aW9uKHYpe3JldHVybiB4Lmhhc0F0dHJpYih2LGYpJiZnKHYpfX0sc3RhcnQ6ZnVuY3Rpb24oZyx1LG8pe3ZhciBmPXUubmFtZSx4PXUudmFsdWUsYz14Lmxlbmd0aCx2PW8uYWRhcHRlcjtyZXR1cm4gYz09PTA/cjp1Lmlnbm9yZUNhc2U/KHg9eC50b0xvd2VyQ2FzZSgpLGZ1bmN0aW9uKGIpe3ZhciBFPXYuZ2V0QXR0cmlidXRlVmFsdWUoYixmKTtyZXR1cm4gRSE9bnVsbCYmRS5zdWJzdHIoMCxjKS50b0xvd2VyQ2FzZSgpPT09eCYmZyhiKX0pOmZ1bmN0aW9uKGIpe3ZhciBFPXYuZ2V0QXR0cmlidXRlVmFsdWUoYixmKTtyZXR1cm4gRSE9bnVsbCYmRS5zdWJzdHIoMCxjKT09PXgmJmcoYil9fSxlbmQ6ZnVuY3Rpb24oZyx1LG8pe3ZhciBmPXUubmFtZSx4PXUudmFsdWUsYz0teC5sZW5ndGgsdj1vLmFkYXB0ZXI7cmV0dXJuIGM9PT0wP3I6dS5pZ25vcmVDYXNlPyh4PXgudG9Mb3dlckNhc2UoKSxmdW5jdGlvbihiKXt2YXIgRT12LmdldEF0dHJpYnV0ZVZhbHVlKGIsZik7cmV0dXJuIEUhPW51bGwmJkUuc3Vic3RyKGMpLnRvTG93ZXJDYXNlKCk9PT14JiZnKGIpfSk6ZnVuY3Rpb24oYil7dmFyIEU9di5nZXRBdHRyaWJ1dGVWYWx1ZShiLGYpO3JldHVybiBFIT1udWxsJiZFLnN1YnN0cihjKT09PXgmJmcoYil9fSxhbnk6ZnVuY3Rpb24oZyx1LG8pe3ZhciBmPXUubmFtZSx4PXUudmFsdWUsYz1vLmFkYXB0ZXI7aWYoeD09PSIiKXJldHVybiByO2lmKHUuaWdub3JlQ2FzZSl7dmFyIHY9bmV3IFJlZ0V4cCh4LnJlcGxhY2UobiwiXFwkJiIpLCJpIik7cmV0dXJuIGZ1bmN0aW9uKGIpe3ZhciBFPWMuZ2V0QXR0cmlidXRlVmFsdWUoYixmKTtyZXR1cm4gRSE9bnVsbCYmdi50ZXN0KEUpJiZnKGIpfX1yZXR1cm4gZnVuY3Rpb24oYil7dmFyIEU9Yy5nZXRBdHRyaWJ1dGVWYWx1ZShiLGYpO3JldHVybiBFIT1udWxsJiZFLmluZGV4T2YoeCk+PTAmJmcoYil9fSxub3Q6ZnVuY3Rpb24oZyx1LG8pe3ZhciBmPXUubmFtZSx4PXUudmFsdWUsYz1vLmFkYXB0ZXI7cmV0dXJuIHg9PT0iIj9mdW5jdGlvbihwKXtyZXR1cm4hIWMuZ2V0QXR0cmlidXRlVmFsdWUocCxmKSYmZyhwKX06dS5pZ25vcmVDYXNlPyh4PXgudG9Mb3dlckNhc2UoKSxmdW5jdGlvbihwKXt2YXIgYj1jLmdldEF0dHJpYnV0ZVZhbHVlKHAsZik7cmV0dXJuIGIhPW51bGwmJmIudG9Mb3dlckNhc2UoKSE9PXgmJmcocCl9KTpmdW5jdGlvbihwKXtyZXR1cm4gYy5nZXRBdHRyaWJ1dGVWYWx1ZShwLGYpIT09eCYmZyhwKX19fTtoLmV4cG9ydHM9e2NvbXBpbGU6ZnVuY3Rpb24oZyx1LG8pe2lmKG8mJm8uc3RyaWN0JiYodS5pZ25vcmVDYXNlfHx1LmFjdGlvbj09PSJub3QiKSl0aHJvdyBuZXcgRXJyb3IoIlVuc3VwcG9ydGVkIGF0dHJpYnV0ZSBzZWxlY3RvciIpO3JldHVybiBkW3UuYWN0aW9uXShnLHUsbyl9LHJ1bGVzOmR9fSxmdW5jdGlvbihoLGUsdCl7dmFyIHI9dCgyODMpLG49dCgyNzMpLGQ9dCgyODEpLGc9bi50cnVlRnVuYyx1PW4uZmFsc2VGdW5jLG89ZC5ydWxlcy5lcXVhbHM7ZnVuY3Rpb24gZihNLGkpe3ZhciBhPXtuYW1lOk0sdmFsdWU6aX07cmV0dXJuIGZ1bmN0aW9uKGwsTyxBKXtyZXR1cm4gbyhsLGEsQSl9fWZ1bmN0aW9uIHgoTSxpKXtyZXR1cm4gZnVuY3Rpb24oYSl7cmV0dXJuISFpLmdldFBhcmVudChhKSYmTShhKX19dmFyIGM9e2NvbnRhaW5zOmZ1bmN0aW9uKE0saSxhKXt2YXIgcz1hLmFkYXB0ZXI7cmV0dXJuIGZ1bmN0aW9uKE8pe3JldHVybiBNKE8pJiZzLmdldFRleHQoTykuaW5kZXhPZihpKT49MH19LGljb250YWluczpmdW5jdGlvbihNLGksYSl7dmFyIHM9aS50b0xvd2VyQ2FzZSgpLGw9YS5hZGFwdGVyO3JldHVybiBmdW5jdGlvbihBKXtyZXR1cm4gTShBKSYmbC5nZXRUZXh0KEEpLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihzKT49MH19LCJudGgtY2hpbGQiOmZ1bmN0aW9uKE0saSxhKXt2YXIgcz1yKGkpLGw9YS5hZGFwdGVyO3JldHVybiBzPT09dT9zOnM9PT1nP3goTSxsKTpmdW5jdGlvbihBKXtmb3IodmFyIFI9bC5nZXRTaWJsaW5ncyhBKSxJPTAsUD0wO0k8Ui5sZW5ndGg7SSsrKWlmKGwuaXNUYWcoUltJXSkpe2lmKFJbSV09PT1BKWJyZWFrO1ArK31yZXR1cm4gcyhQKSYmTShBKX19LCJudGgtbGFzdC1jaGlsZCI6ZnVuY3Rpb24oTSxpLGEpe3ZhciBzPXIoaSksbD1hLmFkYXB0ZXI7cmV0dXJuIHM9PT11P3M6cz09PWc/eChNLGwpOmZ1bmN0aW9uKEEpe2Zvcih2YXIgUj1sLmdldFNpYmxpbmdzKEEpLEk9MCxQPVIubGVuZ3RoLTE7UD49MDtQLS0paWYobC5pc1RhZyhSW1BdKSl7aWYoUltQXT09PUEpYnJlYWs7SSsrfXJldHVybiBzKEkpJiZNKEEpfX0sIm50aC1vZi10eXBlIjpmdW5jdGlvbihNLGksYSl7dmFyIHM9cihpKSxsPWEuYWRhcHRlcjtyZXR1cm4gcz09PXU/czpzPT09Zz94KE0sbCk6ZnVuY3Rpb24oQSl7Zm9yKHZhciBSPWwuZ2V0U2libGluZ3MoQSksST0wLFA9MDtQPFIubGVuZ3RoO1ArKylpZihsLmlzVGFnKFJbUF0pKXtpZihSW1BdPT09QSlicmVhaztsLmdldE5hbWUoUltQXSk9PT1sLmdldE5hbWUoQSkmJkkrK31yZXR1cm4gcyhJKSYmTShBKX19LCJudGgtbGFzdC1vZi10eXBlIjpmdW5jdGlvbihNLGksYSl7dmFyIHM9cihpKSxsPWEuYWRhcHRlcjtyZXR1cm4gcz09PXU/czpzPT09Zz94KE0sbCk6ZnVuY3Rpb24oQSl7Zm9yKHZhciBSPWwuZ2V0U2libGluZ3MoQSksST0wLFA9Ui5sZW5ndGgtMTtQPj0wO1AtLSlpZihsLmlzVGFnKFJbUF0pKXtpZihSW1BdPT09QSlicmVhaztsLmdldE5hbWUoUltQXSk9PT1sLmdldE5hbWUoQSkmJkkrK31yZXR1cm4gcyhJKSYmTShBKX19LHJvb3Q6ZnVuY3Rpb24oTSxpLGEpe3ZhciBzPWEuYWRhcHRlcjtyZXR1cm4gZnVuY3Rpb24obCl7cmV0dXJuIXMuZ2V0UGFyZW50KGwpJiZNKGwpfX0sc2NvcGU6ZnVuY3Rpb24oTSxpLGEscyl7dmFyIGw9YS5hZGFwdGVyO2lmKCFzfHxzLmxlbmd0aD09PTApcmV0dXJuIGMucm9vdChNLGksYSk7ZnVuY3Rpb24gTyhBLFIpe3JldHVybiB0eXBlb2YgbC5lcXVhbHM9PSJmdW5jdGlvbiI/bC5lcXVhbHMoQSxSKTpBPT09Un1yZXR1cm4gcy5sZW5ndGg9PT0xP2Z1bmN0aW9uKEEpe3JldHVybiBPKHNbMF0sQSkmJk0oQSl9OmZ1bmN0aW9uKEEpe3JldHVybiBzLmluZGV4T2YoQSk+PTAmJk0oQSl9fSxjaGVja2JveDpmKCJ0eXBlIiwiY2hlY2tib3giKSxmaWxlOmYoInR5cGUiLCJmaWxlIikscGFzc3dvcmQ6ZigidHlwZSIsInBhc3N3b3JkIikscmFkaW86ZigidHlwZSIsInJhZGlvIikscmVzZXQ6ZigidHlwZSIsInJlc2V0IiksaW1hZ2U6ZigidHlwZSIsImltYWdlIiksc3VibWl0OmYoInR5cGUiLCJzdWJtaXQiKSxob3ZlcjpmdW5jdGlvbihNLGksYSl7dmFyIHM9YS5hZGFwdGVyO3JldHVybiB0eXBlb2Ygcy5pc0hvdmVyZWQ9PSJmdW5jdGlvbiI/ZnVuY3Rpb24oTyl7cmV0dXJuIE0oTykmJnMuaXNIb3ZlcmVkKE8pfTp1fSx2aXNpdGVkOmZ1bmN0aW9uKE0saSxhKXt2YXIgcz1hLmFkYXB0ZXI7cmV0dXJuIHR5cGVvZiBzLmlzVmlzaXRlZD09ImZ1bmN0aW9uIj9mdW5jdGlvbihPKXtyZXR1cm4gTShPKSYmcy5pc1Zpc2l0ZWQoTyl9OnV9LGFjdGl2ZTpmdW5jdGlvbihNLGksYSl7dmFyIHM9YS5hZGFwdGVyO3JldHVybiB0eXBlb2Ygcy5pc0FjdGl2ZT09ImZ1bmN0aW9uIj9mdW5jdGlvbihPKXtyZXR1cm4gTShPKSYmcy5pc0FjdGl2ZShPKX06dX19O2Z1bmN0aW9uIHYoTSxpKXtmb3IodmFyIGE9MDtNJiZhPE0ubGVuZ3RoO2ErKylpZihpLmlzVGFnKE1bYV0pKXJldHVybiBNW2FdfXZhciBwPXtlbXB0eTpmdW5jdGlvbihNLGkpe3JldHVybiFpLmdldENoaWxkcmVuKE0pLnNvbWUoZnVuY3Rpb24oYSl7cmV0dXJuIGkuaXNUYWcoYSl8fGEudHlwZT09PSJ0ZXh0In0pfSwiZmlyc3QtY2hpbGQiOmZ1bmN0aW9uKE0saSl7cmV0dXJuIHYoaS5nZXRTaWJsaW5ncyhNKSxpKT09PU19LCJsYXN0LWNoaWxkIjpmdW5jdGlvbihNLGkpe2Zvcih2YXIgYT1pLmdldFNpYmxpbmdzKE0pLHM9YS5sZW5ndGgtMTtzPj0wO3MtLSl7aWYoYVtzXT09PU0pcmV0dXJuITA7aWYoaS5pc1RhZyhhW3NdKSlicmVha31yZXR1cm4hMX0sImZpcnN0LW9mLXR5cGUiOmZ1bmN0aW9uKE0saSl7Zm9yKHZhciBhPWkuZ2V0U2libGluZ3MoTSkscz0wO3M8YS5sZW5ndGg7cysrKWlmKGkuaXNUYWcoYVtzXSkpe2lmKGFbc109PT1NKXJldHVybiEwO2lmKGkuZ2V0TmFtZShhW3NdKT09PWkuZ2V0TmFtZShNKSlicmVha31yZXR1cm4hMX0sImxhc3Qtb2YtdHlwZSI6ZnVuY3Rpb24oTSxpKXtmb3IodmFyIGE9aS5nZXRTaWJsaW5ncyhNKSxzPWEubGVuZ3RoLTE7cz49MDtzLS0paWYoaS5pc1RhZyhhW3NdKSl7aWYoYVtzXT09PU0pcmV0dXJuITA7aWYoaS5nZXROYW1lKGFbc10pPT09aS5nZXROYW1lKE0pKWJyZWFrfXJldHVybiExfSwib25seS1vZi10eXBlIjpmdW5jdGlvbihNLGkpe2Zvcih2YXIgYT1pLmdldFNpYmxpbmdzKE0pLHM9MCxsPWEubGVuZ3RoO3M8bDtzKyspaWYoaS5pc1RhZyhhW3NdKSl7aWYoYVtzXT09PU0pY29udGludWU7aWYoaS5nZXROYW1lKGFbc10pPT09aS5nZXROYW1lKE0pKXJldHVybiExfXJldHVybiEwfSwib25seS1jaGlsZCI6ZnVuY3Rpb24oTSxpKXtmb3IodmFyIGE9aS5nZXRTaWJsaW5ncyhNKSxzPTA7czxhLmxlbmd0aDtzKyspaWYoaS5pc1RhZyhhW3NdKSYmYVtzXSE9PU0pcmV0dXJuITE7cmV0dXJuITB9LGxpbms6ZnVuY3Rpb24oTSxpKXtyZXR1cm4gaS5oYXNBdHRyaWIoTSwiaHJlZiIpfSxzZWxlY3RlZDpmdW5jdGlvbihNLGkpe2lmKGkuaGFzQXR0cmliKE0sInNlbGVjdGVkIikpcmV0dXJuITA7aWYoaS5nZXROYW1lKE0pIT09Im9wdGlvbiIpcmV0dXJuITE7dmFyIGE9aS5nZXRQYXJlbnQoTSk7aWYoIWF8fGkuZ2V0TmFtZShhKSE9PSJzZWxlY3QifHxpLmhhc0F0dHJpYihhLCJtdWx0aXBsZSIpKXJldHVybiExO2Zvcih2YXIgcz1pLmdldENoaWxkcmVuKGEpLGw9ITEsTz0wO088cy5sZW5ndGg7TysrKWlmKGkuaXNUYWcoc1tPXSkpaWYoc1tPXT09PU0pbD0hMDtlbHNlIGlmKGwpe2lmKGkuaGFzQXR0cmliKHNbT10sInNlbGVjdGVkIikpcmV0dXJuITF9ZWxzZSByZXR1cm4hMTtyZXR1cm4gbH0sZGlzYWJsZWQ6ZnVuY3Rpb24oTSxpKXtyZXR1cm4gaS5oYXNBdHRyaWIoTSwiZGlzYWJsZWQiKX0sZW5hYmxlZDpmdW5jdGlvbihNLGkpe3JldHVybiFpLmhhc0F0dHJpYihNLCJkaXNhYmxlZCIpfSxjaGVja2VkOmZ1bmN0aW9uKE0saSl7cmV0dXJuIGkuaGFzQXR0cmliKE0sImNoZWNrZWQiKXx8cC5zZWxlY3RlZChNLGkpfSxyZXF1aXJlZDpmdW5jdGlvbihNLGkpe3JldHVybiBpLmhhc0F0dHJpYihNLCJyZXF1aXJlZCIpfSxvcHRpb25hbDpmdW5jdGlvbihNLGkpe3JldHVybiFpLmhhc0F0dHJpYihNLCJyZXF1aXJlZCIpfSxwYXJlbnQ6ZnVuY3Rpb24oTSxpKXtyZXR1cm4hcC5lbXB0eShNLGkpfSxoZWFkZXI6YihbImgxIiwiaDIiLCJoMyIsImg0IiwiaDUiLCJoNiJdKSxidXR0b246ZnVuY3Rpb24oTSxpKXt2YXIgYT1pLmdldE5hbWUoTSk7cmV0dXJuIGE9PT0iYnV0dG9uInx8YT09PSJpbnB1dCImJmkuZ2V0QXR0cmlidXRlVmFsdWUoTSwidHlwZSIpPT09ImJ1dHRvbiJ9LGlucHV0OmIoWyJpbnB1dCIsInRleHRhcmVhIiwic2VsZWN0IiwiYnV0dG9uIl0pLHRleHQ6ZnVuY3Rpb24oTSxpKXt2YXIgYTtyZXR1cm4gaS5nZXROYW1lKE0pPT09ImlucHV0IiYmKCEoYT1pLmdldEF0dHJpYnV0ZVZhbHVlKE0sInR5cGUiKSl8fGEudG9Mb3dlckNhc2UoKT09PSJ0ZXh0Iil9fTtmdW5jdGlvbiBiKE0pe2lmKHR5cGVvZiBTZXQ8InUiKXt2YXIgaT1uZXcgU2V0KE0pO3JldHVybiBmdW5jdGlvbihhLHMpe3JldHVybiBpLmhhcyhzLmdldE5hbWUoYSkpfX1yZXR1cm4gZnVuY3Rpb24oYSxzKXtyZXR1cm4gTS5pbmRleE9mKHMuZ2V0TmFtZShhKSk+PTB9fWZ1bmN0aW9uIEUoTSxpLGEpe2lmKGE9PT1udWxsKXtpZihNLmxlbmd0aD4yJiZpIT09InNjb3BlIil0aHJvdyBuZXcgRXJyb3IoInBzZXVkby1zZWxlY3RvciA6IitpKyIgcmVxdWlyZXMgYW4gYXJndW1lbnQiKX1lbHNlIGlmKE0ubGVuZ3RoPT09Mil0aHJvdyBuZXcgRXJyb3IoInBzZXVkby1zZWxlY3RvciA6IitpKyIgZG9lc24ndCBoYXZlIGFueSBhcmd1bWVudHMiKX12YXIgeT0vXig/Oig/Om50aHxsYXN0fGZpcnN0fG9ubHkpLSg/OmNoaWxkfG9mLXR5cGUpfHJvb3R8ZW1wdHl8KD86ZW58ZGlzKWFibGVkfGNoZWNrZWR8bm90KSQvO2guZXhwb3J0cz17Y29tcGlsZTpmdW5jdGlvbihNLGksYSxzKXt2YXIgbD1pLm5hbWUsTz1pLmRhdGEsQT1hLmFkYXB0ZXI7aWYoYSYmYS5zdHJpY3QmJiF5LnRlc3QobCkpdGhyb3cgbmV3IEVycm9yKCI6IitsKyIgaXNuJ3QgcGFydCBvZiBDU1MzIik7aWYodHlwZW9mIGNbbF09PSJmdW5jdGlvbiIpcmV0dXJuIGNbbF0oTSxPLGEscyk7aWYodHlwZW9mIHBbbF09PSJmdW5jdGlvbiIpe3ZhciBSPXBbbF07cmV0dXJuIEUoUixsLE8pLFI9PT11P1I6TT09PWc/ZnVuY3Rpb24oUCl7cmV0dXJuIFIoUCxBLE8pfTpmdW5jdGlvbihQKXtyZXR1cm4gUihQLEEsTykmJk0oUCl9fWVsc2UgdGhyb3cgbmV3IEVycm9yKCJ1bm1hdGNoZWQgcHNldWRvLWNsYXNzIDoiK2wpfSxmaWx0ZXJzOmMscHNldWRvczpwfX0sZnVuY3Rpb24oaCxlLHQpe3ZhciByPXQoMjg0KSxuPXQoMjg1KTtoLmV4cG9ydHM9ZnVuY3Rpb24oZyl7cmV0dXJuIG4ocihnKSl9LGguZXhwb3J0cy5wYXJzZT1yLGguZXhwb3J0cy5jb21waWxlPW59LGZ1bmN0aW9uKGgsZSl7aC5leHBvcnRzPXI7dmFyIHQ9L14oWytcLV0/XGQqbik/XHMqKD86KFsrXC1dPylccyooXGQrKSk/JC87ZnVuY3Rpb24gcihuKXtpZihuPW4udHJpbSgpLnRvTG93ZXJDYXNlKCksbj09PSJldmVuIilyZXR1cm5bMiwwXTtpZihuPT09Im9kZCIpcmV0dXJuWzIsMV07dmFyIGQ9bi5tYXRjaCh0KTtpZighZCl0aHJvdyBuZXcgU3ludGF4RXJyb3IoIm4tdGggcnVsZSBjb3VsZG4ndCBiZSBwYXJzZWQgKCciK24rIicpIik7dmFyIGc7cmV0dXJuIGRbMV0/KGc9cGFyc2VJbnQoZFsxXSwxMCksaXNOYU4oZykmJihkWzFdLmNoYXJBdCgwKT09PSItIj9nPS0xOmc9MSkpOmc9MCxbZyxkWzNdP3BhcnNlSW50KChkWzJdfHwiIikrZFszXSwxMCk6MF19fSxmdW5jdGlvbihoLGUsdCl7aC5leHBvcnRzPWc7dmFyIHI9dCgyNzMpLG49ci50cnVlRnVuYyxkPXIuZmFsc2VGdW5jO2Z1bmN0aW9uIGcodSl7dmFyIG89dVswXSxmPXVbMV0tMTtpZihmPDAmJm88PTApcmV0dXJuIGQ7aWYobz09PS0xKXJldHVybiBmdW5jdGlvbihjKXtyZXR1cm4gYzw9Zn07aWYobz09PTApcmV0dXJuIGZ1bmN0aW9uKGMpe3JldHVybiBjPT09Zn07aWYobz09PTEpcmV0dXJuIGY8MD9uOmZ1bmN0aW9uKGMpe3JldHVybiBjPj1mfTt2YXIgeD1mJW87cmV0dXJuIHg8MCYmKHgrPW8pLG8+MT9mdW5jdGlvbihjKXtyZXR1cm4gYz49ZiYmYyVvPT09eH06KG8qPS0xLGZ1bmN0aW9uKGMpe3JldHVybiBjPD1mJiZjJW89PT14fSl9fSxmdW5jdGlvbihoLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBPfSk7dmFyIHI9dCgxMiksbj10KDc0KSxkPXQoMSksZz10KDY4KSx1PXQoMjUwKSxvPXQoMjEzKSxmPXQoMjE4KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24geChBLFIpe2lmKEE9PW51bGwpcmV0dXJue307dmFyIEk9YyhBLFIpLFAsTDtpZihPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKXt2YXIgRD1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKEEpO2ZvcihMPTA7TDxELmxlbmd0aDtMKyspUD1EW0xdLCEoUi5pbmRleE9mKFApPj0wKSYmT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKEEsUCkmJihJW1BdPUFbUF0pfXJldHVybiBJfWZ1bmN0aW9uIGMoQSxSKXtpZihBPT1udWxsKXJldHVybnt9O3ZhciBJPXt9LFA9T2JqZWN0LmtleXMoQSksTCxEO2ZvcihEPTA7RDxQLmxlbmd0aDtEKyspTD1QW0RdLCEoUi5pbmRleE9mKEwpPj0wKSYmKElbTF09QVtMXSk7cmV0dXJuIEl9Y29uc3Qgdj17YW50aWFsaWFzOiEwLGF1dG9SZW5kZXI6ITAsYWxwaGE6ITB9LHA9U3ltYm9sKCJhdXRvUmVuZGVyIiksYj1TeW1ib2woInJlbmRlcmVyIiksRT1TeW1ib2woInRpbWVsaW5lIikseT1TeW1ib2woInByZXBhcmVSZW5kZXIiKSxNPVN5bWJvbCgidGlja1JlbmRlciIpLGk9U3ltYm9sKCJwYXNzIiksYT1TeW1ib2woImZibyIpLHM9U3ltYm9sKCJ0aWNrZXJzIiksbD1TeW1ib2woImxheWVyVHJhbnNmb3JtSW52ZXJ0Iik7Y2xhc3MgTyBleHRlbmRzIHUuZGVmYXVsdHtjb25zdHJ1Y3RvcihSPXt9KXtpZihzdXBlcigpLCFSLmNhbnZhcyl7Y29uc3R7d2lkdGg6RCxoZWlnaHQ6Q309dGhpcy5nZXRSZXNvbHV0aW9uKCksUz1yLkVOVi5jcmVhdGVDYW52YXMoRCxDLHtvZmZzY3JlZW46ISFSLm9mZnNjcmVlbixpZDpSLmlkLGV4dHJhOlIuZXh0cmF9KTtTLnN0eWxlJiYoUy5zdHlsZS5wb3NpdGlvbj0iYWJzb2x1dGUiKSxTLmRhdGFzZXQmJihTLmRhdGFzZXQubGF5ZXJJZD1SLmlkKSxTLmNvbnRleHRUeXBlJiYoUi5jb250ZXh0VHlwZT1TLmNvbnRleHRUeXBlKSxSLmNhbnZhcz1TfWNvbnN0IEk9Ui5jYW52YXMsUD1PYmplY3QuYXNzaWduKHt9LHYsUik7dGhpc1twXT1QLmF1dG9SZW5kZXIsZGVsZXRlIFIuYXV0b1JlbmRlcjtjb25zdCBMPVAuUmVuZGVyZXJ8fHIuUmVuZGVyZXI7dGhpc1tiXT1uZXcgTChJLFApLHRoaXMub3B0aW9ucz1SLHRoaXMuaWQ9Ui5pZCx0aGlzW2ldPVtdLHRoaXMuc2V0UmVzb2x1dGlvbihJKSx0aGlzLmNhbnZhcz1JLHRoaXNbRV09bmV3IG4uVGltZWxpbmUsdGhpcy5fX21vdXNlQ2FwdHVyZWRUYXJnZXQ9bnVsbCx0aGlzW2xdPW51bGx9Z2V0IGF1dG9SZW5kZXIoKXtyZXR1cm4gdGhpc1twXX1nZXQgZGlzcGxheVJhdGlvKCl7cmV0dXJuIHRoaXMucGFyZW50JiZ0aGlzLnBhcmVudC5vcHRpb25zP3RoaXMucGFyZW50Lm9wdGlvbnMuZGlzcGxheVJhdGlvOjF9Z2V0IGhlaWdodCgpe2NvbnN0e2hlaWdodDpSfT10aGlzLmdldFJlc29sdXRpb24oKTtyZXR1cm4gUi90aGlzLmRpc3BsYXlSYXRpb31nZXQgZ2woKXtyZXR1cm4gdGhpcy5yZW5kZXJlci5nbFJlbmRlcmVyP3RoaXMucmVuZGVyZXIuZ2xSZW5kZXJlci5nbDpudWxsfWdldCBsYXllcigpe3JldHVybiB0aGlzfWdldCBvZmZzY3JlZW4oKXtyZXR1cm4hIXRoaXMub3B0aW9ucy5vZmZzY3JlZW58fHRoaXMuY2FudmFzLl9vZmZzY3JlZW59Z2V0IHBhc3MoKXtyZXR1cm4gdGhpc1tpXX1nZXQgcHJlcGFyZVJlbmRlcigpe3JldHVybiB0aGlzW3ldP3RoaXNbeV06UHJvbWlzZS5yZXNvbHZlKCl9Z2V0IHJlbmRlcmVyKCl7cmV0dXJuIHRoaXNbYl19Z2V0IHJlbmRlck9mZnNldCgpe2lmKHRoaXMucGFyZW50JiZ0aGlzLnBhcmVudC5vcHRpb25zKXtjb25zdHtsZWZ0OlIsdG9wOkl9PXRoaXMucGFyZW50Lm9wdGlvbnM7cmV0dXJuW1IsSV19cmV0dXJuW3RoaXMub3B0aW9ucy5sZWZ0fDAsdGhpcy5vcHRpb25zLnRvcHwwXX1nZXQgdGltZWxpbmUoKXtyZXR1cm4gdGhpc1tFXX1nZXQgd2lkdGgoKXtjb25zdHt3aWR0aDpSfT10aGlzLmdldFJlc29sdXRpb24oKTtyZXR1cm4gUi90aGlzLmRpc3BsYXlSYXRpb31nZXQgbG9jYWxNYXRyaXgoKXtjb25zdHt4OlIseTpJfT10aGlzLmF0dHJpYnV0ZXM7cmV0dXJuWzEsMCwwLDEsUixJXX1nZXQgbGF5ZXJUcmFuc2Zvcm1JbnZlcnQoKXtpZih0aGlzW2xdKXJldHVybiB0aGlzW2xdO2NvbnN0IFI9dGhpcy50cmFuc2Zvcm1NYXRyaXg7cmV0dXJuIFJbMF09PT0xJiZSWzFdPT09MCYmUlsyXT09PTAmJlJbM109PT0xJiZSWzRdPT09MCYmUls1XT09PTA/bnVsbDoodGhpc1tsXT1kLm1hdDJkLmludmVydChBcnJheS5vZigwLDAsMCwwLDAsMCksUiksdGhpc1tsXSl9Zm9yY2VDb250ZXh0TG9zcygpe2NvbnN0IFI9dGhpcy5yZW5kZXJlci5nbFJlbmRlcmVyO2lmKFIpe2NvbnN0IEk9Ui5nZXRFeHRlbnNpb24oIldFQkdMX2xvc2VfY29udGV4dCIpO2lmKEkpcmV0dXJuIEkubG9zZUNvbnRleHQoKSwhMH1yZXR1cm4hMX1hZGRQYXNzKHt2ZXJ0ZXg6UixmcmFnbWVudDpJLG9wdGlvbnM6UCx1bmlmb3JtczpMfT17fSl7aWYodGhpcy5yZW5kZXJlci5nbFJlbmRlcmVyKXtjb25zdHt3aWR0aDpELGhlaWdodDpDfT10aGlzLmdldFJlc29sdXRpb24oKSxTPXRoaXMucmVuZGVyZXIuY3JlYXRlUGFzc1Byb2dyYW0oe3ZlcnRleDpSLGZyYWdtZW50Okksb3B0aW9uczpQfSksQj1uZXcgci5GaWd1cmUyRDtCLnJlY3QoMCwwLEQvdGhpcy5kaXNwbGF5UmF0aW8sQy90aGlzLmRpc3BsYXlSYXRpbyk7Y29uc3Qgdz1uZXcgci5NZXNoMkQoQik7cmV0dXJuIHcuc2V0VW5pZm9ybXMoTCksdy5zZXRQcm9ncmFtKFMpLHRoaXNbaV0ucHVzaCh3KSx0aGlzLmZvcmNlVXBkYXRlKCksd31yZXR1cm4gbnVsbH1kZWxldGVUZXh0dXJlKFIpe3JldHVybiBPYmplY3QoZi5kZWxldGVUZXh0dXJlKShSLHRoaXMucmVuZGVyZXIpfWRpc3BhdGNoUG9pbnRlckV2ZW50KFIpe2NvbnN0IEk9Ui50eXBlO2lmKEk9PT0ibW91c2Vkb3duInx8ST09PSJtb3VzZXVwInx8ST09PSJtb3VzZW1vdmUiKXtjb25zdCBTPXRoaXMuX19tb3VzZUNhcHR1cmVkVGFyZ2V0O2lmKFMpe2lmKFMubGF5ZXI9PT10aGlzKXJldHVybiBTLmRpc3BhdGNoRXZlbnQoUiksITA7dGhpcy5fX21vdXNlQ2FwdHVyZWRUYXJnZXQ9bnVsbH19bGV0IFAsTDtjb25zdCBEPXRoaXMubGF5ZXJUcmFuc2Zvcm1JbnZlcnQ7aWYoRCl7UD1SLngsTD1SLnk7Y29uc3QgUz1ELEI9U1swXSpQK1NbMl0qTCtTWzRdLHc9U1sxXSpQK1NbM10qTCtTWzVdO2RlbGV0ZSBSLngsZGVsZXRlIFIueSxkZWxldGUgUi5sYXllclgsZGVsZXRlIFIubGF5ZXJZLE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFIse2xheWVyWDp7dmFsdWU6Qixjb25maWd1cmFibGU6ITB9LGxheWVyWTp7dmFsdWU6dyxjb25maWd1cmFibGU6ITB9LHg6e3ZhbHVlOkIsY29uZmlndXJhYmxlOiEwfSx5Ont2YWx1ZTp3LGNvbmZpZ3VyYWJsZTohMH19KX1jb25zdCBDPXN1cGVyLmRpc3BhdGNoUG9pbnRlckV2ZW50KFIpO3JldHVybiBEJiZPYmplY3QuZGVmaW5lUHJvcGVydGllcyhSLHtsYXllclg6e3ZhbHVlOlAsY29uZmlndXJhYmxlOiEwfSxsYXllclk6e3ZhbHVlOkwsY29uZmlndXJhYmxlOiEwfSx4Ont2YWx1ZTpQLGNvbmZpZ3VyYWJsZTohMH0seTp7dmFsdWU6TCxjb25maWd1cmFibGU6ITB9fSksQ31mb3JjZVVwZGF0ZSgpe2lmKCF0aGlzW3ldKWlmKHRoaXMucGFyZW50JiZ0aGlzLnBhcmVudC5oYXNPZmZzY3JlZW5DYW52YXMpe3RoaXMucGFyZW50LmZvcmNlVXBkYXRlKCk7bGV0IFI9bnVsbDtjb25zdCBJPW5ldyBQcm9taXNlKFA9PntSPVB9KTtJLl9yZXNvbHZlPVIsdGhpc1t5XT1JfWVsc2V7bGV0IFI9bnVsbCxJPW51bGw7Y29uc3QgUD1uZXcgUHJvbWlzZShMPT57Uj1MLHRoaXNbcF0mJihJPU9iamVjdChnLnJlcXVlc3RBbmltYXRpb25GcmFtZSkoKCk9PntkZWxldGUgUC5fcmVxdWVzdElELHRoaXMucmVuZGVyKCl9KSl9KTtQLl9yZXNvbHZlPVIsUC5fcmVxdWVzdElEPUksdGhpc1t5XT1QfX1nZXRGQk8oKXtjb25zdCBSPXRoaXMucmVuZGVyZXIuZ2xSZW5kZXJlcix7d2lkdGg6SSxoZWlnaHQ6UH09dGhpcy5nZXRSZXNvbHV0aW9uKCk7cmV0dXJuIFImJighdGhpc1thXXx8dGhpc1thXS53aWR0aCE9PUl8fHRoaXNbYV0uaGVpZ2h0IT09UCk/KHRoaXNbYV09e3dpZHRoOkksaGVpZ2h0OlAsdGFyZ2V0OlIuY3JlYXRlRkJPKCksYnVmZmVyOlIuY3JlYXRlRkJPKCksc3dhcCgpe1t0aGlzLnRhcmdldCx0aGlzLmJ1ZmZlcl09W3RoaXMuYnVmZmVyLHRoaXMudGFyZ2V0XX19LHRoaXNbYV0pOnRoaXNbYV0/dGhpc1thXTpudWxsfXVwZGF0ZUdsb2JhbFRyYW5zZm9ybSgpe2lmKHRoaXMubGF5ZXJUcmFuc2Zvcm1JbnZlcnQpe2NvbnN0IFI9dGhpcy5yZW5kZXJlcixJPVIuX19nbG9iYWxUcmFuc2Zvcm1NYXRyaXh8fFIuZ2xvYmFsVHJhbnNmb3JtTWF0cml4O1IuX19nbG9iYWxUcmFuc2Zvcm1NYXRyaXg9STtjb25zdCBQPWQubWF0MmQuZnJvbVZhbHVlcygxLDAsMCwxLDAsMCk7Ui5zZXRHbG9iYWxUcmFuc2Zvcm0oLi4uZC5tYXQyZC5tdWx0aXBseShQLEksdGhpcy50cmFuc2Zvcm1NYXRyaXgpKX19b25Qcm9wZXJ0eUNoYW5nZShSLEksUCl7aWYoc3VwZXIub25Qcm9wZXJ0eUNoYW5nZShSLEksUCksUj09PSJ6SW5kZXgiJiYodGhpcy5jYW52YXMuc3R5bGUuekluZGV4PUkpLFI9PT0idHJhbnNmb3JtInx8Uj09PSJ0cmFuc2xhdGUifHxSPT09InJvdGF0ZSJ8fFI9PT0ic2NhbGUifHxSPT09InNrZXciKXtjb25zdCBMPXRoaXNbbF07aWYodGhpc1tsXT1udWxsLHRoaXMudXBkYXRlR2xvYmFsVHJhbnNmb3JtKCksTCYmIXRoaXMubGF5ZXJUcmFuc2Zvcm1JbnZlcnQpe2NvbnN0IEQ9dGhpcy5yZW5kZXJlcixDPUQuX19nbG9iYWxUcmFuc2Zvcm1NYXRyaXh8fEQuZ2xvYmFsVHJhbnNmb3JtTWF0cml4O0Quc2V0R2xvYmFsVHJhbnNmb3JtKC4uLkMpfX19X3ByZXBhcmVSZW5kZXJGaW5pc2hlZCgpe3RoaXNbeV0mJih0aGlzW3ldLl9yZXF1ZXN0SUQmJk9iamVjdChnLmNhbmNlbEFuaW1hdGlvbkZyYW1lKSh0aGlzW3ldLl9yZXF1ZXN0SUQpLHRoaXNbeV0uX3Jlc29sdmUoKSxkZWxldGUgdGhpc1t5XSl9cmVuZGVyKHtjbGVhcjpSPSEwfT17fSl7Y29uc3QgST10aGlzW2ldLmxlbmd0aD90aGlzLmdldEZCTygpOm51bGw7SSYmdGhpcy5yZW5kZXJlci5nbFJlbmRlcmVyLmJpbmRGQk8oSS50YXJnZXQpLFImJnRoaXNbYl0uY2xlYXIoKTtjb25zdCBQPXRoaXMuZHJhdygpO2lmKFAmJlAubGVuZ3RoJiYodGhpcy5yZW5kZXJlci5kcmF3TWVzaGVzKFApLHRoaXMuY2FudmFzLmRyYXcmJnRoaXMuY2FudmFzLmRyYXcoKSksSSl7Y29uc3QgTD10aGlzLnJlbmRlcmVyLmdsUmVuZGVyZXIsRD10aGlzW2ldLmxlbmd0aCx7d2lkdGg6QyxoZWlnaHQ6U309dGhpcy5nZXRSZXNvbHV0aW9uKCksQj1bMCwwLEMvdGhpcy5kaXNwbGF5UmF0aW8sUy90aGlzLmRpc3BsYXlSYXRpb107dGhpc1tpXS5mb3JFYWNoKCh3LEgpPT57dy5ibGVuZD0hMCx3LnNldFRleHR1cmUoSS50YXJnZXQudGV4dHVyZSx7cmVjdDpCfSksSD09PUQtMT9MLmJpbmRGQk8obnVsbCk6KEkuc3dhcCgpLEwuYmluZEZCTyhJLnRhcmdldCkpLHRoaXNbYl0uY2xlYXIoKSx0aGlzLnJlbmRlcmVyLmRyYXdNZXNoZXMoW3ddKX0pfXRoaXMuX3ByZXBhcmVSZW5kZXJGaW5pc2hlZCgpfXNldFJlc29sdXRpb24oe3dpZHRoOlIsaGVpZ2h0Okl9KXtjb25zdCBQPXRoaXMucmVuZGVyZXIsTD1QLl9fZ2xvYmFsVHJhbnNmb3JtTWF0cml4fHxQLmdsb2JhbFRyYW5zZm9ybU1hdHJpeCxEPUxbNF0sQz1MWzVdLFM9TFswXSx7d2lkdGg6QixoZWlnaHQ6d309dGhpcy5nZXRSZXNvbHV0aW9uKCk7KEIhPT1SfHx3IT09SSkmJihzdXBlci5zZXRSZXNvbHV0aW9uKHt3aWR0aDpSLGhlaWdodDpJfSksdGhpcy5jYW52YXMmJih0aGlzLmNhbnZhcy53aWR0aD1SLHRoaXMuY2FudmFzLmhlaWdodD1JLFAudXBkYXRlUmVzb2x1dGlvbiYmUC51cGRhdGVSZXNvbHV0aW9uKCkpLHRoaXMuYXR0cmlidXRlcy5zaXplPVtSLEldLHRoaXNbaV0ubGVuZ3RoJiZ0aGlzW2ldLmZvckVhY2goVT0+e2NvbnN0IEc9bmV3IHIuRmlndXJlMkQ7Ry5yZWN0KDAsMCxSL3RoaXMuZGlzcGxheVJhdGlvLEkvdGhpcy5kaXNwbGF5UmF0aW8pLFUuY29udG91cnM9Ry5jb250b3Vyc30pKTtjb25zdFtILEpdPXRoaXMucmVuZGVyT2Zmc2V0LHE9dGhpcy5kaXNwbGF5UmF0aW87KEQhPT1IfHxDIT09Snx8UyE9PXEpJiYoUC5zZXRHbG9iYWxUcmFuc2Zvcm0ocSwwLDAscSxILEopLFAuX19nbG9iYWxUcmFuc2Zvcm1NYXRyaXg9bnVsbCx0aGlzW2xdPW51bGwsdGhpcy51cGRhdGVHbG9iYWxUcmFuc2Zvcm0oKSx0aGlzLmZvcmNlVXBkYXRlKCkpfXRpY2soUj1udWxsLEk9e30pe2xldHtkdXJhdGlvbjpQPTEvMH09SSxMPXgoSSxbImR1cmF0aW9uIl0pO2NvbnN0IEQ9dGhpcy50aW1lbGluZS5mb3JrKEwpLEM9dGhpczt0aGlzW3NdPXRoaXNbc118fFtdLHRoaXNbc10ucHVzaCh7aGFuZGxlcjpSLGR1cmF0aW9uOlB9KTtjb25zdCBTPSgpPT57bGV0IEI9bnVsbCx3PW51bGw7Y29uc3QgSD0oKT0+e2NvbnN0IEo9dGhpc1tzXS5tYXAoKHtoYW5kbGVyOnEsZHVyYXRpb246VX0pPT57Y29uc3QgRz1NYXRoLm1pbigxLEQuY3VycmVudFRpbWUvVSk7cmV0dXJue3ZhbHVlOnE/cShELmN1cnJlbnRUaW1lLEcpOm51bGwscDpHfX0pO0NbTV18fChDW01dPVByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCk9PntDW3BdJiZDLnJlbmRlcigpLGRlbGV0ZSBDW01dO2ZvcihsZXQgcT1KLmxlbmd0aC0xO3E+PTA7cS0tKXtjb25zdHt2YWx1ZTpVLHA6R309SltxXTsoVT09PSExfHxHPj0xKSYmdGhpc1tzXS5zcGxpY2UocSwxKX10aGlzW3NdLmxlbmd0aD4wJiZTKCl9KSl9O2lmKHRoaXNbeV0mJnRoaXNbeV0uX3R5cGUhPT0idGlja2VyIiYmKE9iamVjdChnLmNhbmNlbEFuaW1hdGlvbkZyYW1lKSh0aGlzW3ldLl9yZXF1ZXN0SUQpLGRlbGV0ZSB0aGlzW3ldKSwhdGhpc1t5XSl7Y29uc3QgSj1uZXcgUHJvbWlzZShxPT57Qj1xLHc9T2JqZWN0KGcucmVxdWVzdEFuaW1hdGlvbkZyYW1lKShIKX0pO0ouX3Jlc29sdmU9QixKLl9yZXF1ZXN0SUQ9dyxKLl90eXBlPSJ0aWNrZXIiLHRoaXNbeV09Sn19O1MoKX10b0dsb2JhbFBvcyhSLEkpe2lmKHRoaXMubGF5ZXJUcmFuc2Zvcm1JbnZlcnQpe2NvbnN0IEI9dGhpcy50cmFuc2Zvcm1NYXRyaXg7Uj1CWzBdKlIrQlsyXSpJK0JbNF0sST1CWzFdKlIrQlszXSpJK0JbNV19Y29uc3R7d2lkdGg6UCxoZWlnaHQ6TH09dGhpcy5nZXRSZXNvbHV0aW9uKCksRD10aGlzLnJlbmRlck9mZnNldCxDPVt0aGlzLmNhbnZhcy5jbGllbnRXaWR0aCx0aGlzLmNhbnZhcy5jbGllbnRIZWlnaHRdO1I9UipDWzBdL1ArRFswXSxJPUkqQ1sxXS9MK0RbMV07Y29uc3QgUz10aGlzLmRpc3BsYXlSYXRpbztyZXR1cm4gUio9UyxJKj1TLFtSLEldfXRvTG9jYWxQb3MoUixJKXtjb25zdHt3aWR0aDpQLGhlaWdodDpMfT10aGlzLmdldFJlc29sdXRpb24oKSxEPXRoaXMucmVuZGVyT2Zmc2V0LEM9W3RoaXMuY2FudmFzLmNsaWVudFdpZHRoLHRoaXMuY2FudmFzLmNsaWVudEhlaWdodF07Uj1SKlAvQ1swXS1EWzBdLEk9SSpML0NbMV0tRFsxXTtjb25zdCBTPXRoaXMuZGlzcGxheVJhdGlvO1IvPVMsSS89Uztjb25zdCBCPXRoaXMubGF5ZXJUcmFuc2Zvcm1JbnZlcnQ7cmV0dXJuIEImJihSPUJbMF0qUitCWzJdKkkrQls0XSxJPUJbMV0qUitCWzNdKkkrQls1XSksW1IsSV19fW8uZGVmYXVsdC5yZWdpc3Rlck5vZGUoTywibGF5ZXIiKX0sZnVuY3Rpb24oaCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4geX0pO3ZhciByPXQoMjI0KSxuPXQoMjg4KSxkPXQoMjEzKSxnPXQoMjUyKSx1PXQoNzIpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBvKE0saSl7aWYoTT09bnVsbClyZXR1cm57fTt2YXIgYT1mKE0saSkscyxsO2lmKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpe3ZhciBPPU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoTSk7Zm9yKGw9MDtsPE8ubGVuZ3RoO2wrKylzPU9bbF0sIShpLmluZGV4T2Yocyk+PTApJiZPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoTSxzKSYmKGFbc109TVtzXSl9cmV0dXJuIGF9ZnVuY3Rpb24gZihNLGkpe2lmKE09PW51bGwpcmV0dXJue307dmFyIGE9e30scz1PYmplY3Qua2V5cyhNKSxsLE87Zm9yKE89MDtPPHMubGVuZ3RoO08rKylsPXNbT10sIShpLmluZGV4T2YobCk+PTApJiYoYVtsXT1NW2xdKTtyZXR1cm4gYX1mdW5jdGlvbiB4KE0saSxhKXtyZXR1cm4gaSBpbiBNP09iamVjdC5kZWZpbmVQcm9wZXJ0eShNLGkse3ZhbHVlOmEsZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTpNW2ldPWEsTX1jb25zdCBjPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIsdj1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGUiKSxwPVN5bWJvbCgicm9vdCIpLGI9U3ltYm9sKCJ0YXNrIik7ZnVuY3Rpb24gRShNLGk9ITApe2NvbnN0IGE9TVtwXTtpZihhJiZhLmNoaWxkcmVuWzBdKXtjb25zdCBzPU0uc3ZnLGw9TS5sYXllcj9NLmxheWVyLmRpc3BsYXlSYXRpbzoxO2lmKCFzLmhhc0F0dHJpYnV0ZSgiZGF0YS1vcmlnaW5hbC13aWR0aCIpKXtsZXQgUj1zLmdldEF0dHJpYnV0ZSgid2lkdGgiKTtSPVI/T2JqZWN0KHUuc2l6ZVRvUGl4ZWwpKFIpOjMwMDtsZXQgST1zLmdldEF0dHJpYnV0ZSgiaGVpZ2h0Iik7ST1JP09iamVjdCh1LnNpemVUb1BpeGVsKShJKToxNTAscy5oYXNBdHRyaWJ1dGUoInZpZXdCb3giKXx8cy5zZXRBdHRyaWJ1dGUoInZpZXdCb3giLGAwIDAgJHtNYXRoLnJvdW5kKFIpfSAke01hdGgucm91bmQoSSl9YCkscy5zZXRBdHRyaWJ1dGUoImRhdGEtb3JpZ2luYWwtd2lkdGgiLFIpLHMuc2V0QXR0cmlidXRlKCJkYXRhLW9yaWdpbmFsLWhlaWdodCIsSSl9bGV0IE89TS5hdHRyaWJ1dGVzLndpZHRofHxOdW1iZXIocy5nZXRBdHRyaWJ1dGUoImRhdGEtb3JpZ2luYWwtd2lkdGgiKSksQT1NLmF0dHJpYnV0ZXMuaGVpZ2h0fHxOdW1iZXIocy5nZXRBdHRyaWJ1dGUoImRhdGEtb3JpZ2luYWwtaGVpZ2h0IikpO2lmKE8qPWwsQSo9bCxpJiZNLmF0dHJpYnV0ZXMuZmxleGlibGUpe2NvbnN0IFI9TS5hdHRyaWJ1dGVzLnNjYWxlWzBdO2lmKE8qPVIsQSo9UixzLnNldEF0dHJpYnV0ZSgid2lkdGgiLE8pLHMuc2V0QXR0cmlidXRlKCJoZWlnaHQiLEEpLE8mJkEmJk0udGV4dHVyZUltYWdlKXtjb25zdCBJPU0udGV4dHVyZUltYWdlLndpZHRoLFA9TS50ZXh0dXJlSW1hZ2UuaGVpZ2h0LEw9TS5jbGllbnRTaXplO00uYXR0cmlidXRlcy50ZXh0dXJlUmVjdD1bMCwwLE1hdGgucm91bmQoTFswXSpJL08pLE1hdGgucm91bmQoTFsxXSpQL0EpXX19ZWxzZSBNW2JdfHwocy5zZXRBdHRyaWJ1dGUoIndpZHRoIixPKSxzLnNldEF0dHJpYnV0ZSgiaGVpZ2h0IixBKSxNW2JdPVByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCk9PntkZWxldGUgTVtiXTtjb25zdCBSPWEuaW5uZXJIVE1MLEk9bmV3IEJsb2IoW1JdLHt0eXBlOiJpbWFnZS9zdmcreG1sIn0pLFA9VVJMLmNyZWF0ZU9iamVjdFVSTChJKSxMPW5ldyBJbWFnZTtMLm9ubG9hZD1mdW5jdGlvbigpe0wud2lkdGgmJkwuaGVpZ2h0PyhNLmF0dHJpYnV0ZXNbdl0oInRleHR1cmUiLEwpLE0uYXR0cmlidXRlcy5mbGV4aWJsZSYmKE0uYXR0cmlidXRlcy50ZXh0dXJlUmVjdD1udWxsKSk6TS5hdHRyaWJ1dGVzW3ZdKCJ0ZXh0dXJlIixudWxsKX0sTC5zcmM9UH0pKX19Y2xhc3MgeSBleHRlbmRzIHIuZGVmYXVsdHtjb25zdHJ1Y3RvcihpPXt9KXt0eXBlb2YgaT09InN0cmluZyImJihpPXtzdmdUZXh0Oml9KTtsZXR7c3ZnVGV4dDphfT1pLHM9byhpLFsic3ZnVGV4dCJdKTtpZihzdXBlcihzKSx0aGlzW3BdPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpLGEpe3RoaXNbcF0uaW5uZXJIVE1MPWE7Y29uc3QgbD10aGlzW3BdLmNoaWxkcmVuWzBdO2w/bC5zZXRBdHRyaWJ1dGUoInhtbG5zIixjKTooZmV0Y2goYSkudGhlbihPPT5PLnRleHQoKSkudGhlbihPPT57dGhpc1twXS5pbm5lckhUTUw9TywoIXRoaXMub2JzZXJ2ZXJ8fHRoaXMuYXR0cmlidXRlcy5mbGV4aWJsZSkmJkUodGhpcyl9KSxhPW51bGwpfWlmKCFhKXtjb25zdCBsPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhjLCJzdmciKTtsLnNldEF0dHJpYnV0ZSgieG1sbnMiLGMpLHRoaXNbcF0uYXBwZW5kQ2hpbGQobCl9aWYodHlwZW9mIE11dGF0aW9uT2JzZXJ2ZXI9PSJmdW5jdGlvbiIpe2NvbnN0IGw9bmV3IE11dGF0aW9uT2JzZXJ2ZXIoTz0+e0UodGhpcywhMSl9KTtsLm9ic2VydmUodGhpc1twXSx7YXR0cmlidXRlczohMCxzdWJ0cmVlOiEwLGNoYXJhY3RlckRhdGE6ITAsY2hpbGRMaXN0OiEwfSksdGhpcy5vYnNlcnZlcj1sfX1nZXQgY2hpbGRyZW4oKXtyZXR1cm5bdGhpcy5zdmddfWdldCBjaGlsZE5vZGVzKCl7cmV0dXJuW3RoaXMuc3ZnXX1nZXQgc3ZnKCl7cmV0dXJuIHRoaXNbcF0/dGhpc1twXS5jaGlsZHJlblswXTpudWxsfXNldFJlc29sdXRpb24oe3dpZHRoOmksaGVpZ2h0OmF9KXtzdXBlci5zZXRSZXNvbHV0aW9uKHt3aWR0aDppLGhlaWdodDphfSksRSh0aGlzKX1kaXNwYXRjaFBvaW50ZXJFdmVudChpKXtjb25zdCBhPXN1cGVyLmRpc3BhdGNoUG9pbnRlckV2ZW50KGkpO2lmKGEmJnRoaXMuYXR0cmlidXRlcy5wYXNzRXZlbnRzJiZ0eXBlb2YgTW91c2VFdmVudD09ImZ1bmN0aW9uIil7Y29uc3R7eDpzLHk6bH09aTtsZXRbTyxBXT10aGlzLmdldE9mZnNldFBvc2l0aW9uKHMsbCk7Y29uc3QgUj1pLm9yaWdpbmFsRXZlbnQsST10aGlzLmF0dHJpYnV0ZXMuYW5jaG9yLFA9dGhpcy5jbGllbnRTaXplO089KE8rSVswXSpQWzBdKS8yLEE9KEErSVsxXSpQWzFdKS8yO2NvbnN0IEw9aS50eXBlO2lmKEw9PT1SLnR5cGUpe2xldCBEPW51bGw7aWYoUiBpbnN0YW5jZW9mIE1vdXNlRXZlbnQpRD1uZXcgTW91c2VFdmVudChMLHtzY3JlZW5YOk8sc2NyZWVuWTpBLGNsaWVudFg6TyxjbGllbnRZOkEsYnViYmxlczpSLmJ1YmJsZXMsYnV0dG9uOlIuYnV0dG9uLGJ1dHRvbnM6Ui5idXR0b25zLGNhbmNlbEJ1YmJsZTpSLmNhbmNlbEJ1YmJsZSxjYW5jZWxhYmxlOlIuY2FuY2VsYWJsZSxjdXJyZW50VGFyZ2V0OlIuY3VycmVudFRhcmdldCxmcm9tRWxlbWVudDpSLmZyb21FbGVtZW50LHJlbGF0ZWRUYXJnZXQ6Ui5yZWxhdGVkVGFyZ2V0LHJldHVyblZhbHVlOlIucmV0dXJuVmFsdWUsc3JjRWxlbWVudDpSLnNyY0VsZW1lbnQsdGFyZ2V0OlIudGFyZ2V0LHRvRWxlbWVudDpSLnRvRWxlbWVudCx3aGljaDpSLndpdGNofSk7ZWxzZSBpZihSIGluc3RhbmNlb2YgVG91Y2hFdmVudCl7bGV0IEM9bnVsbDtjb25zdCBTPVIuY2hhbmdlZFRvdWNoZXN8fFtSXTtmb3IobGV0IEI9MDtCPFMubGVuZ3RoO0IrKyl7Y29uc3Qgdz1TW0JdO2lmKGkuaWRlbnRpZmllcj09PXcuaWRlbnRpZmllcil7Qz13O2JyZWFrfX1pZihDKXtjb25zdCBCPW5ldyBUb3VjaCh7aWRlbnRpZmllcjpDLmlkZW50aWZpZXIsdGFyZ2V0OkMudGFyZ2V0LGNsaWVudFg6TyxjbGllbnRZOkEsc2NyZWVuWDpPLHNjcmVlblk6QSxwYWdlWDpPLHBhZ2VZOkEscmFkaXVzWDpDLnJhZGl1c1gscmFkaXVzWTpDLnJhZGl1c1kscm90YXRpb25BbmdsZTpDLnJvdGF0aW9uQW5nbGUsZm9yY2U6Qy5mb3JjZX0pO0Q9bmV3IFRvdWNoRXZlbnQoTCx7Y2FuY2VsYWJsZTpSLmNhbmNlbGFibGUsYnViYmxlczpSLmJ1YmJsZXMsY29tcG9zZWQ6Ui5jb21wb3NlZCx0b3VjaGVzOltCXSx0YXJnZXRUb3VjaGVzOltCXSxjaGFuZ2VkVG91Y2hlczpbQl19KX19ZWxzZSBEPVI7RCYmdGhpcy5zdmcuZGlzcGF0Y2hFdmVudChEKX19cmV0dXJuIGF9Z2V0RWxlbWVudEJ5SWQoaSl7cmV0dXJuIE9iamVjdChnLnF1ZXJ5U2VsZWN0b3IpKGAjJHtpfWAsdGhpcyl9Z2V0RWxlbWVudHNCeUNsYXNzTmFtZShpKXtyZXR1cm4gT2JqZWN0KGcucXVlcnlTZWxlY3RvckFsbCkoYC4ke2l9YCx0aGlzKX1nZXRFbGVtZW50c0J5TmFtZShpKXtyZXR1cm4gT2JqZWN0KGcucXVlcnlTZWxlY3RvckFsbCkoYFtuYW1lPSIke2l9Il1gLHRoaXMpfWdldEVsZW1lbnRzQnlUYWdOYW1lKGkpe3JldHVybiBPYmplY3QoZy5xdWVyeVNlbGVjdG9yQWxsKShpLHRoaXMpfXF1ZXJ5U2VsZWN0b3IoaSl7cmV0dXJuIE9iamVjdChnLnF1ZXJ5U2VsZWN0b3IpKGksdGhpcyl9cXVlcnlTZWxlY3RvckFsbChpKXtyZXR1cm4gT2JqZWN0KGcucXVlcnlTZWxlY3RvckFsbCkoaSx0aGlzKX1vblByb3BlcnR5Q2hhbmdlKGksYSxzKXtzdXBlci5vblByb3BlcnR5Q2hhbmdlKGksYSxzKSxpPT09ImZsZXhpYmxlIiYmRSh0aGlzKSx0aGlzLmF0dHJpYnV0ZXMuZmxleGlibGUmJihpPT09IndpZHRoInx8aT09PSJoZWlnaHQifHxpPT09InNjYWxlInx8aT09PSJ0cmFuc2Zvcm0iKSYmRSh0aGlzKX19eCh5LCJBdHRyIixuLmRlZmF1bHQpLGQuZGVmYXVsdC5yZWdpc3Rlck5vZGUoeSwic3ByaXRlc3ZnIil9LGZ1bmN0aW9uKGgsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIHV9KTt2YXIgcj10KDIyNSk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IG49U3ltYm9sLmZvcigic3ByaXRlanNfZ2V0QXR0cmlidXRlIiksZD1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGUiKSxnPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZURlZmF1bHQiKTtjbGFzcyB1IGV4dGVuZHMgci5kZWZhdWx0e2NvbnN0cnVjdG9yKGYpe3N1cGVyKGYpLHRoaXNbZ10oe3Bhc3NFdmVudHM6ITEsZmxleGlibGU6ITF9KX1nZXQgdGV4dHVyZSgpe3JldHVybiB0aGlzW25dKCJ0ZXh0dXJlIil9c2V0IHRleHR1cmUoZil7fWdldCBwYXNzRXZlbnRzKCl7cmV0dXJuIHRoaXNbbl0oInBhc3NFdmVudHMiKX1zZXQgcGFzc0V2ZW50cyhmKXtyZXR1cm4gdGhpc1tkXSgicGFzc0V2ZW50cyIsZil9Z2V0IGZsZXhpYmxlKCl7cmV0dXJuIHRoaXNbbl0oImZsZXhpYmxlIil9c2V0IGZsZXhpYmxlKGYpe3JldHVybiB0aGlzW2RdKCJmbGV4aWJsZSIsZil9fX0sZnVuY3Rpb24oaCxlLHQpe3QucihlKTt2YXIgcj10KDEyKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gbihmLHgpe3ZhciBjPU9iamVjdC5rZXlzKGYpO2lmKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpe3ZhciB2PU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZik7eCYmKHY9di5maWx0ZXIoZnVuY3Rpb24ocCl7cmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZixwKS5lbnVtZXJhYmxlfSkpLGMucHVzaC5hcHBseShjLHYpfXJldHVybiBjfWZ1bmN0aW9uIGQoZil7Zm9yKHZhciB4PTE7eDxhcmd1bWVudHMubGVuZ3RoO3grKyl7dmFyIGM9YXJndW1lbnRzW3hdIT1udWxsP2FyZ3VtZW50c1t4XTp7fTt4JTI/bihPYmplY3QoYyksITApLmZvckVhY2goZnVuY3Rpb24odil7ZyhmLHYsY1t2XSl9KTpPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycz9PYmplY3QuZGVmaW5lUHJvcGVydGllcyhmLE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKGMpKTpuKE9iamVjdChjKSkuZm9yRWFjaChmdW5jdGlvbih2KXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZix2LE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYyx2KSl9KX1yZXR1cm4gZn1mdW5jdGlvbiBnKGYseCxjKXtyZXR1cm4geCBpbiBmP09iamVjdC5kZWZpbmVQcm9wZXJ0eShmLHgse3ZhbHVlOmMsZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTpmW3hdPWMsZn1jb25zdCB1PVN5bWJvbCgiaW5pdGVkIik7bGV0IG89bnVsbDt0eXBlb2YgV29ya2VyPT0iZnVuY3Rpb24iJiYobz1jbGFzcyBleHRlbmRzIFdvcmtlcntjb25zdHJ1Y3RvcihmKXtpZihmLndvcmtlcj09PSEwJiYoZi53b3JrZXI9YC4vJHtmLmlkfS53b3JrZXIuanNgKSxzdXBlcihmLndvcmtlciksdGhpcy5vcHRpb25zPWYsIWYuY2FudmFzKXtjb25zdHt3aWR0aDp4LGhlaWdodDpjfT10aGlzLmdldFJlc29sdXRpb24oKSx2PXIuRU5WLmNyZWF0ZUNhbnZhcyh4LGMse29mZnNjcmVlbjohMX0pO3Yuc3R5bGUmJih2LnN0eWxlLnBvc2l0aW9uPSJhYnNvbHV0ZSIpLHYuZGF0YXNldCYmKHYuZGF0YXNldC5sYXllcklkPWYuaWQpLGYuY2FudmFzPXZ9dGhpcy5jYW52YXM9Zi5jYW52YXN9Z2V0IGlkKCl7cmV0dXJuIHRoaXMub3B0aW9ucy5pZH1zZXRSZXNvbHV0aW9uKHt3aWR0aDpmLGhlaWdodDp4fSl7aWYodGhpc1t1XSl0aGlzLnBvc3RNZXNzYWdlKHt0eXBlOiJyZXNvbHV0aW9uX2NoYW5nZSIsd2lkdGg6ZixoZWlnaHQ6eH0pO2Vsc2V7dGhpcy5jYW52YXMud2lkdGg9Zix0aGlzLmNhbnZhcy5oZWlnaHQ9eDtjb25zdCBjPXRoaXMub3B0aW9ucyx2PWMuY2FudmFzLnRyYW5zZmVyQ29udHJvbFRvT2Zmc2NyZWVuKCkscD1kKHt9LGMpO2RlbGV0ZSBwLmNvbnRhaW5lcixwLmNhbnZhcz12LHRoaXMucG9zdE1lc3NhZ2Uoe3R5cGU6ImNyZWF0ZSIsb3B0aW9uczpwfSxbdl0pLHRoaXNbdV09ITB9fWdldFJlc29sdXRpb24oKXtpZih0aGlzLmNhbnZhcyl7Y29uc3R7d2lkdGg6ZixoZWlnaHQ6eH09dGhpcy5jYW52YXM7cmV0dXJue3dpZHRoOmYsaGVpZ2h0Onh9fXJldHVybnt3aWR0aDozMDAsaGVpZ2h0OjE1MH19cmVtb3ZlKCl7cmV0dXJuIHRoaXMucGFyZW50JiZ0aGlzLnBhcmVudC5yZW1vdmVDaGlsZD8odGhpcy5wYXJlbnQucmVtb3ZlQ2hpbGQodGhpcyksITApOiExfWNvbm5lY3QoZix4KXtPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywicGFyZW50Iix7dmFsdWU6Zix3cml0YWJsZTohMSxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiek9yZGVyIix7dmFsdWU6eCx3cml0YWJsZTohMSxjb25maWd1cmFibGU6ITB9KX1kaXNjb25uZWN0KCl7ZGVsZXRlIHRoaXMucGFyZW50LGRlbGV0ZSB0aGlzLnpPcmRlcn1kaXNwYXRjaFBvaW50ZXJFdmVudChmKXt0aGlzLnBvc3RNZXNzYWdlKHt0eXBlOiJldmVudCIsZXZlbnQ6e2NhbmNlbEJ1YmJsZTpmLmNhbmNlbEJ1YmJsZSxidWJibGVzOmYuYnViYmxlcyxkZXRhaWw6Zi5kZXRhaWwsaWRlbnRpZmllcjpmLmlkZW50aWZpZXIsbGF5ZXJYOmYubGF5ZXJYLGxheWVyWTpmLmxheWVyWSxvcmlnaW5hbFg6Zi5vcmlnaW5hbFgsb3JpZ2luYWxZOmYub3JpZ2luYWxZLHR5cGU6Zi50eXBlLHg6Zi54LHk6Zi55fX0pfX0pLGUuZGVmYXVsdD1vfSxmdW5jdGlvbihoLGUsdCl7dC5yKGUpLChmdW5jdGlvbihyKXt0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gT30pO3ZhciBuPXQoMTIpLGQ9dCg2OCksZz10KDcwKSx1PXQoMjg2KSxvPXQoMjg5KSxmPXQoMjUwKSx4PXQoMjkxKSxjPXQoMjE0KSx2PXQoMjE4KSxwPXQoMjEzKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3QgYj1TeW1ib2woImVudGVyZWRUYXJnZXRzIik7ZnVuY3Rpb24gRShBKXtyZXR1cm4gQS5pZD1BLmlkfHxgX2xheWVyJHtNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyLDEyKX1gLEEuZGF0YXNldHx8KEEuZGF0YXNldD17fSksQS5kYXRhc2V0LmxheWVySWQ9QS5pZCxBLmNvbm5lY3Q9KFIsSSk9PntBLnBhcmVudD1SLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBLCJ6T3JkZXIiLHt2YWx1ZTpJLHdyaXRhYmxlOiExLGNvbmZpZ3VyYWJsZTohMH0pfSxBLmRpc2Nvbm5lY3Q9Uj0+e2RlbGV0ZSBBLnpPcmRlcn0sQS5jYW52YXM9QSxBLmdldFJlc29sdXRpb249KCk9Pih7d2lkdGg6MCxoZWlnaHQ6MH0pLEEuc2V0UmVzb2x1dGlvbj0oKT0+ITEsQS5vcHRpb25zPXtoYW5kbGVFdmVudDohMX0sQX1mdW5jdGlvbiB5KEEsUil7Y29uc3QgST1BLmNoaWxkcmVuO2xldCBQPW51bGw7Zm9yKGxldCBMPTA7TDxJLmxlbmd0aDtMKyspe2NvbnN0IEQ9SVtMXTtpZigoUj09PUR8fFAhPW51bGwpJiYoUD1EKSxQJiZQIT09UiYmIVAub2Zmc2NyZWVuKXJldHVybiBQLmNhbnZhc31yZXR1cm4gbnVsbH1mdW5jdGlvbiBNKEEsUil7Y29uc3RbSSxQXT1BLnJlbmRlck9mZnNldCx7d2lkdGg6TCxoZWlnaHQ6RH09QS5nZXRSZXNvbHV0aW9uKCksQz1BLmRpc3BsYXlSYXRpbztBLnJlbmRlcmVyLmRyYXdJbWFnZShSLmNhbnZhcywtSS9DLC1QL0MsTC9DLEQvQyl9Y29uc3QgaT17fTtmdW5jdGlvbiBhKEEpe2NvbnN0IFI9WyJtb3VzZWRvd24iLCJtb3VzZXVwIiwibW91c2Vtb3ZlIiwibW91c2V3aGVlbCIsIndoZWVsIiwidG91Y2hzdGFydCIsInRvdWNoZW5kIiwidG91Y2htb3ZlIiwidG91Y2hjYW5jZWwiLCJjbGljayIsImRibGNsaWNrIiwibG9uZ3ByZXNzIiwidGFwIiwiY29udGV4dG1lbnUiXSxJPUEuY29udGFpbmVyO0kuYWRkRXZlbnRMaXN0ZW5lcigibW91c2VsZWF2ZSIsUD0+e2NvbnN0IEw9QVtiXTtpZihMLnNpemUpe2NvbnN0IEQ9bmV3IGMuZGVmYXVsdCgibW91c2VsZWF2ZSIpO0Quc2V0T3JpZ2luYWxFdmVudChQKSxbLi4uTF0uZm9yRWFjaChDPT57Qy5kaXNwYXRjaEV2ZW50KEQpfSksQVtiXS5jbGVhcigpfX0se3Bhc3NpdmU6ITB9KSxSLmZvckVhY2goUD0+e0kuYWRkRXZlbnRMaXN0ZW5lcihQLEw9Pntjb25zdHtsZWZ0OkQsdG9wOkMsZGlzcGxheVJhdGlvOlN9PUEub3B0aW9ucyxCPUEub3JkZXJlZENoaWxkcmVuO09iamVjdCh4LmRlZmF1bHQpKEwse29mZnNldExlZnQ6RCxvZmZzZXRUb3A6QyxkaXNwbGF5UmF0aW86U30pLmZvckVhY2goSD0+e2NvbnN0IEo9SC5pZGVudGlmaWVyO2lmKEgudHlwZT09PSJ0b3VjaG1vdmUifHxILnR5cGU9PT0idG91Y2hlbmQiKXtjb25zdCBVPWlbSl07VSYmVS5kaXNwYXRjaEV2ZW50KEgpLEgudHlwZT09PSJ0b3VjaGVuZCImJmRlbGV0ZSBpW0pdfWVsc2V7Zm9yKGxldCBVPUIubGVuZ3RoLTE7VT49MDtVLS0pe2NvbnN0IEc9QltVXTtpZihHLm9wdGlvbnMuaGFuZGxlRXZlbnQhPT0hMSl7aWYoRy5kaXNwYXRjaFBvaW50ZXJFdmVudChIKSYmSC50YXJnZXQhPT1HKWJyZWFrO0guY2FuY2VsQnViYmxlPSExfX1pZihILnRhcmdldD09PUJbMF0pZm9yKGxldCBVPUIubGVuZ3RoLTE7VT49MDtVLS0pe2NvbnN0IEc9QltVXTtpZihHLm9wdGlvbnMuaGFuZGxlRXZlbnQhPT0hMSl7SC50YXJnZXQ9RzticmVha319fWNvbnN0IHE9SC50YXJnZXQ7aWYoSC50eXBlPT09InRvdWNoc3RhcnQiJiYoaVtKXT1ILnRhcmdldCksSC50eXBlPT09Im1vdXNlbW92ZSIpe2NvbnN0IFU9QVtiXTtsZXQgRztpZihxKXtjb25zdCBfPXEuYW5jZXN0b3JzfHxbXTtHPW5ldyBTZXQoW3EsLi4uX10pfWVsc2UgRz1uZXcgU2V0O2NvbnN0IFo9T2JqZWN0LmVudHJpZXMoTCk7aWYoIVUuaGFzKHEpJiZxKXtjb25zdCBfPW5ldyBjLmRlZmF1bHQoIm1vdXNlZW50ZXIiKTtfLnNldE9yaWdpbmFsRXZlbnQoTCksWi5mb3JFYWNoKChbayxodF0pPT57X1trXT1odH0pLFUuYWRkKHEpLHEuZGlzcGF0Y2hFdmVudChfKTtjb25zdCBzdD1xLmFuY2VzdG9ycztzdCYmc3QuZm9yRWFjaChrPT57ayBpbnN0YW5jZW9mIGcuZGVmYXVsdCYmIVUuaGFzKGspJiYoVS5hZGQoayksay5kaXNwYXRjaEV2ZW50KF8pKX0pfWNvbnN0IHR0PW5ldyBjLmRlZmF1bHQoIm1vdXNlbGVhdmUiKTt0dC5zZXRPcmlnaW5hbEV2ZW50KEwpLFouZm9yRWFjaCgoW18sc3RdKT0+e3R0W19dPXN0fSksWy4uLlVdLmZvckVhY2goXz0+e0cuaGFzKF8pfHwoVS5kZWxldGUoXyksXy5kaXNwYXRjaEV2ZW50KHR0KSl9KX19KX0se3Bhc3NpdmU6UCE9PSJjb250ZXh0bWVudSJ9KX0pfWZ1bmN0aW9uIHMoQSxSKXtpZihSJiZSLnN0eWxlKXtsZXR7d2lkdGg6SSxoZWlnaHQ6UCxtb2RlOkwsY29udGFpbmVyOkR9PUE7Y29uc3R7Y2xpZW50V2lkdGg6QyxjbGllbnRIZWlnaHQ6U309RDtJPUl8fEMsUD1QfHxTLEw9PT0ic3RhdGljIj8oUi5zdHlsZS53aWR0aD1gJHtJfXB4YCxSLnN0eWxlLmhlaWdodD1gJHtQfXB4YCk6KFIuc3R5bGUudG9wPSIwIixSLnN0eWxlLmxlZnQ9IjAiLFIuc3R5bGUud2lkdGg9YCR7Q31weGAsUi5zdHlsZS5oZWlnaHQ9YCR7U31weGAsUi5zdHlsZS50cmFuc2Zvcm09IiIsUi5zdHlsZS53ZWJraXRUcmFuc2Zvcm09IiIpfX1jb25zdCBsPVN5bWJvbCgib2Zmc2NyZWVuTGF5ZXJDb3VudCIpO2NsYXNzIE8gZXh0ZW5kcyBmLmRlZmF1bHR7Y29uc3RydWN0b3IoUj17fSl7aWYoc3VwZXIoKSwhUi5jb250YWluZXIpaWYodHlwZW9mIG4uRU5WLkNvbnRhaW5lcj09ImZ1bmN0aW9uIilSLmNvbnRhaW5lcj1uZXcgbi5FTlYuQ29udGFpbmVyKFIud2lkdGh8fDMwMCxSLmhlaWdodHx8MTUwKTtlbHNlIHRocm93IG5ldyBFcnJvcigiTm8gY29udGFpbmVyIHNwZWNpZmllZC4iKTtpZih0aGlzLmNvbnRhaW5lcj1SLmNvbnRhaW5lcix0aGlzLmNvbnRhaW5lci5zdHlsZSYmKHRoaXMuY29udGFpbmVyLnN0eWxlLm92ZXJmbG93fHwodGhpcy5jb250YWluZXIuc3R5bGUub3ZlcmZsb3c9ImhpZGRlbiIpLHRoaXMuY29udGFpbmVyLnN0eWxlLnBvc2l0aW9ufHwodGhpcy5jb250YWluZXIuc3R5bGUucG9zaXRpb249InJlbGF0aXZlIikpLHRoaXMub3B0aW9ucz1SLFIuZGlzcGxheVJhdGlvPVIuZGlzcGxheVJhdGlvfHwxLFIubW9kZT1SLm1vZGV8fCJzY2FsZSIsUi5sZWZ0PTAsUi50b3A9MCxSLmF1dG9SZXNpemU9Ui5hdXRvUmVzaXplIT09ITEsUi5hdXRvUmVzaXplKXtsZXQgSTtpZih0eXBlb2YgZ2xvYmFsVGhpczwidSI/ST1nbG9iYWxUaGlzOkk9dHlwZW9mIHdpbmRvdzwidSI/d2luZG93OnIsSS5hZGRFdmVudExpc3RlbmVyKXtjb25zdCBQPXRoaXM7SS5hZGRFdmVudExpc3RlbmVyKCJyZXNpemUiLGZ1bmN0aW9uIEwoKXt0eXBlb2YgZG9jdW1lbnQ8InUiJiZkb2N1bWVudC5jb250YWlucyhQLmNvbnRhaW5lcik/UC5yZXNpemUoKTpJLnJlbW92ZUV2ZW50TGlzdGVuZXIoInJlc2l6ZSIsTCl9KX19dGhpc1tiXT1uZXcgU2V0LHRoaXMuc2V0UmVzb2x1dGlvbihSKSxhKHRoaXMpLHRoaXNbbF09MH1nZXQgaGFzT2Zmc2NyZWVuQ2FudmFzKCl7cmV0dXJuIHRoaXNbbF0+MH1zZXQgZGlzcGxheVJhdGlvKFIpe3RoaXMub3B0aW9ucy5kaXNwbGF5UmF0aW8hPT1SJiYodGhpcy5vcHRpb25zLmRpc3BsYXlSYXRpbz1SLHRoaXMucmVzaXplKCkpfWdldCBkaXNwbGF5UmF0aW8oKXtyZXR1cm4gdGhpcy5vcHRpb25zLmRpc3BsYXlSYXRpb31zZXQgaGVpZ2h0KFIpe3RoaXMub3B0aW9ucy5oZWlnaHQhPT1SJiYodGhpcy5vcHRpb25zLmhlaWdodD1SLHRoaXMucmVzaXplKCkpfWdldCBoZWlnaHQoKXtyZXR1cm4gdGhpcy5vcHRpb25zLmhlaWdodH1zZXQgbW9kZShSKXt0aGlzLm9wdGlvbnMubW9kZSE9PVImJih0aGlzLm9wdGlvbnMubW9kZT1SLHRoaXMucmVzaXplKCkpfWdldCBtb2RlKCl7cmV0dXJuIHRoaXMub3B0aW9ucy5tb2RlfXNldCB3aWR0aChSKXt0aGlzLm9wdGlvbnMud2lkdGghPT1SJiYodGhpcy5vcHRpb25zLndpZHRoPVIsdGhpcy5yZXNpemUoKSl9Z2V0IHdpZHRoKCl7cmV0dXJuIHRoaXMub3B0aW9ucy53aWR0aH1hcHBlbmRDaGlsZChSKXshKFIgaW5zdGFuY2VvZiB1LmRlZmF1bHQpJiYhKFIgaW5zdGFuY2VvZiBvLmRlZmF1bHQpJiZFKFIpO2NvbnN0IEk9c3VwZXIuYXBwZW5kQ2hpbGQoUiksUD1SLmNhbnZhcztyZXR1cm4gUi5vZmZzY3JlZW4/dGhpc1tsXSsrOnRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKFApLHModGhpcy5vcHRpb25zLFApLFIuc2V0UmVzb2x1dGlvbih0aGlzLmdldFJlc29sdXRpb24oKSksSX1mb3JjZVVwZGF0ZSgpe3RoaXMuaGFzT2Zmc2NyZWVuQ2FudmFzJiYhdGhpcy5fcmVxdWVzdElEJiYodGhpcy5fcmVxdWVzdElEPU9iamVjdChkLnJlcXVlc3RBbmltYXRpb25GcmFtZSkoKCk9PntkZWxldGUgdGhpcy5fcmVxdWVzdElELHRoaXMucmVuZGVyKCl9KSl9aW5zZXJ0QmVmb3JlKFIsSSl7IShSIGluc3RhbmNlb2YgdS5kZWZhdWx0KSYmIShSIGluc3RhbmNlb2Ygby5kZWZhdWx0KSYmRShSKTtjb25zdCBQPXN1cGVyLmluc2VydEJlZm9yZShSLEkpLEw9Ui5jYW52YXM7aWYoIVIub2Zmc2NyZWVuKXtjb25zdCBEPXkodGhpcyxSKTt0aGlzLmNvbnRhaW5lci5pbnNlcnRCZWZvcmUoTCxEKX1yZXR1cm4gcyh0aGlzLm9wdGlvbnMsTCksUi5zZXRSZXNvbHV0aW9uKHRoaXMuZ2V0UmVzb2x1dGlvbigpKSxQfWxheWVyKFI9ImRlZmF1bHQiLEk9e30pe0k9T2JqZWN0LmFzc2lnbih7fSx0aGlzLm9wdGlvbnMsSSksSS5pZD1SO2NvbnN0IFA9dGhpcy5vcmRlcmVkQ2hpbGRyZW47Zm9yKGxldCBDPTA7QzxQLmxlbmd0aDtDKyspaWYoUFtDXS5pZD09PVIpcmV0dXJuIFBbQ107Y29uc3QgTD1JLndvcmtlcjtsZXQgRDtyZXR1cm4gTD9EPW5ldyBvLmRlZmF1bHQoSSk6RD1uZXcgdS5kZWZhdWx0KEkpLHRoaXMuYXBwZW5kQ2hpbGQoRCksRH1hc3luYyBwcmVsb2FkKC4uLlIpe2NvbnN0IEk9W10sUD1bXSxMPVtdO2ZvcihsZXQgRD0wO0Q8Ui5sZW5ndGg7RCsrKXtjb25zdCBDPVJbRF07bGV0IFM7aWYodHlwZW9mIEM9PSJzdHJpbmciKVM9T2JqZWN0KHYubG9hZFRleHR1cmUpKEMpO2Vsc2UgaWYoQXJyYXkuaXNBcnJheShDKSlTPU9iamVjdCh2LmxvYWRGcmFtZXMpKC4uLkMpO2Vsc2V7Y29uc3R7aWQ6QixzcmM6d309QztTPU9iamVjdCh2LmxvYWRUZXh0dXJlKSh3LEIpfVMgaW5zdGFuY2VvZiBQcm9taXNlfHwoUz1Qcm9taXNlLnJlc29sdmUoUykpLFAucHVzaChTLnRoZW4oQj0+e0kucHVzaChCKSxMW0RdPUI7Y29uc3Qgdz1uZXcgYy5kZWZhdWx0KHt0eXBlOiJwcmVsb2FkIixkZXRhaWw6e2N1cnJlbnQ6Qixsb2FkZWQ6SSxyZXNvdXJjZXM6Un19KTt0aGlzLmRpc3BhdGNoRXZlbnQodyl9KSl9cmV0dXJuIGF3YWl0IFByb21pc2UuYWxsKFApLEx9cmVtb3ZlQ2hpbGQoUil7Y29uc3QgST1zdXBlci5yZW1vdmVDaGlsZChSKTtpZihJKXtSLl9wcmVwYXJlUmVuZGVyRmluaXNoZWQmJlIuX3ByZXBhcmVSZW5kZXJGaW5pc2hlZCgpO2NvbnN0IFA9Ui5jYW52YXM7UCYmUC5yZW1vdmUmJlAucmVtb3ZlKCksUi5vZmZzY3JlZW4mJnRoaXNbbF0tLX1yZXR1cm4gSX1yZW5kZXIoKXtjb25zdCBSPXRoaXMub3JkZXJlZENoaWxkcmVuO2xldCBJPW51bGw7Y29uc3QgUD1bXTtmb3IobGV0IEw9MDtMPFIubGVuZ3RoO0wrKyl7Y29uc3QgRD1SW0xdLEM9UC5sZW5ndGg+MDtpZihEIGluc3RhbmNlb2YgdS5kZWZhdWx0JiYhRC5vZmZzY3JlZW4paWYoIUQuYXV0b1JlbmRlcilDJiYoY29uc29sZS53YXJuKCJTb21lIG9mZnNjcmVlbiBjYW52YXMgd2lsbCBub3QgYmUgcmVuZGVyZWQuIiksUC5sZW5ndGg9MCk7ZWxzZSBpZihJPUQsQyl7RC5yZW5kZXJlci5jbGVhcigpO2ZvcihsZXQgUz0wO1M8UC5sZW5ndGg7UysrKXtjb25zdCBCPVBbU107Qi5yZW5kZXIoKSxNKEQsQil9UC5sZW5ndGg9MCxELnJlbmRlcih7Y2xlYXI6ITF9KX1lbHNlIEQucHJlcGFyZVJlbmRlciYmRC5yZW5kZXIoKTtlbHNlIEQub2Zmc2NyZWVuP0k/KEQucHJlcGFyZVJlbmRlciYmRC5yZW5kZXIoKSxNKEksRCkpOlAucHVzaChEKTpEIGluc3RhbmNlb2Ygby5kZWZhdWx0JiZDJiYoY29uc29sZS53YXJuKCJTb21lIG9mZnNjcmVlbiBjYW52YXMgd2lsbCBub3QgYmUgcmVuZGVyZWQuIiksUC5sZW5ndGg9MCl9fXJlcGxhY2VDaGlsZChSLEkpe2NvbnN0IFA9c3VwZXIucmVwbGFjZUNoaWxkKFIsSSk7SS5jYW52YXMucmVtb3ZlJiZJLmNhbnZhcy5yZW1vdmUoKSxJLm9mZnNjcmVlbiYmdGhpc1tsXS0tO2NvbnN0IEw9Ui5jYW52YXM7aWYoIVIub2Zmc2NyZWVuKXtjb25zdCBEPXkodGhpcyxSKTt0aGlzLmNvbnRhaW5lci5pbnNlcnRCZWZvcmUoTCxEKX1yZXR1cm4gcyh0aGlzLm9wdGlvbnMsTCksUi5zZXRSZXNvbHV0aW9uKHRoaXMuZ2V0UmVzb2x1dGlvbigpKSxQfXJlc2l6ZSgpe2NvbnN0IFI9dGhpcy5vcHRpb25zO3RoaXMuY2hpbGRyZW4uZm9yRWFjaChJPT57cyhSLEkuY2FudmFzKX0pLHRoaXMuc2V0UmVzb2x1dGlvbihSKSx0aGlzLmRpc3BhdGNoRXZlbnQoe3R5cGU6InJlc2l6ZSJ9KX1zZXRSZXNvbHV0aW9uKHt3aWR0aDpSLGhlaWdodDpJfT17fSl7Y29uc3QgUD10aGlzLmNvbnRhaW5lcix7Y2xpZW50V2lkdGg6TCxjbGllbnRIZWlnaHQ6RH09UDsoUj09bnVsbHx8ST09bnVsbCkmJihSPVI/P0wsST1JPz9EKTtjb25zdHttb2RlOkMsZGlzcGxheVJhdGlvOlN9PXRoaXMub3B0aW9ucztpZihSKj1TLEkqPVMsdGhpcy5vcHRpb25zLmxlZnQ9MCx0aGlzLm9wdGlvbnMudG9wPTAsQz09PSJzdGlja3lIZWlnaHQifHxDPT09InN0aWNreUxlZnQifHxDPT09InN0aWNreVJpZ2h0Iil7Y29uc3QgQj1SO1I9TCpJL0QsQz09PSJzdGlja3lIZWlnaHQiJiYodGhpcy5vcHRpb25zLmxlZnQ9LjUqKFItQikpLEM9PT0ic3RpY2t5UmlnaHQiJiYodGhpcy5vcHRpb25zLmxlZnQ9Ui1CKX1lbHNlIGlmKEM9PT0ic3RpY2t5V2lkdGgifHxDPT09InN0aWNreVRvcCJ8fEM9PT0ic3RpY2t5Qm90dG9tIil7Y29uc3QgQj1JO0k9RCpSL0wsQz09PSJzdGlja3lXaWR0aCImJih0aGlzLm9wdGlvbnMudG9wPS41KihJLUIpKSxDPT09InN0aWNreUJvdHRvbSImJih0aGlzLm9wdGlvbnMudG9wPUktQil9c3VwZXIuc2V0UmVzb2x1dGlvbih7d2lkdGg6UixoZWlnaHQ6SX0pfXNuYXBzaG90KHtvZmZzY3JlZW46Uj0hMSxsYXllcnM6SX09e30pe2NvbnN0IFA9Uj8ic25hcHNob3RPZmZTY3JlZW5DYW52YXMiOiJzbmFwc2hvdENhbnZhcyIse3dpZHRoOkwsaGVpZ2h0OkR9PXRoaXMuZ2V0UmVzb2x1dGlvbigpO3RoaXNbUF09dGhpc1tQXXx8bi5FTlYuY3JlYXRlQ2FudmFzKEwsRCx7b2Zmc2NyZWVuOlJ9KTtjb25zdCBDPXRoaXNbUF0uZ2V0Q29udGV4dCgiMmQiKTtJPUl8fHRoaXMub3JkZXJlZENoaWxkcmVuLHRoaXNbUF0ud2lkdGg9TCx0aGlzW1BdLmhlaWdodD1EO2ZvcihsZXQgUz0wO1M8SS5sZW5ndGg7UysrKXtjb25zdCBCPUlbU107aWYoIUIub3B0aW9ucy5pZ25vcmVTbmFwc2hvdCl7Qi5yZW5kZXImJkIucmVuZGVyKCk7Y29uc3Qgdz1CLmNhbnZhczt3JiZ3IT09QiYmQy5kcmF3SW1hZ2UodywwLDAsTCxEKX19cmV0dXJuIHRoaXNbUF19fXR5cGVvZiBkb2N1bWVudDwidSImJihPLnByb3RvdHlwZS5sYXllcjNkPWZ1bmN0aW9uKEEsUj17fSl7Y29uc3QgST1SLnVybHx8Imh0dHBzOi8vdW5wa2cuY29tL3Nwcml0ZS1leHRlbmQtM2QvZGlzdC9zcHJpdGUtZXh0ZW5kLTNkLm1pbi5qcyI7cmV0dXJuIG5ldyBQcm9taXNlKChQLEwpPT57Y29uc3QgRD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJzY3JpcHQiKTtELmFzeW5jPSExLEQuc3JjPUksRC5vbmxvYWQ9KCk9Pnt0cnl7UCh0aGlzLmxheWVyM2QoQSxSKSl9Y2F0Y2goQyl7TChDKX19LGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZChEKX0pfSkscC5kZWZhdWx0LnJlZ2lzdGVyTm9kZShPLCJzY2VuZSIpfSkuY2FsbCh0aGlzLHQoMjIpKX0sZnVuY3Rpb24oaCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gbn0pO3ZhciByPXQoMjE0KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gbihkLHtvZmZzZXRUb3A6Zz0wLG9mZnNldExlZnQ6dT0wLGRpc3BsYXlSYXRpbzpvPTF9PXt9KXtsZXQgZix4O2NvbnN0IGM9W10se2xlZnQ6dix0b3A6cCx3aWR0aDpiLGhlaWdodDpFfT1kLnRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSx5PWQudGFyZ2V0LndpZHRoLE09ZC50YXJnZXQuaGVpZ2h0LGk9ZC5jaGFuZ2VkVG91Y2hlc3x8W2RdO2ZvcihsZXQgcz0wO3M8aS5sZW5ndGg7cysrKXtjb25zdCBsPWlbc10sTz1sLmlkZW50aWZpZXIse2NsaWVudFg6QSxjbGllbnRZOlJ9PWw7QSE9bnVsbCYmUiE9bnVsbCYmYy5wdXNoKHt4Ok1hdGgucm91bmQoKEF8MCktdikseTpNYXRoLnJvdW5kKChSfDApLXApLGlkZW50aWZpZXI6T30pfWMubGVuZ3RoPD0wJiZjLnB1c2goe3g6Zix5Onh9KTtjb25zdCBhPVtdO3JldHVybiBjLmZvckVhY2gocz0+e3MueCE9bnVsbCYmcy55IT1udWxsJiYoZj0ocy54KnkvYi11KS9vLHg9KHMueSpNL0UtZykvbyk7Y29uc3QgbD1uZXcgci5kZWZhdWx0KGQpO09iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGwse2xheWVyWDp7dmFsdWU6Zixjb25maWd1cmFibGU6ITB9LGxheWVyWTp7dmFsdWU6eCxjb25maWd1cmFibGU6ITB9LG9yaWdpbmFsWDp7dmFsdWU6cy54fSxvcmlnaW5hbFk6e3ZhbHVlOnMueX0seDp7dmFsdWU6Zixjb25maWd1cmFibGU6ITB9LHk6e3ZhbHVlOngsY29uZmlndXJhYmxlOiEwfSxpZGVudGlmaWVyOnt2YWx1ZTpzLmlkZW50aWZpZXJ9fSksYS5wdXNoKGwpfSksYX19XSk7UnQudmVyc2lvbixSdC5BcmMsUnQuQmxvY2ssUnQuQ2xvdWQsUnQuQ29sb3IsUnQuRWxsaXBzZSxSdC5HcmFkaWVudDtjb25zdCBEZT1SdC5Hcm91cDtSdC5MYWJlbCxSdC5MYXllcixSdC5MYXllcldvcmtlcixSdC5Ob2RlLFJ0LlBhcmFsbGVsO2NvbnN0IEllPVJ0LlBhdGg7UnQuUG9seWxpbmU7Y29uc3Qgc3I9UnQuUmVjdDtSdC5SZWd1bGFyLFJ0LlJpbmc7Y29uc3Qgb249UnQuU2NlbmU7UnQuU3ByaXRlLFJ0LlNwcml0ZVN2ZyxSdC5TdGFyLFJ0LlRyaWFuZ2xlLFJ0LmhlbHBlcnMsUnQuY3JlYXRlRWxlbWVudCxSdC5pc1Nwcml0ZU5vZGUsUnQucmVnaXN0ZXJOb2RlLFJ0LnJlcXVlc3RBbmltYXRpb25GcmFtZSxSdC5jYW5jZWxBbmltYXRpb25GcmFtZSxSdC5FTlY7Y29uc3QgYW49e2xpbmVhcjpoPT5oLGVhc2VJblF1YWQ6aD0+aCpoLGVhc2VPdXRRdWFkOmg9PmgqKDItaCksZWFzZUluT3V0UXVhZDpoPT5oPC41PzIqaCpoOi0xKyg0LTIqaCkqaCxlYXNlSW5DdWJpYzpoPT5oKmgqaCxlYXNlT3V0Q3ViaWM6aD0+LS1oKmgqaCsxLGVhc2VJbk91dEN1YmljOmg9Pmg8LjU/NCpoKmgqaDooaC0xKSooMipoLTIpKigyKmgtMikrMSxlYXNlSW5RdWFydDpoPT5oKmgqaCpoLGVhc2VPdXRRdWFydDpoPT4xLSAtLWgqaCpoKmgsZWFzZUluT3V0UXVhcnQ6aD0+aDwuNT84KmgqaCpoKmg6MS04Ki0taCpoKmgqaCxlYXNlSW5RdWludDpoPT5oKmgqaCpoKmgsZWFzZU91dFF1aW50Omg9PjErLS1oKmgqaCpoKmgsZWFzZUluT3V0UXVpbnQ6aD0+aDwuNT8xNipoKmgqaCpoKmg6MSsxNiotLWgqaCpoKmgqaCxlYXNlSW5TaW5lOmg9PjEtTWF0aC5jb3MoaCpNYXRoLlBJLzIpLGVhc2VPdXRTaW5lOmg9Pk1hdGguc2luKGgqTWF0aC5QSS8yKSxlYXNlSW5PdXRTaW5lOmg9Pi0oTWF0aC5jb3MoTWF0aC5QSSpoKS0xKS8yLGVhc2VJbkV4cG86aD0+aDw9MD8wOk1hdGgucG93KDIsMTAqaC0xMCksZWFzZU91dEV4cG86aD0+aD49MT8xOjEtTWF0aC5wb3coMiwtMTAqaCksZWFzZUluT3V0RXhwbzpoPT5oPD0wPzA6aD49MT8xOmg8LjU/TWF0aC5wb3coMiwyMCpoLTEwKS8yOigyLU1hdGgucG93KDIsLTIwKmgrMTApKS8yfTtjbGFzcyBjdHtjb25zdHJ1Y3RvcihlPTAsdD0wLHI9MSl7T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIngiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTplfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInkiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp0fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInoiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpyfSl9Z2V0IFhZKCl7cmV0dXJuW3RoaXMueCx0aGlzLnldfXNldHooZSl7cmV0dXJuIHRoaXMuej1lLHRoaXN9c2V0WFkoZT10aGlzLngsdD10aGlzLnkpe3JldHVybiB0aGlzLng9ZSx0aGlzLnk9dCx0aGlzfXNldChlPXRoaXMueCx0PXRoaXMueSxyPXRoaXMueil7cmV0dXJuIHRoaXMueD1lLHRoaXMueT10LHRoaXMuej1yLHRoaXN9c2V0VG8oe3g6ZT0wLHk6dD0wLHo6cj0xfSl7cmV0dXJuIHRoaXMueD1lLHRoaXMueT10LHRoaXMuej1yLHRoaXN9cm90KGUpe2lmKGU9PT0wKXJldHVybiB0aGlzO2NvbnN0e3g6dCx5OnJ9PXRoaXMsbj1NYXRoLnNpbihlKSxkPU1hdGguY29zKGUpO3JldHVybiB0aGlzLng9dCpkLXIqbix0aGlzLnk9dCpuK3IqZCx0aGlzfXJvdFdpdGgoZSx0KXtpZih0PT09MClyZXR1cm4gdGhpcztjb25zdCByPXRoaXMueC1lLngsbj10aGlzLnktZS55LGQ9TWF0aC5zaW4odCksZz1NYXRoLmNvcyh0KTtyZXR1cm4gdGhpcy54PWUueCsocipnLW4qZCksdGhpcy55PWUueSsocipkK24qZyksdGhpc31jbG9uZSgpe2NvbnN0e3g6ZSx5OnQsejpyfT10aGlzO3JldHVybiBuZXcgY3QoZSx0LHIpfXN1YihlKXtyZXR1cm4gdGhpcy54LT1lLngsdGhpcy55LT1lLnksdGhpc31zdWJYWShlLHQpe3JldHVybiB0aGlzLngtPWUsdGhpcy55LT10LHRoaXN9c3ViU2NhbGFyKGUpe3JldHVybiB0aGlzLngtPWUsdGhpcy55LT1lLHRoaXN9YWRkKGUpe3JldHVybiB0aGlzLngrPWUueCx0aGlzLnkrPWUueSx0aGlzfWFkZFhZKGUsdCl7cmV0dXJuIHRoaXMueCs9ZSx0aGlzLnkrPXQsdGhpc31hZGRTY2FsYXIoZSl7cmV0dXJuIHRoaXMueCs9ZSx0aGlzLnkrPWUsdGhpc31jbGFtcChlLHQpe3JldHVybiB0aGlzLng9TWF0aC5tYXgodGhpcy54LGUpLHRoaXMueT1NYXRoLm1heCh0aGlzLnksZSksdCE9PXZvaWQgMCYmKHRoaXMueD1NYXRoLm1pbih0aGlzLngsdCksdGhpcy55PU1hdGgubWluKHRoaXMueSx0KSksdGhpc31kaXYoZSl7cmV0dXJuIHRoaXMueC89ZSx0aGlzLnkvPWUsdGhpc31kaXZWKGUpe3JldHVybiB0aGlzLngvPWUueCx0aGlzLnkvPWUueSx0aGlzfW11bChlKXtyZXR1cm4gdGhpcy54Kj1lLHRoaXMueSo9ZSx0aGlzfW11bFYoZSl7cmV0dXJuIHRoaXMueCo9ZS54LHRoaXMueSo9ZS55LHRoaXN9YWJzKCl7cmV0dXJuIHRoaXMueD1NYXRoLmFicyh0aGlzLngpLHRoaXMueT1NYXRoLmFicyh0aGlzLnkpLHRoaXN9bnVkZ2UoZSx0KXtjb25zdCByPWN0LlRhbihlLHRoaXMpO3JldHVybiB0aGlzLmFkZChyLm11bCh0KSl9bmVnKCl7cmV0dXJuIHRoaXMueCo9LTEsdGhpcy55Kj0tMSx0aGlzfWNyb3NzKGUpe3JldHVybiB0aGlzLng9dGhpcy55KmUuei10aGlzLnoqZS55LHRoaXMueT10aGlzLnoqZS54LXRoaXMueCplLnosdGhpc31kcHIoZSl7cmV0dXJuIGN0LkRwcih0aGlzLGUpfWNwcihlKXtyZXR1cm4gY3QuQ3ByKHRoaXMsZSl9bGVuMigpe3JldHVybiBjdC5MZW4yKHRoaXMpfWxlbigpe3JldHVybiBjdC5MZW4odGhpcyl9cHJ5KGUpe3JldHVybiBjdC5QcnkodGhpcyxlKX1wZXIoKXtjb25zdHt4OmUseTp0fT10aGlzO3JldHVybiB0aGlzLng9dCx0aGlzLnk9LWUsdGhpc311bmkoKXtyZXR1cm4gY3QuVW5pKHRoaXMpfXRhbihlKXtyZXR1cm4gY3QuVGFuKHRoaXMsZSl9ZGlzdChlKXtyZXR1cm4gY3QuRGlzdCh0aGlzLGUpfWRpc3RhbmNlVG9MaW5lU2VnbWVudChlLHQpe3JldHVybiBjdC5EaXN0YW5jZVRvTGluZVNlZ21lbnQoZSx0LHRoaXMpfXNsb3BlKGUpe3JldHVybiBjdC5TbG9wZSh0aGlzLGUpfXNuYXBUb0dyaWQoZSl7cmV0dXJuIHRoaXMueD1NYXRoLnJvdW5kKHRoaXMueC9lKSplLHRoaXMueT1NYXRoLnJvdW5kKHRoaXMueS9lKSplLHRoaXN9YW5nbGUoZSl7cmV0dXJuIGN0LkFuZ2xlKHRoaXMsZSl9dG9BbmdsZSgpe3JldHVybiBjdC5Ub0FuZ2xlKHRoaXMpfWxycChlLHQpe3JldHVybiB0aGlzLng9dGhpcy54KyhlLngtdGhpcy54KSp0LHRoaXMueT10aGlzLnkrKGUueS10aGlzLnkpKnQsdGhpc31lcXVhbHMoZSx0KXtyZXR1cm4gY3QuRXF1YWxzKHRoaXMsZSx0KX1lcXVhbHNYWShlLHQpe3JldHVybiBjdC5FcXVhbHNYWSh0aGlzLGUsdCl9bm9ybSgpe2NvbnN0IGU9dGhpcy5sZW4oKTtyZXR1cm4gdGhpcy54PWU9PT0wPzA6dGhpcy54L2UsdGhpcy55PWU9PT0wPzA6dGhpcy55L2UsdGhpc310b0ZpeGVkKCl7cmV0dXJuIGN0LlRvRml4ZWQodGhpcyl9dG9TdHJpbmcoKXtyZXR1cm4gY3QuVG9TdHJpbmcoY3QuVG9GaXhlZCh0aGlzKSl9dG9Kc29uKCl7cmV0dXJuIGN0LlRvSnNvbih0aGlzKX10b0FycmF5KCl7cmV0dXJuIGN0LlRvQXJyYXkodGhpcyl9c3RhdGljIEFkZChlLHQpe3JldHVybiBuZXcgY3QoZS54K3QueCxlLnkrdC55KX1zdGF0aWMgQWRkWFkoZSx0LHIpe3JldHVybiBuZXcgY3QoZS54K3QsZS55K3IpfXN0YXRpYyBTdWIoZSx0KXtyZXR1cm4gbmV3IGN0KGUueC10LngsZS55LXQueSl9c3RhdGljIFN1YlhZKGUsdCxyKXtyZXR1cm4gbmV3IGN0KGUueC10LGUueS1yKX1zdGF0aWMgQWRkU2NhbGFyKGUsdCl7cmV0dXJuIG5ldyBjdChlLngrdCxlLnkrdCl9c3RhdGljIFN1YlNjYWxhcihlLHQpe3JldHVybiBuZXcgY3QoZS54LXQsZS55LXQpfXN0YXRpYyBEaXYoZSx0KXtyZXR1cm4gbmV3IGN0KGUueC90LGUueS90KX1zdGF0aWMgTXVsKGUsdCl7cmV0dXJuIG5ldyBjdChlLngqdCxlLnkqdCl9c3RhdGljIERpdlYoZSx0KXtyZXR1cm4gbmV3IGN0KGUueC90LngsZS55L3QueSl9c3RhdGljIE11bFYoZSx0KXtyZXR1cm4gbmV3IGN0KGUueCp0LngsZS55KnQueSl9c3RhdGljIE5lZyhlKXtyZXR1cm4gbmV3IGN0KC1lLngsLWUueSl9c3RhdGljIFBlcihlKXtyZXR1cm4gbmV3IGN0KGUueSwtZS54KX1zdGF0aWMgRGlzdDIoZSx0KXtyZXR1cm4gY3QuU3ViKGUsdCkubGVuMigpfXN0YXRpYyBBYnMoZSl7cmV0dXJuIG5ldyBjdChNYXRoLmFicyhlLngpLE1hdGguYWJzKGUueSkpfXN0YXRpYyBEaXN0KGUsdCl7cmV0dXJuIE1hdGguaHlwb3QoZS55LXQueSxlLngtdC54KX1zdGF0aWMgRHByKGUsdCl7cmV0dXJuIGUueCp0LngrZS55KnQueX1zdGF0aWMgQ3Jvc3MoZSx0KXtyZXR1cm4gbmV3IGN0KGUueSp0LnotZS56KnQueSxlLnoqdC54LWUueCp0LnopfXN0YXRpYyBDcHIoZSx0KXtyZXR1cm4gZS54KnQueS10LngqZS55fXN0YXRpYyBMZW4yKGUpe3JldHVybiBlLngqZS54K2UueSplLnl9c3RhdGljIExlbihlKXtyZXR1cm4gTWF0aC5oeXBvdChlLngsZS55KX1zdGF0aWMgUHJ5KGUsdCl7cmV0dXJuIGN0LkRwcihlLHQpL2N0Lkxlbih0KX1zdGF0aWMgVW5pKGUpe3JldHVybiBjdC5EaXYoZSxjdC5MZW4oZSkpfXN0YXRpYyBUYW4oZSx0KXtyZXR1cm4gY3QuVW5pKGN0LlN1YihlLHQpKX1zdGF0aWMgTWluKGUsdCl7cmV0dXJuIG5ldyBjdChNYXRoLm1pbihlLngsdC54KSxNYXRoLm1pbihlLnksdC55KSl9c3RhdGljIE1heChlLHQpe3JldHVybiBuZXcgY3QoTWF0aC5tYXgoZS54LHQueCksTWF0aC5tYXgoZS55LHQueSkpfXN0YXRpYyBGcm9tKGUpe3JldHVybiBuZXcgY3QoKS5hZGQoZSl9c3RhdGljIEZyb21BcnJheShlKXtyZXR1cm4gbmV3IGN0KGVbMF0sZVsxXSl9c3RhdGljIFJvdChlLHQ9MCl7Y29uc3Qgcj1NYXRoLnNpbih0KSxuPU1hdGguY29zKHQpO3JldHVybiBuZXcgY3QoZS54Km4tZS55KnIsZS54KnIrZS55Km4pfXN0YXRpYyBSb3RXaXRoKGUsdCxyKXtjb25zdCBuPWUueC10LngsZD1lLnktdC55LGc9TWF0aC5zaW4ociksdT1NYXRoLmNvcyhyKTtyZXR1cm4gbmV3IGN0KHQueCsobip1LWQqZyksdC55KyhuKmcrZCp1KSl9c3RhdGljIE5lYXJlc3RQb2ludE9uTGluZVRocm91Z2hQb2ludChlLHQscil7cmV0dXJuIGN0Lk11bCh0LGN0LlN1YihyLGUpLnByeSh0KSkuYWRkKGUpfXN0YXRpYyBOZWFyZXN0UG9pbnRPbkxpbmVTZWdtZW50KGUsdCxyLG49ITApe2NvbnN0IGQ9Y3QuVGFuKHQsZSksZz1jdC5BZGQoZSxjdC5NdWwoZCxjdC5TdWIocixlKS5wcnkoZCkpKTtpZihuKXtpZihnLng8TWF0aC5taW4oZS54LHQueCkpcmV0dXJuIGN0LkNhc3QoZS54PHQueD9lOnQpO2lmKGcueD5NYXRoLm1heChlLngsdC54KSlyZXR1cm4gY3QuQ2FzdChlLng+dC54P2U6dCk7aWYoZy55PE1hdGgubWluKGUueSx0LnkpKXJldHVybiBjdC5DYXN0KGUueTx0Lnk/ZTp0KTtpZihnLnk+TWF0aC5tYXgoZS55LHQueSkpcmV0dXJuIGN0LkNhc3QoZS55PnQueT9lOnQpfXJldHVybiBnfXN0YXRpYyBEaXN0YW5jZVRvTGluZVRocm91Z2hQb2ludChlLHQscil7cmV0dXJuIGN0LkRpc3QocixjdC5OZWFyZXN0UG9pbnRPbkxpbmVUaHJvdWdoUG9pbnQoZSx0LHIpKX1zdGF0aWMgRGlzdGFuY2VUb0xpbmVTZWdtZW50KGUsdCxyLG49ITApe3JldHVybiBjdC5EaXN0KHIsY3QuTmVhcmVzdFBvaW50T25MaW5lU2VnbWVudChlLHQscixuKSl9c3RhdGljIFNuYXAoZSx0PTEpe3JldHVybiBuZXcgY3QoTWF0aC5yb3VuZChlLngvdCkqdCxNYXRoLnJvdW5kKGUueS90KSp0KX1zdGF0aWMgQ2FzdChlKXtyZXR1cm4gZSBpbnN0YW5jZW9mIGN0P2U6Y3QuRnJvbShlKX1zdGF0aWMgU2xvcGUoZSx0KXtyZXR1cm4gZS54PT09dC55P05hTjooZS55LXQueSkvKGUueC10LngpfXN0YXRpYyBBbmdsZShlLHQpe3JldHVybiBNYXRoLmF0YW4yKHQueS1lLnksdC54LWUueCl9c3RhdGljIExycChlLHQscil7cmV0dXJuIGN0LlN1Yih0LGUpLm11bChyKS5hZGQoZSl9c3RhdGljIE1lZChlLHQpe3JldHVybiBuZXcgY3QoKGUueCt0LngpLzIsKGUueSt0LnkpLzIpfXN0YXRpYyBFcXVhbHMoZSx0LHI9MWUtNCl7cmV0dXJuIE1hdGguYWJzKGUueC10LngpPHImJk1hdGguYWJzKGUueS10LnkpPHJ9c3RhdGljIEVxdWFsc1hZKGUsdCxyKXtyZXR1cm4gZS54PT09dCYmZS55PT09cn1zdGF0aWMgRXF1YWxzWFlaKGUsdCxyPTFlLTQpe3JldHVybiBjdC5FcXVhbHMoZSx0LHIpJiZNYXRoLmFicygoZS56fHwwKS0odC56fHwwKSk8cn1zdGF0aWMgQ2xvY2t3aXNlKGUsdCxyKXtyZXR1cm4oci54LWUueCkqKHQueS1lLnkpLSh0LngtZS54KSooci55LWUueSk8MH1zdGF0aWMgUmVzY2FsZShlLHQpe2NvbnN0IHI9Y3QuTGVuKGUpO3JldHVybiBuZXcgY3QodCplLngvcix0KmUueS9yKX1zdGF0aWMgU2NhbGVXaXRoT3JpZ2luKGUsdCxyKXtyZXR1cm4gY3QuU3ViKGUscikubXVsKHQpLmFkZChyKX1zdGF0aWMgU2NhbGVXT3JpZ2luKGUsdCxyKXtyZXR1cm4gY3QuU3ViKGUscikubXVsVih0KS5hZGQocil9c3RhdGljIFRvRml4ZWQoZSx0PTIpe3JldHVybiBuZXcgY3QoK2UueC50b0ZpeGVkKHQpLCtlLnkudG9GaXhlZCh0KSwrZS56LnRvRml4ZWQodCkpfXN0YXRpYyBOdWRnZShlLHQscil7cmV0dXJuIGN0LkFkZChlLGN0LlRhbih0LGUpLm11bChyKSl9c3RhdGljIFRvU3RyaW5nKGUpe3JldHVybmAke2UueH0sICR7ZS55fWB9c3RhdGljIFRvQW5nbGUoZSl7bGV0IHQ9TWF0aC5hdGFuMihlLnksZS54KTtyZXR1cm4gdDwwJiYodCs9TWF0aC5QSSoyKSx0fXN0YXRpYyBGcm9tQW5nbGUoZSx0PTEpe3JldHVybiBuZXcgY3QoTWF0aC5jb3MoZSkqdCxNYXRoLnNpbihlKSp0KX1zdGF0aWMgVG9BcnJheShlKXtyZXR1cm5bZS54LGUueSxlLnpdfXN0YXRpYyBUb0pzb24oZSl7Y29uc3R7eDp0LHk6cix6Om59PWU7cmV0dXJue3g6dCx5OnIsejpufX1zdGF0aWMgQXZlcmFnZShlKXtjb25zdCB0PWUubGVuZ3RoLHI9bmV3IGN0KDAsMCk7Zm9yKGxldCBuPTA7bjx0O24rKylyLmFkZChlW25dKTtyZXR1cm4gci5kaXYodCl9c3RhdGljIENsYW1wKGUsdCxyKXtyZXR1cm4gcj09PXZvaWQgMD9uZXcgY3QoTWF0aC5taW4oTWF0aC5tYXgoZS54LHQpKSxNYXRoLm1pbihNYXRoLm1heChlLnksdCkpKTpuZXcgY3QoTWF0aC5taW4oTWF0aC5tYXgoZS54LHQpLHIpLE1hdGgubWluKE1hdGgubWF4KGUueSx0KSxyKSl9c3RhdGljIFBvaW50c0JldHdlZW4oZSx0LHI9Nil7Y29uc3Qgbj1bXTtmb3IobGV0IGQ9MDtkPHI7ZCsrKXtjb25zdCBnPWFuLmVhc2VJblF1YWQoZC8oci0xKSksdT1jdC5McnAoZSx0LGcpO3Uuej1NYXRoLm1pbigxLC41K01hdGguYWJzKC41LWxuKGcpKSouNjUpLG4ucHVzaCh1KX1yZXR1cm4gbn1zdGF0aWMgU25hcFRvR3JpZChlLHQ9OCl7cmV0dXJuIG5ldyBjdChNYXRoLnJvdW5kKGUueC90KSp0LE1hdGgucm91bmQoZS55L3QpKnQpfX1jb25zdCBsbj1oPT5oPC41PzIqaCpoOi0xKyg0LTIqaCkqaDtjbGFzcyBMdCBleHRlbmRzIGN0e2NvbnN0cnVjdG9yKGU9MCx0PTAscj0wLG49e3g6MCx5OjB9LGQ9MCxnPTApe3N1cGVyKGUsdCxyKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywieCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOmV9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywieSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnR9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywieiIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnJ9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidiIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOm59KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOmR9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiYSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOmd9KX1nZXQgdGltZXN0YW1wKCl7cmV0dXJuIHRoaXMudH1nZXQgcHJlc3N1cmUoKXtyZXR1cm4gdGhpcy56fWdldCBhbmdsZU51bSgpe3JldHVybiB0aGlzLmF9Z2V0IFhZKCl7cmV0dXJuW3RoaXMueCx0aGlzLnldfXNldEEoZSl7dGhpcy5hPWV9c2V0VChlKXt0aGlzLnQ9ZX1zZXR2KGUpe3JldHVybiB0aGlzLnY9e3g6ZS54LHk6ZS55fSx0aGlzfXNldChlPXRoaXMueCx0PXRoaXMueSxyPXRoaXMueixuPXRoaXMudixkPXRoaXMudCxnPXRoaXMuYSl7cmV0dXJuIHRoaXMueD1lLHRoaXMueT10LHRoaXMuej1yLHRoaXMudj1uLHRoaXMudD1kLHRoaXMuYT1nLHRoaXN9Y2xvbmUoKXtjb25zdHt4OmUseTp0LHo6cix2Om4sdDpkLGE6Z309dGhpcyx1PXt4Om4ueCx5Om4ueX07cmV0dXJuIG5ldyBMdChlLHQscix1LGQsZyl9ZGlzdGFuY2UoZSl7cmV0dXJuIEx0LkdldERpc3RhbmNlKHRoaXMsZSl9aXNOZWFyKGUsdCl7cmV0dXJuIEx0LklzTmVhcih0aGlzLGUsdCl9Z2V0QW5nbGVCeVBvaW50cyhlLHQpe3JldHVybiBMdC5HZXRBbmdsZUJ5UG9pbnRzKGUsdGhpcyx0KX1zdGF0aWMgU3ViKGUsdCl7cmV0dXJuIG5ldyBMdChlLngtdC54LGUueS10LnkpfXN0YXRpYyBBZGQoZSx0KXtyZXR1cm4gbmV3IEx0KGUueCt0LngsZS55K3QueSl9c3RhdGljIEdldERpc3RhbmNlKGUsdCl7cmV0dXJuIEx0LkxlbihlLmNsb25lKCkuc3ViKHQpKX1zdGF0aWMgR2V0QW5nbGVCeVBvaW50cyhlLHQscil7Y29uc3Qgbj10LngtZS54LGQ9ci54LXQueCxnPXQueS1lLnksdT1yLnktdC55O2xldCBvPTA7Y29uc3QgZj1NYXRoLnNxcnQobipuK2cqZykseD1NYXRoLnNxcnQoZCpkK3UqdSk7aWYoZiYmeCl7Y29uc3QgYz1uKmQrZyp1O289TWF0aC5hY29zKGMvKGYqeCkpLG89by9NYXRoLlBJKjE4MDtsZXQgdj1uKnUtZypkO3Y9dj4wPzE6LTEsbz0xODArdipvfXJldHVybiBvfXN0YXRpYyBJc05lYXIoZSx0LHIpe3JldHVybiBMdC5MZW4oZS5jbG9uZSgpLnN1Yih0KSk8cn1zdGF0aWMgUm90V2l0aChlLHQscixuPTIpe2NvbnN0IGQ9ZS54LXQueCxnPWUueS10LnksdT1NYXRoLnNpbihyKSxvPU1hdGguY29zKHIpLGY9TWF0aC5wb3coMTAsbikseD1NYXRoLmZsb29yKCh0LngrKGQqby1nKnUpKSpmKS9mLGM9TWF0aC5mbG9vcigodC55KyhkKnUrZypvKSkqZikvZjtyZXR1cm4gbmV3IEx0KHgsYyl9c3RhdGljIEdldERvdFN0cm9rZShlLHQscj0xNil7Y29uc3Qgbj1uZXcgY3QoMSwxKSxkPU1hdGguUEkrLjAwMSxnPUx0LkFkZChlLEx0LlN1YihlLG4pLnVuaSgpLnBlcigpLm11bCgtdCkpLHU9W107Zm9yKGxldCBvPTEvcixmPW87Zjw9MTtmKz1vKXUucHVzaChMdC5Sb3RXaXRoKGcsZSxkKjIqZikpO3JldHVybiB1fXN0YXRpYyBHZXRTZW1pY2lyY2xlU3Ryb2tlKGUsdCxyPS0xLG49OCl7Y29uc3QgZD1yKihNYXRoLlBJKy4wMDEpLGc9W107Zm9yKGxldCB1PTEvbixvPXU7bzw9MTtvKz11KWcucHVzaChMdC5Sb3RXaXRoKHQsZSxkKm8pKTtyZXR1cm4gZ319dmFyIG9yOyhmdW5jdGlvbihoKXtoW2gucGVkZGluZz0wXT0icGVkZGluZyIsaFtoLm1vdW50ZWQ9MV09Im1vdW50ZWQiLGhbaC51cGRhdGU9Ml09InVwZGF0ZSIsaFtoLnVubW91bnRlZD0zXT0idW5tb3VudGVkIn0pKG9yfHwob3I9e30pKTt2YXIgRHQ7KGZ1bmN0aW9uKGgpe2hbaC5Ob3JtYWw9MF09Ik5vcm1hbCIsaFtoLlN0cm9rZT0xXT0iU3Ryb2tlIixoW2guRG90dGVkPTJdPSJEb3R0ZWQiLGhbaC5Mb25nRG90dGVkPTNdPSJMb25nRG90dGVkIn0pKER0fHwoRHQ9e30pKTt2YXIgYnQ7KGZ1bmN0aW9uKGgpe2guU2hvd0Zsb2F0QmFyPSJTaG93RmxvYXRCYXIiLGguWkluZGV4RmxvYXRCYXI9IlpJbmRleEZsb2F0QmFyIixoLkRlbGV0ZU5vZGU9IkRlbGV0ZU5vZGUiLGguQ29weU5vZGU9IkNvcHlOb2RlIixoLlpJbmRleEFjdGl2ZT0iWkluZGV4QWN0aXZlIixoLlpJbmRleE5vZGU9IlpJbmRleE5vZGUiLGguUm90YXRlTm9kZT0iUm90YXRlTm9kZSIsaC5TZXRDb2xvck5vZGU9IlNldENvbG9yTm9kZSIsaC5UcmFuc2xhdGVOb2RlPSJUcmFuc2xhdGVOb2RlIixoLlNjYWxlTm9kZT0iU2NhbGVOb2RlIixoLk9yaWdpbmFsRXZlbnQ9Ik9yaWdpbmFsRXZlbnQiLGguQ3JlYXRlU2NlbmU9ImNyZWF0ZVNjZW5lIixoLkFjdGl2ZUN1cnNvcj0iQWN0aXZlQ3Vyc29yIixoLk1vdmVDdXJzb3I9Ik1vdmVDdXJzb3IifSkoYnR8fChidD17fSkpO3ZhciBhcjsoZnVuY3Rpb24oaCl7aC5EaXNwbGF5U3RhdGU9IkRpc3BsYXlTdGF0ZSIsaC5GbG9hdEJhcj0iRmxvYXRCYXIiLGguQ2FudmFzU2VsZWN0b3I9IkNhbnZhc1NlbGVjdG9yIixoLk1haW5FbmdpbmU9Ik1haW5FbmdpbmUiLGguRGlzcGxheUNvbnRhaW5lcj0iRGlzcGxheUNvbnRhaW5lciIsaC5DdXJzb3I9IkN1cnNvciJ9KShhcnx8KGFyPXt9KSk7ZnVuY3Rpb24gVHQoaCxlKXtpZihoJiZlKXtjb25zdCB0PU1hdGgubWluKGgueCxlLngpLHI9TWF0aC5taW4oaC55LGUueSksbj1NYXRoLm1heChoLngraC53LGUueCtlLncpLGQ9TWF0aC5tYXgoaC55K2guaCxlLnkrZS5oKSxnPW4tdCx1PWQtcjtyZXR1cm57eDp0LHk6cix3OmcsaDp1fX1yZXR1cm4gZXx8aH1mdW5jdGlvbiBadChoLGU9MCl7Y29uc3QgdD17eDowLHk6MCx3OjAsaDowfTtsZXQgcj0xLzAsbj0xLzAsZD0tMS8wLGc9LTEvMDtyZXR1cm4gaC5mb3JFYWNoKHU9Pntjb25zdFtvLGZdPXUuWFk7cj1NYXRoLm1pbihyLG8tZSksbj1NYXRoLm1pbihuLGYtZSksZD1NYXRoLm1heChkLG8rZSksZz1NYXRoLm1heChnLGYrZSl9KSx0Lng9cix0Lnk9bix0Lnc9ZC1yLHQuaD1nLW4sdH1mdW5jdGlvbiBtZShoLGUpe3JldHVybiEoaC54K2gudzxlLnh8fGgueD5lLngrZS53fHxoLnkraC5oPGUueXx8aC55PmUueStlLmgpfWZ1bmN0aW9uIGZuKGgsZSl7cmV0dXJuIGgubGVuZ3RoPT09ZS5sZW5ndGgmJmguc29ydCgpLnRvU3RyaW5nKCk9PT1lLnNvcnQoKS50b1N0cmluZygpfWZ1bmN0aW9uIGNuKGgsZT0xMCl7cmV0dXJue3g6TWF0aC5mbG9vcihoLngtZSkseTpNYXRoLmZsb29yKGgueS1lKSx3Ok1hdGguZmxvb3IoaC53K2UqMiksaDpNYXRoLmZsb29yKGguaCtlKjIpfX1mdW5jdGlvbiB1bihoLGUpe2NvbnN0IHQ9bmV3IGN0KGgueCxoLnkpLHI9bmV3IGN0KGgueCtoLncsaC55KSxuPW5ldyBjdChoLngraC53LGgueStoLmgpLGQ9bmV3IGN0KGgueCxoLnkraC5oKSxnPW5ldyBjdChoLngraC53LzIsaC55K2guaC8yKSx1PU1hdGguUEkqZS8xODAsbz1jdC5Sb3RXaXRoKHQsZyx1KSxmPWN0LlJvdFdpdGgocixnLHUpLHg9Y3QuUm90V2l0aChuLGcsdSksYz1jdC5Sb3RXaXRoKGQsZyx1KTtyZXR1cm4gWnQoW28sZix4LGNdKX1mdW5jdGlvbiBobihoLGUpe2NvbnN0IHQ9bmV3IGN0KGgueCxoLnkpLHI9bmV3IGN0KGgueCtoLncsaC55KSxuPW5ldyBjdChoLngraC53LGgueStoLmgpLGQ9bmV3IGN0KGgueCxoLnkraC5oKSxnPW5ldyBjdChoLngraC53LzIsaC55K2guaC8yKSx1PW5ldyBjdChlWzBdLGVbMV0pLG89Y3QuU2NhbGVXT3JpZ2luKHQsdSxnKSxmPWN0LlNjYWxlV09yaWdpbihyLHUsZykseD1jdC5TY2FsZVdPcmlnaW4obix1LGcpLGM9Y3QuU2NhbGVXT3JpZ2luKGQsdSxnKTtyZXR1cm4gWnQoW28sZix4LGNdKX1mdW5jdGlvbiBkbihoLGUsdCl7Y29uc3Qgcj1uZXcgY3QoZVswXSxlWzFdKTtmb3IobGV0IG49MDtuPGgubGVuZ3RoO24rPTMpe2NvbnN0IGQ9bmV3IGN0KGhbbl0saFtuKzFdKSxnPU1hdGguUEkqdC8xODAsdT1jdC5Sb3RXaXRoKGQscixnKTtoW25dPXUueCxoW24rMV09dS55fX1mdW5jdGlvbiBnbihoLGUsdCl7Y29uc3Qgcj1uZXcgY3QoZVswXSxlWzFdKTtmb3IobGV0IG49MDtuPGgubGVuZ3RoO24rPTMpe2NvbnN0IGQ9bmV3IGN0KGhbbl0saFtuKzFdKSxnPW5ldyBjdCh0WzBdLHRbMV0pO2lmKG48aC5sZW5ndGgtMyl7Y29uc3Qgbz1uZXcgY3QoaFtuKzNdLGhbbis0XSksZj1jdC5UYW4obyxkKS5wZXIoKS5tdWwoaFtuKzJdKS5tdWxWKGcpLmxlbigpO2hbbisyXT1mfWVsc2UgaWYobj09PWgubGVuZ3RoLTMpe2NvbnN0IG89bmV3IGN0KGhbbi0zXSxoW24tMl0pLGY9Y3QuVGFuKGQsbykucGVyKCkubXVsKGhbbisyXSkubXVsVihnKS5sZW4oKTtoW24rMl09Zn1jb25zdCB1PWN0LlNjYWxlV09yaWdpbihkLGcscik7aFtuXT11LngsaFtuKzFdPXUueX19ZnVuY3Rpb24gWHQoaCxlKXtsZXQgdDtyZXR1cm4gZT09bnVsbHx8ZS5nZXRFbGVtZW50c0J5TmFtZShoKS5mb3JFYWNoKHI9PntpZihyLnRhZ05hbWU9PT0iUEFUSCIpe2NvbnN0IG49cj09bnVsbD92b2lkIDA6ci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtuJiYodD1UdCh0LHt4Ok1hdGguZmxvb3Iobi54KSx5Ok1hdGguZmxvb3Iobi55KSx3Ok1hdGgucm91bmQobi53aWR0aCksaDpNYXRoLnJvdW5kKG4uaGVpZ2h0KX0pKX1lbHNlIGlmKHIudGFnTmFtZT09PSJHUk9VUCIpe2NvbnN0IG49ci5jbGFzc05hbWUuc3BsaXQoIiwiKTtpZihuLmxlbmd0aD09PTMmJk51bWJlcihuWzJdKT09PUR0LlN0cm9rZSl7Y29uc3QgZD1yPT1udWxsP3ZvaWQgMDpyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO2QmJih0PVR0KHQse3g6TWF0aC5mbG9vcihkLngpLHk6TWF0aC5mbG9vcihkLnkpLHc6TWF0aC5yb3VuZChkLndpZHRoKSxoOk1hdGgucm91bmQoZC5oZWlnaHQpfSkpfWVsc2Ugci5jaGlsZHJlbi5mb3JFYWNoKGQ9PntpZihkLnRhZ05hbWU9PT0iUEFUSCIpe2NvbnN0IGc9ZD09bnVsbD92b2lkIDA6ZC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtnJiYodD1UdCh0LHt4Ok1hdGguZmxvb3IoZy54KSx5Ok1hdGguZmxvb3IoZy55KSx3Ok1hdGgucm91bmQoZy53aWR0aCksaDpNYXRoLnJvdW5kKGcuaGVpZ2h0KX0pKX19KX19KSx0fWZ1bmN0aW9uIF90KGgpe3JldHVybmAke3ZlKGgueCl9LCR7dmUoaC55KX0gYH1mdW5jdGlvbiB0ZShoLGUpe3JldHVybmAke3ZlKChoLngrZS54KS8yKX0sJHt2ZSgoaC55K2UueSkvMil9IGB9ZnVuY3Rpb24gdmUoaCl7cmV0dXJuK2gudG9GaXhlZCg0KX1mdW5jdGlvbiB5ZShoLGU9ITApe2NvbnN0IHQ9aC5sZW5ndGg7aWYodDwyKXJldHVybiIiO2xldCByPWhbMF0sbj1oWzFdO2lmKHQ9PT0yKXJldHVybmBNJHtfdChyKX1MJHtfdChuKX1gO2xldCBkPSIiO2ZvcihsZXQgZz0yLHU9dC0xO2c8dTtnKyspcj1oW2ddLG49aFtnKzFdLGQrPXRlKHIsbik7cmV0dXJuIGU/YE0ke3RlKGhbMF0saFsxXSl9USR7X3QoaFsxXSl9JHt0ZShoWzFdLGhbMl0pfVQke2R9JHt0ZShoW3QtMV0saFswXSl9JHt0ZShoWzBdLGhbMV0pfVpgOmBNJHtfdChoWzBdKX1RJHtfdChoWzFdKX0ke3RlKGhbMV0saFsyXSl9JHtoLmxlbmd0aD4zPyJUIjoiIn0ke2R9TCR7X3QoaFt0LTFdKX1gfXZhciBwZT10eXBlb2YgZ2xvYmFsVGhpczwidSI/Z2xvYmFsVGhpczp0eXBlb2Ygd2luZG93PCJ1Ij93aW5kb3c6dHlwZW9mIGdsb2JhbDwidSI/Z2xvYmFsOnR5cGVvZiBzZWxmPCJ1Ij9zZWxmOnt9O2Z1bmN0aW9uIE5lKGgpe3JldHVybiBoJiZoLl9fZXNNb2R1bGUmJk9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChoLCJkZWZhdWx0Iik/aC5kZWZhdWx0Omh9dmFyIEJlPXtleHBvcnRzOnt9fTtCZS5leHBvcnRzLGZ1bmN0aW9uKGgpe3ZhciBlPWZ1bmN0aW9uKCl7dmFyIHQ9U3RyaW5nLmZyb21DaGFyQ29kZSxyPSJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPSIsbj0iQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLSQiLGQ9e307ZnVuY3Rpb24gZyhvLGYpe2lmKCFkW29dKXtkW29dPXt9O2Zvcih2YXIgeD0wO3g8by5sZW5ndGg7eCsrKWRbb11bby5jaGFyQXQoeCldPXh9cmV0dXJuIGRbb11bZl19dmFyIHU9e2NvbXByZXNzVG9CYXNlNjQ6ZnVuY3Rpb24obyl7aWYobz09bnVsbClyZXR1cm4iIjt2YXIgZj11Ll9jb21wcmVzcyhvLDYsZnVuY3Rpb24oeCl7cmV0dXJuIHIuY2hhckF0KHgpfSk7c3dpdGNoKGYubGVuZ3RoJTQpe2RlZmF1bHQ6Y2FzZSAwOnJldHVybiBmO2Nhc2UgMTpyZXR1cm4gZisiPT09IjtjYXNlIDI6cmV0dXJuIGYrIj09IjtjYXNlIDM6cmV0dXJuIGYrIj0ifX0sZGVjb21wcmVzc0Zyb21CYXNlNjQ6ZnVuY3Rpb24obyl7cmV0dXJuIG89PW51bGw/IiI6bz09IiI/bnVsbDp1Ll9kZWNvbXByZXNzKG8ubGVuZ3RoLDMyLGZ1bmN0aW9uKGYpe3JldHVybiBnKHIsby5jaGFyQXQoZikpfSl9LGNvbXByZXNzVG9VVEYxNjpmdW5jdGlvbihvKXtyZXR1cm4gbz09bnVsbD8iIjp1Ll9jb21wcmVzcyhvLDE1LGZ1bmN0aW9uKGYpe3JldHVybiB0KGYrMzIpfSkrIiAifSxkZWNvbXByZXNzRnJvbVVURjE2OmZ1bmN0aW9uKG8pe3JldHVybiBvPT1udWxsPyIiOm89PSIiP251bGw6dS5fZGVjb21wcmVzcyhvLmxlbmd0aCwxNjM4NCxmdW5jdGlvbihmKXtyZXR1cm4gby5jaGFyQ29kZUF0KGYpLTMyfSl9LGNvbXByZXNzVG9VaW50OEFycmF5OmZ1bmN0aW9uKG8pe2Zvcih2YXIgZj11LmNvbXByZXNzKG8pLHg9bmV3IFVpbnQ4QXJyYXkoZi5sZW5ndGgqMiksYz0wLHY9Zi5sZW5ndGg7Yzx2O2MrKyl7dmFyIHA9Zi5jaGFyQ29kZUF0KGMpO3hbYyoyXT1wPj4+OCx4W2MqMisxXT1wJTI1Nn1yZXR1cm4geH0sZGVjb21wcmVzc0Zyb21VaW50OEFycmF5OmZ1bmN0aW9uKG8pe2lmKG89PW51bGwpcmV0dXJuIHUuZGVjb21wcmVzcyhvKTtmb3IodmFyIGY9bmV3IEFycmF5KG8ubGVuZ3RoLzIpLHg9MCxjPWYubGVuZ3RoO3g8Yzt4KyspZlt4XT1vW3gqMl0qMjU2K29beCoyKzFdO3ZhciB2PVtdO3JldHVybiBmLmZvckVhY2goZnVuY3Rpb24ocCl7di5wdXNoKHQocCkpfSksdS5kZWNvbXByZXNzKHYuam9pbigiIikpfSxjb21wcmVzc1RvRW5jb2RlZFVSSUNvbXBvbmVudDpmdW5jdGlvbihvKXtyZXR1cm4gbz09bnVsbD8iIjp1Ll9jb21wcmVzcyhvLDYsZnVuY3Rpb24oZil7cmV0dXJuIG4uY2hhckF0KGYpfSl9LGRlY29tcHJlc3NGcm9tRW5jb2RlZFVSSUNvbXBvbmVudDpmdW5jdGlvbihvKXtyZXR1cm4gbz09bnVsbD8iIjpvPT0iIj9udWxsOihvPW8ucmVwbGFjZSgvIC9nLCIrIiksdS5fZGVjb21wcmVzcyhvLmxlbmd0aCwzMixmdW5jdGlvbihmKXtyZXR1cm4gZyhuLG8uY2hhckF0KGYpKX0pKX0sY29tcHJlc3M6ZnVuY3Rpb24obyl7cmV0dXJuIHUuX2NvbXByZXNzKG8sMTYsZnVuY3Rpb24oZil7cmV0dXJuIHQoZil9KX0sX2NvbXByZXNzOmZ1bmN0aW9uKG8sZix4KXtpZihvPT1udWxsKXJldHVybiIiO3ZhciBjLHYscD17fSxiPXt9LEU9IiIseT0iIixNPSIiLGk9MixhPTMscz0yLGw9W10sTz0wLEE9MCxSO2ZvcihSPTA7UjxvLmxlbmd0aDtSKz0xKWlmKEU9by5jaGFyQXQoUiksT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHAsRSl8fChwW0VdPWErKyxiW0VdPSEwKSx5PU0rRSxPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocCx5KSlNPXk7ZWxzZXtpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYixNKSl7aWYoTS5jaGFyQ29kZUF0KDApPDI1Nil7Zm9yKGM9MDtjPHM7YysrKU89Tzw8MSxBPT1mLTE/KEE9MCxsLnB1c2goeChPKSksTz0wKTpBKys7Zm9yKHY9TS5jaGFyQ29kZUF0KDApLGM9MDtjPDg7YysrKU89Tzw8MXx2JjEsQT09Zi0xPyhBPTAsbC5wdXNoKHgoTykpLE89MCk6QSsrLHY9dj4+MX1lbHNle2Zvcih2PTEsYz0wO2M8cztjKyspTz1PPDwxfHYsQT09Zi0xPyhBPTAsbC5wdXNoKHgoTykpLE89MCk6QSsrLHY9MDtmb3Iodj1NLmNoYXJDb2RlQXQoMCksYz0wO2M8MTY7YysrKU89Tzw8MXx2JjEsQT09Zi0xPyhBPTAsbC5wdXNoKHgoTykpLE89MCk6QSsrLHY9dj4+MX1pLS0saT09MCYmKGk9TWF0aC5wb3coMixzKSxzKyspLGRlbGV0ZSBiW01dfWVsc2UgZm9yKHY9cFtNXSxjPTA7YzxzO2MrKylPPU88PDF8diYxLEE9PWYtMT8oQT0wLGwucHVzaCh4KE8pKSxPPTApOkErKyx2PXY+PjE7aS0tLGk9PTAmJihpPU1hdGgucG93KDIscykscysrKSxwW3ldPWErKyxNPVN0cmluZyhFKX1pZihNIT09IiIpe2lmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLE0pKXtpZihNLmNoYXJDb2RlQXQoMCk8MjU2KXtmb3IoYz0wO2M8cztjKyspTz1PPDwxLEE9PWYtMT8oQT0wLGwucHVzaCh4KE8pKSxPPTApOkErKztmb3Iodj1NLmNoYXJDb2RlQXQoMCksYz0wO2M8ODtjKyspTz1PPDwxfHYmMSxBPT1mLTE/KEE9MCxsLnB1c2goeChPKSksTz0wKTpBKyssdj12Pj4xfWVsc2V7Zm9yKHY9MSxjPTA7YzxzO2MrKylPPU88PDF8dixBPT1mLTE/KEE9MCxsLnB1c2goeChPKSksTz0wKTpBKyssdj0wO2Zvcih2PU0uY2hhckNvZGVBdCgwKSxjPTA7YzwxNjtjKyspTz1PPDwxfHYmMSxBPT1mLTE/KEE9MCxsLnB1c2goeChPKSksTz0wKTpBKyssdj12Pj4xfWktLSxpPT0wJiYoaT1NYXRoLnBvdygyLHMpLHMrKyksZGVsZXRlIGJbTV19ZWxzZSBmb3Iodj1wW01dLGM9MDtjPHM7YysrKU89Tzw8MXx2JjEsQT09Zi0xPyhBPTAsbC5wdXNoKHgoTykpLE89MCk6QSsrLHY9dj4+MTtpLS0saT09MCYmKGk9TWF0aC5wb3coMixzKSxzKyspfWZvcih2PTIsYz0wO2M8cztjKyspTz1PPDwxfHYmMSxBPT1mLTE/KEE9MCxsLnB1c2goeChPKSksTz0wKTpBKyssdj12Pj4xO2Zvcig7OylpZihPPU88PDEsQT09Zi0xKXtsLnB1c2goeChPKSk7YnJlYWt9ZWxzZSBBKys7cmV0dXJuIGwuam9pbigiIil9LGRlY29tcHJlc3M6ZnVuY3Rpb24obyl7cmV0dXJuIG89PW51bGw/IiI6bz09IiI/bnVsbDp1Ll9kZWNvbXByZXNzKG8ubGVuZ3RoLDMyNzY4LGZ1bmN0aW9uKGYpe3JldHVybiBvLmNoYXJDb2RlQXQoZil9KX0sX2RlY29tcHJlc3M6ZnVuY3Rpb24obyxmLHgpe3ZhciBjPVtdLHY9NCxwPTQsYj0zLEU9IiIseT1bXSxNLGksYSxzLGwsTyxBLFI9e3ZhbDp4KDApLHBvc2l0aW9uOmYsaW5kZXg6MX07Zm9yKE09MDtNPDM7TSs9MSljW01dPU07Zm9yKGE9MCxsPU1hdGgucG93KDIsMiksTz0xO08hPWw7KXM9Ui52YWwmUi5wb3NpdGlvbixSLnBvc2l0aW9uPj49MSxSLnBvc2l0aW9uPT0wJiYoUi5wb3NpdGlvbj1mLFIudmFsPXgoUi5pbmRleCsrKSksYXw9KHM+MD8xOjApKk8sTzw8PTE7c3dpdGNoKGEpe2Nhc2UgMDpmb3IoYT0wLGw9TWF0aC5wb3coMiw4KSxPPTE7TyE9bDspcz1SLnZhbCZSLnBvc2l0aW9uLFIucG9zaXRpb24+Pj0xLFIucG9zaXRpb249PTAmJihSLnBvc2l0aW9uPWYsUi52YWw9eChSLmluZGV4KyspKSxhfD0ocz4wPzE6MCkqTyxPPDw9MTtBPXQoYSk7YnJlYWs7Y2FzZSAxOmZvcihhPTAsbD1NYXRoLnBvdygyLDE2KSxPPTE7TyE9bDspcz1SLnZhbCZSLnBvc2l0aW9uLFIucG9zaXRpb24+Pj0xLFIucG9zaXRpb249PTAmJihSLnBvc2l0aW9uPWYsUi52YWw9eChSLmluZGV4KyspKSxhfD0ocz4wPzE6MCkqTyxPPDw9MTtBPXQoYSk7YnJlYWs7Y2FzZSAyOnJldHVybiIifWZvcihjWzNdPUEsaT1BLHkucHVzaChBKTs7KXtpZihSLmluZGV4Pm8pcmV0dXJuIiI7Zm9yKGE9MCxsPU1hdGgucG93KDIsYiksTz0xO08hPWw7KXM9Ui52YWwmUi5wb3NpdGlvbixSLnBvc2l0aW9uPj49MSxSLnBvc2l0aW9uPT0wJiYoUi5wb3NpdGlvbj1mLFIudmFsPXgoUi5pbmRleCsrKSksYXw9KHM+MD8xOjApKk8sTzw8PTE7c3dpdGNoKEE9YSl7Y2FzZSAwOmZvcihhPTAsbD1NYXRoLnBvdygyLDgpLE89MTtPIT1sOylzPVIudmFsJlIucG9zaXRpb24sUi5wb3NpdGlvbj4+PTEsUi5wb3NpdGlvbj09MCYmKFIucG9zaXRpb249ZixSLnZhbD14KFIuaW5kZXgrKykpLGF8PShzPjA/MTowKSpPLE88PD0xO2NbcCsrXT10KGEpLEE9cC0xLHYtLTticmVhaztjYXNlIDE6Zm9yKGE9MCxsPU1hdGgucG93KDIsMTYpLE89MTtPIT1sOylzPVIudmFsJlIucG9zaXRpb24sUi5wb3NpdGlvbj4+PTEsUi5wb3NpdGlvbj09MCYmKFIucG9zaXRpb249ZixSLnZhbD14KFIuaW5kZXgrKykpLGF8PShzPjA/MTowKSpPLE88PD0xO2NbcCsrXT10KGEpLEE9cC0xLHYtLTticmVhaztjYXNlIDI6cmV0dXJuIHkuam9pbigiIil9aWYodj09MCYmKHY9TWF0aC5wb3coMixiKSxiKyspLGNbQV0pRT1jW0FdO2Vsc2UgaWYoQT09PXApRT1pK2kuY2hhckF0KDApO2Vsc2UgcmV0dXJuIG51bGw7eS5wdXNoKEUpLGNbcCsrXT1pK0UuY2hhckF0KDApLHYtLSxpPUUsdj09MCYmKHY9TWF0aC5wb3coMixiKSxiKyspfX19O3JldHVybiB1fSgpO2ghPW51bGw/aC5leHBvcnRzPWU6dHlwZW9mIGFuZ3VsYXI8InUiJiZhbmd1bGFyIT1udWxsJiZhbmd1bGFyLm1vZHVsZSgiTFpTdHJpbmciLFtdKS5mYWN0b3J5KCJMWlN0cmluZyIsZnVuY3Rpb24oKXtyZXR1cm4gZX0pfShCZSk7dmFyIGxyPUJlLmV4cG9ydHM7ZnVuY3Rpb24gZWUoaCl7cmV0dXJuIEpTT04ucGFyc2UobHIuZGVjb21wcmVzcyhoKSl9ZnVuY3Rpb24geGUoaCl7cmV0dXJuIGxyLmNvbXByZXNzKEpTT04uc3RyaW5naWZ5KGgpKX1jbGFzcyBCdCBleHRlbmRzIGdle2NvbnN0cnVjdG9yKGUsdCxyKXtzdXBlcih0LHIpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ0b29sc1R5cGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpBdC5QZW5jaWx9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywic3luY1RpbWVzdGFtcCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzeW5jSW5kZXgiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTowfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInRtcFBvaW50cyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOltdfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIk1BWF9SRVBFQVIiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZToxMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ1bmlUaGlja25lc3MiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywid29ya09wdGlvbnMiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiY2VudGVyUG9zIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6WzAsMF19KSx0aGlzLndvcmtPcHRpb25zPWUsdGhpcy51bmlUaGlja25lc3M9dGhpcy5NQVhfUkVQRUFSL2UudGhpY2tuZXNzLzEwLHRoaXMuc3luY1RpbWVzdGFtcD0wfWNvbWJpbmVDb25zdW1lKCl7dmFyIGQ7Y29uc3QgZT0oZD10aGlzLndvcmtJZCk9PW51bGw/dm9pZCAwOmQudG9TdHJpbmcoKSx0PXRoaXMudHJhbnNmb3JtRGF0YUFsbCghMCkscj17bmFtZTplLGNsYXNzTmFtZToicGVuY2lsIn07bGV0IG47cmV0dXJuIHQubGVuZ3RoJiYobj10aGlzLmRyYXcoe2F0dHJzOnIsdGFza3M6dCxyZXBsYWNlSWQ6ZSxpc0Z1bGxXb3JrOiExLG5vcm1hbGl6ZTohMCxpc0NsZWFyQWxsOiEwfSkpLHtyZWN0Om4sdHlwZTpwdC5EcmF3V29yayxkYXRhVHlwZTpTdC5Mb2NhbH19c2V0V29ya09wdGlvbnMoZSl7c3VwZXIuc2V0V29ya09wdGlvbnMoZSksdGhpcy5zeW5jVGltZXN0YW1wPURhdGUubm93KCl9Y29uc3VtZShlKXt2YXIgRTtjb25zdHtkYXRhOnQsaXNGdWxsV29yazpyLGlzQ2xlYXJBbGw6bixpc1N1YldvcmtlcjpkfT1lO2lmKCgoRT10Lm9wKT09bnVsbD92b2lkIDA6RS5sZW5ndGgpPT09MClyZXR1cm57dHlwZTpwdC5Ob25lfTtjb25zdHt3b3JrSWQ6Z309dCx7dGFza3M6dSxlZmZlY3RzOm8sY29uc3VtZUluZGV4OmZ9PXRoaXMudHJhbnNmb3JtRGF0YSh0LCExKTt0aGlzLnN5bmNJbmRleD1NYXRoLm1pbih0aGlzLnN5bmNJbmRleCxmKTtjb25zdCB4PXtuYW1lOmc9PW51bGw/dm9pZCAwOmcudG9TdHJpbmcoKSxjbGFzc05hbWU6InBlbmNpbCJ9O2xldCBjLHY9ITE7Y29uc3QgcD10aGlzLnN5bmNJbmRleDtpZih0aGlzLnN5bmNUaW1lc3RhbXA9PT0wJiYodGhpcy5zeW5jVGltZXN0YW1wPURhdGUubm93KCkpLHUubGVuZ3RoJiYodVswXS50YXNrSWQtdGhpcy5zeW5jVGltZXN0YW1wPnRoaXMuc3luY1VuaXRUaW1lJiYodj0hMCx0aGlzLnN5bmNUaW1lc3RhbXA9dVswXS50YXNrSWQsdGhpcy5zeW5jSW5kZXg9dGhpcy50bXBQb2ludHMubGVuZ3RoKSxjPXRoaXMuZHJhdyh7YXR0cnM6eCx0YXNrczp1LGVmZmVjdHM6byxpc0Z1bGxXb3JrOnIsaXNDbGVhckFsbDpufSkpLGQpcmV0dXJuIGY+MTAmJnRoaXMudG1wUG9pbnRzLnNwbGljZSgwLGYtMTApLHtyZWN0OmMsdHlwZTpwdC5EcmF3V29yayxkYXRhVHlwZTpTdC5Mb2NhbH07Y29uc3QgYj1bXTtyZXR1cm4gdGhpcy50bXBQb2ludHMuc2xpY2UocCkuZm9yRWFjaCh5PT57Yi5wdXNoKHkueCx5LnksdGhpcy5jb21wdXRSYWRpdXMoeS56LHRoaXMud29ya09wdGlvbnMudGhpY2tuZXNzKSl9KSx7cmVjdDpjLHR5cGU6cHQuRHJhd1dvcmssZGF0YVR5cGU6U3QuTG9jYWwsd29ya0lkOnY/Zzp2b2lkIDAsb3A6dj9iOnZvaWQgMCxpbmRleDp2P3AqMzp2b2lkIDB9fWNvbnN1bWVBbGwoZSl7dmFyIHUsbztpZihlLmRhdGEpe2NvbnN0e29wOmYsd29ya1N0YXRlOnh9PWUuZGF0YTtmIT1udWxsJiZmLmxlbmd0aCYmeD09PUd0LkRvbmUmJnRoaXMud29ya09wdGlvbnMuc3Ryb2tlVHlwZT09PUR0LlN0cm9rZSYmdGhpcy51cGRhdGVUZW1wUG9pbnRzV2l0aFByZXNzdXJlV2hlbkRvbmUoZil9Y29uc3QgdD0odT10aGlzLndvcmtJZCk9PW51bGw/dm9pZCAwOnUudG9TdHJpbmcoKSxyPXRoaXMudHJhbnNmb3JtRGF0YUFsbCghMCksbj17bmFtZTp0LGNsYXNzTmFtZToicGVuY2lsIn07bGV0IGQ7ci5sZW5ndGgmJihkPXRoaXMuZHJhdyh7YXR0cnM6bix0YXNrczpyLHJlcGxhY2VJZDp0LGlzRnVsbFdvcms6ITAsbm9ybWFsaXplOiEwLGlzQ2xlYXJBbGw6ITF9KSk7Y29uc3QgZz1bXTtyZXR1cm4gdGhpcy50bXBQb2ludHMubWFwKGY9PntnLnB1c2goZi54LGYueSx0aGlzLmNvbXB1dFJhZGl1cyhmLnosdGhpcy53b3JrT3B0aW9ucy50aGlja25lc3MpKX0pLHRoaXMuc3luY1RpbWVzdGFtcD0wLGRlbGV0ZSB0aGlzLndvcmtPcHRpb25zLnN5bmNVbml0VGltZSx7cmVjdDpkLHR5cGU6cHQuRnVsbFdvcmssZGF0YVR5cGU6U3QuTG9jYWwsd29ya0lkOnQsb3BzOnhlKGcpLHVwZGF0ZU5vZGVPcHQ6e3Bvczp0aGlzLmNlbnRlclBvcyx1c2VBbmltYXRpb246ITB9LG9wdDp0aGlzLndvcmtPcHRpb25zLHVuZG9UaWNrZXJJZDoobz1lLmRhdGEpPT1udWxsP3ZvaWQgMDpvLnVuZG9UaWNrZXJJZH19Y2xlYXJUbXBQb2ludHMoKXt0aGlzLnRtcFBvaW50cy5sZW5ndGg9MCx0aGlzLnN5bmNUaW1lc3RhbXA9MCx0aGlzLnN5bmNJbmRleD0wfWNvbnN1bWVTZXJ2aWNlKGUpe3ZhciB4O2NvbnN0e29wOnQsaXNGdWxsV29yazpyLHJlcGxhY2VJZDpuLGlzQ2xlYXJBbGw6ZH09ZTt0aGlzLnRtcFBvaW50cy5sZW5ndGg9MDtmb3IobGV0IGM9MDtjPHQubGVuZ3RoO2MrPTMpe2NvbnN0IHY9bmV3IEx0KHRbY10sdFtjKzFdLHRbYysyXSk7aWYodGhpcy50bXBQb2ludHMubGVuZ3RoPjApe2NvbnN0IHA9dGhpcy50bXBQb2ludHNbdGhpcy50bXBQb2ludHMubGVuZ3RoLTFdLGI9Y3QuU3ViKHYscCkudW5pKCk7di5zZXR2KGIpfXRoaXMudG1wUG9pbnRzLnB1c2godil9Y29uc3QgZz10aGlzLnRyYW5zZm9ybURhdGFBbGwoITEpLG89e25hbWU6KHg9dGhpcy53b3JrSWQpPT1udWxsP3ZvaWQgMDp4LnRvU3RyaW5nKCksY2xhc3NOYW1lOiJwZW5jaWwifTtsZXQgZjtyZXR1cm4gZy5sZW5ndGgmJihmPXRoaXMuZHJhdyh7YXR0cnM6byx0YXNrczpnLHJlcGxhY2VJZDpuLGlzRnVsbFdvcms6cixub3JtYWxpemU6ITAsaXNDbGVhckFsbDpkfSkpLGZ9dHJhbnNmb3JtRGF0YUFsbChlPSEwKXtyZXR1cm4gdGhpcy5nZXRUYXNrUG9pbnRzKHRoaXMudG1wUG9pbnRzLGUmJnRoaXMud29ya09wdGlvbnMudGhpY2tuZXNzfHx2b2lkIDApfWRyYXcoZSl7dmFyIGw7Y29uc3R7YXR0cnM6dCx0YXNrczpyLHJlcGxhY2VJZDpuLGVmZmVjdHM6ZCxpc0Z1bGxXb3JrOmcsbm9ybWFsaXplOnUsaXNDbGVhckFsbDpvfT1lLGY9Zz90aGlzLmZ1bGxMYXllcjp0aGlzLmRyYXdMYXllcnx8dGhpcy5mdWxsTGF5ZXIse2NvbG9yOngsc3Ryb2tlVHlwZTpjLHRoaWNrbmVzczp2LG9wYWNpdHk6cCx6SW5kZXg6YixzY2FsZTpFLHJvdGF0ZTp5fT10aGlzLndvcmtPcHRpb25zO28mJmYucmVtb3ZlQWxsQ2hpbGRyZW4oKSxuJiYodGhpcy5mdWxsTGF5ZXIuZ2V0RWxlbWVudHNCeU5hbWUobisiIikubWFwKE89Pk8ucmVtb3ZlKCkpLChsPXRoaXMuZHJhd0xheWVyKT09bnVsbHx8bC5nZXRFbGVtZW50c0J5TmFtZShuKyIiKS5tYXAoTz0+Ty5yZW1vdmUoKSkpLGQhPW51bGwmJmQuc2l6ZSYmKGQuZm9yRWFjaChPPT57dmFyIEE7KEE9Zi5nZXRFbGVtZW50QnlJZChPKyIiKSk9PW51bGx8fEEucmVtb3ZlKCl9KSxkLmNsZWFyKCkpO2xldCBNO2NvbnN0IGk9W10sYT1mLndvcmxkUG9zaXRpb24scz1mLndvcmxkU2NhbGluZztmb3IobGV0IE89MDtPPHIubGVuZ3RoO08rKyl7Y29uc3R7cG9zOkEscG9pbnRzOlIsdGFza0lkOkl9PXJbT107dC5pZD1JLnRvU3RyaW5nKCk7Y29uc3R7cHM6UCxyZWN0Okx9PXRoaXMuY29tcHV0RHJhd1BvaW50cyhSKTtsZXQgRDtjb25zdCBDPVIubGVuZ3RoPT09MTtjPT09RHQuU3Ryb2tlfHxDP0Q9eWUoUCwhMCk6RD15ZShQLCExKTtjb25zdCBTPXtwb3M6QSxkOkQsZmlsbENvbG9yOmM9PT1EdC5TdHJva2V8fEM/eDp2b2lkIDAsbGluZURhc2g6Yz09PUR0LkRvdHRlZCYmIUM/WzEsdioyXTpjPT09RHQuTG9uZ0RvdHRlZCYmIUM/W3YsdioyXTp2b2lkIDAsc3Ryb2tlQ29sb3I6eCxvcGFjaXR5OnAsbGluZUNhcDpjPT09RHQuU3Ryb2tlfHxDP3ZvaWQgMDoicm91bmQiLGxpbmVXaWR0aDpjPT09RHQuU3Ryb2tlfHxDPzA6dixjbGFzc05hbWU6YCR7QVswXX0sJHtBWzFdfSwke2N9YH07aWYoci5sZW5ndGg9PT0xJiZ1KXtjb25zdCBCPVtMLngrTC53LzIsTC55K0wuaC8yXTtpZih0aGlzLmNlbnRlclBvcz1bQlswXStBWzBdLEJbMV0rQVsxXV0sUy5ub3JtYWxpemU9ITAsUy5wb3M9dGhpcy5jZW50ZXJQb3MsUy5jbGFzc05hbWU9YCR7dGhpcy5jZW50ZXJQb3NbMF19LCR7dGhpcy5jZW50ZXJQb3NbMV19LCR7Y31gLFMuaWQ9dC5uYW1lLFMuekluZGV4PWIsRSl7Uy5zY2FsZT1FO2NvbnN0IHc9aG4oe3g6TWF0aC5mbG9vcihMLngrQVswXSthWzBdLUJ0LlBlbmNpbEJvcmRlclBhZGRpbmcpLHk6TWF0aC5mbG9vcihMLnkrQVsxXSthWzFdLUJ0LlBlbmNpbEJvcmRlclBhZGRpbmcpLHc6TWF0aC5mbG9vcihMLncrMipCdC5QZW5jaWxCb3JkZXJQYWRkaW5nKSxoOk1hdGguZmxvb3IoTC5oKzIqQnQuUGVuY2lsQm9yZGVyUGFkZGluZyl9LEUpO009VHQoTSx3KX1pZih5KXtTLnJvdGF0ZT15O2NvbnN0IHc9dW4oe3g6TWF0aC5mbG9vcihMLngrQVswXSthWzBdLUJ0LlBlbmNpbEJvcmRlclBhZGRpbmcpLHk6TWF0aC5mbG9vcihMLnkrQVsxXSthWzFdLUJ0LlBlbmNpbEJvcmRlclBhZGRpbmcpLHc6TWF0aC5mbG9vcihMLncrMipCdC5QZW5jaWxCb3JkZXJQYWRkaW5nKSxoOk1hdGguZmxvb3IoTC5oKzIqQnQuUGVuY2lsQm9yZGVyUGFkZGluZyl9LHkpO009VHQoTSx3KX19TT1UdChNLHt4Ok1hdGguZmxvb3IoKEwueCtBWzBdKSpzWzBdK2FbMF0tQnQuUGVuY2lsQm9yZGVyUGFkZGluZykseTpNYXRoLmZsb29yKChMLnkrQVsxXSkqc1sxXSthWzFdLUJ0LlBlbmNpbEJvcmRlclBhZGRpbmcpLHc6TWF0aC5mbG9vcihMLncqc1swXSsyKkJ0LlBlbmNpbEJvcmRlclBhZGRpbmcpLGg6TWF0aC5mbG9vcihMLmgqc1sxXSsyKkJ0LlBlbmNpbEJvcmRlclBhZGRpbmcpfSksaS5wdXNoKFMpfWlmKHUmJmkubGVuZ3RoPjEmJk0pe2NvbnN0IE89bmV3IERlO3RoaXMuY2VudGVyUG9zPVsoTS54K00udy8yLWFbMF0pL3NbMF0sKE0ueStNLmgvMi1hWzFdKS9zWzFdXSxPLmF0dHIoey4uLnQsaWQ6dC5uYW1lLGFuY2hvcjpbLjUsLjVdLGJnY29sb3I6Yz09PUR0LlN0cm9rZT94OnZvaWQgMCxzY2FsZTpFLG9wYWNpdHk6cCxwb3M6dGhpcy5jZW50ZXJQb3Mscm90YXRlOnksY2xhc3NOYW1lOmAke3RoaXMuY2VudGVyUG9zWzBdfSwke3RoaXMuY2VudGVyUG9zWzFdfSwke2N9YCxzaXplOltNLncsTS5oXSx6SW5kZXg6Yn0pLGkuZm9yRWFjaChBPT57QS5wb3M9W0EucG9zWzBdLXRoaXMuY2VudGVyUG9zWzBdLEEucG9zWzFdLXRoaXMuY2VudGVyUG9zWzFdXSxBLm9wYWNpdHk9MTtjb25zdCBSPW5ldyBJZShBKTtPLmFwcGVuZENoaWxkKFIpfSksYz09PUR0LlN0cm9rZSYmTy5zZWFsKCksZi5hcHBlbmQoTyl9ZWxzZXtjb25zdCBPPWkubWFwKEE9Pm5ldyBJZSh7Li4udCwuLi5BfSkpO2YuYXBwZW5kKC4uLk8pfXJldHVybiBNfWNvbXB1dERyYXdQb2ludHMoZSl7cmV0dXJuIHRoaXMud29ya09wdGlvbnMuc3Ryb2tlVHlwZT09PUR0LlN0cm9rZXx8ZS5sZW5ndGg9PT0xP3RoaXMuY29tcHV0U3Ryb2tlKGUpOnRoaXMuY29tcHV0Tm9tYWwoZSl9Y29tcHV0Tm9tYWwoZSl7bGV0IHQ9dGhpcy53b3JrT3B0aW9ucy50aGlja25lc3M7Y29uc3Qgcj1lLm1hcChuPT4odD1NYXRoLm1heCh0LG4ucmFkaXVzKSxuLnBvaW50KSk7cmV0dXJue3BzOnIscmVjdDpadChyLHQpfX1jb21wdXRTdHJva2UoZSl7cmV0dXJuIGUubGVuZ3RoPT09MT90aGlzLmNvbXB1dERvdFN0cm9rZShlWzBdKTp0aGlzLmNvbXB1dExpbmVTdHJva2UoZSl9Y29tcHV0TGluZVN0cm9rZShlKXtjb25zdCB0PVtdLHI9W107Zm9yKGxldCBvPTA7bzxlLmxlbmd0aDtvKyspe2NvbnN0e3BvaW50OmYscmFkaXVzOnh9PWVbb107bGV0IGM9Zi52O289PT0wJiZlLmxlbmd0aD4xJiYoYz1lW28rMV0ucG9pbnQudik7Y29uc3Qgdj1jdC5QZXIoYykubXVsKHgpO3QucHVzaChMdC5TdWIoZix2KSksci5wdXNoKEx0LkFkZChmLHYpKX1jb25zdCBuPWVbZS5sZW5ndGgtMV0sZD1MdC5HZXRTZW1pY2lyY2xlU3Ryb2tlKG4ucG9pbnQsdFt0Lmxlbmd0aC0xXSwtMSw4KSxnPUx0LkdldFNlbWljaXJjbGVTdHJva2UoZVswXS5wb2ludCxyWzBdLC0xLDgpLHU9dC5jb25jYXQoZCxyLnJldmVyc2UoKSxnKTtyZXR1cm57cHM6dSxyZWN0Olp0KHUpfX1jb21wdXREb3RTdHJva2UoZSl7Y29uc3R7cG9pbnQ6dCxyYWRpdXM6cn09ZSxuPXt4OnQueC1yLHk6dC55LXIsdzpyKjIsaDpyKjJ9O3JldHVybntwczpMdC5HZXREb3RTdHJva2UodCxyLDgpLHJlY3Q6bn19dHJhbnNmb3JtRGF0YShlLHQpe2NvbnN0e29wOnIsd29ya1N0YXRlOm59PWU7bGV0IGQ9dGhpcy50bXBQb2ludHMubGVuZ3RoLTEsZz1bXTtpZihyIT1udWxsJiZyLmxlbmd0aCYmbil7Y29uc3R7c3Ryb2tlVHlwZTp1LHRoaWNrbmVzczpvfT10aGlzLndvcmtPcHRpb25zLGY9bmV3IFNldDtkPXU9PT1EdC5TdHJva2U/dGhpcy51cGRhdGVUZW1wUG9pbnRzV2l0aFByZXNzdXJlKHIsbyxmKTp0aGlzLnVwZGF0ZVRlbXBQb2ludHMocixvLGYpO2NvbnN0IHg9dD90aGlzLnRtcFBvaW50czp0aGlzLnRtcFBvaW50cy5zbGljZShkKTtyZXR1cm4gZz10aGlzLmdldFRhc2tQb2ludHMoeCxvKSx7dGFza3M6ZyxlZmZlY3RzOmYsY29uc3VtZUluZGV4OmR9fXJldHVybnt0YXNrczpnLGNvbnN1bWVJbmRleDpkfX1jb21wdXRSYWRpdXMoZSx0KXtyZXR1cm4gZSouMDMqdCt0Ki41fWdldE1pblooZSx0KXtyZXR1cm4oKHR8fE1hdGgubWF4KDEsTWF0aC5mbG9vcihlKi4zKSkpLWUqLjUpKjEwMC9lLzN9Z2V0VGFza1BvaW50cyhlLHQpe3ZhciB4O2NvbnN0IHI9W107aWYoZS5sZW5ndGg9PT0wKXJldHVybltdO2xldCBuPTAsZD1lWzBdLngsZz1lWzBdLnksdT1bZCxnXSxvPVtdLGY9ZVswXS50O2Zvcig7bjxlLmxlbmd0aDspe2NvbnN0IGM9ZVtuXSx2PWMueC1kLHA9Yy55LWcsYj1jLnosRT10P3RoaXMuY29tcHV0UmFkaXVzKGIsdCk6YjtpZihvLnB1c2goe3BvaW50Om5ldyBMdCh2LHAsYixlW25dLnYpLHJhZGl1czpFfSksbj4wJiZuPGUubGVuZ3RoLTEpe2NvbnN0IHk9ZVtuXS5nZXRBbmdsZUJ5UG9pbnRzKGVbbi0xXSxlW24rMV0pO2lmKHk8OTB8fHk+MjcwKXtjb25zdCBNPSh4PW8ucG9wKCkpPT1udWxsP3ZvaWQgMDp4LnBvaW50LmNsb25lKCk7TSYmci5wdXNoKHt0YXNrSWQ6Zixwb3M6dSxwb2ludHM6Wy4uLm8se3BvaW50Ok0scmFkaXVzOkV9XX0pLGQ9ZVtuXS54LGc9ZVtuXS55LHU9W2QsZ107Y29uc3QgaT1jLngtZCxhPWMueS1nO289W3twb2ludDpuZXcgTHQoaSxhLGIpLHJhZGl1czpFfV0sZj1EYXRlLm5vdygpfX1uKyt9cmV0dXJuIHIucHVzaCh7dGFza0lkOmYscG9zOnUscG9pbnRzOm99KSxyfXVwZGF0ZVRlbXBQb2ludHNXaXRoUHJlc3N1cmUoZSx0LHIpe2NvbnN0IG49RGF0ZS5ub3coKSxkPXRoaXMudG1wUG9pbnRzLmxlbmd0aDtsZXQgZz1kO2ZvcihsZXQgbz0wO288ZS5sZW5ndGg7bys9Mil7Zz1NYXRoLm1pbihnLGQpO2NvbnN0IGY9dGhpcy50bXBQb2ludHMubGVuZ3RoLHg9bmV3IEx0KGVbb10sZVtvKzFdKTtpZihmPT09MCl7dGhpcy50bXBQb2ludHMucHVzaCh4KTtjb250aW51ZX1jb25zdCBjPWYtMSx2PXRoaXMudG1wUG9pbnRzW2NdLHA9Y3QuU3ViKHgsdikudW5pKCk7aWYoeC5pc05lYXIodix0KSl7aWYodi56PHRoaXMuTUFYX1JFUEVBUil7aWYodi5zZXR6KE1hdGgubWluKHYueisxLHRoaXMuTUFYX1JFUEVBUikpLGc9TWF0aC5taW4oZyxjKSxmPjEpe2xldCB5PWYtMTtmb3IoO3k+MDspe2NvbnN0IE09dGhpcy50bXBQb2ludHNbeV0uZGlzdGFuY2UodGhpcy50bXBQb2ludHNbeS0xXSksaT1NYXRoLm1heCh0aGlzLnRtcFBvaW50c1t5XS56LXRoaXMudW5pVGhpY2tuZXNzKk0sMCk7aWYodGhpcy50bXBQb2ludHNbeS0xXS56Pj1pKWJyZWFrO3RoaXMudG1wUG9pbnRzW3ktMV0uc2V0eihpKSxnPU1hdGgubWluKGcseS0xKSx5LS19fX1lbHNlIGc9MS8wO2NvbnRpbnVlfXguc2V0dihwKTtjb25zdCBiPXguZGlzdGFuY2UodiksRT1NYXRoLm1heCh2LnotdGhpcy51bmlUaGlja25lc3MqYiwwKTtmPjEmJmN0LkVxdWFscyhwLHYudiwuMDIpJiYoRT4wfHx2Lno8PTApJiYociYmdi50JiZyLmFkZCh2LnQpLHRoaXMudG1wUG9pbnRzLnBvcCgpLGc9TWF0aC5taW4oYyxnKSkseC5zZXR6KEUpLHRoaXMudG1wUG9pbnRzLnB1c2goeCl9aWYoZz09PTEvMClyZXR1cm4gdGhpcy50bXBQb2ludHMubGVuZ3RoO2xldCB1PWQ7aWYoZz09PWQpe3U9TWF0aC5tYXgodS0xLDApO2NvbnN0IG89dGhpcy50bXBQb2ludHNbdV0udDtvJiYocj09bnVsbHx8ci5hZGQobykpfWVsc2V7bGV0IG89ZC0xO2Zvcih1PWc7bz49MDspe2NvbnN0IGY9dGhpcy50bXBQb2ludHNbb10udDtpZihmJiYocj09bnVsbHx8ci5hZGQoZiksbzw9Zykpe3U9byxvPS0xO2JyZWFrfW8tLX19cmV0dXJuIHRoaXMudG1wUG9pbnRzW3VdLnNldFQobiksdX11cGRhdGVUZW1wUG9pbnRzKGUsdCxyKXt2YXIgbztjb25zdCBuPURhdGUubm93KCksZD10aGlzLnRtcFBvaW50cy5sZW5ndGg7bGV0IGc9ZDtmb3IobGV0IGY9MDtmPGUubGVuZ3RoO2YrPTIpe2NvbnN0IHg9dGhpcy50bXBQb2ludHMubGVuZ3RoLGM9bmV3IEx0KGVbZl0sZVtmKzFdKTtpZih4PT09MCl7dGhpcy50bXBQb2ludHMucHVzaChjKTtjb250aW51ZX1jb25zdCB2PXgtMSxwPXRoaXMudG1wUG9pbnRzW3ZdLGI9Y3QuU3ViKGMscCkudW5pKCk7aWYoY3QuRXF1YWxzKGIscC52LC4wMikpe3ImJnAudCYmci5hZGQocC50KSx0aGlzLnRtcFBvaW50cy5wb3AoKSxnPU1hdGgubWluKHYsZyk7Y29udGludWV9aWYoYy5pc05lYXIocCx0LzIpKXtnPU1hdGgubWluKHYsZyk7Y29udGludWV9Yy5zZXR2KGIpLHRoaXMudG1wUG9pbnRzLnB1c2goYyl9bGV0IHU9ZDtpZihnPT09ZCl7dT1NYXRoLm1heCh1LTEsMCk7Y29uc3QgZj10aGlzLnRtcFBvaW50c1t1XS50O2YmJihyPT1udWxsfHxyLmFkZChmKSl9ZWxzZXtsZXQgZj1NYXRoLm1pbihkLTEsZyk7Zm9yKHU9ZztmPj0wOyl7Y29uc3QgeD0obz10aGlzLnRtcFBvaW50c1tmXSk9PW51bGw/dm9pZCAwOm8udDtpZih4JiYocj09bnVsbHx8ci5hZGQoeCksZjw9Zykpe3U9ZixmPS0xO2JyZWFrfWYtLX19cmV0dXJuIHRoaXMudG1wUG9pbnRzW3VdLnNldFQobiksdX11cGRhdGVUZW1wUG9pbnRzV2l0aFByZXNzdXJlV2hlbkRvbmUoZSl7Y29uc3R7dGhpY2tuZXNzOnR9PXRoaXMud29ya09wdGlvbnMscj1lLmxlbmd0aCxuPXRoaXMuZ2V0TWluWih0KTtmb3IobGV0IGQ9MDtkPHI7ZCs9Mil7Y29uc3QgZz10aGlzLnRtcFBvaW50cy5sZW5ndGgsdT1uZXcgTHQoZVtkXSxlW2QrMV0pO2lmKGc9PT0wKXt0aGlzLnRtcFBvaW50cy5wdXNoKHUpO2NvbnRpbnVlfWNvbnN0IG89Zy0xLGY9dGhpcy50bXBQb2ludHNbb10seD1jdC5TdWIodSxmKS51bmkoKSxjPXUuZGlzdGFuY2UoZik7aWYoZz4xJiZmLno9PT1uKWJyZWFrO2lmKHUuaXNOZWFyKGYsdC8yKSl7aWYocjwzJiZmLno8dGhpcy5NQVhfUkVQRUFSJiYoZi5zZXR6KE1hdGgubWluKGYueisxLHRoaXMuTUFYX1JFUEVBUikpLGc+MSkpe2xldCBwPWctMTtmb3IoO3A+MDspe2NvbnN0IGI9dGhpcy50bXBQb2ludHNbcF0uZGlzdGFuY2UodGhpcy50bXBQb2ludHNbcC0xXSksRT1NYXRoLm1heCh0aGlzLnRtcFBvaW50c1twXS56LXRoaXMudW5pVGhpY2tuZXNzKmIsLXQvNCk7aWYodGhpcy50bXBQb2ludHNbcC0xXS56Pj1FKWJyZWFrO3RoaXMudG1wUG9pbnRzW3AtMV0uc2V0eihFKSxwLS19fWNvbnRpbnVlfXUuc2V0dih4KTtjb25zdCB2PU1hdGgubWF4KGYuei10aGlzLnVuaVRoaWNrbmVzcypjLG4pO2c+MSYmY3QuRXF1YWxzKHgsZi52LC4wMikmJmYuejw9MCYmdGhpcy50bXBQb2ludHMucG9wKCksdS5zZXR6KHYpLHRoaXMudG1wUG9pbnRzLnB1c2godSl9fXVwZGF0YU9wdFNlcnZpY2UoZSl7dmFyIG47bGV0IHQ7Y29uc3Qgcj0obj10aGlzLndvcmtJZCk9PW51bGw/dm9pZCAwOm4udG9TdHJpbmcoKTtpZihyJiZlKXtjb25zdCBkPXRoaXMuZnVsbExheWVyLmdldEVsZW1lbnRzQnlOYW1lKHIpLHtwb3M6Zyx6SW5kZXg6dSxjb2xvcjpvLHNjYWxlOmYsYW5nbGU6eCxvcGFjaXR5OmN9PWUsdj17fTtpZih0eXBlb2YgdT09Im51bWJlciImJih2LnpJbmRleD11KSxnJiYodi5wb3M9W2dbMF0sZ1sxXV0sZFswXSkpe2NvbnN0IHA9ZFswXS5jbGFzc05hbWUuc3BsaXQoIiwiKTt2LmNsYXNzTmFtZT1gJHtnWzBdfSwke2dbMV19LCR7cFsyXX1gfXJldHVybiBvJiYodi5zdHJva2VDb2xvcj1vKSxmJiYodi5zY2FsZT1mKSxjJiYodi5vcGFjaXR5PWMpLHgmJih2LnJvdGF0ZT14KSxPYmplY3Qua2V5cyh2KS5sZW5ndGgmJmQuZm9yRWFjaChwPT57Y29uc3QgYj1wLmF0dHIoImZpbGxDb2xvciIpO28mJmI/cC5hdHRyKHsuLi52LGZpbGxDb2xvcjpvfSk6cC5hdHRyKHYpO2NvbnN0IEU9cD09bnVsbD92b2lkIDA6cC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtFJiYodD1UdCh0LHt4Ok1hdGguZmxvb3IoRS54LUJ0LlBlbmNpbEJvcmRlclBhZGRpbmcpLHk6TWF0aC5mbG9vcihFLnktQnQuUGVuY2lsQm9yZGVyUGFkZGluZyksdzpNYXRoLmZsb29yKEUud2lkdGgrQnQuUGVuY2lsQm9yZGVyUGFkZGluZyoyKSxoOk1hdGguZmxvb3IoRS5oZWlnaHQrQnQuUGVuY2lsQm9yZGVyUGFkZGluZyoyKX0pKX0pLHR9fX1PYmplY3QuZGVmaW5lUHJvcGVydHkoQnQsIlBlbmNpbEJvcmRlclBhZGRpbmciLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZToxMH0pO3ZhciBtbj1NZTtNZS5wb2x5bGluZT1NZSxNZS5wb2x5Z29uPXZuO2Z1bmN0aW9uIE1lKGgsZSx0KXt2YXIgcj1oLmxlbmd0aCxuPXJlKGhbMF0sZSksZD1bXSxnLHUsbyxmLHg7Zm9yKHR8fCh0PVtdKSxnPTE7ZzxyO2crKyl7Zm9yKHU9aFtnLTFdLG89aFtnXSxmPXg9cmUobyxlKTs7KWlmKG58Zil7aWYobiZmKWJyZWFrO24/KHU9amUodSxvLG4sZSksbj1yZSh1LGUpKToobz1qZSh1LG8sZixlKSxmPXJlKG8sZSkpfWVsc2V7ZC5wdXNoKHUpLGYhPT14PyhkLnB1c2gobyksZzxyLTEmJih0LnB1c2goZCksZD1bXSkpOmc9PT1yLTEmJmQucHVzaChvKTticmVha31uPXh9cmV0dXJuIGQubGVuZ3RoJiZ0LnB1c2goZCksdH1mdW5jdGlvbiB2bihoLGUpe3ZhciB0LHIsbixkLGcsdSxvO2ZvcihyPTE7cjw9ODtyKj0yKXtmb3IodD1bXSxuPWhbaC5sZW5ndGgtMV0sZD0hKHJlKG4sZSkmciksZz0wO2c8aC5sZW5ndGg7ZysrKXU9aFtnXSxvPSEocmUodSxlKSZyKSxvIT09ZCYmdC5wdXNoKGplKG4sdSxyLGUpKSxvJiZ0LnB1c2godSksbj11LGQ9bztpZihoPXQsIWgubGVuZ3RoKWJyZWFrfXJldHVybiB0fWZ1bmN0aW9uIGplKGgsZSx0LHIpe3JldHVybiB0Jjg/W2hbMF0rKGVbMF0taFswXSkqKHJbM10taFsxXSkvKGVbMV0taFsxXSksclszXV06dCY0P1toWzBdKyhlWzBdLWhbMF0pKihyWzFdLWhbMV0pLyhlWzFdLWhbMV0pLHJbMV1dOnQmMj9bclsyXSxoWzFdKyhlWzFdLWhbMV0pKihyWzJdLWhbMF0pLyhlWzBdLWhbMF0pXTp0JjE/W3JbMF0saFsxXSsoZVsxXS1oWzFdKSooclswXS1oWzBdKS8oZVswXS1oWzBdKV06bnVsbH1mdW5jdGlvbiByZShoLGUpe3ZhciB0PTA7cmV0dXJuIGhbMF08ZVswXT90fD0xOmhbMF0+ZVsyXSYmKHR8PTIpLGhbMV08ZVsxXT90fD00OmhbMV0+ZVszXSYmKHR8PTgpLHR9dmFyIHluPU5lKG1uKTtjbGFzcyBLdCBleHRlbmRzIGdle3VwZGF0YU9wdFNlcnZpY2UoKXt9Y29uc3RydWN0b3IoZSx0KXtzdXBlcih0KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywic3luY1RpbWVzdGFtcCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ0b29sc1R5cGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpBdC5FcmFzZXJ9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidG1wUG9pbnRzIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6W119KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywid29ya09wdGlvbnMiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywid29ybGRQb3NpdGlvbiIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ3b3JsZFNjYWxpbmciLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiZXJhc2VyUmVjdCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJlcmFzZXJQb2x5bGluZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJjdXJOb2RlTWFwIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6bmV3IE1hcH0pLHRoaXMud29ya09wdGlvbnM9ZSx0aGlzLnN5bmNUaW1lc3RhbXA9MCx0aGlzLndvcmxkUG9zaXRpb249dGhpcy5mdWxsTGF5ZXIud29ybGRQb3NpdGlvbix0aGlzLndvcmxkU2NhbGluZz10aGlzLmZ1bGxMYXllci53b3JsZFNjYWxpbmd9Y29tcHV0Tm9kZU1hcChlKXt0aGlzLmN1ck5vZGVNYXAuY2xlYXIoKSxlLmZvckVhY2godD0+e2NvbnN0IHI9dGhpcy5mdWxsTGF5ZXIuZ2V0RWxlbWVudHNCeU5hbWUodC5uYW1lKVswXSxuPXQub3BzJiZlZSh0Lm9wcyk7aWYociYmbi5sZW5ndGgpe2NvbnN0IGQ9W107Zm9yKGxldCB1PTA7dTxuLmxlbmd0aDt1Kz0zKXtjb25zdCBvPW5ldyBjdChuW3VdKnRoaXMud29ybGRTY2FsaW5nWzBdK3RoaXMud29ybGRQb3NpdGlvblswXSxuW3UrMV0qdGhpcy53b3JsZFNjYWxpbmdbMV0rdGhpcy53b3JsZFBvc2l0aW9uWzFdLG5bdSsyXSk7ZC5wdXNoKG8pfWxldCBnPXQub3B0O2lmKCFnKXtsZXQgdT1yLmdldEF0dHJpYnV0ZSgic3Ryb2tlQ29sb3IiKTtjb25zdCBvPXIuY2xhc3NOYW1lLnNwbGl0KCIsIiksZj1OdW1iZXIob1syXSk7ci50YWdOYW1lPT09IkdST1VQIiYmKGY9PT1EdC5TdHJva2U/dT1yLmdldEF0dHJpYnV0ZSgiYmdjb2xvciIpOnU9ci5jaGlsZHJlblswXS5nZXRBdHRyaWJ1dGUoInN0cm9rZUNvbG9yIikpO2NvbnN0IHg9ci5nZXRBdHRyaWJ1dGUoIm9wYWNpdHkiKSxjPXIuZ2V0QXR0cmlidXRlKCJzY2FsZSIpLHY9ci5nZXRBdHRyaWJ1dGUoInpJbmRleCIpLHA9ci5nZXRBdHRyaWJ1dGUoInJvdGF0ZSIpLGI9dGhpcy53b3JrT3B0aW9ucy5zeW5jVW5pdFRpbWU7Zz17Y29sb3I6dSxvcGFjaXR5Ongsc3luY1VuaXRUaW1lOmIsekluZGV4OnYsc2NhbGU6Yyxyb3RhdGU6cCxzdHJva2VUeXBlOmZ9fXRoaXMuY3VyTm9kZU1hcC5zZXQodC5uYW1lLHtuYW1lOnQubmFtZSxyZWN0OnQucmVjdCxwb2x5bGluZTpkLG9wdDpnLHRvb2xzVHlwZTp0LnRvb2xzVHlwZXx8QXQuUGVuY2lsfSl9fSl9dXBkYXRhTm9kZU1hcChlLHQpe2NvbnN0IHI9dC5vcCxuPVtdO2ZvcihsZXQgZD0wO2Q8ci5sZW5ndGg7ZCs9Myl7Y29uc3QgZz1uZXcgY3QocltkXSp0aGlzLndvcmxkU2NhbGluZ1swXSt0aGlzLndvcmxkUG9zaXRpb25bMF0scltkKzFdKnRoaXMud29ybGRTY2FsaW5nWzFdK3RoaXMud29ybGRQb3NpdGlvblsxXSxyW2QrMl0pO24ucHVzaChnKX10aGlzLmN1ck5vZGVNYXAuc2V0KGUse25hbWU6dC5uYW1lLHJlY3Q6dC5yZWN0LHBvbHlsaW5lOm4sb3B0OnQub3B0LHRvb2xzVHlwZTp0LnRvb2xzVHlwZXx8QXQuUGVuY2lsfSl9Y29tYmluZUNvbnN1bWUoKXt9Y3JlYXRlRXJhc2VyUmVjdChlKXtjb25zdCB0PWVbMF0qdGhpcy53b3JsZFNjYWxpbmdbMF0rdGhpcy53b3JsZFBvc2l0aW9uWzBdLHI9ZVsxXSp0aGlzLndvcmxkU2NhbGluZ1sxXSt0aGlzLndvcmxkUG9zaXRpb25bMV0se3dpZHRoOm4saGVpZ2h0OmR9PUt0LmVyYXNlclNpemVzW3RoaXMud29ya09wdGlvbnMudGhpY2tuZXNzXTt0aGlzLmVyYXNlclJlY3Q9e3g6dC1uKi41LHk6ci1kKi41LHc6bixoOmR9LHRoaXMuZXJhc2VyUG9seWxpbmU9W3RoaXMuZXJhc2VyUmVjdC54LHRoaXMuZXJhc2VyUmVjdC55LHRoaXMuZXJhc2VyUmVjdC54K3RoaXMuZXJhc2VyUmVjdC53LHRoaXMuZXJhc2VyUmVjdC55K3RoaXMuZXJhc2VyUmVjdC5oXX1jb25zdW1lU2VydmljZSgpe31zZXRXb3JrT3B0aW9ucyhlKXtzdXBlci5zZXRXb3JrT3B0aW9ucyhlKSx0aGlzLnN5bmNUaW1lc3RhbXA9RGF0ZS5ub3coKX1jb21wdXRSZWN0Q2VudGVyUG9pbnRzKCl7Y29uc3QgZT10aGlzLnRtcFBvaW50cy5zbGljZSgtMik7aWYodGhpcy50bXBQb2ludHMubGVuZ3RoPT09NCl7Y29uc3QgdD1uZXcgY3QodGhpcy50bXBQb2ludHNbMF0sdGhpcy50bXBQb2ludHNbMV0pLHI9bmV3IGN0KHRoaXMudG1wUG9pbnRzWzJdLHRoaXMudG1wUG9pbnRzWzNdKSxuPWN0LlN1YihyLHQpLnVuaSgpLGQ9Y3QuRGlzdCh0LHIpLHt3aWR0aDpnLGhlaWdodDp1fT1LdC5lcmFzZXJTaXplc1t0aGlzLndvcmtPcHRpb25zLnRoaWNrbmVzc10sbz1NYXRoLm1pbihnLHUpLGY9TWF0aC5yb3VuZChkL28pO2lmKGY+MSl7Y29uc3QgeD1bXTtmb3IobGV0IGM9MDtjPGY7YysrKXtjb25zdCB2PWN0Lk11bChuLGMqbyk7eC5wdXNoKHRoaXMudG1wUG9pbnRzWzBdK3YueCx0aGlzLnRtcFBvaW50c1sxXSt2LnkpfXJldHVybiB4LmNvbmNhdChlKX19cmV0dXJuIGV9aXNOZWFyKGUsdCl7Y29uc3Qgcj1uZXcgY3QoZVswXSxlWzFdKSxuPW5ldyBjdCh0WzBdLHRbMV0pLHt3aWR0aDpkLGhlaWdodDpnfT1LdC5lcmFzZXJTaXplc1t0aGlzLndvcmtPcHRpb25zLnRoaWNrbmVzc107cmV0dXJuIGN0LkRpc3QocixuKTxNYXRoLmh5cG90KGQsZykqLjV9Y29uc3VtZShlKXtjb25zdHtvcDp0LHdvcmtTdGF0ZTpyfT1lLmRhdGE7aWYoIXR8fHQubGVuZ3RoPT09MClyZXR1cm57dHlwZTpwdC5Ob25lfTtyPT09R3QuU3RhcnQmJmUubm9kZU1hcHMmJnRoaXMuY29tcHV0Tm9kZU1hcChlLm5vZGVNYXBzKTtjb25zdCBuPXRoaXMudG1wUG9pbnRzLmxlbmd0aDtpZihuPjEmJnRoaXMuaXNOZWFyKFt0WzBdLHRbMV1dLFt0aGlzLnRtcFBvaW50c1tuLTJdLHRoaXMudG1wUG9pbnRzW24tMV1dKSlyZXR1cm57dHlwZTpwdC5Ob25lfTtpZihlLm5vZGVNYXBzKXtuPT09NCYmKHRoaXMudG1wUG9pbnRzLnNoaWZ0KCksdGhpcy50bXBQb2ludHMuc2hpZnQoKSksdGhpcy50bXBQb2ludHMucHVzaCh0WzBdLHRbMV0pO2NvbnN0IGQ9dGhpcy5jb21wdXRSZWN0Q2VudGVyUG9pbnRzKCk7bGV0IGc7Y29uc3QgdT1uZXcgU2V0LG89bmV3IE1hcDtmb3IobGV0IGY9MDtmPGQubGVuZ3RoLTE7Zis9Mil7dGhpcy5jcmVhdGVFcmFzZXJSZWN0KGQuc2xpY2UoZixmKzIpKTtjb25zdHtyZWN0OngscmVtb3ZlSWRzOmMsbmV3V29ya0RhdGFzOnZ9PXRoaXMucmVtb3ZlKCk7Zz1UdChnLHgpLGMuZm9yRWFjaChwPT51LmFkZChwKSksdj09bnVsbHx8di5mb3JFYWNoKHA9Pnt1LmhhcyhwLndvcmtJZCl8fG8uc2V0KHAud29ya0lkLHApfSl9aWYoZyYmdS5zaXplKXtjb25zdCBmPVtdO2Zvcihjb25zdCB4IG9mIG8udmFsdWVzKCkpdS5oYXMoeC53b3JrSWQpfHxmLnB1c2goeCk7cmV0dXJue3R5cGU6cHQuUmVtb3ZlTm9kZSxkYXRhVHlwZTpTdC5Mb2NhbCxyZWN0OmcscmVtb3ZlSWRzOlsuLi51XSxuZXdXb3JrRGF0YXM6Zn19fXJldHVybnt0eXBlOnB0Lk5vbmV9fWN1dFBvbHlsaW5lKGUsdCl7bGV0IHI9W3RdLG49MDtmb3IoO248ZS5sZW5ndGg7KXtjb25zdCB1PWVbbl07aWYodS5sZW5ndGg8MilicmVhaztyPWQocix1KSxuKyt9cmV0dXJuIHI7ZnVuY3Rpb24gZCh1LG8pe2NvbnN0IGY9dTtmb3IobGV0IHg9MDt4PHUubGVuZ3RoO3grKyl7Y29uc3QgYz11W3hdLHY9Yy5maW5kSW5kZXgoKHAsYik9PmI8Yy5sZW5ndGgtMT9nKFtwLGNbYisxXV0sW29bMF0sb1sxXV0pOiExKTtpZih2IT09LTEmJnY+LTEpe2NvbnN0IHA9W10sYj1jLnNsaWNlKDAsdisxKTtpZihjdC5FcXVhbHMoY1t2XSxvWzBdKXx8Yi5wdXNoKG9bMF0uY2xvbmUoKS5zZXR6KGNbdl0ueikpLGIubGVuZ3RoPjEmJnAucHVzaChiKSx2K28ubGVuZ3RoLTE8Yy5sZW5ndGgtMSl7Y29uc3QgRT12K28ubGVuZ3RoLTEseT1jLnNsaWNlKEUpLE09b1tvLmxlbmd0aC0xXTtjdC5FcXVhbHMoY1tFXSxNKXx8eS51bnNoaWZ0KE0uY2xvbmUoKS5zZXR6KGNbRV0ueikpLHkubGVuZ3RoPjEmJnAucHVzaCh5KX1yZXR1cm4gZi5zcGxpY2UoeCwxLC4uLnApLGZ9fXJldHVybiBmfWZ1bmN0aW9uIGcodSxvKXtjb25zdCBmPWN0LlN1Yih1WzFdLHVbMF0pLHg9Y3QuU3ViKG9bMV0sb1swXSksYz1jdC5TdWIob1swXSx1WzBdKTtyZXR1cm4gTWF0aC5hYnMoY3QuQ3ByKGYseCkpPC4xJiZNYXRoLmFicyhjdC5DcHIoZixjKSk8LjF9fWlzU2FtZVBvaW50KGUsdCl7cmV0dXJuIGVbMF09PT10WzBdJiZlWzFdPT09dFsxXX10cmFuc2xhdGVJbnRlcnNlY3QoZSl7Y29uc3QgdD1bXTtmb3IobGV0IHI9MDtyPGUubGVuZ3RoO3IrKyl7Y29uc3Qgbj1lW3JdLmZpbHRlcigodSxvLGYpPT4hKG8+MCYmdGhpcy5pc1NhbWVQb2ludCh1LGZbby0xXSkpKSxkPVtdO2xldCBnPTA7Zm9yKDtnPG4ubGVuZ3RoOyl7Y29uc3QgdT1uW2ddLG89bmV3IGN0KHVbMF0sdVsxXSk7ZC5wdXNoKG8pLGcrK310LnB1c2goZCl9cmV0dXJuIHR9cmVtb3ZlKCl7Y29uc3R7aXNMaW5lOmV9PXRoaXMud29ya09wdGlvbnM7bGV0IHQ7Y29uc3Qgcj1bXSxuPVtdLGQ9W107cmV0dXJuIHRoaXMuY3VyTm9kZU1hcC5mb3JFYWNoKChnLHUpPT57Y29uc3Qgbz10aGlzLmZ1bGxMYXllci5nZXRFbGVtZW50c0J5TmFtZShnLm5hbWUpWzBdO2lmKG8mJmcucmVjdCYmdGhpcy5lcmFzZXJSZWN0JiZ0aGlzLmVyYXNlclBvbHlsaW5lJiZtZSh0aGlzLmVyYXNlclJlY3QsZy5yZWN0KSl7aWYoZy5wb2x5bGluZS5sZW5ndGg+MSl7Y29uc3QgZj15bi5wb2x5bGluZShnLnBvbHlsaW5lLm1hcCh4PT54LlhZKSx0aGlzLmVyYXNlclBvbHlsaW5lKTtpZihmLmxlbmd0aCYmKG4ucHVzaChvKSxyLnB1c2goZy5uYW1lKSwhZSkpe2NvbnN0IHg9dGhpcy50cmFuc2xhdGVJbnRlcnNlY3QoZiksYz10aGlzLmN1dFBvbHlsaW5lKHgsZy5wb2x5bGluZSk7Zm9yKGxldCB2PTA7djxjLmxlbmd0aDt2Kyspe2NvbnN0IHA9YCR7dX1fc18ke3Z9YCxiPVtdO2Nbdl0uZm9yRWFjaChFPT57Yi5wdXNoKChFLngtdGhpcy53b3JsZFBvc2l0aW9uWzBdKS90aGlzLndvcmxkU2NhbGluZ1swXSwoRS55LXRoaXMud29ybGRQb3NpdGlvblsxXSkvdGhpcy53b3JsZFNjYWxpbmdbMV0sRS56KX0pLGQucHVzaCh7d29ya0lkOnAsb3A6YixvcHQ6Zy5vcHQsdG9vbHNUeXBlOmcudG9vbHNUeXBlfSl9fX1lbHNlIG4ucHVzaChvKSxyLnB1c2goZy5uYW1lKTt0PVR0KHQsZy5yZWN0KX19KSxuLmZvckVhY2goZz0+Zy5yZW1vdmUoKSksdCYmKHQueC09S3QuU2FmZUJvcmRlclBhZGRpbmcsdC55LT1LdC5TYWZlQm9yZGVyUGFkZGluZyx0LncrPUt0LlNhZmVCb3JkZXJQYWRkaW5nKjIsdC5oKz1LdC5TYWZlQm9yZGVyUGFkZGluZyoyKSx7cmVjdDp0LHJlbW92ZUlkczpyLG5ld1dvcmtEYXRhczpkfX1jb25zdW1lQWxsKGUpe3JldHVybiB0aGlzLmNvbnN1bWUoZSl9Y2xlYXJUbXBQb2ludHMoKXt0aGlzLnRtcFBvaW50cy5sZW5ndGg9MCx0aGlzLnN5bmNUaW1lc3RhbXA9MH19T2JqZWN0LmRlZmluZVByb3BlcnR5KEt0LCJTYWZlQm9yZGVyUGFkZGluZyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOjEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KEt0LCJlcmFzZXJTaXplcyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOk9iamVjdC5mcmVlemUoW09iamVjdC5mcmVlemUoe3dpZHRoOjE4LGhlaWdodDoyNn0pLE9iamVjdC5mcmVlemUoe3dpZHRoOjI2LGhlaWdodDozNH0pLE9iamVjdC5mcmVlemUoe3dpZHRoOjM0LGhlaWdodDo1MH0pXSl9KTtmdW5jdGlvbiBwbihoLGUsdCl7cmV0dXJuIiMiKygoaDw8MTYpKyhlPDw4KSt0KS50b1N0cmluZygxNikucGFkU3RhcnQoNiwiMCIpfWZ1bmN0aW9uIHhuKGgpe2NvbnN0IGU9aC5zcGxpdCgiLCIpLHQ9cGFyc2VJbnQoZVswXS5zcGxpdCgiKCIpWzFdKSxyPXBhcnNlSW50KGVbMV0pLG49cGFyc2VJbnQoZVsyXSksZD1wYXJzZUludChlWzNdLnNwbGl0KCIpIilbMF0pO3JldHVybltwbih0LHIsbiksZF19Y29uc3QgTW49IisrIixFbj0ic2VsZWN0b3IiO3ZhciBPbj10eXBlb2YgcGU9PSJvYmplY3QiJiZwZSYmcGUuT2JqZWN0PT09T2JqZWN0JiZwZSxmcj1PbixUbj1mcixQbj10eXBlb2Ygc2VsZj09Im9iamVjdCImJnNlbGYmJnNlbGYuT2JqZWN0PT09T2JqZWN0JiZzZWxmLEFuPVRufHxQbnx8RnVuY3Rpb24oInJldHVybiB0aGlzIikoKSxKdD1BbixTbj1KdCxibj1Tbi5TeW1ib2wsV2U9Ym4sY3I9V2UsdXI9T2JqZWN0LnByb3RvdHlwZSxDbj11ci5oYXNPd25Qcm9wZXJ0eSxSbj11ci50b1N0cmluZyxmZT1jcj9jci50b1N0cmluZ1RhZzp2b2lkIDA7ZnVuY3Rpb24gTG4oaCl7dmFyIGU9Q24uY2FsbChoLGZlKSx0PWhbZmVdO3RyeXtoW2ZlXT12b2lkIDA7dmFyIHI9ITB9Y2F0Y2h7fXZhciBuPVJuLmNhbGwoaCk7cmV0dXJuIHImJihlP2hbZmVdPXQ6ZGVsZXRlIGhbZmVdKSxufXZhciBEbj1MbixJbj1PYmplY3QucHJvdG90eXBlLE5uPUluLnRvU3RyaW5nO2Z1bmN0aW9uIEJuKGgpe3JldHVybiBObi5jYWxsKGgpfXZhciBqbj1Cbixocj1XZSxXbj1EbixGbj1qbixVbj0iW29iamVjdCBOdWxsXSIsJG49IltvYmplY3QgVW5kZWZpbmVkXSIsZHI9aHI/aHIudG9TdHJpbmdUYWc6dm9pZCAwO2Z1bmN0aW9uIHpuKGgpe3JldHVybiBoPT1udWxsP2g9PT12b2lkIDA/JG46VW46ZHImJmRyIGluIE9iamVjdChoKT9XbihoKTpGbihoKX12YXIgY2U9em47ZnVuY3Rpb24gd24oaCl7cmV0dXJuIGghPW51bGwmJnR5cGVvZiBoPT0ib2JqZWN0In12YXIgbmU9d24sR249Y2UsS249bmUsSG49IltvYmplY3QgTnVtYmVyXSI7ZnVuY3Rpb24gVm4oaCl7cmV0dXJuIHR5cGVvZiBoPT0ibnVtYmVyInx8S24oaCkmJkduKGgpPT1Ibn12YXIgWW49Vm4sWG49TmUoWW4pO2NsYXNzIHZ0IGV4dGVuZHMgZ2V7dXBkYXRhT3B0U2VydmljZSgpe31jb25zdHJ1Y3RvcihlLHQscil7c3VwZXIodCxyKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidG1wUG9pbnRzIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6W119KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidG9vbHNUeXBlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6QXQuU2VsZWN0b3J9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywid29ya09wdGlvbnMiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywic3luY1RpbWVzdGFtcCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJjdXJOb2RlTWFwIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6bmV3IE1hcH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzZWxlY3RJZHMiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywib2xkUmVjdCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJub2RlQ29sb3IiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywibm9kZU9wYWN0aXkiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywib2xkU2VsZWN0UmVjdCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLHRoaXMud29ya09wdGlvbnM9ZSx0aGlzLnN5bmNUaW1lc3RhbXA9MH1jb21wdXROb2RlTWFwKGUpe3RoaXMuY3VyTm9kZU1hcC5jbGVhcigpLGUuZm9yRWFjaCh0PT57dmFyIG47Y29uc3Qgcj10aGlzLmZ1bGxMYXllci5nZXRFbGVtZW50c0J5TmFtZSh0Lm5hbWUpWzBdfHwoKG49dGhpcy5kcmF3TGF5ZXIpPT1udWxsP3ZvaWQgMDpuLmdldEVsZW1lbnRzQnlOYW1lKHQubmFtZSlbMF0pO2lmKHIpe2NvbnN0IGQ9ci53b3JsZFBvc2l0aW9uO2xldCBnPXIuZ2V0QXR0cmlidXRlKCJzdHJva2VDb2xvciIpO2NvbnN0IHU9ci5jbGFzc05hbWUuc3BsaXQoIiwiKTtyLnRhZ05hbWU9PT0iR1JPVVAiJiYoTnVtYmVyKHVbMl0pPT09RHQuU3Ryb2tlP2c9ci5nZXRBdHRyaWJ1dGUoImJnY29sb3IiKTpnPXIuY2hpbGRyZW5bMF0uZ2V0QXR0cmlidXRlKCJzdHJva2VDb2xvciIpKSx0aGlzLmN1ck5vZGVNYXAuc2V0KHQubmFtZSx7bmFtZTp0Lm5hbWUscmVjdDp0LnJlY3QsY29sb3I6eG4oZylbMF0scG9zOmQscm90YXRlOnIuZ2V0QXR0cmlidXRlKCJyb3RhdGUiKXx8MCxzY2FsZTpyLmdldEF0dHJpYnV0ZSgic2NhbGUiKXx8WzEsMV0sb3BhY3RpeTpyLmdldEF0dHJpYnV0ZSgib3BhY2l0eSIpfHwxfSl9fSl9Y29tcHV0U2VsZWN0b3IoKXtsZXQgZTtjb25zdCB0PVtdLHI9bmV3IE1hcCxuPW5ldyBTZXQsZD1uZXcgU2V0LGc9bmV3IE1hcDtpZih0aGlzLnRtcFBvaW50cy5sZW5ndGgmJnRoaXMuY3VyTm9kZU1hcC5zaXplKXtjb25zdCB1PVp0KHRoaXMudG1wUG9pbnRzKTt0aGlzLmN1ck5vZGVNYXAuZm9yRWFjaCgobyxmKT0+e2NvbnN0IHg9e3g6by5yZWN0LngseTpvLnJlY3QueSx3Om8ucmVjdC53LGg6by5yZWN0Lmh9LGM9e3g6dS54LHk6dS55LHc6dS53LGg6dS5ofTttZShjLHgpJiYodC5wdXNoKGYpLGU9VHQoZSx4KSxyLnNldChmLHgpLG4uYWRkKG8uY29sb3IpLGcuc2V0KGYsWy4uLm8ucG9zLG8ucm90YXRlXSksZC5hZGQoby5vcGFjdGl5KSl9KX1yZXR1cm57c2VsZWN0SWRzOnQsaW50ZXJzZWN0UmVjdDplLHN1YlJlY3RzOnIsbm9kZUNvbG9yczpuLHN1YlBvczpnLG9wYWN0aXlzOmR9fXVwZGF0ZVRlbXBQb2ludHMoZSl7Y29uc3QgdD10aGlzLnRtcFBvaW50cy5sZW5ndGgscj1lLmxlbmd0aDtpZihyPjEpe2NvbnN0IG49bmV3IEx0KGVbci0yXSp0aGlzLmZ1bGxMYXllci53b3JsZFNjYWxpbmdbMF0rdGhpcy5mdWxsTGF5ZXIud29ybGRQb3NpdGlvblswXSxlW3ItMV0qdGhpcy5mdWxsTGF5ZXIud29ybGRTY2FsaW5nWzBdK3RoaXMuZnVsbExheWVyLndvcmxkUG9zaXRpb25bMV0pO3Q9PT0yP3RoaXMudG1wUG9pbnRzLnNwbGljZSgxLDEsbik6dGhpcy50bXBQb2ludHMucHVzaChuKX19ZHJhdyhlKXt2YXIgZCxnLHU7Y29uc3R7aW50ZXJzZWN0UmVjdDp0LHN1YlJlY3RzOnIsc3ViUG9zOm59PWU7KHU9KGc9KGQ9dGhpcy5kcmF3TGF5ZXIpPT1udWxsP3ZvaWQgMDpkLnBhcmVudCk9PW51bGw/dm9pZCAwOmcuZ2V0RWxlbWVudEJ5SWQodnQuc2VsZWN0b3JJZCkpPT1udWxsfHx1LnJlbW92ZSgpLHQmJnRoaXMuZHJhd0xheWVyJiZ0aGlzLmRyYXdTZWxlY3Rvcih7ZHJhd1JlY3Q6dCxzdWJSZWN0czpyLHN1YlBvczpuLHNlbGVjdG9ySWQ6dnQuc2VsZWN0b3JJZCxsYXllcjp0aGlzLmRyYXdMYXllcn0pfWNvbnN1bWUoZSl7Y29uc3R7b3A6dCx3b3JrU3RhdGU6cn09ZS5kYXRhO2lmKHI9PT1HdC5TdGFydCYmZS5ub2RlTWFwcyYmKHRoaXMuY29tcHV0Tm9kZU1hcChlLm5vZGVNYXBzKSx0aGlzLm9sZFJlY3Q9dGhpcy5iYWNrVG9GdWxsTGF5ZXIoZS5ub2RlTWFwcykpLCEodCE9bnVsbCYmdC5sZW5ndGgpfHwhdGhpcy5jdXJOb2RlTWFwLnNpemUpcmV0dXJue3R5cGU6cHQuTm9uZX07dGhpcy51cGRhdGVUZW1wUG9pbnRzKHQpO2NvbnN0IG49dGhpcy5jb21wdXRTZWxlY3RvcigpO2lmKHRoaXMuc2VsZWN0SWRzJiZmbih0aGlzLnNlbGVjdElkcyxuLnNlbGVjdElkcykpcmV0dXJue3R5cGU6cHQuTm9uZX07dGhpcy5zZWxlY3RJZHM9bi5zZWxlY3RJZHM7Y29uc3QgZD10aGlzLmRyYXdMYXllciYmdGhpcy5nZXRTZWxlY3RvclJlY3QodGhpcy5kcmF3TGF5ZXIsdnQuc2VsZWN0b3JJZCwhMCksZz1uLmludGVyc2VjdFJlY3QmJnt4Om4uaW50ZXJzZWN0UmVjdC54LXZ0LlNlbGVjdEJvcmRlclBhZGRpbmcseTpuLmludGVyc2VjdFJlY3QueS12dC5TZWxlY3RCb3JkZXJQYWRkaW5nLHc6bi5pbnRlcnNlY3RSZWN0LncrdnQuU2VsZWN0Qm9yZGVyUGFkZGluZyoyLGg6bi5pbnRlcnNlY3RSZWN0LmgrdnQuU2VsZWN0Qm9yZGVyUGFkZGluZyoyfXx8dm9pZCAwO3JldHVybiB0aGlzLm9sZFJlY3Q9VHQoZCxnKSx0aGlzLmRyYXcobiksdGhpcy5ub2RlQ29sb3I9bi5ub2RlQ29sb3JzLnNpemU9PT0xP24ubm9kZUNvbG9ycy52YWx1ZXMoKS5uZXh0KCkudmFsdWU6dm9pZCAwLHRoaXMubm9kZU9wYWN0aXk9bi5vcGFjdGl5cy5zaXplPT09MT9uLm9wYWN0aXlzLnZhbHVlcygpLm5leHQoKS52YWx1ZToxLHRoaXMub2xkU2VsZWN0UmVjdD1nLHt0eXBlOnB0LlNlbGVjdCxkYXRhVHlwZTpTdC5Mb2NhbCxyZWN0OnRoaXMub2xkUmVjdCxzZWxlY3RJZHM6bi5zZWxlY3RJZHMsb3B0OnRoaXMud29ya09wdGlvbnMscGFkZGluZzp2dC5TZWxlY3RCb3JkZXJQYWRkaW5nLHNlbGVjdFJlY3Q6Zyxub2RlQ29sb3I6dGhpcy5ub2RlQ29sb3Isbm9kZU9wYWN0aXk6dGhpcy5ub2RlT3BhY3RpeSx3aWxsU3luY1NlcnZpY2U6ITB9fWNvbnN1bWVBbGwoKXt2YXIgZTtyZXR1cm4oZT10aGlzLnNlbGVjdElkcykhPW51bGwmJmUubGVuZ3RoJiZ0aGlzLnNlYWxUb0RyYXdMYXllcih0aGlzLnNlbGVjdElkcyksdGhpcy5vbGRTZWxlY3RSZWN0P3t0eXBlOnB0LlNlbGVjdCxkYXRhVHlwZTpTdC5Mb2NhbCxyZWN0OnRoaXMub2xkUmVjdCxzZWxlY3RJZHM6dGhpcy5zZWxlY3RJZHMsb3B0OnRoaXMud29ya09wdGlvbnMscGFkZGluZzp2dC5TZWxlY3RCb3JkZXJQYWRkaW5nLHNlbGVjdFJlY3Q6dGhpcy5vbGRTZWxlY3RSZWN0LG5vZGVDb2xvcjp0aGlzLm5vZGVDb2xvcixub2RlT3BhY3RpeTp0aGlzLm5vZGVPcGFjdGl5LHdpbGxTeW5jU2VydmljZTohMX06e3R5cGU6cHQuTm9uZX19Y29uc3VtZVNlcnZpY2UoKXt9Y29tYmluZUNvbnN1bWUoKXt9Y2xlYXJUbXBQb2ludHMoKXt0aGlzLnRtcFBvaW50cy5sZW5ndGg9MH1jbGVhclNlbGVjdERhdGEoKXt0aGlzLnNlbGVjdElkcz12b2lkIDAsdGhpcy5vbGRSZWN0PXZvaWQgMCx0aGlzLm9sZFNlbGVjdFJlY3Q9dm9pZCAwfWJhY2tUb0Z1bGxMYXllcihlPW5ldyBNYXAsdCl7dmFyIGcsdTtsZXQgcjtjb25zdCBuPVtdLGQ9W107Zm9yKGNvbnN0IG8gb2YoKGc9dGhpcy5kcmF3TGF5ZXIpPT1udWxsP3ZvaWQgMDpnLmNoaWxkcmVuKXx8W10paWYoISh0IT1udWxsJiZ0Lmxlbmd0aCYmIXQuaW5jbHVkZXMoby5pZCkpJiZvLmlkIT09dnQuc2VsZWN0b3JJZCl7Y29uc3QgZj1vLmNsb25lTm9kZSghMCk7aWYoZi50YWdOYW1lPT09IkdST1VQIil7Y29uc3QgYz1vLmNsYXNzTmFtZS5zcGxpdCgiLCIpO2MubGVuZ3RoPT09MyYmTnVtYmVyKGNbMl0pPT09RHQuU3Ryb2tlJiZmLnNlYWwoKX10aGlzLmZ1bGxMYXllci5nZXRFbGVtZW50c0J5TmFtZShvLm5hbWUpLmxlbmd0aHx8bi5wdXNoKGYpLGQucHVzaChvKTtjb25zdCB4PSgodT1lLmdldChvLm5hbWUpKT09bnVsbD92b2lkIDA6dS5yZWN0KXx8WHQoby5uYW1lLHRoaXMuZHJhd0xheWVyKTt4JiYocj1UdChyLHgpKX1yZXR1cm4gZC5mb3JFYWNoKG89Pm8ucmVtb3ZlKCkpLG4ubGVuZ3RoJiZ0aGlzLmZ1bGxMYXllci5hcHBlbmQoLi4ubiksciYmKHIueC09dnQuU2VsZWN0Qm9yZGVyUGFkZGluZyxyLnktPXZ0LlNlbGVjdEJvcmRlclBhZGRpbmcsci53Kz12dC5TZWxlY3RCb3JkZXJQYWRkaW5nKjIsci5oKz12dC5TZWxlY3RCb3JkZXJQYWRkaW5nKjIpLHJ9c2VhbFRvRHJhd0xheWVyKGUpe3ZhciBuO2NvbnN0IHQ9W10scj1bXTtlLmZvckVhY2goZD0+e3RoaXMuZnVsbExheWVyLmdldEVsZW1lbnRzQnlOYW1lKGQudG9TdHJpbmcoKSkuZm9yRWFjaChnPT57dmFyIG87Y29uc3QgdT1nLmNsb25lTm9kZSghMCk7aWYodS50YWdOYW1lPT09IkdST1VQIil7Y29uc3QgZj1nLmNsYXNzTmFtZS5zcGxpdCgiLCIpO2YubGVuZ3RoPT09MyYmTnVtYmVyKGZbMl0pPT09RHQuU3Ryb2tlJiZ1LnNlYWwoKX0obz10aGlzLmRyYXdMYXllcikhPW51bGwmJm8uZ2V0RWxlbWVudHNCeU5hbWUoZy5uYW1lKS5sZW5ndGh8fHQucHVzaCh1KSxyLnB1c2goZyl9KX0pLHIuZm9yRWFjaChkPT5kLnJlbW92ZSgpKSx0JiYoKG49dGhpcy5kcmF3TGF5ZXIpPT1udWxsfHxuLmFwcGVuZCguLi50KSl9dXBkYXRlU2VsZWN0b3JTaXplKGUsdCxyKXtjb25zdCBuPW5ldyBNYXAsZD1lLmdldEF0dHJpYnV0ZSgicG9zIiksZz1lLmNsYXNzTmFtZS5zcGxpdCgiLCIpLHU9dC12dC5TZWxlY3RCb3JkZXJQYWRkaW5nKjIsbz1yLXZ0LlNlbGVjdEJvcmRlclBhZGRpbmcqMixmPWcubGVuZ3RoPT09MiYmW3UvTnVtYmVyKGdbMF0pLG8vTnVtYmVyKGdbMV0pXXx8WzEsMV07cmV0dXJuIGUuc2V0QXR0cmlidXRlKCJzaXplIixbdSxvXSksZS5jaGlsZHJlbi5mb3JFYWNoKHg9PntpZih4LmlkPT09dnQuc2VsZWN0b3JCb3JkZXJJZCl4LnNldEF0dHJpYnV0ZSgicG9zIixbdS8yLG8vMl0pLHguc2V0QXR0cmlidXRlKCJ3aWR0aCIsdSkseC5zZXRBdHRyaWJ1dGUoImhlaWdodCIsbyk7ZWxzZSBpZihmKXtjb25zdCBjPXguY2xhc3NOYW1lLnNwbGl0KCIsIiksdj1bTnVtYmVyKGNbMF0pKmZbMF0sTnVtYmVyKGNbMV0pKmZbMV1dLHA9eC5nZXRBdHRyaWJ1dGUoIndpZHRoIiksYj14LmdldEF0dHJpYnV0ZSgiaGVpZ2h0IiksRT1OdW1iZXIoY1syXSkqZlswXSx5PU51bWJlcihjWzNdKSpmWzFdO3guc2V0QXR0cmlidXRlKCJwb3MiLHYpLHguc2V0QXR0cmlidXRlKCJ3aWR0aCIsRSkseC5zZXRBdHRyaWJ1dGUoImhlaWdodCIseSk7Y29uc3QgTT14LmlkLnNwbGl0KCJzZWxlY3Rvci0iKVsxXTtpZihNKXtjb25zdCBpPVt2WzBdK2RbMF0sdlsxXStkWzFdXSxhPVtFL3AseS9iXTtuLnNldChNLFtpWzBdLGlbMV0sYVswXSxhWzFdXSl9fX0pLG59dXBkYXRlU2VsZWN0b3JSZWN0KGUsdCl7Y29uc3R7dzpyLGg6bix4OmQseTpnfT10LHU9ci12dC5TZWxlY3RCb3JkZXJQYWRkaW5nKjIsbz1uLXZ0LlNlbGVjdEJvcmRlclBhZGRpbmcqMixmPWQrdnQuU2VsZWN0Qm9yZGVyUGFkZGluZyx4PWcrdnQuU2VsZWN0Qm9yZGVyUGFkZGluZztlLnNldEF0dHJpYnV0ZSgic2l6ZSIsW3Isbl0pLGUuc2V0QXR0cmlidXRlKCJwb3MiLFtmLHhdKSxlLnNldEF0dHJpYnV0ZSgiY2xhc3NOYW1lIixgJHt0Lnd9LCR7dC5ofWApLGUuY2hpbGRyZW4uZm9yRWFjaChjPT57aWYoYy5zZXRBdHRyaWJ1dGUoInBvcyIsW3UvMixvLzJdKSxjLnNldEF0dHJpYnV0ZSgid2lkdGgiLHUpLGMuc2V0QXR0cmlidXRlKCJoZWlnaHQiLG8pLGMuaWQ9PT12dC5zZWxlY3RvckJvcmRlcklkKWMuc2V0QXR0cmlidXRlKCJjbGFzc05hbWUiLGAke3Qudy8yfSwke3QuaC8yfSwke3Qud30sJHt0Lmh9YCk7ZWxzZXtjb25zdCB2PWMuY2xhc3NOYW1lLnNwbGl0KCIsIikscD12JiZOdW1iZXIodls0XSl8fDA7Yy5zZXRBdHRyaWJ1dGUoImNsYXNzTmFtZSIsYCR7dS8yfSwke28vMn0sJHt0Lnd9LCR7dC5ofSwke3B9YCl9fSl9Z2V0U2VsZWN0b3JSZWN0KGUsdCxyKXt2YXIgbztsZXQgbjtjb25zdCBkPShvPWUucGFyZW50KT09bnVsbD92b2lkIDA6by5nZXRFbGVtZW50QnlJZCh0KSxnPWQ9PW51bGw/dm9pZCAwOmQuZ2V0RWxlbWVudEJ5SWQodnQuc2VsZWN0b3JCb3JkZXJJZCksdT1nPT1udWxsP3ZvaWQgMDpnLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO3JldHVybiB1JiYobj1UdChuLHt4Ok1hdGguZmxvb3IodS54KSx5Ok1hdGguZmxvb3IodS55KSx3Ok1hdGgucm91bmQodS53aWR0aCksaDpNYXRoLnJvdW5kKHUuaGVpZ2h0KX0pKSxuJiZyP3t4Om4ueC12dC5TZWxlY3RCb3JkZXJQYWRkaW5nLHk6bi55LXZ0LlNlbGVjdEJvcmRlclBhZGRpbmcsdzpuLncrdnQuU2VsZWN0Qm9yZGVyUGFkZGluZyoyLGg6bi5oK3Z0LlNlbGVjdEJvcmRlclBhZGRpbmcqMn06bn11cGRhdGVTZWxlY3RvcihlKXt2YXIgZix4LGM7Y29uc3R7dXBkYXRlU2VsZWN0b3JPcHQ6dCxzZWxlY3RJZHM6cixzZWxlY3RTdG9yZTpufT1lO2xldCBkO2NvbnN0IGc9bmV3IE1hcDtsZXQgdTtjb25zdCBvPSh4PShmPXRoaXMuZHJhd0xheWVyKT09bnVsbD92b2lkIDA6Zi5wYXJlbnQpPT1udWxsP3ZvaWQgMDp4LmdldEVsZW1lbnRCeUlkKHZ0LnNlbGVjdG9ySWQpO2lmKG8pe2xldCB2O2lmKHQucG9zKXtjb25zdCBwPVt0LnBvc1swXSp0aGlzLmZ1bGxMYXllci53b3JsZFNjYWxpbmdbMF0rdGhpcy5mdWxsTGF5ZXIud29ybGRQb3NpdGlvblswXSx0LnBvc1sxXSp0aGlzLmZ1bGxMYXllci53b3JsZFNjYWxpbmdbMV0rdGhpcy5mdWxsTGF5ZXIud29ybGRQb3NpdGlvblsxXV0sYj1vLmdldEF0dHJpYnV0ZSgicG9zIik7dj1bcFswXS1iWzBdLHBbMV0tYlsxXV0sby5zZXRBdHRyaWJ1dGUoInBvcyIscCl9aWYodC5zZWxlY3RvckNvbG9yJiYoKGM9by5nZXRFbGVtZW50QnlJZCh2dC5zZWxlY3RvckJvcmRlcklkKSk9PW51bGx8fGMuc2V0QXR0cmlidXRlKCJzdHJva2VDb2xvciIsdC5zZWxlY3RvckNvbG9yKSksdC5zaXplJiYodT10aGlzLnVwZGF0ZVNlbGVjdG9yU2l6ZShvLHQuc2l6ZS53aWR0aCx0LnNpemUuaGVpZ2h0KSksdC5hbmdsZSlyPT1udWxsfHxyLmZvckVhY2gocD0+e3ZhciBiOyhiPXRoaXMuZHJhd0xheWVyKT09bnVsbHx8Yi5nZXRFbGVtZW50c0J5TmFtZShwKS5mb3JFYWNoKEU9PntpZihFKXtjb25zdCB5PXt1c2VBbmltYXRpb246ITF9O3QuYW5nbGUmJih5LmFuZ2xlPXQuYW5nbGUseS5vcmlnaW5Qb3M9RS5jbGFzc05hbWUuc3BsaXQoIiwiKS5tYXAoaT0+TnVtYmVyKGkpKSxFLnNldEF0dHJpYnV0ZSgicm90YXRlIix5LmFuZ2xlKSksZy5zZXQoRS5uYW1lLHkpO2NvbnN0IE09WHQoRS5uYW1lLHRoaXMuZHJhd0xheWVyKTtkPVR0KGQsTSl9fSl9LHRoaXMpO2Vsc2V7cj09bnVsbHx8ci5mb3JFYWNoKEU9Pnt2YXIgeTsoeT10aGlzLmRyYXdMYXllcik9PW51bGx8fHkuZ2V0RWxlbWVudHNCeU5hbWUoRSkuZm9yRWFjaChNPT57dmFyIGksYTtpZihNKXtjb25zdCBzPXt1c2VBbmltYXRpb246ITF9O2lmKHQucG9zJiZ2KXtjb25zdCBPPU0uZ2V0QXR0cmlidXRlKCJwb3MiKTtzLnBvcz1bdlswXS90aGlzLmZ1bGxMYXllci53b3JsZFNjYWxpbmdbMF0rT1swXSx2WzFdL3RoaXMuZnVsbExheWVyLndvcmxkU2NhbGluZ1swXStPWzFdXSxzLm9yaWdpblBvcz1NLmNsYXNzTmFtZS5zcGxpdCgiLCIpLm1hcChBPT5OdW1iZXIoQSkpLE0uc2V0QXR0cmlidXRlKCJwb3MiLHMucG9zKX1pZih0LnpJbmRleExheWVyJiYobiE9bnVsbCYmbi5oYXMoRSkpKXtjb25zdCBPPShhPShpPW4uZ2V0KEUpKT09bnVsbD92b2lkIDA6aS51cGRhdGVOb2RlT3B0KT09bnVsbD92b2lkIDA6YS56SW5kZXg7WG4oTykmJihzLnpJbmRleD1PLE0uc2V0QXR0cmlidXRlKCJ6SW5kZXgiLHMuekluZGV4KSl9aWYodC56SW5kZXgmJihzLnpJbmRleD10LnpJbmRleCxNLnNldEF0dHJpYnV0ZSgiekluZGV4IixzLnpJbmRleCkpLHQuY29sb3Ipe3MuY29sb3I9dC5jb2xvcjtjb25zdCBPPU0uY2xhc3NOYW1lLnNwbGl0KCIsIik7TS50YWdOYW1lPT09IkdST1VQIj9OdW1iZXIoT1syXSk9PT1EdC5TdHJva2U/TS5zZXRBdHRyaWJ1dGUoImJnY29sb3IiLHMuY29sb3IpOk0uY2hpbGRyZW4uZm9yRWFjaChBPT57QS5zZXRBdHRyaWJ1dGUoInN0cm9rZUNvbG9yIixzLmNvbG9yKX0pOk0udGFnTmFtZT09PSJQQVRIIiYmKE0uc2V0QXR0cmlidXRlKCJzdHJva2VDb2xvciIscy5jb2xvciksTS5nZXRBdHRyaWJ1dGUoImZpbGxDb2xvciIpJiZNLnNldEF0dHJpYnV0ZSgiZmlsbENvbG9yIixzLmNvbG9yKSl9dC5vcGFjaXR5JiYocy5vcGFjaXR5PXQub3BhY2l0eSxNLnNldEF0dHJpYnV0ZSgib3BhY2l0eSIscy5vcGFjaXR5KSk7Y29uc3QgbD11PT1udWxsP3ZvaWQgMDp1LmdldChNLm5hbWUpO2lmKGwpe2NvbnN0IE89TS5nZXRBdHRyaWJ1dGUoInNjYWxlIiksQT1bbFsyXSpPWzBdLGxbM10qT1sxXV07cy5vcmlnaW5Qb3M9TS5jbGFzc05hbWUuc3BsaXQoIiwiKS5tYXAoUj0+TnVtYmVyKFIpKSxzLnBvcz1bKGxbMF0tdGhpcy5mdWxsTGF5ZXIud29ybGRQb3NpdGlvblswXSkvdGhpcy5mdWxsTGF5ZXIud29ybGRTY2FsaW5nWzBdLChsWzFdLXRoaXMuZnVsbExheWVyLndvcmxkUG9zaXRpb25bMV0pL3RoaXMuZnVsbExheWVyLndvcmxkU2NhbGluZ1sxXV0scy5zY2FsZT1BLE0uc2V0QXR0cmlidXRlKCJwb3MiLHMucG9zKSxNLnNldEF0dHJpYnV0ZSgic2NhbGUiLHMuc2NhbGUpfWcuc2V0KE0ubmFtZSxzKX19KX0sdGhpcyk7Y29uc3QgcD1vLmdldEVsZW1lbnRCeUlkKHZ0LnNlbGVjdG9yQm9yZGVySWQpLGI9cD09bnVsbD92b2lkIDA6cC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtiJiYoZD1UdChkLHt4Ok1hdGguZmxvb3IoYi54KSx5Ok1hdGguZmxvb3IoYi55KSx3Ok1hdGgucm91bmQoYi53aWR0aCksaDpNYXRoLnJvdW5kKGIuaGVpZ2h0KX0pKX19aWYoZClyZXR1cm4gZC54LT12dC5TZWxlY3RCb3JkZXJQYWRkaW5nLGQueS09dnQuU2VsZWN0Qm9yZGVyUGFkZGluZyxkLncrPXZ0LlNlbGVjdEJvcmRlclBhZGRpbmcqMixkLmgrPXZ0LlNlbGVjdEJvcmRlclBhZGRpbmcqMix0LmFuZ2xlJiZ0aGlzLnVwZGF0ZVNlbGVjdG9yUmVjdChvLGQpLHRoaXMub2xkUmVjdD1UdCh0aGlzLm9sZFJlY3QsZCksdGhpcy5vbGRTZWxlY3RSZWN0PWQse3R5cGU6cHQuVXBkYXRlTm9kZSxkYXRhVHlwZTpTdC5Mb2NhbCxyZWN0OmQsdXBkYXRlTm9kZU9wdHM6Z319Ymx1clNlbGVjdG9yKGUpe2NvbnN0IHQ9dGhpcy5iYWNrVG9GdWxsTGF5ZXIoZSk7cmV0dXJue3R5cGU6cHQuU2VsZWN0LGRhdGFUeXBlOlN0LkxvY2FsLHJlY3Q6dCxzZWxlY3RJZHM6W10sd2lsbFN5bmNTZXJ2aWNlOiEwfX1nZXRSaWdodFNlcnZpY2VJZChlKXtyZXR1cm4gZS5yZXBsYWNlKCIrKyIsIi0iKX1kcmF3U2VsZWN0b3IoZSl7Y29uc3R7ZHJhd1JlY3Q6dCxzdWJSZWN0czpyLHN1YlBvczpuLHNlbGVjdG9ySWQ6ZCxsYXllcjpnfT1lLHU9bmV3IERlKHtwb3M6W3QueCx0LnldLGFuY2hvcjpbMCwwXSxzaXplOlt0LncsdC5oXSxjbGFzc05hbWU6YCR7dC53fSwke3QuaH1gLGlkOmQsbmFtZTp2dC5zZWxlY3RvcklkLHpJbmRleDoxZTN9KSxvPVtdLGY9bmV3IHNyKHtub3JtYWxpemU6ITAscG9zOlt0LncvMix0LmgvMl0sbGluZVdpZHRoOjEsc3Ryb2tlQ29sb3I6dGhpcy53b3JrT3B0aW9ucy5jb2xvcix3aWR0aDp0LncsaGVpZ2h0OnQuaCxjbGFzc05hbWU6YCR7dC53LzJ9LCR7dC5oLzJ9LCR7dC53fSwke3QuaH1gLGlkOnZ0LnNlbGVjdG9yQm9yZGVySWR9KTtvLnB1c2goZiksci5mb3JFYWNoKCh4LGMpPT57Y29uc3Qgdj1uPT1udWxsP3ZvaWQgMDpuLmdldChjKTtpZih2KXtjb25zdCBwPVt2WzBdLXQueCx2WzFdLXQueV0sYj1gJHtwWzBdfSwke3BbMV19LCR7eC53fSwke3guaH0sJHt2WzJdfWAsRT1uZXcgc3Ioe25vcm1hbGl6ZTohMCxwb3M6cCxsaW5lV2lkdGg6MSxzdHJva2VDb2xvcjpyLnNpemU+MT90aGlzLndvcmtPcHRpb25zLmNvbG9yOnZvaWQgMCx3aWR0aDp4LncsaGVpZ2h0OnguaCxjbGFzc05hbWU6YixpZDpgc2VsZWN0b3ItJHtjfWAsbmFtZTpgc2VsZWN0b3ItJHtjfWB9KTtvLnB1c2goRSl9fSksbyYmdS5hcHBlbmQoLi4ubyksKGc9PW51bGw/dm9pZCAwOmcucGFyZW50KS5hcHBlbmRDaGlsZCh1KX1zZWxlY3RTZXJ2aWNlTm9kZShlLHQscil7dmFyIHg7Y29uc3R7c2VsZWN0SWRzOm59PXQsZD10aGlzLmdldFJpZ2h0U2VydmljZUlkKGUpLGc9dGhpcy5nZXRTZWxlY3RvclJlY3QodGhpcy5mdWxsTGF5ZXIsZCwhMCk7KHg9dGhpcy5mdWxsTGF5ZXIucGFyZW50LmdldEVsZW1lbnRCeUlkKGQpKT09bnVsbHx8eC5yZW1vdmUoKTtsZXQgdTtjb25zdCBvPW5ldyBNYXAsZj1uZXcgTWFwO3JldHVybiBuPT1udWxsfHxuLmZvckVhY2goYz0+e3ZhciBiO2NvbnN0IHY9ci5nZXQoYykscD10aGlzLmZ1bGxMYXllci5nZXRFbGVtZW50c0J5TmFtZShjKVswXTtpZih2JiZwKXt1PVR0KHUsdi5yZWN0KSxvLnNldChjLHYucmVjdCk7Y29uc3QgRT1wLndvcmxkUG9zaXRpb24seT0oKGI9di5vcHQpPT1udWxsP3ZvaWQgMDpiLnJvdGF0ZSl8fHAuZ2V0QXR0cmlidXRlKCJyb3RhdGUiKXx8MDtmLnNldChjLFsuLi5FLHldKX19KSx1JiZ0aGlzLmZ1bGxMYXllciYmdGhpcy5kcmF3U2VsZWN0b3Ioe2RyYXdSZWN0OnUsc3ViUmVjdHM6byxzdWJQb3M6ZixzZWxlY3RvcklkOmQsbGF5ZXI6dGhpcy5mdWxsTGF5ZXJ9KSx1PVR0KHUsZyksdSYmKHUueC09dnQuU2VsZWN0Qm9yZGVyUGFkZGluZyx1LnktPXZ0LlNlbGVjdEJvcmRlclBhZGRpbmcsdS53Kz12dC5TZWxlY3RCb3JkZXJQYWRkaW5nKjIsdS5oKz12dC5TZWxlY3RCb3JkZXJQYWRkaW5nKjIpLHV9cmVtb3ZlU2VydmljZSgpe3Rocm93IG5ldyBFcnJvcigiTWV0aG9kIG5vdCBpbXBsZW1lbnRlZC4iKX1nZXRTZWxlY3RvcihlKXt2YXIgZDtsZXQgdDtjb25zdCByPW5ldyBNYXAsbj1uZXcgTWFwO3JldHVybihkPXRoaXMuc2VsZWN0SWRzKT09bnVsbHx8ZC5mb3JFYWNoKGc9Pnt2YXIgZjtjb25zdCB1PWUuZ2V0KGcpLG89KGY9dGhpcy5kcmF3TGF5ZXIpPT1udWxsP3ZvaWQgMDpmLmdldEVsZW1lbnRzQnlOYW1lKGcpWzBdO2lmKHUmJm8pe2NvbnN0IHg9by53b3JsZFBvc2l0aW9uLGM9by5nZXRBdHRyaWJ1dGUoInJvdGF0ZSIpfHwwO3Q9VHQodCx1LnJlY3QpLHIuc2V0KGcsdS5yZWN0KSxuLnNldChnLFsuLi54LGNdKX19LHRoaXMpLHRoaXMub2xkUmVjdD1UdCh0LHRoaXMub2xkUmVjdCksdGhpcy5kcmF3KHtpbnRlcnNlY3RSZWN0OnQsc3ViUmVjdHM6cixzdWJQb3M6bn0pLHQmJih0LngtPXZ0LlNlbGVjdEJvcmRlclBhZGRpbmcsdC55LT12dC5TZWxlY3RCb3JkZXJQYWRkaW5nLHQudys9dnQuU2VsZWN0Qm9yZGVyUGFkZGluZyoyLHQuaCs9dnQuU2VsZWN0Qm9yZGVyUGFkZGluZyoyKSx0aGlzLm9sZFNlbGVjdFJlY3Q9dCx0fXVwZGF0ZVNlbGVjdElkcyhlLHQpe3ZhciB1LG87bGV0IHI7Y29uc3Qgbj0odT10aGlzLnNlbGVjdElkcyk9PW51bGw/dm9pZCAwOnUuZmlsdGVyKGY9PiFlLmluY2x1ZGVzKGYpKSxkPWUuZmlsdGVyKGY9Pnt2YXIgeDtyZXR1cm4hKCh4PXRoaXMuc2VsZWN0SWRzKSE9bnVsbCYmeC5pbmNsdWRlcyhmKSl9KTtpZihuIT1udWxsJiZuLmxlbmd0aCYmKHI9dGhpcy5iYWNrVG9GdWxsTGF5ZXIodCxuKSksZC5sZW5ndGgpe3RoaXMuc2VhbFRvRHJhd0xheWVyKGQpO2Zvcihjb25zdCBmIG9mIGQpe2NvbnN0IHg9KG89dC5nZXQoZikpPT1udWxsP3ZvaWQgMDpvLnJlY3Q7eCYmKHI9VHQocix4KSl9ciYmKHIueC09dnQuU2VsZWN0Qm9yZGVyUGFkZGluZyxyLnktPXZ0LlNlbGVjdEJvcmRlclBhZGRpbmcsci53Kz12dC5TZWxlY3RCb3JkZXJQYWRkaW5nKjIsci5oKz12dC5TZWxlY3RCb3JkZXJQYWRkaW5nKjIpfXRoaXMuc2VsZWN0SWRzPWU7Y29uc3QgZz10aGlzLmdldFNlbGVjdG9yKHQpO3JldHVybntiZ1JlY3Q6cixzZWxlY3RSZWN0Omd9fX1PYmplY3QuZGVmaW5lUHJvcGVydHkodnQsInNlbGVjdG9ySWQiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpFbn0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh2dCwic2VsZWN0b3JCb3JkZXJJZCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOiJzZWxlY3Rvci1ib3JkZXIifSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHZ0LCJTZWxlY3RCb3JkZXJQYWRkaW5nIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6Mn0pO2NsYXNzIGdyIGV4dGVuZHMgZ2V7dXBkYXRhT3B0U2VydmljZSgpe31jb25zdHJ1Y3RvcihlLHQpe3N1cGVyKHQpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzeW5jVGltZXN0YW1wIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInN5bmNJbmRleCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOjB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidG9vbHNUeXBlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6QXQuTGFzZXJQZW59KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidG1wUG9pbnRzIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6W119KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywid29ya09wdGlvbnMiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiY29uc3VtZUluZGV4Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6MH0pLHRoaXMud29ya09wdGlvbnM9ZSx0aGlzLnN5bmNUaW1lc3RhbXA9MH1jb21iaW5lQ29uc3VtZSgpe31zZXRXb3JrT3B0aW9ucyhlKXtzdXBlci5zZXRXb3JrT3B0aW9ucyhlKSx0aGlzLnN5bmNUaW1lc3RhbXA9RGF0ZS5ub3coKX1jb25zdW1lKGUpe2NvbnN0e2RhdGE6dCxpc0Z1bGxXb3JrOnJ9PWUse3dvcmtJZDpuLG9wOmR9PXQ7aWYoKGQ9PW51bGw/dm9pZCAwOmQubGVuZ3RoKT09PTApcmV0dXJue3R5cGU6cHQuTm9uZX07aWYodGhpcy51cGRhdGVUZW1wUG9pbnRzKGR8fFtdKSx0aGlzLmNvbnN1bWVJbmRleD50aGlzLnRtcFBvaW50cy5sZW5ndGgtNClyZXR1cm57dHlwZTpwdC5Ob25lfTtjb25zdHtjb2xvcjpnLHRoaWNrbmVzczp1LHN0cm9rZVR5cGU6byxvcGFjaXR5OmZ9PXRoaXMud29ya09wdGlvbnMseD1adCh0aGlzLnRtcFBvaW50cyx1KTtsZXQgYz0hMTtjb25zdCB2PXRoaXMuc3luY0luZGV4LHA9dGhpcy50bXBQb2ludHMuc2xpY2UodGhpcy5jb25zdW1lSW5kZXgpO3RoaXMuY29uc3VtZUluZGV4PXRoaXMudG1wUG9pbnRzLmxlbmd0aC0xLHRoaXMuc3luY1RpbWVzdGFtcD09PTAmJih0aGlzLnN5bmNUaW1lc3RhbXA9RGF0ZS5ub3coKSk7Y29uc3QgYj17bmFtZTpuPT1udWxsP3ZvaWQgMDpuLnRvU3RyaW5nKCksY2xhc3NOYW1lOiJMYXNlclBlbiIsb3BhY2l0eTpmfHwxLGxpbmVEYXNoOm89PT1EdC5Eb3R0ZWQ/WzEsdSoyXTpvPT09RHQuTG9uZ0RvdHRlZD9bdSx1KjJdOnZvaWQgMCxzdHJva2VDb2xvcjpnLGxpbmVDYXA6InJvdW5kIixsaW5lV2lkdGg6dSxhbmNob3I6Wy41LC41XX0sRT10aGlzLmdldFRhc2tQb2ludHMocCk7aWYoRS5sZW5ndGgpe2NvbnN0IE09RGF0ZS5ub3coKTtNLXRoaXMuc3luY1RpbWVzdGFtcD50aGlzLnN5bmNVbml0VGltZSYmKGM9ITAsdGhpcy5zeW5jVGltZXN0YW1wPU0sdGhpcy5zeW5jSW5kZXg9dGhpcy50bXBQb2ludHMubGVuZ3RoKSwhciYmdGhpcy5kcmF3KHthdHRyczpiLHRhc2tzOkUsaXNEb3Q6ITF9KX1jb25zdCB5PVtdO3JldHVybiB0aGlzLnRtcFBvaW50cy5zbGljZSh2KS5mb3JFYWNoKE09Pnt5LnB1c2goTS54LE0ueSl9KSx7cmVjdDp7eDp4LngqdGhpcy5mdWxsTGF5ZXIud29ybGRTY2FsaW5nWzBdK3RoaXMuZnVsbExheWVyLndvcmxkUG9zaXRpb25bMF0seTp4LnkqdGhpcy5mdWxsTGF5ZXIud29ybGRTY2FsaW5nWzFdK3RoaXMuZnVsbExheWVyLndvcmxkUG9zaXRpb25bMV0sdzp4LncqdGhpcy5mdWxsTGF5ZXIud29ybGRTY2FsaW5nWzBdLGg6eC5oKnRoaXMuZnVsbExheWVyLndvcmxkU2NhbGluZ1sxXX0sdHlwZTpwdC5EcmF3V29yayxkYXRhVHlwZTpTdC5Mb2NhbCx3b3JrSWQ6Yz9uOnZvaWQgMCxvcDpjP3k6dm9pZCAwLGluZGV4OmM/dioyOnZvaWQgMH19Y29uc3VtZUFsbCgpe3ZhciBuO2NvbnN0IGU9KG49dGhpcy53b3JrSWQpPT1udWxsP3ZvaWQgMDpuLnRvU3RyaW5nKCk7bGV0IHQ7aWYodGhpcy50bXBQb2ludHMubGVuZ3RoLTE+dGhpcy5jb25zdW1lSW5kZXgpe2xldCBkPXRoaXMudG1wUG9pbnRzLnNsaWNlKHRoaXMuY29uc3VtZUluZGV4KTtjb25zdCBnPWQubGVuZ3RoPT09MSx7Y29sb3I6dSx0aGlja25lc3M6byxzdHJva2VUeXBlOmYsb3BhY2l0eTp4fT10aGlzLndvcmtPcHRpb25zO2lmKGcpe2NvbnN0IHA9dGhpcy5jb21wdXREb3RTdHJva2Uoe3BvaW50OmRbMF0scmFkaXVzOm8vMn0pO2Q9cC5wcyx0PXAucmVjdH1lbHNlIHQ9WnQodGhpcy50bXBQb2ludHMsbyk7Y29uc3QgYz17bmFtZTplPT1udWxsP3ZvaWQgMDplLnRvU3RyaW5nKCksY2xhc3NOYW1lOiJMYXNlclBlbiIsZmlsbENvbG9yOmc/dTp2b2lkIDAsb3BhY2l0eTp4fHwxLGxpbmVEYXNoOmY9PT1EdC5Eb3R0ZWQmJiFnP1sxLG8qMl06Zj09PUR0LkxvbmdEb3R0ZWQmJiFnP1tvLG8qMl06dm9pZCAwLHN0cm9rZUNvbG9yOnUsbGluZUNhcDpnP3ZvaWQgMDoicm91bmQiLGxpbmVXaWR0aDpnPzA6byxhbmNob3I6Wy41LC41XX0sdj10aGlzLmdldFRhc2tQb2ludHMoZCk7di5sZW5ndGgmJnRoaXMuZHJhdyh7YXR0cnM6Yyx0YXNrczp2LGlzRG90Omd9KX1jb25zdCByPVtdO3JldHVybiB0aGlzLnRtcFBvaW50cy5zbGljZSh0aGlzLnN5bmNJbmRleCkuZm9yRWFjaChkPT57ci5wdXNoKGQueCxkLnkpfSkse3JlY3Q6dCYme3g6dC54KnRoaXMuZnVsbExheWVyLndvcmxkU2NhbGluZ1swXSt0aGlzLmZ1bGxMYXllci53b3JsZFBvc2l0aW9uWzBdLHk6dC55KnRoaXMuZnVsbExheWVyLndvcmxkU2NhbGluZ1sxXSt0aGlzLmZ1bGxMYXllci53b3JsZFBvc2l0aW9uWzFdLHc6dC53KnRoaXMuZnVsbExheWVyLndvcmxkU2NhbGluZ1swXSxoOnQuaCp0aGlzLmZ1bGxMYXllci53b3JsZFNjYWxpbmdbMV19LHR5cGU6cHQuRHJhd1dvcmssZGF0YVR5cGU6U3QuTG9jYWwsd29ya0lkOmUsb3A6cixpbmRleDp0aGlzLnN5bmNJbmRleCoyfX1jbGVhclRtcFBvaW50cygpe3RoaXMudG1wUG9pbnRzLmxlbmd0aD0wLHRoaXMuc3luY1RpbWVzdGFtcD0wLHRoaXMuc3luY0luZGV4PTB9Y29uc3VtZVNlcnZpY2UoZSl7dmFyIHA7Y29uc3R7b3A6dH09ZSx7Y29sb3I6cix0aGlja25lc3M6bixzdHJva2VUeXBlOmQsb3BhY2l0eTpnfT10aGlzLndvcmtPcHRpb25zO2lmKCF0Lmxlbmd0aCl7Y29uc3QgYj1adCh0aGlzLnRtcFBvaW50cyxuKTtyZXR1cm57eDpiLngqdGhpcy5mdWxsTGF5ZXIud29ybGRTY2FsaW5nWzBdK3RoaXMuZnVsbExheWVyLndvcmxkUG9zaXRpb25bMF0seTpiLnkqdGhpcy5mdWxsTGF5ZXIud29ybGRTY2FsaW5nWzFdK3RoaXMuZnVsbExheWVyLndvcmxkUG9zaXRpb25bMV0sdzpiLncqdGhpcy5mdWxsTGF5ZXIud29ybGRTY2FsaW5nWzBdLGg6Yi5oKnRoaXMuZnVsbExheWVyLndvcmxkU2NhbGluZ1sxXX19Y29uc3QgdT1NYXRoLm1heCgwLHRoaXMudG1wUG9pbnRzLmxlbmd0aC0xKTt0aGlzLnVwZGF0ZVRlbXBQb2ludHModHx8W10pO2xldCBvLGY9dGhpcy50bXBQb2ludHMuc2xpY2UodSk7Y29uc3QgeD1mLmxlbmd0aD09PTE7aWYoeCl7Y29uc3QgYj10aGlzLmNvbXB1dERvdFN0cm9rZSh7cG9pbnQ6ZlswXSxyYWRpdXM6bi8yfSk7Zj1iLnBzLG89Yi5yZWN0fWVsc2Ugbz1adCh0aGlzLnRtcFBvaW50cyxuKTtjb25zdCBjPXtuYW1lOihwPXRoaXMud29ya0lkKT09bnVsbD92b2lkIDA6cC50b1N0cmluZygpLGNsYXNzTmFtZToiTGFzZXJQZW4iLGZpbGxDb2xvcjp4P3I6dm9pZCAwLG9wYWNpdHk6Z3x8MSxsaW5lRGFzaDpkPT09RHQuRG90dGVkJiYheD9bMSxuKjJdOmQ9PT1EdC5Mb25nRG90dGVkJiYheD9bbixuKjJdOnZvaWQgMCxzdHJva2VDb2xvcjpyLGxpbmVDYXA6eD92b2lkIDA6InJvdW5kIixsaW5lV2lkdGg6eD8wOm4sYW5jaG9yOlsuNSwuNV19LHY9dGhpcy5nZXRUYXNrUG9pbnRzKGYpO3JldHVybiB2Lmxlbmd0aCYmdGhpcy5kcmF3KHthdHRyczpjLHRhc2tzOnYsaXNEb3Q6eH0pLHt4Om8ueCp0aGlzLmZ1bGxMYXllci53b3JsZFNjYWxpbmdbMF0rdGhpcy5mdWxsTGF5ZXIud29ybGRQb3NpdGlvblswXSx5Om8ueSp0aGlzLmZ1bGxMYXllci53b3JsZFNjYWxpbmdbMV0rdGhpcy5mdWxsTGF5ZXIud29ybGRQb3NpdGlvblsxXSx3Om8udyp0aGlzLmZ1bGxMYXllci53b3JsZFNjYWxpbmdbMF0saDpvLmgqdGhpcy5mdWxsTGF5ZXIud29ybGRTY2FsaW5nWzFdfX1jb21wdXREb3RTdHJva2UoZSl7Y29uc3R7cG9pbnQ6dCxyYWRpdXM6cn09ZSxuPXt4OnQueC1yLHk6dC55LXIsdzpyKjIsaDpyKjJ9O3JldHVybntwczpMdC5HZXREb3RTdHJva2UodCxyLDgpLHJlY3Q6bn19dXBkYXRlVGVtcFBvaW50cyhlKXtjb25zdCB0PXRoaXMudG1wUG9pbnRzLmxlbmd0aDtmb3IobGV0IHI9MDtyPGUubGVuZ3RoO3IrPTIpe2lmKHQpe2NvbnN0IG49dGhpcy50bXBQb2ludHMuc2xpY2UoLTEpWzBdO24mJm4ueD09PWVbcl0mJm4ueT09PWVbcisxXSYmdGhpcy50bXBQb2ludHMucG9wKCl9dGhpcy50bXBQb2ludHMucHVzaChuZXcgTHQoZVtyXSxlW3IrMV0pKX19YXN5bmMgZHJhdyhlKXtjb25zdHthdHRyczp0LHRhc2tzOnIsaXNEb3Q6bn09ZSxkPXRoaXMuZnVsbExheWVyLHtkdXJhdGlvbjpnfT10aGlzLndvcmtPcHRpb25zLHU9bmV3IEllO2ZvcihsZXQgbz0wO288ci5sZW5ndGg7bysrKXtjb25zdHtwb3M6Zixwb2ludHM6eH09cltvXTtsZXQgYztuP2M9eWUoeCwhMCk6Yz15ZSh4LCExKSx1LmF0dHIoey4uLnQscG9zOmYsZDpjfSk7Y29uc3R7dmVydGV4OnYsZnJhZ21lbnQ6cH09dGhpcy53b3JrT3B0aW9ucztpZih2JiZwKXtjb25zdCBiPWQucmVuZGVyZXIuY3JlYXRlUHJvZ3JhbSh7dmVydGV4OnYsZnJhZ21lbnQ6cH0pLHt3aWR0aDpFLGhlaWdodDp5fT1kLmdldFJlc29sdXRpb24oKTt1LnNldFVuaWZvcm1zKHt1X3RpbWU6MCx1X3Jlc29sdXRpb246W0UseV19KSx1LnNldFByb2dyYW0oYil9ZC5hcHBlbmRDaGlsZCh1KSxhd2FpdCB1LnRyYW5zaXRpb24oZykuYXR0cih7c2NhbGU6bj9bLjEsLjFdOlsxLDFdLGxpbmVXaWR0aDpuPzA6MX0pLHUucmVtb3ZlKCl9fWdldFRhc2tQb2ludHMoZSl7dmFyIG87Y29uc3QgdD1bXTtpZihlLmxlbmd0aD09PTApcmV0dXJuW107bGV0IHI9MCxuPWVbMF0ueCxkPWVbMF0ueSxnPVtuLGRdLHU9W107Zm9yKDtyPGUubGVuZ3RoOyl7Y29uc3QgZj1lW3JdLHg9Zi54LW4sYz1mLnktZDtpZih1LnB1c2gobmV3IEx0KHgsYykpLHI+MCYmcjxlLmxlbmd0aC0xKXtjb25zdCB2PWVbcl0uZ2V0QW5nbGVCeVBvaW50cyhlW3ItMV0sZVtyKzFdKTtpZih2PDkwfHx2PjI3MCl7Y29uc3QgcD0obz11LnBvcCgpKT09bnVsbD92b2lkIDA6by5jbG9uZSgpO3AmJnQucHVzaCh7cG9zOmcscG9pbnRzOlsuLi51LHBdfSksbj1lW3JdLngsZD1lW3JdLnksZz1bbixkXTtjb25zdCBiPWYueC1uLEU9Zi55LWQ7dT1bbmV3IEx0KGIsRSldfX1yKyt9cmV0dXJuIHQucHVzaCh7cG9zOmcscG9pbnRzOnV9KSx0fXJlbW92ZUxvY2FsKCl7fXJlbW92ZVNlcnZpY2UoZSl7bGV0IHQ7Y29uc3Qgcj1bXTtyZXR1cm4gdGhpcy5mdWxsTGF5ZXIuZ2V0RWxlbWVudHNCeU5hbWUoZSkuZm9yRWFjaChuPT57aWYobi5uYW1lPT09ZSl7Y29uc3QgZD1uLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO3Q9VHQodCx7eDpkLngseTpkLnksdzpkLndpZHRoLGg6ZC5oZWlnaHR9KSxyLnB1c2gobil9fSksci5sZW5ndGgmJnIuZm9yRWFjaChuPT5uLnJlbW92ZSgpKSx0fX1jbGFzcyBKbntjb25zdHJ1Y3Rvcigpe09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJjdXJOb2RlTWFwIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6bmV3IE1hcH0pfXVwZGF0ZVNjZW5lKGUpe3RoaXMuc2NlbmUuYXR0cih7Li4uZX0pO2NvbnN0e3dpZHRoOnQsaGVpZ2h0OnJ9PWU7dGhpcy5zY2VuZS5jb250YWluZXIud2lkdGg9dCx0aGlzLnNjZW5lLmNvbnRhaW5lci5oZWlnaHQ9cix0aGlzLnNjZW5lLndpZHRoPXQsdGhpcy5zY2VuZS5oZWlnaHQ9cix0aGlzLnVwZGF0ZUxheWVyKHt3aWR0aDp0LGhlaWdodDpyfSl9dXBkYXRlTGF5ZXIoZSl7Y29uc3R7d2lkdGg6dCxoZWlnaHQ6cn09ZTt0aGlzLmZ1bGxMYXllciYmKHRoaXMuZnVsbExheWVyLnBhcmVudC5zZXRBdHRyaWJ1dGUoIndpZHRoIix0KSx0aGlzLmZ1bGxMYXllci5wYXJlbnQuc2V0QXR0cmlidXRlKCJoZWlnaHQiLHIpLHRoaXMuZnVsbExheWVyLnNldEF0dHJpYnV0ZSgic2l6ZSIsW3Qscl0pLHRoaXMuZnVsbExheWVyLnNldEF0dHJpYnV0ZSgicG9zIixbdCouNSxyKi41XSkpLHRoaXMuZHJhd0xheWVyJiYodGhpcy5kcmF3TGF5ZXIucGFyZW50LnNldEF0dHJpYnV0ZSgid2lkdGgiLHQpLHRoaXMuZHJhd0xheWVyLnBhcmVudC5zZXRBdHRyaWJ1dGUoImhlaWdodCIsciksdGhpcy5kcmF3TGF5ZXIuc2V0QXR0cmlidXRlKCJzaXplIixbdCxyXSksdGhpcy5kcmF3TGF5ZXIuc2V0QXR0cmlidXRlKCJwb3MiLFt0Ki41LHIqLjVdKSksdGhpcy5zbmFwc2hvdEZ1bGxMYXllciYmKHRoaXMuc25hcHNob3RGdWxsTGF5ZXIucGFyZW50LnNldEF0dHJpYnV0ZSgid2lkdGgiLHQpLHRoaXMuc25hcHNob3RGdWxsTGF5ZXIucGFyZW50LnNldEF0dHJpYnV0ZSgiaGVpZ2h0IixyKSx0aGlzLnNuYXBzaG90RnVsbExheWVyLnNldEF0dHJpYnV0ZSgic2l6ZSIsW3Qscl0pLHRoaXMuc25hcHNob3RGdWxsTGF5ZXIuc2V0QXR0cmlidXRlKCJwb3MiLFt0Ki41LHIqLjVdKSl9Y3JlYXRlU2NlbmUoZSl7Y29uc3R7d2lkdGg6dCxoZWlnaHQ6cn09ZSxuPW5ldyBPZmZzY3JlZW5DYW52YXModCxyKTtyZXR1cm4gbmV3IG9uKHtjb250YWluZXI6bixkaXNwbGF5UmF0aW86dGhpcy5kcHIsZGVwdGg6ITEsZGVzeW5jaHJvbml6ZWQ6ITAsLi4uZX0pfWNyZWF0ZUxheWVyKGUsdCl7Y29uc3R7d2lkdGg6cixoZWlnaHQ6bn09dCxkPSJvZmZzY3JlZW4iK0RhdGUubm93KCksZz1lLmxheWVyKGQsdCksdT1uZXcgRGUoe2FuY2hvcjpbLjUsLjVdLHBvczpbciouNSxuKi41XSxzaXplOltyLG5dLG5hbWU6InZpZXdwb3J0In0pO3JldHVybiBnLmFwcGVuZCh1KSx1fWdldE5vZGVzKGUpe3JldHVybiB0aGlzLmZ1bGxMYXllci5nZXRFbGVtZW50c0J5TmFtZShlKyIiKS5jb25jYXQodGhpcy5kcmF3TGF5ZXIuZ2V0RWxlbWVudHNCeU5hbWUoZSsiIikpfX1jbGFzcyBabntjb25zdHJ1Y3RvcihlLHQscil7T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImZ1bGxMYXllciIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJkcmF3TGF5ZXIiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiY3VyTm9kZU1hcCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ0bXBXb3JrU2hhcGVOb2RlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInRtcE9wdCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ3b3JrU2hhcGVTdGF0ZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOm5ldyBNYXB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiZWZmZWN0V29ya0lkIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksdGhpcy5jdXJOb2RlTWFwPWUsdGhpcy5mdWxsTGF5ZXI9dCx0aGlzLmRyYXdMYXllcj1yfWdldFdvcmtTaGFwZShlKXtyZXR1cm4gdGhpcy53b3JrU2hhcGVzLmdldChlKX1nZXRUbXBXb3JrU2hhcGVOb2RlKCl7cmV0dXJuIHRoaXMudG1wV29ya1NoYXBlTm9kZX1zZXRUbXBXb3JrSWQoZSl7aWYoZSYmdGhpcy50bXBXb3JrU2hhcGVOb2RlKXt0aGlzLnRtcFdvcmtTaGFwZU5vZGUuc2V0V29ya0lkKGUpLHRoaXMud29ya1NoYXBlcy5zZXQoZSx0aGlzLnRtcFdvcmtTaGFwZU5vZGUpLHRoaXMudG1wT3B0JiZ0aGlzLnNldFRvb2xzT3B0KHRoaXMudG1wT3B0KTtyZXR1cm59fXNldFRtcFdvcmtPcHRpb25zKGUpe3ZhciB0Oyh0PXRoaXMudG1wV29ya1NoYXBlTm9kZSk9PW51bGx8fHQuc2V0V29ya09wdGlvbnMoZSl9c2V0V29ya09wdGlvbnMoZSx0KXt2YXIgbjt0aGlzLndvcmtTaGFwZXMuZ2V0KGUpfHx0aGlzLnNldFRtcFdvcmtJZChlKSwobj10aGlzLndvcmtTaGFwZXMuZ2V0KGUpKT09bnVsbHx8bi5zZXRXb3JrT3B0aW9ucyh0KX1jcmVhdGVXb3JrU2hhcGVOb2RlKGUpe2xldCB0O3N3aXRjaChlLnRvb2xzVHlwZSl7Y2FzZSBBdC5QZW5jaWw6dD1uZXcgQnQoZS50b29sc09wdCx0aGlzLmZ1bGxMYXllcix0aGlzLmRyYXdMYXllcik7YnJlYWs7Y2FzZSBBdC5MYXNlclBlbjp0PW5ldyBncihlLnRvb2xzT3B0LHRoaXMuZnVsbExheWVyKTticmVhaztjYXNlIEF0LkVyYXNlcjp0PW5ldyBLdChlLnRvb2xzT3B0LHRoaXMuZnVsbExheWVyKTticmVhaztjYXNlIEF0LlNlbGVjdG9yOnQ9bmV3IHZ0KGUudG9vbHNPcHQsdGhpcy5mdWxsTGF5ZXIsdGhpcy5kcmF3TGF5ZXIpO2JyZWFrO2RlZmF1bHQ6dD12b2lkIDA7YnJlYWt9cmV0dXJuIHR9c2V0VG9vbHNPcHQoZSl7dmFyIHQscjsoKHQ9dGhpcy50bXBPcHQpPT1udWxsP3ZvaWQgMDp0LnRvb2xzVHlwZSkhPT1lLnRvb2xzVHlwZSYmKHI9dGhpcy50bXBPcHQpIT1udWxsJiZyLnRvb2xzVHlwZSYmdGhpcy5jbGVhckFsbFdvcmtTaGFwZXNDYWNoZSgpLHRoaXMudG1wT3B0PWUsdGhpcy50bXBXb3JrU2hhcGVOb2RlPXRoaXMuY3JlYXRlV29ya1NoYXBlTm9kZShlKX1jbGVhcldvcmtTaGFwZU5vZGVDYWNoZShlKXt2YXIgdDsodD10aGlzLmdldFdvcmtTaGFwZShlKSk9PW51bGx8fHQuY2xlYXJUbXBQb2ludHMoKSx0aGlzLndvcmtTaGFwZXMuZGVsZXRlKGUpLHRoaXMud29ya1NoYXBlU3RhdGUuZGVsZXRlKGUpfWNsZWFyQWxsV29ya1NoYXBlc0NhY2hlKCl7dGhpcy53b3JrU2hhcGVzLmZvckVhY2goZT0+ZS5jbGVhclRtcFBvaW50cygpKSx0aGlzLndvcmtTaGFwZXMuY2xlYXIoKSx0aGlzLndvcmtTaGFwZVN0YXRlLmNsZWFyKCl9cnVuRWZmZWN0V29yayhlKXt0aGlzLmVmZmVjdFdvcmtJZCYmKGNsZWFyVGltZW91dCh0aGlzLmVmZmVjdFdvcmtJZCksdGhpcy5lZmZlY3RXb3JrSWQ9dm9pZCAwKSx0aGlzLmVmZmVjdFdvcmtJZD1zZXRUaW1lb3V0KCgpPT57dGhpcy5lZmZlY3RXb3JrSWQ9dm9pZCAwLHRoaXMuY29tcHV0Tm9kZU1hcCgpLHRoaXMucmVyUmVuZGVyU2VsZWN0b3IoKSxlJiZlKCl9LDUwKX1jb21wdXROb2RlTWFwKCl7dmFyIHQscjtjb25zdCBlPW5ldyBTZXQodGhpcy5jdXJOb2RlTWFwLmtleXMoKSk7aWYodGhpcy5mdWxsTGF5ZXIuY2hpbGRyZW4uZm9yRWFjaChuPT57aWYobi5uYW1lIT09dnQuc2VsZWN0b3JJZCl7Y29uc3QgZD1YdChuLm5hbWUsdGhpcy5mdWxsTGF5ZXIpO2lmKGQpe2NvbnN0IGc9dGhpcy5jdXJOb2RlTWFwLmdldChuLm5hbWUpO2c/KGcucmVjdD1kLGUuZGVsZXRlKG4ubmFtZSkpOnRoaXMuY3VyTm9kZU1hcC5zZXQobi5uYW1lLHtuYW1lOm4ubmFtZSxyZWN0OmR9KX19fSksKHI9KHQ9dGhpcy5kcmF3TGF5ZXIpPT1udWxsP3ZvaWQgMDp0LmNoaWxkcmVuKT09bnVsbHx8ci5mb3JFYWNoKG49PntpZihuLm5hbWUhPT12dC5zZWxlY3RvcklkKXtjb25zdCBkPVh0KG4ubmFtZSx0aGlzLmRyYXdMYXllcik7aWYoZCl7Y29uc3QgZz10aGlzLmN1ck5vZGVNYXAuZ2V0KG4ubmFtZSk7Zz8oZy5yZWN0PWQsZS5kZWxldGUobi5uYW1lKSk6dGhpcy5jdXJOb2RlTWFwLnNldChuLm5hbWUse25hbWU6bi5uYW1lLHJlY3Q6ZH0pfX19KSxlLnNpemUpZm9yKGNvbnN0IG4gb2YgZS5rZXlzKCkpdGhpcy5jdXJOb2RlTWFwLmRlbGV0ZShuKX11cGRhdGFOb2RlTWFwKGUpe2NvbnN0e2tleTp0LG9wczpyLG9wdDpuLHRvb2xzVHlwZTpkfT1lO2xldCBnPVh0KHQsdGhpcy5mdWxsTGF5ZXIpO2NvbnN0IHU9dGhpcy5jdXJOb2RlTWFwLmdldCh0KXx8e25hbWU6dCxyZWN0Omd9O3ImJih1Lm9wcz1yKSxuJiYodS5vcHQ9biksZyYmKHUucmVjdD1nKSxkJiYodS50b29sc1R5cGU9ZCksdGhpcy5kcmF3TGF5ZXImJihnPVh0KHQsdGhpcy5kcmF3TGF5ZXIpLGcmJnRoaXMuZHJhd0xheWVyJiYodS5yZWN0PWcpKSx1LnJlY3Q/dGhpcy5jdXJOb2RlTWFwLnNldCh0LHUpOnRoaXMuY3VyTm9kZU1hcC5kZWxldGUodCl9cmVyUmVuZGVyU2VsZWN0b3IoKXt2YXIgdDtjb25zdCBlPXRoaXMud29ya1NoYXBlcy5nZXQodnQuc2VsZWN0b3JJZCk7aWYoKHQ9ZT09bnVsbD92b2lkIDA6ZS5zZWxlY3RJZHMpIT1udWxsJiZ0Lmxlbmd0aCYmdGhpcy5kcmF3TGF5ZXIpe2NvbnN0IHI9ZS5nZXRTZWxlY3Rvcih0aGlzLmN1ck5vZGVNYXApO3ImJnRoaXMuX3Bvc3Qoe3JlbmRlcjpbe3JlY3Q6cixpc0NsZWFyOiEwLGlzRnVsbFdvcms6ITEsY2xlYXJDYW52YXM6eXQuU2VsZWN0b3IsZHJhd0NhbnZhczp5dC5TZWxlY3Rvcn1dLHNwOlt7dHlwZTpwdC5TZWxlY3Qsc2VsZWN0SWRzOmUuc2VsZWN0SWRzLHNlbGVjdFJlY3Q6cix3aWxsU3luY1NlcnZpY2U6ITF9XX0pfX19Y2xhc3MgUW57Y29uc3RydWN0b3IoZSx0LHIpe09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJkcmF3TGF5ZXIiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiZnVsbExheWVyIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImN1ck5vZGVNYXAiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSx0aGlzLmN1ck5vZGVNYXA9ZSx0aGlzLmZ1bGxMYXllcj10LHRoaXMuZHJhd0xheWVyPXJ9dXBkYXRhTm9kZU1hcChlLHQscil7bGV0IG49WHQoZSx0aGlzLmZ1bGxMYXllcik7Y29uc3QgZD10aGlzLmN1ck5vZGVNYXAuZ2V0KGUpfHx7bmFtZTplLHJlY3Q6bn07dCYmKGQub3BzPXQpLHImJihkLm9wdD1yKSxuJiYoZC5yZWN0PW4pLHRoaXMuZHJhd0xheWVyJiYobj1YdChlLHRoaXMuZHJhd0xheWVyKSxuJiZ0aGlzLmRyYXdMYXllciYmKGQucmVjdD1uKSksZC5yZWN0P3RoaXMuY3VyTm9kZU1hcC5zZXQoZSxkKTp0aGlzLmN1ck5vZGVNYXAuZGVsZXRlKGUpfX1jbGFzcyBxbiBleHRlbmRzIFpue2NvbnN0cnVjdG9yKGUsdCxyLG4pe3N1cGVyKGUsdCxyKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiX3Bvc3QiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywid29ya1NoYXBlcyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOm5ldyBNYXB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiY29tYmluZVVuaXRUaW1lIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6NjAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImNvbWJpbmVUaW1lcklkIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImRyYXdDb3VudCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOjB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiZWZmZWN0U2VsZWN0Tm9kZURhdGEiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpuZXcgU2V0fSksdGhpcy5fcG9zdD1ufWRyYXdQZW5jaWxDb21iaW5lKGUpe3ZhciByLG47Y29uc3QgdD0ocj10aGlzLndvcmtTaGFwZXMuZ2V0KGUpKT09bnVsbD92b2lkIDA6ci5jb21iaW5lQ29uc3VtZSgpO2lmKHQpe2NvbnN0IGQ9e3JlbmRlcjpbXSxkcmF3Q291bnQ6dGhpcy5kcmF3Q291bnR9OyhuPWQucmVuZGVyKT09bnVsbHx8bi5wdXNoKHtyZWN0OnQ9PW51bGw/dm9pZCAwOnQucmVjdCxpc0NsZWFyOiEwLGRyYXdDYW52YXM6eXQuRmxvYXQsY2xlYXJDYW52YXM6eXQuRmxvYXQsaXNGdWxsV29yazohMX0pLHRoaXMuX3Bvc3QoZCl9fWRyYXdTZWxlY3RvcihlLHQpe3ZhciBuLGQsZztjb25zdCByPXtyZW5kZXI6W10sc3A6W2VdfTsobj1lLnNlbGVjdElkcykhPW51bGwmJm4ubGVuZ3RoJiYhdCYmKChkPXIucmVuZGVyKT09bnVsbHx8ZC5wdXNoKHtyZWN0OmUuc2VsZWN0UmVjdCxkcmF3Q2FudmFzOnl0LlNlbGVjdG9yLGlzQ2xlYXI6ITAsY2xlYXJDYW52YXM6eXQuU2VsZWN0b3IsaXNGdWxsV29yazohMX0se3JlY3Q6ZS5zZWxlY3RSZWN0fHxlLnJlY3QsaXNDbGVhcjohMCxjbGVhckNhbnZhczp5dC5GbG9hdCxpc0Z1bGxXb3JrOiExfSx7cmVjdDplLnJlY3QsZHJhd0NhbnZhczp5dC5CZyxpc0NsZWFyOiEwLGNsZWFyQ2FudmFzOnl0LkJnLGlzRnVsbFdvcms6ITB9KSksdCYmKChnPXIucmVuZGVyKT09bnVsbHx8Zy5wdXNoKHtyZWN0OmUucmVjdCxkcmF3Q2FudmFzOnl0LkZsb2F0LGlzQ2xlYXI6ITAsY2xlYXJDYW52YXM6eXQuRmxvYXQsaXNGdWxsV29yazohMX0se3JlY3Q6ZS5yZWN0LGRyYXdDYW52YXM6eXQuQmcsaXNDbGVhcjohMCxjbGVhckNhbnZhczp5dC5CZyxpc0Z1bGxXb3JrOiEwfSkpLHRoaXMuX3Bvc3Qocil9YXN5bmMgZHJhd0VyYXNlcihlLHQpe3ZhciBuLGQsZyx1O2NvbnN0IHI9W107KG49ZS5uZXdXb3JrRGF0YXMpIT1udWxsJiZuLmxlbmd0aCYmKHIucHVzaCguLi5lLm5ld1dvcmtEYXRhcy5tYXAobz0+KHt0eXBlOnB0LkZ1bGxXb3JrLHdvcmtJZDpvLndvcmtJZCxvcHM6eGUoby5vcCksb3B0Om8ub3B0LHRvb2xzVHlwZTpvLnRvb2xzVHlwZSx1cGRhdGVOb2RlT3B0Ont1c2VBbmltYXRpb246ITF9fSkpKSxkZWxldGUgZS5uZXdXb3JrRGF0YXMpLHIucHVzaChlKSxhd2FpdCB0aGlzLl9wb3N0KHtyZW5kZXI6W3tyZWN0OmUucmVjdCxkcmF3Q2FudmFzOnl0LkJnLGlzQ2xlYXI6ITAsY2xlYXJDYW52YXM6eXQuQmcsaXNGdWxsV29yazohMH1dLHNwOnJ9KTtmb3IobGV0IG89MDtvPHIubGVuZ3RoO28rKylpZigoZD1yW29dLnJlbW92ZUlkcykhPW51bGwmJmQubGVuZ3RoKShnPXJbb10ucmVtb3ZlSWRzKT09bnVsbHx8Zy5mb3JFYWNoKGY9Pnt0aGlzLmN1ck5vZGVNYXAuZGVsZXRlKGYpLHQuY3VyTm9kZU1hcC5kZWxldGUoZil9KTtlbHNlIGlmKHJbb10udHlwZT09PXB0LkZ1bGxXb3JrKXtjb25zdCBmPSh1PXJbb10ud29ya0lkKT09bnVsbD92b2lkIDA6dS50b1N0cmluZygpO2lmKGYpe2NvbnN0IHg9cltvXS5vcHMsYz1yW29dLm9wdCx2PXJbb10udG9vbHNUeXBlO3RoaXMudXBkYXRhTm9kZU1hcCh7a2V5OmYsb3BzOngsb3B0OmMsdG9vbHNUeXBlOnZ9KX19fWRyYXdQZW5jaWwoZSl7dGhpcy5fcG9zdCh7ZHJhd0NvdW50OnRoaXMuZHJhd0NvdW50LHNwOihlPT1udWxsP3ZvaWQgMDplLm9wKSYmW2VdfSl9ZHJhd1BlbmNpbEZ1bGwoZSx0LHIpe3ZhciBkO2NvbnN0IG49e2RyYXdDb3VudDoxLzAscmVuZGVyOlt7cmVjdDplLnJlY3QsZHJhd0NhbnZhczp5dC5CZyxpc0NsZWFyOihyPT1udWxsP3ZvaWQgMDpyLndpbGxDbGVhcil8fCh0Lm9wYWNpdHl8fDEpPDEsY2xlYXJDYW52YXM6eXQuQmcsaXNGdWxsV29yazohMH1dLHNwOltlXX07KGQ9bi5yZW5kZXIpPT1udWxsfHxkLnB1c2goe2lzQ2xlYXJBbGw6ITAsY2xlYXJDYW52YXM6eXQuRmxvYXQsaXNGdWxsV29yazohMX0pLHRoaXMuX3Bvc3QobikudGhlbigoKT0+e2Uud29ya0lkJiZ0aGlzLnVwZGF0YU5vZGVNYXAoe2tleTplLndvcmtJZC50b1N0cmluZygpLG9wczplLm9wcyx0b29sc1R5cGU6QXQuUGVuY2lsLG9wdDp0fSl9KX1jb25zdW1lRHJhdyhlLHQpe3ZhciBkO2NvbnN0e29wOnIsd29ya0lkOm59PWU7aWYociE9bnVsbCYmci5sZW5ndGgmJm4pe2NvbnN0IGc9dGhpcy53b3JrU2hhcGVzLmdldChuKTtpZighZylyZXR1cm47Y29uc3QgdT1nLnRvb2xzVHlwZTtpZih1PT09QXQuTGFzZXJQZW4pcmV0dXJuO2NvbnN0IG89Zy5jb25zdW1lKHtkYXRhOmUsaXNGdWxsV29yazohMCxub2RlTWFwczp0aGlzLmN1ck5vZGVNYXB9KTtpZih1PT09QXQuU2VsZWN0b3Ipe28udHlwZT09PXB0LlNlbGVjdCYmKG8uc2VsZWN0SWRzJiZ0LnJ1blJldmVyc2VTZWxlY3RXb3JrKG8uc2VsZWN0SWRzKSx0aGlzLmRyYXdTZWxlY3RvcihvLCEwKSk7cmV0dXJufWlmKHU9PT1BdC5FcmFzZXIpe2lmKChkPW8ubmV3V29ya0RhdGFzKSE9bnVsbCYmZC5sZW5ndGgpe2xldCBmPW89PW51bGw/dm9pZCAwOm8ucmVjdDtvLm5ld1dvcmtEYXRhcy5mb3JFYWNoKHg9Pntjb25zdCBjPXRoaXMuc2V0RnVsbFdvcmsoeCksdj1jJiZjLmNvbnN1bWVTZXJ2aWNlKHtvcDp4Lm9wLGlzRnVsbFdvcms6ITB9KSxwPXgud29ya0lkLnRvU3RyaW5nKCk7diYmKGcudXBkYXRhTm9kZU1hcChwLHtuYW1lOnAscmVjdDp2LG9wdDp4Lm9wdCx0b29sc1R5cGU6eC50b29sc1R5cGUsb3A6eC5vcH0pLGY9VHQoZix2KSl9KSxmJiYoby5yZWN0PWYpfW8hPW51bGwmJm8ucmVjdCYmdGhpcy5kcmF3RXJhc2VyKG8sZyk7cmV0dXJufXU9PT1BdC5QZW5jaWwmJih0aGlzLmNvbWJpbmVUaW1lcklkfHwodGhpcy5jb21iaW5lVGltZXJJZD1zZXRUaW1lb3V0KCgpPT57dGhpcy5jb21iaW5lVGltZXJJZD12b2lkIDAsdGhpcy5kcmF3UGVuY2lsQ29tYmluZShuKX0sTWF0aC5mbG9vcihnLmdldFdvcmtPcHRpb25zKCkuc3luY1VuaXRUaW1lfHx0aGlzLmNvbWJpbmVVbml0VGltZS8yKSkpLG8mJih0aGlzLmRyYXdDb3VudCsrLHRoaXMuZHJhd1BlbmNpbChvKSkpfX1jb25zdW1lRHJhd0FsbChlLHQpe3ZhciBkO3RoaXMuY29tYmluZVRpbWVySWQmJihjbGVhclRpbWVvdXQodGhpcy5jb21iaW5lVGltZXJJZCksdGhpcy5jb21iaW5lVGltZXJJZD12b2lkIDApO2NvbnN0e3dvcmtJZDpyLHVuZG9UaWNrZXJJZDpufT1lO2lmKHIpe24mJnNldFRpbWVvdXQoKCk9Pnt0aGlzLl9wb3N0KHtzcDpbe3R5cGU6cHQuTm9uZSx1bmRvVGlja2VySWQ6bn1dfSl9LDApO2NvbnN0IGc9dGhpcy53b3JrU2hhcGVzLmdldChyKTtpZighZylyZXR1cm47Y29uc3QgdT1nLnRvb2xzVHlwZTtpZih1PT09QXQuTGFzZXJQZW4pcmV0dXJuO2NvbnN0IG89Zy5jb25zdW1lQWxsKHtkYXRhOmUsbm9kZU1hcHM6dGhpcy5jdXJOb2RlTWFwfSk7aWYodT09PUF0LlNlbGVjdG9yKXtvLnNlbGVjdElkcyYmdC5ydW5SZXZlcnNlU2VsZWN0V29yayhvLnNlbGVjdElkcyksdGhpcy5kcmF3U2VsZWN0b3IobywhMSksKGQ9Zy5zZWxlY3RJZHMpIT1udWxsJiZkLmxlbmd0aD9nLmNsZWFyVG1wUG9pbnRzKCk6dGhpcy5jbGVhcldvcmtTaGFwZU5vZGVDYWNoZShyKTtyZXR1cm59aWYodT09PUF0LkVyYXNlcil7byE9bnVsbCYmby5yZWN0JiZ0aGlzLmRyYXdFcmFzZXIobyxnKSxnLmNsZWFyVG1wUG9pbnRzKCk7cmV0dXJufWlmKHU9PT1BdC5QZW5jaWwpe2lmKG8hPW51bGwmJm8ucmVjdCl7Y29uc3QgZj10aGlzLndvcmtTaGFwZVN0YXRlLmdldChyKTt0aGlzLmRyYXdQZW5jaWxGdWxsKG8sZy5nZXRXb3JrT3B0aW9ucygpLGYpLHRoaXMuZHJhd0NvdW50PTB9dGhpcy5jbGVhcldvcmtTaGFwZU5vZGVDYWNoZShyKX19fWFzeW5jIHVwZGF0ZVNlbGVjdG9yKGUpe3ZhciBFLHksTSxpO2NvbnN0IHQ9dGhpcy53b3JrU2hhcGVzLmdldCh2dC5zZWxlY3RvcklkKTtpZighKChFPXQuc2VsZWN0SWRzKSE9bnVsbCYmRS5sZW5ndGgpKXJldHVybjtjb25zdHt1cGRhdGVTZWxlY3Rvck9wdDpyLHdpbGxSZWZyZXNoU2VsZWN0b3I6bix3aWxsU3luY1NlcnZpY2U6ZCx3aWxsU2VyaWFsaXplRGF0YTpnLGVtaXRFdmVudFR5cGU6dSxzZWxlY3RTdG9yZTpvLGlzU3luYzpmfT1lLHg9ci53b3JrU3RhdGUsYz0odT09PWJ0LlJvdGF0ZU5vZGV8fHU9PT1idC5TY2FsZU5vZGUpJiZ4PT09R3QuRG9uZSYmZyx2PXQ9PW51bGw/dm9pZCAwOnQudXBkYXRlU2VsZWN0b3Ioe3VwZGF0ZVNlbGVjdG9yT3B0OnIsc2VsZWN0SWRzOnQuc2VsZWN0SWRzLHNlbGVjdFN0b3JlOm99KTtsZXQgcD1bXTt1PT09YnQuU2NhbGVOb2RlJiZwLnB1c2goe2lzQ2xlYXJBbGw6ITAsaXNGdWxsV29yazohMSxjbGVhckNhbnZhczp5dC5TZWxlY3Rvcn0pLHYmJm4mJnAucHVzaCh7cmVjdDp2LnJlY3QsaXNDbGVhcjp1IT09YnQuU2NhbGVOb2RlLGlzRnVsbFdvcms6ITEsY2xlYXJDYW52YXM6eXQuU2VsZWN0b3IsZHJhd0NhbnZhczp5dC5TZWxlY3Rvcn0pLHYmJm4mJmcmJnAmJiFjJiYoYXdhaXQgdGhpcy5fcG9zdCh7cmVuZGVyOnB9KSxwPXZvaWQgMCk7Y29uc3QgYj1uZXcgTWFwO2lmKGcmJnYhPW51bGwmJnYudXBkYXRlTm9kZU9wdHMmJm8pZm9yKGNvbnN0W2Esc11vZiBvLmVudHJpZXMoKSl7Y29uc3R7b3BzOmwsb3B0Ok8sdXBkYXRlTm9kZU9wdDpBLHRvb2xzVHlwZTpSfT1zO2xldCBJO2NvbnN0IFA9TyxMPXsuLi5BLC4uLnYudXBkYXRlTm9kZU9wdHMuZ2V0KGEpfTtsZXQgRD1bXTtpZihQJiZMLmNvbG9yJiYoUC5jb2xvcj1MLmNvbG9yLGRlbGV0ZSBMLmNvbG9yKSxQJiZMLnpJbmRleCYmKFAuekluZGV4PUwuekluZGV4LGRlbGV0ZSBMLnpJbmRleCksUCYmTC5vcGFjaXR5JiYoUC5vcGFjaXR5PUwub3BhY2l0eSxkZWxldGUgTC5vcGFjaXR5KSxsJiYoTCE9bnVsbCYmTC5wb3MpJiYoTCE9bnVsbCYmTC5vcmlnaW5Qb3MpKXtjb25zdCBDPVtMLnBvc1swXS1MLm9yaWdpblBvc1swXSxMLnBvc1sxXS1MLm9yaWdpblBvc1sxXV0sUz1lZShsKS5tYXAoKEIsdyk9Pntjb25zdCBIPXclMztyZXR1cm4gSD09PTA/QitDWzBdOkg9PT0xP0IrQ1sxXTpCfSk7TC5zY2FsZSYmKGduKFMsTC5wb3MsTC5zY2FsZSksRD1TLGRlbGV0ZSBMLnNjYWxlKSxJPXhlKFMpLCh5PXRoaXMuZHJhd0xheWVyKT09bnVsbHx8eS5nZXRFbGVtZW50c0J5TmFtZShhKS5mb3JFYWNoKEI9PntpZihMLnBvcyl7Y29uc3Qgdz1CLmNsYXNzTmFtZS5zcGxpdCgiLCIpO0Iuc2V0QXR0cmlidXRlKCJjbGFzc05hbWUiLGAke0wucG9zWzBdfSwgJHtMLnBvc1sxXX0sICR7d1syXX1gKX19KSxkZWxldGUgTC5vcmlnaW5Qb3N9aWYobCYmTC5hbmdsZSYmTC5vcmlnaW5Qb3Mpe2NvbnN0IEM9ZWUobCk7ZG4oQyxMLm9yaWdpblBvcyxMLmFuZ2xlKSxEPUMsST14ZShDKSxkZWxldGUgTC5hbmdsZSxkZWxldGUgTC5vcmlnaW5Qb3N9aWYoUiYmbCYmTyYmRC5sZW5ndGgpe2NvbnN0IEM9dGhpcy5jcmVhdGVXb3JrU2hhcGVOb2RlKHt0b29sc1R5cGU6Uix0b29sc09wdDpPfSk7Qz09bnVsbHx8Qy5zZXRXb3JrSWQoYSksQz09bnVsbHx8Qy5jb25zdW1lU2VydmljZSh7b3A6RCxpc0Z1bGxXb3JrOiExLHJlcGxhY2VJZDphLGlzQ2xlYXJBbGw6ITF9KX1iLnNldChhLHtvcHM6SSx1cGRhdGVOb2RlT3B0Okwsb3B0OlAsdG9vbHNUeXBlOlJ9KX1pZih2JiYoKE09di51cGRhdGVOb2RlT3B0cykhPW51bGwmJk0uc2l6ZSkpe2RlbGV0ZSByLndvcmtTdGF0ZTtjb25zdCBhPVtdO2lmKGQpe2lmKGcpe3U9PT1idC5Sb3RhdGVOb2RlJiZ4PT09R3QuRG9uZSYmYS5wdXNoKHt0eXBlOnB0LlNlbGVjdCxzZWxlY3RJZHM6dC5zZWxlY3RJZHMsc2VsZWN0UmVjdDp2LnJlY3QsaXNTeW5jOmZ9KSx1PT09YnQuU2NhbGVOb2RlJiZ4PT09R3QuRG9uZSYmYS5wdXNoKHt0eXBlOnB0LlNlbGVjdCxzZWxlY3RJZHM6dC5zZWxlY3RJZHMsc2VsZWN0UmVjdDp2LnJlY3Qsd2lsbFN5bmNTZXJ2aWNlOiExfSk7Zm9yKGNvbnN0W3MsbF1vZiBiLmVudHJpZXMoKSlhLnB1c2goey4uLmwsd29ya0lkOnMsdHlwZTpwdC5VcGRhdGVOb2RlLGlzU3luYzpmfSl9ZWxzZXt1PT09YnQuU2NhbGVOb2RlJiZ4PT09R3QuU3RhcnQmJmEucHVzaCh7dHlwZTpwdC5TZWxlY3Qsc2VsZWN0SWRzOnQuc2VsZWN0SWRzLHNlbGVjdFJlY3Q6di5yZWN0LGNhbnZhc1dpZHRoOnRoaXMuZnVsbExheWVyLnBhcmVudC53aWR0aCxjYW52YXNIZWlnaHQ6dGhpcy5mdWxsTGF5ZXIucGFyZW50LmhlaWdodCx3aWxsU3luY1NlcnZpY2U6ITF9KTtmb3IoY29uc3RbcyxsXW9mIHYudXBkYXRlTm9kZU9wdHMuZW50cmllcygpKWEucHVzaCh7d29ya0lkOnMsdHlwZTpwdC5VcGRhdGVOb2RlLHVwZGF0ZU5vZGVPcHQ6bCxpc1N5bmM6Zn0pfWF3YWl0IHRoaXMuX3Bvc3Qoe3JlbmRlcjohYyYmcHx8dm9pZCAwLHNwOmF9KX0hYyYmeD09PUd0LkRvbmUmJigoaT10LnNlbGVjdElkcyk9PW51bGx8fGkuZm9yRWFjaChzPT57Y29uc3QgbD1hPT1udWxsP3ZvaWQgMDphLmZpbmQoTz0+KE89PW51bGw/dm9pZCAwOk8ud29ya0lkKSYmTy53b3JrSWQ9PT1zKTt0aGlzLnVwZGF0YU5vZGVNYXAoe2tleTpzLG9wczpsPT1udWxsP3ZvaWQgMDpsLm9wcyxvcHQ6bD09bnVsbD92b2lkIDA6bC5vcHR9KX0pKSxjJiYocCE9bnVsbCYmcC5sZW5ndGgpJiZzZXRUaW1lb3V0KCgpPT57dGhpcy5fcG9zdCh7cmVuZGVyOnB9KS50aGVuKCgpPT57dmFyIHM7eD09PUd0LkRvbmUmJigocz10LnNlbGVjdElkcyk9PW51bGx8fHMuZm9yRWFjaChsPT57Y29uc3QgTz1hPT1udWxsP3ZvaWQgMDphLmZpbmQoQT0+KEE9PW51bGw/dm9pZCAwOkEud29ya0lkKSYmQS53b3JrSWQ9PT1sKTt0aGlzLnVwZGF0YU5vZGVNYXAoe2tleTpsLG9wczpPPT1udWxsP3ZvaWQgMDpPLm9wcyxvcHQ6Tz09bnVsbD92b2lkIDA6Ty5vcHR9KX0pKX0pfSwyMCl9fWJsdXJTZWxlY3RvcihlKXt2YXIgbjtjb25zdCB0PXRoaXMud29ya1NoYXBlcy5nZXQodnQuc2VsZWN0b3JJZCkscj10PT1udWxsP3ZvaWQgMDp0LmJsdXJTZWxlY3Rvcih0aGlzLmN1ck5vZGVNYXApO2lmKHRoaXMuY2xlYXJXb3JrU2hhcGVOb2RlQ2FjaGUodnQuc2VsZWN0b3JJZCksKChuPXRoaXMuZHJhd0xheWVyKT09bnVsbD92b2lkIDA6bi5wYXJlbnQpLmNoaWxkcmVuLmZvckVhY2goZD0+e2QubmFtZT09PXZ0LnNlbGVjdG9ySWQmJmQucmVtb3ZlKCl9KSxyKXtjb25zdCBkPVtyXTtlIT1udWxsJiZlLnVuZG9UaWNrZXJJZCYmZC5wdXNoKHt0eXBlOnB0Lk5vbmUsdW5kb1RpY2tlcklkOmUudW5kb1RpY2tlcklkfSksdGhpcy5fcG9zdCh7cmVuZGVyOihyPT1udWxsP3ZvaWQgMDpyLnJlY3QpJiZbe3JlY3Q6ci5yZWN0LGRyYXdDYW52YXM6eXQuQmcsaXNDbGVhcjohMCxjbGVhckNhbnZhczp5dC5CZyxpc0Z1bGxXb3JrOiEwfV0sc3A6ZH0pfX1zZXRGdWxsV29yayhlKXtjb25zdHt3b3JrSWQ6dCxvcHQ6cix0b29sc1R5cGU6bn09ZTtpZih0JiZyJiZuKXtjb25zdCBkPXQmJnRoaXMud29ya1NoYXBlcy5nZXQodCl8fHRoaXMuY3JlYXRlV29ya1NoYXBlTm9kZSh7dG9vbHNPcHQ6cix0b29sc1R5cGU6bn0pO3JldHVybiBkPyhkLnNldFdvcmtJZCh0KSx0aGlzLndvcmtTaGFwZXMuc2V0KHQsZCksZCk6dm9pZCAwfX1jb25zdW1lRnVsbChlKXt2YXIgbjtjb25zdCB0PXRoaXMuc2V0RnVsbFdvcmsoZSkscj1lLm9wcyYmZWUoZS5vcHMpO2lmKHQpe2xldCBkPXQuY29uc3VtZVNlcnZpY2Uoe29wOnIsaXNGdWxsV29yazohMCxyZXBsYWNlSWQ6KG49dC5nZXRXb3JrSWQoKSk9PW51bGw/dm9pZCAwOm4udG9TdHJpbmcoKX0pO2Q9VHQoZCwoZT09bnVsbD92b2lkIDA6ZS51cGRhdGVOb2RlT3B0KSYmdC51cGRhdGFPcHRTZXJ2aWNlKGUudXBkYXRlTm9kZU9wdCkpLGQmJmUud2lsbFJlZnJlc2gmJnRoaXMuX3Bvc3Qoe3JlbmRlcjpbe3JlY3Q6ZCxkcmF3Q2FudmFzOnl0LkJnLGlzRnVsbFdvcms6ITB9XSxzcDplLndpbGxTeW5jU2VydmljZSYmW3tvcHQ6ZS5vcHQsdG9vbHNUeXBlOmUudG9vbHNUeXBlLHR5cGU6cHQuRnVsbFdvcmssd29ya0lkOmUud29ya0lkLG9wczplLm9wcyx1cGRhdGVOb2RlT3B0OmUudXBkYXRlTm9kZU9wdCx1bmRvVGlja2VySWQ6ZS51bmRvVGlja2VySWR9XXx8dm9pZCAwfSkudGhlbigoKT0+e3ZhciBnO2Uud29ya0lkJiZ0aGlzLnVwZGF0YU5vZGVNYXAoe2tleTooZz1lLndvcmtJZCk9PW51bGw/dm9pZCAwOmcudG9TdHJpbmcoKSxvcHM6ZS5vcHMsb3B0OmUub3B0LHRvb2xzVHlwZTplLnRvb2xzVHlwZX0pfSksZS53b3JrSWQmJnRoaXMud29ya1NoYXBlcy5kZWxldGUoZS53b3JrSWQpfX11cGRhdGVOb2RlKGUpe2NvbnN0e3dvcmtJZDp0LHVwZGF0ZU5vZGVPcHQ6cix3aWxsUmVmcmVzaDpuLHdpbGxTeW5jU2VydmljZTpkfT1lO2lmKHQpe2NvbnN0IGc9dC50b1N0cmluZygpO2xldCB1O2NvbnN0IG89e307dGhpcy5mdWxsTGF5ZXIuZ2V0RWxlbWVudHNCeU5hbWUoZykuZm9yRWFjaChmPT57aWYobil7Y29uc3QgeD1mLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO3U9VHQodSx7eDpNYXRoLmZsb29yKHgueC0xMCkseTpNYXRoLmZsb29yKHgueS0xMCksdzpNYXRoLmZsb29yKHgud2lkdGgrMjApLGg6TWF0aC5mbG9vcih4LmhlaWdodCsyMCl9KX1pZihyLnBvcyYmKG8ucG9zPXIucG9zLGYuc2V0QXR0cmlidXRlKCJwb3MiLHIucG9zKSksci56SW5kZXgmJihvLnpJbmRleD1yLnpJbmRleCxmLnNldEF0dHJpYnV0ZSgiekluZGV4IixvLnpJbmRleCkpLHIuY29sb3ImJihvLmNvbG9yPXIuY29sb3IsZi5zZXRBdHRyaWJ1dGUoInN0cm9rZUNvbG9yIixvLmNvbG9yKSxmLmdldEF0dHJpYnV0ZSgiZmlsbENvbG9yIikmJmYuc2V0QXR0cmlidXRlKCJzdHJva2VDb2xvciIsby5jb2xvcikpLG4pe2NvbnN0IHg9Zi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTt1PVR0KHUse3g6TWF0aC5mbG9vcih4LngtMTApLHk6TWF0aC5mbG9vcih4LnktMTApLHc6TWF0aC5mbG9vcih4LndpZHRoKzIwKSxoOk1hdGguZmxvb3IoeC5oZWlnaHQrMjApfSl9fSksKHV8fGQpJiZ0aGlzLl9wb3N0KHtyZW5kZXI6W3tyZWN0OnUsZHJhd0NhbnZhczp5dC5CZyxpc0NsZWFyOiEwLGNsZWFyQ2FudmFzOnl0LkJnLGlzRnVsbFdvcms6ITB9XSxzcDpkJiZbe3R5cGU6cHQuVXBkYXRlTm9kZSx3b3JrSWQ6dCx1cGRhdGVOb2RlT3B0Om99XXx8dm9pZCAwfSl9fXJlbW92ZVdvcmsoZSl7dmFyIG47Y29uc3R7d29ya0lkOnR9PWUscj10PT1udWxsP3ZvaWQgMDp0LnRvU3RyaW5nKCk7aWYocil7dGhpcy53b3JrU2hhcGVzLmhhcyhyKSYmdGhpcy5jbGVhcldvcmtTaGFwZU5vZGVDYWNoZShyKTtsZXQgZDtjb25zdCBnPVtdLHU9dGhpcy5jdXJOb2RlTWFwLmdldChyKTt1JiZ0aGlzLmN1ck5vZGVNYXAuZGVsZXRlKHIpLHRoaXMuZnVsbExheWVyLmdldEVsZW1lbnRzQnlOYW1lKHIpLmNvbmNhdCgoKG49dGhpcy5kcmF3TGF5ZXIpPT1udWxsP3ZvaWQgMDpuLmdldEVsZW1lbnRzQnlOYW1lKHIpKXx8W10pLmZvckVhY2gobz0+e2lmKHUpZD1UdChkLHUucmVjdCk7ZWxzZXtjb25zdCBmPW8uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7ZD1UdChkLHt4OmYueCx5OmYueSx3OmYud2lkdGgsaDpmLmhlaWdodH0pfWcucHVzaChvKX0pLGcubGVuZ3RoJiZnLmZvckVhY2gobz0+by5yZW1vdmUoKSksZCYmdGhpcy5fcG9zdCh7cmVuZGVyOlt7cmVjdDpkLGlzQ2xlYXI6ITAsaXNGdWxsV29yazohMCxjbGVhckNhbnZhczp5dC5CZyxkcmF3Q2FudmFzOnl0LkJnfV19KSx0aGlzLmN1ck5vZGVNYXAuZGVsZXRlKHIpfX1ydW5SZXZlcnNlU2VsZWN0V29yayhlKXtjb25zdCB0PXRoaXMud29ya1NoYXBlcy5nZXQodnQuc2VsZWN0b3JJZCkse3NlbGVjdElkczpyfT1lLG49W107aWYodCYmciYmdC5zZWxlY3RJZHMpe2Zvcihjb25zdCBkIG9mIHIpe2NvbnN0IGc9dC5zZWxlY3RJZHMuZmluZEluZGV4KHU9PnU9PT1kKTtnPi0xJiYodC5zZWxlY3RJZHMuc3BsaWNlKGcsMSksbi5wdXNoKGQpKX1pZihuLmxlbmd0aCl7Y29uc3QgZD1bXTt0LnNlbGVjdElkcy5sZW5ndGghPT0wJiZ0aGlzLnJlclJlbmRlclNlbGVjdG9yKCk7bGV0IGc7bi5mb3JFYWNoKHU9Pnt2YXIgZjtjb25zdCBvPShmPXRoaXMuZHJhd0xheWVyKT09bnVsbD92b2lkIDA6Zi5nZXRFbGVtZW50c0J5TmFtZSh1KVswXTtpZihvKXtjb25zdCB4PW8uY2xvbmVOb2RlKCEwKTtpZih4LnRhZ05hbWU9PT0iR1JPVVAiKXtjb25zdCB2PW8uY2xhc3NOYW1lLnNwbGl0KCIsIik7di5sZW5ndGg9PT0zJiZOdW1iZXIodlsyXSk9PT1EdC5TdHJva2UmJnguc2VhbCgpfWQucHVzaCh4KSxvLnJlbW92ZSgpO2NvbnN0IGM9dGhpcy5jdXJOb2RlTWFwLmdldCh1KTtjJiYoZz1UdChnLGMucmVjdCkpfX0pLGQubGVuZ3RoJiZ0aGlzLmZ1bGxMYXllci5hcHBlbmQoLi4uZCksZyYmdGhpcy5fcG9zdCh7cmVuZGVyOlt7cmVjdDpnLGlzQ2xlYXI6ITAsaXNGdWxsV29yazohMCxjbGVhckNhbnZhczp5dC5CZyxkcmF3Q2FudmFzOnl0LkJnfV0sc3A6dC5zZWxlY3RJZHMubGVuZ3RoPT09MCYmW3t0eXBlOnB0LlNlbGVjdCxzZWxlY3RJZHM6W10sd2lsbFN5bmNTZXJ2aWNlOiExfV18fHZvaWQgMH0pfX19dXBkYXRlRnVsbFNlbGVjdFdvcmsoZSl7dmFyIG4sZCxnLHUsbztjb25zdCB0PXRoaXMud29ya1NoYXBlcy5nZXQodnQuc2VsZWN0b3JJZCkse3NlbGVjdElkczpyfT1lO2lmKCEociE9bnVsbCYmci5sZW5ndGgpKXt0aGlzLmJsdXJTZWxlY3RvcihlKTtyZXR1cm59aWYoIXQpe3RoaXMuc2V0RnVsbFdvcmsoZSksdGhpcy51cGRhdGVGdWxsU2VsZWN0V29yayhlKTtyZXR1cm59aWYodCYmKHIhPW51bGwmJnIubGVuZ3RoKSl7Y29uc3R7YmdSZWN0OmYsc2VsZWN0UmVjdDp4fT10LnVwZGF0ZVNlbGVjdElkcyhyLHRoaXMuY3VyTm9kZU1hcCksYz17cmVuZGVyOltdLHNwOltdfTtmJiYoKG49Yy5yZW5kZXIpPT1udWxsfHxuLnB1c2goe3JlY3Q6Zixpc0NsZWFyOiEwLGlzRnVsbFdvcms6ITAsY2xlYXJDYW52YXM6eXQuQmcsZHJhd0NhbnZhczp5dC5CZ30pKSwoZD1jLnJlbmRlcik9PW51bGx8fGQucHVzaCh7cmVjdDpmfHx4LGlzQ2xlYXI6ITAsaXNGdWxsV29yazohMSxjbGVhckNhbnZhczp5dC5TZWxlY3RvcixkcmF3Q2FudmFzOnl0LlNlbGVjdG9yfSksKG89Yy5zcCk9PW51bGx8fG8ucHVzaCh7Li4uZSxub2RlT3BhY3RpeTooZz1lLm9wdCk9PW51bGw/dm9pZCAwOmcub3BhY2l0eSxub2RlQ29sb3I6KHU9ZS5vcHQpPT1udWxsP3ZvaWQgMDp1LmNvbG9yLHR5cGU6cHQuU2VsZWN0LHNlbGVjdFJlY3Q6Znx8eCx3aWxsU3luY1NlcnZpY2U6ITF9KSx0aGlzLl9wb3N0KGMpfX1jb2xsb2N0RWZmZWN0U2VsZWN0V29yayhlKXtjb25zdCB0PXRoaXMud29ya1NoYXBlcy5nZXQodnQuc2VsZWN0b3JJZCkse3dvcmtJZDpyfT1lO2lmKHQmJnImJnQuc2VsZWN0SWRzJiZ0LnNlbGVjdElkcy5pbmNsdWRlcyhyLnRvU3RyaW5nKCkpKXt0aGlzLmVmZmVjdFNlbGVjdE5vZGVEYXRhLmFkZChlKSxzZXRUaW1lb3V0KCgpPT57dmFyIG47dGhpcy5ydW5FZmZlY3RTZWxlY3RXb3JrKCksKG49dGhpcy5lZmZlY3RTZWxlY3ROb2RlRGF0YSk9PW51bGx8fG4uY2xlYXIoKX0sMCk7cmV0dXJufXJldHVybiBlfXJ1bkVmZmVjdFNlbGVjdFdvcmsoKXt2YXIgZSx0O2Zvcihjb25zdCByIG9mIHRoaXMuZWZmZWN0U2VsZWN0Tm9kZURhdGEudmFsdWVzKCkpe2NvbnN0IG49dGhpcy5zZXRGdWxsV29yayhyKSxkPXIub3BzJiZlZShyLm9wcyk7aWYobil7bGV0IGc9bi5jb25zdW1lU2VydmljZSh7b3A6ZCxpc0Z1bGxXb3JrOiExLHJlcGxhY2VJZDooZT1uLmdldFdvcmtJZCgpKT09bnVsbD92b2lkIDA6ZS50b1N0cmluZygpfSk7Zz1UdChnLChyPT1udWxsP3ZvaWQgMDpyLnVwZGF0ZU5vZGVPcHQpJiZuLnVwZGF0YU9wdFNlcnZpY2Uoci51cGRhdGVOb2RlT3B0KSksZyYmci53b3JrSWQmJnRoaXMudXBkYXRhTm9kZU1hcCh7a2V5Oih0PXIud29ya0lkKT09bnVsbD92b2lkIDA6dC50b1N0cmluZygpLG9wczpyLm9wcyxvcHQ6ci5vcHQsdG9vbHNUeXBlOnIudG9vbHNUeXBlfSksci53b3JrSWQmJnRoaXMud29ya1NoYXBlcy5kZWxldGUoci53b3JrSWQpfX10aGlzLnJlclJlbmRlclNlbGVjdG9yKCl9fWNsYXNzIGtuIGV4dGVuZHMgUW57Y29uc3RydWN0b3IoZSx0LHIsbil7c3VwZXIoZSx0LHIpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ3b3JrU2hhcGVzIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6bmV3IE1hcH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJhbmltYXRpb25JZCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzZWxlY3RvcldvcmtTaGFwZXMiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpuZXcgTWFwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIl9wb3N0Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIndpbGxSdW5FZmZlY3RTZWxlY3RvcklkcyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOm5ldyBTZXR9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywicnVuRWZmZWN0SWQiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywibm9BbmltYXRpb25SZWN0Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksdGhpcy5fcG9zdD1ufWFjdGl2ZVdvcmtTaGFwZShlKXt2YXIgcCxiLEU7Y29uc3R7d29ya0lkOnQsb3B0OnIsdG9vbHNUeXBlOm4sdHlwZTpkLHVwZGF0ZU5vZGVPcHQ6ZyxvcHM6dSxvcDpvLHVzZUFuaW1hdGlvbjpmLG5vUmVuZGVyOnh9PWU7aWYoIXQpcmV0dXJuO2NvbnN0IGM9dC50b1N0cmluZygpO2lmKCEoKHA9dGhpcy53b3JrU2hhcGVzKSE9bnVsbCYmcC5oYXMoYykpKXtsZXQgeT17dG9vbHNUeXBlOm4sYW5pbWF0aW9uV29ya0RhdGE6b3x8W10sYW5pbWF0aW9uSW5kZXg6MCx0eXBlOmQsdXBkYXRlTm9kZU9wdDpnLG9wczp1LHVzZUFuaW1hdGlvbjp0eXBlb2YgZjwidSI/Zjp0eXBlb2YoZz09bnVsbD92b2lkIDA6Zy51c2VBbmltYXRpb24pPCJ1Ij9nPT1udWxsP3ZvaWQgMDpnLnVzZUFuaW1hdGlvbjohMCxvbGRSZWN0OnRoaXMuZ2V0Tm9kZVJlY3QoYyksbm9SZW5kZXI6eH07biYmciYmKHk9dGhpcy5zZXROb2RlS2V5KHksbixyKSksKGI9dGhpcy53b3JrU2hhcGVzKT09bnVsbHx8Yi5zZXQoYyx5KX1jb25zdCB2PShFPXRoaXMud29ya1NoYXBlcyk9PW51bGw/dm9pZCAwOkUuZ2V0KGMpO2QmJih2LnR5cGU9ZCksdSYmKHYuYW5pbWF0aW9uV29ya0RhdGE9ZWUodSksdi5vcHM9dSksZyYmKHYudXBkYXRlTm9kZU9wdD1nKSxvJiYodi5hbmltYXRpb25Xb3JrRGF0YT1vKSx4JiYodi5ub1JlbmRlcj14KSx2Lm5vZGUmJnYubm9kZS5nZXRXb3JrSWQoKSE9PWMmJnYubm9kZS5zZXRXb3JrSWQoYyksdi50b29sc1R5cGUhPT1uJiZuJiZyJiZ0aGlzLnNldE5vZGVLZXkodixuLHIpfWFjdGl2ZVNlbGVjdG9yU2hhcGUoZSl7dmFyIGYseCxjO2NvbnN0e3dvcmtJZDp0LG9wdDpyLHRvb2xzVHlwZTpuLHR5cGU6ZCxzZWxlY3RJZHM6Z309ZTtpZighdClyZXR1cm47Y29uc3QgdT10LnRvU3RyaW5nKCk7aWYoISgoZj10aGlzLnNlbGVjdG9yV29ya1NoYXBlcykhPW51bGwmJmYuaGFzKHUpKSl7bGV0IHY9e3Rvb2xzVHlwZTpuLHNlbGVjdElkczpnLHR5cGU6ZCxvcHQ6cn07biYmciYmKHY9dGhpcy5zZXROb2RlS2V5KHYsbixyKSksKHg9dGhpcy5zZWxlY3RvcldvcmtTaGFwZXMpPT1udWxsfHx4LnNldCh1LHYpfWNvbnN0IG89KGM9dGhpcy5zZWxlY3RvcldvcmtTaGFwZXMpPT1udWxsP3ZvaWQgMDpjLmdldCh1KTtkJiYoby50eXBlPWQpLG8ubm9kZSYmby5ub2RlLmdldFdvcmtJZCgpIT09dSYmby5ub2RlLnNldFdvcmtJZCh1KSxvLnNlbGVjdElkcz1nfHxbXX1zZXROb2RlS2V5KGUsdCxyKXtzd2l0Y2goZS50b29sc1R5cGU9dCx0KXtjYXNlIEF0LlBlbmNpbDplLm5vZGU9bmV3IEJ0KHIsdGhpcy5mdWxsTGF5ZXIsdGhpcy5kcmF3TGF5ZXIpO2JyZWFrO2Nhc2UgQXQuTGFzZXJQZW46ZS5ub2RlPW5ldyBncihyLHRoaXMuZHJhd0xheWVyKTticmVhaztjYXNlIEF0LlNlbGVjdG9yOmUubm9kZT1uZXcgdnQocix0aGlzLmZ1bGxMYXllcik7YnJlYWs7ZGVmYXVsdDplLm5vZGU9dm9pZCAwO2JyZWFrfXJldHVybiBlfWNvbXB1dE5leHRBbmltYXRpb25JbmRleChlLHQpe3ZhciBuO2NvbnN0IHI9TWF0aC5mbG9vcigoZS5hbmltYXRpb25Xb3JrRGF0YXx8W10pLnNsaWNlKGUuYW5pbWF0aW9uSW5kZXgpLmxlbmd0aCozMi90LygoKG49ZS5ub2RlKT09bnVsbD92b2lkIDA6bi5zeW5jVW5pdFRpbWUpfHwxZTMpKSp0O3JldHVybiBNYXRoLm1pbigoZS5hbmltYXRpb25JbmRleHx8MCkrKHJ8fHQpLChlLmFuaW1hdGlvbldvcmtEYXRhfHxbXSkubGVuZ3RoKX1hbmltYXRpb25EcmF3KCl7dmFyIG8sZix4LGMsdjt0aGlzLmFuaW1hdGlvbklkPXZvaWQgMDtsZXQgZSx0LHI9ITEsbj0hMSxkO2NvbnN0IGc9bmV3IE1hcDt0aGlzLndvcmtTaGFwZXMuZm9yRWFjaCgocCxiKT0+e3ZhciBFLHksTSxpLGEscyxsLE8sQSxSLEksUDtpZihwLnVzZUFuaW1hdGlvbil7Y29uc3QgTD1wLnRvb2xzVHlwZT09PUF0LlBlbmNpbD8zOjIsRD10aGlzLmNvbXB1dE5leHRBbmltYXRpb25JbmRleChwLEwpLEM9TWF0aC5tYXgoMCwocC5hbmltYXRpb25JbmRleHx8MCktTCksUz0ocC5hbmltYXRpb25Xb3JrRGF0YXx8W10pLnNsaWNlKEMsRCk7bGV0IEI7KHAuYW5pbWF0aW9uSW5kZXh8fDApPEQ/KEI9KGE9cC5ub2RlKT09bnVsbD92b2lkIDA6YS5jb25zdW1lU2VydmljZSh7b3A6Uyxpc0Z1bGxXb3JrOiExLHJlcGxhY2VJZDooaT1wLm5vZGUuZ2V0V29ya0lkKCkpPT1udWxsP3ZvaWQgMDppLnRvU3RyaW5nKCl9KSxwLnRvb2xzVHlwZT09PUF0Lkxhc2VyUGVuPyh0PVR0KHQsQikscC50aW1lciYmKGNsZWFyVGltZW91dChwLnRpbWVyKSxwLnRpbWVyPXZvaWQgMCkpOnAubm9SZW5kZXJ8fChlPVR0KGUsQikscC50b3RhbFJlY3Q9VHQocC50b3RhbFJlY3QsQikpLHI9ITAscC5hbmltYXRpb25JbmRleD1EKTpwLmlzRGVsP3AuaXNEZWwmJihwLnRvb2xzVHlwZT09PUF0Lkxhc2VyUGVuJiYoQj0oUj1wLm5vZGUpPT1udWxsP3ZvaWQgMDpSLmNvbnN1bWVTZXJ2aWNlKHtvcDpbXSxpc0Z1bGxXb3JrOiExfSkscC5ub1JlbmRlcnx8KHQ9VHQodCxCKSkpLHRoaXMudXBkYXRhTm9kZU1hcChiLHAub3BzLChJPXAubm9kZSk9PW51bGw/dm9pZCAwOkkuZ2V0V29ya09wdGlvbnMoKSksdGhpcy53b3JrU2hhcGVzLmRlbGV0ZShiKSk6KHAudG9vbHNUeXBlPT09QXQuUGVuY2lsJiZwLm9wcyYmKEI9KGw9cC5ub2RlKT09bnVsbD92b2lkIDA6bC5jb25zdW1lU2VydmljZSh7b3A6cC5hbmltYXRpb25Xb3JrRGF0YXx8W10saXNGdWxsV29yazohMCxyZXBsYWNlSWQ6KHM9cC5ub2RlLmdldFdvcmtJZCgpKT09bnVsbD92b2lkIDA6cy50b1N0cmluZygpfSkscC5pc0RlbD0hMCxuPSEwLHAubm9SZW5kZXJ8fCh0PVR0KHQsQikscC50b3RhbFJlY3Q9dCkpLHAudG9vbHNUeXBlPT09QXQuTGFzZXJQZW4mJihwLnRpbWVyfHwocC50aW1lcj1zZXRUaW1lb3V0KCgpPT57cC50aW1lcj12b2lkIDAscC5pc0RlbD0hMCx0aGlzLnJ1bkFuaW1hdGlvbigpfSwoKE89cC5ub2RlKT09bnVsbD92b2lkIDA6Ty5nZXRXb3JrT3B0aW9ucygpKS5kdXJhdGlvbioxZTMrMTAwKSksbj0hMSxCPShBPXAubm9kZSk9PW51bGw/dm9pZCAwOkEuY29uc3VtZVNlcnZpY2Uoe29wOltdLGlzRnVsbFdvcms6ITF9KSx0PVR0KHQsQikpLHI9ITApLFMubGVuZ3RoJiZnLnNldChiLHt3b3JrU3RhdGU6Qz09PTA/R3QuU3RhcnQ6RD09PSgoUD1wLmFuaW1hdGlvbldvcmtEYXRhKT09bnVsbD92b2lkIDA6UC5sZW5ndGgpP0d0LkRvbmU6R3QuRG9pbmcsb3A6Uy5maWx0ZXIoKHcsSCk9PntpZihMPT09MyYmSCVMIT09TC0xKXJldHVybiEwO2lmKEw9PT0yKXJldHVybiEwfSkuc2xpY2UoLTIpfSl9ZWxzZSBpZihwLnRvb2xzVHlwZT09PUF0LlBlbmNpbCYmcC5vcHMpe2xldCBMPShFPXAubm9kZSk9PW51bGw/dm9pZCAwOkUuY29uc3VtZVNlcnZpY2Uoe29wOnAuYW5pbWF0aW9uV29ya0RhdGF8fFtdLGlzRnVsbFdvcms6ITAscmVwbGFjZUlkOmJ9KTtMPVR0KHAub2xkUmVjdCxMKSxMPVR0KEwsKHk9cC5ub2RlKT09bnVsbD92b2lkIDA6eS51cGRhdGFPcHRTZXJ2aWNlKHAudXBkYXRlTm9kZU9wdCkpLHAubm9SZW5kZXJ8fChkPVR0KGQsTCkpLHRoaXMuc2VsZWN0b3JXb3JrU2hhcGVzLmZvckVhY2goKEQsQyk9Pnt2YXIgUzsoUz1ELnNlbGVjdElkcykhPW51bGwmJlMuaW5jbHVkZXMoYikmJih0aGlzLndpbGxSdW5FZmZlY3RTZWxlY3Rvcklkcy5hZGQoQyksdGhpcy5ub0FuaW1hdGlvblJlY3Q9VHQodGhpcy5ub0FuaW1hdGlvblJlY3QsZCksZD12b2lkIDAsdGhpcy5ydW5FZmZlY3QoKSl9KSx0aGlzLnVwZGF0YU5vZGVNYXAoYixwLm9wcywoTT1wLm5vZGUpPT1udWxsP3ZvaWQgMDpNLmdldFdvcmtPcHRpb25zKCkpLHRoaXMud29ya1NoYXBlcy5kZWxldGUoYil9fSksciYmdGhpcy5ydW5BbmltYXRpb24oKTtjb25zdCB1PXtyZW5kZXI6W119O2UmJigobz11LnJlbmRlcik9PW51bGx8fG8ucHVzaCh7cmVjdDplLGRyYXdDYW52YXM6bj95dC5CZzp5dC5GbG9hdCxpc0NsZWFyOm4sY2xlYXJDYW52YXM6eXQuRmxvYXQsaXNGdWxsV29yazpufSkpLHQmJigoZj11LnJlbmRlcik9PW51bGx8fGYucHVzaCh7cmVjdDp0LGRyYXdDYW52YXM6IW4mJnl0LkZsb2F0fHx2b2lkIDAsaXNDbGVhcjohMCxjbGVhckNhbnZhczp5dC5GbG9hdCxpc0Z1bGxXb3JrOm59KSxuJiYoKHg9dS5yZW5kZXIpPT1udWxsfHx4LnB1c2goe3JlY3Q6dCxkcmF3Q2FudmFzOnl0LkJnLGlzQ2xlYXI6ITAsY2xlYXJDYW52YXM6eXQuQmcsaXNGdWxsV29yazpufSkpKSxkJiYoKGM9dS5yZW5kZXIpPT1udWxsfHxjLnB1c2goe3JlY3Q6ZCxkcmF3Q2FudmFzOnl0LkJnLGlzQ2xlYXI6ITAsY2xlYXJDYW52YXM6eXQuQmcsaXNGdWxsV29yazohMH0pKSxnLnNpemUmJih1LnNwPVtdLGcuZm9yRWFjaCgocCxiKT0+e3ZhciBFOyhFPXUuc3ApPT1udWxsfHxFLnB1c2goe3R5cGU6cHQuQ3Vyc29yLHVpZDpiLnNwbGl0KE1uKVswXSxvcDpwLm9wLHdvcmtTdGF0ZTpwLndvcmtTdGF0ZX0pfSkpLCh2PXUucmVuZGVyKSE9bnVsbCYmdi5sZW5ndGgmJnRoaXMuX3Bvc3QodSl9cnVuRWZmZWN0KCl7dGhpcy5ydW5FZmZlY3RJZHx8KHRoaXMucnVuRWZmZWN0SWQ9c2V0VGltZW91dCh0aGlzLmVmZmVjdFJ1blNlbGVjdG9yLmJpbmQodGhpcyksMCkpfXJ1bkFuaW1hdGlvbigpe3RoaXMuYW5pbWF0aW9uSWR8fCh0aGlzLmFuaW1hdGlvbklkPXJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLmFuaW1hdGlvbkRyYXcuYmluZCh0aGlzKSkpfWNvbnN1bWVEcmF3KGUpe3RoaXMuYWN0aXZlV29ya1NoYXBlKGUpLHRoaXMucnVuQW5pbWF0aW9uKCl9Y29uc3VtZUZ1bGwoZSl7dGhpcy5hY3RpdmVXb3JrU2hhcGUoZSksdGhpcy5ydW5BbmltYXRpb24oKX1jbGVhckFsbFdvcmtTaGFwZXNDYWNoZSgpe3RoaXMud29ya1NoYXBlcy5mb3JFYWNoKChlLHQpPT57ZS50b29sc1R5cGU9PT1BdC5MYXNlclBlbj9zZXRUaW1lb3V0KCgpPT57dGhpcy53b3JrU2hhcGVzLmRlbGV0ZSh0KX0sMmUzKTp0aGlzLndvcmtTaGFwZXMuZGVsZXRlKHQpfSl9cnVuU2VsZWN0V29yayhlKXt0aGlzLmFjdGl2ZVNlbGVjdG9yU2hhcGUoZSk7Y29uc3R7d29ya0lkOnR9PWUscj10PT1udWxsP3ZvaWQgMDp0LnRvU3RyaW5nKCk7ciYmdGhpcy53aWxsUnVuRWZmZWN0U2VsZWN0b3JJZHMuYWRkKHIpLHRoaXMucnVuRWZmZWN0KCl9cmVtb3ZlU2VsZWN0V29yayhlKXtjb25zdHt3b3JrSWQ6dH09ZSxyPXQ9PW51bGw/dm9pZCAwOnQudG9TdHJpbmcoKTtyJiYodGhpcy5hY3RpdmVTZWxlY3RvclNoYXBlKGUpLHRoaXMud2lsbFJ1bkVmZmVjdFNlbGVjdG9ySWRzLmFkZChyKSksdGhpcy5ydW5FZmZlY3QoKX1lZmZlY3RSdW5TZWxlY3Rvcigpe3RoaXMucnVuRWZmZWN0SWQ9dm9pZCAwO2xldCBlPXRoaXMubm9BbmltYXRpb25SZWN0O3RoaXMud2lsbFJ1bkVmZmVjdFNlbGVjdG9ySWRzLmZvckVhY2godD0+e3ZhciBkLGc7Y29uc3Qgcj10aGlzLnNlbGVjdG9yV29ya1NoYXBlcy5nZXQodCksbj1yJiZyLnNlbGVjdElkcyYmKChkPXIubm9kZSk9PW51bGw/dm9pZCAwOmQuc2VsZWN0U2VydmljZU5vZGUodCxyLHRoaXMuY3VyTm9kZU1hcCkpO2U9VHQoZSxuKSwoZz1yPT1udWxsP3ZvaWQgMDpyLnNlbGVjdElkcykhPW51bGwmJmcubGVuZ3RofHx0aGlzLnNlbGVjdG9yV29ya1NoYXBlcy5kZWxldGUodCl9KSxlJiZ0aGlzLl9wb3N0KHtyZW5kZXI6W3tyZWN0OmUsZHJhd0NhbnZhczp5dC5CZyxpc0NsZWFyOiEwLGNsZWFyQ2FudmFzOnl0LkJnLGlzRnVsbFdvcms6ITB9XX0pLHRoaXMud2lsbFJ1bkVmZmVjdFNlbGVjdG9ySWRzLmNsZWFyKCksdGhpcy5ub0FuaW1hdGlvblJlY3Q9dm9pZCAwfXJlbW92ZVdvcmsoZSl7Y29uc3R7d29ya0lkOnR9PWUscj10PT1udWxsP3ZvaWQgMDp0LnRvU3RyaW5nKCk7aWYocil7Y29uc3Qgbj10aGlzLndvcmtTaGFwZXMuZ2V0KHIpO2lmKG4pe3RoaXMud29ya1NoYXBlcy5kZWxldGUociksdGhpcy5yZW1vdmVOb2RlKHIsZSxuPT1udWxsP3ZvaWQgMDpuLnRvdGFsUmVjdCwhMSk7cmV0dXJufXRoaXMucmVtb3ZlTm9kZShyLGUpfX1yZW1vdmVOb2RlKGUsdCxyLG49ITApe3ZhciBvO2NvbnN0IGQ9dGhpcy5mdWxsTGF5ZXIuZ2V0RWxlbWVudHNCeU5hbWUoZSkuY29uY2F0KChvPXRoaXMuZHJhd0xheWVyKT09bnVsbD92b2lkIDA6by5nZXRFbGVtZW50c0J5TmFtZShlKSk7ZS5pbmRleE9mKHZ0LnNlbGVjdG9ySWQpPi0xJiZ0aGlzLnJlbW92ZVNlbGVjdFdvcmsodCk7Y29uc3QgZz1bXTtsZXQgdT1yO2QuZm9yRWFjaChmPT57Y29uc3QgeD1mLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO3U9VHQodSx7eDpNYXRoLmZsb29yKHgueC0xMCkseTpNYXRoLmZsb29yKHgueS0xMCksdzpNYXRoLmZsb29yKHgud2lkdGgrMjApLGg6TWF0aC5mbG9vcih4LmhlaWdodCsyMCl9KSxnLnB1c2goZil9KSxnLmxlbmd0aCYmZy5mb3JFYWNoKGY9PmYucmVtb3ZlKCkpLHUmJih0aGlzLl9wb3N0KHtyZW5kZXI6W3tyZWN0OnUsaXNDbGVhcjohMCxpc0Z1bGxXb3JrOm4sY2xlYXJDYW52YXM6bj95dC5CZzp5dC5GbG9hdCxkcmF3Q2FudmFzOm4/eXQuQmc6eXQuRmxvYXR9XX0pLHRoaXMuY3VyTm9kZU1hcC5kZWxldGUoZSkpfWdldE5vZGVSZWN0KGUpe2xldCB0O3JldHVybiB0aGlzLmZ1bGxMYXllci5nZXRFbGVtZW50c0J5TmFtZShlKS5mb3JFYWNoKHI9Pntjb25zdCBuPXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksZD1NYXRoLmZsb29yKG4ubGVmdC1CdC5QZW5jaWxCb3JkZXJQYWRkaW5nKSxnPU1hdGguZmxvb3Iobi50b3AtQnQuUGVuY2lsQm9yZGVyUGFkZGluZyksdT1NYXRoLmNlaWwobi53aWR0aCtCdC5QZW5jaWxCb3JkZXJQYWRkaW5nKjIpLG89TWF0aC5jZWlsKG4uaGVpZ2h0K0J0LlBlbmNpbEJvcmRlclBhZGRpbmcqMik7dD1UdCh0LHt4OmQseTpnLHc6dSxoOm99KX0pLHR9cnVuUmV2ZXJzZVNlbGVjdFdvcmsoZSl7ZS5mb3JFYWNoKHQ9Pnt0aGlzLnNlbGVjdG9yV29ya1NoYXBlcy5mb3JFYWNoKChyLG4pPT57dmFyIGQ7aWYoKGQ9ci5zZWxlY3RJZHMpIT1udWxsJiZkLmxlbmd0aCl7Y29uc3QgZz1yLnNlbGVjdElkcy5pbmRleE9mKHQpO2c+LTEmJihyLnNlbGVjdElkcy5zcGxpY2UoZywxKSx0aGlzLndpbGxSdW5FZmZlY3RTZWxlY3Rvcklkcy5hZGQobikpfX0pfSksdGhpcy53aWxsUnVuRWZmZWN0U2VsZWN0b3JJZHMuc2l6ZSYmdGhpcy5ydW5FZmZlY3QoKX19Y2xhc3MgUXR7Y29uc3RydWN0b3IoKXtPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywibG9jYWxXb3JrIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInNlcnZpY2VXb3JrIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSl9cmVnaXN0ZXJGb3JXb3JrZXIoZSx0KXtyZXR1cm4gdGhpcy5sb2NhbFdvcms9ZSx0aGlzLnNlcnZpY2VXb3JrPXQsdGhpc319Y2xhc3MgX24gZXh0ZW5kcyBRdHtjb25zdHJ1Y3Rvcigpe3N1cGVyKC4uLmFyZ3VtZW50cyksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImVtaXRFdmVudFR5cGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpidC5aSW5kZXhBY3RpdmV9KX1jb25zdW1lKGUpe2NvbnN0e21zZ1R5cGU6dCxkYXRhVHlwZTpyLGVtaXRFdmVudFR5cGU6bn09ZTtpZih0PT09cHQuVXBkYXRlTm9kZSYmcj09PVN0LkxvY2FsJiZuPT09dGhpcy5lbWl0RXZlbnRUeXBlKXJldHVybiB0aGlzLmNvbnN1bWVGb3JMb2NhbFdvcmtlcihlKSwhMH1jb25zdW1lRm9yTG9jYWxXb3JrZXIoZSl7dmFyIHUsbyxmLHgsYztjb25zdHt3b3JrSWQ6dCxpc0FjdGl2ZVpJbmRleDpyLHdpbGxSZWZyZXNoU2VsZWN0b3I6bn09ZTtpZih0IT09dnQuc2VsZWN0b3JJZClyZXR1cm47Y29uc3QgZD0odT10aGlzLmxvY2FsV29yayk9PW51bGw/dm9pZCAwOnUud29ya1NoYXBlcy5nZXQodnQuc2VsZWN0b3JJZCk7aWYoIWQpcmV0dXJuO2NvbnN0IGc9ZC5vbGRTZWxlY3RSZWN0O2lmKHImJmcmJnRoaXMubG9jYWxXb3JrKXtjb25zdCB2PW5ldyBTZXQ7aWYodGhpcy5sb2NhbFdvcmsuY3VyTm9kZU1hcC5mb3JFYWNoKChwLGIpPT57bWUoZyxwLnJlY3QpJiZ2LmFkZChiKX0pLHYuc2l6ZSl7Y29uc3QgcD1bXTt2LmZvckVhY2goYj0+e3ZhciBFOyhFPXRoaXMubG9jYWxXb3JrKT09bnVsbHx8RS5mdWxsTGF5ZXIuZ2V0RWxlbWVudHNCeU5hbWUoYikuZm9yRWFjaCh5PT57dmFyIGksYTtjb25zdCBNPXkuY2xvbmVOb2RlKCEwKTtpZihNLnRhZ05hbWU9PT0iR1JPVVAiKXtjb25zdCBzPXkuY2xhc3NOYW1lLnNwbGl0KCIsIik7cy5sZW5ndGg9PT0zJiZOdW1iZXIoc1syXSk9PT1EdC5TdHJva2UmJk0uc2VhbCgpfShhPShpPXRoaXMubG9jYWxXb3JrKT09bnVsbD92b2lkIDA6aS5kcmF3TGF5ZXIpIT1udWxsJiZhLmdldEVsZW1lbnRzQnlOYW1lKGIpLmxlbmd0aHx8cC5wdXNoKE0pfSl9KSxwLmxlbmd0aCYmKChvPXRoaXMubG9jYWxXb3JrLmRyYXdMYXllcik9PW51bGx8fG8uYXBwZW5kKC4uLnApKX19ZWxzZSh4PShmPXRoaXMubG9jYWxXb3JrKT09bnVsbD92b2lkIDA6Zi5kcmF3TGF5ZXIpPT1udWxsfHx4LmNoaWxkcmVuLmZpbHRlcih2PT57dmFyIHA7cmV0dXJuISgocD1kLnNlbGVjdElkcykhPW51bGwmJnAuaW5jbHVkZXModi5uYW1lKSl9KS5mb3JFYWNoKHY9PnYucmVtb3ZlKCkpO24mJigoYz10aGlzLmxvY2FsV29yayk9PW51bGx8fGMuX3Bvc3Qoe3JlbmRlcjpbe3JlY3Q6ZyxkcmF3Q2FudmFzOnl0LlNlbGVjdG9yLGNsZWFyQ2FudmFzOnl0LlNlbGVjdG9yLGlzQ2xlYXI6ITAsaXNGdWxsV29yazohMX1dLHNwOlt7dHlwZTpwdC5TZWxlY3Qsc2VsZWN0SWRzOmQuc2VsZWN0SWRzLG9wdDpkLmdldFdvcmtPcHRpb25zKCkscGFkZGluZzp2dC5TZWxlY3RCb3JkZXJQYWRkaW5nLHNlbGVjdFJlY3Q6Zyxub2RlQ29sb3I6ZC5ub2RlQ29sb3Isd2lsbFN5bmNTZXJ2aWNlOiExLGlzU3luYzohMH1dfSkpfX1jbGFzcyB0aSBleHRlbmRzIFF0e2NvbnN0cnVjdG9yKCl7c3VwZXIoLi4uYXJndW1lbnRzKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiZW1pdEV2ZW50VHlwZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOmJ0LkNvcHlOb2RlfSl9Y29uc3VtZShlKXtjb25zdHttc2dUeXBlOnQsZGF0YVR5cGU6cixlbWl0RXZlbnRUeXBlOm59PWU7aWYodD09PXB0LkZ1bGxXb3JrJiZyPT09U3QuTG9jYWwmJm49PT10aGlzLmVtaXRFdmVudFR5cGUpcmV0dXJuIHRoaXMuY29uc3VtZUZvckxvY2FsV29ya2VyKGUpLCEwfWNvbnN1bWVGb3JMb2NhbFdvcmtlcihlKXt2YXIgcjtjb25zdHt3b3JrSWQ6dH09ZTt0JiYoKHI9dGhpcy5sb2NhbFdvcmspPT1udWxsfHxyLmNvbnN1bWVGdWxsKGUpKX19Y2xhc3MgZWkgZXh0ZW5kcyBRdHtjb25zdHJ1Y3Rvcigpe3N1cGVyKC4uLmFyZ3VtZW50cyksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImVtaXRFdmVudFR5cGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpidC5TZXRDb2xvck5vZGV9KX1jb25zdW1lKGUpe2NvbnN0e21zZ1R5cGU6dCxkYXRhVHlwZTpyLGVtaXRFdmVudFR5cGU6bix1bmRvVGlja2VySWQ6ZH09ZTtpZih0PT09cHQuVXBkYXRlTm9kZSYmcj09PVN0LkxvY2FsJiZuPT09dGhpcy5lbWl0RXZlbnRUeXBlKXJldHVybiB0aGlzLmNvbnN1bWVGb3JMb2NhbFdvcmtlcihlKSxkJiZzZXRUaW1lb3V0KCgpPT57dmFyIGc7KGc9dGhpcy5sb2NhbFdvcmspPT1udWxsfHxnLl9wb3N0KHtzcDpbe3R5cGU6cHQuTm9uZSx1bmRvVGlja2VySWQ6ZH1dfSl9LDApLCEwfWNvbnN1bWVGb3JMb2NhbFdvcmtlcihlKXt2YXIgZix4O2NvbnN0e3dvcmtJZDp0LHVwZGF0ZU5vZGVPcHQ6cix3aWxsUmVmcmVzaFNlbGVjdG9yOm4sd2lsbFN5bmNTZXJ2aWNlOmQsd2lsbFJlZnJlc2g6ZyxzZWxlY3RTdG9yZTp1LHdpbGxTZXJpYWxpemVEYXRhOm99PWU7dD09PXZ0LnNlbGVjdG9ySWQmJnI/KGY9dGhpcy5sb2NhbFdvcmspPT1udWxsfHxmLnVwZGF0ZVNlbGVjdG9yKHt1cGRhdGVTZWxlY3Rvck9wdDpyLHdpbGxSZWZyZXNoU2VsZWN0b3I6bix3aWxsU3luY1NlcnZpY2U6ZCxzZWxlY3RTdG9yZTp1LHdpbGxTZXJpYWxpemVEYXRhOm99KTp0JiZyJiYoKHg9dGhpcy5sb2NhbFdvcmspPT1udWxsfHx4LnVwZGF0ZU5vZGUoe3dvcmtJZDp0LHVwZGF0ZU5vZGVPcHQ6cix3aWxsUmVmcmVzaDpnLHdpbGxTeW5jU2VydmljZTpkfSkpfX1jbGFzcyByaSBleHRlbmRzIFF0e2NvbnN0cnVjdG9yKCl7c3VwZXIoLi4uYXJndW1lbnRzKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiZW1pdEV2ZW50VHlwZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOmJ0LlpJbmRleE5vZGV9KX1jb25zdW1lKGUpe2NvbnN0e21zZ1R5cGU6dCxkYXRhVHlwZTpyLGVtaXRFdmVudFR5cGU6bn09ZTtpZih0PT09cHQuVXBkYXRlTm9kZSYmcj09PVN0LkxvY2FsJiZuPT09dGhpcy5lbWl0RXZlbnRUeXBlKXJldHVybiB0aGlzLmNvbnN1bWVGb3JMb2NhbFdvcmtlcihlKSwhMH1jb25zdW1lRm9yTG9jYWxXb3JrZXIoZSl7dmFyIGYseDtjb25zdHt3b3JrSWQ6dCx1cGRhdGVOb2RlT3B0OnIsd2lsbFJlZnJlc2hTZWxlY3RvcjpuLHdpbGxTeW5jU2VydmljZTpkLHdpbGxSZWZyZXNoOmcsc2VsZWN0U3RvcmU6dSx3aWxsU2VyaWFsaXplRGF0YTpvfT1lO3Q9PT12dC5zZWxlY3RvcklkJiZyPyhmPXRoaXMubG9jYWxXb3JrKT09bnVsbHx8Zi51cGRhdGVTZWxlY3Rvcih7dXBkYXRlU2VsZWN0b3JPcHQ6cix3aWxsUmVmcmVzaFNlbGVjdG9yOm4sd2lsbFN5bmNTZXJ2aWNlOmQsc2VsZWN0U3RvcmU6dSx3aWxsU2VyaWFsaXplRGF0YTpvfSk6dCYmciYmKCh4PXRoaXMubG9jYWxXb3JrKT09bnVsbHx8eC51cGRhdGVOb2RlKHt3b3JrSWQ6dCx1cGRhdGVOb2RlT3B0OnIsd2lsbFJlZnJlc2g6Zyx3aWxsU3luY1NlcnZpY2U6ZH0pKX19Y2xhc3MgbmkgZXh0ZW5kcyBRdHtjb25zdHJ1Y3Rvcigpe3N1cGVyKC4uLmFyZ3VtZW50cyksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImVtaXRFdmVudFR5cGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpidC5UcmFuc2xhdGVOb2RlfSl9Y29uc3VtZShlKXtjb25zdHttc2dUeXBlOnQsZGF0YVR5cGU6cixlbWl0RXZlbnRUeXBlOm4sdW5kb1RpY2tlcklkOmR9PWU7aWYodD09PXB0LlVwZGF0ZU5vZGUmJnI9PT1TdC5Mb2NhbCYmbj09PXRoaXMuZW1pdEV2ZW50VHlwZSlyZXR1cm4gdGhpcy5jb25zdW1lRm9yTG9jYWxXb3JrZXIoZSksZCYmc2V0VGltZW91dCgoKT0+e3ZhciBnOyhnPXRoaXMubG9jYWxXb3JrKT09bnVsbHx8Zy5fcG9zdCh7c3A6W3t0eXBlOnB0Lk5vbmUsdW5kb1RpY2tlcklkOmR9XX0pfSwwKSwhMH1jb25zdW1lRm9yTG9jYWxXb3JrZXIoZSl7dmFyIGYseDtjb25zdHt3b3JrSWQ6dCx1cGRhdGVOb2RlT3B0OnIsd2lsbFJlZnJlc2hTZWxlY3RvcjpuLHdpbGxTeW5jU2VydmljZTpkLHdpbGxSZWZyZXNoOmcsc2VsZWN0U3RvcmU6dSx3aWxsU2VyaWFsaXplRGF0YTpvfT1lO3Q9PT12dC5zZWxlY3RvcklkJiZyPyhmPXRoaXMubG9jYWxXb3JrKT09bnVsbHx8Zi51cGRhdGVTZWxlY3Rvcih7dXBkYXRlU2VsZWN0b3JPcHQ6cix3aWxsUmVmcmVzaFNlbGVjdG9yOm4sd2lsbFN5bmNTZXJ2aWNlOmQsc2VsZWN0U3RvcmU6dSx3aWxsU2VyaWFsaXplRGF0YTpvLGlzU3luYzohMH0pOnQmJnImJigoeD10aGlzLmxvY2FsV29yayk9PW51bGx8fHgudXBkYXRlTm9kZSh7d29ya0lkOnQsdXBkYXRlTm9kZU9wdDpyLHdpbGxSZWZyZXNoOmcsd2lsbFN5bmNTZXJ2aWNlOmR9KSl9fWNsYXNzIGlpIGV4dGVuZHMgUXR7Y29uc3RydWN0b3IoKXtzdXBlciguLi5hcmd1bWVudHMpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJlbWl0RXZlbnRUeXBlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6YnQuRGVsZXRlTm9kZX0pfWNvbnN1bWUoZSl7Y29uc3R7bXNnVHlwZTp0LGRhdGFUeXBlOnIsZW1pdEV2ZW50VHlwZTpufT1lO2lmKHQ9PT1wdC5SZW1vdmVOb2RlKXtpZihyPT09U3QuTG9jYWwmJm49PT10aGlzLmVtaXRFdmVudFR5cGUpcmV0dXJuIHRoaXMuY29uc3VtZUZvckxvY2FsV29ya2VyKGUpLCEwO2lmKHI9PT1TdC5TZXJ2aWNlJiZuPT09dGhpcy5lbWl0RXZlbnRUeXBlKXJldHVybiB0aGlzLmNvbnN1bWVGb3JTZXJ2aWNlV29ya2VyKGUpLCEwfX1jb25zdW1lRm9yTG9jYWxXb3JrZXIoZSl7dmFyIGcsdSxvLGYseDtpZighdGhpcy5sb2NhbFdvcmspcmV0dXJuO2NvbnN0e3dvcmtJZDp0LHdpbGxSZWZyZXNoOnJ9PWU7aWYoIXQpcmV0dXJuO2xldCBuO2NvbnN0IGQ9dGhpcy5sb2NhbFdvcmsud29ya1NoYXBlcy5nZXQodCk7aWYoZCYmdD09PXZ0LnNlbGVjdG9ySWQpe2NvbnN0IGM9ZC5zZWxlY3RJZHM7Yz09bnVsbHx8Yy5mb3JFYWNoKHY9Pnt2YXIgcCxiLEU7KGI9KHA9dGhpcy5sb2NhbFdvcmspPT1udWxsP3ZvaWQgMDpwLmRyYXdMYXllcik9PW51bGx8fGIuZ2V0RWxlbWVudHNCeU5hbWUodikuZm9yRWFjaCh5PT57eS5yZW1vdmUoKX0pLChFPXRoaXMubG9jYWxXb3JrKT09bnVsbHx8RS5jdXJOb2RlTWFwLmRlbGV0ZSh2KX0pLG49ZC5vbGRSZWN0LChvPSh1PShnPXRoaXMubG9jYWxXb3JrLmRyYXdMYXllcik9PW51bGw/dm9pZCAwOmcucGFyZW50KT09bnVsbD92b2lkIDA6dS5nZXRFbGVtZW50QnlJZCh2dC5zZWxlY3RvcklkKSk9PW51bGx8fG8ucmVtb3ZlKCksdGhpcy5sb2NhbFdvcmsud29ya1NoYXBlcy5kZWxldGUodnQuc2VsZWN0b3JJZCl9ZWxzZSBpZih0KXtjb25zdCBjPXQudG9TdHJpbmcoKTtsZXQgdj1YdChjLHRoaXMubG9jYWxXb3JrLmZ1bGxMYXllcik7diYmdGhpcy5sb2NhbFdvcmsuZnVsbExheWVyLmdldEVsZW1lbnRzQnlOYW1lKGMpLmZvckVhY2goYj0+Yi5yZW1vdmUoKSk7Y29uc3QgcD1YdChjLHRoaXMubG9jYWxXb3JrLmRyYXdMYXllcik7cCYmKHY9VHQodixwKSwoZj10aGlzLmxvY2FsV29yay5kcmF3TGF5ZXIpPT1udWxsfHxmLmdldEVsZW1lbnRzQnlOYW1lKGMpLmZvckVhY2goYj0+Yi5yZW1vdmUoKSkpLHYmJih2PWNuKHYpKSwoeD10aGlzLmxvY2FsV29yayk9PW51bGx8fHguY3VyTm9kZU1hcC5kZWxldGUoYyl9biYmciYmdGhpcy5sb2NhbFdvcmsuX3Bvc3Qoe3JlbmRlcjpbe3JlY3Q6bixkcmF3Q2FudmFzOnl0LkJnLGNsZWFyQ2FudmFzOnl0LkJnLGlzQ2xlYXI6ITAsaXNGdWxsV29yazohMH1dfSl9Y29uc3VtZUZvclNlcnZpY2VXb3JrZXIoZSl7dGhpcy5zZXJ2aWNlV29yayYmdGhpcy5zZXJ2aWNlV29yay5yZW1vdmVTZWxlY3RXb3JrKGUpfX1jbGFzcyBzaSBleHRlbmRzIFF0e2NvbnN0cnVjdG9yKCl7c3VwZXIoLi4uYXJndW1lbnRzKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiZW1pdEV2ZW50VHlwZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOmJ0LlNjYWxlTm9kZX0pfWNvbnN1bWUoZSl7Y29uc3R7bXNnVHlwZTp0LGRhdGFUeXBlOnIsZW1pdEV2ZW50VHlwZTpuLHVuZG9UaWNrZXJJZDpkfT1lO2lmKHQ9PT1wdC5VcGRhdGVOb2RlJiZyPT09U3QuTG9jYWwmJm49PT10aGlzLmVtaXRFdmVudFR5cGUpcmV0dXJuIHRoaXMuY29uc3VtZUZvckxvY2FsV29ya2VyKGUpLGQmJnNldFRpbWVvdXQoKCk9Pnt2YXIgZzsoZz10aGlzLmxvY2FsV29yayk9PW51bGx8fGcuX3Bvc3Qoe3NwOlt7dHlwZTpwdC5Ob25lLHVuZG9UaWNrZXJJZDpkfV19KX0sMCksITB9Y29uc3VtZUZvckxvY2FsV29ya2VyKGUpe3ZhciBmLHg7Y29uc3R7d29ya0lkOnQsdXBkYXRlTm9kZU9wdDpyLHdpbGxSZWZyZXNoU2VsZWN0b3I6bix3aWxsU3luY1NlcnZpY2U6ZCx3aWxsUmVmcmVzaDpnLHNlbGVjdFN0b3JlOnUsd2lsbFNlcmlhbGl6ZURhdGE6b309ZTt0PT09dnQuc2VsZWN0b3JJZCYmcj8oZj10aGlzLmxvY2FsV29yayk9PW51bGx8fGYudXBkYXRlU2VsZWN0b3Ioe3VwZGF0ZVNlbGVjdG9yT3B0OnIsd2lsbFJlZnJlc2hTZWxlY3RvcjpuLHdpbGxTeW5jU2VydmljZTpkLGVtaXRFdmVudFR5cGU6dGhpcy5lbWl0RXZlbnRUeXBlLHNlbGVjdFN0b3JlOnUsd2lsbFNlcmlhbGl6ZURhdGE6byxpc1N5bmM6ITB9KTp0JiZyJiYoKHg9dGhpcy5sb2NhbFdvcmspPT1udWxsfHx4LnVwZGF0ZU5vZGUoe3dvcmtJZDp0LHVwZGF0ZU5vZGVPcHQ6cix3aWxsUmVmcmVzaDpnLHdpbGxTeW5jU2VydmljZTpkfSkpfX1jbGFzcyBvaSBleHRlbmRzIFF0e2NvbnN0cnVjdG9yKCl7c3VwZXIoLi4uYXJndW1lbnRzKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiZW1pdEV2ZW50VHlwZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOmJ0LlJvdGF0ZU5vZGV9KX1jb25zdW1lKGUpe2NvbnN0e21zZ1R5cGU6dCxkYXRhVHlwZTpyLGVtaXRFdmVudFR5cGU6bix1bmRvVGlja2VySWQ6ZH09ZTtpZih0PT09cHQuVXBkYXRlTm9kZSYmcj09PVN0LkxvY2FsJiZuPT09dGhpcy5lbWl0RXZlbnRUeXBlKXJldHVybiB0aGlzLmNvbnN1bWVGb3JMb2NhbFdvcmtlcihlKSxkJiZzZXRUaW1lb3V0KCgpPT57dmFyIGc7KGc9dGhpcy5sb2NhbFdvcmspPT1udWxsfHxnLl9wb3N0KHtzcDpbe3R5cGU6cHQuTm9uZSx1bmRvVGlja2VySWQ6ZH1dfSl9LDApLCEwfWNvbnN1bWVGb3JMb2NhbFdvcmtlcihlKXt2YXIgeCxjO2NvbnN0e3dvcmtJZDp0LHVwZGF0ZU5vZGVPcHQ6cix3aWxsUmVmcmVzaFNlbGVjdG9yOm4sd2lsbFN5bmNTZXJ2aWNlOmQsd2lsbFJlZnJlc2g6ZyxzZWxlY3RTdG9yZTp1LHdpbGxTZXJpYWxpemVEYXRhOm8sZW1pdEV2ZW50VHlwZTpmfT1lO3Q9PT12dC5zZWxlY3RvcklkJiZyPyh4PXRoaXMubG9jYWxXb3JrKT09bnVsbHx8eC51cGRhdGVTZWxlY3Rvcih7dXBkYXRlU2VsZWN0b3JPcHQ6cix3aWxsUmVmcmVzaFNlbGVjdG9yOm4sd2lsbFN5bmNTZXJ2aWNlOmQsc2VsZWN0U3RvcmU6dSx3aWxsU2VyaWFsaXplRGF0YTpvLGVtaXRFdmVudFR5cGU6Zixpc1N5bmM6ITB9KTp0JiZyJiYoKGM9dGhpcy5sb2NhbFdvcmspPT1udWxsfHxjLnVwZGF0ZU5vZGUoe3dvcmtJZDp0LHVwZGF0ZU5vZGVPcHQ6cix3aWxsUmVmcmVzaDpnLHdpbGxTeW5jU2VydmljZTpkfSkpfX1jbGFzcyBhaXtjb25zdHJ1Y3RvcihlKXtPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiYnVpbGRlcnMiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpuZXcgTWFwfSksdGhpcy5idWlsZGVycz1uZXcgTWFwKGUubWFwKHQ9Plt0LHRoaXMuYnVpbGQodCldKSl9YnVpbGQoZSl7c3dpdGNoKGUpe2Nhc2UgYnQuVHJhbnNsYXRlTm9kZTpyZXR1cm4gbmV3IG5pO2Nhc2UgYnQuWkluZGV4Tm9kZTpyZXR1cm4gbmV3IHJpO2Nhc2UgYnQuWkluZGV4QWN0aXZlOnJldHVybiBuZXcgX247Y2FzZSBidC5Db3B5Tm9kZTpyZXR1cm4gbmV3IHRpO2Nhc2UgYnQuU2V0Q29sb3JOb2RlOnJldHVybiBuZXcgZWk7Y2FzZSBidC5EZWxldGVOb2RlOnJldHVybiBuZXcgaWk7Y2FzZSBidC5TY2FsZU5vZGU6cmV0dXJuIG5ldyBzaTtjYXNlIGJ0LlJvdGF0ZU5vZGU6cmV0dXJuIG5ldyBvaX19cmVnaXN0ZXJGb3JXb3JrZXIoZSx0KXtyZXR1cm4gdGhpcy5idWlsZGVycy5mb3JFYWNoKHI9PntyJiZyLnJlZ2lzdGVyRm9yV29ya2VyKGUsdCl9KSx0aGlzfWNvbnN1bWVGb3JXb3JrZXIoZSl7Zm9yKGNvbnN0IHQgb2YgdGhpcy5idWlsZGVycy52YWx1ZXMoKSlpZih0IT1udWxsJiZ0LmNvbnN1bWUoZSkpcmV0dXJuITA7cmV0dXJuITF9fWZ1bmN0aW9uIGxpKCl7dGhpcy5fX2RhdGFfXz1bXSx0aGlzLnNpemU9MH12YXIgZmk9bGk7ZnVuY3Rpb24gY2koaCxlKXtyZXR1cm4gaD09PWV8fGghPT1oJiZlIT09ZX12YXIgbXI9Y2ksdWk9bXI7ZnVuY3Rpb24gaGkoaCxlKXtmb3IodmFyIHQ9aC5sZW5ndGg7dC0tOylpZih1aShoW3RdWzBdLGUpKXJldHVybiB0O3JldHVybi0xfXZhciBFZT1oaSxkaT1FZSxnaT1BcnJheS5wcm90b3R5cGUsbWk9Z2kuc3BsaWNlO2Z1bmN0aW9uIHZpKGgpe3ZhciBlPXRoaXMuX19kYXRhX18sdD1kaShlLGgpO2lmKHQ8MClyZXR1cm4hMTt2YXIgcj1lLmxlbmd0aC0xO3JldHVybiB0PT1yP2UucG9wKCk6bWkuY2FsbChlLHQsMSksLS10aGlzLnNpemUsITB9dmFyIHlpPXZpLHBpPUVlO2Z1bmN0aW9uIHhpKGgpe3ZhciBlPXRoaXMuX19kYXRhX18sdD1waShlLGgpO3JldHVybiB0PDA/dm9pZCAwOmVbdF1bMV19dmFyIE1pPXhpLEVpPUVlO2Z1bmN0aW9uIE9pKGgpe3JldHVybiBFaSh0aGlzLl9fZGF0YV9fLGgpPi0xfXZhciBUaT1PaSxQaT1FZTtmdW5jdGlvbiBBaShoLGUpe3ZhciB0PXRoaXMuX19kYXRhX18scj1QaSh0LGgpO3JldHVybiByPDA/KCsrdGhpcy5zaXplLHQucHVzaChbaCxlXSkpOnRbcl1bMV09ZSx0aGlzfXZhciBTaT1BaSxiaT1maSxDaT15aSxSaT1NaSxMaT1UaSxEaT1TaTtmdW5jdGlvbiBpZShoKXt2YXIgZT0tMSx0PWg9PW51bGw/MDpoLmxlbmd0aDtmb3IodGhpcy5jbGVhcigpOysrZTx0Oyl7dmFyIHI9aFtlXTt0aGlzLnNldChyWzBdLHJbMV0pfX1pZS5wcm90b3R5cGUuY2xlYXI9YmksaWUucHJvdG90eXBlLmRlbGV0ZT1DaSxpZS5wcm90b3R5cGUuZ2V0PVJpLGllLnByb3RvdHlwZS5oYXM9TGksaWUucHJvdG90eXBlLnNldD1EaTt2YXIgT2U9aWUsSWk9T2U7ZnVuY3Rpb24gTmkoKXt0aGlzLl9fZGF0YV9fPW5ldyBJaSx0aGlzLnNpemU9MH12YXIgQmk9Tmk7ZnVuY3Rpb24gamkoaCl7dmFyIGU9dGhpcy5fX2RhdGFfXyx0PWUuZGVsZXRlKGgpO3JldHVybiB0aGlzLnNpemU9ZS5zaXplLHR9dmFyIFdpPWppO2Z1bmN0aW9uIEZpKGgpe3JldHVybiB0aGlzLl9fZGF0YV9fLmdldChoKX12YXIgVWk9Rmk7ZnVuY3Rpb24gJGkoaCl7cmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKGgpfXZhciB6aT0kaTtmdW5jdGlvbiB3aShoKXt2YXIgZT10eXBlb2YgaDtyZXR1cm4gaCE9bnVsbCYmKGU9PSJvYmplY3QifHxlPT0iZnVuY3Rpb24iKX12YXIgdWU9d2ksR2k9Y2UsS2k9dWUsSGk9IltvYmplY3QgQXN5bmNGdW5jdGlvbl0iLFZpPSJbb2JqZWN0IEZ1bmN0aW9uXSIsWWk9IltvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dIixYaT0iW29iamVjdCBQcm94eV0iO2Z1bmN0aW9uIEppKGgpe2lmKCFLaShoKSlyZXR1cm4hMTt2YXIgZT1HaShoKTtyZXR1cm4gZT09Vml8fGU9PVlpfHxlPT1IaXx8ZT09WGl9dmFyIHZyPUppLFppPUp0LFFpPVppWyJfX2NvcmUtanNfc2hhcmVkX18iXSxxaT1RaSxGZT1xaSx5cj1mdW5jdGlvbigpe3ZhciBoPS9bXi5dKyQvLmV4ZWMoRmUmJkZlLmtleXMmJkZlLmtleXMuSUVfUFJPVE98fCIiKTtyZXR1cm4gaD8iU3ltYm9sKHNyYylfMS4iK2g6IiJ9KCk7ZnVuY3Rpb24ga2koaCl7cmV0dXJuISF5ciYmeXIgaW4gaH12YXIgX2k9a2ksdHM9RnVuY3Rpb24ucHJvdG90eXBlLGVzPXRzLnRvU3RyaW5nO2Z1bmN0aW9uIHJzKGgpe2lmKGghPW51bGwpe3RyeXtyZXR1cm4gZXMuY2FsbChoKX1jYXRjaHt9dHJ5e3JldHVybiBoKyIifWNhdGNoe319cmV0dXJuIiJ9dmFyIHByPXJzLG5zPXZyLGlzPV9pLHNzPXVlLG9zPXByLGFzPS9bXFxeJC4qKz8oKVtcXXt9fF0vZyxscz0vXlxbb2JqZWN0IC4rP0NvbnN0cnVjdG9yXF0kLyxmcz1GdW5jdGlvbi5wcm90b3R5cGUsY3M9T2JqZWN0LnByb3RvdHlwZSx1cz1mcy50b1N0cmluZyxocz1jcy5oYXNPd25Qcm9wZXJ0eSxkcz1SZWdFeHAoIl4iK3VzLmNhbGwoaHMpLnJlcGxhY2UoYXMsIlxcJCYiKS5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcKCl8IGZvciAuKz8oPz1cXFxdKS9nLCIkMS4qPyIpKyIkIik7ZnVuY3Rpb24gZ3MoaCl7aWYoIXNzKGgpfHxpcyhoKSlyZXR1cm4hMTt2YXIgZT1ucyhoKT9kczpscztyZXR1cm4gZS50ZXN0KG9zKGgpKX12YXIgbXM9Z3M7ZnVuY3Rpb24gdnMoaCxlKXtyZXR1cm4gaD09bnVsbD92b2lkIDA6aFtlXX12YXIgeXM9dnMscHM9bXMseHM9eXM7ZnVuY3Rpb24gTXMoaCxlKXt2YXIgdD14cyhoLGUpO3JldHVybiBwcyh0KT90OnZvaWQgMH12YXIgcXQ9TXMsRXM9cXQsT3M9SnQsVHM9RXMoT3MsIk1hcCIpLFVlPVRzLFBzPXF0LEFzPVBzKE9iamVjdCwiY3JlYXRlIiksVGU9QXMseHI9VGU7ZnVuY3Rpb24gU3MoKXt0aGlzLl9fZGF0YV9fPXhyP3hyKG51bGwpOnt9LHRoaXMuc2l6ZT0wfXZhciBicz1TcztmdW5jdGlvbiBDcyhoKXt2YXIgZT10aGlzLmhhcyhoKSYmZGVsZXRlIHRoaXMuX19kYXRhX19baF07cmV0dXJuIHRoaXMuc2l6ZS09ZT8xOjAsZX12YXIgUnM9Q3MsTHM9VGUsRHM9Il9fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18iLElzPU9iamVjdC5wcm90b3R5cGUsTnM9SXMuaGFzT3duUHJvcGVydHk7ZnVuY3Rpb24gQnMoaCl7dmFyIGU9dGhpcy5fX2RhdGFfXztpZihMcyl7dmFyIHQ9ZVtoXTtyZXR1cm4gdD09PURzP3ZvaWQgMDp0fXJldHVybiBOcy5jYWxsKGUsaCk/ZVtoXTp2b2lkIDB9dmFyIGpzPUJzLFdzPVRlLEZzPU9iamVjdC5wcm90b3R5cGUsVXM9RnMuaGFzT3duUHJvcGVydHk7ZnVuY3Rpb24gJHMoaCl7dmFyIGU9dGhpcy5fX2RhdGFfXztyZXR1cm4gV3M/ZVtoXSE9PXZvaWQgMDpVcy5jYWxsKGUsaCl9dmFyIHpzPSRzLHdzPVRlLEdzPSJfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fIjtmdW5jdGlvbiBLcyhoLGUpe3ZhciB0PXRoaXMuX19kYXRhX187cmV0dXJuIHRoaXMuc2l6ZSs9dGhpcy5oYXMoaCk/MDoxLHRbaF09d3MmJmU9PT12b2lkIDA/R3M6ZSx0aGlzfXZhciBIcz1LcyxWcz1icyxZcz1ScyxYcz1qcyxKcz16cyxacz1IcztmdW5jdGlvbiBzZShoKXt2YXIgZT0tMSx0PWg9PW51bGw/MDpoLmxlbmd0aDtmb3IodGhpcy5jbGVhcigpOysrZTx0Oyl7dmFyIHI9aFtlXTt0aGlzLnNldChyWzBdLHJbMV0pfX1zZS5wcm90b3R5cGUuY2xlYXI9VnMsc2UucHJvdG90eXBlLmRlbGV0ZT1ZcyxzZS5wcm90b3R5cGUuZ2V0PVhzLHNlLnByb3RvdHlwZS5oYXM9SnMsc2UucHJvdG90eXBlLnNldD1aczt2YXIgUXM9c2UsTXI9UXMscXM9T2Usa3M9VWU7ZnVuY3Rpb24gX3MoKXt0aGlzLnNpemU9MCx0aGlzLl9fZGF0YV9fPXtoYXNoOm5ldyBNcixtYXA6bmV3KGtzfHxxcyksc3RyaW5nOm5ldyBNcn19dmFyIHRvPV9zO2Z1bmN0aW9uIGVvKGgpe3ZhciBlPXR5cGVvZiBoO3JldHVybiBlPT0ic3RyaW5nInx8ZT09Im51bWJlciJ8fGU9PSJzeW1ib2wifHxlPT0iYm9vbGVhbiI/aCE9PSJfX3Byb3RvX18iOmg9PT1udWxsfXZhciBybz1lbyxubz1ybztmdW5jdGlvbiBpbyhoLGUpe3ZhciB0PWguX19kYXRhX187cmV0dXJuIG5vKGUpP3RbdHlwZW9mIGU9PSJzdHJpbmciPyJzdHJpbmciOiJoYXNoIl06dC5tYXB9dmFyIFBlPWlvLHNvPVBlO2Z1bmN0aW9uIG9vKGgpe3ZhciBlPXNvKHRoaXMsaCkuZGVsZXRlKGgpO3JldHVybiB0aGlzLnNpemUtPWU/MTowLGV9dmFyIGFvPW9vLGxvPVBlO2Z1bmN0aW9uIGZvKGgpe3JldHVybiBsbyh0aGlzLGgpLmdldChoKX12YXIgY289Zm8sdW89UGU7ZnVuY3Rpb24gaG8oaCl7cmV0dXJuIHVvKHRoaXMsaCkuaGFzKGgpfXZhciBnbz1obyxtbz1QZTtmdW5jdGlvbiB2byhoLGUpe3ZhciB0PW1vKHRoaXMsaCkscj10LnNpemU7cmV0dXJuIHQuc2V0KGgsZSksdGhpcy5zaXplKz10LnNpemU9PXI/MDoxLHRoaXN9dmFyIHlvPXZvLHBvPXRvLHhvPWFvLE1vPWNvLEVvPWdvLE9vPXlvO2Z1bmN0aW9uIG9lKGgpe3ZhciBlPS0xLHQ9aD09bnVsbD8wOmgubGVuZ3RoO2Zvcih0aGlzLmNsZWFyKCk7KytlPHQ7KXt2YXIgcj1oW2VdO3RoaXMuc2V0KHJbMF0sclsxXSl9fW9lLnByb3RvdHlwZS5jbGVhcj1wbyxvZS5wcm90b3R5cGUuZGVsZXRlPXhvLG9lLnByb3RvdHlwZS5nZXQ9TW8sb2UucHJvdG90eXBlLmhhcz1FbyxvZS5wcm90b3R5cGUuc2V0PU9vO3ZhciBUbz1vZSxQbz1PZSxBbz1VZSxTbz1Ubyxibz0yMDA7ZnVuY3Rpb24gQ28oaCxlKXt2YXIgdD10aGlzLl9fZGF0YV9fO2lmKHQgaW5zdGFuY2VvZiBQbyl7dmFyIHI9dC5fX2RhdGFfXztpZighQW98fHIubGVuZ3RoPGJvLTEpcmV0dXJuIHIucHVzaChbaCxlXSksdGhpcy5zaXplPSsrdC5zaXplLHRoaXM7dD10aGlzLl9fZGF0YV9fPW5ldyBTbyhyKX1yZXR1cm4gdC5zZXQoaCxlKSx0aGlzLnNpemU9dC5zaXplLHRoaXN9dmFyIFJvPUNvLExvPU9lLERvPUJpLElvPVdpLE5vPVVpLEJvPXppLGpvPVJvO2Z1bmN0aW9uIGFlKGgpe3ZhciBlPXRoaXMuX19kYXRhX189bmV3IExvKGgpO3RoaXMuc2l6ZT1lLnNpemV9YWUucHJvdG90eXBlLmNsZWFyPURvLGFlLnByb3RvdHlwZS5kZWxldGU9SW8sYWUucHJvdG90eXBlLmdldD1ObyxhZS5wcm90b3R5cGUuaGFzPUJvLGFlLnByb3RvdHlwZS5zZXQ9am87dmFyIFdvPWFlO2Z1bmN0aW9uIEZvKGgsZSl7Zm9yKHZhciB0PS0xLHI9aD09bnVsbD8wOmgubGVuZ3RoOysrdDxyJiZlKGhbdF0sdCxoKSE9PSExOyk7cmV0dXJuIGh9dmFyIFVvPUZvLCRvPXF0LHpvPWZ1bmN0aW9uKCl7dHJ5e3ZhciBoPSRvKE9iamVjdCwiZGVmaW5lUHJvcGVydHkiKTtyZXR1cm4gaCh7fSwiIix7fSksaH1jYXRjaHt9fSgpLHdvPXpvLEVyPXdvO2Z1bmN0aW9uIEdvKGgsZSx0KXtlPT0iX19wcm90b19fIiYmRXI/RXIoaCxlLHtjb25maWd1cmFibGU6ITAsZW51bWVyYWJsZTohMCx2YWx1ZTp0LHdyaXRhYmxlOiEwfSk6aFtlXT10fXZhciBPcj1HbyxLbz1PcixIbz1tcixWbz1PYmplY3QucHJvdG90eXBlLFlvPVZvLmhhc093blByb3BlcnR5O2Z1bmN0aW9uIFhvKGgsZSx0KXt2YXIgcj1oW2VdOyghKFlvLmNhbGwoaCxlKSYmSG8ocix0KSl8fHQ9PT12b2lkIDAmJiEoZSBpbiBoKSkmJktvKGgsZSx0KX12YXIgVHI9WG8sSm89VHIsWm89T3I7ZnVuY3Rpb24gUW8oaCxlLHQscil7dmFyIG49IXQ7dHx8KHQ9e30pO2Zvcih2YXIgZD0tMSxnPWUubGVuZ3RoOysrZDxnOyl7dmFyIHU9ZVtkXSxvPXI/cih0W3VdLGhbdV0sdSx0LGgpOnZvaWQgMDtvPT09dm9pZCAwJiYobz1oW3VdKSxuP1pvKHQsdSxvKTpKbyh0LHUsbyl9cmV0dXJuIHR9dmFyIEFlPVFvO2Z1bmN0aW9uIHFvKGgsZSl7Zm9yKHZhciB0PS0xLHI9QXJyYXkoaCk7Kyt0PGg7KXJbdF09ZSh0KTtyZXR1cm4gcn12YXIga289cW8sX289Y2UsdGE9bmUsZWE9IltvYmplY3QgQXJndW1lbnRzXSI7ZnVuY3Rpb24gcmEoaCl7cmV0dXJuIHRhKGgpJiZfbyhoKT09ZWF9dmFyIG5hPXJhLFByPW5hLGlhPW5lLEFyPU9iamVjdC5wcm90b3R5cGUsc2E9QXIuaGFzT3duUHJvcGVydHksb2E9QXIucHJvcGVydHlJc0VudW1lcmFibGUsYWE9UHIoZnVuY3Rpb24oKXtyZXR1cm4gYXJndW1lbnRzfSgpKT9QcjpmdW5jdGlvbihoKXtyZXR1cm4gaWEoaCkmJnNhLmNhbGwoaCwiY2FsbGVlIikmJiFvYS5jYWxsKGgsImNhbGxlZSIpfSxsYT1hYSxmYT1BcnJheS5pc0FycmF5LCRlPWZhLFNlPXtleHBvcnRzOnt9fTtmdW5jdGlvbiBjYSgpe3JldHVybiExfXZhciB1YT1jYTtTZS5leHBvcnRzLGZ1bmN0aW9uKGgsZSl7dmFyIHQ9SnQscj11YSxuPWUmJiFlLm5vZGVUeXBlJiZlLGQ9biYmITAmJmgmJiFoLm5vZGVUeXBlJiZoLGc9ZCYmZC5leHBvcnRzPT09bix1PWc/dC5CdWZmZXI6dm9pZCAwLG89dT91LmlzQnVmZmVyOnZvaWQgMCxmPW98fHI7aC5leHBvcnRzPWZ9KFNlLFNlLmV4cG9ydHMpO3ZhciBTcj1TZS5leHBvcnRzLGhhPTkwMDcxOTkyNTQ3NDA5OTEsZGE9L14oPzowfFsxLTldXGQqKSQvO2Z1bmN0aW9uIGdhKGgsZSl7dmFyIHQ9dHlwZW9mIGg7cmV0dXJuIGU9ZT8/aGEsISFlJiYodD09Im51bWJlciJ8fHQhPSJzeW1ib2wiJiZkYS50ZXN0KGgpKSYmaD4tMSYmaCUxPT0wJiZoPGV9dmFyIG1hPWdhLHZhPTkwMDcxOTkyNTQ3NDA5OTE7ZnVuY3Rpb24geWEoaCl7cmV0dXJuIHR5cGVvZiBoPT0ibnVtYmVyIiYmaD4tMSYmaCUxPT0wJiZoPD12YX12YXIgYnI9eWEscGE9Y2UseGE9YnIsTWE9bmUsRWE9IltvYmplY3QgQXJndW1lbnRzXSIsT2E9IltvYmplY3QgQXJyYXldIixUYT0iW29iamVjdCBCb29sZWFuXSIsUGE9IltvYmplY3QgRGF0ZV0iLEFhPSJbb2JqZWN0IEVycm9yXSIsU2E9IltvYmplY3QgRnVuY3Rpb25dIixiYT0iW29iamVjdCBNYXBdIixDYT0iW29iamVjdCBOdW1iZXJdIixSYT0iW29iamVjdCBPYmplY3RdIixMYT0iW29iamVjdCBSZWdFeHBdIixEYT0iW29iamVjdCBTZXRdIixJYT0iW29iamVjdCBTdHJpbmddIixOYT0iW29iamVjdCBXZWFrTWFwXSIsQmE9IltvYmplY3QgQXJyYXlCdWZmZXJdIixqYT0iW29iamVjdCBEYXRhVmlld10iLFdhPSJbb2JqZWN0IEZsb2F0MzJBcnJheV0iLEZhPSJbb2JqZWN0IEZsb2F0NjRBcnJheV0iLFVhPSJbb2JqZWN0IEludDhBcnJheV0iLCRhPSJbb2JqZWN0IEludDE2QXJyYXldIix6YT0iW29iamVjdCBJbnQzMkFycmF5XSIsd2E9IltvYmplY3QgVWludDhBcnJheV0iLEdhPSJbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XSIsS2E9IltvYmplY3QgVWludDE2QXJyYXldIixIYT0iW29iamVjdCBVaW50MzJBcnJheV0iLE50PXt9O050W1dhXT1OdFtGYV09TnRbVWFdPU50WyRhXT1OdFt6YV09TnRbd2FdPU50W0dhXT1OdFtLYV09TnRbSGFdPSEwLE50W0VhXT1OdFtPYV09TnRbQmFdPU50W1RhXT1OdFtqYV09TnRbUGFdPU50W0FhXT1OdFtTYV09TnRbYmFdPU50W0NhXT1OdFtSYV09TnRbTGFdPU50W0RhXT1OdFtJYV09TnRbTmFdPSExO2Z1bmN0aW9uIFZhKGgpe3JldHVybiBNYShoKSYmeGEoaC5sZW5ndGgpJiYhIU50W3BhKGgpXX12YXIgWWE9VmE7ZnVuY3Rpb24gWGEoaCl7cmV0dXJuIGZ1bmN0aW9uKGUpe3JldHVybiBoKGUpfX12YXIgemU9WGEsYmU9e2V4cG9ydHM6e319O2JlLmV4cG9ydHMsZnVuY3Rpb24oaCxlKXt2YXIgdD1mcixyPWUmJiFlLm5vZGVUeXBlJiZlLG49ciYmITAmJmgmJiFoLm5vZGVUeXBlJiZoLGQ9biYmbi5leHBvcnRzPT09cixnPWQmJnQucHJvY2Vzcyx1PWZ1bmN0aW9uKCl7dHJ5e3ZhciBvPW4mJm4ucmVxdWlyZSYmbi5yZXF1aXJlKCJ1dGlsIikudHlwZXM7cmV0dXJuIG98fGcmJmcuYmluZGluZyYmZy5iaW5kaW5nKCJ1dGlsIil9Y2F0Y2h7fX0oKTtoLmV4cG9ydHM9dX0oYmUsYmUuZXhwb3J0cyk7dmFyIHdlPWJlLmV4cG9ydHMsSmE9WWEsWmE9emUsQ3I9d2UsUnI9Q3ImJkNyLmlzVHlwZWRBcnJheSxRYT1Scj9aYShScik6SmEscWE9UWEsa2E9a28sX2E9bGEsdGw9JGUsZWw9U3Iscmw9bWEsbmw9cWEsaWw9T2JqZWN0LnByb3RvdHlwZSxzbD1pbC5oYXNPd25Qcm9wZXJ0eTtmdW5jdGlvbiBvbChoLGUpe3ZhciB0PXRsKGgpLHI9IXQmJl9hKGgpLG49IXQmJiFyJiZlbChoKSxkPSF0JiYhciYmIW4mJm5sKGgpLGc9dHx8cnx8bnx8ZCx1PWc/a2EoaC5sZW5ndGgsU3RyaW5nKTpbXSxvPXUubGVuZ3RoO2Zvcih2YXIgZiBpbiBoKShlfHxzbC5jYWxsKGgsZikpJiYhKGcmJihmPT0ibGVuZ3RoInx8biYmKGY9PSJvZmZzZXQifHxmPT0icGFyZW50Iil8fGQmJihmPT0iYnVmZmVyInx8Zj09ImJ5dGVMZW5ndGgifHxmPT0iYnl0ZU9mZnNldCIpfHxybChmLG8pKSkmJnUucHVzaChmKTtyZXR1cm4gdX12YXIgTHI9b2wsYWw9T2JqZWN0LnByb3RvdHlwZTtmdW5jdGlvbiBsbChoKXt2YXIgZT1oJiZoLmNvbnN0cnVjdG9yLHQ9dHlwZW9mIGU9PSJmdW5jdGlvbiImJmUucHJvdG90eXBlfHxhbDtyZXR1cm4gaD09PXR9dmFyIEdlPWxsO2Z1bmN0aW9uIGZsKGgsZSl7cmV0dXJuIGZ1bmN0aW9uKHQpe3JldHVybiBoKGUodCkpfX12YXIgRHI9ZmwsY2w9RHIsdWw9Y2woT2JqZWN0LmtleXMsT2JqZWN0KSxobD11bCxkbD1HZSxnbD1obCxtbD1PYmplY3QucHJvdG90eXBlLHZsPW1sLmhhc093blByb3BlcnR5O2Z1bmN0aW9uIHlsKGgpe2lmKCFkbChoKSlyZXR1cm4gZ2woaCk7dmFyIGU9W107Zm9yKHZhciB0IGluIE9iamVjdChoKSl2bC5jYWxsKGgsdCkmJnQhPSJjb25zdHJ1Y3RvciImJmUucHVzaCh0KTtyZXR1cm4gZX12YXIgcGw9eWwseGw9dnIsTWw9YnI7ZnVuY3Rpb24gRWwoaCl7cmV0dXJuIGghPW51bGwmJk1sKGgubGVuZ3RoKSYmIXhsKGgpfXZhciBJcj1FbCxPbD1McixUbD1wbCxQbD1JcjtmdW5jdGlvbiBBbChoKXtyZXR1cm4gUGwoaCk/T2woaCk6VGwoaCl9dmFyIEtlPUFsLFNsPUFlLGJsPUtlO2Z1bmN0aW9uIENsKGgsZSl7cmV0dXJuIGgmJlNsKGUsYmwoZSksaCl9dmFyIFJsPUNsO2Z1bmN0aW9uIExsKGgpe3ZhciBlPVtdO2lmKGghPW51bGwpZm9yKHZhciB0IGluIE9iamVjdChoKSllLnB1c2godCk7cmV0dXJuIGV9dmFyIERsPUxsLElsPXVlLE5sPUdlLEJsPURsLGpsPU9iamVjdC5wcm90b3R5cGUsV2w9amwuaGFzT3duUHJvcGVydHk7ZnVuY3Rpb24gRmwoaCl7aWYoIUlsKGgpKXJldHVybiBCbChoKTt2YXIgZT1ObChoKSx0PVtdO2Zvcih2YXIgciBpbiBoKXI9PSJjb25zdHJ1Y3RvciImJihlfHwhV2wuY2FsbChoLHIpKXx8dC5wdXNoKHIpO3JldHVybiB0fXZhciBVbD1GbCwkbD1Mcix6bD1VbCx3bD1JcjtmdW5jdGlvbiBHbChoKXtyZXR1cm4gd2woaCk/JGwoaCwhMCk6emwoaCl9dmFyIEhlPUdsLEtsPUFlLEhsPUhlO2Z1bmN0aW9uIFZsKGgsZSl7cmV0dXJuIGgmJktsKGUsSGwoZSksaCl9dmFyIFlsPVZsLENlPXtleHBvcnRzOnt9fTtDZS5leHBvcnRzLGZ1bmN0aW9uKGgsZSl7dmFyIHQ9SnQscj1lJiYhZS5ub2RlVHlwZSYmZSxuPXImJiEwJiZoJiYhaC5ub2RlVHlwZSYmaCxkPW4mJm4uZXhwb3J0cz09PXIsZz1kP3QuQnVmZmVyOnZvaWQgMCx1PWc/Zy5hbGxvY1Vuc2FmZTp2b2lkIDA7ZnVuY3Rpb24gbyhmLHgpe2lmKHgpcmV0dXJuIGYuc2xpY2UoKTt2YXIgYz1mLmxlbmd0aCx2PXU/dShjKTpuZXcgZi5jb25zdHJ1Y3RvcihjKTtyZXR1cm4gZi5jb3B5KHYpLHZ9aC5leHBvcnRzPW99KENlLENlLmV4cG9ydHMpO3ZhciBYbD1DZS5leHBvcnRzO2Z1bmN0aW9uIEpsKGgsZSl7dmFyIHQ9LTEscj1oLmxlbmd0aDtmb3IoZXx8KGU9QXJyYXkocikpOysrdDxyOyllW3RdPWhbdF07cmV0dXJuIGV9dmFyIFpsPUpsO2Z1bmN0aW9uIFFsKGgsZSl7Zm9yKHZhciB0PS0xLHI9aD09bnVsbD8wOmgubGVuZ3RoLG49MCxkPVtdOysrdDxyOyl7dmFyIGc9aFt0XTtlKGcsdCxoKSYmKGRbbisrXT1nKX1yZXR1cm4gZH12YXIgcWw9UWw7ZnVuY3Rpb24ga2woKXtyZXR1cm5bXX12YXIgTnI9a2wsX2w9cWwsdGY9TnIsZWY9T2JqZWN0LnByb3RvdHlwZSxyZj1lZi5wcm9wZXJ0eUlzRW51bWVyYWJsZSxCcj1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzLG5mPUJyP2Z1bmN0aW9uKGgpe3JldHVybiBoPT1udWxsP1tdOihoPU9iamVjdChoKSxfbChCcihoKSxmdW5jdGlvbihlKXtyZXR1cm4gcmYuY2FsbChoLGUpfSkpfTp0ZixWZT1uZixzZj1BZSxvZj1WZTtmdW5jdGlvbiBhZihoLGUpe3JldHVybiBzZihoLG9mKGgpLGUpfXZhciBsZj1hZjtmdW5jdGlvbiBmZihoLGUpe2Zvcih2YXIgdD0tMSxyPWUubGVuZ3RoLG49aC5sZW5ndGg7Kyt0PHI7KWhbbit0XT1lW3RdO3JldHVybiBofXZhciBqcj1mZixjZj1Ecix1Zj1jZihPYmplY3QuZ2V0UHJvdG90eXBlT2YsT2JqZWN0KSxXcj11ZixoZj1qcixkZj1XcixnZj1WZSxtZj1Ocix2Zj1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzLHlmPXZmP2Z1bmN0aW9uKGgpe2Zvcih2YXIgZT1bXTtoOyloZihlLGdmKGgpKSxoPWRmKGgpO3JldHVybiBlfTptZixGcj15ZixwZj1BZSx4Zj1GcjtmdW5jdGlvbiBNZihoLGUpe3JldHVybiBwZihoLHhmKGgpLGUpfXZhciBFZj1NZixPZj1qcixUZj0kZTtmdW5jdGlvbiBQZihoLGUsdCl7dmFyIHI9ZShoKTtyZXR1cm4gVGYoaCk/cjpPZihyLHQoaCkpfXZhciBVcj1QZixBZj1VcixTZj1WZSxiZj1LZTtmdW5jdGlvbiBDZihoKXtyZXR1cm4gQWYoaCxiZixTZil9dmFyIFJmPUNmLExmPVVyLERmPUZyLElmPUhlO2Z1bmN0aW9uIE5mKGgpe3JldHVybiBMZihoLElmLERmKX12YXIgQmY9TmYsamY9cXQsV2Y9SnQsRmY9amYoV2YsIkRhdGFWaWV3IiksVWY9RmYsJGY9cXQsemY9SnQsd2Y9JGYoemYsIlByb21pc2UiKSxHZj13ZixLZj1xdCxIZj1KdCxWZj1LZihIZiwiU2V0IiksWWY9VmYsWGY9cXQsSmY9SnQsWmY9WGYoSmYsIldlYWtNYXAiKSxRZj1aZixZZT1VZixYZT1VZSxKZT1HZixaZT1ZZixRZT1RZiwkcj1jZSxsZT1wcix6cj0iW29iamVjdCBNYXBdIixxZj0iW29iamVjdCBPYmplY3RdIix3cj0iW29iamVjdCBQcm9taXNlXSIsR3I9IltvYmplY3QgU2V0XSIsS3I9IltvYmplY3QgV2Vha01hcF0iLEhyPSJbb2JqZWN0IERhdGFWaWV3XSIsa2Y9bGUoWWUpLF9mPWxlKFhlKSx0Yz1sZShKZSksZWM9bGUoWmUpLHJjPWxlKFFlKSxrdD0kcjsoWWUmJmt0KG5ldyBZZShuZXcgQXJyYXlCdWZmZXIoMSkpKSE9SHJ8fFhlJiZrdChuZXcgWGUpIT16cnx8SmUmJmt0KEplLnJlc29sdmUoKSkhPXdyfHxaZSYma3QobmV3IFplKSE9R3J8fFFlJiZrdChuZXcgUWUpIT1LcikmJihrdD1mdW5jdGlvbihoKXt2YXIgZT0kcihoKSx0PWU9PXFmP2guY29uc3RydWN0b3I6dm9pZCAwLHI9dD9sZSh0KToiIjtpZihyKXN3aXRjaChyKXtjYXNlIGtmOnJldHVybiBIcjtjYXNlIF9mOnJldHVybiB6cjtjYXNlIHRjOnJldHVybiB3cjtjYXNlIGVjOnJldHVybiBHcjtjYXNlIHJjOnJldHVybiBLcn1yZXR1cm4gZX0pO3ZhciBxZT1rdCxuYz1PYmplY3QucHJvdG90eXBlLGljPW5jLmhhc093blByb3BlcnR5O2Z1bmN0aW9uIHNjKGgpe3ZhciBlPWgubGVuZ3RoLHQ9bmV3IGguY29uc3RydWN0b3IoZSk7cmV0dXJuIGUmJnR5cGVvZiBoWzBdPT0ic3RyaW5nIiYmaWMuY2FsbChoLCJpbmRleCIpJiYodC5pbmRleD1oLmluZGV4LHQuaW5wdXQ9aC5pbnB1dCksdH12YXIgb2M9c2MsYWM9SnQsbGM9YWMuVWludDhBcnJheSxmYz1sYyxWcj1mYztmdW5jdGlvbiBjYyhoKXt2YXIgZT1uZXcgaC5jb25zdHJ1Y3RvcihoLmJ5dGVMZW5ndGgpO3JldHVybiBuZXcgVnIoZSkuc2V0KG5ldyBWcihoKSksZX12YXIga2U9Y2MsdWM9a2U7ZnVuY3Rpb24gaGMoaCxlKXt2YXIgdD1lP3VjKGguYnVmZmVyKTpoLmJ1ZmZlcjtyZXR1cm4gbmV3IGguY29uc3RydWN0b3IodCxoLmJ5dGVPZmZzZXQsaC5ieXRlTGVuZ3RoKX12YXIgZGM9aGMsZ2M9L1x3KiQvO2Z1bmN0aW9uIG1jKGgpe3ZhciBlPW5ldyBoLmNvbnN0cnVjdG9yKGguc291cmNlLGdjLmV4ZWMoaCkpO3JldHVybiBlLmxhc3RJbmRleD1oLmxhc3RJbmRleCxlfXZhciB2Yz1tYyxZcj1XZSxYcj1Zcj9Zci5wcm90b3R5cGU6dm9pZCAwLEpyPVhyP1hyLnZhbHVlT2Y6dm9pZCAwO2Z1bmN0aW9uIHljKGgpe3JldHVybiBKcj9PYmplY3QoSnIuY2FsbChoKSk6e319dmFyIHBjPXljLHhjPWtlO2Z1bmN0aW9uIE1jKGgsZSl7dmFyIHQ9ZT94YyhoLmJ1ZmZlcik6aC5idWZmZXI7cmV0dXJuIG5ldyBoLmNvbnN0cnVjdG9yKHQsaC5ieXRlT2Zmc2V0LGgubGVuZ3RoKX12YXIgRWM9TWMsT2M9a2UsVGM9ZGMsUGM9dmMsQWM9cGMsU2M9RWMsYmM9IltvYmplY3QgQm9vbGVhbl0iLENjPSJbb2JqZWN0IERhdGVdIixSYz0iW29iamVjdCBNYXBdIixMYz0iW29iamVjdCBOdW1iZXJdIixEYz0iW29iamVjdCBSZWdFeHBdIixJYz0iW29iamVjdCBTZXRdIixOYz0iW29iamVjdCBTdHJpbmddIixCYz0iW29iamVjdCBTeW1ib2xdIixqYz0iW29iamVjdCBBcnJheUJ1ZmZlcl0iLFdjPSJbb2JqZWN0IERhdGFWaWV3XSIsRmM9IltvYmplY3QgRmxvYXQzMkFycmF5XSIsVWM9IltvYmplY3QgRmxvYXQ2NEFycmF5XSIsJGM9IltvYmplY3QgSW50OEFycmF5XSIsemM9IltvYmplY3QgSW50MTZBcnJheV0iLHdjPSJbb2JqZWN0IEludDMyQXJyYXldIixHYz0iW29iamVjdCBVaW50OEFycmF5XSIsS2M9IltvYmplY3QgVWludDhDbGFtcGVkQXJyYXldIixIYz0iW29iamVjdCBVaW50MTZBcnJheV0iLFZjPSJbb2JqZWN0IFVpbnQzMkFycmF5XSI7ZnVuY3Rpb24gWWMoaCxlLHQpe3ZhciByPWguY29uc3RydWN0b3I7c3dpdGNoKGUpe2Nhc2UgamM6cmV0dXJuIE9jKGgpO2Nhc2UgYmM6Y2FzZSBDYzpyZXR1cm4gbmV3IHIoK2gpO2Nhc2UgV2M6cmV0dXJuIFRjKGgsdCk7Y2FzZSBGYzpjYXNlIFVjOmNhc2UgJGM6Y2FzZSB6YzpjYXNlIHdjOmNhc2UgR2M6Y2FzZSBLYzpjYXNlIEhjOmNhc2UgVmM6cmV0dXJuIFNjKGgsdCk7Y2FzZSBSYzpyZXR1cm4gbmV3IHI7Y2FzZSBMYzpjYXNlIE5jOnJldHVybiBuZXcgcihoKTtjYXNlIERjOnJldHVybiBQYyhoKTtjYXNlIEljOnJldHVybiBuZXcgcjtjYXNlIEJjOnJldHVybiBBYyhoKX19dmFyIFhjPVljLEpjPXVlLFpyPU9iamVjdC5jcmVhdGUsWmM9ZnVuY3Rpb24oKXtmdW5jdGlvbiBoKCl7fXJldHVybiBmdW5jdGlvbihlKXtpZighSmMoZSkpcmV0dXJue307aWYoWnIpcmV0dXJuIFpyKGUpO2gucHJvdG90eXBlPWU7dmFyIHQ9bmV3IGg7cmV0dXJuIGgucHJvdG90eXBlPXZvaWQgMCx0fX0oKSxRYz1aYyxxYz1RYyxrYz1XcixfYz1HZTtmdW5jdGlvbiB0dShoKXtyZXR1cm4gdHlwZW9mIGguY29uc3RydWN0b3I9PSJmdW5jdGlvbiImJiFfYyhoKT9xYyhrYyhoKSk6e319dmFyIGV1PXR1LHJ1PXFlLG51PW5lLGl1PSJbb2JqZWN0IE1hcF0iO2Z1bmN0aW9uIHN1KGgpe3JldHVybiBudShoKSYmcnUoaCk9PWl1fXZhciBvdT1zdSxhdT1vdSxsdT16ZSxRcj13ZSxxcj1RciYmUXIuaXNNYXAsZnU9cXI/bHUocXIpOmF1LGN1PWZ1LHV1PXFlLGh1PW5lLGR1PSJbb2JqZWN0IFNldF0iO2Z1bmN0aW9uIGd1KGgpe3JldHVybiBodShoKSYmdXUoaCk9PWR1fXZhciBtdT1ndSx2dT1tdSx5dT16ZSxrcj13ZSxfcj1rciYma3IuaXNTZXQscHU9X3I/eXUoX3IpOnZ1LHh1PXB1LE11PVdvLEV1PVVvLE91PVRyLFR1PVJsLFB1PVlsLEF1PVhsLFN1PVpsLGJ1PWxmLEN1PUVmLFJ1PVJmLEx1PUJmLER1PXFlLEl1PW9jLE51PVhjLEJ1PWV1LGp1PSRlLFd1PVNyLEZ1PWN1LFV1PXVlLCR1PXh1LHp1PUtlLHd1PUhlLEd1PTEsS3U9MixIdT00LHRuPSJbb2JqZWN0IEFyZ3VtZW50c10iLFZ1PSJbb2JqZWN0IEFycmF5XSIsWXU9IltvYmplY3QgQm9vbGVhbl0iLFh1PSJbb2JqZWN0IERhdGVdIixKdT0iW29iamVjdCBFcnJvcl0iLGVuPSJbb2JqZWN0IEZ1bmN0aW9uXSIsWnU9IltvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dIixRdT0iW29iamVjdCBNYXBdIixxdT0iW29iamVjdCBOdW1iZXJdIixybj0iW29iamVjdCBPYmplY3RdIixrdT0iW29iamVjdCBSZWdFeHBdIixfdT0iW29iamVjdCBTZXRdIix0aD0iW29iamVjdCBTdHJpbmddIixlaD0iW29iamVjdCBTeW1ib2xdIixyaD0iW29iamVjdCBXZWFrTWFwXSIsbmg9IltvYmplY3QgQXJyYXlCdWZmZXJdIixpaD0iW29iamVjdCBEYXRhVmlld10iLHNoPSJbb2JqZWN0IEZsb2F0MzJBcnJheV0iLG9oPSJbb2JqZWN0IEZsb2F0NjRBcnJheV0iLGFoPSJbb2JqZWN0IEludDhBcnJheV0iLGxoPSJbb2JqZWN0IEludDE2QXJyYXldIixmaD0iW29iamVjdCBJbnQzMkFycmF5XSIsY2g9IltvYmplY3QgVWludDhBcnJheV0iLHVoPSJbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XSIsaGg9IltvYmplY3QgVWludDE2QXJyYXldIixkaD0iW29iamVjdCBVaW50MzJBcnJheV0iLEl0PXt9O0l0W3RuXT1JdFtWdV09SXRbbmhdPUl0W2loXT1JdFtZdV09SXRbWHVdPUl0W3NoXT1JdFtvaF09SXRbYWhdPUl0W2xoXT1JdFtmaF09SXRbUXVdPUl0W3F1XT1JdFtybl09SXRba3VdPUl0W191XT1JdFt0aF09SXRbZWhdPUl0W2NoXT1JdFt1aF09SXRbaGhdPUl0W2RoXT0hMCxJdFtKdV09SXRbZW5dPUl0W3JoXT0hMTtmdW5jdGlvbiBSZShoLGUsdCxyLG4sZCl7dmFyIGcsdT1lJkd1LG89ZSZLdSxmPWUmSHU7aWYodCYmKGc9bj90KGgscixuLGQpOnQoaCkpLGchPT12b2lkIDApcmV0dXJuIGc7aWYoIVV1KGgpKXJldHVybiBoO3ZhciB4PWp1KGgpO2lmKHgpe2lmKGc9SXUoaCksIXUpcmV0dXJuIFN1KGgsZyl9ZWxzZXt2YXIgYz1EdShoKSx2PWM9PWVufHxjPT1adTtpZihXdShoKSlyZXR1cm4gQXUoaCx1KTtpZihjPT1ybnx8Yz09dG58fHYmJiFuKXtpZihnPW98fHY/e306QnUoaCksIXUpcmV0dXJuIG8/Q3UoaCxQdShnLGgpKTpidShoLFR1KGcsaCkpfWVsc2V7aWYoIUl0W2NdKXJldHVybiBuP2g6e307Zz1OdShoLGMsdSl9fWR8fChkPW5ldyBNdSk7dmFyIHA9ZC5nZXQoaCk7aWYocClyZXR1cm4gcDtkLnNldChoLGcpLCR1KGgpP2guZm9yRWFjaChmdW5jdGlvbih5KXtnLmFkZChSZSh5LGUsdCx5LGgsZCkpfSk6RnUoaCkmJmguZm9yRWFjaChmdW5jdGlvbih5LE0pe2cuc2V0KE0sUmUoeSxlLHQsTSxoLGQpKX0pO3ZhciBiPWY/bz9MdTpSdTpvP3d1Onp1LEU9eD92b2lkIDA6YihoKTtyZXR1cm4gRXUoRXx8aCxmdW5jdGlvbih5LE0pe0UmJihNPXkseT1oW01dKSxPdShnLE0sUmUoeSxlLHQsTSxoLGQpKX0pLGd9dmFyIGdoPVJlLG1oPWdoLHZoPTEseWg9NDtmdW5jdGlvbiBwaChoKXtyZXR1cm4gbWgoaCx2aHx5aCl9dmFyIHhoPXBoLE1oPU5lKHhoKTtjb25zdCBMZT1jbGFzcyBMZSBleHRlbmRzIEpue2NvbnN0cnVjdG9yKCl7c3VwZXIoKTtWdCh0aGlzLCJjYW1lcmFPcHQiKTtWdCh0aGlzLCJkcHIiKTtWdCh0aGlzLCJzY2VuZSIpO1Z0KHRoaXMsImRyYXdMYXllciIpO1Z0KHRoaXMsImZ1bGxMYXllciIpO1Z0KHRoaXMsInNuYXBzaG90RnVsbExheWVyIik7VnQodGhpcywibG9jYWxXb3JrIik7VnQodGhpcywic2VydmljZVdvcmsiKTtWdCh0aGlzLCJtZXRob2RCdWlsZGVyIik7dGhpcy5yZWdpc3RlcigpfWluaXQodCxyLG4pe3RoaXMuZHByPXQsdGhpcy5zY2VuZT10aGlzLmNyZWF0ZVNjZW5lKHIpLHRoaXMuZHJhd0xheWVyPXRoaXMuY3JlYXRlTGF5ZXIodGhpcy5zY2VuZSx7Li4ubix3aWR0aDpyLndpZHRoLGhlaWdodDpyLmhlaWdodH0pLHRoaXMuZnVsbExheWVyPXRoaXMuY3JlYXRlTGF5ZXIodGhpcy5zY2VuZSx7Li4ubix3aWR0aDpyLndpZHRoLGhlaWdodDpyLmhlaWdodCxidWZmZXJTaXplOjVlM30pLHRoaXMubG9jYWxXb3JrPW5ldyBxbih0aGlzLmN1ck5vZGVNYXAsdGhpcy5mdWxsTGF5ZXIsdGhpcy5kcmF3TGF5ZXIsdGhpcy5wb3N0LmJpbmQodGhpcykpLHRoaXMuc2VydmljZVdvcms9bmV3IGtuKHRoaXMuY3VyTm9kZU1hcCx0aGlzLmZ1bGxMYXllcix0aGlzLmRyYXdMYXllcix0aGlzLnBvc3QuYmluZCh0aGlzKSksdGhpcy5tZXRob2RCdWlsZGVyPW5ldyBhaShbYnQuQ29weU5vZGUsYnQuU2V0Q29sb3JOb2RlLGJ0LkRlbGV0ZU5vZGUsYnQuUm90YXRlTm9kZSxidC5TY2FsZU5vZGUsYnQuVHJhbnNsYXRlTm9kZSxidC5aSW5kZXhBY3RpdmUsYnQuWkluZGV4Tm9kZV0pLnJlZ2lzdGVyRm9yV29ya2VyKHRoaXMubG9jYWxXb3JrLHRoaXMuc2VydmljZVdvcmspfWdldE9mZnNjcmVlbih0KXtyZXR1cm4odD90aGlzLmZ1bGxMYXllci5wYXJlbnQ6dGhpcy5kcmF3TGF5ZXIucGFyZW50KS5jYW52YXN9cmVnaXN0ZXIoKXt0aGlzLm9uKHQ9Pnt2YXIgcjtmb3IoY29uc3QgbiBvZiB0KXtjb25zdHt3b3JrU3RhdGU6ZCxkYXRhVHlwZTpnLG1zZ1R5cGU6dSx3b3JrSWQ6byx0b29sc1R5cGU6ZixvcHQ6eH09bjtpZighKChyPXRoaXMubWV0aG9kQnVpbGRlcikhPW51bGwmJnIuY29uc3VtZUZvcldvcmtlcihuKSkpc3dpdGNoKHUpe2Nhc2UgcHQuVXBkYXRlVG9vbHM6ZiYmeCYmdGhpcy5zZXRUb29sc09wdCh7dG9vbHNUeXBlOmYsdG9vbHNPcHQ6eH0pO2JyZWFrO2Nhc2UgcHQuQ3JlYXRlV29yazpvJiZ4JiYoIXRoaXMubG9jYWxXb3JrLmdldFRtcFdvcmtTaGFwZU5vZGUoKSYmZiYmdGhpcy5zZXRUb29sc09wdCh7dG9vbHNUeXBlOmYsdG9vbHNPcHQ6eH0pLHRoaXMuc2V0V29ya09wdCh7d29ya0lkOm8sdG9vbHNPcHQ6eH0pKTticmVhaztjYXNlIHB0LlNlbGVjdDpnPT09U3QuU2VydmljZSYmKG89PT12dC5zZWxlY3RvcklkP3RoaXMubG9jYWxXb3JrLnVwZGF0ZUZ1bGxTZWxlY3RXb3JrKG4pOnRoaXMuc2VydmljZVdvcmsucnVuU2VsZWN0V29yayhuKSk7YnJlYWs7Y2FzZSBwdC5VcGRhdGVOb2RlOmNhc2UgcHQuRnVsbFdvcms6dGhpcy5jb25zdW1lRnVsbChnLG4pO2JyZWFrO2Nhc2UgcHQuRHJhd1dvcms6ZD09PUd0LkRvbmUmJmc9PT1TdC5Mb2NhbD90aGlzLmNvbnN1bWVEcmF3QWxsKGcsbik6dGhpcy5jb25zdW1lRHJhdyhnLG4pO2JyZWFrO2Nhc2UgcHQuUmVtb3ZlTm9kZTp0aGlzLnJlbW92ZU5vZGUobik7YnJlYWt9fX0pfXNldFRvb2xzT3B0KHQpe3RoaXMubG9jYWxXb3JrLnNldFRvb2xzT3B0KHQpfXNldFdvcmtPcHQodCl7Y29uc3R7d29ya0lkOnIsdG9vbHNPcHQ6bn09dDtyJiZuJiZ0aGlzLmxvY2FsV29yay5zZXRXb3JrT3B0aW9ucyhyLG4pfWNsZWFyQWxsKCl7dmFyIHIsbjtjb25zdCB0PVtdOyhyPXRoaXMubG9jYWxXb3JrKT09bnVsbHx8ci5jbGVhckFsbFdvcmtTaGFwZXNDYWNoZSgpLChuPXRoaXMuc2VydmljZVdvcmspPT1udWxsfHxuLmNsZWFyQWxsV29ya1NoYXBlc0NhY2hlKCksdGhpcy5mdWxsTGF5ZXIucGFyZW50LmNoaWxkcmVuLmZvckVhY2goZD0+e2QubmFtZSE9PSJ2aWV3cG9ydCImJnQucHVzaChkKX0pLHRoaXMuZHJhd0xheWVyLnBhcmVudC5jaGlsZHJlbi5mb3JFYWNoKGQ9PntkLm5hbWUhPT0idmlld3BvcnQiJiZ0LnB1c2goZCl9KSx0LmZvckVhY2goZD0+e2QucmVtb3ZlKCl9KSx0aGlzLmZ1bGxMYXllci5yZW1vdmVBbGxDaGlsZHJlbigpLHRoaXMuZHJhd0xheWVyLnJlbW92ZUFsbENoaWxkcmVuKCksdGhpcy5sb2NhbFdvcmsucnVuRWZmZWN0V29yaygpfXNldENhbWVyYU9wdCh0KXt0aGlzLmNhbWVyYU9wdD10LHRoaXMubG9jYWxXb3JrLndvcmtTaGFwZXMuZm9yRWFjaCgobyxmKT0+e28udG9vbHNUeXBlPT09QXQuUGVuY2lsJiZ0aGlzLmxvY2FsV29yay53b3JrU2hhcGVTdGF0ZS5zZXQoZix7d2lsbENsZWFyOiEwfSl9KTtjb25zdHtzY2FsZTpyLGNlbnRlclg6bixjZW50ZXJZOmQsd2lkdGg6ZyxoZWlnaHQ6dX09dDsoZyE9PXRoaXMuc2NlbmUud2lkdGh8fHUhPT10aGlzLnNjZW5lLmhlaWdodCkmJnRoaXMudXBkYXRlU2NlbmUoe3dpZHRoOmcsaGVpZ2h0OnV9KSx0aGlzLmZ1bGxMYXllci5zZXRBdHRyaWJ1dGUoInNjYWxlIixbcixyXSksdGhpcy5mdWxsTGF5ZXIuc2V0QXR0cmlidXRlKCJ0cmFuc2xhdGUiLFstbiwtZF0pLHRoaXMuZHJhd0xheWVyLnNldEF0dHJpYnV0ZSgic2NhbGUiLFtyLHJdKSx0aGlzLmRyYXdMYXllci5zZXRBdHRyaWJ1dGUoInRyYW5zbGF0ZSIsWy1uLC1kXSksdGhpcy5sb2NhbFdvcmsucnVuRWZmZWN0V29yaygoKT0+e2lmKHRoaXMuc2VydmljZVdvcmsuc2VsZWN0b3JXb3JrU2hhcGVzLnNpemUpZm9yKGNvbnN0W28sZl1vZiB0aGlzLnNlcnZpY2VXb3JrLnNlbGVjdG9yV29ya1NoYXBlcy5lbnRyaWVzKCkpdGhpcy5zZXJ2aWNlV29yay5ydW5TZWxlY3RXb3JrKHt3b3JrSWQ6byxzZWxlY3RJZHM6Zi5zZWxlY3RJZHMsbXNnVHlwZTpwdC5TZWxlY3QsZGF0YVR5cGU6U3QuU2VydmljZX0pfSl9Z2V0UmVjdEltYWdlQml0bWFwKHQscil7Y29uc3Qgbj10LngqdGhpcy5kcHIsZD10LnkqdGhpcy5kcHIsZz10LncqdGhpcy5kcHIsdT10LmgqdGhpcy5kcHI7cmV0dXJuIGNyZWF0ZUltYWdlQml0bWFwKHRoaXMuZ2V0T2Zmc2NyZWVuKHIpLG4sZCxnLHUpfXNhZmFyaUZpeFJlY3QodCl7aWYoISh0LncrdC54PD0wfHx0LmgrdC55PD0wKSYmKHQudyt0Lng+dGhpcy5zY2VuZS53aWR0aCYmKHQudz10aGlzLnNjZW5lLndpZHRoLU1hdGgubWF4KHQueCwwKSksdC5oK3QueT50aGlzLnNjZW5lLndpZHRoJiYodC5oPXRoaXMuc2NlbmUuaGVpZ2h0LU1hdGgubWF4KHQueSwwKSksISh0Lnc8PTB8fHQuaDw9MCkpKXJldHVybiB0Lng8MCYmKHQudz10LncrdC54LHQueD0wKSx0Lnk8MCYmKHQuaD10LmgrdC55LHQueT0wKSx0fWdldFNjZW5lUmVjdCgpe2NvbnN0e3dpZHRoOnQsaGVpZ2h0OnJ9PXRoaXMuc2NlbmU7cmV0dXJue3g6MCx5OjAsdzp0LGg6cn19Y2hlY2tSaWdodFJlY3RCb3VuZGluZ0JveCh0KXtsZXQgcj10O3JldHVybiB0aGlzLmxvY2FsV29yay5jdXJOb2RlTWFwLmZvckVhY2gobj0+e21lKHIsbi5yZWN0KSYmKHI9VHQocixuLnJlY3QpKX0pLHJ9YXN5bmMgcG9zdCh0KXt2YXIgZyx1O2NvbnN0IHI9dC5yZW5kZXIsbj1bXTtpZihyIT1udWxsJiZyLmxlbmd0aCl7Zm9yKGNvbnN0IG8gb2YgcilpZihvLmlzQ2xlYXJBbGwmJihvLnJlY3Q9dGhpcy5nZXRTY2VuZVJlY3QoKSxvLmlzQ2xlYXI9ITAsZGVsZXRlIG8uaXNDbGVhckFsbCksby5pc0RyYXdBbGwmJihvLnJlY3Q9dGhpcy5nZXRTY2VuZVJlY3QoKSxkZWxldGUgby5pc0RyYXdBbGwpLG8uZHJhd0NhbnZhcyYmKG8uaXNGdWxsV29yaz90aGlzLmZ1bGxMYXllcjp0aGlzLmRyYXdMYXllcikucGFyZW50LnJlbmRlcigpLG8ucmVjdCl7by5jbGVhckNhbnZhcz09PW8uZHJhd0NhbnZhcyYmby5kcmF3Q2FudmFzPT09eXQuQmcmJihvLnJlY3Q9dGhpcy5jaGVja1JpZ2h0UmVjdEJvdW5kaW5nQm94KG8ucmVjdCkpO2NvbnN0IGY9by5yZWN0O2lmKG8ucmVjdD10aGlzLnNhZmFyaUZpeFJlY3QoTWgoby5yZWN0KSksIW8ucmVjdCljb250aW51ZTtpZihvLmRyYXdDYW52YXM9PT15dC5TZWxlY3RvciYmby5jbGVhckNhbnZhcz09PXl0LlNlbGVjdG9yKXtjb25zdCB4PShnPXQuc3ApPT1udWxsP3ZvaWQgMDpnLmZpbmQoYz0+Yy50eXBlPT09cHQuU2VsZWN0KTt4JiYoeC5yZWN0PW8ucmVjdCksby5vZmZzZXQ9e3g6by5yZWN0LngtZi54LHk6by5yZWN0LnktZi55fX1pZihvLmRyYXdDYW52YXMpe2NvbnN0IHg9YXdhaXQgdGhpcy5nZXRSZWN0SW1hZ2VCaXRtYXAoby5yZWN0LCEhby5pc0Z1bGxXb3JrKTtvLmltYWdlQml0bWFwPXh9bi5wdXNoKG8pfXQucmVuZGVyPW59Y29uc3QgZD0odT10LnNwKT09bnVsbD92b2lkIDA6dS5maWx0ZXIobz0+by50eXBlIT09cHQuTm9uZXx8T2JqZWN0LmtleXMobykuZmlsdGVyKGY9PmY9PT0idHlwZSIpLmxlbmd0aCk7aWYoZCE9bnVsbCYmZC5sZW5ndGgmJih0LnNwPWQpLCh0LmRyYXdDb3VudHx8ZCE9bnVsbCYmZC5sZW5ndGh8fG4hPW51bGwmJm4ubGVuZ3RoKSYmKExlLl9zZWxmLnBvc3RNZXNzYWdlKHQpLG4ubGVuZ3RoKSlmb3IoY29uc3QgbyBvZiBuKW8uaW1hZ2VCaXRtYXAmJm8uaW1hZ2VCaXRtYXAuY2xvc2UoKX1vbih0KXtvbm1lc3NhZ2U9cj0+e2lmKHIuZGF0YSl7Y29uc3Qgbj1yLmRhdGEuZ2V0KCJJbml0Iik7aWYobil7Y29uc3R7ZHByOm8sb2Zmc2NyZWVuQ2FudmFzT3B0OmYsbGF5ZXJPcHQ6eH09bjtmJiZ4JiZvJiZ0aGlzLmluaXQobyxmLHgpfWNvbnN0IGQ9ci5kYXRhLmhhcygiQ2xlYXJBbGwiKSxnPXIuZGF0YS5nZXQoIlVwZGF0ZUNhbWVyYSIpLHU9W107aWYoZyl7Y29uc3R7Y2FtZXJhT3B0Om99PWc7byYmdGhpcy5zZXRDYW1lcmFPcHQobyksdS5wdXNoKHtpc0NsZWFyQWxsOiEwLGNsZWFyQ2FudmFzOnl0LkJnLGlzRnVsbFdvcms6ITB9LHtpc0NsZWFyQWxsOiEwLGNsZWFyQ2FudmFzOnl0LkZsb2F0LGlzRnVsbFdvcms6ITF9KSx0aGlzLmZ1bGxMYXllci5jaGlsZHJlbi5sZW5ndGgmJnUucHVzaCh7aXNEcmF3QWxsOiEwLGRyYXdDYW52YXM6eXQuQmcsaXNDbGVhcjohMSxpc0Z1bGxXb3JrOiEwfSl9IWQmJnUubGVuZ3RoP3RoaXMucG9zdCh7cmVuZGVyOnV9KTpkJiYodGhpcy5jbGVhckFsbCgpLHRoaXMucG9zdCh7cmVuZGVyOlt7aXNDbGVhckFsbDohMCxjbGVhckNhbnZhczp5dC5CZyxpc0Z1bGxXb3JrOiEwfSx7aXNDbGVhckFsbDohMCxjbGVhckNhbnZhczp5dC5GbG9hdCxpc0Z1bGxXb3JrOiExfV0sc3A6W3t0eXBlOnB0LkNsZWFyfV19KSksdChyLmRhdGEudmFsdWVzKCkpfX19Y29uc3VtZURyYXcodCxyKXt0PT09U3QuTG9jYWwmJnRoaXMubG9jYWxXb3JrLmNvbnN1bWVEcmF3KHIsdGhpcy5zZXJ2aWNlV29yayksdD09PVN0LlNlcnZpY2UmJnRoaXMuc2VydmljZVdvcmsuY29uc3VtZURyYXcocil9Y29uc3VtZURyYXdBbGwodCxyKXt0PT09U3QuTG9jYWwmJnRoaXMubG9jYWxXb3JrLmNvbnN1bWVEcmF3QWxsKHIsdGhpcy5zZXJ2aWNlV29yayl9Y29uc3VtZUZ1bGwodCxyKXt0PT09U3QuTG9jYWwmJnRoaXMubG9jYWxXb3JrLmNvbnN1bWVGdWxsKHIpO2NvbnN0IG49dGhpcy5sb2NhbFdvcmsuY29sbG9jdEVmZmVjdFNlbGVjdFdvcmsocik7biYmdD09PVN0LlNlcnZpY2UmJnRoaXMuc2VydmljZVdvcmsuY29uc3VtZUZ1bGwobil9cmVtb3ZlTm9kZSh0KXtjb25zdHtkYXRhVHlwZTpyLHdvcmtJZDpufT10O249PT12dC5zZWxlY3RvcklkJiZ0aGlzLmxvY2FsV29yay5ibHVyU2VsZWN0b3IodCkscj09PVN0LlNlcnZpY2UmJnRoaXMuc2VydmljZVdvcmsucmVtb3ZlV29yayh0KSxyPT09U3QuTG9jYWwmJnRoaXMubG9jYWxXb3JrLnJlbW92ZVdvcmsodCl9fTtWdChMZSwiX3NlbGYiLHNlbGYpO2xldCBfZT1MZTtuZXcgX2V9KSgpOwo=", ht = typeof window < "u" && window.Blob && new Blob([atob(ds)], { type: "text/javascript;charset=utf-8" });
function oa(m) {
  let l;
  try {
    if (l = ht && (window.URL || window.webkitURL).createObjectURL(ht), !l)
      throw "";
    const i = new Worker(l, {
      name: m == null ? void 0 : m.name
    });
    return i.addEventListener("error", () => {
      (window.URL || window.webkitURL).revokeObjectURL(l);
    }), i;
  } catch {
    return new Worker(
      "data:application/javascript;base64," + ds,
      {
        name: m == null ? void 0 : m.name
      }
    );
  } finally {
    l && (window.URL || window.webkitURL).revokeObjectURL(l);
  }
}
const ts = "dmFyIHNoPU9iamVjdC5kZWZpbmVQcm9wZXJ0eTt2YXIgYWg9KER0LEd0LEx0KT0+R3QgaW4gRHQ/c2goRHQsR3Qse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOkx0fSk6RHRbR3RdPUx0O3ZhciBWdD0oRHQsR3QsTHQpPT4oYWgoRHQsdHlwZW9mIEd0IT0ic3ltYm9sIj9HdCsiIjpHdCxMdCksTHQpOyhmdW5jdGlvbigpeyJ1c2Ugc3RyaWN0Ijt2YXIgRHQ7KGZ1bmN0aW9uKGMpe2NbYy5QZW5jaWw9MV09IlBlbmNpbCIsY1tjLkVyYXNlcj0yXT0iRXJhc2VyIixjW2MuU2VsZWN0b3I9M109IlNlbGVjdG9yIixjW2MuQ2xpY2tlcj00XT0iQ2xpY2tlciIsY1tjLkFycm93PTVdPSJBcnJvdyIsY1tjLkhhbmQ9Nl09IkhhbmQiLGNbYy5MYXNlclBlbj03XT0iTGFzZXJQZW4ifSkoRHR8fChEdD17fSkpO3ZhciBHdDsoZnVuY3Rpb24oYyl7Y1tjLlBhdGg9MF09IlBhdGgiLGNbYy5SZWN0PTFdPSJSZWN0In0pKEd0fHwoR3Q9e30pKTt2YXIgTHQ7KGZ1bmN0aW9uKGMpe2NbYy5Mb2NhbD0xXT0iTG9jYWwiLGNbYy5TZXJ2aWNlPTJdPSJTZXJ2aWNlIn0pKEx0fHwoTHQ9e30pKTt2YXIgUXQ7KGZ1bmN0aW9uKGMpe2NbYy5QZW5kaW5nPTBdPSJQZW5kaW5nIixjW2MuU3RhcnQ9MV09IlN0YXJ0IixjW2MuRG9pbmc9Ml09IkRvaW5nIixjW2MuRG9uZT0zXT0iRG9uZSIsY1tjLkZyZWV6ZT00XT0iRnJlZXplIixjW2MuVW53cml0YWJsZT01XT0iVW53cml0YWJsZSJ9KShRdHx8KFF0PXt9KSk7dmFyIEV0OyhmdW5jdGlvbihjKXtjW2MuSW5pdD0wXT0iSW5pdCIsY1tjLlVwZGF0ZUNhbWVyYT0xXT0iVXBkYXRlQ2FtZXJhIixjW2MuVXBkYXRlVG9vbHM9Ml09IlVwZGF0ZVRvb2xzIixjW2MuQ3JlYXRlV29yaz0zXT0iQ3JlYXRlV29yayIsY1tjLkRyYXdXb3JrPTRdPSJEcmF3V29yayIsY1tjLkZ1bGxXb3JrPTVdPSJGdWxsV29yayIsY1tjLlVwZGF0ZU5vZGU9Nl09IlVwZGF0ZU5vZGUiLGNbYy5SZW1vdmVOb2RlPTddPSJSZW1vdmVOb2RlIixjW2MuQ2xlYXI9OF09IkNsZWFyIixjW2MuU2VsZWN0PTldPSJTZWxlY3QiLGNbYy5EZXN0cm95PTEwXT0iRGVzdHJveSIsY1tjLk5vbmU9MTFdPSJOb25lIixjW2MuU25hcHNob3Q9MTJdPSJTbmFwc2hvdCIsY1tjLkJvdW5kaW5nQm94PTEzXT0iQm91bmRpbmdCb3giLGNbYy5DdXJzb3I9MTRdPSJDdXJzb3IifSkoRXR8fChFdD17fSkpO3ZhciBaZTsoZnVuY3Rpb24oYyl7Y1tjLlBhdGg9MF09IlBhdGgiLGNbYy5SZWN0PTFdPSJSZWN0IixjW2MuVGV4dHVyZT0yXT0iVGV4dHVyZSJ9KShaZXx8KFplPXt9KSk7dmFyIHFlOyhmdW5jdGlvbihjKXtjLldlYmdsMj0id2ViZ2wyIixjLldlYmdsPSJ3ZWJnbCIsYy5DYW52YXMyZD0iMmQifSkocWV8fChxZT17fSkpO3ZhciBZdDsoZnVuY3Rpb24oYyl7Y1tjLkZsb2F0PTFdPSJGbG9hdCIsY1tjLkJnPTJdPSJCZyIsY1tjLlNlbGVjdG9yPTNdPSJTZWxlY3RvciIsY1tjLk5vbmU9NF09Ik5vbmUifSkoWXR8fChZdD17fSkpO3ZhciBrZTsoZnVuY3Rpb24oYyl7Yy5MVD0idG9wTGVmdCIsYy5MQz0ibGVmdCIsYy5MQj0iYm90dG9tTGVmdCIsYy5UQz0idG9wIixjLlJUPSJ0b3BSaWdodCIsYy5SQz0icmlnaHQiLGMuUkI9ImJvdHRvbVJpZ2h0IixjLkJDPSJib3R0b20ifSkoa2V8fChrZT17fSkpO3ZhciBfZTsoZnVuY3Rpb24oYyl7Y1tjLkN1cnNvcj0xXT0iQ3Vyc29yIn0pKF9lfHwoX2U9e30pKTt2YXIgdHI7KGZ1bmN0aW9uKGMpe2NbYy5Ub3A9MV09IlRvcCIsY1tjLkJvdHRvbT0yXT0iQm90dG9tIn0pKHRyfHwodHI9e30pKTtjbGFzcyBoZXtjb25zdHJ1Y3RvcihlLHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzeW5jVW5pdFRpbWUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZToxZTN9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiZHJhd0xheWVyIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImZ1bGxMYXllciIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ3b3JrSWQiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSx0aGlzLmZ1bGxMYXllcj1lLHRoaXMuZHJhd0xheWVyPXR9c2V0V29ya0lkKGUpe3RoaXMud29ya0lkPWV9Z2V0V29ya0lkKCl7cmV0dXJuIHRoaXMud29ya0lkfWdldFdvcmtPcHRpb25zKCl7cmV0dXJuIHRoaXMud29ya09wdGlvbnN9c2V0V29ya09wdGlvbnMoZSl7dGhpcy53b3JrT3B0aW9ucz1lLHRoaXMuc3luY1VuaXRUaW1lPWUuc3luY1VuaXRUaW1lfHx0aGlzLnN5bmNVbml0VGltZX19dmFyIEF0PWZ1bmN0aW9uKGMpe3ZhciBlPXt9O2Z1bmN0aW9uIHQocil7aWYoZVtyXSlyZXR1cm4gZVtyXS5leHBvcnRzO3ZhciBzPWVbcl09e2k6cixsOiExLGV4cG9ydHM6e319O3JldHVybiBjW3JdLmNhbGwocy5leHBvcnRzLHMscy5leHBvcnRzLHQpLHMubD0hMCxzLmV4cG9ydHN9cmV0dXJuIHQubT1jLHQuYz1lLHQuZD1mdW5jdGlvbihyLHMsZyl7dC5vKHIscyl8fE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyLHMse2VudW1lcmFibGU6ITAsZ2V0Omd9KX0sdC5yPWZ1bmN0aW9uKHIpe3R5cGVvZiBTeW1ib2w8InUiJiZTeW1ib2wudG9TdHJpbmdUYWcmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eShyLFN5bWJvbC50b1N0cmluZ1RhZyx7dmFsdWU6Ik1vZHVsZSJ9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkociwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSl9LHQudD1mdW5jdGlvbihyLHMpe2lmKHMmMSYmKHI9dChyKSkscyY4fHxzJjQmJnR5cGVvZiByPT0ib2JqZWN0IiYmciYmci5fX2VzTW9kdWxlKXJldHVybiByO3ZhciBnPU9iamVjdC5jcmVhdGUobnVsbCk7aWYodC5yKGcpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShnLCJkZWZhdWx0Iix7ZW51bWVyYWJsZTohMCx2YWx1ZTpyfSkscyYyJiZ0eXBlb2YgciE9InN0cmluZyIpZm9yKHZhciB2IGluIHIpdC5kKGcsdiwoZnVuY3Rpb24oaCl7cmV0dXJuIHJbaF19KS5iaW5kKG51bGwsdikpO3JldHVybiBnfSx0Lm49ZnVuY3Rpb24ocil7dmFyIHM9ciYmci5fX2VzTW9kdWxlP2Z1bmN0aW9uKCl7cmV0dXJuIHIuZGVmYXVsdH06ZnVuY3Rpb24oKXtyZXR1cm4gcn07cmV0dXJuIHQuZChzLCJhIixzKSxzfSx0Lm89ZnVuY3Rpb24ocixzKXtyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHIscyl9LHQucD0iL2pzLyIsdCh0LnM9MCl9KFtmdW5jdGlvbihjLGUsdCl7dC5yKGUpLHQuZChlLCJ2ZXJzaW9uIixmdW5jdGlvbigpe3JldHVybiBIfSksdC5kKGUsImhlbHBlcnMiLGZ1bmN0aW9uKCl7cmV0dXJuIEJ9KSx0LmQoZSwiY3JlYXRlRWxlbWVudCIsZnVuY3Rpb24oKXtyZXR1cm4gRH0pLHQuZChlLCJpc1Nwcml0ZU5vZGUiLGZ1bmN0aW9uKCl7cmV0dXJuIFJ9KSx0LmQoZSwicmVnaXN0ZXJOb2RlIixmdW5jdGlvbigpe3JldHVybiBTfSk7dmFyIHI9dCgxMik7dC5kKGUsIkVOViIsZnVuY3Rpb24oKXtyZXR1cm4gci5FTlZ9KTt2YXIgcz10KDY4KTt0LmQoZSwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIixmdW5jdGlvbigpe3JldHVybiBzLnJlcXVlc3RBbmltYXRpb25GcmFtZX0pLHQuZChlLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsZnVuY3Rpb24oKXtyZXR1cm4gcy5jYW5jZWxBbmltYXRpb25GcmFtZX0pO3ZhciBnPXQoNzApO3QuZChlLCJOb2RlIixmdW5jdGlvbigpe3JldHVybiBnLmRlZmF1bHR9KTt2YXIgdj10KDIxNyk7dC5kKGUsIkNsb3VkIixmdW5jdGlvbigpe3JldHVybiB2LmRlZmF1bHR9KTt2YXIgaD10KDIxOSk7dC5kKGUsIkJsb2NrIixmdW5jdGlvbigpe3JldHVybiBoLmRlZmF1bHR9KTt2YXIgbD10KDIyNCk7dC5kKGUsIlNwcml0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gbC5kZWZhdWx0fSk7dmFyIHU9dCgyMjYpO3QuZChlLCJQYXRoIixmdW5jdGlvbigpe3JldHVybiB1LmRlZmF1bHR9KTt2YXIgTT10KDIyOSk7dC5kKGUsIlJlY3QiLGZ1bmN0aW9uKCl7cmV0dXJuIE0uZGVmYXVsdH0pO3ZhciBmPXQoMjMxKTt0LmQoZSwiVHJpYW5nbGUiLGZ1bmN0aW9uKCl7cmV0dXJuIGYuZGVmYXVsdH0pO3ZhciB5PXQoMjM2KTt0LmQoZSwiUGFyYWxsZWwiLGZ1bmN0aW9uKCl7cmV0dXJuIHkuZGVmYXVsdH0pO3ZhciB4PXQoMjM4KTt0LmQoZSwiUmVndWxhciIsZnVuY3Rpb24oKXtyZXR1cm4geC5kZWZhdWx0fSk7dmFyIGI9dCgyNDApO3QuZChlLCJTdGFyIixmdW5jdGlvbigpe3JldHVybiBiLmRlZmF1bHR9KTt2YXIgTz10KDI0Mik7dC5kKGUsIkVsbGlwc2UiLGZ1bmN0aW9uKCl7cmV0dXJuIE8uZGVmYXVsdH0pO3ZhciBtPXQoMjQ0KTt0LmQoZSwiQXJjIixmdW5jdGlvbigpe3JldHVybiBtLmRlZmF1bHR9KTt2YXIgcD10KDI0Nik7dC5kKGUsIlJpbmciLGZ1bmN0aW9uKCl7cmV0dXJuIHAuZGVmYXVsdH0pO3ZhciBuPXQoMjMyKTt0LmQoZSwiUG9seWxpbmUiLGZ1bmN0aW9uKCl7cmV0dXJuIG4uZGVmYXVsdH0pO3ZhciBhPXQoMjQ4KTt0LmQoZSwiTGFiZWwiLGZ1bmN0aW9uKCl7cmV0dXJuIGEuZGVmYXVsdH0pO3ZhciBpPXQoMjUwKTt0LmQoZSwiR3JvdXAiLGZ1bmN0aW9uKCl7cmV0dXJuIGkuZGVmYXVsdH0pO3ZhciBvPXQoMjg2KTt0LmQoZSwiTGF5ZXIiLGZ1bmN0aW9uKCl7cmV0dXJuIG8uZGVmYXVsdH0pO3ZhciBUPXQoMjg3KTt0LmQoZSwiU3ByaXRlU3ZnIixmdW5jdGlvbigpe3JldHVybiBULmRlZmF1bHR9KTt2YXIgUD10KDI4OSk7dC5kKGUsIkxheWVyV29ya2VyIixmdW5jdGlvbigpe3JldHVybiBQLmRlZmF1bHR9KTt2YXIgQz10KDI5MCk7dC5kKGUsIlNjZW5lIixmdW5jdGlvbigpe3JldHVybiBDLmRlZmF1bHR9KTt2YXIgST10KDIxMyksQT10KDIyMSk7dC5kKGUsIkNvbG9yIixmdW5jdGlvbigpe3JldHVybiBBLkNvbG9yfSksdC5kKGUsIkdyYWRpZW50IixmdW5jdGlvbigpe3JldHVybiBBLkdyYWRpZW50fSk7dmFyIEw9dCg3Mik7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IEQ9SS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQsUj1JLmRlZmF1bHQuaXNTcHJpdGVOb2RlLFM9SS5kZWZhdWx0LnJlZ2lzdGVyTm9kZSxCPXtwYXJzZUNvbG9yOkEucGFyc2VDb2xvcixzaXplVG9QaXhlbDpMLnNpemVUb1BpeGVsLHRvQXJyYXk6TC50b0FycmF5LHRvU3RyaW5nOkwudG9TdHJpbmcsdG9OdW1iZXI6TC50b051bWJlcn07bGV0IHc7dz0iMy44LjMiO2NvbnN0IEg9d30sZnVuY3Rpb24oYyxlLHQpe3QucihlKTt2YXIgcj10KDIpO3QuZChlLCJnbE1hdHJpeCIsZnVuY3Rpb24oKXtyZXR1cm4gcn0pO3ZhciBzPXQoMyk7dC5kKGUsIm1hdDIiLGZ1bmN0aW9uKCl7cmV0dXJuIHN9KTt2YXIgZz10KDQpO3QuZChlLCJtYXQyZCIsZnVuY3Rpb24oKXtyZXR1cm4gZ30pO3ZhciB2PXQoNSk7dC5kKGUsIm1hdDMiLGZ1bmN0aW9uKCl7cmV0dXJuIHZ9KTt2YXIgaD10KDYpO3QuZChlLCJtYXQ0IixmdW5jdGlvbigpe3JldHVybiBofSk7dmFyIGw9dCg3KTt0LmQoZSwicXVhdCIsZnVuY3Rpb24oKXtyZXR1cm4gbH0pO3ZhciB1PXQoMTApO3QuZChlLCJxdWF0MiIsZnVuY3Rpb24oKXtyZXR1cm4gdX0pO3ZhciBNPXQoMTEpO3QuZChlLCJ2ZWMyIixmdW5jdGlvbigpe3JldHVybiBNfSk7dmFyIGY9dCg4KTt0LmQoZSwidmVjMyIsZnVuY3Rpb24oKXtyZXR1cm4gZn0pO3ZhciB5PXQoOSk7dC5kKGUsInZlYzQiLGZ1bmN0aW9uKCl7cmV0dXJuIHl9KX0sZnVuY3Rpb24oYyxlLHQpe3QucihlKSx0LmQoZSwiRVBTSUxPTiIsZnVuY3Rpb24oKXtyZXR1cm4gcn0pLHQuZChlLCJBUlJBWV9UWVBFIixmdW5jdGlvbigpe3JldHVybiBzfSksdC5kKGUsIlJBTkRPTSIsZnVuY3Rpb24oKXtyZXR1cm4gZ30pLHQuZChlLCJzZXRNYXRyaXhBcnJheVR5cGUiLGZ1bmN0aW9uKCl7cmV0dXJuIHZ9KSx0LmQoZSwidG9SYWRpYW4iLGZ1bmN0aW9uKCl7cmV0dXJuIGx9KSx0LmQoZSwiZXF1YWxzIixmdW5jdGlvbigpe3JldHVybiB1fSk7dmFyIHI9MWUtNixzPXR5cGVvZiBGbG9hdDMyQXJyYXk8InUiP0Zsb2F0MzJBcnJheTpBcnJheSxnPU1hdGgucmFuZG9tO2Z1bmN0aW9uIHYoTSl7cz1NfXZhciBoPU1hdGguUEkvMTgwO2Z1bmN0aW9uIGwoTSl7cmV0dXJuIE0qaH1mdW5jdGlvbiB1KE0sZil7cmV0dXJuIE1hdGguYWJzKE0tZik8PXIqTWF0aC5tYXgoMSxNYXRoLmFicyhNKSxNYXRoLmFicyhmKSl9TWF0aC5oeXBvdHx8KE1hdGguaHlwb3Q9ZnVuY3Rpb24oKXtmb3IodmFyIE09MCxmPWFyZ3VtZW50cy5sZW5ndGg7Zi0tOylNKz1hcmd1bWVudHNbZl0qYXJndW1lbnRzW2ZdO3JldHVybiBNYXRoLnNxcnQoTSl9KX0sZnVuY3Rpb24oYyxlLHQpe3QucihlKSx0LmQoZSwiY3JlYXRlIixmdW5jdGlvbigpe3JldHVybiBzfSksdC5kKGUsImNsb25lIixmdW5jdGlvbigpe3JldHVybiBnfSksdC5kKGUsImNvcHkiLGZ1bmN0aW9uKCl7cmV0dXJuIHZ9KSx0LmQoZSwiaWRlbnRpdHkiLGZ1bmN0aW9uKCl7cmV0dXJuIGh9KSx0LmQoZSwiZnJvbVZhbHVlcyIsZnVuY3Rpb24oKXtyZXR1cm4gbH0pLHQuZChlLCJzZXQiLGZ1bmN0aW9uKCl7cmV0dXJuIHV9KSx0LmQoZSwidHJhbnNwb3NlIixmdW5jdGlvbigpe3JldHVybiBNfSksdC5kKGUsImludmVydCIsZnVuY3Rpb24oKXtyZXR1cm4gZn0pLHQuZChlLCJhZGpvaW50IixmdW5jdGlvbigpe3JldHVybiB5fSksdC5kKGUsImRldGVybWluYW50IixmdW5jdGlvbigpe3JldHVybiB4fSksdC5kKGUsIm11bHRpcGx5IixmdW5jdGlvbigpe3JldHVybiBifSksdC5kKGUsInJvdGF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gT30pLHQuZChlLCJzY2FsZSIsZnVuY3Rpb24oKXtyZXR1cm4gbX0pLHQuZChlLCJmcm9tUm90YXRpb24iLGZ1bmN0aW9uKCl7cmV0dXJuIHB9KSx0LmQoZSwiZnJvbVNjYWxpbmciLGZ1bmN0aW9uKCl7cmV0dXJuIG59KSx0LmQoZSwic3RyIixmdW5jdGlvbigpe3JldHVybiBhfSksdC5kKGUsImZyb2IiLGZ1bmN0aW9uKCl7cmV0dXJuIGl9KSx0LmQoZSwiTERVIixmdW5jdGlvbigpe3JldHVybiBvfSksdC5kKGUsImFkZCIsZnVuY3Rpb24oKXtyZXR1cm4gVH0pLHQuZChlLCJzdWJ0cmFjdCIsZnVuY3Rpb24oKXtyZXR1cm4gUH0pLHQuZChlLCJleGFjdEVxdWFscyIsZnVuY3Rpb24oKXtyZXR1cm4gQ30pLHQuZChlLCJlcXVhbHMiLGZ1bmN0aW9uKCl7cmV0dXJuIEl9KSx0LmQoZSwibXVsdGlwbHlTY2FsYXIiLGZ1bmN0aW9uKCl7cmV0dXJuIEF9KSx0LmQoZSwibXVsdGlwbHlTY2FsYXJBbmRBZGQiLGZ1bmN0aW9uKCl7cmV0dXJuIEx9KSx0LmQoZSwibXVsIixmdW5jdGlvbigpe3JldHVybiBEfSksdC5kKGUsInN1YiIsZnVuY3Rpb24oKXtyZXR1cm4gUn0pO3ZhciByPXQoMik7ZnVuY3Rpb24gcygpe3ZhciBTPW5ldyByLkFSUkFZX1RZUEUoNCk7cmV0dXJuIHIuQVJSQVlfVFlQRSE9RmxvYXQzMkFycmF5JiYoU1sxXT0wLFNbMl09MCksU1swXT0xLFNbM109MSxTfWZ1bmN0aW9uIGcoUyl7dmFyIEI9bmV3IHIuQVJSQVlfVFlQRSg0KTtyZXR1cm4gQlswXT1TWzBdLEJbMV09U1sxXSxCWzJdPVNbMl0sQlszXT1TWzNdLEJ9ZnVuY3Rpb24gdihTLEIpe3JldHVybiBTWzBdPUJbMF0sU1sxXT1CWzFdLFNbMl09QlsyXSxTWzNdPUJbM10sU31mdW5jdGlvbiBoKFMpe3JldHVybiBTWzBdPTEsU1sxXT0wLFNbMl09MCxTWzNdPTEsU31mdW5jdGlvbiBsKFMsQix3LEgpe3ZhciBKPW5ldyByLkFSUkFZX1RZUEUoNCk7cmV0dXJuIEpbMF09UyxKWzFdPUIsSlsyXT13LEpbM109SCxKfWZ1bmN0aW9uIHUoUyxCLHcsSCxKKXtyZXR1cm4gU1swXT1CLFNbMV09dyxTWzJdPUgsU1szXT1KLFN9ZnVuY3Rpb24gTShTLEIpe2lmKFM9PT1CKXt2YXIgdz1CWzFdO1NbMV09QlsyXSxTWzJdPXd9ZWxzZSBTWzBdPUJbMF0sU1sxXT1CWzJdLFNbMl09QlsxXSxTWzNdPUJbM107cmV0dXJuIFN9ZnVuY3Rpb24gZihTLEIpe3ZhciB3PUJbMF0sSD1CWzFdLEo9QlsyXSxxPUJbM10sVz13KnEtSipIO3JldHVybiBXPyhXPTEvVyxTWzBdPXEqVyxTWzFdPS1IKlcsU1syXT0tSipXLFNbM109dypXLFMpOm51bGx9ZnVuY3Rpb24geShTLEIpe3ZhciB3PUJbMF07cmV0dXJuIFNbMF09QlszXSxTWzFdPS1CWzFdLFNbMl09LUJbMl0sU1szXT13LFN9ZnVuY3Rpb24geChTKXtyZXR1cm4gU1swXSpTWzNdLVNbMl0qU1sxXX1mdW5jdGlvbiBiKFMsQix3KXt2YXIgSD1CWzBdLEo9QlsxXSxxPUJbMl0sVz1CWzNdLEc9d1swXSxRPXdbMV0sdHQ9d1syXSxfPXdbM107cmV0dXJuIFNbMF09SCpHK3EqUSxTWzFdPUoqRytXKlEsU1syXT1IKnR0K3EqXyxTWzNdPUoqdHQrVypfLFN9ZnVuY3Rpb24gTyhTLEIsdyl7dmFyIEg9QlswXSxKPUJbMV0scT1CWzJdLFc9QlszXSxHPU1hdGguc2luKHcpLFE9TWF0aC5jb3Modyk7cmV0dXJuIFNbMF09SCpRK3EqRyxTWzFdPUoqUStXKkcsU1syXT1IKi1HK3EqUSxTWzNdPUoqLUcrVypRLFN9ZnVuY3Rpb24gbShTLEIsdyl7dmFyIEg9QlswXSxKPUJbMV0scT1CWzJdLFc9QlszXSxHPXdbMF0sUT13WzFdO3JldHVybiBTWzBdPUgqRyxTWzFdPUoqRyxTWzJdPXEqUSxTWzNdPVcqUSxTfWZ1bmN0aW9uIHAoUyxCKXt2YXIgdz1NYXRoLnNpbihCKSxIPU1hdGguY29zKEIpO3JldHVybiBTWzBdPUgsU1sxXT13LFNbMl09LXcsU1szXT1ILFN9ZnVuY3Rpb24gbihTLEIpe3JldHVybiBTWzBdPUJbMF0sU1sxXT0wLFNbMl09MCxTWzNdPUJbMV0sU31mdW5jdGlvbiBhKFMpe3JldHVybiJtYXQyKCIrU1swXSsiLCAiK1NbMV0rIiwgIitTWzJdKyIsICIrU1szXSsiKSJ9ZnVuY3Rpb24gaShTKXtyZXR1cm4gTWF0aC5oeXBvdChTWzBdLFNbMV0sU1syXSxTWzNdKX1mdW5jdGlvbiBvKFMsQix3LEgpe3JldHVybiBTWzJdPUhbMl0vSFswXSx3WzBdPUhbMF0sd1sxXT1IWzFdLHdbM109SFszXS1TWzJdKndbMV0sW1MsQix3XX1mdW5jdGlvbiBUKFMsQix3KXtyZXR1cm4gU1swXT1CWzBdK3dbMF0sU1sxXT1CWzFdK3dbMV0sU1syXT1CWzJdK3dbMl0sU1szXT1CWzNdK3dbM10sU31mdW5jdGlvbiBQKFMsQix3KXtyZXR1cm4gU1swXT1CWzBdLXdbMF0sU1sxXT1CWzFdLXdbMV0sU1syXT1CWzJdLXdbMl0sU1szXT1CWzNdLXdbM10sU31mdW5jdGlvbiBDKFMsQil7cmV0dXJuIFNbMF09PT1CWzBdJiZTWzFdPT09QlsxXSYmU1syXT09PUJbMl0mJlNbM109PT1CWzNdfWZ1bmN0aW9uIEkoUyxCKXt2YXIgdz1TWzBdLEg9U1sxXSxKPVNbMl0scT1TWzNdLFc9QlswXSxHPUJbMV0sUT1CWzJdLHR0PUJbM107cmV0dXJuIE1hdGguYWJzKHctVyk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKHcpLE1hdGguYWJzKFcpKSYmTWF0aC5hYnMoSC1HKTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoSCksTWF0aC5hYnMoRykpJiZNYXRoLmFicyhKLVEpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhKKSxNYXRoLmFicyhRKSkmJk1hdGguYWJzKHEtdHQpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhxKSxNYXRoLmFicyh0dCkpfWZ1bmN0aW9uIEEoUyxCLHcpe3JldHVybiBTWzBdPUJbMF0qdyxTWzFdPUJbMV0qdyxTWzJdPUJbMl0qdyxTWzNdPUJbM10qdyxTfWZ1bmN0aW9uIEwoUyxCLHcsSCl7cmV0dXJuIFNbMF09QlswXSt3WzBdKkgsU1sxXT1CWzFdK3dbMV0qSCxTWzJdPUJbMl0rd1syXSpILFNbM109QlszXSt3WzNdKkgsU312YXIgRD1iLFI9UH0sZnVuY3Rpb24oYyxlLHQpe3QucihlKSx0LmQoZSwiY3JlYXRlIixmdW5jdGlvbigpe3JldHVybiBzfSksdC5kKGUsImNsb25lIixmdW5jdGlvbigpe3JldHVybiBnfSksdC5kKGUsImNvcHkiLGZ1bmN0aW9uKCl7cmV0dXJuIHZ9KSx0LmQoZSwiaWRlbnRpdHkiLGZ1bmN0aW9uKCl7cmV0dXJuIGh9KSx0LmQoZSwiZnJvbVZhbHVlcyIsZnVuY3Rpb24oKXtyZXR1cm4gbH0pLHQuZChlLCJzZXQiLGZ1bmN0aW9uKCl7cmV0dXJuIHV9KSx0LmQoZSwiaW52ZXJ0IixmdW5jdGlvbigpe3JldHVybiBNfSksdC5kKGUsImRldGVybWluYW50IixmdW5jdGlvbigpe3JldHVybiBmfSksdC5kKGUsIm11bHRpcGx5IixmdW5jdGlvbigpe3JldHVybiB5fSksdC5kKGUsInJvdGF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4geH0pLHQuZChlLCJzY2FsZSIsZnVuY3Rpb24oKXtyZXR1cm4gYn0pLHQuZChlLCJ0cmFuc2xhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIE99KSx0LmQoZSwiZnJvbVJvdGF0aW9uIixmdW5jdGlvbigpe3JldHVybiBtfSksdC5kKGUsImZyb21TY2FsaW5nIixmdW5jdGlvbigpe3JldHVybiBwfSksdC5kKGUsImZyb21UcmFuc2xhdGlvbiIsZnVuY3Rpb24oKXtyZXR1cm4gbn0pLHQuZChlLCJzdHIiLGZ1bmN0aW9uKCl7cmV0dXJuIGF9KSx0LmQoZSwiZnJvYiIsZnVuY3Rpb24oKXtyZXR1cm4gaX0pLHQuZChlLCJhZGQiLGZ1bmN0aW9uKCl7cmV0dXJuIG99KSx0LmQoZSwic3VidHJhY3QiLGZ1bmN0aW9uKCl7cmV0dXJuIFR9KSx0LmQoZSwibXVsdGlwbHlTY2FsYXIiLGZ1bmN0aW9uKCl7cmV0dXJuIFB9KSx0LmQoZSwibXVsdGlwbHlTY2FsYXJBbmRBZGQiLGZ1bmN0aW9uKCl7cmV0dXJuIEN9KSx0LmQoZSwiZXhhY3RFcXVhbHMiLGZ1bmN0aW9uKCl7cmV0dXJuIEl9KSx0LmQoZSwiZXF1YWxzIixmdW5jdGlvbigpe3JldHVybiBBfSksdC5kKGUsIm11bCIsZnVuY3Rpb24oKXtyZXR1cm4gTH0pLHQuZChlLCJzdWIiLGZ1bmN0aW9uKCl7cmV0dXJuIER9KTt2YXIgcj10KDIpO2Z1bmN0aW9uIHMoKXt2YXIgUj1uZXcgci5BUlJBWV9UWVBFKDYpO3JldHVybiByLkFSUkFZX1RZUEUhPUZsb2F0MzJBcnJheSYmKFJbMV09MCxSWzJdPTAsUls0XT0wLFJbNV09MCksUlswXT0xLFJbM109MSxSfWZ1bmN0aW9uIGcoUil7dmFyIFM9bmV3IHIuQVJSQVlfVFlQRSg2KTtyZXR1cm4gU1swXT1SWzBdLFNbMV09UlsxXSxTWzJdPVJbMl0sU1szXT1SWzNdLFNbNF09Uls0XSxTWzVdPVJbNV0sU31mdW5jdGlvbiB2KFIsUyl7cmV0dXJuIFJbMF09U1swXSxSWzFdPVNbMV0sUlsyXT1TWzJdLFJbM109U1szXSxSWzRdPVNbNF0sUls1XT1TWzVdLFJ9ZnVuY3Rpb24gaChSKXtyZXR1cm4gUlswXT0xLFJbMV09MCxSWzJdPTAsUlszXT0xLFJbNF09MCxSWzVdPTAsUn1mdW5jdGlvbiBsKFIsUyxCLHcsSCxKKXt2YXIgcT1uZXcgci5BUlJBWV9UWVBFKDYpO3JldHVybiBxWzBdPVIscVsxXT1TLHFbMl09QixxWzNdPXcscVs0XT1ILHFbNV09SixxfWZ1bmN0aW9uIHUoUixTLEIsdyxILEoscSl7cmV0dXJuIFJbMF09UyxSWzFdPUIsUlsyXT13LFJbM109SCxSWzRdPUosUls1XT1xLFJ9ZnVuY3Rpb24gTShSLFMpe3ZhciBCPVNbMF0sdz1TWzFdLEg9U1syXSxKPVNbM10scT1TWzRdLFc9U1s1XSxHPUIqSi13Kkg7cmV0dXJuIEc/KEc9MS9HLFJbMF09SipHLFJbMV09LXcqRyxSWzJdPS1IKkcsUlszXT1CKkcsUls0XT0oSCpXLUoqcSkqRyxSWzVdPSh3KnEtQipXKSpHLFIpOm51bGx9ZnVuY3Rpb24gZihSKXtyZXR1cm4gUlswXSpSWzNdLVJbMV0qUlsyXX1mdW5jdGlvbiB5KFIsUyxCKXt2YXIgdz1TWzBdLEg9U1sxXSxKPVNbMl0scT1TWzNdLFc9U1s0XSxHPVNbNV0sUT1CWzBdLHR0PUJbMV0sXz1CWzJdLHN0PUJbM10saz1CWzRdLGN0PUJbNV07cmV0dXJuIFJbMF09dypRK0oqdHQsUlsxXT1IKlErcSp0dCxSWzJdPXcqXytKKnN0LFJbM109SCpfK3Eqc3QsUls0XT13KmsrSipjdCtXLFJbNV09SCprK3EqY3QrRyxSfWZ1bmN0aW9uIHgoUixTLEIpe3ZhciB3PVNbMF0sSD1TWzFdLEo9U1syXSxxPVNbM10sVz1TWzRdLEc9U1s1XSxRPU1hdGguc2luKEIpLHR0PU1hdGguY29zKEIpO3JldHVybiBSWzBdPXcqdHQrSipRLFJbMV09SCp0dCtxKlEsUlsyXT13Ki1RK0oqdHQsUlszXT1IKi1RK3EqdHQsUls0XT1XLFJbNV09RyxSfWZ1bmN0aW9uIGIoUixTLEIpe3ZhciB3PVNbMF0sSD1TWzFdLEo9U1syXSxxPVNbM10sVz1TWzRdLEc9U1s1XSxRPUJbMF0sdHQ9QlsxXTtyZXR1cm4gUlswXT13KlEsUlsxXT1IKlEsUlsyXT1KKnR0LFJbM109cSp0dCxSWzRdPVcsUls1XT1HLFJ9ZnVuY3Rpb24gTyhSLFMsQil7dmFyIHc9U1swXSxIPVNbMV0sSj1TWzJdLHE9U1szXSxXPVNbNF0sRz1TWzVdLFE9QlswXSx0dD1CWzFdO3JldHVybiBSWzBdPXcsUlsxXT1ILFJbMl09SixSWzNdPXEsUls0XT13KlErSip0dCtXLFJbNV09SCpRK3EqdHQrRyxSfWZ1bmN0aW9uIG0oUixTKXt2YXIgQj1NYXRoLnNpbihTKSx3PU1hdGguY29zKFMpO3JldHVybiBSWzBdPXcsUlsxXT1CLFJbMl09LUIsUlszXT13LFJbNF09MCxSWzVdPTAsUn1mdW5jdGlvbiBwKFIsUyl7cmV0dXJuIFJbMF09U1swXSxSWzFdPTAsUlsyXT0wLFJbM109U1sxXSxSWzRdPTAsUls1XT0wLFJ9ZnVuY3Rpb24gbihSLFMpe3JldHVybiBSWzBdPTEsUlsxXT0wLFJbMl09MCxSWzNdPTEsUls0XT1TWzBdLFJbNV09U1sxXSxSfWZ1bmN0aW9uIGEoUil7cmV0dXJuIm1hdDJkKCIrUlswXSsiLCAiK1JbMV0rIiwgIitSWzJdKyIsICIrUlszXSsiLCAiK1JbNF0rIiwgIitSWzVdKyIpIn1mdW5jdGlvbiBpKFIpe3JldHVybiBNYXRoLmh5cG90KFJbMF0sUlsxXSxSWzJdLFJbM10sUls0XSxSWzVdLDEpfWZ1bmN0aW9uIG8oUixTLEIpe3JldHVybiBSWzBdPVNbMF0rQlswXSxSWzFdPVNbMV0rQlsxXSxSWzJdPVNbMl0rQlsyXSxSWzNdPVNbM10rQlszXSxSWzRdPVNbNF0rQls0XSxSWzVdPVNbNV0rQls1XSxSfWZ1bmN0aW9uIFQoUixTLEIpe3JldHVybiBSWzBdPVNbMF0tQlswXSxSWzFdPVNbMV0tQlsxXSxSWzJdPVNbMl0tQlsyXSxSWzNdPVNbM10tQlszXSxSWzRdPVNbNF0tQls0XSxSWzVdPVNbNV0tQls1XSxSfWZ1bmN0aW9uIFAoUixTLEIpe3JldHVybiBSWzBdPVNbMF0qQixSWzFdPVNbMV0qQixSWzJdPVNbMl0qQixSWzNdPVNbM10qQixSWzRdPVNbNF0qQixSWzVdPVNbNV0qQixSfWZ1bmN0aW9uIEMoUixTLEIsdyl7cmV0dXJuIFJbMF09U1swXStCWzBdKncsUlsxXT1TWzFdK0JbMV0qdyxSWzJdPVNbMl0rQlsyXSp3LFJbM109U1szXStCWzNdKncsUls0XT1TWzRdK0JbNF0qdyxSWzVdPVNbNV0rQls1XSp3LFJ9ZnVuY3Rpb24gSShSLFMpe3JldHVybiBSWzBdPT09U1swXSYmUlsxXT09PVNbMV0mJlJbMl09PT1TWzJdJiZSWzNdPT09U1szXSYmUls0XT09PVNbNF0mJlJbNV09PT1TWzVdfWZ1bmN0aW9uIEEoUixTKXt2YXIgQj1SWzBdLHc9UlsxXSxIPVJbMl0sSj1SWzNdLHE9Uls0XSxXPVJbNV0sRz1TWzBdLFE9U1sxXSx0dD1TWzJdLF89U1szXSxzdD1TWzRdLGs9U1s1XTtyZXR1cm4gTWF0aC5hYnMoQi1HKTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoQiksTWF0aC5hYnMoRykpJiZNYXRoLmFicyh3LVEpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyh3KSxNYXRoLmFicyhRKSkmJk1hdGguYWJzKEgtdHQpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhIKSxNYXRoLmFicyh0dCkpJiZNYXRoLmFicyhKLV8pPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhKKSxNYXRoLmFicyhfKSkmJk1hdGguYWJzKHEtc3QpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhxKSxNYXRoLmFicyhzdCkpJiZNYXRoLmFicyhXLWspPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhXKSxNYXRoLmFicyhrKSl9dmFyIEw9eSxEPVR9LGZ1bmN0aW9uKGMsZSx0KXt0LnIoZSksdC5kKGUsImNyZWF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gc30pLHQuZChlLCJmcm9tTWF0NCIsZnVuY3Rpb24oKXtyZXR1cm4gZ30pLHQuZChlLCJjbG9uZSIsZnVuY3Rpb24oKXtyZXR1cm4gdn0pLHQuZChlLCJjb3B5IixmdW5jdGlvbigpe3JldHVybiBofSksdC5kKGUsImZyb21WYWx1ZXMiLGZ1bmN0aW9uKCl7cmV0dXJuIGx9KSx0LmQoZSwic2V0IixmdW5jdGlvbigpe3JldHVybiB1fSksdC5kKGUsImlkZW50aXR5IixmdW5jdGlvbigpe3JldHVybiBNfSksdC5kKGUsInRyYW5zcG9zZSIsZnVuY3Rpb24oKXtyZXR1cm4gZn0pLHQuZChlLCJpbnZlcnQiLGZ1bmN0aW9uKCl7cmV0dXJuIHl9KSx0LmQoZSwiYWRqb2ludCIsZnVuY3Rpb24oKXtyZXR1cm4geH0pLHQuZChlLCJkZXRlcm1pbmFudCIsZnVuY3Rpb24oKXtyZXR1cm4gYn0pLHQuZChlLCJtdWx0aXBseSIsZnVuY3Rpb24oKXtyZXR1cm4gT30pLHQuZChlLCJ0cmFuc2xhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIG19KSx0LmQoZSwicm90YXRlIixmdW5jdGlvbigpe3JldHVybiBwfSksdC5kKGUsInNjYWxlIixmdW5jdGlvbigpe3JldHVybiBufSksdC5kKGUsImZyb21UcmFuc2xhdGlvbiIsZnVuY3Rpb24oKXtyZXR1cm4gYX0pLHQuZChlLCJmcm9tUm90YXRpb24iLGZ1bmN0aW9uKCl7cmV0dXJuIGl9KSx0LmQoZSwiZnJvbVNjYWxpbmciLGZ1bmN0aW9uKCl7cmV0dXJuIG99KSx0LmQoZSwiZnJvbU1hdDJkIixmdW5jdGlvbigpe3JldHVybiBUfSksdC5kKGUsImZyb21RdWF0IixmdW5jdGlvbigpe3JldHVybiBQfSksdC5kKGUsIm5vcm1hbEZyb21NYXQ0IixmdW5jdGlvbigpe3JldHVybiBDfSksdC5kKGUsInByb2plY3Rpb24iLGZ1bmN0aW9uKCl7cmV0dXJuIEl9KSx0LmQoZSwic3RyIixmdW5jdGlvbigpe3JldHVybiBBfSksdC5kKGUsImZyb2IiLGZ1bmN0aW9uKCl7cmV0dXJuIEx9KSx0LmQoZSwiYWRkIixmdW5jdGlvbigpe3JldHVybiBEfSksdC5kKGUsInN1YnRyYWN0IixmdW5jdGlvbigpe3JldHVybiBSfSksdC5kKGUsIm11bHRpcGx5U2NhbGFyIixmdW5jdGlvbigpe3JldHVybiBTfSksdC5kKGUsIm11bHRpcGx5U2NhbGFyQW5kQWRkIixmdW5jdGlvbigpe3JldHVybiBCfSksdC5kKGUsImV4YWN0RXF1YWxzIixmdW5jdGlvbigpe3JldHVybiB3fSksdC5kKGUsImVxdWFscyIsZnVuY3Rpb24oKXtyZXR1cm4gSH0pLHQuZChlLCJtdWwiLGZ1bmN0aW9uKCl7cmV0dXJuIEp9KSx0LmQoZSwic3ViIixmdW5jdGlvbigpe3JldHVybiBxfSk7dmFyIHI9dCgyKTtmdW5jdGlvbiBzKCl7dmFyIFc9bmV3IHIuQVJSQVlfVFlQRSg5KTtyZXR1cm4gci5BUlJBWV9UWVBFIT1GbG9hdDMyQXJyYXkmJihXWzFdPTAsV1syXT0wLFdbM109MCxXWzVdPTAsV1s2XT0wLFdbN109MCksV1swXT0xLFdbNF09MSxXWzhdPTEsV31mdW5jdGlvbiBnKFcsRyl7cmV0dXJuIFdbMF09R1swXSxXWzFdPUdbMV0sV1syXT1HWzJdLFdbM109R1s0XSxXWzRdPUdbNV0sV1s1XT1HWzZdLFdbNl09R1s4XSxXWzddPUdbOV0sV1s4XT1HWzEwXSxXfWZ1bmN0aW9uIHYoVyl7dmFyIEc9bmV3IHIuQVJSQVlfVFlQRSg5KTtyZXR1cm4gR1swXT1XWzBdLEdbMV09V1sxXSxHWzJdPVdbMl0sR1szXT1XWzNdLEdbNF09V1s0XSxHWzVdPVdbNV0sR1s2XT1XWzZdLEdbN109V1s3XSxHWzhdPVdbOF0sR31mdW5jdGlvbiBoKFcsRyl7cmV0dXJuIFdbMF09R1swXSxXWzFdPUdbMV0sV1syXT1HWzJdLFdbM109R1szXSxXWzRdPUdbNF0sV1s1XT1HWzVdLFdbNl09R1s2XSxXWzddPUdbN10sV1s4XT1HWzhdLFd9ZnVuY3Rpb24gbChXLEcsUSx0dCxfLHN0LGssY3QsZnQpe3ZhciBVPW5ldyByLkFSUkFZX1RZUEUoOSk7cmV0dXJuIFVbMF09VyxVWzFdPUcsVVsyXT1RLFVbM109dHQsVVs0XT1fLFVbNV09c3QsVVs2XT1rLFVbN109Y3QsVVs4XT1mdCxVfWZ1bmN0aW9uIHUoVyxHLFEsdHQsXyxzdCxrLGN0LGZ0LFUpe3JldHVybiBXWzBdPUcsV1sxXT1RLFdbMl09dHQsV1szXT1fLFdbNF09c3QsV1s1XT1rLFdbNl09Y3QsV1s3XT1mdCxXWzhdPVUsV31mdW5jdGlvbiBNKFcpe3JldHVybiBXWzBdPTEsV1sxXT0wLFdbMl09MCxXWzNdPTAsV1s0XT0xLFdbNV09MCxXWzZdPTAsV1s3XT0wLFdbOF09MSxXfWZ1bmN0aW9uIGYoVyxHKXtpZihXPT09Ryl7dmFyIFE9R1sxXSx0dD1HWzJdLF89R1s1XTtXWzFdPUdbM10sV1syXT1HWzZdLFdbM109USxXWzVdPUdbN10sV1s2XT10dCxXWzddPV99ZWxzZSBXWzBdPUdbMF0sV1sxXT1HWzNdLFdbMl09R1s2XSxXWzNdPUdbMV0sV1s0XT1HWzRdLFdbNV09R1s3XSxXWzZdPUdbMl0sV1s3XT1HWzVdLFdbOF09R1s4XTtyZXR1cm4gV31mdW5jdGlvbiB5KFcsRyl7dmFyIFE9R1swXSx0dD1HWzFdLF89R1syXSxzdD1HWzNdLGs9R1s0XSxjdD1HWzVdLGZ0PUdbNl0sVT1HWzddLEY9R1s4XSxWPUYqay1jdCpVLFg9LUYqc3QrY3QqZnQsaj1VKnN0LWsqZnQsej1RKlYrdHQqWCtfKmo7cmV0dXJuIHo/KHo9MS96LFdbMF09Vip6LFdbMV09KC1GKnR0K18qVSkqeixXWzJdPShjdCp0dC1fKmspKnosV1szXT1YKnosV1s0XT0oRipRLV8qZnQpKnosV1s1XT0oLWN0KlErXypzdCkqeixXWzZdPWoqeixXWzddPSgtVSpRK3R0KmZ0KSp6LFdbOF09KGsqUS10dCpzdCkqeixXKTpudWxsfWZ1bmN0aW9uIHgoVyxHKXt2YXIgUT1HWzBdLHR0PUdbMV0sXz1HWzJdLHN0PUdbM10saz1HWzRdLGN0PUdbNV0sZnQ9R1s2XSxVPUdbN10sRj1HWzhdO3JldHVybiBXWzBdPWsqRi1jdCpVLFdbMV09XypVLXR0KkYsV1syXT10dCpjdC1fKmssV1szXT1jdCpmdC1zdCpGLFdbNF09USpGLV8qZnQsV1s1XT1fKnN0LVEqY3QsV1s2XT1zdCpVLWsqZnQsV1s3XT10dCpmdC1RKlUsV1s4XT1RKmstdHQqc3QsV31mdW5jdGlvbiBiKFcpe3ZhciBHPVdbMF0sUT1XWzFdLHR0PVdbMl0sXz1XWzNdLHN0PVdbNF0saz1XWzVdLGN0PVdbNl0sZnQ9V1s3XSxVPVdbOF07cmV0dXJuIEcqKFUqc3QtaypmdCkrUSooLVUqXytrKmN0KSt0dCooZnQqXy1zdCpjdCl9ZnVuY3Rpb24gTyhXLEcsUSl7dmFyIHR0PUdbMF0sXz1HWzFdLHN0PUdbMl0saz1HWzNdLGN0PUdbNF0sZnQ9R1s1XSxVPUdbNl0sRj1HWzddLFY9R1s4XSxYPVFbMF0saj1RWzFdLHo9UVsyXSxkPVFbM10sRT1RWzRdLE49UVs1XSwkPVFbNl0sSz1RWzddLFk9UVs4XTtyZXR1cm4gV1swXT1YKnR0K2oqayt6KlUsV1sxXT1YKl8raipjdCt6KkYsV1syXT1YKnN0K2oqZnQreipWLFdbM109ZCp0dCtFKmsrTipVLFdbNF09ZCpfK0UqY3QrTipGLFdbNV09ZCpzdCtFKmZ0K04qVixXWzZdPSQqdHQrSyprK1kqVSxXWzddPSQqXytLKmN0K1kqRixXWzhdPSQqc3QrSypmdCtZKlYsV31mdW5jdGlvbiBtKFcsRyxRKXt2YXIgdHQ9R1swXSxfPUdbMV0sc3Q9R1syXSxrPUdbM10sY3Q9R1s0XSxmdD1HWzVdLFU9R1s2XSxGPUdbN10sVj1HWzhdLFg9UVswXSxqPVFbMV07cmV0dXJuIFdbMF09dHQsV1sxXT1fLFdbMl09c3QsV1szXT1rLFdbNF09Y3QsV1s1XT1mdCxXWzZdPVgqdHQraiprK1UsV1s3XT1YKl8raipjdCtGLFdbOF09WCpzdCtqKmZ0K1YsV31mdW5jdGlvbiBwKFcsRyxRKXt2YXIgdHQ9R1swXSxfPUdbMV0sc3Q9R1syXSxrPUdbM10sY3Q9R1s0XSxmdD1HWzVdLFU9R1s2XSxGPUdbN10sVj1HWzhdLFg9TWF0aC5zaW4oUSksaj1NYXRoLmNvcyhRKTtyZXR1cm4gV1swXT1qKnR0K1gqayxXWzFdPWoqXytYKmN0LFdbMl09aipzdCtYKmZ0LFdbM109aiprLVgqdHQsV1s0XT1qKmN0LVgqXyxXWzVdPWoqZnQtWCpzdCxXWzZdPVUsV1s3XT1GLFdbOF09VixXfWZ1bmN0aW9uIG4oVyxHLFEpe3ZhciB0dD1RWzBdLF89UVsxXTtyZXR1cm4gV1swXT10dCpHWzBdLFdbMV09dHQqR1sxXSxXWzJdPXR0KkdbMl0sV1szXT1fKkdbM10sV1s0XT1fKkdbNF0sV1s1XT1fKkdbNV0sV1s2XT1HWzZdLFdbN109R1s3XSxXWzhdPUdbOF0sV31mdW5jdGlvbiBhKFcsRyl7cmV0dXJuIFdbMF09MSxXWzFdPTAsV1syXT0wLFdbM109MCxXWzRdPTEsV1s1XT0wLFdbNl09R1swXSxXWzddPUdbMV0sV1s4XT0xLFd9ZnVuY3Rpb24gaShXLEcpe3ZhciBRPU1hdGguc2luKEcpLHR0PU1hdGguY29zKEcpO3JldHVybiBXWzBdPXR0LFdbMV09USxXWzJdPTAsV1szXT0tUSxXWzRdPXR0LFdbNV09MCxXWzZdPTAsV1s3XT0wLFdbOF09MSxXfWZ1bmN0aW9uIG8oVyxHKXtyZXR1cm4gV1swXT1HWzBdLFdbMV09MCxXWzJdPTAsV1szXT0wLFdbNF09R1sxXSxXWzVdPTAsV1s2XT0wLFdbN109MCxXWzhdPTEsV31mdW5jdGlvbiBUKFcsRyl7cmV0dXJuIFdbMF09R1swXSxXWzFdPUdbMV0sV1syXT0wLFdbM109R1syXSxXWzRdPUdbM10sV1s1XT0wLFdbNl09R1s0XSxXWzddPUdbNV0sV1s4XT0xLFd9ZnVuY3Rpb24gUChXLEcpe3ZhciBRPUdbMF0sdHQ9R1sxXSxfPUdbMl0sc3Q9R1szXSxrPVErUSxjdD10dCt0dCxmdD1fK18sVT1RKmssRj10dCprLFY9dHQqY3QsWD1fKmssaj1fKmN0LHo9XypmdCxkPXN0KmssRT1zdCpjdCxOPXN0KmZ0O3JldHVybiBXWzBdPTEtVi16LFdbM109Ri1OLFdbNl09WCtFLFdbMV09RitOLFdbNF09MS1VLXosV1s3XT1qLWQsV1syXT1YLUUsV1s1XT1qK2QsV1s4XT0xLVUtVixXfWZ1bmN0aW9uIEMoVyxHKXt2YXIgUT1HWzBdLHR0PUdbMV0sXz1HWzJdLHN0PUdbM10saz1HWzRdLGN0PUdbNV0sZnQ9R1s2XSxVPUdbN10sRj1HWzhdLFY9R1s5XSxYPUdbMTBdLGo9R1sxMV0sej1HWzEyXSxkPUdbMTNdLEU9R1sxNF0sTj1HWzE1XSwkPVEqY3QtdHQqayxLPVEqZnQtXyprLFk9USpVLXN0KmssWj10dCpmdC1fKmN0LGV0PXR0KlUtc3QqY3QscnQ9XypVLXN0KmZ0LGF0PUYqZC1WKnosbHQ9RipFLVgqeixpdD1GKk4taip6LG50PVYqRS1YKmQsb3Q9VipOLWoqZCxkdD1YKk4taipFLGd0PSQqZHQtSypvdCtZKm50K1oqaXQtZXQqbHQrcnQqYXQ7cmV0dXJuIGd0PyhndD0xL2d0LFdbMF09KGN0KmR0LWZ0Km90K1UqbnQpKmd0LFdbMV09KGZ0Kml0LWsqZHQtVSpsdCkqZ3QsV1syXT0oaypvdC1jdCppdCtVKmF0KSpndCxXWzNdPShfKm90LXR0KmR0LXN0Km50KSpndCxXWzRdPShRKmR0LV8qaXQrc3QqbHQpKmd0LFdbNV09KHR0Kml0LVEqb3Qtc3QqYXQpKmd0LFdbNl09KGQqcnQtRSpldCtOKlopKmd0LFdbN109KEUqWS16KnJ0LU4qSykqZ3QsV1s4XT0oeipldC1kKlkrTiokKSpndCxXKTpudWxsfWZ1bmN0aW9uIEkoVyxHLFEpe3JldHVybiBXWzBdPTIvRyxXWzFdPTAsV1syXT0wLFdbM109MCxXWzRdPS0yL1EsV1s1XT0wLFdbNl09LTEsV1s3XT0xLFdbOF09MSxXfWZ1bmN0aW9uIEEoVyl7cmV0dXJuIm1hdDMoIitXWzBdKyIsICIrV1sxXSsiLCAiK1dbMl0rIiwgIitXWzNdKyIsICIrV1s0XSsiLCAiK1dbNV0rIiwgIitXWzZdKyIsICIrV1s3XSsiLCAiK1dbOF0rIikifWZ1bmN0aW9uIEwoVyl7cmV0dXJuIE1hdGguaHlwb3QoV1swXSxXWzFdLFdbMl0sV1szXSxXWzRdLFdbNV0sV1s2XSxXWzddLFdbOF0pfWZ1bmN0aW9uIEQoVyxHLFEpe3JldHVybiBXWzBdPUdbMF0rUVswXSxXWzFdPUdbMV0rUVsxXSxXWzJdPUdbMl0rUVsyXSxXWzNdPUdbM10rUVszXSxXWzRdPUdbNF0rUVs0XSxXWzVdPUdbNV0rUVs1XSxXWzZdPUdbNl0rUVs2XSxXWzddPUdbN10rUVs3XSxXWzhdPUdbOF0rUVs4XSxXfWZ1bmN0aW9uIFIoVyxHLFEpe3JldHVybiBXWzBdPUdbMF0tUVswXSxXWzFdPUdbMV0tUVsxXSxXWzJdPUdbMl0tUVsyXSxXWzNdPUdbM10tUVszXSxXWzRdPUdbNF0tUVs0XSxXWzVdPUdbNV0tUVs1XSxXWzZdPUdbNl0tUVs2XSxXWzddPUdbN10tUVs3XSxXWzhdPUdbOF0tUVs4XSxXfWZ1bmN0aW9uIFMoVyxHLFEpe3JldHVybiBXWzBdPUdbMF0qUSxXWzFdPUdbMV0qUSxXWzJdPUdbMl0qUSxXWzNdPUdbM10qUSxXWzRdPUdbNF0qUSxXWzVdPUdbNV0qUSxXWzZdPUdbNl0qUSxXWzddPUdbN10qUSxXWzhdPUdbOF0qUSxXfWZ1bmN0aW9uIEIoVyxHLFEsdHQpe3JldHVybiBXWzBdPUdbMF0rUVswXSp0dCxXWzFdPUdbMV0rUVsxXSp0dCxXWzJdPUdbMl0rUVsyXSp0dCxXWzNdPUdbM10rUVszXSp0dCxXWzRdPUdbNF0rUVs0XSp0dCxXWzVdPUdbNV0rUVs1XSp0dCxXWzZdPUdbNl0rUVs2XSp0dCxXWzddPUdbN10rUVs3XSp0dCxXWzhdPUdbOF0rUVs4XSp0dCxXfWZ1bmN0aW9uIHcoVyxHKXtyZXR1cm4gV1swXT09PUdbMF0mJldbMV09PT1HWzFdJiZXWzJdPT09R1syXSYmV1szXT09PUdbM10mJldbNF09PT1HWzRdJiZXWzVdPT09R1s1XSYmV1s2XT09PUdbNl0mJldbN109PT1HWzddJiZXWzhdPT09R1s4XX1mdW5jdGlvbiBIKFcsRyl7dmFyIFE9V1swXSx0dD1XWzFdLF89V1syXSxzdD1XWzNdLGs9V1s0XSxjdD1XWzVdLGZ0PVdbNl0sVT1XWzddLEY9V1s4XSxWPUdbMF0sWD1HWzFdLGo9R1syXSx6PUdbM10sZD1HWzRdLEU9R1s1XSxOPUdbNl0sJD1HWzddLEs9R1s4XTtyZXR1cm4gTWF0aC5hYnMoUS1WKTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoUSksTWF0aC5hYnMoVikpJiZNYXRoLmFicyh0dC1YKTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnModHQpLE1hdGguYWJzKFgpKSYmTWF0aC5hYnMoXy1qKTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoXyksTWF0aC5hYnMoaikpJiZNYXRoLmFicyhzdC16KTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoc3QpLE1hdGguYWJzKHopKSYmTWF0aC5hYnMoay1kKTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoayksTWF0aC5hYnMoZCkpJiZNYXRoLmFicyhjdC1FKTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoY3QpLE1hdGguYWJzKEUpKSYmTWF0aC5hYnMoZnQtTik8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKGZ0KSxNYXRoLmFicyhOKSkmJk1hdGguYWJzKFUtJCk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKFUpLE1hdGguYWJzKCQpKSYmTWF0aC5hYnMoRi1LKTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoRiksTWF0aC5hYnMoSykpfXZhciBKPU8scT1SfSxmdW5jdGlvbihjLGUsdCl7dC5yKGUpLHQuZChlLCJjcmVhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIHN9KSx0LmQoZSwiY2xvbmUiLGZ1bmN0aW9uKCl7cmV0dXJuIGd9KSx0LmQoZSwiY29weSIsZnVuY3Rpb24oKXtyZXR1cm4gdn0pLHQuZChlLCJmcm9tVmFsdWVzIixmdW5jdGlvbigpe3JldHVybiBofSksdC5kKGUsInNldCIsZnVuY3Rpb24oKXtyZXR1cm4gbH0pLHQuZChlLCJpZGVudGl0eSIsZnVuY3Rpb24oKXtyZXR1cm4gdX0pLHQuZChlLCJ0cmFuc3Bvc2UiLGZ1bmN0aW9uKCl7cmV0dXJuIE19KSx0LmQoZSwiaW52ZXJ0IixmdW5jdGlvbigpe3JldHVybiBmfSksdC5kKGUsImFkam9pbnQiLGZ1bmN0aW9uKCl7cmV0dXJuIHl9KSx0LmQoZSwiZGV0ZXJtaW5hbnQiLGZ1bmN0aW9uKCl7cmV0dXJuIHh9KSx0LmQoZSwibXVsdGlwbHkiLGZ1bmN0aW9uKCl7cmV0dXJuIGJ9KSx0LmQoZSwidHJhbnNsYXRlIixmdW5jdGlvbigpe3JldHVybiBPfSksdC5kKGUsInNjYWxlIixmdW5jdGlvbigpe3JldHVybiBtfSksdC5kKGUsInJvdGF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gcH0pLHQuZChlLCJyb3RhdGVYIixmdW5jdGlvbigpe3JldHVybiBufSksdC5kKGUsInJvdGF0ZVkiLGZ1bmN0aW9uKCl7cmV0dXJuIGF9KSx0LmQoZSwicm90YXRlWiIsZnVuY3Rpb24oKXtyZXR1cm4gaX0pLHQuZChlLCJmcm9tVHJhbnNsYXRpb24iLGZ1bmN0aW9uKCl7cmV0dXJuIG99KSx0LmQoZSwiZnJvbVNjYWxpbmciLGZ1bmN0aW9uKCl7cmV0dXJuIFR9KSx0LmQoZSwiZnJvbVJvdGF0aW9uIixmdW5jdGlvbigpe3JldHVybiBQfSksdC5kKGUsImZyb21YUm90YXRpb24iLGZ1bmN0aW9uKCl7cmV0dXJuIEN9KSx0LmQoZSwiZnJvbVlSb3RhdGlvbiIsZnVuY3Rpb24oKXtyZXR1cm4gSX0pLHQuZChlLCJmcm9tWlJvdGF0aW9uIixmdW5jdGlvbigpe3JldHVybiBBfSksdC5kKGUsImZyb21Sb3RhdGlvblRyYW5zbGF0aW9uIixmdW5jdGlvbigpe3JldHVybiBMfSksdC5kKGUsImZyb21RdWF0MiIsZnVuY3Rpb24oKXtyZXR1cm4gRH0pLHQuZChlLCJnZXRUcmFuc2xhdGlvbiIsZnVuY3Rpb24oKXtyZXR1cm4gUn0pLHQuZChlLCJnZXRTY2FsaW5nIixmdW5jdGlvbigpe3JldHVybiBTfSksdC5kKGUsImdldFJvdGF0aW9uIixmdW5jdGlvbigpe3JldHVybiBCfSksdC5kKGUsImZyb21Sb3RhdGlvblRyYW5zbGF0aW9uU2NhbGUiLGZ1bmN0aW9uKCl7cmV0dXJuIHd9KSx0LmQoZSwiZnJvbVJvdGF0aW9uVHJhbnNsYXRpb25TY2FsZU9yaWdpbiIsZnVuY3Rpb24oKXtyZXR1cm4gSH0pLHQuZChlLCJmcm9tUXVhdCIsZnVuY3Rpb24oKXtyZXR1cm4gSn0pLHQuZChlLCJmcnVzdHVtIixmdW5jdGlvbigpe3JldHVybiBxfSksdC5kKGUsInBlcnNwZWN0aXZlIixmdW5jdGlvbigpe3JldHVybiBXfSksdC5kKGUsInBlcnNwZWN0aXZlRnJvbUZpZWxkT2ZWaWV3IixmdW5jdGlvbigpe3JldHVybiBHfSksdC5kKGUsIm9ydGhvIixmdW5jdGlvbigpe3JldHVybiBRfSksdC5kKGUsImxvb2tBdCIsZnVuY3Rpb24oKXtyZXR1cm4gdHR9KSx0LmQoZSwidGFyZ2V0VG8iLGZ1bmN0aW9uKCl7cmV0dXJuIF99KSx0LmQoZSwic3RyIixmdW5jdGlvbigpe3JldHVybiBzdH0pLHQuZChlLCJmcm9iIixmdW5jdGlvbigpe3JldHVybiBrfSksdC5kKGUsImFkZCIsZnVuY3Rpb24oKXtyZXR1cm4gY3R9KSx0LmQoZSwic3VidHJhY3QiLGZ1bmN0aW9uKCl7cmV0dXJuIGZ0fSksdC5kKGUsIm11bHRpcGx5U2NhbGFyIixmdW5jdGlvbigpe3JldHVybiBVfSksdC5kKGUsIm11bHRpcGx5U2NhbGFyQW5kQWRkIixmdW5jdGlvbigpe3JldHVybiBGfSksdC5kKGUsImV4YWN0RXF1YWxzIixmdW5jdGlvbigpe3JldHVybiBWfSksdC5kKGUsImVxdWFscyIsZnVuY3Rpb24oKXtyZXR1cm4gWH0pLHQuZChlLCJtdWwiLGZ1bmN0aW9uKCl7cmV0dXJuIGp9KSx0LmQoZSwic3ViIixmdW5jdGlvbigpe3JldHVybiB6fSk7dmFyIHI9dCgyKTtmdW5jdGlvbiBzKCl7dmFyIGQ9bmV3IHIuQVJSQVlfVFlQRSgxNik7cmV0dXJuIHIuQVJSQVlfVFlQRSE9RmxvYXQzMkFycmF5JiYoZFsxXT0wLGRbMl09MCxkWzNdPTAsZFs0XT0wLGRbNl09MCxkWzddPTAsZFs4XT0wLGRbOV09MCxkWzExXT0wLGRbMTJdPTAsZFsxM109MCxkWzE0XT0wKSxkWzBdPTEsZFs1XT0xLGRbMTBdPTEsZFsxNV09MSxkfWZ1bmN0aW9uIGcoZCl7dmFyIEU9bmV3IHIuQVJSQVlfVFlQRSgxNik7cmV0dXJuIEVbMF09ZFswXSxFWzFdPWRbMV0sRVsyXT1kWzJdLEVbM109ZFszXSxFWzRdPWRbNF0sRVs1XT1kWzVdLEVbNl09ZFs2XSxFWzddPWRbN10sRVs4XT1kWzhdLEVbOV09ZFs5XSxFWzEwXT1kWzEwXSxFWzExXT1kWzExXSxFWzEyXT1kWzEyXSxFWzEzXT1kWzEzXSxFWzE0XT1kWzE0XSxFWzE1XT1kWzE1XSxFfWZ1bmN0aW9uIHYoZCxFKXtyZXR1cm4gZFswXT1FWzBdLGRbMV09RVsxXSxkWzJdPUVbMl0sZFszXT1FWzNdLGRbNF09RVs0XSxkWzVdPUVbNV0sZFs2XT1FWzZdLGRbN109RVs3XSxkWzhdPUVbOF0sZFs5XT1FWzldLGRbMTBdPUVbMTBdLGRbMTFdPUVbMTFdLGRbMTJdPUVbMTJdLGRbMTNdPUVbMTNdLGRbMTRdPUVbMTRdLGRbMTVdPUVbMTVdLGR9ZnVuY3Rpb24gaChkLEUsTiwkLEssWSxaLGV0LHJ0LGF0LGx0LGl0LG50LG90LGR0LGd0KXt2YXIgdXQ9bmV3IHIuQVJSQVlfVFlQRSgxNik7cmV0dXJuIHV0WzBdPWQsdXRbMV09RSx1dFsyXT1OLHV0WzNdPSQsdXRbNF09Syx1dFs1XT1ZLHV0WzZdPVosdXRbN109ZXQsdXRbOF09cnQsdXRbOV09YXQsdXRbMTBdPWx0LHV0WzExXT1pdCx1dFsxMl09bnQsdXRbMTNdPW90LHV0WzE0XT1kdCx1dFsxNV09Z3QsdXR9ZnVuY3Rpb24gbChkLEUsTiwkLEssWSxaLGV0LHJ0LGF0LGx0LGl0LG50LG90LGR0LGd0LHV0KXtyZXR1cm4gZFswXT1FLGRbMV09TixkWzJdPSQsZFszXT1LLGRbNF09WSxkWzVdPVosZFs2XT1ldCxkWzddPXJ0LGRbOF09YXQsZFs5XT1sdCxkWzEwXT1pdCxkWzExXT1udCxkWzEyXT1vdCxkWzEzXT1kdCxkWzE0XT1ndCxkWzE1XT11dCxkfWZ1bmN0aW9uIHUoZCl7cmV0dXJuIGRbMF09MSxkWzFdPTAsZFsyXT0wLGRbM109MCxkWzRdPTAsZFs1XT0xLGRbNl09MCxkWzddPTAsZFs4XT0wLGRbOV09MCxkWzEwXT0xLGRbMTFdPTAsZFsxMl09MCxkWzEzXT0wLGRbMTRdPTAsZFsxNV09MSxkfWZ1bmN0aW9uIE0oZCxFKXtpZihkPT09RSl7dmFyIE49RVsxXSwkPUVbMl0sSz1FWzNdLFk9RVs2XSxaPUVbN10sZXQ9RVsxMV07ZFsxXT1FWzRdLGRbMl09RVs4XSxkWzNdPUVbMTJdLGRbNF09TixkWzZdPUVbOV0sZFs3XT1FWzEzXSxkWzhdPSQsZFs5XT1ZLGRbMTFdPUVbMTRdLGRbMTJdPUssZFsxM109WixkWzE0XT1ldH1lbHNlIGRbMF09RVswXSxkWzFdPUVbNF0sZFsyXT1FWzhdLGRbM109RVsxMl0sZFs0XT1FWzFdLGRbNV09RVs1XSxkWzZdPUVbOV0sZFs3XT1FWzEzXSxkWzhdPUVbMl0sZFs5XT1FWzZdLGRbMTBdPUVbMTBdLGRbMTFdPUVbMTRdLGRbMTJdPUVbM10sZFsxM109RVs3XSxkWzE0XT1FWzExXSxkWzE1XT1FWzE1XTtyZXR1cm4gZH1mdW5jdGlvbiBmKGQsRSl7dmFyIE49RVswXSwkPUVbMV0sSz1FWzJdLFk9RVszXSxaPUVbNF0sZXQ9RVs1XSxydD1FWzZdLGF0PUVbN10sbHQ9RVs4XSxpdD1FWzldLG50PUVbMTBdLG90PUVbMTFdLGR0PUVbMTJdLGd0PUVbMTNdLHV0PUVbMTRdLG10PUVbMTVdLE90PU4qZXQtJCpaLHl0PU4qcnQtSypaLHB0PU4qYXQtWSpaLHh0PSQqcnQtSypldCxNdD0kKmF0LVkqZXQsQnQ9SyphdC1ZKnJ0LEl0PWx0Kmd0LWl0KmR0LE50PWx0KnV0LW50KmR0LGp0PWx0Km10LW90KmR0LEZ0PWl0KnV0LW50Kmd0LFd0PWl0Km10LW90Kmd0LCR0PW50Km10LW90KnV0LFR0PU90KiR0LXl0Kld0K3B0KkZ0K3h0Kmp0LU10Kk50K0J0Kkl0O3JldHVybiBUdD8oVHQ9MS9UdCxkWzBdPShldCokdC1ydCpXdCthdCpGdCkqVHQsZFsxXT0oSypXdC0kKiR0LVkqRnQpKlR0LGRbMl09KGd0KkJ0LXV0Kk10K210Knh0KSpUdCxkWzNdPShudCpNdC1pdCpCdC1vdCp4dCkqVHQsZFs0XT0ocnQqanQtWiokdC1hdCpOdCkqVHQsZFs1XT0oTiokdC1LKmp0K1kqTnQpKlR0LGRbNl09KHV0KnB0LWR0KkJ0LW10Knl0KSpUdCxkWzddPShsdCpCdC1udCpwdCtvdCp5dCkqVHQsZFs4XT0oWipXdC1ldCpqdCthdCpJdCkqVHQsZFs5XT0oJCpqdC1OKld0LVkqSXQpKlR0LGRbMTBdPShkdCpNdC1ndCpwdCttdCpPdCkqVHQsZFsxMV09KGl0KnB0LWx0Kk10LW90Kk90KSpUdCxkWzEyXT0oZXQqTnQtWipGdC1ydCpJdCkqVHQsZFsxM109KE4qRnQtJCpOdCtLKkl0KSpUdCxkWzE0XT0oZ3QqeXQtZHQqeHQtdXQqT3QpKlR0LGRbMTVdPShsdCp4dC1pdCp5dCtudCpPdCkqVHQsZCk6bnVsbH1mdW5jdGlvbiB5KGQsRSl7dmFyIE49RVswXSwkPUVbMV0sSz1FWzJdLFk9RVszXSxaPUVbNF0sZXQ9RVs1XSxydD1FWzZdLGF0PUVbN10sbHQ9RVs4XSxpdD1FWzldLG50PUVbMTBdLG90PUVbMTFdLGR0PUVbMTJdLGd0PUVbMTNdLHV0PUVbMTRdLG10PUVbMTVdO3JldHVybiBkWzBdPWV0KihudCptdC1vdCp1dCktaXQqKHJ0Km10LWF0KnV0KStndCoocnQqb3QtYXQqbnQpLGRbMV09LSgkKihudCptdC1vdCp1dCktaXQqKEsqbXQtWSp1dCkrZ3QqKEsqb3QtWSpudCkpLGRbMl09JCoocnQqbXQtYXQqdXQpLWV0KihLKm10LVkqdXQpK2d0KihLKmF0LVkqcnQpLGRbM109LSgkKihydCpvdC1hdCpudCktZXQqKEsqb3QtWSpudCkraXQqKEsqYXQtWSpydCkpLGRbNF09LShaKihudCptdC1vdCp1dCktbHQqKHJ0Km10LWF0KnV0KStkdCoocnQqb3QtYXQqbnQpKSxkWzVdPU4qKG50Km10LW90KnV0KS1sdCooSyptdC1ZKnV0KStkdCooSypvdC1ZKm50KSxkWzZdPS0oTioocnQqbXQtYXQqdXQpLVoqKEsqbXQtWSp1dCkrZHQqKEsqYXQtWSpydCkpLGRbN109TioocnQqb3QtYXQqbnQpLVoqKEsqb3QtWSpudCkrbHQqKEsqYXQtWSpydCksZFs4XT1aKihpdCptdC1vdCpndCktbHQqKGV0Km10LWF0Kmd0KStkdCooZXQqb3QtYXQqaXQpLGRbOV09LShOKihpdCptdC1vdCpndCktbHQqKCQqbXQtWSpndCkrZHQqKCQqb3QtWSppdCkpLGRbMTBdPU4qKGV0Km10LWF0Kmd0KS1aKigkKm10LVkqZ3QpK2R0KigkKmF0LVkqZXQpLGRbMTFdPS0oTiooZXQqb3QtYXQqaXQpLVoqKCQqb3QtWSppdCkrbHQqKCQqYXQtWSpldCkpLGRbMTJdPS0oWiooaXQqdXQtbnQqZ3QpLWx0KihldCp1dC1ydCpndCkrZHQqKGV0Km50LXJ0Kml0KSksZFsxM109TiooaXQqdXQtbnQqZ3QpLWx0KigkKnV0LUsqZ3QpK2R0KigkKm50LUsqaXQpLGRbMTRdPS0oTiooZXQqdXQtcnQqZ3QpLVoqKCQqdXQtSypndCkrZHQqKCQqcnQtSypldCkpLGRbMTVdPU4qKGV0Km50LXJ0Kml0KS1aKigkKm50LUsqaXQpK2x0KigkKnJ0LUsqZXQpLGR9ZnVuY3Rpb24geChkKXt2YXIgRT1kWzBdLE49ZFsxXSwkPWRbMl0sSz1kWzNdLFk9ZFs0XSxaPWRbNV0sZXQ9ZFs2XSxydD1kWzddLGF0PWRbOF0sbHQ9ZFs5XSxpdD1kWzEwXSxudD1kWzExXSxvdD1kWzEyXSxkdD1kWzEzXSxndD1kWzE0XSx1dD1kWzE1XSxtdD1FKlotTipZLE90PUUqZXQtJCpZLHl0PUUqcnQtSypZLHB0PU4qZXQtJCpaLHh0PU4qcnQtSypaLE10PSQqcnQtSypldCxCdD1hdCpkdC1sdCpvdCxJdD1hdCpndC1pdCpvdCxOdD1hdCp1dC1udCpvdCxqdD1sdCpndC1pdCpkdCxGdD1sdCp1dC1udCpkdCxXdD1pdCp1dC1udCpndDtyZXR1cm4gbXQqV3QtT3QqRnQreXQqanQrcHQqTnQteHQqSXQrTXQqQnR9ZnVuY3Rpb24gYihkLEUsTil7dmFyICQ9RVswXSxLPUVbMV0sWT1FWzJdLFo9RVszXSxldD1FWzRdLHJ0PUVbNV0sYXQ9RVs2XSxsdD1FWzddLGl0PUVbOF0sbnQ9RVs5XSxvdD1FWzEwXSxkdD1FWzExXSxndD1FWzEyXSx1dD1FWzEzXSxtdD1FWzE0XSxPdD1FWzE1XSx5dD1OWzBdLHB0PU5bMV0seHQ9TlsyXSxNdD1OWzNdO3JldHVybiBkWzBdPXl0KiQrcHQqZXQreHQqaXQrTXQqZ3QsZFsxXT15dCpLK3B0KnJ0K3h0Km50K010KnV0LGRbMl09eXQqWStwdCphdCt4dCpvdCtNdCptdCxkWzNdPXl0KlorcHQqbHQreHQqZHQrTXQqT3QseXQ9Tls0XSxwdD1OWzVdLHh0PU5bNl0sTXQ9Tls3XSxkWzRdPXl0KiQrcHQqZXQreHQqaXQrTXQqZ3QsZFs1XT15dCpLK3B0KnJ0K3h0Km50K010KnV0LGRbNl09eXQqWStwdCphdCt4dCpvdCtNdCptdCxkWzddPXl0KlorcHQqbHQreHQqZHQrTXQqT3QseXQ9Tls4XSxwdD1OWzldLHh0PU5bMTBdLE10PU5bMTFdLGRbOF09eXQqJCtwdCpldCt4dCppdCtNdCpndCxkWzldPXl0KksrcHQqcnQreHQqbnQrTXQqdXQsZFsxMF09eXQqWStwdCphdCt4dCpvdCtNdCptdCxkWzExXT15dCpaK3B0Kmx0K3h0KmR0K010Kk90LHl0PU5bMTJdLHB0PU5bMTNdLHh0PU5bMTRdLE10PU5bMTVdLGRbMTJdPXl0KiQrcHQqZXQreHQqaXQrTXQqZ3QsZFsxM109eXQqSytwdCpydCt4dCpudCtNdCp1dCxkWzE0XT15dCpZK3B0KmF0K3h0Km90K010Km10LGRbMTVdPXl0KlorcHQqbHQreHQqZHQrTXQqT3QsZH1mdW5jdGlvbiBPKGQsRSxOKXt2YXIgJD1OWzBdLEs9TlsxXSxZPU5bMl0sWixldCxydCxhdCxsdCxpdCxudCxvdCxkdCxndCx1dCxtdDtyZXR1cm4gRT09PWQ/KGRbMTJdPUVbMF0qJCtFWzRdKksrRVs4XSpZK0VbMTJdLGRbMTNdPUVbMV0qJCtFWzVdKksrRVs5XSpZK0VbMTNdLGRbMTRdPUVbMl0qJCtFWzZdKksrRVsxMF0qWStFWzE0XSxkWzE1XT1FWzNdKiQrRVs3XSpLK0VbMTFdKlkrRVsxNV0pOihaPUVbMF0sZXQ9RVsxXSxydD1FWzJdLGF0PUVbM10sbHQ9RVs0XSxpdD1FWzVdLG50PUVbNl0sb3Q9RVs3XSxkdD1FWzhdLGd0PUVbOV0sdXQ9RVsxMF0sbXQ9RVsxMV0sZFswXT1aLGRbMV09ZXQsZFsyXT1ydCxkWzNdPWF0LGRbNF09bHQsZFs1XT1pdCxkWzZdPW50LGRbN109b3QsZFs4XT1kdCxkWzldPWd0LGRbMTBdPXV0LGRbMTFdPW10LGRbMTJdPVoqJCtsdCpLK2R0KlkrRVsxMl0sZFsxM109ZXQqJCtpdCpLK2d0KlkrRVsxM10sZFsxNF09cnQqJCtudCpLK3V0KlkrRVsxNF0sZFsxNV09YXQqJCtvdCpLK210KlkrRVsxNV0pLGR9ZnVuY3Rpb24gbShkLEUsTil7dmFyICQ9TlswXSxLPU5bMV0sWT1OWzJdO3JldHVybiBkWzBdPUVbMF0qJCxkWzFdPUVbMV0qJCxkWzJdPUVbMl0qJCxkWzNdPUVbM10qJCxkWzRdPUVbNF0qSyxkWzVdPUVbNV0qSyxkWzZdPUVbNl0qSyxkWzddPUVbN10qSyxkWzhdPUVbOF0qWSxkWzldPUVbOV0qWSxkWzEwXT1FWzEwXSpZLGRbMTFdPUVbMTFdKlksZFsxMl09RVsxMl0sZFsxM109RVsxM10sZFsxNF09RVsxNF0sZFsxNV09RVsxNV0sZH1mdW5jdGlvbiBwKGQsRSxOLCQpe3ZhciBLPSRbMF0sWT0kWzFdLFo9JFsyXSxldD1NYXRoLmh5cG90KEssWSxaKSxydCxhdCxsdCxpdCxudCxvdCxkdCxndCx1dCxtdCxPdCx5dCxwdCx4dCxNdCxCdCxJdCxOdCxqdCxGdCxXdCwkdCxUdCx3dDtyZXR1cm4gZXQ8ci5FUFNJTE9OP251bGw6KGV0PTEvZXQsSyo9ZXQsWSo9ZXQsWio9ZXQscnQ9TWF0aC5zaW4oTiksYXQ9TWF0aC5jb3MoTiksbHQ9MS1hdCxpdD1FWzBdLG50PUVbMV0sb3Q9RVsyXSxkdD1FWzNdLGd0PUVbNF0sdXQ9RVs1XSxtdD1FWzZdLE90PUVbN10seXQ9RVs4XSxwdD1FWzldLHh0PUVbMTBdLE10PUVbMTFdLEJ0PUsqSypsdCthdCxJdD1ZKksqbHQrWipydCxOdD1aKksqbHQtWSpydCxqdD1LKlkqbHQtWipydCxGdD1ZKlkqbHQrYXQsV3Q9WipZKmx0K0sqcnQsJHQ9SypaKmx0K1kqcnQsVHQ9WSpaKmx0LUsqcnQsd3Q9WipaKmx0K2F0LGRbMF09aXQqQnQrZ3QqSXQreXQqTnQsZFsxXT1udCpCdCt1dCpJdCtwdCpOdCxkWzJdPW90KkJ0K210Kkl0K3h0Kk50LGRbM109ZHQqQnQrT3QqSXQrTXQqTnQsZFs0XT1pdCpqdCtndCpGdCt5dCpXdCxkWzVdPW50Kmp0K3V0KkZ0K3B0Kld0LGRbNl09b3QqanQrbXQqRnQreHQqV3QsZFs3XT1kdCpqdCtPdCpGdCtNdCpXdCxkWzhdPWl0KiR0K2d0KlR0K3l0Knd0LGRbOV09bnQqJHQrdXQqVHQrcHQqd3QsZFsxMF09b3QqJHQrbXQqVHQreHQqd3QsZFsxMV09ZHQqJHQrT3QqVHQrTXQqd3QsRSE9PWQmJihkWzEyXT1FWzEyXSxkWzEzXT1FWzEzXSxkWzE0XT1FWzE0XSxkWzE1XT1FWzE1XSksZCl9ZnVuY3Rpb24gbihkLEUsTil7dmFyICQ9TWF0aC5zaW4oTiksSz1NYXRoLmNvcyhOKSxZPUVbNF0sWj1FWzVdLGV0PUVbNl0scnQ9RVs3XSxhdD1FWzhdLGx0PUVbOV0saXQ9RVsxMF0sbnQ9RVsxMV07cmV0dXJuIEUhPT1kJiYoZFswXT1FWzBdLGRbMV09RVsxXSxkWzJdPUVbMl0sZFszXT1FWzNdLGRbMTJdPUVbMTJdLGRbMTNdPUVbMTNdLGRbMTRdPUVbMTRdLGRbMTVdPUVbMTVdKSxkWzRdPVkqSythdCokLGRbNV09WipLK2x0KiQsZFs2XT1ldCpLK2l0KiQsZFs3XT1ydCpLK250KiQsZFs4XT1hdCpLLVkqJCxkWzldPWx0KkstWiokLGRbMTBdPWl0KkstZXQqJCxkWzExXT1udCpLLXJ0KiQsZH1mdW5jdGlvbiBhKGQsRSxOKXt2YXIgJD1NYXRoLnNpbihOKSxLPU1hdGguY29zKE4pLFk9RVswXSxaPUVbMV0sZXQ9RVsyXSxydD1FWzNdLGF0PUVbOF0sbHQ9RVs5XSxpdD1FWzEwXSxudD1FWzExXTtyZXR1cm4gRSE9PWQmJihkWzRdPUVbNF0sZFs1XT1FWzVdLGRbNl09RVs2XSxkWzddPUVbN10sZFsxMl09RVsxMl0sZFsxM109RVsxM10sZFsxNF09RVsxNF0sZFsxNV09RVsxNV0pLGRbMF09WSpLLWF0KiQsZFsxXT1aKkstbHQqJCxkWzJdPWV0KkstaXQqJCxkWzNdPXJ0KkstbnQqJCxkWzhdPVkqJCthdCpLLGRbOV09WiokK2x0KkssZFsxMF09ZXQqJCtpdCpLLGRbMTFdPXJ0KiQrbnQqSyxkfWZ1bmN0aW9uIGkoZCxFLE4pe3ZhciAkPU1hdGguc2luKE4pLEs9TWF0aC5jb3MoTiksWT1FWzBdLFo9RVsxXSxldD1FWzJdLHJ0PUVbM10sYXQ9RVs0XSxsdD1FWzVdLGl0PUVbNl0sbnQ9RVs3XTtyZXR1cm4gRSE9PWQmJihkWzhdPUVbOF0sZFs5XT1FWzldLGRbMTBdPUVbMTBdLGRbMTFdPUVbMTFdLGRbMTJdPUVbMTJdLGRbMTNdPUVbMTNdLGRbMTRdPUVbMTRdLGRbMTVdPUVbMTVdKSxkWzBdPVkqSythdCokLGRbMV09WipLK2x0KiQsZFsyXT1ldCpLK2l0KiQsZFszXT1ydCpLK250KiQsZFs0XT1hdCpLLVkqJCxkWzVdPWx0KkstWiokLGRbNl09aXQqSy1ldCokLGRbN109bnQqSy1ydCokLGR9ZnVuY3Rpb24gbyhkLEUpe3JldHVybiBkWzBdPTEsZFsxXT0wLGRbMl09MCxkWzNdPTAsZFs0XT0wLGRbNV09MSxkWzZdPTAsZFs3XT0wLGRbOF09MCxkWzldPTAsZFsxMF09MSxkWzExXT0wLGRbMTJdPUVbMF0sZFsxM109RVsxXSxkWzE0XT1FWzJdLGRbMTVdPTEsZH1mdW5jdGlvbiBUKGQsRSl7cmV0dXJuIGRbMF09RVswXSxkWzFdPTAsZFsyXT0wLGRbM109MCxkWzRdPTAsZFs1XT1FWzFdLGRbNl09MCxkWzddPTAsZFs4XT0wLGRbOV09MCxkWzEwXT1FWzJdLGRbMTFdPTAsZFsxMl09MCxkWzEzXT0wLGRbMTRdPTAsZFsxNV09MSxkfWZ1bmN0aW9uIFAoZCxFLE4pe3ZhciAkPU5bMF0sSz1OWzFdLFk9TlsyXSxaPU1hdGguaHlwb3QoJCxLLFkpLGV0LHJ0LGF0O3JldHVybiBaPHIuRVBTSUxPTj9udWxsOihaPTEvWiwkKj1aLEsqPVosWSo9WixldD1NYXRoLnNpbihFKSxydD1NYXRoLmNvcyhFKSxhdD0xLXJ0LGRbMF09JCokKmF0K3J0LGRbMV09SyokKmF0K1kqZXQsZFsyXT1ZKiQqYXQtSypldCxkWzNdPTAsZFs0XT0kKksqYXQtWSpldCxkWzVdPUsqSyphdCtydCxkWzZdPVkqSyphdCskKmV0LGRbN109MCxkWzhdPSQqWSphdCtLKmV0LGRbOV09SypZKmF0LSQqZXQsZFsxMF09WSpZKmF0K3J0LGRbMTFdPTAsZFsxMl09MCxkWzEzXT0wLGRbMTRdPTAsZFsxNV09MSxkKX1mdW5jdGlvbiBDKGQsRSl7dmFyIE49TWF0aC5zaW4oRSksJD1NYXRoLmNvcyhFKTtyZXR1cm4gZFswXT0xLGRbMV09MCxkWzJdPTAsZFszXT0wLGRbNF09MCxkWzVdPSQsZFs2XT1OLGRbN109MCxkWzhdPTAsZFs5XT0tTixkWzEwXT0kLGRbMTFdPTAsZFsxMl09MCxkWzEzXT0wLGRbMTRdPTAsZFsxNV09MSxkfWZ1bmN0aW9uIEkoZCxFKXt2YXIgTj1NYXRoLnNpbihFKSwkPU1hdGguY29zKEUpO3JldHVybiBkWzBdPSQsZFsxXT0wLGRbMl09LU4sZFszXT0wLGRbNF09MCxkWzVdPTEsZFs2XT0wLGRbN109MCxkWzhdPU4sZFs5XT0wLGRbMTBdPSQsZFsxMV09MCxkWzEyXT0wLGRbMTNdPTAsZFsxNF09MCxkWzE1XT0xLGR9ZnVuY3Rpb24gQShkLEUpe3ZhciBOPU1hdGguc2luKEUpLCQ9TWF0aC5jb3MoRSk7cmV0dXJuIGRbMF09JCxkWzFdPU4sZFsyXT0wLGRbM109MCxkWzRdPS1OLGRbNV09JCxkWzZdPTAsZFs3XT0wLGRbOF09MCxkWzldPTAsZFsxMF09MSxkWzExXT0wLGRbMTJdPTAsZFsxM109MCxkWzE0XT0wLGRbMTVdPTEsZH1mdW5jdGlvbiBMKGQsRSxOKXt2YXIgJD1FWzBdLEs9RVsxXSxZPUVbMl0sWj1FWzNdLGV0PSQrJCxydD1LK0ssYXQ9WStZLGx0PSQqZXQsaXQ9JCpydCxudD0kKmF0LG90PUsqcnQsZHQ9SyphdCxndD1ZKmF0LHV0PVoqZXQsbXQ9WipydCxPdD1aKmF0O3JldHVybiBkWzBdPTEtKG90K2d0KSxkWzFdPWl0K090LGRbMl09bnQtbXQsZFszXT0wLGRbNF09aXQtT3QsZFs1XT0xLShsdCtndCksZFs2XT1kdCt1dCxkWzddPTAsZFs4XT1udCttdCxkWzldPWR0LXV0LGRbMTBdPTEtKGx0K290KSxkWzExXT0wLGRbMTJdPU5bMF0sZFsxM109TlsxXSxkWzE0XT1OWzJdLGRbMTVdPTEsZH1mdW5jdGlvbiBEKGQsRSl7dmFyIE49bmV3IHIuQVJSQVlfVFlQRSgzKSwkPS1FWzBdLEs9LUVbMV0sWT0tRVsyXSxaPUVbM10sZXQ9RVs0XSxydD1FWzVdLGF0PUVbNl0sbHQ9RVs3XSxpdD0kKiQrSypLK1kqWStaKlo7cmV0dXJuIGl0PjA/KE5bMF09KGV0KlorbHQqJCtydCpZLWF0KkspKjIvaXQsTlsxXT0ocnQqWitsdCpLK2F0KiQtZXQqWSkqMi9pdCxOWzJdPShhdCpaK2x0KlkrZXQqSy1ydCokKSoyL2l0KTooTlswXT0oZXQqWitsdCokK3J0KlktYXQqSykqMixOWzFdPShydCpaK2x0KksrYXQqJC1ldCpZKSoyLE5bMl09KGF0KlorbHQqWStldCpLLXJ0KiQpKjIpLEwoZCxFLE4pLGR9ZnVuY3Rpb24gUihkLEUpe3JldHVybiBkWzBdPUVbMTJdLGRbMV09RVsxM10sZFsyXT1FWzE0XSxkfWZ1bmN0aW9uIFMoZCxFKXt2YXIgTj1FWzBdLCQ9RVsxXSxLPUVbMl0sWT1FWzRdLFo9RVs1XSxldD1FWzZdLHJ0PUVbOF0sYXQ9RVs5XSxsdD1FWzEwXTtyZXR1cm4gZFswXT1NYXRoLmh5cG90KE4sJCxLKSxkWzFdPU1hdGguaHlwb3QoWSxaLGV0KSxkWzJdPU1hdGguaHlwb3QocnQsYXQsbHQpLGR9ZnVuY3Rpb24gQihkLEUpe3ZhciBOPW5ldyByLkFSUkFZX1RZUEUoMyk7UyhOLEUpO3ZhciAkPTEvTlswXSxLPTEvTlsxXSxZPTEvTlsyXSxaPUVbMF0qJCxldD1FWzFdKksscnQ9RVsyXSpZLGF0PUVbNF0qJCxsdD1FWzVdKkssaXQ9RVs2XSpZLG50PUVbOF0qJCxvdD1FWzldKkssZHQ9RVsxMF0qWSxndD1aK2x0K2R0LHV0PTA7cmV0dXJuIGd0PjA/KHV0PU1hdGguc3FydChndCsxKSoyLGRbM109LjI1KnV0LGRbMF09KGl0LW90KS91dCxkWzFdPShudC1ydCkvdXQsZFsyXT0oZXQtYXQpL3V0KTpaPmx0JiZaPmR0Pyh1dD1NYXRoLnNxcnQoMStaLWx0LWR0KSoyLGRbM109KGl0LW90KS91dCxkWzBdPS4yNSp1dCxkWzFdPShldCthdCkvdXQsZFsyXT0obnQrcnQpL3V0KTpsdD5kdD8odXQ9TWF0aC5zcXJ0KDErbHQtWi1kdCkqMixkWzNdPShudC1ydCkvdXQsZFswXT0oZXQrYXQpL3V0LGRbMV09LjI1KnV0LGRbMl09KGl0K290KS91dCk6KHV0PU1hdGguc3FydCgxK2R0LVotbHQpKjIsZFszXT0oZXQtYXQpL3V0LGRbMF09KG50K3J0KS91dCxkWzFdPShpdCtvdCkvdXQsZFsyXT0uMjUqdXQpLGR9ZnVuY3Rpb24gdyhkLEUsTiwkKXt2YXIgSz1FWzBdLFk9RVsxXSxaPUVbMl0sZXQ9RVszXSxydD1LK0ssYXQ9WStZLGx0PVorWixpdD1LKnJ0LG50PUsqYXQsb3Q9SypsdCxkdD1ZKmF0LGd0PVkqbHQsdXQ9WipsdCxtdD1ldCpydCxPdD1ldCphdCx5dD1ldCpsdCxwdD0kWzBdLHh0PSRbMV0sTXQ9JFsyXTtyZXR1cm4gZFswXT0oMS0oZHQrdXQpKSpwdCxkWzFdPShudCt5dCkqcHQsZFsyXT0ob3QtT3QpKnB0LGRbM109MCxkWzRdPShudC15dCkqeHQsZFs1XT0oMS0oaXQrdXQpKSp4dCxkWzZdPShndCttdCkqeHQsZFs3XT0wLGRbOF09KG90K090KSpNdCxkWzldPShndC1tdCkqTXQsZFsxMF09KDEtKGl0K2R0KSkqTXQsZFsxMV09MCxkWzEyXT1OWzBdLGRbMTNdPU5bMV0sZFsxNF09TlsyXSxkWzE1XT0xLGR9ZnVuY3Rpb24gSChkLEUsTiwkLEspe3ZhciBZPUVbMF0sWj1FWzFdLGV0PUVbMl0scnQ9RVszXSxhdD1ZK1ksbHQ9WitaLGl0PWV0K2V0LG50PVkqYXQsb3Q9WSpsdCxkdD1ZKml0LGd0PVoqbHQsdXQ9WippdCxtdD1ldCppdCxPdD1ydCphdCx5dD1ydCpsdCxwdD1ydCppdCx4dD0kWzBdLE10PSRbMV0sQnQ9JFsyXSxJdD1LWzBdLE50PUtbMV0sanQ9S1syXSxGdD0oMS0oZ3QrbXQpKSp4dCxXdD0ob3QrcHQpKnh0LCR0PShkdC15dCkqeHQsVHQ9KG90LXB0KSpNdCx3dD0oMS0obnQrbXQpKSpNdCx1ZT0odXQrT3QpKk10LGNlPShkdCt5dCkqQnQsZW49KHV0LU90KSpCdCxybj0oMS0obnQrZ3QpKSpCdDtyZXR1cm4gZFswXT1GdCxkWzFdPVd0LGRbMl09JHQsZFszXT0wLGRbNF09VHQsZFs1XT13dCxkWzZdPXVlLGRbN109MCxkWzhdPWNlLGRbOV09ZW4sZFsxMF09cm4sZFsxMV09MCxkWzEyXT1OWzBdK0l0LShGdCpJdCtUdCpOdCtjZSpqdCksZFsxM109TlsxXStOdC0oV3QqSXQrd3QqTnQrZW4qanQpLGRbMTRdPU5bMl0ranQtKCR0Kkl0K3VlKk50K3JuKmp0KSxkWzE1XT0xLGR9ZnVuY3Rpb24gSihkLEUpe3ZhciBOPUVbMF0sJD1FWzFdLEs9RVsyXSxZPUVbM10sWj1OK04sZXQ9JCskLHJ0PUsrSyxhdD1OKlosbHQ9JCpaLGl0PSQqZXQsbnQ9SypaLG90PUsqZXQsZHQ9SypydCxndD1ZKlosdXQ9WSpldCxtdD1ZKnJ0O3JldHVybiBkWzBdPTEtaXQtZHQsZFsxXT1sdCttdCxkWzJdPW50LXV0LGRbM109MCxkWzRdPWx0LW10LGRbNV09MS1hdC1kdCxkWzZdPW90K2d0LGRbN109MCxkWzhdPW50K3V0LGRbOV09b3QtZ3QsZFsxMF09MS1hdC1pdCxkWzExXT0wLGRbMTJdPTAsZFsxM109MCxkWzE0XT0wLGRbMTVdPTEsZH1mdW5jdGlvbiBxKGQsRSxOLCQsSyxZLFope3ZhciBldD0xLyhOLUUpLHJ0PTEvKEstJCksYXQ9MS8oWS1aKTtyZXR1cm4gZFswXT1ZKjIqZXQsZFsxXT0wLGRbMl09MCxkWzNdPTAsZFs0XT0wLGRbNV09WSoyKnJ0LGRbNl09MCxkWzddPTAsZFs4XT0oTitFKSpldCxkWzldPShLKyQpKnJ0LGRbMTBdPShaK1kpKmF0LGRbMTFdPS0xLGRbMTJdPTAsZFsxM109MCxkWzE0XT1aKlkqMiphdCxkWzE1XT0wLGR9ZnVuY3Rpb24gVyhkLEUsTiwkLEspe3ZhciBZPTEvTWF0aC50YW4oRS8yKSxaO3JldHVybiBkWzBdPVkvTixkWzFdPTAsZFsyXT0wLGRbM109MCxkWzRdPTAsZFs1XT1ZLGRbNl09MCxkWzddPTAsZFs4XT0wLGRbOV09MCxkWzExXT0tMSxkWzEyXT0wLGRbMTNdPTAsZFsxNV09MCxLIT1udWxsJiZLIT09MS8wPyhaPTEvKCQtSyksZFsxMF09KEsrJCkqWixkWzE0XT0yKksqJCpaKTooZFsxMF09LTEsZFsxNF09LTIqJCksZH1mdW5jdGlvbiBHKGQsRSxOLCQpe3ZhciBLPU1hdGgudGFuKEUudXBEZWdyZWVzKk1hdGguUEkvMTgwKSxZPU1hdGgudGFuKEUuZG93bkRlZ3JlZXMqTWF0aC5QSS8xODApLFo9TWF0aC50YW4oRS5sZWZ0RGVncmVlcypNYXRoLlBJLzE4MCksZXQ9TWF0aC50YW4oRS5yaWdodERlZ3JlZXMqTWF0aC5QSS8xODApLHJ0PTIvKForZXQpLGF0PTIvKEsrWSk7cmV0dXJuIGRbMF09cnQsZFsxXT0wLGRbMl09MCxkWzNdPTAsZFs0XT0wLGRbNV09YXQsZFs2XT0wLGRbN109MCxkWzhdPS0oKFotZXQpKnJ0Ki41KSxkWzldPShLLVkpKmF0Ki41LGRbMTBdPSQvKE4tJCksZFsxMV09LTEsZFsxMl09MCxkWzEzXT0wLGRbMTRdPSQqTi8oTi0kKSxkWzE1XT0wLGR9ZnVuY3Rpb24gUShkLEUsTiwkLEssWSxaKXt2YXIgZXQ9MS8oRS1OKSxydD0xLygkLUspLGF0PTEvKFktWik7cmV0dXJuIGRbMF09LTIqZXQsZFsxXT0wLGRbMl09MCxkWzNdPTAsZFs0XT0wLGRbNV09LTIqcnQsZFs2XT0wLGRbN109MCxkWzhdPTAsZFs5XT0wLGRbMTBdPTIqYXQsZFsxMV09MCxkWzEyXT0oRStOKSpldCxkWzEzXT0oSyskKSpydCxkWzE0XT0oWitZKSphdCxkWzE1XT0xLGR9ZnVuY3Rpb24gdHQoZCxFLE4sJCl7dmFyIEssWSxaLGV0LHJ0LGF0LGx0LGl0LG50LG90LGR0PUVbMF0sZ3Q9RVsxXSx1dD1FWzJdLG10PSRbMF0sT3Q9JFsxXSx5dD0kWzJdLHB0PU5bMF0seHQ9TlsxXSxNdD1OWzJdO3JldHVybiBNYXRoLmFicyhkdC1wdCk8ci5FUFNJTE9OJiZNYXRoLmFicyhndC14dCk8ci5FUFNJTE9OJiZNYXRoLmFicyh1dC1NdCk8ci5FUFNJTE9OP3UoZCk6KGx0PWR0LXB0LGl0PWd0LXh0LG50PXV0LU10LG90PTEvTWF0aC5oeXBvdChsdCxpdCxudCksbHQqPW90LGl0Kj1vdCxudCo9b3QsSz1PdCpudC15dCppdCxZPXl0Kmx0LW10Km50LFo9bXQqaXQtT3QqbHQsb3Q9TWF0aC5oeXBvdChLLFksWiksb3Q/KG90PTEvb3QsSyo9b3QsWSo9b3QsWio9b3QpOihLPTAsWT0wLFo9MCksZXQ9aXQqWi1udCpZLHJ0PW50KkstbHQqWixhdD1sdCpZLWl0Kkssb3Q9TWF0aC5oeXBvdChldCxydCxhdCksb3Q/KG90PTEvb3QsZXQqPW90LHJ0Kj1vdCxhdCo9b3QpOihldD0wLHJ0PTAsYXQ9MCksZFswXT1LLGRbMV09ZXQsZFsyXT1sdCxkWzNdPTAsZFs0XT1ZLGRbNV09cnQsZFs2XT1pdCxkWzddPTAsZFs4XT1aLGRbOV09YXQsZFsxMF09bnQsZFsxMV09MCxkWzEyXT0tKEsqZHQrWSpndCtaKnV0KSxkWzEzXT0tKGV0KmR0K3J0Kmd0K2F0KnV0KSxkWzE0XT0tKGx0KmR0K2l0Kmd0K250KnV0KSxkWzE1XT0xLGQpfWZ1bmN0aW9uIF8oZCxFLE4sJCl7dmFyIEs9RVswXSxZPUVbMV0sWj1FWzJdLGV0PSRbMF0scnQ9JFsxXSxhdD0kWzJdLGx0PUstTlswXSxpdD1ZLU5bMV0sbnQ9Wi1OWzJdLG90PWx0Kmx0K2l0Kml0K250Km50O290PjAmJihvdD0xL01hdGguc3FydChvdCksbHQqPW90LGl0Kj1vdCxudCo9b3QpO3ZhciBkdD1ydCpudC1hdCppdCxndD1hdCpsdC1ldCpudCx1dD1ldCppdC1ydCpsdDtyZXR1cm4gb3Q9ZHQqZHQrZ3QqZ3QrdXQqdXQsb3Q+MCYmKG90PTEvTWF0aC5zcXJ0KG90KSxkdCo9b3QsZ3QqPW90LHV0Kj1vdCksZFswXT1kdCxkWzFdPWd0LGRbMl09dXQsZFszXT0wLGRbNF09aXQqdXQtbnQqZ3QsZFs1XT1udCpkdC1sdCp1dCxkWzZdPWx0Kmd0LWl0KmR0LGRbN109MCxkWzhdPWx0LGRbOV09aXQsZFsxMF09bnQsZFsxMV09MCxkWzEyXT1LLGRbMTNdPVksZFsxNF09WixkWzE1XT0xLGR9ZnVuY3Rpb24gc3QoZCl7cmV0dXJuIm1hdDQoIitkWzBdKyIsICIrZFsxXSsiLCAiK2RbMl0rIiwgIitkWzNdKyIsICIrZFs0XSsiLCAiK2RbNV0rIiwgIitkWzZdKyIsICIrZFs3XSsiLCAiK2RbOF0rIiwgIitkWzldKyIsICIrZFsxMF0rIiwgIitkWzExXSsiLCAiK2RbMTJdKyIsICIrZFsxM10rIiwgIitkWzE0XSsiLCAiK2RbMTVdKyIpIn1mdW5jdGlvbiBrKGQpe3JldHVybiBNYXRoLmh5cG90KGRbMF0sZFsxXSxkWzJdLGRbM10sZFs0XSxkWzVdLGRbNl0sZFs3XSxkWzhdLGRbOV0sZFsxMF0sZFsxMV0sZFsxMl0sZFsxM10sZFsxNF0sZFsxNV0pfWZ1bmN0aW9uIGN0KGQsRSxOKXtyZXR1cm4gZFswXT1FWzBdK05bMF0sZFsxXT1FWzFdK05bMV0sZFsyXT1FWzJdK05bMl0sZFszXT1FWzNdK05bM10sZFs0XT1FWzRdK05bNF0sZFs1XT1FWzVdK05bNV0sZFs2XT1FWzZdK05bNl0sZFs3XT1FWzddK05bN10sZFs4XT1FWzhdK05bOF0sZFs5XT1FWzldK05bOV0sZFsxMF09RVsxMF0rTlsxMF0sZFsxMV09RVsxMV0rTlsxMV0sZFsxMl09RVsxMl0rTlsxMl0sZFsxM109RVsxM10rTlsxM10sZFsxNF09RVsxNF0rTlsxNF0sZFsxNV09RVsxNV0rTlsxNV0sZH1mdW5jdGlvbiBmdChkLEUsTil7cmV0dXJuIGRbMF09RVswXS1OWzBdLGRbMV09RVsxXS1OWzFdLGRbMl09RVsyXS1OWzJdLGRbM109RVszXS1OWzNdLGRbNF09RVs0XS1OWzRdLGRbNV09RVs1XS1OWzVdLGRbNl09RVs2XS1OWzZdLGRbN109RVs3XS1OWzddLGRbOF09RVs4XS1OWzhdLGRbOV09RVs5XS1OWzldLGRbMTBdPUVbMTBdLU5bMTBdLGRbMTFdPUVbMTFdLU5bMTFdLGRbMTJdPUVbMTJdLU5bMTJdLGRbMTNdPUVbMTNdLU5bMTNdLGRbMTRdPUVbMTRdLU5bMTRdLGRbMTVdPUVbMTVdLU5bMTVdLGR9ZnVuY3Rpb24gVShkLEUsTil7cmV0dXJuIGRbMF09RVswXSpOLGRbMV09RVsxXSpOLGRbMl09RVsyXSpOLGRbM109RVszXSpOLGRbNF09RVs0XSpOLGRbNV09RVs1XSpOLGRbNl09RVs2XSpOLGRbN109RVs3XSpOLGRbOF09RVs4XSpOLGRbOV09RVs5XSpOLGRbMTBdPUVbMTBdKk4sZFsxMV09RVsxMV0qTixkWzEyXT1FWzEyXSpOLGRbMTNdPUVbMTNdKk4sZFsxNF09RVsxNF0qTixkWzE1XT1FWzE1XSpOLGR9ZnVuY3Rpb24gRihkLEUsTiwkKXtyZXR1cm4gZFswXT1FWzBdK05bMF0qJCxkWzFdPUVbMV0rTlsxXSokLGRbMl09RVsyXStOWzJdKiQsZFszXT1FWzNdK05bM10qJCxkWzRdPUVbNF0rTls0XSokLGRbNV09RVs1XStOWzVdKiQsZFs2XT1FWzZdK05bNl0qJCxkWzddPUVbN10rTls3XSokLGRbOF09RVs4XStOWzhdKiQsZFs5XT1FWzldK05bOV0qJCxkWzEwXT1FWzEwXStOWzEwXSokLGRbMTFdPUVbMTFdK05bMTFdKiQsZFsxMl09RVsxMl0rTlsxMl0qJCxkWzEzXT1FWzEzXStOWzEzXSokLGRbMTRdPUVbMTRdK05bMTRdKiQsZFsxNV09RVsxNV0rTlsxNV0qJCxkfWZ1bmN0aW9uIFYoZCxFKXtyZXR1cm4gZFswXT09PUVbMF0mJmRbMV09PT1FWzFdJiZkWzJdPT09RVsyXSYmZFszXT09PUVbM10mJmRbNF09PT1FWzRdJiZkWzVdPT09RVs1XSYmZFs2XT09PUVbNl0mJmRbN109PT1FWzddJiZkWzhdPT09RVs4XSYmZFs5XT09PUVbOV0mJmRbMTBdPT09RVsxMF0mJmRbMTFdPT09RVsxMV0mJmRbMTJdPT09RVsxMl0mJmRbMTNdPT09RVsxM10mJmRbMTRdPT09RVsxNF0mJmRbMTVdPT09RVsxNV19ZnVuY3Rpb24gWChkLEUpe3ZhciBOPWRbMF0sJD1kWzFdLEs9ZFsyXSxZPWRbM10sWj1kWzRdLGV0PWRbNV0scnQ9ZFs2XSxhdD1kWzddLGx0PWRbOF0saXQ9ZFs5XSxudD1kWzEwXSxvdD1kWzExXSxkdD1kWzEyXSxndD1kWzEzXSx1dD1kWzE0XSxtdD1kWzE1XSxPdD1FWzBdLHl0PUVbMV0scHQ9RVsyXSx4dD1FWzNdLE10PUVbNF0sQnQ9RVs1XSxJdD1FWzZdLE50PUVbN10sanQ9RVs4XSxGdD1FWzldLFd0PUVbMTBdLCR0PUVbMTFdLFR0PUVbMTJdLHd0PUVbMTNdLHVlPUVbMTRdLGNlPUVbMTVdO3JldHVybiBNYXRoLmFicyhOLU90KTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoTiksTWF0aC5hYnMoT3QpKSYmTWF0aC5hYnMoJC15dCk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKCQpLE1hdGguYWJzKHl0KSkmJk1hdGguYWJzKEstcHQpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhLKSxNYXRoLmFicyhwdCkpJiZNYXRoLmFicyhZLXh0KTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoWSksTWF0aC5hYnMoeHQpKSYmTWF0aC5hYnMoWi1NdCk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKFopLE1hdGguYWJzKE10KSkmJk1hdGguYWJzKGV0LUJ0KTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoZXQpLE1hdGguYWJzKEJ0KSkmJk1hdGguYWJzKHJ0LUl0KTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMocnQpLE1hdGguYWJzKEl0KSkmJk1hdGguYWJzKGF0LU50KTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoYXQpLE1hdGguYWJzKE50KSkmJk1hdGguYWJzKGx0LWp0KTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMobHQpLE1hdGguYWJzKGp0KSkmJk1hdGguYWJzKGl0LUZ0KTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoaXQpLE1hdGguYWJzKEZ0KSkmJk1hdGguYWJzKG50LVd0KTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMobnQpLE1hdGguYWJzKFd0KSkmJk1hdGguYWJzKG90LSR0KTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMob3QpLE1hdGguYWJzKCR0KSkmJk1hdGguYWJzKGR0LVR0KTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoZHQpLE1hdGguYWJzKFR0KSkmJk1hdGguYWJzKGd0LXd0KTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoZ3QpLE1hdGguYWJzKHd0KSkmJk1hdGguYWJzKHV0LXVlKTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnModXQpLE1hdGguYWJzKHVlKSkmJk1hdGguYWJzKG10LWNlKTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMobXQpLE1hdGguYWJzKGNlKSl9dmFyIGo9Yix6PWZ0fSxmdW5jdGlvbihjLGUsdCl7dC5yKGUpLHQuZChlLCJjcmVhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIGh9KSx0LmQoZSwiaWRlbnRpdHkiLGZ1bmN0aW9uKCl7cmV0dXJuIGx9KSx0LmQoZSwic2V0QXhpc0FuZ2xlIixmdW5jdGlvbigpe3JldHVybiB1fSksdC5kKGUsImdldEF4aXNBbmdsZSIsZnVuY3Rpb24oKXtyZXR1cm4gTX0pLHQuZChlLCJnZXRBbmdsZSIsZnVuY3Rpb24oKXtyZXR1cm4gZn0pLHQuZChlLCJtdWx0aXBseSIsZnVuY3Rpb24oKXtyZXR1cm4geX0pLHQuZChlLCJyb3RhdGVYIixmdW5jdGlvbigpe3JldHVybiB4fSksdC5kKGUsInJvdGF0ZVkiLGZ1bmN0aW9uKCl7cmV0dXJuIGJ9KSx0LmQoZSwicm90YXRlWiIsZnVuY3Rpb24oKXtyZXR1cm4gT30pLHQuZChlLCJjYWxjdWxhdGVXIixmdW5jdGlvbigpe3JldHVybiBtfSksdC5kKGUsImV4cCIsZnVuY3Rpb24oKXtyZXR1cm4gcH0pLHQuZChlLCJsbiIsZnVuY3Rpb24oKXtyZXR1cm4gbn0pLHQuZChlLCJwb3ciLGZ1bmN0aW9uKCl7cmV0dXJuIGF9KSx0LmQoZSwic2xlcnAiLGZ1bmN0aW9uKCl7cmV0dXJuIGl9KSx0LmQoZSwicmFuZG9tIixmdW5jdGlvbigpe3JldHVybiBvfSksdC5kKGUsImludmVydCIsZnVuY3Rpb24oKXtyZXR1cm4gVH0pLHQuZChlLCJjb25qdWdhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIFB9KSx0LmQoZSwiZnJvbU1hdDMiLGZ1bmN0aW9uKCl7cmV0dXJuIEN9KSx0LmQoZSwiZnJvbUV1bGVyIixmdW5jdGlvbigpe3JldHVybiBJfSksdC5kKGUsInN0ciIsZnVuY3Rpb24oKXtyZXR1cm4gQX0pLHQuZChlLCJjbG9uZSIsZnVuY3Rpb24oKXtyZXR1cm4gTH0pLHQuZChlLCJmcm9tVmFsdWVzIixmdW5jdGlvbigpe3JldHVybiBEfSksdC5kKGUsImNvcHkiLGZ1bmN0aW9uKCl7cmV0dXJuIFJ9KSx0LmQoZSwic2V0IixmdW5jdGlvbigpe3JldHVybiBTfSksdC5kKGUsImFkZCIsZnVuY3Rpb24oKXtyZXR1cm4gQn0pLHQuZChlLCJtdWwiLGZ1bmN0aW9uKCl7cmV0dXJuIHd9KSx0LmQoZSwic2NhbGUiLGZ1bmN0aW9uKCl7cmV0dXJuIEh9KSx0LmQoZSwiZG90IixmdW5jdGlvbigpe3JldHVybiBKfSksdC5kKGUsImxlcnAiLGZ1bmN0aW9uKCl7cmV0dXJuIHF9KSx0LmQoZSwibGVuZ3RoIixmdW5jdGlvbigpe3JldHVybiBXfSksdC5kKGUsImxlbiIsZnVuY3Rpb24oKXtyZXR1cm4gR30pLHQuZChlLCJzcXVhcmVkTGVuZ3RoIixmdW5jdGlvbigpe3JldHVybiBRfSksdC5kKGUsInNxckxlbiIsZnVuY3Rpb24oKXtyZXR1cm4gdHR9KSx0LmQoZSwibm9ybWFsaXplIixmdW5jdGlvbigpe3JldHVybiBffSksdC5kKGUsImV4YWN0RXF1YWxzIixmdW5jdGlvbigpe3JldHVybiBzdH0pLHQuZChlLCJlcXVhbHMiLGZ1bmN0aW9uKCl7cmV0dXJuIGt9KSx0LmQoZSwicm90YXRpb25UbyIsZnVuY3Rpb24oKXtyZXR1cm4gY3R9KSx0LmQoZSwic3FsZXJwIixmdW5jdGlvbigpe3JldHVybiBmdH0pLHQuZChlLCJzZXRBeGVzIixmdW5jdGlvbigpe3JldHVybiBVfSk7dmFyIHI9dCgyKSxzPXQoNSksZz10KDgpLHY9dCg5KTtmdW5jdGlvbiBoKCl7dmFyIEY9bmV3IHIuQVJSQVlfVFlQRSg0KTtyZXR1cm4gci5BUlJBWV9UWVBFIT1GbG9hdDMyQXJyYXkmJihGWzBdPTAsRlsxXT0wLEZbMl09MCksRlszXT0xLEZ9ZnVuY3Rpb24gbChGKXtyZXR1cm4gRlswXT0wLEZbMV09MCxGWzJdPTAsRlszXT0xLEZ9ZnVuY3Rpb24gdShGLFYsWCl7WD1YKi41O3ZhciBqPU1hdGguc2luKFgpO3JldHVybiBGWzBdPWoqVlswXSxGWzFdPWoqVlsxXSxGWzJdPWoqVlsyXSxGWzNdPU1hdGguY29zKFgpLEZ9ZnVuY3Rpb24gTShGLFYpe3ZhciBYPU1hdGguYWNvcyhWWzNdKSoyLGo9TWF0aC5zaW4oWC8yKTtyZXR1cm4gaj5yLkVQU0lMT04/KEZbMF09VlswXS9qLEZbMV09VlsxXS9qLEZbMl09VlsyXS9qKTooRlswXT0xLEZbMV09MCxGWzJdPTApLFh9ZnVuY3Rpb24gZihGLFYpe3ZhciBYPUooRixWKTtyZXR1cm4gTWF0aC5hY29zKDIqWCpYLTEpfWZ1bmN0aW9uIHkoRixWLFgpe3ZhciBqPVZbMF0sej1WWzFdLGQ9VlsyXSxFPVZbM10sTj1YWzBdLCQ9WFsxXSxLPVhbMl0sWT1YWzNdO3JldHVybiBGWzBdPWoqWStFKk4reipLLWQqJCxGWzFdPXoqWStFKiQrZCpOLWoqSyxGWzJdPWQqWStFKksraiokLXoqTixGWzNdPUUqWS1qKk4teiokLWQqSyxGfWZ1bmN0aW9uIHgoRixWLFgpe1gqPS41O3ZhciBqPVZbMF0sej1WWzFdLGQ9VlsyXSxFPVZbM10sTj1NYXRoLnNpbihYKSwkPU1hdGguY29zKFgpO3JldHVybiBGWzBdPWoqJCtFKk4sRlsxXT16KiQrZCpOLEZbMl09ZCokLXoqTixGWzNdPUUqJC1qKk4sRn1mdW5jdGlvbiBiKEYsVixYKXtYKj0uNTt2YXIgaj1WWzBdLHo9VlsxXSxkPVZbMl0sRT1WWzNdLE49TWF0aC5zaW4oWCksJD1NYXRoLmNvcyhYKTtyZXR1cm4gRlswXT1qKiQtZCpOLEZbMV09eiokK0UqTixGWzJdPWQqJCtqKk4sRlszXT1FKiQteipOLEZ9ZnVuY3Rpb24gTyhGLFYsWCl7WCo9LjU7dmFyIGo9VlswXSx6PVZbMV0sZD1WWzJdLEU9VlszXSxOPU1hdGguc2luKFgpLCQ9TWF0aC5jb3MoWCk7cmV0dXJuIEZbMF09aiokK3oqTixGWzFdPXoqJC1qKk4sRlsyXT1kKiQrRSpOLEZbM109RSokLWQqTixGfWZ1bmN0aW9uIG0oRixWKXt2YXIgWD1WWzBdLGo9VlsxXSx6PVZbMl07cmV0dXJuIEZbMF09WCxGWzFdPWosRlsyXT16LEZbM109TWF0aC5zcXJ0KE1hdGguYWJzKDEtWCpYLWoqai16KnopKSxGfWZ1bmN0aW9uIHAoRixWKXt2YXIgWD1WWzBdLGo9VlsxXSx6PVZbMl0sZD1WWzNdLEU9TWF0aC5zcXJ0KFgqWCtqKmoreip6KSxOPU1hdGguZXhwKGQpLCQ9RT4wP04qTWF0aC5zaW4oRSkvRTowO3JldHVybiBGWzBdPVgqJCxGWzFdPWoqJCxGWzJdPXoqJCxGWzNdPU4qTWF0aC5jb3MoRSksRn1mdW5jdGlvbiBuKEYsVil7dmFyIFg9VlswXSxqPVZbMV0sej1WWzJdLGQ9VlszXSxFPU1hdGguc3FydChYKlgraipqK3oqeiksTj1FPjA/TWF0aC5hdGFuMihFLGQpL0U6MDtyZXR1cm4gRlswXT1YKk4sRlsxXT1qKk4sRlsyXT16Kk4sRlszXT0uNSpNYXRoLmxvZyhYKlgraipqK3oqeitkKmQpLEZ9ZnVuY3Rpb24gYShGLFYsWCl7cmV0dXJuIG4oRixWKSxIKEYsRixYKSxwKEYsRiksRn1mdW5jdGlvbiBpKEYsVixYLGope3ZhciB6PVZbMF0sZD1WWzFdLEU9VlsyXSxOPVZbM10sJD1YWzBdLEs9WFsxXSxZPVhbMl0sWj1YWzNdLGV0LHJ0LGF0LGx0LGl0O3JldHVybiBydD16KiQrZCpLK0UqWStOKloscnQ8MCYmKHJ0PS1ydCwkPS0kLEs9LUssWT0tWSxaPS1aKSwxLXJ0PnIuRVBTSUxPTj8oZXQ9TWF0aC5hY29zKHJ0KSxhdD1NYXRoLnNpbihldCksbHQ9TWF0aC5zaW4oKDEtaikqZXQpL2F0LGl0PU1hdGguc2luKGoqZXQpL2F0KToobHQ9MS1qLGl0PWopLEZbMF09bHQqeitpdCokLEZbMV09bHQqZCtpdCpLLEZbMl09bHQqRStpdCpZLEZbM109bHQqTitpdCpaLEZ9ZnVuY3Rpb24gbyhGKXt2YXIgVj1yLlJBTkRPTSgpLFg9ci5SQU5ET00oKSxqPXIuUkFORE9NKCksej1NYXRoLnNxcnQoMS1WKSxkPU1hdGguc3FydChWKTtyZXR1cm4gRlswXT16Kk1hdGguc2luKDIqTWF0aC5QSSpYKSxGWzFdPXoqTWF0aC5jb3MoMipNYXRoLlBJKlgpLEZbMl09ZCpNYXRoLnNpbigyKk1hdGguUEkqaiksRlszXT1kKk1hdGguY29zKDIqTWF0aC5QSSpqKSxGfWZ1bmN0aW9uIFQoRixWKXt2YXIgWD1WWzBdLGo9VlsxXSx6PVZbMl0sZD1WWzNdLEU9WCpYK2oqait6KnorZCpkLE49RT8xL0U6MDtyZXR1cm4gRlswXT0tWCpOLEZbMV09LWoqTixGWzJdPS16Kk4sRlszXT1kKk4sRn1mdW5jdGlvbiBQKEYsVil7cmV0dXJuIEZbMF09LVZbMF0sRlsxXT0tVlsxXSxGWzJdPS1WWzJdLEZbM109VlszXSxGfWZ1bmN0aW9uIEMoRixWKXt2YXIgWD1WWzBdK1ZbNF0rVls4XSxqO2lmKFg+MClqPU1hdGguc3FydChYKzEpLEZbM109LjUqaixqPS41L2osRlswXT0oVls1XS1WWzddKSpqLEZbMV09KFZbNl0tVlsyXSkqaixGWzJdPShWWzFdLVZbM10pKmo7ZWxzZXt2YXIgej0wO1ZbNF0+VlswXSYmKHo9MSksVls4XT5WW3oqMyt6XSYmKHo9Mik7dmFyIGQ9KHorMSklMyxFPSh6KzIpJTM7aj1NYXRoLnNxcnQoVlt6KjMrel0tVltkKjMrZF0tVltFKjMrRV0rMSksRlt6XT0uNSpqLGo9LjUvaixGWzNdPShWW2QqMytFXS1WW0UqMytkXSkqaixGW2RdPShWW2QqMyt6XStWW3oqMytkXSkqaixGW0VdPShWW0UqMyt6XStWW3oqMytFXSkqan1yZXR1cm4gRn1mdW5jdGlvbiBJKEYsVixYLGope3ZhciB6PS41Kk1hdGguUEkvMTgwO1YqPXosWCo9eixqKj16O3ZhciBkPU1hdGguc2luKFYpLEU9TWF0aC5jb3MoViksTj1NYXRoLnNpbihYKSwkPU1hdGguY29zKFgpLEs9TWF0aC5zaW4oaiksWT1NYXRoLmNvcyhqKTtyZXR1cm4gRlswXT1kKiQqWS1FKk4qSyxGWzFdPUUqTipZK2QqJCpLLEZbMl09RSokKkstZCpOKlksRlszXT1FKiQqWStkKk4qSyxGfWZ1bmN0aW9uIEEoRil7cmV0dXJuInF1YXQoIitGWzBdKyIsICIrRlsxXSsiLCAiK0ZbMl0rIiwgIitGWzNdKyIpIn12YXIgTD12LmNsb25lLEQ9di5mcm9tVmFsdWVzLFI9di5jb3B5LFM9di5zZXQsQj12LmFkZCx3PXksSD12LnNjYWxlLEo9di5kb3QscT12LmxlcnAsVz12Lmxlbmd0aCxHPVcsUT12LnNxdWFyZWRMZW5ndGgsdHQ9USxfPXYubm9ybWFsaXplLHN0PXYuZXhhY3RFcXVhbHMsaz12LmVxdWFscyxjdD1mdW5jdGlvbigpe3ZhciBGPWcuY3JlYXRlKCksVj1nLmZyb21WYWx1ZXMoMSwwLDApLFg9Zy5mcm9tVmFsdWVzKDAsMSwwKTtyZXR1cm4gZnVuY3Rpb24oaix6LGQpe3ZhciBFPWcuZG90KHosZCk7cmV0dXJuIEU8LS45OTk5OTk/KGcuY3Jvc3MoRixWLHopLGcubGVuKEYpPDFlLTYmJmcuY3Jvc3MoRixYLHopLGcubm9ybWFsaXplKEYsRiksdShqLEYsTWF0aC5QSSksaik6RT4uOTk5OTk5PyhqWzBdPTAsalsxXT0wLGpbMl09MCxqWzNdPTEsaik6KGcuY3Jvc3MoRix6LGQpLGpbMF09RlswXSxqWzFdPUZbMV0salsyXT1GWzJdLGpbM109MStFLF8oaixqKSl9fSgpLGZ0PWZ1bmN0aW9uKCl7dmFyIEY9aCgpLFY9aCgpO3JldHVybiBmdW5jdGlvbihYLGoseixkLEUsTil7cmV0dXJuIGkoRixqLEUsTiksaShWLHosZCxOKSxpKFgsRixWLDIqTiooMS1OKSksWH19KCksVT1mdW5jdGlvbigpe3ZhciBGPXMuY3JlYXRlKCk7cmV0dXJuIGZ1bmN0aW9uKFYsWCxqLHope3JldHVybiBGWzBdPWpbMF0sRlszXT1qWzFdLEZbNl09alsyXSxGWzFdPXpbMF0sRls0XT16WzFdLEZbN109elsyXSxGWzJdPS1YWzBdLEZbNV09LVhbMV0sRls4XT0tWFsyXSxfKFYsQyhWLEYpKX19KCl9LGZ1bmN0aW9uKGMsZSx0KXt0LnIoZSksdC5kKGUsImNyZWF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gc30pLHQuZChlLCJjbG9uZSIsZnVuY3Rpb24oKXtyZXR1cm4gZ30pLHQuZChlLCJsZW5ndGgiLGZ1bmN0aW9uKCl7cmV0dXJuIHZ9KSx0LmQoZSwiZnJvbVZhbHVlcyIsZnVuY3Rpb24oKXtyZXR1cm4gaH0pLHQuZChlLCJjb3B5IixmdW5jdGlvbigpe3JldHVybiBsfSksdC5kKGUsInNldCIsZnVuY3Rpb24oKXtyZXR1cm4gdX0pLHQuZChlLCJhZGQiLGZ1bmN0aW9uKCl7cmV0dXJuIE19KSx0LmQoZSwic3VidHJhY3QiLGZ1bmN0aW9uKCl7cmV0dXJuIGZ9KSx0LmQoZSwibXVsdGlwbHkiLGZ1bmN0aW9uKCl7cmV0dXJuIHl9KSx0LmQoZSwiZGl2aWRlIixmdW5jdGlvbigpe3JldHVybiB4fSksdC5kKGUsImNlaWwiLGZ1bmN0aW9uKCl7cmV0dXJuIGJ9KSx0LmQoZSwiZmxvb3IiLGZ1bmN0aW9uKCl7cmV0dXJuIE99KSx0LmQoZSwibWluIixmdW5jdGlvbigpe3JldHVybiBtfSksdC5kKGUsIm1heCIsZnVuY3Rpb24oKXtyZXR1cm4gcH0pLHQuZChlLCJyb3VuZCIsZnVuY3Rpb24oKXtyZXR1cm4gbn0pLHQuZChlLCJzY2FsZSIsZnVuY3Rpb24oKXtyZXR1cm4gYX0pLHQuZChlLCJzY2FsZUFuZEFkZCIsZnVuY3Rpb24oKXtyZXR1cm4gaX0pLHQuZChlLCJkaXN0YW5jZSIsZnVuY3Rpb24oKXtyZXR1cm4gb30pLHQuZChlLCJzcXVhcmVkRGlzdGFuY2UiLGZ1bmN0aW9uKCl7cmV0dXJuIFR9KSx0LmQoZSwic3F1YXJlZExlbmd0aCIsZnVuY3Rpb24oKXtyZXR1cm4gUH0pLHQuZChlLCJuZWdhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIEN9KSx0LmQoZSwiaW52ZXJzZSIsZnVuY3Rpb24oKXtyZXR1cm4gSX0pLHQuZChlLCJub3JtYWxpemUiLGZ1bmN0aW9uKCl7cmV0dXJuIEF9KSx0LmQoZSwiZG90IixmdW5jdGlvbigpe3JldHVybiBMfSksdC5kKGUsImNyb3NzIixmdW5jdGlvbigpe3JldHVybiBEfSksdC5kKGUsImxlcnAiLGZ1bmN0aW9uKCl7cmV0dXJuIFJ9KSx0LmQoZSwiaGVybWl0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gU30pLHQuZChlLCJiZXppZXIiLGZ1bmN0aW9uKCl7cmV0dXJuIEJ9KSx0LmQoZSwicmFuZG9tIixmdW5jdGlvbigpe3JldHVybiB3fSksdC5kKGUsInRyYW5zZm9ybU1hdDQiLGZ1bmN0aW9uKCl7cmV0dXJuIEh9KSx0LmQoZSwidHJhbnNmb3JtTWF0MyIsZnVuY3Rpb24oKXtyZXR1cm4gSn0pLHQuZChlLCJ0cmFuc2Zvcm1RdWF0IixmdW5jdGlvbigpe3JldHVybiBxfSksdC5kKGUsInJvdGF0ZVgiLGZ1bmN0aW9uKCl7cmV0dXJuIFd9KSx0LmQoZSwicm90YXRlWSIsZnVuY3Rpb24oKXtyZXR1cm4gR30pLHQuZChlLCJyb3RhdGVaIixmdW5jdGlvbigpe3JldHVybiBRfSksdC5kKGUsImFuZ2xlIixmdW5jdGlvbigpe3JldHVybiB0dH0pLHQuZChlLCJ6ZXJvIixmdW5jdGlvbigpe3JldHVybiBffSksdC5kKGUsInN0ciIsZnVuY3Rpb24oKXtyZXR1cm4gc3R9KSx0LmQoZSwiZXhhY3RFcXVhbHMiLGZ1bmN0aW9uKCl7cmV0dXJuIGt9KSx0LmQoZSwiZXF1YWxzIixmdW5jdGlvbigpe3JldHVybiBjdH0pLHQuZChlLCJzdWIiLGZ1bmN0aW9uKCl7cmV0dXJuIGZ0fSksdC5kKGUsIm11bCIsZnVuY3Rpb24oKXtyZXR1cm4gVX0pLHQuZChlLCJkaXYiLGZ1bmN0aW9uKCl7cmV0dXJuIEZ9KSx0LmQoZSwiZGlzdCIsZnVuY3Rpb24oKXtyZXR1cm4gVn0pLHQuZChlLCJzcXJEaXN0IixmdW5jdGlvbigpe3JldHVybiBYfSksdC5kKGUsImxlbiIsZnVuY3Rpb24oKXtyZXR1cm4gan0pLHQuZChlLCJzcXJMZW4iLGZ1bmN0aW9uKCl7cmV0dXJuIHp9KSx0LmQoZSwiZm9yRWFjaCIsZnVuY3Rpb24oKXtyZXR1cm4gZH0pO3ZhciByPXQoMik7ZnVuY3Rpb24gcygpe3ZhciBFPW5ldyByLkFSUkFZX1RZUEUoMyk7cmV0dXJuIHIuQVJSQVlfVFlQRSE9RmxvYXQzMkFycmF5JiYoRVswXT0wLEVbMV09MCxFWzJdPTApLEV9ZnVuY3Rpb24gZyhFKXt2YXIgTj1uZXcgci5BUlJBWV9UWVBFKDMpO3JldHVybiBOWzBdPUVbMF0sTlsxXT1FWzFdLE5bMl09RVsyXSxOfWZ1bmN0aW9uIHYoRSl7dmFyIE49RVswXSwkPUVbMV0sSz1FWzJdO3JldHVybiBNYXRoLmh5cG90KE4sJCxLKX1mdW5jdGlvbiBoKEUsTiwkKXt2YXIgSz1uZXcgci5BUlJBWV9UWVBFKDMpO3JldHVybiBLWzBdPUUsS1sxXT1OLEtbMl09JCxLfWZ1bmN0aW9uIGwoRSxOKXtyZXR1cm4gRVswXT1OWzBdLEVbMV09TlsxXSxFWzJdPU5bMl0sRX1mdW5jdGlvbiB1KEUsTiwkLEspe3JldHVybiBFWzBdPU4sRVsxXT0kLEVbMl09SyxFfWZ1bmN0aW9uIE0oRSxOLCQpe3JldHVybiBFWzBdPU5bMF0rJFswXSxFWzFdPU5bMV0rJFsxXSxFWzJdPU5bMl0rJFsyXSxFfWZ1bmN0aW9uIGYoRSxOLCQpe3JldHVybiBFWzBdPU5bMF0tJFswXSxFWzFdPU5bMV0tJFsxXSxFWzJdPU5bMl0tJFsyXSxFfWZ1bmN0aW9uIHkoRSxOLCQpe3JldHVybiBFWzBdPU5bMF0qJFswXSxFWzFdPU5bMV0qJFsxXSxFWzJdPU5bMl0qJFsyXSxFfWZ1bmN0aW9uIHgoRSxOLCQpe3JldHVybiBFWzBdPU5bMF0vJFswXSxFWzFdPU5bMV0vJFsxXSxFWzJdPU5bMl0vJFsyXSxFfWZ1bmN0aW9uIGIoRSxOKXtyZXR1cm4gRVswXT1NYXRoLmNlaWwoTlswXSksRVsxXT1NYXRoLmNlaWwoTlsxXSksRVsyXT1NYXRoLmNlaWwoTlsyXSksRX1mdW5jdGlvbiBPKEUsTil7cmV0dXJuIEVbMF09TWF0aC5mbG9vcihOWzBdKSxFWzFdPU1hdGguZmxvb3IoTlsxXSksRVsyXT1NYXRoLmZsb29yKE5bMl0pLEV9ZnVuY3Rpb24gbShFLE4sJCl7cmV0dXJuIEVbMF09TWF0aC5taW4oTlswXSwkWzBdKSxFWzFdPU1hdGgubWluKE5bMV0sJFsxXSksRVsyXT1NYXRoLm1pbihOWzJdLCRbMl0pLEV9ZnVuY3Rpb24gcChFLE4sJCl7cmV0dXJuIEVbMF09TWF0aC5tYXgoTlswXSwkWzBdKSxFWzFdPU1hdGgubWF4KE5bMV0sJFsxXSksRVsyXT1NYXRoLm1heChOWzJdLCRbMl0pLEV9ZnVuY3Rpb24gbihFLE4pe3JldHVybiBFWzBdPU1hdGgucm91bmQoTlswXSksRVsxXT1NYXRoLnJvdW5kKE5bMV0pLEVbMl09TWF0aC5yb3VuZChOWzJdKSxFfWZ1bmN0aW9uIGEoRSxOLCQpe3JldHVybiBFWzBdPU5bMF0qJCxFWzFdPU5bMV0qJCxFWzJdPU5bMl0qJCxFfWZ1bmN0aW9uIGkoRSxOLCQsSyl7cmV0dXJuIEVbMF09TlswXSskWzBdKkssRVsxXT1OWzFdKyRbMV0qSyxFWzJdPU5bMl0rJFsyXSpLLEV9ZnVuY3Rpb24gbyhFLE4pe3ZhciAkPU5bMF0tRVswXSxLPU5bMV0tRVsxXSxZPU5bMl0tRVsyXTtyZXR1cm4gTWF0aC5oeXBvdCgkLEssWSl9ZnVuY3Rpb24gVChFLE4pe3ZhciAkPU5bMF0tRVswXSxLPU5bMV0tRVsxXSxZPU5bMl0tRVsyXTtyZXR1cm4gJCokK0sqSytZKll9ZnVuY3Rpb24gUChFKXt2YXIgTj1FWzBdLCQ9RVsxXSxLPUVbMl07cmV0dXJuIE4qTiskKiQrSypLfWZ1bmN0aW9uIEMoRSxOKXtyZXR1cm4gRVswXT0tTlswXSxFWzFdPS1OWzFdLEVbMl09LU5bMl0sRX1mdW5jdGlvbiBJKEUsTil7cmV0dXJuIEVbMF09MS9OWzBdLEVbMV09MS9OWzFdLEVbMl09MS9OWzJdLEV9ZnVuY3Rpb24gQShFLE4pe3ZhciAkPU5bMF0sSz1OWzFdLFk9TlsyXSxaPSQqJCtLKksrWSpZO3JldHVybiBaPjAmJihaPTEvTWF0aC5zcXJ0KFopKSxFWzBdPU5bMF0qWixFWzFdPU5bMV0qWixFWzJdPU5bMl0qWixFfWZ1bmN0aW9uIEwoRSxOKXtyZXR1cm4gRVswXSpOWzBdK0VbMV0qTlsxXStFWzJdKk5bMl19ZnVuY3Rpb24gRChFLE4sJCl7dmFyIEs9TlswXSxZPU5bMV0sWj1OWzJdLGV0PSRbMF0scnQ9JFsxXSxhdD0kWzJdO3JldHVybiBFWzBdPVkqYXQtWipydCxFWzFdPVoqZXQtSyphdCxFWzJdPUsqcnQtWSpldCxFfWZ1bmN0aW9uIFIoRSxOLCQsSyl7dmFyIFk9TlswXSxaPU5bMV0sZXQ9TlsyXTtyZXR1cm4gRVswXT1ZK0sqKCRbMF0tWSksRVsxXT1aK0sqKCRbMV0tWiksRVsyXT1ldCtLKigkWzJdLWV0KSxFfWZ1bmN0aW9uIFMoRSxOLCQsSyxZLFope3ZhciBldD1aKloscnQ9ZXQqKDIqWi0zKSsxLGF0PWV0KihaLTIpK1osbHQ9ZXQqKFotMSksaXQ9ZXQqKDMtMipaKTtyZXR1cm4gRVswXT1OWzBdKnJ0KyRbMF0qYXQrS1swXSpsdCtZWzBdKml0LEVbMV09TlsxXSpydCskWzFdKmF0K0tbMV0qbHQrWVsxXSppdCxFWzJdPU5bMl0qcnQrJFsyXSphdCtLWzJdKmx0K1lbMl0qaXQsRX1mdW5jdGlvbiBCKEUsTiwkLEssWSxaKXt2YXIgZXQ9MS1aLHJ0PWV0KmV0LGF0PVoqWixsdD1ydCpldCxpdD0zKloqcnQsbnQ9MyphdCpldCxvdD1hdCpaO3JldHVybiBFWzBdPU5bMF0qbHQrJFswXSppdCtLWzBdKm50K1lbMF0qb3QsRVsxXT1OWzFdKmx0KyRbMV0qaXQrS1sxXSpudCtZWzFdKm90LEVbMl09TlsyXSpsdCskWzJdKml0K0tbMl0qbnQrWVsyXSpvdCxFfWZ1bmN0aW9uIHcoRSxOKXtOPU58fDE7dmFyICQ9ci5SQU5ET00oKSoyKk1hdGguUEksSz1yLlJBTkRPTSgpKjItMSxZPU1hdGguc3FydCgxLUsqSykqTjtyZXR1cm4gRVswXT1NYXRoLmNvcygkKSpZLEVbMV09TWF0aC5zaW4oJCkqWSxFWzJdPUsqTixFfWZ1bmN0aW9uIEgoRSxOLCQpe3ZhciBLPU5bMF0sWT1OWzFdLFo9TlsyXSxldD0kWzNdKksrJFs3XSpZKyRbMTFdKlorJFsxNV07cmV0dXJuIGV0PWV0fHwxLEVbMF09KCRbMF0qSyskWzRdKlkrJFs4XSpaKyRbMTJdKS9ldCxFWzFdPSgkWzFdKksrJFs1XSpZKyRbOV0qWiskWzEzXSkvZXQsRVsyXT0oJFsyXSpLKyRbNl0qWSskWzEwXSpaKyRbMTRdKS9ldCxFfWZ1bmN0aW9uIEooRSxOLCQpe3ZhciBLPU5bMF0sWT1OWzFdLFo9TlsyXTtyZXR1cm4gRVswXT1LKiRbMF0rWSokWzNdK1oqJFs2XSxFWzFdPUsqJFsxXStZKiRbNF0rWiokWzddLEVbMl09SyokWzJdK1kqJFs1XStaKiRbOF0sRX1mdW5jdGlvbiBxKEUsTiwkKXt2YXIgSz0kWzBdLFk9JFsxXSxaPSRbMl0sZXQ9JFszXSxydD1OWzBdLGF0PU5bMV0sbHQ9TlsyXSxpdD1ZKmx0LVoqYXQsbnQ9WipydC1LKmx0LG90PUsqYXQtWSpydCxkdD1ZKm90LVoqbnQsZ3Q9WippdC1LKm90LHV0PUsqbnQtWSppdCxtdD1ldCoyO3JldHVybiBpdCo9bXQsbnQqPW10LG90Kj1tdCxkdCo9MixndCo9Mix1dCo9MixFWzBdPXJ0K2l0K2R0LEVbMV09YXQrbnQrZ3QsRVsyXT1sdCtvdCt1dCxFfWZ1bmN0aW9uIFcoRSxOLCQsSyl7dmFyIFk9W10sWj1bXTtyZXR1cm4gWVswXT1OWzBdLSRbMF0sWVsxXT1OWzFdLSRbMV0sWVsyXT1OWzJdLSRbMl0sWlswXT1ZWzBdLFpbMV09WVsxXSpNYXRoLmNvcyhLKS1ZWzJdKk1hdGguc2luKEspLFpbMl09WVsxXSpNYXRoLnNpbihLKStZWzJdKk1hdGguY29zKEspLEVbMF09WlswXSskWzBdLEVbMV09WlsxXSskWzFdLEVbMl09WlsyXSskWzJdLEV9ZnVuY3Rpb24gRyhFLE4sJCxLKXt2YXIgWT1bXSxaPVtdO3JldHVybiBZWzBdPU5bMF0tJFswXSxZWzFdPU5bMV0tJFsxXSxZWzJdPU5bMl0tJFsyXSxaWzBdPVlbMl0qTWF0aC5zaW4oSykrWVswXSpNYXRoLmNvcyhLKSxaWzFdPVlbMV0sWlsyXT1ZWzJdKk1hdGguY29zKEspLVlbMF0qTWF0aC5zaW4oSyksRVswXT1aWzBdKyRbMF0sRVsxXT1aWzFdKyRbMV0sRVsyXT1aWzJdKyRbMl0sRX1mdW5jdGlvbiBRKEUsTiwkLEspe3ZhciBZPVtdLFo9W107cmV0dXJuIFlbMF09TlswXS0kWzBdLFlbMV09TlsxXS0kWzFdLFlbMl09TlsyXS0kWzJdLFpbMF09WVswXSpNYXRoLmNvcyhLKS1ZWzFdKk1hdGguc2luKEspLFpbMV09WVswXSpNYXRoLnNpbihLKStZWzFdKk1hdGguY29zKEspLFpbMl09WVsyXSxFWzBdPVpbMF0rJFswXSxFWzFdPVpbMV0rJFsxXSxFWzJdPVpbMl0rJFsyXSxFfWZ1bmN0aW9uIHR0KEUsTil7dmFyICQ9RVswXSxLPUVbMV0sWT1FWzJdLFo9TlswXSxldD1OWzFdLHJ0PU5bMl0sYXQ9TWF0aC5zcXJ0KCQqJCtLKksrWSpZKSxsdD1NYXRoLnNxcnQoWipaK2V0KmV0K3J0KnJ0KSxpdD1hdCpsdCxudD1pdCYmTChFLE4pL2l0O3JldHVybiBNYXRoLmFjb3MoTWF0aC5taW4oTWF0aC5tYXgobnQsLTEpLDEpKX1mdW5jdGlvbiBfKEUpe3JldHVybiBFWzBdPTAsRVsxXT0wLEVbMl09MCxFfWZ1bmN0aW9uIHN0KEUpe3JldHVybiJ2ZWMzKCIrRVswXSsiLCAiK0VbMV0rIiwgIitFWzJdKyIpIn1mdW5jdGlvbiBrKEUsTil7cmV0dXJuIEVbMF09PT1OWzBdJiZFWzFdPT09TlsxXSYmRVsyXT09PU5bMl19ZnVuY3Rpb24gY3QoRSxOKXt2YXIgJD1FWzBdLEs9RVsxXSxZPUVbMl0sWj1OWzBdLGV0PU5bMV0scnQ9TlsyXTtyZXR1cm4gTWF0aC5hYnMoJC1aKTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoJCksTWF0aC5hYnMoWikpJiZNYXRoLmFicyhLLWV0KTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoSyksTWF0aC5hYnMoZXQpKSYmTWF0aC5hYnMoWS1ydCk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKFkpLE1hdGguYWJzKHJ0KSl9dmFyIGZ0PWYsVT15LEY9eCxWPW8sWD1ULGo9dix6PVAsZD1mdW5jdGlvbigpe3ZhciBFPXMoKTtyZXR1cm4gZnVuY3Rpb24oTiwkLEssWSxaLGV0KXt2YXIgcnQsYXQ7Zm9yKCR8fCgkPTMpLEt8fChLPTApLFk/YXQ9TWF0aC5taW4oWSokK0ssTi5sZW5ndGgpOmF0PU4ubGVuZ3RoLHJ0PUs7cnQ8YXQ7cnQrPSQpRVswXT1OW3J0XSxFWzFdPU5bcnQrMV0sRVsyXT1OW3J0KzJdLFooRSxFLGV0KSxOW3J0XT1FWzBdLE5bcnQrMV09RVsxXSxOW3J0KzJdPUVbMl07cmV0dXJuIE59fSgpfSxmdW5jdGlvbihjLGUsdCl7dC5yKGUpLHQuZChlLCJjcmVhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIHN9KSx0LmQoZSwiY2xvbmUiLGZ1bmN0aW9uKCl7cmV0dXJuIGd9KSx0LmQoZSwiZnJvbVZhbHVlcyIsZnVuY3Rpb24oKXtyZXR1cm4gdn0pLHQuZChlLCJjb3B5IixmdW5jdGlvbigpe3JldHVybiBofSksdC5kKGUsInNldCIsZnVuY3Rpb24oKXtyZXR1cm4gbH0pLHQuZChlLCJhZGQiLGZ1bmN0aW9uKCl7cmV0dXJuIHV9KSx0LmQoZSwic3VidHJhY3QiLGZ1bmN0aW9uKCl7cmV0dXJuIE19KSx0LmQoZSwibXVsdGlwbHkiLGZ1bmN0aW9uKCl7cmV0dXJuIGZ9KSx0LmQoZSwiZGl2aWRlIixmdW5jdGlvbigpe3JldHVybiB5fSksdC5kKGUsImNlaWwiLGZ1bmN0aW9uKCl7cmV0dXJuIHh9KSx0LmQoZSwiZmxvb3IiLGZ1bmN0aW9uKCl7cmV0dXJuIGJ9KSx0LmQoZSwibWluIixmdW5jdGlvbigpe3JldHVybiBPfSksdC5kKGUsIm1heCIsZnVuY3Rpb24oKXtyZXR1cm4gbX0pLHQuZChlLCJyb3VuZCIsZnVuY3Rpb24oKXtyZXR1cm4gcH0pLHQuZChlLCJzY2FsZSIsZnVuY3Rpb24oKXtyZXR1cm4gbn0pLHQuZChlLCJzY2FsZUFuZEFkZCIsZnVuY3Rpb24oKXtyZXR1cm4gYX0pLHQuZChlLCJkaXN0YW5jZSIsZnVuY3Rpb24oKXtyZXR1cm4gaX0pLHQuZChlLCJzcXVhcmVkRGlzdGFuY2UiLGZ1bmN0aW9uKCl7cmV0dXJuIG99KSx0LmQoZSwibGVuZ3RoIixmdW5jdGlvbigpe3JldHVybiBUfSksdC5kKGUsInNxdWFyZWRMZW5ndGgiLGZ1bmN0aW9uKCl7cmV0dXJuIFB9KSx0LmQoZSwibmVnYXRlIixmdW5jdGlvbigpe3JldHVybiBDfSksdC5kKGUsImludmVyc2UiLGZ1bmN0aW9uKCl7cmV0dXJuIEl9KSx0LmQoZSwibm9ybWFsaXplIixmdW5jdGlvbigpe3JldHVybiBBfSksdC5kKGUsImRvdCIsZnVuY3Rpb24oKXtyZXR1cm4gTH0pLHQuZChlLCJjcm9zcyIsZnVuY3Rpb24oKXtyZXR1cm4gRH0pLHQuZChlLCJsZXJwIixmdW5jdGlvbigpe3JldHVybiBSfSksdC5kKGUsInJhbmRvbSIsZnVuY3Rpb24oKXtyZXR1cm4gU30pLHQuZChlLCJ0cmFuc2Zvcm1NYXQ0IixmdW5jdGlvbigpe3JldHVybiBCfSksdC5kKGUsInRyYW5zZm9ybVF1YXQiLGZ1bmN0aW9uKCl7cmV0dXJuIHd9KSx0LmQoZSwiemVybyIsZnVuY3Rpb24oKXtyZXR1cm4gSH0pLHQuZChlLCJzdHIiLGZ1bmN0aW9uKCl7cmV0dXJuIEp9KSx0LmQoZSwiZXhhY3RFcXVhbHMiLGZ1bmN0aW9uKCl7cmV0dXJuIHF9KSx0LmQoZSwiZXF1YWxzIixmdW5jdGlvbigpe3JldHVybiBXfSksdC5kKGUsInN1YiIsZnVuY3Rpb24oKXtyZXR1cm4gR30pLHQuZChlLCJtdWwiLGZ1bmN0aW9uKCl7cmV0dXJuIFF9KSx0LmQoZSwiZGl2IixmdW5jdGlvbigpe3JldHVybiB0dH0pLHQuZChlLCJkaXN0IixmdW5jdGlvbigpe3JldHVybiBffSksdC5kKGUsInNxckRpc3QiLGZ1bmN0aW9uKCl7cmV0dXJuIHN0fSksdC5kKGUsImxlbiIsZnVuY3Rpb24oKXtyZXR1cm4ga30pLHQuZChlLCJzcXJMZW4iLGZ1bmN0aW9uKCl7cmV0dXJuIGN0fSksdC5kKGUsImZvckVhY2giLGZ1bmN0aW9uKCl7cmV0dXJuIGZ0fSk7dmFyIHI9dCgyKTtmdW5jdGlvbiBzKCl7dmFyIFU9bmV3IHIuQVJSQVlfVFlQRSg0KTtyZXR1cm4gci5BUlJBWV9UWVBFIT1GbG9hdDMyQXJyYXkmJihVWzBdPTAsVVsxXT0wLFVbMl09MCxVWzNdPTApLFV9ZnVuY3Rpb24gZyhVKXt2YXIgRj1uZXcgci5BUlJBWV9UWVBFKDQpO3JldHVybiBGWzBdPVVbMF0sRlsxXT1VWzFdLEZbMl09VVsyXSxGWzNdPVVbM10sRn1mdW5jdGlvbiB2KFUsRixWLFgpe3ZhciBqPW5ldyByLkFSUkFZX1RZUEUoNCk7cmV0dXJuIGpbMF09VSxqWzFdPUYsalsyXT1WLGpbM109WCxqfWZ1bmN0aW9uIGgoVSxGKXtyZXR1cm4gVVswXT1GWzBdLFVbMV09RlsxXSxVWzJdPUZbMl0sVVszXT1GWzNdLFV9ZnVuY3Rpb24gbChVLEYsVixYLGope3JldHVybiBVWzBdPUYsVVsxXT1WLFVbMl09WCxVWzNdPWosVX1mdW5jdGlvbiB1KFUsRixWKXtyZXR1cm4gVVswXT1GWzBdK1ZbMF0sVVsxXT1GWzFdK1ZbMV0sVVsyXT1GWzJdK1ZbMl0sVVszXT1GWzNdK1ZbM10sVX1mdW5jdGlvbiBNKFUsRixWKXtyZXR1cm4gVVswXT1GWzBdLVZbMF0sVVsxXT1GWzFdLVZbMV0sVVsyXT1GWzJdLVZbMl0sVVszXT1GWzNdLVZbM10sVX1mdW5jdGlvbiBmKFUsRixWKXtyZXR1cm4gVVswXT1GWzBdKlZbMF0sVVsxXT1GWzFdKlZbMV0sVVsyXT1GWzJdKlZbMl0sVVszXT1GWzNdKlZbM10sVX1mdW5jdGlvbiB5KFUsRixWKXtyZXR1cm4gVVswXT1GWzBdL1ZbMF0sVVsxXT1GWzFdL1ZbMV0sVVsyXT1GWzJdL1ZbMl0sVVszXT1GWzNdL1ZbM10sVX1mdW5jdGlvbiB4KFUsRil7cmV0dXJuIFVbMF09TWF0aC5jZWlsKEZbMF0pLFVbMV09TWF0aC5jZWlsKEZbMV0pLFVbMl09TWF0aC5jZWlsKEZbMl0pLFVbM109TWF0aC5jZWlsKEZbM10pLFV9ZnVuY3Rpb24gYihVLEYpe3JldHVybiBVWzBdPU1hdGguZmxvb3IoRlswXSksVVsxXT1NYXRoLmZsb29yKEZbMV0pLFVbMl09TWF0aC5mbG9vcihGWzJdKSxVWzNdPU1hdGguZmxvb3IoRlszXSksVX1mdW5jdGlvbiBPKFUsRixWKXtyZXR1cm4gVVswXT1NYXRoLm1pbihGWzBdLFZbMF0pLFVbMV09TWF0aC5taW4oRlsxXSxWWzFdKSxVWzJdPU1hdGgubWluKEZbMl0sVlsyXSksVVszXT1NYXRoLm1pbihGWzNdLFZbM10pLFV9ZnVuY3Rpb24gbShVLEYsVil7cmV0dXJuIFVbMF09TWF0aC5tYXgoRlswXSxWWzBdKSxVWzFdPU1hdGgubWF4KEZbMV0sVlsxXSksVVsyXT1NYXRoLm1heChGWzJdLFZbMl0pLFVbM109TWF0aC5tYXgoRlszXSxWWzNdKSxVfWZ1bmN0aW9uIHAoVSxGKXtyZXR1cm4gVVswXT1NYXRoLnJvdW5kKEZbMF0pLFVbMV09TWF0aC5yb3VuZChGWzFdKSxVWzJdPU1hdGgucm91bmQoRlsyXSksVVszXT1NYXRoLnJvdW5kKEZbM10pLFV9ZnVuY3Rpb24gbihVLEYsVil7cmV0dXJuIFVbMF09RlswXSpWLFVbMV09RlsxXSpWLFVbMl09RlsyXSpWLFVbM109RlszXSpWLFV9ZnVuY3Rpb24gYShVLEYsVixYKXtyZXR1cm4gVVswXT1GWzBdK1ZbMF0qWCxVWzFdPUZbMV0rVlsxXSpYLFVbMl09RlsyXStWWzJdKlgsVVszXT1GWzNdK1ZbM10qWCxVfWZ1bmN0aW9uIGkoVSxGKXt2YXIgVj1GWzBdLVVbMF0sWD1GWzFdLVVbMV0saj1GWzJdLVVbMl0sej1GWzNdLVVbM107cmV0dXJuIE1hdGguaHlwb3QoVixYLGoseil9ZnVuY3Rpb24gbyhVLEYpe3ZhciBWPUZbMF0tVVswXSxYPUZbMV0tVVsxXSxqPUZbMl0tVVsyXSx6PUZbM10tVVszXTtyZXR1cm4gVipWK1gqWCtqKmoreip6fWZ1bmN0aW9uIFQoVSl7dmFyIEY9VVswXSxWPVVbMV0sWD1VWzJdLGo9VVszXTtyZXR1cm4gTWF0aC5oeXBvdChGLFYsWCxqKX1mdW5jdGlvbiBQKFUpe3ZhciBGPVVbMF0sVj1VWzFdLFg9VVsyXSxqPVVbM107cmV0dXJuIEYqRitWKlYrWCpYK2oqan1mdW5jdGlvbiBDKFUsRil7cmV0dXJuIFVbMF09LUZbMF0sVVsxXT0tRlsxXSxVWzJdPS1GWzJdLFVbM109LUZbM10sVX1mdW5jdGlvbiBJKFUsRil7cmV0dXJuIFVbMF09MS9GWzBdLFVbMV09MS9GWzFdLFVbMl09MS9GWzJdLFVbM109MS9GWzNdLFV9ZnVuY3Rpb24gQShVLEYpe3ZhciBWPUZbMF0sWD1GWzFdLGo9RlsyXSx6PUZbM10sZD1WKlYrWCpYK2oqait6Kno7cmV0dXJuIGQ+MCYmKGQ9MS9NYXRoLnNxcnQoZCkpLFVbMF09VipkLFVbMV09WCpkLFVbMl09aipkLFVbM109eipkLFV9ZnVuY3Rpb24gTChVLEYpe3JldHVybiBVWzBdKkZbMF0rVVsxXSpGWzFdK1VbMl0qRlsyXStVWzNdKkZbM119ZnVuY3Rpb24gRChVLEYsVixYKXt2YXIgaj1WWzBdKlhbMV0tVlsxXSpYWzBdLHo9VlswXSpYWzJdLVZbMl0qWFswXSxkPVZbMF0qWFszXS1WWzNdKlhbMF0sRT1WWzFdKlhbMl0tVlsyXSpYWzFdLE49VlsxXSpYWzNdLVZbM10qWFsxXSwkPVZbMl0qWFszXS1WWzNdKlhbMl0sSz1GWzBdLFk9RlsxXSxaPUZbMl0sZXQ9RlszXTtyZXR1cm4gVVswXT1ZKiQtWipOK2V0KkUsVVsxXT0tKEsqJCkrWipkLWV0KnosVVsyXT1LKk4tWSpkK2V0KmosVVszXT0tKEsqRSkrWSp6LVoqaixVfWZ1bmN0aW9uIFIoVSxGLFYsWCl7dmFyIGo9RlswXSx6PUZbMV0sZD1GWzJdLEU9RlszXTtyZXR1cm4gVVswXT1qK1gqKFZbMF0taiksVVsxXT16K1gqKFZbMV0teiksVVsyXT1kK1gqKFZbMl0tZCksVVszXT1FK1gqKFZbM10tRSksVX1mdW5jdGlvbiBTKFUsRil7Rj1GfHwxO3ZhciBWLFgsaix6LGQsRTtkbyBWPXIuUkFORE9NKCkqMi0xLFg9ci5SQU5ET00oKSoyLTEsZD1WKlYrWCpYO3doaWxlKGQ+PTEpO2RvIGo9ci5SQU5ET00oKSoyLTEsej1yLlJBTkRPTSgpKjItMSxFPWoqait6Kno7d2hpbGUoRT49MSk7dmFyIE49TWF0aC5zcXJ0KCgxLWQpL0UpO3JldHVybiBVWzBdPUYqVixVWzFdPUYqWCxVWzJdPUYqaipOLFVbM109Rip6Kk4sVX1mdW5jdGlvbiBCKFUsRixWKXt2YXIgWD1GWzBdLGo9RlsxXSx6PUZbMl0sZD1GWzNdO3JldHVybiBVWzBdPVZbMF0qWCtWWzRdKmorVls4XSp6K1ZbMTJdKmQsVVsxXT1WWzFdKlgrVls1XSpqK1ZbOV0qeitWWzEzXSpkLFVbMl09VlsyXSpYK1ZbNl0qaitWWzEwXSp6K1ZbMTRdKmQsVVszXT1WWzNdKlgrVls3XSpqK1ZbMTFdKnorVlsxNV0qZCxVfWZ1bmN0aW9uIHcoVSxGLFYpe3ZhciBYPUZbMF0saj1GWzFdLHo9RlsyXSxkPVZbMF0sRT1WWzFdLE49VlsyXSwkPVZbM10sSz0kKlgrRSp6LU4qaixZPSQqaitOKlgtZCp6LFo9JCp6K2Qqai1FKlgsZXQ9LWQqWC1FKmotTip6O3JldHVybiBVWzBdPUsqJCtldCotZCtZKi1OLVoqLUUsVVsxXT1ZKiQrZXQqLUUrWiotZC1LKi1OLFVbMl09WiokK2V0Ki1OK0sqLUUtWSotZCxVWzNdPUZbM10sVX1mdW5jdGlvbiBIKFUpe3JldHVybiBVWzBdPTAsVVsxXT0wLFVbMl09MCxVWzNdPTAsVX1mdW5jdGlvbiBKKFUpe3JldHVybiJ2ZWM0KCIrVVswXSsiLCAiK1VbMV0rIiwgIitVWzJdKyIsICIrVVszXSsiKSJ9ZnVuY3Rpb24gcShVLEYpe3JldHVybiBVWzBdPT09RlswXSYmVVsxXT09PUZbMV0mJlVbMl09PT1GWzJdJiZVWzNdPT09RlszXX1mdW5jdGlvbiBXKFUsRil7dmFyIFY9VVswXSxYPVVbMV0saj1VWzJdLHo9VVszXSxkPUZbMF0sRT1GWzFdLE49RlsyXSwkPUZbM107cmV0dXJuIE1hdGguYWJzKFYtZCk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKFYpLE1hdGguYWJzKGQpKSYmTWF0aC5hYnMoWC1FKTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoWCksTWF0aC5hYnMoRSkpJiZNYXRoLmFicyhqLU4pPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhqKSxNYXRoLmFicyhOKSkmJk1hdGguYWJzKHotJCk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKHopLE1hdGguYWJzKCQpKX12YXIgRz1NLFE9Zix0dD15LF89aSxzdD1vLGs9VCxjdD1QLGZ0PWZ1bmN0aW9uKCl7dmFyIFU9cygpO3JldHVybiBmdW5jdGlvbihGLFYsWCxqLHosZCl7dmFyIEUsTjtmb3IoVnx8KFY9NCksWHx8KFg9MCksaj9OPU1hdGgubWluKGoqVitYLEYubGVuZ3RoKTpOPUYubGVuZ3RoLEU9WDtFPE47RSs9VilVWzBdPUZbRV0sVVsxXT1GW0UrMV0sVVsyXT1GW0UrMl0sVVszXT1GW0UrM10seihVLFUsZCksRltFXT1VWzBdLEZbRSsxXT1VWzFdLEZbRSsyXT1VWzJdLEZbRSszXT1VWzNdO3JldHVybiBGfX0oKX0sZnVuY3Rpb24oYyxlLHQpe3QucihlKSx0LmQoZSwiY3JlYXRlIixmdW5jdGlvbigpe3JldHVybiB2fSksdC5kKGUsImNsb25lIixmdW5jdGlvbigpe3JldHVybiBofSksdC5kKGUsImZyb21WYWx1ZXMiLGZ1bmN0aW9uKCl7cmV0dXJuIGx9KSx0LmQoZSwiZnJvbVJvdGF0aW9uVHJhbnNsYXRpb25WYWx1ZXMiLGZ1bmN0aW9uKCl7cmV0dXJuIHV9KSx0LmQoZSwiZnJvbVJvdGF0aW9uVHJhbnNsYXRpb24iLGZ1bmN0aW9uKCl7cmV0dXJuIE19KSx0LmQoZSwiZnJvbVRyYW5zbGF0aW9uIixmdW5jdGlvbigpe3JldHVybiBmfSksdC5kKGUsImZyb21Sb3RhdGlvbiIsZnVuY3Rpb24oKXtyZXR1cm4geX0pLHQuZChlLCJmcm9tTWF0NCIsZnVuY3Rpb24oKXtyZXR1cm4geH0pLHQuZChlLCJjb3B5IixmdW5jdGlvbigpe3JldHVybiBifSksdC5kKGUsImlkZW50aXR5IixmdW5jdGlvbigpe3JldHVybiBPfSksdC5kKGUsInNldCIsZnVuY3Rpb24oKXtyZXR1cm4gbX0pLHQuZChlLCJnZXRSZWFsIixmdW5jdGlvbigpe3JldHVybiBwfSksdC5kKGUsImdldER1YWwiLGZ1bmN0aW9uKCl7cmV0dXJuIG59KSx0LmQoZSwic2V0UmVhbCIsZnVuY3Rpb24oKXtyZXR1cm4gYX0pLHQuZChlLCJzZXREdWFsIixmdW5jdGlvbigpe3JldHVybiBpfSksdC5kKGUsImdldFRyYW5zbGF0aW9uIixmdW5jdGlvbigpe3JldHVybiBvfSksdC5kKGUsInRyYW5zbGF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gVH0pLHQuZChlLCJyb3RhdGVYIixmdW5jdGlvbigpe3JldHVybiBQfSksdC5kKGUsInJvdGF0ZVkiLGZ1bmN0aW9uKCl7cmV0dXJuIEN9KSx0LmQoZSwicm90YXRlWiIsZnVuY3Rpb24oKXtyZXR1cm4gSX0pLHQuZChlLCJyb3RhdGVCeVF1YXRBcHBlbmQiLGZ1bmN0aW9uKCl7cmV0dXJuIEF9KSx0LmQoZSwicm90YXRlQnlRdWF0UHJlcGVuZCIsZnVuY3Rpb24oKXtyZXR1cm4gTH0pLHQuZChlLCJyb3RhdGVBcm91bmRBeGlzIixmdW5jdGlvbigpe3JldHVybiBEfSksdC5kKGUsImFkZCIsZnVuY3Rpb24oKXtyZXR1cm4gUn0pLHQuZChlLCJtdWx0aXBseSIsZnVuY3Rpb24oKXtyZXR1cm4gU30pLHQuZChlLCJtdWwiLGZ1bmN0aW9uKCl7cmV0dXJuIEJ9KSx0LmQoZSwic2NhbGUiLGZ1bmN0aW9uKCl7cmV0dXJuIHd9KSx0LmQoZSwiZG90IixmdW5jdGlvbigpe3JldHVybiBIfSksdC5kKGUsImxlcnAiLGZ1bmN0aW9uKCl7cmV0dXJuIEp9KSx0LmQoZSwiaW52ZXJ0IixmdW5jdGlvbigpe3JldHVybiBxfSksdC5kKGUsImNvbmp1Z2F0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gV30pLHQuZChlLCJsZW5ndGgiLGZ1bmN0aW9uKCl7cmV0dXJuIEd9KSx0LmQoZSwibGVuIixmdW5jdGlvbigpe3JldHVybiBRfSksdC5kKGUsInNxdWFyZWRMZW5ndGgiLGZ1bmN0aW9uKCl7cmV0dXJuIHR0fSksdC5kKGUsInNxckxlbiIsZnVuY3Rpb24oKXtyZXR1cm4gX30pLHQuZChlLCJub3JtYWxpemUiLGZ1bmN0aW9uKCl7cmV0dXJuIHN0fSksdC5kKGUsInN0ciIsZnVuY3Rpb24oKXtyZXR1cm4ga30pLHQuZChlLCJleGFjdEVxdWFscyIsZnVuY3Rpb24oKXtyZXR1cm4gY3R9KSx0LmQoZSwiZXF1YWxzIixmdW5jdGlvbigpe3JldHVybiBmdH0pO3ZhciByPXQoMikscz10KDcpLGc9dCg2KTtmdW5jdGlvbiB2KCl7dmFyIFU9bmV3IHIuQVJSQVlfVFlQRSg4KTtyZXR1cm4gci5BUlJBWV9UWVBFIT1GbG9hdDMyQXJyYXkmJihVWzBdPTAsVVsxXT0wLFVbMl09MCxVWzRdPTAsVVs1XT0wLFVbNl09MCxVWzddPTApLFVbM109MSxVfWZ1bmN0aW9uIGgoVSl7dmFyIEY9bmV3IHIuQVJSQVlfVFlQRSg4KTtyZXR1cm4gRlswXT1VWzBdLEZbMV09VVsxXSxGWzJdPVVbMl0sRlszXT1VWzNdLEZbNF09VVs0XSxGWzVdPVVbNV0sRls2XT1VWzZdLEZbN109VVs3XSxGfWZ1bmN0aW9uIGwoVSxGLFYsWCxqLHosZCxFKXt2YXIgTj1uZXcgci5BUlJBWV9UWVBFKDgpO3JldHVybiBOWzBdPVUsTlsxXT1GLE5bMl09VixOWzNdPVgsTls0XT1qLE5bNV09eixOWzZdPWQsTls3XT1FLE59ZnVuY3Rpb24gdShVLEYsVixYLGoseixkKXt2YXIgRT1uZXcgci5BUlJBWV9UWVBFKDgpO0VbMF09VSxFWzFdPUYsRVsyXT1WLEVbM109WDt2YXIgTj1qKi41LCQ9eiouNSxLPWQqLjU7cmV0dXJuIEVbNF09TipYKyQqVi1LKkYsRVs1XT0kKlgrSypVLU4qVixFWzZdPUsqWCtOKkYtJCpVLEVbN109LU4qVS0kKkYtSypWLEV9ZnVuY3Rpb24gTShVLEYsVil7dmFyIFg9VlswXSouNSxqPVZbMV0qLjUsej1WWzJdKi41LGQ9RlswXSxFPUZbMV0sTj1GWzJdLCQ9RlszXTtyZXR1cm4gVVswXT1kLFVbMV09RSxVWzJdPU4sVVszXT0kLFVbNF09WCokK2oqTi16KkUsVVs1XT1qKiQreipkLVgqTixVWzZdPXoqJCtYKkUtaipkLFVbN109LVgqZC1qKkUteipOLFV9ZnVuY3Rpb24gZihVLEYpe3JldHVybiBVWzBdPTAsVVsxXT0wLFVbMl09MCxVWzNdPTEsVVs0XT1GWzBdKi41LFVbNV09RlsxXSouNSxVWzZdPUZbMl0qLjUsVVs3XT0wLFV9ZnVuY3Rpb24geShVLEYpe3JldHVybiBVWzBdPUZbMF0sVVsxXT1GWzFdLFVbMl09RlsyXSxVWzNdPUZbM10sVVs0XT0wLFVbNV09MCxVWzZdPTAsVVs3XT0wLFV9ZnVuY3Rpb24geChVLEYpe3ZhciBWPXMuY3JlYXRlKCk7Zy5nZXRSb3RhdGlvbihWLEYpO3ZhciBYPW5ldyByLkFSUkFZX1RZUEUoMyk7cmV0dXJuIGcuZ2V0VHJhbnNsYXRpb24oWCxGKSxNKFUsVixYKSxVfWZ1bmN0aW9uIGIoVSxGKXtyZXR1cm4gVVswXT1GWzBdLFVbMV09RlsxXSxVWzJdPUZbMl0sVVszXT1GWzNdLFVbNF09Rls0XSxVWzVdPUZbNV0sVVs2XT1GWzZdLFVbN109Rls3XSxVfWZ1bmN0aW9uIE8oVSl7cmV0dXJuIFVbMF09MCxVWzFdPTAsVVsyXT0wLFVbM109MSxVWzRdPTAsVVs1XT0wLFVbNl09MCxVWzddPTAsVX1mdW5jdGlvbiBtKFUsRixWLFgsaix6LGQsRSxOKXtyZXR1cm4gVVswXT1GLFVbMV09VixVWzJdPVgsVVszXT1qLFVbNF09eixVWzVdPWQsVVs2XT1FLFVbN109TixVfXZhciBwPXMuY29weTtmdW5jdGlvbiBuKFUsRil7cmV0dXJuIFVbMF09Rls0XSxVWzFdPUZbNV0sVVsyXT1GWzZdLFVbM109Rls3XSxVfXZhciBhPXMuY29weTtmdW5jdGlvbiBpKFUsRil7cmV0dXJuIFVbNF09RlswXSxVWzVdPUZbMV0sVVs2XT1GWzJdLFVbN109RlszXSxVfWZ1bmN0aW9uIG8oVSxGKXt2YXIgVj1GWzRdLFg9Rls1XSxqPUZbNl0sej1GWzddLGQ9LUZbMF0sRT0tRlsxXSxOPS1GWzJdLCQ9RlszXTtyZXR1cm4gVVswXT0oViokK3oqZCtYKk4taipFKSoyLFVbMV09KFgqJCt6KkUraipkLVYqTikqMixVWzJdPShqKiQreipOK1YqRS1YKmQpKjIsVX1mdW5jdGlvbiBUKFUsRixWKXt2YXIgWD1GWzBdLGo9RlsxXSx6PUZbMl0sZD1GWzNdLEU9VlswXSouNSxOPVZbMV0qLjUsJD1WWzJdKi41LEs9Rls0XSxZPUZbNV0sWj1GWzZdLGV0PUZbN107cmV0dXJuIFVbMF09WCxVWzFdPWosVVsyXT16LFVbM109ZCxVWzRdPWQqRStqKiQteipOK0ssVVs1XT1kKk4reipFLVgqJCtZLFVbNl09ZCokK1gqTi1qKkUrWixVWzddPS1YKkUtaipOLXoqJCtldCxVfWZ1bmN0aW9uIFAoVSxGLFYpe3ZhciBYPS1GWzBdLGo9LUZbMV0sej0tRlsyXSxkPUZbM10sRT1GWzRdLE49Rls1XSwkPUZbNl0sSz1GWzddLFk9RSpkK0sqWCtOKnotJCpqLFo9TipkK0sqaiskKlgtRSp6LGV0PSQqZCtLKnorRSpqLU4qWCxydD1LKmQtRSpYLU4qai0kKno7cmV0dXJuIHMucm90YXRlWChVLEYsViksWD1VWzBdLGo9VVsxXSx6PVVbMl0sZD1VWzNdLFVbNF09WSpkK3J0KlgrWip6LWV0KmosVVs1XT1aKmQrcnQqaitldCpYLVkqeixVWzZdPWV0KmQrcnQqeitZKmotWipYLFVbN109cnQqZC1ZKlgtWipqLWV0KnosVX1mdW5jdGlvbiBDKFUsRixWKXt2YXIgWD0tRlswXSxqPS1GWzFdLHo9LUZbMl0sZD1GWzNdLEU9Rls0XSxOPUZbNV0sJD1GWzZdLEs9Rls3XSxZPUUqZCtLKlgrTip6LSQqaixaPU4qZCtLKmorJCpYLUUqeixldD0kKmQrSyp6K0Uqai1OKlgscnQ9SypkLUUqWC1OKmotJCp6O3JldHVybiBzLnJvdGF0ZVkoVSxGLFYpLFg9VVswXSxqPVVbMV0sej1VWzJdLGQ9VVszXSxVWzRdPVkqZCtydCpYK1oqei1ldCpqLFVbNV09WipkK3J0KmorZXQqWC1ZKnosVVs2XT1ldCpkK3J0KnorWSpqLVoqWCxVWzddPXJ0KmQtWSpYLVoqai1ldCp6LFV9ZnVuY3Rpb24gSShVLEYsVil7dmFyIFg9LUZbMF0saj0tRlsxXSx6PS1GWzJdLGQ9RlszXSxFPUZbNF0sTj1GWzVdLCQ9Rls2XSxLPUZbN10sWT1FKmQrSypYK04qei0kKmosWj1OKmQrSypqKyQqWC1FKnosZXQ9JCpkK0sqeitFKmotTipYLHJ0PUsqZC1FKlgtTipqLSQqejtyZXR1cm4gcy5yb3RhdGVaKFUsRixWKSxYPVVbMF0saj1VWzFdLHo9VVsyXSxkPVVbM10sVVs0XT1ZKmQrcnQqWCtaKnotZXQqaixVWzVdPVoqZCtydCpqK2V0KlgtWSp6LFVbNl09ZXQqZCtydCp6K1kqai1aKlgsVVs3XT1ydCpkLVkqWC1aKmotZXQqeixVfWZ1bmN0aW9uIEEoVSxGLFYpe3ZhciBYPVZbMF0saj1WWzFdLHo9VlsyXSxkPVZbM10sRT1GWzBdLE49RlsxXSwkPUZbMl0sSz1GWzNdO3JldHVybiBVWzBdPUUqZCtLKlgrTip6LSQqaixVWzFdPU4qZCtLKmorJCpYLUUqeixVWzJdPSQqZCtLKnorRSpqLU4qWCxVWzNdPUsqZC1FKlgtTipqLSQqeixFPUZbNF0sTj1GWzVdLCQ9Rls2XSxLPUZbN10sVVs0XT1FKmQrSypYK04qei0kKmosVVs1XT1OKmQrSypqKyQqWC1FKnosVVs2XT0kKmQrSyp6K0Uqai1OKlgsVVs3XT1LKmQtRSpYLU4qai0kKnosVX1mdW5jdGlvbiBMKFUsRixWKXt2YXIgWD1GWzBdLGo9RlsxXSx6PUZbMl0sZD1GWzNdLEU9VlswXSxOPVZbMV0sJD1WWzJdLEs9VlszXTtyZXR1cm4gVVswXT1YKksrZCpFK2oqJC16Kk4sVVsxXT1qKksrZCpOK3oqRS1YKiQsVVsyXT16KksrZCokK1gqTi1qKkUsVVszXT1kKkstWCpFLWoqTi16KiQsRT1WWzRdLE49Vls1XSwkPVZbNl0sSz1WWzddLFVbNF09WCpLK2QqRStqKiQteipOLFVbNV09aipLK2QqTit6KkUtWCokLFVbNl09eipLK2QqJCtYKk4taipFLFVbN109ZCpLLVgqRS1qKk4teiokLFV9ZnVuY3Rpb24gRChVLEYsVixYKXtpZihNYXRoLmFicyhYKTxyLkVQU0lMT04pcmV0dXJuIGIoVSxGKTt2YXIgaj1NYXRoLmh5cG90KFZbMF0sVlsxXSxWWzJdKTtYPVgqLjU7dmFyIHo9TWF0aC5zaW4oWCksZD16KlZbMF0vaixFPXoqVlsxXS9qLE49eipWWzJdL2osJD1NYXRoLmNvcyhYKSxLPUZbMF0sWT1GWzFdLFo9RlsyXSxldD1GWzNdO1VbMF09SyokK2V0KmQrWSpOLVoqRSxVWzFdPVkqJCtldCpFK1oqZC1LKk4sVVsyXT1aKiQrZXQqTitLKkUtWSpkLFVbM109ZXQqJC1LKmQtWSpFLVoqTjt2YXIgcnQ9Rls0XSxhdD1GWzVdLGx0PUZbNl0saXQ9Rls3XTtyZXR1cm4gVVs0XT1ydCokK2l0KmQrYXQqTi1sdCpFLFVbNV09YXQqJCtpdCpFK2x0KmQtcnQqTixVWzZdPWx0KiQraXQqTitydCpFLWF0KmQsVVs3XT1pdCokLXJ0KmQtYXQqRS1sdCpOLFV9ZnVuY3Rpb24gUihVLEYsVil7cmV0dXJuIFVbMF09RlswXStWWzBdLFVbMV09RlsxXStWWzFdLFVbMl09RlsyXStWWzJdLFVbM109RlszXStWWzNdLFVbNF09Rls0XStWWzRdLFVbNV09Rls1XStWWzVdLFVbNl09Rls2XStWWzZdLFVbN109Rls3XStWWzddLFV9ZnVuY3Rpb24gUyhVLEYsVil7dmFyIFg9RlswXSxqPUZbMV0sej1GWzJdLGQ9RlszXSxFPVZbNF0sTj1WWzVdLCQ9Vls2XSxLPVZbN10sWT1GWzRdLFo9Rls1XSxldD1GWzZdLHJ0PUZbN10sYXQ9VlswXSxsdD1WWzFdLGl0PVZbMl0sbnQ9VlszXTtyZXR1cm4gVVswXT1YKm50K2QqYXQraippdC16Kmx0LFVbMV09aipudCtkKmx0K3oqYXQtWCppdCxVWzJdPXoqbnQrZCppdCtYKmx0LWoqYXQsVVszXT1kKm50LVgqYXQtaipsdC16Kml0LFVbNF09WCpLK2QqRStqKiQteipOK1kqbnQrcnQqYXQrWippdC1ldCpsdCxVWzVdPWoqSytkKk4reipFLVgqJCtaKm50K3J0Kmx0K2V0KmF0LVkqaXQsVVs2XT16KksrZCokK1gqTi1qKkUrZXQqbnQrcnQqaXQrWSpsdC1aKmF0LFVbN109ZCpLLVgqRS1qKk4teiokK3J0Km50LVkqYXQtWipsdC1ldCppdCxVfXZhciBCPVM7ZnVuY3Rpb24gdyhVLEYsVil7cmV0dXJuIFVbMF09RlswXSpWLFVbMV09RlsxXSpWLFVbMl09RlsyXSpWLFVbM109RlszXSpWLFVbNF09Rls0XSpWLFVbNV09Rls1XSpWLFVbNl09Rls2XSpWLFVbN109Rls3XSpWLFV9dmFyIEg9cy5kb3Q7ZnVuY3Rpb24gSihVLEYsVixYKXt2YXIgaj0xLVg7cmV0dXJuIEgoRixWKTwwJiYoWD0tWCksVVswXT1GWzBdKmorVlswXSpYLFVbMV09RlsxXSpqK1ZbMV0qWCxVWzJdPUZbMl0qaitWWzJdKlgsVVszXT1GWzNdKmorVlszXSpYLFVbNF09Rls0XSpqK1ZbNF0qWCxVWzVdPUZbNV0qaitWWzVdKlgsVVs2XT1GWzZdKmorVls2XSpYLFVbN109Rls3XSpqK1ZbN10qWCxVfWZ1bmN0aW9uIHEoVSxGKXt2YXIgVj10dChGKTtyZXR1cm4gVVswXT0tRlswXS9WLFVbMV09LUZbMV0vVixVWzJdPS1GWzJdL1YsVVszXT1GWzNdL1YsVVs0XT0tRls0XS9WLFVbNV09LUZbNV0vVixVWzZdPS1GWzZdL1YsVVs3XT1GWzddL1YsVX1mdW5jdGlvbiBXKFUsRil7cmV0dXJuIFVbMF09LUZbMF0sVVsxXT0tRlsxXSxVWzJdPS1GWzJdLFVbM109RlszXSxVWzRdPS1GWzRdLFVbNV09LUZbNV0sVVs2XT0tRls2XSxVWzddPUZbN10sVX12YXIgRz1zLmxlbmd0aCxRPUcsdHQ9cy5zcXVhcmVkTGVuZ3RoLF89dHQ7ZnVuY3Rpb24gc3QoVSxGKXt2YXIgVj10dChGKTtpZihWPjApe1Y9TWF0aC5zcXJ0KFYpO3ZhciBYPUZbMF0vVixqPUZbMV0vVix6PUZbMl0vVixkPUZbM10vVixFPUZbNF0sTj1GWzVdLCQ9Rls2XSxLPUZbN10sWT1YKkUraipOK3oqJCtkKks7VVswXT1YLFVbMV09aixVWzJdPXosVVszXT1kLFVbNF09KEUtWCpZKS9WLFVbNV09KE4taipZKS9WLFVbNl09KCQteipZKS9WLFVbN109KEstZCpZKS9WfXJldHVybiBVfWZ1bmN0aW9uIGsoVSl7cmV0dXJuInF1YXQyKCIrVVswXSsiLCAiK1VbMV0rIiwgIitVWzJdKyIsICIrVVszXSsiLCAiK1VbNF0rIiwgIitVWzVdKyIsICIrVVs2XSsiLCAiK1VbN10rIikifWZ1bmN0aW9uIGN0KFUsRil7cmV0dXJuIFVbMF09PT1GWzBdJiZVWzFdPT09RlsxXSYmVVsyXT09PUZbMl0mJlVbM109PT1GWzNdJiZVWzRdPT09Rls0XSYmVVs1XT09PUZbNV0mJlVbNl09PT1GWzZdJiZVWzddPT09Rls3XX1mdW5jdGlvbiBmdChVLEYpe3ZhciBWPVVbMF0sWD1VWzFdLGo9VVsyXSx6PVVbM10sZD1VWzRdLEU9VVs1XSxOPVVbNl0sJD1VWzddLEs9RlswXSxZPUZbMV0sWj1GWzJdLGV0PUZbM10scnQ9Rls0XSxhdD1GWzVdLGx0PUZbNl0saXQ9Rls3XTtyZXR1cm4gTWF0aC5hYnMoVi1LKTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoViksTWF0aC5hYnMoSykpJiZNYXRoLmFicyhYLVkpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhYKSxNYXRoLmFicyhZKSkmJk1hdGguYWJzKGotWik8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKGopLE1hdGguYWJzKFopKSYmTWF0aC5hYnMoei1ldCk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKHopLE1hdGguYWJzKGV0KSkmJk1hdGguYWJzKGQtcnQpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhkKSxNYXRoLmFicyhydCkpJiZNYXRoLmFicyhFLWF0KTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoRSksTWF0aC5hYnMoYXQpKSYmTWF0aC5hYnMoTi1sdCk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKE4pLE1hdGguYWJzKGx0KSkmJk1hdGguYWJzKCQtaXQpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicygkKSxNYXRoLmFicyhpdCkpfX0sZnVuY3Rpb24oYyxlLHQpe3QucihlKSx0LmQoZSwiY3JlYXRlIixmdW5jdGlvbigpe3JldHVybiBzfSksdC5kKGUsImNsb25lIixmdW5jdGlvbigpe3JldHVybiBnfSksdC5kKGUsImZyb21WYWx1ZXMiLGZ1bmN0aW9uKCl7cmV0dXJuIHZ9KSx0LmQoZSwiY29weSIsZnVuY3Rpb24oKXtyZXR1cm4gaH0pLHQuZChlLCJzZXQiLGZ1bmN0aW9uKCl7cmV0dXJuIGx9KSx0LmQoZSwiYWRkIixmdW5jdGlvbigpe3JldHVybiB1fSksdC5kKGUsInN1YnRyYWN0IixmdW5jdGlvbigpe3JldHVybiBNfSksdC5kKGUsIm11bHRpcGx5IixmdW5jdGlvbigpe3JldHVybiBmfSksdC5kKGUsImRpdmlkZSIsZnVuY3Rpb24oKXtyZXR1cm4geX0pLHQuZChlLCJjZWlsIixmdW5jdGlvbigpe3JldHVybiB4fSksdC5kKGUsImZsb29yIixmdW5jdGlvbigpe3JldHVybiBifSksdC5kKGUsIm1pbiIsZnVuY3Rpb24oKXtyZXR1cm4gT30pLHQuZChlLCJtYXgiLGZ1bmN0aW9uKCl7cmV0dXJuIG19KSx0LmQoZSwicm91bmQiLGZ1bmN0aW9uKCl7cmV0dXJuIHB9KSx0LmQoZSwic2NhbGUiLGZ1bmN0aW9uKCl7cmV0dXJuIG59KSx0LmQoZSwic2NhbGVBbmRBZGQiLGZ1bmN0aW9uKCl7cmV0dXJuIGF9KSx0LmQoZSwiZGlzdGFuY2UiLGZ1bmN0aW9uKCl7cmV0dXJuIGl9KSx0LmQoZSwic3F1YXJlZERpc3RhbmNlIixmdW5jdGlvbigpe3JldHVybiBvfSksdC5kKGUsImxlbmd0aCIsZnVuY3Rpb24oKXtyZXR1cm4gVH0pLHQuZChlLCJzcXVhcmVkTGVuZ3RoIixmdW5jdGlvbigpe3JldHVybiBQfSksdC5kKGUsIm5lZ2F0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gQ30pLHQuZChlLCJpbnZlcnNlIixmdW5jdGlvbigpe3JldHVybiBJfSksdC5kKGUsIm5vcm1hbGl6ZSIsZnVuY3Rpb24oKXtyZXR1cm4gQX0pLHQuZChlLCJkb3QiLGZ1bmN0aW9uKCl7cmV0dXJuIEx9KSx0LmQoZSwiY3Jvc3MiLGZ1bmN0aW9uKCl7cmV0dXJuIER9KSx0LmQoZSwibGVycCIsZnVuY3Rpb24oKXtyZXR1cm4gUn0pLHQuZChlLCJyYW5kb20iLGZ1bmN0aW9uKCl7cmV0dXJuIFN9KSx0LmQoZSwidHJhbnNmb3JtTWF0MiIsZnVuY3Rpb24oKXtyZXR1cm4gQn0pLHQuZChlLCJ0cmFuc2Zvcm1NYXQyZCIsZnVuY3Rpb24oKXtyZXR1cm4gd30pLHQuZChlLCJ0cmFuc2Zvcm1NYXQzIixmdW5jdGlvbigpe3JldHVybiBIfSksdC5kKGUsInRyYW5zZm9ybU1hdDQiLGZ1bmN0aW9uKCl7cmV0dXJuIEp9KSx0LmQoZSwicm90YXRlIixmdW5jdGlvbigpe3JldHVybiBxfSksdC5kKGUsImFuZ2xlIixmdW5jdGlvbigpe3JldHVybiBXfSksdC5kKGUsInplcm8iLGZ1bmN0aW9uKCl7cmV0dXJuIEd9KSx0LmQoZSwic3RyIixmdW5jdGlvbigpe3JldHVybiBRfSksdC5kKGUsImV4YWN0RXF1YWxzIixmdW5jdGlvbigpe3JldHVybiB0dH0pLHQuZChlLCJlcXVhbHMiLGZ1bmN0aW9uKCl7cmV0dXJuIF99KSx0LmQoZSwibGVuIixmdW5jdGlvbigpe3JldHVybiBzdH0pLHQuZChlLCJzdWIiLGZ1bmN0aW9uKCl7cmV0dXJuIGt9KSx0LmQoZSwibXVsIixmdW5jdGlvbigpe3JldHVybiBjdH0pLHQuZChlLCJkaXYiLGZ1bmN0aW9uKCl7cmV0dXJuIGZ0fSksdC5kKGUsImRpc3QiLGZ1bmN0aW9uKCl7cmV0dXJuIFV9KSx0LmQoZSwic3FyRGlzdCIsZnVuY3Rpb24oKXtyZXR1cm4gRn0pLHQuZChlLCJzcXJMZW4iLGZ1bmN0aW9uKCl7cmV0dXJuIFZ9KSx0LmQoZSwiZm9yRWFjaCIsZnVuY3Rpb24oKXtyZXR1cm4gWH0pO3ZhciByPXQoMik7ZnVuY3Rpb24gcygpe3ZhciBqPW5ldyByLkFSUkFZX1RZUEUoMik7cmV0dXJuIHIuQVJSQVlfVFlQRSE9RmxvYXQzMkFycmF5JiYoalswXT0wLGpbMV09MCksan1mdW5jdGlvbiBnKGope3ZhciB6PW5ldyByLkFSUkFZX1RZUEUoMik7cmV0dXJuIHpbMF09alswXSx6WzFdPWpbMV0sen1mdW5jdGlvbiB2KGoseil7dmFyIGQ9bmV3IHIuQVJSQVlfVFlQRSgyKTtyZXR1cm4gZFswXT1qLGRbMV09eixkfWZ1bmN0aW9uIGgoaix6KXtyZXR1cm4galswXT16WzBdLGpbMV09elsxXSxqfWZ1bmN0aW9uIGwoaix6LGQpe3JldHVybiBqWzBdPXosalsxXT1kLGp9ZnVuY3Rpb24gdShqLHosZCl7cmV0dXJuIGpbMF09elswXStkWzBdLGpbMV09elsxXStkWzFdLGp9ZnVuY3Rpb24gTShqLHosZCl7cmV0dXJuIGpbMF09elswXS1kWzBdLGpbMV09elsxXS1kWzFdLGp9ZnVuY3Rpb24gZihqLHosZCl7cmV0dXJuIGpbMF09elswXSpkWzBdLGpbMV09elsxXSpkWzFdLGp9ZnVuY3Rpb24geShqLHosZCl7cmV0dXJuIGpbMF09elswXS9kWzBdLGpbMV09elsxXS9kWzFdLGp9ZnVuY3Rpb24geChqLHope3JldHVybiBqWzBdPU1hdGguY2VpbCh6WzBdKSxqWzFdPU1hdGguY2VpbCh6WzFdKSxqfWZ1bmN0aW9uIGIoaix6KXtyZXR1cm4galswXT1NYXRoLmZsb29yKHpbMF0pLGpbMV09TWF0aC5mbG9vcih6WzFdKSxqfWZ1bmN0aW9uIE8oaix6LGQpe3JldHVybiBqWzBdPU1hdGgubWluKHpbMF0sZFswXSksalsxXT1NYXRoLm1pbih6WzFdLGRbMV0pLGp9ZnVuY3Rpb24gbShqLHosZCl7cmV0dXJuIGpbMF09TWF0aC5tYXgoelswXSxkWzBdKSxqWzFdPU1hdGgubWF4KHpbMV0sZFsxXSksan1mdW5jdGlvbiBwKGoseil7cmV0dXJuIGpbMF09TWF0aC5yb3VuZCh6WzBdKSxqWzFdPU1hdGgucm91bmQoelsxXSksan1mdW5jdGlvbiBuKGoseixkKXtyZXR1cm4galswXT16WzBdKmQsalsxXT16WzFdKmQsan1mdW5jdGlvbiBhKGoseixkLEUpe3JldHVybiBqWzBdPXpbMF0rZFswXSpFLGpbMV09elsxXStkWzFdKkUsan1mdW5jdGlvbiBpKGoseil7dmFyIGQ9elswXS1qWzBdLEU9elsxXS1qWzFdO3JldHVybiBNYXRoLmh5cG90KGQsRSl9ZnVuY3Rpb24gbyhqLHope3ZhciBkPXpbMF0talswXSxFPXpbMV0talsxXTtyZXR1cm4gZCpkK0UqRX1mdW5jdGlvbiBUKGope3ZhciB6PWpbMF0sZD1qWzFdO3JldHVybiBNYXRoLmh5cG90KHosZCl9ZnVuY3Rpb24gUChqKXt2YXIgej1qWzBdLGQ9alsxXTtyZXR1cm4geip6K2QqZH1mdW5jdGlvbiBDKGoseil7cmV0dXJuIGpbMF09LXpbMF0salsxXT0telsxXSxqfWZ1bmN0aW9uIEkoaix6KXtyZXR1cm4galswXT0xL3pbMF0salsxXT0xL3pbMV0san1mdW5jdGlvbiBBKGoseil7dmFyIGQ9elswXSxFPXpbMV0sTj1kKmQrRSpFO3JldHVybiBOPjAmJihOPTEvTWF0aC5zcXJ0KE4pKSxqWzBdPXpbMF0qTixqWzFdPXpbMV0qTixqfWZ1bmN0aW9uIEwoaix6KXtyZXR1cm4galswXSp6WzBdK2pbMV0qelsxXX1mdW5jdGlvbiBEKGoseixkKXt2YXIgRT16WzBdKmRbMV0telsxXSpkWzBdO3JldHVybiBqWzBdPWpbMV09MCxqWzJdPUUsan1mdW5jdGlvbiBSKGoseixkLEUpe3ZhciBOPXpbMF0sJD16WzFdO3JldHVybiBqWzBdPU4rRSooZFswXS1OKSxqWzFdPSQrRSooZFsxXS0kKSxqfWZ1bmN0aW9uIFMoaix6KXt6PXp8fDE7dmFyIGQ9ci5SQU5ET00oKSoyKk1hdGguUEk7cmV0dXJuIGpbMF09TWF0aC5jb3MoZCkqeixqWzFdPU1hdGguc2luKGQpKnosan1mdW5jdGlvbiBCKGoseixkKXt2YXIgRT16WzBdLE49elsxXTtyZXR1cm4galswXT1kWzBdKkUrZFsyXSpOLGpbMV09ZFsxXSpFK2RbM10qTixqfWZ1bmN0aW9uIHcoaix6LGQpe3ZhciBFPXpbMF0sTj16WzFdO3JldHVybiBqWzBdPWRbMF0qRStkWzJdKk4rZFs0XSxqWzFdPWRbMV0qRStkWzNdKk4rZFs1XSxqfWZ1bmN0aW9uIEgoaix6LGQpe3ZhciBFPXpbMF0sTj16WzFdO3JldHVybiBqWzBdPWRbMF0qRStkWzNdKk4rZFs2XSxqWzFdPWRbMV0qRStkWzRdKk4rZFs3XSxqfWZ1bmN0aW9uIEooaix6LGQpe3ZhciBFPXpbMF0sTj16WzFdO3JldHVybiBqWzBdPWRbMF0qRStkWzRdKk4rZFsxMl0salsxXT1kWzFdKkUrZFs1XSpOK2RbMTNdLGp9ZnVuY3Rpb24gcShqLHosZCxFKXt2YXIgTj16WzBdLWRbMF0sJD16WzFdLWRbMV0sSz1NYXRoLnNpbihFKSxZPU1hdGguY29zKEUpO3JldHVybiBqWzBdPU4qWS0kKksrZFswXSxqWzFdPU4qSyskKlkrZFsxXSxqfWZ1bmN0aW9uIFcoaix6KXt2YXIgZD1qWzBdLEU9alsxXSxOPXpbMF0sJD16WzFdLEs9TWF0aC5zcXJ0KGQqZCtFKkUpKk1hdGguc3FydChOKk4rJCokKSxZPUsmJihkKk4rRSokKS9LO3JldHVybiBNYXRoLmFjb3MoTWF0aC5taW4oTWF0aC5tYXgoWSwtMSksMSkpfWZ1bmN0aW9uIEcoail7cmV0dXJuIGpbMF09MCxqWzFdPTAsan1mdW5jdGlvbiBRKGope3JldHVybiJ2ZWMyKCIralswXSsiLCAiK2pbMV0rIikifWZ1bmN0aW9uIHR0KGoseil7cmV0dXJuIGpbMF09PT16WzBdJiZqWzFdPT09elsxXX1mdW5jdGlvbiBfKGoseil7dmFyIGQ9alswXSxFPWpbMV0sTj16WzBdLCQ9elsxXTtyZXR1cm4gTWF0aC5hYnMoZC1OKTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoZCksTWF0aC5hYnMoTikpJiZNYXRoLmFicyhFLSQpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhFKSxNYXRoLmFicygkKSl9dmFyIHN0PVQsaz1NLGN0PWYsZnQ9eSxVPWksRj1vLFY9UCxYPWZ1bmN0aW9uKCl7dmFyIGo9cygpO3JldHVybiBmdW5jdGlvbih6LGQsRSxOLCQsSyl7dmFyIFksWjtmb3IoZHx8KGQ9MiksRXx8KEU9MCksTj9aPU1hdGgubWluKE4qZCtFLHoubGVuZ3RoKTpaPXoubGVuZ3RoLFk9RTtZPFo7WSs9ZClqWzBdPXpbWV0salsxXT16W1krMV0sJChqLGosSykseltZXT1qWzBdLHpbWSsxXT1qWzFdO3JldHVybiB6fX0oKX0sZnVuY3Rpb24oYyxlLHQpe3QucihlKTt2YXIgcj10KDEzKTt0LmQoZSwiUmVuZGVyZXIiLGZ1bmN0aW9uKCl7cmV0dXJuIHIuZGVmYXVsdH0pO3ZhciBzPXQoNDApO3QuZChlLCJGaWd1cmUyRCIsZnVuY3Rpb24oKXtyZXR1cm4gcy5kZWZhdWx0fSk7dmFyIGc9dCg1Nik7dC5kKGUsIk1lc2gyRCIsZnVuY3Rpb24oKXtyZXR1cm4gZy5kZWZhdWx0fSk7dmFyIHY9dCgyOSk7dC5kKGUsIk1lc2hDbG91ZCIsZnVuY3Rpb24oKXtyZXR1cm4gdi5kZWZhdWx0fSk7dmFyIGg9dCgyMyk7dC5kKGUsInBhcnNlRm9udCIsZnVuY3Rpb24oKXtyZXR1cm4gaC5kZWZhdWx0fSk7dmFyIGw9dCgzMSk7dC5kKGUsInBhcnNlQ29sb3IiLGZ1bmN0aW9uKCl7cmV0dXJuIGwuZGVmYXVsdH0pO3ZhciB1PXQoMjEpO3QuZChlLCJFTlYiLGZ1bmN0aW9uKCl7cmV0dXJuIHUuZGVmYXVsdH0pLHQoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KX0sZnVuY3Rpb24oYyxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gSX0pO3ZhciByPXQoMTQpLHM9dCgxKSxnPXQoMjApLHY9dCgyNyksaD10KDI1KSxsPXQoNDApLHU9dCg1NiksTT10KDI5KSxmPXQoNTkpLHk9dCgyMSkseD10KDYzKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3QgYj17YXV0b1VwZGF0ZTohMSxwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6ITEsYnVmZmVyU2l6ZToxNTAwfSxPPWBhdHRyaWJ1dGUgdmVjMyBhX3ZlcnRleFBvc2l0aW9uOwphdHRyaWJ1dGUgdmVjMyBhX3ZlcnRleFRleHR1cmVDb29yZDsKdmFyeWluZyB2ZWMzIHZUZXh0dXJlQ29vcmQ7CnVuaWZvcm0gbWF0MyB2aWV3TWF0cml4Owp1bmlmb3JtIG1hdDMgcHJvamVjdGlvbk1hdHJpeDsKCnZvaWQgbWFpbigpIHsKICBnbF9Qb2ludFNpemUgPSAxLjA7CiAgdmVjMyBwb3MgPSBwcm9qZWN0aW9uTWF0cml4ICogdmlld01hdHJpeCAqIHZlYzMoYV92ZXJ0ZXhQb3NpdGlvbi54eSwgMS4wKTsKICBnbF9Qb3NpdGlvbiA9IHZlYzQocG9zLnh5LCAxLjAsIDEuMCk7ICAgIAogIHZUZXh0dXJlQ29vcmQgPSBhX3ZlcnRleFRleHR1cmVDb29yZDsgICAgICAgICAgICAgIAp9CmAsbT1gcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7CnZhcnlpbmcgdmVjMyB2VGV4dHVyZUNvb3JkOwp1bmlmb3JtIHNhbXBsZXIyRCB1X3RleFNhbXBsZXI7CnZvaWQgbWFpbigpIHsKICBnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQodV90ZXhTYW1wbGVyLCB2VGV4dHVyZUNvb3JkLnh5KTsKfQpgLHA9U3ltYm9sKCJnbFJlbmRlcmVyIiksbj1TeW1ib2woImNhbnZhc1JlbmRlcmVyIiksYT1TeW1ib2woIm9wdGlvbnMiKSxpPVN5bWJvbCgiZ2xvYmFsVHJhbnNmb3JtIiksbz1TeW1ib2woImFwcGx5R2xvYmFsVHJhbnNmb3JtIiksVD1TeW1ib2woImNhbnZhcyIpO2Z1bmN0aW9uIFAoQSl7Y29uc3QgTD1BLmdsLEQ9QS5mYm87RCYmTC5iaW5kRnJhbWVidWZmZXIoTC5GUkFNRUJVRkZFUixEKSxBLl9kcmF3KCksRCYmTC5iaW5kRnJhbWVidWZmZXIoTC5GUkFNRUJVRkZFUixudWxsKX1mdW5jdGlvbiBDKEEsTCxELFIpe2NvbnN0IFM9QS5jcmVhdGVUZXh0dXJlKEwuY2FudmFzKSxCPVtbWzAsMF0sW0QsMF0sW0QsUl0sWzAsUl0sWzAsMF1dXTtCLmNsb3NlZD0hMDtjb25zdCB3PW5ldyB1LmRlZmF1bHQoe2NvbnRvdXJzOkJ9KTt3LnNldFRleHR1cmUoUyksQS5zZXRNZXNoRGF0YShbdy5tZXNoRGF0YV0pLFAoQSksUy5kZWxldGUoKSxMLmNsZWFyUmVjdCgwLDAsRCxSKSxkZWxldGUgTC5fZmlsdGVyfWNsYXNzIEl7Y29uc3RydWN0b3IoTCxEPXt9KXtsZXQgUj1ELmNvbnRleHRUeXBlO2lmKFJ8fCh0eXBlb2YgV2ViR0wyUmVuZGVyaW5nQ29udGV4dD09ImZ1bmN0aW9uIj9SPSJ3ZWJnbDIiOnR5cGVvZiBXZWJHTFJlbmRlcmluZ0NvbnRleHQ9PSJmdW5jdGlvbiI/Uj0id2ViZ2wiOlI9IjJkIiksIUwuZ2V0Q29udGV4dCl7Y29uc3QgUz1MO0w9e2dldENvbnRleHQoKXtyZXR1cm4gU30sd2lkdGg6RC53aWR0aCxoZWlnaHQ6RC5oZWlnaHR9LFMuY2FudmFzPUwsUj0iMmQifWlmKHRoaXNbVF09TCxSIT09IndlYmdsIiYmUiE9PSJ3ZWJnbDIiJiZSIT09IjJkIil0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gY29udGV4dCB0eXBlICR7Un1gKTtpZihELmNvbnRleHRUeXBlPVIsdGhpc1thXT1PYmplY3QuYXNzaWduKHt9LGIsRCksUj09PSJ3ZWJnbCJ8fFI9PT0id2ViZ2wyIil7Uj09PSJ3ZWJnbDIiJiYodGhpc1thXS53ZWJnbDI9ITApO2NvbnN0IFM9bmV3IHIuZGVmYXVsdChMLHRoaXNbYV0pO1I9PT0id2ViZ2wyIiYmIVMuaXNXZWJHTDImJihELmNvbnRleHRUeXBlPSJ3ZWJnbCIpLE9iamVjdCh4LmNyZWF0ZVNoYWRlcnMpKFMpLE9iamVjdCh4LmFwcGx5U2hhZGVyKShTKSxPYmplY3QoeC5jcmVhdGVDbG91ZFNoYWRlcnMpKFMpO2NvbnN0IEI9Uy5nbDtCLmNsZWFyQ29sb3IoMCwwLDAsMCksQi5ibGVuZEZ1bmNTZXBhcmF0ZShCLlNSQ19BTFBIQSxCLk9ORV9NSU5VU19TUkNfQUxQSEEsQi5PTkUsQi5PTkVfTUlOVVNfU1JDX0FMUEhBKSx0aGlzW3BdPVN9ZWxzZSB0aGlzW25dPW5ldyBnLmRlZmF1bHQoTCx0aGlzW2FdKTt0aGlzW2ldPVsxLDAsMCwwLDEsMCwwLDAsMV0sdGhpcy51cGRhdGVSZXNvbHV0aW9uKCl9Z2V0IGNhbnZhcygpe3JldHVybiB0aGlzW1RdfWdldCBjYW52YXNSZW5kZXJlcigpe3JldHVybiB0aGlzW25dfWdldCBnbFJlbmRlcmVyKCl7cmV0dXJuIHRoaXNbcF19Z2V0IGlzV2ViR0wyKCl7cmV0dXJuIHRoaXNbcF0mJnRoaXNbcF0uaXNXZWJHTDJ9Z2V0IG9wdGlvbnMoKXtyZXR1cm4gdGhpc1thXX1nZXQgZ2xvYmFsVHJhbnNmb3JtTWF0cml4KCl7Y29uc3QgTD10aGlzW2ldO3JldHVybltMWzBdLExbMV0sTFszXSxMWzRdLExbNl0sTFs3XV19Z2V0IHZpZXdNYXRyaXgoKXtyZXR1cm4gdGhpc1tpXX1bb10oKXtjb25zdCBMPXRoaXNbcF18fHRoaXNbbl07aWYodGhpc1twXSl7Y29uc3R7d2lkdGg6RCxoZWlnaHQ6Un09dGhpcy5jYW52YXM7TC51bmlmb3Jtcy52aWV3TWF0cml4PXRoaXMudmlld01hdHJpeCxMLnVuaWZvcm1zLnByb2plY3Rpb25NYXRyaXg9dGhpcy5wcm9qZWN0aW9uTWF0cml4LEwudW5pZm9ybXMudV9yZXNvbHV0aW9uPVtELFJdfX11cGRhdGVSZXNvbHV0aW9uKCl7Y29uc3R7d2lkdGg6TCxoZWlnaHQ6RH09dGhpcy5jYW52YXMsUj1bMSwwLDAsMCwxLDAsLUwvMiwtRC8yLDFdLFM9WzIvTCwwLDAsMCwtMi9ELDAsMCwwLDFdLEI9cy5tYXQzLm11bHRpcGx5KEFycmF5Lm9mKDAsMCwwLDAsMCwwLDAsMCwwKSxTLFIpO3RoaXMucHJvamVjdGlvbk1hdHJpeD1CLHRoaXNbcF0mJnRoaXNbcF0uZ2wudmlld3BvcnQoMCwwLEwsRCl9Y3JlYXRlVGV4dHVyZShMLEQpe3JldHVybih0aGlzW3BdfHx0aGlzW25dKS5jcmVhdGVUZXh0dXJlKEwsRCl9bG9hZFRleHR1cmUoTCx7dXNlSW1hZ2VCaXRtYXA6RD0hMX09e30pe3JldHVybih0aGlzW3BdfHx0aGlzW25dKS5sb2FkVGV4dHVyZShMLHt1c2VJbWFnZUJpdG1hcDpEfSl9Y3JlYXRlVGV4dChMLHtmb250OkQ9IjE2cHggYXJpYWwiLGZpbGxDb2xvcjpSPW51bGwsc3Ryb2tlQ29sb3I6Uz1udWxsLHN0cm9rZVdpZHRoOkI9MX09e30pe2lmKHRoaXNbcF0pe2NvbnN0IHc9eS5kZWZhdWx0LmNyZWF0ZVRleHQoTCx7Zm9udDpELGZpbGxDb2xvcjpSLHN0cm9rZUNvbG9yOlMsc3Ryb2tlV2lkdGg6Qn0pO3JldHVybntpbWFnZTp0aGlzLmNyZWF0ZVRleHR1cmUody5pbWFnZSkscmVjdDp3LnJlY3R9fXJldHVybntfaW1nOntmb250OkQsZmlsbENvbG9yOlIsc3Ryb2tlQ29sb3I6UyxzdHJva2VXaWR0aDpCLHRleHQ6TH19fWNyZWF0ZVByb2dyYW0oe3ZlcnRleDpMLGZyYWdtZW50OkQsb3B0aW9uczpSfT17fSl7aWYodGhpc1twXSl7Y29uc3QgUz10aGlzW3BdLmNvbXBpbGVTeW5jKEQsTCk7cmV0dXJuIFMuX2F0dHJpYk9wdHM9UixTfXRocm93IG5ldyBFcnJvcigiQ29udGV4dCAyRCBjYW5ub3QgY3JlYXRlIHdlYmdsIHByb2dyYW0uIil9Y3JlYXRlUGFzc1Byb2dyYW0oe3ZlcnRleDpMPU8sZnJhZ21lbnQ6RD1tLG9wdGlvbnM6Un09e30pe3JldHVybiB0aGlzLmNyZWF0ZVByb2dyYW0oe3ZlcnRleDpMLGZyYWdtZW50OkQsb3B0aW9uczpSfSl9dXNlUHJvZ3JhbShMLEQ9e30pe2lmKHRoaXNbcF0pe2NvbnN0IFI9T2JqZWN0LmFzc2lnbih7fSxMLl9hdHRyaWJPcHRzLEQpO3JldHVybiB0aGlzW3BdLnVzZVByb2dyYW0oTCxSKX10aHJvdyBuZXcgRXJyb3IoIkNvbnRleHQgMkQgY2Fubm90IHVzZSB3ZWJnbCBwcm9ncmFtLiIpfWRlbGV0ZVRleHR1cmUoTCl7cmV0dXJuKHRoaXNbcF18fHRoaXNbbl0pLmRlbGV0ZVRleHR1cmUoTCl9Y2xlYXIoLi4uTCl7aWYodGhpc1twXSl7Y29uc3QgRD10aGlzW3BdLmdsO0QuY2xlYXIoRC5DT0xPUl9CVUZGRVJfQklUKX1lbHNlIHRoaXNbbl0uY2xlYXIoLi4uTCl9ZHJhd01lc2hDbG91ZChMLHtjbGVhcjpEPSExLHByb2dyYW06Uj1udWxsfT17fSl7Y29uc3QgUz10aGlzW3BdfHx0aGlzW25dLEI9Unx8TC5wcm9ncmFtO2lmKHRoaXNbcF0pe2NvbnN0IHc9Uy5nbDtpZihEJiZ3LmNsZWFyKHcuQ09MT1JfQlVGRkVSX0JJVCksQilTLnByb2dyYW0hPT1CJiZ0aGlzLnVzZVByb2dyYW0oQix7YV9jb2xvcjp7dHlwZToiVU5TSUdORURfQllURSIsbm9ybWFsaXplOiEwfSxhX2ZpbGxDbG91ZENvbG9yOnt0eXBlOiJVTlNJR05FRF9CWVRFIixub3JtYWxpemU6ITB9LGFfc3Ryb2tlQ2xvdWRDb2xvcjp7dHlwZToiVU5TSUdORURfQllURSIsbm9ybWFsaXplOiEwfSxhX2ZyYW1lSW5kZXg6e3R5cGU6IlVOU0lHTkVEX0JZVEUiLG5vcm1hbGl6ZTohMX19KTtlbHNle2NvbnN0IEg9TC5tZXNoLm1lc2hEYXRhLEo9ISFILnVuaWZvcm1zLnVfdGV4U2FtcGxlcixxPSEhSC51bmlmb3Jtcy51X2ZpbHRlckZsYWcsVz0hIUgudW5pZm9ybXMudV9yYWRpYWxHcmFkaWVudFZlY3RvcixHPUwuaGFzQ2xvdWRDb2xvcixRPUwuaGFzQ2xvdWRGaWx0ZXIsdHQ9ISFILnVuaWZvcm1zLnVfY2xpcFNhbXBsZXI7T2JqZWN0KHguYXBwbHlDbG91ZFNoYWRlcikoUyx7aGFzVGV4dHVyZTpKLGhhc0ZpbHRlcjpxLGhhc0dyYWRpZW50OlcsaGFzQ2xvdWRDb2xvcjpHLGhhc0Nsb3VkRmlsdGVyOlEsaGFzQ2xpcFBhdGg6dHR9KX10aGlzW29dKCksUy5zZXRNZXNoRGF0YShbTC5tZXNoRGF0YV0pLEwuYmVmb3JlUmVuZGVyJiZMLmJlZm9yZVJlbmRlcih3LEwpLFAoUyksTC5hZnRlclJlbmRlciYmTC5hZnRlclJlbmRlcih3LEwpfWVsc2UgUy5zZXRUcmFuc2Zvcm0odGhpcy5nbG9iYWxUcmFuc2Zvcm1NYXRyaXgpLFMuZHJhd01lc2hDbG91ZChMLHtjbGVhcjpELGhvb2s6ITF9KX1kcmF3TWVzaGVzKEwse2NsZWFyOkQ9ITEscHJvZ3JhbTpSPW51bGx9PXt9KXtjb25zdCBTPXRoaXNbcF18fHRoaXNbbl07aWYodGhpc1twXSl7Y29uc3QgQj1TLmZibyx3PU9iamVjdCh2LmRlZmF1bHQpKHRoaXMsTCxSPT1udWxsKSxIPVMuZ2w7RCYmSC5jbGVhcihILkNPTE9SX0JVRkZFUl9CSVQpO2NvbnN0IEo9IU9iamVjdChmLmlzVW5pdFRyYW5zZm9ybSkodGhpcy5nbG9iYWxUcmFuc2Zvcm1NYXRyaXgpO3RoaXMuX2RyYXdDYWxscz0wO2Zvcihjb25zdCBxIG9mIHcpe3RoaXMuX2RyYXdDYWxscysrO2NvbnN0IFc9Unx8cS5wcm9ncmFtO2lmKHEgaW5zdGFuY2VvZiBNLmRlZmF1bHQpdGhpcy5kcmF3TWVzaENsb3VkKHEse2NsZWFyOkQscHJvZ3JhbTpXfSk7ZWxzZXtjb25zdHt3aWR0aDpHLGhlaWdodDpRfT10aGlzLmNhbnZhcztpZihxLmJlZm9yZVJlbmRlciYmcS5iZWZvcmVSZW5kZXIoSCxxKSxxLnBhc3MubGVuZ3RoJiYoKCF0aGlzLmZib3x8dGhpcy5mYm8ud2lkdGghPT1HfHx0aGlzLmZiby5oZWlnaHQhPT1RKSYmKHRoaXMuZmJvPXt3aWR0aDpHLGhlaWdodDpRLHRhcmdldDpTLmNyZWF0ZUZCTygpLGJ1ZmZlcjpTLmNyZWF0ZUZCTygpLHN3YXAoKXtbdGhpcy50YXJnZXQsdGhpcy5idWZmZXJdPVt0aGlzLmJ1ZmZlcix0aGlzLnRhcmdldF19fSksUy5iaW5kRkJPKHRoaXMuZmJvLnRhcmdldCkpLCFXJiZxLmZpbHRlckNhbnZhcyl7T2JqZWN0KHguYXBwbHlTaGFkZXIpKFMse2hhc1RleHR1cmU6ITB9KTtsZXQgdHQ9dGhpcy5maWx0ZXJDb250ZXh0O3R0fHwodHQ9eS5kZWZhdWx0LmNyZWF0ZUNhbnZhcyhHLFEpLmdldENvbnRleHQoIjJkIiksdGhpcy5maWx0ZXJDb250ZXh0PXR0KTtjb25zdCBfPUxbcS5wYWNrSW5kZXhdLHN0PV8uZmlsdGVyLGs9TFtxLnBhY2tJbmRleCsxXSxjdD1MW3EucGFja0luZGV4LTFdOyghY3R8fCFjdC5maWx0ZXJDYW52YXN8fGN0LmZpbHRlciE9PXN0KSYmKCFrfHwhay5maWx0ZXJDYW52YXN8fGsuZmlsdGVyIT09c3QpPyhKPyh0dC5zYXZlKCksT2JqZWN0KGguZHJhd01lc2gyRCkoXyx0dCwhMSksdHQucmVzdG9yZSgpLE9iamVjdChoLmFwcGx5RmlsdGVyKSh0dCxzdCkpOk9iamVjdChoLmRyYXdNZXNoMkQpKF8sdHQsITApLHRoaXNbb10oKSxDKFMsdHQsRyxRKSk6KEomJnR0LnNhdmUoKSxPYmplY3QoaC5kcmF3TWVzaDJEKShfLHR0LCExKSxKJiZ0dC5yZXN0b3JlKCksKCFrfHwhay5maWx0ZXJDYW52YXN8fF8uZmlsdGVyIT09ay5maWx0ZXIpJiYoT2JqZWN0KGguYXBwbHlGaWx0ZXIpKHR0LHN0KSx0aGlzW29dKCksQyhTLHR0LEcsUSkpKX1lbHNle2lmKFcpUy5wcm9ncmFtIT09VyYmdGhpcy51c2VQcm9ncmFtKFcse2FfY29sb3I6e3R5cGU6IlVOU0lHTkVEX0JZVEUiLG5vcm1hbGl6ZTohMH19KTtlbHNle2NvbnN0IHR0PSEhcS51bmlmb3Jtcy51X3RleFNhbXBsZXIsXz0hIXEudW5pZm9ybXMudV9maWx0ZXJGbGFnLHN0PSEhcS51bmlmb3Jtcy51X3JhZGlhbEdyYWRpZW50VmVjdG9yLGs9ISFxLnVuaWZvcm1zLnVfY2xpcFNhbXBsZXI7T2JqZWN0KHguYXBwbHlTaGFkZXIpKFMse2hhc1RleHR1cmU6dHQsaGFzRmlsdGVyOl8saGFzR3JhZGllbnQ6c3QsaGFzQ2xpcFBhdGg6a30pfXEuZmlsdGVyQ2FudmFzJiZjb25zb2xlLndhcm4oIlVzZXIgcHJvZ3JhbSBpZ25vcmVkIHNvbWUgZmlsdGVyIGVmZmVjdHMuIiksdGhpc1tvXSgpLFMuc2V0TWVzaERhdGEoW3FdKSxQKFMpfWlmKHEucGFzcy5sZW5ndGgpe2NvbnN0IHR0PXEucGFzcy5sZW5ndGg7cS5wYXNzLmZvckVhY2goKF8sc3QpPT57Xy5ibGVuZD1xLmVuYWJsZUJsZW5kLF8uc2V0VGV4dHVyZShTLmZiby50ZXh0dXJlKSxzdD09PXR0LTE/Uy5iaW5kRkJPKEIpOih0aGlzLmZiby5zd2FwKCksUy5iaW5kRkJPKHRoaXMuZmJvLnRhcmdldCkpLF8ucHJvZ3JhbT9TLnVzZVByb2dyYW0oXy5wcm9ncmFtKToodGhpcy5kZWZhdWx0UGFzc1Byb2dyYW09dGhpcy5kZWZhdWx0UGFzc1Byb2dyYW18fHRoaXMuY3JlYXRlUGFzc1Byb2dyYW0oKSxTLnVzZVByb2dyYW0odGhpcy5kZWZhdWx0UGFzc1Byb2dyYW0pKSxTLnNldE1lc2hEYXRhKFtfLm1lc2hEYXRhXSksSC5jbGVhcihILkNPTE9SX0JVRkZFUl9CSVQpLFAoUyl9KX1xLmFmdGVyUmVuZGVyJiZxLmFmdGVyUmVuZGVyKEgscSl9fX1lbHNlIFMuc2V0VHJhbnNmb3JtKHRoaXMuZ2xvYmFsVHJhbnNmb3JtTWF0cml4KSxTLmRyYXdNZXNoZXMoTCx7Y2xlYXI6RH0pfWRyYXdJbWFnZShMLC4uLkQpe2NvbnN0IFI9RC5sZW5ndGg7aWYoUjwyKXRocm93IG5ldyBUeXBlRXJyb3IoYEZhaWxlZCB0byBleGVjdXRlICdkcmF3SW1hZ2UnIG9uICdSZW5kZXJlcic6IDMgYXJndW1lbnRzIHJlcXVpcmVkLCBidXQgb25seSAke0QubGVuZ3RoKzF9IHByZXNlbnQuYCk7aWYoUiE9PTImJlIhPT00JiZSIT09OCl0aHJvdyBuZXcgVHlwZUVycm9yKGBGYWlsZWQgdG8gZXhlY3V0ZSAnZHJhd0ltYWdlJyBvbiAnUmVuZGVyZXInOiBWYWxpZCBhcml0aWVzIGFyZTogWzMsIDUsIDldLCBidXQgJHtELmxlbmd0aCsxfSBhcmd1bWVudHMgcHJvdmlkZWQuYCk7bGV0IFM9bnVsbCxCPW51bGw7Uj09PTI/Uz1bRFswXSxEWzFdLEwud2lkdGgsTC5oZWlnaHRdOlI9PT00P1M9RDpSPT09OCYmKEI9RC5zbGljZSgwLDQpLFM9RC5zbGljZSg0KSk7Y29uc3Qgdz10aGlzLmNyZWF0ZVRleHR1cmUoTCkse3dpZHRoOkgsaGVpZ2h0Okp9PXRoaXMuY2FudmFzLHE9bmV3IGwuZGVmYXVsdDtxLnJlY3QoU1swXSxTWzFdLEgsSik7Y29uc3QgVz1uZXcgdS5kZWZhdWx0KHEse3dpZHRoOkgsaGVpZ2h0Okp9KTtXLnNldFRleHR1cmUodyx7cmVjdDpTLHNyY1JlY3Q6Qn0pLHRoaXMuZHJhd01lc2hlcyhbV10pLHRoaXMuZGVsZXRlVGV4dHVyZSh3KX1zZXRHbG9iYWxUcmFuc2Zvcm0oLi4uTCl7cmV0dXJuIHRoaXNbaV09W0xbMF0sTFsxXSwwLExbMl0sTFszXSwwLExbNF0sTFs1XSwxXSx0aGlzfWdsb2JhbFRyYW5zZm9ybSguLi5MKXtjb25zdCBEPXRoaXNbaV07cmV0dXJuIHRoaXNbaV09cy5tYXQzLm11bHRpcGx5KEFycmF5Lm9mKDAsMCwwLDAsMCwwLDAsMCwwKSxELEwpLHRoaXN9Z2xvYmFsVHJhbnNsYXRlKEwsRCl7bGV0IFI9cy5tYXQzLmNyZWF0ZSgpO3JldHVybiBSPXMubWF0My50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDAsMCwwLDApLFIsW0wsRF0pLHRoaXMuZ2xvYmFsVHJhbnNmb3JtKC4uLlIpfWdsb2JhbFJvdGF0ZShMLFtELFJdPVswLDBdKXtsZXQgUz1zLm1hdDMuY3JlYXRlKCk7cmV0dXJuIFM9cy5tYXQzLnRyYW5zbGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCwwLDAsMCksUyxbRCxSXSksUz1zLm1hdDMucm90YXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwLDAsMCwwKSxTLEwpLFM9cy5tYXQzLnRyYW5zbGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCwwLDAsMCksUyxbLUQsLVJdKSx0aGlzLmdsb2JhbFRyYW5zZm9ybSguLi5TKX1nbG9iYWxTY2FsZShMLEQ9TCxbUixTXT1bMCwwXSl7bGV0IEI9cy5tYXQzLmNyZWF0ZSgpO3JldHVybiBCPXMubWF0My50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDAsMCwwLDApLEIsW1IsU10pLEI9cy5tYXQzLnNjYWxlKEFycmF5Lm9mKDAsMCwwLDAsMCwwLDAsMCwwKSxCLFtMLERdKSxCPXMubWF0My50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDAsMCwwLDApLEIsWy1SLC1TXSksdGhpcy5nbG9iYWxUcmFuc2Zvcm0oLi4uQil9Z2xvYmFsU2tldyhMLEQ9TCxbUixTXT1bMCwwXSl7bGV0IEI9cy5tYXQzLmNyZWF0ZSgpO3JldHVybiBCPXMubWF0My50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDAsMCwwLDApLEIsW1IsU10pLEI9cy5tYXQzLm11bHRpcGx5KEFycmF5Lm9mKDAsMCwwLDAsMCwwLDAsMCwwKSxCLHMubWF0My5mcm9tVmFsdWVzKDEsTWF0aC50YW4oRCksTWF0aC50YW4oTCksMSwwLDApKSxCPXMubWF0My50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDAsMCwwLDApLEIsWy1SLC1TXSksdGhpcy5nbG9iYWxUcmFuc2Zvcm0oLi4uQil9dHJhbnNmb3JtUG9pbnQoTCxELFIpe2xldCBTPXRoaXMuZ2xvYmFsVHJhbnNmb3JtTWF0cml4O1ImJihTPXMubWF0My5tdWx0aXBseShBcnJheS5vZigwLDAsMCwwLDAsMCwwLDAsMCksUyxSKSk7Y29uc3QgQj1MKlNbMF0rRCpTWzJdK1NbNF0sdz1MKlNbMV0rRCpTWzNdK1NbNV07cmV0dXJuW0Isd119fX0sZnVuY3Rpb24oYyxlLHQpe3QucihlKTt2YXIgcj10KDE1KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSksZS5kZWZhdWx0PXIuZGVmYXVsdH0sZnVuY3Rpb24oYyxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4geH0pO3ZhciByPXQoMTYpLHM9dCgxNyksZz10KDE4KSx2PXQoMTkpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBoKGIsTyxtKXtyZXR1cm4gTyBpbiBiP09iamVjdC5kZWZpbmVQcm9wZXJ0eShiLE8se3ZhbHVlOm0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTpiW09dPW0sYn1jb25zdCBsPXt9O2Z1bmN0aW9uIHUoYixPPTMpe2NvbnN0IG09W10scD1iLmxlbmd0aDtmb3IobGV0IG49MDtuPHA7bisrKW4lTzwyJiZtLnB1c2goLjUqKGJbbl0rMSkpO3JldHVybiBtfWZ1bmN0aW9uIE0oYixPKXtjb25zdCBtPU8uX2J1ZmZlcnM7T2JqZWN0LnZhbHVlcyhtKS5mb3JFYWNoKHA9PntiLmRlbGV0ZUJ1ZmZlcihwKX0pLE8uX2J1ZmZlcnM9e319ZnVuY3Rpb24gZihiLE8sbSl7cmV0dXJuIGIuYWN0aXZlVGV4dHVyZShiLlRFWFRVUkUwK20pLEFycmF5LmlzQXJyYXkoTy5faW1nKT9iLmJpbmRUZXh0dXJlKGIuVEVYVFVSRV9DVUJFX01BUCxPKTpiLmJpbmRUZXh0dXJlKGIuVEVYVFVSRV8yRCxPKSxPfWNvbnN0IHk9e2ludDoiMWkiLGl2ZWMyOiIyaSIsaXZlYzM6IjNpIixpdmVjNDoiNGkiLGZsb2F0OiIxZiIsdmVjMjoiMmYiLHZlYzM6IjNmIix2ZWM0OiI0ZiIsbWF0MjoiTWF0cml4MmZ2IixtYXQzOiJNYXRyaXgzZnYiLG1hdDQ6Ik1hdHJpeDRmdiIsc2FtcGxlcjFEOiJzYW1wbGVyMUQiLHNhbXBsZXIyRDoic2FtcGxlcjJEIixzYW1wbGVyM0Q6InNhbXBsZXIzRCIsc2FtcGxlckN1YmU6InNhbXBsZXJDdWJlIixzYW1wbGVyMURTaGFkb3c6InNhbXBsZXIxRFNoYWRvdyIsc2FtcGxlcjJEU2hhZG93OiJzYW1wbGVyMkRTaGFkb3ciLHNhbXBsZXIyRFJlY3Q6InNhbXBsZXIyRFJlY3QiLHNhbXBsZXIyRFJlY3RTaGFkb3c6InNhbXBsZXIyRFJlY3RTaGFkb3cifTtjbGFzcyB4e3N0YXRpYyBhZGRMaWJzKE89e30pe09iamVjdC5hc3NpZ24obCxPKX1zdGF0aWMgRkxPQVQoTyxtKXtyZXR1cm4gT2JqZWN0KHIucG9pbnRzVG9CdWZmZXIpKE8sRmxvYXQzMkFycmF5LG0pfXN0YXRpYyBVTlNJR05FRF9CWVRFKE8sbSl7cmV0dXJuIE9iamVjdChyLnBvaW50c1RvQnVmZmVyKShPLFVpbnQ4QXJyYXksbSl9c3RhdGljIFVOU0lHTkVEX1NIT1JUKE8sbSl7cmV0dXJuIE9iamVjdChyLnBvaW50c1RvQnVmZmVyKShPLFVpbnQxNkFycmF5LG0pfXN0YXRpYyBCWVRFKE8sbSl7cmV0dXJuIE9iamVjdChyLnBvaW50c1RvQnVmZmVyKShPLEludDhBcnJheSxtKX1zdGF0aWMgU0hPUlQoTyxtKXtyZXR1cm4gT2JqZWN0KHIucG9pbnRzVG9CdWZmZXIpKE8sSW50MTZBcnJheSxtKX1jb25zdHJ1Y3RvcihPLG09e30pe3RoaXMub3B0aW9ucz1PYmplY3QuYXNzaWduKHt9LHguZGVmYXVsdE9wdGlvbnMsbSksdGhpcy5jYW52YXM9TztsZXQgcDt0aGlzLm9wdGlvbnMud2ViZ2wyJiYocD1PLmdldENvbnRleHQoIndlYmdsMiIsdGhpcy5vcHRpb25zKSkscD09bnVsbCYmKHA9T2JqZWN0KHIuc2V0dXBXZWJHTCkoTyx0aGlzLm9wdGlvbnMpLHRoaXMuYWlhX2V4dD1wLmdldEV4dGVuc2lvbigiQU5HTEVfaW5zdGFuY2VkX2FycmF5cyIpKSx0aGlzLmdsPXAscC52aWV3cG9ydCgwLDAsTy53aWR0aCxPLmhlaWdodCkscC5jbGVhckNvbG9yKDAsMCwwLDApLHAuYmxlbmRGdW5jU2VwYXJhdGUocC5TUkNfQUxQSEEscC5PTkVfTUlOVVNfU1JDX0FMUEhBLHAuT05FLHAuT05FX01JTlVTX1NSQ19BTFBIQSksdGhpcy5wcm9ncmFtcz1bXSx0aGlzLl9ldmVudHM9e319Z2V0IHByb2dyYW0oKXtjb25zdCBPPXRoaXMuZ2w7cmV0dXJuIE8uZ2V0UGFyYW1ldGVyKE8uQ1VSUkVOVF9QUk9HUkFNKX1fZGVjbGFyZVVuaWZvcm0oTyxtLHA9IjFmIil7Y29uc3Qgbj10aGlzLmdsLGE9bi5nZXRVbmlmb3JtTG9jYXRpb24oTyxtKTtsZXQgaTtjb25zdCBvPXRoaXM7aWYoL15zYW1wbGVyLy50ZXN0KHApKXtjb25zdCBUPU8uX3NhbXBsZXJNYXAsUD1PLl9iaW5kVGV4dHVyZXM7T2JqZWN0LmRlZmluZVByb3BlcnR5KE8udW5pZm9ybXMsbSx7Z2V0KCl7cmV0dXJuIGl9LHNldChDKXtpPUM7Y29uc3QgST1UW21dIT1udWxsP1RbbV06UC5sZW5ndGg7UFtJXT1DLGYobixDLEkpLFRbbV18fChUW21dPUksbi51bmlmb3JtMWkoYSxJKSksby5vcHRpb25zLmF1dG9VcGRhdGUmJm8udXBkYXRlKCl9LGNvbmZpZ3VyYWJsZTohMSxlbnVtZXJhYmxlOiEwfSl9ZWxzZXtjb25zdCBUPXAuaW5kZXhPZigiTWF0cml4Iik9PT0wLFA9IVQmJi92JC8udGVzdChwKSxDPW5bYHVuaWZvcm0ke3B9YF0uYmluZChuKTtPYmplY3QuZGVmaW5lUHJvcGVydHkoTy51bmlmb3JtcyxtLHtnZXQoKXtyZXR1cm4gaX0sc2V0KEkpe2k9SSx0eXBlb2YgST09Im51bWJlciImJihJPVtJXSksVD9DKGEsITEsSSk6UD9DKGEsSSk6QyhhLC4uLkkpLG8ub3B0aW9ucy5hdXRvVXBkYXRlJiZvLnVwZGF0ZSgpfSxjb25maWd1cmFibGU6ITEsZW51bWVyYWJsZTohMH0pfX1fZHJhdygpe2NvbnN0IE89dGhpcy5wcm9ncmFtO08ubWVzaERhdGEuZm9yRWFjaCgobSxwKT0+e2NvbnN0e3Bvc2l0aW9uczpuLGNlbGxzOmEsaW5zdGFuY2VDb3VudDppLGNlbGxzQ291bnQ6byxhdHRyaWJ1dGVzOlQsdW5pZm9ybXM6UCx0ZXh0dXJlQ29vcmQ6QyxlbmFibGVCbGVuZDpJfT1tLEE9dGhpcy5nbDtsZXQgTD1tLm1vZGUhPW51bGw/bS5tb2RlOkEuVFJJQU5HTEVTO3R5cGVvZiBMPT0ic3RyaW5nIiYmKEw9QVtMXSksST9BLmVuYWJsZShBLkJMRU5EKTpBLmRpc2FibGUoQS5CTEVORCksQS5iaW5kQnVmZmVyKEEuQVJSQVlfQlVGRkVSLE8uX2J1ZmZlcnMudmVydGljZXNCdWZmZXIpLEEuYnVmZmVyRGF0YShBLkFSUkFZX0JVRkZFUixuLEEuU1RBVElDX0RSQVcpLGEmJihBLmJpbmRCdWZmZXIoQS5FTEVNRU5UX0FSUkFZX0JVRkZFUixPLl9idWZmZXJzLmNlbGxzQnVmZmVyKSxBLmJ1ZmZlckRhdGEoQS5FTEVNRU5UX0FSUkFZX0JVRkZFUixhLEEuU1RBVElDX0RSQVcpKTtjb25zdCBEPVtdO1QmJk9iamVjdC52YWx1ZXMoVCkuZm9yRWFjaCgoe25hbWU6UyxkYXRhOkIsZGl2aXNvcjp3fSk9PntpZihBLmJpbmRCdWZmZXIoQS5BUlJBWV9CVUZGRVIsTy5fYnVmZmVyc1tTXSksQS5idWZmZXJEYXRhKEEuQVJSQVlfQlVGRkVSLEIsQS5TVEFUSUNfRFJBVyksdyE9bnVsbCl7Y29uc3QgSD1BLmdldEF0dHJpYkxvY2F0aW9uKE8sUyk7SD49MCYmKEEuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoSCksRC5wdXNoKEgpLEEudmVydGV4QXR0cmliRGl2aXNvcj9BLnZlcnRleEF0dHJpYkRpdmlzb3IoSCx3KTp0aGlzLmFpYV9leHQmJnRoaXMuYWlhX2V4dC52ZXJ0ZXhBdHRyaWJEaXZpc29yQU5HTEUoSCx3KSl9fSksUCYmT2JqZWN0LmVudHJpZXMoUCkuZm9yRWFjaCgoW1MsQl0pPT57dGhpcy51bmlmb3Jtc1tTXT1CfSk7bGV0IFI7aWYoIWEpe2NvbnN0IFM9Ty5fZGltZW5zaW9uO1I9bi5sZW5ndGgvU31pZihPLl9lbmFibGVUZXh0dXJlcyYmTy5fYnVmZmVycy50ZXhDb29yZEJ1ZmZlcil7Y29uc3QgUz1DfHx1KG4sTy5fZGltZW5zaW9uKTtBLmJpbmRCdWZmZXIoQS5BUlJBWV9CVUZGRVIsTy5fYnVmZmVycy50ZXhDb29yZEJ1ZmZlciksQS5idWZmZXJEYXRhKEEuQVJSQVlfQlVGRkVSLHguRkxPQVQoUyksQS5TVEFUSUNfRFJBVyl9aSE9bnVsbD8oYT9BLmRyYXdFbGVtZW50c0luc3RhbmNlZD9BLmRyYXdFbGVtZW50c0luc3RhbmNlZChMLG8sQS5VTlNJR05FRF9TSE9SVCwwLGkpOnRoaXMuYWlhX2V4dCYmdGhpcy5haWFfZXh0LmRyYXdFbGVtZW50c0luc3RhbmNlZEFOR0xFKEwsbyxBLlVOU0lHTkVEX1NIT1JULDAsaSk6QS5kcmF3QXJyYXlzSW5zdGFuY2VkP0EuZHJhd0FycmF5c0luc3RhbmNlZChMLDAsUixpKTp0aGlzLmFpYV9leHQuZHJhd0FycmF5c0luc3RhbmNlZEFOR0xFKEwsMCxSLGkpLEQuZm9yRWFjaChTPT57QS52ZXJ0ZXhBdHRyaWJEaXZpc29yP0EudmVydGV4QXR0cmliRGl2aXNvcihTLG51bGwpOnRoaXMuYWlhX2V4dCYmdGhpcy5haWFfZXh0LnZlcnRleEF0dHJpYkRpdmlzb3JBTkdMRShTLG51bGwpfSkpOmE/QS5kcmF3RWxlbWVudHMoTCxvLEEuVU5TSUdORURfU0hPUlQsMCk6QS5kcmF3QXJyYXlzKEwsMCxSKX0pfWdldCBpc1dlYkdMMigpe3JldHVybiB0eXBlb2YgV2ViR0wyUmVuZGVyaW5nQ29udGV4dDwidSImJnRoaXMuZ2wgaW5zdGFuY2VvZiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0fWdldCBlbmFibGVUZXh0dXJlcygpe3JldHVybiB0aGlzLnByb2dyYW0mJnRoaXMucHJvZ3JhbS5fZW5hYmxlVGV4dHVyZXN9Z2V0IHVuaWZvcm1zKCl7Y29uc3QgTz10aGlzLnByb2dyYW07aWYoIU98fCFPLnVuaWZvcm1zKXRocm93IEVycm9yKCJObyBhdmFsaWFibGUgcHJvZ3JhbS4iKTtyZXR1cm4gTy51bmlmb3Jtc31kZWxldGVQcm9ncmFtKE8pe2NvbnN0IG09dGhpcy5nbDt0aGlzLnByb2dyYW09PT1PJiYodGhpcy5zdGFydFJlbmRlcj0hMSx0aGlzLl9yZW5kZXJGcmFtZUlEJiYoY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5fcmVuZGVyRnJhbWVJRCksZGVsZXRlIHRoaXMuX3JlbmRlckZyYW1lSUQpLG0udXNlUHJvZ3JhbShudWxsKSk7Y29uc3QgcD10aGlzLnByb2dyYW1zLmluZGV4T2YoTyk7cD49MCYmdGhpcy5wcm9ncmFtcy5zcGxpY2UocCwxKSxNKG0sTyksbS5kZWxldGVQcm9ncmFtKE8pfXNldE1lc2hEYXRhKE8pe0FycmF5LmlzQXJyYXkoTyl8fChPPVtPXSk7Y29uc3QgbT10aGlzLnByb2dyYW07bS5tZXNoRGF0YT1PLm1hcCgoe21vZGU6cCxwb3NpdGlvbnM6bixpbnN0YW5jZUNvdW50OmEsY2VsbHM6aSxjZWxsc0NvdW50Om8sYXR0cmlidXRlczpULHVuaWZvcm1zOlAsdGV4dHVyZUNvb3JkOkMsZW5hYmxlQmxlbmQ6SX0pPT57Y29uc3QgQT17cG9zaXRpb25zOnguRkxPQVQobiksdW5pZm9ybXM6UCxlbmFibGVCbGVuZDohIUksdGV4dHVyZUNvb3JkOnguRkxPQVQoQyl9O2lmKGkmJihBLmNlbGxzPXguVVNIT1JUKGkpLEEuY2VsbHNDb3VudD1vfHxBLmNlbGxzLmxlbmd0aCkscCE9bnVsbCYmKEEubW9kZT1wKSxhIT1udWxsKXtpZighdGhpcy5pc1dlYkdMMiYmIXRoaXMuYWlhX2V4dCl0aHJvdyBuZXcgRXJyb3IoIkNhbm5vdCB1c2UgaW5zdGFuY2VDb3VudCBpbiB0aGlzIHJlbmRlcmluZyBjb250ZXh0LCB1c2Ugd2ViZ2wyIGNvbnRleHQgaW5zdGVhZC4iKTtBLmluc3RhbmNlQ291bnQ9YX1pZihUKXtjb25zdCBMPXt9O09iamVjdC5lbnRyaWVzKFQpLmZvckVhY2goKFtELFJdKT0+e2lmKCFtLl9hdHRyaWJ1dGVbRF0pbS5fYXR0cmlidXRlW0RdPSJpZ25vcmVkIjtlbHNlIGlmKG0uX2F0dHJpYnV0ZVtEXSE9PSJpZ25vcmVkIil7Y29uc3R7bmFtZTpTLHR5cGU6Qn09bS5fYXR0cmlidXRlW0RdO2xldCB3PVIuZGF0YXx8UjtpZihBcnJheS5pc0FycmF5KHcpJiYodz14W0JdKHcpKSxMW0RdPXtuYW1lOlMsZGF0YTp3fSxSLmRpdmlzb3IhPW51bGwpe2lmKCF0aGlzLmlzV2ViR0wyJiYhdGhpcy5haWFfZXh0KXRocm93IG5ldyBFcnJvcigiQ2Fubm90IHVzZSBkaXZpc29yIGluIHRoaXMgcmVuZGVyaW5nIGNvbnRleHQsIHVzZSB3ZWJnbDIgY29udGV4dCBpbnN0ZWFkLiIpO0xbRF0uZGl2aXNvcj1SLmRpdmlzb3J9fX0pLEEuYXR0cmlidXRlcz1MfXJldHVybiBBfSksdGhpcy5vcHRpb25zLmF1dG9VcGRhdGUmJnRoaXMudXBkYXRlKCl9Y3JlYXRlUHJvZ3JhbShPLG0pe2NvbnN0IHA9L15ccyp1bmlmb3JtXHMrc2FtcGxlci9tZy50ZXN0KE8pO089PW51bGwmJihPPWcuZGVmYXVsdCksbT09bnVsbCYmKG09cD92LmRlZmF1bHQ6cy5kZWZhdWx0KTtjb25zdCBuPXRoaXMuZ2wsYT1PYmplY3Qoci5jcmVhdGVQcm9ncmFtKShuLG0sTyk7YS5zaGFkZXJUZXh0PXt2ZXJ0ZXhTaGFkZXI6bSxmcmFnbWVudFNoYWRlcjpPfSxhLl9idWZmZXJzPXt9LGEuX2F0dHJpYnV0ZT17fSxhLnVuaWZvcm1zPXt9LGEuX3NhbXBsZXJNYXA9e30sYS5fYmluZFRleHR1cmVzPVtdO2NvbnN0IGk9bmV3IFJlZ0V4cChgKD86YXR0cmlidXRlfGluKSB2ZWMoXFxkKSAke3RoaXMub3B0aW9ucy52ZXJ0ZXhQb3NpdGlvbn1gLCJpbSIpO2xldCBvPW0ubWF0Y2goaSk7byYmKGEuX2RpbWVuc2lvbj1OdW1iZXIob1sxXSkpO2NvbnN0IFQ9bmV3IFJlZ0V4cChgKD86YXR0cmlidXRlfGluKSB2ZWMoXFxkKSAke3RoaXMub3B0aW9ucy52ZXJ0ZXhUZXh0dXJlQ29vcmR9YCwiaW0iKTtvPW0ubWF0Y2goVCksbyYmKGEuX3RleENvb3JkU2l6ZT1OdW1iZXIob1sxXSkpO2NvbnN0IFA9L15ccyooPzphdHRyaWJ1dGV8aW4pIChcdys/KShcZCopIChcdyspL2dpbTtpZihvPW0ubWF0Y2goUCksbylmb3IobGV0IEE9MDtBPG8ubGVuZ3RoO0ErKyl7Y29uc3QgTD0vXlxzKig/OmF0dHJpYnV0ZXxpbikgKFx3Kz8pKFxkKikgKFx3KykvaW0sRD1vW0FdLm1hdGNoKEwpO2lmKEQmJkRbM10hPT10aGlzLm9wdGlvbnMudmVydGV4UG9zaXRpb24mJkRbM10hPT10aGlzLm9wdGlvbnMudmVydGV4VGV4dHVyZUNvb3JkKXtsZXRbLFIsUyxCXT1EO1I9PT0ibWF0IiYmKFMqKj0yKSxhLl9idWZmZXJzW0JdPW4uY3JlYXRlQnVmZmVyKCksYS5fYXR0cmlidXRlW0JdPXtuYW1lOkIsdHlwZTpSLHNpemU6TnVtYmVyKFMpfHwxfX19Y29uc3QgQz0vXlxzKnVuaWZvcm1ccysoXHcrKVxzKyhcdyspKFxbXGQrXF0pPy9tZztvPW0ubWF0Y2goQyl8fFtdLG89by5jb25jYXQoTy5tYXRjaChDKXx8W10pLG8uZm9yRWFjaChBPT57Y29uc3QgTD1BLm1hdGNoKC9eXHMqdW5pZm9ybVxzKyhcdyspXHMrKFx3KykoXFtcZCtcXSk/Lyk7bGV0W0QsUixTXT1MLnNsaWNlKDEpO0Q9eVtEXSxTPSEhUyxELmluZGV4T2YoIk1hdHJpeCIpIT09MCYmUyYmKEQrPSJ2IiksdGhpcy5fZGVjbGFyZVVuaWZvcm0oYSxSLEQpfSksYS5fYnVmZmVycy52ZXJ0aWNlc0J1ZmZlcj1uLmNyZWF0ZUJ1ZmZlcigpLGEuX2J1ZmZlcnMuY2VsbHNCdWZmZXI9bi5jcmVhdGVCdWZmZXIoKTtjb25zdCBJPW4uZ2V0QXR0cmliTG9jYXRpb24oYSx0aGlzLm9wdGlvbnMudmVydGV4VGV4dHVyZUNvb3JkKTtyZXR1cm4gYS5fZW5hYmxlVGV4dHVyZXM9ST49MCxhLl9lbmFibGVUZXh0dXJlcyYmKGEuX2J1ZmZlcnMudGV4Q29vcmRCdWZmZXI9bi5jcmVhdGVCdWZmZXIoKSksdGhpcy5wcm9ncmFtcy5wdXNoKGEpLGF9dXNlUHJvZ3JhbShPLG09e30pe3RoaXMuc3RhcnRSZW5kZXI9ITEsdGhpcy5fcmVuZGVyRnJhbWVJRCYmKGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuX3JlbmRlckZyYW1lSUQpLGRlbGV0ZSB0aGlzLl9yZW5kZXJGcmFtZUlEKTtjb25zdCBwPXRoaXMuZ2w7cC51c2VQcm9ncmFtKE8pO2NvbnN0IG49Ty5fZGltZW5zaW9uO3AuYmluZEJ1ZmZlcihwLkFSUkFZX0JVRkZFUixPLl9idWZmZXJzLnZlcnRpY2VzQnVmZmVyKTtjb25zdCBhPXAuZ2V0QXR0cmliTG9jYXRpb24oTyx0aGlzLm9wdGlvbnMudmVydGV4UG9zaXRpb24pO2lmKHAudmVydGV4QXR0cmliUG9pbnRlcihhLG4scC5GTE9BVCwhMSwwLDApLHAuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoYSksTy5fZW5hYmxlVGV4dHVyZXMpe3AuYmluZEJ1ZmZlcihwLkFSUkFZX0JVRkZFUixPLl9idWZmZXJzLnRleENvb3JkQnVmZmVyKTtjb25zdCBpPXAuZ2V0QXR0cmliTG9jYXRpb24oTyx0aGlzLm9wdGlvbnMudmVydGV4VGV4dHVyZUNvb3JkKTtwLnZlcnRleEF0dHJpYlBvaW50ZXIoaSxPLl90ZXhDb29yZFNpemV8fDIscC5GTE9BVCwhMSwwLDApLHAuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoaSl9aWYoT2JqZWN0LmVudHJpZXMoTy5fYXR0cmlidXRlKS5mb3JFYWNoKChbaSxvXSk9PntpZihvIT09Imlnbm9yZWQiKXtjb25zdCBUPW8uc2l6ZSxQPW1baV18fHt9LEM9ISFQLm5vcm1hbGl6ZTtsZXQgST1QLnR5cGV8fCJGTE9BVCI7Y29uc3QgQT1QLmtleXx8aTtJPT09IlVCWVRFIiYmKEk9IlVOU0lHTkVEX0JZVEUiKSxJPT09IlVTSE9SVCImJihJPSJVTlNJR05FRF9TSE9SVCIpLG8udHlwZT1JLEEmJkEhPT1pJiYoTy5fYXR0cmlidXRlW0FdPW8pLHAuYmluZEJ1ZmZlcihwLkFSUkFZX0JVRkZFUixPLl9idWZmZXJzW2ldKTtjb25zdCBMPXAuZ2V0QXR0cmliTG9jYXRpb24oTyxpKTtMPj0wJiYocC52ZXJ0ZXhBdHRyaWJQb2ludGVyKEwsVCxwW0ldLEMsMCwwKSxwLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KEwpKX19KSwhTy5tZXNoRGF0YSl7Y29uc3QgaT1bWy0xLC0xLDAsMV0uc2xpY2UoMCxuKSxbMSwtMSwwLDFdLnNsaWNlKDAsbiksWzEsMSwwLDFdLnNsaWNlKDAsbiksWy0xLDEsMCwxXS5zbGljZSgwLG4pXSxvPVtbMCwxLDNdLFszLDEsMl1dO3RoaXMuc2V0TWVzaERhdGEoe3Bvc2l0aW9uczppLGNlbGxzOm99KX1yZXR1cm4gT31jb21waWxlU3luYyhPLG0pe089T3x8Zy5kZWZhdWx0O2NvbnN0IHA9e307ZnVuY3Rpb24gbihUKXtUPVQucmVwbGFjZSgvXlxzKi9tZywiIik7Y29uc3QgUD1bXSxDPVQubWF0Y2goL14jcHJhZ21hXHMraW5jbHVkZVxzKy4qL21nKTtpZihDKXtmb3IobGV0IEk9MDtJPEMubGVuZ3RoO0krKyl7Y29uc3QgTD1DW0ldLm1hdGNoKC8oPzo8fCIpKC4qKSg/Oj58IikvKTtpZihMKXtjb25zdCBEPUxbMF0uaW5kZXhPZigiPCIpPT09MD8ibGliIjoibGluayI7bGV0IFI9TFsxXTtpZihSPT09ImdyYXBoIiYmKFI9ImdyYXBoaWNzIikscFtSXSlQLnB1c2goYC8qIGluY2x1ZGVkICR7Un0gKi9gKTtlbHNlIGlmKHBbUl09ITAsRD09PSJsaWIiKXtjb25zdCBTPW4obFtSXSk7UC5wdXNoKFMpfWVsc2UgaWYoRD09PSJsaW5rIil0aHJvdyBuZXcgRXJyb3IoIkNhbm5vdCBsb2FkIGV4dGVybmFsIGxpbmtzIHN5bmNocm9ub3VzbHkuIFVzZSBjb21waWxlIGluc3RlYWQgb2YgY29tcGlsZVN5bmMuIil9fVAuZm9yRWFjaChJPT57VD1ULnJlcGxhY2UoL14jcHJhZ21hXHMraW5jbHVkZVxzKy4qL20sSSl9KX1yZXR1cm4gVH1jb25zdCBhPW4oTyksaT1tP24obSk6bnVsbDtyZXR1cm4gdGhpcy5jcmVhdGVQcm9ncmFtKGEsaSl9YXN5bmMgY29tcGlsZShPLG0pe089T3x8Zy5kZWZhdWx0O2NvbnN0IHA9e307YXN5bmMgZnVuY3Rpb24gbihUKXtUPVQucmVwbGFjZSgvXlxzKi9tZywiIik7Y29uc3QgUD1bXSxDPVQubWF0Y2goL14jcHJhZ21hXHMraW5jbHVkZVxzKy4qL21nKTtpZihDKXtmb3IobGV0IEk9MDtJPEMubGVuZ3RoO0krKyl7Y29uc3QgTD1DW0ldLm1hdGNoKC8oPzo8fCIpKC4qKSg/Oj58IikvKTtpZihMKXtjb25zdCBEPUxbMF0uaW5kZXhPZigiPCIpPT09MD8ibGliIjoibGluayI7bGV0IFI9TFsxXTtpZihSPT09ImdyYXBoIiYmKFI9ImdyYXBoaWNzIikscFtSXSlQLnB1c2goYC8qIGluY2x1ZGVkICR7Un0gKi9gKTtlbHNlIGlmKHBbUl09ITAsRD09PSJsaWIiKXtjb25zdCBTPWF3YWl0IG4obFtSXSk7UC5wdXNoKFMpfWVsc2UgaWYoRD09PSJsaW5rIil7bGV0IFM9YXdhaXQgeC5mZXRjaFNoYWRlcihSKTtTPWF3YWl0IG4oUyksUC5wdXNoKFMpfX19UC5mb3JFYWNoKEk9PntUPVQucmVwbGFjZSgvXiNwcmFnbWFccytpbmNsdWRlXHMrLiovbSxJKX0pfXJldHVybiBUfWNvbnN0IGE9YXdhaXQgbihPKSxpPW0/YXdhaXQgbihtKTpudWxsO3JldHVybiB0aGlzLmNyZWF0ZVByb2dyYW0oYSxpKX1hc3luYyBsb2FkKE8sbT1udWxsKXtyZXR1cm4gTz1hd2FpdCB4LmZldGNoU2hhZGVyKE8pLG0mJihtPWF3YWl0IHguZmV0Y2hTaGFkZXIobSkpLHRoaXMuY29tcGlsZShPLG0pfWNyZWF0ZVRleHR1cmUoTz1udWxsLHt3cmFwUzptPXRoaXMuZ2wuQ0xBTVBfVE9fRURHRSx3cmFwVDpwPXRoaXMuZ2wuQ0xBTVBfVE9fRURHRSxtaW5GaWx0ZXI6bj10aGlzLmdsLkxJTkVBUixtYWdGaWx0ZXI6YT10aGlzLmdsLkxJTkVBUn09e30pe2NvbnN0IGk9dGhpcy5nbCxvPUFycmF5LmlzQXJyYXkoTyk/aS5URVhUVVJFX0NVQkVfTUFQOmkuVEVYVFVSRV8yRDt0aGlzLl9tYXhfdGV4dHVyZV9pbWFnZV91bml0cz10aGlzLl9tYXhfdGV4dHVyZV9pbWFnZV91bml0c3x8aS5nZXRQYXJhbWV0ZXIoaS5NQVhfQ09NQklORURfVEVYVFVSRV9JTUFHRV9VTklUUyksaS5hY3RpdmVUZXh0dXJlKGkuVEVYVFVSRTArdGhpcy5fbWF4X3RleHR1cmVfaW1hZ2VfdW5pdHMtMSk7Y29uc3QgVD1pLmNyZWF0ZVRleHR1cmUoKTtpLmJpbmRUZXh0dXJlKG8sVCksaS5waXhlbFN0b3JlaShpLlVOUEFDS19GTElQX1lfV0VCR0wsITApO2NvbnN0e3dpZHRoOlAsaGVpZ2h0OkN9PXRoaXMuY2FudmFzO2lmKE8paWYobz09PWkuVEVYVFVSRV9DVUJFX01BUClmb3IobGV0IEk9MDtJPDY7SSsrKWkudGV4SW1hZ2UyRChpLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCtJLDAsaS5SR0JBLGkuUkdCQSxpLlVOU0lHTkVEX0JZVEUsT1tJXSk7ZWxzZSBpLnRleEltYWdlMkQobywwLGkuUkdCQSxpLlJHQkEsaS5VTlNJR05FRF9CWVRFLE8pO2Vsc2UgaWYobz09PWkuVEVYVFVSRV9DVUJFX01BUClmb3IobGV0IEk9MDtJPDY7SSsrKXRoaXMuZ2wudGV4SW1hZ2UyRCh0aGlzLmdsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCtJLDAsaS5SR0JBLFAsQywwLGkuUkdCQSxpLlVOU0lHTkVEX0JZVEUsbnVsbCk7ZWxzZSBpLnRleEltYWdlMkQobywwLGkuUkdCQSxQLEMsMCxpLlJHQkEsaS5VTlNJR05FRF9CWVRFLG51bGwpO3JldHVybiBpLnRleFBhcmFtZXRlcmkobyxpLlRFWFRVUkVfTUlOX0ZJTFRFUixuKSxpLnRleFBhcmFtZXRlcmkobyxpLlRFWFRVUkVfTUFHX0ZJTFRFUixhKSxpLnRleFBhcmFtZXRlcmkobyxpLlRFWFRVUkVfV1JBUF9TLG0pLGkudGV4UGFyYW1ldGVyaShvLGkuVEVYVFVSRV9XUkFQX1QscCksbz09PWkuVEVYVFVSRV9DVUJFX01BUCYmKE8ud2lkdGg9T1swXS53aWR0aCxPLmhlaWdodD1PWzBdLmhlaWdodCksaS5iaW5kVGV4dHVyZShvLG51bGwpLFQuX2ltZz1PfHx7d2lkdGg6UCxoZWlnaHQ6Q30sVC5kZWxldGU9KCk9Pnt0aGlzLmRlbGV0ZVRleHR1cmUoVCl9LFR9ZGVsZXRlVGV4dHVyZShPKXtjb25zdCBtPU8uX2ltZzt0aGlzLmdsLmRlbGV0ZVRleHR1cmUoTyksdHlwZW9mIG0uY2xvc2U9PSJmdW5jdGlvbiImJm0uY2xvc2UoKX1hc3luYyBsb2FkVGV4dHVyZShPLHt1c2VJbWFnZUJpdG1hcDptPSEwfT17fSl7Y29uc3QgcD1hd2FpdCB4LmxvYWRJbWFnZShPLHt1c2VJbWFnZUJpdG1hcDptfSk7cmV0dXJuIHRoaXMuY3JlYXRlVGV4dHVyZShwKX1jcmVhdGVGQk8oe2NvbG9yOk89MSxibGVuZDptPSExLGRlcHRoOnA9dGhpcy5vcHRpb25zLmRlcHRoIT09ITEsc3RlbmNpbDpuPSEhdGhpcy5vcHRpb25zLnN0ZW5jaWx9PXt9KXtjb25zdCBhPXRoaXMuZ2wsaT1hLmNyZWF0ZUZyYW1lYnVmZmVyKCk7YS5iaW5kRnJhbWVidWZmZXIoYS5GUkFNRUJVRkZFUixpKTtjb25zdCBvPVtdO2ZvcihsZXQgQz0wO0M8TztDKyspe2NvbnN0IEk9dGhpcy5jcmVhdGVUZXh0dXJlKCk7YS5mcmFtZWJ1ZmZlclRleHR1cmUyRChhLkZSQU1FQlVGRkVSLGEuQ09MT1JfQVRUQUNITUVOVDArQyxhLlRFWFRVUkVfMkQsSSwwKSxvLnB1c2goSSl9aS50ZXh0dXJlcz1vLGkudGV4dHVyZT1vWzBdLGkuYmxlbmQ9bTtjb25zdHt3aWR0aDpULGhlaWdodDpQfT10aGlzLmNhbnZhcztyZXR1cm4gcCYmIW4mJihpLmRlcHRoQnVmZmVyPWEuY3JlYXRlUmVuZGVyYnVmZmVyKCksYS5iaW5kUmVuZGVyYnVmZmVyKGEuUkVOREVSQlVGRkVSLGkuZGVwdGhCdWZmZXIpLGEucmVuZGVyYnVmZmVyU3RvcmFnZShhLlJFTkRFUkJVRkZFUixhLkRFUFRIX0NPTVBPTkVOVDE2LFQsUCksYS5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlcihhLkZSQU1FQlVGRkVSLGEuREVQVEhfQVRUQUNITUVOVCxhLlJFTkRFUkJVRkZFUixpLmRlcHRoQnVmZmVyKSksbiYmIXAmJihpLnN0ZW5jaWxCdWZmZXI9YS5jcmVhdGVSZW5kZXJidWZmZXIoKSxhLmJpbmRSZW5kZXJidWZmZXIoYS5SRU5ERVJCVUZGRVIsaS5zdGVuY2lsQnVmZmVyKSxhLnJlbmRlcmJ1ZmZlclN0b3JhZ2UoYS5SRU5ERVJCVUZGRVIsYS5TVEVOQ0lMX0lOREVYOCxULFApLGEuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoYS5GUkFNRUJVRkZFUixhLlNURU5DSUxfQVRUQUNITUVOVCxhLlJFTkRFUkJVRkZFUixpLnN0ZW5jaWxCdWZmZXIpKSxwJiZuJiYoaS5kZXB0aFN0ZW5jaWxCdWZmZXI9YS5jcmVhdGVSZW5kZXJidWZmZXIoKSxhLmJpbmRSZW5kZXJidWZmZXIoYS5SRU5ERVJCVUZGRVIsaS5kZXB0aFN0ZW5jaWxCdWZmZXIpLGEucmVuZGVyYnVmZmVyU3RvcmFnZShhLlJFTkRFUkJVRkZFUixhLkRFUFRIX1NURU5DSUwsVCxQKSxhLmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKGEuRlJBTUVCVUZGRVIsYS5ERVBUSF9TVEVOQ0lMX0FUVEFDSE1FTlQsYS5SRU5ERVJCVUZGRVIsaS5kZXB0aFN0ZW5jaWxCdWZmZXIpKSxhLmJpbmRGcmFtZWJ1ZmZlcihhLkZSQU1FQlVGRkVSLG51bGwpLGl9YmluZEZCTyhPPW51bGwpe3RoaXMuZmJvPU99cmVuZGVyKHtjbGVhckJ1ZmZlcjpPPSEwfT17fSl7dGhpcy5zdGFydFJlbmRlcj0hMDtjb25zdCBtPXRoaXMuZ2w7bGV0IHA9dGhpcy5wcm9ncmFtO3B8fChwPXRoaXMuY3JlYXRlUHJvZ3JhbSgpLHRoaXMudXNlUHJvZ3JhbShwKSksdGhpcy5mYm8mJm0uYmluZEZyYW1lYnVmZmVyKG0uRlJBTUVCVUZGRVIsdGhpcy5mYm8pO2NvbnN0IG49dGhpcy5vcHRpb25zLmRlcHRoO24mJm0uZW5hYmxlKG0uREVQVEhfVEVTVCksdGhpcy5nbC5jbGVhcih0aGlzLmdsLkNPTE9SX0JVRkZFUl9CSVR8KG4/dGhpcy5nbC5ERVBUSF9CVUZGRVJfQklUOjApfCh0aGlzLm9wdGlvbnMuc3RlbmNpbD90aGlzLmdsLlNURU5DSUxfQlVGRkVSX0JJVDowKSk7Y29uc3QgYT10aGlzLl9yZW5kZXJGcmFtZUlEO3RoaXMuX2RyYXcoKSx0aGlzLmZibyYmbS5iaW5kRnJhbWVidWZmZXIobS5GUkFNRUJVRkZFUixudWxsKSx0aGlzLl9yZW5kZXJGcmFtZUlEPT09YSYmKHRoaXMuX3JlbmRlckZyYW1lSUQ9bnVsbCl9dXBkYXRlKCl7dGhpcy5zdGFydFJlbmRlciYmdGhpcy5fcmVuZGVyRnJhbWVJRD09bnVsbCYmKHRoaXMuX3JlbmRlckZyYW1lSUQ9cmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMucmVuZGVyLmJpbmQodGhpcykpKX19aCh4LCJkZWZhdWx0T3B0aW9ucyIse3ByZXNlcnZlRHJhd2luZ0J1ZmZlcjohMCxhdXRvVXBkYXRlOiEwLHZlcnRleFBvc2l0aW9uOiJhX3ZlcnRleFBvc2l0aW9uIix2ZXJ0ZXhUZXh0dXJlQ29vcmQ6ImFfdmVydGV4VGV4dHVyZUNvb3JkIix3ZWJnbDI6ITF9KSxoKHgsIlVCWVRFIix4LlVOU0lHTkVEX0JZVEUpLGgoeCwiVVNIT1JUIix4LlVOU0lHTkVEX1NIT1JUKSxoKHgsImZldGNoU2hhZGVyIixyLmZldGNoU2hhZGVyKSxoKHgsImxvYWRJbWFnZSIsci5sb2FkSW1hZ2UpfSxmdW5jdGlvbihjLGUsdCl7dC5yKGUpLHQuZChlLCJzZXR1cFdlYkdMIixmdW5jdGlvbigpe3JldHVybiBzfSksdC5kKGUsImNyZWF0ZVByb2dyYW0iLGZ1bmN0aW9uKCl7cmV0dXJuIGd9KSx0LmQoZSwicG9pbnRzVG9CdWZmZXIiLGZ1bmN0aW9uKCl7cmV0dXJuIHZ9KSx0LmQoZSwibG9hZEltYWdlIixmdW5jdGlvbigpe3JldHVybiBsfSksdC5kKGUsImZldGNoU2hhZGVyIixmdW5jdGlvbigpe3JldHVybiBNfSksdCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIHIoZix5KXtjb25zdCB4PVsid2ViZ2wiLCJleHBlcmltZW50YWwtd2ViZ2wiLCJ3ZWJraXQtM2QiLCJtb3otd2ViZ2wiXTtsZXQgYj1udWxsO2ZvcihsZXQgTz0wO088eC5sZW5ndGg7KytPKXt0cnl7Yj1mLmdldENvbnRleHQoeFtPXSx5KX1jYXRjaHt9aWYoYilicmVha31yZXR1cm4gYn1mdW5jdGlvbiBzKGYseSl7Y29uc3QgeD1yKGYseSk7aWYoIXgpdGhyb3cgbmV3IEVycm9yKCJTb3JyeSwgeW91ciBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCBXZWJHTC4iKTtyZXR1cm4geH1mdW5jdGlvbiBnKGYseSx4KXtjb25zdCBiPWYuY3JlYXRlU2hhZGVyKGYuVkVSVEVYX1NIQURFUik7aWYoZi5zaGFkZXJTb3VyY2UoYix5KSxmLmNvbXBpbGVTaGFkZXIoYiksIWYuZ2V0U2hhZGVyUGFyYW1ldGVyKGIsZi5DT01QSUxFX1NUQVRVUykpe2NvbnN0IHA9YFZlcnRleCBzaGFkZXIgZmFpbGVkIHRvIGNvbXBpbGUuICBUaGUgZXJyb3IgbG9nIGlzOiR7Zi5nZXRTaGFkZXJJbmZvTG9nKGIpfWA7dGhyb3cgbmV3IEVycm9yKHApfWNvbnN0IE89Zi5jcmVhdGVTaGFkZXIoZi5GUkFHTUVOVF9TSEFERVIpO2lmKGYuc2hhZGVyU291cmNlKE8seCksZi5jb21waWxlU2hhZGVyKE8pLCFmLmdldFNoYWRlclBhcmFtZXRlcihPLGYuQ09NUElMRV9TVEFUVVMpKXtjb25zdCBwPWBGcmFnbWVudCBzaGFkZXIgZmFpbGVkIHRvIGNvbXBpbGUuICBUaGUgZXJyb3IgbG9nIGlzOiR7Zi5nZXRTaGFkZXJJbmZvTG9nKE8pfWA7dGhyb3cgbmV3IEVycm9yKHApfWNvbnN0IG09Zi5jcmVhdGVQcm9ncmFtKCk7aWYoZi5hdHRhY2hTaGFkZXIobSxiKSxmLmF0dGFjaFNoYWRlcihtLE8pLGYubGlua1Byb2dyYW0obSksIWYuZ2V0UHJvZ3JhbVBhcmFtZXRlcihtLGYuTElOS19TVEFUVVMpKXtjb25zdCBwPWBTaGFkZXIgcHJvZ3JhbSBmYWlsZWQgdG8gbGluay4gIFRoZSBlcnJvciBsb2cgaXM6JHtmLmdldFByb2dyYW1JbmZvTG9nKG0pfWA7dGhyb3cgbmV3IEVycm9yKHApfXJldHVybiBmLmRlbGV0ZVNoYWRlcihiKSxmLmRlbGV0ZVNoYWRlcihPKSxtfWZ1bmN0aW9uIHYoZix5PUZsb2F0MzJBcnJheSx4PW51bGwpe2lmKHgmJiEoeCBpbnN0YW5jZW9mIHkpKXRocm93IG5ldyBUeXBlRXJyb3IoIldyb25nIGJ1ZmZlciB0eXBlLiIpO2lmKGY9PW51bGx8fGYgaW5zdGFuY2VvZiB5KXJldHVybiBmO2lmKGZbMF09PW51bGx8fGZbMF0ubGVuZ3RoPT1udWxsKXJldHVybiB4Pyh4LnNldChmLDApLHgpOm5ldyB5KGYpO2NvbnN0IGI9ZlswXS5sZW5ndGgsTz1mLmxlbmd0aDt4fHwoeD1uZXcgeShiKk8pKTtsZXQgbT0wO2ZvcihsZXQgcD0wO3A8TztwKyspZm9yKGxldCBuPTA7bjxiO24rKyl4W20rK109ZltwXVtuXTtyZXR1cm4geH1jb25zdCBoPXt9O2Z1bmN0aW9uIGwoZix7dXNlSW1hZ2VCaXRtYXA6eT0hMCxhbGlhczp4PW51bGx9PXt9KXtpZighaFtmXSl7aWYodHlwZW9mIEltYWdlPT0iZnVuY3Rpb24iKXtjb25zdCBiPW5ldyBJbWFnZTt0eXBlb2YgZj09InN0cmluZyImJiEodHlwZW9mIGxvY2F0aW9uPT0ib2JqZWN0IiYmL15maWxlOi8udGVzdChsb2NhdGlvbi5ocmVmKSkmJiEvXmRhdGE6Ly50ZXN0KGYpJiYoYi5jcm9zc09yaWdpbj0iYW5vbnltb3VzIiksaFtmXT1uZXcgUHJvbWlzZShPPT57Yi5vbmxvYWQ9ZnVuY3Rpb24oKXt5JiZ0eXBlb2YgY3JlYXRlSW1hZ2VCaXRtYXA9PSJmdW5jdGlvbiI/Y3JlYXRlSW1hZ2VCaXRtYXAoYix7aW1hZ2VPcmllbnRhdGlvbjoiZmxpcFkifSkudGhlbihtPT57aFtmXT1tLHgmJihoW3hdPW0pLE8obSl9KTooaFtmXT1iLHgmJihoW3hdPWIpLE8oYikpfSxiLnNyYz1mfSkseCYmKGhbeF09aFtmXSl9ZWxzZSBpZih0eXBlb2YgZmV0Y2g9PSJmdW5jdGlvbiIpcmV0dXJuIGZldGNoKGYse21ldGhvZDoiR0VUIixtb2RlOiJjb3JzIixjYWNoZToiZGVmYXVsdCJ9KS50aGVuKGI9PmIuYmxvYigpKS50aGVuKGI9PmNyZWF0ZUltYWdlQml0bWFwKGIse2ltYWdlT3JpZW50YXRpb246ImZsaXBZIn0pLnRoZW4oTz0+KGhbZl09Tyx4JiYoaFt4XT1PKSxPKSkpfXJldHVybiBoW2ZdfWNvbnN0IHU9e307YXN5bmMgZnVuY3Rpb24gTShmKXtpZih1W2ZdKXJldHVybiB1W2ZdO2NvbnN0IHk9YXdhaXQgZmV0Y2goZik7aWYoeS5zdGF0dXM+PTIwMCYmeS5zdGF0dXM8MzAwKXtjb25zdCB4PWF3YWl0IHkudGV4dCgpO3JldHVybiB1W2ZdPXgseH10aHJvdyBuZXcgRXJyb3IoIlNoYWRlciBsb2FkZWQgZXJyb3IuIil9fSxmdW5jdGlvbihjLGUsdCl7dC5yKGUpLGUuZGVmYXVsdD1gYXR0cmlidXRlIHZlYzMgYV92ZXJ0ZXhQb3NpdGlvbjsKCnZvaWQgbWFpbigpIHsKICBnbF9Qb2ludFNpemUgPSAxLjA7CiAgZ2xfUG9zaXRpb24gPSB2ZWM0KGFfdmVydGV4UG9zaXRpb24sIDEpOwp9YH0sZnVuY3Rpb24oYyxlLHQpe3QucihlKSxlLmRlZmF1bHQ9YCNpZmRlZiBHTF9FUwpwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDsKI2VuZGlmCgp2b2lkIG1haW4oKSB7CiAgZ2xfRnJhZ0NvbG9yID0gdmVjNCgwLjAsIDAuMCwgMC4wLCAwLjEpOwp9YH0sZnVuY3Rpb24oYyxlLHQpe3QucihlKSxlLmRlZmF1bHQ9YGF0dHJpYnV0ZSB2ZWM0IGFfdmVydGV4UG9zaXRpb247CmF0dHJpYnV0ZSB2ZWMyIGFfdmVydGV4VGV4dHVyZUNvb3JkOwp2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDsKCnZvaWQgbWFpbigpIHsKICBnbF9Qb2ludFNpemUgPSAxLjA7CiAgZ2xfUG9zaXRpb24gPSBhX3ZlcnRleFBvc2l0aW9uOwogIHZUZXh0dXJlQ29vcmQgPSBhX3ZlcnRleFRleHR1cmVDb29yZDsKfWB9LGZ1bmN0aW9uKGMsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIHZ9KTt2YXIgcj10KDIxKSxzPXQoMjUpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCBnPVN5bWJvbCgidHJhbnNmb3JtIik7Y2xhc3Mgdntjb25zdHJ1Y3RvcihsLHUpe3RoaXMuY29udGV4dD1sLmdldENvbnRleHQoIjJkIiksdGhpcy5vcHRpb25zPXUsdGhpc1tnXT1bMSwwLDAsMSwwLDBdfWNyZWF0ZVRleHR1cmUobCl7cmV0dXJue19pbWc6bH19YXN5bmMgbG9hZFRleHR1cmUobCl7Y29uc3QgdT1hd2FpdCByLmRlZmF1bHQubG9hZEltYWdlKGwse3VzZUltYWdlQml0bWFwOiExfSk7cmV0dXJuIHRoaXMuY3JlYXRlVGV4dHVyZSh1KX1kZWxldGVUZXh0dXJlKGwpe3JldHVybiBsfWNsZWFyKGwsdSxNLGYpe2NvbnN0IHk9dGhpcy5jb250ZXh0O2w9bHx8MCx1PXV8fDAsTT1NfHx5LmNhbnZhcy53aWR0aC1sLGY9Znx8eS5jYW52YXMuaGVpZ2h0LXUseS5jbGVhclJlY3QobCx1LE0sZil9ZHJhd01lc2hDbG91ZChsLHtjbGVhcjp1PSExfT17fSl7Y29uc3QgTT1bXTtmb3IobGV0IGY9MDtmPGwuYW1vdW50O2YrKyl7Y29uc3QgeT1sLmdldFRyYW5zZm9ybShmKTtsZXQgeD1sLmdldFRleHR1cmVGcmFtZShmKTt4JiYoeD14Ll9pbWcpO2NvbnN0IGI9bC5nZXRGaWx0ZXIoZikse2ZpbGw6TyxzdHJva2U6bX09bC5nZXRDbG91ZFJHQkEoZik7TS5wdXNoKHttZXNoOmwubWVzaCxfY2xvdWRPcHRpb25zOltPLG0seCx5LGJdfSl9bC5iZWZvcmVSZW5kZXImJmwuYmVmb3JlUmVuZGVyKHRoaXMuY29udGV4dCxsKSx0aGlzLmRyYXdNZXNoZXMoTSx7Y2xlYXI6dSxob29rOiExfSksbC5hZnRlclJlbmRlciYmbC5hZnRlclJlbmRlcih0aGlzLmNvbnRleHQsbCl9ZHJhd01lc2hlcyhsLHtjbGVhcjp1PSExLGhvb2s6TT0hMH09e30pe2NvbnN0IGY9dGhpcy5jb250ZXh0O3UmJmYuY2xlYXJSZWN0KDAsMCxmLmNhbnZhcy53aWR0aCxmLmNhbnZhcy5oZWlnaHQpO2xldCB5PW51bGw7Y29uc3R7d2lkdGg6eCxoZWlnaHQ6Yn09Zi5jYW52YXMsTz1sLmxlbmd0aDtsLmZvckVhY2goKG0scCk9PntsZXQgbixhLGksbyxUO00mJm0uYmVmb3JlUmVuZGVyJiZtLmJlZm9yZVJlbmRlcihmLG0pLG0uX2Nsb3VkT3B0aW9ucyYmKFtuLGEsaSxvLFRdPW0uX2Nsb3VkT3B0aW9ucyxtPW0ubWVzaCk7bGV0IFA9bS5maWx0ZXI7aWYoVCYmKFA9UD9gJHtQfSAke1R9YDpUKSxQJiYhdGhpcy5maWx0ZXJCdWZmZXImJnRoaXMuZmlsdGVyQnVmZmVyIT09ITEpe2NvbnN0IEM9ci5kZWZhdWx0LmNyZWF0ZUNhbnZhcyh4LGIpO0M/dGhpcy5maWx0ZXJCdWZmZXI9Qy5nZXRDb250ZXh0KCIyZCIpOnRoaXMuZmlsdGVyQnVmZmVyPSExfXkmJnkhPT1QJiYoT2JqZWN0KHMuYXBwbHlGaWx0ZXIpKHRoaXMuZmlsdGVyQnVmZmVyLHkpLGYuZHJhd0ltYWdlKHRoaXMuZmlsdGVyQnVmZmVyLmNhbnZhcywwLDAseCxiKSx0aGlzLmZpbHRlckJ1ZmZlci5jbGVhclJlY3QoMCwwLHgsYikseT1udWxsKSxQJiZ0aGlzLmZpbHRlckJ1ZmZlcj8odGhpcy5maWx0ZXJCdWZmZXIuc2F2ZSgpLHRoaXMuZmlsdGVyQnVmZmVyLnRyYW5zZm9ybSguLi50aGlzW2ddKSxPYmplY3Qocy5kcmF3TWVzaDJEKShtLHRoaXMuZmlsdGVyQnVmZmVyLCExLG4sYSxpLG8pLHRoaXMuZmlsdGVyQnVmZmVyLnJlc3RvcmUoKSxwPT09Ty0xPyhPYmplY3Qocy5hcHBseUZpbHRlcikodGhpcy5maWx0ZXJCdWZmZXIsUCksZi5kcmF3SW1hZ2UodGhpcy5maWx0ZXJCdWZmZXIuY2FudmFzLDAsMCx4LGIpLHRoaXMuZmlsdGVyQnVmZmVyLmNsZWFyUmVjdCgwLDAseCxiKSk6eT1QKTooZi5zYXZlKCksZi50cmFuc2Zvcm0oLi4udGhpc1tnXSksT2JqZWN0KHMuZHJhd01lc2gyRCkobSxmLCExLG4sYSxpLG8pLGYucmVzdG9yZSgpKSxNJiZtLmFmdGVyUmVuZGVyJiZtLmFmdGVyUmVuZGVyKGYsbSl9KX1zZXRUcmFuc2Zvcm0obCl7dGhpc1tnXT1sfX19LGZ1bmN0aW9uKGMsZSx0KXt0LnIoZSksKGZ1bmN0aW9uKHIpe3ZhciBzPXQoMTQpLGc9dCgyMyksdj10KDI0KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3QgaD17fTtmdW5jdGlvbiBsKHgsYil7Y29uc3R7c3R5bGU6Tyx2YXJpYW50Om0sd2VpZ2h0OnAsc3RyZXRjaDpuLHNpemU6YSxweExpbmVIZWlnaHQ6aSxmYW1pbHk6b309eDtyZXR1cm4gbj09PSJub3JtYWwiP2Ake099ICR7bX0gJHtwfSAke2EqYn1weC8ke2kqYn1weCAke299YDpgJHtPfSAke219ICR7cH0gJHtufSAke2EqYn1weC8ke2kqYn1weCAke299YH1mdW5jdGlvbiB1KHgse2ZvbnQ6YixmaWxsQ29sb3I6TyxzdHJva2VDb2xvcjptLHN0cm9rZVdpZHRoOnAscmF0aW86bj0xLHRleHRDYW52YXM6YSxjYWNoYWJsZTppPSExfSl7bGV0IG87aWYoaSl7bz1beCxiLFN0cmluZyhPKSxTdHJpbmcobSksU3RyaW5nKHApXS5qb2luKCIjIyMiKTtjb25zdCB3PWhbb107aWYodylyZXR1cm4gd31hfHwoYT1mKDEsMSkpO2NvbnN0IFQ9YS5nZXRDb250ZXh0KCIyZCIpO1Quc2F2ZSgpLFQuZm9udD1iO2xldHt3aWR0aDpQfT1ULm1lYXN1cmVUZXh0KHgpO1QucmVzdG9yZSgpO2NvbnN0IEM9T2JqZWN0KGcuZGVmYXVsdCkoYiksST1NYXRoLm1heChDLnB4TGluZUhlaWdodCxDLnB4SGVpZ2h0KjEuMTMpOy9pdGFsaWN8b2JsaXF1ZS8udGVzdChiKSYmKFArPUkqTWF0aC50YW4oMTUqTWF0aC5QSS8xODApKSwhTyYmIW0mJihPPSIjMDAwIik7Y29uc3QgQT1ULmNhbnZhcyxMPU1hdGguY2VpbChQKSxEPU1hdGguY2VpbChJKTtBLndpZHRoPU1hdGgucm91bmQoTCpuKSxBLmhlaWdodD1NYXRoLnJvdW5kKEQqbiksVC5zYXZlKCksVC5mb250PWwoQyxuKSxULnRleHRBbGlnbj0iY2VudGVyIixULnRleHRCYXNlbGluZT0ibWlkZGxlIjtjb25zdCBSPUEuaGVpZ2h0Ki41K0MucHhIZWlnaHQqLjA1Km4sUz1BLndpZHRoKi41O2lmKE8pe2lmKEFycmF5LmlzQXJyYXkoTykpTz1PYmplY3Qodi5kZWZhdWx0KShPKTtlbHNlIGlmKE8udmVjdG9yKXtsZXQgdztjb25zdHt2ZWN0b3I6SCxjb2xvcnM6Sn09TztILmxlbmd0aD09PTY/dz1ULmNyZWF0ZVJhZGlhbEdyYWRpZW50KC4uLkgpOnc9VC5jcmVhdGVMaW5lYXJHcmFkaWVudCguLi5IKSxKLmZvckVhY2goKHtvZmZzZXQ6cSxjb2xvcjpXfSk9Pnt3LmFkZENvbG9yU3RvcChxLFcpfSksTz13fVQuZmlsbFN0eWxlPU8sVC5maWxsVGV4dCh4LFMsUil9aWYobSl7aWYoVC5saW5lV2lkdGg9cCpuLEFycmF5LmlzQXJyYXkobSkpbT1PYmplY3Qodi5kZWZhdWx0KShtKTtlbHNlIGlmKG0udmVjdG9yKXtsZXQgdztjb25zdHt2ZWN0b3I6SCxjb2xvcnM6Sn09bTtILmxlbmd0aD09PTY/dz1ULmNyZWF0ZVJhZGlhbEdyYWRpZW50KC4uLkgpOnc9VC5jcmVhdGVMaW5lYXJHcmFkaWVudCguLi5IKSxKLmZvckVhY2goKHtvZmZzZXQ6cSxjb2xvcjpXfSk9Pnt3LmFkZENvbG9yU3RvcChxLFcpfSksbT13fVQuc3Ryb2tlU3R5bGU9bSxULnN0cm9rZVRleHQoeCxTLFIpfVQucmVzdG9yZSgpO2NvbnN0IEI9e2ltYWdlOmEscmVjdDpbMCwwLEwsRF19O3JldHVybiBpJiYoaFtvXT1CKSxCfWxldCBNPSExO2lmKHR5cGVvZiBuYXZpZ2F0b3I9PSJvYmplY3QiJiZ0eXBlb2YgbmF2aWdhdG9yLnVzZXJBZ2VudD09InN0cmluZyIpe2NvbnN0IHg9bmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9jaHJvbWVcLyhcZCspLyk7eCYmKE09TnVtYmVyKHhbMV0pPDcwKX1mdW5jdGlvbiBmKHgsYixPPXt9KXtjb25zdCBtPU8ub2Zmc2NyZWVufHwhTSYmTy5vZmZzY3JlZW4hPT0hMTtsZXQgcDtyZXR1cm4gdHlwZW9mIHI8InUiJiZ0eXBlb2Ygci5jcmVhdGVDYW52YXM9PSJmdW5jdGlvbiI/cD1yLmNyZWF0ZUNhbnZhcyh4LGIsTyk6bSYmdHlwZW9mIE9mZnNjcmVlbkNhbnZhcz09ImZ1bmN0aW9uIj9wPW5ldyBPZmZzY3JlZW5DYW52YXMoeCxiKToocD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJjYW52YXMiKSxwLndpZHRoPXgscC5oZWlnaHQ9YikscH1jb25zdCB5PXtjcmVhdGVDYW52YXM6ZixjcmVhdGVUZXh0OnUsbG9hZEltYWdlOnMuZGVmYXVsdC5sb2FkSW1hZ2V9O2UuZGVmYXVsdD15fSkuY2FsbCh0aGlzLHQoMjIpKX0sZnVuY3Rpb24oYyxlKXt2YXIgdDt0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9KCk7dHJ5e3Q9dHx8bmV3IEZ1bmN0aW9uKCJyZXR1cm4gdGhpcyIpKCl9Y2F0Y2h7dHlwZW9mIHdpbmRvdz09Im9iamVjdCImJih0PXdpbmRvdyl9Yy5leHBvcnRzPXR9LGZ1bmN0aW9uKGMsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIE99KSx0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gcihtLHApe2lmKHR5cGVvZiBtPT0ic3RyaW5nIil7Y29uc3QgaT1tLnRyaW0oKS5tYXRjaCgvXihbXGQuXSspKHB4fHB0fHBjfGlufGNtfG1tfGVtfGV4fHJlbXxxfHZ3fHZofHZtYXh8dm1pbnwlKSQvKTtpP209e3NpemU6cGFyc2VGbG9hdChpWzFdKSx1bml0OmlbMl19Om09e3NpemU6cGFyc2VJbnQobSwxMCksdW5pdDoicHgifX1sZXR7c2l6ZTpuLHVuaXQ6YX09bTtpZihhPT09InB0IiluLz0uNzU7ZWxzZSBpZihhPT09InBjIiluKj0xNjtlbHNlIGlmKGE9PT0iaW4iKW4qPTk2O2Vsc2UgaWYoYT09PSJjbSIpbio9OTYvMi41NDtlbHNlIGlmKGE9PT0ibW0iKW4qPTk2LzI1LjQ7ZWxzZSBpZihhPT09ImVtInx8YT09PSJyZW0ifHxhPT09ImV4Iil7aWYoIXAmJnR5cGVvZiBnZXRDb21wdXRlZFN0eWxlPT0iZnVuY3Rpb24iJiZ0eXBlb2YgZG9jdW1lbnQ8InUiKXtjb25zdCBpPWdldENvbXB1dGVkU3R5bGUoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KS5mb250U2l6ZTtwPXIoaSwxNil9bio9cCxhPT09ImV4IiYmKG4vPTIpfWVsc2UgaWYoYT09PSJxIiluKj05Ni8yNS40LzQ7ZWxzZSBpZihhPT09InZ3Inx8YT09PSJ2aCIpe2lmKHR5cGVvZiBkb2N1bWVudDwidSIpe2NvbnN0IGk9YT09PSJ2dyI/ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoOmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQ7bio9aS8xMDB9fWVsc2UgaWYoKGE9PT0idm1heCJ8fGE9PT0idm1pbiIpJiZ0eXBlb2YgZG9jdW1lbnQ8InUiKXtjb25zdCBpPWRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCxvPWRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQ7YT09PSJ2bWF4Ij9uKj1NYXRoLm1heChpLG8pLzEwMDpuKj1NYXRoLm1pbihpLG8pLzEwMH1yZXR1cm4gbn1jb25zdCBzPSJib2xkfGJvbGRlcnxsaWdodGVyfFsxLTldMDAiLGc9Iml0YWxpY3xvYmxpcXVlIix2PSJzbWFsbC1jYXBzIixoPSJ1bHRyYS1jb25kZW5zZWR8ZXh0cmEtY29uZGVuc2VkfGNvbmRlbnNlZHxzZW1pLWNvbmRlbnNlZHxzZW1pLWV4cGFuZGVkfGV4cGFuZGVkfGV4dHJhLWV4cGFuZGVkfHVsdHJhLWV4cGFuZGVkIixsPSJweHxwdHxwY3xpbnxjbXxtbXxlbXxleHxyZW18cXx2d3x2aHx2bWF4fHZtaW58JSIsdT1gJyhbXiddKyknfCIoW14iXSspInwoW1xcdy1dfFvkuIAt6b6lXSkrYCxNPW5ldyBSZWdFeHAoYCgke3N9KSArYCwiaSIpLGY9bmV3IFJlZ0V4cChgKCR7Z30pICtgLCJpIikseT1uZXcgUmVnRXhwKGAoJHt2fSkgK2AsImkiKSx4PW5ldyBSZWdFeHAoYCgke2h9KSArYCwiaSIpLGI9bmV3IFJlZ0V4cCgiKFtcXGRcXC5dKykoIitsKyIpKD86XFwvKFtcXGRcXC5dKykoIitsKyIpKT8gKigoPzoiK3UrIikoICosICooPzoiK3UrIikpKikiKTtmdW5jdGlvbiBPKG0scCl7Y29uc3Qgbj1iLmV4ZWMobSk7aWYoIW4pcmV0dXJuO2NvbnN0IGE9cGFyc2VGbG9hdChuWzNdKSxpPXt3ZWlnaHQ6Im5vcm1hbCIsc3R5bGU6Im5vcm1hbCIsc3RyZXRjaDoibm9ybWFsIix2YXJpYW50OiJub3JtYWwiLHNpemU6cGFyc2VGbG9hdChuWzFdKSx1bml0Om5bMl0sbGluZUhlaWdodDpOdW1iZXIuaXNGaW5pdGUoYSk/YTp2b2lkIDAsbGluZUhlaWdodFVuaXQ6bls0XSxmYW1pbHk6bls1XS5yZXBsYWNlKC8gKiwgKi9nLCIsIil9LG89bS5zdWJzdHJpbmcoMCxuLmluZGV4KSxUPU0uZXhlYyhvKSxQPWYuZXhlYyhvKSxDPXkuZXhlYyhvKSxJPXguZXhlYyhvKTtyZXR1cm4gVCYmKGkud2VpZ2h0PVRbMV0pLFAmJihpLnN0eWxlPVBbMV0pLEMmJihpLnZhcmlhbnQ9Q1sxXSksSSYmKGkuc3RyZXRjaD1JWzFdKSxpLnB4SGVpZ2h0PXIoe3NpemU6aS5zaXplLHVuaXQ6aS51bml0fSxwKSxpLnB4TGluZUhlaWdodD1yKHtzaXplOmkubGluZUhlaWdodHx8aS5zaXplLHVuaXQ6aS5saW5lSGVpZ2h0VW5pdHx8aS51bml0fSxwKSxpfX0sZnVuY3Rpb24oYyxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gcn0pLHQoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiByKHMpe3JldHVybmByZ2JhKCR7cy5tYXAoKGcsdik9PnY8Mz9NYXRoLnJvdW5kKGcqMjU1KTpnKS5qb2luKCl9KWB9fSxmdW5jdGlvbihjLGUsdCl7dC5yKGUpLHQuZChlLCJhcHBseUZpbHRlciIsZnVuY3Rpb24oKXtyZXR1cm4gaH0pLHQuZChlLCJkcmF3TWVzaDJEIixmdW5jdGlvbigpe3JldHVybiB1fSk7dmFyIHI9dCgxKSxzPXQoMjQpLGc9dCgyMyksdj10KDI2KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gaChNLGYpe2NvbnN0IHk9TS5jYW52YXM7TS5zYXZlKCksTS5maWx0ZXI9ZixNLmRyYXdJbWFnZSh5LDAsMCx5LndpZHRoLHkuaGVpZ2h0KSxNLnJlc3RvcmUoKX1mdW5jdGlvbiBsKE0sZil7Y29uc3QgeT0vcmdiYVwoKFxkKyksKFxkKyksKFxkKyksKFxkKylcKS87TT1NLm1hdGNoKHkpLnNsaWNlKDEsNSkubWFwKE51bWJlciksZj1mLm1hdGNoKHkpLnNsaWNlKDEsNSkubWFwKE51bWJlcik7Y29uc3QgeD1bXSxiPWZbM107Zm9yKGxldCBPPTA7Tzw0O08rKyl4W09dPU9iamVjdCh2Lm1peCkoTVtPXSxmW09dLGIpO3JldHVybmByZ2JhKCR7eC5qb2luKCl9KWB9ZnVuY3Rpb24gdShNLGYseT0hMCx4PW51bGwsYj1udWxsLE89bnVsbCxtPW51bGwpe2Yuc2F2ZSgpO2xldCBwPSExLG49ITE7aWYoZi5nbG9iYWxBbHBoYT1NLmdldE9wYWNpdHkoKSxNLl91cGRhdGVNYXRyaXgmJk0udHJhbnNmb3JtU2NhbGUvTS5jb250b3Vycy5zY2FsZT4xLjUmJk0uYWNjdXJhdGUoTS50cmFuc2Zvcm1TY2FsZSksTS5saW5lV2lkdGgpe2xldCBvPU0uZ3JhZGllbnQmJk0uZ3JhZGllbnQuc3Ryb2tlO2lmKG8pe2NvbnN0e3ZlY3RvcjpULGNvbG9yczpQfT1vO2lmKFQubGVuZ3RoPT09NilvPWYuY3JlYXRlUmFkaWFsR3JhZGllbnQoLi4uVCk7ZWxzZSBpZihULmxlbmd0aD09PTQpbz1mLmNyZWF0ZUxpbmVhckdyYWRpZW50KC4uLlQpO2Vsc2UgaWYoVC5sZW5ndGg9PT0zKW89Zi5jcmVhdGVDaXJjdWxhckdyYWRpZW50KC4uLlQpO2Vsc2UgdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCB2ZWN0b3IgZGltZW5zaW9uLiIpO1AuZm9yRWFjaCgoe29mZnNldDpDLGNvbG9yOkl9KT0+e2xldCBBPU9iamVjdChzLmRlZmF1bHQpKEkpO2ImJihBPWwoQSxiKSksby5hZGRDb2xvclN0b3AoQyxBKX0pLGYuc3Ryb2tlU3R5bGU9byxwPSEwfWVsc2UgTS5zdHJva2VTdHlsZSYmKGI/Zi5zdHJva2VTdHlsZT1sKE0uc3Ryb2tlU3R5bGUsYik6Zi5zdHJva2VTdHlsZT1NLnN0cm9rZVN0eWxlLHA9ITApfXAmJihmLmxpbmVXaWR0aD1NLmxpbmVXaWR0aCxmLmxpbmVKb2luPU0ubGluZUpvaW4sZi5saW5lQ2FwPU0ubGluZUNhcCxmLm1pdGVyTGltaXQ9TS5taXRlckxpbWl0LE0ubGluZURhc2gmJihmLnNldExpbmVEYXNoKE0ubGluZURhc2gpLE0ubGluZURhc2hPZmZzZXQmJihmLmxpbmVEYXNoT2Zmc2V0PU0ubGluZURhc2hPZmZzZXQpKSk7bGV0IGE9TS5ncmFkaWVudCYmTS5ncmFkaWVudC5maWxsO2lmKGEpe2NvbnN0e3ZlY3RvcjpvLGNvbG9yczpUfT1hO2lmKG8ubGVuZ3RoPT09NilhPWYuY3JlYXRlUmFkaWFsR3JhZGllbnQoLi4ubyk7ZWxzZSBpZihvLmxlbmd0aD09PTQpYT1mLmNyZWF0ZUxpbmVhckdyYWRpZW50KC4uLm8pO2Vsc2UgaWYoby5sZW5ndGg9PT0zKWE9Zi5jcmVhdGVDaXJjdWxhckdyYWRpZW50KC4uLm8pO2Vsc2UgdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCB2ZWN0b3IgZGltZW5zaW9uLiIpO1QuZm9yRWFjaCgoe29mZnNldDpQLGNvbG9yOkN9KT0+e2xldCBJPU9iamVjdChzLmRlZmF1bHQpKEMpO2ImJihJPWwoSSxiKSksYS5hZGRDb2xvclN0b3AoUCxJKX0pLGYuZmlsbFN0eWxlPWEsbj0hMH1lbHNlIE0uZmlsbFN0eWxlJiYoeD9mLmZpbGxTdHlsZT1sKE0uZmlsbFN0eWxlLHgpOmYuZmlsbFN0eWxlPU0uZmlsbFN0eWxlLG49ITApO2lmKG0mJmYudHJhbnNmb3JtKC4uLm0pLGYudHJhbnNmb3JtKC4uLk0udHJhbnNmb3JtTWF0cml4KSxNLmNsaXBQYXRoKXtjb25zdCBvPU0uY2xpcFBhdGgsVD1uZXcgUGF0aDJEKG8pO2YuY2xpcChUKX1jb25zdCBpPU0uY29udG91cnMubGVuZ3RoO2lmKE0uY29udG91cnMuZm9yRWFjaCgobyxUKT0+e2NvbnN0IFA9by5sZW5ndGgsQz1QPjEmJnIudmVjMi5lcXVhbHMob1swXSxvW1AtMV0pLEk9VD09PWktMSYmTS50ZXh0dXJlO2lmKG8mJlA+MCl7aWYobnx8cHx8SSl7Zi5iZWdpblBhdGgoKSxmLm1vdmVUbyguLi5vWzBdKTtmb3IobGV0IEE9MTtBPFA7QSsrKUE9PT1QLTEmJkM/Zi5jbG9zZVBhdGgoKTpmLmxpbmVUbyguLi5vW0FdKX1pZihuJiZmLmZpbGwoTS5maWxsUnVsZSksSSl7Zi5zYXZlKCksZi5jbGlwKCk7bGV0e2ltYWdlOkEsb3B0aW9uczpMfT1NLnRleHR1cmU7aWYoTyYmKEE9TyksTC5yZXBlYXQmJmNvbnNvbGUud2FybigiQ29udGV4dCAyRCBub3Qgc3VwcG9ydGVkIGltYWdlIHJlcGVhdCB5ZXQuIiksQS5mb250KXtMLnNjYWxlJiZjb25zb2xlLndhcm4oIkNvbnRleHQgMkQgbm90IHN1cHBvcnRlZCB0ZXh0IHNjYWxlIHlldC4iKSxMLnNyY1JlY3QmJmNvbnNvbGUud2FybigiQ29udGV4dCAyRCBub3Qgc3VwcG9ydGVkIHRleHQgc3JjUmVjdCB5ZXQuIik7bGV0e2ZvbnQ6RCxmaWxsQ29sb3I6UixzdHJva2VDb2xvcjpTLHN0cm9rZVdpZHRoOkIsdGV4dDp3fT1BOyFSJiYhUyYmKFI9IiMwMDAiKSxBcnJheS5pc0FycmF5KFIpJiYoUj1PYmplY3Qocy5kZWZhdWx0KShSKSksQXJyYXkuaXNBcnJheShTKSYmKFM9T2JqZWN0KHMuZGVmYXVsdCkoUykpLGYuZm9udD1EO2NvbnN0e3dpZHRoOkh9PWYubWVhc3VyZVRleHQodyksSj1PYmplY3QoZy5kZWZhdWx0KShEKSxxPU1hdGgubWF4KEoucHhMaW5lSGVpZ2h0LEoucHhIZWlnaHQqMS4xMyk7Zi50ZXh0QWxpZ249ImNlbnRlciIsZi50ZXh0QmFzZWxpbmU9Im1pZGRsZSI7Y29uc3QgVz1MLnJlY3QsRz1XWzBdK3EqLjUrSi5weEhlaWdodCouMDYsUT1XWzFdK0gqLjU7V1syXSE9bnVsbCYmZi5zY2FsZShXWzJdL0gsV1szXS9xKSxSJiYoZi5maWxsU3R5bGU9UixmLmZpbGxUZXh0KHcsUSxHKSksUyYmKGYubGluZVdpZHRoPUIsZi5zdHJva2VTdHlsZT1TLGYuc3Ryb2tlVGV4dCh3LFEsRykpfWVsc2V7bGV0IEQ9TC5yZWN0O2NvbnN0IFI9TC5zcmNSZWN0O0wuc2NhbGUmJihEPVswLDAsZi5jYW52YXMud2lkdGgsZi5jYW52YXMuaGVpZ2h0XSksTC5yb3RhdGVkJiZEJiYoRD1bLURbMV0sRFswXSxEWzNdLERbMl1dKSxSJiYoRD1EfHxbMCwwLFJbMl0sUlszXV0pLEwucm90YXRlZCYmKGYudHJhbnNsYXRlKDAsRD9EWzJdOkEud2lkdGgpLGYucm90YXRlKC0uNSpNYXRoLlBJKSksUj9mLmRyYXdJbWFnZShBLC4uLlIsLi4uRCk6RD9mLmRyYXdJbWFnZShBLC4uLkQpOmYuZHJhd0ltYWdlKEEsMCwwKX1mLnJlc3RvcmUoKX1wJiZmLnN0cm9rZSgpfX0pLGYucmVzdG9yZSgpLHkpe2NvbnN0IG89TS5maWx0ZXI7byYmaChmLG8pfX19LGZ1bmN0aW9uKGMsZSx0KXt0LnIoZSksdC5kKGUsImNsYW1wIixmdW5jdGlvbigpe3JldHVybiByfSksdC5kKGUsIm1peCIsZnVuY3Rpb24oKXtyZXR1cm4gc30pLHQuZChlLCJ0cmFuc2Zvcm1Qb2ludCIsZnVuY3Rpb24oKXtyZXR1cm4gZ30pLHQoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiByKHYsaCxsKXtyZXR1cm4gaD5sJiYoW2gsbF09W2wsaF0pLHY8aD9oOnY+bD9sOnZ9ZnVuY3Rpb24gcyh2LGgsbCl7cmV0dXJuIHYqKDEtbCkraCpsfWZ1bmN0aW9uIGcodixoKXtjb25zdFtsLHVdPXY7cmV0dXJuW2wqaFswXSt1KmhbMl0raFs0XSxsKmhbMV0rdSpoWzNdK2hbNV1dfX0sZnVuY3Rpb24oYyxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gbH0pO3ZhciByPXQoMjgpLHM9dCgyOSk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIGcodSxNLGYpe2NvbnN0IHk9dS51bmlmb3Jtc3x8e30seD1NLnVuaWZvcm1zfHx7fTtpZih5LnVfdGV4U2FtcGxlciYmeC51X3RleFNhbXBsZXImJnkudV90ZXhTYW1wbGVyIT09eC51X3RleFNhbXBsZXIpcmV0dXJuITE7Y29uc3QgYj1PYmplY3Qua2V5cyh5KSxPPU9iamVjdC5rZXlzKHgpLG09Yi5pbmRleE9mKCJ1X3RleFNhbXBsZXIiKSxwPU8uaW5kZXhPZigidV90ZXhTYW1wbGVyIik7aWYobT49MCYmYi5zcGxpY2UobSwxKSxwPj0wJiZPLnNwbGljZShwLDEpLGIubGVuZ3RoIT09Ty5sZW5ndGgpcmV0dXJuITE7Y29uc3Qgbj1iLmV2ZXJ5KGE9Pntjb25zdCBpPXlbYV0sbz14W2FdO2lmKGk9PT1vKXJldHVybiEwO2lmKGkubGVuZ3RoJiZvLmxlbmd0aCYmaS5sZW5ndGg9PT1vLmxlbmd0aCl7Zm9yKGxldCBUPTA7VDxpLmxlbmd0aDtUKyspaWYoaVtUXSE9PW9bVF0pcmV0dXJuITE7cmV0dXJuITB9cmV0dXJuITF9KTtpZihuKXtpZih5LnVfdGV4U2FtcGxlciYmIXgudV90ZXhTYW1wbGVyKU0uc2V0VGV4dHVyZSh5LnVfdGV4U2FtcGxlcix7aGlkZGVuOiEwfSk7ZWxzZSBpZigheS51X3RleFNhbXBsZXImJngudV90ZXhTYW1wbGVyKWZvcihsZXQgYT0wO2E8Zi5sZW5ndGg7YSsrKWZbYV0uc2V0VGV4dHVyZSh4LnVfdGV4U2FtcGxlcix7aGlkZGVuOiEwfSl9cmV0dXJuIG59Y29uc3Qgdj17fTtmdW5jdGlvbiBoKHUsTSl7aWYodS5sZW5ndGgpe2NvbnN0IGY9T2JqZWN0KHIuZGVmYXVsdCkodSx2KTtyZXR1cm4gZi5lbmFibGVCbGVuZD1NLHVbMF0uZmlsdGVyQ2FudmFzJiYoZi5maWx0ZXJDYW52YXM9ITApLGYucGFja0luZGV4PXVbMF0ucGFja0luZGV4LGYucGFja0xlbmd0aD11Lmxlbmd0aCxmLmJlZm9yZVJlbmRlcj11WzBdLmJlZm9yZVJlbmRlcixmLnBhc3M9dVswXS5wYXNzLGYuYWZ0ZXJSZW5kZXI9dVt1Lmxlbmd0aC0xXS5hZnRlclJlbmRlcix1Lmxlbmd0aD0wLGZ9fWZ1bmN0aW9uKmwodSxNLGY9ITEpe2NvbnN0IHk9W10seD11Lm9wdGlvbnMuYnVmZmVyU2l6ZTtsZXQgYj0wLE89ITE7Zm9yKGxldCBtPTA7bTxNLmxlbmd0aDttKyspe2NvbnN0IHA9TVttXTtpZihwIGluc3RhbmNlb2Ygcy5kZWZhdWx0KXkubGVuZ3RoJiYoeWllbGQgaCh5LE8pKSxiPTAsTz0hMSx5aWVsZCBwO2Vsc2V7Y29uc3Qgbj1wLm1lc2hEYXRhO2lmKG4uY2xpcFBhdGgmJiFuLnVuaWZvcm1zLnVfY2xpcFNhbXBsZXIpe2NvbnN0IGk9dS5jcmVhdGVUZXh0dXJlKG4uY2xpcFBhdGgpO24udW5pZm9ybXMudV9jbGlwU2FtcGxlcj1pfWxldCBhPTA7aWYoKCFmfHwhcC5jYW5JZ25vcmUoKSkmJm4mJm4ucG9zaXRpb25zLmxlbmd0aCl7cC5wYWNrSW5kZXg9bTtjb25zdCBpPXAuZmlsdGVyQ2FudmFzO2lmKGE9bi5wb3NpdGlvbnMubGVuZ3RoLGl8fGIrYT54KXkubGVuZ3RoJiYoeWllbGQgaCh5LE8pKSxiPTAsTz0hMTtlbHNlIGlmKGIpe2NvbnN0IG89eVt5Lmxlbmd0aC0xXTtvJiYoby5maWx0ZXJDYW52YXN8fG8uYWZ0ZXJSZW5kZXJ8fHAuYmVmb3JlUmVuZGVyfHxvLnBhc3MubGVuZ3RofHxwLnBhc3MubGVuZ3RofHxvLnByb2dyYW0hPT1wLnByb2dyYW18fCFnKG8scCx5KSkmJih5aWVsZCBoKHksTyksYj0wLE89ITEpfXkucHVzaChwKSxPPU98fHAuZW5hYmxlQmxlbmQsYis9YX1tPT09TS5sZW5ndGgtMSYmeS5sZW5ndGgmJih5aWVsZCBoKHksTykpfX19fSxmdW5jdGlvbihjLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBnfSksdCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IHI9e1VOU0lHTkVEX0JZVEU6VWludDhBcnJheSxVTlNJR05FRF9TSE9SVDpVaW50MTZBcnJheSxCWVRFOkludDhBcnJheSxTSE9SVDpJbnQxNkFycmF5LEZMT0FUOkZsb2F0MzJBcnJheX07ZnVuY3Rpb24gcyh2LGgpe2xldCBsPTAsdT0wLE09MCxmPTAseT0wLHg9MCxiPTA7Y29uc3QgTz12WzBdLnByb2dyYW07Zm9yKGxldCBtPTA7bTx2Lmxlbmd0aDttKyspe2NvbnN0IHA9dlttXS5tZXNoRGF0YTtpZihwKXtiKz1wLnBvc2l0aW9ucy5sZW5ndGg7Y29uc3Qgbj1wLnBvc2l0aW9uc1swXS5sZW5ndGg7bCs9cC5wb3NpdGlvbnMubGVuZ3RoKm4sdSs9cC5jZWxscy5sZW5ndGgqMyx4Kz1wLmF0dHJpYnV0ZXMuYV9jb2xvci5sZW5ndGgqNDtjb25zdCBhPXAudGV4dHVyZUNvb3JkO2EmJihNKz1hLmxlbmd0aCphWzBdLmxlbmd0aCk7Y29uc3QgaT1wLmF0dHJpYnV0ZXMuYV9zb3VyY2VSZWN0O2kmJihmKz1pLmxlbmd0aCo0KTtjb25zdCBvPXAuYXR0cmlidXRlcy5hX2NsaXBVVjtvJiYoeSs9by5sZW5ndGgqMil9fWlmKCghaC5wb3NpdGlvbnN8fGgucG9zaXRpb25zLmxlbmd0aDxsKSYmKGgucG9zaXRpb25zPW5ldyBGbG9hdDMyQXJyYXkobCkpLCghaC5jZWxsc3x8aC5jZWxscy5sZW5ndGg8dSkmJihoLmNlbGxzPW5ldyBVaW50MTZBcnJheSh1KSksTSYmKCFoLnRleHR1cmVDb29yZHx8aC50ZXh0dXJlQ29vcmQubGVuZ3RoPE0pJiYoaC50ZXh0dXJlQ29vcmQ9bmV3IEZsb2F0MzJBcnJheShNKSksKCFoLmFfY29sb3J8fGguYV9jb2xvci5sZW5ndGg8eCkmJihoLmFfY29sb3I9bmV3IFVpbnQ4QXJyYXkoeCkpLGYmJighaC5hX3NvdXJjZVJlY3R8fGguYV9zb3VyY2VSZWN0Lmxlbmd0aDxmKSYmKGguYV9zb3VyY2VSZWN0PW5ldyBGbG9hdDMyQXJyYXkoZikpLHkmJighaC5hX2NsaXBVVnx8aC5hX2NsaXBVVi5sZW5ndGg8eSkmJihoLmFfY2xpcFVWPW5ldyBGbG9hdDMyQXJyYXkoeSkpLE8pe2NvbnN0IG09T2JqZWN0LmVudHJpZXMoTy5fYXR0cmlidXRlKSxwPU8uX2F0dHJpYk9wdHN8fHt9O2ZvcihsZXQgbj0wO248bS5sZW5ndGg7bisrKXtjb25zdFthLGldPW1bbl07aWYoYSE9PSJhX2NvbG9yIiYmYSE9PSJhX3NvdXJjZVJlY3QiJiZpIT09Imlnbm9yZWQiKXtjb25zdCBvPXBbYV0/cFthXS50eXBlOiJGTE9BVCIsVD1yW29dLFA9aS5zaXplKmI7KCFoW2FdfHxoW2FdLmxlbmd0aDxQKSYmKGhbYV09bmV3IFQoUCkpfX19cmV0dXJuIGh9ZnVuY3Rpb24gZyh2LGgpe2xldCBsPVtdLHU9W10sTT1bXSxmPVtdLHk9W10seD1bXSxiPTAsTz0wO2NvbnN0IG09dlswXT92WzBdLnVuaWZvcm1zfHx7fTp7fSxwPXZbMF0/dlswXS5wcm9ncmFtOm51bGw7aCYmKHModixoKSx1PWguY2VsbHMsbD1oLnBvc2l0aW9ucyxNPWgudGV4dHVyZUNvb3JkLGY9aC5hX2NvbG9yLHk9aC5hX3NvdXJjZVJlY3QseD1oLmFfY2xpcFVWKTtsZXQgbj0hMSxhPSExO2NvbnN0IGk9e307Zm9yKGxldCBUPTA7VDx2Lmxlbmd0aDtUKyspe2xldCBQPXZbVF07aWYoUCl7aWYoUC5tZXNoRGF0YSYmKFA9UC5tZXNoRGF0YSksaCl7Y29uc3QgST1QLnBvc2l0aW9ucztmb3IobGV0IEE9MDtBPEkubGVuZ3RoO0ErKyl7Y29uc3QgTD1JW0FdLEQ9MyooYitBKTtmb3IobGV0IFI9MDtSPEwubGVuZ3RoO1IrKylsW0QrUl09TFtSXX19ZWxzZSBsLnB1c2goLi4uUC5wb3NpdGlvbnMpO2NvbnN0IEM9UC5jZWxscztmb3IobGV0IEk9MDtJPEMubGVuZ3RoO0krKyl7Y29uc3QgQT1DW0ldO2lmKGgpe2NvbnN0IEw9MyooTytJKTt1W0xdPUFbMF0rYix1W0wrMV09QVsxXStiLHVbTCsyXT1BWzJdK2J9ZWxzZSB1LnB1c2goW0FbMF0rYixBWzFdK2IsQVsyXStiXSl9aWYoaCl7Y29uc3QgST1QLmF0dHJpYnV0ZXMuYV9jb2xvcjtmb3IobGV0IEE9MDtBPEkubGVuZ3RoO0ErKyl7Y29uc3QgTD1JW0FdLEQ9NCooYitBKTtmW0RdPUxbMF0sZltEKzFdPUxbMV0sZltEKzJdPUxbMl0sZltEKzNdPUxbM119fWVsc2UgZi5wdXNoKC4uLlAuYXR0cmlidXRlcy5hX2NvbG9yKTtpZihQLmF0dHJpYnV0ZXMuYV9zb3VyY2VSZWN0KWlmKG49ITAsaCl7Y29uc3QgST1QLmF0dHJpYnV0ZXMuYV9zb3VyY2VSZWN0O2ZvcihsZXQgQT0wO0E8SS5sZW5ndGg7QSsrKXtjb25zdCBMPUlbQV0sRD00KihiK0EpO3lbRF09TFswXSx5W0QrMV09TFsxXSx5W0QrMl09TFsyXSx5W0QrM109TFszXX19ZWxzZSB5LnB1c2goLi4uUC5hdHRyaWJ1dGVzLmFfc291cmNlUmVjdCk7aWYoUC5hdHRyaWJ1dGVzLmFfY2xpcFVWKWlmKGE9ITAsaCl7Y29uc3QgST1QLmF0dHJpYnV0ZXMuYV9jbGlwVVY7Zm9yKGxldCBBPTA7QTxJLmxlbmd0aDtBKyspe2NvbnN0IEw9SVtBXSxEPTIqKGIrQSk7eFtEXT1MWzBdLHhbRCsxXT1MWzFdfX1lbHNlIHgucHVzaCguLi5QLmF0dHJpYnV0ZXMuYV9jbGlwVVYpO2lmKFAudGV4dHVyZUNvb3JkKWlmKGgpe2NvbnN0IEk9UC50ZXh0dXJlQ29vcmQ7Zm9yKGxldCBBPTA7QTxJLmxlbmd0aDtBKyspe2NvbnN0IEw9SVtBXSxEPTMqKGIrQSk7Zm9yKGxldCBSPTA7UjxMLmxlbmd0aDtSKyspTVtEK1JdPUxbUl19fWVsc2UgTS5wdXNoKC4uLlAudGV4dHVyZUNvb3JkKTtpZihwKXtjb25zdCBJPU9iamVjdC5lbnRyaWVzKHAuX2F0dHJpYnV0ZSk7Zm9yKGxldCBBPTA7QTxJLmxlbmd0aDtBKyspe2NvbnN0W0wsRF09SVtBXTtpZihMIT09ImFfY29sb3IiJiZMIT09ImFfc291cmNlUmVjdCImJkQhPT0iaWdub3JlZCIpaWYoaVtMXT1bXSxoKXtpW0xdPWhbTF07Y29uc3QgUj1QLmF0dHJpYnV0ZXNbTF0sUz1SWzBdLmxlbmd0aDtmb3IobGV0IEI9MDtCPFIubGVuZ3RoO0IrKyl7Y29uc3Qgdz1SW0JdLEg9UyooYitCKTtmb3IobGV0IEo9MDtKPHcubGVuZ3RoO0orKylpW0xdW0grSl09d1tKXX19ZWxzZSBpW0xdLnB1c2goLi4uUC5hdHRyaWJ1dGVzW0xdKX19Yis9UC5wb3NpdGlvbnMubGVuZ3RoLE8rPVAuY2VsbHMubGVuZ3RofX1pLmFfY29sb3I9ZixuJiZ5JiZ5Lmxlbmd0aD4wJiYoaS5hX3NvdXJjZVJlY3Q9eSk7Y29uc3Qgbz17cG9zaXRpb25zOmwsY2VsbHM6dSxhdHRyaWJ1dGVzOmksdW5pZm9ybXM6bSxjZWxsc0NvdW50Ok8qMyxwcm9ncmFtOnB9O3JldHVybiBNJiZNLmxlbmd0aCYmKG8udGV4dHVyZUNvb3JkPU0pLGEmJngubGVuZ3RoPjAmJihpLmFfY2xpcFVWPXgpLG99fSxmdW5jdGlvbihjLGUsdCl7dC5yKGUpO3ZhciByPXQoMSkscz10KDMwKSxnPXQoMjYpLHY9dCgzMSk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIGgoaSxvKXt2YXIgVD1PYmplY3Qua2V5cyhpKTtpZihPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKXt2YXIgUD1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGkpO28mJihQPVAuZmlsdGVyKGZ1bmN0aW9uKEMpe3JldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGksQykuZW51bWVyYWJsZX0pKSxULnB1c2guYXBwbHkoVCxQKX1yZXR1cm4gVH1mdW5jdGlvbiBsKGkpe2Zvcih2YXIgbz0xO288YXJndW1lbnRzLmxlbmd0aDtvKyspe3ZhciBUPWFyZ3VtZW50c1tvXSE9bnVsbD9hcmd1bWVudHNbb106e307byUyP2goT2JqZWN0KFQpLCEwKS5mb3JFYWNoKGZ1bmN0aW9uKFApe3UoaSxQLFRbUF0pfSk6T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnM/T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoaSxPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhUKSk6aChPYmplY3QoVCkpLmZvckVhY2goZnVuY3Rpb24oUCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGksUCxPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFQsUCkpfSl9cmV0dXJuIGl9ZnVuY3Rpb24gdShpLG8sVCl7cmV0dXJuIG8gaW4gaT9PYmplY3QuZGVmaW5lUHJvcGVydHkoaSxvLHt2YWx1ZTpULGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6aVtvXT1ULGl9Y29uc3QgTT1TeW1ib2woIm1lc2giKSxmPVN5bWJvbCgiY291bnQiKSx5PVN5bWJvbCgiYmxlbmQiKSx4PVN5bWJvbCgiZmlsdGVyIiksYj1TeW1ib2woInRleHR1cmVzIiksTz1TeW1ib2woInRleHR1cmVPcHRpb25zIiksbT1TeW1ib2woImNsb3VkQ29sb3IiKSxwPVN5bWJvbCgiY2xvdWRGaWx0ZXIiKSxuPVN5bWJvbCgiYnVmZmVyIik7ZnVuY3Rpb24gYShpLG89bnVsbCl7Y29uc3QgVD1uZXcgRmxvYXQzMkFycmF5KDMqaSksUD1uZXcgRmxvYXQzMkFycmF5KDMqaSksQz1uZXcgRmxvYXQzMkFycmF5KDQqaSksST1uZXcgRmxvYXQzMkFycmF5KDQqaSksQT1uZXcgRmxvYXQzMkFycmF5KDQqaSksTD1uZXcgRmxvYXQzMkFycmF5KDQqaSksRD1uZXcgRmxvYXQzMkFycmF5KDQqaSksUj1uZXcgVWludDhBcnJheShpKSxTPW5ldyBVaW50OEFycmF5KDQqaSksQj1uZXcgVWludDhBcnJheSg0KmkpO3JldHVybiBvJiYoVC5zZXQoby50cmFuc2Zvcm0wLDApLFAuc2V0KG8udHJhbnNmb3JtMSwwKSxDLnNldChvLmNvbG9yMCwwKSxJLnNldChvLmNvbG9yMSwwKSxBLnNldChvLmNvbG9yMiwwKSxMLnNldChvLmNvbG9yMywwKSxELnNldChvLmNvbG9yNCwwKSxSLnNldChvLmZyYW1lSW5kZXgsMCksUy5zZXQoby5maWxsQ29sb3IsMCksQi5zZXQoby5zdHJva2VDb2xvciwwKSkse2J1ZmZlclNpemU6aSx0cmFuc2Zvcm0wOlQsdHJhbnNmb3JtMTpQLGNvbG9yMDpDLGNvbG9yMTpJLGNvbG9yMjpBLGNvbG9yMzpMLGNvbG9yNDpELGZyYW1lSW5kZXg6UixmaWxsQ29sb3I6UyxzdHJva2VDb2xvcjpCfX1lLmRlZmF1bHQ9Y2xhc3N7Y29uc3RydWN0b3IoaSxvPTEse2J1ZmZlcjpUPTFlM309e30pe1Q9TWF0aC5tYXgoVCxvKSx0aGlzW2ZdPW8sdGhpc1tNXT1pLHRoaXNbbl09YShUKSx0aGlzW2JdPVtdLHRoaXNbeF09W10sdGhpc1ttXT0hMSx0aGlzW3BdPSExLHRoaXNbeV09ITEsdGhpcy5pbml0QnVmZmVyKCl9aW5pdEJ1ZmZlcihpPTApe2NvbnN0IG89dGhpc1tmXTtmb3IobGV0IFQ9aTtUPG87VCsrKXRoaXNbbl0udHJhbnNmb3JtMC5zZXQoWzEsMCwwXSxUKjMpLHRoaXNbbl0udHJhbnNmb3JtMS5zZXQoWzAsMSwwXSxUKjMpLHRoaXNbbl0uZnJhbWVJbmRleC5zZXQoWy0xXSxUKSx0aGlzW25dLmZpbGxDb2xvci5zZXQoWzAsMCwwLDBdLFQqNCksdGhpc1tuXS5zdHJva2VDb2xvci5zZXQoWzAsMCwwLDBdLFQqNCksdGhpcy5zZXRDb2xvclRyYW5zZm9ybShULG51bGwpfWdldCBidWZmZXJTaXplKCl7cmV0dXJuIHRoaXNbbl0uYnVmZmVyU2l6ZX1nZXQgbWVzaCgpe3JldHVybiB0aGlzW01dfXNldCBtZXNoKGkpe3RoaXNbTV09aSx0aGlzW2JdJiZ0aGlzLnNldFRleHR1cmVGcmFtZXModGhpc1tiXSx0aGlzW09dKX1nZXQgaGFzQ2xvdWRDb2xvcigpe3JldHVybiB0aGlzW21dfWdldCBoYXNDbG91ZEZpbHRlcigpe3JldHVybiB0aGlzW3BdfV9nZXRGaWx0ZXIoaSl7cmV0dXJuIHRoaXNbeF1baV09dGhpc1t4XVtpXXx8W10sdGhpc1t4XVtpXX1nZXRGaWx0ZXIoaSl7cmV0dXJuIHRoaXMuX2dldEZpbHRlcihpKS5qb2luKCIgIil9Z2V0IGVuYWJsZUJsZW5kKCl7cmV0dXJuIHRoaXNbTV0uZW5hYmxlQmxlbmR8fHRoaXNbeV19Y2FuSWdub3JlKCl7cmV0dXJuIHRoaXNbTV0uY2FuSWdub3JlKCl9ZGVsZXRlKGkpe2lmKGk+PXRoaXNbZl18fGk8MCl0aHJvdyBuZXcgRXJyb3IoIk91dCBvZiByYW5nZS4iKTtjb25zdHt0cmFuc2Zvcm0wOm8sdHJhbnNmb3JtMTpULGNvbG9yMDpQLGNvbG9yMTpDLGNvbG9yMjpJLGNvbG9yMzpBLGNvbG9yNDpMLGZyYW1lSW5kZXg6RCxmaWxsQ29sb3I6UixzdHJva2VDb2xvcjpTfT10aGlzW25dO28uc2V0KG8uc3ViYXJyYXkoMyooaSsxKSksMyppKSxULnNldChULnN1YmFycmF5KDMqKGkrMSkpLDMqaSksUC5zZXQoUC5zdWJhcnJheSg0KihpKzEpKSw0KmkpLEMuc2V0KEMuc3ViYXJyYXkoNCooaSsxKSksNCppKSxJLnNldChJLnN1YmFycmF5KDQqKGkrMSkpLDQqaSksQS5zZXQoQS5zdWJhcnJheSg0KihpKzEpKSw0KmkpLEwuc2V0KEwuc3ViYXJyYXkoNCooaSsxKSksNCppKSxELnNldChELnN1YmFycmF5KGkrMSksaSksUi5zZXQoUi5zdWJhcnJheSg0KihpKzEpKSw0KmkpLFMuc2V0KFMuc3ViYXJyYXkoNCooaSsxKSksNCppKTtmb3IoY29uc3QgQiBpbiB0aGlzW3hdKUI9PT1pP2RlbGV0ZSB0aGlzW3hdW0JdOkI+aSYmKHRoaXNbeF1bQi0xXT10aGlzW3hdW0JdLGRlbGV0ZSB0aGlzW3hdW0JdKTt0aGlzW2ZdLS19c2V0Q29sb3JUcmFuc2Zvcm0oaSxvKXtpZihpPj10aGlzW2ZdfHxpPDApdGhyb3cgbmV3IEVycm9yKCJPdXQgb2YgcmFuZ2UuIik7aSo9NDtjb25zdHtjb2xvcjA6VCxjb2xvcjE6UCxjb2xvcjI6Qyxjb2xvcjM6SSxjb2xvcjQ6QX09dGhpc1tuXTtyZXR1cm4gbyE9bnVsbD8oVC5zZXQoW29bMF0sb1s1XSxvWzEwXSxvWzE1XV0saSksUC5zZXQoW29bMV0sb1s2XSxvWzExXSxvWzE2XV0saSksQy5zZXQoW29bMl0sb1s3XSxvWzEyXSxvWzE3XV0saSksSS5zZXQoW29bM10sb1s4XSxvWzEzXSxvWzE4XV0saSksQS5zZXQoW29bNF0sb1s5XSxvWzE0XSxvWzE5XV0saSksdGhpc1t5XT10aGlzW3ldfHxvWzE4XTwxLHRoaXNbcF09ITApOihULnNldChbMSwwLDAsMF0saSksUC5zZXQoWzAsMSwwLDBdLGkpLEMuc2V0KFswLDAsMSwwXSxpKSxJLnNldChbMCwwLDAsMV0saSksQS5zZXQoWzAsMCwwLDBdLGkpKSx0aGlzfWdldENvbG9yVHJhbnNmb3JtKGkpe2lmKGk+PXRoaXNbZl18fGk8MCl0aHJvdyBuZXcgRXJyb3IoIk91dCBvZiByYW5nZS4iKTtpKj00O2NvbnN0e2NvbG9yMDpvLGNvbG9yMTpULGNvbG9yMjpQLGNvbG9yMzpDLGNvbG9yNDpJfT10aGlzW25dO3JldHVybltvW2ldLFRbaV0sUFtpXSxDW2ldLElbaV0sb1tpKzFdLFRbaSsxXSxQW2krMV0sQ1tpKzFdLElbaSsxXSxvW2krMl0sVFtpKzJdLFBbaSsyXSxDW2krMl0sSVtpKzJdLG9baSszXSxUW2krM10sUFtpKzNdLENbaSszXSxJW2krM11dfXRyYW5zZm9ybUNvbG9yKGksbyl7bGV0IFQ9dGhpcy5nZXRDb2xvclRyYW5zZm9ybShpKTtyZXR1cm4gVD1PYmplY3Qocy5tdWx0aXBseSkoVCxvKSx0aGlzLnNldENvbG9yVHJhbnNmb3JtKGksVCksdGhpc31zZXRGaWxsQ29sb3IoaSxvKXtpZihpPj10aGlzW2ZdfHxpPDApdGhyb3cgbmV3IEVycm9yKCJPdXQgb2YgcmFuZ2UuIik7dHlwZW9mIG89PSJzdHJpbmciJiYobz1PYmplY3Qodi5kZWZhdWx0KShvKSksb1szXT4wJiYodGhpc1ttXT0hMCksdGhpc1tuXS5maWxsQ29sb3Iuc2V0KG8ubWFwKFQ9Pk1hdGgucm91bmQoMjU1KlQpKSw0KmkpfXNldFN0cm9rZUNvbG9yKGksbyl7aWYoaT49dGhpc1tmXXx8aTwwKXRocm93IG5ldyBFcnJvcigiT3V0IG9mIHJhbmdlLiIpO3R5cGVvZiBvPT0ic3RyaW5nIiYmKG89T2JqZWN0KHYuZGVmYXVsdCkobykpLG9bM10+MCYmKHRoaXNbbV09ITApLHRoaXNbbl0uc3Ryb2tlQ29sb3Iuc2V0KG8ubWFwKFQ9Pk1hdGgucm91bmQoMjU1KlQpKSw0KmkpfWdldENsb3VkUkdCQShpKXtpZihpPj10aGlzW2ZdfHxpPDApdGhyb3cgbmV3IEVycm9yKCJPdXQgb2YgcmFuZ2UuIik7aSo9NDtjb25zdHtmaWxsQ29sb3I6byxzdHJva2VDb2xvcjpUfT10aGlzW25dLFA9W29baV0sb1tpKzFdLG9baSsyXSxvW2krM11dLEM9W1RbaV0sVFtpKzFdLFRbaSsyXSxUW2krM11dO3JldHVybiBQWzNdLz0yNTUsQ1szXS89MjU1LHtmaWxsOmByZ2JhKCR7UC5qb2luKCl9KWAsc3Ryb2tlOmByZ2JhKCR7Qy5qb2luKCl9KWB9fWdyYXlzY2FsZShpLG8pe3RoaXMudHJhbnNmb3JtQ29sb3IoaSxPYmplY3Qocy5ncmF5c2NhbGUpKG8pKSx0aGlzLl9nZXRGaWx0ZXIoaSkucHVzaChgZ3JheXNjYWxlKCR7MTAwKm99JSlgKX1icmlnaHRuZXNzKGksbyl7dGhpcy50cmFuc2Zvcm1Db2xvcihpLE9iamVjdChzLmJyaWdodG5lc3MpKG8pKSx0aGlzLl9nZXRGaWx0ZXIoaSkucHVzaChgYnJpZ2h0bmVzcygkezEwMCpvfSUpYCl9c2F0dXJhdGUoaSxvKXt0aGlzLnRyYW5zZm9ybUNvbG9yKGksT2JqZWN0KHMuc2F0dXJhdGUpKG8pKSx0aGlzLl9nZXRGaWx0ZXIoaSkucHVzaChgc2F0dXJhdGUoJHsxMDAqb30lKWApfWNvbnRyYXN0KGksbyl7dGhpcy50cmFuc2Zvcm1Db2xvcihpLE9iamVjdChzLmNvbnRyYXN0KShvKSksdGhpcy5fZ2V0RmlsdGVyKGkpLnB1c2goYGNvbnRyYXN0KCR7MTAwKm99JSlgKX1pbnZlcnQoaSxvKXt0aGlzLnRyYW5zZm9ybUNvbG9yKGksT2JqZWN0KHMuaW52ZXJ0KShvKSksdGhpcy5fZ2V0RmlsdGVyKGkpLnB1c2goYGludmVydCgkezEwMCpvfSUpYCl9c2VwaWEoaSxvKXt0aGlzLnRyYW5zZm9ybUNvbG9yKGksT2JqZWN0KHMuc2VwaWEpKG8pKSx0aGlzLl9nZXRGaWx0ZXIoaSkucHVzaChgc2VwaWEoJHsxMDAqb30lKWApfW9wYWNpdHkoaSxvKXt0aGlzLnRyYW5zZm9ybUNvbG9yKGksT2JqZWN0KHMub3BhY2l0eSkobykpLHRoaXMuX2dldEZpbHRlcihpKS5wdXNoKGBvcGFjaXR5KCR7MTAwKm99JSlgKX1odWVSb3RhdGUoaSxvKXt0aGlzLnRyYW5zZm9ybUNvbG9yKGksT2JqZWN0KHMuaHVlUm90YXRlKShvKSksdGhpcy5fZ2V0RmlsdGVyKGkpLnB1c2goYGh1ZS1yb3RhdGUoJHtvfWRlZylgKX1zZXRUcmFuc2Zvcm0oaSxvKXtpZihpPj10aGlzW2ZdfHxpPDApdGhyb3cgbmV3IEVycm9yKCJPdXQgb2YgcmFuZ2UuIik7aSo9MyxvPT1udWxsJiYobz1bMSwwLDAsMSwwLDBdKTtjb25zdHt0cmFuc2Zvcm0wOlQsdHJhbnNmb3JtMTpQfT10aGlzW25dO3JldHVybiBULnNldChbb1swXSxvWzJdLG9bNF1dLGkpLFAuc2V0KFtvWzFdLG9bM10sb1s1XV0saSksdGhpc31nZXRUcmFuc2Zvcm0oaSl7aWYoaT49dGhpc1tmXXx8aTwwKXRocm93IG5ldyBFcnJvcigiT3V0IG9mIHJhbmdlLiIpO2kqPTM7Y29uc3R7dHJhbnNmb3JtMDpvLHRyYW5zZm9ybTE6VH09dGhpc1tuXTtyZXR1cm5bb1tpXSxUW2ldLG9baSsxXSxUW2krMV0sb1tpKzJdLFRbaSsyXV19Z2V0VGV4dHVyZUZyYW1lKGkpe3JldHVybiB0aGlzW2JdW3RoaXNbbl0uZnJhbWVJbmRleFtpXV19c2V0VGV4dHVyZUZyYW1lcyhpPVtdLG89e30pe2lmKGkubGVuZ3RoPjEyKXRocm93IG5ldyBFcnJvcigiTWF4IGZyYW1lcyBleGNlZWQuIEFsbG93IDEyIGZyYW1lcy4iKTtpLmxlbmd0aCYmdGhpc1tNXS5zZXRUZXh0dXJlKGlbMF0sbyksdGhpc1tiXT1pLHRoaXNbT109b31zZXRGcmFtZUluZGV4KGksbyl7aWYoaT49dGhpc1tmXXx8aTwwKXRocm93IG5ldyBFcnJvcigiT3V0IG9mIHJhbmdlLiIpO2NvbnN0IFQ9dGhpc1tiXS5sZW5ndGg7aWYoVDw9MCl0aHJvdyBuZXcgRXJyb3IoIk5vIGZyYW1lcyIpO3RoaXNbbl0uZnJhbWVJbmRleFtpXT1vJVR9Z2V0IGFtb3VudCgpe3JldHVybiB0aGlzW2ZdfXNldCBhbW91bnQoaSl7Y29uc3Qgbz10aGlzW2ZdO2khPT1vJiYoaT50aGlzW25dLmJ1ZmZlclNpemUmJih0aGlzW25dPWEoTWF0aC5tYXgoaSx0aGlzW25dLmJ1ZmZlclNpemUrMWUzKSx0aGlzW25dKSksdGhpc1tmXT1pLGk+byYmdGhpcy5pbml0QnVmZmVyKG8pKX1nZXQgbWVzaERhdGEoKXtjb25zdHthdHRyaWJ1dGVzOmksY2VsbHM6byxwb3NpdGlvbnM6VCx0ZXh0dXJlQ29vcmQ6UCx1bmlmb3JtczpDfT10aGlzW01dLm1lc2hEYXRhLEk9dGhpc1tiXSxBPXthdHRyaWJ1dGVzOmwoe30saSksY2VsbHM6byxwb3NpdGlvbnM6VCx0ZXh0dXJlQ29vcmQ6UCx1bmlmb3JtczpsKHt9LEMpLGluc3RhbmNlQ291bnQ6dGhpc1tmXSxlbmFibGVCbGVuZDp0aGlzLmVuYWJsZUJsZW5kfTtJLmxlbmd0aCYmSS5mb3JFYWNoKChHLFEpPT57QS51bmlmb3Jtc1tgdV90ZXhGcmFtZSR7UX1gXT1HfSk7Y29uc3R7dHJhbnNmb3JtMDpMLHRyYW5zZm9ybTE6RCxjb2xvcjA6Uixjb2xvcjE6Uyxjb2xvcjI6Qixjb2xvcjM6dyxjb2xvcjQ6SCxmaWxsQ29sb3I6SixzdHJva2VDb2xvcjpxLGZyYW1lSW5kZXg6V309dGhpc1tuXTtyZXR1cm4gdGhpc1tNXS51bmlmb3Jtcy51X3RleFNhbXBsZXImJihBLmF0dHJpYnV0ZXMuYV9mcmFtZUluZGV4PXtkYXRhOlcsZGl2aXNvcjoxfSksQS5hdHRyaWJ1dGVzLmFfdHJhbnNmb3JtMD17ZGF0YTpMLGRpdmlzb3I6MX0sQS5hdHRyaWJ1dGVzLmFfdHJhbnNmb3JtMT17ZGF0YTpELGRpdmlzb3I6MX0sQS5hdHRyaWJ1dGVzLmFfY29sb3JDbG91ZDA9e2RhdGE6UixkaXZpc29yOjF9LEEuYXR0cmlidXRlcy5hX2NvbG9yQ2xvdWQxPXtkYXRhOlMsZGl2aXNvcjoxfSxBLmF0dHJpYnV0ZXMuYV9jb2xvckNsb3VkMj17ZGF0YTpCLGRpdmlzb3I6MX0sQS5hdHRyaWJ1dGVzLmFfY29sb3JDbG91ZDM9e2RhdGE6dyxkaXZpc29yOjF9LEEuYXR0cmlidXRlcy5hX2NvbG9yQ2xvdWQ0PXtkYXRhOkgsZGl2aXNvcjoxfSx0aGlzLmhhc0Nsb3VkQ29sb3ImJihBLmF0dHJpYnV0ZXMuYV9maWxsQ2xvdWRDb2xvcj17ZGF0YTpKLGRpdmlzb3I6MX0sQS5hdHRyaWJ1dGVzLmFfc3Ryb2tlQ2xvdWRDb2xvcj17ZGF0YTpxLGRpdmlzb3I6MX0pLEF9c2V0UHJvZ3JhbShpKXt0aGlzW01dLnNldFByb2dyYW0oaSl9Z2V0IHByb2dyYW0oKXtyZXR1cm4gdGhpc1tNXS5wcm9ncmFtfXRyYW5zZm9ybShpLG8pe2NvbnN0IFQ9dGhpcy5nZXRUcmFuc2Zvcm0oaSk7cmV0dXJuIG89ci5tYXQyZC5tdWx0aXBseShBcnJheS5vZigwLDAsMCwwLDAsMCksVCxvKSx0aGlzLnNldFRyYW5zZm9ybShpLG8pLHRoaXN9dHJhbnNsYXRlKGksW28sVF0pe2xldCBQPXIubWF0MmQuY3JlYXRlKCk7cmV0dXJuIFA9ci5tYXQyZC50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDApLFAsW28sVF0pLHRoaXMudHJhbnNmb3JtKGksUCl9cm90YXRlKGksbyxbVCxQXT1bMCwwXSl7bGV0IEM9ci5tYXQyZC5jcmVhdGUoKTtyZXR1cm4gQz1yLm1hdDJkLnRyYW5zbGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCksQyxbVCxQXSksQz1yLm1hdDJkLnJvdGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCksQyxvKSxDPXIubWF0MmQudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxDLFstVCwtUF0pLHRoaXMudHJhbnNmb3JtKGksQyl9c2NhbGUoaSxbbyxUPW9dLFtQLENdPVswLDBdKXtsZXQgST1yLm1hdDJkLmNyZWF0ZSgpO3JldHVybiBJPXIubWF0MmQudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxJLFtQLENdKSxJPXIubWF0MmQuc2NhbGUoQXJyYXkub2YoMCwwLDAsMCwwLDApLEksW28sVF0pLEk9ci5tYXQyZC50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDApLEksWy1QLC1DXSksdGhpcy50cmFuc2Zvcm0oaSxJKX1za2V3KGksW28sVD1vXSxbUCxDXT1bMCwwXSl7bGV0IEk9ci5tYXQyZC5jcmVhdGUoKTtyZXR1cm4gST1yLm1hdDJkLnRyYW5zbGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCksSSxbUCxDXSksST1yLm1hdDJkLm11bHRpcGx5KEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxJLHIubWF0MmQuZnJvbVZhbHVlcygxLE1hdGgudGFuKFQpLE1hdGgudGFuKG8pLDEsMCwwKSksST1yLm1hdDJkLnRyYW5zbGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCksSSxbLVAsLUNdKSx0aGlzLnRyYW5zZm9ybShpLEkpfWlzUG9pbnRDb2xsaXNpb24oaSxbbyxUXSxQPSJib3RoIil7Y29uc3QgQz10aGlzLmdldFRyYW5zZm9ybShpKSxJPU9iamVjdChnLnRyYW5zZm9ybVBvaW50KShbbyxUXSxyLm1hdDJkLmludmVydChBcnJheS5vZigwLDAsMCwwLDAsMCksQykpO3JldHVybiB0aGlzW01dLmlzUG9pbnRDb2xsaXNpb24oLi4uSSxQKX1pc1BvaW50SW5GaWxsKGksW28sVF0pe3JldHVybiB0aGlzLmlzUG9pbnRDb2xsaXNpb24oaSxbbyxUXSwiZmlsbCIpfWlzUG9pbnRJblN0cm9rZShpLFtvLFRdKXtyZXR1cm4gdGhpcy5pc1BvaW50Q29sbGlzaW9uKGksW28sVF0sInN0cm9rZSIpfX19LGZ1bmN0aW9uKGMsZSx0KXt0LnIoZSksdC5kKGUsIm11bHRpcGx5IixmdW5jdGlvbigpe3JldHVybiBzfSksdC5kKGUsImdyYXlzY2FsZSIsZnVuY3Rpb24oKXtyZXR1cm4gZ30pLHQuZChlLCJicmlnaHRuZXNzIixmdW5jdGlvbigpe3JldHVybiB2fSksdC5kKGUsInNhdHVyYXRlIixmdW5jdGlvbigpe3JldHVybiBofSksdC5kKGUsImNvbnRyYXN0IixmdW5jdGlvbigpe3JldHVybiBsfSksdC5kKGUsImludmVydCIsZnVuY3Rpb24oKXtyZXR1cm4gdX0pLHQuZChlLCJzZXBpYSIsZnVuY3Rpb24oKXtyZXR1cm4gTX0pLHQuZChlLCJvcGFjaXR5IixmdW5jdGlvbigpe3JldHVybiBmfSksdC5kKGUsImh1ZVJvdGF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4geX0pO3ZhciByPXQoMjYpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBzKHgsYil7Y29uc3QgTz1bXSxtPXhbMF0scD14WzFdLG49eFsyXSxhPXhbM10saT14WzRdLG89eFs1XSxUPXhbNl0sUD14WzddLEM9eFs4XSxJPXhbOV0sQT14WzEwXSxMPXhbMTFdLEQ9eFsxMl0sUj14WzEzXSxTPXhbMTRdLEI9eFsxNV0sdz14WzE2XSxIPXhbMTddLEo9eFsxOF0scT14WzE5XTtsZXQgVz1iWzBdLEc9YlsxXSxRPWJbMl0sdHQ9YlszXSxfPWJbNF07cmV0dXJuIE9bMF09VyptK0cqbytRKkErdHQqQixPWzFdPVcqcCtHKlQrUSpMK3R0KncsT1syXT1XKm4rRypQK1EqRCt0dCpILE9bM109VyphK0cqQytRKlIrdHQqSixPWzRdPVcqaStHKkkrUSpTK3R0KnErXyxXPWJbNV0sRz1iWzZdLFE9Yls3XSx0dD1iWzhdLF89Yls5XSxPWzVdPVcqbStHKm8rUSpBK3R0KkIsT1s2XT1XKnArRypUK1EqTCt0dCp3LE9bN109VypuK0cqUCtRKkQrdHQqSCxPWzhdPVcqYStHKkMrUSpSK3R0KkosT1s5XT1XKmkrRypJK1EqUyt0dCpxK18sVz1iWzEwXSxHPWJbMTFdLFE9YlsxMl0sdHQ9YlsxM10sXz1iWzE0XSxPWzEwXT1XKm0rRypvK1EqQSt0dCpCLE9bMTFdPVcqcCtHKlQrUSpMK3R0KncsT1sxMl09VypuK0cqUCtRKkQrdHQqSCxPWzEzXT1XKmErRypDK1EqUit0dCpKLE9bMTRdPVcqaStHKkkrUSpTK3R0KnErXyxXPWJbMTVdLEc9YlsxNl0sUT1iWzE3XSx0dD1iWzE4XSxfPWJbMTldLE9bMTVdPVcqbStHKm8rUSpBK3R0KkIsT1sxNl09VypwK0cqVCtRKkwrdHQqdyxPWzE3XT1XKm4rRypQK1EqRCt0dCpILE9bMThdPVcqYStHKkMrUSpSK3R0KkosT1sxOV09VyppK0cqSStRKlMrdHQqcStfLE99ZnVuY3Rpb24gZyh4KXt4PU9iamVjdChyLmNsYW1wKSgwLDEseCk7Y29uc3QgYj0uMjEyNip4LE89LjcxNTIqeCxtPS4wNzIyKng7cmV0dXJuW2IrMS14LE8sbSwwLDAsYixPKzEteCxtLDAsMCxiLE8sbSsxLXgsMCwwLDAsMCwwLDEsMF19ZnVuY3Rpb24gdih4KXtyZXR1cm5beCwwLDAsMCwwLDAseCwwLDAsMCwwLDAseCwwLDAsMCwwLDAsMSwwXX1mdW5jdGlvbiBoKHgpe2NvbnN0IGI9LjIxMjYqKDEteCksTz0uNzE1MiooMS14KSxtPS4wNzIyKigxLXgpO3JldHVybltiK3gsTyxtLDAsMCxiLE8reCxtLDAsMCxiLE8sbSt4LDAsMCwwLDAsMCwxLDBdfWZ1bmN0aW9uIGwoeCl7Y29uc3QgYj0uNSooMS14KTtyZXR1cm5beCwwLDAsMCxiLDAseCwwLDAsYiwwLDAseCwwLGIsMCwwLDAsMSwwXX1mdW5jdGlvbiB1KHgpe2NvbnN0IGI9MS0yKng7cmV0dXJuW2IsMCwwLDAseCwwLGIsMCwwLHgsMCwwLGIsMCx4LDAsMCwwLDEsMF19ZnVuY3Rpb24gTSh4KXtyZXR1cm5bMS0uNjA3KngsLjc2OSp4LC4xODkqeCwwLDAsLjM0OSp4LDEtLjMxNCp4LC4xNjgqeCwwLDAsLjI3Mip4LC41MzQqeCwxLS44NjkqeCwwLDAsMCwwLDAsMSwwXX1mdW5jdGlvbiBmKHgpe3JldHVyblsxLDAsMCwwLDAsMCwxLDAsMCwwLDAsMCwxLDAsMCwwLDAsMCx4LDBdfWZ1bmN0aW9uIHkoeCl7Y29uc3QgYj14LzE4MCpNYXRoLlBJLE89TWF0aC5jb3MoYiksbT1NYXRoLnNpbihiKSxwPS4yMTI2LG49LjcxNTIsYT0uMDcyMjtyZXR1cm5bcCtPKigxLXApK20qLXAsbitPKi1uK20qLW4sYStPKi1hK20qKDEtYSksMCwwLHArTyotcCttKi4xNDMsbitPKigxLW4pK20qLjE0LGErTyotYSttKi0uMjgzLDAsMCxwK08qLXArbSotKDEtcCksbitPKi1uK20qbixhK08qKDEtYSkrbSphLDAsMCwwLDAsMCwxLDBdfX0sZnVuY3Rpb24oYyxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gZ30pO3ZhciByPXQoMzIpLHM9dC5uKHIpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBnKHYpe2NvbnN0IGg9cygpKHYpO2lmKCFofHwhaC5sZW5ndGgpdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCBjb2xvciB2YWx1ZS4iKTtyZXR1cm5baFswXS8yNTUsaFsxXS8yNTUsaFsyXS8yNTUsaFszXV19fSxmdW5jdGlvbihjLGUsdCl7dmFyIHI9dCgzMykscz10KDM3KSxnPXQoMzkpO2MuZXhwb3J0cz1mdW5jdGlvbihoKXt2YXIgbCx1PXIoaCk7cmV0dXJuIHUuc3BhY2U/KGw9QXJyYXkoMyksbFswXT1nKHUudmFsdWVzWzBdLDAsMjU1KSxsWzFdPWcodS52YWx1ZXNbMV0sMCwyNTUpLGxbMl09Zyh1LnZhbHVlc1syXSwwLDI1NSksdS5zcGFjZVswXT09PSJoIiYmKGw9cy5yZ2IobCkpLGwucHVzaChnKHUuYWxwaGEsMCwxKSksbCk6W119fSxmdW5jdGlvbihjLGUsdCl7KGZ1bmN0aW9uKHIpe3ZhciBzPXQoMzQpLGc9dCgzNSksdj10KDM2KTtjLmV4cG9ydHM9bDt2YXIgaD17cmVkOjAsb3JhbmdlOjYwLHllbGxvdzoxMjAsZ3JlZW46MTgwLGJsdWU6MjQwLHB1cnBsZTozMDB9O2Z1bmN0aW9uIGwodSl7dmFyIE0sZj1bXSx5PTEseDtpZih0eXBlb2YgdT09InN0cmluZyIpaWYoc1t1XSlmPXNbdV0uc2xpY2UoKSx4PSJyZ2IiO2Vsc2UgaWYodT09PSJ0cmFuc3BhcmVudCIpeT0wLHg9InJnYiIsZj1bMCwwLDBdO2Vsc2UgaWYoL14jW0EtRmEtZjAtOV0rJC8udGVzdCh1KSl7dmFyIGI9dS5zbGljZSgxKSxPPWIubGVuZ3RoLG09Tzw9NDt5PTEsbT8oZj1bcGFyc2VJbnQoYlswXStiWzBdLDE2KSxwYXJzZUludChiWzFdK2JbMV0sMTYpLHBhcnNlSW50KGJbMl0rYlsyXSwxNildLE89PT00JiYoeT1wYXJzZUludChiWzNdK2JbM10sMTYpLzI1NSkpOihmPVtwYXJzZUludChiWzBdK2JbMV0sMTYpLHBhcnNlSW50KGJbMl0rYlszXSwxNikscGFyc2VJbnQoYls0XStiWzVdLDE2KV0sTz09PTgmJih5PXBhcnNlSW50KGJbNl0rYls3XSwxNikvMjU1KSksZlswXXx8KGZbMF09MCksZlsxXXx8KGZbMV09MCksZlsyXXx8KGZbMl09MCkseD0icmdiIn1lbHNlIGlmKE09L14oKD86cmdifGhzW2x2Yl18aHdifGNteWs/fHh5W3p5XXxncmF5fGxhYnxsY2h1P3Y/fFtseV11dnxsbXMpYT8pXHMqXCgoW15cKV0qKVwpLy5leGVjKHUpKXt2YXIgcD1NWzFdLG49cD09PSJyZ2IiLGI9cC5yZXBsYWNlKC9hJC8sIiIpO3g9Yjt2YXIgTz1iPT09ImNteWsiPzQ6Yj09PSJncmF5Ij8xOjM7Zj1NWzJdLnRyaW0oKS5zcGxpdCgvXHMqLFxzKi8pLm1hcChmdW5jdGlvbihULFApe2lmKC8lJC8udGVzdChUKSlyZXR1cm4gUD09PU8/cGFyc2VGbG9hdChUKS8xMDA6Yj09PSJyZ2IiP3BhcnNlRmxvYXQoVCkqMjU1LzEwMDpwYXJzZUZsb2F0KFQpO2lmKGJbUF09PT0iaCIpe2lmKC9kZWckLy50ZXN0KFQpKXJldHVybiBwYXJzZUZsb2F0KFQpO2lmKGhbVF0hPT12b2lkIDApcmV0dXJuIGhbVF19cmV0dXJuIHBhcnNlRmxvYXQoVCl9KSxwPT09YiYmZi5wdXNoKDEpLHk9bnx8ZltPXT09PXZvaWQgMD8xOmZbT10sZj1mLnNsaWNlKDAsTyl9ZWxzZSB1Lmxlbmd0aD4xMCYmL1swLTldKD86XHN8XC8pLy50ZXN0KHUpJiYoZj11Lm1hdGNoKC8oWzAtOV0rKS9nKS5tYXAoZnVuY3Rpb24oaSl7cmV0dXJuIHBhcnNlRmxvYXQoaSl9KSx4PXUubWF0Y2goLyhbYS16XSkvaWcpLmpvaW4oIiIpLnRvTG93ZXJDYXNlKCkpO2Vsc2UgaWYoIWlzTmFOKHUpKXg9InJnYiIsZj1bdT4+PjE2LCh1JjY1MjgwKT4+PjgsdSYyNTVdO2Vsc2UgaWYoZyh1KSl7dmFyIGE9dih1LnIsdS5yZWQsdS5SLG51bGwpO2EhPT1udWxsPyh4PSJyZ2IiLGY9W2Esdih1LmcsdS5ncmVlbix1LkcpLHYodS5iLHUuYmx1ZSx1LkIpXSk6KHg9ImhzbCIsZj1bdih1LmgsdS5odWUsdS5IKSx2KHUucyx1LnNhdHVyYXRpb24sdS5TKSx2KHUubCx1LmxpZ2h0bmVzcyx1LkwsdS5iLHUuYnJpZ2h0bmVzcyldKSx5PXYodS5hLHUuYWxwaGEsdS5vcGFjaXR5LDEpLHUub3BhY2l0eSE9bnVsbCYmKHkvPTEwMCl9ZWxzZShBcnJheS5pc0FycmF5KHUpfHxyLkFycmF5QnVmZmVyJiZBcnJheUJ1ZmZlci5pc1ZpZXcmJkFycmF5QnVmZmVyLmlzVmlldyh1KSkmJihmPVt1WzBdLHVbMV0sdVsyXV0seD0icmdiIix5PXUubGVuZ3RoPT09ND91WzNdOjEpO3JldHVybntzcGFjZTp4LHZhbHVlczpmLGFscGhhOnl9fX0pLmNhbGwodGhpcyx0KDIyKSl9LGZ1bmN0aW9uKGMsZSx0KXtjLmV4cG9ydHM9e2FsaWNlYmx1ZTpbMjQwLDI0OCwyNTVdLGFudGlxdWV3aGl0ZTpbMjUwLDIzNSwyMTVdLGFxdWE6WzAsMjU1LDI1NV0sYXF1YW1hcmluZTpbMTI3LDI1NSwyMTJdLGF6dXJlOlsyNDAsMjU1LDI1NV0sYmVpZ2U6WzI0NSwyNDUsMjIwXSxiaXNxdWU6WzI1NSwyMjgsMTk2XSxibGFjazpbMCwwLDBdLGJsYW5jaGVkYWxtb25kOlsyNTUsMjM1LDIwNV0sYmx1ZTpbMCwwLDI1NV0sYmx1ZXZpb2xldDpbMTM4LDQzLDIyNl0sYnJvd246WzE2NSw0Miw0Ml0sYnVybHl3b29kOlsyMjIsMTg0LDEzNV0sY2FkZXRibHVlOls5NSwxNTgsMTYwXSxjaGFydHJldXNlOlsxMjcsMjU1LDBdLGNob2NvbGF0ZTpbMjEwLDEwNSwzMF0sY29yYWw6WzI1NSwxMjcsODBdLGNvcm5mbG93ZXJibHVlOlsxMDAsMTQ5LDIzN10sY29ybnNpbGs6WzI1NSwyNDgsMjIwXSxjcmltc29uOlsyMjAsMjAsNjBdLGN5YW46WzAsMjU1LDI1NV0sZGFya2JsdWU6WzAsMCwxMzldLGRhcmtjeWFuOlswLDEzOSwxMzldLGRhcmtnb2xkZW5yb2Q6WzE4NCwxMzQsMTFdLGRhcmtncmF5OlsxNjksMTY5LDE2OV0sZGFya2dyZWVuOlswLDEwMCwwXSxkYXJrZ3JleTpbMTY5LDE2OSwxNjldLGRhcmtraGFraTpbMTg5LDE4MywxMDddLGRhcmttYWdlbnRhOlsxMzksMCwxMzldLGRhcmtvbGl2ZWdyZWVuOls4NSwxMDcsNDddLGRhcmtvcmFuZ2U6WzI1NSwxNDAsMF0sZGFya29yY2hpZDpbMTUzLDUwLDIwNF0sZGFya3JlZDpbMTM5LDAsMF0sZGFya3NhbG1vbjpbMjMzLDE1MCwxMjJdLGRhcmtzZWFncmVlbjpbMTQzLDE4OCwxNDNdLGRhcmtzbGF0ZWJsdWU6WzcyLDYxLDEzOV0sZGFya3NsYXRlZ3JheTpbNDcsNzksNzldLGRhcmtzbGF0ZWdyZXk6WzQ3LDc5LDc5XSxkYXJrdHVycXVvaXNlOlswLDIwNiwyMDldLGRhcmt2aW9sZXQ6WzE0OCwwLDIxMV0sZGVlcHBpbms6WzI1NSwyMCwxNDddLGRlZXBza3libHVlOlswLDE5MSwyNTVdLGRpbWdyYXk6WzEwNSwxMDUsMTA1XSxkaW1ncmV5OlsxMDUsMTA1LDEwNV0sZG9kZ2VyYmx1ZTpbMzAsMTQ0LDI1NV0sZmlyZWJyaWNrOlsxNzgsMzQsMzRdLGZsb3JhbHdoaXRlOlsyNTUsMjUwLDI0MF0sZm9yZXN0Z3JlZW46WzM0LDEzOSwzNF0sZnVjaHNpYTpbMjU1LDAsMjU1XSxnYWluc2Jvcm86WzIyMCwyMjAsMjIwXSxnaG9zdHdoaXRlOlsyNDgsMjQ4LDI1NV0sZ29sZDpbMjU1LDIxNSwwXSxnb2xkZW5yb2Q6WzIxOCwxNjUsMzJdLGdyYXk6WzEyOCwxMjgsMTI4XSxncmVlbjpbMCwxMjgsMF0sZ3JlZW55ZWxsb3c6WzE3MywyNTUsNDddLGdyZXk6WzEyOCwxMjgsMTI4XSxob25leWRldzpbMjQwLDI1NSwyNDBdLGhvdHBpbms6WzI1NSwxMDUsMTgwXSxpbmRpYW5yZWQ6WzIwNSw5Miw5Ml0saW5kaWdvOls3NSwwLDEzMF0saXZvcnk6WzI1NSwyNTUsMjQwXSxraGFraTpbMjQwLDIzMCwxNDBdLGxhdmVuZGVyOlsyMzAsMjMwLDI1MF0sbGF2ZW5kZXJibHVzaDpbMjU1LDI0MCwyNDVdLGxhd25ncmVlbjpbMTI0LDI1MiwwXSxsZW1vbmNoaWZmb246WzI1NSwyNTAsMjA1XSxsaWdodGJsdWU6WzE3MywyMTYsMjMwXSxsaWdodGNvcmFsOlsyNDAsMTI4LDEyOF0sbGlnaHRjeWFuOlsyMjQsMjU1LDI1NV0sbGlnaHRnb2xkZW5yb2R5ZWxsb3c6WzI1MCwyNTAsMjEwXSxsaWdodGdyYXk6WzIxMSwyMTEsMjExXSxsaWdodGdyZWVuOlsxNDQsMjM4LDE0NF0sbGlnaHRncmV5OlsyMTEsMjExLDIxMV0sbGlnaHRwaW5rOlsyNTUsMTgyLDE5M10sbGlnaHRzYWxtb246WzI1NSwxNjAsMTIyXSxsaWdodHNlYWdyZWVuOlszMiwxNzgsMTcwXSxsaWdodHNreWJsdWU6WzEzNSwyMDYsMjUwXSxsaWdodHNsYXRlZ3JheTpbMTE5LDEzNiwxNTNdLGxpZ2h0c2xhdGVncmV5OlsxMTksMTM2LDE1M10sbGlnaHRzdGVlbGJsdWU6WzE3NiwxOTYsMjIyXSxsaWdodHllbGxvdzpbMjU1LDI1NSwyMjRdLGxpbWU6WzAsMjU1LDBdLGxpbWVncmVlbjpbNTAsMjA1LDUwXSxsaW5lbjpbMjUwLDI0MCwyMzBdLG1hZ2VudGE6WzI1NSwwLDI1NV0sbWFyb29uOlsxMjgsMCwwXSxtZWRpdW1hcXVhbWFyaW5lOlsxMDIsMjA1LDE3MF0sbWVkaXVtYmx1ZTpbMCwwLDIwNV0sbWVkaXVtb3JjaGlkOlsxODYsODUsMjExXSxtZWRpdW1wdXJwbGU6WzE0NywxMTIsMjE5XSxtZWRpdW1zZWFncmVlbjpbNjAsMTc5LDExM10sbWVkaXVtc2xhdGVibHVlOlsxMjMsMTA0LDIzOF0sbWVkaXVtc3ByaW5nZ3JlZW46WzAsMjUwLDE1NF0sbWVkaXVtdHVycXVvaXNlOls3MiwyMDksMjA0XSxtZWRpdW12aW9sZXRyZWQ6WzE5OSwyMSwxMzNdLG1pZG5pZ2h0Ymx1ZTpbMjUsMjUsMTEyXSxtaW50Y3JlYW06WzI0NSwyNTUsMjUwXSxtaXN0eXJvc2U6WzI1NSwyMjgsMjI1XSxtb2NjYXNpbjpbMjU1LDIyOCwxODFdLG5hdmFqb3doaXRlOlsyNTUsMjIyLDE3M10sbmF2eTpbMCwwLDEyOF0sb2xkbGFjZTpbMjUzLDI0NSwyMzBdLG9saXZlOlsxMjgsMTI4LDBdLG9saXZlZHJhYjpbMTA3LDE0MiwzNV0sb3JhbmdlOlsyNTUsMTY1LDBdLG9yYW5nZXJlZDpbMjU1LDY5LDBdLG9yY2hpZDpbMjE4LDExMiwyMTRdLHBhbGVnb2xkZW5yb2Q6WzIzOCwyMzIsMTcwXSxwYWxlZ3JlZW46WzE1MiwyNTEsMTUyXSxwYWxldHVycXVvaXNlOlsxNzUsMjM4LDIzOF0scGFsZXZpb2xldHJlZDpbMjE5LDExMiwxNDddLHBhcGF5YXdoaXA6WzI1NSwyMzksMjEzXSxwZWFjaHB1ZmY6WzI1NSwyMTgsMTg1XSxwZXJ1OlsyMDUsMTMzLDYzXSxwaW5rOlsyNTUsMTkyLDIwM10scGx1bTpbMjIxLDE2MCwyMjFdLHBvd2RlcmJsdWU6WzE3NiwyMjQsMjMwXSxwdXJwbGU6WzEyOCwwLDEyOF0scmViZWNjYXB1cnBsZTpbMTAyLDUxLDE1M10scmVkOlsyNTUsMCwwXSxyb3N5YnJvd246WzE4OCwxNDMsMTQzXSxyb3lhbGJsdWU6WzY1LDEwNSwyMjVdLHNhZGRsZWJyb3duOlsxMzksNjksMTldLHNhbG1vbjpbMjUwLDEyOCwxMTRdLHNhbmR5YnJvd246WzI0NCwxNjQsOTZdLHNlYWdyZWVuOls0NiwxMzksODddLHNlYXNoZWxsOlsyNTUsMjQ1LDIzOF0sc2llbm5hOlsxNjAsODIsNDVdLHNpbHZlcjpbMTkyLDE5MiwxOTJdLHNreWJsdWU6WzEzNSwyMDYsMjM1XSxzbGF0ZWJsdWU6WzEwNiw5MCwyMDVdLHNsYXRlZ3JheTpbMTEyLDEyOCwxNDRdLHNsYXRlZ3JleTpbMTEyLDEyOCwxNDRdLHNub3c6WzI1NSwyNTAsMjUwXSxzcHJpbmdncmVlbjpbMCwyNTUsMTI3XSxzdGVlbGJsdWU6WzcwLDEzMCwxODBdLHRhbjpbMjEwLDE4MCwxNDBdLHRlYWw6WzAsMTI4LDEyOF0sdGhpc3RsZTpbMjE2LDE5MSwyMTZdLHRvbWF0bzpbMjU1LDk5LDcxXSx0dXJxdW9pc2U6WzY0LDIyNCwyMDhdLHZpb2xldDpbMjM4LDEzMCwyMzhdLHdoZWF0OlsyNDUsMjIyLDE3OV0sd2hpdGU6WzI1NSwyNTUsMjU1XSx3aGl0ZXNtb2tlOlsyNDUsMjQ1LDI0NV0seWVsbG93OlsyNTUsMjU1LDBdLHllbGxvd2dyZWVuOlsxNTQsMjA1LDUwXX19LGZ1bmN0aW9uKGMsZSx0KXt2YXIgcj1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO2MuZXhwb3J0cz1mdW5jdGlvbihzKXt2YXIgZztyZXR1cm4gci5jYWxsKHMpPT09IltvYmplY3QgT2JqZWN0XSImJihnPU9iamVjdC5nZXRQcm90b3R5cGVPZihzKSxnPT09bnVsbHx8Zz09PU9iamVjdC5nZXRQcm90b3R5cGVPZih7fSkpfX0sZnVuY3Rpb24oYyxlKXtjLmV4cG9ydHM9ZnVuY3Rpb24oKXtmb3IodmFyIHQ9MDt0PGFyZ3VtZW50cy5sZW5ndGg7dCsrKWlmKGFyZ3VtZW50c1t0XSE9PXZvaWQgMClyZXR1cm4gYXJndW1lbnRzW3RdfX0sZnVuY3Rpb24oYyxlLHQpe3ZhciByPXQoMzgpO2MuZXhwb3J0cz17bmFtZToiaHNsIixtaW46WzAsMCwwXSxtYXg6WzM2MCwxMDAsMTAwXSxjaGFubmVsOlsiaHVlIiwic2F0dXJhdGlvbiIsImxpZ2h0bmVzcyJdLGFsaWFzOlsiSFNMIl0scmdiOmZ1bmN0aW9uKHMpe3ZhciBnPXNbMF0vMzYwLHY9c1sxXS8xMDAsaD1zWzJdLzEwMCxsLHUsTSxmLHk7aWYodj09PTApcmV0dXJuIHk9aCoyNTUsW3kseSx5XTtoPC41P3U9aCooMSt2KTp1PWgrdi1oKnYsbD0yKmgtdSxmPVswLDAsMF07Zm9yKHZhciB4PTA7eDwzO3grKylNPWcrMS8zKi0oeC0xKSxNPDA/TSsrOk0+MSYmTS0tLDYqTTwxP3k9bCsodS1sKSo2Kk06MipNPDE/eT11OjMqTTwyP3k9bCsodS1sKSooMi8zLU0pKjY6eT1sLGZbeF09eSoyNTU7cmV0dXJuIGZ9fSxyLmhzbD1mdW5jdGlvbihzKXt2YXIgZz1zWzBdLzI1NSx2PXNbMV0vMjU1LGg9c1syXS8yNTUsbD1NYXRoLm1pbihnLHYsaCksdT1NYXRoLm1heChnLHYsaCksTT11LWwsZix5LHg7cmV0dXJuIHU9PT1sP2Y9MDpnPT09dT9mPSh2LWgpL006dj09PXU/Zj0yKyhoLWcpL006aD09PXUmJihmPTQrKGctdikvTSksZj1NYXRoLm1pbihmKjYwLDM2MCksZjwwJiYoZis9MzYwKSx4PShsK3UpLzIsdT09PWw/eT0wOng8PS41P3k9TS8odStsKTp5PU0vKDItdS1sKSxbZix5KjEwMCx4KjEwMF19fSxmdW5jdGlvbihjLGUsdCl7Yy5leHBvcnRzPXtuYW1lOiJyZ2IiLG1pbjpbMCwwLDBdLG1heDpbMjU1LDI1NSwyNTVdLGNoYW5uZWw6WyJyZWQiLCJncmVlbiIsImJsdWUiXSxhbGlhczpbIlJHQiJdfX0sZnVuY3Rpb24oYyxlKXtjLmV4cG9ydHM9dDtmdW5jdGlvbiB0KHIscyxnKXtyZXR1cm4gczxnP3I8cz9zOnI+Zz9nOnI6cjxnP2c6cj5zP3M6cn19LGZ1bmN0aW9uKGMsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIGF9KTt2YXIgcj10KDQxKSxzPXQubihyKSxnPXQoNDIpLHY9dC5uKGcpLGg9dCg0MyksbD10Lm4oaCksdT10KDQ0KSxNPXQoNDYpLGY9dC5uKE0pLHk9dCg1MykseD10KDU1KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3QgYj1TeW1ib2woImNvbnRvdXJzIiksTz1TeW1ib2woInBhdGgiKSxtPVN5bWJvbCgic2ltcGxpZnkiKSxwPVN5bWJvbCgic2NhbGUiKSxuPTIqTWF0aC5QSTtjbGFzcyBhe2NvbnN0cnVjdG9yKG89e30pe3R5cGVvZiBvPT0ic3RyaW5nIiYmKG89e3BhdGg6b30pLG8ucGF0aD90aGlzW09dPXMoKShvLnBhdGgpOnRoaXNbT109W10sdGhpc1tiXT1udWxsLHRoaXNbbV09by5zaW1wbGlmeSE9bnVsbD9vLnNpbXBsaWZ5OjAsdGhpc1twXT1vLnNjYWxlIT1udWxsP28uc2NhbGU6Mn1nZXQgY29udG91cnMoKXtsZXQgbz1udWxsO2lmKCF0aGlzW2JdJiZ0aGlzW09dKXtjb25zdCBUPU9iamVjdCh1LmRlZmF1bHQpKGwoKSh0aGlzW09dKSk7dGhpc1tiXT1mKCkoVCx0aGlzW3BdLHRoaXNbbV0pLHRoaXNbYl0ucGF0aD1ULHRoaXNbYl0uc2ltcGxpZnk9dGhpc1ttXSx0aGlzW2JdLnNjYWxlPXRoaXNbcF19cmV0dXJuIHRoaXNbYl0mJihvPXRoaXNbYl0ubWFwKFQ9PlsuLi5UXSksby5wYXRoPXRoaXNbYl0ucGF0aCxvLnNpbXBsaWZ5PXRoaXNbYl0uc2ltcGxpZnksby5zY2FsZT10aGlzW2JdLnNjYWxlKSxvfWdldCBwYXRoKCl7cmV0dXJuIHRoaXNbT119Z2V0IHNpbXBsaWZ5KCl7cmV0dXJuIHRoaXNbbV19Z2V0IGJvdW5kaW5nQm94KCl7Y29uc3Qgbz10aGlzLmNvbnRvdXJzO2lmKG8mJm8ubGVuZ3RoKXtjb25zdCBUPW8ucmVkdWNlKChQLEMpPT5bLi4uUCwuLi5DXSk7cmV0dXJuIHYoKShUKX1yZXR1cm5bWzAsMF0sWzAsMF1dfWdldCBib3VuZGluZ0NlbnRlcigpe2NvbnN0IG89dGhpcy5ib3VuZGluZ0JveDtyZXR1cm4gbz9bLjUqKG9bMF1bMF0rb1sxXVswXSksLjUqKG9bMF1bMV0rb1sxXVsxXSldOlswLDBdfW5vcm1hbGl6ZShvPTAsVD0wKXtjb25zdCBQPU9iamVjdCh1LmRlZmF1bHQpKGwoKSh0aGlzW09dKSkubWFwKChbQywuLi5JXSk9Pntjb25zdCBBPVtDXTtmb3IobGV0IEw9MDtMPEkubGVuZ3RoO0wrPTIpe2NvbnN0IEQ9SVtMXS1vLFI9SVtMKzFdLVQ7QS5wdXNoKEQsUil9cmV0dXJuIEF9KTtyZXR1cm4gdGhpcy5iZWdpblBhdGgoKSx0aGlzW09dLnB1c2goLi4uUCksdGhpc31nZXRQb2ludEF0TGVuZ3RoKG8pe3JldHVybiB0aGlzLmNvbnRvdXJzP09iamVjdCh5LmdldFBvaW50QXRMZW5ndGgpKHRoaXNbYl0sbyk6bnVsbH1nZXRUb3RhbExlbmd0aCgpe3JldHVybiB0aGlzLmNvbnRvdXJzP09iamVjdCh5LmdldFRvdGFsTGVuZ3RoKSh0aGlzW2JdKTowfWFkZFBhdGgobyl7dGhpc1tiXT1udWxsLHR5cGVvZiBvPT0ic3RyaW5nIiYmKG89cygpKG8pKSx0aGlzW09dLnB1c2goLi4ubyl9YmVnaW5QYXRoKCl7dGhpc1tPXT1bXSx0aGlzW2JdPW51bGx9Y2xlYXIoKXt0aGlzLmJlZ2luUGF0aCgpfWVsbGlwc2UobyxULFAsQyxJLEEsTCxEPTApe2lmKEErPUksTCs9SSxQPD0wfHxDPD0wfHxMPT09QSlyZXR1cm47TDxBJiYoTD1BK24rKEwtQSklbiksTC1BPm4mJihMPUErbik7Y29uc3QgUj1MLUE7Uj49biYmKEwtPS4wMDEpO2xldCBTPXRoaXNbT10ubGVuZ3RoPjAmJlI8bj8iTCI6Ik0iO2NvbnN0IEI9T2JqZWN0KHguZ2V0UG9pbnQpKG8sVCxQLEMsQSksdz1PYmplY3QoeC5nZXRQb2ludCkobyxULFAsQyxMKSxIPSshRDtsZXQgSj1SPk1hdGguUEk/MTowO0QmJihKPTEtSiksUys9Qi5qb2luKCIgIiksUys9YEEke1B9ICR7Q30gMCAke0p9ICR7SH0gJHt3LmpvaW4oIiAiKX1gLFI+PW4mJihTKz0iWiIpLHRoaXMuYWRkUGF0aChTKX1hcmMobyxULFAsQyxJLEE9MCl7cmV0dXJuIHRoaXMuZWxsaXBzZShvLFQsUCxQLDAsQyxJLEEpfWFyY1RvKG8sVCxQLEMsSSxBLEwpe3RoaXNbYl09bnVsbCx0aGlzW09dLnB1c2goWyJBIixvLFQsUCxDLEksQSxMXSl9bW92ZVRvKG8sVCl7dGhpc1tiXT1udWxsLHRoaXNbT10ucHVzaChbIk0iLG8sVF0pfWxpbmVUbyhvLFQpe3RoaXNbYl09bnVsbCx0aGlzW09dLnB1c2goWyJMIixvLFRdKX1iZXppZXJDdXJ2ZVRvKG8sVCxQLEMsSSxBKXt0aGlzW2JdPW51bGwsdGhpc1tPXS5wdXNoKFsiQyIsbyxULFAsQyxJLEFdKX1xdWFkcmF0aWNDdXJ2ZVRvKG8sVCxQLEMpe3RoaXNbYl09bnVsbCx0aGlzW09dLnB1c2goWyJRIixvLFQsUCxDXSl9cmVjdChvLFQsUCxDKXtjb25zdCBJPWBNJHtvfSAke1R9TCR7bytQfSAke1R9TCR7bytQfSAke1QrQ31MJHtvfSAke1QrQ31aYDt0aGlzLmFkZFBhdGgoSSl9Y2xvc2VQYXRoKCl7dGhpc1tiXT1udWxsO2xldCBvPVtdO2NvbnN0IFQ9dGhpc1tPXS5sZW5ndGg7VD4wJiYobz10aGlzW09dW1QtMV0pLG9bMF0hPT0iWiImJm9bMF0hPT0ieiImJnRoaXNbT10ucHVzaChbIloiXSl9fX0sZnVuY3Rpb24oYyxlKXtjLmV4cG9ydHM9czt2YXIgdD17YTo3LGM6NixoOjEsbDoyLG06MixxOjQsczo0LHQ6Mix2OjEsejowfSxyPS8oW2FzdHZ6cW1obGNdKShbXmFzdHZ6cW1obGNdKikvaWc7ZnVuY3Rpb24gcyhoKXt2YXIgbD1bXTtyZXR1cm4gaC5yZXBsYWNlKHIsZnVuY3Rpb24odSxNLGYpe3ZhciB5PU0udG9Mb3dlckNhc2UoKTtmb3IoZj12KGYpLHk9PSJtIiYmZi5sZW5ndGg+MiYmKGwucHVzaChbTV0uY29uY2F0KGYuc3BsaWNlKDAsMikpKSx5PSJsIixNPU09PSJtIj8ibCI6IkwiKTs7KXtpZihmLmxlbmd0aD09dFt5XSlyZXR1cm4gZi51bnNoaWZ0KE0pLGwucHVzaChmKTtpZihmLmxlbmd0aDx0W3ldKXRocm93IG5ldyBFcnJvcigibWFsZm9ybWVkIHBhdGggZGF0YSIpO2wucHVzaChbTV0uY29uY2F0KGYuc3BsaWNlKDAsdFt5XSkpKX19KSxsfXZhciBnPS8tP1swLTldKlwuP1swLTldKyg/OmVbLStdP1xkKyk/L2lnO2Z1bmN0aW9uIHYoaCl7dmFyIGw9aC5tYXRjaChnKTtyZXR1cm4gbD9sLm1hcChOdW1iZXIpOltdfX0sZnVuY3Rpb24oYyxlLHQpe2MuZXhwb3J0cz1yO2Z1bmN0aW9uIHIocyl7dmFyIGc9cy5sZW5ndGg7aWYoZz09PTApcmV0dXJuW1tdLFtdXTtmb3IodmFyIHY9c1swXS5sZW5ndGgsaD1zWzBdLnNsaWNlKCksbD1zWzBdLnNsaWNlKCksdT0xO3U8ZzsrK3UpZm9yKHZhciBNPXNbdV0sZj0wO2Y8djsrK2Ype3ZhciB5PU1bZl07aFtmXT1NYXRoLm1pbihoW2ZdLHkpLGxbZl09TWF0aC5tYXgobFtmXSx5KX1yZXR1cm5baCxsXX19LGZ1bmN0aW9uKGMsZSl7Yy5leHBvcnRzPXQ7ZnVuY3Rpb24gdChyKXt2YXIgcz0wLGc9MCx2PTAsaD0wO3JldHVybiByLm1hcChmdW5jdGlvbihsKXtsPWwuc2xpY2UoKTt2YXIgdT1sWzBdLE09dS50b1VwcGVyQ2FzZSgpO2lmKHUhPU0pc3dpdGNoKGxbMF09TSx1KXtjYXNlImEiOmxbNl0rPXYsbFs3XSs9aDticmVhaztjYXNlInYiOmxbMV0rPWg7YnJlYWs7Y2FzZSJoIjpsWzFdKz12O2JyZWFrO2RlZmF1bHQ6Zm9yKHZhciBmPTE7ZjxsLmxlbmd0aDspbFtmKytdKz12LGxbZisrXSs9aH1zd2l0Y2goTSl7Y2FzZSJaIjp2PXMsaD1nO2JyZWFrO2Nhc2UiSCI6dj1sWzFdO2JyZWFrO2Nhc2UiViI6aD1sWzFdO2JyZWFrO2Nhc2UiTSI6dj1zPWxbMV0saD1nPWxbMl07YnJlYWs7ZGVmYXVsdDp2PWxbbC5sZW5ndGgtMl0saD1sW2wubGVuZ3RoLTFdfXJldHVybiBsfSl9fSxmdW5jdGlvbihjLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBzfSk7dmFyIHI9dCg0NSk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIHMoaCl7Zm9yKHZhciBsLHU9W10sTT0wLGY9MCx5PTAseD0wLGI9bnVsbCxPPW51bGwsbT0wLHA9MCxuPTAsYT1oLmxlbmd0aDtuPGE7bisrKXt2YXIgaT1oW25dLG89aVswXTtzd2l0Y2gobyl7Y2FzZSJNIjp5PWlbMV0seD1pWzJdO2JyZWFrO2Nhc2UiQSI6dmFyIFQ9T2JqZWN0KHIuZGVmYXVsdCkobSxwLGlbNl0saVs3XSxpWzRdLGlbNV0saVsxXSxpWzJdLGlbM10pO2lmKCFULmxlbmd0aCljb250aW51ZTtUPVQubWFwKEw9Pntjb25zdFtELFIsUyxCLHcsSCxKLHFdPUw7cmV0dXJue3gxOlMseTE6Qix4Mjp3LHkyOkgseDpKLHk6cX19KTtmb3IodmFyIFA9MCxDO1A8VC5sZW5ndGg7UCsrKUM9VFtQXSxpPVsiQyIsQy54MSxDLnkxLEMueDIsQy55MixDLngsQy55XSxQPFQubGVuZ3RoLTEmJnUucHVzaChpKTticmVhaztjYXNlIlMiOnZhciBJPW0sQT1wOyhsPT0iQyJ8fGw9PSJTIikmJihJKz1JLU0sQSs9QS1mKSxpPVsiQyIsSSxBLGlbMV0saVsyXSxpWzNdLGlbNF1dO2JyZWFrO2Nhc2UiVCI6bD09IlEifHxsPT0iVCI/KGI9bSoyLWIsTz1wKjItTyk6KGI9bSxPPXApLGk9dihtLHAsYixPLGlbMV0saVsyXSk7YnJlYWs7Y2FzZSJRIjpiPWlbMV0sTz1pWzJdLGk9dihtLHAsaVsxXSxpWzJdLGlbM10saVs0XSk7YnJlYWs7Y2FzZSJMIjppPWcobSxwLGlbMV0saVsyXSk7YnJlYWs7Y2FzZSJIIjppPWcobSxwLGlbMV0scCk7YnJlYWs7Y2FzZSJWIjppPWcobSxwLG0saVsxXSk7YnJlYWs7Y2FzZSJaIjppPWcobSxwLHkseCk7YnJlYWt9bD1vLG09aVtpLmxlbmd0aC0yXSxwPWlbaS5sZW5ndGgtMV0saS5sZW5ndGg+ND8oTT1pW2kubGVuZ3RoLTRdLGY9aVtpLmxlbmd0aC0zXSk6KE09bSxmPXApLHUucHVzaChpKX1yZXR1cm4gdX1mdW5jdGlvbiBnKGgsbCx1LE0pe3JldHVyblsiQyIsaCxsLHUsTSx1LE1dfWZ1bmN0aW9uIHYoaCxsLHUsTSxmLHkpe3JldHVyblsiQyIsaC8zKzIvMyp1LGwvMysyLzMqTSxmLzMrMi8zKnUseS8zKzIvMypNLGYseV19fSxmdW5jdGlvbihjLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBofSksdCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IHI9TWF0aC5QSSoyO2Z1bmN0aW9uIHMobCx1LE0sZil7Y29uc3QgeT1sKmYtdSpNPDA/LTE6MTtsZXQgeD1sKk0rdSpmO3JldHVybiB4PjEmJih4PTEpLHg8LTEmJih4PS0xKSx5Kk1hdGguYWNvcyh4KX1mdW5jdGlvbiBnKGwsdSxNLGYseSx4LGIsTyxtLHApe2NvbnN0IG49cCoobC1NKS8yK20qKHUtZikvMixhPS1tKihsLU0pLzIrcCoodS1mKS8yLGk9YipiLG89TypPLFQ9bipuLFA9YSphO2xldCBDPWkqby1pKlAtbypUO0M8MCYmKEM9MCksQy89aSpQK28qVCxDPU1hdGguc3FydChDKSooeT09PXg/LTE6MSk7Y29uc3QgST1DKmIvTyphLEE9QyotTy9iKm4sTD1wKkktbSpBKyhsK00pLzIsRD1tKkkrcCpBKyh1K2YpLzIsUj0obi1JKS9iLFM9KGEtQSkvTyxCPSgtbi1JKS9iLHc9KC1hLUEpL08sSD1zKDEsMCxSLFMpO2xldCBKPXMoUixTLEIsdyk7cmV0dXJuIHg9PT0wJiZKPjAmJihKLT1yKSx4PT09MSYmSjwwJiYoSis9ciksW0wsRCxILEpdfWZ1bmN0aW9uIHYobCx1KXtjb25zdCBNPTEuMzMzMzMzMzMzMzMzMzMzMypNYXRoLnRhbih1LzQpLGY9TWF0aC5jb3MobCkseT1NYXRoLnNpbihsKSx4PU1hdGguY29zKGwrdSksYj1NYXRoLnNpbihsK3UpO3JldHVybltmLHksZi15Kk0seStmKk0seCtiKk0sYi14Kk0seCxiXX1mdW5jdGlvbiBoKGwsdSxNLGYseSx4LGIsTyxtKXtjb25zdCBwPU1hdGguc2luKG0qci8zNjApLG49TWF0aC5jb3MobSpyLzM2MCksYT1uKihsLU0pLzIrcCoodS1mKS8yLGk9LXAqKGwtTSkvMituKih1LWYpLzI7aWYoYT09PTAmJmk9PT0wKXJldHVybltdO2lmKGI9PT0wfHxPPT09MClyZXR1cm5bXTtiPU1hdGguYWJzKGIpLE89TWF0aC5hYnMoTyk7Y29uc3Qgbz1hKmEvKGIqYikraSppLyhPKk8pO28+MSYmKGIqPU1hdGguc3FydChvKSxPKj1NYXRoLnNxcnQobykpO2NvbnN0IFQ9ZyhsLHUsTSxmLHkseCxiLE8scCxuKSxQPVtdO2xldCBDPVRbMl0sST1UWzNdO2NvbnN0IEE9TWF0aC5tYXgoTWF0aC5jZWlsKE1hdGguYWJzKEkpLyhyLzQpKSwxKTtJLz1BO2ZvcihsZXQgTD0wO0w8QTtMKyspUC5wdXNoKHYoQyxJKSksQys9STtyZXR1cm4gUC5tYXAoTD0+e2ZvcihsZXQgRD0wO0Q8TC5sZW5ndGg7RCs9Mil7bGV0IFI9TFtEKzBdLFM9TFtEKzFdO1IqPWIsUyo9Tztjb25zdCBCPW4qUi1wKlMsdz1wKlIrbipTO0xbRCswXT1CK1RbMF0sTFtEKzFdPXcrVFsxXX1yZXR1cm4gTH0pfX0sZnVuY3Rpb24oYyxlLHQpe3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTt2YXIgcj10KDQ3KSx7Y29weTpzfT10KDQ5KSxnPXQoNTApO2Z1bmN0aW9uIHYoZix5LHgpe3JldHVybiBmWzBdPXksZlsxXT14LGZ9dmFyIGg9WzAsMF0sbD1bMCwwXSx1PVswLDBdO2Z1bmN0aW9uIE0oZix5LHgsYil7cih4LHYoaCxiWzFdLGJbMl0pLHYobCxiWzNdLGJbNF0pLHYodSxiWzVdLGJbNl0pLHksZil9Yy5leHBvcnRzPWZ1bmN0aW9uKHkseCxiKXt2YXIgTz1bXSxtPVtdLHA9WzAsMF07cmV0dXJuIHkuZm9yRWFjaChmdW5jdGlvbihuLGEsaSl7aWYoblswXT09PSJNIilzKHAsbi5zbGljZSgxKSksbS5sZW5ndGg+MCYmKE8ucHVzaChtKSxtPVtdKTtlbHNlIGlmKG5bMF09PT0iQyIpTShtLHgscCxuKSx2KHAsbls1XSxuWzZdKTtlbHNlIHRocm93IG5ldyBFcnJvcigiaWxsZWdhbCB0eXBlIGluIFNWRzogIituWzBdKX0pLG0ubGVuZ3RoPjAmJk8ucHVzaChtKSxPLm1hcChmdW5jdGlvbihuKXtyZXR1cm4gZyhuLGJ8fDApfSl9fSxmdW5jdGlvbihjLGUsdCl7Yy5leHBvcnRzPXQoNDgpKCl9LGZ1bmN0aW9uKGMsZSl7ZnVuY3Rpb24gdChzKXtyZXR1cm5bc1swXSxzWzFdXX1mdW5jdGlvbiByKHMsZyl7cmV0dXJuW3MsZ119Yy5leHBvcnRzPWZ1bmN0aW9uKGcpe2c9Z3x8e307dmFyIHY9dHlwZW9mIGcucmVjdXJzaW9uPT0ibnVtYmVyIj9nLnJlY3Vyc2lvbjo4LGg9dHlwZW9mIGcuZXBzaWxvbj09Im51bWJlciI/Zy5lcHNpbG9uOjExOTIwOTI5ZS0xNCxsPXR5cGVvZiBnLnBhdGhFcHNpbG9uPT0ibnVtYmVyIj9nLnBhdGhFcHNpbG9uOjEsdT10eXBlb2YgZy5hbmdsZUVwc2lsb249PSJudW1iZXIiP2cuYW5nbGVFcHNpbG9uOi4wMSxNPWcuYW5nbGVUb2xlcmFuY2V8fDAsZj1nLmN1c3BMaW1pdHx8MDtyZXR1cm4gZnVuY3Rpb24oTyxtLHAsbixhLGkpe2l8fChpPVtdKSxhPXR5cGVvZiBhPT0ibnVtYmVyIj9hOjE7dmFyIG89bC9hO3JldHVybiBvKj1vLHkoTyxtLHAsbixpLG8pLGl9O2Z1bmN0aW9uIHkoYixPLG0scCxuLGEpe24ucHVzaCh0KGIpKTt2YXIgaT1iWzBdLG89YlsxXSxUPU9bMF0sUD1PWzFdLEM9bVswXSxJPW1bMV0sQT1wWzBdLEw9cFsxXTt4KGksbyxULFAsQyxJLEEsTCxuLGEsMCksbi5wdXNoKHQocCkpfWZ1bmN0aW9uIHgoYixPLG0scCxuLGEsaSxvLFQsUCxDKXtpZighKEM+dikpe3ZhciBJPU1hdGguUEksQT0oYittKS8yLEw9KE8rcCkvMixEPShtK24pLzIsUj0ocCthKS8yLFM9KG4raSkvMixCPShhK28pLzIsdz0oQStEKS8yLEg9KEwrUikvMixKPShEK1MpLzIscT0oUitCKS8yLFc9KHcrSikvMixHPShIK3EpLzI7aWYoQz4wKXt2YXIgUT1pLWIsdHQ9by1PLF89TWF0aC5hYnMoKG0taSkqdHQtKHAtbykqUSksc3Q9TWF0aC5hYnMoKG4taSkqdHQtKGEtbykqUSksayxjdDtpZihfPmgmJnN0Pmgpe2lmKChfK3N0KSooXytzdCk8PVAqKFEqUSt0dCp0dCkpe2lmKE08dSl7VC5wdXNoKHIoVyxHKSk7cmV0dXJufXZhciBmdD1NYXRoLmF0YW4yKGEtcCxuLW0pO2lmKGs9TWF0aC5hYnMoZnQtTWF0aC5hdGFuMihwLU8sbS1iKSksY3Q9TWF0aC5hYnMoTWF0aC5hdGFuMihvLWEsaS1uKS1mdCksaz49SSYmKGs9MipJLWspLGN0Pj1JJiYoY3Q9MipJLWN0KSxrK2N0PE0pe1QucHVzaChyKFcsRykpO3JldHVybn1pZihmIT09MCl7aWYoaz5mKXtULnB1c2gocihtLHApKTtyZXR1cm59aWYoY3Q+Zil7VC5wdXNoKHIobixhKSk7cmV0dXJufX19fWVsc2UgaWYoXz5oKXtpZihfKl88PVAqKFEqUSt0dCp0dCkpe2lmKE08dSl7VC5wdXNoKHIoVyxHKSk7cmV0dXJufWlmKGs9TWF0aC5hYnMoTWF0aC5hdGFuMihhLXAsbi1tKS1NYXRoLmF0YW4yKHAtTyxtLWIpKSxrPj1JJiYoaz0yKkktayksazxNKXtULnB1c2gocihtLHApKSxULnB1c2gocihuLGEpKTtyZXR1cm59aWYoZiE9PTAmJms+Zil7VC5wdXNoKHIobSxwKSk7cmV0dXJufX19ZWxzZSBpZihzdD5oKXtpZihzdCpzdDw9UCooUSpRK3R0KnR0KSl7aWYoTTx1KXtULnB1c2gocihXLEcpKTtyZXR1cm59aWYoaz1NYXRoLmFicyhNYXRoLmF0YW4yKG8tYSxpLW4pLU1hdGguYXRhbjIoYS1wLG4tbSkpLGs+PUkmJihrPTIqSS1rKSxrPE0pe1QucHVzaChyKG0scCkpLFQucHVzaChyKG4sYSkpO3JldHVybn1pZihmIT09MCYmaz5mKXtULnB1c2gocihuLGEpKTtyZXR1cm59fX1lbHNlIGlmKFE9Vy0oYitpKS8yLHR0PUctKE8rbykvMixRKlErdHQqdHQ8PVApe1QucHVzaChyKFcsRykpO3JldHVybn19eChiLE8sQSxMLHcsSCxXLEcsVCxQLEMrMSkseChXLEcsSixxLFMsQixpLG8sVCxQLEMrMSl9fX19LGZ1bmN0aW9uKGMsZSx0KXt0LnIoZSksdC5kKGUsImNyZWF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gZ30pLHQuZChlLCJjbG9uZSIsZnVuY3Rpb24oKXtyZXR1cm4gc30pLHQuZChlLCJjb3B5IixmdW5jdGlvbigpe3JldHVybiB2fSksdC5kKGUsInNjYWxlQW5kQWRkIixmdW5jdGlvbigpe3JldHVybiBofSksdC5kKGUsImRvdCIsZnVuY3Rpb24oKXtyZXR1cm4gbH0pLHQuZChlLCJyb3RhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIHV9KSx0LmQoZSwiY3Jvc3MiLGZ1bmN0aW9uKCl7cmV0dXJuIE19KSx0LmQoZSwic3ViIixmdW5jdGlvbigpe3JldHVybiBmfSksdC5kKGUsImFkZCIsZnVuY3Rpb24oKXtyZXR1cm4geX0pLHQuZChlLCJjb21wdXRlTWl0ZXIiLGZ1bmN0aW9uKCl7cmV0dXJuIG19KSx0LmQoZSwibm9ybWFsIixmdW5jdGlvbigpe3JldHVybiBwfSksdC5kKGUsImRpcmVjdGlvbiIsZnVuY3Rpb24oKXtyZXR1cm4gbn0pO3ZhciByPXQoMSk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIHMoYSl7cmV0dXJuW2FbMF0sYVsxXV19ZnVuY3Rpb24gZygpe3JldHVyblswLDBdfWNvbnN0IHY9ci52ZWMyLmNvcHksaD1yLnZlYzIuc2NhbGVBbmRBZGQsbD1yLnZlYzIuZG90LHU9ci52ZWMyLnJvdGF0ZSxNPXIudmVjMi5jcm9zcyxmPXIudmVjMi5zdWIseT1yLnZlYzIuYWRkLHg9ci52ZWMyLm5vcm1hbGl6ZSxiPXIudmVjMi5zZXQsTz1nKCk7ZnVuY3Rpb24gbShhLGksbyxULFApe3koYSxvLFQpLHgoYSxhKSxiKGksLWFbMV0sYVswXSksYihPLC1vWzFdLG9bMF0pO2NvbnN0IEM9UC9sKGksTyk7cmV0dXJuIE1hdGguYWJzKEMpfWZ1bmN0aW9uIHAoYSxpKXtyZXR1cm4gYihhLC1pWzFdLGlbMF0pLGF9ZnVuY3Rpb24gbihhLGksbyl7cmV0dXJuIGYoYSxpLG8pLHgoYSxhKSxhfX0sZnVuY3Rpb24oYyxlLHQpe3ZhciByPXQoNTEpLHM9dCg1Mik7Yy5leHBvcnRzPWZ1bmN0aW9uKHYsaCl7cmV0dXJuIHY9cih2LGgpLHY9cyh2LGgpLHZ9LGMuZXhwb3J0cy5yYWRpYWxEaXN0YW5jZT1yLGMuZXhwb3J0cy5kb3VnbGFzUGV1Y2tlcj1zfSxmdW5jdGlvbihjLGUpe2Z1bmN0aW9uIHQocixzKXt2YXIgZz1yWzBdLXNbMF0sdj1yWzFdLXNbMV07cmV0dXJuIGcqZyt2KnZ9Yy5leHBvcnRzPWZ1bmN0aW9uKHMsZyl7aWYocy5sZW5ndGg8PTEpcmV0dXJuIHM7Zz10eXBlb2YgZz09Im51bWJlciI/ZzoxO2Zvcih2YXIgdj1nKmcsaD1zWzBdLGw9W2hdLHUsTT0xLGY9cy5sZW5ndGg7TTxmO00rKyl1PXNbTV0sdCh1LGgpPnYmJihsLnB1c2godSksaD11KTtyZXR1cm4gaCE9PXUmJmwucHVzaCh1KSxsfX0sZnVuY3Rpb24oYyxlKXtmdW5jdGlvbiB0KHMsZyx2KXt2YXIgaD1nWzBdLGw9Z1sxXSx1PXZbMF0taCxNPXZbMV0tbDtpZih1IT09MHx8TSE9PTApe3ZhciBmPSgoc1swXS1oKSp1KyhzWzFdLWwpKk0pLyh1KnUrTSpNKTtmPjE/KGg9dlswXSxsPXZbMV0pOmY+MCYmKGgrPXUqZixsKz1NKmYpfXJldHVybiB1PXNbMF0taCxNPXNbMV0tbCx1KnUrTSpNfWZ1bmN0aW9uIHIocyxnLHYsaCxsKXtmb3IodmFyIHU9aCxNLGY9ZysxO2Y8djtmKyspe3ZhciB5PXQoc1tmXSxzW2ddLHNbdl0pO3k+dSYmKE09Zix1PXkpfXU+aCYmKE0tZz4xJiZyKHMsZyxNLGgsbCksbC5wdXNoKHNbTV0pLHYtTT4xJiZyKHMsTSx2LGgsbCkpfWMuZXhwb3J0cz1mdW5jdGlvbihnLHYpe2lmKGcubGVuZ3RoPD0xKXJldHVybiBnO3Y9dHlwZW9mIHY9PSJudW1iZXIiP3Y6MTt2YXIgaD12KnYsbD1nLmxlbmd0aC0xLHU9W2dbMF1dO3JldHVybiByKGcsMCxsLGgsdSksdS5wdXNoKGdbbF0pLHV9fSxmdW5jdGlvbihjLGUsdCl7dC5yKGUpLHQuZChlLCJnZXRUb3RhbExlbmd0aCIsZnVuY3Rpb24oKXtyZXR1cm4gc30pLHQuZChlLCJnZXRQb2ludEF0TGVuZ3RoIixmdW5jdGlvbigpe3JldHVybiB2fSksdC5kKGUsImdldERhc2hDb250b3VycyIsZnVuY3Rpb24oKXtyZXR1cm4gaH0pO3ZhciByPXQoNTQpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBzKGwpe2lmKGwudG90YWxMZW5ndGghPW51bGwpcmV0dXJuIGwudG90YWxMZW5ndGg7bGV0IHU9MDtyZXR1cm4gbC5mb3JFYWNoKE09PntsZXQgZj1NWzBdO2ZvcihsZXQgeT0xO3k8TS5sZW5ndGg7eSsrKXtjb25zdCB4PU1beV07dSs9T2JqZWN0KHIuZGlzdGFuY2UpKGYseCksZj14fX0pLGwudG90YWxMZW5ndGg9dSx1fWZ1bmN0aW9uIGcobCx1LE09ITApe2lmKHU9TnVtYmVyKHUpLCFOdW1iZXIuaXNGaW5pdGUodSkpdGhyb3cgbmV3IFR5cGVFcnJvcigiRmFpbGVkIHRvIGV4ZWN1dGUgJ2dldFBvaW50QXRMZW5ndGgnIG9uIGZpZ3VyZTogVGhlIHByb3ZpZGVkIGZsb2F0IHZhbHVlIGlzIG5vbi1maW5pdGUuIik7aWYodTw9MCl0aHJvdyBuZXcgVHlwZUVycm9yKCJMZW5ndGggbXVzdCA+IDAiKTtjb25zdCBmPXMobCk7aWYodT49Zil7Y29uc3QgeD1sW2wubGVuZ3RoLTFdLGI9eFt4Lmxlbmd0aC0yXSxPPXhbeC5sZW5ndGgtMV0sbT1NYXRoLmF0YW4yKE9bMV0tYlsxXSxPWzBdLWJbMF0pO3JldHVybntjdXJyZW50OmwubWFwKHA9PlsuLi5wXSkscG9pbnQ6e3g6T1swXSx5Ok9bMV0sYW5nbGU6bX19fWNvbnN0IHk9W107Zm9yKGxldCB4PTA7eDxsLmxlbmd0aDt4Kyspe3lbeF09W107Y29uc3QgYj1sW3hdO2xldCBPPWJbMF07Zm9yKGxldCBtPTE7bTxiLmxlbmd0aDttKyspe2NvbnN0IHA9YlttXSxuPU9iamVjdChyLmRpc3RhbmNlKShPLHApO2lmKHU8bil7Y29uc3QgYT11L24saT1NYXRoLmF0YW4yKHBbMV0tT1sxXSxwWzBdLU9bMF0pLG89e3g6T1swXSooMS1hKStwWzBdKmEseTpPWzFdKigxLWEpK3BbMV0qYSxhbmdsZTppfTtpZih5W3hdLnB1c2goTyksdT4wJiZ5W3hdLnB1c2goW28ueCxvLnldKSwhTSlyZXR1cm57Y3VycmVudDp5LHBvaW50Om99O2NvbnN0IFQ9W10sUD14O2Zvcig7eDxsLmxlbmd0aDt4Kyspe2ZvcihUW3gtUF09W10seD09PVAmJlRbMF0ucHVzaChbby54LG8ueV0pO208Yi5sZW5ndGg7bSsrKVRbeC1QXS5wdXNoKGJbbV0pO209MH1yZXR1cm57Y3VycmVudDp5LHBvaW50Om8scmVzdDpUfX11LT1uLHlbeF0ucHVzaChPKSxPPXB9fX1mdW5jdGlvbiB2KGwsdSl7aWYodT1OdW1iZXIodSksIU51bWJlci5pc0Zpbml0ZSh1KSl0aHJvdyBuZXcgVHlwZUVycm9yKCJGYWlsZWQgdG8gZXhlY3V0ZSAnZ2V0UG9pbnRBdExlbmd0aCcgb24gZmlndXJlOiBUaGUgcHJvdmlkZWQgZmxvYXQgdmFsdWUgaXMgbm9uLWZpbml0ZS4iKTtpZihsLmxlbmd0aDw9MClyZXR1cm57eDowLHk6MCxhbmdsZTowfTtpZih1PD0wKXtjb25zdCBNPWxbMF1bMF0sZj1sWzBdWzFdLHk9TWF0aC5hdGFuMihmWzFdLU1bMV0sZlswXS1NWzBdKTtyZXR1cm57eDpNWzBdLHk6TVsxXSxhbmdsZTp5fX1yZXR1cm4gZyhsLHUsITEpLnBvaW50fWZ1bmN0aW9uIGgobCx1LE0pe2xldCBmPTAseT11WzBdLHg9bDtjb25zdCBiPVtdLE89dS5sZW5ndGg7aWYoTT4wKXtkbyBNLT11W2YlT10sZisrO3doaWxlKE0+MCk7TTwwJiYoeT0tTSxmLS0pfWVsc2UgaWYoTTwwKXtmPS0xO2RvIE0rPXVbZiVPK08tMV0sZi0tO3doaWxlKE08MCk7TT49MCYmKGYrKyx5PXVbZiVPK08tMV0tTSl9ZG97Y29uc3QgbT1nKHgseSk7eD1tLnJlc3QsKytmJTImJmIucHVzaCguLi5tLmN1cnJlbnQpO2xldCBwPWYlTztwPDAmJihwKz1PKSx5PXVbcF19d2hpbGUoeCk7cmV0dXJuIGJ9fSxmdW5jdGlvbihjLGUsdCl7dC5yKGUpLHQuZChlLCJub3JtYWxpemUiLGZ1bmN0aW9uKCl7cmV0dXJuIHJ9KSx0LmQoZSwiZGlzdGFuY2UiLGZ1bmN0aW9uKCl7cmV0dXJuIHN9KSx0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gcihbZyx2LGhdLGwsdSxNKXtyZXR1cm4gZz1nKjIvbC0xLHY9MS12KjIvdSxOdW1iZXIuaXNGaW5pdGUoTSk/KGg9aCoyL00tMSxbZyx2LGhdKTpbZyx2XX1mdW5jdGlvbiBzKFtnLHYsaD0wXSxbbCx1LE09MF0pe3JldHVybiBNYXRoLmh5cG90KGwtZyx1LXYsTS1oKX19LGZ1bmN0aW9uKGMsZSx0KXt0LnIoZSksdC5kKGUsImdldFBvaW50IixmdW5jdGlvbigpe3JldHVybiBzfSksdCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IHI9TWF0aC5QSSoyO2Z1bmN0aW9uIHMoZyx2LGgsbCx1KXt1JT1yLHU8MCYmKHUrPXIpO2NvbnN0IE09TWF0aC50YW4odSk7aWYoTWF0aC5hYnMoTSk8MWU1KXtjb25zdCBmPXYtTSpnLHk9MS9oKioyK00qKjIvbCoqMjtsZXQgeD0tMTsodTw9TWF0aC5QSS8yfHx1PjMqTWF0aC5QSS8yKSYmKHg9MSk7Y29uc3QgYj14Kk1hdGguc3FydCgxL3kpK2csTz1NKmIrZjtyZXR1cm5bYixPXX1yZXR1cm4gdTxNYXRoLlBJP1tnLHYrbF06W2csdi1sXX19LGZ1bmN0aW9uKGMsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIFZ9KTt2YXIgcj10KDEpLHM9dCg0MiksZz10Lm4ocyksdj10KDU3KSxoPXQoMjgpLGw9dCgyNCksdT10KDMwKSxNPXQoNTkpLGY9dCg1MykseT10KDYwKSx4PXQubih5KSxiPXQoNDYpLE89dC5uKGIpLG09dCgzMSkscD10KDQwKSxuPXQoMjEpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBhKFgsail7aWYoWD09bnVsbClyZXR1cm57fTt2YXIgej1pKFgsaiksZCxFO2lmKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpe3ZhciBOPU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoWCk7Zm9yKEU9MDtFPE4ubGVuZ3RoO0UrKylkPU5bRV0sIShqLmluZGV4T2YoZCk+PTApJiZPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoWCxkKSYmKHpbZF09WFtkXSl9cmV0dXJuIHp9ZnVuY3Rpb24gaShYLGope2lmKFg9PW51bGwpcmV0dXJue307dmFyIHo9e30sZD1PYmplY3Qua2V5cyhYKSxFLE47Zm9yKE49MDtOPGQubGVuZ3RoO04rKylFPWRbTl0sIShqLmluZGV4T2YoRSk+PTApJiYoeltFXT1YW0VdKTtyZXR1cm4gen1jb25zdCBvPVN5bWJvbCgibWVzaCIpLFQ9U3ltYm9sKCJjb250b3VycyIpLFA9U3ltYm9sKCJzdHJva2UiKSxDPVN5bWJvbCgiZmlsbCIpLEk9U3ltYm9sKCJzdHJva2VDb2xvciIpLEE9U3ltYm9sKCJmaWxsQ29sb3IiKSxMPVN5bWJvbCgidHJhbnNmb3JtIiksRD1TeW1ib2woImludmVydFRyYW5zZm9ybSIpLFI9U3ltYm9sKCJ1bmlmb3JtcyIpLFM9U3ltYm9sKCJ0ZXhPcHRpb25zIiksQj1TeW1ib2woImJsZW5kIiksdz1TeW1ib2woImFwcGx5VGV4dHVyZSIpLEg9U3ltYm9sKCJhcHBseVRyYW5zZm9ybSIpLEo9U3ltYm9sKCJhcHBseUdyYWRpZW50VHJhbnNmb3JtIikscT1TeW1ib2woImFwcGx5UHJvZ3JhbSIpLFc9U3ltYm9sKCJncmFkaWVudCIpLEc9U3ltYm9sKCJmaWx0ZXIiKSxRPVN5bWJvbCgib3BhY2l0eSIpLHR0PVN5bWJvbCgicHJvZ3JhbSIpLF89U3ltYm9sKCJhdHRyaWJ1dGVzIiksc3Q9U3ltYm9sKCJwYXNzIiksaz1TeW1ib2woImNsaXBDb250ZXh0IiksY3Q9U3ltYm9sKCJhcHBseUNsaXBQYXRoIik7ZnVuY3Rpb24gZnQoWCxqKXtjb25zdFt6LGRdPVtYWzFdWzBdLVhbMF1bMF0sWFsxXVsxXS1YWzBdWzFdXSxFPVtdO2ZvcihsZXQgTj0wO048ai5sZW5ndGg7TisrKXtjb25zdCAkPWpbTl0sSz1bKCRbMF0tWFswXVswXSkveiwxLSgkWzFdLVhbMF1bMV0pL2RdO0UucHVzaChLKX1yZXR1cm4gRX1mdW5jdGlvbiBVKFtYLGpdLFt6LGQsRSxOXSx7c2NhbGU6JH0pe3JldHVybiAkfHwoWC89RSxqPTEtai9OLFgtPXosais9ZCksW1gsaiwwXX1mdW5jdGlvbiBGKFgsaix6KXtjb25zdCBkPU8oKShYLGoseik7cmV0dXJuIGQucGF0aD1YLGQuc2ltcGxpZnk9eixkLnNjYWxlPWosZH1jbGFzcyBWe2NvbnN0cnVjdG9yKGope3RoaXNbUF09bnVsbCx0aGlzW0NdPW51bGwsdGhpc1tMXT1bMSwwLDAsMSwwLDBdLHRoaXNbUV09MSx0aGlzW1JdPXt9LHRoaXNbR109W10sdGhpc1tCXT1udWxsLHRoaXNbU109e30sdGhpcy5jb250b3Vycz1qLmNvbnRvdXJzLHRoaXNbdHRdPW51bGwsdGhpc1tfXT17fSx0aGlzW3N0XT1bXX1nZXQgY29udG91cnMoKXtyZXR1cm4gdGhpc1tUXX1zZXQgY29udG91cnMoail7dGhpc1tvXT1udWxsLHRoaXNbVF09ajtjb25zdCB6PWouc2NhbGU7dGhpcy50cmFuc2Zvcm1TY2FsZS96PjEuNSYmdGhpcy5hY2N1cmF0ZSh0aGlzLnRyYW5zZm9ybVNjYWxlKX1zZXRQcm9ncmFtKGope3RoaXNbdHRdPWosdGhpc1tvXSYmdGhpc1txXShqKX1nZXQgcHJvZ3JhbSgpe3JldHVybiB0aGlzW3R0XX1zZXRBdHRyaWJ1dGUoaix6KXt6PT1udWxsP2RlbGV0ZSB0aGlzW19dW2pdOnRoaXNbX11bal09en1nZXRPcGFjaXR5KCl7cmV0dXJuIHRoaXNbUV19c2V0T3BhY2l0eShqKXtpZihqPDB8fGo+MSl0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIG9wYWNpdHkgdmFsdWUuIik7dGhpc1tvXSYmdGhpc1tvXS5wb3NpdGlvbnMuZm9yRWFjaCh6PT57elsyXT0xL3pbMl0+MD9qOi1qfSksdGhpc1tRXT1qfXNldENsaXBQYXRoKGope3RoaXMuY2xpcFBhdGg9aix0aGlzW1JdLnVfY2xpcFNhbXBsZXImJnRoaXNbUl0udV9jbGlwU2FtcGxlci5kZWxldGUoKSx0aGlzLnNldFVuaWZvcm1zKHt1X2NsaXBTYW1wbGVyOm51bGx9KSx0aGlzW29dJiZkZWxldGUgdGhpc1tvXS5hdHRyaWJ1dGVzLmFfY2xpcFVWLGomJnRoaXNbb10mJnRoaXNbY3RdKCl9W2N0XSgpe2lmKHRoaXMuY2xpcFBhdGgpe3RoaXNba118fCh0aGlzW2tdPW4uZGVmYXVsdC5jcmVhdGVDYW52YXMoMSwxKSk7Y29uc3RbW2osel0sW2QsRV1dPXRoaXMuYm91bmRpbmdCb3g7ZCYmRSYmKHRoaXNba10ud2lkdGg9ZC1qLHRoaXNba10uaGVpZ2h0PUUteik7Y29uc3QgTj10aGlzW2tdLmdldENvbnRleHQoIjJkIiksJD1uZXcgUGF0aDJEKHRoaXMuY2xpcFBhdGgpO04uY2xlYXJSZWN0KDAsMCx0aGlzW2tdLndpZHRoLHRoaXNba10uaGVpZ2h0KSxOLnNhdmUoKSxOLnRyYW5zbGF0ZSgtaiwteiksTi5maWxsU3R5bGU9IndoaXRlIixOLmZpbGwoJCksTi5yZXN0b3JlKCksdGhpc1tvXS5jbGlwUGF0aD10aGlzW2tdO2NvbnN0IEs9ZnQodGhpcy5ib3VuZGluZ0JveCx0aGlzW29dLnBvc2l0aW9uMCk7dGhpc1tvXS5hdHRyaWJ1dGVzLmFfY2xpcFVWPUt9fWdldFBvaW50QXRMZW5ndGgoail7cmV0dXJuIE9iamVjdChmLmdldFBvaW50QXRMZW5ndGgpKHRoaXNbVF0sail9Z2V0VG90YWxMZW5ndGgoKXtyZXR1cm4gT2JqZWN0KGYuZ2V0VG90YWxMZW5ndGgpKHRoaXNbVF0pfWdldCBibGVuZCgpe3JldHVybiB0aGlzW0JdPT1udWxsPyJhdXRvIjp0aGlzW0JdfXNldCBibGVuZChqKXt0aGlzW0JdPWosdGhpc1tvXSYmKHRoaXNbb10uZW5hYmxlQmxlbmQ9dGhpcy5lbmFibGVCbGVuZCl9Z2V0IGJvdW5kaW5nQm94KCl7aWYodGhpc1tvXSYmdGhpc1tvXS5ib3VuZGluZ0JveClyZXR1cm4gdGhpc1tvXS5ib3VuZGluZ0JveDtjb25zdCBqPXRoaXMubWVzaERhdGE7aWYoail7Y29uc3Qgej1qLnBvc2l0aW9uMDtpZih6Lmxlbmd0aClqLmJvdW5kaW5nQm94PWcoKSh6KTtlbHNlIHJldHVybltbMCwwXSxbMCwwXV07cmV0dXJuIGouYm91bmRpbmdCb3h9cmV0dXJuW1swLDBdLFswLDBdXX1nZXQgYm91bmRpbmdDZW50ZXIoKXtjb25zdCBqPXRoaXMuYm91bmRpbmdCb3g7cmV0dXJuIGo/Wy41KihqWzBdWzBdK2pbMV1bMF0pLC41KihqWzBdWzFdK2pbMV1bMV0pXTpbMCwwXX1nZXQgZmlsbFJ1bGUoKXtyZXR1cm4gdGhpc1tDXT90aGlzW0NdLnJ1bGU6Im5vbnplcm8ifWdldCBsaW5lV2lkdGgoKXtyZXR1cm4gdGhpc1tQXT90aGlzW1BdLmxpbmVXaWR0aDowfWdldCBsaW5lQ2FwKCl7cmV0dXJuIHRoaXNbUF0/dGhpc1tQXS5saW5lQ2FwOiIifWdldCBsaW5lSm9pbigpe3JldHVybiB0aGlzW1BdP3RoaXNbUF0ubGluZUpvaW46IiJ9Z2V0IG1pdGVyTGltaXQoKXtyZXR1cm4gdGhpc1tQXT90aGlzW1BdLm1pdGVyTGltaXQ6MH1nZXQgc3Ryb2tlU3R5bGUoKXtyZXR1cm4gdGhpc1tJXSYmdGhpc1tJXVszXSE9PTA/T2JqZWN0KGwuZGVmYXVsdCkodGhpc1tJXSk6IiJ9Z2V0IGxpbmVEYXNoKCl7cmV0dXJuIHRoaXNbUF0/dGhpc1tQXS5saW5lRGFzaDpudWxsfWdldCBsaW5lRGFzaE9mZnNldCgpe3JldHVybiB0aGlzW1BdP3RoaXNbUF0ubGluZURhc2hPZmZzZXQ6MH1nZXQgZmlsbFN0eWxlKCl7cmV0dXJuIHRoaXNbQV0mJnRoaXNbQV1bM10hPT0wP09iamVjdChsLmRlZmF1bHQpKHRoaXNbQV0pOiIifWdldCBncmFkaWVudCgpe3JldHVybiB0aGlzW1ddfWdldCB0ZXh0dXJlKCl7cmV0dXJuIHRoaXNbUl0udV90ZXhTYW1wbGVyP3tpbWFnZTp0aGlzW1JdLnVfdGV4U2FtcGxlci5faW1nLG9wdGlvbnM6dGhpc1tTXX06bnVsbH1nZXQgZW5hYmxlQmxlbmQoKXtyZXR1cm4gdGhpc1tCXT09PSEwfHx0aGlzW0JdPT09ITE/dGhpc1tCXTp0aGlzW1FdPDF8fHRoaXNbSV0hPW51bGwmJnRoaXNbSV1bM108MXx8dGhpc1tBXSE9bnVsbCYmdGhpc1tBXVszXTwxfHx0aGlzW1JdLnVfY29sb3JNYXRyaXghPW51bGwmJnRoaXNbUl0udV9jb2xvck1hdHJpeFsxOF08MXx8dGhpc1tSXS51X3JhZGlhbEdyYWRpZW50VmVjdG9yIT1udWxsfHx0aGlzLmJlZm9yZVJlbmRlcnx8dGhpcy5hZnRlclJlbmRlcn1nZXQgZmlsdGVyQ2FudmFzKCl7cmV0dXJuL2JsdXJ8ZHJvcC1zaGFkb3d8dXJsLy50ZXN0KHRoaXMuZmlsdGVyKX1nZXQgZmlsdGVyKCl7cmV0dXJuIHRoaXNbR10uam9pbigiICIpfWdldCB0cmFuc2Zvcm1NYXRyaXgoKXtyZXR1cm4gdGhpc1tMXX1nZXQgaW52ZXJ0TWF0cml4KCl7aWYoIXRoaXNbRF0pe2NvbnN0IGo9ci5tYXQyZC5pbnZlcnQoQXJyYXkub2YoMCwwLDAsMCwwLDApLHRoaXNbTF0pO3RoaXNbRF09an1yZXR1cm4gdGhpc1tEXX1nZXQgdHJhbnNmb3JtU2NhbGUoKXtjb25zdCBqPXRoaXNbTF07cmV0dXJuIE1hdGgubWF4KE1hdGguaHlwb3QoalswXSxqWzFdKSxNYXRoLmh5cG90KGpbMl0salszXSkpfWdldCB1bmlmb3Jtcygpe3JldHVybiB0aGlzW1JdfWdldCBwYXNzKCl7cmV0dXJuIHRoaXNbc3RdfVtxXShqKXtjb25zdCB6PXRoaXNbX10sZD10aGlzW29dLnBvc2l0aW9uMCxFPU9iamVjdC5lbnRyaWVzKGouX2F0dHJpYnV0ZSk7Zm9yKGxldCBOPTA7TjxFLmxlbmd0aDtOKyspe2NvbnN0WyQsS109RVtOXTtpZigkIT09ImFfY29sb3IiJiYkIT09ImFfc291cmNlUmVjdCImJkshPT0iaWdub3JlZCIpe2NvbnN0IFk9elskXTtpZigkPT09InV2IiYmIVkpe2NvbnN0IFo9dGhpc1tvXS5ib3VuZGluZ0JveHx8ZygpKGQpO3RoaXNbb10uYXR0cmlidXRlc1skXT1mdChaLGQpfWVsc2V7dGhpc1tvXS5hdHRyaWJ1dGVzWyRdPVtdO2ZvcihsZXQgWj0wO1o8ZC5sZW5ndGg7WisrKXtjb25zdCBldD1kW1pdO3RoaXNbb10uYXR0cmlidXRlc1skXS5wdXNoKFk/WShldCxOLGQpOkFycmF5KEsuc2l6ZSkuZmlsbCgwKSl9fX19fWdldCBtZXNoRGF0YSgpe2lmKHRoaXMuX3VwZGF0ZU1hdHJpeCYmdGhpcy50cmFuc2Zvcm1TY2FsZS90aGlzLmNvbnRvdXJzLnNjYWxlPjEuNSYmdGhpcy5hY2N1cmF0ZSh0aGlzLnRyYW5zZm9ybVNjYWxlKSwhdGhpc1tvXSl7IXRoaXNbQ10mJiF0aGlzW1BdJiZ0aGlzLnNldEZpbGwoKTtjb25zdCBqPXRoaXNbVF0sej17fTtpZihqJiZqLmxlbmd0aCl7aWYodGhpc1tDXSl0cnl7Y29uc3QgTj14KCkoaix0aGlzW0NdKTtOLnBvc2l0aW9ucz1OLnBvc2l0aW9ucy5tYXAoJD0+KCQucHVzaCh0aGlzW1FdKSwkKSksTi5hdHRyaWJ1dGVzPXthX2NvbG9yOkFycmF5LmZyb20oe2xlbmd0aDpOLnBvc2l0aW9ucy5sZW5ndGh9KS5tYXAoKCk9PnRoaXNbQV0ubWFwKCQ9Pk1hdGgucm91bmQoMjU1KiQpKSl9LHouZmlsbD1OfWNhdGNoe31pZih0aGlzW1BdKXtjb25zdCBOPXRoaXNbUF0ubGluZURhc2g7bGV0ICQ9ajtpZihOKXtjb25zdCBZPXRoaXNbUF0ubGluZURhc2hPZmZzZXQ7JD1PYmplY3QoZi5nZXREYXNoQ29udG91cnMpKGosTixZKX1jb25zdCBLPSQubWFwKChZLFopPT57Y29uc3QgZXQ9WS5sZW5ndGg+MSYmci52ZWMyLmVxdWFscyhZWzBdLFlbWS5sZW5ndGgtMV0pLHJ0PXRoaXNbUF0uYnVpbGQoWSxldCk7cmV0dXJuIHgoKShbcnRdKX0pO0suZm9yRWFjaChZPT57WS5wb3NpdGlvbnM9WS5wb3NpdGlvbnMubWFwKFo9PihaLnB1c2goLXRoaXNbUV0pLFopKSxZLmF0dHJpYnV0ZXM9e2FfY29sb3I6QXJyYXkuZnJvbSh7bGVuZ3RoOlkucG9zaXRpb25zLmxlbmd0aH0pLm1hcCgoKT0+dGhpc1tJXS5tYXAoWj0+TWF0aC5yb3VuZCgyNTUqWikpKX19KSx6LnN0cm9rZT1PYmplY3QoaC5kZWZhdWx0KShLKX19Y29uc3QgZD1PYmplY3QoaC5kZWZhdWx0KShbei5maWxsLHouc3Ryb2tlXSk7ZC5maWxsUG9pbnRDb3VudD16LmZpbGw/ei5maWxsLnBvc2l0aW9ucy5sZW5ndGg6MCxkLmVuYWJsZUJsZW5kPXRoaXMuZW5hYmxlQmxlbmQsZC5wb3NpdGlvbjA9ZC5wb3NpdGlvbnMubWFwKChbTiwkLEtdKT0+W04sJCxLXSksZC51bmlmb3Jtcz10aGlzW1JdLHRoaXNbb109ZCx0aGlzW1JdLnVfdGV4U2FtcGxlciYmdGhpc1t3XShkLHRoaXNbU10pO2NvbnN0IEU9dGhpc1tMXTtPYmplY3QoTS5pc1VuaXRUcmFuc2Zvcm0pKEUpfHwodGhpc1tIXShkLEUpLHRoaXNbUl0udV9yYWRpYWxHcmFkaWVudFZlY3RvciYmdGhpc1tKXSgpKSx0aGlzLmNsaXBQYXRoJiZ0aGlzW2N0XSgpLHRoaXNbdHRdJiZ0aGlzW3FdKHRoaXNbdHRdKX1yZXR1cm4gdGhpcy5fdXBkYXRlTWF0cml4JiYodGhpc1tvXS5tYXRyaXg9dGhpc1tMXSx0aGlzW0hdKHRoaXNbb10sdGhpc1tMXSksdGhpc1tSXS51X3JhZGlhbEdyYWRpZW50VmVjdG9yJiZ0aGlzW0pdKCkpLHRoaXNbb119W0hdKGoseil7Y29uc3R7cG9zaXRpb25zOmQscG9zaXRpb24wOkV9PWo7Zm9yKGxldCBOPTA7TjxkLmxlbmd0aDtOKyspe2NvbnN0WyQsS109RVtOXSxZPWRbTl07WVswXT0kKnpbMF0rSyp6WzJdK3pbNF0sWVsxXT0kKnpbMV0rSyp6WzNdK3pbNV19dGhpcy5fdXBkYXRlTWF0cml4PSExfVtKXSgpe2NvbnN0IGo9dGhpc1tMXSx6PVsuLi50aGlzLl9yYWRpYWxHcmFkaWVudFZlY3Rvcl07aWYoeil7Y29uc3RbZCxFLCxOLCRdPXo7elswXT1kKmpbMF0rRSpqWzJdK2pbNF0selsxXT1kKmpbMV0rRSpqWzNdK2pbNV0selszXT1OKmpbMF0rJCpqWzJdK2pbNF0sels0XT1OKmpbMV0rJCpqWzNdK2pbNV0sdGhpc1tSXS51X3JhZGlhbEdyYWRpZW50VmVjdG9yPXp9fVt3XShqLHope2Z1bmN0aW9uIGQoWixldCl7cmV0dXJuIFo9PW51bGwmJmV0PT1udWxsPyEwOlo9PW51bGx8fGV0PT1udWxsPyExOlpbMF09PT1ldFswXSYmWlsxXT09PWV0WzFdJiZaWzJdPT09ZXRbMl0mJlpbM109PT1ldFszXX1jb25zdCBFPXRoaXNbUl0udV90ZXhTYW1wbGVyO2lmKCFFKXJldHVybjtjb25zdHt3aWR0aDpOLGhlaWdodDokfT1FLl9pbWcsSz16LnNyY1JlY3Q7bGV0IFk9ei5yZWN0fHxbMCwwXTtpZih6LnJvdGF0ZWQmJihZPVstWVsxXSxZWzBdLFlbM10sWVsyXV0pLFlbMl09PW51bGwmJihZWzJdPUs/S1syXTpOKSxZWzNdPT1udWxsJiYoWVszXT1LP0tbM106JCksei5oaWRkZW4pai50ZXh0dXJlQ29vcmQ9ai5wb3NpdGlvbnMubWFwKCgpPT5bLTEsLTEsLTFdKTtlbHNlIGlmKCFqLnRleHR1cmVDb29yZHx8IWQodGhpc1tTXS5yZWN0LHoucmVjdCl8fHRoaXNbU10uaGlkZGVuIT09ei5oaWRkZW58fHRoaXNbU10ucm90YXRlZCE9PXoucm90YXRlZCl7bGV0IFo9bnVsbDt6LnJvdGF0ZWQmJihaPXIubWF0MmQucm90YXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxyLm1hdDJkLmZyb21WYWx1ZXMoMSwwLDAsMSwwLDApLC41Kk1hdGguUEkpLFo9ci5tYXQyZC50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDApLFosWzAsLVlbMl1dKSksai50ZXh0dXJlQ29vcmQ9ai5wb3NpdGlvbjAubWFwKChbZXQscnQsYXRdKT0+e2lmKDEvYXQ+MCl7aWYoei5yb3RhdGVkKXtjb25zdCBpdD1ldCpaWzBdK3J0KlpbMl0rWls0XSxudD1ldCpaWzFdK3J0KlpbM10rWls1XTtbZXQscnRdPVtpdCxudF19Y29uc3QgbHQ9VShbZXQscnRdLFtZWzBdL1lbMl0sWVsxXS9ZWzNdLFlbMl0sWVszXV0seik7cmV0dXJuIHoucmVwZWF0JiYobHRbMl09MSksbHR9cmV0dXJuWy0xLC0xLC0xXX0pfWlmKEspe2NvbnN0IFo9W0tbMF0vTixLWzFdLyQsS1syXS9OLEtbM10vJF07ai5hdHRyaWJ1dGVzLmFfc291cmNlUmVjdD1qLnBvc2l0aW9ucy5tYXAoKCk9PlsuLi5aXSl9ZWxzZSBqLmF0dHJpYnV0ZXMuYV9zb3VyY2VSZWN0PWoucG9zaXRpb25zLm1hcCgoKT0+WzAsMCwwLDBdKX1hY2N1cmF0ZShqKXtpZighdGhpcy5jb250b3VycylyZXR1cm47aWYodGhpcy5jb250b3Vycy5wYXRoKXtjb25zdCBkPXRoaXMuY29udG91cnMuc2ltcGxpZnksRT1GKHRoaXMuY29udG91cnMucGF0aCwyKmosZCk7dGhpc1tvXT1udWxsLHRoaXNbVF09RX19Y2FuSWdub3JlKCl7Y29uc3Qgaj10aGlzW1BdPT1udWxsfHx0aGlzW1BdLmxpbmVXaWR0aD09PTB8fHRoaXNbSV1bM109PT0wLHo9dGhpc1tDXT09bnVsbHx8dGhpc1tBXVszXT09PTAsZD10aGlzW1JdLnVfcmFkaWFsR3JhZGllbnRWZWN0b3I9PW51bGwsRT10aGlzW1JdLnVfdGV4U2FtcGxlcj09bnVsbDtyZXR1cm4gdGhpc1tRXT09PTB8fHRoaXNbdHRdPT1udWxsJiZqJiZ6JiZkJiZFJiYhdGhpcy5iZWZvcmVSZW5kZXImJiF0aGlzLmFmdGVyUmVuZGVyfXNldFN0cm9rZSh7dGhpY2tuZXNzOmo9MSxjYXA6ej0iYnV0dCIsam9pbjpkPSJtaXRlciIsbWl0ZXJMaW1pdDpFPTEwLGNvbG9yOk49WzAsMCwwLDBdLGxpbmVEYXNoOiQ9bnVsbCxsaW5lRGFzaE9mZnNldDpLPTAscm91bmRTZWdtZW50czpZPTIwfT17fSl7cmV0dXJuIHRoaXNbb109bnVsbCx0aGlzW1BdPW5ldyB2LmRlZmF1bHQoe2xpbmVXaWR0aDpqLGxpbmVDYXA6eixsaW5lSm9pbjpkLG1pdGVyTGltaXQ6RSxyb3VuZFNlZ21lbnRzOll9KSx0eXBlb2YgTj09InN0cmluZyImJihOPU9iamVjdChtLmRlZmF1bHQpKE4pKSx0aGlzW0ldPU4sdGhpc1tQXS5saW5lRGFzaD0kLHRoaXNbUF0ubGluZURhc2hPZmZzZXQ9Syx0aGlzfXNldEZpbGwoe3J1bGU6aj10aGlzLmZpbGxSdWxlLGNvbG9yOno9WzAsMCwwLDBdfT17fSl7cmV0dXJuIHRoaXNbb109bnVsbCx0aGlzW0NdPXtydWxlOmp9LHR5cGVvZiB6PT0ic3RyaW5nIiYmKHo9T2JqZWN0KG0uZGVmYXVsdCkoeikpLHRoaXNbQV09eix0aGlzfXNldFRleHR1cmUoaix6PXt9KXtpZihqJiZqLmltYWdlKXtjb25zdHtpbWFnZTpkLHJlY3Q6RX09ajtpZihqPWQsei5yZWN0KWZvcihsZXQgTj0wO048ei5yZWN0Lmxlbmd0aDtOKyspRVtOXT16LnJlY3RbTl07ei5yZWN0PUV9cmV0dXJuIHRoaXNbQ118fHRoaXMuc2V0RmlsbCgpLHRoaXMuc2V0VW5pZm9ybXMoe3VfdGV4U2FtcGxlcjpqfSksdGhpc1tvXSYmdGhpc1t3XSh0aGlzW29dLHopLHRoaXNbU109eix0aGlzfXNldENpcmN1bGFyR3JhZGllbnQoe3ZlY3RvcjpqLGNvbG9yczp6LHR5cGU6ZD0iZmlsbCJ9PXt9KXtpZihqLmxlbmd0aCE9PTMpdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCBsaW5lYXJHcmFkaWVudC4iKTt0aGlzLnNldEdyYWRpZW50KHt2ZWN0b3I6aixjb2xvcnM6eix0eXBlOmR9KX1zZXRMaW5lYXJHcmFkaWVudCh7dmVjdG9yOmosY29sb3JzOnosdHlwZTpkPSJmaWxsIn09e30pe2lmKGoubGVuZ3RoIT09NCl0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIGxpbmVhckdyYWRpZW50LiIpO3RoaXMuc2V0R3JhZGllbnQoe3ZlY3RvcjpqLGNvbG9yczp6LHR5cGU6ZH0pfXNldFJhZGlhbEdyYWRpZW50KHt2ZWN0b3I6aixjb2xvcnM6eix0eXBlOmQ9ImZpbGwifT17fSl7aWYoai5sZW5ndGghPT02KXRocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgcmFkaWFsR3JhZGllbnQuIik7dGhpcy5zZXRHcmFkaWVudCh7dmVjdG9yOmosY29sb3JzOnosdHlwZTpkfSl9c2V0R3JhZGllbnQoe3ZlY3RvcjpqLGNvbG9yczp6LHR5cGU6ZD0iZmlsbCJ9PXt9KXt6PXoubWFwKCh7b2Zmc2V0OiQsY29sb3I6S30pPT4odHlwZW9mIEs9PSJzdHJpbmciJiYoSz1PYmplY3QobS5kZWZhdWx0KShLKSkse29mZnNldDokLGNvbG9yOkt9KSksdGhpc1tXXT10aGlzW1ddfHx7fSx0aGlzW1ddW2RdPXt2ZWN0b3I6aixjb2xvcnM6en0sei5zb3J0KCgkLEspPT4kLm9mZnNldC1LLm9mZnNldCk7Y29uc3QgRT1bXTt6LmZvckVhY2goKHtvZmZzZXQ6JCxjb2xvcjpLfSk9PntFLnB1c2goJCwuLi5LKX0pO2xldCBOO2lmKGoubGVuZ3RoPT09ND9OPVtqWzBdLGpbMV0sMCxqWzJdLGpbM10sMF06Tj1bLi4ual0sRS5sZW5ndGg8NDAmJkUucHVzaCgtMSksRS5sZW5ndGg+NDApdGhyb3cgbmV3IEVycm9yKCJUb28gbWFueSBjb2xvcnMsIHNob3VsZCBiZSBsZXNzIHRoYW4gOCBjb2xvcnMiKTtyZXR1cm4gdGhpcy5fcmFkaWFsR3JhZGllbnRWZWN0b3I9Tix0aGlzW1JdLnVfY29sb3JTdGVwcz1FLGQ9PT0iZmlsbCI/dGhpc1tSXS51X2dyYWRpZW50VHlwZT0xOnRoaXNbUl0udV9ncmFkaWVudFR5cGU9MCx0aGlzW0pdKCksdGhpc31zZXRVbmlmb3JtcyhqPXt9KXtyZXR1cm4gT2JqZWN0LmFzc2lnbih0aGlzW1JdLGopLHRoaXN9c2V0VHJhbnNmb3JtKC4uLmope2NvbnN0IHo9dGhpc1tMXTtyZXR1cm4gci5tYXQyZC5lcXVhbHMoaix6KXx8KHRoaXNbTF09aixkZWxldGUgdGhpc1tEXSx0aGlzLl91cGRhdGVNYXRyaXg9ITApLHRoaXN9dHJhbnNmb3JtKC4uLmope2NvbnN0IHo9dGhpc1tMXTtyZXR1cm4gdGhpc1tMXT1yLm1hdDJkLm11bHRpcGx5KEFycmF5Lm9mKDAsMCwwLDAsMCwwKSx6LGopLGRlbGV0ZSB0aGlzW0RdLHRoaXMuX3VwZGF0ZU1hdHJpeD0hMCx0aGlzfXRyYW5zbGF0ZShqLHope2xldCBkPXIubWF0MmQuY3JlYXRlKCk7cmV0dXJuIGQ9ci5tYXQyZC50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDApLGQsW2osel0pLHRoaXMudHJhbnNmb3JtKC4uLmQpfXJvdGF0ZShqLFt6LGRdPVswLDBdKXtsZXQgRT1yLm1hdDJkLmNyZWF0ZSgpO3JldHVybiBFPXIubWF0MmQudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxFLFt6LGRdKSxFPXIubWF0MmQucm90YXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxFLGopLEU9ci5tYXQyZC50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDApLEUsWy16LC1kXSksdGhpcy50cmFuc2Zvcm0oLi4uRSl9c2NhbGUoaix6PWosW2QsRV09WzAsMF0pe2xldCBOPXIubWF0MmQuY3JlYXRlKCk7cmV0dXJuIE49ci5tYXQyZC50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDApLE4sW2QsRV0pLE49ci5tYXQyZC5zY2FsZShBcnJheS5vZigwLDAsMCwwLDAsMCksTixbaix6XSksTj1yLm1hdDJkLnRyYW5zbGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCksTixbLWQsLUVdKSx0aGlzLnRyYW5zZm9ybSguLi5OKX1za2V3KGosej1qLFtkLEVdPVswLDBdKXtsZXQgTj1yLm1hdDJkLmNyZWF0ZSgpO3JldHVybiBOPXIubWF0MmQudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxOLFtkLEVdKSxOPXIubWF0MmQubXVsdGlwbHkoQXJyYXkub2YoMCwwLDAsMCwwLDApLE4sci5tYXQyZC5mcm9tVmFsdWVzKDEsTWF0aC50YW4oeiksTWF0aC50YW4oaiksMSwwLDApKSxOPXIubWF0MmQudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxOLFstZCwtRV0pLHRoaXMudHJhbnNmb3JtKC4uLk4pfWNsZWFyRmlsdGVyKCl7cmV0dXJuIHRoaXMuc2V0Q29sb3JUcmFuc2Zvcm0obnVsbCksdGhpc1tHXS5sZW5ndGg9MCx0aGlzfXNldENvbG9yVHJhbnNmb3JtKC4uLmope3JldHVybiBqWzBdPT09bnVsbD90aGlzLnNldFVuaWZvcm1zKHt1X2ZpbHRlckZsYWc6MCx1X2NvbG9yTWF0cml4OjB9KTp0aGlzLnNldFVuaWZvcm1zKHt1X2ZpbHRlckZsYWc6MSx1X2NvbG9yTWF0cml4Omp9KSx0aGlzfXRyYW5zZm9ybUNvbG9yKC4uLmope2xldCB6PXRoaXMudW5pZm9ybXMudV9jb2xvck1hdHJpeDtyZXR1cm4gej96PU9iamVjdCh1Lm11bHRpcGx5KSh6LGopOno9aix0aGlzLnNldENvbG9yVHJhbnNmb3JtKC4uLnopLHRoaXN9Ymx1cihqKXtyZXR1cm4gdGhpc1tHXS5wdXNoKGBibHVyKCR7an1weClgKSx0aGlzfWJyaWdodG5lc3Moaj0xKXtyZXR1cm4gdGhpc1tHXS5wdXNoKGBicmlnaHRuZXNzKCR7MTAwKmp9JSlgKSx0aGlzLnRyYW5zZm9ybUNvbG9yKC4uLk9iamVjdCh1LmJyaWdodG5lc3MpKGopKX1jb250cmFzdChqPTEpe3JldHVybiB0aGlzW0ddLnB1c2goYGNvbnRyYXN0KCR7MTAwKmp9JSlgKSx0aGlzLnRyYW5zZm9ybUNvbG9yKC4uLk9iamVjdCh1LmNvbnRyYXN0KShqKSl9ZHJvcFNoYWRvdyhqLHosZD0wLEU9WzAsMCwwLDFdKXtyZXR1cm4gQXJyYXkuaXNBcnJheShFKSYmKEU9T2JqZWN0KGwuZGVmYXVsdCkoRSkpLHRoaXNbR10ucHVzaChgZHJvcC1zaGFkb3coJHtqfXB4ICR7en1weCAke2R9cHggJHtFfSlgKSx0aGlzfWdyYXlzY2FsZShqPTEpe3JldHVybiB0aGlzW0ddLnB1c2goYGdyYXlzY2FsZSgkezEwMCpqfSUpYCksdGhpcy50cmFuc2Zvcm1Db2xvciguLi5PYmplY3QodS5ncmF5c2NhbGUpKGopKX1odWVSb3RhdGUoaj0wKXtyZXR1cm4gdGhpc1tHXS5wdXNoKGBodWUtcm90YXRlKCR7an1kZWcpYCksdGhpcy50cmFuc2Zvcm1Db2xvciguLi5PYmplY3QodS5odWVSb3RhdGUpKGopKX1pbnZlcnQoaj0xKXtyZXR1cm4gdGhpc1tHXS5wdXNoKGBpbnZlcnQoJHsxMDAqan0lKWApLHRoaXMudHJhbnNmb3JtQ29sb3IoLi4uT2JqZWN0KHUuaW52ZXJ0KShqKSl9b3BhY2l0eShqPTEpe3JldHVybiB0aGlzW0ddLnB1c2goYG9wYWNpdHkoJHsxMDAqan0lKWApLHRoaXMudHJhbnNmb3JtQ29sb3IoLi4uT2JqZWN0KHUub3BhY2l0eSkoaikpfXNhdHVyYXRlKGo9MSl7cmV0dXJuIHRoaXNbR10ucHVzaChgc2F0dXJhdGUoJHsxMDAqan0lKWApLHRoaXMudHJhbnNmb3JtQ29sb3IoLi4uT2JqZWN0KHUuc2F0dXJhdGUpKGopKX1zZXBpYShqPTEpe3JldHVybiB0aGlzW0ddLnB1c2goYHNlcGlhKCR7MTAwKmp9JSlgKSx0aGlzLnRyYW5zZm9ybUNvbG9yKC4uLk9iamVjdCh1LnNlcGlhKShqKSl9dXJsKGope3JldHVybiB0aGlzW0ddLnB1c2goYHVybCgke2p9KWApLHRoaXN9aXNQb2ludENvbGxpc2lvbihqLHosZD0iYm90aCIpe2NvbnN0IEU9dGhpcy5tZXNoRGF0YSx7cG9zaXRpb25zOk4sY2VsbHM6JH09RSxLPXRoaXMuaW52ZXJ0TWF0cml4LFk9S1swXSpqK0tbMl0qeitLWzRdLFo9S1sxXSpqK0tbM10qeitLWzVdLGV0PXRoaXMuYm91bmRpbmdCb3g7aWYoWTxldFswXVswXXx8WT5ldFsxXVswXXx8WjxldFswXVsxXXx8Wj5ldFsxXVsxXSlyZXR1cm4hMTtmdW5jdGlvbiBydChbYXQsbHRdLFtpdCxudF0sW290LGR0XSl7Y29uc3QgZ3Q9b3QtaXQsdXQ9ZHQtbnQsbXQ9KChhdC1pdCkqZ3QrKGx0LW50KSp1dCkvKGd0KioyK3V0KioyKTtyZXR1cm4gbXQ+PTAmJm10PD0xfWZvcihsZXQgYXQ9MDthdDwkLmxlbmd0aDthdCsrKXtjb25zdCBsdD0kW2F0XTtpZihkPT09ImZpbGwiJiZsdFswXT49RS5maWxsUG9pbnRDb3VudClicmVhaztpZihkPT09InN0cm9rZSImJmx0WzBdPEUuZmlsbFBvaW50Q291bnQpY29udGludWU7Y29uc3RbW2l0LG50XSxbb3QsZHRdLFtndCx1dF1dPWx0Lm1hcChwdD0+TltwdF0pLG10PU1hdGguc2lnbigoai1pdCkqKGR0LW50KS0ob3QtaXQpKih6LW50KSk7aWYobXQ9PT0wJiZydChbaix6XSxbaXQsbnRdLFtvdCxkdF0pKXJldHVybiEwO2NvbnN0IE90PU1hdGguc2lnbigoai1vdCkqKHV0LWR0KS0oZ3Qtb3QpKih6LWR0KSk7aWYoT3Q9PT0wJiZydChbaix6XSxbb3QsZHRdLFtndCx1dF0pKXJldHVybiEwO2NvbnN0IHl0PU1hdGguc2lnbigoai1ndCkqKG50LXV0KS0oaXQtZ3QpKih6LXV0KSk7aWYoeXQ9PT0wJiZydChbaix6XSxbZ3QsdXRdLFtpdCxudF0pfHxtdD09PTEmJk90PT09MSYmeXQ9PT0xfHxtdD09PS0xJiZPdD09PS0xJiZ5dD09PS0xKXJldHVybiEwfXJldHVybiExfWlzUG9pbnRJbkZpbGwoaix6KXtyZXR1cm4gdGhpcy5pc1BvaW50Q29sbGlzaW9uKGoseiwiZmlsbCIpfWlzUG9pbnRJblN0cm9rZShqLHope3JldHVybiB0aGlzLmlzUG9pbnRDb2xsaXNpb24oaix6LCJzdHJva2UiKX1hZGRQYXNzKGosej17fSl7bGV0e3dpZHRoOmQsaGVpZ2h0OkV9PXosTj1hKHosWyJ3aWR0aCIsImhlaWdodCJdKTtjb25zdCAkPW5ldyBwLmRlZmF1bHQ7JC5yZWN0KDAsMCxkLEUpO2NvbnN0IEs9bmV3IFYoJCx7d2lkdGg6ZCxoZWlnaHQ6RX0pO0suc2V0VW5pZm9ybXMoTiksSy5zZXRQcm9ncmFtKGopLHRoaXNbc3RdLnB1c2goSyl9fX0sZnVuY3Rpb24oYyxlLHQpe3QucihlKTt2YXIgcj10KDU4KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSksZS5kZWZhdWx0PXIuU3Ryb2tlfSxmdW5jdGlvbihjLGUsdCl7dC5yKGUpLHQuZChlLCJTdHJva2UiLGZ1bmN0aW9uKCl7cmV0dXJuIE19KTt2YXIgcj10KDQ5KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3Qgcz1PYmplY3Qoci5jcmVhdGUpKCksZz1PYmplY3Qoci5jcmVhdGUpKCksdj1PYmplY3Qoci5jcmVhdGUpKCksaD1PYmplY3Qoci5jcmVhdGUpKCksbD1PYmplY3Qoci5jcmVhdGUpKCksdT0xZTIwO2NsYXNzIE17Y29uc3RydWN0b3Ioe2xpbmVXaWR0aDpPPTEsbGluZUpvaW46bT0ibWl0ZXIiLG1pdGVyTGltaXQ6cD0xMCxsaW5lQ2FwOm49ImJ1dHQiLHJvdW5kU2VnbWVudHM6YT0yMH09e30pe3RoaXMubGluZVdpZHRoPU8sdGhpcy5saW5lSm9pbj1tLHRoaXMubWl0ZXJMaW1pdD1wLHRoaXMubGluZUNhcD1uLHRoaXMucm91bmRTZWdtZW50cz1hLHRoaXMuX25vcm1hbD1udWxsfWJ1aWxkKE8sbT0hMSl7bGV0IHA9Ty5sZW5ndGg7aWYoTz1bLi4uT10scDwyKXJldHVybiBPO20mJigoT1swXVswXSE9PU9bcC0xXVswXXx8T1swXVsxXSE9PU9bcC0xXVsxXSkmJk8ucHVzaChbLi4uT1swXV0pLE8ucHVzaChbLi4uT1sxXV0pKSxwPU8ubGVuZ3RoLHRoaXMuX25vcm1hbD1udWxsO2NvbnN0IG49e2xlZnQ6W10scmlnaHQ6W119LGE9dGhpcy5saW5lV2lkdGgvMixpPXRoaXMubGluZUNhcDtpZighbSYmaT09PSJzcXVhcmUiKXtPYmplY3Qoci5kaXJlY3Rpb24pKGcsT1swXSxPWzFdKSxPYmplY3Qoci5zY2FsZUFuZEFkZCkoT1swXSxPWzBdLGcsYSk7Y29uc3QgVD1PLmxlbmd0aC0xO09iamVjdChyLmRpcmVjdGlvbikoZyxPW1RdLE9bVC0xXSksT2JqZWN0KHIuc2NhbGVBbmRBZGQpKE9bVF0sT1tUXSxnLGEpfWZvcihsZXQgVD0xO1Q8cDtUKyspe2NvbnN0IFA9T1tULTFdLEM9T1tUXSxJPU9bVCsxXTt0aGlzLl9zZWcobixQLEMsSSxhLG0pfXJldHVybiFtJiZpPT09InJvdW5kIiYmeChuLHRoaXMucm91bmRTZWdtZW50cyksWy4uLm4ubGVmdCwuLi5uLnJpZ2h0LnJldmVyc2UoKV19X3NlZyhPLG0scCxuLGEsaSl7Y29uc3Qgbz10aGlzLmxpbmVKb2luPT09ImJldmVsIixUPXRoaXMubGluZUpvaW49PT0icm91bmQiO2lmKE9iamVjdChyLmRpcmVjdGlvbikoZyxwLG0pLHRoaXMuX25vcm1hbHx8KHRoaXMuX25vcm1hbD1PYmplY3Qoci5jcmVhdGUpKCksT2JqZWN0KHIubm9ybWFsKSh0aGlzLl9ub3JtYWwsZykpLE8ubGVmdC5sZW5ndGh8fHkoTyxtLHRoaXMuX25vcm1hbCxhKSwhbilPYmplY3Qoci5ub3JtYWwpKHRoaXMuX25vcm1hbCxnKSxpP3koTyxtLHRoaXMuX25vcm1hbCxhKTp5KE8scCx0aGlzLl9ub3JtYWwsYSk7ZWxzZXtPYmplY3Qoci5kaXJlY3Rpb24pKHYsbixwKTtsZXQgUD1PYmplY3Qoci5jb21wdXRlTWl0ZXIpKGgsbCxnLHYsYSk7UD1NYXRoLm1pbihQLHUpO2NvbnN0IEM9T2JqZWN0KHIuZG90KShoLHRoaXMuX25vcm1hbCk8MD8tMToxO2xldCBJPW98fFQ7aWYoIUkmJnRoaXMubGluZUpvaW49PT0ibWl0ZXIiJiZQL2E+dGhpcy5taXRlckxpbWl0JiYoST0hMCksSSl7T2JqZWN0KHIuc2NhbGVBbmRBZGQpKHMscCx0aGlzLl9ub3JtYWwsLWEqQyksZihPLHMsQyk7bGV0IEE9MS8wO20mJihBPU1hdGgubWluKEEsTWF0aC5oeXBvdChwWzBdLW1bMF0scFsxXS1tWzFdKSkpLG4mJihBPU1hdGgubWluKEEsTWF0aC5oeXBvdChuWzBdLXBbMF0sblsxXS1wWzFdKSkpO2NvbnN0IEw9TWF0aC5tYXgoYSxNYXRoLm1pbihQLEEpKTtpZihPYmplY3Qoci5zY2FsZUFuZEFkZCkocyxwLGwsTCpDKSxmKE8scywtQyksbilpZihPYmplY3Qoci5ub3JtYWwpKHMsdiksT2JqZWN0KHIuY29weSkodGhpcy5fbm9ybWFsLHMpLE9iamVjdChyLnNjYWxlQW5kQWRkKShzLHAscywtYSpDKSxUKXtjb25zdCBEPU9iamVjdChyLmNsb25lKShzKSxSPUM+MD9PLmxlZnRbTy5sZWZ0Lmxlbmd0aC0xXTpPLnJpZ2h0W08ucmlnaHQubGVuZ3RoLTFdLFM9T2JqZWN0KHIuY2xvbmUpKHApLEI9T2JqZWN0KHIuc3ViKShPYmplY3Qoci5jcmVhdGUpKCksUixTKSx3PU9iamVjdChyLnN1YikoT2JqZWN0KHIuY3JlYXRlKSgpLEQsUyksSD1NYXRoLlBJL3RoaXMucm91bmRTZWdtZW50cztmb3IobGV0IEo9MDtKPHRoaXMucm91bmRTZWdtZW50cyYmKE9iamVjdChyLnJvdGF0ZSkoQixCLFswLDBdLEMqSCksTWF0aC5zaWduKE9iamVjdChyLmNyb3NzKShzLEIsdylbMl0pPT09Qyk7SisrKU9iamVjdChyLmFkZCkocyxCLFMpLGYoTyxzLEMpO2YoTyxELEMpfWVsc2UgZihPLHMsQyl9ZWxzZSB5KE8scCxsLFApLE9iamVjdChyLmNvcHkpKHRoaXMuX25vcm1hbCxsKX19fWZ1bmN0aW9uIGYoYixPLG0pe20+MD9iLmxlZnQucHVzaChPYmplY3Qoci5jbG9uZSkoTykpOmIucmlnaHQucHVzaChPYmplY3Qoci5jbG9uZSkoTykpfWZ1bmN0aW9uIHkoYixPLG0scCxuPS0xKXtPYmplY3Qoci5zY2FsZUFuZEFkZCkocyxPLG0sLXApLGYoYixzLC1uKSxPYmplY3Qoci5zY2FsZUFuZEFkZCkocyxPLG0scCksZihiLHMsbil9ZnVuY3Rpb24geCh7bGVmdDpiLHJpZ2h0Ok99LG0pe2NvbnN0IHA9T2JqZWN0KHIuY3JlYXRlKSgpLG49T2JqZWN0KHIuY3JlYXRlKSgpO2xldCBhPWJbMF0saT1PWzBdLG89Wy41KihhWzBdK2lbMF0pLC41KihhWzFdK2lbMV0pXTtPYmplY3Qoci5zdWIpKG4sYSxvKTtmb3IobGV0IFQ9MTtUPD1tO1QrKyl7Y29uc3QgUD0tMSpNYXRoLlBJKlQvbTtPYmplY3Qoci5yb3RhdGUpKHAsbixbMCwwXSxQKSxPYmplY3Qoci5hZGQpKHMsbyxwKSxiLnVuc2hpZnQoT2JqZWN0KHIuY2xvbmUpKHMpKX1hPU9bTy5sZW5ndGgtMV0saT1iW2IubGVuZ3RoLTFdLG89Wy41KihhWzBdK2lbMF0pLC41KihhWzFdK2lbMV0pXSxPYmplY3Qoci5zdWIpKG4sYSxvKTtmb3IobGV0IFQ9MTtUPD1tO1QrKyl7Y29uc3QgUD0tMSpNYXRoLlBJKlQvbTtPYmplY3Qoci5yb3RhdGUpKHAsbixbMCwwXSxQKSxPYmplY3Qoci5hZGQpKHMsbyxwKSxPLnB1c2goT2JqZWN0KHIuY2xvbmUpKHMpKX19fSxmdW5jdGlvbihjLGUsdCl7dC5yKGUpLHQuZChlLCJpc1VuaXRUcmFuc2Zvcm0iLGZ1bmN0aW9uKCl7cmV0dXJuIHJ9KSx0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gcihzKXtyZXR1cm4gc1swXT09PTEmJnNbMV09PT0wJiZzWzJdPT09MCYmc1szXT09PTEmJnNbNF09PT0wJiZzWzVdPT09MH19LGZ1bmN0aW9uKGMsZSx0KXt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7dmFyIHI9dCg2MSkscz10KDYyKTtjLmV4cG9ydHM9ZnVuY3Rpb24oZyx2KXtpZih2PXZ8fHt9LGc9Zy5maWx0ZXIoZnVuY3Rpb24obSl7cmV0dXJuIG0ubGVuZ3RoPjJ9KSxnLmxlbmd0aD09PTApcmV0dXJue3Bvc2l0aW9uczpbXSxjZWxsczpbXX07dHlwZW9mIHYudmVydGV4U2l6ZSE9Im51bWJlciImJih2LnZlcnRleFNpemU9Z1swXVswXS5sZW5ndGgpLGc9Zy5tYXAoZnVuY3Rpb24obSl7cmV0dXJuIG0ucmVkdWNlKGZ1bmN0aW9uKHAsbil7cmV0dXJuIHAuY29uY2F0KG4pfSl9KTtjb25zdCBoPXYucnVsZT09PSJldmVub2RkIj9yLldJTkRJTkdfT0REOnIuV0lORElOR19OT05aRVJPO2Zvcih2YXIgbD1yLnRlc3NlbGF0ZShzKHtjb250b3VyczpnLHdpbmRpbmdSdWxlOmgsZWxlbWVudFR5cGU6ci5QT0xZR09OUyxwb2x5U2l6ZTozLHZlcnRleFNpemU6Mn0sdikpLHU9W10sTT0wO008bC52ZXJ0aWNlcy5sZW5ndGg7TSs9di52ZXJ0ZXhTaXplKXt2YXIgZj1sLnZlcnRpY2VzLnNsaWNlKE0sTSt2LnZlcnRleFNpemUpO3UucHVzaChmKX12YXIgeT1bXTtmb3IoTT0wO008bC5lbGVtZW50cy5sZW5ndGg7TSs9Myl7dmFyIHg9bC5lbGVtZW50c1tNXSxiPWwuZWxlbWVudHNbTSsxXSxPPWwuZWxlbWVudHNbTSsyXTt5LnB1c2goW3gsYixPXSl9cmV0dXJue3Bvc2l0aW9uczp1LGNlbGxzOnl9fX0sZnVuY3Rpb24oYyxlLHQpe3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTt2YXIgcj17fSxzPXt9O2MuZXhwb3J0cz1yLHIuV0lORElOR19PREQ9MCxyLldJTkRJTkdfTk9OWkVSTz0xLHIuV0lORElOR19QT1NJVElWRT0yLHIuV0lORElOR19ORUdBVElWRT0zLHIuV0lORElOR19BQlNfR0VRX1RXTz00LHIuUE9MWUdPTlM9MCxyLkNPTk5FQ1RFRF9QT0xZR09OUz0xLHIuQk9VTkRBUllfQ09OVE9VUlM9MixyLnRlc3NlbGF0ZT1mdW5jdGlvbihuKXtmb3IodmFyIGE9bi5kZWJ1Z3x8ITEsaT1uZXcgcCxvPTA7bzxuLmNvbnRvdXJzLmxlbmd0aDtvKyspaS5hZGRDb250b3VyKG4udmVydGV4U2l6ZXx8MixuLmNvbnRvdXJzW29dKTtyZXR1cm4gaS50ZXNzZWxhdGUobi53aW5kaW5nUnVsZXx8ci5XSU5ESU5HX09ERCxuLmVsZW1lbnRUeXBlfHxyLlBPTFlHT05TLG4ucG9seVNpemV8fDMsbi52ZXJ0ZXhTaXplfHwyLG4ubm9ybWFsfHxbMCwwLDFdKSx7dmVydGljZXM6aS52ZXJ0aWNlcyx2ZXJ0ZXhJbmRpY2VzOmkudmVydGV4SW5kaWNlcyx2ZXJ0ZXhDb3VudDppLnZlcnRleENvdW50LGVsZW1lbnRzOmkuZWxlbWVudHMsZWxlbWVudENvdW50OmkuZWxlbWVudENvdW50LG1lc2g6YT9pLm1lc2g6dm9pZCAwfX07dmFyIGc9ZnVuY3Rpb24obil7aWYoIW4pdGhyb3ciQXNzZXJ0aW9uIEZhaWxlZCEifTtmdW5jdGlvbiB2KCl7dGhpcy5uZXh0PW51bGwsdGhpcy5wcmV2PW51bGwsdGhpcy5hbkVkZ2U9bnVsbCx0aGlzLmNvb3Jkcz1bMCwwLDBdLHRoaXMucz0wLHRoaXMudD0wLHRoaXMucHFIYW5kbGU9MCx0aGlzLm49MCx0aGlzLmlkeD0wfWZ1bmN0aW9uIGgoKXt0aGlzLm5leHQ9bnVsbCx0aGlzLnByZXY9bnVsbCx0aGlzLmFuRWRnZT1udWxsLHRoaXMudHJhaWw9bnVsbCx0aGlzLm49MCx0aGlzLm1hcmtlZD0hMSx0aGlzLmluc2lkZT0hMX1mdW5jdGlvbiBsKG4pe3RoaXMubmV4dD1udWxsLHRoaXMuU3ltPW51bGwsdGhpcy5PbmV4dD1udWxsLHRoaXMuTG5leHQ9bnVsbCx0aGlzLk9yZz1udWxsLHRoaXMuTGZhY2U9bnVsbCx0aGlzLmFjdGl2ZVJlZ2lvbj1udWxsLHRoaXMud2luZGluZz0wLHRoaXMuc2lkZT1ufWwucHJvdG90eXBlPXtnZXQgUmZhY2UoKXtyZXR1cm4gdGhpcy5TeW0uTGZhY2V9LHNldCBSZmFjZShuKXt0aGlzLlN5bS5MZmFjZT1ufSxnZXQgRHN0KCl7cmV0dXJuIHRoaXMuU3ltLk9yZ30sc2V0IERzdChuKXt0aGlzLlN5bS5Pcmc9bn0sZ2V0IE9wcmV2KCl7cmV0dXJuIHRoaXMuU3ltLkxuZXh0fSxzZXQgT3ByZXYobil7dGhpcy5TeW0uTG5leHQ9bn0sZ2V0IExwcmV2KCl7cmV0dXJuIHRoaXMuT25leHQuU3ltfSxzZXQgTHByZXYobil7dGhpcy5PbmV4dC5TeW09bn0sZ2V0IERwcmV2KCl7cmV0dXJuIHRoaXMuTG5leHQuU3ltfSxzZXQgRHByZXYobil7dGhpcy5MbmV4dC5TeW09bn0sZ2V0IFJwcmV2KCl7cmV0dXJuIHRoaXMuU3ltLk9uZXh0fSxzZXQgUnByZXYobil7dGhpcy5TeW0uT25leHQ9bn0sZ2V0IERuZXh0KCl7cmV0dXJuIHRoaXMuU3ltLk9uZXh0LlN5bX0sc2V0IERuZXh0KG4pe3RoaXMuU3ltLk9uZXh0LlN5bT1ufSxnZXQgUm5leHQoKXtyZXR1cm4gdGhpcy5TeW0uTG5leHQuU3ltfSxzZXQgUm5leHQobil7dGhpcy5TeW0uTG5leHQuU3ltPW59fTtmdW5jdGlvbiB1KCl7dmFyIG49bmV3IHYsYT1uZXcgaCxpPW5ldyBsKDApLG89bmV3IGwoMSk7bi5uZXh0PW4ucHJldj1uLG4uYW5FZGdlPW51bGwsYS5uZXh0PWEucHJldj1hLGEuYW5FZGdlPW51bGwsYS50cmFpbD1udWxsLGEubWFya2VkPSExLGEuaW5zaWRlPSExLGkubmV4dD1pLGkuU3ltPW8saS5PbmV4dD1udWxsLGkuTG5leHQ9bnVsbCxpLk9yZz1udWxsLGkuTGZhY2U9bnVsbCxpLndpbmRpbmc9MCxpLmFjdGl2ZVJlZ2lvbj1udWxsLG8ubmV4dD1vLG8uU3ltPWksby5PbmV4dD1udWxsLG8uTG5leHQ9bnVsbCxvLk9yZz1udWxsLG8uTGZhY2U9bnVsbCxvLndpbmRpbmc9MCxvLmFjdGl2ZVJlZ2lvbj1udWxsLHRoaXMudkhlYWQ9bix0aGlzLmZIZWFkPWEsdGhpcy5lSGVhZD1pLHRoaXMuZUhlYWRTeW09b311LnByb3RvdHlwZT17bWFrZUVkZ2VfOmZ1bmN0aW9uKG4pe3ZhciBhPW5ldyBsKDApLGk9bmV3IGwoMSk7bi5TeW0uc2lkZTxuLnNpZGUmJihuPW4uU3ltKTt2YXIgbz1uLlN5bS5uZXh0O3JldHVybiBpLm5leHQ9byxvLlN5bS5uZXh0PWEsYS5uZXh0PW4sbi5TeW0ubmV4dD1pLGEuU3ltPWksYS5PbmV4dD1hLGEuTG5leHQ9aSxhLk9yZz1udWxsLGEuTGZhY2U9bnVsbCxhLndpbmRpbmc9MCxhLmFjdGl2ZVJlZ2lvbj1udWxsLGkuU3ltPWEsaS5PbmV4dD1pLGkuTG5leHQ9YSxpLk9yZz1udWxsLGkuTGZhY2U9bnVsbCxpLndpbmRpbmc9MCxpLmFjdGl2ZVJlZ2lvbj1udWxsLGF9LHNwbGljZV86ZnVuY3Rpb24obixhKXt2YXIgaT1uLk9uZXh0LG89YS5PbmV4dDtpLlN5bS5MbmV4dD1hLG8uU3ltLkxuZXh0PW4sbi5PbmV4dD1vLGEuT25leHQ9aX0sbWFrZVZlcnRleF86ZnVuY3Rpb24obixhLGkpe3ZhciBvPW47ZyhvIT09bnVsbCk7dmFyIFQ9aS5wcmV2O28ucHJldj1ULFQubmV4dD1vLG8ubmV4dD1pLGkucHJldj1vLG8uYW5FZGdlPWE7dmFyIFA9YTtkbyBQLk9yZz1vLFA9UC5PbmV4dDt3aGlsZShQIT09YSl9LG1ha2VGYWNlXzpmdW5jdGlvbihuLGEsaSl7dmFyIG89bjtnKG8hPT1udWxsKTt2YXIgVD1pLnByZXY7by5wcmV2PVQsVC5uZXh0PW8sby5uZXh0PWksaS5wcmV2PW8sby5hbkVkZ2U9YSxvLnRyYWlsPW51bGwsby5tYXJrZWQ9ITEsby5pbnNpZGU9aS5pbnNpZGU7dmFyIFA9YTtkbyBQLkxmYWNlPW8sUD1QLkxuZXh0O3doaWxlKFAhPT1hKX0sa2lsbEVkZ2VfOmZ1bmN0aW9uKG4pe24uU3ltLnNpZGU8bi5zaWRlJiYobj1uLlN5bSk7dmFyIGE9bi5uZXh0LGk9bi5TeW0ubmV4dDthLlN5bS5uZXh0PWksaS5TeW0ubmV4dD1hfSxraWxsVmVydGV4XzpmdW5jdGlvbihuLGEpe3ZhciBpPW4uYW5FZGdlLG89aTtkbyBvLk9yZz1hLG89by5PbmV4dDt3aGlsZShvIT09aSk7dmFyIFQ9bi5wcmV2LFA9bi5uZXh0O1AucHJldj1ULFQubmV4dD1QfSxraWxsRmFjZV86ZnVuY3Rpb24obixhKXt2YXIgaT1uLmFuRWRnZSxvPWk7ZG8gby5MZmFjZT1hLG89by5MbmV4dDt3aGlsZShvIT09aSk7dmFyIFQ9bi5wcmV2LFA9bi5uZXh0O1AucHJldj1ULFQubmV4dD1QfSxtYWtlRWRnZTpmdW5jdGlvbigpe3ZhciBuPW5ldyB2LGE9bmV3IHYsaT1uZXcgaCxvPXRoaXMubWFrZUVkZ2VfKHRoaXMuZUhlYWQpO3JldHVybiB0aGlzLm1ha2VWZXJ0ZXhfKG4sbyx0aGlzLnZIZWFkKSx0aGlzLm1ha2VWZXJ0ZXhfKGEsby5TeW0sdGhpcy52SGVhZCksdGhpcy5tYWtlRmFjZV8oaSxvLHRoaXMuZkhlYWQpLG99LHNwbGljZTpmdW5jdGlvbihuLGEpe3ZhciBpPSExLG89ITE7aWYobiE9PWEpe2lmKGEuT3JnIT09bi5PcmcmJihvPSEwLHRoaXMua2lsbFZlcnRleF8oYS5Pcmcsbi5PcmcpKSxhLkxmYWNlIT09bi5MZmFjZSYmKGk9ITAsdGhpcy5raWxsRmFjZV8oYS5MZmFjZSxuLkxmYWNlKSksdGhpcy5zcGxpY2VfKGEsbiksIW8pe3ZhciBUPW5ldyB2O3RoaXMubWFrZVZlcnRleF8oVCxhLG4uT3JnKSxuLk9yZy5hbkVkZ2U9bn1pZighaSl7dmFyIFA9bmV3IGg7dGhpcy5tYWtlRmFjZV8oUCxhLG4uTGZhY2UpLG4uTGZhY2UuYW5FZGdlPW59fX0sZGVsZXRlOmZ1bmN0aW9uKG4pe3ZhciBhPW4uU3ltLGk9ITE7aWYobi5MZmFjZSE9PW4uUmZhY2UmJihpPSEwLHRoaXMua2lsbEZhY2VfKG4uTGZhY2Usbi5SZmFjZSkpLG4uT25leHQ9PT1uKXRoaXMua2lsbFZlcnRleF8obi5PcmcsbnVsbCk7ZWxzZSBpZihuLlJmYWNlLmFuRWRnZT1uLk9wcmV2LG4uT3JnLmFuRWRnZT1uLk9uZXh0LHRoaXMuc3BsaWNlXyhuLG4uT3ByZXYpLCFpKXt2YXIgbz1uZXcgaDt0aGlzLm1ha2VGYWNlXyhvLG4sbi5MZmFjZSl9YS5PbmV4dD09PWE/KHRoaXMua2lsbFZlcnRleF8oYS5PcmcsbnVsbCksdGhpcy5raWxsRmFjZV8oYS5MZmFjZSxudWxsKSk6KG4uTGZhY2UuYW5FZGdlPWEuT3ByZXYsYS5PcmcuYW5FZGdlPWEuT25leHQsdGhpcy5zcGxpY2VfKGEsYS5PcHJldikpLHRoaXMua2lsbEVkZ2VfKG4pfSxhZGRFZGdlVmVydGV4OmZ1bmN0aW9uKG4pe3ZhciBhPXRoaXMubWFrZUVkZ2VfKG4pLGk9YS5TeW07dGhpcy5zcGxpY2VfKGEsbi5MbmV4dCksYS5Pcmc9bi5Ec3Q7dmFyIG89bmV3IHY7cmV0dXJuIHRoaXMubWFrZVZlcnRleF8obyxpLGEuT3JnKSxhLkxmYWNlPWkuTGZhY2U9bi5MZmFjZSxhfSxzcGxpdEVkZ2U6ZnVuY3Rpb24obixhKXt2YXIgaT10aGlzLmFkZEVkZ2VWZXJ0ZXgobiksbz1pLlN5bTtyZXR1cm4gdGhpcy5zcGxpY2VfKG4uU3ltLG4uU3ltLk9wcmV2KSx0aGlzLnNwbGljZV8obi5TeW0sbyksbi5Ec3Q9by5Pcmcsby5Ec3QuYW5FZGdlPW8uU3ltLG8uUmZhY2U9bi5SZmFjZSxvLndpbmRpbmc9bi53aW5kaW5nLG8uU3ltLndpbmRpbmc9bi5TeW0ud2luZGluZyxvfSxjb25uZWN0OmZ1bmN0aW9uKG4sYSl7dmFyIGk9ITEsbz10aGlzLm1ha2VFZGdlXyhuKSxUPW8uU3ltO2lmKGEuTGZhY2UhPT1uLkxmYWNlJiYoaT0hMCx0aGlzLmtpbGxGYWNlXyhhLkxmYWNlLG4uTGZhY2UpKSx0aGlzLnNwbGljZV8obyxuLkxuZXh0KSx0aGlzLnNwbGljZV8oVCxhKSxvLk9yZz1uLkRzdCxULk9yZz1hLk9yZyxvLkxmYWNlPVQuTGZhY2U9bi5MZmFjZSxuLkxmYWNlLmFuRWRnZT1ULCFpKXt2YXIgUD1uZXcgaDt0aGlzLm1ha2VGYWNlXyhQLG8sbi5MZmFjZSl9cmV0dXJuIG99LHphcEZhY2U6ZnVuY3Rpb24obil7dmFyIGE9bi5hbkVkZ2UsaSxvLFQsUCxDO289YS5MbmV4dDtkbyBpPW8sbz1pLkxuZXh0LGkuTGZhY2U9bnVsbCxpLlJmYWNlPT09bnVsbCYmKGkuT25leHQ9PT1pP3RoaXMua2lsbFZlcnRleF8oaS5PcmcsbnVsbCk6KGkuT3JnLmFuRWRnZT1pLk9uZXh0LHRoaXMuc3BsaWNlXyhpLGkuT3ByZXYpKSxUPWkuU3ltLFQuT25leHQ9PT1UP3RoaXMua2lsbFZlcnRleF8oVC5PcmcsbnVsbCk6KFQuT3JnLmFuRWRnZT1ULk9uZXh0LHRoaXMuc3BsaWNlXyhULFQuT3ByZXYpKSx0aGlzLmtpbGxFZGdlXyhpKSk7d2hpbGUoaSE9YSk7UD1uLnByZXYsQz1uLm5leHQsQy5wcmV2PVAsUC5uZXh0PUN9LGNvdW50RmFjZVZlcnRzXzpmdW5jdGlvbihuKXt2YXIgYT1uLmFuRWRnZSxpPTA7ZG8gaSsrLGE9YS5MbmV4dDt3aGlsZShhIT09bi5hbkVkZ2UpO3JldHVybiBpfSxtZXJnZUNvbnZleEZhY2VzOmZ1bmN0aW9uKG4pe3ZhciBhLGksbyxULFAsQyxJO2ZvcihhPXRoaXMuZkhlYWQubmV4dDthIT09dGhpcy5mSGVhZDthPWEubmV4dClpZihhLmluc2lkZSlmb3IoaT1hLmFuRWRnZSxQPWkuT3JnO289aS5MbmV4dCxUPWkuU3ltLFQmJlQuTGZhY2UmJlQuTGZhY2UuaW5zaWRlJiYoQz10aGlzLmNvdW50RmFjZVZlcnRzXyhhKSxJPXRoaXMuY291bnRGYWNlVmVydHNfKFQuTGZhY2UpLEMrSS0yPD1uJiZzLnZlcnRDQ1coaS5McHJldi5PcmcsaS5PcmcsVC5MbmV4dC5MbmV4dC5PcmcpJiZzLnZlcnRDQ1coVC5McHJldi5PcmcsVC5PcmcsaS5MbmV4dC5MbmV4dC5PcmcpJiYobz1ULkxuZXh0LHRoaXMuZGVsZXRlKFQpLGk9bnVsbCxUPW51bGwpKSwhKGkmJmkuTG5leHQuT3JnPT09UCk7KWk9bztyZXR1cm4hMH0sY2hlY2s6ZnVuY3Rpb24oKXt2YXIgbj10aGlzLmZIZWFkLGE9dGhpcy52SGVhZCxpPXRoaXMuZUhlYWQsbyxULFAsQyxJLEE7Zm9yKFQ9bixUPW47KG89VC5uZXh0KSE9PW47VD1vKXtnKG8ucHJldj09PVQpLEk9by5hbkVkZ2U7ZG8gZyhJLlN5bSE9PUkpLGcoSS5TeW0uU3ltPT09SSksZyhJLkxuZXh0Lk9uZXh0LlN5bT09PUkpLGcoSS5PbmV4dC5TeW0uTG5leHQ9PT1JKSxnKEkuTGZhY2U9PT1vKSxJPUkuTG5leHQ7d2hpbGUoSSE9PW8uYW5FZGdlKX1mb3IoZyhvLnByZXY9PT1UJiZvLmFuRWRnZT09PW51bGwpLEM9YSxDPWE7KFA9Qy5uZXh0KSE9PWE7Qz1QKXtnKFAucHJldj09PUMpLEk9UC5hbkVkZ2U7ZG8gZyhJLlN5bSE9PUkpLGcoSS5TeW0uU3ltPT09SSksZyhJLkxuZXh0Lk9uZXh0LlN5bT09PUkpLGcoSS5PbmV4dC5TeW0uTG5leHQ9PT1JKSxnKEkuT3JnPT09UCksST1JLk9uZXh0O3doaWxlKEkhPT1QLmFuRWRnZSl9Zm9yKGcoUC5wcmV2PT09QyYmUC5hbkVkZ2U9PT1udWxsKSxBPWksQT1pOyhJPUEubmV4dCkhPT1pO0E9SSlnKEkuU3ltLm5leHQ9PT1BLlN5bSksZyhJLlN5bSE9PUkpLGcoSS5TeW0uU3ltPT09SSksZyhJLk9yZyE9PW51bGwpLGcoSS5Ec3QhPT1udWxsKSxnKEkuTG5leHQuT25leHQuU3ltPT09SSksZyhJLk9uZXh0LlN5bS5MbmV4dD09PUkpO2coSS5TeW0ubmV4dD09PUEuU3ltJiZJLlN5bT09PXRoaXMuZUhlYWRTeW0mJkkuU3ltLlN5bT09PUkmJkkuT3JnPT09bnVsbCYmSS5Ec3Q9PT1udWxsJiZJLkxmYWNlPT09bnVsbCYmSS5SZmFjZT09PW51bGwpfX0scy52ZXJ0RXE9ZnVuY3Rpb24obixhKXtyZXR1cm4gbi5zPT09YS5zJiZuLnQ9PT1hLnR9LHMudmVydExlcT1mdW5jdGlvbihuLGEpe3JldHVybiBuLnM8YS5zfHxuLnM9PT1hLnMmJm4udDw9YS50fSxzLnRyYW5zTGVxPWZ1bmN0aW9uKG4sYSl7cmV0dXJuIG4udDxhLnR8fG4udD09PWEudCYmbi5zPD1hLnN9LHMuZWRnZUdvZXNMZWZ0PWZ1bmN0aW9uKG4pe3JldHVybiBzLnZlcnRMZXEobi5Ec3Qsbi5PcmcpfSxzLmVkZ2VHb2VzUmlnaHQ9ZnVuY3Rpb24obil7cmV0dXJuIHMudmVydExlcShuLk9yZyxuLkRzdCl9LHMudmVydEwxZGlzdD1mdW5jdGlvbihuLGEpe3JldHVybiBNYXRoLmFicyhuLnMtYS5zKStNYXRoLmFicyhuLnQtYS50KX0scy5lZGdlRXZhbD1mdW5jdGlvbihuLGEsaSl7ZyhzLnZlcnRMZXEobixhKSYmcy52ZXJ0TGVxKGEsaSkpO3ZhciBvPWEucy1uLnMsVD1pLnMtYS5zO3JldHVybiBvK1Q+MD9vPFQ/YS50LW4udCsobi50LWkudCkqKG8vKG8rVCkpOmEudC1pLnQrKGkudC1uLnQpKihULyhvK1QpKTowfSxzLmVkZ2VTaWduPWZ1bmN0aW9uKG4sYSxpKXtnKHMudmVydExlcShuLGEpJiZzLnZlcnRMZXEoYSxpKSk7dmFyIG89YS5zLW4ucyxUPWkucy1hLnM7cmV0dXJuIG8rVD4wPyhhLnQtaS50KSpvKyhhLnQtbi50KSpUOjB9LHMudHJhbnNFdmFsPWZ1bmN0aW9uKG4sYSxpKXtnKHMudHJhbnNMZXEobixhKSYmcy50cmFuc0xlcShhLGkpKTt2YXIgbz1hLnQtbi50LFQ9aS50LWEudDtyZXR1cm4gbytUPjA/bzxUP2Eucy1uLnMrKG4ucy1pLnMpKihvLyhvK1QpKTphLnMtaS5zKyhpLnMtbi5zKSooVC8obytUKSk6MH0scy50cmFuc1NpZ249ZnVuY3Rpb24obixhLGkpe2cocy50cmFuc0xlcShuLGEpJiZzLnRyYW5zTGVxKGEsaSkpO3ZhciBvPWEudC1uLnQsVD1pLnQtYS50O3JldHVybiBvK1Q+MD8oYS5zLWkucykqbysoYS5zLW4ucykqVDowfSxzLnZlcnRDQ1c9ZnVuY3Rpb24obixhLGkpe3JldHVybiBuLnMqKGEudC1pLnQpK2EucyooaS50LW4udCkraS5zKihuLnQtYS50KT49MH0scy5pbnRlcnBvbGF0ZT1mdW5jdGlvbihuLGEsaSxvKXtyZXR1cm4gbj1uPDA/MDpuLGk9aTwwPzA6aSxuPD1pP2k9PT0wPyhhK28pLzI6YSsoby1hKSoobi8obitpKSk6bysoYS1vKSooaS8obitpKSl9LHMuaW50ZXJzZWN0PWZ1bmN0aW9uKG4sYSxpLG8sVCl7dmFyIFAsQyxJO3MudmVydExlcShuLGEpfHwoST1uLG49YSxhPUkpLHMudmVydExlcShpLG8pfHwoST1pLGk9byxvPUkpLHMudmVydExlcShuLGkpfHwoST1uLG49aSxpPUksST1hLGE9byxvPUkpLHMudmVydExlcShpLGEpP3MudmVydExlcShhLG8pPyhQPXMuZWRnZUV2YWwobixpLGEpLEM9cy5lZGdlRXZhbChpLGEsbyksUCtDPDAmJihQPS1QLEM9LUMpLFQucz1zLmludGVycG9sYXRlKFAsaS5zLEMsYS5zKSk6KFA9cy5lZGdlU2lnbihuLGksYSksQz0tcy5lZGdlU2lnbihuLG8sYSksUCtDPDAmJihQPS1QLEM9LUMpLFQucz1zLmludGVycG9sYXRlKFAsaS5zLEMsby5zKSk6VC5zPShpLnMrYS5zKS8yLHMudHJhbnNMZXEobixhKXx8KEk9bixuPWEsYT1JKSxzLnRyYW5zTGVxKGksbyl8fChJPWksaT1vLG89SSkscy50cmFuc0xlcShuLGkpfHwoST1uLG49aSxpPUksST1hLGE9byxvPUkpLHMudHJhbnNMZXEoaSxhKT9zLnRyYW5zTGVxKGEsbyk/KFA9cy50cmFuc0V2YWwobixpLGEpLEM9cy50cmFuc0V2YWwoaSxhLG8pLFArQzwwJiYoUD0tUCxDPS1DKSxULnQ9cy5pbnRlcnBvbGF0ZShQLGkudCxDLGEudCkpOihQPXMudHJhbnNTaWduKG4saSxhKSxDPS1zLnRyYW5zU2lnbihuLG8sYSksUCtDPDAmJihQPS1QLEM9LUMpLFQudD1zLmludGVycG9sYXRlKFAsaS50LEMsby50KSk6VC50PShpLnQrYS50KS8yfTtmdW5jdGlvbiBNKCl7dGhpcy5rZXk9bnVsbCx0aGlzLm5leHQ9bnVsbCx0aGlzLnByZXY9bnVsbH1mdW5jdGlvbiBmKG4sYSl7dGhpcy5oZWFkPW5ldyBNLHRoaXMuaGVhZC5uZXh0PXRoaXMuaGVhZCx0aGlzLmhlYWQucHJldj10aGlzLmhlYWQsdGhpcy5mcmFtZT1uLHRoaXMubGVxPWF9Zi5wcm90b3R5cGU9e21pbjpmdW5jdGlvbigpe3JldHVybiB0aGlzLmhlYWQubmV4dH0sbWF4OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaGVhZC5wcmV2fSxpbnNlcnQ6ZnVuY3Rpb24obil7cmV0dXJuIHRoaXMuaW5zZXJ0QmVmb3JlKHRoaXMuaGVhZCxuKX0sc2VhcmNoOmZ1bmN0aW9uKG4pe3ZhciBhPXRoaXMuaGVhZDtkbyBhPWEubmV4dDt3aGlsZShhLmtleSE9PW51bGwmJiF0aGlzLmxlcSh0aGlzLmZyYW1lLG4sYS5rZXkpKTtyZXR1cm4gYX0saW5zZXJ0QmVmb3JlOmZ1bmN0aW9uKG4sYSl7ZG8gbj1uLnByZXY7d2hpbGUobi5rZXkhPT1udWxsJiYhdGhpcy5sZXEodGhpcy5mcmFtZSxuLmtleSxhKSk7dmFyIGk9bmV3IE07cmV0dXJuIGkua2V5PWEsaS5uZXh0PW4ubmV4dCxuLm5leHQucHJldj1pLGkucHJldj1uLG4ubmV4dD1pLGl9LGRlbGV0ZTpmdW5jdGlvbihuKXtuLm5leHQucHJldj1uLnByZXYsbi5wcmV2Lm5leHQ9bi5uZXh0fX07ZnVuY3Rpb24geSgpe3RoaXMuaGFuZGxlPW51bGx9ZnVuY3Rpb24geCgpe3RoaXMua2V5PW51bGwsdGhpcy5ub2RlPW51bGx9ZnVuY3Rpb24gYihuLGEpe3RoaXMuc2l6ZT0wLHRoaXMubWF4PW4sdGhpcy5ub2Rlcz1bXSx0aGlzLm5vZGVzLmxlbmd0aD1uKzE7dmFyIGk7Zm9yKGk9MDtpPHRoaXMubm9kZXMubGVuZ3RoO2krKyl0aGlzLm5vZGVzW2ldPW5ldyB5O2Zvcih0aGlzLmhhbmRsZXM9W10sdGhpcy5oYW5kbGVzLmxlbmd0aD1uKzEsaT0wO2k8dGhpcy5oYW5kbGVzLmxlbmd0aDtpKyspdGhpcy5oYW5kbGVzW2ldPW5ldyB4O3RoaXMuaW5pdGlhbGl6ZWQ9ITEsdGhpcy5mcmVlTGlzdD0wLHRoaXMubGVxPWEsdGhpcy5ub2Rlc1sxXS5oYW5kbGU9MSx0aGlzLmhhbmRsZXNbMV0ua2V5PW51bGx9Yi5wcm90b3R5cGU9e2Zsb2F0RG93bl86ZnVuY3Rpb24obil7dmFyIGE9dGhpcy5ub2RlcyxpPXRoaXMuaGFuZGxlcyxvLFQsUDtmb3Iobz1hW25dLmhhbmRsZTs7KXtpZihQPW48PDEsUDx0aGlzLnNpemUmJnRoaXMubGVxKGlbYVtQKzFdLmhhbmRsZV0ua2V5LGlbYVtQXS5oYW5kbGVdLmtleSkmJisrUCxnKFA8PXRoaXMubWF4KSxUPWFbUF0uaGFuZGxlLFA+dGhpcy5zaXplfHx0aGlzLmxlcShpW29dLmtleSxpW1RdLmtleSkpe2Fbbl0uaGFuZGxlPW8saVtvXS5ub2RlPW47YnJlYWt9YVtuXS5oYW5kbGU9VCxpW1RdLm5vZGU9bixuPVB9fSxmbG9hdFVwXzpmdW5jdGlvbihuKXt2YXIgYT10aGlzLm5vZGVzLGk9dGhpcy5oYW5kbGVzLG8sVCxQO2ZvcihvPWFbbl0uaGFuZGxlOzspe2lmKFA9bj4+MSxUPWFbUF0uaGFuZGxlLFA9PT0wfHx0aGlzLmxlcShpW1RdLmtleSxpW29dLmtleSkpe2Fbbl0uaGFuZGxlPW8saVtvXS5ub2RlPW47YnJlYWt9YVtuXS5oYW5kbGU9VCxpW1RdLm5vZGU9bixuPVB9fSxpbml0OmZ1bmN0aW9uKCl7Zm9yKHZhciBuPXRoaXMuc2l6ZTtuPj0xOy0tbil0aGlzLmZsb2F0RG93bl8obik7dGhpcy5pbml0aWFsaXplZD0hMH0sbWluOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaGFuZGxlc1t0aGlzLm5vZGVzWzFdLmhhbmRsZV0ua2V5fSxpbnNlcnQ6ZnVuY3Rpb24obil7dmFyIGEsaTtpZihhPSsrdGhpcy5zaXplLGEqMj50aGlzLm1heCl7dGhpcy5tYXgqPTI7dmFyIG8sVDtmb3IoVD10aGlzLm5vZGVzLmxlbmd0aCx0aGlzLm5vZGVzLmxlbmd0aD10aGlzLm1heCsxLG89VDtvPHRoaXMubm9kZXMubGVuZ3RoO28rKyl0aGlzLm5vZGVzW29dPW5ldyB5O2ZvcihUPXRoaXMuaGFuZGxlcy5sZW5ndGgsdGhpcy5oYW5kbGVzLmxlbmd0aD10aGlzLm1heCsxLG89VDtvPHRoaXMuaGFuZGxlcy5sZW5ndGg7bysrKXRoaXMuaGFuZGxlc1tvXT1uZXcgeH1yZXR1cm4gdGhpcy5mcmVlTGlzdD09PTA/aT1hOihpPXRoaXMuZnJlZUxpc3QsdGhpcy5mcmVlTGlzdD10aGlzLmhhbmRsZXNbaV0ubm9kZSksdGhpcy5ub2Rlc1thXS5oYW5kbGU9aSx0aGlzLmhhbmRsZXNbaV0ubm9kZT1hLHRoaXMuaGFuZGxlc1tpXS5rZXk9bix0aGlzLmluaXRpYWxpemVkJiZ0aGlzLmZsb2F0VXBfKGEpLGl9LGV4dHJhY3RNaW46ZnVuY3Rpb24oKXt2YXIgbj10aGlzLm5vZGVzLGE9dGhpcy5oYW5kbGVzLGk9blsxXS5oYW5kbGUsbz1hW2ldLmtleTtyZXR1cm4gdGhpcy5zaXplPjAmJihuWzFdLmhhbmRsZT1uW3RoaXMuc2l6ZV0uaGFuZGxlLGFbblsxXS5oYW5kbGVdLm5vZGU9MSxhW2ldLmtleT1udWxsLGFbaV0ubm9kZT10aGlzLmZyZWVMaXN0LHRoaXMuZnJlZUxpc3Q9aSwtLXRoaXMuc2l6ZSx0aGlzLnNpemU+MCYmdGhpcy5mbG9hdERvd25fKDEpKSxvfSxkZWxldGU6ZnVuY3Rpb24obil7dmFyIGE9dGhpcy5ub2RlcyxpPXRoaXMuaGFuZGxlcyxvO2cobj49MSYmbjw9dGhpcy5tYXgmJmlbbl0ua2V5IT09bnVsbCksbz1pW25dLm5vZGUsYVtvXS5oYW5kbGU9YVt0aGlzLnNpemVdLmhhbmRsZSxpW2Fbb10uaGFuZGxlXS5ub2RlPW8sLS10aGlzLnNpemUsbzw9dGhpcy5zaXplJiYobzw9MXx8dGhpcy5sZXEoaVthW28+PjFdLmhhbmRsZV0ua2V5LGlbYVtvXS5oYW5kbGVdLmtleSk/dGhpcy5mbG9hdERvd25fKG8pOnRoaXMuZmxvYXRVcF8obykpLGlbbl0ua2V5PW51bGwsaVtuXS5ub2RlPXRoaXMuZnJlZUxpc3QsdGhpcy5mcmVlTGlzdD1ufX07ZnVuY3Rpb24gTygpe3RoaXMuZVVwPW51bGwsdGhpcy5ub2RlVXA9bnVsbCx0aGlzLndpbmRpbmdOdW1iZXI9MCx0aGlzLmluc2lkZT0hMSx0aGlzLnNlbnRpbmVsPSExLHRoaXMuZGlydHk9ITEsdGhpcy5maXhVcHBlckVkZ2U9ITF9dmFyIG09e307bS5yZWdpb25CZWxvdz1mdW5jdGlvbihuKXtyZXR1cm4gbi5ub2RlVXAucHJldi5rZXl9LG0ucmVnaW9uQWJvdmU9ZnVuY3Rpb24obil7cmV0dXJuIG4ubm9kZVVwLm5leHQua2V5fSxtLmRlYnVnRXZlbnQ9ZnVuY3Rpb24obil7fSxtLmFkZFdpbmRpbmc9ZnVuY3Rpb24obixhKXtuLndpbmRpbmcrPWEud2luZGluZyxuLlN5bS53aW5kaW5nKz1hLlN5bS53aW5kaW5nfSxtLmVkZ2VMZXE9ZnVuY3Rpb24obixhLGkpe3ZhciBvPW4uZXZlbnQsQyxJLFQ9YS5lVXAsUD1pLmVVcDtpZihULkRzdD09PW8pcmV0dXJuIFAuRHN0PT09bz9zLnZlcnRMZXEoVC5PcmcsUC5PcmcpP3MuZWRnZVNpZ24oUC5Ec3QsVC5PcmcsUC5PcmcpPD0wOnMuZWRnZVNpZ24oVC5Ec3QsUC5PcmcsVC5PcmcpPj0wOnMuZWRnZVNpZ24oUC5Ec3QsbyxQLk9yZyk8PTA7aWYoUC5Ec3Q9PT1vKXJldHVybiBzLmVkZ2VTaWduKFQuRHN0LG8sVC5PcmcpPj0wO3ZhciBDPXMuZWRnZUV2YWwoVC5Ec3QsbyxULk9yZyksST1zLmVkZ2VFdmFsKFAuRHN0LG8sUC5PcmcpO3JldHVybiBDPj1JfSxtLmRlbGV0ZVJlZ2lvbj1mdW5jdGlvbihuLGEpe2EuZml4VXBwZXJFZGdlJiZnKGEuZVVwLndpbmRpbmc9PT0wKSxhLmVVcC5hY3RpdmVSZWdpb249bnVsbCxuLmRpY3QuZGVsZXRlKGEubm9kZVVwKX0sbS5maXhVcHBlckVkZ2U9ZnVuY3Rpb24obixhLGkpe2coYS5maXhVcHBlckVkZ2UpLG4ubWVzaC5kZWxldGUoYS5lVXApLGEuZml4VXBwZXJFZGdlPSExLGEuZVVwPWksaS5hY3RpdmVSZWdpb249YX0sbS50b3BMZWZ0UmVnaW9uPWZ1bmN0aW9uKG4sYSl7dmFyIGk9YS5lVXAuT3JnLG87ZG8gYT1tLnJlZ2lvbkFib3ZlKGEpO3doaWxlKGEuZVVwLk9yZz09PWkpO2lmKGEuZml4VXBwZXJFZGdlKXtpZihvPW4ubWVzaC5jb25uZWN0KG0ucmVnaW9uQmVsb3coYSkuZVVwLlN5bSxhLmVVcC5MbmV4dCksbz09PW51bGwpcmV0dXJuIG51bGw7bS5maXhVcHBlckVkZ2UobixhLG8pLGE9bS5yZWdpb25BYm92ZShhKX1yZXR1cm4gYX0sbS50b3BSaWdodFJlZ2lvbj1mdW5jdGlvbihuKXt2YXIgYT1uLmVVcC5Ec3Q7ZG8gbj1tLnJlZ2lvbkFib3ZlKG4pO3doaWxlKG4uZVVwLkRzdD09PWEpO3JldHVybiBufSxtLmFkZFJlZ2lvbkJlbG93PWZ1bmN0aW9uKG4sYSxpKXt2YXIgbz1uZXcgTztyZXR1cm4gby5lVXA9aSxvLm5vZGVVcD1uLmRpY3QuaW5zZXJ0QmVmb3JlKGEubm9kZVVwLG8pLG8uZml4VXBwZXJFZGdlPSExLG8uc2VudGluZWw9ITEsby5kaXJ0eT0hMSxpLmFjdGl2ZVJlZ2lvbj1vLG99LG0uaXNXaW5kaW5nSW5zaWRlPWZ1bmN0aW9uKG4sYSl7c3dpdGNoKG4ud2luZGluZ1J1bGUpe2Nhc2Ugci5XSU5ESU5HX09ERDpyZXR1cm4oYSYxKSE9PTA7Y2FzZSByLldJTkRJTkdfTk9OWkVSTzpyZXR1cm4gYSE9PTA7Y2FzZSByLldJTkRJTkdfUE9TSVRJVkU6cmV0dXJuIGE+MDtjYXNlIHIuV0lORElOR19ORUdBVElWRTpyZXR1cm4gYTwwO2Nhc2Ugci5XSU5ESU5HX0FCU19HRVFfVFdPOnJldHVybiBhPj0yfHxhPD0tMn1yZXR1cm4gZyghMSksITF9LG0uY29tcHV0ZVdpbmRpbmc9ZnVuY3Rpb24obixhKXthLndpbmRpbmdOdW1iZXI9bS5yZWdpb25BYm92ZShhKS53aW5kaW5nTnVtYmVyK2EuZVVwLndpbmRpbmcsYS5pbnNpZGU9bS5pc1dpbmRpbmdJbnNpZGUobixhLndpbmRpbmdOdW1iZXIpfSxtLmZpbmlzaFJlZ2lvbj1mdW5jdGlvbihuLGEpe3ZhciBpPWEuZVVwLG89aS5MZmFjZTtvLmluc2lkZT1hLmluc2lkZSxvLmFuRWRnZT1pLG0uZGVsZXRlUmVnaW9uKG4sYSl9LG0uZmluaXNoTGVmdFJlZ2lvbnM9ZnVuY3Rpb24obixhLGkpe2Zvcih2YXIgbyxDLFQ9bnVsbCxQPWEsQz1hLmVVcDtQIT09aTspe2lmKFAuZml4VXBwZXJFZGdlPSExLFQ9bS5yZWdpb25CZWxvdyhQKSxvPVQuZVVwLG8uT3JnIT1DLk9yZyl7aWYoIVQuZml4VXBwZXJFZGdlKXttLmZpbmlzaFJlZ2lvbihuLFApO2JyZWFrfW89bi5tZXNoLmNvbm5lY3QoQy5McHJldixvLlN5bSksbS5maXhVcHBlckVkZ2UobixULG8pfUMuT25leHQhPT1vJiYobi5tZXNoLnNwbGljZShvLk9wcmV2LG8pLG4ubWVzaC5zcGxpY2UoQyxvKSksbS5maW5pc2hSZWdpb24obixQKSxDPVQuZVVwLFA9VH1yZXR1cm4gQ30sbS5hZGRSaWdodEVkZ2VzPWZ1bmN0aW9uKG4sYSxpLG8sVCxQKXt2YXIgQyxJLEEsTCxEPSEwO0E9aTtkbyBnKHMudmVydExlcShBLk9yZyxBLkRzdCkpLG0uYWRkUmVnaW9uQmVsb3cobixhLEEuU3ltKSxBPUEuT25leHQ7d2hpbGUoQSE9PW8pO2ZvcihUPT09bnVsbCYmKFQ9bS5yZWdpb25CZWxvdyhhKS5lVXAuUnByZXYpLEk9YSxMPVQ7Qz1tLnJlZ2lvbkJlbG93KEkpLEE9Qy5lVXAuU3ltLEEuT3JnPT09TC5Pcmc7KUEuT25leHQhPT1MJiYobi5tZXNoLnNwbGljZShBLk9wcmV2LEEpLG4ubWVzaC5zcGxpY2UoTC5PcHJldixBKSksQy53aW5kaW5nTnVtYmVyPUkud2luZGluZ051bWJlci1BLndpbmRpbmcsQy5pbnNpZGU9bS5pc1dpbmRpbmdJbnNpZGUobixDLndpbmRpbmdOdW1iZXIpLEkuZGlydHk9ITAsIUQmJm0uY2hlY2tGb3JSaWdodFNwbGljZShuLEkpJiYobS5hZGRXaW5kaW5nKEEsTCksbS5kZWxldGVSZWdpb24obixJKSxuLm1lc2guZGVsZXRlKEwpKSxEPSExLEk9QyxMPUE7SS5kaXJ0eT0hMCxnKEkud2luZGluZ051bWJlci1BLndpbmRpbmc9PT1DLndpbmRpbmdOdW1iZXIpLFAmJm0ud2Fsa0RpcnR5UmVnaW9ucyhuLEkpfSxtLnNwbGljZU1lcmdlVmVydGljZXM9ZnVuY3Rpb24obixhLGkpe24ubWVzaC5zcGxpY2UoYSxpKX0sbS52ZXJ0ZXhXZWlnaHRzPWZ1bmN0aW9uKG4sYSxpKXt2YXIgbz1zLnZlcnRMMWRpc3QoYSxuKSxUPXMudmVydEwxZGlzdChpLG4pLFA9LjUqVC8obytUKSxDPS41Km8vKG8rVCk7bi5jb29yZHNbMF0rPVAqYS5jb29yZHNbMF0rQyppLmNvb3Jkc1swXSxuLmNvb3Jkc1sxXSs9UCphLmNvb3Jkc1sxXStDKmkuY29vcmRzWzFdLG4uY29vcmRzWzJdKz1QKmEuY29vcmRzWzJdK0MqaS5jb29yZHNbMl19LG0uZ2V0SW50ZXJzZWN0RGF0YT1mdW5jdGlvbihuLGEsaSxvLFQsUCl7YS5jb29yZHNbMF09YS5jb29yZHNbMV09YS5jb29yZHNbMl09MCxhLmlkeD0tMSxtLnZlcnRleFdlaWdodHMoYSxpLG8pLG0udmVydGV4V2VpZ2h0cyhhLFQsUCl9LG0uY2hlY2tGb3JSaWdodFNwbGljZT1mdW5jdGlvbihuLGEpe3ZhciBpPW0ucmVnaW9uQmVsb3coYSksbz1hLmVVcCxUPWkuZVVwO2lmKHMudmVydExlcShvLk9yZyxULk9yZykpe2lmKHMuZWRnZVNpZ24oVC5Ec3Qsby5PcmcsVC5PcmcpPjApcmV0dXJuITE7cy52ZXJ0RXEoby5PcmcsVC5PcmcpP28uT3JnIT09VC5PcmcmJihuLnBxLmRlbGV0ZShvLk9yZy5wcUhhbmRsZSksbS5zcGxpY2VNZXJnZVZlcnRpY2VzKG4sVC5PcHJldixvKSk6KG4ubWVzaC5zcGxpdEVkZ2UoVC5TeW0pLG4ubWVzaC5zcGxpY2UobyxULk9wcmV2KSxhLmRpcnR5PWkuZGlydHk9ITApfWVsc2V7aWYocy5lZGdlU2lnbihvLkRzdCxULk9yZyxvLk9yZyk8MClyZXR1cm4hMTttLnJlZ2lvbkFib3ZlKGEpLmRpcnR5PWEuZGlydHk9ITAsbi5tZXNoLnNwbGl0RWRnZShvLlN5bSksbi5tZXNoLnNwbGljZShULk9wcmV2LG8pfXJldHVybiEwfSxtLmNoZWNrRm9yTGVmdFNwbGljZT1mdW5jdGlvbihuLGEpe3ZhciBpPW0ucmVnaW9uQmVsb3coYSksbz1hLmVVcCxUPWkuZVVwLFA7aWYoZyghcy52ZXJ0RXEoby5Ec3QsVC5Ec3QpKSxzLnZlcnRMZXEoby5Ec3QsVC5Ec3QpKXtpZihzLmVkZ2VTaWduKG8uRHN0LFQuRHN0LG8uT3JnKTwwKXJldHVybiExO20ucmVnaW9uQWJvdmUoYSkuZGlydHk9YS5kaXJ0eT0hMCxQPW4ubWVzaC5zcGxpdEVkZ2Uobyksbi5tZXNoLnNwbGljZShULlN5bSxQKSxQLkxmYWNlLmluc2lkZT1hLmluc2lkZX1lbHNle2lmKHMuZWRnZVNpZ24oVC5Ec3Qsby5Ec3QsVC5PcmcpPjApcmV0dXJuITE7YS5kaXJ0eT1pLmRpcnR5PSEwLFA9bi5tZXNoLnNwbGl0RWRnZShUKSxuLm1lc2guc3BsaWNlKG8uTG5leHQsVC5TeW0pLFAuUmZhY2UuaW5zaWRlPWEuaW5zaWRlfXJldHVybiEwfSxtLmNoZWNrRm9ySW50ZXJzZWN0PWZ1bmN0aW9uKG4sYSl7dmFyIGk9bS5yZWdpb25CZWxvdyhhKSxvPWEuZVVwLFQ9aS5lVXAsUD1vLk9yZyxDPVQuT3JnLEk9by5Ec3QsQT1ULkRzdCxMLEQsUj1uZXcgdixTLEI7aWYoZyghcy52ZXJ0RXEoQSxJKSksZyhzLmVkZ2VTaWduKEksbi5ldmVudCxQKTw9MCksZyhzLmVkZ2VTaWduKEEsbi5ldmVudCxDKT49MCksZyhQIT09bi5ldmVudCYmQyE9PW4uZXZlbnQpLGcoIWEuZml4VXBwZXJFZGdlJiYhaS5maXhVcHBlckVkZ2UpLFA9PT1DfHwoTD1NYXRoLm1pbihQLnQsSS50KSxEPU1hdGgubWF4KEMudCxBLnQpLEw+RCkpcmV0dXJuITE7aWYocy52ZXJ0TGVxKFAsQykpe2lmKHMuZWRnZVNpZ24oQSxQLEMpPjApcmV0dXJuITF9ZWxzZSBpZihzLmVkZ2VTaWduKEksQyxQKTwwKXJldHVybiExO3JldHVybiBtLmRlYnVnRXZlbnQobikscy5pbnRlcnNlY3QoSSxQLEEsQyxSKSxnKE1hdGgubWluKFAudCxJLnQpPD1SLnQpLGcoUi50PD1NYXRoLm1heChDLnQsQS50KSksZyhNYXRoLm1pbihBLnMsSS5zKTw9Ui5zKSxnKFIuczw9TWF0aC5tYXgoQy5zLFAucykpLHMudmVydExlcShSLG4uZXZlbnQpJiYoUi5zPW4uZXZlbnQucyxSLnQ9bi5ldmVudC50KSxTPXMudmVydExlcShQLEMpP1A6QyxzLnZlcnRMZXEoUyxSKSYmKFIucz1TLnMsUi50PVMudCkscy52ZXJ0RXEoUixQKXx8cy52ZXJ0RXEoUixDKT8obS5jaGVja0ZvclJpZ2h0U3BsaWNlKG4sYSksITEpOiFzLnZlcnRFcShJLG4uZXZlbnQpJiZzLmVkZ2VTaWduKEksbi5ldmVudCxSKT49MHx8IXMudmVydEVxKEEsbi5ldmVudCkmJnMuZWRnZVNpZ24oQSxuLmV2ZW50LFIpPD0wP0E9PT1uLmV2ZW50PyhuLm1lc2guc3BsaXRFZGdlKG8uU3ltKSxuLm1lc2guc3BsaWNlKFQuU3ltLG8pLGE9bS50b3BMZWZ0UmVnaW9uKG4sYSksbz1tLnJlZ2lvbkJlbG93KGEpLmVVcCxtLmZpbmlzaExlZnRSZWdpb25zKG4sbS5yZWdpb25CZWxvdyhhKSxpKSxtLmFkZFJpZ2h0RWRnZXMobixhLG8uT3ByZXYsbyxvLCEwKSwhMCk6ST09PW4uZXZlbnQ/KG4ubWVzaC5zcGxpdEVkZ2UoVC5TeW0pLG4ubWVzaC5zcGxpY2Uoby5MbmV4dCxULk9wcmV2KSxpPWEsYT1tLnRvcFJpZ2h0UmVnaW9uKGEpLEI9bS5yZWdpb25CZWxvdyhhKS5lVXAuUnByZXYsaS5lVXA9VC5PcHJldixUPW0uZmluaXNoTGVmdFJlZ2lvbnMobixpLG51bGwpLG0uYWRkUmlnaHRFZGdlcyhuLGEsVC5PbmV4dCxvLlJwcmV2LEIsITApLCEwKToocy5lZGdlU2lnbihJLG4uZXZlbnQsUik+PTAmJihtLnJlZ2lvbkFib3ZlKGEpLmRpcnR5PWEuZGlydHk9ITAsbi5tZXNoLnNwbGl0RWRnZShvLlN5bSksby5Pcmcucz1uLmV2ZW50LnMsby5PcmcudD1uLmV2ZW50LnQpLHMuZWRnZVNpZ24oQSxuLmV2ZW50LFIpPD0wJiYoYS5kaXJ0eT1pLmRpcnR5PSEwLG4ubWVzaC5zcGxpdEVkZ2UoVC5TeW0pLFQuT3JnLnM9bi5ldmVudC5zLFQuT3JnLnQ9bi5ldmVudC50KSwhMSk6KG4ubWVzaC5zcGxpdEVkZ2Uoby5TeW0pLG4ubWVzaC5zcGxpdEVkZ2UoVC5TeW0pLG4ubWVzaC5zcGxpY2UoVC5PcHJldixvKSxvLk9yZy5zPVIucyxvLk9yZy50PVIudCxvLk9yZy5wcUhhbmRsZT1uLnBxLmluc2VydChvLk9yZyksbS5nZXRJbnRlcnNlY3REYXRhKG4sby5PcmcsUCxJLEMsQSksbS5yZWdpb25BYm92ZShhKS5kaXJ0eT1hLmRpcnR5PWkuZGlydHk9ITAsITEpfSxtLndhbGtEaXJ0eVJlZ2lvbnM9ZnVuY3Rpb24obixhKXtmb3IodmFyIGk9bS5yZWdpb25CZWxvdyhhKSxvLFQ7Oyl7Zm9yKDtpLmRpcnR5OylhPWksaT1tLnJlZ2lvbkJlbG93KGkpO2lmKCFhLmRpcnR5JiYoaT1hLGE9bS5yZWdpb25BYm92ZShhKSxhPT09bnVsbHx8IWEuZGlydHkpKXJldHVybjtpZihhLmRpcnR5PSExLG89YS5lVXAsVD1pLmVVcCxvLkRzdCE9PVQuRHN0JiZtLmNoZWNrRm9yTGVmdFNwbGljZShuLGEpJiYoaS5maXhVcHBlckVkZ2U/KG0uZGVsZXRlUmVnaW9uKG4saSksbi5tZXNoLmRlbGV0ZShUKSxpPW0ucmVnaW9uQmVsb3coYSksVD1pLmVVcCk6YS5maXhVcHBlckVkZ2UmJihtLmRlbGV0ZVJlZ2lvbihuLGEpLG4ubWVzaC5kZWxldGUobyksYT1tLnJlZ2lvbkFib3ZlKGkpLG89YS5lVXApKSxvLk9yZyE9PVQuT3JnKWlmKG8uRHN0IT09VC5Ec3QmJiFhLmZpeFVwcGVyRWRnZSYmIWkuZml4VXBwZXJFZGdlJiYoby5Ec3Q9PT1uLmV2ZW50fHxULkRzdD09PW4uZXZlbnQpKXtpZihtLmNoZWNrRm9ySW50ZXJzZWN0KG4sYSkpcmV0dXJufWVsc2UgbS5jaGVja0ZvclJpZ2h0U3BsaWNlKG4sYSk7by5Pcmc9PT1ULk9yZyYmby5Ec3Q9PT1ULkRzdCYmKG0uYWRkV2luZGluZyhULG8pLG0uZGVsZXRlUmVnaW9uKG4sYSksbi5tZXNoLmRlbGV0ZShvKSxhPW0ucmVnaW9uQWJvdmUoaSkpfX0sbS5jb25uZWN0UmlnaHRWZXJ0ZXg9ZnVuY3Rpb24obixhLGkpe3ZhciBvLFQ9aS5PbmV4dCxQPW0ucmVnaW9uQmVsb3coYSksQz1hLmVVcCxJPVAuZVVwLEE9ITE7aWYoQy5Ec3QhPT1JLkRzdCYmbS5jaGVja0ZvckludGVyc2VjdChuLGEpLHMudmVydEVxKEMuT3JnLG4uZXZlbnQpJiYobi5tZXNoLnNwbGljZShULk9wcmV2LEMpLGE9bS50b3BMZWZ0UmVnaW9uKG4sYSksVD1tLnJlZ2lvbkJlbG93KGEpLmVVcCxtLmZpbmlzaExlZnRSZWdpb25zKG4sbS5yZWdpb25CZWxvdyhhKSxQKSxBPSEwKSxzLnZlcnRFcShJLk9yZyxuLmV2ZW50KSYmKG4ubWVzaC5zcGxpY2UoaSxJLk9wcmV2KSxpPW0uZmluaXNoTGVmdFJlZ2lvbnMobixQLG51bGwpLEE9ITApLEEpe20uYWRkUmlnaHRFZGdlcyhuLGEsaS5PbmV4dCxULFQsITApO3JldHVybn1zLnZlcnRMZXEoSS5PcmcsQy5PcmcpP289SS5PcHJldjpvPUMsbz1uLm1lc2guY29ubmVjdChpLkxwcmV2LG8pLG0uYWRkUmlnaHRFZGdlcyhuLGEsbyxvLk9uZXh0LG8uT25leHQsITEpLG8uU3ltLmFjdGl2ZVJlZ2lvbi5maXhVcHBlckVkZ2U9ITAsbS53YWxrRGlydHlSZWdpb25zKG4sYSl9LG0uY29ubmVjdExlZnREZWdlbmVyYXRlPWZ1bmN0aW9uKG4sYSxpKXt2YXIgbyxULFAsQyxJO2lmKG89YS5lVXAscy52ZXJ0RXEoby5PcmcsaSkpe2coITEpLG0uc3BsaWNlTWVyZ2VWZXJ0aWNlcyhuLG8saS5hbkVkZ2UpO3JldHVybn1pZighcy52ZXJ0RXEoby5Ec3QsaSkpe24ubWVzaC5zcGxpdEVkZ2Uoby5TeW0pLGEuZml4VXBwZXJFZGdlJiYobi5tZXNoLmRlbGV0ZShvLk9uZXh0KSxhLmZpeFVwcGVyRWRnZT0hMSksbi5tZXNoLnNwbGljZShpLmFuRWRnZSxvKSxtLnN3ZWVwRXZlbnQobixpKTtyZXR1cm59ZyghMSksYT1tLnRvcFJpZ2h0UmVnaW9uKGEpLEk9bS5yZWdpb25CZWxvdyhhKSxQPUkuZVVwLlN5bSxUPUM9UC5PbmV4dCxJLmZpeFVwcGVyRWRnZSYmKGcoVCE9PVApLG0uZGVsZXRlUmVnaW9uKG4sSSksbi5tZXNoLmRlbGV0ZShQKSxQPVQuT3ByZXYpLG4ubWVzaC5zcGxpY2UoaS5hbkVkZ2UsUCkscy5lZGdlR29lc0xlZnQoVCl8fChUPW51bGwpLG0uYWRkUmlnaHRFZGdlcyhuLGEsUC5PbmV4dCxDLFQsITApfSxtLmNvbm5lY3RMZWZ0VmVydGV4PWZ1bmN0aW9uKG4sYSl7dmFyIGksbyxULFAsQyxJLEE9bmV3IE87aWYoQS5lVXA9YS5hbkVkZ2UuU3ltLGk9bi5kaWN0LnNlYXJjaChBKS5rZXksbz1tLnJlZ2lvbkJlbG93KGkpLCEhbyl7aWYoUD1pLmVVcCxDPW8uZVVwLHMuZWRnZVNpZ24oUC5Ec3QsYSxQLk9yZyk9PT0wKXttLmNvbm5lY3RMZWZ0RGVnZW5lcmF0ZShuLGksYSk7cmV0dXJufWlmKFQ9cy52ZXJ0TGVxKEMuRHN0LFAuRHN0KT9pOm8saS5pbnNpZGV8fFQuZml4VXBwZXJFZGdlKXtpZihUPT09aSlJPW4ubWVzaC5jb25uZWN0KGEuYW5FZGdlLlN5bSxQLkxuZXh0KTtlbHNle3ZhciBMPW4ubWVzaC5jb25uZWN0KEMuRG5leHQsYS5hbkVkZ2UpO0k9TC5TeW19VC5maXhVcHBlckVkZ2U/bS5maXhVcHBlckVkZ2UobixULEkpOm0uY29tcHV0ZVdpbmRpbmcobixtLmFkZFJlZ2lvbkJlbG93KG4saSxJKSksbS5zd2VlcEV2ZW50KG4sYSl9ZWxzZSBtLmFkZFJpZ2h0RWRnZXMobixpLGEuYW5FZGdlLGEuYW5FZGdlLG51bGwsITApfX0sbS5zd2VlcEV2ZW50PWZ1bmN0aW9uKG4sYSl7bi5ldmVudD1hLG0uZGVidWdFdmVudChuKTtmb3IodmFyIGk9YS5hbkVkZ2U7aS5hY3RpdmVSZWdpb249PT1udWxsOylpZihpPWkuT25leHQsaT09PWEuYW5FZGdlKXttLmNvbm5lY3RMZWZ0VmVydGV4KG4sYSk7cmV0dXJufXZhciBvPW0udG9wTGVmdFJlZ2lvbihuLGkuYWN0aXZlUmVnaW9uKTtnKG8hPT1udWxsKTt2YXIgVD1tLnJlZ2lvbkJlbG93KG8pLFA9VC5lVXAsQz1tLmZpbmlzaExlZnRSZWdpb25zKG4sVCxudWxsKTtDLk9uZXh0PT09UD9tLmNvbm5lY3RSaWdodFZlcnRleChuLG8sQyk6bS5hZGRSaWdodEVkZ2VzKG4sbyxDLk9uZXh0LFAsUCwhMCl9LG0uYWRkU2VudGluZWw9ZnVuY3Rpb24obixhLGksbyl7dmFyIFQ9bmV3IE8sUD1uLm1lc2gubWFrZUVkZ2UoKTtQLk9yZy5zPWksUC5PcmcudD1vLFAuRHN0LnM9YSxQLkRzdC50PW8sbi5ldmVudD1QLkRzdCxULmVVcD1QLFQud2luZGluZ051bWJlcj0wLFQuaW5zaWRlPSExLFQuZml4VXBwZXJFZGdlPSExLFQuc2VudGluZWw9ITAsVC5kaXJ0eT0hMSxULm5vZGVVcD1uLmRpY3QuaW5zZXJ0KFQpfSxtLmluaXRFZGdlRGljdD1mdW5jdGlvbihuKXtuLmRpY3Q9bmV3IGYobixtLmVkZ2VMZXEpO3ZhciBhPW4uYm1heFswXS1uLmJtaW5bMF0saT1uLmJtYXhbMV0tbi5ibWluWzFdLG89bi5ibWluWzBdLWEsVD1uLmJtYXhbMF0rYSxQPW4uYm1pblsxXS1pLEM9bi5ibWF4WzFdK2k7bS5hZGRTZW50aW5lbChuLG8sVCxQKSxtLmFkZFNlbnRpbmVsKG4sbyxULEMpfSxtLmRvbmVFZGdlRGljdD1mdW5jdGlvbihuKXtmb3IodmFyIGEsaT0wOyhhPW4uZGljdC5taW4oKS5rZXkpIT09bnVsbDspYS5zZW50aW5lbHx8KGcoYS5maXhVcHBlckVkZ2UpLGcoKytpPT09MSkpLGcoYS53aW5kaW5nTnVtYmVyPT09MCksbS5kZWxldGVSZWdpb24obixhKX0sbS5yZW1vdmVEZWdlbmVyYXRlRWRnZXM9ZnVuY3Rpb24obil7dmFyIGEsaSxvLFQ9bi5tZXNoLmVIZWFkO2ZvcihhPVQubmV4dDthIT09VDthPWkpaT1hLm5leHQsbz1hLkxuZXh0LHMudmVydEVxKGEuT3JnLGEuRHN0KSYmYS5MbmV4dC5MbmV4dCE9PWEmJihtLnNwbGljZU1lcmdlVmVydGljZXMobixvLGEpLG4ubWVzaC5kZWxldGUoYSksYT1vLG89YS5MbmV4dCksby5MbmV4dD09PWEmJihvIT09YSYmKChvPT09aXx8bz09PWkuU3ltKSYmKGk9aS5uZXh0KSxuLm1lc2guZGVsZXRlKG8pKSwoYT09PWl8fGE9PT1pLlN5bSkmJihpPWkubmV4dCksbi5tZXNoLmRlbGV0ZShhKSl9LG0uaW5pdFByaW9yaXR5UT1mdW5jdGlvbihuKXt2YXIgYSxpLG8sVD0wO2ZvcihvPW4ubWVzaC52SGVhZCxpPW8ubmV4dDtpIT09bztpPWkubmV4dClUKys7Zm9yKFQrPTgsYT1uLnBxPW5ldyBiKFQscy52ZXJ0TGVxKSxvPW4ubWVzaC52SGVhZCxpPW8ubmV4dDtpIT09bztpPWkubmV4dClpLnBxSGFuZGxlPWEuaW5zZXJ0KGkpO3JldHVybiBpIT09bz8hMTooYS5pbml0KCksITApfSxtLmRvbmVQcmlvcml0eVE9ZnVuY3Rpb24obil7bi5wcT1udWxsfSxtLnJlbW92ZURlZ2VuZXJhdGVGYWNlcz1mdW5jdGlvbihuLGEpe3ZhciBpLG8sVDtmb3IoaT1hLmZIZWFkLm5leHQ7aSE9PWEuZkhlYWQ7aT1vKW89aS5uZXh0LFQ9aS5hbkVkZ2UsZyhULkxuZXh0IT09VCksVC5MbmV4dC5MbmV4dD09PVQmJihtLmFkZFdpbmRpbmcoVC5PbmV4dCxUKSxuLm1lc2guZGVsZXRlKFQpKTtyZXR1cm4hMH0sbS5jb21wdXRlSW50ZXJpb3I9ZnVuY3Rpb24obil7dmFyIGEsaTtpZihtLnJlbW92ZURlZ2VuZXJhdGVFZGdlcyhuKSwhbS5pbml0UHJpb3JpdHlRKG4pKXJldHVybiExO2ZvcihtLmluaXRFZGdlRGljdChuKTsoYT1uLnBxLmV4dHJhY3RNaW4oKSkhPT1udWxsOyl7Zm9yKDtpPW4ucHEubWluKCksIShpPT09bnVsbHx8IXMudmVydEVxKGksYSkpOylpPW4ucHEuZXh0cmFjdE1pbigpLG0uc3BsaWNlTWVyZ2VWZXJ0aWNlcyhuLGEuYW5FZGdlLGkuYW5FZGdlKTttLnN3ZWVwRXZlbnQobixhKX1yZXR1cm4gbi5ldmVudD1uLmRpY3QubWluKCkua2V5LmVVcC5PcmcsbS5kZWJ1Z0V2ZW50KG4pLG0uZG9uZUVkZ2VEaWN0KG4pLG0uZG9uZVByaW9yaXR5UShuKSxtLnJlbW92ZURlZ2VuZXJhdGVGYWNlcyhuLG4ubWVzaCk/KG4ubWVzaC5jaGVjaygpLCEwKTohMX07ZnVuY3Rpb24gcCgpe3RoaXMubWVzaD1udWxsLHRoaXMubm9ybWFsPVswLDAsMF0sdGhpcy5zVW5pdD1bMCwwLDBdLHRoaXMudFVuaXQ9WzAsMCwwXSx0aGlzLmJtaW49WzAsMF0sdGhpcy5ibWF4PVswLDBdLHRoaXMud2luZGluZ1J1bGU9ci5XSU5ESU5HX09ERCx0aGlzLmRpY3Q9bnVsbCx0aGlzLnBxPW51bGwsdGhpcy5ldmVudD1udWxsLHRoaXMudmVydGV4SW5kZXhDb3VudGVyPTAsdGhpcy52ZXJ0aWNlcz1bXSx0aGlzLnZlcnRleEluZGljZXM9W10sdGhpcy52ZXJ0ZXhDb3VudD0wLHRoaXMuZWxlbWVudHM9W10sdGhpcy5lbGVtZW50Q291bnQ9MH1wLnByb3RvdHlwZT17ZG90XzpmdW5jdGlvbihuLGEpe3JldHVybiBuWzBdKmFbMF0rblsxXSphWzFdK25bMl0qYVsyXX0sbm9ybWFsaXplXzpmdW5jdGlvbihuKXt2YXIgYT1uWzBdKm5bMF0rblsxXSpuWzFdK25bMl0qblsyXTtnKGE+MCksYT1NYXRoLnNxcnQoYSksblswXS89YSxuWzFdLz1hLG5bMl0vPWF9LGxvbmdBeGlzXzpmdW5jdGlvbihuKXt2YXIgYT0wO3JldHVybiBNYXRoLmFicyhuWzFdKT5NYXRoLmFicyhuWzBdKSYmKGE9MSksTWF0aC5hYnMoblsyXSk+TWF0aC5hYnMoblthXSkmJihhPTIpLGF9LGNvbXB1dGVOb3JtYWxfOmZ1bmN0aW9uKG4pe3ZhciBhLGksbyxULFAsQyxJPVswLDAsMF0sQT1bMCwwLDBdLEw9WzAsMCwwXSxEPVswLDAsMF0sUj1bMCwwLDBdLFM9W251bGwsbnVsbCxudWxsXSxCPVtudWxsLG51bGwsbnVsbF0sdz10aGlzLm1lc2gudkhlYWQsSDtmb3IoYT13Lm5leHQsSD0wO0g8MzsrK0gpVD1hLmNvb3Jkc1tIXSxBW0hdPVQsQltIXT1hLElbSF09VCxTW0hdPWE7Zm9yKGE9dy5uZXh0O2EhPT13O2E9YS5uZXh0KWZvcihIPTA7SDwzOysrSClUPWEuY29vcmRzW0hdLFQ8QVtIXSYmKEFbSF09VCxCW0hdPWEpLFQ+SVtIXSYmKElbSF09VCxTW0hdPWEpO2lmKEg9MCxJWzFdLUFbMV0+SVswXS1BWzBdJiYoSD0xKSxJWzJdLUFbMl0+SVtIXS1BW0hdJiYoSD0yKSxBW0hdPj1JW0hdKXtuWzBdPTAsblsxXT0wLG5bMl09MTtyZXR1cm59Zm9yKEM9MCxpPUJbSF0sbz1TW0hdLExbMF09aS5jb29yZHNbMF0tby5jb29yZHNbMF0sTFsxXT1pLmNvb3Jkc1sxXS1vLmNvb3Jkc1sxXSxMWzJdPWkuY29vcmRzWzJdLW8uY29vcmRzWzJdLGE9dy5uZXh0O2EhPT13O2E9YS5uZXh0KURbMF09YS5jb29yZHNbMF0tby5jb29yZHNbMF0sRFsxXT1hLmNvb3Jkc1sxXS1vLmNvb3Jkc1sxXSxEWzJdPWEuY29vcmRzWzJdLW8uY29vcmRzWzJdLFJbMF09TFsxXSpEWzJdLUxbMl0qRFsxXSxSWzFdPUxbMl0qRFswXS1MWzBdKkRbMl0sUlsyXT1MWzBdKkRbMV0tTFsxXSpEWzBdLFA9UlswXSpSWzBdK1JbMV0qUlsxXStSWzJdKlJbMl0sUD5DJiYoQz1QLG5bMF09UlswXSxuWzFdPVJbMV0sblsyXT1SWzJdKTtDPD0wJiYoblswXT1uWzFdPW5bMl09MCxuW3RoaXMubG9uZ0F4aXNfKEwpXT0xKX0sY2hlY2tPcmllbnRhdGlvbl86ZnVuY3Rpb24oKXt2YXIgbixhLGk9dGhpcy5tZXNoLmZIZWFkLG8sVD10aGlzLm1lc2gudkhlYWQsUDtmb3Iobj0wLGE9aS5uZXh0O2EhPT1pO2E9YS5uZXh0KWlmKFA9YS5hbkVkZ2UsIShQLndpbmRpbmc8PTApKWRvIG4rPShQLk9yZy5zLVAuRHN0LnMpKihQLk9yZy50K1AuRHN0LnQpLFA9UC5MbmV4dDt3aGlsZShQIT09YS5hbkVkZ2UpO2lmKG48MCl7Zm9yKG89VC5uZXh0O28hPT1UO289by5uZXh0KW8udD0tby50O3RoaXMudFVuaXRbMF09LXRoaXMudFVuaXRbMF0sdGhpcy50VW5pdFsxXT0tdGhpcy50VW5pdFsxXSx0aGlzLnRVbml0WzJdPS10aGlzLnRVbml0WzJdfX0scHJvamVjdFBvbHlnb25fOmZ1bmN0aW9uKCl7dmFyIG4sYT10aGlzLm1lc2gudkhlYWQsaT1bMCwwLDBdLG8sVCxQLEMsST0hMTtmb3IoaVswXT10aGlzLm5vcm1hbFswXSxpWzFdPXRoaXMubm9ybWFsWzFdLGlbMl09dGhpcy5ub3JtYWxbMl0saVswXT09PTAmJmlbMV09PT0wJiZpWzJdPT09MCYmKHRoaXMuY29tcHV0ZU5vcm1hbF8oaSksST0hMCksbz10aGlzLnNVbml0LFQ9dGhpcy50VW5pdCxQPXRoaXMubG9uZ0F4aXNfKGkpLG9bUF09MCxvWyhQKzEpJTNdPTEsb1soUCsyKSUzXT0wLFRbUF09MCxUWyhQKzEpJTNdPTAsVFsoUCsyKSUzXT1pW1BdPjA/MTotMSxuPWEubmV4dDtuIT09YTtuPW4ubmV4dCluLnM9dGhpcy5kb3RfKG4uY29vcmRzLG8pLG4udD10aGlzLmRvdF8obi5jb29yZHMsVCk7Zm9yKEkmJnRoaXMuY2hlY2tPcmllbnRhdGlvbl8oKSxDPSEwLG49YS5uZXh0O24hPT1hO249bi5uZXh0KUM/KHRoaXMuYm1pblswXT10aGlzLmJtYXhbMF09bi5zLHRoaXMuYm1pblsxXT10aGlzLmJtYXhbMV09bi50LEM9ITEpOihuLnM8dGhpcy5ibWluWzBdJiYodGhpcy5ibWluWzBdPW4ucyksbi5zPnRoaXMuYm1heFswXSYmKHRoaXMuYm1heFswXT1uLnMpLG4udDx0aGlzLmJtaW5bMV0mJih0aGlzLmJtaW5bMV09bi50KSxuLnQ+dGhpcy5ibWF4WzFdJiYodGhpcy5ibWF4WzFdPW4udCkpfSxhZGRXaW5kaW5nXzpmdW5jdGlvbihuLGEpe24ud2luZGluZys9YS53aW5kaW5nLG4uU3ltLndpbmRpbmcrPWEuU3ltLndpbmRpbmd9LHRlc3NlbGxhdGVNb25vUmVnaW9uXzpmdW5jdGlvbihuLGEpe3ZhciBpLG87Zm9yKGk9YS5hbkVkZ2UsZyhpLkxuZXh0IT09aSYmaS5MbmV4dC5MbmV4dCE9PWkpO3MudmVydExlcShpLkRzdCxpLk9yZyk7aT1pLkxwcmV2KTtmb3IoO3MudmVydExlcShpLk9yZyxpLkRzdCk7aT1pLkxuZXh0KTtmb3Iobz1pLkxwcmV2O2kuTG5leHQhPT1vOylpZihzLnZlcnRMZXEoaS5Ec3Qsby5PcmcpKXtmb3IoO28uTG5leHQhPT1pJiYocy5lZGdlR29lc0xlZnQoby5MbmV4dCl8fHMuZWRnZVNpZ24oby5Pcmcsby5Ec3Qsby5MbmV4dC5Ec3QpPD0wKTspe3ZhciBUPW4uY29ubmVjdChvLkxuZXh0LG8pO289VC5TeW19bz1vLkxwcmV2fWVsc2V7Zm9yKDtvLkxuZXh0IT09aSYmKHMuZWRnZUdvZXNSaWdodChpLkxwcmV2KXx8cy5lZGdlU2lnbihpLkRzdCxpLk9yZyxpLkxwcmV2Lk9yZyk+PTApOyl7dmFyIFQ9bi5jb25uZWN0KGksaS5McHJldik7aT1ULlN5bX1pPWkuTG5leHR9Zm9yKGcoby5MbmV4dCE9PWkpO28uTG5leHQuTG5leHQhPT1pOyl7dmFyIFQ9bi5jb25uZWN0KG8uTG5leHQsbyk7bz1ULlN5bX1yZXR1cm4hMH0sdGVzc2VsbGF0ZUludGVyaW9yXzpmdW5jdGlvbihuKXt2YXIgYSxpO2ZvcihhPW4uZkhlYWQubmV4dDthIT09bi5mSGVhZDthPWkpaWYoaT1hLm5leHQsYS5pbnNpZGUmJiF0aGlzLnRlc3NlbGxhdGVNb25vUmVnaW9uXyhuLGEpKXJldHVybiExO3JldHVybiEwfSxkaXNjYXJkRXh0ZXJpb3JfOmZ1bmN0aW9uKG4pe3ZhciBhLGk7Zm9yKGE9bi5mSGVhZC5uZXh0O2EhPT1uLmZIZWFkO2E9aSlpPWEubmV4dCxhLmluc2lkZXx8bi56YXBGYWNlKGEpfSxzZXRXaW5kaW5nTnVtYmVyXzpmdW5jdGlvbihuLGEsaSl7dmFyIG8sVDtmb3Iobz1uLmVIZWFkLm5leHQ7byE9PW4uZUhlYWQ7bz1UKVQ9by5uZXh0LG8uUmZhY2UuaW5zaWRlIT09by5MZmFjZS5pbnNpZGU/by53aW5kaW5nPW8uTGZhY2UuaW5zaWRlP2E6LWE6aT9uLmRlbGV0ZShvKTpvLndpbmRpbmc9MH0sZ2V0TmVpZ2hib3VyRmFjZV86ZnVuY3Rpb24obil7cmV0dXJuIW4uUmZhY2V8fCFuLlJmYWNlLmluc2lkZT8tMTpuLlJmYWNlLm59LG91dHB1dFBvbHltZXNoXzpmdW5jdGlvbihuLGEsaSxvKXt2YXIgVCxQLEMsST0wLEE9MCxMLEQ7Zm9yKGk+MyYmbi5tZXJnZUNvbnZleEZhY2VzKGkpLFQ9bi52SGVhZC5uZXh0O1QhPT1uLnZIZWFkO1Q9VC5uZXh0KVQubj0tMTtmb3IoUD1uLmZIZWFkLm5leHQ7UCE9PW4uZkhlYWQ7UD1QLm5leHQpaWYoUC5uPS0xLCEhUC5pbnNpZGUpe0M9UC5hbkVkZ2UsTD0wO2RvIFQ9Qy5PcmcsVC5uPT09LTEmJihULm49QSxBKyspLEwrKyxDPUMuTG5leHQ7d2hpbGUoQyE9PVAuYW5FZGdlKTtnKEw8PWkpLFAubj1JLCsrSX1mb3IodGhpcy5lbGVtZW50Q291bnQ9SSxhPT09ci5DT05ORUNURURfUE9MWUdPTlMmJihJKj0yKSx0aGlzLmVsZW1lbnRzPVtdLHRoaXMuZWxlbWVudHMubGVuZ3RoPUkqaSx0aGlzLnZlcnRleENvdW50PUEsdGhpcy52ZXJ0aWNlcz1bXSx0aGlzLnZlcnRpY2VzLmxlbmd0aD1BKm8sdGhpcy52ZXJ0ZXhJbmRpY2VzPVtdLHRoaXMudmVydGV4SW5kaWNlcy5sZW5ndGg9QSxUPW4udkhlYWQubmV4dDtUIT09bi52SGVhZDtUPVQubmV4dClpZihULm4hPT0tMSl7dmFyIFI9VC5uKm87dGhpcy52ZXJ0aWNlc1tSKzBdPVQuY29vcmRzWzBdLHRoaXMudmVydGljZXNbUisxXT1ULmNvb3Jkc1sxXSxvPjImJih0aGlzLnZlcnRpY2VzW1IrMl09VC5jb29yZHNbMl0pLHRoaXMudmVydGV4SW5kaWNlc1tULm5dPVQuaWR4fXZhciBTPTA7Zm9yKFA9bi5mSGVhZC5uZXh0O1AhPT1uLmZIZWFkO1A9UC5uZXh0KWlmKFAuaW5zaWRlKXtDPVAuYW5FZGdlLEw9MDtkbyBUPUMuT3JnLHRoaXMuZWxlbWVudHNbUysrXT1ULm4sTCsrLEM9Qy5MbmV4dDt3aGlsZShDIT09UC5hbkVkZ2UpO2ZvcihEPUw7RDxpOysrRCl0aGlzLmVsZW1lbnRzW1MrK109LTE7aWYoYT09PXIuQ09OTkVDVEVEX1BPTFlHT05TKXtDPVAuYW5FZGdlO2RvIHRoaXMuZWxlbWVudHNbUysrXT10aGlzLmdldE5laWdoYm91ckZhY2VfKEMpLEM9Qy5MbmV4dDt3aGlsZShDIT09UC5hbkVkZ2UpO2ZvcihEPUw7RDxpOysrRCl0aGlzLmVsZW1lbnRzW1MrK109LTF9fX0sb3V0cHV0Q29udG91cnNfOmZ1bmN0aW9uKG4sYSl7dmFyIGksbyxULFA9MCxDPTA7Zm9yKHRoaXMudmVydGV4Q291bnQ9MCx0aGlzLmVsZW1lbnRDb3VudD0wLGk9bi5mSGVhZC5uZXh0O2khPT1uLmZIZWFkO2k9aS5uZXh0KWlmKGkuaW5zaWRlKXtUPW89aS5hbkVkZ2U7ZG8gdGhpcy52ZXJ0ZXhDb3VudCsrLG89by5MbmV4dDt3aGlsZShvIT09VCk7dGhpcy5lbGVtZW50Q291bnQrK310aGlzLmVsZW1lbnRzPVtdLHRoaXMuZWxlbWVudHMubGVuZ3RoPXRoaXMuZWxlbWVudENvdW50KjIsdGhpcy52ZXJ0aWNlcz1bXSx0aGlzLnZlcnRpY2VzLmxlbmd0aD10aGlzLnZlcnRleENvdW50KmEsdGhpcy52ZXJ0ZXhJbmRpY2VzPVtdLHRoaXMudmVydGV4SW5kaWNlcy5sZW5ndGg9dGhpcy52ZXJ0ZXhDb3VudDt2YXIgST0wLEE9MCxMPTA7Zm9yKFA9MCxpPW4uZkhlYWQubmV4dDtpIT09bi5mSGVhZDtpPWkubmV4dClpZihpLmluc2lkZSl7Qz0wLFQ9bz1pLmFuRWRnZTtkbyB0aGlzLnZlcnRpY2VzW0krK109by5PcmcuY29vcmRzWzBdLHRoaXMudmVydGljZXNbSSsrXT1vLk9yZy5jb29yZHNbMV0sYT4yJiYodGhpcy52ZXJ0aWNlc1tJKytdPW8uT3JnLmNvb3Jkc1syXSksdGhpcy52ZXJ0ZXhJbmRpY2VzW0ErK109by5PcmcuaWR4LEMrKyxvPW8uTG5leHQ7d2hpbGUobyE9PVQpO3RoaXMuZWxlbWVudHNbTCsrXT1QLHRoaXMuZWxlbWVudHNbTCsrXT1DLFArPUN9fSxhZGRDb250b3VyOmZ1bmN0aW9uKG4sYSl7dmFyIGksbztmb3IodGhpcy5tZXNoPT09bnVsbCYmKHRoaXMubWVzaD1uZXcgdSksbjwyJiYobj0yKSxuPjMmJihuPTMpLGk9bnVsbCxvPTA7bzxhLmxlbmd0aDtvKz1uKWk9PT1udWxsPyhpPXRoaXMubWVzaC5tYWtlRWRnZSgpLHRoaXMubWVzaC5zcGxpY2UoaSxpLlN5bSkpOih0aGlzLm1lc2guc3BsaXRFZGdlKGkpLGk9aS5MbmV4dCksaS5PcmcuY29vcmRzWzBdPWFbbyswXSxpLk9yZy5jb29yZHNbMV09YVtvKzFdLG4+Mj9pLk9yZy5jb29yZHNbMl09YVtvKzJdOmkuT3JnLmNvb3Jkc1syXT0wLGkuT3JnLmlkeD10aGlzLnZlcnRleEluZGV4Q291bnRlcisrLGkud2luZGluZz0xLGkuU3ltLndpbmRpbmc9LTF9LHRlc3NlbGF0ZTpmdW5jdGlvbihuLGEsaSxvLFQpe2lmKHRoaXMudmVydGljZXM9W10sdGhpcy5lbGVtZW50cz1bXSx0aGlzLnZlcnRleEluZGljZXM9W10sdGhpcy52ZXJ0ZXhJbmRleENvdW50ZXI9MCxUJiYodGhpcy5ub3JtYWxbMF09VFswXSx0aGlzLm5vcm1hbFsxXT1UWzFdLHRoaXMubm9ybWFsWzJdPVRbMl0pLHRoaXMud2luZGluZ1J1bGU9bixvPDImJihvPTIpLG8+MyYmKG89MyksIXRoaXMubWVzaClyZXR1cm4hMTt0aGlzLnByb2plY3RQb2x5Z29uXygpLG0uY29tcHV0ZUludGVyaW9yKHRoaXMpO3ZhciBQPXRoaXMubWVzaDtyZXR1cm4gYT09PXIuQk9VTkRBUllfQ09OVE9VUlM/dGhpcy5zZXRXaW5kaW5nTnVtYmVyXyhQLDEsITApOnRoaXMudGVzc2VsbGF0ZUludGVyaW9yXyhQKSxQLmNoZWNrKCksYT09PXIuQk9VTkRBUllfQ09OVE9VUlM/dGhpcy5vdXRwdXRDb250b3Vyc18oUCxvKTp0aGlzLm91dHB1dFBvbHltZXNoXyhQLGEsaSxvKSwhMH19fSxmdW5jdGlvbihjLGUpe2MuZXhwb3J0cz1yO3ZhciB0PU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7ZnVuY3Rpb24gcigpe2Zvcih2YXIgcz17fSxnPTA7Zzxhcmd1bWVudHMubGVuZ3RoO2crKyl7dmFyIHY9YXJndW1lbnRzW2ddO2Zvcih2YXIgaCBpbiB2KXQuY2FsbCh2LGgpJiYoc1toXT12W2hdKX1yZXR1cm4gc319LGZ1bmN0aW9uKGMsZSx0KXt0LnIoZSksdC5kKGUsImNyZWF0ZVNoYWRlcnMiLGZ1bmN0aW9uKCl7cmV0dXJuIGx9KSx0LmQoZSwiYXBwbHlTaGFkZXIiLGZ1bmN0aW9uKCl7cmV0dXJuIHV9KSx0LmQoZSwiY3JlYXRlQ2xvdWRTaGFkZXJzIixmdW5jdGlvbigpe3JldHVybiBmfSksdC5kKGUsImFwcGx5Q2xvdWRTaGFkZXIiLGZ1bmN0aW9uKCl7cmV0dXJuIHl9KTt2YXIgcj10KDY0KSxzPXQoNjUpLGc9dCg2Niksdj10KDY3KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3QgaD1TeW1ib2woInNoYWRlcnMiKTtmdW5jdGlvbiBsKHgpe3hbaF09W107Zm9yKGxldCBiPTA7YjwxNjtiKyspe2NvbnN0IE89W10sbT0hIShiJjEpLHA9ISEoYiYyKSxuPSEhKGImNCksYT0hIShiJjgpO20mJk8ucHVzaCgiI2RlZmluZSBURVhUVVJFIDEiKSxwJiZPLnB1c2goIiNkZWZpbmUgRklMVEVSIDEiKSxuJiZPLnB1c2goIiNkZWZpbmUgR1JBRElFTlQgMSIpLGEmJk8ucHVzaCgiI2RlZmluZSBDTElQUEFUSCAxIik7Y29uc3QgaT1gJHtPLmpvaW4oYApgKX0KYCxvPVtdO20mJm8ucHVzaCgidW5pZm9ybSBzYW1wbGVyMkQgdV90ZXhTYW1wbGVyOyIpLGEmJm8ucHVzaCgidW5pZm9ybSBzYW1wbGVyMkQgdV9jbGlwU2FtcGxlcjsiKSx4W2hdW2JdPVtpK28uam9pbihgCmApK3MuZGVmYXVsdCxpK3IuZGVmYXVsdF19fWZ1bmN0aW9uIHUoeCx7aGFzVGV4dHVyZTpiPSExLGhhc0ZpbHRlcjpPPSExLGhhc0dyYWRpZW50Om09ITEsaGFzQ2xpcFBhdGg6cD0hMX09e30pe2NvbnN0IG49YnxPPDwxfG08PDJ8cDw8MztsZXQgYT14W2hdW25dO0FycmF5LmlzQXJyYXkoYSkmJihhPXguY3JlYXRlUHJvZ3JhbSguLi5hKSx4W2hdW25dPWEpLHgucHJvZ3JhbSE9PWEmJngudXNlUHJvZ3JhbShhLHthX2NvbG9yOnt0eXBlOiJVTlNJR05FRF9CWVRFIixub3JtYWxpemU6ITB9fSl9Y29uc3QgTT1bXTtmdW5jdGlvbiBmKHgpe2ZvcihsZXQgYj0wO2I8NjQ7YisrKXtjb25zdCBPPVtdLG09ISEoYiYxKSxwPSEhKGImMiksbj0hIShiJjQpLGE9ISEoYiY4KSxpPSEhKGImMTYpLG89ISEoYiYzMik7bSYmTy5wdXNoKCIjZGVmaW5lIFRFWFRVUkUgMSIpLHAmJk8ucHVzaCgiI2RlZmluZSBGSUxURVIgMSIpLG4mJk8ucHVzaCgiI2RlZmluZSBHUkFESUVOVCAxIiksYSYmTy5wdXNoKCIjZGVmaW5lIENMT1VEQ09MT1IgMSIpLGkmJk8ucHVzaCgiI2RlZmluZSBDTE9VREZJTFRFUiAxIiksbyYmTy5wdXNoKCIjZGVmaW5lIENMSVBQQVRIIDEiKTtjb25zdCBUPWAke08uam9pbihgCmApfQpgLFA9W107aWYobSl7UC5wdXNoKCJ1bmlmb3JtIHNhbXBsZXIyRCB1X3RleFNhbXBsZXI7Iik7Zm9yKGxldCBDPTA7QzwxMjtDKyspUC5wdXNoKGB1bmlmb3JtIHNhbXBsZXIyRCB1X3RleEZyYW1lJHtDfTtgKX1vJiZQLnB1c2goInVuaWZvcm0gc2FtcGxlcjJEIHVfY2xpcFNhbXBsZXI7IiksTVtiXT1bVCtQLmpvaW4oYApgKSt2LmRlZmF1bHQsVCtnLmRlZmF1bHRdfX1mdW5jdGlvbiB5KHgse2hhc1RleHR1cmU6Yj0hMSxoYXNGaWx0ZXI6Tz0hMSxoYXNHcmFkaWVudDptPSExLGhhc0Nsb3VkQ29sb3I6cD0hMSxoYXNDbG91ZEZpbHRlcjpuPSExLGhhc0NsaXBQYXRoOmE9ITF9PXt9KXtjb25zdCBpPWJ8Tzw8MXxtPDwyfHA8PDN8bjw8NHxhPDw1O2xldCBvPU1baV07QXJyYXkuaXNBcnJheShvKSYmKG89eC5jcmVhdGVQcm9ncmFtKC4uLm8pLE1baV09bykseC5wcm9ncmFtIT09byYmeC51c2VQcm9ncmFtKG8se2FfY29sb3I6e3R5cGU6IlVOU0lHTkVEX0JZVEUiLG5vcm1hbGl6ZTohMH0sYV9maWxsQ2xvdWRDb2xvcjp7dHlwZToiVU5TSUdORURfQllURSIsbm9ybWFsaXplOiEwfSxhX3N0cm9rZUNsb3VkQ29sb3I6e3R5cGU6IlVOU0lHTkVEX0JZVEUiLG5vcm1hbGl6ZTohMH0sYV9mcmFtZUluZGV4Ont0eXBlOiJVTlNJR05FRF9CWVRFIixub3JtYWxpemU6ITF9fSl9fSxmdW5jdGlvbihjLGUsdCl7dC5yKGUpLGUuZGVmYXVsdD1gYXR0cmlidXRlIHZlYzMgYV92ZXJ0ZXhQb3NpdGlvbjsKYXR0cmlidXRlIHZlYzQgYV9jb2xvcjsKdmFyeWluZyB2ZWM0IHZDb2xvcjsKdmFyeWluZyBmbG9hdCBmbGFnQmFja2dyb3VuZDsKdW5pZm9ybSB2ZWMyIHVfcmVzb2x1dGlvbjsKdW5pZm9ybSBtYXQzIHZpZXdNYXRyaXg7CnVuaWZvcm0gbWF0MyBwcm9qZWN0aW9uTWF0cml4OwoKI2lmZGVmIFRFWFRVUkUKYXR0cmlidXRlIHZlYzMgYV92ZXJ0ZXhUZXh0dXJlQ29vcmQ7CnZhcnlpbmcgdmVjMyB2VGV4dHVyZUNvb3JkOwphdHRyaWJ1dGUgdmVjNCBhX3NvdXJjZVJlY3Q7CnZhcnlpbmcgdmVjNCB2U291cmNlUmVjdDsKI2VuZGlmCgojaWZkZWYgQ0xJUFBBVEgKYXR0cmlidXRlIHZlYzIgYV9jbGlwVVY7CnZhcnlpbmcgdmVjMiB2Q2xpcFVWOwojZW5kaWYKCiNpZmRlZiBHUkFESUVOVAp1bmlmb3JtIGZsb2F0IHVfcmFkaWFsR3JhZGllbnRWZWN0b3JbNl07CnZhcnlpbmcgdmVjMyB2R3JhZGllbnRWZWN0b3IxOwp2YXJ5aW5nIHZlYzMgdkdyYWRpZW50VmVjdG9yMjsKI2VuZGlmCgp2b2lkIG1haW4oKSB7CiAgZ2xfUG9pbnRTaXplID0gMS4wOwoKICB2ZWMzIHBvcyA9IHByb2plY3Rpb25NYXRyaXggKiB2aWV3TWF0cml4ICogdmVjMyhhX3ZlcnRleFBvc2l0aW9uLnh5LCAxLjApOwogIGdsX1Bvc2l0aW9uID0gdmVjNChwb3MueHksIDEuMCwgMS4wKTsKCiNpZmRlZiBHUkFESUVOVAogIHZlYzMgdmcxID0gdmlld01hdHJpeCAqIHZlYzModV9yYWRpYWxHcmFkaWVudFZlY3RvclswXSwgdV9yYWRpYWxHcmFkaWVudFZlY3RvclsxXSwgMS4wKTsKICB2ZWMzIHZnMiA9IHZpZXdNYXRyaXggKiB2ZWMzKHVfcmFkaWFsR3JhZGllbnRWZWN0b3JbM10sIHVfcmFkaWFsR3JhZGllbnRWZWN0b3JbNF0sIDEuMCk7CiAgZmxvYXQgaCA9IHVfcmVzb2x1dGlvbi55OwogIHZnMS55ID0gaCAtIHZnMS55OwogIHZnMi55ID0gaCAtIHZnMi55OwogIHZHcmFkaWVudFZlY3RvcjEgPSB2ZWMzKHZnMS54eSwgdV9yYWRpYWxHcmFkaWVudFZlY3RvclsyXSk7CiAgdkdyYWRpZW50VmVjdG9yMiA9IHZlYzModmcyLnh5LCB1X3JhZGlhbEdyYWRpZW50VmVjdG9yWzVdKTsKI2VuZGlmCiAgCiAgZmxhZ0JhY2tncm91bmQgPSBhX3ZlcnRleFBvc2l0aW9uLno7CiAgdkNvbG9yID0gYV9jb2xvcjsKCiNpZmRlZiBURVhUVVJFCiAgdlRleHR1cmVDb29yZCA9IGFfdmVydGV4VGV4dHVyZUNvb3JkOwogIHZTb3VyY2VSZWN0ID0gYV9zb3VyY2VSZWN0OwojZW5kaWYKCiNpZmRlZiBDTElQUEFUSAogIHZDbGlwVVYgPSBhX2NsaXBVVjsKI2VuZGlmCn1gfSxmdW5jdGlvbihjLGUsdCl7dC5yKGUpLGUuZGVmYXVsdD1gcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7Cgp2YXJ5aW5nIHZlYzQgdkNvbG9yOwp2YXJ5aW5nIGZsb2F0IGZsYWdCYWNrZ3JvdW5kOwoKI2lmZGVmIFRFWFRVUkUKdmFyeWluZyB2ZWMzIHZUZXh0dXJlQ29vcmQ7CnZhcnlpbmcgdmVjNCB2U291cmNlUmVjdDsKI2VuZGlmCgojaWZkZWYgQ0xJUFBBVEgKdmFyeWluZyB2ZWMyIHZDbGlwVVY7CiNlbmRpZgoKI2lmZGVmIEZJTFRFUgp1bmlmb3JtIGludCB1X2ZpbHRlckZsYWc7CnVuaWZvcm0gZmxvYXQgdV9jb2xvck1hdHJpeFsyMF07CiNlbmRpZgoKI2lmZGVmIEdSQURJRU5UCnZhcnlpbmcgdmVjMyB2R3JhZGllbnRWZWN0b3IxOwp2YXJ5aW5nIHZlYzMgdkdyYWRpZW50VmVjdG9yMjsKdW5pZm9ybSBmbG9hdCB1X2NvbG9yU3RlcHNbNDBdOwp1bmlmb3JtIGludCB1X2dyYWRpZW50VHlwZTsKLy8gdW5pZm9ybSBmbG9hdCB1X3JhZGlhbEdyYWRpZW50VmVjdG9yWzZdOwoKdm9pZCBncmFkaWVudChpbm91dCB2ZWM0IGNvbG9yLCB2ZWMzIGd2MSwgdmVjMyBndjIsIGZsb2F0IGNvbG9yU3RlcHNbNDBdKSB7CiAgZmxvYXQgdDsKICAvLyBjZW50ZXIgY2lyY2xlIHJhZGl1cwogIGZsb2F0IGNyID0gZ3YxLno7CiAgLy8gZm9jYWwgY2lyY2xlIHJhZGl1cwogIGZsb2F0IGZyID0gZ3YyLno7CgogIGlmKGNyID4gMC4wIHx8IGZyID4gMC4wKSB7CiAgICAvLyByYWRpYWwgZ3JhZGllbnQKICAgIHZlYzIgY2VudGVyID0gZ3YxLnh5OwogICAgdmVjMiBmb2NhbCA9IGd2Mi54eTsKICAgIGZsb2F0IHggPSBmb2NhbC54IC0gZ2xfRnJhZ0Nvb3JkLng7CiAgICBmbG9hdCB5ID0gZm9jYWwueSAtIGdsX0ZyYWdDb29yZC55OwogICAgZmxvYXQgZHggPSBmb2NhbC54IC0gY2VudGVyLng7CiAgICBmbG9hdCBkeSA9IGZvY2FsLnkgLSBjZW50ZXIueTsKICAgIGZsb2F0IGRyID0gY3IgLSBmcjsKICAgIGZsb2F0IGEgPSBkeCAqIGR4ICsgZHkgKiBkeSAtIGRyICogZHI7CiAgICBmbG9hdCBiID0gLTIuMCAqICh5ICogZHkgKyB4ICogZHggKyBmciAqIGRyKTsKICAgIGZsb2F0IGMgPSB4ICogeCArIHkgKiB5IC0gZnIgKiBmcjsKICAgIHQgPSAxLjAgLSAwLjUgKiAoMS4wIC8gYSkgKiAoLWIgKyBzcXJ0KGIgKiBiIC0gNC4wICogYSAqIGMpKTsKICB9IGVsc2UgewogICAgLy8gbGluZWFyIGdyYWRpZW50CiAgICB2ZWMyIHYxID0gZ2xfRnJhZ0Nvb3JkLnh5IC0gZ3YxLnh5OwogICAgdmVjMiB2MiA9IGd2Mi54eSAtIGd2MS54eTsKICAgIHQgPSAodjEueCAqIHYyLnggKyB2MS55ICogdjIueSkgLyAodjIueCAqIHYyLnggKyB2Mi55ICogdjIueSk7CiAgfQoKICB2ZWM0IGNvbG9yc1s4XTsKICBjb2xvcnNbMF0gPSB2ZWM0KGNvbG9yU3RlcHNbMV0sIGNvbG9yU3RlcHNbMl0sIGNvbG9yU3RlcHNbM10sIGNvbG9yU3RlcHNbNF0pOwogIGNvbG9yc1sxXSA9IHZlYzQoY29sb3JTdGVwc1s2XSwgY29sb3JTdGVwc1s3XSwgY29sb3JTdGVwc1s4XSwgY29sb3JTdGVwc1s5XSk7CiAgY29sb3JzWzJdID0gdmVjNChjb2xvclN0ZXBzWzExXSwgY29sb3JTdGVwc1sxMl0sIGNvbG9yU3RlcHNbMTNdLCBjb2xvclN0ZXBzWzE0XSk7CiAgY29sb3JzWzNdID0gdmVjNChjb2xvclN0ZXBzWzE2XSwgY29sb3JTdGVwc1sxN10sIGNvbG9yU3RlcHNbMThdLCBjb2xvclN0ZXBzWzE5XSk7CiAgY29sb3JzWzRdID0gdmVjNChjb2xvclN0ZXBzWzIxXSwgY29sb3JTdGVwc1syMl0sIGNvbG9yU3RlcHNbMjNdLCBjb2xvclN0ZXBzWzI0XSk7CiAgY29sb3JzWzVdID0gdmVjNChjb2xvclN0ZXBzWzI2XSwgY29sb3JTdGVwc1syN10sIGNvbG9yU3RlcHNbMjhdLCBjb2xvclN0ZXBzWzI5XSk7CiAgY29sb3JzWzZdID0gdmVjNChjb2xvclN0ZXBzWzMxXSwgY29sb3JTdGVwc1szMl0sIGNvbG9yU3RlcHNbMzNdLCBjb2xvclN0ZXBzWzM0XSk7CiAgY29sb3JzWzddID0gdmVjNChjb2xvclN0ZXBzWzM2XSwgY29sb3JTdGVwc1szN10sIGNvbG9yU3RlcHNbMzhdLCBjb2xvclN0ZXBzWzM5XSk7CiAgCiAgZmxvYXQgc3RlcHNbOF07CiAgc3RlcHNbMF0gPSBjb2xvclN0ZXBzWzBdOwogIHN0ZXBzWzFdID0gY29sb3JTdGVwc1s1XTsKICBzdGVwc1syXSA9IGNvbG9yU3RlcHNbMTBdOwogIHN0ZXBzWzNdID0gY29sb3JTdGVwc1sxNV07CiAgc3RlcHNbNF0gPSBjb2xvclN0ZXBzWzIwXTsKICBzdGVwc1s1XSA9IGNvbG9yU3RlcHNbMjVdOwogIHN0ZXBzWzZdID0gY29sb3JTdGVwc1szMF07CiAgc3RlcHNbN10gPSBjb2xvclN0ZXBzWzM1XTsKCiAgY29sb3IgPSBjb2xvcnNbMF07CiAgZm9yIChpbnQgaSA9IDE7IGkgPCA4OyBpKyspIHsKICAgIGlmIChzdGVwc1tpXSA8IDAuMCB8fCBzdGVwc1tpXSA+IDEuMCkgewogICAgICBicmVhazsKICAgIH0KICAgIGlmKHN0ZXBzW2ldID09IHN0ZXBzW2kgLSAxXSkgewogICAgICBjb2xvciA9IGNvbG9yc1tpXTsKICAgIH0gZWxzZSB7CiAgICAgIGNvbG9yID0gbWl4KGNvbG9yLCBjb2xvcnNbaV0sIGNsYW1wKCh0IC0gc3RlcHNbaSAtIDFdKSAvIChzdGVwc1tpXSAtIHN0ZXBzW2kgLSAxXSksIDAuMCwgMS4wKSk7CiAgICB9CiAgICBpZiAoc3RlcHNbaV0gPj0gdCkgewogICAgICBicmVhazsKICAgIH0KICB9Cn0KI2VuZGlmCgojaWZkZWYgRklMVEVSCnZvaWQgdHJhbnNmb3JtQ29sb3IoaW5vdXQgdmVjNCBjb2xvciwgaW4gZmxvYXQgY29sb3JNYXRyaXhbMjBdKSB7CiAgZmxvYXQgciA9IGNvbG9yLnIsIGcgPSBjb2xvci5nLCBiID0gY29sb3IuYiwgYSA9IGNvbG9yLmE7CiAgY29sb3JbMF0gPSBjb2xvck1hdHJpeFswXSAqIHIgKyBjb2xvck1hdHJpeFsxXSAqIGcgKyBjb2xvck1hdHJpeFsyXSAqIGIgKyBjb2xvck1hdHJpeFszXSAqIGEgKyBjb2xvck1hdHJpeFs0XTsKICBjb2xvclsxXSA9IGNvbG9yTWF0cml4WzVdICogciArIGNvbG9yTWF0cml4WzZdICogZyArIGNvbG9yTWF0cml4WzddICogYiArIGNvbG9yTWF0cml4WzhdICogYSArIGNvbG9yTWF0cml4WzldOwogIGNvbG9yWzJdID0gY29sb3JNYXRyaXhbMTBdICogciArIGNvbG9yTWF0cml4WzExXSAqIGcgKyBjb2xvck1hdHJpeFsxMl0gKiBiICsgY29sb3JNYXRyaXhbMTNdICogYSArIGNvbG9yTWF0cml4WzE0XTsKICBjb2xvclszXSA9IGNvbG9yTWF0cml4WzE1XSAqIHIgKyBjb2xvck1hdHJpeFsxNl0gKiBnICsgY29sb3JNYXRyaXhbMTddICogYiArIGNvbG9yTWF0cml4WzE4XSAqIGEgKyBjb2xvck1hdHJpeFsxOV07Cn0KI2VuZGlmCgp2b2lkIG1haW4oKSB7CiAgdmVjNCBjb2xvciA9IHZDb2xvcjsKICBmbG9hdCBvcGFjaXR5ID0gYWJzKGZsYWdCYWNrZ3JvdW5kKTsKCiNpZmRlZiBHUkFESUVOVAogIGlmKHVfZ3JhZGllbnRUeXBlID4gMCAmJiBmbGFnQmFja2dyb3VuZCA+IDAuMCB8fCB1X2dyYWRpZW50VHlwZSA9PSAwICYmIGZsYWdCYWNrZ3JvdW5kIDw9IDAuMCkgewogICAgZ3JhZGllbnQoY29sb3IsIHZHcmFkaWVudFZlY3RvcjEsIHZHcmFkaWVudFZlY3RvcjIsIHVfY29sb3JTdGVwcyk7CiAgfQojZW5kaWYKCiAgaWYob3BhY2l0eSA8IDEuMCkgewogICAgY29sb3IuYSAqPSBvcGFjaXR5OwogIH0KCiNpZmRlZiBURVhUVVJFCiAgaWYoZmxhZ0JhY2tncm91bmQgPiAwLjApIHsKICAgIHZlYzMgdGV4Q29vcmQgPSB2VGV4dHVyZUNvb3JkOwoKICAgIGlmKHRleENvb3JkLnogPT0gMS4wKSB7CiAgICAgIHRleENvb3JkID0gZnJhY3QodGV4Q29vcmQpOwogICAgfQoKICAgIGlmKHRleENvb3JkLnggPD0gMS4wICYmIHRleENvb3JkLnggPj0gMC4wCiAgICAgICYmIHRleENvb3JkLnkgPD0gMS4wICYmIHRleENvb3JkLnkgPj0gMC4wKSB7CiAgICAgIGlmKHZTb3VyY2VSZWN0LnogPiAwLjApIHsKICAgICAgICB0ZXhDb29yZC54ID0gdlNvdXJjZVJlY3QueCArIHRleENvb3JkLnggKiB2U291cmNlUmVjdC56OwogICAgICAgIHRleENvb3JkLnkgPSAxLjAgLSAodlNvdXJjZVJlY3QueSArICgxLjAgLSB0ZXhDb29yZC55KSAqIHZTb3VyY2VSZWN0LncpOwogICAgICB9CiAgICAgIHZlYzQgdGV4Q29sb3IgPSB0ZXh0dXJlMkQodV90ZXhTYW1wbGVyLCB0ZXhDb29yZC54eSk7CiAgICAgIGZsb2F0IGFscGhhID0gdGV4Q29sb3IuYTsKICAgICAgaWYob3BhY2l0eSA8IDEuMCkgewogICAgICAgIHRleENvbG9yLmEgKj0gb3BhY2l0eTsKICAgICAgICBhbHBoYSAqPSBtaXgoMC40NjUsIDEuMCwgb3BhY2l0eSk7CiAgICAgIH0KICAgICAgLy8gY29sb3IgPSBtaXgoY29sb3IsIHRleENvbG9yLCB0ZXhDb2xvci5hKTsKICAgICAgY29sb3IucmdiID0gbWl4KGNvbG9yLnJnYiwgdGV4Q29sb3IucmdiLCBhbHBoYSk7CiAgICAgIC8vIGNvbG9yLnJnYiA9IG1peCh0ZXhDb2xvci5yZ2IsIGNvbG9yLnJnYiwgY29sb3IuYSk7CiAgICAgIGNvbG9yLnJnYiA9IG1peCh0ZXhDb2xvci5yZ2IsIGNvbG9yLnJnYiwgY2xhbXAoY29sb3IuYSAvIG1heCgwLjAwMDEsIHRleENvbG9yLmEpLCAwLjAsIDEuMCkpOwogICAgICBjb2xvci5hID0gdGV4Q29sb3IuYSArICgxLjAgLSB0ZXhDb2xvci5hKSAqIGNvbG9yLmE7CiAgICB9CiAgfQojZW5kaWYKCiNpZmRlZiBGSUxURVIKICBpZih1X2ZpbHRlckZsYWcgPiAwKSB7CiAgICB0cmFuc2Zvcm1Db2xvcihjb2xvciwgdV9jb2xvck1hdHJpeCk7CiAgfQojZW5kaWYKCiNpZmRlZiBDTElQUEFUSAogIGZsb2F0IGNsaXAgPSB0ZXh0dXJlMkQodV9jbGlwU2FtcGxlciwgdkNsaXBVVikucjsKICBjb2xvciAqPSBjbGlwOwojZW5kaWYKCiAgZ2xfRnJhZ0NvbG9yID0gY29sb3I7Cn1gfSxmdW5jdGlvbihjLGUsdCl7dC5yKGUpLGUuZGVmYXVsdD1gYXR0cmlidXRlIHZlYzMgYV92ZXJ0ZXhQb3NpdGlvbjsKYXR0cmlidXRlIHZlYzQgYV9jb2xvcjsKdmFyeWluZyB2ZWM0IHZDb2xvcjsKdmFyeWluZyBmbG9hdCBmbGFnQmFja2dyb3VuZDsKYXR0cmlidXRlIHZlYzMgYV90cmFuc2Zvcm0wOwphdHRyaWJ1dGUgdmVjMyBhX3RyYW5zZm9ybTE7CnVuaWZvcm0gdmVjMiB1X3Jlc29sdXRpb247CnVuaWZvcm0gbWF0MyB2aWV3TWF0cml4Owp1bmlmb3JtIG1hdDMgcHJvamVjdGlvbk1hdHJpeDsKCiNpZmRlZiBURVhUVVJFCmF0dHJpYnV0ZSB2ZWMzIGFfdmVydGV4VGV4dHVyZUNvb3JkOwp2YXJ5aW5nIHZlYzMgdlRleHR1cmVDb29yZDsKYXR0cmlidXRlIGZsb2F0IGFfZnJhbWVJbmRleDsKdmFyeWluZyBmbG9hdCBmcmFtZUluZGV4OwphdHRyaWJ1dGUgdmVjNCBhX3NvdXJjZVJlY3Q7CnZhcnlpbmcgdmVjNCB2U291cmNlUmVjdDsKI2VuZGlmCgojaWZkZWYgQ0xJUFBBVEgKYXR0cmlidXRlIHZlYzIgYV9jbGlwVVY7CnZhcnlpbmcgdmVjMiB2Q2xpcFVWOwojZW5kaWYKCiNpZmRlZiBDTE9VREZJTFRFUgphdHRyaWJ1dGUgdmVjNCBhX2NvbG9yQ2xvdWQwOwphdHRyaWJ1dGUgdmVjNCBhX2NvbG9yQ2xvdWQxOwphdHRyaWJ1dGUgdmVjNCBhX2NvbG9yQ2xvdWQyOwphdHRyaWJ1dGUgdmVjNCBhX2NvbG9yQ2xvdWQzOwphdHRyaWJ1dGUgdmVjNCBhX2NvbG9yQ2xvdWQ0Owp2YXJ5aW5nIHZlYzQgY29sb3JDbG91ZDA7CnZhcnlpbmcgdmVjNCBjb2xvckNsb3VkMTsKdmFyeWluZyB2ZWM0IGNvbG9yQ2xvdWQyOwp2YXJ5aW5nIHZlYzQgY29sb3JDbG91ZDM7CnZhcnlpbmcgdmVjNCBjb2xvckNsb3VkNDsKI2VuZGlmCgojaWZkZWYgQ0xPVURDT0xPUgphdHRyaWJ1dGUgdmVjNCBhX2ZpbGxDbG91ZENvbG9yOwphdHRyaWJ1dGUgdmVjNCBhX3N0cm9rZUNsb3VkQ29sb3I7CiNlbmRpZgoKI2lmZGVmIEdSQURJRU5UCnVuaWZvcm0gZmxvYXQgdV9yYWRpYWxHcmFkaWVudFZlY3Rvcls2XTsKdmFyeWluZyB2ZWMzIHZHcmFkaWVudFZlY3RvcjE7CnZhcnlpbmcgdmVjMyB2R3JhZGllbnRWZWN0b3IyOwojZW5kaWYKCnZvaWQgbWFpbigpIHsKICBnbF9Qb2ludFNpemUgPSAxLjA7CgogIG1hdDMgbW9kZWxNYXRyaXggPSBtYXQzKAogICAgYV90cmFuc2Zvcm0wLngsIGFfdHJhbnNmb3JtMS54LCAwLCAKICAgIGFfdHJhbnNmb3JtMC55LCBhX3RyYW5zZm9ybTEueSwgMCwKICAgIGFfdHJhbnNmb3JtMC56LCBhX3RyYW5zZm9ybTEueiwgMQogICk7CgogIHZlYzMgcG9zID0gcHJvamVjdGlvbk1hdHJpeCAqIHZpZXdNYXRyaXggKiBtb2RlbE1hdHJpeCAqIHZlYzMoYV92ZXJ0ZXhQb3NpdGlvbi54eSwgMS4wKTsKICBnbF9Qb3NpdGlvbiA9IHZlYzQocG9zLnh5LCAxLjAsIDEuMCk7CgojaWZkZWYgR1JBRElFTlQKICB2ZWMzIHZnMSA9IHZpZXdNYXRyaXggKiB2ZWMzKHVfcmFkaWFsR3JhZGllbnRWZWN0b3JbMF0sIHVfcmFkaWFsR3JhZGllbnRWZWN0b3JbMV0sIDEuMCk7CiAgdmVjMyB2ZzIgPSB2aWV3TWF0cml4ICogdmVjMyh1X3JhZGlhbEdyYWRpZW50VmVjdG9yWzNdLCB1X3JhZGlhbEdyYWRpZW50VmVjdG9yWzRdLCAxLjApOwogIGZsb2F0IGggPSB1X3Jlc29sdXRpb24ueTsKICB2ZzEueSA9IGggLSB2ZzEueTsKICB2ZzIueSA9IGggLSB2ZzIueTsKICB2R3JhZGllbnRWZWN0b3IxID0gdmVjMyh2ZzEueHksIHVfcmFkaWFsR3JhZGllbnRWZWN0b3JbMl0pOwogIHZHcmFkaWVudFZlY3RvcjIgPSB2ZWMzKHZnMi54eSwgdV9yYWRpYWxHcmFkaWVudFZlY3Rvcls1XSk7CiNlbmRpZgogIAogIGZsYWdCYWNrZ3JvdW5kID0gYV92ZXJ0ZXhQb3NpdGlvbi56OwoKI2lmZGVmIENMT1VEQ09MT1IKICBpZihmbGFnQmFja2dyb3VuZCA+IDAuMCkgewogICAgdkNvbG9yID0gbWl4KGFfY29sb3IsIGFfZmlsbENsb3VkQ29sb3IsIGFfZmlsbENsb3VkQ29sb3IuYSk7CiAgfSBlbHNlIHsKICAgIHZDb2xvciA9IG1peChhX2NvbG9yLCBhX3N0cm9rZUNsb3VkQ29sb3IsIGFfc3Ryb2tlQ2xvdWRDb2xvci5hKTsKICB9CiNlbHNlCiAgdkNvbG9yID0gYV9jb2xvcjsKI2VuZGlmCgojaWZkZWYgVEVYVFVSRQogIHZUZXh0dXJlQ29vcmQgPSBhX3ZlcnRleFRleHR1cmVDb29yZDsKICBmcmFtZUluZGV4ID0gYV9mcmFtZUluZGV4OwogIHZTb3VyY2VSZWN0ID0gYV9zb3VyY2VSZWN0OwojZW5kaWYKCiNpZmRlZiBDTElQUEFUSAogIHZDbGlwVVYgPSBhX2NsaXBVVjsKI2VuZGlmCgojaWZkZWYgQ0xPVURGSUxURVIKICBjb2xvckNsb3VkMCA9IGFfY29sb3JDbG91ZDA7CiAgY29sb3JDbG91ZDEgPSBhX2NvbG9yQ2xvdWQxOwogIGNvbG9yQ2xvdWQyID0gYV9jb2xvckNsb3VkMjsKICBjb2xvckNsb3VkMyA9IGFfY29sb3JDbG91ZDM7CiAgY29sb3JDbG91ZDQgPSBhX2NvbG9yQ2xvdWQ0OwojZW5kaWYKfWB9LGZ1bmN0aW9uKGMsZSx0KXt0LnIoZSksZS5kZWZhdWx0PWBwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDsKCnZhcnlpbmcgdmVjNCB2Q29sb3I7CnZhcnlpbmcgZmxvYXQgZmxhZ0JhY2tncm91bmQ7CgojaWZkZWYgVEVYVFVSRQp2YXJ5aW5nIGZsb2F0IGZyYW1lSW5kZXg7CnZhcnlpbmcgdmVjMyB2VGV4dHVyZUNvb3JkOwp2YXJ5aW5nIHZlYzQgdlNvdXJjZVJlY3Q7CiNlbmRpZgoKI2lmZGVmIENMSVBQQVRICnZhcnlpbmcgdmVjMiB2Q2xpcFVWOwojZW5kaWYKCiNpZmRlZiBGSUxURVIKdW5pZm9ybSBpbnQgdV9maWx0ZXJGbGFnOwp1bmlmb3JtIGZsb2F0IHVfY29sb3JNYXRyaXhbMjBdOwojZW5kaWYKCiNpZmRlZiBDTE9VREZJTFRFUgp2YXJ5aW5nIHZlYzQgY29sb3JDbG91ZDA7CnZhcnlpbmcgdmVjNCBjb2xvckNsb3VkMTsKdmFyeWluZyB2ZWM0IGNvbG9yQ2xvdWQyOwp2YXJ5aW5nIHZlYzQgY29sb3JDbG91ZDM7CnZhcnlpbmcgdmVjNCBjb2xvckNsb3VkNDsKI2VuZGlmCgojaWZkZWYgR1JBRElFTlQKdmFyeWluZyB2ZWMzIHZHcmFkaWVudFZlY3RvcjE7CnZhcnlpbmcgdmVjMyB2R3JhZGllbnRWZWN0b3IyOwp1bmlmb3JtIGZsb2F0IHVfY29sb3JTdGVwc1s0MF07CnVuaWZvcm0gaW50IHVfZ3JhZGllbnRUeXBlOwoKdm9pZCBncmFkaWVudChpbm91dCB2ZWM0IGNvbG9yLCB2ZWMzIGd2MSwgdmVjMyBndjIsIGZsb2F0IGNvbG9yU3RlcHNbNDBdKSB7CiAgZmxvYXQgdDsKICAvLyBjZW50ZXIgY2lyY2xlIHJhZGl1cwogIGZsb2F0IGNyID0gZ3YxLno7CiAgLy8gZm9jYWwgY2lyY2xlIHJhZGl1cwogIGZsb2F0IGZyID0gZ3YyLno7CgogIGlmKGNyID4gMC4wIHx8IGZyID4gMC4wKSB7CiAgICAvLyByYWRpYWwgZ3JhZGllbnQKICAgIHZlYzIgY2VudGVyID0gZ3YxLnh5OwogICAgdmVjMiBmb2NhbCA9IGd2Mi54eTsKICAgIGZsb2F0IHggPSBmb2NhbC54IC0gZ2xfRnJhZ0Nvb3JkLng7CiAgICBmbG9hdCB5ID0gZm9jYWwueSAtIGdsX0ZyYWdDb29yZC55OwogICAgZmxvYXQgZHggPSBmb2NhbC54IC0gY2VudGVyLng7CiAgICBmbG9hdCBkeSA9IGZvY2FsLnkgLSBjZW50ZXIueTsKICAgIGZsb2F0IGRyID0gY3IgLSBmcjsKICAgIGZsb2F0IGEgPSBkeCAqIGR4ICsgZHkgKiBkeSAtIGRyICogZHI7CiAgICBmbG9hdCBiID0gLTIuMCAqICh5ICogZHkgKyB4ICogZHggKyBmciAqIGRyKTsKICAgIGZsb2F0IGMgPSB4ICogeCArIHkgKiB5IC0gZnIgKiBmcjsKICAgIHQgPSAxLjAgLSAwLjUgKiAoMS4wIC8gYSkgKiAoLWIgKyBzcXJ0KGIgKiBiIC0gNC4wICogYSAqIGMpKTsKICB9IGVsc2UgewogICAgLy8gbGluZWFyIGdyYWRpZW50CiAgICB2ZWMyIHYxID0gZ2xfRnJhZ0Nvb3JkLnh5IC0gZ3YxLnh5OwogICAgdmVjMiB2MiA9IGd2Mi54eSAtIGd2MS54eTsKICAgIHQgPSAodjEueCAqIHYyLnggKyB2MS55ICogdjIueSkgLyAodjIueCAqIHYyLnggKyB2Mi55ICogdjIueSk7CiAgfQoKICB2ZWM0IGNvbG9yc1s4XTsKICBjb2xvcnNbMF0gPSB2ZWM0KGNvbG9yU3RlcHNbMV0sIGNvbG9yU3RlcHNbMl0sIGNvbG9yU3RlcHNbM10sIGNvbG9yU3RlcHNbNF0pOwogIGNvbG9yc1sxXSA9IHZlYzQoY29sb3JTdGVwc1s2XSwgY29sb3JTdGVwc1s3XSwgY29sb3JTdGVwc1s4XSwgY29sb3JTdGVwc1s5XSk7CiAgY29sb3JzWzJdID0gdmVjNChjb2xvclN0ZXBzWzExXSwgY29sb3JTdGVwc1sxMl0sIGNvbG9yU3RlcHNbMTNdLCBjb2xvclN0ZXBzWzE0XSk7CiAgY29sb3JzWzNdID0gdmVjNChjb2xvclN0ZXBzWzE2XSwgY29sb3JTdGVwc1sxN10sIGNvbG9yU3RlcHNbMThdLCBjb2xvclN0ZXBzWzE5XSk7CiAgY29sb3JzWzRdID0gdmVjNChjb2xvclN0ZXBzWzIxXSwgY29sb3JTdGVwc1syMl0sIGNvbG9yU3RlcHNbMjNdLCBjb2xvclN0ZXBzWzI0XSk7CiAgY29sb3JzWzVdID0gdmVjNChjb2xvclN0ZXBzWzI2XSwgY29sb3JTdGVwc1syN10sIGNvbG9yU3RlcHNbMjhdLCBjb2xvclN0ZXBzWzI5XSk7CiAgY29sb3JzWzZdID0gdmVjNChjb2xvclN0ZXBzWzMxXSwgY29sb3JTdGVwc1szMl0sIGNvbG9yU3RlcHNbMzNdLCBjb2xvclN0ZXBzWzM0XSk7CiAgY29sb3JzWzddID0gdmVjNChjb2xvclN0ZXBzWzM2XSwgY29sb3JTdGVwc1szN10sIGNvbG9yU3RlcHNbMzhdLCBjb2xvclN0ZXBzWzM5XSk7CiAgCiAgZmxvYXQgc3RlcHNbOF07CiAgc3RlcHNbMF0gPSBjb2xvclN0ZXBzWzBdOwogIHN0ZXBzWzFdID0gY29sb3JTdGVwc1s1XTsKICBzdGVwc1syXSA9IGNvbG9yU3RlcHNbMTBdOwogIHN0ZXBzWzNdID0gY29sb3JTdGVwc1sxNV07CiAgc3RlcHNbNF0gPSBjb2xvclN0ZXBzWzIwXTsKICBzdGVwc1s1XSA9IGNvbG9yU3RlcHNbMjVdOwogIHN0ZXBzWzZdID0gY29sb3JTdGVwc1szMF07CiAgc3RlcHNbN10gPSBjb2xvclN0ZXBzWzM1XTsKCiAgY29sb3IgPSBjb2xvcnNbMF07CiAgZm9yIChpbnQgaSA9IDE7IGkgPCA4OyBpKyspIHsKICAgIGlmIChzdGVwc1tpXSA8IDAuMCB8fCBzdGVwc1tpXSA+IDEuMCkgewogICAgICBicmVhazsKICAgIH0KICAgIGlmKHN0ZXBzW2ldID09IHN0ZXBzW2kgLSAxXSkgewogICAgICBjb2xvciA9IGNvbG9yc1tpXTsKICAgIH0gZWxzZSB7CiAgICAgIGNvbG9yID0gbWl4KGNvbG9yLCBjb2xvcnNbaV0sIGNsYW1wKCh0IC0gc3RlcHNbaSAtIDFdKSAvIChzdGVwc1tpXSAtIHN0ZXBzW2kgLSAxXSksIDAuMCwgMS4wKSk7CiAgICB9CiAgICBpZiAoc3RlcHNbaV0gPj0gdCkgewogICAgICBicmVhazsKICAgIH0KICB9Cn0KI2VuZGlmCgp2b2lkIHRyYW5zZm9ybUNvbG9yKGlub3V0IHZlYzQgY29sb3IsIGluIGZsb2F0IGNvbG9yTWF0cml4WzIwXSkgewogIGZsb2F0IHIgPSBjb2xvci5yLCBnID0gY29sb3IuZywgYiA9IGNvbG9yLmIsIGEgPSBjb2xvci5hOwogIGNvbG9yWzBdID0gY29sb3JNYXRyaXhbMF0gKiByICsgY29sb3JNYXRyaXhbMV0gKiBnICsgY29sb3JNYXRyaXhbMl0gKiBiICsgY29sb3JNYXRyaXhbM10gKiBhICsgY29sb3JNYXRyaXhbNF07CiAgY29sb3JbMV0gPSBjb2xvck1hdHJpeFs1XSAqIHIgKyBjb2xvck1hdHJpeFs2XSAqIGcgKyBjb2xvck1hdHJpeFs3XSAqIGIgKyBjb2xvck1hdHJpeFs4XSAqIGEgKyBjb2xvck1hdHJpeFs5XTsKICBjb2xvclsyXSA9IGNvbG9yTWF0cml4WzEwXSAqIHIgKyBjb2xvck1hdHJpeFsxMV0gKiBnICsgY29sb3JNYXRyaXhbMTJdICogYiArIGNvbG9yTWF0cml4WzEzXSAqIGEgKyBjb2xvck1hdHJpeFsxNF07CiAgY29sb3JbM10gPSBjb2xvck1hdHJpeFsxNV0gKiByICsgY29sb3JNYXRyaXhbMTZdICogZyArIGNvbG9yTWF0cml4WzE3XSAqIGIgKyBjb2xvck1hdHJpeFsxOF0gKiBhICsgY29sb3JNYXRyaXhbMTldOwp9CgojaWZkZWYgQ0xPVURGSUxURVIKdm9pZCBidWlsZENsb3VkQ29sb3IoaW5vdXQgZmxvYXQgY29sb3JDbG91ZE1hdHJpeFsyMF0pIHsKICBjb2xvckNsb3VkTWF0cml4WzBdID0gY29sb3JDbG91ZDBbMF07CiAgY29sb3JDbG91ZE1hdHJpeFsxXSA9IGNvbG9yQ2xvdWQxWzBdOwogIGNvbG9yQ2xvdWRNYXRyaXhbMl0gPSBjb2xvckNsb3VkMlswXTsKICBjb2xvckNsb3VkTWF0cml4WzNdID0gY29sb3JDbG91ZDNbMF07CiAgY29sb3JDbG91ZE1hdHJpeFs0XSA9IGNvbG9yQ2xvdWQ0WzBdOwoKICBjb2xvckNsb3VkTWF0cml4WzVdID0gY29sb3JDbG91ZDBbMV07CiAgY29sb3JDbG91ZE1hdHJpeFs2XSA9IGNvbG9yQ2xvdWQxWzFdOwogIGNvbG9yQ2xvdWRNYXRyaXhbN10gPSBjb2xvckNsb3VkMlsxXTsKICBjb2xvckNsb3VkTWF0cml4WzhdID0gY29sb3JDbG91ZDNbMV07CiAgY29sb3JDbG91ZE1hdHJpeFs5XSA9IGNvbG9yQ2xvdWQ0WzFdOwoKICBjb2xvckNsb3VkTWF0cml4WzEwXSA9IGNvbG9yQ2xvdWQwWzJdOwogIGNvbG9yQ2xvdWRNYXRyaXhbMTFdID0gY29sb3JDbG91ZDFbMl07CiAgY29sb3JDbG91ZE1hdHJpeFsxMl0gPSBjb2xvckNsb3VkMlsyXTsKICBjb2xvckNsb3VkTWF0cml4WzEzXSA9IGNvbG9yQ2xvdWQzWzJdOwogIGNvbG9yQ2xvdWRNYXRyaXhbMTRdID0gY29sb3JDbG91ZDRbMl07CgogIGNvbG9yQ2xvdWRNYXRyaXhbMTVdID0gY29sb3JDbG91ZDBbM107CiAgY29sb3JDbG91ZE1hdHJpeFsxNl0gPSBjb2xvckNsb3VkMVszXTsKICBjb2xvckNsb3VkTWF0cml4WzE3XSA9IGNvbG9yQ2xvdWQyWzNdOwogIGNvbG9yQ2xvdWRNYXRyaXhbMThdID0gY29sb3JDbG91ZDNbM107CiAgY29sb3JDbG91ZE1hdHJpeFsxOV0gPSBjb2xvckNsb3VkNFszXTsKfQojZW5kaWYKCnZvaWQgbWFpbigpIHsKICB2ZWM0IGNvbG9yID0gdkNvbG9yOwogIGZsb2F0IG9wYWNpdHkgPSBhYnMoZmxhZ0JhY2tncm91bmQpOwoKI2lmZGVmIEdSQURJRU5UCiAgaWYodV9ncmFkaWVudFR5cGUgPiAwICYmIGZsYWdCYWNrZ3JvdW5kID4gMC4wIHx8IHVfZ3JhZGllbnRUeXBlID09IDAgJiYgZmxhZ0JhY2tncm91bmQgPD0gMC4wKSB7CiAgICBncmFkaWVudChjb2xvciwgdkdyYWRpZW50VmVjdG9yMSwgdkdyYWRpZW50VmVjdG9yMiwgdV9jb2xvclN0ZXBzKTsKICB9CiNlbmRpZgoKICBpZihvcGFjaXR5IDwgMS4wKSB7CiAgICBjb2xvci5hICo9IG9wYWNpdHk7CiAgfQoKI2lmZGVmIFRFWFRVUkUKICBpZihmbGFnQmFja2dyb3VuZCA+IDAuMCkgewogICAgdmVjMyB0ZXhDb29yZCA9IHZUZXh0dXJlQ29vcmQ7CgogICAgaWYodGV4Q29vcmQueiA9PSAxLjApIHsKICAgICAgdGV4Q29vcmQgPSBmcmFjdCh0ZXhDb29yZCk7CiAgICB9CgogICAgaWYodGV4Q29vcmQueCA8PSAxLjAgJiYgdGV4Q29vcmQueCA+PSAwLjAKICAgICAgJiYgdGV4Q29vcmQueSA8PSAxLjAgJiYgdGV4Q29vcmQueSA+PSAwLjApIHsKICAgICAgaWYodlNvdXJjZVJlY3QueiA+IDAuMCkgewogICAgICAgIHRleENvb3JkLnggPSB2U291cmNlUmVjdC54ICsgdGV4Q29vcmQueCAqIHZTb3VyY2VSZWN0Lno7CiAgICAgICAgdGV4Q29vcmQueSA9IDEuMCAtICh2U291cmNlUmVjdC55ICsgKDEuMCAtIHRleENvb3JkLnkpICogdlNvdXJjZVJlY3Qudyk7CiAgICAgIH0KICAgICAgaWYoZnJhbWVJbmRleCA8IDAuMCkgewogICAgICAgIHZlYzQgdGV4Q29sb3IgPSB0ZXh0dXJlMkQodV90ZXhTYW1wbGVyLCB0ZXhDb29yZC54eSk7CiAgICAgICAgY29sb3IgPSBtaXgoY29sb3IsIHRleENvbG9yLCB0ZXhDb2xvci5hKTsKICAgICAgfSBlbHNlIHsKICAgICAgICBpbnQgaW5kZXggPSBpbnQoZmxvb3IoY2xhbXAoMC4wLCAxMS4wLCBmcmFtZUluZGV4KSkpOwogICAgICAgIHZlYzQgdGV4Q29sb3I7CiAgICAgICAgaWYoaW5kZXggPT0gMCkgdGV4Q29sb3IgPSB0ZXh0dXJlMkQodV90ZXhGcmFtZTAsIHRleENvb3JkLnh5KTsKICAgICAgICBlbHNlIGlmKGluZGV4ID09IDEpIHRleENvbG9yID0gdGV4dHVyZTJEKHVfdGV4RnJhbWUxLCB0ZXhDb29yZC54eSk7CiAgICAgICAgZWxzZSBpZihpbmRleCA9PSAyKSB0ZXhDb2xvciA9IHRleHR1cmUyRCh1X3RleEZyYW1lMiwgdGV4Q29vcmQueHkpOwogICAgICAgIGVsc2UgaWYoaW5kZXggPT0gMykgdGV4Q29sb3IgPSB0ZXh0dXJlMkQodV90ZXhGcmFtZTMsIHRleENvb3JkLnh5KTsKICAgICAgICBlbHNlIGlmKGluZGV4ID09IDQpIHRleENvbG9yID0gdGV4dHVyZTJEKHVfdGV4RnJhbWU0LCB0ZXhDb29yZC54eSk7CiAgICAgICAgZWxzZSBpZihpbmRleCA9PSA1KSB0ZXhDb2xvciA9IHRleHR1cmUyRCh1X3RleEZyYW1lNSwgdGV4Q29vcmQueHkpOwogICAgICAgIGVsc2UgaWYoaW5kZXggPT0gNikgdGV4Q29sb3IgPSB0ZXh0dXJlMkQodV90ZXhGcmFtZTYsIHRleENvb3JkLnh5KTsKICAgICAgICBlbHNlIGlmKGluZGV4ID09IDcpIHRleENvbG9yID0gdGV4dHVyZTJEKHVfdGV4RnJhbWU3LCB0ZXhDb29yZC54eSk7CiAgICAgICAgZWxzZSBpZihpbmRleCA9PSA4KSB0ZXhDb2xvciA9IHRleHR1cmUyRCh1X3RleEZyYW1lOCwgdGV4Q29vcmQueHkpOwogICAgICAgIGVsc2UgaWYoaW5kZXggPT0gOSkgdGV4Q29sb3IgPSB0ZXh0dXJlMkQodV90ZXhGcmFtZTksIHRleENvb3JkLnh5KTsKICAgICAgICBlbHNlIGlmKGluZGV4ID09IDEwKSB0ZXhDb2xvciA9IHRleHR1cmUyRCh1X3RleEZyYW1lMTAsIHRleENvb3JkLnh5KTsKICAgICAgICBlbHNlIHRleENvbG9yID0gdGV4dHVyZTJEKHVfdGV4RnJhbWUxMSwgdGV4Q29vcmQueHkpOwogICAgICAgIGZsb2F0IGFscGhhID0gdGV4Q29sb3IuYTsKICAgICAgICBpZihvcGFjaXR5IDwgMS4wKSB7CiAgICAgICAgICB0ZXhDb2xvci5hICo9IG9wYWNpdHk7CiAgICAgICAgICBhbHBoYSAqPSBtaXgoMC40NjUsIDEuMCwgb3BhY2l0eSk7CiAgICAgICAgfQogICAgICAgIC8vIGNvbG9yID0gbWl4KGNvbG9yLCB0ZXhDb2xvciwgdGV4Q29sb3IuYSk7CiAgICAgICAgY29sb3IucmdiID0gbWl4KGNvbG9yLnJnYiwgdGV4Q29sb3IucmdiLCBhbHBoYSk7CiAgICAgICAgLy8gY29sb3IucmdiID0gbWl4KHRleENvbG9yLnJnYiwgY29sb3IucmdiLCBjb2xvci5hKTsKICAgICAgICBjb2xvci5yZ2IgPSBtaXgodGV4Q29sb3IucmdiLCBjb2xvci5yZ2IsIGNsYW1wKGNvbG9yLmEgLyBtYXgoMC4wMDAxLCB0ZXhDb2xvci5hKSwgMC4wLCAxLjApKTsKICAgICAgICBjb2xvci5hID0gdGV4Q29sb3IuYSArICgxLjAgLSB0ZXhDb2xvci5hKSAqIGNvbG9yLmE7CiAgICAgIH0KICAgIH0KICB9CiNlbmRpZgoKI2lmZGVmIEZJTFRFUgogIGlmKHVfZmlsdGVyRmxhZyA+IDApIHsKICAgIHRyYW5zZm9ybUNvbG9yKGNvbG9yLCB1X2NvbG9yTWF0cml4KTsKICB9CiNlbmRpZgoKI2lmZGVmIENMT1VERklMVEVSCiAgZmxvYXQgY29sb3JDbG91ZE1hdHJpeFsyMF07CiAgYnVpbGRDbG91ZENvbG9yKGNvbG9yQ2xvdWRNYXRyaXgpOwogIHRyYW5zZm9ybUNvbG9yKGNvbG9yLCBjb2xvckNsb3VkTWF0cml4KTsKI2VuZGlmCgojaWZkZWYgQ0xJUFBBVEgKICBmbG9hdCBjbGlwID0gdGV4dHVyZTJEKHVfY2xpcFNhbXBsZXIsIHZDbGlwVVYpLnI7CiAgY29sb3IgKj0gY2xpcDsKI2VuZGlmCgogIGdsX0ZyYWdDb2xvciA9IGNvbG9yOwp9YH0sZnVuY3Rpb24oYyxlLHQpe3QucihlKSwoZnVuY3Rpb24ocixzKXt0LmQoZSwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIixmdW5jdGlvbigpe3JldHVybiB2fSksdC5kKGUsImNhbmNlbEFuaW1hdGlvbkZyYW1lIixmdW5jdGlvbigpe3JldHVybiBofSksdCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIGcoKXtpZih0eXBlb2YgcGVyZm9ybWFuY2U8InUiJiZwZXJmb3JtYW5jZS5ub3cpcmV0dXJuIHBlcmZvcm1hbmNlLm5vdygpO2lmKHR5cGVvZiByPCJ1IiYmci5ocnRpbWUpe2NvbnN0W2wsdV09ci5ocnRpbWUoKTtyZXR1cm4gbCoxZTMrdSoxZS02fXJldHVybiBEYXRlLm5vdz9EYXRlLm5vdygpOm5ldyBEYXRlKCkuZ2V0VGltZSgpfWxldCB2LGg7dHlwZW9mIHM8InUiJiZ0eXBlb2Ygcy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU9PSJmdW5jdGlvbiI/KHY9cy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUsaD1zLmNhbmNlbEFuaW1hdGlvbkZyYW1lKToodj1mdW5jdGlvbihsKXtyZXR1cm4gc2V0VGltZW91dCgoKT0+e2woZygpKX0sMTYpfSxoPWZ1bmN0aW9uKGwpe3JldHVybiBjbGVhclRpbWVvdXQobCl9KX0pLmNhbGwodGhpcyx0KDY5KSx0KDIyKSl9LGZ1bmN0aW9uKGMsZSl7dmFyIHQ9Yy5leHBvcnRzPXt9LHIscztmdW5jdGlvbiBnKCl7dGhyb3cgbmV3IEVycm9yKCJzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkIil9ZnVuY3Rpb24gdigpe3Rocm93IG5ldyBFcnJvcigiY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkIil9KGZ1bmN0aW9uKCl7dHJ5e3R5cGVvZiBzZXRUaW1lb3V0PT0iZnVuY3Rpb24iP3I9c2V0VGltZW91dDpyPWd9Y2F0Y2h7cj1nfXRyeXt0eXBlb2YgY2xlYXJUaW1lb3V0PT0iZnVuY3Rpb24iP3M9Y2xlYXJUaW1lb3V0OnM9dn1jYXRjaHtzPXZ9fSkoKTtmdW5jdGlvbiBoKHApe2lmKHI9PT1zZXRUaW1lb3V0KXJldHVybiBzZXRUaW1lb3V0KHAsMCk7aWYoKHI9PT1nfHwhcikmJnNldFRpbWVvdXQpcmV0dXJuIHI9c2V0VGltZW91dCxzZXRUaW1lb3V0KHAsMCk7dHJ5e3JldHVybiByKHAsMCl9Y2F0Y2h7dHJ5e3JldHVybiByLmNhbGwobnVsbCxwLDApfWNhdGNoe3JldHVybiByLmNhbGwodGhpcyxwLDApfX19ZnVuY3Rpb24gbChwKXtpZihzPT09Y2xlYXJUaW1lb3V0KXJldHVybiBjbGVhclRpbWVvdXQocCk7aWYoKHM9PT12fHwhcykmJmNsZWFyVGltZW91dClyZXR1cm4gcz1jbGVhclRpbWVvdXQsY2xlYXJUaW1lb3V0KHApO3RyeXtyZXR1cm4gcyhwKX1jYXRjaHt0cnl7cmV0dXJuIHMuY2FsbChudWxsLHApfWNhdGNoe3JldHVybiBzLmNhbGwodGhpcyxwKX19fXZhciB1PVtdLE09ITEsZix5PS0xO2Z1bmN0aW9uIHgoKXshTXx8IWZ8fChNPSExLGYubGVuZ3RoP3U9Zi5jb25jYXQodSk6eT0tMSx1Lmxlbmd0aCYmYigpKX1mdW5jdGlvbiBiKCl7aWYoIU0pe3ZhciBwPWgoeCk7TT0hMDtmb3IodmFyIG49dS5sZW5ndGg7bjspe2ZvcihmPXUsdT1bXTsrK3k8bjspZiYmZlt5XS5ydW4oKTt5PS0xLG49dS5sZW5ndGh9Zj1udWxsLE09ITEsbChwKX19dC5uZXh0VGljaz1mdW5jdGlvbihwKXt2YXIgbj1uZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aC0xKTtpZihhcmd1bWVudHMubGVuZ3RoPjEpZm9yKHZhciBhPTE7YTxhcmd1bWVudHMubGVuZ3RoO2ErKyluW2EtMV09YXJndW1lbnRzW2FdO3UucHVzaChuZXcgTyhwLG4pKSx1Lmxlbmd0aD09PTEmJiFNJiZoKGIpfTtmdW5jdGlvbiBPKHAsbil7dGhpcy5mdW49cCx0aGlzLmFycmF5PW59Ty5wcm90b3R5cGUucnVuPWZ1bmN0aW9uKCl7dGhpcy5mdW4uYXBwbHkobnVsbCx0aGlzLmFycmF5KX0sdC50aXRsZT0iYnJvd3NlciIsdC5icm93c2VyPSEwLHQuZW52PXt9LHQuYXJndj1bXSx0LnZlcnNpb249IiIsdC52ZXJzaW9ucz17fTtmdW5jdGlvbiBtKCl7fXQub249bSx0LmFkZExpc3RlbmVyPW0sdC5vbmNlPW0sdC5vZmY9bSx0LnJlbW92ZUxpc3RlbmVyPW0sdC5yZW1vdmVBbGxMaXN0ZW5lcnM9bSx0LmVtaXQ9bSx0LnByZXBlbmRMaXN0ZW5lcj1tLHQucHJlcGVuZE9uY2VMaXN0ZW5lcj1tLHQubGlzdGVuZXJzPWZ1bmN0aW9uKHApe3JldHVybltdfSx0LmJpbmRpbmc9ZnVuY3Rpb24ocCl7dGhyb3cgbmV3IEVycm9yKCJwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCIpfSx0LmN3ZD1mdW5jdGlvbigpe3JldHVybiIvIn0sdC5jaGRpcj1mdW5jdGlvbihwKXt0aHJvdyBuZXcgRXJyb3IoInByb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCIpfSx0LnVtYXNrPWZ1bmN0aW9uKCl7cmV0dXJuIDB9fSxmdW5jdGlvbihjLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBDfSk7dmFyIHI9dCgxKSxzPXQoNzEpLGc9dCg3Myksdj10KDIxMyksaD10KDIxNCksbD10KDIxNSksdT10KDIxNik7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIE0oSSxBKXt2YXIgTD1PYmplY3Qua2V5cyhJKTtpZihPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKXt2YXIgRD1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKEkpO0EmJihEPUQuZmlsdGVyKGZ1bmN0aW9uKFIpe3JldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKEksUikuZW51bWVyYWJsZX0pKSxMLnB1c2guYXBwbHkoTCxEKX1yZXR1cm4gTH1mdW5jdGlvbiBmKEkpe2Zvcih2YXIgQT0xO0E8YXJndW1lbnRzLmxlbmd0aDtBKyspe3ZhciBMPWFyZ3VtZW50c1tBXSE9bnVsbD9hcmd1bWVudHNbQV06e307QSUyP00oT2JqZWN0KEwpLCEwKS5mb3JFYWNoKGZ1bmN0aW9uKEQpe3koSSxELExbRF0pfSk6T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnM/T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoSSxPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhMKSk6TShPYmplY3QoTCkpLmZvckVhY2goZnVuY3Rpb24oRCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KEksRCxPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKEwsRCkpfSl9cmV0dXJuIEl9ZnVuY3Rpb24geShJLEEsTCl7cmV0dXJuIEEgaW4gST9PYmplY3QuZGVmaW5lUHJvcGVydHkoSSxBLHt2YWx1ZTpMLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6SVtBXT1MLEl9Y29uc3QgeD1TeW1ib2wuZm9yKCJzcHJpdGVqc19jaGFuZ2VkQXR0cnMiKSxiPVN5bWJvbC5mb3IoInNwcml0ZWpzX2F0dHJpYnV0ZXMiKSxPPVN5bWJvbCgicmVzb2x1dGlvbiIpLG09U3ltYm9sKCJhbmltYXRpb25zIikscD1TeW1ib2woImV2ZW50TGlzdGVuZXJzIiksbj1TeW1ib2woImNhcHR1cmVFdmVudExpc3RlbmVycyIpLGE9U3ltYm9sKCJmaWx0ZXJzIiksaT1TeW1ib2woImRpc3BsYXkiKSxvPVN5bWJvbCgicHJvZ3JhbSIpLFQ9U3ltYm9sKCJzaGFkZXJBdHRycyIpLFA9U3ltYm9sKCJ1bmlmb3JtcyIpO2NsYXNzIEN7Y29uc3RydWN0b3IoQT17fSl7dGhpcy5hdHRyaWJ1dGVzPW5ldyB0aGlzLmNvbnN0cnVjdG9yLkF0dHIodGhpcyksdGhpc1tPXT17d2lkdGg6MzAwLGhlaWdodDoxNTB9LE9iamVjdC5hc3NpZ24odGhpcy5hdHRyaWJ1dGVzLEEpLHRoaXNbbV09bmV3IFNldCx0aGlzW3BdPXt9LHRoaXNbbl09e319Z2V0IGFuY2VzdG9ycygpe2xldCBBPXRoaXMucGFyZW50O2NvbnN0IEw9W107Zm9yKDtBOylMLnB1c2goQSksQT1BLnBhcmVudDtyZXR1cm4gTH1nZXQgYW5pbWF0aW9ucygpe3JldHVybiB0aGlzW21dfWdldCBmaWx0ZXJzKCl7cmV0dXJuIHRoaXNbYV18fHRoaXMucGFyZW50JiZ0aGlzLnBhcmVudC5maWx0ZXJzfWdldCBpc1Zpc2libGUoKXtyZXR1cm4hMX1nZXQgbGF5ZXIoKXtyZXR1cm4gdGhpcy5wYXJlbnQ/dGhpcy5wYXJlbnQubGF5ZXI6bnVsbH1nZXQgbG9jYWxNYXRyaXgoKXtjb25zdCBBPXRoaXMudHJhbnNmb3JtTWF0cml4LHt4OkwseTpEfT10aGlzLmF0dHJpYnV0ZXM7cmV0dXJuIEFbNF0rPUwsQVs1XSs9RCxBfWdldCBvcGFjaXR5KCl7bGV0IEE9dGhpcy5hdHRyaWJ1dGVzLm9wYWNpdHk7cmV0dXJuIHRoaXMucGFyZW50JiZ0aGlzLnBhcmVudC5vcGFjaXR5IT1udWxsJiYoQSo9dGhpcy5wYXJlbnQub3BhY2l0eSksQX1nZXQgcGFyZW50Tm9kZSgpe3JldHVybiB0aGlzLnBhcmVudH1nZXQgbmV4dFNpYmxpbmcoKXtyZXR1cm4gdGhpcy5nZXROb2RlTmVhckJ5KDEpfWdldCBwcmV2aW91c1NpYmxpbmcoKXtyZXR1cm4gdGhpcy5nZXROb2RlTmVhckJ5KC0xKX1nZXQgcHJvZ3JhbSgpe3JldHVybiB0aGlzW29dfWdldCByZW5kZXJlcigpe3JldHVybiB0aGlzLnBhcmVudD90aGlzLnBhcmVudC5yZW5kZXJlcjpudWxsfWdldCByZW5kZXJNYXRyaXgoKXtpZih0aGlzLl9fY2FjaGVSZW5kZXJNYXRyaXgpcmV0dXJuIHRoaXMuX19jYWNoZVJlbmRlck1hdHJpeDtsZXQgQT10aGlzLmxvY2FsTWF0cml4O2NvbnN0IEw9dGhpcy5wYXJlbnQ7aWYoTCl7Y29uc3QgRD1MLl9fY2FjaGVSZW5kZXJNYXRyaXh8fEwucmVuZGVyTWF0cml4O0QmJihBPXIubWF0MmQubXVsdGlwbHkoQXJyYXkub2YoMCwwLDAsMCwwLDApLEQsQSkpfXJldHVybiBBfWdldCB3b3JsZFNjYWxpbmcoKXtjb25zdCBBPXRoaXMucmVuZGVyTWF0cml4O3JldHVybltNYXRoLmh5cG90KEFbMF0sQVsxXSksTWF0aC5oeXBvdChBWzJdLEFbM10pXX1nZXQgd29ybGRSb3RhdGlvbigpe2NvbnN0IEE9dGhpcy5yZW5kZXJNYXRyaXg7cmV0dXJuIE1hdGguYXRhbjIoQVsxXSxBWzNdKX1nZXQgd29ybGRQb3NpdGlvbigpe2NvbnN0IEE9dGhpcy5yZW5kZXJNYXRyaXg7cmV0dXJuW0FbNF0sQVs1XV19Z2V0IHVuaWZvcm1zKCl7cmV0dXJuIHRoaXNbUF19Z2V0IGNsYXNzTmFtZSgpe3JldHVybiB0aGlzLmF0dHJpYnV0ZXMuY2xhc3NOYW1lfXNldCBjbGFzc05hbWUoQSl7dGhpcy5hdHRyaWJ1dGVzLmNsYXNzTmFtZT1BfWdldCBpZCgpe3JldHVybiB0aGlzLmF0dHJpYnV0ZXMuaWR9c2V0IGlkKEEpe3RoaXMuYXR0cmlidXRlcy5pZD1BfWdldCBuYW1lKCl7cmV0dXJuIHRoaXMuYXR0cmlidXRlcy5uYW1lfXNldCBuYW1lKEEpe3RoaXMuYXR0cmlidXRlcy5uYW1lPUF9Z2V0IHpJbmRleCgpe3JldHVybiB0aGlzLmF0dHJpYnV0ZXMuekluZGV4fXNldCB6SW5kZXgoQSl7dGhpcy5hdHRyaWJ1dGVzLnpJbmRleD1BfWdldCBtZXNoKCl7cmV0dXJuIG51bGx9Z2V0IHNoYWRlckF0dHJzKCl7cmV0dXJuIHRoaXNbVF18fHt9fWFjdGl2YXRlQW5pbWF0aW9ucygpe2NvbnN0IEE9dGhpcy5sYXllcjtpZihBKXtjb25zdCBMPXRoaXNbbV07TC5mb3JFYWNoKFI9PntSLmJhc2VUaW1lbGluZT1BLnRpbWVsaW5lLFIucGxheSgpLFIuZmluaXNoZWQudGhlbigoKT0+e0wuZGVsZXRlKFIpfSl9KTtjb25zdCBEPXRoaXMuY2hpbGRyZW47RCYmRC5mb3JFYWNoKFI9PntSLmFjdGl2YXRlQW5pbWF0aW9ucyYmUi5hY3RpdmF0ZUFuaW1hdGlvbnMoKX0pfX1hZGRFdmVudExpc3RlbmVyKEEsTCxEPXt9KXtBPT09Im1vdXNld2hlZWwiJiYoQT0id2hlZWwiKSx0eXBlb2YgRD09ImJvb2xlYW4iJiYoRD17Y2FwdHVyZTpEfSk7Y29uc3R7Y2FwdHVyZTpSLG9uY2U6U309RCxCPVI/bjpwO3JldHVybiB0aGlzW0JdW0FdPXRoaXNbQl1bQV18fFtdLHRoaXNbQl1bQV0ucHVzaCh7bGlzdGVuZXI6TCxvbmNlOlN9KSx0aGlzfWFuaW1hdGUoQSxMKXtjb25zdCBEPW5ldyBnLmRlZmF1bHQodGhpcyxBLEwpO3JldHVybiB0aGlzLmVmZmVjdHMmJkQuYXBwbHlFZmZlY3RzKHRoaXMuZWZmZWN0cyksdGhpcy5sYXllciYmKEQuYmFzZVRpbWVsaW5lPXRoaXMubGF5ZXIudGltZWxpbmUsRC5wbGF5KCksRC5maW5pc2hlZC50aGVuKCgpPT57dGhpc1ttXS5kZWxldGUoRCl9KSksdGhpc1ttXS5hZGQoRCksRH1hdHRyKC4uLkEpe2lmKEEubGVuZ3RoPT09MClyZXR1cm4gdGhpcy5hdHRyaWJ1dGVzW2JdO2lmKEEubGVuZ3RoPjEpe2xldFtMLERdPUE7cmV0dXJuIHR5cGVvZiBEPT0iZnVuY3Rpb24iJiYoRD1EKHRoaXMuYXR0cihMKSkpLHRoaXMuc2V0QXR0cmlidXRlKEwsRCksdGhpc31yZXR1cm4gdHlwZW9mIEFbMF09PSJzdHJpbmciP3RoaXMuZ2V0QXR0cmlidXRlKEFbMF0pOihPYmplY3QuYXNzaWduKHRoaXMuYXR0cmlidXRlcyxBWzBdKSx0aGlzKX1jbG9uZU5vZGUoKXtjb25zdCBBPW5ldyB0aGlzLmNvbnN0cnVjdG9yLEw9dGhpcy5hdHRyaWJ1dGVzW3hdO3JldHVybiBBLmF0dHIoTCksQX1jb25uZWN0KEEsTCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInBhcmVudCIse3ZhbHVlOkEsd3JpdGFibGU6ITEsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInpPcmRlciIse3ZhbHVlOkwsd3JpdGFibGU6ITEsY29uZmlndXJhYmxlOiEwfSksQS50aW1lbGluZSYmdGhpcy5hY3RpdmF0ZUFuaW1hdGlvbnMoKSx0aGlzLnNldFJlc29sdXRpb24oQS5nZXRSZXNvbHV0aW9uKCkpLHRoaXMuZm9yY2VVcGRhdGUoKSx0aGlzLmRpc3BhdGNoRXZlbnQoe3R5cGU6ImFwcGVuZCIsZGV0YWlsOntwYXJlbnQ6QSx6T3JkZXI6TH19KX1jb250YWlucyhBKXtmb3IoO0EmJnRoaXMhPT1BOylBPUEucGFyZW50O3JldHVybiEhQX1kZWFjdGl2YXRlQW5pbWF0aW9ucygpe3RoaXNbbV0uZm9yRWFjaChMPT5MLmNhbmNlbCgpKTtjb25zdCBBPXRoaXMuY2hpbGRyZW47QSYmQS5mb3JFYWNoKEw9PntMLmRlYWN0aXZhdGVBbmltYXRpb25zJiZMLmRlYWN0aXZhdGVBbmltYXRpb25zKCl9KX1kaXNjb25uZWN0KCl7Y29uc3R7cGFyZW50OkEsek9yZGVyOkx9PXRoaXM7ZGVsZXRlIHRoaXMucGFyZW50LGRlbGV0ZSB0aGlzLnpPcmRlcix0aGlzLmRlYWN0aXZhdGVBbmltYXRpb25zKCksdGhpcy5kaXNwYXRjaEV2ZW50KHt0eXBlOiJyZW1vdmUiLGRldGFpbDp7cGFyZW50OkEsek9yZGVyOkx9fSksQSYmQS5mb3JjZVVwZGF0ZSgpfWRpc3BhdGNoRXZlbnQoQSl7QSBpbnN0YW5jZW9mIGguZGVmYXVsdHx8KEE9bmV3IGguZGVmYXVsdChBKSksQS50YXJnZXQ9dGhpcztsZXQgTD1BLnR5cGU7TD09PSJtb3VzZXdoZWVsIiYmKEw9IndoZWVsIik7Y29uc3QgRD1bdGhpc107bGV0IFI9dGhpcy5wYXJlbnQ7Zm9yKDtBLmJ1YmJsZXMmJlI7KUQucHVzaChSKSxSPVIucGFyZW50O2ZvcihsZXQgUz1ELmxlbmd0aC0xO1M+PTA7Uy0tKXtjb25zdCBCPURbU10sdz1CW25dJiZCW25dW0xdO2lmKHcmJncubGVuZ3RoJiYoQS5jdXJyZW50VGFyZ2V0PUIsdy5mb3JFYWNoKCh7bGlzdGVuZXI6SCxvbmNlOkp9KT0+e0guY2FsbCh0aGlzLEEpLEomJkQucmVtb3ZlRXZlbnRMaXN0ZW5lcihIKX0pLGRlbGV0ZSBBLmN1cnJlbnRUYXJnZXQpLCFBLmJ1YmJsZXMmJkEuY2FuY2VsQnViYmxlKWJyZWFrfWlmKCFBLmNhbmNlbEJ1YmJsZSlmb3IobGV0IFM9MDtTPEQubGVuZ3RoO1MrKyl7Y29uc3QgQj1EW1NdLHc9QltwXSYmQltwXVtMXTtpZih3JiZ3Lmxlbmd0aCYmKEEuY3VycmVudFRhcmdldD1CLHcuZm9yRWFjaCgoe2xpc3RlbmVyOkgsb25jZTpKfSk9PntILmNhbGwodGhpcyxBKSxKJiZELnJlbW92ZUV2ZW50TGlzdGVuZXIoSCl9KSxkZWxldGUgQS5jdXJyZW50VGFyZ2V0KSwhQS5idWJibGVzfHxBLmNhbmNlbEJ1YmJsZSlicmVha319ZGlzcGF0Y2hQb2ludGVyRXZlbnQoQSl7Y29uc3R7bGF5ZXJYOkwsbGF5ZXJZOkR9PUE7cmV0dXJuIHRoaXMuaXNQb2ludENvbGxpc2lvbihMLEQpPyh0aGlzLmRpc3BhdGNoRXZlbnQoQSksITApOiExfWRyYXcoQT1bXSl7Y29uc3QgTD10aGlzLm1lc2g7aWYoTCl7aWYoT2JqZWN0KGwuYXBwbHlGaWx0ZXJzKShMLHRoaXMuZmlsdGVycyksQS5wdXNoKEwpLHRoaXNbb10pe0wuc2V0UHJvZ3JhbSh0aGlzW29dKTtjb25zdCBEPXRoaXNbVF07RCYmT2JqZWN0LmVudHJpZXMoRCkuZm9yRWFjaCgoW1MsQl0pPT57TC5zZXRBdHRyaWJ1dGUoUyxCKX0pO2NvbnN0IFI9dGhpc1tQXTtpZih0aGlzW1BdKXtjb25zdCBTPXt9O09iamVjdC5lbnRyaWVzKFIpLmZvckVhY2goKFtCLHddKT0+e3R5cGVvZiB3PT0iZnVuY3Rpb24iJiYodz13KHRoaXMsQikpLFNbQl09d30pLEwuc2V0VW5pZm9ybXMoUyl9fU9iamVjdCh1LmRlZmF1bHQpKHRoaXMsTCl9cmV0dXJuIEF9Zm9yY2VVcGRhdGUoKXt0aGlzLnBhcmVudCYmdGhpcy5wYXJlbnQuZm9yY2VVcGRhdGUoKX1nZXRBdHRyaWJ1dGUoQSl7cmV0dXJuIHRoaXMuYXR0cmlidXRlc1tBXX1nZXRMaXN0ZW5lcnMoQSx7Y2FwdHVyZTpMPSExfT17fSl7cmV0dXJuWy4uLnRoaXNbTD9uOnBdW0FdfHxbXV19Z2V0Tm9kZU5lYXJCeShBPTEpe2lmKCF0aGlzLnBhcmVudClyZXR1cm4gbnVsbDtpZihBPT09MClyZXR1cm4gdGhpcztjb25zdCBMPXRoaXMucGFyZW50LmNoaWxkcmVuLEQ9TC5pbmRleE9mKHRoaXMpO3JldHVybiBMW0QrQV19Z2V0V29ybGRQb3NpdGlvbihBLEwpe2NvbnN0IEQ9dGhpcy5yZW5kZXJNYXRyaXgsUj1BKkRbMF0rTCpEWzJdK0RbNF0sUz1BKkRbMV0rTCpEWzNdK0RbNV07cmV0dXJuW1IsU119Z2V0T2Zmc2V0UG9zaXRpb24oQSxMKXtjb25zdCBEPXIubWF0MmQuaW52ZXJ0KEFycmF5Lm9mKDAsMCwwLDAsMCwwKSx0aGlzLnJlbmRlck1hdHJpeCksUj1BKkRbMF0rTCpEWzJdK0RbNF0sUz1BKkRbMV0rTCpEWzNdK0RbNV07cmV0dXJuW1IsU119Z2V0UmVzb2x1dGlvbigpe3JldHVybiBmKHt9LHRoaXNbT10pfWlzUG9pbnRDb2xsaXNpb24oQSxMKXtpZighdGhpcy5tZXNoKXJldHVybiExO2NvbnN0IEQ9dGhpcy5hdHRyaWJ1dGVzLnBvaW50ZXJFdmVudHM7aWYoRD09PSJub25lInx8RCE9PSJhbGwiJiYhdGhpcy5pc1Zpc2libGUpcmV0dXJuITE7bGV0IFI9ImJvdGgiO3JldHVybiBEPT09InZpc2libGVGaWxsIiYmKFI9ImZpbGwiKSxEPT09InZpc2libGVTdHJva2UiJiYoUj0ic3Ryb2tlIiksdGhpcy5tZXNoLmlzUG9pbnRDb2xsaXNpb24oQSxMLFIpfW9uUHJvcGVydHlDaGFuZ2UoQSxMLEQpe0EhPT0iaWQiJiZBIT09Im5hbWUiJiZBIT09ImNsYXNzTmFtZSImJkEhPT0icG9pbnRlckV2ZW50cyImJkEhPT0icGFzc0V2ZW50cyImJnRoaXMuZm9yY2VVcGRhdGUoKSxBPT09ImZpbHRlciImJih0aGlzW2FdPU9iamVjdChsLnBhcnNlRmlsdGVyU3RyaW5nKShMKSksQT09PSJ6SW5kZXgiJiZ0aGlzLnBhcmVudCYmdGhpcy5wYXJlbnQucmVvcmRlcigpfXNldEF0dHJpYnV0ZShBLEwpe0E9PT0iYXR0cnMiJiZ0aGlzLmF0dHIoTCksdGhpcy5hdHRyaWJ1dGVzW0FdPUx9c2V0TW91c2VDYXB0dXJlKCl7dGhpcy5sYXllciYmKHRoaXMubGF5ZXIuX19tb3VzZUNhcHR1cmVkVGFyZ2V0PXRoaXMpfXNldFByb2dyYW0oQSl7dGhpc1tvXT1BLHRoaXMuZm9yY2VVcGRhdGUoKX1zZXRTaGFkZXJBdHRyaWJ1dGUoQSxMKXt0aGlzW1RdPXRoaXNbVF18fHt9LHRoaXNbVF1bQV09TCx0aGlzLmZvcmNlVXBkYXRlKCl9c2V0VW5pZm9ybXMoQSl7dGhpc1tQXT10aGlzW1BdfHx7fSxPYmplY3QuYXNzaWduKHRoaXNbUF0sQSksdGhpcy5mb3JjZVVwZGF0ZSgpfXNldFJlc29sdXRpb24oe3dpZHRoOkEsaGVpZ2h0Okx9KXtjb25zdHt3aWR0aDpELGhlaWdodDpSfT10aGlzW09dOyhEIT09QXx8UiE9PUwpJiYodGhpc1tPXT17d2lkdGg6QSxoZWlnaHQ6TH0sdGhpcy5mb3JjZVVwZGF0ZSgpLHRoaXMuZGlzcGF0Y2hFdmVudCh7dHlwZToicmVzb2x1dGlvbmNoYW5nZSIsZGV0YWlsOnt3aWR0aDpBLGhlaWdodDpMfX0pKX1zaG93KCl7dGhpcy5hdHRyaWJ1dGVzLmRpc3BsYXk9PT0ibm9uZSImJih0aGlzLmF0dHJpYnV0ZXMuZGlzcGxheT10aGlzW2ldfHwiIil9aGlkZSgpe3RoaXMuYXR0cmlidXRlcy5kaXNwbGF5IT09Im5vbmUiJiYodGhpc1tpXT10aGlzLmF0dHJpYnV0ZXMuZGlzcGxheSx0aGlzLmF0dHJpYnV0ZXMuZGlzcGxheT0ibm9uZSIpfXJlbGVhc2VNb3VzZUNhcHR1cmUoKXt0aGlzLmxheWVyJiZ0aGlzLmxheWVyLl9fbW91c2VDYXB0dXJlZFRhcmdldD09PXRoaXMmJih0aGlzLmxheWVyLl9fbW91c2VDYXB0dXJlZFRhcmdldD1udWxsKX1yZW1vdmUoKXtyZXR1cm4gdGhpcy5wYXJlbnQmJnRoaXMucGFyZW50LnJlbW92ZUNoaWxkPyh0aGlzLnBhcmVudC5yZW1vdmVDaGlsZCh0aGlzKSwhMCk6ITF9cmVtb3ZlQWxsTGlzdGVuZXJzKEEsTD17fSl7dHlwZW9mIEw9PSJib29sZWFuIiYmKEw9e2NhcHR1cmU6TH0pO2NvbnN0IFI9TC5jYXB0dXJlP246cDtyZXR1cm4gdGhpc1tSXVtBXSYmKHRoaXNbUl1bQV09W10pLHRoaXN9cmVtb3ZlQXR0cmlidXRlKEEpe3RoaXMuc2V0QXR0cmlidXRlKEEsbnVsbCl9cmVtb3ZlRXZlbnRMaXN0ZW5lcihBLEwsRD17fSl7dHlwZW9mIEQ9PSJib29sZWFuIiYmKEQ9e2NhcHR1cmU6RH0pO2NvbnN0IFM9RC5jYXB0dXJlP246cDtpZih0aGlzW1NdW0FdKXtjb25zdCBCPXRoaXNbU11bQV07aWYoQilmb3IobGV0IHc9MDt3PEIubGVuZ3RoO3crKyl7Y29uc3R7bGlzdGVuZXI6SH09Qlt3XTtpZihIPT09TCl7dGhpc1tTXVtBXS5zcGxpY2UodywxKTticmVha319fXJldHVybiB0aGlzfXRyYW5zaXRpb24oQSxMPSJsaW5lYXIiKXtjb25zdCBEPXRoaXMsUj1TeW1ib2woImFuaW1hdGlvbiIpO0w9THx8ImxpbmVhciI7bGV0IFM9MDtyZXR1cm4gdHlwZW9mIEE9PSJvYmplY3QiJiYoUz1BLmRlbGF5fHwwLEE9QS5kdXJhdGlvbikse1tSXTpudWxsLGNhbmNlbChCPSExKXtjb25zdCB3PXRoaXNbUl07dyYmdy5jYW5jZWwoQil9LGVuZCgpe2NvbnN0IEI9dGhpc1tSXTtCJiYoQi5wbGF5U3RhdGU9PT0icnVubmluZyJ8fEIucGxheVN0YXRlPT09InBlbmRpbmciKSYmQi5maW5pc2goKX0scmV2ZXJzZSgpe2NvbnN0IEI9dGhpc1tSXTtpZihCKWlmKEIucGxheVN0YXRlPT09InJ1bm5pbmcifHxCLnBsYXlTdGF0ZT09PSJwZW5kaW5nIilCLnBsYXliYWNrUmF0ZT0tQi5wbGF5YmFja1JhdGU7ZWxzZXtjb25zdCB3PUIudGltaW5nLmRpcmVjdGlvbjtCLnRpbWluZy5kaXJlY3Rpb249dz09PSJyZXZlcnNlIj8ibm9ybWFsIjoicmV2ZXJzZSIsQi5wbGF5KCl9cmV0dXJuIEIuZmluaXNoZWR9LGF0dHIoQix3KXtyZXR1cm4gdGhpcy5lbmQoKSx0eXBlb2YgQj09InN0cmluZyImJihCPXtbQl06d30pLE9iamVjdC5lbnRyaWVzKEIpLmZvckVhY2goKFtILEpdKT0+e3R5cGVvZiBKPT0iZnVuY3Rpb24iJiYoQltIXT1KKEQuYXR0cihIKSkpfSksdGhpc1tSXT1ELmFuaW1hdGUoW0JdLHtkdXJhdGlvbjpBKjFlMyxkZWxheTpTKjFlMyxmaWxsOiJmb3J3YXJkcyIsZWFzaW5nOkx9KSx0aGlzW1JdLmZpbmlzaGVkfX19dXBkYXRlQ29udG91cnMoKXt9fXkoQywiQXR0ciIscy5kZWZhdWx0KSx2LmRlZmF1bHQucmVnaXN0ZXJOb2RlKEMsIm5vZGUiKX0sZnVuY3Rpb24oYyxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gQ30pO3ZhciByPXQoMSkscz10KDEyKSxnPXQoNzIpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCB2PVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZURlZmF1bHQiKSxoPVN5bWJvbC5mb3IoInNwcml0ZWpzX2RlY2xhcmVBbGlhcyIpLGw9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlIiksdT1TeW1ib2wuZm9yKCJzcHJpdGVqc19nZXRBdHRyaWJ1dGUiKSxNPVN5bWJvbC5mb3IoInNwcml0ZWpzX2F0dHJpYnV0ZXMiKSxmPVN5bWJvbC5mb3IoInNwcml0ZWpzX2NoYW5nZWRBdHRycyIpLHk9U3ltYm9sKCJzdWJqZWN0IikseD1TeW1ib2woImF0dHIiKSxiPVN5bWJvbCgiZGVmYXVsdCIpLE89U3ltYm9sKCJhbGlhcyIpO2Z1bmN0aW9uIG0oSSxbQSxMXSl7bGV0IEQ9ci5tYXQyZC5mcm9tVmFsdWVzKDEsMCwwLDEsMCwwKTtyZXR1cm5bLi4uSV0uZm9yRWFjaCgoW1IsU10pPT57aWYoKEF8fEwpJiYoRD1yLm1hdDJkLnRyYW5zbGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCksRCxbQSxMXSkpLFI9PT0ibWF0cml4IilEPXIubWF0MmQubXVsdGlwbHkoRCxELFMpO2Vsc2UgaWYoUj09PSJvZmZzZXRUcmFuc2xhdGUiKURbNF0rPVNbMF0sRFs1XSs9U1sxXTtlbHNlIGlmKFI9PT0ib2Zmc2V0Um90YXRlIilEPXIubWF0MmQucm90YXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxELFMpO2Vsc2UgaWYoUj09PSJza2V3Iil7Y29uc3RbQix3XT1TO0Q9ci5tYXQyZC5tdWx0aXBseShELEQsci5tYXQyZC5mcm9tVmFsdWVzKDEsTWF0aC50YW4odyksTWF0aC50YW4oQiksMSwwLDApKX1lbHNlIHIubWF0MmRbUl0oRCxELFMpOyhBfHxMKSYmKEQ9ci5tYXQyZC50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDApLEQsWy1BLC1MXSkpfSksRH1jb25zdCBwPVN5bWJvbCgidHJhbnNmb3JtTWF0cml4Iiksbj1TeW1ib2woInRyYW5zZm9ybXMiKSxhPVN5bWJvbCgiY2hhbmdlZEF0dHJzIiksaT1TeW1ib2woImxhc3RDaGFuZ2VkQXR0ciIpLG89U3ltYm9sKCJvZmZzZXRGaWd1cmUiKTtmdW5jdGlvbiBUKEksQSxMKXtjb25zdCBEPUlbeF1bQV07aWYoSVtsXShBLEwsITEpfHxJW2ldIT09QSl7Y29uc3QgUz1JW25dO1MuaGFzKEEpJiZTLmRlbGV0ZShBKSxMJiYoQT09PSJyb3RhdGUiJiYoTD1NYXRoLlBJKkwvMTgwKSxBPT09InNjYWxlIiYmKEw9TC5tYXAoQj0+TWF0aC5hYnMoQik+MWUtNT9COjEvQj4wPzFlLTU6LTFlLTUpKSxTLnNldChBLEwpKSxJW3BdPW51bGwsSVt5XS5vblByb3BlcnR5Q2hhbmdlKEEsTCxELEkpfX1mdW5jdGlvbiBQKEkpe2NvbnN0IEE9SVtvXSxMPUkub2Zmc2V0RGlzdGFuY2UqQS5nZXRUb3RhbExlbmd0aCgpLEQ9QS5nZXRQb2ludEF0TGVuZ3RoKEwpO2lmKEQpe2NvbnN0IFI9SVtuXTtsZXQgUz1JLm9mZnNldFJvdGF0ZTtTPT09ImF1dG8iP1M9RC5hbmdsZTpTPT09InJldmVyc2UiP1M9TWF0aC5QSStELmFuZ2xlOlM9TWF0aC5QSSpTLzE4MCxSLnNldCgib2Zmc2V0Um90YXRlIixTKSxSLnNldCgib2Zmc2V0VHJhbnNsYXRlIixbRC54LEQueV0pLElbcF09bnVsbH19Y2xhc3MgQ3tzdGF0aWMgc2V0RGVmYXVsdChBLC4uLkwpe3JldHVybiBBW3ZdKC4uLkwpfXN0YXRpYyBkZWNsYXJlQWxpYXMoQSwuLi5MKXtyZXR1cm4gQVtoXSguLi5MKX1zdGF0aWMgc2V0QXR0cmlidXRlKEEsLi4uTCl7cmV0dXJuIEFbbF0oLi4uTCl9c3RhdGljIGdldEF0dHJpYnV0ZShBLC4uLkwpe3JldHVybiBBW3VdKC4uLkwpfXN0YXRpYyBnZXRBdHRyaWJ1dGVzKEEpe3JldHVybiBBW01dfXN0YXRpYyBnZXRDaGFuZ2VkQXR0cmlidXRlcyhBKXtyZXR1cm4gQVtmXX1jb25zdHJ1Y3RvcihBKXt0aGlzW3ldPUEsdGhpc1t4XT17fSx0aGlzW3BdPXIubWF0MmQuZnJvbVZhbHVlcygxLDAsMCwxLDAsMCksdGhpc1tuXT1uZXcgTWFwLHRoaXNbYl09e30sdGhpc1tPXT1bXSxPYmplY3QuZGVmaW5lUHJvcGVydHkoQSwidHJhbnNmb3JtTWF0cml4Iix7Z2V0OigpPT4odGhpc1twXXx8KHRoaXNbcF09bSh0aGlzW25dLHRoaXMudHJhbnNmb3JtT3JpZ2luKSksWy4uLnRoaXNbcF1dKX0pLHRoaXNbdl0oe2lkOiIiLG5hbWU6IiIsY2xhc3NOYW1lOiIiLHg6MCx5OjAsdHJhbnNmb3JtT3JpZ2luOlswLDBdLHRyYW5zZm9ybToiIix0cmFuc2xhdGU6WzAsMF0scm90YXRlOjAsc2NhbGU6WzEsMV0sc2tldzpbMCwwXSxvcGFjaXR5OjEsekluZGV4OjAsb2Zmc2V0UGF0aDp2b2lkIDAsb2Zmc2V0RGlzdGFuY2U6MCxvZmZzZXRSb3RhdGU6ImF1dG8iLHBvaW50ZXJFdmVudHM6InZpc2libGUiLGZpbHRlcjoibm9uZSIsZGlzcGxheToiIn0pLHRoaXNbaF0oImNsYXNzIiwicG9zIiksdGhpc1thXT1uZXcgU2V0LHRoaXNbb109bmV3IHMuRmlndXJlMkQoe3NjYWxlOjUsc2ltcGxpZnk6MH0pfWdldFtmXSgpe2NvbnN0IEE9e307cmV0dXJuWy4uLnRoaXNbYV1dLmZvckVhY2goTD0+e0FbTF09dGhpc1t4XVtMXX0pLEF9Z2V0W01dKCl7Y29uc3QgQT1PYmplY3QuYXNzaWduKHt9LHRoaXNbeF0pO2ZvcihsZXQgTD0wO0w8dGhpc1tPXS5sZW5ndGg7TCsrKXtjb25zdCBEPXRoaXNbT11bTF07QVtEXT10aGlzW0RdfXJldHVybiBBfVt2XShBKXtPYmplY3QuYXNzaWduKHRoaXNbYl0sQSksT2JqZWN0LmFzc2lnbih0aGlzW3hdLEEpfVtoXSguLi5BKXt0aGlzW09dLnB1c2goLi4uQSl9W2xdKEEsTCxEPSEwKXtjb25zdCBSPXRoaXNbeF1bQV0sUz10aGlzW3ldO3JldHVybiBMPT1udWxsJiYoTD10aGlzW2JdW0FdKSxPYmplY3QoZy5jb21wYXJlVmFsdWUpKFIsTCk/ITE6KHRoaXNbeF1bQV09TCx0aGlzW2FdLmhhcyhBKSYmdGhpc1thXS5kZWxldGUoQSksdGhpc1thXS5hZGQoQSksdGhpc1tpXT1BLEQmJlMub25Qcm9wZXJ0eUNoYW5nZShBLEwsUix0aGlzKSwhMCl9W3VdKEEpe3JldHVybiB0aGlzW3hdW0FdfXNldCBpZChBKXt0aGlzW2xdKCJpZCIsQSl9Z2V0IGlkKCl7cmV0dXJuIHRoaXNbdV0oImlkIil9c2V0IG5hbWUoQSl7dGhpc1tsXSgibmFtZSIsQSl9Z2V0IG5hbWUoKXtyZXR1cm4gdGhpc1t1XSgibmFtZSIpfXNldCBjbGFzc05hbWUoQSl7dGhpc1tsXSgiY2xhc3NOYW1lIixBKX1nZXQgY2xhc3NOYW1lKCl7cmV0dXJuIHRoaXNbdV0oImNsYXNzTmFtZSIpfXNldCBjbGFzcyhBKXt0aGlzLmNsYXNzTmFtZT1BfWdldCBjbGFzcygpe3JldHVybiB0aGlzLmNsYXNzTmFtZX1nZXQgeCgpe3JldHVybiB0aGlzW3VdKCJ4Iil9c2V0IHgoQSl7dGhpc1tsXSgieCIsT2JqZWN0KGcudG9OdW1iZXIpKEEpKX1nZXQgeSgpe3JldHVybiB0aGlzW3VdKCJ5Iil9c2V0IHkoQSl7dGhpc1tsXSgieSIsT2JqZWN0KGcudG9OdW1iZXIpKEEpKX1nZXQgcG9zKCl7cmV0dXJuW3RoaXMueCx0aGlzLnldfXNldCBwb3MoQSl7QT1PYmplY3QoZy50b0FycmF5KShBKSxBcnJheS5pc0FycmF5KEEpfHwoQT1bQSxBXSksdGhpcy54PUFbMF0sdGhpcy55PUFbMV19Z2V0IHRyYW5zZm9ybSgpe3JldHVybiB0aGlzW3VdKCJ0cmFuc2Zvcm0iKX1zZXQgdHJhbnNmb3JtKEEpe2xldCBMPW51bGw7aWYoQXJyYXkuaXNBcnJheShBKSYmKEw9QSxBPWBtYXRyaXgoJHtBLm1hcChnLnRvTnVtYmVyKS5qb2luKCl9KWApLHR5cGVvZiBBPT0ic3RyaW5nIilBPUEucmVwbGFjZSgvXHMqLFxzKi9nLCIsIik7ZWxzZSBpZihBIT1udWxsKXRocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgdHJhbnNmb3JtIHZhbHVlLiIpO2NvbnN0IEQ9dGhpc1t4XS50cmFuc2Zvcm07aWYodGhpc1tsXSgidHJhbnNmb3JtIixBLCExKSl7Y29uc3QgUj10aGlzW25dO2lmKFIuaGFzKCJtYXRyaXgiKSYmUi5kZWxldGUoIm1hdHJpeCIpLEwpUi5zZXQoIm1hdHJpeCIsTCk7ZWxzZSBpZihBKXtjb25zdCBTPUEubWF0Y2goLyhtYXRyaXh8dHJhbnNsYXRlfHJvdGF0ZXxzY2FsZXxza2V3KVwoW14oKV0rXCkvZyk7aWYoUyl7bGV0IEI9ci5tYXQyZC5mcm9tVmFsdWVzKDEsMCwwLDEsMCwwKTtmb3IobGV0IHc9MDt3PFMubGVuZ3RoO3crKyl7Y29uc3QgSj1TW3ddLm1hdGNoKC9eKG1hdHJpeHx0cmFuc2xhdGV8cm90YXRlfHNjYWxlfHNrZXcpXCgoW14oKV0rKVwpLyk7aWYoSil7bGV0WyxxLFddPUo7cT09PSJyb3RhdGUiP1c9TWF0aC5QSSpwYXJzZUZsb2F0KFcpLzE4MDpXPVcudHJpbSgpLnNwbGl0KC9bXHMsXSsvKS5tYXAoRz0+T2JqZWN0KGcudG9OdW1iZXIpKEcpKSxxPT09Im1hdHJpeCI/Qj1yLm1hdDJkLm11bHRpcGx5KEIsQixXKTpxPT09InNrZXciP0I9ci5tYXQyZC5tdWx0aXBseShCLEIsci5tYXQyZC5mcm9tVmFsdWVzKDEsTWF0aC50YW4oV1sxXSksTWF0aC50YW4oV1swXSksMSwwLDApKTpyLm1hdDJkW3FdKEIsQixXKSxSLnNldCgibWF0cml4IixCKX19fWVsc2UgdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCB0cmFuc2Zvcm0gdmFsdWUuIil9dGhpc1twXT1udWxsLHRoaXNbeV0ub25Qcm9wZXJ0eUNoYW5nZSgidHJhbnNmb3JtIixBLEQsdGhpcyl9fWdldCB0cmFuc2Zvcm1PcmlnaW4oKXtyZXR1cm4gdGhpc1t1XSgidHJhbnNmb3JtT3JpZ2luIil9c2V0IHRyYW5zZm9ybU9yaWdpbihBKXtBPU9iamVjdChnLnRvQXJyYXkpKEEsITApLEEhPW51bGwmJiFBcnJheS5pc0FycmF5KEEpJiYoQT1bQSxBXSksdGhpc1tsXSgidHJhbnNmb3JtT3JpZ2luIixBKSYmKHRoaXNbcF09bnVsbCl9Z2V0IHJvdGF0ZSgpe3JldHVybiB0aGlzW3VdKCJyb3RhdGUiKX1zZXQgcm90YXRlKEEpe1QodGhpcywicm90YXRlIixBKX1nZXQgdHJhbnNsYXRlKCl7cmV0dXJuIHRoaXNbdV0oInRyYW5zbGF0ZSIpfXNldCB0cmFuc2xhdGUoQSl7QT1PYmplY3QoZy50b0FycmF5KShBLCEwKSxBIT1udWxsJiYhQXJyYXkuaXNBcnJheShBKSYmKEE9W0EsQV0pLFQodGhpcywidHJhbnNsYXRlIixBKX1nZXQgc2NhbGUoKXtyZXR1cm4gdGhpc1t1XSgic2NhbGUiKX1zZXQgc2NhbGUoQSl7QT1PYmplY3QoZy50b0FycmF5KShBLCEwKSxBIT1udWxsJiYhQXJyYXkuaXNBcnJheShBKSYmKEE9W0EsQV0pLFQodGhpcywic2NhbGUiLEEpfWdldCBza2V3KCl7cmV0dXJuIHRoaXNbdV0oInNrZXciKX1zZXQgc2tldyhBKXtBPU9iamVjdChnLnRvQXJyYXkpKEEsITApLEEhPW51bGwmJiFBcnJheS5pc0FycmF5KEEpJiYoQT1bQSxBXSksVCh0aGlzLCJza2V3IixBKX1nZXQgb3BhY2l0eSgpe3JldHVybiB0aGlzW3VdKCJvcGFjaXR5Iil9c2V0IG9wYWNpdHkoQSl7QSE9bnVsbCYmKEE9TnVtYmVyKEEpKSx0aGlzW2xdKCJvcGFjaXR5IixBKX1nZXQgekluZGV4KCl7cmV0dXJuIHRoaXNbdV0oInpJbmRleCIpfXNldCB6SW5kZXgoQSl7QSE9bnVsbCYmKEE9TnVtYmVyKEEpKSx0aGlzW2xdKCJ6SW5kZXgiLEEpfWdldCBvZmZzZXRQYXRoKCl7cmV0dXJuIHRoaXNbdV0oIm9mZnNldFBhdGgiKX1zZXQgb2Zmc2V0UGF0aChBKXt0aGlzW2xdKCJvZmZzZXRQYXRoIixBKSYmKHRoaXNbb10uYmVnaW5QYXRoKCksQSE9bnVsbCYmdGhpc1tvXS5hZGRQYXRoKEEpLFAodGhpcykpfWdldCBvZmZzZXREaXN0YW5jZSgpe3JldHVybiB0aGlzW3VdKCJvZmZzZXREaXN0YW5jZSIpfXNldCBvZmZzZXREaXN0YW5jZShBKXt0aGlzW2xdKCJvZmZzZXREaXN0YW5jZSIsT2JqZWN0KGcudG9OdW1iZXIpKEEpKSYmUCh0aGlzKX1nZXQgb2Zmc2V0Um90YXRlKCl7cmV0dXJuIHRoaXNbdV0oIm9mZnNldFJvdGF0ZSIpfXNldCBvZmZzZXRSb3RhdGUoQSl7dGhpc1tsXSgib2Zmc2V0Um90YXRlIixBKSxQKHRoaXMpfWdldCBwb2ludGVyRXZlbnRzKCl7cmV0dXJuIHRoaXNbdV0oInBvaW50ZXJFdmVudHMiKX1zZXQgcG9pbnRlckV2ZW50cyhBKXtpZihBIT1udWxsJiZBIT09Im5vbmUiJiZBIT09InZpc2libGUiJiZBIT09InZpc2libGVGaWxsIiYmQSE9PSJ2aXNpYmxlU3Ryb2tlIiYmQSE9PSJhbGwiKXRocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgcG9pbnRlckV2ZW50cyB0eXBlLiIpO3RoaXNbbF0oInBvaW50ZXJFdmVudHMiLEEpfWdldCBmaWx0ZXIoKXtyZXR1cm4gdGhpc1t1XSgiZmlsdGVyIil9c2V0IGZpbHRlcihBKXt0aGlzW2xdKCJmaWx0ZXIiLEEpfWdldCBkaXNwbGF5KCl7cmV0dXJuIHRoaXNbdV0oImRpc3BsYXkiKX1zZXQgZGlzcGxheShBKXt0aGlzW2xdKCJkaXNwbGF5IixBKX1zZXQgb2Zmc2V0KEEpe319fSxmdW5jdGlvbihjLGUsdCl7dC5yKGUpLHQuZChlLCJzaXplVG9QaXhlbCIsZnVuY3Rpb24oKXtyZXR1cm4gcn0pLHQuZChlLCJ0b1N0cmluZyIsZnVuY3Rpb24oKXtyZXR1cm4gc30pLHQuZChlLCJ0b051bWJlciIsZnVuY3Rpb24oKXtyZXR1cm4gZ30pLHQuZChlLCJ0b0FycmF5IixmdW5jdGlvbigpe3JldHVybiB2fSksdC5kKGUsImNvbXBhcmVWYWx1ZSIsZnVuY3Rpb24oKXtyZXR1cm4gaH0pLHQoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiByKGwsdSl7Y29uc3QgTT1sLnRyaW0oKS5tYXRjaCgvXihbXGQuXSspKHB4fHB0fHBjfGlufGNtfG1tfGVtfGV4fHJlbXxxfHZ3fHZofHZtYXh8dm1pbikkLyk7TT9sPXtzaXplOnBhcnNlRmxvYXQoTVsxXSksdW5pdDpNWzJdfTpsPXtzaXplOnBhcnNlRmxvYXQobCksdW5pdDoicHgifTtsZXR7c2l6ZTpmLHVuaXQ6eX09bDtpZih5PT09InB0IilmLz0uNzU7ZWxzZSBpZih5PT09InBjIilmKj0xNjtlbHNlIGlmKHk9PT0iaW4iKWYqPTk2O2Vsc2UgaWYoeT09PSJjbSIpZio9OTYvMi41NDtlbHNlIGlmKHk9PT0ibW0iKWYqPTk2LzI1LjQ7ZWxzZSBpZih5PT09ImVtInx8eT09PSJyZW0ifHx5PT09ImV4Iil7aWYoIXUmJnR5cGVvZiBnZXRDb21wdXRlZFN0eWxlPT0iZnVuY3Rpb24iJiZ0eXBlb2YgZG9jdW1lbnQ8InUiKXtjb25zdCB4PWdldENvbXB1dGVkU3R5bGUoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KS5mb250U2l6ZTt4P3U9cih4LDE2KTp1PTE2fWYqPXUseT09PSJleCImJihmLz0yKX1lbHNlIGlmKHk9PT0icSIpZio9OTYvMjUuNC80O2Vsc2UgaWYoeT09PSJ2dyJ8fHk9PT0idmgiKXtpZih0eXBlb2YgZG9jdW1lbnQ8InUiKXtjb25zdCB4PXk9PT0idnciP3dpbmRvdy5pbm5lcldpZHRofHxkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGg6d2luZG93LmlubmVySGVpZ2h0fHxkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0O2YqPXgvMTAwfX1lbHNlIGlmKCh5PT09InZtYXgifHx5PT09InZtaW4iKSYmdHlwZW9mIGRvY3VtZW50PCJ1Iil7Y29uc3QgeD13aW5kb3cuaW5uZXJXaWR0aHx8ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoLGI9d2luZG93LmlubmVySGVpZ2h0fHxkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0O3k9PT0idm1heCI/Zio9TWF0aC5tYXgoeCxiKS8xMDA6Zio9TWF0aC5taW4oeCxiKS8xMDB9cmV0dXJuIGZ9ZnVuY3Rpb24gcyhsKXtyZXR1cm4gbD09bnVsbD9sOlN0cmluZyhsKX1mdW5jdGlvbiBnKGwpe2lmKGw9PW51bGwpcmV0dXJuIGw7aWYodHlwZW9mIGw9PSJzdHJpbmciJiYobD1yKGwpKSwhTnVtYmVyLmlzRmluaXRlKGwpKXRocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgdmFsdWUiKTtyZXR1cm4gbH1mdW5jdGlvbiB2KGwsdT0hMSl7cmV0dXJuIGw9PT0iIj9udWxsOih0eXBlb2YgbD09InN0cmluZyImJihsPWwuc3BsaXQoL1tccyxdKy9nKSksQXJyYXkuaXNBcnJheShsKSYmKHUmJihsPWwubWFwKGcpKSxsLmxlbmd0aD09PTEpP2xbMF06bCl9ZnVuY3Rpb24gaChsLHUpe2lmKEFycmF5LmlzQXJyYXkobCkmJkFycmF5LmlzQXJyYXkodSkpe2lmKGwubGVuZ3RoIT09dS5sZW5ndGgpcmV0dXJuITE7Zm9yKGxldCBNPTA7TTxsLmxlbmd0aDtNKyspaWYobFtNXSE9PXVbTV0pcmV0dXJuITE7cmV0dXJuITB9cmV0dXJuIGw9PW51bGwmJnU9PW51bGx8fGw9PT11fX0sZnVuY3Rpb24oYyxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4geX0pO3ZhciByPXQoNzQpLHM9dCgzMiksZz10Lm4ocyksdj10KDY4KSxoPXQoNzIpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBsKCl7cmV0dXJuIGw9T2JqZWN0LmFzc2lnbnx8ZnVuY3Rpb24oeCl7Zm9yKHZhciBiPTE7Yjxhcmd1bWVudHMubGVuZ3RoO2IrKyl7dmFyIE89YXJndW1lbnRzW2JdO2Zvcih2YXIgbSBpbiBPKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChPLG0pJiYoeFttXT1PW21dKX1yZXR1cm4geH0sbC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9ZnVuY3Rpb24gdSh4KXtpZih0eXBlb2YgeD09InN0cmluZyIpe2lmKHg9eC50cmltKCksL15bMC05Ll0rJSQvLnRlc3QoeCkpcmV0dXJuIHBhcnNlRmxvYXQoeCkvMTAwO2lmKC9eKFtcZC5dKykocHh8cHR8cGN8aW58Y218bW18ZW18ZXh8cmVtfHF8dnd8dmh8dm1heHx2bWluKSQvLnRlc3QoeCkpcmV0dXJuIE9iamVjdChoLnNpemVUb1BpeGVsKSh4KX1yZXR1cm4geH1mdW5jdGlvbiBNKHgsYixPLG0scCl7cmV0dXJuIHR5cGVvZiB4PT0ic3RyaW5nIiYmKHg9ZygpKHgpKSx0eXBlb2YgYj09InN0cmluZyImJihiPWcoKShiKSksci5FZmZlY3RzLmRlZmF1bHQoeCxiLE8sbSxwKX1mdW5jdGlvbiBmKHgsYixPLG0scCl7cmV0dXJuIHIuRWZmZWN0cy5kZWZhdWx0KHgsYixPLG0scCl9ci5FZmZlY3RzLmRlZmF1bHQ9ZnVuY3Rpb24oeCxiLE8sbSxwKXtyZXR1cm4gQXJyYXkuaXNBcnJheSh4KSYmQXJyYXkuaXNBcnJheShiKT94Lm1hcCgobixhKT0+bisoTy1tKS8ocC1tKSooYlthXS1uKSk6dHlwZW9mIHg9PSJudW1iZXIiJiZ0eXBlb2YgYj09Im51bWJlciI/eCsoTy1tKS8ocC1tKSooYi14KTpPLW0+cC1PP2I6eH0sci5FZmZlY3RzLmZpbGxDb2xvcj1NLHIuRWZmZWN0cy5zdHJva2VDb2xvcj1NLHIuRWZmZWN0cy5iZ2NvbG9yPU0sci5FZmZlY3RzLmJvcmRlckNvbG9yPU0sci5FZmZlY3RzLnRleHQ9ZjtjbGFzcyB5IGV4dGVuZHMgci5BbmltYXRvcntjb25zdHJ1Y3RvcihiLE8sbSl7Y29uc3QgcD1iLmF0dHIoKTtPYmplY3QuZW50cmllcyhwKS5mb3JFYWNoKChbbixhXSk9PntwW25dPXIuRWZmZWN0c1tuXT9hOnUoYSl9KSxPPU8ubWFwKG49PntsZXQgYT1sKHt9LG4pO2NvbnN0IGk9e307cmV0dXJuIE9iamVjdC5lbnRyaWVzKGEpLmZvckVhY2goKFtvLFRdKT0+e2lbb109ci5FZmZlY3RzW29dP1Q6dShUKX0pLGl9KSxzdXBlcihwLE8sbSksdGhpcy50YXJnZXQ9Yix0aGlzLnNldHRlcj1mdW5jdGlvbihuLGEpe2EuYXR0cihuKX19Z2V0IHBsYXlTdGF0ZSgpe3JldHVybiB0aGlzLnRhcmdldC5wYXJlbnQ/c3VwZXIucGxheVN0YXRlOiJpZGxlIn1nZXQgZmluaXNoZWQoKXtyZXR1cm4gc3VwZXIuZmluaXNoZWQudGhlbigoKT0+e2NvbnN0IGI9dGhpcztyZXR1cm4gbmV3IFByb21pc2UoTz0+e2Z1bmN0aW9uIG0oKXtiLnNldHRlcihiLmZyYW1lLGIudGFyZ2V0KTtjb25zdCBwPWIucGxheVN0YXRlO3A9PT0iZmluaXNoZWQifHxwPT09ImlkbGUiPyhPYmplY3Qodi5jYW5jZWxBbmltYXRpb25GcmFtZSkoYi5yZXF1ZXN0SWQpLE8oKSk6T2JqZWN0KHYucmVxdWVzdEFuaW1hdGlvbkZyYW1lKShtKX1tKCl9KX0pfWZpbmlzaCgpe3N1cGVyLmZpbmlzaCgpLE9iamVjdCh2LmNhbmNlbEFuaW1hdGlvbkZyYW1lKSh0aGlzLnJlcXVlc3RJZCksdGhpcy5zZXR0ZXIodGhpcy5mcmFtZSx0aGlzLnRhcmdldCl9cGxheSgpe2lmKCF0aGlzLnRhcmdldC5wYXJlbnR8fHRoaXMucGxheVN0YXRlPT09InJ1bm5pbmciKXJldHVybjtzdXBlci5wbGF5KCksdGhpcy5zZXR0ZXIodGhpcy5mcmFtZSx0aGlzLnRhcmdldCk7Y29uc3QgYj10aGlzO3RoaXMucmVhZHkudGhlbigoKT0+e2Iuc2V0dGVyKGIuZnJhbWUsYi50YXJnZXQpLGIucmVxdWVzdElkPU9iamVjdCh2LnJlcXVlc3RBbmltYXRpb25GcmFtZSkoZnVuY3Rpb24gTygpe2NvbnN0IG09Yi50YXJnZXQ7aWYodHlwZW9mIGRvY3VtZW50PCJ1IiYmZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50JiZkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY29udGFpbnMmJm0ubGF5ZXImJm0ubGF5ZXIuY2FudmFzJiYhZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNvbnRhaW5zKG0ubGF5ZXIuY2FudmFzKSl7Yi5jYW5jZWwoKTtyZXR1cm59Y29uc3QgcD1iLnBsYXlTdGF0ZTtiLnNldHRlcihiLmZyYW1lLGIudGFyZ2V0KSxwIT09ImlkbGUiJiYocD09PSJydW5uaW5nIj9iLnJlcXVlc3RJZD1PYmplY3Qodi5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpKE8pOihwPT09InBhdXNlZCJ8fHA9PT0icGVuZGluZyImJmIudGltZWxpbmUuY3VycmVudFRpbWU8MCkmJmIucmVhZHkudGhlbigoKT0+e2Iuc2V0dGVyKGIuZnJhbWUsYi50YXJnZXQpLGIucmVxdWVzdElkPU9iamVjdCh2LnJlcXVlc3RBbmltYXRpb25GcmFtZSkoTyl9KSl9KX0pfWNhbmNlbChiPSExKXtPYmplY3Qodi5jYW5jZWxBbmltYXRpb25GcmFtZSkodGhpcy5yZXF1ZXN0SWQpLGI/KHRoaXMuc2V0dGVyKHRoaXMuZnJhbWUsdGhpcy50YXJnZXQpLHN1cGVyLmNhbmNlbCgpKTooc3VwZXIuY2FuY2VsKCksdGhpcy5zZXR0ZXIodGhpcy5mcmFtZSx0aGlzLnRhcmdldCkpfX19LGZ1bmN0aW9uKGMsZSx0KXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksZS5UaW1lbGluZT1lLkVmZmVjdHM9ZS5FYXNpbmdzPWUuQW5pbWF0b3I9dm9pZCAwO3ZhciByPXQoNzUpLHM9TShyKSxnPXQoMTg3KSx2PU0oZyksaD10KDE4OCksbD10KDE5MCksdT1NKGwpO2Z1bmN0aW9uIE0oZil7cmV0dXJuIGYmJmYuX19lc01vZHVsZT9mOntkZWZhdWx0OmZ9fWUuQW5pbWF0b3I9dS5kZWZhdWx0LGUuRWFzaW5ncz1oLkVhc2luZ3MsZS5FZmZlY3RzPXYuZGVmYXVsdCxlLlRpbWVsaW5lPXMuZGVmYXVsdH0sZnVuY3Rpb24oYyxlLHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KTt2YXIgcj10KDc2KSxzPW4ociksZz10KDEzMyksdj1uKGcpLGg9dCgxNDEpLGw9bihoKSx1PXQoMTY0KSxNPW4odSksZj10KDE3MCkseT1uKGYpLHg9dCgxNzEpLGI9bih4KSxPPXQoMTc1KSxtPW4oTykscD10KDE4Nik7ZnVuY3Rpb24gbihEKXtyZXR1cm4gRCYmRC5fX2VzTW9kdWxlP0Q6e2RlZmF1bHQ6RH19dmFyIGE9KDAscC5jcmVhdGVOb3dUaW1lKSgpLGk9e29yaWdpblRpbWU6MCxwbGF5YmFja1JhdGU6MX0sbz0oMCxtLmRlZmF1bHQpKCJ0aW1lTWFyayIpLFQ9KDAsbS5kZWZhdWx0KSgicGxheWJhY2tSYXRlIiksUD0oMCxtLmRlZmF1bHQpKCJ0aW1lcnMiKSxDPSgwLG0uZGVmYXVsdCkoIm9yaWdpblRpbWUiKSxJPSgwLG0uZGVmYXVsdCkoInNldFRpbWVyIiksQT0oMCxtLmRlZmF1bHQpKCJwYXJlbnQiKSxMPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gRChSLFMpeygwLHkuZGVmYXVsdCkodGhpcyxEKSxSIGluc3RhbmNlb2YgRCYmKFM9UixSPXt9KSxSPSgwLE0uZGVmYXVsdCkoe30saSxSKSxTJiYodGhpc1tBXT1TKTt2YXIgQj1SLm5vd3RpbWV8fGE7aWYoUylPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiZ2xvYmFsVGltZSIse2dldDpmdW5jdGlvbigpe3JldHVybiBTLmN1cnJlbnRUaW1lfX0pO2Vsc2V7dmFyIHc9QigpO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJnbG9iYWxUaW1lIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIEIoKS13fX0pfXRoaXNbb109W3tnbG9iYWxUaW1lOnRoaXMuZ2xvYmFsVGltZSxsb2NhbFRpbWU6LVIub3JpZ2luVGltZSxlbnRyb3B5Oi1SLm9yaWdpblRpbWUscGxheWJhY2tSYXRlOlIucGxheWJhY2tSYXRlLGdsb2JhbEVudHJvcHk6MH1dLHRoaXNbQV0mJih0aGlzW29dWzBdLmdsb2JhbEVudHJvcHk9dGhpc1tBXS5lbnRyb3B5KSx0aGlzW0NdPVIub3JpZ2luVGltZSx0aGlzW1RdPVIucGxheWJhY2tSYXRlLHRoaXNbUF09bmV3IGwuZGVmYXVsdH1yZXR1cm4oMCxiLmRlZmF1bHQpKEQsW3trZXk6Im1hcmtUaW1lIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBTPWFyZ3VtZW50cy5sZW5ndGg+MCYmYXJndW1lbnRzWzBdIT09dm9pZCAwP2FyZ3VtZW50c1swXTp7fSxCPVMudGltZSx3PUI9PT12b2lkIDA/dGhpcy5jdXJyZW50VGltZTpCLEg9Uy5lbnRyb3B5LEo9SD09PXZvaWQgMD90aGlzLmVudHJvcHk6SCxxPVMucGxheWJhY2tSYXRlLFc9cT09PXZvaWQgMD90aGlzLnBsYXliYWNrUmF0ZTpxLEc9e2dsb2JhbFRpbWU6dGhpcy5nbG9iYWxUaW1lLGxvY2FsVGltZTp3LGVudHJvcHk6SixwbGF5YmFja1JhdGU6VyxnbG9iYWxFbnRyb3B5OnRoaXMuZ2xvYmFsRW50cm9weX07dGhpc1tvXS5wdXNoKEcpfX0se2tleToiZm9yayIsdmFsdWU6ZnVuY3Rpb24oUyl7cmV0dXJuIG5ldyBEKFMsdGhpcyl9fSx7a2V5OiJzZWVrR2xvYmFsVGltZSIsdmFsdWU6ZnVuY3Rpb24oUyl7dmFyIEI9dGhpcy5zZWVrVGltZU1hcmsoUyksdz10aGlzW29dW0JdLEg9dy5lbnRyb3B5LEo9dy5wbGF5YmFja1JhdGUscT13Lmdsb2JhbFRpbWU7cmV0dXJuIHErKFMtSCkvTWF0aC5hYnMoSil9fSx7a2V5OiJzZWVrTG9jYWxUaW1lIix2YWx1ZTpmdW5jdGlvbihTKXt2YXIgQj10aGlzLnNlZWtUaW1lTWFyayhTKSx3PXRoaXNbb11bQl0sSD13LmxvY2FsVGltZSxKPXcuZW50cm9weSxxPXcucGxheWJhY2tSYXRlO3JldHVybiBxPjA/SCsoUy1KKTpILShTLUopfX0se2tleToic2Vla1RpbWVNYXJrIix2YWx1ZTpmdW5jdGlvbihTKXt2YXIgQj10aGlzW29dLHc9MCxIPUIubGVuZ3RoLTE7aWYoUzw9Qlt3XS5lbnRyb3B5KXJldHVybiB3O2lmKFM+PUJbSF0uZW50cm9weSlyZXR1cm4gSDtmb3IodmFyIEo9TWF0aC5mbG9vcigodytIKS8yKTtKPncmJko8SDspe2lmKFM9PT1CW0pdLmVudHJvcHkpcmV0dXJuIEo7UzxCW0pdLmVudHJvcHk/SD1KOlM+QltKXS5lbnRyb3B5JiYodz1KKSxKPU1hdGguZmxvb3IoKHcrSCkvMil9cmV0dXJuIHd9fSx7a2V5OiJ1cGRhdGVUaW1lcnMiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIFM9dGhpcyxCPVtdLmNvbmNhdCgoMCx2LmRlZmF1bHQpKHRoaXNbUF0pKTtCLmZvckVhY2goZnVuY3Rpb24odyl7dmFyIEg9KDAscy5kZWZhdWx0KSh3LDIpLEo9SFswXSxxPUhbMV07U1tJXShxLmhhbmRsZXIscS50aW1lLEopfSl9fSx7a2V5OiJjbGVhclRpbWVvdXQiLHZhbHVlOmZ1bmN0aW9uKFIpe2Z1bmN0aW9uIFMoQil7cmV0dXJuIFIuYXBwbHkodGhpcyxhcmd1bWVudHMpfXJldHVybiBTLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIFIudG9TdHJpbmcoKX0sU30oZnVuY3Rpb24oUil7dmFyIFM9dGhpc1tQXS5nZXQoUik7UyYmUy50aW1lcklEIT1udWxsJiYodGhpc1tBXT90aGlzW0FdLmNsZWFyVGltZW91dChTLnRpbWVySUQpOmNsZWFyVGltZW91dChTLnRpbWVySUQpKSx0aGlzW1BdLmRlbGV0ZShSKX0pfSx7a2V5OiJjbGVhckludGVydmFsIix2YWx1ZTpmdW5jdGlvbihTKXtyZXR1cm4gdGhpcy5jbGVhclRpbWVvdXQoUyl9fSx7a2V5OiJjbGVhciIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgUz10aGlzLEI9dGhpc1tQXTtbXS5jb25jYXQoKDAsdi5kZWZhdWx0KShCLmtleXMoKSkpLmZvckVhY2goZnVuY3Rpb24odyl7Uy5jbGVhclRpbWVvdXQodyl9KX19LHtrZXk6InNldFRpbWVvdXQiLHZhbHVlOmZ1bmN0aW9uKFMpe3ZhciBCPWFyZ3VtZW50cy5sZW5ndGg+MSYmYXJndW1lbnRzWzFdIT09dm9pZCAwP2FyZ3VtZW50c1sxXTp7ZGVsYXk6MH07cmV0dXJuIHRoaXNbSV0oUyxCKX19LHtrZXk6InNldEludGVydmFsIix2YWx1ZTpmdW5jdGlvbihTKXt2YXIgQj1hcmd1bWVudHMubGVuZ3RoPjEmJmFyZ3VtZW50c1sxXSE9PXZvaWQgMD9hcmd1bWVudHNbMV06e2RlbGF5OjB9LHc9dGhpcyxIPXRoaXNbSV0oZnVuY3Rpb24gSigpe3dbSV0oSixCLEgpLFMoKX0sQik7cmV0dXJuIEh9fSx7a2V5OkksdmFsdWU6ZnVuY3Rpb24oUyxCKXt2YXIgdz10aGlzLEg9YXJndW1lbnRzLmxlbmd0aD4yJiZhcmd1bWVudHNbMl0hPT12b2lkIDA/YXJndW1lbnRzWzJdOigwLG0uZGVmYXVsdCkoInRpbWVySUQiKTtCPSgwLHAuZm9ybWF0RGVsYXkpKEIpO3ZhciBKPXRoaXNbUF0uZ2V0KEgpLHE9dm9pZCAwLFc9bnVsbCxHPXZvaWQgMCxRPXZvaWQgMDtKPyh0aGlzLmNsZWFyVGltZW91dChIKSxCLmlzRW50cm9weT9xPShCLmRlbGF5LSh0aGlzLmVudHJvcHktSi5zdGFydEVudHJvcHkpKS9NYXRoLmFicyh0aGlzLnBsYXliYWNrUmF0ZSk6cT0oQi5kZWxheS0odGhpcy5jdXJyZW50VGltZS1KLnN0YXJ0VGltZSkpL3RoaXMucGxheWJhY2tSYXRlLEc9Si5zdGFydFRpbWUsUT1KLnN0YXJ0RW50cm9weSk6KHE9Qi5kZWxheS8oQi5pc0VudHJvcHk/TWF0aC5hYnModGhpcy5wbGF5YmFja1JhdGUpOnRoaXMucGxheWJhY2tSYXRlKSxHPXRoaXMuY3VycmVudFRpbWUsUT10aGlzLmVudHJvcHkpO3ZhciB0dD10aGlzW0FdLF89dHQ/dHQuc2V0VGltZW91dC5iaW5kKHR0KTpzZXRUaW1lb3V0LHN0PUIuaGVhZGluZztyZXR1cm4hdHQmJnN0PT09ITEmJnE8MCYmKHE9MS8wKSwoaXNGaW5pdGUocSl8fHR0KSYmKHE9TWF0aC5jZWlsKHEpLF8hPT1zZXRUaW1lb3V0JiYocT17ZGVsYXk6cSxoZWFkaW5nOnN0fSksVz1fKGZ1bmN0aW9uKCl7d1tQXS5kZWxldGUoSCksUygpfSxxKSksdGhpc1tQXS5zZXQoSCx7dGltZXJJRDpXLGhhbmRsZXI6Uyx0aW1lOkIsc3RhcnRUaW1lOkcsc3RhcnRFbnRyb3B5OlF9KSxIfX0se2tleToicGFyZW50IixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc1tBXX19LHtrZXk6Imxhc3RUaW1lTWFyayIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXNbb11bdGhpc1tvXS5sZW5ndGgtMV19fSx7a2V5OiJjdXJyZW50VGltZSIsZ2V0OmZ1bmN0aW9uKCl7dmFyIFM9dGhpcy5sYXN0VGltZU1hcmssQj1TLmxvY2FsVGltZSx3PVMuZ2xvYmFsVGltZTtyZXR1cm4gQisodGhpcy5nbG9iYWxUaW1lLXcpKnRoaXMucGxheWJhY2tSYXRlfSxzZXQ6ZnVuY3Rpb24oUyl7dmFyIEI9dGhpcyx3PXRoaXMuY3VycmVudFRpbWUsSD1TLEo9dGhpc1tQXTt0aGlzLm1hcmtUaW1lKHt0aW1lOlN9KSxbXS5jb25jYXQoKDAsdi5kZWZhdWx0KShKKSkuZm9yRWFjaChmdW5jdGlvbihxKXt2YXIgVz0oMCxzLmRlZmF1bHQpKHEsMiksRz1XWzBdLFE9V1sxXTtpZihKLmhhcyhHKSl7dmFyIHR0PVEudGltZSxfPXR0LmlzRW50cm9weSxzdD10dC5kZWxheSxrPXR0LmhlYWRpbmcsY3Q9US5oYW5kbGVyLGZ0PVEuc3RhcnRUaW1lO2lmKF8pc3Q9PT0wJiYoY3QoKSxCLmNsZWFyVGltZW91dChHKSk7ZWxzZXt2YXIgVT1mdCtzdDsoc3Q9PT0wfHxrIT09ITEmJihILXcpKnN0PD0wfHx3PD1VJiZVPD1IfHx3Pj1VJiZVPj1IKSYmKGN0KCksQi5jbGVhclRpbWVvdXQoRykpfX19KSx0aGlzLnVwZGF0ZVRpbWVycygpfX0se2tleToiZW50cm9weSIsZ2V0OmZ1bmN0aW9uKCl7dmFyIFM9dGhpcy5sYXN0VGltZU1hcmssQj1TLmVudHJvcHksdz1TLmdsb2JhbEVudHJvcHk7cmV0dXJuIEIrTWF0aC5hYnMoKHRoaXMuZ2xvYmFsRW50cm9weS13KSp0aGlzLnBsYXliYWNrUmF0ZSl9LHNldDpmdW5jdGlvbihTKXtpZih0aGlzLmVudHJvcHk+Uyl7dmFyIEI9dGhpcy5zZWVrVGltZU1hcmsoUyk7dGhpc1tvXS5sZW5ndGg9QisxfXRoaXMubWFya1RpbWUoe2VudHJvcHk6U30pLHRoaXMudXBkYXRlVGltZXJzKCl9fSx7a2V5OiJnbG9iYWxFbnRyb3B5IixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc1tBXT90aGlzW0FdLmVudHJvcHk6dGhpcy5nbG9iYWxUaW1lfX0se2tleToicGxheWJhY2tSYXRlIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc1tUXX0sc2V0OmZ1bmN0aW9uKFMpe1MhPT10aGlzLnBsYXliYWNrUmF0ZSYmKHRoaXMubWFya1RpbWUoe3BsYXliYWNrUmF0ZTpTfSksdGhpc1tUXT1TLHRoaXMudXBkYXRlVGltZXJzKCkpfX0se2tleToicGF1c2VkIixnZXQ6ZnVuY3Rpb24oKXtpZih0aGlzLnBsYXliYWNrUmF0ZT09PTApcmV0dXJuITA7Zm9yKHZhciBTPXRoaXMucGFyZW50O1M7KXtpZihTLnBsYXliYWNrUmF0ZT09PTApcmV0dXJuITA7Uz1TLnBhcmVudH1yZXR1cm4hMX19XSksRH0oKTtlLmRlZmF1bHQ9TH0sZnVuY3Rpb24oYyxlLHQpe2UuX19lc01vZHVsZT0hMDt2YXIgcj10KDc3KSxzPWgociksZz10KDEyOSksdj1oKGcpO2Z1bmN0aW9uIGgobCl7cmV0dXJuIGwmJmwuX19lc01vZHVsZT9sOntkZWZhdWx0Omx9fWUuZGVmYXVsdD1mdW5jdGlvbigpe2Z1bmN0aW9uIGwodSxNKXt2YXIgZj1bXSx5PSEwLHg9ITEsYj12b2lkIDA7dHJ5e2Zvcih2YXIgTz0oMCx2LmRlZmF1bHQpKHUpLG07ISh5PShtPU8ubmV4dCgpKS5kb25lKSYmKGYucHVzaChtLnZhbHVlKSwhKE0mJmYubGVuZ3RoPT09TSkpO3k9ITApO31jYXRjaChwKXt4PSEwLGI9cH1maW5hbGx5e3RyeXsheSYmTy5yZXR1cm4mJk8ucmV0dXJuKCl9ZmluYWxseXtpZih4KXRocm93IGJ9fXJldHVybiBmfXJldHVybiBmdW5jdGlvbih1LE0pe2lmKEFycmF5LmlzQXJyYXkodSkpcmV0dXJuIHU7aWYoKDAscy5kZWZhdWx0KShPYmplY3QodSkpKXJldHVybiBsKHUsTSk7dGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZSIpfX0oKX0sZnVuY3Rpb24oYyxlLHQpe2MuZXhwb3J0cz17ZGVmYXVsdDp0KDc4KSxfX2VzTW9kdWxlOiEwfX0sZnVuY3Rpb24oYyxlLHQpe3QoNzkpLHQoMTI1KSxjLmV4cG9ydHM9dCgxMjcpfSxmdW5jdGlvbihjLGUsdCl7dCg4MCk7Zm9yKHZhciByPXQoOTEpLHM9dCg5NSksZz10KDgzKSx2PXQoMTIyKSgidG9TdHJpbmdUYWciKSxoPSJDU1NSdWxlTGlzdCxDU1NTdHlsZURlY2xhcmF0aW9uLENTU1ZhbHVlTGlzdCxDbGllbnRSZWN0TGlzdCxET01SZWN0TGlzdCxET01TdHJpbmdMaXN0LERPTVRva2VuTGlzdCxEYXRhVHJhbnNmZXJJdGVtTGlzdCxGaWxlTGlzdCxIVE1MQWxsQ29sbGVjdGlvbixIVE1MQ29sbGVjdGlvbixIVE1MRm9ybUVsZW1lbnQsSFRNTFNlbGVjdEVsZW1lbnQsTWVkaWFMaXN0LE1pbWVUeXBlQXJyYXksTmFtZWROb2RlTWFwLE5vZGVMaXN0LFBhaW50UmVxdWVzdExpc3QsUGx1Z2luLFBsdWdpbkFycmF5LFNWR0xlbmd0aExpc3QsU1ZHTnVtYmVyTGlzdCxTVkdQYXRoU2VnTGlzdCxTVkdQb2ludExpc3QsU1ZHU3RyaW5nTGlzdCxTVkdUcmFuc2Zvcm1MaXN0LFNvdXJjZUJ1ZmZlckxpc3QsU3R5bGVTaGVldExpc3QsVGV4dFRyYWNrQ3VlTGlzdCxUZXh0VHJhY2tMaXN0LFRvdWNoTGlzdCIuc3BsaXQoIiwiKSxsPTA7bDxoLmxlbmd0aDtsKyspe3ZhciB1PWhbbF0sTT1yW3VdLGY9TSYmTS5wcm90b3R5cGU7ZiYmIWZbdl0mJnMoZix2LHUpLGdbdV09Zy5BcnJheX19LGZ1bmN0aW9uKGMsZSx0KXt2YXIgcj10KDgxKSxzPXQoODIpLGc9dCg4Myksdj10KDg0KTtjLmV4cG9ydHM9dCg4OCkoQXJyYXksIkFycmF5IixmdW5jdGlvbihoLGwpe3RoaXMuX3Q9dihoKSx0aGlzLl9pPTAsdGhpcy5faz1sfSxmdW5jdGlvbigpe3ZhciBoPXRoaXMuX3QsbD10aGlzLl9rLHU9dGhpcy5faSsrO3JldHVybiFofHx1Pj1oLmxlbmd0aD8odGhpcy5fdD12b2lkIDAscygxKSk6bD09ImtleXMiP3MoMCx1KTpsPT0idmFsdWVzIj9zKDAsaFt1XSk6cygwLFt1LGhbdV1dKX0sInZhbHVlcyIpLGcuQXJndW1lbnRzPWcuQXJyYXkscigia2V5cyIpLHIoInZhbHVlcyIpLHIoImVudHJpZXMiKX0sZnVuY3Rpb24oYyxlKXtjLmV4cG9ydHM9ZnVuY3Rpb24oKXt9fSxmdW5jdGlvbihjLGUpe2MuZXhwb3J0cz1mdW5jdGlvbih0LHIpe3JldHVybnt2YWx1ZTpyLGRvbmU6ISF0fX19LGZ1bmN0aW9uKGMsZSl7Yy5leHBvcnRzPXt9fSxmdW5jdGlvbihjLGUsdCl7dmFyIHI9dCg4NSkscz10KDg3KTtjLmV4cG9ydHM9ZnVuY3Rpb24oZyl7cmV0dXJuIHIocyhnKSl9fSxmdW5jdGlvbihjLGUsdCl7dmFyIHI9dCg4Nik7Yy5leHBvcnRzPU9iamVjdCgieiIpLnByb3BlcnR5SXNFbnVtZXJhYmxlKDApP09iamVjdDpmdW5jdGlvbihzKXtyZXR1cm4gcihzKT09IlN0cmluZyI/cy5zcGxpdCgiIik6T2JqZWN0KHMpfX0sZnVuY3Rpb24oYyxlKXt2YXIgdD17fS50b1N0cmluZztjLmV4cG9ydHM9ZnVuY3Rpb24ocil7cmV0dXJuIHQuY2FsbChyKS5zbGljZSg4LC0xKX19LGZ1bmN0aW9uKGMsZSl7Yy5leHBvcnRzPWZ1bmN0aW9uKHQpe2lmKHQ9PW51bGwpdGhyb3cgVHlwZUVycm9yKCJDYW4ndCBjYWxsIG1ldGhvZCBvbiAgIit0KTtyZXR1cm4gdH19LGZ1bmN0aW9uKGMsZSx0KXt2YXIgcj10KDg5KSxzPXQoOTApLGc9dCgxMDYpLHY9dCg5NSksaD10KDgzKSxsPXQoMTA3KSx1PXQoMTIxKSxNPXQoMTIzKSxmPXQoMTIyKSgiaXRlcmF0b3IiKSx5PSEoW10ua2V5cyYmIm5leHQiaW5bXS5rZXlzKCkpLHg9IkBAaXRlcmF0b3IiLGI9ImtleXMiLE89InZhbHVlcyIsbT1mdW5jdGlvbigpe3JldHVybiB0aGlzfTtjLmV4cG9ydHM9ZnVuY3Rpb24ocCxuLGEsaSxvLFQsUCl7bChhLG4saSk7dmFyIEM9ZnVuY3Rpb24oVyl7aWYoIXkmJlcgaW4gRClyZXR1cm4gRFtXXTtzd2l0Y2goVyl7Y2FzZSBiOnJldHVybiBmdW5jdGlvbigpe3JldHVybiBuZXcgYSh0aGlzLFcpfTtjYXNlIE86cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBhKHRoaXMsVyl9fXJldHVybiBmdW5jdGlvbigpe3JldHVybiBuZXcgYSh0aGlzLFcpfX0sST1uKyIgSXRlcmF0b3IiLEE9bz09TyxMPSExLEQ9cC5wcm90b3R5cGUsUj1EW2ZdfHxEW3hdfHxvJiZEW29dLFM9Unx8QyhvKSxCPW8/QT9DKCJlbnRyaWVzIik6Uzp2b2lkIDAsdz1uPT0iQXJyYXkiJiZELmVudHJpZXN8fFIsSCxKLHE7aWYodyYmKHE9TSh3LmNhbGwobmV3IHApKSxxIT09T2JqZWN0LnByb3RvdHlwZSYmcS5uZXh0JiYodShxLEksITApLCFyJiZ0eXBlb2YgcVtmXSE9ImZ1bmN0aW9uIiYmdihxLGYsbSkpKSxBJiZSJiZSLm5hbWUhPT1PJiYoTD0hMCxTPWZ1bmN0aW9uKCl7cmV0dXJuIFIuY2FsbCh0aGlzKX0pLCghcnx8UCkmJih5fHxMfHwhRFtmXSkmJnYoRCxmLFMpLGhbbl09UyxoW0ldPW0sbylpZihIPXt2YWx1ZXM6QT9TOkMoTyksa2V5czpUP1M6QyhiKSxlbnRyaWVzOkJ9LFApZm9yKEogaW4gSClKIGluIER8fGcoRCxKLEhbSl0pO2Vsc2UgcyhzLlArcy5GKih5fHxMKSxuLEgpO3JldHVybiBIfX0sZnVuY3Rpb24oYyxlKXtjLmV4cG9ydHM9ITB9LGZ1bmN0aW9uKGMsZSx0KXt2YXIgcj10KDkxKSxzPXQoOTIpLGc9dCg5Myksdj10KDk1KSxoPXQoMTA1KSxsPSJwcm90b3R5cGUiLHU9ZnVuY3Rpb24oTSxmLHkpe3ZhciB4PU0mdS5GLGI9TSZ1LkcsTz1NJnUuUyxtPU0mdS5QLHA9TSZ1LkIsbj1NJnUuVyxhPWI/czpzW2ZdfHwoc1tmXT17fSksaT1hW2xdLG89Yj9yOk8/cltmXToocltmXXx8e30pW2xdLFQsUCxDO2ImJih5PWYpO2ZvcihUIGluIHkpUD0heCYmbyYmb1tUXSE9PXZvaWQgMCwhKFAmJmgoYSxUKSkmJihDPVA/b1tUXTp5W1RdLGFbVF09YiYmdHlwZW9mIG9bVF0hPSJmdW5jdGlvbiI/eVtUXTpwJiZQP2coQyxyKTpuJiZvW1RdPT1DP2Z1bmN0aW9uKEkpe3ZhciBBPWZ1bmN0aW9uKEwsRCxSKXtpZih0aGlzIGluc3RhbmNlb2YgSSl7c3dpdGNoKGFyZ3VtZW50cy5sZW5ndGgpe2Nhc2UgMDpyZXR1cm4gbmV3IEk7Y2FzZSAxOnJldHVybiBuZXcgSShMKTtjYXNlIDI6cmV0dXJuIG5ldyBJKEwsRCl9cmV0dXJuIG5ldyBJKEwsRCxSKX1yZXR1cm4gSS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O3JldHVybiBBW2xdPUlbbF0sQX0oQyk6bSYmdHlwZW9mIEM9PSJmdW5jdGlvbiI/ZyhGdW5jdGlvbi5jYWxsLEMpOkMsbSYmKChhLnZpcnR1YWx8fChhLnZpcnR1YWw9e30pKVtUXT1DLE0mdS5SJiZpJiYhaVtUXSYmdihpLFQsQykpKX07dS5GPTEsdS5HPTIsdS5TPTQsdS5QPTgsdS5CPTE2LHUuVz0zMix1LlU9NjQsdS5SPTEyOCxjLmV4cG9ydHM9dX0sZnVuY3Rpb24oYyxlKXt2YXIgdD1jLmV4cG9ydHM9dHlwZW9mIHdpbmRvdzwidSImJndpbmRvdy5NYXRoPT1NYXRoP3dpbmRvdzp0eXBlb2Ygc2VsZjwidSImJnNlbGYuTWF0aD09TWF0aD9zZWxmOkZ1bmN0aW9uKCJyZXR1cm4gdGhpcyIpKCk7dHlwZW9mIF9fZz09Im51bWJlciImJihfX2c9dCl9LGZ1bmN0aW9uKGMsZSl7dmFyIHQ9Yy5leHBvcnRzPXt2ZXJzaW9uOiIyLjYuMTEifTt0eXBlb2YgX19lPT0ibnVtYmVyIiYmKF9fZT10KX0sZnVuY3Rpb24oYyxlLHQpe3ZhciByPXQoOTQpO2MuZXhwb3J0cz1mdW5jdGlvbihzLGcsdil7aWYocihzKSxnPT09dm9pZCAwKXJldHVybiBzO3N3aXRjaCh2KXtjYXNlIDE6cmV0dXJuIGZ1bmN0aW9uKGgpe3JldHVybiBzLmNhbGwoZyxoKX07Y2FzZSAyOnJldHVybiBmdW5jdGlvbihoLGwpe3JldHVybiBzLmNhbGwoZyxoLGwpfTtjYXNlIDM6cmV0dXJuIGZ1bmN0aW9uKGgsbCx1KXtyZXR1cm4gcy5jYWxsKGcsaCxsLHUpfX1yZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gcy5hcHBseShnLGFyZ3VtZW50cyl9fX0sZnVuY3Rpb24oYyxlKXtjLmV4cG9ydHM9ZnVuY3Rpb24odCl7aWYodHlwZW9mIHQhPSJmdW5jdGlvbiIpdGhyb3cgVHlwZUVycm9yKHQrIiBpcyBub3QgYSBmdW5jdGlvbiEiKTtyZXR1cm4gdH19LGZ1bmN0aW9uKGMsZSx0KXt2YXIgcj10KDk2KSxzPXQoMTA0KTtjLmV4cG9ydHM9dCgxMDApP2Z1bmN0aW9uKGcsdixoKXtyZXR1cm4gci5mKGcsdixzKDEsaCkpfTpmdW5jdGlvbihnLHYsaCl7cmV0dXJuIGdbdl09aCxnfX0sZnVuY3Rpb24oYyxlLHQpe3ZhciByPXQoOTcpLHM9dCg5OSksZz10KDEwMyksdj1PYmplY3QuZGVmaW5lUHJvcGVydHk7ZS5mPXQoMTAwKT9PYmplY3QuZGVmaW5lUHJvcGVydHk6ZnVuY3Rpb24obCx1LE0pe2lmKHIobCksdT1nKHUsITApLHIoTSkscyl0cnl7cmV0dXJuIHYobCx1LE0pfWNhdGNoe31pZigiZ2V0ImluIE18fCJzZXQiaW4gTSl0aHJvdyBUeXBlRXJyb3IoIkFjY2Vzc29ycyBub3Qgc3VwcG9ydGVkISIpO3JldHVybiJ2YWx1ZSJpbiBNJiYobFt1XT1NLnZhbHVlKSxsfX0sZnVuY3Rpb24oYyxlLHQpe3ZhciByPXQoOTgpO2MuZXhwb3J0cz1mdW5jdGlvbihzKXtpZighcihzKSl0aHJvdyBUeXBlRXJyb3IocysiIGlzIG5vdCBhbiBvYmplY3QhIik7cmV0dXJuIHN9fSxmdW5jdGlvbihjLGUpe2MuZXhwb3J0cz1mdW5jdGlvbih0KXtyZXR1cm4gdHlwZW9mIHQ9PSJvYmplY3QiP3QhPT1udWxsOnR5cGVvZiB0PT0iZnVuY3Rpb24ifX0sZnVuY3Rpb24oYyxlLHQpe2MuZXhwb3J0cz0hdCgxMDApJiYhdCgxMDEpKGZ1bmN0aW9uKCl7cmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0KDEwMikoImRpdiIpLCJhIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIDd9fSkuYSE9N30pfSxmdW5jdGlvbihjLGUsdCl7Yy5leHBvcnRzPSF0KDEwMSkoZnVuY3Rpb24oKXtyZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCJhIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIDd9fSkuYSE9N30pfSxmdW5jdGlvbihjLGUpe2MuZXhwb3J0cz1mdW5jdGlvbih0KXt0cnl7cmV0dXJuISF0KCl9Y2F0Y2h7cmV0dXJuITB9fX0sZnVuY3Rpb24oYyxlLHQpe3ZhciByPXQoOTgpLHM9dCg5MSkuZG9jdW1lbnQsZz1yKHMpJiZyKHMuY3JlYXRlRWxlbWVudCk7Yy5leHBvcnRzPWZ1bmN0aW9uKHYpe3JldHVybiBnP3MuY3JlYXRlRWxlbWVudCh2KTp7fX19LGZ1bmN0aW9uKGMsZSx0KXt2YXIgcj10KDk4KTtjLmV4cG9ydHM9ZnVuY3Rpb24ocyxnKXtpZighcihzKSlyZXR1cm4gczt2YXIgdixoO2lmKGcmJnR5cGVvZih2PXMudG9TdHJpbmcpPT0iZnVuY3Rpb24iJiYhcihoPXYuY2FsbChzKSl8fHR5cGVvZih2PXMudmFsdWVPZik9PSJmdW5jdGlvbiImJiFyKGg9di5jYWxsKHMpKXx8IWcmJnR5cGVvZih2PXMudG9TdHJpbmcpPT0iZnVuY3Rpb24iJiYhcihoPXYuY2FsbChzKSkpcmV0dXJuIGg7dGhyb3cgVHlwZUVycm9yKCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWUiKX19LGZ1bmN0aW9uKGMsZSl7Yy5leHBvcnRzPWZ1bmN0aW9uKHQscil7cmV0dXJue2VudW1lcmFibGU6ISh0JjEpLGNvbmZpZ3VyYWJsZTohKHQmMiksd3JpdGFibGU6ISh0JjQpLHZhbHVlOnJ9fX0sZnVuY3Rpb24oYyxlKXt2YXIgdD17fS5oYXNPd25Qcm9wZXJ0eTtjLmV4cG9ydHM9ZnVuY3Rpb24ocixzKXtyZXR1cm4gdC5jYWxsKHIscyl9fSxmdW5jdGlvbihjLGUsdCl7Yy5leHBvcnRzPXQoOTUpfSxmdW5jdGlvbihjLGUsdCl7dmFyIHI9dCgxMDgpLHM9dCgxMDQpLGc9dCgxMjEpLHY9e307dCg5NSkodix0KDEyMikoIml0ZXJhdG9yIiksZnVuY3Rpb24oKXtyZXR1cm4gdGhpc30pLGMuZXhwb3J0cz1mdW5jdGlvbihoLGwsdSl7aC5wcm90b3R5cGU9cih2LHtuZXh0OnMoMSx1KX0pLGcoaCxsKyIgSXRlcmF0b3IiKX19LGZ1bmN0aW9uKGMsZSx0KXt2YXIgcj10KDk3KSxzPXQoMTA5KSxnPXQoMTE5KSx2PXQoMTE2KSgiSUVfUFJPVE8iKSxoPWZ1bmN0aW9uKCl7fSxsPSJwcm90b3R5cGUiLHU9ZnVuY3Rpb24oKXt2YXIgTT10KDEwMikoImlmcmFtZSIpLGY9Zy5sZW5ndGgseT0iPCIseD0iPiIsYjtmb3IoTS5zdHlsZS5kaXNwbGF5PSJub25lIix0KDEyMCkuYXBwZW5kQ2hpbGQoTSksTS5zcmM9ImphdmFzY3JpcHQ6IixiPU0uY29udGVudFdpbmRvdy5kb2N1bWVudCxiLm9wZW4oKSxiLndyaXRlKHkrInNjcmlwdCIreCsiZG9jdW1lbnQuRj1PYmplY3QiK3krIi9zY3JpcHQiK3gpLGIuY2xvc2UoKSx1PWIuRjtmLS07KWRlbGV0ZSB1W2xdW2dbZl1dO3JldHVybiB1KCl9O2MuZXhwb3J0cz1PYmplY3QuY3JlYXRlfHxmdW5jdGlvbihmLHkpe3ZhciB4O3JldHVybiBmIT09bnVsbD8oaFtsXT1yKGYpLHg9bmV3IGgsaFtsXT1udWxsLHhbdl09Zik6eD11KCkseT09PXZvaWQgMD94OnMoeCx5KX19LGZ1bmN0aW9uKGMsZSx0KXt2YXIgcj10KDk2KSxzPXQoOTcpLGc9dCgxMTApO2MuZXhwb3J0cz10KDEwMCk/T2JqZWN0LmRlZmluZVByb3BlcnRpZXM6ZnVuY3Rpb24oaCxsKXtzKGgpO2Zvcih2YXIgdT1nKGwpLE09dS5sZW5ndGgsZj0wLHk7TT5mOylyLmYoaCx5PXVbZisrXSxsW3ldKTtyZXR1cm4gaH19LGZ1bmN0aW9uKGMsZSx0KXt2YXIgcj10KDExMSkscz10KDExOSk7Yy5leHBvcnRzPU9iamVjdC5rZXlzfHxmdW5jdGlvbih2KXtyZXR1cm4gcih2LHMpfX0sZnVuY3Rpb24oYyxlLHQpe3ZhciByPXQoMTA1KSxzPXQoODQpLGc9dCgxMTIpKCExKSx2PXQoMTE2KSgiSUVfUFJPVE8iKTtjLmV4cG9ydHM9ZnVuY3Rpb24oaCxsKXt2YXIgdT1zKGgpLE09MCxmPVtdLHk7Zm9yKHkgaW4gdSl5IT12JiZyKHUseSkmJmYucHVzaCh5KTtmb3IoO2wubGVuZ3RoPk07KXIodSx5PWxbTSsrXSkmJih+ZyhmLHkpfHxmLnB1c2goeSkpO3JldHVybiBmfX0sZnVuY3Rpb24oYyxlLHQpe3ZhciByPXQoODQpLHM9dCgxMTMpLGc9dCgxMTUpO2MuZXhwb3J0cz1mdW5jdGlvbih2KXtyZXR1cm4gZnVuY3Rpb24oaCxsLHUpe3ZhciBNPXIoaCksZj1zKE0ubGVuZ3RoKSx5PWcodSxmKSx4O2lmKHYmJmwhPWwpe2Zvcig7Zj55OylpZih4PU1beSsrXSx4IT14KXJldHVybiEwfWVsc2UgZm9yKDtmPnk7eSsrKWlmKCh2fHx5IGluIE0pJiZNW3ldPT09bClyZXR1cm4gdnx8eXx8MDtyZXR1cm4hdiYmLTF9fX0sZnVuY3Rpb24oYyxlLHQpe3ZhciByPXQoMTE0KSxzPU1hdGgubWluO2MuZXhwb3J0cz1mdW5jdGlvbihnKXtyZXR1cm4gZz4wP3MocihnKSw5MDA3MTk5MjU0NzQwOTkxKTowfX0sZnVuY3Rpb24oYyxlKXt2YXIgdD1NYXRoLmNlaWwscj1NYXRoLmZsb29yO2MuZXhwb3J0cz1mdW5jdGlvbihzKXtyZXR1cm4gaXNOYU4ocz0rcyk/MDoocz4wP3I6dCkocyl9fSxmdW5jdGlvbihjLGUsdCl7dmFyIHI9dCgxMTQpLHM9TWF0aC5tYXgsZz1NYXRoLm1pbjtjLmV4cG9ydHM9ZnVuY3Rpb24odixoKXtyZXR1cm4gdj1yKHYpLHY8MD9zKHYraCwwKTpnKHYsaCl9fSxmdW5jdGlvbihjLGUsdCl7dmFyIHI9dCgxMTcpKCJrZXlzIikscz10KDExOCk7Yy5leHBvcnRzPWZ1bmN0aW9uKGcpe3JldHVybiByW2ddfHwocltnXT1zKGcpKX19LGZ1bmN0aW9uKGMsZSx0KXt2YXIgcj10KDkyKSxzPXQoOTEpLGc9Il9fY29yZS1qc19zaGFyZWRfXyIsdj1zW2ddfHwoc1tnXT17fSk7KGMuZXhwb3J0cz1mdW5jdGlvbihoLGwpe3JldHVybiB2W2hdfHwodltoXT1sIT09dm9pZCAwP2w6e30pfSkoInZlcnNpb25zIixbXSkucHVzaCh7dmVyc2lvbjpyLnZlcnNpb24sbW9kZTp0KDg5KT8icHVyZSI6Imdsb2JhbCIsY29weXJpZ2h0OiLCqSAyMDE5IERlbmlzIFB1c2hrYXJldiAoemxvaXJvY2sucnUpIn0pfSxmdW5jdGlvbihjLGUpe3ZhciB0PTAscj1NYXRoLnJhbmRvbSgpO2MuZXhwb3J0cz1mdW5jdGlvbihzKXtyZXR1cm4iU3ltYm9sKCIuY29uY2F0KHM9PT12b2lkIDA/IiI6cywiKV8iLCgrK3QrcikudG9TdHJpbmcoMzYpKX19LGZ1bmN0aW9uKGMsZSl7Yy5leHBvcnRzPSJjb25zdHJ1Y3RvcixoYXNPd25Qcm9wZXJ0eSxpc1Byb3RvdHlwZU9mLHByb3BlcnR5SXNFbnVtZXJhYmxlLHRvTG9jYWxlU3RyaW5nLHRvU3RyaW5nLHZhbHVlT2YiLnNwbGl0KCIsIil9LGZ1bmN0aW9uKGMsZSx0KXt2YXIgcj10KDkxKS5kb2N1bWVudDtjLmV4cG9ydHM9ciYmci5kb2N1bWVudEVsZW1lbnR9LGZ1bmN0aW9uKGMsZSx0KXt2YXIgcj10KDk2KS5mLHM9dCgxMDUpLGc9dCgxMjIpKCJ0b1N0cmluZ1RhZyIpO2MuZXhwb3J0cz1mdW5jdGlvbih2LGgsbCl7diYmIXModj1sP3Y6di5wcm90b3R5cGUsZykmJnIodixnLHtjb25maWd1cmFibGU6ITAsdmFsdWU6aH0pfX0sZnVuY3Rpb24oYyxlLHQpe3ZhciByPXQoMTE3KSgid2tzIikscz10KDExOCksZz10KDkxKS5TeW1ib2wsdj10eXBlb2YgZz09ImZ1bmN0aW9uIixoPWMuZXhwb3J0cz1mdW5jdGlvbihsKXtyZXR1cm4gcltsXXx8KHJbbF09diYmZ1tsXXx8KHY/ZzpzKSgiU3ltYm9sLiIrbCkpfTtoLnN0b3JlPXJ9LGZ1bmN0aW9uKGMsZSx0KXt2YXIgcj10KDEwNSkscz10KDEyNCksZz10KDExNikoIklFX1BST1RPIiksdj1PYmplY3QucHJvdG90eXBlO2MuZXhwb3J0cz1PYmplY3QuZ2V0UHJvdG90eXBlT2Z8fGZ1bmN0aW9uKGgpe3JldHVybiBoPXMoaCkscihoLGcpP2hbZ106dHlwZW9mIGguY29uc3RydWN0b3I9PSJmdW5jdGlvbiImJmggaW5zdGFuY2VvZiBoLmNvbnN0cnVjdG9yP2guY29uc3RydWN0b3IucHJvdG90eXBlOmggaW5zdGFuY2VvZiBPYmplY3Q/djpudWxsfX0sZnVuY3Rpb24oYyxlLHQpe3ZhciByPXQoODcpO2MuZXhwb3J0cz1mdW5jdGlvbihzKXtyZXR1cm4gT2JqZWN0KHIocykpfX0sZnVuY3Rpb24oYyxlLHQpe3ZhciByPXQoMTI2KSghMCk7dCg4OCkoU3RyaW5nLCJTdHJpbmciLGZ1bmN0aW9uKHMpe3RoaXMuX3Q9U3RyaW5nKHMpLHRoaXMuX2k9MH0sZnVuY3Rpb24oKXt2YXIgcz10aGlzLl90LGc9dGhpcy5faSx2O3JldHVybiBnPj1zLmxlbmd0aD97dmFsdWU6dm9pZCAwLGRvbmU6ITB9Oih2PXIocyxnKSx0aGlzLl9pKz12Lmxlbmd0aCx7dmFsdWU6dixkb25lOiExfSl9KX0sZnVuY3Rpb24oYyxlLHQpe3ZhciByPXQoMTE0KSxzPXQoODcpO2MuZXhwb3J0cz1mdW5jdGlvbihnKXtyZXR1cm4gZnVuY3Rpb24odixoKXt2YXIgbD1TdHJpbmcocyh2KSksdT1yKGgpLE09bC5sZW5ndGgsZix5O3JldHVybiB1PDB8fHU+PU0/Zz8iIjp2b2lkIDA6KGY9bC5jaGFyQ29kZUF0KHUpLGY8NTUyOTZ8fGY+NTYzMTl8fHUrMT09PU18fCh5PWwuY2hhckNvZGVBdCh1KzEpKTw1NjMyMHx8eT41NzM0Mz9nP2wuY2hhckF0KHUpOmY6Zz9sLnNsaWNlKHUsdSsyKTooZi01NTI5Njw8MTApKyh5LTU2MzIwKSs2NTUzNil9fX0sZnVuY3Rpb24oYyxlLHQpe3ZhciByPXQoMTI4KSxzPXQoMTIyKSgiaXRlcmF0b3IiKSxnPXQoODMpO2MuZXhwb3J0cz10KDkyKS5pc0l0ZXJhYmxlPWZ1bmN0aW9uKHYpe3ZhciBoPU9iamVjdCh2KTtyZXR1cm4gaFtzXSE9PXZvaWQgMHx8IkBAaXRlcmF0b3IiaW4gaHx8Zy5oYXNPd25Qcm9wZXJ0eShyKGgpKX19LGZ1bmN0aW9uKGMsZSx0KXt2YXIgcj10KDg2KSxzPXQoMTIyKSgidG9TdHJpbmdUYWciKSxnPXIoZnVuY3Rpb24oKXtyZXR1cm4gYXJndW1lbnRzfSgpKT09IkFyZ3VtZW50cyIsdj1mdW5jdGlvbihoLGwpe3RyeXtyZXR1cm4gaFtsXX1jYXRjaHt9fTtjLmV4cG9ydHM9ZnVuY3Rpb24oaCl7dmFyIGwsdSxNO3JldHVybiBoPT09dm9pZCAwPyJVbmRlZmluZWQiOmg9PT1udWxsPyJOdWxsIjp0eXBlb2YodT12KGw9T2JqZWN0KGgpLHMpKT09InN0cmluZyI/dTpnP3IobCk6KE09cihsKSk9PSJPYmplY3QiJiZ0eXBlb2YgbC5jYWxsZWU9PSJmdW5jdGlvbiI/IkFyZ3VtZW50cyI6TX19LGZ1bmN0aW9uKGMsZSx0KXtjLmV4cG9ydHM9e2RlZmF1bHQ6dCgxMzApLF9fZXNNb2R1bGU6ITB9fSxmdW5jdGlvbihjLGUsdCl7dCg3OSksdCgxMjUpLGMuZXhwb3J0cz10KDEzMSl9LGZ1bmN0aW9uKGMsZSx0KXt2YXIgcj10KDk3KSxzPXQoMTMyKTtjLmV4cG9ydHM9dCg5MikuZ2V0SXRlcmF0b3I9ZnVuY3Rpb24oZyl7dmFyIHY9cyhnKTtpZih0eXBlb2YgdiE9ImZ1bmN0aW9uIil0aHJvdyBUeXBlRXJyb3IoZysiIGlzIG5vdCBpdGVyYWJsZSEiKTtyZXR1cm4gcih2LmNhbGwoZykpfX0sZnVuY3Rpb24oYyxlLHQpe3ZhciByPXQoMTI4KSxzPXQoMTIyKSgiaXRlcmF0b3IiKSxnPXQoODMpO2MuZXhwb3J0cz10KDkyKS5nZXRJdGVyYXRvck1ldGhvZD1mdW5jdGlvbih2KXtpZih2IT1udWxsKXJldHVybiB2W3NdfHx2WyJAQGl0ZXJhdG9yIl18fGdbcih2KV19fSxmdW5jdGlvbihjLGUsdCl7ZS5fX2VzTW9kdWxlPSEwO3ZhciByPXQoMTM0KSxzPWcocik7ZnVuY3Rpb24gZyh2KXtyZXR1cm4gdiYmdi5fX2VzTW9kdWxlP3Y6e2RlZmF1bHQ6dn19ZS5kZWZhdWx0PWZ1bmN0aW9uKHYpe2lmKEFycmF5LmlzQXJyYXkodikpe2Zvcih2YXIgaD0wLGw9QXJyYXkodi5sZW5ndGgpO2g8di5sZW5ndGg7aCsrKWxbaF09dltoXTtyZXR1cm4gbH1lbHNlIHJldHVybigwLHMuZGVmYXVsdCkodil9fSxmdW5jdGlvbihjLGUsdCl7Yy5leHBvcnRzPXtkZWZhdWx0OnQoMTM1KSxfX2VzTW9kdWxlOiEwfX0sZnVuY3Rpb24oYyxlLHQpe3QoMTI1KSx0KDEzNiksYy5leHBvcnRzPXQoOTIpLkFycmF5LmZyb219LGZ1bmN0aW9uKGMsZSx0KXt2YXIgcj10KDkzKSxzPXQoOTApLGc9dCgxMjQpLHY9dCgxMzcpLGg9dCgxMzgpLGw9dCgxMTMpLHU9dCgxMzkpLE09dCgxMzIpO3Mocy5TK3MuRiohdCgxNDApKGZ1bmN0aW9uKGYpe0FycmF5LmZyb20oZil9KSwiQXJyYXkiLHtmcm9tOmZ1bmN0aW9uKHkpe3ZhciB4PWcoeSksYj10eXBlb2YgdGhpcz09ImZ1bmN0aW9uIj90aGlzOkFycmF5LE89YXJndW1lbnRzLmxlbmd0aCxtPU8+MT9hcmd1bWVudHNbMV06dm9pZCAwLHA9bSE9PXZvaWQgMCxuPTAsYT1NKHgpLGksbyxULFA7aWYocCYmKG09cihtLE8+Mj9hcmd1bWVudHNbMl06dm9pZCAwLDIpKSxhIT1udWxsJiYhKGI9PUFycmF5JiZoKGEpKSlmb3IoUD1hLmNhbGwoeCksbz1uZXcgYjshKFQ9UC5uZXh0KCkpLmRvbmU7bisrKXUobyxuLHA/dihQLG0sW1QudmFsdWUsbl0sITApOlQudmFsdWUpO2Vsc2UgZm9yKGk9bCh4Lmxlbmd0aCksbz1uZXcgYihpKTtpPm47bisrKXUobyxuLHA/bSh4W25dLG4pOnhbbl0pO3JldHVybiBvLmxlbmd0aD1uLG99fSl9LGZ1bmN0aW9uKGMsZSx0KXt2YXIgcj10KDk3KTtjLmV4cG9ydHM9ZnVuY3Rpb24ocyxnLHYsaCl7dHJ5e3JldHVybiBoP2cocih2KVswXSx2WzFdKTpnKHYpfWNhdGNoKHUpe3ZhciBsPXMucmV0dXJuO3Rocm93IGwhPT12b2lkIDAmJnIobC5jYWxsKHMpKSx1fX19LGZ1bmN0aW9uKGMsZSx0KXt2YXIgcj10KDgzKSxzPXQoMTIyKSgiaXRlcmF0b3IiKSxnPUFycmF5LnByb3RvdHlwZTtjLmV4cG9ydHM9ZnVuY3Rpb24odil7cmV0dXJuIHYhPT12b2lkIDAmJihyLkFycmF5PT09dnx8Z1tzXT09PXYpfX0sZnVuY3Rpb24oYyxlLHQpe3ZhciByPXQoOTYpLHM9dCgxMDQpO2MuZXhwb3J0cz1mdW5jdGlvbihnLHYsaCl7diBpbiBnP3IuZihnLHYscygwLGgpKTpnW3ZdPWh9fSxmdW5jdGlvbihjLGUsdCl7dmFyIHI9dCgxMjIpKCJpdGVyYXRvciIpLHM9ITE7dHJ5e3ZhciBnPVs3XVtyXSgpO2cucmV0dXJuPWZ1bmN0aW9uKCl7cz0hMH0sQXJyYXkuZnJvbShnLGZ1bmN0aW9uKCl7dGhyb3cgMn0pfWNhdGNoe31jLmV4cG9ydHM9ZnVuY3Rpb24odixoKXtpZighaCYmIXMpcmV0dXJuITE7dmFyIGw9ITE7dHJ5e3ZhciB1PVs3XSxNPXVbcl0oKTtNLm5leHQ9ZnVuY3Rpb24oKXtyZXR1cm57ZG9uZTpsPSEwfX0sdVtyXT1mdW5jdGlvbigpe3JldHVybiBNfSx2KHUpfWNhdGNoe31yZXR1cm4gbH19LGZ1bmN0aW9uKGMsZSx0KXtjLmV4cG9ydHM9e2RlZmF1bHQ6dCgxNDIpLF9fZXNNb2R1bGU6ITB9fSxmdW5jdGlvbihjLGUsdCl7dCgxNDMpLHQoMTI1KSx0KDc5KSx0KDE0NCksdCgxNTcpLHQoMTYwKSx0KDE2MiksYy5leHBvcnRzPXQoOTIpLk1hcH0sZnVuY3Rpb24oYyxlKXt9LGZ1bmN0aW9uKGMsZSx0KXt2YXIgcj10KDE0NSkscz10KDE1MSksZz0iTWFwIjtjLmV4cG9ydHM9dCgxNTIpKGcsZnVuY3Rpb24odil7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIHYodGhpcyxhcmd1bWVudHMubGVuZ3RoPjA/YXJndW1lbnRzWzBdOnZvaWQgMCl9fSx7Z2V0OmZ1bmN0aW9uKGgpe3ZhciBsPXIuZ2V0RW50cnkocyh0aGlzLGcpLGgpO3JldHVybiBsJiZsLnZ9LHNldDpmdW5jdGlvbihoLGwpe3JldHVybiByLmRlZihzKHRoaXMsZyksaD09PTA/MDpoLGwpfX0sciwhMCl9LGZ1bmN0aW9uKGMsZSx0KXt2YXIgcj10KDk2KS5mLHM9dCgxMDgpLGc9dCgxNDYpLHY9dCg5MyksaD10KDE0NyksbD10KDE0OCksdT10KDg4KSxNPXQoODIpLGY9dCgxNDkpLHk9dCgxMDApLHg9dCgxNTApLmZhc3RLZXksYj10KDE1MSksTz15PyJfcyI6InNpemUiLG09ZnVuY3Rpb24ocCxuKXt2YXIgYT14KG4pLGk7aWYoYSE9PSJGIilyZXR1cm4gcC5faVthXTtmb3IoaT1wLl9mO2k7aT1pLm4paWYoaS5rPT1uKXJldHVybiBpfTtjLmV4cG9ydHM9e2dldENvbnN0cnVjdG9yOmZ1bmN0aW9uKHAsbixhLGkpe3ZhciBvPXAoZnVuY3Rpb24oVCxQKXtoKFQsbyxuLCJfaSIpLFQuX3Q9bixULl9pPXMobnVsbCksVC5fZj12b2lkIDAsVC5fbD12b2lkIDAsVFtPXT0wLFAhPW51bGwmJmwoUCxhLFRbaV0sVCl9KTtyZXR1cm4gZyhvLnByb3RvdHlwZSx7Y2xlYXI6ZnVuY3Rpb24oKXtmb3IodmFyIFA9Yih0aGlzLG4pLEM9UC5faSxJPVAuX2Y7STtJPUkubilJLnI9ITAsSS5wJiYoSS5wPUkucC5uPXZvaWQgMCksZGVsZXRlIENbSS5pXTtQLl9mPVAuX2w9dm9pZCAwLFBbT109MH0sZGVsZXRlOmZ1bmN0aW9uKFQpe3ZhciBQPWIodGhpcyxuKSxDPW0oUCxUKTtpZihDKXt2YXIgST1DLm4sQT1DLnA7ZGVsZXRlIFAuX2lbQy5pXSxDLnI9ITAsQSYmKEEubj1JKSxJJiYoSS5wPUEpLFAuX2Y9PUMmJihQLl9mPUkpLFAuX2w9PUMmJihQLl9sPUEpLFBbT10tLX1yZXR1cm4hIUN9LGZvckVhY2g6ZnVuY3Rpb24oUCl7Yih0aGlzLG4pO2Zvcih2YXIgQz12KFAsYXJndW1lbnRzLmxlbmd0aD4xP2FyZ3VtZW50c1sxXTp2b2lkIDAsMyksSTtJPUk/SS5uOnRoaXMuX2Y7KWZvcihDKEkudixJLmssdGhpcyk7SSYmSS5yOylJPUkucH0saGFzOmZ1bmN0aW9uKFApe3JldHVybiEhbShiKHRoaXMsbiksUCl9fSkseSYmcihvLnByb3RvdHlwZSwic2l6ZSIse2dldDpmdW5jdGlvbigpe3JldHVybiBiKHRoaXMsbilbT119fSksb30sZGVmOmZ1bmN0aW9uKHAsbixhKXt2YXIgaT1tKHAsbiksbyxUO3JldHVybiBpP2kudj1hOihwLl9sPWk9e2k6VD14KG4sITApLGs6bix2OmEscDpvPXAuX2wsbjp2b2lkIDAscjohMX0scC5fZnx8KHAuX2Y9aSksbyYmKG8ubj1pKSxwW09dKyssVCE9PSJGIiYmKHAuX2lbVF09aSkpLHB9LGdldEVudHJ5Om0sc2V0U3Ryb25nOmZ1bmN0aW9uKHAsbixhKXt1KHAsbixmdW5jdGlvbihpLG8pe3RoaXMuX3Q9YihpLG4pLHRoaXMuX2s9byx0aGlzLl9sPXZvaWQgMH0sZnVuY3Rpb24oKXtmb3IodmFyIGk9dGhpcyxvPWkuX2ssVD1pLl9sO1QmJlQucjspVD1ULnA7cmV0dXJuIWkuX3R8fCEoaS5fbD1UPVQ/VC5uOmkuX3QuX2YpPyhpLl90PXZvaWQgMCxNKDEpKTpvPT0ia2V5cyI/TSgwLFQuayk6bz09InZhbHVlcyI/TSgwLFQudik6TSgwLFtULmssVC52XSl9LGE/ImVudHJpZXMiOiJ2YWx1ZXMiLCFhLCEwKSxmKG4pfX19LGZ1bmN0aW9uKGMsZSx0KXt2YXIgcj10KDk1KTtjLmV4cG9ydHM9ZnVuY3Rpb24ocyxnLHYpe2Zvcih2YXIgaCBpbiBnKXYmJnNbaF0/c1toXT1nW2hdOnIocyxoLGdbaF0pO3JldHVybiBzfX0sZnVuY3Rpb24oYyxlKXtjLmV4cG9ydHM9ZnVuY3Rpb24odCxyLHMsZyl7aWYoISh0IGluc3RhbmNlb2Ygcil8fGchPT12b2lkIDAmJmcgaW4gdCl0aHJvdyBUeXBlRXJyb3IocysiOiBpbmNvcnJlY3QgaW52b2NhdGlvbiEiKTtyZXR1cm4gdH19LGZ1bmN0aW9uKGMsZix0KXt2YXIgcj10KDkzKSxzPXQoMTM3KSxnPXQoMTM4KSx2PXQoOTcpLGg9dCgxMTMpLGw9dCgxMzIpLHU9e30sTT17fSxmPWMuZXhwb3J0cz1mdW5jdGlvbih5LHgsYixPLG0pe3ZhciBwPW0/ZnVuY3Rpb24oKXtyZXR1cm4geX06bCh5KSxuPXIoYixPLHg/MjoxKSxhPTAsaSxvLFQsUDtpZih0eXBlb2YgcCE9ImZ1bmN0aW9uIil0aHJvdyBUeXBlRXJyb3IoeSsiIGlzIG5vdCBpdGVyYWJsZSEiKTtpZihnKHApKXtmb3IoaT1oKHkubGVuZ3RoKTtpPmE7YSsrKWlmKFA9eD9uKHYobz15W2FdKVswXSxvWzFdKTpuKHlbYV0pLFA9PT11fHxQPT09TSlyZXR1cm4gUH1lbHNlIGZvcihUPXAuY2FsbCh5KTshKG89VC5uZXh0KCkpLmRvbmU7KWlmKFA9cyhULG4sby52YWx1ZSx4KSxQPT09dXx8UD09PU0pcmV0dXJuIFB9O2YuQlJFQUs9dSxmLlJFVFVSTj1NfSxmdW5jdGlvbihjLGUsdCl7dmFyIHI9dCg5MSkscz10KDkyKSxnPXQoOTYpLHY9dCgxMDApLGg9dCgxMjIpKCJzcGVjaWVzIik7Yy5leHBvcnRzPWZ1bmN0aW9uKGwpe3ZhciB1PXR5cGVvZiBzW2xdPT0iZnVuY3Rpb24iP3NbbF06cltsXTt2JiZ1JiYhdVtoXSYmZy5mKHUsaCx7Y29uZmlndXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzfX0pfX0sZnVuY3Rpb24oYyxlLHQpe3ZhciByPXQoMTE4KSgibWV0YSIpLHM9dCg5OCksZz10KDEwNSksdj10KDk2KS5mLGg9MCxsPU9iamVjdC5pc0V4dGVuc2libGV8fGZ1bmN0aW9uKCl7cmV0dXJuITB9LHU9IXQoMTAxKShmdW5jdGlvbigpe3JldHVybiBsKE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh7fSkpfSksTT1mdW5jdGlvbihPKXt2KE8scix7dmFsdWU6e2k6Ik8iKyArK2gsdzp7fX19KX0sZj1mdW5jdGlvbihPLG0pe2lmKCFzKE8pKXJldHVybiB0eXBlb2YgTz09InN5bWJvbCI/TzoodHlwZW9mIE89PSJzdHJpbmciPyJTIjoiUCIpK087aWYoIWcoTyxyKSl7aWYoIWwoTykpcmV0dXJuIkYiO2lmKCFtKXJldHVybiJFIjtNKE8pfXJldHVybiBPW3JdLml9LHk9ZnVuY3Rpb24oTyxtKXtpZighZyhPLHIpKXtpZighbChPKSlyZXR1cm4hMDtpZighbSlyZXR1cm4hMTtNKE8pfXJldHVybiBPW3JdLnd9LHg9ZnVuY3Rpb24oTyl7cmV0dXJuIHUmJmIuTkVFRCYmbChPKSYmIWcoTyxyKSYmTShPKSxPfSxiPWMuZXhwb3J0cz17S0VZOnIsTkVFRDohMSxmYXN0S2V5OmYsZ2V0V2Vhazp5LG9uRnJlZXplOnh9fSxmdW5jdGlvbihjLGUsdCl7dmFyIHI9dCg5OCk7Yy5leHBvcnRzPWZ1bmN0aW9uKHMsZyl7aWYoIXIocyl8fHMuX3QhPT1nKXRocm93IFR5cGVFcnJvcigiSW5jb21wYXRpYmxlIHJlY2VpdmVyLCAiK2crIiByZXF1aXJlZCEiKTtyZXR1cm4gc319LGZ1bmN0aW9uKGMsZSx0KXt2YXIgcj10KDkxKSxzPXQoOTApLGc9dCgxNTApLHY9dCgxMDEpLGg9dCg5NSksbD10KDE0NiksdT10KDE0OCksTT10KDE0NyksZj10KDk4KSx5PXQoMTIxKSx4PXQoOTYpLmYsYj10KDE1MykoMCksTz10KDEwMCk7Yy5leHBvcnRzPWZ1bmN0aW9uKG0scCxuLGEsaSxvKXt2YXIgVD1yW21dLFA9VCxDPWk/InNldCI6ImFkZCIsST1QJiZQLnByb3RvdHlwZSxBPXt9O3JldHVybiFPfHx0eXBlb2YgUCE9ImZ1bmN0aW9uInx8IShvfHxJLmZvckVhY2gmJiF2KGZ1bmN0aW9uKCl7bmV3IFAoKS5lbnRyaWVzKCkubmV4dCgpfSkpPyhQPWEuZ2V0Q29uc3RydWN0b3IocCxtLGksQyksbChQLnByb3RvdHlwZSxuKSxnLk5FRUQ9ITApOihQPXAoZnVuY3Rpb24oTCxEKXtNKEwsUCxtLCJfYyIpLEwuX2M9bmV3IFQsRCE9bnVsbCYmdShELGksTFtDXSxMKX0pLGIoImFkZCxjbGVhcixkZWxldGUsZm9yRWFjaCxnZXQsaGFzLHNldCxrZXlzLHZhbHVlcyxlbnRyaWVzLHRvSlNPTiIuc3BsaXQoIiwiKSxmdW5jdGlvbihMKXt2YXIgRD1MPT0iYWRkInx8TD09InNldCI7TCBpbiBJJiYhKG8mJkw9PSJjbGVhciIpJiZoKFAucHJvdG90eXBlLEwsZnVuY3Rpb24oUixTKXtpZihNKHRoaXMsUCxMKSwhRCYmbyYmIWYoUikpcmV0dXJuIEw9PSJnZXQiP3ZvaWQgMDohMTt2YXIgQj10aGlzLl9jW0xdKFI9PT0wPzA6UixTKTtyZXR1cm4gRD90aGlzOkJ9KX0pLG98fHgoUC5wcm90b3R5cGUsInNpemUiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fYy5zaXplfX0pKSx5KFAsbSksQVttXT1QLHMocy5HK3MuVytzLkYsQSksb3x8YS5zZXRTdHJvbmcoUCxtLGkpLFB9fSxmdW5jdGlvbihjLGUsdCl7dmFyIHI9dCg5Mykscz10KDg1KSxnPXQoMTI0KSx2PXQoMTEzKSxoPXQoMTU0KTtjLmV4cG9ydHM9ZnVuY3Rpb24obCx1KXt2YXIgTT1sPT0xLGY9bD09Mix5PWw9PTMseD1sPT00LGI9bD09NixPPWw9PTV8fGIsbT11fHxoO3JldHVybiBmdW5jdGlvbihwLG4sYSl7Zm9yKHZhciBpPWcocCksbz1zKGkpLFQ9cihuLGEsMyksUD12KG8ubGVuZ3RoKSxDPTAsST1NP20ocCxQKTpmP20ocCwwKTp2b2lkIDAsQSxMO1A+QztDKyspaWYoKE98fEMgaW4gbykmJihBPW9bQ10sTD1UKEEsQyxpKSxsKSl7aWYoTSlJW0NdPUw7ZWxzZSBpZihMKXN3aXRjaChsKXtjYXNlIDM6cmV0dXJuITA7Y2FzZSA1OnJldHVybiBBO2Nhc2UgNjpyZXR1cm4gQztjYXNlIDI6SS5wdXNoKEEpfWVsc2UgaWYoeClyZXR1cm4hMX1yZXR1cm4gYj8tMTp5fHx4P3g6SX19fSxmdW5jdGlvbihjLGUsdCl7dmFyIHI9dCgxNTUpO2MuZXhwb3J0cz1mdW5jdGlvbihzLGcpe3JldHVybiBuZXcocihzKSkoZyl9fSxmdW5jdGlvbihjLGUsdCl7dmFyIHI9dCg5OCkscz10KDE1NiksZz10KDEyMikoInNwZWNpZXMiKTtjLmV4cG9ydHM9ZnVuY3Rpb24odil7dmFyIGg7cmV0dXJuIHModikmJihoPXYuY29uc3RydWN0b3IsdHlwZW9mIGg9PSJmdW5jdGlvbiImJihoPT09QXJyYXl8fHMoaC5wcm90b3R5cGUpKSYmKGg9dm9pZCAwKSxyKGgpJiYoaD1oW2ddLGg9PT1udWxsJiYoaD12b2lkIDApKSksaD09PXZvaWQgMD9BcnJheTpofX0sZnVuY3Rpb24oYyxlLHQpe3ZhciByPXQoODYpO2MuZXhwb3J0cz1BcnJheS5pc0FycmF5fHxmdW5jdGlvbihnKXtyZXR1cm4gcihnKT09IkFycmF5In19LGZ1bmN0aW9uKGMsZSx0KXt2YXIgcj10KDkwKTtyKHIuUCtyLlIsIk1hcCIse3RvSlNPTjp0KDE1OCkoIk1hcCIpfSl9LGZ1bmN0aW9uKGMsZSx0KXt2YXIgcj10KDEyOCkscz10KDE1OSk7Yy5leHBvcnRzPWZ1bmN0aW9uKGcpe3JldHVybiBmdW5jdGlvbigpe2lmKHIodGhpcykhPWcpdGhyb3cgVHlwZUVycm9yKGcrIiN0b0pTT04gaXNuJ3QgZ2VuZXJpYyIpO3JldHVybiBzKHRoaXMpfX19LGZ1bmN0aW9uKGMsZSx0KXt2YXIgcj10KDE0OCk7Yy5leHBvcnRzPWZ1bmN0aW9uKHMsZyl7dmFyIHY9W107cmV0dXJuIHIocywhMSx2LnB1c2gsdixnKSx2fX0sZnVuY3Rpb24oYyxlLHQpe3QoMTYxKSgiTWFwIil9LGZ1bmN0aW9uKGMsZSx0KXt2YXIgcj10KDkwKTtjLmV4cG9ydHM9ZnVuY3Rpb24ocyl7cihyLlMscyx7b2Y6ZnVuY3Rpb24oKXtmb3IodmFyIHY9YXJndW1lbnRzLmxlbmd0aCxoPW5ldyBBcnJheSh2KTt2LS07KWhbdl09YXJndW1lbnRzW3ZdO3JldHVybiBuZXcgdGhpcyhoKX19KX19LGZ1bmN0aW9uKGMsZSx0KXt0KDE2MykoIk1hcCIpfSxmdW5jdGlvbihjLGUsdCl7dmFyIHI9dCg5MCkscz10KDk0KSxnPXQoOTMpLHY9dCgxNDgpO2MuZXhwb3J0cz1mdW5jdGlvbihoKXtyKHIuUyxoLHtmcm9tOmZ1bmN0aW9uKHUpe3ZhciBNPWFyZ3VtZW50c1sxXSxmLHkseCxiO3JldHVybiBzKHRoaXMpLGY9TSE9PXZvaWQgMCxmJiZzKE0pLHU9PW51bGw/bmV3IHRoaXM6KHk9W10sZj8oeD0wLGI9ZyhNLGFyZ3VtZW50c1syXSwyKSx2KHUsITEsZnVuY3Rpb24oTyl7eS5wdXNoKGIoTyx4KyspKX0pKTp2KHUsITEseS5wdXNoLHkpLG5ldyB0aGlzKHkpKX19KX19LGZ1bmN0aW9uKGMsZSx0KXtjLmV4cG9ydHM9e2RlZmF1bHQ6dCgxNjUpLF9fZXNNb2R1bGU6ITB9fSxmdW5jdGlvbihjLGUsdCl7dCgxNjYpLGMuZXhwb3J0cz10KDkyKS5PYmplY3QuYXNzaWdufSxmdW5jdGlvbihjLGUsdCl7dmFyIHI9dCg5MCk7cihyLlMrci5GLCJPYmplY3QiLHthc3NpZ246dCgxNjcpfSl9LGZ1bmN0aW9uKGMsZSx0KXt2YXIgcj10KDEwMCkscz10KDExMCksZz10KDE2OCksdj10KDE2OSksaD10KDEyNCksbD10KDg1KSx1PU9iamVjdC5hc3NpZ247Yy5leHBvcnRzPSF1fHx0KDEwMSkoZnVuY3Rpb24oKXt2YXIgTT17fSxmPXt9LHk9U3ltYm9sKCkseD0iYWJjZGVmZ2hpamtsbW5vcHFyc3QiO3JldHVybiBNW3ldPTcseC5zcGxpdCgiIikuZm9yRWFjaChmdW5jdGlvbihiKXtmW2JdPWJ9KSx1KHt9LE0pW3ldIT03fHxPYmplY3Qua2V5cyh1KHt9LGYpKS5qb2luKCIiKSE9eH0pP2Z1bmN0aW9uKGYseSl7Zm9yKHZhciB4PWgoZiksYj1hcmd1bWVudHMubGVuZ3RoLE89MSxtPWcuZixwPXYuZjtiPk87KWZvcih2YXIgbj1sKGFyZ3VtZW50c1tPKytdKSxhPW0/cyhuKS5jb25jYXQobShuKSk6cyhuKSxpPWEubGVuZ3RoLG89MCxUO2k+bzspVD1hW28rK10sKCFyfHxwLmNhbGwobixUKSkmJih4W1RdPW5bVF0pO3JldHVybiB4fTp1fSxmdW5jdGlvbihjLGUpe2UuZj1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzfSxmdW5jdGlvbihjLGUpe2UuZj17fS5wcm9wZXJ0eUlzRW51bWVyYWJsZX0sZnVuY3Rpb24oYyxlLHQpe2UuX19lc01vZHVsZT0hMCxlLmRlZmF1bHQ9ZnVuY3Rpb24ocixzKXtpZighKHIgaW5zdGFuY2VvZiBzKSl0aHJvdyBuZXcgVHlwZUVycm9yKCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24iKX19LGZ1bmN0aW9uKGMsZSx0KXtlLl9fZXNNb2R1bGU9ITA7dmFyIHI9dCgxNzIpLHM9ZyhyKTtmdW5jdGlvbiBnKHYpe3JldHVybiB2JiZ2Ll9fZXNNb2R1bGU/djp7ZGVmYXVsdDp2fX1lLmRlZmF1bHQ9ZnVuY3Rpb24oKXtmdW5jdGlvbiB2KGgsbCl7Zm9yKHZhciB1PTA7dTxsLmxlbmd0aDt1Kyspe3ZhciBNPWxbdV07TS5lbnVtZXJhYmxlPU0uZW51bWVyYWJsZXx8ITEsTS5jb25maWd1cmFibGU9ITAsInZhbHVlImluIE0mJihNLndyaXRhYmxlPSEwKSwoMCxzLmRlZmF1bHQpKGgsTS5rZXksTSl9fXJldHVybiBmdW5jdGlvbihoLGwsdSl7cmV0dXJuIGwmJnYoaC5wcm90b3R5cGUsbCksdSYmdihoLHUpLGh9fSgpfSxmdW5jdGlvbihjLGUsdCl7Yy5leHBvcnRzPXtkZWZhdWx0OnQoMTczKSxfX2VzTW9kdWxlOiEwfX0sZnVuY3Rpb24oYyxlLHQpe3QoMTc0KTt2YXIgcj10KDkyKS5PYmplY3Q7Yy5leHBvcnRzPWZ1bmN0aW9uKGcsdixoKXtyZXR1cm4gci5kZWZpbmVQcm9wZXJ0eShnLHYsaCl9fSxmdW5jdGlvbihjLGUsdCl7dmFyIHI9dCg5MCk7cihyLlMrci5GKiF0KDEwMCksIk9iamVjdCIse2RlZmluZVByb3BlcnR5OnQoOTYpLmZ9KX0sZnVuY3Rpb24oYyxlLHQpe2MuZXhwb3J0cz17ZGVmYXVsdDp0KDE3NiksX19lc01vZHVsZTohMH19LGZ1bmN0aW9uKGMsZSx0KXt0KDE3NyksdCgxNDMpLHQoMTg0KSx0KDE4NSksYy5leHBvcnRzPXQoOTIpLlN5bWJvbH0sZnVuY3Rpb24oYyxlLHQpe3ZhciByPXQoOTEpLHM9dCgxMDUpLGc9dCgxMDApLHY9dCg5MCksaD10KDEwNiksbD10KDE1MCkuS0VZLHU9dCgxMDEpLE09dCgxMTcpLGY9dCgxMjEpLHk9dCgxMTgpLHg9dCgxMjIpLGI9dCgxNzgpLE89dCgxNzkpLG09dCgxODApLHA9dCgxNTYpLG49dCg5NyksYT10KDk4KSxpPXQoMTI0KSxvPXQoODQpLFQ9dCgxMDMpLFA9dCgxMDQpLEM9dCgxMDgpLEk9dCgxODEpLEE9dCgxODMpLEw9dCgxNjgpLEQ9dCg5NiksUj10KDExMCksUz1BLmYsQj1ELmYsdz1JLmYsSD1yLlN5bWJvbCxKPXIuSlNPTixxPUomJkouc3RyaW5naWZ5LFc9InByb3RvdHlwZSIsRz14KCJfaGlkZGVuIiksUT14KCJ0b1ByaW1pdGl2ZSIpLHR0PXt9LnByb3BlcnR5SXNFbnVtZXJhYmxlLF89TSgic3ltYm9sLXJlZ2lzdHJ5Iiksc3Q9TSgic3ltYm9scyIpLGs9TSgib3Atc3ltYm9scyIpLGN0PU9iamVjdFtXXSxmdD10eXBlb2YgSD09ImZ1bmN0aW9uIiYmISFMLmYsVT1yLlFPYmplY3QsRj0hVXx8IVVbV118fCFVW1ddLmZpbmRDaGlsZCxWPWcmJnUoZnVuY3Rpb24oKXtyZXR1cm4gQyhCKHt9LCJhIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIEIodGhpcywiYSIse3ZhbHVlOjd9KS5hfX0pKS5hIT03fSk/ZnVuY3Rpb24oaXQsbnQsb3Qpe3ZhciBkdD1TKGN0LG50KTtkdCYmZGVsZXRlIGN0W250XSxCKGl0LG50LG90KSxkdCYmaXQhPT1jdCYmQihjdCxudCxkdCl9OkIsWD1mdW5jdGlvbihpdCl7dmFyIG50PXN0W2l0XT1DKEhbV10pO3JldHVybiBudC5faz1pdCxudH0saj1mdCYmdHlwZW9mIEguaXRlcmF0b3I9PSJzeW1ib2wiP2Z1bmN0aW9uKGl0KXtyZXR1cm4gdHlwZW9mIGl0PT0ic3ltYm9sIn06ZnVuY3Rpb24oaXQpe3JldHVybiBpdCBpbnN0YW5jZW9mIEh9LHo9ZnVuY3Rpb24obnQsb3QsZHQpe3JldHVybiBudD09PWN0JiZ6KGssb3QsZHQpLG4obnQpLG90PVQob3QsITApLG4oZHQpLHMoc3Qsb3QpPyhkdC5lbnVtZXJhYmxlPyhzKG50LEcpJiZudFtHXVtvdF0mJihudFtHXVtvdF09ITEpLGR0PUMoZHQse2VudW1lcmFibGU6UCgwLCExKX0pKToocyhudCxHKXx8QihudCxHLFAoMSx7fSkpLG50W0ddW290XT0hMCksVihudCxvdCxkdCkpOkIobnQsb3QsZHQpfSxkPWZ1bmN0aW9uKG50LG90KXtuKG50KTtmb3IodmFyIGR0PW0ob3Q9byhvdCkpLGd0PTAsdXQ9ZHQubGVuZ3RoLG10O3V0Pmd0Oyl6KG50LG10PWR0W2d0KytdLG90W210XSk7cmV0dXJuIG50fSxFPWZ1bmN0aW9uKG50LG90KXtyZXR1cm4gb3Q9PT12b2lkIDA/QyhudCk6ZChDKG50KSxvdCl9LE49ZnVuY3Rpb24obnQpe3ZhciBvdD10dC5jYWxsKHRoaXMsbnQ9VChudCwhMCkpO3JldHVybiB0aGlzPT09Y3QmJnMoc3QsbnQpJiYhcyhrLG50KT8hMTpvdHx8IXModGhpcyxudCl8fCFzKHN0LG50KXx8cyh0aGlzLEcpJiZ0aGlzW0ddW250XT9vdDohMH0sJD1mdW5jdGlvbihudCxvdCl7aWYobnQ9byhudCksb3Q9VChvdCwhMCksIShudD09PWN0JiZzKHN0LG90KSYmIXMoayxvdCkpKXt2YXIgZHQ9UyhudCxvdCk7cmV0dXJuIGR0JiZzKHN0LG90KSYmIShzKG50LEcpJiZudFtHXVtvdF0pJiYoZHQuZW51bWVyYWJsZT0hMCksZHR9fSxLPWZ1bmN0aW9uKG50KXtmb3IodmFyIG90PXcobyhudCkpLGR0PVtdLGd0PTAsdXQ7b3QubGVuZ3RoPmd0OykhcyhzdCx1dD1vdFtndCsrXSkmJnV0IT1HJiZ1dCE9bCYmZHQucHVzaCh1dCk7cmV0dXJuIGR0fSxZPWZ1bmN0aW9uKG50KXtmb3IodmFyIG90PW50PT09Y3QsZHQ9dyhvdD9rOm8obnQpKSxndD1bXSx1dD0wLG10O2R0Lmxlbmd0aD51dDspcyhzdCxtdD1kdFt1dCsrXSkmJighb3R8fHMoY3QsbXQpKSYmZ3QucHVzaChzdFttdF0pO3JldHVybiBndH07ZnR8fChIPWZ1bmN0aW9uKCl7aWYodGhpcyBpbnN0YW5jZW9mIEgpdGhyb3cgVHlwZUVycm9yKCJTeW1ib2wgaXMgbm90IGEgY29uc3RydWN0b3IhIik7dmFyIG50PXkoYXJndW1lbnRzLmxlbmd0aD4wP2FyZ3VtZW50c1swXTp2b2lkIDApLG90PWZ1bmN0aW9uKGR0KXt0aGlzPT09Y3QmJm90LmNhbGwoayxkdCkscyh0aGlzLEcpJiZzKHRoaXNbR10sbnQpJiYodGhpc1tHXVtudF09ITEpLFYodGhpcyxudCxQKDEsZHQpKX07cmV0dXJuIGcmJkYmJlYoY3QsbnQse2NvbmZpZ3VyYWJsZTohMCxzZXQ6b3R9KSxYKG50KX0saChIW1ddLCJ0b1N0cmluZyIsZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fa30pLEEuZj0kLEQuZj16LHQoMTgyKS5mPUkuZj1LLHQoMTY5KS5mPU4sTC5mPVksZyYmIXQoODkpJiZoKGN0LCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsTiwhMCksYi5mPWZ1bmN0aW9uKGl0KXtyZXR1cm4gWCh4KGl0KSl9KSx2KHYuRyt2Llcrdi5GKiFmdCx7U3ltYm9sOkh9KTtmb3IodmFyIFo9Imhhc0luc3RhbmNlLGlzQ29uY2F0U3ByZWFkYWJsZSxpdGVyYXRvcixtYXRjaCxyZXBsYWNlLHNlYXJjaCxzcGVjaWVzLHNwbGl0LHRvUHJpbWl0aXZlLHRvU3RyaW5nVGFnLHVuc2NvcGFibGVzIi5zcGxpdCgiLCIpLGV0PTA7Wi5sZW5ndGg+ZXQ7KXgoWltldCsrXSk7Zm9yKHZhciBydD1SKHguc3RvcmUpLGF0PTA7cnQubGVuZ3RoPmF0OylPKHJ0W2F0KytdKTt2KHYuUyt2LkYqIWZ0LCJTeW1ib2wiLHtmb3I6ZnVuY3Rpb24oaXQpe3JldHVybiBzKF8saXQrPSIiKT9fW2l0XTpfW2l0XT1IKGl0KX0sa2V5Rm9yOmZ1bmN0aW9uKG50KXtpZighaihudCkpdGhyb3cgVHlwZUVycm9yKG50KyIgaXMgbm90IGEgc3ltYm9sISIpO2Zvcih2YXIgb3QgaW4gXylpZihfW290XT09PW50KXJldHVybiBvdH0sdXNlU2V0dGVyOmZ1bmN0aW9uKCl7Rj0hMH0sdXNlU2ltcGxlOmZ1bmN0aW9uKCl7Rj0hMX19KSx2KHYuUyt2LkYqIWZ0LCJPYmplY3QiLHtjcmVhdGU6RSxkZWZpbmVQcm9wZXJ0eTp6LGRlZmluZVByb3BlcnRpZXM6ZCxnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6JCxnZXRPd25Qcm9wZXJ0eU5hbWVzOkssZ2V0T3duUHJvcGVydHlTeW1ib2xzOll9KTt2YXIgbHQ9dShmdW5jdGlvbigpe0wuZigxKX0pO3Yodi5TK3YuRipsdCwiT2JqZWN0Iix7Z2V0T3duUHJvcGVydHlTeW1ib2xzOmZ1bmN0aW9uKG50KXtyZXR1cm4gTC5mKGkobnQpKX19KSxKJiZ2KHYuUyt2LkYqKCFmdHx8dShmdW5jdGlvbigpe3ZhciBpdD1IKCk7cmV0dXJuIHEoW2l0XSkhPSJbbnVsbF0ifHxxKHthOml0fSkhPSJ7fSJ8fHEoT2JqZWN0KGl0KSkhPSJ7fSJ9KSksIkpTT04iLHtzdHJpbmdpZnk6ZnVuY3Rpb24obnQpe2Zvcih2YXIgb3Q9W250XSxkdD0xLGd0LHV0O2FyZ3VtZW50cy5sZW5ndGg+ZHQ7KW90LnB1c2goYXJndW1lbnRzW2R0KytdKTtpZih1dD1ndD1vdFsxXSwhKCFhKGd0KSYmbnQ9PT12b2lkIDB8fGoobnQpKSlyZXR1cm4gcChndCl8fChndD1mdW5jdGlvbihtdCxPdCl7aWYodHlwZW9mIHV0PT0iZnVuY3Rpb24iJiYoT3Q9dXQuY2FsbCh0aGlzLG10LE90KSksIWooT3QpKXJldHVybiBPdH0pLG90WzFdPWd0LHEuYXBwbHkoSixvdCl9fSksSFtXXVtRXXx8dCg5NSkoSFtXXSxRLEhbV10udmFsdWVPZiksZihILCJTeW1ib2wiKSxmKE1hdGgsIk1hdGgiLCEwKSxmKHIuSlNPTiwiSlNPTiIsITApfSxmdW5jdGlvbihjLGUsdCl7ZS5mPXQoMTIyKX0sZnVuY3Rpb24oYyxlLHQpe3ZhciByPXQoOTEpLHM9dCg5MiksZz10KDg5KSx2PXQoMTc4KSxoPXQoOTYpLmY7Yy5leHBvcnRzPWZ1bmN0aW9uKGwpe3ZhciB1PXMuU3ltYm9sfHwocy5TeW1ib2w9Zz97fTpyLlN5bWJvbHx8e30pO2wuY2hhckF0KDApIT0iXyImJiEobCBpbiB1KSYmaCh1LGwse3ZhbHVlOnYuZihsKX0pfX0sZnVuY3Rpb24oYyxlLHQpe3ZhciByPXQoMTEwKSxzPXQoMTY4KSxnPXQoMTY5KTtjLmV4cG9ydHM9ZnVuY3Rpb24odil7dmFyIGg9cih2KSxsPXMuZjtpZihsKWZvcih2YXIgdT1sKHYpLE09Zy5mLGY9MCx5O3UubGVuZ3RoPmY7KU0uY2FsbCh2LHk9dVtmKytdKSYmaC5wdXNoKHkpO3JldHVybiBofX0sZnVuY3Rpb24oYyxlLHQpe3ZhciByPXQoODQpLHM9dCgxODIpLmYsZz17fS50b1N0cmluZyx2PXR5cGVvZiB3aW5kb3c9PSJvYmplY3QiJiZ3aW5kb3cmJk9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzP09iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHdpbmRvdyk6W10saD1mdW5jdGlvbihsKXt0cnl7cmV0dXJuIHMobCl9Y2F0Y2h7cmV0dXJuIHYuc2xpY2UoKX19O2MuZXhwb3J0cy5mPWZ1bmN0aW9uKHUpe3JldHVybiB2JiZnLmNhbGwodSk9PSJbb2JqZWN0IFdpbmRvd10iP2godSk6cyhyKHUpKX19LGZ1bmN0aW9uKGMsZSx0KXt2YXIgcj10KDExMSkscz10KDExOSkuY29uY2F0KCJsZW5ndGgiLCJwcm90b3R5cGUiKTtlLmY9T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXN8fGZ1bmN0aW9uKHYpe3JldHVybiByKHYscyl9fSxmdW5jdGlvbihjLGUsdCl7dmFyIHI9dCgxNjkpLHM9dCgxMDQpLGc9dCg4NCksdj10KDEwMyksaD10KDEwNSksbD10KDk5KSx1PU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7ZS5mPXQoMTAwKT91OmZ1bmN0aW9uKGYseSl7aWYoZj1nKGYpLHk9dih5LCEwKSxsKXRyeXtyZXR1cm4gdShmLHkpfWNhdGNoe31pZihoKGYseSkpcmV0dXJuIHMoIXIuZi5jYWxsKGYseSksZlt5XSl9fSxmdW5jdGlvbihjLGUsdCl7dCgxNzkpKCJhc3luY0l0ZXJhdG9yIil9LGZ1bmN0aW9uKGMsZSx0KXt0KDE3OSkoIm9ic2VydmFibGUiKX0sZnVuY3Rpb24oYyxlLHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxlLmNyZWF0ZU5vd1RpbWU9cixlLmZvcm1hdERlbGF5PXM7ZnVuY3Rpb24gcigpe3ZhciBnPW51bGw7cmV0dXJuIERhdGUubm93P2c9RGF0ZS5ub3c6Zz1mdW5jdGlvbigpe3JldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKX0sZ31mdW5jdGlvbiBzKGcpe3JldHVybiB0eXBlb2YgZz09Im51bWJlciI/Zz17ZGVsYXk6Z306ImVudHJvcHkiaW4gZyYmKGc9e2RlbGF5OmcuZW50cm9weSxpc0VudHJvcHk6ITB9KSxnfX0sZnVuY3Rpb24oYyxlLHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxlLmRlZmF1bHQ9e2RlZmF1bHQ6ZnVuY3Rpb24ocyxnLHYsaCxsKXtyZXR1cm4gdHlwZW9mIHM9PSJudW1iZXIiJiZ0eXBlb2YgZz09Im51bWJlciI/cysodi1oKS8obC1oKSooZy1zKTp2LWg+bC12P2c6c319fSxmdW5jdGlvbihjLGUsdCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLGUucGFyc2VFYXNpbmc9ZS5FYXNpbmdzPXZvaWQgMDt2YXIgcj10KDc2KSxzPXUociksZz10KDEzMyksdj11KGcpLGg9dCgxNDEpLGw9dShoKTtmdW5jdGlvbiB1KHApe3JldHVybiBwJiZwLl9fZXNNb2R1bGU/cDp7ZGVmYXVsdDpwfX12YXIgTT10KDE4OSksZj1uZXcgbC5kZWZhdWx0O2Z1bmN0aW9uIHkoKXtmb3IodmFyIHA9YXJndW1lbnRzLmxlbmd0aCxuPUFycmF5KHApLGE9MDthPHA7YSsrKW5bYV09YXJndW1lbnRzW2FdO3ZhciBpPWYuZ2V0KG4pO3JldHVybiBpfHwoaT1NLmFwcGx5KHZvaWQgMCxuKSxmLnNldChuLGkpLGkpfWZ1bmN0aW9uIHgocCl7dmFyIG49YXJndW1lbnRzLmxlbmd0aD4xJiZhcmd1bWVudHNbMV0hPT12b2lkIDA/YXJndW1lbnRzWzFdOiJlbmQiO3JldHVybiBmdW5jdGlvbihhLGkpe2Zvcih2YXIgbz0xO288aS5sZW5ndGg7bysrKXt2YXIgVD1pW29dLm9mZnNldDtpZihhPD1UKXt2YXIgUD1pW28tMV0ub2Zmc2V0LEM9VCxJPShhLVApLyhDLVApLEE9MS9wLEw9SS9BO3JldHVybiBuPT09ImVuZCI/TD1NYXRoLmZsb29yKEwpOkw9TWF0aC5jZWlsKEwpLEEqTCooQy1QKStQfX1yZXR1cm4gMH19ZnVuY3Rpb24gYihwKXt2YXIgbj0vXmN1YmljLWJlemllclwoKC4qKVwpLyxhPXAubWF0Y2gobik7aWYoYSl7dmFyIGk9YVsxXS50cmltKCk7cmV0dXJuIGk9aS5zcGxpdCgiLCIpLm1hcChmdW5jdGlvbihBKXtyZXR1cm4gcGFyc2VGbG9hdChBLnRyaW0oKSl9KSx5LmFwcGx5KHZvaWQgMCwoMCx2LmRlZmF1bHQpKGkpKX1pZihuPS9ec3RlcHNcKCguKilcKS8sYT1wLm1hdGNoKG4pLGEpe3ZhciBvPWFbMV0udHJpbSgpO289by5zcGxpdCgiLCIpLm1hcChmdW5jdGlvbihBKXtyZXR1cm4gQS50cmltKCl9KTt2YXIgVD1vLFA9KDAscy5kZWZhdWx0KShULDIpLEM9UFswXSxJPVBbMV07cmV0dXJuIHgocGFyc2VJbnQoQywxMCksSSl9cmV0dXJuIHB9dmFyIE89e2xpbmVhcjpmdW5jdGlvbihuKXtyZXR1cm4gbn0sZWFzZTp5KC4yNSwuMSwuMjUsMSksImVhc2UtaW4iOnkoLjQyLDAsMSwxKSwiZWFzZS1vdXQiOnkoMCwwLC41OCwxKSwiZWFzZS1pbi1vdXQiOnkoLjQyLDAsLjU4LDEpLCJzdGVwLXN0YXJ0Ijp4KDEsInN0YXJ0IiksInN0ZXAtZW5kIjp4KDEsImVuZCIpfTtmdW5jdGlvbiBtKHApe3JldHVybiB0eXBlb2YgcD09InN0cmluZyI/T1twXT9wPU9bcF06cD1iKHApOnAudHlwZT09PSJjdWJpYy1iZXppZXIiP3A9eS5hcHBseSh2b2lkIDAsKDAsdi5kZWZhdWx0KShwLnZhbHVlKSk6cC50eXBlPT09InN0ZXBzIiYmKHA9eChwLnN0ZXAscC5wb3MpKSxwfWUuRWFzaW5ncz1PLGUucGFyc2VFYXNpbmc9bX0sZnVuY3Rpb24oYyxlKXt2YXIgdD00LHI9LjAwMSxzPTFlLTcsZz0xMCx2PTExLGg9MS8odi0xKSxsPXR5cGVvZiBGbG9hdDMyQXJyYXk9PSJmdW5jdGlvbiI7ZnVuY3Rpb24gdShwLG4pe3JldHVybiAxLTMqbiszKnB9ZnVuY3Rpb24gTShwLG4pe3JldHVybiAzKm4tNipwfWZ1bmN0aW9uIGYocCl7cmV0dXJuIDMqcH1mdW5jdGlvbiB5KHAsbixhKXtyZXR1cm4oKHUobixhKSpwK00obixhKSkqcCtmKG4pKSpwfWZ1bmN0aW9uIHgocCxuLGEpe3JldHVybiAzKnUobixhKSpwKnArMipNKG4sYSkqcCtmKG4pfWZ1bmN0aW9uIGIocCxuLGEsaSxvKXt2YXIgVCxQLEM9MDtkbyBQPW4rKGEtbikvMixUPXkoUCxpLG8pLXAsVD4wP2E9UDpuPVA7d2hpbGUoTWF0aC5hYnMoVCk+cyYmKytDPGcpO3JldHVybiBQfWZ1bmN0aW9uIE8ocCxuLGEsaSl7Zm9yKHZhciBvPTA7bzx0Oysrbyl7dmFyIFQ9eChuLGEsaSk7aWYoVD09PTApcmV0dXJuIG47dmFyIFA9eShuLGEsaSktcDtuLT1QL1R9cmV0dXJuIG59ZnVuY3Rpb24gbShwKXtyZXR1cm4gcH1jLmV4cG9ydHM9ZnVuY3Rpb24obixhLGksbyl7aWYoISgwPD1uJiZuPD0xJiYwPD1pJiZpPD0xKSl0aHJvdyBuZXcgRXJyb3IoImJlemllciB4IHZhbHVlcyBtdXN0IGJlIGluIFswLCAxXSByYW5nZSIpO2lmKG49PT1hJiZpPT09bylyZXR1cm4gbTtmb3IodmFyIFQ9bD9uZXcgRmxvYXQzMkFycmF5KHYpOm5ldyBBcnJheSh2KSxQPTA7UDx2OysrUClUW1BdPXkoUCpoLG4saSk7ZnVuY3Rpb24gQyhJKXtmb3IodmFyIEE9MCxMPTEsRD12LTE7TCE9PUQmJlRbTF08PUk7KytMKUErPWg7LS1MO3ZhciBSPShJLVRbTF0pLyhUW0wrMV0tVFtMXSksUz1BK1IqaCxCPXgoUyxuLGkpO3JldHVybiBCPj1yP08oSSxTLG4saSk6Qj09PTA/UzpiKEksQSxBK2gsbixpKX1yZXR1cm4gZnVuY3Rpb24oQSl7cmV0dXJuIEE9PT0wPzA6QT09PTE/MTp5KEMoQSksYSxvKX19fSxmdW5jdGlvbihjLGUsdCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pO3ZhciByPXQoMTkxKSxzPWEociksZz10KDIwNCksdj1hKGcpLGg9dCgxNjQpLGw9YShoKSx1PXQoMTcwKSxNPWEodSksZj10KDE3MSkseT1hKGYpLHg9dCgxNzUpLGI9YSh4KSxPPXQoNzUpLG09YShPKSxwPXQoMjA4KSxuPXQoMTg4KTtmdW5jdGlvbiBhKEIpe3JldHVybiBCJiZCLl9fZXNNb2R1bGU/Qjp7ZGVmYXVsdDpCfX12YXIgaT0oMCxiLmRlZmF1bHQpKCJ0aW1pbmciKSxvPSgwLGIuZGVmYXVsdCkoImtleWZyYW1lcyIpLFQ9KDAsYi5kZWZhdWx0KSgiaW5pdFN0YXRlIiksUD0oMCxiLmRlZmF1bHQpKCJyZWFkeURlZmVyIiksQz0oMCxiLmRlZmF1bHQpKCJmaW5pc2hlZERlZmVyIiksST0oMCxiLmRlZmF1bHQpKCJlZmZlY3RzIiksQT0oMCxiLmRlZmF1bHQpKCJhY3RpdmVSZWFkeVRpbWVyIiksTD0oMCxiLmRlZmF1bHQpKCJhY3RpdmVGaW5pc2hUaW1lciIpLEQ9KDAsYi5kZWZhdWx0KSgicmVtb3ZlRGVmZXIiKSxSPXtkZWxheTowLGVuZERlbGF5OjAsZmlsbDoiYXV0byIsaXRlcmF0aW9uczoxLHBsYXliYWNrUmF0ZToxLGRpcmVjdGlvbjoibm9ybWFsIixlYXNpbmc6ImxpbmVhciIsZWZmZWN0Om51bGx9LFM9ZnVuY3Rpb24oKXtmdW5jdGlvbiBCKHcsSCxKKXt2YXIgcT10aGlzO2lmKCgwLE0uZGVmYXVsdCkodGhpcyxCKSxBcnJheS5pc0FycmF5KHcpKXt2YXIgVz1bd1swXSx3LEhdO3c9V1swXSxIPVdbMV0sSj1XWzJdfXR5cGVvZiBKPT0ibnVtYmVyIiYmKEo9e2R1cmF0aW9uOkp9KSx0aGlzW2ldPSgwLGwuZGVmYXVsdCkoe30sUixKKSx0aGlzW2ldLmVhc2luZz0oMCxuLnBhcnNlRWFzaW5nKSh0aGlzW2ldLmVhc2luZyksdGhpc1tvXT0oMCxwLmNhbGN1bGF0ZUZyYW1lc09mZnNldCkoSCk7dmFyIEc9dGhpc1tvXVt0aGlzW29dLmxlbmd0aC0xXTt0aGlzW1RdPXt9LCgwLHYuZGVmYXVsdCkoRykuZm9yRWFjaChmdW5jdGlvbihRKXtPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodyxRKSYmUSE9PSJlYXNpbmciJiZRIT09Im9mZnNldCImJihxW1RdW1FdPXdbUV0pfSksdGhpc1tvXT10aGlzW29dLm1hcChmdW5jdGlvbihRKXtyZXR1cm4oMCxsLmRlZmF1bHQpKHt9LHFbVF0sUSl9KSx0aGlzW29dWzBdLm9mZnNldCE9PTAmJnRoaXNbb10udW5zaGlmdCgoMCxsLmRlZmF1bHQpKHt9LHRoaXNbVF0se29mZnNldDowfSkpLEcub2Zmc2V0PDEmJnRoaXNbb10ucHVzaCgoMCxsLmRlZmF1bHQpKHt9LEcse29mZnNldDoxfSkpLHRoaXNbSV09e30sdGhpcy50aW1lbGluZT1udWxsfXJldHVybigwLHkuZGVmYXVsdCkoQixbe2tleToicGF1c2UiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy50aW1lbGluZS5wbGF5YmFja1JhdGU9MH19LHtrZXk6QSx2YWx1ZTpmdW5jdGlvbigpe3ZhciBIPXRoaXM7dGhpc1tQXSYmIXRoaXNbUF0udGltZXJJRCYmKHRoaXMudGltZWxpbmUuY3VycmVudFRpbWU8MD90aGlzW1BdLnRpbWVySUQ9dGhpcy50aW1lbGluZS5zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7SFtQXS5yZXNvbHZlKCksZGVsZXRlIEhbUF19LHtkZWxheTotdGhpcy50aW1lbGluZS5jdXJyZW50VGltZSxoZWFkaW5nOiExfSk6dGhpc1tQXS50aW1lcklEPXRoaXMudGltZWxpbmUuc2V0VGltZW91dChmdW5jdGlvbigpe0hbUF0ucmVzb2x2ZSgpLGRlbGV0ZSBIW1BdfSx7ZGVsYXk6MCxpc0VudHJvcHk6ITB9KSl9fSx7a2V5OkwsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgSD10aGlzLEo9dGhpc1tpXSxxPUouZHVyYXRpb24sVz1KLml0ZXJhdGlvbnMsRz1KLmVuZERlbGF5LFE9TWF0aC5jZWlsKHEqVytHLXRoaXMudGltZWxpbmUuY3VycmVudFRpbWUpKzE7dGhpc1tDXSYmIXRoaXNbQ10udGltZXJJRCYmKHRoaXNbQ10udGltZXJJRD10aGlzLnRpbWVsaW5lLnNldFRpbWVvdXQoZnVuY3Rpb24oKXtIW0NdLnJlc29sdmUoKSxIW0RdKFApLEhbRF0oQyl9LHtkZWxheTpRLGhlYWRpbmc6ITF9KSx0aGlzW0NdLnJldmVyc2VUaW1lcklEPXRoaXMudGltZWxpbmUuc2V0VGltZW91dChmdW5jdGlvbigpe0hbQ10ucmVzb2x2ZSgpLEhbRF0oUCksSFtEXShDKSxILnRpbWVsaW5lPW51bGx9LHtkZWxheTotdGhpc1tpXS5kZWxheS0xLGhlYWRpbmc6ITF9KSl9fSx7a2V5OiJwbGF5Iix2YWx1ZTpmdW5jdGlvbigpe2lmKHRoaXMucGxheVN0YXRlPT09ImZpbmlzaGVkIiYmdGhpcy5jYW5jZWwoKSx0aGlzLnBsYXlTdGF0ZT09PSJpZGxlIil7aWYodGhpcy5wbGF5YmFja1JhdGU8PTApcmV0dXJuO3ZhciBIPXRoaXNbaV0sSj1ILmRlbGF5LHE9SC5wbGF5YmFja1JhdGUsVz1ILnRpbWVsaW5lO3RoaXMudGltZWxpbmU9bmV3IG0uZGVmYXVsdCh7b3JpZ2luVGltZTpKLHBsYXliYWNrUmF0ZTpxfSxXKSx0aGlzW0FdKCksdGhpc1tMXSgpfWVsc2UgdGhpcy5wbGF5U3RhdGU9PT0icGF1c2VkIiYmKHRoaXMudGltZWxpbmUucGxheWJhY2tSYXRlPXRoaXMucGxheWJhY2tSYXRlLHRoaXNbQV0oKSl9fSx7a2V5OkQsdmFsdWU6ZnVuY3Rpb24oSCl7dmFyIEo9dGhpc1tIXSxxPXRoaXMudGltZWxpbmU7SiYmcSYmKHEuY2xlYXJUaW1lb3V0KEoudGltZXJJRCksSi5yZXZlcnNlVGltZXJJRCYmcS5jbGVhclRpbWVvdXQoSi5yZXZlcnNlVGltZXJJRCkpLGRlbGV0ZSB0aGlzW0hdfX0se2tleToiY2FuY2VsIix2YWx1ZTpmdW5jdGlvbigpe3RoaXNbRF0oUCksdGhpc1tEXShDKSx0aGlzLnRpbWVsaW5lPW51bGx9fSx7a2V5OiJmaW5pc2giLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy50aW1lbGluZSYmKHRoaXMudGltZWxpbmUuY3VycmVudFRpbWU9MS8wL3RoaXMucGxheWJhY2tSYXRlKSx0aGlzW0RdKFApLHRoaXNbRF0oQyl9fSx7a2V5OiJhcHBseUVmZmVjdHMiLHZhbHVlOmZ1bmN0aW9uKEgpe3JldHVybigwLGwuZGVmYXVsdCkodGhpc1tJXSxIKX19LHtrZXk6InBsYXliYWNrUmF0ZSIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXNbaV0ucGxheWJhY2tSYXRlfSxzZXQ6ZnVuY3Rpb24oSCl7dGhpcy50aW1lbGluZSYmKHRoaXMudGltZWxpbmUucGxheWJhY2tSYXRlPUgpLHRoaXNbaV0ucGxheWJhY2tSYXRlPUh9fSx7a2V5OiJwbGF5U3RhdGUiLGdldDpmdW5jdGlvbigpe3ZhciBIPXRoaXMudGltZWxpbmUsSj10aGlzW2ldLHE9Si5pdGVyYXRpb25zLFc9Si5kdXJhdGlvbixHPUouZW5kRGVsYXksUT0icnVubmluZyI7aWYoSD09bnVsbClRPSJpZGxlIjtlbHNlIGlmKEgucGF1c2VkKVE9InBhdXNlZCI7ZWxzZSBpZihILmN1cnJlbnRUaW1lPDApUT0icGVuZGluZyI7ZWxzZXt2YXIgdHQ9SC5jdXJyZW50VGltZS1xKlc7dHQ+MCYmdHQ8Rz9RPSJwZW5kaW5nIjp0dD49RyYmKFE9ImZpbmlzaGVkIil9cmV0dXJuIFF9fSx7a2V5OiJwcm9ncmVzcyIsZ2V0OmZ1bmN0aW9uKCl7aWYoIXRoaXMudGltZWxpbmUpcmV0dXJuIDA7dmFyIEg9dGhpc1tpXSxKPUguZHVyYXRpb24scT1ILml0ZXJhdGlvbnMsVz10aGlzLnRpbWVsaW5lLEc9dGhpcy5wbGF5U3RhdGUsUT12b2lkIDA7aWYoRz09PSJpZGxlIilRPTA7ZWxzZSBpZihHPT09InBhdXNlZCImJlcuY3VycmVudFRpbWU8MClRPTA7ZWxzZSBpZihHPT09InBlbmRpbmciKWlmKFcuY3VycmVudFRpbWU8MClRPTA7ZWxzZXt2YXIgdHQ9Vy5zZWVrTG9jYWxUaW1lKHEqSik7UT0oMCxwLnBlcmlvZGljaXR5KSh0dCxKKVsxXS9KfWVsc2UoRz09PSJydW5uaW5nInx8Rz09PSJwYXVzZWQiKSYmKFE9KDAscC5wZXJpb2RpY2l0eSkoVy5jdXJyZW50VGltZSxKKVsxXS9KKTtyZXR1cm4gRz09PSJmaW5pc2hlZCImJihRPSgwLHAucGVyaW9kaWNpdHkpKHEsMSlbMV0pLFF9fSx7a2V5OiJmcmFtZSIsZ2V0OmZ1bmN0aW9uKCl7dmFyIEg9dGhpcy5wbGF5U3RhdGUsSj10aGlzW1RdLHE9dGhpc1tpXS5maWxsO2lmKEg9PT0iaWRsZSIpcmV0dXJuIEo7dmFyIFc9dGhpcy50aW1lbGluZS5jdXJyZW50VGltZSxHPXRoaXNbb10uc2xpY2UoMCksUT0oMCxwLmdldFByb2dyZXNzKSh0aGlzLnRpbWVsaW5lLHRoaXNbaV0sdGhpcy5wcm9ncmVzcyksdHQ9US5wLF89US5pbnZlcnRlZCxzdD1KO3JldHVybiBXPDAmJkg9PT0icGVuZGluZyI/KHE9PT0iYmFja3dhcmRzInx8cT09PSJib3RoIikmJihzdD1fP0dbRy5sZW5ndGgtMV06R1swXSk6KEghPT0icGVuZGluZyImJkghPT0iZmluaXNoZWQifHxxPT09ImZvcndhcmRzInx8cT09PSJib3RoIikmJihzdD0oMCxwLmdldEN1cnJlbnRGcmFtZSkodGhpc1tpXSxHLHRoaXNbSV0sdHQpKSxzdH19LHtrZXk6InRpbWluZyIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXNbaV19fSx7a2V5OiJlZmZlY3RzIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc1tJXX19LHtrZXk6ImJhc2VUaW1lbGluZSIsc2V0OmZ1bmN0aW9uKEgpe3RoaXNbaV0udGltZWxpbmU9SH0sZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXNbaV0udGltZWxpbmV9fSx7a2V5OiJyZWFkeSIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXNbUF0/dGhpc1tQXS5wcm9taXNlOnRoaXMudGltZWxpbmUmJnRoaXMudGltZWxpbmUuY3VycmVudFRpbWU+PTAmJnRoaXMucGxheVN0YXRlIT09InBhdXNlZCI/cy5kZWZhdWx0LnJlc29sdmUoKToodGhpc1tQXT0oMCxwLmRlZmVyKSgpLHRoaXMudGltZWxpbmUmJnRoaXNbQV0oKSx0aGlzW1BdP3RoaXNbUF0ucHJvbWlzZTpzLmRlZmF1bHQucmVzb2x2ZSgpKX19LHtrZXk6ImZpbmlzaGVkIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wbGF5U3RhdGU9PT0iZmluaXNoZWQiP3MuZGVmYXVsdC5yZXNvbHZlKCk6KHRoaXNbQ118fCh0aGlzW0NdPSgwLHAuZGVmZXIpKCksdGhpcy50aW1lbGluZSYmdGhpc1tMXSgpKSx0aGlzW0NdLnByb21pc2UpfX1dKSxCfSgpO2UuZGVmYXVsdD1TfSxmdW5jdGlvbihjLGUsdCl7Yy5leHBvcnRzPXtkZWZhdWx0OnQoMTkyKSxfX2VzTW9kdWxlOiEwfX0sZnVuY3Rpb24oYyxlLHQpe3QoMTQzKSx0KDEyNSksdCg3OSksdCgxOTMpLHQoMjAyKSx0KDIwMyksYy5leHBvcnRzPXQoOTIpLlByb21pc2V9LGZ1bmN0aW9uKGMsZSx0KXt2YXIgcj10KDg5KSxzPXQoOTEpLGc9dCg5Myksdj10KDEyOCksaD10KDkwKSxsPXQoOTgpLHU9dCg5NCksTT10KDE0NyksZj10KDE0OCkseT10KDE5NCkseD10KDE5NSkuc2V0LGI9dCgxOTcpKCksTz10KDE5OCksbT10KDE5OSkscD10KDIwMCksbj10KDIwMSksYT0iUHJvbWlzZSIsaT1zLlR5cGVFcnJvcixvPXMucHJvY2VzcyxUPW8mJm8udmVyc2lvbnMsUD1UJiZULnY4fHwiIixDPXNbYV0sST12KG8pPT0icHJvY2VzcyIsQT1mdW5jdGlvbigpe30sTCxELFIsUyxCPUQ9Ty5mLHc9ISFmdW5jdGlvbigpe3RyeXt2YXIgXz1DLnJlc29sdmUoMSksc3Q9KF8uY29uc3RydWN0b3I9e30pW3QoMTIyKSgic3BlY2llcyIpXT1mdW5jdGlvbihrKXtrKEEsQSl9O3JldHVybihJfHx0eXBlb2YgUHJvbWlzZVJlamVjdGlvbkV2ZW50PT0iZnVuY3Rpb24iKSYmXy50aGVuKEEpaW5zdGFuY2VvZiBzdCYmUC5pbmRleE9mKCI2LjYiKSE9PTAmJnAuaW5kZXhPZigiQ2hyb21lLzY2Iik9PT0tMX1jYXRjaHt9fSgpLEg9ZnVuY3Rpb24oXyl7dmFyIHN0O3JldHVybiBsKF8pJiZ0eXBlb2Yoc3Q9Xy50aGVuKT09ImZ1bmN0aW9uIj9zdDohMX0sSj1mdW5jdGlvbihfLHN0KXtpZighXy5fbil7Xy5fbj0hMDt2YXIgaz1fLl9jO2IoZnVuY3Rpb24oKXtmb3IodmFyIGN0PV8uX3YsZnQ9Xy5fcz09MSxVPTAsRj1mdW5jdGlvbihWKXt2YXIgWD1mdD9WLm9rOlYuZmFpbCxqPVYucmVzb2x2ZSx6PVYucmVqZWN0LGQ9Vi5kb21haW4sRSxOLCQ7dHJ5e1g/KGZ0fHwoXy5faD09MiYmRyhfKSxfLl9oPTEpLFg9PT0hMD9FPWN0OihkJiZkLmVudGVyKCksRT1YKGN0KSxkJiYoZC5leGl0KCksJD0hMCkpLEU9PT1WLnByb21pc2U/eihpKCJQcm9taXNlLWNoYWluIGN5Y2xlIikpOihOPUgoRSkpP04uY2FsbChFLGoseik6aihFKSk6eihjdCl9Y2F0Y2goSyl7ZCYmISQmJmQuZXhpdCgpLHooSyl9fTtrLmxlbmd0aD5VOylGKGtbVSsrXSk7Xy5fYz1bXSxfLl9uPSExLHN0JiYhXy5faCYmcShfKX0pfX0scT1mdW5jdGlvbihfKXt4LmNhbGwocyxmdW5jdGlvbigpe3ZhciBzdD1fLl92LGs9VyhfKSxjdCxmdCxVO2lmKGsmJihjdD1tKGZ1bmN0aW9uKCl7ST9vLmVtaXQoInVuaGFuZGxlZFJlamVjdGlvbiIsc3QsXyk6KGZ0PXMub251bmhhbmRsZWRyZWplY3Rpb24pP2Z0KHtwcm9taXNlOl8scmVhc29uOnN0fSk6KFU9cy5jb25zb2xlKSYmVS5lcnJvciYmVS5lcnJvcigiVW5oYW5kbGVkIHByb21pc2UgcmVqZWN0aW9uIixzdCl9KSxfLl9oPUl8fFcoXyk/MjoxKSxfLl9hPXZvaWQgMCxrJiZjdC5lKXRocm93IGN0LnZ9KX0sVz1mdW5jdGlvbihfKXtyZXR1cm4gXy5faCE9PTEmJihfLl9hfHxfLl9jKS5sZW5ndGg9PT0wfSxHPWZ1bmN0aW9uKF8pe3guY2FsbChzLGZ1bmN0aW9uKCl7dmFyIHN0O0k/by5lbWl0KCJyZWplY3Rpb25IYW5kbGVkIixfKTooc3Q9cy5vbnJlamVjdGlvbmhhbmRsZWQpJiZzdCh7cHJvbWlzZTpfLHJlYXNvbjpfLl92fSl9KX0sUT1mdW5jdGlvbihfKXt2YXIgc3Q9dGhpcztzdC5fZHx8KHN0Ll9kPSEwLHN0PXN0Ll93fHxzdCxzdC5fdj1fLHN0Ll9zPTIsc3QuX2F8fChzdC5fYT1zdC5fYy5zbGljZSgpKSxKKHN0LCEwKSl9LHR0PWZ1bmN0aW9uKF8pe3ZhciBzdD10aGlzLGs7aWYoIXN0Ll9kKXtzdC5fZD0hMCxzdD1zdC5fd3x8c3Q7dHJ5e2lmKHN0PT09Xyl0aHJvdyBpKCJQcm9taXNlIGNhbid0IGJlIHJlc29sdmVkIGl0c2VsZiIpOyhrPUgoXykpP2IoZnVuY3Rpb24oKXt2YXIgY3Q9e193OnN0LF9kOiExfTt0cnl7ay5jYWxsKF8sZyh0dCxjdCwxKSxnKFEsY3QsMSkpfWNhdGNoKGZ0KXtRLmNhbGwoY3QsZnQpfX0pOihzdC5fdj1fLHN0Ll9zPTEsSihzdCwhMSkpfWNhdGNoKGN0KXtRLmNhbGwoe193OnN0LF9kOiExfSxjdCl9fX07d3x8KEM9ZnVuY3Rpb24oc3Qpe00odGhpcyxDLGEsIl9oIiksdShzdCksTC5jYWxsKHRoaXMpO3RyeXtzdChnKHR0LHRoaXMsMSksZyhRLHRoaXMsMSkpfWNhdGNoKGspe1EuY2FsbCh0aGlzLGspfX0sTD1mdW5jdGlvbihzdCl7dGhpcy5fYz1bXSx0aGlzLl9hPXZvaWQgMCx0aGlzLl9zPTAsdGhpcy5fZD0hMSx0aGlzLl92PXZvaWQgMCx0aGlzLl9oPTAsdGhpcy5fbj0hMX0sTC5wcm90b3R5cGU9dCgxNDYpKEMucHJvdG90eXBlLHt0aGVuOmZ1bmN0aW9uKHN0LGspe3ZhciBjdD1CKHkodGhpcyxDKSk7cmV0dXJuIGN0Lm9rPXR5cGVvZiBzdD09ImZ1bmN0aW9uIj9zdDohMCxjdC5mYWlsPXR5cGVvZiBrPT0iZnVuY3Rpb24iJiZrLGN0LmRvbWFpbj1JP28uZG9tYWluOnZvaWQgMCx0aGlzLl9jLnB1c2goY3QpLHRoaXMuX2EmJnRoaXMuX2EucHVzaChjdCksdGhpcy5fcyYmSih0aGlzLCExKSxjdC5wcm9taXNlfSxjYXRjaDpmdW5jdGlvbihfKXtyZXR1cm4gdGhpcy50aGVuKHZvaWQgMCxfKX19KSxSPWZ1bmN0aW9uKCl7dmFyIF89bmV3IEw7dGhpcy5wcm9taXNlPV8sdGhpcy5yZXNvbHZlPWcodHQsXywxKSx0aGlzLnJlamVjdD1nKFEsXywxKX0sTy5mPUI9ZnVuY3Rpb24oXyl7cmV0dXJuIF89PT1DfHxfPT09Uz9uZXcgUihfKTpEKF8pfSksaChoLkcraC5XK2guRiohdyx7UHJvbWlzZTpDfSksdCgxMjEpKEMsYSksdCgxNDkpKGEpLFM9dCg5MilbYV0saChoLlMraC5GKiF3LGEse3JlamVjdDpmdW5jdGlvbihzdCl7dmFyIGs9Qih0aGlzKSxjdD1rLnJlamVjdDtyZXR1cm4gY3Qoc3QpLGsucHJvbWlzZX19KSxoKGguUytoLkYqKHJ8fCF3KSxhLHtyZXNvbHZlOmZ1bmN0aW9uKHN0KXtyZXR1cm4gbihyJiZ0aGlzPT09Uz9DOnRoaXMsc3QpfX0pLGgoaC5TK2guRiohKHcmJnQoMTQwKShmdW5jdGlvbihfKXtDLmFsbChfKS5jYXRjaChBKX0pKSxhLHthbGw6ZnVuY3Rpb24oc3Qpe3ZhciBrPXRoaXMsY3Q9QihrKSxmdD1jdC5yZXNvbHZlLFU9Y3QucmVqZWN0LEY9bShmdW5jdGlvbigpe3ZhciBWPVtdLFg9MCxqPTE7ZihzdCwhMSxmdW5jdGlvbih6KXt2YXIgZD1YKyssRT0hMTtWLnB1c2godm9pZCAwKSxqKyssay5yZXNvbHZlKHopLnRoZW4oZnVuY3Rpb24oTil7RXx8KEU9ITAsVltkXT1OLC0tanx8ZnQoVikpfSxVKX0pLC0tanx8ZnQoVil9KTtyZXR1cm4gRi5lJiZVKEYudiksY3QucHJvbWlzZX0scmFjZTpmdW5jdGlvbihzdCl7dmFyIGs9dGhpcyxjdD1CKGspLGZ0PWN0LnJlamVjdCxVPW0oZnVuY3Rpb24oKXtmKHN0LCExLGZ1bmN0aW9uKEYpe2sucmVzb2x2ZShGKS50aGVuKGN0LnJlc29sdmUsZnQpfSl9KTtyZXR1cm4gVS5lJiZmdChVLnYpLGN0LnByb21pc2V9fSl9LGZ1bmN0aW9uKGMsZSx0KXt2YXIgcj10KDk3KSxzPXQoOTQpLGc9dCgxMjIpKCJzcGVjaWVzIik7Yy5leHBvcnRzPWZ1bmN0aW9uKHYsaCl7dmFyIGw9cih2KS5jb25zdHJ1Y3Rvcix1O3JldHVybiBsPT09dm9pZCAwfHwodT1yKGwpW2ddKT09bnVsbD9oOnModSl9fSxmdW5jdGlvbihjLGUsdCl7dmFyIHI9dCg5Mykscz10KDE5NiksZz10KDEyMCksdj10KDEwMiksaD10KDkxKSxsPWgucHJvY2Vzcyx1PWguc2V0SW1tZWRpYXRlLE09aC5jbGVhckltbWVkaWF0ZSxmPWguTWVzc2FnZUNoYW5uZWwseT1oLkRpc3BhdGNoLHg9MCxiPXt9LE89Im9ucmVhZHlzdGF0ZWNoYW5nZSIsbSxwLG4sYT1mdW5jdGlvbigpe3ZhciBvPSt0aGlzO2lmKGIuaGFzT3duUHJvcGVydHkobykpe3ZhciBUPWJbb107ZGVsZXRlIGJbb10sVCgpfX0saT1mdW5jdGlvbihvKXthLmNhbGwoby5kYXRhKX07KCF1fHwhTSkmJih1PWZ1bmN0aW9uKFQpe2Zvcih2YXIgUD1bXSxDPTE7YXJndW1lbnRzLmxlbmd0aD5DOylQLnB1c2goYXJndW1lbnRzW0MrK10pO3JldHVybiBiWysreF09ZnVuY3Rpb24oKXtzKHR5cGVvZiBUPT0iZnVuY3Rpb24iP1Q6RnVuY3Rpb24oVCksUCl9LG0oeCkseH0sTT1mdW5jdGlvbihUKXtkZWxldGUgYltUXX0sdCg4NikobCk9PSJwcm9jZXNzIj9tPWZ1bmN0aW9uKG8pe2wubmV4dFRpY2socihhLG8sMSkpfTp5JiZ5Lm5vdz9tPWZ1bmN0aW9uKG8pe3kubm93KHIoYSxvLDEpKX06Zj8ocD1uZXcgZixuPXAucG9ydDIscC5wb3J0MS5vbm1lc3NhZ2U9aSxtPXIobi5wb3N0TWVzc2FnZSxuLDEpKTpoLmFkZEV2ZW50TGlzdGVuZXImJnR5cGVvZiBwb3N0TWVzc2FnZT09ImZ1bmN0aW9uIiYmIWguaW1wb3J0U2NyaXB0cz8obT1mdW5jdGlvbihvKXtoLnBvc3RNZXNzYWdlKG8rIiIsIioiKX0saC5hZGRFdmVudExpc3RlbmVyKCJtZXNzYWdlIixpLCExKSk6TyBpbiB2KCJzY3JpcHQiKT9tPWZ1bmN0aW9uKG8pe2cuYXBwZW5kQ2hpbGQodigic2NyaXB0IikpW09dPWZ1bmN0aW9uKCl7Zy5yZW1vdmVDaGlsZCh0aGlzKSxhLmNhbGwobyl9fTptPWZ1bmN0aW9uKG8pe3NldFRpbWVvdXQocihhLG8sMSksMCl9KSxjLmV4cG9ydHM9e3NldDp1LGNsZWFyOk19fSxmdW5jdGlvbihjLGUpe2MuZXhwb3J0cz1mdW5jdGlvbih0LHIscyl7dmFyIGc9cz09PXZvaWQgMDtzd2l0Y2goci5sZW5ndGgpe2Nhc2UgMDpyZXR1cm4gZz90KCk6dC5jYWxsKHMpO2Nhc2UgMTpyZXR1cm4gZz90KHJbMF0pOnQuY2FsbChzLHJbMF0pO2Nhc2UgMjpyZXR1cm4gZz90KHJbMF0sclsxXSk6dC5jYWxsKHMsclswXSxyWzFdKTtjYXNlIDM6cmV0dXJuIGc/dChyWzBdLHJbMV0sclsyXSk6dC5jYWxsKHMsclswXSxyWzFdLHJbMl0pO2Nhc2UgNDpyZXR1cm4gZz90KHJbMF0sclsxXSxyWzJdLHJbM10pOnQuY2FsbChzLHJbMF0sclsxXSxyWzJdLHJbM10pfXJldHVybiB0LmFwcGx5KHMscil9fSxmdW5jdGlvbihjLGUsdCl7dmFyIHI9dCg5MSkscz10KDE5NSkuc2V0LGc9ci5NdXRhdGlvbk9ic2VydmVyfHxyLldlYktpdE11dGF0aW9uT2JzZXJ2ZXIsdj1yLnByb2Nlc3MsaD1yLlByb21pc2UsbD10KDg2KSh2KT09InByb2Nlc3MiO2MuZXhwb3J0cz1mdW5jdGlvbigpe3ZhciB1LE0sZix5PWZ1bmN0aW9uKCl7dmFyIG0scDtmb3IobCYmKG09di5kb21haW4pJiZtLmV4aXQoKTt1Oyl7cD11LmZuLHU9dS5uZXh0O3RyeXtwKCl9Y2F0Y2gobil7dGhyb3cgdT9mKCk6TT12b2lkIDAsbn19TT12b2lkIDAsbSYmbS5lbnRlcigpfTtpZihsKWY9ZnVuY3Rpb24oKXt2Lm5leHRUaWNrKHkpfTtlbHNlIGlmKGcmJiEoci5uYXZpZ2F0b3ImJnIubmF2aWdhdG9yLnN0YW5kYWxvbmUpKXt2YXIgeD0hMCxiPWRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCIiKTtuZXcgZyh5KS5vYnNlcnZlKGIse2NoYXJhY3RlckRhdGE6ITB9KSxmPWZ1bmN0aW9uKCl7Yi5kYXRhPXg9IXh9fWVsc2UgaWYoaCYmaC5yZXNvbHZlKXt2YXIgTz1oLnJlc29sdmUodm9pZCAwKTtmPWZ1bmN0aW9uKCl7Ty50aGVuKHkpfX1lbHNlIGY9ZnVuY3Rpb24oKXtzLmNhbGwocix5KX07cmV0dXJuIGZ1bmN0aW9uKG0pe3ZhciBwPXtmbjptLG5leHQ6dm9pZCAwfTtNJiYoTS5uZXh0PXApLHV8fCh1PXAsZigpKSxNPXB9fX0sZnVuY3Rpb24oYyxlLHQpe3ZhciByPXQoOTQpO2Z1bmN0aW9uIHMoZyl7dmFyIHYsaDt0aGlzLnByb21pc2U9bmV3IGcoZnVuY3Rpb24obCx1KXtpZih2IT09dm9pZCAwfHxoIT09dm9pZCAwKXRocm93IFR5cGVFcnJvcigiQmFkIFByb21pc2UgY29uc3RydWN0b3IiKTt2PWwsaD11fSksdGhpcy5yZXNvbHZlPXIodiksdGhpcy5yZWplY3Q9cihoKX1jLmV4cG9ydHMuZj1mdW5jdGlvbihnKXtyZXR1cm4gbmV3IHMoZyl9fSxmdW5jdGlvbihjLGUpe2MuZXhwb3J0cz1mdW5jdGlvbih0KXt0cnl7cmV0dXJue2U6ITEsdjp0KCl9fWNhdGNoKHIpe3JldHVybntlOiEwLHY6cn19fX0sZnVuY3Rpb24oYyxlLHQpe3ZhciByPXQoOTEpLHM9ci5uYXZpZ2F0b3I7Yy5leHBvcnRzPXMmJnMudXNlckFnZW50fHwiIn0sZnVuY3Rpb24oYyxlLHQpe3ZhciByPXQoOTcpLHM9dCg5OCksZz10KDE5OCk7Yy5leHBvcnRzPWZ1bmN0aW9uKHYsaCl7aWYocih2KSxzKGgpJiZoLmNvbnN0cnVjdG9yPT09dilyZXR1cm4gaDt2YXIgbD1nLmYodiksdT1sLnJlc29sdmU7cmV0dXJuIHUoaCksbC5wcm9taXNlfX0sZnVuY3Rpb24oYyxlLHQpe3ZhciByPXQoOTApLHM9dCg5MiksZz10KDkxKSx2PXQoMTk0KSxoPXQoMjAxKTtyKHIuUCtyLlIsIlByb21pc2UiLHtmaW5hbGx5OmZ1bmN0aW9uKGwpe3ZhciB1PXYodGhpcyxzLlByb21pc2V8fGcuUHJvbWlzZSksTT10eXBlb2YgbD09ImZ1bmN0aW9uIjtyZXR1cm4gdGhpcy50aGVuKE0/ZnVuY3Rpb24oZil7cmV0dXJuIGgodSxsKCkpLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gZn0pfTpsLE0/ZnVuY3Rpb24oZil7cmV0dXJuIGgodSxsKCkpLnRoZW4oZnVuY3Rpb24oKXt0aHJvdyBmfSl9OmwpfX0pfSxmdW5jdGlvbihjLGUsdCl7dmFyIHI9dCg5MCkscz10KDE5OCksZz10KDE5OSk7cihyLlMsIlByb21pc2UiLHt0cnk6ZnVuY3Rpb24odil7dmFyIGg9cy5mKHRoaXMpLGw9Zyh2KTtyZXR1cm4obC5lP2gucmVqZWN0OmgucmVzb2x2ZSkobC52KSxoLnByb21pc2V9fSl9LGZ1bmN0aW9uKGMsZSx0KXtjLmV4cG9ydHM9e2RlZmF1bHQ6dCgyMDUpLF9fZXNNb2R1bGU6ITB9fSxmdW5jdGlvbihjLGUsdCl7dCgyMDYpLGMuZXhwb3J0cz10KDkyKS5PYmplY3Qua2V5c30sZnVuY3Rpb24oYyxlLHQpe3ZhciByPXQoMTI0KSxzPXQoMTEwKTt0KDIwNykoImtleXMiLGZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKHYpe3JldHVybiBzKHIodikpfX0pfSxmdW5jdGlvbihjLGUsdCl7dmFyIHI9dCg5MCkscz10KDkyKSxnPXQoMTAxKTtjLmV4cG9ydHM9ZnVuY3Rpb24odixoKXt2YXIgbD0ocy5PYmplY3R8fHt9KVt2XXx8T2JqZWN0W3ZdLHU9e307dVt2XT1oKGwpLHIoci5TK3IuRipnKGZ1bmN0aW9uKCl7bCgxKX0pLCJPYmplY3QiLHUpfX0sZnVuY3Rpb24oYyxlLHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KTt2YXIgcj10KDc2KSxzPWIociksZz10KDIwOSksdj1iKGcpLGg9dCgxNjQpLGw9YihoKSx1PXQoMTkxKSxNPWIodSk7ZS5kZWZlcj1PLGUucGVyaW9kaWNpdHk9bSxlLmNhbGN1bGF0ZUZyYW1lc09mZnNldD1wLGUuZ2V0UHJvZ3Jlc3M9bixlLmdldEN1cnJlbnRGcmFtZT1pO3ZhciBmPXQoMTg4KSx5PXQoMTg3KSx4PWIoeSk7ZnVuY3Rpb24gYihvKXtyZXR1cm4gbyYmby5fX2VzTW9kdWxlP286e2RlZmF1bHQ6b319ZnVuY3Rpb24gTygpe3ZhciBvPXt9O3JldHVybiBvLnByb21pc2U9bmV3IE0uZGVmYXVsdChmdW5jdGlvbihULFApe28ucmVzb2x2ZT1ULG8ucmVqZWN0PVB9KSxvfWZ1bmN0aW9uIG0obyxUKXt2YXIgUD1NYXRoLmZsb29yKG8vVCksQz1vLVAqVDtyZXR1cm4gQz09PTAmJlA+MCYmKEM9VCxQLS0pLFtQLENdfWZ1bmN0aW9uIHAobyl7bz1vLnNsaWNlKDApO3ZhciBUPW9bMF0sUD1vW28ubGVuZ3RoLTFdO1Aub2Zmc2V0PVAub2Zmc2V0fHwxLFQub2Zmc2V0PVQub2Zmc2V0fHwwO2Zvcih2YXIgQz0wLEk9LTEsQT0wO0E8by5sZW5ndGg7QSsrKXt2YXIgTD1vW0FdO2lmKEwub2Zmc2V0IT1udWxsKXt2YXIgRD1BLUk7aWYoRD4xKWZvcih2YXIgUj0oTC5vZmZzZXQtQykvRCxTPTA7UzxELTE7UysrKW9bSStTKzFdLm9mZnNldD1DK1IqKFMrMSk7Qz1MLm9mZnNldCxJPUF9aWYoTC5lYXNpbmchPW51bGwmJihMLmVhc2luZz0oMCxmLnBhcnNlRWFzaW5nKShMLmVhc2luZykpLEE+MCl7dmFyIEI9b1tBXS5lYXNpbmchPW51bGw7b1tBXT0oMCxsLmRlZmF1bHQpKHt9LG9bQS0xXSxvW0FdKSxCfHxkZWxldGUgb1tBXS5lYXNpbmd9fXJldHVybiBvfWZ1bmN0aW9uIG4obyxULFApe3ZhciBDPW8uY3VycmVudFRpbWUsST1ULmRpcmVjdGlvbixBPVQuZHVyYXRpb24sTD0hMTtpZihJPT09InJldmVyc2UiKVA9MS1QLEw9ITA7ZWxzZSBpZihJPT09ImFsdGVybmF0ZSJ8fEk9PT0iYWx0ZXJuYXRlLXJldmVyc2UiKXt2YXIgRD1NYXRoLmZsb29yKEMvQSk7UD09PTEmJkQtLSxEJTJeST09PSJhbHRlcm5hdGUtcmV2ZXJzZSImJihQPTEtUCxMPSEwKX1yZXR1cm57cDpQLGludmVydGVkOkx9fWZ1bmN0aW9uIGEobyxULFAsQyl7dmFyIEk9e307cmV0dXJuKDAsdi5kZWZhdWx0KShUKS5mb3JFYWNoKGZ1bmN0aW9uKEEpe3ZhciBMPSgwLHMuZGVmYXVsdCkoQSwyKSxEPUxbMF0sUj1MWzFdO2lmKEQhPT0ib2Zmc2V0IiYmRCE9PSJlYXNpbmciKXt2YXIgUz1QW0RdfHxQLmRlZmF1bHQsQj1TKG9bRF0sUixDLG8ub2Zmc2V0LFQub2Zmc2V0KTtCIT1udWxsJiYoSVtEXT1CKX19KSxJfWZ1bmN0aW9uIGkobyxULFAsQyl7dmFyIEk9by5lYXNpbmcsQT1vLmVmZmVjdDtBfHwoUD0oMCxsLmRlZmF1bHQpKHt9LHguZGVmYXVsdCxQKSk7dmFyIEw9e307Qz1JKEMsVCk7Zm9yKHZhciBEPTE7RDxULmxlbmd0aDtEKyspe3ZhciBSPVRbRF0sUz1SLm9mZnNldDtpZihTPj1DfHxEPT09VC5sZW5ndGgtMSl7dmFyIEI9VFtELTFdLHc9Qi5vZmZzZXQsSD1CLmVhc2luZyxKPUM7aWYoSCl7dmFyIHE9Uy13O0o9SCgoQy13KS9xKSpxK3d9QT9MPUEoQixSLEosdyxTKTpMPWEoQixSLFAsSik7YnJlYWt9fXJldHVybiBMfX0sZnVuY3Rpb24oYyxlLHQpe2MuZXhwb3J0cz17ZGVmYXVsdDp0KDIxMCksX19lc01vZHVsZTohMH19LGZ1bmN0aW9uKGMsZSx0KXt0KDIxMSksYy5leHBvcnRzPXQoOTIpLk9iamVjdC5lbnRyaWVzfSxmdW5jdGlvbihjLGUsdCl7dmFyIHI9dCg5MCkscz10KDIxMikoITApO3Ioci5TLCJPYmplY3QiLHtlbnRyaWVzOmZ1bmN0aW9uKHYpe3JldHVybiBzKHYpfX0pfSxmdW5jdGlvbihjLGUsdCl7dmFyIHI9dCgxMDApLHM9dCgxMTApLGc9dCg4NCksdj10KDE2OSkuZjtjLmV4cG9ydHM9ZnVuY3Rpb24oaCl7cmV0dXJuIGZ1bmN0aW9uKGwpe2Zvcih2YXIgdT1nKGwpLE09cyh1KSxmPU0ubGVuZ3RoLHk9MCx4PVtdLGI7Zj55OyliPU1beSsrXSwoIXJ8fHYuY2FsbCh1LGIpKSYmeC5wdXNoKGg/W2IsdVtiXV06dVtiXSk7cmV0dXJuIHh9fX0sZnVuY3Rpb24oYyxlLHQpe3QucihlKSx0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3Qgcj1uZXcgTWFwO2Z1bmN0aW9uIHModixoPXt9LGw9W10pe3Y9di50b0xvd2VyQ2FzZSgpO2NvbnN0IHU9ci5nZXQodik7aWYoIXUpdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBub2RlOiAke3Z9YCk7Y29uc3QgTT1uZXcgdShoKTtyZXR1cm4gbC5mb3JFYWNoKGY9PntNLmFwcGVuZENoaWxkKGYpfSksTX1jb25zdCBnPXtyZWdpc3Rlck5vZGUodixoLGw9MTAwKXtpZihoPWgudG9Mb3dlckNhc2UoKSxyLmhhcyhoKSl0aHJvdyBuZXcgVHlwZUVycm9yKGBDYW5ub3QgcmVnaXN0ZXJOb2RlLCAke2h9IGhhcyBiZWVuIHRha2VuLmApO3Iuc2V0KGgsdiksT2JqZWN0LmRlZmluZVByb3BlcnRpZXModi5wcm90b3R5cGUse25vZGVUeXBlOnt2YWx1ZTpsfSx0YWdOYW1lOnt2YWx1ZTpoLnRvVXBwZXJDYXNlKCl9LG5vZGVOYW1lOnt2YWx1ZTpofSxvd25lckRvY3VtZW50Ont2YWx1ZTpnfSxuYW1lc3BhY2VVUkk6e3ZhbHVlOmBodHRwOi8vc3ByaXRlanMuY29tLyR7aH1gfX0pfSxjcmVhdGVFbGVtZW50OnMsY3JlYXRlRWxlbWVudE5TKHYsaCl7cmV0dXJuIHMoaCl9LGlzU3ByaXRlTm9kZSh2KXtyZXR1cm4gci5oYXModi50b0xvd2VyQ2FzZSgpKX19O2UuZGVmYXVsdD1nfSxmdW5jdGlvbihjLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBofSksdCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IHI9U3ltYm9sKCJ0eXBlIikscz1TeW1ib2woImJ1YmJsZXMiKSxnPVN5bWJvbCgib3JpZ2luYWxFdmVudCIpLHY9U3ltYm9sKCJkZXRhaWwiKTtjbGFzcyBoe2NvbnN0cnVjdG9yKHUse2J1YmJsZXM6TT1udWxsfT17fSl7aWYodHlwZW9mIHU9PSJzdHJpbmciPyh0aGlzW3JdPXUsdGhpc1tzXT0hIU0pOih0aGlzW3JdPXUudHlwZSx0aGlzW2ddPXUsdGhpc1tzXT1NIT1udWxsPyEhTTohIXUuYnViYmxlcyx1LmRldGFpbCYmKHRoaXNbdl09dS5kZXRhaWwpKSwhdGhpc1tyXSl0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIGV2ZW50IHR5cGUuIik7dGhpcy5jYW5jZWxCdWJibGU9ITF9c2V0T3JpZ2luYWxFdmVudCh1KXt0aGlzW2ddPXV9Z2V0IG9yaWdpbmFsRXZlbnQoKXtyZXR1cm4gdGhpc1tnXX1nZXQgdHlwZSgpe3JldHVybiB0aGlzW3JdfWdldCBidWJibGVzKCl7cmV0dXJuIHRoaXNbc119Z2V0IGRldGFpbCgpe3JldHVybiB0aGlzW3ZdfXN0b3BQcm9wYWdhdGlvbigpe3RoaXMuY2FuY2VsQnViYmxlPSEwfX19LGZ1bmN0aW9uKGMsZSx0KXt0LnIoZSksdC5kKGUsInBhcnNlRmlsdGVyU3RyaW5nIixmdW5jdGlvbigpe3JldHVybiBzfSksdC5kKGUsImFwcGx5RmlsdGVycyIsZnVuY3Rpb24oKXtyZXR1cm4gZ30pO3ZhciByPXQoNzIpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBzKHYpe2lmKHY9di50cmltKCksIXZ8fHY9PT0ibm9uZSIpcmV0dXJuIG51bGw7Y29uc3QgaD0vXig/Oih1cmx8Ymx1cnxicmlnaHRuZXNzfGNvbnRyYXN0fGRyb3Atc2hhZG93fGdyYXlzY2FsZXxodWUtcm90YXRlfGludmVydHxvcGFjaXR5fHNhdHVyYXRlfHNlcGlhKVwoKFteKCldKig/OlwoLipcKSkqW14oKV0qKVwpKSskL2ksbD12Lm1hdGNoKC8oPzoodXJsfGJsdXJ8YnJpZ2h0bmVzc3xjb250cmFzdHxkcm9wLXNoYWRvd3xncmF5c2NhbGV8aHVlLXJvdGF0ZXxpbnZlcnR8b3BhY2l0eXxzYXR1cmF0ZXxzZXBpYSlcKChbXigpXSooPzpcKC4qXCkpKlteKCldKilcKSkrPy9pZyksdT1bXTtyZXR1cm4gbCYmbC5mb3JFYWNoKE09Pntjb25zdCBmPU0ubWF0Y2goaCk7aWYoIWYpdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCBmaXRsZXIgc3RyaW5nLiIpO2xldFsseSx4XT1mO3k9eS50b0xvd2VyQ2FzZSgpLHg9eC50cmltKCkubWF0Y2goLyhbXiggKV0rfChbXiggKV0rXCguKlwpKSkoPz1cc3wkKS9nKS5tYXAoKGIsTyk9PntsZXQgbTtyZXR1cm4geT09PSJ1cmwifHx5PT09ImRyb3Atc2hhZG93IiYmTz09PTM/bT1iOm09T2JqZWN0KHIudG9OdW1iZXIpKGIpLC8lJC8udGVzdChiKSYmKG0vPTEwMCksbX0pLHUucHVzaCh7dHlwZTp5LGFyZ3M6eH0pfSksdX1mdW5jdGlvbiBnKHYsaCl7di5jbGVhckZpbHRlcigpLGgmJmguZm9yRWFjaCgoe3R5cGU6bCxhcmdzOnV9KT0+e2xldCBNPWw7TT09PSJkcm9wLXNoYWRvdyI/TT0iZHJvcFNoYWRvdyI6TT09PSJodWUtcm90YXRlIiYmKE09Imh1ZVJvdGF0ZSIpLHZbTV0oLi4udSl9KX19LGZ1bmN0aW9uKGMsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIHJ9KSx0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gcihzLGcpe2lmKCFnKXJldHVybjtjb25zdCB2PXMuZ2V0TGlzdGVuZXJzKCJiZWZvcmVyZW5kZXIiKSxoPXMuZ2V0TGlzdGVuZXJzKCJhZnRlcnJlbmRlciIpO3YubGVuZ3RoJiYhZy5iZWZvcmVSZW5kZXI/Zy5iZWZvcmVSZW5kZXI9bD0+e3MuZGlzcGF0Y2hFdmVudCh7dHlwZToiYmVmb3JlcmVuZGVyIixkZXRhaWw6e2NvbnRleHQ6bH19KX06di5sZW5ndGh8fChnLmJlZm9yZVJlbmRlcj1udWxsKSxoLmxlbmd0aCYmIWcuYWZ0ZXJSZW5kZXI/Zy5hZnRlclJlbmRlcj1sPT57cy5kaXNwYXRjaEV2ZW50KHt0eXBlOiJhZnRlcnJlbmRlciIsZGV0YWlsOntjb250ZXh0Omx9fSl9OmgubGVuZ3RofHwoZy5hZnRlclJlbmRlcj1udWxsKX19LGZ1bmN0aW9uKGMsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIHV9KTt2YXIgcj10KDEyKSxzPXQoMjE4KSxnPXQoNzApLHY9dCgyMTMpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCBoPVN5bWJvbCgiYW1vdW50IiksbD1TeW1ib2woIm1lc2hDbG91ZCIpO2NsYXNzIHUgZXh0ZW5kcyBnLmRlZmF1bHR7Y29uc3RydWN0b3IoZix5PTEpe3N1cGVyKCksdGhpcy5tZXNoTm9kZT1mLGYuY29ubmVjdCh0aGlzKSx0aGlzW2hdPXksdGhpc1tsXT1udWxsfWdldCBtZXNoQ2xvdWQoKXtjb25zdCBmPXRoaXMubWVzaE5vZGUseT10aGlzW2hdO3JldHVybiF0aGlzW2xdJiZmLm1lc2gmJih0aGlzW2xdPW5ldyByLk1lc2hDbG91ZChmLm1lc2gseSkpLHRoaXNbbF19Z2V0IGlzVmlzaWJsZSgpe3JldHVybiEhdGhpcy5tZXNoTm9kZSYmdGhpcy5tZXNoTm9kZS5pc1Zpc2libGV9Z2V0IGFtb3VudCgpe3JldHVybiB0aGlzW2hdfXNldCBhbW91bnQoZil7dGhpc1toXT1mLHRoaXNbbF0mJih0aGlzW2xdLmFtb3VudD1mKX1icmlnaHRuZXNzKGYseSl7dGhpcy5tZXNoQ2xvdWQmJih0aGlzLm1lc2hDbG91ZC5icmlnaHRuZXNzKGYseSksdGhpcy5mb3JjZVVwZGF0ZSgpKX1jb250cmFzdChmLHkpe3RoaXMubWVzaENsb3VkJiYodGhpcy5tZXNoQ2xvdWQuY29udHJhc3QoZix5KSx0aGlzLmZvcmNlVXBkYXRlKCkpfWRlbGV0ZShmKXt0aGlzLm1lc2hDbG91ZCYmKHRoaXMubWVzaENsb3VkLmRlbGV0ZShmKSx0aGlzW2hdLS0sdGhpcy5mb3JjZVVwZGF0ZSgpKX1kcmF3KGY9W10pe2lmKHN1cGVyLmRyYXcoZiksdGhpcy5tZXNoQ2xvdWQpe2lmKHRoaXMucHJvZ3JhbSl7dGhpcy5tZXNoQ2xvdWQuc2V0UHJvZ3JhbSh0aGlzLnByb2dyYW0pO2NvbnN0IHk9dGhpcy5zaGFkZXJBdHRyczt5JiZPYmplY3QuZW50cmllcyh5KS5mb3JFYWNoKChbYixPXSk9Pnt0aGlzLm1lc2hDbG91ZC5tZXNoLnNldEF0dHJpYnV0ZShiLE8pfSk7Y29uc3QgeD10aGlzLnVuaWZvcm1zO2lmKHRoaXMudW5pZm9ybXMpe2NvbnN0IGI9e307T2JqZWN0LmVudHJpZXMoeCkuZm9yRWFjaCgoW08sbV0pPT57dHlwZW9mIG09PSJmdW5jdGlvbiImJihtPW0odGhpcyxPKSksYltPXT1tfSksdGhpcy5tZXNoQ2xvdWQubWVzaC5zZXRVbmlmb3JtcyhiKX19dGhpcy5tZXNoTm9kZS50ZXh0dXJlSW1hZ2UmJk9iamVjdChzLmRyYXdUZXh0dXJlKSh0aGlzLm1lc2hOb2RlLHRoaXMubWVzaE5vZGUubWVzaCksZi5wdXNoKHRoaXMubWVzaENsb3VkKX1yZXR1cm4gZn1nZXRUcmFuc2Zvcm0oZil7aWYodGhpcy5tZXNoQ2xvdWQpcmV0dXJuIHRoaXMubWVzaENsb3VkLmdldFRyYW5zZm9ybShmKX1ncmF5c2NhbGUoZix5KXt0aGlzLm1lc2hDbG91ZCYmKHRoaXMubWVzaENsb3VkLmdyYXlzY2FsZShmLHkpLHRoaXMuZm9yY2VVcGRhdGUoKSl9aHVlUm90YXRlKGYseSl7dGhpcy5tZXNoQ2xvdWQmJih0aGlzLm1lc2hDbG91ZC5odWVSb3RhdGUoZix5KSx0aGlzLmZvcmNlVXBkYXRlKCkpfWludmVydChmLHkpe3RoaXMubWVzaENsb3VkJiYodGhpcy5tZXNoQ2xvdWQuaW52ZXJ0KGYseSksdGhpcy5mb3JjZVVwZGF0ZSgpKX1pc1BvaW50Q29sbGlzaW9uKGYseSl7aWYoIXRoaXMubWVzaENsb3VkKXJldHVybiExO2NvbnN0IHg9dGhpcy5hdHRyaWJ1dGVzLnBvaW50ZXJFdmVudHM7aWYoeD09PSJub25lInx8eCE9PSJhbGwiJiYhdGhpcy5pc1Zpc2libGUpcmV0dXJuITE7bGV0IGI9ImJvdGgiO3g9PT0idmlzaWJsZUZpbGwiJiYoYj0iZmlsbCIpLHg9PT0idmlzaWJsZVN0cm9rZSImJihiPSJzdHJva2UiKTtmb3IobGV0IE89MDtPPHRoaXNbaF07TysrKWlmKCF0aGlzLm1lc2hDbG91ZC5pc1BvaW50Q29sbGlzaW9uKE8sW2YseV0sYikpcmV0dXJuITE7cmV0dXJuITB9c2V0T3BhY2l0eShmLHkpe3RoaXMubWVzaENsb3VkJiYodGhpcy5tZXNoQ2xvdWQub3BhY2l0eShmLHkpLHRoaXMuZm9yY2VVcGRhdGUoKSl9cm90YXRlKGYseSxbeCxiXT1bMCwwXSl7Y29uc3QgTz1NYXRoLlBJKnkvMTgwO2lmKHRoaXMubWVzaENsb3VkKXtjb25zdHt4Om0seTpwfT10aGlzLm1lc2hOb2RlLmF0dHJpYnV0ZXM7dGhpcy5tZXNoQ2xvdWQucm90YXRlKGYsTyxbeCttLGIrcF0pLHRoaXMuZm9yY2VVcGRhdGUoKX19c2F0dXJhdGUoZix5KXt0aGlzLm1lc2hDbG91ZCYmKHRoaXMubWVzaENsb3VkLnNhdHVyYXRlKGYseSksdGhpcy5mb3JjZVVwZGF0ZSgpKX1zY2FsZShmLFt5LHg9eV0sW2IsT109WzAsMF0pe2lmKHRoaXMubWVzaENsb3VkKXtjb25zdHt4Om0seTpwfT10aGlzLm1lc2hOb2RlLmF0dHJpYnV0ZXMsbj0xZS01O01hdGguYWJzKHkpPG4mJih5PTEveT4wP246LW4pLE1hdGguYWJzKHgpPG4mJih4PTEveD4wP246LW4pLHRoaXMubWVzaENsb3VkLnNjYWxlKGYsW3kseF0sW2IrbSxPK3BdKSx0aGlzLmZvcmNlVXBkYXRlKCl9fXNldENvbG9yVHJhbnNmb3JtKGYseSl7dGhpcy5tZXNoQ2xvdWQmJih0aGlzLm1lc2hDbG91ZC5zZXRDb2xvclRyYW5zZm9ybShmLHkpLHRoaXMuZm9yY2VVcGRhdGUoKSl9c2V0RmlsbENvbG9yKGYseSl7dGhpcy5tZXNoQ2xvdWQmJihBcnJheS5pc0FycmF5KHkpJiYoeT1bLi4ueV0seVswXS89MjU1LHlbMV0vPTI1NSx5WzJdLz0yNTUpLHRoaXMubWVzaENsb3VkLnNldEZpbGxDb2xvcihmLHkpLHRoaXMuZm9yY2VVcGRhdGUoKSl9c2VwaWEoZix5KXt0aGlzLm1lc2hDbG91ZCYmKHRoaXMubWVzaENsb3VkLnNlcGlhKGYseSksdGhpcy5mb3JjZVVwZGF0ZSgpKX1zZXRSZXNvbHV0aW9uKHt3aWR0aDpmLGhlaWdodDp5fSl7c3VwZXIuc2V0UmVzb2x1dGlvbih7d2lkdGg6ZixoZWlnaHQ6eX0pLHRoaXMubWVzaE5vZGUuc2V0UmVzb2x1dGlvbih7d2lkdGg6ZixoZWlnaHQ6eX0pfXNldFN0cm9rZUNvbG9yKGYseSl7dGhpcy5tZXNoQ2xvdWQmJihBcnJheS5pc0FycmF5KHkpJiYoeT1bLi4ueV0seVswXS89MjU1LHlbMV0vPTI1NSx5WzJdLz0yNTUpLHRoaXMubWVzaENsb3VkLnNldFN0cm9rZUNvbG9yKGYseSksdGhpcy5mb3JjZVVwZGF0ZSgpKX1zZXRUcmFuc2Zvcm0oZix5KXt0aGlzLm1lc2hDbG91ZCYmKHRoaXMubWVzaENsb3VkLnNldFRyYW5zZm9ybShmLHkpLHRoaXMuZm9yY2VVcGRhdGUoKSl9c2tldyhmLFt5LHg9eV0sW2IsT109WzAsMF0pe2lmKHRoaXMubWVzaENsb3VkKXtjb25zdHt4Om0seTpwfT10aGlzLm1lc2hOb2RlLmF0dHJpYnV0ZXM7dGhpcy5tZXNoQ2xvdWQuc2tldyhmLFt5LHhdLFtiK20sTytwXSksdGhpcy5mb3JjZVVwZGF0ZSgpfX10cmFuc2Zvcm0oZix5KXt0aGlzLm1lc2hDbG91ZCYmKHRoaXMubWVzaENsb3VkLnRyYW5zZm9ybShmLHkpLHRoaXMuZm9yY2VVcGRhdGUoKSl9dHJhbnNmb3JtQ29sb3IoZix5KXt0aGlzLm1lc2hDbG91ZCYmKHRoaXMubWVzaENsb3VkLnRyYW5zZm9ybUNvbG9yKGYseSksdGhpcy5mb3JjZVVwZGF0ZSgpKX10cmFuc2xhdGUoZixbeSx4XSl7dGhpcy5tZXNoQ2xvdWQmJih0aGlzLm1lc2hDbG91ZC50cmFuc2xhdGUoZixbeSx4XSksdGhpcy5mb3JjZVVwZGF0ZSgpKX11cGRhdGVNZXNoKCl7dGhpc1tsXSYmKHRoaXNbbF0ubWVzaD10aGlzLm1lc2hOb2RlLm1lc2gsdGhpcy5mb3JjZVVwZGF0ZSgpKX19di5kZWZhdWx0LnJlZ2lzdGVyTm9kZSh1LCJjbG91ZCIpfSxmdW5jdGlvbihjLGUsdCl7dC5yKGUpLHQuZChlLCJsb2FkVGV4dHVyZSIsZnVuY3Rpb24oKXtyZXR1cm4gdn0pLHQuZChlLCJhcHBseVRleHR1cmUiLGZ1bmN0aW9uKCl7cmV0dXJuIGh9KSx0LmQoZSwiY3JlYXRlVGV4dHVyZSIsZnVuY3Rpb24oKXtyZXR1cm4gdX0pLHQuZChlLCJkZWxldGVUZXh0dXJlIixmdW5jdGlvbigpe3JldHVybiBNfSksdC5kKGUsImRyYXdUZXh0dXJlIixmdW5jdGlvbigpe3JldHVybiB5fSksdC5kKGUsImxvYWRGcmFtZXMiLGZ1bmN0aW9uKCl7cmV0dXJuIHh9KTt2YXIgcj10KDEyKSxzPXQoNzIpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCBnPXt9O2Z1bmN0aW9uIHYoYixPKXtpZihnW2JdKXJldHVybiBnW2JdO2NvbnN0IG09ci5FTlYubG9hZEltYWdlKGIse2FsaWFzOk8sdXNlSW1hZ2VCaXRtYXA6ITF9KTtyZXR1cm4gbT8/Yn1hc3luYyBmdW5jdGlvbiBoKGIsTyxtKXtsZXQgcD1PO2lmKHR5cGVvZiBPPT0ic3RyaW5nIiYmKHA9dihPKSkscCYmdHlwZW9mIHAudGhlbj09ImZ1bmN0aW9uIiYmKHA9YXdhaXQgcCksTz09PWIuYXR0cmlidXRlcy50ZXh0dXJlKXtwJiZwLmltYWdlJiYocC5zb3VyY2VSZWN0JiYoYi5hdHRyaWJ1dGVzLnNvdXJjZVJlY3Q9cC5zb3VyY2VSZWN0KSxiLnRleHR1cmVJbWFnZVJvdGF0ZWQ9ISFwLnJvdGF0ZWQscD1wLmltYWdlKTtjb25zdHt3aWR0aDpuLGhlaWdodDphLHRleHR1cmVSZWN0Oml9PWIuYXR0cmlidXRlcyxvPWIudGV4dHVyZUltYWdlO2IudGV4dHVyZUltYWdlPXAsbSYmbyE9PXAmJiFpJiYobj09bnVsbHx8YT09bnVsbCkmJmIudXBkYXRlQ29udG91cnMoKSxiLmZvcmNlVXBkYXRlKCl9cmV0dXJuIHB9Y29uc3QgbD1TeW1ib2woInRleHR1cmVNYXAiKTtmdW5jdGlvbiB1KGIsTyl7aWYoT1tsXT1PW2xdfHxuZXcgTWFwLE9bbF0uaGFzKGIpKXJldHVybiBPW2xdLmdldChiKTtjb25zdCBtPU8uY3JlYXRlVGV4dHVyZShiKTtyZXR1cm4hL15ibG9iOi8udGVzdChiLnNyYykmJnR5cGVvZiBiLmdldENvbnRleHQhPSJmdW5jdGlvbiImJk9bbF0uc2V0KGIsbSksbX1mdW5jdGlvbiBNKGIsTyl7aWYoT1tsXSYmT1tsXS5oYXMoYikpe2NvbnN0IG09T1tsXS5nZXQoYik7cmV0dXJuIE8uZGVsZXRlVGV4dHVyZShtKSxPW2xdLmRlbGV0ZShiKSwhMH1yZXR1cm4hMX1jb25zdCBmPVN5bWJvbCgidGV4dHVyZUNvbnRleHQiKTtmdW5jdGlvbiB5KGIsTyl7Y29uc3QgbT1iLnRleHR1cmVJbWFnZSBpbnN0YW5jZW9mIFN0cmluZz9TdHJpbmcoYi50ZXh0dXJlSW1hZ2UpOmIudGV4dHVyZUltYWdlLHA9Yi50ZXh0dXJlSW1hZ2VSb3RhdGVkLG49Ty50ZXh0dXJlLGE9Yi5yZW5kZXJlcjtpZihtKXtjb25zdCBpPWIub3JpZ2luYWxDb250ZW50UmVjdDtsZXQgbz1iLmF0dHJpYnV0ZXMudGV4dHVyZVJlY3Q7Y29uc3QgVD1iLmF0dHJpYnV0ZXMudGV4dHVyZVJlcGVhdCxQPWIuYXR0cmlidXRlcy5zb3VyY2VSZWN0O2lmKCFufHxiW2ZdJiZiW2ZdIT09YXx8bi5pbWFnZSE9PW18fG4ub3B0aW9ucy5yZXBlYXQhPT1UfHwhT2JqZWN0KHMuY29tcGFyZVZhbHVlKShuLm9wdGlvbnMucmVjdCxvKXx8IU9iamVjdChzLmNvbXBhcmVWYWx1ZSkobi5vcHRpb25zLnNyY1JlY3QsUCkpe2NvbnN0IEM9dShtLGEpO28/KG9bMF0rPWlbMF0sb1sxXSs9aVsxXSk6bz1pO2xldCBJPW51bGw7biYmIWFbbF0uaGFzKG4uaW1hZ2UpJiYoIW4ub3B0aW9uc3x8IW4ub3B0aW9ucy5oaWRkZW4pJiYoST1PLnVuaWZvcm1zLnVfdGV4U2FtcGxlciksTy5zZXRUZXh0dXJlKEMse3JlY3Q6byxyZXBlYXQ6VCxzcmNSZWN0OlAscm90YXRlZDpwfSksSSYmSS5kZWxldGUmJkkuZGVsZXRlKCksYltmXT1hfX1lbHNlIGlmKG4pe2xldCBpPW51bGw7IWFbbF0uaGFzKG4uaW1hZ2UpJiYoIW4ub3B0aW9uc3x8IW4ub3B0aW9ucy5oaWRkZW4pJiYoaT1PLnVuaWZvcm1zLnVfdGV4U2FtcGxlciksTy5zZXRUZXh0dXJlKG51bGwpLGkmJmkuZGVsZXRlJiZpLmRlbGV0ZSgpfX1hc3luYyBmdW5jdGlvbiB4KGIsTyl7dHlwZW9mIE89PSJzdHJpbmciJiYoTz1hd2FpdChhd2FpdCBmZXRjaChPLHttZXRob2Q6IkdFVCIsbW9kZToiY29ycyIsY2FjaGU6ImRlZmF1bHQifSkpLmpzb24oKSk7Y29uc3QgbT1hd2FpdCB2KGIpLHA9Ty5mcmFtZXM7cmV0dXJuIE9iamVjdC5lbnRyaWVzKHApLmZvckVhY2goKFtuLGFdKT0+e2NvbnN0e3g6aSx5Om8sdzpULGg6UH09YS5mcmFtZTtsZXQgQz1baSxvLFQsUF07Y29uc3QgST1hLnJvdGF0ZWQ7SSYmKEM9W0NbMF0sQ1sxXSxDWzNdLENbMl1dKSxnW25dPXtpbWFnZTptLHNvdXJjZVJlY3Q6Qyxyb3RhdGVkOkl9fSksbX19LGZ1bmN0aW9uKGMsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIHh9KTt2YXIgcj10KDEpLHM9dCgxMiksZz10KDcwKSx2PXQoMjIwKSxoPXQoMjIxKSxsPXQoMjIyKSx1PXQoMjEzKSxNPXQoMjIzKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gZihiLE8sbSl7cmV0dXJuIE8gaW4gYj9PYmplY3QuZGVmaW5lUHJvcGVydHkoYixPLHt2YWx1ZTptLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6YltPXT1tLGJ9Y29uc3QgeT1TeW1ib2woIm1lc2giKTtjbGFzcyB4IGV4dGVuZHMgZy5kZWZhdWx0e2NvbnN0cnVjdG9yKE89e30pe3N1cGVyKE8pfWdldCBib3JkZXJTaXplKCl7Y29uc3R7cGFkZGluZ1RvcDpPLHBhZGRpbmdSaWdodDptLHBhZGRpbmdCb3R0b206cCxwYWRkaW5nTGVmdDpuLGJvcmRlcldpZHRoOmF9PXRoaXMuYXR0cmlidXRlcyxbaSxvXT10aGlzLmNvbnRlbnRTaXplO3JldHVybltuK2krbSthLE8rbytwK2FdfWdldCBjbGllbnRTaXplKCl7Y29uc3R7cGFkZGluZ1RvcDpPLHBhZGRpbmdSaWdodDptLHBhZGRpbmdCb3R0b206cCxwYWRkaW5nTGVmdDpufT10aGlzLmF0dHJpYnV0ZXMsW2EsaV09dGhpcy5jb250ZW50U2l6ZTtyZXR1cm5bbithK20sTytpK3BdfWdldCBjb250ZW50U2l6ZSgpe2xldHt3aWR0aDpPLGhlaWdodDptLGJveFNpemluZzpwLHBhZGRpbmdUb3A6bixwYWRkaW5nUmlnaHQ6YSxwYWRkaW5nQm90dG9tOmkscGFkZGluZ0xlZnQ6b309dGhpcy5hdHRyaWJ1dGVzO2lmKE89T3x8MCxtPW18fDAscD09PSJib3JkZXItYm94Iil7Y29uc3QgVD0yKnRoaXMuYXR0cmlidXRlcy5ib3JkZXJXaWR0aDtPLT1UK2ErbyxtLT1UK24raSxPPU1hdGgubWF4KDAsTyksbT1NYXRoLm1heCgwLG0pfXJldHVybltPLG1dfWdldCBoYXNCb3JkZXIoKXtyZXR1cm4gdGhpcy5hdHRyaWJ1dGVzLmJvcmRlcldpZHRoPjB9Z2V0IGlzVmlzaWJsZSgpe2NvbnN0W08sbV09dGhpcy5ib3JkZXJTaXplO3JldHVybiBPPjAmJm0+MH1nZXQgbWVzaCgpe2lmKHRoaXMuYXR0cmlidXRlcy5kaXNwbGF5PT09Im5vbmUiKXJldHVybiBudWxsO2NvbnN0IE89dGhpcy5jbGllbnRCb3g7aWYoTyl7bGV0IG09dGhpc1t5XTtpZihtKW0uYm94IT09TyYmKG0uY29udG91cnM9Ty5jb250b3VycyxtLmJveD1PKTtlbHNle209bmV3IHMuTWVzaDJEKE8pLG0uYm94PU87Y29uc3Qgbj10aGlzLmF0dHJpYnV0ZXMuYmdjb2xvcjtpZihPYmplY3QoaC5zZXRGaWxsQ29sb3IpKG0se2NvbG9yOm59KSx0aGlzLmhhc0JvcmRlcil7Y29uc3R7Ym9yZGVyQ29sb3I6aSxib3JkZXJXaWR0aDpvLGJvcmRlckRhc2g6VCxib3JkZXJEYXNoT2Zmc2V0OlB9PXRoaXMuYXR0cmlidXRlcztPYmplY3QoaC5zZXRTdHJva2VDb2xvcikobSx7Y29sb3I6aSxsaW5lV2lkdGg6byxsaW5lRGFzaDpULGxpbmVEYXNoT2Zmc2V0OlB9KX10aGlzW3ldPW07Y29uc3QgYT10aGlzLmF0dHJpYnV0ZXMuY2xpcFBhdGg7YSYmdGhpc1t5XS5zZXRDbGlwUGF0aChhKX1jb25zdCBwPXRoaXMub3BhY2l0eTtyZXR1cm4gbS5nZXRPcGFjaXR5KCkhPT1wJiZtLnNldE9wYWNpdHkocCksbS5zZXRUcmFuc2Zvcm0oLi4udGhpcy5yZW5kZXJNYXRyaXgpLG19cmV0dXJuIG51bGx9Z2V0IG9mZnNldFNpemUoKXtjb25zdHtwYWRkaW5nVG9wOk8scGFkZGluZ1JpZ2h0Om0scGFkZGluZ0JvdHRvbTpwLHBhZGRpbmdMZWZ0Om4sYm9yZGVyV2lkdGg6YX09dGhpcy5hdHRyaWJ1dGVzLFtpLG9dPXRoaXMuY29udGVudFNpemUsVD0yKmE7cmV0dXJuW24raSttK1QsTytvK3ArVF19Z2V0IG9yaWdpbmFsQ2xpZW50UmVjdCgpe2lmKHRoaXMubWVzaCl7Y29uc3QgTz10aGlzLm1lc2guYm91bmRpbmdCb3g7cmV0dXJuW09bMF1bMF0sT1swXVsxXSxPWzFdWzBdLU9bMF1bMF0sT1sxXVsxXS1PWzBdWzFdXX1yZXR1cm5bMCwwLDAsMF19Z2V0IG9yaWdpbmFsQ29udGVudFJlY3QoKXtjb25zdFtPLG0scCxuXT10aGlzLm9yaWdpbmFsQ2xpZW50UmVjdCxhPXRoaXMuYXR0cmlidXRlcy5wYWRkaW5nO3JldHVybltPK2FbMF0sbSthWzFdLHAtYVswXS1hWzJdLG4tYVsxXS1hWzNdXX1nZXRCb3VuZGluZ0NsaWVudFJlY3QoKXtsZXQgTz10aGlzLnJlbmRlck1hdHJpeDt0aGlzLmxheWVyJiZ0aGlzLmxheWVyLmxheWVyVHJhbnNmb3JtSW52ZXJ0JiYoTz1yLm1hdDJkLm11bHRpcGx5KEFycmF5Lm9mKDAsMCwwLDAsMCwwKSx0aGlzLmxheWVyLnRyYW5zZm9ybU1hdHJpeCxPKSk7bGV0IG09bnVsbDtpZih0aGlzLm1lc2gpe209Wy4uLnRoaXMubWVzaC5ib3VuZGluZ0JveF07Y29uc3QgcD10aGlzLmF0dHJpYnV0ZXMuYm9yZGVyV2lkdGg7cCYmKG1bMF09W21bMF1bMF0tcCxtWzBdWzFdLXBdLG1bMV09W21bMV1bMF0rcCxtWzFdWzFdK3BdKX1yZXR1cm4gT2JqZWN0KE0uZGVmYXVsdCkobSxPKX1vblByb3BlcnR5Q2hhbmdlKE8sbSxwKXtpZihzdXBlci5vblByb3BlcnR5Q2hhbmdlKE8sbSxwKSwoTz09PSJhbmNob3JYInx8Tz09PSJhbmNob3JZInx8Tz09PSJib3hTaXppbmcifHxPPT09IndpZHRoInx8Tz09PSJoZWlnaHQifHxPPT09ImJvcmRlcldpZHRoInx8Tz09PSJwYWRkaW5nTGVmdCJ8fE89PT0icGFkZGluZ1JpZ2h0Inx8Tz09PSJwYWRkaW5nVG9wInx8Tz09PSJwYWRkaW5nQm90dG9tInx8L15ib3JkZXIoVG9wTGVmdHxUb3BSaWdodHxCb3R0b21SaWdodHxCb3R0b21MZWZ0KVJhZGl1cyQvLnRlc3QoTykpJiZ0aGlzLnVwZGF0ZUNvbnRvdXJzKCksdGhpc1t5XSYmTz09PSJjbGlwUGF0aCImJnRoaXNbeV0uc2V0Q2xpcFBhdGgobSksdGhpc1t5XSYmTz09PSJiZ2NvbG9yIiYmT2JqZWN0KGguc2V0RmlsbENvbG9yKSh0aGlzW3ldLHtjb2xvcjptfSksdGhpc1t5XSYmKE89PT0iYm9yZGVyQ29sb3IifHxPPT09ImJvcmRlcldpZHRoInx8Tz09PSJib3JkZXJEYXNoInx8Tz09PSJib3JkZXJEYXNoT2Zmc2V0Iikpe2NvbnN0e2JvcmRlckNvbG9yOm4sYm9yZGVyV2lkdGg6YSxib3JkZXJEYXNoOmksYm9yZGVyRGFzaE9mZnNldDpvfT10aGlzLmF0dHJpYnV0ZXM7T2JqZWN0KGguc2V0U3Ryb2tlQ29sb3IpKHRoaXNbeV0se2NvbG9yOm4sbGluZVdpZHRoOmEsbGluZURhc2g6YT9pOjAsbGluZURhc2hPZmZzZXQ6b30pfX11cGRhdGVDb250b3Vycygpe2NvbnN0e2FuY2hvclg6TyxhbmNob3JZOm0sYm9yZGVyV2lkdGg6cCxib3JkZXJSYWRpdXM6bn09dGhpcy5hdHRyaWJ1dGVzLFthLGldPXRoaXMuYm9yZGVyU2l6ZSxvPXRoaXMub2Zmc2V0U2l6ZSxUPS41KnAsUD0tTypvWzBdK1QsQz0tbSpvWzFdK1Q7dGhpcy5jbGllbnRCb3g9bmV3IHMuRmlndXJlMkQsT2JqZWN0KGwuY3JlYXRlUmFkaXVzQm94KSh0aGlzLmNsaWVudEJveCxbUCxDLGEsaV0sbil9fWYoeCwiQXR0ciIsdi5kZWZhdWx0KSx1LmRlZmF1bHQucmVnaXN0ZXJOb2RlKHgsImJsb2NrIil9LGZ1bmN0aW9uKGMsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIE19KTt2YXIgcj10KDcxKSxzPXQoNzIpLGc9dCgyMjEpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCB2PVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZSIpLGg9U3ltYm9sLmZvcigic3ByaXRlanNfZ2V0QXR0cmlidXRlIiksbD1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGVEZWZhdWx0IiksdT1TeW1ib2wuZm9yKCJzcHJpdGVqc19kZWNsYXJlQWxpYXMiKTtjbGFzcyBNIGV4dGVuZHMgci5kZWZhdWx0e2NvbnN0cnVjdG9yKHkpe3N1cGVyKHkpLHRoaXNbbF0oe2FuY2hvclg6MCxhbmNob3JZOjAsd2lkdGg6dm9pZCAwLGhlaWdodDp2b2lkIDAsYm9yZGVyV2lkdGg6MCxib3JkZXJDb2xvcjoicmdiYSgwLDAsMCwxKSIsYm9yZGVyRGFzaDp2b2lkIDAsYm9yZGVyRGFzaE9mZnNldDowLGJvcmRlclRvcExlZnRSYWRpdXM6WzAsMF0sYm9yZGVyVG9wUmlnaHRSYWRpdXM6WzAsMF0sYm9yZGVyQm90dG9tUmlnaHRSYWRpdXM6WzAsMF0sYm9yZGVyQm90dG9tTGVmdFJhZGl1czpbMCwwXSxiZ2NvbG9yOiJyZ2JhKDAsMCwwLDApIixwYWRkaW5nVG9wOjAscGFkZGluZ1JpZ2h0OjAscGFkZGluZ0JvdHRvbTowLHBhZGRpbmdMZWZ0OjAsYm94U2l6aW5nOiJjb250ZW50LWJveCIsY2xpcFBhdGg6dm9pZCAwfSksdGhpc1t1XSgiYW5jaG9yIiwic2l6ZSIsImJvcmRlciIsImJvcmRlclJhZGl1cyIsInBhZGRpbmciKX1nZXQgYW5jaG9yWCgpe3JldHVybiB0aGlzW2hdKCJhbmNob3JYIil9c2V0IGFuY2hvclgoeSl7dGhpc1t2XSgiYW5jaG9yWCIsT2JqZWN0KHMudG9OdW1iZXIpKHkpKX1nZXQgYW5jaG9yWSgpe3JldHVybiB0aGlzW2hdKCJhbmNob3JZIil9c2V0IGFuY2hvclkoeSl7dGhpc1t2XSgiYW5jaG9yWSIsT2JqZWN0KHMudG9OdW1iZXIpKHkpKX1nZXQgYW5jaG9yKCl7cmV0dXJuW3RoaXMuYW5jaG9yWCx0aGlzLmFuY2hvclldfXNldCBhbmNob3IoeSl7eT1PYmplY3Qocy50b0FycmF5KSh5KSxBcnJheS5pc0FycmF5KHkpfHwoeT1beSx5XSksdGhpcy5hbmNob3JYPXlbMF0sdGhpcy5hbmNob3JZPXlbMV19Z2V0IHdpZHRoKCl7cmV0dXJuIHRoaXNbaF0oIndpZHRoIil9c2V0IHdpZHRoKHkpe3RoaXNbdl0oIndpZHRoIixPYmplY3Qocy50b051bWJlcikoeSkpfWdldCBoZWlnaHQoKXtyZXR1cm4gdGhpc1toXSgiaGVpZ2h0Iil9c2V0IGhlaWdodCh5KXt0aGlzW3ZdKCJoZWlnaHQiLE9iamVjdChzLnRvTnVtYmVyKSh5KSl9Z2V0IHNpemUoKXtyZXR1cm5bdGhpcy53aWR0aCx0aGlzLmhlaWdodF19c2V0IHNpemUoeSl7eT1PYmplY3Qocy50b0FycmF5KSh5KSxBcnJheS5pc0FycmF5KHkpfHwoeT1beSx5XSksdGhpcy53aWR0aD15WzBdLHRoaXMuaGVpZ2h0PXlbMV19Z2V0IGJvcmRlcldpZHRoKCl7cmV0dXJuIHRoaXNbaF0oImJvcmRlcldpZHRoIil9c2V0IGJvcmRlcldpZHRoKHkpe3RoaXNbdl0oImJvcmRlcldpZHRoIixPYmplY3Qocy50b051bWJlcikoeSkpfWdldCBib3JkZXJDb2xvcigpe3JldHVybiB0aGlzW2hdKCJib3JkZXJDb2xvciIpfXNldCBib3JkZXJDb2xvcih5KXt0aGlzW3ZdKCJib3JkZXJDb2xvciIsT2JqZWN0KGcucGFyc2VDb2xvcikoeSkpfWdldCBib3JkZXIoKXtyZXR1cm5bdGhpcy5ib3JkZXJXaWR0aCx0aGlzLmJvcmRlckNvbG9yXX1zZXQgYm9yZGVyKHkpe3k9T2JqZWN0KHMudG9BcnJheSkoeSksQXJyYXkuaXNBcnJheSh5KXx8KHk9W3ldKSx0aGlzLmJvcmRlcldpZHRoPXlbMF0seVsxXSE9bnVsbCYmKHRoaXMuYm9yZGVyQ29sb3I9eVsxXSl9Z2V0IGJvcmRlckRhc2goKXtyZXR1cm4gdGhpc1toXSgiYm9yZGVyRGFzaCIpfXNldCBib3JkZXJEYXNoKHkpe3k9T2JqZWN0KHMudG9BcnJheSkoeSwhMCkseSE9bnVsbCYmIUFycmF5LmlzQXJyYXkoeSkmJih5PVt5XSksdGhpc1t2XSgiYm9yZGVyRGFzaCIseT95Lm1hcChzLnRvTnVtYmVyKTpudWxsKX1nZXQgYm9yZGVyRGFzaE9mZnNldCgpe3JldHVybiB0aGlzW2hdKCJib3JkZXJEYXNoT2Zmc2V0Iil9c2V0IGJvcmRlckRhc2hPZmZzZXQoeSl7dGhpc1t2XSgiYm9yZGVyRGFzaE9mZnNldCIsT2JqZWN0KHMudG9OdW1iZXIpKHkpKX1nZXQgYm9yZGVyVG9wTGVmdFJhZGl1cygpe3JldHVybiB0aGlzW2hdKCJib3JkZXJUb3BMZWZ0UmFkaXVzIil9c2V0IGJvcmRlclRvcExlZnRSYWRpdXMoeSl7eT1PYmplY3Qocy50b0FycmF5KSh5LCEwKSxBcnJheS5pc0FycmF5KHkpfHwoeT1beSx5XSksdGhpc1t2XSgiYm9yZGVyVG9wTGVmdFJhZGl1cyIseS5tYXAocy50b051bWJlcikpfWdldCBib3JkZXJUb3BSaWdodFJhZGl1cygpe3JldHVybiB0aGlzW2hdKCJib3JkZXJUb3BSaWdodFJhZGl1cyIpfXNldCBib3JkZXJUb3BSaWdodFJhZGl1cyh5KXt5PU9iamVjdChzLnRvQXJyYXkpKHksITApLEFycmF5LmlzQXJyYXkoeSl8fCh5PVt5LHldKSx0aGlzW3ZdKCJib3JkZXJUb3BSaWdodFJhZGl1cyIseS5tYXAocy50b051bWJlcikpfWdldCBib3JkZXJCb3R0b21SaWdodFJhZGl1cygpe3JldHVybiB0aGlzW2hdKCJib3JkZXJCb3R0b21SaWdodFJhZGl1cyIpfXNldCBib3JkZXJCb3R0b21SaWdodFJhZGl1cyh5KXt5PU9iamVjdChzLnRvQXJyYXkpKHksITApLEFycmF5LmlzQXJyYXkoeSl8fCh5PVt5LHldKSx0aGlzW3ZdKCJib3JkZXJCb3R0b21SaWdodFJhZGl1cyIseS5tYXAocy50b051bWJlcikpfWdldCBib3JkZXJCb3R0b21MZWZ0UmFkaXVzKCl7cmV0dXJuIHRoaXNbaF0oImJvcmRlckJvdHRvbUxlZnRSYWRpdXMiKX1zZXQgYm9yZGVyQm90dG9tTGVmdFJhZGl1cyh5KXt5PU9iamVjdChzLnRvQXJyYXkpKHksITApLEFycmF5LmlzQXJyYXkoeSl8fCh5PVt5LHldKSx0aGlzW3ZdKCJib3JkZXJCb3R0b21MZWZ0UmFkaXVzIix5Lm1hcChzLnRvTnVtYmVyKSl9Z2V0IGJvcmRlclJhZGl1cygpe3JldHVyblsuLi50aGlzLmJvcmRlclRvcExlZnRSYWRpdXMsLi4udGhpcy5ib3JkZXJUb3BSaWdodFJhZGl1cywuLi50aGlzLmJvcmRlckJvdHRvbVJpZ2h0UmFkaXVzLC4uLnRoaXMuYm9yZGVyQm90dG9tTGVmdFJhZGl1c119c2V0IGJvcmRlclJhZGl1cyh5KXtpZih5PU9iamVjdChzLnRvQXJyYXkpKHkpLCFBcnJheS5pc0FycmF5KHkpKXk9QXJyYXkoOCkuZmlsbCh5KTtlbHNlIGlmKHkubGVuZ3RoPT09Mil5PVt5WzBdLHlbMV0seVswXSx5WzFdLHlbMF0seVsxXSx5WzBdLHlbMV1dO2Vsc2UgaWYoeS5sZW5ndGg9PT00KXk9W3lbMF0seVsxXSx5WzJdLHlbM10seVswXSx5WzFdLHlbMl0seVszXV07ZWxzZSBpZih5Lmxlbmd0aD09PTYpeT1beVswXSx5WzFdLHlbMl0seVszXSx5WzRdLHlbNV0seVsyXSx5WzNdXTtlbHNlIGlmKHkubGVuZ3RoIT09OCl0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIGJvcmRlclJhZGl1cyB2YWx1ZS4iKTt0aGlzLmJvcmRlclRvcExlZnRSYWRpdXM9W3lbMF0seVsxXV0sdGhpcy5ib3JkZXJUb3BSaWdodFJhZGl1cz1beVsyXSx5WzNdXSx0aGlzLmJvcmRlckJvdHRvbVJpZ2h0UmFkaXVzPVt5WzRdLHlbNV1dLHRoaXMuYm9yZGVyQm90dG9tTGVmdFJhZGl1cz1beVs2XSx5WzddXX1nZXQgYmdjb2xvcigpe3JldHVybiB0aGlzW2hdKCJiZ2NvbG9yIil9c2V0IGJnY29sb3IoeSl7dGhpc1t2XSgiYmdjb2xvciIsT2JqZWN0KGcucGFyc2VDb2xvcikoeSkpfWdldCBwYWRkaW5nVG9wKCl7cmV0dXJuIHRoaXNbaF0oInBhZGRpbmdUb3AiKX1zZXQgcGFkZGluZ1RvcCh5KXt0aGlzW3ZdKCJwYWRkaW5nVG9wIixPYmplY3Qocy50b051bWJlcikoeSkpfWdldCBwYWRkaW5nUmlnaHQoKXtyZXR1cm4gdGhpc1toXSgicGFkZGluZ1JpZ2h0Iil9c2V0IHBhZGRpbmdSaWdodCh5KXt0aGlzW3ZdKCJwYWRkaW5nUmlnaHQiLE9iamVjdChzLnRvTnVtYmVyKSh5KSl9Z2V0IHBhZGRpbmdCb3R0b20oKXtyZXR1cm4gdGhpc1toXSgicGFkZGluZ0JvdHRvbSIpfXNldCBwYWRkaW5nQm90dG9tKHkpe3RoaXNbdl0oInBhZGRpbmdCb3R0b20iLE9iamVjdChzLnRvTnVtYmVyKSh5KSl9Z2V0IHBhZGRpbmdMZWZ0KCl7cmV0dXJuIHRoaXNbaF0oInBhZGRpbmdMZWZ0Iil9c2V0IHBhZGRpbmdMZWZ0KHkpe3RoaXNbdl0oInBhZGRpbmdMZWZ0IixPYmplY3Qocy50b051bWJlcikoeSkpfWdldCBwYWRkaW5nKCl7cmV0dXJuW3RoaXMucGFkZGluZ1RvcCx0aGlzLnBhZGRpbmdSaWdodCx0aGlzLnBhZGRpbmdCb3R0b20sdGhpcy5wYWRkaW5nTGVmdF19c2V0IHBhZGRpbmcoeSl7eT1PYmplY3Qocy50b0FycmF5KSh5KSxBcnJheS5pc0FycmF5KHkpP3kubGVuZ3RoPT09Mj95PVt5WzBdLHlbMV0seVswXSx5WzFdXTp5Lmxlbmd0aD09PTMmJih5PVt5WzBdLHlbMV0seVsyXSx5WzFdXSk6eT1beSx5LHkseV0sdGhpcy5wYWRkaW5nVG9wPXlbMF0sdGhpcy5wYWRkaW5nUmlnaHQ9eVsxXSx0aGlzLnBhZGRpbmdCb3R0b209eVsyXSx0aGlzLnBhZGRpbmdMZWZ0PXlbM119Z2V0IGNsaXBQYXRoKCl7cmV0dXJuIHRoaXNbaF0oImNsaXBQYXRoIil9c2V0IGNsaXBQYXRoKHkpe3RoaXNbdl0oImNsaXBQYXRoIix5KX1nZXQgYm94U2l6aW5nKCl7cmV0dXJuIHRoaXNbaF0oImJveFNpemluZyIpfXNldCBib3hTaXppbmcoeSl7aWYoeSE9bnVsbCYmeSE9PSJib3JkZXItYm94IiYmeSE9PSJjb250ZW50LWJveCIpdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCBib3hTaXppbmcgdHlwZS4iKTt0aGlzW3ZdKCJib3hTaXppbmciLHkpfX19LGZ1bmN0aW9uKGMsZSx0KXt0LnIoZSksdC5kKGUsIkdyYWRpZW50IixmdW5jdGlvbigpe3JldHVybiBnfSksdC5kKGUsImlzVHJhbnNwYXJlbnQiLGZ1bmN0aW9uKCl7cmV0dXJuIHZ9KSx0LmQoZSwicGFyc2VDb2xvciIsZnVuY3Rpb24oKXtyZXR1cm4gaH0pLHQuZChlLCJzZXRGaWxsQ29sb3IiLGZ1bmN0aW9uKCl7cmV0dXJuIHV9KSx0LmQoZSwic2V0U3Ryb2tlQ29sb3IiLGZ1bmN0aW9uKCl7cmV0dXJuIE19KSx0LmQoZSwiQ29sb3IiLGZ1bmN0aW9uKCl7cmV0dXJuIGZ9KTt2YXIgcj10KDMyKSxzPXQubihyKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y2xhc3MgZ3tjb25zdHJ1Y3Rvcih7dmVjdG9yOngsY29sb3JzOmJ9KXtpZighQXJyYXkuaXNBcnJheSh4KXx8eC5sZW5ndGghPT00JiZ4Lmxlbmd0aCE9PTYmJngubGVuZ3RoIT09Myl0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIGdyYWRpZW50Iik7dGhpcy52ZWN0b3I9eCx0aGlzLmNvbG9ycz1iLm1hcCgoe29mZnNldDpPLGNvbG9yOm19KT0+KHtvZmZzZXQ6Tyxjb2xvcjpoKG0pfSkpfXRvU3RyaW5nKCl7cmV0dXJuIEpTT04uc3RyaW5naWZ5KHt2ZWN0b3I6dGhpcy52ZWN0b3IsY29sb3JzOnRoaXMuY29sb3JzfSl9fWZ1bmN0aW9uIHYoeSl7cmV0dXJuIHkgaW5zdGFuY2VvZiBnPyExOnk9PW51bGw/ITA6cygpKHkpWzNdPT09MH1mdW5jdGlvbiBoKHkpe2lmKHk9PW51bGx8fCh5fHwoeT0idHJhbnNwYXJlbnQiKSx5IGluc3RhbmNlb2YgZykpcmV0dXJuIHk7Y29uc3QgeD1zKCkoeSk7aWYoIXh8fCF4Lmxlbmd0aCl0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIGNvbG9yIHZhbHVlLiIpO3JldHVybmByZ2JhKCR7eC5qb2luKCl9KWB9ZnVuY3Rpb24gbCh5LHgsYil7Y29uc3QgTz15LmJvdW5kaW5nQm94WzBdO2lmKGIudmVjdG9yKXtsZXR7dmVjdG9yOm0sY29sb3JzOnB9PWI7bS5sZW5ndGg9PT00PyhtPVttWzBdK09bMF0sbVsxXStPWzFdLG1bMl0rT1swXSxtWzNdK09bMV1dLHkuc2V0TGluZWFyR3JhZGllbnQoe3ZlY3RvcjptLGNvbG9yczpwLHR5cGU6eH0pKTptLmxlbmd0aD09PTM/KG09W21bMF0rT1swXSxtWzFdK09bMV0sbVsyXV0seS5zZXRDaXJjdWxhckdyYWRpZW50KHt2ZWN0b3I6bSxjb2xvcnM6cCx0eXBlOnh9KSk6KG09W21bMF0rT1swXSxtWzFdK09bMV0sbVsyXSxtWzNdK09bMF0sbVs0XStPWzFdLG1bNV1dLHkuc2V0UmFkaWFsR3JhZGllbnQoe3ZlY3RvcjptLGNvbG9yczpwLHR5cGU6eH0pKX1lbHNlIHkuZ3JhZGllbnQmJnkuZ3JhZGllbnRbeF0mJihkZWxldGUgeS5ncmFkaWVudFt4XSxkZWxldGUgeS51bmlmb3Jtcy51X3JhZGlhbEdyYWRpZW50VmVjdG9yKX1mdW5jdGlvbiB1KHkse2NvbG9yOngscnVsZTpiPSJub256ZXJvIn0pe3JldHVybiBsKHksImZpbGwiLHgpLHgudmVjdG9yfHx5LnNldEZpbGwoe2NvbG9yOngscnVsZTpifSkseX1mdW5jdGlvbiBNKHkse2NvbG9yOngsbGluZVdpZHRoOmIsbGluZUNhcDpPLGxpbmVKb2luOm0sbGluZURhc2g6cCxsaW5lRGFzaE9mZnNldDpuLG1pdGVyTGltaXQ6YSxyb3VuZFNlZ21lbnRzOml9KXtsKHksInN0cm9rZSIseCkseC52ZWN0b3ImJih4PVswLDAsMCwxXSkseS5zZXRTdHJva2Uoe2NvbG9yOngsdGhpY2tuZXNzOmIsY2FwOk8sam9pbjptLG1pdGVyTGltaXQ6YSxsaW5lRGFzaDpwLGxpbmVEYXNoT2Zmc2V0Om4scm91bmRTZWdtZW50czppfSl9Y2xhc3MgZiBleHRlbmRzIEFycmF5e2NvbnN0cnVjdG9yKHg9MCxiPTAsTz0wLG09MCl7cmV0dXJuIEFycmF5LmlzQXJyYXkoeCkmJihbeCxiLE8sbV09eCksdHlwZW9mIHg9PSJzdHJpbmciJiYoW3gsYixPLG1dPXMoKSh4KSx4Lz0yNTUsYi89MjU1LE8vPTI1NSksc3VwZXIoeCxiLE8sbSksdGhpc31nZXQgcigpe3JldHVybiBNYXRoLnJvdW5kKHRoaXNbMF0qMjU1KX1zZXQgcih4KXt0aGlzWzBdPXgvMjU1fWdldCBnKCl7cmV0dXJuIE1hdGgucm91bmQodGhpc1sxXSoyNTUpfXNldCBnKHgpe3RoaXNbMV09eC8yNTV9Z2V0IGIoKXtyZXR1cm4gTWF0aC5yb3VuZCh0aGlzWzJdKjI1NSl9c2V0IGIoeCl7dGhpc1syXT14LzI1NX1nZXQgYSgpe3JldHVybiB0aGlzWzNdfXNldCBhKHgpe3RoaXNbM109eH1nZXQgaGV4KCl7Y29uc3QgeD1gMCR7dGhpcy5yLnRvU3RyaW5nKDE2KX1gLnNsaWNlKC0yKSxiPWAwJHt0aGlzLmcudG9TdHJpbmcoMTYpfWAuc2xpY2UoLTIpLE89YDAke3RoaXMuYi50b1N0cmluZygxNil9YC5zbGljZSgtMik7bGV0IG07cmV0dXJuIHRoaXMuYTwxJiYobT1NYXRoLnJvdW5kKHRoaXNbM10qMjU1KSxtPWAwJHttLnRvU3RyaW5nKDE2KX1gLnNsaWNlKC0yKSksYCMke3h9JHtifSR7T30ke218fCIifWB9Z2V0IHJnYmEoKXtyZXR1cm5gcmdiYSgke3RoaXMucn0sJHt0aGlzLmd9LCR7dGhpcy5ifSwke3RoaXMuYX0pYH1mcm9tQ29sb3IoeCl7cmV0dXJuIHR5cGVvZiB4PT0ic3RyaW5nIiYmKHg9cygpKHgpLHhbMF0vPTI1NSx4WzFdLz0yNTUseFsyXS89MjU1KSx0aGlzWzBdPXhbMF0sdGhpc1sxXT14WzFdLHRoaXNbMl09eFsyXSx0aGlzWzNdPXhbM10sdGhpc319fSxmdW5jdGlvbihjLGUsdCl7dC5yKGUpLHQuZChlLCJjcmVhdGVSYWRpdXNCb3giLGZ1bmN0aW9uKCl7cmV0dXJuIHN9KSx0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gcihnLHYsaCxsLHUsTT0ibGVmdFRvcCIpe2NvbnN0IGY9LjU1MjI4NDgseT1sLzIqZix4PXUvMipmLGI9ditsLE89aCt1LG09ditsLzIscD1oK3UvMjtNPT09ImxlZnRUb3AiPyhnLm1vdmVUbyh2LHApLGcuYmV6aWVyQ3VydmVUbyh2LHAteCxtLXksaCxtLGgpKTpNPT09InJpZ2h0VG9wIj9nLmJlemllckN1cnZlVG8obSt5LGgsYixwLXgsYixwKTpNPT09InJpZ2h0Qm90dG9tIj9nLmJlemllckN1cnZlVG8oYixwK3gsbSt5LE8sbSxPKTpNPT09ImxlZnRCb3R0b20iJiZnLmJlemllckN1cnZlVG8obS15LE8sdixwK3gsdixwKX1mdW5jdGlvbiBzKGcsW3YsaCxsLHVdLE0pe2lmKCFNfHxBcnJheS5pc0FycmF5KE0pJiZNLmV2ZXJ5KGY9PmY9PT0wKSlnLmJlZ2luUGF0aCgpLGcucmVjdCh2LGgsbCx1KTtlbHNle3R5cGVvZiBNPT0ibnVtYmVyIiYmKE09QXJyYXkoOCkuZmlsbChNKSk7Y29uc3RbZix5LHgsYixPLG0scCxuXT1NLm1hcCgoYSxpKT0+aSUyP01hdGgubWluKGEsdS8yKTpNYXRoLm1pbihhLGwvMikpO2cuYmVnaW5QYXRoKCksZy5tb3ZlVG8odixoK3kpLHIoZyx2LGgsZioyLHkqMiwibGVmdFRvcCIpLGcubGluZVRvKHYrbC14LGgpLHIoZyx2K2wteCoyLGgseCoyLGIqMiwicmlnaHRUb3AiKSxnLmxpbmVUbyh2K2wsaCt1LW0pLHIoZyx2K2wtTyoyLGgrdS1tKjIsTyoyLG0qMiwicmlnaHRCb3R0b20iKSxnLmxpbmVUbyh2K3AsaCt1KSxyKGcsdixoK3UtbioyLHAqMixuKjIsImxlZnRCb3R0b20iKSxnLmNsb3NlUGF0aCgpfXJldHVybiBnfX0sZnVuY3Rpb24oYyxlLHQpe3QucihlKSx0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSksZS5kZWZhdWx0PWZ1bmN0aW9uKHIscyl7aWYoIXIpcmV0dXJue3g6MCx5OjAsd2lkdGg6MCxoZWlnaHQ6MCxsZWZ0OjAsdG9wOjAscmlnaHQ6MCxib3R0b206MH07Y29uc3RbW2csdl0sW2gsbF1dPXIsdT1nKnNbMF0rdipzWzJdK3NbNF0sTT1nKnNbMV0rdipzWzNdK3NbNV0sZj1oKnNbMF0rdipzWzJdK3NbNF0seT1oKnNbMV0rdipzWzNdK3NbNV0seD1oKnNbMF0rbCpzWzJdK3NbNF0sYj1oKnNbMV0rbCpzWzNdK3NbNV0sTz1nKnNbMF0rbCpzWzJdK3NbNF0sbT1nKnNbMV0rbCpzWzNdK3NbNV0scD1NYXRoLm1pbih1LGYseCxPKSxuPU1hdGgubWluKE0seSxiLG0pLGE9TWF0aC5tYXgodSxmLHgsTyksaT1NYXRoLm1heChNLHksYixtKTtyZXR1cm57eDpwLHk6bix3aWR0aDphLXAsaGVpZ2h0OmktbixsZWZ0OnAsdG9wOm4scmlnaHQ6YSxib3R0b206aX19fSxmdW5jdGlvbihjLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiB1fSk7dmFyIHI9dCgyMTgpLHM9dCgyMTkpLGc9dCgyMjUpLHY9dCgyMTMpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBoKE0sZix5KXtyZXR1cm4gZiBpbiBNP09iamVjdC5kZWZpbmVQcm9wZXJ0eShNLGYse3ZhbHVlOnksZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTpNW2ZdPXksTX1jb25zdCBsPVN5bWJvbCgidGV4dHVyZVRhc2siKTtjbGFzcyB1IGV4dGVuZHMgcy5kZWZhdWx0e2NvbnN0cnVjdG9yKGY9e30pe3R5cGVvZiBmPT0ic3RyaW5nIiYmKGY9e3RleHR1cmU6Zn0pLHN1cGVyKGYpfWdldCBjb250ZW50U2l6ZSgpe2xldFtmLHldPXN1cGVyLmNvbnRlbnRTaXplO2NvbnN0e3dpZHRoOngsaGVpZ2h0OmJ9PXRoaXMuYXR0cmlidXRlcztpZih4PT1udWxsfHxiPT1udWxsKXtjb25zdCBPPXRoaXMudGV4dHVyZUltYWdlLG09dGhpcy5hdHRyaWJ1dGVzLnRleHR1cmVSZWN0LHA9dGhpcy5hdHRyaWJ1dGVzLnNvdXJjZVJlY3Q7aWYobSl4PT1udWxsJiYoZj1tWzBdK21bMl0pLGI9PW51bGwmJih5PW1bMV0rbVszXSk7ZWxzZSBpZihwKXtjb25zdCBuPXRoaXMubGF5ZXI/dGhpcy5sYXllci5kaXNwbGF5UmF0aW86MTt4PT1udWxsJiYoZj1wWzJdL24pLGI9PW51bGwmJih5PXBbM10vbil9ZWxzZSBpZihPKXtjb25zdCBuPXRoaXMubGF5ZXI/dGhpcy5sYXllci5kaXNwbGF5UmF0aW86MTt4PT1udWxsJiYoZj1PLndpZHRoL24pLGI9PW51bGwmJih5PU8uaGVpZ2h0L24pfX1yZXR1cm5bZix5XX1nZXQgdGV4dHVyZUltYWdlUmVhZHkoKXtyZXR1cm4gdGhpc1tsXXx8UHJvbWlzZS5yZXNvbHZlKCl9ZHJhdyhmPVtdKXtzdXBlci5kcmF3KGYpO2NvbnN0IHk9dGhpcy5tZXNoO3JldHVybiB5JiZPYmplY3Qoci5kcmF3VGV4dHVyZSkodGhpcyx5KSxmfW9uUHJvcGVydHlDaGFuZ2UoZix5LHgpe2lmKHN1cGVyLm9uUHJvcGVydHlDaGFuZ2UoZix5LHgpLGY9PT0idGV4dHVyZSImJih0aGlzW2xdPU9iamVjdChyLmFwcGx5VGV4dHVyZSkodGhpcyx5LCEwKSksZj09PSJ0ZXh0dXJlUmVjdCIpe2NvbnN0e3dpZHRoOmIsaGVpZ2h0Ok99PXRoaXMuYXR0cmlidXRlczsoYj09bnVsbHx8Tz09bnVsbCkmJnRoaXMudXBkYXRlQ29udG91cnMoKX19fWgodSwiQXR0ciIsZy5kZWZhdWx0KSx2LmRlZmF1bHQucmVnaXN0ZXJOb2RlKHUsInNwcml0ZSIpfSxmdW5jdGlvbihjLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBofSk7dmFyIHI9dCgyMjApO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCBzPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZURlZmF1bHQiKSxnPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZSIpLHY9U3ltYm9sLmZvcigic3ByaXRlanNfZ2V0QXR0cmlidXRlIik7Y2xhc3MgaCBleHRlbmRzIHIuZGVmYXVsdHtjb25zdHJ1Y3Rvcih1KXtzdXBlcih1KSx0aGlzW3NdKHt0ZXh0dXJlOnZvaWQgMCx0ZXh0dXJlUmVjdDp2b2lkIDAsdGV4dHVyZVJlcGVhdDohMSxzb3VyY2VSZWN0OnZvaWQgMH0pfWdldCB0ZXh0dXJlKCl7cmV0dXJuIHRoaXNbdl0oInRleHR1cmUiKX1zZXQgdGV4dHVyZSh1KXt0aGlzW2ddKCJ0ZXh0dXJlIix1KX1nZXQgdGV4dHVyZVJlY3QoKXtyZXR1cm4gdGhpc1t2XSgidGV4dHVyZVJlY3QiKX1zZXQgdGV4dHVyZVJlY3QodSl7dGhpc1tnXSgidGV4dHVyZVJlY3QiLHUpfWdldCBzb3VyY2VSZWN0KCl7cmV0dXJuIHRoaXNbdl0oInNvdXJjZVJlY3QiKX1zZXQgc291cmNlUmVjdCh1KXt0aGlzW2ddKCJzb3VyY2VSZWN0Iix1KX1nZXQgdGV4dHVyZVJlcGVhdCgpe3JldHVybiB0aGlzW3ZdKCJ0ZXh0dXJlUmVwZWF0Iil9c2V0IHRleHR1cmVSZXBlYXQodSl7dGhpc1tnXSgidGV4dHVyZVJlcGVhdCIsISF1KX19fSxmdW5jdGlvbihjLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBifSk7dmFyIHI9dCgxMikscz10KDIyNyksZz10Lm4ocyksdj10KDcwKSxoPXQoMjI4KSxsPXQoMjIxKSx1PXQoMjE4KSxNPXQoMjEzKSxmPXQoMjIzKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24geShPLG0scCl7cmV0dXJuIG0gaW4gTz9PYmplY3QuZGVmaW5lUHJvcGVydHkoTyxtLHt2YWx1ZTpwLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6T1ttXT1wLE99Y29uc3QgeD1TeW1ib2woIm1lc2giKTtjbGFzcyBiIGV4dGVuZHMgdi5kZWZhdWx0e2NvbnN0cnVjdG9yKG09e30pe3R5cGVvZiBtPT0ic3RyaW5nIiYmKG09e2Q6bX0pLHN1cGVyKG0pLHRoaXMuZWZmZWN0cz17ZChwLG4sYSxpLG8pe2NvbnN0IFQ9KGEtaSkvKG8taSk7aWYoVDw9MClyZXR1cm4gcDtpZihUPj0xKXJldHVybiBuO2NvbnN0IFA9Zy5hLl9wcmVwcm9jZXNzaW5nKGcuYS5wYXRoMnNoYXBlcyhwKSxnLmEucGF0aDJzaGFwZXMobikpLEM9Zy5hLl9sZXJwKC4uLlAsVClbMF07cmV0dXJuIEMucmVkdWNlKChBLEwpPT5gJHtBfSR7TC5zbGljZSgyKS5qb2luKCIgIil9IGAsYE0ke0NbMF1bMF19ICR7Q1swXVsxXX1DYCkudHJpbSgpfX19Z2V0IGlzVmlzaWJsZSgpe3JldHVybiEhdGhpcy5kfWdldCBtZXNoKCl7aWYodGhpcy5hdHRyaWJ1dGVzLmRpc3BsYXk9PT0ibm9uZSIpcmV0dXJuIG51bGw7Y29uc3QgbT10aGlzLnBhdGg7aWYobSl7bGV0IHA9dGhpc1t4XTtpZihwKXAucGF0aCE9PW0mJihwLmNvbnRvdXJzPW0uY29udG91cnMscC5wYXRoPW0pO2Vsc2V7cD1uZXcgci5NZXNoMkQodGhpcy5wYXRoKSxwLnBhdGg9bTtjb25zdCBhPXRoaXMuYXR0cmlidXRlcy5maWxsQ29sb3IsaT10aGlzLmF0dHJpYnV0ZXMuZmlsbFJ1bGU7YSYmT2JqZWN0KGwuc2V0RmlsbENvbG9yKShwLHtjb2xvcjphLHJ1bGU6aX0pO2NvbnN0IG89dGhpcy5hdHRyaWJ1dGVzLmxpbmVXaWR0aCxUPXRoaXMuYXR0cmlidXRlcy5zdHJva2VDb2xvcjtpZihUJiZvPjApe2NvbnN0e2xpbmVDYXA6QyxsaW5lSm9pbjpJLG1pdGVyTGltaXQ6QSxsaW5lRGFzaDpMLGxpbmVEYXNoT2Zmc2V0OkQscm91bmRTZWdtZW50czpSfT10aGlzLmF0dHJpYnV0ZXM7T2JqZWN0KGwuc2V0U3Ryb2tlQ29sb3IpKHAse2NvbG9yOlQsbGluZVdpZHRoOm8sbGluZUNhcDpDLGxpbmVKb2luOkksbWl0ZXJMaW1pdDpBLGxpbmVEYXNoOkwsbGluZURhc2hPZmZzZXQ6RCxyb3VuZFNlZ21lbnRzOlJ9KX10aGlzW3hdPXA7Y29uc3QgUD10aGlzLmF0dHJpYnV0ZXMuY2xpcFBhdGg7UCYmdGhpc1t4XS5zZXRDbGlwUGF0aChQKX1jb25zdCBuPXRoaXMub3BhY2l0eTtyZXR1cm4gcC5nZXRPcGFjaXR5KCkhPT1uJiZwLnNldE9wYWNpdHkobikscC5zZXRUcmFuc2Zvcm0oLi4udGhpcy5yZW5kZXJNYXRyaXgpLHB9cmV0dXJuIG51bGx9Z2V0IG9yaWdpbmFsQ29udGVudFJlY3QoKXtpZih0aGlzLnBhdGgpe2NvbnN0IG09dGhpcy5wYXRoLmJvdW5kaW5nQm94O3JldHVyblttWzBdWzBdLG1bMF1bMV0sbVsxXVswXS1tWzBdWzBdLG1bMV1bMV0tbVswXVsxXV19cmV0dXJuWzAsMCwwLDBdfWdldCBvcmlnaW5hbENsaWVudFJlY3QoKXtpZih0aGlzLm1lc2gpe2NvbnN0IG09dGhpcy5tZXNoLmJvdW5kaW5nQm94O3JldHVyblttWzBdWzBdLG1bMF1bMV0sbVsxXVswXS1tWzBdWzBdLG1bMV1bMV0tbVswXVsxXV19cmV0dXJuWzAsMCwwLDBdfWdldCBvcmlnaW5hbENsaWVudENlbnRlcigpe3JldHVybiB0aGlzLm1lc2g/dGhpcy5tZXNoLmJvdW5kaW5nQ2VudGVyOlswLDBdfXNldCBkKG0pe3RoaXMuYXR0cmlidXRlcy5kPW19Z2V0IGQoKXtyZXR1cm4gdGhpcy5hdHRyaWJ1dGVzLmR9ZHJhdyhtPVtdKXtzdXBlci5kcmF3KG0pO2NvbnN0IHA9dGhpcy5tZXNoO3JldHVybiBwJiZPYmplY3QodS5kcmF3VGV4dHVyZSkodGhpcyxwKSxtfWdldEJvdW5kaW5nQ2xpZW50UmVjdCgpe2xldCBtPW51bGw7cmV0dXJuIHRoaXMubWVzaCYmKG09dGhpcy5tZXNoLmJvdW5kaW5nQm94KSxPYmplY3QoZi5kZWZhdWx0KShtLHRoaXMucmVuZGVyTWF0cml4KX1nZXRQYXRoTGVuZ3RoKCl7cmV0dXJuIHRoaXMubWVzaD90aGlzLm1lc2guZ2V0VG90YWxMZW5ndGgoKTowfWdldFBvaW50QXRMZW5ndGgobSl7aWYodGhpcy5tZXNoKXtjb25zdCBwPXRoaXMubWVzaC5nZXRQb2ludEF0TGVuZ3RoKG0pO2lmKHApcmV0dXJuW3AueCxwLnldfXJldHVyblswLDBdfW9uUHJvcGVydHlDaGFuZ2UobSxwLG4pe2lmKHN1cGVyLm9uUHJvcGVydHlDaGFuZ2UobSxwLG4pLChtPT09ImQifHxtPT09Im5vcm1hbGl6ZSIpJiZ0aGlzLnVwZGF0ZUNvbnRvdXJzKCksdGhpc1t4XSYmKG09PT0iZmlsbENvbG9yInx8bT09PSJmaWxsUnVsZSIpKXtjb25zdHtmaWxsQ29sb3I6YSxmaWxsUnVsZTppfT10aGlzLmF0dHJpYnV0ZXM7T2JqZWN0KGwuc2V0RmlsbENvbG9yKSh0aGlzW3hdLHtjb2xvcjphLHJ1bGU6aX0pfWlmKHRoaXNbeF0mJihtPT09InN0cm9rZUNvbG9yInx8bT09PSJsaW5lV2lkdGgifHxtPT09ImxpbmVDYXAifHxtPT09ImxpbmVKb2luInx8bT09PSJsaW5lRGFzaCJ8fG09PT0ibGluZURhc2hPZmZzZXQifHxtPT09InJvdW5kU2VnbWVudHMiKSl7Y29uc3R7c3Ryb2tlQ29sb3I6YSxsaW5lV2lkdGg6aX09dGhpcy5hdHRyaWJ1dGVzO2lmKGEmJmk+MCl7Y29uc3R7bGluZUNhcDpvLGxpbmVKb2luOlQsbGluZURhc2g6UCxsaW5lRGFzaE9mZnNldDpDLG1pdGVyTGltaXQ6SSxyb3VuZFNlZ21lbnRzOkF9PXRoaXMuYXR0cmlidXRlcztPYmplY3QobC5zZXRTdHJva2VDb2xvcikodGhpc1t4XSx7Y29sb3I6YSxsaW5lQ2FwOm8sbGluZUpvaW46VCxsaW5lV2lkdGg6aSxsaW5lRGFzaDpQLGxpbmVEYXNoT2Zmc2V0OkMsbWl0ZXJMaW1pdDpJLHJvdW5kU2VnbWVudHM6QX0pfX10aGlzW3hdJiZtPT09ImNsaXBQYXRoIiYmdGhpc1t4XS5zZXRDbGlwUGF0aChwKSxtPT09InRleHR1cmUiJiZPYmplY3QodS5hcHBseVRleHR1cmUpKHRoaXMscCl9dXBkYXRlQ29udG91cnMoKXt0aGlzLnBhdGg9bmV3IHIuRmlndXJlMkQsdGhpcy5wYXRoLmFkZFBhdGgodGhpcy5hdHRyaWJ1dGVzLmQpLHRoaXMuYXR0cmlidXRlcy5ub3JtYWxpemUmJnRoaXMucGF0aC5ub3JtYWxpemUoLi4udGhpcy5wYXRoLmJvdW5kaW5nQ2VudGVyKX19eShiLCJBdHRyIixoLmRlZmF1bHQpLE0uZGVmYXVsdC5yZWdpc3Rlck5vZGUoYiwicGF0aCIpfSxmdW5jdGlvbihjLGUsdCl7KGZ1bmN0aW9uKHIscyl7Yy5leHBvcnRzPXMoKX0pKHRoaXMsZnVuY3Rpb24oKXt2YXIgcj1mdW5jdGlvbigpe2Z1bmN0aW9uIEwoRCxSKXt2YXIgUz1bXSxCPSEwLHc9ITEsSD12b2lkIDA7dHJ5e2Zvcih2YXIgSj1EW1N5bWJvbC5pdGVyYXRvcl0oKSxxOyEoQj0ocT1KLm5leHQoKSkuZG9uZSkmJihTLnB1c2gocS52YWx1ZSksIShSJiZTLmxlbmd0aD09PVIpKTtCPSEwKTt9Y2F0Y2goVyl7dz0hMCxIPVd9ZmluYWxseXt0cnl7IUImJkoucmV0dXJuJiZKLnJldHVybigpfWZpbmFsbHl7aWYodyl0aHJvdyBIfX1yZXR1cm4gU31yZXR1cm4gZnVuY3Rpb24oRCxSKXtpZihBcnJheS5pc0FycmF5KEQpKXJldHVybiBEO2lmKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoRCkpcmV0dXJuIEwoRCxSKTt0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlIil9fSgpLHM9TWF0aC5QSSoyLGc9ZnVuY3Rpb24oRCxSLFMsQix3LEgsSil7dmFyIHE9RC54LFc9RC55O3EqPVIsVyo9Uzt2YXIgRz1CKnEtdypXLFE9dypxK0IqVztyZXR1cm57eDpHK0gseTpRK0p9fSx2PWZ1bmN0aW9uKEQsUil7dmFyIFM9MS4zMzMzMzMzMzMzMzMzMzMzKk1hdGgudGFuKFIvNCksQj1NYXRoLmNvcyhEKSx3PU1hdGguc2luKEQpLEg9TWF0aC5jb3MoRCtSKSxKPU1hdGguc2luKEQrUik7cmV0dXJuW3t4OkItdypTLHk6dytCKlN9LHt4OkgrSipTLHk6Si1IKlN9LHt4OkgseTpKfV19LGg9ZnVuY3Rpb24oRCxSLFMsQil7dmFyIHc9RCpCLVIqUzwwPy0xOjEsSD1NYXRoLnNxcnQoRCpEK1IqUiksSj1NYXRoLnNxcnQoRCpEK1IqUikscT1EKlMrUipCLFc9cS8oSCpKKTtyZXR1cm4gVz4xJiYoVz0xKSxXPC0xJiYoVz0tMSksdypNYXRoLmFjb3MoVyl9LGw9ZnVuY3Rpb24oRCxSLFMsQix3LEgsSixxLFcsRyxRLHR0KXt2YXIgXz1NYXRoLnBvdyh3LDIpLHN0PU1hdGgucG93KEgsMiksaz1NYXRoLnBvdyhRLDIpLGN0PU1hdGgucG93KHR0LDIpLGZ0PV8qc3QtXypjdC1zdCprO2Z0PDAmJihmdD0wKSxmdC89XypjdCtzdCprLGZ0PU1hdGguc3FydChmdCkqKEo9PT1xPy0xOjEpO3ZhciBVPWZ0KncvSCp0dCxGPWZ0Ki1IL3cqUSxWPUcqVS1XKkYrKEQrUykvMixYPVcqVStHKkYrKFIrQikvMixqPShRLVUpL3csej0odHQtRikvSCxkPSgtUS1VKS93LEU9KC10dC1GKS9ILE49aCgxLDAsaix6KSwkPWgoaix6LGQsRSk7cmV0dXJuIHE9PT0wJiYkPjAmJigkLT1zKSxxPT09MSYmJDwwJiYoJCs9cyksW1YsWCxOLCRdfSx1PWZ1bmN0aW9uKEQpe3ZhciBSPUQucHgsUz1ELnB5LEI9RC5jeCx3PUQuY3ksSD1ELnJ4LEo9RC5yeSxxPUQueEF4aXNSb3RhdGlvbixXPXE9PT12b2lkIDA/MDpxLEc9RC5sYXJnZUFyY0ZsYWcsUT1HPT09dm9pZCAwPzA6Ryx0dD1ELnN3ZWVwRmxhZyxfPXR0PT09dm9pZCAwPzA6dHQsc3Q9W107aWYoSD09PTB8fEo9PT0wKXJldHVybltdO3ZhciBrPU1hdGguc2luKFcqcy8zNjApLGN0PU1hdGguY29zKFcqcy8zNjApLGZ0PWN0KihSLUIpLzIrayooUy13KS8yLFU9LWsqKFItQikvMitjdCooUy13KS8yO2lmKGZ0PT09MCYmVT09PTApcmV0dXJuW107SD1NYXRoLmFicyhIKSxKPU1hdGguYWJzKEopO3ZhciBGPU1hdGgucG93KGZ0LDIpL01hdGgucG93KEgsMikrTWF0aC5wb3coVSwyKS9NYXRoLnBvdyhKLDIpO0Y+MSYmKEgqPU1hdGguc3FydChGKSxKKj1NYXRoLnNxcnQoRikpO3ZhciBWPWwoUixTLEIsdyxILEosUSxfLGssY3QsZnQsVSksWD1yKFYsNCksaj1YWzBdLHo9WFsxXSxkPVhbMl0sRT1YWzNdLE49TWF0aC5tYXgoTWF0aC5jZWlsKE1hdGguYWJzKEUpLyhzLzQpKSwxKTtFLz1OO2Zvcih2YXIgJD0wOyQ8TjskKyspc3QucHVzaCh2KGQsRSkpLGQrPUU7cmV0dXJuIHN0Lm1hcChmdW5jdGlvbihLKXt2YXIgWT1nKEtbMF0sSCxKLGN0LGssaix6KSxaPVkueCxldD1ZLnkscnQ9ZyhLWzFdLEgsSixjdCxrLGoseiksYXQ9cnQueCxsdD1ydC55LGl0PWcoS1syXSxILEosY3QsayxqLHopLG50PWl0Lngsb3Q9aXQueTtyZXR1cm57eDE6Wix5MTpldCx4MjphdCx5MjpsdCx4Om50LHk6b3R9fSl9LE09e2E6NyxjOjYsaDoxLGw6MixtOjIscTo0LHM6NCx0OjIsdjoxLHo6MH0sZj0vKFthc3R2enFtaGxjXSkoW15hc3R2enFtaGxjXSopL2lnO2Z1bmN0aW9uIHkoTCl7dmFyIEQ9W107cmV0dXJuIEwucmVwbGFjZShmLGZ1bmN0aW9uKFIsUyxCKXt2YXIgdz1TLnRvTG93ZXJDYXNlKCk7Zm9yKEI9YihCKSx3PT0ibSImJkIubGVuZ3RoPjImJihELnB1c2goW1NdLmNvbmNhdChCLnNwbGljZSgwLDIpKSksdz0ibCIsUz1TPT0ibSI/ImwiOiJMIik7Oyl7aWYoQi5sZW5ndGg9PU1bd10pcmV0dXJuIEIudW5zaGlmdChTKSxELnB1c2goQik7aWYoQi5sZW5ndGg8TVt3XSl0aHJvdyBuZXcgRXJyb3IoIm1hbGZvcm1lZCBwYXRoIGRhdGEiKTtELnB1c2goW1NdLmNvbmNhdChCLnNwbGljZSgwLE1bd10pKSl9fSksRH12YXIgeD0vLT9bMC05XSpcLj9bMC05XSsoPzplWy0rXT9cZCspPy9pZztmdW5jdGlvbiBiKEwpe3ZhciBEPUwubWF0Y2goeCk7cmV0dXJuIEQ/RC5tYXAoTnVtYmVyKTpbXX1mdW5jdGlvbiBPKEwpe3ZhciBEPUxbMF1bMF0sUj1MWzBdWzFdLFM9RCxCPVI7cmV0dXJuIEwuZm9yRWFjaChmdW5jdGlvbih3KXt2YXIgSD13WzBdLEo9d1syXSxxPXdbNF0sVz13WzZdLEc9d1sxXSxRPXdbM10sdHQ9d1s1XSxfPXdbN107RD1NYXRoLm1pbihELEgsSixxLFcpLFI9TWF0aC5taW4oUixHLFEsdHQsXyksUz1NYXRoLm1heChTLEgsSixxLFcpLEI9TWF0aC5tYXgoQixHLFEsdHQsXyl9KSxbRCxSLFMsQl19ZnVuY3Rpb24gbShMLEQpe3JldHVybiBNYXRoLnNxcnQoTWF0aC5wb3coTFswXS1EWzBdLDIpK01hdGgucG93KExbMV0tRFsxXSwyKSkrTWF0aC5zcXJ0KE1hdGgucG93KExbMl0tRFsyXSwyKStNYXRoLnBvdyhMWzNdLURbM10sMikpfWZ1bmN0aW9uIHAoTCxEKXt2YXIgUj1MWzBdLFM9TFsyXSxCPUxbNF0sdz1MWzZdLEg9TFsxXSxKPUxbM10scT1MWzVdLFc9TFs3XSxHPURbMF0sUT1EWzJdLHR0PURbNF0sXz1EWzZdLHN0PURbMV0saz1EWzNdLGN0PURbNV0sZnQ9RFs3XTtyZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KEctUiwyKStNYXRoLnBvdyhzdC1ILDIpKStNYXRoLnNxcnQoTWF0aC5wb3coUS1TLDIpK01hdGgucG93KGstSiwyKSkrTWF0aC5zcXJ0KE1hdGgucG93KHR0LUIsMikrTWF0aC5wb3coY3QtcSwyKSkrTWF0aC5zcXJ0KE1hdGgucG93KF8tdywyKStNYXRoLnBvdyhmdC1XLDIpKX1mdW5jdGlvbiBuKEwsRCl7dmFyIFI9aShMLmxlbmd0aCksUz1bXTtSLmZvckVhY2goZnVuY3Rpb24odyl7dmFyIEg9MCxKPTA7dy5mb3JFYWNoKGZ1bmN0aW9uKHEpe0grPXAoTFtxXSxEW0orK10pfSksUy5wdXNoKHtpbmRleDp3LGRpc3RhbmNlOkh9KX0pLFMuc29ydChmdW5jdGlvbih3LEgpe3JldHVybiB3LmRpc3RhbmNlLUguZGlzdGFuY2V9KTt2YXIgQj1bXTtyZXR1cm4gU1swXS5pbmRleC5mb3JFYWNoKGZ1bmN0aW9uKHcpe0IucHVzaChMW3ddKX0pLEJ9ZnVuY3Rpb24gYShMLEQpe3ZhciBSPW8oTC5sZW5ndGgpLFM9W107Ui5mb3JFYWNoKGZ1bmN0aW9uKHcpe3ZhciBIPTA7dy5mb3JFYWNoKGZ1bmN0aW9uKEope0grPW0oTyhMW0pdKSxPKERbSl0pKX0pLFMucHVzaCh7aW5kZXg6dyxkaXN0YW5jZTpIfSl9KSxTLnNvcnQoZnVuY3Rpb24odyxIKXtyZXR1cm4gdy5kaXN0YW5jZS1ILmRpc3RhbmNlfSk7dmFyIEI9W107cmV0dXJuIFNbMF0uaW5kZXguZm9yRWFjaChmdW5jdGlvbih3KXtCLnB1c2goTFt3XSl9KSxCfWZ1bmN0aW9uIGkoTCl7Zm9yKHZhciBEPVtdLFI9MDtSPEw7UisrKXtmb3IodmFyIFM9W10sQj0wO0I8TDtCKyspe3ZhciB3PUIrUjt3PkwtMSYmKHctPUwpLFNbd109Qn1ELnB1c2goUyl9cmV0dXJuIER9ZnVuY3Rpb24gbyhMKXtmb3IodmFyIEQ9W10sUj0wO1I8TDtSKyspRC5wdXNoKFIpO3JldHVybiBUKEQpfWZ1bmN0aW9uIFQoTCl7dmFyIEQ9W10sUj1bXTtmdW5jdGlvbiBTKEIpe3ZhciB3LEg7Zm9yKHc9MDt3PEIubGVuZ3RoO3crKylIPUIuc3BsaWNlKHcsMSlbMF0sUi5wdXNoKEgpLEIubGVuZ3RoPT0wJiZELnB1c2goUi5zbGljZSgpKSxTKEIpLEIuc3BsaWNlKHcsMCxIKSxSLnBvcCgpO3JldHVybiBEfXJldHVybiBTKEwpfXZhciBQPXt9O1AucGFyc2VyPXksUC5sZXJwQ3VydmU9ZnVuY3Rpb24oTCxELFIpe3JldHVybiBQLmxlcnBQb2ludHMoTFswXSxMWzFdLERbMF0sRFsxXSxSKS5jb25jYXQoUC5sZXJwUG9pbnRzKExbMl0sTFszXSxEWzJdLERbM10sUikpLmNvbmNhdChQLmxlcnBQb2ludHMoTFs0XSxMWzVdLERbNF0sRFs1XSxSKSkuY29uY2F0KFAubGVycFBvaW50cyhMWzZdLExbN10sRFs2XSxEWzddLFIpKX0sUC5sZXJwUG9pbnRzPWZ1bmN0aW9uKEwsRCxSLFMsQil7cmV0dXJuW0wrKFItTCkqQixEKyhTLUQpKkJdfSxQLnEyYj1mdW5jdGlvbihMLEQsUixTLEIsdyl7cmV0dXJuW0wsRCwoTCsyKlIpLzMsKEQrMipTKS8zLChCKzIqUikvMywodysyKlMpLzMsQix3XX0sUC5wYXRoMnNoYXBlcz1mdW5jdGlvbihMKXtmb3IodmFyIEQ9UC5wYXJzZXIoTCksUj0wLFM9MCxCPTAsdz1ELmxlbmd0aCxIPVtdLEo9bnVsbCxxPXZvaWQgMCxXPXZvaWQgMCxHPXZvaWQgMCxRPXZvaWQgMCx0dD12b2lkIDAsXz12b2lkIDAsc3Q9dm9pZCAwO0I8dztCKyspe3ZhciBrPURbQl0sY3Q9a1swXSxmdD1EW0ItMV07c3dpdGNoKGN0KXtjYXNlIm0iOnR0PUgubGVuZ3RoLEhbdHRdPVtdLEo9SFt0dF0sUj1SK2tbMV0sUz1TK2tbMl07YnJlYWs7Y2FzZSJNIjp0dD1ILmxlbmd0aCxIW3R0XT1bXSxKPUhbdHRdLFI9a1sxXSxTPWtbMl07YnJlYWs7Y2FzZSJsIjpKLnB1c2goW1IsUyxSLFMsUixTLFIra1sxXSxTK2tbMl1dKSxSKz1rWzFdLFMrPWtbMl07YnJlYWs7Y2FzZSJMIjpKLnB1c2goW1IsUyxrWzFdLGtbMl0sa1sxXSxrWzJdLGtbMV0sa1syXV0pLFI9a1sxXSxTPWtbMl07YnJlYWs7Y2FzZSJoIjpKLnB1c2goW1IsUyxSLFMsUixTLFIra1sxXSxTXSksUis9a1sxXTticmVhaztjYXNlIkgiOkoucHVzaChbUixTLGtbMV0sUyxrWzFdLFMsa1sxXSxTXSksUj1rWzFdO2JyZWFrO2Nhc2UidiI6Si5wdXNoKFtSLFMsUixTLFIsUyxSLFMra1sxXV0pLFMrPWtbMV07YnJlYWs7Y2FzZSJWIjpKLnB1c2goW1IsUyxSLGtbMV0sUixrWzFdLFIsa1sxXV0pLFM9a1sxXTticmVhaztjYXNlIkMiOkoucHVzaChbUixTLGtbMV0sa1syXSxrWzNdLGtbNF0sa1s1XSxrWzZdXSksUj1rWzVdLFM9a1s2XTticmVhaztjYXNlIlMiOmZ0WzBdPT09IkMifHxmdFswXT09PSJjIj9KLnB1c2goW1IsUyxSK2Z0WzVdLWZ0WzNdLFMrZnRbNl0tZnRbNF0sa1sxXSxrWzJdLGtbM10sa1s0XV0pOihmdFswXT09PSJTInx8ZnRbMF09PT0icyIpJiZKLnB1c2goW1IsUyxSK2Z0WzNdLWZ0WzFdLFMrZnRbNF0tZnRbMl0sa1sxXSxrWzJdLGtbM10sa1s0XV0pLFI9a1szXSxTPWtbNF07YnJlYWs7Y2FzZSJjIjpKLnB1c2goW1IsUyxSK2tbMV0sUytrWzJdLFIra1szXSxTK2tbNF0sUitrWzVdLFMra1s2XV0pLFI9UitrWzVdLFM9UytrWzZdO2JyZWFrO2Nhc2UicyI6ZnRbMF09PT0iQyJ8fGZ0WzBdPT09ImMiP0oucHVzaChbUixTLFIrZnRbNV0tZnRbM10sUytmdFs2XS1mdFs0XSxSK2tbMV0sUytrWzJdLFIra1szXSxTK2tbNF1dKTooZnRbMF09PT0iUyJ8fGZ0WzBdPT09InMiKSYmSi5wdXNoKFtSLFMsUitmdFszXS1mdFsxXSxTK2Z0WzRdLWZ0WzJdLFIra1sxXSxTK2tbMl0sUitrWzNdLFMra1s0XV0pLFI9UitrWzNdLFM9UytrWzRdO2JyZWFrO2Nhc2UiYSI6Xz11KHtyeDprWzFdLHJ5OmtbMl0scHg6UixweTpTLHhBeGlzUm90YXRpb246a1szXSxsYXJnZUFyY0ZsYWc6a1s0XSxzd2VlcEZsYWc6a1s1XSxjeDpSK2tbNl0sY3k6UytrWzddfSksc3Q9X1tfLmxlbmd0aC0xXSxfLmZvckVhY2goZnVuY3Rpb24oVSxGKXtGPT09MD9KLnB1c2goW1IsUyxVLngxLFUueTEsVS54MixVLnkyLFUueCxVLnldKTpKLnB1c2goW19bRi0xXS54LF9bRi0xXS55LFUueDEsVS55MSxVLngyLFUueTIsVS54LFUueV0pfSksUj1zdC54LFM9c3QueTticmVhaztjYXNlIkEiOl89dSh7cng6a1sxXSxyeTprWzJdLHB4OlIscHk6Uyx4QXhpc1JvdGF0aW9uOmtbM10sbGFyZ2VBcmNGbGFnOmtbNF0sc3dlZXBGbGFnOmtbNV0sY3g6a1s2XSxjeTprWzddfSksc3Q9X1tfLmxlbmd0aC0xXSxfLmZvckVhY2goZnVuY3Rpb24oVSxGKXtGPT09MD9KLnB1c2goW1IsUyxVLngxLFUueTEsVS54MixVLnkyLFUueCxVLnldKTpKLnB1c2goW19bRi0xXS54LF9bRi0xXS55LFUueDEsVS55MSxVLngyLFUueTIsVS54LFUueV0pfSksUj1zdC54LFM9c3QueTticmVhaztjYXNlIlEiOkoucHVzaChQLnEyYihSLFMsa1sxXSxrWzJdLGtbM10sa1s0XSkpLFI9a1szXSxTPWtbNF07YnJlYWs7Y2FzZSJxIjpKLnB1c2goUC5xMmIoUixTLFIra1sxXSxTK2tbMl0sa1szXStSLGtbNF0rUykpLFIrPWtbM10sUys9a1s0XTticmVhaztjYXNlIlQiOmZ0WzBdPT09IlEifHxmdFswXT09PSJxIj8oRz1SK2Z0WzNdLWZ0WzFdLFE9UytmdFs0XS1mdFsyXSxKLnB1c2goUC5xMmIoUixTLEcsUSxrWzFdLGtbMl0pKSk6KGZ0WzBdPT09IlQifHxmdFswXT09PSJ0IikmJihKLnB1c2goUC5xMmIoUixTLFIrUi1HLFMrUy1RLGtbMV0sa1syXSkpLEc9UitSLUcsUT1TK1MtUSksUj1rWzFdLFM9a1syXTticmVhaztjYXNlInQiOmZ0WzBdPT09IlEifHxmdFswXT09PSJxIj8oRz1SK2Z0WzNdLWZ0WzFdLFE9UytmdFs0XS1mdFsyXSxKLnB1c2goUC5xMmIoUixTLEcsUSxSK2tbMV0sUytrWzJdKSkpOihmdFswXT09PSJUInx8ZnRbMF09PT0idCIpJiYoSi5wdXNoKFAucTJiKFIsUyxSK1ItRyxTK1MtUSxSK2tbMV0sUytrWzJdKSksRz1SK1ItRyxRPVMrUy1RKSxSKz1rWzFdLFMrPWtbMl07YnJlYWs7Y2FzZSJaIjpxPUpbMF1bMF0sVz1KWzBdWzFdLEoucHVzaChbUixTLHEsVyxxLFcscSxXXSk7YnJlYWs7Y2FzZSJ6IjpxPUpbMF1bMF0sVz1KWzBdWzFdLEoucHVzaChbUixTLHEsVyxxLFcscSxXXSk7YnJlYWt9fXJldHVybiBIfSxQLl91cEN1cnZlcz1mdW5jdGlvbihMLEQpe2Zvcih2YXIgUj0wLFM9MCxCPUwubGVuZ3RoO1I8RDtSKyspTC5wdXNoKExbU10uc2xpY2UoMCkpLFMrKyxTPkItMSYmKFMtPUIpfTtmdW5jdGlvbiBDKEwsRCxSLFMsQix3LEgsSixxKXtyZXR1cm57bGVmdDpJKEwsRCxSLFMsQix3LEgsSixxKSxyaWdodDpJKEgsSixCLHcsUixTLEwsRCwxLXEsITApfX1mdW5jdGlvbiBJKEwsRCxSLFMsQix3LEgsSixxLFcpe3ZhciBHPShSLUwpKnErTCxRPShTLUQpKnErRCx0dD0oQi1SKSpxK1IsXz0ody1TKSpxK1Msc3Q9KEgtQikqcStCLGs9KEotdykqcSt3LGN0PSh0dC1HKSpxK0csZnQ9KF8tUSkqcStRLFU9KHN0LXR0KSpxK3R0LEY9KGstXykqcStfLFY9KFUtY3QpKnErY3QsWD0oRi1mdCkqcStmdDtyZXR1cm4gVz9bVixYLGN0LGZ0LEcsUSxMLERdOltMLEQsRyxRLGN0LGZ0LFYsWF19UC5fc3BsaXRDdXJ2ZXM9ZnVuY3Rpb24oTCxEKXtmb3IodmFyIFI9MCxTPTA7UjxEO1IrKyl7dmFyIEI9TFtTXSx3PUMoQlswXSxCWzFdLEJbMl0sQlszXSxCWzRdLEJbNV0sQls2XSxCWzddLC41KTtMLnNwbGljZShTLDEpLEwuc3BsaWNlKFMsMCx3LmxlZnQsdy5yaWdodCksUys9MixTPj1MLmxlbmd0aC0xJiYoUz0wKX19O2Z1bmN0aW9uIEEoTCxEKXtmb3IodmFyIFI9ZnVuY3Rpb24odyl7dmFyIEg9TFtMLmxlbmd0aC0xXSxKPVtdO0guZm9yRWFjaChmdW5jdGlvbihxKXtKLnB1c2gocS5zbGljZSgwKSl9KSxMLnB1c2goSil9LFM9MDtTPEQ7UysrKVIoKX1yZXR1cm4gUC5sZXJwPWZ1bmN0aW9uKEwsRCxSKXtyZXR1cm4gUC5fbGVycChQLnBhdGgyc2hhcGVzKEwpLFAucGF0aDJzaGFwZXMoRCksUil9LFAuTUlNX0NVUlZFU19DT1VOVD0xMDAsUC5fcHJlcHJvY2Vzc2luZz1mdW5jdGlvbihMLEQpe3ZhciBSPUwubGVuZ3RoLFM9RC5sZW5ndGgsQj1KU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KEwpKSx3PUpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoRCkpO3JldHVybiBSPlM/QSh3LFItUyk6UjxTJiZBKEIsUy1SKSxCPWEoQix3KSxCLmZvckVhY2goZnVuY3Rpb24oSCxKKXt2YXIgcT1ILmxlbmd0aCxXPXdbSl0ubGVuZ3RoO3E+Vz9xPFAuTUlNX0NVUlZFU19DT1VOVD8oUC5fc3BsaXRDdXJ2ZXMoSCxQLk1JTV9DVVJWRVNfQ09VTlQtcSksUC5fc3BsaXRDdXJ2ZXMod1tKXSxQLk1JTV9DVVJWRVNfQ09VTlQtVykpOlAuX3NwbGl0Q3VydmVzKHdbSl0scS1XKTpxPFcmJihXPFAuTUlNX0NVUlZFU19DT1VOVD8oUC5fc3BsaXRDdXJ2ZXMoSCxQLk1JTV9DVVJWRVNfQ09VTlQtcSksUC5fc3BsaXRDdXJ2ZXMod1tKXSxQLk1JTV9DVVJWRVNfQ09VTlQtVykpOlAuX3NwbGl0Q3VydmVzKEgsVy1xKSl9KSxCLmZvckVhY2goZnVuY3Rpb24oSCxKKXtCW0pdPW4oSCx3W0pdKX0pLFtCLHddfSxQLl9sZXJwPWZ1bmN0aW9uKEwsRCxSKXt2YXIgUz1bXTtyZXR1cm4gTC5mb3JFYWNoKGZ1bmN0aW9uKEIsdyl7dmFyIEg9W107Qi5mb3JFYWNoKGZ1bmN0aW9uKEoscSl7SC5wdXNoKFAubGVycEN1cnZlKEosRFt3XVtxXSxSKSl9KSxTLnB1c2goSCl9KSxTfSxQLmFuaW1hdGU9ZnVuY3Rpb24oTCl7dmFyIEQ9UC5wYXRoMnNoYXBlcyhMLmZyb20pLFI9UC5wYXRoMnNoYXBlcyhMLnRvKSxTPVAuX3ByZXByb2Nlc3NpbmcoRCxSKSxCPW5ldyBEYXRlLHc9TC5lbmR8fGZ1bmN0aW9uKCl7fSxIPUwucHJvZ3Jlc3N8fGZ1bmN0aW9uKCl7fSxKPUwuYmVnaW58fGZ1bmN0aW9uKCl7fSxxPUwuZWFzaW5nfHxmdW5jdGlvbihfKXtyZXR1cm4gX30sVz1udWxsLEc9bnVsbCxRPUwudGltZTtKKEQpO3ZhciB0dD1mdW5jdGlvbiBfKCl7dmFyIHN0PW5ldyBEYXRlLUI7aWYoc3Q+PVEpe0c9UixIKEcsMSksdyhHKSxjYW5jZWxBbmltYXRpb25GcmFtZShXKTtyZXR1cm59dmFyIGs9cShzdC9RKTtHPVAuX2xlcnAoU1swXSxTWzFdLGspLEgoRyxrKSxXPXJlcXVlc3RBbmltYXRpb25GcmFtZShfKX07dHQoKX0sUH0pfSxmdW5jdGlvbihjLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiB1fSk7dmFyIHI9dCg3MSkscz10KDIyMSksZz10KDcyKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3Qgdj1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGVEZWZhdWx0IiksaD1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGUiKSxsPVN5bWJvbC5mb3IoInNwcml0ZWpzX2dldEF0dHJpYnV0ZSIpO2NsYXNzIHUgZXh0ZW5kcyByLmRlZmF1bHR7Y29uc3RydWN0b3IoZil7c3VwZXIoZiksdGhpc1t2XSh7ZDoiIixub3JtYWxpemU6ITEsZmlsbENvbG9yOnZvaWQgMCxmaWxsUnVsZToibm9uemVybyIsc3Ryb2tlQ29sb3I6dm9pZCAwLGxpbmVXaWR0aDoxLGxpbmVKb2luOiJtaXRlciIsbGluZUNhcDoiYnV0dCIscm91bmRTZWdtZW50czoyMCxsaW5lRGFzaDp2b2lkIDAsbGluZURhc2hPZmZzZXQ6MCxtaXRlckxpbWl0OjEwLHRleHR1cmU6dm9pZCAwLHRleHR1cmVSZWN0OnZvaWQgMCx0ZXh0dXJlUmVwZWF0OiExLHNvdXJjZVJlY3Q6dm9pZCAwLGNsaXBQYXRoOnZvaWQgMH0pfWdldCBkKCl7cmV0dXJuIHRoaXNbbF0oImQiKX1zZXQgZChmKXt0aGlzW2hdKCJkIixmKX1nZXQgbm9ybWFsaXplKCl7cmV0dXJuIHRoaXNbbF0oIm5vcm1hbGl6ZSIpfXNldCBub3JtYWxpemUoZil7dGhpc1toXSgibm9ybWFsaXplIiwhIWYpfWdldCBmaWxsQ29sb3IoKXtyZXR1cm4gdGhpc1tsXSgiZmlsbENvbG9yIil9c2V0IGZpbGxDb2xvcihmKXt0aGlzW2hdKCJmaWxsQ29sb3IiLE9iamVjdChzLnBhcnNlQ29sb3IpKGYpKX1nZXQgZmlsbFJ1bGUoKXtyZXR1cm4gdGhpc1tsXSgiZmlsbFJ1bGUiKX1zZXQgZmlsbFJ1bGUoZil7aWYoZiE9bnVsbCYmZiE9PSJub256ZXJvIiYmZiE9PSJldmVub2RkIil0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIGZpbGwgcnVsZS4iKTt0aGlzW2hdKCJmaWxsUnVsZSIsZil9Z2V0IHN0cm9rZUNvbG9yKCl7cmV0dXJuIHRoaXNbbF0oInN0cm9rZUNvbG9yIil9c2V0IHN0cm9rZUNvbG9yKGYpe3RoaXNbaF0oInN0cm9rZUNvbG9yIixPYmplY3Qocy5wYXJzZUNvbG9yKShmKSl9Z2V0IGxpbmVXaWR0aCgpe3JldHVybiB0aGlzW2xdKCJsaW5lV2lkdGgiKX1zZXQgbGluZVdpZHRoKGYpe3RoaXNbaF0oImxpbmVXaWR0aCIsT2JqZWN0KGcudG9OdW1iZXIpKGYpKX1nZXQgbGluZUpvaW4oKXtyZXR1cm4gdGhpc1tsXSgibGluZUpvaW4iKX1zZXQgbGluZUpvaW4oZil7aWYoZiE9bnVsbCYmZiE9PSJtaXRlciImJmYhPT0iYmV2ZWwiJiZmIT09InJvdW5kIil0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIGxpbmVKb2luIHR5cGUuIik7dGhpc1toXSgibGluZUpvaW4iLGYpfWdldCBsaW5lQ2FwKCl7cmV0dXJuIHRoaXNbbF0oImxpbmVDYXAiKX1zZXQgbGluZUNhcChmKXtpZihmIT1udWxsJiZmIT09ImJ1dHQiJiZmIT09InNxdWFyZSImJmYhPT0icm91bmQiKXRocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgbGluZUNhcCB0eXBlLiIpO3RoaXNbaF0oImxpbmVDYXAiLGYpfWdldCBsaW5lRGFzaCgpe3JldHVybiB0aGlzW2xdKCJsaW5lRGFzaCIpfXNldCBsaW5lRGFzaChmKXtmPU9iamVjdChnLnRvQXJyYXkpKGYsITApLGYhPW51bGwmJiFBcnJheS5pc0FycmF5KGYpJiYoZj1bZl0pLHRoaXNbaF0oImxpbmVEYXNoIixmP2YubWFwKGcudG9OdW1iZXIpOm51bGwpfWdldCBsaW5lRGFzaE9mZnNldCgpe3JldHVybiB0aGlzW2xdKCJsaW5lRGFzaE9mZnNldCIpfXNldCBsaW5lRGFzaE9mZnNldChmKXt0aGlzW2hdKCJsaW5lRGFzaE9mZnNldCIsT2JqZWN0KGcudG9OdW1iZXIpKGYpKX1nZXQgbWl0ZXJMaW1pdCgpe3JldHVybiB0aGlzW2xdKCJtaXRlckxpbWl0Iil9c2V0IG1pdGVyTGltaXQoZil7dGhpc1toXSgibWl0ZXJMaW1pdCIsT2JqZWN0KGcudG9OdW1iZXIpKGYpKX1nZXQgcm91bmRTZWdtZW50cygpe3JldHVybiB0aGlzW2xdKCJyb3VuZFNlZ21lbnRzIil9c2V0IHJvdW5kU2VnbWVudHMoZil7dGhpc1toXSgicm91bmRTZWdtZW50cyIsZil9Z2V0IHRleHR1cmUoKXtyZXR1cm4gdGhpc1tsXSgidGV4dHVyZSIpfXNldCB0ZXh0dXJlKGYpe3RoaXNbaF0oInRleHR1cmUiLGYpfWdldCB0ZXh0dXJlUmVjdCgpe3JldHVybiB0aGlzW2xdKCJ0ZXh0dXJlUmVjdCIpfXNldCB0ZXh0dXJlUmVjdChmKXt0aGlzW2hdKCJ0ZXh0dXJlUmVjdCIsZil9Z2V0IHNvdXJjZVJlY3QoKXtyZXR1cm4gdGhpc1tsXSgic291cmNlUmVjdCIpfXNldCBzb3VyY2VSZWN0KGYpe3RoaXNbaF0oInNvdXJjZVJlY3QiLGYpfWdldCB0ZXh0dXJlUmVwZWF0KCl7cmV0dXJuIHRoaXNbbF0oInRleHR1cmVSZXBlYXQiKX1zZXQgdGV4dHVyZVJlcGVhdChmKXt0aGlzW2hdKCJ0ZXh0dXJlUmVwZWF0IiwhIWYpfWdldCBjbGlwUGF0aCgpe3JldHVybiB0aGlzW2xdKCJjbGlwUGF0aCIpfXNldCBjbGlwUGF0aChmKXt0aGlzW2hdKCJjbGlwUGF0aCIsZil9fX0sZnVuY3Rpb24oYyxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gaH0pO3ZhciByPXQoMjI2KSxzPXQoMjEzKSxnPXQoMjMwKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gdihsLHUsTSl7cmV0dXJuIHUgaW4gbD9PYmplY3QuZGVmaW5lUHJvcGVydHkobCx1LHt2YWx1ZTpNLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6bFt1XT1NLGx9Y2xhc3MgaCBleHRlbmRzIHIuZGVmYXVsdHtnZXQgaXNWaXNpYmxlKCl7Y29uc3R7d2lkdGg6dSxoZWlnaHQ6TX09dGhpcy5hdHRyaWJ1dGVzO3JldHVybiB1PjAmJk0+MCYmc3VwZXIuaXNWaXNpYmxlfX12KGgsIkF0dHIiLGcuZGVmYXVsdCkscy5kZWZhdWx0LnJlZ2lzdGVyTm9kZShoLCJyZWN0Iil9LGZ1bmN0aW9uKGMsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIE19KTt2YXIgcj10KDIyOCkscz10KDcyKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3QgZz1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGVEZWZhdWx0Iiksdj1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGUiKSxoPVN5bWJvbC5mb3IoInNwcml0ZWpzX2dldEF0dHJpYnV0ZSIpLGw9U3ltYm9sLmZvcigic3ByaXRlanNfZGVjbGFyZUFsaWFzIik7ZnVuY3Rpb24gdShmKXtjb25zdHt3aWR0aDp5LGhlaWdodDp4fT1mO3JldHVybmBNMCAwTCR7eX0gMEwke3l9ICR7eH1MMCAke3h9WmB9Y2xhc3MgTSBleHRlbmRzIHIuZGVmYXVsdHtjb25zdHJ1Y3Rvcih5KXtzdXBlcih5KSx0aGlzW2ddKHt3aWR0aDowLGhlaWdodDowfSksdGhpc1tsXSgic2l6ZSIpfWdldCBkKCl7cmV0dXJuIHRoaXNbaF0oImQiKX1zZXQgZCh5KXt9Z2V0IHdpZHRoKCl7cmV0dXJuIHRoaXNbaF0oIndpZHRoIil9c2V0IHdpZHRoKHkpe2lmKHk9T2JqZWN0KHMudG9OdW1iZXIpKHkpLHRoaXNbdl0oIndpZHRoIix5KSl7Y29uc3QgeD11KHRoaXMpO3RoaXNbdl0oImQiLHgpfX1nZXQgaGVpZ2h0KCl7cmV0dXJuIHRoaXNbaF0oImhlaWdodCIpfXNldCBoZWlnaHQoeSl7aWYoeT1PYmplY3Qocy50b051bWJlcikoeSksdGhpc1t2XSgiaGVpZ2h0Iix5KSl7Y29uc3QgeD11KHRoaXMpO3RoaXNbdl0oImQiLHgpfX1nZXQgc2l6ZSgpe3JldHVyblt0aGlzLndpZHRoLHRoaXMuaGVpZ2h0XX1zZXQgc2l6ZSh5KXt5PU9iamVjdChzLnRvQXJyYXkpKHkpLEFycmF5LmlzQXJyYXkoeSl8fCh5PVt5LHldKSx0aGlzLndpZHRoPXlbMF0sdGhpcy5oZWlnaHQ9eVsxXX19fSxmdW5jdGlvbihjLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBofSk7dmFyIHI9dCgyMzIpLHM9dCgyMTMpLGc9dCgyMzUpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiB2KGwsdSxNKXtyZXR1cm4gdSBpbiBsP09iamVjdC5kZWZpbmVQcm9wZXJ0eShsLHUse3ZhbHVlOk0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTpsW3VdPU0sbH1jbGFzcyBoIGV4dGVuZHMgci5kZWZhdWx0e2dldCBpc1Zpc2libGUoKXtjb25zdHtzaWRlczp1fT10aGlzLmF0dHJpYnV0ZXM7cmV0dXJuIHVbMF0+MCYmdVsxXT4wJiZzdXBlci5pc1Zpc2libGV9fXYoaCwiQXR0ciIsZy5kZWZhdWx0KSxzLmRlZmF1bHQucmVnaXN0ZXJOb2RlKGgsInRyaWFuZ2xlIil9LGZ1bmN0aW9uKGMsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIGh9KTt2YXIgcj10KDIyNikscz10KDIxMyksZz10KDIzMyk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIHYobCx1LE0pe3JldHVybiB1IGluIGw/T2JqZWN0LmRlZmluZVByb3BlcnR5KGwsdSx7dmFsdWU6TSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOmxbdV09TSxsfWNsYXNzIGggZXh0ZW5kcyByLmRlZmF1bHR7Z2V0IGlzVmlzaWJsZSgpe2NvbnN0e3BvaW50czp1fT10aGlzLmF0dHJpYnV0ZXM7cmV0dXJuIHUubGVuZ3RoPjAmJnN1cGVyLmlzVmlzaWJsZX19dihoLCJBdHRyIixnLmRlZmF1bHQpLHMuZGVmYXVsdC5yZWdpc3Rlck5vZGUoaCwicG9seWxpbmUiKX0sZnVuY3Rpb24oYyxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gZn0pO3ZhciByPXQoMjI4KSxzPXQoNzIpLGc9dCgyMzQpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCB2PVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZURlZmF1bHQiKSxoPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZSIpLGw9U3ltYm9sLmZvcigic3ByaXRlanNfZ2V0QXR0cmlidXRlIiksdT1TeW1ib2wuZm9yKCJzcHJpdGVqc19kZWNsYXJlQWxpYXMiKTtmdW5jdGlvbiBNKHkpe2NvbnN0e3BvaW50czp4LHNtb290aDpiLHNtb290aFJhbmdlOk8sY2xvc2U6bX09eSxwPVtdO2ZvcihsZXQgYT0wO2E8eC5sZW5ndGg7YSs9MilwLnB1c2goW3hbYV0seFthKzFdXSk7bGV0IG49IiI7cmV0dXJuIGI/bj1PYmplY3QoZy5tYWtlU21vb3RoQ3VydmVMaW5lKShwLE8pOnAubGVuZ3RoJiYobj1gTSR7cC5tYXAoYT0+YS5qb2luKCIgIikpLmpvaW4oIkwiKX1gKSxuJiZtJiYobis9IloiKSxufWNsYXNzIGYgZXh0ZW5kcyByLmRlZmF1bHR7Y29uc3RydWN0b3IoeCl7c3VwZXIoeCksdGhpc1t2XSh7cG9pbnRzOltdLHNtb290aDohMSxzbW9vdGhSYW5nZTpbMF0sY2xvc2VUeXBlOiJub25lIn0pLHRoaXNbdV0oImNsb3NlIil9Z2V0IGQoKXtyZXR1cm4gdGhpc1tsXSgiZCIpfXNldCBkKHgpe31nZXQgY2xvc2UoKXtyZXR1cm4gdGhpcy5jbG9zZVR5cGUhPT0ibm9uZSJ9c2V0IGNsb3NlKHgpe3g9eD8ibm9ybWFsIjoibm9uZSIsdGhpcy5jbG9zZVR5cGU9eH1nZXQgY2xvc2VUeXBlKCl7cmV0dXJuIHRoaXNbbF0oImNsb3NlVHlwZSIpfXNldCBjbG9zZVR5cGUoeCl7aWYoeCE9bnVsbCYmeCE9PSJub25lIiYmeCE9PSJub3JtYWwiKXRocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgY2xvc2VUeXBlIHR5cGUuIik7aWYodGhpc1toXSgiY2xvc2VUeXBlIix4KSl7Y29uc3QgYj1NKHRoaXMpO3RoaXNbaF0oImQiLGIpfX1nZXQgc21vb3RoKCl7cmV0dXJuIHRoaXNbbF0oInNtb290aCIpfXNldCBzbW9vdGgoeCl7aWYodGhpc1toXSgic21vb3RoIix4KSl7Y29uc3QgYj1NKHRoaXMpO3RoaXNbaF0oImQiLGIpfX1nZXQgc21vb3RoUmFuZ2UoKXtyZXR1cm4gdGhpc1tsXSgic21vb3RoUmFuZ2UiKX1zZXQgc21vb3RoUmFuZ2UoeCl7aWYoeCYmIUFycmF5LmlzQXJyYXkoeCkmJih4PVt4XSksdGhpc1toXSgic21vb3RoUmFuZ2UiLHgpJiZ0aGlzLnNtb290aCl7Y29uc3QgYj1NKHRoaXMpO3RoaXNbaF0oImQiLGIpfX1nZXQgcG9pbnRzKCl7cmV0dXJuIHRoaXNbbF0oInBvaW50cyIpfXNldCBwb2ludHMoeCl7aWYoeD1PYmplY3Qocy50b0FycmF5KSh4KSxBcnJheS5pc0FycmF5KHgpJiYoeD14LnJlZHVjZSgoYixPKT0+QXJyYXkuaXNBcnJheShPKT9bLi4uYiwuLi5PLm1hcChtPT5PYmplY3Qocy50b051bWJlcikobSkpXTpbLi4uYixPYmplY3Qocy50b051bWJlcikoTyldLFtdKSksdGhpc1toXSgicG9pbnRzIix4KSl7Y29uc3QgYj1NKHRoaXMpO3RoaXNbaF0oImQiLGIpfX19fSxmdW5jdGlvbihjLGUsdCl7dC5yKGUpLHQuZChlLCJtYWtlU21vb3RoQ3VydmVMaW5lIixmdW5jdGlvbigpe3JldHVybiByfSksdCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIHIocyxnPVswXSl7ZnVuY3Rpb24gdih1LE09LjE2OCxmPS4xNjgpe2xldCB5LHgsYixPO2lmKChzW3VdLng9PT1zW3UrMV0ueHx8c1t1XS55PT09c1t1KzFdLnkpJiYoTT0wLGY9MCksdTwxPyh5PXNbMF0ueCsoc1sxXS54LXNbMF0ueCkqTSx4PXNbMF0ueSsoc1sxXS55LXNbMF0ueSkqTSk6KHk9c1t1XS54KyhzW3UrMV0ueC1zW3UtMV0ueCkqTSx4PXNbdV0ueSsoc1t1KzFdLnktc1t1LTFdLnkpKk0pLHU+cy5sZW5ndGgtMyl7Y29uc3QgbT1zLmxlbmd0aC0xO2I9c1ttXS54LShzW21dLngtc1ttLTFdLngpKmYsTz1zW21dLnktKHNbbV0ueS1zW20tMV0ueSkqZn1lbHNlIGI9c1t1KzFdLngtKHNbdSsyXS54LXNbdV0ueCkqZixPPXNbdSsxXS55LShzW3UrMl0ueS1zW3VdLnkpKmY7cmV0dXJuW3t4OnkseTp4fSx7eDpiLHk6T31dfXM9cy5tYXAoKFt1LE1dKT0+KHt4OnUseTpNfSkpO2xldCBoPSIiLGw9MDtyZXR1cm4gcy5mb3JFYWNoKCh1LE0pPT57aWYoTT09PTApaCs9YE0ke3UueH0gJHt1Lnl9YDtlbHNle2Zvcig7TT5nW2xdOylsKys7aWYobCUyKXtjb25zdFtmLHldPXYoTS0xKTtoKz1gQyR7W2YueCxmLnkseS54LHkueSx1LngsdS55XS5qb2luKCIgIil9YH1lbHNlIGgrPWBMJHt1Lnh9ICR7dS55fWB9fSksaH19LGZ1bmN0aW9uKGMsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIHV9KTt2YXIgcj10KDIzMykscz10KDcyKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3QgZz1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGVEZWZhdWx0Iiksdj1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGUiKSxoPVN5bWJvbC5mb3IoInNwcml0ZWpzX2dldEF0dHJpYnV0ZSIpO2Z1bmN0aW9uIGwoTSl7Y29uc3RbZix5XT1NLnNpZGVzO2xldCB4PU0uYW5nbGUlMzYwO3JldHVybiB4PDAmJih4Kz0zNjApLHg9TWF0aC5QSSp4LzE4MCxbMCwwLGYsMCx5Kk1hdGguY29zKHgpLHkqTWF0aC5zaW4oeCldfWNsYXNzIHUgZXh0ZW5kcyByLmRlZmF1bHR7Y29uc3RydWN0b3IoZil7c3VwZXIoZiksdGhpc1tnXSh7c2lkZXM6WzAsMF0sYW5nbGU6NjAsY2xvc2VUeXBlOiJub3JtYWwifSl9Z2V0IHBvaW50cygpe3JldHVybiBzdXBlci5wb2ludHN9c2V0IHBvaW50cyhmKXt9Z2V0IHNpZGVzKCl7cmV0dXJuIHRoaXNbaF0oInNpZGVzIil9c2V0IHNpZGVzKGYpe2lmKGY9T2JqZWN0KHMudG9BcnJheSkoZiwhMCksZiE9bnVsbCYmIUFycmF5LmlzQXJyYXkoZikmJihmPVtmLGZdKSx0aGlzW3ZdKCJzaWRlcyIsZikpe2NvbnN0IHk9bCh0aGlzKTtzdXBlci5wb2ludHM9eX19Z2V0IGFuZ2xlKCl7cmV0dXJuIHRoaXNbaF0oImFuZ2xlIil9c2V0IGFuZ2xlKGYpe2lmKGY9T2JqZWN0KHMudG9OdW1iZXIpKGYpLHRoaXNbdl0oImFuZ2xlIixmKSl7Y29uc3QgeT1sKHRoaXMpO3N1cGVyLnBvaW50cz15fX19fSxmdW5jdGlvbihjLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBofSk7dmFyIHI9dCgyMzIpLHM9dCgyMTMpLGc9dCgyMzcpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiB2KGwsdSxNKXtyZXR1cm4gdSBpbiBsP09iamVjdC5kZWZpbmVQcm9wZXJ0eShsLHUse3ZhbHVlOk0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTpsW3VdPU0sbH1jbGFzcyBoIGV4dGVuZHMgci5kZWZhdWx0e2dldCBpc1Zpc2libGUoKXtjb25zdHtzaWRlczp1fT10aGlzLmF0dHJpYnV0ZXM7cmV0dXJuIHVbMF0+MCYmdVsxXT4wJiZzdXBlci5pc1Zpc2libGV9fXYoaCwiQXR0ciIsZy5kZWZhdWx0KSxzLmRlZmF1bHQucmVnaXN0ZXJOb2RlKGgsInBhcmFsbGVsIil9LGZ1bmN0aW9uKGMsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIHV9KTt2YXIgcj10KDIzMykscz10KDcyKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3QgZz1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGVEZWZhdWx0Iiksdj1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGUiKSxoPVN5bWJvbC5mb3IoInNwcml0ZWpzX2dldEF0dHJpYnV0ZSIpO2Z1bmN0aW9uIGwoTSl7Y29uc3RbZix5XT1NLnNpZGVzO2xldCB4PU0uYW5nbGUlMzYwO3g8MCYmKHgrPTM2MCkseD1NYXRoLlBJKngvMTgwO2NvbnN0IGI9eSpNYXRoLmNvcyh4KSxPPXkqTWF0aC5zaW4oeCk7cmV0dXJuWzAsMCxmLDAsYitmLE8sYixPXX1jbGFzcyB1IGV4dGVuZHMgci5kZWZhdWx0e2NvbnN0cnVjdG9yKGYpe3N1cGVyKGYpLHRoaXNbZ10oe3NpZGVzOlswLDBdLGFuZ2xlOjkwLGNsb3NlVHlwZToibm9ybWFsIn0pfWdldCBwb2ludHMoKXtyZXR1cm4gc3VwZXIucG9pbnRzfXNldCBwb2ludHMoZil7fWdldCBzaWRlcygpe3JldHVybiB0aGlzW2hdKCJzaWRlcyIpfXNldCBzaWRlcyhmKXtpZihmPU9iamVjdChzLnRvQXJyYXkpKGYsITApLGYhPW51bGwmJiFBcnJheS5pc0FycmF5KGYpJiYoZj1bZixmXSksdGhpc1t2XSgic2lkZXMiLGYpKXtjb25zdCB5PWwodGhpcyk7c3VwZXIucG9pbnRzPXl9fWdldCBhbmdsZSgpe3JldHVybiB0aGlzW2hdKCJhbmdsZSIpfXNldCBhbmdsZShmKXtpZihmPU9iamVjdChzLnRvTnVtYmVyKShmKSx0aGlzW3ZdKCJhbmdsZSIsZikpe2NvbnN0IHk9bCh0aGlzKTtzdXBlci5wb2ludHM9eX19fX0sZnVuY3Rpb24oYyxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gaH0pO3ZhciByPXQoMjMyKSxzPXQoMjEzKSxnPXQoMjM5KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gdihsLHUsTSl7cmV0dXJuIHUgaW4gbD9PYmplY3QuZGVmaW5lUHJvcGVydHkobCx1LHt2YWx1ZTpNLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6bFt1XT1NLGx9Y2xhc3MgaCBleHRlbmRzIHIuZGVmYXVsdHt9dihoLCJBdHRyIixnLmRlZmF1bHQpLHMuZGVmYXVsdC5yZWdpc3Rlck5vZGUoaCwicmVndWxhciIpfSxmdW5jdGlvbihjLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiB1fSk7dmFyIHI9dCgyMzMpLHM9dCg3Mik7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IGc9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlRGVmYXVsdCIpLHY9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlIiksaD1TeW1ib2wuZm9yKCJzcHJpdGVqc19nZXRBdHRyaWJ1dGUiKTtmdW5jdGlvbiBsKE0pe2NvbnN0e2VkZ2VzOmYscmFkaXVzOnksb2Zmc2V0QW5nbGU6eH09TSxiPU1hdGguUEkqeC8xODAtLjUqTWF0aC5QSTtpZihmPDN8fHk8PTApcmV0dXJuW107Y29uc3QgTz1bXTtmb3IobGV0IG09MDttPGY7bSsrKXtjb25zdCBwPW0qMipNYXRoLlBJL2YrYixuPXkqTWF0aC5jb3MocCksYT15Kk1hdGguc2luKHApO08ucHVzaChuLGEpfXJldHVybiBPfWNsYXNzIHUgZXh0ZW5kcyByLmRlZmF1bHR7Y29uc3RydWN0b3IoZil7c3VwZXIoZiksdGhpc1tnXSh7ZWRnZXM6MyxyYWRpdXM6MCxvZmZzZXRBbmdsZTowLGNsb3NlVHlwZToibm9ybWFsIn0pfWdldCBwb2ludHMoKXtyZXR1cm4gc3VwZXIucG9pbnRzfXNldCBwb2ludHMoZil7fWdldCBlZGdlcygpe3JldHVybiB0aGlzW2hdKCJlZGdlcyIpfXNldCBlZGdlcyhmKXtpZihmPU9iamVjdChzLnRvTnVtYmVyKShmKSx0aGlzW3ZdKCJlZGdlcyIsZikpe2NvbnN0IHk9bCh0aGlzKTtzdXBlci5wb2ludHM9eX19Z2V0IHJhZGl1cygpe3JldHVybiB0aGlzW2hdKCJyYWRpdXMiKX1zZXQgcmFkaXVzKGYpe2lmKGY9T2JqZWN0KHMudG9OdW1iZXIpKGYpLHRoaXNbdl0oInJhZGl1cyIsZikpe2NvbnN0IHk9bCh0aGlzKTtzdXBlci5wb2ludHM9eX19Z2V0IG9mZnNldEFuZ2xlKCl7cmV0dXJuIHRoaXNbaF0oIm9mZnNldEFuZ2xlIil9c2V0IG9mZnNldEFuZ2xlKGYpe2lmKGY9T2JqZWN0KHMudG9OdW1iZXIpKGYpLHRoaXNbdl0oIm9mZnNldEFuZ2xlIixmKSl7Y29uc3QgeT1sKHRoaXMpO3N1cGVyLnBvaW50cz15fX19fSxmdW5jdGlvbihjLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBofSk7dmFyIHI9dCgyMzIpLHM9dCgyMTMpLGc9dCgyNDEpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiB2KGwsdSxNKXtyZXR1cm4gdSBpbiBsP09iamVjdC5kZWZpbmVQcm9wZXJ0eShsLHUse3ZhbHVlOk0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTpsW3VdPU0sbH1jbGFzcyBoIGV4dGVuZHMgci5kZWZhdWx0e312KGgsIkF0dHIiLGcuZGVmYXVsdCkscy5kZWZhdWx0LnJlZ2lzdGVyTm9kZShoLCJzdGFyIil9LGZ1bmN0aW9uKGMsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIHV9KTt2YXIgcj10KDIzMykscz10KDcyKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3QgZz1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGVEZWZhdWx0Iiksdj1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGUiKSxoPVN5bWJvbC5mb3IoInNwcml0ZWpzX2dldEF0dHJpYnV0ZSIpO2Z1bmN0aW9uIGwoTSl7Y29uc3R7YW5nbGVzOmYsaW5uZXJSYWRpdXM6eSxvdXRlclJhZGl1czp4LG9mZnNldEFuZ2xlOmJ9PU0sTz1NYXRoLlBJKmIvMTgwLS41Kk1hdGguUEk7aWYoZjwzfHx5PD0wfHx4PD0wKXJldHVybltdO2NvbnN0IG09W107Zm9yKGxldCBwPTA7cDxmKjI7cCsrKXtjb25zdCBuPXAqTWF0aC5QSS9mK08sYT1wJTI/eTp4LGk9YSpNYXRoLmNvcyhuKSxvPWEqTWF0aC5zaW4obik7bS5wdXNoKGksbyl9cmV0dXJuIG19Y2xhc3MgdSBleHRlbmRzIHIuZGVmYXVsdHtjb25zdHJ1Y3RvcihmKXtzdXBlcihmKSx0aGlzW2ddKHthbmdsZXM6NSxpbm5lclJhZGl1czowLG91dGVyUmFkaXVzOjAsb2Zmc2V0QW5nbGU6MCxjbG9zZVR5cGU6Im5vcm1hbCJ9KX1nZXQgcG9pbnRzKCl7cmV0dXJuIHN1cGVyLnBvaW50c31zZXQgcG9pbnRzKGYpe31nZXQgYW5nbGVzKCl7cmV0dXJuIHRoaXNbaF0oImFuZ2xlcyIpfXNldCBhbmdsZXMoZil7aWYoZj1PYmplY3Qocy50b051bWJlcikoZiksdGhpc1t2XSgiYW5nbGVzIixmKSl7Y29uc3QgeT1sKHRoaXMpO3N1cGVyLnBvaW50cz15fX1nZXQgaW5uZXJSYWRpdXMoKXtyZXR1cm4gdGhpc1toXSgiaW5uZXJSYWRpdXMiKX1zZXQgaW5uZXJSYWRpdXMoZil7aWYoZj1PYmplY3Qocy50b051bWJlcikoZiksdGhpc1t2XSgiaW5uZXJSYWRpdXMiLGYpKXtjb25zdCB5PWwodGhpcyk7c3VwZXIucG9pbnRzPXl9fWdldCBvdXRlclJhZGl1cygpe3JldHVybiB0aGlzW2hdKCJvdXRlclJhZGl1cyIpfXNldCBvdXRlclJhZGl1cyhmKXtpZihmPU9iamVjdChzLnRvTnVtYmVyKShmKSx0aGlzW3ZdKCJvdXRlclJhZGl1cyIsZikpe2NvbnN0IHk9bCh0aGlzKTtzdXBlci5wb2ludHM9eX19Z2V0IHJhZGl1cygpe3JldHVyblt0aGlzLmlubmVyUmFkaXVzLHRoaXMub3V0ZXJSYWRpdXNdfXNldCByYWRpdXMoZil7Zj1PYmplY3Qocy50b0FycmF5KShmLCEwKSxBcnJheS5pc0FycmF5KGYpfHwoZj1bZixmXSksdGhpcy5pbm5lclJhZGl1cz1mWzBdLHRoaXMub3V0ZXJSYWRpdXM9ZlsxXX1nZXQgb2Zmc2V0QW5nbGUoKXtyZXR1cm4gdGhpc1toXSgib2Zmc2V0QW5nbGUiKX1zZXQgb2Zmc2V0QW5nbGUoZil7aWYoZj1PYmplY3Qocy50b051bWJlcikoZiksdGhpc1t2XSgib2Zmc2V0QW5nbGUiLGYpKXtjb25zdCB5PWwodGhpcyk7c3VwZXIucG9pbnRzPXl9fX19LGZ1bmN0aW9uKGMsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIGh9KTt2YXIgcj10KDIyNikscz10KDIxMyksZz10KDI0Myk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIHYobCx1LE0pe3JldHVybiB1IGluIGw/T2JqZWN0LmRlZmluZVByb3BlcnR5KGwsdSx7dmFsdWU6TSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOmxbdV09TSxsfWNsYXNzIGggZXh0ZW5kcyByLmRlZmF1bHR7Z2V0IGlzVmlzaWJsZSgpe2NvbnN0e3JhZGl1c1g6dSxyYWRpdXNZOk0sc3RhcnRBbmdsZTpmLGVuZEFuZ2xlOnl9PXRoaXMuYXR0cmlidXRlcztyZXR1cm4gdT4wJiZNPjAmJmYhPT15JiZzdXBlci5pc1Zpc2libGV9fXYoaCwiQXR0ciIsZy5kZWZhdWx0KSxzLmRlZmF1bHQucmVnaXN0ZXJOb2RlKGgsImVsbGlwc2UiKX0sZnVuY3Rpb24oYyxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gZn0pO3ZhciByPXQoMTIpLHM9dCgyMjgpLGc9dCg3Mik7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IHY9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlRGVmYXVsdCIpLGg9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlIiksbD1TeW1ib2wuZm9yKCJzcHJpdGVqc19nZXRBdHRyaWJ1dGUiKSx1PVN5bWJvbC5mb3IoInNwcml0ZWpzX2RlY2xhcmVBbGlhcyIpO2Z1bmN0aW9uIE0oeSl7Y29uc3R7cmFkaXVzWDp4LHJhZGl1c1k6YixzdGFydEFuZ2xlOk8sZW5kQW5nbGU6bSxkaXJlY3Rpb246cCxjbG9zZVR5cGU6bn09eSxhPXA9PT0iYW5pdGNsb2Nrd2lzZSIsaT1uZXcgci5GaWd1cmUyRDtyZXR1cm4gbj09PSJzZWN0b3IiJiZpLm1vdmVUbygwLDApLGkuZWxsaXBzZSgwLDAseCxiLDAsTWF0aC5QSSpPLzE4MCxNYXRoLlBJKm0vMTgwLGEpLG4hPT0ibm9uZSImJmkuY2xvc2VQYXRoKCksaS5wYXRoLnJlZHVjZSgoUCxDKT0+UCtDLmpvaW4oIiAiKSwiIil9Y2xhc3MgZiBleHRlbmRzIHMuZGVmYXVsdHtjb25zdHJ1Y3Rvcih4KXtzdXBlcih4KSx0aGlzW3ZdKHtyYWRpdXNYOjAscmFkaXVzWTowLHN0YXJ0QW5nbGU6MCxlbmRBbmdsZTozNjAsZGlyZWN0aW9uOiJjbG9ja3dpc2UiLGNsb3NlVHlwZToibm9uZSJ9KSx0aGlzW3VdKCJyYWRpdXMiLCJhbmdsZSIpfWdldCBkKCl7cmV0dXJuIHRoaXNbbF0oImQiKX1zZXQgZCh4KXt9Z2V0IHJhZGl1c1goKXtyZXR1cm4gdGhpc1tsXSgicmFkaXVzWCIpfXNldCByYWRpdXNYKHgpe2lmKHg9T2JqZWN0KGcudG9OdW1iZXIpKHgpLHRoaXNbaF0oInJhZGl1c1giLHgpKXtjb25zdCBiPU0odGhpcyk7dGhpc1toXSgiZCIsYil9fWdldCByYWRpdXNZKCl7cmV0dXJuIHRoaXNbbF0oInJhZGl1c1kiKX1zZXQgcmFkaXVzWSh4KXtpZih4PU9iamVjdChnLnRvTnVtYmVyKSh4KSx0aGlzW2hdKCJyYWRpdXNZIix4KSl7Y29uc3QgYj1NKHRoaXMpO3RoaXNbaF0oImQiLGIpfX1nZXQgcmFkaXVzKCl7cmV0dXJuW3RoaXMucmFkaXVzWCx0aGlzLnJhZGl1c1ldfXNldCByYWRpdXMoeCl7eD1PYmplY3QoZy50b0FycmF5KSh4LCEwKSxBcnJheS5pc0FycmF5KHgpfHwoeD1beCx4XSksdGhpcy5yYWRpdXNYPXhbMF0sdGhpcy5yYWRpdXNZPXhbMV19Z2V0IGFuZ2xlKCl7cmV0dXJuW3RoaXMuc3RhcnRBbmdsZSx0aGlzLmVuZEFuZ2xlXX1zZXQgYW5nbGUoeCl7eD1PYmplY3QoZy50b0FycmF5KSh4KSxBcnJheS5pc0FycmF5KHgpfHwoeD1beCx4XSksdGhpcy5zdGFydEFuZ2xlPXhbMF0sdGhpcy5lbmRBbmdsZT14WzFdfWdldCBkaXJlY3Rpb24oKXtyZXR1cm4gdGhpc1tsXSgiZGlyZWN0aW9uIil9c2V0IGRpcmVjdGlvbih4KXtpZih4IT1udWxsJiZ4IT09ImNsb2Nrd2lzZSImJnghPT0iYW50aWNsb2Nrd2lzZSIpdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCBkaXJlY3Rpb24gdHlwZS4iKTt0aGlzW2hdKCJkaXJlY3Rpb24iLHgpfWdldCBzdGFydEFuZ2xlKCl7cmV0dXJuIHRoaXNbbF0oInN0YXJ0QW5nbGUiKX1zZXQgc3RhcnRBbmdsZSh4KXtpZih4PU9iamVjdChnLnRvTnVtYmVyKSh4KSx0aGlzW2hdKCJzdGFydEFuZ2xlIix4KSl7Y29uc3QgYj1NKHRoaXMpO3RoaXNbaF0oImQiLGIpfX1nZXQgZW5kQW5nbGUoKXtyZXR1cm4gdGhpc1tsXSgiZW5kQW5nbGUiKX1zZXQgZW5kQW5nbGUoeCl7aWYoeD1PYmplY3QoZy50b051bWJlcikoeCksdGhpc1toXSgiZW5kQW5nbGUiLHgpKXtjb25zdCBiPU0odGhpcyk7dGhpc1toXSgiZCIsYil9fWdldCBjbG9zZVR5cGUoKXtyZXR1cm4gdGhpc1tsXSgiY2xvc2VUeXBlIil9c2V0IGNsb3NlVHlwZSh4KXtpZih4IT1udWxsJiZ4IT09Im5vbmUiJiZ4IT09InNlY3RvciImJnghPT0ibm9ybWFsIil0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIGNsb3NlVHlwZSB0eXBlLiIpO2lmKHRoaXNbaF0oImNsb3NlVHlwZSIseCkpe2NvbnN0IGI9TSh0aGlzKTt0aGlzW2hdKCJkIixiKX19fX0sZnVuY3Rpb24oYyxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gaH0pO3ZhciByPXQoMjQyKSxzPXQoMjEzKSxnPXQoMjQ1KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gdihsLHUsTSl7cmV0dXJuIHUgaW4gbD9PYmplY3QuZGVmaW5lUHJvcGVydHkobCx1LHt2YWx1ZTpNLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6bFt1XT1NLGx9Y2xhc3MgaCBleHRlbmRzIHIuZGVmYXVsdHt9dihoLCJBdHRyIixnLmRlZmF1bHQpLHMuZGVmYXVsdC5yZWdpc3Rlck5vZGUoaCwiYXJjIil9LGZ1bmN0aW9uKGMsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIGd9KTt2YXIgcj10KDI0Mykscz10KDcyKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y2xhc3MgZyBleHRlbmRzIHIuZGVmYXVsdHtnZXQgcmFkaXVzKCl7cmV0dXJuIHN1cGVyLnJhZGl1c1h9c2V0IHJhZGl1cyhoKXtoPU9iamVjdChzLnRvTnVtYmVyKShoKSxzdXBlci5yYWRpdXNYPWgsc3VwZXIucmFkaXVzWT1ofX19LGZ1bmN0aW9uKGMsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIGh9KTt2YXIgcj10KDIyNikscz10KDIxMyksZz10KDI0Nyk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIHYobCx1LE0pe3JldHVybiB1IGluIGw/T2JqZWN0LmRlZmluZVByb3BlcnR5KGwsdSx7dmFsdWU6TSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOmxbdV09TSxsfWNsYXNzIGggZXh0ZW5kcyByLmRlZmF1bHR7Z2V0IGlzVmlzaWJsZSgpe2NvbnN0e2lubmVyUmFkaXVzOnUsb3V0ZXJSYWRpdXM6TSxzdGFydEFuZ2xlOmYsZW5kQW5nbGU6eX09dGhpcy5hdHRyaWJ1dGVzO3JldHVybih1PjB8fE0+MCkmJmYhPT15JiZzdXBlci5pc1Zpc2libGV9fXYoaCwiQXR0ciIsZy5kZWZhdWx0KSxzLmRlZmF1bHQucmVnaXN0ZXJOb2RlKGgsInJpbmciKX0sZnVuY3Rpb24oYyxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gZn0pO3ZhciByPXQoMTIpLHM9dCgyMjgpLGc9dCg3Mik7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IHY9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlRGVmYXVsdCIpLGg9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlIiksbD1TeW1ib2wuZm9yKCJzcHJpdGVqc19nZXRBdHRyaWJ1dGUiKSx1PVN5bWJvbC5mb3IoInNwcml0ZWpzX2RlY2xhcmVBbGlhcyIpO2Z1bmN0aW9uIE0oeSl7bGV0e2lubmVyUmFkaXVzOngsb3V0ZXJSYWRpdXM6YixzdGFydEFuZ2xlOk8sZW5kQW5nbGU6bX09eTtjb25zdCBwPW5ldyByLkZpZ3VyZTJEO2lmKE89TWF0aC5QSSpPLzE4MCxtPU1hdGguUEkqbS8xODAseD5iJiYoW3gsYl09W2IseF0pLHg8PTAmJnAubW92ZVRvKDAsMCkscC5hcmMoMCwwLGIsTyxtLCExKSx4PjApe2NvbnN0IGk9TWF0aC5QSSoyO208TyYmKG09TytpKyhtLU8pJWkpLG0tTz49aSYmKG09TytpLTFlLTYpLHAuYXJjKDAsMCx4LG0sTywhMCl9cmV0dXJuIHAuY2xvc2VQYXRoKCkscC5wYXRoLnJlZHVjZSgoaSxvKT0+aStvLmpvaW4oIiAiKSwiIil9Y2xhc3MgZiBleHRlbmRzIHMuZGVmYXVsdHtjb25zdHJ1Y3Rvcih4KXtzdXBlcih4KSx0aGlzW3ZdKHtpbm5lclJhZGl1czowLG91dGVyUmFkaXVzOjAsc3RhcnRBbmdsZTowLGVuZEFuZ2xlOjM2MH0pLHRoaXNbdV0oInJhZGl1cyIsImFuZ2xlIil9Z2V0IGQoKXtyZXR1cm4gdGhpc1tsXSgiZCIpfXNldCBkKHgpe31nZXQgaW5uZXJSYWRpdXMoKXtyZXR1cm4gdGhpc1tsXSgiaW5uZXJSYWRpdXMiKX1zZXQgaW5uZXJSYWRpdXMoeCl7aWYoeD1PYmplY3QoZy50b051bWJlcikoeCksdGhpc1toXSgiaW5uZXJSYWRpdXMiLHgpKXtjb25zdCBiPU0odGhpcyk7dGhpc1toXSgiZCIsYil9fWdldCBvdXRlclJhZGl1cygpe3JldHVybiB0aGlzW2xdKCJvdXRlclJhZGl1cyIpfXNldCBvdXRlclJhZGl1cyh4KXtpZih4PU9iamVjdChnLnRvTnVtYmVyKSh4KSx0aGlzW2hdKCJvdXRlclJhZGl1cyIseCkpe2NvbnN0IGI9TSh0aGlzKTt0aGlzW2hdKCJkIixiKX19Z2V0IHJhZGl1cygpe3JldHVyblt0aGlzLmlubmVyUmFkaXVzLHRoaXMub3V0ZXJSYWRpdXNdfXNldCByYWRpdXMoeCl7eD1PYmplY3QoZy50b0FycmF5KSh4LCEwKSxBcnJheS5pc0FycmF5KHgpfHwoeD1beCx4XSksdGhpcy5pbm5lclJhZGl1cz14WzBdLHRoaXMub3V0ZXJSYWRpdXM9eFsxXX1nZXQgc3RhcnRBbmdsZSgpe3JldHVybiB0aGlzW2xdKCJzdGFydEFuZ2xlIil9c2V0IHN0YXJ0QW5nbGUoeCl7aWYoeD1PYmplY3QoZy50b051bWJlcikoeCksdGhpc1toXSgic3RhcnRBbmdsZSIseCkpe2NvbnN0IGI9TSh0aGlzKTt0aGlzW2hdKCJkIixiKX19Z2V0IGVuZEFuZ2xlKCl7cmV0dXJuIHRoaXNbbF0oImVuZEFuZ2xlIil9c2V0IGVuZEFuZ2xlKHgpe2lmKHg9T2JqZWN0KGcudG9OdW1iZXIpKHgpLHRoaXNbaF0oImVuZEFuZ2xlIix4KSl7Y29uc3QgYj1NKHRoaXMpO3RoaXNbaF0oImQiLGIpfX1nZXQgYW5nbGUoKXtyZXR1cm5bdGhpcy5zdGFydEFuZ2xlLHRoaXMuZW5kQW5nbGVdfXNldCBhbmdsZSh4KXt4PU9iamVjdChnLnRvQXJyYXkpKHgpLEFycmF5LmlzQXJyYXkoeCl8fCh4PVt4LHhdKSx0aGlzLnN0YXJ0QW5nbGU9eFswXSx0aGlzLmVuZEFuZ2xlPXhbMV19fX0sZnVuY3Rpb24oYyxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gYn0pO3ZhciByPXQoMTIpLHM9dCgyMTgpLGc9dCgyMTkpLHY9dCgyNDkpLGg9dCgyMTMpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBsKE8sbSxwKXtyZXR1cm4gbSBpbiBPP09iamVjdC5kZWZpbmVQcm9wZXJ0eShPLG0se3ZhbHVlOnAsZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTpPW21dPXAsT31jb25zdCB1PVN5bWJvbCgidGV4dEltYWdlIiksTT1TeW1ib2woInRleHRJbWFnZVRhc2siKSxmPVN5bWJvbCgidGV4dHVyZUNvbnRleHQiKSx5PVN5bWJvbCgidXBkYXRlVGV4dHVyZVJlY3QiKSx4PVN5bWJvbCgidGV4dENhbnZhcyIpO2NsYXNzIGIgZXh0ZW5kcyBnLmRlZmF1bHR7Y29uc3RydWN0b3IobT17fSl7dHlwZW9mIG09PSJzdHJpbmciJiYobT17dGV4dDptfSksc3VwZXIobSl9Z2V0IGNvbnRlbnRTaXplKCl7bGV0W20scF09c3VwZXIuY29udGVudFNpemU7Y29uc3R7d2lkdGg6bixoZWlnaHQ6YX09dGhpcy5hdHRyaWJ1dGVzO2lmKG49PW51bGx8fGE9PW51bGwpe2NvbnN0IGk9dGhpc1t1XTtpJiYobj09bnVsbCYmKG09aS5yZWN0WzJdKSxhPT1udWxsJiYocD1pLnJlY3RbM10pKX1yZXR1cm5bbSxwXX1nZXQgdGV4dCgpe3JldHVybiB0aGlzLmF0dHJpYnV0ZXMudGV4dH1zZXQgdGV4dChtKXt0aGlzLmF0dHJpYnV0ZXMudGV4dD1tfWdldCB0ZXh0Q29udGVudCgpe3JldHVybiB0aGlzLmF0dHJpYnV0ZXMudGV4dH1zZXQgdGV4dENvbnRlbnQobSl7dGhpcy5hdHRyaWJ1dGVzLnRleHQ9bX1nZXQgdGV4dEltYWdlKCl7cmV0dXJuIHRoaXNbdV18fHt9fWdldCB0ZXh0SW1hZ2VSZWFkeSgpe3JldHVybiB0aGlzW01dfHxQcm9taXNlLnJlc29sdmUoKX1kcmF3KG0pe3N1cGVyLmRyYXcobSk7Y29uc3QgcD10aGlzLm1lc2g7aWYocCl7Y29uc3Qgbj10aGlzW3VdO2lmKG4pe2xldCBhPXAudGV4dHVyZTtpZighYXx8dGhpc1tmXSYmdGhpc1tmXSE9PXRoaXMucmVuZGVyZXJ8fG4ubmVlZHNVcGRhdGU/KG4ubmVlZHNVcGRhdGU9ITEsT2JqZWN0KHMuZGVsZXRlVGV4dHVyZSkobi5pbWFnZSx0aGlzLnJlbmRlcmVyKSxhPU9iamVjdChzLmNyZWF0ZVRleHR1cmUpKG4uaW1hZ2UsdGhpcy5yZW5kZXJlciksdGhpc1t5XT0hMCk6YT1wLnVuaWZvcm1zLnVfdGV4U2FtcGxlcix0aGlzW3ldKXtjb25zdFtpLG9dPW4ucmVjdC5zbGljZSgyKSxbVCxQXT10aGlzLmNvbnRlbnRTaXplLEM9dGhpcy5hdHRyaWJ1dGVzLnRleHRBbGlnbixJPXRoaXMuYXR0cmlidXRlcy52ZXJ0aWNhbEFsaWduO2xldCBBPTA7Qz09PSJjZW50ZXIiP0E9KFQtaSkvMjooQz09PSJyaWdodCJ8fEM9PT0iZW5kIikmJihBPVQtaSk7Y29uc3QgTD10aGlzLmF0dHJpYnV0ZXMuZm9udFNpemUsRD10aGlzLmF0dHJpYnV0ZXMubGluZUhlaWdodDtsZXQgUj0wO0k9PT0idG9wIj9SPShMLUQpLzI6ST09PSJib3R0b20iJiYoUj0oRC1MKS8yKTtjb25zdHtwYWRkaW5nTGVmdDpTLHBhZGRpbmdUb3A6Qn09dGhpcy5hdHRyaWJ1dGVzLHtib3JkZXJXaWR0aDp3fT10aGlzLmF0dHJpYnV0ZXM7QSs9Uyt3LFIrPUIrdztjb25zdHthbmNob3JYOkgsYW5jaG9yWTpKfT10aGlzLmF0dHJpYnV0ZXM7QS09dGhpcy5vZmZzZXRTaXplWzBdKkgsUi09dGhpcy5vZmZzZXRTaXplWzFdKkoscC5zZXRUZXh0dXJlKGEse3JlY3Q6W0EsUixpLG9dfSksdGhpc1t5XT0hMSx0aGlzW2ZdPXRoaXMucmVuZGVyZXJ9fX1yZXR1cm4gbX1vblByb3BlcnR5Q2hhbmdlKG0scCxuKXttPT09InRleHQifHxtPT09ImZvbnRTaXplInx8bT09PSJmb250RmFtaWx5Inx8bT09PSJmb250U3R5bGUifHxtPT09ImZvbnRWYXJpYW50Inx8bT09PSJmb250V2VpZ2h0Inx8bT09PSJmb250U3RyZXRjaCJ8fG09PT0ibGluZUhlaWdodCJ8fG09PT0ic3Ryb2tlQ29sb3IifHxtPT09ImZpbGxDb2xvciJ8fG09PT0ic3Ryb2tlV2lkdGgiP3RoaXMudXBkYXRlVGV4dCgpOigobT09PSJ0ZXh0QWxpZ24ifHxtPT09InZlcnRpY2FsQWxpZ24iKSYmKHRoaXNbeV09ITApLHN1cGVyLm9uUHJvcGVydHlDaGFuZ2UobSxwLG4pKX11cGRhdGVDb250b3Vycygpe3N1cGVyLnVwZGF0ZUNvbnRvdXJzKCksdGhpc1t5XT0hMH11cGRhdGVUZXh0KCl7dGhpc1tNXXx8KHRoaXNbTV09UHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKT0+e3RoaXNbTV09bnVsbDtjb25zdHt0ZXh0Om0sZm9udDpwLGZpbGxDb2xvcjpuLHN0cm9rZUNvbG9yOmEsc3Ryb2tlV2lkdGg6aX09dGhpcy5hdHRyaWJ1dGVzLG89dGhpcy5sYXllcj90aGlzLmxheWVyLmRpc3BsYXlSYXRpbzoxO3JldHVybiB0aGlzW3hdPXRoaXNbeF18fHIuRU5WLmNyZWF0ZUNhbnZhcygxLDEpLHRoaXNbdV09ci5FTlYuY3JlYXRlVGV4dChtLHtmb250OnAsZmlsbENvbG9yOm4sc3Ryb2tlQ29sb3I6YSxzdHJva2VXaWR0aDppLHBhcnNlRm9udDpyLnBhcnNlRm9udCxyYXRpbzpvLHRleHRDYW52YXM6dGhpc1t4XX0pLHRoaXNbdV0ubmVlZHNVcGRhdGU9ITAsdGhpcy51cGRhdGVDb250b3VycygpLHRoaXMuZm9yY2VVcGRhdGUoKSx0aGlzW3VdfSkpfX1sKGIsIkF0dHIiLHYuZGVmYXVsdCksaC5kZWZhdWx0LnJlZ2lzdGVyTm9kZShiLCJsYWJlbCIpfSxmdW5jdGlvbihjLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBmfSk7dmFyIHI9dCgxMikscz10KDcyKSxnPXQoMjIxKSx2PXQoMjIwKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3QgaD1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGVEZWZhdWx0IiksbD1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGUiKSx1PVN5bWJvbC5mb3IoInNwcml0ZWpzX2dldEF0dHJpYnV0ZSIpLE09U3ltYm9sLmZvcigic3ByaXRlanNfZGVjbGFyZUFsaWFzIik7Y2xhc3MgZiBleHRlbmRzIHYuZGVmYXVsdHtjb25zdHJ1Y3Rvcih4KXtzdXBlcih4KSx0aGlzW2hdKHt0ZXh0OiIiLGZvbnRTaXplOjE2LGZvbnRGYW1pbHk6IkhlbHZldGljYSxBcmlhbCxzYW5zLXNlcmlmIixmb250U3R5bGU6Im5vcm1hbCIsZm9udFZhcmlhbnQ6Im5vcm1hbCIsZm9udFdlaWdodDoibm9ybWFsIixmb250U3RyZXRjaDoibm9ybWFsIixsaW5lSGVpZ2h0OiIiLHRleHRBbGlnbjoibGVmdCIsc3Ryb2tlQ29sb3I6dm9pZCAwLHN0cm9rZVdpZHRoOjEsZmlsbENvbG9yOnZvaWQgMCx2ZXJ0aWNhbEFsaWduOiJtaWRkbGUifSksdGhpc1tNXSgiZm9udCIpfWdldCB0ZXh0KCl7cmV0dXJuIHRoaXNbdV0oInRleHQiKXx8IiAifXNldCB0ZXh0KHgpe3RoaXNbbF0oInRleHQiLHgpfWdldCBmb250U2l6ZSgpe3JldHVybiB0aGlzW3VdKCJmb250U2l6ZSIpfXNldCBmb250U2l6ZSh4KXt0aGlzW2xdKCJmb250U2l6ZSIsT2JqZWN0KHMudG9OdW1iZXIpKHgpKX1nZXQgZm9udEZhbWlseSgpe3JldHVybiB0aGlzW3VdKCJmb250RmFtaWx5Iil9c2V0IGZvbnRGYW1pbHkoeCl7dGhpc1tsXSgiZm9udEZhbWlseSIseCl9Z2V0IGZvbnRTdHlsZSgpe3JldHVybiB0aGlzW3VdKCJmb250U3R5bGUiKX1zZXQgZm9udFN0eWxlKHgpe3RoaXNbbF0oImZvbnRTdHlsZSIseCl9Z2V0IGZvbnRWYXJpYW50KCl7cmV0dXJuIHRoaXNbdV0oImZvbnRWYXJpYW50Iil9c2V0IGZvbnRWYXJpYW50KHgpe3RoaXNbbF0oImZvbnRWYXJpYW50Iix4KX1nZXQgZm9udFdlaWdodCgpe3JldHVybiB0aGlzW3VdKCJmb250V2VpZ2h0Iil9c2V0IGZvbnRXZWlnaHQoeCl7dGhpc1tsXSgiZm9udFdlaWdodCIseCl9Z2V0IGZvbnRTdHJldGNoKCl7cmV0dXJuIHRoaXNbdV0oImZvbnRTdHJldGNoIil9c2V0IGZvbnRTdHJldGNoKHgpe3RoaXNbbF0oImZvbnRTdHJldGNoIix4KX1nZXQgbGluZUhlaWdodCgpe3JldHVybiB0aGlzW3VdKCJsaW5lSGVpZ2h0Iil8fHRoaXMuZm9udFNpemV9c2V0IGxpbmVIZWlnaHQoeCl7dGhpc1tsXSgibGluZUhlaWdodCIsT2JqZWN0KHMudG9OdW1iZXIpKHgpKX1nZXQgdGV4dEFsaWduKCl7cmV0dXJuIHRoaXNbdV0oInRleHRBbGlnbiIpfXNldCB0ZXh0QWxpZ24oeCl7dGhpc1tsXSgidGV4dEFsaWduIix4KX1nZXQgc3Ryb2tlQ29sb3IoKXtyZXR1cm4gdGhpc1t1XSgic3Ryb2tlQ29sb3IiKX1zZXQgc3Ryb2tlQ29sb3IoeCl7dGhpc1tsXSgic3Ryb2tlQ29sb3IiLE9iamVjdChnLnBhcnNlQ29sb3IpKHgpKX1nZXQgc3Ryb2tlV2lkdGgoKXtyZXR1cm4gdGhpc1t1XSgic3Ryb2tlV2lkdGgiKX1zZXQgc3Ryb2tlV2lkdGgoeCl7dGhpc1tsXSgic3Ryb2tlV2lkdGgiLE9iamVjdChzLnRvTnVtYmVyKSh4KSl9Z2V0IHZlcnRpY2FsQWxpZ24oKXtyZXR1cm4gdGhpc1t1XSgidmVydGljYWxBbGlnbiIpfXNldCB2ZXJ0aWNhbEFsaWduKHgpe3RoaXNbbF0oInZlcnRpY2FsQWxpZ24iLHgpfWdldCBmaWxsQ29sb3IoKXtyZXR1cm4gdGhpc1t1XSgiZmlsbENvbG9yIil9c2V0IGZpbGxDb2xvcih4KXt0aGlzW2xdKCJmaWxsQ29sb3IiLE9iamVjdChnLnBhcnNlQ29sb3IpKHgpKX1nZXQgZm9udCgpe2NvbnN0e2ZvbnRTdHlsZTp4LGZvbnRWYXJpYW50OmIsZm9udFdlaWdodDpPLGZvbnRTdHJldGNoOm0sZm9udFNpemU6cCxsaW5lSGVpZ2h0Om4sZm9udEZhbWlseTphfT10aGlzO3JldHVybmAke3h9ICR7Yn0gJHtPfSAke219ICR7cH1weC8ke259cHggJHthfWB9c2V0IGZvbnQoeCl7aWYoeD09bnVsbCl0aGlzLmZvbnRTdHlsZT1udWxsLHRoaXMuZm9udFZhcmlhbnQ9bnVsbCx0aGlzLmZvbnRXZWlnaHQ9bnVsbCx0aGlzLmZvbnRTdHJldGNoPW51bGwsdGhpcy5mb250U2l6ZT1udWxsLHRoaXMubGluZUhlaWdodD1udWxsLHRoaXMuZm9udEZhbWlseT1udWxsO2Vsc2V7Y29uc3QgYj1PYmplY3Qoci5wYXJzZUZvbnQpKHgpO3RoaXMuZm9udFN0eWxlPWIuc3R5bGUsdGhpcy5mb250VmFyaWFudD1iLnZhcmlhbnQsdGhpcy5mb250V2VpZ2h0PWIud2VpZ2h0LHRoaXMuZm9udFN0cmV0Y2g9Yi5zdHJldGNoLHRoaXMuZm9udFNpemU9T2JqZWN0KHMudG9OdW1iZXIpKGAke2Iuc2l6ZX0ke2IudW5pdH1gKSxiLmxpbmVIZWlnaHQmJih0aGlzLmxpbmVIZWlnaHQ9Yi5weExpbmVIZWlnaHQpLHRoaXMuZm9udEZhbWlseT1iLmZhbWlseX19fX0sZnVuY3Rpb24oYyxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4geH0pO3ZhciByPXQoMTIpLHM9dCgyMTkpLGc9dCgyNTEpLHY9dCgyMTMpLGg9dCgyNTIpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBsKGIsTyxtKXtyZXR1cm4gTyBpbiBiP09iamVjdC5kZWZpbmVQcm9wZXJ0eShiLE8se3ZhbHVlOm0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTpiW09dPW0sYn1jb25zdCB1PVN5bWJvbCgiek9yZGVyIiksTT1TeW1ib2woIm9yZGVyZWQiKSxmPVN5bWJvbCgiY2hpbGRyZW4iKSx5PVN5bWJvbCgic2VhbGVkIik7Y2xhc3MgeCBleHRlbmRzIHMuZGVmYXVsdHtjb25zdHJ1Y3RvcihPPXt9KXtzdXBlcihPKSx0aGlzW2ZdPVtdLHRoaXNbTV09bnVsbCx0aGlzW3VdPTB9Z2V0IGNoaWxkTm9kZXMoKXtyZXR1cm4gdGhpc1tmXX1nZXQgY2hpbGRyZW4oKXtyZXR1cm4gdGhpc1tmXX1nZXQgb3JkZXJlZENoaWxkcmVuKCl7cmV0dXJuIHRoaXNbTV18fCh0aGlzW01dPVsuLi50aGlzW2ZdXSx0aGlzW01dLnNvcnQoKE8sbSk9Pk8uekluZGV4LW0uekluZGV4fHxPLnpPcmRlci1tLnpPcmRlcikpLHRoaXNbTV19YXBwZW5kKC4uLk8pe3JldHVybiBPLm1hcChtPT50aGlzLmFwcGVuZENoaWxkKG0pKX1hcHBlbmRDaGlsZChPKXtyZXR1cm4gTy5yZW1vdmUoKSx0aGlzW2ZdLnB1c2goTyksTy5jb25uZWN0KHRoaXMsdGhpc1t1XSsrKSx0aGlzW01dJiYodGhpc1tNXS5sZW5ndGgmJk8uekluZGV4PHRoaXNbTV1bdGhpc1tNXS5sZW5ndGgtMV0uekluZGV4P3RoaXMucmVvcmRlcigpOnRoaXNbTV0ucHVzaChPKSksT31jbG9uZU5vZGUoTz0hMSl7Y29uc3QgbT1zdXBlci5jbG9uZU5vZGUoKTtyZXR1cm4gTyYmdGhpc1tmXS5mb3JFYWNoKHA9Pntjb25zdCBuPXAuY2xvbmVOb2RlKE8pO20uYXBwZW5kQ2hpbGQobil9KSxtfWRpc3BhdGNoUG9pbnRlckV2ZW50KE8pe2NvbnN0IG09dGhpcy5vcmRlcmVkQ2hpbGRyZW47Zm9yKGxldCBwPW0ubGVuZ3RoLTE7cD49MDtwLS0paWYobVtwXS5kaXNwYXRjaFBvaW50ZXJFdmVudChPKSlyZXR1cm4hMDtyZXR1cm4gc3VwZXIuZGlzcGF0Y2hQb2ludGVyRXZlbnQoTyl9ZHJhdyhPPVtdKXtpZih0aGlzLl9fY2FjaGVSZW5kZXJNYXRyaXg9dGhpcy5yZW5kZXJNYXRyaXgsc3VwZXIuZHJhdyhPKSwhdGhpc1t5XSYmdGhpcy5hdHRyaWJ1dGVzLmRpc3BsYXkhPT0ibm9uZSIpe2NvbnN0IG09dGhpcy5vcmRlcmVkQ2hpbGRyZW47Zm9yKGxldCBwPTA7cDxtLmxlbmd0aDtwKyspbVtwXS5kcmF3KE8pfXJldHVybiB0aGlzLl9fY2FjaGVSZW5kZXJNYXRyaXg9bnVsbCxPfWdldEVsZW1lbnRCeUlkKE8pe3JldHVybiBPYmplY3QoaC5xdWVyeVNlbGVjdG9yKShgIyR7T31gLHRoaXMpfWdldEVsZW1lbnRzQnlDbGFzc05hbWUoTyl7cmV0dXJuIE9iamVjdChoLnF1ZXJ5U2VsZWN0b3JBbGwpKGAuJHtPfWAsdGhpcyl9Z2V0RWxlbWVudHNCeU5hbWUoTyl7cmV0dXJuIE9iamVjdChoLnF1ZXJ5U2VsZWN0b3JBbGwpKGBbbmFtZT0iJHtPfSJdYCx0aGlzKX1nZXRFbGVtZW50c0J5VGFnTmFtZShPKXtyZXR1cm4gT2JqZWN0KGgucXVlcnlTZWxlY3RvckFsbCkoTyx0aGlzKX1pbnNlcnRCZWZvcmUoTyxtKXtpZihtPT1udWxsKXJldHVybiB0aGlzLmFwcGVuZENoaWxkKE8pO08ucmVtb3ZlKCk7Y29uc3QgcD10aGlzW2ZdLmluZGV4T2YobSk7aWYocDwwKXRocm93IG5ldyBFcnJvcigiSW52YWxpZCByZWZlcmVuY2Ugbm9kZS4iKTtjb25zdCBuPW0uek9yZGVyO2ZvcihsZXQgYT1wO2E8dGhpc1tmXS5sZW5ndGg7YSsrKXtjb25zdCBpPXRoaXNbZl1bYV0uek9yZGVyLG89dGhpc1tmXVthXTtkZWxldGUgby56T3JkZXIsT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sInpPcmRlciIse3ZhbHVlOmkrMSx3cml0YWJsZTohMSxjb25maWd1cmFibGU6ITB9KX1pZih0aGlzW2ZdLnNwbGljZShwLDAsTyksTy5jb25uZWN0KHRoaXMsbiksdGhpc1tNXSlpZihPLnpJbmRleCE9PW0uekluZGV4KXRoaXMucmVvcmRlcigpO2Vsc2V7Y29uc3QgYT10aGlzW01dLmluZGV4T2YobSk7dGhpc1tNXS5zcGxpY2UoYSwwLE8pfXJldHVybiBPfXF1ZXJ5U2VsZWN0b3IoTyl7cmV0dXJuIE9iamVjdChoLnF1ZXJ5U2VsZWN0b3IpKE8sdGhpcyl9cXVlcnlTZWxlY3RvckFsbChPKXtyZXR1cm4gT2JqZWN0KGgucXVlcnlTZWxlY3RvckFsbCkoTyx0aGlzKX1yZXBsYWNlQ2hpbGQoTyxtKXtPLnJlbW92ZSgpO2NvbnN0IHA9dGhpc1tmXS5pbmRleE9mKG0pO2lmKHA8MCl0aHJvdyBuZXcgRXJyb3IoIkludmFsaWQgcmVmZXJlbmNlIG5vZGUuIik7aWYodGhpc1tmXVtwXT1PLE8uY29ubmVjdCh0aGlzLG0uek9yZGVyKSx0aGlzW01dKWlmKE8uekluZGV4IT09bS56SW5kZXgpdGhpcy5yZW9yZGVyKCk7ZWxzZXtjb25zdCBuPXRoaXNbTV0uaW5kZXhPZihtKTt0aGlzW01dW25dPU99cmV0dXJuIG0uZGlzY29ubmVjdCh0aGlzKSxPfXJlbW92ZUFsbENoaWxkcmVuKCl7Y29uc3QgTz10aGlzW2ZdO2ZvcihsZXQgbT1PLmxlbmd0aC0xO20+PTA7bS0tKU9bbV0ucmVtb3ZlKCl9cmVtb3ZlQ2hpbGQoTyl7Y29uc3QgbT10aGlzW2ZdLmluZGV4T2YoTyk7aWYobT49MCl7aWYodGhpc1tmXS5zcGxpY2UobSwxKSx0aGlzW01dKXtjb25zdCBwPXRoaXNbTV0uaW5kZXhPZihPKTt0aGlzW01dLnNwbGljZShwLDEpfXJldHVybiBPLmRpc2Nvbm5lY3QodGhpcyksT31yZXR1cm4gbnVsbH1yZW9yZGVyKCl7dGhpc1tNXT1udWxsfXNlYWwoKXtmdW5jdGlvbiBPKGEsaSl7Y29uc3Qgbz1bXTtmb3IobGV0IFQ9MDtUPGEubGVuZ3RoO1QrKyl7Y29uc3QgUD1bLi4uYVtUXV07Zm9yKGxldCBDPTE7QzxQLmxlbmd0aDtDKz0yKXtjb25zdCBJPVBbQ10sQT1QW0MrMV07UFtDXT1JKmlbMF0rQSppWzJdK2lbNF0sUFtDKzFdPUkqaVsxXStBKmlbM10raVs1XX1vLnB1c2goUCl9cmV0dXJuIG99Y29uc3QgbT10aGlzLm9yZGVyZWRDaGlsZHJlbixwPW5ldyByLkZpZ3VyZTJELG49dGhpcy5sb2NhbE1hdHJpeDtmb3IobGV0IGE9MDthPG0ubGVuZ3RoO2ErKyl7bGV0IGk9bVthXTtpZihpIGluc3RhbmNlb2YgeCYmKGk9aS5zZWFsKCkpLGkuY2xpZW50Qm94KXtsZXQgbz1pLmNsaWVudEJveC5jb250b3Vycy5wYXRoO289TyhvLGkubG9jYWxNYXRyaXgpLHAuYWRkUGF0aChvKX1pZihpLnBhdGgpe2xldCBvPWkucGF0aC5jb250b3Vycy5wYXRoO289TyhvLGkubG9jYWxNYXRyaXgpLHAuYWRkUGF0aChvKX19cmV0dXJuIHRoaXNbeV09ITAsdGhpcy5jbGllbnRCb3g9cCx7Y2xpZW50Qm94OnAsbG9jYWxNYXRyaXg6bn19c2V0UmVzb2x1dGlvbih7d2lkdGg6TyxoZWlnaHQ6bX0pe3N1cGVyLnNldFJlc29sdXRpb24oe3dpZHRoOk8saGVpZ2h0Om19KSx0aGlzW2ZdLmZvckVhY2gocD0+e3Auc2V0UmVzb2x1dGlvbih7d2lkdGg6TyxoZWlnaHQ6bX0pfSl9dXBkYXRlQ29udG91cnMoKXt0aGlzW3ldfHxzdXBlci51cGRhdGVDb250b3VycygpfX1sKHgsIkF0dHIiLGcuZGVmYXVsdCksdi5kZWZhdWx0LnJlZ2lzdGVyTm9kZSh4LCJncm91cCIpfSxmdW5jdGlvbihjLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBzfSk7dmFyIHI9dCgyMjApO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjbGFzcyBzIGV4dGVuZHMgci5kZWZhdWx0e319LGZ1bmN0aW9uKGMsZSx0KXt0LnIoZSksdC5kKGUsInF1ZXJ5U2VsZWN0b3JBbGwiLGZ1bmN0aW9uKCl7cmV0dXJuIHl9KSx0LmQoZSwicXVlcnlTZWxlY3RvciIsZnVuY3Rpb24oKXtyZXR1cm4geH0pLHQuZChlLCJpc01hdGNoZWQiLGZ1bmN0aW9uKCl7cmV0dXJuIGJ9KSx0LmQoZSwiY29tcGlsZSIsZnVuY3Rpb24oKXtyZXR1cm4gT30pO3ZhciByPXQoMjIxKSxzPXQoMjEzKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3QgZz10KDI1Myk7ZnVuY3Rpb24gdihtKXtyZXR1cm4gbS5ub2RlVHlwZT09PTF8fHMuZGVmYXVsdC5pc1Nwcml0ZU5vZGUobS5ub2RlTmFtZSl9ZnVuY3Rpb24gaChtKXtyZXR1cm4gQXJyYXkuZnJvbShtLmNoaWxkTm9kZXN8fFtdKX1mdW5jdGlvbiBsKG0pe3JldHVybiBzLmRlZmF1bHQuaXNTcHJpdGVOb2RlKG0ubm9kZU5hbWUpP20ucGFyZW50fHxtLmNhbnZhc3x8bS5jb250YWluZXI6bS5wYXJlbnRFbGVtZW50fWZ1bmN0aW9uIHUobSl7bGV0IHA9bS5sZW5ndGgsbixhLGk7Zm9yKDstLXA+LTE7KXtmb3Iobj1hPW1bcF0sbVtwXT1udWxsLGk9ITA7YTspe2lmKG0uaW5kZXhPZihhKT4tMSl7aT0hMSxtLnNwbGljZShwLDEpO2JyZWFrfWE9bChhKX1pJiYobVtwXT1uKX1yZXR1cm4gbX1jb25zdCBNPXtpc1RhZzp2LGV4aXN0c09uZShtLHApe3JldHVybiBwLnNvbWUobj0+dihuKT9tKG4pfHxNLmV4aXN0c09uZShtLGgobikpOiExKX0sZ2V0U2libGluZ3MobSl7Y29uc3QgcD1sKG0pO3JldHVybiBwJiZoKHApfSxnZXRDaGlsZHJlbjpoLGdldFBhcmVudDpsLGdldEF0dHJpYnV0ZVZhbHVlKG0scCl7aWYobS5ub2RlVHlwZT09PTEmJnA9PT0iY2xhc3MifHxwPT09ImlkIilyZXR1cm4gbVtwXTtpZih0aGlzLmhhc0F0dHJpYihtLHApKXtsZXQgbj1tLmF0dHJpYnV0ZXNbcF07cmV0dXJuIEFycmF5LmlzQXJyYXkobikmJihuPWBbJHtuLmpvaW4oKX1dYCksU3RyaW5nKG4pfX0saGFzQXR0cmliKG0scCl7cmV0dXJuIG0uYXR0cmlidXRlc1twXSE9bnVsbH0scmVtb3ZlU3Vic2V0czp1LGdldE5hbWUobSl7cmV0dXJuIG0udGFnTmFtZT9tLnRhZ05hbWUudG9Mb3dlckNhc2UoKTpudWxsfSxmaW5kT25lOmZ1bmN0aW9uIG0ocCxuKXtsZXQgYT1udWxsO2ZvcihsZXQgaT0wLG89bi5sZW5ndGg7aTxvJiYhYTtpKyspaWYocChuW2ldKSlhPW5baV07ZWxzZXtjb25zdCBUPWgobltpXSk7VCYmVC5sZW5ndGg+MCYmKGE9bShwLFQpKX1yZXR1cm4gYX0sZmluZEFsbDpmdW5jdGlvbiBtKHAsbil7bGV0IGE9W107Zm9yKGxldCBpPTAsbz1uLmxlbmd0aDtpPG87aSsrKXtpZighdihuW2ldKSljb250aW51ZTtwKG5baV0pJiZhLnB1c2gobltpXSk7Y29uc3QgVD1oKG5baV0pO1QmJihhPWEuY29uY2F0KG0ocCxUKSkpfXJldHVybiBhfSxnZXRUZXh0OmZ1bmN0aW9uIG0ocCl7cmV0dXJuIEFycmF5LmlzQXJyYXkocCk/cC5tYXAobSkuam9pbigiIik6dihwKT9tKGgocCkpOnAubm9kZVR5cGU9PT0zP3Aubm9kZVZhbHVlOnMuZGVmYXVsdC5pc1Nwcml0ZU5vZGUocC5ub2RlTmFtZSk/cC50ZXh0OiIifX07ZnVuY3Rpb24gZihtKXtpZih0eXBlb2YgbSE9InN0cmluZyIpcmV0dXJuIG07bGV0IHA9bS5tYXRjaCgvXFsoYmdjb2xvcnxmaWxsQ29sb3J8c3Ryb2tlQ29sb3J8Y29sb3IpXHMqPVxzKlsnIl0/XHcrWyciXT9cXS9nKTtyZXR1cm4gcCYmKHA9cC5tYXAobj0+e2NvbnN0IGE9bi5zbGljZSgxLC0xKS5zcGxpdCgiPSIpLGk9T2JqZWN0KHIucGFyc2VDb2xvcikoYVsxXS5yZXBsYWNlKC9bJyJdL2csIiIpKTtyZXR1cm5bbixgWyR7YVswXX09IiR7aX0iXWBdfSkscC5mb3JFYWNoKChbbixhXSk9PnttPW0ucmVwbGFjZShuLGEpfSkpLHA9bS5tYXRjaCgvXFtcdytccyo9XHMqWyciXVxbLis/XF1bJyJdXF0vZykscCYmKHA9cC5tYXAobj0+e2NvbnN0IGE9bi5zbGljZSgxLC0xKS5zcGxpdCgiPSIpLGk9YVsxXS5zbGljZSgyLC0yKS5zcGxpdCgvLC9nKS5tYXAobz0+by50cmltKCkpO3JldHVybltuLGBbJHthWzBdfT0iWyR7aX1dIl1gXX0pLHAuZm9yRWFjaCgoW24sYV0pPT57bT1tLnJlcGxhY2UobixhKX0pKSxtfWZ1bmN0aW9uIHkobSxwKXtyZXR1cm4gZy5zZWxlY3RBbGwoZihtKSxwLHthZGFwdGVyOk19KX1mdW5jdGlvbiB4KG0scCl7cmV0dXJuIGcuc2VsZWN0T25lKGYobSkscCx7YWRhcHRlcjpNfSl9ZnVuY3Rpb24gYihtLHApe3JldHVybiBnLmlzKG0sZihwKSx7YWRhcHRlcjpNfSl9ZnVuY3Rpb24gTyhtKXtyZXR1cm4gZy5jb21waWxlKGYobSkse2FkYXB0ZXI6TX0pfX0sZnVuY3Rpb24oYyxlLHQpe2MuZXhwb3J0cz1PO3ZhciByPXQoMjU0KSxzPXQoMjczKS5mYWxzZUZ1bmMsZz10KDI3NCk7ZnVuY3Rpb24gdihtKXtyZXR1cm4gZnVuY3Rpb24obixhLGkpe3JldHVybiBhPWF8fHt9LGEuYWRhcHRlcj1hLmFkYXB0ZXJ8fHIsbShuLGEsaSl9fXZhciBoPXYoZyksbD12KGcuY29tcGlsZVVuc2FmZSk7ZnVuY3Rpb24gdShtKXtyZXR1cm4gZnVuY3Rpb24obixhLGkpe3JldHVybiBpPWl8fHt9LGkuYWRhcHRlcj1pLmFkYXB0ZXJ8fHIsdHlwZW9mIG4hPSJmdW5jdGlvbiImJihuPWwobixpLGEpKSxuLnNob3VsZFRlc3ROZXh0U2libGluZ3MmJihhPWYoaSYmaS5jb250ZXh0fHxhLGkuYWRhcHRlcikpLEFycmF5LmlzQXJyYXkoYSk/YT1pLmFkYXB0ZXIucmVtb3ZlU3Vic2V0cyhhKTphPWkuYWRhcHRlci5nZXRDaGlsZHJlbihhKSxtKG4sYSxpKX19ZnVuY3Rpb24gTShtLHApe3ZhciBuPXAuZ2V0U2libGluZ3MobSk7aWYoIUFycmF5LmlzQXJyYXkobikpcmV0dXJuW107Zm9yKG49bi5zbGljZSgwKTtuLnNoaWZ0KCkhPT1tOyk7cmV0dXJuIG59ZnVuY3Rpb24gZihtLHApe0FycmF5LmlzQXJyYXkobSl8fChtPVttXSk7Zm9yKHZhciBuPW0uc2xpY2UoMCksYT0wLGk9bS5sZW5ndGg7YTxpO2ErKyl7dmFyIG89TShuW2FdLHApO24ucHVzaC5hcHBseShuLG8pfXJldHVybiBufXZhciB5PXUoZnVuY3Rpb24ocCxuLGEpe3JldHVybiBwPT09c3x8IW58fG4ubGVuZ3RoPT09MD9bXTphLmFkYXB0ZXIuZmluZEFsbChwLG4pfSkseD11KGZ1bmN0aW9uKHAsbixhKXtyZXR1cm4gcD09PXN8fCFufHxuLmxlbmd0aD09PTA/bnVsbDphLmFkYXB0ZXIuZmluZE9uZShwLG4pfSk7ZnVuY3Rpb24gYihtLHAsbil7cmV0dXJuIG49bnx8e30sbi5hZGFwdGVyPW4uYWRhcHRlcnx8ciwodHlwZW9mIHA9PSJmdW5jdGlvbiI/cDpoKHAsbikpKG0pfWZ1bmN0aW9uIE8obSxwLG4pe3JldHVybiB5KG0scCxuKX1PLmNvbXBpbGU9aCxPLmZpbHRlcnM9Zy5Qc2V1ZG9zLmZpbHRlcnMsTy5wc2V1ZG9zPWcuUHNldWRvcy5wc2V1ZG9zLE8uc2VsZWN0QWxsPXksTy5zZWxlY3RPbmU9eCxPLmlzPWIsTy5wYXJzZT1oLE8uaXRlcmF0ZT15LE8uX2NvbXBpbGVVbnNhZmU9bCxPLl9jb21waWxlVG9rZW49Zy5jb21waWxlVG9rZW59LGZ1bmN0aW9uKGMsZSx0KXt2YXIgcj1jLmV4cG9ydHM7W3QoMjU1KSx0KDI2OCksdCgyNjkpLHQoMjcwKSx0KDI3MSksdCgyNzIpXS5mb3JFYWNoKGZ1bmN0aW9uKHMpe09iamVjdC5rZXlzKHMpLmZvckVhY2goZnVuY3Rpb24oZyl7cltnXT1zW2ddLmJpbmQocil9KX0pfSxmdW5jdGlvbihjLGUsdCl7dmFyIHI9dCgyNTYpLHM9dCgyNTcpLGc9ci5pc1RhZztjLmV4cG9ydHM9e2dldElubmVySFRNTDp2LGdldE91dGVySFRNTDpzLGdldFRleHQ6aH07ZnVuY3Rpb24gdihsLHUpe3JldHVybiBsLmNoaWxkcmVuP2wuY2hpbGRyZW4ubWFwKGZ1bmN0aW9uKE0pe3JldHVybiBzKE0sdSl9KS5qb2luKCIiKToiIn1mdW5jdGlvbiBoKGwpe3JldHVybiBBcnJheS5pc0FycmF5KGwpP2wubWFwKGgpLmpvaW4oIiIpOmcobCk/bC5uYW1lPT09ImJyIj9gCmA6aChsLmNoaWxkcmVuKTpsLnR5cGU9PT1yLkNEQVRBP2gobC5jaGlsZHJlbik6bC50eXBlPT09ci5UZXh0P2wuZGF0YToiIn19LGZ1bmN0aW9uKGMsZSl7Yy5leHBvcnRzPXtUZXh0OiJ0ZXh0IixEaXJlY3RpdmU6ImRpcmVjdGl2ZSIsQ29tbWVudDoiY29tbWVudCIsU2NyaXB0OiJzY3JpcHQiLFN0eWxlOiJzdHlsZSIsVGFnOiJ0YWciLENEQVRBOiJjZGF0YSIsRG9jdHlwZToiZG9jdHlwZSIsaXNUYWc6ZnVuY3Rpb24odCl7cmV0dXJuIHQudHlwZT09PSJ0YWcifHx0LnR5cGU9PT0ic2NyaXB0Inx8dC50eXBlPT09InN0eWxlIn19fSxmdW5jdGlvbihjLGUsdCl7dmFyIHI9dCgyNTgpLHM9dCgyNTkpLGc9dCgyNjcpO2cuZWxlbWVudE5hbWVzLl9fcHJvdG9fXz1udWxsLGcuYXR0cmlidXRlTmFtZXMuX19wcm90b19fPW51bGw7dmFyIHY9e19fcHJvdG9fXzpudWxsLHN0eWxlOiEwLHNjcmlwdDohMCx4bXA6ITAsaWZyYW1lOiEwLG5vZW1iZWQ6ITAsbm9mcmFtZXM6ITAscGxhaW50ZXh0OiEwLG5vc2NyaXB0OiEwfTtmdW5jdGlvbiBoKG0scCl7aWYobSl7dmFyIG49IiIsYTtmb3IodmFyIGkgaW4gbSlhPW1baV0sbiYmKG4rPSIgIikscC54bWxNb2RlPT09ImZvcmVpZ24iJiYoaT1nLmF0dHJpYnV0ZU5hbWVzW2ldfHxpKSxuKz1pLChhIT09bnVsbCYmYSE9PSIifHxwLnhtbE1vZGUpJiYobis9Jz0iJysocC5kZWNvZGVFbnRpdGllcz9zLmVuY29kZVhNTChhKTphLnJlcGxhY2UoL1wiL2csIiZxdW90OyIpKSsnIicpO3JldHVybiBufX12YXIgbD17X19wcm90b19fOm51bGwsYXJlYTohMCxiYXNlOiEwLGJhc2Vmb250OiEwLGJyOiEwLGNvbDohMCxjb21tYW5kOiEwLGVtYmVkOiEwLGZyYW1lOiEwLGhyOiEwLGltZzohMCxpbnB1dDohMCxpc2luZGV4OiEwLGtleWdlbjohMCxsaW5rOiEwLG1ldGE6ITAscGFyYW06ITAsc291cmNlOiEwLHRyYWNrOiEwLHdicjohMH0sdT1jLmV4cG9ydHM9ZnVuY3Rpb24obSxwKXshQXJyYXkuaXNBcnJheShtKSYmIW0uY2hlZXJpbyYmKG09W21dKSxwPXB8fHt9O2Zvcih2YXIgbj0iIixhPTA7YTxtLmxlbmd0aDthKyspe3ZhciBpPW1bYV07aS50eXBlPT09InJvb3QiP24rPXUoaS5jaGlsZHJlbixwKTpyLmlzVGFnKGkpP24rPWYoaSxwKTppLnR5cGU9PT1yLkRpcmVjdGl2ZT9uKz15KGkpOmkudHlwZT09PXIuQ29tbWVudD9uKz1PKGkpOmkudHlwZT09PXIuQ0RBVEE/bis9YihpKTpuKz14KGkscCl9cmV0dXJuIG59LE09WyJtaSIsIm1vIiwibW4iLCJtcyIsIm10ZXh0IiwiYW5ub3RhdGlvbi14bWwiLCJmb3JlaWduT2JqZWN0IiwiZGVzYyIsInRpdGxlIl07ZnVuY3Rpb24gZihtLHApe3AueG1sTW9kZT09PSJmb3JlaWduIiYmKG0ubmFtZT1nLmVsZW1lbnROYW1lc1ttLm5hbWVdfHxtLm5hbWUsbS5wYXJlbnQmJk0uaW5kZXhPZihtLnBhcmVudC5uYW1lKT49MCYmKHA9T2JqZWN0LmFzc2lnbih7fSxwLHt4bWxNb2RlOiExfSkpKSwhcC54bWxNb2RlJiZbInN2ZyIsIm1hdGgiXS5pbmRleE9mKG0ubmFtZSk+PTAmJihwPU9iamVjdC5hc3NpZ24oe30scCx7eG1sTW9kZToiZm9yZWlnbiJ9KSk7dmFyIG49IjwiK20ubmFtZSxhPWgobS5hdHRyaWJzLHApO3JldHVybiBhJiYobis9IiAiK2EpLHAueG1sTW9kZSYmKCFtLmNoaWxkcmVufHxtLmNoaWxkcmVuLmxlbmd0aD09PTApP24rPSIvPiI6KG4rPSI+IixtLmNoaWxkcmVuJiYobis9dShtLmNoaWxkcmVuLHApKSwoIWxbbS5uYW1lXXx8cC54bWxNb2RlKSYmKG4rPSI8LyIrbS5uYW1lKyI+IikpLG59ZnVuY3Rpb24geShtKXtyZXR1cm4iPCIrbS5kYXRhKyI+In1mdW5jdGlvbiB4KG0scCl7dmFyIG49bS5kYXRhfHwiIjtyZXR1cm4gcC5kZWNvZGVFbnRpdGllcyYmIShtLnBhcmVudCYmbS5wYXJlbnQubmFtZSBpbiB2KSYmKG49cy5lbmNvZGVYTUwobikpLG59ZnVuY3Rpb24gYihtKXtyZXR1cm4iPCFbQ0RBVEFbIittLmNoaWxkcmVuWzBdLmRhdGErIl1dPiJ9ZnVuY3Rpb24gTyhtKXtyZXR1cm4iPCEtLSIrbS5kYXRhKyItLT4ifX0sZnVuY3Rpb24oYyxlLHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KTtmdW5jdGlvbiByKHMpe3JldHVybiBzLnR5cGU9PT0idGFnInx8cy50eXBlPT09InNjcmlwdCJ8fHMudHlwZT09PSJzdHlsZSJ9ZS5pc1RhZz1yLGUuVGV4dD0idGV4dCIsZS5EaXJlY3RpdmU9ImRpcmVjdGl2ZSIsZS5Db21tZW50PSJjb21tZW50IixlLlNjcmlwdD0ic2NyaXB0IixlLlN0eWxlPSJzdHlsZSIsZS5UYWc9InRhZyIsZS5DREFUQT0iY2RhdGEiLGUuRG9jdHlwZT0iZG9jdHlwZSJ9LGZ1bmN0aW9uKGMsZSx0KXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksZS5lbmNvZGU9ZS5kZWNvZGVTdHJpY3Q9ZS5kZWNvZGU9dm9pZCAwO3ZhciByPXQoMjYwKSxzPXQoMjY2KTtmdW5jdGlvbiBnKE0sZil7cmV0dXJuKCFmfHxmPD0wP3IuZGVjb2RlWE1MOnIuZGVjb2RlSFRNTCkoTSl9ZS5kZWNvZGU9ZztmdW5jdGlvbiB2KE0sZil7cmV0dXJuKCFmfHxmPD0wP3IuZGVjb2RlWE1MOnIuZGVjb2RlSFRNTFN0cmljdCkoTSl9ZS5kZWNvZGVTdHJpY3Q9djtmdW5jdGlvbiBoKE0sZil7cmV0dXJuKCFmfHxmPD0wP3MuZW5jb2RlWE1MOnMuZW5jb2RlSFRNTCkoTSl9ZS5lbmNvZGU9aDt2YXIgbD10KDI2Nik7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsImVuY29kZVhNTCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGwuZW5jb2RlWE1MfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJlbmNvZGVIVE1MIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gbC5lbmNvZGVIVE1MfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJlc2NhcGUiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBsLmVzY2FwZX19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiZW5jb2RlSFRNTDQiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBsLmVuY29kZUhUTUx9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsImVuY29kZUhUTUw1Iix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gbC5lbmNvZGVIVE1MfX0pO3ZhciB1PXQoMjYwKTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiZGVjb2RlWE1MIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdS5kZWNvZGVYTUx9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsImRlY29kZUhUTUwiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiB1LmRlY29kZUhUTUx9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsImRlY29kZUhUTUxTdHJpY3QiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiB1LmRlY29kZUhUTUxTdHJpY3R9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsImRlY29kZUhUTUw0Iix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdS5kZWNvZGVIVE1MfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJkZWNvZGVIVE1MNSIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHUuZGVjb2RlSFRNTH19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiZGVjb2RlSFRNTDRTdHJpY3QiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiB1LmRlY29kZUhUTUxTdHJpY3R9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsImRlY29kZUhUTUw1U3RyaWN0Iix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdS5kZWNvZGVIVE1MU3RyaWN0fX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJkZWNvZGVYTUxTdHJpY3QiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiB1LmRlY29kZVhNTH19KX0sZnVuY3Rpb24oYyxlLHQpe3ZhciByPXRoaXMmJnRoaXMuX19pbXBvcnREZWZhdWx0fHxmdW5jdGlvbihmKXtyZXR1cm4gZiYmZi5fX2VzTW9kdWxlP2Y6e2RlZmF1bHQ6Zn19O09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxlLmRlY29kZUhUTUw9ZS5kZWNvZGVIVE1MU3RyaWN0PWUuZGVjb2RlWE1MPXZvaWQgMDt2YXIgcz1yKHQoMjYxKSksZz1yKHQoMjYyKSksdj1yKHQoMjYzKSksaD1yKHQoMjY0KSk7ZS5kZWNvZGVYTUw9bCh2LmRlZmF1bHQpLGUuZGVjb2RlSFRNTFN0cmljdD1sKHMuZGVmYXVsdCk7ZnVuY3Rpb24gbChmKXt2YXIgeT1PYmplY3Qua2V5cyhmKS5qb2luKCJ8IikseD1NKGYpO3krPSJ8I1t4WF1bXFxkYS1mQS1GXSt8I1xcZCsiO3ZhciBiPW5ldyBSZWdFeHAoIiYoPzoiK3krIik7IiwiZyIpO3JldHVybiBmdW5jdGlvbihPKXtyZXR1cm4gU3RyaW5nKE8pLnJlcGxhY2UoYix4KX19dmFyIHU9ZnVuY3Rpb24oZix5KXtyZXR1cm4gZjx5PzE6LTF9O2UuZGVjb2RlSFRNTD1mdW5jdGlvbigpe2Zvcih2YXIgZj1PYmplY3Qua2V5cyhnLmRlZmF1bHQpLnNvcnQodSkseT1PYmplY3Qua2V5cyhzLmRlZmF1bHQpLnNvcnQodSkseD0wLGI9MDt4PHkubGVuZ3RoO3grKylmW2JdPT09eVt4XT8oeVt4XSs9Ijs/IixiKyspOnlbeF0rPSI7Ijt2YXIgTz1uZXcgUmVnRXhwKCImKD86Iit5LmpvaW4oInwiKSsifCNbeFhdW1xcZGEtZkEtRl0rOz98I1xcZCs7PykiLCJnIiksbT1NKHMuZGVmYXVsdCk7ZnVuY3Rpb24gcChuKXtyZXR1cm4gbi5zdWJzdHIoLTEpIT09IjsiJiYobis9IjsiKSxtKG4pfXJldHVybiBmdW5jdGlvbihuKXtyZXR1cm4gU3RyaW5nKG4pLnJlcGxhY2UoTyxwKX19KCk7ZnVuY3Rpb24gTShmKXtyZXR1cm4gZnVuY3Rpb24oeCl7aWYoeC5jaGFyQXQoMSk9PT0iIyIpe3ZhciBiPXguY2hhckF0KDIpO3JldHVybiBiPT09IlgifHxiPT09IngiP2guZGVmYXVsdChwYXJzZUludCh4LnN1YnN0cigzKSwxNikpOmguZGVmYXVsdChwYXJzZUludCh4LnN1YnN0cigyKSwxMCkpfXJldHVybiBmW3guc2xpY2UoMSwtMSldfX19LGZ1bmN0aW9uKGMpe2MuZXhwb3J0cz1KU09OLnBhcnNlKCd7IkFhY3V0ZSI6IsOBIiwiYWFjdXRlIjoiw6EiLCJBYnJldmUiOiLEgiIsImFicmV2ZSI6IsSDIiwiYWMiOiLiiL4iLCJhY2QiOiLiiL8iLCJhY0UiOiLiiL7MsyIsIkFjaXJjIjoiw4IiLCJhY2lyYyI6IsOiIiwiYWN1dGUiOiLCtCIsIkFjeSI6ItCQIiwiYWN5Ijoi0LAiLCJBRWxpZyI6IsOGIiwiYWVsaWciOiLDpiIsImFmIjoi4oGhIiwiQWZyIjoi8J2UhCIsImFmciI6IvCdlJ4iLCJBZ3JhdmUiOiLDgCIsImFncmF2ZSI6IsOgIiwiYWxlZnN5bSI6IuKEtSIsImFsZXBoIjoi4oS1IiwiQWxwaGEiOiLOkSIsImFscGhhIjoizrEiLCJBbWFjciI6IsSAIiwiYW1hY3IiOiLEgSIsImFtYWxnIjoi4qi/IiwiYW1wIjoiJiIsIkFNUCI6IiYiLCJhbmRhbmQiOiLiqZUiLCJBbmQiOiLiqZMiLCJhbmQiOiLiiKciLCJhbmRkIjoi4qmcIiwiYW5kc2xvcGUiOiLiqZgiLCJhbmR2Ijoi4qmaIiwiYW5nIjoi4oigIiwiYW5nZSI6IuKmpCIsImFuZ2xlIjoi4oigIiwiYW5nbXNkYWEiOiLipqgiLCJhbmdtc2RhYiI6IuKmqSIsImFuZ21zZGFjIjoi4qaqIiwiYW5nbXNkYWQiOiLipqsiLCJhbmdtc2RhZSI6IuKmrCIsImFuZ21zZGFmIjoi4qatIiwiYW5nbXNkYWciOiLipq4iLCJhbmdtc2RhaCI6IuKmryIsImFuZ21zZCI6IuKIoSIsImFuZ3J0Ijoi4oifIiwiYW5ncnR2YiI6IuKKviIsImFuZ3J0dmJkIjoi4qadIiwiYW5nc3BoIjoi4oiiIiwiYW5nc3QiOiLDhSIsImFuZ3phcnIiOiLijbwiLCJBb2dvbiI6IsSEIiwiYW9nb24iOiLEhSIsIkFvcGYiOiLwnZS4IiwiYW9wZiI6IvCdlZIiLCJhcGFjaXIiOiLiqa8iLCJhcCI6IuKJiCIsImFwRSI6IuKpsCIsImFwZSI6IuKJiiIsImFwaWQiOiLiiYsiLCJhcG9zIjoiXCciLCJBcHBseUZ1bmN0aW9uIjoi4oGhIiwiYXBwcm94Ijoi4omIIiwiYXBwcm94ZXEiOiLiiYoiLCJBcmluZyI6IsOFIiwiYXJpbmciOiLDpSIsIkFzY3IiOiLwnZKcIiwiYXNjciI6IvCdkrYiLCJBc3NpZ24iOiLiiZQiLCJhc3QiOiIqIiwiYXN5bXAiOiLiiYgiLCJhc3ltcGVxIjoi4omNIiwiQXRpbGRlIjoiw4MiLCJhdGlsZGUiOiLDoyIsIkF1bWwiOiLDhCIsImF1bWwiOiLDpCIsImF3Y29uaW50Ijoi4oizIiwiYXdpbnQiOiLiqJEiLCJiYWNrY29uZyI6IuKJjCIsImJhY2tlcHNpbG9uIjoiz7YiLCJiYWNrcHJpbWUiOiLigLUiLCJiYWNrc2ltIjoi4oi9IiwiYmFja3NpbWVxIjoi4ouNIiwiQmFja3NsYXNoIjoi4oiWIiwiQmFydiI6IuKrpyIsImJhcnZlZSI6IuKKvSIsImJhcndlZCI6IuKMhSIsIkJhcndlZCI6IuKMhiIsImJhcndlZGdlIjoi4oyFIiwiYmJyayI6IuKOtSIsImJicmt0YnJrIjoi4o62IiwiYmNvbmciOiLiiYwiLCJCY3kiOiLQkSIsImJjeSI6ItCxIiwiYmRxdW8iOiLigJ4iLCJiZWNhdXMiOiLiiLUiLCJiZWNhdXNlIjoi4oi1IiwiQmVjYXVzZSI6IuKItSIsImJlbXB0eXYiOiLiprAiLCJiZXBzaSI6Is+2IiwiYmVybm91Ijoi4oSsIiwiQmVybm91bGxpcyI6IuKErCIsIkJldGEiOiLOkiIsImJldGEiOiLOsiIsImJldGgiOiLihLYiLCJiZXR3ZWVuIjoi4omsIiwiQmZyIjoi8J2UhSIsImJmciI6IvCdlJ8iLCJiaWdjYXAiOiLii4IiLCJiaWdjaXJjIjoi4pevIiwiYmlnY3VwIjoi4ouDIiwiYmlnb2RvdCI6IuKogCIsImJpZ29wbHVzIjoi4qiBIiwiYmlnb3RpbWVzIjoi4qiCIiwiYmlnc3FjdXAiOiLiqIYiLCJiaWdzdGFyIjoi4piFIiwiYmlndHJpYW5nbGVkb3duIjoi4pa9IiwiYmlndHJpYW5nbGV1cCI6IuKWsyIsImJpZ3VwbHVzIjoi4qiEIiwiYmlndmVlIjoi4ouBIiwiYmlnd2VkZ2UiOiLii4AiLCJia2Fyb3ciOiLipI0iLCJibGFja2xvemVuZ2UiOiLip6siLCJibGFja3NxdWFyZSI6IuKWqiIsImJsYWNrdHJpYW5nbGUiOiLilrQiLCJibGFja3RyaWFuZ2xlZG93biI6IuKWviIsImJsYWNrdHJpYW5nbGVsZWZ0Ijoi4peCIiwiYmxhY2t0cmlhbmdsZXJpZ2h0Ijoi4pa4IiwiYmxhbmsiOiLikKMiLCJibGsxMiI6IuKWkiIsImJsazE0Ijoi4paRIiwiYmxrMzQiOiLilpMiLCJibG9jayI6IuKWiCIsImJuZSI6Ij3ig6UiLCJibmVxdWl2Ijoi4omh4oOlIiwiYk5vdCI6IuKrrSIsImJub3QiOiLijJAiLCJCb3BmIjoi8J2UuSIsImJvcGYiOiLwnZWTIiwiYm90Ijoi4oqlIiwiYm90dG9tIjoi4oqlIiwiYm93dGllIjoi4ouIIiwiYm94Ym94Ijoi4qeJIiwiYm94ZGwiOiLilJAiLCJib3hkTCI6IuKVlSIsImJveERsIjoi4pWWIiwiYm94REwiOiLilZciLCJib3hkciI6IuKUjCIsImJveGRSIjoi4pWSIiwiYm94RHIiOiLilZMiLCJib3hEUiI6IuKVlCIsImJveGgiOiLilIAiLCJib3hIIjoi4pWQIiwiYm94aGQiOiLilKwiLCJib3hIZCI6IuKVpCIsImJveGhEIjoi4pWlIiwiYm94SEQiOiLilaYiLCJib3hodSI6IuKUtCIsImJveEh1Ijoi4pWnIiwiYm94aFUiOiLilagiLCJib3hIVSI6IuKVqSIsImJveG1pbnVzIjoi4oqfIiwiYm94cGx1cyI6IuKKniIsImJveHRpbWVzIjoi4oqgIiwiYm94dWwiOiLilJgiLCJib3h1TCI6IuKVmyIsImJveFVsIjoi4pWcIiwiYm94VUwiOiLilZ0iLCJib3h1ciI6IuKUlCIsImJveHVSIjoi4pWYIiwiYm94VXIiOiLilZkiLCJib3hVUiI6IuKVmiIsImJveHYiOiLilIIiLCJib3hWIjoi4pWRIiwiYm94dmgiOiLilLwiLCJib3h2SCI6IuKVqiIsImJveFZoIjoi4pWrIiwiYm94VkgiOiLilawiLCJib3h2bCI6IuKUpCIsImJveHZMIjoi4pWhIiwiYm94VmwiOiLilaIiLCJib3hWTCI6IuKVoyIsImJveHZyIjoi4pScIiwiYm94dlIiOiLilZ4iLCJib3hWciI6IuKVnyIsImJveFZSIjoi4pWgIiwiYnByaW1lIjoi4oC1IiwiYnJldmUiOiLLmCIsIkJyZXZlIjoiy5giLCJicnZiYXIiOiLCpiIsImJzY3IiOiLwnZK3IiwiQnNjciI6IuKErCIsImJzZW1pIjoi4oGPIiwiYnNpbSI6IuKIvSIsImJzaW1lIjoi4ouNIiwiYnNvbGIiOiLip4UiLCJic29sIjoiXFxcXCIsImJzb2xoc3ViIjoi4p+IIiwiYnVsbCI6IuKAoiIsImJ1bGxldCI6IuKAoiIsImJ1bXAiOiLiiY4iLCJidW1wRSI6IuKqriIsImJ1bXBlIjoi4omPIiwiQnVtcGVxIjoi4omOIiwiYnVtcGVxIjoi4omPIiwiQ2FjdXRlIjoixIYiLCJjYWN1dGUiOiLEhyIsImNhcGFuZCI6IuKphCIsImNhcGJyY3VwIjoi4qmJIiwiY2FwY2FwIjoi4qmLIiwiY2FwIjoi4oipIiwiQ2FwIjoi4ouSIiwiY2FwY3VwIjoi4qmHIiwiY2FwZG90Ijoi4qmAIiwiQ2FwaXRhbERpZmZlcmVudGlhbEQiOiLihYUiLCJjYXBzIjoi4oip77iAIiwiY2FyZXQiOiLigYEiLCJjYXJvbiI6IsuHIiwiQ2F5bGV5cyI6IuKErSIsImNjYXBzIjoi4qmNIiwiQ2Nhcm9uIjoixIwiLCJjY2Fyb24iOiLEjSIsIkNjZWRpbCI6IsOHIiwiY2NlZGlsIjoiw6ciLCJDY2lyYyI6IsSIIiwiY2NpcmMiOiLEiSIsIkNjb25pbnQiOiLiiLAiLCJjY3VwcyI6IuKpjCIsImNjdXBzc20iOiLiqZAiLCJDZG90IjoixIoiLCJjZG90IjoixIsiLCJjZWRpbCI6IsK4IiwiQ2VkaWxsYSI6IsK4IiwiY2VtcHR5diI6IuKmsiIsImNlbnQiOiLCoiIsImNlbnRlcmRvdCI6IsK3IiwiQ2VudGVyRG90IjoiwrciLCJjZnIiOiLwnZSgIiwiQ2ZyIjoi4oStIiwiQ0hjeSI6ItCnIiwiY2hjeSI6ItGHIiwiY2hlY2siOiLinJMiLCJjaGVja21hcmsiOiLinJMiLCJDaGkiOiLOpyIsImNoaSI6Is+HIiwiY2lyYyI6IsuGIiwiY2lyY2VxIjoi4omXIiwiY2lyY2xlYXJyb3dsZWZ0Ijoi4oa6IiwiY2lyY2xlYXJyb3dyaWdodCI6IuKGuyIsImNpcmNsZWRhc3QiOiLiipsiLCJjaXJjbGVkY2lyYyI6IuKKmiIsImNpcmNsZWRkYXNoIjoi4oqdIiwiQ2lyY2xlRG90Ijoi4oqZIiwiY2lyY2xlZFIiOiLCriIsImNpcmNsZWRTIjoi4pOIIiwiQ2lyY2xlTWludXMiOiLiipYiLCJDaXJjbGVQbHVzIjoi4oqVIiwiQ2lyY2xlVGltZXMiOiLiipciLCJjaXIiOiLil4siLCJjaXJFIjoi4qeDIiwiY2lyZSI6IuKJlyIsImNpcmZuaW50Ijoi4qiQIiwiY2lybWlkIjoi4quvIiwiY2lyc2NpciI6IuKngiIsIkNsb2Nrd2lzZUNvbnRvdXJJbnRlZ3JhbCI6IuKIsiIsIkNsb3NlQ3VybHlEb3VibGVRdW90ZSI6IuKAnSIsIkNsb3NlQ3VybHlRdW90ZSI6IuKAmSIsImNsdWJzIjoi4pmjIiwiY2x1YnN1aXQiOiLimaMiLCJjb2xvbiI6IjoiLCJDb2xvbiI6IuKItyIsIkNvbG9uZSI6IuKptCIsImNvbG9uZSI6IuKJlCIsImNvbG9uZXEiOiLiiZQiLCJjb21tYSI6IiwiLCJjb21tYXQiOiJAIiwiY29tcCI6IuKIgSIsImNvbXBmbiI6IuKImCIsImNvbXBsZW1lbnQiOiLiiIEiLCJjb21wbGV4ZXMiOiLihIIiLCJjb25nIjoi4omFIiwiY29uZ2RvdCI6IuKprSIsIkNvbmdydWVudCI6IuKJoSIsImNvbmludCI6IuKIriIsIkNvbmludCI6IuKIryIsIkNvbnRvdXJJbnRlZ3JhbCI6IuKIriIsImNvcGYiOiLwnZWUIiwiQ29wZiI6IuKEgiIsImNvcHJvZCI6IuKIkCIsIkNvcHJvZHVjdCI6IuKIkCIsImNvcHkiOiLCqSIsIkNPUFkiOiLCqSIsImNvcHlzciI6IuKElyIsIkNvdW50ZXJDbG9ja3dpc2VDb250b3VySW50ZWdyYWwiOiLiiLMiLCJjcmFyciI6IuKGtSIsImNyb3NzIjoi4pyXIiwiQ3Jvc3MiOiLiqK8iLCJDc2NyIjoi8J2SniIsImNzY3IiOiLwnZK4IiwiY3N1YiI6IuKrjyIsImNzdWJlIjoi4quRIiwiY3N1cCI6IuKrkCIsImNzdXBlIjoi4quSIiwiY3Rkb3QiOiLii68iLCJjdWRhcnJsIjoi4qS4IiwiY3VkYXJyciI6IuKktSIsImN1ZXByIjoi4oueIiwiY3Vlc2MiOiLii58iLCJjdWxhcnIiOiLihrYiLCJjdWxhcnJwIjoi4qS9IiwiY3VwYnJjYXAiOiLiqYgiLCJjdXBjYXAiOiLiqYYiLCJDdXBDYXAiOiLiiY0iLCJjdXAiOiLiiKoiLCJDdXAiOiLii5MiLCJjdXBjdXAiOiLiqYoiLCJjdXBkb3QiOiLiio0iLCJjdXBvciI6IuKphSIsImN1cHMiOiLiiKrvuIAiLCJjdXJhcnIiOiLihrciLCJjdXJhcnJtIjoi4qS8IiwiY3VybHllcXByZWMiOiLii54iLCJjdXJseWVxc3VjYyI6IuKLnyIsImN1cmx5dmVlIjoi4ouOIiwiY3VybHl3ZWRnZSI6IuKLjyIsImN1cnJlbiI6IsKkIiwiY3VydmVhcnJvd2xlZnQiOiLihrYiLCJjdXJ2ZWFycm93cmlnaHQiOiLihrciLCJjdXZlZSI6IuKLjiIsImN1d2VkIjoi4ouPIiwiY3djb25pbnQiOiLiiLIiLCJjd2ludCI6IuKIsSIsImN5bGN0eSI6IuKMrSIsImRhZ2dlciI6IuKAoCIsIkRhZ2dlciI6IuKAoSIsImRhbGV0aCI6IuKEuCIsImRhcnIiOiLihpMiLCJEYXJyIjoi4oahIiwiZEFyciI6IuKHkyIsImRhc2giOiLigJAiLCJEYXNodiI6IuKrpCIsImRhc2h2Ijoi4oqjIiwiZGJrYXJvdyI6IuKkjyIsImRibGFjIjoiy50iLCJEY2Fyb24iOiLEjiIsImRjYXJvbiI6IsSPIiwiRGN5Ijoi0JQiLCJkY3kiOiLQtCIsImRkYWdnZXIiOiLigKEiLCJkZGFyciI6IuKHiiIsIkREIjoi4oWFIiwiZGQiOiLihYYiLCJERG90cmFoZCI6IuKkkSIsImRkb3RzZXEiOiLiqbciLCJkZWciOiLCsCIsIkRlbCI6IuKIhyIsIkRlbHRhIjoizpQiLCJkZWx0YSI6Is60IiwiZGVtcHR5diI6IuKmsSIsImRmaXNodCI6IuKlvyIsIkRmciI6IvCdlIciLCJkZnIiOiLwnZShIiwiZEhhciI6IuKlpSIsImRoYXJsIjoi4oeDIiwiZGhhcnIiOiLih4IiLCJEaWFjcml0aWNhbEFjdXRlIjoiwrQiLCJEaWFjcml0aWNhbERvdCI6IsuZIiwiRGlhY3JpdGljYWxEb3VibGVBY3V0ZSI6IsudIiwiRGlhY3JpdGljYWxHcmF2ZSI6ImAiLCJEaWFjcml0aWNhbFRpbGRlIjoiy5wiLCJkaWFtIjoi4ouEIiwiZGlhbW9uZCI6IuKLhCIsIkRpYW1vbmQiOiLii4QiLCJkaWFtb25kc3VpdCI6IuKZpiIsImRpYW1zIjoi4pmmIiwiZGllIjoiwqgiLCJEaWZmZXJlbnRpYWxEIjoi4oWGIiwiZGlnYW1tYSI6Is+dIiwiZGlzaW4iOiLii7IiLCJkaXYiOiLDtyIsImRpdmlkZSI6IsO3IiwiZGl2aWRlb250aW1lcyI6IuKLhyIsImRpdm9ueCI6IuKLhyIsIkRKY3kiOiLQgiIsImRqY3kiOiLRkiIsImRsY29ybiI6IuKMniIsImRsY3JvcCI6IuKMjSIsImRvbGxhciI6IiQiLCJEb3BmIjoi8J2UuyIsImRvcGYiOiLwnZWVIiwiRG90IjoiwqgiLCJkb3QiOiLLmSIsIkRvdERvdCI6IuKDnCIsImRvdGVxIjoi4omQIiwiZG90ZXFkb3QiOiLiiZEiLCJEb3RFcXVhbCI6IuKJkCIsImRvdG1pbnVzIjoi4oi4IiwiZG90cGx1cyI6IuKIlCIsImRvdHNxdWFyZSI6IuKKoSIsImRvdWJsZWJhcndlZGdlIjoi4oyGIiwiRG91YmxlQ29udG91ckludGVncmFsIjoi4oivIiwiRG91YmxlRG90IjoiwqgiLCJEb3VibGVEb3duQXJyb3ciOiLih5MiLCJEb3VibGVMZWZ0QXJyb3ciOiLih5AiLCJEb3VibGVMZWZ0UmlnaHRBcnJvdyI6IuKHlCIsIkRvdWJsZUxlZnRUZWUiOiLiq6QiLCJEb3VibGVMb25nTGVmdEFycm93Ijoi4p+4IiwiRG91YmxlTG9uZ0xlZnRSaWdodEFycm93Ijoi4p+6IiwiRG91YmxlTG9uZ1JpZ2h0QXJyb3ciOiLin7kiLCJEb3VibGVSaWdodEFycm93Ijoi4oeSIiwiRG91YmxlUmlnaHRUZWUiOiLiiqgiLCJEb3VibGVVcEFycm93Ijoi4oeRIiwiRG91YmxlVXBEb3duQXJyb3ciOiLih5UiLCJEb3VibGVWZXJ0aWNhbEJhciI6IuKIpSIsIkRvd25BcnJvd0JhciI6IuKkkyIsImRvd25hcnJvdyI6IuKGkyIsIkRvd25BcnJvdyI6IuKGkyIsIkRvd25hcnJvdyI6IuKHkyIsIkRvd25BcnJvd1VwQXJyb3ciOiLih7UiLCJEb3duQnJldmUiOiLMkSIsImRvd25kb3duYXJyb3dzIjoi4oeKIiwiZG93bmhhcnBvb25sZWZ0Ijoi4oeDIiwiZG93bmhhcnBvb25yaWdodCI6IuKHgiIsIkRvd25MZWZ0UmlnaHRWZWN0b3IiOiLipZAiLCJEb3duTGVmdFRlZVZlY3RvciI6IuKlniIsIkRvd25MZWZ0VmVjdG9yQmFyIjoi4qWWIiwiRG93bkxlZnRWZWN0b3IiOiLihr0iLCJEb3duUmlnaHRUZWVWZWN0b3IiOiLipZ8iLCJEb3duUmlnaHRWZWN0b3JCYXIiOiLipZciLCJEb3duUmlnaHRWZWN0b3IiOiLih4EiLCJEb3duVGVlQXJyb3ciOiLihqciLCJEb3duVGVlIjoi4oqkIiwiZHJia2Fyb3ciOiLipJAiLCJkcmNvcm4iOiLijJ8iLCJkcmNyb3AiOiLijIwiLCJEc2NyIjoi8J2SnyIsImRzY3IiOiLwnZK5IiwiRFNjeSI6ItCFIiwiZHNjeSI6ItGVIiwiZHNvbCI6IuKntiIsIkRzdHJvayI6IsSQIiwiZHN0cm9rIjoixJEiLCJkdGRvdCI6IuKLsSIsImR0cmkiOiLilr8iLCJkdHJpZiI6IuKWviIsImR1YXJyIjoi4oe1IiwiZHVoYXIiOiLipa8iLCJkd2FuZ2xlIjoi4qamIiwiRFpjeSI6ItCPIiwiZHpjeSI6ItGfIiwiZHppZ3JhcnIiOiLin78iLCJFYWN1dGUiOiLDiSIsImVhY3V0ZSI6IsOpIiwiZWFzdGVyIjoi4qmuIiwiRWNhcm9uIjoixJoiLCJlY2Fyb24iOiLEmyIsIkVjaXJjIjoiw4oiLCJlY2lyYyI6IsOqIiwiZWNpciI6IuKJliIsImVjb2xvbiI6IuKJlSIsIkVjeSI6ItCtIiwiZWN5Ijoi0Y0iLCJlRERvdCI6IuKptyIsIkVkb3QiOiLEliIsImVkb3QiOiLElyIsImVEb3QiOiLiiZEiLCJlZSI6IuKFhyIsImVmRG90Ijoi4omSIiwiRWZyIjoi8J2UiCIsImVmciI6IvCdlKIiLCJlZyI6IuKqmiIsIkVncmF2ZSI6IsOIIiwiZWdyYXZlIjoiw6giLCJlZ3MiOiLiqpYiLCJlZ3Nkb3QiOiLiqpgiLCJlbCI6IuKqmSIsIkVsZW1lbnQiOiLiiIgiLCJlbGludGVycyI6IuKPpyIsImVsbCI6IuKEkyIsImVscyI6IuKqlSIsImVsc2RvdCI6IuKqlyIsIkVtYWNyIjoixJIiLCJlbWFjciI6IsSTIiwiZW1wdHkiOiLiiIUiLCJlbXB0eXNldCI6IuKIhSIsIkVtcHR5U21hbGxTcXVhcmUiOiLil7siLCJlbXB0eXYiOiLiiIUiLCJFbXB0eVZlcnlTbWFsbFNxdWFyZSI6IuKWqyIsImVtc3AxMyI6IuKAhCIsImVtc3AxNCI6IuKAhSIsImVtc3AiOiLigIMiLCJFTkciOiLFiiIsImVuZyI6IsWLIiwiZW5zcCI6IuKAgiIsIkVvZ29uIjoixJgiLCJlb2dvbiI6IsSZIiwiRW9wZiI6IvCdlLwiLCJlb3BmIjoi8J2VliIsImVwYXIiOiLii5UiLCJlcGFyc2wiOiLip6MiLCJlcGx1cyI6IuKpsSIsImVwc2kiOiLOtSIsIkVwc2lsb24iOiLOlSIsImVwc2lsb24iOiLOtSIsImVwc2l2Ijoiz7UiLCJlcWNpcmMiOiLiiZYiLCJlcWNvbG9uIjoi4omVIiwiZXFzaW0iOiLiiYIiLCJlcXNsYW50Z3RyIjoi4qqWIiwiZXFzbGFudGxlc3MiOiLiqpUiLCJFcXVhbCI6IuKptSIsImVxdWFscyI6Ij0iLCJFcXVhbFRpbGRlIjoi4omCIiwiZXF1ZXN0Ijoi4omfIiwiRXF1aWxpYnJpdW0iOiLih4wiLCJlcXVpdiI6IuKJoSIsImVxdWl2REQiOiLiqbgiLCJlcXZwYXJzbCI6IuKnpSIsImVyYXJyIjoi4qWxIiwiZXJEb3QiOiLiiZMiLCJlc2NyIjoi4oSvIiwiRXNjciI6IuKEsCIsImVzZG90Ijoi4omQIiwiRXNpbSI6IuKpsyIsImVzaW0iOiLiiYIiLCJFdGEiOiLOlyIsImV0YSI6Is63IiwiRVRIIjoiw5AiLCJldGgiOiLDsCIsIkV1bWwiOiLDiyIsImV1bWwiOiLDqyIsImV1cm8iOiLigqwiLCJleGNsIjoiISIsImV4aXN0Ijoi4oiDIiwiRXhpc3RzIjoi4oiDIiwiZXhwZWN0YXRpb24iOiLihLAiLCJleHBvbmVudGlhbGUiOiLihYciLCJFeHBvbmVudGlhbEUiOiLihYciLCJmYWxsaW5nZG90c2VxIjoi4omSIiwiRmN5Ijoi0KQiLCJmY3kiOiLRhCIsImZlbWFsZSI6IuKZgCIsImZmaWxpZyI6Iu+sgyIsImZmbGlnIjoi76yAIiwiZmZsbGlnIjoi76yEIiwiRmZyIjoi8J2UiSIsImZmciI6IvCdlKMiLCJmaWxpZyI6Iu+sgSIsIkZpbGxlZFNtYWxsU3F1YXJlIjoi4pe8IiwiRmlsbGVkVmVyeVNtYWxsU3F1YXJlIjoi4paqIiwiZmpsaWciOiJmaiIsImZsYXQiOiLima0iLCJmbGxpZyI6Iu+sgiIsImZsdG5zIjoi4paxIiwiZm5vZiI6IsaSIiwiRm9wZiI6IvCdlL0iLCJmb3BmIjoi8J2VlyIsImZvcmFsbCI6IuKIgCIsIkZvckFsbCI6IuKIgCIsImZvcmsiOiLii5QiLCJmb3JrdiI6IuKrmSIsIkZvdXJpZXJ0cmYiOiLihLEiLCJmcGFydGludCI6IuKojSIsImZyYWMxMiI6IsK9IiwiZnJhYzEzIjoi4oWTIiwiZnJhYzE0IjoiwrwiLCJmcmFjMTUiOiLihZUiLCJmcmFjMTYiOiLihZkiLCJmcmFjMTgiOiLihZsiLCJmcmFjMjMiOiLihZQiLCJmcmFjMjUiOiLihZYiLCJmcmFjMzQiOiLCviIsImZyYWMzNSI6IuKFlyIsImZyYWMzOCI6IuKFnCIsImZyYWM0NSI6IuKFmCIsImZyYWM1NiI6IuKFmiIsImZyYWM1OCI6IuKFnSIsImZyYWM3OCI6IuKFniIsImZyYXNsIjoi4oGEIiwiZnJvd24iOiLijKIiLCJmc2NyIjoi8J2SuyIsIkZzY3IiOiLihLEiLCJnYWN1dGUiOiLHtSIsIkdhbW1hIjoizpMiLCJnYW1tYSI6Is6zIiwiR2FtbWFkIjoiz5wiLCJnYW1tYWQiOiLPnSIsImdhcCI6IuKqhiIsIkdicmV2ZSI6IsSeIiwiZ2JyZXZlIjoixJ8iLCJHY2VkaWwiOiLEoiIsIkdjaXJjIjoixJwiLCJnY2lyYyI6IsSdIiwiR2N5Ijoi0JMiLCJnY3kiOiLQsyIsIkdkb3QiOiLEoCIsImdkb3QiOiLEoSIsImdlIjoi4omlIiwiZ0UiOiLiiaciLCJnRWwiOiLiqowiLCJnZWwiOiLii5siLCJnZXEiOiLiiaUiLCJnZXFxIjoi4omnIiwiZ2Vxc2xhbnQiOiLiqb4iLCJnZXNjYyI6IuKqqSIsImdlcyI6IuKpviIsImdlc2RvdCI6IuKqgCIsImdlc2RvdG8iOiLiqoIiLCJnZXNkb3RvbCI6IuKqhCIsImdlc2wiOiLii5vvuIAiLCJnZXNsZXMiOiLiqpQiLCJHZnIiOiLwnZSKIiwiZ2ZyIjoi8J2UpCIsImdnIjoi4omrIiwiR2ciOiLii5kiLCJnZ2ciOiLii5kiLCJnaW1lbCI6IuKEtyIsIkdKY3kiOiLQgyIsImdqY3kiOiLRkyIsImdsYSI6IuKqpSIsImdsIjoi4om3IiwiZ2xFIjoi4qqSIiwiZ2xqIjoi4qqkIiwiZ25hcCI6IuKqiiIsImduYXBwcm94Ijoi4qqKIiwiZ25lIjoi4qqIIiwiZ25FIjoi4ompIiwiZ25lcSI6IuKqiCIsImduZXFxIjoi4ompIiwiZ25zaW0iOiLii6ciLCJHb3BmIjoi8J2UviIsImdvcGYiOiLwnZWYIiwiZ3JhdmUiOiJgIiwiR3JlYXRlckVxdWFsIjoi4omlIiwiR3JlYXRlckVxdWFsTGVzcyI6IuKLmyIsIkdyZWF0ZXJGdWxsRXF1YWwiOiLiiaciLCJHcmVhdGVyR3JlYXRlciI6IuKqoiIsIkdyZWF0ZXJMZXNzIjoi4om3IiwiR3JlYXRlclNsYW50RXF1YWwiOiLiqb4iLCJHcmVhdGVyVGlsZGUiOiLiibMiLCJHc2NyIjoi8J2SoiIsImdzY3IiOiLihIoiLCJnc2ltIjoi4omzIiwiZ3NpbWUiOiLiqo4iLCJnc2ltbCI6IuKqkCIsImd0Y2MiOiLiqqciLCJndGNpciI6IuKpuiIsImd0IjoiPiIsIkdUIjoiPiIsIkd0Ijoi4omrIiwiZ3Rkb3QiOiLii5ciLCJndGxQYXIiOiLippUiLCJndHF1ZXN0Ijoi4qm8IiwiZ3RyYXBwcm94Ijoi4qqGIiwiZ3RyYXJyIjoi4qW4IiwiZ3RyZG90Ijoi4ouXIiwiZ3RyZXFsZXNzIjoi4oubIiwiZ3RyZXFxbGVzcyI6IuKqjCIsImd0cmxlc3MiOiLiibciLCJndHJzaW0iOiLiibMiLCJndmVydG5lcXEiOiLiianvuIAiLCJndm5FIjoi4omp77iAIiwiSGFjZWsiOiLLhyIsImhhaXJzcCI6IuKAiiIsImhhbGYiOiLCvSIsImhhbWlsdCI6IuKEiyIsIkhBUkRjeSI6ItCqIiwiaGFyZGN5Ijoi0YoiLCJoYXJyY2lyIjoi4qWIIiwiaGFyciI6IuKGlCIsImhBcnIiOiLih5QiLCJoYXJydyI6IuKGrSIsIkhhdCI6Il4iLCJoYmFyIjoi4oSPIiwiSGNpcmMiOiLEpCIsImhjaXJjIjoixKUiLCJoZWFydHMiOiLimaUiLCJoZWFydHN1aXQiOiLimaUiLCJoZWxsaXAiOiLigKYiLCJoZXJjb24iOiLiirkiLCJoZnIiOiLwnZSlIiwiSGZyIjoi4oSMIiwiSGlsYmVydFNwYWNlIjoi4oSLIiwiaGtzZWFyb3ciOiLipKUiLCJoa3N3YXJvdyI6IuKkpiIsImhvYXJyIjoi4oe/IiwiaG9tdGh0Ijoi4oi7IiwiaG9va2xlZnRhcnJvdyI6IuKGqSIsImhvb2tyaWdodGFycm93Ijoi4oaqIiwiaG9wZiI6IvCdlZkiLCJIb3BmIjoi4oSNIiwiaG9yYmFyIjoi4oCVIiwiSG9yaXpvbnRhbExpbmUiOiLilIAiLCJoc2NyIjoi8J2SvSIsIkhzY3IiOiLihIsiLCJoc2xhc2giOiLihI8iLCJIc3Ryb2siOiLEpiIsImhzdHJvayI6IsSnIiwiSHVtcERvd25IdW1wIjoi4omOIiwiSHVtcEVxdWFsIjoi4omPIiwiaHlidWxsIjoi4oGDIiwiaHlwaGVuIjoi4oCQIiwiSWFjdXRlIjoiw40iLCJpYWN1dGUiOiLDrSIsImljIjoi4oGjIiwiSWNpcmMiOiLDjiIsImljaXJjIjoiw64iLCJJY3kiOiLQmCIsImljeSI6ItC4IiwiSWRvdCI6IsSwIiwiSUVjeSI6ItCVIiwiaWVjeSI6ItC1IiwiaWV4Y2wiOiLCoSIsImlmZiI6IuKHlCIsImlmciI6IvCdlKYiLCJJZnIiOiLihJEiLCJJZ3JhdmUiOiLDjCIsImlncmF2ZSI6IsOsIiwiaWkiOiLihYgiLCJpaWlpbnQiOiLiqIwiLCJpaWludCI6IuKIrSIsImlpbmZpbiI6IuKnnCIsImlpb3RhIjoi4oSpIiwiSUpsaWciOiLEsiIsImlqbGlnIjoixLMiLCJJbWFjciI6IsSqIiwiaW1hY3IiOiLEqyIsImltYWdlIjoi4oSRIiwiSW1hZ2luYXJ5SSI6IuKFiCIsImltYWdsaW5lIjoi4oSQIiwiaW1hZ3BhcnQiOiLihJEiLCJpbWF0aCI6IsSxIiwiSW0iOiLihJEiLCJpbW9mIjoi4oq3IiwiaW1wZWQiOiLGtSIsIkltcGxpZXMiOiLih5IiLCJpbmNhcmUiOiLihIUiLCJpbiI6IuKIiCIsImluZmluIjoi4oieIiwiaW5maW50aWUiOiLip50iLCJpbm9kb3QiOiLEsSIsImludGNhbCI6IuKKuiIsImludCI6IuKIqyIsIkludCI6IuKIrCIsImludGVnZXJzIjoi4oSkIiwiSW50ZWdyYWwiOiLiiKsiLCJpbnRlcmNhbCI6IuKKuiIsIkludGVyc2VjdGlvbiI6IuKLgiIsImludGxhcmhrIjoi4qiXIiwiaW50cHJvZCI6IuKovCIsIkludmlzaWJsZUNvbW1hIjoi4oGjIiwiSW52aXNpYmxlVGltZXMiOiLigaIiLCJJT2N5Ijoi0IEiLCJpb2N5Ijoi0ZEiLCJJb2dvbiI6IsSuIiwiaW9nb24iOiLEryIsIklvcGYiOiLwnZWAIiwiaW9wZiI6IvCdlZoiLCJJb3RhIjoizpkiLCJpb3RhIjoizrkiLCJpcHJvZCI6IuKovCIsImlxdWVzdCI6IsK/IiwiaXNjciI6IvCdkr4iLCJJc2NyIjoi4oSQIiwiaXNpbiI6IuKIiCIsImlzaW5kb3QiOiLii7UiLCJpc2luRSI6IuKLuSIsImlzaW5zIjoi4ou0IiwiaXNpbnN2Ijoi4ouzIiwiaXNpbnYiOiLiiIgiLCJpdCI6IuKBoiIsIkl0aWxkZSI6IsSoIiwiaXRpbGRlIjoixKkiLCJJdWtjeSI6ItCGIiwiaXVrY3kiOiLRliIsIkl1bWwiOiLDjyIsIml1bWwiOiLDryIsIkpjaXJjIjoixLQiLCJqY2lyYyI6IsS1IiwiSmN5Ijoi0JkiLCJqY3kiOiLQuSIsIkpmciI6IvCdlI0iLCJqZnIiOiLwnZSnIiwiam1hdGgiOiLItyIsIkpvcGYiOiLwnZWBIiwiam9wZiI6IvCdlZsiLCJKc2NyIjoi8J2SpSIsImpzY3IiOiLwnZK/IiwiSnNlcmN5Ijoi0IgiLCJqc2VyY3kiOiLRmCIsIkp1a2N5Ijoi0IQiLCJqdWtjeSI6ItGUIiwiS2FwcGEiOiLOmiIsImthcHBhIjoizroiLCJrYXBwYXYiOiLPsCIsIktjZWRpbCI6IsS2Iiwia2NlZGlsIjoixLciLCJLY3kiOiLQmiIsImtjeSI6ItC6IiwiS2ZyIjoi8J2UjiIsImtmciI6IvCdlKgiLCJrZ3JlZW4iOiLEuCIsIktIY3kiOiLQpSIsImtoY3kiOiLRhSIsIktKY3kiOiLQjCIsImtqY3kiOiLRnCIsIktvcGYiOiLwnZWCIiwia29wZiI6IvCdlZwiLCJLc2NyIjoi8J2SpiIsImtzY3IiOiLwnZOAIiwibEFhcnIiOiLih5oiLCJMYWN1dGUiOiLEuSIsImxhY3V0ZSI6IsS6IiwibGFlbXB0eXYiOiLiprQiLCJsYWdyYW4iOiLihJIiLCJMYW1iZGEiOiLOmyIsImxhbWJkYSI6Is67IiwibGFuZyI6IuKfqCIsIkxhbmciOiLin6oiLCJsYW5nZCI6IuKmkSIsImxhbmdsZSI6IuKfqCIsImxhcCI6IuKqhSIsIkxhcGxhY2V0cmYiOiLihJIiLCJsYXF1byI6IsKrIiwibGFycmIiOiLih6QiLCJsYXJyYmZzIjoi4qSfIiwibGFyciI6IuKGkCIsIkxhcnIiOiLihp4iLCJsQXJyIjoi4oeQIiwibGFycmZzIjoi4qSdIiwibGFycmhrIjoi4oapIiwibGFycmxwIjoi4oarIiwibGFycnBsIjoi4qS5IiwibGFycnNpbSI6IuKlsyIsImxhcnJ0bCI6IuKGoiIsImxhdGFpbCI6IuKkmSIsImxBdGFpbCI6IuKkmyIsImxhdCI6IuKqqyIsImxhdGUiOiLiqq0iLCJsYXRlcyI6IuKqre+4gCIsImxiYXJyIjoi4qSMIiwibEJhcnIiOiLipI4iLCJsYmJyayI6IuKdsiIsImxicmFjZSI6InsiLCJsYnJhY2siOiJbIiwibGJya2UiOiLiposiLCJsYnJrc2xkIjoi4qaPIiwibGJya3NsdSI6IuKmjSIsIkxjYXJvbiI6IsS9IiwibGNhcm9uIjoixL4iLCJMY2VkaWwiOiLEuyIsImxjZWRpbCI6IsS8IiwibGNlaWwiOiLijIgiLCJsY3ViIjoieyIsIkxjeSI6ItCbIiwibGN5Ijoi0LsiLCJsZGNhIjoi4qS2IiwibGRxdW8iOiLigJwiLCJsZHF1b3IiOiLigJ4iLCJsZHJkaGFyIjoi4qWnIiwibGRydXNoYXIiOiLipYsiLCJsZHNoIjoi4oayIiwibGUiOiLiiaQiLCJsRSI6IuKJpiIsIkxlZnRBbmdsZUJyYWNrZXQiOiLin6giLCJMZWZ0QXJyb3dCYXIiOiLih6QiLCJsZWZ0YXJyb3ciOiLihpAiLCJMZWZ0QXJyb3ciOiLihpAiLCJMZWZ0YXJyb3ciOiLih5AiLCJMZWZ0QXJyb3dSaWdodEFycm93Ijoi4oeGIiwibGVmdGFycm93dGFpbCI6IuKGoiIsIkxlZnRDZWlsaW5nIjoi4oyIIiwiTGVmdERvdWJsZUJyYWNrZXQiOiLin6YiLCJMZWZ0RG93blRlZVZlY3RvciI6IuKloSIsIkxlZnREb3duVmVjdG9yQmFyIjoi4qWZIiwiTGVmdERvd25WZWN0b3IiOiLih4MiLCJMZWZ0Rmxvb3IiOiLijIoiLCJsZWZ0aGFycG9vbmRvd24iOiLihr0iLCJsZWZ0aGFycG9vbnVwIjoi4oa8IiwibGVmdGxlZnRhcnJvd3MiOiLih4ciLCJsZWZ0cmlnaHRhcnJvdyI6IuKGlCIsIkxlZnRSaWdodEFycm93Ijoi4oaUIiwiTGVmdHJpZ2h0YXJyb3ciOiLih5QiLCJsZWZ0cmlnaHRhcnJvd3MiOiLih4YiLCJsZWZ0cmlnaHRoYXJwb29ucyI6IuKHiyIsImxlZnRyaWdodHNxdWlnYXJyb3ciOiLihq0iLCJMZWZ0UmlnaHRWZWN0b3IiOiLipY4iLCJMZWZ0VGVlQXJyb3ciOiLihqQiLCJMZWZ0VGVlIjoi4oqjIiwiTGVmdFRlZVZlY3RvciI6IuKlmiIsImxlZnR0aHJlZXRpbWVzIjoi4ouLIiwiTGVmdFRyaWFuZ2xlQmFyIjoi4qePIiwiTGVmdFRyaWFuZ2xlIjoi4oqyIiwiTGVmdFRyaWFuZ2xlRXF1YWwiOiLiirQiLCJMZWZ0VXBEb3duVmVjdG9yIjoi4qWRIiwiTGVmdFVwVGVlVmVjdG9yIjoi4qWgIiwiTGVmdFVwVmVjdG9yQmFyIjoi4qWYIiwiTGVmdFVwVmVjdG9yIjoi4oa/IiwiTGVmdFZlY3RvckJhciI6IuKlkiIsIkxlZnRWZWN0b3IiOiLihrwiLCJsRWciOiLiqosiLCJsZWciOiLii5oiLCJsZXEiOiLiiaQiLCJsZXFxIjoi4ommIiwibGVxc2xhbnQiOiLiqb0iLCJsZXNjYyI6IuKqqCIsImxlcyI6IuKpvSIsImxlc2RvdCI6IuKpvyIsImxlc2RvdG8iOiLiqoEiLCJsZXNkb3RvciI6IuKqgyIsImxlc2ciOiLii5rvuIAiLCJsZXNnZXMiOiLiqpMiLCJsZXNzYXBwcm94Ijoi4qqFIiwibGVzc2RvdCI6IuKLliIsImxlc3NlcWd0ciI6IuKLmiIsImxlc3NlcXFndHIiOiLiqosiLCJMZXNzRXF1YWxHcmVhdGVyIjoi4ouaIiwiTGVzc0Z1bGxFcXVhbCI6IuKJpiIsIkxlc3NHcmVhdGVyIjoi4om2IiwibGVzc2d0ciI6IuKJtiIsIkxlc3NMZXNzIjoi4qqhIiwibGVzc3NpbSI6IuKJsiIsIkxlc3NTbGFudEVxdWFsIjoi4qm9IiwiTGVzc1RpbGRlIjoi4omyIiwibGZpc2h0Ijoi4qW8IiwibGZsb29yIjoi4oyKIiwiTGZyIjoi8J2UjyIsImxmciI6IvCdlKkiLCJsZyI6IuKJtiIsImxnRSI6IuKqkSIsImxIYXIiOiLipaIiLCJsaGFyZCI6IuKGvSIsImxoYXJ1Ijoi4oa8IiwibGhhcnVsIjoi4qWqIiwibGhibGsiOiLiloQiLCJMSmN5Ijoi0IkiLCJsamN5Ijoi0ZkiLCJsbGFyciI6IuKHhyIsImxsIjoi4omqIiwiTGwiOiLii5giLCJsbGNvcm5lciI6IuKMniIsIkxsZWZ0YXJyb3ciOiLih5oiLCJsbGhhcmQiOiLipasiLCJsbHRyaSI6IuKXuiIsIkxtaWRvdCI6IsS/IiwibG1pZG90IjoixYAiLCJsbW91c3RhY2hlIjoi4o6wIiwibG1vdXN0Ijoi4o6wIiwibG5hcCI6IuKqiSIsImxuYXBwcm94Ijoi4qqJIiwibG5lIjoi4qqHIiwibG5FIjoi4omoIiwibG5lcSI6IuKqhyIsImxuZXFxIjoi4omoIiwibG5zaW0iOiLii6YiLCJsb2FuZyI6IuKfrCIsImxvYXJyIjoi4oe9IiwibG9icmsiOiLin6YiLCJsb25nbGVmdGFycm93Ijoi4p+1IiwiTG9uZ0xlZnRBcnJvdyI6IuKftSIsIkxvbmdsZWZ0YXJyb3ciOiLin7giLCJsb25nbGVmdHJpZ2h0YXJyb3ciOiLin7ciLCJMb25nTGVmdFJpZ2h0QXJyb3ciOiLin7ciLCJMb25nbGVmdHJpZ2h0YXJyb3ciOiLin7oiLCJsb25nbWFwc3RvIjoi4p+8IiwibG9uZ3JpZ2h0YXJyb3ciOiLin7YiLCJMb25nUmlnaHRBcnJvdyI6IuKftiIsIkxvbmdyaWdodGFycm93Ijoi4p+5IiwibG9vcGFycm93bGVmdCI6IuKGqyIsImxvb3BhcnJvd3JpZ2h0Ijoi4oasIiwibG9wYXIiOiLipoUiLCJMb3BmIjoi8J2VgyIsImxvcGYiOiLwnZWdIiwibG9wbHVzIjoi4qitIiwibG90aW1lcyI6IuKotCIsImxvd2FzdCI6IuKIlyIsImxvd2JhciI6Il8iLCJMb3dlckxlZnRBcnJvdyI6IuKGmSIsIkxvd2VyUmlnaHRBcnJvdyI6IuKGmCIsImxveiI6IuKXiiIsImxvemVuZ2UiOiLil4oiLCJsb3pmIjoi4qerIiwibHBhciI6IigiLCJscGFybHQiOiLippMiLCJscmFyciI6IuKHhiIsImxyY29ybmVyIjoi4oyfIiwibHJoYXIiOiLih4siLCJscmhhcmQiOiLipa0iLCJscm0iOiLigI4iLCJscnRyaSI6IuKKvyIsImxzYXF1byI6IuKAuSIsImxzY3IiOiLwnZOBIiwiTHNjciI6IuKEkiIsImxzaCI6IuKGsCIsIkxzaCI6IuKGsCIsImxzaW0iOiLiibIiLCJsc2ltZSI6IuKqjSIsImxzaW1nIjoi4qqPIiwibHNxYiI6IlsiLCJsc3F1byI6IuKAmCIsImxzcXVvciI6IuKAmiIsIkxzdHJvayI6IsWBIiwibHN0cm9rIjoixYIiLCJsdGNjIjoi4qqmIiwibHRjaXIiOiLiqbkiLCJsdCI6IjwiLCJMVCI6IjwiLCJMdCI6IuKJqiIsImx0ZG90Ijoi4ouWIiwibHRocmVlIjoi4ouLIiwibHRpbWVzIjoi4ouJIiwibHRsYXJyIjoi4qW2IiwibHRxdWVzdCI6IuKpuyIsImx0cmkiOiLil4MiLCJsdHJpZSI6IuKKtCIsImx0cmlmIjoi4peCIiwibHRyUGFyIjoi4qaWIiwibHVyZHNoYXIiOiLipYoiLCJsdXJ1aGFyIjoi4qWmIiwibHZlcnRuZXFxIjoi4omo77iAIiwibHZuRSI6IuKJqO+4gCIsIm1hY3IiOiLCryIsIm1hbGUiOiLimYIiLCJtYWx0Ijoi4pygIiwibWFsdGVzZSI6IuKcoCIsIk1hcCI6IuKkhSIsIm1hcCI6IuKGpiIsIm1hcHN0byI6IuKGpiIsIm1hcHN0b2Rvd24iOiLihqciLCJtYXBzdG9sZWZ0Ijoi4oakIiwibWFwc3RvdXAiOiLihqUiLCJtYXJrZXIiOiLilq4iLCJtY29tbWEiOiLiqKkiLCJNY3kiOiLQnCIsIm1jeSI6ItC8IiwibWRhc2giOiLigJQiLCJtRERvdCI6IuKIuiIsIm1lYXN1cmVkYW5nbGUiOiLiiKEiLCJNZWRpdW1TcGFjZSI6IuKBnyIsIk1lbGxpbnRyZiI6IuKEsyIsIk1mciI6IvCdlJAiLCJtZnIiOiLwnZSqIiwibWhvIjoi4oSnIiwibWljcm8iOiLCtSIsIm1pZGFzdCI6IioiLCJtaWRjaXIiOiLiq7AiLCJtaWQiOiLiiKMiLCJtaWRkb3QiOiLCtyIsIm1pbnVzYiI6IuKKnyIsIm1pbnVzIjoi4oiSIiwibWludXNkIjoi4oi4IiwibWludXNkdSI6IuKoqiIsIk1pbnVzUGx1cyI6IuKIkyIsIm1sY3AiOiLiq5siLCJtbGRyIjoi4oCmIiwibW5wbHVzIjoi4oiTIiwibW9kZWxzIjoi4oqnIiwiTW9wZiI6IvCdlYQiLCJtb3BmIjoi8J2VniIsIm1wIjoi4oiTIiwibXNjciI6IvCdk4IiLCJNc2NyIjoi4oSzIiwibXN0cG9zIjoi4oi+IiwiTXUiOiLOnCIsIm11IjoizrwiLCJtdWx0aW1hcCI6IuKKuCIsIm11bWFwIjoi4oq4IiwibmFibGEiOiLiiIciLCJOYWN1dGUiOiLFgyIsIm5hY3V0ZSI6IsWEIiwibmFuZyI6IuKIoOKDkiIsIm5hcCI6IuKJiSIsIm5hcEUiOiLiqbDMuCIsIm5hcGlkIjoi4omLzLgiLCJuYXBvcyI6IsWJIiwibmFwcHJveCI6IuKJiSIsIm5hdHVyYWwiOiLima4iLCJuYXR1cmFscyI6IuKElSIsIm5hdHVyIjoi4pmuIiwibmJzcCI6IsKgIiwibmJ1bXAiOiLiiY7MuCIsIm5idW1wZSI6IuKJj8y4IiwibmNhcCI6IuKpgyIsIk5jYXJvbiI6IsWHIiwibmNhcm9uIjoixYgiLCJOY2VkaWwiOiLFhSIsIm5jZWRpbCI6IsWGIiwibmNvbmciOiLiiYciLCJuY29uZ2RvdCI6IuKprcy4IiwibmN1cCI6IuKpgiIsIk5jeSI6ItCdIiwibmN5Ijoi0L0iLCJuZGFzaCI6IuKAkyIsIm5lYXJoayI6IuKkpCIsIm5lYXJyIjoi4oaXIiwibmVBcnIiOiLih5ciLCJuZWFycm93Ijoi4oaXIiwibmUiOiLiiaAiLCJuZWRvdCI6IuKJkMy4IiwiTmVnYXRpdmVNZWRpdW1TcGFjZSI6IuKAiyIsIk5lZ2F0aXZlVGhpY2tTcGFjZSI6IuKAiyIsIk5lZ2F0aXZlVGhpblNwYWNlIjoi4oCLIiwiTmVnYXRpdmVWZXJ5VGhpblNwYWNlIjoi4oCLIiwibmVxdWl2Ijoi4omiIiwibmVzZWFyIjoi4qSoIiwibmVzaW0iOiLiiYLMuCIsIk5lc3RlZEdyZWF0ZXJHcmVhdGVyIjoi4omrIiwiTmVzdGVkTGVzc0xlc3MiOiLiiaoiLCJOZXdMaW5lIjoiXFxuIiwibmV4aXN0Ijoi4oiEIiwibmV4aXN0cyI6IuKIhCIsIk5mciI6IvCdlJEiLCJuZnIiOiLwnZSrIiwibmdFIjoi4omnzLgiLCJuZ2UiOiLiibEiLCJuZ2VxIjoi4omxIiwibmdlcXEiOiLiiafMuCIsIm5nZXFzbGFudCI6IuKpvsy4IiwibmdlcyI6IuKpvsy4IiwibkdnIjoi4ouZzLgiLCJuZ3NpbSI6IuKJtSIsIm5HdCI6IuKJq+KDkiIsIm5ndCI6IuKJryIsIm5ndHIiOiLiia8iLCJuR3R2Ijoi4omrzLgiLCJuaGFyciI6IuKGriIsIm5oQXJyIjoi4oeOIiwibmhwYXIiOiLiq7IiLCJuaSI6IuKIiyIsIm5pcyI6IuKLvCIsIm5pc2QiOiLii7oiLCJuaXYiOiLiiIsiLCJOSmN5Ijoi0IoiLCJuamN5Ijoi0ZoiLCJubGFyciI6IuKGmiIsIm5sQXJyIjoi4oeNIiwibmxkciI6IuKApSIsIm5sRSI6IuKJpsy4IiwibmxlIjoi4omwIiwibmxlZnRhcnJvdyI6IuKGmiIsIm5MZWZ0YXJyb3ciOiLih40iLCJubGVmdHJpZ2h0YXJyb3ciOiLihq4iLCJuTGVmdHJpZ2h0YXJyb3ciOiLih44iLCJubGVxIjoi4omwIiwibmxlcXEiOiLiiabMuCIsIm5sZXFzbGFudCI6IuKpvcy4IiwibmxlcyI6IuKpvcy4Iiwibmxlc3MiOiLiia4iLCJuTGwiOiLii5jMuCIsIm5sc2ltIjoi4om0Iiwibkx0Ijoi4omq4oOSIiwibmx0Ijoi4omuIiwibmx0cmkiOiLii6oiLCJubHRyaWUiOiLii6wiLCJuTHR2Ijoi4omqzLgiLCJubWlkIjoi4oikIiwiTm9CcmVhayI6IuKBoCIsIk5vbkJyZWFraW5nU3BhY2UiOiLCoCIsIm5vcGYiOiLwnZWfIiwiTm9wZiI6IuKElSIsIk5vdCI6IuKrrCIsIm5vdCI6IsKsIiwiTm90Q29uZ3J1ZW50Ijoi4omiIiwiTm90Q3VwQ2FwIjoi4omtIiwiTm90RG91YmxlVmVydGljYWxCYXIiOiLiiKYiLCJOb3RFbGVtZW50Ijoi4oiJIiwiTm90RXF1YWwiOiLiiaAiLCJOb3RFcXVhbFRpbGRlIjoi4omCzLgiLCJOb3RFeGlzdHMiOiLiiIQiLCJOb3RHcmVhdGVyIjoi4omvIiwiTm90R3JlYXRlckVxdWFsIjoi4omxIiwiTm90R3JlYXRlckZ1bGxFcXVhbCI6IuKJp8y4IiwiTm90R3JlYXRlckdyZWF0ZXIiOiLiiavMuCIsIk5vdEdyZWF0ZXJMZXNzIjoi4om5IiwiTm90R3JlYXRlclNsYW50RXF1YWwiOiLiqb7MuCIsIk5vdEdyZWF0ZXJUaWxkZSI6IuKJtSIsIk5vdEh1bXBEb3duSHVtcCI6IuKJjsy4IiwiTm90SHVtcEVxdWFsIjoi4omPzLgiLCJub3RpbiI6IuKIiSIsIm5vdGluZG90Ijoi4ou1zLgiLCJub3RpbkUiOiLii7nMuCIsIm5vdGludmEiOiLiiIkiLCJub3RpbnZiIjoi4ou3Iiwibm90aW52YyI6IuKLtiIsIk5vdExlZnRUcmlhbmdsZUJhciI6IuKnj8y4IiwiTm90TGVmdFRyaWFuZ2xlIjoi4ouqIiwiTm90TGVmdFRyaWFuZ2xlRXF1YWwiOiLii6wiLCJOb3RMZXNzIjoi4omuIiwiTm90TGVzc0VxdWFsIjoi4omwIiwiTm90TGVzc0dyZWF0ZXIiOiLiibgiLCJOb3RMZXNzTGVzcyI6IuKJqsy4IiwiTm90TGVzc1NsYW50RXF1YWwiOiLiqb3MuCIsIk5vdExlc3NUaWxkZSI6IuKJtCIsIk5vdE5lc3RlZEdyZWF0ZXJHcmVhdGVyIjoi4qqizLgiLCJOb3ROZXN0ZWRMZXNzTGVzcyI6IuKqocy4Iiwibm90bmkiOiLiiIwiLCJub3RuaXZhIjoi4oiMIiwibm90bml2YiI6IuKLviIsIm5vdG5pdmMiOiLii70iLCJOb3RQcmVjZWRlcyI6IuKKgCIsIk5vdFByZWNlZGVzRXF1YWwiOiLiqq/MuCIsIk5vdFByZWNlZGVzU2xhbnRFcXVhbCI6IuKLoCIsIk5vdFJldmVyc2VFbGVtZW50Ijoi4oiMIiwiTm90UmlnaHRUcmlhbmdsZUJhciI6IuKnkMy4IiwiTm90UmlnaHRUcmlhbmdsZSI6IuKLqyIsIk5vdFJpZ2h0VHJpYW5nbGVFcXVhbCI6IuKLrSIsIk5vdFNxdWFyZVN1YnNldCI6IuKKj8y4IiwiTm90U3F1YXJlU3Vic2V0RXF1YWwiOiLii6IiLCJOb3RTcXVhcmVTdXBlcnNldCI6IuKKkMy4IiwiTm90U3F1YXJlU3VwZXJzZXRFcXVhbCI6IuKLoyIsIk5vdFN1YnNldCI6IuKKguKDkiIsIk5vdFN1YnNldEVxdWFsIjoi4oqIIiwiTm90U3VjY2VlZHMiOiLiioEiLCJOb3RTdWNjZWVkc0VxdWFsIjoi4qqwzLgiLCJOb3RTdWNjZWVkc1NsYW50RXF1YWwiOiLii6EiLCJOb3RTdWNjZWVkc1RpbGRlIjoi4om/zLgiLCJOb3RTdXBlcnNldCI6IuKKg+KDkiIsIk5vdFN1cGVyc2V0RXF1YWwiOiLiiokiLCJOb3RUaWxkZSI6IuKJgSIsIk5vdFRpbGRlRXF1YWwiOiLiiYQiLCJOb3RUaWxkZUZ1bGxFcXVhbCI6IuKJhyIsIk5vdFRpbGRlVGlsZGUiOiLiiYkiLCJOb3RWZXJ0aWNhbEJhciI6IuKIpCIsIm5wYXJhbGxlbCI6IuKIpiIsIm5wYXIiOiLiiKYiLCJucGFyc2wiOiLiq73ig6UiLCJucGFydCI6IuKIgsy4IiwibnBvbGludCI6IuKolCIsIm5wciI6IuKKgCIsIm5wcmN1ZSI6IuKLoCIsIm5wcmVjIjoi4oqAIiwibnByZWNlcSI6IuKqr8y4IiwibnByZSI6IuKqr8y4IiwibnJhcnJjIjoi4qSzzLgiLCJucmFyciI6IuKGmyIsIm5yQXJyIjoi4oePIiwibnJhcnJ3Ijoi4oadzLgiLCJucmlnaHRhcnJvdyI6IuKGmyIsIm5SaWdodGFycm93Ijoi4oePIiwibnJ0cmkiOiLii6siLCJucnRyaWUiOiLii60iLCJuc2MiOiLiioEiLCJuc2NjdWUiOiLii6EiLCJuc2NlIjoi4qqwzLgiLCJOc2NyIjoi8J2SqSIsIm5zY3IiOiLwnZODIiwibnNob3J0bWlkIjoi4oikIiwibnNob3J0cGFyYWxsZWwiOiLiiKYiLCJuc2ltIjoi4omBIiwibnNpbWUiOiLiiYQiLCJuc2ltZXEiOiLiiYQiLCJuc21pZCI6IuKIpCIsIm5zcGFyIjoi4oimIiwibnNxc3ViZSI6IuKLoiIsIm5zcXN1cGUiOiLii6MiLCJuc3ViIjoi4oqEIiwibnN1YkUiOiLiq4XMuCIsIm5zdWJlIjoi4oqIIiwibnN1YnNldCI6IuKKguKDkiIsIm5zdWJzZXRlcSI6IuKKiCIsIm5zdWJzZXRlcXEiOiLiq4XMuCIsIm5zdWNjIjoi4oqBIiwibnN1Y2NlcSI6IuKqsMy4IiwibnN1cCI6IuKKhSIsIm5zdXBFIjoi4quGzLgiLCJuc3VwZSI6IuKKiSIsIm5zdXBzZXQiOiLiioPig5IiLCJuc3Vwc2V0ZXEiOiLiiokiLCJuc3Vwc2V0ZXFxIjoi4quGzLgiLCJudGdsIjoi4om5IiwiTnRpbGRlIjoiw5EiLCJudGlsZGUiOiLDsSIsIm50bGciOiLiibgiLCJudHJpYW5nbGVsZWZ0Ijoi4ouqIiwibnRyaWFuZ2xlbGVmdGVxIjoi4ousIiwibnRyaWFuZ2xlcmlnaHQiOiLii6siLCJudHJpYW5nbGVyaWdodGVxIjoi4outIiwiTnUiOiLOnSIsIm51Ijoizr0iLCJudW0iOiIjIiwibnVtZXJvIjoi4oSWIiwibnVtc3AiOiLigIciLCJudmFwIjoi4omN4oOSIiwibnZkYXNoIjoi4oqsIiwibnZEYXNoIjoi4oqtIiwiblZkYXNoIjoi4oquIiwiblZEYXNoIjoi4oqvIiwibnZnZSI6IuKJpeKDkiIsIm52Z3QiOiI+4oOSIiwibnZIYXJyIjoi4qSEIiwibnZpbmZpbiI6IuKnniIsIm52bEFyciI6IuKkgiIsIm52bGUiOiLiiaTig5IiLCJudmx0IjoiPOKDkiIsIm52bHRyaWUiOiLiirTig5IiLCJudnJBcnIiOiLipIMiLCJudnJ0cmllIjoi4oq14oOSIiwibnZzaW0iOiLiiLzig5IiLCJud2FyaGsiOiLipKMiLCJud2FyciI6IuKGliIsIm53QXJyIjoi4oeWIiwibndhcnJvdyI6IuKGliIsIm53bmVhciI6IuKkpyIsIk9hY3V0ZSI6IsOTIiwib2FjdXRlIjoiw7MiLCJvYXN0Ijoi4oqbIiwiT2NpcmMiOiLDlCIsIm9jaXJjIjoiw7QiLCJvY2lyIjoi4oqaIiwiT2N5Ijoi0J4iLCJvY3kiOiLQviIsIm9kYXNoIjoi4oqdIiwiT2RibGFjIjoixZAiLCJvZGJsYWMiOiLFkSIsIm9kaXYiOiLiqLgiLCJvZG90Ijoi4oqZIiwib2Rzb2xkIjoi4qa8IiwiT0VsaWciOiLFkiIsIm9lbGlnIjoixZMiLCJvZmNpciI6IuKmvyIsIk9mciI6IvCdlJIiLCJvZnIiOiLwnZSsIiwib2dvbiI6IsubIiwiT2dyYXZlIjoiw5IiLCJvZ3JhdmUiOiLDsiIsIm9ndCI6IuKngSIsIm9oYmFyIjoi4qa1Iiwib2htIjoizqkiLCJvaW50Ijoi4oiuIiwib2xhcnIiOiLihroiLCJvbGNpciI6IuKmviIsIm9sY3Jvc3MiOiLiprsiLCJvbGluZSI6IuKAviIsIm9sdCI6IuKngCIsIk9tYWNyIjoixYwiLCJvbWFjciI6IsWNIiwiT21lZ2EiOiLOqSIsIm9tZWdhIjoiz4kiLCJPbWljcm9uIjoizp8iLCJvbWljcm9uIjoizr8iLCJvbWlkIjoi4qa2Iiwib21pbnVzIjoi4oqWIiwiT29wZiI6IvCdlYYiLCJvb3BmIjoi8J2VoCIsIm9wYXIiOiLiprciLCJPcGVuQ3VybHlEb3VibGVRdW90ZSI6IuKAnCIsIk9wZW5DdXJseVF1b3RlIjoi4oCYIiwib3BlcnAiOiLiprkiLCJvcGx1cyI6IuKKlSIsIm9yYXJyIjoi4oa7IiwiT3IiOiLiqZQiLCJvciI6IuKIqCIsIm9yZCI6IuKpnSIsIm9yZGVyIjoi4oS0Iiwib3JkZXJvZiI6IuKEtCIsIm9yZGYiOiLCqiIsIm9yZG0iOiLCuiIsIm9yaWdvZiI6IuKKtiIsIm9yb3IiOiLiqZYiLCJvcnNsb3BlIjoi4qmXIiwib3J2Ijoi4qmbIiwib1MiOiLik4giLCJPc2NyIjoi8J2SqiIsIm9zY3IiOiLihLQiLCJPc2xhc2giOiLDmCIsIm9zbGFzaCI6IsO4Iiwib3NvbCI6IuKKmCIsIk90aWxkZSI6IsOVIiwib3RpbGRlIjoiw7UiLCJvdGltZXNhcyI6IuKotiIsIk90aW1lcyI6IuKotyIsIm90aW1lcyI6IuKKlyIsIk91bWwiOiLDliIsIm91bWwiOiLDtiIsIm92YmFyIjoi4oy9IiwiT3ZlckJhciI6IuKAviIsIk92ZXJCcmFjZSI6IuKPniIsIk92ZXJCcmFja2V0Ijoi4o60IiwiT3ZlclBhcmVudGhlc2lzIjoi4o+cIiwicGFyYSI6IsK2IiwicGFyYWxsZWwiOiLiiKUiLCJwYXIiOiLiiKUiLCJwYXJzaW0iOiLiq7MiLCJwYXJzbCI6IuKrvSIsInBhcnQiOiLiiIIiLCJQYXJ0aWFsRCI6IuKIgiIsIlBjeSI6ItCfIiwicGN5Ijoi0L8iLCJwZXJjbnQiOiIlIiwicGVyaW9kIjoiLiIsInBlcm1pbCI6IuKAsCIsInBlcnAiOiLiiqUiLCJwZXJ0ZW5rIjoi4oCxIiwiUGZyIjoi8J2UkyIsInBmciI6IvCdlK0iLCJQaGkiOiLOpiIsInBoaSI6Is+GIiwicGhpdiI6Is+VIiwicGhtbWF0Ijoi4oSzIiwicGhvbmUiOiLimI4iLCJQaSI6Is6gIiwicGkiOiLPgCIsInBpdGNoZm9yayI6IuKLlCIsInBpdiI6Is+WIiwicGxhbmNrIjoi4oSPIiwicGxhbmNraCI6IuKEjiIsInBsYW5rdiI6IuKEjyIsInBsdXNhY2lyIjoi4qijIiwicGx1c2IiOiLiip4iLCJwbHVzY2lyIjoi4qiiIiwicGx1cyI6IisiLCJwbHVzZG8iOiLiiJQiLCJwbHVzZHUiOiLiqKUiLCJwbHVzZSI6IuKpsiIsIlBsdXNNaW51cyI6IsKxIiwicGx1c21uIjoiwrEiLCJwbHVzc2ltIjoi4qimIiwicGx1c3R3byI6IuKopyIsInBtIjoiwrEiLCJQb2luY2FyZXBsYW5lIjoi4oSMIiwicG9pbnRpbnQiOiLiqJUiLCJwb3BmIjoi8J2VoSIsIlBvcGYiOiLihJkiLCJwb3VuZCI6IsKjIiwicHJhcCI6IuKqtyIsIlByIjoi4qq7IiwicHIiOiLiiboiLCJwcmN1ZSI6IuKJvCIsInByZWNhcHByb3giOiLiqrciLCJwcmVjIjoi4om6IiwicHJlY2N1cmx5ZXEiOiLiibwiLCJQcmVjZWRlcyI6IuKJuiIsIlByZWNlZGVzRXF1YWwiOiLiqq8iLCJQcmVjZWRlc1NsYW50RXF1YWwiOiLiibwiLCJQcmVjZWRlc1RpbGRlIjoi4om+IiwicHJlY2VxIjoi4qqvIiwicHJlY25hcHByb3giOiLiqrkiLCJwcmVjbmVxcSI6IuKqtSIsInByZWNuc2ltIjoi4ouoIiwicHJlIjoi4qqvIiwicHJFIjoi4qqzIiwicHJlY3NpbSI6IuKJviIsInByaW1lIjoi4oCyIiwiUHJpbWUiOiLigLMiLCJwcmltZXMiOiLihJkiLCJwcm5hcCI6IuKquSIsInBybkUiOiLiqrUiLCJwcm5zaW0iOiLii6giLCJwcm9kIjoi4oiPIiwiUHJvZHVjdCI6IuKIjyIsInByb2ZhbGFyIjoi4oyuIiwicHJvZmxpbmUiOiLijJIiLCJwcm9mc3VyZiI6IuKMkyIsInByb3AiOiLiiJ0iLCJQcm9wb3J0aW9uYWwiOiLiiJ0iLCJQcm9wb3J0aW9uIjoi4oi3IiwicHJvcHRvIjoi4oidIiwicHJzaW0iOiLiib4iLCJwcnVyZWwiOiLiirAiLCJQc2NyIjoi8J2SqyIsInBzY3IiOiLwnZOFIiwiUHNpIjoizqgiLCJwc2kiOiLPiCIsInB1bmNzcCI6IuKAiCIsIlFmciI6IvCdlJQiLCJxZnIiOiLwnZSuIiwicWludCI6IuKojCIsInFvcGYiOiLwnZWiIiwiUW9wZiI6IuKEmiIsInFwcmltZSI6IuKBlyIsIlFzY3IiOiLwnZKsIiwicXNjciI6IvCdk4YiLCJxdWF0ZXJuaW9ucyI6IuKEjSIsInF1YXRpbnQiOiLiqJYiLCJxdWVzdCI6Ij8iLCJxdWVzdGVxIjoi4omfIiwicXVvdCI6IlxcIiIsIlFVT1QiOiJcXCIiLCJyQWFyciI6IuKHmyIsInJhY2UiOiLiiL3MsSIsIlJhY3V0ZSI6IsWUIiwicmFjdXRlIjoixZUiLCJyYWRpYyI6IuKImiIsInJhZW1wdHl2Ijoi4qazIiwicmFuZyI6IuKfqSIsIlJhbmciOiLin6siLCJyYW5nZCI6IuKmkiIsInJhbmdlIjoi4qalIiwicmFuZ2xlIjoi4p+pIiwicmFxdW8iOiLCuyIsInJhcnJhcCI6IuKltSIsInJhcnJiIjoi4oelIiwicmFycmJmcyI6IuKkoCIsInJhcnJjIjoi4qSzIiwicmFyciI6IuKGkiIsIlJhcnIiOiLihqAiLCJyQXJyIjoi4oeSIiwicmFycmZzIjoi4qSeIiwicmFycmhrIjoi4oaqIiwicmFycmxwIjoi4oasIiwicmFycnBsIjoi4qWFIiwicmFycnNpbSI6IuKltCIsIlJhcnJ0bCI6IuKkliIsInJhcnJ0bCI6IuKGoyIsInJhcnJ3Ijoi4oadIiwicmF0YWlsIjoi4qSaIiwickF0YWlsIjoi4qScIiwicmF0aW8iOiLiiLYiLCJyYXRpb25hbHMiOiLihJoiLCJyYmFyciI6IuKkjSIsInJCYXJyIjoi4qSPIiwiUkJhcnIiOiLipJAiLCJyYmJyayI6IuKdsyIsInJicmFjZSI6In0iLCJyYnJhY2siOiJdIiwicmJya2UiOiLipowiLCJyYnJrc2xkIjoi4qaOIiwicmJya3NsdSI6IuKmkCIsIlJjYXJvbiI6IsWYIiwicmNhcm9uIjoixZkiLCJSY2VkaWwiOiLFliIsInJjZWRpbCI6IsWXIiwicmNlaWwiOiLijIkiLCJyY3ViIjoifSIsIlJjeSI6ItCgIiwicmN5Ijoi0YAiLCJyZGNhIjoi4qS3IiwicmRsZGhhciI6IuKlqSIsInJkcXVvIjoi4oCdIiwicmRxdW9yIjoi4oCdIiwicmRzaCI6IuKGsyIsInJlYWwiOiLihJwiLCJyZWFsaW5lIjoi4oSbIiwicmVhbHBhcnQiOiLihJwiLCJyZWFscyI6IuKEnSIsIlJlIjoi4oScIiwicmVjdCI6IuKWrSIsInJlZyI6IsKuIiwiUkVHIjoiwq4iLCJSZXZlcnNlRWxlbWVudCI6IuKIiyIsIlJldmVyc2VFcXVpbGlicml1bSI6IuKHiyIsIlJldmVyc2VVcEVxdWlsaWJyaXVtIjoi4qWvIiwicmZpc2h0Ijoi4qW9IiwicmZsb29yIjoi4oyLIiwicmZyIjoi8J2UryIsIlJmciI6IuKEnCIsInJIYXIiOiLipaQiLCJyaGFyZCI6IuKHgSIsInJoYXJ1Ijoi4oeAIiwicmhhcnVsIjoi4qWsIiwiUmhvIjoizqEiLCJyaG8iOiLPgSIsInJob3YiOiLPsSIsIlJpZ2h0QW5nbGVCcmFja2V0Ijoi4p+pIiwiUmlnaHRBcnJvd0JhciI6IuKHpSIsInJpZ2h0YXJyb3ciOiLihpIiLCJSaWdodEFycm93Ijoi4oaSIiwiUmlnaHRhcnJvdyI6IuKHkiIsIlJpZ2h0QXJyb3dMZWZ0QXJyb3ciOiLih4QiLCJyaWdodGFycm93dGFpbCI6IuKGoyIsIlJpZ2h0Q2VpbGluZyI6IuKMiSIsIlJpZ2h0RG91YmxlQnJhY2tldCI6IuKfpyIsIlJpZ2h0RG93blRlZVZlY3RvciI6IuKlnSIsIlJpZ2h0RG93blZlY3RvckJhciI6IuKllSIsIlJpZ2h0RG93blZlY3RvciI6IuKHgiIsIlJpZ2h0Rmxvb3IiOiLijIsiLCJyaWdodGhhcnBvb25kb3duIjoi4oeBIiwicmlnaHRoYXJwb29udXAiOiLih4AiLCJyaWdodGxlZnRhcnJvd3MiOiLih4QiLCJyaWdodGxlZnRoYXJwb29ucyI6IuKHjCIsInJpZ2h0cmlnaHRhcnJvd3MiOiLih4kiLCJyaWdodHNxdWlnYXJyb3ciOiLihp0iLCJSaWdodFRlZUFycm93Ijoi4oamIiwiUmlnaHRUZWUiOiLiiqIiLCJSaWdodFRlZVZlY3RvciI6IuKlmyIsInJpZ2h0dGhyZWV0aW1lcyI6IuKLjCIsIlJpZ2h0VHJpYW5nbGVCYXIiOiLip5AiLCJSaWdodFRyaWFuZ2xlIjoi4oqzIiwiUmlnaHRUcmlhbmdsZUVxdWFsIjoi4oq1IiwiUmlnaHRVcERvd25WZWN0b3IiOiLipY8iLCJSaWdodFVwVGVlVmVjdG9yIjoi4qWcIiwiUmlnaHRVcFZlY3RvckJhciI6IuKllCIsIlJpZ2h0VXBWZWN0b3IiOiLihr4iLCJSaWdodFZlY3RvckJhciI6IuKlkyIsIlJpZ2h0VmVjdG9yIjoi4oeAIiwicmluZyI6IsuaIiwicmlzaW5nZG90c2VxIjoi4omTIiwicmxhcnIiOiLih4QiLCJybGhhciI6IuKHjCIsInJsbSI6IuKAjyIsInJtb3VzdGFjaGUiOiLijrEiLCJybW91c3QiOiLijrEiLCJybm1pZCI6IuKrriIsInJvYW5nIjoi4p+tIiwicm9hcnIiOiLih74iLCJyb2JyayI6IuKfpyIsInJvcGFyIjoi4qaGIiwicm9wZiI6IvCdlaMiLCJSb3BmIjoi4oSdIiwicm9wbHVzIjoi4qiuIiwicm90aW1lcyI6IuKotSIsIlJvdW5kSW1wbGllcyI6IuKlsCIsInJwYXIiOiIpIiwicnBhcmd0Ijoi4qaUIiwicnBwb2xpbnQiOiLiqJIiLCJycmFyciI6IuKHiSIsIlJyaWdodGFycm93Ijoi4oebIiwicnNhcXVvIjoi4oC6IiwicnNjciI6IvCdk4ciLCJSc2NyIjoi4oSbIiwicnNoIjoi4oaxIiwiUnNoIjoi4oaxIiwicnNxYiI6Il0iLCJyc3F1byI6IuKAmSIsInJzcXVvciI6IuKAmSIsInJ0aHJlZSI6IuKLjCIsInJ0aW1lcyI6IuKLiiIsInJ0cmkiOiLilrkiLCJydHJpZSI6IuKKtSIsInJ0cmlmIjoi4pa4IiwicnRyaWx0cmkiOiLip44iLCJSdWxlRGVsYXllZCI6IuKntCIsInJ1bHVoYXIiOiLipagiLCJyeCI6IuKEniIsIlNhY3V0ZSI6IsWaIiwic2FjdXRlIjoixZsiLCJzYnF1byI6IuKAmiIsInNjYXAiOiLiqrgiLCJTY2Fyb24iOiLFoCIsInNjYXJvbiI6IsWhIiwiU2MiOiLiqrwiLCJzYyI6IuKJuyIsInNjY3VlIjoi4om9Iiwic2NlIjoi4qqwIiwic2NFIjoi4qq0IiwiU2NlZGlsIjoixZ4iLCJzY2VkaWwiOiLFnyIsIlNjaXJjIjoixZwiLCJzY2lyYyI6IsWdIiwic2NuYXAiOiLiqroiLCJzY25FIjoi4qq2Iiwic2Nuc2ltIjoi4oupIiwic2Nwb2xpbnQiOiLiqJMiLCJzY3NpbSI6IuKJvyIsIlNjeSI6ItChIiwic2N5Ijoi0YEiLCJzZG90YiI6IuKKoSIsInNkb3QiOiLii4UiLCJzZG90ZSI6IuKppiIsInNlYXJoayI6IuKkpSIsInNlYXJyIjoi4oaYIiwic2VBcnIiOiLih5giLCJzZWFycm93Ijoi4oaYIiwic2VjdCI6IsKnIiwic2VtaSI6IjsiLCJzZXN3YXIiOiLipKkiLCJzZXRtaW51cyI6IuKIliIsInNldG1uIjoi4oiWIiwic2V4dCI6IuKctiIsIlNmciI6IvCdlJYiLCJzZnIiOiLwnZSwIiwic2Zyb3duIjoi4oyiIiwic2hhcnAiOiLima8iLCJTSENIY3kiOiLQqSIsInNoY2hjeSI6ItGJIiwiU0hjeSI6ItCoIiwic2hjeSI6ItGIIiwiU2hvcnREb3duQXJyb3ciOiLihpMiLCJTaG9ydExlZnRBcnJvdyI6IuKGkCIsInNob3J0bWlkIjoi4oijIiwic2hvcnRwYXJhbGxlbCI6IuKIpSIsIlNob3J0UmlnaHRBcnJvdyI6IuKGkiIsIlNob3J0VXBBcnJvdyI6IuKGkSIsInNoeSI6IsKtIiwiU2lnbWEiOiLOoyIsInNpZ21hIjoiz4MiLCJzaWdtYWYiOiLPgiIsInNpZ21hdiI6Is+CIiwic2ltIjoi4oi8Iiwic2ltZG90Ijoi4qmqIiwic2ltZSI6IuKJgyIsInNpbWVxIjoi4omDIiwic2ltZyI6IuKqniIsInNpbWdFIjoi4qqgIiwic2ltbCI6IuKqnSIsInNpbWxFIjoi4qqfIiwic2ltbmUiOiLiiYYiLCJzaW1wbHVzIjoi4qikIiwic2ltcmFyciI6IuKlsiIsInNsYXJyIjoi4oaQIiwiU21hbGxDaXJjbGUiOiLiiJgiLCJzbWFsbHNldG1pbnVzIjoi4oiWIiwic21hc2hwIjoi4qizIiwic21lcGFyc2wiOiLip6QiLCJzbWlkIjoi4oijIiwic21pbGUiOiLijKMiLCJzbXQiOiLiqqoiLCJzbXRlIjoi4qqsIiwic210ZXMiOiLiqqzvuIAiLCJTT0ZUY3kiOiLQrCIsInNvZnRjeSI6ItGMIiwic29sYmFyIjoi4oy/Iiwic29sYiI6IuKnhCIsInNvbCI6Ii8iLCJTb3BmIjoi8J2ViiIsInNvcGYiOiLwnZWkIiwic3BhZGVzIjoi4pmgIiwic3BhZGVzdWl0Ijoi4pmgIiwic3BhciI6IuKIpSIsInNxY2FwIjoi4oqTIiwic3FjYXBzIjoi4oqT77iAIiwic3FjdXAiOiLiipQiLCJzcWN1cHMiOiLiipTvuIAiLCJTcXJ0Ijoi4oiaIiwic3FzdWIiOiLiio8iLCJzcXN1YmUiOiLiipEiLCJzcXN1YnNldCI6IuKKjyIsInNxc3Vic2V0ZXEiOiLiipEiLCJzcXN1cCI6IuKKkCIsInNxc3VwZSI6IuKKkiIsInNxc3Vwc2V0Ijoi4oqQIiwic3FzdXBzZXRlcSI6IuKKkiIsInNxdWFyZSI6IuKWoSIsIlNxdWFyZSI6IuKWoSIsIlNxdWFyZUludGVyc2VjdGlvbiI6IuKKkyIsIlNxdWFyZVN1YnNldCI6IuKKjyIsIlNxdWFyZVN1YnNldEVxdWFsIjoi4oqRIiwiU3F1YXJlU3VwZXJzZXQiOiLiipAiLCJTcXVhcmVTdXBlcnNldEVxdWFsIjoi4oqSIiwiU3F1YXJlVW5pb24iOiLiipQiLCJzcXVhcmYiOiLilqoiLCJzcXUiOiLilqEiLCJzcXVmIjoi4paqIiwic3JhcnIiOiLihpIiLCJTc2NyIjoi8J2SriIsInNzY3IiOiLwnZOIIiwic3NldG1uIjoi4oiWIiwic3NtaWxlIjoi4oyjIiwic3N0YXJmIjoi4ouGIiwiU3RhciI6IuKLhiIsInN0YXIiOiLimIYiLCJzdGFyZiI6IuKYhSIsInN0cmFpZ2h0ZXBzaWxvbiI6Is+1Iiwic3RyYWlnaHRwaGkiOiLPlSIsInN0cm5zIjoiwq8iLCJzdWIiOiLiioIiLCJTdWIiOiLii5AiLCJzdWJkb3QiOiLiqr0iLCJzdWJFIjoi4quFIiwic3ViZSI6IuKKhiIsInN1YmVkb3QiOiLiq4MiLCJzdWJtdWx0Ijoi4quBIiwic3VibkUiOiLiq4siLCJzdWJuZSI6IuKKiiIsInN1YnBsdXMiOiLiqr8iLCJzdWJyYXJyIjoi4qW5Iiwic3Vic2V0Ijoi4oqCIiwiU3Vic2V0Ijoi4ouQIiwic3Vic2V0ZXEiOiLiioYiLCJzdWJzZXRlcXEiOiLiq4UiLCJTdWJzZXRFcXVhbCI6IuKKhiIsInN1YnNldG5lcSI6IuKKiiIsInN1YnNldG5lcXEiOiLiq4siLCJzdWJzaW0iOiLiq4ciLCJzdWJzdWIiOiLiq5UiLCJzdWJzdXAiOiLiq5MiLCJzdWNjYXBwcm94Ijoi4qq4Iiwic3VjYyI6IuKJuyIsInN1Y2NjdXJseWVxIjoi4om9IiwiU3VjY2VlZHMiOiLiibsiLCJTdWNjZWVkc0VxdWFsIjoi4qqwIiwiU3VjY2VlZHNTbGFudEVxdWFsIjoi4om9IiwiU3VjY2VlZHNUaWxkZSI6IuKJvyIsInN1Y2NlcSI6IuKqsCIsInN1Y2NuYXBwcm94Ijoi4qq6Iiwic3VjY25lcXEiOiLiqrYiLCJzdWNjbnNpbSI6IuKLqSIsInN1Y2NzaW0iOiLiib8iLCJTdWNoVGhhdCI6IuKIiyIsInN1bSI6IuKIkSIsIlN1bSI6IuKIkSIsInN1bmciOiLimaoiLCJzdXAxIjoiwrkiLCJzdXAyIjoiwrIiLCJzdXAzIjoiwrMiLCJzdXAiOiLiioMiLCJTdXAiOiLii5EiLCJzdXBkb3QiOiLiqr4iLCJzdXBkc3ViIjoi4quYIiwic3VwRSI6IuKrhiIsInN1cGUiOiLiiociLCJzdXBlZG90Ijoi4quEIiwiU3VwZXJzZXQiOiLiioMiLCJTdXBlcnNldEVxdWFsIjoi4oqHIiwic3VwaHNvbCI6IuKfiSIsInN1cGhzdWIiOiLiq5ciLCJzdXBsYXJyIjoi4qW7Iiwic3VwbXVsdCI6IuKrgiIsInN1cG5FIjoi4quMIiwic3VwbmUiOiLiiosiLCJzdXBwbHVzIjoi4quAIiwic3Vwc2V0Ijoi4oqDIiwiU3Vwc2V0Ijoi4ouRIiwic3Vwc2V0ZXEiOiLiiociLCJzdXBzZXRlcXEiOiLiq4YiLCJzdXBzZXRuZXEiOiLiiosiLCJzdXBzZXRuZXFxIjoi4quMIiwic3Vwc2ltIjoi4quIIiwic3Vwc3ViIjoi4quUIiwic3Vwc3VwIjoi4quWIiwic3dhcmhrIjoi4qSmIiwic3dhcnIiOiLihpkiLCJzd0FyciI6IuKHmSIsInN3YXJyb3ciOiLihpkiLCJzd253YXIiOiLipKoiLCJzemxpZyI6IsOfIiwiVGFiIjoiXFx0IiwidGFyZ2V0Ijoi4oyWIiwiVGF1IjoizqQiLCJ0YXUiOiLPhCIsInRicmsiOiLijrQiLCJUY2Fyb24iOiLFpCIsInRjYXJvbiI6IsWlIiwiVGNlZGlsIjoixaIiLCJ0Y2VkaWwiOiLFoyIsIlRjeSI6ItCiIiwidGN5Ijoi0YIiLCJ0ZG90Ijoi4oObIiwidGVscmVjIjoi4oyVIiwiVGZyIjoi8J2UlyIsInRmciI6IvCdlLEiLCJ0aGVyZTQiOiLiiLQiLCJ0aGVyZWZvcmUiOiLiiLQiLCJUaGVyZWZvcmUiOiLiiLQiLCJUaGV0YSI6Is6YIiwidGhldGEiOiLOuCIsInRoZXRhc3ltIjoiz5EiLCJ0aGV0YXYiOiLPkSIsInRoaWNrYXBwcm94Ijoi4omIIiwidGhpY2tzaW0iOiLiiLwiLCJUaGlja1NwYWNlIjoi4oGf4oCKIiwiVGhpblNwYWNlIjoi4oCJIiwidGhpbnNwIjoi4oCJIiwidGhrYXAiOiLiiYgiLCJ0aGtzaW0iOiLiiLwiLCJUSE9STiI6IsOeIiwidGhvcm4iOiLDviIsInRpbGRlIjoiy5wiLCJUaWxkZSI6IuKIvCIsIlRpbGRlRXF1YWwiOiLiiYMiLCJUaWxkZUZ1bGxFcXVhbCI6IuKJhSIsIlRpbGRlVGlsZGUiOiLiiYgiLCJ0aW1lc2JhciI6IuKosSIsInRpbWVzYiI6IuKKoCIsInRpbWVzIjoiw5ciLCJ0aW1lc2QiOiLiqLAiLCJ0aW50Ijoi4oitIiwidG9lYSI6IuKkqCIsInRvcGJvdCI6IuKMtiIsInRvcGNpciI6IuKrsSIsInRvcCI6IuKKpCIsIlRvcGYiOiLwnZWLIiwidG9wZiI6IvCdlaUiLCJ0b3Bmb3JrIjoi4quaIiwidG9zYSI6IuKkqSIsInRwcmltZSI6IuKAtCIsInRyYWRlIjoi4oSiIiwiVFJBREUiOiLihKIiLCJ0cmlhbmdsZSI6IuKWtSIsInRyaWFuZ2xlZG93biI6IuKWvyIsInRyaWFuZ2xlbGVmdCI6IuKXgyIsInRyaWFuZ2xlbGVmdGVxIjoi4oq0IiwidHJpYW5nbGVxIjoi4omcIiwidHJpYW5nbGVyaWdodCI6IuKWuSIsInRyaWFuZ2xlcmlnaHRlcSI6IuKKtSIsInRyaWRvdCI6IuKXrCIsInRyaWUiOiLiiZwiLCJ0cmltaW51cyI6IuKouiIsIlRyaXBsZURvdCI6IuKDmyIsInRyaXBsdXMiOiLiqLkiLCJ0cmlzYiI6IuKnjSIsInRyaXRpbWUiOiLiqLsiLCJ0cnBleml1bSI6IuKPoiIsIlRzY3IiOiLwnZKvIiwidHNjciI6IvCdk4kiLCJUU2N5Ijoi0KYiLCJ0c2N5Ijoi0YYiLCJUU0hjeSI6ItCLIiwidHNoY3kiOiLRmyIsIlRzdHJvayI6IsWmIiwidHN0cm9rIjoixaciLCJ0d2l4dCI6IuKJrCIsInR3b2hlYWRsZWZ0YXJyb3ciOiLihp4iLCJ0d29oZWFkcmlnaHRhcnJvdyI6IuKGoCIsIlVhY3V0ZSI6IsOaIiwidWFjdXRlIjoiw7oiLCJ1YXJyIjoi4oaRIiwiVWFyciI6IuKGnyIsInVBcnIiOiLih5EiLCJVYXJyb2NpciI6IuKliSIsIlVicmN5Ijoi0I4iLCJ1YnJjeSI6ItGeIiwiVWJyZXZlIjoixawiLCJ1YnJldmUiOiLFrSIsIlVjaXJjIjoiw5siLCJ1Y2lyYyI6IsO7IiwiVWN5Ijoi0KMiLCJ1Y3kiOiLRgyIsInVkYXJyIjoi4oeFIiwiVWRibGFjIjoixbAiLCJ1ZGJsYWMiOiLFsSIsInVkaGFyIjoi4qWuIiwidWZpc2h0Ijoi4qW+IiwiVWZyIjoi8J2UmCIsInVmciI6IvCdlLIiLCJVZ3JhdmUiOiLDmSIsInVncmF2ZSI6IsO5IiwidUhhciI6IuKloyIsInVoYXJsIjoi4oa/IiwidWhhcnIiOiLihr4iLCJ1aGJsayI6IuKWgCIsInVsY29ybiI6IuKMnCIsInVsY29ybmVyIjoi4oycIiwidWxjcm9wIjoi4oyPIiwidWx0cmkiOiLil7giLCJVbWFjciI6IsWqIiwidW1hY3IiOiLFqyIsInVtbCI6IsKoIiwiVW5kZXJCYXIiOiJfIiwiVW5kZXJCcmFjZSI6IuKPnyIsIlVuZGVyQnJhY2tldCI6IuKOtSIsIlVuZGVyUGFyZW50aGVzaXMiOiLij50iLCJVbmlvbiI6IuKLgyIsIlVuaW9uUGx1cyI6IuKKjiIsIlVvZ29uIjoixbIiLCJ1b2dvbiI6IsWzIiwiVW9wZiI6IvCdlYwiLCJ1b3BmIjoi8J2VpiIsIlVwQXJyb3dCYXIiOiLipJIiLCJ1cGFycm93Ijoi4oaRIiwiVXBBcnJvdyI6IuKGkSIsIlVwYXJyb3ciOiLih5EiLCJVcEFycm93RG93bkFycm93Ijoi4oeFIiwidXBkb3duYXJyb3ciOiLihpUiLCJVcERvd25BcnJvdyI6IuKGlSIsIlVwZG93bmFycm93Ijoi4oeVIiwiVXBFcXVpbGlicml1bSI6IuKlriIsInVwaGFycG9vbmxlZnQiOiLihr8iLCJ1cGhhcnBvb25yaWdodCI6IuKGviIsInVwbHVzIjoi4oqOIiwiVXBwZXJMZWZ0QXJyb3ciOiLihpYiLCJVcHBlclJpZ2h0QXJyb3ciOiLihpciLCJ1cHNpIjoiz4UiLCJVcHNpIjoiz5IiLCJ1cHNpaCI6Is+SIiwiVXBzaWxvbiI6Is6lIiwidXBzaWxvbiI6Is+FIiwiVXBUZWVBcnJvdyI6IuKGpSIsIlVwVGVlIjoi4oqlIiwidXB1cGFycm93cyI6IuKHiCIsInVyY29ybiI6IuKMnSIsInVyY29ybmVyIjoi4oydIiwidXJjcm9wIjoi4oyOIiwiVXJpbmciOiLFriIsInVyaW5nIjoixa8iLCJ1cnRyaSI6IuKXuSIsIlVzY3IiOiLwnZKwIiwidXNjciI6IvCdk4oiLCJ1dGRvdCI6IuKLsCIsIlV0aWxkZSI6IsWoIiwidXRpbGRlIjoixakiLCJ1dHJpIjoi4pa1IiwidXRyaWYiOiLilrQiLCJ1dWFyciI6IuKHiCIsIlV1bWwiOiLDnCIsInV1bWwiOiLDvCIsInV3YW5nbGUiOiLipqciLCJ2YW5ncnQiOiLippwiLCJ2YXJlcHNpbG9uIjoiz7UiLCJ2YXJrYXBwYSI6Is+wIiwidmFybm90aGluZyI6IuKIhSIsInZhcnBoaSI6Is+VIiwidmFycGkiOiLPliIsInZhcnByb3B0byI6IuKInSIsInZhcnIiOiLihpUiLCJ2QXJyIjoi4oeVIiwidmFycmhvIjoiz7EiLCJ2YXJzaWdtYSI6Is+CIiwidmFyc3Vic2V0bmVxIjoi4oqK77iAIiwidmFyc3Vic2V0bmVxcSI6IuKri++4gCIsInZhcnN1cHNldG5lcSI6IuKKi++4gCIsInZhcnN1cHNldG5lcXEiOiLiq4zvuIAiLCJ2YXJ0aGV0YSI6Is+RIiwidmFydHJpYW5nbGVsZWZ0Ijoi4oqyIiwidmFydHJpYW5nbGVyaWdodCI6IuKKsyIsInZCYXIiOiLiq6giLCJWYmFyIjoi4qurIiwidkJhcnYiOiLiq6kiLCJWY3kiOiLQkiIsInZjeSI6ItCyIiwidmRhc2giOiLiiqIiLCJ2RGFzaCI6IuKKqCIsIlZkYXNoIjoi4oqpIiwiVkRhc2giOiLiiqsiLCJWZGFzaGwiOiLiq6YiLCJ2ZWViYXIiOiLiirsiLCJ2ZWUiOiLiiKgiLCJWZWUiOiLii4EiLCJ2ZWVlcSI6IuKJmiIsInZlbGxpcCI6IuKLriIsInZlcmJhciI6InwiLCJWZXJiYXIiOiLigJYiLCJ2ZXJ0IjoifCIsIlZlcnQiOiLigJYiLCJWZXJ0aWNhbEJhciI6IuKIoyIsIlZlcnRpY2FsTGluZSI6InwiLCJWZXJ0aWNhbFNlcGFyYXRvciI6IuKdmCIsIlZlcnRpY2FsVGlsZGUiOiLiiYAiLCJWZXJ5VGhpblNwYWNlIjoi4oCKIiwiVmZyIjoi8J2UmSIsInZmciI6IvCdlLMiLCJ2bHRyaSI6IuKKsiIsInZuc3ViIjoi4oqC4oOSIiwidm5zdXAiOiLiioPig5IiLCJWb3BmIjoi8J2VjSIsInZvcGYiOiLwnZWnIiwidnByb3AiOiLiiJ0iLCJ2cnRyaSI6IuKKsyIsIlZzY3IiOiLwnZKxIiwidnNjciI6IvCdk4siLCJ2c3VibkUiOiLiq4vvuIAiLCJ2c3VibmUiOiLiiorvuIAiLCJ2c3VwbkUiOiLiq4zvuIAiLCJ2c3VwbmUiOiLiiovvuIAiLCJWdmRhc2giOiLiiqoiLCJ2emlnemFnIjoi4qaaIiwiV2NpcmMiOiLFtCIsIndjaXJjIjoixbUiLCJ3ZWRiYXIiOiLiqZ8iLCJ3ZWRnZSI6IuKIpyIsIldlZGdlIjoi4ouAIiwid2VkZ2VxIjoi4omZIiwid2VpZXJwIjoi4oSYIiwiV2ZyIjoi8J2UmiIsIndmciI6IvCdlLQiLCJXb3BmIjoi8J2VjiIsIndvcGYiOiLwnZWoIiwid3AiOiLihJgiLCJ3ciI6IuKJgCIsIndyZWF0aCI6IuKJgCIsIldzY3IiOiLwnZKyIiwid3NjciI6IvCdk4wiLCJ4Y2FwIjoi4ouCIiwieGNpcmMiOiLil68iLCJ4Y3VwIjoi4ouDIiwieGR0cmkiOiLilr0iLCJYZnIiOiLwnZSbIiwieGZyIjoi8J2UtSIsInhoYXJyIjoi4p+3IiwieGhBcnIiOiLin7oiLCJYaSI6Is6eIiwieGkiOiLOviIsInhsYXJyIjoi4p+1IiwieGxBcnIiOiLin7giLCJ4bWFwIjoi4p+8IiwieG5pcyI6IuKLuyIsInhvZG90Ijoi4qiAIiwiWG9wZiI6IvCdlY8iLCJ4b3BmIjoi8J2VqSIsInhvcGx1cyI6IuKogSIsInhvdGltZSI6IuKogiIsInhyYXJyIjoi4p+2IiwieHJBcnIiOiLin7kiLCJYc2NyIjoi8J2SsyIsInhzY3IiOiLwnZONIiwieHNxY3VwIjoi4qiGIiwieHVwbHVzIjoi4qiEIiwieHV0cmkiOiLilrMiLCJ4dmVlIjoi4ouBIiwieHdlZGdlIjoi4ouAIiwiWWFjdXRlIjoiw50iLCJ5YWN1dGUiOiLDvSIsIllBY3kiOiLQryIsInlhY3kiOiLRjyIsIlljaXJjIjoixbYiLCJ5Y2lyYyI6IsW3IiwiWWN5Ijoi0KsiLCJ5Y3kiOiLRiyIsInllbiI6IsKlIiwiWWZyIjoi8J2UnCIsInlmciI6IvCdlLYiLCJZSWN5Ijoi0IciLCJ5aWN5Ijoi0ZciLCJZb3BmIjoi8J2VkCIsInlvcGYiOiLwnZWqIiwiWXNjciI6IvCdkrQiLCJ5c2NyIjoi8J2TjiIsIllVY3kiOiLQriIsInl1Y3kiOiLRjiIsInl1bWwiOiLDvyIsIll1bWwiOiLFuCIsIlphY3V0ZSI6IsW5IiwiemFjdXRlIjoixboiLCJaY2Fyb24iOiLFvSIsInpjYXJvbiI6IsW+IiwiWmN5Ijoi0JciLCJ6Y3kiOiLQtyIsIlpkb3QiOiLFuyIsInpkb3QiOiLFvCIsInplZXRyZiI6IuKEqCIsIlplcm9XaWR0aFNwYWNlIjoi4oCLIiwiWmV0YSI6Is6WIiwiemV0YSI6Is62IiwiemZyIjoi8J2UtyIsIlpmciI6IuKEqCIsIlpIY3kiOiLQliIsInpoY3kiOiLQtiIsInppZ3JhcnIiOiLih50iLCJ6b3BmIjoi8J2VqyIsIlpvcGYiOiLihKQiLCJac2NyIjoi8J2StSIsInpzY3IiOiLwnZOPIiwiendqIjoi4oCNIiwienduaiI6IuKAjCJ9Jyl9LGZ1bmN0aW9uKGMpe2MuZXhwb3J0cz1KU09OLnBhcnNlKCd7IkFhY3V0ZSI6IsOBIiwiYWFjdXRlIjoiw6EiLCJBY2lyYyI6IsOCIiwiYWNpcmMiOiLDoiIsImFjdXRlIjoiwrQiLCJBRWxpZyI6IsOGIiwiYWVsaWciOiLDpiIsIkFncmF2ZSI6IsOAIiwiYWdyYXZlIjoiw6AiLCJhbXAiOiImIiwiQU1QIjoiJiIsIkFyaW5nIjoiw4UiLCJhcmluZyI6IsOlIiwiQXRpbGRlIjoiw4MiLCJhdGlsZGUiOiLDoyIsIkF1bWwiOiLDhCIsImF1bWwiOiLDpCIsImJydmJhciI6IsKmIiwiQ2NlZGlsIjoiw4ciLCJjY2VkaWwiOiLDpyIsImNlZGlsIjoiwrgiLCJjZW50IjoiwqIiLCJjb3B5IjoiwqkiLCJDT1BZIjoiwqkiLCJjdXJyZW4iOiLCpCIsImRlZyI6IsKwIiwiZGl2aWRlIjoiw7ciLCJFYWN1dGUiOiLDiSIsImVhY3V0ZSI6IsOpIiwiRWNpcmMiOiLDiiIsImVjaXJjIjoiw6oiLCJFZ3JhdmUiOiLDiCIsImVncmF2ZSI6IsOoIiwiRVRIIjoiw5AiLCJldGgiOiLDsCIsIkV1bWwiOiLDiyIsImV1bWwiOiLDqyIsImZyYWMxMiI6IsK9IiwiZnJhYzE0IjoiwrwiLCJmcmFjMzQiOiLCviIsImd0IjoiPiIsIkdUIjoiPiIsIklhY3V0ZSI6IsONIiwiaWFjdXRlIjoiw60iLCJJY2lyYyI6IsOOIiwiaWNpcmMiOiLDriIsImlleGNsIjoiwqEiLCJJZ3JhdmUiOiLDjCIsImlncmF2ZSI6IsOsIiwiaXF1ZXN0Ijoiwr8iLCJJdW1sIjoiw48iLCJpdW1sIjoiw68iLCJsYXF1byI6IsKrIiwibHQiOiI8IiwiTFQiOiI8IiwibWFjciI6IsKvIiwibWljcm8iOiLCtSIsIm1pZGRvdCI6IsK3IiwibmJzcCI6IsKgIiwibm90IjoiwqwiLCJOdGlsZGUiOiLDkSIsIm50aWxkZSI6IsOxIiwiT2FjdXRlIjoiw5MiLCJvYWN1dGUiOiLDsyIsIk9jaXJjIjoiw5QiLCJvY2lyYyI6IsO0IiwiT2dyYXZlIjoiw5IiLCJvZ3JhdmUiOiLDsiIsIm9yZGYiOiLCqiIsIm9yZG0iOiLCuiIsIk9zbGFzaCI6IsOYIiwib3NsYXNoIjoiw7giLCJPdGlsZGUiOiLDlSIsIm90aWxkZSI6IsO1IiwiT3VtbCI6IsOWIiwib3VtbCI6IsO2IiwicGFyYSI6IsK2IiwicGx1c21uIjoiwrEiLCJwb3VuZCI6IsKjIiwicXVvdCI6IlxcIiIsIlFVT1QiOiJcXCIiLCJyYXF1byI6IsK7IiwicmVnIjoiwq4iLCJSRUciOiLCriIsInNlY3QiOiLCpyIsInNoeSI6IsKtIiwic3VwMSI6IsK5Iiwic3VwMiI6IsKyIiwic3VwMyI6IsKzIiwic3psaWciOiLDnyIsIlRIT1JOIjoiw54iLCJ0aG9ybiI6IsO+IiwidGltZXMiOiLDlyIsIlVhY3V0ZSI6IsOaIiwidWFjdXRlIjoiw7oiLCJVY2lyYyI6IsObIiwidWNpcmMiOiLDuyIsIlVncmF2ZSI6IsOZIiwidWdyYXZlIjoiw7kiLCJ1bWwiOiLCqCIsIlV1bWwiOiLDnCIsInV1bWwiOiLDvCIsIllhY3V0ZSI6IsOdIiwieWFjdXRlIjoiw70iLCJ5ZW4iOiLCpSIsInl1bWwiOiLDvyJ9Jyl9LGZ1bmN0aW9uKGMpe2MuZXhwb3J0cz1KU09OLnBhcnNlKGB7ImFtcCI6IiYiLCJhcG9zIjoiJyIsImd0IjoiPiIsImx0IjoiPCIsInF1b3QiOiJcXCIifWApfSxmdW5jdGlvbihjLGUsdCl7dmFyIHI9dGhpcyYmdGhpcy5fX2ltcG9ydERlZmF1bHR8fGZ1bmN0aW9uKHYpe3JldHVybiB2JiZ2Ll9fZXNNb2R1bGU/djp7ZGVmYXVsdDp2fX07T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pO3ZhciBzPXIodCgyNjUpKTtmdW5jdGlvbiBnKHYpe2lmKHY+PTU1Mjk2JiZ2PD01NzM0M3x8dj4xMTE0MTExKXJldHVybiLvv70iO3YgaW4gcy5kZWZhdWx0JiYodj1zLmRlZmF1bHRbdl0pO3ZhciBoPSIiO3JldHVybiB2PjY1NTM1JiYodi09NjU1MzYsaCs9U3RyaW5nLmZyb21DaGFyQ29kZSh2Pj4+MTAmMTAyM3w1NTI5Niksdj01NjMyMHx2JjEwMjMpLGgrPVN0cmluZy5mcm9tQ2hhckNvZGUodiksaH1lLmRlZmF1bHQ9Z30sZnVuY3Rpb24oYyl7Yy5leHBvcnRzPUpTT04ucGFyc2UoJ3siMCI6NjU1MzMsIjEyOCI6ODM2NCwiMTMwIjo4MjE4LCIxMzEiOjQwMiwiMTMyIjo4MjIyLCIxMzMiOjgyMzAsIjEzNCI6ODIyNCwiMTM1Ijo4MjI1LCIxMzYiOjcxMCwiMTM3Ijo4MjQwLCIxMzgiOjM1MiwiMTM5Ijo4MjQ5LCIxNDAiOjMzOCwiMTQyIjozODEsIjE0NSI6ODIxNiwiMTQ2Ijo4MjE3LCIxNDciOjgyMjAsIjE0OCI6ODIyMSwiMTQ5Ijo4MjI2LCIxNTAiOjgyMTEsIjE1MSI6ODIxMiwiMTUyIjo3MzIsIjE1MyI6ODQ4MiwiMTU0IjozNTMsIjE1NSI6ODI1MCwiMTU2IjozMzksIjE1OCI6MzgyLCIxNTkiOjM3Nn0nKX0sZnVuY3Rpb24oYyxlLHQpe3ZhciByPXRoaXMmJnRoaXMuX19pbXBvcnREZWZhdWx0fHxmdW5jdGlvbihwKXtyZXR1cm4gcCYmcC5fX2VzTW9kdWxlP3A6e2RlZmF1bHQ6cH19O09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxlLmVzY2FwZT1lLmVuY29kZUhUTUw9ZS5lbmNvZGVYTUw9dm9pZCAwO3ZhciBzPXIodCgyNjMpKSxnPU0ocy5kZWZhdWx0KSx2PWYoZyk7ZS5lbmNvZGVYTUw9YihnLHYpO3ZhciBoPXIodCgyNjEpKSxsPU0oaC5kZWZhdWx0KSx1PWYobCk7ZS5lbmNvZGVIVE1MPWIobCx1KTtmdW5jdGlvbiBNKHApe3JldHVybiBPYmplY3Qua2V5cyhwKS5zb3J0KCkucmVkdWNlKGZ1bmN0aW9uKG4sYSl7cmV0dXJuIG5bcFthXV09IiYiK2ErIjsiLG59LHt9KX1mdW5jdGlvbiBmKHApe2Zvcih2YXIgbj1bXSxhPVtdLGk9MCxvPU9iamVjdC5rZXlzKHApO2k8by5sZW5ndGg7aSsrKXt2YXIgVD1vW2ldO1QubGVuZ3RoPT09MT9uLnB1c2goIlxcIitUKTphLnB1c2goVCl9bi5zb3J0KCk7Zm9yKHZhciBQPTA7UDxuLmxlbmd0aC0xO1ArKyl7Zm9yKHZhciBDPVA7QzxuLmxlbmd0aC0xJiZuW0NdLmNoYXJDb2RlQXQoMSkrMT09PW5bQysxXS5jaGFyQ29kZUF0KDEpOylDKz0xO3ZhciBJPTErQy1QO0k8M3x8bi5zcGxpY2UoUCxJLG5bUF0rIi0iK25bQ10pfXJldHVybiBhLnVuc2hpZnQoIlsiK24uam9pbigiIikrIl0iKSxuZXcgUmVnRXhwKGEuam9pbigifCIpLCJnIil9dmFyIHk9Lyg/OltceDgwLVx1RDdGRlx1RTAwMC1cdUZGRkZdfFtcdUQ4MDAtXHVEQkZGXVtcdURDMDAtXHVERkZGXXxbXHVEODAwLVx1REJGRl0oPyFbXHVEQzAwLVx1REZGRl0pfCg/OlteXHVEODAwLVx1REJGRl18XilbXHVEQzAwLVx1REZGRl0pL2c7ZnVuY3Rpb24geChwKXtyZXR1cm4iJiN4IitwLmNvZGVQb2ludEF0KDApLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpKyI7In1mdW5jdGlvbiBiKHAsbil7cmV0dXJuIGZ1bmN0aW9uKGEpe3JldHVybiBhLnJlcGxhY2UobixmdW5jdGlvbihpKXtyZXR1cm4gcFtpXX0pLnJlcGxhY2UoeSx4KX19dmFyIE89ZihnKTtmdW5jdGlvbiBtKHApe3JldHVybiBwLnJlcGxhY2UoTyx4KS5yZXBsYWNlKHkseCl9ZS5lc2NhcGU9bX0sZnVuY3Rpb24oYyl7Yy5leHBvcnRzPUpTT04ucGFyc2UoJ3siZWxlbWVudE5hbWVzIjp7ImFsdGdseXBoIjoiYWx0R2x5cGgiLCJhbHRnbHlwaGRlZiI6ImFsdEdseXBoRGVmIiwiYWx0Z2x5cGhpdGVtIjoiYWx0R2x5cGhJdGVtIiwiYW5pbWF0ZWNvbG9yIjoiYW5pbWF0ZUNvbG9yIiwiYW5pbWF0ZW1vdGlvbiI6ImFuaW1hdGVNb3Rpb24iLCJhbmltYXRldHJhbnNmb3JtIjoiYW5pbWF0ZVRyYW5zZm9ybSIsImNsaXBwYXRoIjoiY2xpcFBhdGgiLCJmZWJsZW5kIjoiZmVCbGVuZCIsImZlY29sb3JtYXRyaXgiOiJmZUNvbG9yTWF0cml4IiwiZmVjb21wb25lbnR0cmFuc2ZlciI6ImZlQ29tcG9uZW50VHJhbnNmZXIiLCJmZWNvbXBvc2l0ZSI6ImZlQ29tcG9zaXRlIiwiZmVjb252b2x2ZW1hdHJpeCI6ImZlQ29udm9sdmVNYXRyaXgiLCJmZWRpZmZ1c2VsaWdodGluZyI6ImZlRGlmZnVzZUxpZ2h0aW5nIiwiZmVkaXNwbGFjZW1lbnRtYXAiOiJmZURpc3BsYWNlbWVudE1hcCIsImZlZGlzdGFudGxpZ2h0IjoiZmVEaXN0YW50TGlnaHQiLCJmZWRyb3BzaGFkb3ciOiJmZURyb3BTaGFkb3ciLCJmZWZsb29kIjoiZmVGbG9vZCIsImZlZnVuY2EiOiJmZUZ1bmNBIiwiZmVmdW5jYiI6ImZlRnVuY0IiLCJmZWZ1bmNnIjoiZmVGdW5jRyIsImZlZnVuY3IiOiJmZUZ1bmNSIiwiZmVnYXVzc2lhbmJsdXIiOiJmZUdhdXNzaWFuQmx1ciIsImZlaW1hZ2UiOiJmZUltYWdlIiwiZmVtZXJnZSI6ImZlTWVyZ2UiLCJmZW1lcmdlbm9kZSI6ImZlTWVyZ2VOb2RlIiwiZmVtb3JwaG9sb2d5IjoiZmVNb3JwaG9sb2d5IiwiZmVvZmZzZXQiOiJmZU9mZnNldCIsImZlcG9pbnRsaWdodCI6ImZlUG9pbnRMaWdodCIsImZlc3BlY3VsYXJsaWdodGluZyI6ImZlU3BlY3VsYXJMaWdodGluZyIsImZlc3BvdGxpZ2h0IjoiZmVTcG90TGlnaHQiLCJmZXRpbGUiOiJmZVRpbGUiLCJmZXR1cmJ1bGVuY2UiOiJmZVR1cmJ1bGVuY2UiLCJmb3JlaWdub2JqZWN0IjoiZm9yZWlnbk9iamVjdCIsImdseXBocmVmIjoiZ2x5cGhSZWYiLCJsaW5lYXJncmFkaWVudCI6ImxpbmVhckdyYWRpZW50IiwicmFkaWFsZ3JhZGllbnQiOiJyYWRpYWxHcmFkaWVudCIsInRleHRwYXRoIjoidGV4dFBhdGgifSwiYXR0cmlidXRlTmFtZXMiOnsiZGVmaW5pdGlvbnVybCI6ImRlZmluaXRpb25VUkwiLCJhdHRyaWJ1dGVuYW1lIjoiYXR0cmlidXRlTmFtZSIsImF0dHJpYnV0ZXR5cGUiOiJhdHRyaWJ1dGVUeXBlIiwiYmFzZWZyZXF1ZW5jeSI6ImJhc2VGcmVxdWVuY3kiLCJiYXNlcHJvZmlsZSI6ImJhc2VQcm9maWxlIiwiY2FsY21vZGUiOiJjYWxjTW9kZSIsImNsaXBwYXRodW5pdHMiOiJjbGlwUGF0aFVuaXRzIiwiZGlmZnVzZWNvbnN0YW50IjoiZGlmZnVzZUNvbnN0YW50IiwiZWRnZW1vZGUiOiJlZGdlTW9kZSIsImZpbHRlcnVuaXRzIjoiZmlsdGVyVW5pdHMiLCJnbHlwaHJlZiI6ImdseXBoUmVmIiwiZ3JhZGllbnR0cmFuc2Zvcm0iOiJncmFkaWVudFRyYW5zZm9ybSIsImdyYWRpZW50dW5pdHMiOiJncmFkaWVudFVuaXRzIiwia2VybmVsbWF0cml4Ijoia2VybmVsTWF0cml4Iiwia2VybmVsdW5pdGxlbmd0aCI6Imtlcm5lbFVuaXRMZW5ndGgiLCJrZXlwb2ludHMiOiJrZXlQb2ludHMiLCJrZXlzcGxpbmVzIjoia2V5U3BsaW5lcyIsImtleXRpbWVzIjoia2V5VGltZXMiLCJsZW5ndGhhZGp1c3QiOiJsZW5ndGhBZGp1c3QiLCJsaW1pdGluZ2NvbmVhbmdsZSI6ImxpbWl0aW5nQ29uZUFuZ2xlIiwibWFya2VyaGVpZ2h0IjoibWFya2VySGVpZ2h0IiwibWFya2VydW5pdHMiOiJtYXJrZXJVbml0cyIsIm1hcmtlcndpZHRoIjoibWFya2VyV2lkdGgiLCJtYXNrY29udGVudHVuaXRzIjoibWFza0NvbnRlbnRVbml0cyIsIm1hc2t1bml0cyI6Im1hc2tVbml0cyIsIm51bW9jdGF2ZXMiOiJudW1PY3RhdmVzIiwicGF0aGxlbmd0aCI6InBhdGhMZW5ndGgiLCJwYXR0ZXJuY29udGVudHVuaXRzIjoicGF0dGVybkNvbnRlbnRVbml0cyIsInBhdHRlcm50cmFuc2Zvcm0iOiJwYXR0ZXJuVHJhbnNmb3JtIiwicGF0dGVybnVuaXRzIjoicGF0dGVyblVuaXRzIiwicG9pbnRzYXR4IjoicG9pbnRzQXRYIiwicG9pbnRzYXR5IjoicG9pbnRzQXRZIiwicG9pbnRzYXR6IjoicG9pbnRzQXRaIiwicHJlc2VydmVhbHBoYSI6InByZXNlcnZlQWxwaGEiLCJwcmVzZXJ2ZWFzcGVjdHJhdGlvIjoicHJlc2VydmVBc3BlY3RSYXRpbyIsInByaW1pdGl2ZXVuaXRzIjoicHJpbWl0aXZlVW5pdHMiLCJyZWZ4IjoicmVmWCIsInJlZnkiOiJyZWZZIiwicmVwZWF0Y291bnQiOiJyZXBlYXRDb3VudCIsInJlcGVhdGR1ciI6InJlcGVhdER1ciIsInJlcXVpcmVkZXh0ZW5zaW9ucyI6InJlcXVpcmVkRXh0ZW5zaW9ucyIsInJlcXVpcmVkZmVhdHVyZXMiOiJyZXF1aXJlZEZlYXR1cmVzIiwic3BlY3VsYXJjb25zdGFudCI6InNwZWN1bGFyQ29uc3RhbnQiLCJzcGVjdWxhcmV4cG9uZW50Ijoic3BlY3VsYXJFeHBvbmVudCIsInNwcmVhZG1ldGhvZCI6InNwcmVhZE1ldGhvZCIsInN0YXJ0b2Zmc2V0Ijoic3RhcnRPZmZzZXQiLCJzdGRkZXZpYXRpb24iOiJzdGREZXZpYXRpb24iLCJzdGl0Y2h0aWxlcyI6InN0aXRjaFRpbGVzIiwic3VyZmFjZXNjYWxlIjoic3VyZmFjZVNjYWxlIiwic3lzdGVtbGFuZ3VhZ2UiOiJzeXN0ZW1MYW5ndWFnZSIsInRhYmxldmFsdWVzIjoidGFibGVWYWx1ZXMiLCJ0YXJnZXR4IjoidGFyZ2V0WCIsInRhcmdldHkiOiJ0YXJnZXRZIiwidGV4dGxlbmd0aCI6InRleHRMZW5ndGgiLCJ2aWV3Ym94Ijoidmlld0JveCIsInZpZXd0YXJnZXQiOiJ2aWV3VGFyZ2V0IiwieGNoYW5uZWxzZWxlY3RvciI6InhDaGFubmVsU2VsZWN0b3IiLCJ5Y2hhbm5lbHNlbGVjdG9yIjoieUNoYW5uZWxTZWxlY3RvciIsInpvb21hbmRwYW4iOiJ6b29tQW5kUGFuIn19Jyl9LGZ1bmN0aW9uKGMsZSl7dmFyIHQ9ZS5nZXRDaGlsZHJlbj1mdW5jdGlvbihzKXtyZXR1cm4gcy5jaGlsZHJlbn0scj1lLmdldFBhcmVudD1mdW5jdGlvbihzKXtyZXR1cm4gcy5wYXJlbnR9O2UuZ2V0U2libGluZ3M9ZnVuY3Rpb24ocyl7dmFyIGc9cihzKTtyZXR1cm4gZz90KGcpOltzXX0sZS5nZXRBdHRyaWJ1dGVWYWx1ZT1mdW5jdGlvbihzLGcpe3JldHVybiBzLmF0dHJpYnMmJnMuYXR0cmlic1tnXX0sZS5oYXNBdHRyaWI9ZnVuY3Rpb24ocyxnKXtyZXR1cm4hIXMuYXR0cmlicyYmaGFzT3duUHJvcGVydHkuY2FsbChzLmF0dHJpYnMsZyl9LGUuZ2V0TmFtZT1mdW5jdGlvbihzKXtyZXR1cm4gcy5uYW1lfX0sZnVuY3Rpb24oYyxlKXtlLnJlbW92ZUVsZW1lbnQ9ZnVuY3Rpb24odCl7aWYodC5wcmV2JiYodC5wcmV2Lm5leHQ9dC5uZXh0KSx0Lm5leHQmJih0Lm5leHQucHJldj10LnByZXYpLHQucGFyZW50KXt2YXIgcj10LnBhcmVudC5jaGlsZHJlbjtyLnNwbGljZShyLmxhc3RJbmRleE9mKHQpLDEpfX0sZS5yZXBsYWNlRWxlbWVudD1mdW5jdGlvbih0LHIpe3ZhciBzPXIucHJldj10LnByZXY7cyYmKHMubmV4dD1yKTt2YXIgZz1yLm5leHQ9dC5uZXh0O2cmJihnLnByZXY9cik7dmFyIHY9ci5wYXJlbnQ9dC5wYXJlbnQ7aWYodil7dmFyIGg9di5jaGlsZHJlbjtoW2gubGFzdEluZGV4T2YodCldPXJ9fSxlLmFwcGVuZENoaWxkPWZ1bmN0aW9uKHQscil7aWYoci5wYXJlbnQ9dCx0LmNoaWxkcmVuLnB1c2gocikhPT0xKXt2YXIgcz10LmNoaWxkcmVuW3QuY2hpbGRyZW4ubGVuZ3RoLTJdO3MubmV4dD1yLHIucHJldj1zLHIubmV4dD1udWxsfX0sZS5hcHBlbmQ9ZnVuY3Rpb24odCxyKXt2YXIgcz10LnBhcmVudCxnPXQubmV4dDtpZihyLm5leHQ9ZyxyLnByZXY9dCx0Lm5leHQ9cixyLnBhcmVudD1zLGcpe2lmKGcucHJldj1yLHMpe3ZhciB2PXMuY2hpbGRyZW47di5zcGxpY2Uodi5sYXN0SW5kZXhPZihnKSwwLHIpfX1lbHNlIHMmJnMuY2hpbGRyZW4ucHVzaChyKX0sZS5wcmVwZW5kPWZ1bmN0aW9uKHQscil7dmFyIHM9dC5wYXJlbnQ7aWYocyl7dmFyIGc9cy5jaGlsZHJlbjtnLnNwbGljZShnLmxhc3RJbmRleE9mKHQpLDAscil9dC5wcmV2JiYodC5wcmV2Lm5leHQ9ciksci5wYXJlbnQ9cyxyLnByZXY9dC5wcmV2LHIubmV4dD10LHQucHJldj1yfX0sZnVuY3Rpb24oYyxlLHQpe3ZhciByPXQoMjU2KS5pc1RhZztjLmV4cG9ydHM9e2ZpbHRlcjpzLGZpbmQ6ZyxmaW5kT25lQ2hpbGQ6dixmaW5kT25lOmgsZXhpc3RzT25lOmwsZmluZEFsbDp1fTtmdW5jdGlvbiBzKE0sZix5LHgpe3JldHVybiBBcnJheS5pc0FycmF5KGYpfHwoZj1bZl0pLCh0eXBlb2YgeCE9Im51bWJlciJ8fCFpc0Zpbml0ZSh4KSkmJih4PTEvMCksZyhNLGYseSE9PSExLHgpfWZ1bmN0aW9uIGcoTSxmLHkseCl7Zm9yKHZhciBiPVtdLE8sbT0wLHA9Zi5sZW5ndGg7bTxwJiYhKE0oZlttXSkmJihiLnB1c2goZlttXSksLS14PD0wKXx8KE89ZlttXS5jaGlsZHJlbix5JiZPJiZPLmxlbmd0aD4wJiYoTz1nKE0sTyx5LHgpLGI9Yi5jb25jYXQoTykseC09Ty5sZW5ndGgseDw9MCkpKTttKyspO3JldHVybiBifWZ1bmN0aW9uIHYoTSxmKXtmb3IodmFyIHk9MCx4PWYubGVuZ3RoO3k8eDt5KyspaWYoTShmW3ldKSlyZXR1cm4gZlt5XTtyZXR1cm4gbnVsbH1mdW5jdGlvbiBoKE0sZil7Zm9yKHZhciB5PW51bGwseD0wLGI9Zi5sZW5ndGg7eDxiJiYheTt4KyspaWYocihmW3hdKSlNKGZbeF0pP3k9Zlt4XTpmW3hdLmNoaWxkcmVuLmxlbmd0aD4wJiYoeT1oKE0sZlt4XS5jaGlsZHJlbikpO2Vsc2UgY29udGludWU7cmV0dXJuIHl9ZnVuY3Rpb24gbChNLGYpe2Zvcih2YXIgeT0wLHg9Zi5sZW5ndGg7eTx4O3krKylpZihyKGZbeV0pJiYoTShmW3ldKXx8Zlt5XS5jaGlsZHJlbi5sZW5ndGg+MCYmbChNLGZbeV0uY2hpbGRyZW4pKSlyZXR1cm4hMDtyZXR1cm4hMX1mdW5jdGlvbiB1KE0sZil7Zm9yKHZhciB5PVtdLHg9Zi5zbGljZSgpO3gubGVuZ3RoOyl7dmFyIGI9eC5zaGlmdCgpO3IoYikmJihiLmNoaWxkcmVuJiZiLmNoaWxkcmVuLmxlbmd0aD4wJiZ4LnVuc2hpZnQuYXBwbHkoeCxiLmNoaWxkcmVuKSxNKGIpJiZ5LnB1c2goYikpfXJldHVybiB5fX0sZnVuY3Rpb24oYyxlLHQpe3ZhciByPXQoMjU2KSxzPWUuaXNUYWc9ci5pc1RhZztlLnRlc3RFbGVtZW50PWZ1bmN0aW9uKGwsdSl7Zm9yKHZhciBNIGluIGwpaWYobC5oYXNPd25Qcm9wZXJ0eShNKSl7aWYoTT09PSJ0YWdfbmFtZSIpe2lmKCFzKHUpfHwhbC50YWdfbmFtZSh1Lm5hbWUpKXJldHVybiExfWVsc2UgaWYoTT09PSJ0YWdfdHlwZSIpe2lmKCFsLnRhZ190eXBlKHUudHlwZSkpcmV0dXJuITF9ZWxzZSBpZihNPT09InRhZ19jb250YWlucyIpe2lmKHModSl8fCFsLnRhZ19jb250YWlucyh1LmRhdGEpKXJldHVybiExfWVsc2UgaWYoIXUuYXR0cmlic3x8IWxbTV0odS5hdHRyaWJzW01dKSlyZXR1cm4hMX1yZXR1cm4hMH07dmFyIGc9e3RhZ19uYW1lOmZ1bmN0aW9uKGwpe3JldHVybiB0eXBlb2YgbD09ImZ1bmN0aW9uIj9mdW5jdGlvbih1KXtyZXR1cm4gcyh1KSYmbCh1Lm5hbWUpfTpsPT09IioiP3M6ZnVuY3Rpb24odSl7cmV0dXJuIHModSkmJnUubmFtZT09PWx9fSx0YWdfdHlwZTpmdW5jdGlvbihsKXtyZXR1cm4gdHlwZW9mIGw9PSJmdW5jdGlvbiI/ZnVuY3Rpb24odSl7cmV0dXJuIGwodS50eXBlKX06ZnVuY3Rpb24odSl7cmV0dXJuIHUudHlwZT09PWx9fSx0YWdfY29udGFpbnM6ZnVuY3Rpb24obCl7cmV0dXJuIHR5cGVvZiBsPT0iZnVuY3Rpb24iP2Z1bmN0aW9uKHUpe3JldHVybiFzKHUpJiZsKHUuZGF0YSl9OmZ1bmN0aW9uKHUpe3JldHVybiFzKHUpJiZ1LmRhdGE9PT1sfX19O2Z1bmN0aW9uIHYobCx1KXtyZXR1cm4gdHlwZW9mIHU9PSJmdW5jdGlvbiI/ZnVuY3Rpb24oTSl7cmV0dXJuIE0uYXR0cmlicyYmdShNLmF0dHJpYnNbbF0pfTpmdW5jdGlvbihNKXtyZXR1cm4gTS5hdHRyaWJzJiZNLmF0dHJpYnNbbF09PT11fX1mdW5jdGlvbiBoKGwsdSl7cmV0dXJuIGZ1bmN0aW9uKE0pe3JldHVybiBsKE0pfHx1KE0pfX1lLmdldEVsZW1lbnRzPWZ1bmN0aW9uKGwsdSxNLGYpe3ZhciB5PU9iamVjdC5rZXlzKGwpLm1hcChmdW5jdGlvbih4KXt2YXIgYj1sW3hdO3JldHVybiB4IGluIGc/Z1t4XShiKTp2KHgsYil9KTtyZXR1cm4geS5sZW5ndGg9PT0wP1tdOnRoaXMuZmlsdGVyKHkucmVkdWNlKGgpLHUsTSxmKX0sZS5nZXRFbGVtZW50QnlJZD1mdW5jdGlvbihsLHUsTSl7cmV0dXJuIEFycmF5LmlzQXJyYXkodSl8fCh1PVt1XSksdGhpcy5maW5kT25lKHYoImlkIixsKSx1LE0hPT0hMSl9LGUuZ2V0RWxlbWVudHNCeVRhZ05hbWU9ZnVuY3Rpb24obCx1LE0sZil7cmV0dXJuIHRoaXMuZmlsdGVyKGcudGFnX25hbWUobCksdSxNLGYpfSxlLmdldEVsZW1lbnRzQnlUYWdUeXBlPWZ1bmN0aW9uKGwsdSxNLGYpe3JldHVybiB0aGlzLmZpbHRlcihnLnRhZ190eXBlKGwpLHUsTSxmKX19LGZ1bmN0aW9uKGMsZSl7ZS5yZW1vdmVTdWJzZXRzPWZ1bmN0aW9uKHMpe2Zvcih2YXIgZz1zLmxlbmd0aCx2LGgsbDstLWc+LTE7KXtmb3Iodj1oPXNbZ10sc1tnXT1udWxsLGw9ITA7aDspe2lmKHMuaW5kZXhPZihoKT4tMSl7bD0hMSxzLnNwbGljZShnLDEpO2JyZWFrfWg9aC5wYXJlbnR9bCYmKHNbZ109dil9cmV0dXJuIHN9O3ZhciB0PXtESVNDT05ORUNURUQ6MSxQUkVDRURJTkc6MixGT0xMT1dJTkc6NCxDT05UQUlOUzo4LENPTlRBSU5FRF9CWToxNn0scj1lLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uPWZ1bmN0aW9uKHMsZyl7dmFyIHY9W10saD1bXSxsLHUsTSxmLHkseDtpZihzPT09ZylyZXR1cm4gMDtmb3IobD1zO2w7KXYudW5zaGlmdChsKSxsPWwucGFyZW50O2ZvcihsPWc7bDspaC51bnNoaWZ0KGwpLGw9bC5wYXJlbnQ7Zm9yKHg9MDt2W3hdPT09aFt4XTspeCsrO3JldHVybiB4PT09MD90LkRJU0NPTk5FQ1RFRDoodT12W3gtMV0sTT11LmNoaWxkcmVuLGY9dlt4XSx5PWhbeF0sTS5pbmRleE9mKGYpPk0uaW5kZXhPZih5KT91PT09Zz90LkZPTExPV0lOR3x0LkNPTlRBSU5FRF9CWTp0LkZPTExPV0lORzp1PT09cz90LlBSRUNFRElOR3x0LkNPTlRBSU5TOnQuUFJFQ0VESU5HKX07ZS51bmlxdWVTb3J0PWZ1bmN0aW9uKHMpe3ZhciBnPXMubGVuZ3RoLHYsaDtmb3Iocz1zLnNsaWNlKCk7LS1nPi0xOyl2PXNbZ10saD1zLmluZGV4T2YodiksaD4tMSYmaDxnJiZzLnNwbGljZShnLDEpO3JldHVybiBzLnNvcnQoZnVuY3Rpb24obCx1KXt2YXIgTT1yKGwsdSk7cmV0dXJuIE0mdC5QUkVDRURJTkc/LTE6TSZ0LkZPTExPV0lORz8xOjB9KSxzfX0sZnVuY3Rpb24oYyxlKXtjLmV4cG9ydHM9e3RydWVGdW5jOmZ1bmN0aW9uKCl7cmV0dXJuITB9LGZhbHNlRnVuYzpmdW5jdGlvbigpe3JldHVybiExfX19LGZ1bmN0aW9uKGMsZSx0KXtjLmV4cG9ydHM9eTt2YXIgcj10KDI3NSkucGFyc2Uscz10KDI3MyksZz10KDI3OCksdj10KDI3OSksaD10KDI4MCksbD10KDI4MiksdT1zLnRydWVGdW5jLE09cy5mYWxzZUZ1bmMsZj1sLmZpbHRlcnM7ZnVuY3Rpb24geShBLEwsRCl7dmFyIFI9YihBLEwsRCk7cmV0dXJuIHgoUixMKX1mdW5jdGlvbiB4KEEsTCl7dmFyIEQ9TC5hZGFwdGVyO3JldHVybiBmdW5jdGlvbihTKXtyZXR1cm4gRC5pc1RhZyhTKSYmQShTKX19ZnVuY3Rpb24gYihBLEwsRCl7dmFyIFI9cihBLEwpO3JldHVybiBvKFIsTCxEKX1mdW5jdGlvbiBPKEEpe3JldHVybiBBLnR5cGU9PT0icHNldWRvIiYmKEEubmFtZT09PSJzY29wZSJ8fEFycmF5LmlzQXJyYXkoQS5kYXRhKSYmQS5kYXRhLnNvbWUoZnVuY3Rpb24oTCl7cmV0dXJuIEwuc29tZShPKX0pKX12YXIgbT17dHlwZToiZGVzY2VuZGFudCJ9LHA9e3R5cGU6Il9mbGV4aWJsZURlc2NlbmRhbnQifSxuPXt0eXBlOiJwc2V1ZG8iLG5hbWU6InNjb3BlIn0sYT17fTtmdW5jdGlvbiBpKEEsTCxEKXt2YXIgUj1MLmFkYXB0ZXIsUz0hIUQmJiEhRC5sZW5ndGgmJkQuZXZlcnkoZnVuY3Rpb24oQil7cmV0dXJuIEI9PT1hfHwhIVIuZ2V0UGFyZW50KEIpfSk7QS5mb3JFYWNoKGZ1bmN0aW9uKEIpe2lmKCEoQi5sZW5ndGg+MCYmVChCWzBdKSYmQlswXS50eXBlIT09ImRlc2NlbmRhbnQiKSlpZihTJiYhKEFycmF5LmlzQXJyYXkoQik/Qi5zb21lKE8pOk8oQikpKUIudW5zaGlmdChtKTtlbHNlIHJldHVybjtCLnVuc2hpZnQobil9KX1mdW5jdGlvbiBvKEEsTCxEKXtBPUEuZmlsdGVyKGZ1bmN0aW9uKHcpe3JldHVybiB3Lmxlbmd0aD4wfSksQS5mb3JFYWNoKGcpO3ZhciBSPUFycmF5LmlzQXJyYXkoRCk7RD1MJiZMLmNvbnRleHR8fEQsRCYmIVImJihEPVtEXSksaShBLEwsRCk7dmFyIFM9ITEsQj1BLm1hcChmdW5jdGlvbih3KXtpZih3WzBdJiZ3WzFdJiZ3WzBdLm5hbWU9PT0ic2NvcGUiKXt2YXIgSD13WzFdLnR5cGU7UiYmSD09PSJkZXNjZW5kYW50Ij93WzFdPXA6KEg9PT0iYWRqYWNlbnQifHxIPT09InNpYmxpbmciKSYmKFM9ITApfXJldHVybiBQKHcsTCxEKX0pLnJlZHVjZShDLE0pO3JldHVybiBCLnNob3VsZFRlc3ROZXh0U2libGluZ3M9UyxCfWZ1bmN0aW9uIFQoQSl7cmV0dXJuIHZbQS50eXBlXTwwfWZ1bmN0aW9uIFAoQSxMLEQpe3JldHVybiBBLnJlZHVjZShmdW5jdGlvbihSLFMpe2lmKFI9PT1NKXJldHVybiBSO2lmKCEoUy50eXBlIGluIGgpKXRocm93IG5ldyBFcnJvcigiUnVsZSB0eXBlICIrUy50eXBlKyIgaXMgbm90IHN1cHBvcnRlZCBieSBjc3Mtc2VsZWN0Iik7cmV0dXJuIGhbUy50eXBlXShSLFMsTCxEKX0sTCYmTC5yb290RnVuY3x8dSl9ZnVuY3Rpb24gQyhBLEwpe3JldHVybiBMPT09TXx8QT09PXU/QTpBPT09TXx8TD09PXU/TDpmdW5jdGlvbihSKXtyZXR1cm4gQShSKXx8TChSKX19ZnVuY3Rpb24gSShBKXtyZXR1cm4gQS5zb21lKFQpfWYubm90PWZ1bmN0aW9uKEEsTCxELFIpe3ZhciBTPXt4bWxNb2RlOiEhKEQmJkQueG1sTW9kZSksc3RyaWN0OiEhKEQmJkQuc3RyaWN0KSxhZGFwdGVyOkQuYWRhcHRlcn07aWYoUy5zdHJpY3QmJihMLmxlbmd0aD4xfHxMLnNvbWUoSSkpKXRocm93IG5ldyBFcnJvcigiY29tcGxleCBzZWxlY3RvcnMgaW4gOm5vdCBhcmVuJ3QgYWxsb3dlZCBpbiBzdHJpY3QgbW9kZSIpO3ZhciBCPW8oTCxTLFIpO3JldHVybiBCPT09TT9BOkI9PT11P006ZnVuY3Rpb24oSCl7cmV0dXJuIUIoSCkmJkEoSCl9fSxmLmhhcz1mdW5jdGlvbihBLEwsRCl7dmFyIFI9RC5hZGFwdGVyLFM9e3htbE1vZGU6ISEoRCYmRC54bWxNb2RlKSxzdHJpY3Q6ISEoRCYmRC5zdHJpY3QpLGFkYXB0ZXI6Un0sQj1MLnNvbWUoSSk/W2FdOm51bGwsdz1vKEwsUyxCKTtyZXR1cm4gdz09PU0/TTp3PT09dT9mdW5jdGlvbihKKXtyZXR1cm4gUi5nZXRDaGlsZHJlbihKKS5zb21lKFIuaXNUYWcpJiZBKEopfToodz14KHcsRCksQj9mdW5jdGlvbihKKXtyZXR1cm4gQShKKSYmKEJbMF09SixSLmV4aXN0c09uZSh3LFIuZ2V0Q2hpbGRyZW4oSikpKX06ZnVuY3Rpb24oSil7cmV0dXJuIEEoSikmJlIuZXhpc3RzT25lKHcsUi5nZXRDaGlsZHJlbihKKSl9KX0sZi5tYXRjaGVzPWZ1bmN0aW9uKEEsTCxELFIpe3ZhciBTPXt4bWxNb2RlOiEhKEQmJkQueG1sTW9kZSksc3RyaWN0OiEhKEQmJkQuc3RyaWN0KSxyb290RnVuYzpBLGFkYXB0ZXI6RC5hZGFwdGVyfTtyZXR1cm4gbyhMLFMsUil9LHkuY29tcGlsZVRva2VuPW8seS5jb21waWxlVW5zYWZlPWIseS5Qc2V1ZG9zPWx9LGZ1bmN0aW9uKGMsZSx0KXt2YXIgcj10aGlzJiZ0aGlzLl9fY3JlYXRlQmluZGluZ3x8KE9iamVjdC5jcmVhdGU/ZnVuY3Rpb24oaCxsLHUsTSl7TT09PXZvaWQgMCYmKE09dSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGgsTSx7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gbFt1XX19KX06ZnVuY3Rpb24oaCxsLHUsTSl7TT09PXZvaWQgMCYmKE09dSksaFtNXT1sW3VdfSkscz10aGlzJiZ0aGlzLl9fZXhwb3J0U3Rhcnx8ZnVuY3Rpb24oaCxsKXtmb3IodmFyIHUgaW4gaCl1IT09ImRlZmF1bHQiJiYhbC5oYXNPd25Qcm9wZXJ0eSh1KSYmcihsLGgsdSl9O09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxzKHQoMjc2KSxlKTt2YXIgZz10KDI3Nik7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsInBhcnNlIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gZy5kZWZhdWx0fX0pO3ZhciB2PXQoMjc3KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwic3RyaW5naWZ5Iix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdi5kZWZhdWx0fX0pfSxmdW5jdGlvbihjLGUsdCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLGUuZGVmYXVsdD1PO3ZhciByPS9eW15cXF0/KD86XFwoPzpbXGRhLWZdezEsNn1ccz98Lil8W1x3XC1cdTAwYjAtXHVGRkZGXSkrLyxzPS9cXChbXGRhLWZdezEsNn1ccz98KFxzKXwuKS9naSxnPS9eXHMqKCg/OlxcLnxbXHdcdTAwYjAtXHVGRkZGLV0pKylccyooPzooXFM/KT1ccyooPzooWyciXSkoW15dKj8pXDN8KCM/KD86XFwufFtcd1x1MDBiMC1cdUZGRkYtXSkqKXwpfClccyooaSk/XF0vLHY9e3VuZGVmaW5lZDoiZXhpc3RzIiwiIjoiZXF1YWxzIiwifiI6ImVsZW1lbnQiLCJeIjoic3RhcnQiLCQ6ImVuZCIsIioiOiJhbnkiLCIhIjoibm90IiwifCI6Imh5cGhlbiJ9LGg9eyI+IjoiY2hpbGQiLCI8IjoicGFyZW50IiwifiI6InNpYmxpbmciLCIrIjoiYWRqYWNlbnQifSxsPXsiIyI6WyJpZCIsImVxdWFscyJdLCIuIjpbImNsYXNzIiwiZWxlbWVudCJdfSx1PW5ldyBTZXQoWyJoYXMiLCJub3QiLCJtYXRjaGVzIl0pLE09bmV3IFNldChbImNvbnRhaW5zIiwiaWNvbnRhaW5zIl0pLGY9bmV3IFNldChbJyInLCInIl0pO2Z1bmN0aW9uIHkobixhLGkpe3ZhciBvPXBhcnNlSW50KGEsMTYpLTY1NTM2O3JldHVybiBvIT09b3x8aT9hOm88MD9TdHJpbmcuZnJvbUNoYXJDb2RlKG8rNjU1MzYpOlN0cmluZy5mcm9tQ2hhckNvZGUobz4+MTB8NTUyOTYsbyYxMDIzfDU2MzIwKX1mdW5jdGlvbiB4KG4pe3JldHVybiBuLnJlcGxhY2Uocyx5KX1mdW5jdGlvbiBiKG4pe3JldHVybiBuPT09IiAifHxuPT09YApgfHxuPT09IgkifHxuPT09IlxmInx8bj09PSJcciJ9ZnVuY3Rpb24gTyhuLGEpe3ZhciBpPVtdO2lmKG49bShpLCIiK24sYSksbiE9PSIiKXRocm93IG5ldyBFcnJvcigiVW5tYXRjaGVkIHNlbGVjdG9yOiAiK24pO3JldHVybiBpfWZ1bmN0aW9uIG0obixhLGkpe3ZhciBvPVtdLFQ9ITE7ZnVuY3Rpb24gUCgpe3ZhciBRPWEubWF0Y2gocik7aWYoIVEpdGhyb3cgbmV3IEVycm9yKCJFeHBlY3RlZCBuYW1lLCBmb3VuZCAiK2EpO3ZhciB0dD1RWzBdO3JldHVybiBhPWEuc3Vic3RyKHR0Lmxlbmd0aCkseCh0dCl9ZnVuY3Rpb24gQyhRKXtmb3IoO2IoYS5jaGFyQXQoUSkpOylRKys7YT1hLnN1YnN0cihRKX1mdW5jdGlvbiBJKFEpe2Zvcih2YXIgdHQ9MDthLmNoYXJBdCgtLVEpPT09IlxcIjspdHQrKztyZXR1cm4odHQmMSk9PT0xfWZvcihDKDApO2EhPT0iIjspe3ZhciBBPWEuY2hhckF0KDApO2lmKGIoQSkpVD0hMCxDKDEpO2Vsc2UgaWYoQSBpbiBoKW8ucHVzaCh7dHlwZTpoW0FdfSksVD0hMSxDKDEpO2Vsc2UgaWYoQT09PSIsIil7aWYoby5sZW5ndGg9PT0wKXRocm93IG5ldyBFcnJvcigiRW1wdHkgc3ViLXNlbGVjdG9yIik7bi5wdXNoKG8pLG89W10sVD0hMSxDKDEpfWVsc2UgaWYoVCYmKG8ubGVuZ3RoPjAmJm8ucHVzaCh7dHlwZToiZGVzY2VuZGFudCJ9KSxUPSExKSxBPT09IioiKWE9YS5zdWJzdHIoMSksby5wdXNoKHt0eXBlOiJ1bml2ZXJzYWwifSk7ZWxzZSBpZihBIGluIGwpe3ZhciBMPWxbQV0sRD1MWzBdLFI9TFsxXTthPWEuc3Vic3RyKDEpLG8ucHVzaCh7dHlwZToiYXR0cmlidXRlIixuYW1lOkQsYWN0aW9uOlIsdmFsdWU6UCgpLGlnbm9yZUNhc2U6ITF9KX1lbHNlIGlmKEE9PT0iWyIpe2E9YS5zdWJzdHIoMSk7dmFyIFM9YS5tYXRjaChnKTtpZighUyl0aHJvdyBuZXcgRXJyb3IoIk1hbGZvcm1lZCBhdHRyaWJ1dGUgc2VsZWN0b3I6ICIrYSk7YT1hLnN1YnN0cihTWzBdLmxlbmd0aCk7dmFyIEI9eChTWzFdKTsoIWl8fCgibG93ZXJDYXNlQXR0cmlidXRlTmFtZXMiaW4gaT9pLmxvd2VyQ2FzZUF0dHJpYnV0ZU5hbWVzOiFpLnhtbE1vZGUpKSYmKEI9Qi50b0xvd2VyQ2FzZSgpKSxvLnB1c2goe3R5cGU6ImF0dHJpYnV0ZSIsbmFtZTpCLGFjdGlvbjp2W1NbMl1dLHZhbHVlOngoU1s0XXx8U1s1XXx8IiIpLGlnbm9yZUNhc2U6ISFTWzZdfSl9ZWxzZSBpZihBPT09IjoiKXtpZihhLmNoYXJBdCgxKT09PSI6Iil7YT1hLnN1YnN0cigyKSxvLnB1c2goe3R5cGU6InBzZXVkby1lbGVtZW50IixuYW1lOlAoKS50b0xvd2VyQ2FzZSgpfSk7Y29udGludWV9YT1hLnN1YnN0cigxKTt2YXIgdz1QKCkudG9Mb3dlckNhc2UoKSxTPW51bGw7aWYoYS5jaGFyQXQoMCk9PT0iKCIpaWYodS5oYXModykpe3ZhciBIPWEuY2hhckF0KDEpLEo9Zi5oYXMoSCk7aWYoYT1hLnN1YnN0cihKPzI6MSksUz1bXSxhPW0oUyxhLGkpLEope2lmKGEuY2hhckF0KDApIT09SCl0aHJvdyBuZXcgRXJyb3IoIlVubWF0Y2hlZCBxdW90ZXMgaW4gOiIrdyk7YT1hLnN1YnN0cigxKX1pZihhLmNoYXJBdCgwKSE9PSIpIil0aHJvdyBuZXcgRXJyb3IoIk1pc3NpbmcgY2xvc2luZyBwYXJlbnRoZXNpcyBpbiA6Iit3KyIgKCIrYSsiKSIpO2E9YS5zdWJzdHIoMSl9ZWxzZXtmb3IodmFyIHE9MSxXPTE7Vz4wJiZxPGEubGVuZ3RoO3ErKylhLmNoYXJBdChxKT09PSIoIiYmIUkocSk/VysrOmEuY2hhckF0KHEpPT09IikiJiYhSShxKSYmVy0tO2lmKFcpdGhyb3cgbmV3IEVycm9yKCJQYXJlbnRoZXNpcyBub3QgbWF0Y2hlZCIpO2lmKFM9YS5zdWJzdHIoMSxxLTIpLGE9YS5zdWJzdHIocSksTS5oYXModykpe3ZhciBIPVMuY2hhckF0KDApO0g9PT1TLnNsaWNlKC0xKSYmZi5oYXMoSCkmJihTPVMuc2xpY2UoMSwtMSkpLFM9eChTKX19by5wdXNoKHt0eXBlOiJwc2V1ZG8iLG5hbWU6dyxkYXRhOlN9KX1lbHNlIGlmKHIudGVzdChhKSl7dmFyIEc9UCgpOyghaXx8KCJsb3dlckNhc2VUYWdzImluIGk/aS5sb3dlckNhc2VUYWdzOiFpLnhtbE1vZGUpKSYmKEc9Ry50b0xvd2VyQ2FzZSgpKSxvLnB1c2goe3R5cGU6InRhZyIsbmFtZTpHfSl9ZWxzZSByZXR1cm4gby5sZW5ndGgmJm9bby5sZW5ndGgtMV0udHlwZT09PSJkZXNjZW5kYW50IiYmby5wb3AoKSxwKG4sbyksYX1yZXR1cm4gcChuLG8pLGF9ZnVuY3Rpb24gcChuLGEpe2lmKG4ubGVuZ3RoPjAmJmEubGVuZ3RoPT09MCl0aHJvdyBuZXcgRXJyb3IoIkVtcHR5IHN1Yi1zZWxlY3RvciIpO24ucHVzaChhKX19LGZ1bmN0aW9uKGMsZSx0KXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSk7dmFyIHI9e2VxdWFsczoiIixlbGVtZW50OiJ+IixzdGFydDoiXiIsZW5kOiIkIixhbnk6IioiLG5vdDoiISIsaHlwaGVuOiJ8In07ZnVuY3Rpb24gcyhsKXtyZXR1cm4gbC5tYXAoZykuam9pbigiLCAiKX1lLmRlZmF1bHQ9cztmdW5jdGlvbiBnKGwpe3JldHVybiBsLm1hcCh2KS5qb2luKCIiKX1mdW5jdGlvbiB2KGwpe3N3aXRjaChsLnR5cGUpe2Nhc2UiY2hpbGQiOnJldHVybiIgPiAiO2Nhc2UicGFyZW50IjpyZXR1cm4iIDwgIjtjYXNlInNpYmxpbmciOnJldHVybiIgfiAiO2Nhc2UiYWRqYWNlbnQiOnJldHVybiIgKyAiO2Nhc2UiZGVzY2VuZGFudCI6cmV0dXJuIiAiO2Nhc2UidW5pdmVyc2FsIjpyZXR1cm4iKiI7Y2FzZSJ0YWciOnJldHVybiBsLm5hbWU7Y2FzZSJwc2V1ZG8tZWxlbWVudCI6cmV0dXJuIjo6IitsLm5hbWU7Y2FzZSJwc2V1ZG8iOnJldHVybiBsLmRhdGE9PT1udWxsPyI6IitsLm5hbWU6dHlwZW9mIGwuZGF0YT09InN0cmluZyI/IjoiK2wubmFtZSsiKCIrbC5kYXRhKyIpIjoiOiIrbC5uYW1lKyIoIitzKGwuZGF0YSkrIikiO2Nhc2UiYXR0cmlidXRlIjpyZXR1cm4gbC5hY3Rpb249PT0iZXhpc3RzIj8iWyIrbC5uYW1lKyJdIjpsLm5hbWU9PT0iaWQiJiZsLmFjdGlvbj09PSJlcXVhbHMiJiYhbC5pZ25vcmVDYXNlPyIjIitsLnZhbHVlOmwubmFtZT09PSJjbGFzcyImJmwuYWN0aW9uPT09ImVsZW1lbnQiJiYhbC5pZ25vcmVDYXNlPyIuIitsLnZhbHVlOiJbIitsLm5hbWUrcltsLmFjdGlvbl0rIj0nIitsLnZhbHVlKyInIisobC5pZ25vcmVDYXNlPyJpIjoiIikrIl0iO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKCJVbmtub3duIHR5cGUiKX19ZnVuY3Rpb24gaChsKXtyZXR1cm4gbH19LGZ1bmN0aW9uKGMsZSx0KXtjLmV4cG9ydHM9Zzt2YXIgcj10KDI3OSkscz17X19wcm90b19fOm51bGwsZXhpc3RzOjEwLGVxdWFsczo4LG5vdDo3LHN0YXJ0OjYsZW5kOjYsYW55OjUsaHlwaGVuOjQsZWxlbWVudDo0fTtmdW5jdGlvbiBnKGgpe2Zvcih2YXIgbD1oLm1hcCh2KSx1PTE7dTxoLmxlbmd0aDt1Kyspe3ZhciBNPWxbdV07aWYoIShNPDApKWZvcih2YXIgZj11LTE7Zj49MCYmTTxsW2ZdO2YtLSl7dmFyIHk9aFtmKzFdO2hbZisxXT1oW2ZdLGhbZl09eSxsW2YrMV09bFtmXSxsW2ZdPU19fX1mdW5jdGlvbiB2KGgpe3ZhciBsPXJbaC50eXBlXTtpZihsPT09ci5hdHRyaWJ1dGUpbD1zW2guYWN0aW9uXSxsPT09cy5lcXVhbHMmJmgubmFtZT09PSJpZCImJihsPTkpLGguaWdub3JlQ2FzZSYmKGw+Pj0xKTtlbHNlIGlmKGw9PT1yLnBzZXVkbylpZighaC5kYXRhKWw9MztlbHNlIGlmKGgubmFtZT09PSJoYXMifHxoLm5hbWU9PT0iY29udGFpbnMiKWw9MDtlbHNlIGlmKGgubmFtZT09PSJtYXRjaGVzInx8aC5uYW1lPT09Im5vdCIpe2w9MDtmb3IodmFyIHU9MDt1PGguZGF0YS5sZW5ndGg7dSsrKWlmKGguZGF0YVt1XS5sZW5ndGg9PT0xKXt2YXIgTT12KGguZGF0YVt1XVswXSk7aWYoTT09PTApe2w9MDticmVha31NPmwmJihsPU0pfWguZGF0YS5sZW5ndGg+MSYmbD4wJiYobC09MSl9ZWxzZSBsPTE7cmV0dXJuIGx9fSxmdW5jdGlvbihjKXtjLmV4cG9ydHM9SlNPTi5wYXJzZSgneyJ1bml2ZXJzYWwiOjUwLCJ0YWciOjMwLCJhdHRyaWJ1dGUiOjEsInBzZXVkbyI6MCwiZGVzY2VuZGFudCI6LTEsImNoaWxkIjotMSwicGFyZW50IjotMSwic2libGluZyI6LTEsImFkamFjZW50IjotMX0nKX0sZnVuY3Rpb24oYyxlLHQpe3ZhciByPXQoMjgxKSxzPXQoMjgyKTtjLmV4cG9ydHM9e19fcHJvdG9fXzpudWxsLGF0dHJpYnV0ZTpyLmNvbXBpbGUscHNldWRvOnMuY29tcGlsZSx0YWc6ZnVuY3Rpb24oZyx2LGgpe3ZhciBsPXYubmFtZSx1PWguYWRhcHRlcjtyZXR1cm4gZnVuY3Rpb24oZil7cmV0dXJuIHUuZ2V0TmFtZShmKT09PWwmJmcoZil9fSxkZXNjZW5kYW50OmZ1bmN0aW9uKGcsdixoKXt2YXIgbD10eXBlb2YgV2Vha1NldDwidSI/bmV3IFdlYWtTZXQ6bnVsbCx1PWguYWRhcHRlcjtyZXR1cm4gZnVuY3Rpb24oZil7Zm9yKHZhciB5PSExOyF5JiYoZj11LmdldFBhcmVudChmKSk7KSghbHx8IWwuaGFzKGYpKSYmKHk9ZyhmKSwheSYmbCYmbC5hZGQoZikpO3JldHVybiB5fX0sX2ZsZXhpYmxlRGVzY2VuZGFudDpmdW5jdGlvbihnLHYsaCl7dmFyIGw9aC5hZGFwdGVyO3JldHVybiBmdW5jdGlvbihNKXtmb3IodmFyIGY9ZyhNKTshZiYmKE09bC5nZXRQYXJlbnQoTSkpOylmPWcoTSk7cmV0dXJuIGZ9fSxwYXJlbnQ6ZnVuY3Rpb24oZyx2LGgpe2lmKGgmJmguc3RyaWN0KXRocm93IG5ldyBFcnJvcigiUGFyZW50IHNlbGVjdG9yIGlzbid0IHBhcnQgb2YgQ1NTMyIpO3ZhciBsPWguYWRhcHRlcjtyZXR1cm4gZnVuY3Rpb24oZil7cmV0dXJuIGwuZ2V0Q2hpbGRyZW4oZikuc29tZSh1KX07ZnVuY3Rpb24gdShNKXtyZXR1cm4gbC5pc1RhZyhNKSYmZyhNKX19LGNoaWxkOmZ1bmN0aW9uKGcsdixoKXt2YXIgbD1oLmFkYXB0ZXI7cmV0dXJuIGZ1bmN0aW9uKE0pe3ZhciBmPWwuZ2V0UGFyZW50KE0pO3JldHVybiEhZiYmZyhmKX19LHNpYmxpbmc6ZnVuY3Rpb24oZyx2LGgpe3ZhciBsPWguYWRhcHRlcjtyZXR1cm4gZnVuY3Rpb24oTSl7Zm9yKHZhciBmPWwuZ2V0U2libGluZ3MoTSkseT0wO3k8Zi5sZW5ndGg7eSsrKWlmKGwuaXNUYWcoZlt5XSkpe2lmKGZbeV09PT1NKWJyZWFrO2lmKGcoZlt5XSkpcmV0dXJuITB9cmV0dXJuITF9fSxhZGphY2VudDpmdW5jdGlvbihnLHYsaCl7dmFyIGw9aC5hZGFwdGVyO3JldHVybiBmdW5jdGlvbihNKXtmb3IodmFyIGY9bC5nZXRTaWJsaW5ncyhNKSx5LHg9MDt4PGYubGVuZ3RoO3grKylpZihsLmlzVGFnKGZbeF0pKXtpZihmW3hdPT09TSlicmVhazt5PWZbeF19cmV0dXJuISF5JiZnKHkpfX0sdW5pdmVyc2FsOmZ1bmN0aW9uKGcpe3JldHVybiBnfX19LGZ1bmN0aW9uKGMsZSx0KXt2YXIgcj10KDI3MykuZmFsc2VGdW5jLHM9L1stW1xde30oKSorPy4sXFxeJHwjXHNdL2csZz17X19wcm90b19fOm51bGwsZXF1YWxzOmZ1bmN0aW9uKHYsaCxsKXt2YXIgdT1oLm5hbWUsTT1oLnZhbHVlLGY9bC5hZGFwdGVyO3JldHVybiBoLmlnbm9yZUNhc2U/KE09TS50b0xvd2VyQ2FzZSgpLGZ1bmN0aW9uKHgpe3ZhciBiPWYuZ2V0QXR0cmlidXRlVmFsdWUoeCx1KTtyZXR1cm4gYiE9bnVsbCYmYi50b0xvd2VyQ2FzZSgpPT09TSYmdih4KX0pOmZ1bmN0aW9uKHgpe3JldHVybiBmLmdldEF0dHJpYnV0ZVZhbHVlKHgsdSk9PT1NJiZ2KHgpfX0saHlwaGVuOmZ1bmN0aW9uKHYsaCxsKXt2YXIgdT1oLm5hbWUsTT1oLnZhbHVlLGY9TS5sZW5ndGgseT1sLmFkYXB0ZXI7cmV0dXJuIGguaWdub3JlQ2FzZT8oTT1NLnRvTG93ZXJDYXNlKCksZnVuY3Rpb24oYil7dmFyIE89eS5nZXRBdHRyaWJ1dGVWYWx1ZShiLHUpO3JldHVybiBPIT1udWxsJiYoTy5sZW5ndGg9PT1mfHxPLmNoYXJBdChmKT09PSItIikmJk8uc3Vic3RyKDAsZikudG9Mb3dlckNhc2UoKT09PU0mJnYoYil9KTpmdW5jdGlvbihiKXt2YXIgTz15LmdldEF0dHJpYnV0ZVZhbHVlKGIsdSk7cmV0dXJuIE8hPW51bGwmJk8uc3Vic3RyKDAsZik9PT1NJiYoTy5sZW5ndGg9PT1mfHxPLmNoYXJBdChmKT09PSItIikmJnYoYil9fSxlbGVtZW50OmZ1bmN0aW9uKHYsaCxsKXt2YXIgdT1oLm5hbWUsTT1oLnZhbHVlLGY9bC5hZGFwdGVyO2lmKC9ccy8udGVzdChNKSlyZXR1cm4gcjtNPU0ucmVwbGFjZShzLCJcXCQmIik7dmFyIHk9Iig/Ol58XFxzKSIrTSsiKD86JHxcXHMpIix4PWguaWdub3JlQ2FzZT8iaSI6IiIsYj1uZXcgUmVnRXhwKHkseCk7cmV0dXJuIGZ1bmN0aW9uKG0pe3ZhciBwPWYuZ2V0QXR0cmlidXRlVmFsdWUobSx1KTtyZXR1cm4gcCE9bnVsbCYmYi50ZXN0KHApJiZ2KG0pfX0sZXhpc3RzOmZ1bmN0aW9uKHYsaCxsKXt2YXIgdT1oLm5hbWUsTT1sLmFkYXB0ZXI7cmV0dXJuIGZ1bmN0aW9uKHkpe3JldHVybiBNLmhhc0F0dHJpYih5LHUpJiZ2KHkpfX0sc3RhcnQ6ZnVuY3Rpb24odixoLGwpe3ZhciB1PWgubmFtZSxNPWgudmFsdWUsZj1NLmxlbmd0aCx5PWwuYWRhcHRlcjtyZXR1cm4gZj09PTA/cjpoLmlnbm9yZUNhc2U/KE09TS50b0xvd2VyQ2FzZSgpLGZ1bmN0aW9uKGIpe3ZhciBPPXkuZ2V0QXR0cmlidXRlVmFsdWUoYix1KTtyZXR1cm4gTyE9bnVsbCYmTy5zdWJzdHIoMCxmKS50b0xvd2VyQ2FzZSgpPT09TSYmdihiKX0pOmZ1bmN0aW9uKGIpe3ZhciBPPXkuZ2V0QXR0cmlidXRlVmFsdWUoYix1KTtyZXR1cm4gTyE9bnVsbCYmTy5zdWJzdHIoMCxmKT09PU0mJnYoYil9fSxlbmQ6ZnVuY3Rpb24odixoLGwpe3ZhciB1PWgubmFtZSxNPWgudmFsdWUsZj0tTS5sZW5ndGgseT1sLmFkYXB0ZXI7cmV0dXJuIGY9PT0wP3I6aC5pZ25vcmVDYXNlPyhNPU0udG9Mb3dlckNhc2UoKSxmdW5jdGlvbihiKXt2YXIgTz15LmdldEF0dHJpYnV0ZVZhbHVlKGIsdSk7cmV0dXJuIE8hPW51bGwmJk8uc3Vic3RyKGYpLnRvTG93ZXJDYXNlKCk9PT1NJiZ2KGIpfSk6ZnVuY3Rpb24oYil7dmFyIE89eS5nZXRBdHRyaWJ1dGVWYWx1ZShiLHUpO3JldHVybiBPIT1udWxsJiZPLnN1YnN0cihmKT09PU0mJnYoYil9fSxhbnk6ZnVuY3Rpb24odixoLGwpe3ZhciB1PWgubmFtZSxNPWgudmFsdWUsZj1sLmFkYXB0ZXI7aWYoTT09PSIiKXJldHVybiByO2lmKGguaWdub3JlQ2FzZSl7dmFyIHk9bmV3IFJlZ0V4cChNLnJlcGxhY2UocywiXFwkJiIpLCJpIik7cmV0dXJuIGZ1bmN0aW9uKGIpe3ZhciBPPWYuZ2V0QXR0cmlidXRlVmFsdWUoYix1KTtyZXR1cm4gTyE9bnVsbCYmeS50ZXN0KE8pJiZ2KGIpfX1yZXR1cm4gZnVuY3Rpb24oYil7dmFyIE89Zi5nZXRBdHRyaWJ1dGVWYWx1ZShiLHUpO3JldHVybiBPIT1udWxsJiZPLmluZGV4T2YoTSk+PTAmJnYoYil9fSxub3Q6ZnVuY3Rpb24odixoLGwpe3ZhciB1PWgubmFtZSxNPWgudmFsdWUsZj1sLmFkYXB0ZXI7cmV0dXJuIE09PT0iIj9mdW5jdGlvbih4KXtyZXR1cm4hIWYuZ2V0QXR0cmlidXRlVmFsdWUoeCx1KSYmdih4KX06aC5pZ25vcmVDYXNlPyhNPU0udG9Mb3dlckNhc2UoKSxmdW5jdGlvbih4KXt2YXIgYj1mLmdldEF0dHJpYnV0ZVZhbHVlKHgsdSk7cmV0dXJuIGIhPW51bGwmJmIudG9Mb3dlckNhc2UoKSE9PU0mJnYoeCl9KTpmdW5jdGlvbih4KXtyZXR1cm4gZi5nZXRBdHRyaWJ1dGVWYWx1ZSh4LHUpIT09TSYmdih4KX19fTtjLmV4cG9ydHM9e2NvbXBpbGU6ZnVuY3Rpb24odixoLGwpe2lmKGwmJmwuc3RyaWN0JiYoaC5pZ25vcmVDYXNlfHxoLmFjdGlvbj09PSJub3QiKSl0aHJvdyBuZXcgRXJyb3IoIlVuc3VwcG9ydGVkIGF0dHJpYnV0ZSBzZWxlY3RvciIpO3JldHVybiBnW2guYWN0aW9uXSh2LGgsbCl9LHJ1bGVzOmd9fSxmdW5jdGlvbihjLGUsdCl7dmFyIHI9dCgyODMpLHM9dCgyNzMpLGc9dCgyODEpLHY9cy50cnVlRnVuYyxoPXMuZmFsc2VGdW5jLGw9Zy5ydWxlcy5lcXVhbHM7ZnVuY3Rpb24gdShwLG4pe3ZhciBhPXtuYW1lOnAsdmFsdWU6bn07cmV0dXJuIGZ1bmN0aW9uKG8sVCxQKXtyZXR1cm4gbChvLGEsUCl9fWZ1bmN0aW9uIE0ocCxuKXtyZXR1cm4gZnVuY3Rpb24oYSl7cmV0dXJuISFuLmdldFBhcmVudChhKSYmcChhKX19dmFyIGY9e2NvbnRhaW5zOmZ1bmN0aW9uKHAsbixhKXt2YXIgaT1hLmFkYXB0ZXI7cmV0dXJuIGZ1bmN0aW9uKFQpe3JldHVybiBwKFQpJiZpLmdldFRleHQoVCkuaW5kZXhPZihuKT49MH19LGljb250YWluczpmdW5jdGlvbihwLG4sYSl7dmFyIGk9bi50b0xvd2VyQ2FzZSgpLG89YS5hZGFwdGVyO3JldHVybiBmdW5jdGlvbihQKXtyZXR1cm4gcChQKSYmby5nZXRUZXh0KFApLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihpKT49MH19LCJudGgtY2hpbGQiOmZ1bmN0aW9uKHAsbixhKXt2YXIgaT1yKG4pLG89YS5hZGFwdGVyO3JldHVybiBpPT09aD9pOmk9PT12P00ocCxvKTpmdW5jdGlvbihQKXtmb3IodmFyIEM9by5nZXRTaWJsaW5ncyhQKSxJPTAsQT0wO0k8Qy5sZW5ndGg7SSsrKWlmKG8uaXNUYWcoQ1tJXSkpe2lmKENbSV09PT1QKWJyZWFrO0ErK31yZXR1cm4gaShBKSYmcChQKX19LCJudGgtbGFzdC1jaGlsZCI6ZnVuY3Rpb24ocCxuLGEpe3ZhciBpPXIobiksbz1hLmFkYXB0ZXI7cmV0dXJuIGk9PT1oP2k6aT09PXY/TShwLG8pOmZ1bmN0aW9uKFApe2Zvcih2YXIgQz1vLmdldFNpYmxpbmdzKFApLEk9MCxBPUMubGVuZ3RoLTE7QT49MDtBLS0paWYoby5pc1RhZyhDW0FdKSl7aWYoQ1tBXT09PVApYnJlYWs7SSsrfXJldHVybiBpKEkpJiZwKFApfX0sIm50aC1vZi10eXBlIjpmdW5jdGlvbihwLG4sYSl7dmFyIGk9cihuKSxvPWEuYWRhcHRlcjtyZXR1cm4gaT09PWg/aTppPT09dj9NKHAsbyk6ZnVuY3Rpb24oUCl7Zm9yKHZhciBDPW8uZ2V0U2libGluZ3MoUCksST0wLEE9MDtBPEMubGVuZ3RoO0ErKylpZihvLmlzVGFnKENbQV0pKXtpZihDW0FdPT09UClicmVhaztvLmdldE5hbWUoQ1tBXSk9PT1vLmdldE5hbWUoUCkmJkkrK31yZXR1cm4gaShJKSYmcChQKX19LCJudGgtbGFzdC1vZi10eXBlIjpmdW5jdGlvbihwLG4sYSl7dmFyIGk9cihuKSxvPWEuYWRhcHRlcjtyZXR1cm4gaT09PWg/aTppPT09dj9NKHAsbyk6ZnVuY3Rpb24oUCl7Zm9yKHZhciBDPW8uZ2V0U2libGluZ3MoUCksST0wLEE9Qy5sZW5ndGgtMTtBPj0wO0EtLSlpZihvLmlzVGFnKENbQV0pKXtpZihDW0FdPT09UClicmVhaztvLmdldE5hbWUoQ1tBXSk9PT1vLmdldE5hbWUoUCkmJkkrK31yZXR1cm4gaShJKSYmcChQKX19LHJvb3Q6ZnVuY3Rpb24ocCxuLGEpe3ZhciBpPWEuYWRhcHRlcjtyZXR1cm4gZnVuY3Rpb24obyl7cmV0dXJuIWkuZ2V0UGFyZW50KG8pJiZwKG8pfX0sc2NvcGU6ZnVuY3Rpb24ocCxuLGEsaSl7dmFyIG89YS5hZGFwdGVyO2lmKCFpfHxpLmxlbmd0aD09PTApcmV0dXJuIGYucm9vdChwLG4sYSk7ZnVuY3Rpb24gVChQLEMpe3JldHVybiB0eXBlb2Ygby5lcXVhbHM9PSJmdW5jdGlvbiI/by5lcXVhbHMoUCxDKTpQPT09Q31yZXR1cm4gaS5sZW5ndGg9PT0xP2Z1bmN0aW9uKFApe3JldHVybiBUKGlbMF0sUCkmJnAoUCl9OmZ1bmN0aW9uKFApe3JldHVybiBpLmluZGV4T2YoUCk+PTAmJnAoUCl9fSxjaGVja2JveDp1KCJ0eXBlIiwiY2hlY2tib3giKSxmaWxlOnUoInR5cGUiLCJmaWxlIikscGFzc3dvcmQ6dSgidHlwZSIsInBhc3N3b3JkIikscmFkaW86dSgidHlwZSIsInJhZGlvIikscmVzZXQ6dSgidHlwZSIsInJlc2V0IiksaW1hZ2U6dSgidHlwZSIsImltYWdlIiksc3VibWl0OnUoInR5cGUiLCJzdWJtaXQiKSxob3ZlcjpmdW5jdGlvbihwLG4sYSl7dmFyIGk9YS5hZGFwdGVyO3JldHVybiB0eXBlb2YgaS5pc0hvdmVyZWQ9PSJmdW5jdGlvbiI/ZnVuY3Rpb24oVCl7cmV0dXJuIHAoVCkmJmkuaXNIb3ZlcmVkKFQpfTpofSx2aXNpdGVkOmZ1bmN0aW9uKHAsbixhKXt2YXIgaT1hLmFkYXB0ZXI7cmV0dXJuIHR5cGVvZiBpLmlzVmlzaXRlZD09ImZ1bmN0aW9uIj9mdW5jdGlvbihUKXtyZXR1cm4gcChUKSYmaS5pc1Zpc2l0ZWQoVCl9Omh9LGFjdGl2ZTpmdW5jdGlvbihwLG4sYSl7dmFyIGk9YS5hZGFwdGVyO3JldHVybiB0eXBlb2YgaS5pc0FjdGl2ZT09ImZ1bmN0aW9uIj9mdW5jdGlvbihUKXtyZXR1cm4gcChUKSYmaS5pc0FjdGl2ZShUKX06aH19O2Z1bmN0aW9uIHkocCxuKXtmb3IodmFyIGE9MDtwJiZhPHAubGVuZ3RoO2ErKylpZihuLmlzVGFnKHBbYV0pKXJldHVybiBwW2FdfXZhciB4PXtlbXB0eTpmdW5jdGlvbihwLG4pe3JldHVybiFuLmdldENoaWxkcmVuKHApLnNvbWUoZnVuY3Rpb24oYSl7cmV0dXJuIG4uaXNUYWcoYSl8fGEudHlwZT09PSJ0ZXh0In0pfSwiZmlyc3QtY2hpbGQiOmZ1bmN0aW9uKHAsbil7cmV0dXJuIHkobi5nZXRTaWJsaW5ncyhwKSxuKT09PXB9LCJsYXN0LWNoaWxkIjpmdW5jdGlvbihwLG4pe2Zvcih2YXIgYT1uLmdldFNpYmxpbmdzKHApLGk9YS5sZW5ndGgtMTtpPj0wO2ktLSl7aWYoYVtpXT09PXApcmV0dXJuITA7aWYobi5pc1RhZyhhW2ldKSlicmVha31yZXR1cm4hMX0sImZpcnN0LW9mLXR5cGUiOmZ1bmN0aW9uKHAsbil7Zm9yKHZhciBhPW4uZ2V0U2libGluZ3MocCksaT0wO2k8YS5sZW5ndGg7aSsrKWlmKG4uaXNUYWcoYVtpXSkpe2lmKGFbaV09PT1wKXJldHVybiEwO2lmKG4uZ2V0TmFtZShhW2ldKT09PW4uZ2V0TmFtZShwKSlicmVha31yZXR1cm4hMX0sImxhc3Qtb2YtdHlwZSI6ZnVuY3Rpb24ocCxuKXtmb3IodmFyIGE9bi5nZXRTaWJsaW5ncyhwKSxpPWEubGVuZ3RoLTE7aT49MDtpLS0paWYobi5pc1RhZyhhW2ldKSl7aWYoYVtpXT09PXApcmV0dXJuITA7aWYobi5nZXROYW1lKGFbaV0pPT09bi5nZXROYW1lKHApKWJyZWFrfXJldHVybiExfSwib25seS1vZi10eXBlIjpmdW5jdGlvbihwLG4pe2Zvcih2YXIgYT1uLmdldFNpYmxpbmdzKHApLGk9MCxvPWEubGVuZ3RoO2k8bztpKyspaWYobi5pc1RhZyhhW2ldKSl7aWYoYVtpXT09PXApY29udGludWU7aWYobi5nZXROYW1lKGFbaV0pPT09bi5nZXROYW1lKHApKXJldHVybiExfXJldHVybiEwfSwib25seS1jaGlsZCI6ZnVuY3Rpb24ocCxuKXtmb3IodmFyIGE9bi5nZXRTaWJsaW5ncyhwKSxpPTA7aTxhLmxlbmd0aDtpKyspaWYobi5pc1RhZyhhW2ldKSYmYVtpXSE9PXApcmV0dXJuITE7cmV0dXJuITB9LGxpbms6ZnVuY3Rpb24ocCxuKXtyZXR1cm4gbi5oYXNBdHRyaWIocCwiaHJlZiIpfSxzZWxlY3RlZDpmdW5jdGlvbihwLG4pe2lmKG4uaGFzQXR0cmliKHAsInNlbGVjdGVkIikpcmV0dXJuITA7aWYobi5nZXROYW1lKHApIT09Im9wdGlvbiIpcmV0dXJuITE7dmFyIGE9bi5nZXRQYXJlbnQocCk7aWYoIWF8fG4uZ2V0TmFtZShhKSE9PSJzZWxlY3QifHxuLmhhc0F0dHJpYihhLCJtdWx0aXBsZSIpKXJldHVybiExO2Zvcih2YXIgaT1uLmdldENoaWxkcmVuKGEpLG89ITEsVD0wO1Q8aS5sZW5ndGg7VCsrKWlmKG4uaXNUYWcoaVtUXSkpaWYoaVtUXT09PXApbz0hMDtlbHNlIGlmKG8pe2lmKG4uaGFzQXR0cmliKGlbVF0sInNlbGVjdGVkIikpcmV0dXJuITF9ZWxzZSByZXR1cm4hMTtyZXR1cm4gb30sZGlzYWJsZWQ6ZnVuY3Rpb24ocCxuKXtyZXR1cm4gbi5oYXNBdHRyaWIocCwiZGlzYWJsZWQiKX0sZW5hYmxlZDpmdW5jdGlvbihwLG4pe3JldHVybiFuLmhhc0F0dHJpYihwLCJkaXNhYmxlZCIpfSxjaGVja2VkOmZ1bmN0aW9uKHAsbil7cmV0dXJuIG4uaGFzQXR0cmliKHAsImNoZWNrZWQiKXx8eC5zZWxlY3RlZChwLG4pfSxyZXF1aXJlZDpmdW5jdGlvbihwLG4pe3JldHVybiBuLmhhc0F0dHJpYihwLCJyZXF1aXJlZCIpfSxvcHRpb25hbDpmdW5jdGlvbihwLG4pe3JldHVybiFuLmhhc0F0dHJpYihwLCJyZXF1aXJlZCIpfSxwYXJlbnQ6ZnVuY3Rpb24ocCxuKXtyZXR1cm4heC5lbXB0eShwLG4pfSxoZWFkZXI6YihbImgxIiwiaDIiLCJoMyIsImg0IiwiaDUiLCJoNiJdKSxidXR0b246ZnVuY3Rpb24ocCxuKXt2YXIgYT1uLmdldE5hbWUocCk7cmV0dXJuIGE9PT0iYnV0dG9uInx8YT09PSJpbnB1dCImJm4uZ2V0QXR0cmlidXRlVmFsdWUocCwidHlwZSIpPT09ImJ1dHRvbiJ9LGlucHV0OmIoWyJpbnB1dCIsInRleHRhcmVhIiwic2VsZWN0IiwiYnV0dG9uIl0pLHRleHQ6ZnVuY3Rpb24ocCxuKXt2YXIgYTtyZXR1cm4gbi5nZXROYW1lKHApPT09ImlucHV0IiYmKCEoYT1uLmdldEF0dHJpYnV0ZVZhbHVlKHAsInR5cGUiKSl8fGEudG9Mb3dlckNhc2UoKT09PSJ0ZXh0Iil9fTtmdW5jdGlvbiBiKHApe2lmKHR5cGVvZiBTZXQ8InUiKXt2YXIgbj1uZXcgU2V0KHApO3JldHVybiBmdW5jdGlvbihhLGkpe3JldHVybiBuLmhhcyhpLmdldE5hbWUoYSkpfX1yZXR1cm4gZnVuY3Rpb24oYSxpKXtyZXR1cm4gcC5pbmRleE9mKGkuZ2V0TmFtZShhKSk+PTB9fWZ1bmN0aW9uIE8ocCxuLGEpe2lmKGE9PT1udWxsKXtpZihwLmxlbmd0aD4yJiZuIT09InNjb3BlIil0aHJvdyBuZXcgRXJyb3IoInBzZXVkby1zZWxlY3RvciA6IituKyIgcmVxdWlyZXMgYW4gYXJndW1lbnQiKX1lbHNlIGlmKHAubGVuZ3RoPT09Mil0aHJvdyBuZXcgRXJyb3IoInBzZXVkby1zZWxlY3RvciA6IituKyIgZG9lc24ndCBoYXZlIGFueSBhcmd1bWVudHMiKX12YXIgbT0vXig/Oig/Om50aHxsYXN0fGZpcnN0fG9ubHkpLSg/OmNoaWxkfG9mLXR5cGUpfHJvb3R8ZW1wdHl8KD86ZW58ZGlzKWFibGVkfGNoZWNrZWR8bm90KSQvO2MuZXhwb3J0cz17Y29tcGlsZTpmdW5jdGlvbihwLG4sYSxpKXt2YXIgbz1uLm5hbWUsVD1uLmRhdGEsUD1hLmFkYXB0ZXI7aWYoYSYmYS5zdHJpY3QmJiFtLnRlc3QobykpdGhyb3cgbmV3IEVycm9yKCI6IitvKyIgaXNuJ3QgcGFydCBvZiBDU1MzIik7aWYodHlwZW9mIGZbb109PSJmdW5jdGlvbiIpcmV0dXJuIGZbb10ocCxULGEsaSk7aWYodHlwZW9mIHhbb109PSJmdW5jdGlvbiIpe3ZhciBDPXhbb107cmV0dXJuIE8oQyxvLFQpLEM9PT1oP0M6cD09PXY/ZnVuY3Rpb24oQSl7cmV0dXJuIEMoQSxQLFQpfTpmdW5jdGlvbihBKXtyZXR1cm4gQyhBLFAsVCkmJnAoQSl9fWVsc2UgdGhyb3cgbmV3IEVycm9yKCJ1bm1hdGNoZWQgcHNldWRvLWNsYXNzIDoiK28pfSxmaWx0ZXJzOmYscHNldWRvczp4fX0sZnVuY3Rpb24oYyxlLHQpe3ZhciByPXQoMjg0KSxzPXQoMjg1KTtjLmV4cG9ydHM9ZnVuY3Rpb24odil7cmV0dXJuIHMocih2KSl9LGMuZXhwb3J0cy5wYXJzZT1yLGMuZXhwb3J0cy5jb21waWxlPXN9LGZ1bmN0aW9uKGMsZSl7Yy5leHBvcnRzPXI7dmFyIHQ9L14oWytcLV0/XGQqbik/XHMqKD86KFsrXC1dPylccyooXGQrKSk/JC87ZnVuY3Rpb24gcihzKXtpZihzPXMudHJpbSgpLnRvTG93ZXJDYXNlKCkscz09PSJldmVuIilyZXR1cm5bMiwwXTtpZihzPT09Im9kZCIpcmV0dXJuWzIsMV07dmFyIGc9cy5tYXRjaCh0KTtpZighZyl0aHJvdyBuZXcgU3ludGF4RXJyb3IoIm4tdGggcnVsZSBjb3VsZG4ndCBiZSBwYXJzZWQgKCciK3MrIicpIik7dmFyIHY7cmV0dXJuIGdbMV0/KHY9cGFyc2VJbnQoZ1sxXSwxMCksaXNOYU4odikmJihnWzFdLmNoYXJBdCgwKT09PSItIj92PS0xOnY9MSkpOnY9MCxbdixnWzNdP3BhcnNlSW50KChnWzJdfHwiIikrZ1szXSwxMCk6MF19fSxmdW5jdGlvbihjLGUsdCl7Yy5leHBvcnRzPXY7dmFyIHI9dCgyNzMpLHM9ci50cnVlRnVuYyxnPXIuZmFsc2VGdW5jO2Z1bmN0aW9uIHYoaCl7dmFyIGw9aFswXSx1PWhbMV0tMTtpZih1PDAmJmw8PTApcmV0dXJuIGc7aWYobD09PS0xKXJldHVybiBmdW5jdGlvbihmKXtyZXR1cm4gZjw9dX07aWYobD09PTApcmV0dXJuIGZ1bmN0aW9uKGYpe3JldHVybiBmPT09dX07aWYobD09PTEpcmV0dXJuIHU8MD9zOmZ1bmN0aW9uKGYpe3JldHVybiBmPj11fTt2YXIgTT11JWw7cmV0dXJuIE08MCYmKE0rPWwpLGw+MT9mdW5jdGlvbihmKXtyZXR1cm4gZj49dSYmZiVsPT09TX06KGwqPS0xLGZ1bmN0aW9uKGYpe3JldHVybiBmPD11JiZmJWw9PT1NfSl9fSxmdW5jdGlvbihjLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBUfSk7dmFyIHI9dCgxMikscz10KDc0KSxnPXQoMSksdj10KDY4KSxoPXQoMjUwKSxsPXQoMjEzKSx1PXQoMjE4KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gTShQLEMpe2lmKFA9PW51bGwpcmV0dXJue307dmFyIEk9ZihQLEMpLEEsTDtpZihPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKXt2YXIgRD1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKFApO2ZvcihMPTA7TDxELmxlbmd0aDtMKyspQT1EW0xdLCEoQy5pbmRleE9mKEEpPj0wKSYmT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKFAsQSkmJihJW0FdPVBbQV0pfXJldHVybiBJfWZ1bmN0aW9uIGYoUCxDKXtpZihQPT1udWxsKXJldHVybnt9O3ZhciBJPXt9LEE9T2JqZWN0LmtleXMoUCksTCxEO2ZvcihEPTA7RDxBLmxlbmd0aDtEKyspTD1BW0RdLCEoQy5pbmRleE9mKEwpPj0wKSYmKElbTF09UFtMXSk7cmV0dXJuIEl9Y29uc3QgeT17YW50aWFsaWFzOiEwLGF1dG9SZW5kZXI6ITAsYWxwaGE6ITB9LHg9U3ltYm9sKCJhdXRvUmVuZGVyIiksYj1TeW1ib2woInJlbmRlcmVyIiksTz1TeW1ib2woInRpbWVsaW5lIiksbT1TeW1ib2woInByZXBhcmVSZW5kZXIiKSxwPVN5bWJvbCgidGlja1JlbmRlciIpLG49U3ltYm9sKCJwYXNzIiksYT1TeW1ib2woImZibyIpLGk9U3ltYm9sKCJ0aWNrZXJzIiksbz1TeW1ib2woImxheWVyVHJhbnNmb3JtSW52ZXJ0Iik7Y2xhc3MgVCBleHRlbmRzIGguZGVmYXVsdHtjb25zdHJ1Y3RvcihDPXt9KXtpZihzdXBlcigpLCFDLmNhbnZhcyl7Y29uc3R7d2lkdGg6RCxoZWlnaHQ6Un09dGhpcy5nZXRSZXNvbHV0aW9uKCksUz1yLkVOVi5jcmVhdGVDYW52YXMoRCxSLHtvZmZzY3JlZW46ISFDLm9mZnNjcmVlbixpZDpDLmlkLGV4dHJhOkMuZXh0cmF9KTtTLnN0eWxlJiYoUy5zdHlsZS5wb3NpdGlvbj0iYWJzb2x1dGUiKSxTLmRhdGFzZXQmJihTLmRhdGFzZXQubGF5ZXJJZD1DLmlkKSxTLmNvbnRleHRUeXBlJiYoQy5jb250ZXh0VHlwZT1TLmNvbnRleHRUeXBlKSxDLmNhbnZhcz1TfWNvbnN0IEk9Qy5jYW52YXMsQT1PYmplY3QuYXNzaWduKHt9LHksQyk7dGhpc1t4XT1BLmF1dG9SZW5kZXIsZGVsZXRlIEMuYXV0b1JlbmRlcjtjb25zdCBMPUEuUmVuZGVyZXJ8fHIuUmVuZGVyZXI7dGhpc1tiXT1uZXcgTChJLEEpLHRoaXMub3B0aW9ucz1DLHRoaXMuaWQ9Qy5pZCx0aGlzW25dPVtdLHRoaXMuc2V0UmVzb2x1dGlvbihJKSx0aGlzLmNhbnZhcz1JLHRoaXNbT109bmV3IHMuVGltZWxpbmUsdGhpcy5fX21vdXNlQ2FwdHVyZWRUYXJnZXQ9bnVsbCx0aGlzW29dPW51bGx9Z2V0IGF1dG9SZW5kZXIoKXtyZXR1cm4gdGhpc1t4XX1nZXQgZGlzcGxheVJhdGlvKCl7cmV0dXJuIHRoaXMucGFyZW50JiZ0aGlzLnBhcmVudC5vcHRpb25zP3RoaXMucGFyZW50Lm9wdGlvbnMuZGlzcGxheVJhdGlvOjF9Z2V0IGhlaWdodCgpe2NvbnN0e2hlaWdodDpDfT10aGlzLmdldFJlc29sdXRpb24oKTtyZXR1cm4gQy90aGlzLmRpc3BsYXlSYXRpb31nZXQgZ2woKXtyZXR1cm4gdGhpcy5yZW5kZXJlci5nbFJlbmRlcmVyP3RoaXMucmVuZGVyZXIuZ2xSZW5kZXJlci5nbDpudWxsfWdldCBsYXllcigpe3JldHVybiB0aGlzfWdldCBvZmZzY3JlZW4oKXtyZXR1cm4hIXRoaXMub3B0aW9ucy5vZmZzY3JlZW58fHRoaXMuY2FudmFzLl9vZmZzY3JlZW59Z2V0IHBhc3MoKXtyZXR1cm4gdGhpc1tuXX1nZXQgcHJlcGFyZVJlbmRlcigpe3JldHVybiB0aGlzW21dP3RoaXNbbV06UHJvbWlzZS5yZXNvbHZlKCl9Z2V0IHJlbmRlcmVyKCl7cmV0dXJuIHRoaXNbYl19Z2V0IHJlbmRlck9mZnNldCgpe2lmKHRoaXMucGFyZW50JiZ0aGlzLnBhcmVudC5vcHRpb25zKXtjb25zdHtsZWZ0OkMsdG9wOkl9PXRoaXMucGFyZW50Lm9wdGlvbnM7cmV0dXJuW0MsSV19cmV0dXJuW3RoaXMub3B0aW9ucy5sZWZ0fDAsdGhpcy5vcHRpb25zLnRvcHwwXX1nZXQgdGltZWxpbmUoKXtyZXR1cm4gdGhpc1tPXX1nZXQgd2lkdGgoKXtjb25zdHt3aWR0aDpDfT10aGlzLmdldFJlc29sdXRpb24oKTtyZXR1cm4gQy90aGlzLmRpc3BsYXlSYXRpb31nZXQgbG9jYWxNYXRyaXgoKXtjb25zdHt4OkMseTpJfT10aGlzLmF0dHJpYnV0ZXM7cmV0dXJuWzEsMCwwLDEsQyxJXX1nZXQgbGF5ZXJUcmFuc2Zvcm1JbnZlcnQoKXtpZih0aGlzW29dKXJldHVybiB0aGlzW29dO2NvbnN0IEM9dGhpcy50cmFuc2Zvcm1NYXRyaXg7cmV0dXJuIENbMF09PT0xJiZDWzFdPT09MCYmQ1syXT09PTAmJkNbM109PT0xJiZDWzRdPT09MCYmQ1s1XT09PTA/bnVsbDoodGhpc1tvXT1nLm1hdDJkLmludmVydChBcnJheS5vZigwLDAsMCwwLDAsMCksQyksdGhpc1tvXSl9Zm9yY2VDb250ZXh0TG9zcygpe2NvbnN0IEM9dGhpcy5yZW5kZXJlci5nbFJlbmRlcmVyO2lmKEMpe2NvbnN0IEk9Qy5nZXRFeHRlbnNpb24oIldFQkdMX2xvc2VfY29udGV4dCIpO2lmKEkpcmV0dXJuIEkubG9zZUNvbnRleHQoKSwhMH1yZXR1cm4hMX1hZGRQYXNzKHt2ZXJ0ZXg6QyxmcmFnbWVudDpJLG9wdGlvbnM6QSx1bmlmb3JtczpMfT17fSl7aWYodGhpcy5yZW5kZXJlci5nbFJlbmRlcmVyKXtjb25zdHt3aWR0aDpELGhlaWdodDpSfT10aGlzLmdldFJlc29sdXRpb24oKSxTPXRoaXMucmVuZGVyZXIuY3JlYXRlUGFzc1Byb2dyYW0oe3ZlcnRleDpDLGZyYWdtZW50Okksb3B0aW9uczpBfSksQj1uZXcgci5GaWd1cmUyRDtCLnJlY3QoMCwwLEQvdGhpcy5kaXNwbGF5UmF0aW8sUi90aGlzLmRpc3BsYXlSYXRpbyk7Y29uc3Qgdz1uZXcgci5NZXNoMkQoQik7cmV0dXJuIHcuc2V0VW5pZm9ybXMoTCksdy5zZXRQcm9ncmFtKFMpLHRoaXNbbl0ucHVzaCh3KSx0aGlzLmZvcmNlVXBkYXRlKCksd31yZXR1cm4gbnVsbH1kZWxldGVUZXh0dXJlKEMpe3JldHVybiBPYmplY3QodS5kZWxldGVUZXh0dXJlKShDLHRoaXMucmVuZGVyZXIpfWRpc3BhdGNoUG9pbnRlckV2ZW50KEMpe2NvbnN0IEk9Qy50eXBlO2lmKEk9PT0ibW91c2Vkb3duInx8ST09PSJtb3VzZXVwInx8ST09PSJtb3VzZW1vdmUiKXtjb25zdCBTPXRoaXMuX19tb3VzZUNhcHR1cmVkVGFyZ2V0O2lmKFMpe2lmKFMubGF5ZXI9PT10aGlzKXJldHVybiBTLmRpc3BhdGNoRXZlbnQoQyksITA7dGhpcy5fX21vdXNlQ2FwdHVyZWRUYXJnZXQ9bnVsbH19bGV0IEEsTDtjb25zdCBEPXRoaXMubGF5ZXJUcmFuc2Zvcm1JbnZlcnQ7aWYoRCl7QT1DLngsTD1DLnk7Y29uc3QgUz1ELEI9U1swXSpBK1NbMl0qTCtTWzRdLHc9U1sxXSpBK1NbM10qTCtTWzVdO2RlbGV0ZSBDLngsZGVsZXRlIEMueSxkZWxldGUgQy5sYXllclgsZGVsZXRlIEMubGF5ZXJZLE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEMse2xheWVyWDp7dmFsdWU6Qixjb25maWd1cmFibGU6ITB9LGxheWVyWTp7dmFsdWU6dyxjb25maWd1cmFibGU6ITB9LHg6e3ZhbHVlOkIsY29uZmlndXJhYmxlOiEwfSx5Ont2YWx1ZTp3LGNvbmZpZ3VyYWJsZTohMH19KX1jb25zdCBSPXN1cGVyLmRpc3BhdGNoUG9pbnRlckV2ZW50KEMpO3JldHVybiBEJiZPYmplY3QuZGVmaW5lUHJvcGVydGllcyhDLHtsYXllclg6e3ZhbHVlOkEsY29uZmlndXJhYmxlOiEwfSxsYXllclk6e3ZhbHVlOkwsY29uZmlndXJhYmxlOiEwfSx4Ont2YWx1ZTpBLGNvbmZpZ3VyYWJsZTohMH0seTp7dmFsdWU6TCxjb25maWd1cmFibGU6ITB9fSksUn1mb3JjZVVwZGF0ZSgpe2lmKCF0aGlzW21dKWlmKHRoaXMucGFyZW50JiZ0aGlzLnBhcmVudC5oYXNPZmZzY3JlZW5DYW52YXMpe3RoaXMucGFyZW50LmZvcmNlVXBkYXRlKCk7bGV0IEM9bnVsbDtjb25zdCBJPW5ldyBQcm9taXNlKEE9PntDPUF9KTtJLl9yZXNvbHZlPUMsdGhpc1ttXT1JfWVsc2V7bGV0IEM9bnVsbCxJPW51bGw7Y29uc3QgQT1uZXcgUHJvbWlzZShMPT57Qz1MLHRoaXNbeF0mJihJPU9iamVjdCh2LnJlcXVlc3RBbmltYXRpb25GcmFtZSkoKCk9PntkZWxldGUgQS5fcmVxdWVzdElELHRoaXMucmVuZGVyKCl9KSl9KTtBLl9yZXNvbHZlPUMsQS5fcmVxdWVzdElEPUksdGhpc1ttXT1BfX1nZXRGQk8oKXtjb25zdCBDPXRoaXMucmVuZGVyZXIuZ2xSZW5kZXJlcix7d2lkdGg6SSxoZWlnaHQ6QX09dGhpcy5nZXRSZXNvbHV0aW9uKCk7cmV0dXJuIEMmJighdGhpc1thXXx8dGhpc1thXS53aWR0aCE9PUl8fHRoaXNbYV0uaGVpZ2h0IT09QSk/KHRoaXNbYV09e3dpZHRoOkksaGVpZ2h0OkEsdGFyZ2V0OkMuY3JlYXRlRkJPKCksYnVmZmVyOkMuY3JlYXRlRkJPKCksc3dhcCgpe1t0aGlzLnRhcmdldCx0aGlzLmJ1ZmZlcl09W3RoaXMuYnVmZmVyLHRoaXMudGFyZ2V0XX19LHRoaXNbYV0pOnRoaXNbYV0/dGhpc1thXTpudWxsfXVwZGF0ZUdsb2JhbFRyYW5zZm9ybSgpe2lmKHRoaXMubGF5ZXJUcmFuc2Zvcm1JbnZlcnQpe2NvbnN0IEM9dGhpcy5yZW5kZXJlcixJPUMuX19nbG9iYWxUcmFuc2Zvcm1NYXRyaXh8fEMuZ2xvYmFsVHJhbnNmb3JtTWF0cml4O0MuX19nbG9iYWxUcmFuc2Zvcm1NYXRyaXg9STtjb25zdCBBPWcubWF0MmQuZnJvbVZhbHVlcygxLDAsMCwxLDAsMCk7Qy5zZXRHbG9iYWxUcmFuc2Zvcm0oLi4uZy5tYXQyZC5tdWx0aXBseShBLEksdGhpcy50cmFuc2Zvcm1NYXRyaXgpKX19b25Qcm9wZXJ0eUNoYW5nZShDLEksQSl7aWYoc3VwZXIub25Qcm9wZXJ0eUNoYW5nZShDLEksQSksQz09PSJ6SW5kZXgiJiYodGhpcy5jYW52YXMuc3R5bGUuekluZGV4PUkpLEM9PT0idHJhbnNmb3JtInx8Qz09PSJ0cmFuc2xhdGUifHxDPT09InJvdGF0ZSJ8fEM9PT0ic2NhbGUifHxDPT09InNrZXciKXtjb25zdCBMPXRoaXNbb107aWYodGhpc1tvXT1udWxsLHRoaXMudXBkYXRlR2xvYmFsVHJhbnNmb3JtKCksTCYmIXRoaXMubGF5ZXJUcmFuc2Zvcm1JbnZlcnQpe2NvbnN0IEQ9dGhpcy5yZW5kZXJlcixSPUQuX19nbG9iYWxUcmFuc2Zvcm1NYXRyaXh8fEQuZ2xvYmFsVHJhbnNmb3JtTWF0cml4O0Quc2V0R2xvYmFsVHJhbnNmb3JtKC4uLlIpfX19X3ByZXBhcmVSZW5kZXJGaW5pc2hlZCgpe3RoaXNbbV0mJih0aGlzW21dLl9yZXF1ZXN0SUQmJk9iamVjdCh2LmNhbmNlbEFuaW1hdGlvbkZyYW1lKSh0aGlzW21dLl9yZXF1ZXN0SUQpLHRoaXNbbV0uX3Jlc29sdmUoKSxkZWxldGUgdGhpc1ttXSl9cmVuZGVyKHtjbGVhcjpDPSEwfT17fSl7Y29uc3QgST10aGlzW25dLmxlbmd0aD90aGlzLmdldEZCTygpOm51bGw7SSYmdGhpcy5yZW5kZXJlci5nbFJlbmRlcmVyLmJpbmRGQk8oSS50YXJnZXQpLEMmJnRoaXNbYl0uY2xlYXIoKTtjb25zdCBBPXRoaXMuZHJhdygpO2lmKEEmJkEubGVuZ3RoJiYodGhpcy5yZW5kZXJlci5kcmF3TWVzaGVzKEEpLHRoaXMuY2FudmFzLmRyYXcmJnRoaXMuY2FudmFzLmRyYXcoKSksSSl7Y29uc3QgTD10aGlzLnJlbmRlcmVyLmdsUmVuZGVyZXIsRD10aGlzW25dLmxlbmd0aCx7d2lkdGg6UixoZWlnaHQ6U309dGhpcy5nZXRSZXNvbHV0aW9uKCksQj1bMCwwLFIvdGhpcy5kaXNwbGF5UmF0aW8sUy90aGlzLmRpc3BsYXlSYXRpb107dGhpc1tuXS5mb3JFYWNoKCh3LEgpPT57dy5ibGVuZD0hMCx3LnNldFRleHR1cmUoSS50YXJnZXQudGV4dHVyZSx7cmVjdDpCfSksSD09PUQtMT9MLmJpbmRGQk8obnVsbCk6KEkuc3dhcCgpLEwuYmluZEZCTyhJLnRhcmdldCkpLHRoaXNbYl0uY2xlYXIoKSx0aGlzLnJlbmRlcmVyLmRyYXdNZXNoZXMoW3ddKX0pfXRoaXMuX3ByZXBhcmVSZW5kZXJGaW5pc2hlZCgpfXNldFJlc29sdXRpb24oe3dpZHRoOkMsaGVpZ2h0Okl9KXtjb25zdCBBPXRoaXMucmVuZGVyZXIsTD1BLl9fZ2xvYmFsVHJhbnNmb3JtTWF0cml4fHxBLmdsb2JhbFRyYW5zZm9ybU1hdHJpeCxEPUxbNF0sUj1MWzVdLFM9TFswXSx7d2lkdGg6QixoZWlnaHQ6d309dGhpcy5nZXRSZXNvbHV0aW9uKCk7KEIhPT1DfHx3IT09SSkmJihzdXBlci5zZXRSZXNvbHV0aW9uKHt3aWR0aDpDLGhlaWdodDpJfSksdGhpcy5jYW52YXMmJih0aGlzLmNhbnZhcy53aWR0aD1DLHRoaXMuY2FudmFzLmhlaWdodD1JLEEudXBkYXRlUmVzb2x1dGlvbiYmQS51cGRhdGVSZXNvbHV0aW9uKCkpLHRoaXMuYXR0cmlidXRlcy5zaXplPVtDLEldLHRoaXNbbl0ubGVuZ3RoJiZ0aGlzW25dLmZvckVhY2goVz0+e2NvbnN0IEc9bmV3IHIuRmlndXJlMkQ7Ry5yZWN0KDAsMCxDL3RoaXMuZGlzcGxheVJhdGlvLEkvdGhpcy5kaXNwbGF5UmF0aW8pLFcuY29udG91cnM9Ry5jb250b3Vyc30pKTtjb25zdFtILEpdPXRoaXMucmVuZGVyT2Zmc2V0LHE9dGhpcy5kaXNwbGF5UmF0aW87KEQhPT1IfHxSIT09Snx8UyE9PXEpJiYoQS5zZXRHbG9iYWxUcmFuc2Zvcm0ocSwwLDAscSxILEopLEEuX19nbG9iYWxUcmFuc2Zvcm1NYXRyaXg9bnVsbCx0aGlzW29dPW51bGwsdGhpcy51cGRhdGVHbG9iYWxUcmFuc2Zvcm0oKSx0aGlzLmZvcmNlVXBkYXRlKCkpfXRpY2soQz1udWxsLEk9e30pe2xldHtkdXJhdGlvbjpBPTEvMH09SSxMPU0oSSxbImR1cmF0aW9uIl0pO2NvbnN0IEQ9dGhpcy50aW1lbGluZS5mb3JrKEwpLFI9dGhpczt0aGlzW2ldPXRoaXNbaV18fFtdLHRoaXNbaV0ucHVzaCh7aGFuZGxlcjpDLGR1cmF0aW9uOkF9KTtjb25zdCBTPSgpPT57bGV0IEI9bnVsbCx3PW51bGw7Y29uc3QgSD0oKT0+e2NvbnN0IEo9dGhpc1tpXS5tYXAoKHtoYW5kbGVyOnEsZHVyYXRpb246V30pPT57Y29uc3QgRz1NYXRoLm1pbigxLEQuY3VycmVudFRpbWUvVyk7cmV0dXJue3ZhbHVlOnE/cShELmN1cnJlbnRUaW1lLEcpOm51bGwscDpHfX0pO1JbcF18fChSW3BdPVByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCk9PntSW3hdJiZSLnJlbmRlcigpLGRlbGV0ZSBSW3BdO2ZvcihsZXQgcT1KLmxlbmd0aC0xO3E+PTA7cS0tKXtjb25zdHt2YWx1ZTpXLHA6R309SltxXTsoVz09PSExfHxHPj0xKSYmdGhpc1tpXS5zcGxpY2UocSwxKX10aGlzW2ldLmxlbmd0aD4wJiZTKCl9KSl9O2lmKHRoaXNbbV0mJnRoaXNbbV0uX3R5cGUhPT0idGlja2VyIiYmKE9iamVjdCh2LmNhbmNlbEFuaW1hdGlvbkZyYW1lKSh0aGlzW21dLl9yZXF1ZXN0SUQpLGRlbGV0ZSB0aGlzW21dKSwhdGhpc1ttXSl7Y29uc3QgSj1uZXcgUHJvbWlzZShxPT57Qj1xLHc9T2JqZWN0KHYucmVxdWVzdEFuaW1hdGlvbkZyYW1lKShIKX0pO0ouX3Jlc29sdmU9QixKLl9yZXF1ZXN0SUQ9dyxKLl90eXBlPSJ0aWNrZXIiLHRoaXNbbV09Sn19O1MoKX10b0dsb2JhbFBvcyhDLEkpe2lmKHRoaXMubGF5ZXJUcmFuc2Zvcm1JbnZlcnQpe2NvbnN0IEI9dGhpcy50cmFuc2Zvcm1NYXRyaXg7Qz1CWzBdKkMrQlsyXSpJK0JbNF0sST1CWzFdKkMrQlszXSpJK0JbNV19Y29uc3R7d2lkdGg6QSxoZWlnaHQ6TH09dGhpcy5nZXRSZXNvbHV0aW9uKCksRD10aGlzLnJlbmRlck9mZnNldCxSPVt0aGlzLmNhbnZhcy5jbGllbnRXaWR0aCx0aGlzLmNhbnZhcy5jbGllbnRIZWlnaHRdO0M9QypSWzBdL0ErRFswXSxJPUkqUlsxXS9MK0RbMV07Y29uc3QgUz10aGlzLmRpc3BsYXlSYXRpbztyZXR1cm4gQyo9UyxJKj1TLFtDLEldfXRvTG9jYWxQb3MoQyxJKXtjb25zdHt3aWR0aDpBLGhlaWdodDpMfT10aGlzLmdldFJlc29sdXRpb24oKSxEPXRoaXMucmVuZGVyT2Zmc2V0LFI9W3RoaXMuY2FudmFzLmNsaWVudFdpZHRoLHRoaXMuY2FudmFzLmNsaWVudEhlaWdodF07Qz1DKkEvUlswXS1EWzBdLEk9SSpML1JbMV0tRFsxXTtjb25zdCBTPXRoaXMuZGlzcGxheVJhdGlvO0MvPVMsSS89Uztjb25zdCBCPXRoaXMubGF5ZXJUcmFuc2Zvcm1JbnZlcnQ7cmV0dXJuIEImJihDPUJbMF0qQytCWzJdKkkrQls0XSxJPUJbMV0qQytCWzNdKkkrQls1XSksW0MsSV19fWwuZGVmYXVsdC5yZWdpc3Rlck5vZGUoVCwibGF5ZXIiKX0sZnVuY3Rpb24oYyxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gbX0pO3ZhciByPXQoMjI0KSxzPXQoMjg4KSxnPXQoMjEzKSx2PXQoMjUyKSxoPXQoNzIpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBsKHAsbil7aWYocD09bnVsbClyZXR1cm57fTt2YXIgYT11KHAsbiksaSxvO2lmKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpe3ZhciBUPU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocCk7Zm9yKG89MDtvPFQubGVuZ3RoO28rKylpPVRbb10sIShuLmluZGV4T2YoaSk+PTApJiZPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocCxpKSYmKGFbaV09cFtpXSl9cmV0dXJuIGF9ZnVuY3Rpb24gdShwLG4pe2lmKHA9PW51bGwpcmV0dXJue307dmFyIGE9e30saT1PYmplY3Qua2V5cyhwKSxvLFQ7Zm9yKFQ9MDtUPGkubGVuZ3RoO1QrKylvPWlbVF0sIShuLmluZGV4T2Yobyk+PTApJiYoYVtvXT1wW29dKTtyZXR1cm4gYX1mdW5jdGlvbiBNKHAsbixhKXtyZXR1cm4gbiBpbiBwP09iamVjdC5kZWZpbmVQcm9wZXJ0eShwLG4se3ZhbHVlOmEsZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTpwW25dPWEscH1jb25zdCBmPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIseT1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGUiKSx4PVN5bWJvbCgicm9vdCIpLGI9U3ltYm9sKCJ0YXNrIik7ZnVuY3Rpb24gTyhwLG49ITApe2NvbnN0IGE9cFt4XTtpZihhJiZhLmNoaWxkcmVuWzBdKXtjb25zdCBpPXAuc3ZnLG89cC5sYXllcj9wLmxheWVyLmRpc3BsYXlSYXRpbzoxO2lmKCFpLmhhc0F0dHJpYnV0ZSgiZGF0YS1vcmlnaW5hbC13aWR0aCIpKXtsZXQgQz1pLmdldEF0dHJpYnV0ZSgid2lkdGgiKTtDPUM/T2JqZWN0KGguc2l6ZVRvUGl4ZWwpKEMpOjMwMDtsZXQgST1pLmdldEF0dHJpYnV0ZSgiaGVpZ2h0Iik7ST1JP09iamVjdChoLnNpemVUb1BpeGVsKShJKToxNTAsaS5oYXNBdHRyaWJ1dGUoInZpZXdCb3giKXx8aS5zZXRBdHRyaWJ1dGUoInZpZXdCb3giLGAwIDAgJHtNYXRoLnJvdW5kKEMpfSAke01hdGgucm91bmQoSSl9YCksaS5zZXRBdHRyaWJ1dGUoImRhdGEtb3JpZ2luYWwtd2lkdGgiLEMpLGkuc2V0QXR0cmlidXRlKCJkYXRhLW9yaWdpbmFsLWhlaWdodCIsSSl9bGV0IFQ9cC5hdHRyaWJ1dGVzLndpZHRofHxOdW1iZXIoaS5nZXRBdHRyaWJ1dGUoImRhdGEtb3JpZ2luYWwtd2lkdGgiKSksUD1wLmF0dHJpYnV0ZXMuaGVpZ2h0fHxOdW1iZXIoaS5nZXRBdHRyaWJ1dGUoImRhdGEtb3JpZ2luYWwtaGVpZ2h0IikpO2lmKFQqPW8sUCo9byxuJiZwLmF0dHJpYnV0ZXMuZmxleGlibGUpe2NvbnN0IEM9cC5hdHRyaWJ1dGVzLnNjYWxlWzBdO2lmKFQqPUMsUCo9QyxpLnNldEF0dHJpYnV0ZSgid2lkdGgiLFQpLGkuc2V0QXR0cmlidXRlKCJoZWlnaHQiLFApLFQmJlAmJnAudGV4dHVyZUltYWdlKXtjb25zdCBJPXAudGV4dHVyZUltYWdlLndpZHRoLEE9cC50ZXh0dXJlSW1hZ2UuaGVpZ2h0LEw9cC5jbGllbnRTaXplO3AuYXR0cmlidXRlcy50ZXh0dXJlUmVjdD1bMCwwLE1hdGgucm91bmQoTFswXSpJL1QpLE1hdGgucm91bmQoTFsxXSpBL1ApXX19ZWxzZSBwW2JdfHwoaS5zZXRBdHRyaWJ1dGUoIndpZHRoIixUKSxpLnNldEF0dHJpYnV0ZSgiaGVpZ2h0IixQKSxwW2JdPVByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCk9PntkZWxldGUgcFtiXTtjb25zdCBDPWEuaW5uZXJIVE1MLEk9bmV3IEJsb2IoW0NdLHt0eXBlOiJpbWFnZS9zdmcreG1sIn0pLEE9VVJMLmNyZWF0ZU9iamVjdFVSTChJKSxMPW5ldyBJbWFnZTtMLm9ubG9hZD1mdW5jdGlvbigpe0wud2lkdGgmJkwuaGVpZ2h0PyhwLmF0dHJpYnV0ZXNbeV0oInRleHR1cmUiLEwpLHAuYXR0cmlidXRlcy5mbGV4aWJsZSYmKHAuYXR0cmlidXRlcy50ZXh0dXJlUmVjdD1udWxsKSk6cC5hdHRyaWJ1dGVzW3ldKCJ0ZXh0dXJlIixudWxsKX0sTC5zcmM9QX0pKX19Y2xhc3MgbSBleHRlbmRzIHIuZGVmYXVsdHtjb25zdHJ1Y3RvcihuPXt9KXt0eXBlb2Ygbj09InN0cmluZyImJihuPXtzdmdUZXh0Om59KTtsZXR7c3ZnVGV4dDphfT1uLGk9bChuLFsic3ZnVGV4dCJdKTtpZihzdXBlcihpKSx0aGlzW3hdPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpLGEpe3RoaXNbeF0uaW5uZXJIVE1MPWE7Y29uc3Qgbz10aGlzW3hdLmNoaWxkcmVuWzBdO28/by5zZXRBdHRyaWJ1dGUoInhtbG5zIixmKTooZmV0Y2goYSkudGhlbihUPT5ULnRleHQoKSkudGhlbihUPT57dGhpc1t4XS5pbm5lckhUTUw9VCwoIXRoaXMub2JzZXJ2ZXJ8fHRoaXMuYXR0cmlidXRlcy5mbGV4aWJsZSkmJk8odGhpcyl9KSxhPW51bGwpfWlmKCFhKXtjb25zdCBvPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhmLCJzdmciKTtvLnNldEF0dHJpYnV0ZSgieG1sbnMiLGYpLHRoaXNbeF0uYXBwZW5kQ2hpbGQobyl9aWYodHlwZW9mIE11dGF0aW9uT2JzZXJ2ZXI9PSJmdW5jdGlvbiIpe2NvbnN0IG89bmV3IE11dGF0aW9uT2JzZXJ2ZXIoVD0+e08odGhpcywhMSl9KTtvLm9ic2VydmUodGhpc1t4XSx7YXR0cmlidXRlczohMCxzdWJ0cmVlOiEwLGNoYXJhY3RlckRhdGE6ITAsY2hpbGRMaXN0OiEwfSksdGhpcy5vYnNlcnZlcj1vfX1nZXQgY2hpbGRyZW4oKXtyZXR1cm5bdGhpcy5zdmddfWdldCBjaGlsZE5vZGVzKCl7cmV0dXJuW3RoaXMuc3ZnXX1nZXQgc3ZnKCl7cmV0dXJuIHRoaXNbeF0/dGhpc1t4XS5jaGlsZHJlblswXTpudWxsfXNldFJlc29sdXRpb24oe3dpZHRoOm4saGVpZ2h0OmF9KXtzdXBlci5zZXRSZXNvbHV0aW9uKHt3aWR0aDpuLGhlaWdodDphfSksTyh0aGlzKX1kaXNwYXRjaFBvaW50ZXJFdmVudChuKXtjb25zdCBhPXN1cGVyLmRpc3BhdGNoUG9pbnRlckV2ZW50KG4pO2lmKGEmJnRoaXMuYXR0cmlidXRlcy5wYXNzRXZlbnRzJiZ0eXBlb2YgTW91c2VFdmVudD09ImZ1bmN0aW9uIil7Y29uc3R7eDppLHk6b309bjtsZXRbVCxQXT10aGlzLmdldE9mZnNldFBvc2l0aW9uKGksbyk7Y29uc3QgQz1uLm9yaWdpbmFsRXZlbnQsST10aGlzLmF0dHJpYnV0ZXMuYW5jaG9yLEE9dGhpcy5jbGllbnRTaXplO1Q9KFQrSVswXSpBWzBdKS8yLFA9KFArSVsxXSpBWzFdKS8yO2NvbnN0IEw9bi50eXBlO2lmKEw9PT1DLnR5cGUpe2xldCBEPW51bGw7aWYoQyBpbnN0YW5jZW9mIE1vdXNlRXZlbnQpRD1uZXcgTW91c2VFdmVudChMLHtzY3JlZW5YOlQsc2NyZWVuWTpQLGNsaWVudFg6VCxjbGllbnRZOlAsYnViYmxlczpDLmJ1YmJsZXMsYnV0dG9uOkMuYnV0dG9uLGJ1dHRvbnM6Qy5idXR0b25zLGNhbmNlbEJ1YmJsZTpDLmNhbmNlbEJ1YmJsZSxjYW5jZWxhYmxlOkMuY2FuY2VsYWJsZSxjdXJyZW50VGFyZ2V0OkMuY3VycmVudFRhcmdldCxmcm9tRWxlbWVudDpDLmZyb21FbGVtZW50LHJlbGF0ZWRUYXJnZXQ6Qy5yZWxhdGVkVGFyZ2V0LHJldHVyblZhbHVlOkMucmV0dXJuVmFsdWUsc3JjRWxlbWVudDpDLnNyY0VsZW1lbnQsdGFyZ2V0OkMudGFyZ2V0LHRvRWxlbWVudDpDLnRvRWxlbWVudCx3aGljaDpDLndpdGNofSk7ZWxzZSBpZihDIGluc3RhbmNlb2YgVG91Y2hFdmVudCl7bGV0IFI9bnVsbDtjb25zdCBTPUMuY2hhbmdlZFRvdWNoZXN8fFtDXTtmb3IobGV0IEI9MDtCPFMubGVuZ3RoO0IrKyl7Y29uc3Qgdz1TW0JdO2lmKG4uaWRlbnRpZmllcj09PXcuaWRlbnRpZmllcil7Uj13O2JyZWFrfX1pZihSKXtjb25zdCBCPW5ldyBUb3VjaCh7aWRlbnRpZmllcjpSLmlkZW50aWZpZXIsdGFyZ2V0OlIudGFyZ2V0LGNsaWVudFg6VCxjbGllbnRZOlAsc2NyZWVuWDpULHNjcmVlblk6UCxwYWdlWDpULHBhZ2VZOlAscmFkaXVzWDpSLnJhZGl1c1gscmFkaXVzWTpSLnJhZGl1c1kscm90YXRpb25BbmdsZTpSLnJvdGF0aW9uQW5nbGUsZm9yY2U6Ui5mb3JjZX0pO0Q9bmV3IFRvdWNoRXZlbnQoTCx7Y2FuY2VsYWJsZTpDLmNhbmNlbGFibGUsYnViYmxlczpDLmJ1YmJsZXMsY29tcG9zZWQ6Qy5jb21wb3NlZCx0b3VjaGVzOltCXSx0YXJnZXRUb3VjaGVzOltCXSxjaGFuZ2VkVG91Y2hlczpbQl19KX19ZWxzZSBEPUM7RCYmdGhpcy5zdmcuZGlzcGF0Y2hFdmVudChEKX19cmV0dXJuIGF9Z2V0RWxlbWVudEJ5SWQobil7cmV0dXJuIE9iamVjdCh2LnF1ZXJ5U2VsZWN0b3IpKGAjJHtufWAsdGhpcyl9Z2V0RWxlbWVudHNCeUNsYXNzTmFtZShuKXtyZXR1cm4gT2JqZWN0KHYucXVlcnlTZWxlY3RvckFsbCkoYC4ke259YCx0aGlzKX1nZXRFbGVtZW50c0J5TmFtZShuKXtyZXR1cm4gT2JqZWN0KHYucXVlcnlTZWxlY3RvckFsbCkoYFtuYW1lPSIke259Il1gLHRoaXMpfWdldEVsZW1lbnRzQnlUYWdOYW1lKG4pe3JldHVybiBPYmplY3Qodi5xdWVyeVNlbGVjdG9yQWxsKShuLHRoaXMpfXF1ZXJ5U2VsZWN0b3Iobil7cmV0dXJuIE9iamVjdCh2LnF1ZXJ5U2VsZWN0b3IpKG4sdGhpcyl9cXVlcnlTZWxlY3RvckFsbChuKXtyZXR1cm4gT2JqZWN0KHYucXVlcnlTZWxlY3RvckFsbCkobix0aGlzKX1vblByb3BlcnR5Q2hhbmdlKG4sYSxpKXtzdXBlci5vblByb3BlcnR5Q2hhbmdlKG4sYSxpKSxuPT09ImZsZXhpYmxlIiYmTyh0aGlzKSx0aGlzLmF0dHJpYnV0ZXMuZmxleGlibGUmJihuPT09IndpZHRoInx8bj09PSJoZWlnaHQifHxuPT09InNjYWxlInx8bj09PSJ0cmFuc2Zvcm0iKSYmTyh0aGlzKX19TShtLCJBdHRyIixzLmRlZmF1bHQpLGcuZGVmYXVsdC5yZWdpc3Rlck5vZGUobSwic3ByaXRlc3ZnIil9LGZ1bmN0aW9uKGMsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIGh9KTt2YXIgcj10KDIyNSk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IHM9U3ltYm9sLmZvcigic3ByaXRlanNfZ2V0QXR0cmlidXRlIiksZz1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGUiKSx2PVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZURlZmF1bHQiKTtjbGFzcyBoIGV4dGVuZHMgci5kZWZhdWx0e2NvbnN0cnVjdG9yKHUpe3N1cGVyKHUpLHRoaXNbdl0oe3Bhc3NFdmVudHM6ITEsZmxleGlibGU6ITF9KX1nZXQgdGV4dHVyZSgpe3JldHVybiB0aGlzW3NdKCJ0ZXh0dXJlIil9c2V0IHRleHR1cmUodSl7fWdldCBwYXNzRXZlbnRzKCl7cmV0dXJuIHRoaXNbc10oInBhc3NFdmVudHMiKX1zZXQgcGFzc0V2ZW50cyh1KXtyZXR1cm4gdGhpc1tnXSgicGFzc0V2ZW50cyIsdSl9Z2V0IGZsZXhpYmxlKCl7cmV0dXJuIHRoaXNbc10oImZsZXhpYmxlIil9c2V0IGZsZXhpYmxlKHUpe3JldHVybiB0aGlzW2ddKCJmbGV4aWJsZSIsdSl9fX0sZnVuY3Rpb24oYyxlLHQpe3QucihlKTt2YXIgcj10KDEyKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gcyh1LE0pe3ZhciBmPU9iamVjdC5rZXlzKHUpO2lmKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpe3ZhciB5PU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHModSk7TSYmKHk9eS5maWx0ZXIoZnVuY3Rpb24oeCl7cmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodSx4KS5lbnVtZXJhYmxlfSkpLGYucHVzaC5hcHBseShmLHkpfXJldHVybiBmfWZ1bmN0aW9uIGcodSl7Zm9yKHZhciBNPTE7TTxhcmd1bWVudHMubGVuZ3RoO00rKyl7dmFyIGY9YXJndW1lbnRzW01dIT1udWxsP2FyZ3VtZW50c1tNXTp7fTtNJTI/cyhPYmplY3QoZiksITApLmZvckVhY2goZnVuY3Rpb24oeSl7dih1LHksZlt5XSl9KTpPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycz9PYmplY3QuZGVmaW5lUHJvcGVydGllcyh1LE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKGYpKTpzKE9iamVjdChmKSkuZm9yRWFjaChmdW5jdGlvbih5KXtPYmplY3QuZGVmaW5lUHJvcGVydHkodSx5LE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZix5KSl9KX1yZXR1cm4gdX1mdW5jdGlvbiB2KHUsTSxmKXtyZXR1cm4gTSBpbiB1P09iamVjdC5kZWZpbmVQcm9wZXJ0eSh1LE0se3ZhbHVlOmYsZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTp1W01dPWYsdX1jb25zdCBoPVN5bWJvbCgiaW5pdGVkIik7bGV0IGw9bnVsbDt0eXBlb2YgV29ya2VyPT0iZnVuY3Rpb24iJiYobD1jbGFzcyBleHRlbmRzIFdvcmtlcntjb25zdHJ1Y3Rvcih1KXtpZih1Lndvcmtlcj09PSEwJiYodS53b3JrZXI9YC4vJHt1LmlkfS53b3JrZXIuanNgKSxzdXBlcih1LndvcmtlciksdGhpcy5vcHRpb25zPXUsIXUuY2FudmFzKXtjb25zdHt3aWR0aDpNLGhlaWdodDpmfT10aGlzLmdldFJlc29sdXRpb24oKSx5PXIuRU5WLmNyZWF0ZUNhbnZhcyhNLGYse29mZnNjcmVlbjohMX0pO3kuc3R5bGUmJih5LnN0eWxlLnBvc2l0aW9uPSJhYnNvbHV0ZSIpLHkuZGF0YXNldCYmKHkuZGF0YXNldC5sYXllcklkPXUuaWQpLHUuY2FudmFzPXl9dGhpcy5jYW52YXM9dS5jYW52YXN9Z2V0IGlkKCl7cmV0dXJuIHRoaXMub3B0aW9ucy5pZH1zZXRSZXNvbHV0aW9uKHt3aWR0aDp1LGhlaWdodDpNfSl7aWYodGhpc1toXSl0aGlzLnBvc3RNZXNzYWdlKHt0eXBlOiJyZXNvbHV0aW9uX2NoYW5nZSIsd2lkdGg6dSxoZWlnaHQ6TX0pO2Vsc2V7dGhpcy5jYW52YXMud2lkdGg9dSx0aGlzLmNhbnZhcy5oZWlnaHQ9TTtjb25zdCBmPXRoaXMub3B0aW9ucyx5PWYuY2FudmFzLnRyYW5zZmVyQ29udHJvbFRvT2Zmc2NyZWVuKCkseD1nKHt9LGYpO2RlbGV0ZSB4LmNvbnRhaW5lcix4LmNhbnZhcz15LHRoaXMucG9zdE1lc3NhZ2Uoe3R5cGU6ImNyZWF0ZSIsb3B0aW9uczp4fSxbeV0pLHRoaXNbaF09ITB9fWdldFJlc29sdXRpb24oKXtpZih0aGlzLmNhbnZhcyl7Y29uc3R7d2lkdGg6dSxoZWlnaHQ6TX09dGhpcy5jYW52YXM7cmV0dXJue3dpZHRoOnUsaGVpZ2h0Ok19fXJldHVybnt3aWR0aDozMDAsaGVpZ2h0OjE1MH19cmVtb3ZlKCl7cmV0dXJuIHRoaXMucGFyZW50JiZ0aGlzLnBhcmVudC5yZW1vdmVDaGlsZD8odGhpcy5wYXJlbnQucmVtb3ZlQ2hpbGQodGhpcyksITApOiExfWNvbm5lY3QodSxNKXtPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywicGFyZW50Iix7dmFsdWU6dSx3cml0YWJsZTohMSxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiek9yZGVyIix7dmFsdWU6TSx3cml0YWJsZTohMSxjb25maWd1cmFibGU6ITB9KX1kaXNjb25uZWN0KCl7ZGVsZXRlIHRoaXMucGFyZW50LGRlbGV0ZSB0aGlzLnpPcmRlcn1kaXNwYXRjaFBvaW50ZXJFdmVudCh1KXt0aGlzLnBvc3RNZXNzYWdlKHt0eXBlOiJldmVudCIsZXZlbnQ6e2NhbmNlbEJ1YmJsZTp1LmNhbmNlbEJ1YmJsZSxidWJibGVzOnUuYnViYmxlcyxkZXRhaWw6dS5kZXRhaWwsaWRlbnRpZmllcjp1LmlkZW50aWZpZXIsbGF5ZXJYOnUubGF5ZXJYLGxheWVyWTp1LmxheWVyWSxvcmlnaW5hbFg6dS5vcmlnaW5hbFgsb3JpZ2luYWxZOnUub3JpZ2luYWxZLHR5cGU6dS50eXBlLHg6dS54LHk6dS55fX0pfX0pLGUuZGVmYXVsdD1sfSxmdW5jdGlvbihjLGUsdCl7dC5yKGUpLChmdW5jdGlvbihyKXt0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gVH0pO3ZhciBzPXQoMTIpLGc9dCg2OCksdj10KDcwKSxoPXQoMjg2KSxsPXQoMjg5KSx1PXQoMjUwKSxNPXQoMjkxKSxmPXQoMjE0KSx5PXQoMjE4KSx4PXQoMjEzKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3QgYj1TeW1ib2woImVudGVyZWRUYXJnZXRzIik7ZnVuY3Rpb24gTyhQKXtyZXR1cm4gUC5pZD1QLmlkfHxgX2xheWVyJHtNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyLDEyKX1gLFAuZGF0YXNldHx8KFAuZGF0YXNldD17fSksUC5kYXRhc2V0LmxheWVySWQ9UC5pZCxQLmNvbm5lY3Q9KEMsSSk9PntQLnBhcmVudD1DLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQLCJ6T3JkZXIiLHt2YWx1ZTpJLHdyaXRhYmxlOiExLGNvbmZpZ3VyYWJsZTohMH0pfSxQLmRpc2Nvbm5lY3Q9Qz0+e2RlbGV0ZSBQLnpPcmRlcn0sUC5jYW52YXM9UCxQLmdldFJlc29sdXRpb249KCk9Pih7d2lkdGg6MCxoZWlnaHQ6MH0pLFAuc2V0UmVzb2x1dGlvbj0oKT0+ITEsUC5vcHRpb25zPXtoYW5kbGVFdmVudDohMX0sUH1mdW5jdGlvbiBtKFAsQyl7Y29uc3QgST1QLmNoaWxkcmVuO2xldCBBPW51bGw7Zm9yKGxldCBMPTA7TDxJLmxlbmd0aDtMKyspe2NvbnN0IEQ9SVtMXTtpZigoQz09PUR8fEEhPW51bGwpJiYoQT1EKSxBJiZBIT09QyYmIUEub2Zmc2NyZWVuKXJldHVybiBBLmNhbnZhc31yZXR1cm4gbnVsbH1mdW5jdGlvbiBwKFAsQyl7Y29uc3RbSSxBXT1QLnJlbmRlck9mZnNldCx7d2lkdGg6TCxoZWlnaHQ6RH09UC5nZXRSZXNvbHV0aW9uKCksUj1QLmRpc3BsYXlSYXRpbztQLnJlbmRlcmVyLmRyYXdJbWFnZShDLmNhbnZhcywtSS9SLC1BL1IsTC9SLEQvUil9Y29uc3Qgbj17fTtmdW5jdGlvbiBhKFApe2NvbnN0IEM9WyJtb3VzZWRvd24iLCJtb3VzZXVwIiwibW91c2Vtb3ZlIiwibW91c2V3aGVlbCIsIndoZWVsIiwidG91Y2hzdGFydCIsInRvdWNoZW5kIiwidG91Y2htb3ZlIiwidG91Y2hjYW5jZWwiLCJjbGljayIsImRibGNsaWNrIiwibG9uZ3ByZXNzIiwidGFwIiwiY29udGV4dG1lbnUiXSxJPVAuY29udGFpbmVyO0kuYWRkRXZlbnRMaXN0ZW5lcigibW91c2VsZWF2ZSIsQT0+e2NvbnN0IEw9UFtiXTtpZihMLnNpemUpe2NvbnN0IEQ9bmV3IGYuZGVmYXVsdCgibW91c2VsZWF2ZSIpO0Quc2V0T3JpZ2luYWxFdmVudChBKSxbLi4uTF0uZm9yRWFjaChSPT57Ui5kaXNwYXRjaEV2ZW50KEQpfSksUFtiXS5jbGVhcigpfX0se3Bhc3NpdmU6ITB9KSxDLmZvckVhY2goQT0+e0kuYWRkRXZlbnRMaXN0ZW5lcihBLEw9Pntjb25zdHtsZWZ0OkQsdG9wOlIsZGlzcGxheVJhdGlvOlN9PVAub3B0aW9ucyxCPVAub3JkZXJlZENoaWxkcmVuO09iamVjdChNLmRlZmF1bHQpKEwse29mZnNldExlZnQ6RCxvZmZzZXRUb3A6UixkaXNwbGF5UmF0aW86U30pLmZvckVhY2goSD0+e2NvbnN0IEo9SC5pZGVudGlmaWVyO2lmKEgudHlwZT09PSJ0b3VjaG1vdmUifHxILnR5cGU9PT0idG91Y2hlbmQiKXtjb25zdCBXPW5bSl07VyYmVy5kaXNwYXRjaEV2ZW50KEgpLEgudHlwZT09PSJ0b3VjaGVuZCImJmRlbGV0ZSBuW0pdfWVsc2V7Zm9yKGxldCBXPUIubGVuZ3RoLTE7Vz49MDtXLS0pe2NvbnN0IEc9QltXXTtpZihHLm9wdGlvbnMuaGFuZGxlRXZlbnQhPT0hMSl7aWYoRy5kaXNwYXRjaFBvaW50ZXJFdmVudChIKSYmSC50YXJnZXQhPT1HKWJyZWFrO0guY2FuY2VsQnViYmxlPSExfX1pZihILnRhcmdldD09PUJbMF0pZm9yKGxldCBXPUIubGVuZ3RoLTE7Vz49MDtXLS0pe2NvbnN0IEc9QltXXTtpZihHLm9wdGlvbnMuaGFuZGxlRXZlbnQhPT0hMSl7SC50YXJnZXQ9RzticmVha319fWNvbnN0IHE9SC50YXJnZXQ7aWYoSC50eXBlPT09InRvdWNoc3RhcnQiJiYobltKXT1ILnRhcmdldCksSC50eXBlPT09Im1vdXNlbW92ZSIpe2NvbnN0IFc9UFtiXTtsZXQgRztpZihxKXtjb25zdCBfPXEuYW5jZXN0b3JzfHxbXTtHPW5ldyBTZXQoW3EsLi4uX10pfWVsc2UgRz1uZXcgU2V0O2NvbnN0IFE9T2JqZWN0LmVudHJpZXMoTCk7aWYoIVcuaGFzKHEpJiZxKXtjb25zdCBfPW5ldyBmLmRlZmF1bHQoIm1vdXNlZW50ZXIiKTtfLnNldE9yaWdpbmFsRXZlbnQoTCksUS5mb3JFYWNoKChbayxjdF0pPT57X1trXT1jdH0pLFcuYWRkKHEpLHEuZGlzcGF0Y2hFdmVudChfKTtjb25zdCBzdD1xLmFuY2VzdG9ycztzdCYmc3QuZm9yRWFjaChrPT57ayBpbnN0YW5jZW9mIHYuZGVmYXVsdCYmIVcuaGFzKGspJiYoVy5hZGQoayksay5kaXNwYXRjaEV2ZW50KF8pKX0pfWNvbnN0IHR0PW5ldyBmLmRlZmF1bHQoIm1vdXNlbGVhdmUiKTt0dC5zZXRPcmlnaW5hbEV2ZW50KEwpLFEuZm9yRWFjaCgoW18sc3RdKT0+e3R0W19dPXN0fSksWy4uLlddLmZvckVhY2goXz0+e0cuaGFzKF8pfHwoVy5kZWxldGUoXyksXy5kaXNwYXRjaEV2ZW50KHR0KSl9KX19KX0se3Bhc3NpdmU6QSE9PSJjb250ZXh0bWVudSJ9KX0pfWZ1bmN0aW9uIGkoUCxDKXtpZihDJiZDLnN0eWxlKXtsZXR7d2lkdGg6SSxoZWlnaHQ6QSxtb2RlOkwsY29udGFpbmVyOkR9PVA7Y29uc3R7Y2xpZW50V2lkdGg6UixjbGllbnRIZWlnaHQ6U309RDtJPUl8fFIsQT1BfHxTLEw9PT0ic3RhdGljIj8oQy5zdHlsZS53aWR0aD1gJHtJfXB4YCxDLnN0eWxlLmhlaWdodD1gJHtBfXB4YCk6KEMuc3R5bGUudG9wPSIwIixDLnN0eWxlLmxlZnQ9IjAiLEMuc3R5bGUud2lkdGg9YCR7Un1weGAsQy5zdHlsZS5oZWlnaHQ9YCR7U31weGAsQy5zdHlsZS50cmFuc2Zvcm09IiIsQy5zdHlsZS53ZWJraXRUcmFuc2Zvcm09IiIpfX1jb25zdCBvPVN5bWJvbCgib2Zmc2NyZWVuTGF5ZXJDb3VudCIpO2NsYXNzIFQgZXh0ZW5kcyB1LmRlZmF1bHR7Y29uc3RydWN0b3IoQz17fSl7aWYoc3VwZXIoKSwhQy5jb250YWluZXIpaWYodHlwZW9mIHMuRU5WLkNvbnRhaW5lcj09ImZ1bmN0aW9uIilDLmNvbnRhaW5lcj1uZXcgcy5FTlYuQ29udGFpbmVyKEMud2lkdGh8fDMwMCxDLmhlaWdodHx8MTUwKTtlbHNlIHRocm93IG5ldyBFcnJvcigiTm8gY29udGFpbmVyIHNwZWNpZmllZC4iKTtpZih0aGlzLmNvbnRhaW5lcj1DLmNvbnRhaW5lcix0aGlzLmNvbnRhaW5lci5zdHlsZSYmKHRoaXMuY29udGFpbmVyLnN0eWxlLm92ZXJmbG93fHwodGhpcy5jb250YWluZXIuc3R5bGUub3ZlcmZsb3c9ImhpZGRlbiIpLHRoaXMuY29udGFpbmVyLnN0eWxlLnBvc2l0aW9ufHwodGhpcy5jb250YWluZXIuc3R5bGUucG9zaXRpb249InJlbGF0aXZlIikpLHRoaXMub3B0aW9ucz1DLEMuZGlzcGxheVJhdGlvPUMuZGlzcGxheVJhdGlvfHwxLEMubW9kZT1DLm1vZGV8fCJzY2FsZSIsQy5sZWZ0PTAsQy50b3A9MCxDLmF1dG9SZXNpemU9Qy5hdXRvUmVzaXplIT09ITEsQy5hdXRvUmVzaXplKXtsZXQgSTtpZih0eXBlb2YgZ2xvYmFsVGhpczwidSI/ST1nbG9iYWxUaGlzOkk9dHlwZW9mIHdpbmRvdzwidSI/d2luZG93OnIsSS5hZGRFdmVudExpc3RlbmVyKXtjb25zdCBBPXRoaXM7SS5hZGRFdmVudExpc3RlbmVyKCJyZXNpemUiLGZ1bmN0aW9uIEwoKXt0eXBlb2YgZG9jdW1lbnQ8InUiJiZkb2N1bWVudC5jb250YWlucyhBLmNvbnRhaW5lcik/QS5yZXNpemUoKTpJLnJlbW92ZUV2ZW50TGlzdGVuZXIoInJlc2l6ZSIsTCl9KX19dGhpc1tiXT1uZXcgU2V0LHRoaXMuc2V0UmVzb2x1dGlvbihDKSxhKHRoaXMpLHRoaXNbb109MH1nZXQgaGFzT2Zmc2NyZWVuQ2FudmFzKCl7cmV0dXJuIHRoaXNbb10+MH1zZXQgZGlzcGxheVJhdGlvKEMpe3RoaXMub3B0aW9ucy5kaXNwbGF5UmF0aW8hPT1DJiYodGhpcy5vcHRpb25zLmRpc3BsYXlSYXRpbz1DLHRoaXMucmVzaXplKCkpfWdldCBkaXNwbGF5UmF0aW8oKXtyZXR1cm4gdGhpcy5vcHRpb25zLmRpc3BsYXlSYXRpb31zZXQgaGVpZ2h0KEMpe3RoaXMub3B0aW9ucy5oZWlnaHQhPT1DJiYodGhpcy5vcHRpb25zLmhlaWdodD1DLHRoaXMucmVzaXplKCkpfWdldCBoZWlnaHQoKXtyZXR1cm4gdGhpcy5vcHRpb25zLmhlaWdodH1zZXQgbW9kZShDKXt0aGlzLm9wdGlvbnMubW9kZSE9PUMmJih0aGlzLm9wdGlvbnMubW9kZT1DLHRoaXMucmVzaXplKCkpfWdldCBtb2RlKCl7cmV0dXJuIHRoaXMub3B0aW9ucy5tb2RlfXNldCB3aWR0aChDKXt0aGlzLm9wdGlvbnMud2lkdGghPT1DJiYodGhpcy5vcHRpb25zLndpZHRoPUMsdGhpcy5yZXNpemUoKSl9Z2V0IHdpZHRoKCl7cmV0dXJuIHRoaXMub3B0aW9ucy53aWR0aH1hcHBlbmRDaGlsZChDKXshKEMgaW5zdGFuY2VvZiBoLmRlZmF1bHQpJiYhKEMgaW5zdGFuY2VvZiBsLmRlZmF1bHQpJiZPKEMpO2NvbnN0IEk9c3VwZXIuYXBwZW5kQ2hpbGQoQyksQT1DLmNhbnZhcztyZXR1cm4gQy5vZmZzY3JlZW4/dGhpc1tvXSsrOnRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKEEpLGkodGhpcy5vcHRpb25zLEEpLEMuc2V0UmVzb2x1dGlvbih0aGlzLmdldFJlc29sdXRpb24oKSksSX1mb3JjZVVwZGF0ZSgpe3RoaXMuaGFzT2Zmc2NyZWVuQ2FudmFzJiYhdGhpcy5fcmVxdWVzdElEJiYodGhpcy5fcmVxdWVzdElEPU9iamVjdChnLnJlcXVlc3RBbmltYXRpb25GcmFtZSkoKCk9PntkZWxldGUgdGhpcy5fcmVxdWVzdElELHRoaXMucmVuZGVyKCl9KSl9aW5zZXJ0QmVmb3JlKEMsSSl7IShDIGluc3RhbmNlb2YgaC5kZWZhdWx0KSYmIShDIGluc3RhbmNlb2YgbC5kZWZhdWx0KSYmTyhDKTtjb25zdCBBPXN1cGVyLmluc2VydEJlZm9yZShDLEkpLEw9Qy5jYW52YXM7aWYoIUMub2Zmc2NyZWVuKXtjb25zdCBEPW0odGhpcyxDKTt0aGlzLmNvbnRhaW5lci5pbnNlcnRCZWZvcmUoTCxEKX1yZXR1cm4gaSh0aGlzLm9wdGlvbnMsTCksQy5zZXRSZXNvbHV0aW9uKHRoaXMuZ2V0UmVzb2x1dGlvbigpKSxBfWxheWVyKEM9ImRlZmF1bHQiLEk9e30pe0k9T2JqZWN0LmFzc2lnbih7fSx0aGlzLm9wdGlvbnMsSSksSS5pZD1DO2NvbnN0IEE9dGhpcy5vcmRlcmVkQ2hpbGRyZW47Zm9yKGxldCBSPTA7UjxBLmxlbmd0aDtSKyspaWYoQVtSXS5pZD09PUMpcmV0dXJuIEFbUl07Y29uc3QgTD1JLndvcmtlcjtsZXQgRDtyZXR1cm4gTD9EPW5ldyBsLmRlZmF1bHQoSSk6RD1uZXcgaC5kZWZhdWx0KEkpLHRoaXMuYXBwZW5kQ2hpbGQoRCksRH1hc3luYyBwcmVsb2FkKC4uLkMpe2NvbnN0IEk9W10sQT1bXSxMPVtdO2ZvcihsZXQgRD0wO0Q8Qy5sZW5ndGg7RCsrKXtjb25zdCBSPUNbRF07bGV0IFM7aWYodHlwZW9mIFI9PSJzdHJpbmciKVM9T2JqZWN0KHkubG9hZFRleHR1cmUpKFIpO2Vsc2UgaWYoQXJyYXkuaXNBcnJheShSKSlTPU9iamVjdCh5LmxvYWRGcmFtZXMpKC4uLlIpO2Vsc2V7Y29uc3R7aWQ6QixzcmM6d309UjtTPU9iamVjdCh5LmxvYWRUZXh0dXJlKSh3LEIpfVMgaW5zdGFuY2VvZiBQcm9taXNlfHwoUz1Qcm9taXNlLnJlc29sdmUoUykpLEEucHVzaChTLnRoZW4oQj0+e0kucHVzaChCKSxMW0RdPUI7Y29uc3Qgdz1uZXcgZi5kZWZhdWx0KHt0eXBlOiJwcmVsb2FkIixkZXRhaWw6e2N1cnJlbnQ6Qixsb2FkZWQ6SSxyZXNvdXJjZXM6Q319KTt0aGlzLmRpc3BhdGNoRXZlbnQodyl9KSl9cmV0dXJuIGF3YWl0IFByb21pc2UuYWxsKEEpLEx9cmVtb3ZlQ2hpbGQoQyl7Y29uc3QgST1zdXBlci5yZW1vdmVDaGlsZChDKTtpZihJKXtDLl9wcmVwYXJlUmVuZGVyRmluaXNoZWQmJkMuX3ByZXBhcmVSZW5kZXJGaW5pc2hlZCgpO2NvbnN0IEE9Qy5jYW52YXM7QSYmQS5yZW1vdmUmJkEucmVtb3ZlKCksQy5vZmZzY3JlZW4mJnRoaXNbb10tLX1yZXR1cm4gSX1yZW5kZXIoKXtjb25zdCBDPXRoaXMub3JkZXJlZENoaWxkcmVuO2xldCBJPW51bGw7Y29uc3QgQT1bXTtmb3IobGV0IEw9MDtMPEMubGVuZ3RoO0wrKyl7Y29uc3QgRD1DW0xdLFI9QS5sZW5ndGg+MDtpZihEIGluc3RhbmNlb2YgaC5kZWZhdWx0JiYhRC5vZmZzY3JlZW4paWYoIUQuYXV0b1JlbmRlcilSJiYoY29uc29sZS53YXJuKCJTb21lIG9mZnNjcmVlbiBjYW52YXMgd2lsbCBub3QgYmUgcmVuZGVyZWQuIiksQS5sZW5ndGg9MCk7ZWxzZSBpZihJPUQsUil7RC5yZW5kZXJlci5jbGVhcigpO2ZvcihsZXQgUz0wO1M8QS5sZW5ndGg7UysrKXtjb25zdCBCPUFbU107Qi5yZW5kZXIoKSxwKEQsQil9QS5sZW5ndGg9MCxELnJlbmRlcih7Y2xlYXI6ITF9KX1lbHNlIEQucHJlcGFyZVJlbmRlciYmRC5yZW5kZXIoKTtlbHNlIEQub2Zmc2NyZWVuP0k/KEQucHJlcGFyZVJlbmRlciYmRC5yZW5kZXIoKSxwKEksRCkpOkEucHVzaChEKTpEIGluc3RhbmNlb2YgbC5kZWZhdWx0JiZSJiYoY29uc29sZS53YXJuKCJTb21lIG9mZnNjcmVlbiBjYW52YXMgd2lsbCBub3QgYmUgcmVuZGVyZWQuIiksQS5sZW5ndGg9MCl9fXJlcGxhY2VDaGlsZChDLEkpe2NvbnN0IEE9c3VwZXIucmVwbGFjZUNoaWxkKEMsSSk7SS5jYW52YXMucmVtb3ZlJiZJLmNhbnZhcy5yZW1vdmUoKSxJLm9mZnNjcmVlbiYmdGhpc1tvXS0tO2NvbnN0IEw9Qy5jYW52YXM7aWYoIUMub2Zmc2NyZWVuKXtjb25zdCBEPW0odGhpcyxDKTt0aGlzLmNvbnRhaW5lci5pbnNlcnRCZWZvcmUoTCxEKX1yZXR1cm4gaSh0aGlzLm9wdGlvbnMsTCksQy5zZXRSZXNvbHV0aW9uKHRoaXMuZ2V0UmVzb2x1dGlvbigpKSxBfXJlc2l6ZSgpe2NvbnN0IEM9dGhpcy5vcHRpb25zO3RoaXMuY2hpbGRyZW4uZm9yRWFjaChJPT57aShDLEkuY2FudmFzKX0pLHRoaXMuc2V0UmVzb2x1dGlvbihDKSx0aGlzLmRpc3BhdGNoRXZlbnQoe3R5cGU6InJlc2l6ZSJ9KX1zZXRSZXNvbHV0aW9uKHt3aWR0aDpDLGhlaWdodDpJfT17fSl7Y29uc3QgQT10aGlzLmNvbnRhaW5lcix7Y2xpZW50V2lkdGg6TCxjbGllbnRIZWlnaHQ6RH09QTsoQz09bnVsbHx8ST09bnVsbCkmJihDPUM/P0wsST1JPz9EKTtjb25zdHttb2RlOlIsZGlzcGxheVJhdGlvOlN9PXRoaXMub3B0aW9ucztpZihDKj1TLEkqPVMsdGhpcy5vcHRpb25zLmxlZnQ9MCx0aGlzLm9wdGlvbnMudG9wPTAsUj09PSJzdGlja3lIZWlnaHQifHxSPT09InN0aWNreUxlZnQifHxSPT09InN0aWNreVJpZ2h0Iil7Y29uc3QgQj1DO0M9TCpJL0QsUj09PSJzdGlja3lIZWlnaHQiJiYodGhpcy5vcHRpb25zLmxlZnQ9LjUqKEMtQikpLFI9PT0ic3RpY2t5UmlnaHQiJiYodGhpcy5vcHRpb25zLmxlZnQ9Qy1CKX1lbHNlIGlmKFI9PT0ic3RpY2t5V2lkdGgifHxSPT09InN0aWNreVRvcCJ8fFI9PT0ic3RpY2t5Qm90dG9tIil7Y29uc3QgQj1JO0k9RCpDL0wsUj09PSJzdGlja3lXaWR0aCImJih0aGlzLm9wdGlvbnMudG9wPS41KihJLUIpKSxSPT09InN0aWNreUJvdHRvbSImJih0aGlzLm9wdGlvbnMudG9wPUktQil9c3VwZXIuc2V0UmVzb2x1dGlvbih7d2lkdGg6QyxoZWlnaHQ6SX0pfXNuYXBzaG90KHtvZmZzY3JlZW46Qz0hMSxsYXllcnM6SX09e30pe2NvbnN0IEE9Qz8ic25hcHNob3RPZmZTY3JlZW5DYW52YXMiOiJzbmFwc2hvdENhbnZhcyIse3dpZHRoOkwsaGVpZ2h0OkR9PXRoaXMuZ2V0UmVzb2x1dGlvbigpO3RoaXNbQV09dGhpc1tBXXx8cy5FTlYuY3JlYXRlQ2FudmFzKEwsRCx7b2Zmc2NyZWVuOkN9KTtjb25zdCBSPXRoaXNbQV0uZ2V0Q29udGV4dCgiMmQiKTtJPUl8fHRoaXMub3JkZXJlZENoaWxkcmVuLHRoaXNbQV0ud2lkdGg9TCx0aGlzW0FdLmhlaWdodD1EO2ZvcihsZXQgUz0wO1M8SS5sZW5ndGg7UysrKXtjb25zdCBCPUlbU107aWYoIUIub3B0aW9ucy5pZ25vcmVTbmFwc2hvdCl7Qi5yZW5kZXImJkIucmVuZGVyKCk7Y29uc3Qgdz1CLmNhbnZhczt3JiZ3IT09QiYmUi5kcmF3SW1hZ2UodywwLDAsTCxEKX19cmV0dXJuIHRoaXNbQV19fXR5cGVvZiBkb2N1bWVudDwidSImJihULnByb3RvdHlwZS5sYXllcjNkPWZ1bmN0aW9uKFAsQz17fSl7Y29uc3QgST1DLnVybHx8Imh0dHBzOi8vdW5wa2cuY29tL3Nwcml0ZS1leHRlbmQtM2QvZGlzdC9zcHJpdGUtZXh0ZW5kLTNkLm1pbi5qcyI7cmV0dXJuIG5ldyBQcm9taXNlKChBLEwpPT57Y29uc3QgRD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJzY3JpcHQiKTtELmFzeW5jPSExLEQuc3JjPUksRC5vbmxvYWQ9KCk9Pnt0cnl7QSh0aGlzLmxheWVyM2QoUCxDKSl9Y2F0Y2goUil7TChSKX19LGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZChEKX0pfSkseC5kZWZhdWx0LnJlZ2lzdGVyTm9kZShULCJzY2VuZSIpfSkuY2FsbCh0aGlzLHQoMjIpKX0sZnVuY3Rpb24oYyxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gc30pO3ZhciByPXQoMjE0KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gcyhnLHtvZmZzZXRUb3A6dj0wLG9mZnNldExlZnQ6aD0wLGRpc3BsYXlSYXRpbzpsPTF9PXt9KXtsZXQgdSxNO2NvbnN0IGY9W10se2xlZnQ6eSx0b3A6eCx3aWR0aDpiLGhlaWdodDpPfT1nLnRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxtPWcudGFyZ2V0LndpZHRoLHA9Zy50YXJnZXQuaGVpZ2h0LG49Zy5jaGFuZ2VkVG91Y2hlc3x8W2ddO2ZvcihsZXQgaT0wO2k8bi5sZW5ndGg7aSsrKXtjb25zdCBvPW5baV0sVD1vLmlkZW50aWZpZXIse2NsaWVudFg6UCxjbGllbnRZOkN9PW87UCE9bnVsbCYmQyE9bnVsbCYmZi5wdXNoKHt4Ok1hdGgucm91bmQoKFB8MCkteSkseTpNYXRoLnJvdW5kKChDfDApLXgpLGlkZW50aWZpZXI6VH0pfWYubGVuZ3RoPD0wJiZmLnB1c2goe3g6dSx5Ok19KTtjb25zdCBhPVtdO3JldHVybiBmLmZvckVhY2goaT0+e2kueCE9bnVsbCYmaS55IT1udWxsJiYodT0oaS54Km0vYi1oKS9sLE09KGkueSpwL08tdikvbCk7Y29uc3Qgbz1uZXcgci5kZWZhdWx0KGcpO09iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKG8se2xheWVyWDp7dmFsdWU6dSxjb25maWd1cmFibGU6ITB9LGxheWVyWTp7dmFsdWU6TSxjb25maWd1cmFibGU6ITB9LG9yaWdpbmFsWDp7dmFsdWU6aS54fSxvcmlnaW5hbFk6e3ZhbHVlOmkueX0seDp7dmFsdWU6dSxjb25maWd1cmFibGU6ITB9LHk6e3ZhbHVlOk0sY29uZmlndXJhYmxlOiEwfSxpZGVudGlmaWVyOnt2YWx1ZTppLmlkZW50aWZpZXJ9fSksYS5wdXNoKG8pfSksYX19XSk7QXQudmVyc2lvbixBdC5BcmMsQXQuQmxvY2ssQXQuQ2xvdWQsQXQuQ29sb3IsQXQuRWxsaXBzZSxBdC5HcmFkaWVudDtjb25zdCBTZT1BdC5Hcm91cDtBdC5MYWJlbCxBdC5MYXllcixBdC5MYXllcldvcmtlcixBdC5Ob2RlLEF0LlBhcmFsbGVsO2NvbnN0IGJlPUF0LlBhdGg7QXQuUG9seWxpbmU7Y29uc3QgZXI9QXQuUmVjdDtBdC5SZWd1bGFyLEF0LlJpbmc7Y29uc3Qgbm49QXQuU2NlbmU7QXQuU3ByaXRlLEF0LlNwcml0ZVN2ZyxBdC5TdGFyLEF0LlRyaWFuZ2xlLEF0LmhlbHBlcnMsQXQuY3JlYXRlRWxlbWVudCxBdC5pc1Nwcml0ZU5vZGUsQXQucmVnaXN0ZXJOb2RlLEF0LnJlcXVlc3RBbmltYXRpb25GcmFtZSxBdC5jYW5jZWxBbmltYXRpb25GcmFtZSxBdC5FTlY7Y29uc3Qgc249e2xpbmVhcjpjPT5jLGVhc2VJblF1YWQ6Yz0+YypjLGVhc2VPdXRRdWFkOmM9PmMqKDItYyksZWFzZUluT3V0UXVhZDpjPT5jPC41PzIqYypjOi0xKyg0LTIqYykqYyxlYXNlSW5DdWJpYzpjPT5jKmMqYyxlYXNlT3V0Q3ViaWM6Yz0+LS1jKmMqYysxLGVhc2VJbk91dEN1YmljOmM9PmM8LjU/NCpjKmMqYzooYy0xKSooMipjLTIpKigyKmMtMikrMSxlYXNlSW5RdWFydDpjPT5jKmMqYypjLGVhc2VPdXRRdWFydDpjPT4xLSAtLWMqYypjKmMsZWFzZUluT3V0UXVhcnQ6Yz0+YzwuNT84KmMqYypjKmM6MS04Ki0tYypjKmMqYyxlYXNlSW5RdWludDpjPT5jKmMqYypjKmMsZWFzZU91dFF1aW50OmM9PjErLS1jKmMqYypjKmMsZWFzZUluT3V0UXVpbnQ6Yz0+YzwuNT8xNipjKmMqYypjKmM6MSsxNiotLWMqYypjKmMqYyxlYXNlSW5TaW5lOmM9PjEtTWF0aC5jb3MoYypNYXRoLlBJLzIpLGVhc2VPdXRTaW5lOmM9Pk1hdGguc2luKGMqTWF0aC5QSS8yKSxlYXNlSW5PdXRTaW5lOmM9Pi0oTWF0aC5jb3MoTWF0aC5QSSpjKS0xKS8yLGVhc2VJbkV4cG86Yz0+Yzw9MD8wOk1hdGgucG93KDIsMTAqYy0xMCksZWFzZU91dEV4cG86Yz0+Yz49MT8xOjEtTWF0aC5wb3coMiwtMTAqYyksZWFzZUluT3V0RXhwbzpjPT5jPD0wPzA6Yz49MT8xOmM8LjU/TWF0aC5wb3coMiwyMCpjLTEwKS8yOigyLU1hdGgucG93KDIsLTIwKmMrMTApKS8yfTtjbGFzcyBodHtjb25zdHJ1Y3RvcihlPTAsdD0wLHI9MSl7T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIngiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTplfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInkiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp0fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInoiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpyfSl9Z2V0IFhZKCl7cmV0dXJuW3RoaXMueCx0aGlzLnldfXNldHooZSl7cmV0dXJuIHRoaXMuej1lLHRoaXN9c2V0WFkoZT10aGlzLngsdD10aGlzLnkpe3JldHVybiB0aGlzLng9ZSx0aGlzLnk9dCx0aGlzfXNldChlPXRoaXMueCx0PXRoaXMueSxyPXRoaXMueil7cmV0dXJuIHRoaXMueD1lLHRoaXMueT10LHRoaXMuej1yLHRoaXN9c2V0VG8oe3g6ZT0wLHk6dD0wLHo6cj0xfSl7cmV0dXJuIHRoaXMueD1lLHRoaXMueT10LHRoaXMuej1yLHRoaXN9cm90KGUpe2lmKGU9PT0wKXJldHVybiB0aGlzO2NvbnN0e3g6dCx5OnJ9PXRoaXMscz1NYXRoLnNpbihlKSxnPU1hdGguY29zKGUpO3JldHVybiB0aGlzLng9dCpnLXIqcyx0aGlzLnk9dCpzK3IqZyx0aGlzfXJvdFdpdGgoZSx0KXtpZih0PT09MClyZXR1cm4gdGhpcztjb25zdCByPXRoaXMueC1lLngscz10aGlzLnktZS55LGc9TWF0aC5zaW4odCksdj1NYXRoLmNvcyh0KTtyZXR1cm4gdGhpcy54PWUueCsocip2LXMqZyksdGhpcy55PWUueSsocipnK3MqdiksdGhpc31jbG9uZSgpe2NvbnN0e3g6ZSx5OnQsejpyfT10aGlzO3JldHVybiBuZXcgaHQoZSx0LHIpfXN1YihlKXtyZXR1cm4gdGhpcy54LT1lLngsdGhpcy55LT1lLnksdGhpc31zdWJYWShlLHQpe3JldHVybiB0aGlzLngtPWUsdGhpcy55LT10LHRoaXN9c3ViU2NhbGFyKGUpe3JldHVybiB0aGlzLngtPWUsdGhpcy55LT1lLHRoaXN9YWRkKGUpe3JldHVybiB0aGlzLngrPWUueCx0aGlzLnkrPWUueSx0aGlzfWFkZFhZKGUsdCl7cmV0dXJuIHRoaXMueCs9ZSx0aGlzLnkrPXQsdGhpc31hZGRTY2FsYXIoZSl7cmV0dXJuIHRoaXMueCs9ZSx0aGlzLnkrPWUsdGhpc31jbGFtcChlLHQpe3JldHVybiB0aGlzLng9TWF0aC5tYXgodGhpcy54LGUpLHRoaXMueT1NYXRoLm1heCh0aGlzLnksZSksdCE9PXZvaWQgMCYmKHRoaXMueD1NYXRoLm1pbih0aGlzLngsdCksdGhpcy55PU1hdGgubWluKHRoaXMueSx0KSksdGhpc31kaXYoZSl7cmV0dXJuIHRoaXMueC89ZSx0aGlzLnkvPWUsdGhpc31kaXZWKGUpe3JldHVybiB0aGlzLngvPWUueCx0aGlzLnkvPWUueSx0aGlzfW11bChlKXtyZXR1cm4gdGhpcy54Kj1lLHRoaXMueSo9ZSx0aGlzfW11bFYoZSl7cmV0dXJuIHRoaXMueCo9ZS54LHRoaXMueSo9ZS55LHRoaXN9YWJzKCl7cmV0dXJuIHRoaXMueD1NYXRoLmFicyh0aGlzLngpLHRoaXMueT1NYXRoLmFicyh0aGlzLnkpLHRoaXN9bnVkZ2UoZSx0KXtjb25zdCByPWh0LlRhbihlLHRoaXMpO3JldHVybiB0aGlzLmFkZChyLm11bCh0KSl9bmVnKCl7cmV0dXJuIHRoaXMueCo9LTEsdGhpcy55Kj0tMSx0aGlzfWNyb3NzKGUpe3JldHVybiB0aGlzLng9dGhpcy55KmUuei10aGlzLnoqZS55LHRoaXMueT10aGlzLnoqZS54LXRoaXMueCplLnosdGhpc31kcHIoZSl7cmV0dXJuIGh0LkRwcih0aGlzLGUpfWNwcihlKXtyZXR1cm4gaHQuQ3ByKHRoaXMsZSl9bGVuMigpe3JldHVybiBodC5MZW4yKHRoaXMpfWxlbigpe3JldHVybiBodC5MZW4odGhpcyl9cHJ5KGUpe3JldHVybiBodC5QcnkodGhpcyxlKX1wZXIoKXtjb25zdHt4OmUseTp0fT10aGlzO3JldHVybiB0aGlzLng9dCx0aGlzLnk9LWUsdGhpc311bmkoKXtyZXR1cm4gaHQuVW5pKHRoaXMpfXRhbihlKXtyZXR1cm4gaHQuVGFuKHRoaXMsZSl9ZGlzdChlKXtyZXR1cm4gaHQuRGlzdCh0aGlzLGUpfWRpc3RhbmNlVG9MaW5lU2VnbWVudChlLHQpe3JldHVybiBodC5EaXN0YW5jZVRvTGluZVNlZ21lbnQoZSx0LHRoaXMpfXNsb3BlKGUpe3JldHVybiBodC5TbG9wZSh0aGlzLGUpfXNuYXBUb0dyaWQoZSl7cmV0dXJuIHRoaXMueD1NYXRoLnJvdW5kKHRoaXMueC9lKSplLHRoaXMueT1NYXRoLnJvdW5kKHRoaXMueS9lKSplLHRoaXN9YW5nbGUoZSl7cmV0dXJuIGh0LkFuZ2xlKHRoaXMsZSl9dG9BbmdsZSgpe3JldHVybiBodC5Ub0FuZ2xlKHRoaXMpfWxycChlLHQpe3JldHVybiB0aGlzLng9dGhpcy54KyhlLngtdGhpcy54KSp0LHRoaXMueT10aGlzLnkrKGUueS10aGlzLnkpKnQsdGhpc31lcXVhbHMoZSx0KXtyZXR1cm4gaHQuRXF1YWxzKHRoaXMsZSx0KX1lcXVhbHNYWShlLHQpe3JldHVybiBodC5FcXVhbHNYWSh0aGlzLGUsdCl9bm9ybSgpe2NvbnN0IGU9dGhpcy5sZW4oKTtyZXR1cm4gdGhpcy54PWU9PT0wPzA6dGhpcy54L2UsdGhpcy55PWU9PT0wPzA6dGhpcy55L2UsdGhpc310b0ZpeGVkKCl7cmV0dXJuIGh0LlRvRml4ZWQodGhpcyl9dG9TdHJpbmcoKXtyZXR1cm4gaHQuVG9TdHJpbmcoaHQuVG9GaXhlZCh0aGlzKSl9dG9Kc29uKCl7cmV0dXJuIGh0LlRvSnNvbih0aGlzKX10b0FycmF5KCl7cmV0dXJuIGh0LlRvQXJyYXkodGhpcyl9c3RhdGljIEFkZChlLHQpe3JldHVybiBuZXcgaHQoZS54K3QueCxlLnkrdC55KX1zdGF0aWMgQWRkWFkoZSx0LHIpe3JldHVybiBuZXcgaHQoZS54K3QsZS55K3IpfXN0YXRpYyBTdWIoZSx0KXtyZXR1cm4gbmV3IGh0KGUueC10LngsZS55LXQueSl9c3RhdGljIFN1YlhZKGUsdCxyKXtyZXR1cm4gbmV3IGh0KGUueC10LGUueS1yKX1zdGF0aWMgQWRkU2NhbGFyKGUsdCl7cmV0dXJuIG5ldyBodChlLngrdCxlLnkrdCl9c3RhdGljIFN1YlNjYWxhcihlLHQpe3JldHVybiBuZXcgaHQoZS54LXQsZS55LXQpfXN0YXRpYyBEaXYoZSx0KXtyZXR1cm4gbmV3IGh0KGUueC90LGUueS90KX1zdGF0aWMgTXVsKGUsdCl7cmV0dXJuIG5ldyBodChlLngqdCxlLnkqdCl9c3RhdGljIERpdlYoZSx0KXtyZXR1cm4gbmV3IGh0KGUueC90LngsZS55L3QueSl9c3RhdGljIE11bFYoZSx0KXtyZXR1cm4gbmV3IGh0KGUueCp0LngsZS55KnQueSl9c3RhdGljIE5lZyhlKXtyZXR1cm4gbmV3IGh0KC1lLngsLWUueSl9c3RhdGljIFBlcihlKXtyZXR1cm4gbmV3IGh0KGUueSwtZS54KX1zdGF0aWMgRGlzdDIoZSx0KXtyZXR1cm4gaHQuU3ViKGUsdCkubGVuMigpfXN0YXRpYyBBYnMoZSl7cmV0dXJuIG5ldyBodChNYXRoLmFicyhlLngpLE1hdGguYWJzKGUueSkpfXN0YXRpYyBEaXN0KGUsdCl7cmV0dXJuIE1hdGguaHlwb3QoZS55LXQueSxlLngtdC54KX1zdGF0aWMgRHByKGUsdCl7cmV0dXJuIGUueCp0LngrZS55KnQueX1zdGF0aWMgQ3Jvc3MoZSx0KXtyZXR1cm4gbmV3IGh0KGUueSp0LnotZS56KnQueSxlLnoqdC54LWUueCp0LnopfXN0YXRpYyBDcHIoZSx0KXtyZXR1cm4gZS54KnQueS10LngqZS55fXN0YXRpYyBMZW4yKGUpe3JldHVybiBlLngqZS54K2UueSplLnl9c3RhdGljIExlbihlKXtyZXR1cm4gTWF0aC5oeXBvdChlLngsZS55KX1zdGF0aWMgUHJ5KGUsdCl7cmV0dXJuIGh0LkRwcihlLHQpL2h0Lkxlbih0KX1zdGF0aWMgVW5pKGUpe3JldHVybiBodC5EaXYoZSxodC5MZW4oZSkpfXN0YXRpYyBUYW4oZSx0KXtyZXR1cm4gaHQuVW5pKGh0LlN1YihlLHQpKX1zdGF0aWMgTWluKGUsdCl7cmV0dXJuIG5ldyBodChNYXRoLm1pbihlLngsdC54KSxNYXRoLm1pbihlLnksdC55KSl9c3RhdGljIE1heChlLHQpe3JldHVybiBuZXcgaHQoTWF0aC5tYXgoZS54LHQueCksTWF0aC5tYXgoZS55LHQueSkpfXN0YXRpYyBGcm9tKGUpe3JldHVybiBuZXcgaHQoKS5hZGQoZSl9c3RhdGljIEZyb21BcnJheShlKXtyZXR1cm4gbmV3IGh0KGVbMF0sZVsxXSl9c3RhdGljIFJvdChlLHQ9MCl7Y29uc3Qgcj1NYXRoLnNpbih0KSxzPU1hdGguY29zKHQpO3JldHVybiBuZXcgaHQoZS54KnMtZS55KnIsZS54KnIrZS55KnMpfXN0YXRpYyBSb3RXaXRoKGUsdCxyKXtjb25zdCBzPWUueC10LngsZz1lLnktdC55LHY9TWF0aC5zaW4ociksaD1NYXRoLmNvcyhyKTtyZXR1cm4gbmV3IGh0KHQueCsocypoLWcqdiksdC55KyhzKnYrZypoKSl9c3RhdGljIE5lYXJlc3RQb2ludE9uTGluZVRocm91Z2hQb2ludChlLHQscil7cmV0dXJuIGh0Lk11bCh0LGh0LlN1YihyLGUpLnByeSh0KSkuYWRkKGUpfXN0YXRpYyBOZWFyZXN0UG9pbnRPbkxpbmVTZWdtZW50KGUsdCxyLHM9ITApe2NvbnN0IGc9aHQuVGFuKHQsZSksdj1odC5BZGQoZSxodC5NdWwoZyxodC5TdWIocixlKS5wcnkoZykpKTtpZihzKXtpZih2Lng8TWF0aC5taW4oZS54LHQueCkpcmV0dXJuIGh0LkNhc3QoZS54PHQueD9lOnQpO2lmKHYueD5NYXRoLm1heChlLngsdC54KSlyZXR1cm4gaHQuQ2FzdChlLng+dC54P2U6dCk7aWYodi55PE1hdGgubWluKGUueSx0LnkpKXJldHVybiBodC5DYXN0KGUueTx0Lnk/ZTp0KTtpZih2Lnk+TWF0aC5tYXgoZS55LHQueSkpcmV0dXJuIGh0LkNhc3QoZS55PnQueT9lOnQpfXJldHVybiB2fXN0YXRpYyBEaXN0YW5jZVRvTGluZVRocm91Z2hQb2ludChlLHQscil7cmV0dXJuIGh0LkRpc3QocixodC5OZWFyZXN0UG9pbnRPbkxpbmVUaHJvdWdoUG9pbnQoZSx0LHIpKX1zdGF0aWMgRGlzdGFuY2VUb0xpbmVTZWdtZW50KGUsdCxyLHM9ITApe3JldHVybiBodC5EaXN0KHIsaHQuTmVhcmVzdFBvaW50T25MaW5lU2VnbWVudChlLHQscixzKSl9c3RhdGljIFNuYXAoZSx0PTEpe3JldHVybiBuZXcgaHQoTWF0aC5yb3VuZChlLngvdCkqdCxNYXRoLnJvdW5kKGUueS90KSp0KX1zdGF0aWMgQ2FzdChlKXtyZXR1cm4gZSBpbnN0YW5jZW9mIGh0P2U6aHQuRnJvbShlKX1zdGF0aWMgU2xvcGUoZSx0KXtyZXR1cm4gZS54PT09dC55P05hTjooZS55LXQueSkvKGUueC10LngpfXN0YXRpYyBBbmdsZShlLHQpe3JldHVybiBNYXRoLmF0YW4yKHQueS1lLnksdC54LWUueCl9c3RhdGljIExycChlLHQscil7cmV0dXJuIGh0LlN1Yih0LGUpLm11bChyKS5hZGQoZSl9c3RhdGljIE1lZChlLHQpe3JldHVybiBuZXcgaHQoKGUueCt0LngpLzIsKGUueSt0LnkpLzIpfXN0YXRpYyBFcXVhbHMoZSx0LHI9MWUtNCl7cmV0dXJuIE1hdGguYWJzKGUueC10LngpPHImJk1hdGguYWJzKGUueS10LnkpPHJ9c3RhdGljIEVxdWFsc1hZKGUsdCxyKXtyZXR1cm4gZS54PT09dCYmZS55PT09cn1zdGF0aWMgRXF1YWxzWFlaKGUsdCxyPTFlLTQpe3JldHVybiBodC5FcXVhbHMoZSx0LHIpJiZNYXRoLmFicygoZS56fHwwKS0odC56fHwwKSk8cn1zdGF0aWMgQ2xvY2t3aXNlKGUsdCxyKXtyZXR1cm4oci54LWUueCkqKHQueS1lLnkpLSh0LngtZS54KSooci55LWUueSk8MH1zdGF0aWMgUmVzY2FsZShlLHQpe2NvbnN0IHI9aHQuTGVuKGUpO3JldHVybiBuZXcgaHQodCplLngvcix0KmUueS9yKX1zdGF0aWMgU2NhbGVXaXRoT3JpZ2luKGUsdCxyKXtyZXR1cm4gaHQuU3ViKGUscikubXVsKHQpLmFkZChyKX1zdGF0aWMgU2NhbGVXT3JpZ2luKGUsdCxyKXtyZXR1cm4gaHQuU3ViKGUscikubXVsVih0KS5hZGQocil9c3RhdGljIFRvRml4ZWQoZSx0PTIpe3JldHVybiBuZXcgaHQoK2UueC50b0ZpeGVkKHQpLCtlLnkudG9GaXhlZCh0KSwrZS56LnRvRml4ZWQodCkpfXN0YXRpYyBOdWRnZShlLHQscil7cmV0dXJuIGh0LkFkZChlLGh0LlRhbih0LGUpLm11bChyKSl9c3RhdGljIFRvU3RyaW5nKGUpe3JldHVybmAke2UueH0sICR7ZS55fWB9c3RhdGljIFRvQW5nbGUoZSl7bGV0IHQ9TWF0aC5hdGFuMihlLnksZS54KTtyZXR1cm4gdDwwJiYodCs9TWF0aC5QSSoyKSx0fXN0YXRpYyBGcm9tQW5nbGUoZSx0PTEpe3JldHVybiBuZXcgaHQoTWF0aC5jb3MoZSkqdCxNYXRoLnNpbihlKSp0KX1zdGF0aWMgVG9BcnJheShlKXtyZXR1cm5bZS54LGUueSxlLnpdfXN0YXRpYyBUb0pzb24oZSl7Y29uc3R7eDp0LHk6cix6OnN9PWU7cmV0dXJue3g6dCx5OnIsejpzfX1zdGF0aWMgQXZlcmFnZShlKXtjb25zdCB0PWUubGVuZ3RoLHI9bmV3IGh0KDAsMCk7Zm9yKGxldCBzPTA7czx0O3MrKylyLmFkZChlW3NdKTtyZXR1cm4gci5kaXYodCl9c3RhdGljIENsYW1wKGUsdCxyKXtyZXR1cm4gcj09PXZvaWQgMD9uZXcgaHQoTWF0aC5taW4oTWF0aC5tYXgoZS54LHQpKSxNYXRoLm1pbihNYXRoLm1heChlLnksdCkpKTpuZXcgaHQoTWF0aC5taW4oTWF0aC5tYXgoZS54LHQpLHIpLE1hdGgubWluKE1hdGgubWF4KGUueSx0KSxyKSl9c3RhdGljIFBvaW50c0JldHdlZW4oZSx0LHI9Nil7Y29uc3Qgcz1bXTtmb3IobGV0IGc9MDtnPHI7ZysrKXtjb25zdCB2PXNuLmVhc2VJblF1YWQoZy8oci0xKSksaD1odC5McnAoZSx0LHYpO2guej1NYXRoLm1pbigxLC41K01hdGguYWJzKC41LWFuKHYpKSouNjUpLHMucHVzaChoKX1yZXR1cm4gc31zdGF0aWMgU25hcFRvR3JpZChlLHQ9OCl7cmV0dXJuIG5ldyBodChNYXRoLnJvdW5kKGUueC90KSp0LE1hdGgucm91bmQoZS55L3QpKnQpfX1jb25zdCBhbj1jPT5jPC41PzIqYypjOi0xKyg0LTIqYykqYztjbGFzcyBQdCBleHRlbmRzIGh0e2NvbnN0cnVjdG9yKGU9MCx0PTAscj0wLHM9e3g6MCx5OjB9LGc9MCx2PTApe3N1cGVyKGUsdCxyKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywieCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOmV9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywieSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnR9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywieiIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnJ9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidiIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnN9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOmd9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiYSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZ9KX1nZXQgdGltZXN0YW1wKCl7cmV0dXJuIHRoaXMudH1nZXQgcHJlc3N1cmUoKXtyZXR1cm4gdGhpcy56fWdldCBhbmdsZU51bSgpe3JldHVybiB0aGlzLmF9Z2V0IFhZKCl7cmV0dXJuW3RoaXMueCx0aGlzLnldfXNldEEoZSl7dGhpcy5hPWV9c2V0VChlKXt0aGlzLnQ9ZX1zZXR2KGUpe3JldHVybiB0aGlzLnY9e3g6ZS54LHk6ZS55fSx0aGlzfXNldChlPXRoaXMueCx0PXRoaXMueSxyPXRoaXMueixzPXRoaXMudixnPXRoaXMudCx2PXRoaXMuYSl7cmV0dXJuIHRoaXMueD1lLHRoaXMueT10LHRoaXMuej1yLHRoaXMudj1zLHRoaXMudD1nLHRoaXMuYT12LHRoaXN9Y2xvbmUoKXtjb25zdHt4OmUseTp0LHo6cix2OnMsdDpnLGE6dn09dGhpcyxoPXt4OnMueCx5OnMueX07cmV0dXJuIG5ldyBQdChlLHQscixoLGcsdil9ZGlzdGFuY2UoZSl7cmV0dXJuIFB0LkdldERpc3RhbmNlKHRoaXMsZSl9aXNOZWFyKGUsdCl7cmV0dXJuIFB0LklzTmVhcih0aGlzLGUsdCl9Z2V0QW5nbGVCeVBvaW50cyhlLHQpe3JldHVybiBQdC5HZXRBbmdsZUJ5UG9pbnRzKGUsdGhpcyx0KX1zdGF0aWMgU3ViKGUsdCl7cmV0dXJuIG5ldyBQdChlLngtdC54LGUueS10LnkpfXN0YXRpYyBBZGQoZSx0KXtyZXR1cm4gbmV3IFB0KGUueCt0LngsZS55K3QueSl9c3RhdGljIEdldERpc3RhbmNlKGUsdCl7cmV0dXJuIFB0LkxlbihlLmNsb25lKCkuc3ViKHQpKX1zdGF0aWMgR2V0QW5nbGVCeVBvaW50cyhlLHQscil7Y29uc3Qgcz10LngtZS54LGc9ci54LXQueCx2PXQueS1lLnksaD1yLnktdC55O2xldCBsPTA7Y29uc3QgdT1NYXRoLnNxcnQocypzK3YqdiksTT1NYXRoLnNxcnQoZypnK2gqaCk7aWYodSYmTSl7Y29uc3QgZj1zKmcrdipoO2w9TWF0aC5hY29zKGYvKHUqTSkpLGw9bC9NYXRoLlBJKjE4MDtsZXQgeT1zKmgtdipnO3k9eT4wPzE6LTEsbD0xODAreSpsfXJldHVybiBsfXN0YXRpYyBJc05lYXIoZSx0LHIpe3JldHVybiBQdC5MZW4oZS5jbG9uZSgpLnN1Yih0KSk8cn1zdGF0aWMgUm90V2l0aChlLHQscixzPTIpe2NvbnN0IGc9ZS54LXQueCx2PWUueS10LnksaD1NYXRoLnNpbihyKSxsPU1hdGguY29zKHIpLHU9TWF0aC5wb3coMTAscyksTT1NYXRoLmZsb29yKCh0LngrKGcqbC12KmgpKSp1KS91LGY9TWF0aC5mbG9vcigodC55KyhnKmgrdipsKSkqdSkvdTtyZXR1cm4gbmV3IFB0KE0sZil9c3RhdGljIEdldERvdFN0cm9rZShlLHQscj0xNil7Y29uc3Qgcz1uZXcgaHQoMSwxKSxnPU1hdGguUEkrLjAwMSx2PVB0LkFkZChlLFB0LlN1YihlLHMpLnVuaSgpLnBlcigpLm11bCgtdCkpLGg9W107Zm9yKGxldCBsPTEvcix1PWw7dTw9MTt1Kz1sKWgucHVzaChQdC5Sb3RXaXRoKHYsZSxnKjIqdSkpO3JldHVybiBofXN0YXRpYyBHZXRTZW1pY2lyY2xlU3Ryb2tlKGUsdCxyPS0xLHM9OCl7Y29uc3QgZz1yKihNYXRoLlBJKy4wMDEpLHY9W107Zm9yKGxldCBoPTEvcyxsPWg7bDw9MTtsKz1oKXYucHVzaChQdC5Sb3RXaXRoKHQsZSxnKmwpKTtyZXR1cm4gdn19dmFyIHJyOyhmdW5jdGlvbihjKXtjW2MucGVkZGluZz0wXT0icGVkZGluZyIsY1tjLm1vdW50ZWQ9MV09Im1vdW50ZWQiLGNbYy51cGRhdGU9Ml09InVwZGF0ZSIsY1tjLnVubW91bnRlZD0zXT0idW5tb3VudGVkIn0pKHJyfHwocnI9e30pKTt2YXIgYnQ7KGZ1bmN0aW9uKGMpe2NbYy5Ob3JtYWw9MF09Ik5vcm1hbCIsY1tjLlN0cm9rZT0xXT0iU3Ryb2tlIixjW2MuRG90dGVkPTJdPSJEb3R0ZWQiLGNbYy5Mb25nRG90dGVkPTNdPSJMb25nRG90dGVkIn0pKGJ0fHwoYnQ9e30pKTt2YXIgbnI7KGZ1bmN0aW9uKGMpe2MuU2hvd0Zsb2F0QmFyPSJTaG93RmxvYXRCYXIiLGMuWkluZGV4RmxvYXRCYXI9IlpJbmRleEZsb2F0QmFyIixjLkRlbGV0ZU5vZGU9IkRlbGV0ZU5vZGUiLGMuQ29weU5vZGU9IkNvcHlOb2RlIixjLlpJbmRleEFjdGl2ZT0iWkluZGV4QWN0aXZlIixjLlpJbmRleE5vZGU9IlpJbmRleE5vZGUiLGMuUm90YXRlTm9kZT0iUm90YXRlTm9kZSIsYy5TZXRDb2xvck5vZGU9IlNldENvbG9yTm9kZSIsYy5UcmFuc2xhdGVOb2RlPSJUcmFuc2xhdGVOb2RlIixjLlNjYWxlTm9kZT0iU2NhbGVOb2RlIixjLk9yaWdpbmFsRXZlbnQ9Ik9yaWdpbmFsRXZlbnQiLGMuQ3JlYXRlU2NlbmU9ImNyZWF0ZVNjZW5lIixjLkFjdGl2ZUN1cnNvcj0iQWN0aXZlQ3Vyc29yIixjLk1vdmVDdXJzb3I9Ik1vdmVDdXJzb3IifSkobnJ8fChucj17fSkpO3ZhciBpcjsoZnVuY3Rpb24oYyl7Yy5EaXNwbGF5U3RhdGU9IkRpc3BsYXlTdGF0ZSIsYy5GbG9hdEJhcj0iRmxvYXRCYXIiLGMuQ2FudmFzU2VsZWN0b3I9IkNhbnZhc1NlbGVjdG9yIixjLk1haW5FbmdpbmU9Ik1haW5FbmdpbmUiLGMuRGlzcGxheUNvbnRhaW5lcj0iRGlzcGxheUNvbnRhaW5lciIsYy5DdXJzb3I9IkN1cnNvciJ9KShpcnx8KGlyPXt9KSk7ZnVuY3Rpb24gQ3QoYyxlKXtpZihjJiZlKXtjb25zdCB0PU1hdGgubWluKGMueCxlLngpLHI9TWF0aC5taW4oYy55LGUueSkscz1NYXRoLm1heChjLngrYy53LGUueCtlLncpLGc9TWF0aC5tYXgoYy55K2MuaCxlLnkrZS5oKSx2PXMtdCxoPWctcjtyZXR1cm57eDp0LHk6cix3OnYsaH19cmV0dXJuIGV8fGN9ZnVuY3Rpb24gSHQoYyxlPTApe2NvbnN0IHQ9e3g6MCx5OjAsdzowLGg6MH07bGV0IHI9MS8wLHM9MS8wLGc9LTEvMCx2PS0xLzA7cmV0dXJuIGMuZm9yRWFjaChoPT57Y29uc3RbbCx1XT1oLlhZO3I9TWF0aC5taW4ocixsLWUpLHM9TWF0aC5taW4ocyx1LWUpLGc9TWF0aC5tYXgoZyxsK2UpLHY9TWF0aC5tYXgodix1K2UpfSksdC54PXIsdC55PXMsdC53PWctcix0Lmg9di1zLHR9ZnVuY3Rpb24gc3IoYyxlKXtyZXR1cm4hKGMueCtjLnc8ZS54fHxjLng+ZS54K2Uud3x8Yy55K2MuaDxlLnl8fGMueT5lLnkrZS5oKX1mdW5jdGlvbiBvbihjLGUpe3JldHVybiBjLmxlbmd0aD09PWUubGVuZ3RoJiZjLnNvcnQoKS50b1N0cmluZygpPT09ZS5zb3J0KCkudG9TdHJpbmcoKX1mdW5jdGlvbiBsbihjLGUpe2NvbnN0IHQ9bmV3IGh0KGMueCxjLnkpLHI9bmV3IGh0KGMueCtjLncsYy55KSxzPW5ldyBodChjLngrYy53LGMueStjLmgpLGc9bmV3IGh0KGMueCxjLnkrYy5oKSx2PW5ldyBodChjLngrYy53LzIsYy55K2MuaC8yKSxoPU1hdGguUEkqZS8xODAsbD1odC5Sb3RXaXRoKHQsdixoKSx1PWh0LlJvdFdpdGgocix2LGgpLE09aHQuUm90V2l0aChzLHYsaCksZj1odC5Sb3RXaXRoKGcsdixoKTtyZXR1cm4gSHQoW2wsdSxNLGZdKX1mdW5jdGlvbiBmbihjLGUpe2NvbnN0IHQ9bmV3IGh0KGMueCxjLnkpLHI9bmV3IGh0KGMueCtjLncsYy55KSxzPW5ldyBodChjLngrYy53LGMueStjLmgpLGc9bmV3IGh0KGMueCxjLnkrYy5oKSx2PW5ldyBodChjLngrYy53LzIsYy55K2MuaC8yKSxoPW5ldyBodChlWzBdLGVbMV0pLGw9aHQuU2NhbGVXT3JpZ2luKHQsaCx2KSx1PWh0LlNjYWxlV09yaWdpbihyLGgsdiksTT1odC5TY2FsZVdPcmlnaW4ocyxoLHYpLGY9aHQuU2NhbGVXT3JpZ2luKGcsaCx2KTtyZXR1cm4gSHQoW2wsdSxNLGZdKX1mdW5jdGlvbiBadChjLGUpe2xldCB0O3JldHVybiBlPT1udWxsfHxlLmdldEVsZW1lbnRzQnlOYW1lKGMpLmZvckVhY2gocj0+e2lmKHIudGFnTmFtZT09PSJQQVRIIil7Y29uc3Qgcz1yPT1udWxsP3ZvaWQgMDpyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO3MmJih0PUN0KHQse3g6TWF0aC5mbG9vcihzLngpLHk6TWF0aC5mbG9vcihzLnkpLHc6TWF0aC5yb3VuZChzLndpZHRoKSxoOk1hdGgucm91bmQocy5oZWlnaHQpfSkpfWVsc2UgaWYoci50YWdOYW1lPT09IkdST1VQIil7Y29uc3Qgcz1yLmNsYXNzTmFtZS5zcGxpdCgiLCIpO2lmKHMubGVuZ3RoPT09MyYmTnVtYmVyKHNbMl0pPT09YnQuU3Ryb2tlKXtjb25zdCBnPXI9PW51bGw/dm9pZCAwOnIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7ZyYmKHQ9Q3QodCx7eDpNYXRoLmZsb29yKGcueCkseTpNYXRoLmZsb29yKGcueSksdzpNYXRoLnJvdW5kKGcud2lkdGgpLGg6TWF0aC5yb3VuZChnLmhlaWdodCl9KSl9ZWxzZSByLmNoaWxkcmVuLmZvckVhY2goZz0+e2lmKGcudGFnTmFtZT09PSJQQVRIIil7Y29uc3Qgdj1nPT1udWxsP3ZvaWQgMDpnLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO3YmJih0PUN0KHQse3g6TWF0aC5mbG9vcih2LngpLHk6TWF0aC5mbG9vcih2LnkpLHc6TWF0aC5yb3VuZCh2LndpZHRoKSxoOk1hdGgucm91bmQodi5oZWlnaHQpfSkpfX0pfX0pLHR9ZnVuY3Rpb24gcXQoYyl7cmV0dXJuYCR7ZGUoYy54KX0sJHtkZShjLnkpfSBgfWZ1bmN0aW9uIGt0KGMsZSl7cmV0dXJuYCR7ZGUoKGMueCtlLngpLzIpfSwke2RlKChjLnkrZS55KS8yKX0gYH1mdW5jdGlvbiBkZShjKXtyZXR1cm4rYy50b0ZpeGVkKDQpfWZ1bmN0aW9uIGdlKGMsZT0hMCl7Y29uc3QgdD1jLmxlbmd0aDtpZih0PDIpcmV0dXJuIiI7bGV0IHI9Y1swXSxzPWNbMV07aWYodD09PTIpcmV0dXJuYE0ke3F0KHIpfUwke3F0KHMpfWA7bGV0IGc9IiI7Zm9yKGxldCB2PTIsaD10LTE7djxoO3YrKylyPWNbdl0scz1jW3YrMV0sZys9a3QocixzKTtyZXR1cm4gZT9gTSR7a3QoY1swXSxjWzFdKX1RJHtxdChjWzFdKX0ke2t0KGNbMV0sY1syXSl9VCR7Z30ke2t0KGNbdC0xXSxjWzBdKX0ke2t0KGNbMF0sY1sxXSl9WmA6YE0ke3F0KGNbMF0pfVEke3F0KGNbMV0pfSR7a3QoY1sxXSxjWzJdKX0ke2MubGVuZ3RoPjM/IlQiOiIifSR7Z31MJHtxdChjW3QtMV0pfWB9dmFyIG1lPXR5cGVvZiBnbG9iYWxUaGlzPCJ1Ij9nbG9iYWxUaGlzOnR5cGVvZiB3aW5kb3c8InUiP3dpbmRvdzp0eXBlb2YgZ2xvYmFsPCJ1Ij9nbG9iYWw6dHlwZW9mIHNlbGY8InUiP3NlbGY6e307ZnVuY3Rpb24gUmUoYyl7cmV0dXJuIGMmJmMuX19lc01vZHVsZSYmT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGMsImRlZmF1bHQiKT9jLmRlZmF1bHQ6Y312YXIgQ2U9e2V4cG9ydHM6e319O0NlLmV4cG9ydHMsZnVuY3Rpb24oYyl7dmFyIGU9ZnVuY3Rpb24oKXt2YXIgdD1TdHJpbmcuZnJvbUNoYXJDb2RlLHI9IkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89IixzPSJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSstJCIsZz17fTtmdW5jdGlvbiB2KGwsdSl7aWYoIWdbbF0pe2dbbF09e307Zm9yKHZhciBNPTA7TTxsLmxlbmd0aDtNKyspZ1tsXVtsLmNoYXJBdChNKV09TX1yZXR1cm4gZ1tsXVt1XX12YXIgaD17Y29tcHJlc3NUb0Jhc2U2NDpmdW5jdGlvbihsKXtpZihsPT1udWxsKXJldHVybiIiO3ZhciB1PWguX2NvbXByZXNzKGwsNixmdW5jdGlvbihNKXtyZXR1cm4gci5jaGFyQXQoTSl9KTtzd2l0Y2godS5sZW5ndGglNCl7ZGVmYXVsdDpjYXNlIDA6cmV0dXJuIHU7Y2FzZSAxOnJldHVybiB1KyI9PT0iO2Nhc2UgMjpyZXR1cm4gdSsiPT0iO2Nhc2UgMzpyZXR1cm4gdSsiPSJ9fSxkZWNvbXByZXNzRnJvbUJhc2U2NDpmdW5jdGlvbihsKXtyZXR1cm4gbD09bnVsbD8iIjpsPT0iIj9udWxsOmguX2RlY29tcHJlc3MobC5sZW5ndGgsMzIsZnVuY3Rpb24odSl7cmV0dXJuIHYocixsLmNoYXJBdCh1KSl9KX0sY29tcHJlc3NUb1VURjE2OmZ1bmN0aW9uKGwpe3JldHVybiBsPT1udWxsPyIiOmguX2NvbXByZXNzKGwsMTUsZnVuY3Rpb24odSl7cmV0dXJuIHQodSszMil9KSsiICJ9LGRlY29tcHJlc3NGcm9tVVRGMTY6ZnVuY3Rpb24obCl7cmV0dXJuIGw9PW51bGw/IiI6bD09IiI/bnVsbDpoLl9kZWNvbXByZXNzKGwubGVuZ3RoLDE2Mzg0LGZ1bmN0aW9uKHUpe3JldHVybiBsLmNoYXJDb2RlQXQodSktMzJ9KX0sY29tcHJlc3NUb1VpbnQ4QXJyYXk6ZnVuY3Rpb24obCl7Zm9yKHZhciB1PWguY29tcHJlc3MobCksTT1uZXcgVWludDhBcnJheSh1Lmxlbmd0aCoyKSxmPTAseT11Lmxlbmd0aDtmPHk7ZisrKXt2YXIgeD11LmNoYXJDb2RlQXQoZik7TVtmKjJdPXg+Pj44LE1bZioyKzFdPXglMjU2fXJldHVybiBNfSxkZWNvbXByZXNzRnJvbVVpbnQ4QXJyYXk6ZnVuY3Rpb24obCl7aWYobD09bnVsbClyZXR1cm4gaC5kZWNvbXByZXNzKGwpO2Zvcih2YXIgdT1uZXcgQXJyYXkobC5sZW5ndGgvMiksTT0wLGY9dS5sZW5ndGg7TTxmO00rKyl1W01dPWxbTSoyXSoyNTYrbFtNKjIrMV07dmFyIHk9W107cmV0dXJuIHUuZm9yRWFjaChmdW5jdGlvbih4KXt5LnB1c2godCh4KSl9KSxoLmRlY29tcHJlc3MoeS5qb2luKCIiKSl9LGNvbXByZXNzVG9FbmNvZGVkVVJJQ29tcG9uZW50OmZ1bmN0aW9uKGwpe3JldHVybiBsPT1udWxsPyIiOmguX2NvbXByZXNzKGwsNixmdW5jdGlvbih1KXtyZXR1cm4gcy5jaGFyQXQodSl9KX0sZGVjb21wcmVzc0Zyb21FbmNvZGVkVVJJQ29tcG9uZW50OmZ1bmN0aW9uKGwpe3JldHVybiBsPT1udWxsPyIiOmw9PSIiP251bGw6KGw9bC5yZXBsYWNlKC8gL2csIisiKSxoLl9kZWNvbXByZXNzKGwubGVuZ3RoLDMyLGZ1bmN0aW9uKHUpe3JldHVybiB2KHMsbC5jaGFyQXQodSkpfSkpfSxjb21wcmVzczpmdW5jdGlvbihsKXtyZXR1cm4gaC5fY29tcHJlc3MobCwxNixmdW5jdGlvbih1KXtyZXR1cm4gdCh1KX0pfSxfY29tcHJlc3M6ZnVuY3Rpb24obCx1LE0pe2lmKGw9PW51bGwpcmV0dXJuIiI7dmFyIGYseSx4PXt9LGI9e30sTz0iIixtPSIiLHA9IiIsbj0yLGE9MyxpPTIsbz1bXSxUPTAsUD0wLEM7Zm9yKEM9MDtDPGwubGVuZ3RoO0MrPTEpaWYoTz1sLmNoYXJBdChDKSxPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCxPKXx8KHhbT109YSsrLGJbT109ITApLG09cCtPLE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LG0pKXA9bTtlbHNle2lmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLHApKXtpZihwLmNoYXJDb2RlQXQoMCk8MjU2KXtmb3IoZj0wO2Y8aTtmKyspVD1UPDwxLFA9PXUtMT8oUD0wLG8ucHVzaChNKFQpKSxUPTApOlArKztmb3IoeT1wLmNoYXJDb2RlQXQoMCksZj0wO2Y8ODtmKyspVD1UPDwxfHkmMSxQPT11LTE/KFA9MCxvLnB1c2goTShUKSksVD0wKTpQKysseT15Pj4xfWVsc2V7Zm9yKHk9MSxmPTA7ZjxpO2YrKylUPVQ8PDF8eSxQPT11LTE/KFA9MCxvLnB1c2goTShUKSksVD0wKTpQKysseT0wO2Zvcih5PXAuY2hhckNvZGVBdCgwKSxmPTA7ZjwxNjtmKyspVD1UPDwxfHkmMSxQPT11LTE/KFA9MCxvLnB1c2goTShUKSksVD0wKTpQKysseT15Pj4xfW4tLSxuPT0wJiYobj1NYXRoLnBvdygyLGkpLGkrKyksZGVsZXRlIGJbcF19ZWxzZSBmb3IoeT14W3BdLGY9MDtmPGk7ZisrKVQ9VDw8MXx5JjEsUD09dS0xPyhQPTAsby5wdXNoKE0oVCkpLFQ9MCk6UCsrLHk9eT4+MTtuLS0sbj09MCYmKG49TWF0aC5wb3coMixpKSxpKyspLHhbbV09YSsrLHA9U3RyaW5nKE8pfWlmKHAhPT0iIil7aWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIscCkpe2lmKHAuY2hhckNvZGVBdCgwKTwyNTYpe2ZvcihmPTA7ZjxpO2YrKylUPVQ8PDEsUD09dS0xPyhQPTAsby5wdXNoKE0oVCkpLFQ9MCk6UCsrO2Zvcih5PXAuY2hhckNvZGVBdCgwKSxmPTA7Zjw4O2YrKylUPVQ8PDF8eSYxLFA9PXUtMT8oUD0wLG8ucHVzaChNKFQpKSxUPTApOlArKyx5PXk+PjF9ZWxzZXtmb3IoeT0xLGY9MDtmPGk7ZisrKVQ9VDw8MXx5LFA9PXUtMT8oUD0wLG8ucHVzaChNKFQpKSxUPTApOlArKyx5PTA7Zm9yKHk9cC5jaGFyQ29kZUF0KDApLGY9MDtmPDE2O2YrKylUPVQ8PDF8eSYxLFA9PXUtMT8oUD0wLG8ucHVzaChNKFQpKSxUPTApOlArKyx5PXk+PjF9bi0tLG49PTAmJihuPU1hdGgucG93KDIsaSksaSsrKSxkZWxldGUgYltwXX1lbHNlIGZvcih5PXhbcF0sZj0wO2Y8aTtmKyspVD1UPDwxfHkmMSxQPT11LTE/KFA9MCxvLnB1c2goTShUKSksVD0wKTpQKysseT15Pj4xO24tLSxuPT0wJiYobj1NYXRoLnBvdygyLGkpLGkrKyl9Zm9yKHk9MixmPTA7ZjxpO2YrKylUPVQ8PDF8eSYxLFA9PXUtMT8oUD0wLG8ucHVzaChNKFQpKSxUPTApOlArKyx5PXk+PjE7Zm9yKDs7KWlmKFQ9VDw8MSxQPT11LTEpe28ucHVzaChNKFQpKTticmVha31lbHNlIFArKztyZXR1cm4gby5qb2luKCIiKX0sZGVjb21wcmVzczpmdW5jdGlvbihsKXtyZXR1cm4gbD09bnVsbD8iIjpsPT0iIj9udWxsOmguX2RlY29tcHJlc3MobC5sZW5ndGgsMzI3NjgsZnVuY3Rpb24odSl7cmV0dXJuIGwuY2hhckNvZGVBdCh1KX0pfSxfZGVjb21wcmVzczpmdW5jdGlvbihsLHUsTSl7dmFyIGY9W10seT00LHg9NCxiPTMsTz0iIixtPVtdLHAsbixhLGksbyxULFAsQz17dmFsOk0oMCkscG9zaXRpb246dSxpbmRleDoxfTtmb3IocD0wO3A8MztwKz0xKWZbcF09cDtmb3IoYT0wLG89TWF0aC5wb3coMiwyKSxUPTE7VCE9bzspaT1DLnZhbCZDLnBvc2l0aW9uLEMucG9zaXRpb24+Pj0xLEMucG9zaXRpb249PTAmJihDLnBvc2l0aW9uPXUsQy52YWw9TShDLmluZGV4KyspKSxhfD0oaT4wPzE6MCkqVCxUPDw9MTtzd2l0Y2goYSl7Y2FzZSAwOmZvcihhPTAsbz1NYXRoLnBvdygyLDgpLFQ9MTtUIT1vOylpPUMudmFsJkMucG9zaXRpb24sQy5wb3NpdGlvbj4+PTEsQy5wb3NpdGlvbj09MCYmKEMucG9zaXRpb249dSxDLnZhbD1NKEMuaW5kZXgrKykpLGF8PShpPjA/MTowKSpULFQ8PD0xO1A9dChhKTticmVhaztjYXNlIDE6Zm9yKGE9MCxvPU1hdGgucG93KDIsMTYpLFQ9MTtUIT1vOylpPUMudmFsJkMucG9zaXRpb24sQy5wb3NpdGlvbj4+PTEsQy5wb3NpdGlvbj09MCYmKEMucG9zaXRpb249dSxDLnZhbD1NKEMuaW5kZXgrKykpLGF8PShpPjA/MTowKSpULFQ8PD0xO1A9dChhKTticmVhaztjYXNlIDI6cmV0dXJuIiJ9Zm9yKGZbM109UCxuPVAsbS5wdXNoKFApOzspe2lmKEMuaW5kZXg+bClyZXR1cm4iIjtmb3IoYT0wLG89TWF0aC5wb3coMixiKSxUPTE7VCE9bzspaT1DLnZhbCZDLnBvc2l0aW9uLEMucG9zaXRpb24+Pj0xLEMucG9zaXRpb249PTAmJihDLnBvc2l0aW9uPXUsQy52YWw9TShDLmluZGV4KyspKSxhfD0oaT4wPzE6MCkqVCxUPDw9MTtzd2l0Y2goUD1hKXtjYXNlIDA6Zm9yKGE9MCxvPU1hdGgucG93KDIsOCksVD0xO1QhPW87KWk9Qy52YWwmQy5wb3NpdGlvbixDLnBvc2l0aW9uPj49MSxDLnBvc2l0aW9uPT0wJiYoQy5wb3NpdGlvbj11LEMudmFsPU0oQy5pbmRleCsrKSksYXw9KGk+MD8xOjApKlQsVDw8PTE7Zlt4KytdPXQoYSksUD14LTEseS0tO2JyZWFrO2Nhc2UgMTpmb3IoYT0wLG89TWF0aC5wb3coMiwxNiksVD0xO1QhPW87KWk9Qy52YWwmQy5wb3NpdGlvbixDLnBvc2l0aW9uPj49MSxDLnBvc2l0aW9uPT0wJiYoQy5wb3NpdGlvbj11LEMudmFsPU0oQy5pbmRleCsrKSksYXw9KGk+MD8xOjApKlQsVDw8PTE7Zlt4KytdPXQoYSksUD14LTEseS0tO2JyZWFrO2Nhc2UgMjpyZXR1cm4gbS5qb2luKCIiKX1pZih5PT0wJiYoeT1NYXRoLnBvdygyLGIpLGIrKyksZltQXSlPPWZbUF07ZWxzZSBpZihQPT09eClPPW4rbi5jaGFyQXQoMCk7ZWxzZSByZXR1cm4gbnVsbDttLnB1c2goTyksZlt4KytdPW4rTy5jaGFyQXQoMCkseS0tLG49Tyx5PT0wJiYoeT1NYXRoLnBvdygyLGIpLGIrKyl9fX07cmV0dXJuIGh9KCk7YyE9bnVsbD9jLmV4cG9ydHM9ZTp0eXBlb2YgYW5ndWxhcjwidSImJmFuZ3VsYXIhPW51bGwmJmFuZ3VsYXIubW9kdWxlKCJMWlN0cmluZyIsW10pLmZhY3RvcnkoIkxaU3RyaW5nIixmdW5jdGlvbigpe3JldHVybiBlfSl9KENlKTt2YXIgYXI9Q2UuZXhwb3J0cztmdW5jdGlvbiBvcihjKXtyZXR1cm4gSlNPTi5wYXJzZShhci5kZWNvbXByZXNzKGMpKX1mdW5jdGlvbiB1bihjKXtyZXR1cm4gYXIuY29tcHJlc3MoSlNPTi5zdHJpbmdpZnkoYykpfWNsYXNzIFV0IGV4dGVuZHMgaGV7Y29uc3RydWN0b3IoZSx0LHIpe3N1cGVyKHQsciksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInRvb2xzVHlwZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOkR0LlBlbmNpbH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzeW5jVGltZXN0YW1wIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInN5bmNJbmRleCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOjB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidG1wUG9pbnRzIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6W119KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiTUFYX1JFUEVBUiIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOjEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInVuaVRoaWNrbmVzcyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ3b3JrT3B0aW9ucyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJjZW50ZXJQb3MiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpbMCwwXX0pLHRoaXMud29ya09wdGlvbnM9ZSx0aGlzLnVuaVRoaWNrbmVzcz10aGlzLk1BWF9SRVBFQVIvZS50aGlja25lc3MvMTAsdGhpcy5zeW5jVGltZXN0YW1wPTB9Y29tYmluZUNvbnN1bWUoKXt2YXIgZztjb25zdCBlPShnPXRoaXMud29ya0lkKT09bnVsbD92b2lkIDA6Zy50b1N0cmluZygpLHQ9dGhpcy50cmFuc2Zvcm1EYXRhQWxsKCEwKSxyPXtuYW1lOmUsY2xhc3NOYW1lOiJwZW5jaWwifTtsZXQgcztyZXR1cm4gdC5sZW5ndGgmJihzPXRoaXMuZHJhdyh7YXR0cnM6cix0YXNrczp0LHJlcGxhY2VJZDplLGlzRnVsbFdvcms6ITEsbm9ybWFsaXplOiEwLGlzQ2xlYXJBbGw6ITB9KSkse3JlY3Q6cyx0eXBlOkV0LkRyYXdXb3JrLGRhdGFUeXBlOkx0LkxvY2FsfX1zZXRXb3JrT3B0aW9ucyhlKXtzdXBlci5zZXRXb3JrT3B0aW9ucyhlKSx0aGlzLnN5bmNUaW1lc3RhbXA9RGF0ZS5ub3coKX1jb25zdW1lKGUpe3ZhciBPO2NvbnN0e2RhdGE6dCxpc0Z1bGxXb3JrOnIsaXNDbGVhckFsbDpzLGlzU3ViV29ya2VyOmd9PWU7aWYoKChPPXQub3ApPT1udWxsP3ZvaWQgMDpPLmxlbmd0aCk9PT0wKXJldHVybnt0eXBlOkV0Lk5vbmV9O2NvbnN0e3dvcmtJZDp2fT10LHt0YXNrczpoLGVmZmVjdHM6bCxjb25zdW1lSW5kZXg6dX09dGhpcy50cmFuc2Zvcm1EYXRhKHQsITEpO3RoaXMuc3luY0luZGV4PU1hdGgubWluKHRoaXMuc3luY0luZGV4LHUpO2NvbnN0IE09e25hbWU6dj09bnVsbD92b2lkIDA6di50b1N0cmluZygpLGNsYXNzTmFtZToicGVuY2lsIn07bGV0IGYseT0hMTtjb25zdCB4PXRoaXMuc3luY0luZGV4O2lmKHRoaXMuc3luY1RpbWVzdGFtcD09PTAmJih0aGlzLnN5bmNUaW1lc3RhbXA9RGF0ZS5ub3coKSksaC5sZW5ndGgmJihoWzBdLnRhc2tJZC10aGlzLnN5bmNUaW1lc3RhbXA+dGhpcy5zeW5jVW5pdFRpbWUmJih5PSEwLHRoaXMuc3luY1RpbWVzdGFtcD1oWzBdLnRhc2tJZCx0aGlzLnN5bmNJbmRleD10aGlzLnRtcFBvaW50cy5sZW5ndGgpLGY9dGhpcy5kcmF3KHthdHRyczpNLHRhc2tzOmgsZWZmZWN0czpsLGlzRnVsbFdvcms6cixpc0NsZWFyQWxsOnN9KSksZylyZXR1cm4gdT4xMCYmdGhpcy50bXBQb2ludHMuc3BsaWNlKDAsdS0xMCkse3JlY3Q6Zix0eXBlOkV0LkRyYXdXb3JrLGRhdGFUeXBlOkx0LkxvY2FsfTtjb25zdCBiPVtdO3JldHVybiB0aGlzLnRtcFBvaW50cy5zbGljZSh4KS5mb3JFYWNoKG09PntiLnB1c2gobS54LG0ueSx0aGlzLmNvbXB1dFJhZGl1cyhtLnosdGhpcy53b3JrT3B0aW9ucy50aGlja25lc3MpKX0pLHtyZWN0OmYsdHlwZTpFdC5EcmF3V29yayxkYXRhVHlwZTpMdC5Mb2NhbCx3b3JrSWQ6eT92OnZvaWQgMCxvcDp5P2I6dm9pZCAwLGluZGV4Onk/eCozOnZvaWQgMH19Y29uc3VtZUFsbChlKXt2YXIgaCxsO2lmKGUuZGF0YSl7Y29uc3R7b3A6dSx3b3JrU3RhdGU6TX09ZS5kYXRhO3UhPW51bGwmJnUubGVuZ3RoJiZNPT09UXQuRG9uZSYmdGhpcy53b3JrT3B0aW9ucy5zdHJva2VUeXBlPT09YnQuU3Ryb2tlJiZ0aGlzLnVwZGF0ZVRlbXBQb2ludHNXaXRoUHJlc3N1cmVXaGVuRG9uZSh1KX1jb25zdCB0PShoPXRoaXMud29ya0lkKT09bnVsbD92b2lkIDA6aC50b1N0cmluZygpLHI9dGhpcy50cmFuc2Zvcm1EYXRhQWxsKCEwKSxzPXtuYW1lOnQsY2xhc3NOYW1lOiJwZW5jaWwifTtsZXQgZztyLmxlbmd0aCYmKGc9dGhpcy5kcmF3KHthdHRyczpzLHRhc2tzOnIscmVwbGFjZUlkOnQsaXNGdWxsV29yazohMCxub3JtYWxpemU6ITAsaXNDbGVhckFsbDohMX0pKTtjb25zdCB2PVtdO3JldHVybiB0aGlzLnRtcFBvaW50cy5tYXAodT0+e3YucHVzaCh1LngsdS55LHRoaXMuY29tcHV0UmFkaXVzKHUueix0aGlzLndvcmtPcHRpb25zLnRoaWNrbmVzcykpfSksdGhpcy5zeW5jVGltZXN0YW1wPTAsZGVsZXRlIHRoaXMud29ya09wdGlvbnMuc3luY1VuaXRUaW1lLHtyZWN0OmcsdHlwZTpFdC5GdWxsV29yayxkYXRhVHlwZTpMdC5Mb2NhbCx3b3JrSWQ6dCxvcHM6dW4odiksdXBkYXRlTm9kZU9wdDp7cG9zOnRoaXMuY2VudGVyUG9zLHVzZUFuaW1hdGlvbjohMH0sb3B0OnRoaXMud29ya09wdGlvbnMsdW5kb1RpY2tlcklkOihsPWUuZGF0YSk9PW51bGw/dm9pZCAwOmwudW5kb1RpY2tlcklkfX1jbGVhclRtcFBvaW50cygpe3RoaXMudG1wUG9pbnRzLmxlbmd0aD0wLHRoaXMuc3luY1RpbWVzdGFtcD0wLHRoaXMuc3luY0luZGV4PTB9Y29uc3VtZVNlcnZpY2UoZSl7dmFyIE07Y29uc3R7b3A6dCxpc0Z1bGxXb3JrOnIscmVwbGFjZUlkOnMsaXNDbGVhckFsbDpnfT1lO3RoaXMudG1wUG9pbnRzLmxlbmd0aD0wO2ZvcihsZXQgZj0wO2Y8dC5sZW5ndGg7Zis9Myl7Y29uc3QgeT1uZXcgUHQodFtmXSx0W2YrMV0sdFtmKzJdKTtpZih0aGlzLnRtcFBvaW50cy5sZW5ndGg+MCl7Y29uc3QgeD10aGlzLnRtcFBvaW50c1t0aGlzLnRtcFBvaW50cy5sZW5ndGgtMV0sYj1odC5TdWIoeSx4KS51bmkoKTt5LnNldHYoYil9dGhpcy50bXBQb2ludHMucHVzaCh5KX1jb25zdCB2PXRoaXMudHJhbnNmb3JtRGF0YUFsbCghMSksbD17bmFtZTooTT10aGlzLndvcmtJZCk9PW51bGw/dm9pZCAwOk0udG9TdHJpbmcoKSxjbGFzc05hbWU6InBlbmNpbCJ9O2xldCB1O3JldHVybiB2Lmxlbmd0aCYmKHU9dGhpcy5kcmF3KHthdHRyczpsLHRhc2tzOnYscmVwbGFjZUlkOnMsaXNGdWxsV29yazpyLG5vcm1hbGl6ZTohMCxpc0NsZWFyQWxsOmd9KSksdX10cmFuc2Zvcm1EYXRhQWxsKGU9ITApe3JldHVybiB0aGlzLmdldFRhc2tQb2ludHModGhpcy50bXBQb2ludHMsZSYmdGhpcy53b3JrT3B0aW9ucy50aGlja25lc3N8fHZvaWQgMCl9ZHJhdyhlKXt2YXIgbztjb25zdHthdHRyczp0LHRhc2tzOnIscmVwbGFjZUlkOnMsZWZmZWN0czpnLGlzRnVsbFdvcms6dixub3JtYWxpemU6aCxpc0NsZWFyQWxsOmx9PWUsdT12P3RoaXMuZnVsbExheWVyOnRoaXMuZHJhd0xheWVyfHx0aGlzLmZ1bGxMYXllcix7Y29sb3I6TSxzdHJva2VUeXBlOmYsdGhpY2tuZXNzOnksb3BhY2l0eTp4LHpJbmRleDpiLHNjYWxlOk8scm90YXRlOm19PXRoaXMud29ya09wdGlvbnM7bCYmdS5yZW1vdmVBbGxDaGlsZHJlbigpLHMmJih0aGlzLmZ1bGxMYXllci5nZXRFbGVtZW50c0J5TmFtZShzKyIiKS5tYXAoVD0+VC5yZW1vdmUoKSksKG89dGhpcy5kcmF3TGF5ZXIpPT1udWxsfHxvLmdldEVsZW1lbnRzQnlOYW1lKHMrIiIpLm1hcChUPT5ULnJlbW92ZSgpKSksZyE9bnVsbCYmZy5zaXplJiYoZy5mb3JFYWNoKFQ9Pnt2YXIgUDsoUD11LmdldEVsZW1lbnRCeUlkKFQrIiIpKT09bnVsbHx8UC5yZW1vdmUoKX0pLGcuY2xlYXIoKSk7bGV0IHA7Y29uc3Qgbj1bXSxhPXUud29ybGRQb3NpdGlvbixpPXUud29ybGRTY2FsaW5nO2ZvcihsZXQgVD0wO1Q8ci5sZW5ndGg7VCsrKXtjb25zdHtwb3M6UCxwb2ludHM6Qyx0YXNrSWQ6SX09cltUXTt0LmlkPUkudG9TdHJpbmcoKTtjb25zdHtwczpBLHJlY3Q6TH09dGhpcy5jb21wdXREcmF3UG9pbnRzKEMpO2xldCBEO2NvbnN0IFI9Qy5sZW5ndGg9PT0xO2Y9PT1idC5TdHJva2V8fFI/RD1nZShBLCEwKTpEPWdlKEEsITEpO2NvbnN0IFM9e3BvczpQLGQ6RCxmaWxsQ29sb3I6Zj09PWJ0LlN0cm9rZXx8Uj9NOnZvaWQgMCxsaW5lRGFzaDpmPT09YnQuRG90dGVkJiYhUj9bMSx5KjJdOmY9PT1idC5Mb25nRG90dGVkJiYhUj9beSx5KjJdOnZvaWQgMCxzdHJva2VDb2xvcjpNLG9wYWNpdHk6eCxsaW5lQ2FwOmY9PT1idC5TdHJva2V8fFI/dm9pZCAwOiJyb3VuZCIsbGluZVdpZHRoOmY9PT1idC5TdHJva2V8fFI/MDp5LGNsYXNzTmFtZTpgJHtQWzBdfSwke1BbMV19LCR7Zn1gfTtpZihyLmxlbmd0aD09PTEmJmgpe2NvbnN0IEI9W0wueCtMLncvMixMLnkrTC5oLzJdO2lmKHRoaXMuY2VudGVyUG9zPVtCWzBdK1BbMF0sQlsxXStQWzFdXSxTLm5vcm1hbGl6ZT0hMCxTLnBvcz10aGlzLmNlbnRlclBvcyxTLmNsYXNzTmFtZT1gJHt0aGlzLmNlbnRlclBvc1swXX0sJHt0aGlzLmNlbnRlclBvc1sxXX0sJHtmfWAsUy5pZD10Lm5hbWUsUy56SW5kZXg9YixPKXtTLnNjYWxlPU87Y29uc3Qgdz1mbih7eDpNYXRoLmZsb29yKEwueCtQWzBdK2FbMF0tVXQuUGVuY2lsQm9yZGVyUGFkZGluZykseTpNYXRoLmZsb29yKEwueStQWzFdK2FbMV0tVXQuUGVuY2lsQm9yZGVyUGFkZGluZyksdzpNYXRoLmZsb29yKEwudysyKlV0LlBlbmNpbEJvcmRlclBhZGRpbmcpLGg6TWF0aC5mbG9vcihMLmgrMipVdC5QZW5jaWxCb3JkZXJQYWRkaW5nKX0sTyk7cD1DdChwLHcpfWlmKG0pe1Mucm90YXRlPW07Y29uc3Qgdz1sbih7eDpNYXRoLmZsb29yKEwueCtQWzBdK2FbMF0tVXQuUGVuY2lsQm9yZGVyUGFkZGluZykseTpNYXRoLmZsb29yKEwueStQWzFdK2FbMV0tVXQuUGVuY2lsQm9yZGVyUGFkZGluZyksdzpNYXRoLmZsb29yKEwudysyKlV0LlBlbmNpbEJvcmRlclBhZGRpbmcpLGg6TWF0aC5mbG9vcihMLmgrMipVdC5QZW5jaWxCb3JkZXJQYWRkaW5nKX0sbSk7cD1DdChwLHcpfX1wPUN0KHAse3g6TWF0aC5mbG9vcigoTC54K1BbMF0pKmlbMF0rYVswXS1VdC5QZW5jaWxCb3JkZXJQYWRkaW5nKSx5Ok1hdGguZmxvb3IoKEwueStQWzFdKSppWzFdK2FbMV0tVXQuUGVuY2lsQm9yZGVyUGFkZGluZyksdzpNYXRoLmZsb29yKEwudyppWzBdKzIqVXQuUGVuY2lsQm9yZGVyUGFkZGluZyksaDpNYXRoLmZsb29yKEwuaCppWzFdKzIqVXQuUGVuY2lsQm9yZGVyUGFkZGluZyl9KSxuLnB1c2goUyl9aWYoaCYmbi5sZW5ndGg+MSYmcCl7Y29uc3QgVD1uZXcgU2U7dGhpcy5jZW50ZXJQb3M9WyhwLngrcC53LzItYVswXSkvaVswXSwocC55K3AuaC8yLWFbMV0pL2lbMV1dLFQuYXR0cih7Li4udCxpZDp0Lm5hbWUsYW5jaG9yOlsuNSwuNV0sYmdjb2xvcjpmPT09YnQuU3Ryb2tlP006dm9pZCAwLHNjYWxlOk8sb3BhY2l0eTp4LHBvczp0aGlzLmNlbnRlclBvcyxyb3RhdGU6bSxjbGFzc05hbWU6YCR7dGhpcy5jZW50ZXJQb3NbMF19LCR7dGhpcy5jZW50ZXJQb3NbMV19LCR7Zn1gLHNpemU6W3AudyxwLmhdLHpJbmRleDpifSksbi5mb3JFYWNoKFA9PntQLnBvcz1bUC5wb3NbMF0tdGhpcy5jZW50ZXJQb3NbMF0sUC5wb3NbMV0tdGhpcy5jZW50ZXJQb3NbMV1dLFAub3BhY2l0eT0xO2NvbnN0IEM9bmV3IGJlKFApO1QuYXBwZW5kQ2hpbGQoQyl9KSxmPT09YnQuU3Ryb2tlJiZULnNlYWwoKSx1LmFwcGVuZChUKX1lbHNle2NvbnN0IFQ9bi5tYXAoUD0+bmV3IGJlKHsuLi50LC4uLlB9KSk7dS5hcHBlbmQoLi4uVCl9cmV0dXJuIHB9Y29tcHV0RHJhd1BvaW50cyhlKXtyZXR1cm4gdGhpcy53b3JrT3B0aW9ucy5zdHJva2VUeXBlPT09YnQuU3Ryb2tlfHxlLmxlbmd0aD09PTE/dGhpcy5jb21wdXRTdHJva2UoZSk6dGhpcy5jb21wdXROb21hbChlKX1jb21wdXROb21hbChlKXtsZXQgdD10aGlzLndvcmtPcHRpb25zLnRoaWNrbmVzcztjb25zdCByPWUubWFwKHM9Pih0PU1hdGgubWF4KHQscy5yYWRpdXMpLHMucG9pbnQpKTtyZXR1cm57cHM6cixyZWN0Okh0KHIsdCl9fWNvbXB1dFN0cm9rZShlKXtyZXR1cm4gZS5sZW5ndGg9PT0xP3RoaXMuY29tcHV0RG90U3Ryb2tlKGVbMF0pOnRoaXMuY29tcHV0TGluZVN0cm9rZShlKX1jb21wdXRMaW5lU3Ryb2tlKGUpe2NvbnN0IHQ9W10scj1bXTtmb3IobGV0IGw9MDtsPGUubGVuZ3RoO2wrKyl7Y29uc3R7cG9pbnQ6dSxyYWRpdXM6TX09ZVtsXTtsZXQgZj11LnY7bD09PTAmJmUubGVuZ3RoPjEmJihmPWVbbCsxXS5wb2ludC52KTtjb25zdCB5PWh0LlBlcihmKS5tdWwoTSk7dC5wdXNoKFB0LlN1Yih1LHkpKSxyLnB1c2goUHQuQWRkKHUseSkpfWNvbnN0IHM9ZVtlLmxlbmd0aC0xXSxnPVB0LkdldFNlbWljaXJjbGVTdHJva2Uocy5wb2ludCx0W3QubGVuZ3RoLTFdLC0xLDgpLHY9UHQuR2V0U2VtaWNpcmNsZVN0cm9rZShlWzBdLnBvaW50LHJbMF0sLTEsOCksaD10LmNvbmNhdChnLHIucmV2ZXJzZSgpLHYpO3JldHVybntwczpoLHJlY3Q6SHQoaCl9fWNvbXB1dERvdFN0cm9rZShlKXtjb25zdHtwb2ludDp0LHJhZGl1czpyfT1lLHM9e3g6dC54LXIseTp0Lnktcix3OnIqMixoOnIqMn07cmV0dXJue3BzOlB0LkdldERvdFN0cm9rZSh0LHIsOCkscmVjdDpzfX10cmFuc2Zvcm1EYXRhKGUsdCl7Y29uc3R7b3A6cix3b3JrU3RhdGU6c309ZTtsZXQgZz10aGlzLnRtcFBvaW50cy5sZW5ndGgtMSx2PVtdO2lmKHIhPW51bGwmJnIubGVuZ3RoJiZzKXtjb25zdHtzdHJva2VUeXBlOmgsdGhpY2tuZXNzOmx9PXRoaXMud29ya09wdGlvbnMsdT1uZXcgU2V0O2c9aD09PWJ0LlN0cm9rZT90aGlzLnVwZGF0ZVRlbXBQb2ludHNXaXRoUHJlc3N1cmUocixsLHUpOnRoaXMudXBkYXRlVGVtcFBvaW50cyhyLGwsdSk7Y29uc3QgTT10P3RoaXMudG1wUG9pbnRzOnRoaXMudG1wUG9pbnRzLnNsaWNlKGcpO3JldHVybiB2PXRoaXMuZ2V0VGFza1BvaW50cyhNLGwpLHt0YXNrczp2LGVmZmVjdHM6dSxjb25zdW1lSW5kZXg6Z319cmV0dXJue3Rhc2tzOnYsY29uc3VtZUluZGV4Omd9fWNvbXB1dFJhZGl1cyhlLHQpe3JldHVybiBlKi4wMyp0K3QqLjV9Z2V0TWluWihlLHQpe3JldHVybigodHx8TWF0aC5tYXgoMSxNYXRoLmZsb29yKGUqLjMpKSktZSouNSkqMTAwL2UvM31nZXRUYXNrUG9pbnRzKGUsdCl7dmFyIE07Y29uc3Qgcj1bXTtpZihlLmxlbmd0aD09PTApcmV0dXJuW107bGV0IHM9MCxnPWVbMF0ueCx2PWVbMF0ueSxoPVtnLHZdLGw9W10sdT1lWzBdLnQ7Zm9yKDtzPGUubGVuZ3RoOyl7Y29uc3QgZj1lW3NdLHk9Zi54LWcseD1mLnktdixiPWYueixPPXQ/dGhpcy5jb21wdXRSYWRpdXMoYix0KTpiO2lmKGwucHVzaCh7cG9pbnQ6bmV3IFB0KHkseCxiLGVbc10udikscmFkaXVzOk99KSxzPjAmJnM8ZS5sZW5ndGgtMSl7Y29uc3QgbT1lW3NdLmdldEFuZ2xlQnlQb2ludHMoZVtzLTFdLGVbcysxXSk7aWYobTw5MHx8bT4yNzApe2NvbnN0IHA9KE09bC5wb3AoKSk9PW51bGw/dm9pZCAwOk0ucG9pbnQuY2xvbmUoKTtwJiZyLnB1c2goe3Rhc2tJZDp1LHBvczpoLHBvaW50czpbLi4ubCx7cG9pbnQ6cCxyYWRpdXM6T31dfSksZz1lW3NdLngsdj1lW3NdLnksaD1bZyx2XTtjb25zdCBuPWYueC1nLGE9Zi55LXY7bD1be3BvaW50Om5ldyBQdChuLGEsYikscmFkaXVzOk99XSx1PURhdGUubm93KCl9fXMrK31yZXR1cm4gci5wdXNoKHt0YXNrSWQ6dSxwb3M6aCxwb2ludHM6bH0pLHJ9dXBkYXRlVGVtcFBvaW50c1dpdGhQcmVzc3VyZShlLHQscil7Y29uc3Qgcz1EYXRlLm5vdygpLGc9dGhpcy50bXBQb2ludHMubGVuZ3RoO2xldCB2PWc7Zm9yKGxldCBsPTA7bDxlLmxlbmd0aDtsKz0yKXt2PU1hdGgubWluKHYsZyk7Y29uc3QgdT10aGlzLnRtcFBvaW50cy5sZW5ndGgsTT1uZXcgUHQoZVtsXSxlW2wrMV0pO2lmKHU9PT0wKXt0aGlzLnRtcFBvaW50cy5wdXNoKE0pO2NvbnRpbnVlfWNvbnN0IGY9dS0xLHk9dGhpcy50bXBQb2ludHNbZl0seD1odC5TdWIoTSx5KS51bmkoKTtpZihNLmlzTmVhcih5LHQpKXtpZih5Lno8dGhpcy5NQVhfUkVQRUFSKXtpZih5LnNldHooTWF0aC5taW4oeS56KzEsdGhpcy5NQVhfUkVQRUFSKSksdj1NYXRoLm1pbih2LGYpLHU+MSl7bGV0IG09dS0xO2Zvcig7bT4wOyl7Y29uc3QgcD10aGlzLnRtcFBvaW50c1ttXS5kaXN0YW5jZSh0aGlzLnRtcFBvaW50c1ttLTFdKSxuPU1hdGgubWF4KHRoaXMudG1wUG9pbnRzW21dLnotdGhpcy51bmlUaGlja25lc3MqcCwwKTtpZih0aGlzLnRtcFBvaW50c1ttLTFdLno+PW4pYnJlYWs7dGhpcy50bXBQb2ludHNbbS0xXS5zZXR6KG4pLHY9TWF0aC5taW4odixtLTEpLG0tLX19fWVsc2Ugdj0xLzA7Y29udGludWV9TS5zZXR2KHgpO2NvbnN0IGI9TS5kaXN0YW5jZSh5KSxPPU1hdGgubWF4KHkuei10aGlzLnVuaVRoaWNrbmVzcypiLDApO3U+MSYmaHQuRXF1YWxzKHgseS52LC4wMikmJihPPjB8fHkuejw9MCkmJihyJiZ5LnQmJnIuYWRkKHkudCksdGhpcy50bXBQb2ludHMucG9wKCksdj1NYXRoLm1pbihmLHYpKSxNLnNldHooTyksdGhpcy50bXBQb2ludHMucHVzaChNKX1pZih2PT09MS8wKXJldHVybiB0aGlzLnRtcFBvaW50cy5sZW5ndGg7bGV0IGg9ZztpZih2PT09Zyl7aD1NYXRoLm1heChoLTEsMCk7Y29uc3QgbD10aGlzLnRtcFBvaW50c1toXS50O2wmJihyPT1udWxsfHxyLmFkZChsKSl9ZWxzZXtsZXQgbD1nLTE7Zm9yKGg9djtsPj0wOyl7Y29uc3QgdT10aGlzLnRtcFBvaW50c1tsXS50O2lmKHUmJihyPT1udWxsfHxyLmFkZCh1KSxsPD12KSl7aD1sLGw9LTE7YnJlYWt9bC0tfX1yZXR1cm4gdGhpcy50bXBQb2ludHNbaF0uc2V0VChzKSxofXVwZGF0ZVRlbXBQb2ludHMoZSx0LHIpe3ZhciBsO2NvbnN0IHM9RGF0ZS5ub3coKSxnPXRoaXMudG1wUG9pbnRzLmxlbmd0aDtsZXQgdj1nO2ZvcihsZXQgdT0wO3U8ZS5sZW5ndGg7dSs9Mil7Y29uc3QgTT10aGlzLnRtcFBvaW50cy5sZW5ndGgsZj1uZXcgUHQoZVt1XSxlW3UrMV0pO2lmKE09PT0wKXt0aGlzLnRtcFBvaW50cy5wdXNoKGYpO2NvbnRpbnVlfWNvbnN0IHk9TS0xLHg9dGhpcy50bXBQb2ludHNbeV0sYj1odC5TdWIoZix4KS51bmkoKTtpZihodC5FcXVhbHMoYix4LnYsLjAyKSl7ciYmeC50JiZyLmFkZCh4LnQpLHRoaXMudG1wUG9pbnRzLnBvcCgpLHY9TWF0aC5taW4oeSx2KTtjb250aW51ZX1pZihmLmlzTmVhcih4LHQvMikpe3Y9TWF0aC5taW4oeSx2KTtjb250aW51ZX1mLnNldHYoYiksdGhpcy50bXBQb2ludHMucHVzaChmKX1sZXQgaD1nO2lmKHY9PT1nKXtoPU1hdGgubWF4KGgtMSwwKTtjb25zdCB1PXRoaXMudG1wUG9pbnRzW2hdLnQ7dSYmKHI9PW51bGx8fHIuYWRkKHUpKX1lbHNle2xldCB1PU1hdGgubWluKGctMSx2KTtmb3IoaD12O3U+PTA7KXtjb25zdCBNPShsPXRoaXMudG1wUG9pbnRzW3VdKT09bnVsbD92b2lkIDA6bC50O2lmKE0mJihyPT1udWxsfHxyLmFkZChNKSx1PD12KSl7aD11LHU9LTE7YnJlYWt9dS0tfX1yZXR1cm4gdGhpcy50bXBQb2ludHNbaF0uc2V0VChzKSxofXVwZGF0ZVRlbXBQb2ludHNXaXRoUHJlc3N1cmVXaGVuRG9uZShlKXtjb25zdHt0aGlja25lc3M6dH09dGhpcy53b3JrT3B0aW9ucyxyPWUubGVuZ3RoLHM9dGhpcy5nZXRNaW5aKHQpO2ZvcihsZXQgZz0wO2c8cjtnKz0yKXtjb25zdCB2PXRoaXMudG1wUG9pbnRzLmxlbmd0aCxoPW5ldyBQdChlW2ddLGVbZysxXSk7aWYodj09PTApe3RoaXMudG1wUG9pbnRzLnB1c2goaCk7Y29udGludWV9Y29uc3QgbD12LTEsdT10aGlzLnRtcFBvaW50c1tsXSxNPWh0LlN1YihoLHUpLnVuaSgpLGY9aC5kaXN0YW5jZSh1KTtpZih2PjEmJnUuej09PXMpYnJlYWs7aWYoaC5pc05lYXIodSx0LzIpKXtpZihyPDMmJnUuejx0aGlzLk1BWF9SRVBFQVImJih1LnNldHooTWF0aC5taW4odS56KzEsdGhpcy5NQVhfUkVQRUFSKSksdj4xKSl7bGV0IHg9di0xO2Zvcig7eD4wOyl7Y29uc3QgYj10aGlzLnRtcFBvaW50c1t4XS5kaXN0YW5jZSh0aGlzLnRtcFBvaW50c1t4LTFdKSxPPU1hdGgubWF4KHRoaXMudG1wUG9pbnRzW3hdLnotdGhpcy51bmlUaGlja25lc3MqYiwtdC80KTtpZih0aGlzLnRtcFBvaW50c1t4LTFdLno+PU8pYnJlYWs7dGhpcy50bXBQb2ludHNbeC0xXS5zZXR6KE8pLHgtLX19Y29udGludWV9aC5zZXR2KE0pO2NvbnN0IHk9TWF0aC5tYXgodS56LXRoaXMudW5pVGhpY2tuZXNzKmYscyk7dj4xJiZodC5FcXVhbHMoTSx1LnYsLjAyKSYmdS56PD0wJiZ0aGlzLnRtcFBvaW50cy5wb3AoKSxoLnNldHooeSksdGhpcy50bXBQb2ludHMucHVzaChoKX19dXBkYXRhT3B0U2VydmljZShlKXt2YXIgcztsZXQgdDtjb25zdCByPShzPXRoaXMud29ya0lkKT09bnVsbD92b2lkIDA6cy50b1N0cmluZygpO2lmKHImJmUpe2NvbnN0IGc9dGhpcy5mdWxsTGF5ZXIuZ2V0RWxlbWVudHNCeU5hbWUocikse3Bvczp2LHpJbmRleDpoLGNvbG9yOmwsc2NhbGU6dSxhbmdsZTpNLG9wYWNpdHk6Zn09ZSx5PXt9O2lmKHR5cGVvZiBoPT0ibnVtYmVyIiYmKHkuekluZGV4PWgpLHYmJih5LnBvcz1bdlswXSx2WzFdXSxnWzBdKSl7Y29uc3QgeD1nWzBdLmNsYXNzTmFtZS5zcGxpdCgiLCIpO3kuY2xhc3NOYW1lPWAke3ZbMF19LCR7dlsxXX0sJHt4WzJdfWB9cmV0dXJuIGwmJih5LnN0cm9rZUNvbG9yPWwpLHUmJih5LnNjYWxlPXUpLGYmJih5Lm9wYWNpdHk9ZiksTSYmKHkucm90YXRlPU0pLE9iamVjdC5rZXlzKHkpLmxlbmd0aCYmZy5mb3JFYWNoKHg9Pntjb25zdCBiPXguYXR0cigiZmlsbENvbG9yIik7bCYmYj94LmF0dHIoey4uLnksZmlsbENvbG9yOmx9KTp4LmF0dHIoeSk7Y29uc3QgTz14PT1udWxsP3ZvaWQgMDp4LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO08mJih0PUN0KHQse3g6TWF0aC5mbG9vcihPLngtVXQuUGVuY2lsQm9yZGVyUGFkZGluZykseTpNYXRoLmZsb29yKE8ueS1VdC5QZW5jaWxCb3JkZXJQYWRkaW5nKSx3Ok1hdGguZmxvb3IoTy53aWR0aCtVdC5QZW5jaWxCb3JkZXJQYWRkaW5nKjIpLGg6TWF0aC5mbG9vcihPLmhlaWdodCtVdC5QZW5jaWxCb3JkZXJQYWRkaW5nKjIpfSkpfSksdH19fU9iamVjdC5kZWZpbmVQcm9wZXJ0eShVdCwiUGVuY2lsQm9yZGVyUGFkZGluZyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOjEwfSk7dmFyIGNuPXZlO3ZlLnBvbHlsaW5lPXZlLHZlLnBvbHlnb249aG47ZnVuY3Rpb24gdmUoYyxlLHQpe3ZhciByPWMubGVuZ3RoLHM9X3QoY1swXSxlKSxnPVtdLHYsaCxsLHUsTTtmb3IodHx8KHQ9W10pLHY9MTt2PHI7disrKXtmb3IoaD1jW3YtMV0sbD1jW3ZdLHU9TT1fdChsLGUpOzspaWYoc3x1KXtpZihzJnUpYnJlYWs7cz8oaD1MZShoLGwscyxlKSxzPV90KGgsZSkpOihsPUxlKGgsbCx1LGUpLHU9X3QobCxlKSl9ZWxzZXtnLnB1c2goaCksdSE9PU0/KGcucHVzaChsKSx2PHItMSYmKHQucHVzaChnKSxnPVtdKSk6dj09PXItMSYmZy5wdXNoKGwpO2JyZWFrfXM9TX1yZXR1cm4gZy5sZW5ndGgmJnQucHVzaChnKSx0fWZ1bmN0aW9uIGhuKGMsZSl7dmFyIHQscixzLGcsdixoLGw7Zm9yKHI9MTtyPD04O3IqPTIpe2Zvcih0PVtdLHM9Y1tjLmxlbmd0aC0xXSxnPSEoX3QocyxlKSZyKSx2PTA7djxjLmxlbmd0aDt2KyspaD1jW3ZdLGw9IShfdChoLGUpJnIpLGwhPT1nJiZ0LnB1c2goTGUocyxoLHIsZSkpLGwmJnQucHVzaChoKSxzPWgsZz1sO2lmKGM9dCwhYy5sZW5ndGgpYnJlYWt9cmV0dXJuIHR9ZnVuY3Rpb24gTGUoYyxlLHQscil7cmV0dXJuIHQmOD9bY1swXSsoZVswXS1jWzBdKSooclszXS1jWzFdKS8oZVsxXS1jWzFdKSxyWzNdXTp0JjQ/W2NbMF0rKGVbMF0tY1swXSkqKHJbMV0tY1sxXSkvKGVbMV0tY1sxXSksclsxXV06dCYyP1tyWzJdLGNbMV0rKGVbMV0tY1sxXSkqKHJbMl0tY1swXSkvKGVbMF0tY1swXSldOnQmMT9bclswXSxjWzFdKyhlWzFdLWNbMV0pKihyWzBdLWNbMF0pLyhlWzBdLWNbMF0pXTpudWxsfWZ1bmN0aW9uIF90KGMsZSl7dmFyIHQ9MDtyZXR1cm4gY1swXTxlWzBdP3R8PTE6Y1swXT5lWzJdJiYodHw9MiksY1sxXTxlWzFdP3R8PTQ6Y1sxXT5lWzNdJiYodHw9OCksdH12YXIgZG49UmUoY24pO2NsYXNzIHp0IGV4dGVuZHMgaGV7dXBkYXRhT3B0U2VydmljZSgpe31jb25zdHJ1Y3RvcihlLHQpe3N1cGVyKHQpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzeW5jVGltZXN0YW1wIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInRvb2xzVHlwZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOkR0LkVyYXNlcn0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ0bXBQb2ludHMiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpbXX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ3b3JrT3B0aW9ucyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ3b3JsZFBvc2l0aW9uIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIndvcmxkU2NhbGluZyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJlcmFzZXJSZWN0Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImVyYXNlclBvbHlsaW5lIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImN1ck5vZGVNYXAiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpuZXcgTWFwfSksdGhpcy53b3JrT3B0aW9ucz1lLHRoaXMuc3luY1RpbWVzdGFtcD0wLHRoaXMud29ybGRQb3NpdGlvbj10aGlzLmZ1bGxMYXllci53b3JsZFBvc2l0aW9uLHRoaXMud29ybGRTY2FsaW5nPXRoaXMuZnVsbExheWVyLndvcmxkU2NhbGluZ31jb21wdXROb2RlTWFwKGUpe3RoaXMuY3VyTm9kZU1hcC5jbGVhcigpLGUuZm9yRWFjaCh0PT57Y29uc3Qgcj10aGlzLmZ1bGxMYXllci5nZXRFbGVtZW50c0J5TmFtZSh0Lm5hbWUpWzBdLHM9dC5vcHMmJm9yKHQub3BzKTtpZihyJiZzLmxlbmd0aCl7Y29uc3QgZz1bXTtmb3IobGV0IGg9MDtoPHMubGVuZ3RoO2grPTMpe2NvbnN0IGw9bmV3IGh0KHNbaF0qdGhpcy53b3JsZFNjYWxpbmdbMF0rdGhpcy53b3JsZFBvc2l0aW9uWzBdLHNbaCsxXSp0aGlzLndvcmxkU2NhbGluZ1sxXSt0aGlzLndvcmxkUG9zaXRpb25bMV0sc1toKzJdKTtnLnB1c2gobCl9bGV0IHY9dC5vcHQ7aWYoIXYpe2xldCBoPXIuZ2V0QXR0cmlidXRlKCJzdHJva2VDb2xvciIpO2NvbnN0IGw9ci5jbGFzc05hbWUuc3BsaXQoIiwiKSx1PU51bWJlcihsWzJdKTtyLnRhZ05hbWU9PT0iR1JPVVAiJiYodT09PWJ0LlN0cm9rZT9oPXIuZ2V0QXR0cmlidXRlKCJiZ2NvbG9yIik6aD1yLmNoaWxkcmVuWzBdLmdldEF0dHJpYnV0ZSgic3Ryb2tlQ29sb3IiKSk7Y29uc3QgTT1yLmdldEF0dHJpYnV0ZSgib3BhY2l0eSIpLGY9ci5nZXRBdHRyaWJ1dGUoInNjYWxlIikseT1yLmdldEF0dHJpYnV0ZSgiekluZGV4IikseD1yLmdldEF0dHJpYnV0ZSgicm90YXRlIiksYj10aGlzLndvcmtPcHRpb25zLnN5bmNVbml0VGltZTt2PXtjb2xvcjpoLG9wYWNpdHk6TSxzeW5jVW5pdFRpbWU6Yix6SW5kZXg6eSxzY2FsZTpmLHJvdGF0ZTp4LHN0cm9rZVR5cGU6dX19dGhpcy5jdXJOb2RlTWFwLnNldCh0Lm5hbWUse25hbWU6dC5uYW1lLHJlY3Q6dC5yZWN0LHBvbHlsaW5lOmcsb3B0OnYsdG9vbHNUeXBlOnQudG9vbHNUeXBlfHxEdC5QZW5jaWx9KX19KX11cGRhdGFOb2RlTWFwKGUsdCl7Y29uc3Qgcj10Lm9wLHM9W107Zm9yKGxldCBnPTA7ZzxyLmxlbmd0aDtnKz0zKXtjb25zdCB2PW5ldyBodChyW2ddKnRoaXMud29ybGRTY2FsaW5nWzBdK3RoaXMud29ybGRQb3NpdGlvblswXSxyW2crMV0qdGhpcy53b3JsZFNjYWxpbmdbMV0rdGhpcy53b3JsZFBvc2l0aW9uWzFdLHJbZysyXSk7cy5wdXNoKHYpfXRoaXMuY3VyTm9kZU1hcC5zZXQoZSx7bmFtZTp0Lm5hbWUscmVjdDp0LnJlY3QscG9seWxpbmU6cyxvcHQ6dC5vcHQsdG9vbHNUeXBlOnQudG9vbHNUeXBlfHxEdC5QZW5jaWx9KX1jb21iaW5lQ29uc3VtZSgpe31jcmVhdGVFcmFzZXJSZWN0KGUpe2NvbnN0IHQ9ZVswXSp0aGlzLndvcmxkU2NhbGluZ1swXSt0aGlzLndvcmxkUG9zaXRpb25bMF0scj1lWzFdKnRoaXMud29ybGRTY2FsaW5nWzFdK3RoaXMud29ybGRQb3NpdGlvblsxXSx7d2lkdGg6cyxoZWlnaHQ6Z309enQuZXJhc2VyU2l6ZXNbdGhpcy53b3JrT3B0aW9ucy50aGlja25lc3NdO3RoaXMuZXJhc2VyUmVjdD17eDp0LXMqLjUseTpyLWcqLjUsdzpzLGg6Z30sdGhpcy5lcmFzZXJQb2x5bGluZT1bdGhpcy5lcmFzZXJSZWN0LngsdGhpcy5lcmFzZXJSZWN0LnksdGhpcy5lcmFzZXJSZWN0LngrdGhpcy5lcmFzZXJSZWN0LncsdGhpcy5lcmFzZXJSZWN0LnkrdGhpcy5lcmFzZXJSZWN0LmhdfWNvbnN1bWVTZXJ2aWNlKCl7fXNldFdvcmtPcHRpb25zKGUpe3N1cGVyLnNldFdvcmtPcHRpb25zKGUpLHRoaXMuc3luY1RpbWVzdGFtcD1EYXRlLm5vdygpfWNvbXB1dFJlY3RDZW50ZXJQb2ludHMoKXtjb25zdCBlPXRoaXMudG1wUG9pbnRzLnNsaWNlKC0yKTtpZih0aGlzLnRtcFBvaW50cy5sZW5ndGg9PT00KXtjb25zdCB0PW5ldyBodCh0aGlzLnRtcFBvaW50c1swXSx0aGlzLnRtcFBvaW50c1sxXSkscj1uZXcgaHQodGhpcy50bXBQb2ludHNbMl0sdGhpcy50bXBQb2ludHNbM10pLHM9aHQuU3ViKHIsdCkudW5pKCksZz1odC5EaXN0KHQscikse3dpZHRoOnYsaGVpZ2h0Omh9PXp0LmVyYXNlclNpemVzW3RoaXMud29ya09wdGlvbnMudGhpY2tuZXNzXSxsPU1hdGgubWluKHYsaCksdT1NYXRoLnJvdW5kKGcvbCk7aWYodT4xKXtjb25zdCBNPVtdO2ZvcihsZXQgZj0wO2Y8dTtmKyspe2NvbnN0IHk9aHQuTXVsKHMsZipsKTtNLnB1c2godGhpcy50bXBQb2ludHNbMF0reS54LHRoaXMudG1wUG9pbnRzWzFdK3kueSl9cmV0dXJuIE0uY29uY2F0KGUpfX1yZXR1cm4gZX1pc05lYXIoZSx0KXtjb25zdCByPW5ldyBodChlWzBdLGVbMV0pLHM9bmV3IGh0KHRbMF0sdFsxXSkse3dpZHRoOmcsaGVpZ2h0OnZ9PXp0LmVyYXNlclNpemVzW3RoaXMud29ya09wdGlvbnMudGhpY2tuZXNzXTtyZXR1cm4gaHQuRGlzdChyLHMpPE1hdGguaHlwb3QoZyx2KSouNX1jb25zdW1lKGUpe2NvbnN0e29wOnQsd29ya1N0YXRlOnJ9PWUuZGF0YTtpZighdHx8dC5sZW5ndGg9PT0wKXJldHVybnt0eXBlOkV0Lk5vbmV9O3I9PT1RdC5TdGFydCYmZS5ub2RlTWFwcyYmdGhpcy5jb21wdXROb2RlTWFwKGUubm9kZU1hcHMpO2NvbnN0IHM9dGhpcy50bXBQb2ludHMubGVuZ3RoO2lmKHM+MSYmdGhpcy5pc05lYXIoW3RbMF0sdFsxXV0sW3RoaXMudG1wUG9pbnRzW3MtMl0sdGhpcy50bXBQb2ludHNbcy0xXV0pKXJldHVybnt0eXBlOkV0Lk5vbmV9O2lmKGUubm9kZU1hcHMpe3M9PT00JiYodGhpcy50bXBQb2ludHMuc2hpZnQoKSx0aGlzLnRtcFBvaW50cy5zaGlmdCgpKSx0aGlzLnRtcFBvaW50cy5wdXNoKHRbMF0sdFsxXSk7Y29uc3QgZz10aGlzLmNvbXB1dFJlY3RDZW50ZXJQb2ludHMoKTtsZXQgdjtjb25zdCBoPW5ldyBTZXQsbD1uZXcgTWFwO2ZvcihsZXQgdT0wO3U8Zy5sZW5ndGgtMTt1Kz0yKXt0aGlzLmNyZWF0ZUVyYXNlclJlY3QoZy5zbGljZSh1LHUrMikpO2NvbnN0e3JlY3Q6TSxyZW1vdmVJZHM6ZixuZXdXb3JrRGF0YXM6eX09dGhpcy5yZW1vdmUoKTt2PUN0KHYsTSksZi5mb3JFYWNoKHg9PmguYWRkKHgpKSx5PT1udWxsfHx5LmZvckVhY2goeD0+e2guaGFzKHgud29ya0lkKXx8bC5zZXQoeC53b3JrSWQseCl9KX1pZih2JiZoLnNpemUpe2NvbnN0IHU9W107Zm9yKGNvbnN0IE0gb2YgbC52YWx1ZXMoKSloLmhhcyhNLndvcmtJZCl8fHUucHVzaChNKTtyZXR1cm57dHlwZTpFdC5SZW1vdmVOb2RlLGRhdGFUeXBlOkx0LkxvY2FsLHJlY3Q6dixyZW1vdmVJZHM6Wy4uLmhdLG5ld1dvcmtEYXRhczp1fX19cmV0dXJue3R5cGU6RXQuTm9uZX19Y3V0UG9seWxpbmUoZSx0KXtsZXQgcj1bdF0scz0wO2Zvcig7czxlLmxlbmd0aDspe2NvbnN0IGg9ZVtzXTtpZihoLmxlbmd0aDwyKWJyZWFrO3I9ZyhyLGgpLHMrK31yZXR1cm4gcjtmdW5jdGlvbiBnKGgsbCl7Y29uc3QgdT1oO2ZvcihsZXQgTT0wO008aC5sZW5ndGg7TSsrKXtjb25zdCBmPWhbTV0seT1mLmZpbmRJbmRleCgoeCxiKT0+YjxmLmxlbmd0aC0xP3YoW3gsZltiKzFdXSxbbFswXSxsWzFdXSk6ITEpO2lmKHkhPT0tMSYmeT4tMSl7Y29uc3QgeD1bXSxiPWYuc2xpY2UoMCx5KzEpO2lmKGh0LkVxdWFscyhmW3ldLGxbMF0pfHxiLnB1c2gobFswXS5jbG9uZSgpLnNldHooZlt5XS56KSksYi5sZW5ndGg+MSYmeC5wdXNoKGIpLHkrbC5sZW5ndGgtMTxmLmxlbmd0aC0xKXtjb25zdCBPPXkrbC5sZW5ndGgtMSxtPWYuc2xpY2UoTykscD1sW2wubGVuZ3RoLTFdO2h0LkVxdWFscyhmW09dLHApfHxtLnVuc2hpZnQocC5jbG9uZSgpLnNldHooZltPXS56KSksbS5sZW5ndGg+MSYmeC5wdXNoKG0pfXJldHVybiB1LnNwbGljZShNLDEsLi4ueCksdX19cmV0dXJuIHV9ZnVuY3Rpb24gdihoLGwpe2NvbnN0IHU9aHQuU3ViKGhbMV0saFswXSksTT1odC5TdWIobFsxXSxsWzBdKSxmPWh0LlN1YihsWzBdLGhbMF0pO3JldHVybiBNYXRoLmFicyhodC5DcHIodSxNKSk8LjEmJk1hdGguYWJzKGh0LkNwcih1LGYpKTwuMX19aXNTYW1lUG9pbnQoZSx0KXtyZXR1cm4gZVswXT09PXRbMF0mJmVbMV09PT10WzFdfXRyYW5zbGF0ZUludGVyc2VjdChlKXtjb25zdCB0PVtdO2ZvcihsZXQgcj0wO3I8ZS5sZW5ndGg7cisrKXtjb25zdCBzPWVbcl0uZmlsdGVyKChoLGwsdSk9PiEobD4wJiZ0aGlzLmlzU2FtZVBvaW50KGgsdVtsLTFdKSkpLGc9W107bGV0IHY9MDtmb3IoO3Y8cy5sZW5ndGg7KXtjb25zdCBoPXNbdl0sbD1uZXcgaHQoaFswXSxoWzFdKTtnLnB1c2gobCksdisrfXQucHVzaChnKX1yZXR1cm4gdH1yZW1vdmUoKXtjb25zdHtpc0xpbmU6ZX09dGhpcy53b3JrT3B0aW9ucztsZXQgdDtjb25zdCByPVtdLHM9W10sZz1bXTtyZXR1cm4gdGhpcy5jdXJOb2RlTWFwLmZvckVhY2goKHYsaCk9Pntjb25zdCBsPXRoaXMuZnVsbExheWVyLmdldEVsZW1lbnRzQnlOYW1lKHYubmFtZSlbMF07aWYobCYmdi5yZWN0JiZ0aGlzLmVyYXNlclJlY3QmJnRoaXMuZXJhc2VyUG9seWxpbmUmJnNyKHRoaXMuZXJhc2VyUmVjdCx2LnJlY3QpKXtpZih2LnBvbHlsaW5lLmxlbmd0aD4xKXtjb25zdCB1PWRuLnBvbHlsaW5lKHYucG9seWxpbmUubWFwKE09Pk0uWFkpLHRoaXMuZXJhc2VyUG9seWxpbmUpO2lmKHUubGVuZ3RoJiYocy5wdXNoKGwpLHIucHVzaCh2Lm5hbWUpLCFlKSl7Y29uc3QgTT10aGlzLnRyYW5zbGF0ZUludGVyc2VjdCh1KSxmPXRoaXMuY3V0UG9seWxpbmUoTSx2LnBvbHlsaW5lKTtmb3IobGV0IHk9MDt5PGYubGVuZ3RoO3krKyl7Y29uc3QgeD1gJHtofV9zXyR7eX1gLGI9W107Zlt5XS5mb3JFYWNoKE89PntiLnB1c2goKE8ueC10aGlzLndvcmxkUG9zaXRpb25bMF0pL3RoaXMud29ybGRTY2FsaW5nWzBdLChPLnktdGhpcy53b3JsZFBvc2l0aW9uWzFdKS90aGlzLndvcmxkU2NhbGluZ1sxXSxPLnopfSksZy5wdXNoKHt3b3JrSWQ6eCxvcDpiLG9wdDp2Lm9wdCx0b29sc1R5cGU6di50b29sc1R5cGV9KX19fWVsc2Ugcy5wdXNoKGwpLHIucHVzaCh2Lm5hbWUpO3Q9Q3QodCx2LnJlY3QpfX0pLHMuZm9yRWFjaCh2PT52LnJlbW92ZSgpKSx0JiYodC54LT16dC5TYWZlQm9yZGVyUGFkZGluZyx0LnktPXp0LlNhZmVCb3JkZXJQYWRkaW5nLHQudys9enQuU2FmZUJvcmRlclBhZGRpbmcqMix0LmgrPXp0LlNhZmVCb3JkZXJQYWRkaW5nKjIpLHtyZWN0OnQscmVtb3ZlSWRzOnIsbmV3V29ya0RhdGFzOmd9fWNvbnN1bWVBbGwoZSl7cmV0dXJuIHRoaXMuY29uc3VtZShlKX1jbGVhclRtcFBvaW50cygpe3RoaXMudG1wUG9pbnRzLmxlbmd0aD0wLHRoaXMuc3luY1RpbWVzdGFtcD0wfX1PYmplY3QuZGVmaW5lUHJvcGVydHkoenQsIlNhZmVCb3JkZXJQYWRkaW5nIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6MTB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoenQsImVyYXNlclNpemVzIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6T2JqZWN0LmZyZWV6ZShbT2JqZWN0LmZyZWV6ZSh7d2lkdGg6MTgsaGVpZ2h0OjI2fSksT2JqZWN0LmZyZWV6ZSh7d2lkdGg6MjYsaGVpZ2h0OjM0fSksT2JqZWN0LmZyZWV6ZSh7d2lkdGg6MzQsaGVpZ2h0OjUwfSldKX0pO2Z1bmN0aW9uIGduKGMsZSx0KXtyZXR1cm4iIyIrKChjPDwxNikrKGU8PDgpK3QpLnRvU3RyaW5nKDE2KS5wYWRTdGFydCg2LCIwIil9ZnVuY3Rpb24gbW4oYyl7Y29uc3QgZT1jLnNwbGl0KCIsIiksdD1wYXJzZUludChlWzBdLnNwbGl0KCIoIilbMV0pLHI9cGFyc2VJbnQoZVsxXSkscz1wYXJzZUludChlWzJdKSxnPXBhcnNlSW50KGVbM10uc3BsaXQoIikiKVswXSk7cmV0dXJuW2duKHQscixzKSxnXX1jb25zdCB2bj0ic2VsZWN0b3IiO3ZhciB5bj10eXBlb2YgbWU9PSJvYmplY3QiJiZtZSYmbWUuT2JqZWN0PT09T2JqZWN0JiZtZSxscj15bixwbj1scix4bj10eXBlb2Ygc2VsZj09Im9iamVjdCImJnNlbGYmJnNlbGYuT2JqZWN0PT09T2JqZWN0JiZzZWxmLE1uPXBufHx4bnx8RnVuY3Rpb24oInJldHVybiB0aGlzIikoKSxLdD1NbixPbj1LdCxFbj1Pbi5TeW1ib2wsRGU9RW4sZnI9RGUsdXI9T2JqZWN0LnByb3RvdHlwZSxUbj11ci5oYXNPd25Qcm9wZXJ0eSxBbj11ci50b1N0cmluZyxvZT1mcj9mci50b1N0cmluZ1RhZzp2b2lkIDA7ZnVuY3Rpb24gUG4oYyl7dmFyIGU9VG4uY2FsbChjLG9lKSx0PWNbb2VdO3RyeXtjW29lXT12b2lkIDA7dmFyIHI9ITB9Y2F0Y2h7fXZhciBzPUFuLmNhbGwoYyk7cmV0dXJuIHImJihlP2Nbb2VdPXQ6ZGVsZXRlIGNbb2VdKSxzfXZhciBTbj1Qbixibj1PYmplY3QucHJvdG90eXBlLFJuPWJuLnRvU3RyaW5nO2Z1bmN0aW9uIENuKGMpe3JldHVybiBSbi5jYWxsKGMpfXZhciBMbj1Dbixjcj1EZSxEbj1TbixJbj1MbixObj0iW29iamVjdCBOdWxsXSIsam49IltvYmplY3QgVW5kZWZpbmVkXSIsaHI9Y3I/Y3IudG9TdHJpbmdUYWc6dm9pZCAwO2Z1bmN0aW9uIEJuKGMpe3JldHVybiBjPT1udWxsP2M9PT12b2lkIDA/am46Tm46aHImJmhyIGluIE9iamVjdChjKT9EbihjKTpJbihjKX12YXIgbGU9Qm47ZnVuY3Rpb24gVW4oYyl7cmV0dXJuIGMhPW51bGwmJnR5cGVvZiBjPT0ib2JqZWN0In12YXIgdGU9VW4sRm49bGUsV249dGUsJG49IltvYmplY3QgTnVtYmVyXSI7ZnVuY3Rpb24gem4oYyl7cmV0dXJuIHR5cGVvZiBjPT0ibnVtYmVyInx8V24oYykmJkZuKGMpPT0kbn12YXIgd249em4sR249UmUod24pO2NsYXNzIHZ0IGV4dGVuZHMgaGV7dXBkYXRhT3B0U2VydmljZSgpe31jb25zdHJ1Y3RvcihlLHQscil7c3VwZXIodCxyKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidG1wUG9pbnRzIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6W119KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidG9vbHNUeXBlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6RHQuU2VsZWN0b3J9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywid29ya09wdGlvbnMiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywic3luY1RpbWVzdGFtcCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJjdXJOb2RlTWFwIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6bmV3IE1hcH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzZWxlY3RJZHMiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywib2xkUmVjdCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJub2RlQ29sb3IiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywibm9kZU9wYWN0aXkiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywib2xkU2VsZWN0UmVjdCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLHRoaXMud29ya09wdGlvbnM9ZSx0aGlzLnN5bmNUaW1lc3RhbXA9MH1jb21wdXROb2RlTWFwKGUpe3RoaXMuY3VyTm9kZU1hcC5jbGVhcigpLGUuZm9yRWFjaCh0PT57dmFyIHM7Y29uc3Qgcj10aGlzLmZ1bGxMYXllci5nZXRFbGVtZW50c0J5TmFtZSh0Lm5hbWUpWzBdfHwoKHM9dGhpcy5kcmF3TGF5ZXIpPT1udWxsP3ZvaWQgMDpzLmdldEVsZW1lbnRzQnlOYW1lKHQubmFtZSlbMF0pO2lmKHIpe2NvbnN0IGc9ci53b3JsZFBvc2l0aW9uO2xldCB2PXIuZ2V0QXR0cmlidXRlKCJzdHJva2VDb2xvciIpO2NvbnN0IGg9ci5jbGFzc05hbWUuc3BsaXQoIiwiKTtyLnRhZ05hbWU9PT0iR1JPVVAiJiYoTnVtYmVyKGhbMl0pPT09YnQuU3Ryb2tlP3Y9ci5nZXRBdHRyaWJ1dGUoImJnY29sb3IiKTp2PXIuY2hpbGRyZW5bMF0uZ2V0QXR0cmlidXRlKCJzdHJva2VDb2xvciIpKSx0aGlzLmN1ck5vZGVNYXAuc2V0KHQubmFtZSx7bmFtZTp0Lm5hbWUscmVjdDp0LnJlY3QsY29sb3I6bW4odilbMF0scG9zOmcscm90YXRlOnIuZ2V0QXR0cmlidXRlKCJyb3RhdGUiKXx8MCxzY2FsZTpyLmdldEF0dHJpYnV0ZSgic2NhbGUiKXx8WzEsMV0sb3BhY3RpeTpyLmdldEF0dHJpYnV0ZSgib3BhY2l0eSIpfHwxfSl9fSl9Y29tcHV0U2VsZWN0b3IoKXtsZXQgZTtjb25zdCB0PVtdLHI9bmV3IE1hcCxzPW5ldyBTZXQsZz1uZXcgU2V0LHY9bmV3IE1hcDtpZih0aGlzLnRtcFBvaW50cy5sZW5ndGgmJnRoaXMuY3VyTm9kZU1hcC5zaXplKXtjb25zdCBoPUh0KHRoaXMudG1wUG9pbnRzKTt0aGlzLmN1ck5vZGVNYXAuZm9yRWFjaCgobCx1KT0+e2NvbnN0IE09e3g6bC5yZWN0LngseTpsLnJlY3QueSx3OmwucmVjdC53LGg6bC5yZWN0Lmh9LGY9e3g6aC54LHk6aC55LHc6aC53LGg6aC5ofTtzcihmLE0pJiYodC5wdXNoKHUpLGU9Q3QoZSxNKSxyLnNldCh1LE0pLHMuYWRkKGwuY29sb3IpLHYuc2V0KHUsWy4uLmwucG9zLGwucm90YXRlXSksZy5hZGQobC5vcGFjdGl5KSl9KX1yZXR1cm57c2VsZWN0SWRzOnQsaW50ZXJzZWN0UmVjdDplLHN1YlJlY3RzOnIsbm9kZUNvbG9yczpzLHN1YlBvczp2LG9wYWN0aXlzOmd9fXVwZGF0ZVRlbXBQb2ludHMoZSl7Y29uc3QgdD10aGlzLnRtcFBvaW50cy5sZW5ndGgscj1lLmxlbmd0aDtpZihyPjEpe2NvbnN0IHM9bmV3IFB0KGVbci0yXSp0aGlzLmZ1bGxMYXllci53b3JsZFNjYWxpbmdbMF0rdGhpcy5mdWxsTGF5ZXIud29ybGRQb3NpdGlvblswXSxlW3ItMV0qdGhpcy5mdWxsTGF5ZXIud29ybGRTY2FsaW5nWzBdK3RoaXMuZnVsbExheWVyLndvcmxkUG9zaXRpb25bMV0pO3Q9PT0yP3RoaXMudG1wUG9pbnRzLnNwbGljZSgxLDEscyk6dGhpcy50bXBQb2ludHMucHVzaChzKX19ZHJhdyhlKXt2YXIgZyx2LGg7Y29uc3R7aW50ZXJzZWN0UmVjdDp0LHN1YlJlY3RzOnIsc3ViUG9zOnN9PWU7KGg9KHY9KGc9dGhpcy5kcmF3TGF5ZXIpPT1udWxsP3ZvaWQgMDpnLnBhcmVudCk9PW51bGw/dm9pZCAwOnYuZ2V0RWxlbWVudEJ5SWQodnQuc2VsZWN0b3JJZCkpPT1udWxsfHxoLnJlbW92ZSgpLHQmJnRoaXMuZHJhd0xheWVyJiZ0aGlzLmRyYXdTZWxlY3Rvcih7ZHJhd1JlY3Q6dCxzdWJSZWN0czpyLHN1YlBvczpzLHNlbGVjdG9ySWQ6dnQuc2VsZWN0b3JJZCxsYXllcjp0aGlzLmRyYXdMYXllcn0pfWNvbnN1bWUoZSl7Y29uc3R7b3A6dCx3b3JrU3RhdGU6cn09ZS5kYXRhO2lmKHI9PT1RdC5TdGFydCYmZS5ub2RlTWFwcyYmKHRoaXMuY29tcHV0Tm9kZU1hcChlLm5vZGVNYXBzKSx0aGlzLm9sZFJlY3Q9dGhpcy5iYWNrVG9GdWxsTGF5ZXIoZS5ub2RlTWFwcykpLCEodCE9bnVsbCYmdC5sZW5ndGgpfHwhdGhpcy5jdXJOb2RlTWFwLnNpemUpcmV0dXJue3R5cGU6RXQuTm9uZX07dGhpcy51cGRhdGVUZW1wUG9pbnRzKHQpO2NvbnN0IHM9dGhpcy5jb21wdXRTZWxlY3RvcigpO2lmKHRoaXMuc2VsZWN0SWRzJiZvbih0aGlzLnNlbGVjdElkcyxzLnNlbGVjdElkcykpcmV0dXJue3R5cGU6RXQuTm9uZX07dGhpcy5zZWxlY3RJZHM9cy5zZWxlY3RJZHM7Y29uc3QgZz10aGlzLmRyYXdMYXllciYmdGhpcy5nZXRTZWxlY3RvclJlY3QodGhpcy5kcmF3TGF5ZXIsdnQuc2VsZWN0b3JJZCwhMCksdj1zLmludGVyc2VjdFJlY3QmJnt4OnMuaW50ZXJzZWN0UmVjdC54LXZ0LlNlbGVjdEJvcmRlclBhZGRpbmcseTpzLmludGVyc2VjdFJlY3QueS12dC5TZWxlY3RCb3JkZXJQYWRkaW5nLHc6cy5pbnRlcnNlY3RSZWN0LncrdnQuU2VsZWN0Qm9yZGVyUGFkZGluZyoyLGg6cy5pbnRlcnNlY3RSZWN0LmgrdnQuU2VsZWN0Qm9yZGVyUGFkZGluZyoyfXx8dm9pZCAwO3JldHVybiB0aGlzLm9sZFJlY3Q9Q3QoZyx2KSx0aGlzLmRyYXcocyksdGhpcy5ub2RlQ29sb3I9cy5ub2RlQ29sb3JzLnNpemU9PT0xP3Mubm9kZUNvbG9ycy52YWx1ZXMoKS5uZXh0KCkudmFsdWU6dm9pZCAwLHRoaXMubm9kZU9wYWN0aXk9cy5vcGFjdGl5cy5zaXplPT09MT9zLm9wYWN0aXlzLnZhbHVlcygpLm5leHQoKS52YWx1ZToxLHRoaXMub2xkU2VsZWN0UmVjdD12LHt0eXBlOkV0LlNlbGVjdCxkYXRhVHlwZTpMdC5Mb2NhbCxyZWN0OnRoaXMub2xkUmVjdCxzZWxlY3RJZHM6cy5zZWxlY3RJZHMsb3B0OnRoaXMud29ya09wdGlvbnMscGFkZGluZzp2dC5TZWxlY3RCb3JkZXJQYWRkaW5nLHNlbGVjdFJlY3Q6dixub2RlQ29sb3I6dGhpcy5ub2RlQ29sb3Isbm9kZU9wYWN0aXk6dGhpcy5ub2RlT3BhY3RpeSx3aWxsU3luY1NlcnZpY2U6ITB9fWNvbnN1bWVBbGwoKXt2YXIgZTtyZXR1cm4oZT10aGlzLnNlbGVjdElkcykhPW51bGwmJmUubGVuZ3RoJiZ0aGlzLnNlYWxUb0RyYXdMYXllcih0aGlzLnNlbGVjdElkcyksdGhpcy5vbGRTZWxlY3RSZWN0P3t0eXBlOkV0LlNlbGVjdCxkYXRhVHlwZTpMdC5Mb2NhbCxyZWN0OnRoaXMub2xkUmVjdCxzZWxlY3RJZHM6dGhpcy5zZWxlY3RJZHMsb3B0OnRoaXMud29ya09wdGlvbnMscGFkZGluZzp2dC5TZWxlY3RCb3JkZXJQYWRkaW5nLHNlbGVjdFJlY3Q6dGhpcy5vbGRTZWxlY3RSZWN0LG5vZGVDb2xvcjp0aGlzLm5vZGVDb2xvcixub2RlT3BhY3RpeTp0aGlzLm5vZGVPcGFjdGl5LHdpbGxTeW5jU2VydmljZTohMX06e3R5cGU6RXQuTm9uZX19Y29uc3VtZVNlcnZpY2UoKXt9Y29tYmluZUNvbnN1bWUoKXt9Y2xlYXJUbXBQb2ludHMoKXt0aGlzLnRtcFBvaW50cy5sZW5ndGg9MH1jbGVhclNlbGVjdERhdGEoKXt0aGlzLnNlbGVjdElkcz12b2lkIDAsdGhpcy5vbGRSZWN0PXZvaWQgMCx0aGlzLm9sZFNlbGVjdFJlY3Q9dm9pZCAwfWJhY2tUb0Z1bGxMYXllcihlPW5ldyBNYXAsdCl7dmFyIHYsaDtsZXQgcjtjb25zdCBzPVtdLGc9W107Zm9yKGNvbnN0IGwgb2YoKHY9dGhpcy5kcmF3TGF5ZXIpPT1udWxsP3ZvaWQgMDp2LmNoaWxkcmVuKXx8W10paWYoISh0IT1udWxsJiZ0Lmxlbmd0aCYmIXQuaW5jbHVkZXMobC5pZCkpJiZsLmlkIT09dnQuc2VsZWN0b3JJZCl7Y29uc3QgdT1sLmNsb25lTm9kZSghMCk7aWYodS50YWdOYW1lPT09IkdST1VQIil7Y29uc3QgZj1sLmNsYXNzTmFtZS5zcGxpdCgiLCIpO2YubGVuZ3RoPT09MyYmTnVtYmVyKGZbMl0pPT09YnQuU3Ryb2tlJiZ1LnNlYWwoKX10aGlzLmZ1bGxMYXllci5nZXRFbGVtZW50c0J5TmFtZShsLm5hbWUpLmxlbmd0aHx8cy5wdXNoKHUpLGcucHVzaChsKTtjb25zdCBNPSgoaD1lLmdldChsLm5hbWUpKT09bnVsbD92b2lkIDA6aC5yZWN0KXx8WnQobC5uYW1lLHRoaXMuZHJhd0xheWVyKTtNJiYocj1DdChyLE0pKX1yZXR1cm4gZy5mb3JFYWNoKGw9PmwucmVtb3ZlKCkpLHMubGVuZ3RoJiZ0aGlzLmZ1bGxMYXllci5hcHBlbmQoLi4ucyksciYmKHIueC09dnQuU2VsZWN0Qm9yZGVyUGFkZGluZyxyLnktPXZ0LlNlbGVjdEJvcmRlclBhZGRpbmcsci53Kz12dC5TZWxlY3RCb3JkZXJQYWRkaW5nKjIsci5oKz12dC5TZWxlY3RCb3JkZXJQYWRkaW5nKjIpLHJ9c2VhbFRvRHJhd0xheWVyKGUpe3ZhciBzO2NvbnN0IHQ9W10scj1bXTtlLmZvckVhY2goZz0+e3RoaXMuZnVsbExheWVyLmdldEVsZW1lbnRzQnlOYW1lKGcudG9TdHJpbmcoKSkuZm9yRWFjaCh2PT57dmFyIGw7Y29uc3QgaD12LmNsb25lTm9kZSghMCk7aWYoaC50YWdOYW1lPT09IkdST1VQIil7Y29uc3QgdT12LmNsYXNzTmFtZS5zcGxpdCgiLCIpO3UubGVuZ3RoPT09MyYmTnVtYmVyKHVbMl0pPT09YnQuU3Ryb2tlJiZoLnNlYWwoKX0obD10aGlzLmRyYXdMYXllcikhPW51bGwmJmwuZ2V0RWxlbWVudHNCeU5hbWUodi5uYW1lKS5sZW5ndGh8fHQucHVzaChoKSxyLnB1c2godil9KX0pLHIuZm9yRWFjaChnPT5nLnJlbW92ZSgpKSx0JiYoKHM9dGhpcy5kcmF3TGF5ZXIpPT1udWxsfHxzLmFwcGVuZCguLi50KSl9dXBkYXRlU2VsZWN0b3JTaXplKGUsdCxyKXtjb25zdCBzPW5ldyBNYXAsZz1lLmdldEF0dHJpYnV0ZSgicG9zIiksdj1lLmNsYXNzTmFtZS5zcGxpdCgiLCIpLGg9dC12dC5TZWxlY3RCb3JkZXJQYWRkaW5nKjIsbD1yLXZ0LlNlbGVjdEJvcmRlclBhZGRpbmcqMix1PXYubGVuZ3RoPT09MiYmW2gvTnVtYmVyKHZbMF0pLGwvTnVtYmVyKHZbMV0pXXx8WzEsMV07cmV0dXJuIGUuc2V0QXR0cmlidXRlKCJzaXplIixbaCxsXSksZS5jaGlsZHJlbi5mb3JFYWNoKE09PntpZihNLmlkPT09dnQuc2VsZWN0b3JCb3JkZXJJZClNLnNldEF0dHJpYnV0ZSgicG9zIixbaC8yLGwvMl0pLE0uc2V0QXR0cmlidXRlKCJ3aWR0aCIsaCksTS5zZXRBdHRyaWJ1dGUoImhlaWdodCIsbCk7ZWxzZSBpZih1KXtjb25zdCBmPU0uY2xhc3NOYW1lLnNwbGl0KCIsIikseT1bTnVtYmVyKGZbMF0pKnVbMF0sTnVtYmVyKGZbMV0pKnVbMV1dLHg9TS5nZXRBdHRyaWJ1dGUoIndpZHRoIiksYj1NLmdldEF0dHJpYnV0ZSgiaGVpZ2h0IiksTz1OdW1iZXIoZlsyXSkqdVswXSxtPU51bWJlcihmWzNdKSp1WzFdO00uc2V0QXR0cmlidXRlKCJwb3MiLHkpLE0uc2V0QXR0cmlidXRlKCJ3aWR0aCIsTyksTS5zZXRBdHRyaWJ1dGUoImhlaWdodCIsbSk7Y29uc3QgcD1NLmlkLnNwbGl0KCJzZWxlY3Rvci0iKVsxXTtpZihwKXtjb25zdCBuPVt5WzBdK2dbMF0seVsxXStnWzFdXSxhPVtPL3gsbS9iXTtzLnNldChwLFtuWzBdLG5bMV0sYVswXSxhWzFdXSl9fX0pLHN9dXBkYXRlU2VsZWN0b3JSZWN0KGUsdCl7Y29uc3R7dzpyLGg6cyx4OmcseTp2fT10LGg9ci12dC5TZWxlY3RCb3JkZXJQYWRkaW5nKjIsbD1zLXZ0LlNlbGVjdEJvcmRlclBhZGRpbmcqMix1PWcrdnQuU2VsZWN0Qm9yZGVyUGFkZGluZyxNPXYrdnQuU2VsZWN0Qm9yZGVyUGFkZGluZztlLnNldEF0dHJpYnV0ZSgic2l6ZSIsW3Isc10pLGUuc2V0QXR0cmlidXRlKCJwb3MiLFt1LE1dKSxlLnNldEF0dHJpYnV0ZSgiY2xhc3NOYW1lIixgJHt0Lnd9LCR7dC5ofWApLGUuY2hpbGRyZW4uZm9yRWFjaChmPT57aWYoZi5zZXRBdHRyaWJ1dGUoInBvcyIsW2gvMixsLzJdKSxmLnNldEF0dHJpYnV0ZSgid2lkdGgiLGgpLGYuc2V0QXR0cmlidXRlKCJoZWlnaHQiLGwpLGYuaWQ9PT12dC5zZWxlY3RvckJvcmRlcklkKWYuc2V0QXR0cmlidXRlKCJjbGFzc05hbWUiLGAke3Qudy8yfSwke3QuaC8yfSwke3Qud30sJHt0Lmh9YCk7ZWxzZXtjb25zdCB5PWYuY2xhc3NOYW1lLnNwbGl0KCIsIikseD15JiZOdW1iZXIoeVs0XSl8fDA7Zi5zZXRBdHRyaWJ1dGUoImNsYXNzTmFtZSIsYCR7aC8yfSwke2wvMn0sJHt0Lnd9LCR7dC5ofSwke3h9YCl9fSl9Z2V0U2VsZWN0b3JSZWN0KGUsdCxyKXt2YXIgbDtsZXQgcztjb25zdCBnPShsPWUucGFyZW50KT09bnVsbD92b2lkIDA6bC5nZXRFbGVtZW50QnlJZCh0KSx2PWc9PW51bGw/dm9pZCAwOmcuZ2V0RWxlbWVudEJ5SWQodnQuc2VsZWN0b3JCb3JkZXJJZCksaD12PT1udWxsP3ZvaWQgMDp2LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO3JldHVybiBoJiYocz1DdChzLHt4Ok1hdGguZmxvb3IoaC54KSx5Ok1hdGguZmxvb3IoaC55KSx3Ok1hdGgucm91bmQoaC53aWR0aCksaDpNYXRoLnJvdW5kKGguaGVpZ2h0KX0pKSxzJiZyP3t4OnMueC12dC5TZWxlY3RCb3JkZXJQYWRkaW5nLHk6cy55LXZ0LlNlbGVjdEJvcmRlclBhZGRpbmcsdzpzLncrdnQuU2VsZWN0Qm9yZGVyUGFkZGluZyoyLGg6cy5oK3Z0LlNlbGVjdEJvcmRlclBhZGRpbmcqMn06c311cGRhdGVTZWxlY3RvcihlKXt2YXIgdSxNLGY7Y29uc3R7dXBkYXRlU2VsZWN0b3JPcHQ6dCxzZWxlY3RJZHM6cixzZWxlY3RTdG9yZTpzfT1lO2xldCBnO2NvbnN0IHY9bmV3IE1hcDtsZXQgaDtjb25zdCBsPShNPSh1PXRoaXMuZHJhd0xheWVyKT09bnVsbD92b2lkIDA6dS5wYXJlbnQpPT1udWxsP3ZvaWQgMDpNLmdldEVsZW1lbnRCeUlkKHZ0LnNlbGVjdG9ySWQpO2lmKGwpe2xldCB5O2lmKHQucG9zKXtjb25zdCB4PVt0LnBvc1swXSp0aGlzLmZ1bGxMYXllci53b3JsZFNjYWxpbmdbMF0rdGhpcy5mdWxsTGF5ZXIud29ybGRQb3NpdGlvblswXSx0LnBvc1sxXSp0aGlzLmZ1bGxMYXllci53b3JsZFNjYWxpbmdbMV0rdGhpcy5mdWxsTGF5ZXIud29ybGRQb3NpdGlvblsxXV0sYj1sLmdldEF0dHJpYnV0ZSgicG9zIik7eT1beFswXS1iWzBdLHhbMV0tYlsxXV0sbC5zZXRBdHRyaWJ1dGUoInBvcyIseCl9aWYodC5zZWxlY3RvckNvbG9yJiYoKGY9bC5nZXRFbGVtZW50QnlJZCh2dC5zZWxlY3RvckJvcmRlcklkKSk9PW51bGx8fGYuc2V0QXR0cmlidXRlKCJzdHJva2VDb2xvciIsdC5zZWxlY3RvckNvbG9yKSksdC5zaXplJiYoaD10aGlzLnVwZGF0ZVNlbGVjdG9yU2l6ZShsLHQuc2l6ZS53aWR0aCx0LnNpemUuaGVpZ2h0KSksdC5hbmdsZSlyPT1udWxsfHxyLmZvckVhY2goeD0+e3ZhciBiOyhiPXRoaXMuZHJhd0xheWVyKT09bnVsbHx8Yi5nZXRFbGVtZW50c0J5TmFtZSh4KS5mb3JFYWNoKE89PntpZihPKXtjb25zdCBtPXt1c2VBbmltYXRpb246ITF9O3QuYW5nbGUmJihtLmFuZ2xlPXQuYW5nbGUsbS5vcmlnaW5Qb3M9Ty5jbGFzc05hbWUuc3BsaXQoIiwiKS5tYXAobj0+TnVtYmVyKG4pKSxPLnNldEF0dHJpYnV0ZSgicm90YXRlIixtLmFuZ2xlKSksdi5zZXQoTy5uYW1lLG0pO2NvbnN0IHA9WnQoTy5uYW1lLHRoaXMuZHJhd0xheWVyKTtnPUN0KGcscCl9fSl9LHRoaXMpO2Vsc2V7cj09bnVsbHx8ci5mb3JFYWNoKE89Pnt2YXIgbTsobT10aGlzLmRyYXdMYXllcik9PW51bGx8fG0uZ2V0RWxlbWVudHNCeU5hbWUoTykuZm9yRWFjaChwPT57dmFyIG4sYTtpZihwKXtjb25zdCBpPXt1c2VBbmltYXRpb246ITF9O2lmKHQucG9zJiZ5KXtjb25zdCBUPXAuZ2V0QXR0cmlidXRlKCJwb3MiKTtpLnBvcz1beVswXS90aGlzLmZ1bGxMYXllci53b3JsZFNjYWxpbmdbMF0rVFswXSx5WzFdL3RoaXMuZnVsbExheWVyLndvcmxkU2NhbGluZ1swXStUWzFdXSxpLm9yaWdpblBvcz1wLmNsYXNzTmFtZS5zcGxpdCgiLCIpLm1hcChQPT5OdW1iZXIoUCkpLHAuc2V0QXR0cmlidXRlKCJwb3MiLGkucG9zKX1pZih0LnpJbmRleExheWVyJiYocyE9bnVsbCYmcy5oYXMoTykpKXtjb25zdCBUPShhPShuPXMuZ2V0KE8pKT09bnVsbD92b2lkIDA6bi51cGRhdGVOb2RlT3B0KT09bnVsbD92b2lkIDA6YS56SW5kZXg7R24oVCkmJihpLnpJbmRleD1ULHAuc2V0QXR0cmlidXRlKCJ6SW5kZXgiLGkuekluZGV4KSl9aWYodC56SW5kZXgmJihpLnpJbmRleD10LnpJbmRleCxwLnNldEF0dHJpYnV0ZSgiekluZGV4IixpLnpJbmRleCkpLHQuY29sb3Ipe2kuY29sb3I9dC5jb2xvcjtjb25zdCBUPXAuY2xhc3NOYW1lLnNwbGl0KCIsIik7cC50YWdOYW1lPT09IkdST1VQIj9OdW1iZXIoVFsyXSk9PT1idC5TdHJva2U/cC5zZXRBdHRyaWJ1dGUoImJnY29sb3IiLGkuY29sb3IpOnAuY2hpbGRyZW4uZm9yRWFjaChQPT57UC5zZXRBdHRyaWJ1dGUoInN0cm9rZUNvbG9yIixpLmNvbG9yKX0pOnAudGFnTmFtZT09PSJQQVRIIiYmKHAuc2V0QXR0cmlidXRlKCJzdHJva2VDb2xvciIsaS5jb2xvcikscC5nZXRBdHRyaWJ1dGUoImZpbGxDb2xvciIpJiZwLnNldEF0dHJpYnV0ZSgiZmlsbENvbG9yIixpLmNvbG9yKSl9dC5vcGFjaXR5JiYoaS5vcGFjaXR5PXQub3BhY2l0eSxwLnNldEF0dHJpYnV0ZSgib3BhY2l0eSIsaS5vcGFjaXR5KSk7Y29uc3Qgbz1oPT1udWxsP3ZvaWQgMDpoLmdldChwLm5hbWUpO2lmKG8pe2NvbnN0IFQ9cC5nZXRBdHRyaWJ1dGUoInNjYWxlIiksUD1bb1syXSpUWzBdLG9bM10qVFsxXV07aS5vcmlnaW5Qb3M9cC5jbGFzc05hbWUuc3BsaXQoIiwiKS5tYXAoQz0+TnVtYmVyKEMpKSxpLnBvcz1bKG9bMF0tdGhpcy5mdWxsTGF5ZXIud29ybGRQb3NpdGlvblswXSkvdGhpcy5mdWxsTGF5ZXIud29ybGRTY2FsaW5nWzBdLChvWzFdLXRoaXMuZnVsbExheWVyLndvcmxkUG9zaXRpb25bMV0pL3RoaXMuZnVsbExheWVyLndvcmxkU2NhbGluZ1sxXV0saS5zY2FsZT1QLHAuc2V0QXR0cmlidXRlKCJwb3MiLGkucG9zKSxwLnNldEF0dHJpYnV0ZSgic2NhbGUiLGkuc2NhbGUpfXYuc2V0KHAubmFtZSxpKX19KX0sdGhpcyk7Y29uc3QgeD1sLmdldEVsZW1lbnRCeUlkKHZ0LnNlbGVjdG9yQm9yZGVySWQpLGI9eD09bnVsbD92b2lkIDA6eC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtiJiYoZz1DdChnLHt4Ok1hdGguZmxvb3IoYi54KSx5Ok1hdGguZmxvb3IoYi55KSx3Ok1hdGgucm91bmQoYi53aWR0aCksaDpNYXRoLnJvdW5kKGIuaGVpZ2h0KX0pKX19aWYoZylyZXR1cm4gZy54LT12dC5TZWxlY3RCb3JkZXJQYWRkaW5nLGcueS09dnQuU2VsZWN0Qm9yZGVyUGFkZGluZyxnLncrPXZ0LlNlbGVjdEJvcmRlclBhZGRpbmcqMixnLmgrPXZ0LlNlbGVjdEJvcmRlclBhZGRpbmcqMix0LmFuZ2xlJiZ0aGlzLnVwZGF0ZVNlbGVjdG9yUmVjdChsLGcpLHRoaXMub2xkUmVjdD1DdCh0aGlzLm9sZFJlY3QsZyksdGhpcy5vbGRTZWxlY3RSZWN0PWcse3R5cGU6RXQuVXBkYXRlTm9kZSxkYXRhVHlwZTpMdC5Mb2NhbCxyZWN0OmcsdXBkYXRlTm9kZU9wdHM6dn19Ymx1clNlbGVjdG9yKGUpe2NvbnN0IHQ9dGhpcy5iYWNrVG9GdWxsTGF5ZXIoZSk7cmV0dXJue3R5cGU6RXQuU2VsZWN0LGRhdGFUeXBlOkx0LkxvY2FsLHJlY3Q6dCxzZWxlY3RJZHM6W10sd2lsbFN5bmNTZXJ2aWNlOiEwfX1nZXRSaWdodFNlcnZpY2VJZChlKXtyZXR1cm4gZS5yZXBsYWNlKCIrKyIsIi0iKX1kcmF3U2VsZWN0b3IoZSl7Y29uc3R7ZHJhd1JlY3Q6dCxzdWJSZWN0czpyLHN1YlBvczpzLHNlbGVjdG9ySWQ6ZyxsYXllcjp2fT1lLGg9bmV3IFNlKHtwb3M6W3QueCx0LnldLGFuY2hvcjpbMCwwXSxzaXplOlt0LncsdC5oXSxjbGFzc05hbWU6YCR7dC53fSwke3QuaH1gLGlkOmcsbmFtZTp2dC5zZWxlY3RvcklkLHpJbmRleDoxZTN9KSxsPVtdLHU9bmV3IGVyKHtub3JtYWxpemU6ITAscG9zOlt0LncvMix0LmgvMl0sbGluZVdpZHRoOjEsc3Ryb2tlQ29sb3I6dGhpcy53b3JrT3B0aW9ucy5jb2xvcix3aWR0aDp0LncsaGVpZ2h0OnQuaCxjbGFzc05hbWU6YCR7dC53LzJ9LCR7dC5oLzJ9LCR7dC53fSwke3QuaH1gLGlkOnZ0LnNlbGVjdG9yQm9yZGVySWR9KTtsLnB1c2godSksci5mb3JFYWNoKChNLGYpPT57Y29uc3QgeT1zPT1udWxsP3ZvaWQgMDpzLmdldChmKTtpZih5KXtjb25zdCB4PVt5WzBdLXQueCx5WzFdLXQueV0sYj1gJHt4WzBdfSwke3hbMV19LCR7TS53fSwke00uaH0sJHt5WzJdfWAsTz1uZXcgZXIoe25vcm1hbGl6ZTohMCxwb3M6eCxsaW5lV2lkdGg6MSxzdHJva2VDb2xvcjpyLnNpemU+MT90aGlzLndvcmtPcHRpb25zLmNvbG9yOnZvaWQgMCx3aWR0aDpNLncsaGVpZ2h0Ok0uaCxjbGFzc05hbWU6YixpZDpgc2VsZWN0b3ItJHtmfWAsbmFtZTpgc2VsZWN0b3ItJHtmfWB9KTtsLnB1c2goTyl9fSksbCYmaC5hcHBlbmQoLi4ubCksKHY9PW51bGw/dm9pZCAwOnYucGFyZW50KS5hcHBlbmRDaGlsZChoKX1zZWxlY3RTZXJ2aWNlTm9kZShlLHQscil7dmFyIE07Y29uc3R7c2VsZWN0SWRzOnN9PXQsZz10aGlzLmdldFJpZ2h0U2VydmljZUlkKGUpLHY9dGhpcy5nZXRTZWxlY3RvclJlY3QodGhpcy5mdWxsTGF5ZXIsZywhMCk7KE09dGhpcy5mdWxsTGF5ZXIucGFyZW50LmdldEVsZW1lbnRCeUlkKGcpKT09bnVsbHx8TS5yZW1vdmUoKTtsZXQgaDtjb25zdCBsPW5ldyBNYXAsdT1uZXcgTWFwO3JldHVybiBzPT1udWxsfHxzLmZvckVhY2goZj0+e3ZhciBiO2NvbnN0IHk9ci5nZXQoZikseD10aGlzLmZ1bGxMYXllci5nZXRFbGVtZW50c0J5TmFtZShmKVswXTtpZih5JiZ4KXtoPUN0KGgseS5yZWN0KSxsLnNldChmLHkucmVjdCk7Y29uc3QgTz14LndvcmxkUG9zaXRpb24sbT0oKGI9eS5vcHQpPT1udWxsP3ZvaWQgMDpiLnJvdGF0ZSl8fHguZ2V0QXR0cmlidXRlKCJyb3RhdGUiKXx8MDt1LnNldChmLFsuLi5PLG1dKX19KSxoJiZ0aGlzLmZ1bGxMYXllciYmdGhpcy5kcmF3U2VsZWN0b3Ioe2RyYXdSZWN0Omgsc3ViUmVjdHM6bCxzdWJQb3M6dSxzZWxlY3RvcklkOmcsbGF5ZXI6dGhpcy5mdWxsTGF5ZXJ9KSxoPUN0KGgsdiksaCYmKGgueC09dnQuU2VsZWN0Qm9yZGVyUGFkZGluZyxoLnktPXZ0LlNlbGVjdEJvcmRlclBhZGRpbmcsaC53Kz12dC5TZWxlY3RCb3JkZXJQYWRkaW5nKjIsaC5oKz12dC5TZWxlY3RCb3JkZXJQYWRkaW5nKjIpLGh9cmVtb3ZlU2VydmljZSgpe3Rocm93IG5ldyBFcnJvcigiTWV0aG9kIG5vdCBpbXBsZW1lbnRlZC4iKX1nZXRTZWxlY3RvcihlKXt2YXIgZztsZXQgdDtjb25zdCByPW5ldyBNYXAscz1uZXcgTWFwO3JldHVybihnPXRoaXMuc2VsZWN0SWRzKT09bnVsbHx8Zy5mb3JFYWNoKHY9Pnt2YXIgdTtjb25zdCBoPWUuZ2V0KHYpLGw9KHU9dGhpcy5kcmF3TGF5ZXIpPT1udWxsP3ZvaWQgMDp1LmdldEVsZW1lbnRzQnlOYW1lKHYpWzBdO2lmKGgmJmwpe2NvbnN0IE09bC53b3JsZFBvc2l0aW9uLGY9bC5nZXRBdHRyaWJ1dGUoInJvdGF0ZSIpfHwwO3Q9Q3QodCxoLnJlY3QpLHIuc2V0KHYsaC5yZWN0KSxzLnNldCh2LFsuLi5NLGZdKX19LHRoaXMpLHRoaXMub2xkUmVjdD1DdCh0LHRoaXMub2xkUmVjdCksdGhpcy5kcmF3KHtpbnRlcnNlY3RSZWN0OnQsc3ViUmVjdHM6cixzdWJQb3M6c30pLHQmJih0LngtPXZ0LlNlbGVjdEJvcmRlclBhZGRpbmcsdC55LT12dC5TZWxlY3RCb3JkZXJQYWRkaW5nLHQudys9dnQuU2VsZWN0Qm9yZGVyUGFkZGluZyoyLHQuaCs9dnQuU2VsZWN0Qm9yZGVyUGFkZGluZyoyKSx0aGlzLm9sZFNlbGVjdFJlY3Q9dCx0fXVwZGF0ZVNlbGVjdElkcyhlLHQpe3ZhciBoLGw7bGV0IHI7Y29uc3Qgcz0oaD10aGlzLnNlbGVjdElkcyk9PW51bGw/dm9pZCAwOmguZmlsdGVyKHU9PiFlLmluY2x1ZGVzKHUpKSxnPWUuZmlsdGVyKHU9Pnt2YXIgTTtyZXR1cm4hKChNPXRoaXMuc2VsZWN0SWRzKSE9bnVsbCYmTS5pbmNsdWRlcyh1KSl9KTtpZihzIT1udWxsJiZzLmxlbmd0aCYmKHI9dGhpcy5iYWNrVG9GdWxsTGF5ZXIodCxzKSksZy5sZW5ndGgpe3RoaXMuc2VhbFRvRHJhd0xheWVyKGcpO2Zvcihjb25zdCB1IG9mIGcpe2NvbnN0IE09KGw9dC5nZXQodSkpPT1udWxsP3ZvaWQgMDpsLnJlY3Q7TSYmKHI9Q3QocixNKSl9ciYmKHIueC09dnQuU2VsZWN0Qm9yZGVyUGFkZGluZyxyLnktPXZ0LlNlbGVjdEJvcmRlclBhZGRpbmcsci53Kz12dC5TZWxlY3RCb3JkZXJQYWRkaW5nKjIsci5oKz12dC5TZWxlY3RCb3JkZXJQYWRkaW5nKjIpfXRoaXMuc2VsZWN0SWRzPWU7Y29uc3Qgdj10aGlzLmdldFNlbGVjdG9yKHQpO3JldHVybntiZ1JlY3Q6cixzZWxlY3RSZWN0OnZ9fX1PYmplY3QuZGVmaW5lUHJvcGVydHkodnQsInNlbGVjdG9ySWQiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2bn0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh2dCwic2VsZWN0b3JCb3JkZXJJZCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOiJzZWxlY3Rvci1ib3JkZXIifSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHZ0LCJTZWxlY3RCb3JkZXJQYWRkaW5nIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6Mn0pO2NsYXNzIEtuIGV4dGVuZHMgaGV7dXBkYXRhT3B0U2VydmljZSgpe31jb25zdHJ1Y3RvcihlLHQpe3N1cGVyKHQpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzeW5jVGltZXN0YW1wIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInN5bmNJbmRleCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOjB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidG9vbHNUeXBlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6RHQuTGFzZXJQZW59KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidG1wUG9pbnRzIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6W119KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywid29ya09wdGlvbnMiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiY29uc3VtZUluZGV4Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6MH0pLHRoaXMud29ya09wdGlvbnM9ZSx0aGlzLnN5bmNUaW1lc3RhbXA9MH1jb21iaW5lQ29uc3VtZSgpe31zZXRXb3JrT3B0aW9ucyhlKXtzdXBlci5zZXRXb3JrT3B0aW9ucyhlKSx0aGlzLnN5bmNUaW1lc3RhbXA9RGF0ZS5ub3coKX1jb25zdW1lKGUpe2NvbnN0e2RhdGE6dCxpc0Z1bGxXb3JrOnJ9PWUse3dvcmtJZDpzLG9wOmd9PXQ7aWYoKGc9PW51bGw/dm9pZCAwOmcubGVuZ3RoKT09PTApcmV0dXJue3R5cGU6RXQuTm9uZX07aWYodGhpcy51cGRhdGVUZW1wUG9pbnRzKGd8fFtdKSx0aGlzLmNvbnN1bWVJbmRleD50aGlzLnRtcFBvaW50cy5sZW5ndGgtNClyZXR1cm57dHlwZTpFdC5Ob25lfTtjb25zdHtjb2xvcjp2LHRoaWNrbmVzczpoLHN0cm9rZVR5cGU6bCxvcGFjaXR5OnV9PXRoaXMud29ya09wdGlvbnMsTT1IdCh0aGlzLnRtcFBvaW50cyxoKTtsZXQgZj0hMTtjb25zdCB5PXRoaXMuc3luY0luZGV4LHg9dGhpcy50bXBQb2ludHMuc2xpY2UodGhpcy5jb25zdW1lSW5kZXgpO3RoaXMuY29uc3VtZUluZGV4PXRoaXMudG1wUG9pbnRzLmxlbmd0aC0xLHRoaXMuc3luY1RpbWVzdGFtcD09PTAmJih0aGlzLnN5bmNUaW1lc3RhbXA9RGF0ZS5ub3coKSk7Y29uc3QgYj17bmFtZTpzPT1udWxsP3ZvaWQgMDpzLnRvU3RyaW5nKCksY2xhc3NOYW1lOiJMYXNlclBlbiIsb3BhY2l0eTp1fHwxLGxpbmVEYXNoOmw9PT1idC5Eb3R0ZWQ/WzEsaCoyXTpsPT09YnQuTG9uZ0RvdHRlZD9baCxoKjJdOnZvaWQgMCxzdHJva2VDb2xvcjp2LGxpbmVDYXA6InJvdW5kIixsaW5lV2lkdGg6aCxhbmNob3I6Wy41LC41XX0sTz10aGlzLmdldFRhc2tQb2ludHMoeCk7aWYoTy5sZW5ndGgpe2NvbnN0IHA9RGF0ZS5ub3coKTtwLXRoaXMuc3luY1RpbWVzdGFtcD50aGlzLnN5bmNVbml0VGltZSYmKGY9ITAsdGhpcy5zeW5jVGltZXN0YW1wPXAsdGhpcy5zeW5jSW5kZXg9dGhpcy50bXBQb2ludHMubGVuZ3RoKSwhciYmdGhpcy5kcmF3KHthdHRyczpiLHRhc2tzOk8saXNEb3Q6ITF9KX1jb25zdCBtPVtdO3JldHVybiB0aGlzLnRtcFBvaW50cy5zbGljZSh5KS5mb3JFYWNoKHA9PnttLnB1c2gocC54LHAueSl9KSx7cmVjdDp7eDpNLngqdGhpcy5mdWxsTGF5ZXIud29ybGRTY2FsaW5nWzBdK3RoaXMuZnVsbExheWVyLndvcmxkUG9zaXRpb25bMF0seTpNLnkqdGhpcy5mdWxsTGF5ZXIud29ybGRTY2FsaW5nWzFdK3RoaXMuZnVsbExheWVyLndvcmxkUG9zaXRpb25bMV0sdzpNLncqdGhpcy5mdWxsTGF5ZXIud29ybGRTY2FsaW5nWzBdLGg6TS5oKnRoaXMuZnVsbExheWVyLndvcmxkU2NhbGluZ1sxXX0sdHlwZTpFdC5EcmF3V29yayxkYXRhVHlwZTpMdC5Mb2NhbCx3b3JrSWQ6Zj9zOnZvaWQgMCxvcDpmP206dm9pZCAwLGluZGV4OmY/eSoyOnZvaWQgMH19Y29uc3VtZUFsbCgpe3ZhciBzO2NvbnN0IGU9KHM9dGhpcy53b3JrSWQpPT1udWxsP3ZvaWQgMDpzLnRvU3RyaW5nKCk7bGV0IHQ7aWYodGhpcy50bXBQb2ludHMubGVuZ3RoLTE+dGhpcy5jb25zdW1lSW5kZXgpe2xldCBnPXRoaXMudG1wUG9pbnRzLnNsaWNlKHRoaXMuY29uc3VtZUluZGV4KTtjb25zdCB2PWcubGVuZ3RoPT09MSx7Y29sb3I6aCx0aGlja25lc3M6bCxzdHJva2VUeXBlOnUsb3BhY2l0eTpNfT10aGlzLndvcmtPcHRpb25zO2lmKHYpe2NvbnN0IHg9dGhpcy5jb21wdXREb3RTdHJva2Uoe3BvaW50OmdbMF0scmFkaXVzOmwvMn0pO2c9eC5wcyx0PXgucmVjdH1lbHNlIHQ9SHQodGhpcy50bXBQb2ludHMsbCk7Y29uc3QgZj17bmFtZTplPT1udWxsP3ZvaWQgMDplLnRvU3RyaW5nKCksY2xhc3NOYW1lOiJMYXNlclBlbiIsZmlsbENvbG9yOnY/aDp2b2lkIDAsb3BhY2l0eTpNfHwxLGxpbmVEYXNoOnU9PT1idC5Eb3R0ZWQmJiF2P1sxLGwqMl06dT09PWJ0LkxvbmdEb3R0ZWQmJiF2P1tsLGwqMl06dm9pZCAwLHN0cm9rZUNvbG9yOmgsbGluZUNhcDp2P3ZvaWQgMDoicm91bmQiLGxpbmVXaWR0aDp2PzA6bCxhbmNob3I6Wy41LC41XX0seT10aGlzLmdldFRhc2tQb2ludHMoZyk7eS5sZW5ndGgmJnRoaXMuZHJhdyh7YXR0cnM6Zix0YXNrczp5LGlzRG90OnZ9KX1jb25zdCByPVtdO3JldHVybiB0aGlzLnRtcFBvaW50cy5zbGljZSh0aGlzLnN5bmNJbmRleCkuZm9yRWFjaChnPT57ci5wdXNoKGcueCxnLnkpfSkse3JlY3Q6dCYme3g6dC54KnRoaXMuZnVsbExheWVyLndvcmxkU2NhbGluZ1swXSt0aGlzLmZ1bGxMYXllci53b3JsZFBvc2l0aW9uWzBdLHk6dC55KnRoaXMuZnVsbExheWVyLndvcmxkU2NhbGluZ1sxXSt0aGlzLmZ1bGxMYXllci53b3JsZFBvc2l0aW9uWzFdLHc6dC53KnRoaXMuZnVsbExheWVyLndvcmxkU2NhbGluZ1swXSxoOnQuaCp0aGlzLmZ1bGxMYXllci53b3JsZFNjYWxpbmdbMV19LHR5cGU6RXQuRHJhd1dvcmssZGF0YVR5cGU6THQuTG9jYWwsd29ya0lkOmUsb3A6cixpbmRleDp0aGlzLnN5bmNJbmRleCoyfX1jbGVhclRtcFBvaW50cygpe3RoaXMudG1wUG9pbnRzLmxlbmd0aD0wLHRoaXMuc3luY1RpbWVzdGFtcD0wLHRoaXMuc3luY0luZGV4PTB9Y29uc3VtZVNlcnZpY2UoZSl7dmFyIHg7Y29uc3R7b3A6dH09ZSx7Y29sb3I6cix0aGlja25lc3M6cyxzdHJva2VUeXBlOmcsb3BhY2l0eTp2fT10aGlzLndvcmtPcHRpb25zO2lmKCF0Lmxlbmd0aCl7Y29uc3QgYj1IdCh0aGlzLnRtcFBvaW50cyxzKTtyZXR1cm57eDpiLngqdGhpcy5mdWxsTGF5ZXIud29ybGRTY2FsaW5nWzBdK3RoaXMuZnVsbExheWVyLndvcmxkUG9zaXRpb25bMF0seTpiLnkqdGhpcy5mdWxsTGF5ZXIud29ybGRTY2FsaW5nWzFdK3RoaXMuZnVsbExheWVyLndvcmxkUG9zaXRpb25bMV0sdzpiLncqdGhpcy5mdWxsTGF5ZXIud29ybGRTY2FsaW5nWzBdLGg6Yi5oKnRoaXMuZnVsbExheWVyLndvcmxkU2NhbGluZ1sxXX19Y29uc3QgaD1NYXRoLm1heCgwLHRoaXMudG1wUG9pbnRzLmxlbmd0aC0xKTt0aGlzLnVwZGF0ZVRlbXBQb2ludHModHx8W10pO2xldCBsLHU9dGhpcy50bXBQb2ludHMuc2xpY2UoaCk7Y29uc3QgTT11Lmxlbmd0aD09PTE7aWYoTSl7Y29uc3QgYj10aGlzLmNvbXB1dERvdFN0cm9rZSh7cG9pbnQ6dVswXSxyYWRpdXM6cy8yfSk7dT1iLnBzLGw9Yi5yZWN0fWVsc2UgbD1IdCh0aGlzLnRtcFBvaW50cyxzKTtjb25zdCBmPXtuYW1lOih4PXRoaXMud29ya0lkKT09bnVsbD92b2lkIDA6eC50b1N0cmluZygpLGNsYXNzTmFtZToiTGFzZXJQZW4iLGZpbGxDb2xvcjpNP3I6dm9pZCAwLG9wYWNpdHk6dnx8MSxsaW5lRGFzaDpnPT09YnQuRG90dGVkJiYhTT9bMSxzKjJdOmc9PT1idC5Mb25nRG90dGVkJiYhTT9bcyxzKjJdOnZvaWQgMCxzdHJva2VDb2xvcjpyLGxpbmVDYXA6TT92b2lkIDA6InJvdW5kIixsaW5lV2lkdGg6TT8wOnMsYW5jaG9yOlsuNSwuNV19LHk9dGhpcy5nZXRUYXNrUG9pbnRzKHUpO3JldHVybiB5Lmxlbmd0aCYmdGhpcy5kcmF3KHthdHRyczpmLHRhc2tzOnksaXNEb3Q6TX0pLHt4OmwueCp0aGlzLmZ1bGxMYXllci53b3JsZFNjYWxpbmdbMF0rdGhpcy5mdWxsTGF5ZXIud29ybGRQb3NpdGlvblswXSx5OmwueSp0aGlzLmZ1bGxMYXllci53b3JsZFNjYWxpbmdbMV0rdGhpcy5mdWxsTGF5ZXIud29ybGRQb3NpdGlvblsxXSx3Omwudyp0aGlzLmZ1bGxMYXllci53b3JsZFNjYWxpbmdbMF0saDpsLmgqdGhpcy5mdWxsTGF5ZXIud29ybGRTY2FsaW5nWzFdfX1jb21wdXREb3RTdHJva2UoZSl7Y29uc3R7cG9pbnQ6dCxyYWRpdXM6cn09ZSxzPXt4OnQueC1yLHk6dC55LXIsdzpyKjIsaDpyKjJ9O3JldHVybntwczpQdC5HZXREb3RTdHJva2UodCxyLDgpLHJlY3Q6c319dXBkYXRlVGVtcFBvaW50cyhlKXtjb25zdCB0PXRoaXMudG1wUG9pbnRzLmxlbmd0aDtmb3IobGV0IHI9MDtyPGUubGVuZ3RoO3IrPTIpe2lmKHQpe2NvbnN0IHM9dGhpcy50bXBQb2ludHMuc2xpY2UoLTEpWzBdO3MmJnMueD09PWVbcl0mJnMueT09PWVbcisxXSYmdGhpcy50bXBQb2ludHMucG9wKCl9dGhpcy50bXBQb2ludHMucHVzaChuZXcgUHQoZVtyXSxlW3IrMV0pKX19YXN5bmMgZHJhdyhlKXtjb25zdHthdHRyczp0LHRhc2tzOnIsaXNEb3Q6c309ZSxnPXRoaXMuZnVsbExheWVyLHtkdXJhdGlvbjp2fT10aGlzLndvcmtPcHRpb25zLGg9bmV3IGJlO2ZvcihsZXQgbD0wO2w8ci5sZW5ndGg7bCsrKXtjb25zdHtwb3M6dSxwb2ludHM6TX09cltsXTtsZXQgZjtzP2Y9Z2UoTSwhMCk6Zj1nZShNLCExKSxoLmF0dHIoey4uLnQscG9zOnUsZDpmfSk7Y29uc3R7dmVydGV4OnksZnJhZ21lbnQ6eH09dGhpcy53b3JrT3B0aW9ucztpZih5JiZ4KXtjb25zdCBiPWcucmVuZGVyZXIuY3JlYXRlUHJvZ3JhbSh7dmVydGV4OnksZnJhZ21lbnQ6eH0pLHt3aWR0aDpPLGhlaWdodDptfT1nLmdldFJlc29sdXRpb24oKTtoLnNldFVuaWZvcm1zKHt1X3RpbWU6MCx1X3Jlc29sdXRpb246W08sbV19KSxoLnNldFByb2dyYW0oYil9Zy5hcHBlbmRDaGlsZChoKSxhd2FpdCBoLnRyYW5zaXRpb24odikuYXR0cih7c2NhbGU6cz9bLjEsLjFdOlsxLDFdLGxpbmVXaWR0aDpzPzA6MX0pLGgucmVtb3ZlKCl9fWdldFRhc2tQb2ludHMoZSl7dmFyIGw7Y29uc3QgdD1bXTtpZihlLmxlbmd0aD09PTApcmV0dXJuW107bGV0IHI9MCxzPWVbMF0ueCxnPWVbMF0ueSx2PVtzLGddLGg9W107Zm9yKDtyPGUubGVuZ3RoOyl7Y29uc3QgdT1lW3JdLE09dS54LXMsZj11LnktZztpZihoLnB1c2gobmV3IFB0KE0sZikpLHI+MCYmcjxlLmxlbmd0aC0xKXtjb25zdCB5PWVbcl0uZ2V0QW5nbGVCeVBvaW50cyhlW3ItMV0sZVtyKzFdKTtpZih5PDkwfHx5PjI3MCl7Y29uc3QgeD0obD1oLnBvcCgpKT09bnVsbD92b2lkIDA6bC5jbG9uZSgpO3gmJnQucHVzaCh7cG9zOnYscG9pbnRzOlsuLi5oLHhdfSkscz1lW3JdLngsZz1lW3JdLnksdj1bcyxnXTtjb25zdCBiPXUueC1zLE89dS55LWc7aD1bbmV3IFB0KGIsTyldfX1yKyt9cmV0dXJuIHQucHVzaCh7cG9zOnYscG9pbnRzOmh9KSx0fXJlbW92ZUxvY2FsKCl7fXJlbW92ZVNlcnZpY2UoZSl7bGV0IHQ7Y29uc3Qgcj1bXTtyZXR1cm4gdGhpcy5mdWxsTGF5ZXIuZ2V0RWxlbWVudHNCeU5hbWUoZSkuZm9yRWFjaChzPT57aWYocy5uYW1lPT09ZSl7Y29uc3QgZz1zLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO3Q9Q3QodCx7eDpnLngseTpnLnksdzpnLndpZHRoLGg6Zy5oZWlnaHR9KSxyLnB1c2gocyl9fSksci5sZW5ndGgmJnIuZm9yRWFjaChzPT5zLnJlbW92ZSgpKSx0fX1jbGFzcyBIbntjb25zdHJ1Y3Rvcigpe09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJjdXJOb2RlTWFwIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6bmV3IE1hcH0pfXVwZGF0ZVNjZW5lKGUpe3RoaXMuc2NlbmUuYXR0cih7Li4uZX0pO2NvbnN0e3dpZHRoOnQsaGVpZ2h0OnJ9PWU7dGhpcy5zY2VuZS5jb250YWluZXIud2lkdGg9dCx0aGlzLnNjZW5lLmNvbnRhaW5lci5oZWlnaHQ9cix0aGlzLnNjZW5lLndpZHRoPXQsdGhpcy5zY2VuZS5oZWlnaHQ9cix0aGlzLnVwZGF0ZUxheWVyKHt3aWR0aDp0LGhlaWdodDpyfSl9dXBkYXRlTGF5ZXIoZSl7Y29uc3R7d2lkdGg6dCxoZWlnaHQ6cn09ZTt0aGlzLmZ1bGxMYXllciYmKHRoaXMuZnVsbExheWVyLnBhcmVudC5zZXRBdHRyaWJ1dGUoIndpZHRoIix0KSx0aGlzLmZ1bGxMYXllci5wYXJlbnQuc2V0QXR0cmlidXRlKCJoZWlnaHQiLHIpLHRoaXMuZnVsbExheWVyLnNldEF0dHJpYnV0ZSgic2l6ZSIsW3Qscl0pLHRoaXMuZnVsbExheWVyLnNldEF0dHJpYnV0ZSgicG9zIixbdCouNSxyKi41XSkpLHRoaXMuZHJhd0xheWVyJiYodGhpcy5kcmF3TGF5ZXIucGFyZW50LnNldEF0dHJpYnV0ZSgid2lkdGgiLHQpLHRoaXMuZHJhd0xheWVyLnBhcmVudC5zZXRBdHRyaWJ1dGUoImhlaWdodCIsciksdGhpcy5kcmF3TGF5ZXIuc2V0QXR0cmlidXRlKCJzaXplIixbdCxyXSksdGhpcy5kcmF3TGF5ZXIuc2V0QXR0cmlidXRlKCJwb3MiLFt0Ki41LHIqLjVdKSksdGhpcy5zbmFwc2hvdEZ1bGxMYXllciYmKHRoaXMuc25hcHNob3RGdWxsTGF5ZXIucGFyZW50LnNldEF0dHJpYnV0ZSgid2lkdGgiLHQpLHRoaXMuc25hcHNob3RGdWxsTGF5ZXIucGFyZW50LnNldEF0dHJpYnV0ZSgiaGVpZ2h0IixyKSx0aGlzLnNuYXBzaG90RnVsbExheWVyLnNldEF0dHJpYnV0ZSgic2l6ZSIsW3Qscl0pLHRoaXMuc25hcHNob3RGdWxsTGF5ZXIuc2V0QXR0cmlidXRlKCJwb3MiLFt0Ki41LHIqLjVdKSl9Y3JlYXRlU2NlbmUoZSl7Y29uc3R7d2lkdGg6dCxoZWlnaHQ6cn09ZSxzPW5ldyBPZmZzY3JlZW5DYW52YXModCxyKTtyZXR1cm4gbmV3IG5uKHtjb250YWluZXI6cyxkaXNwbGF5UmF0aW86dGhpcy5kcHIsZGVwdGg6ITEsZGVzeW5jaHJvbml6ZWQ6ITAsLi4uZX0pfWNyZWF0ZUxheWVyKGUsdCl7Y29uc3R7d2lkdGg6cixoZWlnaHQ6c309dCxnPSJvZmZzY3JlZW4iK0RhdGUubm93KCksdj1lLmxheWVyKGcsdCksaD1uZXcgU2Uoe2FuY2hvcjpbLjUsLjVdLHBvczpbciouNSxzKi41XSxzaXplOltyLHNdLG5hbWU6InZpZXdwb3J0In0pO3JldHVybiB2LmFwcGVuZChoKSxofWdldE5vZGVzKGUpe3JldHVybiB0aGlzLmZ1bGxMYXllci5nZXRFbGVtZW50c0J5TmFtZShlKyIiKS5jb25jYXQodGhpcy5kcmF3TGF5ZXIuZ2V0RWxlbWVudHNCeU5hbWUoZSsiIikpfX1jbGFzcyBWbntjb25zdHJ1Y3RvcihlLHQscil7T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImZ1bGxMYXllciIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJkcmF3TGF5ZXIiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiY3VyTm9kZU1hcCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ0bXBXb3JrU2hhcGVOb2RlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInRtcE9wdCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ3b3JrU2hhcGVTdGF0ZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOm5ldyBNYXB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiZWZmZWN0V29ya0lkIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksdGhpcy5jdXJOb2RlTWFwPWUsdGhpcy5mdWxsTGF5ZXI9dCx0aGlzLmRyYXdMYXllcj1yfWdldFdvcmtTaGFwZShlKXtyZXR1cm4gdGhpcy53b3JrU2hhcGVzLmdldChlKX1nZXRUbXBXb3JrU2hhcGVOb2RlKCl7cmV0dXJuIHRoaXMudG1wV29ya1NoYXBlTm9kZX1zZXRUbXBXb3JrSWQoZSl7aWYoZSYmdGhpcy50bXBXb3JrU2hhcGVOb2RlKXt0aGlzLnRtcFdvcmtTaGFwZU5vZGUuc2V0V29ya0lkKGUpLHRoaXMud29ya1NoYXBlcy5zZXQoZSx0aGlzLnRtcFdvcmtTaGFwZU5vZGUpLHRoaXMudG1wT3B0JiZ0aGlzLnNldFRvb2xzT3B0KHRoaXMudG1wT3B0KTtyZXR1cm59fXNldFRtcFdvcmtPcHRpb25zKGUpe3ZhciB0Oyh0PXRoaXMudG1wV29ya1NoYXBlTm9kZSk9PW51bGx8fHQuc2V0V29ya09wdGlvbnMoZSl9c2V0V29ya09wdGlvbnMoZSx0KXt2YXIgczt0aGlzLndvcmtTaGFwZXMuZ2V0KGUpfHx0aGlzLnNldFRtcFdvcmtJZChlKSwocz10aGlzLndvcmtTaGFwZXMuZ2V0KGUpKT09bnVsbHx8cy5zZXRXb3JrT3B0aW9ucyh0KX1jcmVhdGVXb3JrU2hhcGVOb2RlKGUpe2xldCB0O3N3aXRjaChlLnRvb2xzVHlwZSl7Y2FzZSBEdC5QZW5jaWw6dD1uZXcgVXQoZS50b29sc09wdCx0aGlzLmZ1bGxMYXllcix0aGlzLmRyYXdMYXllcik7YnJlYWs7Y2FzZSBEdC5MYXNlclBlbjp0PW5ldyBLbihlLnRvb2xzT3B0LHRoaXMuZnVsbExheWVyKTticmVhaztjYXNlIER0LkVyYXNlcjp0PW5ldyB6dChlLnRvb2xzT3B0LHRoaXMuZnVsbExheWVyKTticmVhaztjYXNlIER0LlNlbGVjdG9yOnQ9bmV3IHZ0KGUudG9vbHNPcHQsdGhpcy5mdWxsTGF5ZXIsdGhpcy5kcmF3TGF5ZXIpO2JyZWFrO2RlZmF1bHQ6dD12b2lkIDA7YnJlYWt9cmV0dXJuIHR9c2V0VG9vbHNPcHQoZSl7dmFyIHQscjsoKHQ9dGhpcy50bXBPcHQpPT1udWxsP3ZvaWQgMDp0LnRvb2xzVHlwZSkhPT1lLnRvb2xzVHlwZSYmKHI9dGhpcy50bXBPcHQpIT1udWxsJiZyLnRvb2xzVHlwZSYmdGhpcy5jbGVhckFsbFdvcmtTaGFwZXNDYWNoZSgpLHRoaXMudG1wT3B0PWUsdGhpcy50bXBXb3JrU2hhcGVOb2RlPXRoaXMuY3JlYXRlV29ya1NoYXBlTm9kZShlKX1jbGVhcldvcmtTaGFwZU5vZGVDYWNoZShlKXt2YXIgdDsodD10aGlzLmdldFdvcmtTaGFwZShlKSk9PW51bGx8fHQuY2xlYXJUbXBQb2ludHMoKSx0aGlzLndvcmtTaGFwZXMuZGVsZXRlKGUpLHRoaXMud29ya1NoYXBlU3RhdGUuZGVsZXRlKGUpfWNsZWFyQWxsV29ya1NoYXBlc0NhY2hlKCl7dGhpcy53b3JrU2hhcGVzLmZvckVhY2goZT0+ZS5jbGVhclRtcFBvaW50cygpKSx0aGlzLndvcmtTaGFwZXMuY2xlYXIoKSx0aGlzLndvcmtTaGFwZVN0YXRlLmNsZWFyKCl9cnVuRWZmZWN0V29yayhlKXt0aGlzLmVmZmVjdFdvcmtJZCYmKGNsZWFyVGltZW91dCh0aGlzLmVmZmVjdFdvcmtJZCksdGhpcy5lZmZlY3RXb3JrSWQ9dm9pZCAwKSx0aGlzLmVmZmVjdFdvcmtJZD1zZXRUaW1lb3V0KCgpPT57dGhpcy5lZmZlY3RXb3JrSWQ9dm9pZCAwLHRoaXMuY29tcHV0Tm9kZU1hcCgpLHRoaXMucmVyUmVuZGVyU2VsZWN0b3IoKSxlJiZlKCl9LDUwKX1jb21wdXROb2RlTWFwKCl7dmFyIHQscjtjb25zdCBlPW5ldyBTZXQodGhpcy5jdXJOb2RlTWFwLmtleXMoKSk7aWYodGhpcy5mdWxsTGF5ZXIuY2hpbGRyZW4uZm9yRWFjaChzPT57aWYocy5uYW1lIT09dnQuc2VsZWN0b3JJZCl7Y29uc3QgZz1adChzLm5hbWUsdGhpcy5mdWxsTGF5ZXIpO2lmKGcpe2NvbnN0IHY9dGhpcy5jdXJOb2RlTWFwLmdldChzLm5hbWUpO3Y/KHYucmVjdD1nLGUuZGVsZXRlKHMubmFtZSkpOnRoaXMuY3VyTm9kZU1hcC5zZXQocy5uYW1lLHtuYW1lOnMubmFtZSxyZWN0Omd9KX19fSksKHI9KHQ9dGhpcy5kcmF3TGF5ZXIpPT1udWxsP3ZvaWQgMDp0LmNoaWxkcmVuKT09bnVsbHx8ci5mb3JFYWNoKHM9PntpZihzLm5hbWUhPT12dC5zZWxlY3RvcklkKXtjb25zdCBnPVp0KHMubmFtZSx0aGlzLmRyYXdMYXllcik7aWYoZyl7Y29uc3Qgdj10aGlzLmN1ck5vZGVNYXAuZ2V0KHMubmFtZSk7dj8odi5yZWN0PWcsZS5kZWxldGUocy5uYW1lKSk6dGhpcy5jdXJOb2RlTWFwLnNldChzLm5hbWUse25hbWU6cy5uYW1lLHJlY3Q6Z30pfX19KSxlLnNpemUpZm9yKGNvbnN0IHMgb2YgZS5rZXlzKCkpdGhpcy5jdXJOb2RlTWFwLmRlbGV0ZShzKX11cGRhdGFOb2RlTWFwKGUpe2NvbnN0e2tleTp0LG9wczpyLG9wdDpzLHRvb2xzVHlwZTpnfT1lO2xldCB2PVp0KHQsdGhpcy5mdWxsTGF5ZXIpO2NvbnN0IGg9dGhpcy5jdXJOb2RlTWFwLmdldCh0KXx8e25hbWU6dCxyZWN0OnZ9O3ImJihoLm9wcz1yKSxzJiYoaC5vcHQ9cyksdiYmKGgucmVjdD12KSxnJiYoaC50b29sc1R5cGU9ZyksdGhpcy5kcmF3TGF5ZXImJih2PVp0KHQsdGhpcy5kcmF3TGF5ZXIpLHYmJnRoaXMuZHJhd0xheWVyJiYoaC5yZWN0PXYpKSxoLnJlY3Q/dGhpcy5jdXJOb2RlTWFwLnNldCh0LGgpOnRoaXMuY3VyTm9kZU1hcC5kZWxldGUodCl9cmVyUmVuZGVyU2VsZWN0b3IoKXt2YXIgdDtjb25zdCBlPXRoaXMud29ya1NoYXBlcy5nZXQodnQuc2VsZWN0b3JJZCk7aWYoKHQ9ZT09bnVsbD92b2lkIDA6ZS5zZWxlY3RJZHMpIT1udWxsJiZ0Lmxlbmd0aCYmdGhpcy5kcmF3TGF5ZXIpe2NvbnN0IHI9ZS5nZXRTZWxlY3Rvcih0aGlzLmN1ck5vZGVNYXApO3ImJnRoaXMuX3Bvc3Qoe3JlbmRlcjpbe3JlY3Q6cixpc0NsZWFyOiEwLGlzRnVsbFdvcms6ITEsY2xlYXJDYW52YXM6WXQuU2VsZWN0b3IsZHJhd0NhbnZhczpZdC5TZWxlY3Rvcn1dLHNwOlt7dHlwZTpFdC5TZWxlY3Qsc2VsZWN0SWRzOmUuc2VsZWN0SWRzLHNlbGVjdFJlY3Q6cix3aWxsU3luY1NlcnZpY2U6ITF9XX0pfX19Y2xhc3MgWW4gZXh0ZW5kcyBWbntjb25zdHJ1Y3RvcihlLHQscil7c3VwZXIoZSx0KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiX3Bvc3QiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywid29ya1NoYXBlcyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOm5ldyBNYXB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiY29tYmluZURyYXdUaW1lciIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJkcmF3Q291bnQiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTowfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImFuaW1hdGlvbldvcmtSZWN0cyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOm5ldyBNYXB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiYW5pbWF0aW9uSWQiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiY2xvc2VBbmltYXRpb25UaW1lIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6MTEwMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJydW5MYXNlclBlblN0ZXAiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTowfSksdGhpcy5fcG9zdD1yfWJsdXJTZWxlY3Rvcigpe31ydW5MYXNlclBlbkFuaW1hdGlvbigpe3RoaXMuYW5pbWF0aW9uSWR8fCh0aGlzLmFuaW1hdGlvbklkPXJlcXVlc3RBbmltYXRpb25GcmFtZSgoKT0+e3ZhciByLHM7aWYodGhpcy5hbmltYXRpb25JZD12b2lkIDAsdGhpcy5ydW5MYXNlclBlblN0ZXArKyx0aGlzLnJ1bkxhc2VyUGVuU3RlcD4xKXt0aGlzLnJ1bkxhc2VyUGVuU3RlcD0wLHRoaXMucnVuTGFzZXJQZW5BbmltYXRpb24oKTtyZXR1cm59bGV0IGU7Y29uc3QgdD1bXTsocj10aGlzLmFuaW1hdGlvbldvcmtSZWN0cyk9PW51bGx8fHIuZm9yRWFjaCgoZyx2LGgpPT57Zy5pc1JlY3QmJihlPUN0KGUsZy5yZXMucmVjdCkpLGcucmVzLndvcmtJZCYmdC5wdXNoKGcucmVzKSx0aGlzLmZ1bGxMYXllci5nZXRFbGVtZW50c0J5TmFtZSh2LnRvU3RyaW5nKCkpLmxlbmd0aD9nLmlzUmVjdD0hMDpnLmlzUmVjdD0hMSxnLmNhbkRlbCYmaC5kZWxldGUodil9KSwocz10aGlzLmFuaW1hdGlvbldvcmtSZWN0cykhPW51bGwmJnMuc2l6ZSYmdGhpcy5ydW5MYXNlclBlbkFuaW1hdGlvbigpLGUmJnRoaXMuX3Bvc3Qoe3JlbmRlcjpbe3JlY3Q6ZSxkcmF3Q2FudmFzOll0LkZsb2F0LGlzQ2xlYXI6ITAsY2xlYXJDYW52YXM6WXQuRmxvYXQsaXNGdWxsV29yazohMX1dLHNwOnR9KX0pKX1kcmF3UGVuY2lsKGUpe3RoaXMuX3Bvc3Qoe2RyYXdDb3VudDp0aGlzLmRyYXdDb3VudCxyZW5kZXI6W3tyZWN0OmU9PW51bGw/dm9pZCAwOmUucmVjdCxkcmF3Q2FudmFzOll0LkZsb2F0LGlzQ2xlYXI6ITEsaXNGdWxsV29yazohMX1dLHNwOihlPT1udWxsP3ZvaWQgMDplLm9wKSYmW2VdfSl9Y29uc3VtZURyYXcoZSl7dmFyIHM7Y29uc3R7b3A6dCx3b3JrSWQ6cn09ZTtpZih0IT1udWxsJiZ0Lmxlbmd0aCYmcil7Y29uc3QgZz10aGlzLndvcmtTaGFwZXMuZ2V0KHIpO2lmKCFnKXJldHVybjtjb25zdCB2PWcudG9vbHNUeXBlLGg9Zy5jb25zdW1lKHtkYXRhOmUsaXNGdWxsV29yazohMSxpc0NsZWFyQWxsOiEwLGlzU3ViV29ya2VyOiEwfSk7aWYodj09PUR0Lkxhc2VyUGVuKXtoIT1udWxsJiZoLnJlY3QmJigocz10aGlzLmFuaW1hdGlvbldvcmtSZWN0cyk9PW51bGx8fHMuc2V0KHIse3JlczpoLGNhbkRlbDohMSxpc1JlY3Q6ITB9KSksdGhpcy5ydW5MYXNlclBlbkFuaW1hdGlvbigpO3JldHVybn1oJiYodGhpcy5kcmF3Q291bnQrKyx0aGlzLmRyYXdQZW5jaWwoaCkpfX1jb25zdW1lRHJhd0FsbChlKXt2YXIgcixzO2NvbnN0e3dvcmtJZDp0fT1lO2lmKHQpe2NvbnN0IGc9dGhpcy53b3JrU2hhcGVzLmdldCh0KTtpZighZylyZXR1cm47Y29uc3Qgdj1nLnRvb2xzVHlwZTtpZih2PT09RHQuTGFzZXJQZW4mJnRoaXMuYW5pbWF0aW9uSWQpe2NvbnN0IGg9Zy5jb25zdW1lQWxsKHtkYXRhOmV9KTtoIT1udWxsJiZoLm9wJiYoaCE9bnVsbCYmaC5yZWN0JiYoKHI9dGhpcy5hbmltYXRpb25Xb3JrUmVjdHMpPT1udWxsfHxyLnNldCh0LHtyZXM6aCxjYW5EZWw6ITEsaXNSZWN0OiEwfSksdGhpcy5ydW5MYXNlclBlbkFuaW1hdGlvbigpKSx0aGlzLl9wb3N0KHtzcDpbaF19KSk7Y29uc3QgbD0ocz1nLmdldFdvcmtPcHRpb25zKCkpPT1udWxsP3ZvaWQgMDpzLmR1cmF0aW9uO3RoaXMuY2xvc2VBbmltYXRpb25UaW1lPWw/bCoxZTMrMTAwOnRoaXMuY2xvc2VBbmltYXRpb25UaW1lLHNldFRpbWVvdXQoKCk9Pnt2YXIgTTt0aGlzLmZ1bGxMYXllci5nZXRFbGVtZW50c0J5TmFtZSh0LnRvU3RyaW5nKCkpLm1hcChmPT5mLnJlbW92ZSgpKSx0aGlzLmNsZWFyV29ya1NoYXBlTm9kZUNhY2hlKHQpO2NvbnN0IHU9KE09dGhpcy5hbmltYXRpb25Xb3JrUmVjdHMpPT1udWxsP3ZvaWQgMDpNLmdldCh0KTt1JiYodS5jYW5EZWw9ITApLHNldFRpbWVvdXQoKCk9Pnt0aGlzLl9wb3N0KHtzcDpbe3JlbW92ZUlkczpbdC50b1N0cmluZygpXSx0eXBlOkV0LlJlbW92ZU5vZGV9XX0pfSxnLmdldFdvcmtPcHRpb25zKCkuc3luY1VuaXRUaW1lfHx0aGlzLmNsb3NlQW5pbWF0aW9uVGltZSl9LHRoaXMuY2xvc2VBbmltYXRpb25UaW1lKTtyZXR1cm59dj09PUR0LlBlbmNpbCYmKHRoaXMuZHJhd0NvdW50PTAsdGhpcy5mdWxsTGF5ZXIucmVtb3ZlQWxsQ2hpbGRyZW4oKSx0aGlzLmNsZWFyV29ya1NoYXBlTm9kZUNhY2hlKHQpKX19c2V0RnVsbFdvcmsoZSl7Y29uc3R7d29ya0lkOnQsb3B0OnIsdG9vbHNUeXBlOnN9PWU7aWYodCYmciYmcyl7Y29uc3QgZz10JiZ0aGlzLndvcmtTaGFwZXMuZ2V0KHQpfHx0aGlzLmNyZWF0ZVdvcmtTaGFwZU5vZGUoe3Rvb2xzT3B0OnIsdG9vbHNUeXBlOnN9KTtyZXR1cm4gZz8oZy5zZXRXb3JrSWQodCksdGhpcy53b3JrU2hhcGVzLnNldCh0LGcpLGcpOnZvaWQgMH19cnVuRnVsbFdvcmsoZSl7dmFyIHM7Y29uc3QgdD10aGlzLnNldEZ1bGxXb3JrKGUpLHI9ZS5vcHMmJm9yKGUub3BzKTt0JiYodC5jb25zdW1lU2VydmljZSh7b3A6cixpc0Z1bGxXb3JrOiEwLHJlcGxhY2VJZDoocz10LmdldFdvcmtJZCgpKT09bnVsbD92b2lkIDA6cy50b1N0cmluZygpfSksZSE9bnVsbCYmZS51cGRhdGVOb2RlT3B0JiZ0LnVwZGF0YU9wdFNlcnZpY2UoZS51cGRhdGVOb2RlT3B0KSxlLndvcmtJZCYmdGhpcy53b3JrU2hhcGVzLmRlbGV0ZShlLndvcmtJZCkpfXJ1blNlbGVjdFdvcmsoZSl7dmFyIHI7Y29uc3QgdD10aGlzLnNldEZ1bGxXb3JrKGUpO3QmJigocj1lLnNlbGVjdElkcykhPW51bGwmJnIubGVuZ3RoKSYmZS53b3JrSWQmJnQuc2VsZWN0U2VydmljZU5vZGUoZS53b3JrSWQudG9TdHJpbmcoKSx7c2VsZWN0SWRzOmUuc2VsZWN0SWRzfSx0aGlzLmN1ck5vZGVNYXApfX1mdW5jdGlvbiBYbigpe3RoaXMuX19kYXRhX189W10sdGhpcy5zaXplPTB9dmFyIEpuPVhuO2Z1bmN0aW9uIFFuKGMsZSl7cmV0dXJuIGM9PT1lfHxjIT09YyYmZSE9PWV9dmFyIGRyPVFuLFpuPWRyO2Z1bmN0aW9uIHFuKGMsZSl7Zm9yKHZhciB0PWMubGVuZ3RoO3QtLTspaWYoWm4oY1t0XVswXSxlKSlyZXR1cm4gdDtyZXR1cm4tMX12YXIgeWU9cW4sa249eWUsX249QXJyYXkucHJvdG90eXBlLHRpPV9uLnNwbGljZTtmdW5jdGlvbiBlaShjKXt2YXIgZT10aGlzLl9fZGF0YV9fLHQ9a24oZSxjKTtpZih0PDApcmV0dXJuITE7dmFyIHI9ZS5sZW5ndGgtMTtyZXR1cm4gdD09cj9lLnBvcCgpOnRpLmNhbGwoZSx0LDEpLC0tdGhpcy5zaXplLCEwfXZhciByaT1laSxuaT15ZTtmdW5jdGlvbiBpaShjKXt2YXIgZT10aGlzLl9fZGF0YV9fLHQ9bmkoZSxjKTtyZXR1cm4gdDwwP3ZvaWQgMDplW3RdWzFdfXZhciBzaT1paSxhaT15ZTtmdW5jdGlvbiBvaShjKXtyZXR1cm4gYWkodGhpcy5fX2RhdGFfXyxjKT4tMX12YXIgbGk9b2ksZmk9eWU7ZnVuY3Rpb24gdWkoYyxlKXt2YXIgdD10aGlzLl9fZGF0YV9fLHI9ZmkodCxjKTtyZXR1cm4gcjwwPygrK3RoaXMuc2l6ZSx0LnB1c2goW2MsZV0pKTp0W3JdWzFdPWUsdGhpc312YXIgY2k9dWksaGk9Sm4sZGk9cmksZ2k9c2ksbWk9bGksdmk9Y2k7ZnVuY3Rpb24gZWUoYyl7dmFyIGU9LTEsdD1jPT1udWxsPzA6Yy5sZW5ndGg7Zm9yKHRoaXMuY2xlYXIoKTsrK2U8dDspe3ZhciByPWNbZV07dGhpcy5zZXQoclswXSxyWzFdKX19ZWUucHJvdG90eXBlLmNsZWFyPWhpLGVlLnByb3RvdHlwZS5kZWxldGU9ZGksZWUucHJvdG90eXBlLmdldD1naSxlZS5wcm90b3R5cGUuaGFzPW1pLGVlLnByb3RvdHlwZS5zZXQ9dmk7dmFyIHBlPWVlLHlpPXBlO2Z1bmN0aW9uIHBpKCl7dGhpcy5fX2RhdGFfXz1uZXcgeWksdGhpcy5zaXplPTB9dmFyIHhpPXBpO2Z1bmN0aW9uIE1pKGMpe3ZhciBlPXRoaXMuX19kYXRhX18sdD1lLmRlbGV0ZShjKTtyZXR1cm4gdGhpcy5zaXplPWUuc2l6ZSx0fXZhciBPaT1NaTtmdW5jdGlvbiBFaShjKXtyZXR1cm4gdGhpcy5fX2RhdGFfXy5nZXQoYyl9dmFyIFRpPUVpO2Z1bmN0aW9uIEFpKGMpe3JldHVybiB0aGlzLl9fZGF0YV9fLmhhcyhjKX12YXIgUGk9QWk7ZnVuY3Rpb24gU2koYyl7dmFyIGU9dHlwZW9mIGM7cmV0dXJuIGMhPW51bGwmJihlPT0ib2JqZWN0Inx8ZT09ImZ1bmN0aW9uIil9dmFyIGZlPVNpLGJpPWxlLFJpPWZlLENpPSJbb2JqZWN0IEFzeW5jRnVuY3Rpb25dIixMaT0iW29iamVjdCBGdW5jdGlvbl0iLERpPSJbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXSIsSWk9IltvYmplY3QgUHJveHldIjtmdW5jdGlvbiBOaShjKXtpZighUmkoYykpcmV0dXJuITE7dmFyIGU9YmkoYyk7cmV0dXJuIGU9PUxpfHxlPT1EaXx8ZT09Q2l8fGU9PUlpfXZhciBncj1OaSxqaT1LdCxCaT1qaVsiX19jb3JlLWpzX3NoYXJlZF9fIl0sVWk9QmksSWU9VWksbXI9ZnVuY3Rpb24oKXt2YXIgYz0vW14uXSskLy5leGVjKEllJiZJZS5rZXlzJiZJZS5rZXlzLklFX1BST1RPfHwiIik7cmV0dXJuIGM/IlN5bWJvbChzcmMpXzEuIitjOiIifSgpO2Z1bmN0aW9uIEZpKGMpe3JldHVybiEhbXImJm1yIGluIGN9dmFyIFdpPUZpLCRpPUZ1bmN0aW9uLnByb3RvdHlwZSx6aT0kaS50b1N0cmluZztmdW5jdGlvbiB3aShjKXtpZihjIT1udWxsKXt0cnl7cmV0dXJuIHppLmNhbGwoYyl9Y2F0Y2h7fXRyeXtyZXR1cm4gYysiIn1jYXRjaHt9fXJldHVybiIifXZhciB2cj13aSxHaT1ncixLaT1XaSxIaT1mZSxWaT12cixZaT0vW1xcXiQuKis/KClbXF17fXxdL2csWGk9L15cW29iamVjdCAuKz9Db25zdHJ1Y3RvclxdJC8sSmk9RnVuY3Rpb24ucHJvdG90eXBlLFFpPU9iamVjdC5wcm90b3R5cGUsWmk9SmkudG9TdHJpbmcscWk9UWkuaGFzT3duUHJvcGVydHksa2k9UmVnRXhwKCJeIitaaS5jYWxsKHFpKS5yZXBsYWNlKFlpLCJcXCQmIikucmVwbGFjZSgvaGFzT3duUHJvcGVydHl8KGZ1bmN0aW9uKS4qPyg/PVxcXCgpfCBmb3IgLis/KD89XFxcXSkvZywiJDEuKj8iKSsiJCIpO2Z1bmN0aW9uIF9pKGMpe2lmKCFIaShjKXx8S2koYykpcmV0dXJuITE7dmFyIGU9R2koYyk/a2k6WGk7cmV0dXJuIGUudGVzdChWaShjKSl9dmFyIHRzPV9pO2Z1bmN0aW9uIGVzKGMsZSl7cmV0dXJuIGM9PW51bGw/dm9pZCAwOmNbZV19dmFyIHJzPWVzLG5zPXRzLGlzPXJzO2Z1bmN0aW9uIHNzKGMsZSl7dmFyIHQ9aXMoYyxlKTtyZXR1cm4gbnModCk/dDp2b2lkIDB9dmFyIFh0PXNzLGFzPVh0LG9zPUt0LGxzPWFzKG9zLCJNYXAiKSxOZT1scyxmcz1YdCx1cz1mcyhPYmplY3QsImNyZWF0ZSIpLHhlPXVzLHlyPXhlO2Z1bmN0aW9uIGNzKCl7dGhpcy5fX2RhdGFfXz15cj95cihudWxsKTp7fSx0aGlzLnNpemU9MH12YXIgaHM9Y3M7ZnVuY3Rpb24gZHMoYyl7dmFyIGU9dGhpcy5oYXMoYykmJmRlbGV0ZSB0aGlzLl9fZGF0YV9fW2NdO3JldHVybiB0aGlzLnNpemUtPWU/MTowLGV9dmFyIGdzPWRzLG1zPXhlLHZzPSJfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fIix5cz1PYmplY3QucHJvdG90eXBlLHBzPXlzLmhhc093blByb3BlcnR5O2Z1bmN0aW9uIHhzKGMpe3ZhciBlPXRoaXMuX19kYXRhX187aWYobXMpe3ZhciB0PWVbY107cmV0dXJuIHQ9PT12cz92b2lkIDA6dH1yZXR1cm4gcHMuY2FsbChlLGMpP2VbY106dm9pZCAwfXZhciBNcz14cyxPcz14ZSxFcz1PYmplY3QucHJvdG90eXBlLFRzPUVzLmhhc093blByb3BlcnR5O2Z1bmN0aW9uIEFzKGMpe3ZhciBlPXRoaXMuX19kYXRhX187cmV0dXJuIE9zP2VbY10hPT12b2lkIDA6VHMuY2FsbChlLGMpfXZhciBQcz1BcyxTcz14ZSxicz0iX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyI7ZnVuY3Rpb24gUnMoYyxlKXt2YXIgdD10aGlzLl9fZGF0YV9fO3JldHVybiB0aGlzLnNpemUrPXRoaXMuaGFzKGMpPzA6MSx0W2NdPVNzJiZlPT09dm9pZCAwP2JzOmUsdGhpc312YXIgQ3M9UnMsTHM9aHMsRHM9Z3MsSXM9TXMsTnM9UHMsanM9Q3M7ZnVuY3Rpb24gcmUoYyl7dmFyIGU9LTEsdD1jPT1udWxsPzA6Yy5sZW5ndGg7Zm9yKHRoaXMuY2xlYXIoKTsrK2U8dDspe3ZhciByPWNbZV07dGhpcy5zZXQoclswXSxyWzFdKX19cmUucHJvdG90eXBlLmNsZWFyPUxzLHJlLnByb3RvdHlwZS5kZWxldGU9RHMscmUucHJvdG90eXBlLmdldD1JcyxyZS5wcm90b3R5cGUuaGFzPU5zLHJlLnByb3RvdHlwZS5zZXQ9anM7dmFyIEJzPXJlLHByPUJzLFVzPXBlLEZzPU5lO2Z1bmN0aW9uIFdzKCl7dGhpcy5zaXplPTAsdGhpcy5fX2RhdGFfXz17aGFzaDpuZXcgcHIsbWFwOm5ldyhGc3x8VXMpLHN0cmluZzpuZXcgcHJ9fXZhciAkcz1XcztmdW5jdGlvbiB6cyhjKXt2YXIgZT10eXBlb2YgYztyZXR1cm4gZT09InN0cmluZyJ8fGU9PSJudW1iZXIifHxlPT0ic3ltYm9sInx8ZT09ImJvb2xlYW4iP2MhPT0iX19wcm90b19fIjpjPT09bnVsbH12YXIgd3M9enMsR3M9d3M7ZnVuY3Rpb24gS3MoYyxlKXt2YXIgdD1jLl9fZGF0YV9fO3JldHVybiBHcyhlKT90W3R5cGVvZiBlPT0ic3RyaW5nIj8ic3RyaW5nIjoiaGFzaCJdOnQubWFwfXZhciBNZT1LcyxIcz1NZTtmdW5jdGlvbiBWcyhjKXt2YXIgZT1Icyh0aGlzLGMpLmRlbGV0ZShjKTtyZXR1cm4gdGhpcy5zaXplLT1lPzE6MCxlfXZhciBZcz1WcyxYcz1NZTtmdW5jdGlvbiBKcyhjKXtyZXR1cm4gWHModGhpcyxjKS5nZXQoYyl9dmFyIFFzPUpzLFpzPU1lO2Z1bmN0aW9uIHFzKGMpe3JldHVybiBacyh0aGlzLGMpLmhhcyhjKX12YXIga3M9cXMsX3M9TWU7ZnVuY3Rpb24gdGEoYyxlKXt2YXIgdD1fcyh0aGlzLGMpLHI9dC5zaXplO3JldHVybiB0LnNldChjLGUpLHRoaXMuc2l6ZSs9dC5zaXplPT1yPzA6MSx0aGlzfXZhciBlYT10YSxyYT0kcyxuYT1ZcyxpYT1RcyxzYT1rcyxhYT1lYTtmdW5jdGlvbiBuZShjKXt2YXIgZT0tMSx0PWM9PW51bGw/MDpjLmxlbmd0aDtmb3IodGhpcy5jbGVhcigpOysrZTx0Oyl7dmFyIHI9Y1tlXTt0aGlzLnNldChyWzBdLHJbMV0pfX1uZS5wcm90b3R5cGUuY2xlYXI9cmEsbmUucHJvdG90eXBlLmRlbGV0ZT1uYSxuZS5wcm90b3R5cGUuZ2V0PWlhLG5lLnByb3RvdHlwZS5oYXM9c2EsbmUucHJvdG90eXBlLnNldD1hYTt2YXIgb2E9bmUsbGE9cGUsZmE9TmUsdWE9b2EsY2E9MjAwO2Z1bmN0aW9uIGhhKGMsZSl7dmFyIHQ9dGhpcy5fX2RhdGFfXztpZih0IGluc3RhbmNlb2YgbGEpe3ZhciByPXQuX19kYXRhX187aWYoIWZhfHxyLmxlbmd0aDxjYS0xKXJldHVybiByLnB1c2goW2MsZV0pLHRoaXMuc2l6ZT0rK3Quc2l6ZSx0aGlzO3Q9dGhpcy5fX2RhdGFfXz1uZXcgdWEocil9cmV0dXJuIHQuc2V0KGMsZSksdGhpcy5zaXplPXQuc2l6ZSx0aGlzfXZhciBkYT1oYSxnYT1wZSxtYT14aSx2YT1PaSx5YT1UaSxwYT1QaSx4YT1kYTtmdW5jdGlvbiBpZShjKXt2YXIgZT10aGlzLl9fZGF0YV9fPW5ldyBnYShjKTt0aGlzLnNpemU9ZS5zaXplfWllLnByb3RvdHlwZS5jbGVhcj1tYSxpZS5wcm90b3R5cGUuZGVsZXRlPXZhLGllLnByb3RvdHlwZS5nZXQ9eWEsaWUucHJvdG90eXBlLmhhcz1wYSxpZS5wcm90b3R5cGUuc2V0PXhhO3ZhciBNYT1pZTtmdW5jdGlvbiBPYShjLGUpe2Zvcih2YXIgdD0tMSxyPWM9PW51bGw/MDpjLmxlbmd0aDsrK3Q8ciYmZShjW3RdLHQsYykhPT0hMTspO3JldHVybiBjfXZhciBFYT1PYSxUYT1YdCxBYT1mdW5jdGlvbigpe3RyeXt2YXIgYz1UYShPYmplY3QsImRlZmluZVByb3BlcnR5Iik7cmV0dXJuIGMoe30sIiIse30pLGN9Y2F0Y2h7fX0oKSxQYT1BYSx4cj1QYTtmdW5jdGlvbiBTYShjLGUsdCl7ZT09Il9fcHJvdG9fXyImJnhyP3hyKGMsZSx7Y29uZmlndXJhYmxlOiEwLGVudW1lcmFibGU6ITAsdmFsdWU6dCx3cml0YWJsZTohMH0pOmNbZV09dH12YXIgTXI9U2EsYmE9TXIsUmE9ZHIsQ2E9T2JqZWN0LnByb3RvdHlwZSxMYT1DYS5oYXNPd25Qcm9wZXJ0eTtmdW5jdGlvbiBEYShjLGUsdCl7dmFyIHI9Y1tlXTsoIShMYS5jYWxsKGMsZSkmJlJhKHIsdCkpfHx0PT09dm9pZCAwJiYhKGUgaW4gYykpJiZiYShjLGUsdCl9dmFyIE9yPURhLElhPU9yLE5hPU1yO2Z1bmN0aW9uIGphKGMsZSx0LHIpe3ZhciBzPSF0O3R8fCh0PXt9KTtmb3IodmFyIGc9LTEsdj1lLmxlbmd0aDsrK2c8djspe3ZhciBoPWVbZ10sbD1yP3IodFtoXSxjW2hdLGgsdCxjKTp2b2lkIDA7bD09PXZvaWQgMCYmKGw9Y1toXSkscz9OYSh0LGgsbCk6SWEodCxoLGwpfXJldHVybiB0fXZhciBPZT1qYTtmdW5jdGlvbiBCYShjLGUpe2Zvcih2YXIgdD0tMSxyPUFycmF5KGMpOysrdDxjOylyW3RdPWUodCk7cmV0dXJuIHJ9dmFyIFVhPUJhLEZhPWxlLFdhPXRlLCRhPSJbb2JqZWN0IEFyZ3VtZW50c10iO2Z1bmN0aW9uIHphKGMpe3JldHVybiBXYShjKSYmRmEoYyk9PSRhfXZhciB3YT16YSxFcj13YSxHYT10ZSxUcj1PYmplY3QucHJvdG90eXBlLEthPVRyLmhhc093blByb3BlcnR5LEhhPVRyLnByb3BlcnR5SXNFbnVtZXJhYmxlLFZhPUVyKGZ1bmN0aW9uKCl7cmV0dXJuIGFyZ3VtZW50c30oKSk/RXI6ZnVuY3Rpb24oYyl7cmV0dXJuIEdhKGMpJiZLYS5jYWxsKGMsImNhbGxlZSIpJiYhSGEuY2FsbChjLCJjYWxsZWUiKX0sWWE9VmEsWGE9QXJyYXkuaXNBcnJheSxqZT1YYSxFZT17ZXhwb3J0czp7fX07ZnVuY3Rpb24gSmEoKXtyZXR1cm4hMX12YXIgUWE9SmE7RWUuZXhwb3J0cyxmdW5jdGlvbihjLGUpe3ZhciB0PUt0LHI9UWEscz1lJiYhZS5ub2RlVHlwZSYmZSxnPXMmJiEwJiZjJiYhYy5ub2RlVHlwZSYmYyx2PWcmJmcuZXhwb3J0cz09PXMsaD12P3QuQnVmZmVyOnZvaWQgMCxsPWg/aC5pc0J1ZmZlcjp2b2lkIDAsdT1sfHxyO2MuZXhwb3J0cz11fShFZSxFZS5leHBvcnRzKTt2YXIgQXI9RWUuZXhwb3J0cyxaYT05MDA3MTk5MjU0NzQwOTkxLHFhPS9eKD86MHxbMS05XVxkKikkLztmdW5jdGlvbiBrYShjLGUpe3ZhciB0PXR5cGVvZiBjO3JldHVybiBlPWU/P1phLCEhZSYmKHQ9PSJudW1iZXIifHx0IT0ic3ltYm9sIiYmcWEudGVzdChjKSkmJmM+LTEmJmMlMT09MCYmYzxlfXZhciBfYT1rYSx0bz05MDA3MTk5MjU0NzQwOTkxO2Z1bmN0aW9uIGVvKGMpe3JldHVybiB0eXBlb2YgYz09Im51bWJlciImJmM+LTEmJmMlMT09MCYmYzw9dG99dmFyIFByPWVvLHJvPWxlLG5vPVByLGlvPXRlLHNvPSJbb2JqZWN0IEFyZ3VtZW50c10iLGFvPSJbb2JqZWN0IEFycmF5XSIsb289IltvYmplY3QgQm9vbGVhbl0iLGxvPSJbb2JqZWN0IERhdGVdIixmbz0iW29iamVjdCBFcnJvcl0iLHVvPSJbb2JqZWN0IEZ1bmN0aW9uXSIsY289IltvYmplY3QgTWFwXSIsaG89IltvYmplY3QgTnVtYmVyXSIsZ289IltvYmplY3QgT2JqZWN0XSIsbW89IltvYmplY3QgUmVnRXhwXSIsdm89IltvYmplY3QgU2V0XSIseW89IltvYmplY3QgU3RyaW5nXSIscG89IltvYmplY3QgV2Vha01hcF0iLHhvPSJbb2JqZWN0IEFycmF5QnVmZmVyXSIsTW89IltvYmplY3QgRGF0YVZpZXddIixPbz0iW29iamVjdCBGbG9hdDMyQXJyYXldIixFbz0iW29iamVjdCBGbG9hdDY0QXJyYXldIixUbz0iW29iamVjdCBJbnQ4QXJyYXldIixBbz0iW29iamVjdCBJbnQxNkFycmF5XSIsUG89IltvYmplY3QgSW50MzJBcnJheV0iLFNvPSJbb2JqZWN0IFVpbnQ4QXJyYXldIixibz0iW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0iLFJvPSJbb2JqZWN0IFVpbnQxNkFycmF5XSIsQ289IltvYmplY3QgVWludDMyQXJyYXldIixSdD17fTtSdFtPb109UnRbRW9dPVJ0W1RvXT1SdFtBb109UnRbUG9dPVJ0W1NvXT1SdFtib109UnRbUm9dPVJ0W0NvXT0hMCxSdFtzb109UnRbYW9dPVJ0W3hvXT1SdFtvb109UnRbTW9dPVJ0W2xvXT1SdFtmb109UnRbdW9dPVJ0W2NvXT1SdFtob109UnRbZ29dPVJ0W21vXT1SdFt2b109UnRbeW9dPVJ0W3BvXT0hMTtmdW5jdGlvbiBMbyhjKXtyZXR1cm4gaW8oYykmJm5vKGMubGVuZ3RoKSYmISFSdFtybyhjKV19dmFyIERvPUxvO2Z1bmN0aW9uIElvKGMpe3JldHVybiBmdW5jdGlvbihlKXtyZXR1cm4gYyhlKX19dmFyIEJlPUlvLFRlPXtleHBvcnRzOnt9fTtUZS5leHBvcnRzLGZ1bmN0aW9uKGMsZSl7dmFyIHQ9bHIscj1lJiYhZS5ub2RlVHlwZSYmZSxzPXImJiEwJiZjJiYhYy5ub2RlVHlwZSYmYyxnPXMmJnMuZXhwb3J0cz09PXIsdj1nJiZ0LnByb2Nlc3MsaD1mdW5jdGlvbigpe3RyeXt2YXIgbD1zJiZzLnJlcXVpcmUmJnMucmVxdWlyZSgidXRpbCIpLnR5cGVzO3JldHVybiBsfHx2JiZ2LmJpbmRpbmcmJnYuYmluZGluZygidXRpbCIpfWNhdGNoe319KCk7Yy5leHBvcnRzPWh9KFRlLFRlLmV4cG9ydHMpO3ZhciBVZT1UZS5leHBvcnRzLE5vPURvLGpvPUJlLFNyPVVlLGJyPVNyJiZTci5pc1R5cGVkQXJyYXksQm89YnI/am8oYnIpOk5vLFVvPUJvLEZvPVVhLFdvPVlhLCRvPWplLHpvPUFyLHdvPV9hLEdvPVVvLEtvPU9iamVjdC5wcm90b3R5cGUsSG89S28uaGFzT3duUHJvcGVydHk7ZnVuY3Rpb24gVm8oYyxlKXt2YXIgdD0kbyhjKSxyPSF0JiZXbyhjKSxzPSF0JiYhciYmem8oYyksZz0hdCYmIXImJiFzJiZHbyhjKSx2PXR8fHJ8fHN8fGcsaD12P0ZvKGMubGVuZ3RoLFN0cmluZyk6W10sbD1oLmxlbmd0aDtmb3IodmFyIHUgaW4gYykoZXx8SG8uY2FsbChjLHUpKSYmISh2JiYodT09Imxlbmd0aCJ8fHMmJih1PT0ib2Zmc2V0Inx8dT09InBhcmVudCIpfHxnJiYodT09ImJ1ZmZlciJ8fHU9PSJieXRlTGVuZ3RoInx8dT09ImJ5dGVPZmZzZXQiKXx8d28odSxsKSkpJiZoLnB1c2godSk7cmV0dXJuIGh9dmFyIFJyPVZvLFlvPU9iamVjdC5wcm90b3R5cGU7ZnVuY3Rpb24gWG8oYyl7dmFyIGU9YyYmYy5jb25zdHJ1Y3Rvcix0PXR5cGVvZiBlPT0iZnVuY3Rpb24iJiZlLnByb3RvdHlwZXx8WW87cmV0dXJuIGM9PT10fXZhciBGZT1YbztmdW5jdGlvbiBKbyhjLGUpe3JldHVybiBmdW5jdGlvbih0KXtyZXR1cm4gYyhlKHQpKX19dmFyIENyPUpvLFFvPUNyLFpvPVFvKE9iamVjdC5rZXlzLE9iamVjdCkscW89Wm8sa289RmUsX289cW8sdGw9T2JqZWN0LnByb3RvdHlwZSxlbD10bC5oYXNPd25Qcm9wZXJ0eTtmdW5jdGlvbiBybChjKXtpZigha28oYykpcmV0dXJuIF9vKGMpO3ZhciBlPVtdO2Zvcih2YXIgdCBpbiBPYmplY3QoYykpZWwuY2FsbChjLHQpJiZ0IT0iY29uc3RydWN0b3IiJiZlLnB1c2godCk7cmV0dXJuIGV9dmFyIG5sPXJsLGlsPWdyLHNsPVByO2Z1bmN0aW9uIGFsKGMpe3JldHVybiBjIT1udWxsJiZzbChjLmxlbmd0aCkmJiFpbChjKX12YXIgTHI9YWwsb2w9UnIsbGw9bmwsZmw9THI7ZnVuY3Rpb24gdWwoYyl7cmV0dXJuIGZsKGMpP29sKGMpOmxsKGMpfXZhciBXZT11bCxjbD1PZSxobD1XZTtmdW5jdGlvbiBkbChjLGUpe3JldHVybiBjJiZjbChlLGhsKGUpLGMpfXZhciBnbD1kbDtmdW5jdGlvbiBtbChjKXt2YXIgZT1bXTtpZihjIT1udWxsKWZvcih2YXIgdCBpbiBPYmplY3QoYykpZS5wdXNoKHQpO3JldHVybiBlfXZhciB2bD1tbCx5bD1mZSxwbD1GZSx4bD12bCxNbD1PYmplY3QucHJvdG90eXBlLE9sPU1sLmhhc093blByb3BlcnR5O2Z1bmN0aW9uIEVsKGMpe2lmKCF5bChjKSlyZXR1cm4geGwoYyk7dmFyIGU9cGwoYyksdD1bXTtmb3IodmFyIHIgaW4gYylyPT0iY29uc3RydWN0b3IiJiYoZXx8IU9sLmNhbGwoYyxyKSl8fHQucHVzaChyKTtyZXR1cm4gdH12YXIgVGw9RWwsQWw9UnIsUGw9VGwsU2w9THI7ZnVuY3Rpb24gYmwoYyl7cmV0dXJuIFNsKGMpP0FsKGMsITApOlBsKGMpfXZhciAkZT1ibCxSbD1PZSxDbD0kZTtmdW5jdGlvbiBMbChjLGUpe3JldHVybiBjJiZSbChlLENsKGUpLGMpfXZhciBEbD1MbCxBZT17ZXhwb3J0czp7fX07QWUuZXhwb3J0cyxmdW5jdGlvbihjLGUpe3ZhciB0PUt0LHI9ZSYmIWUubm9kZVR5cGUmJmUscz1yJiYhMCYmYyYmIWMubm9kZVR5cGUmJmMsZz1zJiZzLmV4cG9ydHM9PT1yLHY9Zz90LkJ1ZmZlcjp2b2lkIDAsaD12P3YuYWxsb2NVbnNhZmU6dm9pZCAwO2Z1bmN0aW9uIGwodSxNKXtpZihNKXJldHVybiB1LnNsaWNlKCk7dmFyIGY9dS5sZW5ndGgseT1oP2goZik6bmV3IHUuY29uc3RydWN0b3IoZik7cmV0dXJuIHUuY29weSh5KSx5fWMuZXhwb3J0cz1sfShBZSxBZS5leHBvcnRzKTt2YXIgSWw9QWUuZXhwb3J0cztmdW5jdGlvbiBObChjLGUpe3ZhciB0PS0xLHI9Yy5sZW5ndGg7Zm9yKGV8fChlPUFycmF5KHIpKTsrK3Q8cjspZVt0XT1jW3RdO3JldHVybiBlfXZhciBqbD1ObDtmdW5jdGlvbiBCbChjLGUpe2Zvcih2YXIgdD0tMSxyPWM9PW51bGw/MDpjLmxlbmd0aCxzPTAsZz1bXTsrK3Q8cjspe3ZhciB2PWNbdF07ZSh2LHQsYykmJihnW3MrK109dil9cmV0dXJuIGd9dmFyIFVsPUJsO2Z1bmN0aW9uIEZsKCl7cmV0dXJuW119dmFyIERyPUZsLFdsPVVsLCRsPURyLHpsPU9iamVjdC5wcm90b3R5cGUsd2w9emwucHJvcGVydHlJc0VudW1lcmFibGUsSXI9T2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyxHbD1Jcj9mdW5jdGlvbihjKXtyZXR1cm4gYz09bnVsbD9bXTooYz1PYmplY3QoYyksV2woSXIoYyksZnVuY3Rpb24oZSl7cmV0dXJuIHdsLmNhbGwoYyxlKX0pKX06JGwsemU9R2wsS2w9T2UsSGw9emU7ZnVuY3Rpb24gVmwoYyxlKXtyZXR1cm4gS2woYyxIbChjKSxlKX12YXIgWWw9Vmw7ZnVuY3Rpb24gWGwoYyxlKXtmb3IodmFyIHQ9LTEscj1lLmxlbmd0aCxzPWMubGVuZ3RoOysrdDxyOyljW3MrdF09ZVt0XTtyZXR1cm4gY312YXIgTnI9WGwsSmw9Q3IsUWw9SmwoT2JqZWN0LmdldFByb3RvdHlwZU9mLE9iamVjdCksanI9UWwsWmw9TnIscWw9anIsa2w9emUsX2w9RHIsdGY9T2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyxlZj10Zj9mdW5jdGlvbihjKXtmb3IodmFyIGU9W107YzspWmwoZSxrbChjKSksYz1xbChjKTtyZXR1cm4gZX06X2wsQnI9ZWYscmY9T2UsbmY9QnI7ZnVuY3Rpb24gc2YoYyxlKXtyZXR1cm4gcmYoYyxuZihjKSxlKX12YXIgYWY9c2Ysb2Y9TnIsbGY9amU7ZnVuY3Rpb24gZmYoYyxlLHQpe3ZhciByPWUoYyk7cmV0dXJuIGxmKGMpP3I6b2Yocix0KGMpKX12YXIgVXI9ZmYsdWY9VXIsY2Y9emUsaGY9V2U7ZnVuY3Rpb24gZGYoYyl7cmV0dXJuIHVmKGMsaGYsY2YpfXZhciBnZj1kZixtZj1Vcix2Zj1Ccix5Zj0kZTtmdW5jdGlvbiBwZihjKXtyZXR1cm4gbWYoYyx5Zix2Zil9dmFyIHhmPXBmLE1mPVh0LE9mPUt0LEVmPU1mKE9mLCJEYXRhVmlldyIpLFRmPUVmLEFmPVh0LFBmPUt0LFNmPUFmKFBmLCJQcm9taXNlIiksYmY9U2YsUmY9WHQsQ2Y9S3QsTGY9UmYoQ2YsIlNldCIpLERmPUxmLElmPVh0LE5mPUt0LGpmPUlmKE5mLCJXZWFrTWFwIiksQmY9amYsd2U9VGYsR2U9TmUsS2U9YmYsSGU9RGYsVmU9QmYsRnI9bGUsc2U9dnIsV3I9IltvYmplY3QgTWFwXSIsVWY9IltvYmplY3QgT2JqZWN0XSIsJHI9IltvYmplY3QgUHJvbWlzZV0iLHpyPSJbb2JqZWN0IFNldF0iLHdyPSJbb2JqZWN0IFdlYWtNYXBdIixHcj0iW29iamVjdCBEYXRhVmlld10iLEZmPXNlKHdlKSxXZj1zZShHZSksJGY9c2UoS2UpLHpmPXNlKEhlKSx3Zj1zZShWZSksSnQ9RnI7KHdlJiZKdChuZXcgd2UobmV3IEFycmF5QnVmZmVyKDEpKSkhPUdyfHxHZSYmSnQobmV3IEdlKSE9V3J8fEtlJiZKdChLZS5yZXNvbHZlKCkpIT0kcnx8SGUmJkp0KG5ldyBIZSkhPXpyfHxWZSYmSnQobmV3IFZlKSE9d3IpJiYoSnQ9ZnVuY3Rpb24oYyl7dmFyIGU9RnIoYyksdD1lPT1VZj9jLmNvbnN0cnVjdG9yOnZvaWQgMCxyPXQ/c2UodCk6IiI7aWYocilzd2l0Y2gocil7Y2FzZSBGZjpyZXR1cm4gR3I7Y2FzZSBXZjpyZXR1cm4gV3I7Y2FzZSAkZjpyZXR1cm4gJHI7Y2FzZSB6ZjpyZXR1cm4genI7Y2FzZSB3ZjpyZXR1cm4gd3J9cmV0dXJuIGV9KTt2YXIgWWU9SnQsR2Y9T2JqZWN0LnByb3RvdHlwZSxLZj1HZi5oYXNPd25Qcm9wZXJ0eTtmdW5jdGlvbiBIZihjKXt2YXIgZT1jLmxlbmd0aCx0PW5ldyBjLmNvbnN0cnVjdG9yKGUpO3JldHVybiBlJiZ0eXBlb2YgY1swXT09InN0cmluZyImJktmLmNhbGwoYywiaW5kZXgiKSYmKHQuaW5kZXg9Yy5pbmRleCx0LmlucHV0PWMuaW5wdXQpLHR9dmFyIFZmPUhmLFlmPUt0LFhmPVlmLlVpbnQ4QXJyYXksSmY9WGYsS3I9SmY7ZnVuY3Rpb24gUWYoYyl7dmFyIGU9bmV3IGMuY29uc3RydWN0b3IoYy5ieXRlTGVuZ3RoKTtyZXR1cm4gbmV3IEtyKGUpLnNldChuZXcgS3IoYykpLGV9dmFyIFhlPVFmLFpmPVhlO2Z1bmN0aW9uIHFmKGMsZSl7dmFyIHQ9ZT9aZihjLmJ1ZmZlcik6Yy5idWZmZXI7cmV0dXJuIG5ldyBjLmNvbnN0cnVjdG9yKHQsYy5ieXRlT2Zmc2V0LGMuYnl0ZUxlbmd0aCl9dmFyIGtmPXFmLF9mPS9cdyokLztmdW5jdGlvbiB0dShjKXt2YXIgZT1uZXcgYy5jb25zdHJ1Y3RvcihjLnNvdXJjZSxfZi5leGVjKGMpKTtyZXR1cm4gZS5sYXN0SW5kZXg9Yy5sYXN0SW5kZXgsZX12YXIgZXU9dHUsSHI9RGUsVnI9SHI/SHIucHJvdG90eXBlOnZvaWQgMCxZcj1Wcj9Wci52YWx1ZU9mOnZvaWQgMDtmdW5jdGlvbiBydShjKXtyZXR1cm4gWXI/T2JqZWN0KFlyLmNhbGwoYykpOnt9fXZhciBudT1ydSxpdT1YZTtmdW5jdGlvbiBzdShjLGUpe3ZhciB0PWU/aXUoYy5idWZmZXIpOmMuYnVmZmVyO3JldHVybiBuZXcgYy5jb25zdHJ1Y3Rvcih0LGMuYnl0ZU9mZnNldCxjLmxlbmd0aCl9dmFyIGF1PXN1LG91PVhlLGx1PWtmLGZ1PWV1LHV1PW51LGN1PWF1LGh1PSJbb2JqZWN0IEJvb2xlYW5dIixkdT0iW29iamVjdCBEYXRlXSIsZ3U9IltvYmplY3QgTWFwXSIsbXU9IltvYmplY3QgTnVtYmVyXSIsdnU9IltvYmplY3QgUmVnRXhwXSIseXU9IltvYmplY3QgU2V0XSIscHU9IltvYmplY3QgU3RyaW5nXSIseHU9IltvYmplY3QgU3ltYm9sXSIsTXU9IltvYmplY3QgQXJyYXlCdWZmZXJdIixPdT0iW29iamVjdCBEYXRhVmlld10iLEV1PSJbb2JqZWN0IEZsb2F0MzJBcnJheV0iLFR1PSJbb2JqZWN0IEZsb2F0NjRBcnJheV0iLEF1PSJbb2JqZWN0IEludDhBcnJheV0iLFB1PSJbb2JqZWN0IEludDE2QXJyYXldIixTdT0iW29iamVjdCBJbnQzMkFycmF5XSIsYnU9IltvYmplY3QgVWludDhBcnJheV0iLFJ1PSJbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XSIsQ3U9IltvYmplY3QgVWludDE2QXJyYXldIixMdT0iW29iamVjdCBVaW50MzJBcnJheV0iO2Z1bmN0aW9uIER1KGMsZSx0KXt2YXIgcj1jLmNvbnN0cnVjdG9yO3N3aXRjaChlKXtjYXNlIE11OnJldHVybiBvdShjKTtjYXNlIGh1OmNhc2UgZHU6cmV0dXJuIG5ldyByKCtjKTtjYXNlIE91OnJldHVybiBsdShjLHQpO2Nhc2UgRXU6Y2FzZSBUdTpjYXNlIEF1OmNhc2UgUHU6Y2FzZSBTdTpjYXNlIGJ1OmNhc2UgUnU6Y2FzZSBDdTpjYXNlIEx1OnJldHVybiBjdShjLHQpO2Nhc2UgZ3U6cmV0dXJuIG5ldyByO2Nhc2UgbXU6Y2FzZSBwdTpyZXR1cm4gbmV3IHIoYyk7Y2FzZSB2dTpyZXR1cm4gZnUoYyk7Y2FzZSB5dTpyZXR1cm4gbmV3IHI7Y2FzZSB4dTpyZXR1cm4gdXUoYyl9fXZhciBJdT1EdSxOdT1mZSxYcj1PYmplY3QuY3JlYXRlLGp1PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gYygpe31yZXR1cm4gZnVuY3Rpb24oZSl7aWYoIU51KGUpKXJldHVybnt9O2lmKFhyKXJldHVybiBYcihlKTtjLnByb3RvdHlwZT1lO3ZhciB0PW5ldyBjO3JldHVybiBjLnByb3RvdHlwZT12b2lkIDAsdH19KCksQnU9anUsVXU9QnUsRnU9anIsV3U9RmU7ZnVuY3Rpb24gJHUoYyl7cmV0dXJuIHR5cGVvZiBjLmNvbnN0cnVjdG9yPT0iZnVuY3Rpb24iJiYhV3UoYyk/VXUoRnUoYykpOnt9fXZhciB6dT0kdSx3dT1ZZSxHdT10ZSxLdT0iW29iamVjdCBNYXBdIjtmdW5jdGlvbiBIdShjKXtyZXR1cm4gR3UoYykmJnd1KGMpPT1LdX12YXIgVnU9SHUsWXU9VnUsWHU9QmUsSnI9VWUsUXI9SnImJkpyLmlzTWFwLEp1PVFyP1h1KFFyKTpZdSxRdT1KdSxadT1ZZSxxdT10ZSxrdT0iW29iamVjdCBTZXRdIjtmdW5jdGlvbiBfdShjKXtyZXR1cm4gcXUoYykmJlp1KGMpPT1rdX12YXIgdGM9X3UsZWM9dGMscmM9QmUsWnI9VWUscXI9WnImJlpyLmlzU2V0LG5jPXFyP3JjKHFyKTplYyxpYz1uYyxzYz1NYSxhYz1FYSxvYz1PcixsYz1nbCxmYz1EbCx1Yz1JbCxjYz1qbCxoYz1ZbCxkYz1hZixnYz1nZixtYz14Zix2Yz1ZZSx5Yz1WZixwYz1JdSx4Yz16dSxNYz1qZSxPYz1BcixFYz1RdSxUYz1mZSxBYz1pYyxQYz1XZSxTYz0kZSxiYz0xLFJjPTIsQ2M9NCxrcj0iW29iamVjdCBBcmd1bWVudHNdIixMYz0iW29iamVjdCBBcnJheV0iLERjPSJbb2JqZWN0IEJvb2xlYW5dIixJYz0iW29iamVjdCBEYXRlXSIsTmM9IltvYmplY3QgRXJyb3JdIixfcj0iW29iamVjdCBGdW5jdGlvbl0iLGpjPSJbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXSIsQmM9IltvYmplY3QgTWFwXSIsVWM9IltvYmplY3QgTnVtYmVyXSIsdG49IltvYmplY3QgT2JqZWN0XSIsRmM9IltvYmplY3QgUmVnRXhwXSIsV2M9IltvYmplY3QgU2V0XSIsJGM9IltvYmplY3QgU3RyaW5nXSIsemM9IltvYmplY3QgU3ltYm9sXSIsd2M9IltvYmplY3QgV2Vha01hcF0iLEdjPSJbb2JqZWN0IEFycmF5QnVmZmVyXSIsS2M9IltvYmplY3QgRGF0YVZpZXddIixIYz0iW29iamVjdCBGbG9hdDMyQXJyYXldIixWYz0iW29iamVjdCBGbG9hdDY0QXJyYXldIixZYz0iW29iamVjdCBJbnQ4QXJyYXldIixYYz0iW29iamVjdCBJbnQxNkFycmF5XSIsSmM9IltvYmplY3QgSW50MzJBcnJheV0iLFFjPSJbb2JqZWN0IFVpbnQ4QXJyYXldIixaYz0iW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0iLHFjPSJbb2JqZWN0IFVpbnQxNkFycmF5XSIsa2M9IltvYmplY3QgVWludDMyQXJyYXldIixTdD17fTtTdFtrcl09U3RbTGNdPVN0W0djXT1TdFtLY109U3RbRGNdPVN0W0ljXT1TdFtIY109U3RbVmNdPVN0W1ljXT1TdFtYY109U3RbSmNdPVN0W0JjXT1TdFtVY109U3RbdG5dPVN0W0ZjXT1TdFtXY109U3RbJGNdPVN0W3pjXT1TdFtRY109U3RbWmNdPVN0W3FjXT1TdFtrY109ITAsU3RbTmNdPVN0W19yXT1TdFt3Y109ITE7ZnVuY3Rpb24gUGUoYyxlLHQscixzLGcpe3ZhciB2LGg9ZSZiYyxsPWUmUmMsdT1lJkNjO2lmKHQmJih2PXM/dChjLHIscyxnKTp0KGMpKSx2IT09dm9pZCAwKXJldHVybiB2O2lmKCFUYyhjKSlyZXR1cm4gYzt2YXIgTT1NYyhjKTtpZihNKXtpZih2PXljKGMpLCFoKXJldHVybiBjYyhjLHYpfWVsc2V7dmFyIGY9dmMoYykseT1mPT1fcnx8Zj09amM7aWYoT2MoYykpcmV0dXJuIHVjKGMsaCk7aWYoZj09dG58fGY9PWtyfHx5JiYhcyl7aWYodj1sfHx5P3t9OnhjKGMpLCFoKXJldHVybiBsP2RjKGMsZmModixjKSk6aGMoYyxsYyh2LGMpKX1lbHNle2lmKCFTdFtmXSlyZXR1cm4gcz9jOnt9O3Y9cGMoYyxmLGgpfX1nfHwoZz1uZXcgc2MpO3ZhciB4PWcuZ2V0KGMpO2lmKHgpcmV0dXJuIHg7Zy5zZXQoYyx2KSxBYyhjKT9jLmZvckVhY2goZnVuY3Rpb24obSl7di5hZGQoUGUobSxlLHQsbSxjLGcpKX0pOkVjKGMpJiZjLmZvckVhY2goZnVuY3Rpb24obSxwKXt2LnNldChwLFBlKG0sZSx0LHAsYyxnKSl9KTt2YXIgYj11P2w/bWM6Z2M6bD9TYzpQYyxPPU0/dm9pZCAwOmIoYyk7cmV0dXJuIGFjKE98fGMsZnVuY3Rpb24obSxwKXtPJiYocD1tLG09Y1twXSksb2ModixwLFBlKG0sZSx0LHAsYyxnKSl9KSx2fXZhciBfYz1QZSx0aD1fYyxlaD0xLHJoPTQ7ZnVuY3Rpb24gbmgoYyl7cmV0dXJuIHRoKGMsZWh8cmgpfXZhciBpaD1uaCxKZT1SZShpaCk7Y29uc3QgYWU9Y2xhc3MgYWUgZXh0ZW5kcyBIbntjb25zdHJ1Y3Rvcigpe3N1cGVyKCk7VnQodGhpcywiY2FtZXJhT3B0Iik7VnQodGhpcywiZHByIik7VnQodGhpcywic2NlbmUiKTtWdCh0aGlzLCJkcmF3TGF5ZXIiKTtWdCh0aGlzLCJmdWxsTGF5ZXIiKTtWdCh0aGlzLCJzbmFwc2hvdEZ1bGxMYXllciIpO1Z0KHRoaXMsImxvY2FsV29yayIpO3RoaXMucmVnaXN0ZXIoKX1pbml0KHQscixzKXt0aGlzLmRwcj10LHRoaXMuc2NlbmU9dGhpcy5jcmVhdGVTY2VuZShyKSx0aGlzLmRyYXdMYXllcj10aGlzLmNyZWF0ZUxheWVyKHRoaXMuc2NlbmUsey4uLnMsd2lkdGg6ci53aWR0aCxoZWlnaHQ6ci5oZWlnaHR9KSx0aGlzLnNuYXBzaG90RnVsbExheWVyPXRoaXMuY3JlYXRlTGF5ZXIodGhpcy5zY2VuZSx7Li4ucyx3aWR0aDpyLndpZHRoLGhlaWdodDpyLmhlaWdodCxidWZmZXJTaXplOjVlM30pLHRoaXMubG9jYWxXb3JrPW5ldyBZbih0aGlzLmN1ck5vZGVNYXAsdGhpcy5kcmF3TGF5ZXIsdGhpcy5wb3N0LmJpbmQodGhpcykpfWdldE9mZnNjcmVlbih0KXt2YXIgcjtyZXR1cm4ocj0odCYmdGhpcy5zbmFwc2hvdEZ1bGxMYXllcnx8dGhpcy5kcmF3TGF5ZXIpLnBhcmVudCk9PW51bGw/dm9pZCAwOnIuY2FudmFzfXJlZ2lzdGVyKCl7dGhpcy5vbih0PT57Zm9yKGNvbnN0IHIgb2YgdCl7Y29uc3R7d29ya1N0YXRlOnMsZGF0YVR5cGU6Zyxtc2dUeXBlOnYsd29ya0lkOmgsdG9vbHNUeXBlOmwsb3B0OnV9PXI7c3dpdGNoKHYpe2Nhc2UgRXQuU25hcHNob3Q6dGhpcy5nZXRTbmFwc2hvdChyKTticmVhaztjYXNlIEV0LkJvdW5kaW5nQm94OnRoaXMuZ2V0Qm91bmRpbmdSZWN0KHIpO2JyZWFrO2Nhc2UgRXQuVXBkYXRlVG9vbHM6bCYmdSYmdGhpcy5zZXRUb29sc09wdCh7dG9vbHNUeXBlOmwsdG9vbHNPcHQ6dX0pO2JyZWFrO2Nhc2UgRXQuQ3JlYXRlV29yazpoJiZ1JiYoIXRoaXMubG9jYWxXb3JrLmdldFRtcFdvcmtTaGFwZU5vZGUoKSYmbCYmdGhpcy5zZXRUb29sc09wdCh7dG9vbHNUeXBlOmwsdG9vbHNPcHQ6dX0pLHRoaXMuc2V0V29ya09wdCh7d29ya0lkOmgsdG9vbHNPcHQ6dX0pKTticmVhaztjYXNlIEV0LkRyYXdXb3JrOnM9PT1RdC5Eb25lJiZnPT09THQuTG9jYWw/dGhpcy5jb25zdW1lRHJhd0FsbChnLHIpOnRoaXMuY29uc3VtZURyYXcoZyxyKTticmVha319fSl9c2V0VG9vbHNPcHQodCl7dGhpcy5sb2NhbFdvcmsuc2V0VG9vbHNPcHQodCl9c2V0V29ya09wdCh0KXtjb25zdHt3b3JrSWQ6cix0b29sc09wdDpzfT10O3ImJnMmJnRoaXMubG9jYWxXb3JrLnNldFdvcmtPcHRpb25zKHIscyl9Y2xlYXJBbGwoKXt0aGlzLmRyYXdMYXllci5yZW1vdmVBbGxDaGlsZHJlbigpLHRoaXMubG9jYWxXb3JrLmNsZWFyQWxsV29ya1NoYXBlc0NhY2hlKCl9c2V0Q2FtZXJhT3B0KHQscil7dGhpcy5jYW1lcmFPcHQ9dDtjb25zdHtzY2FsZTpzLGNlbnRlclg6ZyxjZW50ZXJZOnYsd2lkdGg6aCxoZWlnaHQ6bH09dDsoaCE9PXRoaXMuc2NlbmUud2lkdGh8fGwhPT10aGlzLnNjZW5lLmhlaWdodCkmJnRoaXMudXBkYXRlU2NlbmUoe3dpZHRoOmgsaGVpZ2h0Omx9KSxyLnNldEF0dHJpYnV0ZSgic2NhbGUiLFtzLHNdKSxyLnNldEF0dHJpYnV0ZSgidHJhbnNsYXRlIixbLWcsLXZdKX1nZXRSZWN0SW1hZ2VCaXRtYXAodCxyPSExLHMpe2NvbnN0IGc9dC54KnRoaXMuZHByLHY9dC55KnRoaXMuZHByLGg9dC53KnRoaXMuZHByLGw9dC5oKnRoaXMuZHByO3JldHVybiBjcmVhdGVJbWFnZUJpdG1hcCh0aGlzLmdldE9mZnNjcmVlbihyKSxnLHYsaCxsLHMpfXNhZmFyaUZpeFJlY3QodCl7aWYoISh0LncrdC54PD0wfHx0LmgrdC55PD0wKSYmKHQudyt0Lng+dGhpcy5zY2VuZS53aWR0aCYmKHQudz10aGlzLnNjZW5lLndpZHRoLU1hdGgubWF4KHQueCwwKSksdC5oK3QueT50aGlzLnNjZW5lLndpZHRoJiYodC5oPXRoaXMuc2NlbmUuaGVpZ2h0LU1hdGgubWF4KHQueSwwKSksISh0Lnc8PTB8fHQuaDw9MCkpKXJldHVybiB0Lng8MCYmKHQueD0wKSx0Lnk8MCYmKHQueT0wKSx0fWFzeW5jIHBvc3QodCl7dmFyIGc7Y29uc3Qgcj10LnJlbmRlcixzPVtdO2lmKHIhPW51bGwmJnIubGVuZ3RoKXtmb3IoY29uc3QgdiBvZiByKWlmKHYuZHJhd0NhbnZhcyYmdGhpcy5kcmF3TGF5ZXIucGFyZW50LnJlbmRlcigpLHYucmVjdCl7aWYodi5yZWN0PXRoaXMuc2FmYXJpRml4UmVjdChKZSh2LnJlY3QpKSwhdi5yZWN0KWNvbnRpbnVlO2lmKHYuZHJhd0NhbnZhcyl7Y29uc3QgaD1hd2FpdCB0aGlzLmdldFJlY3RJbWFnZUJpdG1hcCh2LnJlY3QsISF2LmlzRnVsbFdvcmspO3YuaW1hZ2VCaXRtYXA9aH1zLnB1c2godil9dC5yZW5kZXI9c31pZigoKGc9dC5zcCkhPW51bGwmJmcubGVuZ3RofHx0LmRyYXdDb3VudHx8cyE9bnVsbCYmcy5sZW5ndGgpJiYoYWUuX3NlbGYucG9zdE1lc3NhZ2UodCkscy5sZW5ndGgpKWZvcihjb25zdCB2IG9mIHMpdi5pbWFnZUJpdG1hcCYmdi5pbWFnZUJpdG1hcC5jbG9zZSgpfW9uKHQpe29ubWVzc2FnZT1yPT57aWYoci5kYXRhKXtjb25zdCBzPXIuZGF0YS5nZXQoIkluaXQiKTtpZihzKXtjb25zdHtkcHI6aCxvZmZzY3JlZW5DYW52YXNPcHQ6bCxsYXllck9wdDp1fT1zO2wmJnUmJmgmJnRoaXMuaW5pdChoLGwsdSl9Y29uc3QgZz1yLmRhdGEuaGFzKCJDbGVhckFsbCIpLHY9ci5kYXRhLmdldCgiVXBkYXRlQ2FtZXJhIik7aWYodil7Y29uc3R7Y2FtZXJhT3B0Omh9PXY7aCYmdGhpcy5zZXRDYW1lcmFPcHQoaCx0aGlzLmRyYXdMYXllcil9ZyYmdGhpcy5jbGVhckFsbCgpLHQoci5kYXRhLnZhbHVlcygpKX19fWNvbnN1bWVEcmF3KHQscil7dD09PUx0LkxvY2FsJiZ0aGlzLmxvY2FsV29yay5jb25zdW1lRHJhdyhyKX1jb25zdW1lRHJhd0FsbCh0LHIpe3RoaXMubG9jYWxXb3JrLmNvbnN1bWVEcmF3QWxsKHIpfWFzeW5jIGdldFNuYXBzaG90KHQpe2NvbnN0e3NjZW5lUGF0aDpyLHNjZW5lczpzLGNhbWVyYU9wdDpnLHc6dixofT10O2lmKHImJnMmJmcpe2NvbnN0IGw9SmUodGhpcy5jYW1lcmFPcHQpO3RoaXMuc2V0Q2FtZXJhT3B0KGcsdGhpcy5zbmFwc2hvdEZ1bGxMYXllciksdGhpcy5sb2NhbFdvcmsuZnVsbExheWVyPXRoaXMuc25hcHNob3RGdWxsTGF5ZXIsdGhpcy5sb2NhbFdvcmsuZHJhd0xheWVyPXRoaXMuZHJhd0xheWVyO2Zvcihjb25zdFtmLHldb2YgT2JqZWN0LmVudHJpZXMocykpaWYoeSE9bnVsbCYmeS50eXBlKXN3aXRjaCh5PT1udWxsP3ZvaWQgMDp5LnR5cGUpe2Nhc2UgRXQuVXBkYXRlTm9kZTpjYXNlIEV0LkZ1bGxXb3JrOnRoaXMubG9jYWxXb3JrLnJ1bkZ1bGxXb3JrKHsuLi55LHdvcmtJZDpmLG1zZ1R5cGU6RXQuRnVsbFdvcmssZGF0YVR5cGU6THQuU2VydmljZX0pO2JyZWFrfXRoaXMubG9jYWxXb3JrLmZ1bGxMYXllcj10aGlzLmRyYXdMYXllcix0aGlzLmxvY2FsV29yay5kcmF3TGF5ZXI9dm9pZCAwO2xldCB1O3YmJmgmJih1PXtyZXNpemVXaWR0aDp2LHJlc2l6ZUhlaWdodDpofSksdGhpcy5zbmFwc2hvdEZ1bGxMYXllci5wYXJlbnQucmVuZGVyKCk7Y29uc3QgTT1hd2FpdCB0aGlzLmdldFJlY3RJbWFnZUJpdG1hcCh7eDowLHk6MCx3OnRoaXMuc2NlbmUud2lkdGgsaDp0aGlzLnNjZW5lLmhlaWdodH0sITAsdSk7TSYmKGFlLl9zZWxmLnBvc3RNZXNzYWdlKHtzcDpbe3R5cGU6RXQuU25hcHNob3Qsc2NlbmVQYXRoOnIsaW1hZ2VCaXRtYXA6TX1dfSxbTV0pLE0uY2xvc2UoKSx0aGlzLnNuYXBzaG90RnVsbExheWVyLnJlbW92ZUFsbENoaWxkcmVuKCksdGhpcy5zZXRDYW1lcmFPcHQobCx0aGlzLmRyYXdMYXllcikpfX1nZXRCb3VuZGluZ1JlY3QodCl7Y29uc3R7c2NlbmVQYXRoOnIsc2NlbmVzOnMsY2FtZXJhT3B0Omd9PXQ7aWYociYmcyYmZyl7Y29uc3Qgdj1KZSh0aGlzLmNhbWVyYU9wdCk7dGhpcy5zZXRDYW1lcmFPcHQoZyx0aGlzLnNuYXBzaG90RnVsbExheWVyKSx0aGlzLmxvY2FsV29yay5mdWxsTGF5ZXI9dGhpcy5zbmFwc2hvdEZ1bGxMYXllcix0aGlzLmxvY2FsV29yay5kcmF3TGF5ZXI9dGhpcy5kcmF3TGF5ZXI7bGV0IGg7Zm9yKGNvbnN0W2wsdV1vZiBPYmplY3QuZW50cmllcyhzKSlpZih1IT1udWxsJiZ1LnR5cGUpc3dpdGNoKHU9PW51bGw/dm9pZCAwOnUudHlwZSl7Y2FzZSBFdC5VcGRhdGVOb2RlOmNhc2UgRXQuRnVsbFdvcms6dGhpcy5sb2NhbFdvcmsucnVuRnVsbFdvcmsoey4uLnUsd29ya0lkOmwsbXNnVHlwZTpFdC5GdWxsV29yayxkYXRhVHlwZTpMdC5TZXJ2aWNlfSk7YnJlYWt9dGhpcy5sb2NhbFdvcmsuY29tcHV0Tm9kZU1hcCgpLHRoaXMuY3VyTm9kZU1hcC5mb3JFYWNoKChsLHUpPT57bC5yZWN0JiYoaD1DdChoLHt4Ok1hdGguZmxvb3IoKGwucmVjdC54LXRoaXMuc25hcHNob3RGdWxsTGF5ZXIud29ybGRQb3NpdGlvblswXSkvdGhpcy5zbmFwc2hvdEZ1bGxMYXllci53b3JsZFNjYWxpbmdbMF0pLHk6TWF0aC5mbG9vcigobC5yZWN0LnktdGhpcy5zbmFwc2hvdEZ1bGxMYXllci53b3JsZFBvc2l0aW9uWzFdKS90aGlzLnNuYXBzaG90RnVsbExheWVyLndvcmxkU2NhbGluZ1sxXSksdzpNYXRoLmZsb29yKGwucmVjdC53L3RoaXMuc25hcHNob3RGdWxsTGF5ZXIud29ybGRTY2FsaW5nWzBdKSxoOk1hdGguZmxvb3IobC5yZWN0LmgvdGhpcy5zbmFwc2hvdEZ1bGxMYXllci53b3JsZFNjYWxpbmdbMV0pfSksdGhpcy5jdXJOb2RlTWFwLmRlbGV0ZSh1KSl9KSxoJiZhZS5fc2VsZi5wb3N0TWVzc2FnZSh7c3A6W3t0eXBlOkV0LkJvdW5kaW5nQm94LHNjZW5lUGF0aDpyLHJlY3Q6aH1dfSksdGhpcy5sb2NhbFdvcmsuZnVsbExheWVyPXRoaXMuZHJhd0xheWVyLHRoaXMubG9jYWxXb3JrLmRyYXdMYXllcj12b2lkIDAsdGhpcy5zbmFwc2hvdEZ1bGxMYXllci5yZW1vdmVBbGxDaGlsZHJlbigpLHRoaXMuc2V0Q2FtZXJhT3B0KHYsdGhpcy5kcmF3TGF5ZXIpfX19O1Z0KGFlLCJfc2VsZiIsc2VsZik7bGV0IFFlPWFlO25ldyBRZX0pKCk7Cg==", It = typeof window < "u" && window.Blob && new Blob([atob(ts)], { type: "text/javascript;charset=utf-8" });
function aa(m) {
  let l;
  try {
    if (l = It && (window.URL || window.webkitURL).createObjectURL(It), !l)
      throw "";
    const i = new Worker(l, {
      name: m == null ? void 0 : m.name
    });
    return i.addEventListener("error", () => {
      (window.URL || window.webkitURL).revokeObjectURL(l);
    }), i;
  } catch {
    return new Worker(
      "data:application/javascript;base64," + ts,
      {
        name: m == null ? void 0 : m.name
      }
    );
  } finally {
    l && (window.URL || window.webkitURL).revokeObjectURL(l);
  }
}
const Wa = "index-module__Container__nLsM3", ua = "index-module__CanvasBox__j2Xe-", Ga = "index-module__FloatCanvas__d1YR7", Va = "index-module__FloatBar__cm-EL", ha = "index-module__RotateBtn__HSSkf", Ia = "index-module__CursorBox__2UHvI", dl = {
  Container: Wa,
  CanvasBox: ua,
  FloatCanvas: Ga,
  FloatBar: Va,
  RotateBtn: ha,
  CursorBox: Ia
};
var pa = Zl, ya = function() {
  return pa.Date.now();
}, La = ya, ra = /\s/;
function Ya(m) {
  for (var l = m.length; l-- && ra.test(m.charAt(l)); )
    ;
  return l;
}
var xa = Ya, Sa = xa, Ra = /^\s+/;
function Ka(m) {
  return m && m.slice(0, Sa(m) + 1).replace(Ra, "");
}
var Ca = Ka, Ja = Kl, Fa = pl, Ta = "[object Symbol]";
function Na(m) {
  return typeof m == "symbol" || Fa(m) && Ja(m) == Ta;
}
var ga = Na, Ha = Ca, pt = Il, Ma = ga, yt = NaN, za = /^[-+]0x[0-9a-f]+$/i, ka = /^0b[01]+$/i, va = /^0o[0-7]+$/i, Ua = parseInt;
function fa(m) {
  if (typeof m == "number")
    return m;
  if (Ma(m))
    return yt;
  if (pt(m)) {
    var l = typeof m.valueOf == "function" ? m.valueOf() : m;
    m = pt(l) ? l + "" : l;
  }
  if (typeof m != "string")
    return m === 0 ? m : +m;
  m = Ha(m);
  var i = ka.test(m);
  return i || va.test(m) ? Ua(m.slice(2), i ? 2 : 8) : za.test(m) ? yt : +m;
}
var Qa = fa, Pa = Il, nd = La, Lt = Qa, wa = "Expected a function", Ea = Math.max, ja = Math.min;
function Ba(m, l, i) {
  var d, s, X, a, e, n, G = 0, y = !1, o = !1, h = !0;
  if (typeof m != "function")
    throw new TypeError(wa);
  l = Lt(l) || 0, Pa(i) && (y = !!i.leading, o = "maxWait" in i, X = o ? Ea(Lt(i.maxWait) || 0, l) : X, h = "trailing" in i ? !!i.trailing : h);
  function I(r) {
    var S = d, C = s;
    return d = s = void 0, G = r, a = m.apply(C, S), a;
  }
  function x(r) {
    return G = r, e = setTimeout(V, l), y ? I(r) : a;
  }
  function p(r) {
    var S = r - n, C = r - G, F = l - S;
    return o ? ja(F, X - C) : F;
  }
  function W(r) {
    var S = r - n, C = r - G;
    return n === void 0 || S >= l || S < 0 || o && C >= X;
  }
  function V() {
    var r = nd();
    if (W(r))
      return t(r);
    e = setTimeout(V, p(r));
  }
  function t(r) {
    return e = void 0, h && d ? I(r) : (d = s = void 0, a);
  }
  function c() {
    e !== void 0 && clearTimeout(e), G = 0, d = n = s = e = void 0;
  }
  function b() {
    return e === void 0 ? a : t(nd());
  }
  function Z() {
    var r = nd(), S = W(r);
    if (d = arguments, s = this, n = r, S) {
      if (e === void 0)
        return x(n);
      if (o)
        return clearTimeout(e), e = setTimeout(V, l), I(n);
    }
    return e === void 0 && (e = setTimeout(V, l)), a;
  }
  return Z.cancel = c, Z.flush = b, Z;
}
var Oa = Ba, Da = Oa, Aa = Il, qa = "Expected a function";
function $a(m, l, i) {
  var d = !0, s = !0;
  if (typeof m != "function")
    throw new TypeError(qa);
  return Aa(i) && (d = "leading" in i ? !!i.leading : d, s = "trailing" in i ? !!i.trailing : s), Da(m, l, {
    leading: d,
    maxWait: l,
    trailing: s
  });
}
var _a = $a;
const ji = /* @__PURE__ */ Dl(_a), iW = {
  delete: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTEyIDZ2NmEyIDIgMCAwIDEtMiAySDZhMiAyIDAgMCAxLTItMlY2aDBtMS0yYTIgMiAwIDAgMSAyLTJoMmEyIDIgMCAwIDEgMiAyaDBNMyA0aDEwIiBzdHJva2U9IiM0NDRFNjAiIGZpbGw9Im5vbmUiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIvPjwvc3ZnPg==",
  duplicate: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgc3Ryb2tlPSIjNDQ0RTYwIiBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiPjxwYXRoIGQ9Ik0xMSAySDZhMSAxIDAgMCAwLTEgMXY4YTEgMSAwIDAgMCAxIDFoNmExIDEgMCAwIDAgMS0xVjRoMGwtMi0yeiIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIi8+PHBhdGggZD0iTTExIDJ2MWExIDEgMCAwIDAgMSAxaDFsLTItMnoiLz48cGF0aCBkPSJNOSAxNEg0YTEgMSAwIDAgMS0xLTFWNWgwIiBzdHJva2UtbGluZWNhcD0icm91bmQiLz48L2c+PC9zdmc+",
  "layer-pressed": "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0ibTE2IDEwLTYgNCA2IDQgNi00em0tNiA4IDYgNCA2LTQiIHN0cm9rZT0iIzMzODFGRiIgZmlsbD0ibm9uZSIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIi8+PC9zdmc+",
  layer: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0ibTE2IDEwLTYgNCA2IDQgNi00em0tNiA4IDYgNCA2LTQiIHN0cm9rZT0iIzQ0NEU2MCIgZmlsbD0ibm9uZSIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIi8+PC9zdmc+",
  rotate: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjUiIGhlaWdodD0iMjQiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgc3Ryb2tlPSIjNDQ0RTYwIiBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCI+PHBhdGggZD0iTTEzIDZhNiA2IDAgMSAxLTMuNzA5IDEuMjgzIi8+PHBhdGggZD0ibTEzIDYgMS40MTQgMi40NUwxMyA2bDIuNDUtMS40MTQiLz48L2c+PC9zdmc+",
  "rotation-button": "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgZmlsbD0iI0ZGRiIgZmlsbC1ydWxlPSJldmVub2RkIj48cGF0aCBvcGFjaXR5PSIuMDEiIGQ9Ik0wIDI0VjBoMjR2MjR6Ii8+PHBhdGggZD0iTTUuNzI0IDUuNzI0QTguODQ3IDguODQ3IDAgMCAxIDEyIDMuMTI1YzIuMjcxIDAgNC41NDMuODY2IDYuMjc2IDIuNmE4Ljg0NiA4Ljg0NiAwIDAgMSAyLjU5OCA2LjE0IDguODQ5IDguODQ5IDAgMCAxLTIuNTU5IDYuMzdsLTEuNS0uOTgzQTcuMTA1IDcuMTA1IDAgMCAwIDE5LjEyNSAxMmE3LjEwMyA3LjEwMyAwIDAgMC0yLjA4Ny01LjAzOEE3LjEwMyA3LjEwMyAwIDAgMCAxMiA0Ljg3NWE3LjEwMyA3LjEwMyAwIDAgMC01LjAzOCAyLjA4NyA3LjEwMSA3LjEwMSAwIDAgMC0yLjA4NiA0LjkyIDcuMTAzIDcuMTAzIDAgMCAwIDEuNzY2IDQuODE1bDEuOTQ1LTEuNTg0IDIuMzk0IDcuMTgyLTcuMjIyLTIuNDA4IDEuNzkxLTEuNzlBOC44NDYgOC44NDYgMCAwIDEgMy4xMjUgMTJjMC0yLjI3MS44NjYtNC41NDMgMi42LTYuMjc2eiIgc3Ryb2tlPSIjRkZGIiBzdHJva2Utd2lkdGg9Ii41IiBmaWxsLXJ1bGU9Im5vbnplcm8iLz48L2c+PC9zdmc+",
  rotation: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIj48cGF0aCBmaWxsPSIjRkZGIiBvcGFjaXR5PSIuMDEiIGQ9Ik0wIDI0VjBoMjR2MjR6Ii8+PHBhdGggZD0iTTUuNzI0IDUuNzI0QTguODQ3IDguODQ3IDAgMCAxIDEyIDMuMTI1YzIuMjcxIDAgNC41NDMuODY2IDYuMjc2IDIuNmE4Ljg0NiA4Ljg0NiAwIDAgMSAyLjU5OCA2LjE0IDguODQ5IDguODQ5IDAgMCAxLTIuNTU5IDYuMzdsLTEuNS0uOTgzQTcuMTA1IDcuMTA1IDAgMCAwIDE5LjEyNSAxMmE3LjEwMyA3LjEwMyAwIDAgMC0yLjA4Ny01LjAzOEE3LjEwMyA3LjEwMyAwIDAgMCAxMiA0Ljg3NWE3LjEwMyA3LjEwMyAwIDAgMC01LjAzOCAyLjA4NyA3LjEwMSA3LjEwMSAwIDAgMC0yLjA4NiA0LjkyIDcuMTAzIDcuMTAzIDAgMCAwIDEuNzY2IDQuODE1bDEuOTQ1LTEuNTg0IDIuMzk0IDcuMTgyLTcuMjIyLTIuNDA4IDEuNzkxLTEuNzlBOC44NDYgOC44NDYgMCAwIDEgMy4xMjUgMTJjMC0yLjI3MS44NjYtNC41NDMgMi42LTYuMjc2eiIgc3Ryb2tlPSIjRkZGIiBzdHJva2Utd2lkdGg9Ii41IiBmaWxsPSIjMDAwIiBmaWxsLXJ1bGU9Im5vbnplcm8iLz48L2c+PC9zdmc+",
  "font-colors-active": "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0ibTQgMTEgNC05IDQgOU02IDdoNCIgc3Ryb2tlPSIjMzM4MUZGIiBmaWxsPSJub25lIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiLz48L3N2Zz4=",
  "font-colors": "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0ibTQgMTEgNC05IDQgOU02IDdoNCIgc3Ryb2tlPSIjNDQ0RTYwIiBmaWxsPSJub25lIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiLz48L3N2Zz4=",
  "to-bottom": "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTEyIDEwdjhtMCAwLTItMm0yIDIgMi0ybS00IDZoMTJtLTYtNGg2bS02LTRoNm0tNi00aDYiIHN0cm9rZT0iIzQ0NEU2MCIgZmlsbD0ibm9uZSIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIi8+PC9zdmc+",
  "to-top": "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTEyIDIydi04bTAgMC0yIDJtMi0yIDIgMm0tNC02aDEybS02IDRoNm0tNiA0aDZtLTYgNGg2IiBzdHJva2U9IiM0NDRFNjAiIGZpbGw9Im5vbmUiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIvPjwvc3ZnPg=="
};
function rl(m) {
  return iW[m];
}
var qi;
(function(m) {
  m[m.sdk = 1] = "sdk", m[m.plugin = 2] = "plugin", m[m.both = 3] = "both";
})(qi || (qi = {}));
var Wl;
(function(m) {
  m[m.Draw = 1] = "Draw", m[m.Delete = 2] = "Delete", m[m.Update = 3] = "Update";
})(Wl || (Wl = {}));
class Ki {
  constructor(l, i, d) {
    Object.defineProperty(this, "undoStack", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "redoStack", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "worker", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "colloctor", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "room", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "isTicking", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "undoTickerId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "tickStartStorerCache", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "excludeIds", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: /* @__PURE__ */ new Set()
    }), Object.defineProperty(this, "undoTickerEnd", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: Ws((s) => {
        if (s === this.undoTickerId && this.tickStartStorerCache) {
          this.isTicking = !1;
          const X = this.diffFun(this.tickStartStorerCache, new Map(Object.entries(this.colloctor.storage))), a = this.undoStack.find((e) => e.id === this.undoTickerId);
          a ? a.data = X : X.size && (this.undoStack.push({
            id: s,
            type: qi.plugin,
            data: X
          }), this.undoStack.length > Ki.MaxStackLength && this.undoStack.shift(), Ki.emitter.emit("onCanUndoStepsUpdate", this.undoStack.length)), this.redoStack.length && (this.redoStack.length = 0, Ki.emitter.emit("onCanRedoStepsUpdate", this.redoStack.length)), this.tickStartStorerCache = void 0, this.undoTickerId = void 0, this.excludeIds.clear();
        }
      }, Ki.waitTime)
    }), this.undoStack = [], this.redoStack = [], this.room = l, this.worker = i, this.colloctor = d, this.isTicking = !1, Ki.emitter.on("undoTickerStart", this.undoTickerStart.bind(this)), Ki.emitter.on("undoTickerEnd", this.undoTickerEnd.bind(this)), Ki.emitter.on("excludeIds", this.addExcludeIds.bind(this));
  }
  addExcludeIds(l) {
    if (this.isTicking)
      for (const i of l)
        this.excludeIds.add(i);
  }
  addSdkUndoData(l) {
    const i = this.undoStack.findIndex((d) => (d == null ? void 0 : d.sdkStep) && d.sdkStep > l);
    if (i > -1)
      this.undoStack.splice(i);
    else if (l > 0 && this.undoStack.findIndex((s) => (s == null ? void 0 : s.sdkStep) && s.sdkStep === l) === -1)
      if (this.isTicking && this.undoTickerId) {
        const s = this.undoStack.find((X) => X.id === this.undoTickerId);
        s ? (s.type = qi.both, s.sdkStep = l) : (this.undoStack.push({
          id: this.undoTickerId,
          type: qi.both,
          sdkStep: l
        }), this.undoStack.length > Ki.MaxStackLength && this.undoStack.shift(), Ki.emitter.emit("onCanUndoStepsUpdate", this.undoStack.length));
      } else
        this.undoStack.push({
          type: qi.sdk,
          sdkStep: l
        }), this.undoStack.length > Ki.MaxStackLength && this.undoStack.shift(), Ki.emitter.emit("onCanUndoStepsUpdate", this.undoStack.length);
  }
  diffFun(l, i) {
    const d = /* @__PURE__ */ new Set(), s = l.keys(), X = i.keys();
    for (const a of s) {
      if (this.excludeIds.has(a))
        continue;
      const e = l.get(a), n = i.get(a);
      if (e && n) {
        if (us(n, e))
          continue;
        d.add({
          dataType: Wl.Update,
          key: a,
          data: [e, n]
        });
        continue;
      }
      e && d.add({
        dataType: Wl.Delete,
        key: a,
        data: e
      });
    }
    for (const a of X) {
      const e = i.get(a);
      e && !l.has(a) && d.add({
        dataType: Wl.Draw,
        key: a,
        data: e
      });
    }
    return d;
  }
  undoTickerStart(l) {
    this.excludeIds.clear(), this.isTicking = !0, this.undoTickerId = l, this.tickStartStorerCache = new Map(Object.entries(Gs(this.colloctor.storage)));
  }
  isDrawEffectiveScene(l, i) {
    const { key: d } = l;
    return !i.includes(d);
  }
  isDeleteEffectiveScene(l, i) {
    var X;
    const { key: d } = l;
    if (!i.includes(d))
      return !1;
    const s = i.filter((a) => this.colloctor.getLocalId(a) === Ci && !this.colloctor.isOwn(a)).map((a) => this.colloctor.storage[a]);
    for (const a of s)
      if ((X = a == null ? void 0 : a.selectIds) != null && X.includes(d))
        return !1;
    return !0;
  }
  isOldEffectiveScene(l, i) {
    var X;
    const { key: d } = l;
    if (!i.includes(d))
      return !1;
    const s = i.filter((a) => this.colloctor.getLocalId(a) === Ci && !this.colloctor.isOwn(a)).map((a) => this.colloctor.storage[a]);
    for (const a of s)
      if ((X = a == null ? void 0 : a.selectIds) != null && X.includes(d))
        return !1;
    return !0;
  }
  isNewEffectiveScene(l, i) {
    const { key: d } = l;
    return !!i.includes(d);
  }
  refreshPlugin(l, i = !1) {
    var X, a, e, n, G, y, o, h;
    let d;
    const s = Object.keys(this.colloctor.storage);
    for (const I of l.values())
      switch (I.dataType) {
        case Wl.Draw:
          if (d = i ? this.isDrawEffectiveScene(I, s) : this.isDeleteEffectiveScene(I, s), d)
            if (i && !Array.isArray(I.data)) {
              if ((X = I.data.updateNodeOpt) != null && X.useAnimation && (I.data.updateNodeOpt.useAnimation = !1), this.colloctor.getLocalId(I.key) === Ci && this.colloctor.isOwn(I.key)) {
                const x = I.data.selectIds;
                if (x) {
                  const p = s.filter((V) => this.colloctor.getLocalId(V) === Ci && !this.colloctor.isOwn(V)).map((V) => this.colloctor.storage[V]);
                  let W = !1;
                  for (const V of p)
                    for (let t = 0; t < x.length; t++)
                      (a = V == null ? void 0 : V.selectIds) != null && a.includes(x[t]) && (delete x[t], W = !0);
                  W && (I.data.selectIds = x.filter((V) => !!V));
                }
              }
              this.colloctor.updateValue(I.key, I.data, { isAfterUpdate: !0 });
            } else
              !i && !Array.isArray(I.data) && this.colloctor.updateValue(I.key, void 0, { isAfterUpdate: !0 });
          break;
        case Wl.Delete:
          if (d = i ? this.isDeleteEffectiveScene(I, s) : this.isDrawEffectiveScene(I, s), d) {
            if (i && !Array.isArray(I.data))
              this.colloctor.updateValue(I.key, void 0, { isAfterUpdate: !0 });
            else if (!i && !Array.isArray(I.data)) {
              if ((e = I.data.updateNodeOpt) != null && e.useAnimation && (I.data.updateNodeOpt.useAnimation = !1), this.colloctor.getLocalId(I.key) === Ci && this.colloctor.isOwn(I.key)) {
                const x = I.data.selectIds;
                if (x) {
                  const p = s.filter((V) => this.colloctor.getLocalId(V) === Ci && !this.colloctor.isOwn(V)).map((V) => this.colloctor.storage[V]);
                  let W = !1;
                  for (const V of p)
                    for (let t = 0; t < x.length; t++)
                      (n = V == null ? void 0 : V.selectIds) != null && n.includes(x[t]) && (delete x[t], W = !0);
                  W && (I.data.selectIds = x.filter((V) => !!V));
                }
              }
              this.colloctor.updateValue(I.key, I.data, { isAfterUpdate: !0 });
            }
          }
          break;
        case Wl.Update:
          if (d = i ? this.isNewEffectiveScene(I, s) : this.isOldEffectiveScene(I, s), d) {
            if (i && Array.isArray(I.data) && I.data.length === 2) {
              const x = I.data[1];
              if ((G = x.updateNodeOpt) != null && G.useAnimation && (x.updateNodeOpt.useAnimation = !1), this.colloctor.getLocalId(I.key) === Ci && this.colloctor.isOwn(I.key)) {
                const p = x.selectIds;
                if (p) {
                  const W = s.filter((t) => this.colloctor.getLocalId(t) === Ci && !this.colloctor.isOwn(t)).map((t) => this.colloctor.storage[t]);
                  let V = !1;
                  for (const t of W)
                    for (let c = 0; c < p.length; c++)
                      (y = t == null ? void 0 : t.selectIds) != null && y.includes(p[c]) && (delete p[c], V = !0);
                  V && (x.selectIds = p.filter((t) => !!t));
                }
              }
              this.colloctor.updateValue(I.key, x, { isAfterUpdate: !0 });
            } else if (!i && Array.isArray(I.data) && I.data.length === 2) {
              const x = I.data[0];
              if ((o = x.updateNodeOpt) != null && o.useAnimation && (x.updateNodeOpt.useAnimation = !1), this.colloctor.getLocalId(I.key) === Ci && this.colloctor.isOwn(I.key)) {
                const p = x.selectIds;
                if (p) {
                  const W = s.filter((t) => this.colloctor.getLocalId(t) === Ci && !this.colloctor.isOwn(t)).map((t) => this.colloctor.storage[t]);
                  let V = !1;
                  for (const t of W)
                    for (let c = 0; c < p.length; c++)
                      (h = t == null ? void 0 : t.selectIds) != null && h.includes(p[c]) && (delete p[c], V = !0);
                  V && (x.selectIds = p.filter((t) => !!t));
                }
              }
              this.colloctor.updateValue(I.key, x, { isAfterUpdate: !0 });
            }
          }
          break;
      }
  }
  undo(l) {
    const i = this.undoStack.pop();
    return i && (this.redoStack.push(i), (i.type === qi.sdk || i.type === qi.both) && i.sdkStep && l.call(this.room), (i.type === qi.plugin || i.type === qi.both) && i.data && this.refreshPlugin(i.data)), Ki.emitter.emit("onCanUndoStepsUpdate", this.undoStack.length), Ki.emitter.emit("onCanRedoStepsUpdate", this.redoStack.length), this.undoStack.length;
  }
  redo(l) {
    const i = this.redoStack.pop();
    return i && (this.undoStack.push(i), (i.type === qi.plugin || i.type === qi.both) && i.data && this.refreshPlugin(i.data, !0), (i.type === qi.sdk || i.type === qi.both) && i.sdkStep && l.call(this.room)), Ki.emitter.emit("onCanUndoStepsUpdate", this.undoStack.length), Ki.emitter.emit("onCanRedoStepsUpdate", this.redoStack.length), this.redoStack.length;
  }
  clear() {
    this.clearUndo(), this.clearRedo();
  }
  clearUndo() {
    this.undoStack.length = 0, Ki.emitter.emit("onCanUndoStepsUpdate", this.undoStack.length);
  }
  clearRedo() {
    this.redoStack.length = 0, Ki.emitter.emit("onCanRedoStepsUpdate", this.redoStack.length);
  }
  canUndo() {
    return !!this.undoStack.length;
  }
  canRedo() {
    return !!this.redoStack.length;
  }
  destroy() {
    Ki.emitter.removeAllListeners();
  }
}
Object.defineProperty(Ki, "MaxStackLength", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 20
});
Object.defineProperty(Ki, "emitter", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: new Vd()
});
Object.defineProperty(Ki, "waitTime", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 100
});
class ol {
  constructor() {
    Object.defineProperty(this, "emtType", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "mainEngine", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "serviceColloctor", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
  }
  static dispatch(l, i, d) {
    var s;
    (s = Fi.InternalMsgEmitter) == null || s.emit([l, i], d);
  }
  registerForMainEngine(l, i, d) {
    var s;
    return this.emtType = l, this.mainEngine = i, this.serviceColloctor = d, (s = Fi.InternalMsgEmitter) == null || s.on([this.emtType, this.emitEventType], this.collect.bind(this)), this;
  }
  destroy() {
    var l;
    this.emtType && ((l = Fi.InternalMsgEmitter) == null || l.off([this.emtType, this.emitEventType], this.collect.bind(this)));
  }
  collectForLocalWorker(l) {
    var d, s, X;
    const i = ((d = this.mainEngine) == null ? void 0 : d.taskBatchData) && [...this.mainEngine.taskBatchData.keys()] || [];
    for (const a of l)
      i.findIndex((e) => e.split("##")[0] === `${a.msgType},${a.workId}`) ? requestAnimationFrame(() => {
        var e, n;
        (e = this.mainEngine) == null || e.taskBatchData.set(`${a.msgType},${a.workId}##${a.emitEventType},`, a), (n = this.mainEngine) == null || n.runAnimation();
      }) : (s = this.mainEngine) == null || s.taskBatchData.set(`${a.msgType},${a.workId}##${a.emitEventType},`, a);
    (X = this.mainEngine) == null || X.runAnimation();
  }
  collectForServiceWorker(l) {
    sd(() => {
      l.forEach((i) => {
        var d;
        (d = this.serviceColloctor) == null || d.dispatch(i), i.undoTickerId && Ki.emitter.emit("undoTickerEnd", i.undoTickerId);
      });
    }, $i.maxLastSyncTime);
  }
}
class lW extends ol {
  constructor() {
    super(...arguments), Object.defineProperty(this, "emitEventType", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: Wi.ZIndexActive
    });
  }
  collect(l) {
    if (!this.serviceColloctor || !this.mainEngine)
      return;
    const { workId: i, isActive: d } = l, s = [], X = [];
    i === Li.selectorId && s.push({
      workId: i,
      msgType: pi.UpdateNode,
      dataType: Ti.Local,
      isActiveZIndex: d,
      emitEventType: this.emitEventType,
      willRefreshSelector: !0,
      willSyncService: !1
    }), s.length && this.collectForLocalWorker(s), X.length && this.collectForServiceWorker(X);
  }
}
class dW extends ol {
  constructor() {
    super(...arguments), Object.defineProperty(this, "emitEventType", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: Wi.CopyNode
    });
  }
  collect(l) {
    var y;
    if (!this.serviceColloctor || !this.mainEngine)
      return;
    const { workIds: i } = l, d = [...i], s = (y = this.serviceColloctor) == null ? void 0 : y.storage, X = [], a = [], e = Math.floor(Math.random() * 20 + 10);
    let n;
    const G = Date.now();
    for (; d.length; ) {
      const o = d.pop();
      if (!o)
        continue;
      const h = o.toString(), I = this.serviceColloctor.isLocalId(h), x = I ? this.serviceColloctor.transformKey(o) : h, p = tl(s[x]);
      let W = h;
      if (!I && this.serviceColloctor.isOwn(W) && (W = this.serviceColloctor.getLocalId(W)), p && W === Li.selectorId) {
        p.selectIds && d.push(...p.selectIds);
        continue;
      }
      if (p) {
        const V = Date.now(), t = (I ? o : this.serviceColloctor.getLocalId(o.toString())) + "-" + V, c = p.updateNodeOpt || {}, b = c.pos || [0, 0];
        n || (n = [-b[0], -b[1]]), c.pos = [b[0] + n[0] + e, b[1] + n[1] + e], c.useAnimation = !1;
        const Z = [c.pos[0] - b[0], c.pos[1] - b[1]];
        if (p.ops) {
          const r = $t(p.ops).map((C, F) => {
            const Y = F % 3;
            return Y === 0 ? C + Z[0] : Y === 1 ? C + Z[1] : C;
          }), S = _t(r);
          p.ops = S, a.push({
            ...p,
            updateNodeOpt: c,
            type: pi.FullWork,
            workId: t,
            undoTickerId: G
          }), X.push({
            ...p,
            workId: t,
            msgType: pi.FullWork,
            dataType: Ti.Local,
            updateNodeOpt: c,
            emitEventType: this.emitEventType,
            willSyncService: !1,
            willRefresh: !0
          });
        }
      }
    }
    Ki.emitter.emit("undoTickerStart", G), X.length && this.collectForLocalWorker(X), a.length && this.collectForServiceWorker(a);
  }
}
class tW extends ol {
  constructor() {
    super(...arguments), Object.defineProperty(this, "emitEventType", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: Wi.SetColorNode
    });
  }
  collect(l) {
    if (!this.serviceColloctor || !this.mainEngine)
      return;
    const { workIds: i, color: d, opacity: s } = l, X = [...i], a = this.serviceColloctor.storage, e = [], n = [], G = [], y = Date.now();
    for (; X.length; ) {
      const o = X.pop();
      if (!o)
        continue;
      const h = o.toString(), I = this.serviceColloctor.isLocalId(h), x = I ? this.serviceColloctor.transformKey(o) : h, p = tl(a[x]);
      let W = h;
      if (!I && this.serviceColloctor.isOwn(W) && (W = this.serviceColloctor.getLocalId(W)), p && W === Li.selectorId) {
        if (p.selectIds) {
          G.push(...p.selectIds);
          const V = p.updateNodeOpt || {};
          V.color = d, s && (V.opacity = s);
          const t = {
            workId: o,
            msgType: pi.UpdateNode,
            dataType: Ti.Local,
            updateNodeOpt: V,
            emitEventType: this.emitEventType,
            willRefreshSelector: !0,
            willSyncService: !0
          }, c = /* @__PURE__ */ new Map();
          G.forEach((b) => {
            var C, F, Y;
            const Z = (C = this.serviceColloctor) == null ? void 0 : C.isLocalId(b);
            let r = Z && ((F = this.serviceColloctor) == null ? void 0 : F.transformKey(b)) || b;
            const S = a[r];
            !Z && ((Y = this.serviceColloctor) != null && Y.isOwn(r)) && (r = this.serviceColloctor.getLocalId(r)), S != null && S.opt && c.set(r, {
              updateNodeOpt: S.updateNodeOpt,
              opt: S.opt
            });
          }), t.selectStore = c, t.willSerializeData = !0, t.undoTickerId = y, e.push(t);
        }
        continue;
      }
      if (p) {
        const V = p.opt, t = p.updateNodeOpt || {};
        if (V && (t.color = d, t.opacity = s, n.push({
          ...p,
          type: pi.UpdateNode,
          updateNodeOpt: t
        }), !G.includes(h))) {
          let c = h;
          !I && this.serviceColloctor.isOwn(c) && (c = this.serviceColloctor.getLocalId(c)), e.push({
            workId: c,
            msgType: pi.UpdateNode,
            dataType: Ti.Local,
            updateNodeOpt: t,
            emitEventType: this.emitEventType,
            willSyncService: !1,
            willRefresh: !0
          });
        }
      }
    }
    Ki.emitter.emit("undoTickerStart", y), e.length && this.collectForLocalWorker(e), n.length && this.collectForServiceWorker(n);
  }
}
class sW extends ol {
  constructor() {
    super(...arguments), Object.defineProperty(this, "emitEventType", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: Wi.ZIndexNode
    }), Object.defineProperty(this, "min", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "max", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    });
  }
  get minZIndex() {
    return this.min;
  }
  get maxZIndex() {
    return this.max;
  }
  set maxZIndex(l) {
    this.max = l;
  }
  set minZIndex(l) {
    this.min = l;
  }
  addMaxLayer() {
    this.max = this.max + 1;
  }
  addMinLayer() {
    this.min = this.min - 1;
  }
  collect(l) {
    if (!this.serviceColloctor || !this.mainEngine)
      return;
    const { workIds: i, layer: d } = l, s = [...i], X = this.serviceColloctor.storage, a = [], e = [], n = [];
    for (; s.length; ) {
      const y = s.pop();
      if (!y)
        continue;
      const o = y.toString(), h = this.serviceColloctor.isLocalId(o), I = h ? this.serviceColloctor.transformKey(y) : o, x = tl(X[I]);
      let p = o;
      !h && this.serviceColloctor.isOwn(p) && (p = this.serviceColloctor.getLocalId(p));
      let W;
      if (x && p === Li.selectorId) {
        if (x.selectIds) {
          n.push(...x.selectIds), n.sort((b, Z) => {
            var C, F, Y, J;
            const r = ((F = (C = X[G(b, this.serviceColloctor)]) == null ? void 0 : C.opt) == null ? void 0 : F.zIndex) || 0, S = ((J = (Y = X[G(b, this.serviceColloctor)]) == null ? void 0 : Y.opt) == null ? void 0 : J.zIndex) || 0;
            return r > S ? 1 : b < Z ? -1 : 0;
          });
          const V = x.updateNodeOpt || {};
          V.zIndexLayer = d;
          const t = {
            workId: y,
            msgType: pi.UpdateNode,
            dataType: Ti.Local,
            updateNodeOpt: V,
            emitEventType: this.emitEventType,
            willRefreshSelector: !0,
            willSyncService: !0
          }, c = /* @__PURE__ */ new Map();
          n.forEach((b) => {
            var C, F, Y;
            const Z = (C = this.serviceColloctor) == null ? void 0 : C.isLocalId(b);
            let r = Z && ((F = this.serviceColloctor) == null ? void 0 : F.transformKey(b)) || b;
            const S = X[r];
            !Z && ((Y = this.serviceColloctor) != null && Y.isOwn(r)) && (r = this.serviceColloctor.getLocalId(r)), d === ul.Top ? (this.addMaxLayer(), W = this.max) : (this.addMinLayer(), W = this.min), V.zIndex = W, S != null && S.opt && (S.opt.zIndex = W), S != null && S.opt && c.set(r, {
              updateNodeOpt: S.updateNodeOpt,
              opt: S.opt
            });
          }), t.selectStore = c, t.willSerializeData = !0, a.push(t);
        }
        continue;
      }
      if (x) {
        d === ul.Top ? (this.addMaxLayer(), W = this.max) : (this.addMinLayer(), W = this.min);
        const V = x.opt, t = x.updateNodeOpt || {};
        if (V && (t.zIndex = W, V.zIndex = W, e.push({
          ...x,
          type: pi.UpdateNode,
          opt: V
        }), !n.includes(o))) {
          let c = o;
          !h && this.serviceColloctor.isOwn(c) && (c = this.serviceColloctor.getLocalId(c)), a.push({
            workId: c,
            msgType: pi.UpdateNode,
            dataType: Ti.Local,
            updateNodeOpt: t,
            emitEventType: this.emitEventType,
            willSyncService: !1,
            willRefresh: !0
          });
        }
      }
    }
    a.length && this.collectForLocalWorker(a), e.length && this.collectForServiceWorker(e);
    function G(y, o) {
      return o.isLocalId(y) && o.transformKey(y) || y;
    }
  }
}
class bW extends ol {
  constructor() {
    super(...arguments), Object.defineProperty(this, "emitEventType", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: Wi.TranslateNode
    }), Object.defineProperty(this, "undoTickerId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "oldRect", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
  }
  collect(l) {
    var x, p, W, V, t;
    if (!this.serviceColloctor || !this.mainEngine)
      return;
    const { workIds: i, position: d, workState: s } = l, X = [...i], a = (x = this.serviceColloctor) == null ? void 0 : x.storage, e = [], n = [], G = [], y = (W = (p = this.mainEngine.displayer) == null ? void 0 : p.canvasBgRef) == null ? void 0 : W.getBoundingClientRect(), o = (t = (V = this.mainEngine.displayer) == null ? void 0 : V.floatBarCanvasRef.current) == null ? void 0 : t.getBoundingClientRect();
    let h = !1;
    const I = s === Ii.Start && Date.now() || void 0;
    for (I && (this.undoTickerId = I, Ki.emitter.emit("undoTickerStart", I)), y && o && this.oldRect && (this.oldRect.x < y.x && o.x > this.oldRect.x || this.oldRect.y < y.y && o.y > this.oldRect.y || this.oldRect.x + this.oldRect.width > y.x + y.width && o.x < this.oldRect.x || this.oldRect.y + this.oldRect.height > y.y + y.height && o.y < this.oldRect.y) && (h = !0), o && (this.oldRect = o); X.length; ) {
      const c = X.pop();
      if (!c)
        continue;
      const b = c.toString(), Z = this.serviceColloctor.isLocalId(b), r = Z && this.serviceColloctor.transformKey(c) || b, S = tl(a[r]);
      let C = b;
      if (!Z && this.serviceColloctor.isOwn(C) && (C = this.serviceColloctor.getLocalId(C)), S && C === Li.selectorId) {
        if (S.selectIds && (G.push(...S.selectIds), s !== Ii.Start)) {
          const F = S.updateNodeOpt || {};
          F.pos = this.mainEngine.transformToScenePoint([d.x, d.y]), F.workState = s;
          const Y = {
            workId: c,
            msgType: pi.UpdateNode,
            dataType: Ti.Local,
            updateNodeOpt: F,
            emitEventType: this.emitEventType,
            willRefreshSelector: h,
            willSyncService: !0
          };
          if (s === Ii.Done) {
            const J = /* @__PURE__ */ new Map();
            G.forEach((T) => {
              var f, w, O;
              const K = (f = this.serviceColloctor) == null ? void 0 : f.isLocalId(T);
              let R = K && ((w = this.serviceColloctor) == null ? void 0 : w.transformKey(T)) || T;
              const H = a[R];
              !K && ((O = this.serviceColloctor) != null && O.isOwn(R)) && (R = this.serviceColloctor.getLocalId(R)), H != null && H.ops && J.set(R, {
                ops: H.ops,
                updateNodeOpt: H.updateNodeOpt
              });
            }), Y.selectStore = J, Y.willSerializeData = !0, Y.undoTickerId = this.undoTickerId;
          }
          e.push(Y);
        }
        continue;
      }
      if (S) {
        const F = S.opt, Y = S.updateNodeOpt || {};
        if (F && (Y.pos = this.mainEngine.transformToScenePoint([d.x, d.y]), n.push({
          ...S,
          type: pi.UpdateNode,
          updateNodeOpt: Y
        }), !G.includes(b))) {
          let J = b;
          !Z && this.serviceColloctor.isOwn(J) && (J = this.serviceColloctor.getLocalId(J)), e.push({
            workId: J,
            msgType: pi.UpdateNode,
            dataType: Ti.Local,
            updateNodeOpt: Y,
            emitEventType: this.emitEventType,
            willSyncService: !1,
            willRefresh: !0
          });
        }
      }
    }
    e.length && this.collectForLocalWorker(e), n.length && this.collectForServiceWorker(n);
  }
}
class cW extends ol {
  constructor() {
    super(...arguments), Object.defineProperty(this, "emitEventType", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: Wi.DeleteNode
    });
  }
  collect(l) {
    var G;
    if (!this.serviceColloctor || !this.mainEngine)
      return;
    const { workIds: i } = l, d = this.serviceColloctor.storage, s = [...i], X = [], a = [], e = [], n = Date.now();
    for (; s.length; ) {
      const y = s.pop();
      if (!y)
        continue;
      const o = y.toString(), h = this.serviceColloctor.isLocalId(o), I = h ? this.serviceColloctor.transformKey(y) : o, x = d[I];
      let p = o;
      if (!h && this.serviceColloctor.isOwn(p) && (p = this.serviceColloctor.getLocalId(p)), x && p === Li.selectorId) {
        e.push(I), (G = Fi.InternalMsgEmitter) == null || G.emit([ui.FloatBar, Wi.ShowFloatBar], !1), x.selectIds && (e.push(...x.selectIds), X.push({
          msgType: pi.RemoveNode,
          workId: p,
          dataType: Ti.Local,
          emitEventType: Wi.DeleteNode
        }));
        continue;
      }
      x && e.push(I), X.push({
        msgType: pi.RemoveNode,
        emitEventType: Wi.DeleteNode,
        workId: y,
        dataType: Ti.Local,
        willSyncService: !1,
        willRefresh: !0
      });
    }
    Ki.emitter.emit("undoTickerStart", n), X.length && this.collectForLocalWorker(X), e.length && (a.push({
      type: pi.RemoveNode,
      removeIds: e,
      undoTickerId: n
    }), this.collectForServiceWorker(a));
  }
}
class mW extends ol {
  constructor() {
    super(...arguments), Object.defineProperty(this, "emitEventType", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: Wi.ScaleNode
    }), Object.defineProperty(this, "undoTickerId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
  }
  collect(l) {
    var o;
    if (!this.serviceColloctor || !this.mainEngine)
      return;
    const { workIds: i, size: d, workState: s } = l, X = [...i], a = (o = this.serviceColloctor) == null ? void 0 : o.storage, e = [], n = [], G = [], y = s === Ii.Start && Date.now() || void 0;
    for (y && (this.undoTickerId = y, Ki.emitter.emit("undoTickerStart", y)); X.length; ) {
      const h = X.pop();
      if (!h)
        continue;
      const I = h.toString(), x = this.serviceColloctor.isLocalId(I), p = x ? this.serviceColloctor.transformKey(h) : I, W = tl(a[p]);
      let V = I;
      if (!x && this.serviceColloctor.isOwn(V) && (V = this.serviceColloctor.getLocalId(V)), W && V === Li.selectorId && W.selectIds) {
        G.push(...W.selectIds);
        const t = W.updateNodeOpt || {};
        t.size = d, t.workState = s;
        const c = {
          workId: h,
          msgType: pi.UpdateNode,
          dataType: Ti.Local,
          updateNodeOpt: t,
          emitEventType: this.emitEventType,
          willRefreshSelector: !0,
          willSyncService: !0
        };
        if (s === Ii.Done) {
          const b = /* @__PURE__ */ new Map();
          G.forEach((Z) => {
            var F, Y, J;
            const r = (F = this.serviceColloctor) == null ? void 0 : F.isLocalId(Z);
            let S = r && ((Y = this.serviceColloctor) == null ? void 0 : Y.transformKey(Z)) || Z;
            const C = a[S];
            !r && ((J = this.serviceColloctor) != null && J.isOwn(S)) && (S = this.serviceColloctor.getLocalId(S)), C != null && C.ops && b.set(S, {
              ops: C.ops,
              updateNodeOpt: C.updateNodeOpt,
              opt: C.opt,
              toolsType: C.toolsType
            });
          }), c.selectStore = b, c.willSerializeData = !0, c.undoTickerId = this.undoTickerId;
        }
        e.push(c);
        continue;
      }
      if (W) {
        const t = W.opt, c = W.updateNodeOpt || {};
        if (t && (c.size = d, n.push({
          ...W,
          type: pi.UpdateNode,
          updateNodeOpt: c
        }), !G.includes(I))) {
          let b = I;
          !x && this.serviceColloctor.isOwn(b) && (b = this.serviceColloctor.getLocalId(b)), e.push({
            workId: b,
            msgType: pi.UpdateNode,
            dataType: Ti.Local,
            updateNodeOpt: c,
            emitEventType: this.emitEventType,
            willSyncService: !1,
            willRefresh: !0
          });
        }
      }
    }
    e.length && this.collectForLocalWorker(e), n.length && this.collectForServiceWorker(n);
  }
}
class ZW extends ol {
  constructor() {
    super(...arguments), Object.defineProperty(this, "emitEventType", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: Wi.RotateNode
    }), Object.defineProperty(this, "undoTickerId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
  }
  collect(l) {
    var o;
    if (!this.serviceColloctor || !this.mainEngine)
      return;
    const { workIds: i, angle: d, workState: s } = l, X = [...i], a = (o = this.serviceColloctor) == null ? void 0 : o.storage, e = [], n = [], G = [], y = s === Ii.Start && Date.now() || void 0;
    for (y && (this.undoTickerId = y, Ki.emitter.emit("undoTickerStart", y)); X.length; ) {
      const h = X.pop();
      if (!h)
        continue;
      const I = h.toString(), x = this.serviceColloctor.isLocalId(I), p = x && this.serviceColloctor.transformKey(h) || I, W = tl(a[p]);
      let V = I;
      if (!x && this.serviceColloctor.isOwn(V) && (V = this.serviceColloctor.getLocalId(V)), W && V === Li.selectorId) {
        if (W.selectIds && (G.push(...W.selectIds), s !== Ii.Start)) {
          const t = W.updateNodeOpt || {};
          t.angle = d, t.workState = s;
          const c = {
            workId: h,
            msgType: pi.UpdateNode,
            dataType: Ti.Local,
            updateNodeOpt: t,
            emitEventType: this.emitEventType,
            willRefreshSelector: !1,
            willSyncService: !0
          };
          if (s === Ii.Done) {
            const b = /* @__PURE__ */ new Map();
            G.forEach((Z) => {
              var F, Y, J;
              const r = (F = this.serviceColloctor) == null ? void 0 : F.isLocalId(Z);
              let S = r && ((Y = this.serviceColloctor) == null ? void 0 : Y.transformKey(Z)) || Z;
              const C = a[S];
              !r && ((J = this.serviceColloctor) != null && J.isOwn(S)) && (S = this.serviceColloctor.getLocalId(S)), C != null && C.ops && b.set(S, {
                ops: C.ops,
                updateNodeOpt: C.updateNodeOpt,
                opt: C.opt,
                toolsType: C.toolsType
              });
            }), c.willRefreshSelector = !0, c.selectStore = b, c.willSerializeData = !0, c.undoTickerId = this.undoTickerId;
          }
          e.push(c);
        }
        continue;
      }
      if (W) {
        const t = W.opt, c = W.updateNodeOpt || {};
        if (t && (c.angle = d, n.push({
          ...W,
          type: pi.UpdateNode,
          updateNodeOpt: c
        }), !G.includes(I))) {
          let b = I;
          !x && this.serviceColloctor.isOwn(b) && (b = this.serviceColloctor.getLocalId(b)), e.push({
            workId: b,
            msgType: pi.UpdateNode,
            dataType: Ti.Local,
            updateNodeOpt: c,
            emitEventType: this.emitEventType,
            willSyncService: !1,
            willRefresh: !0
          });
        }
      }
    }
    e.length && this.collectForLocalWorker(e), n.length && this.collectForServiceWorker(n);
  }
}
class vi {
  constructor(l) {
    Object.defineProperty(this, "builders", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: /* @__PURE__ */ new Map()
    }), this.builders = new Map(l.map((i) => [i, this.build(i)]));
  }
  build(l) {
    switch (l) {
      case Wi.TranslateNode:
        return new bW();
      case Wi.ZIndexNode:
        return new sW();
      case Wi.ZIndexActive:
        return new lW();
      case Wi.CopyNode:
        return new dW();
      case Wi.SetColorNode:
        return new tW();
      case Wi.DeleteNode:
        return new cW();
      case Wi.ScaleNode:
        return new mW();
      case Wi.RotateNode:
        return new ZW();
    }
  }
  getBuilder(l) {
    return this.builders.get(l);
  }
  registerForMainEngine(l, i, d) {
    return this.builders.forEach((s) => {
      s && s.registerForMainEngine(l, i, d);
    }), this;
  }
  destroy() {
    this.builders.forEach((l) => {
      l && l.destroy();
    });
  }
  static emitMethod(l, i, d) {
    ol.dispatch(l, i, d);
  }
}
const nW = () => {
  const { InternalMsgEmitter: m } = hl(al);
  return hi.createElement(
    "div",
    { className: "button normal-button", onClick: (l) => {
      l.preventDefault(), l.stopPropagation(), m && vi.emitMethod(ui.MainEngine, Wi.DeleteNode, { workIds: [Ci] });
    }, onTouchEnd: (l) => {
      l.stopPropagation(), m && vi.emitMethod(ui.MainEngine, Wi.DeleteNode, { workIds: [Ci] });
    } },
    hi.createElement("img", { alt: "icon", src: rl("delete") })
  );
}, eW = () => {
  const { InternalMsgEmitter: m } = hl(al);
  return hi.createElement(
    "div",
    { className: "button normal-button", onClick: (l) => {
      l.preventDefault(), l.stopPropagation(), m && vi.emitMethod(ui.MainEngine, Wi.CopyNode, { workIds: [Ci] });
    }, onTouchEnd: (l) => {
      l.stopPropagation(), m && vi.emitMethod(ui.MainEngine, Wi.CopyNode, { workIds: [Ci] });
    } },
    hi.createElement("img", { alt: "icon", src: rl("duplicate") })
  );
}, rt = (m) => {
  const { icon: l, onClickHandler: i, onTouchEndHandler: d } = m;
  return hi.createElement(
    "div",
    { className: "button normal-button", onClick: i, onTouchEnd: d },
    hi.createElement("img", { src: rl(l) })
  );
}, XW = () => {
  const { InternalMsgEmitter: m, floatBarData: l } = hl(al), [i, d] = Xl(!1), [s, X] = Xl([]), a = zl(() => i ? hi.createElement(
    "div",
    { className: "image-layer-menu" },
    hi.createElement(rt, { icon: "to-top", onClickHandler: (G) => {
      G.preventDefault(), G.stopPropagation(), m && vi.emitMethod(ui.MainEngine, Wi.ZIndexNode, { workIds: [Ci], layer: ul.Top });
    }, onTouchEndHandler: (G) => {
      G.stopPropagation(), m && vi.emitMethod(ui.MainEngine, Wi.ZIndexNode, { workIds: [Ci], layer: ul.Top });
    } }),
    hi.createElement(rt, { icon: "to-bottom", onClickHandler: (G) => {
      G.preventDefault(), G.stopPropagation(), m && vi.emitMethod(ui.MainEngine, Wi.ZIndexNode, { workIds: [Ci], layer: ul.Bottom });
    }, onTouchEndHandler: (G) => {
      G.stopPropagation(), m && vi.emitMethod(ui.MainEngine, Wi.ZIndexNode, { workIds: [Ci], layer: ul.Bottom });
    } })
  ) : null, [m, i]), e = (G) => {
    G.preventDefault(), G.stopPropagation(), G.nativeEvent.stopImmediatePropagation();
    const y = !i;
    d(y), y && m && vi.emitMethod(ui.MainEngine, Wi.ZIndexActive, { workId: Ci, isActive: y });
  }, n = (G) => {
    G.stopPropagation(), G.nativeEvent.stopImmediatePropagation();
    const y = !i;
    d(y), m && vi.emitMethod(ui.MainEngine, Wi.ZIndexActive, { workId: Ci, isActive: y });
  };
  return Ul(() => {
    fl(l == null ? void 0 : l.selectIds, s) || l != null && l.selectIds && !fl(l == null ? void 0 : l.selectIds, s) && (X(l == null ? void 0 : l.selectIds), d(!1));
  }, [m, i, l, s]), Ul(() => () => {
    i && m && vi.emitMethod(ui.MainEngine, Wi.ZIndexActive, { workId: Ci, isActive: !1 });
  }, [m, i]), hi.createElement(
    "div",
    { className: `button normal-button ${i && "active"}`, onClick: e, onTouchEnd: n },
    a,
    hi.createElement("img", { alt: "icon", src: rl(i ? "layer-pressed" : "layer") })
  );
}, oW = (m) => {
  const { color: l, opacity: i, activeColor: d, onClickHandler: s, onTouchEndHandler: X } = m;
  return hi.createElement(
    "div",
    { className: `font-color-button ${l === d ? "active" : ""}`, onClick: s, onTouchEnd: X },
    hi.createElement("div", { className: "circle", style: { backgroundColor: d && kl(l, i) } })
  );
}, aW = (m) => {
  const { opacity: l, activeColor: i, setCurOpacity: d } = m;
  if (!i)
    return null;
  const s = ji((e, n) => {
    e.preventDefault(), e.stopPropagation();
    const G = Math.min(Math.max(l * 100 + n.x, 0.01), 100) / 100;
    l !== G && d(G, Ii.Doing);
  }, 100, { leading: !1 }), X = (e) => {
    e.preventDefault(), e.stopPropagation(), d(l, Ii.Start);
  }, a = ji((e, n) => {
    e.preventDefault(), e.stopPropagation();
    const G = Math.min(Math.max(l * 100 + n.x, 0.01), 100) / 100;
    d(G, Ii.Done);
  }, 100, { leading: !1 });
  return hi.createElement(
    "div",
    { className: "font-color-opacity" },
    hi.createElement("div", { className: "range-color", style: {
      background: `linear-gradient(to right, ${kl(i, 0)}, ${kl(i, 1)})`
    } }),
    hi.createElement(
      "div",
      { className: "range-opacity" },
      hi.createElement(
        Gd,
        { bounds: "parent", axis: "x", onDrag: s, onStart: X, onStop: a },
        hi.createElement("div", { className: "circle", style: {
          left: `calc(${l * 100}% - 13px)`,
          backgroundColor: kl(i, l)
        } })
      )
    )
  );
}, WW = () => {
  const { InternalMsgEmitter: m, floatBarData: l, floatBarColors: i } = hl(al), [d, s] = Xl(!1), [X, a] = Xl(l == null ? void 0 : l.nodeColor), [e, n] = Xl((l == null ? void 0 : l.opacity) || 1);
  Ul(() => {
    l && (a(l.nodeColor), n(l.opacity || 1));
  }, [l]);
  const G = zl(() => hi.createElement(aW, { opacity: (l == null ? void 0 : l.opacity) || 1, activeColor: X, setCurOpacity: (h, I) => {
    n(h), m && vi.emitMethod(ui.MainEngine, Wi.SetColorNode, { workIds: [Ci], color: X, opacity: h, workState: I });
  } }), [m, X, l == null ? void 0 : l.opacity]), y = zl(() => d ? hi.createElement(
    "div",
    { className: "font-colors-menu", onTouchEnd: (h) => {
      h.stopPropagation(), h.nativeEvent.stopImmediatePropagation();
    }, onClick: (h) => {
      h.preventDefault(), h.stopPropagation(), h.nativeEvent.stopImmediatePropagation();
    } },
    i.map((h, I) => {
      const x = bd(...h);
      return hi.createElement(oW, { key: I, color: x, opacity: e, activeColor: X, onTouchEndHandler: (p) => {
        p.stopPropagation(), a(x), m && vi.emitMethod(ui.MainEngine, Wi.SetColorNode, { workIds: [Ci], color: x });
      }, onClickHandler: (p) => {
        p.preventDefault(), p.stopPropagation(), a(x), m && vi.emitMethod(ui.MainEngine, Wi.SetColorNode, { workIds: [Ci], color: x });
      } });
    }),
    G
  ) : null, [d, i, G, e, X, m]), o = zl(() => X && e ? hi.createElement("div", { className: "color-bar", style: { backgroundColor: kl(X, e) } }) : null, [X, e]);
  return hi.createElement(
    "div",
    { className: `button normal-button font-colors-icon ${d && "active"}`, onTouchEnd: (h) => {
      h.stopPropagation(), h.nativeEvent.stopImmediatePropagation(), s(!d);
    }, onClick: (h) => {
      h.preventDefault(), h.stopPropagation(), h.nativeEvent.stopImmediatePropagation(), s(!d);
    } },
    hi.createElement("img", { alt: "icon", src: rl("font-colors") }),
    o,
    y
  );
}, uW = hi.memo(() => {
  const { position: m } = hl(al);
  return hi.createElement(
    "div",
    { className: "bezier-pencil-plugin-floatbtns", style: m && m.y < 80 ? {
      bottom: "-120px"
    } : void 0 },
    hi.createElement(nW, null),
    hi.createElement(XW, null),
    hi.createElement(eW, null),
    hi.createElement(WW, null)
  );
}, () => !0), GW = () => {
  const [m, l] = Xl({ width: 0, height: 0 }), { floatBarData: i, InternalMsgEmitter: d, setSize: s } = hl(al);
  Ul(() => {
    i && l({ width: i.w, height: i.h });
  }, [i]);
  const X = (n, G, y) => {
    n.preventDefault(), n.stopPropagation();
    const o = y.offsetWidth, h = y.offsetHeight, I = { width: o, height: h, workState: Ii.Start };
    s(I), l(I), d && vi.emitMethod(ui.MainEngine, Wi.ScaleNode, { workIds: [Ci], size: I, workState: Ii.Start });
  }, a = ji((n, G, y) => {
    n.preventDefault(), n.stopPropagation();
    const o = y.offsetWidth, h = y.offsetHeight, I = { width: o, height: h, workState: Ii.Doing };
    (I.width !== m.width || I.height !== m.height) && (s(I), l(I), d && vi.emitMethod(ui.MainEngine, Wi.ScaleNode, { workIds: [Ci], size: I, workState: Ii.Doing }));
  }, 100, { leading: !1 }), e = (n, G, y) => {
    n.preventDefault(), n.stopPropagation();
    const o = y.offsetWidth, h = y.offsetHeight, I = { width: o, height: h, workState: Ii.Done };
    s(I), l(I), d && vi.emitMethod(ui.MainEngine, Wi.ScaleNode, { workIds: [Ci], size: I, workState: Ii.Done });
  };
  return hi.createElement(
    Vs,
    { className: "bezier-pencil-plugin-hightlight-box", boundsByDirection: !0, size: {
      width: m.width,
      height: m.height
    }, onResizeStart: X, onResize: a, onResizeStop: e },
    hi.createElement("div", { className: "point LT nwse-resize", style: { backgroundColor: i == null ? void 0 : i.color } }),
    hi.createElement("div", { className: "point LC ew-resize", style: { backgroundColor: i == null ? void 0 : i.color } }),
    hi.createElement("div", { className: "point LB nesw-resize", style: { backgroundColor: i == null ? void 0 : i.color } }),
    hi.createElement("div", { className: "point TC ns-resize", style: { backgroundColor: i == null ? void 0 : i.color } }),
    hi.createElement("div", { className: "point RT nesw-resize", style: { backgroundColor: i == null ? void 0 : i.color } }),
    hi.createElement("div", { className: "point RC ew-resize", style: { backgroundColor: i == null ? void 0 : i.color } }),
    hi.createElement("div", { className: "point RB nwse-resize", style: { backgroundColor: i == null ? void 0 : i.color } }),
    hi.createElement("div", { className: "point BC ns-resize", style: { backgroundColor: i == null ? void 0 : i.color } })
  );
}, ss = hi.forwardRef((m, l) => {
  const { floatBarData: i, zIndex: d, InternalMsgEmitter: s, position: X, showFloatBarBtn: a, angle: e, isRotating: n, setShowFloatBarBtn: G, setPosition: y } = hl(al), { className: o } = m, h = (W) => {
    W.preventDefault(), W.stopPropagation(), s && vi.emitMethod(ui.MainEngine, Wi.TranslateNode, { workIds: [Ci], position: X, workState: Ii.Start });
  }, I = ji((W, V) => {
    W.preventDefault(), W.stopPropagation(), G(!0);
    const t = { x: V.x, y: V.y };
    y(t), s && vi.emitMethod(ui.MainEngine, Wi.TranslateNode, { workIds: [Ci], position: t, workState: Ii.Done });
  }, 100, { leading: !1 }), x = ji((W, V) => {
    W.preventDefault(), W.stopPropagation(), G(!1);
    const t = { x: V.x, y: V.y };
    (V.x !== (X == null ? void 0 : X.x) || V.y !== (X == null ? void 0 : X.y)) && (y(t), s && vi.emitMethod(ui.MainEngine, Wi.TranslateNode, { workIds: [Ci], position: t, workState: Ii.Doing }));
  }, 100, { leading: !1 }), p = zl(() => a && !n ? hi.createElement(uW, null) : null, [a, n]);
  return hi.createElement(
    Gd,
    { position: X, onStart: h, onDrag: x, onStop: I, handle: "canvas" },
    hi.createElement(
      "div",
      { className: `${o}`, style: i ? {
        width: i.w,
        height: i.h,
        zIndex: d,
        pointerEvents: d < 2 ? "none" : "auto"
      } : void 0 },
      p,
      hi.createElement(
        "div",
        { className: "bezier-pencil-plugin-floatCanvas-box", style: {
          width: "100%",
          height: "100%",
          transform: `rotate(${e}deg)`
        } },
        hi.createElement("canvas", { ref: l, className: "bezier-pencil-plugin-floatCanvas" })
      ),
      !n && hi.createElement(GW, null)
    )
  );
}), bs = (m) => {
  const { className: l } = m, { floatBarData: i, InternalMsgEmitter: d, angle: s, setAngle: X, setRotateState: a, position: e, setShowRotateBtn: n } = hl(al), [G, y] = Xl(!1), [o, h] = Xl(new ki()), [I, x] = Xl(new ki());
  Ul(() => {
    if (i) {
      const t = Math.floor(i.w / 2), c = Math.floor(-i.h / 2);
      x(new ki(t, c)), h(new ki());
    }
  }, [i, e]);
  const p = (t, c) => {
    t.preventDefault(), t.stopPropagation(), y(!0);
    const b = Math.round(ki.GetAngleByPoints(o, I, new ki(c.x, c.y))) || 0;
    X(b), a(!0), d && vi.emitMethod(ui.MainEngine, Wi.RotateNode, { workIds: [Ci], angle: b, workState: Ii.Start });
  }, W = ji((t, c) => {
    t.preventDefault(), t.stopPropagation(), y(!1);
    const b = Math.round(ki.GetAngleByPoints(o, I, new ki(c.x, c.y))) || 0;
    X(b), a(!1), n(!1), d && vi.emitMethod(ui.MainEngine, Wi.RotateNode, { workIds: [Ci], angle: b, workState: Ii.Done });
  }, 100, { leading: !1 }), V = ji((t, c) => {
    t.preventDefault(), t.stopPropagation(), y(!0);
    const b = Math.round(ki.GetAngleByPoints(o, I, new ki(c.x, c.y))) || 0;
    X(b), a(!0), d && vi.emitMethod(ui.MainEngine, Wi.RotateNode, { workIds: [Ci], angle: b, workState: Ii.Doing });
  }, 100, { leading: !1 });
  return hi.createElement(
    Gd,
    { handle: ".bezier-pencil-plugin-rotate-mouse-pointer", onStart: p, onDrag: V, onStop: W },
    hi.createElement(
      "div",
      { className: `${l}`, style: e && i ? {
        left: e.x - 30,
        top: e.y + i.h + 20
      } : void 0 },
      !G && hi.createElement(
        "div",
        { className: "bezier-pencil-plugin-rotate-btn", style: { backgroundColor: i == null ? void 0 : i.color } },
        hi.createElement("img", { alt: "icon", src: rl("rotation-button") })
      ),
      hi.createElement(
        "div",
        { className: `bezier-pencil-plugin-rotate-mouse-pointer ${G ? "active" : ""}` },
        hi.createElement("img", { alt: "icon", src: rl("rotation") }),
        hi.createElement(
          "div",
          { className: "angle-icon" },
          s,
          "°"
        )
      )
    )
  );
}, VW = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADQAAAA0CAYAAADFeBvrAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAYISURBVHgB7ZpNSCtXFIBPEuvz+dMGpYUKD/sWFX+Qti6kK7Hqpm6e9q0rIoIUFUShPLV10VZx4+JZqa9v20LBhdq9fyBUCtKNPH8qYl2IOw3G38Rkek4y15y5uTOZJDOWggcOSSYzN/ebc+45554JwIM8iBCPyTEP+86T4vyMfsRN4b+nQTKIJp0vzuGvlpID7os8EQNEIBD4oKio6Bm9DwaDv/v9/n/076JgbtWUYPchwrW8qD7UnOvr6wFNkpubm+/wu7f0c7y6mrnlvQufxB0Iau7V1dX3BDA/P6/V1dVpzc3N2uLiIofK1c8VYHys/wRKBUN3/hGHqaysNOjc3FwMis6hc0FtLTHuvYLxCCZgci8uLn4wg5Gh6Fy8Jk+/NkcCAlAAuUkoW4g0B+d5tLS05O/r67O8eGxsDNra2uDy8nKsoKCAwCIQDxQa0yTxgrvCYXyTk5Ml+Orf2dlJeeHIyAigFSE/P38ELfUNqNdSkjgF5FF89jL1TU1NlQwODl5gZPujp6cHWltbUw7Koc7Pz8mkZpHPFeFrJuZeqLnoMoPoZqe0JjDP/IZgnyLUG/o8NDRkuo5Ua2pjY6MC4oFCFf1cA0oKzRSOp6enRfTaGh0d/QxBt+1CUVgnOTs7+xrHfQzGyOcKkK3QTJMnQffZ6e/v/xwttmsHqqmpKXbdycnJCxy7ABLh3FEgVZ6hZJhnFZoFFMF0d3c/w7v+dyookXBnZ2c/xvHfhriVcvXfdBRItsxjnOhYqjwjoAimq6vrCysoGofk+Ph4Esd/F/UdiFtJAGUd2DygTpp5dmBUUJ2dnc9VUALm8PDwJY7/BPU9VD8k3M4RC6kskxZMKigKIMLN9vf3p3H8DyWgfEhEOwOQD9IXOTz7EObbwsLC4YWFBRgeHrY9ECXYo6MjaGlpKWlsbPxkYGDgRW1tbSEWquVlZWXBzc3Nl1VVVa8hXiXc6ioqBqGaPDk7AACJTRZ3NS9lcUp86cJwoSQ7Pj4Op6enfxUXF3/V0NCQv7q6GsCvwrqGUG/01xAD4+VQTOxaSF43d5bBOisrGBJRCtXX17+/trb268rKSgASFgmz97KFkmo6OztWuVyPweiWGc4WRkhFRQVEIpHg8vJyQAIQVlLBROVxvBYQHsXnO8tk62ZcyN0wecLBwcEvYHSzEPscBqOLCRhLC4n9uqaA8UAWAcAKhtbQ3t7eTHl5+Y9gtAp3twhT056CDMQ7MRzIFTeTYKb1yYYVQFH9VdzsqNmYKpfTJBDX3Ixgdnd3XyHMT2AMALJlBBSPaMpNngrIsTyTCgaj288YDGakictrxizvKFNOjgSSBLS+vv6UYHDb7DgMVgsChjTEgCIKGG4ZU+EWkgNBzN1qamq+pAMTExPgFMzW1tZrhHkFyWE5KxgSszx0527RaDRmOSpRshEOU11dPQPG8CwHARHJlMnTSrwSRFIlfXt7m3V5ngJGuJtqzaQtZkFBVNJezN5ZAdmwjKo2k9tVtrcI3OXk4tPgcg7ChCDZ1URgMOu72Xa5VFHOkymQhWVU60YVmjN6wiC7k6p+S1syCACOwJBYFaexV+yhBekNPsMBO6KAEeE4BMaCU67RsoYhSbXgaT//ht709vZCaWmp6YkEbLFmVJWzas04+iBL7EKpm0J7duqu0B7+CTUpNJuyvb1NCfMj1CqI9wLKUOlOUMeG+gGFkHii4HizUF4z/KFUrPsJ8WbEIyx7nnZ0dDynME6BAuce09iFHo+GrnmGltltb2//E4wVAN82y7vOjKOZXSBhJdHNiT3TYWD8OY2PTUJkdd7MkJMnT5wZVQF2RFX6yBMUdzPMvvfqxz3sXHF+GNT9ANXit/10O1sgHkZvdQAOKvs9B5L7ARELGAAXLSTvM8QExTE+YbHe+HURhZp1aRyF4CJXClbbWwGketgkW9VsY+YaiBCVhfgE+XvxRwgZSM4jUVCDZFQ9pytmXR8hUTB2gnidx4XffVWydN0yQjwmx/jkAZJBrIBI5J7ZvQGZWUgVSuU/EqmOAzicKNMVu816DdRWUV1/7xAP8n+SfwF3Du3NF2sYhwAAAABJRU5ErkJggg==";
class hW extends cl.Component {
  constructor(l) {
    super(l), Object.defineProperty(this, "renderAvatar", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (i) => {
        var s;
        const d = `rgb(${i.memberState.strokeColor[0]}, ${i.memberState.strokeColor[1]}, ${i.memberState.strokeColor[2]})`;
        if (this.detectAvatar(i)) {
          const X = this.detectCursorName(i);
          return cl.createElement("img", { className: "cursor-selector-avatar", style: {
            width: X ? 19 : 28,
            height: X ? 19 : 28,
            position: X ? "initial" : "absolute",
            borderColor: X ? "white" : d,
            marginRight: X ? 4 : 0
          }, src: (s = i.payload) == null ? void 0 : s.avatar, alt: "avatar" });
        } else
          return null;
      }
    }), Object.defineProperty(this, "getOpacity", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (i) => {
        const d = this.getCursorName(i), s = this.detectAvatar(i);
        return d === void 0 && s === void 0 ? 0 : 1;
      }
    }), Object.defineProperty(this, "getCursorName", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (i) => {
        if (i.payload && i.payload.cursorName)
          return i.payload.cursorName;
      }
    }), Object.defineProperty(this, "getThemeClass", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (i) => i.payload && i.payload.theme ? "cursor-inner-mellow" : "cursor-inner"
    }), Object.defineProperty(this, "getCursorBackgroundColor", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (i) => {
        const d = this.detectCursorName(i);
        return i.payload && i.payload.cursorBackgroundColor ? i.payload.cursorBackgroundColor : d ? `rgb(${i.memberState.strokeColor[0]}, ${i.memberState.strokeColor[1]}, ${i.memberState.strokeColor[2]})` : void 0;
      }
    }), Object.defineProperty(this, "getCursorTextColor", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (i) => i.payload && i.payload.cursorTextColor ? i.payload.cursorTextColor : "#FFFFFF"
    }), Object.defineProperty(this, "getCursorTagBackgroundColor", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (i) => i.payload && i.payload.cursorTagBackgroundColor ? i.payload.cursorTagBackgroundColor : this.getCursorBackgroundColor(i)
    }), Object.defineProperty(this, "detectCursorName", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (i) => !!(i.payload && i.payload.cursorName)
    }), Object.defineProperty(this, "detectAvatar", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (i) => !!(i.payload && i.payload.avatar)
    }), Object.defineProperty(this, "renderTag", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (i) => {
        if (i.payload && i.payload.cursorTagName)
          return cl.createElement("span", { className: "cursor-tag-name", style: { backgroundColor: this.getCursorTagBackgroundColor(i) } }, i.payload.cursorTagName);
      }
    });
  }
  render() {
    const { roomMember: l } = this.props, i = this.getCursorName(l);
    switch (l.memberState.currentApplianceName) {
      case _i.pencil:
        return cl.createElement(
          "div",
          { className: "cursor-box" },
          cl.createElement(
            "div",
            { className: "cursor-mid cursor-pencil-offset", style: { transform: "translate(-50%, -90%)", marginLeft: "10px" } },
            cl.createElement(
              "div",
              { className: "cursor-name" },
              cl.createElement(
                "div",
                { style: {
                  opacity: this.getOpacity(l),
                  backgroundColor: this.getCursorBackgroundColor(l),
                  color: this.getCursorTextColor(l)
                }, className: this.getThemeClass(l) },
                this.renderAvatar(l),
                i,
                this.renderTag(l)
              )
            ),
            cl.createElement(
              "div",
              null,
              cl.createElement("img", { className: "cursor-pencil-image", src: VW, alt: "pencilCursor" })
            )
          )
        );
      default:
        return null;
    }
  }
}
const cs = (m) => {
  const { className: l, info: i } = m, { roomMember: d, ...s } = i || {};
  return cl.createElement("div", { className: `${l}`, style: s ? {
    transform: `translate(${s.x}px, ${s.y}px)`
  } : { display: "none" } }, d && cl.createElement(hW, { roomMember: d }));
}, al = hi.createContext({
  floatBarColors: [],
  InternalMsgEmitter: void 0,
  floatBarData: void 0,
  zIndex: -1,
  dpr: 1,
  position: void 0,
  angle: 0,
  isRotating: !1,
  showFloatBarBtn: !1,
  setPosition: () => {
  },
  setSize: () => {
  },
  setAngle: () => {
  },
  setRotateState: () => {
  },
  setShowRotateBtn: () => {
  },
  setShowFloatBarBtn: () => {
  }
});
let ll = class xl extends hi.Component {
  constructor(l) {
    super(l), Object.defineProperty(this, "containerRef", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: null
    }), Object.defineProperty(this, "canvasFloatRef", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: null
    }), Object.defineProperty(this, "canvasBgRef", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: null
    }), Object.defineProperty(this, "floatBarRef", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: null
    }), Object.defineProperty(this, "floatBarCanvasRef", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: hi.createRef()
    }), Object.defineProperty(this, "containerOffset", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: { x: 0, y: 0 }
    }), Object.defineProperty(this, "mousedown", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (i) => {
        i.button === 0 && Fi.InternalMsgEmitter.emit([ui.MainEngine, Wi.OriginalEvent], Ii.Start, [i.pageX - this.containerOffset.x, i.pageY - this.containerOffset.y]);
      }
    }), Object.defineProperty(this, "mousemove", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (i) => {
        Fi.InternalMsgEmitter.emit([ui.MainEngine, Wi.OriginalEvent], Ii.Doing, [i.pageX - this.containerOffset.x, i.pageY - this.containerOffset.y]);
      }
    }), Object.defineProperty(this, "mouseup", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (i) => {
        i.button === 0 && Fi.InternalMsgEmitter.emit([ui.MainEngine, Wi.OriginalEvent], Ii.Done, [i.pageX - this.containerOffset.x, i.pageY - this.containerOffset.y]);
      }
    }), Object.defineProperty(this, "touchstart", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (i) => {
        Fi.InternalMsgEmitter.emit([ui.MainEngine, Wi.OriginalEvent], Ii.Start, [i.targetTouches[0].pageX - this.containerOffset.x, i.targetTouches[0].pageY - this.containerOffset.y]);
      }
    }), Object.defineProperty(this, "touchmove", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ji((i) => {
        Fi.InternalMsgEmitter.emit([ui.MainEngine, Wi.OriginalEvent], Ii.Doing, [i.targetTouches[0].pageX - this.containerOffset.x, i.targetTouches[0].pageY - this.containerOffset.y]);
      }, 20, { leading: !1 })
    }), Object.defineProperty(this, "touchend", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (i) => {
        Fi.InternalMsgEmitter.emit([ui.MainEngine, Wi.OriginalEvent], Ii.Done, [i.changedTouches[0].pageX - this.containerOffset.x, i.changedTouches[0].pageY - this.containerOffset.y]);
      }
    }), Object.defineProperty(this, "cursorMouseMove", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ji((i) => {
        Fi.InternalMsgEmitter.emit([ui.Cursor, Wi.MoveCursor], [i.pageX - this.containerOffset.x, i.pageY - this.containerOffset.y]);
      }, 20, { leading: !1 })
    }), Object.defineProperty(this, "cursorMouseLeave", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ji(() => {
        Fi.InternalMsgEmitter.emit([ui.Cursor, Wi.MoveCursor], [void 0, void 0]);
      }, 20, { leading: !1 })
    }), Object.defineProperty(this, "setPosition", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (i) => {
        this.setState({ position: i });
      }
    }), Object.defineProperty(this, "setAngle", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (i) => {
        this.setState({ angle: i });
      }
    }), Object.defineProperty(this, "setRotateState", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (i) => {
        this.setState({ isRotating: i });
      }
    }), Object.defineProperty(this, "setShowRotateBtn", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (i) => {
        this.setState({ showRotateBtn: i });
      }
    }), Object.defineProperty(this, "setShowFloatBarBtn", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (i) => {
        this.setState({ showFloatBarBtn: i });
      }
    }), this.state = {
      showRotateBtn: !1,
      floatBarData: void 0,
      showFloatBar: !1,
      zIndex: -1,
      dpr: 1,
      position: void 0,
      angle: 0,
      isRotating: !1,
      showFloatBarBtn: !1,
      cursorInfo: void 0
    };
  }
  showFloatBar(l, i) {
    const d = l && i && { ...this.state.floatBarData, ...i } || void 0;
    this.setState({
      showFloatBar: l,
      floatBarData: d,
      position: i && { x: i.x, y: i.y },
      angle: 0,
      showRotateBtn: l,
      showFloatBarBtn: !0
    }), i && this.floatBarCanvasRef.current && (i.canvasHeight && i.canvasWidth ? (this.floatBarCanvasRef.current.width = i.canvasWidth * this.state.dpr, this.floatBarCanvasRef.current.height = i.canvasHeight * this.state.dpr, this.floatBarCanvasRef.current.style.width = i.canvasWidth + "px", this.floatBarCanvasRef.current.style.height = i.canvasHeight + "px") : (this.floatBarCanvasRef.current.width = i.w * this.state.dpr, this.floatBarCanvasRef.current.height = i.h * this.state.dpr, this.floatBarCanvasRef.current.style.width = "100%", this.floatBarCanvasRef.current.style.height = "100%"));
  }
  setSize(l) {
    this.state.floatBarData && this.setState({ floatBarData: { ...this.state.floatBarData, w: l.width, h: l.height } });
  }
  setFloatZIndex(l) {
    this.setState({ zIndex: l });
  }
  componentDidMount() {
    xl.instance = this, Fi.InternalMsgEmitter.on(ui.DisplayContainer, this.init.bind(this)), Fi.InternalMsgEmitter.on([ui.FloatBar, Wi.ShowFloatBar], this.showFloatBar.bind(this)), Fi.InternalMsgEmitter.on([ui.FloatBar, Wi.ZIndexFloatBar], this.setFloatZIndex.bind(this)), Fi.InternalMsgEmitter.on([ui.Cursor, Wi.ActiveCursor], this.setActiveCursor.bind(this)), Fi.InternalMsgEmitter.emit(ui.DisplayState, nl.mounted);
  }
  componentWillUnmount() {
    var i, d;
    Fi.InternalMsgEmitter.emit(ui.DisplayState, nl.unmounted);
    const l = (i = xl.instance) == null ? void 0 : i.containerRef;
    if (l) {
      const s = (d = l.parentNode) == null ? void 0 : d.children[0];
      xl.isRoom && this.removeDisplayerEvent(s);
    }
    Fi.InternalMsgEmitter.removeAllListeners();
  }
  setActiveCursor(l) {
    this.setState({ cursorInfo: l });
  }
  getRatioWithContext(l) {
    const i = l.webkitBackingStorePixelRatio || l.mozBackingStorePixelRatio || l.msBackingStorePixelRatio || l.oBackingStorePixelRatio || l.backingStorePixelRatio || 1;
    return Math.max(1, (window.devicePixelRatio || 1) / i);
  }
  init() {
    var s;
    const l = this.containerRef, i = this.canvasFloatRef, d = this.canvasBgRef;
    if (l && i && d) {
      const X = l.offsetWidth, a = l.offsetHeight;
      if (X && a) {
        i.style.width = `${X}px`, i.style.height = `${a}px`, d.style.width = `${X}px`, d.style.height = `${a}px`;
        const e = this.getRatioWithContext(d.getContext("2d"));
        if (i.width = X * e, i.height = a * e, d.width = X * e, d.height = a * e, Fi.InternalMsgEmitter.emit([ui.MainEngine, Wi.CreateScene], l.offsetWidth, l.offsetHeight, e), xl.isRoom) {
          const n = (s = l.parentNode) == null ? void 0 : s.children[0];
          n && (this.containerOffset = this.getContainerOffset(l, this.containerOffset), this.bindDisplayerEvent(n));
        }
        this.setState({ dpr: e });
      }
    }
  }
  getContainerOffset(l, i) {
    var s;
    let d = {
      x: i.x + l.offsetLeft,
      y: i.y + l.offsetTop
    };
    return (s = l.offsetParent) != null && s.nodeName && l.offsetParent.nodeName !== "BODY" && (d = this.getContainerOffset(l.offsetParent, d)), d;
  }
  bindDisplayerEvent(l) {
    l.addEventListener("mousedown", this.mousedown, !1), l.addEventListener("touchstart", this.touchstart, !1), window.addEventListener("mouseleave", this.mouseup, !1), window.addEventListener("mousemove", this.mousemove, !1), window.addEventListener("mouseup", this.mouseup, !1), window.addEventListener("touchmove", this.touchmove, !1), window.addEventListener("touchend", this.touchend, !1), l.addEventListener("mousemove", this.cursorMouseMove, !1), l.addEventListener("mouseleave", this.cursorMouseLeave, !1);
  }
  removeDisplayerEvent(l) {
    l.removeEventListener("mousedown", this.mousedown), l.removeEventListener("touchstart", this.touchstart), window.removeEventListener("mouseleave", this.mouseup), window.removeEventListener("mousemove", this.mousemove), window.removeEventListener("mouseup", this.mouseup), window.removeEventListener("touchmove", this.touchmove), window.removeEventListener("touchend", this.touchend), l.addEventListener("mousemove", this.cursorMouseMove), l.addEventListener("mouseleave", this.cursorMouseLeave);
  }
  render() {
    var l, i, d;
    return hi.createElement(
      hi.Fragment,
      null,
      this.props.children,
      hi.createElement(
        "div",
        { id: "bezier-pencil-plugin", className: dl.Container, ref: (s) => this.containerRef = s, onMouseDown: (s) => {
          s.preventDefault(), s.stopPropagation();
        }, onTouchStart: (s) => {
          s.stopPropagation();
        } },
        hi.createElement(
          "div",
          { className: dl.CanvasBox },
          hi.createElement("canvas", { id: "bezier-pencil-float-canvas", className: dl.FloatCanvas, ref: (s) => this.canvasFloatRef = s }),
          hi.createElement("canvas", { id: "bezier-pencil-bg-canvas", ref: (s) => this.canvasBgRef = s })
        ),
        hi.createElement(
          al.Provider,
          { value: {
            InternalMsgEmitter: Fi.InternalMsgEmitter,
            floatBarColors: xl.floatBarColors,
            floatBarData: this.state.floatBarData,
            zIndex: this.state.zIndex,
            dpr: this.state.dpr,
            position: this.state.position,
            angle: this.state.angle,
            isRotating: this.state.isRotating,
            showFloatBarBtn: this.state.showFloatBarBtn,
            setPosition: this.setPosition.bind(this),
            setSize: this.setSize.bind(this),
            setAngle: this.setAngle.bind(this),
            setRotateState: this.setRotateState.bind(this),
            setShowRotateBtn: this.setShowRotateBtn.bind(this),
            setShowFloatBarBtn: this.setShowFloatBarBtn.bind(this)
          } },
          this.state.showFloatBar && hi.createElement(ss, { className: dl.FloatBar, ref: this.floatBarCanvasRef }),
          this.state.showFloatBarBtn && this.state.showRotateBtn && ((i = (l = this.state.floatBarData) == null ? void 0 : l.selectIds) == null ? void 0 : i.length) === 1 && hi.createElement(bs, { className: dl.RotateBtn })
        ),
        (d = this.state.cursorInfo) == null ? void 0 : d.map((s) => s.roomMember ? hi.createElement(cs, { key: s.roomMember.memberId, className: dl.CursorBox, info: s }) : null)
      )
    );
  }
};
Object.defineProperty(ll, "isRoom", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: !0
});
Object.defineProperty(ll, "floatBarColors", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: []
});
class el extends qt {
  constructor(l, i) {
    super(), Object.defineProperty(this, "serviceStorage", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "storage", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "uid", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "plugin", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "stateDisposer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "asyncClockTimer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "namespace", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), el.syncInterval = (i || el.syncInterval) * 0.5, this.plugin = l, this.uid = l.displayer.uid, this.setNamespace(el.namespace);
  }
  addStorageStateListener(l) {
    this.stateDisposer = xt(async () => {
      const i = this.getNamespaceData(this.namespace), d = this.getDiffMap(this.serviceStorage, i);
      this.serviceStorage = i, d.size && l(d);
    });
  }
  getDiffMap(l, i) {
    const d = /* @__PURE__ */ new Map();
    for (const [s, X] of Object.entries(i))
      s !== this.uid && (X && fl(l[s], X) || X && d.set(s, X));
    return d;
  }
  removeStorageStateListener() {
    this.stateDisposer && this.stateDisposer();
  }
  transformKey(l) {
    return this.uid + Gl + l;
  }
  isOwn(l) {
    return l === this.uid;
  }
  dispatch(l) {
    const { type: i, op: d, isSync: s } = l;
    switch (i) {
      case Ll.Cursor:
        d && this.pushValue(this.uid, {
          type: Ll.Cursor,
          op: d
        }, { isSync: s });
        break;
    }
  }
  pushValue(l, i, d) {
    var s;
    this.storage[l] || (this.storage[l] = []), (s = this.storage[l]) == null || s.push(i), this.runSyncService(d);
  }
  clearValue(l) {
    var d;
    this.storage[l] = void 0, Object.keys(this.serviceStorage).length && ((d = this.plugin) == null || d.updateAttributes([this.namespace, l], void 0));
  }
  runSyncService(l) {
    this.asyncClockTimer || (this.asyncClockTimer = setTimeout(() => {
      l != null && l.isSync ? (this.asyncClockTimer = void 0, this.syncSerivice()) : sd(() => {
        this.asyncClockTimer = void 0, this.syncSerivice();
      }, el.syncInterval);
    }, l != null && l.isSync ? 0 : el.syncInterval));
  }
  syncSerivice() {
    var i;
    Object.keys(this.serviceStorage).length ? Object.keys(this.storage).forEach((d) => {
      var s;
      (s = this.plugin) == null || s.updateAttributes([this.namespace, d], this.storage[d]);
    }) : (i = this.plugin) == null || i.updateAttributes(this.namespace, this.storage), this.storage = {};
  }
  destroy() {
    this.removeStorageStateListener(), this.plugin = void 0, this.storage = {}, this.serviceStorage = {}, this.namespace = "";
  }
}
Object.defineProperty(el, "syncInterval", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 500
});
Object.defineProperty(el, "namespace", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "PluginEvent"
});
var Yt;
(function(m) {
  m[m.Event = 0] = "Event", m[m.Storage = 1] = "Storage";
})(Yt || (Yt = {}));
class ms {
  constructor(l, i, d) {
    Object.defineProperty(this, "eventCollector", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "plugin", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "roomMember", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "animationId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "removeTimerId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "animationPointWorkers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: /* @__PURE__ */ new Map()
    }), Object.defineProperty(this, "animationDrawWorkers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: /* @__PURE__ */ new Map()
    }), Object.defineProperty(this, "worker", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.plugin = l, this.roomMember = i, this.eventCollector = new el(l, d), this.eventCollector.addStorageStateListener((s) => {
      s.forEach((X, a) => {
        if (this.eventCollector.uid !== a) {
          const e = [];
          X == null || X.forEach((n) => {
            var G;
            if (n && n.type === Ll.Cursor && n.op) {
              const y = [];
              for (let o = 0; o < n.op.length; o += 2) {
                const h = n.op[o], I = n.op[o + 1];
                if (bl(h) && bl(I)) {
                  const x = ((G = this.worker) == null ? void 0 : G.transformToOriginPoint([h, I])) || [h, I];
                  y.push(...x);
                } else
                  y.push(h, I);
              }
              e.push(...y);
            }
          }), e.length && (this.activePointWorkShape(a, e), this.runAnimation(), this.removeTimerId && (clearTimeout(this.removeTimerId), this.removeTimerId = void 0));
        }
      });
    });
  }
  injectWorker(l) {
    this.worker = l;
  }
  sendEvent(l) {
    var i;
    this.eventCollector.dispatch({
      type: Ll.Cursor,
      op: bl(l[0]) && bl(l[1]) && ((i = this.worker) == null ? void 0 : i.transformToScenePoint(l)) || l
    });
  }
  collectServiceCursor(l) {
    var X;
    const { op: i, uid: d, workState: s } = l;
    if (d && i && s) {
      this.removeTimerId && (clearTimeout(this.removeTimerId), this.removeTimerId = void 0);
      const a = bl(i[0]) && bl(i[1]) && ((X = this.worker) == null ? void 0 : X.transformToOriginPoint(i)) || i;
      this.activeDrawWorkShape(d, a, s), this.runAnimation(), s === Ii.Done && !this.removeTimerId && (this.removeTimerId = setTimeout(() => {
        this.removeTimerId = void 0, this.activeDrawWorkShape(d, [void 0, void 0], Ii.Done), this.runAnimation();
      }, 3e3));
    }
  }
  activePointWorkShape(l, i) {
    var a;
    if (!this.roomMember.getRoomMember(l))
      return;
    const s = this.animationDrawWorkers.get(l), X = this.animationPointWorkers.get(l);
    if (!X && i) {
      const e = {
        animationIndex: 0,
        animationWorkData: i,
        freeze: (s == null ? void 0 : s.workState) === Ii.Start || (s == null ? void 0 : s.workState) === Ii.Doing
      };
      (a = this.animationPointWorkers) == null || a.set(l, e);
      return;
    }
    X && i && (X.animationWorkData = i, X.animationIndex = 0, X.freeze = (s == null ? void 0 : s.workState) === Ii.Start || (s == null ? void 0 : s.workState) === Ii.Doing);
  }
  activeDrawWorkShape(l, i, d) {
    var a, e;
    if (!this.roomMember.getRoomMember(l))
      return;
    if (d === Ii.Start) {
      const n = this.animationPointWorkers.get(l);
      if (n)
        n.animationWorkData = [], n.animationIndex = 0, n.freeze = !0;
      else {
        const G = {
          animationIndex: 0,
          animationWorkData: [],
          freeze: !0
        };
        (a = this.animationDrawWorkers) == null || a.set(l, G);
      }
    } else if (d === Ii.Done) {
      const n = this.animationPointWorkers.get(l);
      n && (n.freeze = !1);
    }
    const X = this.animationDrawWorkers.get(l);
    if (!X && i) {
      const n = {
        animationIndex: 0,
        animationWorkData: i,
        workState: d
      };
      (e = this.animationDrawWorkers) == null || e.set(l, n);
      return;
    }
    X && i && (X.animationWorkData = i, X.animationIndex = 0, X.workState = d);
  }
  animationCursor() {
    this.animationId = void 0;
    const l = /* @__PURE__ */ new Map();
    this.animationPointWorkers.forEach((i, d) => {
      if (i.freeze)
        return;
      const X = i.animationIndex, a = this.roomMember.getRoomMember(d);
      if (a) {
        i.animationWorkData.length - 1 > X && (i.animationIndex = X + 2);
        const e = i.animationWorkData[X], n = i.animationWorkData[X + 1];
        l.set(d, {
          x: e,
          y: n,
          roomMember: bl(e) && bl(n) && a || void 0
        }), i.animationWorkData.length - 1 <= i.animationIndex && this.animationPointWorkers.delete(d);
      }
    }), this.animationDrawWorkers.forEach((i, d) => {
      const s = i.animationIndex, X = this.roomMember.getRoomMember(d);
      if (X) {
        i.animationWorkData.length - 1 > s && (i.animationIndex = s + 2);
        const a = i.animationWorkData[s], e = i.animationWorkData[s + 1];
        l.set(d, {
          x: a,
          y: e,
          roomMember: bl(a) && bl(e) && X || void 0
        }), i.animationWorkData.length - 1 <= i.animationIndex && this.animationDrawWorkers.delete(d);
      }
    }), Fi.InternalMsgEmitter.emit([ui.Cursor, Wi.ActiveCursor], [...l.values()]), (this.animationPointWorkers.size || this.animationDrawWorkers.size) && this.runAnimation();
  }
  runAnimation() {
    this.animationId || (this.animationId = requestAnimationFrame(this.animationCursor.bind(this)));
  }
  unable() {
    this.eventCollector.dispatch({
      type: Ll.Cursor,
      op: [void 0, void 0]
    });
  }
  destroy() {
    this.eventCollector.destroy();
  }
}
class Zs {
  constructor() {
    Object.defineProperty(this, "roomMembers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "onChangeHooks", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: /* @__PURE__ */ new Set()
    });
  }
  setRoomMembers(l) {
    this.executChangeUidHook(this.roomMembers, l), this.roomMembers = l;
  }
  executChangeUidHook(l, i) {
    const d = {
      online: i.map((s) => {
        var X;
        return ((X = s.payload) == null ? void 0 : X.uid) || s.session;
      }),
      offline: l.map((s) => {
        var X;
        return ((X = s.payload) == null ? void 0 : X.uid) || s.session;
      })
    };
    this.onChangeHooks.forEach((s) => s(d));
  }
  getRoomMember(l) {
    return this.roomMembers.find((i) => {
      var d;
      return ((d = i.payload) == null ? void 0 : d.uid) === l;
    });
  }
  isOnLine(l) {
    return !this.getRoomMember(l);
  }
  onUidChangeHook(l) {
    this.onChangeHooks.add(l);
  }
  destroy() {
    this.onChangeHooks.clear();
  }
}
let Fi = class il {
  constructor(l, i) {
    Object.defineProperty(this, "plugin", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "pluginOptions", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "collector", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "worker", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "room", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "cursor", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "roomMember", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "isDelayMount", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "commiter", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "onCameraChange", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ji((d) => {
        var s;
        (s = this.worker) == null || s.setCameraOpt(vl(d));
      }, 20, { leading: !1 })
    }), Object.defineProperty(this, "onSceneChange", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ji((d) => {
        var s, X;
        (s = this.collector) == null || s.setNamespace(d.scenePath), this.room && ((X = this.worker) == null || X.clearAll(!0).then(() => {
          var a;
          (a = this.worker) == null || a.initSyncData();
        }));
      }, 100, { leading: !1 })
    }), Object.defineProperty(this, "onMemberChange", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ji((d) => {
        var e, n, G, y, o, h, I, x, p, W, V, t, c;
        if (!this.room || !this.worker)
          return;
        const s = d.currentApplianceName, X = s === _i.pencil && d.useLaserPen ? ri.LaserPen : s === _i.eraser || s === _i.pencilEraser ? ri.Eraser : s === _i.pencil && d.useNewPencil ? ri.Pencil : s === _i.selector ? ri.Selector : ri.Clicker, a = {
          color: bd(d.strokeColor[0], d.strokeColor[1], d.strokeColor[2]),
          opacity: (d == null ? void 0 : d.strokeOpacity) || 1
        };
        if (X === ri.Pencil ? (a.thickness = d.strokeWidth, a.strokeType = (d == null ? void 0 : d.strokeType) || ml.Normal) : X === ri.Eraser ? (a.thickness = Math.min(3, Math.max(1, Math.floor(d.pencilEraserSize || 1))) - 1, a.isLine = s === _i.eraser && !0) : X === ri.LaserPen && (a.thickness = d.strokeWidth, a.duration = (d == null ? void 0 : d.duration) || 1, a.strokeType = (d == null ? void 0 : d.strokeType) || ml.Normal), (e = this.worker) == null || e.setCurrentToolsData({
          toolsType: X,
          toolsOpt: a
        }), X === ri.Selector ? ((n = il.InternalMsgEmitter) == null || n.on([ui.MainEngine, Wi.TranslateNode], this.linstenerSelector.bind(this)), (G = il.InternalMsgEmitter) == null || G.on([ui.MainEngine, Wi.SetColorNode], this.linstenerSelector.bind(this)), (y = il.InternalMsgEmitter) == null || y.on([ui.MainEngine, Wi.ScaleNode], this.linstenerSelector.bind(this)), (o = il.InternalMsgEmitter) == null || o.on([ui.MainEngine, Wi.RotateNode], this.linstenerSelector.bind(this))) : ((h = il.InternalMsgEmitter) == null || h.off([ui.MainEngine, Wi.TranslateNode], this.linstenerSelector.bind(this)), (I = il.InternalMsgEmitter) == null || I.off([ui.MainEngine, Wi.SetColorNode], this.linstenerSelector.bind(this)), (x = il.InternalMsgEmitter) == null || x.off([ui.MainEngine, Wi.ScaleNode], this.linstenerSelector.bind(this)), (p = il.InternalMsgEmitter) == null || p.off([ui.MainEngine, Wi.RotateNode], this.linstenerSelector.bind(this))), X === ri.Eraser || X === ri.Pencil || X === ri.LaserPen || X === ri.Selector) {
          X === ri.Pencil || X === ri.LaserPen ? (this.room.disableDeviceInputs = !0, setTimeout(() => {
            var Z, r;
            const b = (r = (Z = ll.instance.containerRef) == null ? void 0 : Z.parentNode) == null ? void 0 : r.children[0];
            b && (b.className = b.className + " cursor-pencil");
          }, 0)) : (this.room.disableDeviceInputs = !1, (W = this.cursor) == null || W.unable()), (V = this.worker) == null || V.abled();
          return;
        }
        this.room.disableDeviceInputs = !1, (t = this.worker) == null || t.unabled(), (c = this.cursor) == null || c.unable();
      }, 100, { leading: !1 })
    }), Object.defineProperty(this, "onRoomMembersChange", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (d) => {
        this.roomMember.setRoomMembers(vl(d));
      }
    }), this.plugin = l, this.room = Oi(l.displayer) ? l.displayer : void 0, this.pluginOptions = i, this.roomMember = new Zs();
  }
  init() {
    var l, i;
    ll.isRoom = !!this.room, ll.floatBarColors = ((i = (l = this.room) == null ? void 0 : l.floatBarOptions) == null ? void 0 : i.colors) || [], il.InternalMsgEmitter.on(ui.DisplayState, this.displayStateListener.bind(this)), ll.instance ? (this.onMountDisplayer(), il.InternalMsgEmitter.emit(ui.DisplayContainer, !0), this.isDelayMount = !1) : this.isDelayMount = !0;
  }
  async getBoundingRect(l) {
    var d;
    const i = await ((d = this.worker) == null ? void 0 : d.getBoundingRect(l));
    if (i)
      return {
        width: i.w,
        height: i.h,
        originX: i.x,
        originY: i.y
      };
  }
  async screenshotToCanvas(l, i, d, s, X) {
    var e;
    const a = await ((e = this.worker) == null ? void 0 : e.getSnapshot(i, d, s, X));
    a && (l.drawImage(a, 0, 0), a.close());
  }
  async scenePreview(l, i) {
    var s;
    const d = await ((s = this.worker) == null ? void 0 : s.getSnapshot(l));
    if (d && this.worker) {
      const X = document.createElement("canvas"), a = X.getContext("2d"), { width: e, height: n } = this.worker.getCameraOpt();
      X.width = e, X.height = n, a && (a.drawImage(d, 0, 0), i.src = X.toDataURL(), i.onload = () => {
        X.remove();
      }, i.onerror = () => {
        X.remove(), i.remove();
      }), d.close();
    }
  }
  cleanCurrentScene() {
    var l;
    (l = this.worker) == null || l.clearAll();
  }
  destroy() {
    this.onUnMountDisplayer();
  }
  displayStateListener(l) {
    this.isDelayMount && l === nl.mounted && (this.onMountDisplayer(), il.InternalMsgEmitter.emit(ui.DisplayContainer, !0)), l === nl.unmounted && this.onUnMountDisplayer();
  }
  linstenerSelector(l) {
    this.room && l.workState === Ii.Start ? this.room.disableDeviceInputs = !0 : this.room && l.workState === Ii.Done && (this.room.disableDeviceInputs = !1);
  }
  onWritableChange(l) {
    var i, d;
    l ? (d = this.worker) == null || d.abled() : (i = this.worker) == null || i.unabled();
  }
  onMountDisplayer() {
    var s, X, a, e, n, G, y;
    const l = (s = ll.instance) == null ? void 0 : s.containerRef, i = (X = ll.instance) == null ? void 0 : X.canvasFloatRef, d = (a = ll.instance) == null ? void 0 : a.canvasBgRef;
    i && d && l && (this.collector = new Vl(this.plugin, (n = (e = this.pluginOptions) == null ? void 0 : e.syncOpt) == null ? void 0 : n.interval), this.cursor = new ms(this.plugin, this.roomMember, (y = (G = this.pluginOptions) == null ? void 0 : G.syncOpt) == null ? void 0 : y.interval), this.worker = new $i(this.collector, this.cursor, this.pluginOptions), this.commiter = this.room && new Ki(this.room, this.worker, this.collector), this.collector.addStorageStateListener((o) => {
      var h, I;
      if (o) {
        if ((h = this.collector) != null && h.storage && Object.keys(this.collector.storage).length === 0) {
          (I = this.worker) == null || I.clearAll(!0);
          return;
        }
        if (this.worker) {
          const x = this.worker.getRelevantWork(o);
          Object.keys(o).forEach((p) => {
            var V;
            const W = o[p];
            W && ((V = this.worker) == null || V.onServiceDerive(p, W, x));
          }), Ki.emitter.emit("excludeIds", Object.keys(o));
        }
      }
    }), this.cursor.injectWorker(this.worker), this.room && (this.roomMember.onUidChangeHook((o) => {
      var h, I, x;
      (h = this.collector) != null && h.serviceStorage && Object.keys(this.collector.serviceStorage).filter((W) => {
        var V;
        return (V = this.collector) == null ? void 0 : V.isSelector(W);
      }).forEach((W) => {
        var t, c;
        const V = (t = this.collector) == null ? void 0 : t.getUidFromKey(W);
        V && !o.online.includes(V) && ((c = this.collector) == null || c.updateValue(W, void 0, { isAfterUpdate: !0 }));
      }), (I = this.cursor) != null && I.eventCollector.serviceStorage && Object.keys((x = this.cursor) == null ? void 0 : x.eventCollector.serviceStorage).forEach((W) => {
        var V;
        o.online.includes(W) || (V = this.cursor) == null || V.eventCollector.clearValue(W);
      });
    }), this.worker.initSyncData()));
  }
  onUnMountDisplayer() {
    var l, i, d, s;
    this.roomMember.destroy(), (l = this.collector) == null || l.destroy(), this.collector = void 0, (i = this.worker) == null || i.destroy(), this.worker = void 0, (d = this.commiter) == null || d.destroy(), this.commiter = void 0, (s = this.cursor) == null || s.destroy(), this.cursor = void 0;
  }
};
Object.defineProperty(Fi, "InternalMsgEmitter", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: new Vd()
});
const IW = hi.createContext({
  floatBarColors: [],
  InternalMsgEmitter: void 0,
  floatBarData: void 0,
  zIndex: -1,
  dpr: 1,
  position: void 0,
  angle: 0,
  isRotating: !1,
  showFloatBarBtn: !1,
  setPosition: () => {
  },
  setSize: () => {
  },
  setAngle: () => {
  },
  setRotateState: () => {
  },
  setShowRotateBtn: () => {
  },
  setShowFloatBarBtn: () => {
  }
});
class Ai extends hi.Component {
  constructor(l) {
    super(l), Object.defineProperty(this, "containerRef", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: null
    }), Object.defineProperty(this, "canvasFloatRef", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: null
    }), Object.defineProperty(this, "canvasBgRef", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: null
    }), Object.defineProperty(this, "floatBarRef", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: null
    }), Object.defineProperty(this, "floatBarCanvasRef", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: hi.createRef()
    }), Object.defineProperty(this, "containerOffset", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: { x: 0, y: 0 }
    }), Object.defineProperty(this, "mousedown", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (i) => {
        i.button === 0 && gi.InternalMsgEmitter.emit([ui.MainEngine, Wi.OriginalEvent], Ii.Start, [i.pageX - this.containerOffset.x, i.pageY - this.containerOffset.y]);
      }
    }), Object.defineProperty(this, "mousemove", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (i) => {
        gi.InternalMsgEmitter.emit([ui.MainEngine, Wi.OriginalEvent], Ii.Doing, [i.pageX - this.containerOffset.x, i.pageY - this.containerOffset.y]);
      }
    }), Object.defineProperty(this, "mouseup", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (i) => {
        i.button === 0 && gi.InternalMsgEmitter.emit([ui.MainEngine, Wi.OriginalEvent], Ii.Done, [i.pageX - this.containerOffset.x, i.pageY - this.containerOffset.y]);
      }
    }), Object.defineProperty(this, "touchstart", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (i) => {
        gi.InternalMsgEmitter.emit([ui.MainEngine, Wi.OriginalEvent], Ii.Start, [i.targetTouches[0].pageX - this.containerOffset.x, i.targetTouches[0].pageY - this.containerOffset.y]);
      }
    }), Object.defineProperty(this, "touchmove", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ji((i) => {
        gi.InternalMsgEmitter.emit([ui.MainEngine, Wi.OriginalEvent], Ii.Doing, [i.targetTouches[0].pageX - this.containerOffset.x, i.targetTouches[0].pageY - this.containerOffset.y]);
      }, 20, { leading: !1 })
    }), Object.defineProperty(this, "touchend", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (i) => {
        gi.InternalMsgEmitter.emit([ui.MainEngine, Wi.OriginalEvent], Ii.Done, [i.changedTouches[0].pageX - this.containerOffset.x, i.changedTouches[0].pageY - this.containerOffset.y]);
      }
    }), Object.defineProperty(this, "cursorMouseMove", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ji((i) => {
        gi.InternalMsgEmitter.emit([ui.Cursor, Wi.MoveCursor], [i.pageX - this.containerOffset.x, i.pageY - this.containerOffset.y]);
      }, 20, { leading: !1 })
    }), Object.defineProperty(this, "cursorMouseLeave", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ji(() => {
        gi.InternalMsgEmitter.emit([ui.Cursor, Wi.MoveCursor], [void 0, void 0]);
      }, 20, { leading: !1 })
    }), Object.defineProperty(this, "setPosition", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (i) => {
        this.setState({ position: i });
      }
    }), Object.defineProperty(this, "setAngle", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (i) => {
        this.setState({ angle: i });
      }
    }), Object.defineProperty(this, "setRotateState", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (i) => {
        this.setState({ isRotating: i });
      }
    }), Object.defineProperty(this, "setShowRotateBtn", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (i) => {
        this.setState({ showRotateBtn: i });
      }
    }), Object.defineProperty(this, "setShowFloatBarBtn", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (i) => {
        this.setState({ showFloatBarBtn: i });
      }
    }), this.state = {
      showRotateBtn: !1,
      floatBarData: void 0,
      showFloatBar: !1,
      zIndex: -1,
      dpr: 1,
      position: void 0,
      angle: 0,
      isRotating: !1,
      showFloatBarBtn: !1,
      cursorInfo: void 0
    };
  }
  showFloatBar(l, i) {
    const d = l && i && { ...this.state.floatBarData, ...i } || void 0;
    this.setState({
      showFloatBar: l,
      floatBarData: d,
      position: i && { x: i.x, y: i.y },
      angle: 0,
      showRotateBtn: l,
      showFloatBarBtn: !0
    }), i && this.floatBarCanvasRef.current && (i.canvasHeight && i.canvasWidth ? (this.floatBarCanvasRef.current.width = i.canvasWidth * this.state.dpr, this.floatBarCanvasRef.current.height = i.canvasHeight * this.state.dpr, this.floatBarCanvasRef.current.style.width = i.canvasWidth + "px", this.floatBarCanvasRef.current.style.height = i.canvasHeight + "px") : (this.floatBarCanvasRef.current.width = i.w * this.state.dpr, this.floatBarCanvasRef.current.height = i.h * this.state.dpr, this.floatBarCanvasRef.current.style.width = "100%", this.floatBarCanvasRef.current.style.height = "100%"));
  }
  setSize(l) {
    this.state.floatBarData && this.setState({ floatBarData: { ...this.state.floatBarData, w: l.width, h: l.height } });
  }
  setFloatZIndex(l) {
    this.setState({ zIndex: l });
  }
  componentDidMount() {
    Ai.instance = this, gi.InternalMsgEmitter.on(ui.DisplayContainer, this.init.bind(this)), gi.InternalMsgEmitter.on([ui.FloatBar, Wi.ShowFloatBar], this.showFloatBar.bind(this)), gi.InternalMsgEmitter.on([ui.FloatBar, Wi.ZIndexFloatBar], this.setFloatZIndex.bind(this)), gi.InternalMsgEmitter.on([ui.Cursor, Wi.ActiveCursor], this.setActiveCursor.bind(this)), gi.InternalMsgEmitter.emit(ui.DisplayState, nl.mounted);
  }
  componentWillUnmount() {
    var i, d;
    gi.InternalMsgEmitter.emit(ui.DisplayState, nl.unmounted);
    const l = (i = Ai.instance) == null ? void 0 : i.containerRef;
    if (l) {
      const s = (d = l.parentNode) == null ? void 0 : d.children[0];
      Ai.isRoom && this.removeDisplayerEvent(s);
    }
    gi.InternalMsgEmitter.removeAllListeners();
  }
  setActiveCursor(l) {
    this.setState({ cursorInfo: l });
  }
  getRatioWithContext(l) {
    const i = l.webkitBackingStorePixelRatio || l.mozBackingStorePixelRatio || l.msBackingStorePixelRatio || l.oBackingStorePixelRatio || l.backingStorePixelRatio || 1;
    return Math.max(1, (window.devicePixelRatio || 1) / i);
  }
  init() {
    var s;
    const l = this.containerRef, i = this.canvasFloatRef, d = this.canvasBgRef;
    if (l && i && d) {
      const X = l.offsetWidth, a = l.offsetHeight;
      if (X && a) {
        i.style.width = `${X}px`, i.style.height = `${a}px`, d.style.width = `${X}px`, d.style.height = `${a}px`;
        const e = this.getRatioWithContext(d.getContext("2d"));
        if (i.width = X * e, i.height = a * e, d.width = X * e, d.height = a * e, gi.InternalMsgEmitter.emit([ui.MainEngine, Wi.CreateScene], l.offsetWidth, l.offsetHeight, e), Ai.isRoom) {
          const n = (s = l.parentNode) == null ? void 0 : s.children[0];
          n && (this.containerOffset = this.getContainerOffset(l, this.containerOffset), this.bindDisplayerEvent(n));
        }
        this.setState({ dpr: e });
      }
    }
  }
  getContainerOffset(l, i) {
    var s;
    let d = {
      x: i.x + l.offsetLeft,
      y: i.y + l.offsetTop
    };
    return (s = l.offsetParent) != null && s.nodeName && l.offsetParent.nodeName !== "BODY" && (d = this.getContainerOffset(l.offsetParent, d)), d;
  }
  bindDisplayerEvent(l) {
    l.addEventListener("mousedown", this.mousedown, !1), l.addEventListener("touchstart", this.touchstart, !1), window.addEventListener("mouseleave", this.mouseup, !1), window.addEventListener("mousemove", this.mousemove, !1), window.addEventListener("mouseup", this.mouseup, !1), window.addEventListener("touchmove", this.touchmove, !1), window.addEventListener("touchend", this.touchend, !1), l.addEventListener("mousemove", this.cursorMouseMove, !1), l.addEventListener("mouseleave", this.cursorMouseLeave, !1);
  }
  removeDisplayerEvent(l) {
    l.removeEventListener("mousedown", this.mousedown), l.removeEventListener("touchstart", this.touchstart), window.removeEventListener("mouseleave", this.mouseup), window.removeEventListener("mousemove", this.mousemove), window.removeEventListener("mouseup", this.mouseup), window.removeEventListener("touchmove", this.touchmove), window.removeEventListener("touchend", this.touchend), l.addEventListener("mousemove", this.cursorMouseMove), l.addEventListener("mouseleave", this.cursorMouseLeave);
  }
  render() {
    var l, i, d;
    return hi.createElement(
      hi.Fragment,
      null,
      this.props.children,
      hi.createElement(
        "div",
        { id: "bezier-pencil-plugin", className: dl.Container, ref: (s) => this.containerRef = s, onMouseDown: (s) => {
          s.preventDefault(), s.stopPropagation();
        }, onTouchStart: (s) => {
          s.stopPropagation();
        } },
        hi.createElement(
          "div",
          { className: dl.CanvasBox },
          hi.createElement("canvas", { id: "bezier-pencil-float-canvas", className: dl.FloatCanvas, ref: (s) => this.canvasFloatRef = s }),
          hi.createElement("canvas", { id: "bezier-pencil-bg-canvas", ref: (s) => this.canvasBgRef = s })
        ),
        hi.createElement(
          IW.Provider,
          { value: {
            InternalMsgEmitter: gi.InternalMsgEmitter,
            floatBarColors: Ai.floatBarColors,
            floatBarData: this.state.floatBarData,
            zIndex: this.state.zIndex,
            dpr: this.state.dpr,
            position: this.state.position,
            angle: this.state.angle,
            isRotating: this.state.isRotating,
            showFloatBarBtn: this.state.showFloatBarBtn,
            setPosition: this.setPosition.bind(this),
            setSize: this.setSize.bind(this),
            setAngle: this.setAngle.bind(this),
            setRotateState: this.setRotateState.bind(this),
            setShowRotateBtn: this.setShowRotateBtn.bind(this),
            setShowFloatBarBtn: this.setShowFloatBarBtn.bind(this)
          } },
          this.state.showFloatBar && hi.createElement(ss, { className: dl.FloatBar, ref: this.floatBarCanvasRef }),
          this.state.showFloatBarBtn && this.state.showRotateBtn && ((i = (l = this.state.floatBarData) == null ? void 0 : l.selectIds) == null ? void 0 : i.length) === 1 && hi.createElement(bs, { className: dl.RotateBtn })
        ),
        (d = this.state.cursorInfo) == null ? void 0 : d.map((s) => s.roomMember ? hi.createElement(cs, { key: s.roomMember.memberId, className: dl.CursorBox, info: s }) : null)
      )
    );
  }
}
Object.defineProperty(Ai, "isRoom", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: !0
});
Object.defineProperty(Ai, "floatBarColors", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: []
});
class gi {
  constructor(l, i) {
    Object.defineProperty(this, "plugin", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "pluginOptions", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "collector", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "worker", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "room", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "cursor", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "roomMember", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "isDelayMount", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "commiter", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "onCameraChange", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ji((d) => {
        var s;
        (s = this.worker) == null || s.setCameraOpt(vl(d));
      }, 20, { leading: !1 })
    }), Object.defineProperty(this, "onSceneChange", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ji((d) => {
        var s, X;
        (s = this.collector) == null || s.setNamespace(d.scenePath), this.room && ((X = this.worker) == null || X.clearAll(!0).then(() => {
          var a;
          (a = this.worker) == null || a.initSyncData();
        }));
      }, 100, { leading: !1 })
    }), Object.defineProperty(this, "onMemberChange", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ji((d) => {
        var e, n, G, y, o, h, I, x, p, W, V, t, c;
        if (!this.room || !this.worker)
          return;
        const s = d.currentApplianceName, X = s === _i.pencil && d.useLaserPen ? ri.LaserPen : s === _i.eraser || s === _i.pencilEraser ? ri.Eraser : s === _i.pencil && d.useNewPencil ? ri.Pencil : s === _i.selector ? ri.Selector : ri.Clicker, a = {
          color: bd(d.strokeColor[0], d.strokeColor[1], d.strokeColor[2]),
          opacity: (d == null ? void 0 : d.strokeOpacity) || 1
        };
        if (X === ri.Pencil ? (a.thickness = d.strokeWidth, a.strokeType = (d == null ? void 0 : d.strokeType) || ml.Normal) : X === ri.Eraser ? (a.thickness = Math.min(3, Math.max(1, Math.floor(d.pencilEraserSize || 1))) - 1, a.isLine = s === _i.eraser && !0) : X === ri.LaserPen && (a.thickness = d.strokeWidth, a.duration = (d == null ? void 0 : d.duration) || 1, a.strokeType = (d == null ? void 0 : d.strokeType) || ml.Normal), (e = this.worker) == null || e.setCurrentToolsData({
          toolsType: X,
          toolsOpt: a
        }), X === ri.Selector ? ((n = gi.InternalMsgEmitter) == null || n.on([ui.MainEngine, Wi.TranslateNode], this.linstenerSelector.bind(this)), (G = gi.InternalMsgEmitter) == null || G.on([ui.MainEngine, Wi.SetColorNode], this.linstenerSelector.bind(this)), (y = gi.InternalMsgEmitter) == null || y.on([ui.MainEngine, Wi.ScaleNode], this.linstenerSelector.bind(this)), (o = gi.InternalMsgEmitter) == null || o.on([ui.MainEngine, Wi.RotateNode], this.linstenerSelector.bind(this))) : ((h = gi.InternalMsgEmitter) == null || h.off([ui.MainEngine, Wi.TranslateNode], this.linstenerSelector.bind(this)), (I = gi.InternalMsgEmitter) == null || I.off([ui.MainEngine, Wi.SetColorNode], this.linstenerSelector.bind(this)), (x = gi.InternalMsgEmitter) == null || x.off([ui.MainEngine, Wi.ScaleNode], this.linstenerSelector.bind(this)), (p = gi.InternalMsgEmitter) == null || p.off([ui.MainEngine, Wi.RotateNode], this.linstenerSelector.bind(this))), X === ri.Eraser || X === ri.Pencil || X === ri.LaserPen || X === ri.Selector) {
          X === ri.Pencil || X === ri.LaserPen ? (this.room.disableDeviceInputs = !0, setTimeout(() => {
            var Z, r;
            const b = (r = (Z = Ai.instance.containerRef) == null ? void 0 : Z.parentNode) == null ? void 0 : r.children[0];
            b && (b.className = b.className + " cursor-pencil");
          }, 0)) : (this.room.disableDeviceInputs = !1, (W = this.cursor) == null || W.unable()), (V = this.worker) == null || V.abled();
          return;
        }
        this.room.disableDeviceInputs = !1, (t = this.worker) == null || t.unabled(), (c = this.cursor) == null || c.unable();
      }, 100, { leading: !1 })
    }), Object.defineProperty(this, "onRoomMembersChange", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (d) => {
        this.roomMember.setRoomMembers(vl(d));
      }
    }), this.plugin = l, this.room = Oi(l.displayer) ? l.displayer : void 0, this.pluginOptions = i, this.roomMember = new Zs();
  }
  init() {
    var l, i;
    Ai.isRoom = !!this.room, Ai.floatBarColors = ((i = (l = this.room) == null ? void 0 : l.floatBarOptions) == null ? void 0 : i.colors) || [], gi.InternalMsgEmitter.on(ui.DisplayState, this.displayStateListener.bind(this)), Ai.instance ? (this.onMountDisplayer(), gi.InternalMsgEmitter.emit(ui.DisplayContainer, !0), this.isDelayMount = !1) : this.isDelayMount = !0;
  }
  async getBoundingRect(l) {
    var d;
    const i = await ((d = this.worker) == null ? void 0 : d.getBoundingRect(l));
    if (i)
      return {
        width: i.w,
        height: i.h,
        originX: i.x,
        originY: i.y
      };
  }
  async screenshotToCanvas(l, i, d, s, X) {
    var e;
    const a = await ((e = this.worker) == null ? void 0 : e.getSnapshot(i, d, s, X));
    a && (l.drawImage(a, 0, 0), a.close());
  }
  async scenePreview(l, i) {
    var s;
    const d = await ((s = this.worker) == null ? void 0 : s.getSnapshot(l));
    if (d && this.worker) {
      const X = document.createElement("canvas"), a = X.getContext("2d"), { width: e, height: n } = this.worker.getCameraOpt();
      X.width = e, X.height = n, a && (a.drawImage(d, 0, 0), i.src = X.toDataURL(), i.onload = () => {
        X.remove();
      }, i.onerror = () => {
        X.remove(), i.remove();
      }), d.close();
    }
  }
  cleanCurrentScene() {
    var l;
    (l = this.worker) == null || l.clearAll();
  }
  destroy() {
    this.onUnMountDisplayer();
  }
  displayStateListener(l) {
    this.isDelayMount && l === nl.mounted && (this.onMountDisplayer(), gi.InternalMsgEmitter.emit(ui.DisplayContainer, !0)), l === nl.unmounted && this.onUnMountDisplayer();
  }
  linstenerSelector(l) {
    this.room && l.workState === Ii.Start ? this.room.disableDeviceInputs = !0 : this.room && l.workState === Ii.Done && (this.room.disableDeviceInputs = !1);
  }
  onWritableChange(l) {
    var i, d;
    l ? (d = this.worker) == null || d.abled() : (i = this.worker) == null || i.unabled();
  }
  onMountDisplayer() {
    var s, X, a, e, n, G, y;
    const l = (s = Ai.instance) == null ? void 0 : s.containerRef, i = (X = Ai.instance) == null ? void 0 : X.canvasFloatRef, d = (a = Ai.instance) == null ? void 0 : a.canvasBgRef;
    i && d && l && (this.collector = new Vl(this.plugin, (n = (e = this.pluginOptions) == null ? void 0 : e.syncOpt) == null ? void 0 : n.interval), this.cursor = new ms(this.plugin, this.roomMember, (y = (G = this.pluginOptions) == null ? void 0 : G.syncOpt) == null ? void 0 : y.interval), this.worker = new $i(this.collector, this.cursor, this.pluginOptions), this.commiter = this.room && new Ki(this.room, this.worker, this.collector), this.collector.addStorageStateListener((o) => {
      var h, I;
      if (o) {
        if ((h = this.collector) != null && h.storage && Object.keys(this.collector.storage).length === 0) {
          (I = this.worker) == null || I.clearAll(!0);
          return;
        }
        if (this.worker) {
          const x = this.worker.getRelevantWork(o);
          Object.keys(o).forEach((p) => {
            var V;
            const W = o[p];
            W && ((V = this.worker) == null || V.onServiceDerive(p, W, x));
          }), Ki.emitter.emit("excludeIds", Object.keys(o));
        }
      }
    }), this.cursor.injectWorker(this.worker), this.room && (this.roomMember.onUidChangeHook((o) => {
      var h, I, x;
      (h = this.collector) != null && h.serviceStorage && Object.keys(this.collector.serviceStorage).filter((W) => {
        var V;
        return (V = this.collector) == null ? void 0 : V.isSelector(W);
      }).forEach((W) => {
        var t, c;
        const V = (t = this.collector) == null ? void 0 : t.getUidFromKey(W);
        V && !o.online.includes(V) && ((c = this.collector) == null || c.updateValue(W, void 0, { isAfterUpdate: !0 }));
      }), (I = this.cursor) != null && I.eventCollector.serviceStorage && Object.keys((x = this.cursor) == null ? void 0 : x.eventCollector.serviceStorage).forEach((W) => {
        var V;
        o.online.includes(W) || (V = this.cursor) == null || V.eventCollector.clearValue(W);
      });
    }), this.worker.initSyncData()));
  }
  onUnMountDisplayer() {
    var l, i, d, s;
    this.roomMember.destroy(), (l = this.collector) == null || l.destroy(), this.collector = void 0, (i = this.worker) == null || i.destroy(), this.worker = void 0, (d = this.commiter) == null || d.destroy(), this.commiter = void 0, (s = this.cursor) == null || s.destroy(), this.cursor = void 0;
  }
}
Object.defineProperty(gi, "InternalMsgEmitter", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: new Vd()
});
class yi extends ns {
  constructor() {
    super(...arguments), Object.defineProperty(this, "onPhaseChanged", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (l) => {
        l === es.Disconnected && (this.displayer.callbacks.off(this.callbackName, this.roomStateChangeListener), this.displayer.callbacks.off("onEnableWriteNowChanged", this.updateRoomWritable), this.displayer.callbacks.off("onPhaseChanged", this.onPhaseChanged), yi.currentManager.destroy());
      }
    }), Object.defineProperty(this, "updateRoomWritable", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: () => {
        yi.currentManager.onWritableChange(this.displayer.isWritable);
      }
    }), Object.defineProperty(this, "roomStateChangeListener", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: async (l) => {
        l.cameraState && yi.currentManager.onCameraChange(l.cameraState), l.sceneState && yi.currentManager.onSceneChange(l.sceneState), !(Oi(this.displayer) && !this.displayer.isWritable) && (l.memberState && yi.currentManager.onMemberChange(l.memberState), l != null && l.roomMembers && yi.currentManager.onRoomMembersChange(l.roomMembers));
      }
    }), Object.defineProperty(this, "createCurrentManager", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: () => {
        yi.currentManager && yi.currentManager.destroy();
        const l = yi.useMultiViews ? new gi(this, yi.options) : new Fi(this, yi.options);
        l.init(), yi.currentManager = l, yi.logger.info("[BezierPencilPlugin plugin] refresh currentSlideManager object");
      }
    });
  }
  static async getInstance(l, i) {
    i != null && i.logger && (yi.logger = i.logger), i != null && i.options && (yi.options = i.options), i != null && i.cursorAdapter && (yi.cursorAdapter = i.cursorAdapter, yi.effectInstance()), yi.useMultiViews = (i == null ? void 0 : i.useMultiViews) || !1;
    const d = l instanceof hs ? l.displayer : l;
    if (!d.getInvisiblePlugin(yi.kind) && Oi(d) && await l.createInvisiblePlugin(yi, {}), yi.useMultiViews) {
      const a = {
        displayer: d,
        getBoundingRectAsync: async function(e) {
          yi.logger.info("[BezierPencilPlugin plugin] getBoundingRect");
          const n = this.displayer.getBoundingRect(e), G = await yi.currentManager.getBoundingRect(e);
          return Gt(n, G);
        },
        screenshotToCanvasAsync: async function(e, n, G, y, o, h) {
          yi.logger.info("[BezierPencilPlugin plugin] screenshotToCanvasAsync");
          const I = document.createElement("canvas"), x = I.getContext("2d");
          I.width = G * (h || 1), I.height = y * (h || 1), x && (this.displayer.screenshotToCanvas(x, n, G, y, o, h), e.drawImage(I, 0, 0, G * (h || 1), y * (h || 1), 0, 0, G, y), I.remove()), await yi.currentManager.screenshotToCanvas(e, n, G, y, o);
        },
        scenePreviewAsync: async function(e, n, G, y, o) {
          yi.logger.info("[BezierPencilPlugin plugin] scenePreview"), this.displayer.scenePreview(e, n, G, y, o);
          const h = document.createElement("img");
          h.style.position = "absolute", h.style.top = "0px", h.style.left = "0px", h.style.width = "100%", h.style.height = "100%", h.style.pointerEvents = "none", n.append(h), getComputedStyle(n).position || (n.style.position = "relative"), await yi.currentManager.scenePreview(e, h);
        },
        callbacksOn: function(e, n) {
          yi.logger.info(`[BezierPencilPlugin plugin] callbacks ${e}`), (e === "onCanUndoStepsUpdate" || e === "onCanRedoStepsUpdate") && Oi(this.displayer) && this.displayer.isWritable ? Ki.emitter.on(e, n) : this.displayer.callbacks.on(e, n);
        },
        callbacksOnce: function(e, n) {
          yi.logger.info(`[BezierPencilPlugin plugin] callbacks ${e}`), (e === "onCanUndoStepsUpdate" || e === "onCanRedoStepsUpdate") && Oi(this.displayer) && this.displayer.isWritable ? Ki.emitter.on(e, n) : this.displayer.callbacks.on(e, n);
        },
        callbacksOff: function(e, n) {
          yi.logger.info(`[BezierPencilPlugin plugin] callbacks ${e}`), (e === "onCanUndoStepsUpdate" || e === "onCanRedoStepsUpdate") && Oi(this.displayer) && this.displayer.isWritable ? Ki.emitter.off(e, n) : this.displayer.callbacks.off(e, n);
        },
        undo: function() {
          var e;
          return yi.logger.info("[BezierPencilPlugin plugin] undo"), Oi(this.displayer) && !this.displayer.disableSerialization && ((e = yi.currentManager.commiter) == null ? void 0 : e.undo(this.displayer.undo)) || 0;
        },
        redo: function() {
          var e;
          return yi.logger.info("[BezierPencilPlugin plugin] redo"), Oi(this.displayer) && !this.displayer.disableSerialization && ((e = yi.currentManager.commiter) == null ? void 0 : e.redo(this.displayer.redo)) || 0;
        },
        cleanCurrentScene: function(e) {
          yi.logger.info("[BezierPencilPlugin plugin] cleanCurrentScene"), Oi(this.displayer) && l.isWritable && (yi.currentManager.cleanCurrentScene(), this.displayer.cleanCurrentScene(e));
        }
      };
      return {
        ...a,
        callbacks: {
          on: a.callbacksOn.bind(a),
          once: a.callbacksOnce.bind(a),
          off: a.callbacksOff.bind(a),
          forwardTo: a.displayer.callbacks.forwardTo
        }
      };
    }
    const X = {
      displayer: l,
      getBoundingRectAsync: async function(a) {
        yi.logger.info("[BezierPencilPlugin plugin] getBoundingRect");
        const e = this.displayer.getBoundingRect(a), n = await yi.currentManager.getBoundingRect(a);
        return Gt(e, n);
      },
      screenshotToCanvasAsync: async function(a, e, n, G, y, o) {
        yi.logger.info("[BezierPencilPlugin plugin] screenshotToCanvasAsync");
        const h = document.createElement("canvas"), I = h.getContext("2d");
        h.width = n * (o || 1), h.height = G * (o || 1), I && (this.displayer.screenshotToCanvas(I, e, n, G, y, o), a.drawImage(h, 0, 0, n * (o || 1), G * (o || 1), 0, 0, n, G), h.remove()), await yi.currentManager.screenshotToCanvas(a, e, n, G, y);
      },
      scenePreviewAsync: async function(a, e, n, G, y) {
        yi.logger.info("[BezierPencilPlugin plugin] scenePreview"), this.displayer.scenePreview(a, e, n, G, y);
        const o = document.createElement("img");
        o.style.position = "absolute", o.style.top = "0px", o.style.left = "0px", o.style.width = "100%", o.style.height = "100%", o.style.pointerEvents = "none", e.append(o), getComputedStyle(e).position || (e.style.position = "relative"), await yi.currentManager.scenePreview(a, o);
      },
      callbacksOn: function(a, e) {
        yi.logger.info(`[BezierPencilPlugin plugin] callbacks ${a}`), (a === "onCanUndoStepsUpdate" || a === "onCanRedoStepsUpdate") && Oi(this.displayer) && this.displayer.isWritable ? Ki.emitter.on(a, e) : this.displayer.callbacks.on(a, e);
      },
      callbacksOnce: function(a, e) {
        yi.logger.info(`[BezierPencilPlugin plugin] callbacks ${a}`), (a === "onCanUndoStepsUpdate" || a === "onCanRedoStepsUpdate") && Oi(this.displayer) && this.displayer.isWritable ? Ki.emitter.on(a, e) : this.displayer.callbacks.on(a, e);
      },
      callbacksOff: function(a, e) {
        yi.logger.info(`[BezierPencilPlugin plugin] callbacks ${a}`), (a === "onCanUndoStepsUpdate" || a === "onCanRedoStepsUpdate") && Oi(this.displayer) && this.displayer.isWritable ? Ki.emitter.off(a, e) : this.displayer.callbacks.off(a, e);
      },
      undo: function() {
        var a;
        return yi.logger.info("[BezierPencilPlugin plugin] undo"), Oi(this.displayer) && !this.displayer.disableSerialization && ((a = yi.currentManager.commiter) == null ? void 0 : a.undo(this.displayer.undo)) || 0;
      },
      redo: function() {
        var a;
        return yi.logger.info("[BezierPencilPlugin plugin] redo"), Oi(this.displayer) && !this.displayer.disableSerialization && ((a = yi.currentManager.commiter) == null ? void 0 : a.redo(this.displayer.redo)) || 0;
      },
      cleanCurrentScene: function(a) {
        yi.logger.info("[BezierPencilPlugin plugin] cleanCurrentScene"), Oi(this.displayer) && this.displayer.isWritable && (yi.currentManager.cleanCurrentScene(), this.displayer.cleanCurrentScene(a));
      }
    };
    return {
      ...X,
      callbacks: {
        on: X.callbacksOn.bind(X),
        once: X.callbacksOnce.bind(X),
        off: X.callbacksOff.bind(X),
        forwardTo: X.displayer.callbacks.forwardTo
      }
    };
  }
  static onCreate(l) {
    const i = l.displayer;
    l == null || l.init(i);
  }
  // static onDestroy(plugin: BezierPencilPlugin) {}
  /**
   * 房间实例化时，将当前实例对displayer外部API的添加内部处理逻辑;
   * @param displayer
   */
  static effectInstance() {
    if (yi.cursorAdapter) {
      yi.cursorAdapter;
      const l = yi.cursorAdapter.onAddedCursor;
      yi.cursorAdapter.onAddedCursor = function(i) {
        i.onCursorMemberChanged = (d) => {
          try {
            d.appliance === "pencil" ? i != null && i.divElement && (i.divElement.style.display = "none") : i != null && i.divElement && (i.divElement.style.display = "block");
          } catch {
          }
        }, l.call(yi.cursorAdapter, i);
      };
    }
  }
  // constructor(context: InvisiblePluginContext) {
  //     super(context);
  //     // const invisiblePlugin$ = BezierPencilPlugin.invisiblePlugins.get(this.displayer);
  //     // invisiblePlugin$ && setValue(invisiblePlugin$, this);
  // }
  get isReplay() {
    return Xs(this.displayer);
  }
  get callbackName() {
    return this.isReplay ? "onPlayerStateChanged" : "onRoomStateChanged";
  }
  init(l) {
    if (this.createCurrentManager(), Oi(l)) {
      const i = l.state;
      i != null && i.memberState && yi.currentManager.onMemberChange(i.memberState);
    }
    this.displayer.callbacks.on(this.callbackName, this.roomStateChangeListener), this.displayer.callbacks.on("onEnableWriteNowChanged", this.updateRoomWritable), this.displayer.callbacks.on("onPhaseChanged", this.onPhaseChanged), this.displayer.callbacks.on("onCanUndoStepsUpdate", (i) => {
      var d;
      (d = yi.currentManager.commiter) == null || d.addSdkUndoData(i);
    });
  }
  destroy() {
    yi.currentManager.destroy();
  }
}
Object.defineProperty(yi, "kind", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "bezier-pencil-plugin"
});
Object.defineProperty(yi, "useMultiViews", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: !1
});
Object.defineProperty(yi, "logger", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: {
    info: console.log,
    warn: console.warn,
    error: console.error
  }
});
class $i extends Xa {
  constructor(l, i, d) {
    var s, X;
    if (super(ll.instance, l), Object.defineProperty(this, "dpr", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 1
    }), Object.defineProperty(this, "threadEngine", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "pluginOptions", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "layerOpt", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "msgEmitter", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "offscreenCanvasOpt", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "originalPoint", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: [0, 0]
    }), Object.defineProperty(this, "cameraOpt", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "localPointsBatchData", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "taskBatchData", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: /* @__PURE__ */ new Map()
    }), Object.defineProperty(this, "currentToolsData", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "currentLocalWorkData", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "animationId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "subWorker", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "subWorkerDrawCount", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "wokerDrawCount", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "maxDrawCount", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "cacheDrawCount", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "reRenders", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "bgCanvas", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "floatCanvas", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "methodBuilder", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "zIndexNodeMethod", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "localEventTimerId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "undoTickerId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "snapshotMap", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: /* @__PURE__ */ new Map()
    }), Object.defineProperty(this, "boundingRectMap", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: /* @__PURE__ */ new Map()
    }), Object.defineProperty(this, "cursor", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "cachePoint", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "clearAllResolve", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.cursor = i, this.bgCanvas = ll.instance.canvasBgRef, this.floatCanvas = ll.instance.canvasFloatRef, this.bgCanvas && this.floatCanvas) {
      this.pluginOptions = d, $i.maxLastSyncTime = (((s = d == null ? void 0 : d.syncOpt) == null ? void 0 : s.interval) || $i.maxLastSyncTime) * 0.5, this.msgEmitter = new oa();
      const a = {
        ...$i.defaultScreenCanvasOpt,
        ...(X = this.pluginOptions) == null ? void 0 : X.canvasOpt,
        width: this.bgCanvas.offsetWidth,
        height: this.bgCanvas.offsetHeight
      };
      this.offscreenCanvasOpt = a, this.layerOpt = $i.defauleLayerOpt, this.setLayerOpt(this.layerOpt), this.setCurrentLocalWorkData({
        workId: void 0,
        workState: Ii.Pending
      }), this.internalMsgEmitterListener(), this.on();
    }
    Fi.InternalMsgEmitter.on([ui.Cursor, Wi.MoveCursor], this.sendCursorEvent.bind(this));
  }
  sendCursorEvent(l) {
    if (this.currentLocalWorkData.workState === Ii.Freeze || this.currentLocalWorkData.workState === Ii.Unwritable)
      return;
    let i = [void 0, void 0];
    this.currentToolsData && (this.currentToolsData.toolsType === ri.LaserPen || this.currentToolsData.toolsType === ri.Pencil) && this.currentLocalWorkData.workState !== Ii.Start && this.currentLocalWorkData.workState !== Ii.Doing && (i = l), (!this.cachePoint || this.cachePoint[0] !== i[0] || this.cachePoint[1] !== i[1]) && (this.cursor.sendEvent(i), this.cachePoint = i);
  }
  internalMsgEmitterListener() {
    var l, i, d, s;
    this.collector && (this.methodBuilder = new vi([
      Wi.CopyNode,
      Wi.SetColorNode,
      Wi.DeleteNode,
      Wi.RotateNode,
      Wi.ScaleNode,
      Wi.TranslateNode,
      Wi.ZIndexActive,
      Wi.ZIndexNode,
      Wi.RotateNode
    ]).registerForMainEngine(ui.MainEngine, this, this.collector), this.zIndexNodeMethod = (l = this.methodBuilder) == null ? void 0 : l.getBuilder(Wi.ZIndexNode)), (i = Fi.InternalMsgEmitter) == null || i.on([ui.MainEngine, Wi.CreateScene], this.createSceneLintener.bind(this)), (d = Fi.InternalMsgEmitter) == null || d.on([ui.MainEngine, Wi.OriginalEvent], this.originalEventLintener.bind(this)), (s = Fi.InternalMsgEmitter) == null || s.on([ui.FloatBar, Wi.ShowFloatBar], this.showFloatBar.bind(this));
  }
  showFloatBar(l) {
    l ? window.addEventListener("beforeunload", this.removeSelectorFromStore.bind(this)) : window.removeEventListener("beforeunload", this.removeSelectorFromStore.bind(this));
  }
  removeSelectorFromStore() {
    this.collector.dispatch({
      type: pi.Select,
      selectIds: void 0
    });
  }
  internalMsgEmitterRemoveListener() {
    var l, i, d;
    (l = this.methodBuilder) == null || l.destroy(), (i = Fi.InternalMsgEmitter) == null || i.off([ui.MainEngine, Wi.CreateScene], this.createSceneLintener.bind(this)), (d = Fi.InternalMsgEmitter) == null || d.off([ui.MainEngine, Wi.OriginalEvent], this.originalEventLintener.bind(this));
  }
  createSceneLintener(l, i, d) {
    this.offscreenCanvasOpt = {
      ...this.offscreenCanvasOpt,
      width: l,
      height: i
    }, this.dpr = d, this.originalPoint = [l / 2, i / 2], this.cameraOpt = {
      centerX: 0,
      centerY: 0,
      scale: 1,
      width: l,
      height: i
    }, this.createThreadEngine(), this.createOptimizationWorker();
  }
  originalEventLintener(l, i) {
    switch (l) {
      case Ii.Start:
        this.onLocalEventStart(i);
        break;
      case Ii.Doing:
        this.onLocalEventDoing(i);
        break;
      case Ii.Done:
        this.onLocalEventEnd(i);
        break;
    }
  }
  destroySubWorker() {
    this.subWorker && (this.subWorker.terminate(), this.subWorker = void 0);
  }
  createThreadEngine() {
    this.taskBatchData.set("Init", {
      msgType: pi.Init,
      dataType: Ti.Local,
      offscreenCanvasOpt: this.offscreenCanvasOpt,
      layerOpt: this.layerOpt,
      dpr: this.dpr,
      isRunSubWork: !0
    }), this.runAnimation();
  }
  render(l) {
    var i, d, s, X, a, e, n, G;
    for (const y of l) {
      const { rect: o, imageBitmap: h, isClear: I, isUnClose: x, drawCanvas: p, clearCanvas: W, offset: V } = y;
      if (o) {
        const t = o.w * this.dpr, c = o.h * this.dpr, b = o.x * this.dpr, Z = o.y * this.dpr;
        if (I)
          if (W === Sl.Selector)
            (d = (i = this.displayer.floatBarCanvasRef.current) == null ? void 0 : i.getContext("2d")) == null || d.clearRect(0, 0, t, c);
          else {
            const r = W === Sl.Float ? (s = this.floatCanvas) == null ? void 0 : s.getContext("2d") : (X = this.bgCanvas) == null ? void 0 : X.getContext("2d");
            r == null || r.clearRect(b, Z, t, c);
          }
        if (p && h)
          if (p === Sl.Selector) {
            const r = ((V == null ? void 0 : V.x) || 0) * this.dpr, S = ((V == null ? void 0 : V.y) || 0) * this.dpr;
            (e = (a = this.displayer.floatBarCanvasRef.current) == null ? void 0 : a.getContext("2d")) == null || e.drawImage(h, 0, 0, t, c, r, S, t, c);
          } else {
            const r = p === Sl.Float ? (n = this.floatCanvas) == null ? void 0 : n.getContext("2d") : (G = this.bgCanvas) == null ? void 0 : G.getContext("2d");
            r == null || r.drawImage(h, 0, 0, t, c, b, Z, t, c);
          }
        if (x)
          return;
        h == null || h.close();
      }
    }
  }
  runAnimation() {
    this.animationId || (this.animationId = requestAnimationFrame(this.consume.bind(this)));
  }
  setLayerOpt(l) {
    this.layerOpt = l;
  }
  updateCanvas(l) {
    const { width: i, height: d } = l;
    this.bgCanvas && this.floatCanvas && (this.bgCanvas.width = i * this.dpr, this.bgCanvas.height = d * this.dpr, this.floatCanvas.width = i * this.dpr, this.floatCanvas.height = d * this.dpr), this.originalPoint = [i * 0.5, d * 0.5], this.offscreenCanvasOpt.width = i, this.offscreenCanvasOpt.height = d;
  }
  pushPoint(l) {
    this.localPointsBatchData.push(l[0], l[1]);
  }
  transformToScenePoint(l) {
    const i = l, { scale: d, centerX: s, centerY: X } = this.cameraOpt;
    return this.originalPoint && (i[0] = (l[0] - this.originalPoint[0]) / d + s, i[1] = (l[1] - this.originalPoint[1]) / d + X), i;
  }
  transformToOriginPoint(l) {
    const i = l, { scale: d, centerX: s, centerY: X } = this.cameraOpt;
    return this.originalPoint && (i[0] = (l[0] - s) * d + this.originalPoint[0], i[1] = (l[1] - X) * d + this.originalPoint[1]), i;
  }
  getCameraOpt() {
    return this.cameraOpt;
  }
  getDpr() {
    return this.dpr;
  }
  initSyncData(l) {
    var d, s, X;
    const i = (d = this.collector) == null ? void 0 : d.storage;
    if (i) {
      let a, e;
      for (const n of Object.keys(i)) {
        l && l(n, i[n]);
        const G = (s = i[n]) == null ? void 0 : s.type;
        if (G && n) {
          const y = tl(i[n]);
          y.workId = n, y.msgType = G, y.dataType = Ti.Service, y.useAnimation = !1, this.taskBatchData.set(`${y.dataType},${y.msgType},${y.workId}`, y), (X = y.opt) != null && X.zIndex && (e = Math.max(e || 0, y.opt.zIndex), a = Math.min(a || 1 / 0, y.opt.zIndex));
        }
      }
      this.runAnimation(), this.zIndexNodeMethod && (e && (this.zIndexNodeMethod.maxZIndex = e), a && (this.zIndexNodeMethod.minZIndex = a));
    }
  }
  getRelevantWork(l) {
    let i;
    for (const [d, s] of Object.entries(l))
      if (s) {
        const { newValue: X, oldValue: a } = s;
        if (!X && a && Object.keys(l).some((n) => n !== d && n.indexOf(`${d}_s_`) > -1 ? (i = d, !0) : !1))
          break;
      }
    return i;
  }
  onServiceDerive(l, i, d) {
    var G;
    const { newValue: s, oldValue: X } = i, a = tl(s) || {}, e = l;
    let n = a.type;
    if (!(!s && X && (n = pi.RemoveNode, X.toolsType === ri.LaserPen))) {
      if (n && e) {
        const y = a;
        y.workId = this.collector.isOwn(e) ? this.collector.getLocalId(e) : e, y.msgType = n, y.dataType = Ti.Service, y.selectIds && (y.selectIds = y.selectIds.map((o) => this.collector.isOwn(o) ? this.collector.getLocalId(o) : o)), d === l ? setTimeout(() => {
          this.taskBatchData.set(`${y.dataType},${y.msgType},${y.workId}`, y), this.runAnimation();
        }, 16) : this.taskBatchData.set(`${y.dataType},${y.msgType},${y.workId}`, y);
      }
      if (this.runAnimation(), this.zIndexNodeMethod) {
        let y, o;
        i.newValue && ((G = i.newValue.opt) != null && G.zIndex) && (o = Math.max(o || 0, i.newValue.opt.zIndex), y = Math.min(y || 1 / 0, i.newValue.opt.zIndex)), o && (this.zIndexNodeMethod.maxZIndex = o), y && (this.zIndexNodeMethod.minZIndex = y);
      }
    }
  }
  onLocalEventEnd(l) {
    var d;
    const i = this.currentLocalWorkData.workState;
    if (!(i === Ii.Freeze || i === Ii.Unwritable) && (i === Ii.Start || i === Ii.Doing)) {
      const s = this.transformToScenePoint(l);
      this.pushPoint(s), this.localEventTimerId = setTimeout(() => {
        this.localEventTimerId = void 0, this.setCurrentLocalWorkData({ workId: this.currentLocalWorkData.workId, workState: Ii.Done }), this.runAnimation();
      }, 0), this.currentToolsData.toolsType === ri.Selector && ((d = Fi.InternalMsgEmitter) == null || d.emit([ui.FloatBar, Wi.ZIndexFloatBar], 2));
    }
  }
  onLocalEventDoing(l) {
    let i = this.currentLocalWorkData.workState;
    if (!(i === Ii.Freeze || i === Ii.Unwritable) && (i === Ii.Start && (i = Ii.Doing, this.setCurrentLocalWorkData({ workId: this.currentLocalWorkData.workId, workState: i })), i === Ii.Doing || this.localEventTimerId)) {
      const d = this.transformToScenePoint(l);
      this.pushPoint(d), this.localEventTimerId || this.runAnimation();
    }
  }
  onLocalEventStart(l) {
    var a, e;
    const { workState: i } = this.currentLocalWorkData;
    if (i === Ii.Freeze || i === Ii.Unwritable)
      return;
    const d = this.currentToolsData.toolsType === ri.Selector ? Ci : Date.now(), s = tl(this.currentToolsData.toolsOpt);
    this.currentToolsData.toolsType === ri.Pencil && this.zIndexNodeMethod && (this.zIndexNodeMethod.addMaxLayer(), s.zIndex = this.zIndexNodeMethod.maxZIndex), this.setCurrentLocalWorkData({
      workId: d,
      workState: Ii.Start,
      toolsOpt: s
    }, pi.CreateWork);
    const X = this.transformToScenePoint(l);
    this.pushPoint(X), this.maxDrawCount = 0, this.cacheDrawCount = 0, this.wokerDrawCount = 0, this.subWorkerDrawCount = 0, this.reRenders.length = 0, (this.currentToolsData.toolsType === ri.Pencil || this.currentToolsData.toolsType === ri.Eraser || this.currentToolsData.toolsType === ri.Selector) && (this.currentToolsData.toolsType === ri.Selector ? this.undoTickerId = Date.now() : this.undoTickerId = d, Ki.emitter.emit("undoTickerStart", this.undoTickerId)), this.currentToolsData.toolsType === ri.Pencil || this.currentToolsData.toolsType === ri.LaserPen ? ((a = this.collector) == null || a.dispatch({
      type: pi.CreateWork,
      workId: d,
      toolsType: this.currentToolsData.toolsType,
      opt: this.currentToolsData.toolsOpt
    }), this.collector.hasSelector() && this.taskBatchData.set(Ci, {
      workId: Ci,
      selectIds: [],
      msgType: pi.Select,
      dataType: Ti.Service
    })) : this.currentToolsData.toolsType === ri.Selector && ((e = Fi.InternalMsgEmitter) == null || e.emit([ui.FloatBar, Wi.ZIndexFloatBar], -1)), this.consume();
  }
  consume() {
    this.animationId = void 0;
    const l = this.currentLocalWorkData.workState;
    let i = !1;
    if (!this.localEventTimerId) {
      if (this.localPointsBatchData.length) {
        const d = this.currentToolsData.toolsType === ri.Pencil || this.currentToolsData.toolsType === ri.LaserPen;
        this.wokerDrawCount !== 1 / 0 && this.wokerDrawCount <= this.subWorkerDrawCount && this.cacheDrawCount < this.maxDrawCount && (i = !0), this.maxDrawCount || (i = !0), i && (this.taskBatchData.set(this.currentLocalWorkData.workId, {
          op: this.localPointsBatchData.map((s) => s),
          workState: l,
          workId: this.currentLocalWorkData.workId,
          dataType: Ti.Local,
          msgType: pi.DrawWork,
          isRunSubWork: d,
          undoTickerId: l === Ii.Done && this.undoTickerId || void 0
        }), this.localPointsBatchData.length = 0, this.cacheDrawCount = this.maxDrawCount);
      }
      this.taskBatchData.size && (this.post(this.taskBatchData), this.taskBatchData.clear(), this.undoTickerId && l === Ii.Done && (this.undoTickerId = void 0));
    }
    (this.taskBatchData.size || this.localPointsBatchData.length) && (this.animationId = requestAnimationFrame(this.consume.bind(this)));
  }
  post(l) {
    var d;
    this.msgEmitter.postMessage(l);
    const i = /* @__PURE__ */ new Map();
    for (const [s, X] of l.entries())
      (s === "Init" || s === "ClearAll" || s === "UpdateCamera" || X.isRunSubWork) && i.set(s, X);
    i.size && ((d = this.subWorker) == null || d.postMessage(i));
  }
  on() {
    this.msgEmitter.onmessage = (l) => {
      if (l.data) {
        const { render: i, sp: d, drawCount: s } = l.data;
        if (d != null && d.length && this.collectorSyncData(d), !s && i) {
          this.render(i);
          return;
        }
        s && (this.wokerDrawCount = s, this.wokerDrawCount < 1 / 0 ? this.maxDrawCount = Math.max(this.maxDrawCount, this.wokerDrawCount) : this.maxDrawCount = 0, i != null && i.length && (this.render(i), this.wokerDrawCount < this.subWorkerDrawCount && (this.reRenders.forEach((X) => {
          X.isUnClose = !1;
        }), this.render(this.reRenders), this.reRenders.length = 0)));
      }
    };
  }
  createOptimizationWorker() {
    this.subWorker = new aa(), this.subWorker.onmessage = (l) => {
      if (l.data) {
        const { render: i, drawCount: d, sp: s } = l.data;
        if (s != null && s.length && this.collectorSyncData(s), !d && (i != null && i.length)) {
          this.render(i);
          return;
        }
        d && (this.subWorkerDrawCount = d, this.wokerDrawCount < 1 / 0 && (this.maxDrawCount = Math.max(this.maxDrawCount, this.subWorkerDrawCount)), i != null && i.length && (this.subWorkerDrawCount > this.wokerDrawCount && (i.forEach((X) => X.isUnClose = !0), this.reRenders.push(...i)), this.wokerDrawCount < 1 / 0 && this.render(i)));
      }
    };
  }
  collectorSyncData(l) {
    var d, s, X;
    let i = !1;
    for (const a of l) {
      const { type: e, selectIds: n, opt: G, padding: y, selectRect: o, nodeColor: h, nodeOpactiy: I, willSyncService: x, isSync: p, undoTickerId: W, imageBitmap: V, scenePath: t, canvasHeight: c, canvasWidth: b, rect: Z, op: r } = a;
      switch (e) {
        case pi.Select:
          const S = n != null && n.length ? { ...o, selectIds: n, canvasHeight: c, canvasWidth: b } : void 0;
          S && (G != null && G.color) && (S.color = G.color), S && y && (S.padding = y), S && h && (S.nodeColor = h), S && (G != null && G.opacity) && (S.opacity = G.opacity), S && I && (S.opacity = I), (d = Fi.InternalMsgEmitter) == null || d.emit([ui.FloatBar, Wi.ShowFloatBar], !!S, S), x && ((s = this.collector) == null || s.dispatch({ type: e, selectIds: n, opt: G, isSync: p }), W && Ki.emitter.emit("undoTickerEnd", W));
          break;
        case pi.Snapshot:
          if (V && t) {
            const C = this.snapshotMap.get(t);
            C && C(V);
          }
          break;
        case pi.BoundingBox:
          if (Z && t) {
            const C = this.boundingRectMap.get(t);
            C && C(Z);
          }
          break;
        case pi.Cursor:
          r && this.cursor.collectServiceCursor({ ...a });
          break;
        case pi.Clear:
          (X = Fi.InternalMsgEmitter) == null || X.emit([ui.FloatBar, Wi.ShowFloatBar], !1), this.clearAllResolve && this.clearAllResolve(!0);
          break;
        default:
          i = !0;
          break;
      }
    }
    i && sd(() => {
      this.collectorAsyncData(l);
    }, $i.maxLastSyncTime);
  }
  collectorAsyncData(l) {
    var i, d, s, X;
    for (const a of l) {
      const { type: e, op: n, workId: G, index: y, removeIds: o, ops: h, opt: I, updateNodeOpt: x, toolsType: p, isSync: W, undoTickerId: V } = a;
      switch (e) {
        case pi.DrawWork:
          n != null && n.length && G && typeof y == "number" && ((i = this.collector) == null || i.dispatch({
            type: e,
            op: n,
            workId: G,
            index: y,
            isSync: W
          }));
          break;
        case pi.FullWork:
          h && ((d = this.collector) == null || d.dispatch({ type: e, ops: h, workId: G, updateNodeOpt: x, opt: I, toolsType: p, isSync: W }));
          break;
        case pi.UpdateNode:
          (x || I || h) && ((s = this.collector) == null || s.dispatch({ type: e, updateNodeOpt: x, workId: G, opt: I, ops: h, isSync: W }));
          break;
        case pi.RemoveNode:
          (n || o != null && o.length) && ((X = this.collector) == null || X.dispatch({ type: e, removeIds: o, isSync: W }));
          break;
      }
      V && Ki.emitter.emit("undoTickerEnd", V);
    }
  }
  async clearAll(l = !1) {
    var i;
    if (this.taskBatchData.set("ClearAll", {
      dataType: Ti.Local,
      msgType: pi.Clear
    }), this.runAnimation(), !l) {
      const d = Date.now();
      Ki.emitter.emit("undoTickerStart", d), (i = this.collector) == null || i.dispatch({
        type: pi.Clear
      }), Ki.emitter.emit("undoTickerEnd", d);
    }
    this.zIndexNodeMethod && (this.zIndexNodeMethod.maxZIndex = 0, this.zIndexNodeMethod.minZIndex = 0), this.localPointsBatchData.length = 0, await new Promise((d) => {
      this.clearAllResolve = d;
    }).then(() => {
      this.clearAllResolve = void 0;
    });
  }
  unabled() {
    this.setCurrentLocalWorkData({ workState: Ii.Freeze, workId: void 0 });
  }
  abled() {
    this.setCurrentLocalWorkData({ workState: Ii.Pending, workId: void 0 });
  }
  destroy() {
    var l;
    (l = this.msgEmitter) == null || l.terminate(), this.destroySubWorker(), this.internalMsgEmitterRemoveListener();
  }
  updateNode(l, i) {
    this.taskBatchData.set(`${pi.UpdateNode},${l}`, {
      msgType: pi.UpdateNode,
      workId: l,
      updateNodeOpt: i,
      dataType: Ti.Local
    }), this.runAnimation();
  }
  setCurrentLocalWorkData(l, i = pi.None) {
    super.setCurrentLocalWorkData(l);
    const { workState: d, workId: s, toolsOpt: X } = l;
    if (d !== Ii.Unwritable && i !== pi.None) {
      const a = this.currentToolsData.toolsType;
      this.taskBatchData.set(`${i},${s}`, {
        msgType: i,
        workId: s,
        toolsType: a,
        opt: { ...this.currentToolsData.toolsOpt, ...X, syncUnitTime: $i.maxLastSyncTime },
        dataType: Ti.Local,
        isRunSubWork: a === ri.Pencil || a === ri.LaserPen
      }), this.runAnimation();
    }
  }
  setCurrentToolsData(l) {
    super.setCurrentToolsData(l);
    const i = l.toolsType;
    if (this.collector.hasSelector()) {
      const d = Date.now();
      Ki.emitter.emit("undoTickerStart", d), this.taskBatchData.set(Ci, {
        workId: Ci,
        msgType: pi.RemoveNode,
        dataType: Ti.Local,
        undoTickerId: d
      });
    }
    this.taskBatchData.set("UpdateTools", {
      msgType: pi.UpdateTools,
      dataType: Ti.Local,
      toolsType: i,
      opt: { ...l.toolsOpt, syncUnitTime: $i.maxLastSyncTime },
      isRunSubWork: i === ri.Pencil || i === ri.LaserPen
    }), this.runAnimation();
  }
  setCameraOpt(l) {
    super.setCameraOpt(l);
    const { width: i, height: d } = l;
    (i !== this.offscreenCanvasOpt.width || d !== this.offscreenCanvasOpt.height) && (this.bgCanvas && (this.bgCanvas.style.width = `${i}px`, this.bgCanvas.style.height = `${d}px`), this.floatCanvas && (this.floatCanvas.style.width = `${i}px`, this.floatCanvas.style.height = `${d}px`), this.updateCanvas({ width: i, height: d })), this.taskBatchData.set("UpdateCamera", {
      msgType: pi.UpdateCamera,
      dataType: Ti.Local,
      cameraOpt: l,
      isRunSubWork: !0
    }), this.runAnimation();
  }
  getSnapshot(l, i, d, s) {
    var a;
    if (!((a = this.snapshotMap) == null ? void 0 : a.get(l))) {
      const e = this.collector.getNamespaceData(l);
      if (Object.keys(e).forEach((n) => {
        this.collector.getLocalId(n) === Ci && delete e[n];
      }), Object.keys(e).length) {
        const n = i || this.cameraOpt.width, G = d || this.cameraOpt.height, y = {
          msgType: pi.Snapshot,
          dataType: Ti.Local,
          scenePath: l,
          scenes: e,
          w: n,
          h: G,
          cameraOpt: s && {
            ...s,
            width: n,
            height: G
          } || this.cameraOpt,
          isRunSubWork: !0
        };
        return this.taskBatchData.set(`${y.scenePath}`, y), this.runAnimation(), new Promise((o) => {
          this.snapshotMap.set(l, o);
        }).then((o) => (this.snapshotMap.delete(l), o));
      }
    }
  }
  getBoundingRect(l) {
    var d;
    if (!((d = this.boundingRectMap) == null ? void 0 : d.get(l))) {
      const s = this.collector.getNamespaceData(l);
      if (Object.keys(s).forEach((X) => {
        this.collector.getLocalId(X) === Ci && delete s[X];
      }), Object.keys(s).length) {
        const X = {
          msgType: pi.BoundingBox,
          dataType: Ti.Local,
          scenePath: l,
          scenes: s,
          cameraOpt: this.cameraOpt,
          isRunSubWork: !0
        };
        return this.taskBatchData.set(`${X.scenePath}`, X), this.runAnimation(), new Promise((a) => {
          this.boundingRectMap.set(l, a);
        }).then((a) => (this.boundingRectMap.delete(l), a));
      }
    }
  }
}
Object.defineProperty($i, "defaultScreenCanvasOpt", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: {
    autoRender: !1,
    contextType: ed.Canvas2d
    // bufferSize: 5000
  }
});
Object.defineProperty($i, "defauleLayerOpt", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: {
    offscreen: !0,
    handleEvent: !1,
    depth: !1
  }
});
Object.defineProperty($i, "maxLastSyncTime", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 500
});
export {
  ll as BezierPencilDisplayer,
  yi as BezierPencilPlugin,
  nl as DisplayStateEnum,
  ed as ECanvasContextType,
  Sl as ECanvasShowType,
  Ti as EDataType,
  pi as EPostMessageType,
  Td as EScaleDirection,
  Fd as EShapeDataTypeKey,
  Jd as ESpriteNodeKey,
  ml as EStrokeType,
  ri as EToolsKey,
  ul as ElayerType,
  Wi as EmitEventType,
  Ll as EventMessageType,
  Ii as EvevtWorkState,
  ui as InternalMsgEmitterType,
  $i as MainEngineForWorker
};
