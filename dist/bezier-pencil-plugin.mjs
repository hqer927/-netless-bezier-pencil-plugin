import { decompress as zs, compress as Ms } from "lz-string";
import "lineclip";
import { toJS as Dl, autorun as ks, ApplianceNames as cl, isRoom as fl, InvisiblePlugin as vs, RoomPhase as Us, isPlayer as Qs } from "white-web-sdk";
import { setValue as fs, val as Ps } from "value-enhancer";
import Vi, { useContext as il, useState as $i, useMemo as hl, useEffect as Yl } from "react";
import Al from "react-draggable";
import { Resizable as ws } from "re-resizable";
import { EventEmitter2 as Es } from "eventemitter2";
var ml;
(function(Z) {
  Z[Z.pedding = 0] = "pedding", Z[Z.mounted = 1] = "mounted", Z[Z.update = 2] = "update", Z[Z.unmounted = 3] = "unmounted";
})(ml || (ml = {}));
var Oi;
(function(Z) {
  Z[Z.Normal = 0] = "Normal", Z[Z.Stroke = 1] = "Stroke", Z[Z.Dotted = 2] = "Dotted", Z[Z.LongDotted = 3] = "LongDotted";
})(Oi || (Oi = {}));
var Gi;
(function(Z) {
  Z.ShowFloatBar = "ShowFloatBar", Z.ZIndexFloatBar = "ZIndexFloatBar", Z.DeleteNode = "DeleteNode", Z.CopyNode = "CopyNode", Z.ZIndexActive = "ZIndexActive", Z.ZIndexNode = "ZIndexNode", Z.RotateNode = "RotateNode", Z.SetColorNode = "SetColorNode", Z.TranslateNode = "TranslateNode", Z.ScaleNode = "ScaleNode", Z.OriginalEvent = "OriginalEvent", Z.CreateScene = "createScene", Z.UpdateScene = "UpdateScene";
})(Gi || (Gi = {}));
var Ii;
(function(Z) {
  Z.DisplayState = "DisplayState", Z.FloatBar = "FloatBar", Z.CanvasSelector = "CanvasSelector", Z.MainEngine = "MainEngine";
})(Ii || (Ii = {}));
var Yi;
(function(Z) {
  Z[Z.Pencil = 1] = "Pencil", Z[Z.Eraser = 2] = "Eraser", Z[Z.Selector = 3] = "Selector", Z[Z.Clicker = 4] = "Clicker", Z[Z.Arrow = 5] = "Arrow", Z[Z.Hand = 6] = "Hand", Z[Z.LaserPen = 7] = "LaserPen";
})(Yi || (Yi = {}));
var od;
(function(Z) {
  Z[Z.Path = 0] = "Path", Z[Z.Rect = 1] = "Rect";
})(od || (od = {}));
var Ji;
(function(Z) {
  Z[Z.Local = 1] = "Local", Z[Z.Service = 2] = "Service";
})(Ji || (Ji = {}));
var pi;
(function(Z) {
  Z[Z.Pending = 0] = "Pending", Z[Z.Start = 1] = "Start", Z[Z.Doing = 2] = "Doing", Z[Z.Done = 3] = "Done", Z[Z.Freeze = 4] = "Freeze", Z[Z.Unwritable = 5] = "Unwritable";
})(pi || (pi = {}));
var hi;
(function(Z) {
  Z[Z.Init = 0] = "Init", Z[Z.UpdateCamera = 1] = "UpdateCamera", Z[Z.UpdateTools = 2] = "UpdateTools", Z[Z.UpdateScene = 3] = "UpdateScene", Z[Z.CreateWork = 4] = "CreateWork", Z[Z.DrawWork = 5] = "DrawWork", Z[Z.FullWork = 6] = "FullWork", Z[Z.UpdateWork = 7] = "UpdateWork", Z[Z.UpdateNode = 8] = "UpdateNode", Z[Z.RemoveNode = 9] = "RemoveNode", Z[Z.Clear = 10] = "Clear", Z[Z.Select = 11] = "Select", Z[Z.Destroy = 12] = "Destroy", Z[Z.None = 13] = "None", Z[Z.CombineDraw = 14] = "CombineDraw";
})(hi || (hi = {}));
var ad;
(function(Z) {
  Z[Z.Path = 0] = "Path", Z[Z.Rect = 1] = "Rect", Z[Z.Texture = 2] = "Texture";
})(ad || (ad = {}));
var Pl;
(function(Z) {
  Z.Webgl2 = "webgl2", Z.Webgl = "webgl", Z.Canvas2d = "2d";
})(Pl || (Pl = {}));
var Zl;
(function(Z) {
  Z[Z.Float = 1] = "Float", Z[Z.Bg = 2] = "Bg", Z[Z.Selector = 3] = "Selector";
})(Zl || (Zl = {}));
var ed;
(function(Z) {
  Z.LT = "topLeft", Z.LC = "left", Z.LB = "bottomLeft", Z.TC = "top", Z.RT = "topRight", Z.RC = "right", Z.RB = "bottomRight", Z.BC = "bottom";
})(ed || (ed = {}));
class js {
  constructor(l, i) {
    Object.defineProperty(this, "syncUnitTime", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 1e3
    }), Object.defineProperty(this, "drawLayer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "fullLayer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "workId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.fullLayer = l, this.drawLayer = i;
  }
  setWorkId(l) {
    this.workId = l;
  }
  getWorkId() {
    return this.workId;
  }
  getWorkOptions() {
    return this.workOptions;
  }
  setWorkOptions(l) {
    this.workOptions = l, this.syncUnitTime = l.syncUnitTime || this.syncUnitTime;
  }
}
var Fi = (
  /******/
  function(Z) {
    var l = {};
    function i(s) {
      if (l[s])
        return l[s].exports;
      var c = l[s] = {
        /******/
        i: s,
        /******/
        l: !1,
        /******/
        exports: {}
        /******/
      };
      return Z[s].call(c.exports, c, c.exports, i), c.l = !0, c.exports;
    }
    return i.m = Z, i.c = l, i.d = function(s, c, W) {
      i.o(s, c) || Object.defineProperty(s, c, { enumerable: !0, get: W });
    }, i.r = function(s) {
      typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(s, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(s, "__esModule", { value: !0 });
    }, i.t = function(s, c) {
      if (c & 1 && (s = i(s)), c & 8 || c & 4 && typeof s == "object" && s && s.__esModule)
        return s;
      var W = /* @__PURE__ */ Object.create(null);
      if (i.r(W), Object.defineProperty(W, "default", { enumerable: !0, value: s }), c & 2 && typeof s != "string")
        for (var h in s)
          i.d(W, h, (function(e) {
            return s[e];
          }).bind(null, h));
      return W;
    }, i.n = function(s) {
      var c = s && s.__esModule ? (
        /******/
        function() {
          return s.default;
        }
      ) : (
        /******/
        function() {
          return s;
        }
      );
      return i.d(c, "a", c), c;
    }, i.o = function(s, c) {
      return Object.prototype.hasOwnProperty.call(s, c);
    }, i.p = "/js/", i(i.s = 0);
  }([
    /* 0 */
    /***/
    function(Z, l, i) {
      i.r(l), i.d(l, "version", function() {
        return w;
      }), i.d(l, "helpers", function() {
        return H;
      }), i.d(l, "createElement", function() {
        return T;
      }), i.d(l, "isSpriteNode", function() {
        return Y;
      }), i.d(l, "registerNode", function() {
        return x;
      });
      var s = i(12);
      i.d(l, "ENV", function() {
        return s.ENV;
      });
      var c = i(68);
      i.d(l, "requestAnimationFrame", function() {
        return c.requestAnimationFrame;
      }), i.d(l, "cancelAnimationFrame", function() {
        return c.cancelAnimationFrame;
      });
      var W = i(70);
      i.d(l, "Node", function() {
        return W.default;
      });
      var h = i(217);
      i.d(l, "Cloud", function() {
        return h.default;
      });
      var e = i(219);
      i.d(l, "Block", function() {
        return e.default;
      });
      var a = i(224);
      i.d(l, "Sprite", function() {
        return a.default;
      });
      var G = i(226);
      i.d(l, "Path", function() {
        return G.default;
      });
      var y = i(229);
      i.d(l, "Rect", function() {
        return y.default;
      });
      var n = i(231);
      i.d(l, "Triangle", function() {
        return n.default;
      });
      var V = i(236);
      i.d(l, "Parallel", function() {
        return V.default;
      });
      var I = i(238);
      i.d(l, "Regular", function() {
        return I.default;
      });
      var r = i(240);
      i.d(l, "Star", function() {
        return r.default;
      });
      var p = i(242);
      i.d(l, "Ellipse", function() {
        return p.default;
      });
      var o = i(244);
      i.d(l, "Arc", function() {
        return o.default;
      });
      var u = i(246);
      i.d(l, "Ring", function() {
        return u.default;
      });
      var d = i(232);
      i.d(l, "Polyline", function() {
        return d.default;
      });
      var b = i(248);
      i.d(l, "Label", function() {
        return b.default;
      });
      var t = i(250);
      i.d(l, "Group", function() {
        return t.default;
      });
      var m = i(286);
      i.d(l, "Layer", function() {
        return m.default;
      });
      var R = i(287);
      i.d(l, "SpriteSvg", function() {
        return R.default;
      });
      var S = i(289);
      i.d(l, "LayerWorker", function() {
        return S.default;
      });
      var C = i(290);
      i.d(l, "Scene", function() {
        return C.default;
      });
      var F = i(213), K = i(221);
      i.d(l, "Color", function() {
        return K.Color;
      }), i.d(l, "Gradient", function() {
        return K.Gradient;
      });
      var J = i(72);
      i(1).glMatrix.setMatrixArrayType(Array);
      const T = F.default.createElement, Y = F.default.isSpriteNode, x = F.default.registerNode, H = {
        parseColor: K.parseColor,
        sizeToPixel: J.sizeToPixel,
        toArray: J.toArray,
        toString: J.toString,
        toNumber: J.toNumber
      };
      let Q;
      Q = "3.8.3";
      const w = Q;
    },
    /* 1 */
    /***/
    function(Z, l, i) {
      i.r(l);
      var s = i(2);
      i.d(l, "glMatrix", function() {
        return s;
      });
      var c = i(3);
      i.d(l, "mat2", function() {
        return c;
      });
      var W = i(4);
      i.d(l, "mat2d", function() {
        return W;
      });
      var h = i(5);
      i.d(l, "mat3", function() {
        return h;
      });
      var e = i(6);
      i.d(l, "mat4", function() {
        return e;
      });
      var a = i(7);
      i.d(l, "quat", function() {
        return a;
      });
      var G = i(10);
      i.d(l, "quat2", function() {
        return G;
      });
      var y = i(11);
      i.d(l, "vec2", function() {
        return y;
      });
      var n = i(8);
      i.d(l, "vec3", function() {
        return n;
      });
      var V = i(9);
      i.d(l, "vec4", function() {
        return V;
      });
    },
    /* 2 */
    /***/
    function(Z, l, i) {
      i.r(l), i.d(l, "EPSILON", function() {
        return s;
      }), i.d(l, "ARRAY_TYPE", function() {
        return c;
      }), i.d(l, "RANDOM", function() {
        return W;
      }), i.d(l, "setMatrixArrayType", function() {
        return h;
      }), i.d(l, "toRadian", function() {
        return a;
      }), i.d(l, "equals", function() {
        return G;
      });
      var s = 1e-6, c = typeof Float32Array < "u" ? Float32Array : Array, W = Math.random;
      function h(y) {
        c = y;
      }
      var e = Math.PI / 180;
      function a(y) {
        return y * e;
      }
      function G(y, n) {
        return Math.abs(y - n) <= s * Math.max(1, Math.abs(y), Math.abs(n));
      }
      Math.hypot || (Math.hypot = function() {
        for (var y = 0, n = arguments.length; n--; )
          y += arguments[n] * arguments[n];
        return Math.sqrt(y);
      });
    },
    /* 3 */
    /***/
    function(Z, l, i) {
      i.r(l), i.d(l, "create", function() {
        return c;
      }), i.d(l, "clone", function() {
        return W;
      }), i.d(l, "copy", function() {
        return h;
      }), i.d(l, "identity", function() {
        return e;
      }), i.d(l, "fromValues", function() {
        return a;
      }), i.d(l, "set", function() {
        return G;
      }), i.d(l, "transpose", function() {
        return y;
      }), i.d(l, "invert", function() {
        return n;
      }), i.d(l, "adjoint", function() {
        return V;
      }), i.d(l, "determinant", function() {
        return I;
      }), i.d(l, "multiply", function() {
        return r;
      }), i.d(l, "rotate", function() {
        return p;
      }), i.d(l, "scale", function() {
        return o;
      }), i.d(l, "fromRotation", function() {
        return u;
      }), i.d(l, "fromScaling", function() {
        return d;
      }), i.d(l, "str", function() {
        return b;
      }), i.d(l, "frob", function() {
        return t;
      }), i.d(l, "LDU", function() {
        return m;
      }), i.d(l, "add", function() {
        return R;
      }), i.d(l, "subtract", function() {
        return S;
      }), i.d(l, "exactEquals", function() {
        return C;
      }), i.d(l, "equals", function() {
        return F;
      }), i.d(l, "multiplyScalar", function() {
        return K;
      }), i.d(l, "multiplyScalarAndAdd", function() {
        return J;
      }), i.d(l, "mul", function() {
        return T;
      }), i.d(l, "sub", function() {
        return Y;
      });
      var s = i(2);
      function c() {
        var x = new s.ARRAY_TYPE(4);
        return s.ARRAY_TYPE != Float32Array && (x[1] = 0, x[2] = 0), x[0] = 1, x[3] = 1, x;
      }
      function W(x) {
        var H = new s.ARRAY_TYPE(4);
        return H[0] = x[0], H[1] = x[1], H[2] = x[2], H[3] = x[3], H;
      }
      function h(x, H) {
        return x[0] = H[0], x[1] = H[1], x[2] = H[2], x[3] = H[3], x;
      }
      function e(x) {
        return x[0] = 1, x[1] = 0, x[2] = 0, x[3] = 1, x;
      }
      function a(x, H, Q, w) {
        var O = new s.ARRAY_TYPE(4);
        return O[0] = x, O[1] = H, O[2] = Q, O[3] = w, O;
      }
      function G(x, H, Q, w, O) {
        return x[0] = H, x[1] = Q, x[2] = w, x[3] = O, x;
      }
      function y(x, H) {
        if (x === H) {
          var Q = H[1];
          x[1] = H[2], x[2] = Q;
        } else
          x[0] = H[0], x[1] = H[2], x[2] = H[1], x[3] = H[3];
        return x;
      }
      function n(x, H) {
        var Q = H[0], w = H[1], O = H[2], q = H[3], k = Q * q - O * w;
        return k ? (k = 1 / k, x[0] = q * k, x[1] = -w * k, x[2] = -O * k, x[3] = Q * k, x) : null;
      }
      function V(x, H) {
        var Q = H[0];
        return x[0] = H[3], x[1] = -H[1], x[2] = -H[2], x[3] = Q, x;
      }
      function I(x) {
        return x[0] * x[3] - x[2] * x[1];
      }
      function r(x, H, Q) {
        var w = H[0], O = H[1], q = H[2], k = H[3], f = Q[0], D = Q[1], ii = Q[2], _ = Q[3];
        return x[0] = w * f + q * D, x[1] = O * f + k * D, x[2] = w * ii + q * _, x[3] = O * ii + k * _, x;
      }
      function p(x, H, Q) {
        var w = H[0], O = H[1], q = H[2], k = H[3], f = Math.sin(Q), D = Math.cos(Q);
        return x[0] = w * D + q * f, x[1] = O * D + k * f, x[2] = w * -f + q * D, x[3] = O * -f + k * D, x;
      }
      function o(x, H, Q) {
        var w = H[0], O = H[1], q = H[2], k = H[3], f = Q[0], D = Q[1];
        return x[0] = w * f, x[1] = O * f, x[2] = q * D, x[3] = k * D, x;
      }
      function u(x, H) {
        var Q = Math.sin(H), w = Math.cos(H);
        return x[0] = w, x[1] = Q, x[2] = -Q, x[3] = w, x;
      }
      function d(x, H) {
        return x[0] = H[0], x[1] = 0, x[2] = 0, x[3] = H[1], x;
      }
      function b(x) {
        return "mat2(" + x[0] + ", " + x[1] + ", " + x[2] + ", " + x[3] + ")";
      }
      function t(x) {
        return Math.hypot(x[0], x[1], x[2], x[3]);
      }
      function m(x, H, Q, w) {
        return x[2] = w[2] / w[0], Q[0] = w[0], Q[1] = w[1], Q[3] = w[3] - x[2] * Q[1], [x, H, Q];
      }
      function R(x, H, Q) {
        return x[0] = H[0] + Q[0], x[1] = H[1] + Q[1], x[2] = H[2] + Q[2], x[3] = H[3] + Q[3], x;
      }
      function S(x, H, Q) {
        return x[0] = H[0] - Q[0], x[1] = H[1] - Q[1], x[2] = H[2] - Q[2], x[3] = H[3] - Q[3], x;
      }
      function C(x, H) {
        return x[0] === H[0] && x[1] === H[1] && x[2] === H[2] && x[3] === H[3];
      }
      function F(x, H) {
        var Q = x[0], w = x[1], O = x[2], q = x[3], k = H[0], f = H[1], D = H[2], ii = H[3];
        return Math.abs(Q - k) <= s.EPSILON * Math.max(1, Math.abs(Q), Math.abs(k)) && Math.abs(w - f) <= s.EPSILON * Math.max(1, Math.abs(w), Math.abs(f)) && Math.abs(O - D) <= s.EPSILON * Math.max(1, Math.abs(O), Math.abs(D)) && Math.abs(q - ii) <= s.EPSILON * Math.max(1, Math.abs(q), Math.abs(ii));
      }
      function K(x, H, Q) {
        return x[0] = H[0] * Q, x[1] = H[1] * Q, x[2] = H[2] * Q, x[3] = H[3] * Q, x;
      }
      function J(x, H, Q, w) {
        return x[0] = H[0] + Q[0] * w, x[1] = H[1] + Q[1] * w, x[2] = H[2] + Q[2] * w, x[3] = H[3] + Q[3] * w, x;
      }
      var T = r, Y = S;
    },
    /* 4 */
    /***/
    function(Z, l, i) {
      i.r(l), i.d(l, "create", function() {
        return c;
      }), i.d(l, "clone", function() {
        return W;
      }), i.d(l, "copy", function() {
        return h;
      }), i.d(l, "identity", function() {
        return e;
      }), i.d(l, "fromValues", function() {
        return a;
      }), i.d(l, "set", function() {
        return G;
      }), i.d(l, "invert", function() {
        return y;
      }), i.d(l, "determinant", function() {
        return n;
      }), i.d(l, "multiply", function() {
        return V;
      }), i.d(l, "rotate", function() {
        return I;
      }), i.d(l, "scale", function() {
        return r;
      }), i.d(l, "translate", function() {
        return p;
      }), i.d(l, "fromRotation", function() {
        return o;
      }), i.d(l, "fromScaling", function() {
        return u;
      }), i.d(l, "fromTranslation", function() {
        return d;
      }), i.d(l, "str", function() {
        return b;
      }), i.d(l, "frob", function() {
        return t;
      }), i.d(l, "add", function() {
        return m;
      }), i.d(l, "subtract", function() {
        return R;
      }), i.d(l, "multiplyScalar", function() {
        return S;
      }), i.d(l, "multiplyScalarAndAdd", function() {
        return C;
      }), i.d(l, "exactEquals", function() {
        return F;
      }), i.d(l, "equals", function() {
        return K;
      }), i.d(l, "mul", function() {
        return J;
      }), i.d(l, "sub", function() {
        return T;
      });
      var s = i(2);
      function c() {
        var Y = new s.ARRAY_TYPE(6);
        return s.ARRAY_TYPE != Float32Array && (Y[1] = 0, Y[2] = 0, Y[4] = 0, Y[5] = 0), Y[0] = 1, Y[3] = 1, Y;
      }
      function W(Y) {
        var x = new s.ARRAY_TYPE(6);
        return x[0] = Y[0], x[1] = Y[1], x[2] = Y[2], x[3] = Y[3], x[4] = Y[4], x[5] = Y[5], x;
      }
      function h(Y, x) {
        return Y[0] = x[0], Y[1] = x[1], Y[2] = x[2], Y[3] = x[3], Y[4] = x[4], Y[5] = x[5], Y;
      }
      function e(Y) {
        return Y[0] = 1, Y[1] = 0, Y[2] = 0, Y[3] = 1, Y[4] = 0, Y[5] = 0, Y;
      }
      function a(Y, x, H, Q, w, O) {
        var q = new s.ARRAY_TYPE(6);
        return q[0] = Y, q[1] = x, q[2] = H, q[3] = Q, q[4] = w, q[5] = O, q;
      }
      function G(Y, x, H, Q, w, O, q) {
        return Y[0] = x, Y[1] = H, Y[2] = Q, Y[3] = w, Y[4] = O, Y[5] = q, Y;
      }
      function y(Y, x) {
        var H = x[0], Q = x[1], w = x[2], O = x[3], q = x[4], k = x[5], f = H * O - Q * w;
        return f ? (f = 1 / f, Y[0] = O * f, Y[1] = -Q * f, Y[2] = -w * f, Y[3] = H * f, Y[4] = (w * k - O * q) * f, Y[5] = (Q * q - H * k) * f, Y) : null;
      }
      function n(Y) {
        return Y[0] * Y[3] - Y[1] * Y[2];
      }
      function V(Y, x, H) {
        var Q = x[0], w = x[1], O = x[2], q = x[3], k = x[4], f = x[5], D = H[0], ii = H[1], _ = H[2], bi = H[3], $ = H[4], oi = H[5];
        return Y[0] = Q * D + O * ii, Y[1] = w * D + q * ii, Y[2] = Q * _ + O * bi, Y[3] = w * _ + q * bi, Y[4] = Q * $ + O * oi + k, Y[5] = w * $ + q * oi + f, Y;
      }
      function I(Y, x, H) {
        var Q = x[0], w = x[1], O = x[2], q = x[3], k = x[4], f = x[5], D = Math.sin(H), ii = Math.cos(H);
        return Y[0] = Q * ii + O * D, Y[1] = w * ii + q * D, Y[2] = Q * -D + O * ii, Y[3] = w * -D + q * ii, Y[4] = k, Y[5] = f, Y;
      }
      function r(Y, x, H) {
        var Q = x[0], w = x[1], O = x[2], q = x[3], k = x[4], f = x[5], D = H[0], ii = H[1];
        return Y[0] = Q * D, Y[1] = w * D, Y[2] = O * ii, Y[3] = q * ii, Y[4] = k, Y[5] = f, Y;
      }
      function p(Y, x, H) {
        var Q = x[0], w = x[1], O = x[2], q = x[3], k = x[4], f = x[5], D = H[0], ii = H[1];
        return Y[0] = Q, Y[1] = w, Y[2] = O, Y[3] = q, Y[4] = Q * D + O * ii + k, Y[5] = w * D + q * ii + f, Y;
      }
      function o(Y, x) {
        var H = Math.sin(x), Q = Math.cos(x);
        return Y[0] = Q, Y[1] = H, Y[2] = -H, Y[3] = Q, Y[4] = 0, Y[5] = 0, Y;
      }
      function u(Y, x) {
        return Y[0] = x[0], Y[1] = 0, Y[2] = 0, Y[3] = x[1], Y[4] = 0, Y[5] = 0, Y;
      }
      function d(Y, x) {
        return Y[0] = 1, Y[1] = 0, Y[2] = 0, Y[3] = 1, Y[4] = x[0], Y[5] = x[1], Y;
      }
      function b(Y) {
        return "mat2d(" + Y[0] + ", " + Y[1] + ", " + Y[2] + ", " + Y[3] + ", " + Y[4] + ", " + Y[5] + ")";
      }
      function t(Y) {
        return Math.hypot(Y[0], Y[1], Y[2], Y[3], Y[4], Y[5], 1);
      }
      function m(Y, x, H) {
        return Y[0] = x[0] + H[0], Y[1] = x[1] + H[1], Y[2] = x[2] + H[2], Y[3] = x[3] + H[3], Y[4] = x[4] + H[4], Y[5] = x[5] + H[5], Y;
      }
      function R(Y, x, H) {
        return Y[0] = x[0] - H[0], Y[1] = x[1] - H[1], Y[2] = x[2] - H[2], Y[3] = x[3] - H[3], Y[4] = x[4] - H[4], Y[5] = x[5] - H[5], Y;
      }
      function S(Y, x, H) {
        return Y[0] = x[0] * H, Y[1] = x[1] * H, Y[2] = x[2] * H, Y[3] = x[3] * H, Y[4] = x[4] * H, Y[5] = x[5] * H, Y;
      }
      function C(Y, x, H, Q) {
        return Y[0] = x[0] + H[0] * Q, Y[1] = x[1] + H[1] * Q, Y[2] = x[2] + H[2] * Q, Y[3] = x[3] + H[3] * Q, Y[4] = x[4] + H[4] * Q, Y[5] = x[5] + H[5] * Q, Y;
      }
      function F(Y, x) {
        return Y[0] === x[0] && Y[1] === x[1] && Y[2] === x[2] && Y[3] === x[3] && Y[4] === x[4] && Y[5] === x[5];
      }
      function K(Y, x) {
        var H = Y[0], Q = Y[1], w = Y[2], O = Y[3], q = Y[4], k = Y[5], f = x[0], D = x[1], ii = x[2], _ = x[3], bi = x[4], $ = x[5];
        return Math.abs(H - f) <= s.EPSILON * Math.max(1, Math.abs(H), Math.abs(f)) && Math.abs(Q - D) <= s.EPSILON * Math.max(1, Math.abs(Q), Math.abs(D)) && Math.abs(w - ii) <= s.EPSILON * Math.max(1, Math.abs(w), Math.abs(ii)) && Math.abs(O - _) <= s.EPSILON * Math.max(1, Math.abs(O), Math.abs(_)) && Math.abs(q - bi) <= s.EPSILON * Math.max(1, Math.abs(q), Math.abs(bi)) && Math.abs(k - $) <= s.EPSILON * Math.max(1, Math.abs(k), Math.abs($));
      }
      var J = V, T = R;
    },
    /* 5 */
    /***/
    function(Z, l, i) {
      i.r(l), i.d(l, "create", function() {
        return c;
      }), i.d(l, "fromMat4", function() {
        return W;
      }), i.d(l, "clone", function() {
        return h;
      }), i.d(l, "copy", function() {
        return e;
      }), i.d(l, "fromValues", function() {
        return a;
      }), i.d(l, "set", function() {
        return G;
      }), i.d(l, "identity", function() {
        return y;
      }), i.d(l, "transpose", function() {
        return n;
      }), i.d(l, "invert", function() {
        return V;
      }), i.d(l, "adjoint", function() {
        return I;
      }), i.d(l, "determinant", function() {
        return r;
      }), i.d(l, "multiply", function() {
        return p;
      }), i.d(l, "translate", function() {
        return o;
      }), i.d(l, "rotate", function() {
        return u;
      }), i.d(l, "scale", function() {
        return d;
      }), i.d(l, "fromTranslation", function() {
        return b;
      }), i.d(l, "fromRotation", function() {
        return t;
      }), i.d(l, "fromScaling", function() {
        return m;
      }), i.d(l, "fromMat2d", function() {
        return R;
      }), i.d(l, "fromQuat", function() {
        return S;
      }), i.d(l, "normalFromMat4", function() {
        return C;
      }), i.d(l, "projection", function() {
        return F;
      }), i.d(l, "str", function() {
        return K;
      }), i.d(l, "frob", function() {
        return J;
      }), i.d(l, "add", function() {
        return T;
      }), i.d(l, "subtract", function() {
        return Y;
      }), i.d(l, "multiplyScalar", function() {
        return x;
      }), i.d(l, "multiplyScalarAndAdd", function() {
        return H;
      }), i.d(l, "exactEquals", function() {
        return Q;
      }), i.d(l, "equals", function() {
        return w;
      }), i.d(l, "mul", function() {
        return O;
      }), i.d(l, "sub", function() {
        return q;
      });
      var s = i(2);
      function c() {
        var k = new s.ARRAY_TYPE(9);
        return s.ARRAY_TYPE != Float32Array && (k[1] = 0, k[2] = 0, k[3] = 0, k[5] = 0, k[6] = 0, k[7] = 0), k[0] = 1, k[4] = 1, k[8] = 1, k;
      }
      function W(k, f) {
        return k[0] = f[0], k[1] = f[1], k[2] = f[2], k[3] = f[4], k[4] = f[5], k[5] = f[6], k[6] = f[8], k[7] = f[9], k[8] = f[10], k;
      }
      function h(k) {
        var f = new s.ARRAY_TYPE(9);
        return f[0] = k[0], f[1] = k[1], f[2] = k[2], f[3] = k[3], f[4] = k[4], f[5] = k[5], f[6] = k[6], f[7] = k[7], f[8] = k[8], f;
      }
      function e(k, f) {
        return k[0] = f[0], k[1] = f[1], k[2] = f[2], k[3] = f[3], k[4] = f[4], k[5] = f[5], k[6] = f[6], k[7] = f[7], k[8] = f[8], k;
      }
      function a(k, f, D, ii, _, bi, $, oi, ni) {
        var z = new s.ARRAY_TYPE(9);
        return z[0] = k, z[1] = f, z[2] = D, z[3] = ii, z[4] = _, z[5] = bi, z[6] = $, z[7] = oi, z[8] = ni, z;
      }
      function G(k, f, D, ii, _, bi, $, oi, ni, z) {
        return k[0] = f, k[1] = D, k[2] = ii, k[3] = _, k[4] = bi, k[5] = $, k[6] = oi, k[7] = ni, k[8] = z, k;
      }
      function y(k) {
        return k[0] = 1, k[1] = 0, k[2] = 0, k[3] = 0, k[4] = 1, k[5] = 0, k[6] = 0, k[7] = 0, k[8] = 1, k;
      }
      function n(k, f) {
        if (k === f) {
          var D = f[1], ii = f[2], _ = f[5];
          k[1] = f[3], k[2] = f[6], k[3] = D, k[5] = f[7], k[6] = ii, k[7] = _;
        } else
          k[0] = f[0], k[1] = f[3], k[2] = f[6], k[3] = f[1], k[4] = f[4], k[5] = f[7], k[6] = f[2], k[7] = f[5], k[8] = f[8];
        return k;
      }
      function V(k, f) {
        var D = f[0], ii = f[1], _ = f[2], bi = f[3], $ = f[4], oi = f[5], ni = f[6], z = f[7], M = f[8], E = M * $ - oi * z, B = -M * bi + oi * ni, g = z * bi - $ * ni, U = D * E + ii * B + _ * g;
        return U ? (U = 1 / U, k[0] = E * U, k[1] = (-M * ii + _ * z) * U, k[2] = (oi * ii - _ * $) * U, k[3] = B * U, k[4] = (M * D - _ * ni) * U, k[5] = (-oi * D + _ * bi) * U, k[6] = g * U, k[7] = (-z * D + ii * ni) * U, k[8] = ($ * D - ii * bi) * U, k) : null;
      }
      function I(k, f) {
        var D = f[0], ii = f[1], _ = f[2], bi = f[3], $ = f[4], oi = f[5], ni = f[6], z = f[7], M = f[8];
        return k[0] = $ * M - oi * z, k[1] = _ * z - ii * M, k[2] = ii * oi - _ * $, k[3] = oi * ni - bi * M, k[4] = D * M - _ * ni, k[5] = _ * bi - D * oi, k[6] = bi * z - $ * ni, k[7] = ii * ni - D * z, k[8] = D * $ - ii * bi, k;
      }
      function r(k) {
        var f = k[0], D = k[1], ii = k[2], _ = k[3], bi = k[4], $ = k[5], oi = k[6], ni = k[7], z = k[8];
        return f * (z * bi - $ * ni) + D * (-z * _ + $ * oi) + ii * (ni * _ - bi * oi);
      }
      function p(k, f, D) {
        var ii = f[0], _ = f[1], bi = f[2], $ = f[3], oi = f[4], ni = f[5], z = f[6], M = f[7], E = f[8], B = D[0], g = D[1], U = D[2], X = D[3], L = D[4], N = D[5], v = D[6], P = D[7], j = D[8];
        return k[0] = B * ii + g * $ + U * z, k[1] = B * _ + g * oi + U * M, k[2] = B * bi + g * ni + U * E, k[3] = X * ii + L * $ + N * z, k[4] = X * _ + L * oi + N * M, k[5] = X * bi + L * ni + N * E, k[6] = v * ii + P * $ + j * z, k[7] = v * _ + P * oi + j * M, k[8] = v * bi + P * ni + j * E, k;
      }
      function o(k, f, D) {
        var ii = f[0], _ = f[1], bi = f[2], $ = f[3], oi = f[4], ni = f[5], z = f[6], M = f[7], E = f[8], B = D[0], g = D[1];
        return k[0] = ii, k[1] = _, k[2] = bi, k[3] = $, k[4] = oi, k[5] = ni, k[6] = B * ii + g * $ + z, k[7] = B * _ + g * oi + M, k[8] = B * bi + g * ni + E, k;
      }
      function u(k, f, D) {
        var ii = f[0], _ = f[1], bi = f[2], $ = f[3], oi = f[4], ni = f[5], z = f[6], M = f[7], E = f[8], B = Math.sin(D), g = Math.cos(D);
        return k[0] = g * ii + B * $, k[1] = g * _ + B * oi, k[2] = g * bi + B * ni, k[3] = g * $ - B * ii, k[4] = g * oi - B * _, k[5] = g * ni - B * bi, k[6] = z, k[7] = M, k[8] = E, k;
      }
      function d(k, f, D) {
        var ii = D[0], _ = D[1];
        return k[0] = ii * f[0], k[1] = ii * f[1], k[2] = ii * f[2], k[3] = _ * f[3], k[4] = _ * f[4], k[5] = _ * f[5], k[6] = f[6], k[7] = f[7], k[8] = f[8], k;
      }
      function b(k, f) {
        return k[0] = 1, k[1] = 0, k[2] = 0, k[3] = 0, k[4] = 1, k[5] = 0, k[6] = f[0], k[7] = f[1], k[8] = 1, k;
      }
      function t(k, f) {
        var D = Math.sin(f), ii = Math.cos(f);
        return k[0] = ii, k[1] = D, k[2] = 0, k[3] = -D, k[4] = ii, k[5] = 0, k[6] = 0, k[7] = 0, k[8] = 1, k;
      }
      function m(k, f) {
        return k[0] = f[0], k[1] = 0, k[2] = 0, k[3] = 0, k[4] = f[1], k[5] = 0, k[6] = 0, k[7] = 0, k[8] = 1, k;
      }
      function R(k, f) {
        return k[0] = f[0], k[1] = f[1], k[2] = 0, k[3] = f[2], k[4] = f[3], k[5] = 0, k[6] = f[4], k[7] = f[5], k[8] = 1, k;
      }
      function S(k, f) {
        var D = f[0], ii = f[1], _ = f[2], bi = f[3], $ = D + D, oi = ii + ii, ni = _ + _, z = D * $, M = ii * $, E = ii * oi, B = _ * $, g = _ * oi, U = _ * ni, X = bi * $, L = bi * oi, N = bi * ni;
        return k[0] = 1 - E - U, k[3] = M - N, k[6] = B + L, k[1] = M + N, k[4] = 1 - z - U, k[7] = g - X, k[2] = B - L, k[5] = g + X, k[8] = 1 - z - E, k;
      }
      function C(k, f) {
        var D = f[0], ii = f[1], _ = f[2], bi = f[3], $ = f[4], oi = f[5], ni = f[6], z = f[7], M = f[8], E = f[9], B = f[10], g = f[11], U = f[12], X = f[13], L = f[14], N = f[15], v = D * oi - ii * $, P = D * ni - _ * $, j = D * z - bi * $, A = ii * ni - _ * oi, li = ii * z - bi * oi, di = _ * z - bi * ni, ci = M * X - E * U, mi = M * L - B * U, ti = M * N - g * U, si = E * L - B * X, Zi = E * N - g * X, ai = B * N - g * L, ei = v * ai - P * Zi + j * si + A * ti - li * mi + di * ci;
        return ei ? (ei = 1 / ei, k[0] = (oi * ai - ni * Zi + z * si) * ei, k[1] = (ni * ti - $ * ai - z * mi) * ei, k[2] = ($ * Zi - oi * ti + z * ci) * ei, k[3] = (_ * Zi - ii * ai - bi * si) * ei, k[4] = (D * ai - _ * ti + bi * mi) * ei, k[5] = (ii * ti - D * Zi - bi * ci) * ei, k[6] = (X * di - L * li + N * A) * ei, k[7] = (L * j - U * di - N * P) * ei, k[8] = (U * li - X * j + N * v) * ei, k) : null;
      }
      function F(k, f, D) {
        return k[0] = 2 / f, k[1] = 0, k[2] = 0, k[3] = 0, k[4] = -2 / D, k[5] = 0, k[6] = -1, k[7] = 1, k[8] = 1, k;
      }
      function K(k) {
        return "mat3(" + k[0] + ", " + k[1] + ", " + k[2] + ", " + k[3] + ", " + k[4] + ", " + k[5] + ", " + k[6] + ", " + k[7] + ", " + k[8] + ")";
      }
      function J(k) {
        return Math.hypot(k[0], k[1], k[2], k[3], k[4], k[5], k[6], k[7], k[8]);
      }
      function T(k, f, D) {
        return k[0] = f[0] + D[0], k[1] = f[1] + D[1], k[2] = f[2] + D[2], k[3] = f[3] + D[3], k[4] = f[4] + D[4], k[5] = f[5] + D[5], k[6] = f[6] + D[6], k[7] = f[7] + D[7], k[8] = f[8] + D[8], k;
      }
      function Y(k, f, D) {
        return k[0] = f[0] - D[0], k[1] = f[1] - D[1], k[2] = f[2] - D[2], k[3] = f[3] - D[3], k[4] = f[4] - D[4], k[5] = f[5] - D[5], k[6] = f[6] - D[6], k[7] = f[7] - D[7], k[8] = f[8] - D[8], k;
      }
      function x(k, f, D) {
        return k[0] = f[0] * D, k[1] = f[1] * D, k[2] = f[2] * D, k[3] = f[3] * D, k[4] = f[4] * D, k[5] = f[5] * D, k[6] = f[6] * D, k[7] = f[7] * D, k[8] = f[8] * D, k;
      }
      function H(k, f, D, ii) {
        return k[0] = f[0] + D[0] * ii, k[1] = f[1] + D[1] * ii, k[2] = f[2] + D[2] * ii, k[3] = f[3] + D[3] * ii, k[4] = f[4] + D[4] * ii, k[5] = f[5] + D[5] * ii, k[6] = f[6] + D[6] * ii, k[7] = f[7] + D[7] * ii, k[8] = f[8] + D[8] * ii, k;
      }
      function Q(k, f) {
        return k[0] === f[0] && k[1] === f[1] && k[2] === f[2] && k[3] === f[3] && k[4] === f[4] && k[5] === f[5] && k[6] === f[6] && k[7] === f[7] && k[8] === f[8];
      }
      function w(k, f) {
        var D = k[0], ii = k[1], _ = k[2], bi = k[3], $ = k[4], oi = k[5], ni = k[6], z = k[7], M = k[8], E = f[0], B = f[1], g = f[2], U = f[3], X = f[4], L = f[5], N = f[6], v = f[7], P = f[8];
        return Math.abs(D - E) <= s.EPSILON * Math.max(1, Math.abs(D), Math.abs(E)) && Math.abs(ii - B) <= s.EPSILON * Math.max(1, Math.abs(ii), Math.abs(B)) && Math.abs(_ - g) <= s.EPSILON * Math.max(1, Math.abs(_), Math.abs(g)) && Math.abs(bi - U) <= s.EPSILON * Math.max(1, Math.abs(bi), Math.abs(U)) && Math.abs($ - X) <= s.EPSILON * Math.max(1, Math.abs($), Math.abs(X)) && Math.abs(oi - L) <= s.EPSILON * Math.max(1, Math.abs(oi), Math.abs(L)) && Math.abs(ni - N) <= s.EPSILON * Math.max(1, Math.abs(ni), Math.abs(N)) && Math.abs(z - v) <= s.EPSILON * Math.max(1, Math.abs(z), Math.abs(v)) && Math.abs(M - P) <= s.EPSILON * Math.max(1, Math.abs(M), Math.abs(P));
      }
      var O = p, q = Y;
    },
    /* 6 */
    /***/
    function(Z, l, i) {
      i.r(l), i.d(l, "create", function() {
        return c;
      }), i.d(l, "clone", function() {
        return W;
      }), i.d(l, "copy", function() {
        return h;
      }), i.d(l, "fromValues", function() {
        return e;
      }), i.d(l, "set", function() {
        return a;
      }), i.d(l, "identity", function() {
        return G;
      }), i.d(l, "transpose", function() {
        return y;
      }), i.d(l, "invert", function() {
        return n;
      }), i.d(l, "adjoint", function() {
        return V;
      }), i.d(l, "determinant", function() {
        return I;
      }), i.d(l, "multiply", function() {
        return r;
      }), i.d(l, "translate", function() {
        return p;
      }), i.d(l, "scale", function() {
        return o;
      }), i.d(l, "rotate", function() {
        return u;
      }), i.d(l, "rotateX", function() {
        return d;
      }), i.d(l, "rotateY", function() {
        return b;
      }), i.d(l, "rotateZ", function() {
        return t;
      }), i.d(l, "fromTranslation", function() {
        return m;
      }), i.d(l, "fromScaling", function() {
        return R;
      }), i.d(l, "fromRotation", function() {
        return S;
      }), i.d(l, "fromXRotation", function() {
        return C;
      }), i.d(l, "fromYRotation", function() {
        return F;
      }), i.d(l, "fromZRotation", function() {
        return K;
      }), i.d(l, "fromRotationTranslation", function() {
        return J;
      }), i.d(l, "fromQuat2", function() {
        return T;
      }), i.d(l, "getTranslation", function() {
        return Y;
      }), i.d(l, "getScaling", function() {
        return x;
      }), i.d(l, "getRotation", function() {
        return H;
      }), i.d(l, "fromRotationTranslationScale", function() {
        return Q;
      }), i.d(l, "fromRotationTranslationScaleOrigin", function() {
        return w;
      }), i.d(l, "fromQuat", function() {
        return O;
      }), i.d(l, "frustum", function() {
        return q;
      }), i.d(l, "perspective", function() {
        return k;
      }), i.d(l, "perspectiveFromFieldOfView", function() {
        return f;
      }), i.d(l, "ortho", function() {
        return D;
      }), i.d(l, "lookAt", function() {
        return ii;
      }), i.d(l, "targetTo", function() {
        return _;
      }), i.d(l, "str", function() {
        return bi;
      }), i.d(l, "frob", function() {
        return $;
      }), i.d(l, "add", function() {
        return oi;
      }), i.d(l, "subtract", function() {
        return ni;
      }), i.d(l, "multiplyScalar", function() {
        return z;
      }), i.d(l, "multiplyScalarAndAdd", function() {
        return M;
      }), i.d(l, "exactEquals", function() {
        return E;
      }), i.d(l, "equals", function() {
        return B;
      }), i.d(l, "mul", function() {
        return g;
      }), i.d(l, "sub", function() {
        return U;
      });
      var s = i(2);
      function c() {
        var X = new s.ARRAY_TYPE(16);
        return s.ARRAY_TYPE != Float32Array && (X[1] = 0, X[2] = 0, X[3] = 0, X[4] = 0, X[6] = 0, X[7] = 0, X[8] = 0, X[9] = 0, X[11] = 0, X[12] = 0, X[13] = 0, X[14] = 0), X[0] = 1, X[5] = 1, X[10] = 1, X[15] = 1, X;
      }
      function W(X) {
        var L = new s.ARRAY_TYPE(16);
        return L[0] = X[0], L[1] = X[1], L[2] = X[2], L[3] = X[3], L[4] = X[4], L[5] = X[5], L[6] = X[6], L[7] = X[7], L[8] = X[8], L[9] = X[9], L[10] = X[10], L[11] = X[11], L[12] = X[12], L[13] = X[13], L[14] = X[14], L[15] = X[15], L;
      }
      function h(X, L) {
        return X[0] = L[0], X[1] = L[1], X[2] = L[2], X[3] = L[3], X[4] = L[4], X[5] = L[5], X[6] = L[6], X[7] = L[7], X[8] = L[8], X[9] = L[9], X[10] = L[10], X[11] = L[11], X[12] = L[12], X[13] = L[13], X[14] = L[14], X[15] = L[15], X;
      }
      function e(X, L, N, v, P, j, A, li, di, ci, mi, ti, si, Zi, ai, ei) {
        var Xi = new s.ARRAY_TYPE(16);
        return Xi[0] = X, Xi[1] = L, Xi[2] = N, Xi[3] = v, Xi[4] = P, Xi[5] = j, Xi[6] = A, Xi[7] = li, Xi[8] = di, Xi[9] = ci, Xi[10] = mi, Xi[11] = ti, Xi[12] = si, Xi[13] = Zi, Xi[14] = ai, Xi[15] = ei, Xi;
      }
      function a(X, L, N, v, P, j, A, li, di, ci, mi, ti, si, Zi, ai, ei, Xi) {
        return X[0] = L, X[1] = N, X[2] = v, X[3] = P, X[4] = j, X[5] = A, X[6] = li, X[7] = di, X[8] = ci, X[9] = mi, X[10] = ti, X[11] = si, X[12] = Zi, X[13] = ai, X[14] = ei, X[15] = Xi, X;
      }
      function G(X) {
        return X[0] = 1, X[1] = 0, X[2] = 0, X[3] = 0, X[4] = 0, X[5] = 1, X[6] = 0, X[7] = 0, X[8] = 0, X[9] = 0, X[10] = 1, X[11] = 0, X[12] = 0, X[13] = 0, X[14] = 0, X[15] = 1, X;
      }
      function y(X, L) {
        if (X === L) {
          var N = L[1], v = L[2], P = L[3], j = L[6], A = L[7], li = L[11];
          X[1] = L[4], X[2] = L[8], X[3] = L[12], X[4] = N, X[6] = L[9], X[7] = L[13], X[8] = v, X[9] = j, X[11] = L[14], X[12] = P, X[13] = A, X[14] = li;
        } else
          X[0] = L[0], X[1] = L[4], X[2] = L[8], X[3] = L[12], X[4] = L[1], X[5] = L[5], X[6] = L[9], X[7] = L[13], X[8] = L[2], X[9] = L[6], X[10] = L[10], X[11] = L[14], X[12] = L[3], X[13] = L[7], X[14] = L[11], X[15] = L[15];
        return X;
      }
      function n(X, L) {
        var N = L[0], v = L[1], P = L[2], j = L[3], A = L[4], li = L[5], di = L[6], ci = L[7], mi = L[8], ti = L[9], si = L[10], Zi = L[11], ai = L[12], ei = L[13], Xi = L[14], ui = L[15], ri = N * li - v * A, yi = N * di - P * A, Ki = N * ci - j * A, Ri = v * di - P * li, xi = v * ci - j * li, Ui = P * ci - j * di, Mi = mi * ei - ti * ai, ki = mi * Xi - si * ai, vi = mi * ui - Zi * ai, Qi = ti * Xi - si * ei, fi = ti * ui - Zi * ei, Pi = si * ui - Zi * Xi, Ci = ri * Pi - yi * fi + Ki * Qi + Ri * vi - xi * ki + Ui * Mi;
        return Ci ? (Ci = 1 / Ci, X[0] = (li * Pi - di * fi + ci * Qi) * Ci, X[1] = (P * fi - v * Pi - j * Qi) * Ci, X[2] = (ei * Ui - Xi * xi + ui * Ri) * Ci, X[3] = (si * xi - ti * Ui - Zi * Ri) * Ci, X[4] = (di * vi - A * Pi - ci * ki) * Ci, X[5] = (N * Pi - P * vi + j * ki) * Ci, X[6] = (Xi * Ki - ai * Ui - ui * yi) * Ci, X[7] = (mi * Ui - si * Ki + Zi * yi) * Ci, X[8] = (A * fi - li * vi + ci * Mi) * Ci, X[9] = (v * vi - N * fi - j * Mi) * Ci, X[10] = (ai * xi - ei * Ki + ui * ri) * Ci, X[11] = (ti * Ki - mi * xi - Zi * ri) * Ci, X[12] = (li * ki - A * Qi - di * Mi) * Ci, X[13] = (N * Qi - v * ki + P * Mi) * Ci, X[14] = (ei * yi - ai * Ri - Xi * ri) * Ci, X[15] = (mi * Ri - ti * yi + si * ri) * Ci, X) : null;
      }
      function V(X, L) {
        var N = L[0], v = L[1], P = L[2], j = L[3], A = L[4], li = L[5], di = L[6], ci = L[7], mi = L[8], ti = L[9], si = L[10], Zi = L[11], ai = L[12], ei = L[13], Xi = L[14], ui = L[15];
        return X[0] = li * (si * ui - Zi * Xi) - ti * (di * ui - ci * Xi) + ei * (di * Zi - ci * si), X[1] = -(v * (si * ui - Zi * Xi) - ti * (P * ui - j * Xi) + ei * (P * Zi - j * si)), X[2] = v * (di * ui - ci * Xi) - li * (P * ui - j * Xi) + ei * (P * ci - j * di), X[3] = -(v * (di * Zi - ci * si) - li * (P * Zi - j * si) + ti * (P * ci - j * di)), X[4] = -(A * (si * ui - Zi * Xi) - mi * (di * ui - ci * Xi) + ai * (di * Zi - ci * si)), X[5] = N * (si * ui - Zi * Xi) - mi * (P * ui - j * Xi) + ai * (P * Zi - j * si), X[6] = -(N * (di * ui - ci * Xi) - A * (P * ui - j * Xi) + ai * (P * ci - j * di)), X[7] = N * (di * Zi - ci * si) - A * (P * Zi - j * si) + mi * (P * ci - j * di), X[8] = A * (ti * ui - Zi * ei) - mi * (li * ui - ci * ei) + ai * (li * Zi - ci * ti), X[9] = -(N * (ti * ui - Zi * ei) - mi * (v * ui - j * ei) + ai * (v * Zi - j * ti)), X[10] = N * (li * ui - ci * ei) - A * (v * ui - j * ei) + ai * (v * ci - j * li), X[11] = -(N * (li * Zi - ci * ti) - A * (v * Zi - j * ti) + mi * (v * ci - j * li)), X[12] = -(A * (ti * Xi - si * ei) - mi * (li * Xi - di * ei) + ai * (li * si - di * ti)), X[13] = N * (ti * Xi - si * ei) - mi * (v * Xi - P * ei) + ai * (v * si - P * ti), X[14] = -(N * (li * Xi - di * ei) - A * (v * Xi - P * ei) + ai * (v * di - P * li)), X[15] = N * (li * si - di * ti) - A * (v * si - P * ti) + mi * (v * di - P * li), X;
      }
      function I(X) {
        var L = X[0], N = X[1], v = X[2], P = X[3], j = X[4], A = X[5], li = X[6], di = X[7], ci = X[8], mi = X[9], ti = X[10], si = X[11], Zi = X[12], ai = X[13], ei = X[14], Xi = X[15], ui = L * A - N * j, ri = L * li - v * j, yi = L * di - P * j, Ki = N * li - v * A, Ri = N * di - P * A, xi = v * di - P * li, Ui = ci * ai - mi * Zi, Mi = ci * ei - ti * Zi, ki = ci * Xi - si * Zi, vi = mi * ei - ti * ai, Qi = mi * Xi - si * ai, fi = ti * Xi - si * ei;
        return ui * fi - ri * Qi + yi * vi + Ki * ki - Ri * Mi + xi * Ui;
      }
      function r(X, L, N) {
        var v = L[0], P = L[1], j = L[2], A = L[3], li = L[4], di = L[5], ci = L[6], mi = L[7], ti = L[8], si = L[9], Zi = L[10], ai = L[11], ei = L[12], Xi = L[13], ui = L[14], ri = L[15], yi = N[0], Ki = N[1], Ri = N[2], xi = N[3];
        return X[0] = yi * v + Ki * li + Ri * ti + xi * ei, X[1] = yi * P + Ki * di + Ri * si + xi * Xi, X[2] = yi * j + Ki * ci + Ri * Zi + xi * ui, X[3] = yi * A + Ki * mi + Ri * ai + xi * ri, yi = N[4], Ki = N[5], Ri = N[6], xi = N[7], X[4] = yi * v + Ki * li + Ri * ti + xi * ei, X[5] = yi * P + Ki * di + Ri * si + xi * Xi, X[6] = yi * j + Ki * ci + Ri * Zi + xi * ui, X[7] = yi * A + Ki * mi + Ri * ai + xi * ri, yi = N[8], Ki = N[9], Ri = N[10], xi = N[11], X[8] = yi * v + Ki * li + Ri * ti + xi * ei, X[9] = yi * P + Ki * di + Ri * si + xi * Xi, X[10] = yi * j + Ki * ci + Ri * Zi + xi * ui, X[11] = yi * A + Ki * mi + Ri * ai + xi * ri, yi = N[12], Ki = N[13], Ri = N[14], xi = N[15], X[12] = yi * v + Ki * li + Ri * ti + xi * ei, X[13] = yi * P + Ki * di + Ri * si + xi * Xi, X[14] = yi * j + Ki * ci + Ri * Zi + xi * ui, X[15] = yi * A + Ki * mi + Ri * ai + xi * ri, X;
      }
      function p(X, L, N) {
        var v = N[0], P = N[1], j = N[2], A, li, di, ci, mi, ti, si, Zi, ai, ei, Xi, ui;
        return L === X ? (X[12] = L[0] * v + L[4] * P + L[8] * j + L[12], X[13] = L[1] * v + L[5] * P + L[9] * j + L[13], X[14] = L[2] * v + L[6] * P + L[10] * j + L[14], X[15] = L[3] * v + L[7] * P + L[11] * j + L[15]) : (A = L[0], li = L[1], di = L[2], ci = L[3], mi = L[4], ti = L[5], si = L[6], Zi = L[7], ai = L[8], ei = L[9], Xi = L[10], ui = L[11], X[0] = A, X[1] = li, X[2] = di, X[3] = ci, X[4] = mi, X[5] = ti, X[6] = si, X[7] = Zi, X[8] = ai, X[9] = ei, X[10] = Xi, X[11] = ui, X[12] = A * v + mi * P + ai * j + L[12], X[13] = li * v + ti * P + ei * j + L[13], X[14] = di * v + si * P + Xi * j + L[14], X[15] = ci * v + Zi * P + ui * j + L[15]), X;
      }
      function o(X, L, N) {
        var v = N[0], P = N[1], j = N[2];
        return X[0] = L[0] * v, X[1] = L[1] * v, X[2] = L[2] * v, X[3] = L[3] * v, X[4] = L[4] * P, X[5] = L[5] * P, X[6] = L[6] * P, X[7] = L[7] * P, X[8] = L[8] * j, X[9] = L[9] * j, X[10] = L[10] * j, X[11] = L[11] * j, X[12] = L[12], X[13] = L[13], X[14] = L[14], X[15] = L[15], X;
      }
      function u(X, L, N, v) {
        var P = v[0], j = v[1], A = v[2], li = Math.hypot(P, j, A), di, ci, mi, ti, si, Zi, ai, ei, Xi, ui, ri, yi, Ki, Ri, xi, Ui, Mi, ki, vi, Qi, fi, Pi, Ci, ji;
        return li < s.EPSILON ? null : (li = 1 / li, P *= li, j *= li, A *= li, di = Math.sin(N), ci = Math.cos(N), mi = 1 - ci, ti = L[0], si = L[1], Zi = L[2], ai = L[3], ei = L[4], Xi = L[5], ui = L[6], ri = L[7], yi = L[8], Ki = L[9], Ri = L[10], xi = L[11], Ui = P * P * mi + ci, Mi = j * P * mi + A * di, ki = A * P * mi - j * di, vi = P * j * mi - A * di, Qi = j * j * mi + ci, fi = A * j * mi + P * di, Pi = P * A * mi + j * di, Ci = j * A * mi - P * di, ji = A * A * mi + ci, X[0] = ti * Ui + ei * Mi + yi * ki, X[1] = si * Ui + Xi * Mi + Ki * ki, X[2] = Zi * Ui + ui * Mi + Ri * ki, X[3] = ai * Ui + ri * Mi + xi * ki, X[4] = ti * vi + ei * Qi + yi * fi, X[5] = si * vi + Xi * Qi + Ki * fi, X[6] = Zi * vi + ui * Qi + Ri * fi, X[7] = ai * vi + ri * Qi + xi * fi, X[8] = ti * Pi + ei * Ci + yi * ji, X[9] = si * Pi + Xi * Ci + Ki * ji, X[10] = Zi * Pi + ui * Ci + Ri * ji, X[11] = ai * Pi + ri * Ci + xi * ji, L !== X && (X[12] = L[12], X[13] = L[13], X[14] = L[14], X[15] = L[15]), X);
      }
      function d(X, L, N) {
        var v = Math.sin(N), P = Math.cos(N), j = L[4], A = L[5], li = L[6], di = L[7], ci = L[8], mi = L[9], ti = L[10], si = L[11];
        return L !== X && (X[0] = L[0], X[1] = L[1], X[2] = L[2], X[3] = L[3], X[12] = L[12], X[13] = L[13], X[14] = L[14], X[15] = L[15]), X[4] = j * P + ci * v, X[5] = A * P + mi * v, X[6] = li * P + ti * v, X[7] = di * P + si * v, X[8] = ci * P - j * v, X[9] = mi * P - A * v, X[10] = ti * P - li * v, X[11] = si * P - di * v, X;
      }
      function b(X, L, N) {
        var v = Math.sin(N), P = Math.cos(N), j = L[0], A = L[1], li = L[2], di = L[3], ci = L[8], mi = L[9], ti = L[10], si = L[11];
        return L !== X && (X[4] = L[4], X[5] = L[5], X[6] = L[6], X[7] = L[7], X[12] = L[12], X[13] = L[13], X[14] = L[14], X[15] = L[15]), X[0] = j * P - ci * v, X[1] = A * P - mi * v, X[2] = li * P - ti * v, X[3] = di * P - si * v, X[8] = j * v + ci * P, X[9] = A * v + mi * P, X[10] = li * v + ti * P, X[11] = di * v + si * P, X;
      }
      function t(X, L, N) {
        var v = Math.sin(N), P = Math.cos(N), j = L[0], A = L[1], li = L[2], di = L[3], ci = L[4], mi = L[5], ti = L[6], si = L[7];
        return L !== X && (X[8] = L[8], X[9] = L[9], X[10] = L[10], X[11] = L[11], X[12] = L[12], X[13] = L[13], X[14] = L[14], X[15] = L[15]), X[0] = j * P + ci * v, X[1] = A * P + mi * v, X[2] = li * P + ti * v, X[3] = di * P + si * v, X[4] = ci * P - j * v, X[5] = mi * P - A * v, X[6] = ti * P - li * v, X[7] = si * P - di * v, X;
      }
      function m(X, L) {
        return X[0] = 1, X[1] = 0, X[2] = 0, X[3] = 0, X[4] = 0, X[5] = 1, X[6] = 0, X[7] = 0, X[8] = 0, X[9] = 0, X[10] = 1, X[11] = 0, X[12] = L[0], X[13] = L[1], X[14] = L[2], X[15] = 1, X;
      }
      function R(X, L) {
        return X[0] = L[0], X[1] = 0, X[2] = 0, X[3] = 0, X[4] = 0, X[5] = L[1], X[6] = 0, X[7] = 0, X[8] = 0, X[9] = 0, X[10] = L[2], X[11] = 0, X[12] = 0, X[13] = 0, X[14] = 0, X[15] = 1, X;
      }
      function S(X, L, N) {
        var v = N[0], P = N[1], j = N[2], A = Math.hypot(v, P, j), li, di, ci;
        return A < s.EPSILON ? null : (A = 1 / A, v *= A, P *= A, j *= A, li = Math.sin(L), di = Math.cos(L), ci = 1 - di, X[0] = v * v * ci + di, X[1] = P * v * ci + j * li, X[2] = j * v * ci - P * li, X[3] = 0, X[4] = v * P * ci - j * li, X[5] = P * P * ci + di, X[6] = j * P * ci + v * li, X[7] = 0, X[8] = v * j * ci + P * li, X[9] = P * j * ci - v * li, X[10] = j * j * ci + di, X[11] = 0, X[12] = 0, X[13] = 0, X[14] = 0, X[15] = 1, X);
      }
      function C(X, L) {
        var N = Math.sin(L), v = Math.cos(L);
        return X[0] = 1, X[1] = 0, X[2] = 0, X[3] = 0, X[4] = 0, X[5] = v, X[6] = N, X[7] = 0, X[8] = 0, X[9] = -N, X[10] = v, X[11] = 0, X[12] = 0, X[13] = 0, X[14] = 0, X[15] = 1, X;
      }
      function F(X, L) {
        var N = Math.sin(L), v = Math.cos(L);
        return X[0] = v, X[1] = 0, X[2] = -N, X[3] = 0, X[4] = 0, X[5] = 1, X[6] = 0, X[7] = 0, X[8] = N, X[9] = 0, X[10] = v, X[11] = 0, X[12] = 0, X[13] = 0, X[14] = 0, X[15] = 1, X;
      }
      function K(X, L) {
        var N = Math.sin(L), v = Math.cos(L);
        return X[0] = v, X[1] = N, X[2] = 0, X[3] = 0, X[4] = -N, X[5] = v, X[6] = 0, X[7] = 0, X[8] = 0, X[9] = 0, X[10] = 1, X[11] = 0, X[12] = 0, X[13] = 0, X[14] = 0, X[15] = 1, X;
      }
      function J(X, L, N) {
        var v = L[0], P = L[1], j = L[2], A = L[3], li = v + v, di = P + P, ci = j + j, mi = v * li, ti = v * di, si = v * ci, Zi = P * di, ai = P * ci, ei = j * ci, Xi = A * li, ui = A * di, ri = A * ci;
        return X[0] = 1 - (Zi + ei), X[1] = ti + ri, X[2] = si - ui, X[3] = 0, X[4] = ti - ri, X[5] = 1 - (mi + ei), X[6] = ai + Xi, X[7] = 0, X[8] = si + ui, X[9] = ai - Xi, X[10] = 1 - (mi + Zi), X[11] = 0, X[12] = N[0], X[13] = N[1], X[14] = N[2], X[15] = 1, X;
      }
      function T(X, L) {
        var N = new s.ARRAY_TYPE(3), v = -L[0], P = -L[1], j = -L[2], A = L[3], li = L[4], di = L[5], ci = L[6], mi = L[7], ti = v * v + P * P + j * j + A * A;
        return ti > 0 ? (N[0] = (li * A + mi * v + di * j - ci * P) * 2 / ti, N[1] = (di * A + mi * P + ci * v - li * j) * 2 / ti, N[2] = (ci * A + mi * j + li * P - di * v) * 2 / ti) : (N[0] = (li * A + mi * v + di * j - ci * P) * 2, N[1] = (di * A + mi * P + ci * v - li * j) * 2, N[2] = (ci * A + mi * j + li * P - di * v) * 2), J(X, L, N), X;
      }
      function Y(X, L) {
        return X[0] = L[12], X[1] = L[13], X[2] = L[14], X;
      }
      function x(X, L) {
        var N = L[0], v = L[1], P = L[2], j = L[4], A = L[5], li = L[6], di = L[8], ci = L[9], mi = L[10];
        return X[0] = Math.hypot(N, v, P), X[1] = Math.hypot(j, A, li), X[2] = Math.hypot(di, ci, mi), X;
      }
      function H(X, L) {
        var N = new s.ARRAY_TYPE(3);
        x(N, L);
        var v = 1 / N[0], P = 1 / N[1], j = 1 / N[2], A = L[0] * v, li = L[1] * P, di = L[2] * j, ci = L[4] * v, mi = L[5] * P, ti = L[6] * j, si = L[8] * v, Zi = L[9] * P, ai = L[10] * j, ei = A + mi + ai, Xi = 0;
        return ei > 0 ? (Xi = Math.sqrt(ei + 1) * 2, X[3] = 0.25 * Xi, X[0] = (ti - Zi) / Xi, X[1] = (si - di) / Xi, X[2] = (li - ci) / Xi) : A > mi && A > ai ? (Xi = Math.sqrt(1 + A - mi - ai) * 2, X[3] = (ti - Zi) / Xi, X[0] = 0.25 * Xi, X[1] = (li + ci) / Xi, X[2] = (si + di) / Xi) : mi > ai ? (Xi = Math.sqrt(1 + mi - A - ai) * 2, X[3] = (si - di) / Xi, X[0] = (li + ci) / Xi, X[1] = 0.25 * Xi, X[2] = (ti + Zi) / Xi) : (Xi = Math.sqrt(1 + ai - A - mi) * 2, X[3] = (li - ci) / Xi, X[0] = (si + di) / Xi, X[1] = (ti + Zi) / Xi, X[2] = 0.25 * Xi), X;
      }
      function Q(X, L, N, v) {
        var P = L[0], j = L[1], A = L[2], li = L[3], di = P + P, ci = j + j, mi = A + A, ti = P * di, si = P * ci, Zi = P * mi, ai = j * ci, ei = j * mi, Xi = A * mi, ui = li * di, ri = li * ci, yi = li * mi, Ki = v[0], Ri = v[1], xi = v[2];
        return X[0] = (1 - (ai + Xi)) * Ki, X[1] = (si + yi) * Ki, X[2] = (Zi - ri) * Ki, X[3] = 0, X[4] = (si - yi) * Ri, X[5] = (1 - (ti + Xi)) * Ri, X[6] = (ei + ui) * Ri, X[7] = 0, X[8] = (Zi + ri) * xi, X[9] = (ei - ui) * xi, X[10] = (1 - (ti + ai)) * xi, X[11] = 0, X[12] = N[0], X[13] = N[1], X[14] = N[2], X[15] = 1, X;
      }
      function w(X, L, N, v, P) {
        var j = L[0], A = L[1], li = L[2], di = L[3], ci = j + j, mi = A + A, ti = li + li, si = j * ci, Zi = j * mi, ai = j * ti, ei = A * mi, Xi = A * ti, ui = li * ti, ri = di * ci, yi = di * mi, Ki = di * ti, Ri = v[0], xi = v[1], Ui = v[2], Mi = P[0], ki = P[1], vi = P[2], Qi = (1 - (ei + ui)) * Ri, fi = (Zi + Ki) * Ri, Pi = (ai - yi) * Ri, Ci = (Zi - Ki) * xi, ji = (1 - (si + ui)) * xi, Wl = (Xi + ri) * xi, Gl = (ai + yi) * Ui, nd = (Xi - ri) * Ui, Xd = (1 - (si + ei)) * Ui;
        return X[0] = Qi, X[1] = fi, X[2] = Pi, X[3] = 0, X[4] = Ci, X[5] = ji, X[6] = Wl, X[7] = 0, X[8] = Gl, X[9] = nd, X[10] = Xd, X[11] = 0, X[12] = N[0] + Mi - (Qi * Mi + Ci * ki + Gl * vi), X[13] = N[1] + ki - (fi * Mi + ji * ki + nd * vi), X[14] = N[2] + vi - (Pi * Mi + Wl * ki + Xd * vi), X[15] = 1, X;
      }
      function O(X, L) {
        var N = L[0], v = L[1], P = L[2], j = L[3], A = N + N, li = v + v, di = P + P, ci = N * A, mi = v * A, ti = v * li, si = P * A, Zi = P * li, ai = P * di, ei = j * A, Xi = j * li, ui = j * di;
        return X[0] = 1 - ti - ai, X[1] = mi + ui, X[2] = si - Xi, X[3] = 0, X[4] = mi - ui, X[5] = 1 - ci - ai, X[6] = Zi + ei, X[7] = 0, X[8] = si + Xi, X[9] = Zi - ei, X[10] = 1 - ci - ti, X[11] = 0, X[12] = 0, X[13] = 0, X[14] = 0, X[15] = 1, X;
      }
      function q(X, L, N, v, P, j, A) {
        var li = 1 / (N - L), di = 1 / (P - v), ci = 1 / (j - A);
        return X[0] = j * 2 * li, X[1] = 0, X[2] = 0, X[3] = 0, X[4] = 0, X[5] = j * 2 * di, X[6] = 0, X[7] = 0, X[8] = (N + L) * li, X[9] = (P + v) * di, X[10] = (A + j) * ci, X[11] = -1, X[12] = 0, X[13] = 0, X[14] = A * j * 2 * ci, X[15] = 0, X;
      }
      function k(X, L, N, v, P) {
        var j = 1 / Math.tan(L / 2), A;
        return X[0] = j / N, X[1] = 0, X[2] = 0, X[3] = 0, X[4] = 0, X[5] = j, X[6] = 0, X[7] = 0, X[8] = 0, X[9] = 0, X[11] = -1, X[12] = 0, X[13] = 0, X[15] = 0, P != null && P !== 1 / 0 ? (A = 1 / (v - P), X[10] = (P + v) * A, X[14] = 2 * P * v * A) : (X[10] = -1, X[14] = -2 * v), X;
      }
      function f(X, L, N, v) {
        var P = Math.tan(L.upDegrees * Math.PI / 180), j = Math.tan(L.downDegrees * Math.PI / 180), A = Math.tan(L.leftDegrees * Math.PI / 180), li = Math.tan(L.rightDegrees * Math.PI / 180), di = 2 / (A + li), ci = 2 / (P + j);
        return X[0] = di, X[1] = 0, X[2] = 0, X[3] = 0, X[4] = 0, X[5] = ci, X[6] = 0, X[7] = 0, X[8] = -((A - li) * di * 0.5), X[9] = (P - j) * ci * 0.5, X[10] = v / (N - v), X[11] = -1, X[12] = 0, X[13] = 0, X[14] = v * N / (N - v), X[15] = 0, X;
      }
      function D(X, L, N, v, P, j, A) {
        var li = 1 / (L - N), di = 1 / (v - P), ci = 1 / (j - A);
        return X[0] = -2 * li, X[1] = 0, X[2] = 0, X[3] = 0, X[4] = 0, X[5] = -2 * di, X[6] = 0, X[7] = 0, X[8] = 0, X[9] = 0, X[10] = 2 * ci, X[11] = 0, X[12] = (L + N) * li, X[13] = (P + v) * di, X[14] = (A + j) * ci, X[15] = 1, X;
      }
      function ii(X, L, N, v) {
        var P, j, A, li, di, ci, mi, ti, si, Zi, ai = L[0], ei = L[1], Xi = L[2], ui = v[0], ri = v[1], yi = v[2], Ki = N[0], Ri = N[1], xi = N[2];
        return Math.abs(ai - Ki) < s.EPSILON && Math.abs(ei - Ri) < s.EPSILON && Math.abs(Xi - xi) < s.EPSILON ? G(X) : (mi = ai - Ki, ti = ei - Ri, si = Xi - xi, Zi = 1 / Math.hypot(mi, ti, si), mi *= Zi, ti *= Zi, si *= Zi, P = ri * si - yi * ti, j = yi * mi - ui * si, A = ui * ti - ri * mi, Zi = Math.hypot(P, j, A), Zi ? (Zi = 1 / Zi, P *= Zi, j *= Zi, A *= Zi) : (P = 0, j = 0, A = 0), li = ti * A - si * j, di = si * P - mi * A, ci = mi * j - ti * P, Zi = Math.hypot(li, di, ci), Zi ? (Zi = 1 / Zi, li *= Zi, di *= Zi, ci *= Zi) : (li = 0, di = 0, ci = 0), X[0] = P, X[1] = li, X[2] = mi, X[3] = 0, X[4] = j, X[5] = di, X[6] = ti, X[7] = 0, X[8] = A, X[9] = ci, X[10] = si, X[11] = 0, X[12] = -(P * ai + j * ei + A * Xi), X[13] = -(li * ai + di * ei + ci * Xi), X[14] = -(mi * ai + ti * ei + si * Xi), X[15] = 1, X);
      }
      function _(X, L, N, v) {
        var P = L[0], j = L[1], A = L[2], li = v[0], di = v[1], ci = v[2], mi = P - N[0], ti = j - N[1], si = A - N[2], Zi = mi * mi + ti * ti + si * si;
        Zi > 0 && (Zi = 1 / Math.sqrt(Zi), mi *= Zi, ti *= Zi, si *= Zi);
        var ai = di * si - ci * ti, ei = ci * mi - li * si, Xi = li * ti - di * mi;
        return Zi = ai * ai + ei * ei + Xi * Xi, Zi > 0 && (Zi = 1 / Math.sqrt(Zi), ai *= Zi, ei *= Zi, Xi *= Zi), X[0] = ai, X[1] = ei, X[2] = Xi, X[3] = 0, X[4] = ti * Xi - si * ei, X[5] = si * ai - mi * Xi, X[6] = mi * ei - ti * ai, X[7] = 0, X[8] = mi, X[9] = ti, X[10] = si, X[11] = 0, X[12] = P, X[13] = j, X[14] = A, X[15] = 1, X;
      }
      function bi(X) {
        return "mat4(" + X[0] + ", " + X[1] + ", " + X[2] + ", " + X[3] + ", " + X[4] + ", " + X[5] + ", " + X[6] + ", " + X[7] + ", " + X[8] + ", " + X[9] + ", " + X[10] + ", " + X[11] + ", " + X[12] + ", " + X[13] + ", " + X[14] + ", " + X[15] + ")";
      }
      function $(X) {
        return Math.hypot(X[0], X[1], X[2], X[3], X[4], X[5], X[6], X[7], X[8], X[9], X[10], X[11], X[12], X[13], X[14], X[15]);
      }
      function oi(X, L, N) {
        return X[0] = L[0] + N[0], X[1] = L[1] + N[1], X[2] = L[2] + N[2], X[3] = L[3] + N[3], X[4] = L[4] + N[4], X[5] = L[5] + N[5], X[6] = L[6] + N[6], X[7] = L[7] + N[7], X[8] = L[8] + N[8], X[9] = L[9] + N[9], X[10] = L[10] + N[10], X[11] = L[11] + N[11], X[12] = L[12] + N[12], X[13] = L[13] + N[13], X[14] = L[14] + N[14], X[15] = L[15] + N[15], X;
      }
      function ni(X, L, N) {
        return X[0] = L[0] - N[0], X[1] = L[1] - N[1], X[2] = L[2] - N[2], X[3] = L[3] - N[3], X[4] = L[4] - N[4], X[5] = L[5] - N[5], X[6] = L[6] - N[6], X[7] = L[7] - N[7], X[8] = L[8] - N[8], X[9] = L[9] - N[9], X[10] = L[10] - N[10], X[11] = L[11] - N[11], X[12] = L[12] - N[12], X[13] = L[13] - N[13], X[14] = L[14] - N[14], X[15] = L[15] - N[15], X;
      }
      function z(X, L, N) {
        return X[0] = L[0] * N, X[1] = L[1] * N, X[2] = L[2] * N, X[3] = L[3] * N, X[4] = L[4] * N, X[5] = L[5] * N, X[6] = L[6] * N, X[7] = L[7] * N, X[8] = L[8] * N, X[9] = L[9] * N, X[10] = L[10] * N, X[11] = L[11] * N, X[12] = L[12] * N, X[13] = L[13] * N, X[14] = L[14] * N, X[15] = L[15] * N, X;
      }
      function M(X, L, N, v) {
        return X[0] = L[0] + N[0] * v, X[1] = L[1] + N[1] * v, X[2] = L[2] + N[2] * v, X[3] = L[3] + N[3] * v, X[4] = L[4] + N[4] * v, X[5] = L[5] + N[5] * v, X[6] = L[6] + N[6] * v, X[7] = L[7] + N[7] * v, X[8] = L[8] + N[8] * v, X[9] = L[9] + N[9] * v, X[10] = L[10] + N[10] * v, X[11] = L[11] + N[11] * v, X[12] = L[12] + N[12] * v, X[13] = L[13] + N[13] * v, X[14] = L[14] + N[14] * v, X[15] = L[15] + N[15] * v, X;
      }
      function E(X, L) {
        return X[0] === L[0] && X[1] === L[1] && X[2] === L[2] && X[3] === L[3] && X[4] === L[4] && X[5] === L[5] && X[6] === L[6] && X[7] === L[7] && X[8] === L[8] && X[9] === L[9] && X[10] === L[10] && X[11] === L[11] && X[12] === L[12] && X[13] === L[13] && X[14] === L[14] && X[15] === L[15];
      }
      function B(X, L) {
        var N = X[0], v = X[1], P = X[2], j = X[3], A = X[4], li = X[5], di = X[6], ci = X[7], mi = X[8], ti = X[9], si = X[10], Zi = X[11], ai = X[12], ei = X[13], Xi = X[14], ui = X[15], ri = L[0], yi = L[1], Ki = L[2], Ri = L[3], xi = L[4], Ui = L[5], Mi = L[6], ki = L[7], vi = L[8], Qi = L[9], fi = L[10], Pi = L[11], Ci = L[12], ji = L[13], Wl = L[14], Gl = L[15];
        return Math.abs(N - ri) <= s.EPSILON * Math.max(1, Math.abs(N), Math.abs(ri)) && Math.abs(v - yi) <= s.EPSILON * Math.max(1, Math.abs(v), Math.abs(yi)) && Math.abs(P - Ki) <= s.EPSILON * Math.max(1, Math.abs(P), Math.abs(Ki)) && Math.abs(j - Ri) <= s.EPSILON * Math.max(1, Math.abs(j), Math.abs(Ri)) && Math.abs(A - xi) <= s.EPSILON * Math.max(1, Math.abs(A), Math.abs(xi)) && Math.abs(li - Ui) <= s.EPSILON * Math.max(1, Math.abs(li), Math.abs(Ui)) && Math.abs(di - Mi) <= s.EPSILON * Math.max(1, Math.abs(di), Math.abs(Mi)) && Math.abs(ci - ki) <= s.EPSILON * Math.max(1, Math.abs(ci), Math.abs(ki)) && Math.abs(mi - vi) <= s.EPSILON * Math.max(1, Math.abs(mi), Math.abs(vi)) && Math.abs(ti - Qi) <= s.EPSILON * Math.max(1, Math.abs(ti), Math.abs(Qi)) && Math.abs(si - fi) <= s.EPSILON * Math.max(1, Math.abs(si), Math.abs(fi)) && Math.abs(Zi - Pi) <= s.EPSILON * Math.max(1, Math.abs(Zi), Math.abs(Pi)) && Math.abs(ai - Ci) <= s.EPSILON * Math.max(1, Math.abs(ai), Math.abs(Ci)) && Math.abs(ei - ji) <= s.EPSILON * Math.max(1, Math.abs(ei), Math.abs(ji)) && Math.abs(Xi - Wl) <= s.EPSILON * Math.max(1, Math.abs(Xi), Math.abs(Wl)) && Math.abs(ui - Gl) <= s.EPSILON * Math.max(1, Math.abs(ui), Math.abs(Gl));
      }
      var g = r, U = ni;
    },
    /* 7 */
    /***/
    function(Z, l, i) {
      i.r(l), i.d(l, "create", function() {
        return e;
      }), i.d(l, "identity", function() {
        return a;
      }), i.d(l, "setAxisAngle", function() {
        return G;
      }), i.d(l, "getAxisAngle", function() {
        return y;
      }), i.d(l, "getAngle", function() {
        return n;
      }), i.d(l, "multiply", function() {
        return V;
      }), i.d(l, "rotateX", function() {
        return I;
      }), i.d(l, "rotateY", function() {
        return r;
      }), i.d(l, "rotateZ", function() {
        return p;
      }), i.d(l, "calculateW", function() {
        return o;
      }), i.d(l, "exp", function() {
        return u;
      }), i.d(l, "ln", function() {
        return d;
      }), i.d(l, "pow", function() {
        return b;
      }), i.d(l, "slerp", function() {
        return t;
      }), i.d(l, "random", function() {
        return m;
      }), i.d(l, "invert", function() {
        return R;
      }), i.d(l, "conjugate", function() {
        return S;
      }), i.d(l, "fromMat3", function() {
        return C;
      }), i.d(l, "fromEuler", function() {
        return F;
      }), i.d(l, "str", function() {
        return K;
      }), i.d(l, "clone", function() {
        return J;
      }), i.d(l, "fromValues", function() {
        return T;
      }), i.d(l, "copy", function() {
        return Y;
      }), i.d(l, "set", function() {
        return x;
      }), i.d(l, "add", function() {
        return H;
      }), i.d(l, "mul", function() {
        return Q;
      }), i.d(l, "scale", function() {
        return w;
      }), i.d(l, "dot", function() {
        return O;
      }), i.d(l, "lerp", function() {
        return q;
      }), i.d(l, "length", function() {
        return k;
      }), i.d(l, "len", function() {
        return f;
      }), i.d(l, "squaredLength", function() {
        return D;
      }), i.d(l, "sqrLen", function() {
        return ii;
      }), i.d(l, "normalize", function() {
        return _;
      }), i.d(l, "exactEquals", function() {
        return bi;
      }), i.d(l, "equals", function() {
        return $;
      }), i.d(l, "rotationTo", function() {
        return oi;
      }), i.d(l, "sqlerp", function() {
        return ni;
      }), i.d(l, "setAxes", function() {
        return z;
      });
      var s = i(2), c = i(5), W = i(8), h = i(9);
      function e() {
        var M = new s.ARRAY_TYPE(4);
        return s.ARRAY_TYPE != Float32Array && (M[0] = 0, M[1] = 0, M[2] = 0), M[3] = 1, M;
      }
      function a(M) {
        return M[0] = 0, M[1] = 0, M[2] = 0, M[3] = 1, M;
      }
      function G(M, E, B) {
        B = B * 0.5;
        var g = Math.sin(B);
        return M[0] = g * E[0], M[1] = g * E[1], M[2] = g * E[2], M[3] = Math.cos(B), M;
      }
      function y(M, E) {
        var B = Math.acos(E[3]) * 2, g = Math.sin(B / 2);
        return g > s.EPSILON ? (M[0] = E[0] / g, M[1] = E[1] / g, M[2] = E[2] / g) : (M[0] = 1, M[1] = 0, M[2] = 0), B;
      }
      function n(M, E) {
        var B = O(M, E);
        return Math.acos(2 * B * B - 1);
      }
      function V(M, E, B) {
        var g = E[0], U = E[1], X = E[2], L = E[3], N = B[0], v = B[1], P = B[2], j = B[3];
        return M[0] = g * j + L * N + U * P - X * v, M[1] = U * j + L * v + X * N - g * P, M[2] = X * j + L * P + g * v - U * N, M[3] = L * j - g * N - U * v - X * P, M;
      }
      function I(M, E, B) {
        B *= 0.5;
        var g = E[0], U = E[1], X = E[2], L = E[3], N = Math.sin(B), v = Math.cos(B);
        return M[0] = g * v + L * N, M[1] = U * v + X * N, M[2] = X * v - U * N, M[3] = L * v - g * N, M;
      }
      function r(M, E, B) {
        B *= 0.5;
        var g = E[0], U = E[1], X = E[2], L = E[3], N = Math.sin(B), v = Math.cos(B);
        return M[0] = g * v - X * N, M[1] = U * v + L * N, M[2] = X * v + g * N, M[3] = L * v - U * N, M;
      }
      function p(M, E, B) {
        B *= 0.5;
        var g = E[0], U = E[1], X = E[2], L = E[3], N = Math.sin(B), v = Math.cos(B);
        return M[0] = g * v + U * N, M[1] = U * v - g * N, M[2] = X * v + L * N, M[3] = L * v - X * N, M;
      }
      function o(M, E) {
        var B = E[0], g = E[1], U = E[2];
        return M[0] = B, M[1] = g, M[2] = U, M[3] = Math.sqrt(Math.abs(1 - B * B - g * g - U * U)), M;
      }
      function u(M, E) {
        var B = E[0], g = E[1], U = E[2], X = E[3], L = Math.sqrt(B * B + g * g + U * U), N = Math.exp(X), v = L > 0 ? N * Math.sin(L) / L : 0;
        return M[0] = B * v, M[1] = g * v, M[2] = U * v, M[3] = N * Math.cos(L), M;
      }
      function d(M, E) {
        var B = E[0], g = E[1], U = E[2], X = E[3], L = Math.sqrt(B * B + g * g + U * U), N = L > 0 ? Math.atan2(L, X) / L : 0;
        return M[0] = B * N, M[1] = g * N, M[2] = U * N, M[3] = 0.5 * Math.log(B * B + g * g + U * U + X * X), M;
      }
      function b(M, E, B) {
        return d(M, E), w(M, M, B), u(M, M), M;
      }
      function t(M, E, B, g) {
        var U = E[0], X = E[1], L = E[2], N = E[3], v = B[0], P = B[1], j = B[2], A = B[3], li, di, ci, mi, ti;
        return di = U * v + X * P + L * j + N * A, di < 0 && (di = -di, v = -v, P = -P, j = -j, A = -A), 1 - di > s.EPSILON ? (li = Math.acos(di), ci = Math.sin(li), mi = Math.sin((1 - g) * li) / ci, ti = Math.sin(g * li) / ci) : (mi = 1 - g, ti = g), M[0] = mi * U + ti * v, M[1] = mi * X + ti * P, M[2] = mi * L + ti * j, M[3] = mi * N + ti * A, M;
      }
      function m(M) {
        var E = s.RANDOM(), B = s.RANDOM(), g = s.RANDOM(), U = Math.sqrt(1 - E), X = Math.sqrt(E);
        return M[0] = U * Math.sin(2 * Math.PI * B), M[1] = U * Math.cos(2 * Math.PI * B), M[2] = X * Math.sin(2 * Math.PI * g), M[3] = X * Math.cos(2 * Math.PI * g), M;
      }
      function R(M, E) {
        var B = E[0], g = E[1], U = E[2], X = E[3], L = B * B + g * g + U * U + X * X, N = L ? 1 / L : 0;
        return M[0] = -B * N, M[1] = -g * N, M[2] = -U * N, M[3] = X * N, M;
      }
      function S(M, E) {
        return M[0] = -E[0], M[1] = -E[1], M[2] = -E[2], M[3] = E[3], M;
      }
      function C(M, E) {
        var B = E[0] + E[4] + E[8], g;
        if (B > 0)
          g = Math.sqrt(B + 1), M[3] = 0.5 * g, g = 0.5 / g, M[0] = (E[5] - E[7]) * g, M[1] = (E[6] - E[2]) * g, M[2] = (E[1] - E[3]) * g;
        else {
          var U = 0;
          E[4] > E[0] && (U = 1), E[8] > E[U * 3 + U] && (U = 2);
          var X = (U + 1) % 3, L = (U + 2) % 3;
          g = Math.sqrt(E[U * 3 + U] - E[X * 3 + X] - E[L * 3 + L] + 1), M[U] = 0.5 * g, g = 0.5 / g, M[3] = (E[X * 3 + L] - E[L * 3 + X]) * g, M[X] = (E[X * 3 + U] + E[U * 3 + X]) * g, M[L] = (E[L * 3 + U] + E[U * 3 + L]) * g;
        }
        return M;
      }
      function F(M, E, B, g) {
        var U = 0.5 * Math.PI / 180;
        E *= U, B *= U, g *= U;
        var X = Math.sin(E), L = Math.cos(E), N = Math.sin(B), v = Math.cos(B), P = Math.sin(g), j = Math.cos(g);
        return M[0] = X * v * j - L * N * P, M[1] = L * N * j + X * v * P, M[2] = L * v * P - X * N * j, M[3] = L * v * j + X * N * P, M;
      }
      function K(M) {
        return "quat(" + M[0] + ", " + M[1] + ", " + M[2] + ", " + M[3] + ")";
      }
      var J = h.clone, T = h.fromValues, Y = h.copy, x = h.set, H = h.add, Q = V, w = h.scale, O = h.dot, q = h.lerp, k = h.length, f = k, D = h.squaredLength, ii = D, _ = h.normalize, bi = h.exactEquals, $ = h.equals, oi = function() {
        var M = W.create(), E = W.fromValues(1, 0, 0), B = W.fromValues(0, 1, 0);
        return function(g, U, X) {
          var L = W.dot(U, X);
          return L < -0.999999 ? (W.cross(M, E, U), W.len(M) < 1e-6 && W.cross(M, B, U), W.normalize(M, M), G(g, M, Math.PI), g) : L > 0.999999 ? (g[0] = 0, g[1] = 0, g[2] = 0, g[3] = 1, g) : (W.cross(M, U, X), g[0] = M[0], g[1] = M[1], g[2] = M[2], g[3] = 1 + L, _(g, g));
        };
      }(), ni = function() {
        var M = e(), E = e();
        return function(B, g, U, X, L, N) {
          return t(M, g, L, N), t(E, U, X, N), t(B, M, E, 2 * N * (1 - N)), B;
        };
      }(), z = function() {
        var M = c.create();
        return function(E, B, g, U) {
          return M[0] = g[0], M[3] = g[1], M[6] = g[2], M[1] = U[0], M[4] = U[1], M[7] = U[2], M[2] = -B[0], M[5] = -B[1], M[8] = -B[2], _(E, C(E, M));
        };
      }();
    },
    /* 8 */
    /***/
    function(Z, l, i) {
      i.r(l), i.d(l, "create", function() {
        return c;
      }), i.d(l, "clone", function() {
        return W;
      }), i.d(l, "length", function() {
        return h;
      }), i.d(l, "fromValues", function() {
        return e;
      }), i.d(l, "copy", function() {
        return a;
      }), i.d(l, "set", function() {
        return G;
      }), i.d(l, "add", function() {
        return y;
      }), i.d(l, "subtract", function() {
        return n;
      }), i.d(l, "multiply", function() {
        return V;
      }), i.d(l, "divide", function() {
        return I;
      }), i.d(l, "ceil", function() {
        return r;
      }), i.d(l, "floor", function() {
        return p;
      }), i.d(l, "min", function() {
        return o;
      }), i.d(l, "max", function() {
        return u;
      }), i.d(l, "round", function() {
        return d;
      }), i.d(l, "scale", function() {
        return b;
      }), i.d(l, "scaleAndAdd", function() {
        return t;
      }), i.d(l, "distance", function() {
        return m;
      }), i.d(l, "squaredDistance", function() {
        return R;
      }), i.d(l, "squaredLength", function() {
        return S;
      }), i.d(l, "negate", function() {
        return C;
      }), i.d(l, "inverse", function() {
        return F;
      }), i.d(l, "normalize", function() {
        return K;
      }), i.d(l, "dot", function() {
        return J;
      }), i.d(l, "cross", function() {
        return T;
      }), i.d(l, "lerp", function() {
        return Y;
      }), i.d(l, "hermite", function() {
        return x;
      }), i.d(l, "bezier", function() {
        return H;
      }), i.d(l, "random", function() {
        return Q;
      }), i.d(l, "transformMat4", function() {
        return w;
      }), i.d(l, "transformMat3", function() {
        return O;
      }), i.d(l, "transformQuat", function() {
        return q;
      }), i.d(l, "rotateX", function() {
        return k;
      }), i.d(l, "rotateY", function() {
        return f;
      }), i.d(l, "rotateZ", function() {
        return D;
      }), i.d(l, "angle", function() {
        return ii;
      }), i.d(l, "zero", function() {
        return _;
      }), i.d(l, "str", function() {
        return bi;
      }), i.d(l, "exactEquals", function() {
        return $;
      }), i.d(l, "equals", function() {
        return oi;
      }), i.d(l, "sub", function() {
        return ni;
      }), i.d(l, "mul", function() {
        return z;
      }), i.d(l, "div", function() {
        return M;
      }), i.d(l, "dist", function() {
        return E;
      }), i.d(l, "sqrDist", function() {
        return B;
      }), i.d(l, "len", function() {
        return g;
      }), i.d(l, "sqrLen", function() {
        return U;
      }), i.d(l, "forEach", function() {
        return X;
      });
      var s = i(2);
      function c() {
        var L = new s.ARRAY_TYPE(3);
        return s.ARRAY_TYPE != Float32Array && (L[0] = 0, L[1] = 0, L[2] = 0), L;
      }
      function W(L) {
        var N = new s.ARRAY_TYPE(3);
        return N[0] = L[0], N[1] = L[1], N[2] = L[2], N;
      }
      function h(L) {
        var N = L[0], v = L[1], P = L[2];
        return Math.hypot(N, v, P);
      }
      function e(L, N, v) {
        var P = new s.ARRAY_TYPE(3);
        return P[0] = L, P[1] = N, P[2] = v, P;
      }
      function a(L, N) {
        return L[0] = N[0], L[1] = N[1], L[2] = N[2], L;
      }
      function G(L, N, v, P) {
        return L[0] = N, L[1] = v, L[2] = P, L;
      }
      function y(L, N, v) {
        return L[0] = N[0] + v[0], L[1] = N[1] + v[1], L[2] = N[2] + v[2], L;
      }
      function n(L, N, v) {
        return L[0] = N[0] - v[0], L[1] = N[1] - v[1], L[2] = N[2] - v[2], L;
      }
      function V(L, N, v) {
        return L[0] = N[0] * v[0], L[1] = N[1] * v[1], L[2] = N[2] * v[2], L;
      }
      function I(L, N, v) {
        return L[0] = N[0] / v[0], L[1] = N[1] / v[1], L[2] = N[2] / v[2], L;
      }
      function r(L, N) {
        return L[0] = Math.ceil(N[0]), L[1] = Math.ceil(N[1]), L[2] = Math.ceil(N[2]), L;
      }
      function p(L, N) {
        return L[0] = Math.floor(N[0]), L[1] = Math.floor(N[1]), L[2] = Math.floor(N[2]), L;
      }
      function o(L, N, v) {
        return L[0] = Math.min(N[0], v[0]), L[1] = Math.min(N[1], v[1]), L[2] = Math.min(N[2], v[2]), L;
      }
      function u(L, N, v) {
        return L[0] = Math.max(N[0], v[0]), L[1] = Math.max(N[1], v[1]), L[2] = Math.max(N[2], v[2]), L;
      }
      function d(L, N) {
        return L[0] = Math.round(N[0]), L[1] = Math.round(N[1]), L[2] = Math.round(N[2]), L;
      }
      function b(L, N, v) {
        return L[0] = N[0] * v, L[1] = N[1] * v, L[2] = N[2] * v, L;
      }
      function t(L, N, v, P) {
        return L[0] = N[0] + v[0] * P, L[1] = N[1] + v[1] * P, L[2] = N[2] + v[2] * P, L;
      }
      function m(L, N) {
        var v = N[0] - L[0], P = N[1] - L[1], j = N[2] - L[2];
        return Math.hypot(v, P, j);
      }
      function R(L, N) {
        var v = N[0] - L[0], P = N[1] - L[1], j = N[2] - L[2];
        return v * v + P * P + j * j;
      }
      function S(L) {
        var N = L[0], v = L[1], P = L[2];
        return N * N + v * v + P * P;
      }
      function C(L, N) {
        return L[0] = -N[0], L[1] = -N[1], L[2] = -N[2], L;
      }
      function F(L, N) {
        return L[0] = 1 / N[0], L[1] = 1 / N[1], L[2] = 1 / N[2], L;
      }
      function K(L, N) {
        var v = N[0], P = N[1], j = N[2], A = v * v + P * P + j * j;
        return A > 0 && (A = 1 / Math.sqrt(A)), L[0] = N[0] * A, L[1] = N[1] * A, L[2] = N[2] * A, L;
      }
      function J(L, N) {
        return L[0] * N[0] + L[1] * N[1] + L[2] * N[2];
      }
      function T(L, N, v) {
        var P = N[0], j = N[1], A = N[2], li = v[0], di = v[1], ci = v[2];
        return L[0] = j * ci - A * di, L[1] = A * li - P * ci, L[2] = P * di - j * li, L;
      }
      function Y(L, N, v, P) {
        var j = N[0], A = N[1], li = N[2];
        return L[0] = j + P * (v[0] - j), L[1] = A + P * (v[1] - A), L[2] = li + P * (v[2] - li), L;
      }
      function x(L, N, v, P, j, A) {
        var li = A * A, di = li * (2 * A - 3) + 1, ci = li * (A - 2) + A, mi = li * (A - 1), ti = li * (3 - 2 * A);
        return L[0] = N[0] * di + v[0] * ci + P[0] * mi + j[0] * ti, L[1] = N[1] * di + v[1] * ci + P[1] * mi + j[1] * ti, L[2] = N[2] * di + v[2] * ci + P[2] * mi + j[2] * ti, L;
      }
      function H(L, N, v, P, j, A) {
        var li = 1 - A, di = li * li, ci = A * A, mi = di * li, ti = 3 * A * di, si = 3 * ci * li, Zi = ci * A;
        return L[0] = N[0] * mi + v[0] * ti + P[0] * si + j[0] * Zi, L[1] = N[1] * mi + v[1] * ti + P[1] * si + j[1] * Zi, L[2] = N[2] * mi + v[2] * ti + P[2] * si + j[2] * Zi, L;
      }
      function Q(L, N) {
        N = N || 1;
        var v = s.RANDOM() * 2 * Math.PI, P = s.RANDOM() * 2 - 1, j = Math.sqrt(1 - P * P) * N;
        return L[0] = Math.cos(v) * j, L[1] = Math.sin(v) * j, L[2] = P * N, L;
      }
      function w(L, N, v) {
        var P = N[0], j = N[1], A = N[2], li = v[3] * P + v[7] * j + v[11] * A + v[15];
        return li = li || 1, L[0] = (v[0] * P + v[4] * j + v[8] * A + v[12]) / li, L[1] = (v[1] * P + v[5] * j + v[9] * A + v[13]) / li, L[2] = (v[2] * P + v[6] * j + v[10] * A + v[14]) / li, L;
      }
      function O(L, N, v) {
        var P = N[0], j = N[1], A = N[2];
        return L[0] = P * v[0] + j * v[3] + A * v[6], L[1] = P * v[1] + j * v[4] + A * v[7], L[2] = P * v[2] + j * v[5] + A * v[8], L;
      }
      function q(L, N, v) {
        var P = v[0], j = v[1], A = v[2], li = v[3], di = N[0], ci = N[1], mi = N[2], ti = j * mi - A * ci, si = A * di - P * mi, Zi = P * ci - j * di, ai = j * Zi - A * si, ei = A * ti - P * Zi, Xi = P * si - j * ti, ui = li * 2;
        return ti *= ui, si *= ui, Zi *= ui, ai *= 2, ei *= 2, Xi *= 2, L[0] = di + ti + ai, L[1] = ci + si + ei, L[2] = mi + Zi + Xi, L;
      }
      function k(L, N, v, P) {
        var j = [], A = [];
        return j[0] = N[0] - v[0], j[1] = N[1] - v[1], j[2] = N[2] - v[2], A[0] = j[0], A[1] = j[1] * Math.cos(P) - j[2] * Math.sin(P), A[2] = j[1] * Math.sin(P) + j[2] * Math.cos(P), L[0] = A[0] + v[0], L[1] = A[1] + v[1], L[2] = A[2] + v[2], L;
      }
      function f(L, N, v, P) {
        var j = [], A = [];
        return j[0] = N[0] - v[0], j[1] = N[1] - v[1], j[2] = N[2] - v[2], A[0] = j[2] * Math.sin(P) + j[0] * Math.cos(P), A[1] = j[1], A[2] = j[2] * Math.cos(P) - j[0] * Math.sin(P), L[0] = A[0] + v[0], L[1] = A[1] + v[1], L[2] = A[2] + v[2], L;
      }
      function D(L, N, v, P) {
        var j = [], A = [];
        return j[0] = N[0] - v[0], j[1] = N[1] - v[1], j[2] = N[2] - v[2], A[0] = j[0] * Math.cos(P) - j[1] * Math.sin(P), A[1] = j[0] * Math.sin(P) + j[1] * Math.cos(P), A[2] = j[2], L[0] = A[0] + v[0], L[1] = A[1] + v[1], L[2] = A[2] + v[2], L;
      }
      function ii(L, N) {
        var v = L[0], P = L[1], j = L[2], A = N[0], li = N[1], di = N[2], ci = Math.sqrt(v * v + P * P + j * j), mi = Math.sqrt(A * A + li * li + di * di), ti = ci * mi, si = ti && J(L, N) / ti;
        return Math.acos(Math.min(Math.max(si, -1), 1));
      }
      function _(L) {
        return L[0] = 0, L[1] = 0, L[2] = 0, L;
      }
      function bi(L) {
        return "vec3(" + L[0] + ", " + L[1] + ", " + L[2] + ")";
      }
      function $(L, N) {
        return L[0] === N[0] && L[1] === N[1] && L[2] === N[2];
      }
      function oi(L, N) {
        var v = L[0], P = L[1], j = L[2], A = N[0], li = N[1], di = N[2];
        return Math.abs(v - A) <= s.EPSILON * Math.max(1, Math.abs(v), Math.abs(A)) && Math.abs(P - li) <= s.EPSILON * Math.max(1, Math.abs(P), Math.abs(li)) && Math.abs(j - di) <= s.EPSILON * Math.max(1, Math.abs(j), Math.abs(di));
      }
      var ni = n, z = V, M = I, E = m, B = R, g = h, U = S, X = function() {
        var L = c();
        return function(N, v, P, j, A, li) {
          var di, ci;
          for (v || (v = 3), P || (P = 0), j ? ci = Math.min(j * v + P, N.length) : ci = N.length, di = P; di < ci; di += v)
            L[0] = N[di], L[1] = N[di + 1], L[2] = N[di + 2], A(L, L, li), N[di] = L[0], N[di + 1] = L[1], N[di + 2] = L[2];
          return N;
        };
      }();
    },
    /* 9 */
    /***/
    function(Z, l, i) {
      i.r(l), i.d(l, "create", function() {
        return c;
      }), i.d(l, "clone", function() {
        return W;
      }), i.d(l, "fromValues", function() {
        return h;
      }), i.d(l, "copy", function() {
        return e;
      }), i.d(l, "set", function() {
        return a;
      }), i.d(l, "add", function() {
        return G;
      }), i.d(l, "subtract", function() {
        return y;
      }), i.d(l, "multiply", function() {
        return n;
      }), i.d(l, "divide", function() {
        return V;
      }), i.d(l, "ceil", function() {
        return I;
      }), i.d(l, "floor", function() {
        return r;
      }), i.d(l, "min", function() {
        return p;
      }), i.d(l, "max", function() {
        return o;
      }), i.d(l, "round", function() {
        return u;
      }), i.d(l, "scale", function() {
        return d;
      }), i.d(l, "scaleAndAdd", function() {
        return b;
      }), i.d(l, "distance", function() {
        return t;
      }), i.d(l, "squaredDistance", function() {
        return m;
      }), i.d(l, "length", function() {
        return R;
      }), i.d(l, "squaredLength", function() {
        return S;
      }), i.d(l, "negate", function() {
        return C;
      }), i.d(l, "inverse", function() {
        return F;
      }), i.d(l, "normalize", function() {
        return K;
      }), i.d(l, "dot", function() {
        return J;
      }), i.d(l, "cross", function() {
        return T;
      }), i.d(l, "lerp", function() {
        return Y;
      }), i.d(l, "random", function() {
        return x;
      }), i.d(l, "transformMat4", function() {
        return H;
      }), i.d(l, "transformQuat", function() {
        return Q;
      }), i.d(l, "zero", function() {
        return w;
      }), i.d(l, "str", function() {
        return O;
      }), i.d(l, "exactEquals", function() {
        return q;
      }), i.d(l, "equals", function() {
        return k;
      }), i.d(l, "sub", function() {
        return f;
      }), i.d(l, "mul", function() {
        return D;
      }), i.d(l, "div", function() {
        return ii;
      }), i.d(l, "dist", function() {
        return _;
      }), i.d(l, "sqrDist", function() {
        return bi;
      }), i.d(l, "len", function() {
        return $;
      }), i.d(l, "sqrLen", function() {
        return oi;
      }), i.d(l, "forEach", function() {
        return ni;
      });
      var s = i(2);
      function c() {
        var z = new s.ARRAY_TYPE(4);
        return s.ARRAY_TYPE != Float32Array && (z[0] = 0, z[1] = 0, z[2] = 0, z[3] = 0), z;
      }
      function W(z) {
        var M = new s.ARRAY_TYPE(4);
        return M[0] = z[0], M[1] = z[1], M[2] = z[2], M[3] = z[3], M;
      }
      function h(z, M, E, B) {
        var g = new s.ARRAY_TYPE(4);
        return g[0] = z, g[1] = M, g[2] = E, g[3] = B, g;
      }
      function e(z, M) {
        return z[0] = M[0], z[1] = M[1], z[2] = M[2], z[3] = M[3], z;
      }
      function a(z, M, E, B, g) {
        return z[0] = M, z[1] = E, z[2] = B, z[3] = g, z;
      }
      function G(z, M, E) {
        return z[0] = M[0] + E[0], z[1] = M[1] + E[1], z[2] = M[2] + E[2], z[3] = M[3] + E[3], z;
      }
      function y(z, M, E) {
        return z[0] = M[0] - E[0], z[1] = M[1] - E[1], z[2] = M[2] - E[2], z[3] = M[3] - E[3], z;
      }
      function n(z, M, E) {
        return z[0] = M[0] * E[0], z[1] = M[1] * E[1], z[2] = M[2] * E[2], z[3] = M[3] * E[3], z;
      }
      function V(z, M, E) {
        return z[0] = M[0] / E[0], z[1] = M[1] / E[1], z[2] = M[2] / E[2], z[3] = M[3] / E[3], z;
      }
      function I(z, M) {
        return z[0] = Math.ceil(M[0]), z[1] = Math.ceil(M[1]), z[2] = Math.ceil(M[2]), z[3] = Math.ceil(M[3]), z;
      }
      function r(z, M) {
        return z[0] = Math.floor(M[0]), z[1] = Math.floor(M[1]), z[2] = Math.floor(M[2]), z[3] = Math.floor(M[3]), z;
      }
      function p(z, M, E) {
        return z[0] = Math.min(M[0], E[0]), z[1] = Math.min(M[1], E[1]), z[2] = Math.min(M[2], E[2]), z[3] = Math.min(M[3], E[3]), z;
      }
      function o(z, M, E) {
        return z[0] = Math.max(M[0], E[0]), z[1] = Math.max(M[1], E[1]), z[2] = Math.max(M[2], E[2]), z[3] = Math.max(M[3], E[3]), z;
      }
      function u(z, M) {
        return z[0] = Math.round(M[0]), z[1] = Math.round(M[1]), z[2] = Math.round(M[2]), z[3] = Math.round(M[3]), z;
      }
      function d(z, M, E) {
        return z[0] = M[0] * E, z[1] = M[1] * E, z[2] = M[2] * E, z[3] = M[3] * E, z;
      }
      function b(z, M, E, B) {
        return z[0] = M[0] + E[0] * B, z[1] = M[1] + E[1] * B, z[2] = M[2] + E[2] * B, z[3] = M[3] + E[3] * B, z;
      }
      function t(z, M) {
        var E = M[0] - z[0], B = M[1] - z[1], g = M[2] - z[2], U = M[3] - z[3];
        return Math.hypot(E, B, g, U);
      }
      function m(z, M) {
        var E = M[0] - z[0], B = M[1] - z[1], g = M[2] - z[2], U = M[3] - z[3];
        return E * E + B * B + g * g + U * U;
      }
      function R(z) {
        var M = z[0], E = z[1], B = z[2], g = z[3];
        return Math.hypot(M, E, B, g);
      }
      function S(z) {
        var M = z[0], E = z[1], B = z[2], g = z[3];
        return M * M + E * E + B * B + g * g;
      }
      function C(z, M) {
        return z[0] = -M[0], z[1] = -M[1], z[2] = -M[2], z[3] = -M[3], z;
      }
      function F(z, M) {
        return z[0] = 1 / M[0], z[1] = 1 / M[1], z[2] = 1 / M[2], z[3] = 1 / M[3], z;
      }
      function K(z, M) {
        var E = M[0], B = M[1], g = M[2], U = M[3], X = E * E + B * B + g * g + U * U;
        return X > 0 && (X = 1 / Math.sqrt(X)), z[0] = E * X, z[1] = B * X, z[2] = g * X, z[3] = U * X, z;
      }
      function J(z, M) {
        return z[0] * M[0] + z[1] * M[1] + z[2] * M[2] + z[3] * M[3];
      }
      function T(z, M, E, B) {
        var g = E[0] * B[1] - E[1] * B[0], U = E[0] * B[2] - E[2] * B[0], X = E[0] * B[3] - E[3] * B[0], L = E[1] * B[2] - E[2] * B[1], N = E[1] * B[3] - E[3] * B[1], v = E[2] * B[3] - E[3] * B[2], P = M[0], j = M[1], A = M[2], li = M[3];
        return z[0] = j * v - A * N + li * L, z[1] = -(P * v) + A * X - li * U, z[2] = P * N - j * X + li * g, z[3] = -(P * L) + j * U - A * g, z;
      }
      function Y(z, M, E, B) {
        var g = M[0], U = M[1], X = M[2], L = M[3];
        return z[0] = g + B * (E[0] - g), z[1] = U + B * (E[1] - U), z[2] = X + B * (E[2] - X), z[3] = L + B * (E[3] - L), z;
      }
      function x(z, M) {
        M = M || 1;
        var E, B, g, U, X, L;
        do
          E = s.RANDOM() * 2 - 1, B = s.RANDOM() * 2 - 1, X = E * E + B * B;
        while (X >= 1);
        do
          g = s.RANDOM() * 2 - 1, U = s.RANDOM() * 2 - 1, L = g * g + U * U;
        while (L >= 1);
        var N = Math.sqrt((1 - X) / L);
        return z[0] = M * E, z[1] = M * B, z[2] = M * g * N, z[3] = M * U * N, z;
      }
      function H(z, M, E) {
        var B = M[0], g = M[1], U = M[2], X = M[3];
        return z[0] = E[0] * B + E[4] * g + E[8] * U + E[12] * X, z[1] = E[1] * B + E[5] * g + E[9] * U + E[13] * X, z[2] = E[2] * B + E[6] * g + E[10] * U + E[14] * X, z[3] = E[3] * B + E[7] * g + E[11] * U + E[15] * X, z;
      }
      function Q(z, M, E) {
        var B = M[0], g = M[1], U = M[2], X = E[0], L = E[1], N = E[2], v = E[3], P = v * B + L * U - N * g, j = v * g + N * B - X * U, A = v * U + X * g - L * B, li = -X * B - L * g - N * U;
        return z[0] = P * v + li * -X + j * -N - A * -L, z[1] = j * v + li * -L + A * -X - P * -N, z[2] = A * v + li * -N + P * -L - j * -X, z[3] = M[3], z;
      }
      function w(z) {
        return z[0] = 0, z[1] = 0, z[2] = 0, z[3] = 0, z;
      }
      function O(z) {
        return "vec4(" + z[0] + ", " + z[1] + ", " + z[2] + ", " + z[3] + ")";
      }
      function q(z, M) {
        return z[0] === M[0] && z[1] === M[1] && z[2] === M[2] && z[3] === M[3];
      }
      function k(z, M) {
        var E = z[0], B = z[1], g = z[2], U = z[3], X = M[0], L = M[1], N = M[2], v = M[3];
        return Math.abs(E - X) <= s.EPSILON * Math.max(1, Math.abs(E), Math.abs(X)) && Math.abs(B - L) <= s.EPSILON * Math.max(1, Math.abs(B), Math.abs(L)) && Math.abs(g - N) <= s.EPSILON * Math.max(1, Math.abs(g), Math.abs(N)) && Math.abs(U - v) <= s.EPSILON * Math.max(1, Math.abs(U), Math.abs(v));
      }
      var f = y, D = n, ii = V, _ = t, bi = m, $ = R, oi = S, ni = function() {
        var z = c();
        return function(M, E, B, g, U, X) {
          var L, N;
          for (E || (E = 4), B || (B = 0), g ? N = Math.min(g * E + B, M.length) : N = M.length, L = B; L < N; L += E)
            z[0] = M[L], z[1] = M[L + 1], z[2] = M[L + 2], z[3] = M[L + 3], U(z, z, X), M[L] = z[0], M[L + 1] = z[1], M[L + 2] = z[2], M[L + 3] = z[3];
          return M;
        };
      }();
    },
    /* 10 */
    /***/
    function(Z, l, i) {
      i.r(l), i.d(l, "create", function() {
        return h;
      }), i.d(l, "clone", function() {
        return e;
      }), i.d(l, "fromValues", function() {
        return a;
      }), i.d(l, "fromRotationTranslationValues", function() {
        return G;
      }), i.d(l, "fromRotationTranslation", function() {
        return y;
      }), i.d(l, "fromTranslation", function() {
        return n;
      }), i.d(l, "fromRotation", function() {
        return V;
      }), i.d(l, "fromMat4", function() {
        return I;
      }), i.d(l, "copy", function() {
        return r;
      }), i.d(l, "identity", function() {
        return p;
      }), i.d(l, "set", function() {
        return o;
      }), i.d(l, "getReal", function() {
        return u;
      }), i.d(l, "getDual", function() {
        return d;
      }), i.d(l, "setReal", function() {
        return b;
      }), i.d(l, "setDual", function() {
        return t;
      }), i.d(l, "getTranslation", function() {
        return m;
      }), i.d(l, "translate", function() {
        return R;
      }), i.d(l, "rotateX", function() {
        return S;
      }), i.d(l, "rotateY", function() {
        return C;
      }), i.d(l, "rotateZ", function() {
        return F;
      }), i.d(l, "rotateByQuatAppend", function() {
        return K;
      }), i.d(l, "rotateByQuatPrepend", function() {
        return J;
      }), i.d(l, "rotateAroundAxis", function() {
        return T;
      }), i.d(l, "add", function() {
        return Y;
      }), i.d(l, "multiply", function() {
        return x;
      }), i.d(l, "mul", function() {
        return H;
      }), i.d(l, "scale", function() {
        return Q;
      }), i.d(l, "dot", function() {
        return w;
      }), i.d(l, "lerp", function() {
        return O;
      }), i.d(l, "invert", function() {
        return q;
      }), i.d(l, "conjugate", function() {
        return k;
      }), i.d(l, "length", function() {
        return f;
      }), i.d(l, "len", function() {
        return D;
      }), i.d(l, "squaredLength", function() {
        return ii;
      }), i.d(l, "sqrLen", function() {
        return _;
      }), i.d(l, "normalize", function() {
        return bi;
      }), i.d(l, "str", function() {
        return $;
      }), i.d(l, "exactEquals", function() {
        return oi;
      }), i.d(l, "equals", function() {
        return ni;
      });
      var s = i(2), c = i(7), W = i(6);
      function h() {
        var z = new s.ARRAY_TYPE(8);
        return s.ARRAY_TYPE != Float32Array && (z[0] = 0, z[1] = 0, z[2] = 0, z[4] = 0, z[5] = 0, z[6] = 0, z[7] = 0), z[3] = 1, z;
      }
      function e(z) {
        var M = new s.ARRAY_TYPE(8);
        return M[0] = z[0], M[1] = z[1], M[2] = z[2], M[3] = z[3], M[4] = z[4], M[5] = z[5], M[6] = z[6], M[7] = z[7], M;
      }
      function a(z, M, E, B, g, U, X, L) {
        var N = new s.ARRAY_TYPE(8);
        return N[0] = z, N[1] = M, N[2] = E, N[3] = B, N[4] = g, N[5] = U, N[6] = X, N[7] = L, N;
      }
      function G(z, M, E, B, g, U, X) {
        var L = new s.ARRAY_TYPE(8);
        L[0] = z, L[1] = M, L[2] = E, L[3] = B;
        var N = g * 0.5, v = U * 0.5, P = X * 0.5;
        return L[4] = N * B + v * E - P * M, L[5] = v * B + P * z - N * E, L[6] = P * B + N * M - v * z, L[7] = -N * z - v * M - P * E, L;
      }
      function y(z, M, E) {
        var B = E[0] * 0.5, g = E[1] * 0.5, U = E[2] * 0.5, X = M[0], L = M[1], N = M[2], v = M[3];
        return z[0] = X, z[1] = L, z[2] = N, z[3] = v, z[4] = B * v + g * N - U * L, z[5] = g * v + U * X - B * N, z[6] = U * v + B * L - g * X, z[7] = -B * X - g * L - U * N, z;
      }
      function n(z, M) {
        return z[0] = 0, z[1] = 0, z[2] = 0, z[3] = 1, z[4] = M[0] * 0.5, z[5] = M[1] * 0.5, z[6] = M[2] * 0.5, z[7] = 0, z;
      }
      function V(z, M) {
        return z[0] = M[0], z[1] = M[1], z[2] = M[2], z[3] = M[3], z[4] = 0, z[5] = 0, z[6] = 0, z[7] = 0, z;
      }
      function I(z, M) {
        var E = c.create();
        W.getRotation(E, M);
        var B = new s.ARRAY_TYPE(3);
        return W.getTranslation(B, M), y(z, E, B), z;
      }
      function r(z, M) {
        return z[0] = M[0], z[1] = M[1], z[2] = M[2], z[3] = M[3], z[4] = M[4], z[5] = M[5], z[6] = M[6], z[7] = M[7], z;
      }
      function p(z) {
        return z[0] = 0, z[1] = 0, z[2] = 0, z[3] = 1, z[4] = 0, z[5] = 0, z[6] = 0, z[7] = 0, z;
      }
      function o(z, M, E, B, g, U, X, L, N) {
        return z[0] = M, z[1] = E, z[2] = B, z[3] = g, z[4] = U, z[5] = X, z[6] = L, z[7] = N, z;
      }
      var u = c.copy;
      function d(z, M) {
        return z[0] = M[4], z[1] = M[5], z[2] = M[6], z[3] = M[7], z;
      }
      var b = c.copy;
      function t(z, M) {
        return z[4] = M[0], z[5] = M[1], z[6] = M[2], z[7] = M[3], z;
      }
      function m(z, M) {
        var E = M[4], B = M[5], g = M[6], U = M[7], X = -M[0], L = -M[1], N = -M[2], v = M[3];
        return z[0] = (E * v + U * X + B * N - g * L) * 2, z[1] = (B * v + U * L + g * X - E * N) * 2, z[2] = (g * v + U * N + E * L - B * X) * 2, z;
      }
      function R(z, M, E) {
        var B = M[0], g = M[1], U = M[2], X = M[3], L = E[0] * 0.5, N = E[1] * 0.5, v = E[2] * 0.5, P = M[4], j = M[5], A = M[6], li = M[7];
        return z[0] = B, z[1] = g, z[2] = U, z[3] = X, z[4] = X * L + g * v - U * N + P, z[5] = X * N + U * L - B * v + j, z[6] = X * v + B * N - g * L + A, z[7] = -B * L - g * N - U * v + li, z;
      }
      function S(z, M, E) {
        var B = -M[0], g = -M[1], U = -M[2], X = M[3], L = M[4], N = M[5], v = M[6], P = M[7], j = L * X + P * B + N * U - v * g, A = N * X + P * g + v * B - L * U, li = v * X + P * U + L * g - N * B, di = P * X - L * B - N * g - v * U;
        return c.rotateX(z, M, E), B = z[0], g = z[1], U = z[2], X = z[3], z[4] = j * X + di * B + A * U - li * g, z[5] = A * X + di * g + li * B - j * U, z[6] = li * X + di * U + j * g - A * B, z[7] = di * X - j * B - A * g - li * U, z;
      }
      function C(z, M, E) {
        var B = -M[0], g = -M[1], U = -M[2], X = M[3], L = M[4], N = M[5], v = M[6], P = M[7], j = L * X + P * B + N * U - v * g, A = N * X + P * g + v * B - L * U, li = v * X + P * U + L * g - N * B, di = P * X - L * B - N * g - v * U;
        return c.rotateY(z, M, E), B = z[0], g = z[1], U = z[2], X = z[3], z[4] = j * X + di * B + A * U - li * g, z[5] = A * X + di * g + li * B - j * U, z[6] = li * X + di * U + j * g - A * B, z[7] = di * X - j * B - A * g - li * U, z;
      }
      function F(z, M, E) {
        var B = -M[0], g = -M[1], U = -M[2], X = M[3], L = M[4], N = M[5], v = M[6], P = M[7], j = L * X + P * B + N * U - v * g, A = N * X + P * g + v * B - L * U, li = v * X + P * U + L * g - N * B, di = P * X - L * B - N * g - v * U;
        return c.rotateZ(z, M, E), B = z[0], g = z[1], U = z[2], X = z[3], z[4] = j * X + di * B + A * U - li * g, z[5] = A * X + di * g + li * B - j * U, z[6] = li * X + di * U + j * g - A * B, z[7] = di * X - j * B - A * g - li * U, z;
      }
      function K(z, M, E) {
        var B = E[0], g = E[1], U = E[2], X = E[3], L = M[0], N = M[1], v = M[2], P = M[3];
        return z[0] = L * X + P * B + N * U - v * g, z[1] = N * X + P * g + v * B - L * U, z[2] = v * X + P * U + L * g - N * B, z[3] = P * X - L * B - N * g - v * U, L = M[4], N = M[5], v = M[6], P = M[7], z[4] = L * X + P * B + N * U - v * g, z[5] = N * X + P * g + v * B - L * U, z[6] = v * X + P * U + L * g - N * B, z[7] = P * X - L * B - N * g - v * U, z;
      }
      function J(z, M, E) {
        var B = M[0], g = M[1], U = M[2], X = M[3], L = E[0], N = E[1], v = E[2], P = E[3];
        return z[0] = B * P + X * L + g * v - U * N, z[1] = g * P + X * N + U * L - B * v, z[2] = U * P + X * v + B * N - g * L, z[3] = X * P - B * L - g * N - U * v, L = E[4], N = E[5], v = E[6], P = E[7], z[4] = B * P + X * L + g * v - U * N, z[5] = g * P + X * N + U * L - B * v, z[6] = U * P + X * v + B * N - g * L, z[7] = X * P - B * L - g * N - U * v, z;
      }
      function T(z, M, E, B) {
        if (Math.abs(B) < s.EPSILON)
          return r(z, M);
        var g = Math.hypot(E[0], E[1], E[2]);
        B = B * 0.5;
        var U = Math.sin(B), X = U * E[0] / g, L = U * E[1] / g, N = U * E[2] / g, v = Math.cos(B), P = M[0], j = M[1], A = M[2], li = M[3];
        z[0] = P * v + li * X + j * N - A * L, z[1] = j * v + li * L + A * X - P * N, z[2] = A * v + li * N + P * L - j * X, z[3] = li * v - P * X - j * L - A * N;
        var di = M[4], ci = M[5], mi = M[6], ti = M[7];
        return z[4] = di * v + ti * X + ci * N - mi * L, z[5] = ci * v + ti * L + mi * X - di * N, z[6] = mi * v + ti * N + di * L - ci * X, z[7] = ti * v - di * X - ci * L - mi * N, z;
      }
      function Y(z, M, E) {
        return z[0] = M[0] + E[0], z[1] = M[1] + E[1], z[2] = M[2] + E[2], z[3] = M[3] + E[3], z[4] = M[4] + E[4], z[5] = M[5] + E[5], z[6] = M[6] + E[6], z[7] = M[7] + E[7], z;
      }
      function x(z, M, E) {
        var B = M[0], g = M[1], U = M[2], X = M[3], L = E[4], N = E[5], v = E[6], P = E[7], j = M[4], A = M[5], li = M[6], di = M[7], ci = E[0], mi = E[1], ti = E[2], si = E[3];
        return z[0] = B * si + X * ci + g * ti - U * mi, z[1] = g * si + X * mi + U * ci - B * ti, z[2] = U * si + X * ti + B * mi - g * ci, z[3] = X * si - B * ci - g * mi - U * ti, z[4] = B * P + X * L + g * v - U * N + j * si + di * ci + A * ti - li * mi, z[5] = g * P + X * N + U * L - B * v + A * si + di * mi + li * ci - j * ti, z[6] = U * P + X * v + B * N - g * L + li * si + di * ti + j * mi - A * ci, z[7] = X * P - B * L - g * N - U * v + di * si - j * ci - A * mi - li * ti, z;
      }
      var H = x;
      function Q(z, M, E) {
        return z[0] = M[0] * E, z[1] = M[1] * E, z[2] = M[2] * E, z[3] = M[3] * E, z[4] = M[4] * E, z[5] = M[5] * E, z[6] = M[6] * E, z[7] = M[7] * E, z;
      }
      var w = c.dot;
      function O(z, M, E, B) {
        var g = 1 - B;
        return w(M, E) < 0 && (B = -B), z[0] = M[0] * g + E[0] * B, z[1] = M[1] * g + E[1] * B, z[2] = M[2] * g + E[2] * B, z[3] = M[3] * g + E[3] * B, z[4] = M[4] * g + E[4] * B, z[5] = M[5] * g + E[5] * B, z[6] = M[6] * g + E[6] * B, z[7] = M[7] * g + E[7] * B, z;
      }
      function q(z, M) {
        var E = ii(M);
        return z[0] = -M[0] / E, z[1] = -M[1] / E, z[2] = -M[2] / E, z[3] = M[3] / E, z[4] = -M[4] / E, z[5] = -M[5] / E, z[6] = -M[6] / E, z[7] = M[7] / E, z;
      }
      function k(z, M) {
        return z[0] = -M[0], z[1] = -M[1], z[2] = -M[2], z[3] = M[3], z[4] = -M[4], z[5] = -M[5], z[6] = -M[6], z[7] = M[7], z;
      }
      var f = c.length, D = f, ii = c.squaredLength, _ = ii;
      function bi(z, M) {
        var E = ii(M);
        if (E > 0) {
          E = Math.sqrt(E);
          var B = M[0] / E, g = M[1] / E, U = M[2] / E, X = M[3] / E, L = M[4], N = M[5], v = M[6], P = M[7], j = B * L + g * N + U * v + X * P;
          z[0] = B, z[1] = g, z[2] = U, z[3] = X, z[4] = (L - B * j) / E, z[5] = (N - g * j) / E, z[6] = (v - U * j) / E, z[7] = (P - X * j) / E;
        }
        return z;
      }
      function $(z) {
        return "quat2(" + z[0] + ", " + z[1] + ", " + z[2] + ", " + z[3] + ", " + z[4] + ", " + z[5] + ", " + z[6] + ", " + z[7] + ")";
      }
      function oi(z, M) {
        return z[0] === M[0] && z[1] === M[1] && z[2] === M[2] && z[3] === M[3] && z[4] === M[4] && z[5] === M[5] && z[6] === M[6] && z[7] === M[7];
      }
      function ni(z, M) {
        var E = z[0], B = z[1], g = z[2], U = z[3], X = z[4], L = z[5], N = z[6], v = z[7], P = M[0], j = M[1], A = M[2], li = M[3], di = M[4], ci = M[5], mi = M[6], ti = M[7];
        return Math.abs(E - P) <= s.EPSILON * Math.max(1, Math.abs(E), Math.abs(P)) && Math.abs(B - j) <= s.EPSILON * Math.max(1, Math.abs(B), Math.abs(j)) && Math.abs(g - A) <= s.EPSILON * Math.max(1, Math.abs(g), Math.abs(A)) && Math.abs(U - li) <= s.EPSILON * Math.max(1, Math.abs(U), Math.abs(li)) && Math.abs(X - di) <= s.EPSILON * Math.max(1, Math.abs(X), Math.abs(di)) && Math.abs(L - ci) <= s.EPSILON * Math.max(1, Math.abs(L), Math.abs(ci)) && Math.abs(N - mi) <= s.EPSILON * Math.max(1, Math.abs(N), Math.abs(mi)) && Math.abs(v - ti) <= s.EPSILON * Math.max(1, Math.abs(v), Math.abs(ti));
      }
    },
    /* 11 */
    /***/
    function(Z, l, i) {
      i.r(l), i.d(l, "create", function() {
        return c;
      }), i.d(l, "clone", function() {
        return W;
      }), i.d(l, "fromValues", function() {
        return h;
      }), i.d(l, "copy", function() {
        return e;
      }), i.d(l, "set", function() {
        return a;
      }), i.d(l, "add", function() {
        return G;
      }), i.d(l, "subtract", function() {
        return y;
      }), i.d(l, "multiply", function() {
        return n;
      }), i.d(l, "divide", function() {
        return V;
      }), i.d(l, "ceil", function() {
        return I;
      }), i.d(l, "floor", function() {
        return r;
      }), i.d(l, "min", function() {
        return p;
      }), i.d(l, "max", function() {
        return o;
      }), i.d(l, "round", function() {
        return u;
      }), i.d(l, "scale", function() {
        return d;
      }), i.d(l, "scaleAndAdd", function() {
        return b;
      }), i.d(l, "distance", function() {
        return t;
      }), i.d(l, "squaredDistance", function() {
        return m;
      }), i.d(l, "length", function() {
        return R;
      }), i.d(l, "squaredLength", function() {
        return S;
      }), i.d(l, "negate", function() {
        return C;
      }), i.d(l, "inverse", function() {
        return F;
      }), i.d(l, "normalize", function() {
        return K;
      }), i.d(l, "dot", function() {
        return J;
      }), i.d(l, "cross", function() {
        return T;
      }), i.d(l, "lerp", function() {
        return Y;
      }), i.d(l, "random", function() {
        return x;
      }), i.d(l, "transformMat2", function() {
        return H;
      }), i.d(l, "transformMat2d", function() {
        return Q;
      }), i.d(l, "transformMat3", function() {
        return w;
      }), i.d(l, "transformMat4", function() {
        return O;
      }), i.d(l, "rotate", function() {
        return q;
      }), i.d(l, "angle", function() {
        return k;
      }), i.d(l, "zero", function() {
        return f;
      }), i.d(l, "str", function() {
        return D;
      }), i.d(l, "exactEquals", function() {
        return ii;
      }), i.d(l, "equals", function() {
        return _;
      }), i.d(l, "len", function() {
        return bi;
      }), i.d(l, "sub", function() {
        return $;
      }), i.d(l, "mul", function() {
        return oi;
      }), i.d(l, "div", function() {
        return ni;
      }), i.d(l, "dist", function() {
        return z;
      }), i.d(l, "sqrDist", function() {
        return M;
      }), i.d(l, "sqrLen", function() {
        return E;
      }), i.d(l, "forEach", function() {
        return B;
      });
      var s = i(2);
      function c() {
        var g = new s.ARRAY_TYPE(2);
        return s.ARRAY_TYPE != Float32Array && (g[0] = 0, g[1] = 0), g;
      }
      function W(g) {
        var U = new s.ARRAY_TYPE(2);
        return U[0] = g[0], U[1] = g[1], U;
      }
      function h(g, U) {
        var X = new s.ARRAY_TYPE(2);
        return X[0] = g, X[1] = U, X;
      }
      function e(g, U) {
        return g[0] = U[0], g[1] = U[1], g;
      }
      function a(g, U, X) {
        return g[0] = U, g[1] = X, g;
      }
      function G(g, U, X) {
        return g[0] = U[0] + X[0], g[1] = U[1] + X[1], g;
      }
      function y(g, U, X) {
        return g[0] = U[0] - X[0], g[1] = U[1] - X[1], g;
      }
      function n(g, U, X) {
        return g[0] = U[0] * X[0], g[1] = U[1] * X[1], g;
      }
      function V(g, U, X) {
        return g[0] = U[0] / X[0], g[1] = U[1] / X[1], g;
      }
      function I(g, U) {
        return g[0] = Math.ceil(U[0]), g[1] = Math.ceil(U[1]), g;
      }
      function r(g, U) {
        return g[0] = Math.floor(U[0]), g[1] = Math.floor(U[1]), g;
      }
      function p(g, U, X) {
        return g[0] = Math.min(U[0], X[0]), g[1] = Math.min(U[1], X[1]), g;
      }
      function o(g, U, X) {
        return g[0] = Math.max(U[0], X[0]), g[1] = Math.max(U[1], X[1]), g;
      }
      function u(g, U) {
        return g[0] = Math.round(U[0]), g[1] = Math.round(U[1]), g;
      }
      function d(g, U, X) {
        return g[0] = U[0] * X, g[1] = U[1] * X, g;
      }
      function b(g, U, X, L) {
        return g[0] = U[0] + X[0] * L, g[1] = U[1] + X[1] * L, g;
      }
      function t(g, U) {
        var X = U[0] - g[0], L = U[1] - g[1];
        return Math.hypot(X, L);
      }
      function m(g, U) {
        var X = U[0] - g[0], L = U[1] - g[1];
        return X * X + L * L;
      }
      function R(g) {
        var U = g[0], X = g[1];
        return Math.hypot(U, X);
      }
      function S(g) {
        var U = g[0], X = g[1];
        return U * U + X * X;
      }
      function C(g, U) {
        return g[0] = -U[0], g[1] = -U[1], g;
      }
      function F(g, U) {
        return g[0] = 1 / U[0], g[1] = 1 / U[1], g;
      }
      function K(g, U) {
        var X = U[0], L = U[1], N = X * X + L * L;
        return N > 0 && (N = 1 / Math.sqrt(N)), g[0] = U[0] * N, g[1] = U[1] * N, g;
      }
      function J(g, U) {
        return g[0] * U[0] + g[1] * U[1];
      }
      function T(g, U, X) {
        var L = U[0] * X[1] - U[1] * X[0];
        return g[0] = g[1] = 0, g[2] = L, g;
      }
      function Y(g, U, X, L) {
        var N = U[0], v = U[1];
        return g[0] = N + L * (X[0] - N), g[1] = v + L * (X[1] - v), g;
      }
      function x(g, U) {
        U = U || 1;
        var X = s.RANDOM() * 2 * Math.PI;
        return g[0] = Math.cos(X) * U, g[1] = Math.sin(X) * U, g;
      }
      function H(g, U, X) {
        var L = U[0], N = U[1];
        return g[0] = X[0] * L + X[2] * N, g[1] = X[1] * L + X[3] * N, g;
      }
      function Q(g, U, X) {
        var L = U[0], N = U[1];
        return g[0] = X[0] * L + X[2] * N + X[4], g[1] = X[1] * L + X[3] * N + X[5], g;
      }
      function w(g, U, X) {
        var L = U[0], N = U[1];
        return g[0] = X[0] * L + X[3] * N + X[6], g[1] = X[1] * L + X[4] * N + X[7], g;
      }
      function O(g, U, X) {
        var L = U[0], N = U[1];
        return g[0] = X[0] * L + X[4] * N + X[12], g[1] = X[1] * L + X[5] * N + X[13], g;
      }
      function q(g, U, X, L) {
        var N = U[0] - X[0], v = U[1] - X[1], P = Math.sin(L), j = Math.cos(L);
        return g[0] = N * j - v * P + X[0], g[1] = N * P + v * j + X[1], g;
      }
      function k(g, U) {
        var X = g[0], L = g[1], N = U[0], v = U[1], P = Math.sqrt(X * X + L * L) * Math.sqrt(N * N + v * v), j = P && (X * N + L * v) / P;
        return Math.acos(Math.min(Math.max(j, -1), 1));
      }
      function f(g) {
        return g[0] = 0, g[1] = 0, g;
      }
      function D(g) {
        return "vec2(" + g[0] + ", " + g[1] + ")";
      }
      function ii(g, U) {
        return g[0] === U[0] && g[1] === U[1];
      }
      function _(g, U) {
        var X = g[0], L = g[1], N = U[0], v = U[1];
        return Math.abs(X - N) <= s.EPSILON * Math.max(1, Math.abs(X), Math.abs(N)) && Math.abs(L - v) <= s.EPSILON * Math.max(1, Math.abs(L), Math.abs(v));
      }
      var bi = R, $ = y, oi = n, ni = V, z = t, M = m, E = S, B = function() {
        var g = c();
        return function(U, X, L, N, v, P) {
          var j, A;
          for (X || (X = 2), L || (L = 0), N ? A = Math.min(N * X + L, U.length) : A = U.length, j = L; j < A; j += X)
            g[0] = U[j], g[1] = U[j + 1], v(g, g, P), U[j] = g[0], U[j + 1] = g[1];
          return U;
        };
      }();
    },
    /* 12 */
    /***/
    function(Z, l, i) {
      i.r(l);
      var s = i(13);
      i.d(l, "Renderer", function() {
        return s.default;
      });
      var c = i(40);
      i.d(l, "Figure2D", function() {
        return c.default;
      });
      var W = i(56);
      i.d(l, "Mesh2D", function() {
        return W.default;
      });
      var h = i(29);
      i.d(l, "MeshCloud", function() {
        return h.default;
      });
      var e = i(23);
      i.d(l, "parseFont", function() {
        return e.default;
      });
      var a = i(31);
      i.d(l, "parseColor", function() {
        return a.default;
      });
      var G = i(21);
      i.d(l, "ENV", function() {
        return G.default;
      }), i(1).glMatrix.setMatrixArrayType(Array);
    },
    /* 13 */
    /***/
    function(Z, l, i) {
      i.r(l), i.d(l, "default", function() {
        return F;
      });
      var s = i(14), c = i(1), W = i(20), h = i(27), e = i(25), a = i(40), G = i(56), y = i(29), n = i(59), V = i(21), I = i(63);
      i(1).glMatrix.setMatrixArrayType(Array);
      const r = {
        autoUpdate: !1,
        // premultipliedAlpha: true,
        preserveDrawingBuffer: !1,
        // depth: false,
        // antialias: false,
        bufferSize: 1500
      }, p = `attribute vec3 a_vertexPosition;
attribute vec3 a_vertexTextureCoord;
varying vec3 vTextureCoord;
uniform mat3 viewMatrix;
uniform mat3 projectionMatrix;

void main() {
  gl_PointSize = 1.0;
  vec3 pos = projectionMatrix * viewMatrix * vec3(a_vertexPosition.xy, 1.0);
  gl_Position = vec4(pos.xy, 1.0, 1.0);    
  vTextureCoord = a_vertexTextureCoord;              
}
`, o = `precision mediump float;
varying vec3 vTextureCoord;
uniform sampler2D u_texSampler;
void main() {
  gl_FragColor = texture2D(u_texSampler, vTextureCoord.xy);
}
`, u = Symbol("glRenderer"), d = Symbol("canvasRenderer"), b = Symbol("options"), t = Symbol("globalTransform"), m = Symbol("applyGlobalTransform"), R = Symbol("canvas");
      function S(K) {
        const J = K.gl, T = K.fbo;
        T && J.bindFramebuffer(J.FRAMEBUFFER, T), K._draw(), T && J.bindFramebuffer(J.FRAMEBUFFER, null);
      }
      function C(K, J, T, Y) {
        const x = K.createTexture(J.canvas), H = [[[0, 0], [T, 0], [T, Y], [0, Y], [0, 0]]];
        H.closed = !0;
        const Q = new G.default({
          contours: H
        });
        Q.setTexture(x), K.setMeshData([Q.meshData]), S(K), x.delete(), J.clearRect(0, 0, T, Y), delete J._filter;
      }
      class F {
        constructor(J, T = {}) {
          let Y = T.contextType;
          if (Y || (typeof WebGL2RenderingContext == "function" ? Y = "webgl2" : typeof WebGLRenderingContext == "function" ? Y = "webgl" : Y = "2d"), !J.getContext) {
            const x = J;
            J = {
              getContext() {
                return x;
              },
              width: T.width,
              height: T.height
            }, x.canvas = J, Y = "2d";
          }
          if (this[R] = J, Y !== "webgl" && Y !== "webgl2" && Y !== "2d")
            throw new Error(`Unknown context type ${Y}`);
          if (T.contextType = Y, this[b] = Object.assign({}, r, T), Y === "webgl" || Y === "webgl2") {
            Y === "webgl2" && (this[b].webgl2 = !0);
            const x = new s.default(J, this[b]);
            Y === "webgl2" && !x.isWebGL2 && (T.contextType = "webgl"), Object(I.createShaders)(x), Object(I.applyShader)(x), Object(I.createCloudShaders)(x);
            const H = x.gl;
            H.clearColor(0, 0, 0, 0), H.blendFuncSeparate(H.SRC_ALPHA, H.ONE_MINUS_SRC_ALPHA, H.ONE, H.ONE_MINUS_SRC_ALPHA), this[u] = x;
          } else
            this[d] = new W.default(J, this[b]);
          this[t] = [1, 0, 0, 0, 1, 0, 0, 0, 1], this.updateResolution();
        }
        get canvas() {
          return this[R];
        }
        get canvasRenderer() {
          return this[d];
        }
        get glRenderer() {
          return this[u];
        }
        get isWebGL2() {
          return this[u] && this[u].isWebGL2;
        }
        get options() {
          return this[b];
        }
        get globalTransformMatrix() {
          const J = this[t];
          return [J[0], J[1], J[3], J[4], J[6], J[7]];
        }
        get viewMatrix() {
          return this[t];
        }
        [m]() {
          const J = this[u] || this[d];
          if (this[u]) {
            const {
              width: T,
              height: Y
            } = this.canvas;
            J.uniforms.viewMatrix = this.viewMatrix, J.uniforms.projectionMatrix = this.projectionMatrix, J.uniforms.u_resolution = [T, Y];
          }
        }
        updateResolution() {
          const {
            width: J,
            height: T
          } = this.canvas, Y = [
            // translation
            1,
            0,
            0,
            0,
            1,
            0,
            -J / 2,
            -T / 2,
            1
          ], x = [
            // scale
            2 / J,
            0,
            0,
            0,
            -2 / T,
            0,
            0,
            0,
            1
          ], H = c.mat3.multiply(Array.of(0, 0, 0, 0, 0, 0, 0, 0, 0), x, Y);
          this.projectionMatrix = H, this[u] && this[u].gl.viewport(0, 0, J, T);
        }
        createTexture(J, T) {
          return (this[u] || this[d]).createTexture(J, T);
        }
        /* async */
        loadTexture(J, {
          useImageBitmap: T = !1
        } = {}) {
          return (this[u] || this[d]).loadTexture(J, {
            useImageBitmap: T
          });
        }
        createText(J, {
          font: T = "16px arial",
          fillColor: Y = null,
          strokeColor: x = null,
          strokeWidth: H = 1
        } = {}) {
          if (this[u]) {
            const Q = V.default.createText(J, {
              font: T,
              fillColor: Y,
              strokeColor: x,
              strokeWidth: H
            });
            return {
              image: this.createTexture(Q.image),
              rect: Q.rect
            };
          }
          return {
            _img: {
              font: T,
              fillColor: Y,
              strokeColor: x,
              strokeWidth: H,
              text: J
            }
          };
        }
        createProgram({
          vertex: J,
          fragment: T,
          options: Y
        } = {}) {
          if (this[u]) {
            const x = this[u].compileSync(T, J);
            return x._attribOpts = Y, x;
          }
          throw new Error("Context 2D cannot create webgl program.");
        }
        createPassProgram({
          vertex: J = p,
          fragment: T = o,
          options: Y
        } = {}) {
          return this.createProgram({
            vertex: J,
            fragment: T,
            options: Y
          });
        }
        useProgram(J, T = {}) {
          if (this[u]) {
            const Y = Object.assign({}, J._attribOpts, T);
            return this[u].useProgram(J, Y);
          }
          throw new Error("Context 2D cannot use webgl program.");
        }
        deleteTexture(J) {
          return (this[u] || this[d]).deleteTexture(J);
        }
        clear(...J) {
          if (this[u]) {
            const T = this[u].gl;
            T.clear(T.COLOR_BUFFER_BIT);
          } else
            this[d].clear(...J);
        }
        drawMeshCloud(J, {
          clear: T = !1,
          program: Y = null
        } = {}) {
          const x = this[u] || this[d], H = Y || J.program;
          if (this[u]) {
            const Q = x.gl;
            if (T && Q.clear(Q.COLOR_BUFFER_BIT), H)
              x.program !== H && this.useProgram(H, {
                a_color: {
                  type: "UNSIGNED_BYTE",
                  normalize: !0
                },
                a_fillCloudColor: {
                  type: "UNSIGNED_BYTE",
                  normalize: !0
                },
                a_strokeCloudColor: {
                  type: "UNSIGNED_BYTE",
                  normalize: !0
                },
                a_frameIndex: {
                  type: "UNSIGNED_BYTE",
                  normalize: !1
                }
              });
            else {
              const w = J.mesh.meshData, O = !!w.uniforms.u_texSampler, q = !!w.uniforms.u_filterFlag, k = !!w.uniforms.u_radialGradientVector, f = J.hasCloudColor, D = J.hasCloudFilter, ii = !!w.uniforms.u_clipSampler;
              Object(I.applyCloudShader)(x, {
                hasTexture: O,
                hasFilter: q,
                hasGradient: k,
                hasCloudColor: f,
                hasCloudFilter: D,
                hasClipPath: ii
              });
            }
            this[m](), x.setMeshData([J.meshData]), J.beforeRender && J.beforeRender(Q, J), S(x), J.afterRender && J.afterRender(Q, J);
          } else
            x.setTransform(this.globalTransformMatrix), x.drawMeshCloud(J, {
              clear: T,
              hook: !1
            });
        }
        drawMeshes(J, {
          clear: T = !1,
          program: Y = null
        } = {}) {
          const x = this[u] || this[d];
          if (this[u]) {
            const H = x.fbo, Q = Object(h.default)(this, J, Y == null), w = x.gl;
            T && w.clear(w.COLOR_BUFFER_BIT);
            const O = !Object(n.isUnitTransform)(this.globalTransformMatrix);
            this._drawCalls = 0;
            for (const q of Q) {
              this._drawCalls++;
              const k = Y || q.program;
              if (q instanceof y.default)
                this.drawMeshCloud(q, {
                  clear: T,
                  program: k
                });
              else {
                const {
                  width: f,
                  height: D
                } = this.canvas;
                if (q.beforeRender && q.beforeRender(w, q), q.pass.length && ((!this.fbo || this.fbo.width !== f || this.fbo.height !== D) && (this.fbo = {
                  width: f,
                  height: D,
                  target: x.createFBO(),
                  buffer: x.createFBO(),
                  swap() {
                    [this.target, this.buffer] = [this.buffer, this.target];
                  }
                }), x.bindFBO(this.fbo.target)), !k && q.filterCanvas) {
                  Object(I.applyShader)(x, {
                    hasTexture: !0
                  });
                  let ii = this.filterContext;
                  ii || (ii = V.default.createCanvas(f, D).getContext("2d"), this.filterContext = ii);
                  const _ = J[q.packIndex], bi = _.filter, $ = J[q.packIndex + 1], oi = J[q.packIndex - 1];
                  (!oi || !oi.filterCanvas || oi.filter !== bi) && (!$ || !$.filterCanvas || $.filter !== bi) ? (O ? (ii.save(), Object(e.drawMesh2D)(_, ii, !1), ii.restore(), Object(e.applyFilter)(ii, bi)) : Object(e.drawMesh2D)(_, ii, !0), this[m](), C(x, ii, f, D)) : (O && ii.save(), Object(e.drawMesh2D)(_, ii, !1), O && ii.restore(), (!$ || !$.filterCanvas || _.filter !== $.filter) && (Object(e.applyFilter)(ii, bi), this[m](), C(x, ii, f, D)));
                } else {
                  if (k)
                    x.program !== k && this.useProgram(k, {
                      a_color: {
                        type: "UNSIGNED_BYTE",
                        normalize: !0
                      }
                    });
                  else {
                    const ii = !!q.uniforms.u_texSampler, _ = !!q.uniforms.u_filterFlag, bi = !!q.uniforms.u_radialGradientVector, $ = !!q.uniforms.u_clipSampler;
                    Object(I.applyShader)(x, {
                      hasTexture: ii,
                      hasFilter: _,
                      hasGradient: bi,
                      hasClipPath: $
                    });
                  }
                  q.filterCanvas && console.warn("User program ignored some filter effects."), this[m](), x.setMeshData([q]), S(x);
                }
                if (q.pass.length) {
                  const ii = q.pass.length;
                  q.pass.forEach((_, bi) => {
                    _.blend = q.enableBlend, _.setTexture(x.fbo.texture), bi === ii - 1 ? x.bindFBO(H) : (this.fbo.swap(), x.bindFBO(this.fbo.target)), _.program ? x.useProgram(_.program) : (this.defaultPassProgram = this.defaultPassProgram || this.createPassProgram(), x.useProgram(this.defaultPassProgram)), x.setMeshData([_.meshData]), w.clear(w.COLOR_BUFFER_BIT), S(x);
                  });
                }
                q.afterRender && q.afterRender(w, q);
              }
            }
          } else
            x.setTransform(this.globalTransformMatrix), x.drawMeshes(J, {
              clear: T
            });
        }
        drawImage(J, ...T) {
          const Y = T.length;
          if (Y < 2)
            throw new TypeError(`Failed to execute 'drawImage' on 'Renderer': 3 arguments required, but only ${T.length + 1} present.`);
          if (Y !== 2 && Y !== 4 && Y !== 8)
            throw new TypeError(`Failed to execute 'drawImage' on 'Renderer': Valid arities are: [3, 5, 9], but ${T.length + 1} arguments provided.`);
          let x = null, H = null;
          Y === 2 ? x = [T[0], T[1], J.width, J.height] : Y === 4 ? x = T : Y === 8 && (H = T.slice(0, 4), x = T.slice(4));
          const Q = this.createTexture(J), {
            width: w,
            height: O
          } = this.canvas, q = new a.default();
          q.rect(x[0], x[1], w, O);
          const k = new G.default(q, {
            width: w,
            height: O
          });
          k.setTexture(Q, {
            rect: x,
            srcRect: H
          }), this.drawMeshes([k]), this.deleteTexture(Q);
        }
        setGlobalTransform(...J) {
          return this[t] = [J[0], J[1], 0, J[2], J[3], 0, J[4], J[5], 1], this;
        }
        globalTransform(...J) {
          const T = this[t];
          return this[t] = c.mat3.multiply(Array.of(0, 0, 0, 0, 0, 0, 0, 0, 0), T, J), this;
        }
        globalTranslate(J, T) {
          let Y = c.mat3.create();
          return Y = c.mat3.translate(Array.of(0, 0, 0, 0, 0, 0, 0, 0, 0), Y, [J, T]), this.globalTransform(...Y);
        }
        globalRotate(J, [T, Y] = [0, 0]) {
          let x = c.mat3.create();
          return x = c.mat3.translate(Array.of(0, 0, 0, 0, 0, 0, 0, 0, 0), x, [T, Y]), x = c.mat3.rotate(Array.of(0, 0, 0, 0, 0, 0, 0, 0, 0), x, J), x = c.mat3.translate(Array.of(0, 0, 0, 0, 0, 0, 0, 0, 0), x, [-T, -Y]), this.globalTransform(...x);
        }
        globalScale(J, T = J, [Y, x] = [0, 0]) {
          let H = c.mat3.create();
          return H = c.mat3.translate(Array.of(0, 0, 0, 0, 0, 0, 0, 0, 0), H, [Y, x]), H = c.mat3.scale(Array.of(0, 0, 0, 0, 0, 0, 0, 0, 0), H, [J, T]), H = c.mat3.translate(Array.of(0, 0, 0, 0, 0, 0, 0, 0, 0), H, [-Y, -x]), this.globalTransform(...H);
        }
        globalSkew(J, T = J, [Y, x] = [0, 0]) {
          let H = c.mat3.create();
          return H = c.mat3.translate(Array.of(0, 0, 0, 0, 0, 0, 0, 0, 0), H, [Y, x]), H = c.mat3.multiply(Array.of(0, 0, 0, 0, 0, 0, 0, 0, 0), H, c.mat3.fromValues(1, Math.tan(T), Math.tan(J), 1, 0, 0)), H = c.mat3.translate(Array.of(0, 0, 0, 0, 0, 0, 0, 0, 0), H, [-Y, -x]), this.globalTransform(...H);
        }
        transformPoint(J, T, Y) {
          let x = this.globalTransformMatrix;
          Y && (x = c.mat3.multiply(Array.of(0, 0, 0, 0, 0, 0, 0, 0, 0), x, Y));
          const H = J * x[0] + T * x[2] + x[4], Q = J * x[1] + T * x[3] + x[5];
          return [H, Q];
        }
      }
    },
    /* 14 */
    /***/
    function(Z, l, i) {
      i.r(l);
      var s = i(15);
      i(1).glMatrix.setMatrixArrayType(Array), l.default = s.default;
    },
    /* 15 */
    /***/
    function(Z, l, i) {
      i.r(l), i.d(l, "default", function() {
        return I;
      });
      var s = i(16), c = i(17), W = i(18), h = i(19);
      i(1).glMatrix.setMatrixArrayType(Array);
      function e(r, p, o) {
        return p in r ? Object.defineProperty(r, p, { value: o, enumerable: !0, configurable: !0, writable: !0 }) : r[p] = o, r;
      }
      const a = {};
      function G(r, p = 3) {
        const o = [], u = r.length;
        for (let d = 0; d < u; d++)
          d % p < 2 && o.push(0.5 * (r[d] + 1));
        return o;
      }
      function y(r, p) {
        const o = p._buffers;
        Object.values(o).forEach((u) => {
          r.deleteBuffer(u);
        }), p._buffers = {};
      }
      function n(r, p, o) {
        return r.activeTexture(r.TEXTURE0 + o), Array.isArray(p._img) ? r.bindTexture(r.TEXTURE_CUBE_MAP, p) : r.bindTexture(r.TEXTURE_2D, p), p;
      }
      const V = {
        int: "1i",
        ivec2: "2i",
        ivec3: "3i",
        ivec4: "4i",
        float: "1f",
        vec2: "2f",
        vec3: "3f",
        vec4: "4f",
        mat2: "Matrix2fv",
        mat3: "Matrix3fv",
        mat4: "Matrix4fv",
        sampler1D: "sampler1D",
        sampler2D: "sampler2D",
        sampler3D: "sampler3D",
        samplerCube: "samplerCube",
        sampler1DShadow: "sampler1DShadow",
        sampler2DShadow: "sampler2DShadow",
        sampler2DRect: "sampler2DRect",
        sampler2DRectShadow: "sampler2DRectShadow"
      };
      class I {
        static addLibs(p = {}) {
          Object.assign(a, p);
        }
        static FLOAT(p, o) {
          return Object(s.pointsToBuffer)(p, Float32Array, o);
        }
        static UNSIGNED_BYTE(p, o) {
          return Object(s.pointsToBuffer)(p, Uint8Array, o);
        }
        static UNSIGNED_SHORT(p, o) {
          return Object(s.pointsToBuffer)(p, Uint16Array, o);
        }
        static BYTE(p, o) {
          return Object(s.pointsToBuffer)(p, Int8Array, o);
        }
        static SHORT(p, o) {
          return Object(s.pointsToBuffer)(p, Int16Array, o);
        }
        constructor(p, o = {}) {
          this.options = Object.assign({}, I.defaultOptions, o), this.canvas = p;
          let u;
          this.options.webgl2 && (u = p.getContext("webgl2", this.options)), u == null && (u = Object(s.setupWebGL)(p, this.options), this.aia_ext = u.getExtension("ANGLE_instanced_arrays")), this.gl = u, u.viewport(0, 0, p.width, p.height), u.clearColor(0, 0, 0, 0), u.blendFuncSeparate(u.SRC_ALPHA, u.ONE_MINUS_SRC_ALPHA, u.ONE, u.ONE_MINUS_SRC_ALPHA), this.programs = [], this._events = {};
        }
        get program() {
          const p = this.gl;
          return p.getParameter(p.CURRENT_PROGRAM);
        }
        // WebGLRenderingContext.uniform[1234][fi][v]()
        // WebGLRenderingContext.uniformMatrix[234]fv()
        _declareUniform(p, o, u = "1f") {
          const d = this.gl, b = d.getUniformLocation(p, o);
          let t;
          const m = this;
          if (/^sampler/.test(u)) {
            const R = p._samplerMap, S = p._bindTextures;
            Object.defineProperty(p.uniforms, o, {
              get() {
                return t;
              },
              set(C) {
                t = C;
                const F = R[o] != null ? R[o] : S.length;
                S[F] = C, n(d, C, F), R[o] || (R[o] = F, d.uniform1i(b, F)), m.options.autoUpdate && m.update();
              },
              configurable: !1,
              enumerable: !0
            });
          } else {
            const R = u.indexOf("Matrix") === 0, S = !R && /v$/.test(u), C = d[`uniform${u}`].bind(d);
            Object.defineProperty(p.uniforms, o, {
              get() {
                return t;
              },
              set(F) {
                t = F, typeof F == "number" && (F = [F]), R ? C(b, !1, F) : S ? C(b, F) : C(b, ...F), m.options.autoUpdate && m.update();
              },
              configurable: !1,
              enumerable: !0
            });
          }
        }
        _draw() {
          const p = this.program;
          p.meshData.forEach((o, u) => {
            const {
              positions: d,
              cells: b,
              instanceCount: t,
              cellsCount: m,
              attributes: R,
              uniforms: S,
              textureCoord: C,
              enableBlend: F
            } = o, K = this.gl;
            let J = o.mode != null ? o.mode : K.TRIANGLES;
            typeof J == "string" && (J = K[J]), F ? K.enable(K.BLEND) : K.disable(K.BLEND), K.bindBuffer(K.ARRAY_BUFFER, p._buffers.verticesBuffer), K.bufferData(K.ARRAY_BUFFER, d, K.STATIC_DRAW), b && (K.bindBuffer(K.ELEMENT_ARRAY_BUFFER, p._buffers.cellsBuffer), K.bufferData(K.ELEMENT_ARRAY_BUFFER, b, K.STATIC_DRAW));
            const T = [];
            R && Object.values(R).forEach(({
              name: x,
              data: H,
              divisor: Q
            }) => {
              if (K.bindBuffer(K.ARRAY_BUFFER, p._buffers[x]), K.bufferData(K.ARRAY_BUFFER, H, K.STATIC_DRAW), Q != null) {
                const w = K.getAttribLocation(p, x);
                w >= 0 && (K.enableVertexAttribArray(w), T.push(w), K.vertexAttribDivisor ? K.vertexAttribDivisor(w, Q) : this.aia_ext && this.aia_ext.vertexAttribDivisorANGLE(w, Q));
              }
            }), S && Object.entries(S).forEach(([x, H]) => {
              this.uniforms[x] = H;
            });
            let Y;
            if (!b) {
              const x = p._dimension;
              Y = d.length / x;
            }
            if (p._enableTextures && p._buffers.texCoordBuffer) {
              const x = C || G(d, p._dimension);
              K.bindBuffer(K.ARRAY_BUFFER, p._buffers.texCoordBuffer), K.bufferData(K.ARRAY_BUFFER, I.FLOAT(x), K.STATIC_DRAW);
            }
            t != null ? (b ? K.drawElementsInstanced ? K.drawElementsInstanced(J, m, K.UNSIGNED_SHORT, 0, t) : this.aia_ext && this.aia_ext.drawElementsInstancedANGLE(J, m, K.UNSIGNED_SHORT, 0, t) : K.drawArraysInstanced ? K.drawArraysInstanced(J, 0, Y, t) : this.aia_ext.drawArraysInstancedANGLE(J, 0, Y, t), T.forEach((x) => {
              K.vertexAttribDivisor ? K.vertexAttribDivisor(x, null) : this.aia_ext && this.aia_ext.vertexAttribDivisorANGLE(x, null);
            })) : b ? K.drawElements(J, m, K.UNSIGNED_SHORT, 0) : K.drawArrays(J, 0, Y);
          });
        }
        get isWebGL2() {
          return typeof WebGL2RenderingContext < "u" && this.gl instanceof WebGL2RenderingContext;
        }
        get enableTextures() {
          return this.program && this.program._enableTextures;
        }
        get uniforms() {
          const p = this.program;
          if (!p || !p.uniforms)
            throw Error("No avaliable program.");
          return p.uniforms;
        }
        deleteProgram(p) {
          const o = this.gl;
          this.program === p && (this.startRender = !1, this._renderFrameID && (cancelAnimationFrame(this._renderFrameID), delete this._renderFrameID), o.useProgram(null));
          const u = this.programs.indexOf(p);
          u >= 0 && this.programs.splice(u, 1), y(o, p), o.deleteProgram(p);
        }
        /**
          [{
            positions: ...
            cells: ...
            textureCoord: ...
            attributes: {name: {data:..., normalize: true}},
            uniforms: ...
          }]
         */
        setMeshData(p) {
          Array.isArray(p) || (p = [p]);
          const o = this.program;
          o.meshData = p.map(({
            mode: u,
            positions: d,
            instanceCount: b,
            cells: t,
            cellsCount: m,
            attributes: R,
            uniforms: S,
            textureCoord: C,
            enableBlend: F
          }) => {
            const K = {
              positions: I.FLOAT(d),
              uniforms: S,
              enableBlend: !!F,
              textureCoord: I.FLOAT(C)
            };
            if (t && (K.cells = I.USHORT(t), K.cellsCount = m || K.cells.length), u != null && (K.mode = u), b != null) {
              if (!this.isWebGL2 && !this.aia_ext)
                throw new Error("Cannot use instanceCount in this rendering context, use webgl2 context instead.");
              K.instanceCount = b;
            }
            if (R) {
              const J = {};
              Object.entries(R).forEach(([T, Y]) => {
                if (!o._attribute[T])
                  o._attribute[T] = "ignored";
                else if (o._attribute[T] !== "ignored") {
                  const {
                    name: x,
                    type: H
                  } = o._attribute[T];
                  let Q = Y.data || Y;
                  if (Array.isArray(Q) && (Q = I[H](Q)), J[T] = {
                    name: x,
                    data: Q
                  }, Y.divisor != null) {
                    if (!this.isWebGL2 && !this.aia_ext)
                      throw new Error("Cannot use divisor in this rendering context, use webgl2 context instead.");
                    J[T].divisor = Y.divisor;
                  }
                }
              }), K.attributes = J;
            }
            return K;
          }), this.options.autoUpdate && this.update();
        }
        createProgram(p, o) {
          const u = /^\s*uniform\s+sampler/mg.test(p);
          p == null && (p = W.default), o == null && (o = u ? h.default : c.default);
          const d = this.gl, b = Object(s.createProgram)(d, o, p);
          b.shaderText = {
            vertexShader: o,
            fragmentShader: p
          }, b._buffers = {}, b._attribute = {}, b.uniforms = {}, b._samplerMap = {}, b._bindTextures = [];
          const t = new RegExp(`(?:attribute|in) vec(\\d) ${this.options.vertexPosition}`, "im");
          let m = o.match(t);
          m && (b._dimension = Number(m[1]));
          const R = new RegExp(`(?:attribute|in) vec(\\d) ${this.options.vertexTextureCoord}`, "im");
          m = o.match(R), m && (b._texCoordSize = Number(m[1]));
          const S = /^\s*(?:attribute|in) (\w+?)(\d*) (\w+)/gim;
          if (m = o.match(S), m)
            for (let K = 0; K < m.length; K++) {
              const J = /^\s*(?:attribute|in) (\w+?)(\d*) (\w+)/im, T = m[K].match(J);
              if (T && T[3] !== this.options.vertexPosition && T[3] !== this.options.vertexTextureCoord) {
                let [, Y, x, H] = T;
                Y === "mat" && (x **= 2), b._buffers[H] = d.createBuffer(), b._attribute[H] = {
                  name: H,
                  type: Y,
                  size: Number(x) || 1
                };
              }
            }
          const C = /^\s*uniform\s+(\w+)\s+(\w+)(\[\d+\])?/mg;
          m = o.match(C) || [], m = m.concat(p.match(C) || []), m.forEach((K) => {
            const J = K.match(/^\s*uniform\s+(\w+)\s+(\w+)(\[\d+\])?/);
            let [T, Y, x] = J.slice(1);
            T = V[T], x = !!x, T.indexOf("Matrix") !== 0 && x && (T += "v"), this._declareUniform(b, Y, T);
          }), b._buffers.verticesBuffer = d.createBuffer(), b._buffers.cellsBuffer = d.createBuffer();
          const F = d.getAttribLocation(b, this.options.vertexTextureCoord);
          return b._enableTextures = F >= 0, b._enableTextures && (b._buffers.texCoordBuffer = d.createBuffer()), this.programs.push(b), b;
        }
        useProgram(p, o = {}) {
          this.startRender = !1, this._renderFrameID && (cancelAnimationFrame(this._renderFrameID), delete this._renderFrameID);
          const u = this.gl;
          u.useProgram(p);
          const d = p._dimension;
          u.bindBuffer(u.ARRAY_BUFFER, p._buffers.verticesBuffer);
          const b = u.getAttribLocation(p, this.options.vertexPosition);
          if (u.vertexAttribPointer(b, d, u.FLOAT, !1, 0, 0), u.enableVertexAttribArray(b), p._enableTextures) {
            u.bindBuffer(u.ARRAY_BUFFER, p._buffers.texCoordBuffer);
            const t = u.getAttribLocation(p, this.options.vertexTextureCoord);
            u.vertexAttribPointer(t, p._texCoordSize || 2, u.FLOAT, !1, 0, 0), u.enableVertexAttribArray(t);
          }
          if (Object.entries(p._attribute).forEach(([t, m]) => {
            if (m !== "ignored") {
              const R = m.size, S = o[t] || {}, C = !!S.normalize;
              let F = S.type || "FLOAT";
              const K = S.key || t;
              F === "UBYTE" && (F = "UNSIGNED_BYTE"), F === "USHORT" && (F = "UNSIGNED_SHORT"), m.type = F, K && K !== t && (p._attribute[K] = m), u.bindBuffer(u.ARRAY_BUFFER, p._buffers[t]);
              const J = u.getAttribLocation(p, t);
              J >= 0 && (u.vertexAttribPointer(J, R, u[F], C, 0, 0), u.enableVertexAttribArray(J));
            }
          }), !p.meshData) {
            const t = [[-1, -1, 0, 1].slice(0, d), [1, -1, 0, 1].slice(0, d), [1, 1, 0, 1].slice(0, d), [-1, 1, 0, 1].slice(0, d)], m = [[0, 1, 3], [3, 1, 2]];
            this.setMeshData({
              positions: t,
              cells: m
            });
          }
          return p;
        }
        compileSync(p, o) {
          p = p || W.default;
          const u = {};
          function d(R) {
            R = R.replace(/^\s*/mg, "");
            const S = [], C = R.match(/^#pragma\s+include\s+.*/mg);
            if (C) {
              for (let F = 0; F < C.length; F++) {
                const J = C[F].match(/(?:<|")(.*)(?:>|")/);
                if (J) {
                  const T = J[0].indexOf("<") === 0 ? "lib" : "link";
                  let Y = J[1];
                  if (Y === "graph" && (Y = "graphics"), u[Y])
                    S.push(`/* included ${Y} */`);
                  else if (u[Y] = !0, T === "lib") {
                    const x = d(a[Y]);
                    S.push(x);
                  } else if (T === "link")
                    throw new Error("Cannot load external links synchronously. Use compile instead of compileSync.");
                }
              }
              S.forEach((F) => {
                R = R.replace(/^#pragma\s+include\s+.*/m, F);
              });
            }
            return R;
          }
          const b = d(p), t = o ? d(o) : null;
          return this.createProgram(b, t);
        }
        async compile(p, o) {
          p = p || W.default;
          const u = {};
          async function d(R) {
            R = R.replace(/^\s*/mg, "");
            const S = [], C = R.match(/^#pragma\s+include\s+.*/mg);
            if (C) {
              for (let F = 0; F < C.length; F++) {
                const J = C[F].match(/(?:<|")(.*)(?:>|")/);
                if (J) {
                  const T = J[0].indexOf("<") === 0 ? "lib" : "link";
                  let Y = J[1];
                  if (Y === "graph" && (Y = "graphics"), u[Y])
                    S.push(`/* included ${Y} */`);
                  else if (u[Y] = !0, T === "lib") {
                    const x = await d(a[Y]);
                    S.push(x);
                  } else if (T === "link") {
                    let x = await I.fetchShader(Y);
                    x = await d(x), S.push(x);
                  }
                }
              }
              S.forEach((F) => {
                R = R.replace(/^#pragma\s+include\s+.*/m, F);
              });
            }
            return R;
          }
          const b = await d(p), t = o ? await d(o) : null;
          return this.createProgram(b, t);
        }
        async load(p, o = null) {
          return p = await I.fetchShader(p), o && (o = await I.fetchShader(o)), this.compile(p, o);
        }
        createTexture(p = null, {
          wrapS: o = this.gl.CLAMP_TO_EDGE,
          wrapT: u = this.gl.CLAMP_TO_EDGE,
          minFilter: d = this.gl.LINEAR,
          magFilter: b = this.gl.LINEAR
        } = {}) {
          const t = this.gl, m = Array.isArray(p) ? t.TEXTURE_CUBE_MAP : t.TEXTURE_2D;
          this._max_texture_image_units = this._max_texture_image_units || t.getParameter(t.MAX_COMBINED_TEXTURE_IMAGE_UNITS), t.activeTexture(t.TEXTURE0 + this._max_texture_image_units - 1);
          const R = t.createTexture();
          t.bindTexture(m, R), t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, !0);
          const {
            width: S,
            height: C
          } = this.canvas;
          if (p)
            if (m === t.TEXTURE_CUBE_MAP)
              for (let F = 0; F < 6; F++)
                t.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + F, 0, t.RGBA, t.RGBA, t.UNSIGNED_BYTE, p[F]);
            else
              t.texImage2D(m, 0, t.RGBA, t.RGBA, t.UNSIGNED_BYTE, p);
          else if (m === t.TEXTURE_CUBE_MAP)
            for (let F = 0; F < 6; F++)
              this.gl.texImage2D(this.gl.TEXTURE_CUBE_MAP_POSITIVE_X + F, 0, t.RGBA, S, C, 0, t.RGBA, t.UNSIGNED_BYTE, null);
          else
            t.texImage2D(m, 0, t.RGBA, S, C, 0, t.RGBA, t.UNSIGNED_BYTE, null);
          return t.texParameteri(m, t.TEXTURE_MIN_FILTER, d), t.texParameteri(m, t.TEXTURE_MAG_FILTER, b), t.texParameteri(m, t.TEXTURE_WRAP_S, o), t.texParameteri(m, t.TEXTURE_WRAP_T, u), m === t.TEXTURE_CUBE_MAP && (p.width = p[0].width, p.height = p[0].height), t.bindTexture(m, null), R._img = p || {
            width: S,
            height: C
          }, R.delete = () => {
            this.deleteTexture(R);
          }, R;
        }
        deleteTexture(p) {
          const o = p._img;
          this.gl.deleteTexture(p), typeof o.close == "function" && o.close();
        }
        async loadTexture(p, {
          useImageBitmap: o = !0
        } = {}) {
          const u = await I.loadImage(p, {
            useImageBitmap: o
          });
          return this.createTexture(u);
        }
        createFBO({
          color: p = 1,
          blend: o = !1,
          depth: u = this.options.depth !== !1,
          stencil: d = !!this.options.stencil
        } = {}) {
          const b = this.gl, t = b.createFramebuffer();
          b.bindFramebuffer(b.FRAMEBUFFER, t);
          const m = [];
          for (let C = 0; C < p; C++) {
            const F = this.createTexture();
            b.framebufferTexture2D(
              b.FRAMEBUFFER,
              b.COLOR_ATTACHMENT0 + C,
              b.TEXTURE_2D,
              F,
              0
              /* level */
            ), m.push(F);
          }
          t.textures = m, t.texture = m[0], t.blend = o;
          const {
            width: R,
            height: S
          } = this.canvas;
          return u && !d && (t.depthBuffer = b.createRenderbuffer(), b.bindRenderbuffer(b.RENDERBUFFER, t.depthBuffer), b.renderbufferStorage(b.RENDERBUFFER, b.DEPTH_COMPONENT16, R, S), b.framebufferRenderbuffer(b.FRAMEBUFFER, b.DEPTH_ATTACHMENT, b.RENDERBUFFER, t.depthBuffer)), d && !u && (t.stencilBuffer = b.createRenderbuffer(), b.bindRenderbuffer(b.RENDERBUFFER, t.stencilBuffer), b.renderbufferStorage(b.RENDERBUFFER, b.STENCIL_INDEX8, R, S), b.framebufferRenderbuffer(b.FRAMEBUFFER, b.STENCIL_ATTACHMENT, b.RENDERBUFFER, t.stencilBuffer)), u && d && (t.depthStencilBuffer = b.createRenderbuffer(), b.bindRenderbuffer(b.RENDERBUFFER, t.depthStencilBuffer), b.renderbufferStorage(b.RENDERBUFFER, b.DEPTH_STENCIL, R, S), b.framebufferRenderbuffer(b.FRAMEBUFFER, b.DEPTH_STENCIL_ATTACHMENT, b.RENDERBUFFER, t.depthStencilBuffer)), b.bindFramebuffer(b.FRAMEBUFFER, null), t;
        }
        bindFBO(p = null) {
          this.fbo = p;
        }
        render({
          clearBuffer: p = !0
        } = {}) {
          this.startRender = !0;
          const o = this.gl;
          let u = this.program;
          u || (u = this.createProgram(), this.useProgram(u)), this.fbo && o.bindFramebuffer(o.FRAMEBUFFER, this.fbo);
          const d = this.options.depth;
          d && o.enable(o.DEPTH_TEST), this.gl.clear(this.gl.COLOR_BUFFER_BIT | (d ? this.gl.DEPTH_BUFFER_BIT : 0) | (this.options.stencil ? this.gl.STENCIL_BUFFER_BIT : 0));
          const b = this._renderFrameID;
          this._draw(), this.fbo && o.bindFramebuffer(o.FRAMEBUFFER, null), this._renderFrameID === b && (this._renderFrameID = null);
        }
        update() {
          this.startRender && this._renderFrameID == null && (this._renderFrameID = requestAnimationFrame(this.render.bind(this)));
        }
      }
      e(I, "defaultOptions", {
        preserveDrawingBuffer: !0,
        autoUpdate: !0,
        vertexPosition: "a_vertexPosition",
        vertexTextureCoord: "a_vertexTextureCoord",
        webgl2: !1
      }), e(I, "UBYTE", I.UNSIGNED_BYTE), e(I, "USHORT", I.UNSIGNED_SHORT), e(I, "fetchShader", s.fetchShader), e(I, "loadImage", s.loadImage);
    },
    /* 16 */
    /***/
    function(Z, l, i) {
      i.r(l), i.d(l, "setupWebGL", function() {
        return c;
      }), i.d(l, "createProgram", function() {
        return W;
      }), i.d(l, "pointsToBuffer", function() {
        return h;
      }), i.d(l, "loadImage", function() {
        return a;
      }), i.d(l, "fetchShader", function() {
        return y;
      }), i(1).glMatrix.setMatrixArrayType(Array);
      function s(n, V) {
        const I = ["webgl", "experimental-webgl", "webkit-3d", "moz-webgl"];
        let r = null;
        for (let p = 0; p < I.length; ++p) {
          try {
            r = n.getContext(I[p], V);
          } catch {
          }
          if (r)
            break;
        }
        return r;
      }
      function c(n, V) {
        const I = s(n, V);
        if (!I)
          throw new Error("Sorry, your browser doesn't support WebGL.");
        return I;
      }
      function W(n, V, I) {
        const r = n.createShader(n.VERTEX_SHADER);
        if (n.shaderSource(r, V), n.compileShader(r), !n.getShaderParameter(r, n.COMPILE_STATUS)) {
          const u = `Vertex shader failed to compile.  The error log is:${n.getShaderInfoLog(r)}`;
          throw new Error(u);
        }
        const p = n.createShader(n.FRAGMENT_SHADER);
        if (n.shaderSource(p, I), n.compileShader(p), !n.getShaderParameter(p, n.COMPILE_STATUS)) {
          const u = `Fragment shader failed to compile.  The error log is:${n.getShaderInfoLog(p)}`;
          throw new Error(u);
        }
        const o = n.createProgram();
        if (n.attachShader(o, r), n.attachShader(o, p), n.linkProgram(o), !n.getProgramParameter(o, n.LINK_STATUS)) {
          const u = `Shader program failed to link.  The error log is:${n.getProgramInfoLog(o)}`;
          throw new Error(u);
        }
        return n.deleteShader(r), n.deleteShader(p), o;
      }
      function h(n, V = Float32Array, I = null) {
        if (I && !(I instanceof V))
          throw new TypeError("Wrong buffer type.");
        if (n == null || n instanceof V)
          return n;
        if (n[0] == null || n[0].length == null)
          return I ? (I.set(n, 0), I) : new V(n);
        const r = n[0].length, p = n.length;
        I || (I = new V(r * p));
        let o = 0;
        for (let u = 0; u < p; u++)
          for (let d = 0; d < r; d++)
            I[o++] = n[u][d];
        return I;
      }
      const e = {};
      function a(n, {
        useImageBitmap: V = !0,
        alias: I = null
      } = {}) {
        if (!e[n]) {
          if (typeof Image == "function") {
            const r = new Image();
            typeof n == "string" && !(typeof location == "object" && /^file:/.test(location.href)) && !/^data:/.test(n) && (r.crossOrigin = "anonymous"), e[n] = new Promise((p) => {
              r.onload = function() {
                V && typeof createImageBitmap == "function" ? createImageBitmap(r, {
                  imageOrientation: "flipY"
                }).then((o) => {
                  e[n] = o, I && (e[I] = o), p(o);
                }) : (e[n] = r, I && (e[I] = r), p(r));
              }, r.src = n;
            }), I && (e[I] = e[n]);
          } else if (typeof fetch == "function")
            return fetch(n, {
              method: "GET",
              mode: "cors",
              cache: "default"
            }).then((r) => r.blob()).then((r) => createImageBitmap(r, {
              imageOrientation: "flipY"
            }).then((p) => (e[n] = p, I && (e[I] = p), p)));
        }
        return e[n];
      }
      const G = {};
      async function y(n) {
        if (G[n])
          return G[n];
        const V = await fetch(n);
        if (V.status >= 200 && V.status < 300) {
          const I = await V.text();
          return G[n] = I, I;
        }
        throw new Error("Shader loaded error.");
      }
    },
    /* 17 */
    /***/
    function(Z, l, i) {
      i.r(l), l.default = `attribute vec3 a_vertexPosition;

void main() {
  gl_PointSize = 1.0;
  gl_Position = vec4(a_vertexPosition, 1);
}`;
    },
    /* 18 */
    /***/
    function(Z, l, i) {
      i.r(l), l.default = `#ifdef GL_ES
precision mediump float;
#endif

void main() {
  gl_FragColor = vec4(0.0, 0.0, 0.0, 0.1);
}`;
    },
    /* 19 */
    /***/
    function(Z, l, i) {
      i.r(l), l.default = `attribute vec4 a_vertexPosition;
attribute vec2 a_vertexTextureCoord;
varying vec2 vTextureCoord;

void main() {
  gl_PointSize = 1.0;
  gl_Position = a_vertexPosition;
  vTextureCoord = a_vertexTextureCoord;
}`;
    },
    /* 20 */
    /***/
    function(Z, l, i) {
      i.r(l), i.d(l, "default", function() {
        return h;
      });
      var s = i(21), c = i(25);
      i(1).glMatrix.setMatrixArrayType(Array);
      const W = Symbol("transform");
      class h {
        constructor(a, G) {
          this.context = a.getContext("2d"), this.options = G, this[W] = [1, 0, 0, 1, 0, 0];
        }
        createTexture(a) {
          return {
            _img: a
          };
        }
        async loadTexture(a) {
          const G = await s.default.loadImage(a, {
            useImageBitmap: !1
          });
          return this.createTexture(G);
        }
        deleteTexture(a) {
          return a;
        }
        clear(a, G, y, n) {
          const V = this.context;
          a = a || 0, G = G || 0, y = y || V.canvas.width - a, n = n || V.canvas.height - G, V.clearRect(a, G, y, n);
        }
        drawMeshCloud(a, {
          clear: G = !1
        } = {}) {
          const y = [];
          for (let n = 0; n < a.amount; n++) {
            const V = a.getTransform(n);
            let I = a.getTextureFrame(n);
            I && (I = I._img);
            const r = a.getFilter(n), {
              fill: p,
              stroke: o
            } = a.getCloudRGBA(n);
            y.push({
              mesh: a.mesh,
              _cloudOptions: [p, o, I, V, r]
            });
          }
          a.beforeRender && a.beforeRender(this.context, a), this.drawMeshes(y, {
            clear: G,
            hook: !1
          }), a.afterRender && a.afterRender(this.context, a);
        }
        drawMeshes(a, {
          clear: G = !1,
          hook: y = !0
        } = {}) {
          const n = this.context;
          G && n.clearRect(0, 0, n.canvas.width, n.canvas.height);
          let V = null;
          const {
            width: I,
            height: r
          } = n.canvas, p = a.length;
          a.forEach((o, u) => {
            let d, b, t, m, R;
            y && o.beforeRender && o.beforeRender(n, o), o._cloudOptions && ([d, b, t, m, R] = o._cloudOptions, o = o.mesh);
            let S = o.filter;
            if (R && (S = S ? `${S} ${R}` : R), S && !this.filterBuffer && this.filterBuffer !== !1) {
              const C = s.default.createCanvas(I, r);
              C ? this.filterBuffer = C.getContext("2d") : this.filterBuffer = !1;
            }
            V && V !== S && (Object(c.applyFilter)(this.filterBuffer, V), n.drawImage(this.filterBuffer.canvas, 0, 0, I, r), this.filterBuffer.clearRect(0, 0, I, r), V = null), S && this.filterBuffer ? (this.filterBuffer.save(), this.filterBuffer.transform(...this[W]), Object(c.drawMesh2D)(o, this.filterBuffer, !1, d, b, t, m), this.filterBuffer.restore(), u === p - 1 ? (Object(c.applyFilter)(this.filterBuffer, S), n.drawImage(this.filterBuffer.canvas, 0, 0, I, r), this.filterBuffer.clearRect(0, 0, I, r)) : V = S) : (n.save(), n.transform(...this[W]), Object(c.drawMesh2D)(o, n, !1, d, b, t, m), n.restore()), y && o.afterRender && o.afterRender(n, o);
          });
        }
        setTransform(a) {
          this[W] = a;
        }
      }
    },
    /* 21 */
    /***/
    function(Z, l, i) {
      i.r(l), (function(s) {
        var c = i(14), W = i(23), h = i(24);
        i(1).glMatrix.setMatrixArrayType(Array);
        const e = {};
        function a(I, r) {
          const {
            style: p,
            variant: o,
            weight: u,
            stretch: d,
            size: b,
            pxLineHeight: t,
            family: m
          } = I;
          return d === "normal" ? `${p} ${o} ${u} ${b * r}px/${t * r}px ${m}` : `${p} ${o} ${u} ${d} ${b * r}px/${t * r}px ${m}`;
        }
        function G(I, {
          font: r,
          fillColor: p,
          strokeColor: o,
          strokeWidth: u,
          ratio: d = 1,
          textCanvas: b,
          cachable: t = !1
        }) {
          let m;
          if (t) {
            m = [I, r, String(p), String(o), String(u)].join("###");
            const Q = e[m];
            if (Q)
              return Q;
          }
          b || (b = n(1, 1));
          const R = b.getContext("2d");
          R.save(), R.font = r;
          let {
            width: S
          } = R.measureText(I);
          R.restore();
          const C = Object(W.default)(r), F = Math.max(C.pxLineHeight, C.pxHeight * 1.13);
          /italic|oblique/.test(r) && (S += F * Math.tan(15 * Math.PI / 180)), !p && !o && (p = "#000");
          const K = R.canvas, J = Math.ceil(S), T = Math.ceil(F);
          K.width = Math.round(J * d), K.height = Math.round(T * d), R.save(), R.font = a(C, d), R.textAlign = "center", R.textBaseline = "middle";
          const Y = K.height * 0.5 + C.pxHeight * 0.05 * d, x = K.width * 0.5;
          if (p) {
            if (Array.isArray(p))
              p = Object(h.default)(p);
            else if (p.vector) {
              let Q;
              const {
                vector: w,
                colors: O
              } = p;
              w.length === 6 ? Q = R.createRadialGradient(...w) : Q = R.createLinearGradient(...w), O.forEach(({
                offset: q,
                color: k
              }) => {
                Q.addColorStop(q, k);
              }), p = Q;
            }
            R.fillStyle = p, R.fillText(I, x, Y);
          }
          if (o) {
            if (R.lineWidth = u * d, Array.isArray(o))
              o = Object(h.default)(o);
            else if (o.vector) {
              let Q;
              const {
                vector: w,
                colors: O
              } = o;
              w.length === 6 ? Q = R.createRadialGradient(...w) : Q = R.createLinearGradient(...w), O.forEach(({
                offset: q,
                color: k
              }) => {
                Q.addColorStop(q, k);
              }), o = Q;
            }
            R.strokeStyle = o, R.strokeText(I, x, Y);
          }
          R.restore();
          const H = {
            image: b,
            rect: [0, 0, J, T]
          };
          return t && (e[m] = H), H;
        }
        let y = !1;
        if (typeof navigator == "object" && typeof navigator.userAgent == "string") {
          const I = navigator.userAgent.toLowerCase().match(/chrome\/(\d+)/);
          I && (y = Number(I[1]) < 70);
        }
        function n(I, r, p = {}) {
          const o = p.offscreen || !y && p.offscreen !== !1;
          let u;
          return typeof s < "u" && typeof s.createCanvas == "function" ? u = s.createCanvas(I, r, p) : o && typeof OffscreenCanvas == "function" ? u = new OffscreenCanvas(I, r) : (u = document.createElement("canvas"), u.width = I, u.height = r), u;
        }
        const V = {
          createCanvas: n,
          createText: G,
          loadImage: c.default.loadImage
        };
        l.default = V;
      }).call(this, i(22));
    },
    /* 22 */
    /***/
    function(Z, l) {
      var i;
      i = /* @__PURE__ */ function() {
        return this;
      }();
      try {
        i = i || new Function("return this")();
      } catch {
        typeof window == "object" && (i = window);
      }
      Z.exports = i;
    },
    /* 23 */
    /***/
    function(Z, l, i) {
      i.r(l), i.d(l, "default", function() {
        return p;
      }), i(1).glMatrix.setMatrixArrayType(Array);
      function s(o, u) {
        if (typeof o == "string") {
          const t = o.trim().match(/^([\d.]+)(px|pt|pc|in|cm|mm|em|ex|rem|q|vw|vh|vmax|vmin|%)$/);
          t ? o = {
            size: parseFloat(t[1]),
            unit: t[2]
          } : o = {
            size: parseInt(o, 10),
            unit: "px"
          };
        }
        let {
          size: d,
          unit: b
        } = o;
        if (b === "pt")
          d /= 0.75;
        else if (b === "pc")
          d *= 16;
        else if (b === "in")
          d *= 96;
        else if (b === "cm")
          d *= 96 / 2.54;
        else if (b === "mm")
          d *= 96 / 25.4;
        else if (b === "em" || b === "rem" || b === "ex") {
          if (!u && typeof getComputedStyle == "function" && typeof document < "u") {
            const t = getComputedStyle(document.documentElement).fontSize;
            u = s(t, 16);
          }
          d *= u, b === "ex" && (d /= 2);
        } else if (b === "q")
          d *= 96 / 25.4 / 4;
        else if (b === "vw" || b === "vh") {
          if (typeof document < "u") {
            const t = b === "vw" ? document.documentElement.clientWidth : document.documentElement.clientHeight;
            d *= t / 100;
          }
        } else if ((b === "vmax" || b === "vmin") && typeof document < "u") {
          const t = document.documentElement.clientWidth, m = document.documentElement.clientHeight;
          b === "vmax" ? d *= Math.max(t, m) / 100 : d *= Math.min(t, m) / 100;
        }
        return d;
      }
      const c = "bold|bolder|lighter|[1-9]00", W = "italic|oblique", h = "small-caps", e = "ultra-condensed|extra-condensed|condensed|semi-condensed|semi-expanded|expanded|extra-expanded|ultra-expanded", a = "px|pt|pc|in|cm|mm|em|ex|rem|q|vw|vh|vmax|vmin|%", G = `'([^']+)'|"([^"]+)"|([\\w-]|[一-龥])+`, y = new RegExp(`(${c}) +`, "i"), n = new RegExp(`(${W}) +`, "i"), V = new RegExp(`(${h}) +`, "i"), I = new RegExp(`(${e}) +`, "i"), r = new RegExp("([\\d\\.]+)(" + a + ")(?:\\/([\\d\\.]+)(" + a + "))? *((?:" + G + ")( *, *(?:" + G + "))*)");
      function p(o, u) {
        const d = r.exec(o);
        if (!d)
          return;
        const b = parseFloat(d[3]), t = {
          weight: "normal",
          style: "normal",
          stretch: "normal",
          variant: "normal",
          size: parseFloat(d[1]),
          unit: d[2],
          lineHeight: Number.isFinite(b) ? b : void 0,
          lineHeightUnit: d[4],
          family: d[5].replace(/ *, */g, ",")
        }, m = o.substring(0, d.index), R = y.exec(m), S = n.exec(m), C = V.exec(m), F = I.exec(m);
        return R && (t.weight = R[1]), S && (t.style = S[1]), C && (t.variant = C[1]), F && (t.stretch = F[1]), t.pxHeight = s({
          size: t.size,
          unit: t.unit
        }, u), t.pxLineHeight = s({
          size: t.lineHeight || t.size,
          unit: t.lineHeightUnit || t.unit
        }, u), t;
      }
    },
    /* 24 */
    /***/
    function(Z, l, i) {
      i.r(l), i.d(l, "default", function() {
        return s;
      }), i(1).glMatrix.setMatrixArrayType(Array);
      function s(c) {
        return `rgba(${c.map((W, h) => h < 3 ? Math.round(W * 255) : W).join()})`;
      }
    },
    /* 25 */
    /***/
    function(Z, l, i) {
      i.r(l), i.d(l, "applyFilter", function() {
        return e;
      }), i.d(l, "drawMesh2D", function() {
        return G;
      });
      var s = i(1), c = i(24), W = i(23), h = i(26);
      i(1).glMatrix.setMatrixArrayType(Array);
      function e(y, n) {
        const V = y.canvas;
        y.save(), y.filter = n, y.drawImage(V, 0, 0, V.width, V.height), y.restore();
      }
      function a(y, n) {
        const V = /rgba\((\d+),(\d+),(\d+),(\d+)\)/;
        y = y.match(V).slice(1, 5).map(Number), n = n.match(V).slice(1, 5).map(Number);
        const I = [], r = n[3];
        for (let p = 0; p < 4; p++)
          I[p] = Object(h.mix)(y[p], n[p], r);
        return `rgba(${I.join()})`;
      }
      function G(y, n, V = !0, I = null, r = null, p = null, o = null) {
        n.save();
        let u = !1, d = !1;
        if (n.globalAlpha = y.getOpacity(), y._updateMatrix && y.transformScale / y.contours.scale > 1.5 && y.accurate(y.transformScale), y.lineWidth) {
          let m = y.gradient && y.gradient.stroke;
          if (m) {
            const {
              vector: R,
              colors: S
            } = m;
            if (R.length === 6)
              m = n.createRadialGradient(...R);
            else if (R.length === 4)
              m = n.createLinearGradient(...R);
            else if (R.length === 3)
              m = n.createCircularGradient(...R);
            else
              throw new TypeError("Invalid vector dimension.");
            S.forEach(({
              offset: C,
              color: F
            }) => {
              let K = Object(c.default)(F);
              r && (K = a(K, r)), m.addColorStop(C, K);
            }), n.strokeStyle = m, u = !0;
          } else
            y.strokeStyle && (r ? n.strokeStyle = a(y.strokeStyle, r) : n.strokeStyle = y.strokeStyle, u = !0);
        }
        u && (n.lineWidth = y.lineWidth, n.lineJoin = y.lineJoin, n.lineCap = y.lineCap, n.miterLimit = y.miterLimit, y.lineDash && (n.setLineDash(y.lineDash), y.lineDashOffset && (n.lineDashOffset = y.lineDashOffset)));
        let b = y.gradient && y.gradient.fill;
        if (b) {
          const {
            vector: m,
            colors: R
          } = b;
          if (m.length === 6)
            b = n.createRadialGradient(...m);
          else if (m.length === 4)
            b = n.createLinearGradient(...m);
          else if (m.length === 3)
            b = n.createCircularGradient(...m);
          else
            throw new TypeError("Invalid vector dimension.");
          R.forEach(({
            offset: S,
            color: C
          }) => {
            let F = Object(c.default)(C);
            r && (F = a(F, r)), b.addColorStop(S, F);
          }), n.fillStyle = b, d = !0;
        } else
          y.fillStyle && (I ? n.fillStyle = a(y.fillStyle, I) : n.fillStyle = y.fillStyle, d = !0);
        if (o && n.transform(...o), n.transform(...y.transformMatrix), y.clipPath) {
          const m = y.clipPath, R = new Path2D(m);
          n.clip(R);
        }
        const t = y.contours.length;
        if (y.contours.forEach((m, R) => {
          const S = m.length, C = S > 1 && s.vec2.equals(m[0], m[S - 1]), F = R === t - 1 && y.texture;
          if (m && S > 0) {
            if (d || u || F) {
              n.beginPath(), n.moveTo(...m[0]);
              for (let K = 1; K < S; K++)
                K === S - 1 && C ? n.closePath() : n.lineTo(...m[K]);
            }
            if (d && n.fill(y.fillRule), F) {
              n.save(), n.clip();
              let {
                image: K,
                options: J
              } = y.texture;
              if (p && (K = p), J.repeat && console.warn("Context 2D not supported image repeat yet."), K.font) {
                J.scale && console.warn("Context 2D not supported text scale yet."), J.srcRect && console.warn("Context 2D not supported text srcRect yet.");
                let {
                  font: T,
                  fillColor: Y,
                  strokeColor: x,
                  strokeWidth: H,
                  text: Q
                } = K;
                !Y && !x && (Y = "#000"), Array.isArray(Y) && (Y = Object(c.default)(Y)), Array.isArray(x) && (x = Object(c.default)(x)), n.font = T;
                const {
                  width: w
                } = n.measureText(Q), O = Object(W.default)(T), q = Math.max(O.pxLineHeight, O.pxHeight * 1.13);
                n.textAlign = "center", n.textBaseline = "middle";
                const k = J.rect, f = k[0] + q * 0.5 + O.pxHeight * 0.06, D = k[1] + w * 0.5;
                k[2] != null && n.scale(k[2] / w, k[3] / q), Y && (n.fillStyle = Y, n.fillText(Q, D, f)), x && (n.lineWidth = H, n.strokeStyle = x, n.strokeText(Q, D, f));
              } else {
                let T = J.rect;
                const Y = J.srcRect;
                J.scale && (T = [0, 0, n.canvas.width, n.canvas.height]), J.rotated && T && (T = [-T[1], T[0], T[3], T[2]]), Y && (T = T || [0, 0, Y[2], Y[3]]), J.rotated && (n.translate(0, T ? T[2] : K.width), n.rotate(-0.5 * Math.PI)), Y ? n.drawImage(K, ...Y, ...T) : T ? n.drawImage(K, ...T) : n.drawImage(K, 0, 0);
              }
              n.restore();
            }
            u && n.stroke();
          }
        }), n.restore(), V) {
          const m = y.filter;
          m && e(n, m);
        }
      }
    },
    /* 26 */
    /***/
    function(Z, l, i) {
      i.r(l), i.d(l, "clamp", function() {
        return s;
      }), i.d(l, "mix", function() {
        return c;
      }), i.d(l, "transformPoint", function() {
        return W;
      }), i(1).glMatrix.setMatrixArrayType(Array);
      function s(h, e, a) {
        return e > a && ([e, a] = [a, e]), h < e ? e : h > a ? a : h;
      }
      function c(h, e, a) {
        return h * (1 - a) + e * a;
      }
      function W(h, e) {
        const [a, G] = h;
        return [a * e[0] + G * e[2] + e[4], a * e[1] + G * e[3] + e[5]];
      }
    },
    /* 27 */
    /***/
    function(Z, l, i) {
      i.r(l), i.d(l, "default", function() {
        return a;
      });
      var s = i(28), c = i(29);
      i(1).glMatrix.setMatrixArrayType(Array);
      function W(G, y, n) {
        const V = G.uniforms || {}, I = y.uniforms || {};
        if (V.u_texSampler && I.u_texSampler && V.u_texSampler !== I.u_texSampler)
          return !1;
        const r = Object.keys(V), p = Object.keys(I), o = r.indexOf("u_texSampler"), u = p.indexOf("u_texSampler");
        if (o >= 0 && r.splice(o, 1), u >= 0 && p.splice(u, 1), r.length !== p.length)
          return !1;
        const d = r.every((b) => {
          const t = V[b], m = I[b];
          if (t === m)
            return !0;
          if (t.length && m.length && t.length === m.length) {
            for (let R = 0; R < t.length; R++)
              if (t[R] !== m[R])
                return !1;
            return !0;
          }
          return !1;
        });
        if (d) {
          if (V.u_texSampler && !I.u_texSampler)
            y.setTexture(V.u_texSampler, {
              hidden: !0
            });
          else if (!V.u_texSampler && I.u_texSampler)
            for (let b = 0; b < n.length; b++)
              n[b].setTexture(I.u_texSampler, {
                hidden: !0
              });
        }
        return d;
      }
      const h = {};
      function e(G, y) {
        if (G.length) {
          const n = Object(s.default)(G, h);
          return n.enableBlend = y, G[0].filterCanvas && (n.filterCanvas = !0), n.packIndex = G[0].packIndex, n.packLength = G.length, n.beforeRender = G[0].beforeRender, n.pass = G[0].pass, n.afterRender = G[G.length - 1].afterRender, G.length = 0, n;
        }
      }
      function* a(G, y, n = !1) {
        const V = [], I = G.options.bufferSize;
        let r = 0, p = !1;
        for (let o = 0; o < y.length; o++) {
          const u = y[o];
          if (u instanceof c.default)
            V.length && (yield e(V, p)), r = 0, p = !1, yield u;
          else {
            const d = u.meshData;
            if (d.clipPath && !d.uniforms.u_clipSampler) {
              const t = G.createTexture(d.clipPath);
              d.uniforms.u_clipSampler = t;
            }
            let b = 0;
            if ((!n || !u.canIgnore()) && d && d.positions.length) {
              u.packIndex = o;
              const t = u.filterCanvas;
              if (b = d.positions.length, t || r + b > I)
                V.length && (yield e(V, p)), r = 0, p = !1;
              else if (r) {
                const m = V[V.length - 1];
                m && (m.filterCanvas || m.afterRender || u.beforeRender || m.pass.length || u.pass.length || m.program !== u.program || !W(m, u, V)) && (yield e(V, p), r = 0, p = !1);
              }
              V.push(u), p = p || u.enableBlend, r += b;
            }
            o === y.length - 1 && V.length && (yield e(V, p));
          }
        }
      }
    },
    /* 28 */
    /***/
    function(Z, l, i) {
      i.r(l), i.d(l, "default", function() {
        return W;
      }), i(1).glMatrix.setMatrixArrayType(Array);
      const s = {
        UNSIGNED_BYTE: Uint8Array,
        UNSIGNED_SHORT: Uint16Array,
        BYTE: Int8Array,
        SHORT: Int16Array,
        FLOAT: Float32Array
      };
      function c(h, e) {
        let a = 0, G = 0, y = 0, n = 0, V = 0, I = 0, r = 0;
        const p = h[0].program;
        for (let o = 0; o < h.length; o++) {
          const u = h[o].meshData;
          if (u) {
            r += u.positions.length;
            const d = u.positions[0].length;
            a += u.positions.length * d, G += u.cells.length * 3, I += u.attributes.a_color.length * 4;
            const b = u.textureCoord;
            b && (y += b.length * b[0].length);
            const t = u.attributes.a_sourceRect;
            t && (n += t.length * 4);
            const m = u.attributes.a_clipUV;
            m && (V += m.length * 2);
          }
        }
        if ((!e.positions || e.positions.length < a) && (e.positions = new Float32Array(a)), (!e.cells || e.cells.length < G) && (e.cells = new Uint16Array(G)), y && (!e.textureCoord || e.textureCoord.length < y) && (e.textureCoord = new Float32Array(y)), (!e.a_color || e.a_color.length < I) && (e.a_color = new Uint8Array(I)), n && (!e.a_sourceRect || e.a_sourceRect.length < n) && (e.a_sourceRect = new Float32Array(n)), V && (!e.a_clipUV || e.a_clipUV.length < V) && (e.a_clipUV = new Float32Array(V)), p) {
          const o = Object.entries(p._attribute), u = p._attribOpts || {};
          for (let d = 0; d < o.length; d++) {
            const [b, t] = o[d];
            if (b !== "a_color" && b !== "a_sourceRect" && t !== "ignored") {
              const m = u[b] ? u[b].type : "FLOAT", R = s[m], S = t.size * r;
              (!e[b] || e[b].length < S) && (e[b] = new R(S));
            }
          }
        }
        return e;
      }
      function W(h, e) {
        let a = [], G = [], y = [], n = [], V = [], I = [], r = 0, p = 0;
        const o = h[0] ? h[0].uniforms || {} : {}, u = h[0] ? h[0].program : null;
        e && (c(h, e), G = e.cells, a = e.positions, y = e.textureCoord, n = e.a_color, V = e.a_sourceRect, I = e.a_clipUV);
        let d = !1, b = !1;
        const t = {};
        for (let R = 0; R < h.length; R++) {
          let S = h[R];
          if (S) {
            if (S.meshData && (S = S.meshData), e) {
              const F = S.positions;
              for (let K = 0; K < F.length; K++) {
                const J = F[K], T = 3 * (r + K);
                for (let Y = 0; Y < J.length; Y++)
                  a[T + Y] = J[Y];
              }
            } else
              a.push(...S.positions);
            const C = S.cells;
            for (let F = 0; F < C.length; F++) {
              const K = C[F];
              if (e) {
                const J = 3 * (p + F);
                G[J] = K[0] + r, G[J + 1] = K[1] + r, G[J + 2] = K[2] + r;
              } else
                G.push([K[0] + r, K[1] + r, K[2] + r]);
            }
            if (e) {
              const F = S.attributes.a_color;
              for (let K = 0; K < F.length; K++) {
                const J = F[K], T = 4 * (r + K);
                n[T] = J[0], n[T + 1] = J[1], n[T + 2] = J[2], n[T + 3] = J[3];
              }
            } else
              n.push(...S.attributes.a_color);
            if (S.attributes.a_sourceRect)
              if (d = !0, e) {
                const F = S.attributes.a_sourceRect;
                for (let K = 0; K < F.length; K++) {
                  const J = F[K], T = 4 * (r + K);
                  V[T] = J[0], V[T + 1] = J[1], V[T + 2] = J[2], V[T + 3] = J[3];
                }
              } else
                V.push(...S.attributes.a_sourceRect);
            if (S.attributes.a_clipUV)
              if (b = !0, e) {
                const F = S.attributes.a_clipUV;
                for (let K = 0; K < F.length; K++) {
                  const J = F[K], T = 2 * (r + K);
                  I[T] = J[0], I[T + 1] = J[1];
                }
              } else
                I.push(...S.attributes.a_clipUV);
            if (S.textureCoord)
              if (e) {
                const F = S.textureCoord;
                for (let K = 0; K < F.length; K++) {
                  const J = F[K], T = 3 * (r + K);
                  for (let Y = 0; Y < J.length; Y++)
                    y[T + Y] = J[Y];
                }
              } else
                y.push(...S.textureCoord);
            if (u) {
              const F = Object.entries(u._attribute);
              for (let K = 0; K < F.length; K++) {
                const [J, T] = F[K];
                if (J !== "a_color" && J !== "a_sourceRect" && T !== "ignored")
                  if (t[J] = [], e) {
                    t[J] = e[J];
                    const Y = S.attributes[J], x = Y[0].length;
                    for (let H = 0; H < Y.length; H++) {
                      const Q = Y[H], w = x * (r + H);
                      for (let O = 0; O < Q.length; O++)
                        t[J][w + O] = Q[O];
                    }
                  } else
                    t[J].push(...S.attributes[J]);
              }
            }
            r += S.positions.length, p += S.cells.length;
          }
        }
        t.a_color = n, d && V && V.length > 0 && (t.a_sourceRect = V);
        const m = {
          positions: a,
          cells: G,
          attributes: t,
          uniforms: o,
          cellsCount: p * 3,
          program: u
        };
        return y && y.length && (m.textureCoord = y), b && I.length > 0 && (t.a_clipUV = I), m;
      }
    },
    /* 29 */
    /***/
    function(Z, l, i) {
      i.r(l);
      var s = i(1), c = i(30), W = i(26), h = i(31);
      i(1).glMatrix.setMatrixArrayType(Array);
      function e(t, m) {
        var R = Object.keys(t);
        if (Object.getOwnPropertySymbols) {
          var S = Object.getOwnPropertySymbols(t);
          m && (S = S.filter(function(C) {
            return Object.getOwnPropertyDescriptor(t, C).enumerable;
          })), R.push.apply(R, S);
        }
        return R;
      }
      function a(t) {
        for (var m = 1; m < arguments.length; m++) {
          var R = arguments[m] != null ? arguments[m] : {};
          m % 2 ? e(Object(R), !0).forEach(function(S) {
            G(t, S, R[S]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(R)) : e(Object(R)).forEach(function(S) {
            Object.defineProperty(t, S, Object.getOwnPropertyDescriptor(R, S));
          });
        }
        return t;
      }
      function G(t, m, R) {
        return m in t ? Object.defineProperty(t, m, { value: R, enumerable: !0, configurable: !0, writable: !0 }) : t[m] = R, t;
      }
      const y = Symbol("mesh"), n = Symbol("count"), V = Symbol("blend"), I = Symbol("filter"), r = Symbol("textures"), p = Symbol("textureOptions"), o = Symbol("cloudColor"), u = Symbol("cloudFilter"), d = Symbol("buffer");
      function b(t, m = null) {
        const R = new Float32Array(3 * t), S = new Float32Array(3 * t), C = new Float32Array(4 * t), F = new Float32Array(4 * t), K = new Float32Array(4 * t), J = new Float32Array(4 * t), T = new Float32Array(4 * t), Y = new Uint8Array(t), x = new Uint8Array(4 * t), H = new Uint8Array(4 * t);
        return m && (R.set(m.transform0, 0), S.set(m.transform1, 0), C.set(m.color0, 0), F.set(m.color1, 0), K.set(m.color2, 0), J.set(m.color3, 0), T.set(m.color4, 0), Y.set(m.frameIndex, 0), x.set(m.fillColor, 0), H.set(m.strokeColor, 0)), {
          bufferSize: t,
          transform0: R,
          transform1: S,
          color0: C,
          color1: F,
          color2: K,
          color3: J,
          color4: T,
          frameIndex: Y,
          fillColor: x,
          strokeColor: H
        };
      }
      l.default = class {
        constructor(t, m = 1, {
          buffer: R = 1e3
        } = {}) {
          R = Math.max(R, m), this[n] = m, this[y] = t, this[d] = b(R), this[r] = [], this[I] = [], this[o] = !1, this[u] = !1, this[V] = !1, this.initBuffer();
        }
        initBuffer(t = 0) {
          const m = this[n];
          for (let R = t; R < m; R++)
            this[d].transform0.set([1, 0, 0], R * 3), this[d].transform1.set([0, 1, 0], R * 3), this[d].frameIndex.set([-1], R), this[d].fillColor.set([0, 0, 0, 0], R * 4), this[d].strokeColor.set([0, 0, 0, 0], R * 4), this.setColorTransform(R, null);
        }
        get bufferSize() {
          return this[d].bufferSize;
        }
        get mesh() {
          return this[y];
        }
        set mesh(t) {
          this[y] = t, this[r] && this.setTextureFrames(this[r], this[p]);
        }
        get hasCloudColor() {
          return this[o];
        }
        get hasCloudFilter() {
          return this[u];
        }
        _getFilter(t) {
          return this[I][t] = this[I][t] || [], this[I][t];
        }
        getFilter(t) {
          return this._getFilter(t).join(" ");
        }
        get enableBlend() {
          return this[y].enableBlend || this[V];
        }
        canIgnore() {
          return this[y].canIgnore();
        }
        delete(t) {
          if (t >= this[n] || t < 0)
            throw new Error("Out of range.");
          const {
            transform0: m,
            transform1: R,
            color0: S,
            color1: C,
            color2: F,
            color3: K,
            color4: J,
            frameIndex: T,
            fillColor: Y,
            strokeColor: x
          } = this[d];
          m.set(m.subarray(3 * (t + 1)), 3 * t), R.set(R.subarray(3 * (t + 1)), 3 * t), S.set(S.subarray(4 * (t + 1)), 4 * t), C.set(C.subarray(4 * (t + 1)), 4 * t), F.set(F.subarray(4 * (t + 1)), 4 * t), K.set(K.subarray(4 * (t + 1)), 4 * t), J.set(J.subarray(4 * (t + 1)), 4 * t), T.set(T.subarray(t + 1), t), Y.set(Y.subarray(4 * (t + 1)), 4 * t), x.set(x.subarray(4 * (t + 1)), 4 * t);
          for (const H in this[I])
            H === t ? delete this[I][H] : H > t && (this[I][H - 1] = this[I][H], delete this[I][H]);
          this[n]--;
        }
        setColorTransform(t, m) {
          if (t >= this[n] || t < 0)
            throw new Error("Out of range.");
          t *= 4;
          const {
            color0: R,
            color1: S,
            color2: C,
            color3: F,
            color4: K
          } = this[d];
          return m != null ? (R.set([m[0], m[5], m[10], m[15]], t), S.set([m[1], m[6], m[11], m[16]], t), C.set([m[2], m[7], m[12], m[17]], t), F.set([m[3], m[8], m[13], m[18]], t), K.set([m[4], m[9], m[14], m[19]], t), this[V] = this[V] || m[18] < 1, this[u] = !0) : (R.set([1, 0, 0, 0], t), S.set([0, 1, 0, 0], t), C.set([0, 0, 1, 0], t), F.set([0, 0, 0, 1], t), K.set([0, 0, 0, 0], t)), this;
        }
        getColorTransform(t) {
          if (t >= this[n] || t < 0)
            throw new Error("Out of range.");
          t *= 4;
          const {
            color0: m,
            color1: R,
            color2: S,
            color3: C,
            color4: F
          } = this[d];
          return [m[t], R[t], S[t], C[t], F[t], m[t + 1], R[t + 1], S[t + 1], C[t + 1], F[t + 1], m[t + 2], R[t + 2], S[t + 2], C[t + 2], F[t + 2], m[t + 3], R[t + 3], S[t + 3], C[t + 3], F[t + 3]];
        }
        transformColor(t, m) {
          let R = this.getColorTransform(t);
          return R = Object(c.multiply)(R, m), this.setColorTransform(t, R), this;
        }
        setFillColor(t, m) {
          if (t >= this[n] || t < 0)
            throw new Error("Out of range.");
          typeof m == "string" && (m = Object(h.default)(m)), m[3] > 0 && (this[o] = !0), this[d].fillColor.set(m.map((R) => Math.round(255 * R)), 4 * t);
        }
        setStrokeColor(t, m) {
          if (t >= this[n] || t < 0)
            throw new Error("Out of range.");
          typeof m == "string" && (m = Object(h.default)(m)), m[3] > 0 && (this[o] = !0), this[d].strokeColor.set(m.map((R) => Math.round(255 * R)), 4 * t);
        }
        getCloudRGBA(t) {
          if (t >= this[n] || t < 0)
            throw new Error("Out of range.");
          t *= 4;
          const {
            fillColor: m,
            strokeColor: R
          } = this[d], S = [m[t], m[t + 1], m[t + 2], m[t + 3]], C = [R[t], R[t + 1], R[t + 2], R[t + 3]];
          return S[3] /= 255, C[3] /= 255, {
            fill: `rgba(${S.join()})`,
            stroke: `rgba(${C.join()})`
          };
        }
        grayscale(t, m) {
          this.transformColor(t, Object(c.grayscale)(m)), this._getFilter(t).push(`grayscale(${100 * m}%)`);
        }
        brightness(t, m) {
          this.transformColor(t, Object(c.brightness)(m)), this._getFilter(t).push(`brightness(${100 * m}%)`);
        }
        saturate(t, m) {
          this.transformColor(t, Object(c.saturate)(m)), this._getFilter(t).push(`saturate(${100 * m}%)`);
        }
        contrast(t, m) {
          this.transformColor(t, Object(c.contrast)(m)), this._getFilter(t).push(`contrast(${100 * m}%)`);
        }
        invert(t, m) {
          this.transformColor(t, Object(c.invert)(m)), this._getFilter(t).push(`invert(${100 * m}%)`);
        }
        sepia(t, m) {
          this.transformColor(t, Object(c.sepia)(m)), this._getFilter(t).push(`sepia(${100 * m}%)`);
        }
        opacity(t, m) {
          this.transformColor(t, Object(c.opacity)(m)), this._getFilter(t).push(`opacity(${100 * m}%)`);
        }
        hueRotate(t, m) {
          this.transformColor(t, Object(c.hueRotate)(m)), this._getFilter(t).push(`hue-rotate(${m}deg)`);
        }
        setTransform(t, m) {
          if (t >= this[n] || t < 0)
            throw new Error("Out of range.");
          t *= 3, m == null && (m = [1, 0, 0, 1, 0, 0]);
          const {
            transform0: R,
            transform1: S
          } = this[d];
          return R.set([m[0], m[2], m[4]], t), S.set([m[1], m[3], m[5]], t), this;
        }
        getTransform(t) {
          if (t >= this[n] || t < 0)
            throw new Error("Out of range.");
          t *= 3;
          const {
            transform0: m,
            transform1: R
          } = this[d];
          return [m[t], R[t], m[t + 1], R[t + 1], m[t + 2], R[t + 2]];
        }
        getTextureFrame(t) {
          return this[r][this[d].frameIndex[t]];
        }
        setTextureFrames(t = [], m = {}) {
          if (t.length > 12)
            throw new Error("Max frames exceed. Allow 12 frames.");
          t.length && this[y].setTexture(t[0], m), this[r] = t, this[p] = m;
        }
        setFrameIndex(t, m) {
          if (t >= this[n] || t < 0)
            throw new Error("Out of range.");
          const R = this[r].length;
          if (R <= 0)
            throw new Error("No frames");
          this[d].frameIndex[t] = m % R;
        }
        get amount() {
          return this[n];
        }
        set amount(t) {
          const m = this[n];
          t !== m && (t > this[d].bufferSize && (this[d] = b(Math.max(t, this[d].bufferSize + 1e3), this[d])), this[n] = t, t > m && this.initBuffer(m));
        }
        get meshData() {
          const {
            attributes: t,
            cells: m,
            positions: R,
            textureCoord: S,
            uniforms: C
          } = this[y].meshData, F = this[r], K = {
            attributes: a({}, t),
            cells: m,
            positions: R,
            textureCoord: S,
            uniforms: a({}, C),
            instanceCount: this[n],
            enableBlend: this.enableBlend
          };
          F.length && F.forEach((f, D) => {
            K.uniforms[`u_texFrame${D}`] = f;
          });
          const {
            transform0: J,
            transform1: T,
            color0: Y,
            color1: x,
            color2: H,
            color3: Q,
            color4: w,
            fillColor: O,
            strokeColor: q,
            frameIndex: k
          } = this[d];
          return this[y].uniforms.u_texSampler && (K.attributes.a_frameIndex = {
            data: k,
            divisor: 1
          }), K.attributes.a_transform0 = {
            data: J,
            divisor: 1
          }, K.attributes.a_transform1 = {
            data: T,
            divisor: 1
          }, K.attributes.a_colorCloud0 = {
            data: Y,
            divisor: 1
          }, K.attributes.a_colorCloud1 = {
            data: x,
            divisor: 1
          }, K.attributes.a_colorCloud2 = {
            data: H,
            divisor: 1
          }, K.attributes.a_colorCloud3 = {
            data: Q,
            divisor: 1
          }, K.attributes.a_colorCloud4 = {
            data: w,
            divisor: 1
          }, this.hasCloudColor && (K.attributes.a_fillCloudColor = {
            data: O,
            divisor: 1
          }, K.attributes.a_strokeCloudColor = {
            data: q,
            divisor: 1
          }), K;
        }
        setProgram(t) {
          this[y].setProgram(t);
        }
        get program() {
          return this[y].program;
        }
        transform(t, m) {
          const R = this.getTransform(t);
          return m = s.mat2d.multiply(Array.of(0, 0, 0, 0, 0, 0), R, m), this.setTransform(t, m), this;
        }
        translate(t, [m, R]) {
          let S = s.mat2d.create();
          return S = s.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), S, [m, R]), this.transform(t, S);
        }
        rotate(t, m, [R, S] = [0, 0]) {
          let C = s.mat2d.create();
          return C = s.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), C, [R, S]), C = s.mat2d.rotate(Array.of(0, 0, 0, 0, 0, 0), C, m), C = s.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), C, [-R, -S]), this.transform(t, C);
        }
        scale(t, [m, R = m], [S, C] = [0, 0]) {
          let F = s.mat2d.create();
          return F = s.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), F, [S, C]), F = s.mat2d.scale(Array.of(0, 0, 0, 0, 0, 0), F, [m, R]), F = s.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), F, [-S, -C]), this.transform(t, F);
        }
        skew(t, [m, R = m], [S, C] = [0, 0]) {
          let F = s.mat2d.create();
          return F = s.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), F, [S, C]), F = s.mat2d.multiply(Array.of(0, 0, 0, 0, 0, 0), F, s.mat2d.fromValues(1, Math.tan(R), Math.tan(m), 1, 0, 0)), F = s.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), F, [-S, -C]), this.transform(t, F);
        }
        isPointCollision(t, [m, R], S = "both") {
          const C = this.getTransform(t), F = Object(W.transformPoint)([m, R], s.mat2d.invert(Array.of(0, 0, 0, 0, 0, 0), C));
          return this[y].isPointCollision(...F, S);
        }
        isPointInFill(t, [m, R]) {
          return this.isPointCollision(t, [m, R], "fill");
        }
        isPointInStroke(t, [m, R]) {
          return this.isPointCollision(t, [m, R], "stroke");
        }
      };
    },
    /* 30 */
    /***/
    function(Z, l, i) {
      i.r(l), i.d(l, "multiply", function() {
        return c;
      }), i.d(l, "grayscale", function() {
        return W;
      }), i.d(l, "brightness", function() {
        return h;
      }), i.d(l, "saturate", function() {
        return e;
      }), i.d(l, "contrast", function() {
        return a;
      }), i.d(l, "invert", function() {
        return G;
      }), i.d(l, "sepia", function() {
        return y;
      }), i.d(l, "opacity", function() {
        return n;
      }), i.d(l, "hueRotate", function() {
        return V;
      });
      var s = i(26);
      i(1).glMatrix.setMatrixArrayType(Array);
      function c(I, r) {
        const p = [], o = I[0], u = I[1], d = I[2], b = I[3], t = I[4], m = I[5], R = I[6], S = I[7], C = I[8], F = I[9], K = I[10], J = I[11], T = I[12], Y = I[13], x = I[14], H = I[15], Q = I[16], w = I[17], O = I[18], q = I[19];
        let k = r[0], f = r[1], D = r[2], ii = r[3], _ = r[4];
        return p[0] = k * o + f * m + D * K + ii * H, p[1] = k * u + f * R + D * J + ii * Q, p[2] = k * d + f * S + D * T + ii * w, p[3] = k * b + f * C + D * Y + ii * O, p[4] = k * t + f * F + D * x + ii * q + _, k = r[5], f = r[6], D = r[7], ii = r[8], _ = r[9], p[5] = k * o + f * m + D * K + ii * H, p[6] = k * u + f * R + D * J + ii * Q, p[7] = k * d + f * S + D * T + ii * w, p[8] = k * b + f * C + D * Y + ii * O, p[9] = k * t + f * F + D * x + ii * q + _, k = r[10], f = r[11], D = r[12], ii = r[13], _ = r[14], p[10] = k * o + f * m + D * K + ii * H, p[11] = k * u + f * R + D * J + ii * Q, p[12] = k * d + f * S + D * T + ii * w, p[13] = k * b + f * C + D * Y + ii * O, p[14] = k * t + f * F + D * x + ii * q + _, k = r[15], f = r[16], D = r[17], ii = r[18], _ = r[19], p[15] = k * o + f * m + D * K + ii * H, p[16] = k * u + f * R + D * J + ii * Q, p[17] = k * d + f * S + D * T + ii * w, p[18] = k * b + f * C + D * Y + ii * O, p[19] = k * t + f * F + D * x + ii * q + _, p;
      }
      function W(I) {
        I = Object(s.clamp)(0, 1, I);
        const r = 0.2126 * I, p = 0.7152 * I, o = 0.0722 * I;
        return [r + 1 - I, p, o, 0, 0, r, p + 1 - I, o, 0, 0, r, p, o + 1 - I, 0, 0, 0, 0, 0, 1, 0];
      }
      function h(I) {
        return [I, 0, 0, 0, 0, 0, I, 0, 0, 0, 0, 0, I, 0, 0, 0, 0, 0, 1, 0];
      }
      function e(I) {
        const r = 0.2126 * (1 - I), p = 0.7152 * (1 - I), o = 0.0722 * (1 - I);
        return [r + I, p, o, 0, 0, r, p + I, o, 0, 0, r, p, o + I, 0, 0, 0, 0, 0, 1, 0];
      }
      function a(I) {
        const r = 0.5 * (1 - I);
        return [I, 0, 0, 0, r, 0, I, 0, 0, r, 0, 0, I, 0, r, 0, 0, 0, 1, 0];
      }
      function G(I) {
        const r = 1 - 2 * I;
        return [r, 0, 0, 0, I, 0, r, 0, 0, I, 0, 0, r, 0, I, 0, 0, 0, 1, 0];
      }
      function y(I) {
        return [1 - 0.607 * I, 0.769 * I, 0.189 * I, 0, 0, 0.349 * I, 1 - 0.314 * I, 0.168 * I, 0, 0, 0.272 * I, 0.534 * I, 1 - 0.869 * I, 0, 0, 0, 0, 0, 1, 0];
      }
      function n(I) {
        return [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, I, 0];
      }
      function V(I) {
        const r = I / 180 * Math.PI, p = Math.cos(r), o = Math.sin(r), u = 0.2126, d = 0.7152, b = 0.0722;
        return [u + p * (1 - u) + o * -u, d + p * -d + o * -d, b + p * -b + o * (1 - b), 0, 0, u + p * -u + o * 0.143, d + p * (1 - d) + o * 0.14, b + p * -b + o * -0.283, 0, 0, u + p * -u + o * -(1 - u), d + p * -d + o * d, b + p * (1 - b) + o * b, 0, 0, 0, 0, 0, 1, 0];
      }
    },
    /* 31 */
    /***/
    function(Z, l, i) {
      i.r(l), i.d(l, "default", function() {
        return W;
      });
      var s = i(32), c = /* @__PURE__ */ i.n(s);
      i(1).glMatrix.setMatrixArrayType(Array);
      function W(h) {
        const e = c()(h);
        if (!e || !e.length)
          throw new TypeError("Invalid color value.");
        return [e[0] / 255, e[1] / 255, e[2] / 255, e[3]];
      }
    },
    /* 32 */
    /***/
    function(Z, l, i) {
      var s = i(33), c = i(37), W = i(39);
      Z.exports = function(e) {
        var a, G = s(e);
        return G.space ? (a = Array(3), a[0] = W(G.values[0], 0, 255), a[1] = W(G.values[1], 0, 255), a[2] = W(G.values[2], 0, 255), G.space[0] === "h" && (a = c.rgb(a)), a.push(W(G.alpha, 0, 1)), a) : [];
      };
    },
    /* 33 */
    /***/
    function(Z, l, i) {
      (function(s) {
        var c = i(34), W = i(35), h = i(36);
        Z.exports = a;
        var e = {
          red: 0,
          orange: 60,
          yellow: 120,
          green: 180,
          blue: 240,
          purple: 300
        };
        function a(G) {
          var y, n = [], V = 1, I;
          if (typeof G == "string")
            if (c[G])
              n = c[G].slice(), I = "rgb";
            else if (G === "transparent")
              V = 0, I = "rgb", n = [0, 0, 0];
            else if (/^#[A-Fa-f0-9]+$/.test(G)) {
              var r = G.slice(1), p = r.length, o = p <= 4;
              V = 1, o ? (n = [
                parseInt(r[0] + r[0], 16),
                parseInt(r[1] + r[1], 16),
                parseInt(r[2] + r[2], 16)
              ], p === 4 && (V = parseInt(r[3] + r[3], 16) / 255)) : (n = [
                parseInt(r[0] + r[1], 16),
                parseInt(r[2] + r[3], 16),
                parseInt(r[4] + r[5], 16)
              ], p === 8 && (V = parseInt(r[6] + r[7], 16) / 255)), n[0] || (n[0] = 0), n[1] || (n[1] = 0), n[2] || (n[2] = 0), I = "rgb";
            } else if (y = /^((?:rgb|hs[lvb]|hwb|cmyk?|xy[zy]|gray|lab|lchu?v?|[ly]uv|lms)a?)\s*\(([^\)]*)\)/.exec(G)) {
              var u = y[1], d = u === "rgb", r = u.replace(/a$/, "");
              I = r;
              var p = r === "cmyk" ? 4 : r === "gray" ? 1 : 3;
              n = y[2].trim().split(/\s*,\s*/).map(function(R, S) {
                if (/%$/.test(R))
                  return S === p ? parseFloat(R) / 100 : r === "rgb" ? parseFloat(R) * 255 / 100 : parseFloat(R);
                if (r[S] === "h") {
                  if (/deg$/.test(R))
                    return parseFloat(R);
                  if (e[R] !== void 0)
                    return e[R];
                }
                return parseFloat(R);
              }), u === r && n.push(1), V = d || n[p] === void 0 ? 1 : n[p], n = n.slice(0, p);
            } else
              G.length > 10 && /[0-9](?:\s|\/)/.test(G) && (n = G.match(/([0-9]+)/g).map(function(t) {
                return parseFloat(t);
              }), I = G.match(/([a-z])/ig).join("").toLowerCase());
          else if (!isNaN(G))
            I = "rgb", n = [G >>> 16, (G & 65280) >>> 8, G & 255];
          else if (W(G)) {
            var b = h(G.r, G.red, G.R, null);
            b !== null ? (I = "rgb", n = [
              b,
              h(G.g, G.green, G.G),
              h(G.b, G.blue, G.B)
            ]) : (I = "hsl", n = [
              h(G.h, G.hue, G.H),
              h(G.s, G.saturation, G.S),
              h(G.l, G.lightness, G.L, G.b, G.brightness)
            ]), V = h(G.a, G.alpha, G.opacity, 1), G.opacity != null && (V /= 100);
          } else
            (Array.isArray(G) || s.ArrayBuffer && ArrayBuffer.isView && ArrayBuffer.isView(G)) && (n = [G[0], G[1], G[2]], I = "rgb", V = G.length === 4 ? G[3] : 1);
          return {
            space: I,
            values: n,
            alpha: V
          };
        }
      }).call(this, i(22));
    },
    /* 34 */
    /***/
    function(Z, l, i) {
      Z.exports = {
        aliceblue: [240, 248, 255],
        antiquewhite: [250, 235, 215],
        aqua: [0, 255, 255],
        aquamarine: [127, 255, 212],
        azure: [240, 255, 255],
        beige: [245, 245, 220],
        bisque: [255, 228, 196],
        black: [0, 0, 0],
        blanchedalmond: [255, 235, 205],
        blue: [0, 0, 255],
        blueviolet: [138, 43, 226],
        brown: [165, 42, 42],
        burlywood: [222, 184, 135],
        cadetblue: [95, 158, 160],
        chartreuse: [127, 255, 0],
        chocolate: [210, 105, 30],
        coral: [255, 127, 80],
        cornflowerblue: [100, 149, 237],
        cornsilk: [255, 248, 220],
        crimson: [220, 20, 60],
        cyan: [0, 255, 255],
        darkblue: [0, 0, 139],
        darkcyan: [0, 139, 139],
        darkgoldenrod: [184, 134, 11],
        darkgray: [169, 169, 169],
        darkgreen: [0, 100, 0],
        darkgrey: [169, 169, 169],
        darkkhaki: [189, 183, 107],
        darkmagenta: [139, 0, 139],
        darkolivegreen: [85, 107, 47],
        darkorange: [255, 140, 0],
        darkorchid: [153, 50, 204],
        darkred: [139, 0, 0],
        darksalmon: [233, 150, 122],
        darkseagreen: [143, 188, 143],
        darkslateblue: [72, 61, 139],
        darkslategray: [47, 79, 79],
        darkslategrey: [47, 79, 79],
        darkturquoise: [0, 206, 209],
        darkviolet: [148, 0, 211],
        deeppink: [255, 20, 147],
        deepskyblue: [0, 191, 255],
        dimgray: [105, 105, 105],
        dimgrey: [105, 105, 105],
        dodgerblue: [30, 144, 255],
        firebrick: [178, 34, 34],
        floralwhite: [255, 250, 240],
        forestgreen: [34, 139, 34],
        fuchsia: [255, 0, 255],
        gainsboro: [220, 220, 220],
        ghostwhite: [248, 248, 255],
        gold: [255, 215, 0],
        goldenrod: [218, 165, 32],
        gray: [128, 128, 128],
        green: [0, 128, 0],
        greenyellow: [173, 255, 47],
        grey: [128, 128, 128],
        honeydew: [240, 255, 240],
        hotpink: [255, 105, 180],
        indianred: [205, 92, 92],
        indigo: [75, 0, 130],
        ivory: [255, 255, 240],
        khaki: [240, 230, 140],
        lavender: [230, 230, 250],
        lavenderblush: [255, 240, 245],
        lawngreen: [124, 252, 0],
        lemonchiffon: [255, 250, 205],
        lightblue: [173, 216, 230],
        lightcoral: [240, 128, 128],
        lightcyan: [224, 255, 255],
        lightgoldenrodyellow: [250, 250, 210],
        lightgray: [211, 211, 211],
        lightgreen: [144, 238, 144],
        lightgrey: [211, 211, 211],
        lightpink: [255, 182, 193],
        lightsalmon: [255, 160, 122],
        lightseagreen: [32, 178, 170],
        lightskyblue: [135, 206, 250],
        lightslategray: [119, 136, 153],
        lightslategrey: [119, 136, 153],
        lightsteelblue: [176, 196, 222],
        lightyellow: [255, 255, 224],
        lime: [0, 255, 0],
        limegreen: [50, 205, 50],
        linen: [250, 240, 230],
        magenta: [255, 0, 255],
        maroon: [128, 0, 0],
        mediumaquamarine: [102, 205, 170],
        mediumblue: [0, 0, 205],
        mediumorchid: [186, 85, 211],
        mediumpurple: [147, 112, 219],
        mediumseagreen: [60, 179, 113],
        mediumslateblue: [123, 104, 238],
        mediumspringgreen: [0, 250, 154],
        mediumturquoise: [72, 209, 204],
        mediumvioletred: [199, 21, 133],
        midnightblue: [25, 25, 112],
        mintcream: [245, 255, 250],
        mistyrose: [255, 228, 225],
        moccasin: [255, 228, 181],
        navajowhite: [255, 222, 173],
        navy: [0, 0, 128],
        oldlace: [253, 245, 230],
        olive: [128, 128, 0],
        olivedrab: [107, 142, 35],
        orange: [255, 165, 0],
        orangered: [255, 69, 0],
        orchid: [218, 112, 214],
        palegoldenrod: [238, 232, 170],
        palegreen: [152, 251, 152],
        paleturquoise: [175, 238, 238],
        palevioletred: [219, 112, 147],
        papayawhip: [255, 239, 213],
        peachpuff: [255, 218, 185],
        peru: [205, 133, 63],
        pink: [255, 192, 203],
        plum: [221, 160, 221],
        powderblue: [176, 224, 230],
        purple: [128, 0, 128],
        rebeccapurple: [102, 51, 153],
        red: [255, 0, 0],
        rosybrown: [188, 143, 143],
        royalblue: [65, 105, 225],
        saddlebrown: [139, 69, 19],
        salmon: [250, 128, 114],
        sandybrown: [244, 164, 96],
        seagreen: [46, 139, 87],
        seashell: [255, 245, 238],
        sienna: [160, 82, 45],
        silver: [192, 192, 192],
        skyblue: [135, 206, 235],
        slateblue: [106, 90, 205],
        slategray: [112, 128, 144],
        slategrey: [112, 128, 144],
        snow: [255, 250, 250],
        springgreen: [0, 255, 127],
        steelblue: [70, 130, 180],
        tan: [210, 180, 140],
        teal: [0, 128, 128],
        thistle: [216, 191, 216],
        tomato: [255, 99, 71],
        turquoise: [64, 224, 208],
        violet: [238, 130, 238],
        wheat: [245, 222, 179],
        white: [255, 255, 255],
        whitesmoke: [245, 245, 245],
        yellow: [255, 255, 0],
        yellowgreen: [154, 205, 50]
      };
    },
    /* 35 */
    /***/
    function(Z, l, i) {
      var s = Object.prototype.toString;
      Z.exports = function(c) {
        var W;
        return s.call(c) === "[object Object]" && (W = Object.getPrototypeOf(c), W === null || W === Object.getPrototypeOf({}));
      };
    },
    /* 36 */
    /***/
    function(Z, l) {
      Z.exports = function() {
        for (var i = 0; i < arguments.length; i++)
          if (arguments[i] !== void 0)
            return arguments[i];
      };
    },
    /* 37 */
    /***/
    function(Z, l, i) {
      var s = i(38);
      Z.exports = {
        name: "hsl",
        min: [0, 0, 0],
        max: [360, 100, 100],
        channel: ["hue", "saturation", "lightness"],
        alias: ["HSL"],
        rgb: function(c) {
          var W = c[0] / 360, h = c[1] / 100, e = c[2] / 100, a, G, y, n, V;
          if (h === 0)
            return V = e * 255, [V, V, V];
          e < 0.5 ? G = e * (1 + h) : G = e + h - e * h, a = 2 * e - G, n = [0, 0, 0];
          for (var I = 0; I < 3; I++)
            y = W + 1 / 3 * -(I - 1), y < 0 ? y++ : y > 1 && y--, 6 * y < 1 ? V = a + (G - a) * 6 * y : 2 * y < 1 ? V = G : 3 * y < 2 ? V = a + (G - a) * (2 / 3 - y) * 6 : V = a, n[I] = V * 255;
          return n;
        }
      }, s.hsl = function(c) {
        var W = c[0] / 255, h = c[1] / 255, e = c[2] / 255, a = Math.min(W, h, e), G = Math.max(W, h, e), y = G - a, n, V, I;
        return G === a ? n = 0 : W === G ? n = (h - e) / y : h === G ? n = 2 + (e - W) / y : e === G && (n = 4 + (W - h) / y), n = Math.min(n * 60, 360), n < 0 && (n += 360), I = (a + G) / 2, G === a ? V = 0 : I <= 0.5 ? V = y / (G + a) : V = y / (2 - G - a), [n, V * 100, I * 100];
      };
    },
    /* 38 */
    /***/
    function(Z, l, i) {
      Z.exports = {
        name: "rgb",
        min: [0, 0, 0],
        max: [255, 255, 255],
        channel: ["red", "green", "blue"],
        alias: ["RGB"]
      };
    },
    /* 39 */
    /***/
    function(Z, l) {
      Z.exports = i;
      function i(s, c, W) {
        return c < W ? s < c ? c : s > W ? W : s : s < W ? W : s > c ? c : s;
      }
    },
    /* 40 */
    /***/
    function(Z, l, i) {
      i.r(l), i.d(l, "default", function() {
        return b;
      });
      var s = i(41), c = /* @__PURE__ */ i.n(s), W = i(42), h = /* @__PURE__ */ i.n(W), e = i(43), a = /* @__PURE__ */ i.n(e), G = i(44), y = i(46), n = /* @__PURE__ */ i.n(y), V = i(53), I = i(55);
      i(1).glMatrix.setMatrixArrayType(Array);
      const r = Symbol("contours"), p = Symbol("path"), o = Symbol("simplify"), u = Symbol("scale"), d = 2 * Math.PI;
      class b {
        constructor(m = {}) {
          typeof m == "string" && (m = {
            path: m
          }), m.path ? this[p] = c()(m.path) : this[p] = [], this[r] = null, this[o] = m.simplify != null ? m.simplify : 0, this[u] = m.scale != null ? m.scale : 2;
        }
        get contours() {
          let m = null;
          if (!this[r] && this[p]) {
            const R = Object(G.default)(a()(this[p]));
            this[r] = n()(R, this[u], this[o]), this[r].path = R, this[r].simplify = this[o], this[r].scale = this[u];
          }
          return this[r] && (m = this[r].map((R) => [...R]), m.path = this[r].path, m.simplify = this[r].simplify, m.scale = this[r].scale), m;
        }
        get path() {
          return this[p];
        }
        get simplify() {
          return this[o];
        }
        get boundingBox() {
          const m = this.contours;
          if (m && m.length) {
            const R = m.reduce((S, C) => [...S, ...C]);
            return h()(R);
          }
          return [[0, 0], [0, 0]];
        }
        get boundingCenter() {
          const m = this.boundingBox;
          return m ? [0.5 * (m[0][0] + m[1][0]), 0.5 * (m[0][1] + m[1][1])] : [0, 0];
        }
        normalize(m = 0, R = 0) {
          const S = Object(G.default)(a()(this[p])).map(([C, ...F]) => {
            const K = [C];
            for (let J = 0; J < F.length; J += 2) {
              const T = F[J] - m, Y = F[J + 1] - R;
              K.push(T, Y);
            }
            return K;
          });
          return this.beginPath(), this[p].push(...S), this;
        }
        getPointAtLength(m) {
          return this.contours ? Object(V.getPointAtLength)(this[r], m) : null;
        }
        getTotalLength() {
          return this.contours ? Object(V.getTotalLength)(this[r]) : 0;
        }
        addPath(m) {
          this[r] = null, typeof m == "string" && (m = c()(m)), this[p].push(...m);
        }
        beginPath() {
          this[p] = [], this[r] = null;
        }
        clear() {
          this.beginPath();
        }
        ellipse(m, R, S, C, F, K, J, T = 0) {
          if (K += F, J += F, S <= 0 || C <= 0 || J === K)
            return;
          J < K && (J = K + d + (J - K) % d), J - K > d && (J = K + d);
          const Y = J - K;
          Y >= d && (J -= 1e-3);
          let x = this[p].length > 0 && Y < d ? "L" : "M";
          const H = Object(I.getPoint)(m, R, S, C, K), Q = Object(I.getPoint)(m, R, S, C, J), w = +!T;
          let O = Y > Math.PI ? 1 : 0;
          T && (O = 1 - O), x += H.join(" "), x += `A${S} ${C} 0 ${O} ${w} ${Q.join(" ")}`, Y >= d && (x += "Z"), this.addPath(x);
        }
        arc(m, R, S, C, F, K = 0) {
          return this.ellipse(m, R, S, S, 0, C, F, K);
        }
        arcTo(m, R, S, C, F, K, J) {
          this[r] = null, this[p].push(["A", m, R, S, C, F, K, J]);
        }
        moveTo(m, R) {
          this[r] = null, this[p].push(["M", m, R]);
        }
        lineTo(m, R) {
          this[r] = null, this[p].push(["L", m, R]);
        }
        bezierCurveTo(m, R, S, C, F, K) {
          this[r] = null, this[p].push(["C", m, R, S, C, F, K]);
        }
        quadraticCurveTo(m, R, S, C) {
          this[r] = null, this[p].push(["Q", m, R, S, C]);
        }
        rect(m, R, S, C) {
          const F = `M${m} ${R}L${m + S} ${R}L${m + S} ${R + C}L${m} ${R + C}Z`;
          this.addPath(F);
        }
        closePath() {
          this[r] = null;
          let m = [];
          const R = this[p].length;
          R > 0 && (m = this[p][R - 1]), m[0] !== "Z" && m[0] !== "z" && this[p].push(["Z"]);
        }
      }
    },
    /* 41 */
    /***/
    function(Z, l) {
      Z.exports = c;
      var i = { a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0 }, s = /([astvzqmhlc])([^astvzqmhlc]*)/ig;
      function c(e) {
        var a = [];
        return e.replace(s, function(G, y, n) {
          var V = y.toLowerCase();
          for (n = h(n), V == "m" && n.length > 2 && (a.push([y].concat(n.splice(0, 2))), V = "l", y = y == "m" ? "l" : "L"); ; ) {
            if (n.length == i[V])
              return n.unshift(y), a.push(n);
            if (n.length < i[V])
              throw new Error("malformed path data");
            a.push([y].concat(n.splice(0, i[V])));
          }
        }), a;
      }
      var W = /-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/ig;
      function h(e) {
        var a = e.match(W);
        return a ? a.map(Number) : [];
      }
    },
    /* 42 */
    /***/
    function(Z, l, i) {
      Z.exports = s;
      function s(c) {
        var W = c.length;
        if (W === 0)
          return [[], []];
        for (var h = c[0].length, e = c[0].slice(), a = c[0].slice(), G = 1; G < W; ++G)
          for (var y = c[G], n = 0; n < h; ++n) {
            var V = y[n];
            e[n] = Math.min(e[n], V), a[n] = Math.max(a[n], V);
          }
        return [e, a];
      }
    },
    /* 43 */
    /***/
    function(Z, l) {
      Z.exports = i;
      function i(s) {
        var c = 0, W = 0, h = 0, e = 0;
        return s.map(function(a) {
          a = a.slice();
          var G = a[0], y = G.toUpperCase();
          if (G != y)
            switch (a[0] = y, G) {
              case "a":
                a[6] += h, a[7] += e;
                break;
              case "v":
                a[1] += e;
                break;
              case "h":
                a[1] += h;
                break;
              default:
                for (var n = 1; n < a.length; )
                  a[n++] += h, a[n++] += e;
            }
          switch (y) {
            case "Z":
              h = c, e = W;
              break;
            case "H":
              h = a[1];
              break;
            case "V":
              e = a[1];
              break;
            case "M":
              h = c = a[1], e = W = a[2];
              break;
            default:
              h = a[a.length - 2], e = a[a.length - 1];
          }
          return a;
        });
      }
    },
    /* 44 */
    /***/
    function(Z, l, i) {
      i.r(l), i.d(l, "default", function() {
        return c;
      });
      var s = i(45);
      i(1).glMatrix.setMatrixArrayType(Array);
      function c(e) {
        for (var a, G = [], y = 0, n = 0, V = 0, I = 0, r = null, p = null, o = 0, u = 0, d = 0, b = e.length; d < b; d++) {
          var t = e[d], m = t[0];
          switch (m) {
            case "M":
              V = t[1], I = t[2];
              break;
            case "A":
              var R = Object(s.default)(o, u, t[6], t[7], t[4], t[5], t[1], t[2], t[3]);
              if (!R.length)
                continue;
              R = R.map((J) => {
                const [T, Y, x, H, Q, w, O, q] = J;
                return {
                  x1: x,
                  y1: H,
                  x2: Q,
                  y2: w,
                  x: O,
                  y: q
                };
              });
              for (var S = 0, C; S < R.length; S++)
                C = R[S], t = ["C", C.x1, C.y1, C.x2, C.y2, C.x, C.y], S < R.length - 1 && G.push(t);
              break;
            case "S":
              var F = o, K = u;
              (a == "C" || a == "S") && (F += F - y, K += K - n), t = ["C", F, K, t[1], t[2], t[3], t[4]];
              break;
            case "T":
              a == "Q" || a == "T" ? (r = o * 2 - r, p = u * 2 - p) : (r = o, p = u), t = h(o, u, r, p, t[1], t[2]);
              break;
            case "Q":
              r = t[1], p = t[2], t = h(o, u, t[1], t[2], t[3], t[4]);
              break;
            case "L":
              t = W(o, u, t[1], t[2]);
              break;
            case "H":
              t = W(o, u, t[1], u);
              break;
            case "V":
              t = W(o, u, o, t[1]);
              break;
            case "Z":
              t = W(o, u, V, I);
              break;
          }
          a = m, o = t[t.length - 2], u = t[t.length - 1], t.length > 4 ? (y = t[t.length - 4], n = t[t.length - 3]) : (y = o, n = u), G.push(t);
        }
        return G;
      }
      function W(e, a, G, y) {
        return ["C", e, a, G, y, G, y];
      }
      function h(e, a, G, y, n, V) {
        return ["C", e / 3 + 2 / 3 * G, a / 3 + 2 / 3 * y, n / 3 + 2 / 3 * G, V / 3 + 2 / 3 * y, n, V];
      }
    },
    /* 45 */
    /***/
    function(Z, l, i) {
      i.r(l), i.d(l, "default", function() {
        return e;
      }), i(1).glMatrix.setMatrixArrayType(Array);
      const s = Math.PI * 2;
      function c(a, G, y, n) {
        const V = a * n - G * y < 0 ? -1 : 1;
        let I = a * y + G * n;
        return I > 1 && (I = 1), I < -1 && (I = -1), V * Math.acos(I);
      }
      function W(a, G, y, n, V, I, r, p, o, u) {
        const d = u * (a - y) / 2 + o * (G - n) / 2, b = -o * (a - y) / 2 + u * (G - n) / 2, t = r * r, m = p * p, R = d * d, S = b * b;
        let C = t * m - t * S - m * R;
        C < 0 && (C = 0), C /= t * S + m * R, C = Math.sqrt(C) * (V === I ? -1 : 1);
        const F = C * r / p * b, K = C * -p / r * d, J = u * F - o * K + (a + y) / 2, T = o * F + u * K + (G + n) / 2, Y = (d - F) / r, x = (b - K) / p, H = (-d - F) / r, Q = (-b - K) / p, w = c(1, 0, Y, x);
        let O = c(Y, x, H, Q);
        return I === 0 && O > 0 && (O -= s), I === 1 && O < 0 && (O += s), [J, T, w, O];
      }
      function h(a, G) {
        const y = 1.3333333333333333 * Math.tan(G / 4), n = Math.cos(a), V = Math.sin(a), I = Math.cos(a + G), r = Math.sin(a + G);
        return [n, V, n - V * y, V + n * y, I + r * y, r - I * y, I, r];
      }
      function e(a, G, y, n, V, I, r, p, o) {
        const u = Math.sin(o * s / 360), d = Math.cos(o * s / 360), b = d * (a - y) / 2 + u * (G - n) / 2, t = -u * (a - y) / 2 + d * (G - n) / 2;
        if (b === 0 && t === 0)
          return [];
        if (r === 0 || p === 0)
          return [];
        r = Math.abs(r), p = Math.abs(p);
        const m = b * b / (r * r) + t * t / (p * p);
        m > 1 && (r *= Math.sqrt(m), p *= Math.sqrt(m));
        const R = W(a, G, y, n, V, I, r, p, u, d), S = [];
        let C = R[2], F = R[3];
        const K = Math.max(Math.ceil(Math.abs(F) / (s / 4)), 1);
        F /= K;
        for (let J = 0; J < K; J++)
          S.push(h(C, F)), C += F;
        return S.map((J) => {
          for (let T = 0; T < J.length; T += 2) {
            let Y = J[T + 0], x = J[T + 1];
            Y *= r, x *= p;
            const H = d * Y - u * x, Q = u * Y + d * x;
            J[T + 0] = H + R[0], J[T + 1] = Q + R[1];
          }
          return J;
        });
      }
    },
    /* 46 */
    /***/
    function(Z, l, i) {
      i(1).glMatrix.setMatrixArrayType(Array);
      var s = i(47), {
        copy: c
      } = i(49), W = i(50);
      function h(n, V, I) {
        return n[0] = V, n[1] = I, n;
      }
      var e = [0, 0], a = [0, 0], G = [0, 0];
      function y(n, V, I, r) {
        s(I, h(e, r[1], r[2]), h(a, r[3], r[4]), h(G, r[5], r[6]), V, n);
      }
      Z.exports = function(V, I, r) {
        var p = [], o = [], u = [0, 0];
        return V.forEach(function(d, b, t) {
          if (d[0] === "M")
            c(u, d.slice(1)), o.length > 0 && (p.push(o), o = []);
          else if (d[0] === "C")
            y(o, I, u, d), h(u, d[5], d[6]);
          else
            throw new Error("illegal type in SVG: " + d[0]);
        }), o.length > 0 && p.push(o), p.map(function(d) {
          return W(d, r || 0);
        });
      };
    },
    /* 47 */
    /***/
    function(Z, l, i) {
      Z.exports = i(48)();
    },
    /* 48 */
    /***/
    function(Z, l) {
      function i(c) {
        return [c[0], c[1]];
      }
      function s(c, W) {
        return [c, W];
      }
      Z.exports = function(W) {
        W = W || {};
        var h = typeof W.recursion == "number" ? W.recursion : 8, e = typeof W.epsilon == "number" ? W.epsilon : 11920929e-14, a = typeof W.pathEpsilon == "number" ? W.pathEpsilon : 1, G = typeof W.angleEpsilon == "number" ? W.angleEpsilon : 0.01, y = W.angleTolerance || 0, n = W.cuspLimit || 0;
        return function(p, o, u, d, b, t) {
          t || (t = []), b = typeof b == "number" ? b : 1;
          var m = a / b;
          return m *= m, V(p, o, u, d, t, m), t;
        };
        function V(r, p, o, u, d, b) {
          d.push(i(r));
          var t = r[0], m = r[1], R = p[0], S = p[1], C = o[0], F = o[1], K = u[0], J = u[1];
          I(t, m, R, S, C, F, K, J, d, b, 0), d.push(i(u));
        }
        function I(r, p, o, u, d, b, t, m, R, S, C) {
          if (!(C > h)) {
            var F = Math.PI, K = (r + o) / 2, J = (p + u) / 2, T = (o + d) / 2, Y = (u + b) / 2, x = (d + t) / 2, H = (b + m) / 2, Q = (K + T) / 2, w = (J + Y) / 2, O = (T + x) / 2, q = (Y + H) / 2, k = (Q + O) / 2, f = (w + q) / 2;
            if (C > 0) {
              var D = t - r, ii = m - p, _ = Math.abs((o - t) * ii - (u - m) * D), bi = Math.abs((d - t) * ii - (b - m) * D), $, oi;
              if (_ > e && bi > e) {
                if ((_ + bi) * (_ + bi) <= S * (D * D + ii * ii)) {
                  if (y < G) {
                    R.push(s(k, f));
                    return;
                  }
                  var ni = Math.atan2(b - u, d - o);
                  if ($ = Math.abs(ni - Math.atan2(u - p, o - r)), oi = Math.abs(Math.atan2(m - b, t - d) - ni), $ >= F && ($ = 2 * F - $), oi >= F && (oi = 2 * F - oi), $ + oi < y) {
                    R.push(s(k, f));
                    return;
                  }
                  if (n !== 0) {
                    if ($ > n) {
                      R.push(s(o, u));
                      return;
                    }
                    if (oi > n) {
                      R.push(s(d, b));
                      return;
                    }
                  }
                }
              } else if (_ > e) {
                if (_ * _ <= S * (D * D + ii * ii)) {
                  if (y < G) {
                    R.push(s(k, f));
                    return;
                  }
                  if ($ = Math.abs(Math.atan2(b - u, d - o) - Math.atan2(u - p, o - r)), $ >= F && ($ = 2 * F - $), $ < y) {
                    R.push(s(o, u)), R.push(s(d, b));
                    return;
                  }
                  if (n !== 0 && $ > n) {
                    R.push(s(o, u));
                    return;
                  }
                }
              } else if (bi > e) {
                if (bi * bi <= S * (D * D + ii * ii)) {
                  if (y < G) {
                    R.push(s(k, f));
                    return;
                  }
                  if ($ = Math.abs(Math.atan2(m - b, t - d) - Math.atan2(b - u, d - o)), $ >= F && ($ = 2 * F - $), $ < y) {
                    R.push(s(o, u)), R.push(s(d, b));
                    return;
                  }
                  if (n !== 0 && $ > n) {
                    R.push(s(d, b));
                    return;
                  }
                }
              } else if (D = k - (r + t) / 2, ii = f - (p + m) / 2, D * D + ii * ii <= S) {
                R.push(s(k, f));
                return;
              }
            }
            I(r, p, K, J, Q, w, k, f, R, S, C + 1), I(k, f, O, q, x, H, t, m, R, S, C + 1);
          }
        }
      };
    },
    /* 49 */
    /***/
    function(Z, l, i) {
      i.r(l), i.d(l, "create", function() {
        return W;
      }), i.d(l, "clone", function() {
        return c;
      }), i.d(l, "copy", function() {
        return h;
      }), i.d(l, "scaleAndAdd", function() {
        return e;
      }), i.d(l, "dot", function() {
        return a;
      }), i.d(l, "rotate", function() {
        return G;
      }), i.d(l, "cross", function() {
        return y;
      }), i.d(l, "sub", function() {
        return n;
      }), i.d(l, "add", function() {
        return V;
      }), i.d(l, "computeMiter", function() {
        return o;
      }), i.d(l, "normal", function() {
        return u;
      }), i.d(l, "direction", function() {
        return d;
      });
      var s = i(1);
      i(1).glMatrix.setMatrixArrayType(Array);
      function c(b) {
        return [b[0], b[1]];
      }
      function W() {
        return [0, 0];
      }
      const h = s.vec2.copy, e = s.vec2.scaleAndAdd, a = s.vec2.dot, G = s.vec2.rotate, y = s.vec2.cross, n = s.vec2.sub, V = s.vec2.add, I = s.vec2.normalize, r = s.vec2.set, p = W();
      function o(b, t, m, R, S) {
        V(b, m, R), I(b, b), r(t, -b[1], b[0]), r(p, -m[1], m[0]);
        const C = S / a(t, p);
        return Math.abs(C);
      }
      function u(b, t) {
        return r(b, -t[1], t[0]), b;
      }
      function d(b, t, m) {
        return n(b, t, m), I(b, b), b;
      }
    },
    /* 50 */
    /***/
    function(Z, l, i) {
      var s = i(51), c = i(52);
      Z.exports = function(h, e) {
        return h = s(h, e), h = c(h, e), h;
      }, Z.exports.radialDistance = s, Z.exports.douglasPeucker = c;
    },
    /* 51 */
    /***/
    function(Z, l) {
      function i(s, c) {
        var W = s[0] - c[0], h = s[1] - c[1];
        return W * W + h * h;
      }
      Z.exports = function(c, W) {
        if (c.length <= 1)
          return c;
        W = typeof W == "number" ? W : 1;
        for (var h = W * W, e = c[0], a = [e], G, y = 1, n = c.length; y < n; y++)
          G = c[y], i(G, e) > h && (a.push(G), e = G);
        return e !== G && a.push(G), a;
      };
    },
    /* 52 */
    /***/
    function(Z, l) {
      function i(c, W, h) {
        var e = W[0], a = W[1], G = h[0] - e, y = h[1] - a;
        if (G !== 0 || y !== 0) {
          var n = ((c[0] - e) * G + (c[1] - a) * y) / (G * G + y * y);
          n > 1 ? (e = h[0], a = h[1]) : n > 0 && (e += G * n, a += y * n);
        }
        return G = c[0] - e, y = c[1] - a, G * G + y * y;
      }
      function s(c, W, h, e, a) {
        for (var G = e, y, n = W + 1; n < h; n++) {
          var V = i(c[n], c[W], c[h]);
          V > G && (y = n, G = V);
        }
        G > e && (y - W > 1 && s(c, W, y, e, a), a.push(c[y]), h - y > 1 && s(c, y, h, e, a));
      }
      Z.exports = function(W, h) {
        if (W.length <= 1)
          return W;
        h = typeof h == "number" ? h : 1;
        var e = h * h, a = W.length - 1, G = [W[0]];
        return s(W, 0, a, e, G), G.push(W[a]), G;
      };
    },
    /* 53 */
    /***/
    function(Z, l, i) {
      i.r(l), i.d(l, "getTotalLength", function() {
        return c;
      }), i.d(l, "getPointAtLength", function() {
        return h;
      }), i.d(l, "getDashContours", function() {
        return e;
      });
      var s = i(54);
      i(1).glMatrix.setMatrixArrayType(Array);
      function c(a) {
        if (a.totalLength != null)
          return a.totalLength;
        let G = 0;
        return a.forEach((y) => {
          let n = y[0];
          for (let V = 1; V < y.length; V++) {
            const I = y[V];
            G += Object(s.distance)(n, I), n = I;
          }
        }), a.totalLength = G, G;
      }
      function W(a, G, y = !0) {
        if (G = Number(G), !Number.isFinite(G))
          throw new TypeError("Failed to execute 'getPointAtLength' on figure: The provided float value is non-finite.");
        if (G <= 0)
          throw new TypeError("Length must > 0");
        const n = c(a);
        if (G >= n) {
          const I = a[a.length - 1], r = I[I.length - 2], p = I[I.length - 1], o = Math.atan2(p[1] - r[1], p[0] - r[0]);
          return {
            current: a.map((u) => [...u]),
            point: {
              x: p[0],
              y: p[1],
              angle: o
            }
          };
        }
        const V = [];
        for (let I = 0; I < a.length; I++) {
          V[I] = [];
          const r = a[I];
          let p = r[0];
          for (let o = 1; o < r.length; o++) {
            const u = r[o], d = Object(s.distance)(p, u);
            if (G < d) {
              const b = G / d, t = Math.atan2(u[1] - p[1], u[0] - p[0]), m = {
                x: p[0] * (1 - b) + u[0] * b,
                y: p[1] * (1 - b) + u[1] * b,
                angle: t
              };
              if (V[I].push(p), G > 0 && V[I].push([m.x, m.y]), !y)
                return {
                  current: V,
                  point: m
                };
              const R = [], S = I;
              for (; I < a.length; I++) {
                for (R[I - S] = [], I === S && R[0].push([m.x, m.y]); o < r.length; o++)
                  R[I - S].push(r[o]);
                o = 0;
              }
              return {
                current: V,
                point: m,
                rest: R
              };
            }
            G -= d, V[I].push(p), p = u;
          }
        }
      }
      function h(a, G) {
        if (G = Number(G), !Number.isFinite(G))
          throw new TypeError("Failed to execute 'getPointAtLength' on figure: The provided float value is non-finite.");
        if (a.length <= 0)
          return {
            x: 0,
            y: 0,
            angle: 0
          };
        if (G <= 0) {
          const y = a[0][0], n = a[0][1], V = Math.atan2(n[1] - y[1], n[0] - y[0]);
          return {
            x: y[0],
            y: y[1],
            angle: V
          };
        }
        return W(a, G, !1).point;
      }
      function e(a, G, y) {
        let n = 0, V = G[0], I = a;
        const r = [], p = G.length;
        if (y > 0) {
          do
            y -= G[n % p], n++;
          while (y > 0);
          y < 0 && (V = -y, n--);
        } else if (y < 0) {
          n = -1;
          do
            y += G[n % p + p - 1], n--;
          while (y < 0);
          y >= 0 && (n++, V = G[n % p + p - 1] - y);
        }
        do {
          const o = W(I, V);
          I = o.rest, ++n % 2 && r.push(...o.current);
          let u = n % p;
          u < 0 && (u += p), V = G[u];
        } while (I);
        return r;
      }
    },
    /* 54 */
    /***/
    function(Z, l, i) {
      i.r(l), i.d(l, "normalize", function() {
        return s;
      }), i.d(l, "distance", function() {
        return c;
      }), i(1).glMatrix.setMatrixArrayType(Array);
      function s([W, h, e], a, G, y) {
        return W = W * 2 / a - 1, h = 1 - h * 2 / G, Number.isFinite(y) ? (e = e * 2 / y - 1, [W, h, e]) : [W, h];
      }
      function c([W, h, e = 0], [a, G, y = 0]) {
        return Math.hypot(a - W, G - h, y - e);
      }
    },
    /* 55 */
    /***/
    function(Z, l, i) {
      i.r(l), i.d(l, "getPoint", function() {
        return c;
      }), i(1).glMatrix.setMatrixArrayType(Array);
      const s = Math.PI * 2;
      function c(W, h, e, a, G) {
        G %= s, G < 0 && (G += s);
        const y = Math.tan(G);
        if (Math.abs(y) < 1e5) {
          const n = h - y * W, V = 1 / e ** 2 + y ** 2 / a ** 2;
          let I = -1;
          (G <= Math.PI / 2 || G > 3 * Math.PI / 2) && (I = 1);
          const r = I * Math.sqrt(1 / V) + W, p = y * r + n;
          return [r, p];
        }
        return G < Math.PI ? [W, h + a] : [W, h - a];
      }
    },
    /* 56 */
    /***/
    function(Z, l, i) {
      i.r(l), i.d(l, "default", function() {
        return E;
      });
      var s = i(1), c = i(42), W = /* @__PURE__ */ i.n(c), h = i(57), e = i(28), a = i(24), G = i(30), y = i(59), n = i(53), V = i(60), I = /* @__PURE__ */ i.n(V), r = i(46), p = /* @__PURE__ */ i.n(r), o = i(31), u = i(40), d = i(21);
      i(1).glMatrix.setMatrixArrayType(Array);
      function b(B, g) {
        if (B == null)
          return {};
        var U = t(B, g), X, L;
        if (Object.getOwnPropertySymbols) {
          var N = Object.getOwnPropertySymbols(B);
          for (L = 0; L < N.length; L++)
            X = N[L], !(g.indexOf(X) >= 0) && Object.prototype.propertyIsEnumerable.call(B, X) && (U[X] = B[X]);
        }
        return U;
      }
      function t(B, g) {
        if (B == null)
          return {};
        var U = {}, X = Object.keys(B), L, N;
        for (N = 0; N < X.length; N++)
          L = X[N], !(g.indexOf(L) >= 0) && (U[L] = B[L]);
        return U;
      }
      const m = Symbol("mesh"), R = Symbol("contours"), S = Symbol("stroke"), C = Symbol("fill"), F = Symbol("strokeColor"), K = Symbol("fillColor"), J = Symbol("transform"), T = Symbol("invertTransform"), Y = Symbol("uniforms"), x = Symbol("texOptions"), H = Symbol("blend"), Q = Symbol("applyTexture"), w = Symbol("applyTransform"), O = Symbol("applyGradientTransform"), q = Symbol("applyProgram"), k = Symbol("gradient"), f = Symbol("filter"), D = Symbol("opacity"), ii = Symbol("program"), _ = Symbol("attributes"), bi = Symbol("pass"), $ = Symbol("clipContext"), oi = Symbol("applyClipPath");
      function ni(B, g) {
        const [U, X] = [B[1][0] - B[0][0], B[1][1] - B[0][1]], L = [];
        for (let N = 0; N < g.length; N++) {
          const v = g[N], P = [(v[0] - B[0][0]) / U, 1 - (v[1] - B[0][1]) / X];
          L.push(P);
        }
        return L;
      }
      function z([B, g], [U, X, L, N], {
        scale: v
      }) {
        return v || (B /= L, g = 1 - g / N, B -= U, g += X), [B, g, 0];
      }
      function M(B, g, U) {
        const X = p()(B, g, U);
        return X.path = B, X.simplify = U, X.scale = g, X;
      }
      class E {
        constructor(g) {
          this[S] = null, this[C] = null, this[J] = [1, 0, 0, 1, 0, 0], this[D] = 1, this[Y] = {}, this[f] = [], this[H] = null, this[x] = {}, this.contours = g.contours, this[ii] = null, this[_] = {}, this[bi] = [];
        }
        get contours() {
          return this[R];
        }
        set contours(g) {
          this[m] = null, this[R] = g;
          const U = g.scale;
          this.transformScale / U > 1.5 && this.accurate(this.transformScale);
        }
        setProgram(g) {
          this[ii] = g, this[m] && this[q](g);
        }
        get program() {
          return this[ii];
        }
        setAttribute(g, U) {
          U == null ? delete this[_][g] : this[_][g] = U;
        }
        getOpacity() {
          return this[D];
        }
        setOpacity(g) {
          if (g < 0 || g > 1)
            throw new TypeError("Invalid opacity value.");
          this[m] && this[m].positions.forEach((U) => {
            U[2] = 1 / U[2] > 0 ? g : -g;
          }), this[D] = g;
        }
        setClipPath(g) {
          this.clipPath = g, this[Y].u_clipSampler && this[Y].u_clipSampler.delete(), this.setUniforms({
            u_clipSampler: null
          }), this[m] && delete this[m].attributes.a_clipUV, g && this[m] && this[oi]();
        }
        [oi]() {
          if (this.clipPath) {
            this[$] || (this[$] = d.default.createCanvas(1, 1));
            const [[g, U], [X, L]] = this.boundingBox;
            X && L && (this[$].width = X - g, this[$].height = L - U);
            const N = this[$].getContext("2d"), v = new Path2D(this.clipPath);
            N.clearRect(0, 0, this[$].width, this[$].height), N.save(), N.translate(-g, -U), N.fillStyle = "white", N.fill(v), N.restore(), this[m].clipPath = this[$];
            const P = ni(this.boundingBox, this[m].position0);
            this[m].attributes.a_clipUV = P;
          }
        }
        getPointAtLength(g) {
          return Object(n.getPointAtLength)(this[R], g);
        }
        getTotalLength() {
          return Object(n.getTotalLength)(this[R]);
        }
        get blend() {
          return this[H] == null ? "auto" : this[H];
        }
        set blend(g) {
          this[H] = g, this[m] && (this[m].enableBlend = this.enableBlend);
        }
        get boundingBox() {
          if (this[m] && this[m].boundingBox)
            return this[m].boundingBox;
          const g = this.meshData;
          if (g) {
            const U = g.position0;
            if (U.length)
              g.boundingBox = W()(U);
            else
              return [[0, 0], [0, 0]];
            return g.boundingBox;
          }
          return [[0, 0], [0, 0]];
        }
        get boundingCenter() {
          const g = this.boundingBox;
          return g ? [0.5 * (g[0][0] + g[1][0]), 0.5 * (g[0][1] + g[1][1])] : [0, 0];
        }
        get fillRule() {
          return this[C] ? this[C].rule : "nonzero";
        }
        get lineWidth() {
          return this[S] ? this[S].lineWidth : 0;
        }
        get lineCap() {
          return this[S] ? this[S].lineCap : "";
        }
        get lineJoin() {
          return this[S] ? this[S].lineJoin : "";
        }
        get miterLimit() {
          return this[S] ? this[S].miterLimit : 0;
        }
        get strokeStyle() {
          return this[F] && this[F][3] !== 0 ? Object(a.default)(this[F]) : "";
        }
        get lineDash() {
          return this[S] ? this[S].lineDash : null;
        }
        get lineDashOffset() {
          return this[S] ? this[S].lineDashOffset : 0;
        }
        get fillStyle() {
          return this[K] && this[K][3] !== 0 ? Object(a.default)(this[K]) : "";
        }
        get gradient() {
          return this[k];
        }
        get texture() {
          return this[Y].u_texSampler ? {
            image: this[Y].u_texSampler._img,
            options: this[x]
          } : null;
        }
        get enableBlend() {
          return this[H] === !0 || this[H] === !1 ? this[H] : this[D] < 1 || this[F] != null && this[F][3] < 1 || this[K] != null && this[K][3] < 1 || this[Y].u_colorMatrix != null && this[Y].u_colorMatrix[18] < 1 || this[Y].u_radialGradientVector != null || this.beforeRender || this.afterRender;
        }
        get filterCanvas() {
          return /blur|drop-shadow|url/.test(this.filter);
        }
        get filter() {
          return this[f].join(" ");
        }
        get transformMatrix() {
          return this[J];
        }
        get invertMatrix() {
          if (!this[T]) {
            const g = s.mat2d.invert(Array.of(0, 0, 0, 0, 0, 0), this[J]);
            this[T] = g;
          }
          return this[T];
        }
        get transformScale() {
          const g = this[J];
          return Math.max(Math.hypot(g[0], g[1]), Math.hypot(g[2], g[3]));
        }
        get uniforms() {
          return this[Y];
        }
        get pass() {
          return this[bi];
        }
        [q](g) {
          const U = this[_], X = this[m].position0, L = Object.entries(g._attribute);
          for (let N = 0; N < L.length; N++) {
            const [v, P] = L[N];
            if (v !== "a_color" && v !== "a_sourceRect" && P !== "ignored") {
              const j = U[v];
              if (v === "uv" && !j) {
                const A = this[m].boundingBox || W()(X);
                this[m].attributes[v] = ni(A, X);
              } else {
                this[m].attributes[v] = [];
                for (let A = 0; A < X.length; A++) {
                  const li = X[A];
                  this[m].attributes[v].push(j ? j(li, N, X) : Array(P.size).fill(0));
                }
              }
            }
          }
        }
        // {stroke, fill}
        get meshData() {
          if (this._updateMatrix && this.transformScale / this.contours.scale > 1.5 && this.accurate(this.transformScale), !this[m]) {
            !this[C] && !this[S] && this.setFill();
            const g = this[R], U = {};
            if (g && g.length) {
              if (this[C])
                try {
                  const N = I()(g, this[C]);
                  N.positions = N.positions.map((v) => (v.push(this[D]), v)), N.attributes = {
                    a_color: Array.from({
                      length: N.positions.length
                    }).map(() => this[K].map((v) => Math.round(255 * v)))
                    // a_sourceRect: Array.from({length: mesh.positions.length}).map(() => [0, 0, 0, 0]),
                  }, U.fill = N;
                } catch {
                }
              if (this[S]) {
                const N = this[S].lineDash;
                let v = g;
                if (N) {
                  const j = this[S].lineDashOffset;
                  v = Object(n.getDashContours)(g, N, j);
                }
                const P = v.map((j, A) => {
                  const li = j.length > 1 && s.vec2.equals(j[0], j[j.length - 1]), di = this[S].build(j, li);
                  return I()([di]);
                });
                P.forEach((j) => {
                  j.positions = j.positions.map((A) => (A.push(-this[D]), A)), j.attributes = {
                    a_color: Array.from({
                      length: j.positions.length
                    }).map(() => this[F].map((A) => Math.round(255 * A)))
                  };
                }), U.stroke = Object(e.default)(P);
              }
            }
            const X = Object(e.default)([U.fill, U.stroke]);
            X.fillPointCount = U.fill ? U.fill.positions.length : 0, X.enableBlend = this.enableBlend, X.position0 = X.positions.map(([N, v, P]) => [N, v, P]), X.uniforms = this[Y], this[m] = X, this[Y].u_texSampler && this[Q](X, this[x]);
            const L = this[J];
            Object(y.isUnitTransform)(L) || (this[w](X, L), this[Y].u_radialGradientVector && this[O]()), this.clipPath && this[oi](), this[ii] && this[q](this[ii]);
          }
          return this._updateMatrix && (this[m].matrix = this[J], this[w](this[m], this[J]), this[Y].u_radialGradientVector && this[O]()), this[m];
        }
        [w](g, U) {
          const {
            positions: X,
            position0: L
          } = g;
          for (let N = 0; N < X.length; N++) {
            const [v, P] = L[N], j = X[N];
            j[0] = v * U[0] + P * U[2] + U[4], j[1] = v * U[1] + P * U[3] + U[5];
          }
          this._updateMatrix = !1;
        }
        [O]() {
          const g = this[J], U = [...this._radialGradientVector];
          if (U) {
            const [X, L, , N, v] = U;
            U[0] = X * g[0] + L * g[2] + g[4], U[1] = X * g[1] + L * g[3] + g[5], U[3] = N * g[0] + v * g[2] + g[4], U[4] = N * g[1] + v * g[3] + g[5], this[Y].u_radialGradientVector = U;
          }
        }
        [Q](g, U) {
          function X(A, li) {
            return A == null && li == null ? !0 : A == null || li == null ? !1 : A[0] === li[0] && A[1] === li[1] && A[2] === li[2] && A[3] === li[3];
          }
          const L = this[Y].u_texSampler;
          if (!L)
            return;
          const {
            width: N,
            height: v
          } = L._img, P = U.srcRect;
          let j = U.rect || [0, 0];
          if (U.rotated && (j = [-j[1], j[0], j[3], j[2]]), j[2] == null && (j[2] = P ? P[2] : N), j[3] == null && (j[3] = P ? P[3] : v), U.hidden)
            g.textureCoord = g.positions.map(() => [-1, -1, -1]);
          else if (!g.textureCoord || !X(this[x].rect, U.rect) || this[x].hidden !== U.hidden || this[x].rotated !== U.rotated) {
            let A = null;
            U.rotated && (A = s.mat2d.rotate(Array.of(0, 0, 0, 0, 0, 0), s.mat2d.fromValues(1, 0, 0, 1, 0, 0), 0.5 * Math.PI), A = s.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), A, [0, -j[2]])), g.textureCoord = g.position0.map(([li, di, ci]) => {
              if (1 / ci > 0) {
                if (U.rotated) {
                  const ti = li * A[0] + di * A[2] + A[4], si = li * A[1] + di * A[3] + A[5];
                  [li, di] = [ti, si];
                }
                const mi = z([li, di], [j[0] / j[2], j[1] / j[3], j[2], j[3]], U);
                return U.repeat && (mi[2] = 1), mi;
              }
              return [-1, -1, -1];
            });
          }
          if (P) {
            const A = [P[0] / N, P[1] / v, P[2] / N, P[3] / v];
            g.attributes.a_sourceRect = g.positions.map(() => [...A]);
          } else
            g.attributes.a_sourceRect = g.positions.map(() => [0, 0, 0, 0]);
        }
        accurate(g) {
          if (!this.contours)
            return;
          if (this.contours.path) {
            const X = this.contours.simplify, L = M(this.contours.path, 2 * g, X);
            this[m] = null, this[R] = L;
          }
        }
        canIgnore() {
          const g = this[S] == null || this[S].lineWidth === 0 || this[F][3] === 0, U = this[C] == null || this[K][3] === 0, X = this[Y].u_radialGradientVector == null, L = this[Y].u_texSampler == null;
          return this[D] === 0 || this[ii] == null && g && U && X && L && !this.beforeRender && !this.afterRender;
        }
        // join: 'miter' or 'bevel'
        // cap: 'butt' or 'square'
        // lineDash: null
        // lineDashOffset: 0
        setStroke({
          thickness: g = 1,
          cap: U = "butt",
          join: X = "miter",
          miterLimit: L = 10,
          color: N = [0, 0, 0, 0],
          lineDash: v = null,
          lineDashOffset: P = 0,
          roundSegments: j = 20
        } = {}) {
          return this[m] = null, this[S] = new h.default({
            lineWidth: g,
            lineCap: U,
            lineJoin: X,
            miterLimit: L,
            roundSegments: j
          }), typeof N == "string" && (N = Object(o.default)(N)), this[F] = N, this[S].lineDash = v, this[S].lineDashOffset = P, this;
        }
        setFill({
          rule: g = this.fillRule,
          color: U = [0, 0, 0, 0]
        } = {}) {
          return this[m] = null, this[C] = {
            rule: g
          }, typeof U == "string" && (U = Object(o.default)(U)), this[K] = U, this;
        }
        /**
          options: {
            scale: false,
            repeat: false,
            rotated: false,
            rect: [10, 10],
            srcRect: [...],
            hidden: false,
          }
         */
        setTexture(g, U = {}) {
          if (g && g.image) {
            const {
              image: X,
              rect: L
            } = g;
            if (g = X, U.rect)
              for (let N = 0; N < U.rect.length; N++)
                L[N] = U.rect[N];
            U.rect = L;
          }
          return this[C] || this.setFill(), this.setUniforms({
            u_texSampler: g
          }), this[m] && this[Q](this[m], U), this[x] = U, this;
        }
        setCircularGradient({
          vector: g,
          colors: U,
          type: X = "fill"
        } = {}) {
          if (g.length !== 3)
            throw new TypeError("Invalid linearGradient.");
          this.setGradient({
            vector: g,
            colors: U,
            type: X
          });
        }
        setLinearGradient({
          vector: g,
          colors: U,
          type: X = "fill"
        } = {}) {
          if (g.length !== 4)
            throw new TypeError("Invalid linearGradient.");
          this.setGradient({
            vector: g,
            colors: U,
            type: X
          });
        }
        setRadialGradient({
          vector: g,
          colors: U,
          type: X = "fill"
        } = {}) {
          if (g.length !== 6)
            throw new TypeError("Invalid radialGradient.");
          this.setGradient({
            vector: g,
            colors: U,
            type: X
          });
        }
        /**
          vector: [x0, y0, r0, x1, y1, r1],
          colors: [{offset:0, color}, {offset:1, color}, ...],
         */
        setGradient({
          vector: g,
          colors: U,
          type: X = "fill"
        } = {}) {
          U = U.map(({
            offset: v,
            color: P
          }) => (typeof P == "string" && (P = Object(o.default)(P)), {
            offset: v,
            color: P
          })), this[k] = this[k] || {}, this[k][X] = {
            vector: g,
            colors: U
          }, U.sort((v, P) => v.offset - P.offset);
          const L = [];
          U.forEach(({
            offset: v,
            color: P
          }) => {
            L.push(v, ...P);
          });
          let N;
          if (g.length === 4 ? N = [g[0], g[1], 0, g[2], g[3], 0] : N = [...g], L.length < 40 && L.push(-1), L.length > 40)
            throw new Error("Too many colors, should be less than 8 colors");
          return this._radialGradientVector = N, this[Y].u_colorSteps = L, X === "fill" ? this[Y].u_gradientType = 1 : this[Y].u_gradientType = 0, this[O](), this;
        }
        setUniforms(g = {}) {
          return Object.assign(this[Y], g), this;
        }
        setTransform(...g) {
          const U = this[J];
          return s.mat2d.equals(g, U) || (this[J] = g, delete this[T], this._updateMatrix = !0), this;
        }
        transform(...g) {
          const U = this[J];
          return this[J] = s.mat2d.multiply(Array.of(0, 0, 0, 0, 0, 0), U, g), delete this[T], this._updateMatrix = !0, this;
        }
        translate(g, U) {
          let X = s.mat2d.create();
          return X = s.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), X, [g, U]), this.transform(...X);
        }
        rotate(g, [U, X] = [0, 0]) {
          let L = s.mat2d.create();
          return L = s.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), L, [U, X]), L = s.mat2d.rotate(Array.of(0, 0, 0, 0, 0, 0), L, g), L = s.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), L, [-U, -X]), this.transform(...L);
        }
        scale(g, U = g, [X, L] = [0, 0]) {
          let N = s.mat2d.create();
          return N = s.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), N, [X, L]), N = s.mat2d.scale(Array.of(0, 0, 0, 0, 0, 0), N, [g, U]), N = s.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), N, [-X, -L]), this.transform(...N);
        }
        skew(g, U = g, [X, L] = [0, 0]) {
          let N = s.mat2d.create();
          return N = s.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), N, [X, L]), N = s.mat2d.multiply(Array.of(0, 0, 0, 0, 0, 0), N, s.mat2d.fromValues(1, Math.tan(U), Math.tan(g), 1, 0, 0)), N = s.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), N, [-X, -L]), this.transform(...N);
        }
        clearFilter() {
          return this.setColorTransform(null), this[f].length = 0, this;
        }
        setColorTransform(...g) {
          return g[0] === null ? this.setUniforms({
            u_filterFlag: 0,
            u_colorMatrix: 0
          }) : this.setUniforms({
            u_filterFlag: 1,
            u_colorMatrix: g
          }), this;
        }
        // apply linear color transform
        transformColor(...g) {
          let U = this.uniforms.u_colorMatrix;
          return U ? U = Object(G.multiply)(U, g) : U = g, this.setColorTransform(...U), this;
        }
        blur(g) {
          return this[f].push(`blur(${g}px)`), this;
        }
        brightness(g = 1) {
          return this[f].push(`brightness(${100 * g}%)`), this.transformColor(...Object(G.brightness)(g));
        }
        contrast(g = 1) {
          return this[f].push(`contrast(${100 * g}%)`), this.transformColor(...Object(G.contrast)(g));
        }
        dropShadow(g, U, X = 0, L = [0, 0, 0, 1]) {
          return Array.isArray(L) && (L = Object(a.default)(L)), this[f].push(`drop-shadow(${g}px ${U}px ${X}px ${L})`), this;
        }
        grayscale(g = 1) {
          return this[f].push(`grayscale(${100 * g}%)`), this.transformColor(...Object(G.grayscale)(g));
        }
        // https://github.com/phoboslab/WebGLImageFilter/blob/master/webgl-image-filter.js#L371
        hueRotate(g = 0) {
          return this[f].push(`hue-rotate(${g}deg)`), this.transformColor(...Object(G.hueRotate)(g));
        }
        invert(g = 1) {
          return this[f].push(`invert(${100 * g}%)`), this.transformColor(...Object(G.invert)(g));
        }
        opacity(g = 1) {
          return this[f].push(`opacity(${100 * g}%)`), this.transformColor(...Object(G.opacity)(g));
        }
        saturate(g = 1) {
          return this[f].push(`saturate(${100 * g}%)`), this.transformColor(...Object(G.saturate)(g));
        }
        sepia(g = 1) {
          return this[f].push(`sepia(${100 * g}%)`), this.transformColor(...Object(G.sepia)(g));
        }
        url(g) {
          return this[f].push(`url(${g})`), this;
        }
        isPointCollision(g, U, X = "both") {
          const L = this.meshData, {
            positions: N,
            cells: v
          } = L, P = this.invertMatrix, j = P[0] * g + P[2] * U + P[4], A = P[1] * g + P[3] * U + P[5], li = this.boundingBox;
          if (j < li[0][0] || j > li[1][0] || A < li[0][1] || A > li[1][1])
            return !1;
          function di([ci, mi], [ti, si], [Zi, ai]) {
            const ei = Zi - ti, Xi = ai - si, ui = ((ci - ti) * ei + (mi - si) * Xi) / (ei ** 2 + Xi ** 2);
            return ui >= 0 && ui <= 1;
          }
          for (let ci = 0; ci < v.length; ci++) {
            const mi = v[ci];
            if (X === "fill" && mi[0] >= L.fillPointCount)
              break;
            if (X === "stroke" && mi[0] < L.fillPointCount)
              continue;
            const [[ti, si], [Zi, ai], [ei, Xi]] = mi.map((Ki) => N[Ki]), ui = Math.sign((g - ti) * (ai - si) - (Zi - ti) * (U - si));
            if (ui === 0 && di([g, U], [ti, si], [Zi, ai]))
              return !0;
            const ri = Math.sign((g - Zi) * (Xi - ai) - (ei - Zi) * (U - ai));
            if (ri === 0 && di([g, U], [Zi, ai], [ei, Xi]))
              return !0;
            const yi = Math.sign((g - ei) * (si - Xi) - (ti - ei) * (U - Xi));
            if (yi === 0 && di([g, U], [ei, Xi], [ti, si]) || ui === 1 && ri === 1 && yi === 1 || ui === -1 && ri === -1 && yi === -1)
              return !0;
          }
          return !1;
        }
        isPointInFill(g, U) {
          return this.isPointCollision(g, U, "fill");
        }
        isPointInStroke(g, U) {
          return this.isPointCollision(g, U, "stroke");
        }
        addPass(g, U = {}) {
          let {
            width: X,
            height: L
          } = U, N = b(U, ["width", "height"]);
          const v = new u.default();
          v.rect(0, 0, X, L);
          const P = new E(v, {
            width: X,
            height: L
          });
          P.setUniforms(N), P.setProgram(g), this[bi].push(P);
        }
      }
    },
    /* 57 */
    /***/
    function(Z, l, i) {
      i.r(l);
      var s = i(58);
      i(1).glMatrix.setMatrixArrayType(Array), l.default = s.Stroke;
    },
    /* 58 */
    /***/
    function(Z, l, i) {
      i.r(l), i.d(l, "Stroke", function() {
        return y;
      });
      var s = i(49);
      i(1).glMatrix.setMatrixArrayType(Array);
      const c = Object(s.create)(), W = Object(s.create)(), h = Object(s.create)(), e = Object(s.create)(), a = Object(s.create)(), G = 1e20;
      class y {
        constructor({
          lineWidth: p = 1,
          lineJoin: o = "miter",
          miterLimit: u = 10,
          lineCap: d = "butt",
          roundSegments: b = 20
        } = {}) {
          this.lineWidth = p, this.lineJoin = o, this.miterLimit = u, this.lineCap = d, this.roundSegments = b, this._normal = null;
        }
        build(p, o = !1) {
          let u = p.length;
          if (p = [...p], u < 2)
            return p;
          o && ((p[0][0] !== p[u - 1][0] || p[0][1] !== p[u - 1][1]) && p.push([...p[0]]), p.push([...p[1]])), u = p.length, this._normal = null;
          const d = {
            left: [],
            right: []
          }, b = this.lineWidth / 2, t = this.lineCap;
          if (!o && t === "square") {
            Object(s.direction)(W, p[0], p[1]), Object(s.scaleAndAdd)(p[0], p[0], W, b);
            const R = p.length - 1;
            Object(s.direction)(W, p[R], p[R - 1]), Object(s.scaleAndAdd)(p[R], p[R], W, b);
          }
          for (let R = 1; R < u; R++) {
            const S = p[R - 1], C = p[R], F = p[R + 1];
            this._seg(d, S, C, F, b, o);
          }
          return !o && t === "round" && I(d, this.roundSegments), [...d.left, ...d.right.reverse()];
        }
        _seg(p, o, u, d, b, t) {
          const m = this.lineJoin === "bevel", R = this.lineJoin === "round";
          if (Object(s.direction)(W, u, o), this._normal || (this._normal = Object(s.create)(), Object(s.normal)(this._normal, W)), p.left.length || V(p, o, this._normal, b), !d)
            Object(s.normal)(this._normal, W), t ? V(p, o, this._normal, b) : V(p, u, this._normal, b);
          else {
            Object(s.direction)(h, d, u);
            let S = Object(s.computeMiter)(e, a, W, h, b);
            S = Math.min(S, G);
            const C = Object(s.dot)(e, this._normal) < 0 ? -1 : 1;
            let F = m || R;
            if (!F && this.lineJoin === "miter" && S / b > this.miterLimit && (F = !0), F) {
              Object(s.scaleAndAdd)(c, u, this._normal, -b * C), n(p, c, C);
              let K = 1 / 0;
              o && (K = Math.min(K, Math.hypot(u[0] - o[0], u[1] - o[1]))), d && (K = Math.min(K, Math.hypot(d[0] - u[0], d[1] - u[1])));
              const J = Math.max(b, Math.min(S, K));
              if (Object(s.scaleAndAdd)(c, u, a, J * C), n(p, c, -C), d)
                if (Object(s.normal)(c, h), Object(s.copy)(this._normal, c), Object(s.scaleAndAdd)(c, u, c, -b * C), R) {
                  const T = Object(s.clone)(c), Y = C > 0 ? p.left[p.left.length - 1] : p.right[p.right.length - 1], x = Object(s.clone)(u), H = Object(s.sub)(Object(s.create)(), Y, x), Q = Object(s.sub)(Object(s.create)(), T, x), w = Math.PI / this.roundSegments;
                  for (let O = 0; O < this.roundSegments && (Object(s.rotate)(H, H, [0, 0], C * w), Math.sign(Object(s.cross)(c, H, Q)[2]) === C); O++)
                    Object(s.add)(c, H, x), n(p, c, C);
                  n(p, T, C);
                } else
                  n(p, c, C);
            } else
              V(p, u, a, S), Object(s.copy)(this._normal, a);
          }
        }
      }
      function n(r, p, o) {
        o > 0 ? r.left.push(Object(s.clone)(p)) : r.right.push(Object(s.clone)(p));
      }
      function V(r, p, o, u, d = -1) {
        Object(s.scaleAndAdd)(c, p, o, -u), n(r, c, -d), Object(s.scaleAndAdd)(c, p, o, u), n(r, c, d);
      }
      function I({
        left: r,
        right: p
      }, o) {
        const u = Object(s.create)(), d = Object(s.create)();
        let b = r[0], t = p[0], m = [0.5 * (b[0] + t[0]), 0.5 * (b[1] + t[1])];
        Object(s.sub)(d, b, m);
        for (let R = 1; R <= o; R++) {
          const S = -1 * Math.PI * R / o;
          Object(s.rotate)(u, d, [0, 0], S), Object(s.add)(c, m, u), r.unshift(Object(s.clone)(c));
        }
        b = p[p.length - 1], t = r[r.length - 1], m = [0.5 * (b[0] + t[0]), 0.5 * (b[1] + t[1])], Object(s.sub)(d, b, m);
        for (let R = 1; R <= o; R++) {
          const S = -1 * Math.PI * R / o;
          Object(s.rotate)(u, d, [0, 0], S), Object(s.add)(c, m, u), p.push(Object(s.clone)(c));
        }
      }
    },
    /* 59 */
    /***/
    function(Z, l, i) {
      i.r(l), i.d(l, "isUnitTransform", function() {
        return s;
      }), i(1).glMatrix.setMatrixArrayType(Array);
      function s(c) {
        return c[0] === 1 && c[1] === 0 && c[2] === 0 && c[3] === 1 && c[4] === 0 && c[5] === 0;
      }
    },
    /* 60 */
    /***/
    function(Z, l, i) {
      i(1).glMatrix.setMatrixArrayType(Array);
      var s = i(61), c = i(62);
      Z.exports = function(W, h) {
        if (h = h || {}, W = W.filter(function(o) {
          return o.length > 2;
        }), W.length === 0)
          return {
            positions: [],
            cells: []
          };
        typeof h.vertexSize != "number" && (h.vertexSize = W[0][0].length), W = W.map(function(o) {
          return o.reduce(function(u, d) {
            return u.concat(d);
          });
        });
        const e = h.rule === "evenodd" ? s.WINDING_ODD : s.WINDING_NONZERO;
        for (var a = s.tesselate(c({
          contours: W,
          windingRule: e,
          elementType: s.POLYGONS,
          polySize: 3,
          vertexSize: 2
        }, h)), G = [], y = 0; y < a.vertices.length; y += h.vertexSize) {
          var n = a.vertices.slice(y, y + h.vertexSize);
          G.push(n);
        }
        var V = [];
        for (y = 0; y < a.elements.length; y += 3) {
          var I = a.elements[y], r = a.elements[y + 1], p = a.elements[y + 2];
          V.push([I, r, p]);
        }
        return {
          positions: G,
          cells: V
        };
      };
    },
    /* 61 */
    /***/
    function(Z, l, i) {
      i(1).glMatrix.setMatrixArrayType(Array);
      var s = {}, c = {};
      Z.exports = s, s.WINDING_ODD = 0, s.WINDING_NONZERO = 1, s.WINDING_POSITIVE = 2, s.WINDING_NEGATIVE = 3, s.WINDING_ABS_GEQ_TWO = 4, s.POLYGONS = 0, s.CONNECTED_POLYGONS = 1, s.BOUNDARY_CONTOURS = 2, s.tesselate = function(d) {
        for (var b = d.debug || !1, t = new u(), m = 0; m < d.contours.length; m++)
          t.addContour(d.vertexSize || 2, d.contours[m]);
        return t.tesselate(d.windingRule || s.WINDING_ODD, d.elementType || s.POLYGONS, d.polySize || 3, d.vertexSize || 2, d.normal || [0, 0, 1]), {
          vertices: t.vertices,
          vertexIndices: t.vertexIndices,
          vertexCount: t.vertexCount,
          elements: t.elements,
          elementCount: t.elementCount,
          mesh: b ? t.mesh : void 0
        };
      };
      var W = function(d) {
        if (!d)
          throw "Assertion Failed!";
      };
      function h() {
        this.next = null, this.prev = null, this.anEdge = null, this.coords = [0, 0, 0], this.s = 0, this.t = 0, this.pqHandle = 0, this.n = 0, this.idx = 0;
      }
      function e() {
        this.next = null, this.prev = null, this.anEdge = null, this.trail = null, this.n = 0, this.marked = !1, this.inside = !1;
      }
      function a(d) {
        this.next = null, this.Sym = null, this.Onext = null, this.Lnext = null, this.Org = null, this.Lface = null, this.activeRegion = null, this.winding = 0, this.side = d;
      }
      a.prototype = {
        get Rface() {
          return this.Sym.Lface;
        },
        set Rface(d) {
          this.Sym.Lface = d;
        },
        get Dst() {
          return this.Sym.Org;
        },
        set Dst(d) {
          this.Sym.Org = d;
        },
        get Oprev() {
          return this.Sym.Lnext;
        },
        set Oprev(d) {
          this.Sym.Lnext = d;
        },
        get Lprev() {
          return this.Onext.Sym;
        },
        set Lprev(d) {
          this.Onext.Sym = d;
        },
        get Dprev() {
          return this.Lnext.Sym;
        },
        set Dprev(d) {
          this.Lnext.Sym = d;
        },
        get Rprev() {
          return this.Sym.Onext;
        },
        set Rprev(d) {
          this.Sym.Onext = d;
        },
        get Dnext() {
          return (
            /*this.Rprev*/
            this.Sym.Onext.Sym
          );
        },
        /* 3 pointers */
        set Dnext(d) {
          this.Sym.Onext.Sym = d;
        },
        /* 3 pointers */
        get Rnext() {
          return (
            /*this.Oprev*/
            this.Sym.Lnext.Sym
          );
        },
        /* 3 pointers */
        set Rnext(d) {
          this.Sym.Lnext.Sym = d;
        }
        /* 3 pointers */
      };
      function G() {
        var d = new h(), b = new e(), t = new a(0), m = new a(1);
        d.next = d.prev = d, d.anEdge = null, b.next = b.prev = b, b.anEdge = null, b.trail = null, b.marked = !1, b.inside = !1, t.next = t, t.Sym = m, t.Onext = null, t.Lnext = null, t.Org = null, t.Lface = null, t.winding = 0, t.activeRegion = null, m.next = m, m.Sym = t, m.Onext = null, m.Lnext = null, m.Org = null, m.Lface = null, m.winding = 0, m.activeRegion = null, this.vHead = d, this.fHead = b, this.eHead = t, this.eHeadSym = m;
      }
      G.prototype = {
        /* MakeEdge creates a new pair of half-edges which form their own loop.
        * No vertex or face structures are allocated, but these must be assigned
        * before the current edge operation is completed.
        */
        //static TESShalfEdge *MakeEdge( TESSmesh* mesh, TESShalfEdge *eNext )
        makeEdge_: function(d) {
          var b = new a(0), t = new a(1);
          d.Sym.side < d.side && (d = d.Sym);
          var m = d.Sym.next;
          return t.next = m, m.Sym.next = b, b.next = d, d.Sym.next = t, b.Sym = t, b.Onext = b, b.Lnext = t, b.Org = null, b.Lface = null, b.winding = 0, b.activeRegion = null, t.Sym = b, t.Onext = t, t.Lnext = b, t.Org = null, t.Lface = null, t.winding = 0, t.activeRegion = null, b;
        },
        /* Splice( a, b ) is best described by the Guibas/Stolfi paper or the
        * CS348a notes (see mesh.h).  Basically it modifies the mesh so that
        * a->Onext and b->Onext are exchanged.  This can have various effects
        * depending on whether a and b belong to different face or vertex rings.
        * For more explanation see tessMeshSplice() below.
        */
        // static void Splice( TESShalfEdge *a, TESShalfEdge *b )
        splice_: function(d, b) {
          var t = d.Onext, m = b.Onext;
          t.Sym.Lnext = b, m.Sym.Lnext = d, d.Onext = m, b.Onext = t;
        },
        /* MakeVertex( newVertex, eOrig, vNext ) attaches a new vertex and makes it the
        * origin of all edges in the vertex loop to which eOrig belongs. "vNext" gives
        * a place to insert the new vertex in the global vertex list.  We insert
        * the new vertex *before* vNext so that algorithms which walk the vertex
        * list will not see the newly created vertices.
        */
        //static void MakeVertex( TESSvertex *newVertex, TESShalfEdge *eOrig, TESSvertex *vNext )
        makeVertex_: function(d, b, t) {
          var m = d;
          W(m !== null);
          var R = t.prev;
          m.prev = R, R.next = m, m.next = t, t.prev = m, m.anEdge = b;
          var S = b;
          do
            S.Org = m, S = S.Onext;
          while (S !== b);
        },
        /* MakeFace( newFace, eOrig, fNext ) attaches a new face and makes it the left
        * face of all edges in the face loop to which eOrig belongs.  "fNext" gives
        * a place to insert the new face in the global face list.  We insert
        * the new face *before* fNext so that algorithms which walk the face
        * list will not see the newly created faces.
        */
        // static void MakeFace( TESSface *newFace, TESShalfEdge *eOrig, TESSface *fNext )
        makeFace_: function(d, b, t) {
          var m = d;
          W(m !== null);
          var R = t.prev;
          m.prev = R, R.next = m, m.next = t, t.prev = m, m.anEdge = b, m.trail = null, m.marked = !1, m.inside = t.inside;
          var S = b;
          do
            S.Lface = m, S = S.Lnext;
          while (S !== b);
        },
        /* KillEdge( eDel ) destroys an edge (the half-edges eDel and eDel->Sym),
        * and removes from the global edge list.
        */
        //static void KillEdge( TESSmesh *mesh, TESShalfEdge *eDel )
        killEdge_: function(d) {
          d.Sym.side < d.side && (d = d.Sym);
          var b = d.next, t = d.Sym.next;
          b.Sym.next = t, t.Sym.next = b;
        },
        /* KillVertex( vDel ) destroys a vertex and removes it from the global
        * vertex list.  It updates the vertex loop to point to a given new vertex.
        */
        //static void KillVertex( TESSmesh *mesh, TESSvertex *vDel, TESSvertex *newOrg )
        killVertex_: function(d, b) {
          var t = d.anEdge, m = t;
          do
            m.Org = b, m = m.Onext;
          while (m !== t);
          var R = d.prev, S = d.next;
          S.prev = R, R.next = S;
        },
        /* KillFace( fDel ) destroys a face and removes it from the global face
        * list.  It updates the face loop to point to a given new face.
        */
        //static void KillFace( TESSmesh *mesh, TESSface *fDel, TESSface *newLface )
        killFace_: function(d, b) {
          var t = d.anEdge, m = t;
          do
            m.Lface = b, m = m.Lnext;
          while (m !== t);
          var R = d.prev, S = d.next;
          S.prev = R, R.next = S;
        },
        /****************** Basic Edge Operations **********************/
        /* tessMeshMakeEdge creates one edge, two vertices, and a loop (face).
        * The loop consists of the two new half-edges.
        */
        //TESShalfEdge *tessMeshMakeEdge( TESSmesh *mesh )
        makeEdge: function() {
          var d = new h(), b = new h(), t = new e(), m = this.makeEdge_(this.eHead);
          return this.makeVertex_(d, m, this.vHead), this.makeVertex_(b, m.Sym, this.vHead), this.makeFace_(t, m, this.fHead), m;
        },
        /* tessMeshSplice( eOrg, eDst ) is the basic operation for changing the
        * mesh connectivity and topology.  It changes the mesh so that
        *	eOrg->Onext <- OLD( eDst->Onext )
        *	eDst->Onext <- OLD( eOrg->Onext )
        * where OLD(...) means the value before the meshSplice operation.
        *
        * This can have two effects on the vertex structure:
        *  - if eOrg->Org != eDst->Org, the two vertices are merged together
        *  - if eOrg->Org == eDst->Org, the origin is split into two vertices
        * In both cases, eDst->Org is changed and eOrg->Org is untouched.
        *
        * Similarly (and independently) for the face structure,
        *  - if eOrg->Lface == eDst->Lface, one loop is split into two
        *  - if eOrg->Lface != eDst->Lface, two distinct loops are joined into one
        * In both cases, eDst->Lface is changed and eOrg->Lface is unaffected.
        *
        * Some special cases:
        * If eDst == eOrg, the operation has no effect.
        * If eDst == eOrg->Lnext, the new face will have a single edge.
        * If eDst == eOrg->Lprev, the old face will have a single edge.
        * If eDst == eOrg->Onext, the new vertex will have a single edge.
        * If eDst == eOrg->Oprev, the old vertex will have a single edge.
        */
        //int tessMeshSplice( TESSmesh* mesh, TESShalfEdge *eOrg, TESShalfEdge *eDst )
        splice: function(d, b) {
          var t = !1, m = !1;
          if (d !== b) {
            if (b.Org !== d.Org && (m = !0, this.killVertex_(b.Org, d.Org)), b.Lface !== d.Lface && (t = !0, this.killFace_(b.Lface, d.Lface)), this.splice_(b, d), !m) {
              var R = new h();
              this.makeVertex_(R, b, d.Org), d.Org.anEdge = d;
            }
            if (!t) {
              var S = new e();
              this.makeFace_(S, b, d.Lface), d.Lface.anEdge = d;
            }
          }
        },
        /* tessMeshDelete( eDel ) removes the edge eDel.  There are several cases:
        * if (eDel->Lface != eDel->Rface), we join two loops into one; the loop
        * eDel->Lface is deleted.  Otherwise, we are splitting one loop into two;
        * the newly created loop will contain eDel->Dst.  If the deletion of eDel
        * would create isolated vertices, those are deleted as well.
        *
        * This function could be implemented as two calls to tessMeshSplice
        * plus a few calls to memFree, but this would allocate and delete
        * unnecessary vertices and faces.
        */
        //int tessMeshDelete( TESSmesh *mesh, TESShalfEdge *eDel )
        delete: function(d) {
          var b = d.Sym, t = !1;
          if (d.Lface !== d.Rface && (t = !0, this.killFace_(d.Lface, d.Rface)), d.Onext === d)
            this.killVertex_(d.Org, null);
          else if (d.Rface.anEdge = d.Oprev, d.Org.anEdge = d.Onext, this.splice_(d, d.Oprev), !t) {
            var m = new e();
            this.makeFace_(m, d, d.Lface);
          }
          b.Onext === b ? (this.killVertex_(b.Org, null), this.killFace_(b.Lface, null)) : (d.Lface.anEdge = b.Oprev, b.Org.anEdge = b.Onext, this.splice_(b, b.Oprev)), this.killEdge_(d);
        },
        /******************** Other Edge Operations **********************/
        /* All these routines can be implemented with the basic edge
        * operations above.  They are provided for convenience and efficiency.
        */
        /* tessMeshAddEdgeVertex( eOrg ) creates a new edge eNew such that
        * eNew == eOrg->Lnext, and eNew->Dst is a newly created vertex.
        * eOrg and eNew will have the same left face.
        */
        // TESShalfEdge *tessMeshAddEdgeVertex( TESSmesh *mesh, TESShalfEdge *eOrg );
        addEdgeVertex: function(d) {
          var b = this.makeEdge_(d), t = b.Sym;
          this.splice_(b, d.Lnext), b.Org = d.Dst;
          var m = new h();
          return this.makeVertex_(m, t, b.Org), b.Lface = t.Lface = d.Lface, b;
        },
        /* tessMeshSplitEdge( eOrg ) splits eOrg into two edges eOrg and eNew,
        * such that eNew == eOrg->Lnext.  The new vertex is eOrg->Dst == eNew->Org.
        * eOrg and eNew will have the same left face.
        */
        // TESShalfEdge *tessMeshSplitEdge( TESSmesh *mesh, TESShalfEdge *eOrg );
        splitEdge: function(d, b) {
          var t = this.addEdgeVertex(d), m = t.Sym;
          return this.splice_(d.Sym, d.Sym.Oprev), this.splice_(d.Sym, m), d.Dst = m.Org, m.Dst.anEdge = m.Sym, m.Rface = d.Rface, m.winding = d.winding, m.Sym.winding = d.Sym.winding, m;
        },
        /* tessMeshConnect( eOrg, eDst ) creates a new edge from eOrg->Dst
        * to eDst->Org, and returns the corresponding half-edge eNew.
        * If eOrg->Lface == eDst->Lface, this splits one loop into two,
        * and the newly created loop is eNew->Lface.  Otherwise, two disjoint
        * loops are merged into one, and the loop eDst->Lface is destroyed.
        *
        * If (eOrg == eDst), the new face will have only two edges.
        * If (eOrg->Lnext == eDst), the old face is reduced to a single edge.
        * If (eOrg->Lnext->Lnext == eDst), the old face is reduced to two edges.
        */
        // TESShalfEdge *tessMeshConnect( TESSmesh *mesh, TESShalfEdge *eOrg, TESShalfEdge *eDst );
        connect: function(d, b) {
          var t = !1, m = this.makeEdge_(d), R = m.Sym;
          if (b.Lface !== d.Lface && (t = !0, this.killFace_(b.Lface, d.Lface)), this.splice_(m, d.Lnext), this.splice_(R, b), m.Org = d.Dst, R.Org = b.Org, m.Lface = R.Lface = d.Lface, d.Lface.anEdge = R, !t) {
            var S = new e();
            this.makeFace_(S, m, d.Lface);
          }
          return m;
        },
        /* tessMeshZapFace( fZap ) destroys a face and removes it from the
        * global face list.  All edges of fZap will have a NULL pointer as their
        * left face.  Any edges which also have a NULL pointer as their right face
        * are deleted entirely (along with any isolated vertices this produces).
        * An entire mesh can be deleted by zapping its faces, one at a time,
        * in any order.  Zapped faces cannot be used in further mesh operations!
        */
        zapFace: function(d) {
          var b = d.anEdge, t, m, R, S, C;
          m = b.Lnext;
          do
            t = m, m = t.Lnext, t.Lface = null, t.Rface === null && (t.Onext === t ? this.killVertex_(t.Org, null) : (t.Org.anEdge = t.Onext, this.splice_(t, t.Oprev)), R = t.Sym, R.Onext === R ? this.killVertex_(R.Org, null) : (R.Org.anEdge = R.Onext, this.splice_(R, R.Oprev)), this.killEdge_(t));
          while (t != b);
          S = d.prev, C = d.next, C.prev = S, S.next = C;
        },
        countFaceVerts_: function(d) {
          var b = d.anEdge, t = 0;
          do
            t++, b = b.Lnext;
          while (b !== d.anEdge);
          return t;
        },
        //int tessMeshMergeConvexFaces( TESSmesh *mesh, int maxVertsPerFace )
        mergeConvexFaces: function(d) {
          var b, t, m, R, S, C, F;
          for (b = this.fHead.next; b !== this.fHead; b = b.next)
            if (b.inside)
              for (t = b.anEdge, S = t.Org; m = t.Lnext, R = t.Sym, R && R.Lface && R.Lface.inside && (C = this.countFaceVerts_(b), F = this.countFaceVerts_(R.Lface), C + F - 2 <= d && c.vertCCW(t.Lprev.Org, t.Org, R.Lnext.Lnext.Org) && c.vertCCW(R.Lprev.Org, R.Org, t.Lnext.Lnext.Org) && (m = R.Lnext, this.delete(R), t = null, R = null)), !(t && t.Lnext.Org === S); )
                t = m;
          return !0;
        },
        /* tessMeshCheckMesh( mesh ) checks a mesh for self-consistency.
        */
        check: function() {
          var d = this.fHead, b = this.vHead, t = this.eHead, m, R, S, C, F, K;
          for (R = d, R = d; (m = R.next) !== d; R = m) {
            W(m.prev === R), F = m.anEdge;
            do
              W(F.Sym !== F), W(F.Sym.Sym === F), W(F.Lnext.Onext.Sym === F), W(F.Onext.Sym.Lnext === F), W(F.Lface === m), F = F.Lnext;
            while (F !== m.anEdge);
          }
          for (W(m.prev === R && m.anEdge === null), C = b, C = b; (S = C.next) !== b; C = S) {
            W(S.prev === C), F = S.anEdge;
            do
              W(F.Sym !== F), W(F.Sym.Sym === F), W(F.Lnext.Onext.Sym === F), W(F.Onext.Sym.Lnext === F), W(F.Org === S), F = F.Onext;
            while (F !== S.anEdge);
          }
          for (W(S.prev === C && S.anEdge === null), K = t, K = t; (F = K.next) !== t; K = F)
            W(F.Sym.next === K.Sym), W(F.Sym !== F), W(F.Sym.Sym === F), W(F.Org !== null), W(F.Dst !== null), W(F.Lnext.Onext.Sym === F), W(F.Onext.Sym.Lnext === F);
          W(F.Sym.next === K.Sym && F.Sym === this.eHeadSym && F.Sym.Sym === F && F.Org === null && F.Dst === null && F.Lface === null && F.Rface === null);
        }
      }, c.vertEq = function(d, b) {
        return d.s === b.s && d.t === b.t;
      }, c.vertLeq = function(d, b) {
        return d.s < b.s || d.s === b.s && d.t <= b.t;
      }, c.transLeq = function(d, b) {
        return d.t < b.t || d.t === b.t && d.s <= b.s;
      }, c.edgeGoesLeft = function(d) {
        return c.vertLeq(d.Dst, d.Org);
      }, c.edgeGoesRight = function(d) {
        return c.vertLeq(d.Org, d.Dst);
      }, c.vertL1dist = function(d, b) {
        return Math.abs(d.s - b.s) + Math.abs(d.t - b.t);
      }, c.edgeEval = function(d, b, t) {
        W(c.vertLeq(d, b) && c.vertLeq(b, t));
        var m = b.s - d.s, R = t.s - b.s;
        return m + R > 0 ? m < R ? b.t - d.t + (d.t - t.t) * (m / (m + R)) : b.t - t.t + (t.t - d.t) * (R / (m + R)) : 0;
      }, c.edgeSign = function(d, b, t) {
        W(c.vertLeq(d, b) && c.vertLeq(b, t));
        var m = b.s - d.s, R = t.s - b.s;
        return m + R > 0 ? (b.t - t.t) * m + (b.t - d.t) * R : 0;
      }, c.transEval = function(d, b, t) {
        W(c.transLeq(d, b) && c.transLeq(b, t));
        var m = b.t - d.t, R = t.t - b.t;
        return m + R > 0 ? m < R ? b.s - d.s + (d.s - t.s) * (m / (m + R)) : b.s - t.s + (t.s - d.s) * (R / (m + R)) : 0;
      }, c.transSign = function(d, b, t) {
        W(c.transLeq(d, b) && c.transLeq(b, t));
        var m = b.t - d.t, R = t.t - b.t;
        return m + R > 0 ? (b.s - t.s) * m + (b.s - d.s) * R : 0;
      }, c.vertCCW = function(d, b, t) {
        return d.s * (b.t - t.t) + b.s * (t.t - d.t) + t.s * (d.t - b.t) >= 0;
      }, c.interpolate = function(d, b, t, m) {
        return d = d < 0 ? 0 : d, t = t < 0 ? 0 : t, d <= t ? t === 0 ? (b + m) / 2 : b + (m - b) * (d / (d + t)) : m + (b - m) * (t / (d + t));
      }, c.intersect = function(d, b, t, m, R) {
        var S, C, F;
        c.vertLeq(d, b) || (F = d, d = b, b = F), c.vertLeq(t, m) || (F = t, t = m, m = F), c.vertLeq(d, t) || (F = d, d = t, t = F, F = b, b = m, m = F), c.vertLeq(t, b) ? c.vertLeq(b, m) ? (S = c.edgeEval(d, t, b), C = c.edgeEval(t, b, m), S + C < 0 && (S = -S, C = -C), R.s = c.interpolate(S, t.s, C, b.s)) : (S = c.edgeSign(d, t, b), C = -c.edgeSign(d, m, b), S + C < 0 && (S = -S, C = -C), R.s = c.interpolate(S, t.s, C, m.s)) : R.s = (t.s + b.s) / 2, c.transLeq(d, b) || (F = d, d = b, b = F), c.transLeq(t, m) || (F = t, t = m, m = F), c.transLeq(d, t) || (F = d, d = t, t = F, F = b, b = m, m = F), c.transLeq(t, b) ? c.transLeq(b, m) ? (S = c.transEval(d, t, b), C = c.transEval(t, b, m), S + C < 0 && (S = -S, C = -C), R.t = c.interpolate(S, t.t, C, b.t)) : (S = c.transSign(d, t, b), C = -c.transSign(d, m, b), S + C < 0 && (S = -S, C = -C), R.t = c.interpolate(S, t.t, C, m.t)) : R.t = (t.t + b.t) / 2;
      };
      function y() {
        this.key = null, this.next = null, this.prev = null;
      }
      function n(d, b) {
        this.head = new y(), this.head.next = this.head, this.head.prev = this.head, this.frame = d, this.leq = b;
      }
      n.prototype = {
        min: function() {
          return this.head.next;
        },
        max: function() {
          return this.head.prev;
        },
        insert: function(d) {
          return this.insertBefore(this.head, d);
        },
        search: function(d) {
          var b = this.head;
          do
            b = b.next;
          while (b.key !== null && !this.leq(this.frame, d, b.key));
          return b;
        },
        insertBefore: function(d, b) {
          do
            d = d.prev;
          while (d.key !== null && !this.leq(this.frame, d.key, b));
          var t = new y();
          return t.key = b, t.next = d.next, d.next.prev = t, t.prev = d, d.next = t, t;
        },
        delete: function(d) {
          d.next.prev = d.prev, d.prev.next = d.next;
        }
      };
      function V() {
        this.handle = null;
      }
      function I() {
        this.key = null, this.node = null;
      }
      function r(d, b) {
        this.size = 0, this.max = d, this.nodes = [], this.nodes.length = d + 1;
        var t;
        for (t = 0; t < this.nodes.length; t++)
          this.nodes[t] = new V();
        for (this.handles = [], this.handles.length = d + 1, t = 0; t < this.handles.length; t++)
          this.handles[t] = new I();
        this.initialized = !1, this.freeList = 0, this.leq = b, this.nodes[1].handle = 1, this.handles[1].key = null;
      }
      r.prototype = {
        floatDown_: function(d) {
          var b = this.nodes, t = this.handles, m, R, S;
          for (m = b[d].handle; ; ) {
            if (S = d << 1, S < this.size && this.leq(t[b[S + 1].handle].key, t[b[S].handle].key) && ++S, W(S <= this.max), R = b[S].handle, S > this.size || this.leq(t[m].key, t[R].key)) {
              b[d].handle = m, t[m].node = d;
              break;
            }
            b[d].handle = R, t[R].node = d, d = S;
          }
        },
        floatUp_: function(d) {
          var b = this.nodes, t = this.handles, m, R, S;
          for (m = b[d].handle; ; ) {
            if (S = d >> 1, R = b[S].handle, S === 0 || this.leq(t[R].key, t[m].key)) {
              b[d].handle = m, t[m].node = d;
              break;
            }
            b[d].handle = R, t[R].node = d, d = S;
          }
        },
        init: function() {
          for (var d = this.size; d >= 1; --d)
            this.floatDown_(d);
          this.initialized = !0;
        },
        min: function() {
          return this.handles[this.nodes[1].handle].key;
        },
        /* really pqHeapInsert */
        /* returns INV_HANDLE iff out of memory */
        //PQhandle pqHeapInsert( TESSalloc* alloc, PriorityQHeap *pq, PQkey keyNew )
        insert: function(d) {
          var b, t;
          if (b = ++this.size, b * 2 > this.max) {
            this.max *= 2;
            var m, R;
            for (R = this.nodes.length, this.nodes.length = this.max + 1, m = R; m < this.nodes.length; m++)
              this.nodes[m] = new V();
            for (R = this.handles.length, this.handles.length = this.max + 1, m = R; m < this.handles.length; m++)
              this.handles[m] = new I();
          }
          return this.freeList === 0 ? t = b : (t = this.freeList, this.freeList = this.handles[t].node), this.nodes[b].handle = t, this.handles[t].node = b, this.handles[t].key = d, this.initialized && this.floatUp_(b), t;
        },
        //PQkey pqHeapExtractMin( PriorityQHeap *pq )
        extractMin: function() {
          var d = this.nodes, b = this.handles, t = d[1].handle, m = b[t].key;
          return this.size > 0 && (d[1].handle = d[this.size].handle, b[d[1].handle].node = 1, b[t].key = null, b[t].node = this.freeList, this.freeList = t, --this.size, this.size > 0 && this.floatDown_(1)), m;
        },
        delete: function(d) {
          var b = this.nodes, t = this.handles, m;
          W(d >= 1 && d <= this.max && t[d].key !== null), m = t[d].node, b[m].handle = b[this.size].handle, t[b[m].handle].node = m, --this.size, m <= this.size && (m <= 1 || this.leq(t[b[m >> 1].handle].key, t[b[m].handle].key) ? this.floatDown_(m) : this.floatUp_(m)), t[d].key = null, t[d].node = this.freeList, this.freeList = d;
        }
      };
      function p() {
        this.eUp = null, this.nodeUp = null, this.windingNumber = 0, this.inside = !1, this.sentinel = !1, this.dirty = !1, this.fixUpperEdge = !1;
      }
      var o = {};
      o.regionBelow = function(d) {
        return d.nodeUp.prev.key;
      }, o.regionAbove = function(d) {
        return d.nodeUp.next.key;
      }, o.debugEvent = function(d) {
      }, o.addWinding = function(d, b) {
        d.winding += b.winding, d.Sym.winding += b.Sym.winding;
      }, o.edgeLeq = function(d, b, t) {
        var m = d.event, C, F, R = b.eUp, S = t.eUp;
        if (R.Dst === m)
          return S.Dst === m ? c.vertLeq(R.Org, S.Org) ? c.edgeSign(S.Dst, R.Org, S.Org) <= 0 : c.edgeSign(R.Dst, S.Org, R.Org) >= 0 : c.edgeSign(S.Dst, m, S.Org) <= 0;
        if (S.Dst === m)
          return c.edgeSign(R.Dst, m, R.Org) >= 0;
        var C = c.edgeEval(R.Dst, m, R.Org), F = c.edgeEval(S.Dst, m, S.Org);
        return C >= F;
      }, o.deleteRegion = function(d, b) {
        b.fixUpperEdge && W(b.eUp.winding === 0), b.eUp.activeRegion = null, d.dict.delete(b.nodeUp);
      }, o.fixUpperEdge = function(d, b, t) {
        W(b.fixUpperEdge), d.mesh.delete(b.eUp), b.fixUpperEdge = !1, b.eUp = t, t.activeRegion = b;
      }, o.topLeftRegion = function(d, b) {
        var t = b.eUp.Org, m;
        do
          b = o.regionAbove(b);
        while (b.eUp.Org === t);
        if (b.fixUpperEdge) {
          if (m = d.mesh.connect(o.regionBelow(b).eUp.Sym, b.eUp.Lnext), m === null)
            return null;
          o.fixUpperEdge(d, b, m), b = o.regionAbove(b);
        }
        return b;
      }, o.topRightRegion = function(d) {
        var b = d.eUp.Dst;
        do
          d = o.regionAbove(d);
        while (d.eUp.Dst === b);
        return d;
      }, o.addRegionBelow = function(d, b, t) {
        var m = new p();
        return m.eUp = t, m.nodeUp = d.dict.insertBefore(b.nodeUp, m), m.fixUpperEdge = !1, m.sentinel = !1, m.dirty = !1, t.activeRegion = m, m;
      }, o.isWindingInside = function(d, b) {
        switch (d.windingRule) {
          case s.WINDING_ODD:
            return (b & 1) !== 0;
          case s.WINDING_NONZERO:
            return b !== 0;
          case s.WINDING_POSITIVE:
            return b > 0;
          case s.WINDING_NEGATIVE:
            return b < 0;
          case s.WINDING_ABS_GEQ_TWO:
            return b >= 2 || b <= -2;
        }
        return W(!1), !1;
      }, o.computeWinding = function(d, b) {
        b.windingNumber = o.regionAbove(b).windingNumber + b.eUp.winding, b.inside = o.isWindingInside(d, b.windingNumber);
      }, o.finishRegion = function(d, b) {
        var t = b.eUp, m = t.Lface;
        m.inside = b.inside, m.anEdge = t, o.deleteRegion(d, b);
      }, o.finishLeftRegions = function(d, b, t) {
        for (var m, C, R = null, S = b, C = b.eUp; S !== t; ) {
          if (S.fixUpperEdge = !1, R = o.regionBelow(S), m = R.eUp, m.Org != C.Org) {
            if (!R.fixUpperEdge) {
              o.finishRegion(d, S);
              break;
            }
            m = d.mesh.connect(C.Lprev, m.Sym), o.fixUpperEdge(d, R, m);
          }
          C.Onext !== m && (d.mesh.splice(m.Oprev, m), d.mesh.splice(C, m)), o.finishRegion(d, S), C = R.eUp, S = R;
        }
        return C;
      }, o.addRightEdges = function(d, b, t, m, R, S) {
        var C, F, K, J, T = !0;
        K = t;
        do
          W(c.vertLeq(K.Org, K.Dst)), o.addRegionBelow(d, b, K.Sym), K = K.Onext;
        while (K !== m);
        for (R === null && (R = o.regionBelow(b).eUp.Rprev), F = b, J = R; C = o.regionBelow(F), K = C.eUp.Sym, K.Org === J.Org; )
          K.Onext !== J && (d.mesh.splice(K.Oprev, K), d.mesh.splice(J.Oprev, K)), C.windingNumber = F.windingNumber - K.winding, C.inside = o.isWindingInside(d, C.windingNumber), F.dirty = !0, !T && o.checkForRightSplice(d, F) && (o.addWinding(K, J), o.deleteRegion(d, F), d.mesh.delete(J)), T = !1, F = C, J = K;
        F.dirty = !0, W(F.windingNumber - K.winding === C.windingNumber), S && o.walkDirtyRegions(d, F);
      }, o.spliceMergeVertices = function(d, b, t) {
        d.mesh.splice(b, t);
      }, o.vertexWeights = function(d, b, t) {
        var m = c.vertL1dist(b, d), R = c.vertL1dist(t, d), S = 0.5 * R / (m + R), C = 0.5 * m / (m + R);
        d.coords[0] += S * b.coords[0] + C * t.coords[0], d.coords[1] += S * b.coords[1] + C * t.coords[1], d.coords[2] += S * b.coords[2] + C * t.coords[2];
      }, o.getIntersectData = function(d, b, t, m, R, S) {
        b.coords[0] = b.coords[1] = b.coords[2] = 0, b.idx = -1, o.vertexWeights(b, t, m), o.vertexWeights(b, R, S);
      }, o.checkForRightSplice = function(d, b) {
        var t = o.regionBelow(b), m = b.eUp, R = t.eUp;
        if (c.vertLeq(m.Org, R.Org)) {
          if (c.edgeSign(R.Dst, m.Org, R.Org) > 0)
            return !1;
          c.vertEq(m.Org, R.Org) ? m.Org !== R.Org && (d.pq.delete(m.Org.pqHandle), o.spliceMergeVertices(d, R.Oprev, m)) : (d.mesh.splitEdge(R.Sym), d.mesh.splice(m, R.Oprev), b.dirty = t.dirty = !0);
        } else {
          if (c.edgeSign(m.Dst, R.Org, m.Org) < 0)
            return !1;
          o.regionAbove(b).dirty = b.dirty = !0, d.mesh.splitEdge(m.Sym), d.mesh.splice(R.Oprev, m);
        }
        return !0;
      }, o.checkForLeftSplice = function(d, b) {
        var t = o.regionBelow(b), m = b.eUp, R = t.eUp, S;
        if (W(!c.vertEq(m.Dst, R.Dst)), c.vertLeq(m.Dst, R.Dst)) {
          if (c.edgeSign(m.Dst, R.Dst, m.Org) < 0)
            return !1;
          o.regionAbove(b).dirty = b.dirty = !0, S = d.mesh.splitEdge(m), d.mesh.splice(R.Sym, S), S.Lface.inside = b.inside;
        } else {
          if (c.edgeSign(R.Dst, m.Dst, R.Org) > 0)
            return !1;
          b.dirty = t.dirty = !0, S = d.mesh.splitEdge(R), d.mesh.splice(m.Lnext, R.Sym), S.Rface.inside = b.inside;
        }
        return !0;
      }, o.checkForIntersect = function(d, b) {
        var t = o.regionBelow(b), m = b.eUp, R = t.eUp, S = m.Org, C = R.Org, F = m.Dst, K = R.Dst, J, T, Y = new h(), x, H;
        if (W(!c.vertEq(K, F)), W(c.edgeSign(F, d.event, S) <= 0), W(c.edgeSign(K, d.event, C) >= 0), W(S !== d.event && C !== d.event), W(!b.fixUpperEdge && !t.fixUpperEdge), S === C || (J = Math.min(S.t, F.t), T = Math.max(C.t, K.t), J > T))
          return !1;
        if (c.vertLeq(S, C)) {
          if (c.edgeSign(K, S, C) > 0)
            return !1;
        } else if (c.edgeSign(F, C, S) < 0)
          return !1;
        return o.debugEvent(d), c.intersect(F, S, K, C, Y), W(Math.min(S.t, F.t) <= Y.t), W(Y.t <= Math.max(C.t, K.t)), W(Math.min(K.s, F.s) <= Y.s), W(Y.s <= Math.max(C.s, S.s)), c.vertLeq(Y, d.event) && (Y.s = d.event.s, Y.t = d.event.t), x = c.vertLeq(S, C) ? S : C, c.vertLeq(x, Y) && (Y.s = x.s, Y.t = x.t), c.vertEq(Y, S) || c.vertEq(Y, C) ? (o.checkForRightSplice(d, b), !1) : !c.vertEq(F, d.event) && c.edgeSign(F, d.event, Y) >= 0 || !c.vertEq(K, d.event) && c.edgeSign(K, d.event, Y) <= 0 ? K === d.event ? (d.mesh.splitEdge(m.Sym), d.mesh.splice(R.Sym, m), b = o.topLeftRegion(d, b), m = o.regionBelow(b).eUp, o.finishLeftRegions(d, o.regionBelow(b), t), o.addRightEdges(d, b, m.Oprev, m, m, !0), !0) : F === d.event ? (d.mesh.splitEdge(R.Sym), d.mesh.splice(m.Lnext, R.Oprev), t = b, b = o.topRightRegion(b), H = o.regionBelow(b).eUp.Rprev, t.eUp = R.Oprev, R = o.finishLeftRegions(d, t, null), o.addRightEdges(d, b, R.Onext, m.Rprev, H, !0), !0) : (c.edgeSign(F, d.event, Y) >= 0 && (o.regionAbove(b).dirty = b.dirty = !0, d.mesh.splitEdge(m.Sym), m.Org.s = d.event.s, m.Org.t = d.event.t), c.edgeSign(K, d.event, Y) <= 0 && (b.dirty = t.dirty = !0, d.mesh.splitEdge(R.Sym), R.Org.s = d.event.s, R.Org.t = d.event.t), !1) : (d.mesh.splitEdge(m.Sym), d.mesh.splitEdge(R.Sym), d.mesh.splice(R.Oprev, m), m.Org.s = Y.s, m.Org.t = Y.t, m.Org.pqHandle = d.pq.insert(m.Org), o.getIntersectData(d, m.Org, S, F, C, K), o.regionAbove(b).dirty = b.dirty = t.dirty = !0, !1);
      }, o.walkDirtyRegions = function(d, b) {
        for (var t = o.regionBelow(b), m, R; ; ) {
          for (; t.dirty; )
            b = t, t = o.regionBelow(t);
          if (!b.dirty && (t = b, b = o.regionAbove(b), b === null || !b.dirty))
            return;
          if (b.dirty = !1, m = b.eUp, R = t.eUp, m.Dst !== R.Dst && o.checkForLeftSplice(d, b) && (t.fixUpperEdge ? (o.deleteRegion(d, t), d.mesh.delete(R), t = o.regionBelow(b), R = t.eUp) : b.fixUpperEdge && (o.deleteRegion(d, b), d.mesh.delete(m), b = o.regionAbove(t), m = b.eUp)), m.Org !== R.Org)
            if (m.Dst !== R.Dst && !b.fixUpperEdge && !t.fixUpperEdge && (m.Dst === d.event || R.Dst === d.event)) {
              if (o.checkForIntersect(d, b))
                return;
            } else
              o.checkForRightSplice(d, b);
          m.Org === R.Org && m.Dst === R.Dst && (o.addWinding(R, m), o.deleteRegion(d, b), d.mesh.delete(m), b = o.regionAbove(t));
        }
      }, o.connectRightVertex = function(d, b, t) {
        var m, R = t.Onext, S = o.regionBelow(b), C = b.eUp, F = S.eUp, K = !1;
        if (C.Dst !== F.Dst && o.checkForIntersect(d, b), c.vertEq(C.Org, d.event) && (d.mesh.splice(R.Oprev, C), b = o.topLeftRegion(d, b), R = o.regionBelow(b).eUp, o.finishLeftRegions(d, o.regionBelow(b), S), K = !0), c.vertEq(F.Org, d.event) && (d.mesh.splice(t, F.Oprev), t = o.finishLeftRegions(d, S, null), K = !0), K) {
          o.addRightEdges(d, b, t.Onext, R, R, !0);
          return;
        }
        c.vertLeq(F.Org, C.Org) ? m = F.Oprev : m = C, m = d.mesh.connect(t.Lprev, m), o.addRightEdges(d, b, m, m.Onext, m.Onext, !1), m.Sym.activeRegion.fixUpperEdge = !0, o.walkDirtyRegions(d, b);
      }, o.connectLeftDegenerate = function(d, b, t) {
        var m, R, S, C, F;
        if (m = b.eUp, c.vertEq(m.Org, t)) {
          W(
            !1
            /*TOLERANCE_NONZERO*/
          ), o.spliceMergeVertices(d, m, t.anEdge);
          return;
        }
        if (!c.vertEq(m.Dst, t)) {
          d.mesh.splitEdge(m.Sym), b.fixUpperEdge && (d.mesh.delete(m.Onext), b.fixUpperEdge = !1), d.mesh.splice(t.anEdge, m), o.sweepEvent(d, t);
          return;
        }
        W(
          !1
          /*TOLERANCE_NONZERO*/
        ), b = o.topRightRegion(b), F = o.regionBelow(b), S = F.eUp.Sym, R = C = S.Onext, F.fixUpperEdge && (W(R !== S), o.deleteRegion(d, F), d.mesh.delete(S), S = R.Oprev), d.mesh.splice(t.anEdge, S), c.edgeGoesLeft(R) || (R = null), o.addRightEdges(d, b, S.Onext, C, R, !0);
      }, o.connectLeftVertex = function(d, b) {
        var t, m, R, S, C, F, K = new p();
        if (K.eUp = b.anEdge.Sym, t = d.dict.search(K).key, m = o.regionBelow(t), !!m) {
          if (S = t.eUp, C = m.eUp, c.edgeSign(S.Dst, b, S.Org) === 0) {
            o.connectLeftDegenerate(d, t, b);
            return;
          }
          if (R = c.vertLeq(C.Dst, S.Dst) ? t : m, t.inside || R.fixUpperEdge) {
            if (R === t)
              F = d.mesh.connect(b.anEdge.Sym, S.Lnext);
            else {
              var J = d.mesh.connect(C.Dnext, b.anEdge);
              F = J.Sym;
            }
            R.fixUpperEdge ? o.fixUpperEdge(d, R, F) : o.computeWinding(d, o.addRegionBelow(d, t, F)), o.sweepEvent(d, b);
          } else
            o.addRightEdges(d, t, b.anEdge, b.anEdge, null, !0);
        }
      }, o.sweepEvent = function(d, b) {
        d.event = b, o.debugEvent(d);
        for (var t = b.anEdge; t.activeRegion === null; )
          if (t = t.Onext, t === b.anEdge) {
            o.connectLeftVertex(d, b);
            return;
          }
        var m = o.topLeftRegion(d, t.activeRegion);
        W(m !== null);
        var R = o.regionBelow(m), S = R.eUp, C = o.finishLeftRegions(d, R, null);
        C.Onext === S ? o.connectRightVertex(d, m, C) : o.addRightEdges(d, m, C.Onext, S, S, !0);
      }, o.addSentinel = function(d, b, t, m) {
        var R = new p(), S = d.mesh.makeEdge();
        S.Org.s = t, S.Org.t = m, S.Dst.s = b, S.Dst.t = m, d.event = S.Dst, R.eUp = S, R.windingNumber = 0, R.inside = !1, R.fixUpperEdge = !1, R.sentinel = !0, R.dirty = !1, R.nodeUp = d.dict.insert(R);
      }, o.initEdgeDict = function(d) {
        d.dict = new n(d, o.edgeLeq);
        var b = d.bmax[0] - d.bmin[0], t = d.bmax[1] - d.bmin[1], m = d.bmin[0] - b, R = d.bmax[0] + b, S = d.bmin[1] - t, C = d.bmax[1] + t;
        o.addSentinel(d, m, R, S), o.addSentinel(d, m, R, C);
      }, o.doneEdgeDict = function(d) {
        for (var b, t = 0; (b = d.dict.min().key) !== null; )
          b.sentinel || (W(b.fixUpperEdge), W(++t === 1)), W(b.windingNumber === 0), o.deleteRegion(d, b);
      }, o.removeDegenerateEdges = function(d) {
        var b, t, m, R = d.mesh.eHead;
        for (b = R.next; b !== R; b = t)
          t = b.next, m = b.Lnext, c.vertEq(b.Org, b.Dst) && b.Lnext.Lnext !== b && (o.spliceMergeVertices(d, m, b), d.mesh.delete(b), b = m, m = b.Lnext), m.Lnext === b && (m !== b && ((m === t || m === t.Sym) && (t = t.next), d.mesh.delete(m)), (b === t || b === t.Sym) && (t = t.next), d.mesh.delete(b));
      }, o.initPriorityQ = function(d) {
        var b, t, m, R = 0;
        for (m = d.mesh.vHead, t = m.next; t !== m; t = t.next)
          R++;
        for (R += 8, b = d.pq = new r(R, c.vertLeq), m = d.mesh.vHead, t = m.next; t !== m; t = t.next)
          t.pqHandle = b.insert(t);
        return t !== m ? !1 : (b.init(), !0);
      }, o.donePriorityQ = function(d) {
        d.pq = null;
      }, o.removeDegenerateFaces = function(d, b) {
        var t, m, R;
        for (t = b.fHead.next; t !== b.fHead; t = m)
          m = t.next, R = t.anEdge, W(R.Lnext !== R), R.Lnext.Lnext === R && (o.addWinding(R.Onext, R), d.mesh.delete(R));
        return !0;
      }, o.computeInterior = function(d) {
        var b, t;
        if (o.removeDegenerateEdges(d), !o.initPriorityQ(d))
          return !1;
        for (o.initEdgeDict(d); (b = d.pq.extractMin()) !== null; ) {
          for (; t = d.pq.min(), !(t === null || !c.vertEq(t, b)); )
            t = d.pq.extractMin(), o.spliceMergeVertices(d, b.anEdge, t.anEdge);
          o.sweepEvent(d, b);
        }
        return d.event = d.dict.min().key.eUp.Org, o.debugEvent(d), o.doneEdgeDict(d), o.donePriorityQ(d), o.removeDegenerateFaces(d, d.mesh) ? (d.mesh.check(), !0) : !1;
      };
      function u() {
        this.mesh = null, this.normal = [0, 0, 0], this.sUnit = [0, 0, 0], this.tUnit = [0, 0, 0], this.bmin = [0, 0], this.bmax = [0, 0], this.windingRule = s.WINDING_ODD, this.dict = null, this.pq = null, this.event = null, this.vertexIndexCounter = 0, this.vertices = [], this.vertexIndices = [], this.vertexCount = 0, this.elements = [], this.elementCount = 0;
      }
      u.prototype = {
        dot_: function(d, b) {
          return d[0] * b[0] + d[1] * b[1] + d[2] * b[2];
        },
        normalize_: function(d) {
          var b = d[0] * d[0] + d[1] * d[1] + d[2] * d[2];
          W(b > 0), b = Math.sqrt(b), d[0] /= b, d[1] /= b, d[2] /= b;
        },
        longAxis_: function(d) {
          var b = 0;
          return Math.abs(d[1]) > Math.abs(d[0]) && (b = 1), Math.abs(d[2]) > Math.abs(d[b]) && (b = 2), b;
        },
        computeNormal_: function(d) {
          var b, t, m, R, S, C, F = [0, 0, 0], K = [0, 0, 0], J = [0, 0, 0], T = [0, 0, 0], Y = [0, 0, 0], x = [null, null, null], H = [null, null, null], Q = this.mesh.vHead, w;
          for (b = Q.next, w = 0; w < 3; ++w)
            R = b.coords[w], K[w] = R, H[w] = b, F[w] = R, x[w] = b;
          for (b = Q.next; b !== Q; b = b.next)
            for (w = 0; w < 3; ++w)
              R = b.coords[w], R < K[w] && (K[w] = R, H[w] = b), R > F[w] && (F[w] = R, x[w] = b);
          if (w = 0, F[1] - K[1] > F[0] - K[0] && (w = 1), F[2] - K[2] > F[w] - K[w] && (w = 2), K[w] >= F[w]) {
            d[0] = 0, d[1] = 0, d[2] = 1;
            return;
          }
          for (C = 0, t = H[w], m = x[w], J[0] = t.coords[0] - m.coords[0], J[1] = t.coords[1] - m.coords[1], J[2] = t.coords[2] - m.coords[2], b = Q.next; b !== Q; b = b.next)
            T[0] = b.coords[0] - m.coords[0], T[1] = b.coords[1] - m.coords[1], T[2] = b.coords[2] - m.coords[2], Y[0] = J[1] * T[2] - J[2] * T[1], Y[1] = J[2] * T[0] - J[0] * T[2], Y[2] = J[0] * T[1] - J[1] * T[0], S = Y[0] * Y[0] + Y[1] * Y[1] + Y[2] * Y[2], S > C && (C = S, d[0] = Y[0], d[1] = Y[1], d[2] = Y[2]);
          C <= 0 && (d[0] = d[1] = d[2] = 0, d[this.longAxis_(J)] = 1);
        },
        checkOrientation_: function() {
          var d, b, t = this.mesh.fHead, m, R = this.mesh.vHead, S;
          for (d = 0, b = t.next; b !== t; b = b.next)
            if (S = b.anEdge, !(S.winding <= 0))
              do
                d += (S.Org.s - S.Dst.s) * (S.Org.t + S.Dst.t), S = S.Lnext;
              while (S !== b.anEdge);
          if (d < 0) {
            for (m = R.next; m !== R; m = m.next)
              m.t = -m.t;
            this.tUnit[0] = -this.tUnit[0], this.tUnit[1] = -this.tUnit[1], this.tUnit[2] = -this.tUnit[2];
          }
        },
        /*	#ifdef FOR_TRITE_TEST_PROGRAM
          #include <stdlib.h>
          extern int RandomSweep;
          #define S_UNIT_X	(RandomSweep ? (2*drand48()-1) : 1.0)
          #define S_UNIT_Y	(RandomSweep ? (2*drand48()-1) : 0.0)
          #else
          #if defined(SLANTED_SWEEP) */
        /* The "feature merging" is not intended to be complete.  There are
        * special cases where edges are nearly parallel to the sweep line
        * which are not implemented.  The algorithm should still behave
        * robustly (ie. produce a reasonable tesselation) in the presence
        * of such edges, however it may miss features which could have been
        * merged.  We could minimize this effect by choosing the sweep line
        * direction to be something unusual (ie. not parallel to one of the
        * coordinate axes).
        */
        /*	#define S_UNIT_X	(TESSreal)0.50941539564955385	// Pre-normalized
          #define S_UNIT_Y	(TESSreal)0.86052074622010633
          #else
          #define S_UNIT_X	(TESSreal)1.0
          #define S_UNIT_Y	(TESSreal)0.0
          #endif
          #endif*/
        /* Determine the polygon normal and project vertices onto the plane
        * of the polygon.
        */
        projectPolygon_: function() {
          var d, b = this.mesh.vHead, t = [0, 0, 0], m, R, S, C, F = !1;
          for (t[0] = this.normal[0], t[1] = this.normal[1], t[2] = this.normal[2], t[0] === 0 && t[1] === 0 && t[2] === 0 && (this.computeNormal_(t), F = !0), m = this.sUnit, R = this.tUnit, S = this.longAxis_(t), m[S] = 0, m[(S + 1) % 3] = 1, m[(S + 2) % 3] = 0, R[S] = 0, R[(S + 1) % 3] = 0, R[(S + 2) % 3] = t[S] > 0 ? 1 : -1, d = b.next; d !== b; d = d.next)
            d.s = this.dot_(d.coords, m), d.t = this.dot_(d.coords, R);
          for (F && this.checkOrientation_(), C = !0, d = b.next; d !== b; d = d.next)
            C ? (this.bmin[0] = this.bmax[0] = d.s, this.bmin[1] = this.bmax[1] = d.t, C = !1) : (d.s < this.bmin[0] && (this.bmin[0] = d.s), d.s > this.bmax[0] && (this.bmax[0] = d.s), d.t < this.bmin[1] && (this.bmin[1] = d.t), d.t > this.bmax[1] && (this.bmax[1] = d.t));
        },
        addWinding_: function(d, b) {
          d.winding += b.winding, d.Sym.winding += b.Sym.winding;
        },
        /* tessMeshTessellateMonoRegion( face ) tessellates a monotone region
        * (what else would it do??)  The region must consist of a single
        * loop of half-edges (see mesh.h) oriented CCW.  "Monotone" in this
        * case means that any vertical line intersects the interior of the
        * region in a single interval.  
        *
        * Tessellation consists of adding interior edges (actually pairs of
        * half-edges), to split the region into non-overlapping triangles.
        *
        * The basic idea is explained in Preparata and Shamos (which I don''t
        * have handy right now), although their implementation is more
        * complicated than this one.  The are two edge chains, an upper chain
        * and a lower chain.  We process all vertices from both chains in order,
        * from right to left.
        *
        * The algorithm ensures that the following invariant holds after each
        * vertex is processed: the untessellated region consists of two
        * chains, where one chain (say the upper) is a single edge, and
        * the other chain is concave.  The left vertex of the single edge
        * is always to the left of all vertices in the concave chain.
        *
        * Each step consists of adding the rightmost unprocessed vertex to one
        * of the two chains, and forming a fan of triangles from the rightmost
        * of two chain endpoints.  Determining whether we can add each triangle
        * to the fan is a simple orientation test.  By making the fan as large
        * as possible, we restore the invariant (check it yourself).
        */
        //	int tessMeshTessellateMonoRegion( TESSmesh *mesh, TESSface *face )
        tessellateMonoRegion_: function(d, b) {
          var t, m;
          for (t = b.anEdge, W(t.Lnext !== t && t.Lnext.Lnext !== t); c.vertLeq(t.Dst, t.Org); t = t.Lprev)
            ;
          for (; c.vertLeq(t.Org, t.Dst); t = t.Lnext)
            ;
          for (m = t.Lprev; t.Lnext !== m; )
            if (c.vertLeq(t.Dst, m.Org)) {
              for (; m.Lnext !== t && (c.edgeGoesLeft(m.Lnext) || c.edgeSign(m.Org, m.Dst, m.Lnext.Dst) <= 0); ) {
                var R = d.connect(m.Lnext, m);
                m = R.Sym;
              }
              m = m.Lprev;
            } else {
              for (; m.Lnext !== t && (c.edgeGoesRight(t.Lprev) || c.edgeSign(t.Dst, t.Org, t.Lprev.Org) >= 0); ) {
                var R = d.connect(t, t.Lprev);
                t = R.Sym;
              }
              t = t.Lnext;
            }
          for (W(m.Lnext !== t); m.Lnext.Lnext !== t; ) {
            var R = d.connect(m.Lnext, m);
            m = R.Sym;
          }
          return !0;
        },
        /* tessMeshTessellateInterior( mesh ) tessellates each region of
        * the mesh which is marked "inside" the polygon.  Each such region
        * must be monotone.
        */
        //int tessMeshTessellateInterior( TESSmesh *mesh )
        tessellateInterior_: function(d) {
          var b, t;
          for (b = d.fHead.next; b !== d.fHead; b = t)
            if (t = b.next, b.inside && !this.tessellateMonoRegion_(d, b))
              return !1;
          return !0;
        },
        /* tessMeshDiscardExterior( mesh ) zaps (ie. sets to NULL) all faces
        * which are not marked "inside" the polygon.  Since further mesh operations
        * on NULL faces are not allowed, the main purpose is to clean up the
        * mesh so that exterior loops are not represented in the data structure.
        */
        //void tessMeshDiscardExterior( TESSmesh *mesh )
        discardExterior_: function(d) {
          var b, t;
          for (b = d.fHead.next; b !== d.fHead; b = t)
            t = b.next, b.inside || d.zapFace(b);
        },
        /* tessMeshSetWindingNumber( mesh, value, keepOnlyBoundary ) resets the
        * winding numbers on all edges so that regions marked "inside" the
        * polygon have a winding number of "value", and regions outside
        * have a winding number of 0.
        *
        * If keepOnlyBoundary is TRUE, it also deletes all edges which do not
        * separate an interior region from an exterior one.
        */
        //	int tessMeshSetWindingNumber( TESSmesh *mesh, int value, int keepOnlyBoundary )
        setWindingNumber_: function(d, b, t) {
          var m, R;
          for (m = d.eHead.next; m !== d.eHead; m = R)
            R = m.next, m.Rface.inside !== m.Lface.inside ? m.winding = m.Lface.inside ? b : -b : t ? d.delete(m) : m.winding = 0;
        },
        getNeighbourFace_: function(d) {
          return !d.Rface || !d.Rface.inside ? -1 : d.Rface.n;
        },
        outputPolymesh_: function(d, b, t, m) {
          var R, S, C, F = 0, K = 0, J, T;
          for (t > 3 && d.mergeConvexFaces(t), R = d.vHead.next; R !== d.vHead; R = R.next)
            R.n = -1;
          for (S = d.fHead.next; S !== d.fHead; S = S.next)
            if (S.n = -1, !!S.inside) {
              C = S.anEdge, J = 0;
              do
                R = C.Org, R.n === -1 && (R.n = K, K++), J++, C = C.Lnext;
              while (C !== S.anEdge);
              W(J <= t), S.n = F, ++F;
            }
          for (this.elementCount = F, b === s.CONNECTED_POLYGONS && (F *= 2), this.elements = [], this.elements.length = F * t, this.vertexCount = K, this.vertices = [], this.vertices.length = K * m, this.vertexIndices = [], this.vertexIndices.length = K, R = d.vHead.next; R !== d.vHead; R = R.next)
            if (R.n !== -1) {
              var Y = R.n * m;
              this.vertices[Y + 0] = R.coords[0], this.vertices[Y + 1] = R.coords[1], m > 2 && (this.vertices[Y + 2] = R.coords[2]), this.vertexIndices[R.n] = R.idx;
            }
          var x = 0;
          for (S = d.fHead.next; S !== d.fHead; S = S.next)
            if (S.inside) {
              C = S.anEdge, J = 0;
              do
                R = C.Org, this.elements[x++] = R.n, J++, C = C.Lnext;
              while (C !== S.anEdge);
              for (T = J; T < t; ++T)
                this.elements[x++] = -1;
              if (b === s.CONNECTED_POLYGONS) {
                C = S.anEdge;
                do
                  this.elements[x++] = this.getNeighbourFace_(C), C = C.Lnext;
                while (C !== S.anEdge);
                for (T = J; T < t; ++T)
                  this.elements[x++] = -1;
              }
            }
        },
        //	void OutputContours( TESStesselator *tess, TESSmesh *mesh, int vertexSize )
        outputContours_: function(d, b) {
          var t, m, R, S = 0, C = 0;
          for (this.vertexCount = 0, this.elementCount = 0, t = d.fHead.next; t !== d.fHead; t = t.next)
            if (t.inside) {
              R = m = t.anEdge;
              do
                this.vertexCount++, m = m.Lnext;
              while (m !== R);
              this.elementCount++;
            }
          this.elements = [], this.elements.length = this.elementCount * 2, this.vertices = [], this.vertices.length = this.vertexCount * b, this.vertexIndices = [], this.vertexIndices.length = this.vertexCount;
          var F = 0, K = 0, J = 0;
          for (S = 0, t = d.fHead.next; t !== d.fHead; t = t.next)
            if (t.inside) {
              C = 0, R = m = t.anEdge;
              do
                this.vertices[F++] = m.Org.coords[0], this.vertices[F++] = m.Org.coords[1], b > 2 && (this.vertices[F++] = m.Org.coords[2]), this.vertexIndices[K++] = m.Org.idx, C++, m = m.Lnext;
              while (m !== R);
              this.elements[J++] = S, this.elements[J++] = C, S += C;
            }
        },
        addContour: function(d, b) {
          var t, m;
          for (this.mesh === null && (this.mesh = new G()), d < 2 && (d = 2), d > 3 && (d = 3), t = null, m = 0; m < b.length; m += d)
            t === null ? (t = this.mesh.makeEdge(), this.mesh.splice(t, t.Sym)) : (this.mesh.splitEdge(t), t = t.Lnext), t.Org.coords[0] = b[m + 0], t.Org.coords[1] = b[m + 1], d > 2 ? t.Org.coords[2] = b[m + 2] : t.Org.coords[2] = 0, t.Org.idx = this.vertexIndexCounter++, t.winding = 1, t.Sym.winding = -1;
        },
        //	int tessTesselate( TESStesselator *tess, int windingRule, int elementType, int polySize, int vertexSize, const TESSreal* normal )
        tesselate: function(d, b, t, m, R) {
          if (this.vertices = [], this.elements = [], this.vertexIndices = [], this.vertexIndexCounter = 0, R && (this.normal[0] = R[0], this.normal[1] = R[1], this.normal[2] = R[2]), this.windingRule = d, m < 2 && (m = 2), m > 3 && (m = 3), !this.mesh)
            return !1;
          this.projectPolygon_(), o.computeInterior(this);
          var S = this.mesh;
          return b === s.BOUNDARY_CONTOURS ? this.setWindingNumber_(S, 1, !0) : this.tessellateInterior_(S), S.check(), b === s.BOUNDARY_CONTOURS ? this.outputContours_(S, m) : this.outputPolymesh_(S, b, t, m), !0;
        }
      };
    },
    /* 62 */
    /***/
    function(Z, l) {
      Z.exports = s;
      var i = Object.prototype.hasOwnProperty;
      function s() {
        for (var c = {}, W = 0; W < arguments.length; W++) {
          var h = arguments[W];
          for (var e in h)
            i.call(h, e) && (c[e] = h[e]);
        }
        return c;
      }
    },
    /* 63 */
    /***/
    function(Z, l, i) {
      i.r(l), i.d(l, "createShaders", function() {
        return a;
      }), i.d(l, "applyShader", function() {
        return G;
      }), i.d(l, "createCloudShaders", function() {
        return n;
      }), i.d(l, "applyCloudShader", function() {
        return V;
      });
      var s = i(64), c = i(65), W = i(66), h = i(67);
      i(1).glMatrix.setMatrixArrayType(Array);
      const e = Symbol("shaders");
      function a(I) {
        I[e] = [];
        for (let r = 0; r < 16; r++) {
          const p = [], o = !!(r & 1), u = !!(r & 2), d = !!(r & 4), b = !!(r & 8);
          o && p.push("#define TEXTURE 1"), u && p.push("#define FILTER 1"), d && p.push("#define GRADIENT 1"), b && p.push("#define CLIPPATH 1");
          const t = `${p.join(`
`)}
`, m = [];
          o && m.push("uniform sampler2D u_texSampler;"), b && m.push("uniform sampler2D u_clipSampler;"), I[e][r] = [t + m.join(`
`) + c.default, t + s.default];
        }
      }
      function G(I, {
        hasTexture: r = !1,
        hasFilter: p = !1,
        hasGradient: o = !1,
        hasClipPath: u = !1
      } = {}) {
        const d = r | p << 1 | o << 2 | u << 3;
        let b = I[e][d];
        Array.isArray(b) && (b = I.createProgram(...b), I[e][d] = b), I.program !== b && I.useProgram(b, {
          a_color: {
            type: "UNSIGNED_BYTE",
            normalize: !0
          }
        });
      }
      const y = [];
      function n(I) {
        for (let r = 0; r < 64; r++) {
          const p = [], o = !!(r & 1), u = !!(r & 2), d = !!(r & 4), b = !!(r & 8), t = !!(r & 16), m = !!(r & 32);
          o && p.push("#define TEXTURE 1"), u && p.push("#define FILTER 1"), d && p.push("#define GRADIENT 1"), b && p.push("#define CLOUDCOLOR 1"), t && p.push("#define CLOUDFILTER 1"), m && p.push("#define CLIPPATH 1");
          const R = `${p.join(`
`)}
`, S = [];
          if (o) {
            S.push("uniform sampler2D u_texSampler;");
            for (let C = 0; C < 12; C++)
              S.push(`uniform sampler2D u_texFrame${C};`);
          }
          m && S.push("uniform sampler2D u_clipSampler;"), y[r] = [R + S.join(`
`) + h.default, R + W.default];
        }
      }
      function V(I, {
        hasTexture: r = !1,
        hasFilter: p = !1,
        hasGradient: o = !1,
        hasCloudColor: u = !1,
        hasCloudFilter: d = !1,
        hasClipPath: b = !1
      } = {}) {
        const t = r | p << 1 | o << 2 | u << 3 | d << 4 | b << 5;
        let m = y[t];
        Array.isArray(m) && (m = I.createProgram(...m), y[t] = m), I.program !== m && I.useProgram(m, {
          a_color: {
            type: "UNSIGNED_BYTE",
            normalize: !0
          },
          a_fillCloudColor: {
            type: "UNSIGNED_BYTE",
            normalize: !0
          },
          a_strokeCloudColor: {
            type: "UNSIGNED_BYTE",
            normalize: !0
          },
          a_frameIndex: {
            type: "UNSIGNED_BYTE",
            normalize: !1
          }
        });
      }
    },
    /* 64 */
    /***/
    function(Z, l, i) {
      i.r(l), l.default = `attribute vec3 a_vertexPosition;
attribute vec4 a_color;
varying vec4 vColor;
varying float flagBackground;
uniform vec2 u_resolution;
uniform mat3 viewMatrix;
uniform mat3 projectionMatrix;

#ifdef TEXTURE
attribute vec3 a_vertexTextureCoord;
varying vec3 vTextureCoord;
attribute vec4 a_sourceRect;
varying vec4 vSourceRect;
#endif

#ifdef CLIPPATH
attribute vec2 a_clipUV;
varying vec2 vClipUV;
#endif

#ifdef GRADIENT
uniform float u_radialGradientVector[6];
varying vec3 vGradientVector1;
varying vec3 vGradientVector2;
#endif

void main() {
  gl_PointSize = 1.0;

  vec3 pos = projectionMatrix * viewMatrix * vec3(a_vertexPosition.xy, 1.0);
  gl_Position = vec4(pos.xy, 1.0, 1.0);

#ifdef GRADIENT
  vec3 vg1 = viewMatrix * vec3(u_radialGradientVector[0], u_radialGradientVector[1], 1.0);
  vec3 vg2 = viewMatrix * vec3(u_radialGradientVector[3], u_radialGradientVector[4], 1.0);
  float h = u_resolution.y;
  vg1.y = h - vg1.y;
  vg2.y = h - vg2.y;
  vGradientVector1 = vec3(vg1.xy, u_radialGradientVector[2]);
  vGradientVector2 = vec3(vg2.xy, u_radialGradientVector[5]);
#endif
  
  flagBackground = a_vertexPosition.z;
  vColor = a_color;

#ifdef TEXTURE
  vTextureCoord = a_vertexTextureCoord;
  vSourceRect = a_sourceRect;
#endif

#ifdef CLIPPATH
  vClipUV = a_clipUV;
#endif
}`;
    },
    /* 65 */
    /***/
    function(Z, l, i) {
      i.r(l), l.default = `precision mediump float;

varying vec4 vColor;
varying float flagBackground;

#ifdef TEXTURE
varying vec3 vTextureCoord;
varying vec4 vSourceRect;
#endif

#ifdef CLIPPATH
varying vec2 vClipUV;
#endif

#ifdef FILTER
uniform int u_filterFlag;
uniform float u_colorMatrix[20];
#endif

#ifdef GRADIENT
varying vec3 vGradientVector1;
varying vec3 vGradientVector2;
uniform float u_colorSteps[40];
uniform int u_gradientType;
// uniform float u_radialGradientVector[6];

void gradient(inout vec4 color, vec3 gv1, vec3 gv2, float colorSteps[40]) {
  float t;
  // center circle radius
  float cr = gv1.z;
  // focal circle radius
  float fr = gv2.z;

  if(cr > 0.0 || fr > 0.0) {
    // radial gradient
    vec2 center = gv1.xy;
    vec2 focal = gv2.xy;
    float x = focal.x - gl_FragCoord.x;
    float y = focal.y - gl_FragCoord.y;
    float dx = focal.x - center.x;
    float dy = focal.y - center.y;
    float dr = cr - fr;
    float a = dx * dx + dy * dy - dr * dr;
    float b = -2.0 * (y * dy + x * dx + fr * dr);
    float c = x * x + y * y - fr * fr;
    t = 1.0 - 0.5 * (1.0 / a) * (-b + sqrt(b * b - 4.0 * a * c));
  } else {
    // linear gradient
    vec2 v1 = gl_FragCoord.xy - gv1.xy;
    vec2 v2 = gv2.xy - gv1.xy;
    t = (v1.x * v2.x + v1.y * v2.y) / (v2.x * v2.x + v2.y * v2.y);
  }

  vec4 colors[8];
  colors[0] = vec4(colorSteps[1], colorSteps[2], colorSteps[3], colorSteps[4]);
  colors[1] = vec4(colorSteps[6], colorSteps[7], colorSteps[8], colorSteps[9]);
  colors[2] = vec4(colorSteps[11], colorSteps[12], colorSteps[13], colorSteps[14]);
  colors[3] = vec4(colorSteps[16], colorSteps[17], colorSteps[18], colorSteps[19]);
  colors[4] = vec4(colorSteps[21], colorSteps[22], colorSteps[23], colorSteps[24]);
  colors[5] = vec4(colorSteps[26], colorSteps[27], colorSteps[28], colorSteps[29]);
  colors[6] = vec4(colorSteps[31], colorSteps[32], colorSteps[33], colorSteps[34]);
  colors[7] = vec4(colorSteps[36], colorSteps[37], colorSteps[38], colorSteps[39]);
  
  float steps[8];
  steps[0] = colorSteps[0];
  steps[1] = colorSteps[5];
  steps[2] = colorSteps[10];
  steps[3] = colorSteps[15];
  steps[4] = colorSteps[20];
  steps[5] = colorSteps[25];
  steps[6] = colorSteps[30];
  steps[7] = colorSteps[35];

  color = colors[0];
  for (int i = 1; i < 8; i++) {
    if (steps[i] < 0.0 || steps[i] > 1.0) {
      break;
    }
    if(steps[i] == steps[i - 1]) {
      color = colors[i];
    } else {
      color = mix(color, colors[i], clamp((t - steps[i - 1]) / (steps[i] - steps[i - 1]), 0.0, 1.0));
    }
    if (steps[i] >= t) {
      break;
    }
  }
}
#endif

#ifdef FILTER
void transformColor(inout vec4 color, in float colorMatrix[20]) {
  float r = color.r, g = color.g, b = color.b, a = color.a;
  color[0] = colorMatrix[0] * r + colorMatrix[1] * g + colorMatrix[2] * b + colorMatrix[3] * a + colorMatrix[4];
  color[1] = colorMatrix[5] * r + colorMatrix[6] * g + colorMatrix[7] * b + colorMatrix[8] * a + colorMatrix[9];
  color[2] = colorMatrix[10] * r + colorMatrix[11] * g + colorMatrix[12] * b + colorMatrix[13] * a + colorMatrix[14];
  color[3] = colorMatrix[15] * r + colorMatrix[16] * g + colorMatrix[17] * b + colorMatrix[18] * a + colorMatrix[19];
}
#endif

void main() {
  vec4 color = vColor;
  float opacity = abs(flagBackground);

#ifdef GRADIENT
  if(u_gradientType > 0 && flagBackground > 0.0 || u_gradientType == 0 && flagBackground <= 0.0) {
    gradient(color, vGradientVector1, vGradientVector2, u_colorSteps);
  }
#endif

  if(opacity < 1.0) {
    color.a *= opacity;
  }

#ifdef TEXTURE
  if(flagBackground > 0.0) {
    vec3 texCoord = vTextureCoord;

    if(texCoord.z == 1.0) {
      texCoord = fract(texCoord);
    }

    if(texCoord.x <= 1.0 && texCoord.x >= 0.0
      && texCoord.y <= 1.0 && texCoord.y >= 0.0) {
      if(vSourceRect.z > 0.0) {
        texCoord.x = vSourceRect.x + texCoord.x * vSourceRect.z;
        texCoord.y = 1.0 - (vSourceRect.y + (1.0 - texCoord.y) * vSourceRect.w);
      }
      vec4 texColor = texture2D(u_texSampler, texCoord.xy);
      float alpha = texColor.a;
      if(opacity < 1.0) {
        texColor.a *= opacity;
        alpha *= mix(0.465, 1.0, opacity);
      }
      // color = mix(color, texColor, texColor.a);
      color.rgb = mix(color.rgb, texColor.rgb, alpha);
      // color.rgb = mix(texColor.rgb, color.rgb, color.a);
      color.rgb = mix(texColor.rgb, color.rgb, clamp(color.a / max(0.0001, texColor.a), 0.0, 1.0));
      color.a = texColor.a + (1.0 - texColor.a) * color.a;
    }
  }
#endif

#ifdef FILTER
  if(u_filterFlag > 0) {
    transformColor(color, u_colorMatrix);
  }
#endif

#ifdef CLIPPATH
  float clip = texture2D(u_clipSampler, vClipUV).r;
  color *= clip;
#endif

  gl_FragColor = color;
}`;
    },
    /* 66 */
    /***/
    function(Z, l, i) {
      i.r(l), l.default = `attribute vec3 a_vertexPosition;
attribute vec4 a_color;
varying vec4 vColor;
varying float flagBackground;
attribute vec3 a_transform0;
attribute vec3 a_transform1;
uniform vec2 u_resolution;
uniform mat3 viewMatrix;
uniform mat3 projectionMatrix;

#ifdef TEXTURE
attribute vec3 a_vertexTextureCoord;
varying vec3 vTextureCoord;
attribute float a_frameIndex;
varying float frameIndex;
attribute vec4 a_sourceRect;
varying vec4 vSourceRect;
#endif

#ifdef CLIPPATH
attribute vec2 a_clipUV;
varying vec2 vClipUV;
#endif

#ifdef CLOUDFILTER
attribute vec4 a_colorCloud0;
attribute vec4 a_colorCloud1;
attribute vec4 a_colorCloud2;
attribute vec4 a_colorCloud3;
attribute vec4 a_colorCloud4;
varying vec4 colorCloud0;
varying vec4 colorCloud1;
varying vec4 colorCloud2;
varying vec4 colorCloud3;
varying vec4 colorCloud4;
#endif

#ifdef CLOUDCOLOR
attribute vec4 a_fillCloudColor;
attribute vec4 a_strokeCloudColor;
#endif

#ifdef GRADIENT
uniform float u_radialGradientVector[6];
varying vec3 vGradientVector1;
varying vec3 vGradientVector2;
#endif

void main() {
  gl_PointSize = 1.0;

  mat3 modelMatrix = mat3(
    a_transform0.x, a_transform1.x, 0, 
    a_transform0.y, a_transform1.y, 0,
    a_transform0.z, a_transform1.z, 1
  );

  vec3 pos = projectionMatrix * viewMatrix * modelMatrix * vec3(a_vertexPosition.xy, 1.0);
  gl_Position = vec4(pos.xy, 1.0, 1.0);

#ifdef GRADIENT
  vec3 vg1 = viewMatrix * vec3(u_radialGradientVector[0], u_radialGradientVector[1], 1.0);
  vec3 vg2 = viewMatrix * vec3(u_radialGradientVector[3], u_radialGradientVector[4], 1.0);
  float h = u_resolution.y;
  vg1.y = h - vg1.y;
  vg2.y = h - vg2.y;
  vGradientVector1 = vec3(vg1.xy, u_radialGradientVector[2]);
  vGradientVector2 = vec3(vg2.xy, u_radialGradientVector[5]);
#endif
  
  flagBackground = a_vertexPosition.z;

#ifdef CLOUDCOLOR
  if(flagBackground > 0.0) {
    vColor = mix(a_color, a_fillCloudColor, a_fillCloudColor.a);
  } else {
    vColor = mix(a_color, a_strokeCloudColor, a_strokeCloudColor.a);
  }
#else
  vColor = a_color;
#endif

#ifdef TEXTURE
  vTextureCoord = a_vertexTextureCoord;
  frameIndex = a_frameIndex;
  vSourceRect = a_sourceRect;
#endif

#ifdef CLIPPATH
  vClipUV = a_clipUV;
#endif

#ifdef CLOUDFILTER
  colorCloud0 = a_colorCloud0;
  colorCloud1 = a_colorCloud1;
  colorCloud2 = a_colorCloud2;
  colorCloud3 = a_colorCloud3;
  colorCloud4 = a_colorCloud4;
#endif
}`;
    },
    /* 67 */
    /***/
    function(Z, l, i) {
      i.r(l), l.default = `precision mediump float;

varying vec4 vColor;
varying float flagBackground;

#ifdef TEXTURE
varying float frameIndex;
varying vec3 vTextureCoord;
varying vec4 vSourceRect;
#endif

#ifdef CLIPPATH
varying vec2 vClipUV;
#endif

#ifdef FILTER
uniform int u_filterFlag;
uniform float u_colorMatrix[20];
#endif

#ifdef CLOUDFILTER
varying vec4 colorCloud0;
varying vec4 colorCloud1;
varying vec4 colorCloud2;
varying vec4 colorCloud3;
varying vec4 colorCloud4;
#endif

#ifdef GRADIENT
varying vec3 vGradientVector1;
varying vec3 vGradientVector2;
uniform float u_colorSteps[40];
uniform int u_gradientType;

void gradient(inout vec4 color, vec3 gv1, vec3 gv2, float colorSteps[40]) {
  float t;
  // center circle radius
  float cr = gv1.z;
  // focal circle radius
  float fr = gv2.z;

  if(cr > 0.0 || fr > 0.0) {
    // radial gradient
    vec2 center = gv1.xy;
    vec2 focal = gv2.xy;
    float x = focal.x - gl_FragCoord.x;
    float y = focal.y - gl_FragCoord.y;
    float dx = focal.x - center.x;
    float dy = focal.y - center.y;
    float dr = cr - fr;
    float a = dx * dx + dy * dy - dr * dr;
    float b = -2.0 * (y * dy + x * dx + fr * dr);
    float c = x * x + y * y - fr * fr;
    t = 1.0 - 0.5 * (1.0 / a) * (-b + sqrt(b * b - 4.0 * a * c));
  } else {
    // linear gradient
    vec2 v1 = gl_FragCoord.xy - gv1.xy;
    vec2 v2 = gv2.xy - gv1.xy;
    t = (v1.x * v2.x + v1.y * v2.y) / (v2.x * v2.x + v2.y * v2.y);
  }

  vec4 colors[8];
  colors[0] = vec4(colorSteps[1], colorSteps[2], colorSteps[3], colorSteps[4]);
  colors[1] = vec4(colorSteps[6], colorSteps[7], colorSteps[8], colorSteps[9]);
  colors[2] = vec4(colorSteps[11], colorSteps[12], colorSteps[13], colorSteps[14]);
  colors[3] = vec4(colorSteps[16], colorSteps[17], colorSteps[18], colorSteps[19]);
  colors[4] = vec4(colorSteps[21], colorSteps[22], colorSteps[23], colorSteps[24]);
  colors[5] = vec4(colorSteps[26], colorSteps[27], colorSteps[28], colorSteps[29]);
  colors[6] = vec4(colorSteps[31], colorSteps[32], colorSteps[33], colorSteps[34]);
  colors[7] = vec4(colorSteps[36], colorSteps[37], colorSteps[38], colorSteps[39]);
  
  float steps[8];
  steps[0] = colorSteps[0];
  steps[1] = colorSteps[5];
  steps[2] = colorSteps[10];
  steps[3] = colorSteps[15];
  steps[4] = colorSteps[20];
  steps[5] = colorSteps[25];
  steps[6] = colorSteps[30];
  steps[7] = colorSteps[35];

  color = colors[0];
  for (int i = 1; i < 8; i++) {
    if (steps[i] < 0.0 || steps[i] > 1.0) {
      break;
    }
    if(steps[i] == steps[i - 1]) {
      color = colors[i];
    } else {
      color = mix(color, colors[i], clamp((t - steps[i - 1]) / (steps[i] - steps[i - 1]), 0.0, 1.0));
    }
    if (steps[i] >= t) {
      break;
    }
  }
}
#endif

void transformColor(inout vec4 color, in float colorMatrix[20]) {
  float r = color.r, g = color.g, b = color.b, a = color.a;
  color[0] = colorMatrix[0] * r + colorMatrix[1] * g + colorMatrix[2] * b + colorMatrix[3] * a + colorMatrix[4];
  color[1] = colorMatrix[5] * r + colorMatrix[6] * g + colorMatrix[7] * b + colorMatrix[8] * a + colorMatrix[9];
  color[2] = colorMatrix[10] * r + colorMatrix[11] * g + colorMatrix[12] * b + colorMatrix[13] * a + colorMatrix[14];
  color[3] = colorMatrix[15] * r + colorMatrix[16] * g + colorMatrix[17] * b + colorMatrix[18] * a + colorMatrix[19];
}

#ifdef CLOUDFILTER
void buildCloudColor(inout float colorCloudMatrix[20]) {
  colorCloudMatrix[0] = colorCloud0[0];
  colorCloudMatrix[1] = colorCloud1[0];
  colorCloudMatrix[2] = colorCloud2[0];
  colorCloudMatrix[3] = colorCloud3[0];
  colorCloudMatrix[4] = colorCloud4[0];

  colorCloudMatrix[5] = colorCloud0[1];
  colorCloudMatrix[6] = colorCloud1[1];
  colorCloudMatrix[7] = colorCloud2[1];
  colorCloudMatrix[8] = colorCloud3[1];
  colorCloudMatrix[9] = colorCloud4[1];

  colorCloudMatrix[10] = colorCloud0[2];
  colorCloudMatrix[11] = colorCloud1[2];
  colorCloudMatrix[12] = colorCloud2[2];
  colorCloudMatrix[13] = colorCloud3[2];
  colorCloudMatrix[14] = colorCloud4[2];

  colorCloudMatrix[15] = colorCloud0[3];
  colorCloudMatrix[16] = colorCloud1[3];
  colorCloudMatrix[17] = colorCloud2[3];
  colorCloudMatrix[18] = colorCloud3[3];
  colorCloudMatrix[19] = colorCloud4[3];
}
#endif

void main() {
  vec4 color = vColor;
  float opacity = abs(flagBackground);

#ifdef GRADIENT
  if(u_gradientType > 0 && flagBackground > 0.0 || u_gradientType == 0 && flagBackground <= 0.0) {
    gradient(color, vGradientVector1, vGradientVector2, u_colorSteps);
  }
#endif

  if(opacity < 1.0) {
    color.a *= opacity;
  }

#ifdef TEXTURE
  if(flagBackground > 0.0) {
    vec3 texCoord = vTextureCoord;

    if(texCoord.z == 1.0) {
      texCoord = fract(texCoord);
    }

    if(texCoord.x <= 1.0 && texCoord.x >= 0.0
      && texCoord.y <= 1.0 && texCoord.y >= 0.0) {
      if(vSourceRect.z > 0.0) {
        texCoord.x = vSourceRect.x + texCoord.x * vSourceRect.z;
        texCoord.y = 1.0 - (vSourceRect.y + (1.0 - texCoord.y) * vSourceRect.w);
      }
      if(frameIndex < 0.0) {
        vec4 texColor = texture2D(u_texSampler, texCoord.xy);
        color = mix(color, texColor, texColor.a);
      } else {
        int index = int(floor(clamp(0.0, 11.0, frameIndex)));
        vec4 texColor;
        if(index == 0) texColor = texture2D(u_texFrame0, texCoord.xy);
        else if(index == 1) texColor = texture2D(u_texFrame1, texCoord.xy);
        else if(index == 2) texColor = texture2D(u_texFrame2, texCoord.xy);
        else if(index == 3) texColor = texture2D(u_texFrame3, texCoord.xy);
        else if(index == 4) texColor = texture2D(u_texFrame4, texCoord.xy);
        else if(index == 5) texColor = texture2D(u_texFrame5, texCoord.xy);
        else if(index == 6) texColor = texture2D(u_texFrame6, texCoord.xy);
        else if(index == 7) texColor = texture2D(u_texFrame7, texCoord.xy);
        else if(index == 8) texColor = texture2D(u_texFrame8, texCoord.xy);
        else if(index == 9) texColor = texture2D(u_texFrame9, texCoord.xy);
        else if(index == 10) texColor = texture2D(u_texFrame10, texCoord.xy);
        else texColor = texture2D(u_texFrame11, texCoord.xy);
        float alpha = texColor.a;
        if(opacity < 1.0) {
          texColor.a *= opacity;
          alpha *= mix(0.465, 1.0, opacity);
        }
        // color = mix(color, texColor, texColor.a);
        color.rgb = mix(color.rgb, texColor.rgb, alpha);
        // color.rgb = mix(texColor.rgb, color.rgb, color.a);
        color.rgb = mix(texColor.rgb, color.rgb, clamp(color.a / max(0.0001, texColor.a), 0.0, 1.0));
        color.a = texColor.a + (1.0 - texColor.a) * color.a;
      }
    }
  }
#endif

#ifdef FILTER
  if(u_filterFlag > 0) {
    transformColor(color, u_colorMatrix);
  }
#endif

#ifdef CLOUDFILTER
  float colorCloudMatrix[20];
  buildCloudColor(colorCloudMatrix);
  transformColor(color, colorCloudMatrix);
#endif

#ifdef CLIPPATH
  float clip = texture2D(u_clipSampler, vClipUV).r;
  color *= clip;
#endif

  gl_FragColor = color;
}`;
    },
    /* 68 */
    /***/
    function(Z, l, i) {
      i.r(l), (function(s, c) {
        i.d(l, "requestAnimationFrame", function() {
          return h;
        }), i.d(l, "cancelAnimationFrame", function() {
          return e;
        }), i(1).glMatrix.setMatrixArrayType(Array);
        function W() {
          if (typeof performance < "u" && performance.now)
            return performance.now();
          if (typeof s < "u" && s.hrtime) {
            const [a, G] = s.hrtime();
            return a * 1e3 + G * 1e-6;
          }
          return Date.now ? Date.now() : (/* @__PURE__ */ new Date()).getTime();
        }
        let h, e;
        typeof c < "u" && typeof c.requestAnimationFrame == "function" ? (h = c.requestAnimationFrame, e = c.cancelAnimationFrame) : (h = function(a) {
          return setTimeout(() => {
            a(W());
          }, 16);
        }, e = function(a) {
          return clearTimeout(a);
        });
      }).call(this, i(69), i(22));
    },
    /* 69 */
    /***/
    function(Z, l) {
      var i = Z.exports = {}, s, c;
      function W() {
        throw new Error("setTimeout has not been defined");
      }
      function h() {
        throw new Error("clearTimeout has not been defined");
      }
      (function() {
        try {
          typeof setTimeout == "function" ? s = setTimeout : s = W;
        } catch {
          s = W;
        }
        try {
          typeof clearTimeout == "function" ? c = clearTimeout : c = h;
        } catch {
          c = h;
        }
      })();
      function e(u) {
        if (s === setTimeout)
          return setTimeout(u, 0);
        if ((s === W || !s) && setTimeout)
          return s = setTimeout, setTimeout(u, 0);
        try {
          return s(u, 0);
        } catch {
          try {
            return s.call(null, u, 0);
          } catch {
            return s.call(this, u, 0);
          }
        }
      }
      function a(u) {
        if (c === clearTimeout)
          return clearTimeout(u);
        if ((c === h || !c) && clearTimeout)
          return c = clearTimeout, clearTimeout(u);
        try {
          return c(u);
        } catch {
          try {
            return c.call(null, u);
          } catch {
            return c.call(this, u);
          }
        }
      }
      var G = [], y = !1, n, V = -1;
      function I() {
        !y || !n || (y = !1, n.length ? G = n.concat(G) : V = -1, G.length && r());
      }
      function r() {
        if (!y) {
          var u = e(I);
          y = !0;
          for (var d = G.length; d; ) {
            for (n = G, G = []; ++V < d; )
              n && n[V].run();
            V = -1, d = G.length;
          }
          n = null, y = !1, a(u);
        }
      }
      i.nextTick = function(u) {
        var d = new Array(arguments.length - 1);
        if (arguments.length > 1)
          for (var b = 1; b < arguments.length; b++)
            d[b - 1] = arguments[b];
        G.push(new p(u, d)), G.length === 1 && !y && e(r);
      };
      function p(u, d) {
        this.fun = u, this.array = d;
      }
      p.prototype.run = function() {
        this.fun.apply(null, this.array);
      }, i.title = "browser", i.browser = !0, i.env = {}, i.argv = [], i.version = "", i.versions = {};
      function o() {
      }
      i.on = o, i.addListener = o, i.once = o, i.off = o, i.removeListener = o, i.removeAllListeners = o, i.emit = o, i.prependListener = o, i.prependOnceListener = o, i.listeners = function(u) {
        return [];
      }, i.binding = function(u) {
        throw new Error("process.binding is not supported");
      }, i.cwd = function() {
        return "/";
      }, i.chdir = function(u) {
        throw new Error("process.chdir is not supported");
      }, i.umask = function() {
        return 0;
      };
    },
    /* 70 */
    /***/
    function(Z, l, i) {
      i.r(l), i.d(l, "default", function() {
        return C;
      });
      var s = i(1), c = i(71), W = i(73), h = i(213), e = i(214), a = i(215), G = i(216);
      i(1).glMatrix.setMatrixArrayType(Array);
      function y(F, K) {
        var J = Object.keys(F);
        if (Object.getOwnPropertySymbols) {
          var T = Object.getOwnPropertySymbols(F);
          K && (T = T.filter(function(Y) {
            return Object.getOwnPropertyDescriptor(F, Y).enumerable;
          })), J.push.apply(J, T);
        }
        return J;
      }
      function n(F) {
        for (var K = 1; K < arguments.length; K++) {
          var J = arguments[K] != null ? arguments[K] : {};
          K % 2 ? y(Object(J), !0).forEach(function(T) {
            V(F, T, J[T]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(F, Object.getOwnPropertyDescriptors(J)) : y(Object(J)).forEach(function(T) {
            Object.defineProperty(F, T, Object.getOwnPropertyDescriptor(J, T));
          });
        }
        return F;
      }
      function V(F, K, J) {
        return K in F ? Object.defineProperty(F, K, { value: J, enumerable: !0, configurable: !0, writable: !0 }) : F[K] = J, F;
      }
      const I = Symbol.for("spritejs_changedAttrs"), r = Symbol.for("spritejs_attributes"), p = Symbol("resolution"), o = Symbol("animations"), u = Symbol("eventListeners"), d = Symbol("captureEventListeners"), b = Symbol("filters"), t = Symbol("display"), m = Symbol("program"), R = Symbol("shaderAttrs"), S = Symbol("uniforms");
      class C {
        constructor(K = {}) {
          this.attributes = new this.constructor.Attr(this), this[p] = {
            width: 300,
            height: 150
          }, Object.assign(this.attributes, K), this[o] = /* @__PURE__ */ new Set(), this[u] = {}, this[d] = {};
        }
        get ancestors() {
          let K = this.parent;
          const J = [];
          for (; K; )
            J.push(K), K = K.parent;
          return J;
        }
        get animations() {
          return this[o];
        }
        get filters() {
          return this[b] || this.parent && this.parent.filters;
        }
        get isVisible() {
          return !1;
        }
        get layer() {
          return this.parent ? this.parent.layer : null;
        }
        get localMatrix() {
          const K = this.transformMatrix, {
            x: J,
            y: T
          } = this.attributes;
          return K[4] += J, K[5] += T, K;
        }
        get opacity() {
          let K = this.attributes.opacity;
          return this.parent && this.parent.opacity != null && (K *= this.parent.opacity), K;
        }
        get parentNode() {
          return this.parent;
        }
        get nextSibling() {
          return this.getNodeNearBy(1);
        }
        get previousSibling() {
          return this.getNodeNearBy(-1);
        }
        get program() {
          return this[m];
        }
        /* get parent defined by connect method */
        get renderer() {
          return this.parent ? this.parent.renderer : null;
        }
        get renderMatrix() {
          if (this.__cacheRenderMatrix)
            return this.__cacheRenderMatrix;
          let K = this.localMatrix;
          const J = this.parent;
          if (J) {
            const T = J.__cacheRenderMatrix || J.renderMatrix;
            T && (K = s.mat2d.multiply(Array.of(0, 0, 0, 0, 0, 0), T, K));
          }
          return K;
        }
        get worldScaling() {
          const K = this.renderMatrix;
          return [Math.hypot(K[0], K[1]), Math.hypot(K[2], K[3])];
        }
        get worldRotation() {
          const K = this.renderMatrix;
          return Math.atan2(K[1], K[3]);
        }
        get worldPosition() {
          const K = this.renderMatrix;
          return [K[4], K[5]];
        }
        get uniforms() {
          return this[S];
        }
        /* get zOrder defined by connect method */
        /* attributes */
        get className() {
          return this.attributes.className;
        }
        set className(K) {
          this.attributes.className = K;
        }
        get id() {
          return this.attributes.id;
        }
        set id(K) {
          this.attributes.id = K;
        }
        get name() {
          return this.attributes.name;
        }
        set name(K) {
          this.attributes.name = K;
        }
        get zIndex() {
          return this.attributes.zIndex;
        }
        set zIndex(K) {
          this.attributes.zIndex = K;
        }
        get mesh() {
          return null;
        }
        get shaderAttrs() {
          return this[R] || {};
        }
        activateAnimations() {
          const K = this.layer;
          if (K) {
            const J = this[o];
            J.forEach((Y) => {
              Y.baseTimeline = K.timeline, Y.play(), Y.finished.then(() => {
                J.delete(Y);
              });
            });
            const T = this.children;
            T && T.forEach((Y) => {
              Y.activateAnimations && Y.activateAnimations();
            });
          }
        }
        addEventListener(K, J, T = {}) {
          K === "mousewheel" && (K = "wheel"), typeof T == "boolean" && (T = {
            capture: T
          });
          const {
            capture: Y,
            once: x
          } = T, H = Y ? d : u;
          return this[H][K] = this[H][K] || [], this[H][K].push({
            listener: J,
            once: x
          }), this;
        }
        animate(K, J) {
          const T = new W.default(this, K, J);
          return this.effects && T.applyEffects(this.effects), this.layer && (T.baseTimeline = this.layer.timeline, T.play(), T.finished.then(() => {
            this[o].delete(T);
          })), this[o].add(T), T;
        }
        attr(...K) {
          if (K.length === 0)
            return this.attributes[r];
          if (K.length > 1) {
            let [J, T] = K;
            return typeof T == "function" && (T = T(this.attr(J))), this.setAttribute(J, T), this;
          }
          return typeof K[0] == "string" ? this.getAttribute(K[0]) : (Object.assign(this.attributes, K[0]), this);
        }
        cloneNode() {
          const K = new this.constructor(), J = this.attributes[I];
          return K.attr(J), K;
        }
        connect(K, J) {
          Object.defineProperty(this, "parent", {
            value: K,
            writable: !1,
            configurable: !0
          }), Object.defineProperty(this, "zOrder", {
            value: J,
            writable: !1,
            configurable: !0
          }), K.timeline && this.activateAnimations(), this.setResolution(K.getResolution()), this.forceUpdate(), this.dispatchEvent({
            type: "append",
            detail: {
              parent: K,
              zOrder: J
            }
          });
        }
        contains(K) {
          for (; K && this !== K; )
            K = K.parent;
          return !!K;
        }
        deactivateAnimations() {
          this[o].forEach((J) => J.cancel());
          const K = this.children;
          K && K.forEach((J) => {
            J.deactivateAnimations && J.deactivateAnimations();
          });
        }
        disconnect() {
          const {
            parent: K,
            zOrder: J
          } = this;
          delete this.parent, delete this.zOrder, this.deactivateAnimations(), this.dispatchEvent({
            type: "remove",
            detail: {
              parent: K,
              zOrder: J
            }
          }), K && K.forceUpdate();
        }
        dispatchEvent(K) {
          K instanceof e.default || (K = new e.default(K)), K.target = this;
          let J = K.type;
          J === "mousewheel" && (J = "wheel");
          const T = [this];
          let Y = this.parent;
          for (; K.bubbles && Y; )
            T.push(Y), Y = Y.parent;
          for (let x = T.length - 1; x >= 0; x--) {
            const H = T[x], Q = H[d] && H[d][J];
            if (Q && Q.length && (K.currentTarget = H, Q.forEach(({
              listener: w,
              once: O
            }) => {
              w.call(this, K), O && T.removeEventListener(w);
            }), delete K.currentTarget), !K.bubbles && K.cancelBubble)
              break;
          }
          if (!K.cancelBubble)
            for (let x = 0; x < T.length; x++) {
              const H = T[x], Q = H[u] && H[u][J];
              if (Q && Q.length && (K.currentTarget = H, Q.forEach(({
                listener: w,
                once: O
              }) => {
                w.call(this, K), O && T.removeEventListener(w);
              }), delete K.currentTarget), !K.bubbles || K.cancelBubble)
                break;
            }
        }
        dispatchPointerEvent(K) {
          const {
            layerX: J,
            layerY: T
          } = K;
          return this.isPointCollision(J, T) ? (this.dispatchEvent(K), !0) : !1;
        }
        draw(K = []) {
          const J = this.mesh;
          if (J) {
            if (Object(a.applyFilters)(J, this.filters), K.push(J), this[m]) {
              J.setProgram(this[m]);
              const T = this[R];
              T && Object.entries(T).forEach(([x, H]) => {
                J.setAttribute(x, H);
              });
              const Y = this[S];
              if (this[S]) {
                const x = {};
                Object.entries(Y).forEach(([H, Q]) => {
                  typeof Q == "function" && (Q = Q(this, H)), x[H] = Q;
                }), J.setUniforms(x);
              }
            }
            Object(G.default)(this, J);
          }
          return K;
        }
        forceUpdate() {
          this.parent && this.parent.forceUpdate();
        }
        getAttribute(K) {
          return this.attributes[K];
        }
        getListeners(K, {
          capture: J = !1
        } = {}) {
          return [...this[J ? d : u][K] || []];
        }
        getNodeNearBy(K = 1) {
          if (!this.parent)
            return null;
          if (K === 0)
            return this;
          const J = this.parent.children, T = J.indexOf(this);
          return J[T + K];
        }
        getWorldPosition(K, J) {
          const T = this.renderMatrix, Y = K * T[0] + J * T[2] + T[4], x = K * T[1] + J * T[3] + T[5];
          return [Y, x];
        }
        getOffsetPosition(K, J) {
          const T = s.mat2d.invert(Array.of(0, 0, 0, 0, 0, 0), this.renderMatrix), Y = K * T[0] + J * T[2] + T[4], x = K * T[1] + J * T[3] + T[5];
          return [Y, x];
        }
        getResolution() {
          return n({}, this[p]);
        }
        isPointCollision(K, J) {
          if (!this.mesh)
            return !1;
          const T = this.attributes.pointerEvents;
          if (T === "none" || T !== "all" && !this.isVisible)
            return !1;
          let Y = "both";
          return T === "visibleFill" && (Y = "fill"), T === "visibleStroke" && (Y = "stroke"), this.mesh.isPointCollision(K, J, Y);
        }
        onPropertyChange(K, J, T) {
          K !== "id" && K !== "name" && K !== "className" && K !== "pointerEvents" && K !== "passEvents" && this.forceUpdate(), K === "filter" && (this[b] = Object(a.parseFilterString)(J)), K === "zIndex" && this.parent && this.parent.reorder();
        }
        setAttribute(K, J) {
          K === "attrs" && this.attr(J), this.attributes[K] = J;
        }
        setMouseCapture() {
          this.layer && (this.layer.__mouseCapturedTarget = this);
        }
        // layer.renderer.createProgram(fragmentShader, vertexShader, attributeOptions)
        setProgram(K) {
          this[m] = K, this.forceUpdate();
        }
        setShaderAttribute(K, J) {
          this[R] = this[R] || {}, this[R][K] = J, this.forceUpdate();
        }
        setUniforms(K) {
          this[S] = this[S] || {}, Object.assign(this[S], K), this.forceUpdate();
        }
        setResolution({
          width: K,
          height: J
        }) {
          const {
            width: T,
            height: Y
          } = this[p];
          (T !== K || Y !== J) && (this[p] = {
            width: K,
            height: J
          }, this.forceUpdate(), this.dispatchEvent({
            type: "resolutionchange",
            detail: {
              width: K,
              height: J
            }
          }));
        }
        show() {
          this.attributes.display === "none" && (this.attributes.display = this[t] || "");
        }
        hide() {
          this.attributes.display !== "none" && (this[t] = this.attributes.display, this.attributes.display = "none");
        }
        releaseMouseCapture() {
          this.layer && this.layer.__mouseCapturedTarget === this && (this.layer.__mouseCapturedTarget = null);
        }
        remove() {
          return this.parent && this.parent.removeChild ? (this.parent.removeChild(this), !0) : !1;
        }
        removeAllListeners(K, J = {}) {
          typeof J == "boolean" && (J = {
            capture: J
          });
          const Y = J.capture ? d : u;
          return this[Y][K] && (this[Y][K] = []), this;
        }
        removeAttribute(K) {
          this.setAttribute(K, null);
        }
        removeEventListener(K, J, T = {}) {
          typeof T == "boolean" && (T = {
            capture: T
          });
          const x = T.capture ? d : u;
          if (this[x][K]) {
            const H = this[x][K];
            if (H)
              for (let Q = 0; Q < H.length; Q++) {
                const {
                  listener: w
                } = H[Q];
                if (w === J) {
                  this[x][K].splice(Q, 1);
                  break;
                }
              }
          }
          return this;
        }
        transition(K, J = "linear") {
          const T = this, Y = Symbol("animation");
          J = J || "linear";
          let x = 0;
          return typeof K == "object" && (x = K.delay || 0, K = K.duration), {
            [Y]: null,
            cancel(H = !1) {
              const Q = this[Y];
              Q && Q.cancel(H);
            },
            end() {
              const H = this[Y];
              H && (H.playState === "running" || H.playState === "pending") && H.finish();
            },
            reverse() {
              const H = this[Y];
              if (H)
                if (H.playState === "running" || H.playState === "pending")
                  H.playbackRate = -H.playbackRate;
                else {
                  const Q = H.timing.direction;
                  H.timing.direction = Q === "reverse" ? "normal" : "reverse", H.play();
                }
              return H.finished;
            },
            attr(H, Q) {
              return this.end(), typeof H == "string" && (H = {
                [H]: Q
              }), Object.entries(H).forEach(([w, O]) => {
                typeof O == "function" && (H[w] = O(T.attr(w)));
              }), this[Y] = T.animate([H], {
                duration: K * 1e3,
                delay: x * 1e3,
                fill: "forwards",
                easing: J
              }), this[Y].finished;
            }
          };
        }
        updateContours() {
        }
      }
      V(C, "Attr", c.default), h.default.registerNode(C, "node");
    },
    /* 71 */
    /***/
    function(Z, l, i) {
      i.r(l), i.d(l, "default", function() {
        return C;
      });
      var s = i(1), c = i(12), W = i(72);
      i(1).glMatrix.setMatrixArrayType(Array);
      const h = Symbol.for("spritejs_setAttributeDefault"), e = Symbol.for("spritejs_declareAlias"), a = Symbol.for("spritejs_setAttribute"), G = Symbol.for("spritejs_getAttribute"), y = Symbol.for("spritejs_attributes"), n = Symbol.for("spritejs_changedAttrs"), V = Symbol("subject"), I = Symbol("attr"), r = Symbol("default"), p = Symbol("alias");
      function o(F, [K, J]) {
        let T = s.mat2d.fromValues(1, 0, 0, 1, 0, 0);
        return [...F].forEach(([Y, x]) => {
          if ((K || J) && (T = s.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), T, [K, J])), Y === "matrix")
            T = s.mat2d.multiply(T, T, x);
          else if (Y === "offsetTranslate")
            T[4] += x[0], T[5] += x[1];
          else if (Y === "offsetRotate")
            T = s.mat2d.rotate(Array.of(0, 0, 0, 0, 0, 0), T, x);
          else if (Y === "skew") {
            const [H, Q] = x;
            T = s.mat2d.multiply(T, T, s.mat2d.fromValues(1, Math.tan(Q), Math.tan(H), 1, 0, 0));
          } else
            s.mat2d[Y](T, T, x);
          (K || J) && (T = s.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), T, [-K, -J]));
        }), T;
      }
      const u = Symbol("transformMatrix"), d = Symbol("transforms"), b = Symbol("changedAttrs"), t = Symbol("lastChangedAttr"), m = Symbol("offsetFigure");
      function R(F, K, J) {
        const T = F[I][K];
        if (F[a](K, J, !1) || F[t] !== K) {
          const x = F[d];
          x.has(K) && x.delete(K), J && (K === "rotate" && (J = Math.PI * J / 180), K === "scale" && (J = J.map((H) => Math.abs(H) > 1e-5 ? H : 1 / H > 0 ? 1e-5 : -1e-5)), x.set(K, J)), F[u] = null, F[V].onPropertyChange(K, J, T, F);
        }
      }
      function S(F) {
        const K = F[m], J = F.offsetDistance * K.getTotalLength(), T = K.getPointAtLength(J);
        if (T) {
          const Y = F[d];
          let x = F.offsetRotate;
          x === "auto" ? x = T.angle : x === "reverse" ? x = Math.PI + T.angle : x = Math.PI * x / 180, Y.set("offsetRotate", x), Y.set("offsetTranslate", [T.x, T.y]), F[u] = null;
        }
      }
      class C {
        static setDefault(K, ...J) {
          return K[h](...J);
        }
        static declareAlias(K, ...J) {
          return K[e](...J);
        }
        static setAttribute(K, ...J) {
          return K[a](...J);
        }
        static getAttribute(K, ...J) {
          return K[G](...J);
        }
        static getAttributes(K) {
          return K[y];
        }
        static getChangedAttributes(K) {
          return K[n];
        }
        constructor(K) {
          this[V] = K, this[I] = {}, this[u] = s.mat2d.fromValues(1, 0, 0, 1, 0, 0), this[d] = /* @__PURE__ */ new Map(), this[r] = {}, this[p] = [], Object.defineProperty(K, "transformMatrix", {
            get: () => (this[u] || (this[u] = o(this[d], this.transformOrigin)), [...this[u]])
          }), this[h]({
            id: "",
            name: "",
            className: "",
            /* class */
            x: 0,
            y: 0,
            /* pos */
            transformOrigin: [0, 0],
            transform: "",
            translate: [0, 0],
            rotate: 0,
            scale: [1, 1],
            skew: [0, 0],
            opacity: 1,
            zIndex: 0,
            offsetPath: void 0,
            offsetDistance: 0,
            offsetRotate: "auto",
            pointerEvents: "visible",
            // none | visible | visibleFill | visibleStroke | all
            filter: "none",
            display: ""
          }), this[e]("class", "pos"), this[b] = /* @__PURE__ */ new Set(), this[m] = new c.Figure2D({
            scale: 5,
            simplify: 0
          });
        }
        get [n]() {
          const K = {};
          return [...this[b]].forEach((J) => {
            K[J] = this[I][J];
          }), K;
        }
        get [y]() {
          const K = Object.assign({}, this[I]);
          for (let J = 0; J < this[p].length; J++) {
            const T = this[p][J];
            K[T] = this[T];
          }
          return K;
        }
        [h](K) {
          Object.assign(this[r], K), Object.assign(this[I], K);
        }
        [e](...K) {
          this[p].push(...K);
        }
        [a](K, J, T = !0) {
          const Y = this[I][K], x = this[V];
          return J == null && (J = this[r][K]), Object(W.compareValue)(Y, J) ? !1 : (this[I][K] = J, this[b].has(K) && this[b].delete(K), this[b].add(K), this[t] = K, T && x.onPropertyChange(K, J, Y, this), !0);
        }
        [G](K) {
          return this[I][K];
        }
        set id(K) {
          this[a]("id", K);
        }
        get id() {
          return this[G]("id");
        }
        set name(K) {
          this[a]("name", K);
        }
        get name() {
          return this[G]("name");
        }
        set className(K) {
          this[a]("className", K);
        }
        get className() {
          return this[G]("className");
        }
        set class(K) {
          this.className = K;
        }
        get class() {
          return this.className;
        }
        get x() {
          return this[G]("x");
        }
        set x(K) {
          this[a]("x", Object(W.toNumber)(K));
        }
        get y() {
          return this[G]("y");
        }
        set y(K) {
          this[a]("y", Object(W.toNumber)(K));
        }
        get pos() {
          return [this.x, this.y];
        }
        set pos(K) {
          K = Object(W.toArray)(K), Array.isArray(K) || (K = [K, K]), this.x = K[0], this.y = K[1];
        }
        get transform() {
          return this[G]("transform");
        }
        set transform(K) {
          let J = null;
          if (Array.isArray(K) && (J = K, K = `matrix(${K.map(W.toNumber).join()})`), typeof K == "string")
            K = K.replace(/\s*,\s*/g, ",");
          else if (K != null)
            throw new TypeError("Invalid transform value.");
          const T = this[I].transform;
          if (this[a]("transform", K, !1)) {
            const Y = this[d];
            if (Y.has("matrix") && Y.delete("matrix"), J)
              Y.set("matrix", J);
            else if (K) {
              const x = K.match(/(matrix|translate|rotate|scale|skew)\([^()]+\)/g);
              if (x) {
                let H = s.mat2d.fromValues(1, 0, 0, 1, 0, 0);
                for (let Q = 0; Q < x.length; Q++) {
                  const O = x[Q].match(/^(matrix|translate|rotate|scale|skew)\(([^()]+)\)/);
                  if (O) {
                    let [, q, k] = O;
                    q === "rotate" ? k = Math.PI * parseFloat(k) / 180 : k = k.trim().split(/[\s,]+/).map((f) => Object(W.toNumber)(f)), q === "matrix" ? H = s.mat2d.multiply(H, H, k) : q === "skew" ? H = s.mat2d.multiply(H, H, s.mat2d.fromValues(1, Math.tan(k[1]), Math.tan(k[0]), 1, 0, 0)) : s.mat2d[q](H, H, k), Y.set("matrix", H);
                  }
                }
              } else
                throw new TypeError("Invalid transform value.");
            }
            this[u] = null, this[V].onPropertyChange("transform", K, T, this);
          }
        }
        get transformOrigin() {
          return this[G]("transformOrigin");
        }
        set transformOrigin(K) {
          K = Object(W.toArray)(K, !0), K != null && !Array.isArray(K) && (K = [K, K]), this[a]("transformOrigin", K) && (this[u] = null);
        }
        get rotate() {
          return this[G]("rotate");
        }
        set rotate(K) {
          R(this, "rotate", K);
        }
        get translate() {
          return this[G]("translate");
        }
        set translate(K) {
          K = Object(W.toArray)(K, !0), K != null && !Array.isArray(K) && (K = [K, K]), R(this, "translate", K);
        }
        get scale() {
          return this[G]("scale");
        }
        set scale(K) {
          K = Object(W.toArray)(K, !0), K != null && !Array.isArray(K) && (K = [K, K]), R(this, "scale", K);
        }
        get skew() {
          return this[G]("skew");
        }
        set skew(K) {
          K = Object(W.toArray)(K, !0), K != null && !Array.isArray(K) && (K = [K, K]), R(this, "skew", K);
        }
        get opacity() {
          return this[G]("opacity");
        }
        set opacity(K) {
          K != null && (K = Number(K)), this[a]("opacity", K);
        }
        get zIndex() {
          return this[G]("zIndex");
        }
        set zIndex(K) {
          K != null && (K = Number(K)), this[a]("zIndex", K);
        }
        get offsetPath() {
          return this[G]("offsetPath");
        }
        set offsetPath(K) {
          this[a]("offsetPath", K) && (this[m].beginPath(), K != null && this[m].addPath(K), S(this));
        }
        get offsetDistance() {
          return this[G]("offsetDistance");
        }
        set offsetDistance(K) {
          this[a]("offsetDistance", Object(W.toNumber)(K)) && S(this);
        }
        get offsetRotate() {
          return this[G]("offsetRotate");
        }
        set offsetRotate(K) {
          this[a]("offsetRotate", K), S(this);
        }
        get pointerEvents() {
          return this[G]("pointerEvents");
        }
        set pointerEvents(K) {
          if (K != null && K !== "none" && K !== "visible" && K !== "visibleFill" && K !== "visibleStroke" && K !== "all")
            throw new TypeError("Invalid pointerEvents type.");
          this[a]("pointerEvents", K);
        }
        get filter() {
          return this[G]("filter");
        }
        set filter(K) {
          this[a]("filter", K);
        }
        get display() {
          return this[G]("display");
        }
        set display(K) {
          this[a]("display", K);
        }
        /* istanbul ignore next */
        set offset(K) {
        }
      }
    },
    /* 72 */
    /***/
    function(Z, l, i) {
      i.r(l), i.d(l, "sizeToPixel", function() {
        return s;
      }), i.d(l, "toString", function() {
        return c;
      }), i.d(l, "toNumber", function() {
        return W;
      }), i.d(l, "toArray", function() {
        return h;
      }), i.d(l, "compareValue", function() {
        return e;
      }), i(1).glMatrix.setMatrixArrayType(Array);
      function s(a, G) {
        const y = a.trim().match(/^([\d.]+)(px|pt|pc|in|cm|mm|em|ex|rem|q|vw|vh|vmax|vmin)$/);
        y ? a = {
          size: parseFloat(y[1]),
          unit: y[2]
        } : a = {
          size: parseFloat(a),
          unit: "px"
        };
        let {
          size: n,
          unit: V
        } = a;
        if (V === "pt")
          n /= 0.75;
        else if (V === "pc")
          n *= 16;
        else if (V === "in")
          n *= 96;
        else if (V === "cm")
          n *= 96 / 2.54;
        else if (V === "mm")
          n *= 96 / 25.4;
        else if (V === "em" || V === "rem" || V === "ex") {
          if (!G && typeof getComputedStyle == "function" && typeof document < "u") {
            const I = getComputedStyle(document.documentElement).fontSize;
            I ? G = s(I, 16) : G = 16;
          }
          n *= G, V === "ex" && (n /= 2);
        } else if (V === "q")
          n *= 96 / 25.4 / 4;
        else if (V === "vw" || V === "vh") {
          if (typeof document < "u") {
            const I = V === "vw" ? window.innerWidth || document.documentElement.clientWidth : window.innerHeight || document.documentElement.clientHeight;
            n *= I / 100;
          }
        } else if ((V === "vmax" || V === "vmin") && typeof document < "u") {
          const I = window.innerWidth || document.documentElement.clientWidth, r = window.innerHeight || document.documentElement.clientHeight;
          V === "vmax" ? n *= Math.max(I, r) / 100 : n *= Math.min(I, r) / 100;
        }
        return n;
      }
      function c(a) {
        return a == null ? a : String(a);
      }
      function W(a) {
        if (a == null)
          return a;
        if (typeof a == "string" && (a = s(a)), !Number.isFinite(a))
          throw new TypeError("Invalid value");
        return a;
      }
      function h(a, G = !1) {
        return a === "" ? null : (typeof a == "string" && (a = a.split(/[\s,]+/g)), Array.isArray(a) && (G && (a = a.map(W)), a.length === 1) ? a[0] : a);
      }
      function e(a, G) {
        if (Array.isArray(a) && Array.isArray(G)) {
          if (a.length !== G.length)
            return !1;
          for (let y = 0; y < a.length; y++)
            if (a[y] !== G[y])
              return !1;
          return !0;
        }
        return a == null && G == null || a === G;
      }
    },
    /* 73 */
    /***/
    function(Z, l, i) {
      i.r(l), i.d(l, "default", function() {
        return V;
      });
      var s = i(74), c = i(32), W = /* @__PURE__ */ i.n(c), h = i(68), e = i(72);
      i(1).glMatrix.setMatrixArrayType(Array);
      function a() {
        return a = Object.assign || function(I) {
          for (var r = 1; r < arguments.length; r++) {
            var p = arguments[r];
            for (var o in p)
              Object.prototype.hasOwnProperty.call(p, o) && (I[o] = p[o]);
          }
          return I;
        }, a.apply(this, arguments);
      }
      function G(I) {
        if (typeof I == "string") {
          if (I = I.trim(), /^[0-9.]+%$/.test(I))
            return parseFloat(I) / 100;
          if (/^([\d.]+)(px|pt|pc|in|cm|mm|em|ex|rem|q|vw|vh|vmax|vmin)$/.test(I))
            return Object(e.sizeToPixel)(I);
        }
        return I;
      }
      function y(I, r, p, o, u) {
        return typeof I == "string" && (I = W()(I)), typeof r == "string" && (r = W()(r)), s.Effects.default(I, r, p, o, u);
      }
      function n(I, r, p, o, u) {
        return s.Effects.default(I, r, p, o, u);
      }
      s.Effects.default = function(I, r, p, o, u) {
        return Array.isArray(I) && Array.isArray(r) ? I.map((d, b) => d + (p - o) / (u - o) * (r[b] - d)) : typeof I == "number" && typeof r == "number" ? I + (p - o) / (u - o) * (r - I) : p - o > u - p ? r : I;
      }, s.Effects.fillColor = y, s.Effects.strokeColor = y, s.Effects.bgcolor = y, s.Effects.borderColor = y, s.Effects.text = n;
      class V extends s.Animator {
        constructor(r, p, o) {
          const u = r.attr();
          Object.entries(u).forEach(([d, b]) => {
            u[d] = s.Effects[d] ? b : G(b);
          }), p = p.map((d) => {
            let b = a({}, d);
            const t = {};
            return Object.entries(b).forEach(([m, R]) => {
              t[m] = s.Effects[m] ? R : G(R);
            }), t;
          }), super(u, p, o), this.target = r, this.setter = function(d, b) {
            b.attr(d);
          };
        }
        get playState() {
          return this.target.parent ? super.playState : "idle";
        }
        get finished() {
          return super.finished.then(() => {
            const r = this;
            return new Promise((p) => {
              function o() {
                r.setter(r.frame, r.target);
                const u = r.playState;
                u === "finished" || u === "idle" ? (Object(h.cancelAnimationFrame)(r.requestId), p()) : Object(h.requestAnimationFrame)(o);
              }
              o();
            });
          });
        }
        finish() {
          super.finish(), Object(h.cancelAnimationFrame)(this.requestId), this.setter(this.frame, this.target);
        }
        play() {
          if (!this.target.parent || this.playState === "running")
            return;
          super.play(), this.setter(this.frame, this.target);
          const r = this;
          this.ready.then(() => {
            r.setter(r.frame, r.target), r.requestId = Object(h.requestAnimationFrame)(function p() {
              const o = r.target;
              if (typeof document < "u" && document.documentElement && document.documentElement.contains && o.layer && o.layer.canvas && !document.documentElement.contains(o.layer.canvas)) {
                r.cancel();
                return;
              }
              const u = r.playState;
              r.setter(r.frame, r.target), u !== "idle" && (u === "running" ? r.requestId = Object(h.requestAnimationFrame)(p) : (u === "paused" || u === "pending" && r.timeline.currentTime < 0) && r.ready.then(() => {
                r.setter(r.frame, r.target), r.requestId = Object(h.requestAnimationFrame)(p);
              }));
            });
          });
        }
        cancel(r = !1) {
          Object(h.cancelAnimationFrame)(this.requestId), r ? (this.setter(this.frame, this.target), super.cancel()) : (super.cancel(), this.setter(this.frame, this.target));
        }
      }
    },
    /* 74 */
    /***/
    function(Z, l, i) {
      Object.defineProperty(l, "__esModule", {
        value: !0
      }), l.Timeline = l.Effects = l.Easings = l.Animator = void 0;
      var s = i(75), c = y(s), W = i(187), h = y(W), e = i(188), a = i(190), G = y(a);
      function y(n) {
        return n && n.__esModule ? n : { default: n };
      }
      l.Animator = G.default, l.Easings = e.Easings, l.Effects = h.default, l.Timeline = c.default;
    },
    /* 75 */
    /***/
    function(Z, l, i) {
      Object.defineProperty(l, "__esModule", {
        value: !0
      });
      var s = i(76), c = d(s), W = i(133), h = d(W), e = i(141), a = d(e), G = i(164), y = d(G), n = i(170), V = d(n), I = i(171), r = d(I), p = i(175), o = d(p), u = i(186);
      function d(T) {
        return T && T.__esModule ? T : { default: T };
      }
      var b = (0, u.createNowTime)(), t = {
        originTime: 0,
        playbackRate: 1
      }, m = (0, o.default)("timeMark"), R = (0, o.default)("playbackRate"), S = (0, o.default)("timers"), C = (0, o.default)("originTime"), F = (0, o.default)("setTimer"), K = (0, o.default)("parent"), J = function() {
        function T(Y, x) {
          (0, V.default)(this, T), Y instanceof T && (x = Y, Y = {}), Y = (0, y.default)({}, t, Y), x && (this[K] = x);
          var H = Y.nowtime || b;
          if (x)
            Object.defineProperty(this, "globalTime", {
              get: function() {
                return x.currentTime;
              }
            });
          else {
            var Q = H();
            Object.defineProperty(this, "globalTime", {
              get: function() {
                return H() - Q;
              }
            });
          }
          this[m] = [{
            globalTime: this.globalTime,
            localTime: -Y.originTime,
            entropy: -Y.originTime,
            playbackRate: Y.playbackRate,
            globalEntropy: 0
          }], this[K] && (this[m][0].globalEntropy = this[K].entropy), this[C] = Y.originTime, this[R] = Y.playbackRate, this[S] = new a.default();
        }
        return (0, r.default)(T, [{
          key: "markTime",
          value: function() {
            var x = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, H = x.time, Q = H === void 0 ? this.currentTime : H, w = x.entropy, O = w === void 0 ? this.entropy : w, q = x.playbackRate, k = q === void 0 ? this.playbackRate : q, f = {
              globalTime: this.globalTime,
              localTime: Q,
              entropy: O,
              playbackRate: k,
              globalEntropy: this.globalEntropy
            };
            this[m].push(f);
          }
        }, {
          key: "fork",
          value: function(x) {
            return new T(x, this);
          }
        }, {
          key: "seekGlobalTime",
          value: function(x) {
            var H = this.seekTimeMark(x), Q = this[m][H], w = Q.entropy, O = Q.playbackRate, q = Q.globalTime;
            return q + (x - w) / Math.abs(O);
          }
        }, {
          key: "seekLocalTime",
          value: function(x) {
            var H = this.seekTimeMark(x), Q = this[m][H], w = Q.localTime, O = Q.entropy, q = Q.playbackRate;
            return q > 0 ? w + (x - O) : w - (x - O);
          }
        }, {
          key: "seekTimeMark",
          value: function(x) {
            var H = this[m], Q = 0, w = H.length - 1;
            if (x <= H[Q].entropy)
              return Q;
            if (x >= H[w].entropy)
              return w;
            for (var O = Math.floor((Q + w) / 2); O > Q && O < w; ) {
              if (x === H[O].entropy)
                return O;
              x < H[O].entropy ? w = O : x > H[O].entropy && (Q = O), O = Math.floor((Q + w) / 2);
            }
            return Q;
          }
        }, {
          key: "updateTimers",
          value: function() {
            var x = this, H = [].concat((0, h.default)(this[S]));
            H.forEach(function(Q) {
              var w = (0, c.default)(Q, 2), O = w[0], q = w[1];
              x[F](q.handler, q.time, O);
            });
          }
        }, {
          key: "clearTimeout",
          value: function(Y) {
            function x(H) {
              return Y.apply(this, arguments);
            }
            return x.toString = function() {
              return Y.toString();
            }, x;
          }(function(Y) {
            var x = this[S].get(Y);
            x && x.timerID != null && (this[K] ? this[K].clearTimeout(x.timerID) : clearTimeout(x.timerID)), this[S].delete(Y);
          })
        }, {
          key: "clearInterval",
          value: function(x) {
            return this.clearTimeout(x);
          }
        }, {
          key: "clear",
          value: function() {
            var x = this, H = this[S];
            [].concat((0, h.default)(H.keys())).forEach(function(Q) {
              x.clearTimeout(Q);
            });
          }
          /*
            setTimeout(func, {delay: 100, isEntropy: true})
            setTimeout(func, {entropy: 100})
            setTimeout(func, 100})
           */
        }, {
          key: "setTimeout",
          value: function(x) {
            var H = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : { delay: 0 };
            return this[F](x, H);
          }
        }, {
          key: "setInterval",
          value: function(x) {
            var H = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : { delay: 0 }, Q = this, w = this[F](function O() {
              Q[F](O, H, w), x();
            }, H);
            return w;
          }
        }, {
          key: F,
          value: function(x, H) {
            var Q = this, w = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : (0, o.default)("timerID");
            H = (0, u.formatDelay)(H);
            var O = this[S].get(w), q = void 0, k = null, f = void 0, D = void 0;
            O ? (this.clearTimeout(w), H.isEntropy ? q = (H.delay - (this.entropy - O.startEntropy)) / Math.abs(this.playbackRate) : q = (H.delay - (this.currentTime - O.startTime)) / this.playbackRate, f = O.startTime, D = O.startEntropy) : (q = H.delay / (H.isEntropy ? Math.abs(this.playbackRate) : this.playbackRate), f = this.currentTime, D = this.entropy);
            var ii = this[K], _ = ii ? ii.setTimeout.bind(ii) : setTimeout, bi = H.heading;
            return !ii && bi === !1 && q < 0 && (q = 1 / 0), (isFinite(q) || ii) && (q = Math.ceil(q), _ !== setTimeout && (q = { delay: q, heading: bi }), k = _(function() {
              Q[S].delete(w), x();
            }, q)), this[S].set(w, {
              timerID: k,
              handler: x,
              time: H,
              startTime: f,
              startEntropy: D
            }), w;
          }
        }, {
          key: "parent",
          get: function() {
            return this[K];
          }
        }, {
          key: "lastTimeMark",
          get: function() {
            return this[m][this[m].length - 1];
          }
        }, {
          key: "currentTime",
          get: function() {
            var x = this.lastTimeMark, H = x.localTime, Q = x.globalTime;
            return H + (this.globalTime - Q) * this.playbackRate;
          },
          set: function(x) {
            var H = this, Q = this.currentTime, w = x, O = this[S];
            this.markTime({ time: x }), [].concat((0, h.default)(O)).forEach(function(q) {
              var k = (0, c.default)(q, 2), f = k[0], D = k[1];
              if (O.has(f)) {
                var ii = D.time, _ = ii.isEntropy, bi = ii.delay, $ = ii.heading, oi = D.handler, ni = D.startTime;
                if (_)
                  bi === 0 && (oi(), H.clearTimeout(f));
                else {
                  var z = ni + bi;
                  (bi === 0 || $ !== !1 && (w - Q) * bi <= 0 || Q <= z && z <= w || Q >= z && z >= w) && (oi(), H.clearTimeout(f));
                }
              }
            }), this.updateTimers();
          }
          // Both currentTime and entropy should be influenced by playbackRate.
          // If current playbackRate is negative, the currentTime should go backwards
          // while the entropy remain to go forwards.
          // Both of the initial values is set to -originTime
        }, {
          key: "entropy",
          get: function() {
            var x = this.lastTimeMark, H = x.entropy, Q = x.globalEntropy;
            return H + Math.abs((this.globalEntropy - Q) * this.playbackRate);
          },
          // get globalTime() {
          //   if(this[_parent]) {
          //     return this[_parent].currentTime;
          //   }
          //   return nowtime();
          // }
          // change entropy will NOT cause currentTime changing but may influence the pass
          // and the future of the timeline. (It may change the result of seek***Time)
          // While entropy is set, all the marks behind will be droped
          set: function(x) {
            if (this.entropy > x) {
              var H = this.seekTimeMark(x);
              this[m].length = H + 1;
            }
            this.markTime({ entropy: x }), this.updateTimers();
          }
        }, {
          key: "globalEntropy",
          get: function() {
            return this[K] ? this[K].entropy : this.globalTime;
          }
        }, {
          key: "playbackRate",
          get: function() {
            return this[R];
          },
          set: function(x) {
            x !== this.playbackRate && (this.markTime({ playbackRate: x }), this[R] = x, this.updateTimers());
          }
        }, {
          key: "paused",
          get: function() {
            if (this.playbackRate === 0)
              return !0;
            for (var x = this.parent; x; ) {
              if (x.playbackRate === 0)
                return !0;
              x = x.parent;
            }
            return !1;
          }
        }]), T;
      }();
      l.default = J;
    },
    /* 76 */
    /***/
    function(Z, l, i) {
      l.__esModule = !0;
      var s = i(77), c = e(s), W = i(129), h = e(W);
      function e(a) {
        return a && a.__esModule ? a : { default: a };
      }
      l.default = /* @__PURE__ */ function() {
        function a(G, y) {
          var n = [], V = !0, I = !1, r = void 0;
          try {
            for (var p = (0, h.default)(G), o; !(V = (o = p.next()).done) && (n.push(o.value), !(y && n.length === y)); V = !0)
              ;
          } catch (u) {
            I = !0, r = u;
          } finally {
            try {
              !V && p.return && p.return();
            } finally {
              if (I)
                throw r;
            }
          }
          return n;
        }
        return function(G, y) {
          if (Array.isArray(G))
            return G;
          if ((0, c.default)(Object(G)))
            return a(G, y);
          throw new TypeError("Invalid attempt to destructure non-iterable instance");
        };
      }();
    },
    /* 77 */
    /***/
    function(Z, l, i) {
      Z.exports = { default: i(78), __esModule: !0 };
    },
    /* 78 */
    /***/
    function(Z, l, i) {
      i(79), i(125), Z.exports = i(127);
    },
    /* 79 */
    /***/
    function(Z, l, i) {
      i(80);
      for (var s = i(91), c = i(95), W = i(83), h = i(122)("toStringTag"), e = "CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,TextTrackList,TouchList".split(","), a = 0; a < e.length; a++) {
        var G = e[a], y = s[G], n = y && y.prototype;
        n && !n[h] && c(n, h, G), W[G] = W.Array;
      }
    },
    /* 80 */
    /***/
    function(Z, l, i) {
      var s = i(81), c = i(82), W = i(83), h = i(84);
      Z.exports = i(88)(Array, "Array", function(e, a) {
        this._t = h(e), this._i = 0, this._k = a;
      }, function() {
        var e = this._t, a = this._k, G = this._i++;
        return !e || G >= e.length ? (this._t = void 0, c(1)) : a == "keys" ? c(0, G) : a == "values" ? c(0, e[G]) : c(0, [G, e[G]]);
      }, "values"), W.Arguments = W.Array, s("keys"), s("values"), s("entries");
    },
    /* 81 */
    /***/
    function(Z, l) {
      Z.exports = function() {
      };
    },
    /* 82 */
    /***/
    function(Z, l) {
      Z.exports = function(i, s) {
        return { value: s, done: !!i };
      };
    },
    /* 83 */
    /***/
    function(Z, l) {
      Z.exports = {};
    },
    /* 84 */
    /***/
    function(Z, l, i) {
      var s = i(85), c = i(87);
      Z.exports = function(W) {
        return s(c(W));
      };
    },
    /* 85 */
    /***/
    function(Z, l, i) {
      var s = i(86);
      Z.exports = Object("z").propertyIsEnumerable(0) ? Object : function(c) {
        return s(c) == "String" ? c.split("") : Object(c);
      };
    },
    /* 86 */
    /***/
    function(Z, l) {
      var i = {}.toString;
      Z.exports = function(s) {
        return i.call(s).slice(8, -1);
      };
    },
    /* 87 */
    /***/
    function(Z, l) {
      Z.exports = function(i) {
        if (i == null)
          throw TypeError("Can't call method on  " + i);
        return i;
      };
    },
    /* 88 */
    /***/
    function(Z, l, i) {
      var s = i(89), c = i(90), W = i(106), h = i(95), e = i(83), a = i(107), G = i(121), y = i(123), n = i(122)("iterator"), V = !([].keys && "next" in [].keys()), I = "@@iterator", r = "keys", p = "values", o = function() {
        return this;
      };
      Z.exports = function(u, d, b, t, m, R, S) {
        a(b, d, t);
        var C = function(k) {
          if (!V && k in T)
            return T[k];
          switch (k) {
            case r:
              return function() {
                return new b(this, k);
              };
            case p:
              return function() {
                return new b(this, k);
              };
          }
          return function() {
            return new b(this, k);
          };
        }, F = d + " Iterator", K = m == p, J = !1, T = u.prototype, Y = T[n] || T[I] || m && T[m], x = Y || C(m), H = m ? K ? C("entries") : x : void 0, Q = d == "Array" && T.entries || Y, w, O, q;
        if (Q && (q = y(Q.call(new u())), q !== Object.prototype && q.next && (G(q, F, !0), !s && typeof q[n] != "function" && h(q, n, o))), K && Y && Y.name !== p && (J = !0, x = function() {
          return Y.call(this);
        }), (!s || S) && (V || J || !T[n]) && h(T, n, x), e[d] = x, e[F] = o, m)
          if (w = {
            values: K ? x : C(p),
            keys: R ? x : C(r),
            entries: H
          }, S)
            for (O in w)
              O in T || W(T, O, w[O]);
          else
            c(c.P + c.F * (V || J), d, w);
        return w;
      };
    },
    /* 89 */
    /***/
    function(Z, l) {
      Z.exports = !0;
    },
    /* 90 */
    /***/
    function(Z, l, i) {
      var s = i(91), c = i(92), W = i(93), h = i(95), e = i(105), a = "prototype", G = function(y, n, V) {
        var I = y & G.F, r = y & G.G, p = y & G.S, o = y & G.P, u = y & G.B, d = y & G.W, b = r ? c : c[n] || (c[n] = {}), t = b[a], m = r ? s : p ? s[n] : (s[n] || {})[a], R, S, C;
        r && (V = n);
        for (R in V)
          S = !I && m && m[R] !== void 0, !(S && e(b, R)) && (C = S ? m[R] : V[R], b[R] = r && typeof m[R] != "function" ? V[R] : u && S ? W(C, s) : d && m[R] == C ? function(F) {
            var K = function(J, T, Y) {
              if (this instanceof F) {
                switch (arguments.length) {
                  case 0:
                    return new F();
                  case 1:
                    return new F(J);
                  case 2:
                    return new F(J, T);
                }
                return new F(J, T, Y);
              }
              return F.apply(this, arguments);
            };
            return K[a] = F[a], K;
          }(C) : o && typeof C == "function" ? W(Function.call, C) : C, o && ((b.virtual || (b.virtual = {}))[R] = C, y & G.R && t && !t[R] && h(t, R, C)));
      };
      G.F = 1, G.G = 2, G.S = 4, G.P = 8, G.B = 16, G.W = 32, G.U = 64, G.R = 128, Z.exports = G;
    },
    /* 91 */
    /***/
    function(Z, l) {
      var i = Z.exports = typeof window < "u" && window.Math == Math ? window : typeof self < "u" && self.Math == Math ? self : Function("return this")();
      typeof __g == "number" && (__g = i);
    },
    /* 92 */
    /***/
    function(Z, l) {
      var i = Z.exports = { version: "2.6.11" };
      typeof __e == "number" && (__e = i);
    },
    /* 93 */
    /***/
    function(Z, l, i) {
      var s = i(94);
      Z.exports = function(c, W, h) {
        if (s(c), W === void 0)
          return c;
        switch (h) {
          case 1:
            return function(e) {
              return c.call(W, e);
            };
          case 2:
            return function(e, a) {
              return c.call(W, e, a);
            };
          case 3:
            return function(e, a, G) {
              return c.call(W, e, a, G);
            };
        }
        return function() {
          return c.apply(W, arguments);
        };
      };
    },
    /* 94 */
    /***/
    function(Z, l) {
      Z.exports = function(i) {
        if (typeof i != "function")
          throw TypeError(i + " is not a function!");
        return i;
      };
    },
    /* 95 */
    /***/
    function(Z, l, i) {
      var s = i(96), c = i(104);
      Z.exports = i(100) ? function(W, h, e) {
        return s.f(W, h, c(1, e));
      } : function(W, h, e) {
        return W[h] = e, W;
      };
    },
    /* 96 */
    /***/
    function(Z, l, i) {
      var s = i(97), c = i(99), W = i(103), h = Object.defineProperty;
      l.f = i(100) ? Object.defineProperty : function(a, G, y) {
        if (s(a), G = W(G, !0), s(y), c)
          try {
            return h(a, G, y);
          } catch {
          }
        if ("get" in y || "set" in y)
          throw TypeError("Accessors not supported!");
        return "value" in y && (a[G] = y.value), a;
      };
    },
    /* 97 */
    /***/
    function(Z, l, i) {
      var s = i(98);
      Z.exports = function(c) {
        if (!s(c))
          throw TypeError(c + " is not an object!");
        return c;
      };
    },
    /* 98 */
    /***/
    function(Z, l) {
      Z.exports = function(i) {
        return typeof i == "object" ? i !== null : typeof i == "function";
      };
    },
    /* 99 */
    /***/
    function(Z, l, i) {
      Z.exports = !i(100) && !i(101)(function() {
        return Object.defineProperty(i(102)("div"), "a", { get: function() {
          return 7;
        } }).a != 7;
      });
    },
    /* 100 */
    /***/
    function(Z, l, i) {
      Z.exports = !i(101)(function() {
        return Object.defineProperty({}, "a", { get: function() {
          return 7;
        } }).a != 7;
      });
    },
    /* 101 */
    /***/
    function(Z, l) {
      Z.exports = function(i) {
        try {
          return !!i();
        } catch {
          return !0;
        }
      };
    },
    /* 102 */
    /***/
    function(Z, l, i) {
      var s = i(98), c = i(91).document, W = s(c) && s(c.createElement);
      Z.exports = function(h) {
        return W ? c.createElement(h) : {};
      };
    },
    /* 103 */
    /***/
    function(Z, l, i) {
      var s = i(98);
      Z.exports = function(c, W) {
        if (!s(c))
          return c;
        var h, e;
        if (W && typeof (h = c.toString) == "function" && !s(e = h.call(c)) || typeof (h = c.valueOf) == "function" && !s(e = h.call(c)) || !W && typeof (h = c.toString) == "function" && !s(e = h.call(c)))
          return e;
        throw TypeError("Can't convert object to primitive value");
      };
    },
    /* 104 */
    /***/
    function(Z, l) {
      Z.exports = function(i, s) {
        return {
          enumerable: !(i & 1),
          configurable: !(i & 2),
          writable: !(i & 4),
          value: s
        };
      };
    },
    /* 105 */
    /***/
    function(Z, l) {
      var i = {}.hasOwnProperty;
      Z.exports = function(s, c) {
        return i.call(s, c);
      };
    },
    /* 106 */
    /***/
    function(Z, l, i) {
      Z.exports = i(95);
    },
    /* 107 */
    /***/
    function(Z, l, i) {
      var s = i(108), c = i(104), W = i(121), h = {};
      i(95)(h, i(122)("iterator"), function() {
        return this;
      }), Z.exports = function(e, a, G) {
        e.prototype = s(h, { next: c(1, G) }), W(e, a + " Iterator");
      };
    },
    /* 108 */
    /***/
    function(Z, l, i) {
      var s = i(97), c = i(109), W = i(119), h = i(116)("IE_PROTO"), e = function() {
      }, a = "prototype", G = function() {
        var y = i(102)("iframe"), n = W.length, V = "<", I = ">", r;
        for (y.style.display = "none", i(120).appendChild(y), y.src = "javascript:", r = y.contentWindow.document, r.open(), r.write(V + "script" + I + "document.F=Object" + V + "/script" + I), r.close(), G = r.F; n--; )
          delete G[a][W[n]];
        return G();
      };
      Z.exports = Object.create || function(n, V) {
        var I;
        return n !== null ? (e[a] = s(n), I = new e(), e[a] = null, I[h] = n) : I = G(), V === void 0 ? I : c(I, V);
      };
    },
    /* 109 */
    /***/
    function(Z, l, i) {
      var s = i(96), c = i(97), W = i(110);
      Z.exports = i(100) ? Object.defineProperties : function(e, a) {
        c(e);
        for (var G = W(a), y = G.length, n = 0, V; y > n; )
          s.f(e, V = G[n++], a[V]);
        return e;
      };
    },
    /* 110 */
    /***/
    function(Z, l, i) {
      var s = i(111), c = i(119);
      Z.exports = Object.keys || function(h) {
        return s(h, c);
      };
    },
    /* 111 */
    /***/
    function(Z, l, i) {
      var s = i(105), c = i(84), W = i(112)(!1), h = i(116)("IE_PROTO");
      Z.exports = function(e, a) {
        var G = c(e), y = 0, n = [], V;
        for (V in G)
          V != h && s(G, V) && n.push(V);
        for (; a.length > y; )
          s(G, V = a[y++]) && (~W(n, V) || n.push(V));
        return n;
      };
    },
    /* 112 */
    /***/
    function(Z, l, i) {
      var s = i(84), c = i(113), W = i(115);
      Z.exports = function(h) {
        return function(e, a, G) {
          var y = s(e), n = c(y.length), V = W(G, n), I;
          if (h && a != a) {
            for (; n > V; )
              if (I = y[V++], I != I)
                return !0;
          } else
            for (; n > V; V++)
              if ((h || V in y) && y[V] === a)
                return h || V || 0;
          return !h && -1;
        };
      };
    },
    /* 113 */
    /***/
    function(Z, l, i) {
      var s = i(114), c = Math.min;
      Z.exports = function(W) {
        return W > 0 ? c(s(W), 9007199254740991) : 0;
      };
    },
    /* 114 */
    /***/
    function(Z, l) {
      var i = Math.ceil, s = Math.floor;
      Z.exports = function(c) {
        return isNaN(c = +c) ? 0 : (c > 0 ? s : i)(c);
      };
    },
    /* 115 */
    /***/
    function(Z, l, i) {
      var s = i(114), c = Math.max, W = Math.min;
      Z.exports = function(h, e) {
        return h = s(h), h < 0 ? c(h + e, 0) : W(h, e);
      };
    },
    /* 116 */
    /***/
    function(Z, l, i) {
      var s = i(117)("keys"), c = i(118);
      Z.exports = function(W) {
        return s[W] || (s[W] = c(W));
      };
    },
    /* 117 */
    /***/
    function(Z, l, i) {
      var s = i(92), c = i(91), W = "__core-js_shared__", h = c[W] || (c[W] = {});
      (Z.exports = function(e, a) {
        return h[e] || (h[e] = a !== void 0 ? a : {});
      })("versions", []).push({
        version: s.version,
        mode: i(89) ? "pure" : "global",
        copyright: "© 2019 Denis Pushkarev (zloirock.ru)"
      });
    },
    /* 118 */
    /***/
    function(Z, l) {
      var i = 0, s = Math.random();
      Z.exports = function(c) {
        return "Symbol(".concat(c === void 0 ? "" : c, ")_", (++i + s).toString(36));
      };
    },
    /* 119 */
    /***/
    function(Z, l) {
      Z.exports = "constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",");
    },
    /* 120 */
    /***/
    function(Z, l, i) {
      var s = i(91).document;
      Z.exports = s && s.documentElement;
    },
    /* 121 */
    /***/
    function(Z, l, i) {
      var s = i(96).f, c = i(105), W = i(122)("toStringTag");
      Z.exports = function(h, e, a) {
        h && !c(h = a ? h : h.prototype, W) && s(h, W, { configurable: !0, value: e });
      };
    },
    /* 122 */
    /***/
    function(Z, l, i) {
      var s = i(117)("wks"), c = i(118), W = i(91).Symbol, h = typeof W == "function", e = Z.exports = function(a) {
        return s[a] || (s[a] = h && W[a] || (h ? W : c)("Symbol." + a));
      };
      e.store = s;
    },
    /* 123 */
    /***/
    function(Z, l, i) {
      var s = i(105), c = i(124), W = i(116)("IE_PROTO"), h = Object.prototype;
      Z.exports = Object.getPrototypeOf || function(e) {
        return e = c(e), s(e, W) ? e[W] : typeof e.constructor == "function" && e instanceof e.constructor ? e.constructor.prototype : e instanceof Object ? h : null;
      };
    },
    /* 124 */
    /***/
    function(Z, l, i) {
      var s = i(87);
      Z.exports = function(c) {
        return Object(s(c));
      };
    },
    /* 125 */
    /***/
    function(Z, l, i) {
      var s = i(126)(!0);
      i(88)(String, "String", function(c) {
        this._t = String(c), this._i = 0;
      }, function() {
        var c = this._t, W = this._i, h;
        return W >= c.length ? { value: void 0, done: !0 } : (h = s(c, W), this._i += h.length, { value: h, done: !1 });
      });
    },
    /* 126 */
    /***/
    function(Z, l, i) {
      var s = i(114), c = i(87);
      Z.exports = function(W) {
        return function(h, e) {
          var a = String(c(h)), G = s(e), y = a.length, n, V;
          return G < 0 || G >= y ? W ? "" : void 0 : (n = a.charCodeAt(G), n < 55296 || n > 56319 || G + 1 === y || (V = a.charCodeAt(G + 1)) < 56320 || V > 57343 ? W ? a.charAt(G) : n : W ? a.slice(G, G + 2) : (n - 55296 << 10) + (V - 56320) + 65536);
        };
      };
    },
    /* 127 */
    /***/
    function(Z, l, i) {
      var s = i(128), c = i(122)("iterator"), W = i(83);
      Z.exports = i(92).isIterable = function(h) {
        var e = Object(h);
        return e[c] !== void 0 || "@@iterator" in e || W.hasOwnProperty(s(e));
      };
    },
    /* 128 */
    /***/
    function(Z, l, i) {
      var s = i(86), c = i(122)("toStringTag"), W = s(/* @__PURE__ */ function() {
        return arguments;
      }()) == "Arguments", h = function(e, a) {
        try {
          return e[a];
        } catch {
        }
      };
      Z.exports = function(e) {
        var a, G, y;
        return e === void 0 ? "Undefined" : e === null ? "Null" : typeof (G = h(a = Object(e), c)) == "string" ? G : W ? s(a) : (y = s(a)) == "Object" && typeof a.callee == "function" ? "Arguments" : y;
      };
    },
    /* 129 */
    /***/
    function(Z, l, i) {
      Z.exports = { default: i(130), __esModule: !0 };
    },
    /* 130 */
    /***/
    function(Z, l, i) {
      i(79), i(125), Z.exports = i(131);
    },
    /* 131 */
    /***/
    function(Z, l, i) {
      var s = i(97), c = i(132);
      Z.exports = i(92).getIterator = function(W) {
        var h = c(W);
        if (typeof h != "function")
          throw TypeError(W + " is not iterable!");
        return s(h.call(W));
      };
    },
    /* 132 */
    /***/
    function(Z, l, i) {
      var s = i(128), c = i(122)("iterator"), W = i(83);
      Z.exports = i(92).getIteratorMethod = function(h) {
        if (h != null)
          return h[c] || h["@@iterator"] || W[s(h)];
      };
    },
    /* 133 */
    /***/
    function(Z, l, i) {
      l.__esModule = !0;
      var s = i(134), c = W(s);
      function W(h) {
        return h && h.__esModule ? h : { default: h };
      }
      l.default = function(h) {
        if (Array.isArray(h)) {
          for (var e = 0, a = Array(h.length); e < h.length; e++)
            a[e] = h[e];
          return a;
        } else
          return (0, c.default)(h);
      };
    },
    /* 134 */
    /***/
    function(Z, l, i) {
      Z.exports = { default: i(135), __esModule: !0 };
    },
    /* 135 */
    /***/
    function(Z, l, i) {
      i(125), i(136), Z.exports = i(92).Array.from;
    },
    /* 136 */
    /***/
    function(Z, l, i) {
      var s = i(93), c = i(90), W = i(124), h = i(137), e = i(138), a = i(113), G = i(139), y = i(132);
      c(c.S + c.F * !i(140)(function(n) {
        Array.from(n);
      }), "Array", {
        // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
        from: function(V) {
          var I = W(V), r = typeof this == "function" ? this : Array, p = arguments.length, o = p > 1 ? arguments[1] : void 0, u = o !== void 0, d = 0, b = y(I), t, m, R, S;
          if (u && (o = s(o, p > 2 ? arguments[2] : void 0, 2)), b != null && !(r == Array && e(b)))
            for (S = b.call(I), m = new r(); !(R = S.next()).done; d++)
              G(m, d, u ? h(S, o, [R.value, d], !0) : R.value);
          else
            for (t = a(I.length), m = new r(t); t > d; d++)
              G(m, d, u ? o(I[d], d) : I[d]);
          return m.length = d, m;
        }
      });
    },
    /* 137 */
    /***/
    function(Z, l, i) {
      var s = i(97);
      Z.exports = function(c, W, h, e) {
        try {
          return e ? W(s(h)[0], h[1]) : W(h);
        } catch (G) {
          var a = c.return;
          throw a !== void 0 && s(a.call(c)), G;
        }
      };
    },
    /* 138 */
    /***/
    function(Z, l, i) {
      var s = i(83), c = i(122)("iterator"), W = Array.prototype;
      Z.exports = function(h) {
        return h !== void 0 && (s.Array === h || W[c] === h);
      };
    },
    /* 139 */
    /***/
    function(Z, l, i) {
      var s = i(96), c = i(104);
      Z.exports = function(W, h, e) {
        h in W ? s.f(W, h, c(0, e)) : W[h] = e;
      };
    },
    /* 140 */
    /***/
    function(Z, l, i) {
      var s = i(122)("iterator"), c = !1;
      try {
        var W = [7][s]();
        W.return = function() {
          c = !0;
        }, Array.from(W, function() {
          throw 2;
        });
      } catch {
      }
      Z.exports = function(h, e) {
        if (!e && !c)
          return !1;
        var a = !1;
        try {
          var G = [7], y = G[s]();
          y.next = function() {
            return { done: a = !0 };
          }, G[s] = function() {
            return y;
          }, h(G);
        } catch {
        }
        return a;
      };
    },
    /* 141 */
    /***/
    function(Z, l, i) {
      Z.exports = { default: i(142), __esModule: !0 };
    },
    /* 142 */
    /***/
    function(Z, l, i) {
      i(143), i(125), i(79), i(144), i(157), i(160), i(162), Z.exports = i(92).Map;
    },
    /* 143 */
    /***/
    function(Z, l) {
    },
    /* 144 */
    /***/
    function(Z, l, i) {
      var s = i(145), c = i(151), W = "Map";
      Z.exports = i(152)(W, function(h) {
        return function() {
          return h(this, arguments.length > 0 ? arguments[0] : void 0);
        };
      }, {
        // 23.1.3.6 Map.prototype.get(key)
        get: function(e) {
          var a = s.getEntry(c(this, W), e);
          return a && a.v;
        },
        // 23.1.3.9 Map.prototype.set(key, value)
        set: function(e, a) {
          return s.def(c(this, W), e === 0 ? 0 : e, a);
        }
      }, s, !0);
    },
    /* 145 */
    /***/
    function(Z, l, i) {
      var s = i(96).f, c = i(108), W = i(146), h = i(93), e = i(147), a = i(148), G = i(88), y = i(82), n = i(149), V = i(100), I = i(150).fastKey, r = i(151), p = V ? "_s" : "size", o = function(u, d) {
        var b = I(d), t;
        if (b !== "F")
          return u._i[b];
        for (t = u._f; t; t = t.n)
          if (t.k == d)
            return t;
      };
      Z.exports = {
        getConstructor: function(u, d, b, t) {
          var m = u(function(R, S) {
            e(R, m, d, "_i"), R._t = d, R._i = c(null), R._f = void 0, R._l = void 0, R[p] = 0, S != null && a(S, b, R[t], R);
          });
          return W(m.prototype, {
            // 23.1.3.1 Map.prototype.clear()
            // 23.2.3.2 Set.prototype.clear()
            clear: function() {
              for (var S = r(this, d), C = S._i, F = S._f; F; F = F.n)
                F.r = !0, F.p && (F.p = F.p.n = void 0), delete C[F.i];
              S._f = S._l = void 0, S[p] = 0;
            },
            // 23.1.3.3 Map.prototype.delete(key)
            // 23.2.3.4 Set.prototype.delete(value)
            delete: function(R) {
              var S = r(this, d), C = o(S, R);
              if (C) {
                var F = C.n, K = C.p;
                delete S._i[C.i], C.r = !0, K && (K.n = F), F && (F.p = K), S._f == C && (S._f = F), S._l == C && (S._l = K), S[p]--;
              }
              return !!C;
            },
            // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
            // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
            forEach: function(S) {
              r(this, d);
              for (var C = h(S, arguments.length > 1 ? arguments[1] : void 0, 3), F; F = F ? F.n : this._f; )
                for (C(F.v, F.k, this); F && F.r; )
                  F = F.p;
            },
            // 23.1.3.7 Map.prototype.has(key)
            // 23.2.3.7 Set.prototype.has(value)
            has: function(S) {
              return !!o(r(this, d), S);
            }
          }), V && s(m.prototype, "size", {
            get: function() {
              return r(this, d)[p];
            }
          }), m;
        },
        def: function(u, d, b) {
          var t = o(u, d), m, R;
          return t ? t.v = b : (u._l = t = {
            i: R = I(d, !0),
            // <- index
            k: d,
            // <- key
            v: b,
            // <- value
            p: m = u._l,
            // <- previous entry
            n: void 0,
            // <- next entry
            r: !1
            // <- removed
          }, u._f || (u._f = t), m && (m.n = t), u[p]++, R !== "F" && (u._i[R] = t)), u;
        },
        getEntry: o,
        setStrong: function(u, d, b) {
          G(u, d, function(t, m) {
            this._t = r(t, d), this._k = m, this._l = void 0;
          }, function() {
            for (var t = this, m = t._k, R = t._l; R && R.r; )
              R = R.p;
            return !t._t || !(t._l = R = R ? R.n : t._t._f) ? (t._t = void 0, y(1)) : m == "keys" ? y(0, R.k) : m == "values" ? y(0, R.v) : y(0, [R.k, R.v]);
          }, b ? "entries" : "values", !b, !0), n(d);
        }
      };
    },
    /* 146 */
    /***/
    function(Z, l, i) {
      var s = i(95);
      Z.exports = function(c, W, h) {
        for (var e in W)
          h && c[e] ? c[e] = W[e] : s(c, e, W[e]);
        return c;
      };
    },
    /* 147 */
    /***/
    function(Z, l) {
      Z.exports = function(i, s, c, W) {
        if (!(i instanceof s) || W !== void 0 && W in i)
          throw TypeError(c + ": incorrect invocation!");
        return i;
      };
    },
    /* 148 */
    /***/
    function(Z, n, i) {
      var s = i(93), c = i(137), W = i(138), h = i(97), e = i(113), a = i(132), G = {}, y = {}, n = Z.exports = function(V, I, r, p, o) {
        var u = o ? function() {
          return V;
        } : a(V), d = s(r, p, I ? 2 : 1), b = 0, t, m, R, S;
        if (typeof u != "function")
          throw TypeError(V + " is not iterable!");
        if (W(u)) {
          for (t = e(V.length); t > b; b++)
            if (S = I ? d(h(m = V[b])[0], m[1]) : d(V[b]), S === G || S === y)
              return S;
        } else
          for (R = u.call(V); !(m = R.next()).done; )
            if (S = c(R, d, m.value, I), S === G || S === y)
              return S;
      };
      n.BREAK = G, n.RETURN = y;
    },
    /* 149 */
    /***/
    function(Z, l, i) {
      var s = i(91), c = i(92), W = i(96), h = i(100), e = i(122)("species");
      Z.exports = function(a) {
        var G = typeof c[a] == "function" ? c[a] : s[a];
        h && G && !G[e] && W.f(G, e, {
          configurable: !0,
          get: function() {
            return this;
          }
        });
      };
    },
    /* 150 */
    /***/
    function(Z, l, i) {
      var s = i(118)("meta"), c = i(98), W = i(105), h = i(96).f, e = 0, a = Object.isExtensible || function() {
        return !0;
      }, G = !i(101)(function() {
        return a(Object.preventExtensions({}));
      }), y = function(p) {
        h(p, s, { value: {
          i: "O" + ++e,
          // object ID
          w: {}
          // weak collections IDs
        } });
      }, n = function(p, o) {
        if (!c(p))
          return typeof p == "symbol" ? p : (typeof p == "string" ? "S" : "P") + p;
        if (!W(p, s)) {
          if (!a(p))
            return "F";
          if (!o)
            return "E";
          y(p);
        }
        return p[s].i;
      }, V = function(p, o) {
        if (!W(p, s)) {
          if (!a(p))
            return !0;
          if (!o)
            return !1;
          y(p);
        }
        return p[s].w;
      }, I = function(p) {
        return G && r.NEED && a(p) && !W(p, s) && y(p), p;
      }, r = Z.exports = {
        KEY: s,
        NEED: !1,
        fastKey: n,
        getWeak: V,
        onFreeze: I
      };
    },
    /* 151 */
    /***/
    function(Z, l, i) {
      var s = i(98);
      Z.exports = function(c, W) {
        if (!s(c) || c._t !== W)
          throw TypeError("Incompatible receiver, " + W + " required!");
        return c;
      };
    },
    /* 152 */
    /***/
    function(Z, l, i) {
      var s = i(91), c = i(90), W = i(150), h = i(101), e = i(95), a = i(146), G = i(148), y = i(147), n = i(98), V = i(121), I = i(96).f, r = i(153)(0), p = i(100);
      Z.exports = function(o, u, d, b, t, m) {
        var R = s[o], S = R, C = t ? "set" : "add", F = S && S.prototype, K = {};
        return !p || typeof S != "function" || !(m || F.forEach && !h(function() {
          new S().entries().next();
        })) ? (S = b.getConstructor(u, o, t, C), a(S.prototype, d), W.NEED = !0) : (S = u(function(J, T) {
          y(J, S, o, "_c"), J._c = new R(), T != null && G(T, t, J[C], J);
        }), r("add,clear,delete,forEach,get,has,set,keys,values,entries,toJSON".split(","), function(J) {
          var T = J == "add" || J == "set";
          J in F && !(m && J == "clear") && e(S.prototype, J, function(Y, x) {
            if (y(this, S, J), !T && m && !n(Y))
              return J == "get" ? void 0 : !1;
            var H = this._c[J](Y === 0 ? 0 : Y, x);
            return T ? this : H;
          });
        }), m || I(S.prototype, "size", {
          get: function() {
            return this._c.size;
          }
        })), V(S, o), K[o] = S, c(c.G + c.W + c.F, K), m || b.setStrong(S, o, t), S;
      };
    },
    /* 153 */
    /***/
    function(Z, l, i) {
      var s = i(93), c = i(85), W = i(124), h = i(113), e = i(154);
      Z.exports = function(a, G) {
        var y = a == 1, n = a == 2, V = a == 3, I = a == 4, r = a == 6, p = a == 5 || r, o = G || e;
        return function(u, d, b) {
          for (var t = W(u), m = c(t), R = s(d, b, 3), S = h(m.length), C = 0, F = y ? o(u, S) : n ? o(u, 0) : void 0, K, J; S > C; C++)
            if ((p || C in m) && (K = m[C], J = R(K, C, t), a)) {
              if (y)
                F[C] = J;
              else if (J)
                switch (a) {
                  case 3:
                    return !0;
                  case 5:
                    return K;
                  case 6:
                    return C;
                  case 2:
                    F.push(K);
                }
              else if (I)
                return !1;
            }
          return r ? -1 : V || I ? I : F;
        };
      };
    },
    /* 154 */
    /***/
    function(Z, l, i) {
      var s = i(155);
      Z.exports = function(c, W) {
        return new (s(c))(W);
      };
    },
    /* 155 */
    /***/
    function(Z, l, i) {
      var s = i(98), c = i(156), W = i(122)("species");
      Z.exports = function(h) {
        var e;
        return c(h) && (e = h.constructor, typeof e == "function" && (e === Array || c(e.prototype)) && (e = void 0), s(e) && (e = e[W], e === null && (e = void 0))), e === void 0 ? Array : e;
      };
    },
    /* 156 */
    /***/
    function(Z, l, i) {
      var s = i(86);
      Z.exports = Array.isArray || function(W) {
        return s(W) == "Array";
      };
    },
    /* 157 */
    /***/
    function(Z, l, i) {
      var s = i(90);
      s(s.P + s.R, "Map", { toJSON: i(158)("Map") });
    },
    /* 158 */
    /***/
    function(Z, l, i) {
      var s = i(128), c = i(159);
      Z.exports = function(W) {
        return function() {
          if (s(this) != W)
            throw TypeError(W + "#toJSON isn't generic");
          return c(this);
        };
      };
    },
    /* 159 */
    /***/
    function(Z, l, i) {
      var s = i(148);
      Z.exports = function(c, W) {
        var h = [];
        return s(c, !1, h.push, h, W), h;
      };
    },
    /* 160 */
    /***/
    function(Z, l, i) {
      i(161)("Map");
    },
    /* 161 */
    /***/
    function(Z, l, i) {
      var s = i(90);
      Z.exports = function(c) {
        s(s.S, c, { of: function() {
          for (var h = arguments.length, e = new Array(h); h--; )
            e[h] = arguments[h];
          return new this(e);
        } });
      };
    },
    /* 162 */
    /***/
    function(Z, l, i) {
      i(163)("Map");
    },
    /* 163 */
    /***/
    function(Z, l, i) {
      var s = i(90), c = i(94), W = i(93), h = i(148);
      Z.exports = function(e) {
        s(s.S, e, { from: function(G) {
          var y = arguments[1], n, V, I, r;
          return c(this), n = y !== void 0, n && c(y), G == null ? new this() : (V = [], n ? (I = 0, r = W(y, arguments[2], 2), h(G, !1, function(p) {
            V.push(r(p, I++));
          })) : h(G, !1, V.push, V), new this(V));
        } });
      };
    },
    /* 164 */
    /***/
    function(Z, l, i) {
      Z.exports = { default: i(165), __esModule: !0 };
    },
    /* 165 */
    /***/
    function(Z, l, i) {
      i(166), Z.exports = i(92).Object.assign;
    },
    /* 166 */
    /***/
    function(Z, l, i) {
      var s = i(90);
      s(s.S + s.F, "Object", { assign: i(167) });
    },
    /* 167 */
    /***/
    function(Z, l, i) {
      var s = i(100), c = i(110), W = i(168), h = i(169), e = i(124), a = i(85), G = Object.assign;
      Z.exports = !G || i(101)(function() {
        var y = {}, n = {}, V = Symbol(), I = "abcdefghijklmnopqrst";
        return y[V] = 7, I.split("").forEach(function(r) {
          n[r] = r;
        }), G({}, y)[V] != 7 || Object.keys(G({}, n)).join("") != I;
      }) ? function(n, V) {
        for (var I = e(n), r = arguments.length, p = 1, o = W.f, u = h.f; r > p; )
          for (var d = a(arguments[p++]), b = o ? c(d).concat(o(d)) : c(d), t = b.length, m = 0, R; t > m; )
            R = b[m++], (!s || u.call(d, R)) && (I[R] = d[R]);
        return I;
      } : G;
    },
    /* 168 */
    /***/
    function(Z, l) {
      l.f = Object.getOwnPropertySymbols;
    },
    /* 169 */
    /***/
    function(Z, l) {
      l.f = {}.propertyIsEnumerable;
    },
    /* 170 */
    /***/
    function(Z, l, i) {
      l.__esModule = !0, l.default = function(s, c) {
        if (!(s instanceof c))
          throw new TypeError("Cannot call a class as a function");
      };
    },
    /* 171 */
    /***/
    function(Z, l, i) {
      l.__esModule = !0;
      var s = i(172), c = W(s);
      function W(h) {
        return h && h.__esModule ? h : { default: h };
      }
      l.default = /* @__PURE__ */ function() {
        function h(e, a) {
          for (var G = 0; G < a.length; G++) {
            var y = a[G];
            y.enumerable = y.enumerable || !1, y.configurable = !0, "value" in y && (y.writable = !0), (0, c.default)(e, y.key, y);
          }
        }
        return function(e, a, G) {
          return a && h(e.prototype, a), G && h(e, G), e;
        };
      }();
    },
    /* 172 */
    /***/
    function(Z, l, i) {
      Z.exports = { default: i(173), __esModule: !0 };
    },
    /* 173 */
    /***/
    function(Z, l, i) {
      i(174);
      var s = i(92).Object;
      Z.exports = function(W, h, e) {
        return s.defineProperty(W, h, e);
      };
    },
    /* 174 */
    /***/
    function(Z, l, i) {
      var s = i(90);
      s(s.S + s.F * !i(100), "Object", { defineProperty: i(96).f });
    },
    /* 175 */
    /***/
    function(Z, l, i) {
      Z.exports = { default: i(176), __esModule: !0 };
    },
    /* 176 */
    /***/
    function(Z, l, i) {
      i(177), i(143), i(184), i(185), Z.exports = i(92).Symbol;
    },
    /* 177 */
    /***/
    function(Z, l, i) {
      var s = i(91), c = i(105), W = i(100), h = i(90), e = i(106), a = i(150).KEY, G = i(101), y = i(117), n = i(121), V = i(118), I = i(122), r = i(178), p = i(179), o = i(180), u = i(156), d = i(97), b = i(98), t = i(124), m = i(84), R = i(103), S = i(104), C = i(108), F = i(181), K = i(183), J = i(168), T = i(96), Y = i(110), x = K.f, H = T.f, Q = F.f, w = s.Symbol, O = s.JSON, q = O && O.stringify, k = "prototype", f = I("_hidden"), D = I("toPrimitive"), ii = {}.propertyIsEnumerable, _ = y("symbol-registry"), bi = y("symbols"), $ = y("op-symbols"), oi = Object[k], ni = typeof w == "function" && !!J.f, z = s.QObject, M = !z || !z[k] || !z[k].findChild, E = W && G(function() {
        return C(H({}, "a", {
          get: function() {
            return H(this, "a", { value: 7 }).a;
          }
        })).a != 7;
      }) ? function(ti, si, Zi) {
        var ai = x(oi, si);
        ai && delete oi[si], H(ti, si, Zi), ai && ti !== oi && H(oi, si, ai);
      } : H, B = function(ti) {
        var si = bi[ti] = C(w[k]);
        return si._k = ti, si;
      }, g = ni && typeof w.iterator == "symbol" ? function(ti) {
        return typeof ti == "symbol";
      } : function(ti) {
        return ti instanceof w;
      }, U = function(si, Zi, ai) {
        return si === oi && U($, Zi, ai), d(si), Zi = R(Zi, !0), d(ai), c(bi, Zi) ? (ai.enumerable ? (c(si, f) && si[f][Zi] && (si[f][Zi] = !1), ai = C(ai, { enumerable: S(0, !1) })) : (c(si, f) || H(si, f, S(1, {})), si[f][Zi] = !0), E(si, Zi, ai)) : H(si, Zi, ai);
      }, X = function(si, Zi) {
        d(si);
        for (var ai = o(Zi = m(Zi)), ei = 0, Xi = ai.length, ui; Xi > ei; )
          U(si, ui = ai[ei++], Zi[ui]);
        return si;
      }, L = function(si, Zi) {
        return Zi === void 0 ? C(si) : X(C(si), Zi);
      }, N = function(si) {
        var Zi = ii.call(this, si = R(si, !0));
        return this === oi && c(bi, si) && !c($, si) ? !1 : Zi || !c(this, si) || !c(bi, si) || c(this, f) && this[f][si] ? Zi : !0;
      }, v = function(si, Zi) {
        if (si = m(si), Zi = R(Zi, !0), !(si === oi && c(bi, Zi) && !c($, Zi))) {
          var ai = x(si, Zi);
          return ai && c(bi, Zi) && !(c(si, f) && si[f][Zi]) && (ai.enumerable = !0), ai;
        }
      }, P = function(si) {
        for (var Zi = Q(m(si)), ai = [], ei = 0, Xi; Zi.length > ei; )
          !c(bi, Xi = Zi[ei++]) && Xi != f && Xi != a && ai.push(Xi);
        return ai;
      }, j = function(si) {
        for (var Zi = si === oi, ai = Q(Zi ? $ : m(si)), ei = [], Xi = 0, ui; ai.length > Xi; )
          c(bi, ui = ai[Xi++]) && (!Zi || c(oi, ui)) && ei.push(bi[ui]);
        return ei;
      };
      ni || (w = function() {
        if (this instanceof w)
          throw TypeError("Symbol is not a constructor!");
        var si = V(arguments.length > 0 ? arguments[0] : void 0), Zi = function(ai) {
          this === oi && Zi.call($, ai), c(this, f) && c(this[f], si) && (this[f][si] = !1), E(this, si, S(1, ai));
        };
        return W && M && E(oi, si, { configurable: !0, set: Zi }), B(si);
      }, e(w[k], "toString", function() {
        return this._k;
      }), K.f = v, T.f = U, i(182).f = F.f = P, i(169).f = N, J.f = j, W && !i(89) && e(oi, "propertyIsEnumerable", N, !0), r.f = function(ti) {
        return B(I(ti));
      }), h(h.G + h.W + h.F * !ni, { Symbol: w });
      for (var A = (
        // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
        "hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(",")
      ), li = 0; A.length > li; )
        I(A[li++]);
      for (var di = Y(I.store), ci = 0; di.length > ci; )
        p(di[ci++]);
      h(h.S + h.F * !ni, "Symbol", {
        // 19.4.2.1 Symbol.for(key)
        for: function(ti) {
          return c(_, ti += "") ? _[ti] : _[ti] = w(ti);
        },
        // 19.4.2.5 Symbol.keyFor(sym)
        keyFor: function(si) {
          if (!g(si))
            throw TypeError(si + " is not a symbol!");
          for (var Zi in _)
            if (_[Zi] === si)
              return Zi;
        },
        useSetter: function() {
          M = !0;
        },
        useSimple: function() {
          M = !1;
        }
      }), h(h.S + h.F * !ni, "Object", {
        // 19.1.2.2 Object.create(O [, Properties])
        create: L,
        // 19.1.2.4 Object.defineProperty(O, P, Attributes)
        defineProperty: U,
        // 19.1.2.3 Object.defineProperties(O, Properties)
        defineProperties: X,
        // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
        getOwnPropertyDescriptor: v,
        // 19.1.2.7 Object.getOwnPropertyNames(O)
        getOwnPropertyNames: P,
        // 19.1.2.8 Object.getOwnPropertySymbols(O)
        getOwnPropertySymbols: j
      });
      var mi = G(function() {
        J.f(1);
      });
      h(h.S + h.F * mi, "Object", {
        getOwnPropertySymbols: function(si) {
          return J.f(t(si));
        }
      }), O && h(h.S + h.F * (!ni || G(function() {
        var ti = w();
        return q([ti]) != "[null]" || q({ a: ti }) != "{}" || q(Object(ti)) != "{}";
      })), "JSON", {
        stringify: function(si) {
          for (var Zi = [si], ai = 1, ei, Xi; arguments.length > ai; )
            Zi.push(arguments[ai++]);
          if (Xi = ei = Zi[1], !(!b(ei) && si === void 0 || g(si)))
            return u(ei) || (ei = function(ui, ri) {
              if (typeof Xi == "function" && (ri = Xi.call(this, ui, ri)), !g(ri))
                return ri;
            }), Zi[1] = ei, q.apply(O, Zi);
        }
      }), w[k][D] || i(95)(w[k], D, w[k].valueOf), n(w, "Symbol"), n(Math, "Math", !0), n(s.JSON, "JSON", !0);
    },
    /* 178 */
    /***/
    function(Z, l, i) {
      l.f = i(122);
    },
    /* 179 */
    /***/
    function(Z, l, i) {
      var s = i(91), c = i(92), W = i(89), h = i(178), e = i(96).f;
      Z.exports = function(a) {
        var G = c.Symbol || (c.Symbol = W ? {} : s.Symbol || {});
        a.charAt(0) != "_" && !(a in G) && e(G, a, { value: h.f(a) });
      };
    },
    /* 180 */
    /***/
    function(Z, l, i) {
      var s = i(110), c = i(168), W = i(169);
      Z.exports = function(h) {
        var e = s(h), a = c.f;
        if (a)
          for (var G = a(h), y = W.f, n = 0, V; G.length > n; )
            y.call(h, V = G[n++]) && e.push(V);
        return e;
      };
    },
    /* 181 */
    /***/
    function(Z, l, i) {
      var s = i(84), c = i(182).f, W = {}.toString, h = typeof window == "object" && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [], e = function(a) {
        try {
          return c(a);
        } catch {
          return h.slice();
        }
      };
      Z.exports.f = function(G) {
        return h && W.call(G) == "[object Window]" ? e(G) : c(s(G));
      };
    },
    /* 182 */
    /***/
    function(Z, l, i) {
      var s = i(111), c = i(119).concat("length", "prototype");
      l.f = Object.getOwnPropertyNames || function(h) {
        return s(h, c);
      };
    },
    /* 183 */
    /***/
    function(Z, l, i) {
      var s = i(169), c = i(104), W = i(84), h = i(103), e = i(105), a = i(99), G = Object.getOwnPropertyDescriptor;
      l.f = i(100) ? G : function(n, V) {
        if (n = W(n), V = h(V, !0), a)
          try {
            return G(n, V);
          } catch {
          }
        if (e(n, V))
          return c(!s.f.call(n, V), n[V]);
      };
    },
    /* 184 */
    /***/
    function(Z, l, i) {
      i(179)("asyncIterator");
    },
    /* 185 */
    /***/
    function(Z, l, i) {
      i(179)("observable");
    },
    /* 186 */
    /***/
    function(Z, l, i) {
      Object.defineProperty(l, "__esModule", {
        value: !0
      }), l.createNowTime = s, l.formatDelay = c;
      function s() {
        var W = null;
        return Date.now ? W = Date.now : W = function() {
          return (/* @__PURE__ */ new Date()).getTime();
        }, W;
      }
      function c(W) {
        return typeof W == "number" ? W = { delay: W } : "entropy" in W && (W = { delay: W.entropy, isEntropy: !0 }), W;
      }
    },
    /* 187 */
    /***/
    function(Z, l, i) {
      Object.defineProperty(l, "__esModule", {
        value: !0
      }), l.default = {
        // s - startFrame, e - endFrame
        default: function(c, W, h, e, a) {
          return typeof c == "number" && typeof W == "number" ? c + (h - e) / (a - e) * (W - c) : h - e > a - h ? W : c;
        }
      };
    },
    /* 188 */
    /***/
    function(Z, l, i) {
      Object.defineProperty(l, "__esModule", {
        value: !0
      }), l.parseEasing = l.Easings = void 0;
      var s = i(76), c = G(s), W = i(133), h = G(W), e = i(141), a = G(e);
      function G(u) {
        return u && u.__esModule ? u : { default: u };
      }
      var y = i(189), n = new a.default();
      function V() {
        for (var u = arguments.length, d = Array(u), b = 0; b < u; b++)
          d[b] = arguments[b];
        var t = n.get(d);
        return t || (t = y.apply(void 0, d), n.set(d, t), t);
      }
      function I(u) {
        var d = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "end";
        return function(b, t) {
          for (var m = 1; m < t.length; m++) {
            var R = t[m].offset;
            if (b <= R) {
              var S = t[m - 1].offset, C = R, F = (b - S) / (C - S), K = 1 / u, J = F / K;
              return d === "end" ? J = Math.floor(J) : J = Math.ceil(J), K * J * (C - S) + S;
            }
          }
          return 0;
        };
      }
      function r(u) {
        var d = /^cubic-bezier\((.*)\)/, b = u.match(d);
        if (b) {
          var t = b[1].trim();
          return t = t.split(",").map(function(K) {
            return parseFloat(K.trim());
          }), V.apply(void 0, (0, h.default)(t));
        }
        if (d = /^steps\((.*)\)/, b = u.match(d), b) {
          var m = b[1].trim();
          m = m.split(",").map(function(K) {
            return K.trim();
          });
          var R = m, S = (0, c.default)(R, 2), C = S[0], F = S[1];
          return I(parseInt(C, 10), F);
        }
        return u;
      }
      var p = {
        linear: function(d) {
          return d;
        },
        ease: V(0.25, 0.1, 0.25, 1),
        "ease-in": V(0.42, 0, 1, 1),
        "ease-out": V(0, 0, 0.58, 1),
        "ease-in-out": V(0.42, 0, 0.58, 1),
        // 'step-start': function(p, frames){
        //   let ret = 0
        //   for(let i = 0; i < frames.length; i++){
        //     const {offset} = frames[i]
        //     ret = offset
        //     if(p < offset){
        //       break
        //     }
        //   }
        //   return ret
        // },
        // 'step-end': function(p, frames){
        //   let ret = 0
        //   for(let i = 0; i < frames.length; i++){
        //     const {offset} = frames[i]
        //     if(p < offset){
        //       break
        //     }
        //     ret = offset
        //   }
        //   return ret
        // }
        "step-start": I(1, "start"),
        "step-end": I(1, "end")
      };
      function o(u) {
        return typeof u == "string" ? p[u] ? u = p[u] : u = r(u) : u.type === "cubic-bezier" ? u = V.apply(void 0, (0, h.default)(u.value)) : u.type === "steps" && (u = I(u.step, u.pos)), u;
      }
      l.Easings = p, l.parseEasing = o;
    },
    /* 189 */
    /***/
    function(Z, l) {
      var i = 4, s = 1e-3, c = 1e-7, W = 10, h = 11, e = 1 / (h - 1), a = typeof Float32Array == "function";
      function G(u, d) {
        return 1 - 3 * d + 3 * u;
      }
      function y(u, d) {
        return 3 * d - 6 * u;
      }
      function n(u) {
        return 3 * u;
      }
      function V(u, d, b) {
        return ((G(d, b) * u + y(d, b)) * u + n(d)) * u;
      }
      function I(u, d, b) {
        return 3 * G(d, b) * u * u + 2 * y(d, b) * u + n(d);
      }
      function r(u, d, b, t, m) {
        var R, S, C = 0;
        do
          S = d + (b - d) / 2, R = V(S, t, m) - u, R > 0 ? b = S : d = S;
        while (Math.abs(R) > c && ++C < W);
        return S;
      }
      function p(u, d, b, t) {
        for (var m = 0; m < i; ++m) {
          var R = I(d, b, t);
          if (R === 0)
            return d;
          var S = V(d, b, t) - u;
          d -= S / R;
        }
        return d;
      }
      function o(u) {
        return u;
      }
      Z.exports = function(d, b, t, m) {
        if (!(0 <= d && d <= 1 && 0 <= t && t <= 1))
          throw new Error("bezier x values must be in [0, 1] range");
        if (d === b && t === m)
          return o;
        for (var R = a ? new Float32Array(h) : new Array(h), S = 0; S < h; ++S)
          R[S] = V(S * e, d, t);
        function C(F) {
          for (var K = 0, J = 1, T = h - 1; J !== T && R[J] <= F; ++J)
            K += e;
          --J;
          var Y = (F - R[J]) / (R[J + 1] - R[J]), x = K + Y * e, H = I(x, d, t);
          return H >= s ? p(F, x, d, t) : H === 0 ? x : r(F, K, K + e, d, t);
        }
        return function(K) {
          return K === 0 ? 0 : K === 1 ? 1 : V(C(K), b, m);
        };
      };
    },
    /* 190 */
    /***/
    function(Z, l, i) {
      Object.defineProperty(l, "__esModule", {
        value: !0
      });
      var s = i(191), c = b(s), W = i(204), h = b(W), e = i(164), a = b(e), G = i(170), y = b(G), n = i(171), V = b(n), I = i(175), r = b(I), p = i(75), o = b(p), u = i(208), d = i(188);
      function b(H) {
        return H && H.__esModule ? H : { default: H };
      }
      var t = (0, r.default)("timing"), m = (0, r.default)("keyframes"), R = (0, r.default)("initState"), S = (0, r.default)("readyDefer"), C = (0, r.default)("finishedDefer"), F = (0, r.default)("effects"), K = (0, r.default)("activeReadyTimer"), J = (0, r.default)("activeFinishTimer"), T = (0, r.default)("removeDefer"), Y = {
        delay: 0,
        endDelay: 0,
        fill: "auto",
        iterations: 1,
        playbackRate: 1,
        direction: "normal",
        easing: "linear",
        effect: null
      }, x = function() {
        function H(Q, w, O) {
          var q = this;
          if ((0, y.default)(this, H), Array.isArray(Q)) {
            var k = [Q[0], Q, w];
            Q = k[0], w = k[1], O = k[2];
          }
          typeof O == "number" && (O = { duration: O }), this[t] = (0, a.default)({}, Y, O), this[t].easing = (0, d.parseEasing)(this[t].easing), this[m] = (0, u.calculateFramesOffset)(w);
          var f = this[m][this[m].length - 1];
          this[R] = {}, (0, h.default)(f).forEach(function(D) {
            Object.prototype.hasOwnProperty.call(Q, D) && D !== "easing" && D !== "offset" && (q[R][D] = Q[D]);
          }), this[m] = this[m].map(function(D) {
            return (0, a.default)({}, q[R], D);
          }), this[m][0].offset !== 0 && this[m].unshift((0, a.default)({}, this[R], { offset: 0 })), f.offset < 1 && this[m].push((0, a.default)({}, f, { offset: 1 })), this[F] = {}, this.timeline = null;
        }
        return (0, V.default)(H, [{
          key: "pause",
          value: function() {
            this.timeline.playbackRate = 0;
          }
        }, {
          key: K,
          value: function() {
            var w = this;
            this[S] && !this[S].timerID && (this.timeline.currentTime < 0 ? this[S].timerID = this.timeline.setTimeout(function() {
              w[S].resolve(), delete w[S];
            }, { delay: -this.timeline.currentTime, heading: !1 }) : this[S].timerID = this.timeline.setTimeout(function() {
              w[S].resolve(), delete w[S];
            }, { delay: 0, isEntropy: !0 }));
          }
        }, {
          key: J,
          value: function() {
            var w = this, O = this[t], q = O.duration, k = O.iterations, f = O.endDelay, D = Math.ceil(q * k + f - this.timeline.currentTime) + 1;
            this[C] && !this[C].timerID && (this[C].timerID = this.timeline.setTimeout(function() {
              w[C].resolve(), w[T](S), w[T](C);
            }, { delay: D, heading: !1 }), this[C].reverseTimerID = this.timeline.setTimeout(function() {
              w[C].resolve(), w[T](S), w[T](C), w.timeline = null;
            }, { delay: -this[t].delay - 1, heading: !1 }));
          }
        }, {
          key: "play",
          value: function() {
            if (this.playState === "finished" && this.cancel(), this.playState === "idle") {
              if (this.playbackRate <= 0)
                return;
              var w = this[t], O = w.delay, q = w.playbackRate, k = w.timeline;
              this.timeline = new o.default({
                originTime: O,
                playbackRate: q
              }, k), this[K](), this[J]();
            } else
              this.playState === "paused" && (this.timeline.playbackRate = this.playbackRate, this[K]());
          }
        }, {
          key: T,
          value: function(w) {
            var O = this[w], q = this.timeline;
            O && q && (q.clearTimeout(O.timerID), O.reverseTimerID && q.clearTimeout(O.reverseTimerID)), delete this[w];
          }
        }, {
          key: "cancel",
          value: function() {
            this[T](S), this[T](C), this.timeline = null;
          }
        }, {
          key: "finish",
          value: function() {
            this.timeline && (this.timeline.currentTime = 1 / 0 / this.playbackRate), this[T](S), this[T](C);
          }
        }, {
          key: "applyEffects",
          value: function(w) {
            return (0, a.default)(this[F], w);
          }
        }, {
          key: "playbackRate",
          get: function() {
            return this[t].playbackRate;
          },
          set: function(w) {
            this.timeline && (this.timeline.playbackRate = w), this[t].playbackRate = w;
          }
        }, {
          key: "playState",
          get: function() {
            var w = this.timeline, O = this[t], q = O.iterations, k = O.duration, f = O.endDelay, D = "running";
            if (w == null)
              D = "idle";
            else if (w.paused)
              D = "paused";
            else if (w.currentTime < 0)
              D = "pending";
            else {
              var ii = w.currentTime - q * k;
              ii > 0 && ii < f ? D = "pending" : ii >= f && (D = "finished");
            }
            return D;
          }
        }, {
          key: "progress",
          get: function() {
            if (!this.timeline)
              return 0;
            var w = this[t], O = w.duration, q = w.iterations, k = this.timeline, f = this.playState, D = void 0;
            if (f === "idle")
              D = 0;
            else if (f === "paused" && k.currentTime < 0)
              D = 0;
            else if (f === "pending")
              if (k.currentTime < 0)
                D = 0;
              else {
                var ii = k.seekLocalTime(q * O);
                D = (0, u.periodicity)(ii, O)[1] / O;
              }
            else
              (f === "running" || f === "paused") && (D = (0, u.periodicity)(k.currentTime, O)[1] / O);
            return f === "finished" && (D = (0, u.periodicity)(q, 1)[1]), D;
          }
        }, {
          key: "frame",
          get: function() {
            var w = this.playState, O = this[R], q = this[t].fill;
            if (w === "idle")
              return O;
            var k = this.timeline.currentTime, f = this[m].slice(0), D = (0, u.getProgress)(this.timeline, this[t], this.progress), ii = D.p, _ = D.inverted, bi = O;
            return k < 0 && w === "pending" ? (q === "backwards" || q === "both") && (bi = _ ? f[f.length - 1] : f[0]) : (w !== "pending" && w !== "finished" || q === "forwards" || q === "both") && (bi = (0, u.getCurrentFrame)(this[t], f, this[F], ii)), bi;
          }
        }, {
          key: "timing",
          get: function() {
            return this[t];
          }
        }, {
          key: "effects",
          get: function() {
            return this[F];
          }
        }, {
          key: "baseTimeline",
          set: function(w) {
            this[t].timeline = w;
          },
          get: function() {
            return this[t].timeline;
          }
        }, {
          key: "ready",
          get: function() {
            return this[S] ? this[S].promise : this.timeline && this.timeline.currentTime >= 0 && this.playState !== "paused" ? c.default.resolve() : (this[S] = (0, u.defer)(), this.timeline && this[K](), this[S] ? this[S].promise : c.default.resolve());
          }
        }, {
          key: "finished",
          get: function() {
            return this.playState === "finished" ? c.default.resolve() : (this[C] || (this[C] = (0, u.defer)(), this.timeline && this[J]()), this[C].promise);
          }
        }]), H;
      }();
      l.default = x;
    },
    /* 191 */
    /***/
    function(Z, l, i) {
      Z.exports = { default: i(192), __esModule: !0 };
    },
    /* 192 */
    /***/
    function(Z, l, i) {
      i(143), i(125), i(79), i(193), i(202), i(203), Z.exports = i(92).Promise;
    },
    /* 193 */
    /***/
    function(Z, l, i) {
      var s = i(89), c = i(91), W = i(93), h = i(128), e = i(90), a = i(98), G = i(94), y = i(147), n = i(148), V = i(194), I = i(195).set, r = i(197)(), p = i(198), o = i(199), u = i(200), d = i(201), b = "Promise", t = c.TypeError, m = c.process, R = m && m.versions, S = R && R.v8 || "", C = c[b], F = h(m) == "process", K = function() {
      }, J, T, Y, x, H = T = p.f, Q = !!function() {
        try {
          var _ = C.resolve(1), bi = (_.constructor = {})[i(122)("species")] = function($) {
            $(K, K);
          };
          return (F || typeof PromiseRejectionEvent == "function") && _.then(K) instanceof bi && S.indexOf("6.6") !== 0 && u.indexOf("Chrome/66") === -1;
        } catch {
        }
      }(), w = function(_) {
        var bi;
        return a(_) && typeof (bi = _.then) == "function" ? bi : !1;
      }, O = function(_, bi) {
        if (!_._n) {
          _._n = !0;
          var $ = _._c;
          r(function() {
            for (var oi = _._v, ni = _._s == 1, z = 0, M = function(E) {
              var B = ni ? E.ok : E.fail, g = E.resolve, U = E.reject, X = E.domain, L, N, v;
              try {
                B ? (ni || (_._h == 2 && f(_), _._h = 1), B === !0 ? L = oi : (X && X.enter(), L = B(oi), X && (X.exit(), v = !0)), L === E.promise ? U(t("Promise-chain cycle")) : (N = w(L)) ? N.call(L, g, U) : g(L)) : U(oi);
              } catch (P) {
                X && !v && X.exit(), U(P);
              }
            }; $.length > z; )
              M($[z++]);
            _._c = [], _._n = !1, bi && !_._h && q(_);
          });
        }
      }, q = function(_) {
        I.call(c, function() {
          var bi = _._v, $ = k(_), oi, ni, z;
          if ($ && (oi = o(function() {
            F ? m.emit("unhandledRejection", bi, _) : (ni = c.onunhandledrejection) ? ni({ promise: _, reason: bi }) : (z = c.console) && z.error && z.error("Unhandled promise rejection", bi);
          }), _._h = F || k(_) ? 2 : 1), _._a = void 0, $ && oi.e)
            throw oi.v;
        });
      }, k = function(_) {
        return _._h !== 1 && (_._a || _._c).length === 0;
      }, f = function(_) {
        I.call(c, function() {
          var bi;
          F ? m.emit("rejectionHandled", _) : (bi = c.onrejectionhandled) && bi({ promise: _, reason: _._v });
        });
      }, D = function(_) {
        var bi = this;
        bi._d || (bi._d = !0, bi = bi._w || bi, bi._v = _, bi._s = 2, bi._a || (bi._a = bi._c.slice()), O(bi, !0));
      }, ii = function(_) {
        var bi = this, $;
        if (!bi._d) {
          bi._d = !0, bi = bi._w || bi;
          try {
            if (bi === _)
              throw t("Promise can't be resolved itself");
            ($ = w(_)) ? r(function() {
              var oi = { _w: bi, _d: !1 };
              try {
                $.call(_, W(ii, oi, 1), W(D, oi, 1));
              } catch (ni) {
                D.call(oi, ni);
              }
            }) : (bi._v = _, bi._s = 1, O(bi, !1));
          } catch (oi) {
            D.call({ _w: bi, _d: !1 }, oi);
          }
        }
      };
      Q || (C = function(bi) {
        y(this, C, b, "_h"), G(bi), J.call(this);
        try {
          bi(W(ii, this, 1), W(D, this, 1));
        } catch ($) {
          D.call(this, $);
        }
      }, J = function(bi) {
        this._c = [], this._a = void 0, this._s = 0, this._d = !1, this._v = void 0, this._h = 0, this._n = !1;
      }, J.prototype = i(146)(C.prototype, {
        // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
        then: function(bi, $) {
          var oi = H(V(this, C));
          return oi.ok = typeof bi == "function" ? bi : !0, oi.fail = typeof $ == "function" && $, oi.domain = F ? m.domain : void 0, this._c.push(oi), this._a && this._a.push(oi), this._s && O(this, !1), oi.promise;
        },
        // 25.4.5.1 Promise.prototype.catch(onRejected)
        catch: function(_) {
          return this.then(void 0, _);
        }
      }), Y = function() {
        var _ = new J();
        this.promise = _, this.resolve = W(ii, _, 1), this.reject = W(D, _, 1);
      }, p.f = H = function(_) {
        return _ === C || _ === x ? new Y(_) : T(_);
      }), e(e.G + e.W + e.F * !Q, { Promise: C }), i(121)(C, b), i(149)(b), x = i(92)[b], e(e.S + e.F * !Q, b, {
        // 25.4.4.5 Promise.reject(r)
        reject: function(bi) {
          var $ = H(this), oi = $.reject;
          return oi(bi), $.promise;
        }
      }), e(e.S + e.F * (s || !Q), b, {
        // 25.4.4.6 Promise.resolve(x)
        resolve: function(bi) {
          return d(s && this === x ? C : this, bi);
        }
      }), e(e.S + e.F * !(Q && i(140)(function(_) {
        C.all(_).catch(K);
      })), b, {
        // 25.4.4.1 Promise.all(iterable)
        all: function(bi) {
          var $ = this, oi = H($), ni = oi.resolve, z = oi.reject, M = o(function() {
            var E = [], B = 0, g = 1;
            n(bi, !1, function(U) {
              var X = B++, L = !1;
              E.push(void 0), g++, $.resolve(U).then(function(N) {
                L || (L = !0, E[X] = N, --g || ni(E));
              }, z);
            }), --g || ni(E);
          });
          return M.e && z(M.v), oi.promise;
        },
        // 25.4.4.4 Promise.race(iterable)
        race: function(bi) {
          var $ = this, oi = H($), ni = oi.reject, z = o(function() {
            n(bi, !1, function(M) {
              $.resolve(M).then(oi.resolve, ni);
            });
          });
          return z.e && ni(z.v), oi.promise;
        }
      });
    },
    /* 194 */
    /***/
    function(Z, l, i) {
      var s = i(97), c = i(94), W = i(122)("species");
      Z.exports = function(h, e) {
        var a = s(h).constructor, G;
        return a === void 0 || (G = s(a)[W]) == null ? e : c(G);
      };
    },
    /* 195 */
    /***/
    function(Z, l, i) {
      var s = i(93), c = i(196), W = i(120), h = i(102), e = i(91), a = e.process, G = e.setImmediate, y = e.clearImmediate, n = e.MessageChannel, V = e.Dispatch, I = 0, r = {}, p = "onreadystatechange", o, u, d, b = function() {
        var m = +this;
        if (r.hasOwnProperty(m)) {
          var R = r[m];
          delete r[m], R();
        }
      }, t = function(m) {
        b.call(m.data);
      };
      (!G || !y) && (G = function(R) {
        for (var S = [], C = 1; arguments.length > C; )
          S.push(arguments[C++]);
        return r[++I] = function() {
          c(typeof R == "function" ? R : Function(R), S);
        }, o(I), I;
      }, y = function(R) {
        delete r[R];
      }, i(86)(a) == "process" ? o = function(m) {
        a.nextTick(s(b, m, 1));
      } : V && V.now ? o = function(m) {
        V.now(s(b, m, 1));
      } : n ? (u = new n(), d = u.port2, u.port1.onmessage = t, o = s(d.postMessage, d, 1)) : e.addEventListener && typeof postMessage == "function" && !e.importScripts ? (o = function(m) {
        e.postMessage(m + "", "*");
      }, e.addEventListener("message", t, !1)) : p in h("script") ? o = function(m) {
        W.appendChild(h("script"))[p] = function() {
          W.removeChild(this), b.call(m);
        };
      } : o = function(m) {
        setTimeout(s(b, m, 1), 0);
      }), Z.exports = {
        set: G,
        clear: y
      };
    },
    /* 196 */
    /***/
    function(Z, l) {
      Z.exports = function(i, s, c) {
        var W = c === void 0;
        switch (s.length) {
          case 0:
            return W ? i() : i.call(c);
          case 1:
            return W ? i(s[0]) : i.call(c, s[0]);
          case 2:
            return W ? i(s[0], s[1]) : i.call(c, s[0], s[1]);
          case 3:
            return W ? i(s[0], s[1], s[2]) : i.call(c, s[0], s[1], s[2]);
          case 4:
            return W ? i(s[0], s[1], s[2], s[3]) : i.call(c, s[0], s[1], s[2], s[3]);
        }
        return i.apply(c, s);
      };
    },
    /* 197 */
    /***/
    function(Z, l, i) {
      var s = i(91), c = i(195).set, W = s.MutationObserver || s.WebKitMutationObserver, h = s.process, e = s.Promise, a = i(86)(h) == "process";
      Z.exports = function() {
        var G, y, n, V = function() {
          var o, u;
          for (a && (o = h.domain) && o.exit(); G; ) {
            u = G.fn, G = G.next;
            try {
              u();
            } catch (d) {
              throw G ? n() : y = void 0, d;
            }
          }
          y = void 0, o && o.enter();
        };
        if (a)
          n = function() {
            h.nextTick(V);
          };
        else if (W && !(s.navigator && s.navigator.standalone)) {
          var I = !0, r = document.createTextNode("");
          new W(V).observe(r, { characterData: !0 }), n = function() {
            r.data = I = !I;
          };
        } else if (e && e.resolve) {
          var p = e.resolve(void 0);
          n = function() {
            p.then(V);
          };
        } else
          n = function() {
            c.call(s, V);
          };
        return function(o) {
          var u = { fn: o, next: void 0 };
          y && (y.next = u), G || (G = u, n()), y = u;
        };
      };
    },
    /* 198 */
    /***/
    function(Z, l, i) {
      var s = i(94);
      function c(W) {
        var h, e;
        this.promise = new W(function(a, G) {
          if (h !== void 0 || e !== void 0)
            throw TypeError("Bad Promise constructor");
          h = a, e = G;
        }), this.resolve = s(h), this.reject = s(e);
      }
      Z.exports.f = function(W) {
        return new c(W);
      };
    },
    /* 199 */
    /***/
    function(Z, l) {
      Z.exports = function(i) {
        try {
          return { e: !1, v: i() };
        } catch (s) {
          return { e: !0, v: s };
        }
      };
    },
    /* 200 */
    /***/
    function(Z, l, i) {
      var s = i(91), c = s.navigator;
      Z.exports = c && c.userAgent || "";
    },
    /* 201 */
    /***/
    function(Z, l, i) {
      var s = i(97), c = i(98), W = i(198);
      Z.exports = function(h, e) {
        if (s(h), c(e) && e.constructor === h)
          return e;
        var a = W.f(h), G = a.resolve;
        return G(e), a.promise;
      };
    },
    /* 202 */
    /***/
    function(Z, l, i) {
      var s = i(90), c = i(92), W = i(91), h = i(194), e = i(201);
      s(s.P + s.R, "Promise", { finally: function(a) {
        var G = h(this, c.Promise || W.Promise), y = typeof a == "function";
        return this.then(
          y ? function(n) {
            return e(G, a()).then(function() {
              return n;
            });
          } : a,
          y ? function(n) {
            return e(G, a()).then(function() {
              throw n;
            });
          } : a
        );
      } });
    },
    /* 203 */
    /***/
    function(Z, l, i) {
      var s = i(90), c = i(198), W = i(199);
      s(s.S, "Promise", { try: function(h) {
        var e = c.f(this), a = W(h);
        return (a.e ? e.reject : e.resolve)(a.v), e.promise;
      } });
    },
    /* 204 */
    /***/
    function(Z, l, i) {
      Z.exports = { default: i(205), __esModule: !0 };
    },
    /* 205 */
    /***/
    function(Z, l, i) {
      i(206), Z.exports = i(92).Object.keys;
    },
    /* 206 */
    /***/
    function(Z, l, i) {
      var s = i(124), c = i(110);
      i(207)("keys", function() {
        return function(h) {
          return c(s(h));
        };
      });
    },
    /* 207 */
    /***/
    function(Z, l, i) {
      var s = i(90), c = i(92), W = i(101);
      Z.exports = function(h, e) {
        var a = (c.Object || {})[h] || Object[h], G = {};
        G[h] = e(a), s(s.S + s.F * W(function() {
          a(1);
        }), "Object", G);
      };
    },
    /* 208 */
    /***/
    function(Z, l, i) {
      Object.defineProperty(l, "__esModule", {
        value: !0
      });
      var s = i(76), c = r(s), W = i(209), h = r(W), e = i(164), a = r(e), G = i(191), y = r(G);
      l.defer = p, l.periodicity = o, l.calculateFramesOffset = u, l.getProgress = d, l.getCurrentFrame = t;
      var n = i(188), V = i(187), I = r(V);
      function r(m) {
        return m && m.__esModule ? m : { default: m };
      }
      function p() {
        var m = {};
        return m.promise = new y.default(function(R, S) {
          m.resolve = R, m.reject = S;
        }), m;
      }
      function o(m, R) {
        var S = Math.floor(m / R), C = m - S * R;
        return C === 0 && S > 0 && (C = R, S--), [S, C];
      }
      function u(m) {
        m = m.slice(0);
        var R = m[0], S = m[m.length - 1];
        S.offset = S.offset || 1, R.offset = R.offset || 0;
        for (var C = 0, F = -1, K = 0; K < m.length; K++) {
          var J = m[K];
          if (J.offset != null) {
            var T = K - F;
            if (T > 1)
              for (var Y = (J.offset - C) / T, x = 0; x < T - 1; x++)
                m[F + x + 1].offset = C + Y * (x + 1);
            C = J.offset, F = K;
          }
          if (J.easing != null && (J.easing = (0, n.parseEasing)(J.easing)), K > 0) {
            var H = m[K].easing != null;
            m[K] = (0, a.default)({}, m[K - 1], m[K]), H || delete m[K].easing;
          }
        }
        return m;
      }
      function d(m, R, S) {
        var C = m.currentTime, F = R.direction, K = R.duration, J = !1;
        if (F === "reverse")
          S = 1 - S, J = !0;
        else if (F === "alternate" || F === "alternate-reverse") {
          var T = Math.floor(C / K);
          S === 1 && T--, T % 2 ^ F === "alternate-reverse" && (S = 1 - S, J = !0);
        }
        return { p: S, inverted: J };
      }
      function b(m, R, S, C) {
        var F = {};
        return (0, h.default)(R).forEach(function(K) {
          var J = (0, c.default)(K, 2), T = J[0], Y = J[1];
          if (T !== "offset" && T !== "easing") {
            var x = S[T] || S.default, H = x(m[T], Y, C, m.offset, R.offset);
            H != null && (F[T] = H);
          }
        }), F;
      }
      function t(m, R, S, C) {
        var F = m.easing, K = m.effect;
        K || (S = (0, a.default)({}, I.default, S));
        var J = {};
        C = F(C, R);
        for (var T = 1; T < R.length; T++) {
          var Y = R[T], x = Y.offset;
          if (x >= C || T === R.length - 1) {
            var H = R[T - 1], Q = H.offset, w = H.easing, O = C;
            if (w) {
              var q = x - Q;
              O = w((C - Q) / q) * q + Q;
            }
            K ? J = K(H, Y, O, Q, x) : J = b(H, Y, S, O);
            break;
          }
        }
        return J;
      }
    },
    /* 209 */
    /***/
    function(Z, l, i) {
      Z.exports = { default: i(210), __esModule: !0 };
    },
    /* 210 */
    /***/
    function(Z, l, i) {
      i(211), Z.exports = i(92).Object.entries;
    },
    /* 211 */
    /***/
    function(Z, l, i) {
      var s = i(90), c = i(212)(!0);
      s(s.S, "Object", {
        entries: function(h) {
          return c(h);
        }
      });
    },
    /* 212 */
    /***/
    function(Z, l, i) {
      var s = i(100), c = i(110), W = i(84), h = i(169).f;
      Z.exports = function(e) {
        return function(a) {
          for (var G = W(a), y = c(G), n = y.length, V = 0, I = [], r; n > V; )
            r = y[V++], (!s || h.call(G, r)) && I.push(e ? [r, G[r]] : G[r]);
          return I;
        };
      };
    },
    /* 213 */
    /***/
    function(Z, l, i) {
      i.r(l), i(1).glMatrix.setMatrixArrayType(Array);
      const s = /* @__PURE__ */ new Map();
      function c(h, e = {}, a = []) {
        h = h.toLowerCase();
        const G = s.get(h);
        if (!G)
          throw new TypeError(`Invalid node: ${h}`);
        const y = new G(e);
        return a.forEach((n) => {
          y.appendChild(n);
        }), y;
      }
      const W = {
        registerNode(h, e, a = 100) {
          if (e = e.toLowerCase(), s.has(e))
            throw new TypeError(`Cannot registerNode, ${e} has been taken.`);
          s.set(e, h), Object.defineProperties(h.prototype, {
            nodeType: {
              value: a
            },
            tagName: {
              value: e.toUpperCase()
            },
            nodeName: {
              value: e
            },
            ownerDocument: {
              value: W
            },
            namespaceURI: {
              value: `http://spritejs.com/${e}`
            }
          });
        },
        createElement: c,
        createElementNS(h, e) {
          return c(e);
        },
        isSpriteNode(h) {
          return s.has(h.toLowerCase());
        }
      };
      l.default = W;
    },
    /* 214 */
    /***/
    function(Z, l, i) {
      i.r(l), i.d(l, "default", function() {
        return e;
      }), i(1).glMatrix.setMatrixArrayType(Array);
      const s = Symbol("type"), c = Symbol("bubbles"), W = Symbol("originalEvent"), h = Symbol("detail");
      class e {
        constructor(G, {
          bubbles: y = null
        } = {}) {
          if (typeof G == "string" ? (this[s] = G, this[c] = !!y) : (this[s] = G.type, this[W] = G, this[c] = y != null ? !!y : !!G.bubbles, G.detail && (this[h] = G.detail)), !this[s])
            throw new TypeError("Invalid event type.");
          this.cancelBubble = !1;
        }
        setOriginalEvent(G) {
          this[W] = G;
        }
        get originalEvent() {
          return this[W];
        }
        get type() {
          return this[s];
        }
        get bubbles() {
          return this[c];
        }
        get detail() {
          return this[h];
        }
        stopPropagation() {
          this.cancelBubble = !0;
        }
      }
    },
    /* 215 */
    /***/
    function(Z, l, i) {
      i.r(l), i.d(l, "parseFilterString", function() {
        return c;
      }), i.d(l, "applyFilters", function() {
        return W;
      });
      var s = i(72);
      i(1).glMatrix.setMatrixArrayType(Array);
      function c(h) {
        if (h = h.trim(), !h || h === "none")
          return null;
        const e = /^(?:(url|blur|brightness|contrast|drop-shadow|grayscale|hue-rotate|invert|opacity|saturate|sepia)\(([^()]*(?:\(.*\))*[^()]*)\))+$/i, a = h.match(/(?:(url|blur|brightness|contrast|drop-shadow|grayscale|hue-rotate|invert|opacity|saturate|sepia)\(([^()]*(?:\(.*\))*[^()]*)\))+?/ig), G = [];
        return a && a.forEach((y) => {
          const n = y.match(e);
          if (!n)
            throw new TypeError("Invalid fitler string.");
          let [, V, I] = n;
          V = V.toLowerCase(), I = I.trim().match(/([^( )]+|([^( )]+\(.*\)))(?=\s|$)/g).map((r, p) => {
            let o;
            return V === "url" || V === "drop-shadow" && p === 3 ? o = r : o = Object(s.toNumber)(r), /%$/.test(r) && (o /= 100), o;
          }), G.push({
            type: V,
            args: I
          });
        }), G;
      }
      function W(h, e) {
        h.clearFilter(), e && e.forEach(({
          type: a,
          args: G
        }) => {
          let y = a;
          y === "drop-shadow" ? y = "dropShadow" : y === "hue-rotate" && (y = "hueRotate"), h[y](...G);
        });
      }
    },
    /* 216 */
    /***/
    function(Z, l, i) {
      i.r(l), i.d(l, "default", function() {
        return s;
      }), i(1).glMatrix.setMatrixArrayType(Array);
      function s(c, W) {
        if (!W)
          return;
        const h = c.getListeners("beforerender"), e = c.getListeners("afterrender");
        h.length && !W.beforeRender ? W.beforeRender = (a) => {
          c.dispatchEvent({
            type: "beforerender",
            detail: {
              context: a
            }
          });
        } : h.length || (W.beforeRender = null), e.length && !W.afterRender ? W.afterRender = (a) => {
          c.dispatchEvent({
            type: "afterrender",
            detail: {
              context: a
            }
          });
        } : e.length || (W.afterRender = null);
      }
    },
    /* 217 */
    /***/
    function(Z, l, i) {
      i.r(l), i.d(l, "default", function() {
        return G;
      });
      var s = i(12), c = i(218), W = i(70), h = i(213);
      i(1).glMatrix.setMatrixArrayType(Array);
      const e = Symbol("amount"), a = Symbol("meshCloud");
      class G extends W.default {
        constructor(n, V = 1) {
          super(), this.meshNode = n, n.connect(this), this[e] = V, this[a] = null;
        }
        get meshCloud() {
          const n = this.meshNode, V = this[e];
          return !this[a] && n.mesh && (this[a] = new s.MeshCloud(n.mesh, V)), this[a];
        }
        /* override */
        get isVisible() {
          return !!this.meshNode && this.meshNode.isVisible;
        }
        get amount() {
          return this[e];
        }
        set amount(n) {
          this[e] = n, this[a] && (this[a].amount = n);
        }
        brightness(n, V) {
          this.meshCloud && (this.meshCloud.brightness(n, V), this.forceUpdate());
        }
        contrast(n, V) {
          this.meshCloud && (this.meshCloud.contrast(n, V), this.forceUpdate());
        }
        delete(n) {
          this.meshCloud && (this.meshCloud.delete(n), this[e]--, this.forceUpdate());
        }
        /* override */
        draw(n = []) {
          if (super.draw(n), this.meshCloud) {
            if (this.program) {
              this.meshCloud.setProgram(this.program);
              const V = this.shaderAttrs;
              V && Object.entries(V).forEach(([r, p]) => {
                this.meshCloud.mesh.setAttribute(r, p);
              });
              const I = this.uniforms;
              if (this.uniforms) {
                const r = {};
                Object.entries(I).forEach(([p, o]) => {
                  typeof o == "function" && (o = o(this, p)), r[p] = o;
                }), this.meshCloud.mesh.setUniforms(r);
              }
            }
            this.meshNode.textureImage && Object(c.drawTexture)(this.meshNode, this.meshNode.mesh), n.push(this.meshCloud);
          }
          return n;
        }
        getTransform(n) {
          if (this.meshCloud)
            return this.meshCloud.getTransform(n);
        }
        grayscale(n, V) {
          this.meshCloud && (this.meshCloud.grayscale(n, V), this.forceUpdate());
        }
        hueRotate(n, V) {
          this.meshCloud && (this.meshCloud.hueRotate(n, V), this.forceUpdate());
        }
        invert(n, V) {
          this.meshCloud && (this.meshCloud.invert(n, V), this.forceUpdate());
        }
        /* override */
        isPointCollision(n, V) {
          if (!this.meshCloud)
            return !1;
          const I = this.attributes.pointerEvents;
          if (I === "none" || I !== "all" && !this.isVisible)
            return !1;
          let r = "both";
          I === "visibleFill" && (r = "fill"), I === "visibleStroke" && (r = "stroke");
          for (let p = 0; p < this[e]; p++)
            if (!this.meshCloud.isPointCollision(p, [n, V], r))
              return !1;
          return !0;
        }
        setOpacity(n, V) {
          this.meshCloud && (this.meshCloud.opacity(n, V), this.forceUpdate());
        }
        rotate(n, V, [I, r] = [0, 0]) {
          const p = Math.PI * V / 180;
          if (this.meshCloud) {
            const {
              x: o,
              y: u
            } = this.meshNode.attributes;
            this.meshCloud.rotate(n, p, [I + o, r + u]), this.forceUpdate();
          }
        }
        saturate(n, V) {
          this.meshCloud && (this.meshCloud.saturate(n, V), this.forceUpdate());
        }
        scale(n, [V, I = V], [r, p] = [0, 0]) {
          if (this.meshCloud) {
            const {
              x: o,
              y: u
            } = this.meshNode.attributes, d = 1e-5;
            Math.abs(V) < d && (V = 1 / V > 0 ? d : -d), Math.abs(I) < d && (I = 1 / I > 0 ? d : -d), this.meshCloud.scale(n, [V, I], [r + o, p + u]), this.forceUpdate();
          }
        }
        setColorTransform(n, V) {
          this.meshCloud && (this.meshCloud.setColorTransform(n, V), this.forceUpdate());
        }
        setFillColor(n, V) {
          this.meshCloud && (Array.isArray(V) && (V = [...V], V[0] /= 255, V[1] /= 255, V[2] /= 255), this.meshCloud.setFillColor(n, V), this.forceUpdate());
        }
        sepia(n, V) {
          this.meshCloud && (this.meshCloud.sepia(n, V), this.forceUpdate());
        }
        /* override */
        setResolution({
          width: n,
          height: V
        }) {
          super.setResolution({
            width: n,
            height: V
          }), this.meshNode.setResolution({
            width: n,
            height: V
          });
        }
        setStrokeColor(n, V) {
          this.meshCloud && (Array.isArray(V) && (V = [...V], V[0] /= 255, V[1] /= 255, V[2] /= 255), this.meshCloud.setStrokeColor(n, V), this.forceUpdate());
        }
        setTransform(n, V) {
          this.meshCloud && (this.meshCloud.setTransform(n, V), this.forceUpdate());
        }
        skew(n, [V, I = V], [r, p] = [0, 0]) {
          if (this.meshCloud) {
            const {
              x: o,
              y: u
            } = this.meshNode.attributes;
            this.meshCloud.skew(n, [V, I], [r + o, p + u]), this.forceUpdate();
          }
        }
        transform(n, V) {
          this.meshCloud && (this.meshCloud.transform(n, V), this.forceUpdate());
        }
        transformColor(n, V) {
          this.meshCloud && (this.meshCloud.transformColor(n, V), this.forceUpdate());
        }
        translate(n, [V, I]) {
          this.meshCloud && (this.meshCloud.translate(n, [V, I]), this.forceUpdate());
        }
        updateMesh() {
          this[a] && (this[a].mesh = this.meshNode.mesh, this.forceUpdate());
        }
      }
      h.default.registerNode(G, "cloud");
    },
    /* 218 */
    /***/
    function(Z, l, i) {
      i.r(l), i.d(l, "loadTexture", function() {
        return h;
      }), i.d(l, "applyTexture", function() {
        return e;
      }), i.d(l, "createTexture", function() {
        return G;
      }), i.d(l, "deleteTexture", function() {
        return y;
      }), i.d(l, "drawTexture", function() {
        return V;
      }), i.d(l, "loadFrames", function() {
        return I;
      });
      var s = i(12), c = i(72);
      i(1).glMatrix.setMatrixArrayType(Array);
      const W = {};
      function h(r, p) {
        if (W[r])
          return W[r];
        const o = s.ENV.loadImage(r, {
          alias: p,
          useImageBitmap: !1
        });
        return o ?? r;
      }
      async function e(r, p, o) {
        let u = p;
        if (typeof p == "string" && (u = h(p)), u && typeof u.then == "function" && (u = await u), p === r.attributes.texture) {
          u && u.image && (u.sourceRect && (r.attributes.sourceRect = u.sourceRect), r.textureImageRotated = !!u.rotated, u = u.image);
          const {
            width: d,
            height: b,
            textureRect: t
          } = r.attributes, m = r.textureImage;
          r.textureImage = u, o && m !== u && !t && (d == null || b == null) && r.updateContours(), r.forceUpdate();
        }
        return u;
      }
      const a = Symbol("textureMap");
      function G(r, p) {
        if (p[a] = p[a] || /* @__PURE__ */ new Map(), p[a].has(r))
          return p[a].get(r);
        const o = p.createTexture(r);
        return !/^blob:/.test(r.src) && typeof r.getContext != "function" && p[a].set(r, o), o;
      }
      function y(r, p) {
        if (p[a] && p[a].has(r)) {
          const o = p[a].get(r);
          return p.deleteTexture(o), p[a].delete(r), !0;
        }
        return !1;
      }
      const n = Symbol("textureContext");
      function V(r, p) {
        const o = r.textureImage instanceof String ? String(r.textureImage) : r.textureImage, u = r.textureImageRotated, d = p.texture, b = r.renderer;
        if (o) {
          const t = r.originalContentRect;
          let m = r.attributes.textureRect;
          const R = r.attributes.textureRepeat, S = r.attributes.sourceRect;
          if (!d || r[n] && r[n] !== b || d.image !== o || d.options.repeat !== R || !Object(c.compareValue)(d.options.rect, m) || !Object(c.compareValue)(d.options.srcRect, S)) {
            const C = G(o, b);
            m ? (m[0] += t[0], m[1] += t[1]) : m = t;
            let F = null;
            d && !b[a].has(d.image) && (!d.options || !d.options.hidden) && (F = p.uniforms.u_texSampler), p.setTexture(C, {
              rect: m,
              repeat: R,
              srcRect: S,
              rotated: u
            }), F && F.delete && F.delete(), r[n] = b;
          }
        } else if (d) {
          let t = null;
          !b[a].has(d.image) && (!d.options || !d.options.hidden) && (t = p.uniforms.u_texSampler), p.setTexture(null), t && t.delete && t.delete();
        }
      }
      async function I(r, p) {
        typeof p == "string" && (p = await (await fetch(p, {
          method: "GET",
          mode: "cors",
          cache: "default"
        })).json());
        const o = await h(r), u = p.frames;
        return Object.entries(u).forEach(([d, b]) => {
          const {
            x: t,
            y: m,
            w: R,
            h: S
          } = b.frame;
          let C = [t, m, R, S];
          const F = b.rotated;
          F && (C = [C[0], C[1], C[3], C[2]]), W[d] = {
            image: o,
            sourceRect: C,
            rotated: F
          };
        }), o;
      }
    },
    /* 219 */
    /***/
    function(Z, l, i) {
      i.r(l), i.d(l, "default", function() {
        return I;
      });
      var s = i(1), c = i(12), W = i(70), h = i(220), e = i(221), a = i(222), G = i(213), y = i(223);
      i(1).glMatrix.setMatrixArrayType(Array);
      function n(r, p, o) {
        return p in r ? Object.defineProperty(r, p, { value: o, enumerable: !0, configurable: !0, writable: !0 }) : r[p] = o, r;
      }
      const V = Symbol("mesh");
      class I extends W.default {
        constructor(p = {}) {
          super(p);
        }
        get borderSize() {
          const {
            paddingTop: p,
            paddingRight: o,
            paddingBottom: u,
            paddingLeft: d,
            borderWidth: b
          } = this.attributes, [t, m] = this.contentSize;
          return [d + t + o + b, p + m + u + b];
        }
        // content + padding
        get clientSize() {
          const {
            paddingTop: p,
            paddingRight: o,
            paddingBottom: u,
            paddingLeft: d
          } = this.attributes, [b, t] = this.contentSize;
          return [d + b + o, p + t + u];
        }
        get contentSize() {
          let {
            width: p,
            height: o,
            boxSizing: u,
            paddingTop: d,
            paddingRight: b,
            paddingBottom: t,
            paddingLeft: m
          } = this.attributes;
          if (p = p || 0, o = o || 0, u === "border-box") {
            const R = 2 * this.attributes.borderWidth;
            p -= R + b + m, o -= R + d + t, p = Math.max(0, p), o = Math.max(0, o);
          }
          return [p, o];
        }
        get hasBorder() {
          return this.attributes.borderWidth > 0;
        }
        /* override */
        get isVisible() {
          const [p, o] = this.borderSize;
          return p > 0 && o > 0;
        }
        get mesh() {
          if (this.attributes.display === "none")
            return null;
          const p = this.clientBox;
          if (p) {
            let o = this[V];
            if (o)
              o.box !== p && (o.contours = p.contours, o.box = p);
            else {
              o = new c.Mesh2D(p), o.box = p;
              const d = this.attributes.bgcolor;
              if (Object(e.setFillColor)(o, {
                color: d
              }), this.hasBorder) {
                const {
                  borderColor: t,
                  borderWidth: m,
                  borderDash: R,
                  borderDashOffset: S
                } = this.attributes;
                Object(e.setStrokeColor)(o, {
                  color: t,
                  lineWidth: m,
                  lineDash: R,
                  lineDashOffset: S
                });
              }
              this[V] = o;
              const b = this.attributes.clipPath;
              b && this[V].setClipPath(b);
            }
            const u = this.opacity;
            return o.getOpacity() !== u && o.setOpacity(u), o.setTransform(...this.renderMatrix), o;
          }
          return null;
        }
        // content + padding + border
        get offsetSize() {
          const {
            paddingTop: p,
            paddingRight: o,
            paddingBottom: u,
            paddingLeft: d,
            borderWidth: b
          } = this.attributes, [t, m] = this.contentSize, R = 2 * b;
          return [d + t + o + R, p + m + u + R];
        }
        get originalClientRect() {
          if (this.mesh) {
            const p = this.mesh.boundingBox;
            return [p[0][0], p[0][1], p[1][0] - p[0][0], p[1][1] - p[0][1]];
          }
          return [0, 0, 0, 0];
        }
        get originalContentRect() {
          const [p, o, u, d] = this.originalClientRect, b = this.attributes.padding;
          return [p + b[0], o + b[1], u - b[0] - b[2], d - b[1] - b[3]];
        }
        getBoundingClientRect() {
          let p = this.renderMatrix;
          this.layer && this.layer.layerTransformInvert && (p = s.mat2d.multiply(Array.of(0, 0, 0, 0, 0, 0), this.layer.transformMatrix, p));
          let o = null;
          if (this.mesh) {
            o = [...this.mesh.boundingBox];
            const u = this.attributes.borderWidth;
            u && (o[0] = [o[0][0] - u, o[0][1] - u], o[1] = [o[1][0] + u, o[1][1] + u]);
          }
          return Object(y.default)(o, p);
        }
        // transformPoint(x, y) {
        //   const m = mat2d.invert(this.renderMatrix);
        //   const newX = x * m[0] + y * m[2] + m[4];
        //   const newY = x * m[1] + y * m[3] + m[5];
        //   return [newX, newY];
        // }
        /* override */
        onPropertyChange(p, o, u) {
          if (super.onPropertyChange(p, o, u), (p === "anchorX" || p === "anchorY" || p === "boxSizing" || p === "width" || p === "height" || p === "borderWidth" || p === "paddingLeft" || p === "paddingRight" || p === "paddingTop" || p === "paddingBottom" || /^border(TopLeft|TopRight|BottomRight|BottomLeft)Radius$/.test(p)) && this.updateContours(), this[V] && p === "clipPath" && this[V].setClipPath(o), this[V] && p === "bgcolor" && Object(e.setFillColor)(this[V], {
            color: o
          }), this[V] && (p === "borderColor" || p === "borderWidth" || p === "borderDash" || p === "borderDashOffset")) {
            const {
              borderColor: d,
              borderWidth: b,
              borderDash: t,
              borderDashOffset: m
            } = this.attributes;
            Object(e.setStrokeColor)(this[V], {
              color: d,
              lineWidth: b,
              lineDash: b ? t : 0,
              lineDashOffset: m
            });
          }
        }
        /* override */
        updateContours() {
          const {
            anchorX: p,
            anchorY: o,
            borderWidth: u,
            borderRadius: d
          } = this.attributes, [b, t] = this.borderSize, m = this.offsetSize, R = 0.5 * u, S = -p * m[0] + R, C = -o * m[1] + R;
          this.clientBox = new c.Figure2D(), Object(a.createRadiusBox)(this.clientBox, [S, C, b, t], d);
        }
      }
      n(I, "Attr", h.default), G.default.registerNode(I, "block");
    },
    /* 220 */
    /***/
    function(Z, l, i) {
      i.r(l), i.d(l, "default", function() {
        return y;
      });
      var s = i(71), c = i(72), W = i(221);
      i(1).glMatrix.setMatrixArrayType(Array);
      const h = Symbol.for("spritejs_setAttribute"), e = Symbol.for("spritejs_getAttribute"), a = Symbol.for("spritejs_setAttributeDefault"), G = Symbol.for("spritejs_declareAlias");
      class y extends s.default {
        constructor(V) {
          super(V), this[a]({
            anchorX: 0,
            anchorY: 0,
            /* anchor */
            width: void 0,
            height: void 0,
            /* size */
            borderWidth: 0,
            borderColor: "rgba(0,0,0,1)",
            /* border */
            borderDash: void 0,
            borderDashOffset: 0,
            borderTopLeftRadius: [0, 0],
            borderTopRightRadius: [0, 0],
            borderBottomRightRadius: [0, 0],
            borderBottomLeftRadius: [0, 0],
            /* borderRadius */
            bgcolor: "rgba(0,0,0,0)",
            paddingTop: 0,
            paddingRight: 0,
            paddingBottom: 0,
            paddingLeft: 0,
            /* padding */
            boxSizing: "content-box",
            clipPath: void 0
          }), this[G]("anchor", "size", "border", "borderRadius", "padding");
        }
        get anchorX() {
          return this[e]("anchorX");
        }
        set anchorX(V) {
          this[h]("anchorX", Object(c.toNumber)(V));
        }
        get anchorY() {
          return this[e]("anchorY");
        }
        set anchorY(V) {
          this[h]("anchorY", Object(c.toNumber)(V));
        }
        get anchor() {
          return [this.anchorX, this.anchorY];
        }
        set anchor(V) {
          V = Object(c.toArray)(V), Array.isArray(V) || (V = [V, V]), this.anchorX = V[0], this.anchorY = V[1];
        }
        get width() {
          return this[e]("width");
        }
        set width(V) {
          this[h]("width", Object(c.toNumber)(V));
        }
        get height() {
          return this[e]("height");
        }
        set height(V) {
          this[h]("height", Object(c.toNumber)(V));
        }
        get size() {
          return [this.width, this.height];
        }
        set size(V) {
          V = Object(c.toArray)(V), Array.isArray(V) || (V = [V, V]), this.width = V[0], this.height = V[1];
        }
        get borderWidth() {
          return this[e]("borderWidth");
        }
        set borderWidth(V) {
          this[h]("borderWidth", Object(c.toNumber)(V));
        }
        get borderColor() {
          return this[e]("borderColor");
        }
        set borderColor(V) {
          this[h]("borderColor", Object(W.parseColor)(V));
        }
        get border() {
          return [this.borderWidth, this.borderColor];
        }
        set border(V) {
          V = Object(c.toArray)(V), Array.isArray(V) || (V = [V]), this.borderWidth = V[0], V[1] != null && (this.borderColor = V[1]);
        }
        get borderDash() {
          return this[e]("borderDash");
        }
        set borderDash(V) {
          V = Object(c.toArray)(V, !0), V != null && !Array.isArray(V) && (V = [V]), this[h]("borderDash", V ? V.map(c.toNumber) : null);
        }
        get borderDashOffset() {
          return this[e]("borderDashOffset");
        }
        set borderDashOffset(V) {
          this[h]("borderDashOffset", Object(c.toNumber)(V));
        }
        get borderTopLeftRadius() {
          return this[e]("borderTopLeftRadius");
        }
        set borderTopLeftRadius(V) {
          V = Object(c.toArray)(V, !0), Array.isArray(V) || (V = [V, V]), this[h]("borderTopLeftRadius", V.map(c.toNumber));
        }
        get borderTopRightRadius() {
          return this[e]("borderTopRightRadius");
        }
        set borderTopRightRadius(V) {
          V = Object(c.toArray)(V, !0), Array.isArray(V) || (V = [V, V]), this[h]("borderTopRightRadius", V.map(c.toNumber));
        }
        get borderBottomRightRadius() {
          return this[e]("borderBottomRightRadius");
        }
        set borderBottomRightRadius(V) {
          V = Object(c.toArray)(V, !0), Array.isArray(V) || (V = [V, V]), this[h]("borderBottomRightRadius", V.map(c.toNumber));
        }
        get borderBottomLeftRadius() {
          return this[e]("borderBottomLeftRadius");
        }
        set borderBottomLeftRadius(V) {
          V = Object(c.toArray)(V, !0), Array.isArray(V) || (V = [V, V]), this[h]("borderBottomLeftRadius", V.map(c.toNumber));
        }
        get borderRadius() {
          return [...this.borderTopLeftRadius, ...this.borderTopRightRadius, ...this.borderBottomRightRadius, ...this.borderBottomLeftRadius];
        }
        set borderRadius(V) {
          if (V = Object(c.toArray)(V), !Array.isArray(V))
            V = Array(8).fill(V);
          else if (V.length === 2)
            V = [V[0], V[1], V[0], V[1], V[0], V[1], V[0], V[1]];
          else if (V.length === 4)
            V = [V[0], V[1], V[2], V[3], V[0], V[1], V[2], V[3]];
          else if (V.length === 6)
            V = [V[0], V[1], V[2], V[3], V[4], V[5], V[2], V[3]];
          else if (V.length !== 8)
            throw new TypeError("Invalid borderRadius value.");
          this.borderTopLeftRadius = [V[0], V[1]], this.borderTopRightRadius = [V[2], V[3]], this.borderBottomRightRadius = [V[4], V[5]], this.borderBottomLeftRadius = [V[6], V[7]];
        }
        get bgcolor() {
          return this[e]("bgcolor");
        }
        set bgcolor(V) {
          this[h]("bgcolor", Object(W.parseColor)(V));
        }
        get paddingTop() {
          return this[e]("paddingTop");
        }
        set paddingTop(V) {
          this[h]("paddingTop", Object(c.toNumber)(V));
        }
        get paddingRight() {
          return this[e]("paddingRight");
        }
        set paddingRight(V) {
          this[h]("paddingRight", Object(c.toNumber)(V));
        }
        get paddingBottom() {
          return this[e]("paddingBottom");
        }
        set paddingBottom(V) {
          this[h]("paddingBottom", Object(c.toNumber)(V));
        }
        get paddingLeft() {
          return this[e]("paddingLeft");
        }
        set paddingLeft(V) {
          this[h]("paddingLeft", Object(c.toNumber)(V));
        }
        get padding() {
          return [this.paddingTop, this.paddingRight, this.paddingBottom, this.paddingLeft];
        }
        set padding(V) {
          V = Object(c.toArray)(V), Array.isArray(V) ? V.length === 2 ? V = [V[0], V[1], V[0], V[1]] : V.length === 3 && (V = [V[0], V[1], V[2], V[1]]) : V = [V, V, V, V], this.paddingTop = V[0], this.paddingRight = V[1], this.paddingBottom = V[2], this.paddingLeft = V[3];
        }
        get clipPath() {
          return this[e]("clipPath");
        }
        set clipPath(V) {
          this[h]("clipPath", V);
        }
        get boxSizing() {
          return this[e]("boxSizing");
        }
        set boxSizing(V) {
          if (V != null && V !== "border-box" && V !== "content-box")
            throw new TypeError("Invalid boxSizing type.");
          this[h]("boxSizing", V);
        }
      }
    },
    /* 221 */
    /***/
    function(Z, l, i) {
      i.r(l), i.d(l, "Gradient", function() {
        return W;
      }), i.d(l, "isTransparent", function() {
        return h;
      }), i.d(l, "parseColor", function() {
        return e;
      }), i.d(l, "setFillColor", function() {
        return G;
      }), i.d(l, "setStrokeColor", function() {
        return y;
      }), i.d(l, "Color", function() {
        return n;
      });
      var s = i(32), c = /* @__PURE__ */ i.n(s);
      i(1).glMatrix.setMatrixArrayType(Array);
      class W {
        constructor({
          vector: I,
          colors: r
        }) {
          if (!Array.isArray(I) || I.length !== 4 && I.length !== 6 && I.length !== 3)
            throw new TypeError("Invalid gradient");
          this.vector = I, this.colors = r.map(({
            offset: p,
            color: o
          }) => ({
            offset: p,
            color: e(o)
          }));
        }
        toString() {
          return JSON.stringify({
            vector: this.vector,
            colors: this.colors
          });
        }
      }
      function h(V) {
        return V instanceof W ? !1 : V == null ? !0 : c()(V)[3] === 0;
      }
      function e(V) {
        if (V == null || (V || (V = "transparent"), V instanceof W))
          return V;
        const I = c()(V);
        if (!I || !I.length)
          throw new TypeError("Invalid color value.");
        return `rgba(${I.join()})`;
      }
      function a(V, I, r) {
        const p = V.boundingBox[0];
        if (r.vector) {
          let {
            vector: o,
            colors: u
          } = r;
          o.length === 4 ? (o = [o[0] + p[0], o[1] + p[1], o[2] + p[0], o[3] + p[1]], V.setLinearGradient({
            vector: o,
            colors: u,
            type: I
          })) : o.length === 3 ? (o = [o[0] + p[0], o[1] + p[1], o[2]], V.setCircularGradient({
            vector: o,
            colors: u,
            type: I
          })) : (o = [o[0] + p[0], o[1] + p[1], o[2], o[3] + p[0], o[4] + p[1], o[5]], V.setRadialGradient({
            vector: o,
            colors: u,
            type: I
          }));
        } else
          V.gradient && V.gradient[I] && (delete V.gradient[I], delete V.uniforms.u_radialGradientVector);
      }
      function G(V, {
        color: I,
        rule: r = "nonzero"
      }) {
        return a(V, "fill", I), I.vector || V.setFill({
          color: I,
          rule: r
        }), V;
      }
      function y(V, {
        color: I,
        lineWidth: r,
        lineCap: p,
        lineJoin: o,
        lineDash: u,
        lineDashOffset: d,
        miterLimit: b,
        roundSegments: t
      }) {
        a(V, "stroke", I), I.vector && (I = [0, 0, 0, 1]), V.setStroke({
          color: I,
          thickness: r,
          cap: p,
          join: o,
          miterLimit: b,
          lineDash: u,
          lineDashOffset: d,
          roundSegments: t
        });
      }
      class n extends Array {
        constructor(I = 0, r = 0, p = 0, o = 0) {
          return Array.isArray(I) && ([I, r, p, o] = I), typeof I == "string" && ([I, r, p, o] = c()(I), I /= 255, r /= 255, p /= 255), super(I, r, p, o), this;
        }
        get r() {
          return Math.round(this[0] * 255);
        }
        set r(I) {
          this[0] = I / 255;
        }
        get g() {
          return Math.round(this[1] * 255);
        }
        set g(I) {
          this[1] = I / 255;
        }
        get b() {
          return Math.round(this[2] * 255);
        }
        set b(I) {
          this[2] = I / 255;
        }
        get a() {
          return this[3];
        }
        set a(I) {
          this[3] = I;
        }
        get hex() {
          const I = `0${this.r.toString(16)}`.slice(-2), r = `0${this.g.toString(16)}`.slice(-2), p = `0${this.b.toString(16)}`.slice(-2);
          let o;
          return this.a < 1 && (o = Math.round(this[3] * 255), o = `0${o.toString(16)}`.slice(-2)), `#${I}${r}${p}${o || ""}`;
        }
        get rgba() {
          return `rgba(${this.r},${this.g},${this.b},${this.a})`;
        }
        fromColor(I) {
          return typeof I == "string" && (I = c()(I), I[0] /= 255, I[1] /= 255, I[2] /= 255), this[0] = I[0], this[1] = I[1], this[2] = I[2], this[3] = I[3], this;
        }
      }
    },
    /* 222 */
    /***/
    function(Z, l, i) {
      i.r(l), i.d(l, "createRadiusBox", function() {
        return c;
      }), i(1).glMatrix.setMatrixArrayType(Array);
      function s(W, h, e, a, G, y = "leftTop") {
        const n = 0.5522848, V = a / 2 * n, I = G / 2 * n, r = h + a, p = e + G, o = h + a / 2, u = e + G / 2;
        y === "leftTop" ? (W.moveTo(h, u), W.bezierCurveTo(h, u - I, o - V, e, o, e)) : y === "rightTop" ? W.bezierCurveTo(o + V, e, r, u - I, r, u) : y === "rightBottom" ? W.bezierCurveTo(r, u + I, o + V, p, o, p) : y === "leftBottom" && W.bezierCurveTo(o - V, p, h, u + I, h, u);
      }
      function c(W, [h, e, a, G], y) {
        if (!y || Array.isArray(y) && y.every((n) => n === 0))
          W.beginPath(), W.rect(h, e, a, G);
        else {
          typeof y == "number" && (y = Array(8).fill(y));
          const [n, V, I, r, p, o, u, d] = y.map((b, t) => t % 2 ? Math.min(b, G / 2) : Math.min(b, a / 2));
          W.beginPath(), W.moveTo(h, e + V), s(W, h, e, n * 2, V * 2, "leftTop"), W.lineTo(h + a - I, e), s(W, h + a - I * 2, e, I * 2, r * 2, "rightTop"), W.lineTo(h + a, e + G - o), s(W, h + a - p * 2, e + G - o * 2, p * 2, o * 2, "rightBottom"), W.lineTo(h + u, e + G), s(W, h, e + G - d * 2, u * 2, d * 2, "leftBottom"), W.closePath();
        }
        return W;
      }
    },
    /* 223 */
    /***/
    function(Z, l, i) {
      i.r(l), i(1).glMatrix.setMatrixArrayType(Array), l.default = function(s, c) {
        if (!s)
          return {
            x: 0,
            y: 0,
            width: 0,
            height: 0,
            left: 0,
            top: 0,
            right: 0,
            bottom: 0
          };
        const [[W, h], [e, a]] = s, G = W * c[0] + h * c[2] + c[4], y = W * c[1] + h * c[3] + c[5], n = e * c[0] + h * c[2] + c[4], V = e * c[1] + h * c[3] + c[5], I = e * c[0] + a * c[2] + c[4], r = e * c[1] + a * c[3] + c[5], p = W * c[0] + a * c[2] + c[4], o = W * c[1] + a * c[3] + c[5], u = Math.min(G, n, I, p), d = Math.min(y, V, r, o), b = Math.max(G, n, I, p), t = Math.max(y, V, r, o);
        return {
          x: u,
          y: d,
          width: b - u,
          height: t - d,
          left: u,
          top: d,
          right: b,
          bottom: t
        };
      };
    },
    /* 224 */
    /***/
    function(Z, l, i) {
      i.r(l), i.d(l, "default", function() {
        return G;
      });
      var s = i(218), c = i(219), W = i(225), h = i(213);
      i(1).glMatrix.setMatrixArrayType(Array);
      function e(y, n, V) {
        return n in y ? Object.defineProperty(y, n, { value: V, enumerable: !0, configurable: !0, writable: !0 }) : y[n] = V, y;
      }
      const a = Symbol("textureTask");
      class G extends c.default {
        constructor(n = {}) {
          typeof n == "string" && (n = {
            texture: n
          }), super(n);
        }
        /* override */
        get contentSize() {
          let [n, V] = super.contentSize;
          const {
            width: I,
            height: r
          } = this.attributes;
          if (I == null || r == null) {
            const p = this.textureImage, o = this.attributes.textureRect, u = this.attributes.sourceRect;
            if (o)
              I == null && (n = o[0] + o[2]), r == null && (V = o[1] + o[3]);
            else if (u) {
              const d = this.layer ? this.layer.displayRatio : 1;
              I == null && (n = u[2] / d), r == null && (V = u[3] / d);
            } else if (p) {
              const d = this.layer ? this.layer.displayRatio : 1;
              I == null && (n = p.width / d), r == null && (V = p.height / d);
            }
          }
          return [n, V];
        }
        get textureImageReady() {
          return this[a] || Promise.resolve();
        }
        /* override */
        draw(n = []) {
          super.draw(n);
          const V = this.mesh;
          return V && Object(s.drawTexture)(this, V), n;
        }
        /* override */
        onPropertyChange(n, V, I) {
          if (super.onPropertyChange(n, V, I), n === "texture" && (this[a] = Object(s.applyTexture)(this, V, !0)), n === "textureRect") {
            const {
              width: r,
              height: p
            } = this.attributes;
            (r == null || p == null) && this.updateContours();
          }
        }
      }
      e(G, "Attr", W.default), h.default.registerNode(G, "sprite");
    },
    /* 225 */
    /***/
    function(Z, l, i) {
      i.r(l), i.d(l, "default", function() {
        return e;
      });
      var s = i(220);
      i(1).glMatrix.setMatrixArrayType(Array);
      const c = Symbol.for("spritejs_setAttributeDefault"), W = Symbol.for("spritejs_setAttribute"), h = Symbol.for("spritejs_getAttribute");
      class e extends s.default {
        constructor(G) {
          super(G), this[c]({
            texture: void 0,
            textureRect: void 0,
            textureRepeat: !1,
            sourceRect: void 0
          });
        }
        get texture() {
          return this[h]("texture");
        }
        set texture(G) {
          this[W]("texture", G);
        }
        get textureRect() {
          return this[h]("textureRect");
        }
        set textureRect(G) {
          this[W]("textureRect", G);
        }
        get sourceRect() {
          return this[h]("sourceRect");
        }
        set sourceRect(G) {
          this[W]("sourceRect", G);
        }
        get textureRepeat() {
          return this[h]("textureRepeat");
        }
        set textureRepeat(G) {
          this[W]("textureRepeat", !!G);
        }
      }
    },
    /* 226 */
    /***/
    function(Z, l, i) {
      i.r(l), i.d(l, "default", function() {
        return r;
      });
      var s = i(12), c = i(227), W = /* @__PURE__ */ i.n(c), h = i(70), e = i(228), a = i(221), G = i(218), y = i(213), n = i(223);
      i(1).glMatrix.setMatrixArrayType(Array);
      function V(p, o, u) {
        return o in p ? Object.defineProperty(p, o, { value: u, enumerable: !0, configurable: !0, writable: !0 }) : p[o] = u, p;
      }
      const I = Symbol("mesh");
      class r extends h.default {
        constructor(o = {}) {
          typeof o == "string" && (o = {
            d: o
          }), super(o), this.effects = {
            d(u, d, b, t, m) {
              const R = (b - t) / (m - t);
              if (R <= 0)
                return u;
              if (R >= 1)
                return d;
              const S = W.a._preprocessing(W.a.path2shapes(u), W.a.path2shapes(d)), C = W.a._lerp(...S, R)[0];
              return C.reduce((K, J) => `${K}${J.slice(2).join(" ")} `, `M${C[0][0]} ${C[0][1]}C`).trim();
            }
          };
        }
        /* override */
        get isVisible() {
          return !!this.d;
        }
        get mesh() {
          if (this.attributes.display === "none")
            return null;
          const o = this.path;
          if (o) {
            let u = this[I];
            if (u)
              u.path !== o && (u.contours = o.contours, u.path = o);
            else {
              u = new s.Mesh2D(this.path), u.path = o;
              const b = this.attributes.fillColor, t = this.attributes.fillRule;
              b && Object(a.setFillColor)(u, {
                color: b,
                rule: t
              });
              const m = this.attributes.lineWidth, R = this.attributes.strokeColor;
              if (R && m > 0) {
                const {
                  lineCap: C,
                  lineJoin: F,
                  miterLimit: K,
                  lineDash: J,
                  lineDashOffset: T,
                  roundSegments: Y
                } = this.attributes;
                Object(a.setStrokeColor)(u, {
                  color: R,
                  lineWidth: m,
                  lineCap: C,
                  lineJoin: F,
                  miterLimit: K,
                  lineDash: J,
                  lineDashOffset: T,
                  roundSegments: Y
                });
              }
              this[I] = u;
              const S = this.attributes.clipPath;
              S && this[I].setClipPath(S);
            }
            const d = this.opacity;
            return u.getOpacity() !== d && u.setOpacity(d), u.setTransform(...this.renderMatrix), u;
          }
          return null;
        }
        get originalContentRect() {
          if (this.path) {
            const o = this.path.boundingBox;
            return [o[0][0], o[0][1], o[1][0] - o[0][0], o[1][1] - o[0][1]];
          }
          return [0, 0, 0, 0];
        }
        get originalClientRect() {
          if (this.mesh) {
            const o = this.mesh.boundingBox;
            return [o[0][0], o[0][1], o[1][0] - o[0][0], o[1][1] - o[0][1]];
          }
          return [0, 0, 0, 0];
        }
        get originalClientCenter() {
          return this.mesh ? this.mesh.boundingCenter : [0, 0];
        }
        set d(o) {
          this.attributes.d = o;
        }
        get d() {
          return this.attributes.d;
        }
        /* override */
        draw(o = []) {
          super.draw(o);
          const u = this.mesh;
          return u && Object(G.drawTexture)(this, u), o;
        }
        getBoundingClientRect() {
          let o = null;
          return this.mesh && (o = this.mesh.boundingBox), Object(n.default)(o, this.renderMatrix);
        }
        getPathLength() {
          return this.mesh ? this.mesh.getTotalLength() : 0;
        }
        getPointAtLength(o) {
          if (this.mesh) {
            const u = this.mesh.getPointAtLength(o);
            if (u)
              return [u.x, u.y];
          }
          return [0, 0];
        }
        /* override */
        onPropertyChange(o, u, d) {
          if (super.onPropertyChange(o, u, d), (o === "d" || o === "normalize") && this.updateContours(), this[I] && (o === "fillColor" || o === "fillRule")) {
            const {
              fillColor: b,
              fillRule: t
            } = this.attributes;
            Object(a.setFillColor)(this[I], {
              color: b,
              rule: t
            });
          }
          if (this[I] && (o === "strokeColor" || o === "lineWidth" || o === "lineCap" || o === "lineJoin" || o === "lineDash" || o === "lineDashOffset" || o === "roundSegments")) {
            const {
              strokeColor: b,
              lineWidth: t
            } = this.attributes;
            if (b && t > 0) {
              const {
                lineCap: m,
                lineJoin: R,
                lineDash: S,
                lineDashOffset: C,
                miterLimit: F,
                roundSegments: K
              } = this.attributes;
              Object(a.setStrokeColor)(this[I], {
                color: b,
                lineCap: m,
                lineJoin: R,
                lineWidth: t,
                lineDash: S,
                lineDashOffset: C,
                miterLimit: F,
                roundSegments: K
              });
            }
          }
          this[I] && o === "clipPath" && this[I].setClipPath(u), o === "texture" && Object(G.applyTexture)(this, u);
        }
        /* override */
        updateContours() {
          this.path = new s.Figure2D(), this.path.addPath(this.attributes.d), this.attributes.normalize && this.path.normalize(...this.path.boundingCenter);
        }
      }
      V(r, "Attr", e.default), y.default.registerNode(r, "path");
    },
    /* 227 */
    /***/
    function(Z, l, i) {
      (function(s, c) {
        Z.exports = c();
      })(this, function() {
        var s = /* @__PURE__ */ function() {
          function J(T, Y) {
            var x = [], H = !0, Q = !1, w = void 0;
            try {
              for (var O = T[Symbol.iterator](), q; !(H = (q = O.next()).done) && (x.push(q.value), !(Y && x.length === Y)); H = !0)
                ;
            } catch (k) {
              Q = !0, w = k;
            } finally {
              try {
                !H && O.return && O.return();
              } finally {
                if (Q)
                  throw w;
              }
            }
            return x;
          }
          return function(T, Y) {
            if (Array.isArray(T))
              return T;
            if (Symbol.iterator in Object(T))
              return J(T, Y);
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          };
        }(), c = Math.PI * 2, W = function(T, Y, x, H, Q, w, O) {
          var q = T.x, k = T.y;
          q *= Y, k *= x;
          var f = H * q - Q * k, D = Q * q + H * k;
          return {
            x: f + w,
            y: D + O
          };
        }, h = function(T, Y) {
          var x = 1.3333333333333333 * Math.tan(Y / 4), H = Math.cos(T), Q = Math.sin(T), w = Math.cos(T + Y), O = Math.sin(T + Y);
          return [{
            x: H - Q * x,
            y: Q + H * x
          }, {
            x: w + O * x,
            y: O - w * x
          }, {
            x: w,
            y: O
          }];
        }, e = function(T, Y, x, H) {
          var Q = T * H - Y * x < 0 ? -1 : 1, w = Math.sqrt(T * T + Y * Y), O = Math.sqrt(T * T + Y * Y), q = T * x + Y * H, k = q / (w * O);
          return k > 1 && (k = 1), k < -1 && (k = -1), Q * Math.acos(k);
        }, a = function(T, Y, x, H, Q, w, O, q, k, f, D, ii) {
          var _ = Math.pow(Q, 2), bi = Math.pow(w, 2), $ = Math.pow(D, 2), oi = Math.pow(ii, 2), ni = _ * bi - _ * oi - bi * $;
          ni < 0 && (ni = 0), ni /= _ * oi + bi * $, ni = Math.sqrt(ni) * (O === q ? -1 : 1);
          var z = ni * Q / w * ii, M = ni * -w / Q * D, E = f * z - k * M + (T + x) / 2, B = k * z + f * M + (Y + H) / 2, g = (D - z) / Q, U = (ii - M) / w, X = (-D - z) / Q, L = (-ii - M) / w, N = e(1, 0, g, U), v = e(g, U, X, L);
          return q === 0 && v > 0 && (v -= c), q === 1 && v < 0 && (v += c), [E, B, N, v];
        }, G = function(T) {
          var Y = T.px, x = T.py, H = T.cx, Q = T.cy, w = T.rx, O = T.ry, q = T.xAxisRotation, k = q === void 0 ? 0 : q, f = T.largeArcFlag, D = f === void 0 ? 0 : f, ii = T.sweepFlag, _ = ii === void 0 ? 0 : ii, bi = [];
          if (w === 0 || O === 0)
            return [];
          var $ = Math.sin(k * c / 360), oi = Math.cos(k * c / 360), ni = oi * (Y - H) / 2 + $ * (x - Q) / 2, z = -$ * (Y - H) / 2 + oi * (x - Q) / 2;
          if (ni === 0 && z === 0)
            return [];
          w = Math.abs(w), O = Math.abs(O);
          var M = Math.pow(ni, 2) / Math.pow(w, 2) + Math.pow(z, 2) / Math.pow(O, 2);
          M > 1 && (w *= Math.sqrt(M), O *= Math.sqrt(M));
          var E = a(Y, x, H, Q, w, O, D, _, $, oi, ni, z), B = s(E, 4), g = B[0], U = B[1], X = B[2], L = B[3], N = Math.max(Math.ceil(Math.abs(L) / (c / 4)), 1);
          L /= N;
          for (var v = 0; v < N; v++)
            bi.push(h(X, L)), X += L;
          return bi.map(function(P) {
            var j = W(P[0], w, O, oi, $, g, U), A = j.x, li = j.y, di = W(P[1], w, O, oi, $, g, U), ci = di.x, mi = di.y, ti = W(P[2], w, O, oi, $, g, U), si = ti.x, Zi = ti.y;
            return { x1: A, y1: li, x2: ci, y2: mi, x: si, y: Zi };
          });
        }, y = {
          a: 7,
          c: 6,
          h: 1,
          l: 2,
          m: 2,
          q: 4,
          s: 4,
          t: 2,
          v: 1,
          z: 0
          /**
           * segment pattern
           * @type {RegExp}
           */
        }, n = /([astvzqmhlc])([^astvzqmhlc]*)/ig;
        function V(J) {
          var T = [];
          return J.replace(n, function(Y, x, H) {
            var Q = x.toLowerCase();
            for (H = r(H), Q == "m" && H.length > 2 && (T.push([x].concat(H.splice(0, 2))), Q = "l", x = x == "m" ? "l" : "L"); ; ) {
              if (H.length == y[Q])
                return H.unshift(x), T.push(H);
              if (H.length < y[Q])
                throw new Error("malformed path data");
              T.push([x].concat(H.splice(0, y[Q])));
            }
          }), T;
        }
        var I = /-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/ig;
        function r(J) {
          var T = J.match(I);
          return T ? T.map(Number) : [];
        }
        function p(J) {
          var T = J[0][0], Y = J[0][1], x = T, H = Y;
          return J.forEach(function(Q) {
            var w = Q[0], O = Q[2], q = Q[4], k = Q[6], f = Q[1], D = Q[3], ii = Q[5], _ = Q[7];
            T = Math.min(T, w, O, q, k), Y = Math.min(Y, f, D, ii, _), x = Math.max(x, w, O, q, k), H = Math.max(H, f, D, ii, _);
          }), [T, Y, x, H];
        }
        function o(J, T) {
          return Math.sqrt(Math.pow(J[0] - T[0], 2) + Math.pow(J[1] - T[1], 2)) + Math.sqrt(Math.pow(J[2] - T[2], 2) + Math.pow(J[3] - T[3], 2));
        }
        function u(J, T) {
          var Y = J[0], x = J[2], H = J[4], Q = J[6], w = J[1], O = J[3], q = J[5], k = J[7], f = T[0], D = T[2], ii = T[4], _ = T[6], bi = T[1], $ = T[3], oi = T[5], ni = T[7];
          return Math.sqrt(Math.pow(f - Y, 2) + Math.pow(bi - w, 2)) + Math.sqrt(Math.pow(D - x, 2) + Math.pow($ - O, 2)) + Math.sqrt(Math.pow(ii - H, 2) + Math.pow(oi - q, 2)) + Math.sqrt(Math.pow(_ - Q, 2) + Math.pow(ni - k, 2));
        }
        function d(J, T) {
          var Y = t(J.length), x = [];
          Y.forEach(function(Q) {
            var w = 0, O = 0;
            Q.forEach(function(q) {
              w += u(J[q], T[O++]);
            }), x.push({ index: Q, distance: w });
          }), x.sort(function(Q, w) {
            return Q.distance - w.distance;
          });
          var H = [];
          return x[0].index.forEach(function(Q) {
            H.push(J[Q]);
          }), H;
        }
        function b(J, T) {
          var Y = m(J.length), x = [];
          Y.forEach(function(Q) {
            var w = 0;
            Q.forEach(function(O) {
              w += o(p(J[O]), p(T[O]));
            }), x.push({ index: Q, distance: w });
          }), x.sort(function(Q, w) {
            return Q.distance - w.distance;
          });
          var H = [];
          return x[0].index.forEach(function(Q) {
            H.push(J[Q]);
          }), H;
        }
        function t(J) {
          for (var T = [], Y = 0; Y < J; Y++) {
            for (var x = [], H = 0; H < J; H++) {
              var Q = H + Y;
              Q > J - 1 && (Q -= J), x[Q] = H;
            }
            T.push(x);
          }
          return T;
        }
        function m(J) {
          for (var T = [], Y = 0; Y < J; Y++)
            T.push(Y);
          return R(T);
        }
        function R(J) {
          var T = [], Y = [];
          function x(H) {
            var Q, w;
            for (Q = 0; Q < H.length; Q++)
              w = H.splice(Q, 1)[0], Y.push(w), H.length == 0 && T.push(Y.slice()), x(H), H.splice(Q, 0, w), Y.pop();
            return T;
          }
          return x(J);
        }
        var S = {};
        S.parser = V, S.lerpCurve = function(J, T, Y) {
          return S.lerpPoints(J[0], J[1], T[0], T[1], Y).concat(S.lerpPoints(J[2], J[3], T[2], T[3], Y)).concat(S.lerpPoints(J[4], J[5], T[4], T[5], Y)).concat(S.lerpPoints(J[6], J[7], T[6], T[7], Y));
        }, S.lerpPoints = function(J, T, Y, x, H) {
          return [J + (Y - J) * H, T + (x - T) * H];
        }, S.q2b = function(J, T, Y, x, H, Q) {
          return [J, T, (J + 2 * Y) / 3, (T + 2 * x) / 3, (H + 2 * Y) / 3, (Q + 2 * x) / 3, H, Q];
        }, S.path2shapes = function(J) {
          for (var T = S.parser(J), Y = 0, x = 0, H = 0, Q = T.length, w = [], O = null, q = void 0, k = void 0, f = void 0, D = void 0, ii = void 0, _ = void 0, bi = void 0; H < Q; H++) {
            var $ = T[H], oi = $[0], ni = T[H - 1];
            switch (oi) {
              case "m":
                ii = w.length, w[ii] = [], O = w[ii], Y = Y + $[1], x = x + $[2];
                break;
              case "M":
                ii = w.length, w[ii] = [], O = w[ii], Y = $[1], x = $[2];
                break;
              case "l":
                O.push([Y, x, Y, x, Y, x, Y + $[1], x + $[2]]), Y += $[1], x += $[2];
                break;
              case "L":
                O.push([Y, x, $[1], $[2], $[1], $[2], $[1], $[2]]), Y = $[1], x = $[2];
                break;
              case "h":
                O.push([Y, x, Y, x, Y, x, Y + $[1], x]), Y += $[1];
                break;
              case "H":
                O.push([Y, x, $[1], x, $[1], x, $[1], x]), Y = $[1];
                break;
              case "v":
                O.push([Y, x, Y, x, Y, x, Y, x + $[1]]), x += $[1];
                break;
              case "V":
                O.push([Y, x, Y, $[1], Y, $[1], Y, $[1]]), x = $[1];
                break;
              case "C":
                O.push([Y, x, $[1], $[2], $[3], $[4], $[5], $[6]]), Y = $[5], x = $[6];
                break;
              case "S":
                ni[0] === "C" || ni[0] === "c" ? O.push([Y, x, Y + ni[5] - ni[3], x + ni[6] - ni[4], $[1], $[2], $[3], $[4]]) : (ni[0] === "S" || ni[0] === "s") && O.push([Y, x, Y + ni[3] - ni[1], x + ni[4] - ni[2], $[1], $[2], $[3], $[4]]), Y = $[3], x = $[4];
                break;
              case "c":
                O.push([Y, x, Y + $[1], x + $[2], Y + $[3], x + $[4], Y + $[5], x + $[6]]), Y = Y + $[5], x = x + $[6];
                break;
              case "s":
                ni[0] === "C" || ni[0] === "c" ? O.push([Y, x, Y + ni[5] - ni[3], x + ni[6] - ni[4], Y + $[1], x + $[2], Y + $[3], x + $[4]]) : (ni[0] === "S" || ni[0] === "s") && O.push([Y, x, Y + ni[3] - ni[1], x + ni[4] - ni[2], Y + $[1], x + $[2], Y + $[3], x + $[4]]), Y = Y + $[3], x = x + $[4];
                break;
              case "a":
                _ = G({
                  rx: $[1],
                  ry: $[2],
                  px: Y,
                  py: x,
                  xAxisRotation: $[3],
                  largeArcFlag: $[4],
                  sweepFlag: $[5],
                  cx: Y + $[6],
                  cy: x + $[7]
                }), bi = _[_.length - 1], _.forEach(function(z, M) {
                  M === 0 ? O.push([Y, x, z.x1, z.y1, z.x2, z.y2, z.x, z.y]) : O.push([_[M - 1].x, _[M - 1].y, z.x1, z.y1, z.x2, z.y2, z.x, z.y]);
                }), Y = bi.x, x = bi.y;
                break;
              case "A":
                _ = G({
                  rx: $[1],
                  ry: $[2],
                  px: Y,
                  py: x,
                  xAxisRotation: $[3],
                  largeArcFlag: $[4],
                  sweepFlag: $[5],
                  cx: $[6],
                  cy: $[7]
                }), bi = _[_.length - 1], _.forEach(function(z, M) {
                  M === 0 ? O.push([Y, x, z.x1, z.y1, z.x2, z.y2, z.x, z.y]) : O.push([_[M - 1].x, _[M - 1].y, z.x1, z.y1, z.x2, z.y2, z.x, z.y]);
                }), Y = bi.x, x = bi.y;
                break;
              case "Q":
                O.push(S.q2b(Y, x, $[1], $[2], $[3], $[4])), Y = $[3], x = $[4];
                break;
              case "q":
                O.push(S.q2b(Y, x, Y + $[1], x + $[2], $[3] + Y, $[4] + x)), Y += $[3], x += $[4];
                break;
              case "T":
                ni[0] === "Q" || ni[0] === "q" ? (f = Y + ni[3] - ni[1], D = x + ni[4] - ni[2], O.push(S.q2b(Y, x, f, D, $[1], $[2]))) : (ni[0] === "T" || ni[0] === "t") && (O.push(S.q2b(Y, x, Y + Y - f, x + x - D, $[1], $[2])), f = Y + Y - f, D = x + x - D), Y = $[1], x = $[2];
                break;
              case "t":
                ni[0] === "Q" || ni[0] === "q" ? (f = Y + ni[3] - ni[1], D = x + ni[4] - ni[2], O.push(S.q2b(Y, x, f, D, Y + $[1], x + $[2]))) : (ni[0] === "T" || ni[0] === "t") && (O.push(S.q2b(Y, x, Y + Y - f, x + x - D, Y + $[1], x + $[2])), f = Y + Y - f, D = x + x - D), Y += $[1], x += $[2];
                break;
              case "Z":
                q = O[0][0], k = O[0][1], O.push([Y, x, q, k, q, k, q, k]);
                break;
              case "z":
                q = O[0][0], k = O[0][1], O.push([Y, x, q, k, q, k, q, k]);
                break;
            }
          }
          return w;
        }, S._upCurves = function(J, T) {
          for (var Y = 0, x = 0, H = J.length; Y < T; Y++)
            J.push(J[x].slice(0)), x++, x > H - 1 && (x -= H);
        };
        function C(J, T, Y, x, H, Q, w, O, q) {
          return {
            left: F(J, T, Y, x, H, Q, w, O, q),
            right: F(w, O, H, Q, Y, x, J, T, 1 - q, !0)
          };
        }
        function F(J, T, Y, x, H, Q, w, O, q, k) {
          var f = (Y - J) * q + J, D = (x - T) * q + T, ii = (H - Y) * q + Y, _ = (Q - x) * q + x, bi = (w - H) * q + H, $ = (O - Q) * q + Q, oi = (ii - f) * q + f, ni = (_ - D) * q + D, z = (bi - ii) * q + ii, M = ($ - _) * q + _, E = (z - oi) * q + oi, B = (M - ni) * q + ni;
          return k ? [E, B, oi, ni, f, D, J, T] : [J, T, f, D, oi, ni, E, B];
        }
        S._splitCurves = function(J, T) {
          for (var Y = 0, x = 0; Y < T; Y++) {
            var H = J[x], Q = C(H[0], H[1], H[2], H[3], H[4], H[5], H[6], H[7], 0.5);
            J.splice(x, 1), J.splice(x, 0, Q.left, Q.right), x += 2, x >= J.length - 1 && (x = 0);
          }
        };
        function K(J, T) {
          for (var Y = function(Q) {
            var w = J[J.length - 1], O = [];
            w.forEach(function(q) {
              O.push(q.slice(0));
            }), J.push(O);
          }, x = 0; x < T; x++)
            Y();
        }
        return S.lerp = function(J, T, Y) {
          return S._lerp(S.path2shapes(J), S.path2shapes(T), Y);
        }, S.MIM_CURVES_COUNT = 100, S._preprocessing = function(J, T) {
          var Y = J.length, x = T.length, H = JSON.parse(JSON.stringify(J)), Q = JSON.parse(JSON.stringify(T));
          return Y > x ? K(Q, Y - x) : Y < x && K(H, x - Y), H = b(H, Q), H.forEach(function(w, O) {
            var q = w.length, k = Q[O].length;
            q > k ? q < S.MIM_CURVES_COUNT ? (S._splitCurves(w, S.MIM_CURVES_COUNT - q), S._splitCurves(Q[O], S.MIM_CURVES_COUNT - k)) : S._splitCurves(Q[O], q - k) : q < k && (k < S.MIM_CURVES_COUNT ? (S._splitCurves(w, S.MIM_CURVES_COUNT - q), S._splitCurves(Q[O], S.MIM_CURVES_COUNT - k)) : S._splitCurves(w, k - q));
          }), H.forEach(function(w, O) {
            H[O] = d(w, Q[O]);
          }), [H, Q];
        }, S._lerp = function(J, T, Y) {
          var x = [];
          return J.forEach(function(H, Q) {
            var w = [];
            H.forEach(function(O, q) {
              w.push(S.lerpCurve(O, T[Q][q], Y));
            }), x.push(w);
          }), x;
        }, S.animate = function(J) {
          var T = S.path2shapes(J.from), Y = S.path2shapes(J.to), x = S._preprocessing(T, Y), H = /* @__PURE__ */ new Date(), Q = J.end || function() {
          }, w = J.progress || function() {
          }, O = J.begin || function() {
          }, q = J.easing || function(_) {
            return _;
          }, k = null, f = null, D = J.time;
          O(T);
          var ii = function _() {
            var bi = /* @__PURE__ */ new Date() - H;
            if (bi >= D) {
              f = Y, w(f, 1), Q(f), cancelAnimationFrame(k);
              return;
            }
            var $ = q(bi / D);
            f = S._lerp(x[0], x[1], $), w(f, $), k = requestAnimationFrame(_);
          };
          ii();
        }, S;
      });
    },
    /* 228 */
    /***/
    function(Z, l, i) {
      i.r(l), i.d(l, "default", function() {
        return G;
      });
      var s = i(71), c = i(221), W = i(72);
      i(1).glMatrix.setMatrixArrayType(Array);
      const h = Symbol.for("spritejs_setAttributeDefault"), e = Symbol.for("spritejs_setAttribute"), a = Symbol.for("spritejs_getAttribute");
      class G extends s.default {
        constructor(n) {
          super(n), this[h]({
            d: "",
            normalize: !1,
            fillColor: void 0,
            fillRule: "nonzero",
            strokeColor: void 0,
            lineWidth: 1,
            lineJoin: "miter",
            // 'miter' or 'bevel' or 'round'
            lineCap: "butt",
            // 'butt' or 'square' or 'round'
            roundSegments: 20,
            // default roundSegment if lineJoin or lineCap is round
            lineDash: void 0,
            lineDashOffset: 0,
            miterLimit: 10,
            texture: void 0,
            textureRect: void 0,
            textureRepeat: !1,
            sourceRect: void 0,
            clipPath: void 0
          });
        }
        get d() {
          return this[a]("d");
        }
        set d(n) {
          this[e]("d", n);
        }
        get normalize() {
          return this[a]("normalize");
        }
        set normalize(n) {
          this[e]("normalize", !!n);
        }
        get fillColor() {
          return this[a]("fillColor");
        }
        set fillColor(n) {
          this[e]("fillColor", Object(c.parseColor)(n));
        }
        get fillRule() {
          return this[a]("fillRule");
        }
        set fillRule(n) {
          if (n != null && n !== "nonzero" && n !== "evenodd")
            throw new TypeError("Invalid fill rule.");
          this[e]("fillRule", n);
        }
        get strokeColor() {
          return this[a]("strokeColor");
        }
        set strokeColor(n) {
          this[e]("strokeColor", Object(c.parseColor)(n));
        }
        get lineWidth() {
          return this[a]("lineWidth");
        }
        set lineWidth(n) {
          this[e]("lineWidth", Object(W.toNumber)(n));
        }
        get lineJoin() {
          return this[a]("lineJoin");
        }
        set lineJoin(n) {
          if (n != null && n !== "miter" && n !== "bevel" && n !== "round")
            throw new TypeError("Invalid lineJoin type.");
          this[e]("lineJoin", n);
        }
        get lineCap() {
          return this[a]("lineCap");
        }
        set lineCap(n) {
          if (n != null && n !== "butt" && n !== "square" && n !== "round")
            throw new TypeError("Invalid lineCap type.");
          this[e]("lineCap", n);
        }
        get lineDash() {
          return this[a]("lineDash");
        }
        set lineDash(n) {
          n = Object(W.toArray)(n, !0), n != null && !Array.isArray(n) && (n = [n]), this[e]("lineDash", n ? n.map(W.toNumber) : null);
        }
        get lineDashOffset() {
          return this[a]("lineDashOffset");
        }
        set lineDashOffset(n) {
          this[e]("lineDashOffset", Object(W.toNumber)(n));
        }
        get miterLimit() {
          return this[a]("miterLimit");
        }
        set miterLimit(n) {
          this[e]("miterLimit", Object(W.toNumber)(n));
        }
        get roundSegments() {
          return this[a]("roundSegments");
        }
        set roundSegments(n) {
          this[e]("roundSegments", n);
        }
        get texture() {
          return this[a]("texture");
        }
        set texture(n) {
          this[e]("texture", n);
        }
        get textureRect() {
          return this[a]("textureRect");
        }
        set textureRect(n) {
          this[e]("textureRect", n);
        }
        get sourceRect() {
          return this[a]("sourceRect");
        }
        set sourceRect(n) {
          this[e]("sourceRect", n);
        }
        get textureRepeat() {
          return this[a]("textureRepeat");
        }
        set textureRepeat(n) {
          this[e]("textureRepeat", !!n);
        }
        get clipPath() {
          return this[a]("clipPath");
        }
        set clipPath(n) {
          this[e]("clipPath", n);
        }
      }
    },
    /* 229 */
    /***/
    function(Z, l, i) {
      i.r(l), i.d(l, "default", function() {
        return e;
      });
      var s = i(226), c = i(213), W = i(230);
      i(1).glMatrix.setMatrixArrayType(Array);
      function h(a, G, y) {
        return G in a ? Object.defineProperty(a, G, { value: y, enumerable: !0, configurable: !0, writable: !0 }) : a[G] = y, a;
      }
      class e extends s.default {
        /* override */
        get isVisible() {
          const {
            width: G,
            height: y
          } = this.attributes;
          return G > 0 && y > 0 && super.isVisible;
        }
      }
      h(e, "Attr", W.default), c.default.registerNode(e, "rect");
    },
    /* 230 */
    /***/
    function(Z, l, i) {
      i.r(l), i.d(l, "default", function() {
        return y;
      });
      var s = i(228), c = i(72);
      i(1).glMatrix.setMatrixArrayType(Array);
      const W = Symbol.for("spritejs_setAttributeDefault"), h = Symbol.for("spritejs_setAttribute"), e = Symbol.for("spritejs_getAttribute"), a = Symbol.for("spritejs_declareAlias");
      function G(n) {
        const {
          width: V,
          height: I
        } = n;
        return `M0 0L${V} 0L${V} ${I}L0 ${I}Z`;
      }
      class y extends s.default {
        constructor(V) {
          super(V), this[W]({
            width: 0,
            height: 0
            /* size */
          }), this[a]("size");
        }
        // readonly
        get d() {
          return this[e]("d");
        }
        set d(V) {
        }
        // eslint-disable-line no-empty-function
        get width() {
          return this[e]("width");
        }
        set width(V) {
          if (V = Object(c.toNumber)(V), this[h]("width", V)) {
            const I = G(this);
            this[h]("d", I);
          }
        }
        get height() {
          return this[e]("height");
        }
        set height(V) {
          if (V = Object(c.toNumber)(V), this[h]("height", V)) {
            const I = G(this);
            this[h]("d", I);
          }
        }
        get size() {
          return [this.width, this.height];
        }
        set size(V) {
          V = Object(c.toArray)(V), Array.isArray(V) || (V = [V, V]), this.width = V[0], this.height = V[1];
        }
      }
    },
    /* 231 */
    /***/
    function(Z, l, i) {
      i.r(l), i.d(l, "default", function() {
        return e;
      });
      var s = i(232), c = i(213), W = i(235);
      i(1).glMatrix.setMatrixArrayType(Array);
      function h(a, G, y) {
        return G in a ? Object.defineProperty(a, G, { value: y, enumerable: !0, configurable: !0, writable: !0 }) : a[G] = y, a;
      }
      class e extends s.default {
        get isVisible() {
          const {
            sides: G
          } = this.attributes;
          return G[0] > 0 && G[1] > 0 && super.isVisible;
        }
      }
      h(e, "Attr", W.default), c.default.registerNode(e, "triangle");
    },
    /* 232 */
    /***/
    function(Z, l, i) {
      i.r(l), i.d(l, "default", function() {
        return e;
      });
      var s = i(226), c = i(213), W = i(233);
      i(1).glMatrix.setMatrixArrayType(Array);
      function h(a, G, y) {
        return G in a ? Object.defineProperty(a, G, { value: y, enumerable: !0, configurable: !0, writable: !0 }) : a[G] = y, a;
      }
      class e extends s.default {
        /* override */
        get isVisible() {
          const {
            points: G
          } = this.attributes;
          return G.length > 0 && super.isVisible;
        }
      }
      h(e, "Attr", W.default), c.default.registerNode(e, "polyline");
    },
    /* 233 */
    /***/
    function(Z, l, i) {
      i.r(l), i.d(l, "default", function() {
        return n;
      });
      var s = i(228), c = i(72), W = i(234);
      i(1).glMatrix.setMatrixArrayType(Array);
      const h = Symbol.for("spritejs_setAttributeDefault"), e = Symbol.for("spritejs_setAttribute"), a = Symbol.for("spritejs_getAttribute"), G = Symbol.for("spritejs_declareAlias");
      function y(V) {
        const {
          points: I,
          smooth: r,
          smoothRange: p,
          close: o
        } = V, u = [];
        for (let b = 0; b < I.length; b += 2)
          u.push([I[b], I[b + 1]]);
        let d = "";
        return r ? d = Object(W.makeSmoothCurveLine)(u, p) : u.length && (d = `M${u.map((b) => b.join(" ")).join("L")}`), d && o && (d += "Z"), d;
      }
      class n extends s.default {
        constructor(I) {
          super(I), this[h]({
            points: [],
            smooth: !1,
            smoothRange: [0],
            closeType: "none"
            // none | normal
            /* close */
          }), this[G]("close");
        }
        // readonly
        get d() {
          return this[a]("d");
        }
        set d(I) {
        }
        // eslint-disable-line no-empty-function
        get close() {
          return this.closeType !== "none";
        }
        set close(I) {
          I = I ? "normal" : "none", this.closeType = I;
        }
        get closeType() {
          return this[a]("closeType");
        }
        set closeType(I) {
          if (I != null && I !== "none" && I !== "normal")
            throw new TypeError("Invalid closeType type.");
          if (this[e]("closeType", I)) {
            const r = y(this);
            this[e]("d", r);
          }
        }
        get smooth() {
          return this[a]("smooth");
        }
        set smooth(I) {
          if (this[e]("smooth", I)) {
            const r = y(this);
            this[e]("d", r);
          }
        }
        get smoothRange() {
          return this[a]("smoothRange");
        }
        set smoothRange(I) {
          if (I && !Array.isArray(I) && (I = [I]), this[e]("smoothRange", I) && this.smooth) {
            const r = y(this);
            this[e]("d", r);
          }
        }
        get points() {
          return this[a]("points");
        }
        set points(I) {
          if (I = Object(c.toArray)(I), Array.isArray(I) && (I = I.reduce((r, p) => Array.isArray(p) ? [...r, ...p.map((o) => Object(c.toNumber)(o))] : [...r, Object(c.toNumber)(p)], [])), this[e]("points", I)) {
            const r = y(this);
            this[e]("d", r);
          }
        }
      }
    },
    /* 234 */
    /***/
    function(Z, l, i) {
      i.r(l), i.d(l, "makeSmoothCurveLine", function() {
        return s;
      }), i(1).glMatrix.setMatrixArrayType(Array);
      function s(c, W = [0]) {
        function h(G, y = 0.168, n = 0.168) {
          let V, I, r, p;
          if ((c[G].x === c[G + 1].x || c[G].y === c[G + 1].y) && (y = 0, n = 0), G < 1 ? (V = c[0].x + (c[1].x - c[0].x) * y, I = c[0].y + (c[1].y - c[0].y) * y) : (V = c[G].x + (c[G + 1].x - c[G - 1].x) * y, I = c[G].y + (c[G + 1].y - c[G - 1].y) * y), G > c.length - 3) {
            const o = c.length - 1;
            r = c[o].x - (c[o].x - c[o - 1].x) * n, p = c[o].y - (c[o].y - c[o - 1].y) * n;
          } else
            r = c[G + 1].x - (c[G + 2].x - c[G].x) * n, p = c[G + 1].y - (c[G + 2].y - c[G].y) * n;
          return [{
            x: V,
            y: I
          }, {
            x: r,
            y: p
          }];
        }
        c = c.map(([G, y]) => ({
          x: G,
          y
        }));
        let e = "", a = 0;
        return c.forEach((G, y) => {
          if (y === 0)
            e += `M${G.x} ${G.y}`;
          else {
            for (; y > W[a]; )
              a++;
            if (a % 2) {
              const [n, V] = h(y - 1);
              e += `C${[n.x, n.y, V.x, V.y, G.x, G.y].join(" ")}`;
            } else
              e += `L${G.x} ${G.y}`;
          }
        }), e;
      }
    },
    /* 235 */
    /***/
    function(Z, l, i) {
      i.r(l), i.d(l, "default", function() {
        return G;
      });
      var s = i(233), c = i(72);
      i(1).glMatrix.setMatrixArrayType(Array);
      const W = Symbol.for("spritejs_setAttributeDefault"), h = Symbol.for("spritejs_setAttribute"), e = Symbol.for("spritejs_getAttribute");
      function a(y) {
        const [n, V] = y.sides;
        let I = y.angle % 360;
        return I < 0 && (I += 360), I = Math.PI * I / 180, [0, 0, n, 0, V * Math.cos(I), V * Math.sin(I)];
      }
      class G extends s.default {
        constructor(n) {
          super(n), this[W]({
            sides: [0, 0],
            angle: 60,
            closeType: "normal"
          });
        }
        // readonly
        get points() {
          return super.points;
        }
        set points(n) {
        }
        // eslint-disable-line no-empty-function
        get sides() {
          return this[e]("sides");
        }
        set sides(n) {
          if (n = Object(c.toArray)(n, !0), n != null && !Array.isArray(n) && (n = [n, n]), this[h]("sides", n)) {
            const V = a(this);
            super.points = V;
          }
        }
        get angle() {
          return this[e]("angle");
        }
        set angle(n) {
          if (n = Object(c.toNumber)(n), this[h]("angle", n)) {
            const V = a(this);
            super.points = V;
          }
        }
      }
    },
    /* 236 */
    /***/
    function(Z, l, i) {
      i.r(l), i.d(l, "default", function() {
        return e;
      });
      var s = i(232), c = i(213), W = i(237);
      i(1).glMatrix.setMatrixArrayType(Array);
      function h(a, G, y) {
        return G in a ? Object.defineProperty(a, G, { value: y, enumerable: !0, configurable: !0, writable: !0 }) : a[G] = y, a;
      }
      class e extends s.default {
        /* override */
        get isVisible() {
          const {
            sides: G
          } = this.attributes;
          return G[0] > 0 && G[1] > 0 && super.isVisible;
        }
      }
      h(e, "Attr", W.default), c.default.registerNode(e, "parallel");
    },
    /* 237 */
    /***/
    function(Z, l, i) {
      i.r(l), i.d(l, "default", function() {
        return G;
      });
      var s = i(233), c = i(72);
      i(1).glMatrix.setMatrixArrayType(Array);
      const W = Symbol.for("spritejs_setAttributeDefault"), h = Symbol.for("spritejs_setAttribute"), e = Symbol.for("spritejs_getAttribute");
      function a(y) {
        const [n, V] = y.sides;
        let I = y.angle % 360;
        I < 0 && (I += 360), I = Math.PI * I / 180;
        const r = V * Math.cos(I), p = V * Math.sin(I);
        return [0, 0, n, 0, r + n, p, r, p];
      }
      class G extends s.default {
        constructor(n) {
          super(n), this[W]({
            sides: [0, 0],
            angle: 90,
            closeType: "normal"
          });
        }
        // readonly
        get points() {
          return super.points;
        }
        set points(n) {
        }
        // eslint-disable-line no-empty-function
        get sides() {
          return this[e]("sides");
        }
        set sides(n) {
          if (n = Object(c.toArray)(n, !0), n != null && !Array.isArray(n) && (n = [n, n]), this[h]("sides", n)) {
            const V = a(this);
            super.points = V;
          }
        }
        get angle() {
          return this[e]("angle");
        }
        set angle(n) {
          if (n = Object(c.toNumber)(n), this[h]("angle", n)) {
            const V = a(this);
            super.points = V;
          }
        }
      }
    },
    /* 238 */
    /***/
    function(Z, l, i) {
      i.r(l), i.d(l, "default", function() {
        return e;
      });
      var s = i(232), c = i(213), W = i(239);
      i(1).glMatrix.setMatrixArrayType(Array);
      function h(a, G, y) {
        return G in a ? Object.defineProperty(a, G, { value: y, enumerable: !0, configurable: !0, writable: !0 }) : a[G] = y, a;
      }
      class e extends s.default {
      }
      h(e, "Attr", W.default), c.default.registerNode(e, "regular");
    },
    /* 239 */
    /***/
    function(Z, l, i) {
      i.r(l), i.d(l, "default", function() {
        return G;
      });
      var s = i(233), c = i(72);
      i(1).glMatrix.setMatrixArrayType(Array);
      const W = Symbol.for("spritejs_setAttributeDefault"), h = Symbol.for("spritejs_setAttribute"), e = Symbol.for("spritejs_getAttribute");
      function a(y) {
        const {
          edges: n,
          radius: V,
          offsetAngle: I
        } = y, r = Math.PI * I / 180 - 0.5 * Math.PI;
        if (n < 3 || V <= 0)
          return [];
        const p = [];
        for (let o = 0; o < n; o++) {
          const u = o * 2 * Math.PI / n + r, d = V * Math.cos(u), b = V * Math.sin(u);
          p.push(d, b);
        }
        return p;
      }
      class G extends s.default {
        constructor(n) {
          super(n), this[W]({
            edges: 3,
            radius: 0,
            offsetAngle: 0,
            closeType: "normal"
          });
        }
        // readonly
        get points() {
          return super.points;
        }
        set points(n) {
        }
        // eslint-disable-line no-empty-function
        get edges() {
          return this[e]("edges");
        }
        set edges(n) {
          if (n = Object(c.toNumber)(n), this[h]("edges", n)) {
            const V = a(this);
            super.points = V;
          }
        }
        get radius() {
          return this[e]("radius");
        }
        set radius(n) {
          if (n = Object(c.toNumber)(n), this[h]("radius", n)) {
            const V = a(this);
            super.points = V;
          }
        }
        get offsetAngle() {
          return this[e]("offsetAngle");
        }
        set offsetAngle(n) {
          if (n = Object(c.toNumber)(n), this[h]("offsetAngle", n)) {
            const V = a(this);
            super.points = V;
          }
        }
      }
    },
    /* 240 */
    /***/
    function(Z, l, i) {
      i.r(l), i.d(l, "default", function() {
        return e;
      });
      var s = i(232), c = i(213), W = i(241);
      i(1).glMatrix.setMatrixArrayType(Array);
      function h(a, G, y) {
        return G in a ? Object.defineProperty(a, G, { value: y, enumerable: !0, configurable: !0, writable: !0 }) : a[G] = y, a;
      }
      class e extends s.default {
      }
      h(e, "Attr", W.default), c.default.registerNode(e, "star");
    },
    /* 241 */
    /***/
    function(Z, l, i) {
      i.r(l), i.d(l, "default", function() {
        return G;
      });
      var s = i(233), c = i(72);
      i(1).glMatrix.setMatrixArrayType(Array);
      const W = Symbol.for("spritejs_setAttributeDefault"), h = Symbol.for("spritejs_setAttribute"), e = Symbol.for("spritejs_getAttribute");
      function a(y) {
        const {
          angles: n,
          innerRadius: V,
          outerRadius: I,
          offsetAngle: r
        } = y, p = Math.PI * r / 180 - 0.5 * Math.PI;
        if (n < 3 || V <= 0 || I <= 0)
          return [];
        const o = [];
        for (let u = 0; u < n * 2; u++) {
          const d = u * Math.PI / n + p, b = u % 2 ? V : I, t = b * Math.cos(d), m = b * Math.sin(d);
          o.push(t, m);
        }
        return o;
      }
      class G extends s.default {
        constructor(n) {
          super(n), this[W]({
            angles: 5,
            innerRadius: 0,
            outerRadius: 0,
            /* radius */
            offsetAngle: 0,
            closeType: "normal"
          });
        }
        // readonly
        get points() {
          return super.points;
        }
        set points(n) {
        }
        // eslint-disable-line no-empty-function
        get angles() {
          return this[e]("angles");
        }
        set angles(n) {
          if (n = Object(c.toNumber)(n), this[h]("angles", n)) {
            const V = a(this);
            super.points = V;
          }
        }
        get innerRadius() {
          return this[e]("innerRadius");
        }
        set innerRadius(n) {
          if (n = Object(c.toNumber)(n), this[h]("innerRadius", n)) {
            const V = a(this);
            super.points = V;
          }
        }
        get outerRadius() {
          return this[e]("outerRadius");
        }
        set outerRadius(n) {
          if (n = Object(c.toNumber)(n), this[h]("outerRadius", n)) {
            const V = a(this);
            super.points = V;
          }
        }
        get radius() {
          return [this.innerRadius, this.outerRadius];
        }
        set radius(n) {
          n = Object(c.toArray)(n, !0), Array.isArray(n) || (n = [n, n]), this.innerRadius = n[0], this.outerRadius = n[1];
        }
        get offsetAngle() {
          return this[e]("offsetAngle");
        }
        set offsetAngle(n) {
          if (n = Object(c.toNumber)(n), this[h]("offsetAngle", n)) {
            const V = a(this);
            super.points = V;
          }
        }
      }
    },
    /* 242 */
    /***/
    function(Z, l, i) {
      i.r(l), i.d(l, "default", function() {
        return e;
      });
      var s = i(226), c = i(213), W = i(243);
      i(1).glMatrix.setMatrixArrayType(Array);
      function h(a, G, y) {
        return G in a ? Object.defineProperty(a, G, { value: y, enumerable: !0, configurable: !0, writable: !0 }) : a[G] = y, a;
      }
      class e extends s.default {
        /* override */
        get isVisible() {
          const {
            radiusX: G,
            radiusY: y,
            startAngle: n,
            endAngle: V
          } = this.attributes;
          return G > 0 && y > 0 && n !== V && super.isVisible;
        }
      }
      h(e, "Attr", W.default), c.default.registerNode(e, "ellipse");
    },
    /* 243 */
    /***/
    function(Z, l, i) {
      i.r(l), i.d(l, "default", function() {
        return n;
      });
      var s = i(12), c = i(228), W = i(72);
      i(1).glMatrix.setMatrixArrayType(Array);
      const h = Symbol.for("spritejs_setAttributeDefault"), e = Symbol.for("spritejs_setAttribute"), a = Symbol.for("spritejs_getAttribute"), G = Symbol.for("spritejs_declareAlias");
      function y(V) {
        const {
          radiusX: I,
          radiusY: r,
          startAngle: p,
          endAngle: o,
          direction: u,
          closeType: d
        } = V, b = u === "anitclockwise", t = new s.Figure2D();
        return d === "sector" && t.moveTo(0, 0), t.ellipse(0, 0, I, r, 0, Math.PI * p / 180, Math.PI * o / 180, b), d !== "none" && t.closePath(), t.path.reduce((S, C) => S + C.join(" "), "");
      }
      class n extends c.default {
        constructor(I) {
          super(I), this[h]({
            radiusX: 0,
            radiusY: 0,
            /* radius */
            startAngle: 0,
            endAngle: 360,
            /* angle */
            direction: "clockwise",
            // clockwise | anticlockwise
            closeType: "none"
            // none | sector | normal
          }), this[G]("radius", "angle");
        }
        // readonly
        get d() {
          return this[a]("d");
        }
        set d(I) {
        }
        // eslint-disable-line no-empty-function
        get radiusX() {
          return this[a]("radiusX");
        }
        set radiusX(I) {
          if (I = Object(W.toNumber)(I), this[e]("radiusX", I)) {
            const r = y(this);
            this[e]("d", r);
          }
        }
        get radiusY() {
          return this[a]("radiusY");
        }
        set radiusY(I) {
          if (I = Object(W.toNumber)(I), this[e]("radiusY", I)) {
            const r = y(this);
            this[e]("d", r);
          }
        }
        get radius() {
          return [this.radiusX, this.radiusY];
        }
        set radius(I) {
          I = Object(W.toArray)(I, !0), Array.isArray(I) || (I = [I, I]), this.radiusX = I[0], this.radiusY = I[1];
        }
        get angle() {
          return [this.startAngle, this.endAngle];
        }
        set angle(I) {
          I = Object(W.toArray)(I), Array.isArray(I) || (I = [I, I]), this.startAngle = I[0], this.endAngle = I[1];
        }
        get direction() {
          return this[a]("direction");
        }
        set direction(I) {
          if (I != null && I !== "clockwise" && I !== "anticlockwise")
            throw new TypeError("Invalid direction type.");
          this[e]("direction", I);
        }
        get startAngle() {
          return this[a]("startAngle");
        }
        set startAngle(I) {
          if (I = Object(W.toNumber)(I), this[e]("startAngle", I)) {
            const r = y(this);
            this[e]("d", r);
          }
        }
        get endAngle() {
          return this[a]("endAngle");
        }
        set endAngle(I) {
          if (I = Object(W.toNumber)(I), this[e]("endAngle", I)) {
            const r = y(this);
            this[e]("d", r);
          }
        }
        get closeType() {
          return this[a]("closeType");
        }
        set closeType(I) {
          if (I != null && I !== "none" && I !== "sector" && I !== "normal")
            throw new TypeError("Invalid closeType type.");
          if (this[e]("closeType", I)) {
            const r = y(this);
            this[e]("d", r);
          }
        }
      }
    },
    /* 244 */
    /***/
    function(Z, l, i) {
      i.r(l), i.d(l, "default", function() {
        return e;
      });
      var s = i(242), c = i(213), W = i(245);
      i(1).glMatrix.setMatrixArrayType(Array);
      function h(a, G, y) {
        return G in a ? Object.defineProperty(a, G, { value: y, enumerable: !0, configurable: !0, writable: !0 }) : a[G] = y, a;
      }
      class e extends s.default {
      }
      h(e, "Attr", W.default), c.default.registerNode(e, "arc");
    },
    /* 245 */
    /***/
    function(Z, l, i) {
      i.r(l), i.d(l, "default", function() {
        return W;
      });
      var s = i(243), c = i(72);
      i(1).glMatrix.setMatrixArrayType(Array);
      class W extends s.default {
        get radius() {
          return super.radiusX;
        }
        set radius(e) {
          e = Object(c.toNumber)(e), super.radiusX = e, super.radiusY = e;
        }
      }
    },
    /* 246 */
    /***/
    function(Z, l, i) {
      i.r(l), i.d(l, "default", function() {
        return e;
      });
      var s = i(226), c = i(213), W = i(247);
      i(1).glMatrix.setMatrixArrayType(Array);
      function h(a, G, y) {
        return G in a ? Object.defineProperty(a, G, { value: y, enumerable: !0, configurable: !0, writable: !0 }) : a[G] = y, a;
      }
      class e extends s.default {
        /* override */
        get isVisible() {
          const {
            innerRadius: G,
            outerRadius: y,
            startAngle: n,
            endAngle: V
          } = this.attributes;
          return (G > 0 || y > 0) && n !== V && super.isVisible;
        }
      }
      h(e, "Attr", W.default), c.default.registerNode(e, "ring");
    },
    /* 247 */
    /***/
    function(Z, l, i) {
      i.r(l), i.d(l, "default", function() {
        return n;
      });
      var s = i(12), c = i(228), W = i(72);
      i(1).glMatrix.setMatrixArrayType(Array);
      const h = Symbol.for("spritejs_setAttributeDefault"), e = Symbol.for("spritejs_setAttribute"), a = Symbol.for("spritejs_getAttribute"), G = Symbol.for("spritejs_declareAlias");
      function y(V) {
        let {
          innerRadius: I,
          outerRadius: r,
          startAngle: p,
          endAngle: o
        } = V;
        const u = new s.Figure2D();
        if (p = Math.PI * p / 180, o = Math.PI * o / 180, I > r && ([I, r] = [r, I]), I <= 0 && u.moveTo(0, 0), u.arc(0, 0, r, p, o, !1), I > 0) {
          const t = Math.PI * 2;
          o < p && (o = p + t + (o - p) % t), o - p >= t && (o = p + t - 1e-6), u.arc(0, 0, I, o, p, !0);
        }
        return u.closePath(), u.path.reduce((t, m) => t + m.join(" "), "");
      }
      class n extends c.default {
        constructor(I) {
          super(I), this[h]({
            innerRadius: 0,
            outerRadius: 0,
            /* radius */
            startAngle: 0,
            endAngle: 360
            /* angle */
          }), this[G]("radius", "angle");
        }
        // readonly
        get d() {
          return this[a]("d");
        }
        set d(I) {
        }
        // eslint-disable-line no-empty-function
        get innerRadius() {
          return this[a]("innerRadius");
        }
        set innerRadius(I) {
          if (I = Object(W.toNumber)(I), this[e]("innerRadius", I)) {
            const r = y(this);
            this[e]("d", r);
          }
        }
        get outerRadius() {
          return this[a]("outerRadius");
        }
        set outerRadius(I) {
          if (I = Object(W.toNumber)(I), this[e]("outerRadius", I)) {
            const r = y(this);
            this[e]("d", r);
          }
        }
        get radius() {
          return [this.innerRadius, this.outerRadius];
        }
        set radius(I) {
          I = Object(W.toArray)(I, !0), Array.isArray(I) || (I = [I, I]), this.innerRadius = I[0], this.outerRadius = I[1];
        }
        get startAngle() {
          return this[a]("startAngle");
        }
        set startAngle(I) {
          if (I = Object(W.toNumber)(I), this[e]("startAngle", I)) {
            const r = y(this);
            this[e]("d", r);
          }
        }
        get endAngle() {
          return this[a]("endAngle");
        }
        set endAngle(I) {
          if (I = Object(W.toNumber)(I), this[e]("endAngle", I)) {
            const r = y(this);
            this[e]("d", r);
          }
        }
        get angle() {
          return [this.startAngle, this.endAngle];
        }
        set angle(I) {
          I = Object(W.toArray)(I), Array.isArray(I) || (I = [I, I]), this.startAngle = I[0], this.endAngle = I[1];
        }
      }
    },
    /* 248 */
    /***/
    function(Z, l, i) {
      i.r(l), i.d(l, "default", function() {
        return r;
      });
      var s = i(12), c = i(218), W = i(219), h = i(249), e = i(213);
      i(1).glMatrix.setMatrixArrayType(Array);
      function a(p, o, u) {
        return o in p ? Object.defineProperty(p, o, { value: u, enumerable: !0, configurable: !0, writable: !0 }) : p[o] = u, p;
      }
      const G = Symbol("textImage"), y = Symbol("textImageTask"), n = Symbol("textureContext"), V = Symbol("updateTextureRect"), I = Symbol("textCanvas");
      class r extends W.default {
        constructor(o = {}) {
          typeof o == "string" && (o = {
            text: o
          }), super(o);
        }
        /* override */
        get contentSize() {
          let [o, u] = super.contentSize;
          const {
            width: d,
            height: b
          } = this.attributes;
          if (d == null || b == null) {
            const t = this[G];
            t && (d == null && (o = t.rect[2]), b == null && (u = t.rect[3]));
          }
          return [o, u];
        }
        get text() {
          return this.attributes.text;
        }
        set text(o) {
          this.attributes.text = o;
        }
        get textContent() {
          return this.attributes.text;
        }
        set textContent(o) {
          this.attributes.text = o;
        }
        get textImage() {
          return this[G] || {};
        }
        get textImageReady() {
          return this[y] || Promise.resolve();
        }
        /* override */
        draw(o) {
          super.draw(o);
          const u = this.mesh;
          if (u) {
            const d = this[G];
            if (d) {
              let b = u.texture;
              if (!b || this[n] && this[n] !== this.renderer || d.needsUpdate ? (d.needsUpdate = !1, Object(c.deleteTexture)(d.image, this.renderer), b = Object(c.createTexture)(d.image, this.renderer), this[V] = !0) : b = u.uniforms.u_texSampler, this[V]) {
                const [t, m] = d.rect.slice(2), [R, S] = this.contentSize, C = this.attributes.textAlign, F = this.attributes.verticalAlign;
                let K = 0;
                C === "center" ? K = (R - t) / 2 : (C === "right" || C === "end") && (K = R - t);
                const J = this.attributes.fontSize, T = this.attributes.lineHeight;
                let Y = 0;
                F === "top" ? Y = (J - T) / 2 : F === "bottom" && (Y = (T - J) / 2);
                const {
                  paddingLeft: x,
                  paddingTop: H
                } = this.attributes, {
                  borderWidth: Q
                } = this.attributes;
                K += x + Q, Y += H + Q;
                const {
                  anchorX: w,
                  anchorY: O
                } = this.attributes;
                K -= this.offsetSize[0] * w, Y -= this.offsetSize[1] * O, u.setTexture(b, {
                  rect: [K, Y, t, m]
                }), this[V] = !1, this[n] = this.renderer;
              }
            }
          }
          return o;
        }
        /* override */
        onPropertyChange(o, u, d) {
          o === "text" || o === "fontSize" || o === "fontFamily" || o === "fontStyle" || o === "fontVariant" || o === "fontWeight" || o === "fontStretch" || o === "lineHeight" || o === "strokeColor" || o === "fillColor" || o === "strokeWidth" ? this.updateText() : ((o === "textAlign" || o === "verticalAlign") && (this[V] = !0), super.onPropertyChange(o, u, d));
        }
        /* override */
        updateContours() {
          super.updateContours(), this[V] = !0;
        }
        updateText() {
          this[y] || (this[y] = Promise.resolve().then(() => {
            this[y] = null;
            const {
              text: o,
              font: u,
              fillColor: d,
              strokeColor: b,
              strokeWidth: t
            } = this.attributes, m = this.layer ? this.layer.displayRatio : 1;
            return this[I] = this[I] || s.ENV.createCanvas(1, 1), this[G] = s.ENV.createText(o, {
              font: u,
              fillColor: d,
              strokeColor: b,
              strokeWidth: t,
              parseFont: s.parseFont,
              ratio: m,
              textCanvas: this[I]
            }), this[G].needsUpdate = !0, this.updateContours(), this.forceUpdate(), this[G];
          }));
        }
      }
      a(r, "Attr", h.default), e.default.registerNode(r, "label");
    },
    /* 249 */
    /***/
    function(Z, l, i) {
      i.r(l), i.d(l, "default", function() {
        return n;
      });
      var s = i(12), c = i(72), W = i(221), h = i(220);
      i(1).glMatrix.setMatrixArrayType(Array);
      const e = Symbol.for("spritejs_setAttributeDefault"), a = Symbol.for("spritejs_setAttribute"), G = Symbol.for("spritejs_getAttribute"), y = Symbol.for("spritejs_declareAlias");
      class n extends h.default {
        constructor(I) {
          super(I), this[e]({
            text: "",
            fontSize: 16,
            fontFamily: "Helvetica,Arial,sans-serif",
            fontStyle: "normal",
            fontVariant: "normal",
            fontWeight: "normal",
            fontStretch: "normal",
            lineHeight: "",
            /* font */
            textAlign: "left",
            strokeColor: void 0,
            strokeWidth: 1,
            fillColor: void 0,
            verticalAlign: "middle"
          }), this[y]("font");
        }
        get text() {
          return this[G]("text") || " ";
        }
        set text(I) {
          this[a]("text", I);
        }
        get fontSize() {
          return this[G]("fontSize");
        }
        set fontSize(I) {
          this[a]("fontSize", Object(c.toNumber)(I));
        }
        get fontFamily() {
          return this[G]("fontFamily");
        }
        set fontFamily(I) {
          this[a]("fontFamily", I);
        }
        get fontStyle() {
          return this[G]("fontStyle");
        }
        set fontStyle(I) {
          this[a]("fontStyle", I);
        }
        get fontVariant() {
          return this[G]("fontVariant");
        }
        set fontVariant(I) {
          this[a]("fontVariant", I);
        }
        get fontWeight() {
          return this[G]("fontWeight");
        }
        set fontWeight(I) {
          this[a]("fontWeight", I);
        }
        get fontStretch() {
          return this[G]("fontStretch");
        }
        set fontStretch(I) {
          this[a]("fontStretch", I);
        }
        get lineHeight() {
          return this[G]("lineHeight") || this.fontSize;
        }
        set lineHeight(I) {
          this[a]("lineHeight", Object(c.toNumber)(I));
        }
        get textAlign() {
          return this[G]("textAlign");
        }
        set textAlign(I) {
          this[a]("textAlign", I);
        }
        get strokeColor() {
          return this[G]("strokeColor");
        }
        set strokeColor(I) {
          this[a]("strokeColor", Object(W.parseColor)(I));
        }
        get strokeWidth() {
          return this[G]("strokeWidth");
        }
        set strokeWidth(I) {
          this[a]("strokeWidth", Object(c.toNumber)(I));
        }
        get verticalAlign() {
          return this[G]("verticalAlign");
        }
        set verticalAlign(I) {
          this[a]("verticalAlign", I);
        }
        get fillColor() {
          return this[G]("fillColor");
        }
        set fillColor(I) {
          this[a]("fillColor", Object(W.parseColor)(I));
        }
        get font() {
          const {
            fontStyle: I,
            fontVariant: r,
            fontWeight: p,
            fontStretch: o,
            fontSize: u,
            lineHeight: d,
            fontFamily: b
          } = this;
          return `${I} ${r} ${p} ${o} ${u}px/${d}px ${b}`;
        }
        set font(I) {
          if (I == null)
            this.fontStyle = null, this.fontVariant = null, this.fontWeight = null, this.fontStretch = null, this.fontSize = null, this.lineHeight = null, this.fontFamily = null;
          else {
            const r = Object(s.parseFont)(I);
            this.fontStyle = r.style, this.fontVariant = r.variant, this.fontWeight = r.weight, this.fontStretch = r.stretch, this.fontSize = Object(c.toNumber)(`${r.size}${r.unit}`), r.lineHeight && (this.lineHeight = r.pxLineHeight), this.fontFamily = r.family;
          }
        }
      }
    },
    /* 250 */
    /***/
    function(Z, l, i) {
      i.r(l), i.d(l, "default", function() {
        return I;
      });
      var s = i(12), c = i(219), W = i(251), h = i(213), e = i(252);
      i(1).glMatrix.setMatrixArrayType(Array);
      function a(r, p, o) {
        return p in r ? Object.defineProperty(r, p, { value: o, enumerable: !0, configurable: !0, writable: !0 }) : r[p] = o, r;
      }
      const G = Symbol("zOrder"), y = Symbol("ordered"), n = Symbol("children"), V = Symbol("sealed");
      class I extends c.default {
        constructor(p = {}) {
          super(p), this[n] = [], this[y] = null, this[G] = 0;
        }
        get childNodes() {
          return this[n];
        }
        get children() {
          return this[n];
        }
        get orderedChildren() {
          return this[y] || (this[y] = [...this[n]], this[y].sort((p, o) => p.zIndex - o.zIndex || p.zOrder - o.zOrder)), this[y];
        }
        append(...p) {
          return p.map((o) => this.appendChild(o));
        }
        appendChild(p) {
          return p.remove(), this[n].push(p), p.connect(this, this[G]++), this[y] && (this[y].length && p.zIndex < this[y][this[y].length - 1].zIndex ? this.reorder() : this[y].push(p)), p;
        }
        /* override */
        // get isVisible() {
        //   return this.attributes.opacity > 0 && this[_children].length > 0;
        // }
        /* override */
        cloneNode(p = !1) {
          const o = super.cloneNode();
          return p && this[n].forEach((u) => {
            const d = u.cloneNode(p);
            o.appendChild(d);
          }), o;
        }
        /* override */
        dispatchPointerEvent(p) {
          const o = this.orderedChildren;
          for (let u = o.length - 1; u >= 0; u--)
            if (o[u].dispatchPointerEvent(p))
              return !0;
          return super.dispatchPointerEvent(p);
        }
        /* override */
        draw(p = []) {
          if (this.__cacheRenderMatrix = this.renderMatrix, super.draw(p), !this[V] && this.attributes.display !== "none") {
            const o = this.orderedChildren;
            for (let u = 0; u < o.length; u++)
              o[u].draw(p);
          }
          return this.__cacheRenderMatrix = null, p;
        }
        getElementById(p) {
          return Object(e.querySelector)(`#${p}`, this);
        }
        getElementsByClassName(p) {
          return Object(e.querySelectorAll)(`.${p}`, this);
        }
        getElementsByName(p) {
          return Object(e.querySelectorAll)(`[name="${p}"]`, this);
        }
        getElementsByTagName(p) {
          return Object(e.querySelectorAll)(p, this);
        }
        insertBefore(p, o) {
          if (o == null)
            return this.appendChild(p);
          p.remove();
          const u = this[n].indexOf(o);
          if (u < 0)
            throw new Error("Invalid reference node.");
          const d = o.zOrder;
          for (let b = u; b < this[n].length; b++) {
            const t = this[n][b].zOrder, m = this[n][b];
            delete m.zOrder, Object.defineProperty(m, "zOrder", {
              value: t + 1,
              writable: !1,
              configurable: !0
            });
          }
          if (this[n].splice(u, 0, p), p.connect(this, d), this[y])
            if (p.zIndex !== o.zIndex)
              this.reorder();
            else {
              const b = this[y].indexOf(o);
              this[y].splice(b, 0, p);
            }
          return p;
        }
        querySelector(p) {
          return Object(e.querySelector)(p, this);
        }
        querySelectorAll(p) {
          return Object(e.querySelectorAll)(p, this);
        }
        replaceChild(p, o) {
          p.remove();
          const u = this[n].indexOf(o);
          if (u < 0)
            throw new Error("Invalid reference node.");
          if (this[n][u] = p, p.connect(this, o.zOrder), this[y])
            if (p.zIndex !== o.zIndex)
              this.reorder();
            else {
              const d = this[y].indexOf(o);
              this[y][d] = p;
            }
          return o.disconnect(this), p;
        }
        removeAllChildren() {
          const p = this[n];
          for (let o = p.length - 1; o >= 0; o--)
            p[o].remove();
        }
        removeChild(p) {
          const o = this[n].indexOf(p);
          if (o >= 0) {
            if (this[n].splice(o, 1), this[y]) {
              const u = this[y].indexOf(p);
              this[y].splice(u, 1);
            }
            return p.disconnect(this), p;
          }
          return null;
        }
        reorder() {
          this[y] = null;
        }
        seal() {
          function p(b, t) {
            const m = [];
            for (let R = 0; R < b.length; R++) {
              const S = [...b[R]];
              for (let C = 1; C < S.length; C += 2) {
                const F = S[C], K = S[C + 1];
                S[C] = F * t[0] + K * t[2] + t[4], S[C + 1] = F * t[1] + K * t[3] + t[5];
              }
              m.push(S);
            }
            return m;
          }
          const o = this.orderedChildren, u = new s.Figure2D(), d = this.localMatrix;
          for (let b = 0; b < o.length; b++) {
            let t = o[b];
            if (t instanceof I && (t = t.seal()), t.clientBox) {
              let m = t.clientBox.contours.path;
              m = p(m, t.localMatrix), u.addPath(m);
            }
            if (t.path) {
              let m = t.path.contours.path;
              m = p(m, t.localMatrix), u.addPath(m);
            }
          }
          return this[V] = !0, this.clientBox = u, {
            clientBox: u,
            localMatrix: d
          };
        }
        /* override */
        setResolution({
          width: p,
          height: o
        }) {
          super.setResolution({
            width: p,
            height: o
          }), this[n].forEach((u) => {
            u.setResolution({
              width: p,
              height: o
            });
          });
        }
        /* override */
        updateContours() {
          this[V] || super.updateContours();
        }
      }
      a(I, "Attr", W.default), h.default.registerNode(I, "group");
    },
    /* 251 */
    /***/
    function(Z, l, i) {
      i.r(l), i.d(l, "default", function() {
        return c;
      });
      var s = i(220);
      i(1).glMatrix.setMatrixArrayType(Array);
      class c extends s.default {
        // constructor(subject) {
        //   super(subject);
        //   this[setDefault]({
        //     pointerEvents: 'all',
        //   });
        // }
      }
    },
    /* 252 */
    /***/
    function(Z, l, i) {
      i.r(l), i.d(l, "querySelectorAll", function() {
        return V;
      }), i.d(l, "querySelector", function() {
        return I;
      }), i.d(l, "isMatched", function() {
        return r;
      }), i.d(l, "compile", function() {
        return p;
      });
      var s = i(221), c = i(213);
      i(1).glMatrix.setMatrixArrayType(Array);
      const W = i(253);
      function h(o) {
        return o.nodeType === 1 || c.default.isSpriteNode(o.nodeName);
      }
      function e(o) {
        return Array.from(o.childNodes || []);
      }
      function a(o) {
        return c.default.isSpriteNode(o.nodeName) ? o.parent || o.canvas || o.container : o.parentElement;
      }
      function G(o) {
        let u = o.length, d, b, t;
        for (; --u > -1; ) {
          for (d = b = o[u], o[u] = null, t = !0; b; ) {
            if (o.indexOf(b) > -1) {
              t = !1, o.splice(u, 1);
              break;
            }
            b = a(b);
          }
          t && (o[u] = d);
        }
        return o;
      }
      const y = {
        isTag: h,
        existsOne(o, u) {
          return u.some((d) => h(d) ? o(d) || y.existsOne(o, e(d)) : !1);
        },
        getSiblings(o) {
          const u = a(o);
          return u && e(u);
        },
        getChildren: e,
        getParent: a,
        getAttributeValue(o, u) {
          if (o.nodeType === 1 && u === "class" || u === "id")
            return o[u];
          if (this.hasAttrib(o, u)) {
            let d = o.attributes[u];
            return Array.isArray(d) && (d = `[${d.join()}]`), String(d);
          }
        },
        hasAttrib(o, u) {
          return o.attributes[u] != null;
        },
        removeSubsets: G,
        getName(o) {
          return o.tagName ? o.tagName.toLowerCase() : null;
        },
        findOne: function o(u, d) {
          let b = null;
          for (let t = 0, m = d.length; t < m && !b; t++)
            if (u(d[t]))
              b = d[t];
            else {
              const R = e(d[t]);
              R && R.length > 0 && (b = o(u, R));
            }
          return b;
        },
        findAll: function o(u, d) {
          let b = [];
          for (let t = 0, m = d.length; t < m; t++) {
            if (!h(d[t]))
              continue;
            u(d[t]) && b.push(d[t]);
            const R = e(d[t]);
            R && (b = b.concat(o(u, R)));
          }
          return b;
        },
        getText: function o(u) {
          return Array.isArray(u) ? u.map(o).join("") : h(u) ? o(e(u)) : u.nodeType === 3 ? u.nodeValue : c.default.isSpriteNode(u.nodeName) ? u.text : "";
        }
      };
      function n(o) {
        if (typeof o != "string")
          return o;
        let u = o.match(/\[(bgcolor|fillColor|strokeColor|color)\s*=\s*['"]?\w+['"]?\]/g);
        return u && (u = u.map((d) => {
          const b = d.slice(1, -1).split("="), t = Object(s.parseColor)(b[1].replace(/['"]/g, ""));
          return [d, `[${b[0]}="${t}"]`];
        }), u.forEach(([d, b]) => {
          o = o.replace(d, b);
        })), u = o.match(/\[\w+\s*=\s*['"]\[.+?\]['"]\]/g), u && (u = u.map((d) => {
          const b = d.slice(1, -1).split("="), t = b[1].slice(2, -2).split(/,/g).map((m) => m.trim());
          return [d, `[${b[0]}="[${t}]"]`];
        }), u.forEach(([d, b]) => {
          o = o.replace(d, b);
        })), o;
      }
      function V(o, u) {
        return W.selectAll(n(o), u, {
          adapter: y
        });
      }
      function I(o, u) {
        return W.selectOne(n(o), u, {
          adapter: y
        });
      }
      function r(o, u) {
        return W.is(o, n(u), {
          adapter: y
        });
      }
      function p(o) {
        return W.compile(n(o), {
          adapter: y
        });
      }
    },
    /* 253 */
    /***/
    function(Z, l, i) {
      Z.exports = p;
      var s = i(254), c = i(273).falseFunc, W = i(274);
      function h(o) {
        return function(d, b, t) {
          return b = b || {}, b.adapter = b.adapter || s, o(d, b, t);
        };
      }
      var e = h(W), a = h(W.compileUnsafe);
      function G(o) {
        return function(d, b, t) {
          return t = t || {}, t.adapter = t.adapter || s, typeof d != "function" && (d = a(d, t, b)), d.shouldTestNextSiblings && (b = n(t && t.context || b, t.adapter)), Array.isArray(b) ? b = t.adapter.removeSubsets(b) : b = t.adapter.getChildren(b), o(d, b, t);
        };
      }
      function y(o, u) {
        var d = u.getSiblings(o);
        if (!Array.isArray(d))
          return [];
        for (d = d.slice(0); d.shift() !== o; )
          ;
        return d;
      }
      function n(o, u) {
        Array.isArray(o) || (o = [o]);
        for (var d = o.slice(0), b = 0, t = o.length; b < t; b++) {
          var m = y(d[b], u);
          d.push.apply(d, m);
        }
        return d;
      }
      var V = G(function(u, d, b) {
        return u === c || !d || d.length === 0 ? [] : b.adapter.findAll(u, d);
      }), I = G(function(u, d, b) {
        return u === c || !d || d.length === 0 ? null : b.adapter.findOne(u, d);
      });
      function r(o, u, d) {
        return d = d || {}, d.adapter = d.adapter || s, (typeof u == "function" ? u : e(u, d))(o);
      }
      function p(o, u, d) {
        return V(o, u, d);
      }
      p.compile = e, p.filters = W.Pseudos.filters, p.pseudos = W.Pseudos.pseudos, p.selectAll = V, p.selectOne = I, p.is = r, p.parse = e, p.iterate = V, p._compileUnsafe = a, p._compileToken = W.compileToken;
    },
    /* 254 */
    /***/
    function(Z, l, i) {
      var s = Z.exports;
      [
        i(255),
        i(268),
        i(269),
        i(270),
        i(271),
        i(272)
      ].forEach(function(c) {
        Object.keys(c).forEach(function(W) {
          s[W] = c[W].bind(s);
        });
      });
    },
    /* 255 */
    /***/
    function(Z, l, i) {
      var s = i(256), c = i(257), W = s.isTag;
      Z.exports = {
        getInnerHTML: h,
        getOuterHTML: c,
        getText: e
      };
      function h(a, G) {
        return a.children ? a.children.map(function(y) {
          return c(y, G);
        }).join("") : "";
      }
      function e(a) {
        return Array.isArray(a) ? a.map(e).join("") : W(a) ? a.name === "br" ? `
` : e(a.children) : a.type === s.CDATA ? e(a.children) : a.type === s.Text ? a.data : "";
      }
    },
    /* 256 */
    /***/
    function(Z, l) {
      Z.exports = {
        Text: "text",
        //Text
        Directive: "directive",
        //<? ... ?>
        Comment: "comment",
        //<!-- ... -->
        Script: "script",
        //<script> tags
        Style: "style",
        //<style> tags
        Tag: "tag",
        //Any tag
        CDATA: "cdata",
        //<![CDATA[ ... ]]>
        Doctype: "doctype",
        isTag: function(i) {
          return i.type === "tag" || i.type === "script" || i.type === "style";
        }
      };
    },
    /* 257 */
    /***/
    function(Z, l, i) {
      var s = i(258), c = i(259), W = i(267);
      W.elementNames.__proto__ = null, W.attributeNames.__proto__ = null;
      var h = {
        __proto__: null,
        style: !0,
        script: !0,
        xmp: !0,
        iframe: !0,
        noembed: !0,
        noframes: !0,
        plaintext: !0,
        noscript: !0
      };
      function e(o, u) {
        if (o) {
          var d = "", b;
          for (var t in o)
            b = o[t], d && (d += " "), u.xmlMode === "foreign" && (t = W.attributeNames[t] || t), d += t, (b !== null && b !== "" || u.xmlMode) && (d += '="' + (u.decodeEntities ? c.encodeXML(b) : b.replace(/\"/g, "&quot;")) + '"');
          return d;
        }
      }
      var a = {
        __proto__: null,
        area: !0,
        base: !0,
        basefont: !0,
        br: !0,
        col: !0,
        command: !0,
        embed: !0,
        frame: !0,
        hr: !0,
        img: !0,
        input: !0,
        isindex: !0,
        keygen: !0,
        link: !0,
        meta: !0,
        param: !0,
        source: !0,
        track: !0,
        wbr: !0
      }, G = Z.exports = function(o, u) {
        !Array.isArray(o) && !o.cheerio && (o = [o]), u = u || {};
        for (var d = "", b = 0; b < o.length; b++) {
          var t = o[b];
          t.type === "root" ? d += G(t.children, u) : s.isTag(t) ? d += n(t, u) : t.type === s.Directive ? d += V(t) : t.type === s.Comment ? d += p(t) : t.type === s.CDATA ? d += r(t) : d += I(t, u);
        }
        return d;
      }, y = [
        "mi",
        "mo",
        "mn",
        "ms",
        "mtext",
        "annotation-xml",
        "foreignObject",
        "desc",
        "title"
      ];
      function n(o, u) {
        u.xmlMode === "foreign" && (o.name = W.elementNames[o.name] || o.name, o.parent && y.indexOf(o.parent.name) >= 0 && (u = Object.assign({}, u, { xmlMode: !1 }))), !u.xmlMode && ["svg", "math"].indexOf(o.name) >= 0 && (u = Object.assign({}, u, { xmlMode: "foreign" }));
        var d = "<" + o.name, b = e(o.attribs, u);
        return b && (d += " " + b), u.xmlMode && (!o.children || o.children.length === 0) ? d += "/>" : (d += ">", o.children && (d += G(o.children, u)), (!a[o.name] || u.xmlMode) && (d += "</" + o.name + ">")), d;
      }
      function V(o) {
        return "<" + o.data + ">";
      }
      function I(o, u) {
        var d = o.data || "";
        return u.decodeEntities && !(o.parent && o.parent.name in h) && (d = c.encodeXML(d)), d;
      }
      function r(o) {
        return "<![CDATA[" + o.children[0].data + "]]>";
      }
      function p(o) {
        return "<!--" + o.data + "-->";
      }
    },
    /* 258 */
    /***/
    function(Z, l, i) {
      Object.defineProperty(l, "__esModule", { value: !0 });
      function s(c) {
        return c.type === "tag" || c.type === "script" || c.type === "style";
      }
      l.isTag = s, l.Text = "text", l.Directive = "directive", l.Comment = "comment", l.Script = "script", l.Style = "style", l.Tag = "tag", l.CDATA = "cdata", l.Doctype = "doctype";
    },
    /* 259 */
    /***/
    function(Z, l, i) {
      Object.defineProperty(l, "__esModule", { value: !0 }), l.encode = l.decodeStrict = l.decode = void 0;
      var s = i(260), c = i(266);
      function W(y, n) {
        return (!n || n <= 0 ? s.decodeXML : s.decodeHTML)(y);
      }
      l.decode = W;
      function h(y, n) {
        return (!n || n <= 0 ? s.decodeXML : s.decodeHTMLStrict)(y);
      }
      l.decodeStrict = h;
      function e(y, n) {
        return (!n || n <= 0 ? c.encodeXML : c.encodeHTML)(y);
      }
      l.encode = e;
      var a = i(266);
      Object.defineProperty(l, "encodeXML", { enumerable: !0, get: function() {
        return a.encodeXML;
      } }), Object.defineProperty(l, "encodeHTML", { enumerable: !0, get: function() {
        return a.encodeHTML;
      } }), Object.defineProperty(l, "escape", { enumerable: !0, get: function() {
        return a.escape;
      } }), Object.defineProperty(l, "encodeHTML4", { enumerable: !0, get: function() {
        return a.encodeHTML;
      } }), Object.defineProperty(l, "encodeHTML5", { enumerable: !0, get: function() {
        return a.encodeHTML;
      } });
      var G = i(260);
      Object.defineProperty(l, "decodeXML", { enumerable: !0, get: function() {
        return G.decodeXML;
      } }), Object.defineProperty(l, "decodeHTML", { enumerable: !0, get: function() {
        return G.decodeHTML;
      } }), Object.defineProperty(l, "decodeHTMLStrict", { enumerable: !0, get: function() {
        return G.decodeHTMLStrict;
      } }), Object.defineProperty(l, "decodeHTML4", { enumerable: !0, get: function() {
        return G.decodeHTML;
      } }), Object.defineProperty(l, "decodeHTML5", { enumerable: !0, get: function() {
        return G.decodeHTML;
      } }), Object.defineProperty(l, "decodeHTML4Strict", { enumerable: !0, get: function() {
        return G.decodeHTMLStrict;
      } }), Object.defineProperty(l, "decodeHTML5Strict", { enumerable: !0, get: function() {
        return G.decodeHTMLStrict;
      } }), Object.defineProperty(l, "decodeXMLStrict", { enumerable: !0, get: function() {
        return G.decodeXML;
      } });
    },
    /* 260 */
    /***/
    function(Z, l, i) {
      var s = this && this.__importDefault || function(n) {
        return n && n.__esModule ? n : { default: n };
      };
      Object.defineProperty(l, "__esModule", { value: !0 }), l.decodeHTML = l.decodeHTMLStrict = l.decodeXML = void 0;
      var c = s(i(261)), W = s(i(262)), h = s(i(263)), e = s(i(264));
      l.decodeXML = a(h.default), l.decodeHTMLStrict = a(c.default);
      function a(n) {
        var V = Object.keys(n).join("|"), I = y(n);
        V += "|#[xX][\\da-fA-F]+|#\\d+";
        var r = new RegExp("&(?:" + V + ");", "g");
        return function(p) {
          return String(p).replace(r, I);
        };
      }
      var G = function(n, V) {
        return n < V ? 1 : -1;
      };
      l.decodeHTML = function() {
        for (var n = Object.keys(W.default).sort(G), V = Object.keys(c.default).sort(G), I = 0, r = 0; I < V.length; I++)
          n[r] === V[I] ? (V[I] += ";?", r++) : V[I] += ";";
        var p = new RegExp("&(?:" + V.join("|") + "|#[xX][\\da-fA-F]+;?|#\\d+;?)", "g"), o = y(c.default);
        function u(d) {
          return d.substr(-1) !== ";" && (d += ";"), o(d);
        }
        return function(d) {
          return String(d).replace(p, u);
        };
      }();
      function y(n) {
        return function(I) {
          if (I.charAt(1) === "#") {
            var r = I.charAt(2);
            return r === "X" || r === "x" ? e.default(parseInt(I.substr(3), 16)) : e.default(parseInt(I.substr(2), 10));
          }
          return n[I.slice(1, -1)];
        };
      }
    },
    /* 261 */
    /***/
    function(Z) {
      Z.exports = JSON.parse('{"Aacute":"Á","aacute":"á","Abreve":"Ă","abreve":"ă","ac":"∾","acd":"∿","acE":"∾̳","Acirc":"Â","acirc":"â","acute":"´","Acy":"А","acy":"а","AElig":"Æ","aelig":"æ","af":"⁡","Afr":"𝔄","afr":"𝔞","Agrave":"À","agrave":"à","alefsym":"ℵ","aleph":"ℵ","Alpha":"Α","alpha":"α","Amacr":"Ā","amacr":"ā","amalg":"⨿","amp":"&","AMP":"&","andand":"⩕","And":"⩓","and":"∧","andd":"⩜","andslope":"⩘","andv":"⩚","ang":"∠","ange":"⦤","angle":"∠","angmsdaa":"⦨","angmsdab":"⦩","angmsdac":"⦪","angmsdad":"⦫","angmsdae":"⦬","angmsdaf":"⦭","angmsdag":"⦮","angmsdah":"⦯","angmsd":"∡","angrt":"∟","angrtvb":"⊾","angrtvbd":"⦝","angsph":"∢","angst":"Å","angzarr":"⍼","Aogon":"Ą","aogon":"ą","Aopf":"𝔸","aopf":"𝕒","apacir":"⩯","ap":"≈","apE":"⩰","ape":"≊","apid":"≋","apos":"\'","ApplyFunction":"⁡","approx":"≈","approxeq":"≊","Aring":"Å","aring":"å","Ascr":"𝒜","ascr":"𝒶","Assign":"≔","ast":"*","asymp":"≈","asympeq":"≍","Atilde":"Ã","atilde":"ã","Auml":"Ä","auml":"ä","awconint":"∳","awint":"⨑","backcong":"≌","backepsilon":"϶","backprime":"‵","backsim":"∽","backsimeq":"⋍","Backslash":"∖","Barv":"⫧","barvee":"⊽","barwed":"⌅","Barwed":"⌆","barwedge":"⌅","bbrk":"⎵","bbrktbrk":"⎶","bcong":"≌","Bcy":"Б","bcy":"б","bdquo":"„","becaus":"∵","because":"∵","Because":"∵","bemptyv":"⦰","bepsi":"϶","bernou":"ℬ","Bernoullis":"ℬ","Beta":"Β","beta":"β","beth":"ℶ","between":"≬","Bfr":"𝔅","bfr":"𝔟","bigcap":"⋂","bigcirc":"◯","bigcup":"⋃","bigodot":"⨀","bigoplus":"⨁","bigotimes":"⨂","bigsqcup":"⨆","bigstar":"★","bigtriangledown":"▽","bigtriangleup":"△","biguplus":"⨄","bigvee":"⋁","bigwedge":"⋀","bkarow":"⤍","blacklozenge":"⧫","blacksquare":"▪","blacktriangle":"▴","blacktriangledown":"▾","blacktriangleleft":"◂","blacktriangleright":"▸","blank":"␣","blk12":"▒","blk14":"░","blk34":"▓","block":"█","bne":"=⃥","bnequiv":"≡⃥","bNot":"⫭","bnot":"⌐","Bopf":"𝔹","bopf":"𝕓","bot":"⊥","bottom":"⊥","bowtie":"⋈","boxbox":"⧉","boxdl":"┐","boxdL":"╕","boxDl":"╖","boxDL":"╗","boxdr":"┌","boxdR":"╒","boxDr":"╓","boxDR":"╔","boxh":"─","boxH":"═","boxhd":"┬","boxHd":"╤","boxhD":"╥","boxHD":"╦","boxhu":"┴","boxHu":"╧","boxhU":"╨","boxHU":"╩","boxminus":"⊟","boxplus":"⊞","boxtimes":"⊠","boxul":"┘","boxuL":"╛","boxUl":"╜","boxUL":"╝","boxur":"└","boxuR":"╘","boxUr":"╙","boxUR":"╚","boxv":"│","boxV":"║","boxvh":"┼","boxvH":"╪","boxVh":"╫","boxVH":"╬","boxvl":"┤","boxvL":"╡","boxVl":"╢","boxVL":"╣","boxvr":"├","boxvR":"╞","boxVr":"╟","boxVR":"╠","bprime":"‵","breve":"˘","Breve":"˘","brvbar":"¦","bscr":"𝒷","Bscr":"ℬ","bsemi":"⁏","bsim":"∽","bsime":"⋍","bsolb":"⧅","bsol":"\\\\","bsolhsub":"⟈","bull":"•","bullet":"•","bump":"≎","bumpE":"⪮","bumpe":"≏","Bumpeq":"≎","bumpeq":"≏","Cacute":"Ć","cacute":"ć","capand":"⩄","capbrcup":"⩉","capcap":"⩋","cap":"∩","Cap":"⋒","capcup":"⩇","capdot":"⩀","CapitalDifferentialD":"ⅅ","caps":"∩︀","caret":"⁁","caron":"ˇ","Cayleys":"ℭ","ccaps":"⩍","Ccaron":"Č","ccaron":"č","Ccedil":"Ç","ccedil":"ç","Ccirc":"Ĉ","ccirc":"ĉ","Cconint":"∰","ccups":"⩌","ccupssm":"⩐","Cdot":"Ċ","cdot":"ċ","cedil":"¸","Cedilla":"¸","cemptyv":"⦲","cent":"¢","centerdot":"·","CenterDot":"·","cfr":"𝔠","Cfr":"ℭ","CHcy":"Ч","chcy":"ч","check":"✓","checkmark":"✓","Chi":"Χ","chi":"χ","circ":"ˆ","circeq":"≗","circlearrowleft":"↺","circlearrowright":"↻","circledast":"⊛","circledcirc":"⊚","circleddash":"⊝","CircleDot":"⊙","circledR":"®","circledS":"Ⓢ","CircleMinus":"⊖","CirclePlus":"⊕","CircleTimes":"⊗","cir":"○","cirE":"⧃","cire":"≗","cirfnint":"⨐","cirmid":"⫯","cirscir":"⧂","ClockwiseContourIntegral":"∲","CloseCurlyDoubleQuote":"”","CloseCurlyQuote":"’","clubs":"♣","clubsuit":"♣","colon":":","Colon":"∷","Colone":"⩴","colone":"≔","coloneq":"≔","comma":",","commat":"@","comp":"∁","compfn":"∘","complement":"∁","complexes":"ℂ","cong":"≅","congdot":"⩭","Congruent":"≡","conint":"∮","Conint":"∯","ContourIntegral":"∮","copf":"𝕔","Copf":"ℂ","coprod":"∐","Coproduct":"∐","copy":"©","COPY":"©","copysr":"℗","CounterClockwiseContourIntegral":"∳","crarr":"↵","cross":"✗","Cross":"⨯","Cscr":"𝒞","cscr":"𝒸","csub":"⫏","csube":"⫑","csup":"⫐","csupe":"⫒","ctdot":"⋯","cudarrl":"⤸","cudarrr":"⤵","cuepr":"⋞","cuesc":"⋟","cularr":"↶","cularrp":"⤽","cupbrcap":"⩈","cupcap":"⩆","CupCap":"≍","cup":"∪","Cup":"⋓","cupcup":"⩊","cupdot":"⊍","cupor":"⩅","cups":"∪︀","curarr":"↷","curarrm":"⤼","curlyeqprec":"⋞","curlyeqsucc":"⋟","curlyvee":"⋎","curlywedge":"⋏","curren":"¤","curvearrowleft":"↶","curvearrowright":"↷","cuvee":"⋎","cuwed":"⋏","cwconint":"∲","cwint":"∱","cylcty":"⌭","dagger":"†","Dagger":"‡","daleth":"ℸ","darr":"↓","Darr":"↡","dArr":"⇓","dash":"‐","Dashv":"⫤","dashv":"⊣","dbkarow":"⤏","dblac":"˝","Dcaron":"Ď","dcaron":"ď","Dcy":"Д","dcy":"д","ddagger":"‡","ddarr":"⇊","DD":"ⅅ","dd":"ⅆ","DDotrahd":"⤑","ddotseq":"⩷","deg":"°","Del":"∇","Delta":"Δ","delta":"δ","demptyv":"⦱","dfisht":"⥿","Dfr":"𝔇","dfr":"𝔡","dHar":"⥥","dharl":"⇃","dharr":"⇂","DiacriticalAcute":"´","DiacriticalDot":"˙","DiacriticalDoubleAcute":"˝","DiacriticalGrave":"`","DiacriticalTilde":"˜","diam":"⋄","diamond":"⋄","Diamond":"⋄","diamondsuit":"♦","diams":"♦","die":"¨","DifferentialD":"ⅆ","digamma":"ϝ","disin":"⋲","div":"÷","divide":"÷","divideontimes":"⋇","divonx":"⋇","DJcy":"Ђ","djcy":"ђ","dlcorn":"⌞","dlcrop":"⌍","dollar":"$","Dopf":"𝔻","dopf":"𝕕","Dot":"¨","dot":"˙","DotDot":"⃜","doteq":"≐","doteqdot":"≑","DotEqual":"≐","dotminus":"∸","dotplus":"∔","dotsquare":"⊡","doublebarwedge":"⌆","DoubleContourIntegral":"∯","DoubleDot":"¨","DoubleDownArrow":"⇓","DoubleLeftArrow":"⇐","DoubleLeftRightArrow":"⇔","DoubleLeftTee":"⫤","DoubleLongLeftArrow":"⟸","DoubleLongLeftRightArrow":"⟺","DoubleLongRightArrow":"⟹","DoubleRightArrow":"⇒","DoubleRightTee":"⊨","DoubleUpArrow":"⇑","DoubleUpDownArrow":"⇕","DoubleVerticalBar":"∥","DownArrowBar":"⤓","downarrow":"↓","DownArrow":"↓","Downarrow":"⇓","DownArrowUpArrow":"⇵","DownBreve":"̑","downdownarrows":"⇊","downharpoonleft":"⇃","downharpoonright":"⇂","DownLeftRightVector":"⥐","DownLeftTeeVector":"⥞","DownLeftVectorBar":"⥖","DownLeftVector":"↽","DownRightTeeVector":"⥟","DownRightVectorBar":"⥗","DownRightVector":"⇁","DownTeeArrow":"↧","DownTee":"⊤","drbkarow":"⤐","drcorn":"⌟","drcrop":"⌌","Dscr":"𝒟","dscr":"𝒹","DScy":"Ѕ","dscy":"ѕ","dsol":"⧶","Dstrok":"Đ","dstrok":"đ","dtdot":"⋱","dtri":"▿","dtrif":"▾","duarr":"⇵","duhar":"⥯","dwangle":"⦦","DZcy":"Џ","dzcy":"џ","dzigrarr":"⟿","Eacute":"É","eacute":"é","easter":"⩮","Ecaron":"Ě","ecaron":"ě","Ecirc":"Ê","ecirc":"ê","ecir":"≖","ecolon":"≕","Ecy":"Э","ecy":"э","eDDot":"⩷","Edot":"Ė","edot":"ė","eDot":"≑","ee":"ⅇ","efDot":"≒","Efr":"𝔈","efr":"𝔢","eg":"⪚","Egrave":"È","egrave":"è","egs":"⪖","egsdot":"⪘","el":"⪙","Element":"∈","elinters":"⏧","ell":"ℓ","els":"⪕","elsdot":"⪗","Emacr":"Ē","emacr":"ē","empty":"∅","emptyset":"∅","EmptySmallSquare":"◻","emptyv":"∅","EmptyVerySmallSquare":"▫","emsp13":" ","emsp14":" ","emsp":" ","ENG":"Ŋ","eng":"ŋ","ensp":" ","Eogon":"Ę","eogon":"ę","Eopf":"𝔼","eopf":"𝕖","epar":"⋕","eparsl":"⧣","eplus":"⩱","epsi":"ε","Epsilon":"Ε","epsilon":"ε","epsiv":"ϵ","eqcirc":"≖","eqcolon":"≕","eqsim":"≂","eqslantgtr":"⪖","eqslantless":"⪕","Equal":"⩵","equals":"=","EqualTilde":"≂","equest":"≟","Equilibrium":"⇌","equiv":"≡","equivDD":"⩸","eqvparsl":"⧥","erarr":"⥱","erDot":"≓","escr":"ℯ","Escr":"ℰ","esdot":"≐","Esim":"⩳","esim":"≂","Eta":"Η","eta":"η","ETH":"Ð","eth":"ð","Euml":"Ë","euml":"ë","euro":"€","excl":"!","exist":"∃","Exists":"∃","expectation":"ℰ","exponentiale":"ⅇ","ExponentialE":"ⅇ","fallingdotseq":"≒","Fcy":"Ф","fcy":"ф","female":"♀","ffilig":"ﬃ","fflig":"ﬀ","ffllig":"ﬄ","Ffr":"𝔉","ffr":"𝔣","filig":"ﬁ","FilledSmallSquare":"◼","FilledVerySmallSquare":"▪","fjlig":"fj","flat":"♭","fllig":"ﬂ","fltns":"▱","fnof":"ƒ","Fopf":"𝔽","fopf":"𝕗","forall":"∀","ForAll":"∀","fork":"⋔","forkv":"⫙","Fouriertrf":"ℱ","fpartint":"⨍","frac12":"½","frac13":"⅓","frac14":"¼","frac15":"⅕","frac16":"⅙","frac18":"⅛","frac23":"⅔","frac25":"⅖","frac34":"¾","frac35":"⅗","frac38":"⅜","frac45":"⅘","frac56":"⅚","frac58":"⅝","frac78":"⅞","frasl":"⁄","frown":"⌢","fscr":"𝒻","Fscr":"ℱ","gacute":"ǵ","Gamma":"Γ","gamma":"γ","Gammad":"Ϝ","gammad":"ϝ","gap":"⪆","Gbreve":"Ğ","gbreve":"ğ","Gcedil":"Ģ","Gcirc":"Ĝ","gcirc":"ĝ","Gcy":"Г","gcy":"г","Gdot":"Ġ","gdot":"ġ","ge":"≥","gE":"≧","gEl":"⪌","gel":"⋛","geq":"≥","geqq":"≧","geqslant":"⩾","gescc":"⪩","ges":"⩾","gesdot":"⪀","gesdoto":"⪂","gesdotol":"⪄","gesl":"⋛︀","gesles":"⪔","Gfr":"𝔊","gfr":"𝔤","gg":"≫","Gg":"⋙","ggg":"⋙","gimel":"ℷ","GJcy":"Ѓ","gjcy":"ѓ","gla":"⪥","gl":"≷","glE":"⪒","glj":"⪤","gnap":"⪊","gnapprox":"⪊","gne":"⪈","gnE":"≩","gneq":"⪈","gneqq":"≩","gnsim":"⋧","Gopf":"𝔾","gopf":"𝕘","grave":"`","GreaterEqual":"≥","GreaterEqualLess":"⋛","GreaterFullEqual":"≧","GreaterGreater":"⪢","GreaterLess":"≷","GreaterSlantEqual":"⩾","GreaterTilde":"≳","Gscr":"𝒢","gscr":"ℊ","gsim":"≳","gsime":"⪎","gsiml":"⪐","gtcc":"⪧","gtcir":"⩺","gt":">","GT":">","Gt":"≫","gtdot":"⋗","gtlPar":"⦕","gtquest":"⩼","gtrapprox":"⪆","gtrarr":"⥸","gtrdot":"⋗","gtreqless":"⋛","gtreqqless":"⪌","gtrless":"≷","gtrsim":"≳","gvertneqq":"≩︀","gvnE":"≩︀","Hacek":"ˇ","hairsp":" ","half":"½","hamilt":"ℋ","HARDcy":"Ъ","hardcy":"ъ","harrcir":"⥈","harr":"↔","hArr":"⇔","harrw":"↭","Hat":"^","hbar":"ℏ","Hcirc":"Ĥ","hcirc":"ĥ","hearts":"♥","heartsuit":"♥","hellip":"…","hercon":"⊹","hfr":"𝔥","Hfr":"ℌ","HilbertSpace":"ℋ","hksearow":"⤥","hkswarow":"⤦","hoarr":"⇿","homtht":"∻","hookleftarrow":"↩","hookrightarrow":"↪","hopf":"𝕙","Hopf":"ℍ","horbar":"―","HorizontalLine":"─","hscr":"𝒽","Hscr":"ℋ","hslash":"ℏ","Hstrok":"Ħ","hstrok":"ħ","HumpDownHump":"≎","HumpEqual":"≏","hybull":"⁃","hyphen":"‐","Iacute":"Í","iacute":"í","ic":"⁣","Icirc":"Î","icirc":"î","Icy":"И","icy":"и","Idot":"İ","IEcy":"Е","iecy":"е","iexcl":"¡","iff":"⇔","ifr":"𝔦","Ifr":"ℑ","Igrave":"Ì","igrave":"ì","ii":"ⅈ","iiiint":"⨌","iiint":"∭","iinfin":"⧜","iiota":"℩","IJlig":"Ĳ","ijlig":"ĳ","Imacr":"Ī","imacr":"ī","image":"ℑ","ImaginaryI":"ⅈ","imagline":"ℐ","imagpart":"ℑ","imath":"ı","Im":"ℑ","imof":"⊷","imped":"Ƶ","Implies":"⇒","incare":"℅","in":"∈","infin":"∞","infintie":"⧝","inodot":"ı","intcal":"⊺","int":"∫","Int":"∬","integers":"ℤ","Integral":"∫","intercal":"⊺","Intersection":"⋂","intlarhk":"⨗","intprod":"⨼","InvisibleComma":"⁣","InvisibleTimes":"⁢","IOcy":"Ё","iocy":"ё","Iogon":"Į","iogon":"į","Iopf":"𝕀","iopf":"𝕚","Iota":"Ι","iota":"ι","iprod":"⨼","iquest":"¿","iscr":"𝒾","Iscr":"ℐ","isin":"∈","isindot":"⋵","isinE":"⋹","isins":"⋴","isinsv":"⋳","isinv":"∈","it":"⁢","Itilde":"Ĩ","itilde":"ĩ","Iukcy":"І","iukcy":"і","Iuml":"Ï","iuml":"ï","Jcirc":"Ĵ","jcirc":"ĵ","Jcy":"Й","jcy":"й","Jfr":"𝔍","jfr":"𝔧","jmath":"ȷ","Jopf":"𝕁","jopf":"𝕛","Jscr":"𝒥","jscr":"𝒿","Jsercy":"Ј","jsercy":"ј","Jukcy":"Є","jukcy":"є","Kappa":"Κ","kappa":"κ","kappav":"ϰ","Kcedil":"Ķ","kcedil":"ķ","Kcy":"К","kcy":"к","Kfr":"𝔎","kfr":"𝔨","kgreen":"ĸ","KHcy":"Х","khcy":"х","KJcy":"Ќ","kjcy":"ќ","Kopf":"𝕂","kopf":"𝕜","Kscr":"𝒦","kscr":"𝓀","lAarr":"⇚","Lacute":"Ĺ","lacute":"ĺ","laemptyv":"⦴","lagran":"ℒ","Lambda":"Λ","lambda":"λ","lang":"⟨","Lang":"⟪","langd":"⦑","langle":"⟨","lap":"⪅","Laplacetrf":"ℒ","laquo":"«","larrb":"⇤","larrbfs":"⤟","larr":"←","Larr":"↞","lArr":"⇐","larrfs":"⤝","larrhk":"↩","larrlp":"↫","larrpl":"⤹","larrsim":"⥳","larrtl":"↢","latail":"⤙","lAtail":"⤛","lat":"⪫","late":"⪭","lates":"⪭︀","lbarr":"⤌","lBarr":"⤎","lbbrk":"❲","lbrace":"{","lbrack":"[","lbrke":"⦋","lbrksld":"⦏","lbrkslu":"⦍","Lcaron":"Ľ","lcaron":"ľ","Lcedil":"Ļ","lcedil":"ļ","lceil":"⌈","lcub":"{","Lcy":"Л","lcy":"л","ldca":"⤶","ldquo":"“","ldquor":"„","ldrdhar":"⥧","ldrushar":"⥋","ldsh":"↲","le":"≤","lE":"≦","LeftAngleBracket":"⟨","LeftArrowBar":"⇤","leftarrow":"←","LeftArrow":"←","Leftarrow":"⇐","LeftArrowRightArrow":"⇆","leftarrowtail":"↢","LeftCeiling":"⌈","LeftDoubleBracket":"⟦","LeftDownTeeVector":"⥡","LeftDownVectorBar":"⥙","LeftDownVector":"⇃","LeftFloor":"⌊","leftharpoondown":"↽","leftharpoonup":"↼","leftleftarrows":"⇇","leftrightarrow":"↔","LeftRightArrow":"↔","Leftrightarrow":"⇔","leftrightarrows":"⇆","leftrightharpoons":"⇋","leftrightsquigarrow":"↭","LeftRightVector":"⥎","LeftTeeArrow":"↤","LeftTee":"⊣","LeftTeeVector":"⥚","leftthreetimes":"⋋","LeftTriangleBar":"⧏","LeftTriangle":"⊲","LeftTriangleEqual":"⊴","LeftUpDownVector":"⥑","LeftUpTeeVector":"⥠","LeftUpVectorBar":"⥘","LeftUpVector":"↿","LeftVectorBar":"⥒","LeftVector":"↼","lEg":"⪋","leg":"⋚","leq":"≤","leqq":"≦","leqslant":"⩽","lescc":"⪨","les":"⩽","lesdot":"⩿","lesdoto":"⪁","lesdotor":"⪃","lesg":"⋚︀","lesges":"⪓","lessapprox":"⪅","lessdot":"⋖","lesseqgtr":"⋚","lesseqqgtr":"⪋","LessEqualGreater":"⋚","LessFullEqual":"≦","LessGreater":"≶","lessgtr":"≶","LessLess":"⪡","lesssim":"≲","LessSlantEqual":"⩽","LessTilde":"≲","lfisht":"⥼","lfloor":"⌊","Lfr":"𝔏","lfr":"𝔩","lg":"≶","lgE":"⪑","lHar":"⥢","lhard":"↽","lharu":"↼","lharul":"⥪","lhblk":"▄","LJcy":"Љ","ljcy":"љ","llarr":"⇇","ll":"≪","Ll":"⋘","llcorner":"⌞","Lleftarrow":"⇚","llhard":"⥫","lltri":"◺","Lmidot":"Ŀ","lmidot":"ŀ","lmoustache":"⎰","lmoust":"⎰","lnap":"⪉","lnapprox":"⪉","lne":"⪇","lnE":"≨","lneq":"⪇","lneqq":"≨","lnsim":"⋦","loang":"⟬","loarr":"⇽","lobrk":"⟦","longleftarrow":"⟵","LongLeftArrow":"⟵","Longleftarrow":"⟸","longleftrightarrow":"⟷","LongLeftRightArrow":"⟷","Longleftrightarrow":"⟺","longmapsto":"⟼","longrightarrow":"⟶","LongRightArrow":"⟶","Longrightarrow":"⟹","looparrowleft":"↫","looparrowright":"↬","lopar":"⦅","Lopf":"𝕃","lopf":"𝕝","loplus":"⨭","lotimes":"⨴","lowast":"∗","lowbar":"_","LowerLeftArrow":"↙","LowerRightArrow":"↘","loz":"◊","lozenge":"◊","lozf":"⧫","lpar":"(","lparlt":"⦓","lrarr":"⇆","lrcorner":"⌟","lrhar":"⇋","lrhard":"⥭","lrm":"‎","lrtri":"⊿","lsaquo":"‹","lscr":"𝓁","Lscr":"ℒ","lsh":"↰","Lsh":"↰","lsim":"≲","lsime":"⪍","lsimg":"⪏","lsqb":"[","lsquo":"‘","lsquor":"‚","Lstrok":"Ł","lstrok":"ł","ltcc":"⪦","ltcir":"⩹","lt":"<","LT":"<","Lt":"≪","ltdot":"⋖","lthree":"⋋","ltimes":"⋉","ltlarr":"⥶","ltquest":"⩻","ltri":"◃","ltrie":"⊴","ltrif":"◂","ltrPar":"⦖","lurdshar":"⥊","luruhar":"⥦","lvertneqq":"≨︀","lvnE":"≨︀","macr":"¯","male":"♂","malt":"✠","maltese":"✠","Map":"⤅","map":"↦","mapsto":"↦","mapstodown":"↧","mapstoleft":"↤","mapstoup":"↥","marker":"▮","mcomma":"⨩","Mcy":"М","mcy":"м","mdash":"—","mDDot":"∺","measuredangle":"∡","MediumSpace":" ","Mellintrf":"ℳ","Mfr":"𝔐","mfr":"𝔪","mho":"℧","micro":"µ","midast":"*","midcir":"⫰","mid":"∣","middot":"·","minusb":"⊟","minus":"−","minusd":"∸","minusdu":"⨪","MinusPlus":"∓","mlcp":"⫛","mldr":"…","mnplus":"∓","models":"⊧","Mopf":"𝕄","mopf":"𝕞","mp":"∓","mscr":"𝓂","Mscr":"ℳ","mstpos":"∾","Mu":"Μ","mu":"μ","multimap":"⊸","mumap":"⊸","nabla":"∇","Nacute":"Ń","nacute":"ń","nang":"∠⃒","nap":"≉","napE":"⩰̸","napid":"≋̸","napos":"ŉ","napprox":"≉","natural":"♮","naturals":"ℕ","natur":"♮","nbsp":" ","nbump":"≎̸","nbumpe":"≏̸","ncap":"⩃","Ncaron":"Ň","ncaron":"ň","Ncedil":"Ņ","ncedil":"ņ","ncong":"≇","ncongdot":"⩭̸","ncup":"⩂","Ncy":"Н","ncy":"н","ndash":"–","nearhk":"⤤","nearr":"↗","neArr":"⇗","nearrow":"↗","ne":"≠","nedot":"≐̸","NegativeMediumSpace":"​","NegativeThickSpace":"​","NegativeThinSpace":"​","NegativeVeryThinSpace":"​","nequiv":"≢","nesear":"⤨","nesim":"≂̸","NestedGreaterGreater":"≫","NestedLessLess":"≪","NewLine":"\\n","nexist":"∄","nexists":"∄","Nfr":"𝔑","nfr":"𝔫","ngE":"≧̸","nge":"≱","ngeq":"≱","ngeqq":"≧̸","ngeqslant":"⩾̸","nges":"⩾̸","nGg":"⋙̸","ngsim":"≵","nGt":"≫⃒","ngt":"≯","ngtr":"≯","nGtv":"≫̸","nharr":"↮","nhArr":"⇎","nhpar":"⫲","ni":"∋","nis":"⋼","nisd":"⋺","niv":"∋","NJcy":"Њ","njcy":"њ","nlarr":"↚","nlArr":"⇍","nldr":"‥","nlE":"≦̸","nle":"≰","nleftarrow":"↚","nLeftarrow":"⇍","nleftrightarrow":"↮","nLeftrightarrow":"⇎","nleq":"≰","nleqq":"≦̸","nleqslant":"⩽̸","nles":"⩽̸","nless":"≮","nLl":"⋘̸","nlsim":"≴","nLt":"≪⃒","nlt":"≮","nltri":"⋪","nltrie":"⋬","nLtv":"≪̸","nmid":"∤","NoBreak":"⁠","NonBreakingSpace":" ","nopf":"𝕟","Nopf":"ℕ","Not":"⫬","not":"¬","NotCongruent":"≢","NotCupCap":"≭","NotDoubleVerticalBar":"∦","NotElement":"∉","NotEqual":"≠","NotEqualTilde":"≂̸","NotExists":"∄","NotGreater":"≯","NotGreaterEqual":"≱","NotGreaterFullEqual":"≧̸","NotGreaterGreater":"≫̸","NotGreaterLess":"≹","NotGreaterSlantEqual":"⩾̸","NotGreaterTilde":"≵","NotHumpDownHump":"≎̸","NotHumpEqual":"≏̸","notin":"∉","notindot":"⋵̸","notinE":"⋹̸","notinva":"∉","notinvb":"⋷","notinvc":"⋶","NotLeftTriangleBar":"⧏̸","NotLeftTriangle":"⋪","NotLeftTriangleEqual":"⋬","NotLess":"≮","NotLessEqual":"≰","NotLessGreater":"≸","NotLessLess":"≪̸","NotLessSlantEqual":"⩽̸","NotLessTilde":"≴","NotNestedGreaterGreater":"⪢̸","NotNestedLessLess":"⪡̸","notni":"∌","notniva":"∌","notnivb":"⋾","notnivc":"⋽","NotPrecedes":"⊀","NotPrecedesEqual":"⪯̸","NotPrecedesSlantEqual":"⋠","NotReverseElement":"∌","NotRightTriangleBar":"⧐̸","NotRightTriangle":"⋫","NotRightTriangleEqual":"⋭","NotSquareSubset":"⊏̸","NotSquareSubsetEqual":"⋢","NotSquareSuperset":"⊐̸","NotSquareSupersetEqual":"⋣","NotSubset":"⊂⃒","NotSubsetEqual":"⊈","NotSucceeds":"⊁","NotSucceedsEqual":"⪰̸","NotSucceedsSlantEqual":"⋡","NotSucceedsTilde":"≿̸","NotSuperset":"⊃⃒","NotSupersetEqual":"⊉","NotTilde":"≁","NotTildeEqual":"≄","NotTildeFullEqual":"≇","NotTildeTilde":"≉","NotVerticalBar":"∤","nparallel":"∦","npar":"∦","nparsl":"⫽⃥","npart":"∂̸","npolint":"⨔","npr":"⊀","nprcue":"⋠","nprec":"⊀","npreceq":"⪯̸","npre":"⪯̸","nrarrc":"⤳̸","nrarr":"↛","nrArr":"⇏","nrarrw":"↝̸","nrightarrow":"↛","nRightarrow":"⇏","nrtri":"⋫","nrtrie":"⋭","nsc":"⊁","nsccue":"⋡","nsce":"⪰̸","Nscr":"𝒩","nscr":"𝓃","nshortmid":"∤","nshortparallel":"∦","nsim":"≁","nsime":"≄","nsimeq":"≄","nsmid":"∤","nspar":"∦","nsqsube":"⋢","nsqsupe":"⋣","nsub":"⊄","nsubE":"⫅̸","nsube":"⊈","nsubset":"⊂⃒","nsubseteq":"⊈","nsubseteqq":"⫅̸","nsucc":"⊁","nsucceq":"⪰̸","nsup":"⊅","nsupE":"⫆̸","nsupe":"⊉","nsupset":"⊃⃒","nsupseteq":"⊉","nsupseteqq":"⫆̸","ntgl":"≹","Ntilde":"Ñ","ntilde":"ñ","ntlg":"≸","ntriangleleft":"⋪","ntrianglelefteq":"⋬","ntriangleright":"⋫","ntrianglerighteq":"⋭","Nu":"Ν","nu":"ν","num":"#","numero":"№","numsp":" ","nvap":"≍⃒","nvdash":"⊬","nvDash":"⊭","nVdash":"⊮","nVDash":"⊯","nvge":"≥⃒","nvgt":">⃒","nvHarr":"⤄","nvinfin":"⧞","nvlArr":"⤂","nvle":"≤⃒","nvlt":"<⃒","nvltrie":"⊴⃒","nvrArr":"⤃","nvrtrie":"⊵⃒","nvsim":"∼⃒","nwarhk":"⤣","nwarr":"↖","nwArr":"⇖","nwarrow":"↖","nwnear":"⤧","Oacute":"Ó","oacute":"ó","oast":"⊛","Ocirc":"Ô","ocirc":"ô","ocir":"⊚","Ocy":"О","ocy":"о","odash":"⊝","Odblac":"Ő","odblac":"ő","odiv":"⨸","odot":"⊙","odsold":"⦼","OElig":"Œ","oelig":"œ","ofcir":"⦿","Ofr":"𝔒","ofr":"𝔬","ogon":"˛","Ograve":"Ò","ograve":"ò","ogt":"⧁","ohbar":"⦵","ohm":"Ω","oint":"∮","olarr":"↺","olcir":"⦾","olcross":"⦻","oline":"‾","olt":"⧀","Omacr":"Ō","omacr":"ō","Omega":"Ω","omega":"ω","Omicron":"Ο","omicron":"ο","omid":"⦶","ominus":"⊖","Oopf":"𝕆","oopf":"𝕠","opar":"⦷","OpenCurlyDoubleQuote":"“","OpenCurlyQuote":"‘","operp":"⦹","oplus":"⊕","orarr":"↻","Or":"⩔","or":"∨","ord":"⩝","order":"ℴ","orderof":"ℴ","ordf":"ª","ordm":"º","origof":"⊶","oror":"⩖","orslope":"⩗","orv":"⩛","oS":"Ⓢ","Oscr":"𝒪","oscr":"ℴ","Oslash":"Ø","oslash":"ø","osol":"⊘","Otilde":"Õ","otilde":"õ","otimesas":"⨶","Otimes":"⨷","otimes":"⊗","Ouml":"Ö","ouml":"ö","ovbar":"⌽","OverBar":"‾","OverBrace":"⏞","OverBracket":"⎴","OverParenthesis":"⏜","para":"¶","parallel":"∥","par":"∥","parsim":"⫳","parsl":"⫽","part":"∂","PartialD":"∂","Pcy":"П","pcy":"п","percnt":"%","period":".","permil":"‰","perp":"⊥","pertenk":"‱","Pfr":"𝔓","pfr":"𝔭","Phi":"Φ","phi":"φ","phiv":"ϕ","phmmat":"ℳ","phone":"☎","Pi":"Π","pi":"π","pitchfork":"⋔","piv":"ϖ","planck":"ℏ","planckh":"ℎ","plankv":"ℏ","plusacir":"⨣","plusb":"⊞","pluscir":"⨢","plus":"+","plusdo":"∔","plusdu":"⨥","pluse":"⩲","PlusMinus":"±","plusmn":"±","plussim":"⨦","plustwo":"⨧","pm":"±","Poincareplane":"ℌ","pointint":"⨕","popf":"𝕡","Popf":"ℙ","pound":"£","prap":"⪷","Pr":"⪻","pr":"≺","prcue":"≼","precapprox":"⪷","prec":"≺","preccurlyeq":"≼","Precedes":"≺","PrecedesEqual":"⪯","PrecedesSlantEqual":"≼","PrecedesTilde":"≾","preceq":"⪯","precnapprox":"⪹","precneqq":"⪵","precnsim":"⋨","pre":"⪯","prE":"⪳","precsim":"≾","prime":"′","Prime":"″","primes":"ℙ","prnap":"⪹","prnE":"⪵","prnsim":"⋨","prod":"∏","Product":"∏","profalar":"⌮","profline":"⌒","profsurf":"⌓","prop":"∝","Proportional":"∝","Proportion":"∷","propto":"∝","prsim":"≾","prurel":"⊰","Pscr":"𝒫","pscr":"𝓅","Psi":"Ψ","psi":"ψ","puncsp":" ","Qfr":"𝔔","qfr":"𝔮","qint":"⨌","qopf":"𝕢","Qopf":"ℚ","qprime":"⁗","Qscr":"𝒬","qscr":"𝓆","quaternions":"ℍ","quatint":"⨖","quest":"?","questeq":"≟","quot":"\\"","QUOT":"\\"","rAarr":"⇛","race":"∽̱","Racute":"Ŕ","racute":"ŕ","radic":"√","raemptyv":"⦳","rang":"⟩","Rang":"⟫","rangd":"⦒","range":"⦥","rangle":"⟩","raquo":"»","rarrap":"⥵","rarrb":"⇥","rarrbfs":"⤠","rarrc":"⤳","rarr":"→","Rarr":"↠","rArr":"⇒","rarrfs":"⤞","rarrhk":"↪","rarrlp":"↬","rarrpl":"⥅","rarrsim":"⥴","Rarrtl":"⤖","rarrtl":"↣","rarrw":"↝","ratail":"⤚","rAtail":"⤜","ratio":"∶","rationals":"ℚ","rbarr":"⤍","rBarr":"⤏","RBarr":"⤐","rbbrk":"❳","rbrace":"}","rbrack":"]","rbrke":"⦌","rbrksld":"⦎","rbrkslu":"⦐","Rcaron":"Ř","rcaron":"ř","Rcedil":"Ŗ","rcedil":"ŗ","rceil":"⌉","rcub":"}","Rcy":"Р","rcy":"р","rdca":"⤷","rdldhar":"⥩","rdquo":"”","rdquor":"”","rdsh":"↳","real":"ℜ","realine":"ℛ","realpart":"ℜ","reals":"ℝ","Re":"ℜ","rect":"▭","reg":"®","REG":"®","ReverseElement":"∋","ReverseEquilibrium":"⇋","ReverseUpEquilibrium":"⥯","rfisht":"⥽","rfloor":"⌋","rfr":"𝔯","Rfr":"ℜ","rHar":"⥤","rhard":"⇁","rharu":"⇀","rharul":"⥬","Rho":"Ρ","rho":"ρ","rhov":"ϱ","RightAngleBracket":"⟩","RightArrowBar":"⇥","rightarrow":"→","RightArrow":"→","Rightarrow":"⇒","RightArrowLeftArrow":"⇄","rightarrowtail":"↣","RightCeiling":"⌉","RightDoubleBracket":"⟧","RightDownTeeVector":"⥝","RightDownVectorBar":"⥕","RightDownVector":"⇂","RightFloor":"⌋","rightharpoondown":"⇁","rightharpoonup":"⇀","rightleftarrows":"⇄","rightleftharpoons":"⇌","rightrightarrows":"⇉","rightsquigarrow":"↝","RightTeeArrow":"↦","RightTee":"⊢","RightTeeVector":"⥛","rightthreetimes":"⋌","RightTriangleBar":"⧐","RightTriangle":"⊳","RightTriangleEqual":"⊵","RightUpDownVector":"⥏","RightUpTeeVector":"⥜","RightUpVectorBar":"⥔","RightUpVector":"↾","RightVectorBar":"⥓","RightVector":"⇀","ring":"˚","risingdotseq":"≓","rlarr":"⇄","rlhar":"⇌","rlm":"‏","rmoustache":"⎱","rmoust":"⎱","rnmid":"⫮","roang":"⟭","roarr":"⇾","robrk":"⟧","ropar":"⦆","ropf":"𝕣","Ropf":"ℝ","roplus":"⨮","rotimes":"⨵","RoundImplies":"⥰","rpar":")","rpargt":"⦔","rppolint":"⨒","rrarr":"⇉","Rrightarrow":"⇛","rsaquo":"›","rscr":"𝓇","Rscr":"ℛ","rsh":"↱","Rsh":"↱","rsqb":"]","rsquo":"’","rsquor":"’","rthree":"⋌","rtimes":"⋊","rtri":"▹","rtrie":"⊵","rtrif":"▸","rtriltri":"⧎","RuleDelayed":"⧴","ruluhar":"⥨","rx":"℞","Sacute":"Ś","sacute":"ś","sbquo":"‚","scap":"⪸","Scaron":"Š","scaron":"š","Sc":"⪼","sc":"≻","sccue":"≽","sce":"⪰","scE":"⪴","Scedil":"Ş","scedil":"ş","Scirc":"Ŝ","scirc":"ŝ","scnap":"⪺","scnE":"⪶","scnsim":"⋩","scpolint":"⨓","scsim":"≿","Scy":"С","scy":"с","sdotb":"⊡","sdot":"⋅","sdote":"⩦","searhk":"⤥","searr":"↘","seArr":"⇘","searrow":"↘","sect":"§","semi":";","seswar":"⤩","setminus":"∖","setmn":"∖","sext":"✶","Sfr":"𝔖","sfr":"𝔰","sfrown":"⌢","sharp":"♯","SHCHcy":"Щ","shchcy":"щ","SHcy":"Ш","shcy":"ш","ShortDownArrow":"↓","ShortLeftArrow":"←","shortmid":"∣","shortparallel":"∥","ShortRightArrow":"→","ShortUpArrow":"↑","shy":"­","Sigma":"Σ","sigma":"σ","sigmaf":"ς","sigmav":"ς","sim":"∼","simdot":"⩪","sime":"≃","simeq":"≃","simg":"⪞","simgE":"⪠","siml":"⪝","simlE":"⪟","simne":"≆","simplus":"⨤","simrarr":"⥲","slarr":"←","SmallCircle":"∘","smallsetminus":"∖","smashp":"⨳","smeparsl":"⧤","smid":"∣","smile":"⌣","smt":"⪪","smte":"⪬","smtes":"⪬︀","SOFTcy":"Ь","softcy":"ь","solbar":"⌿","solb":"⧄","sol":"/","Sopf":"𝕊","sopf":"𝕤","spades":"♠","spadesuit":"♠","spar":"∥","sqcap":"⊓","sqcaps":"⊓︀","sqcup":"⊔","sqcups":"⊔︀","Sqrt":"√","sqsub":"⊏","sqsube":"⊑","sqsubset":"⊏","sqsubseteq":"⊑","sqsup":"⊐","sqsupe":"⊒","sqsupset":"⊐","sqsupseteq":"⊒","square":"□","Square":"□","SquareIntersection":"⊓","SquareSubset":"⊏","SquareSubsetEqual":"⊑","SquareSuperset":"⊐","SquareSupersetEqual":"⊒","SquareUnion":"⊔","squarf":"▪","squ":"□","squf":"▪","srarr":"→","Sscr":"𝒮","sscr":"𝓈","ssetmn":"∖","ssmile":"⌣","sstarf":"⋆","Star":"⋆","star":"☆","starf":"★","straightepsilon":"ϵ","straightphi":"ϕ","strns":"¯","sub":"⊂","Sub":"⋐","subdot":"⪽","subE":"⫅","sube":"⊆","subedot":"⫃","submult":"⫁","subnE":"⫋","subne":"⊊","subplus":"⪿","subrarr":"⥹","subset":"⊂","Subset":"⋐","subseteq":"⊆","subseteqq":"⫅","SubsetEqual":"⊆","subsetneq":"⊊","subsetneqq":"⫋","subsim":"⫇","subsub":"⫕","subsup":"⫓","succapprox":"⪸","succ":"≻","succcurlyeq":"≽","Succeeds":"≻","SucceedsEqual":"⪰","SucceedsSlantEqual":"≽","SucceedsTilde":"≿","succeq":"⪰","succnapprox":"⪺","succneqq":"⪶","succnsim":"⋩","succsim":"≿","SuchThat":"∋","sum":"∑","Sum":"∑","sung":"♪","sup1":"¹","sup2":"²","sup3":"³","sup":"⊃","Sup":"⋑","supdot":"⪾","supdsub":"⫘","supE":"⫆","supe":"⊇","supedot":"⫄","Superset":"⊃","SupersetEqual":"⊇","suphsol":"⟉","suphsub":"⫗","suplarr":"⥻","supmult":"⫂","supnE":"⫌","supne":"⊋","supplus":"⫀","supset":"⊃","Supset":"⋑","supseteq":"⊇","supseteqq":"⫆","supsetneq":"⊋","supsetneqq":"⫌","supsim":"⫈","supsub":"⫔","supsup":"⫖","swarhk":"⤦","swarr":"↙","swArr":"⇙","swarrow":"↙","swnwar":"⤪","szlig":"ß","Tab":"\\t","target":"⌖","Tau":"Τ","tau":"τ","tbrk":"⎴","Tcaron":"Ť","tcaron":"ť","Tcedil":"Ţ","tcedil":"ţ","Tcy":"Т","tcy":"т","tdot":"⃛","telrec":"⌕","Tfr":"𝔗","tfr":"𝔱","there4":"∴","therefore":"∴","Therefore":"∴","Theta":"Θ","theta":"θ","thetasym":"ϑ","thetav":"ϑ","thickapprox":"≈","thicksim":"∼","ThickSpace":"  ","ThinSpace":" ","thinsp":" ","thkap":"≈","thksim":"∼","THORN":"Þ","thorn":"þ","tilde":"˜","Tilde":"∼","TildeEqual":"≃","TildeFullEqual":"≅","TildeTilde":"≈","timesbar":"⨱","timesb":"⊠","times":"×","timesd":"⨰","tint":"∭","toea":"⤨","topbot":"⌶","topcir":"⫱","top":"⊤","Topf":"𝕋","topf":"𝕥","topfork":"⫚","tosa":"⤩","tprime":"‴","trade":"™","TRADE":"™","triangle":"▵","triangledown":"▿","triangleleft":"◃","trianglelefteq":"⊴","triangleq":"≜","triangleright":"▹","trianglerighteq":"⊵","tridot":"◬","trie":"≜","triminus":"⨺","TripleDot":"⃛","triplus":"⨹","trisb":"⧍","tritime":"⨻","trpezium":"⏢","Tscr":"𝒯","tscr":"𝓉","TScy":"Ц","tscy":"ц","TSHcy":"Ћ","tshcy":"ћ","Tstrok":"Ŧ","tstrok":"ŧ","twixt":"≬","twoheadleftarrow":"↞","twoheadrightarrow":"↠","Uacute":"Ú","uacute":"ú","uarr":"↑","Uarr":"↟","uArr":"⇑","Uarrocir":"⥉","Ubrcy":"Ў","ubrcy":"ў","Ubreve":"Ŭ","ubreve":"ŭ","Ucirc":"Û","ucirc":"û","Ucy":"У","ucy":"у","udarr":"⇅","Udblac":"Ű","udblac":"ű","udhar":"⥮","ufisht":"⥾","Ufr":"𝔘","ufr":"𝔲","Ugrave":"Ù","ugrave":"ù","uHar":"⥣","uharl":"↿","uharr":"↾","uhblk":"▀","ulcorn":"⌜","ulcorner":"⌜","ulcrop":"⌏","ultri":"◸","Umacr":"Ū","umacr":"ū","uml":"¨","UnderBar":"_","UnderBrace":"⏟","UnderBracket":"⎵","UnderParenthesis":"⏝","Union":"⋃","UnionPlus":"⊎","Uogon":"Ų","uogon":"ų","Uopf":"𝕌","uopf":"𝕦","UpArrowBar":"⤒","uparrow":"↑","UpArrow":"↑","Uparrow":"⇑","UpArrowDownArrow":"⇅","updownarrow":"↕","UpDownArrow":"↕","Updownarrow":"⇕","UpEquilibrium":"⥮","upharpoonleft":"↿","upharpoonright":"↾","uplus":"⊎","UpperLeftArrow":"↖","UpperRightArrow":"↗","upsi":"υ","Upsi":"ϒ","upsih":"ϒ","Upsilon":"Υ","upsilon":"υ","UpTeeArrow":"↥","UpTee":"⊥","upuparrows":"⇈","urcorn":"⌝","urcorner":"⌝","urcrop":"⌎","Uring":"Ů","uring":"ů","urtri":"◹","Uscr":"𝒰","uscr":"𝓊","utdot":"⋰","Utilde":"Ũ","utilde":"ũ","utri":"▵","utrif":"▴","uuarr":"⇈","Uuml":"Ü","uuml":"ü","uwangle":"⦧","vangrt":"⦜","varepsilon":"ϵ","varkappa":"ϰ","varnothing":"∅","varphi":"ϕ","varpi":"ϖ","varpropto":"∝","varr":"↕","vArr":"⇕","varrho":"ϱ","varsigma":"ς","varsubsetneq":"⊊︀","varsubsetneqq":"⫋︀","varsupsetneq":"⊋︀","varsupsetneqq":"⫌︀","vartheta":"ϑ","vartriangleleft":"⊲","vartriangleright":"⊳","vBar":"⫨","Vbar":"⫫","vBarv":"⫩","Vcy":"В","vcy":"в","vdash":"⊢","vDash":"⊨","Vdash":"⊩","VDash":"⊫","Vdashl":"⫦","veebar":"⊻","vee":"∨","Vee":"⋁","veeeq":"≚","vellip":"⋮","verbar":"|","Verbar":"‖","vert":"|","Vert":"‖","VerticalBar":"∣","VerticalLine":"|","VerticalSeparator":"❘","VerticalTilde":"≀","VeryThinSpace":" ","Vfr":"𝔙","vfr":"𝔳","vltri":"⊲","vnsub":"⊂⃒","vnsup":"⊃⃒","Vopf":"𝕍","vopf":"𝕧","vprop":"∝","vrtri":"⊳","Vscr":"𝒱","vscr":"𝓋","vsubnE":"⫋︀","vsubne":"⊊︀","vsupnE":"⫌︀","vsupne":"⊋︀","Vvdash":"⊪","vzigzag":"⦚","Wcirc":"Ŵ","wcirc":"ŵ","wedbar":"⩟","wedge":"∧","Wedge":"⋀","wedgeq":"≙","weierp":"℘","Wfr":"𝔚","wfr":"𝔴","Wopf":"𝕎","wopf":"𝕨","wp":"℘","wr":"≀","wreath":"≀","Wscr":"𝒲","wscr":"𝓌","xcap":"⋂","xcirc":"◯","xcup":"⋃","xdtri":"▽","Xfr":"𝔛","xfr":"𝔵","xharr":"⟷","xhArr":"⟺","Xi":"Ξ","xi":"ξ","xlarr":"⟵","xlArr":"⟸","xmap":"⟼","xnis":"⋻","xodot":"⨀","Xopf":"𝕏","xopf":"𝕩","xoplus":"⨁","xotime":"⨂","xrarr":"⟶","xrArr":"⟹","Xscr":"𝒳","xscr":"𝓍","xsqcup":"⨆","xuplus":"⨄","xutri":"△","xvee":"⋁","xwedge":"⋀","Yacute":"Ý","yacute":"ý","YAcy":"Я","yacy":"я","Ycirc":"Ŷ","ycirc":"ŷ","Ycy":"Ы","ycy":"ы","yen":"¥","Yfr":"𝔜","yfr":"𝔶","YIcy":"Ї","yicy":"ї","Yopf":"𝕐","yopf":"𝕪","Yscr":"𝒴","yscr":"𝓎","YUcy":"Ю","yucy":"ю","yuml":"ÿ","Yuml":"Ÿ","Zacute":"Ź","zacute":"ź","Zcaron":"Ž","zcaron":"ž","Zcy":"З","zcy":"з","Zdot":"Ż","zdot":"ż","zeetrf":"ℨ","ZeroWidthSpace":"​","Zeta":"Ζ","zeta":"ζ","zfr":"𝔷","Zfr":"ℨ","ZHcy":"Ж","zhcy":"ж","zigrarr":"⇝","zopf":"𝕫","Zopf":"ℤ","Zscr":"𝒵","zscr":"𝓏","zwj":"‍","zwnj":"‌"}');
    },
    /* 262 */
    /***/
    function(Z) {
      Z.exports = JSON.parse('{"Aacute":"Á","aacute":"á","Acirc":"Â","acirc":"â","acute":"´","AElig":"Æ","aelig":"æ","Agrave":"À","agrave":"à","amp":"&","AMP":"&","Aring":"Å","aring":"å","Atilde":"Ã","atilde":"ã","Auml":"Ä","auml":"ä","brvbar":"¦","Ccedil":"Ç","ccedil":"ç","cedil":"¸","cent":"¢","copy":"©","COPY":"©","curren":"¤","deg":"°","divide":"÷","Eacute":"É","eacute":"é","Ecirc":"Ê","ecirc":"ê","Egrave":"È","egrave":"è","ETH":"Ð","eth":"ð","Euml":"Ë","euml":"ë","frac12":"½","frac14":"¼","frac34":"¾","gt":">","GT":">","Iacute":"Í","iacute":"í","Icirc":"Î","icirc":"î","iexcl":"¡","Igrave":"Ì","igrave":"ì","iquest":"¿","Iuml":"Ï","iuml":"ï","laquo":"«","lt":"<","LT":"<","macr":"¯","micro":"µ","middot":"·","nbsp":" ","not":"¬","Ntilde":"Ñ","ntilde":"ñ","Oacute":"Ó","oacute":"ó","Ocirc":"Ô","ocirc":"ô","Ograve":"Ò","ograve":"ò","ordf":"ª","ordm":"º","Oslash":"Ø","oslash":"ø","Otilde":"Õ","otilde":"õ","Ouml":"Ö","ouml":"ö","para":"¶","plusmn":"±","pound":"£","quot":"\\"","QUOT":"\\"","raquo":"»","reg":"®","REG":"®","sect":"§","shy":"­","sup1":"¹","sup2":"²","sup3":"³","szlig":"ß","THORN":"Þ","thorn":"þ","times":"×","Uacute":"Ú","uacute":"ú","Ucirc":"Û","ucirc":"û","Ugrave":"Ù","ugrave":"ù","uml":"¨","Uuml":"Ü","uuml":"ü","Yacute":"Ý","yacute":"ý","yen":"¥","yuml":"ÿ"}');
    },
    /* 263 */
    /***/
    function(Z) {
      Z.exports = JSON.parse(`{"amp":"&","apos":"'","gt":">","lt":"<","quot":"\\""}`);
    },
    /* 264 */
    /***/
    function(Z, l, i) {
      var s = this && this.__importDefault || function(h) {
        return h && h.__esModule ? h : { default: h };
      };
      Object.defineProperty(l, "__esModule", { value: !0 });
      var c = s(i(265));
      function W(h) {
        if (h >= 55296 && h <= 57343 || h > 1114111)
          return "�";
        h in c.default && (h = c.default[h]);
        var e = "";
        return h > 65535 && (h -= 65536, e += String.fromCharCode(h >>> 10 & 1023 | 55296), h = 56320 | h & 1023), e += String.fromCharCode(h), e;
      }
      l.default = W;
    },
    /* 265 */
    /***/
    function(Z) {
      Z.exports = JSON.parse('{"0":65533,"128":8364,"130":8218,"131":402,"132":8222,"133":8230,"134":8224,"135":8225,"136":710,"137":8240,"138":352,"139":8249,"140":338,"142":381,"145":8216,"146":8217,"147":8220,"148":8221,"149":8226,"150":8211,"151":8212,"152":732,"153":8482,"154":353,"155":8250,"156":339,"158":382,"159":376}');
    },
    /* 266 */
    /***/
    function(Z, l, i) {
      var s = this && this.__importDefault || function(u) {
        return u && u.__esModule ? u : { default: u };
      };
      Object.defineProperty(l, "__esModule", { value: !0 }), l.escape = l.encodeHTML = l.encodeXML = void 0;
      var c = s(i(263)), W = y(c.default), h = n(W);
      l.encodeXML = r(W, h);
      var e = s(i(261)), a = y(e.default), G = n(a);
      l.encodeHTML = r(a, G);
      function y(u) {
        return Object.keys(u).sort().reduce(function(d, b) {
          return d[u[b]] = "&" + b + ";", d;
        }, {});
      }
      function n(u) {
        for (var d = [], b = [], t = 0, m = Object.keys(u); t < m.length; t++) {
          var R = m[t];
          R.length === 1 ? d.push("\\" + R) : b.push(R);
        }
        d.sort();
        for (var S = 0; S < d.length - 1; S++) {
          for (var C = S; C < d.length - 1 && d[C].charCodeAt(1) + 1 === d[C + 1].charCodeAt(1); )
            C += 1;
          var F = 1 + C - S;
          F < 3 || d.splice(S, F, d[S] + "-" + d[C]);
        }
        return b.unshift("[" + d.join("") + "]"), new RegExp(b.join("|"), "g");
      }
      var V = /(?:[\x80-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/g;
      function I(u) {
        return "&#x" + u.codePointAt(0).toString(16).toUpperCase() + ";";
      }
      function r(u, d) {
        return function(b) {
          return b.replace(d, function(t) {
            return u[t];
          }).replace(V, I);
        };
      }
      var p = n(W);
      function o(u) {
        return u.replace(p, I).replace(V, I);
      }
      l.escape = o;
    },
    /* 267 */
    /***/
    function(Z) {
      Z.exports = JSON.parse('{"elementNames":{"altglyph":"altGlyph","altglyphdef":"altGlyphDef","altglyphitem":"altGlyphItem","animatecolor":"animateColor","animatemotion":"animateMotion","animatetransform":"animateTransform","clippath":"clipPath","feblend":"feBlend","fecolormatrix":"feColorMatrix","fecomponenttransfer":"feComponentTransfer","fecomposite":"feComposite","feconvolvematrix":"feConvolveMatrix","fediffuselighting":"feDiffuseLighting","fedisplacementmap":"feDisplacementMap","fedistantlight":"feDistantLight","fedropshadow":"feDropShadow","feflood":"feFlood","fefunca":"feFuncA","fefuncb":"feFuncB","fefuncg":"feFuncG","fefuncr":"feFuncR","fegaussianblur":"feGaussianBlur","feimage":"feImage","femerge":"feMerge","femergenode":"feMergeNode","femorphology":"feMorphology","feoffset":"feOffset","fepointlight":"fePointLight","fespecularlighting":"feSpecularLighting","fespotlight":"feSpotLight","fetile":"feTile","feturbulence":"feTurbulence","foreignobject":"foreignObject","glyphref":"glyphRef","lineargradient":"linearGradient","radialgradient":"radialGradient","textpath":"textPath"},"attributeNames":{"definitionurl":"definitionURL","attributename":"attributeName","attributetype":"attributeType","basefrequency":"baseFrequency","baseprofile":"baseProfile","calcmode":"calcMode","clippathunits":"clipPathUnits","diffuseconstant":"diffuseConstant","edgemode":"edgeMode","filterunits":"filterUnits","glyphref":"glyphRef","gradienttransform":"gradientTransform","gradientunits":"gradientUnits","kernelmatrix":"kernelMatrix","kernelunitlength":"kernelUnitLength","keypoints":"keyPoints","keysplines":"keySplines","keytimes":"keyTimes","lengthadjust":"lengthAdjust","limitingconeangle":"limitingConeAngle","markerheight":"markerHeight","markerunits":"markerUnits","markerwidth":"markerWidth","maskcontentunits":"maskContentUnits","maskunits":"maskUnits","numoctaves":"numOctaves","pathlength":"pathLength","patterncontentunits":"patternContentUnits","patterntransform":"patternTransform","patternunits":"patternUnits","pointsatx":"pointsAtX","pointsaty":"pointsAtY","pointsatz":"pointsAtZ","preservealpha":"preserveAlpha","preserveaspectratio":"preserveAspectRatio","primitiveunits":"primitiveUnits","refx":"refX","refy":"refY","repeatcount":"repeatCount","repeatdur":"repeatDur","requiredextensions":"requiredExtensions","requiredfeatures":"requiredFeatures","specularconstant":"specularConstant","specularexponent":"specularExponent","spreadmethod":"spreadMethod","startoffset":"startOffset","stddeviation":"stdDeviation","stitchtiles":"stitchTiles","surfacescale":"surfaceScale","systemlanguage":"systemLanguage","tablevalues":"tableValues","targetx":"targetX","targety":"targetY","textlength":"textLength","viewbox":"viewBox","viewtarget":"viewTarget","xchannelselector":"xChannelSelector","ychannelselector":"yChannelSelector","zoomandpan":"zoomAndPan"}}');
    },
    /* 268 */
    /***/
    function(Z, l) {
      var i = l.getChildren = function(c) {
        return c.children;
      }, s = l.getParent = function(c) {
        return c.parent;
      };
      l.getSiblings = function(c) {
        var W = s(c);
        return W ? i(W) : [c];
      }, l.getAttributeValue = function(c, W) {
        return c.attribs && c.attribs[W];
      }, l.hasAttrib = function(c, W) {
        return !!c.attribs && hasOwnProperty.call(c.attribs, W);
      }, l.getName = function(c) {
        return c.name;
      };
    },
    /* 269 */
    /***/
    function(Z, l) {
      l.removeElement = function(i) {
        if (i.prev && (i.prev.next = i.next), i.next && (i.next.prev = i.prev), i.parent) {
          var s = i.parent.children;
          s.splice(s.lastIndexOf(i), 1);
        }
      }, l.replaceElement = function(i, s) {
        var c = s.prev = i.prev;
        c && (c.next = s);
        var W = s.next = i.next;
        W && (W.prev = s);
        var h = s.parent = i.parent;
        if (h) {
          var e = h.children;
          e[e.lastIndexOf(i)] = s;
        }
      }, l.appendChild = function(i, s) {
        if (s.parent = i, i.children.push(s) !== 1) {
          var c = i.children[i.children.length - 2];
          c.next = s, s.prev = c, s.next = null;
        }
      }, l.append = function(i, s) {
        var c = i.parent, W = i.next;
        if (s.next = W, s.prev = i, i.next = s, s.parent = c, W) {
          if (W.prev = s, c) {
            var h = c.children;
            h.splice(h.lastIndexOf(W), 0, s);
          }
        } else
          c && c.children.push(s);
      }, l.prepend = function(i, s) {
        var c = i.parent;
        if (c) {
          var W = c.children;
          W.splice(W.lastIndexOf(i), 0, s);
        }
        i.prev && (i.prev.next = s), s.parent = c, s.prev = i.prev, s.next = i, i.prev = s;
      };
    },
    /* 270 */
    /***/
    function(Z, l, i) {
      var s = i(256).isTag;
      Z.exports = {
        filter: c,
        find: W,
        findOneChild: h,
        findOne: e,
        existsOne: a,
        findAll: G
      };
      function c(y, n, V, I) {
        return Array.isArray(n) || (n = [n]), (typeof I != "number" || !isFinite(I)) && (I = 1 / 0), W(y, n, V !== !1, I);
      }
      function W(y, n, V, I) {
        for (var r = [], p, o = 0, u = n.length; o < u && !(y(n[o]) && (r.push(n[o]), --I <= 0) || (p = n[o].children, V && p && p.length > 0 && (p = W(y, p, V, I), r = r.concat(p), I -= p.length, I <= 0))); o++)
          ;
        return r;
      }
      function h(y, n) {
        for (var V = 0, I = n.length; V < I; V++)
          if (y(n[V]))
            return n[V];
        return null;
      }
      function e(y, n) {
        for (var V = null, I = 0, r = n.length; I < r && !V; I++)
          if (s(n[I]))
            y(n[I]) ? V = n[I] : n[I].children.length > 0 && (V = e(y, n[I].children));
          else
            continue;
        return V;
      }
      function a(y, n) {
        for (var V = 0, I = n.length; V < I; V++)
          if (s(n[V]) && (y(n[V]) || n[V].children.length > 0 && a(y, n[V].children)))
            return !0;
        return !1;
      }
      function G(y, n) {
        for (var V = [], I = n.slice(); I.length; ) {
          var r = I.shift();
          s(r) && (r.children && r.children.length > 0 && I.unshift.apply(I, r.children), y(r) && V.push(r));
        }
        return V;
      }
    },
    /* 271 */
    /***/
    function(Z, l, i) {
      var s = i(256), c = l.isTag = s.isTag;
      l.testElement = function(a, G) {
        for (var y in a)
          if (a.hasOwnProperty(y)) {
            if (y === "tag_name") {
              if (!c(G) || !a.tag_name(G.name))
                return !1;
            } else if (y === "tag_type") {
              if (!a.tag_type(G.type))
                return !1;
            } else if (y === "tag_contains") {
              if (c(G) || !a.tag_contains(G.data))
                return !1;
            } else if (!G.attribs || !a[y](G.attribs[y]))
              return !1;
          }
        return !0;
      };
      var W = {
        tag_name: function(a) {
          return typeof a == "function" ? function(G) {
            return c(G) && a(G.name);
          } : a === "*" ? c : function(G) {
            return c(G) && G.name === a;
          };
        },
        tag_type: function(a) {
          return typeof a == "function" ? function(G) {
            return a(G.type);
          } : function(G) {
            return G.type === a;
          };
        },
        tag_contains: function(a) {
          return typeof a == "function" ? function(G) {
            return !c(G) && a(G.data);
          } : function(G) {
            return !c(G) && G.data === a;
          };
        }
      };
      function h(a, G) {
        return typeof G == "function" ? function(y) {
          return y.attribs && G(y.attribs[a]);
        } : function(y) {
          return y.attribs && y.attribs[a] === G;
        };
      }
      function e(a, G) {
        return function(y) {
          return a(y) || G(y);
        };
      }
      l.getElements = function(a, G, y, n) {
        var V = Object.keys(a).map(function(I) {
          var r = a[I];
          return I in W ? W[I](r) : h(I, r);
        });
        return V.length === 0 ? [] : this.filter(
          V.reduce(e),
          G,
          y,
          n
        );
      }, l.getElementById = function(a, G, y) {
        return Array.isArray(G) || (G = [G]), this.findOne(h("id", a), G, y !== !1);
      }, l.getElementsByTagName = function(a, G, y, n) {
        return this.filter(W.tag_name(a), G, y, n);
      }, l.getElementsByTagType = function(a, G, y, n) {
        return this.filter(W.tag_type(a), G, y, n);
      };
    },
    /* 272 */
    /***/
    function(Z, l) {
      l.removeSubsets = function(c) {
        for (var W = c.length, h, e, a; --W > -1; ) {
          for (h = e = c[W], c[W] = null, a = !0; e; ) {
            if (c.indexOf(e) > -1) {
              a = !1, c.splice(W, 1);
              break;
            }
            e = e.parent;
          }
          a && (c[W] = h);
        }
        return c;
      };
      var i = {
        DISCONNECTED: 1,
        PRECEDING: 2,
        FOLLOWING: 4,
        CONTAINS: 8,
        CONTAINED_BY: 16
      }, s = l.compareDocumentPosition = function(c, W) {
        var h = [], e = [], a, G, y, n, V, I;
        if (c === W)
          return 0;
        for (a = c; a; )
          h.unshift(a), a = a.parent;
        for (a = W; a; )
          e.unshift(a), a = a.parent;
        for (I = 0; h[I] === e[I]; )
          I++;
        return I === 0 ? i.DISCONNECTED : (G = h[I - 1], y = G.children, n = h[I], V = e[I], y.indexOf(n) > y.indexOf(V) ? G === W ? i.FOLLOWING | i.CONTAINED_BY : i.FOLLOWING : G === c ? i.PRECEDING | i.CONTAINS : i.PRECEDING);
      };
      l.uniqueSort = function(c) {
        var W = c.length, h, e;
        for (c = c.slice(); --W > -1; )
          h = c[W], e = c.indexOf(h), e > -1 && e < W && c.splice(W, 1);
        return c.sort(function(a, G) {
          var y = s(a, G);
          return y & i.PRECEDING ? -1 : y & i.FOLLOWING ? 1 : 0;
        }), c;
      };
    },
    /* 273 */
    /***/
    function(Z, l) {
      Z.exports = {
        trueFunc: function() {
          return !0;
        },
        falseFunc: function() {
          return !1;
        }
      };
    },
    /* 274 */
    /***/
    function(Z, l, i) {
      Z.exports = V;
      var s = i(275).parse, c = i(273), W = i(278), h = i(279), e = i(280), a = i(282), G = c.trueFunc, y = c.falseFunc, n = a.filters;
      function V(K, J, T) {
        var Y = r(K, J, T);
        return I(Y, J);
      }
      function I(K, J) {
        var T = J.adapter;
        return function(x) {
          return T.isTag(x) && K(x);
        };
      }
      function r(K, J, T) {
        var Y = s(K, J);
        return m(Y, J, T);
      }
      function p(K) {
        return K.type === "pseudo" && (K.name === "scope" || Array.isArray(K.data) && K.data.some(function(J) {
          return J.some(p);
        }));
      }
      var o = { type: "descendant" }, u = { type: "_flexibleDescendant" }, d = { type: "pseudo", name: "scope" }, b = {};
      function t(K, J, T) {
        var Y = J.adapter, x = !!T && !!T.length && T.every(function(H) {
          return H === b || !!Y.getParent(H);
        });
        K.forEach(function(H) {
          if (!(H.length > 0 && R(H[0]) && H[0].type !== "descendant"))
            if (x && !(Array.isArray(H) ? H.some(p) : p(H)))
              H.unshift(o);
            else
              return;
          H.unshift(d);
        });
      }
      function m(K, J, T) {
        K = K.filter(function(Q) {
          return Q.length > 0;
        }), K.forEach(W);
        var Y = Array.isArray(T);
        T = J && J.context || T, T && !Y && (T = [T]), t(K, J, T);
        var x = !1, H = K.map(function(Q) {
          if (Q[0] && Q[1] && Q[0].name === "scope") {
            var w = Q[1].type;
            Y && w === "descendant" ? Q[1] = u : (w === "adjacent" || w === "sibling") && (x = !0);
          }
          return S(Q, J, T);
        }).reduce(C, y);
        return H.shouldTestNextSiblings = x, H;
      }
      function R(K) {
        return h[K.type] < 0;
      }
      function S(K, J, T) {
        return K.reduce(function(Y, x) {
          if (Y === y)
            return Y;
          if (!(x.type in e))
            throw new Error("Rule type " + x.type + " is not supported by css-select");
          return e[x.type](Y, x, J, T);
        }, J && J.rootFunc || G);
      }
      function C(K, J) {
        return J === y || K === G ? K : K === y || J === G ? J : function(Y) {
          return K(Y) || J(Y);
        };
      }
      function F(K) {
        return K.some(R);
      }
      n.not = function(K, J, T, Y) {
        var x = {
          xmlMode: !!(T && T.xmlMode),
          strict: !!(T && T.strict),
          adapter: T.adapter
        };
        if (x.strict && (J.length > 1 || J.some(F)))
          throw new Error("complex selectors in :not aren't allowed in strict mode");
        var H = m(J, x, Y);
        return H === y ? K : H === G ? y : function(w) {
          return !H(w) && K(w);
        };
      }, n.has = function(K, J, T) {
        var Y = T.adapter, x = {
          xmlMode: !!(T && T.xmlMode),
          strict: !!(T && T.strict),
          adapter: Y
        }, H = J.some(F) ? [b] : null, Q = m(J, x, H);
        return Q === y ? y : Q === G ? function(O) {
          return Y.getChildren(O).some(Y.isTag) && K(O);
        } : (Q = I(Q, T), H ? function(O) {
          return K(O) && (H[0] = O, Y.existsOne(Q, Y.getChildren(O)));
        } : function(O) {
          return K(O) && Y.existsOne(Q, Y.getChildren(O));
        });
      }, n.matches = function(K, J, T, Y) {
        var x = {
          xmlMode: !!(T && T.xmlMode),
          strict: !!(T && T.strict),
          rootFunc: K,
          adapter: T.adapter
        };
        return m(J, x, Y);
      }, V.compileToken = m, V.compileUnsafe = r, V.Pseudos = a;
    },
    /* 275 */
    /***/
    function(Z, l, i) {
      var s = this && this.__createBinding || (Object.create ? function(e, a, G, y) {
        y === void 0 && (y = G), Object.defineProperty(e, y, { enumerable: !0, get: function() {
          return a[G];
        } });
      } : function(e, a, G, y) {
        y === void 0 && (y = G), e[y] = a[G];
      }), c = this && this.__exportStar || function(e, a) {
        for (var G in e)
          G !== "default" && !a.hasOwnProperty(G) && s(a, e, G);
      };
      Object.defineProperty(l, "__esModule", { value: !0 }), c(i(276), l);
      var W = i(276);
      Object.defineProperty(l, "parse", { enumerable: !0, get: function() {
        return W.default;
      } });
      var h = i(277);
      Object.defineProperty(l, "stringify", { enumerable: !0, get: function() {
        return h.default;
      } });
    },
    /* 276 */
    /***/
    function(Z, l, i) {
      Object.defineProperty(l, "__esModule", { value: !0 }), l.default = p;
      var s = /^[^\\]?(?:\\(?:[\da-f]{1,6}\s?|.)|[\w\-\u00b0-\uFFFF])+/, c = /\\([\da-f]{1,6}\s?|(\s)|.)/gi, W = /^\s*((?:\\.|[\w\u00b0-\uFFFF-])+)\s*(?:(\S?)=\s*(?:(['"])([^]*?)\3|(#?(?:\\.|[\w\u00b0-\uFFFF-])*)|)|)\s*(i)?\]/, h = {
        undefined: "exists",
        "": "equals",
        "~": "element",
        "^": "start",
        $: "end",
        "*": "any",
        "!": "not",
        "|": "hyphen"
      }, e = {
        ">": "child",
        "<": "parent",
        "~": "sibling",
        "+": "adjacent"
      }, a = {
        "#": ["id", "equals"],
        ".": ["class", "element"]
      }, G = /* @__PURE__ */ new Set(["has", "not", "matches"]), y = /* @__PURE__ */ new Set(["contains", "icontains"]), n = /* @__PURE__ */ new Set(['"', "'"]);
      function V(d, b, t) {
        var m = parseInt(b, 16) - 65536;
        return m !== m || t ? b : m < 0 ? (
          // BMP codepoint
          String.fromCharCode(m + 65536)
        ) : (
          // Supplemental Plane codepoint (surrogate pair)
          String.fromCharCode(m >> 10 | 55296, m & 1023 | 56320)
        );
      }
      function I(d) {
        return d.replace(c, V);
      }
      function r(d) {
        return d === " " || d === `
` || d === "	" || d === "\f" || d === "\r";
      }
      function p(d, b) {
        var t = [];
        if (d = o(t, "" + d, b), d !== "")
          throw new Error("Unmatched selector: " + d);
        return t;
      }
      function o(d, b, t) {
        var m = [], R = !1;
        function S() {
          var D = b.match(s);
          if (!D)
            throw new Error("Expected name, found " + b);
          var ii = D[0];
          return b = b.substr(ii.length), I(ii);
        }
        function C(D) {
          for (; r(b.charAt(D)); )
            D++;
          b = b.substr(D);
        }
        function F(D) {
          for (var ii = 0; b.charAt(--D) === "\\"; )
            ii++;
          return (ii & 1) === 1;
        }
        for (C(0); b !== ""; ) {
          var K = b.charAt(0);
          if (r(K))
            R = !0, C(1);
          else if (K in e)
            m.push({ type: e[K] }), R = !1, C(1);
          else if (K === ",") {
            if (m.length === 0)
              throw new Error("Empty sub-selector");
            d.push(m), m = [], R = !1, C(1);
          } else if (R && (m.length > 0 && m.push({ type: "descendant" }), R = !1), K === "*")
            b = b.substr(1), m.push({ type: "universal" });
          else if (K in a) {
            var J = a[K], T = J[0], Y = J[1];
            b = b.substr(1), m.push({
              type: "attribute",
              name: T,
              action: Y,
              value: S(),
              ignoreCase: !1
            });
          } else if (K === "[") {
            b = b.substr(1);
            var x = b.match(W);
            if (!x)
              throw new Error("Malformed attribute selector: " + b);
            b = b.substr(x[0].length);
            var H = I(x[1]);
            (!t || ("lowerCaseAttributeNames" in t ? t.lowerCaseAttributeNames : !t.xmlMode)) && (H = H.toLowerCase()), m.push({
              type: "attribute",
              name: H,
              action: h[x[2]],
              value: I(x[4] || x[5] || ""),
              ignoreCase: !!x[6]
            });
          } else if (K === ":") {
            if (b.charAt(1) === ":") {
              b = b.substr(2), m.push({
                type: "pseudo-element",
                name: S().toLowerCase()
              });
              continue;
            }
            b = b.substr(1);
            var Q = S().toLowerCase(), x = null;
            if (b.charAt(0) === "(")
              if (G.has(Q)) {
                var w = b.charAt(1), O = n.has(w);
                if (b = b.substr(O ? 2 : 1), x = [], b = o(x, b, t), O) {
                  if (b.charAt(0) !== w)
                    throw new Error("Unmatched quotes in :" + Q);
                  b = b.substr(1);
                }
                if (b.charAt(0) !== ")")
                  throw new Error("Missing closing parenthesis in :" + Q + " (" + b + ")");
                b = b.substr(1);
              } else {
                for (var q = 1, k = 1; k > 0 && q < b.length; q++)
                  b.charAt(q) === "(" && !F(q) ? k++ : b.charAt(q) === ")" && !F(q) && k--;
                if (k)
                  throw new Error("Parenthesis not matched");
                if (x = b.substr(1, q - 2), b = b.substr(q), y.has(Q)) {
                  var w = x.charAt(0);
                  w === x.slice(-1) && n.has(w) && (x = x.slice(1, -1)), x = I(x);
                }
              }
            m.push({ type: "pseudo", name: Q, data: x });
          } else if (s.test(b)) {
            var f = S();
            (!t || ("lowerCaseTags" in t ? t.lowerCaseTags : !t.xmlMode)) && (f = f.toLowerCase()), m.push({ type: "tag", name: f });
          } else
            return m.length && m[m.length - 1].type === "descendant" && m.pop(), u(d, m), b;
        }
        return u(d, m), b;
      }
      function u(d, b) {
        if (d.length > 0 && b.length === 0)
          throw new Error("Empty sub-selector");
        d.push(b);
      }
    },
    /* 277 */
    /***/
    function(Z, l, i) {
      Object.defineProperty(l, "__esModule", { value: !0 });
      var s = {
        equals: "",
        element: "~",
        start: "^",
        end: "$",
        any: "*",
        not: "!",
        hyphen: "|"
      };
      function c(a) {
        return a.map(W).join(", ");
      }
      l.default = c;
      function W(a) {
        return a.map(h).join("");
      }
      function h(a) {
        switch (a.type) {
          case "child":
            return " > ";
          case "parent":
            return " < ";
          case "sibling":
            return " ~ ";
          case "adjacent":
            return " + ";
          case "descendant":
            return " ";
          case "universal":
            return "*";
          case "tag":
            return a.name;
          case "pseudo-element":
            return "::" + a.name;
          case "pseudo":
            return a.data === null ? ":" + a.name : typeof a.data == "string" ? ":" + a.name + "(" + a.data + ")" : ":" + a.name + "(" + c(a.data) + ")";
          case "attribute":
            return a.action === "exists" ? "[" + a.name + "]" : a.name === "id" && a.action === "equals" && !a.ignoreCase ? "#" + a.value : a.name === "class" && a.action === "element" && !a.ignoreCase ? "." + a.value : "[" + a.name + s[a.action] + "='" + a.value + "'" + (a.ignoreCase ? "i" : "") + "]";
          default:
            throw new Error("Unknown type");
        }
      }
      function e(a) {
        return a;
      }
    },
    /* 278 */
    /***/
    function(Z, l, i) {
      Z.exports = W;
      var s = i(279), c = {
        __proto__: null,
        exists: 10,
        equals: 8,
        not: 7,
        start: 6,
        end: 6,
        any: 5,
        hyphen: 4,
        element: 4
      };
      function W(e) {
        for (var a = e.map(h), G = 1; G < e.length; G++) {
          var y = a[G];
          if (!(y < 0))
            for (var n = G - 1; n >= 0 && y < a[n]; n--) {
              var V = e[n + 1];
              e[n + 1] = e[n], e[n] = V, a[n + 1] = a[n], a[n] = y;
            }
        }
      }
      function h(e) {
        var a = s[e.type];
        if (a === s.attribute)
          a = c[e.action], a === c.equals && e.name === "id" && (a = 9), e.ignoreCase && (a >>= 1);
        else if (a === s.pseudo)
          if (!e.data)
            a = 3;
          else if (e.name === "has" || e.name === "contains")
            a = 0;
          else if (e.name === "matches" || e.name === "not") {
            a = 0;
            for (var G = 0; G < e.data.length; G++)
              if (e.data[G].length === 1) {
                var y = h(e.data[G][0]);
                if (y === 0) {
                  a = 0;
                  break;
                }
                y > a && (a = y);
              }
            e.data.length > 1 && a > 0 && (a -= 1);
          } else
            a = 1;
        return a;
      }
    },
    /* 279 */
    /***/
    function(Z) {
      Z.exports = JSON.parse('{"universal":50,"tag":30,"attribute":1,"pseudo":0,"descendant":-1,"child":-1,"parent":-1,"sibling":-1,"adjacent":-1}');
    },
    /* 280 */
    /***/
    function(Z, l, i) {
      var s = i(281), c = i(282);
      Z.exports = {
        __proto__: null,
        attribute: s.compile,
        pseudo: c.compile,
        //tags
        tag: function(W, h, e) {
          var a = h.name, G = e.adapter;
          return function(n) {
            return G.getName(n) === a && W(n);
          };
        },
        //traversal
        descendant: function(W, h, e) {
          var a = typeof WeakSet < "u" ? /* @__PURE__ */ new WeakSet() : null, G = e.adapter;
          return function(n) {
            for (var V = !1; !V && (n = G.getParent(n)); )
              (!a || !a.has(n)) && (V = W(n), !V && a && a.add(n));
            return V;
          };
        },
        _flexibleDescendant: function(W, h, e) {
          var a = e.adapter;
          return function(y) {
            for (var n = W(y); !n && (y = a.getParent(y)); )
              n = W(y);
            return n;
          };
        },
        parent: function(W, h, e) {
          if (e && e.strict)
            throw new Error("Parent selector isn't part of CSS3");
          var a = e.adapter;
          return function(n) {
            return a.getChildren(n).some(G);
          };
          function G(y) {
            return a.isTag(y) && W(y);
          }
        },
        child: function(W, h, e) {
          var a = e.adapter;
          return function(y) {
            var n = a.getParent(y);
            return !!n && W(n);
          };
        },
        sibling: function(W, h, e) {
          var a = e.adapter;
          return function(y) {
            for (var n = a.getSiblings(y), V = 0; V < n.length; V++)
              if (a.isTag(n[V])) {
                if (n[V] === y)
                  break;
                if (W(n[V]))
                  return !0;
              }
            return !1;
          };
        },
        adjacent: function(W, h, e) {
          var a = e.adapter;
          return function(y) {
            for (var n = a.getSiblings(y), V, I = 0; I < n.length; I++)
              if (a.isTag(n[I])) {
                if (n[I] === y)
                  break;
                V = n[I];
              }
            return !!V && W(V);
          };
        },
        universal: function(W) {
          return W;
        }
      };
    },
    /* 281 */
    /***/
    function(Z, l, i) {
      var s = i(273).falseFunc, c = /[-[\]{}()*+?.,\\^$|#\s]/g, W = {
        __proto__: null,
        equals: function(h, e, a) {
          var G = e.name, y = e.value, n = a.adapter;
          return e.ignoreCase ? (y = y.toLowerCase(), function(I) {
            var r = n.getAttributeValue(I, G);
            return r != null && r.toLowerCase() === y && h(I);
          }) : function(I) {
            return n.getAttributeValue(I, G) === y && h(I);
          };
        },
        hyphen: function(h, e, a) {
          var G = e.name, y = e.value, n = y.length, V = a.adapter;
          return e.ignoreCase ? (y = y.toLowerCase(), function(r) {
            var p = V.getAttributeValue(r, G);
            return p != null && (p.length === n || p.charAt(n) === "-") && p.substr(0, n).toLowerCase() === y && h(r);
          }) : function(r) {
            var p = V.getAttributeValue(r, G);
            return p != null && p.substr(0, n) === y && (p.length === n || p.charAt(n) === "-") && h(r);
          };
        },
        element: function(h, e, a) {
          var G = e.name, y = e.value, n = a.adapter;
          if (/\s/.test(y))
            return s;
          y = y.replace(c, "\\$&");
          var V = "(?:^|\\s)" + y + "(?:$|\\s)", I = e.ignoreCase ? "i" : "", r = new RegExp(V, I);
          return function(o) {
            var u = n.getAttributeValue(o, G);
            return u != null && r.test(u) && h(o);
          };
        },
        exists: function(h, e, a) {
          var G = e.name, y = a.adapter;
          return function(V) {
            return y.hasAttrib(V, G) && h(V);
          };
        },
        start: function(h, e, a) {
          var G = e.name, y = e.value, n = y.length, V = a.adapter;
          return n === 0 ? s : e.ignoreCase ? (y = y.toLowerCase(), function(r) {
            var p = V.getAttributeValue(r, G);
            return p != null && p.substr(0, n).toLowerCase() === y && h(r);
          }) : function(r) {
            var p = V.getAttributeValue(r, G);
            return p != null && p.substr(0, n) === y && h(r);
          };
        },
        end: function(h, e, a) {
          var G = e.name, y = e.value, n = -y.length, V = a.adapter;
          return n === 0 ? s : e.ignoreCase ? (y = y.toLowerCase(), function(r) {
            var p = V.getAttributeValue(r, G);
            return p != null && p.substr(n).toLowerCase() === y && h(r);
          }) : function(r) {
            var p = V.getAttributeValue(r, G);
            return p != null && p.substr(n) === y && h(r);
          };
        },
        any: function(h, e, a) {
          var G = e.name, y = e.value, n = a.adapter;
          if (y === "")
            return s;
          if (e.ignoreCase) {
            var V = new RegExp(y.replace(c, "\\$&"), "i");
            return function(r) {
              var p = n.getAttributeValue(r, G);
              return p != null && V.test(p) && h(r);
            };
          }
          return function(r) {
            var p = n.getAttributeValue(r, G);
            return p != null && p.indexOf(y) >= 0 && h(r);
          };
        },
        not: function(h, e, a) {
          var G = e.name, y = e.value, n = a.adapter;
          return y === "" ? function(I) {
            return !!n.getAttributeValue(I, G) && h(I);
          } : e.ignoreCase ? (y = y.toLowerCase(), function(I) {
            var r = n.getAttributeValue(I, G);
            return r != null && r.toLowerCase() !== y && h(I);
          }) : function(I) {
            return n.getAttributeValue(I, G) !== y && h(I);
          };
        }
      };
      Z.exports = {
        compile: function(h, e, a) {
          if (a && a.strict && (e.ignoreCase || e.action === "not"))
            throw new Error("Unsupported attribute selector");
          return W[e.action](h, e, a);
        },
        rules: W
      };
    },
    /* 282 */
    /***/
    function(Z, l, i) {
      var s = i(283), c = i(273), W = i(281), h = c.trueFunc, e = c.falseFunc, a = W.rules.equals;
      function G(u, d) {
        var b = { name: u, value: d };
        return function(m, R, S) {
          return a(m, b, S);
        };
      }
      function y(u, d) {
        return function(b) {
          return !!d.getParent(b) && u(b);
        };
      }
      var n = {
        contains: function(u, d, b) {
          var t = b.adapter;
          return function(R) {
            return u(R) && t.getText(R).indexOf(d) >= 0;
          };
        },
        icontains: function(u, d, b) {
          var t = d.toLowerCase(), m = b.adapter;
          return function(S) {
            return u(S) && m.getText(S).toLowerCase().indexOf(t) >= 0;
          };
        },
        //location specific methods
        "nth-child": function(u, d, b) {
          var t = s(d), m = b.adapter;
          return t === e ? t : t === h ? y(u, m) : function(S) {
            for (var C = m.getSiblings(S), F = 0, K = 0; F < C.length; F++)
              if (m.isTag(C[F])) {
                if (C[F] === S)
                  break;
                K++;
              }
            return t(K) && u(S);
          };
        },
        "nth-last-child": function(u, d, b) {
          var t = s(d), m = b.adapter;
          return t === e ? t : t === h ? y(u, m) : function(S) {
            for (var C = m.getSiblings(S), F = 0, K = C.length - 1; K >= 0; K--)
              if (m.isTag(C[K])) {
                if (C[K] === S)
                  break;
                F++;
              }
            return t(F) && u(S);
          };
        },
        "nth-of-type": function(u, d, b) {
          var t = s(d), m = b.adapter;
          return t === e ? t : t === h ? y(u, m) : function(S) {
            for (var C = m.getSiblings(S), F = 0, K = 0; K < C.length; K++)
              if (m.isTag(C[K])) {
                if (C[K] === S)
                  break;
                m.getName(C[K]) === m.getName(S) && F++;
              }
            return t(F) && u(S);
          };
        },
        "nth-last-of-type": function(u, d, b) {
          var t = s(d), m = b.adapter;
          return t === e ? t : t === h ? y(u, m) : function(S) {
            for (var C = m.getSiblings(S), F = 0, K = C.length - 1; K >= 0; K--)
              if (m.isTag(C[K])) {
                if (C[K] === S)
                  break;
                m.getName(C[K]) === m.getName(S) && F++;
              }
            return t(F) && u(S);
          };
        },
        //TODO determine the actual root element
        root: function(u, d, b) {
          var t = b.adapter;
          return function(m) {
            return !t.getParent(m) && u(m);
          };
        },
        scope: function(u, d, b, t) {
          var m = b.adapter;
          if (!t || t.length === 0)
            return n.root(u, d, b);
          function R(S, C) {
            return typeof m.equals == "function" ? m.equals(S, C) : S === C;
          }
          return t.length === 1 ? function(S) {
            return R(t[0], S) && u(S);
          } : function(S) {
            return t.indexOf(S) >= 0 && u(S);
          };
        },
        //jQuery extensions (others follow as pseudos)
        checkbox: G("type", "checkbox"),
        file: G("type", "file"),
        password: G("type", "password"),
        radio: G("type", "radio"),
        reset: G("type", "reset"),
        image: G("type", "image"),
        submit: G("type", "submit"),
        //dynamic state pseudos. These depend on optional Adapter methods.
        hover: function(u, d, b) {
          var t = b.adapter;
          return typeof t.isHovered == "function" ? function(R) {
            return u(R) && t.isHovered(R);
          } : e;
        },
        visited: function(u, d, b) {
          var t = b.adapter;
          return typeof t.isVisited == "function" ? function(R) {
            return u(R) && t.isVisited(R);
          } : e;
        },
        active: function(u, d, b) {
          var t = b.adapter;
          return typeof t.isActive == "function" ? function(R) {
            return u(R) && t.isActive(R);
          } : e;
        }
      };
      function V(u, d) {
        for (var b = 0; u && b < u.length; b++)
          if (d.isTag(u[b]))
            return u[b];
      }
      var I = {
        empty: function(u, d) {
          return !d.getChildren(u).some(function(b) {
            return d.isTag(b) || b.type === "text";
          });
        },
        "first-child": function(u, d) {
          return V(d.getSiblings(u), d) === u;
        },
        "last-child": function(u, d) {
          for (var b = d.getSiblings(u), t = b.length - 1; t >= 0; t--) {
            if (b[t] === u)
              return !0;
            if (d.isTag(b[t]))
              break;
          }
          return !1;
        },
        "first-of-type": function(u, d) {
          for (var b = d.getSiblings(u), t = 0; t < b.length; t++)
            if (d.isTag(b[t])) {
              if (b[t] === u)
                return !0;
              if (d.getName(b[t]) === d.getName(u))
                break;
            }
          return !1;
        },
        "last-of-type": function(u, d) {
          for (var b = d.getSiblings(u), t = b.length - 1; t >= 0; t--)
            if (d.isTag(b[t])) {
              if (b[t] === u)
                return !0;
              if (d.getName(b[t]) === d.getName(u))
                break;
            }
          return !1;
        },
        "only-of-type": function(u, d) {
          for (var b = d.getSiblings(u), t = 0, m = b.length; t < m; t++)
            if (d.isTag(b[t])) {
              if (b[t] === u)
                continue;
              if (d.getName(b[t]) === d.getName(u))
                return !1;
            }
          return !0;
        },
        "only-child": function(u, d) {
          for (var b = d.getSiblings(u), t = 0; t < b.length; t++)
            if (d.isTag(b[t]) && b[t] !== u)
              return !1;
          return !0;
        },
        //:matches(a, area, link)[href]
        link: function(u, d) {
          return d.hasAttrib(u, "href");
        },
        //TODO: :any-link once the name is finalized (as an alias of :link)
        //forms
        //to consider: :target
        //:matches([selected], select:not([multiple]):not(> option[selected]) > option:first-of-type)
        selected: function(u, d) {
          if (d.hasAttrib(u, "selected"))
            return !0;
          if (d.getName(u) !== "option")
            return !1;
          var b = d.getParent(u);
          if (!b || d.getName(b) !== "select" || d.hasAttrib(b, "multiple"))
            return !1;
          for (var t = d.getChildren(b), m = !1, R = 0; R < t.length; R++)
            if (d.isTag(t[R]))
              if (t[R] === u)
                m = !0;
              else if (m) {
                if (d.hasAttrib(t[R], "selected"))
                  return !1;
              } else
                return !1;
          return m;
        },
        //https://html.spec.whatwg.org/multipage/scripting.html#disabled-elements
        //:matches(
        //  :matches(button, input, select, textarea, menuitem, optgroup, option)[disabled],
        //  optgroup[disabled] > option),
        // fieldset[disabled] * //TODO not child of first <legend>
        //)
        disabled: function(u, d) {
          return d.hasAttrib(u, "disabled");
        },
        enabled: function(u, d) {
          return !d.hasAttrib(u, "disabled");
        },
        //:matches(:matches(:radio, :checkbox)[checked], :selected) (TODO menuitem)
        checked: function(u, d) {
          return d.hasAttrib(u, "checked") || I.selected(u, d);
        },
        //:matches(input, select, textarea)[required]
        required: function(u, d) {
          return d.hasAttrib(u, "required");
        },
        //:matches(input, select, textarea):not([required])
        optional: function(u, d) {
          return !d.hasAttrib(u, "required");
        },
        //jQuery extensions
        //:not(:empty)
        parent: function(u, d) {
          return !I.empty(u, d);
        },
        //:matches(h1, h2, h3, h4, h5, h6)
        header: r(["h1", "h2", "h3", "h4", "h5", "h6"]),
        //:matches(button, input[type=button])
        button: function(u, d) {
          var b = d.getName(u);
          return b === "button" || b === "input" && d.getAttributeValue(u, "type") === "button";
        },
        //:matches(input, textarea, select, button)
        input: r(["input", "textarea", "select", "button"]),
        //input:matches(:not([type!='']), [type='text' i])
        text: function(u, d) {
          var b;
          return d.getName(u) === "input" && (!(b = d.getAttributeValue(u, "type")) || b.toLowerCase() === "text");
        }
      };
      function r(u) {
        if (typeof Set < "u") {
          var d = new Set(u);
          return function(b, t) {
            return d.has(t.getName(b));
          };
        }
        return function(b, t) {
          return u.indexOf(t.getName(b)) >= 0;
        };
      }
      function p(u, d, b) {
        if (b === null) {
          if (u.length > 2 && d !== "scope")
            throw new Error("pseudo-selector :" + d + " requires an argument");
        } else if (u.length === 2)
          throw new Error("pseudo-selector :" + d + " doesn't have any arguments");
      }
      var o = /^(?:(?:nth|last|first|only)-(?:child|of-type)|root|empty|(?:en|dis)abled|checked|not)$/;
      Z.exports = {
        compile: function(u, d, b, t) {
          var m = d.name, R = d.data, S = b.adapter;
          if (b && b.strict && !o.test(m))
            throw new Error(":" + m + " isn't part of CSS3");
          if (typeof n[m] == "function")
            return n[m](u, R, b, t);
          if (typeof I[m] == "function") {
            var C = I[m];
            return p(C, m, R), C === e ? C : u === h ? function(K) {
              return C(K, S, R);
            } : function(K) {
              return C(K, S, R) && u(K);
            };
          } else
            throw new Error("unmatched pseudo-class :" + m);
        },
        filters: n,
        pseudos: I
      };
    },
    /* 283 */
    /***/
    function(Z, l, i) {
      var s = i(284), c = i(285);
      Z.exports = function(h) {
        return c(s(h));
      }, Z.exports.parse = s, Z.exports.compile = c;
    },
    /* 284 */
    /***/
    function(Z, l) {
      Z.exports = s;
      var i = /^([+\-]?\d*n)?\s*(?:([+\-]?)\s*(\d+))?$/;
      function s(c) {
        if (c = c.trim().toLowerCase(), c === "even")
          return [2, 0];
        if (c === "odd")
          return [2, 1];
        var W = c.match(i);
        if (!W)
          throw new SyntaxError("n-th rule couldn't be parsed ('" + c + "')");
        var h;
        return W[1] ? (h = parseInt(W[1], 10), isNaN(h) && (W[1].charAt(0) === "-" ? h = -1 : h = 1)) : h = 0, [
          h,
          W[3] ? parseInt((W[2] || "") + W[3], 10) : 0
        ];
      }
    },
    /* 285 */
    /***/
    function(Z, l, i) {
      Z.exports = h;
      var s = i(273), c = s.trueFunc, W = s.falseFunc;
      function h(e) {
        var a = e[0], G = e[1] - 1;
        if (G < 0 && a <= 0)
          return W;
        if (a === -1)
          return function(n) {
            return n <= G;
          };
        if (a === 0)
          return function(n) {
            return n === G;
          };
        if (a === 1)
          return G < 0 ? c : function(n) {
            return n >= G;
          };
        var y = G % a;
        return y < 0 && (y += a), a > 1 ? function(n) {
          return n >= G && n % a === y;
        } : (a *= -1, function(n) {
          return n <= G && n % a === y;
        });
      }
    },
    /* 286 */
    /***/
    function(Z, l, i) {
      i.r(l), i.d(l, "default", function() {
        return R;
      });
      var s = i(12), c = i(74), W = i(1), h = i(68), e = i(250), a = i(213), G = i(218);
      i(1).glMatrix.setMatrixArrayType(Array);
      function y(S, C) {
        if (S == null)
          return {};
        var F = n(S, C), K, J;
        if (Object.getOwnPropertySymbols) {
          var T = Object.getOwnPropertySymbols(S);
          for (J = 0; J < T.length; J++)
            K = T[J], !(C.indexOf(K) >= 0) && Object.prototype.propertyIsEnumerable.call(S, K) && (F[K] = S[K]);
        }
        return F;
      }
      function n(S, C) {
        if (S == null)
          return {};
        var F = {}, K = Object.keys(S), J, T;
        for (T = 0; T < K.length; T++)
          J = K[T], !(C.indexOf(J) >= 0) && (F[J] = S[J]);
        return F;
      }
      const V = {
        antialias: !0,
        autoRender: !0,
        alpha: !0
        // for wx-miniprogram
      }, I = Symbol("autoRender"), r = Symbol("renderer"), p = Symbol("timeline"), o = Symbol("prepareRender"), u = Symbol("tickRender"), d = Symbol("pass"), b = Symbol("fbo"), t = Symbol("tickers"), m = Symbol("layerTransformInvert");
      class R extends e.default {
        constructor(C = {}) {
          if (super(), !C.canvas) {
            const {
              width: T,
              height: Y
            } = this.getResolution(), x = s.ENV.createCanvas(T, Y, {
              offscreen: !!C.offscreen,
              id: C.id,
              extra: C.extra
            });
            x.style && (x.style.position = "absolute"), x.dataset && (x.dataset.layerId = C.id), x.contextType && (C.contextType = x.contextType), C.canvas = x;
          }
          const F = C.canvas, K = Object.assign({}, V, C);
          this[I] = K.autoRender, delete C.autoRender;
          const J = K.Renderer || s.Renderer;
          this[r] = new J(F, K), this.options = C, this.id = C.id, this[d] = [], this.setResolution(F), this.canvas = F, this[p] = new c.Timeline(), this.__mouseCapturedTarget = null, this[m] = null;
        }
        get autoRender() {
          return this[I];
        }
        get displayRatio() {
          return this.parent && this.parent.options ? this.parent.options.displayRatio : 1;
        }
        get height() {
          const {
            height: C
          } = this.getResolution();
          return C / this.displayRatio;
        }
        get gl() {
          return this.renderer.glRenderer ? this.renderer.glRenderer.gl : null;
        }
        /* override */
        get layer() {
          return this;
        }
        get offscreen() {
          return !!this.options.offscreen || this.canvas._offscreen;
        }
        get pass() {
          return this[d];
        }
        get prepareRender() {
          return this[o] ? this[o] : Promise.resolve();
        }
        /* override */
        get renderer() {
          return this[r];
        }
        get renderOffset() {
          if (this.parent && this.parent.options) {
            const {
              left: C,
              top: F
            } = this.parent.options;
            return [C, F];
          }
          return [this.options.left | 0, this.options.top | 0];
        }
        get timeline() {
          return this[p];
        }
        get width() {
          const {
            width: C
          } = this.getResolution();
          return C / this.displayRatio;
        }
        get localMatrix() {
          const {
            x: C,
            y: F
          } = this.attributes;
          return [1, 0, 0, 1, C, F];
        }
        get layerTransformInvert() {
          if (this[m])
            return this[m];
          const C = this.transformMatrix;
          return C[0] === 1 && C[1] === 0 && C[2] === 0 && C[3] === 1 && C[4] === 0 && C[5] === 0 ? null : (this[m] = W.mat2d.invert(Array.of(0, 0, 0, 0, 0, 0), C), this[m]);
        }
        forceContextLoss() {
          const C = this.renderer.glRenderer;
          if (C) {
            const F = C.getExtension("WEBGL_lose_context");
            if (F)
              return F.loseContext(), !0;
          }
          return !1;
        }
        // isPointCollision(x, y) {
        //   return true;
        // }
        addPass({
          vertex: C,
          fragment: F,
          options: K,
          uniforms: J
        } = {}) {
          if (this.renderer.glRenderer) {
            const {
              width: T,
              height: Y
            } = this.getResolution(), x = this.renderer.createPassProgram({
              vertex: C,
              fragment: F,
              options: K
            }), H = new s.Figure2D();
            H.rect(0, 0, T / this.displayRatio, Y / this.displayRatio);
            const Q = new s.Mesh2D(H);
            return Q.setUniforms(J), Q.setProgram(x), this[d].push(Q), this.forceUpdate(), Q;
          }
          return null;
        }
        // delete unused texture to release memory.
        deleteTexture(C) {
          return Object(G.deleteTexture)(C, this.renderer);
        }
        /* override */
        dispatchPointerEvent(C) {
          const F = C.type;
          if (F === "mousedown" || F === "mouseup" || F === "mousemove") {
            const x = this.__mouseCapturedTarget;
            if (x) {
              if (x.layer === this)
                return x.dispatchEvent(C), !0;
              this.__mouseCapturedTarget = null;
            }
          }
          let K, J;
          const T = this.layerTransformInvert;
          if (T) {
            K = C.x, J = C.y;
            const x = T, H = x[0] * K + x[2] * J + x[4], Q = x[1] * K + x[3] * J + x[5];
            delete C.x, delete C.y, delete C.layerX, delete C.layerY, Object.defineProperties(C, {
              layerX: {
                value: H,
                configurable: !0
              },
              layerY: {
                value: Q,
                configurable: !0
              },
              x: {
                value: H,
                configurable: !0
              },
              y: {
                value: Q,
                configurable: !0
              }
            });
          }
          const Y = super.dispatchPointerEvent(C);
          return T && Object.defineProperties(C, {
            layerX: {
              value: K,
              configurable: !0
            },
            layerY: {
              value: J,
              configurable: !0
            },
            x: {
              value: K,
              configurable: !0
            },
            y: {
              value: J,
              configurable: !0
            }
          }), Y;
        }
        /* override */
        forceUpdate() {
          if (!this[o])
            if (this.parent && this.parent.hasOffscreenCanvas) {
              this.parent.forceUpdate();
              let C = null;
              const F = new Promise((K) => {
                C = K;
              });
              F._resolve = C, this[o] = F;
            } else {
              let C = null, F = null;
              const K = new Promise((J) => {
                C = J, this[I] && (F = Object(h.requestAnimationFrame)(() => {
                  delete K._requestID, this.render();
                }));
              });
              K._resolve = C, K._requestID = F, this[o] = K;
            }
        }
        getFBO() {
          const C = this.renderer.glRenderer, {
            width: F,
            height: K
          } = this.getResolution();
          return C && (!this[b] || this[b].width !== F || this[b].height !== K) ? (this[b] = {
            width: F,
            height: K,
            target: C.createFBO(),
            buffer: C.createFBO(),
            swap() {
              [this.target, this.buffer] = [this.buffer, this.target];
            }
          }, this[b]) : this[b] ? this[b] : null;
        }
        updateGlobalTransform() {
          if (this.layerTransformInvert) {
            const C = this.renderer, F = C.__globalTransformMatrix || C.globalTransformMatrix;
            C.__globalTransformMatrix = F;
            const K = W.mat2d.fromValues(1, 0, 0, 1, 0, 0);
            C.setGlobalTransform(...W.mat2d.multiply(K, F, this.transformMatrix));
          }
        }
        /* override */
        onPropertyChange(C, F, K) {
          if (super.onPropertyChange(C, F, K), C === "zIndex" && (this.canvas.style.zIndex = F), C === "transform" || C === "translate" || C === "rotate" || C === "scale" || C === "skew") {
            const J = this[m];
            if (this[m] = null, this.updateGlobalTransform(), J && !this.layerTransformInvert) {
              const T = this.renderer, Y = T.__globalTransformMatrix || T.globalTransformMatrix;
              T.setGlobalTransform(...Y);
            }
          }
        }
        _prepareRenderFinished() {
          this[o] && (this[o]._requestID && Object(h.cancelAnimationFrame)(this[o]._requestID), this[o]._resolve(), delete this[o]);
        }
        render({
          clear: C = !0
        } = {}) {
          const F = this[d].length ? this.getFBO() : null;
          F && this.renderer.glRenderer.bindFBO(F.target), C && this[r].clear();
          const K = this.draw();
          if (K && K.length && (this.renderer.drawMeshes(K), this.canvas.draw && this.canvas.draw()), F) {
            const J = this.renderer.glRenderer, T = this[d].length, {
              width: Y,
              height: x
            } = this.getResolution(), H = [0, 0, Y / this.displayRatio, x / this.displayRatio];
            this[d].forEach((Q, w) => {
              Q.blend = !0, Q.setTexture(F.target.texture, {
                rect: H
              }), w === T - 1 ? J.bindFBO(null) : (F.swap(), J.bindFBO(F.target)), this[r].clear(), this.renderer.drawMeshes([Q]);
            });
          }
          this._prepareRenderFinished();
        }
        /* override */
        setResolution({
          width: C,
          height: F
        }) {
          const K = this.renderer, J = K.__globalTransformMatrix || K.globalTransformMatrix, T = J[4], Y = J[5], x = J[0], {
            width: H,
            height: Q
          } = this.getResolution();
          (H !== C || Q !== F) && (super.setResolution({
            width: C,
            height: F
          }), this.canvas && (this.canvas.width = C, this.canvas.height = F, K.updateResolution && K.updateResolution()), this.attributes.size = [C, F], this[d].length && this[d].forEach((k) => {
            const f = new s.Figure2D();
            f.rect(0, 0, C / this.displayRatio, F / this.displayRatio), k.contours = f.contours;
          }));
          const [w, O] = this.renderOffset, q = this.displayRatio;
          (T !== w || Y !== O || x !== q) && (K.setGlobalTransform(q, 0, 0, q, w, O), K.__globalTransformMatrix = null, this[m] = null, this.updateGlobalTransform(), this.forceUpdate());
        }
        /**
         * tick(handler, {originTime = 0, playbackRate = 1.0, duration = Infinity})
         * @param {*} handler
         * @param {*} options
         */
        tick(C = null, F = {}) {
          let {
            duration: K = 1 / 0
          } = F, J = y(F, ["duration"]);
          const T = this.timeline.fork(J), Y = this;
          this[t] = this[t] || [], this[t].push({
            handler: C,
            duration: K
          });
          const x = () => {
            let H = null, Q = null;
            const w = () => {
              const O = this[t].map(({
                handler: q,
                duration: k
              }) => {
                const f = Math.min(1, T.currentTime / k);
                return {
                  value: q ? q(T.currentTime, f) : null,
                  p: f
                };
              });
              Y[u] || (Y[u] = Promise.resolve().then(() => {
                Y[I] && Y.render(), delete Y[u];
                for (let q = O.length - 1; q >= 0; q--) {
                  const {
                    value: k,
                    p: f
                  } = O[q];
                  (k === !1 || f >= 1) && this[t].splice(q, 1);
                }
                this[t].length > 0 && x();
              }));
            };
            if (this[o] && this[o]._type !== "ticker" && (Object(h.cancelAnimationFrame)(this[o]._requestID), delete this[o]), !this[o]) {
              const O = new Promise((q) => {
                H = q, Q = Object(h.requestAnimationFrame)(w);
              });
              O._resolve = H, O._requestID = Q, O._type = "ticker", this[o] = O;
            }
          };
          x();
        }
        toGlobalPos(C, F) {
          if (this.layerTransformInvert) {
            const H = this.transformMatrix;
            C = H[0] * C + H[2] * F + H[4], F = H[1] * C + H[3] * F + H[5];
          }
          const {
            width: K,
            height: J
          } = this.getResolution(), T = this.renderOffset, Y = [this.canvas.clientWidth, this.canvas.clientHeight];
          C = C * Y[0] / K + T[0], F = F * Y[1] / J + T[1];
          const x = this.displayRatio;
          return C *= x, F *= x, [C, F];
        }
        toLocalPos(C, F) {
          const {
            width: K,
            height: J
          } = this.getResolution(), T = this.renderOffset, Y = [this.canvas.clientWidth, this.canvas.clientHeight];
          C = C * K / Y[0] - T[0], F = F * J / Y[1] - T[1];
          const x = this.displayRatio;
          C /= x, F /= x;
          const H = this.layerTransformInvert;
          return H && (C = H[0] * C + H[2] * F + H[4], F = H[1] * C + H[3] * F + H[5]), [C, F];
        }
      }
      a.default.registerNode(R, "layer");
    },
    /* 287 */
    /***/
    function(Z, l, i) {
      i.r(l), i.d(l, "default", function() {
        return o;
      });
      var s = i(224), c = i(288), W = i(213), h = i(252), e = i(72);
      i(1).glMatrix.setMatrixArrayType(Array);
      function a(u, d) {
        if (u == null)
          return {};
        var b = G(u, d), t, m;
        if (Object.getOwnPropertySymbols) {
          var R = Object.getOwnPropertySymbols(u);
          for (m = 0; m < R.length; m++)
            t = R[m], !(d.indexOf(t) >= 0) && Object.prototype.propertyIsEnumerable.call(u, t) && (b[t] = u[t]);
        }
        return b;
      }
      function G(u, d) {
        if (u == null)
          return {};
        var b = {}, t = Object.keys(u), m, R;
        for (R = 0; R < t.length; R++)
          m = t[R], !(d.indexOf(m) >= 0) && (b[m] = u[m]);
        return b;
      }
      function y(u, d, b) {
        return d in u ? Object.defineProperty(u, d, { value: b, enumerable: !0, configurable: !0, writable: !0 }) : u[d] = b, u;
      }
      const n = "http://www.w3.org/2000/svg", V = Symbol.for("spritejs_setAttribute"), I = Symbol("root"), r = Symbol("task");
      function p(u, d = !0) {
        const b = u[I];
        if (b && b.children[0]) {
          const t = u.svg, m = u.layer ? u.layer.displayRatio : 1;
          if (!t.hasAttribute("data-original-width")) {
            let C = t.getAttribute("width");
            C = C ? Object(e.sizeToPixel)(C) : 300;
            let F = t.getAttribute("height");
            F = F ? Object(e.sizeToPixel)(F) : 150, t.hasAttribute("viewBox") || t.setAttribute("viewBox", `0 0 ${Math.round(C)} ${Math.round(F)}`), t.setAttribute("data-original-width", C), t.setAttribute("data-original-height", F);
          }
          let R = u.attributes.width || Number(t.getAttribute("data-original-width")), S = u.attributes.height || Number(t.getAttribute("data-original-height"));
          if (R *= m, S *= m, d && u.attributes.flexible) {
            const C = u.attributes.scale[0];
            if (R *= C, S *= C, t.setAttribute("width", R), t.setAttribute("height", S), R && S && u.textureImage) {
              const F = u.textureImage.width, K = u.textureImage.height, J = u.clientSize;
              u.attributes.textureRect = [0, 0, Math.round(J[0] * F / R), Math.round(J[1] * K / S)];
            }
          } else
            u[r] || (t.setAttribute("width", R), t.setAttribute("height", S), u[r] = Promise.resolve().then(() => {
              delete u[r];
              const C = b.innerHTML, F = new Blob([C], {
                type: "image/svg+xml"
              }), K = URL.createObjectURL(F), J = new Image();
              J.onload = function() {
                J.width && J.height ? (u.attributes[V]("texture", J), u.attributes.flexible && (u.attributes.textureRect = null)) : u.attributes[V]("texture", null);
              }, J.src = K;
            }));
        }
      }
      class o extends s.default {
        constructor(d = {}) {
          typeof d == "string" && (d = {
            svgText: d
          });
          let {
            svgText: b
          } = d, t = a(d, ["svgText"]);
          if (super(t), this[I] = document.createElement("div"), b) {
            this[I].innerHTML = b;
            const m = this[I].children[0];
            m ? m.setAttribute("xmlns", n) : (fetch(b).then((R) => R.text()).then((R) => {
              this[I].innerHTML = R, (!this.observer || this.attributes.flexible) && p(this);
            }), b = null);
          }
          if (!b) {
            const m = document.createElementNS(n, "svg");
            m.setAttribute("xmlns", n), this[I].appendChild(m);
          }
          if (typeof MutationObserver == "function") {
            const m = new MutationObserver((R) => {
              p(this, !1);
            });
            m.observe(this[I], {
              attributes: !0,
              subtree: !0,
              characterData: !0,
              childList: !0
            }), this.observer = m;
          }
        }
        get children() {
          return [this.svg];
        }
        get childNodes() {
          return [this.svg];
        }
        get svg() {
          return this[I] ? this[I].children[0] : null;
        }
        /* override */
        setResolution({
          width: d,
          height: b
        }) {
          super.setResolution({
            width: d,
            height: b
          }), p(this);
        }
        /* override */
        dispatchPointerEvent(d) {
          const b = super.dispatchPointerEvent(d);
          if (b && this.attributes.passEvents && typeof MouseEvent == "function") {
            const {
              x: t,
              y: m
            } = d;
            let [R, S] = this.getOffsetPosition(t, m);
            const C = d.originalEvent, F = this.attributes.anchor, K = this.clientSize;
            R = (R + F[0] * K[0]) / 2, S = (S + F[1] * K[1]) / 2;
            const J = d.type;
            if (J === C.type) {
              let T = null;
              if (C instanceof MouseEvent)
                T = new MouseEvent(J, {
                  screenX: R,
                  screenY: S,
                  clientX: R,
                  clientY: S,
                  bubbles: C.bubbles,
                  button: C.button,
                  buttons: C.buttons,
                  cancelBubble: C.cancelBubble,
                  cancelable: C.cancelable,
                  currentTarget: C.currentTarget,
                  fromElement: C.fromElement,
                  relatedTarget: C.relatedTarget,
                  returnValue: C.returnValue,
                  srcElement: C.srcElement,
                  target: C.target,
                  toElement: C.toElement,
                  // view: originalEvent.view,
                  which: C.witch
                });
              else if (C instanceof TouchEvent) {
                let Y = null;
                const x = C.changedTouches || [C];
                for (let H = 0; H < x.length; H++) {
                  const Q = x[H];
                  if (d.identifier === Q.identifier) {
                    Y = Q;
                    break;
                  }
                }
                if (Y) {
                  const H = new Touch({
                    identifier: Y.identifier,
                    target: Y.target,
                    clientX: R,
                    clientY: S,
                    screenX: R,
                    screenY: S,
                    pageX: R,
                    pageY: S,
                    radiusX: Y.radiusX,
                    radiusY: Y.radiusY,
                    rotationAngle: Y.rotationAngle,
                    force: Y.force
                  });
                  T = new TouchEvent(J, {
                    cancelable: C.cancelable,
                    bubbles: C.bubbles,
                    composed: C.composed,
                    touches: [H],
                    targetTouches: [H],
                    changedTouches: [H]
                  });
                }
              } else
                T = C;
              T && this.svg.dispatchEvent(T);
            }
          }
          return b;
        }
        getElementById(d) {
          return Object(h.querySelector)(`#${d}`, this);
        }
        getElementsByClassName(d) {
          return Object(h.querySelectorAll)(`.${d}`, this);
        }
        getElementsByName(d) {
          return Object(h.querySelectorAll)(`[name="${d}"]`, this);
        }
        getElementsByTagName(d) {
          return Object(h.querySelectorAll)(d, this);
        }
        querySelector(d) {
          return Object(h.querySelector)(d, this);
        }
        querySelectorAll(d) {
          return Object(h.querySelectorAll)(d, this);
        }
        /* override */
        onPropertyChange(d, b, t) {
          super.onPropertyChange(d, b, t), d === "flexible" && p(this), this.attributes.flexible && (d === "width" || d === "height" || d === "scale" || d === "transform") && p(this);
        }
      }
      y(o, "Attr", c.default), W.default.registerNode(o, "spritesvg");
    },
    /* 288 */
    /***/
    function(Z, l, i) {
      i.r(l), i.d(l, "default", function() {
        return e;
      });
      var s = i(225);
      i(1).glMatrix.setMatrixArrayType(Array);
      const c = Symbol.for("spritejs_getAttribute"), W = Symbol.for("spritejs_setAttribute"), h = Symbol.for("spritejs_setAttributeDefault");
      class e extends s.default {
        constructor(G) {
          super(G), this[h]({
            passEvents: !1,
            flexible: !1
          });
        }
        // readonly
        get texture() {
          return this[c]("texture");
        }
        set texture(G) {
        }
        // eslint-disable-line no-empty-function
        get passEvents() {
          return this[c]("passEvents");
        }
        set passEvents(G) {
          return this[W]("passEvents", G);
        }
        get flexible() {
          return this[c]("flexible");
        }
        set flexible(G) {
          return this[W]("flexible", G);
        }
      }
    },
    /* 289 */
    /***/
    function(Z, l, i) {
      i.r(l);
      var s = i(12);
      i(1).glMatrix.setMatrixArrayType(Array);
      function c(G, y) {
        var n = Object.keys(G);
        if (Object.getOwnPropertySymbols) {
          var V = Object.getOwnPropertySymbols(G);
          y && (V = V.filter(function(I) {
            return Object.getOwnPropertyDescriptor(G, I).enumerable;
          })), n.push.apply(n, V);
        }
        return n;
      }
      function W(G) {
        for (var y = 1; y < arguments.length; y++) {
          var n = arguments[y] != null ? arguments[y] : {};
          y % 2 ? c(Object(n), !0).forEach(function(V) {
            h(G, V, n[V]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(G, Object.getOwnPropertyDescriptors(n)) : c(Object(n)).forEach(function(V) {
            Object.defineProperty(G, V, Object.getOwnPropertyDescriptor(n, V));
          });
        }
        return G;
      }
      function h(G, y, n) {
        return y in G ? Object.defineProperty(G, y, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : G[y] = n, G;
      }
      const e = Symbol("inited");
      let a = null;
      typeof Worker == "function" && (a = class extends Worker {
        constructor(G) {
          if (G.worker === !0 && (G.worker = `./${G.id}.worker.js`), super(G.worker), this.options = G, !G.canvas) {
            const {
              width: y,
              height: n
            } = this.getResolution(), V = s.ENV.createCanvas(y, n, {
              offscreen: !1
            });
            V.style && (V.style.position = "absolute"), V.dataset && (V.dataset.layerId = G.id), G.canvas = V;
          }
          this.canvas = G.canvas;
        }
        get id() {
          return this.options.id;
        }
        setResolution({
          width: G,
          height: y
        }) {
          if (this[e])
            this.postMessage({
              type: "resolution_change",
              width: G,
              height: y
            });
          else {
            this.canvas.width = G, this.canvas.height = y;
            const n = this.options, V = n.canvas.transferControlToOffscreen(), I = W({}, n);
            delete I.container, I.canvas = V, this.postMessage({
              type: "create",
              options: I
            }, [V]), this[e] = !0;
          }
        }
        getResolution() {
          if (this.canvas) {
            const {
              width: G,
              height: y
            } = this.canvas;
            return {
              width: G,
              height: y
            };
          }
          return {
            width: 300,
            height: 150
          };
        }
        remove() {
          return this.parent && this.parent.removeChild ? (this.parent.removeChild(this), !0) : !1;
        }
        connect(G, y) {
          Object.defineProperty(this, "parent", {
            value: G,
            writable: !1,
            configurable: !0
          }), Object.defineProperty(this, "zOrder", {
            value: y,
            writable: !1,
            configurable: !0
          });
        }
        disconnect() {
          delete this.parent, delete this.zOrder;
        }
        dispatchPointerEvent(G) {
          this.postMessage({
            type: "event",
            event: {
              cancelBubble: G.cancelBubble,
              bubbles: G.bubbles,
              detail: G.detail,
              identifier: G.identifier,
              layerX: G.layerX,
              layerY: G.layerY,
              originalX: G.originalX,
              originalY: G.originalY,
              type: G.type,
              x: G.x,
              y: G.y
            }
          });
        }
      }), l.default = a;
    },
    /* 290 */
    /***/
    function(Z, l, i) {
      i.r(l), (function(s) {
        i.d(l, "default", function() {
          return R;
        });
        var c = i(12), W = i(68), h = i(70), e = i(286), a = i(289), G = i(250), y = i(291), n = i(214), V = i(218), I = i(213);
        i(1).glMatrix.setMatrixArrayType(Array);
        const r = Symbol("enteredTargets");
        function p(S) {
          return S.id = S.id || `_layer${Math.random().toString(36).slice(2, 12)}`, S.dataset || (S.dataset = {}), S.dataset.layerId = S.id, S.connect = (C, F) => {
            S.parent = C, Object.defineProperty(S, "zOrder", {
              value: F,
              writable: !1,
              configurable: !0
            });
          }, S.disconnect = (C) => {
            delete S.zOrder;
          }, S.canvas = S, S.getResolution = () => ({
            width: 0,
            height: 0
          }), S.setResolution = () => !1, S.options = {
            handleEvent: !1
          }, S;
        }
        function o(S, C) {
          const F = S.children;
          let K = null;
          for (let J = 0; J < F.length; J++) {
            const T = F[J];
            if ((C === T || K != null) && (K = T), K && K !== C && !K.offscreen)
              return K.canvas;
          }
          return null;
        }
        function u(S, C) {
          const [F, K] = S.renderOffset, {
            width: J,
            height: T
          } = S.getResolution(), Y = S.displayRatio;
          S.renderer.drawImage(C.canvas, -F / Y, -K / Y, J / Y, T / Y);
        }
        const d = {};
        function b(S) {
          const C = ["mousedown", "mouseup", "mousemove", "mousewheel", "wheel", "touchstart", "touchend", "touchmove", "touchcancel", "click", "dblclick", "longpress", "tap", "contextmenu"], F = S.container;
          F.addEventListener("mouseleave", (K) => {
            const J = S[r];
            if (J.size) {
              const T = new n.default("mouseleave");
              T.setOriginalEvent(K), [...J].forEach((Y) => {
                Y.dispatchEvent(T);
              }), S[r].clear();
            }
          }, {
            passive: !0
          }), C.forEach((K) => {
            F.addEventListener(K, (J) => {
              const {
                left: T,
                top: Y,
                displayRatio: x
              } = S.options, H = S.orderedChildren;
              Object(y.default)(J, {
                offsetLeft: T,
                offsetTop: Y,
                displayRatio: x
              }).forEach((w) => {
                const O = w.identifier;
                if (w.type === "touchmove" || w.type === "touchend") {
                  const k = d[O];
                  k && k.dispatchEvent(w), w.type === "touchend" && delete d[O];
                } else {
                  for (let k = H.length - 1; k >= 0; k--) {
                    const f = H[k];
                    if (f.options.handleEvent !== !1) {
                      if (f.dispatchPointerEvent(w) && w.target !== f)
                        break;
                      w.cancelBubble = !1;
                    }
                  }
                  if (w.target === H[0])
                    for (let k = H.length - 1; k >= 0; k--) {
                      const f = H[k];
                      if (f.options.handleEvent !== !1) {
                        w.target = f;
                        break;
                      }
                    }
                }
                const q = w.target;
                if (w.type === "touchstart" && (d[O] = w.target), w.type === "mousemove") {
                  const k = S[r];
                  let f;
                  if (q) {
                    const _ = q.ancestors || [];
                    f = /* @__PURE__ */ new Set([q, ..._]);
                  } else
                    f = /* @__PURE__ */ new Set();
                  const D = Object.entries(J);
                  if (!k.has(q) && q) {
                    const _ = new n.default("mouseenter");
                    _.setOriginalEvent(J), D.forEach(([$, oi]) => {
                      _[$] = oi;
                    }), k.add(q), q.dispatchEvent(_);
                    const bi = q.ancestors;
                    bi && bi.forEach(($) => {
                      $ instanceof h.default && !k.has($) && (k.add($), $.dispatchEvent(_));
                    });
                  }
                  const ii = new n.default("mouseleave");
                  ii.setOriginalEvent(J), D.forEach(([_, bi]) => {
                    ii[_] = bi;
                  }), [...k].forEach((_) => {
                    f.has(_) || (k.delete(_), _.dispatchEvent(ii));
                  });
                }
              });
            }, {
              passive: K !== "contextmenu"
            });
          });
        }
        function t(S, C) {
          if (C && C.style) {
            let {
              width: F,
              height: K,
              mode: J,
              container: T
            } = S;
            const {
              clientWidth: Y,
              clientHeight: x
            } = T;
            F = F || Y, K = K || x, J === "static" ? (C.style.width = `${F}px`, C.style.height = `${K}px`) : (C.style.top = "0", C.style.left = "0", C.style.width = `${Y}px`, C.style.height = `${x}px`, C.style.transform = "", C.style.webkitTransform = "");
          }
        }
        const m = Symbol("offscreenLayerCount");
        class R extends G.default {
          /**
            width
            height
            mode: 'static', 'scale', 'stickyWidth', 'stickyHeight', 'stickyTop', 'stickyBottom', 'stickyLeft', 'stickyRight'
           */
          constructor(C = {}) {
            if (super(), !C.container)
              if (typeof c.ENV.Container == "function")
                C.container = new c.ENV.Container(C.width || 300, C.height || 150);
              else
                throw new Error("No container specified.");
            if (this.container = C.container, this.container.style && (this.container.style.overflow || (this.container.style.overflow = "hidden"), this.container.style.position || (this.container.style.position = "relative")), this.options = C, C.displayRatio = C.displayRatio || 1, C.mode = C.mode || "scale", C.left = 0, C.top = 0, C.autoResize = C.autoResize !== !1, C.autoResize) {
              let F;
              if (typeof globalThis < "u" ? F = globalThis : F = typeof window < "u" ? window : s, F.addEventListener) {
                const K = this;
                F.addEventListener("resize", function J() {
                  typeof document < "u" && document.contains(K.container) ? K.resize() : F.removeEventListener("resize", J);
                });
              }
            }
            this[r] = /* @__PURE__ */ new Set(), this.setResolution(C), b(this), this[m] = 0;
          }
          get hasOffscreenCanvas() {
            return this[m] > 0;
          }
          set displayRatio(C) {
            this.options.displayRatio !== C && (this.options.displayRatio = C, this.resize());
          }
          get displayRatio() {
            return this.options.displayRatio;
          }
          set height(C) {
            this.options.height !== C && (this.options.height = C, this.resize());
          }
          get height() {
            return this.options.height;
          }
          set mode(C) {
            this.options.mode !== C && (this.options.mode = C, this.resize());
          }
          get mode() {
            return this.options.mode;
          }
          set width(C) {
            this.options.width !== C && (this.options.width = C, this.resize());
          }
          get width() {
            return this.options.width;
          }
          /* override */
          appendChild(C) {
            !(C instanceof e.default) && !(C instanceof a.default) && p(C);
            const F = super.appendChild(C), K = C.canvas;
            return C.offscreen ? this[m]++ : this.container.appendChild(K), t(this.options, K), C.setResolution(this.getResolution()), F;
          }
          /* override */
          forceUpdate() {
            this.hasOffscreenCanvas && !this._requestID && (this._requestID = Object(W.requestAnimationFrame)(() => {
              delete this._requestID, this.render();
            }));
          }
          /* override */
          insertBefore(C, F) {
            !(C instanceof e.default) && !(C instanceof a.default) && p(C);
            const K = super.insertBefore(C, F), J = C.canvas;
            if (!C.offscreen) {
              const T = o(this, C);
              this.container.insertBefore(J, T);
            }
            return t(this.options, J), C.setResolution(this.getResolution()), K;
          }
          layer(C = "default", F = {}) {
            F = Object.assign({}, this.options, F), F.id = C;
            const K = this.orderedChildren;
            for (let Y = 0; Y < K.length; Y++)
              if (K[Y].id === C)
                return K[Y];
            const J = F.worker;
            let T;
            return J ? T = new a.default(F) : T = new e.default(F), this.appendChild(T), T;
          }
          async preload(...C) {
            const F = [], K = [], J = [];
            for (let T = 0; T < C.length; T++) {
              const Y = C[T];
              let x;
              if (typeof Y == "string")
                x = Object(V.loadTexture)(Y);
              else if (Array.isArray(Y))
                x = Object(V.loadFrames)(...Y);
              else {
                const {
                  id: H,
                  src: Q
                } = Y;
                x = Object(V.loadTexture)(Q, H);
              }
              x instanceof Promise || (x = Promise.resolve(x)), K.push(x.then((H) => {
                F.push(H), J[T] = H;
                const Q = new n.default({
                  type: "preload",
                  detail: {
                    current: H,
                    loaded: F,
                    resources: C
                  }
                });
                this.dispatchEvent(Q);
              }));
            }
            return await Promise.all(K), J;
          }
          /* override */
          removeChild(C) {
            const F = super.removeChild(C);
            if (F) {
              C._prepareRenderFinished && C._prepareRenderFinished();
              const K = C.canvas;
              K && K.remove && K.remove(), C.offscreen && this[m]--;
            }
            return F;
          }
          // for offscreen mode rendering
          render() {
            const C = this.orderedChildren;
            let F = null;
            const K = [];
            for (let J = 0; J < C.length; J++) {
              const T = C[J], Y = K.length > 0;
              if (T instanceof e.default && !T.offscreen)
                if (!T.autoRender)
                  Y && (console.warn("Some offscreen canvas will not be rendered."), K.length = 0);
                else if (F = T, Y) {
                  T.renderer.clear();
                  for (let x = 0; x < K.length; x++) {
                    const H = K[x];
                    H.render(), u(T, H);
                  }
                  K.length = 0, T.render({
                    clear: !1
                  });
                } else
                  T.prepareRender && T.render();
              else
                T.offscreen ? F ? (T.prepareRender && T.render(), u(F, T)) : K.push(T) : T instanceof a.default && Y && (console.warn("Some offscreen canvas will not be rendered."), K.length = 0);
            }
          }
          /* override */
          replaceChild(C, F) {
            const K = super.replaceChild(C, F);
            F.canvas.remove && F.canvas.remove(), F.offscreen && this[m]--;
            const J = C.canvas;
            if (!C.offscreen) {
              const T = o(this, C);
              this.container.insertBefore(J, T);
            }
            return t(this.options, J), C.setResolution(this.getResolution()), K;
          }
          resize() {
            const C = this.options;
            this.children.forEach((F) => {
              t(C, F.canvas);
            }), this.setResolution(C), this.dispatchEvent({
              type: "resize"
            });
          }
          /* override */
          setResolution({
            width: C,
            height: F
          } = {}) {
            const K = this.container, {
              clientWidth: J,
              clientHeight: T
            } = K;
            (C == null || F == null) && (C = C ?? J, F = F ?? T);
            const {
              mode: Y,
              displayRatio: x
            } = this.options;
            if (C *= x, F *= x, this.options.left = 0, this.options.top = 0, Y === "stickyHeight" || Y === "stickyLeft" || Y === "stickyRight") {
              const H = C;
              C = J * F / T, Y === "stickyHeight" && (this.options.left = 0.5 * (C - H)), Y === "stickyRight" && (this.options.left = C - H);
            } else if (Y === "stickyWidth" || Y === "stickyTop" || Y === "stickyBottom") {
              const H = F;
              F = T * C / J, Y === "stickyWidth" && (this.options.top = 0.5 * (F - H)), Y === "stickyBottom" && (this.options.top = F - H);
            }
            super.setResolution({
              width: C,
              height: F
            });
          }
          snapshot({
            offscreen: C = !1,
            layers: F
          } = {}) {
            const K = C ? "snapshotOffScreenCanvas" : "snapshotCanvas", {
              width: J,
              height: T
            } = this.getResolution();
            this[K] = this[K] || c.ENV.createCanvas(J, T, {
              offscreen: C
            });
            const Y = this[K].getContext("2d");
            F = F || this.orderedChildren, this[K].width = J, this[K].height = T;
            for (let x = 0; x < F.length; x++) {
              const H = F[x];
              if (!H.options.ignoreSnapshot) {
                H.render && H.render();
                const Q = H.canvas;
                Q && Q !== H && Y.drawImage(Q, 0, 0, J, T);
              }
            }
            return this[K];
          }
        }
        typeof document < "u" && (R.prototype.layer3d = function(S, C = {}) {
          const F = C.url || "https://unpkg.com/sprite-extend-3d/dist/sprite-extend-3d.min.js";
          return new Promise((K, J) => {
            const T = document.createElement("script");
            T.async = !1, T.src = F, T.onload = () => {
              try {
                K(this.layer3d(S, C));
              } catch (Y) {
                J(Y);
              }
            }, document.documentElement.appendChild(T);
          });
        }), I.default.registerNode(R, "scene");
      }).call(this, i(22));
    },
    /* 291 */
    /***/
    function(Z, l, i) {
      i.r(l), i.d(l, "default", function() {
        return c;
      });
      var s = i(214);
      i(1).glMatrix.setMatrixArrayType(Array);
      function c(W, {
        offsetTop: h = 0,
        offsetLeft: e = 0,
        displayRatio: a = 1
      } = {}) {
        let G, y;
        const n = [], {
          left: V,
          top: I,
          width: r,
          height: p
        } = W.target.getBoundingClientRect(), o = W.target.width, u = W.target.height, d = W.changedTouches || [W];
        for (let t = 0; t < d.length; t++) {
          const m = d[t], R = m.identifier, {
            clientX: S,
            clientY: C
          } = m;
          S != null && C != null && n.push({
            x: Math.round((S | 0) - V),
            y: Math.round((C | 0) - I),
            identifier: R
          });
        }
        n.length <= 0 && n.push({
          x: G,
          y
        });
        const b = [];
        return n.forEach((t) => {
          t.x != null && t.y != null && (G = (t.x * o / r - e) / a, y = (t.y * u / p - h) / a);
          const m = new s.default(W);
          Object.defineProperties(m, {
            layerX: {
              value: G,
              configurable: !0
            },
            layerY: {
              value: y,
              configurable: !0
            },
            originalX: {
              value: t.x
            },
            originalY: {
              value: t.y
            },
            x: {
              value: G,
              configurable: !0
            },
            y: {
              value: y,
              configurable: !0
            },
            identifier: {
              value: t.identifier
            }
          }), b.push(m);
        }), b;
      }
    }
    /******/
  ])
);
Fi.version;
Fi.Arc;
Fi.Block;
Fi.Cloud;
Fi.Color;
Fi.Ellipse;
Fi.Gradient;
const Bs = Fi.Group;
Fi.Label;
Fi.Layer;
Fi.LayerWorker;
Fi.Node;
Fi.Parallel;
Fi.Path;
Fi.Polyline;
const Wd = Fi.Rect;
Fi.Regular;
Fi.Ring;
Fi.Scene;
Fi.Sprite;
Fi.SpriteSvg;
Fi.Star;
Fi.Triangle;
Fi.helpers;
Fi.createElement;
Fi.isSpriteNode;
Fi.registerNode;
Fi.requestAnimationFrame;
Fi.cancelAnimationFrame;
Fi.ENV;
const Os = {
  linear: (Z) => Z,
  easeInQuad: (Z) => Z * Z,
  easeOutQuad: (Z) => Z * (2 - Z),
  easeInOutQuad: (Z) => Z < 0.5 ? 2 * Z * Z : -1 + (4 - 2 * Z) * Z,
  easeInCubic: (Z) => Z * Z * Z,
  easeOutCubic: (Z) => --Z * Z * Z + 1,
  easeInOutCubic: (Z) => Z < 0.5 ? 4 * Z * Z * Z : (Z - 1) * (2 * Z - 2) * (2 * Z - 2) + 1,
  easeInQuart: (Z) => Z * Z * Z * Z,
  easeOutQuart: (Z) => 1 - --Z * Z * Z * Z,
  easeInOutQuart: (Z) => Z < 0.5 ? 8 * Z * Z * Z * Z : 1 - 8 * --Z * Z * Z * Z,
  easeInQuint: (Z) => Z * Z * Z * Z * Z,
  easeOutQuint: (Z) => 1 + --Z * Z * Z * Z * Z,
  easeInOutQuint: (Z) => Z < 0.5 ? 16 * Z * Z * Z * Z * Z : 1 + 16 * --Z * Z * Z * Z * Z,
  easeInSine: (Z) => 1 - Math.cos(Z * Math.PI / 2),
  easeOutSine: (Z) => Math.sin(Z * Math.PI / 2),
  easeInOutSine: (Z) => -(Math.cos(Math.PI * Z) - 1) / 2,
  easeInExpo: (Z) => Z <= 0 ? 0 : Math.pow(2, 10 * Z - 10),
  easeOutExpo: (Z) => Z >= 1 ? 1 : 1 - Math.pow(2, -10 * Z),
  easeInOutExpo: (Z) => Z <= 0 ? 0 : Z >= 1 ? 1 : Z < 0.5 ? Math.pow(2, 20 * Z - 10) / 2 : (2 - Math.pow(2, -20 * Z + 10)) / 2
};
class Wi {
  constructor(l = 0, i = 0, s = 1) {
    Object.defineProperty(this, "x", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: l
    }), Object.defineProperty(this, "y", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: i
    }), Object.defineProperty(this, "z", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: s
    });
  }
  get XY() {
    return [this.x, this.y];
  }
  setz(l) {
    return this.z = l, this;
  }
  setXY(l = this.x, i = this.y) {
    return this.x = l, this.y = i, this;
  }
  set(l = this.x, i = this.y, s = this.z) {
    return this.x = l, this.y = i, this.z = s, this;
  }
  setTo({ x: l = 0, y: i = 0, z: s = 1 }) {
    return this.x = l, this.y = i, this.z = s, this;
  }
  rot(l) {
    if (l === 0)
      return this;
    const { x: i, y: s } = this, c = Math.sin(l), W = Math.cos(l);
    return this.x = i * W - s * c, this.y = i * c + s * W, this;
  }
  rotWith(l, i) {
    if (i === 0)
      return this;
    const s = this.x - l.x, c = this.y - l.y, W = Math.sin(i), h = Math.cos(i);
    return this.x = l.x + (s * h - c * W), this.y = l.y + (s * W + c * h), this;
  }
  clone() {
    const { x: l, y: i, z: s } = this;
    return new Wi(l, i, s);
  }
  sub(l) {
    return this.x -= l.x, this.y -= l.y, this;
  }
  subXY(l, i) {
    return this.x -= l, this.y -= i, this;
  }
  subScalar(l) {
    return this.x -= l, this.y -= l, this;
  }
  add(l) {
    return this.x += l.x, this.y += l.y, this;
  }
  addXY(l, i) {
    return this.x += l, this.y += i, this;
  }
  addScalar(l) {
    return this.x += l, this.y += l, this;
  }
  clamp(l, i) {
    return this.x = Math.max(this.x, l), this.y = Math.max(this.y, l), i !== void 0 && (this.x = Math.min(this.x, i), this.y = Math.min(this.y, i)), this;
  }
  div(l) {
    return this.x /= l, this.y /= l, this;
  }
  divV(l) {
    return this.x /= l.x, this.y /= l.y, this;
  }
  mul(l) {
    return this.x *= l, this.y *= l, this;
  }
  mulV(l) {
    return this.x *= l.x, this.y *= l.y, this;
  }
  abs() {
    return this.x = Math.abs(this.x), this.y = Math.abs(this.y), this;
  }
  nudge(l, i) {
    const s = Wi.Tan(l, this);
    return this.add(s.mul(i));
  }
  neg() {
    return this.x *= -1, this.y *= -1, this;
  }
  cross(l) {
    return this.x = this.y * l.z - this.z * l.y, this.y = this.z * l.x - this.x * l.z, this;
  }
  dpr(l) {
    return Wi.Dpr(this, l);
  }
  cpr(l) {
    return Wi.Cpr(this, l);
  }
  len2() {
    return Wi.Len2(this);
  }
  len() {
    return Wi.Len(this);
  }
  pry(l) {
    return Wi.Pry(this, l);
  }
  per() {
    const { x: l, y: i } = this;
    return this.x = i, this.y = -l, this;
  }
  uni() {
    return Wi.Uni(this);
  }
  tan(l) {
    return Wi.Tan(this, l);
  }
  dist(l) {
    return Wi.Dist(this, l);
  }
  distanceToLineSegment(l, i) {
    return Wi.DistanceToLineSegment(l, i, this);
  }
  slope(l) {
    return Wi.Slope(this, l);
  }
  snapToGrid(l) {
    return this.x = Math.round(this.x / l) * l, this.y = Math.round(this.y / l) * l, this;
  }
  angle(l) {
    return Wi.Angle(this, l);
  }
  toAngle() {
    return Wi.ToAngle(this);
  }
  lrp(l, i) {
    return this.x = this.x + (l.x - this.x) * i, this.y = this.y + (l.y - this.y) * i, this;
  }
  equals(l, i) {
    return Wi.Equals(this, l, i);
  }
  equalsXY(l, i) {
    return Wi.EqualsXY(this, l, i);
  }
  norm() {
    const l = this.len();
    return this.x = l === 0 ? 0 : this.x / l, this.y = l === 0 ? 0 : this.y / l, this;
  }
  toFixed() {
    return Wi.ToFixed(this);
  }
  toString() {
    return Wi.ToString(Wi.ToFixed(this));
  }
  toJson() {
    return Wi.ToJson(this);
  }
  toArray() {
    return Wi.ToArray(this);
  }
  static Add(l, i) {
    return new Wi(l.x + i.x, l.y + i.y);
  }
  static AddXY(l, i, s) {
    return new Wi(l.x + i, l.y + s);
  }
  static Sub(l, i) {
    return new Wi(l.x - i.x, l.y - i.y);
  }
  static SubXY(l, i, s) {
    return new Wi(l.x - i, l.y - s);
  }
  static AddScalar(l, i) {
    return new Wi(l.x + i, l.y + i);
  }
  static SubScalar(l, i) {
    return new Wi(l.x - i, l.y - i);
  }
  static Div(l, i) {
    return new Wi(l.x / i, l.y / i);
  }
  static Mul(l, i) {
    return new Wi(l.x * i, l.y * i);
  }
  static DivV(l, i) {
    return new Wi(l.x / i.x, l.y / i.y);
  }
  static MulV(l, i) {
    return new Wi(l.x * i.x, l.y * i.y);
  }
  static Neg(l) {
    return new Wi(-l.x, -l.y);
  }
  static Per(l) {
    return new Wi(l.y, -l.x);
  }
  static Dist2(l, i) {
    return Wi.Sub(l, i).len2();
  }
  static Abs(l) {
    return new Wi(Math.abs(l.x), Math.abs(l.y));
  }
  static Dist(l, i) {
    return Math.hypot(l.y - i.y, l.x - i.x);
  }
  static Dpr(l, i) {
    return l.x * i.x + l.y * i.y;
  }
  static Cross(l, i) {
    return new Wi(
      l.y * i.z - l.z * i.y,
      l.z * i.x - l.x * i.z
      // A.z = A.x * V.y - A.y * V.x
    );
  }
  static Cpr(l, i) {
    return l.x * i.y - i.x * l.y;
  }
  static Len2(l) {
    return l.x * l.x + l.y * l.y;
  }
  static Len(l) {
    return Math.hypot(l.x, l.y);
  }
  static Pry(l, i) {
    return Wi.Dpr(l, i) / Wi.Len(i);
  }
  static Uni(l) {
    return Wi.Div(l, Wi.Len(l));
  }
  static Tan(l, i) {
    return Wi.Uni(Wi.Sub(l, i));
  }
  static Min(l, i) {
    return new Wi(Math.min(l.x, i.x), Math.min(l.y, i.y));
  }
  static Max(l, i) {
    return new Wi(Math.max(l.x, i.x), Math.max(l.y, i.y));
  }
  static From(l) {
    return new Wi().add(l);
  }
  static FromArray(l) {
    return new Wi(l[0], l[1]);
  }
  static Rot(l, i = 0) {
    const s = Math.sin(i), c = Math.cos(i);
    return new Wi(l.x * c - l.y * s, l.x * s + l.y * c);
  }
  static RotWith(l, i, s) {
    const c = l.x - i.x, W = l.y - i.y, h = Math.sin(s), e = Math.cos(s);
    return new Wi(i.x + (c * e - W * h), i.y + (c * h + W * e));
  }
  /**
   * Get the nearest point on a line with a known unit vector that passes through point A
   *
   * ```ts
   * Vec.nearestPointOnLineThroughPoint(A, u, Point)
   * ```
   *
   * @param A - Any point on the line
   * @param u - The unit vector for the line.
   * @param P - A point not on the line to test.
   */
  static NearestPointOnLineThroughPoint(l, i, s) {
    return Wi.Mul(i, Wi.Sub(s, l).pry(i)).add(l);
  }
  static NearestPointOnLineSegment(l, i, s, c = !0) {
    const W = Wi.Tan(i, l), h = Wi.Add(l, Wi.Mul(W, Wi.Sub(s, l).pry(W)));
    if (c) {
      if (h.x < Math.min(l.x, i.x))
        return Wi.Cast(l.x < i.x ? l : i);
      if (h.x > Math.max(l.x, i.x))
        return Wi.Cast(l.x > i.x ? l : i);
      if (h.y < Math.min(l.y, i.y))
        return Wi.Cast(l.y < i.y ? l : i);
      if (h.y > Math.max(l.y, i.y))
        return Wi.Cast(l.y > i.y ? l : i);
    }
    return h;
  }
  static DistanceToLineThroughPoint(l, i, s) {
    return Wi.Dist(s, Wi.NearestPointOnLineThroughPoint(l, i, s));
  }
  static DistanceToLineSegment(l, i, s, c = !0) {
    return Wi.Dist(s, Wi.NearestPointOnLineSegment(l, i, s, c));
  }
  static Snap(l, i = 1) {
    return new Wi(Math.round(l.x / i) * i, Math.round(l.y / i) * i);
  }
  static Cast(l) {
    return l instanceof Wi ? l : Wi.From(l);
  }
  static Slope(l, i) {
    return l.x === i.y ? NaN : (l.y - i.y) / (l.x - i.x);
  }
  static Angle(l, i) {
    return Math.atan2(i.y - l.y, i.x - l.x);
  }
  static Lrp(l, i, s) {
    return Wi.Sub(i, l).mul(s).add(l);
  }
  static Med(l, i) {
    return new Wi((l.x + i.x) / 2, (l.y + i.y) / 2);
  }
  static Equals(l, i, s = 1e-4) {
    return Math.abs(l.x - i.x) < s && Math.abs(l.y - i.y) < s;
  }
  static EqualsXY(l, i, s) {
    return l.x === i && l.y === s;
  }
  static EqualsXYZ(l, i, s = 1e-4) {
    return Wi.Equals(l, i, s) && Math.abs((l.z || 0) - (i.z || 0)) < s;
  }
  static Clockwise(l, i, s) {
    return (s.x - l.x) * (i.y - l.y) - (i.x - l.x) * (s.y - l.y) < 0;
  }
  static Rescale(l, i) {
    const s = Wi.Len(l);
    return new Wi(i * l.x / s, i * l.y / s);
  }
  static ScaleWithOrigin(l, i, s) {
    return Wi.Sub(l, s).mul(i).add(s);
  }
  static ScaleWOrigin(l, i, s) {
    return Wi.Sub(l, s).mulV(i).add(s);
  }
  static ToFixed(l, i = 2) {
    return new Wi(+l.x.toFixed(i), +l.y.toFixed(i), +l.z.toFixed(i));
  }
  static Nudge(l, i, s) {
    return Wi.Add(l, Wi.Tan(i, l).mul(s));
  }
  static ToString(l) {
    return `${l.x}, ${l.y}`;
  }
  static ToAngle(l) {
    let i = Math.atan2(l.y, l.x);
    return i < 0 && (i += Math.PI * 2), i;
  }
  static FromAngle(l, i = 1) {
    return new Wi(Math.cos(l) * i, Math.sin(l) * i);
  }
  static ToArray(l) {
    return [l.x, l.y, l.z];
  }
  static ToJson(l) {
    const { x: i, y: s, z: c } = l;
    return { x: i, y: s, z: c };
  }
  static Average(l) {
    const i = l.length, s = new Wi(0, 0);
    for (let c = 0; c < i; c++)
      s.add(l[c]);
    return s.div(i);
  }
  static Clamp(l, i, s) {
    return s === void 0 ? new Wi(Math.min(Math.max(l.x, i)), Math.min(Math.max(l.y, i))) : new Wi(Math.min(Math.max(l.x, i), s), Math.min(Math.max(l.y, i), s));
  }
  /**
   * Get an array of points (with simulated pressure) between two points.
   *
   * @param A - The first point.
   * @param B - The second point.
   * @param steps - The number of points to return.
   */
  static PointsBetween(l, i, s = 6) {
    const c = [];
    for (let W = 0; W < s; W++) {
      const h = Os.easeInQuad(W / (s - 1)), e = Wi.Lrp(l, i, h);
      e.z = Math.min(1, 0.5 + Math.abs(0.5 - Ds(h)) * 0.65), c.push(e);
    }
    return c;
  }
  static SnapToGrid(l, i = 8) {
    return new Wi(Math.round(l.x / i) * i, Math.round(l.y / i) * i);
  }
}
const Ds = (Z) => Z < 0.5 ? 2 * Z * Z : -1 + (4 - 2 * Z) * Z;
class Hi extends Wi {
  constructor(l = 0, i = 0, s = 0, c = { x: 0, y: 0 }, W = 0, h = 0) {
    super(l, i, s), Object.defineProperty(this, "x", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: l
    }), Object.defineProperty(this, "y", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: i
    }), Object.defineProperty(this, "z", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: s
    }), Object.defineProperty(this, "v", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: c
    }), Object.defineProperty(this, "t", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: W
    }), Object.defineProperty(this, "a", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: h
    });
  }
  get timestamp() {
    return this.t;
  }
  get pressure() {
    return this.z;
  }
  get angleNum() {
    return this.a;
  }
  get XY() {
    return [this.x, this.y];
  }
  setA(l) {
    this.a = l;
  }
  setT(l) {
    this.t = l;
  }
  setv(l) {
    return this.v = { x: l.x, y: l.y }, this;
  }
  set(l = this.x, i = this.y, s = this.z, c = this.v, W = this.t, h = this.a) {
    return this.x = l, this.y = i, this.z = s, this.v = c, this.t = W, this.a = h, this;
  }
  clone() {
    const { x: l, y: i, z: s, v: c, t: W, a: h } = this, e = { x: c.x, y: c.y };
    return new Hi(l, i, s, e, W, h);
  }
  distance(l) {
    return Hi.GetDistance(this, l);
  }
  isNear(l, i) {
    return Hi.IsNear(this, l, i);
  }
  getAngleByPoints(l, i) {
    return Hi.GetAngleByPoints(l, this, i);
  }
  static Sub(l, i) {
    return new Hi(l.x - i.x, l.y - i.y);
  }
  static Add(l, i) {
    return new Hi(l.x + i.x, l.y + i.y);
  }
  static GetDistance(l, i) {
    return Hi.Len(l.clone().sub(i));
  }
  static GetAngleByPoints(l, i, s) {
    const c = i.x - l.x, W = s.x - i.x, h = i.y - l.y, e = s.y - i.y;
    let a = 0;
    const G = Math.sqrt(c * c + h * h), y = Math.sqrt(W * W + e * e);
    if (G && y) {
      const n = c * W + h * e;
      a = Math.acos(n / (G * y)), a = a / Math.PI * 180;
      let V = c * e - h * W;
      V = V > 0 ? 1 : -1, a = 180 + V * a;
    }
    return a;
  }
  static IsNear(l, i, s) {
    return Hi.Len(l.clone().sub(i)) < s;
  }
  static RotWith(l, i, s, c = 2) {
    const W = l.x - i.x, h = l.y - i.y, e = Math.sin(s), a = Math.cos(s), G = Math.pow(10, c), y = Math.floor((i.x + (W * a - h * e)) * G) / G, n = Math.floor((i.y + (W * e + h * a)) * G) / G;
    return new Hi(y, n);
  }
  /**
   * 根据圆心和半径，获取圆上的等份点
   * @param o 圆心
   * @param radius 半径
   * @param average 均分数
   * @returns
   */
  static GetDotStroke(l, i, s = 16) {
    const c = new Wi(1, 1), W = Math.PI + 1e-3, h = Hi.Add(l, Hi.Sub(l, c).uni().per().mul(-i)), e = [];
    for (let a = 1 / s, G = a; G <= 1; G += a)
      e.push(Hi.RotWith(h, l, W * 2 * G));
    return e;
  }
  /**
   * 根据圆心和园上的起始点，获取半圆上的等份点
   * @param o 圆心
   * @param p 圆弧起始点
   * @param radian 1，逆时针180度 -1，顺时针
   * @param average 均分数
   * @returns
   */
  static GetSemicircleStroke(l, i, s = -1, c = 8) {
    const W = s * (Math.PI + 1e-3), h = [];
    for (let e = 1 / c, a = e; a <= 1; a += e)
      h.push(Hi.RotWith(i, l, W * a));
    return h;
  }
}
function Ei(Z, l) {
  if (Z && l) {
    const i = Math.min(Z == null ? void 0 : Z.x, l.x), s = Math.min(Z == null ? void 0 : Z.y, l.y), c = Math.max(Z.x + Z.w, l.x + l.w), W = Math.max(Z.y + Z.h, l.y + l.h), h = c - i, e = W - s;
    return { x: i, y: s, w: h, h: e };
  }
  return l || Z;
}
function As(Z, l = 0) {
  const i = { x: 0, y: 0, w: 0, h: 0 };
  let s = 1 / 0, c = 1 / 0, W = -1 / 0, h = -1 / 0;
  return Z.forEach((e) => {
    const [a, G] = e.XY;
    s = Math.min(s, a - l), c = Math.min(c, G - l), W = Math.max(W, a + l), h = Math.max(h, G + l);
  }), i.x = s, i.y = c, i.w = W - s, i.h = h - c, i;
}
function qs(Z, l) {
  return !(Z.x + Z.w < l.x || Z.x > l.x + l.w || Z.y + Z.h < l.y || Z.y > l.y + l.h);
}
function $s(Z, l) {
  return Z.length === l.length && Z.sort().toString() === l.sort().toString();
}
function Gd(Z, l) {
  let i;
  return l == null || l.getElementsByName(Z).forEach((s) => {
    if (s.tagName === "PATH") {
      const c = s == null ? void 0 : s.getBoundingClientRect();
      c && (i = Ei(i, {
        x: Math.floor(c.x),
        y: Math.floor(c.y),
        w: Math.round(c.width),
        h: Math.round(c.height)
      }));
    } else if (s.tagName === "GROUP") {
      const c = s.className.split(",");
      if (c.length === 3 && Number(c[2]) === Oi.Stroke) {
        const W = s == null ? void 0 : s.getBoundingClientRect();
        W && (i = Ei(i, {
          x: Math.floor(W.x),
          y: Math.floor(W.y),
          w: Math.round(W.width),
          h: Math.round(W.height)
        }));
      } else
        s.children.forEach((W) => {
          if (W.tagName === "PATH") {
            const h = W == null ? void 0 : W.getBoundingClientRect();
            h && (i = Ei(i, {
              x: Math.floor(h.x),
              y: Math.floor(h.y),
              w: Math.round(h.width),
              h: Math.round(h.height)
            }));
          }
        });
    }
  }), i;
}
function bs(Z) {
  return JSON.parse(zs(Z));
}
function cs(Z) {
  return Ms(JSON.stringify(Z));
}
const Ml = Object.keys;
function ql(Z, l, i) {
  return "#" + ((Z << 16) + (l << 8) + i).toString(16).padStart(6, "0");
}
function Il(Z, l = 1) {
  return "rgba(" + parseInt("0x" + Z.slice(1, 3)) + "," + parseInt("0x" + Z.slice(3, 5)) + "," + parseInt("0x" + Z.slice(5, 7)) + "," + l + ")";
}
function _s(Z) {
  const l = Z.split(","), i = parseInt(l[0].split("(")[1]), s = parseInt(l[1]), c = parseInt(l[2]), W = parseInt(l[3].split(")")[0]);
  return [ql(i, s, c), W];
}
class Li extends js {
  updataOptService() {
  }
  constructor(l, i, s) {
    super(i, s), Object.defineProperty(this, "tmpPoints", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "toolsType", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: Yi.Selector
    }), Object.defineProperty(this, "workOptions", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "syncTimestamp", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "curNodeMap", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: /* @__PURE__ */ new Map()
    }), Object.defineProperty(this, "selectIds", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "oldRect", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "nodeColor", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "oldSelectRect", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "worldPosition", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "worldScaling", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.workOptions = l, this.syncTimestamp = 0, this.worldPosition = this.fullLayer.worldPosition, this.worldScaling = this.fullLayer.worldScaling;
  }
  computNodeMap(l) {
    this.curNodeMap.clear(), l.forEach((i) => {
      const s = this.fullLayer.getElementsByName(i.name)[0];
      if (s) {
        const c = s.worldPosition;
        let W = s.getAttribute("strokeColor");
        const h = s.className.split(",");
        s.tagName === "GROUP" && (Number(h[2]) === Oi.Stroke ? W = s.getAttribute("bgcolor") : W = s.children[0].getAttribute("strokeColor")), this.curNodeMap.set(i.name, {
          name: i.name,
          rect: i.rect,
          color: _s(W)[0],
          pos: c,
          rotate: s.getAttribute("rotate") || 0,
          scale: s.getAttribute("scale") || [1, 1]
        });
      }
    });
  }
  computSelector() {
    let l;
    const i = [], s = /* @__PURE__ */ new Map(), c = /* @__PURE__ */ new Set(), W = /* @__PURE__ */ new Map();
    if (this.tmpPoints.length && this.curNodeMap.size) {
      const h = As(this.tmpPoints);
      this.curNodeMap.forEach((e, a) => {
        const G = {
          x: e.rect.x,
          y: e.rect.y,
          w: e.rect.w,
          h: e.rect.h
        }, y = {
          x: h.x,
          y: h.y,
          w: h.w,
          h: h.h
        };
        qs(y, G) && (i.push(a), l = Ei(l, G), s.set(a, G), c.add(e.color), W.set(a, [...e.pos, e.rotate]));
      });
    }
    return {
      selectIds: i,
      intersectRect: l,
      subRects: s,
      nodeColors: c,
      subPos: W
    };
  }
  updateTempPoints(l) {
    const i = this.tmpPoints.length, s = l.length;
    if (s > 1) {
      const c = new Hi(l[s - 2] * this.worldScaling[0] + this.worldPosition[0], l[s - 1] * this.worldScaling[0] + this.worldPosition[1]);
      i === 2 ? this.tmpPoints.splice(1, 1, c) : this.tmpPoints.push(c);
    }
  }
  draw(l) {
    var W, h, e;
    const { intersectRect: i, subRects: s, subPos: c } = l;
    (e = (h = (W = this.drawLayer) == null ? void 0 : W.parent) == null ? void 0 : h.getElementById(Li.selectorId)) == null || e.remove(), i && this.drawLayer && this.drawSelector({
      drawRect: i,
      subRects: s,
      subPos: c,
      selectorId: Li.selectorId,
      layer: this.drawLayer
    });
  }
  consume(l) {
    const { op: i, workState: s } = l.data;
    if (s === pi.Start && (this.oldRect = this.backToFullLayer(), l.nodeMaps && this.computNodeMap(l.nodeMaps)), !(i != null && i.length) || !this.curNodeMap.size)
      return { type: hi.None };
    this.updateTempPoints(i);
    const c = this.computSelector();
    if (this.selectIds && $s(this.selectIds, c.selectIds))
      return { type: hi.None };
    this.selectIds = c.selectIds;
    const W = this.drawLayer && this.getSelectorRect(this.drawLayer, Li.selectorId, !0), h = c.intersectRect && {
      x: c.intersectRect.x - Li.SelectBorderPadding,
      y: c.intersectRect.y - Li.SelectBorderPadding,
      w: c.intersectRect.w + Li.SelectBorderPadding * 2,
      h: c.intersectRect.h + Li.SelectBorderPadding * 2
    } || void 0;
    return this.oldRect = Ei(W, h), this.draw(c), this.nodeColor = c.nodeColors.size === 1 ? c.nodeColors.values().next().value : void 0, this.oldSelectRect = h, {
      type: hi.Select,
      dataType: Ji.Local,
      rect: this.oldRect,
      selectIds: c.selectIds,
      opt: this.workOptions,
      padding: Li.SelectBorderPadding,
      selectRect: h,
      nodeColor: this.nodeColor,
      willSyncService: !0
    };
  }
  consumeAll() {
    var l;
    return (l = this.selectIds) != null && l.length && this.sealToDrawLayer(), this.oldSelectRect ? {
      type: hi.Select,
      dataType: Ji.Local,
      rect: this.oldRect,
      selectIds: this.selectIds,
      opt: this.workOptions,
      padding: Li.SelectBorderPadding,
      selectRect: this.oldSelectRect,
      nodeColor: this.nodeColor,
      willSyncService: !1
    } : {
      type: hi.None
    };
  }
  consumeService() {
  }
  combineConsume() {
  }
  clearTmpPoints() {
    this.tmpPoints.length = 0;
  }
  clearSelectData() {
    this.selectIds = void 0, this.oldRect = void 0, this.oldSelectRect = void 0;
  }
  backToFullLayer() {
    var c;
    let l;
    const i = [], s = [];
    return (c = this.drawLayer) == null || c.children.forEach((W) => {
      if (W.id !== Li.selectorId) {
        const h = W.cloneNode(!0);
        if (h.tagName === "GROUP") {
          const a = W.className.split(",");
          a.length === 3 && Number(a[2]) === Oi.Stroke && h.seal();
        }
        i.push(h), s.push(W);
        const e = Gd(W.name, this.drawLayer);
        e && (l = Ei(l, e));
      }
    }), s.forEach((W) => W.remove()), i.length && this.fullLayer.append(...i), l && (l.x -= Li.SelectBorderPadding, l.y -= Li.SelectBorderPadding, l.w += Li.SelectBorderPadding * 2, l.h += Li.SelectBorderPadding * 2), l;
  }
  sealToDrawLayer() {
    var s, c;
    const l = [], i = [];
    (s = this.selectIds) == null || s.forEach((W) => {
      this.fullLayer.getElementsByName(W.toString()).forEach((h) => {
        const e = h.cloneNode(!0);
        if (e.tagName === "GROUP") {
          const a = h.className.split(",");
          a.length === 3 && Number(a[2]) === Oi.Stroke && e.seal();
        }
        l.push(e), i.push(h);
      });
    }), i.forEach((W) => W.remove()), l && ((c = this.drawLayer) == null || c.append(...l));
  }
  updateSelectorSize(l, i, s) {
    const c = /* @__PURE__ */ new Map(), W = l.getAttribute("pos"), h = l.className.split(","), e = i - Li.SelectBorderPadding * 2, a = s - Li.SelectBorderPadding * 2, G = h.length === 2 && [e / Number(h[0]), a / Number(h[1])] || [1, 1];
    return l.setAttribute("size", [e, a]), l.children.forEach((y) => {
      if (y.id === Li.selectorBorderId)
        y.setAttribute("pos", [e / 2, a / 2]), y.setAttribute("width", e), y.setAttribute("height", a);
      else if (G) {
        const n = y.className.split(","), V = [Number(n[0]) * G[0], Number(n[1]) * G[1]], I = y.getAttribute("width"), r = y.getAttribute("height"), p = Number(n[2]) * G[0], o = Number(n[3]) * G[1];
        y.setAttribute("pos", V), y.setAttribute("width", p), y.setAttribute("height", o);
        const u = y.id.split("selector-")[1];
        if (u) {
          const d = [V[0] + W[0], V[1] + W[1]], b = [
            p / I,
            o / r
          ];
          c.set(u, [
            d[0],
            d[1],
            b[0],
            b[1]
          ]);
        }
      }
    }), c;
  }
  updateSelectorRect(l, i) {
    const { w: s, h: c, x: W, y: h } = i, e = s - Li.SelectBorderPadding * 2, a = c - Li.SelectBorderPadding * 2, G = W + Li.SelectBorderPadding, y = h + Li.SelectBorderPadding;
    l.setAttribute("size", [s, c]), l.setAttribute("pos", [G, y]), l.setAttribute("className", `${i.w},${i.h}`), l.children.forEach((n) => {
      if (n.setAttribute("pos", [e / 2, a / 2]), n.setAttribute("width", e), n.setAttribute("height", a), n.id === Li.selectorBorderId)
        n.setAttribute("className", `${i.w / 2},${i.h / 2},${i.w},${i.h}`);
      else {
        const V = n.className.split(","), I = V && Number(V[4]) || 0;
        n.setAttribute("className", `${e / 2},${a / 2},${i.w},${i.h},${I}`);
      }
    });
  }
  getSelectorRect(l, i, s) {
    var a;
    let c;
    const W = (a = l.parent) == null ? void 0 : a.getElementById(i), h = W == null ? void 0 : W.getElementById(Li.selectorBorderId), e = h == null ? void 0 : h.getBoundingClientRect();
    return e && (c = Ei(c, {
      x: Math.floor(e.x),
      y: Math.floor(e.y),
      w: Math.round(e.width),
      h: Math.round(e.height)
    })), c && s ? {
      x: c.x - Li.SelectBorderPadding,
      y: c.y - Li.SelectBorderPadding,
      w: c.w + Li.SelectBorderPadding * 2,
      h: c.h + Li.SelectBorderPadding * 2
    } : c;
  }
  updateSelector(l) {
    var a, G, y;
    const { updateSelectorOpt: i, selectIds: s } = l;
    let c;
    const W = /* @__PURE__ */ new Map();
    let h;
    const e = (G = (a = this.drawLayer) == null ? void 0 : a.parent) == null ? void 0 : G.getElementById(Li.selectorId);
    if (e) {
      let n;
      if (i.pos) {
        const V = [
          i.pos[0] * this.worldScaling[0] + this.worldPosition[0],
          i.pos[1] * this.worldScaling[1] + this.worldPosition[1]
        ], I = e.getAttribute("pos");
        n = [V[0] - I[0], V[1] - I[1]], e.setAttribute("pos", V);
      }
      if (i.selectorColor && ((y = e.getElementById(Li.selectorBorderId)) == null || y.setAttribute("strokeColor", i.selectorColor)), i.size && (h = this.updateSelectorSize(e, i.size.width, i.size.height)), i.angle)
        s == null || s.forEach((V) => {
          var I;
          (I = this.drawLayer) == null || I.getElementsByName(V).forEach((r) => {
            if (r) {
              const p = {
                useAnimation: !1
              };
              i.angle && (p.angle = i.angle, p.originPos = r.className.split(",").map((u) => Number(u)), r.setAttribute("rotate", p.angle)), W.set(r.name, p);
              const o = Gd(r.name, this.drawLayer);
              c = Ei(c, o);
            }
          });
        }, this);
      else {
        s == null || s.forEach((r) => {
          var p;
          (p = this.drawLayer) == null || p.getElementsByName(r).forEach((o) => {
            if (o) {
              const u = {
                useAnimation: !1
              };
              if (i.pos && n) {
                const b = o.getAttribute("pos");
                u.pos = [n[0] / this.worldScaling[0] + b[0], n[1] / this.worldScaling[0] + b[1]], u.originPos = o.className.split(",").map((t) => Number(t)), o.setAttribute("pos", u.pos);
              }
              if (i.zIndexDistance || i.zIndex) {
                if (i.zIndexDistance) {
                  const b = o.getAttribute("zIndex");
                  u.zIndex = b + i.zIndexDistance;
                } else
                  u.zIndex = i.zIndex;
                o.setAttribute("zIndex", u.zIndex);
              }
              if (i.color) {
                u.color = i.color;
                const b = o.className.split(",");
                o.tagName === "GROUP" ? Number(b[2]) === Oi.Stroke ? o.setAttribute("bgcolor", u.color) : o.children.forEach((t) => {
                  t.setAttribute("strokeColor", u.color);
                }) : o.tagName === "PATH" && (o.setAttribute("strokeColor", u.color), o.getAttribute("fillColor") && o.setAttribute("fillColor", u.color));
              }
              i.opacity && (u.opacity = i.opacity, o.setAttribute("opacity", u.opacity));
              const d = h == null ? void 0 : h.get(o.name);
              if (d) {
                const b = o.getAttribute("scale"), t = [
                  d[2] * b[0],
                  d[3] * b[1]
                ];
                u.originPos = o.className.split(",").map((m) => Number(m)), u.pos = [(d[0] - this.worldPosition[0]) / this.worldScaling[0], (d[1] - this.worldPosition[1]) / this.worldScaling[1]], u.scale = t, o.setAttribute("pos", u.pos), o.setAttribute("scale", u.scale);
              }
              W.set(o.name, u);
            }
          });
        }, this);
        const V = e.getElementById(Li.selectorBorderId), I = V == null ? void 0 : V.getBoundingClientRect();
        I && (c = Ei(c, {
          x: Math.floor(I.x),
          y: Math.floor(I.y),
          w: Math.round(I.width),
          h: Math.round(I.height)
        }));
      }
    }
    if (c)
      return c.x -= Li.SelectBorderPadding, c.y -= Li.SelectBorderPadding, c.w += Li.SelectBorderPadding * 2, c.h += Li.SelectBorderPadding * 2, i.angle && this.updateSelectorRect(e, c), this.oldRect = Ei(this.oldRect, c), this.oldSelectRect = c, {
        type: hi.UpdateNode,
        dataType: Ji.Local,
        rect: c,
        updateNodeOpts: W
      };
  }
  blurSelector() {
    const l = this.backToFullLayer();
    return {
      type: hi.Select,
      dataType: Ji.Local,
      rect: l,
      selectIds: [],
      willSyncService: !0
    };
  }
  getRightServiceId(l) {
    return l.replace("++++", "-");
  }
  drawSelector(l) {
    const { drawRect: i, subRects: s, subPos: c, selectorId: W, layer: h } = l, e = new Bs({
      pos: [i.x, i.y],
      anchor: [0, 0],
      size: [i.w, i.h],
      className: `${i.w},${i.h}`,
      id: W,
      name: Li.selectorId,
      zIndex: 1e3
    }), a = [], G = new Wd({
      normalize: !0,
      pos: [i.w / 2, i.h / 2],
      lineWidth: 1,
      strokeColor: this.workOptions.color,
      width: i.w,
      height: i.h,
      className: `${i.w / 2},${i.h / 2},${i.w},${i.h}`,
      id: Li.selectorBorderId
    });
    a.push(G), s.forEach((y, n) => {
      const V = c == null ? void 0 : c.get(n);
      if (V) {
        const I = [V[0] - i.x, V[1] - i.y], r = `${I[0]},${I[1]},${y.w},${y.h},${V[2]}`, p = new Wd({
          normalize: !0,
          pos: I,
          lineWidth: 1,
          strokeColor: s.size > 1 ? this.workOptions.color : void 0,
          width: y.w,
          height: y.h,
          className: r,
          id: `selector-${n}`,
          name: `selector-${n}`
        });
        a.push(p);
      }
    }), a && e.append(...a), (h == null ? void 0 : h.parent).appendChild(e);
  }
  selectServiceNode(l, i, s) {
    var y;
    const { selectIds: c } = i, W = this.getRightServiceId(l), h = this.getSelectorRect(this.fullLayer, W, !0);
    (y = this.fullLayer.parent.getElementById(W)) == null || y.remove();
    let e;
    const a = /* @__PURE__ */ new Map(), G = /* @__PURE__ */ new Map();
    return c == null || c.forEach((n) => {
      var r;
      const V = s.get(n), I = this.fullLayer.getElementsByName(n)[0];
      if (V && I) {
        e = Ei(e, V.rect), a.set(n, V.rect);
        const p = I.worldPosition, o = ((r = V.opt) == null ? void 0 : r.rotate) || I.getAttribute("rotate") || 0;
        G.set(n, [...p, o]);
      }
    }), e && this.fullLayer && this.drawSelector({
      drawRect: e,
      subRects: a,
      subPos: G,
      selectorId: W,
      layer: this.fullLayer
    }), e = Ei(e, h), e && (e.x -= Li.SelectBorderPadding, e.y -= Li.SelectBorderPadding, e.w += Li.SelectBorderPadding * 2, e.h += Li.SelectBorderPadding * 2), e;
  }
  removeService() {
    throw new Error("Method not implemented.");
  }
  getSelector(l) {
    var W;
    let i;
    const s = /* @__PURE__ */ new Map(), c = /* @__PURE__ */ new Map();
    return (W = this.selectIds) == null || W.forEach((h) => {
      var G;
      const e = l.get(h), a = (G = this.drawLayer) == null ? void 0 : G.getElementsByName(h)[0];
      if (e && a) {
        const y = a.worldPosition, n = a.getAttribute("rotate") || 0;
        i = Ei(i, e.rect), s.set(h, e.rect), c.set(h, [...y, n]);
      }
    }, this), this.oldRect = Ei(i, this.oldRect), this.draw({
      intersectRect: i,
      subRects: s,
      subPos: c
    }), this.oldSelectRect = i, i;
  }
}
Object.defineProperty(Li, "selectorId", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "selector"
});
Object.defineProperty(Li, "selectorBorderId", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "selector-border"
});
Object.defineProperty(Li, "SelectBorderPadding", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 2
});
class it {
  constructor(l, i) {
    Object.defineProperty(this, "collector", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "displayer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "dustbin", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: /* @__PURE__ */ new Set()
    }), this.displayer = l, this.collector = i;
  }
  /** 设置当前选中的工具配置数据 */
  setCurrentToolsData(l) {
    this.currentToolsData = l;
  }
  /** 设置当前绘制任务数据 */
  setCurrentLocalWorkData(l) {
    this.currentLocalWorkData = l;
  }
  /** 设置相机参数 */
  setCameraOpt(l) {
    this.cameraOpt = l;
  }
  /** 获取当前绘制任务id */
  getWorkId() {
    return this.currentLocalWorkData.workId;
  }
}
const Zs = "dmFyIHFlPU9iamVjdC5kZWZpbmVQcm9wZXJ0eTt2YXIga2U9KFN0LCR0LEF0KT0+JHQgaW4gU3Q/cWUoU3QsJHQse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOkF0fSk6U3RbJHRdPUF0O3ZhciBIdD0oU3QsJHQsQXQpPT4oa2UoU3QsdHlwZW9mICR0IT0ic3ltYm9sIj8kdCsiIjokdCxBdCksQXQpOyhmdW5jdGlvbigpeyJ1c2Ugc3RyaWN0Ijt2YXIgU3Q7KGZ1bmN0aW9uKFMpe1NbUy5QZW5jaWw9MV09IlBlbmNpbCIsU1tTLkVyYXNlcj0yXT0iRXJhc2VyIixTW1MuU2VsZWN0b3I9M109IlNlbGVjdG9yIixTW1MuQ2xpY2tlcj00XT0iQ2xpY2tlciIsU1tTLkFycm93PTVdPSJBcnJvdyIsU1tTLkhhbmQ9Nl09IkhhbmQiLFNbUy5MYXNlclBlbj03XT0iTGFzZXJQZW4ifSkoU3R8fChTdD17fSkpO3ZhciAkdDsoZnVuY3Rpb24oUyl7U1tTLlBhdGg9MF09IlBhdGgiLFNbUy5SZWN0PTFdPSJSZWN0In0pKCR0fHwoJHQ9e30pKTt2YXIgQXQ7KGZ1bmN0aW9uKFMpe1NbUy5Mb2NhbD0xXT0iTG9jYWwiLFNbUy5TZXJ2aWNlPTJdPSJTZXJ2aWNlIn0pKEF0fHwoQXQ9e30pKTt2YXIgd3Q7KGZ1bmN0aW9uKFMpe1NbUy5QZW5kaW5nPTBdPSJQZW5kaW5nIixTW1MuU3RhcnQ9MV09IlN0YXJ0IixTW1MuRG9pbmc9Ml09IkRvaW5nIixTW1MuRG9uZT0zXT0iRG9uZSIsU1tTLkZyZWV6ZT00XT0iRnJlZXplIixTW1MuVW53cml0YWJsZT01XT0iVW53cml0YWJsZSJ9KSh3dHx8KHd0PXt9KSk7dmFyIHB0OyhmdW5jdGlvbihTKXtTW1MuSW5pdD0wXT0iSW5pdCIsU1tTLlVwZGF0ZUNhbWVyYT0xXT0iVXBkYXRlQ2FtZXJhIixTW1MuVXBkYXRlVG9vbHM9Ml09IlVwZGF0ZVRvb2xzIixTW1MuVXBkYXRlU2NlbmU9M109IlVwZGF0ZVNjZW5lIixTW1MuQ3JlYXRlV29yaz00XT0iQ3JlYXRlV29yayIsU1tTLkRyYXdXb3JrPTVdPSJEcmF3V29yayIsU1tTLkZ1bGxXb3JrPTZdPSJGdWxsV29yayIsU1tTLlVwZGF0ZVdvcms9N109IlVwZGF0ZVdvcmsiLFNbUy5VcGRhdGVOb2RlPThdPSJVcGRhdGVOb2RlIixTW1MuUmVtb3ZlTm9kZT05XT0iUmVtb3ZlTm9kZSIsU1tTLkNsZWFyPTEwXT0iQ2xlYXIiLFNbUy5TZWxlY3Q9MTFdPSJTZWxlY3QiLFNbUy5EZXN0cm95PTEyXT0iRGVzdHJveSIsU1tTLk5vbmU9MTNdPSJOb25lIixTW1MuQ29tYmluZURyYXc9MTRdPSJDb21iaW5lRHJhdyJ9KShwdHx8KHB0PXt9KSk7dmFyIGhlOyhmdW5jdGlvbihTKXtTW1MuUGF0aD0wXT0iUGF0aCIsU1tTLlJlY3Q9MV09IlJlY3QiLFNbUy5UZXh0dXJlPTJdPSJUZXh0dXJlIn0pKGhlfHwoaGU9e30pKTt2YXIgZGU7KGZ1bmN0aW9uKFMpe1MuV2ViZ2wyPSJ3ZWJnbDIiLFMuV2ViZ2w9IndlYmdsIixTLkNhbnZhczJkPSIyZCJ9KShkZXx8KGRlPXt9KSk7dmFyIHl0OyhmdW5jdGlvbihTKXtTW1MuRmxvYXQ9MV09IkZsb2F0IixTW1MuQmc9Ml09IkJnIixTW1MuU2VsZWN0b3I9M109IlNlbGVjdG9yIn0pKHl0fHwoeXQ9e30pKTt2YXIgZ2U7KGZ1bmN0aW9uKFMpe1MuTFQ9InRvcExlZnQiLFMuTEM9ImxlZnQiLFMuTEI9ImJvdHRvbUxlZnQiLFMuVEM9InRvcCIsUy5SVD0idG9wUmlnaHQiLFMuUkM9InJpZ2h0IixTLlJCPSJib3R0b21SaWdodCIsUy5CQz0iYm90dG9tIn0pKGdlfHwoZ2U9e30pKTtjbGFzcyBlZXtjb25zdHJ1Y3RvcihlLHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzeW5jVW5pdFRpbWUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZToxZTN9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiZHJhd0xheWVyIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImZ1bGxMYXllciIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ3b3JrSWQiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSx0aGlzLmZ1bGxMYXllcj1lLHRoaXMuZHJhd0xheWVyPXR9c2V0V29ya0lkKGUpe3RoaXMud29ya0lkPWV9Z2V0V29ya0lkKCl7cmV0dXJuIHRoaXMud29ya0lkfWdldFdvcmtPcHRpb25zKCl7cmV0dXJuIHRoaXMud29ya09wdGlvbnN9c2V0V29ya09wdGlvbnMoZSl7dGhpcy53b3JrT3B0aW9ucz1lLHRoaXMuc3luY1VuaXRUaW1lPWUuc3luY1VuaXRUaW1lfHx0aGlzLnN5bmNVbml0VGltZX19dmFyIGJ0PWZ1bmN0aW9uKFMpe3ZhciBlPXt9O2Z1bmN0aW9uIHQocil7aWYoZVtyXSlyZXR1cm4gZVtyXS5leHBvcnRzO3ZhciBpPWVbcl09e2k6cixsOiExLGV4cG9ydHM6e319O3JldHVybiBTW3JdLmNhbGwoaS5leHBvcnRzLGksaS5leHBvcnRzLHQpLGkubD0hMCxpLmV4cG9ydHN9cmV0dXJuIHQubT1TLHQuYz1lLHQuZD1mdW5jdGlvbihyLGksaCl7dC5vKHIsaSl8fE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyLGkse2VudW1lcmFibGU6ITAsZ2V0Omh9KX0sdC5yPWZ1bmN0aW9uKHIpe3R5cGVvZiBTeW1ib2w8InUiJiZTeW1ib2wudG9TdHJpbmdUYWcmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eShyLFN5bWJvbC50b1N0cmluZ1RhZyx7dmFsdWU6Ik1vZHVsZSJ9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkociwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSl9LHQudD1mdW5jdGlvbihyLGkpe2lmKGkmMSYmKHI9dChyKSksaSY4fHxpJjQmJnR5cGVvZiByPT0ib2JqZWN0IiYmciYmci5fX2VzTW9kdWxlKXJldHVybiByO3ZhciBoPU9iamVjdC5jcmVhdGUobnVsbCk7aWYodC5yKGgpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShoLCJkZWZhdWx0Iix7ZW51bWVyYWJsZTohMCx2YWx1ZTpyfSksaSYyJiZ0eXBlb2YgciE9InN0cmluZyIpZm9yKHZhciBnIGluIHIpdC5kKGgsZywoZnVuY3Rpb24odSl7cmV0dXJuIHJbdV19KS5iaW5kKG51bGwsZykpO3JldHVybiBofSx0Lm49ZnVuY3Rpb24ocil7dmFyIGk9ciYmci5fX2VzTW9kdWxlP2Z1bmN0aW9uKCl7cmV0dXJuIHIuZGVmYXVsdH06ZnVuY3Rpb24oKXtyZXR1cm4gcn07cmV0dXJuIHQuZChpLCJhIixpKSxpfSx0Lm89ZnVuY3Rpb24ocixpKXtyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHIsaSl9LHQucD0iL2pzLyIsdCh0LnM9MCl9KFtmdW5jdGlvbihTLGUsdCl7dC5yKGUpLHQuZChlLCJ2ZXJzaW9uIixmdW5jdGlvbigpe3JldHVybiBIfSksdC5kKGUsImhlbHBlcnMiLGZ1bmN0aW9uKCl7cmV0dXJuIGp9KSx0LmQoZSwiY3JlYXRlRWxlbWVudCIsZnVuY3Rpb24oKXtyZXR1cm4gRH0pLHQuZChlLCJpc1Nwcml0ZU5vZGUiLGZ1bmN0aW9uKCl7cmV0dXJuIFJ9KSx0LmQoZSwicmVnaXN0ZXJOb2RlIixmdW5jdGlvbigpe3JldHVybiBBfSk7dmFyIHI9dCgxMik7dC5kKGUsIkVOViIsZnVuY3Rpb24oKXtyZXR1cm4gci5FTlZ9KTt2YXIgaT10KDY4KTt0LmQoZSwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIixmdW5jdGlvbigpe3JldHVybiBpLnJlcXVlc3RBbmltYXRpb25GcmFtZX0pLHQuZChlLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsZnVuY3Rpb24oKXtyZXR1cm4gaS5jYW5jZWxBbmltYXRpb25GcmFtZX0pO3ZhciBoPXQoNzApO3QuZChlLCJOb2RlIixmdW5jdGlvbigpe3JldHVybiBoLmRlZmF1bHR9KTt2YXIgZz10KDIxNyk7dC5kKGUsIkNsb3VkIixmdW5jdGlvbigpe3JldHVybiBnLmRlZmF1bHR9KTt2YXIgdT10KDIxOSk7dC5kKGUsIkJsb2NrIixmdW5jdGlvbigpe3JldHVybiB1LmRlZmF1bHR9KTt2YXIgYT10KDIyNCk7dC5kKGUsIlNwcml0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gYS5kZWZhdWx0fSk7dmFyIGM9dCgyMjYpO3QuZChlLCJQYXRoIixmdW5jdGlvbigpe3JldHVybiBjLmRlZmF1bHR9KTt2YXIgeD10KDIyOSk7dC5kKGUsIlJlY3QiLGZ1bmN0aW9uKCl7cmV0dXJuIHguZGVmYXVsdH0pO3ZhciBmPXQoMjMxKTt0LmQoZSwiVHJpYW5nbGUiLGZ1bmN0aW9uKCl7cmV0dXJuIGYuZGVmYXVsdH0pO3ZhciB2PXQoMjM2KTt0LmQoZSwiUGFyYWxsZWwiLGZ1bmN0aW9uKCl7cmV0dXJuIHYuZGVmYXVsdH0pO3ZhciBwPXQoMjM4KTt0LmQoZSwiUmVndWxhciIsZnVuY3Rpb24oKXtyZXR1cm4gcC5kZWZhdWx0fSk7dmFyIEM9dCgyNDApO3QuZChlLCJTdGFyIixmdW5jdGlvbigpe3JldHVybiBDLmRlZmF1bHR9KTt2YXIgTT10KDI0Mik7dC5kKGUsIkVsbGlwc2UiLGZ1bmN0aW9uKCl7cmV0dXJuIE0uZGVmYXVsdH0pO3ZhciBtPXQoMjQ0KTt0LmQoZSwiQXJjIixmdW5jdGlvbigpe3JldHVybiBtLmRlZmF1bHR9KTt2YXIgeT10KDI0Nik7dC5kKGUsIlJpbmciLGZ1bmN0aW9uKCl7cmV0dXJuIHkuZGVmYXVsdH0pO3ZhciBuPXQoMjMyKTt0LmQoZSwiUG9seWxpbmUiLGZ1bmN0aW9uKCl7cmV0dXJuIG4uZGVmYXVsdH0pO3ZhciBvPXQoMjQ4KTt0LmQoZSwiTGFiZWwiLGZ1bmN0aW9uKCl7cmV0dXJuIG8uZGVmYXVsdH0pO3ZhciBzPXQoMjUwKTt0LmQoZSwiR3JvdXAiLGZ1bmN0aW9uKCl7cmV0dXJuIHMuZGVmYXVsdH0pO3ZhciBsPXQoMjg2KTt0LmQoZSwiTGF5ZXIiLGZ1bmN0aW9uKCl7cmV0dXJuIGwuZGVmYXVsdH0pO3ZhciBFPXQoMjg3KTt0LmQoZSwiU3ByaXRlU3ZnIixmdW5jdGlvbigpe3JldHVybiBFLmRlZmF1bHR9KTt2YXIgVD10KDI4OSk7dC5kKGUsIkxheWVyV29ya2VyIixmdW5jdGlvbigpe3JldHVybiBULmRlZmF1bHR9KTt2YXIgYj10KDI5MCk7dC5kKGUsIlNjZW5lIixmdW5jdGlvbigpe3JldHVybiBiLmRlZmF1bHR9KTt2YXIgST10KDIxMyksUD10KDIyMSk7dC5kKGUsIkNvbG9yIixmdW5jdGlvbigpe3JldHVybiBQLkNvbG9yfSksdC5kKGUsIkdyYWRpZW50IixmdW5jdGlvbigpe3JldHVybiBQLkdyYWRpZW50fSk7dmFyIEw9dCg3Mik7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IEQ9SS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQsUj1JLmRlZmF1bHQuaXNTcHJpdGVOb2RlLEE9SS5kZWZhdWx0LnJlZ2lzdGVyTm9kZSxqPXtwYXJzZUNvbG9yOlAucGFyc2VDb2xvcixzaXplVG9QaXhlbDpMLnNpemVUb1BpeGVsLHRvQXJyYXk6TC50b0FycmF5LHRvU3RyaW5nOkwudG9TdHJpbmcsdG9OdW1iZXI6TC50b051bWJlcn07bGV0IEc7Rz0iMy44LjMiO2NvbnN0IEg9R30sZnVuY3Rpb24oUyxlLHQpe3QucihlKTt2YXIgcj10KDIpO3QuZChlLCJnbE1hdHJpeCIsZnVuY3Rpb24oKXtyZXR1cm4gcn0pO3ZhciBpPXQoMyk7dC5kKGUsIm1hdDIiLGZ1bmN0aW9uKCl7cmV0dXJuIGl9KTt2YXIgaD10KDQpO3QuZChlLCJtYXQyZCIsZnVuY3Rpb24oKXtyZXR1cm4gaH0pO3ZhciBnPXQoNSk7dC5kKGUsIm1hdDMiLGZ1bmN0aW9uKCl7cmV0dXJuIGd9KTt2YXIgdT10KDYpO3QuZChlLCJtYXQ0IixmdW5jdGlvbigpe3JldHVybiB1fSk7dmFyIGE9dCg3KTt0LmQoZSwicXVhdCIsZnVuY3Rpb24oKXtyZXR1cm4gYX0pO3ZhciBjPXQoMTApO3QuZChlLCJxdWF0MiIsZnVuY3Rpb24oKXtyZXR1cm4gY30pO3ZhciB4PXQoMTEpO3QuZChlLCJ2ZWMyIixmdW5jdGlvbigpe3JldHVybiB4fSk7dmFyIGY9dCg4KTt0LmQoZSwidmVjMyIsZnVuY3Rpb24oKXtyZXR1cm4gZn0pO3ZhciB2PXQoOSk7dC5kKGUsInZlYzQiLGZ1bmN0aW9uKCl7cmV0dXJuIHZ9KX0sZnVuY3Rpb24oUyxlLHQpe3QucihlKSx0LmQoZSwiRVBTSUxPTiIsZnVuY3Rpb24oKXtyZXR1cm4gcn0pLHQuZChlLCJBUlJBWV9UWVBFIixmdW5jdGlvbigpe3JldHVybiBpfSksdC5kKGUsIlJBTkRPTSIsZnVuY3Rpb24oKXtyZXR1cm4gaH0pLHQuZChlLCJzZXRNYXRyaXhBcnJheVR5cGUiLGZ1bmN0aW9uKCl7cmV0dXJuIGd9KSx0LmQoZSwidG9SYWRpYW4iLGZ1bmN0aW9uKCl7cmV0dXJuIGF9KSx0LmQoZSwiZXF1YWxzIixmdW5jdGlvbigpe3JldHVybiBjfSk7dmFyIHI9MWUtNixpPXR5cGVvZiBGbG9hdDMyQXJyYXk8InUiP0Zsb2F0MzJBcnJheTpBcnJheSxoPU1hdGgucmFuZG9tO2Z1bmN0aW9uIGcoeCl7aT14fXZhciB1PU1hdGguUEkvMTgwO2Z1bmN0aW9uIGEoeCl7cmV0dXJuIHgqdX1mdW5jdGlvbiBjKHgsZil7cmV0dXJuIE1hdGguYWJzKHgtZik8PXIqTWF0aC5tYXgoMSxNYXRoLmFicyh4KSxNYXRoLmFicyhmKSl9TWF0aC5oeXBvdHx8KE1hdGguaHlwb3Q9ZnVuY3Rpb24oKXtmb3IodmFyIHg9MCxmPWFyZ3VtZW50cy5sZW5ndGg7Zi0tOyl4Kz1hcmd1bWVudHNbZl0qYXJndW1lbnRzW2ZdO3JldHVybiBNYXRoLnNxcnQoeCl9KX0sZnVuY3Rpb24oUyxlLHQpe3QucihlKSx0LmQoZSwiY3JlYXRlIixmdW5jdGlvbigpe3JldHVybiBpfSksdC5kKGUsImNsb25lIixmdW5jdGlvbigpe3JldHVybiBofSksdC5kKGUsImNvcHkiLGZ1bmN0aW9uKCl7cmV0dXJuIGd9KSx0LmQoZSwiaWRlbnRpdHkiLGZ1bmN0aW9uKCl7cmV0dXJuIHV9KSx0LmQoZSwiZnJvbVZhbHVlcyIsZnVuY3Rpb24oKXtyZXR1cm4gYX0pLHQuZChlLCJzZXQiLGZ1bmN0aW9uKCl7cmV0dXJuIGN9KSx0LmQoZSwidHJhbnNwb3NlIixmdW5jdGlvbigpe3JldHVybiB4fSksdC5kKGUsImludmVydCIsZnVuY3Rpb24oKXtyZXR1cm4gZn0pLHQuZChlLCJhZGpvaW50IixmdW5jdGlvbigpe3JldHVybiB2fSksdC5kKGUsImRldGVybWluYW50IixmdW5jdGlvbigpe3JldHVybiBwfSksdC5kKGUsIm11bHRpcGx5IixmdW5jdGlvbigpe3JldHVybiBDfSksdC5kKGUsInJvdGF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gTX0pLHQuZChlLCJzY2FsZSIsZnVuY3Rpb24oKXtyZXR1cm4gbX0pLHQuZChlLCJmcm9tUm90YXRpb24iLGZ1bmN0aW9uKCl7cmV0dXJuIHl9KSx0LmQoZSwiZnJvbVNjYWxpbmciLGZ1bmN0aW9uKCl7cmV0dXJuIG59KSx0LmQoZSwic3RyIixmdW5jdGlvbigpe3JldHVybiBvfSksdC5kKGUsImZyb2IiLGZ1bmN0aW9uKCl7cmV0dXJuIHN9KSx0LmQoZSwiTERVIixmdW5jdGlvbigpe3JldHVybiBsfSksdC5kKGUsImFkZCIsZnVuY3Rpb24oKXtyZXR1cm4gRX0pLHQuZChlLCJzdWJ0cmFjdCIsZnVuY3Rpb24oKXtyZXR1cm4gVH0pLHQuZChlLCJleGFjdEVxdWFscyIsZnVuY3Rpb24oKXtyZXR1cm4gYn0pLHQuZChlLCJlcXVhbHMiLGZ1bmN0aW9uKCl7cmV0dXJuIEl9KSx0LmQoZSwibXVsdGlwbHlTY2FsYXIiLGZ1bmN0aW9uKCl7cmV0dXJuIFB9KSx0LmQoZSwibXVsdGlwbHlTY2FsYXJBbmRBZGQiLGZ1bmN0aW9uKCl7cmV0dXJuIEx9KSx0LmQoZSwibXVsIixmdW5jdGlvbigpe3JldHVybiBEfSksdC5kKGUsInN1YiIsZnVuY3Rpb24oKXtyZXR1cm4gUn0pO3ZhciByPXQoMik7ZnVuY3Rpb24gaSgpe3ZhciBBPW5ldyByLkFSUkFZX1RZUEUoNCk7cmV0dXJuIHIuQVJSQVlfVFlQRSE9RmxvYXQzMkFycmF5JiYoQVsxXT0wLEFbMl09MCksQVswXT0xLEFbM109MSxBfWZ1bmN0aW9uIGgoQSl7dmFyIGo9bmV3IHIuQVJSQVlfVFlQRSg0KTtyZXR1cm4galswXT1BWzBdLGpbMV09QVsxXSxqWzJdPUFbMl0salszXT1BWzNdLGp9ZnVuY3Rpb24gZyhBLGope3JldHVybiBBWzBdPWpbMF0sQVsxXT1qWzFdLEFbMl09alsyXSxBWzNdPWpbM10sQX1mdW5jdGlvbiB1KEEpe3JldHVybiBBWzBdPTEsQVsxXT0wLEFbMl09MCxBWzNdPTEsQX1mdW5jdGlvbiBhKEEsaixHLEgpe3ZhciBaPW5ldyByLkFSUkFZX1RZUEUoNCk7cmV0dXJuIFpbMF09QSxaWzFdPWosWlsyXT1HLFpbM109SCxafWZ1bmN0aW9uIGMoQSxqLEcsSCxaKXtyZXR1cm4gQVswXT1qLEFbMV09RyxBWzJdPUgsQVszXT1aLEF9ZnVuY3Rpb24geChBLGope2lmKEE9PT1qKXt2YXIgRz1qWzFdO0FbMV09alsyXSxBWzJdPUd9ZWxzZSBBWzBdPWpbMF0sQVsxXT1qWzJdLEFbMl09alsxXSxBWzNdPWpbM107cmV0dXJuIEF9ZnVuY3Rpb24gZihBLGope3ZhciBHPWpbMF0sSD1qWzFdLFo9alsyXSxxPWpbM10sRj1HKnEtWipIO3JldHVybiBGPyhGPTEvRixBWzBdPXEqRixBWzFdPS1IKkYsQVsyXT0tWipGLEFbM109RypGLEEpOm51bGx9ZnVuY3Rpb24gdihBLGope3ZhciBHPWpbMF07cmV0dXJuIEFbMF09alszXSxBWzFdPS1qWzFdLEFbMl09LWpbMl0sQVszXT1HLEF9ZnVuY3Rpb24gcChBKXtyZXR1cm4gQVswXSpBWzNdLUFbMl0qQVsxXX1mdW5jdGlvbiBDKEEsaixHKXt2YXIgSD1qWzBdLFo9alsxXSxxPWpbMl0sRj1qWzNdLCQ9R1swXSxKPUdbMV0sdHQ9R1syXSxfPUdbM107cmV0dXJuIEFbMF09SCokK3EqSixBWzFdPVoqJCtGKkosQVsyXT1IKnR0K3EqXyxBWzNdPVoqdHQrRipfLEF9ZnVuY3Rpb24gTShBLGosRyl7dmFyIEg9alswXSxaPWpbMV0scT1qWzJdLEY9alszXSwkPU1hdGguc2luKEcpLEo9TWF0aC5jb3MoRyk7cmV0dXJuIEFbMF09SCpKK3EqJCxBWzFdPVoqSitGKiQsQVsyXT1IKi0kK3EqSixBWzNdPVoqLSQrRipKLEF9ZnVuY3Rpb24gbShBLGosRyl7dmFyIEg9alswXSxaPWpbMV0scT1qWzJdLEY9alszXSwkPUdbMF0sSj1HWzFdO3JldHVybiBBWzBdPUgqJCxBWzFdPVoqJCxBWzJdPXEqSixBWzNdPUYqSixBfWZ1bmN0aW9uIHkoQSxqKXt2YXIgRz1NYXRoLnNpbihqKSxIPU1hdGguY29zKGopO3JldHVybiBBWzBdPUgsQVsxXT1HLEFbMl09LUcsQVszXT1ILEF9ZnVuY3Rpb24gbihBLGope3JldHVybiBBWzBdPWpbMF0sQVsxXT0wLEFbMl09MCxBWzNdPWpbMV0sQX1mdW5jdGlvbiBvKEEpe3JldHVybiJtYXQyKCIrQVswXSsiLCAiK0FbMV0rIiwgIitBWzJdKyIsICIrQVszXSsiKSJ9ZnVuY3Rpb24gcyhBKXtyZXR1cm4gTWF0aC5oeXBvdChBWzBdLEFbMV0sQVsyXSxBWzNdKX1mdW5jdGlvbiBsKEEsaixHLEgpe3JldHVybiBBWzJdPUhbMl0vSFswXSxHWzBdPUhbMF0sR1sxXT1IWzFdLEdbM109SFszXS1BWzJdKkdbMV0sW0EsaixHXX1mdW5jdGlvbiBFKEEsaixHKXtyZXR1cm4gQVswXT1qWzBdK0dbMF0sQVsxXT1qWzFdK0dbMV0sQVsyXT1qWzJdK0dbMl0sQVszXT1qWzNdK0dbM10sQX1mdW5jdGlvbiBUKEEsaixHKXtyZXR1cm4gQVswXT1qWzBdLUdbMF0sQVsxXT1qWzFdLUdbMV0sQVsyXT1qWzJdLUdbMl0sQVszXT1qWzNdLUdbM10sQX1mdW5jdGlvbiBiKEEsail7cmV0dXJuIEFbMF09PT1qWzBdJiZBWzFdPT09alsxXSYmQVsyXT09PWpbMl0mJkFbM109PT1qWzNdfWZ1bmN0aW9uIEkoQSxqKXt2YXIgRz1BWzBdLEg9QVsxXSxaPUFbMl0scT1BWzNdLEY9alswXSwkPWpbMV0sSj1qWzJdLHR0PWpbM107cmV0dXJuIE1hdGguYWJzKEctRik8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKEcpLE1hdGguYWJzKEYpKSYmTWF0aC5hYnMoSC0kKTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoSCksTWF0aC5hYnMoJCkpJiZNYXRoLmFicyhaLUopPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhaKSxNYXRoLmFicyhKKSkmJk1hdGguYWJzKHEtdHQpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhxKSxNYXRoLmFicyh0dCkpfWZ1bmN0aW9uIFAoQSxqLEcpe3JldHVybiBBWzBdPWpbMF0qRyxBWzFdPWpbMV0qRyxBWzJdPWpbMl0qRyxBWzNdPWpbM10qRyxBfWZ1bmN0aW9uIEwoQSxqLEcsSCl7cmV0dXJuIEFbMF09alswXStHWzBdKkgsQVsxXT1qWzFdK0dbMV0qSCxBWzJdPWpbMl0rR1syXSpILEFbM109alszXStHWzNdKkgsQX12YXIgRD1DLFI9VH0sZnVuY3Rpb24oUyxlLHQpe3QucihlKSx0LmQoZSwiY3JlYXRlIixmdW5jdGlvbigpe3JldHVybiBpfSksdC5kKGUsImNsb25lIixmdW5jdGlvbigpe3JldHVybiBofSksdC5kKGUsImNvcHkiLGZ1bmN0aW9uKCl7cmV0dXJuIGd9KSx0LmQoZSwiaWRlbnRpdHkiLGZ1bmN0aW9uKCl7cmV0dXJuIHV9KSx0LmQoZSwiZnJvbVZhbHVlcyIsZnVuY3Rpb24oKXtyZXR1cm4gYX0pLHQuZChlLCJzZXQiLGZ1bmN0aW9uKCl7cmV0dXJuIGN9KSx0LmQoZSwiaW52ZXJ0IixmdW5jdGlvbigpe3JldHVybiB4fSksdC5kKGUsImRldGVybWluYW50IixmdW5jdGlvbigpe3JldHVybiBmfSksdC5kKGUsIm11bHRpcGx5IixmdW5jdGlvbigpe3JldHVybiB2fSksdC5kKGUsInJvdGF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gcH0pLHQuZChlLCJzY2FsZSIsZnVuY3Rpb24oKXtyZXR1cm4gQ30pLHQuZChlLCJ0cmFuc2xhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIE19KSx0LmQoZSwiZnJvbVJvdGF0aW9uIixmdW5jdGlvbigpe3JldHVybiBtfSksdC5kKGUsImZyb21TY2FsaW5nIixmdW5jdGlvbigpe3JldHVybiB5fSksdC5kKGUsImZyb21UcmFuc2xhdGlvbiIsZnVuY3Rpb24oKXtyZXR1cm4gbn0pLHQuZChlLCJzdHIiLGZ1bmN0aW9uKCl7cmV0dXJuIG99KSx0LmQoZSwiZnJvYiIsZnVuY3Rpb24oKXtyZXR1cm4gc30pLHQuZChlLCJhZGQiLGZ1bmN0aW9uKCl7cmV0dXJuIGx9KSx0LmQoZSwic3VidHJhY3QiLGZ1bmN0aW9uKCl7cmV0dXJuIEV9KSx0LmQoZSwibXVsdGlwbHlTY2FsYXIiLGZ1bmN0aW9uKCl7cmV0dXJuIFR9KSx0LmQoZSwibXVsdGlwbHlTY2FsYXJBbmRBZGQiLGZ1bmN0aW9uKCl7cmV0dXJuIGJ9KSx0LmQoZSwiZXhhY3RFcXVhbHMiLGZ1bmN0aW9uKCl7cmV0dXJuIEl9KSx0LmQoZSwiZXF1YWxzIixmdW5jdGlvbigpe3JldHVybiBQfSksdC5kKGUsIm11bCIsZnVuY3Rpb24oKXtyZXR1cm4gTH0pLHQuZChlLCJzdWIiLGZ1bmN0aW9uKCl7cmV0dXJuIER9KTt2YXIgcj10KDIpO2Z1bmN0aW9uIGkoKXt2YXIgUj1uZXcgci5BUlJBWV9UWVBFKDYpO3JldHVybiByLkFSUkFZX1RZUEUhPUZsb2F0MzJBcnJheSYmKFJbMV09MCxSWzJdPTAsUls0XT0wLFJbNV09MCksUlswXT0xLFJbM109MSxSfWZ1bmN0aW9uIGgoUil7dmFyIEE9bmV3IHIuQVJSQVlfVFlQRSg2KTtyZXR1cm4gQVswXT1SWzBdLEFbMV09UlsxXSxBWzJdPVJbMl0sQVszXT1SWzNdLEFbNF09Uls0XSxBWzVdPVJbNV0sQX1mdW5jdGlvbiBnKFIsQSl7cmV0dXJuIFJbMF09QVswXSxSWzFdPUFbMV0sUlsyXT1BWzJdLFJbM109QVszXSxSWzRdPUFbNF0sUls1XT1BWzVdLFJ9ZnVuY3Rpb24gdShSKXtyZXR1cm4gUlswXT0xLFJbMV09MCxSWzJdPTAsUlszXT0xLFJbNF09MCxSWzVdPTAsUn1mdW5jdGlvbiBhKFIsQSxqLEcsSCxaKXt2YXIgcT1uZXcgci5BUlJBWV9UWVBFKDYpO3JldHVybiBxWzBdPVIscVsxXT1BLHFbMl09aixxWzNdPUcscVs0XT1ILHFbNV09WixxfWZ1bmN0aW9uIGMoUixBLGosRyxILFoscSl7cmV0dXJuIFJbMF09QSxSWzFdPWosUlsyXT1HLFJbM109SCxSWzRdPVosUls1XT1xLFJ9ZnVuY3Rpb24geChSLEEpe3ZhciBqPUFbMF0sRz1BWzFdLEg9QVsyXSxaPUFbM10scT1BWzRdLEY9QVs1XSwkPWoqWi1HKkg7cmV0dXJuICQ/KCQ9MS8kLFJbMF09WiokLFJbMV09LUcqJCxSWzJdPS1IKiQsUlszXT1qKiQsUls0XT0oSCpGLVoqcSkqJCxSWzVdPShHKnEtaipGKSokLFIpOm51bGx9ZnVuY3Rpb24gZihSKXtyZXR1cm4gUlswXSpSWzNdLVJbMV0qUlsyXX1mdW5jdGlvbiB2KFIsQSxqKXt2YXIgRz1BWzBdLEg9QVsxXSxaPUFbMl0scT1BWzNdLEY9QVs0XSwkPUFbNV0sSj1qWzBdLHR0PWpbMV0sXz1qWzJdLHN0PWpbM10saz1qWzRdLGN0PWpbNV07cmV0dXJuIFJbMF09RypKK1oqdHQsUlsxXT1IKkorcSp0dCxSWzJdPUcqXytaKnN0LFJbM109SCpfK3Eqc3QsUls0XT1HKmsrWipjdCtGLFJbNV09SCprK3EqY3QrJCxSfWZ1bmN0aW9uIHAoUixBLGope3ZhciBHPUFbMF0sSD1BWzFdLFo9QVsyXSxxPUFbM10sRj1BWzRdLCQ9QVs1XSxKPU1hdGguc2luKGopLHR0PU1hdGguY29zKGopO3JldHVybiBSWzBdPUcqdHQrWipKLFJbMV09SCp0dCtxKkosUlsyXT1HKi1KK1oqdHQsUlszXT1IKi1KK3EqdHQsUls0XT1GLFJbNV09JCxSfWZ1bmN0aW9uIEMoUixBLGope3ZhciBHPUFbMF0sSD1BWzFdLFo9QVsyXSxxPUFbM10sRj1BWzRdLCQ9QVs1XSxKPWpbMF0sdHQ9alsxXTtyZXR1cm4gUlswXT1HKkosUlsxXT1IKkosUlsyXT1aKnR0LFJbM109cSp0dCxSWzRdPUYsUls1XT0kLFJ9ZnVuY3Rpb24gTShSLEEsail7dmFyIEc9QVswXSxIPUFbMV0sWj1BWzJdLHE9QVszXSxGPUFbNF0sJD1BWzVdLEo9alswXSx0dD1qWzFdO3JldHVybiBSWzBdPUcsUlsxXT1ILFJbMl09WixSWzNdPXEsUls0XT1HKkorWip0dCtGLFJbNV09SCpKK3EqdHQrJCxSfWZ1bmN0aW9uIG0oUixBKXt2YXIgaj1NYXRoLnNpbihBKSxHPU1hdGguY29zKEEpO3JldHVybiBSWzBdPUcsUlsxXT1qLFJbMl09LWosUlszXT1HLFJbNF09MCxSWzVdPTAsUn1mdW5jdGlvbiB5KFIsQSl7cmV0dXJuIFJbMF09QVswXSxSWzFdPTAsUlsyXT0wLFJbM109QVsxXSxSWzRdPTAsUls1XT0wLFJ9ZnVuY3Rpb24gbihSLEEpe3JldHVybiBSWzBdPTEsUlsxXT0wLFJbMl09MCxSWzNdPTEsUls0XT1BWzBdLFJbNV09QVsxXSxSfWZ1bmN0aW9uIG8oUil7cmV0dXJuIm1hdDJkKCIrUlswXSsiLCAiK1JbMV0rIiwgIitSWzJdKyIsICIrUlszXSsiLCAiK1JbNF0rIiwgIitSWzVdKyIpIn1mdW5jdGlvbiBzKFIpe3JldHVybiBNYXRoLmh5cG90KFJbMF0sUlsxXSxSWzJdLFJbM10sUls0XSxSWzVdLDEpfWZ1bmN0aW9uIGwoUixBLGope3JldHVybiBSWzBdPUFbMF0ralswXSxSWzFdPUFbMV0ralsxXSxSWzJdPUFbMl0ralsyXSxSWzNdPUFbM10ralszXSxSWzRdPUFbNF0rals0XSxSWzVdPUFbNV0rals1XSxSfWZ1bmN0aW9uIEUoUixBLGope3JldHVybiBSWzBdPUFbMF0talswXSxSWzFdPUFbMV0talsxXSxSWzJdPUFbMl0talsyXSxSWzNdPUFbM10talszXSxSWzRdPUFbNF0tals0XSxSWzVdPUFbNV0tals1XSxSfWZ1bmN0aW9uIFQoUixBLGope3JldHVybiBSWzBdPUFbMF0qaixSWzFdPUFbMV0qaixSWzJdPUFbMl0qaixSWzNdPUFbM10qaixSWzRdPUFbNF0qaixSWzVdPUFbNV0qaixSfWZ1bmN0aW9uIGIoUixBLGosRyl7cmV0dXJuIFJbMF09QVswXStqWzBdKkcsUlsxXT1BWzFdK2pbMV0qRyxSWzJdPUFbMl0ralsyXSpHLFJbM109QVszXStqWzNdKkcsUls0XT1BWzRdK2pbNF0qRyxSWzVdPUFbNV0rals1XSpHLFJ9ZnVuY3Rpb24gSShSLEEpe3JldHVybiBSWzBdPT09QVswXSYmUlsxXT09PUFbMV0mJlJbMl09PT1BWzJdJiZSWzNdPT09QVszXSYmUls0XT09PUFbNF0mJlJbNV09PT1BWzVdfWZ1bmN0aW9uIFAoUixBKXt2YXIgaj1SWzBdLEc9UlsxXSxIPVJbMl0sWj1SWzNdLHE9Uls0XSxGPVJbNV0sJD1BWzBdLEo9QVsxXSx0dD1BWzJdLF89QVszXSxzdD1BWzRdLGs9QVs1XTtyZXR1cm4gTWF0aC5hYnMoai0kKTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoaiksTWF0aC5hYnMoJCkpJiZNYXRoLmFicyhHLUopPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhHKSxNYXRoLmFicyhKKSkmJk1hdGguYWJzKEgtdHQpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhIKSxNYXRoLmFicyh0dCkpJiZNYXRoLmFicyhaLV8pPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhaKSxNYXRoLmFicyhfKSkmJk1hdGguYWJzKHEtc3QpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhxKSxNYXRoLmFicyhzdCkpJiZNYXRoLmFicyhGLWspPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhGKSxNYXRoLmFicyhrKSl9dmFyIEw9dixEPUV9LGZ1bmN0aW9uKFMsZSx0KXt0LnIoZSksdC5kKGUsImNyZWF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gaX0pLHQuZChlLCJmcm9tTWF0NCIsZnVuY3Rpb24oKXtyZXR1cm4gaH0pLHQuZChlLCJjbG9uZSIsZnVuY3Rpb24oKXtyZXR1cm4gZ30pLHQuZChlLCJjb3B5IixmdW5jdGlvbigpe3JldHVybiB1fSksdC5kKGUsImZyb21WYWx1ZXMiLGZ1bmN0aW9uKCl7cmV0dXJuIGF9KSx0LmQoZSwic2V0IixmdW5jdGlvbigpe3JldHVybiBjfSksdC5kKGUsImlkZW50aXR5IixmdW5jdGlvbigpe3JldHVybiB4fSksdC5kKGUsInRyYW5zcG9zZSIsZnVuY3Rpb24oKXtyZXR1cm4gZn0pLHQuZChlLCJpbnZlcnQiLGZ1bmN0aW9uKCl7cmV0dXJuIHZ9KSx0LmQoZSwiYWRqb2ludCIsZnVuY3Rpb24oKXtyZXR1cm4gcH0pLHQuZChlLCJkZXRlcm1pbmFudCIsZnVuY3Rpb24oKXtyZXR1cm4gQ30pLHQuZChlLCJtdWx0aXBseSIsZnVuY3Rpb24oKXtyZXR1cm4gTX0pLHQuZChlLCJ0cmFuc2xhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIG19KSx0LmQoZSwicm90YXRlIixmdW5jdGlvbigpe3JldHVybiB5fSksdC5kKGUsInNjYWxlIixmdW5jdGlvbigpe3JldHVybiBufSksdC5kKGUsImZyb21UcmFuc2xhdGlvbiIsZnVuY3Rpb24oKXtyZXR1cm4gb30pLHQuZChlLCJmcm9tUm90YXRpb24iLGZ1bmN0aW9uKCl7cmV0dXJuIHN9KSx0LmQoZSwiZnJvbVNjYWxpbmciLGZ1bmN0aW9uKCl7cmV0dXJuIGx9KSx0LmQoZSwiZnJvbU1hdDJkIixmdW5jdGlvbigpe3JldHVybiBFfSksdC5kKGUsImZyb21RdWF0IixmdW5jdGlvbigpe3JldHVybiBUfSksdC5kKGUsIm5vcm1hbEZyb21NYXQ0IixmdW5jdGlvbigpe3JldHVybiBifSksdC5kKGUsInByb2plY3Rpb24iLGZ1bmN0aW9uKCl7cmV0dXJuIEl9KSx0LmQoZSwic3RyIixmdW5jdGlvbigpe3JldHVybiBQfSksdC5kKGUsImZyb2IiLGZ1bmN0aW9uKCl7cmV0dXJuIEx9KSx0LmQoZSwiYWRkIixmdW5jdGlvbigpe3JldHVybiBEfSksdC5kKGUsInN1YnRyYWN0IixmdW5jdGlvbigpe3JldHVybiBSfSksdC5kKGUsIm11bHRpcGx5U2NhbGFyIixmdW5jdGlvbigpe3JldHVybiBBfSksdC5kKGUsIm11bHRpcGx5U2NhbGFyQW5kQWRkIixmdW5jdGlvbigpe3JldHVybiBqfSksdC5kKGUsImV4YWN0RXF1YWxzIixmdW5jdGlvbigpe3JldHVybiBHfSksdC5kKGUsImVxdWFscyIsZnVuY3Rpb24oKXtyZXR1cm4gSH0pLHQuZChlLCJtdWwiLGZ1bmN0aW9uKCl7cmV0dXJuIFp9KSx0LmQoZSwic3ViIixmdW5jdGlvbigpe3JldHVybiBxfSk7dmFyIHI9dCgyKTtmdW5jdGlvbiBpKCl7dmFyIEY9bmV3IHIuQVJSQVlfVFlQRSg5KTtyZXR1cm4gci5BUlJBWV9UWVBFIT1GbG9hdDMyQXJyYXkmJihGWzFdPTAsRlsyXT0wLEZbM109MCxGWzVdPTAsRls2XT0wLEZbN109MCksRlswXT0xLEZbNF09MSxGWzhdPTEsRn1mdW5jdGlvbiBoKEYsJCl7cmV0dXJuIEZbMF09JFswXSxGWzFdPSRbMV0sRlsyXT0kWzJdLEZbM109JFs0XSxGWzRdPSRbNV0sRls1XT0kWzZdLEZbNl09JFs4XSxGWzddPSRbOV0sRls4XT0kWzEwXSxGfWZ1bmN0aW9uIGcoRil7dmFyICQ9bmV3IHIuQVJSQVlfVFlQRSg5KTtyZXR1cm4gJFswXT1GWzBdLCRbMV09RlsxXSwkWzJdPUZbMl0sJFszXT1GWzNdLCRbNF09Rls0XSwkWzVdPUZbNV0sJFs2XT1GWzZdLCRbN109Rls3XSwkWzhdPUZbOF0sJH1mdW5jdGlvbiB1KEYsJCl7cmV0dXJuIEZbMF09JFswXSxGWzFdPSRbMV0sRlsyXT0kWzJdLEZbM109JFszXSxGWzRdPSRbNF0sRls1XT0kWzVdLEZbNl09JFs2XSxGWzddPSRbN10sRls4XT0kWzhdLEZ9ZnVuY3Rpb24gYShGLCQsSix0dCxfLHN0LGssY3QsZnQpe3ZhciBXPW5ldyByLkFSUkFZX1RZUEUoOSk7cmV0dXJuIFdbMF09RixXWzFdPSQsV1syXT1KLFdbM109dHQsV1s0XT1fLFdbNV09c3QsV1s2XT1rLFdbN109Y3QsV1s4XT1mdCxXfWZ1bmN0aW9uIGMoRiwkLEosdHQsXyxzdCxrLGN0LGZ0LFcpe3JldHVybiBGWzBdPSQsRlsxXT1KLEZbMl09dHQsRlszXT1fLEZbNF09c3QsRls1XT1rLEZbNl09Y3QsRls3XT1mdCxGWzhdPVcsRn1mdW5jdGlvbiB4KEYpe3JldHVybiBGWzBdPTEsRlsxXT0wLEZbMl09MCxGWzNdPTAsRls0XT0xLEZbNV09MCxGWzZdPTAsRls3XT0wLEZbOF09MSxGfWZ1bmN0aW9uIGYoRiwkKXtpZihGPT09JCl7dmFyIEo9JFsxXSx0dD0kWzJdLF89JFs1XTtGWzFdPSRbM10sRlsyXT0kWzZdLEZbM109SixGWzVdPSRbN10sRls2XT10dCxGWzddPV99ZWxzZSBGWzBdPSRbMF0sRlsxXT0kWzNdLEZbMl09JFs2XSxGWzNdPSRbMV0sRls0XT0kWzRdLEZbNV09JFs3XSxGWzZdPSRbMl0sRls3XT0kWzVdLEZbOF09JFs4XTtyZXR1cm4gRn1mdW5jdGlvbiB2KEYsJCl7dmFyIEo9JFswXSx0dD0kWzFdLF89JFsyXSxzdD0kWzNdLGs9JFs0XSxjdD0kWzVdLGZ0PSRbNl0sVz0kWzddLFU9JFs4XSxWPVUqay1jdCpXLFg9LVUqc3QrY3QqZnQsQj1XKnN0LWsqZnQsdz1KKlYrdHQqWCtfKkI7cmV0dXJuIHc/KHc9MS93LEZbMF09Vip3LEZbMV09KC1VKnR0K18qVykqdyxGWzJdPShjdCp0dC1fKmspKncsRlszXT1YKncsRls0XT0oVSpKLV8qZnQpKncsRls1XT0oLWN0KkorXypzdCkqdyxGWzZdPUIqdyxGWzddPSgtVypKK3R0KmZ0KSp3LEZbOF09KGsqSi10dCpzdCkqdyxGKTpudWxsfWZ1bmN0aW9uIHAoRiwkKXt2YXIgSj0kWzBdLHR0PSRbMV0sXz0kWzJdLHN0PSRbM10saz0kWzRdLGN0PSRbNV0sZnQ9JFs2XSxXPSRbN10sVT0kWzhdO3JldHVybiBGWzBdPWsqVS1jdCpXLEZbMV09XypXLXR0KlUsRlsyXT10dCpjdC1fKmssRlszXT1jdCpmdC1zdCpVLEZbNF09SipVLV8qZnQsRls1XT1fKnN0LUoqY3QsRls2XT1zdCpXLWsqZnQsRls3XT10dCpmdC1KKlcsRls4XT1KKmstdHQqc3QsRn1mdW5jdGlvbiBDKEYpe3ZhciAkPUZbMF0sSj1GWzFdLHR0PUZbMl0sXz1GWzNdLHN0PUZbNF0saz1GWzVdLGN0PUZbNl0sZnQ9Rls3XSxXPUZbOF07cmV0dXJuICQqKFcqc3QtaypmdCkrSiooLVcqXytrKmN0KSt0dCooZnQqXy1zdCpjdCl9ZnVuY3Rpb24gTShGLCQsSil7dmFyIHR0PSRbMF0sXz0kWzFdLHN0PSRbMl0saz0kWzNdLGN0PSRbNF0sZnQ9JFs1XSxXPSRbNl0sVT0kWzddLFY9JFs4XSxYPUpbMF0sQj1KWzFdLHc9SlsyXSxkPUpbM10sTz1KWzRdLE49Sls1XSx6PUpbNl0sSz1KWzddLFk9Sls4XTtyZXR1cm4gRlswXT1YKnR0K0Iqayt3KlcsRlsxXT1YKl8rQipjdCt3KlUsRlsyXT1YKnN0K0IqZnQrdypWLEZbM109ZCp0dCtPKmsrTipXLEZbNF09ZCpfK08qY3QrTipVLEZbNV09ZCpzdCtPKmZ0K04qVixGWzZdPXoqdHQrSyprK1kqVyxGWzddPXoqXytLKmN0K1kqVSxGWzhdPXoqc3QrSypmdCtZKlYsRn1mdW5jdGlvbiBtKEYsJCxKKXt2YXIgdHQ9JFswXSxfPSRbMV0sc3Q9JFsyXSxrPSRbM10sY3Q9JFs0XSxmdD0kWzVdLFc9JFs2XSxVPSRbN10sVj0kWzhdLFg9SlswXSxCPUpbMV07cmV0dXJuIEZbMF09dHQsRlsxXT1fLEZbMl09c3QsRlszXT1rLEZbNF09Y3QsRls1XT1mdCxGWzZdPVgqdHQrQiprK1csRls3XT1YKl8rQipjdCtVLEZbOF09WCpzdCtCKmZ0K1YsRn1mdW5jdGlvbiB5KEYsJCxKKXt2YXIgdHQ9JFswXSxfPSRbMV0sc3Q9JFsyXSxrPSRbM10sY3Q9JFs0XSxmdD0kWzVdLFc9JFs2XSxVPSRbN10sVj0kWzhdLFg9TWF0aC5zaW4oSiksQj1NYXRoLmNvcyhKKTtyZXR1cm4gRlswXT1CKnR0K1gqayxGWzFdPUIqXytYKmN0LEZbMl09QipzdCtYKmZ0LEZbM109QiprLVgqdHQsRls0XT1CKmN0LVgqXyxGWzVdPUIqZnQtWCpzdCxGWzZdPVcsRls3XT1VLEZbOF09VixGfWZ1bmN0aW9uIG4oRiwkLEope3ZhciB0dD1KWzBdLF89SlsxXTtyZXR1cm4gRlswXT10dCokWzBdLEZbMV09dHQqJFsxXSxGWzJdPXR0KiRbMl0sRlszXT1fKiRbM10sRls0XT1fKiRbNF0sRls1XT1fKiRbNV0sRls2XT0kWzZdLEZbN109JFs3XSxGWzhdPSRbOF0sRn1mdW5jdGlvbiBvKEYsJCl7cmV0dXJuIEZbMF09MSxGWzFdPTAsRlsyXT0wLEZbM109MCxGWzRdPTEsRls1XT0wLEZbNl09JFswXSxGWzddPSRbMV0sRls4XT0xLEZ9ZnVuY3Rpb24gcyhGLCQpe3ZhciBKPU1hdGguc2luKCQpLHR0PU1hdGguY29zKCQpO3JldHVybiBGWzBdPXR0LEZbMV09SixGWzJdPTAsRlszXT0tSixGWzRdPXR0LEZbNV09MCxGWzZdPTAsRls3XT0wLEZbOF09MSxGfWZ1bmN0aW9uIGwoRiwkKXtyZXR1cm4gRlswXT0kWzBdLEZbMV09MCxGWzJdPTAsRlszXT0wLEZbNF09JFsxXSxGWzVdPTAsRls2XT0wLEZbN109MCxGWzhdPTEsRn1mdW5jdGlvbiBFKEYsJCl7cmV0dXJuIEZbMF09JFswXSxGWzFdPSRbMV0sRlsyXT0wLEZbM109JFsyXSxGWzRdPSRbM10sRls1XT0wLEZbNl09JFs0XSxGWzddPSRbNV0sRls4XT0xLEZ9ZnVuY3Rpb24gVChGLCQpe3ZhciBKPSRbMF0sdHQ9JFsxXSxfPSRbMl0sc3Q9JFszXSxrPUorSixjdD10dCt0dCxmdD1fK18sVz1KKmssVT10dCprLFY9dHQqY3QsWD1fKmssQj1fKmN0LHc9XypmdCxkPXN0KmssTz1zdCpjdCxOPXN0KmZ0O3JldHVybiBGWzBdPTEtVi13LEZbM109VS1OLEZbNl09WCtPLEZbMV09VStOLEZbNF09MS1XLXcsRls3XT1CLWQsRlsyXT1YLU8sRls1XT1CK2QsRls4XT0xLVctVixGfWZ1bmN0aW9uIGIoRiwkKXt2YXIgSj0kWzBdLHR0PSRbMV0sXz0kWzJdLHN0PSRbM10saz0kWzRdLGN0PSRbNV0sZnQ9JFs2XSxXPSRbN10sVT0kWzhdLFY9JFs5XSxYPSRbMTBdLEI9JFsxMV0sdz0kWzEyXSxkPSRbMTNdLE89JFsxNF0sTj0kWzE1XSx6PUoqY3QtdHQqayxLPUoqZnQtXyprLFk9SipXLXN0KmssUT10dCpmdC1fKmN0LGV0PXR0Klctc3QqY3QscnQ9XypXLXN0KmZ0LG90PVUqZC1WKncsbHQ9VSpPLVgqdyxpdD1VKk4tQip3LG50PVYqTy1YKmQsYXQ9VipOLUIqZCxkdD1YKk4tQipPLGd0PXoqZHQtSyphdCtZKm50K1EqaXQtZXQqbHQrcnQqb3Q7cmV0dXJuIGd0PyhndD0xL2d0LEZbMF09KGN0KmR0LWZ0KmF0K1cqbnQpKmd0LEZbMV09KGZ0Kml0LWsqZHQtVypsdCkqZ3QsRlsyXT0oayphdC1jdCppdCtXKm90KSpndCxGWzNdPShfKmF0LXR0KmR0LXN0Km50KSpndCxGWzRdPShKKmR0LV8qaXQrc3QqbHQpKmd0LEZbNV09KHR0Kml0LUoqYXQtc3Qqb3QpKmd0LEZbNl09KGQqcnQtTypldCtOKlEpKmd0LEZbN109KE8qWS13KnJ0LU4qSykqZ3QsRls4XT0odypldC1kKlkrTip6KSpndCxGKTpudWxsfWZ1bmN0aW9uIEkoRiwkLEope3JldHVybiBGWzBdPTIvJCxGWzFdPTAsRlsyXT0wLEZbM109MCxGWzRdPS0yL0osRls1XT0wLEZbNl09LTEsRls3XT0xLEZbOF09MSxGfWZ1bmN0aW9uIFAoRil7cmV0dXJuIm1hdDMoIitGWzBdKyIsICIrRlsxXSsiLCAiK0ZbMl0rIiwgIitGWzNdKyIsICIrRls0XSsiLCAiK0ZbNV0rIiwgIitGWzZdKyIsICIrRls3XSsiLCAiK0ZbOF0rIikifWZ1bmN0aW9uIEwoRil7cmV0dXJuIE1hdGguaHlwb3QoRlswXSxGWzFdLEZbMl0sRlszXSxGWzRdLEZbNV0sRls2XSxGWzddLEZbOF0pfWZ1bmN0aW9uIEQoRiwkLEope3JldHVybiBGWzBdPSRbMF0rSlswXSxGWzFdPSRbMV0rSlsxXSxGWzJdPSRbMl0rSlsyXSxGWzNdPSRbM10rSlszXSxGWzRdPSRbNF0rSls0XSxGWzVdPSRbNV0rSls1XSxGWzZdPSRbNl0rSls2XSxGWzddPSRbN10rSls3XSxGWzhdPSRbOF0rSls4XSxGfWZ1bmN0aW9uIFIoRiwkLEope3JldHVybiBGWzBdPSRbMF0tSlswXSxGWzFdPSRbMV0tSlsxXSxGWzJdPSRbMl0tSlsyXSxGWzNdPSRbM10tSlszXSxGWzRdPSRbNF0tSls0XSxGWzVdPSRbNV0tSls1XSxGWzZdPSRbNl0tSls2XSxGWzddPSRbN10tSls3XSxGWzhdPSRbOF0tSls4XSxGfWZ1bmN0aW9uIEEoRiwkLEope3JldHVybiBGWzBdPSRbMF0qSixGWzFdPSRbMV0qSixGWzJdPSRbMl0qSixGWzNdPSRbM10qSixGWzRdPSRbNF0qSixGWzVdPSRbNV0qSixGWzZdPSRbNl0qSixGWzddPSRbN10qSixGWzhdPSRbOF0qSixGfWZ1bmN0aW9uIGooRiwkLEosdHQpe3JldHVybiBGWzBdPSRbMF0rSlswXSp0dCxGWzFdPSRbMV0rSlsxXSp0dCxGWzJdPSRbMl0rSlsyXSp0dCxGWzNdPSRbM10rSlszXSp0dCxGWzRdPSRbNF0rSls0XSp0dCxGWzVdPSRbNV0rSls1XSp0dCxGWzZdPSRbNl0rSls2XSp0dCxGWzddPSRbN10rSls3XSp0dCxGWzhdPSRbOF0rSls4XSp0dCxGfWZ1bmN0aW9uIEcoRiwkKXtyZXR1cm4gRlswXT09PSRbMF0mJkZbMV09PT0kWzFdJiZGWzJdPT09JFsyXSYmRlszXT09PSRbM10mJkZbNF09PT0kWzRdJiZGWzVdPT09JFs1XSYmRls2XT09PSRbNl0mJkZbN109PT0kWzddJiZGWzhdPT09JFs4XX1mdW5jdGlvbiBIKEYsJCl7dmFyIEo9RlswXSx0dD1GWzFdLF89RlsyXSxzdD1GWzNdLGs9Rls0XSxjdD1GWzVdLGZ0PUZbNl0sVz1GWzddLFU9Rls4XSxWPSRbMF0sWD0kWzFdLEI9JFsyXSx3PSRbM10sZD0kWzRdLE89JFs1XSxOPSRbNl0sej0kWzddLEs9JFs4XTtyZXR1cm4gTWF0aC5hYnMoSi1WKTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoSiksTWF0aC5hYnMoVikpJiZNYXRoLmFicyh0dC1YKTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnModHQpLE1hdGguYWJzKFgpKSYmTWF0aC5hYnMoXy1CKTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoXyksTWF0aC5hYnMoQikpJiZNYXRoLmFicyhzdC13KTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoc3QpLE1hdGguYWJzKHcpKSYmTWF0aC5hYnMoay1kKTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoayksTWF0aC5hYnMoZCkpJiZNYXRoLmFicyhjdC1PKTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoY3QpLE1hdGguYWJzKE8pKSYmTWF0aC5hYnMoZnQtTik8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKGZ0KSxNYXRoLmFicyhOKSkmJk1hdGguYWJzKFcteik8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKFcpLE1hdGguYWJzKHopKSYmTWF0aC5hYnMoVS1LKTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoVSksTWF0aC5hYnMoSykpfXZhciBaPU0scT1SfSxmdW5jdGlvbihTLGUsdCl7dC5yKGUpLHQuZChlLCJjcmVhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIGl9KSx0LmQoZSwiY2xvbmUiLGZ1bmN0aW9uKCl7cmV0dXJuIGh9KSx0LmQoZSwiY29weSIsZnVuY3Rpb24oKXtyZXR1cm4gZ30pLHQuZChlLCJmcm9tVmFsdWVzIixmdW5jdGlvbigpe3JldHVybiB1fSksdC5kKGUsInNldCIsZnVuY3Rpb24oKXtyZXR1cm4gYX0pLHQuZChlLCJpZGVudGl0eSIsZnVuY3Rpb24oKXtyZXR1cm4gY30pLHQuZChlLCJ0cmFuc3Bvc2UiLGZ1bmN0aW9uKCl7cmV0dXJuIHh9KSx0LmQoZSwiaW52ZXJ0IixmdW5jdGlvbigpe3JldHVybiBmfSksdC5kKGUsImFkam9pbnQiLGZ1bmN0aW9uKCl7cmV0dXJuIHZ9KSx0LmQoZSwiZGV0ZXJtaW5hbnQiLGZ1bmN0aW9uKCl7cmV0dXJuIHB9KSx0LmQoZSwibXVsdGlwbHkiLGZ1bmN0aW9uKCl7cmV0dXJuIEN9KSx0LmQoZSwidHJhbnNsYXRlIixmdW5jdGlvbigpe3JldHVybiBNfSksdC5kKGUsInNjYWxlIixmdW5jdGlvbigpe3JldHVybiBtfSksdC5kKGUsInJvdGF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4geX0pLHQuZChlLCJyb3RhdGVYIixmdW5jdGlvbigpe3JldHVybiBufSksdC5kKGUsInJvdGF0ZVkiLGZ1bmN0aW9uKCl7cmV0dXJuIG99KSx0LmQoZSwicm90YXRlWiIsZnVuY3Rpb24oKXtyZXR1cm4gc30pLHQuZChlLCJmcm9tVHJhbnNsYXRpb24iLGZ1bmN0aW9uKCl7cmV0dXJuIGx9KSx0LmQoZSwiZnJvbVNjYWxpbmciLGZ1bmN0aW9uKCl7cmV0dXJuIEV9KSx0LmQoZSwiZnJvbVJvdGF0aW9uIixmdW5jdGlvbigpe3JldHVybiBUfSksdC5kKGUsImZyb21YUm90YXRpb24iLGZ1bmN0aW9uKCl7cmV0dXJuIGJ9KSx0LmQoZSwiZnJvbVlSb3RhdGlvbiIsZnVuY3Rpb24oKXtyZXR1cm4gSX0pLHQuZChlLCJmcm9tWlJvdGF0aW9uIixmdW5jdGlvbigpe3JldHVybiBQfSksdC5kKGUsImZyb21Sb3RhdGlvblRyYW5zbGF0aW9uIixmdW5jdGlvbigpe3JldHVybiBMfSksdC5kKGUsImZyb21RdWF0MiIsZnVuY3Rpb24oKXtyZXR1cm4gRH0pLHQuZChlLCJnZXRUcmFuc2xhdGlvbiIsZnVuY3Rpb24oKXtyZXR1cm4gUn0pLHQuZChlLCJnZXRTY2FsaW5nIixmdW5jdGlvbigpe3JldHVybiBBfSksdC5kKGUsImdldFJvdGF0aW9uIixmdW5jdGlvbigpe3JldHVybiBqfSksdC5kKGUsImZyb21Sb3RhdGlvblRyYW5zbGF0aW9uU2NhbGUiLGZ1bmN0aW9uKCl7cmV0dXJuIEd9KSx0LmQoZSwiZnJvbVJvdGF0aW9uVHJhbnNsYXRpb25TY2FsZU9yaWdpbiIsZnVuY3Rpb24oKXtyZXR1cm4gSH0pLHQuZChlLCJmcm9tUXVhdCIsZnVuY3Rpb24oKXtyZXR1cm4gWn0pLHQuZChlLCJmcnVzdHVtIixmdW5jdGlvbigpe3JldHVybiBxfSksdC5kKGUsInBlcnNwZWN0aXZlIixmdW5jdGlvbigpe3JldHVybiBGfSksdC5kKGUsInBlcnNwZWN0aXZlRnJvbUZpZWxkT2ZWaWV3IixmdW5jdGlvbigpe3JldHVybiAkfSksdC5kKGUsIm9ydGhvIixmdW5jdGlvbigpe3JldHVybiBKfSksdC5kKGUsImxvb2tBdCIsZnVuY3Rpb24oKXtyZXR1cm4gdHR9KSx0LmQoZSwidGFyZ2V0VG8iLGZ1bmN0aW9uKCl7cmV0dXJuIF99KSx0LmQoZSwic3RyIixmdW5jdGlvbigpe3JldHVybiBzdH0pLHQuZChlLCJmcm9iIixmdW5jdGlvbigpe3JldHVybiBrfSksdC5kKGUsImFkZCIsZnVuY3Rpb24oKXtyZXR1cm4gY3R9KSx0LmQoZSwic3VidHJhY3QiLGZ1bmN0aW9uKCl7cmV0dXJuIGZ0fSksdC5kKGUsIm11bHRpcGx5U2NhbGFyIixmdW5jdGlvbigpe3JldHVybiBXfSksdC5kKGUsIm11bHRpcGx5U2NhbGFyQW5kQWRkIixmdW5jdGlvbigpe3JldHVybiBVfSksdC5kKGUsImV4YWN0RXF1YWxzIixmdW5jdGlvbigpe3JldHVybiBWfSksdC5kKGUsImVxdWFscyIsZnVuY3Rpb24oKXtyZXR1cm4gWH0pLHQuZChlLCJtdWwiLGZ1bmN0aW9uKCl7cmV0dXJuIEJ9KSx0LmQoZSwic3ViIixmdW5jdGlvbigpe3JldHVybiB3fSk7dmFyIHI9dCgyKTtmdW5jdGlvbiBpKCl7dmFyIGQ9bmV3IHIuQVJSQVlfVFlQRSgxNik7cmV0dXJuIHIuQVJSQVlfVFlQRSE9RmxvYXQzMkFycmF5JiYoZFsxXT0wLGRbMl09MCxkWzNdPTAsZFs0XT0wLGRbNl09MCxkWzddPTAsZFs4XT0wLGRbOV09MCxkWzExXT0wLGRbMTJdPTAsZFsxM109MCxkWzE0XT0wKSxkWzBdPTEsZFs1XT0xLGRbMTBdPTEsZFsxNV09MSxkfWZ1bmN0aW9uIGgoZCl7dmFyIE89bmV3IHIuQVJSQVlfVFlQRSgxNik7cmV0dXJuIE9bMF09ZFswXSxPWzFdPWRbMV0sT1syXT1kWzJdLE9bM109ZFszXSxPWzRdPWRbNF0sT1s1XT1kWzVdLE9bNl09ZFs2XSxPWzddPWRbN10sT1s4XT1kWzhdLE9bOV09ZFs5XSxPWzEwXT1kWzEwXSxPWzExXT1kWzExXSxPWzEyXT1kWzEyXSxPWzEzXT1kWzEzXSxPWzE0XT1kWzE0XSxPWzE1XT1kWzE1XSxPfWZ1bmN0aW9uIGcoZCxPKXtyZXR1cm4gZFswXT1PWzBdLGRbMV09T1sxXSxkWzJdPU9bMl0sZFszXT1PWzNdLGRbNF09T1s0XSxkWzVdPU9bNV0sZFs2XT1PWzZdLGRbN109T1s3XSxkWzhdPU9bOF0sZFs5XT1PWzldLGRbMTBdPU9bMTBdLGRbMTFdPU9bMTFdLGRbMTJdPU9bMTJdLGRbMTNdPU9bMTNdLGRbMTRdPU9bMTRdLGRbMTVdPU9bMTVdLGR9ZnVuY3Rpb24gdShkLE8sTix6LEssWSxRLGV0LHJ0LG90LGx0LGl0LG50LGF0LGR0LGd0KXt2YXIgdXQ9bmV3IHIuQVJSQVlfVFlQRSgxNik7cmV0dXJuIHV0WzBdPWQsdXRbMV09Tyx1dFsyXT1OLHV0WzNdPXosdXRbNF09Syx1dFs1XT1ZLHV0WzZdPVEsdXRbN109ZXQsdXRbOF09cnQsdXRbOV09b3QsdXRbMTBdPWx0LHV0WzExXT1pdCx1dFsxMl09bnQsdXRbMTNdPWF0LHV0WzE0XT1kdCx1dFsxNV09Z3QsdXR9ZnVuY3Rpb24gYShkLE8sTix6LEssWSxRLGV0LHJ0LG90LGx0LGl0LG50LGF0LGR0LGd0LHV0KXtyZXR1cm4gZFswXT1PLGRbMV09TixkWzJdPXosZFszXT1LLGRbNF09WSxkWzVdPVEsZFs2XT1ldCxkWzddPXJ0LGRbOF09b3QsZFs5XT1sdCxkWzEwXT1pdCxkWzExXT1udCxkWzEyXT1hdCxkWzEzXT1kdCxkWzE0XT1ndCxkWzE1XT11dCxkfWZ1bmN0aW9uIGMoZCl7cmV0dXJuIGRbMF09MSxkWzFdPTAsZFsyXT0wLGRbM109MCxkWzRdPTAsZFs1XT0xLGRbNl09MCxkWzddPTAsZFs4XT0wLGRbOV09MCxkWzEwXT0xLGRbMTFdPTAsZFsxMl09MCxkWzEzXT0wLGRbMTRdPTAsZFsxNV09MSxkfWZ1bmN0aW9uIHgoZCxPKXtpZihkPT09Tyl7dmFyIE49T1sxXSx6PU9bMl0sSz1PWzNdLFk9T1s2XSxRPU9bN10sZXQ9T1sxMV07ZFsxXT1PWzRdLGRbMl09T1s4XSxkWzNdPU9bMTJdLGRbNF09TixkWzZdPU9bOV0sZFs3XT1PWzEzXSxkWzhdPXosZFs5XT1ZLGRbMTFdPU9bMTRdLGRbMTJdPUssZFsxM109USxkWzE0XT1ldH1lbHNlIGRbMF09T1swXSxkWzFdPU9bNF0sZFsyXT1PWzhdLGRbM109T1sxMl0sZFs0XT1PWzFdLGRbNV09T1s1XSxkWzZdPU9bOV0sZFs3XT1PWzEzXSxkWzhdPU9bMl0sZFs5XT1PWzZdLGRbMTBdPU9bMTBdLGRbMTFdPU9bMTRdLGRbMTJdPU9bM10sZFsxM109T1s3XSxkWzE0XT1PWzExXSxkWzE1XT1PWzE1XTtyZXR1cm4gZH1mdW5jdGlvbiBmKGQsTyl7dmFyIE49T1swXSx6PU9bMV0sSz1PWzJdLFk9T1szXSxRPU9bNF0sZXQ9T1s1XSxydD1PWzZdLG90PU9bN10sbHQ9T1s4XSxpdD1PWzldLG50PU9bMTBdLGF0PU9bMTFdLGR0PU9bMTJdLGd0PU9bMTNdLHV0PU9bMTRdLG10PU9bMTVdLFR0PU4qZXQteipRLHh0PU4qcnQtSypRLE10PU4qb3QtWSpRLEV0PXoqcnQtSypldCxPdD16Km90LVkqZXQsV3Q9SypvdC1ZKnJ0LE50PWx0Kmd0LWl0KmR0LEJ0PWx0KnV0LW50KmR0LGp0PWx0Km10LWF0KmR0LFV0PWl0KnV0LW50Kmd0LEZ0PWl0Km10LWF0Kmd0LHp0PW50Km10LWF0KnV0LEN0PVR0Knp0LXh0KkZ0K010KlV0K0V0Kmp0LU90KkJ0K1d0Kk50O3JldHVybiBDdD8oQ3Q9MS9DdCxkWzBdPShldCp6dC1ydCpGdCtvdCpVdCkqQ3QsZFsxXT0oSypGdC16Knp0LVkqVXQpKkN0LGRbMl09KGd0Kld0LXV0Kk90K210KkV0KSpDdCxkWzNdPShudCpPdC1pdCpXdC1hdCpFdCkqQ3QsZFs0XT0ocnQqanQtUSp6dC1vdCpCdCkqQ3QsZFs1XT0oTip6dC1LKmp0K1kqQnQpKkN0LGRbNl09KHV0Kk10LWR0Kld0LW10Knh0KSpDdCxkWzddPShsdCpXdC1udCpNdCthdCp4dCkqQ3QsZFs4XT0oUSpGdC1ldCpqdCtvdCpOdCkqQ3QsZFs5XT0oeipqdC1OKkZ0LVkqTnQpKkN0LGRbMTBdPShkdCpPdC1ndCpNdCttdCpUdCkqQ3QsZFsxMV09KGl0Kk10LWx0Kk90LWF0KlR0KSpDdCxkWzEyXT0oZXQqQnQtUSpVdC1ydCpOdCkqQ3QsZFsxM109KE4qVXQteipCdCtLKk50KSpDdCxkWzE0XT0oZ3QqeHQtZHQqRXQtdXQqVHQpKkN0LGRbMTVdPShsdCpFdC1pdCp4dCtudCpUdCkqQ3QsZCk6bnVsbH1mdW5jdGlvbiB2KGQsTyl7dmFyIE49T1swXSx6PU9bMV0sSz1PWzJdLFk9T1szXSxRPU9bNF0sZXQ9T1s1XSxydD1PWzZdLG90PU9bN10sbHQ9T1s4XSxpdD1PWzldLG50PU9bMTBdLGF0PU9bMTFdLGR0PU9bMTJdLGd0PU9bMTNdLHV0PU9bMTRdLG10PU9bMTVdO3JldHVybiBkWzBdPWV0KihudCptdC1hdCp1dCktaXQqKHJ0Km10LW90KnV0KStndCoocnQqYXQtb3QqbnQpLGRbMV09LSh6KihudCptdC1hdCp1dCktaXQqKEsqbXQtWSp1dCkrZ3QqKEsqYXQtWSpudCkpLGRbMl09eioocnQqbXQtb3QqdXQpLWV0KihLKm10LVkqdXQpK2d0KihLKm90LVkqcnQpLGRbM109LSh6KihydCphdC1vdCpudCktZXQqKEsqYXQtWSpudCkraXQqKEsqb3QtWSpydCkpLGRbNF09LShRKihudCptdC1hdCp1dCktbHQqKHJ0Km10LW90KnV0KStkdCoocnQqYXQtb3QqbnQpKSxkWzVdPU4qKG50Km10LWF0KnV0KS1sdCooSyptdC1ZKnV0KStkdCooSyphdC1ZKm50KSxkWzZdPS0oTioocnQqbXQtb3QqdXQpLVEqKEsqbXQtWSp1dCkrZHQqKEsqb3QtWSpydCkpLGRbN109TioocnQqYXQtb3QqbnQpLVEqKEsqYXQtWSpudCkrbHQqKEsqb3QtWSpydCksZFs4XT1RKihpdCptdC1hdCpndCktbHQqKGV0Km10LW90Kmd0KStkdCooZXQqYXQtb3QqaXQpLGRbOV09LShOKihpdCptdC1hdCpndCktbHQqKHoqbXQtWSpndCkrZHQqKHoqYXQtWSppdCkpLGRbMTBdPU4qKGV0Km10LW90Kmd0KS1RKih6Km10LVkqZ3QpK2R0Kih6Km90LVkqZXQpLGRbMTFdPS0oTiooZXQqYXQtb3QqaXQpLVEqKHoqYXQtWSppdCkrbHQqKHoqb3QtWSpldCkpLGRbMTJdPS0oUSooaXQqdXQtbnQqZ3QpLWx0KihldCp1dC1ydCpndCkrZHQqKGV0Km50LXJ0Kml0KSksZFsxM109TiooaXQqdXQtbnQqZ3QpLWx0Kih6KnV0LUsqZ3QpK2R0Kih6Km50LUsqaXQpLGRbMTRdPS0oTiooZXQqdXQtcnQqZ3QpLVEqKHoqdXQtSypndCkrZHQqKHoqcnQtSypldCkpLGRbMTVdPU4qKGV0Km50LXJ0Kml0KS1RKih6Km50LUsqaXQpK2x0Kih6KnJ0LUsqZXQpLGR9ZnVuY3Rpb24gcChkKXt2YXIgTz1kWzBdLE49ZFsxXSx6PWRbMl0sSz1kWzNdLFk9ZFs0XSxRPWRbNV0sZXQ9ZFs2XSxydD1kWzddLG90PWRbOF0sbHQ9ZFs5XSxpdD1kWzEwXSxudD1kWzExXSxhdD1kWzEyXSxkdD1kWzEzXSxndD1kWzE0XSx1dD1kWzE1XSxtdD1PKlEtTipZLFR0PU8qZXQteipZLHh0PU8qcnQtSypZLE10PU4qZXQteipRLEV0PU4qcnQtSypRLE90PXoqcnQtSypldCxXdD1vdCpkdC1sdCphdCxOdD1vdCpndC1pdCphdCxCdD1vdCp1dC1udCphdCxqdD1sdCpndC1pdCpkdCxVdD1sdCp1dC1udCpkdCxGdD1pdCp1dC1udCpndDtyZXR1cm4gbXQqRnQtVHQqVXQreHQqanQrTXQqQnQtRXQqTnQrT3QqV3R9ZnVuY3Rpb24gQyhkLE8sTil7dmFyIHo9T1swXSxLPU9bMV0sWT1PWzJdLFE9T1szXSxldD1PWzRdLHJ0PU9bNV0sb3Q9T1s2XSxsdD1PWzddLGl0PU9bOF0sbnQ9T1s5XSxhdD1PWzEwXSxkdD1PWzExXSxndD1PWzEyXSx1dD1PWzEzXSxtdD1PWzE0XSxUdD1PWzE1XSx4dD1OWzBdLE10PU5bMV0sRXQ9TlsyXSxPdD1OWzNdO3JldHVybiBkWzBdPXh0KnorTXQqZXQrRXQqaXQrT3QqZ3QsZFsxXT14dCpLK010KnJ0K0V0Km50K090KnV0LGRbMl09eHQqWStNdCpvdCtFdCphdCtPdCptdCxkWzNdPXh0KlErTXQqbHQrRXQqZHQrT3QqVHQseHQ9Tls0XSxNdD1OWzVdLEV0PU5bNl0sT3Q9Tls3XSxkWzRdPXh0KnorTXQqZXQrRXQqaXQrT3QqZ3QsZFs1XT14dCpLK010KnJ0K0V0Km50K090KnV0LGRbNl09eHQqWStNdCpvdCtFdCphdCtPdCptdCxkWzddPXh0KlErTXQqbHQrRXQqZHQrT3QqVHQseHQ9Tls4XSxNdD1OWzldLEV0PU5bMTBdLE90PU5bMTFdLGRbOF09eHQqeitNdCpldCtFdCppdCtPdCpndCxkWzldPXh0KksrTXQqcnQrRXQqbnQrT3QqdXQsZFsxMF09eHQqWStNdCpvdCtFdCphdCtPdCptdCxkWzExXT14dCpRK010Kmx0K0V0KmR0K090KlR0LHh0PU5bMTJdLE10PU5bMTNdLEV0PU5bMTRdLE90PU5bMTVdLGRbMTJdPXh0KnorTXQqZXQrRXQqaXQrT3QqZ3QsZFsxM109eHQqSytNdCpydCtFdCpudCtPdCp1dCxkWzE0XT14dCpZK010Km90K0V0KmF0K090Km10LGRbMTVdPXh0KlErTXQqbHQrRXQqZHQrT3QqVHQsZH1mdW5jdGlvbiBNKGQsTyxOKXt2YXIgej1OWzBdLEs9TlsxXSxZPU5bMl0sUSxldCxydCxvdCxsdCxpdCxudCxhdCxkdCxndCx1dCxtdDtyZXR1cm4gTz09PWQ/KGRbMTJdPU9bMF0qeitPWzRdKksrT1s4XSpZK09bMTJdLGRbMTNdPU9bMV0qeitPWzVdKksrT1s5XSpZK09bMTNdLGRbMTRdPU9bMl0qeitPWzZdKksrT1sxMF0qWStPWzE0XSxkWzE1XT1PWzNdKnorT1s3XSpLK09bMTFdKlkrT1sxNV0pOihRPU9bMF0sZXQ9T1sxXSxydD1PWzJdLG90PU9bM10sbHQ9T1s0XSxpdD1PWzVdLG50PU9bNl0sYXQ9T1s3XSxkdD1PWzhdLGd0PU9bOV0sdXQ9T1sxMF0sbXQ9T1sxMV0sZFswXT1RLGRbMV09ZXQsZFsyXT1ydCxkWzNdPW90LGRbNF09bHQsZFs1XT1pdCxkWzZdPW50LGRbN109YXQsZFs4XT1kdCxkWzldPWd0LGRbMTBdPXV0LGRbMTFdPW10LGRbMTJdPVEqeitsdCpLK2R0KlkrT1sxMl0sZFsxM109ZXQqeitpdCpLK2d0KlkrT1sxM10sZFsxNF09cnQqeitudCpLK3V0KlkrT1sxNF0sZFsxNV09b3QqeithdCpLK210KlkrT1sxNV0pLGR9ZnVuY3Rpb24gbShkLE8sTil7dmFyIHo9TlswXSxLPU5bMV0sWT1OWzJdO3JldHVybiBkWzBdPU9bMF0qeixkWzFdPU9bMV0qeixkWzJdPU9bMl0qeixkWzNdPU9bM10qeixkWzRdPU9bNF0qSyxkWzVdPU9bNV0qSyxkWzZdPU9bNl0qSyxkWzddPU9bN10qSyxkWzhdPU9bOF0qWSxkWzldPU9bOV0qWSxkWzEwXT1PWzEwXSpZLGRbMTFdPU9bMTFdKlksZFsxMl09T1sxMl0sZFsxM109T1sxM10sZFsxNF09T1sxNF0sZFsxNV09T1sxNV0sZH1mdW5jdGlvbiB5KGQsTyxOLHope3ZhciBLPXpbMF0sWT16WzFdLFE9elsyXSxldD1NYXRoLmh5cG90KEssWSxRKSxydCxvdCxsdCxpdCxudCxhdCxkdCxndCx1dCxtdCxUdCx4dCxNdCxFdCxPdCxXdCxOdCxCdCxqdCxVdCxGdCx6dCxDdCxHdDtyZXR1cm4gZXQ8ci5FUFNJTE9OP251bGw6KGV0PTEvZXQsSyo9ZXQsWSo9ZXQsUSo9ZXQscnQ9TWF0aC5zaW4oTiksb3Q9TWF0aC5jb3MoTiksbHQ9MS1vdCxpdD1PWzBdLG50PU9bMV0sYXQ9T1syXSxkdD1PWzNdLGd0PU9bNF0sdXQ9T1s1XSxtdD1PWzZdLFR0PU9bN10seHQ9T1s4XSxNdD1PWzldLEV0PU9bMTBdLE90PU9bMTFdLFd0PUsqSypsdCtvdCxOdD1ZKksqbHQrUSpydCxCdD1RKksqbHQtWSpydCxqdD1LKlkqbHQtUSpydCxVdD1ZKlkqbHQrb3QsRnQ9USpZKmx0K0sqcnQsenQ9SypRKmx0K1kqcnQsQ3Q9WSpRKmx0LUsqcnQsR3Q9USpRKmx0K290LGRbMF09aXQqV3QrZ3QqTnQreHQqQnQsZFsxXT1udCpXdCt1dCpOdCtNdCpCdCxkWzJdPWF0Kld0K210Kk50K0V0KkJ0LGRbM109ZHQqV3QrVHQqTnQrT3QqQnQsZFs0XT1pdCpqdCtndCpVdCt4dCpGdCxkWzVdPW50Kmp0K3V0KlV0K010KkZ0LGRbNl09YXQqanQrbXQqVXQrRXQqRnQsZFs3XT1kdCpqdCtUdCpVdCtPdCpGdCxkWzhdPWl0Knp0K2d0KkN0K3h0Kkd0LGRbOV09bnQqenQrdXQqQ3QrTXQqR3QsZFsxMF09YXQqenQrbXQqQ3QrRXQqR3QsZFsxMV09ZHQqenQrVHQqQ3QrT3QqR3QsTyE9PWQmJihkWzEyXT1PWzEyXSxkWzEzXT1PWzEzXSxkWzE0XT1PWzE0XSxkWzE1XT1PWzE1XSksZCl9ZnVuY3Rpb24gbihkLE8sTil7dmFyIHo9TWF0aC5zaW4oTiksSz1NYXRoLmNvcyhOKSxZPU9bNF0sUT1PWzVdLGV0PU9bNl0scnQ9T1s3XSxvdD1PWzhdLGx0PU9bOV0saXQ9T1sxMF0sbnQ9T1sxMV07cmV0dXJuIE8hPT1kJiYoZFswXT1PWzBdLGRbMV09T1sxXSxkWzJdPU9bMl0sZFszXT1PWzNdLGRbMTJdPU9bMTJdLGRbMTNdPU9bMTNdLGRbMTRdPU9bMTRdLGRbMTVdPU9bMTVdKSxkWzRdPVkqSytvdCp6LGRbNV09USpLK2x0KnosZFs2XT1ldCpLK2l0KnosZFs3XT1ydCpLK250KnosZFs4XT1vdCpLLVkqeixkWzldPWx0KkstUSp6LGRbMTBdPWl0KkstZXQqeixkWzExXT1udCpLLXJ0KnosZH1mdW5jdGlvbiBvKGQsTyxOKXt2YXIgej1NYXRoLnNpbihOKSxLPU1hdGguY29zKE4pLFk9T1swXSxRPU9bMV0sZXQ9T1syXSxydD1PWzNdLG90PU9bOF0sbHQ9T1s5XSxpdD1PWzEwXSxudD1PWzExXTtyZXR1cm4gTyE9PWQmJihkWzRdPU9bNF0sZFs1XT1PWzVdLGRbNl09T1s2XSxkWzddPU9bN10sZFsxMl09T1sxMl0sZFsxM109T1sxM10sZFsxNF09T1sxNF0sZFsxNV09T1sxNV0pLGRbMF09WSpLLW90KnosZFsxXT1RKkstbHQqeixkWzJdPWV0KkstaXQqeixkWzNdPXJ0KkstbnQqeixkWzhdPVkqeitvdCpLLGRbOV09USp6K2x0KkssZFsxMF09ZXQqeitpdCpLLGRbMTFdPXJ0KnorbnQqSyxkfWZ1bmN0aW9uIHMoZCxPLE4pe3ZhciB6PU1hdGguc2luKE4pLEs9TWF0aC5jb3MoTiksWT1PWzBdLFE9T1sxXSxldD1PWzJdLHJ0PU9bM10sb3Q9T1s0XSxsdD1PWzVdLGl0PU9bNl0sbnQ9T1s3XTtyZXR1cm4gTyE9PWQmJihkWzhdPU9bOF0sZFs5XT1PWzldLGRbMTBdPU9bMTBdLGRbMTFdPU9bMTFdLGRbMTJdPU9bMTJdLGRbMTNdPU9bMTNdLGRbMTRdPU9bMTRdLGRbMTVdPU9bMTVdKSxkWzBdPVkqSytvdCp6LGRbMV09USpLK2x0KnosZFsyXT1ldCpLK2l0KnosZFszXT1ydCpLK250KnosZFs0XT1vdCpLLVkqeixkWzVdPWx0KkstUSp6LGRbNl09aXQqSy1ldCp6LGRbN109bnQqSy1ydCp6LGR9ZnVuY3Rpb24gbChkLE8pe3JldHVybiBkWzBdPTEsZFsxXT0wLGRbMl09MCxkWzNdPTAsZFs0XT0wLGRbNV09MSxkWzZdPTAsZFs3XT0wLGRbOF09MCxkWzldPTAsZFsxMF09MSxkWzExXT0wLGRbMTJdPU9bMF0sZFsxM109T1sxXSxkWzE0XT1PWzJdLGRbMTVdPTEsZH1mdW5jdGlvbiBFKGQsTyl7cmV0dXJuIGRbMF09T1swXSxkWzFdPTAsZFsyXT0wLGRbM109MCxkWzRdPTAsZFs1XT1PWzFdLGRbNl09MCxkWzddPTAsZFs4XT0wLGRbOV09MCxkWzEwXT1PWzJdLGRbMTFdPTAsZFsxMl09MCxkWzEzXT0wLGRbMTRdPTAsZFsxNV09MSxkfWZ1bmN0aW9uIFQoZCxPLE4pe3ZhciB6PU5bMF0sSz1OWzFdLFk9TlsyXSxRPU1hdGguaHlwb3QoeixLLFkpLGV0LHJ0LG90O3JldHVybiBRPHIuRVBTSUxPTj9udWxsOihRPTEvUSx6Kj1RLEsqPVEsWSo9USxldD1NYXRoLnNpbihPKSxydD1NYXRoLmNvcyhPKSxvdD0xLXJ0LGRbMF09eip6Km90K3J0LGRbMV09Syp6Km90K1kqZXQsZFsyXT1ZKnoqb3QtSypldCxkWzNdPTAsZFs0XT16Kksqb3QtWSpldCxkWzVdPUsqSypvdCtydCxkWzZdPVkqSypvdCt6KmV0LGRbN109MCxkWzhdPXoqWSpvdCtLKmV0LGRbOV09SypZKm90LXoqZXQsZFsxMF09WSpZKm90K3J0LGRbMTFdPTAsZFsxMl09MCxkWzEzXT0wLGRbMTRdPTAsZFsxNV09MSxkKX1mdW5jdGlvbiBiKGQsTyl7dmFyIE49TWF0aC5zaW4oTyksej1NYXRoLmNvcyhPKTtyZXR1cm4gZFswXT0xLGRbMV09MCxkWzJdPTAsZFszXT0wLGRbNF09MCxkWzVdPXosZFs2XT1OLGRbN109MCxkWzhdPTAsZFs5XT0tTixkWzEwXT16LGRbMTFdPTAsZFsxMl09MCxkWzEzXT0wLGRbMTRdPTAsZFsxNV09MSxkfWZ1bmN0aW9uIEkoZCxPKXt2YXIgTj1NYXRoLnNpbihPKSx6PU1hdGguY29zKE8pO3JldHVybiBkWzBdPXosZFsxXT0wLGRbMl09LU4sZFszXT0wLGRbNF09MCxkWzVdPTEsZFs2XT0wLGRbN109MCxkWzhdPU4sZFs5XT0wLGRbMTBdPXosZFsxMV09MCxkWzEyXT0wLGRbMTNdPTAsZFsxNF09MCxkWzE1XT0xLGR9ZnVuY3Rpb24gUChkLE8pe3ZhciBOPU1hdGguc2luKE8pLHo9TWF0aC5jb3MoTyk7cmV0dXJuIGRbMF09eixkWzFdPU4sZFsyXT0wLGRbM109MCxkWzRdPS1OLGRbNV09eixkWzZdPTAsZFs3XT0wLGRbOF09MCxkWzldPTAsZFsxMF09MSxkWzExXT0wLGRbMTJdPTAsZFsxM109MCxkWzE0XT0wLGRbMTVdPTEsZH1mdW5jdGlvbiBMKGQsTyxOKXt2YXIgej1PWzBdLEs9T1sxXSxZPU9bMl0sUT1PWzNdLGV0PXoreixydD1LK0ssb3Q9WStZLGx0PXoqZXQsaXQ9eipydCxudD16Km90LGF0PUsqcnQsZHQ9SypvdCxndD1ZKm90LHV0PVEqZXQsbXQ9USpydCxUdD1RKm90O3JldHVybiBkWzBdPTEtKGF0K2d0KSxkWzFdPWl0K1R0LGRbMl09bnQtbXQsZFszXT0wLGRbNF09aXQtVHQsZFs1XT0xLShsdCtndCksZFs2XT1kdCt1dCxkWzddPTAsZFs4XT1udCttdCxkWzldPWR0LXV0LGRbMTBdPTEtKGx0K2F0KSxkWzExXT0wLGRbMTJdPU5bMF0sZFsxM109TlsxXSxkWzE0XT1OWzJdLGRbMTVdPTEsZH1mdW5jdGlvbiBEKGQsTyl7dmFyIE49bmV3IHIuQVJSQVlfVFlQRSgzKSx6PS1PWzBdLEs9LU9bMV0sWT0tT1syXSxRPU9bM10sZXQ9T1s0XSxydD1PWzVdLG90PU9bNl0sbHQ9T1s3XSxpdD16KnorSypLK1kqWStRKlE7cmV0dXJuIGl0PjA/KE5bMF09KGV0KlErbHQqeitydCpZLW90KkspKjIvaXQsTlsxXT0ocnQqUStsdCpLK290KnotZXQqWSkqMi9pdCxOWzJdPShvdCpRK2x0KlkrZXQqSy1ydCp6KSoyL2l0KTooTlswXT0oZXQqUStsdCp6K3J0Klktb3QqSykqMixOWzFdPShydCpRK2x0Kksrb3Qqei1ldCpZKSoyLE5bMl09KG90KlErbHQqWStldCpLLXJ0KnopKjIpLEwoZCxPLE4pLGR9ZnVuY3Rpb24gUihkLE8pe3JldHVybiBkWzBdPU9bMTJdLGRbMV09T1sxM10sZFsyXT1PWzE0XSxkfWZ1bmN0aW9uIEEoZCxPKXt2YXIgTj1PWzBdLHo9T1sxXSxLPU9bMl0sWT1PWzRdLFE9T1s1XSxldD1PWzZdLHJ0PU9bOF0sb3Q9T1s5XSxsdD1PWzEwXTtyZXR1cm4gZFswXT1NYXRoLmh5cG90KE4seixLKSxkWzFdPU1hdGguaHlwb3QoWSxRLGV0KSxkWzJdPU1hdGguaHlwb3QocnQsb3QsbHQpLGR9ZnVuY3Rpb24gaihkLE8pe3ZhciBOPW5ldyByLkFSUkFZX1RZUEUoMyk7QShOLE8pO3ZhciB6PTEvTlswXSxLPTEvTlsxXSxZPTEvTlsyXSxRPU9bMF0qeixldD1PWzFdKksscnQ9T1syXSpZLG90PU9bNF0qeixsdD1PWzVdKkssaXQ9T1s2XSpZLG50PU9bOF0qeixhdD1PWzldKkssZHQ9T1sxMF0qWSxndD1RK2x0K2R0LHV0PTA7cmV0dXJuIGd0PjA/KHV0PU1hdGguc3FydChndCsxKSoyLGRbM109LjI1KnV0LGRbMF09KGl0LWF0KS91dCxkWzFdPShudC1ydCkvdXQsZFsyXT0oZXQtb3QpL3V0KTpRPmx0JiZRPmR0Pyh1dD1NYXRoLnNxcnQoMStRLWx0LWR0KSoyLGRbM109KGl0LWF0KS91dCxkWzBdPS4yNSp1dCxkWzFdPShldCtvdCkvdXQsZFsyXT0obnQrcnQpL3V0KTpsdD5kdD8odXQ9TWF0aC5zcXJ0KDErbHQtUS1kdCkqMixkWzNdPShudC1ydCkvdXQsZFswXT0oZXQrb3QpL3V0LGRbMV09LjI1KnV0LGRbMl09KGl0K2F0KS91dCk6KHV0PU1hdGguc3FydCgxK2R0LVEtbHQpKjIsZFszXT0oZXQtb3QpL3V0LGRbMF09KG50K3J0KS91dCxkWzFdPShpdCthdCkvdXQsZFsyXT0uMjUqdXQpLGR9ZnVuY3Rpb24gRyhkLE8sTix6KXt2YXIgSz1PWzBdLFk9T1sxXSxRPU9bMl0sZXQ9T1szXSxydD1LK0ssb3Q9WStZLGx0PVErUSxpdD1LKnJ0LG50PUsqb3QsYXQ9SypsdCxkdD1ZKm90LGd0PVkqbHQsdXQ9USpsdCxtdD1ldCpydCxUdD1ldCpvdCx4dD1ldCpsdCxNdD16WzBdLEV0PXpbMV0sT3Q9elsyXTtyZXR1cm4gZFswXT0oMS0oZHQrdXQpKSpNdCxkWzFdPShudCt4dCkqTXQsZFsyXT0oYXQtVHQpKk10LGRbM109MCxkWzRdPShudC14dCkqRXQsZFs1XT0oMS0oaXQrdXQpKSpFdCxkWzZdPShndCttdCkqRXQsZFs3XT0wLGRbOF09KGF0K1R0KSpPdCxkWzldPShndC1tdCkqT3QsZFsxMF09KDEtKGl0K2R0KSkqT3QsZFsxMV09MCxkWzEyXT1OWzBdLGRbMTNdPU5bMV0sZFsxNF09TlsyXSxkWzE1XT0xLGR9ZnVuY3Rpb24gSChkLE8sTix6LEspe3ZhciBZPU9bMF0sUT1PWzFdLGV0PU9bMl0scnQ9T1szXSxvdD1ZK1ksbHQ9UStRLGl0PWV0K2V0LG50PVkqb3QsYXQ9WSpsdCxkdD1ZKml0LGd0PVEqbHQsdXQ9USppdCxtdD1ldCppdCxUdD1ydCpvdCx4dD1ydCpsdCxNdD1ydCppdCxFdD16WzBdLE90PXpbMV0sV3Q9elsyXSxOdD1LWzBdLEJ0PUtbMV0sanQ9S1syXSxVdD0oMS0oZ3QrbXQpKSpFdCxGdD0oYXQrTXQpKkV0LHp0PShkdC14dCkqRXQsQ3Q9KGF0LU10KSpPdCxHdD0oMS0obnQrbXQpKSpPdCxfdD0odXQrVHQpKk90LHRlPShkdCt4dCkqV3QsTWU9KHV0LVR0KSpXdCxFZT0oMS0obnQrZ3QpKSpXdDtyZXR1cm4gZFswXT1VdCxkWzFdPUZ0LGRbMl09enQsZFszXT0wLGRbNF09Q3QsZFs1XT1HdCxkWzZdPV90LGRbN109MCxkWzhdPXRlLGRbOV09TWUsZFsxMF09RWUsZFsxMV09MCxkWzEyXT1OWzBdK050LShVdCpOdCtDdCpCdCt0ZSpqdCksZFsxM109TlsxXStCdC0oRnQqTnQrR3QqQnQrTWUqanQpLGRbMTRdPU5bMl0ranQtKHp0Kk50K190KkJ0K0VlKmp0KSxkWzE1XT0xLGR9ZnVuY3Rpb24gWihkLE8pe3ZhciBOPU9bMF0sej1PWzFdLEs9T1syXSxZPU9bM10sUT1OK04sZXQ9eit6LHJ0PUsrSyxvdD1OKlEsbHQ9eipRLGl0PXoqZXQsbnQ9SypRLGF0PUsqZXQsZHQ9SypydCxndD1ZKlEsdXQ9WSpldCxtdD1ZKnJ0O3JldHVybiBkWzBdPTEtaXQtZHQsZFsxXT1sdCttdCxkWzJdPW50LXV0LGRbM109MCxkWzRdPWx0LW10LGRbNV09MS1vdC1kdCxkWzZdPWF0K2d0LGRbN109MCxkWzhdPW50K3V0LGRbOV09YXQtZ3QsZFsxMF09MS1vdC1pdCxkWzExXT0wLGRbMTJdPTAsZFsxM109MCxkWzE0XT0wLGRbMTVdPTEsZH1mdW5jdGlvbiBxKGQsTyxOLHosSyxZLFEpe3ZhciBldD0xLyhOLU8pLHJ0PTEvKEsteiksb3Q9MS8oWS1RKTtyZXR1cm4gZFswXT1ZKjIqZXQsZFsxXT0wLGRbMl09MCxkWzNdPTAsZFs0XT0wLGRbNV09WSoyKnJ0LGRbNl09MCxkWzddPTAsZFs4XT0oTitPKSpldCxkWzldPShLK3opKnJ0LGRbMTBdPShRK1kpKm90LGRbMTFdPS0xLGRbMTJdPTAsZFsxM109MCxkWzE0XT1RKlkqMipvdCxkWzE1XT0wLGR9ZnVuY3Rpb24gRihkLE8sTix6LEspe3ZhciBZPTEvTWF0aC50YW4oTy8yKSxRO3JldHVybiBkWzBdPVkvTixkWzFdPTAsZFsyXT0wLGRbM109MCxkWzRdPTAsZFs1XT1ZLGRbNl09MCxkWzddPTAsZFs4XT0wLGRbOV09MCxkWzExXT0tMSxkWzEyXT0wLGRbMTNdPTAsZFsxNV09MCxLIT1udWxsJiZLIT09MS8wPyhRPTEvKHotSyksZFsxMF09KEsreikqUSxkWzE0XT0yKksqeipRKTooZFsxMF09LTEsZFsxNF09LTIqeiksZH1mdW5jdGlvbiAkKGQsTyxOLHope3ZhciBLPU1hdGgudGFuKE8udXBEZWdyZWVzKk1hdGguUEkvMTgwKSxZPU1hdGgudGFuKE8uZG93bkRlZ3JlZXMqTWF0aC5QSS8xODApLFE9TWF0aC50YW4oTy5sZWZ0RGVncmVlcypNYXRoLlBJLzE4MCksZXQ9TWF0aC50YW4oTy5yaWdodERlZ3JlZXMqTWF0aC5QSS8xODApLHJ0PTIvKFErZXQpLG90PTIvKEsrWSk7cmV0dXJuIGRbMF09cnQsZFsxXT0wLGRbMl09MCxkWzNdPTAsZFs0XT0wLGRbNV09b3QsZFs2XT0wLGRbN109MCxkWzhdPS0oKFEtZXQpKnJ0Ki41KSxkWzldPShLLVkpKm90Ki41LGRbMTBdPXovKE4teiksZFsxMV09LTEsZFsxMl09MCxkWzEzXT0wLGRbMTRdPXoqTi8oTi16KSxkWzE1XT0wLGR9ZnVuY3Rpb24gSihkLE8sTix6LEssWSxRKXt2YXIgZXQ9MS8oTy1OKSxydD0xLyh6LUspLG90PTEvKFktUSk7cmV0dXJuIGRbMF09LTIqZXQsZFsxXT0wLGRbMl09MCxkWzNdPTAsZFs0XT0wLGRbNV09LTIqcnQsZFs2XT0wLGRbN109MCxkWzhdPTAsZFs5XT0wLGRbMTBdPTIqb3QsZFsxMV09MCxkWzEyXT0oTytOKSpldCxkWzEzXT0oSyt6KSpydCxkWzE0XT0oUStZKSpvdCxkWzE1XT0xLGR9ZnVuY3Rpb24gdHQoZCxPLE4seil7dmFyIEssWSxRLGV0LHJ0LG90LGx0LGl0LG50LGF0LGR0PU9bMF0sZ3Q9T1sxXSx1dD1PWzJdLG10PXpbMF0sVHQ9elsxXSx4dD16WzJdLE10PU5bMF0sRXQ9TlsxXSxPdD1OWzJdO3JldHVybiBNYXRoLmFicyhkdC1NdCk8ci5FUFNJTE9OJiZNYXRoLmFicyhndC1FdCk8ci5FUFNJTE9OJiZNYXRoLmFicyh1dC1PdCk8ci5FUFNJTE9OP2MoZCk6KGx0PWR0LU10LGl0PWd0LUV0LG50PXV0LU90LGF0PTEvTWF0aC5oeXBvdChsdCxpdCxudCksbHQqPWF0LGl0Kj1hdCxudCo9YXQsSz1UdCpudC14dCppdCxZPXh0Kmx0LW10Km50LFE9bXQqaXQtVHQqbHQsYXQ9TWF0aC5oeXBvdChLLFksUSksYXQ/KGF0PTEvYXQsSyo9YXQsWSo9YXQsUSo9YXQpOihLPTAsWT0wLFE9MCksZXQ9aXQqUS1udCpZLHJ0PW50KkstbHQqUSxvdD1sdCpZLWl0KkssYXQ9TWF0aC5oeXBvdChldCxydCxvdCksYXQ/KGF0PTEvYXQsZXQqPWF0LHJ0Kj1hdCxvdCo9YXQpOihldD0wLHJ0PTAsb3Q9MCksZFswXT1LLGRbMV09ZXQsZFsyXT1sdCxkWzNdPTAsZFs0XT1ZLGRbNV09cnQsZFs2XT1pdCxkWzddPTAsZFs4XT1RLGRbOV09b3QsZFsxMF09bnQsZFsxMV09MCxkWzEyXT0tKEsqZHQrWSpndCtRKnV0KSxkWzEzXT0tKGV0KmR0K3J0Kmd0K290KnV0KSxkWzE0XT0tKGx0KmR0K2l0Kmd0K250KnV0KSxkWzE1XT0xLGQpfWZ1bmN0aW9uIF8oZCxPLE4seil7dmFyIEs9T1swXSxZPU9bMV0sUT1PWzJdLGV0PXpbMF0scnQ9elsxXSxvdD16WzJdLGx0PUstTlswXSxpdD1ZLU5bMV0sbnQ9US1OWzJdLGF0PWx0Kmx0K2l0Kml0K250Km50O2F0PjAmJihhdD0xL01hdGguc3FydChhdCksbHQqPWF0LGl0Kj1hdCxudCo9YXQpO3ZhciBkdD1ydCpudC1vdCppdCxndD1vdCpsdC1ldCpudCx1dD1ldCppdC1ydCpsdDtyZXR1cm4gYXQ9ZHQqZHQrZ3QqZ3QrdXQqdXQsYXQ+MCYmKGF0PTEvTWF0aC5zcXJ0KGF0KSxkdCo9YXQsZ3QqPWF0LHV0Kj1hdCksZFswXT1kdCxkWzFdPWd0LGRbMl09dXQsZFszXT0wLGRbNF09aXQqdXQtbnQqZ3QsZFs1XT1udCpkdC1sdCp1dCxkWzZdPWx0Kmd0LWl0KmR0LGRbN109MCxkWzhdPWx0LGRbOV09aXQsZFsxMF09bnQsZFsxMV09MCxkWzEyXT1LLGRbMTNdPVksZFsxNF09USxkWzE1XT0xLGR9ZnVuY3Rpb24gc3QoZCl7cmV0dXJuIm1hdDQoIitkWzBdKyIsICIrZFsxXSsiLCAiK2RbMl0rIiwgIitkWzNdKyIsICIrZFs0XSsiLCAiK2RbNV0rIiwgIitkWzZdKyIsICIrZFs3XSsiLCAiK2RbOF0rIiwgIitkWzldKyIsICIrZFsxMF0rIiwgIitkWzExXSsiLCAiK2RbMTJdKyIsICIrZFsxM10rIiwgIitkWzE0XSsiLCAiK2RbMTVdKyIpIn1mdW5jdGlvbiBrKGQpe3JldHVybiBNYXRoLmh5cG90KGRbMF0sZFsxXSxkWzJdLGRbM10sZFs0XSxkWzVdLGRbNl0sZFs3XSxkWzhdLGRbOV0sZFsxMF0sZFsxMV0sZFsxMl0sZFsxM10sZFsxNF0sZFsxNV0pfWZ1bmN0aW9uIGN0KGQsTyxOKXtyZXR1cm4gZFswXT1PWzBdK05bMF0sZFsxXT1PWzFdK05bMV0sZFsyXT1PWzJdK05bMl0sZFszXT1PWzNdK05bM10sZFs0XT1PWzRdK05bNF0sZFs1XT1PWzVdK05bNV0sZFs2XT1PWzZdK05bNl0sZFs3XT1PWzddK05bN10sZFs4XT1PWzhdK05bOF0sZFs5XT1PWzldK05bOV0sZFsxMF09T1sxMF0rTlsxMF0sZFsxMV09T1sxMV0rTlsxMV0sZFsxMl09T1sxMl0rTlsxMl0sZFsxM109T1sxM10rTlsxM10sZFsxNF09T1sxNF0rTlsxNF0sZFsxNV09T1sxNV0rTlsxNV0sZH1mdW5jdGlvbiBmdChkLE8sTil7cmV0dXJuIGRbMF09T1swXS1OWzBdLGRbMV09T1sxXS1OWzFdLGRbMl09T1syXS1OWzJdLGRbM109T1szXS1OWzNdLGRbNF09T1s0XS1OWzRdLGRbNV09T1s1XS1OWzVdLGRbNl09T1s2XS1OWzZdLGRbN109T1s3XS1OWzddLGRbOF09T1s4XS1OWzhdLGRbOV09T1s5XS1OWzldLGRbMTBdPU9bMTBdLU5bMTBdLGRbMTFdPU9bMTFdLU5bMTFdLGRbMTJdPU9bMTJdLU5bMTJdLGRbMTNdPU9bMTNdLU5bMTNdLGRbMTRdPU9bMTRdLU5bMTRdLGRbMTVdPU9bMTVdLU5bMTVdLGR9ZnVuY3Rpb24gVyhkLE8sTil7cmV0dXJuIGRbMF09T1swXSpOLGRbMV09T1sxXSpOLGRbMl09T1syXSpOLGRbM109T1szXSpOLGRbNF09T1s0XSpOLGRbNV09T1s1XSpOLGRbNl09T1s2XSpOLGRbN109T1s3XSpOLGRbOF09T1s4XSpOLGRbOV09T1s5XSpOLGRbMTBdPU9bMTBdKk4sZFsxMV09T1sxMV0qTixkWzEyXT1PWzEyXSpOLGRbMTNdPU9bMTNdKk4sZFsxNF09T1sxNF0qTixkWzE1XT1PWzE1XSpOLGR9ZnVuY3Rpb24gVShkLE8sTix6KXtyZXR1cm4gZFswXT1PWzBdK05bMF0qeixkWzFdPU9bMV0rTlsxXSp6LGRbMl09T1syXStOWzJdKnosZFszXT1PWzNdK05bM10qeixkWzRdPU9bNF0rTls0XSp6LGRbNV09T1s1XStOWzVdKnosZFs2XT1PWzZdK05bNl0qeixkWzddPU9bN10rTls3XSp6LGRbOF09T1s4XStOWzhdKnosZFs5XT1PWzldK05bOV0qeixkWzEwXT1PWzEwXStOWzEwXSp6LGRbMTFdPU9bMTFdK05bMTFdKnosZFsxMl09T1sxMl0rTlsxMl0qeixkWzEzXT1PWzEzXStOWzEzXSp6LGRbMTRdPU9bMTRdK05bMTRdKnosZFsxNV09T1sxNV0rTlsxNV0qeixkfWZ1bmN0aW9uIFYoZCxPKXtyZXR1cm4gZFswXT09PU9bMF0mJmRbMV09PT1PWzFdJiZkWzJdPT09T1syXSYmZFszXT09PU9bM10mJmRbNF09PT1PWzRdJiZkWzVdPT09T1s1XSYmZFs2XT09PU9bNl0mJmRbN109PT1PWzddJiZkWzhdPT09T1s4XSYmZFs5XT09PU9bOV0mJmRbMTBdPT09T1sxMF0mJmRbMTFdPT09T1sxMV0mJmRbMTJdPT09T1sxMl0mJmRbMTNdPT09T1sxM10mJmRbMTRdPT09T1sxNF0mJmRbMTVdPT09T1sxNV19ZnVuY3Rpb24gWChkLE8pe3ZhciBOPWRbMF0sej1kWzFdLEs9ZFsyXSxZPWRbM10sUT1kWzRdLGV0PWRbNV0scnQ9ZFs2XSxvdD1kWzddLGx0PWRbOF0saXQ9ZFs5XSxudD1kWzEwXSxhdD1kWzExXSxkdD1kWzEyXSxndD1kWzEzXSx1dD1kWzE0XSxtdD1kWzE1XSxUdD1PWzBdLHh0PU9bMV0sTXQ9T1syXSxFdD1PWzNdLE90PU9bNF0sV3Q9T1s1XSxOdD1PWzZdLEJ0PU9bN10sanQ9T1s4XSxVdD1PWzldLEZ0PU9bMTBdLHp0PU9bMTFdLEN0PU9bMTJdLEd0PU9bMTNdLF90PU9bMTRdLHRlPU9bMTVdO3JldHVybiBNYXRoLmFicyhOLVR0KTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoTiksTWF0aC5hYnMoVHQpKSYmTWF0aC5hYnMoei14dCk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKHopLE1hdGguYWJzKHh0KSkmJk1hdGguYWJzKEstTXQpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhLKSxNYXRoLmFicyhNdCkpJiZNYXRoLmFicyhZLUV0KTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoWSksTWF0aC5hYnMoRXQpKSYmTWF0aC5hYnMoUS1PdCk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKFEpLE1hdGguYWJzKE90KSkmJk1hdGguYWJzKGV0LVd0KTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoZXQpLE1hdGguYWJzKFd0KSkmJk1hdGguYWJzKHJ0LU50KTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMocnQpLE1hdGguYWJzKE50KSkmJk1hdGguYWJzKG90LUJ0KTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMob3QpLE1hdGguYWJzKEJ0KSkmJk1hdGguYWJzKGx0LWp0KTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMobHQpLE1hdGguYWJzKGp0KSkmJk1hdGguYWJzKGl0LVV0KTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoaXQpLE1hdGguYWJzKFV0KSkmJk1hdGguYWJzKG50LUZ0KTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMobnQpLE1hdGguYWJzKEZ0KSkmJk1hdGguYWJzKGF0LXp0KTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoYXQpLE1hdGguYWJzKHp0KSkmJk1hdGguYWJzKGR0LUN0KTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoZHQpLE1hdGguYWJzKEN0KSkmJk1hdGguYWJzKGd0LUd0KTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoZ3QpLE1hdGguYWJzKEd0KSkmJk1hdGguYWJzKHV0LV90KTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnModXQpLE1hdGguYWJzKF90KSkmJk1hdGguYWJzKG10LXRlKTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMobXQpLE1hdGguYWJzKHRlKSl9dmFyIEI9Qyx3PWZ0fSxmdW5jdGlvbihTLGUsdCl7dC5yKGUpLHQuZChlLCJjcmVhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIHV9KSx0LmQoZSwiaWRlbnRpdHkiLGZ1bmN0aW9uKCl7cmV0dXJuIGF9KSx0LmQoZSwic2V0QXhpc0FuZ2xlIixmdW5jdGlvbigpe3JldHVybiBjfSksdC5kKGUsImdldEF4aXNBbmdsZSIsZnVuY3Rpb24oKXtyZXR1cm4geH0pLHQuZChlLCJnZXRBbmdsZSIsZnVuY3Rpb24oKXtyZXR1cm4gZn0pLHQuZChlLCJtdWx0aXBseSIsZnVuY3Rpb24oKXtyZXR1cm4gdn0pLHQuZChlLCJyb3RhdGVYIixmdW5jdGlvbigpe3JldHVybiBwfSksdC5kKGUsInJvdGF0ZVkiLGZ1bmN0aW9uKCl7cmV0dXJuIEN9KSx0LmQoZSwicm90YXRlWiIsZnVuY3Rpb24oKXtyZXR1cm4gTX0pLHQuZChlLCJjYWxjdWxhdGVXIixmdW5jdGlvbigpe3JldHVybiBtfSksdC5kKGUsImV4cCIsZnVuY3Rpb24oKXtyZXR1cm4geX0pLHQuZChlLCJsbiIsZnVuY3Rpb24oKXtyZXR1cm4gbn0pLHQuZChlLCJwb3ciLGZ1bmN0aW9uKCl7cmV0dXJuIG99KSx0LmQoZSwic2xlcnAiLGZ1bmN0aW9uKCl7cmV0dXJuIHN9KSx0LmQoZSwicmFuZG9tIixmdW5jdGlvbigpe3JldHVybiBsfSksdC5kKGUsImludmVydCIsZnVuY3Rpb24oKXtyZXR1cm4gRX0pLHQuZChlLCJjb25qdWdhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIFR9KSx0LmQoZSwiZnJvbU1hdDMiLGZ1bmN0aW9uKCl7cmV0dXJuIGJ9KSx0LmQoZSwiZnJvbUV1bGVyIixmdW5jdGlvbigpe3JldHVybiBJfSksdC5kKGUsInN0ciIsZnVuY3Rpb24oKXtyZXR1cm4gUH0pLHQuZChlLCJjbG9uZSIsZnVuY3Rpb24oKXtyZXR1cm4gTH0pLHQuZChlLCJmcm9tVmFsdWVzIixmdW5jdGlvbigpe3JldHVybiBEfSksdC5kKGUsImNvcHkiLGZ1bmN0aW9uKCl7cmV0dXJuIFJ9KSx0LmQoZSwic2V0IixmdW5jdGlvbigpe3JldHVybiBBfSksdC5kKGUsImFkZCIsZnVuY3Rpb24oKXtyZXR1cm4gan0pLHQuZChlLCJtdWwiLGZ1bmN0aW9uKCl7cmV0dXJuIEd9KSx0LmQoZSwic2NhbGUiLGZ1bmN0aW9uKCl7cmV0dXJuIEh9KSx0LmQoZSwiZG90IixmdW5jdGlvbigpe3JldHVybiBafSksdC5kKGUsImxlcnAiLGZ1bmN0aW9uKCl7cmV0dXJuIHF9KSx0LmQoZSwibGVuZ3RoIixmdW5jdGlvbigpe3JldHVybiBGfSksdC5kKGUsImxlbiIsZnVuY3Rpb24oKXtyZXR1cm4gJH0pLHQuZChlLCJzcXVhcmVkTGVuZ3RoIixmdW5jdGlvbigpe3JldHVybiBKfSksdC5kKGUsInNxckxlbiIsZnVuY3Rpb24oKXtyZXR1cm4gdHR9KSx0LmQoZSwibm9ybWFsaXplIixmdW5jdGlvbigpe3JldHVybiBffSksdC5kKGUsImV4YWN0RXF1YWxzIixmdW5jdGlvbigpe3JldHVybiBzdH0pLHQuZChlLCJlcXVhbHMiLGZ1bmN0aW9uKCl7cmV0dXJuIGt9KSx0LmQoZSwicm90YXRpb25UbyIsZnVuY3Rpb24oKXtyZXR1cm4gY3R9KSx0LmQoZSwic3FsZXJwIixmdW5jdGlvbigpe3JldHVybiBmdH0pLHQuZChlLCJzZXRBeGVzIixmdW5jdGlvbigpe3JldHVybiBXfSk7dmFyIHI9dCgyKSxpPXQoNSksaD10KDgpLGc9dCg5KTtmdW5jdGlvbiB1KCl7dmFyIFU9bmV3IHIuQVJSQVlfVFlQRSg0KTtyZXR1cm4gci5BUlJBWV9UWVBFIT1GbG9hdDMyQXJyYXkmJihVWzBdPTAsVVsxXT0wLFVbMl09MCksVVszXT0xLFV9ZnVuY3Rpb24gYShVKXtyZXR1cm4gVVswXT0wLFVbMV09MCxVWzJdPTAsVVszXT0xLFV9ZnVuY3Rpb24gYyhVLFYsWCl7WD1YKi41O3ZhciBCPU1hdGguc2luKFgpO3JldHVybiBVWzBdPUIqVlswXSxVWzFdPUIqVlsxXSxVWzJdPUIqVlsyXSxVWzNdPU1hdGguY29zKFgpLFV9ZnVuY3Rpb24geChVLFYpe3ZhciBYPU1hdGguYWNvcyhWWzNdKSoyLEI9TWF0aC5zaW4oWC8yKTtyZXR1cm4gQj5yLkVQU0lMT04/KFVbMF09VlswXS9CLFVbMV09VlsxXS9CLFVbMl09VlsyXS9CKTooVVswXT0xLFVbMV09MCxVWzJdPTApLFh9ZnVuY3Rpb24gZihVLFYpe3ZhciBYPVooVSxWKTtyZXR1cm4gTWF0aC5hY29zKDIqWCpYLTEpfWZ1bmN0aW9uIHYoVSxWLFgpe3ZhciBCPVZbMF0sdz1WWzFdLGQ9VlsyXSxPPVZbM10sTj1YWzBdLHo9WFsxXSxLPVhbMl0sWT1YWzNdO3JldHVybiBVWzBdPUIqWStPKk4rdypLLWQqeixVWzFdPXcqWStPKnorZCpOLUIqSyxVWzJdPWQqWStPKksrQip6LXcqTixVWzNdPU8qWS1CKk4tdyp6LWQqSyxVfWZ1bmN0aW9uIHAoVSxWLFgpe1gqPS41O3ZhciBCPVZbMF0sdz1WWzFdLGQ9VlsyXSxPPVZbM10sTj1NYXRoLnNpbihYKSx6PU1hdGguY29zKFgpO3JldHVybiBVWzBdPUIqeitPKk4sVVsxXT13KnorZCpOLFVbMl09ZCp6LXcqTixVWzNdPU8qei1CKk4sVX1mdW5jdGlvbiBDKFUsVixYKXtYKj0uNTt2YXIgQj1WWzBdLHc9VlsxXSxkPVZbMl0sTz1WWzNdLE49TWF0aC5zaW4oWCksej1NYXRoLmNvcyhYKTtyZXR1cm4gVVswXT1CKnotZCpOLFVbMV09dyp6K08qTixVWzJdPWQqeitCKk4sVVszXT1PKnotdypOLFV9ZnVuY3Rpb24gTShVLFYsWCl7WCo9LjU7dmFyIEI9VlswXSx3PVZbMV0sZD1WWzJdLE89VlszXSxOPU1hdGguc2luKFgpLHo9TWF0aC5jb3MoWCk7cmV0dXJuIFVbMF09Qip6K3cqTixVWzFdPXcqei1CKk4sVVsyXT1kKnorTypOLFVbM109Typ6LWQqTixVfWZ1bmN0aW9uIG0oVSxWKXt2YXIgWD1WWzBdLEI9VlsxXSx3PVZbMl07cmV0dXJuIFVbMF09WCxVWzFdPUIsVVsyXT13LFVbM109TWF0aC5zcXJ0KE1hdGguYWJzKDEtWCpYLUIqQi13KncpKSxVfWZ1bmN0aW9uIHkoVSxWKXt2YXIgWD1WWzBdLEI9VlsxXSx3PVZbMl0sZD1WWzNdLE89TWF0aC5zcXJ0KFgqWCtCKkIrdyp3KSxOPU1hdGguZXhwKGQpLHo9Tz4wP04qTWF0aC5zaW4oTykvTzowO3JldHVybiBVWzBdPVgqeixVWzFdPUIqeixVWzJdPXcqeixVWzNdPU4qTWF0aC5jb3MoTyksVX1mdW5jdGlvbiBuKFUsVil7dmFyIFg9VlswXSxCPVZbMV0sdz1WWzJdLGQ9VlszXSxPPU1hdGguc3FydChYKlgrQipCK3cqdyksTj1PPjA/TWF0aC5hdGFuMihPLGQpL086MDtyZXR1cm4gVVswXT1YKk4sVVsxXT1CKk4sVVsyXT13Kk4sVVszXT0uNSpNYXRoLmxvZyhYKlgrQipCK3cqdytkKmQpLFV9ZnVuY3Rpb24gbyhVLFYsWCl7cmV0dXJuIG4oVSxWKSxIKFUsVSxYKSx5KFUsVSksVX1mdW5jdGlvbiBzKFUsVixYLEIpe3ZhciB3PVZbMF0sZD1WWzFdLE89VlsyXSxOPVZbM10sej1YWzBdLEs9WFsxXSxZPVhbMl0sUT1YWzNdLGV0LHJ0LG90LGx0LGl0O3JldHVybiBydD13KnorZCpLK08qWStOKlEscnQ8MCYmKHJ0PS1ydCx6PS16LEs9LUssWT0tWSxRPS1RKSwxLXJ0PnIuRVBTSUxPTj8oZXQ9TWF0aC5hY29zKHJ0KSxvdD1NYXRoLnNpbihldCksbHQ9TWF0aC5zaW4oKDEtQikqZXQpL290LGl0PU1hdGguc2luKEIqZXQpL290KToobHQ9MS1CLGl0PUIpLFVbMF09bHQqdytpdCp6LFVbMV09bHQqZCtpdCpLLFVbMl09bHQqTytpdCpZLFVbM109bHQqTitpdCpRLFV9ZnVuY3Rpb24gbChVKXt2YXIgVj1yLlJBTkRPTSgpLFg9ci5SQU5ET00oKSxCPXIuUkFORE9NKCksdz1NYXRoLnNxcnQoMS1WKSxkPU1hdGguc3FydChWKTtyZXR1cm4gVVswXT13Kk1hdGguc2luKDIqTWF0aC5QSSpYKSxVWzFdPXcqTWF0aC5jb3MoMipNYXRoLlBJKlgpLFVbMl09ZCpNYXRoLnNpbigyKk1hdGguUEkqQiksVVszXT1kKk1hdGguY29zKDIqTWF0aC5QSSpCKSxVfWZ1bmN0aW9uIEUoVSxWKXt2YXIgWD1WWzBdLEI9VlsxXSx3PVZbMl0sZD1WWzNdLE89WCpYK0IqQit3KncrZCpkLE49Tz8xL086MDtyZXR1cm4gVVswXT0tWCpOLFVbMV09LUIqTixVWzJdPS13Kk4sVVszXT1kKk4sVX1mdW5jdGlvbiBUKFUsVil7cmV0dXJuIFVbMF09LVZbMF0sVVsxXT0tVlsxXSxVWzJdPS1WWzJdLFVbM109VlszXSxVfWZ1bmN0aW9uIGIoVSxWKXt2YXIgWD1WWzBdK1ZbNF0rVls4XSxCO2lmKFg+MClCPU1hdGguc3FydChYKzEpLFVbM109LjUqQixCPS41L0IsVVswXT0oVls1XS1WWzddKSpCLFVbMV09KFZbNl0tVlsyXSkqQixVWzJdPShWWzFdLVZbM10pKkI7ZWxzZXt2YXIgdz0wO1ZbNF0+VlswXSYmKHc9MSksVls4XT5WW3cqMyt3XSYmKHc9Mik7dmFyIGQ9KHcrMSklMyxPPSh3KzIpJTM7Qj1NYXRoLnNxcnQoVlt3KjMrd10tVltkKjMrZF0tVltPKjMrT10rMSksVVt3XT0uNSpCLEI9LjUvQixVWzNdPShWW2QqMytPXS1WW08qMytkXSkqQixVW2RdPShWW2QqMyt3XStWW3cqMytkXSkqQixVW09dPShWW08qMyt3XStWW3cqMytPXSkqQn1yZXR1cm4gVX1mdW5jdGlvbiBJKFUsVixYLEIpe3ZhciB3PS41Kk1hdGguUEkvMTgwO1YqPXcsWCo9dyxCKj13O3ZhciBkPU1hdGguc2luKFYpLE89TWF0aC5jb3MoViksTj1NYXRoLnNpbihYKSx6PU1hdGguY29zKFgpLEs9TWF0aC5zaW4oQiksWT1NYXRoLmNvcyhCKTtyZXR1cm4gVVswXT1kKnoqWS1PKk4qSyxVWzFdPU8qTipZK2QqeipLLFVbMl09Typ6KkstZCpOKlksVVszXT1PKnoqWStkKk4qSyxVfWZ1bmN0aW9uIFAoVSl7cmV0dXJuInF1YXQoIitVWzBdKyIsICIrVVsxXSsiLCAiK1VbMl0rIiwgIitVWzNdKyIpIn12YXIgTD1nLmNsb25lLEQ9Zy5mcm9tVmFsdWVzLFI9Zy5jb3B5LEE9Zy5zZXQsaj1nLmFkZCxHPXYsSD1nLnNjYWxlLFo9Zy5kb3QscT1nLmxlcnAsRj1nLmxlbmd0aCwkPUYsSj1nLnNxdWFyZWRMZW5ndGgsdHQ9SixfPWcubm9ybWFsaXplLHN0PWcuZXhhY3RFcXVhbHMsaz1nLmVxdWFscyxjdD1mdW5jdGlvbigpe3ZhciBVPWguY3JlYXRlKCksVj1oLmZyb21WYWx1ZXMoMSwwLDApLFg9aC5mcm9tVmFsdWVzKDAsMSwwKTtyZXR1cm4gZnVuY3Rpb24oQix3LGQpe3ZhciBPPWguZG90KHcsZCk7cmV0dXJuIE88LS45OTk5OTk/KGguY3Jvc3MoVSxWLHcpLGgubGVuKFUpPDFlLTYmJmguY3Jvc3MoVSxYLHcpLGgubm9ybWFsaXplKFUsVSksYyhCLFUsTWF0aC5QSSksQik6Tz4uOTk5OTk5PyhCWzBdPTAsQlsxXT0wLEJbMl09MCxCWzNdPTEsQik6KGguY3Jvc3MoVSx3LGQpLEJbMF09VVswXSxCWzFdPVVbMV0sQlsyXT1VWzJdLEJbM109MStPLF8oQixCKSl9fSgpLGZ0PWZ1bmN0aW9uKCl7dmFyIFU9dSgpLFY9dSgpO3JldHVybiBmdW5jdGlvbihYLEIsdyxkLE8sTil7cmV0dXJuIHMoVSxCLE8sTikscyhWLHcsZCxOKSxzKFgsVSxWLDIqTiooMS1OKSksWH19KCksVz1mdW5jdGlvbigpe3ZhciBVPWkuY3JlYXRlKCk7cmV0dXJuIGZ1bmN0aW9uKFYsWCxCLHcpe3JldHVybiBVWzBdPUJbMF0sVVszXT1CWzFdLFVbNl09QlsyXSxVWzFdPXdbMF0sVVs0XT13WzFdLFVbN109d1syXSxVWzJdPS1YWzBdLFVbNV09LVhbMV0sVVs4XT0tWFsyXSxfKFYsYihWLFUpKX19KCl9LGZ1bmN0aW9uKFMsZSx0KXt0LnIoZSksdC5kKGUsImNyZWF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gaX0pLHQuZChlLCJjbG9uZSIsZnVuY3Rpb24oKXtyZXR1cm4gaH0pLHQuZChlLCJsZW5ndGgiLGZ1bmN0aW9uKCl7cmV0dXJuIGd9KSx0LmQoZSwiZnJvbVZhbHVlcyIsZnVuY3Rpb24oKXtyZXR1cm4gdX0pLHQuZChlLCJjb3B5IixmdW5jdGlvbigpe3JldHVybiBhfSksdC5kKGUsInNldCIsZnVuY3Rpb24oKXtyZXR1cm4gY30pLHQuZChlLCJhZGQiLGZ1bmN0aW9uKCl7cmV0dXJuIHh9KSx0LmQoZSwic3VidHJhY3QiLGZ1bmN0aW9uKCl7cmV0dXJuIGZ9KSx0LmQoZSwibXVsdGlwbHkiLGZ1bmN0aW9uKCl7cmV0dXJuIHZ9KSx0LmQoZSwiZGl2aWRlIixmdW5jdGlvbigpe3JldHVybiBwfSksdC5kKGUsImNlaWwiLGZ1bmN0aW9uKCl7cmV0dXJuIEN9KSx0LmQoZSwiZmxvb3IiLGZ1bmN0aW9uKCl7cmV0dXJuIE19KSx0LmQoZSwibWluIixmdW5jdGlvbigpe3JldHVybiBtfSksdC5kKGUsIm1heCIsZnVuY3Rpb24oKXtyZXR1cm4geX0pLHQuZChlLCJyb3VuZCIsZnVuY3Rpb24oKXtyZXR1cm4gbn0pLHQuZChlLCJzY2FsZSIsZnVuY3Rpb24oKXtyZXR1cm4gb30pLHQuZChlLCJzY2FsZUFuZEFkZCIsZnVuY3Rpb24oKXtyZXR1cm4gc30pLHQuZChlLCJkaXN0YW5jZSIsZnVuY3Rpb24oKXtyZXR1cm4gbH0pLHQuZChlLCJzcXVhcmVkRGlzdGFuY2UiLGZ1bmN0aW9uKCl7cmV0dXJuIEV9KSx0LmQoZSwic3F1YXJlZExlbmd0aCIsZnVuY3Rpb24oKXtyZXR1cm4gVH0pLHQuZChlLCJuZWdhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIGJ9KSx0LmQoZSwiaW52ZXJzZSIsZnVuY3Rpb24oKXtyZXR1cm4gSX0pLHQuZChlLCJub3JtYWxpemUiLGZ1bmN0aW9uKCl7cmV0dXJuIFB9KSx0LmQoZSwiZG90IixmdW5jdGlvbigpe3JldHVybiBMfSksdC5kKGUsImNyb3NzIixmdW5jdGlvbigpe3JldHVybiBEfSksdC5kKGUsImxlcnAiLGZ1bmN0aW9uKCl7cmV0dXJuIFJ9KSx0LmQoZSwiaGVybWl0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gQX0pLHQuZChlLCJiZXppZXIiLGZ1bmN0aW9uKCl7cmV0dXJuIGp9KSx0LmQoZSwicmFuZG9tIixmdW5jdGlvbigpe3JldHVybiBHfSksdC5kKGUsInRyYW5zZm9ybU1hdDQiLGZ1bmN0aW9uKCl7cmV0dXJuIEh9KSx0LmQoZSwidHJhbnNmb3JtTWF0MyIsZnVuY3Rpb24oKXtyZXR1cm4gWn0pLHQuZChlLCJ0cmFuc2Zvcm1RdWF0IixmdW5jdGlvbigpe3JldHVybiBxfSksdC5kKGUsInJvdGF0ZVgiLGZ1bmN0aW9uKCl7cmV0dXJuIEZ9KSx0LmQoZSwicm90YXRlWSIsZnVuY3Rpb24oKXtyZXR1cm4gJH0pLHQuZChlLCJyb3RhdGVaIixmdW5jdGlvbigpe3JldHVybiBKfSksdC5kKGUsImFuZ2xlIixmdW5jdGlvbigpe3JldHVybiB0dH0pLHQuZChlLCJ6ZXJvIixmdW5jdGlvbigpe3JldHVybiBffSksdC5kKGUsInN0ciIsZnVuY3Rpb24oKXtyZXR1cm4gc3R9KSx0LmQoZSwiZXhhY3RFcXVhbHMiLGZ1bmN0aW9uKCl7cmV0dXJuIGt9KSx0LmQoZSwiZXF1YWxzIixmdW5jdGlvbigpe3JldHVybiBjdH0pLHQuZChlLCJzdWIiLGZ1bmN0aW9uKCl7cmV0dXJuIGZ0fSksdC5kKGUsIm11bCIsZnVuY3Rpb24oKXtyZXR1cm4gV30pLHQuZChlLCJkaXYiLGZ1bmN0aW9uKCl7cmV0dXJuIFV9KSx0LmQoZSwiZGlzdCIsZnVuY3Rpb24oKXtyZXR1cm4gVn0pLHQuZChlLCJzcXJEaXN0IixmdW5jdGlvbigpe3JldHVybiBYfSksdC5kKGUsImxlbiIsZnVuY3Rpb24oKXtyZXR1cm4gQn0pLHQuZChlLCJzcXJMZW4iLGZ1bmN0aW9uKCl7cmV0dXJuIHd9KSx0LmQoZSwiZm9yRWFjaCIsZnVuY3Rpb24oKXtyZXR1cm4gZH0pO3ZhciByPXQoMik7ZnVuY3Rpb24gaSgpe3ZhciBPPW5ldyByLkFSUkFZX1RZUEUoMyk7cmV0dXJuIHIuQVJSQVlfVFlQRSE9RmxvYXQzMkFycmF5JiYoT1swXT0wLE9bMV09MCxPWzJdPTApLE99ZnVuY3Rpb24gaChPKXt2YXIgTj1uZXcgci5BUlJBWV9UWVBFKDMpO3JldHVybiBOWzBdPU9bMF0sTlsxXT1PWzFdLE5bMl09T1syXSxOfWZ1bmN0aW9uIGcoTyl7dmFyIE49T1swXSx6PU9bMV0sSz1PWzJdO3JldHVybiBNYXRoLmh5cG90KE4seixLKX1mdW5jdGlvbiB1KE8sTix6KXt2YXIgSz1uZXcgci5BUlJBWV9UWVBFKDMpO3JldHVybiBLWzBdPU8sS1sxXT1OLEtbMl09eixLfWZ1bmN0aW9uIGEoTyxOKXtyZXR1cm4gT1swXT1OWzBdLE9bMV09TlsxXSxPWzJdPU5bMl0sT31mdW5jdGlvbiBjKE8sTix6LEspe3JldHVybiBPWzBdPU4sT1sxXT16LE9bMl09SyxPfWZ1bmN0aW9uIHgoTyxOLHope3JldHVybiBPWzBdPU5bMF0relswXSxPWzFdPU5bMV0relsxXSxPWzJdPU5bMl0relsyXSxPfWZ1bmN0aW9uIGYoTyxOLHope3JldHVybiBPWzBdPU5bMF0telswXSxPWzFdPU5bMV0telsxXSxPWzJdPU5bMl0telsyXSxPfWZ1bmN0aW9uIHYoTyxOLHope3JldHVybiBPWzBdPU5bMF0qelswXSxPWzFdPU5bMV0qelsxXSxPWzJdPU5bMl0qelsyXSxPfWZ1bmN0aW9uIHAoTyxOLHope3JldHVybiBPWzBdPU5bMF0velswXSxPWzFdPU5bMV0velsxXSxPWzJdPU5bMl0velsyXSxPfWZ1bmN0aW9uIEMoTyxOKXtyZXR1cm4gT1swXT1NYXRoLmNlaWwoTlswXSksT1sxXT1NYXRoLmNlaWwoTlsxXSksT1syXT1NYXRoLmNlaWwoTlsyXSksT31mdW5jdGlvbiBNKE8sTil7cmV0dXJuIE9bMF09TWF0aC5mbG9vcihOWzBdKSxPWzFdPU1hdGguZmxvb3IoTlsxXSksT1syXT1NYXRoLmZsb29yKE5bMl0pLE99ZnVuY3Rpb24gbShPLE4seil7cmV0dXJuIE9bMF09TWF0aC5taW4oTlswXSx6WzBdKSxPWzFdPU1hdGgubWluKE5bMV0selsxXSksT1syXT1NYXRoLm1pbihOWzJdLHpbMl0pLE99ZnVuY3Rpb24geShPLE4seil7cmV0dXJuIE9bMF09TWF0aC5tYXgoTlswXSx6WzBdKSxPWzFdPU1hdGgubWF4KE5bMV0selsxXSksT1syXT1NYXRoLm1heChOWzJdLHpbMl0pLE99ZnVuY3Rpb24gbihPLE4pe3JldHVybiBPWzBdPU1hdGgucm91bmQoTlswXSksT1sxXT1NYXRoLnJvdW5kKE5bMV0pLE9bMl09TWF0aC5yb3VuZChOWzJdKSxPfWZ1bmN0aW9uIG8oTyxOLHope3JldHVybiBPWzBdPU5bMF0qeixPWzFdPU5bMV0qeixPWzJdPU5bMl0qeixPfWZ1bmN0aW9uIHMoTyxOLHosSyl7cmV0dXJuIE9bMF09TlswXSt6WzBdKkssT1sxXT1OWzFdK3pbMV0qSyxPWzJdPU5bMl0relsyXSpLLE99ZnVuY3Rpb24gbChPLE4pe3ZhciB6PU5bMF0tT1swXSxLPU5bMV0tT1sxXSxZPU5bMl0tT1syXTtyZXR1cm4gTWF0aC5oeXBvdCh6LEssWSl9ZnVuY3Rpb24gRShPLE4pe3ZhciB6PU5bMF0tT1swXSxLPU5bMV0tT1sxXSxZPU5bMl0tT1syXTtyZXR1cm4geip6K0sqSytZKll9ZnVuY3Rpb24gVChPKXt2YXIgTj1PWzBdLHo9T1sxXSxLPU9bMl07cmV0dXJuIE4qTit6KnorSypLfWZ1bmN0aW9uIGIoTyxOKXtyZXR1cm4gT1swXT0tTlswXSxPWzFdPS1OWzFdLE9bMl09LU5bMl0sT31mdW5jdGlvbiBJKE8sTil7cmV0dXJuIE9bMF09MS9OWzBdLE9bMV09MS9OWzFdLE9bMl09MS9OWzJdLE99ZnVuY3Rpb24gUChPLE4pe3ZhciB6PU5bMF0sSz1OWzFdLFk9TlsyXSxRPXoqeitLKksrWSpZO3JldHVybiBRPjAmJihRPTEvTWF0aC5zcXJ0KFEpKSxPWzBdPU5bMF0qUSxPWzFdPU5bMV0qUSxPWzJdPU5bMl0qUSxPfWZ1bmN0aW9uIEwoTyxOKXtyZXR1cm4gT1swXSpOWzBdK09bMV0qTlsxXStPWzJdKk5bMl19ZnVuY3Rpb24gRChPLE4seil7dmFyIEs9TlswXSxZPU5bMV0sUT1OWzJdLGV0PXpbMF0scnQ9elsxXSxvdD16WzJdO3JldHVybiBPWzBdPVkqb3QtUSpydCxPWzFdPVEqZXQtSypvdCxPWzJdPUsqcnQtWSpldCxPfWZ1bmN0aW9uIFIoTyxOLHosSyl7dmFyIFk9TlswXSxRPU5bMV0sZXQ9TlsyXTtyZXR1cm4gT1swXT1ZK0sqKHpbMF0tWSksT1sxXT1RK0sqKHpbMV0tUSksT1syXT1ldCtLKih6WzJdLWV0KSxPfWZ1bmN0aW9uIEEoTyxOLHosSyxZLFEpe3ZhciBldD1RKlEscnQ9ZXQqKDIqUS0zKSsxLG90PWV0KihRLTIpK1EsbHQ9ZXQqKFEtMSksaXQ9ZXQqKDMtMipRKTtyZXR1cm4gT1swXT1OWzBdKnJ0K3pbMF0qb3QrS1swXSpsdCtZWzBdKml0LE9bMV09TlsxXSpydCt6WzFdKm90K0tbMV0qbHQrWVsxXSppdCxPWzJdPU5bMl0qcnQrelsyXSpvdCtLWzJdKmx0K1lbMl0qaXQsT31mdW5jdGlvbiBqKE8sTix6LEssWSxRKXt2YXIgZXQ9MS1RLHJ0PWV0KmV0LG90PVEqUSxsdD1ydCpldCxpdD0zKlEqcnQsbnQ9MypvdCpldCxhdD1vdCpRO3JldHVybiBPWzBdPU5bMF0qbHQrelswXSppdCtLWzBdKm50K1lbMF0qYXQsT1sxXT1OWzFdKmx0K3pbMV0qaXQrS1sxXSpudCtZWzFdKmF0LE9bMl09TlsyXSpsdCt6WzJdKml0K0tbMl0qbnQrWVsyXSphdCxPfWZ1bmN0aW9uIEcoTyxOKXtOPU58fDE7dmFyIHo9ci5SQU5ET00oKSoyKk1hdGguUEksSz1yLlJBTkRPTSgpKjItMSxZPU1hdGguc3FydCgxLUsqSykqTjtyZXR1cm4gT1swXT1NYXRoLmNvcyh6KSpZLE9bMV09TWF0aC5zaW4oeikqWSxPWzJdPUsqTixPfWZ1bmN0aW9uIEgoTyxOLHope3ZhciBLPU5bMF0sWT1OWzFdLFE9TlsyXSxldD16WzNdKksrels3XSpZK3pbMTFdKlErelsxNV07cmV0dXJuIGV0PWV0fHwxLE9bMF09KHpbMF0qSyt6WzRdKlkrels4XSpRK3pbMTJdKS9ldCxPWzFdPSh6WzFdKksrels1XSpZK3pbOV0qUSt6WzEzXSkvZXQsT1syXT0oelsyXSpLK3pbNl0qWSt6WzEwXSpRK3pbMTRdKS9ldCxPfWZ1bmN0aW9uIFooTyxOLHope3ZhciBLPU5bMF0sWT1OWzFdLFE9TlsyXTtyZXR1cm4gT1swXT1LKnpbMF0rWSp6WzNdK1Eqels2XSxPWzFdPUsqelsxXStZKnpbNF0rUSp6WzddLE9bMl09Syp6WzJdK1kqels1XStRKnpbOF0sT31mdW5jdGlvbiBxKE8sTix6KXt2YXIgSz16WzBdLFk9elsxXSxRPXpbMl0sZXQ9elszXSxydD1OWzBdLG90PU5bMV0sbHQ9TlsyXSxpdD1ZKmx0LVEqb3QsbnQ9USpydC1LKmx0LGF0PUsqb3QtWSpydCxkdD1ZKmF0LVEqbnQsZ3Q9USppdC1LKmF0LHV0PUsqbnQtWSppdCxtdD1ldCoyO3JldHVybiBpdCo9bXQsbnQqPW10LGF0Kj1tdCxkdCo9MixndCo9Mix1dCo9MixPWzBdPXJ0K2l0K2R0LE9bMV09b3QrbnQrZ3QsT1syXT1sdCthdCt1dCxPfWZ1bmN0aW9uIEYoTyxOLHosSyl7dmFyIFk9W10sUT1bXTtyZXR1cm4gWVswXT1OWzBdLXpbMF0sWVsxXT1OWzFdLXpbMV0sWVsyXT1OWzJdLXpbMl0sUVswXT1ZWzBdLFFbMV09WVsxXSpNYXRoLmNvcyhLKS1ZWzJdKk1hdGguc2luKEspLFFbMl09WVsxXSpNYXRoLnNpbihLKStZWzJdKk1hdGguY29zKEspLE9bMF09UVswXSt6WzBdLE9bMV09UVsxXSt6WzFdLE9bMl09UVsyXSt6WzJdLE99ZnVuY3Rpb24gJChPLE4seixLKXt2YXIgWT1bXSxRPVtdO3JldHVybiBZWzBdPU5bMF0telswXSxZWzFdPU5bMV0telsxXSxZWzJdPU5bMl0telsyXSxRWzBdPVlbMl0qTWF0aC5zaW4oSykrWVswXSpNYXRoLmNvcyhLKSxRWzFdPVlbMV0sUVsyXT1ZWzJdKk1hdGguY29zKEspLVlbMF0qTWF0aC5zaW4oSyksT1swXT1RWzBdK3pbMF0sT1sxXT1RWzFdK3pbMV0sT1syXT1RWzJdK3pbMl0sT31mdW5jdGlvbiBKKE8sTix6LEspe3ZhciBZPVtdLFE9W107cmV0dXJuIFlbMF09TlswXS16WzBdLFlbMV09TlsxXS16WzFdLFlbMl09TlsyXS16WzJdLFFbMF09WVswXSpNYXRoLmNvcyhLKS1ZWzFdKk1hdGguc2luKEspLFFbMV09WVswXSpNYXRoLnNpbihLKStZWzFdKk1hdGguY29zKEspLFFbMl09WVsyXSxPWzBdPVFbMF0relswXSxPWzFdPVFbMV0relsxXSxPWzJdPVFbMl0relsyXSxPfWZ1bmN0aW9uIHR0KE8sTil7dmFyIHo9T1swXSxLPU9bMV0sWT1PWzJdLFE9TlswXSxldD1OWzFdLHJ0PU5bMl0sb3Q9TWF0aC5zcXJ0KHoqeitLKksrWSpZKSxsdD1NYXRoLnNxcnQoUSpRK2V0KmV0K3J0KnJ0KSxpdD1vdCpsdCxudD1pdCYmTChPLE4pL2l0O3JldHVybiBNYXRoLmFjb3MoTWF0aC5taW4oTWF0aC5tYXgobnQsLTEpLDEpKX1mdW5jdGlvbiBfKE8pe3JldHVybiBPWzBdPTAsT1sxXT0wLE9bMl09MCxPfWZ1bmN0aW9uIHN0KE8pe3JldHVybiJ2ZWMzKCIrT1swXSsiLCAiK09bMV0rIiwgIitPWzJdKyIpIn1mdW5jdGlvbiBrKE8sTil7cmV0dXJuIE9bMF09PT1OWzBdJiZPWzFdPT09TlsxXSYmT1syXT09PU5bMl19ZnVuY3Rpb24gY3QoTyxOKXt2YXIgej1PWzBdLEs9T1sxXSxZPU9bMl0sUT1OWzBdLGV0PU5bMV0scnQ9TlsyXTtyZXR1cm4gTWF0aC5hYnMoei1RKTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoeiksTWF0aC5hYnMoUSkpJiZNYXRoLmFicyhLLWV0KTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoSyksTWF0aC5hYnMoZXQpKSYmTWF0aC5hYnMoWS1ydCk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKFkpLE1hdGguYWJzKHJ0KSl9dmFyIGZ0PWYsVz12LFU9cCxWPWwsWD1FLEI9Zyx3PVQsZD1mdW5jdGlvbigpe3ZhciBPPWkoKTtyZXR1cm4gZnVuY3Rpb24oTix6LEssWSxRLGV0KXt2YXIgcnQsb3Q7Zm9yKHp8fCh6PTMpLEt8fChLPTApLFk/b3Q9TWF0aC5taW4oWSp6K0ssTi5sZW5ndGgpOm90PU4ubGVuZ3RoLHJ0PUs7cnQ8b3Q7cnQrPXopT1swXT1OW3J0XSxPWzFdPU5bcnQrMV0sT1syXT1OW3J0KzJdLFEoTyxPLGV0KSxOW3J0XT1PWzBdLE5bcnQrMV09T1sxXSxOW3J0KzJdPU9bMl07cmV0dXJuIE59fSgpfSxmdW5jdGlvbihTLGUsdCl7dC5yKGUpLHQuZChlLCJjcmVhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIGl9KSx0LmQoZSwiY2xvbmUiLGZ1bmN0aW9uKCl7cmV0dXJuIGh9KSx0LmQoZSwiZnJvbVZhbHVlcyIsZnVuY3Rpb24oKXtyZXR1cm4gZ30pLHQuZChlLCJjb3B5IixmdW5jdGlvbigpe3JldHVybiB1fSksdC5kKGUsInNldCIsZnVuY3Rpb24oKXtyZXR1cm4gYX0pLHQuZChlLCJhZGQiLGZ1bmN0aW9uKCl7cmV0dXJuIGN9KSx0LmQoZSwic3VidHJhY3QiLGZ1bmN0aW9uKCl7cmV0dXJuIHh9KSx0LmQoZSwibXVsdGlwbHkiLGZ1bmN0aW9uKCl7cmV0dXJuIGZ9KSx0LmQoZSwiZGl2aWRlIixmdW5jdGlvbigpe3JldHVybiB2fSksdC5kKGUsImNlaWwiLGZ1bmN0aW9uKCl7cmV0dXJuIHB9KSx0LmQoZSwiZmxvb3IiLGZ1bmN0aW9uKCl7cmV0dXJuIEN9KSx0LmQoZSwibWluIixmdW5jdGlvbigpe3JldHVybiBNfSksdC5kKGUsIm1heCIsZnVuY3Rpb24oKXtyZXR1cm4gbX0pLHQuZChlLCJyb3VuZCIsZnVuY3Rpb24oKXtyZXR1cm4geX0pLHQuZChlLCJzY2FsZSIsZnVuY3Rpb24oKXtyZXR1cm4gbn0pLHQuZChlLCJzY2FsZUFuZEFkZCIsZnVuY3Rpb24oKXtyZXR1cm4gb30pLHQuZChlLCJkaXN0YW5jZSIsZnVuY3Rpb24oKXtyZXR1cm4gc30pLHQuZChlLCJzcXVhcmVkRGlzdGFuY2UiLGZ1bmN0aW9uKCl7cmV0dXJuIGx9KSx0LmQoZSwibGVuZ3RoIixmdW5jdGlvbigpe3JldHVybiBFfSksdC5kKGUsInNxdWFyZWRMZW5ndGgiLGZ1bmN0aW9uKCl7cmV0dXJuIFR9KSx0LmQoZSwibmVnYXRlIixmdW5jdGlvbigpe3JldHVybiBifSksdC5kKGUsImludmVyc2UiLGZ1bmN0aW9uKCl7cmV0dXJuIEl9KSx0LmQoZSwibm9ybWFsaXplIixmdW5jdGlvbigpe3JldHVybiBQfSksdC5kKGUsImRvdCIsZnVuY3Rpb24oKXtyZXR1cm4gTH0pLHQuZChlLCJjcm9zcyIsZnVuY3Rpb24oKXtyZXR1cm4gRH0pLHQuZChlLCJsZXJwIixmdW5jdGlvbigpe3JldHVybiBSfSksdC5kKGUsInJhbmRvbSIsZnVuY3Rpb24oKXtyZXR1cm4gQX0pLHQuZChlLCJ0cmFuc2Zvcm1NYXQ0IixmdW5jdGlvbigpe3JldHVybiBqfSksdC5kKGUsInRyYW5zZm9ybVF1YXQiLGZ1bmN0aW9uKCl7cmV0dXJuIEd9KSx0LmQoZSwiemVybyIsZnVuY3Rpb24oKXtyZXR1cm4gSH0pLHQuZChlLCJzdHIiLGZ1bmN0aW9uKCl7cmV0dXJuIFp9KSx0LmQoZSwiZXhhY3RFcXVhbHMiLGZ1bmN0aW9uKCl7cmV0dXJuIHF9KSx0LmQoZSwiZXF1YWxzIixmdW5jdGlvbigpe3JldHVybiBGfSksdC5kKGUsInN1YiIsZnVuY3Rpb24oKXtyZXR1cm4gJH0pLHQuZChlLCJtdWwiLGZ1bmN0aW9uKCl7cmV0dXJuIEp9KSx0LmQoZSwiZGl2IixmdW5jdGlvbigpe3JldHVybiB0dH0pLHQuZChlLCJkaXN0IixmdW5jdGlvbigpe3JldHVybiBffSksdC5kKGUsInNxckRpc3QiLGZ1bmN0aW9uKCl7cmV0dXJuIHN0fSksdC5kKGUsImxlbiIsZnVuY3Rpb24oKXtyZXR1cm4ga30pLHQuZChlLCJzcXJMZW4iLGZ1bmN0aW9uKCl7cmV0dXJuIGN0fSksdC5kKGUsImZvckVhY2giLGZ1bmN0aW9uKCl7cmV0dXJuIGZ0fSk7dmFyIHI9dCgyKTtmdW5jdGlvbiBpKCl7dmFyIFc9bmV3IHIuQVJSQVlfVFlQRSg0KTtyZXR1cm4gci5BUlJBWV9UWVBFIT1GbG9hdDMyQXJyYXkmJihXWzBdPTAsV1sxXT0wLFdbMl09MCxXWzNdPTApLFd9ZnVuY3Rpb24gaChXKXt2YXIgVT1uZXcgci5BUlJBWV9UWVBFKDQpO3JldHVybiBVWzBdPVdbMF0sVVsxXT1XWzFdLFVbMl09V1syXSxVWzNdPVdbM10sVX1mdW5jdGlvbiBnKFcsVSxWLFgpe3ZhciBCPW5ldyByLkFSUkFZX1RZUEUoNCk7cmV0dXJuIEJbMF09VyxCWzFdPVUsQlsyXT1WLEJbM109WCxCfWZ1bmN0aW9uIHUoVyxVKXtyZXR1cm4gV1swXT1VWzBdLFdbMV09VVsxXSxXWzJdPVVbMl0sV1szXT1VWzNdLFd9ZnVuY3Rpb24gYShXLFUsVixYLEIpe3JldHVybiBXWzBdPVUsV1sxXT1WLFdbMl09WCxXWzNdPUIsV31mdW5jdGlvbiBjKFcsVSxWKXtyZXR1cm4gV1swXT1VWzBdK1ZbMF0sV1sxXT1VWzFdK1ZbMV0sV1syXT1VWzJdK1ZbMl0sV1szXT1VWzNdK1ZbM10sV31mdW5jdGlvbiB4KFcsVSxWKXtyZXR1cm4gV1swXT1VWzBdLVZbMF0sV1sxXT1VWzFdLVZbMV0sV1syXT1VWzJdLVZbMl0sV1szXT1VWzNdLVZbM10sV31mdW5jdGlvbiBmKFcsVSxWKXtyZXR1cm4gV1swXT1VWzBdKlZbMF0sV1sxXT1VWzFdKlZbMV0sV1syXT1VWzJdKlZbMl0sV1szXT1VWzNdKlZbM10sV31mdW5jdGlvbiB2KFcsVSxWKXtyZXR1cm4gV1swXT1VWzBdL1ZbMF0sV1sxXT1VWzFdL1ZbMV0sV1syXT1VWzJdL1ZbMl0sV1szXT1VWzNdL1ZbM10sV31mdW5jdGlvbiBwKFcsVSl7cmV0dXJuIFdbMF09TWF0aC5jZWlsKFVbMF0pLFdbMV09TWF0aC5jZWlsKFVbMV0pLFdbMl09TWF0aC5jZWlsKFVbMl0pLFdbM109TWF0aC5jZWlsKFVbM10pLFd9ZnVuY3Rpb24gQyhXLFUpe3JldHVybiBXWzBdPU1hdGguZmxvb3IoVVswXSksV1sxXT1NYXRoLmZsb29yKFVbMV0pLFdbMl09TWF0aC5mbG9vcihVWzJdKSxXWzNdPU1hdGguZmxvb3IoVVszXSksV31mdW5jdGlvbiBNKFcsVSxWKXtyZXR1cm4gV1swXT1NYXRoLm1pbihVWzBdLFZbMF0pLFdbMV09TWF0aC5taW4oVVsxXSxWWzFdKSxXWzJdPU1hdGgubWluKFVbMl0sVlsyXSksV1szXT1NYXRoLm1pbihVWzNdLFZbM10pLFd9ZnVuY3Rpb24gbShXLFUsVil7cmV0dXJuIFdbMF09TWF0aC5tYXgoVVswXSxWWzBdKSxXWzFdPU1hdGgubWF4KFVbMV0sVlsxXSksV1syXT1NYXRoLm1heChVWzJdLFZbMl0pLFdbM109TWF0aC5tYXgoVVszXSxWWzNdKSxXfWZ1bmN0aW9uIHkoVyxVKXtyZXR1cm4gV1swXT1NYXRoLnJvdW5kKFVbMF0pLFdbMV09TWF0aC5yb3VuZChVWzFdKSxXWzJdPU1hdGgucm91bmQoVVsyXSksV1szXT1NYXRoLnJvdW5kKFVbM10pLFd9ZnVuY3Rpb24gbihXLFUsVil7cmV0dXJuIFdbMF09VVswXSpWLFdbMV09VVsxXSpWLFdbMl09VVsyXSpWLFdbM109VVszXSpWLFd9ZnVuY3Rpb24gbyhXLFUsVixYKXtyZXR1cm4gV1swXT1VWzBdK1ZbMF0qWCxXWzFdPVVbMV0rVlsxXSpYLFdbMl09VVsyXStWWzJdKlgsV1szXT1VWzNdK1ZbM10qWCxXfWZ1bmN0aW9uIHMoVyxVKXt2YXIgVj1VWzBdLVdbMF0sWD1VWzFdLVdbMV0sQj1VWzJdLVdbMl0sdz1VWzNdLVdbM107cmV0dXJuIE1hdGguaHlwb3QoVixYLEIsdyl9ZnVuY3Rpb24gbChXLFUpe3ZhciBWPVVbMF0tV1swXSxYPVVbMV0tV1sxXSxCPVVbMl0tV1syXSx3PVVbM10tV1szXTtyZXR1cm4gVipWK1gqWCtCKkIrdyp3fWZ1bmN0aW9uIEUoVyl7dmFyIFU9V1swXSxWPVdbMV0sWD1XWzJdLEI9V1szXTtyZXR1cm4gTWF0aC5oeXBvdChVLFYsWCxCKX1mdW5jdGlvbiBUKFcpe3ZhciBVPVdbMF0sVj1XWzFdLFg9V1syXSxCPVdbM107cmV0dXJuIFUqVStWKlYrWCpYK0IqQn1mdW5jdGlvbiBiKFcsVSl7cmV0dXJuIFdbMF09LVVbMF0sV1sxXT0tVVsxXSxXWzJdPS1VWzJdLFdbM109LVVbM10sV31mdW5jdGlvbiBJKFcsVSl7cmV0dXJuIFdbMF09MS9VWzBdLFdbMV09MS9VWzFdLFdbMl09MS9VWzJdLFdbM109MS9VWzNdLFd9ZnVuY3Rpb24gUChXLFUpe3ZhciBWPVVbMF0sWD1VWzFdLEI9VVsyXSx3PVVbM10sZD1WKlYrWCpYK0IqQit3Knc7cmV0dXJuIGQ+MCYmKGQ9MS9NYXRoLnNxcnQoZCkpLFdbMF09VipkLFdbMV09WCpkLFdbMl09QipkLFdbM109dypkLFd9ZnVuY3Rpb24gTChXLFUpe3JldHVybiBXWzBdKlVbMF0rV1sxXSpVWzFdK1dbMl0qVVsyXStXWzNdKlVbM119ZnVuY3Rpb24gRChXLFUsVixYKXt2YXIgQj1WWzBdKlhbMV0tVlsxXSpYWzBdLHc9VlswXSpYWzJdLVZbMl0qWFswXSxkPVZbMF0qWFszXS1WWzNdKlhbMF0sTz1WWzFdKlhbMl0tVlsyXSpYWzFdLE49VlsxXSpYWzNdLVZbM10qWFsxXSx6PVZbMl0qWFszXS1WWzNdKlhbMl0sSz1VWzBdLFk9VVsxXSxRPVVbMl0sZXQ9VVszXTtyZXR1cm4gV1swXT1ZKnotUSpOK2V0Kk8sV1sxXT0tKEsqeikrUSpkLWV0KncsV1syXT1LKk4tWSpkK2V0KkIsV1szXT0tKEsqTykrWSp3LVEqQixXfWZ1bmN0aW9uIFIoVyxVLFYsWCl7dmFyIEI9VVswXSx3PVVbMV0sZD1VWzJdLE89VVszXTtyZXR1cm4gV1swXT1CK1gqKFZbMF0tQiksV1sxXT13K1gqKFZbMV0tdyksV1syXT1kK1gqKFZbMl0tZCksV1szXT1PK1gqKFZbM10tTyksV31mdW5jdGlvbiBBKFcsVSl7VT1VfHwxO3ZhciBWLFgsQix3LGQsTztkbyBWPXIuUkFORE9NKCkqMi0xLFg9ci5SQU5ET00oKSoyLTEsZD1WKlYrWCpYO3doaWxlKGQ+PTEpO2RvIEI9ci5SQU5ET00oKSoyLTEsdz1yLlJBTkRPTSgpKjItMSxPPUIqQit3Knc7d2hpbGUoTz49MSk7dmFyIE49TWF0aC5zcXJ0KCgxLWQpL08pO3JldHVybiBXWzBdPVUqVixXWzFdPVUqWCxXWzJdPVUqQipOLFdbM109VSp3Kk4sV31mdW5jdGlvbiBqKFcsVSxWKXt2YXIgWD1VWzBdLEI9VVsxXSx3PVVbMl0sZD1VWzNdO3JldHVybiBXWzBdPVZbMF0qWCtWWzRdKkIrVls4XSp3K1ZbMTJdKmQsV1sxXT1WWzFdKlgrVls1XSpCK1ZbOV0qdytWWzEzXSpkLFdbMl09VlsyXSpYK1ZbNl0qQitWWzEwXSp3K1ZbMTRdKmQsV1szXT1WWzNdKlgrVls3XSpCK1ZbMTFdKncrVlsxNV0qZCxXfWZ1bmN0aW9uIEcoVyxVLFYpe3ZhciBYPVVbMF0sQj1VWzFdLHc9VVsyXSxkPVZbMF0sTz1WWzFdLE49VlsyXSx6PVZbM10sSz16KlgrTyp3LU4qQixZPXoqQitOKlgtZCp3LFE9eip3K2QqQi1PKlgsZXQ9LWQqWC1PKkItTip3O3JldHVybiBXWzBdPUsqeitldCotZCtZKi1OLVEqLU8sV1sxXT1ZKnorZXQqLU8rUSotZC1LKi1OLFdbMl09USp6K2V0Ki1OK0sqLU8tWSotZCxXWzNdPVVbM10sV31mdW5jdGlvbiBIKFcpe3JldHVybiBXWzBdPTAsV1sxXT0wLFdbMl09MCxXWzNdPTAsV31mdW5jdGlvbiBaKFcpe3JldHVybiJ2ZWM0KCIrV1swXSsiLCAiK1dbMV0rIiwgIitXWzJdKyIsICIrV1szXSsiKSJ9ZnVuY3Rpb24gcShXLFUpe3JldHVybiBXWzBdPT09VVswXSYmV1sxXT09PVVbMV0mJldbMl09PT1VWzJdJiZXWzNdPT09VVszXX1mdW5jdGlvbiBGKFcsVSl7dmFyIFY9V1swXSxYPVdbMV0sQj1XWzJdLHc9V1szXSxkPVVbMF0sTz1VWzFdLE49VVsyXSx6PVVbM107cmV0dXJuIE1hdGguYWJzKFYtZCk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKFYpLE1hdGguYWJzKGQpKSYmTWF0aC5hYnMoWC1PKTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoWCksTWF0aC5hYnMoTykpJiZNYXRoLmFicyhCLU4pPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhCKSxNYXRoLmFicyhOKSkmJk1hdGguYWJzKHcteik8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKHcpLE1hdGguYWJzKHopKX12YXIgJD14LEo9Zix0dD12LF89cyxzdD1sLGs9RSxjdD1ULGZ0PWZ1bmN0aW9uKCl7dmFyIFc9aSgpO3JldHVybiBmdW5jdGlvbihVLFYsWCxCLHcsZCl7dmFyIE8sTjtmb3IoVnx8KFY9NCksWHx8KFg9MCksQj9OPU1hdGgubWluKEIqVitYLFUubGVuZ3RoKTpOPVUubGVuZ3RoLE89WDtPPE47Tys9VilXWzBdPVVbT10sV1sxXT1VW08rMV0sV1syXT1VW08rMl0sV1szXT1VW08rM10sdyhXLFcsZCksVVtPXT1XWzBdLFVbTysxXT1XWzFdLFVbTysyXT1XWzJdLFVbTyszXT1XWzNdO3JldHVybiBVfX0oKX0sZnVuY3Rpb24oUyxlLHQpe3QucihlKSx0LmQoZSwiY3JlYXRlIixmdW5jdGlvbigpe3JldHVybiBnfSksdC5kKGUsImNsb25lIixmdW5jdGlvbigpe3JldHVybiB1fSksdC5kKGUsImZyb21WYWx1ZXMiLGZ1bmN0aW9uKCl7cmV0dXJuIGF9KSx0LmQoZSwiZnJvbVJvdGF0aW9uVHJhbnNsYXRpb25WYWx1ZXMiLGZ1bmN0aW9uKCl7cmV0dXJuIGN9KSx0LmQoZSwiZnJvbVJvdGF0aW9uVHJhbnNsYXRpb24iLGZ1bmN0aW9uKCl7cmV0dXJuIHh9KSx0LmQoZSwiZnJvbVRyYW5zbGF0aW9uIixmdW5jdGlvbigpe3JldHVybiBmfSksdC5kKGUsImZyb21Sb3RhdGlvbiIsZnVuY3Rpb24oKXtyZXR1cm4gdn0pLHQuZChlLCJmcm9tTWF0NCIsZnVuY3Rpb24oKXtyZXR1cm4gcH0pLHQuZChlLCJjb3B5IixmdW5jdGlvbigpe3JldHVybiBDfSksdC5kKGUsImlkZW50aXR5IixmdW5jdGlvbigpe3JldHVybiBNfSksdC5kKGUsInNldCIsZnVuY3Rpb24oKXtyZXR1cm4gbX0pLHQuZChlLCJnZXRSZWFsIixmdW5jdGlvbigpe3JldHVybiB5fSksdC5kKGUsImdldER1YWwiLGZ1bmN0aW9uKCl7cmV0dXJuIG59KSx0LmQoZSwic2V0UmVhbCIsZnVuY3Rpb24oKXtyZXR1cm4gb30pLHQuZChlLCJzZXREdWFsIixmdW5jdGlvbigpe3JldHVybiBzfSksdC5kKGUsImdldFRyYW5zbGF0aW9uIixmdW5jdGlvbigpe3JldHVybiBsfSksdC5kKGUsInRyYW5zbGF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gRX0pLHQuZChlLCJyb3RhdGVYIixmdW5jdGlvbigpe3JldHVybiBUfSksdC5kKGUsInJvdGF0ZVkiLGZ1bmN0aW9uKCl7cmV0dXJuIGJ9KSx0LmQoZSwicm90YXRlWiIsZnVuY3Rpb24oKXtyZXR1cm4gSX0pLHQuZChlLCJyb3RhdGVCeVF1YXRBcHBlbmQiLGZ1bmN0aW9uKCl7cmV0dXJuIFB9KSx0LmQoZSwicm90YXRlQnlRdWF0UHJlcGVuZCIsZnVuY3Rpb24oKXtyZXR1cm4gTH0pLHQuZChlLCJyb3RhdGVBcm91bmRBeGlzIixmdW5jdGlvbigpe3JldHVybiBEfSksdC5kKGUsImFkZCIsZnVuY3Rpb24oKXtyZXR1cm4gUn0pLHQuZChlLCJtdWx0aXBseSIsZnVuY3Rpb24oKXtyZXR1cm4gQX0pLHQuZChlLCJtdWwiLGZ1bmN0aW9uKCl7cmV0dXJuIGp9KSx0LmQoZSwic2NhbGUiLGZ1bmN0aW9uKCl7cmV0dXJuIEd9KSx0LmQoZSwiZG90IixmdW5jdGlvbigpe3JldHVybiBIfSksdC5kKGUsImxlcnAiLGZ1bmN0aW9uKCl7cmV0dXJuIFp9KSx0LmQoZSwiaW52ZXJ0IixmdW5jdGlvbigpe3JldHVybiBxfSksdC5kKGUsImNvbmp1Z2F0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gRn0pLHQuZChlLCJsZW5ndGgiLGZ1bmN0aW9uKCl7cmV0dXJuICR9KSx0LmQoZSwibGVuIixmdW5jdGlvbigpe3JldHVybiBKfSksdC5kKGUsInNxdWFyZWRMZW5ndGgiLGZ1bmN0aW9uKCl7cmV0dXJuIHR0fSksdC5kKGUsInNxckxlbiIsZnVuY3Rpb24oKXtyZXR1cm4gX30pLHQuZChlLCJub3JtYWxpemUiLGZ1bmN0aW9uKCl7cmV0dXJuIHN0fSksdC5kKGUsInN0ciIsZnVuY3Rpb24oKXtyZXR1cm4ga30pLHQuZChlLCJleGFjdEVxdWFscyIsZnVuY3Rpb24oKXtyZXR1cm4gY3R9KSx0LmQoZSwiZXF1YWxzIixmdW5jdGlvbigpe3JldHVybiBmdH0pO3ZhciByPXQoMiksaT10KDcpLGg9dCg2KTtmdW5jdGlvbiBnKCl7dmFyIFc9bmV3IHIuQVJSQVlfVFlQRSg4KTtyZXR1cm4gci5BUlJBWV9UWVBFIT1GbG9hdDMyQXJyYXkmJihXWzBdPTAsV1sxXT0wLFdbMl09MCxXWzRdPTAsV1s1XT0wLFdbNl09MCxXWzddPTApLFdbM109MSxXfWZ1bmN0aW9uIHUoVyl7dmFyIFU9bmV3IHIuQVJSQVlfVFlQRSg4KTtyZXR1cm4gVVswXT1XWzBdLFVbMV09V1sxXSxVWzJdPVdbMl0sVVszXT1XWzNdLFVbNF09V1s0XSxVWzVdPVdbNV0sVVs2XT1XWzZdLFVbN109V1s3XSxVfWZ1bmN0aW9uIGEoVyxVLFYsWCxCLHcsZCxPKXt2YXIgTj1uZXcgci5BUlJBWV9UWVBFKDgpO3JldHVybiBOWzBdPVcsTlsxXT1VLE5bMl09VixOWzNdPVgsTls0XT1CLE5bNV09dyxOWzZdPWQsTls3XT1PLE59ZnVuY3Rpb24gYyhXLFUsVixYLEIsdyxkKXt2YXIgTz1uZXcgci5BUlJBWV9UWVBFKDgpO09bMF09VyxPWzFdPVUsT1syXT1WLE9bM109WDt2YXIgTj1CKi41LHo9dyouNSxLPWQqLjU7cmV0dXJuIE9bNF09TipYK3oqVi1LKlUsT1s1XT16KlgrSypXLU4qVixPWzZdPUsqWCtOKlUteipXLE9bN109LU4qVy16KlUtSypWLE99ZnVuY3Rpb24geChXLFUsVil7dmFyIFg9VlswXSouNSxCPVZbMV0qLjUsdz1WWzJdKi41LGQ9VVswXSxPPVVbMV0sTj1VWzJdLHo9VVszXTtyZXR1cm4gV1swXT1kLFdbMV09TyxXWzJdPU4sV1szXT16LFdbNF09WCp6K0IqTi13Kk8sV1s1XT1CKnordypkLVgqTixXWzZdPXcqeitYKk8tQipkLFdbN109LVgqZC1CKk8tdypOLFd9ZnVuY3Rpb24gZihXLFUpe3JldHVybiBXWzBdPTAsV1sxXT0wLFdbMl09MCxXWzNdPTEsV1s0XT1VWzBdKi41LFdbNV09VVsxXSouNSxXWzZdPVVbMl0qLjUsV1s3XT0wLFd9ZnVuY3Rpb24gdihXLFUpe3JldHVybiBXWzBdPVVbMF0sV1sxXT1VWzFdLFdbMl09VVsyXSxXWzNdPVVbM10sV1s0XT0wLFdbNV09MCxXWzZdPTAsV1s3XT0wLFd9ZnVuY3Rpb24gcChXLFUpe3ZhciBWPWkuY3JlYXRlKCk7aC5nZXRSb3RhdGlvbihWLFUpO3ZhciBYPW5ldyByLkFSUkFZX1RZUEUoMyk7cmV0dXJuIGguZ2V0VHJhbnNsYXRpb24oWCxVKSx4KFcsVixYKSxXfWZ1bmN0aW9uIEMoVyxVKXtyZXR1cm4gV1swXT1VWzBdLFdbMV09VVsxXSxXWzJdPVVbMl0sV1szXT1VWzNdLFdbNF09VVs0XSxXWzVdPVVbNV0sV1s2XT1VWzZdLFdbN109VVs3XSxXfWZ1bmN0aW9uIE0oVyl7cmV0dXJuIFdbMF09MCxXWzFdPTAsV1syXT0wLFdbM109MSxXWzRdPTAsV1s1XT0wLFdbNl09MCxXWzddPTAsV31mdW5jdGlvbiBtKFcsVSxWLFgsQix3LGQsTyxOKXtyZXR1cm4gV1swXT1VLFdbMV09VixXWzJdPVgsV1szXT1CLFdbNF09dyxXWzVdPWQsV1s2XT1PLFdbN109TixXfXZhciB5PWkuY29weTtmdW5jdGlvbiBuKFcsVSl7cmV0dXJuIFdbMF09VVs0XSxXWzFdPVVbNV0sV1syXT1VWzZdLFdbM109VVs3XSxXfXZhciBvPWkuY29weTtmdW5jdGlvbiBzKFcsVSl7cmV0dXJuIFdbNF09VVswXSxXWzVdPVVbMV0sV1s2XT1VWzJdLFdbN109VVszXSxXfWZ1bmN0aW9uIGwoVyxVKXt2YXIgVj1VWzRdLFg9VVs1XSxCPVVbNl0sdz1VWzddLGQ9LVVbMF0sTz0tVVsxXSxOPS1VWzJdLHo9VVszXTtyZXR1cm4gV1swXT0oVip6K3cqZCtYKk4tQipPKSoyLFdbMV09KFgqeit3Kk8rQipkLVYqTikqMixXWzJdPShCKnordypOK1YqTy1YKmQpKjIsV31mdW5jdGlvbiBFKFcsVSxWKXt2YXIgWD1VWzBdLEI9VVsxXSx3PVVbMl0sZD1VWzNdLE89VlswXSouNSxOPVZbMV0qLjUsej1WWzJdKi41LEs9VVs0XSxZPVVbNV0sUT1VWzZdLGV0PVVbN107cmV0dXJuIFdbMF09WCxXWzFdPUIsV1syXT13LFdbM109ZCxXWzRdPWQqTytCKnotdypOK0ssV1s1XT1kKk4rdypPLVgqeitZLFdbNl09ZCp6K1gqTi1CKk8rUSxXWzddPS1YKk8tQipOLXcqeitldCxXfWZ1bmN0aW9uIFQoVyxVLFYpe3ZhciBYPS1VWzBdLEI9LVVbMV0sdz0tVVsyXSxkPVVbM10sTz1VWzRdLE49VVs1XSx6PVVbNl0sSz1VWzddLFk9TypkK0sqWCtOKncteipCLFE9TipkK0sqQit6KlgtTyp3LGV0PXoqZCtLKncrTypCLU4qWCxydD1LKmQtTypYLU4qQi16Knc7cmV0dXJuIGkucm90YXRlWChXLFUsViksWD1XWzBdLEI9V1sxXSx3PVdbMl0sZD1XWzNdLFdbNF09WSpkK3J0KlgrUSp3LWV0KkIsV1s1XT1RKmQrcnQqQitldCpYLVkqdyxXWzZdPWV0KmQrcnQqdytZKkItUSpYLFdbN109cnQqZC1ZKlgtUSpCLWV0KncsV31mdW5jdGlvbiBiKFcsVSxWKXt2YXIgWD0tVVswXSxCPS1VWzFdLHc9LVVbMl0sZD1VWzNdLE89VVs0XSxOPVVbNV0sej1VWzZdLEs9VVs3XSxZPU8qZCtLKlgrTip3LXoqQixRPU4qZCtLKkIreipYLU8qdyxldD16KmQrSyp3K08qQi1OKlgscnQ9SypkLU8qWC1OKkIteip3O3JldHVybiBpLnJvdGF0ZVkoVyxVLFYpLFg9V1swXSxCPVdbMV0sdz1XWzJdLGQ9V1szXSxXWzRdPVkqZCtydCpYK1Eqdy1ldCpCLFdbNV09USpkK3J0KkIrZXQqWC1ZKncsV1s2XT1ldCpkK3J0KncrWSpCLVEqWCxXWzddPXJ0KmQtWSpYLVEqQi1ldCp3LFd9ZnVuY3Rpb24gSShXLFUsVil7dmFyIFg9LVVbMF0sQj0tVVsxXSx3PS1VWzJdLGQ9VVszXSxPPVVbNF0sTj1VWzVdLHo9VVs2XSxLPVVbN10sWT1PKmQrSypYK04qdy16KkIsUT1OKmQrSypCK3oqWC1PKncsZXQ9eipkK0sqdytPKkItTipYLHJ0PUsqZC1PKlgtTipCLXoqdztyZXR1cm4gaS5yb3RhdGVaKFcsVSxWKSxYPVdbMF0sQj1XWzFdLHc9V1syXSxkPVdbM10sV1s0XT1ZKmQrcnQqWCtRKnctZXQqQixXWzVdPVEqZCtydCpCK2V0KlgtWSp3LFdbNl09ZXQqZCtydCp3K1kqQi1RKlgsV1s3XT1ydCpkLVkqWC1RKkItZXQqdyxXfWZ1bmN0aW9uIFAoVyxVLFYpe3ZhciBYPVZbMF0sQj1WWzFdLHc9VlsyXSxkPVZbM10sTz1VWzBdLE49VVsxXSx6PVVbMl0sSz1VWzNdO3JldHVybiBXWzBdPU8qZCtLKlgrTip3LXoqQixXWzFdPU4qZCtLKkIreipYLU8qdyxXWzJdPXoqZCtLKncrTypCLU4qWCxXWzNdPUsqZC1PKlgtTipCLXoqdyxPPVVbNF0sTj1VWzVdLHo9VVs2XSxLPVVbN10sV1s0XT1PKmQrSypYK04qdy16KkIsV1s1XT1OKmQrSypCK3oqWC1PKncsV1s2XT16KmQrSyp3K08qQi1OKlgsV1s3XT1LKmQtTypYLU4qQi16KncsV31mdW5jdGlvbiBMKFcsVSxWKXt2YXIgWD1VWzBdLEI9VVsxXSx3PVVbMl0sZD1VWzNdLE89VlswXSxOPVZbMV0sej1WWzJdLEs9VlszXTtyZXR1cm4gV1swXT1YKksrZCpPK0Iqei13Kk4sV1sxXT1CKksrZCpOK3cqTy1YKnosV1syXT13KksrZCp6K1gqTi1CKk8sV1szXT1kKkstWCpPLUIqTi13KnosTz1WWzRdLE49Vls1XSx6PVZbNl0sSz1WWzddLFdbNF09WCpLK2QqTytCKnotdypOLFdbNV09QipLK2QqTit3Kk8tWCp6LFdbNl09dypLK2QqeitYKk4tQipPLFdbN109ZCpLLVgqTy1CKk4tdyp6LFd9ZnVuY3Rpb24gRChXLFUsVixYKXtpZihNYXRoLmFicyhYKTxyLkVQU0lMT04pcmV0dXJuIEMoVyxVKTt2YXIgQj1NYXRoLmh5cG90KFZbMF0sVlsxXSxWWzJdKTtYPVgqLjU7dmFyIHc9TWF0aC5zaW4oWCksZD13KlZbMF0vQixPPXcqVlsxXS9CLE49dypWWzJdL0Isej1NYXRoLmNvcyhYKSxLPVVbMF0sWT1VWzFdLFE9VVsyXSxldD1VWzNdO1dbMF09Syp6K2V0KmQrWSpOLVEqTyxXWzFdPVkqeitldCpPK1EqZC1LKk4sV1syXT1RKnorZXQqTitLKk8tWSpkLFdbM109ZXQqei1LKmQtWSpPLVEqTjt2YXIgcnQ9VVs0XSxvdD1VWzVdLGx0PVVbNl0saXQ9VVs3XTtyZXR1cm4gV1s0XT1ydCp6K2l0KmQrb3QqTi1sdCpPLFdbNV09b3QqeitpdCpPK2x0KmQtcnQqTixXWzZdPWx0KnoraXQqTitydCpPLW90KmQsV1s3XT1pdCp6LXJ0KmQtb3QqTy1sdCpOLFd9ZnVuY3Rpb24gUihXLFUsVil7cmV0dXJuIFdbMF09VVswXStWWzBdLFdbMV09VVsxXStWWzFdLFdbMl09VVsyXStWWzJdLFdbM109VVszXStWWzNdLFdbNF09VVs0XStWWzRdLFdbNV09VVs1XStWWzVdLFdbNl09VVs2XStWWzZdLFdbN109VVs3XStWWzddLFd9ZnVuY3Rpb24gQShXLFUsVil7dmFyIFg9VVswXSxCPVVbMV0sdz1VWzJdLGQ9VVszXSxPPVZbNF0sTj1WWzVdLHo9Vls2XSxLPVZbN10sWT1VWzRdLFE9VVs1XSxldD1VWzZdLHJ0PVVbN10sb3Q9VlswXSxsdD1WWzFdLGl0PVZbMl0sbnQ9VlszXTtyZXR1cm4gV1swXT1YKm50K2Qqb3QrQippdC13Kmx0LFdbMV09QipudCtkKmx0K3cqb3QtWCppdCxXWzJdPXcqbnQrZCppdCtYKmx0LUIqb3QsV1szXT1kKm50LVgqb3QtQipsdC13Kml0LFdbNF09WCpLK2QqTytCKnotdypOK1kqbnQrcnQqb3QrUSppdC1ldCpsdCxXWzVdPUIqSytkKk4rdypPLVgqeitRKm50K3J0Kmx0K2V0Km90LVkqaXQsV1s2XT13KksrZCp6K1gqTi1CKk8rZXQqbnQrcnQqaXQrWSpsdC1RKm90LFdbN109ZCpLLVgqTy1CKk4tdyp6K3J0Km50LVkqb3QtUSpsdC1ldCppdCxXfXZhciBqPUE7ZnVuY3Rpb24gRyhXLFUsVil7cmV0dXJuIFdbMF09VVswXSpWLFdbMV09VVsxXSpWLFdbMl09VVsyXSpWLFdbM109VVszXSpWLFdbNF09VVs0XSpWLFdbNV09VVs1XSpWLFdbNl09VVs2XSpWLFdbN109VVs3XSpWLFd9dmFyIEg9aS5kb3Q7ZnVuY3Rpb24gWihXLFUsVixYKXt2YXIgQj0xLVg7cmV0dXJuIEgoVSxWKTwwJiYoWD0tWCksV1swXT1VWzBdKkIrVlswXSpYLFdbMV09VVsxXSpCK1ZbMV0qWCxXWzJdPVVbMl0qQitWWzJdKlgsV1szXT1VWzNdKkIrVlszXSpYLFdbNF09VVs0XSpCK1ZbNF0qWCxXWzVdPVVbNV0qQitWWzVdKlgsV1s2XT1VWzZdKkIrVls2XSpYLFdbN109VVs3XSpCK1ZbN10qWCxXfWZ1bmN0aW9uIHEoVyxVKXt2YXIgVj10dChVKTtyZXR1cm4gV1swXT0tVVswXS9WLFdbMV09LVVbMV0vVixXWzJdPS1VWzJdL1YsV1szXT1VWzNdL1YsV1s0XT0tVVs0XS9WLFdbNV09LVVbNV0vVixXWzZdPS1VWzZdL1YsV1s3XT1VWzddL1YsV31mdW5jdGlvbiBGKFcsVSl7cmV0dXJuIFdbMF09LVVbMF0sV1sxXT0tVVsxXSxXWzJdPS1VWzJdLFdbM109VVszXSxXWzRdPS1VWzRdLFdbNV09LVVbNV0sV1s2XT0tVVs2XSxXWzddPVVbN10sV312YXIgJD1pLmxlbmd0aCxKPSQsdHQ9aS5zcXVhcmVkTGVuZ3RoLF89dHQ7ZnVuY3Rpb24gc3QoVyxVKXt2YXIgVj10dChVKTtpZihWPjApe1Y9TWF0aC5zcXJ0KFYpO3ZhciBYPVVbMF0vVixCPVVbMV0vVix3PVVbMl0vVixkPVVbM10vVixPPVVbNF0sTj1VWzVdLHo9VVs2XSxLPVVbN10sWT1YKk8rQipOK3cqeitkKks7V1swXT1YLFdbMV09QixXWzJdPXcsV1szXT1kLFdbNF09KE8tWCpZKS9WLFdbNV09KE4tQipZKS9WLFdbNl09KHotdypZKS9WLFdbN109KEstZCpZKS9WfXJldHVybiBXfWZ1bmN0aW9uIGsoVyl7cmV0dXJuInF1YXQyKCIrV1swXSsiLCAiK1dbMV0rIiwgIitXWzJdKyIsICIrV1szXSsiLCAiK1dbNF0rIiwgIitXWzVdKyIsICIrV1s2XSsiLCAiK1dbN10rIikifWZ1bmN0aW9uIGN0KFcsVSl7cmV0dXJuIFdbMF09PT1VWzBdJiZXWzFdPT09VVsxXSYmV1syXT09PVVbMl0mJldbM109PT1VWzNdJiZXWzRdPT09VVs0XSYmV1s1XT09PVVbNV0mJldbNl09PT1VWzZdJiZXWzddPT09VVs3XX1mdW5jdGlvbiBmdChXLFUpe3ZhciBWPVdbMF0sWD1XWzFdLEI9V1syXSx3PVdbM10sZD1XWzRdLE89V1s1XSxOPVdbNl0sej1XWzddLEs9VVswXSxZPVVbMV0sUT1VWzJdLGV0PVVbM10scnQ9VVs0XSxvdD1VWzVdLGx0PVVbNl0saXQ9VVs3XTtyZXR1cm4gTWF0aC5hYnMoVi1LKTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoViksTWF0aC5hYnMoSykpJiZNYXRoLmFicyhYLVkpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhYKSxNYXRoLmFicyhZKSkmJk1hdGguYWJzKEItUSk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKEIpLE1hdGguYWJzKFEpKSYmTWF0aC5hYnMody1ldCk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKHcpLE1hdGguYWJzKGV0KSkmJk1hdGguYWJzKGQtcnQpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhkKSxNYXRoLmFicyhydCkpJiZNYXRoLmFicyhPLW90KTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoTyksTWF0aC5hYnMob3QpKSYmTWF0aC5hYnMoTi1sdCk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKE4pLE1hdGguYWJzKGx0KSkmJk1hdGguYWJzKHotaXQpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyh6KSxNYXRoLmFicyhpdCkpfX0sZnVuY3Rpb24oUyxlLHQpe3QucihlKSx0LmQoZSwiY3JlYXRlIixmdW5jdGlvbigpe3JldHVybiBpfSksdC5kKGUsImNsb25lIixmdW5jdGlvbigpe3JldHVybiBofSksdC5kKGUsImZyb21WYWx1ZXMiLGZ1bmN0aW9uKCl7cmV0dXJuIGd9KSx0LmQoZSwiY29weSIsZnVuY3Rpb24oKXtyZXR1cm4gdX0pLHQuZChlLCJzZXQiLGZ1bmN0aW9uKCl7cmV0dXJuIGF9KSx0LmQoZSwiYWRkIixmdW5jdGlvbigpe3JldHVybiBjfSksdC5kKGUsInN1YnRyYWN0IixmdW5jdGlvbigpe3JldHVybiB4fSksdC5kKGUsIm11bHRpcGx5IixmdW5jdGlvbigpe3JldHVybiBmfSksdC5kKGUsImRpdmlkZSIsZnVuY3Rpb24oKXtyZXR1cm4gdn0pLHQuZChlLCJjZWlsIixmdW5jdGlvbigpe3JldHVybiBwfSksdC5kKGUsImZsb29yIixmdW5jdGlvbigpe3JldHVybiBDfSksdC5kKGUsIm1pbiIsZnVuY3Rpb24oKXtyZXR1cm4gTX0pLHQuZChlLCJtYXgiLGZ1bmN0aW9uKCl7cmV0dXJuIG19KSx0LmQoZSwicm91bmQiLGZ1bmN0aW9uKCl7cmV0dXJuIHl9KSx0LmQoZSwic2NhbGUiLGZ1bmN0aW9uKCl7cmV0dXJuIG59KSx0LmQoZSwic2NhbGVBbmRBZGQiLGZ1bmN0aW9uKCl7cmV0dXJuIG99KSx0LmQoZSwiZGlzdGFuY2UiLGZ1bmN0aW9uKCl7cmV0dXJuIHN9KSx0LmQoZSwic3F1YXJlZERpc3RhbmNlIixmdW5jdGlvbigpe3JldHVybiBsfSksdC5kKGUsImxlbmd0aCIsZnVuY3Rpb24oKXtyZXR1cm4gRX0pLHQuZChlLCJzcXVhcmVkTGVuZ3RoIixmdW5jdGlvbigpe3JldHVybiBUfSksdC5kKGUsIm5lZ2F0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gYn0pLHQuZChlLCJpbnZlcnNlIixmdW5jdGlvbigpe3JldHVybiBJfSksdC5kKGUsIm5vcm1hbGl6ZSIsZnVuY3Rpb24oKXtyZXR1cm4gUH0pLHQuZChlLCJkb3QiLGZ1bmN0aW9uKCl7cmV0dXJuIEx9KSx0LmQoZSwiY3Jvc3MiLGZ1bmN0aW9uKCl7cmV0dXJuIER9KSx0LmQoZSwibGVycCIsZnVuY3Rpb24oKXtyZXR1cm4gUn0pLHQuZChlLCJyYW5kb20iLGZ1bmN0aW9uKCl7cmV0dXJuIEF9KSx0LmQoZSwidHJhbnNmb3JtTWF0MiIsZnVuY3Rpb24oKXtyZXR1cm4gan0pLHQuZChlLCJ0cmFuc2Zvcm1NYXQyZCIsZnVuY3Rpb24oKXtyZXR1cm4gR30pLHQuZChlLCJ0cmFuc2Zvcm1NYXQzIixmdW5jdGlvbigpe3JldHVybiBIfSksdC5kKGUsInRyYW5zZm9ybU1hdDQiLGZ1bmN0aW9uKCl7cmV0dXJuIFp9KSx0LmQoZSwicm90YXRlIixmdW5jdGlvbigpe3JldHVybiBxfSksdC5kKGUsImFuZ2xlIixmdW5jdGlvbigpe3JldHVybiBGfSksdC5kKGUsInplcm8iLGZ1bmN0aW9uKCl7cmV0dXJuICR9KSx0LmQoZSwic3RyIixmdW5jdGlvbigpe3JldHVybiBKfSksdC5kKGUsImV4YWN0RXF1YWxzIixmdW5jdGlvbigpe3JldHVybiB0dH0pLHQuZChlLCJlcXVhbHMiLGZ1bmN0aW9uKCl7cmV0dXJuIF99KSx0LmQoZSwibGVuIixmdW5jdGlvbigpe3JldHVybiBzdH0pLHQuZChlLCJzdWIiLGZ1bmN0aW9uKCl7cmV0dXJuIGt9KSx0LmQoZSwibXVsIixmdW5jdGlvbigpe3JldHVybiBjdH0pLHQuZChlLCJkaXYiLGZ1bmN0aW9uKCl7cmV0dXJuIGZ0fSksdC5kKGUsImRpc3QiLGZ1bmN0aW9uKCl7cmV0dXJuIFd9KSx0LmQoZSwic3FyRGlzdCIsZnVuY3Rpb24oKXtyZXR1cm4gVX0pLHQuZChlLCJzcXJMZW4iLGZ1bmN0aW9uKCl7cmV0dXJuIFZ9KSx0LmQoZSwiZm9yRWFjaCIsZnVuY3Rpb24oKXtyZXR1cm4gWH0pO3ZhciByPXQoMik7ZnVuY3Rpb24gaSgpe3ZhciBCPW5ldyByLkFSUkFZX1RZUEUoMik7cmV0dXJuIHIuQVJSQVlfVFlQRSE9RmxvYXQzMkFycmF5JiYoQlswXT0wLEJbMV09MCksQn1mdW5jdGlvbiBoKEIpe3ZhciB3PW5ldyByLkFSUkFZX1RZUEUoMik7cmV0dXJuIHdbMF09QlswXSx3WzFdPUJbMV0sd31mdW5jdGlvbiBnKEIsdyl7dmFyIGQ9bmV3IHIuQVJSQVlfVFlQRSgyKTtyZXR1cm4gZFswXT1CLGRbMV09dyxkfWZ1bmN0aW9uIHUoQix3KXtyZXR1cm4gQlswXT13WzBdLEJbMV09d1sxXSxCfWZ1bmN0aW9uIGEoQix3LGQpe3JldHVybiBCWzBdPXcsQlsxXT1kLEJ9ZnVuY3Rpb24gYyhCLHcsZCl7cmV0dXJuIEJbMF09d1swXStkWzBdLEJbMV09d1sxXStkWzFdLEJ9ZnVuY3Rpb24geChCLHcsZCl7cmV0dXJuIEJbMF09d1swXS1kWzBdLEJbMV09d1sxXS1kWzFdLEJ9ZnVuY3Rpb24gZihCLHcsZCl7cmV0dXJuIEJbMF09d1swXSpkWzBdLEJbMV09d1sxXSpkWzFdLEJ9ZnVuY3Rpb24gdihCLHcsZCl7cmV0dXJuIEJbMF09d1swXS9kWzBdLEJbMV09d1sxXS9kWzFdLEJ9ZnVuY3Rpb24gcChCLHcpe3JldHVybiBCWzBdPU1hdGguY2VpbCh3WzBdKSxCWzFdPU1hdGguY2VpbCh3WzFdKSxCfWZ1bmN0aW9uIEMoQix3KXtyZXR1cm4gQlswXT1NYXRoLmZsb29yKHdbMF0pLEJbMV09TWF0aC5mbG9vcih3WzFdKSxCfWZ1bmN0aW9uIE0oQix3LGQpe3JldHVybiBCWzBdPU1hdGgubWluKHdbMF0sZFswXSksQlsxXT1NYXRoLm1pbih3WzFdLGRbMV0pLEJ9ZnVuY3Rpb24gbShCLHcsZCl7cmV0dXJuIEJbMF09TWF0aC5tYXgod1swXSxkWzBdKSxCWzFdPU1hdGgubWF4KHdbMV0sZFsxXSksQn1mdW5jdGlvbiB5KEIsdyl7cmV0dXJuIEJbMF09TWF0aC5yb3VuZCh3WzBdKSxCWzFdPU1hdGgucm91bmQod1sxXSksQn1mdW5jdGlvbiBuKEIsdyxkKXtyZXR1cm4gQlswXT13WzBdKmQsQlsxXT13WzFdKmQsQn1mdW5jdGlvbiBvKEIsdyxkLE8pe3JldHVybiBCWzBdPXdbMF0rZFswXSpPLEJbMV09d1sxXStkWzFdKk8sQn1mdW5jdGlvbiBzKEIsdyl7dmFyIGQ9d1swXS1CWzBdLE89d1sxXS1CWzFdO3JldHVybiBNYXRoLmh5cG90KGQsTyl9ZnVuY3Rpb24gbChCLHcpe3ZhciBkPXdbMF0tQlswXSxPPXdbMV0tQlsxXTtyZXR1cm4gZCpkK08qT31mdW5jdGlvbiBFKEIpe3ZhciB3PUJbMF0sZD1CWzFdO3JldHVybiBNYXRoLmh5cG90KHcsZCl9ZnVuY3Rpb24gVChCKXt2YXIgdz1CWzBdLGQ9QlsxXTtyZXR1cm4gdyp3K2QqZH1mdW5jdGlvbiBiKEIsdyl7cmV0dXJuIEJbMF09LXdbMF0sQlsxXT0td1sxXSxCfWZ1bmN0aW9uIEkoQix3KXtyZXR1cm4gQlswXT0xL3dbMF0sQlsxXT0xL3dbMV0sQn1mdW5jdGlvbiBQKEIsdyl7dmFyIGQ9d1swXSxPPXdbMV0sTj1kKmQrTypPO3JldHVybiBOPjAmJihOPTEvTWF0aC5zcXJ0KE4pKSxCWzBdPXdbMF0qTixCWzFdPXdbMV0qTixCfWZ1bmN0aW9uIEwoQix3KXtyZXR1cm4gQlswXSp3WzBdK0JbMV0qd1sxXX1mdW5jdGlvbiBEKEIsdyxkKXt2YXIgTz13WzBdKmRbMV0td1sxXSpkWzBdO3JldHVybiBCWzBdPUJbMV09MCxCWzJdPU8sQn1mdW5jdGlvbiBSKEIsdyxkLE8pe3ZhciBOPXdbMF0sej13WzFdO3JldHVybiBCWzBdPU4rTyooZFswXS1OKSxCWzFdPXorTyooZFsxXS16KSxCfWZ1bmN0aW9uIEEoQix3KXt3PXd8fDE7dmFyIGQ9ci5SQU5ET00oKSoyKk1hdGguUEk7cmV0dXJuIEJbMF09TWF0aC5jb3MoZCkqdyxCWzFdPU1hdGguc2luKGQpKncsQn1mdW5jdGlvbiBqKEIsdyxkKXt2YXIgTz13WzBdLE49d1sxXTtyZXR1cm4gQlswXT1kWzBdKk8rZFsyXSpOLEJbMV09ZFsxXSpPK2RbM10qTixCfWZ1bmN0aW9uIEcoQix3LGQpe3ZhciBPPXdbMF0sTj13WzFdO3JldHVybiBCWzBdPWRbMF0qTytkWzJdKk4rZFs0XSxCWzFdPWRbMV0qTytkWzNdKk4rZFs1XSxCfWZ1bmN0aW9uIEgoQix3LGQpe3ZhciBPPXdbMF0sTj13WzFdO3JldHVybiBCWzBdPWRbMF0qTytkWzNdKk4rZFs2XSxCWzFdPWRbMV0qTytkWzRdKk4rZFs3XSxCfWZ1bmN0aW9uIFooQix3LGQpe3ZhciBPPXdbMF0sTj13WzFdO3JldHVybiBCWzBdPWRbMF0qTytkWzRdKk4rZFsxMl0sQlsxXT1kWzFdKk8rZFs1XSpOK2RbMTNdLEJ9ZnVuY3Rpb24gcShCLHcsZCxPKXt2YXIgTj13WzBdLWRbMF0sej13WzFdLWRbMV0sSz1NYXRoLnNpbihPKSxZPU1hdGguY29zKE8pO3JldHVybiBCWzBdPU4qWS16KksrZFswXSxCWzFdPU4qSyt6KlkrZFsxXSxCfWZ1bmN0aW9uIEYoQix3KXt2YXIgZD1CWzBdLE89QlsxXSxOPXdbMF0sej13WzFdLEs9TWF0aC5zcXJ0KGQqZCtPKk8pKk1hdGguc3FydChOKk4reip6KSxZPUsmJihkKk4rTyp6KS9LO3JldHVybiBNYXRoLmFjb3MoTWF0aC5taW4oTWF0aC5tYXgoWSwtMSksMSkpfWZ1bmN0aW9uICQoQil7cmV0dXJuIEJbMF09MCxCWzFdPTAsQn1mdW5jdGlvbiBKKEIpe3JldHVybiJ2ZWMyKCIrQlswXSsiLCAiK0JbMV0rIikifWZ1bmN0aW9uIHR0KEIsdyl7cmV0dXJuIEJbMF09PT13WzBdJiZCWzFdPT09d1sxXX1mdW5jdGlvbiBfKEIsdyl7dmFyIGQ9QlswXSxPPUJbMV0sTj13WzBdLHo9d1sxXTtyZXR1cm4gTWF0aC5hYnMoZC1OKTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoZCksTWF0aC5hYnMoTikpJiZNYXRoLmFicyhPLXopPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhPKSxNYXRoLmFicyh6KSl9dmFyIHN0PUUsaz14LGN0PWYsZnQ9dixXPXMsVT1sLFY9VCxYPWZ1bmN0aW9uKCl7dmFyIEI9aSgpO3JldHVybiBmdW5jdGlvbih3LGQsTyxOLHosSyl7dmFyIFksUTtmb3IoZHx8KGQ9MiksT3x8KE89MCksTj9RPU1hdGgubWluKE4qZCtPLHcubGVuZ3RoKTpRPXcubGVuZ3RoLFk9TztZPFE7WSs9ZClCWzBdPXdbWV0sQlsxXT13W1krMV0seihCLEIsSyksd1tZXT1CWzBdLHdbWSsxXT1CWzFdO3JldHVybiB3fX0oKX0sZnVuY3Rpb24oUyxlLHQpe3QucihlKTt2YXIgcj10KDEzKTt0LmQoZSwiUmVuZGVyZXIiLGZ1bmN0aW9uKCl7cmV0dXJuIHIuZGVmYXVsdH0pO3ZhciBpPXQoNDApO3QuZChlLCJGaWd1cmUyRCIsZnVuY3Rpb24oKXtyZXR1cm4gaS5kZWZhdWx0fSk7dmFyIGg9dCg1Nik7dC5kKGUsIk1lc2gyRCIsZnVuY3Rpb24oKXtyZXR1cm4gaC5kZWZhdWx0fSk7dmFyIGc9dCgyOSk7dC5kKGUsIk1lc2hDbG91ZCIsZnVuY3Rpb24oKXtyZXR1cm4gZy5kZWZhdWx0fSk7dmFyIHU9dCgyMyk7dC5kKGUsInBhcnNlRm9udCIsZnVuY3Rpb24oKXtyZXR1cm4gdS5kZWZhdWx0fSk7dmFyIGE9dCgzMSk7dC5kKGUsInBhcnNlQ29sb3IiLGZ1bmN0aW9uKCl7cmV0dXJuIGEuZGVmYXVsdH0pO3ZhciBjPXQoMjEpO3QuZChlLCJFTlYiLGZ1bmN0aW9uKCl7cmV0dXJuIGMuZGVmYXVsdH0pLHQoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KX0sZnVuY3Rpb24oUyxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gSX0pO3ZhciByPXQoMTQpLGk9dCgxKSxoPXQoMjApLGc9dCgyNyksdT10KDI1KSxhPXQoNDApLGM9dCg1NikseD10KDI5KSxmPXQoNTkpLHY9dCgyMSkscD10KDYzKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3QgQz17YXV0b1VwZGF0ZTohMSxwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6ITEsYnVmZmVyU2l6ZToxNTAwfSxNPWBhdHRyaWJ1dGUgdmVjMyBhX3ZlcnRleFBvc2l0aW9uOwphdHRyaWJ1dGUgdmVjMyBhX3ZlcnRleFRleHR1cmVDb29yZDsKdmFyeWluZyB2ZWMzIHZUZXh0dXJlQ29vcmQ7CnVuaWZvcm0gbWF0MyB2aWV3TWF0cml4Owp1bmlmb3JtIG1hdDMgcHJvamVjdGlvbk1hdHJpeDsKCnZvaWQgbWFpbigpIHsKICBnbF9Qb2ludFNpemUgPSAxLjA7CiAgdmVjMyBwb3MgPSBwcm9qZWN0aW9uTWF0cml4ICogdmlld01hdHJpeCAqIHZlYzMoYV92ZXJ0ZXhQb3NpdGlvbi54eSwgMS4wKTsKICBnbF9Qb3NpdGlvbiA9IHZlYzQocG9zLnh5LCAxLjAsIDEuMCk7ICAgIAogIHZUZXh0dXJlQ29vcmQgPSBhX3ZlcnRleFRleHR1cmVDb29yZDsgICAgICAgICAgICAgIAp9CmAsbT1gcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7CnZhcnlpbmcgdmVjMyB2VGV4dHVyZUNvb3JkOwp1bmlmb3JtIHNhbXBsZXIyRCB1X3RleFNhbXBsZXI7CnZvaWQgbWFpbigpIHsKICBnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQodV90ZXhTYW1wbGVyLCB2VGV4dHVyZUNvb3JkLnh5KTsKfQpgLHk9U3ltYm9sKCJnbFJlbmRlcmVyIiksbj1TeW1ib2woImNhbnZhc1JlbmRlcmVyIiksbz1TeW1ib2woIm9wdGlvbnMiKSxzPVN5bWJvbCgiZ2xvYmFsVHJhbnNmb3JtIiksbD1TeW1ib2woImFwcGx5R2xvYmFsVHJhbnNmb3JtIiksRT1TeW1ib2woImNhbnZhcyIpO2Z1bmN0aW9uIFQoUCl7Y29uc3QgTD1QLmdsLEQ9UC5mYm87RCYmTC5iaW5kRnJhbWVidWZmZXIoTC5GUkFNRUJVRkZFUixEKSxQLl9kcmF3KCksRCYmTC5iaW5kRnJhbWVidWZmZXIoTC5GUkFNRUJVRkZFUixudWxsKX1mdW5jdGlvbiBiKFAsTCxELFIpe2NvbnN0IEE9UC5jcmVhdGVUZXh0dXJlKEwuY2FudmFzKSxqPVtbWzAsMF0sW0QsMF0sW0QsUl0sWzAsUl0sWzAsMF1dXTtqLmNsb3NlZD0hMDtjb25zdCBHPW5ldyBjLmRlZmF1bHQoe2NvbnRvdXJzOmp9KTtHLnNldFRleHR1cmUoQSksUC5zZXRNZXNoRGF0YShbRy5tZXNoRGF0YV0pLFQoUCksQS5kZWxldGUoKSxMLmNsZWFyUmVjdCgwLDAsRCxSKSxkZWxldGUgTC5fZmlsdGVyfWNsYXNzIEl7Y29uc3RydWN0b3IoTCxEPXt9KXtsZXQgUj1ELmNvbnRleHRUeXBlO2lmKFJ8fCh0eXBlb2YgV2ViR0wyUmVuZGVyaW5nQ29udGV4dD09ImZ1bmN0aW9uIj9SPSJ3ZWJnbDIiOnR5cGVvZiBXZWJHTFJlbmRlcmluZ0NvbnRleHQ9PSJmdW5jdGlvbiI/Uj0id2ViZ2wiOlI9IjJkIiksIUwuZ2V0Q29udGV4dCl7Y29uc3QgQT1MO0w9e2dldENvbnRleHQoKXtyZXR1cm4gQX0sd2lkdGg6RC53aWR0aCxoZWlnaHQ6RC5oZWlnaHR9LEEuY2FudmFzPUwsUj0iMmQifWlmKHRoaXNbRV09TCxSIT09IndlYmdsIiYmUiE9PSJ3ZWJnbDIiJiZSIT09IjJkIil0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gY29udGV4dCB0eXBlICR7Un1gKTtpZihELmNvbnRleHRUeXBlPVIsdGhpc1tvXT1PYmplY3QuYXNzaWduKHt9LEMsRCksUj09PSJ3ZWJnbCJ8fFI9PT0id2ViZ2wyIil7Uj09PSJ3ZWJnbDIiJiYodGhpc1tvXS53ZWJnbDI9ITApO2NvbnN0IEE9bmV3IHIuZGVmYXVsdChMLHRoaXNbb10pO1I9PT0id2ViZ2wyIiYmIUEuaXNXZWJHTDImJihELmNvbnRleHRUeXBlPSJ3ZWJnbCIpLE9iamVjdChwLmNyZWF0ZVNoYWRlcnMpKEEpLE9iamVjdChwLmFwcGx5U2hhZGVyKShBKSxPYmplY3QocC5jcmVhdGVDbG91ZFNoYWRlcnMpKEEpO2NvbnN0IGo9QS5nbDtqLmNsZWFyQ29sb3IoMCwwLDAsMCksai5ibGVuZEZ1bmNTZXBhcmF0ZShqLlNSQ19BTFBIQSxqLk9ORV9NSU5VU19TUkNfQUxQSEEsai5PTkUsai5PTkVfTUlOVVNfU1JDX0FMUEhBKSx0aGlzW3ldPUF9ZWxzZSB0aGlzW25dPW5ldyBoLmRlZmF1bHQoTCx0aGlzW29dKTt0aGlzW3NdPVsxLDAsMCwwLDEsMCwwLDAsMV0sdGhpcy51cGRhdGVSZXNvbHV0aW9uKCl9Z2V0IGNhbnZhcygpe3JldHVybiB0aGlzW0VdfWdldCBjYW52YXNSZW5kZXJlcigpe3JldHVybiB0aGlzW25dfWdldCBnbFJlbmRlcmVyKCl7cmV0dXJuIHRoaXNbeV19Z2V0IGlzV2ViR0wyKCl7cmV0dXJuIHRoaXNbeV0mJnRoaXNbeV0uaXNXZWJHTDJ9Z2V0IG9wdGlvbnMoKXtyZXR1cm4gdGhpc1tvXX1nZXQgZ2xvYmFsVHJhbnNmb3JtTWF0cml4KCl7Y29uc3QgTD10aGlzW3NdO3JldHVybltMWzBdLExbMV0sTFszXSxMWzRdLExbNl0sTFs3XV19Z2V0IHZpZXdNYXRyaXgoKXtyZXR1cm4gdGhpc1tzXX1bbF0oKXtjb25zdCBMPXRoaXNbeV18fHRoaXNbbl07aWYodGhpc1t5XSl7Y29uc3R7d2lkdGg6RCxoZWlnaHQ6Un09dGhpcy5jYW52YXM7TC51bmlmb3Jtcy52aWV3TWF0cml4PXRoaXMudmlld01hdHJpeCxMLnVuaWZvcm1zLnByb2plY3Rpb25NYXRyaXg9dGhpcy5wcm9qZWN0aW9uTWF0cml4LEwudW5pZm9ybXMudV9yZXNvbHV0aW9uPVtELFJdfX11cGRhdGVSZXNvbHV0aW9uKCl7Y29uc3R7d2lkdGg6TCxoZWlnaHQ6RH09dGhpcy5jYW52YXMsUj1bMSwwLDAsMCwxLDAsLUwvMiwtRC8yLDFdLEE9WzIvTCwwLDAsMCwtMi9ELDAsMCwwLDFdLGo9aS5tYXQzLm11bHRpcGx5KEFycmF5Lm9mKDAsMCwwLDAsMCwwLDAsMCwwKSxBLFIpO3RoaXMucHJvamVjdGlvbk1hdHJpeD1qLHRoaXNbeV0mJnRoaXNbeV0uZ2wudmlld3BvcnQoMCwwLEwsRCl9Y3JlYXRlVGV4dHVyZShMLEQpe3JldHVybih0aGlzW3ldfHx0aGlzW25dKS5jcmVhdGVUZXh0dXJlKEwsRCl9bG9hZFRleHR1cmUoTCx7dXNlSW1hZ2VCaXRtYXA6RD0hMX09e30pe3JldHVybih0aGlzW3ldfHx0aGlzW25dKS5sb2FkVGV4dHVyZShMLHt1c2VJbWFnZUJpdG1hcDpEfSl9Y3JlYXRlVGV4dChMLHtmb250OkQ9IjE2cHggYXJpYWwiLGZpbGxDb2xvcjpSPW51bGwsc3Ryb2tlQ29sb3I6QT1udWxsLHN0cm9rZVdpZHRoOmo9MX09e30pe2lmKHRoaXNbeV0pe2NvbnN0IEc9di5kZWZhdWx0LmNyZWF0ZVRleHQoTCx7Zm9udDpELGZpbGxDb2xvcjpSLHN0cm9rZUNvbG9yOkEsc3Ryb2tlV2lkdGg6an0pO3JldHVybntpbWFnZTp0aGlzLmNyZWF0ZVRleHR1cmUoRy5pbWFnZSkscmVjdDpHLnJlY3R9fXJldHVybntfaW1nOntmb250OkQsZmlsbENvbG9yOlIsc3Ryb2tlQ29sb3I6QSxzdHJva2VXaWR0aDpqLHRleHQ6TH19fWNyZWF0ZVByb2dyYW0oe3ZlcnRleDpMLGZyYWdtZW50OkQsb3B0aW9uczpSfT17fSl7aWYodGhpc1t5XSl7Y29uc3QgQT10aGlzW3ldLmNvbXBpbGVTeW5jKEQsTCk7cmV0dXJuIEEuX2F0dHJpYk9wdHM9UixBfXRocm93IG5ldyBFcnJvcigiQ29udGV4dCAyRCBjYW5ub3QgY3JlYXRlIHdlYmdsIHByb2dyYW0uIil9Y3JlYXRlUGFzc1Byb2dyYW0oe3ZlcnRleDpMPU0sZnJhZ21lbnQ6RD1tLG9wdGlvbnM6Un09e30pe3JldHVybiB0aGlzLmNyZWF0ZVByb2dyYW0oe3ZlcnRleDpMLGZyYWdtZW50OkQsb3B0aW9uczpSfSl9dXNlUHJvZ3JhbShMLEQ9e30pe2lmKHRoaXNbeV0pe2NvbnN0IFI9T2JqZWN0LmFzc2lnbih7fSxMLl9hdHRyaWJPcHRzLEQpO3JldHVybiB0aGlzW3ldLnVzZVByb2dyYW0oTCxSKX10aHJvdyBuZXcgRXJyb3IoIkNvbnRleHQgMkQgY2Fubm90IHVzZSB3ZWJnbCBwcm9ncmFtLiIpfWRlbGV0ZVRleHR1cmUoTCl7cmV0dXJuKHRoaXNbeV18fHRoaXNbbl0pLmRlbGV0ZVRleHR1cmUoTCl9Y2xlYXIoLi4uTCl7aWYodGhpc1t5XSl7Y29uc3QgRD10aGlzW3ldLmdsO0QuY2xlYXIoRC5DT0xPUl9CVUZGRVJfQklUKX1lbHNlIHRoaXNbbl0uY2xlYXIoLi4uTCl9ZHJhd01lc2hDbG91ZChMLHtjbGVhcjpEPSExLHByb2dyYW06Uj1udWxsfT17fSl7Y29uc3QgQT10aGlzW3ldfHx0aGlzW25dLGo9Unx8TC5wcm9ncmFtO2lmKHRoaXNbeV0pe2NvbnN0IEc9QS5nbDtpZihEJiZHLmNsZWFyKEcuQ09MT1JfQlVGRkVSX0JJVCksailBLnByb2dyYW0hPT1qJiZ0aGlzLnVzZVByb2dyYW0oaix7YV9jb2xvcjp7dHlwZToiVU5TSUdORURfQllURSIsbm9ybWFsaXplOiEwfSxhX2ZpbGxDbG91ZENvbG9yOnt0eXBlOiJVTlNJR05FRF9CWVRFIixub3JtYWxpemU6ITB9LGFfc3Ryb2tlQ2xvdWRDb2xvcjp7dHlwZToiVU5TSUdORURfQllURSIsbm9ybWFsaXplOiEwfSxhX2ZyYW1lSW5kZXg6e3R5cGU6IlVOU0lHTkVEX0JZVEUiLG5vcm1hbGl6ZTohMX19KTtlbHNle2NvbnN0IEg9TC5tZXNoLm1lc2hEYXRhLFo9ISFILnVuaWZvcm1zLnVfdGV4U2FtcGxlcixxPSEhSC51bmlmb3Jtcy51X2ZpbHRlckZsYWcsRj0hIUgudW5pZm9ybXMudV9yYWRpYWxHcmFkaWVudFZlY3RvciwkPUwuaGFzQ2xvdWRDb2xvcixKPUwuaGFzQ2xvdWRGaWx0ZXIsdHQ9ISFILnVuaWZvcm1zLnVfY2xpcFNhbXBsZXI7T2JqZWN0KHAuYXBwbHlDbG91ZFNoYWRlcikoQSx7aGFzVGV4dHVyZTpaLGhhc0ZpbHRlcjpxLGhhc0dyYWRpZW50OkYsaGFzQ2xvdWRDb2xvcjokLGhhc0Nsb3VkRmlsdGVyOkosaGFzQ2xpcFBhdGg6dHR9KX10aGlzW2xdKCksQS5zZXRNZXNoRGF0YShbTC5tZXNoRGF0YV0pLEwuYmVmb3JlUmVuZGVyJiZMLmJlZm9yZVJlbmRlcihHLEwpLFQoQSksTC5hZnRlclJlbmRlciYmTC5hZnRlclJlbmRlcihHLEwpfWVsc2UgQS5zZXRUcmFuc2Zvcm0odGhpcy5nbG9iYWxUcmFuc2Zvcm1NYXRyaXgpLEEuZHJhd01lc2hDbG91ZChMLHtjbGVhcjpELGhvb2s6ITF9KX1kcmF3TWVzaGVzKEwse2NsZWFyOkQ9ITEscHJvZ3JhbTpSPW51bGx9PXt9KXtjb25zdCBBPXRoaXNbeV18fHRoaXNbbl07aWYodGhpc1t5XSl7Y29uc3Qgaj1BLmZibyxHPU9iamVjdChnLmRlZmF1bHQpKHRoaXMsTCxSPT1udWxsKSxIPUEuZ2w7RCYmSC5jbGVhcihILkNPTE9SX0JVRkZFUl9CSVQpO2NvbnN0IFo9IU9iamVjdChmLmlzVW5pdFRyYW5zZm9ybSkodGhpcy5nbG9iYWxUcmFuc2Zvcm1NYXRyaXgpO3RoaXMuX2RyYXdDYWxscz0wO2Zvcihjb25zdCBxIG9mIEcpe3RoaXMuX2RyYXdDYWxscysrO2NvbnN0IEY9Unx8cS5wcm9ncmFtO2lmKHEgaW5zdGFuY2VvZiB4LmRlZmF1bHQpdGhpcy5kcmF3TWVzaENsb3VkKHEse2NsZWFyOkQscHJvZ3JhbTpGfSk7ZWxzZXtjb25zdHt3aWR0aDokLGhlaWdodDpKfT10aGlzLmNhbnZhcztpZihxLmJlZm9yZVJlbmRlciYmcS5iZWZvcmVSZW5kZXIoSCxxKSxxLnBhc3MubGVuZ3RoJiYoKCF0aGlzLmZib3x8dGhpcy5mYm8ud2lkdGghPT0kfHx0aGlzLmZiby5oZWlnaHQhPT1KKSYmKHRoaXMuZmJvPXt3aWR0aDokLGhlaWdodDpKLHRhcmdldDpBLmNyZWF0ZUZCTygpLGJ1ZmZlcjpBLmNyZWF0ZUZCTygpLHN3YXAoKXtbdGhpcy50YXJnZXQsdGhpcy5idWZmZXJdPVt0aGlzLmJ1ZmZlcix0aGlzLnRhcmdldF19fSksQS5iaW5kRkJPKHRoaXMuZmJvLnRhcmdldCkpLCFGJiZxLmZpbHRlckNhbnZhcyl7T2JqZWN0KHAuYXBwbHlTaGFkZXIpKEEse2hhc1RleHR1cmU6ITB9KTtsZXQgdHQ9dGhpcy5maWx0ZXJDb250ZXh0O3R0fHwodHQ9di5kZWZhdWx0LmNyZWF0ZUNhbnZhcygkLEopLmdldENvbnRleHQoIjJkIiksdGhpcy5maWx0ZXJDb250ZXh0PXR0KTtjb25zdCBfPUxbcS5wYWNrSW5kZXhdLHN0PV8uZmlsdGVyLGs9TFtxLnBhY2tJbmRleCsxXSxjdD1MW3EucGFja0luZGV4LTFdOyghY3R8fCFjdC5maWx0ZXJDYW52YXN8fGN0LmZpbHRlciE9PXN0KSYmKCFrfHwhay5maWx0ZXJDYW52YXN8fGsuZmlsdGVyIT09c3QpPyhaPyh0dC5zYXZlKCksT2JqZWN0KHUuZHJhd01lc2gyRCkoXyx0dCwhMSksdHQucmVzdG9yZSgpLE9iamVjdCh1LmFwcGx5RmlsdGVyKSh0dCxzdCkpOk9iamVjdCh1LmRyYXdNZXNoMkQpKF8sdHQsITApLHRoaXNbbF0oKSxiKEEsdHQsJCxKKSk6KFomJnR0LnNhdmUoKSxPYmplY3QodS5kcmF3TWVzaDJEKShfLHR0LCExKSxaJiZ0dC5yZXN0b3JlKCksKCFrfHwhay5maWx0ZXJDYW52YXN8fF8uZmlsdGVyIT09ay5maWx0ZXIpJiYoT2JqZWN0KHUuYXBwbHlGaWx0ZXIpKHR0LHN0KSx0aGlzW2xdKCksYihBLHR0LCQsSikpKX1lbHNle2lmKEYpQS5wcm9ncmFtIT09RiYmdGhpcy51c2VQcm9ncmFtKEYse2FfY29sb3I6e3R5cGU6IlVOU0lHTkVEX0JZVEUiLG5vcm1hbGl6ZTohMH19KTtlbHNle2NvbnN0IHR0PSEhcS51bmlmb3Jtcy51X3RleFNhbXBsZXIsXz0hIXEudW5pZm9ybXMudV9maWx0ZXJGbGFnLHN0PSEhcS51bmlmb3Jtcy51X3JhZGlhbEdyYWRpZW50VmVjdG9yLGs9ISFxLnVuaWZvcm1zLnVfY2xpcFNhbXBsZXI7T2JqZWN0KHAuYXBwbHlTaGFkZXIpKEEse2hhc1RleHR1cmU6dHQsaGFzRmlsdGVyOl8saGFzR3JhZGllbnQ6c3QsaGFzQ2xpcFBhdGg6a30pfXEuZmlsdGVyQ2FudmFzJiZjb25zb2xlLndhcm4oIlVzZXIgcHJvZ3JhbSBpZ25vcmVkIHNvbWUgZmlsdGVyIGVmZmVjdHMuIiksdGhpc1tsXSgpLEEuc2V0TWVzaERhdGEoW3FdKSxUKEEpfWlmKHEucGFzcy5sZW5ndGgpe2NvbnN0IHR0PXEucGFzcy5sZW5ndGg7cS5wYXNzLmZvckVhY2goKF8sc3QpPT57Xy5ibGVuZD1xLmVuYWJsZUJsZW5kLF8uc2V0VGV4dHVyZShBLmZiby50ZXh0dXJlKSxzdD09PXR0LTE/QS5iaW5kRkJPKGopOih0aGlzLmZiby5zd2FwKCksQS5iaW5kRkJPKHRoaXMuZmJvLnRhcmdldCkpLF8ucHJvZ3JhbT9BLnVzZVByb2dyYW0oXy5wcm9ncmFtKToodGhpcy5kZWZhdWx0UGFzc1Byb2dyYW09dGhpcy5kZWZhdWx0UGFzc1Byb2dyYW18fHRoaXMuY3JlYXRlUGFzc1Byb2dyYW0oKSxBLnVzZVByb2dyYW0odGhpcy5kZWZhdWx0UGFzc1Byb2dyYW0pKSxBLnNldE1lc2hEYXRhKFtfLm1lc2hEYXRhXSksSC5jbGVhcihILkNPTE9SX0JVRkZFUl9CSVQpLFQoQSl9KX1xLmFmdGVyUmVuZGVyJiZxLmFmdGVyUmVuZGVyKEgscSl9fX1lbHNlIEEuc2V0VHJhbnNmb3JtKHRoaXMuZ2xvYmFsVHJhbnNmb3JtTWF0cml4KSxBLmRyYXdNZXNoZXMoTCx7Y2xlYXI6RH0pfWRyYXdJbWFnZShMLC4uLkQpe2NvbnN0IFI9RC5sZW5ndGg7aWYoUjwyKXRocm93IG5ldyBUeXBlRXJyb3IoYEZhaWxlZCB0byBleGVjdXRlICdkcmF3SW1hZ2UnIG9uICdSZW5kZXJlcic6IDMgYXJndW1lbnRzIHJlcXVpcmVkLCBidXQgb25seSAke0QubGVuZ3RoKzF9IHByZXNlbnQuYCk7aWYoUiE9PTImJlIhPT00JiZSIT09OCl0aHJvdyBuZXcgVHlwZUVycm9yKGBGYWlsZWQgdG8gZXhlY3V0ZSAnZHJhd0ltYWdlJyBvbiAnUmVuZGVyZXInOiBWYWxpZCBhcml0aWVzIGFyZTogWzMsIDUsIDldLCBidXQgJHtELmxlbmd0aCsxfSBhcmd1bWVudHMgcHJvdmlkZWQuYCk7bGV0IEE9bnVsbCxqPW51bGw7Uj09PTI/QT1bRFswXSxEWzFdLEwud2lkdGgsTC5oZWlnaHRdOlI9PT00P0E9RDpSPT09OCYmKGo9RC5zbGljZSgwLDQpLEE9RC5zbGljZSg0KSk7Y29uc3QgRz10aGlzLmNyZWF0ZVRleHR1cmUoTCkse3dpZHRoOkgsaGVpZ2h0Olp9PXRoaXMuY2FudmFzLHE9bmV3IGEuZGVmYXVsdDtxLnJlY3QoQVswXSxBWzFdLEgsWik7Y29uc3QgRj1uZXcgYy5kZWZhdWx0KHEse3dpZHRoOkgsaGVpZ2h0Olp9KTtGLnNldFRleHR1cmUoRyx7cmVjdDpBLHNyY1JlY3Q6an0pLHRoaXMuZHJhd01lc2hlcyhbRl0pLHRoaXMuZGVsZXRlVGV4dHVyZShHKX1zZXRHbG9iYWxUcmFuc2Zvcm0oLi4uTCl7cmV0dXJuIHRoaXNbc109W0xbMF0sTFsxXSwwLExbMl0sTFszXSwwLExbNF0sTFs1XSwxXSx0aGlzfWdsb2JhbFRyYW5zZm9ybSguLi5MKXtjb25zdCBEPXRoaXNbc107cmV0dXJuIHRoaXNbc109aS5tYXQzLm11bHRpcGx5KEFycmF5Lm9mKDAsMCwwLDAsMCwwLDAsMCwwKSxELEwpLHRoaXN9Z2xvYmFsVHJhbnNsYXRlKEwsRCl7bGV0IFI9aS5tYXQzLmNyZWF0ZSgpO3JldHVybiBSPWkubWF0My50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDAsMCwwLDApLFIsW0wsRF0pLHRoaXMuZ2xvYmFsVHJhbnNmb3JtKC4uLlIpfWdsb2JhbFJvdGF0ZShMLFtELFJdPVswLDBdKXtsZXQgQT1pLm1hdDMuY3JlYXRlKCk7cmV0dXJuIEE9aS5tYXQzLnRyYW5zbGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCwwLDAsMCksQSxbRCxSXSksQT1pLm1hdDMucm90YXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwLDAsMCwwKSxBLEwpLEE9aS5tYXQzLnRyYW5zbGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCwwLDAsMCksQSxbLUQsLVJdKSx0aGlzLmdsb2JhbFRyYW5zZm9ybSguLi5BKX1nbG9iYWxTY2FsZShMLEQ9TCxbUixBXT1bMCwwXSl7bGV0IGo9aS5tYXQzLmNyZWF0ZSgpO3JldHVybiBqPWkubWF0My50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDAsMCwwLDApLGosW1IsQV0pLGo9aS5tYXQzLnNjYWxlKEFycmF5Lm9mKDAsMCwwLDAsMCwwLDAsMCwwKSxqLFtMLERdKSxqPWkubWF0My50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDAsMCwwLDApLGosWy1SLC1BXSksdGhpcy5nbG9iYWxUcmFuc2Zvcm0oLi4uail9Z2xvYmFsU2tldyhMLEQ9TCxbUixBXT1bMCwwXSl7bGV0IGo9aS5tYXQzLmNyZWF0ZSgpO3JldHVybiBqPWkubWF0My50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDAsMCwwLDApLGosW1IsQV0pLGo9aS5tYXQzLm11bHRpcGx5KEFycmF5Lm9mKDAsMCwwLDAsMCwwLDAsMCwwKSxqLGkubWF0My5mcm9tVmFsdWVzKDEsTWF0aC50YW4oRCksTWF0aC50YW4oTCksMSwwLDApKSxqPWkubWF0My50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDAsMCwwLDApLGosWy1SLC1BXSksdGhpcy5nbG9iYWxUcmFuc2Zvcm0oLi4uail9dHJhbnNmb3JtUG9pbnQoTCxELFIpe2xldCBBPXRoaXMuZ2xvYmFsVHJhbnNmb3JtTWF0cml4O1ImJihBPWkubWF0My5tdWx0aXBseShBcnJheS5vZigwLDAsMCwwLDAsMCwwLDAsMCksQSxSKSk7Y29uc3Qgaj1MKkFbMF0rRCpBWzJdK0FbNF0sRz1MKkFbMV0rRCpBWzNdK0FbNV07cmV0dXJuW2osR119fX0sZnVuY3Rpb24oUyxlLHQpe3QucihlKTt2YXIgcj10KDE1KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSksZS5kZWZhdWx0PXIuZGVmYXVsdH0sZnVuY3Rpb24oUyxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gcH0pO3ZhciByPXQoMTYpLGk9dCgxNyksaD10KDE4KSxnPXQoMTkpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiB1KEMsTSxtKXtyZXR1cm4gTSBpbiBDP09iamVjdC5kZWZpbmVQcm9wZXJ0eShDLE0se3ZhbHVlOm0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTpDW01dPW0sQ31jb25zdCBhPXt9O2Z1bmN0aW9uIGMoQyxNPTMpe2NvbnN0IG09W10seT1DLmxlbmd0aDtmb3IobGV0IG49MDtuPHk7bisrKW4lTTwyJiZtLnB1c2goLjUqKENbbl0rMSkpO3JldHVybiBtfWZ1bmN0aW9uIHgoQyxNKXtjb25zdCBtPU0uX2J1ZmZlcnM7T2JqZWN0LnZhbHVlcyhtKS5mb3JFYWNoKHk9PntDLmRlbGV0ZUJ1ZmZlcih5KX0pLE0uX2J1ZmZlcnM9e319ZnVuY3Rpb24gZihDLE0sbSl7cmV0dXJuIEMuYWN0aXZlVGV4dHVyZShDLlRFWFRVUkUwK20pLEFycmF5LmlzQXJyYXkoTS5faW1nKT9DLmJpbmRUZXh0dXJlKEMuVEVYVFVSRV9DVUJFX01BUCxNKTpDLmJpbmRUZXh0dXJlKEMuVEVYVFVSRV8yRCxNKSxNfWNvbnN0IHY9e2ludDoiMWkiLGl2ZWMyOiIyaSIsaXZlYzM6IjNpIixpdmVjNDoiNGkiLGZsb2F0OiIxZiIsdmVjMjoiMmYiLHZlYzM6IjNmIix2ZWM0OiI0ZiIsbWF0MjoiTWF0cml4MmZ2IixtYXQzOiJNYXRyaXgzZnYiLG1hdDQ6Ik1hdHJpeDRmdiIsc2FtcGxlcjFEOiJzYW1wbGVyMUQiLHNhbXBsZXIyRDoic2FtcGxlcjJEIixzYW1wbGVyM0Q6InNhbXBsZXIzRCIsc2FtcGxlckN1YmU6InNhbXBsZXJDdWJlIixzYW1wbGVyMURTaGFkb3c6InNhbXBsZXIxRFNoYWRvdyIsc2FtcGxlcjJEU2hhZG93OiJzYW1wbGVyMkRTaGFkb3ciLHNhbXBsZXIyRFJlY3Q6InNhbXBsZXIyRFJlY3QiLHNhbXBsZXIyRFJlY3RTaGFkb3c6InNhbXBsZXIyRFJlY3RTaGFkb3cifTtjbGFzcyBwe3N0YXRpYyBhZGRMaWJzKE09e30pe09iamVjdC5hc3NpZ24oYSxNKX1zdGF0aWMgRkxPQVQoTSxtKXtyZXR1cm4gT2JqZWN0KHIucG9pbnRzVG9CdWZmZXIpKE0sRmxvYXQzMkFycmF5LG0pfXN0YXRpYyBVTlNJR05FRF9CWVRFKE0sbSl7cmV0dXJuIE9iamVjdChyLnBvaW50c1RvQnVmZmVyKShNLFVpbnQ4QXJyYXksbSl9c3RhdGljIFVOU0lHTkVEX1NIT1JUKE0sbSl7cmV0dXJuIE9iamVjdChyLnBvaW50c1RvQnVmZmVyKShNLFVpbnQxNkFycmF5LG0pfXN0YXRpYyBCWVRFKE0sbSl7cmV0dXJuIE9iamVjdChyLnBvaW50c1RvQnVmZmVyKShNLEludDhBcnJheSxtKX1zdGF0aWMgU0hPUlQoTSxtKXtyZXR1cm4gT2JqZWN0KHIucG9pbnRzVG9CdWZmZXIpKE0sSW50MTZBcnJheSxtKX1jb25zdHJ1Y3RvcihNLG09e30pe3RoaXMub3B0aW9ucz1PYmplY3QuYXNzaWduKHt9LHAuZGVmYXVsdE9wdGlvbnMsbSksdGhpcy5jYW52YXM9TTtsZXQgeTt0aGlzLm9wdGlvbnMud2ViZ2wyJiYoeT1NLmdldENvbnRleHQoIndlYmdsMiIsdGhpcy5vcHRpb25zKSkseT09bnVsbCYmKHk9T2JqZWN0KHIuc2V0dXBXZWJHTCkoTSx0aGlzLm9wdGlvbnMpLHRoaXMuYWlhX2V4dD15LmdldEV4dGVuc2lvbigiQU5HTEVfaW5zdGFuY2VkX2FycmF5cyIpKSx0aGlzLmdsPXkseS52aWV3cG9ydCgwLDAsTS53aWR0aCxNLmhlaWdodCkseS5jbGVhckNvbG9yKDAsMCwwLDApLHkuYmxlbmRGdW5jU2VwYXJhdGUoeS5TUkNfQUxQSEEseS5PTkVfTUlOVVNfU1JDX0FMUEhBLHkuT05FLHkuT05FX01JTlVTX1NSQ19BTFBIQSksdGhpcy5wcm9ncmFtcz1bXSx0aGlzLl9ldmVudHM9e319Z2V0IHByb2dyYW0oKXtjb25zdCBNPXRoaXMuZ2w7cmV0dXJuIE0uZ2V0UGFyYW1ldGVyKE0uQ1VSUkVOVF9QUk9HUkFNKX1fZGVjbGFyZVVuaWZvcm0oTSxtLHk9IjFmIil7Y29uc3Qgbj10aGlzLmdsLG89bi5nZXRVbmlmb3JtTG9jYXRpb24oTSxtKTtsZXQgcztjb25zdCBsPXRoaXM7aWYoL15zYW1wbGVyLy50ZXN0KHkpKXtjb25zdCBFPU0uX3NhbXBsZXJNYXAsVD1NLl9iaW5kVGV4dHVyZXM7T2JqZWN0LmRlZmluZVByb3BlcnR5KE0udW5pZm9ybXMsbSx7Z2V0KCl7cmV0dXJuIHN9LHNldChiKXtzPWI7Y29uc3QgST1FW21dIT1udWxsP0VbbV06VC5sZW5ndGg7VFtJXT1iLGYobixiLEkpLEVbbV18fChFW21dPUksbi51bmlmb3JtMWkobyxJKSksbC5vcHRpb25zLmF1dG9VcGRhdGUmJmwudXBkYXRlKCl9LGNvbmZpZ3VyYWJsZTohMSxlbnVtZXJhYmxlOiEwfSl9ZWxzZXtjb25zdCBFPXkuaW5kZXhPZigiTWF0cml4Iik9PT0wLFQ9IUUmJi92JC8udGVzdCh5KSxiPW5bYHVuaWZvcm0ke3l9YF0uYmluZChuKTtPYmplY3QuZGVmaW5lUHJvcGVydHkoTS51bmlmb3JtcyxtLHtnZXQoKXtyZXR1cm4gc30sc2V0KEkpe3M9SSx0eXBlb2YgST09Im51bWJlciImJihJPVtJXSksRT9iKG8sITEsSSk6VD9iKG8sSSk6YihvLC4uLkkpLGwub3B0aW9ucy5hdXRvVXBkYXRlJiZsLnVwZGF0ZSgpfSxjb25maWd1cmFibGU6ITEsZW51bWVyYWJsZTohMH0pfX1fZHJhdygpe2NvbnN0IE09dGhpcy5wcm9ncmFtO00ubWVzaERhdGEuZm9yRWFjaCgobSx5KT0+e2NvbnN0e3Bvc2l0aW9uczpuLGNlbGxzOm8saW5zdGFuY2VDb3VudDpzLGNlbGxzQ291bnQ6bCxhdHRyaWJ1dGVzOkUsdW5pZm9ybXM6VCx0ZXh0dXJlQ29vcmQ6YixlbmFibGVCbGVuZDpJfT1tLFA9dGhpcy5nbDtsZXQgTD1tLm1vZGUhPW51bGw/bS5tb2RlOlAuVFJJQU5HTEVTO3R5cGVvZiBMPT0ic3RyaW5nIiYmKEw9UFtMXSksST9QLmVuYWJsZShQLkJMRU5EKTpQLmRpc2FibGUoUC5CTEVORCksUC5iaW5kQnVmZmVyKFAuQVJSQVlfQlVGRkVSLE0uX2J1ZmZlcnMudmVydGljZXNCdWZmZXIpLFAuYnVmZmVyRGF0YShQLkFSUkFZX0JVRkZFUixuLFAuU1RBVElDX0RSQVcpLG8mJihQLmJpbmRCdWZmZXIoUC5FTEVNRU5UX0FSUkFZX0JVRkZFUixNLl9idWZmZXJzLmNlbGxzQnVmZmVyKSxQLmJ1ZmZlckRhdGEoUC5FTEVNRU5UX0FSUkFZX0JVRkZFUixvLFAuU1RBVElDX0RSQVcpKTtjb25zdCBEPVtdO0UmJk9iamVjdC52YWx1ZXMoRSkuZm9yRWFjaCgoe25hbWU6QSxkYXRhOmosZGl2aXNvcjpHfSk9PntpZihQLmJpbmRCdWZmZXIoUC5BUlJBWV9CVUZGRVIsTS5fYnVmZmVyc1tBXSksUC5idWZmZXJEYXRhKFAuQVJSQVlfQlVGRkVSLGosUC5TVEFUSUNfRFJBVyksRyE9bnVsbCl7Y29uc3QgSD1QLmdldEF0dHJpYkxvY2F0aW9uKE0sQSk7SD49MCYmKFAuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoSCksRC5wdXNoKEgpLFAudmVydGV4QXR0cmliRGl2aXNvcj9QLnZlcnRleEF0dHJpYkRpdmlzb3IoSCxHKTp0aGlzLmFpYV9leHQmJnRoaXMuYWlhX2V4dC52ZXJ0ZXhBdHRyaWJEaXZpc29yQU5HTEUoSCxHKSl9fSksVCYmT2JqZWN0LmVudHJpZXMoVCkuZm9yRWFjaCgoW0Esal0pPT57dGhpcy51bmlmb3Jtc1tBXT1qfSk7bGV0IFI7aWYoIW8pe2NvbnN0IEE9TS5fZGltZW5zaW9uO1I9bi5sZW5ndGgvQX1pZihNLl9lbmFibGVUZXh0dXJlcyYmTS5fYnVmZmVycy50ZXhDb29yZEJ1ZmZlcil7Y29uc3QgQT1ifHxjKG4sTS5fZGltZW5zaW9uKTtQLmJpbmRCdWZmZXIoUC5BUlJBWV9CVUZGRVIsTS5fYnVmZmVycy50ZXhDb29yZEJ1ZmZlciksUC5idWZmZXJEYXRhKFAuQVJSQVlfQlVGRkVSLHAuRkxPQVQoQSksUC5TVEFUSUNfRFJBVyl9cyE9bnVsbD8obz9QLmRyYXdFbGVtZW50c0luc3RhbmNlZD9QLmRyYXdFbGVtZW50c0luc3RhbmNlZChMLGwsUC5VTlNJR05FRF9TSE9SVCwwLHMpOnRoaXMuYWlhX2V4dCYmdGhpcy5haWFfZXh0LmRyYXdFbGVtZW50c0luc3RhbmNlZEFOR0xFKEwsbCxQLlVOU0lHTkVEX1NIT1JULDAscyk6UC5kcmF3QXJyYXlzSW5zdGFuY2VkP1AuZHJhd0FycmF5c0luc3RhbmNlZChMLDAsUixzKTp0aGlzLmFpYV9leHQuZHJhd0FycmF5c0luc3RhbmNlZEFOR0xFKEwsMCxSLHMpLEQuZm9yRWFjaChBPT57UC52ZXJ0ZXhBdHRyaWJEaXZpc29yP1AudmVydGV4QXR0cmliRGl2aXNvcihBLG51bGwpOnRoaXMuYWlhX2V4dCYmdGhpcy5haWFfZXh0LnZlcnRleEF0dHJpYkRpdmlzb3JBTkdMRShBLG51bGwpfSkpOm8/UC5kcmF3RWxlbWVudHMoTCxsLFAuVU5TSUdORURfU0hPUlQsMCk6UC5kcmF3QXJyYXlzKEwsMCxSKX0pfWdldCBpc1dlYkdMMigpe3JldHVybiB0eXBlb2YgV2ViR0wyUmVuZGVyaW5nQ29udGV4dDwidSImJnRoaXMuZ2wgaW5zdGFuY2VvZiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0fWdldCBlbmFibGVUZXh0dXJlcygpe3JldHVybiB0aGlzLnByb2dyYW0mJnRoaXMucHJvZ3JhbS5fZW5hYmxlVGV4dHVyZXN9Z2V0IHVuaWZvcm1zKCl7Y29uc3QgTT10aGlzLnByb2dyYW07aWYoIU18fCFNLnVuaWZvcm1zKXRocm93IEVycm9yKCJObyBhdmFsaWFibGUgcHJvZ3JhbS4iKTtyZXR1cm4gTS51bmlmb3Jtc31kZWxldGVQcm9ncmFtKE0pe2NvbnN0IG09dGhpcy5nbDt0aGlzLnByb2dyYW09PT1NJiYodGhpcy5zdGFydFJlbmRlcj0hMSx0aGlzLl9yZW5kZXJGcmFtZUlEJiYoY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5fcmVuZGVyRnJhbWVJRCksZGVsZXRlIHRoaXMuX3JlbmRlckZyYW1lSUQpLG0udXNlUHJvZ3JhbShudWxsKSk7Y29uc3QgeT10aGlzLnByb2dyYW1zLmluZGV4T2YoTSk7eT49MCYmdGhpcy5wcm9ncmFtcy5zcGxpY2UoeSwxKSx4KG0sTSksbS5kZWxldGVQcm9ncmFtKE0pfXNldE1lc2hEYXRhKE0pe0FycmF5LmlzQXJyYXkoTSl8fChNPVtNXSk7Y29uc3QgbT10aGlzLnByb2dyYW07bS5tZXNoRGF0YT1NLm1hcCgoe21vZGU6eSxwb3NpdGlvbnM6bixpbnN0YW5jZUNvdW50Om8sY2VsbHM6cyxjZWxsc0NvdW50OmwsYXR0cmlidXRlczpFLHVuaWZvcm1zOlQsdGV4dHVyZUNvb3JkOmIsZW5hYmxlQmxlbmQ6SX0pPT57Y29uc3QgUD17cG9zaXRpb25zOnAuRkxPQVQobiksdW5pZm9ybXM6VCxlbmFibGVCbGVuZDohIUksdGV4dHVyZUNvb3JkOnAuRkxPQVQoYil9O2lmKHMmJihQLmNlbGxzPXAuVVNIT1JUKHMpLFAuY2VsbHNDb3VudD1sfHxQLmNlbGxzLmxlbmd0aCkseSE9bnVsbCYmKFAubW9kZT15KSxvIT1udWxsKXtpZighdGhpcy5pc1dlYkdMMiYmIXRoaXMuYWlhX2V4dCl0aHJvdyBuZXcgRXJyb3IoIkNhbm5vdCB1c2UgaW5zdGFuY2VDb3VudCBpbiB0aGlzIHJlbmRlcmluZyBjb250ZXh0LCB1c2Ugd2ViZ2wyIGNvbnRleHQgaW5zdGVhZC4iKTtQLmluc3RhbmNlQ291bnQ9b31pZihFKXtjb25zdCBMPXt9O09iamVjdC5lbnRyaWVzKEUpLmZvckVhY2goKFtELFJdKT0+e2lmKCFtLl9hdHRyaWJ1dGVbRF0pbS5fYXR0cmlidXRlW0RdPSJpZ25vcmVkIjtlbHNlIGlmKG0uX2F0dHJpYnV0ZVtEXSE9PSJpZ25vcmVkIil7Y29uc3R7bmFtZTpBLHR5cGU6an09bS5fYXR0cmlidXRlW0RdO2xldCBHPVIuZGF0YXx8UjtpZihBcnJheS5pc0FycmF5KEcpJiYoRz1wW2pdKEcpKSxMW0RdPXtuYW1lOkEsZGF0YTpHfSxSLmRpdmlzb3IhPW51bGwpe2lmKCF0aGlzLmlzV2ViR0wyJiYhdGhpcy5haWFfZXh0KXRocm93IG5ldyBFcnJvcigiQ2Fubm90IHVzZSBkaXZpc29yIGluIHRoaXMgcmVuZGVyaW5nIGNvbnRleHQsIHVzZSB3ZWJnbDIgY29udGV4dCBpbnN0ZWFkLiIpO0xbRF0uZGl2aXNvcj1SLmRpdmlzb3J9fX0pLFAuYXR0cmlidXRlcz1MfXJldHVybiBQfSksdGhpcy5vcHRpb25zLmF1dG9VcGRhdGUmJnRoaXMudXBkYXRlKCl9Y3JlYXRlUHJvZ3JhbShNLG0pe2NvbnN0IHk9L15ccyp1bmlmb3JtXHMrc2FtcGxlci9tZy50ZXN0KE0pO009PW51bGwmJihNPWguZGVmYXVsdCksbT09bnVsbCYmKG09eT9nLmRlZmF1bHQ6aS5kZWZhdWx0KTtjb25zdCBuPXRoaXMuZ2wsbz1PYmplY3Qoci5jcmVhdGVQcm9ncmFtKShuLG0sTSk7by5zaGFkZXJUZXh0PXt2ZXJ0ZXhTaGFkZXI6bSxmcmFnbWVudFNoYWRlcjpNfSxvLl9idWZmZXJzPXt9LG8uX2F0dHJpYnV0ZT17fSxvLnVuaWZvcm1zPXt9LG8uX3NhbXBsZXJNYXA9e30sby5fYmluZFRleHR1cmVzPVtdO2NvbnN0IHM9bmV3IFJlZ0V4cChgKD86YXR0cmlidXRlfGluKSB2ZWMoXFxkKSAke3RoaXMub3B0aW9ucy52ZXJ0ZXhQb3NpdGlvbn1gLCJpbSIpO2xldCBsPW0ubWF0Y2gocyk7bCYmKG8uX2RpbWVuc2lvbj1OdW1iZXIobFsxXSkpO2NvbnN0IEU9bmV3IFJlZ0V4cChgKD86YXR0cmlidXRlfGluKSB2ZWMoXFxkKSAke3RoaXMub3B0aW9ucy52ZXJ0ZXhUZXh0dXJlQ29vcmR9YCwiaW0iKTtsPW0ubWF0Y2goRSksbCYmKG8uX3RleENvb3JkU2l6ZT1OdW1iZXIobFsxXSkpO2NvbnN0IFQ9L15ccyooPzphdHRyaWJ1dGV8aW4pIChcdys/KShcZCopIChcdyspL2dpbTtpZihsPW0ubWF0Y2goVCksbClmb3IobGV0IFA9MDtQPGwubGVuZ3RoO1ArKyl7Y29uc3QgTD0vXlxzKig/OmF0dHJpYnV0ZXxpbikgKFx3Kz8pKFxkKikgKFx3KykvaW0sRD1sW1BdLm1hdGNoKEwpO2lmKEQmJkRbM10hPT10aGlzLm9wdGlvbnMudmVydGV4UG9zaXRpb24mJkRbM10hPT10aGlzLm9wdGlvbnMudmVydGV4VGV4dHVyZUNvb3JkKXtsZXRbLFIsQSxqXT1EO1I9PT0ibWF0IiYmKEEqKj0yKSxvLl9idWZmZXJzW2pdPW4uY3JlYXRlQnVmZmVyKCksby5fYXR0cmlidXRlW2pdPXtuYW1lOmosdHlwZTpSLHNpemU6TnVtYmVyKEEpfHwxfX19Y29uc3QgYj0vXlxzKnVuaWZvcm1ccysoXHcrKVxzKyhcdyspKFxbXGQrXF0pPy9tZztsPW0ubWF0Y2goYil8fFtdLGw9bC5jb25jYXQoTS5tYXRjaChiKXx8W10pLGwuZm9yRWFjaChQPT57Y29uc3QgTD1QLm1hdGNoKC9eXHMqdW5pZm9ybVxzKyhcdyspXHMrKFx3KykoXFtcZCtcXSk/Lyk7bGV0W0QsUixBXT1MLnNsaWNlKDEpO0Q9dltEXSxBPSEhQSxELmluZGV4T2YoIk1hdHJpeCIpIT09MCYmQSYmKEQrPSJ2IiksdGhpcy5fZGVjbGFyZVVuaWZvcm0obyxSLEQpfSksby5fYnVmZmVycy52ZXJ0aWNlc0J1ZmZlcj1uLmNyZWF0ZUJ1ZmZlcigpLG8uX2J1ZmZlcnMuY2VsbHNCdWZmZXI9bi5jcmVhdGVCdWZmZXIoKTtjb25zdCBJPW4uZ2V0QXR0cmliTG9jYXRpb24obyx0aGlzLm9wdGlvbnMudmVydGV4VGV4dHVyZUNvb3JkKTtyZXR1cm4gby5fZW5hYmxlVGV4dHVyZXM9ST49MCxvLl9lbmFibGVUZXh0dXJlcyYmKG8uX2J1ZmZlcnMudGV4Q29vcmRCdWZmZXI9bi5jcmVhdGVCdWZmZXIoKSksdGhpcy5wcm9ncmFtcy5wdXNoKG8pLG99dXNlUHJvZ3JhbShNLG09e30pe3RoaXMuc3RhcnRSZW5kZXI9ITEsdGhpcy5fcmVuZGVyRnJhbWVJRCYmKGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuX3JlbmRlckZyYW1lSUQpLGRlbGV0ZSB0aGlzLl9yZW5kZXJGcmFtZUlEKTtjb25zdCB5PXRoaXMuZ2w7eS51c2VQcm9ncmFtKE0pO2NvbnN0IG49TS5fZGltZW5zaW9uO3kuYmluZEJ1ZmZlcih5LkFSUkFZX0JVRkZFUixNLl9idWZmZXJzLnZlcnRpY2VzQnVmZmVyKTtjb25zdCBvPXkuZ2V0QXR0cmliTG9jYXRpb24oTSx0aGlzLm9wdGlvbnMudmVydGV4UG9zaXRpb24pO2lmKHkudmVydGV4QXR0cmliUG9pbnRlcihvLG4seS5GTE9BVCwhMSwwLDApLHkuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkobyksTS5fZW5hYmxlVGV4dHVyZXMpe3kuYmluZEJ1ZmZlcih5LkFSUkFZX0JVRkZFUixNLl9idWZmZXJzLnRleENvb3JkQnVmZmVyKTtjb25zdCBzPXkuZ2V0QXR0cmliTG9jYXRpb24oTSx0aGlzLm9wdGlvbnMudmVydGV4VGV4dHVyZUNvb3JkKTt5LnZlcnRleEF0dHJpYlBvaW50ZXIocyxNLl90ZXhDb29yZFNpemV8fDIseS5GTE9BVCwhMSwwLDApLHkuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkocyl9aWYoT2JqZWN0LmVudHJpZXMoTS5fYXR0cmlidXRlKS5mb3JFYWNoKChbcyxsXSk9PntpZihsIT09Imlnbm9yZWQiKXtjb25zdCBFPWwuc2l6ZSxUPW1bc118fHt9LGI9ISFULm5vcm1hbGl6ZTtsZXQgST1ULnR5cGV8fCJGTE9BVCI7Y29uc3QgUD1ULmtleXx8cztJPT09IlVCWVRFIiYmKEk9IlVOU0lHTkVEX0JZVEUiKSxJPT09IlVTSE9SVCImJihJPSJVTlNJR05FRF9TSE9SVCIpLGwudHlwZT1JLFAmJlAhPT1zJiYoTS5fYXR0cmlidXRlW1BdPWwpLHkuYmluZEJ1ZmZlcih5LkFSUkFZX0JVRkZFUixNLl9idWZmZXJzW3NdKTtjb25zdCBMPXkuZ2V0QXR0cmliTG9jYXRpb24oTSxzKTtMPj0wJiYoeS52ZXJ0ZXhBdHRyaWJQb2ludGVyKEwsRSx5W0ldLGIsMCwwKSx5LmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KEwpKX19KSwhTS5tZXNoRGF0YSl7Y29uc3Qgcz1bWy0xLC0xLDAsMV0uc2xpY2UoMCxuKSxbMSwtMSwwLDFdLnNsaWNlKDAsbiksWzEsMSwwLDFdLnNsaWNlKDAsbiksWy0xLDEsMCwxXS5zbGljZSgwLG4pXSxsPVtbMCwxLDNdLFszLDEsMl1dO3RoaXMuc2V0TWVzaERhdGEoe3Bvc2l0aW9uczpzLGNlbGxzOmx9KX1yZXR1cm4gTX1jb21waWxlU3luYyhNLG0pe009TXx8aC5kZWZhdWx0O2NvbnN0IHk9e307ZnVuY3Rpb24gbihFKXtFPUUucmVwbGFjZSgvXlxzKi9tZywiIik7Y29uc3QgVD1bXSxiPUUubWF0Y2goL14jcHJhZ21hXHMraW5jbHVkZVxzKy4qL21nKTtpZihiKXtmb3IobGV0IEk9MDtJPGIubGVuZ3RoO0krKyl7Y29uc3QgTD1iW0ldLm1hdGNoKC8oPzo8fCIpKC4qKSg/Oj58IikvKTtpZihMKXtjb25zdCBEPUxbMF0uaW5kZXhPZigiPCIpPT09MD8ibGliIjoibGluayI7bGV0IFI9TFsxXTtpZihSPT09ImdyYXBoIiYmKFI9ImdyYXBoaWNzIikseVtSXSlULnB1c2goYC8qIGluY2x1ZGVkICR7Un0gKi9gKTtlbHNlIGlmKHlbUl09ITAsRD09PSJsaWIiKXtjb25zdCBBPW4oYVtSXSk7VC5wdXNoKEEpfWVsc2UgaWYoRD09PSJsaW5rIil0aHJvdyBuZXcgRXJyb3IoIkNhbm5vdCBsb2FkIGV4dGVybmFsIGxpbmtzIHN5bmNocm9ub3VzbHkuIFVzZSBjb21waWxlIGluc3RlYWQgb2YgY29tcGlsZVN5bmMuIil9fVQuZm9yRWFjaChJPT57RT1FLnJlcGxhY2UoL14jcHJhZ21hXHMraW5jbHVkZVxzKy4qL20sSSl9KX1yZXR1cm4gRX1jb25zdCBvPW4oTSkscz1tP24obSk6bnVsbDtyZXR1cm4gdGhpcy5jcmVhdGVQcm9ncmFtKG8scyl9YXN5bmMgY29tcGlsZShNLG0pe009TXx8aC5kZWZhdWx0O2NvbnN0IHk9e307YXN5bmMgZnVuY3Rpb24gbihFKXtFPUUucmVwbGFjZSgvXlxzKi9tZywiIik7Y29uc3QgVD1bXSxiPUUubWF0Y2goL14jcHJhZ21hXHMraW5jbHVkZVxzKy4qL21nKTtpZihiKXtmb3IobGV0IEk9MDtJPGIubGVuZ3RoO0krKyl7Y29uc3QgTD1iW0ldLm1hdGNoKC8oPzo8fCIpKC4qKSg/Oj58IikvKTtpZihMKXtjb25zdCBEPUxbMF0uaW5kZXhPZigiPCIpPT09MD8ibGliIjoibGluayI7bGV0IFI9TFsxXTtpZihSPT09ImdyYXBoIiYmKFI9ImdyYXBoaWNzIikseVtSXSlULnB1c2goYC8qIGluY2x1ZGVkICR7Un0gKi9gKTtlbHNlIGlmKHlbUl09ITAsRD09PSJsaWIiKXtjb25zdCBBPWF3YWl0IG4oYVtSXSk7VC5wdXNoKEEpfWVsc2UgaWYoRD09PSJsaW5rIil7bGV0IEE9YXdhaXQgcC5mZXRjaFNoYWRlcihSKTtBPWF3YWl0IG4oQSksVC5wdXNoKEEpfX19VC5mb3JFYWNoKEk9PntFPUUucmVwbGFjZSgvXiNwcmFnbWFccytpbmNsdWRlXHMrLiovbSxJKX0pfXJldHVybiBFfWNvbnN0IG89YXdhaXQgbihNKSxzPW0/YXdhaXQgbihtKTpudWxsO3JldHVybiB0aGlzLmNyZWF0ZVByb2dyYW0obyxzKX1hc3luYyBsb2FkKE0sbT1udWxsKXtyZXR1cm4gTT1hd2FpdCBwLmZldGNoU2hhZGVyKE0pLG0mJihtPWF3YWl0IHAuZmV0Y2hTaGFkZXIobSkpLHRoaXMuY29tcGlsZShNLG0pfWNyZWF0ZVRleHR1cmUoTT1udWxsLHt3cmFwUzptPXRoaXMuZ2wuQ0xBTVBfVE9fRURHRSx3cmFwVDp5PXRoaXMuZ2wuQ0xBTVBfVE9fRURHRSxtaW5GaWx0ZXI6bj10aGlzLmdsLkxJTkVBUixtYWdGaWx0ZXI6bz10aGlzLmdsLkxJTkVBUn09e30pe2NvbnN0IHM9dGhpcy5nbCxsPUFycmF5LmlzQXJyYXkoTSk/cy5URVhUVVJFX0NVQkVfTUFQOnMuVEVYVFVSRV8yRDt0aGlzLl9tYXhfdGV4dHVyZV9pbWFnZV91bml0cz10aGlzLl9tYXhfdGV4dHVyZV9pbWFnZV91bml0c3x8cy5nZXRQYXJhbWV0ZXIocy5NQVhfQ09NQklORURfVEVYVFVSRV9JTUFHRV9VTklUUykscy5hY3RpdmVUZXh0dXJlKHMuVEVYVFVSRTArdGhpcy5fbWF4X3RleHR1cmVfaW1hZ2VfdW5pdHMtMSk7Y29uc3QgRT1zLmNyZWF0ZVRleHR1cmUoKTtzLmJpbmRUZXh0dXJlKGwsRSkscy5waXhlbFN0b3JlaShzLlVOUEFDS19GTElQX1lfV0VCR0wsITApO2NvbnN0e3dpZHRoOlQsaGVpZ2h0OmJ9PXRoaXMuY2FudmFzO2lmKE0paWYobD09PXMuVEVYVFVSRV9DVUJFX01BUClmb3IobGV0IEk9MDtJPDY7SSsrKXMudGV4SW1hZ2UyRChzLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCtJLDAscy5SR0JBLHMuUkdCQSxzLlVOU0lHTkVEX0JZVEUsTVtJXSk7ZWxzZSBzLnRleEltYWdlMkQobCwwLHMuUkdCQSxzLlJHQkEscy5VTlNJR05FRF9CWVRFLE0pO2Vsc2UgaWYobD09PXMuVEVYVFVSRV9DVUJFX01BUClmb3IobGV0IEk9MDtJPDY7SSsrKXRoaXMuZ2wudGV4SW1hZ2UyRCh0aGlzLmdsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCtJLDAscy5SR0JBLFQsYiwwLHMuUkdCQSxzLlVOU0lHTkVEX0JZVEUsbnVsbCk7ZWxzZSBzLnRleEltYWdlMkQobCwwLHMuUkdCQSxULGIsMCxzLlJHQkEscy5VTlNJR05FRF9CWVRFLG51bGwpO3JldHVybiBzLnRleFBhcmFtZXRlcmkobCxzLlRFWFRVUkVfTUlOX0ZJTFRFUixuKSxzLnRleFBhcmFtZXRlcmkobCxzLlRFWFRVUkVfTUFHX0ZJTFRFUixvKSxzLnRleFBhcmFtZXRlcmkobCxzLlRFWFRVUkVfV1JBUF9TLG0pLHMudGV4UGFyYW1ldGVyaShsLHMuVEVYVFVSRV9XUkFQX1QseSksbD09PXMuVEVYVFVSRV9DVUJFX01BUCYmKE0ud2lkdGg9TVswXS53aWR0aCxNLmhlaWdodD1NWzBdLmhlaWdodCkscy5iaW5kVGV4dHVyZShsLG51bGwpLEUuX2ltZz1NfHx7d2lkdGg6VCxoZWlnaHQ6Yn0sRS5kZWxldGU9KCk9Pnt0aGlzLmRlbGV0ZVRleHR1cmUoRSl9LEV9ZGVsZXRlVGV4dHVyZShNKXtjb25zdCBtPU0uX2ltZzt0aGlzLmdsLmRlbGV0ZVRleHR1cmUoTSksdHlwZW9mIG0uY2xvc2U9PSJmdW5jdGlvbiImJm0uY2xvc2UoKX1hc3luYyBsb2FkVGV4dHVyZShNLHt1c2VJbWFnZUJpdG1hcDptPSEwfT17fSl7Y29uc3QgeT1hd2FpdCBwLmxvYWRJbWFnZShNLHt1c2VJbWFnZUJpdG1hcDptfSk7cmV0dXJuIHRoaXMuY3JlYXRlVGV4dHVyZSh5KX1jcmVhdGVGQk8oe2NvbG9yOk09MSxibGVuZDptPSExLGRlcHRoOnk9dGhpcy5vcHRpb25zLmRlcHRoIT09ITEsc3RlbmNpbDpuPSEhdGhpcy5vcHRpb25zLnN0ZW5jaWx9PXt9KXtjb25zdCBvPXRoaXMuZ2wscz1vLmNyZWF0ZUZyYW1lYnVmZmVyKCk7by5iaW5kRnJhbWVidWZmZXIoby5GUkFNRUJVRkZFUixzKTtjb25zdCBsPVtdO2ZvcihsZXQgYj0wO2I8TTtiKyspe2NvbnN0IEk9dGhpcy5jcmVhdGVUZXh0dXJlKCk7by5mcmFtZWJ1ZmZlclRleHR1cmUyRChvLkZSQU1FQlVGRkVSLG8uQ09MT1JfQVRUQUNITUVOVDArYixvLlRFWFRVUkVfMkQsSSwwKSxsLnB1c2goSSl9cy50ZXh0dXJlcz1sLHMudGV4dHVyZT1sWzBdLHMuYmxlbmQ9bTtjb25zdHt3aWR0aDpFLGhlaWdodDpUfT10aGlzLmNhbnZhcztyZXR1cm4geSYmIW4mJihzLmRlcHRoQnVmZmVyPW8uY3JlYXRlUmVuZGVyYnVmZmVyKCksby5iaW5kUmVuZGVyYnVmZmVyKG8uUkVOREVSQlVGRkVSLHMuZGVwdGhCdWZmZXIpLG8ucmVuZGVyYnVmZmVyU3RvcmFnZShvLlJFTkRFUkJVRkZFUixvLkRFUFRIX0NPTVBPTkVOVDE2LEUsVCksby5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlcihvLkZSQU1FQlVGRkVSLG8uREVQVEhfQVRUQUNITUVOVCxvLlJFTkRFUkJVRkZFUixzLmRlcHRoQnVmZmVyKSksbiYmIXkmJihzLnN0ZW5jaWxCdWZmZXI9by5jcmVhdGVSZW5kZXJidWZmZXIoKSxvLmJpbmRSZW5kZXJidWZmZXIoby5SRU5ERVJCVUZGRVIscy5zdGVuY2lsQnVmZmVyKSxvLnJlbmRlcmJ1ZmZlclN0b3JhZ2Uoby5SRU5ERVJCVUZGRVIsby5TVEVOQ0lMX0lOREVYOCxFLFQpLG8uZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoby5GUkFNRUJVRkZFUixvLlNURU5DSUxfQVRUQUNITUVOVCxvLlJFTkRFUkJVRkZFUixzLnN0ZW5jaWxCdWZmZXIpKSx5JiZuJiYocy5kZXB0aFN0ZW5jaWxCdWZmZXI9by5jcmVhdGVSZW5kZXJidWZmZXIoKSxvLmJpbmRSZW5kZXJidWZmZXIoby5SRU5ERVJCVUZGRVIscy5kZXB0aFN0ZW5jaWxCdWZmZXIpLG8ucmVuZGVyYnVmZmVyU3RvcmFnZShvLlJFTkRFUkJVRkZFUixvLkRFUFRIX1NURU5DSUwsRSxUKSxvLmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKG8uRlJBTUVCVUZGRVIsby5ERVBUSF9TVEVOQ0lMX0FUVEFDSE1FTlQsby5SRU5ERVJCVUZGRVIscy5kZXB0aFN0ZW5jaWxCdWZmZXIpKSxvLmJpbmRGcmFtZWJ1ZmZlcihvLkZSQU1FQlVGRkVSLG51bGwpLHN9YmluZEZCTyhNPW51bGwpe3RoaXMuZmJvPU19cmVuZGVyKHtjbGVhckJ1ZmZlcjpNPSEwfT17fSl7dGhpcy5zdGFydFJlbmRlcj0hMDtjb25zdCBtPXRoaXMuZ2w7bGV0IHk9dGhpcy5wcm9ncmFtO3l8fCh5PXRoaXMuY3JlYXRlUHJvZ3JhbSgpLHRoaXMudXNlUHJvZ3JhbSh5KSksdGhpcy5mYm8mJm0uYmluZEZyYW1lYnVmZmVyKG0uRlJBTUVCVUZGRVIsdGhpcy5mYm8pO2NvbnN0IG49dGhpcy5vcHRpb25zLmRlcHRoO24mJm0uZW5hYmxlKG0uREVQVEhfVEVTVCksdGhpcy5nbC5jbGVhcih0aGlzLmdsLkNPTE9SX0JVRkZFUl9CSVR8KG4/dGhpcy5nbC5ERVBUSF9CVUZGRVJfQklUOjApfCh0aGlzLm9wdGlvbnMuc3RlbmNpbD90aGlzLmdsLlNURU5DSUxfQlVGRkVSX0JJVDowKSk7Y29uc3Qgbz10aGlzLl9yZW5kZXJGcmFtZUlEO3RoaXMuX2RyYXcoKSx0aGlzLmZibyYmbS5iaW5kRnJhbWVidWZmZXIobS5GUkFNRUJVRkZFUixudWxsKSx0aGlzLl9yZW5kZXJGcmFtZUlEPT09byYmKHRoaXMuX3JlbmRlckZyYW1lSUQ9bnVsbCl9dXBkYXRlKCl7dGhpcy5zdGFydFJlbmRlciYmdGhpcy5fcmVuZGVyRnJhbWVJRD09bnVsbCYmKHRoaXMuX3JlbmRlckZyYW1lSUQ9cmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMucmVuZGVyLmJpbmQodGhpcykpKX19dShwLCJkZWZhdWx0T3B0aW9ucyIse3ByZXNlcnZlRHJhd2luZ0J1ZmZlcjohMCxhdXRvVXBkYXRlOiEwLHZlcnRleFBvc2l0aW9uOiJhX3ZlcnRleFBvc2l0aW9uIix2ZXJ0ZXhUZXh0dXJlQ29vcmQ6ImFfdmVydGV4VGV4dHVyZUNvb3JkIix3ZWJnbDI6ITF9KSx1KHAsIlVCWVRFIixwLlVOU0lHTkVEX0JZVEUpLHUocCwiVVNIT1JUIixwLlVOU0lHTkVEX1NIT1JUKSx1KHAsImZldGNoU2hhZGVyIixyLmZldGNoU2hhZGVyKSx1KHAsImxvYWRJbWFnZSIsci5sb2FkSW1hZ2UpfSxmdW5jdGlvbihTLGUsdCl7dC5yKGUpLHQuZChlLCJzZXR1cFdlYkdMIixmdW5jdGlvbigpe3JldHVybiBpfSksdC5kKGUsImNyZWF0ZVByb2dyYW0iLGZ1bmN0aW9uKCl7cmV0dXJuIGh9KSx0LmQoZSwicG9pbnRzVG9CdWZmZXIiLGZ1bmN0aW9uKCl7cmV0dXJuIGd9KSx0LmQoZSwibG9hZEltYWdlIixmdW5jdGlvbigpe3JldHVybiBhfSksdC5kKGUsImZldGNoU2hhZGVyIixmdW5jdGlvbigpe3JldHVybiB4fSksdCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIHIoZix2KXtjb25zdCBwPVsid2ViZ2wiLCJleHBlcmltZW50YWwtd2ViZ2wiLCJ3ZWJraXQtM2QiLCJtb3otd2ViZ2wiXTtsZXQgQz1udWxsO2ZvcihsZXQgTT0wO008cC5sZW5ndGg7KytNKXt0cnl7Qz1mLmdldENvbnRleHQocFtNXSx2KX1jYXRjaHt9aWYoQylicmVha31yZXR1cm4gQ31mdW5jdGlvbiBpKGYsdil7Y29uc3QgcD1yKGYsdik7aWYoIXApdGhyb3cgbmV3IEVycm9yKCJTb3JyeSwgeW91ciBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCBXZWJHTC4iKTtyZXR1cm4gcH1mdW5jdGlvbiBoKGYsdixwKXtjb25zdCBDPWYuY3JlYXRlU2hhZGVyKGYuVkVSVEVYX1NIQURFUik7aWYoZi5zaGFkZXJTb3VyY2UoQyx2KSxmLmNvbXBpbGVTaGFkZXIoQyksIWYuZ2V0U2hhZGVyUGFyYW1ldGVyKEMsZi5DT01QSUxFX1NUQVRVUykpe2NvbnN0IHk9YFZlcnRleCBzaGFkZXIgZmFpbGVkIHRvIGNvbXBpbGUuICBUaGUgZXJyb3IgbG9nIGlzOiR7Zi5nZXRTaGFkZXJJbmZvTG9nKEMpfWA7dGhyb3cgbmV3IEVycm9yKHkpfWNvbnN0IE09Zi5jcmVhdGVTaGFkZXIoZi5GUkFHTUVOVF9TSEFERVIpO2lmKGYuc2hhZGVyU291cmNlKE0scCksZi5jb21waWxlU2hhZGVyKE0pLCFmLmdldFNoYWRlclBhcmFtZXRlcihNLGYuQ09NUElMRV9TVEFUVVMpKXtjb25zdCB5PWBGcmFnbWVudCBzaGFkZXIgZmFpbGVkIHRvIGNvbXBpbGUuICBUaGUgZXJyb3IgbG9nIGlzOiR7Zi5nZXRTaGFkZXJJbmZvTG9nKE0pfWA7dGhyb3cgbmV3IEVycm9yKHkpfWNvbnN0IG09Zi5jcmVhdGVQcm9ncmFtKCk7aWYoZi5hdHRhY2hTaGFkZXIobSxDKSxmLmF0dGFjaFNoYWRlcihtLE0pLGYubGlua1Byb2dyYW0obSksIWYuZ2V0UHJvZ3JhbVBhcmFtZXRlcihtLGYuTElOS19TVEFUVVMpKXtjb25zdCB5PWBTaGFkZXIgcHJvZ3JhbSBmYWlsZWQgdG8gbGluay4gIFRoZSBlcnJvciBsb2cgaXM6JHtmLmdldFByb2dyYW1JbmZvTG9nKG0pfWA7dGhyb3cgbmV3IEVycm9yKHkpfXJldHVybiBmLmRlbGV0ZVNoYWRlcihDKSxmLmRlbGV0ZVNoYWRlcihNKSxtfWZ1bmN0aW9uIGcoZix2PUZsb2F0MzJBcnJheSxwPW51bGwpe2lmKHAmJiEocCBpbnN0YW5jZW9mIHYpKXRocm93IG5ldyBUeXBlRXJyb3IoIldyb25nIGJ1ZmZlciB0eXBlLiIpO2lmKGY9PW51bGx8fGYgaW5zdGFuY2VvZiB2KXJldHVybiBmO2lmKGZbMF09PW51bGx8fGZbMF0ubGVuZ3RoPT1udWxsKXJldHVybiBwPyhwLnNldChmLDApLHApOm5ldyB2KGYpO2NvbnN0IEM9ZlswXS5sZW5ndGgsTT1mLmxlbmd0aDtwfHwocD1uZXcgdihDKk0pKTtsZXQgbT0wO2ZvcihsZXQgeT0wO3k8TTt5KyspZm9yKGxldCBuPTA7bjxDO24rKylwW20rK109Zlt5XVtuXTtyZXR1cm4gcH1jb25zdCB1PXt9O2Z1bmN0aW9uIGEoZix7dXNlSW1hZ2VCaXRtYXA6dj0hMCxhbGlhczpwPW51bGx9PXt9KXtpZighdVtmXSl7aWYodHlwZW9mIEltYWdlPT0iZnVuY3Rpb24iKXtjb25zdCBDPW5ldyBJbWFnZTt0eXBlb2YgZj09InN0cmluZyImJiEodHlwZW9mIGxvY2F0aW9uPT0ib2JqZWN0IiYmL15maWxlOi8udGVzdChsb2NhdGlvbi5ocmVmKSkmJiEvXmRhdGE6Ly50ZXN0KGYpJiYoQy5jcm9zc09yaWdpbj0iYW5vbnltb3VzIiksdVtmXT1uZXcgUHJvbWlzZShNPT57Qy5vbmxvYWQ9ZnVuY3Rpb24oKXt2JiZ0eXBlb2YgY3JlYXRlSW1hZ2VCaXRtYXA9PSJmdW5jdGlvbiI/Y3JlYXRlSW1hZ2VCaXRtYXAoQyx7aW1hZ2VPcmllbnRhdGlvbjoiZmxpcFkifSkudGhlbihtPT57dVtmXT1tLHAmJih1W3BdPW0pLE0obSl9KToodVtmXT1DLHAmJih1W3BdPUMpLE0oQykpfSxDLnNyYz1mfSkscCYmKHVbcF09dVtmXSl9ZWxzZSBpZih0eXBlb2YgZmV0Y2g9PSJmdW5jdGlvbiIpcmV0dXJuIGZldGNoKGYse21ldGhvZDoiR0VUIixtb2RlOiJjb3JzIixjYWNoZToiZGVmYXVsdCJ9KS50aGVuKEM9PkMuYmxvYigpKS50aGVuKEM9PmNyZWF0ZUltYWdlQml0bWFwKEMse2ltYWdlT3JpZW50YXRpb246ImZsaXBZIn0pLnRoZW4oTT0+KHVbZl09TSxwJiYodVtwXT1NKSxNKSkpfXJldHVybiB1W2ZdfWNvbnN0IGM9e307YXN5bmMgZnVuY3Rpb24geChmKXtpZihjW2ZdKXJldHVybiBjW2ZdO2NvbnN0IHY9YXdhaXQgZmV0Y2goZik7aWYodi5zdGF0dXM+PTIwMCYmdi5zdGF0dXM8MzAwKXtjb25zdCBwPWF3YWl0IHYudGV4dCgpO3JldHVybiBjW2ZdPXAscH10aHJvdyBuZXcgRXJyb3IoIlNoYWRlciBsb2FkZWQgZXJyb3IuIil9fSxmdW5jdGlvbihTLGUsdCl7dC5yKGUpLGUuZGVmYXVsdD1gYXR0cmlidXRlIHZlYzMgYV92ZXJ0ZXhQb3NpdGlvbjsKCnZvaWQgbWFpbigpIHsKICBnbF9Qb2ludFNpemUgPSAxLjA7CiAgZ2xfUG9zaXRpb24gPSB2ZWM0KGFfdmVydGV4UG9zaXRpb24sIDEpOwp9YH0sZnVuY3Rpb24oUyxlLHQpe3QucihlKSxlLmRlZmF1bHQ9YCNpZmRlZiBHTF9FUwpwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDsKI2VuZGlmCgp2b2lkIG1haW4oKSB7CiAgZ2xfRnJhZ0NvbG9yID0gdmVjNCgwLjAsIDAuMCwgMC4wLCAwLjEpOwp9YH0sZnVuY3Rpb24oUyxlLHQpe3QucihlKSxlLmRlZmF1bHQ9YGF0dHJpYnV0ZSB2ZWM0IGFfdmVydGV4UG9zaXRpb247CmF0dHJpYnV0ZSB2ZWMyIGFfdmVydGV4VGV4dHVyZUNvb3JkOwp2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDsKCnZvaWQgbWFpbigpIHsKICBnbF9Qb2ludFNpemUgPSAxLjA7CiAgZ2xfUG9zaXRpb24gPSBhX3ZlcnRleFBvc2l0aW9uOwogIHZUZXh0dXJlQ29vcmQgPSBhX3ZlcnRleFRleHR1cmVDb29yZDsKfWB9LGZ1bmN0aW9uKFMsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIGd9KTt2YXIgcj10KDIxKSxpPXQoMjUpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCBoPVN5bWJvbCgidHJhbnNmb3JtIik7Y2xhc3MgZ3tjb25zdHJ1Y3RvcihhLGMpe3RoaXMuY29udGV4dD1hLmdldENvbnRleHQoIjJkIiksdGhpcy5vcHRpb25zPWMsdGhpc1toXT1bMSwwLDAsMSwwLDBdfWNyZWF0ZVRleHR1cmUoYSl7cmV0dXJue19pbWc6YX19YXN5bmMgbG9hZFRleHR1cmUoYSl7Y29uc3QgYz1hd2FpdCByLmRlZmF1bHQubG9hZEltYWdlKGEse3VzZUltYWdlQml0bWFwOiExfSk7cmV0dXJuIHRoaXMuY3JlYXRlVGV4dHVyZShjKX1kZWxldGVUZXh0dXJlKGEpe3JldHVybiBhfWNsZWFyKGEsYyx4LGYpe2NvbnN0IHY9dGhpcy5jb250ZXh0O2E9YXx8MCxjPWN8fDAseD14fHx2LmNhbnZhcy53aWR0aC1hLGY9Znx8di5jYW52YXMuaGVpZ2h0LWMsdi5jbGVhclJlY3QoYSxjLHgsZil9ZHJhd01lc2hDbG91ZChhLHtjbGVhcjpjPSExfT17fSl7Y29uc3QgeD1bXTtmb3IobGV0IGY9MDtmPGEuYW1vdW50O2YrKyl7Y29uc3Qgdj1hLmdldFRyYW5zZm9ybShmKTtsZXQgcD1hLmdldFRleHR1cmVGcmFtZShmKTtwJiYocD1wLl9pbWcpO2NvbnN0IEM9YS5nZXRGaWx0ZXIoZikse2ZpbGw6TSxzdHJva2U6bX09YS5nZXRDbG91ZFJHQkEoZik7eC5wdXNoKHttZXNoOmEubWVzaCxfY2xvdWRPcHRpb25zOltNLG0scCx2LENdfSl9YS5iZWZvcmVSZW5kZXImJmEuYmVmb3JlUmVuZGVyKHRoaXMuY29udGV4dCxhKSx0aGlzLmRyYXdNZXNoZXMoeCx7Y2xlYXI6Yyxob29rOiExfSksYS5hZnRlclJlbmRlciYmYS5hZnRlclJlbmRlcih0aGlzLmNvbnRleHQsYSl9ZHJhd01lc2hlcyhhLHtjbGVhcjpjPSExLGhvb2s6eD0hMH09e30pe2NvbnN0IGY9dGhpcy5jb250ZXh0O2MmJmYuY2xlYXJSZWN0KDAsMCxmLmNhbnZhcy53aWR0aCxmLmNhbnZhcy5oZWlnaHQpO2xldCB2PW51bGw7Y29uc3R7d2lkdGg6cCxoZWlnaHQ6Q309Zi5jYW52YXMsTT1hLmxlbmd0aDthLmZvckVhY2goKG0seSk9PntsZXQgbixvLHMsbCxFO3gmJm0uYmVmb3JlUmVuZGVyJiZtLmJlZm9yZVJlbmRlcihmLG0pLG0uX2Nsb3VkT3B0aW9ucyYmKFtuLG8scyxsLEVdPW0uX2Nsb3VkT3B0aW9ucyxtPW0ubWVzaCk7bGV0IFQ9bS5maWx0ZXI7aWYoRSYmKFQ9VD9gJHtUfSAke0V9YDpFKSxUJiYhdGhpcy5maWx0ZXJCdWZmZXImJnRoaXMuZmlsdGVyQnVmZmVyIT09ITEpe2NvbnN0IGI9ci5kZWZhdWx0LmNyZWF0ZUNhbnZhcyhwLEMpO2I/dGhpcy5maWx0ZXJCdWZmZXI9Yi5nZXRDb250ZXh0KCIyZCIpOnRoaXMuZmlsdGVyQnVmZmVyPSExfXYmJnYhPT1UJiYoT2JqZWN0KGkuYXBwbHlGaWx0ZXIpKHRoaXMuZmlsdGVyQnVmZmVyLHYpLGYuZHJhd0ltYWdlKHRoaXMuZmlsdGVyQnVmZmVyLmNhbnZhcywwLDAscCxDKSx0aGlzLmZpbHRlckJ1ZmZlci5jbGVhclJlY3QoMCwwLHAsQyksdj1udWxsKSxUJiZ0aGlzLmZpbHRlckJ1ZmZlcj8odGhpcy5maWx0ZXJCdWZmZXIuc2F2ZSgpLHRoaXMuZmlsdGVyQnVmZmVyLnRyYW5zZm9ybSguLi50aGlzW2hdKSxPYmplY3QoaS5kcmF3TWVzaDJEKShtLHRoaXMuZmlsdGVyQnVmZmVyLCExLG4sbyxzLGwpLHRoaXMuZmlsdGVyQnVmZmVyLnJlc3RvcmUoKSx5PT09TS0xPyhPYmplY3QoaS5hcHBseUZpbHRlcikodGhpcy5maWx0ZXJCdWZmZXIsVCksZi5kcmF3SW1hZ2UodGhpcy5maWx0ZXJCdWZmZXIuY2FudmFzLDAsMCxwLEMpLHRoaXMuZmlsdGVyQnVmZmVyLmNsZWFyUmVjdCgwLDAscCxDKSk6dj1UKTooZi5zYXZlKCksZi50cmFuc2Zvcm0oLi4udGhpc1toXSksT2JqZWN0KGkuZHJhd01lc2gyRCkobSxmLCExLG4sbyxzLGwpLGYucmVzdG9yZSgpKSx4JiZtLmFmdGVyUmVuZGVyJiZtLmFmdGVyUmVuZGVyKGYsbSl9KX1zZXRUcmFuc2Zvcm0oYSl7dGhpc1toXT1hfX19LGZ1bmN0aW9uKFMsZSx0KXt0LnIoZSksKGZ1bmN0aW9uKHIpe3ZhciBpPXQoMTQpLGg9dCgyMyksZz10KDI0KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3QgdT17fTtmdW5jdGlvbiBhKHAsQyl7Y29uc3R7c3R5bGU6TSx2YXJpYW50Om0sd2VpZ2h0Onksc3RyZXRjaDpuLHNpemU6byxweExpbmVIZWlnaHQ6cyxmYW1pbHk6bH09cDtyZXR1cm4gbj09PSJub3JtYWwiP2Ake019ICR7bX0gJHt5fSAke28qQ31weC8ke3MqQ31weCAke2x9YDpgJHtNfSAke219ICR7eX0gJHtufSAke28qQ31weC8ke3MqQ31weCAke2x9YH1mdW5jdGlvbiBjKHAse2ZvbnQ6QyxmaWxsQ29sb3I6TSxzdHJva2VDb2xvcjptLHN0cm9rZVdpZHRoOnkscmF0aW86bj0xLHRleHRDYW52YXM6byxjYWNoYWJsZTpzPSExfSl7bGV0IGw7aWYocyl7bD1bcCxDLFN0cmluZyhNKSxTdHJpbmcobSksU3RyaW5nKHkpXS5qb2luKCIjIyMiKTtjb25zdCBHPXVbbF07aWYoRylyZXR1cm4gR31vfHwobz1mKDEsMSkpO2NvbnN0IEU9by5nZXRDb250ZXh0KCIyZCIpO0Uuc2F2ZSgpLEUuZm9udD1DO2xldHt3aWR0aDpUfT1FLm1lYXN1cmVUZXh0KHApO0UucmVzdG9yZSgpO2NvbnN0IGI9T2JqZWN0KGguZGVmYXVsdCkoQyksST1NYXRoLm1heChiLnB4TGluZUhlaWdodCxiLnB4SGVpZ2h0KjEuMTMpOy9pdGFsaWN8b2JsaXF1ZS8udGVzdChDKSYmKFQrPUkqTWF0aC50YW4oMTUqTWF0aC5QSS8xODApKSwhTSYmIW0mJihNPSIjMDAwIik7Y29uc3QgUD1FLmNhbnZhcyxMPU1hdGguY2VpbChUKSxEPU1hdGguY2VpbChJKTtQLndpZHRoPU1hdGgucm91bmQoTCpuKSxQLmhlaWdodD1NYXRoLnJvdW5kKEQqbiksRS5zYXZlKCksRS5mb250PWEoYixuKSxFLnRleHRBbGlnbj0iY2VudGVyIixFLnRleHRCYXNlbGluZT0ibWlkZGxlIjtjb25zdCBSPVAuaGVpZ2h0Ki41K2IucHhIZWlnaHQqLjA1Km4sQT1QLndpZHRoKi41O2lmKE0pe2lmKEFycmF5LmlzQXJyYXkoTSkpTT1PYmplY3QoZy5kZWZhdWx0KShNKTtlbHNlIGlmKE0udmVjdG9yKXtsZXQgRztjb25zdHt2ZWN0b3I6SCxjb2xvcnM6Wn09TTtILmxlbmd0aD09PTY/Rz1FLmNyZWF0ZVJhZGlhbEdyYWRpZW50KC4uLkgpOkc9RS5jcmVhdGVMaW5lYXJHcmFkaWVudCguLi5IKSxaLmZvckVhY2goKHtvZmZzZXQ6cSxjb2xvcjpGfSk9PntHLmFkZENvbG9yU3RvcChxLEYpfSksTT1HfUUuZmlsbFN0eWxlPU0sRS5maWxsVGV4dChwLEEsUil9aWYobSl7aWYoRS5saW5lV2lkdGg9eSpuLEFycmF5LmlzQXJyYXkobSkpbT1PYmplY3QoZy5kZWZhdWx0KShtKTtlbHNlIGlmKG0udmVjdG9yKXtsZXQgRztjb25zdHt2ZWN0b3I6SCxjb2xvcnM6Wn09bTtILmxlbmd0aD09PTY/Rz1FLmNyZWF0ZVJhZGlhbEdyYWRpZW50KC4uLkgpOkc9RS5jcmVhdGVMaW5lYXJHcmFkaWVudCguLi5IKSxaLmZvckVhY2goKHtvZmZzZXQ6cSxjb2xvcjpGfSk9PntHLmFkZENvbG9yU3RvcChxLEYpfSksbT1HfUUuc3Ryb2tlU3R5bGU9bSxFLnN0cm9rZVRleHQocCxBLFIpfUUucmVzdG9yZSgpO2NvbnN0IGo9e2ltYWdlOm8scmVjdDpbMCwwLEwsRF19O3JldHVybiBzJiYodVtsXT1qKSxqfWxldCB4PSExO2lmKHR5cGVvZiBuYXZpZ2F0b3I9PSJvYmplY3QiJiZ0eXBlb2YgbmF2aWdhdG9yLnVzZXJBZ2VudD09InN0cmluZyIpe2NvbnN0IHA9bmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9jaHJvbWVcLyhcZCspLyk7cCYmKHg9TnVtYmVyKHBbMV0pPDcwKX1mdW5jdGlvbiBmKHAsQyxNPXt9KXtjb25zdCBtPU0ub2Zmc2NyZWVufHwheCYmTS5vZmZzY3JlZW4hPT0hMTtsZXQgeTtyZXR1cm4gdHlwZW9mIHI8InUiJiZ0eXBlb2Ygci5jcmVhdGVDYW52YXM9PSJmdW5jdGlvbiI/eT1yLmNyZWF0ZUNhbnZhcyhwLEMsTSk6bSYmdHlwZW9mIE9mZnNjcmVlbkNhbnZhcz09ImZ1bmN0aW9uIj95PW5ldyBPZmZzY3JlZW5DYW52YXMocCxDKTooeT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJjYW52YXMiKSx5LndpZHRoPXAseS5oZWlnaHQ9QykseX1jb25zdCB2PXtjcmVhdGVDYW52YXM6ZixjcmVhdGVUZXh0OmMsbG9hZEltYWdlOmkuZGVmYXVsdC5sb2FkSW1hZ2V9O2UuZGVmYXVsdD12fSkuY2FsbCh0aGlzLHQoMjIpKX0sZnVuY3Rpb24oUyxlKXt2YXIgdDt0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9KCk7dHJ5e3Q9dHx8bmV3IEZ1bmN0aW9uKCJyZXR1cm4gdGhpcyIpKCl9Y2F0Y2h7dHlwZW9mIHdpbmRvdz09Im9iamVjdCImJih0PXdpbmRvdyl9Uy5leHBvcnRzPXR9LGZ1bmN0aW9uKFMsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIE19KSx0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gcihtLHkpe2lmKHR5cGVvZiBtPT0ic3RyaW5nIil7Y29uc3Qgcz1tLnRyaW0oKS5tYXRjaCgvXihbXGQuXSspKHB4fHB0fHBjfGlufGNtfG1tfGVtfGV4fHJlbXxxfHZ3fHZofHZtYXh8dm1pbnwlKSQvKTtzP209e3NpemU6cGFyc2VGbG9hdChzWzFdKSx1bml0OnNbMl19Om09e3NpemU6cGFyc2VJbnQobSwxMCksdW5pdDoicHgifX1sZXR7c2l6ZTpuLHVuaXQ6b309bTtpZihvPT09InB0IiluLz0uNzU7ZWxzZSBpZihvPT09InBjIiluKj0xNjtlbHNlIGlmKG89PT0iaW4iKW4qPTk2O2Vsc2UgaWYobz09PSJjbSIpbio9OTYvMi41NDtlbHNlIGlmKG89PT0ibW0iKW4qPTk2LzI1LjQ7ZWxzZSBpZihvPT09ImVtInx8bz09PSJyZW0ifHxvPT09ImV4Iil7aWYoIXkmJnR5cGVvZiBnZXRDb21wdXRlZFN0eWxlPT0iZnVuY3Rpb24iJiZ0eXBlb2YgZG9jdW1lbnQ8InUiKXtjb25zdCBzPWdldENvbXB1dGVkU3R5bGUoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KS5mb250U2l6ZTt5PXIocywxNil9bio9eSxvPT09ImV4IiYmKG4vPTIpfWVsc2UgaWYobz09PSJxIiluKj05Ni8yNS40LzQ7ZWxzZSBpZihvPT09InZ3Inx8bz09PSJ2aCIpe2lmKHR5cGVvZiBkb2N1bWVudDwidSIpe2NvbnN0IHM9bz09PSJ2dyI/ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoOmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQ7bio9cy8xMDB9fWVsc2UgaWYoKG89PT0idm1heCJ8fG89PT0idm1pbiIpJiZ0eXBlb2YgZG9jdW1lbnQ8InUiKXtjb25zdCBzPWRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCxsPWRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQ7bz09PSJ2bWF4Ij9uKj1NYXRoLm1heChzLGwpLzEwMDpuKj1NYXRoLm1pbihzLGwpLzEwMH1yZXR1cm4gbn1jb25zdCBpPSJib2xkfGJvbGRlcnxsaWdodGVyfFsxLTldMDAiLGg9Iml0YWxpY3xvYmxpcXVlIixnPSJzbWFsbC1jYXBzIix1PSJ1bHRyYS1jb25kZW5zZWR8ZXh0cmEtY29uZGVuc2VkfGNvbmRlbnNlZHxzZW1pLWNvbmRlbnNlZHxzZW1pLWV4cGFuZGVkfGV4cGFuZGVkfGV4dHJhLWV4cGFuZGVkfHVsdHJhLWV4cGFuZGVkIixhPSJweHxwdHxwY3xpbnxjbXxtbXxlbXxleHxyZW18cXx2d3x2aHx2bWF4fHZtaW58JSIsYz1gJyhbXiddKyknfCIoW14iXSspInwoW1xcdy1dfFvkuIAt6b6lXSkrYCx4PW5ldyBSZWdFeHAoYCgke2l9KSArYCwiaSIpLGY9bmV3IFJlZ0V4cChgKCR7aH0pICtgLCJpIiksdj1uZXcgUmVnRXhwKGAoJHtnfSkgK2AsImkiKSxwPW5ldyBSZWdFeHAoYCgke3V9KSArYCwiaSIpLEM9bmV3IFJlZ0V4cCgiKFtcXGRcXC5dKykoIithKyIpKD86XFwvKFtcXGRcXC5dKykoIithKyIpKT8gKigoPzoiK2MrIikoICosICooPzoiK2MrIikpKikiKTtmdW5jdGlvbiBNKG0seSl7Y29uc3Qgbj1DLmV4ZWMobSk7aWYoIW4pcmV0dXJuO2NvbnN0IG89cGFyc2VGbG9hdChuWzNdKSxzPXt3ZWlnaHQ6Im5vcm1hbCIsc3R5bGU6Im5vcm1hbCIsc3RyZXRjaDoibm9ybWFsIix2YXJpYW50OiJub3JtYWwiLHNpemU6cGFyc2VGbG9hdChuWzFdKSx1bml0Om5bMl0sbGluZUhlaWdodDpOdW1iZXIuaXNGaW5pdGUobyk/bzp2b2lkIDAsbGluZUhlaWdodFVuaXQ6bls0XSxmYW1pbHk6bls1XS5yZXBsYWNlKC8gKiwgKi9nLCIsIil9LGw9bS5zdWJzdHJpbmcoMCxuLmluZGV4KSxFPXguZXhlYyhsKSxUPWYuZXhlYyhsKSxiPXYuZXhlYyhsKSxJPXAuZXhlYyhsKTtyZXR1cm4gRSYmKHMud2VpZ2h0PUVbMV0pLFQmJihzLnN0eWxlPVRbMV0pLGImJihzLnZhcmlhbnQ9YlsxXSksSSYmKHMuc3RyZXRjaD1JWzFdKSxzLnB4SGVpZ2h0PXIoe3NpemU6cy5zaXplLHVuaXQ6cy51bml0fSx5KSxzLnB4TGluZUhlaWdodD1yKHtzaXplOnMubGluZUhlaWdodHx8cy5zaXplLHVuaXQ6cy5saW5lSGVpZ2h0VW5pdHx8cy51bml0fSx5KSxzfX0sZnVuY3Rpb24oUyxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gcn0pLHQoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiByKGkpe3JldHVybmByZ2JhKCR7aS5tYXAoKGgsZyk9Pmc8Mz9NYXRoLnJvdW5kKGgqMjU1KTpoKS5qb2luKCl9KWB9fSxmdW5jdGlvbihTLGUsdCl7dC5yKGUpLHQuZChlLCJhcHBseUZpbHRlciIsZnVuY3Rpb24oKXtyZXR1cm4gdX0pLHQuZChlLCJkcmF3TWVzaDJEIixmdW5jdGlvbigpe3JldHVybiBjfSk7dmFyIHI9dCgxKSxpPXQoMjQpLGg9dCgyMyksZz10KDI2KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gdSh4LGYpe2NvbnN0IHY9eC5jYW52YXM7eC5zYXZlKCkseC5maWx0ZXI9Zix4LmRyYXdJbWFnZSh2LDAsMCx2LndpZHRoLHYuaGVpZ2h0KSx4LnJlc3RvcmUoKX1mdW5jdGlvbiBhKHgsZil7Y29uc3Qgdj0vcmdiYVwoKFxkKyksKFxkKyksKFxkKyksKFxkKylcKS87eD14Lm1hdGNoKHYpLnNsaWNlKDEsNSkubWFwKE51bWJlciksZj1mLm1hdGNoKHYpLnNsaWNlKDEsNSkubWFwKE51bWJlcik7Y29uc3QgcD1bXSxDPWZbM107Zm9yKGxldCBNPTA7TTw0O00rKylwW01dPU9iamVjdChnLm1peCkoeFtNXSxmW01dLEMpO3JldHVybmByZ2JhKCR7cC5qb2luKCl9KWB9ZnVuY3Rpb24gYyh4LGYsdj0hMCxwPW51bGwsQz1udWxsLE09bnVsbCxtPW51bGwpe2Yuc2F2ZSgpO2xldCB5PSExLG49ITE7aWYoZi5nbG9iYWxBbHBoYT14LmdldE9wYWNpdHkoKSx4Ll91cGRhdGVNYXRyaXgmJngudHJhbnNmb3JtU2NhbGUveC5jb250b3Vycy5zY2FsZT4xLjUmJnguYWNjdXJhdGUoeC50cmFuc2Zvcm1TY2FsZSkseC5saW5lV2lkdGgpe2xldCBsPXguZ3JhZGllbnQmJnguZ3JhZGllbnQuc3Ryb2tlO2lmKGwpe2NvbnN0e3ZlY3RvcjpFLGNvbG9yczpUfT1sO2lmKEUubGVuZ3RoPT09NilsPWYuY3JlYXRlUmFkaWFsR3JhZGllbnQoLi4uRSk7ZWxzZSBpZihFLmxlbmd0aD09PTQpbD1mLmNyZWF0ZUxpbmVhckdyYWRpZW50KC4uLkUpO2Vsc2UgaWYoRS5sZW5ndGg9PT0zKWw9Zi5jcmVhdGVDaXJjdWxhckdyYWRpZW50KC4uLkUpO2Vsc2UgdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCB2ZWN0b3IgZGltZW5zaW9uLiIpO1QuZm9yRWFjaCgoe29mZnNldDpiLGNvbG9yOkl9KT0+e2xldCBQPU9iamVjdChpLmRlZmF1bHQpKEkpO0MmJihQPWEoUCxDKSksbC5hZGRDb2xvclN0b3AoYixQKX0pLGYuc3Ryb2tlU3R5bGU9bCx5PSEwfWVsc2UgeC5zdHJva2VTdHlsZSYmKEM/Zi5zdHJva2VTdHlsZT1hKHguc3Ryb2tlU3R5bGUsQyk6Zi5zdHJva2VTdHlsZT14LnN0cm9rZVN0eWxlLHk9ITApfXkmJihmLmxpbmVXaWR0aD14LmxpbmVXaWR0aCxmLmxpbmVKb2luPXgubGluZUpvaW4sZi5saW5lQ2FwPXgubGluZUNhcCxmLm1pdGVyTGltaXQ9eC5taXRlckxpbWl0LHgubGluZURhc2gmJihmLnNldExpbmVEYXNoKHgubGluZURhc2gpLHgubGluZURhc2hPZmZzZXQmJihmLmxpbmVEYXNoT2Zmc2V0PXgubGluZURhc2hPZmZzZXQpKSk7bGV0IG89eC5ncmFkaWVudCYmeC5ncmFkaWVudC5maWxsO2lmKG8pe2NvbnN0e3ZlY3RvcjpsLGNvbG9yczpFfT1vO2lmKGwubGVuZ3RoPT09NilvPWYuY3JlYXRlUmFkaWFsR3JhZGllbnQoLi4ubCk7ZWxzZSBpZihsLmxlbmd0aD09PTQpbz1mLmNyZWF0ZUxpbmVhckdyYWRpZW50KC4uLmwpO2Vsc2UgaWYobC5sZW5ndGg9PT0zKW89Zi5jcmVhdGVDaXJjdWxhckdyYWRpZW50KC4uLmwpO2Vsc2UgdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCB2ZWN0b3IgZGltZW5zaW9uLiIpO0UuZm9yRWFjaCgoe29mZnNldDpULGNvbG9yOmJ9KT0+e2xldCBJPU9iamVjdChpLmRlZmF1bHQpKGIpO0MmJihJPWEoSSxDKSksby5hZGRDb2xvclN0b3AoVCxJKX0pLGYuZmlsbFN0eWxlPW8sbj0hMH1lbHNlIHguZmlsbFN0eWxlJiYocD9mLmZpbGxTdHlsZT1hKHguZmlsbFN0eWxlLHApOmYuZmlsbFN0eWxlPXguZmlsbFN0eWxlLG49ITApO2lmKG0mJmYudHJhbnNmb3JtKC4uLm0pLGYudHJhbnNmb3JtKC4uLngudHJhbnNmb3JtTWF0cml4KSx4LmNsaXBQYXRoKXtjb25zdCBsPXguY2xpcFBhdGgsRT1uZXcgUGF0aDJEKGwpO2YuY2xpcChFKX1jb25zdCBzPXguY29udG91cnMubGVuZ3RoO2lmKHguY29udG91cnMuZm9yRWFjaCgobCxFKT0+e2NvbnN0IFQ9bC5sZW5ndGgsYj1UPjEmJnIudmVjMi5lcXVhbHMobFswXSxsW1QtMV0pLEk9RT09PXMtMSYmeC50ZXh0dXJlO2lmKGwmJlQ+MCl7aWYobnx8eXx8SSl7Zi5iZWdpblBhdGgoKSxmLm1vdmVUbyguLi5sWzBdKTtmb3IobGV0IFA9MTtQPFQ7UCsrKVA9PT1ULTEmJmI/Zi5jbG9zZVBhdGgoKTpmLmxpbmVUbyguLi5sW1BdKX1pZihuJiZmLmZpbGwoeC5maWxsUnVsZSksSSl7Zi5zYXZlKCksZi5jbGlwKCk7bGV0e2ltYWdlOlAsb3B0aW9uczpMfT14LnRleHR1cmU7aWYoTSYmKFA9TSksTC5yZXBlYXQmJmNvbnNvbGUud2FybigiQ29udGV4dCAyRCBub3Qgc3VwcG9ydGVkIGltYWdlIHJlcGVhdCB5ZXQuIiksUC5mb250KXtMLnNjYWxlJiZjb25zb2xlLndhcm4oIkNvbnRleHQgMkQgbm90IHN1cHBvcnRlZCB0ZXh0IHNjYWxlIHlldC4iKSxMLnNyY1JlY3QmJmNvbnNvbGUud2FybigiQ29udGV4dCAyRCBub3Qgc3VwcG9ydGVkIHRleHQgc3JjUmVjdCB5ZXQuIik7bGV0e2ZvbnQ6RCxmaWxsQ29sb3I6UixzdHJva2VDb2xvcjpBLHN0cm9rZVdpZHRoOmosdGV4dDpHfT1QOyFSJiYhQSYmKFI9IiMwMDAiKSxBcnJheS5pc0FycmF5KFIpJiYoUj1PYmplY3QoaS5kZWZhdWx0KShSKSksQXJyYXkuaXNBcnJheShBKSYmKEE9T2JqZWN0KGkuZGVmYXVsdCkoQSkpLGYuZm9udD1EO2NvbnN0e3dpZHRoOkh9PWYubWVhc3VyZVRleHQoRyksWj1PYmplY3QoaC5kZWZhdWx0KShEKSxxPU1hdGgubWF4KFoucHhMaW5lSGVpZ2h0LFoucHhIZWlnaHQqMS4xMyk7Zi50ZXh0QWxpZ249ImNlbnRlciIsZi50ZXh0QmFzZWxpbmU9Im1pZGRsZSI7Y29uc3QgRj1MLnJlY3QsJD1GWzBdK3EqLjUrWi5weEhlaWdodCouMDYsSj1GWzFdK0gqLjU7RlsyXSE9bnVsbCYmZi5zY2FsZShGWzJdL0gsRlszXS9xKSxSJiYoZi5maWxsU3R5bGU9UixmLmZpbGxUZXh0KEcsSiwkKSksQSYmKGYubGluZVdpZHRoPWosZi5zdHJva2VTdHlsZT1BLGYuc3Ryb2tlVGV4dChHLEosJCkpfWVsc2V7bGV0IEQ9TC5yZWN0O2NvbnN0IFI9TC5zcmNSZWN0O0wuc2NhbGUmJihEPVswLDAsZi5jYW52YXMud2lkdGgsZi5jYW52YXMuaGVpZ2h0XSksTC5yb3RhdGVkJiZEJiYoRD1bLURbMV0sRFswXSxEWzNdLERbMl1dKSxSJiYoRD1EfHxbMCwwLFJbMl0sUlszXV0pLEwucm90YXRlZCYmKGYudHJhbnNsYXRlKDAsRD9EWzJdOlAud2lkdGgpLGYucm90YXRlKC0uNSpNYXRoLlBJKSksUj9mLmRyYXdJbWFnZShQLC4uLlIsLi4uRCk6RD9mLmRyYXdJbWFnZShQLC4uLkQpOmYuZHJhd0ltYWdlKFAsMCwwKX1mLnJlc3RvcmUoKX15JiZmLnN0cm9rZSgpfX0pLGYucmVzdG9yZSgpLHYpe2NvbnN0IGw9eC5maWx0ZXI7bCYmdShmLGwpfX19LGZ1bmN0aW9uKFMsZSx0KXt0LnIoZSksdC5kKGUsImNsYW1wIixmdW5jdGlvbigpe3JldHVybiByfSksdC5kKGUsIm1peCIsZnVuY3Rpb24oKXtyZXR1cm4gaX0pLHQuZChlLCJ0cmFuc2Zvcm1Qb2ludCIsZnVuY3Rpb24oKXtyZXR1cm4gaH0pLHQoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiByKGcsdSxhKXtyZXR1cm4gdT5hJiYoW3UsYV09W2EsdV0pLGc8dT91Omc+YT9hOmd9ZnVuY3Rpb24gaShnLHUsYSl7cmV0dXJuIGcqKDEtYSkrdSphfWZ1bmN0aW9uIGgoZyx1KXtjb25zdFthLGNdPWc7cmV0dXJuW2EqdVswXStjKnVbMl0rdVs0XSxhKnVbMV0rYyp1WzNdK3VbNV1dfX0sZnVuY3Rpb24oUyxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gYX0pO3ZhciByPXQoMjgpLGk9dCgyOSk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIGgoYyx4LGYpe2NvbnN0IHY9Yy51bmlmb3Jtc3x8e30scD14LnVuaWZvcm1zfHx7fTtpZih2LnVfdGV4U2FtcGxlciYmcC51X3RleFNhbXBsZXImJnYudV90ZXhTYW1wbGVyIT09cC51X3RleFNhbXBsZXIpcmV0dXJuITE7Y29uc3QgQz1PYmplY3Qua2V5cyh2KSxNPU9iamVjdC5rZXlzKHApLG09Qy5pbmRleE9mKCJ1X3RleFNhbXBsZXIiKSx5PU0uaW5kZXhPZigidV90ZXhTYW1wbGVyIik7aWYobT49MCYmQy5zcGxpY2UobSwxKSx5Pj0wJiZNLnNwbGljZSh5LDEpLEMubGVuZ3RoIT09TS5sZW5ndGgpcmV0dXJuITE7Y29uc3Qgbj1DLmV2ZXJ5KG89Pntjb25zdCBzPXZbb10sbD1wW29dO2lmKHM9PT1sKXJldHVybiEwO2lmKHMubGVuZ3RoJiZsLmxlbmd0aCYmcy5sZW5ndGg9PT1sLmxlbmd0aCl7Zm9yKGxldCBFPTA7RTxzLmxlbmd0aDtFKyspaWYoc1tFXSE9PWxbRV0pcmV0dXJuITE7cmV0dXJuITB9cmV0dXJuITF9KTtpZihuKXtpZih2LnVfdGV4U2FtcGxlciYmIXAudV90ZXhTYW1wbGVyKXguc2V0VGV4dHVyZSh2LnVfdGV4U2FtcGxlcix7aGlkZGVuOiEwfSk7ZWxzZSBpZighdi51X3RleFNhbXBsZXImJnAudV90ZXhTYW1wbGVyKWZvcihsZXQgbz0wO288Zi5sZW5ndGg7bysrKWZbb10uc2V0VGV4dHVyZShwLnVfdGV4U2FtcGxlcix7aGlkZGVuOiEwfSl9cmV0dXJuIG59Y29uc3QgZz17fTtmdW5jdGlvbiB1KGMseCl7aWYoYy5sZW5ndGgpe2NvbnN0IGY9T2JqZWN0KHIuZGVmYXVsdCkoYyxnKTtyZXR1cm4gZi5lbmFibGVCbGVuZD14LGNbMF0uZmlsdGVyQ2FudmFzJiYoZi5maWx0ZXJDYW52YXM9ITApLGYucGFja0luZGV4PWNbMF0ucGFja0luZGV4LGYucGFja0xlbmd0aD1jLmxlbmd0aCxmLmJlZm9yZVJlbmRlcj1jWzBdLmJlZm9yZVJlbmRlcixmLnBhc3M9Y1swXS5wYXNzLGYuYWZ0ZXJSZW5kZXI9Y1tjLmxlbmd0aC0xXS5hZnRlclJlbmRlcixjLmxlbmd0aD0wLGZ9fWZ1bmN0aW9uKmEoYyx4LGY9ITEpe2NvbnN0IHY9W10scD1jLm9wdGlvbnMuYnVmZmVyU2l6ZTtsZXQgQz0wLE09ITE7Zm9yKGxldCBtPTA7bTx4Lmxlbmd0aDttKyspe2NvbnN0IHk9eFttXTtpZih5IGluc3RhbmNlb2YgaS5kZWZhdWx0KXYubGVuZ3RoJiYoeWllbGQgdSh2LE0pKSxDPTAsTT0hMSx5aWVsZCB5O2Vsc2V7Y29uc3Qgbj15Lm1lc2hEYXRhO2lmKG4uY2xpcFBhdGgmJiFuLnVuaWZvcm1zLnVfY2xpcFNhbXBsZXIpe2NvbnN0IHM9Yy5jcmVhdGVUZXh0dXJlKG4uY2xpcFBhdGgpO24udW5pZm9ybXMudV9jbGlwU2FtcGxlcj1zfWxldCBvPTA7aWYoKCFmfHwheS5jYW5JZ25vcmUoKSkmJm4mJm4ucG9zaXRpb25zLmxlbmd0aCl7eS5wYWNrSW5kZXg9bTtjb25zdCBzPXkuZmlsdGVyQ2FudmFzO2lmKG89bi5wb3NpdGlvbnMubGVuZ3RoLHN8fEMrbz5wKXYubGVuZ3RoJiYoeWllbGQgdSh2LE0pKSxDPTAsTT0hMTtlbHNlIGlmKEMpe2NvbnN0IGw9dlt2Lmxlbmd0aC0xXTtsJiYobC5maWx0ZXJDYW52YXN8fGwuYWZ0ZXJSZW5kZXJ8fHkuYmVmb3JlUmVuZGVyfHxsLnBhc3MubGVuZ3RofHx5LnBhc3MubGVuZ3RofHxsLnByb2dyYW0hPT15LnByb2dyYW18fCFoKGwseSx2KSkmJih5aWVsZCB1KHYsTSksQz0wLE09ITEpfXYucHVzaCh5KSxNPU18fHkuZW5hYmxlQmxlbmQsQys9b31tPT09eC5sZW5ndGgtMSYmdi5sZW5ndGgmJih5aWVsZCB1KHYsTSkpfX19fSxmdW5jdGlvbihTLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBofSksdCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IHI9e1VOU0lHTkVEX0JZVEU6VWludDhBcnJheSxVTlNJR05FRF9TSE9SVDpVaW50MTZBcnJheSxCWVRFOkludDhBcnJheSxTSE9SVDpJbnQxNkFycmF5LEZMT0FUOkZsb2F0MzJBcnJheX07ZnVuY3Rpb24gaShnLHUpe2xldCBhPTAsYz0wLHg9MCxmPTAsdj0wLHA9MCxDPTA7Y29uc3QgTT1nWzBdLnByb2dyYW07Zm9yKGxldCBtPTA7bTxnLmxlbmd0aDttKyspe2NvbnN0IHk9Z1ttXS5tZXNoRGF0YTtpZih5KXtDKz15LnBvc2l0aW9ucy5sZW5ndGg7Y29uc3Qgbj15LnBvc2l0aW9uc1swXS5sZW5ndGg7YSs9eS5wb3NpdGlvbnMubGVuZ3RoKm4sYys9eS5jZWxscy5sZW5ndGgqMyxwKz15LmF0dHJpYnV0ZXMuYV9jb2xvci5sZW5ndGgqNDtjb25zdCBvPXkudGV4dHVyZUNvb3JkO28mJih4Kz1vLmxlbmd0aCpvWzBdLmxlbmd0aCk7Y29uc3Qgcz15LmF0dHJpYnV0ZXMuYV9zb3VyY2VSZWN0O3MmJihmKz1zLmxlbmd0aCo0KTtjb25zdCBsPXkuYXR0cmlidXRlcy5hX2NsaXBVVjtsJiYodis9bC5sZW5ndGgqMil9fWlmKCghdS5wb3NpdGlvbnN8fHUucG9zaXRpb25zLmxlbmd0aDxhKSYmKHUucG9zaXRpb25zPW5ldyBGbG9hdDMyQXJyYXkoYSkpLCghdS5jZWxsc3x8dS5jZWxscy5sZW5ndGg8YykmJih1LmNlbGxzPW5ldyBVaW50MTZBcnJheShjKSkseCYmKCF1LnRleHR1cmVDb29yZHx8dS50ZXh0dXJlQ29vcmQubGVuZ3RoPHgpJiYodS50ZXh0dXJlQ29vcmQ9bmV3IEZsb2F0MzJBcnJheSh4KSksKCF1LmFfY29sb3J8fHUuYV9jb2xvci5sZW5ndGg8cCkmJih1LmFfY29sb3I9bmV3IFVpbnQ4QXJyYXkocCkpLGYmJighdS5hX3NvdXJjZVJlY3R8fHUuYV9zb3VyY2VSZWN0Lmxlbmd0aDxmKSYmKHUuYV9zb3VyY2VSZWN0PW5ldyBGbG9hdDMyQXJyYXkoZikpLHYmJighdS5hX2NsaXBVVnx8dS5hX2NsaXBVVi5sZW5ndGg8dikmJih1LmFfY2xpcFVWPW5ldyBGbG9hdDMyQXJyYXkodikpLE0pe2NvbnN0IG09T2JqZWN0LmVudHJpZXMoTS5fYXR0cmlidXRlKSx5PU0uX2F0dHJpYk9wdHN8fHt9O2ZvcihsZXQgbj0wO248bS5sZW5ndGg7bisrKXtjb25zdFtvLHNdPW1bbl07aWYobyE9PSJhX2NvbG9yIiYmbyE9PSJhX3NvdXJjZVJlY3QiJiZzIT09Imlnbm9yZWQiKXtjb25zdCBsPXlbb10/eVtvXS50eXBlOiJGTE9BVCIsRT1yW2xdLFQ9cy5zaXplKkM7KCF1W29dfHx1W29dLmxlbmd0aDxUKSYmKHVbb109bmV3IEUoVCkpfX19cmV0dXJuIHV9ZnVuY3Rpb24gaChnLHUpe2xldCBhPVtdLGM9W10seD1bXSxmPVtdLHY9W10scD1bXSxDPTAsTT0wO2NvbnN0IG09Z1swXT9nWzBdLnVuaWZvcm1zfHx7fTp7fSx5PWdbMF0/Z1swXS5wcm9ncmFtOm51bGw7dSYmKGkoZyx1KSxjPXUuY2VsbHMsYT11LnBvc2l0aW9ucyx4PXUudGV4dHVyZUNvb3JkLGY9dS5hX2NvbG9yLHY9dS5hX3NvdXJjZVJlY3QscD11LmFfY2xpcFVWKTtsZXQgbj0hMSxvPSExO2NvbnN0IHM9e307Zm9yKGxldCBFPTA7RTxnLmxlbmd0aDtFKyspe2xldCBUPWdbRV07aWYoVCl7aWYoVC5tZXNoRGF0YSYmKFQ9VC5tZXNoRGF0YSksdSl7Y29uc3QgST1ULnBvc2l0aW9ucztmb3IobGV0IFA9MDtQPEkubGVuZ3RoO1ArKyl7Y29uc3QgTD1JW1BdLEQ9MyooQytQKTtmb3IobGV0IFI9MDtSPEwubGVuZ3RoO1IrKylhW0QrUl09TFtSXX19ZWxzZSBhLnB1c2goLi4uVC5wb3NpdGlvbnMpO2NvbnN0IGI9VC5jZWxscztmb3IobGV0IEk9MDtJPGIubGVuZ3RoO0krKyl7Y29uc3QgUD1iW0ldO2lmKHUpe2NvbnN0IEw9MyooTStJKTtjW0xdPVBbMF0rQyxjW0wrMV09UFsxXStDLGNbTCsyXT1QWzJdK0N9ZWxzZSBjLnB1c2goW1BbMF0rQyxQWzFdK0MsUFsyXStDXSl9aWYodSl7Y29uc3QgST1ULmF0dHJpYnV0ZXMuYV9jb2xvcjtmb3IobGV0IFA9MDtQPEkubGVuZ3RoO1ArKyl7Y29uc3QgTD1JW1BdLEQ9NCooQytQKTtmW0RdPUxbMF0sZltEKzFdPUxbMV0sZltEKzJdPUxbMl0sZltEKzNdPUxbM119fWVsc2UgZi5wdXNoKC4uLlQuYXR0cmlidXRlcy5hX2NvbG9yKTtpZihULmF0dHJpYnV0ZXMuYV9zb3VyY2VSZWN0KWlmKG49ITAsdSl7Y29uc3QgST1ULmF0dHJpYnV0ZXMuYV9zb3VyY2VSZWN0O2ZvcihsZXQgUD0wO1A8SS5sZW5ndGg7UCsrKXtjb25zdCBMPUlbUF0sRD00KihDK1ApO3ZbRF09TFswXSx2W0QrMV09TFsxXSx2W0QrMl09TFsyXSx2W0QrM109TFszXX19ZWxzZSB2LnB1c2goLi4uVC5hdHRyaWJ1dGVzLmFfc291cmNlUmVjdCk7aWYoVC5hdHRyaWJ1dGVzLmFfY2xpcFVWKWlmKG89ITAsdSl7Y29uc3QgST1ULmF0dHJpYnV0ZXMuYV9jbGlwVVY7Zm9yKGxldCBQPTA7UDxJLmxlbmd0aDtQKyspe2NvbnN0IEw9SVtQXSxEPTIqKEMrUCk7cFtEXT1MWzBdLHBbRCsxXT1MWzFdfX1lbHNlIHAucHVzaCguLi5ULmF0dHJpYnV0ZXMuYV9jbGlwVVYpO2lmKFQudGV4dHVyZUNvb3JkKWlmKHUpe2NvbnN0IEk9VC50ZXh0dXJlQ29vcmQ7Zm9yKGxldCBQPTA7UDxJLmxlbmd0aDtQKyspe2NvbnN0IEw9SVtQXSxEPTMqKEMrUCk7Zm9yKGxldCBSPTA7UjxMLmxlbmd0aDtSKyspeFtEK1JdPUxbUl19fWVsc2UgeC5wdXNoKC4uLlQudGV4dHVyZUNvb3JkKTtpZih5KXtjb25zdCBJPU9iamVjdC5lbnRyaWVzKHkuX2F0dHJpYnV0ZSk7Zm9yKGxldCBQPTA7UDxJLmxlbmd0aDtQKyspe2NvbnN0W0wsRF09SVtQXTtpZihMIT09ImFfY29sb3IiJiZMIT09ImFfc291cmNlUmVjdCImJkQhPT0iaWdub3JlZCIpaWYoc1tMXT1bXSx1KXtzW0xdPXVbTF07Y29uc3QgUj1ULmF0dHJpYnV0ZXNbTF0sQT1SWzBdLmxlbmd0aDtmb3IobGV0IGo9MDtqPFIubGVuZ3RoO2orKyl7Y29uc3QgRz1SW2pdLEg9QSooQytqKTtmb3IobGV0IFo9MDtaPEcubGVuZ3RoO1orKylzW0xdW0grWl09R1taXX19ZWxzZSBzW0xdLnB1c2goLi4uVC5hdHRyaWJ1dGVzW0xdKX19Qys9VC5wb3NpdGlvbnMubGVuZ3RoLE0rPVQuY2VsbHMubGVuZ3RofX1zLmFfY29sb3I9ZixuJiZ2JiZ2Lmxlbmd0aD4wJiYocy5hX3NvdXJjZVJlY3Q9dik7Y29uc3QgbD17cG9zaXRpb25zOmEsY2VsbHM6YyxhdHRyaWJ1dGVzOnMsdW5pZm9ybXM6bSxjZWxsc0NvdW50Ok0qMyxwcm9ncmFtOnl9O3JldHVybiB4JiZ4Lmxlbmd0aCYmKGwudGV4dHVyZUNvb3JkPXgpLG8mJnAubGVuZ3RoPjAmJihzLmFfY2xpcFVWPXApLGx9fSxmdW5jdGlvbihTLGUsdCl7dC5yKGUpO3ZhciByPXQoMSksaT10KDMwKSxoPXQoMjYpLGc9dCgzMSk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIHUocyxsKXt2YXIgRT1PYmplY3Qua2V5cyhzKTtpZihPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKXt2YXIgVD1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpO2wmJihUPVQuZmlsdGVyKGZ1bmN0aW9uKGIpe3JldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHMsYikuZW51bWVyYWJsZX0pKSxFLnB1c2guYXBwbHkoRSxUKX1yZXR1cm4gRX1mdW5jdGlvbiBhKHMpe2Zvcih2YXIgbD0xO2w8YXJndW1lbnRzLmxlbmd0aDtsKyspe3ZhciBFPWFyZ3VtZW50c1tsXSE9bnVsbD9hcmd1bWVudHNbbF06e307bCUyP3UoT2JqZWN0KEUpLCEwKS5mb3JFYWNoKGZ1bmN0aW9uKFQpe2MocyxULEVbVF0pfSk6T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnM/T2JqZWN0LmRlZmluZVByb3BlcnRpZXMocyxPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhFKSk6dShPYmplY3QoRSkpLmZvckVhY2goZnVuY3Rpb24oVCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KHMsVCxPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKEUsVCkpfSl9cmV0dXJuIHN9ZnVuY3Rpb24gYyhzLGwsRSl7cmV0dXJuIGwgaW4gcz9PYmplY3QuZGVmaW5lUHJvcGVydHkocyxsLHt2YWx1ZTpFLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6c1tsXT1FLHN9Y29uc3QgeD1TeW1ib2woIm1lc2giKSxmPVN5bWJvbCgiY291bnQiKSx2PVN5bWJvbCgiYmxlbmQiKSxwPVN5bWJvbCgiZmlsdGVyIiksQz1TeW1ib2woInRleHR1cmVzIiksTT1TeW1ib2woInRleHR1cmVPcHRpb25zIiksbT1TeW1ib2woImNsb3VkQ29sb3IiKSx5PVN5bWJvbCgiY2xvdWRGaWx0ZXIiKSxuPVN5bWJvbCgiYnVmZmVyIik7ZnVuY3Rpb24gbyhzLGw9bnVsbCl7Y29uc3QgRT1uZXcgRmxvYXQzMkFycmF5KDMqcyksVD1uZXcgRmxvYXQzMkFycmF5KDMqcyksYj1uZXcgRmxvYXQzMkFycmF5KDQqcyksST1uZXcgRmxvYXQzMkFycmF5KDQqcyksUD1uZXcgRmxvYXQzMkFycmF5KDQqcyksTD1uZXcgRmxvYXQzMkFycmF5KDQqcyksRD1uZXcgRmxvYXQzMkFycmF5KDQqcyksUj1uZXcgVWludDhBcnJheShzKSxBPW5ldyBVaW50OEFycmF5KDQqcyksaj1uZXcgVWludDhBcnJheSg0KnMpO3JldHVybiBsJiYoRS5zZXQobC50cmFuc2Zvcm0wLDApLFQuc2V0KGwudHJhbnNmb3JtMSwwKSxiLnNldChsLmNvbG9yMCwwKSxJLnNldChsLmNvbG9yMSwwKSxQLnNldChsLmNvbG9yMiwwKSxMLnNldChsLmNvbG9yMywwKSxELnNldChsLmNvbG9yNCwwKSxSLnNldChsLmZyYW1lSW5kZXgsMCksQS5zZXQobC5maWxsQ29sb3IsMCksai5zZXQobC5zdHJva2VDb2xvciwwKSkse2J1ZmZlclNpemU6cyx0cmFuc2Zvcm0wOkUsdHJhbnNmb3JtMTpULGNvbG9yMDpiLGNvbG9yMTpJLGNvbG9yMjpQLGNvbG9yMzpMLGNvbG9yNDpELGZyYW1lSW5kZXg6UixmaWxsQ29sb3I6QSxzdHJva2VDb2xvcjpqfX1lLmRlZmF1bHQ9Y2xhc3N7Y29uc3RydWN0b3IocyxsPTEse2J1ZmZlcjpFPTFlM309e30pe0U9TWF0aC5tYXgoRSxsKSx0aGlzW2ZdPWwsdGhpc1t4XT1zLHRoaXNbbl09byhFKSx0aGlzW0NdPVtdLHRoaXNbcF09W10sdGhpc1ttXT0hMSx0aGlzW3ldPSExLHRoaXNbdl09ITEsdGhpcy5pbml0QnVmZmVyKCl9aW5pdEJ1ZmZlcihzPTApe2NvbnN0IGw9dGhpc1tmXTtmb3IobGV0IEU9cztFPGw7RSsrKXRoaXNbbl0udHJhbnNmb3JtMC5zZXQoWzEsMCwwXSxFKjMpLHRoaXNbbl0udHJhbnNmb3JtMS5zZXQoWzAsMSwwXSxFKjMpLHRoaXNbbl0uZnJhbWVJbmRleC5zZXQoWy0xXSxFKSx0aGlzW25dLmZpbGxDb2xvci5zZXQoWzAsMCwwLDBdLEUqNCksdGhpc1tuXS5zdHJva2VDb2xvci5zZXQoWzAsMCwwLDBdLEUqNCksdGhpcy5zZXRDb2xvclRyYW5zZm9ybShFLG51bGwpfWdldCBidWZmZXJTaXplKCl7cmV0dXJuIHRoaXNbbl0uYnVmZmVyU2l6ZX1nZXQgbWVzaCgpe3JldHVybiB0aGlzW3hdfXNldCBtZXNoKHMpe3RoaXNbeF09cyx0aGlzW0NdJiZ0aGlzLnNldFRleHR1cmVGcmFtZXModGhpc1tDXSx0aGlzW01dKX1nZXQgaGFzQ2xvdWRDb2xvcigpe3JldHVybiB0aGlzW21dfWdldCBoYXNDbG91ZEZpbHRlcigpe3JldHVybiB0aGlzW3ldfV9nZXRGaWx0ZXIocyl7cmV0dXJuIHRoaXNbcF1bc109dGhpc1twXVtzXXx8W10sdGhpc1twXVtzXX1nZXRGaWx0ZXIocyl7cmV0dXJuIHRoaXMuX2dldEZpbHRlcihzKS5qb2luKCIgIil9Z2V0IGVuYWJsZUJsZW5kKCl7cmV0dXJuIHRoaXNbeF0uZW5hYmxlQmxlbmR8fHRoaXNbdl19Y2FuSWdub3JlKCl7cmV0dXJuIHRoaXNbeF0uY2FuSWdub3JlKCl9ZGVsZXRlKHMpe2lmKHM+PXRoaXNbZl18fHM8MCl0aHJvdyBuZXcgRXJyb3IoIk91dCBvZiByYW5nZS4iKTtjb25zdHt0cmFuc2Zvcm0wOmwsdHJhbnNmb3JtMTpFLGNvbG9yMDpULGNvbG9yMTpiLGNvbG9yMjpJLGNvbG9yMzpQLGNvbG9yNDpMLGZyYW1lSW5kZXg6RCxmaWxsQ29sb3I6UixzdHJva2VDb2xvcjpBfT10aGlzW25dO2wuc2V0KGwuc3ViYXJyYXkoMyoocysxKSksMypzKSxFLnNldChFLnN1YmFycmF5KDMqKHMrMSkpLDMqcyksVC5zZXQoVC5zdWJhcnJheSg0KihzKzEpKSw0KnMpLGIuc2V0KGIuc3ViYXJyYXkoNCoocysxKSksNCpzKSxJLnNldChJLnN1YmFycmF5KDQqKHMrMSkpLDQqcyksUC5zZXQoUC5zdWJhcnJheSg0KihzKzEpKSw0KnMpLEwuc2V0KEwuc3ViYXJyYXkoNCoocysxKSksNCpzKSxELnNldChELnN1YmFycmF5KHMrMSkscyksUi5zZXQoUi5zdWJhcnJheSg0KihzKzEpKSw0KnMpLEEuc2V0KEEuc3ViYXJyYXkoNCoocysxKSksNCpzKTtmb3IoY29uc3QgaiBpbiB0aGlzW3BdKWo9PT1zP2RlbGV0ZSB0aGlzW3BdW2pdOmo+cyYmKHRoaXNbcF1bai0xXT10aGlzW3BdW2pdLGRlbGV0ZSB0aGlzW3BdW2pdKTt0aGlzW2ZdLS19c2V0Q29sb3JUcmFuc2Zvcm0ocyxsKXtpZihzPj10aGlzW2ZdfHxzPDApdGhyb3cgbmV3IEVycm9yKCJPdXQgb2YgcmFuZ2UuIik7cyo9NDtjb25zdHtjb2xvcjA6RSxjb2xvcjE6VCxjb2xvcjI6Yixjb2xvcjM6SSxjb2xvcjQ6UH09dGhpc1tuXTtyZXR1cm4gbCE9bnVsbD8oRS5zZXQoW2xbMF0sbFs1XSxsWzEwXSxsWzE1XV0scyksVC5zZXQoW2xbMV0sbFs2XSxsWzExXSxsWzE2XV0scyksYi5zZXQoW2xbMl0sbFs3XSxsWzEyXSxsWzE3XV0scyksSS5zZXQoW2xbM10sbFs4XSxsWzEzXSxsWzE4XV0scyksUC5zZXQoW2xbNF0sbFs5XSxsWzE0XSxsWzE5XV0scyksdGhpc1t2XT10aGlzW3ZdfHxsWzE4XTwxLHRoaXNbeV09ITApOihFLnNldChbMSwwLDAsMF0scyksVC5zZXQoWzAsMSwwLDBdLHMpLGIuc2V0KFswLDAsMSwwXSxzKSxJLnNldChbMCwwLDAsMV0scyksUC5zZXQoWzAsMCwwLDBdLHMpKSx0aGlzfWdldENvbG9yVHJhbnNmb3JtKHMpe2lmKHM+PXRoaXNbZl18fHM8MCl0aHJvdyBuZXcgRXJyb3IoIk91dCBvZiByYW5nZS4iKTtzKj00O2NvbnN0e2NvbG9yMDpsLGNvbG9yMTpFLGNvbG9yMjpULGNvbG9yMzpiLGNvbG9yNDpJfT10aGlzW25dO3JldHVybltsW3NdLEVbc10sVFtzXSxiW3NdLElbc10sbFtzKzFdLEVbcysxXSxUW3MrMV0sYltzKzFdLElbcysxXSxsW3MrMl0sRVtzKzJdLFRbcysyXSxiW3MrMl0sSVtzKzJdLGxbcyszXSxFW3MrM10sVFtzKzNdLGJbcyszXSxJW3MrM11dfXRyYW5zZm9ybUNvbG9yKHMsbCl7bGV0IEU9dGhpcy5nZXRDb2xvclRyYW5zZm9ybShzKTtyZXR1cm4gRT1PYmplY3QoaS5tdWx0aXBseSkoRSxsKSx0aGlzLnNldENvbG9yVHJhbnNmb3JtKHMsRSksdGhpc31zZXRGaWxsQ29sb3IocyxsKXtpZihzPj10aGlzW2ZdfHxzPDApdGhyb3cgbmV3IEVycm9yKCJPdXQgb2YgcmFuZ2UuIik7dHlwZW9mIGw9PSJzdHJpbmciJiYobD1PYmplY3QoZy5kZWZhdWx0KShsKSksbFszXT4wJiYodGhpc1ttXT0hMCksdGhpc1tuXS5maWxsQ29sb3Iuc2V0KGwubWFwKEU9Pk1hdGgucm91bmQoMjU1KkUpKSw0KnMpfXNldFN0cm9rZUNvbG9yKHMsbCl7aWYocz49dGhpc1tmXXx8czwwKXRocm93IG5ldyBFcnJvcigiT3V0IG9mIHJhbmdlLiIpO3R5cGVvZiBsPT0ic3RyaW5nIiYmKGw9T2JqZWN0KGcuZGVmYXVsdCkobCkpLGxbM10+MCYmKHRoaXNbbV09ITApLHRoaXNbbl0uc3Ryb2tlQ29sb3Iuc2V0KGwubWFwKEU9Pk1hdGgucm91bmQoMjU1KkUpKSw0KnMpfWdldENsb3VkUkdCQShzKXtpZihzPj10aGlzW2ZdfHxzPDApdGhyb3cgbmV3IEVycm9yKCJPdXQgb2YgcmFuZ2UuIik7cyo9NDtjb25zdHtmaWxsQ29sb3I6bCxzdHJva2VDb2xvcjpFfT10aGlzW25dLFQ9W2xbc10sbFtzKzFdLGxbcysyXSxsW3MrM11dLGI9W0Vbc10sRVtzKzFdLEVbcysyXSxFW3MrM11dO3JldHVybiBUWzNdLz0yNTUsYlszXS89MjU1LHtmaWxsOmByZ2JhKCR7VC5qb2luKCl9KWAsc3Ryb2tlOmByZ2JhKCR7Yi5qb2luKCl9KWB9fWdyYXlzY2FsZShzLGwpe3RoaXMudHJhbnNmb3JtQ29sb3IocyxPYmplY3QoaS5ncmF5c2NhbGUpKGwpKSx0aGlzLl9nZXRGaWx0ZXIocykucHVzaChgZ3JheXNjYWxlKCR7MTAwKmx9JSlgKX1icmlnaHRuZXNzKHMsbCl7dGhpcy50cmFuc2Zvcm1Db2xvcihzLE9iamVjdChpLmJyaWdodG5lc3MpKGwpKSx0aGlzLl9nZXRGaWx0ZXIocykucHVzaChgYnJpZ2h0bmVzcygkezEwMCpsfSUpYCl9c2F0dXJhdGUocyxsKXt0aGlzLnRyYW5zZm9ybUNvbG9yKHMsT2JqZWN0KGkuc2F0dXJhdGUpKGwpKSx0aGlzLl9nZXRGaWx0ZXIocykucHVzaChgc2F0dXJhdGUoJHsxMDAqbH0lKWApfWNvbnRyYXN0KHMsbCl7dGhpcy50cmFuc2Zvcm1Db2xvcihzLE9iamVjdChpLmNvbnRyYXN0KShsKSksdGhpcy5fZ2V0RmlsdGVyKHMpLnB1c2goYGNvbnRyYXN0KCR7MTAwKmx9JSlgKX1pbnZlcnQocyxsKXt0aGlzLnRyYW5zZm9ybUNvbG9yKHMsT2JqZWN0KGkuaW52ZXJ0KShsKSksdGhpcy5fZ2V0RmlsdGVyKHMpLnB1c2goYGludmVydCgkezEwMCpsfSUpYCl9c2VwaWEocyxsKXt0aGlzLnRyYW5zZm9ybUNvbG9yKHMsT2JqZWN0KGkuc2VwaWEpKGwpKSx0aGlzLl9nZXRGaWx0ZXIocykucHVzaChgc2VwaWEoJHsxMDAqbH0lKWApfW9wYWNpdHkocyxsKXt0aGlzLnRyYW5zZm9ybUNvbG9yKHMsT2JqZWN0KGkub3BhY2l0eSkobCkpLHRoaXMuX2dldEZpbHRlcihzKS5wdXNoKGBvcGFjaXR5KCR7MTAwKmx9JSlgKX1odWVSb3RhdGUocyxsKXt0aGlzLnRyYW5zZm9ybUNvbG9yKHMsT2JqZWN0KGkuaHVlUm90YXRlKShsKSksdGhpcy5fZ2V0RmlsdGVyKHMpLnB1c2goYGh1ZS1yb3RhdGUoJHtsfWRlZylgKX1zZXRUcmFuc2Zvcm0ocyxsKXtpZihzPj10aGlzW2ZdfHxzPDApdGhyb3cgbmV3IEVycm9yKCJPdXQgb2YgcmFuZ2UuIik7cyo9MyxsPT1udWxsJiYobD1bMSwwLDAsMSwwLDBdKTtjb25zdHt0cmFuc2Zvcm0wOkUsdHJhbnNmb3JtMTpUfT10aGlzW25dO3JldHVybiBFLnNldChbbFswXSxsWzJdLGxbNF1dLHMpLFQuc2V0KFtsWzFdLGxbM10sbFs1XV0scyksdGhpc31nZXRUcmFuc2Zvcm0ocyl7aWYocz49dGhpc1tmXXx8czwwKXRocm93IG5ldyBFcnJvcigiT3V0IG9mIHJhbmdlLiIpO3MqPTM7Y29uc3R7dHJhbnNmb3JtMDpsLHRyYW5zZm9ybTE6RX09dGhpc1tuXTtyZXR1cm5bbFtzXSxFW3NdLGxbcysxXSxFW3MrMV0sbFtzKzJdLEVbcysyXV19Z2V0VGV4dHVyZUZyYW1lKHMpe3JldHVybiB0aGlzW0NdW3RoaXNbbl0uZnJhbWVJbmRleFtzXV19c2V0VGV4dHVyZUZyYW1lcyhzPVtdLGw9e30pe2lmKHMubGVuZ3RoPjEyKXRocm93IG5ldyBFcnJvcigiTWF4IGZyYW1lcyBleGNlZWQuIEFsbG93IDEyIGZyYW1lcy4iKTtzLmxlbmd0aCYmdGhpc1t4XS5zZXRUZXh0dXJlKHNbMF0sbCksdGhpc1tDXT1zLHRoaXNbTV09bH1zZXRGcmFtZUluZGV4KHMsbCl7aWYocz49dGhpc1tmXXx8czwwKXRocm93IG5ldyBFcnJvcigiT3V0IG9mIHJhbmdlLiIpO2NvbnN0IEU9dGhpc1tDXS5sZW5ndGg7aWYoRTw9MCl0aHJvdyBuZXcgRXJyb3IoIk5vIGZyYW1lcyIpO3RoaXNbbl0uZnJhbWVJbmRleFtzXT1sJUV9Z2V0IGFtb3VudCgpe3JldHVybiB0aGlzW2ZdfXNldCBhbW91bnQocyl7Y29uc3QgbD10aGlzW2ZdO3MhPT1sJiYocz50aGlzW25dLmJ1ZmZlclNpemUmJih0aGlzW25dPW8oTWF0aC5tYXgocyx0aGlzW25dLmJ1ZmZlclNpemUrMWUzKSx0aGlzW25dKSksdGhpc1tmXT1zLHM+bCYmdGhpcy5pbml0QnVmZmVyKGwpKX1nZXQgbWVzaERhdGEoKXtjb25zdHthdHRyaWJ1dGVzOnMsY2VsbHM6bCxwb3NpdGlvbnM6RSx0ZXh0dXJlQ29vcmQ6VCx1bmlmb3JtczpifT10aGlzW3hdLm1lc2hEYXRhLEk9dGhpc1tDXSxQPXthdHRyaWJ1dGVzOmEoe30scyksY2VsbHM6bCxwb3NpdGlvbnM6RSx0ZXh0dXJlQ29vcmQ6VCx1bmlmb3JtczphKHt9LGIpLGluc3RhbmNlQ291bnQ6dGhpc1tmXSxlbmFibGVCbGVuZDp0aGlzLmVuYWJsZUJsZW5kfTtJLmxlbmd0aCYmSS5mb3JFYWNoKCgkLEopPT57UC51bmlmb3Jtc1tgdV90ZXhGcmFtZSR7Sn1gXT0kfSk7Y29uc3R7dHJhbnNmb3JtMDpMLHRyYW5zZm9ybTE6RCxjb2xvcjA6Uixjb2xvcjE6QSxjb2xvcjI6aixjb2xvcjM6Ryxjb2xvcjQ6SCxmaWxsQ29sb3I6WixzdHJva2VDb2xvcjpxLGZyYW1lSW5kZXg6Rn09dGhpc1tuXTtyZXR1cm4gdGhpc1t4XS51bmlmb3Jtcy51X3RleFNhbXBsZXImJihQLmF0dHJpYnV0ZXMuYV9mcmFtZUluZGV4PXtkYXRhOkYsZGl2aXNvcjoxfSksUC5hdHRyaWJ1dGVzLmFfdHJhbnNmb3JtMD17ZGF0YTpMLGRpdmlzb3I6MX0sUC5hdHRyaWJ1dGVzLmFfdHJhbnNmb3JtMT17ZGF0YTpELGRpdmlzb3I6MX0sUC5hdHRyaWJ1dGVzLmFfY29sb3JDbG91ZDA9e2RhdGE6UixkaXZpc29yOjF9LFAuYXR0cmlidXRlcy5hX2NvbG9yQ2xvdWQxPXtkYXRhOkEsZGl2aXNvcjoxfSxQLmF0dHJpYnV0ZXMuYV9jb2xvckNsb3VkMj17ZGF0YTpqLGRpdmlzb3I6MX0sUC5hdHRyaWJ1dGVzLmFfY29sb3JDbG91ZDM9e2RhdGE6RyxkaXZpc29yOjF9LFAuYXR0cmlidXRlcy5hX2NvbG9yQ2xvdWQ0PXtkYXRhOkgsZGl2aXNvcjoxfSx0aGlzLmhhc0Nsb3VkQ29sb3ImJihQLmF0dHJpYnV0ZXMuYV9maWxsQ2xvdWRDb2xvcj17ZGF0YTpaLGRpdmlzb3I6MX0sUC5hdHRyaWJ1dGVzLmFfc3Ryb2tlQ2xvdWRDb2xvcj17ZGF0YTpxLGRpdmlzb3I6MX0pLFB9c2V0UHJvZ3JhbShzKXt0aGlzW3hdLnNldFByb2dyYW0ocyl9Z2V0IHByb2dyYW0oKXtyZXR1cm4gdGhpc1t4XS5wcm9ncmFtfXRyYW5zZm9ybShzLGwpe2NvbnN0IEU9dGhpcy5nZXRUcmFuc2Zvcm0ocyk7cmV0dXJuIGw9ci5tYXQyZC5tdWx0aXBseShBcnJheS5vZigwLDAsMCwwLDAsMCksRSxsKSx0aGlzLnNldFRyYW5zZm9ybShzLGwpLHRoaXN9dHJhbnNsYXRlKHMsW2wsRV0pe2xldCBUPXIubWF0MmQuY3JlYXRlKCk7cmV0dXJuIFQ9ci5tYXQyZC50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDApLFQsW2wsRV0pLHRoaXMudHJhbnNmb3JtKHMsVCl9cm90YXRlKHMsbCxbRSxUXT1bMCwwXSl7bGV0IGI9ci5tYXQyZC5jcmVhdGUoKTtyZXR1cm4gYj1yLm1hdDJkLnRyYW5zbGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCksYixbRSxUXSksYj1yLm1hdDJkLnJvdGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCksYixsKSxiPXIubWF0MmQudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxiLFstRSwtVF0pLHRoaXMudHJhbnNmb3JtKHMsYil9c2NhbGUocyxbbCxFPWxdLFtULGJdPVswLDBdKXtsZXQgST1yLm1hdDJkLmNyZWF0ZSgpO3JldHVybiBJPXIubWF0MmQudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxJLFtULGJdKSxJPXIubWF0MmQuc2NhbGUoQXJyYXkub2YoMCwwLDAsMCwwLDApLEksW2wsRV0pLEk9ci5tYXQyZC50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDApLEksWy1ULC1iXSksdGhpcy50cmFuc2Zvcm0ocyxJKX1za2V3KHMsW2wsRT1sXSxbVCxiXT1bMCwwXSl7bGV0IEk9ci5tYXQyZC5jcmVhdGUoKTtyZXR1cm4gST1yLm1hdDJkLnRyYW5zbGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCksSSxbVCxiXSksST1yLm1hdDJkLm11bHRpcGx5KEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxJLHIubWF0MmQuZnJvbVZhbHVlcygxLE1hdGgudGFuKEUpLE1hdGgudGFuKGwpLDEsMCwwKSksST1yLm1hdDJkLnRyYW5zbGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCksSSxbLVQsLWJdKSx0aGlzLnRyYW5zZm9ybShzLEkpfWlzUG9pbnRDb2xsaXNpb24ocyxbbCxFXSxUPSJib3RoIil7Y29uc3QgYj10aGlzLmdldFRyYW5zZm9ybShzKSxJPU9iamVjdChoLnRyYW5zZm9ybVBvaW50KShbbCxFXSxyLm1hdDJkLmludmVydChBcnJheS5vZigwLDAsMCwwLDAsMCksYikpO3JldHVybiB0aGlzW3hdLmlzUG9pbnRDb2xsaXNpb24oLi4uSSxUKX1pc1BvaW50SW5GaWxsKHMsW2wsRV0pe3JldHVybiB0aGlzLmlzUG9pbnRDb2xsaXNpb24ocyxbbCxFXSwiZmlsbCIpfWlzUG9pbnRJblN0cm9rZShzLFtsLEVdKXtyZXR1cm4gdGhpcy5pc1BvaW50Q29sbGlzaW9uKHMsW2wsRV0sInN0cm9rZSIpfX19LGZ1bmN0aW9uKFMsZSx0KXt0LnIoZSksdC5kKGUsIm11bHRpcGx5IixmdW5jdGlvbigpe3JldHVybiBpfSksdC5kKGUsImdyYXlzY2FsZSIsZnVuY3Rpb24oKXtyZXR1cm4gaH0pLHQuZChlLCJicmlnaHRuZXNzIixmdW5jdGlvbigpe3JldHVybiBnfSksdC5kKGUsInNhdHVyYXRlIixmdW5jdGlvbigpe3JldHVybiB1fSksdC5kKGUsImNvbnRyYXN0IixmdW5jdGlvbigpe3JldHVybiBhfSksdC5kKGUsImludmVydCIsZnVuY3Rpb24oKXtyZXR1cm4gY30pLHQuZChlLCJzZXBpYSIsZnVuY3Rpb24oKXtyZXR1cm4geH0pLHQuZChlLCJvcGFjaXR5IixmdW5jdGlvbigpe3JldHVybiBmfSksdC5kKGUsImh1ZVJvdGF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gdn0pO3ZhciByPXQoMjYpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBpKHAsQyl7Y29uc3QgTT1bXSxtPXBbMF0seT1wWzFdLG49cFsyXSxvPXBbM10scz1wWzRdLGw9cFs1XSxFPXBbNl0sVD1wWzddLGI9cFs4XSxJPXBbOV0sUD1wWzEwXSxMPXBbMTFdLEQ9cFsxMl0sUj1wWzEzXSxBPXBbMTRdLGo9cFsxNV0sRz1wWzE2XSxIPXBbMTddLFo9cFsxOF0scT1wWzE5XTtsZXQgRj1DWzBdLCQ9Q1sxXSxKPUNbMl0sdHQ9Q1szXSxfPUNbNF07cmV0dXJuIE1bMF09RiptKyQqbCtKKlArdHQqaixNWzFdPUYqeSskKkUrSipMK3R0KkcsTVsyXT1GKm4rJCpUK0oqRCt0dCpILE1bM109RipvKyQqYitKKlIrdHQqWixNWzRdPUYqcyskKkkrSipBK3R0KnErXyxGPUNbNV0sJD1DWzZdLEo9Q1s3XSx0dD1DWzhdLF89Q1s5XSxNWzVdPUYqbSskKmwrSipQK3R0KmosTVs2XT1GKnkrJCpFK0oqTCt0dCpHLE1bN109RipuKyQqVCtKKkQrdHQqSCxNWzhdPUYqbyskKmIrSipSK3R0KlosTVs5XT1GKnMrJCpJK0oqQSt0dCpxK18sRj1DWzEwXSwkPUNbMTFdLEo9Q1sxMl0sdHQ9Q1sxM10sXz1DWzE0XSxNWzEwXT1GKm0rJCpsK0oqUCt0dCpqLE1bMTFdPUYqeSskKkUrSipMK3R0KkcsTVsxMl09RipuKyQqVCtKKkQrdHQqSCxNWzEzXT1GKm8rJCpiK0oqUit0dCpaLE1bMTRdPUYqcyskKkkrSipBK3R0KnErXyxGPUNbMTVdLCQ9Q1sxNl0sSj1DWzE3XSx0dD1DWzE4XSxfPUNbMTldLE1bMTVdPUYqbSskKmwrSipQK3R0KmosTVsxNl09Rip5KyQqRStKKkwrdHQqRyxNWzE3XT1GKm4rJCpUK0oqRCt0dCpILE1bMThdPUYqbyskKmIrSipSK3R0KlosTVsxOV09RipzKyQqSStKKkErdHQqcStfLE19ZnVuY3Rpb24gaChwKXtwPU9iamVjdChyLmNsYW1wKSgwLDEscCk7Y29uc3QgQz0uMjEyNipwLE09LjcxNTIqcCxtPS4wNzIyKnA7cmV0dXJuW0MrMS1wLE0sbSwwLDAsQyxNKzEtcCxtLDAsMCxDLE0sbSsxLXAsMCwwLDAsMCwwLDEsMF19ZnVuY3Rpb24gZyhwKXtyZXR1cm5bcCwwLDAsMCwwLDAscCwwLDAsMCwwLDAscCwwLDAsMCwwLDAsMSwwXX1mdW5jdGlvbiB1KHApe2NvbnN0IEM9LjIxMjYqKDEtcCksTT0uNzE1MiooMS1wKSxtPS4wNzIyKigxLXApO3JldHVybltDK3AsTSxtLDAsMCxDLE0rcCxtLDAsMCxDLE0sbStwLDAsMCwwLDAsMCwxLDBdfWZ1bmN0aW9uIGEocCl7Y29uc3QgQz0uNSooMS1wKTtyZXR1cm5bcCwwLDAsMCxDLDAscCwwLDAsQywwLDAscCwwLEMsMCwwLDAsMSwwXX1mdW5jdGlvbiBjKHApe2NvbnN0IEM9MS0yKnA7cmV0dXJuW0MsMCwwLDAscCwwLEMsMCwwLHAsMCwwLEMsMCxwLDAsMCwwLDEsMF19ZnVuY3Rpb24geChwKXtyZXR1cm5bMS0uNjA3KnAsLjc2OSpwLC4xODkqcCwwLDAsLjM0OSpwLDEtLjMxNCpwLC4xNjgqcCwwLDAsLjI3MipwLC41MzQqcCwxLS44NjkqcCwwLDAsMCwwLDAsMSwwXX1mdW5jdGlvbiBmKHApe3JldHVyblsxLDAsMCwwLDAsMCwxLDAsMCwwLDAsMCwxLDAsMCwwLDAsMCxwLDBdfWZ1bmN0aW9uIHYocCl7Y29uc3QgQz1wLzE4MCpNYXRoLlBJLE09TWF0aC5jb3MoQyksbT1NYXRoLnNpbihDKSx5PS4yMTI2LG49LjcxNTIsbz0uMDcyMjtyZXR1cm5beStNKigxLXkpK20qLXksbitNKi1uK20qLW4sbytNKi1vK20qKDEtbyksMCwwLHkrTSoteSttKi4xNDMsbitNKigxLW4pK20qLjE0LG8rTSotbyttKi0uMjgzLDAsMCx5K00qLXkrbSotKDEteSksbitNKi1uK20qbixvK00qKDEtbykrbSpvLDAsMCwwLDAsMCwxLDBdfX0sZnVuY3Rpb24oUyxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gaH0pO3ZhciByPXQoMzIpLGk9dC5uKHIpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBoKGcpe2NvbnN0IHU9aSgpKGcpO2lmKCF1fHwhdS5sZW5ndGgpdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCBjb2xvciB2YWx1ZS4iKTtyZXR1cm5bdVswXS8yNTUsdVsxXS8yNTUsdVsyXS8yNTUsdVszXV19fSxmdW5jdGlvbihTLGUsdCl7dmFyIHI9dCgzMyksaT10KDM3KSxoPXQoMzkpO1MuZXhwb3J0cz1mdW5jdGlvbih1KXt2YXIgYSxjPXIodSk7cmV0dXJuIGMuc3BhY2U/KGE9QXJyYXkoMyksYVswXT1oKGMudmFsdWVzWzBdLDAsMjU1KSxhWzFdPWgoYy52YWx1ZXNbMV0sMCwyNTUpLGFbMl09aChjLnZhbHVlc1syXSwwLDI1NSksYy5zcGFjZVswXT09PSJoIiYmKGE9aS5yZ2IoYSkpLGEucHVzaChoKGMuYWxwaGEsMCwxKSksYSk6W119fSxmdW5jdGlvbihTLGUsdCl7KGZ1bmN0aW9uKHIpe3ZhciBpPXQoMzQpLGg9dCgzNSksZz10KDM2KTtTLmV4cG9ydHM9YTt2YXIgdT17cmVkOjAsb3JhbmdlOjYwLHllbGxvdzoxMjAsZ3JlZW46MTgwLGJsdWU6MjQwLHB1cnBsZTozMDB9O2Z1bmN0aW9uIGEoYyl7dmFyIHgsZj1bXSx2PTEscDtpZih0eXBlb2YgYz09InN0cmluZyIpaWYoaVtjXSlmPWlbY10uc2xpY2UoKSxwPSJyZ2IiO2Vsc2UgaWYoYz09PSJ0cmFuc3BhcmVudCIpdj0wLHA9InJnYiIsZj1bMCwwLDBdO2Vsc2UgaWYoL14jW0EtRmEtZjAtOV0rJC8udGVzdChjKSl7dmFyIEM9Yy5zbGljZSgxKSxNPUMubGVuZ3RoLG09TTw9NDt2PTEsbT8oZj1bcGFyc2VJbnQoQ1swXStDWzBdLDE2KSxwYXJzZUludChDWzFdK0NbMV0sMTYpLHBhcnNlSW50KENbMl0rQ1syXSwxNildLE09PT00JiYodj1wYXJzZUludChDWzNdK0NbM10sMTYpLzI1NSkpOihmPVtwYXJzZUludChDWzBdK0NbMV0sMTYpLHBhcnNlSW50KENbMl0rQ1szXSwxNikscGFyc2VJbnQoQ1s0XStDWzVdLDE2KV0sTT09PTgmJih2PXBhcnNlSW50KENbNl0rQ1s3XSwxNikvMjU1KSksZlswXXx8KGZbMF09MCksZlsxXXx8KGZbMV09MCksZlsyXXx8KGZbMl09MCkscD0icmdiIn1lbHNlIGlmKHg9L14oKD86cmdifGhzW2x2Yl18aHdifGNteWs/fHh5W3p5XXxncmF5fGxhYnxsY2h1P3Y/fFtseV11dnxsbXMpYT8pXHMqXCgoW15cKV0qKVwpLy5leGVjKGMpKXt2YXIgeT14WzFdLG49eT09PSJyZ2IiLEM9eS5yZXBsYWNlKC9hJC8sIiIpO3A9Qzt2YXIgTT1DPT09ImNteWsiPzQ6Qz09PSJncmF5Ij8xOjM7Zj14WzJdLnRyaW0oKS5zcGxpdCgvXHMqLFxzKi8pLm1hcChmdW5jdGlvbihFLFQpe2lmKC8lJC8udGVzdChFKSlyZXR1cm4gVD09PU0/cGFyc2VGbG9hdChFKS8xMDA6Qz09PSJyZ2IiP3BhcnNlRmxvYXQoRSkqMjU1LzEwMDpwYXJzZUZsb2F0KEUpO2lmKENbVF09PT0iaCIpe2lmKC9kZWckLy50ZXN0KEUpKXJldHVybiBwYXJzZUZsb2F0KEUpO2lmKHVbRV0hPT12b2lkIDApcmV0dXJuIHVbRV19cmV0dXJuIHBhcnNlRmxvYXQoRSl9KSx5PT09QyYmZi5wdXNoKDEpLHY9bnx8ZltNXT09PXZvaWQgMD8xOmZbTV0sZj1mLnNsaWNlKDAsTSl9ZWxzZSBjLmxlbmd0aD4xMCYmL1swLTldKD86XHN8XC8pLy50ZXN0KGMpJiYoZj1jLm1hdGNoKC8oWzAtOV0rKS9nKS5tYXAoZnVuY3Rpb24ocyl7cmV0dXJuIHBhcnNlRmxvYXQocyl9KSxwPWMubWF0Y2goLyhbYS16XSkvaWcpLmpvaW4oIiIpLnRvTG93ZXJDYXNlKCkpO2Vsc2UgaWYoIWlzTmFOKGMpKXA9InJnYiIsZj1bYz4+PjE2LChjJjY1MjgwKT4+PjgsYyYyNTVdO2Vsc2UgaWYoaChjKSl7dmFyIG89ZyhjLnIsYy5yZWQsYy5SLG51bGwpO28hPT1udWxsPyhwPSJyZ2IiLGY9W28sZyhjLmcsYy5ncmVlbixjLkcpLGcoYy5iLGMuYmx1ZSxjLkIpXSk6KHA9ImhzbCIsZj1bZyhjLmgsYy5odWUsYy5IKSxnKGMucyxjLnNhdHVyYXRpb24sYy5TKSxnKGMubCxjLmxpZ2h0bmVzcyxjLkwsYy5iLGMuYnJpZ2h0bmVzcyldKSx2PWcoYy5hLGMuYWxwaGEsYy5vcGFjaXR5LDEpLGMub3BhY2l0eSE9bnVsbCYmKHYvPTEwMCl9ZWxzZShBcnJheS5pc0FycmF5KGMpfHxyLkFycmF5QnVmZmVyJiZBcnJheUJ1ZmZlci5pc1ZpZXcmJkFycmF5QnVmZmVyLmlzVmlldyhjKSkmJihmPVtjWzBdLGNbMV0sY1syXV0scD0icmdiIix2PWMubGVuZ3RoPT09ND9jWzNdOjEpO3JldHVybntzcGFjZTpwLHZhbHVlczpmLGFscGhhOnZ9fX0pLmNhbGwodGhpcyx0KDIyKSl9LGZ1bmN0aW9uKFMsZSx0KXtTLmV4cG9ydHM9e2FsaWNlYmx1ZTpbMjQwLDI0OCwyNTVdLGFudGlxdWV3aGl0ZTpbMjUwLDIzNSwyMTVdLGFxdWE6WzAsMjU1LDI1NV0sYXF1YW1hcmluZTpbMTI3LDI1NSwyMTJdLGF6dXJlOlsyNDAsMjU1LDI1NV0sYmVpZ2U6WzI0NSwyNDUsMjIwXSxiaXNxdWU6WzI1NSwyMjgsMTk2XSxibGFjazpbMCwwLDBdLGJsYW5jaGVkYWxtb25kOlsyNTUsMjM1LDIwNV0sYmx1ZTpbMCwwLDI1NV0sYmx1ZXZpb2xldDpbMTM4LDQzLDIyNl0sYnJvd246WzE2NSw0Miw0Ml0sYnVybHl3b29kOlsyMjIsMTg0LDEzNV0sY2FkZXRibHVlOls5NSwxNTgsMTYwXSxjaGFydHJldXNlOlsxMjcsMjU1LDBdLGNob2NvbGF0ZTpbMjEwLDEwNSwzMF0sY29yYWw6WzI1NSwxMjcsODBdLGNvcm5mbG93ZXJibHVlOlsxMDAsMTQ5LDIzN10sY29ybnNpbGs6WzI1NSwyNDgsMjIwXSxjcmltc29uOlsyMjAsMjAsNjBdLGN5YW46WzAsMjU1LDI1NV0sZGFya2JsdWU6WzAsMCwxMzldLGRhcmtjeWFuOlswLDEzOSwxMzldLGRhcmtnb2xkZW5yb2Q6WzE4NCwxMzQsMTFdLGRhcmtncmF5OlsxNjksMTY5LDE2OV0sZGFya2dyZWVuOlswLDEwMCwwXSxkYXJrZ3JleTpbMTY5LDE2OSwxNjldLGRhcmtraGFraTpbMTg5LDE4MywxMDddLGRhcmttYWdlbnRhOlsxMzksMCwxMzldLGRhcmtvbGl2ZWdyZWVuOls4NSwxMDcsNDddLGRhcmtvcmFuZ2U6WzI1NSwxNDAsMF0sZGFya29yY2hpZDpbMTUzLDUwLDIwNF0sZGFya3JlZDpbMTM5LDAsMF0sZGFya3NhbG1vbjpbMjMzLDE1MCwxMjJdLGRhcmtzZWFncmVlbjpbMTQzLDE4OCwxNDNdLGRhcmtzbGF0ZWJsdWU6WzcyLDYxLDEzOV0sZGFya3NsYXRlZ3JheTpbNDcsNzksNzldLGRhcmtzbGF0ZWdyZXk6WzQ3LDc5LDc5XSxkYXJrdHVycXVvaXNlOlswLDIwNiwyMDldLGRhcmt2aW9sZXQ6WzE0OCwwLDIxMV0sZGVlcHBpbms6WzI1NSwyMCwxNDddLGRlZXBza3libHVlOlswLDE5MSwyNTVdLGRpbWdyYXk6WzEwNSwxMDUsMTA1XSxkaW1ncmV5OlsxMDUsMTA1LDEwNV0sZG9kZ2VyYmx1ZTpbMzAsMTQ0LDI1NV0sZmlyZWJyaWNrOlsxNzgsMzQsMzRdLGZsb3JhbHdoaXRlOlsyNTUsMjUwLDI0MF0sZm9yZXN0Z3JlZW46WzM0LDEzOSwzNF0sZnVjaHNpYTpbMjU1LDAsMjU1XSxnYWluc2Jvcm86WzIyMCwyMjAsMjIwXSxnaG9zdHdoaXRlOlsyNDgsMjQ4LDI1NV0sZ29sZDpbMjU1LDIxNSwwXSxnb2xkZW5yb2Q6WzIxOCwxNjUsMzJdLGdyYXk6WzEyOCwxMjgsMTI4XSxncmVlbjpbMCwxMjgsMF0sZ3JlZW55ZWxsb3c6WzE3MywyNTUsNDddLGdyZXk6WzEyOCwxMjgsMTI4XSxob25leWRldzpbMjQwLDI1NSwyNDBdLGhvdHBpbms6WzI1NSwxMDUsMTgwXSxpbmRpYW5yZWQ6WzIwNSw5Miw5Ml0saW5kaWdvOls3NSwwLDEzMF0saXZvcnk6WzI1NSwyNTUsMjQwXSxraGFraTpbMjQwLDIzMCwxNDBdLGxhdmVuZGVyOlsyMzAsMjMwLDI1MF0sbGF2ZW5kZXJibHVzaDpbMjU1LDI0MCwyNDVdLGxhd25ncmVlbjpbMTI0LDI1MiwwXSxsZW1vbmNoaWZmb246WzI1NSwyNTAsMjA1XSxsaWdodGJsdWU6WzE3MywyMTYsMjMwXSxsaWdodGNvcmFsOlsyNDAsMTI4LDEyOF0sbGlnaHRjeWFuOlsyMjQsMjU1LDI1NV0sbGlnaHRnb2xkZW5yb2R5ZWxsb3c6WzI1MCwyNTAsMjEwXSxsaWdodGdyYXk6WzIxMSwyMTEsMjExXSxsaWdodGdyZWVuOlsxNDQsMjM4LDE0NF0sbGlnaHRncmV5OlsyMTEsMjExLDIxMV0sbGlnaHRwaW5rOlsyNTUsMTgyLDE5M10sbGlnaHRzYWxtb246WzI1NSwxNjAsMTIyXSxsaWdodHNlYWdyZWVuOlszMiwxNzgsMTcwXSxsaWdodHNreWJsdWU6WzEzNSwyMDYsMjUwXSxsaWdodHNsYXRlZ3JheTpbMTE5LDEzNiwxNTNdLGxpZ2h0c2xhdGVncmV5OlsxMTksMTM2LDE1M10sbGlnaHRzdGVlbGJsdWU6WzE3NiwxOTYsMjIyXSxsaWdodHllbGxvdzpbMjU1LDI1NSwyMjRdLGxpbWU6WzAsMjU1LDBdLGxpbWVncmVlbjpbNTAsMjA1LDUwXSxsaW5lbjpbMjUwLDI0MCwyMzBdLG1hZ2VudGE6WzI1NSwwLDI1NV0sbWFyb29uOlsxMjgsMCwwXSxtZWRpdW1hcXVhbWFyaW5lOlsxMDIsMjA1LDE3MF0sbWVkaXVtYmx1ZTpbMCwwLDIwNV0sbWVkaXVtb3JjaGlkOlsxODYsODUsMjExXSxtZWRpdW1wdXJwbGU6WzE0NywxMTIsMjE5XSxtZWRpdW1zZWFncmVlbjpbNjAsMTc5LDExM10sbWVkaXVtc2xhdGVibHVlOlsxMjMsMTA0LDIzOF0sbWVkaXVtc3ByaW5nZ3JlZW46WzAsMjUwLDE1NF0sbWVkaXVtdHVycXVvaXNlOls3MiwyMDksMjA0XSxtZWRpdW12aW9sZXRyZWQ6WzE5OSwyMSwxMzNdLG1pZG5pZ2h0Ymx1ZTpbMjUsMjUsMTEyXSxtaW50Y3JlYW06WzI0NSwyNTUsMjUwXSxtaXN0eXJvc2U6WzI1NSwyMjgsMjI1XSxtb2NjYXNpbjpbMjU1LDIyOCwxODFdLG5hdmFqb3doaXRlOlsyNTUsMjIyLDE3M10sbmF2eTpbMCwwLDEyOF0sb2xkbGFjZTpbMjUzLDI0NSwyMzBdLG9saXZlOlsxMjgsMTI4LDBdLG9saXZlZHJhYjpbMTA3LDE0MiwzNV0sb3JhbmdlOlsyNTUsMTY1LDBdLG9yYW5nZXJlZDpbMjU1LDY5LDBdLG9yY2hpZDpbMjE4LDExMiwyMTRdLHBhbGVnb2xkZW5yb2Q6WzIzOCwyMzIsMTcwXSxwYWxlZ3JlZW46WzE1MiwyNTEsMTUyXSxwYWxldHVycXVvaXNlOlsxNzUsMjM4LDIzOF0scGFsZXZpb2xldHJlZDpbMjE5LDExMiwxNDddLHBhcGF5YXdoaXA6WzI1NSwyMzksMjEzXSxwZWFjaHB1ZmY6WzI1NSwyMTgsMTg1XSxwZXJ1OlsyMDUsMTMzLDYzXSxwaW5rOlsyNTUsMTkyLDIwM10scGx1bTpbMjIxLDE2MCwyMjFdLHBvd2RlcmJsdWU6WzE3NiwyMjQsMjMwXSxwdXJwbGU6WzEyOCwwLDEyOF0scmViZWNjYXB1cnBsZTpbMTAyLDUxLDE1M10scmVkOlsyNTUsMCwwXSxyb3N5YnJvd246WzE4OCwxNDMsMTQzXSxyb3lhbGJsdWU6WzY1LDEwNSwyMjVdLHNhZGRsZWJyb3duOlsxMzksNjksMTldLHNhbG1vbjpbMjUwLDEyOCwxMTRdLHNhbmR5YnJvd246WzI0NCwxNjQsOTZdLHNlYWdyZWVuOls0NiwxMzksODddLHNlYXNoZWxsOlsyNTUsMjQ1LDIzOF0sc2llbm5hOlsxNjAsODIsNDVdLHNpbHZlcjpbMTkyLDE5MiwxOTJdLHNreWJsdWU6WzEzNSwyMDYsMjM1XSxzbGF0ZWJsdWU6WzEwNiw5MCwyMDVdLHNsYXRlZ3JheTpbMTEyLDEyOCwxNDRdLHNsYXRlZ3JleTpbMTEyLDEyOCwxNDRdLHNub3c6WzI1NSwyNTAsMjUwXSxzcHJpbmdncmVlbjpbMCwyNTUsMTI3XSxzdGVlbGJsdWU6WzcwLDEzMCwxODBdLHRhbjpbMjEwLDE4MCwxNDBdLHRlYWw6WzAsMTI4LDEyOF0sdGhpc3RsZTpbMjE2LDE5MSwyMTZdLHRvbWF0bzpbMjU1LDk5LDcxXSx0dXJxdW9pc2U6WzY0LDIyNCwyMDhdLHZpb2xldDpbMjM4LDEzMCwyMzhdLHdoZWF0OlsyNDUsMjIyLDE3OV0sd2hpdGU6WzI1NSwyNTUsMjU1XSx3aGl0ZXNtb2tlOlsyNDUsMjQ1LDI0NV0seWVsbG93OlsyNTUsMjU1LDBdLHllbGxvd2dyZWVuOlsxNTQsMjA1LDUwXX19LGZ1bmN0aW9uKFMsZSx0KXt2YXIgcj1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1MuZXhwb3J0cz1mdW5jdGlvbihpKXt2YXIgaDtyZXR1cm4gci5jYWxsKGkpPT09IltvYmplY3QgT2JqZWN0XSImJihoPU9iamVjdC5nZXRQcm90b3R5cGVPZihpKSxoPT09bnVsbHx8aD09PU9iamVjdC5nZXRQcm90b3R5cGVPZih7fSkpfX0sZnVuY3Rpb24oUyxlKXtTLmV4cG9ydHM9ZnVuY3Rpb24oKXtmb3IodmFyIHQ9MDt0PGFyZ3VtZW50cy5sZW5ndGg7dCsrKWlmKGFyZ3VtZW50c1t0XSE9PXZvaWQgMClyZXR1cm4gYXJndW1lbnRzW3RdfX0sZnVuY3Rpb24oUyxlLHQpe3ZhciByPXQoMzgpO1MuZXhwb3J0cz17bmFtZToiaHNsIixtaW46WzAsMCwwXSxtYXg6WzM2MCwxMDAsMTAwXSxjaGFubmVsOlsiaHVlIiwic2F0dXJhdGlvbiIsImxpZ2h0bmVzcyJdLGFsaWFzOlsiSFNMIl0scmdiOmZ1bmN0aW9uKGkpe3ZhciBoPWlbMF0vMzYwLGc9aVsxXS8xMDAsdT1pWzJdLzEwMCxhLGMseCxmLHY7aWYoZz09PTApcmV0dXJuIHY9dSoyNTUsW3Ysdix2XTt1PC41P2M9dSooMStnKTpjPXUrZy11KmcsYT0yKnUtYyxmPVswLDAsMF07Zm9yKHZhciBwPTA7cDwzO3ArKyl4PWgrMS8zKi0ocC0xKSx4PDA/eCsrOng+MSYmeC0tLDYqeDwxP3Y9YSsoYy1hKSo2Kng6Mip4PDE/dj1jOjMqeDwyP3Y9YSsoYy1hKSooMi8zLXgpKjY6dj1hLGZbcF09dioyNTU7cmV0dXJuIGZ9fSxyLmhzbD1mdW5jdGlvbihpKXt2YXIgaD1pWzBdLzI1NSxnPWlbMV0vMjU1LHU9aVsyXS8yNTUsYT1NYXRoLm1pbihoLGcsdSksYz1NYXRoLm1heChoLGcsdSkseD1jLWEsZix2LHA7cmV0dXJuIGM9PT1hP2Y9MDpoPT09Yz9mPShnLXUpL3g6Zz09PWM/Zj0yKyh1LWgpL3g6dT09PWMmJihmPTQrKGgtZykveCksZj1NYXRoLm1pbihmKjYwLDM2MCksZjwwJiYoZis9MzYwKSxwPShhK2MpLzIsYz09PWE/dj0wOnA8PS41P3Y9eC8oYythKTp2PXgvKDItYy1hKSxbZix2KjEwMCxwKjEwMF19fSxmdW5jdGlvbihTLGUsdCl7Uy5leHBvcnRzPXtuYW1lOiJyZ2IiLG1pbjpbMCwwLDBdLG1heDpbMjU1LDI1NSwyNTVdLGNoYW5uZWw6WyJyZWQiLCJncmVlbiIsImJsdWUiXSxhbGlhczpbIlJHQiJdfX0sZnVuY3Rpb24oUyxlKXtTLmV4cG9ydHM9dDtmdW5jdGlvbiB0KHIsaSxoKXtyZXR1cm4gaTxoP3I8aT9pOnI+aD9oOnI6cjxoP2g6cj5pP2k6cn19LGZ1bmN0aW9uKFMsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIG99KTt2YXIgcj10KDQxKSxpPXQubihyKSxoPXQoNDIpLGc9dC5uKGgpLHU9dCg0MyksYT10Lm4odSksYz10KDQ0KSx4PXQoNDYpLGY9dC5uKHgpLHY9dCg1MykscD10KDU1KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3QgQz1TeW1ib2woImNvbnRvdXJzIiksTT1TeW1ib2woInBhdGgiKSxtPVN5bWJvbCgic2ltcGxpZnkiKSx5PVN5bWJvbCgic2NhbGUiKSxuPTIqTWF0aC5QSTtjbGFzcyBve2NvbnN0cnVjdG9yKGw9e30pe3R5cGVvZiBsPT0ic3RyaW5nIiYmKGw9e3BhdGg6bH0pLGwucGF0aD90aGlzW01dPWkoKShsLnBhdGgpOnRoaXNbTV09W10sdGhpc1tDXT1udWxsLHRoaXNbbV09bC5zaW1wbGlmeSE9bnVsbD9sLnNpbXBsaWZ5OjAsdGhpc1t5XT1sLnNjYWxlIT1udWxsP2wuc2NhbGU6Mn1nZXQgY29udG91cnMoKXtsZXQgbD1udWxsO2lmKCF0aGlzW0NdJiZ0aGlzW01dKXtjb25zdCBFPU9iamVjdChjLmRlZmF1bHQpKGEoKSh0aGlzW01dKSk7dGhpc1tDXT1mKCkoRSx0aGlzW3ldLHRoaXNbbV0pLHRoaXNbQ10ucGF0aD1FLHRoaXNbQ10uc2ltcGxpZnk9dGhpc1ttXSx0aGlzW0NdLnNjYWxlPXRoaXNbeV19cmV0dXJuIHRoaXNbQ10mJihsPXRoaXNbQ10ubWFwKEU9PlsuLi5FXSksbC5wYXRoPXRoaXNbQ10ucGF0aCxsLnNpbXBsaWZ5PXRoaXNbQ10uc2ltcGxpZnksbC5zY2FsZT10aGlzW0NdLnNjYWxlKSxsfWdldCBwYXRoKCl7cmV0dXJuIHRoaXNbTV19Z2V0IHNpbXBsaWZ5KCl7cmV0dXJuIHRoaXNbbV19Z2V0IGJvdW5kaW5nQm94KCl7Y29uc3QgbD10aGlzLmNvbnRvdXJzO2lmKGwmJmwubGVuZ3RoKXtjb25zdCBFPWwucmVkdWNlKChULGIpPT5bLi4uVCwuLi5iXSk7cmV0dXJuIGcoKShFKX1yZXR1cm5bWzAsMF0sWzAsMF1dfWdldCBib3VuZGluZ0NlbnRlcigpe2NvbnN0IGw9dGhpcy5ib3VuZGluZ0JveDtyZXR1cm4gbD9bLjUqKGxbMF1bMF0rbFsxXVswXSksLjUqKGxbMF1bMV0rbFsxXVsxXSldOlswLDBdfW5vcm1hbGl6ZShsPTAsRT0wKXtjb25zdCBUPU9iamVjdChjLmRlZmF1bHQpKGEoKSh0aGlzW01dKSkubWFwKChbYiwuLi5JXSk9Pntjb25zdCBQPVtiXTtmb3IobGV0IEw9MDtMPEkubGVuZ3RoO0wrPTIpe2NvbnN0IEQ9SVtMXS1sLFI9SVtMKzFdLUU7UC5wdXNoKEQsUil9cmV0dXJuIFB9KTtyZXR1cm4gdGhpcy5iZWdpblBhdGgoKSx0aGlzW01dLnB1c2goLi4uVCksdGhpc31nZXRQb2ludEF0TGVuZ3RoKGwpe3JldHVybiB0aGlzLmNvbnRvdXJzP09iamVjdCh2LmdldFBvaW50QXRMZW5ndGgpKHRoaXNbQ10sbCk6bnVsbH1nZXRUb3RhbExlbmd0aCgpe3JldHVybiB0aGlzLmNvbnRvdXJzP09iamVjdCh2LmdldFRvdGFsTGVuZ3RoKSh0aGlzW0NdKTowfWFkZFBhdGgobCl7dGhpc1tDXT1udWxsLHR5cGVvZiBsPT0ic3RyaW5nIiYmKGw9aSgpKGwpKSx0aGlzW01dLnB1c2goLi4ubCl9YmVnaW5QYXRoKCl7dGhpc1tNXT1bXSx0aGlzW0NdPW51bGx9Y2xlYXIoKXt0aGlzLmJlZ2luUGF0aCgpfWVsbGlwc2UobCxFLFQsYixJLFAsTCxEPTApe2lmKFArPUksTCs9SSxUPD0wfHxiPD0wfHxMPT09UClyZXR1cm47TDxQJiYoTD1QK24rKEwtUCklbiksTC1QPm4mJihMPVArbik7Y29uc3QgUj1MLVA7Uj49biYmKEwtPS4wMDEpO2xldCBBPXRoaXNbTV0ubGVuZ3RoPjAmJlI8bj8iTCI6Ik0iO2NvbnN0IGo9T2JqZWN0KHAuZ2V0UG9pbnQpKGwsRSxULGIsUCksRz1PYmplY3QocC5nZXRQb2ludCkobCxFLFQsYixMKSxIPSshRDtsZXQgWj1SPk1hdGguUEk/MTowO0QmJihaPTEtWiksQSs9ai5qb2luKCIgIiksQSs9YEEke1R9ICR7Yn0gMCAke1p9ICR7SH0gJHtHLmpvaW4oIiAiKX1gLFI+PW4mJihBKz0iWiIpLHRoaXMuYWRkUGF0aChBKX1hcmMobCxFLFQsYixJLFA9MCl7cmV0dXJuIHRoaXMuZWxsaXBzZShsLEUsVCxULDAsYixJLFApfWFyY1RvKGwsRSxULGIsSSxQLEwpe3RoaXNbQ109bnVsbCx0aGlzW01dLnB1c2goWyJBIixsLEUsVCxiLEksUCxMXSl9bW92ZVRvKGwsRSl7dGhpc1tDXT1udWxsLHRoaXNbTV0ucHVzaChbIk0iLGwsRV0pfWxpbmVUbyhsLEUpe3RoaXNbQ109bnVsbCx0aGlzW01dLnB1c2goWyJMIixsLEVdKX1iZXppZXJDdXJ2ZVRvKGwsRSxULGIsSSxQKXt0aGlzW0NdPW51bGwsdGhpc1tNXS5wdXNoKFsiQyIsbCxFLFQsYixJLFBdKX1xdWFkcmF0aWNDdXJ2ZVRvKGwsRSxULGIpe3RoaXNbQ109bnVsbCx0aGlzW01dLnB1c2goWyJRIixsLEUsVCxiXSl9cmVjdChsLEUsVCxiKXtjb25zdCBJPWBNJHtsfSAke0V9TCR7bCtUfSAke0V9TCR7bCtUfSAke0UrYn1MJHtsfSAke0UrYn1aYDt0aGlzLmFkZFBhdGgoSSl9Y2xvc2VQYXRoKCl7dGhpc1tDXT1udWxsO2xldCBsPVtdO2NvbnN0IEU9dGhpc1tNXS5sZW5ndGg7RT4wJiYobD10aGlzW01dW0UtMV0pLGxbMF0hPT0iWiImJmxbMF0hPT0ieiImJnRoaXNbTV0ucHVzaChbIloiXSl9fX0sZnVuY3Rpb24oUyxlKXtTLmV4cG9ydHM9aTt2YXIgdD17YTo3LGM6NixoOjEsbDoyLG06MixxOjQsczo0LHQ6Mix2OjEsejowfSxyPS8oW2FzdHZ6cW1obGNdKShbXmFzdHZ6cW1obGNdKikvaWc7ZnVuY3Rpb24gaSh1KXt2YXIgYT1bXTtyZXR1cm4gdS5yZXBsYWNlKHIsZnVuY3Rpb24oYyx4LGYpe3ZhciB2PXgudG9Mb3dlckNhc2UoKTtmb3IoZj1nKGYpLHY9PSJtIiYmZi5sZW5ndGg+MiYmKGEucHVzaChbeF0uY29uY2F0KGYuc3BsaWNlKDAsMikpKSx2PSJsIix4PXg9PSJtIj8ibCI6IkwiKTs7KXtpZihmLmxlbmd0aD09dFt2XSlyZXR1cm4gZi51bnNoaWZ0KHgpLGEucHVzaChmKTtpZihmLmxlbmd0aDx0W3ZdKXRocm93IG5ldyBFcnJvcigibWFsZm9ybWVkIHBhdGggZGF0YSIpO2EucHVzaChbeF0uY29uY2F0KGYuc3BsaWNlKDAsdFt2XSkpKX19KSxhfXZhciBoPS8tP1swLTldKlwuP1swLTldKyg/OmVbLStdP1xkKyk/L2lnO2Z1bmN0aW9uIGcodSl7dmFyIGE9dS5tYXRjaChoKTtyZXR1cm4gYT9hLm1hcChOdW1iZXIpOltdfX0sZnVuY3Rpb24oUyxlLHQpe1MuZXhwb3J0cz1yO2Z1bmN0aW9uIHIoaSl7dmFyIGg9aS5sZW5ndGg7aWYoaD09PTApcmV0dXJuW1tdLFtdXTtmb3IodmFyIGc9aVswXS5sZW5ndGgsdT1pWzBdLnNsaWNlKCksYT1pWzBdLnNsaWNlKCksYz0xO2M8aDsrK2MpZm9yKHZhciB4PWlbY10sZj0wO2Y8ZzsrK2Ype3ZhciB2PXhbZl07dVtmXT1NYXRoLm1pbih1W2ZdLHYpLGFbZl09TWF0aC5tYXgoYVtmXSx2KX1yZXR1cm5bdSxhXX19LGZ1bmN0aW9uKFMsZSl7Uy5leHBvcnRzPXQ7ZnVuY3Rpb24gdChyKXt2YXIgaT0wLGg9MCxnPTAsdT0wO3JldHVybiByLm1hcChmdW5jdGlvbihhKXthPWEuc2xpY2UoKTt2YXIgYz1hWzBdLHg9Yy50b1VwcGVyQ2FzZSgpO2lmKGMhPXgpc3dpdGNoKGFbMF09eCxjKXtjYXNlImEiOmFbNl0rPWcsYVs3XSs9dTticmVhaztjYXNlInYiOmFbMV0rPXU7YnJlYWs7Y2FzZSJoIjphWzFdKz1nO2JyZWFrO2RlZmF1bHQ6Zm9yKHZhciBmPTE7ZjxhLmxlbmd0aDspYVtmKytdKz1nLGFbZisrXSs9dX1zd2l0Y2goeCl7Y2FzZSJaIjpnPWksdT1oO2JyZWFrO2Nhc2UiSCI6Zz1hWzFdO2JyZWFrO2Nhc2UiViI6dT1hWzFdO2JyZWFrO2Nhc2UiTSI6Zz1pPWFbMV0sdT1oPWFbMl07YnJlYWs7ZGVmYXVsdDpnPWFbYS5sZW5ndGgtMl0sdT1hW2EubGVuZ3RoLTFdfXJldHVybiBhfSl9fSxmdW5jdGlvbihTLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBpfSk7dmFyIHI9dCg0NSk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIGkodSl7Zm9yKHZhciBhLGM9W10seD0wLGY9MCx2PTAscD0wLEM9bnVsbCxNPW51bGwsbT0wLHk9MCxuPTAsbz11Lmxlbmd0aDtuPG87bisrKXt2YXIgcz11W25dLGw9c1swXTtzd2l0Y2gobCl7Y2FzZSJNIjp2PXNbMV0scD1zWzJdO2JyZWFrO2Nhc2UiQSI6dmFyIEU9T2JqZWN0KHIuZGVmYXVsdCkobSx5LHNbNl0sc1s3XSxzWzRdLHNbNV0sc1sxXSxzWzJdLHNbM10pO2lmKCFFLmxlbmd0aCljb250aW51ZTtFPUUubWFwKEw9Pntjb25zdFtELFIsQSxqLEcsSCxaLHFdPUw7cmV0dXJue3gxOkEseTE6aix4MjpHLHkyOkgseDpaLHk6cX19KTtmb3IodmFyIFQ9MCxiO1Q8RS5sZW5ndGg7VCsrKWI9RVtUXSxzPVsiQyIsYi54MSxiLnkxLGIueDIsYi55MixiLngsYi55XSxUPEUubGVuZ3RoLTEmJmMucHVzaChzKTticmVhaztjYXNlIlMiOnZhciBJPW0sUD15OyhhPT0iQyJ8fGE9PSJTIikmJihJKz1JLXgsUCs9UC1mKSxzPVsiQyIsSSxQLHNbMV0sc1syXSxzWzNdLHNbNF1dO2JyZWFrO2Nhc2UiVCI6YT09IlEifHxhPT0iVCI/KEM9bSoyLUMsTT15KjItTSk6KEM9bSxNPXkpLHM9ZyhtLHksQyxNLHNbMV0sc1syXSk7YnJlYWs7Y2FzZSJRIjpDPXNbMV0sTT1zWzJdLHM9ZyhtLHksc1sxXSxzWzJdLHNbM10sc1s0XSk7YnJlYWs7Y2FzZSJMIjpzPWgobSx5LHNbMV0sc1syXSk7YnJlYWs7Y2FzZSJIIjpzPWgobSx5LHNbMV0seSk7YnJlYWs7Y2FzZSJWIjpzPWgobSx5LG0sc1sxXSk7YnJlYWs7Y2FzZSJaIjpzPWgobSx5LHYscCk7YnJlYWt9YT1sLG09c1tzLmxlbmd0aC0yXSx5PXNbcy5sZW5ndGgtMV0scy5sZW5ndGg+ND8oeD1zW3MubGVuZ3RoLTRdLGY9c1tzLmxlbmd0aC0zXSk6KHg9bSxmPXkpLGMucHVzaChzKX1yZXR1cm4gY31mdW5jdGlvbiBoKHUsYSxjLHgpe3JldHVyblsiQyIsdSxhLGMseCxjLHhdfWZ1bmN0aW9uIGcodSxhLGMseCxmLHYpe3JldHVyblsiQyIsdS8zKzIvMypjLGEvMysyLzMqeCxmLzMrMi8zKmMsdi8zKzIvMyp4LGYsdl19fSxmdW5jdGlvbihTLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiB1fSksdCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IHI9TWF0aC5QSSoyO2Z1bmN0aW9uIGkoYSxjLHgsZil7Y29uc3Qgdj1hKmYtYyp4PDA/LTE6MTtsZXQgcD1hKngrYypmO3JldHVybiBwPjEmJihwPTEpLHA8LTEmJihwPS0xKSx2Kk1hdGguYWNvcyhwKX1mdW5jdGlvbiBoKGEsYyx4LGYsdixwLEMsTSxtLHkpe2NvbnN0IG49eSooYS14KS8yK20qKGMtZikvMixvPS1tKihhLXgpLzIreSooYy1mKS8yLHM9QypDLGw9TSpNLEU9bipuLFQ9bypvO2xldCBiPXMqbC1zKlQtbCpFO2I8MCYmKGI9MCksYi89cypUK2wqRSxiPU1hdGguc3FydChiKSoodj09PXA/LTE6MSk7Y29uc3QgST1iKkMvTSpvLFA9YiotTS9DKm4sTD15KkktbSpQKyhhK3gpLzIsRD1tKkkreSpQKyhjK2YpLzIsUj0obi1JKS9DLEE9KG8tUCkvTSxqPSgtbi1JKS9DLEc9KC1vLVApL00sSD1pKDEsMCxSLEEpO2xldCBaPWkoUixBLGosRyk7cmV0dXJuIHA9PT0wJiZaPjAmJihaLT1yKSxwPT09MSYmWjwwJiYoWis9ciksW0wsRCxILFpdfWZ1bmN0aW9uIGcoYSxjKXtjb25zdCB4PTEuMzMzMzMzMzMzMzMzMzMzMypNYXRoLnRhbihjLzQpLGY9TWF0aC5jb3MoYSksdj1NYXRoLnNpbihhKSxwPU1hdGguY29zKGErYyksQz1NYXRoLnNpbihhK2MpO3JldHVybltmLHYsZi12KngsditmKngscCtDKngsQy1wKngscCxDXX1mdW5jdGlvbiB1KGEsYyx4LGYsdixwLEMsTSxtKXtjb25zdCB5PU1hdGguc2luKG0qci8zNjApLG49TWF0aC5jb3MobSpyLzM2MCksbz1uKihhLXgpLzIreSooYy1mKS8yLHM9LXkqKGEteCkvMituKihjLWYpLzI7aWYobz09PTAmJnM9PT0wKXJldHVybltdO2lmKEM9PT0wfHxNPT09MClyZXR1cm5bXTtDPU1hdGguYWJzKEMpLE09TWF0aC5hYnMoTSk7Y29uc3QgbD1vKm8vKEMqQykrcypzLyhNKk0pO2w+MSYmKEMqPU1hdGguc3FydChsKSxNKj1NYXRoLnNxcnQobCkpO2NvbnN0IEU9aChhLGMseCxmLHYscCxDLE0seSxuKSxUPVtdO2xldCBiPUVbMl0sST1FWzNdO2NvbnN0IFA9TWF0aC5tYXgoTWF0aC5jZWlsKE1hdGguYWJzKEkpLyhyLzQpKSwxKTtJLz1QO2ZvcihsZXQgTD0wO0w8UDtMKyspVC5wdXNoKGcoYixJKSksYis9STtyZXR1cm4gVC5tYXAoTD0+e2ZvcihsZXQgRD0wO0Q8TC5sZW5ndGg7RCs9Mil7bGV0IFI9TFtEKzBdLEE9TFtEKzFdO1IqPUMsQSo9TTtjb25zdCBqPW4qUi15KkEsRz15KlIrbipBO0xbRCswXT1qK0VbMF0sTFtEKzFdPUcrRVsxXX1yZXR1cm4gTH0pfX0sZnVuY3Rpb24oUyxlLHQpe3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTt2YXIgcj10KDQ3KSx7Y29weTppfT10KDQ5KSxoPXQoNTApO2Z1bmN0aW9uIGcoZix2LHApe3JldHVybiBmWzBdPXYsZlsxXT1wLGZ9dmFyIHU9WzAsMF0sYT1bMCwwXSxjPVswLDBdO2Z1bmN0aW9uIHgoZix2LHAsQyl7cihwLGcodSxDWzFdLENbMl0pLGcoYSxDWzNdLENbNF0pLGcoYyxDWzVdLENbNl0pLHYsZil9Uy5leHBvcnRzPWZ1bmN0aW9uKHYscCxDKXt2YXIgTT1bXSxtPVtdLHk9WzAsMF07cmV0dXJuIHYuZm9yRWFjaChmdW5jdGlvbihuLG8scyl7aWYoblswXT09PSJNIilpKHksbi5zbGljZSgxKSksbS5sZW5ndGg+MCYmKE0ucHVzaChtKSxtPVtdKTtlbHNlIGlmKG5bMF09PT0iQyIpeChtLHAseSxuKSxnKHksbls1XSxuWzZdKTtlbHNlIHRocm93IG5ldyBFcnJvcigiaWxsZWdhbCB0eXBlIGluIFNWRzogIituWzBdKX0pLG0ubGVuZ3RoPjAmJk0ucHVzaChtKSxNLm1hcChmdW5jdGlvbihuKXtyZXR1cm4gaChuLEN8fDApfSl9fSxmdW5jdGlvbihTLGUsdCl7Uy5leHBvcnRzPXQoNDgpKCl9LGZ1bmN0aW9uKFMsZSl7ZnVuY3Rpb24gdChpKXtyZXR1cm5baVswXSxpWzFdXX1mdW5jdGlvbiByKGksaCl7cmV0dXJuW2ksaF19Uy5leHBvcnRzPWZ1bmN0aW9uKGgpe2g9aHx8e307dmFyIGc9dHlwZW9mIGgucmVjdXJzaW9uPT0ibnVtYmVyIj9oLnJlY3Vyc2lvbjo4LHU9dHlwZW9mIGguZXBzaWxvbj09Im51bWJlciI/aC5lcHNpbG9uOjExOTIwOTI5ZS0xNCxhPXR5cGVvZiBoLnBhdGhFcHNpbG9uPT0ibnVtYmVyIj9oLnBhdGhFcHNpbG9uOjEsYz10eXBlb2YgaC5hbmdsZUVwc2lsb249PSJudW1iZXIiP2guYW5nbGVFcHNpbG9uOi4wMSx4PWguYW5nbGVUb2xlcmFuY2V8fDAsZj1oLmN1c3BMaW1pdHx8MDtyZXR1cm4gZnVuY3Rpb24oTSxtLHksbixvLHMpe3N8fChzPVtdKSxvPXR5cGVvZiBvPT0ibnVtYmVyIj9vOjE7dmFyIGw9YS9vO3JldHVybiBsKj1sLHYoTSxtLHksbixzLGwpLHN9O2Z1bmN0aW9uIHYoQyxNLG0seSxuLG8pe24ucHVzaCh0KEMpKTt2YXIgcz1DWzBdLGw9Q1sxXSxFPU1bMF0sVD1NWzFdLGI9bVswXSxJPW1bMV0sUD15WzBdLEw9eVsxXTtwKHMsbCxFLFQsYixJLFAsTCxuLG8sMCksbi5wdXNoKHQoeSkpfWZ1bmN0aW9uIHAoQyxNLG0seSxuLG8scyxsLEUsVCxiKXtpZighKGI+Zykpe3ZhciBJPU1hdGguUEksUD0oQyttKS8yLEw9KE0reSkvMixEPShtK24pLzIsUj0oeStvKS8yLEE9KG4rcykvMixqPShvK2wpLzIsRz0oUCtEKS8yLEg9KEwrUikvMixaPShEK0EpLzIscT0oUitqKS8yLEY9KEcrWikvMiwkPShIK3EpLzI7aWYoYj4wKXt2YXIgSj1zLUMsdHQ9bC1NLF89TWF0aC5hYnMoKG0tcykqdHQtKHktbCkqSiksc3Q9TWF0aC5hYnMoKG4tcykqdHQtKG8tbCkqSiksayxjdDtpZihfPnUmJnN0PnUpe2lmKChfK3N0KSooXytzdCk8PVQqKEoqSit0dCp0dCkpe2lmKHg8Yyl7RS5wdXNoKHIoRiwkKSk7cmV0dXJufXZhciBmdD1NYXRoLmF0YW4yKG8teSxuLW0pO2lmKGs9TWF0aC5hYnMoZnQtTWF0aC5hdGFuMih5LU0sbS1DKSksY3Q9TWF0aC5hYnMoTWF0aC5hdGFuMihsLW8scy1uKS1mdCksaz49SSYmKGs9MipJLWspLGN0Pj1JJiYoY3Q9MipJLWN0KSxrK2N0PHgpe0UucHVzaChyKEYsJCkpO3JldHVybn1pZihmIT09MCl7aWYoaz5mKXtFLnB1c2gocihtLHkpKTtyZXR1cm59aWYoY3Q+Zil7RS5wdXNoKHIobixvKSk7cmV0dXJufX19fWVsc2UgaWYoXz51KXtpZihfKl88PVQqKEoqSit0dCp0dCkpe2lmKHg8Yyl7RS5wdXNoKHIoRiwkKSk7cmV0dXJufWlmKGs9TWF0aC5hYnMoTWF0aC5hdGFuMihvLXksbi1tKS1NYXRoLmF0YW4yKHktTSxtLUMpKSxrPj1JJiYoaz0yKkktayksazx4KXtFLnB1c2gocihtLHkpKSxFLnB1c2gocihuLG8pKTtyZXR1cm59aWYoZiE9PTAmJms+Zil7RS5wdXNoKHIobSx5KSk7cmV0dXJufX19ZWxzZSBpZihzdD51KXtpZihzdCpzdDw9VCooSipKK3R0KnR0KSl7aWYoeDxjKXtFLnB1c2gocihGLCQpKTtyZXR1cm59aWYoaz1NYXRoLmFicyhNYXRoLmF0YW4yKGwtbyxzLW4pLU1hdGguYXRhbjIoby15LG4tbSkpLGs+PUkmJihrPTIqSS1rKSxrPHgpe0UucHVzaChyKG0seSkpLEUucHVzaChyKG4sbykpO3JldHVybn1pZihmIT09MCYmaz5mKXtFLnB1c2gocihuLG8pKTtyZXR1cm59fX1lbHNlIGlmKEo9Ri0oQytzKS8yLHR0PSQtKE0rbCkvMixKKkordHQqdHQ8PVQpe0UucHVzaChyKEYsJCkpO3JldHVybn19cChDLE0sUCxMLEcsSCxGLCQsRSxULGIrMSkscChGLCQsWixxLEEsaixzLGwsRSxULGIrMSl9fX19LGZ1bmN0aW9uKFMsZSx0KXt0LnIoZSksdC5kKGUsImNyZWF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gaH0pLHQuZChlLCJjbG9uZSIsZnVuY3Rpb24oKXtyZXR1cm4gaX0pLHQuZChlLCJjb3B5IixmdW5jdGlvbigpe3JldHVybiBnfSksdC5kKGUsInNjYWxlQW5kQWRkIixmdW5jdGlvbigpe3JldHVybiB1fSksdC5kKGUsImRvdCIsZnVuY3Rpb24oKXtyZXR1cm4gYX0pLHQuZChlLCJyb3RhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIGN9KSx0LmQoZSwiY3Jvc3MiLGZ1bmN0aW9uKCl7cmV0dXJuIHh9KSx0LmQoZSwic3ViIixmdW5jdGlvbigpe3JldHVybiBmfSksdC5kKGUsImFkZCIsZnVuY3Rpb24oKXtyZXR1cm4gdn0pLHQuZChlLCJjb21wdXRlTWl0ZXIiLGZ1bmN0aW9uKCl7cmV0dXJuIG19KSx0LmQoZSwibm9ybWFsIixmdW5jdGlvbigpe3JldHVybiB5fSksdC5kKGUsImRpcmVjdGlvbiIsZnVuY3Rpb24oKXtyZXR1cm4gbn0pO3ZhciByPXQoMSk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIGkobyl7cmV0dXJuW29bMF0sb1sxXV19ZnVuY3Rpb24gaCgpe3JldHVyblswLDBdfWNvbnN0IGc9ci52ZWMyLmNvcHksdT1yLnZlYzIuc2NhbGVBbmRBZGQsYT1yLnZlYzIuZG90LGM9ci52ZWMyLnJvdGF0ZSx4PXIudmVjMi5jcm9zcyxmPXIudmVjMi5zdWIsdj1yLnZlYzIuYWRkLHA9ci52ZWMyLm5vcm1hbGl6ZSxDPXIudmVjMi5zZXQsTT1oKCk7ZnVuY3Rpb24gbShvLHMsbCxFLFQpe3YobyxsLEUpLHAobyxvKSxDKHMsLW9bMV0sb1swXSksQyhNLC1sWzFdLGxbMF0pO2NvbnN0IGI9VC9hKHMsTSk7cmV0dXJuIE1hdGguYWJzKGIpfWZ1bmN0aW9uIHkobyxzKXtyZXR1cm4gQyhvLC1zWzFdLHNbMF0pLG99ZnVuY3Rpb24gbihvLHMsbCl7cmV0dXJuIGYobyxzLGwpLHAobyxvKSxvfX0sZnVuY3Rpb24oUyxlLHQpe3ZhciByPXQoNTEpLGk9dCg1Mik7Uy5leHBvcnRzPWZ1bmN0aW9uKGcsdSl7cmV0dXJuIGc9cihnLHUpLGc9aShnLHUpLGd9LFMuZXhwb3J0cy5yYWRpYWxEaXN0YW5jZT1yLFMuZXhwb3J0cy5kb3VnbGFzUGV1Y2tlcj1pfSxmdW5jdGlvbihTLGUpe2Z1bmN0aW9uIHQocixpKXt2YXIgaD1yWzBdLWlbMF0sZz1yWzFdLWlbMV07cmV0dXJuIGgqaCtnKmd9Uy5leHBvcnRzPWZ1bmN0aW9uKGksaCl7aWYoaS5sZW5ndGg8PTEpcmV0dXJuIGk7aD10eXBlb2YgaD09Im51bWJlciI/aDoxO2Zvcih2YXIgZz1oKmgsdT1pWzBdLGE9W3VdLGMseD0xLGY9aS5sZW5ndGg7eDxmO3grKyljPWlbeF0sdChjLHUpPmcmJihhLnB1c2goYyksdT1jKTtyZXR1cm4gdSE9PWMmJmEucHVzaChjKSxhfX0sZnVuY3Rpb24oUyxlKXtmdW5jdGlvbiB0KGksaCxnKXt2YXIgdT1oWzBdLGE9aFsxXSxjPWdbMF0tdSx4PWdbMV0tYTtpZihjIT09MHx8eCE9PTApe3ZhciBmPSgoaVswXS11KSpjKyhpWzFdLWEpKngpLyhjKmMreCp4KTtmPjE/KHU9Z1swXSxhPWdbMV0pOmY+MCYmKHUrPWMqZixhKz14KmYpfXJldHVybiBjPWlbMF0tdSx4PWlbMV0tYSxjKmMreCp4fWZ1bmN0aW9uIHIoaSxoLGcsdSxhKXtmb3IodmFyIGM9dSx4LGY9aCsxO2Y8ZztmKyspe3ZhciB2PXQoaVtmXSxpW2hdLGlbZ10pO3Y+YyYmKHg9ZixjPXYpfWM+dSYmKHgtaD4xJiZyKGksaCx4LHUsYSksYS5wdXNoKGlbeF0pLGcteD4xJiZyKGkseCxnLHUsYSkpfVMuZXhwb3J0cz1mdW5jdGlvbihoLGcpe2lmKGgubGVuZ3RoPD0xKXJldHVybiBoO2c9dHlwZW9mIGc9PSJudW1iZXIiP2c6MTt2YXIgdT1nKmcsYT1oLmxlbmd0aC0xLGM9W2hbMF1dO3JldHVybiByKGgsMCxhLHUsYyksYy5wdXNoKGhbYV0pLGN9fSxmdW5jdGlvbihTLGUsdCl7dC5yKGUpLHQuZChlLCJnZXRUb3RhbExlbmd0aCIsZnVuY3Rpb24oKXtyZXR1cm4gaX0pLHQuZChlLCJnZXRQb2ludEF0TGVuZ3RoIixmdW5jdGlvbigpe3JldHVybiBnfSksdC5kKGUsImdldERhc2hDb250b3VycyIsZnVuY3Rpb24oKXtyZXR1cm4gdX0pO3ZhciByPXQoNTQpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBpKGEpe2lmKGEudG90YWxMZW5ndGghPW51bGwpcmV0dXJuIGEudG90YWxMZW5ndGg7bGV0IGM9MDtyZXR1cm4gYS5mb3JFYWNoKHg9PntsZXQgZj14WzBdO2ZvcihsZXQgdj0xO3Y8eC5sZW5ndGg7disrKXtjb25zdCBwPXhbdl07Yys9T2JqZWN0KHIuZGlzdGFuY2UpKGYscCksZj1wfX0pLGEudG90YWxMZW5ndGg9YyxjfWZ1bmN0aW9uIGgoYSxjLHg9ITApe2lmKGM9TnVtYmVyKGMpLCFOdW1iZXIuaXNGaW5pdGUoYykpdGhyb3cgbmV3IFR5cGVFcnJvcigiRmFpbGVkIHRvIGV4ZWN1dGUgJ2dldFBvaW50QXRMZW5ndGgnIG9uIGZpZ3VyZTogVGhlIHByb3ZpZGVkIGZsb2F0IHZhbHVlIGlzIG5vbi1maW5pdGUuIik7aWYoYzw9MCl0aHJvdyBuZXcgVHlwZUVycm9yKCJMZW5ndGggbXVzdCA+IDAiKTtjb25zdCBmPWkoYSk7aWYoYz49Zil7Y29uc3QgcD1hW2EubGVuZ3RoLTFdLEM9cFtwLmxlbmd0aC0yXSxNPXBbcC5sZW5ndGgtMV0sbT1NYXRoLmF0YW4yKE1bMV0tQ1sxXSxNWzBdLUNbMF0pO3JldHVybntjdXJyZW50OmEubWFwKHk9PlsuLi55XSkscG9pbnQ6e3g6TVswXSx5Ok1bMV0sYW5nbGU6bX19fWNvbnN0IHY9W107Zm9yKGxldCBwPTA7cDxhLmxlbmd0aDtwKyspe3ZbcF09W107Y29uc3QgQz1hW3BdO2xldCBNPUNbMF07Zm9yKGxldCBtPTE7bTxDLmxlbmd0aDttKyspe2NvbnN0IHk9Q1ttXSxuPU9iamVjdChyLmRpc3RhbmNlKShNLHkpO2lmKGM8bil7Y29uc3Qgbz1jL24scz1NYXRoLmF0YW4yKHlbMV0tTVsxXSx5WzBdLU1bMF0pLGw9e3g6TVswXSooMS1vKSt5WzBdKm8seTpNWzFdKigxLW8pK3lbMV0qbyxhbmdsZTpzfTtpZih2W3BdLnB1c2goTSksYz4wJiZ2W3BdLnB1c2goW2wueCxsLnldKSwheClyZXR1cm57Y3VycmVudDp2LHBvaW50Omx9O2NvbnN0IEU9W10sVD1wO2Zvcig7cDxhLmxlbmd0aDtwKyspe2ZvcihFW3AtVF09W10scD09PVQmJkVbMF0ucHVzaChbbC54LGwueV0pO208Qy5sZW5ndGg7bSsrKUVbcC1UXS5wdXNoKENbbV0pO209MH1yZXR1cm57Y3VycmVudDp2LHBvaW50OmwscmVzdDpFfX1jLT1uLHZbcF0ucHVzaChNKSxNPXl9fX1mdW5jdGlvbiBnKGEsYyl7aWYoYz1OdW1iZXIoYyksIU51bWJlci5pc0Zpbml0ZShjKSl0aHJvdyBuZXcgVHlwZUVycm9yKCJGYWlsZWQgdG8gZXhlY3V0ZSAnZ2V0UG9pbnRBdExlbmd0aCcgb24gZmlndXJlOiBUaGUgcHJvdmlkZWQgZmxvYXQgdmFsdWUgaXMgbm9uLWZpbml0ZS4iKTtpZihhLmxlbmd0aDw9MClyZXR1cm57eDowLHk6MCxhbmdsZTowfTtpZihjPD0wKXtjb25zdCB4PWFbMF1bMF0sZj1hWzBdWzFdLHY9TWF0aC5hdGFuMihmWzFdLXhbMV0sZlswXS14WzBdKTtyZXR1cm57eDp4WzBdLHk6eFsxXSxhbmdsZTp2fX1yZXR1cm4gaChhLGMsITEpLnBvaW50fWZ1bmN0aW9uIHUoYSxjLHgpe2xldCBmPTAsdj1jWzBdLHA9YTtjb25zdCBDPVtdLE09Yy5sZW5ndGg7aWYoeD4wKXtkbyB4LT1jW2YlTV0sZisrO3doaWxlKHg+MCk7eDwwJiYodj0teCxmLS0pfWVsc2UgaWYoeDwwKXtmPS0xO2RvIHgrPWNbZiVNK00tMV0sZi0tO3doaWxlKHg8MCk7eD49MCYmKGYrKyx2PWNbZiVNK00tMV0teCl9ZG97Y29uc3QgbT1oKHAsdik7cD1tLnJlc3QsKytmJTImJkMucHVzaCguLi5tLmN1cnJlbnQpO2xldCB5PWYlTTt5PDAmJih5Kz1NKSx2PWNbeV19d2hpbGUocCk7cmV0dXJuIEN9fSxmdW5jdGlvbihTLGUsdCl7dC5yKGUpLHQuZChlLCJub3JtYWxpemUiLGZ1bmN0aW9uKCl7cmV0dXJuIHJ9KSx0LmQoZSwiZGlzdGFuY2UiLGZ1bmN0aW9uKCl7cmV0dXJuIGl9KSx0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gcihbaCxnLHVdLGEsYyx4KXtyZXR1cm4gaD1oKjIvYS0xLGc9MS1nKjIvYyxOdW1iZXIuaXNGaW5pdGUoeCk/KHU9dSoyL3gtMSxbaCxnLHVdKTpbaCxnXX1mdW5jdGlvbiBpKFtoLGcsdT0wXSxbYSxjLHg9MF0pe3JldHVybiBNYXRoLmh5cG90KGEtaCxjLWcseC11KX19LGZ1bmN0aW9uKFMsZSx0KXt0LnIoZSksdC5kKGUsImdldFBvaW50IixmdW5jdGlvbigpe3JldHVybiBpfSksdCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IHI9TWF0aC5QSSoyO2Z1bmN0aW9uIGkoaCxnLHUsYSxjKXtjJT1yLGM8MCYmKGMrPXIpO2NvbnN0IHg9TWF0aC50YW4oYyk7aWYoTWF0aC5hYnMoeCk8MWU1KXtjb25zdCBmPWcteCpoLHY9MS91KioyK3gqKjIvYSoqMjtsZXQgcD0tMTsoYzw9TWF0aC5QSS8yfHxjPjMqTWF0aC5QSS8yKSYmKHA9MSk7Y29uc3QgQz1wKk1hdGguc3FydCgxL3YpK2gsTT14KkMrZjtyZXR1cm5bQyxNXX1yZXR1cm4gYzxNYXRoLlBJP1toLGcrYV06W2gsZy1hXX19LGZ1bmN0aW9uKFMsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIFZ9KTt2YXIgcj10KDEpLGk9dCg0MiksaD10Lm4oaSksZz10KDU3KSx1PXQoMjgpLGE9dCgyNCksYz10KDMwKSx4PXQoNTkpLGY9dCg1Myksdj10KDYwKSxwPXQubih2KSxDPXQoNDYpLE09dC5uKEMpLG09dCgzMSkseT10KDQwKSxuPXQoMjEpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBvKFgsQil7aWYoWD09bnVsbClyZXR1cm57fTt2YXIgdz1zKFgsQiksZCxPO2lmKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpe3ZhciBOPU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoWCk7Zm9yKE89MDtPPE4ubGVuZ3RoO08rKylkPU5bT10sIShCLmluZGV4T2YoZCk+PTApJiZPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoWCxkKSYmKHdbZF09WFtkXSl9cmV0dXJuIHd9ZnVuY3Rpb24gcyhYLEIpe2lmKFg9PW51bGwpcmV0dXJue307dmFyIHc9e30sZD1PYmplY3Qua2V5cyhYKSxPLE47Zm9yKE49MDtOPGQubGVuZ3RoO04rKylPPWRbTl0sIShCLmluZGV4T2YoTyk+PTApJiYod1tPXT1YW09dKTtyZXR1cm4gd31jb25zdCBsPVN5bWJvbCgibWVzaCIpLEU9U3ltYm9sKCJjb250b3VycyIpLFQ9U3ltYm9sKCJzdHJva2UiKSxiPVN5bWJvbCgiZmlsbCIpLEk9U3ltYm9sKCJzdHJva2VDb2xvciIpLFA9U3ltYm9sKCJmaWxsQ29sb3IiKSxMPVN5bWJvbCgidHJhbnNmb3JtIiksRD1TeW1ib2woImludmVydFRyYW5zZm9ybSIpLFI9U3ltYm9sKCJ1bmlmb3JtcyIpLEE9U3ltYm9sKCJ0ZXhPcHRpb25zIiksaj1TeW1ib2woImJsZW5kIiksRz1TeW1ib2woImFwcGx5VGV4dHVyZSIpLEg9U3ltYm9sKCJhcHBseVRyYW5zZm9ybSIpLFo9U3ltYm9sKCJhcHBseUdyYWRpZW50VHJhbnNmb3JtIikscT1TeW1ib2woImFwcGx5UHJvZ3JhbSIpLEY9U3ltYm9sKCJncmFkaWVudCIpLCQ9U3ltYm9sKCJmaWx0ZXIiKSxKPVN5bWJvbCgib3BhY2l0eSIpLHR0PVN5bWJvbCgicHJvZ3JhbSIpLF89U3ltYm9sKCJhdHRyaWJ1dGVzIiksc3Q9U3ltYm9sKCJwYXNzIiksaz1TeW1ib2woImNsaXBDb250ZXh0IiksY3Q9U3ltYm9sKCJhcHBseUNsaXBQYXRoIik7ZnVuY3Rpb24gZnQoWCxCKXtjb25zdFt3LGRdPVtYWzFdWzBdLVhbMF1bMF0sWFsxXVsxXS1YWzBdWzFdXSxPPVtdO2ZvcihsZXQgTj0wO048Qi5sZW5ndGg7TisrKXtjb25zdCB6PUJbTl0sSz1bKHpbMF0tWFswXVswXSkvdywxLSh6WzFdLVhbMF1bMV0pL2RdO08ucHVzaChLKX1yZXR1cm4gT31mdW5jdGlvbiBXKFtYLEJdLFt3LGQsTyxOXSx7c2NhbGU6en0pe3JldHVybiB6fHwoWC89TyxCPTEtQi9OLFgtPXcsQis9ZCksW1gsQiwwXX1mdW5jdGlvbiBVKFgsQix3KXtjb25zdCBkPU0oKShYLEIsdyk7cmV0dXJuIGQucGF0aD1YLGQuc2ltcGxpZnk9dyxkLnNjYWxlPUIsZH1jbGFzcyBWe2NvbnN0cnVjdG9yKEIpe3RoaXNbVF09bnVsbCx0aGlzW2JdPW51bGwsdGhpc1tMXT1bMSwwLDAsMSwwLDBdLHRoaXNbSl09MSx0aGlzW1JdPXt9LHRoaXNbJF09W10sdGhpc1tqXT1udWxsLHRoaXNbQV09e30sdGhpcy5jb250b3Vycz1CLmNvbnRvdXJzLHRoaXNbdHRdPW51bGwsdGhpc1tfXT17fSx0aGlzW3N0XT1bXX1nZXQgY29udG91cnMoKXtyZXR1cm4gdGhpc1tFXX1zZXQgY29udG91cnMoQil7dGhpc1tsXT1udWxsLHRoaXNbRV09Qjtjb25zdCB3PUIuc2NhbGU7dGhpcy50cmFuc2Zvcm1TY2FsZS93PjEuNSYmdGhpcy5hY2N1cmF0ZSh0aGlzLnRyYW5zZm9ybVNjYWxlKX1zZXRQcm9ncmFtKEIpe3RoaXNbdHRdPUIsdGhpc1tsXSYmdGhpc1txXShCKX1nZXQgcHJvZ3JhbSgpe3JldHVybiB0aGlzW3R0XX1zZXRBdHRyaWJ1dGUoQix3KXt3PT1udWxsP2RlbGV0ZSB0aGlzW19dW0JdOnRoaXNbX11bQl09d31nZXRPcGFjaXR5KCl7cmV0dXJuIHRoaXNbSl19c2V0T3BhY2l0eShCKXtpZihCPDB8fEI+MSl0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIG9wYWNpdHkgdmFsdWUuIik7dGhpc1tsXSYmdGhpc1tsXS5wb3NpdGlvbnMuZm9yRWFjaCh3PT57d1syXT0xL3dbMl0+MD9COi1CfSksdGhpc1tKXT1CfXNldENsaXBQYXRoKEIpe3RoaXMuY2xpcFBhdGg9Qix0aGlzW1JdLnVfY2xpcFNhbXBsZXImJnRoaXNbUl0udV9jbGlwU2FtcGxlci5kZWxldGUoKSx0aGlzLnNldFVuaWZvcm1zKHt1X2NsaXBTYW1wbGVyOm51bGx9KSx0aGlzW2xdJiZkZWxldGUgdGhpc1tsXS5hdHRyaWJ1dGVzLmFfY2xpcFVWLEImJnRoaXNbbF0mJnRoaXNbY3RdKCl9W2N0XSgpe2lmKHRoaXMuY2xpcFBhdGgpe3RoaXNba118fCh0aGlzW2tdPW4uZGVmYXVsdC5jcmVhdGVDYW52YXMoMSwxKSk7Y29uc3RbW0Isd10sW2QsT11dPXRoaXMuYm91bmRpbmdCb3g7ZCYmTyYmKHRoaXNba10ud2lkdGg9ZC1CLHRoaXNba10uaGVpZ2h0PU8tdyk7Y29uc3QgTj10aGlzW2tdLmdldENvbnRleHQoIjJkIiksej1uZXcgUGF0aDJEKHRoaXMuY2xpcFBhdGgpO04uY2xlYXJSZWN0KDAsMCx0aGlzW2tdLndpZHRoLHRoaXNba10uaGVpZ2h0KSxOLnNhdmUoKSxOLnRyYW5zbGF0ZSgtQiwtdyksTi5maWxsU3R5bGU9IndoaXRlIixOLmZpbGwoeiksTi5yZXN0b3JlKCksdGhpc1tsXS5jbGlwUGF0aD10aGlzW2tdO2NvbnN0IEs9ZnQodGhpcy5ib3VuZGluZ0JveCx0aGlzW2xdLnBvc2l0aW9uMCk7dGhpc1tsXS5hdHRyaWJ1dGVzLmFfY2xpcFVWPUt9fWdldFBvaW50QXRMZW5ndGgoQil7cmV0dXJuIE9iamVjdChmLmdldFBvaW50QXRMZW5ndGgpKHRoaXNbRV0sQil9Z2V0VG90YWxMZW5ndGgoKXtyZXR1cm4gT2JqZWN0KGYuZ2V0VG90YWxMZW5ndGgpKHRoaXNbRV0pfWdldCBibGVuZCgpe3JldHVybiB0aGlzW2pdPT1udWxsPyJhdXRvIjp0aGlzW2pdfXNldCBibGVuZChCKXt0aGlzW2pdPUIsdGhpc1tsXSYmKHRoaXNbbF0uZW5hYmxlQmxlbmQ9dGhpcy5lbmFibGVCbGVuZCl9Z2V0IGJvdW5kaW5nQm94KCl7aWYodGhpc1tsXSYmdGhpc1tsXS5ib3VuZGluZ0JveClyZXR1cm4gdGhpc1tsXS5ib3VuZGluZ0JveDtjb25zdCBCPXRoaXMubWVzaERhdGE7aWYoQil7Y29uc3Qgdz1CLnBvc2l0aW9uMDtpZih3Lmxlbmd0aClCLmJvdW5kaW5nQm94PWgoKSh3KTtlbHNlIHJldHVybltbMCwwXSxbMCwwXV07cmV0dXJuIEIuYm91bmRpbmdCb3h9cmV0dXJuW1swLDBdLFswLDBdXX1nZXQgYm91bmRpbmdDZW50ZXIoKXtjb25zdCBCPXRoaXMuYm91bmRpbmdCb3g7cmV0dXJuIEI/Wy41KihCWzBdWzBdK0JbMV1bMF0pLC41KihCWzBdWzFdK0JbMV1bMV0pXTpbMCwwXX1nZXQgZmlsbFJ1bGUoKXtyZXR1cm4gdGhpc1tiXT90aGlzW2JdLnJ1bGU6Im5vbnplcm8ifWdldCBsaW5lV2lkdGgoKXtyZXR1cm4gdGhpc1tUXT90aGlzW1RdLmxpbmVXaWR0aDowfWdldCBsaW5lQ2FwKCl7cmV0dXJuIHRoaXNbVF0/dGhpc1tUXS5saW5lQ2FwOiIifWdldCBsaW5lSm9pbigpe3JldHVybiB0aGlzW1RdP3RoaXNbVF0ubGluZUpvaW46IiJ9Z2V0IG1pdGVyTGltaXQoKXtyZXR1cm4gdGhpc1tUXT90aGlzW1RdLm1pdGVyTGltaXQ6MH1nZXQgc3Ryb2tlU3R5bGUoKXtyZXR1cm4gdGhpc1tJXSYmdGhpc1tJXVszXSE9PTA/T2JqZWN0KGEuZGVmYXVsdCkodGhpc1tJXSk6IiJ9Z2V0IGxpbmVEYXNoKCl7cmV0dXJuIHRoaXNbVF0/dGhpc1tUXS5saW5lRGFzaDpudWxsfWdldCBsaW5lRGFzaE9mZnNldCgpe3JldHVybiB0aGlzW1RdP3RoaXNbVF0ubGluZURhc2hPZmZzZXQ6MH1nZXQgZmlsbFN0eWxlKCl7cmV0dXJuIHRoaXNbUF0mJnRoaXNbUF1bM10hPT0wP09iamVjdChhLmRlZmF1bHQpKHRoaXNbUF0pOiIifWdldCBncmFkaWVudCgpe3JldHVybiB0aGlzW0ZdfWdldCB0ZXh0dXJlKCl7cmV0dXJuIHRoaXNbUl0udV90ZXhTYW1wbGVyP3tpbWFnZTp0aGlzW1JdLnVfdGV4U2FtcGxlci5faW1nLG9wdGlvbnM6dGhpc1tBXX06bnVsbH1nZXQgZW5hYmxlQmxlbmQoKXtyZXR1cm4gdGhpc1tqXT09PSEwfHx0aGlzW2pdPT09ITE/dGhpc1tqXTp0aGlzW0pdPDF8fHRoaXNbSV0hPW51bGwmJnRoaXNbSV1bM108MXx8dGhpc1tQXSE9bnVsbCYmdGhpc1tQXVszXTwxfHx0aGlzW1JdLnVfY29sb3JNYXRyaXghPW51bGwmJnRoaXNbUl0udV9jb2xvck1hdHJpeFsxOF08MXx8dGhpc1tSXS51X3JhZGlhbEdyYWRpZW50VmVjdG9yIT1udWxsfHx0aGlzLmJlZm9yZVJlbmRlcnx8dGhpcy5hZnRlclJlbmRlcn1nZXQgZmlsdGVyQ2FudmFzKCl7cmV0dXJuL2JsdXJ8ZHJvcC1zaGFkb3d8dXJsLy50ZXN0KHRoaXMuZmlsdGVyKX1nZXQgZmlsdGVyKCl7cmV0dXJuIHRoaXNbJF0uam9pbigiICIpfWdldCB0cmFuc2Zvcm1NYXRyaXgoKXtyZXR1cm4gdGhpc1tMXX1nZXQgaW52ZXJ0TWF0cml4KCl7aWYoIXRoaXNbRF0pe2NvbnN0IEI9ci5tYXQyZC5pbnZlcnQoQXJyYXkub2YoMCwwLDAsMCwwLDApLHRoaXNbTF0pO3RoaXNbRF09Qn1yZXR1cm4gdGhpc1tEXX1nZXQgdHJhbnNmb3JtU2NhbGUoKXtjb25zdCBCPXRoaXNbTF07cmV0dXJuIE1hdGgubWF4KE1hdGguaHlwb3QoQlswXSxCWzFdKSxNYXRoLmh5cG90KEJbMl0sQlszXSkpfWdldCB1bmlmb3Jtcygpe3JldHVybiB0aGlzW1JdfWdldCBwYXNzKCl7cmV0dXJuIHRoaXNbc3RdfVtxXShCKXtjb25zdCB3PXRoaXNbX10sZD10aGlzW2xdLnBvc2l0aW9uMCxPPU9iamVjdC5lbnRyaWVzKEIuX2F0dHJpYnV0ZSk7Zm9yKGxldCBOPTA7TjxPLmxlbmd0aDtOKyspe2NvbnN0W3osS109T1tOXTtpZih6IT09ImFfY29sb3IiJiZ6IT09ImFfc291cmNlUmVjdCImJkshPT0iaWdub3JlZCIpe2NvbnN0IFk9d1t6XTtpZih6PT09InV2IiYmIVkpe2NvbnN0IFE9dGhpc1tsXS5ib3VuZGluZ0JveHx8aCgpKGQpO3RoaXNbbF0uYXR0cmlidXRlc1t6XT1mdChRLGQpfWVsc2V7dGhpc1tsXS5hdHRyaWJ1dGVzW3pdPVtdO2ZvcihsZXQgUT0wO1E8ZC5sZW5ndGg7USsrKXtjb25zdCBldD1kW1FdO3RoaXNbbF0uYXR0cmlidXRlc1t6XS5wdXNoKFk/WShldCxOLGQpOkFycmF5KEsuc2l6ZSkuZmlsbCgwKSl9fX19fWdldCBtZXNoRGF0YSgpe2lmKHRoaXMuX3VwZGF0ZU1hdHJpeCYmdGhpcy50cmFuc2Zvcm1TY2FsZS90aGlzLmNvbnRvdXJzLnNjYWxlPjEuNSYmdGhpcy5hY2N1cmF0ZSh0aGlzLnRyYW5zZm9ybVNjYWxlKSwhdGhpc1tsXSl7IXRoaXNbYl0mJiF0aGlzW1RdJiZ0aGlzLnNldEZpbGwoKTtjb25zdCBCPXRoaXNbRV0sdz17fTtpZihCJiZCLmxlbmd0aCl7aWYodGhpc1tiXSl0cnl7Y29uc3QgTj1wKCkoQix0aGlzW2JdKTtOLnBvc2l0aW9ucz1OLnBvc2l0aW9ucy5tYXAoej0+KHoucHVzaCh0aGlzW0pdKSx6KSksTi5hdHRyaWJ1dGVzPXthX2NvbG9yOkFycmF5LmZyb20oe2xlbmd0aDpOLnBvc2l0aW9ucy5sZW5ndGh9KS5tYXAoKCk9PnRoaXNbUF0ubWFwKHo9Pk1hdGgucm91bmQoMjU1KnopKSl9LHcuZmlsbD1OfWNhdGNoe31pZih0aGlzW1RdKXtjb25zdCBOPXRoaXNbVF0ubGluZURhc2g7bGV0IHo9QjtpZihOKXtjb25zdCBZPXRoaXNbVF0ubGluZURhc2hPZmZzZXQ7ej1PYmplY3QoZi5nZXREYXNoQ29udG91cnMpKEIsTixZKX1jb25zdCBLPXoubWFwKChZLFEpPT57Y29uc3QgZXQ9WS5sZW5ndGg+MSYmci52ZWMyLmVxdWFscyhZWzBdLFlbWS5sZW5ndGgtMV0pLHJ0PXRoaXNbVF0uYnVpbGQoWSxldCk7cmV0dXJuIHAoKShbcnRdKX0pO0suZm9yRWFjaChZPT57WS5wb3NpdGlvbnM9WS5wb3NpdGlvbnMubWFwKFE9PihRLnB1c2goLXRoaXNbSl0pLFEpKSxZLmF0dHJpYnV0ZXM9e2FfY29sb3I6QXJyYXkuZnJvbSh7bGVuZ3RoOlkucG9zaXRpb25zLmxlbmd0aH0pLm1hcCgoKT0+dGhpc1tJXS5tYXAoUT0+TWF0aC5yb3VuZCgyNTUqUSkpKX19KSx3LnN0cm9rZT1PYmplY3QodS5kZWZhdWx0KShLKX19Y29uc3QgZD1PYmplY3QodS5kZWZhdWx0KShbdy5maWxsLHcuc3Ryb2tlXSk7ZC5maWxsUG9pbnRDb3VudD13LmZpbGw/dy5maWxsLnBvc2l0aW9ucy5sZW5ndGg6MCxkLmVuYWJsZUJsZW5kPXRoaXMuZW5hYmxlQmxlbmQsZC5wb3NpdGlvbjA9ZC5wb3NpdGlvbnMubWFwKChbTix6LEtdKT0+W04seixLXSksZC51bmlmb3Jtcz10aGlzW1JdLHRoaXNbbF09ZCx0aGlzW1JdLnVfdGV4U2FtcGxlciYmdGhpc1tHXShkLHRoaXNbQV0pO2NvbnN0IE89dGhpc1tMXTtPYmplY3QoeC5pc1VuaXRUcmFuc2Zvcm0pKE8pfHwodGhpc1tIXShkLE8pLHRoaXNbUl0udV9yYWRpYWxHcmFkaWVudFZlY3RvciYmdGhpc1taXSgpKSx0aGlzLmNsaXBQYXRoJiZ0aGlzW2N0XSgpLHRoaXNbdHRdJiZ0aGlzW3FdKHRoaXNbdHRdKX1yZXR1cm4gdGhpcy5fdXBkYXRlTWF0cml4JiYodGhpc1tsXS5tYXRyaXg9dGhpc1tMXSx0aGlzW0hdKHRoaXNbbF0sdGhpc1tMXSksdGhpc1tSXS51X3JhZGlhbEdyYWRpZW50VmVjdG9yJiZ0aGlzW1pdKCkpLHRoaXNbbF19W0hdKEIsdyl7Y29uc3R7cG9zaXRpb25zOmQscG9zaXRpb24wOk99PUI7Zm9yKGxldCBOPTA7TjxkLmxlbmd0aDtOKyspe2NvbnN0W3osS109T1tOXSxZPWRbTl07WVswXT16KndbMF0rSyp3WzJdK3dbNF0sWVsxXT16KndbMV0rSyp3WzNdK3dbNV19dGhpcy5fdXBkYXRlTWF0cml4PSExfVtaXSgpe2NvbnN0IEI9dGhpc1tMXSx3PVsuLi50aGlzLl9yYWRpYWxHcmFkaWVudFZlY3Rvcl07aWYodyl7Y29uc3RbZCxPLCxOLHpdPXc7d1swXT1kKkJbMF0rTypCWzJdK0JbNF0sd1sxXT1kKkJbMV0rTypCWzNdK0JbNV0sd1szXT1OKkJbMF0reipCWzJdK0JbNF0sd1s0XT1OKkJbMV0reipCWzNdK0JbNV0sdGhpc1tSXS51X3JhZGlhbEdyYWRpZW50VmVjdG9yPXd9fVtHXShCLHcpe2Z1bmN0aW9uIGQoUSxldCl7cmV0dXJuIFE9PW51bGwmJmV0PT1udWxsPyEwOlE9PW51bGx8fGV0PT1udWxsPyExOlFbMF09PT1ldFswXSYmUVsxXT09PWV0WzFdJiZRWzJdPT09ZXRbMl0mJlFbM109PT1ldFszXX1jb25zdCBPPXRoaXNbUl0udV90ZXhTYW1wbGVyO2lmKCFPKXJldHVybjtjb25zdHt3aWR0aDpOLGhlaWdodDp6fT1PLl9pbWcsSz13LnNyY1JlY3Q7bGV0IFk9dy5yZWN0fHxbMCwwXTtpZih3LnJvdGF0ZWQmJihZPVstWVsxXSxZWzBdLFlbM10sWVsyXV0pLFlbMl09PW51bGwmJihZWzJdPUs/S1syXTpOKSxZWzNdPT1udWxsJiYoWVszXT1LP0tbM106eiksdy5oaWRkZW4pQi50ZXh0dXJlQ29vcmQ9Qi5wb3NpdGlvbnMubWFwKCgpPT5bLTEsLTEsLTFdKTtlbHNlIGlmKCFCLnRleHR1cmVDb29yZHx8IWQodGhpc1tBXS5yZWN0LHcucmVjdCl8fHRoaXNbQV0uaGlkZGVuIT09dy5oaWRkZW58fHRoaXNbQV0ucm90YXRlZCE9PXcucm90YXRlZCl7bGV0IFE9bnVsbDt3LnJvdGF0ZWQmJihRPXIubWF0MmQucm90YXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxyLm1hdDJkLmZyb21WYWx1ZXMoMSwwLDAsMSwwLDApLC41Kk1hdGguUEkpLFE9ci5tYXQyZC50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDApLFEsWzAsLVlbMl1dKSksQi50ZXh0dXJlQ29vcmQ9Qi5wb3NpdGlvbjAubWFwKChbZXQscnQsb3RdKT0+e2lmKDEvb3Q+MCl7aWYody5yb3RhdGVkKXtjb25zdCBpdD1ldCpRWzBdK3J0KlFbMl0rUVs0XSxudD1ldCpRWzFdK3J0KlFbM10rUVs1XTtbZXQscnRdPVtpdCxudF19Y29uc3QgbHQ9VyhbZXQscnRdLFtZWzBdL1lbMl0sWVsxXS9ZWzNdLFlbMl0sWVszXV0sdyk7cmV0dXJuIHcucmVwZWF0JiYobHRbMl09MSksbHR9cmV0dXJuWy0xLC0xLC0xXX0pfWlmKEspe2NvbnN0IFE9W0tbMF0vTixLWzFdL3osS1syXS9OLEtbM10vel07Qi5hdHRyaWJ1dGVzLmFfc291cmNlUmVjdD1CLnBvc2l0aW9ucy5tYXAoKCk9PlsuLi5RXSl9ZWxzZSBCLmF0dHJpYnV0ZXMuYV9zb3VyY2VSZWN0PUIucG9zaXRpb25zLm1hcCgoKT0+WzAsMCwwLDBdKX1hY2N1cmF0ZShCKXtpZighdGhpcy5jb250b3VycylyZXR1cm47aWYodGhpcy5jb250b3Vycy5wYXRoKXtjb25zdCBkPXRoaXMuY29udG91cnMuc2ltcGxpZnksTz1VKHRoaXMuY29udG91cnMucGF0aCwyKkIsZCk7dGhpc1tsXT1udWxsLHRoaXNbRV09T319Y2FuSWdub3JlKCl7Y29uc3QgQj10aGlzW1RdPT1udWxsfHx0aGlzW1RdLmxpbmVXaWR0aD09PTB8fHRoaXNbSV1bM109PT0wLHc9dGhpc1tiXT09bnVsbHx8dGhpc1tQXVszXT09PTAsZD10aGlzW1JdLnVfcmFkaWFsR3JhZGllbnRWZWN0b3I9PW51bGwsTz10aGlzW1JdLnVfdGV4U2FtcGxlcj09bnVsbDtyZXR1cm4gdGhpc1tKXT09PTB8fHRoaXNbdHRdPT1udWxsJiZCJiZ3JiZkJiZPJiYhdGhpcy5iZWZvcmVSZW5kZXImJiF0aGlzLmFmdGVyUmVuZGVyfXNldFN0cm9rZSh7dGhpY2tuZXNzOkI9MSxjYXA6dz0iYnV0dCIsam9pbjpkPSJtaXRlciIsbWl0ZXJMaW1pdDpPPTEwLGNvbG9yOk49WzAsMCwwLDBdLGxpbmVEYXNoOno9bnVsbCxsaW5lRGFzaE9mZnNldDpLPTAscm91bmRTZWdtZW50czpZPTIwfT17fSl7cmV0dXJuIHRoaXNbbF09bnVsbCx0aGlzW1RdPW5ldyBnLmRlZmF1bHQoe2xpbmVXaWR0aDpCLGxpbmVDYXA6dyxsaW5lSm9pbjpkLG1pdGVyTGltaXQ6Tyxyb3VuZFNlZ21lbnRzOll9KSx0eXBlb2YgTj09InN0cmluZyImJihOPU9iamVjdChtLmRlZmF1bHQpKE4pKSx0aGlzW0ldPU4sdGhpc1tUXS5saW5lRGFzaD16LHRoaXNbVF0ubGluZURhc2hPZmZzZXQ9Syx0aGlzfXNldEZpbGwoe3J1bGU6Qj10aGlzLmZpbGxSdWxlLGNvbG9yOnc9WzAsMCwwLDBdfT17fSl7cmV0dXJuIHRoaXNbbF09bnVsbCx0aGlzW2JdPXtydWxlOkJ9LHR5cGVvZiB3PT0ic3RyaW5nIiYmKHc9T2JqZWN0KG0uZGVmYXVsdCkodykpLHRoaXNbUF09dyx0aGlzfXNldFRleHR1cmUoQix3PXt9KXtpZihCJiZCLmltYWdlKXtjb25zdHtpbWFnZTpkLHJlY3Q6T309QjtpZihCPWQsdy5yZWN0KWZvcihsZXQgTj0wO048dy5yZWN0Lmxlbmd0aDtOKyspT1tOXT13LnJlY3RbTl07dy5yZWN0PU99cmV0dXJuIHRoaXNbYl18fHRoaXMuc2V0RmlsbCgpLHRoaXMuc2V0VW5pZm9ybXMoe3VfdGV4U2FtcGxlcjpCfSksdGhpc1tsXSYmdGhpc1tHXSh0aGlzW2xdLHcpLHRoaXNbQV09dyx0aGlzfXNldENpcmN1bGFyR3JhZGllbnQoe3ZlY3RvcjpCLGNvbG9yczp3LHR5cGU6ZD0iZmlsbCJ9PXt9KXtpZihCLmxlbmd0aCE9PTMpdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCBsaW5lYXJHcmFkaWVudC4iKTt0aGlzLnNldEdyYWRpZW50KHt2ZWN0b3I6Qixjb2xvcnM6dyx0eXBlOmR9KX1zZXRMaW5lYXJHcmFkaWVudCh7dmVjdG9yOkIsY29sb3JzOncsdHlwZTpkPSJmaWxsIn09e30pe2lmKEIubGVuZ3RoIT09NCl0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIGxpbmVhckdyYWRpZW50LiIpO3RoaXMuc2V0R3JhZGllbnQoe3ZlY3RvcjpCLGNvbG9yczp3LHR5cGU6ZH0pfXNldFJhZGlhbEdyYWRpZW50KHt2ZWN0b3I6Qixjb2xvcnM6dyx0eXBlOmQ9ImZpbGwifT17fSl7aWYoQi5sZW5ndGghPT02KXRocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgcmFkaWFsR3JhZGllbnQuIik7dGhpcy5zZXRHcmFkaWVudCh7dmVjdG9yOkIsY29sb3JzOncsdHlwZTpkfSl9c2V0R3JhZGllbnQoe3ZlY3RvcjpCLGNvbG9yczp3LHR5cGU6ZD0iZmlsbCJ9PXt9KXt3PXcubWFwKCh7b2Zmc2V0OnosY29sb3I6S30pPT4odHlwZW9mIEs9PSJzdHJpbmciJiYoSz1PYmplY3QobS5kZWZhdWx0KShLKSkse29mZnNldDp6LGNvbG9yOkt9KSksdGhpc1tGXT10aGlzW0ZdfHx7fSx0aGlzW0ZdW2RdPXt2ZWN0b3I6Qixjb2xvcnM6d30sdy5zb3J0KCh6LEspPT56Lm9mZnNldC1LLm9mZnNldCk7Y29uc3QgTz1bXTt3LmZvckVhY2goKHtvZmZzZXQ6eixjb2xvcjpLfSk9PntPLnB1c2goeiwuLi5LKX0pO2xldCBOO2lmKEIubGVuZ3RoPT09ND9OPVtCWzBdLEJbMV0sMCxCWzJdLEJbM10sMF06Tj1bLi4uQl0sTy5sZW5ndGg8NDAmJk8ucHVzaCgtMSksTy5sZW5ndGg+NDApdGhyb3cgbmV3IEVycm9yKCJUb28gbWFueSBjb2xvcnMsIHNob3VsZCBiZSBsZXNzIHRoYW4gOCBjb2xvcnMiKTtyZXR1cm4gdGhpcy5fcmFkaWFsR3JhZGllbnRWZWN0b3I9Tix0aGlzW1JdLnVfY29sb3JTdGVwcz1PLGQ9PT0iZmlsbCI/dGhpc1tSXS51X2dyYWRpZW50VHlwZT0xOnRoaXNbUl0udV9ncmFkaWVudFR5cGU9MCx0aGlzW1pdKCksdGhpc31zZXRVbmlmb3JtcyhCPXt9KXtyZXR1cm4gT2JqZWN0LmFzc2lnbih0aGlzW1JdLEIpLHRoaXN9c2V0VHJhbnNmb3JtKC4uLkIpe2NvbnN0IHc9dGhpc1tMXTtyZXR1cm4gci5tYXQyZC5lcXVhbHMoQix3KXx8KHRoaXNbTF09QixkZWxldGUgdGhpc1tEXSx0aGlzLl91cGRhdGVNYXRyaXg9ITApLHRoaXN9dHJhbnNmb3JtKC4uLkIpe2NvbnN0IHc9dGhpc1tMXTtyZXR1cm4gdGhpc1tMXT1yLm1hdDJkLm11bHRpcGx5KEFycmF5Lm9mKDAsMCwwLDAsMCwwKSx3LEIpLGRlbGV0ZSB0aGlzW0RdLHRoaXMuX3VwZGF0ZU1hdHJpeD0hMCx0aGlzfXRyYW5zbGF0ZShCLHcpe2xldCBkPXIubWF0MmQuY3JlYXRlKCk7cmV0dXJuIGQ9ci5tYXQyZC50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDApLGQsW0Isd10pLHRoaXMudHJhbnNmb3JtKC4uLmQpfXJvdGF0ZShCLFt3LGRdPVswLDBdKXtsZXQgTz1yLm1hdDJkLmNyZWF0ZSgpO3JldHVybiBPPXIubWF0MmQudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxPLFt3LGRdKSxPPXIubWF0MmQucm90YXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxPLEIpLE89ci5tYXQyZC50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDApLE8sWy13LC1kXSksdGhpcy50cmFuc2Zvcm0oLi4uTyl9c2NhbGUoQix3PUIsW2QsT109WzAsMF0pe2xldCBOPXIubWF0MmQuY3JlYXRlKCk7cmV0dXJuIE49ci5tYXQyZC50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDApLE4sW2QsT10pLE49ci5tYXQyZC5zY2FsZShBcnJheS5vZigwLDAsMCwwLDAsMCksTixbQix3XSksTj1yLm1hdDJkLnRyYW5zbGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCksTixbLWQsLU9dKSx0aGlzLnRyYW5zZm9ybSguLi5OKX1za2V3KEIsdz1CLFtkLE9dPVswLDBdKXtsZXQgTj1yLm1hdDJkLmNyZWF0ZSgpO3JldHVybiBOPXIubWF0MmQudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxOLFtkLE9dKSxOPXIubWF0MmQubXVsdGlwbHkoQXJyYXkub2YoMCwwLDAsMCwwLDApLE4sci5tYXQyZC5mcm9tVmFsdWVzKDEsTWF0aC50YW4odyksTWF0aC50YW4oQiksMSwwLDApKSxOPXIubWF0MmQudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxOLFstZCwtT10pLHRoaXMudHJhbnNmb3JtKC4uLk4pfWNsZWFyRmlsdGVyKCl7cmV0dXJuIHRoaXMuc2V0Q29sb3JUcmFuc2Zvcm0obnVsbCksdGhpc1skXS5sZW5ndGg9MCx0aGlzfXNldENvbG9yVHJhbnNmb3JtKC4uLkIpe3JldHVybiBCWzBdPT09bnVsbD90aGlzLnNldFVuaWZvcm1zKHt1X2ZpbHRlckZsYWc6MCx1X2NvbG9yTWF0cml4OjB9KTp0aGlzLnNldFVuaWZvcm1zKHt1X2ZpbHRlckZsYWc6MSx1X2NvbG9yTWF0cml4OkJ9KSx0aGlzfXRyYW5zZm9ybUNvbG9yKC4uLkIpe2xldCB3PXRoaXMudW5pZm9ybXMudV9jb2xvck1hdHJpeDtyZXR1cm4gdz93PU9iamVjdChjLm11bHRpcGx5KSh3LEIpOnc9Qix0aGlzLnNldENvbG9yVHJhbnNmb3JtKC4uLncpLHRoaXN9Ymx1cihCKXtyZXR1cm4gdGhpc1skXS5wdXNoKGBibHVyKCR7Qn1weClgKSx0aGlzfWJyaWdodG5lc3MoQj0xKXtyZXR1cm4gdGhpc1skXS5wdXNoKGBicmlnaHRuZXNzKCR7MTAwKkJ9JSlgKSx0aGlzLnRyYW5zZm9ybUNvbG9yKC4uLk9iamVjdChjLmJyaWdodG5lc3MpKEIpKX1jb250cmFzdChCPTEpe3JldHVybiB0aGlzWyRdLnB1c2goYGNvbnRyYXN0KCR7MTAwKkJ9JSlgKSx0aGlzLnRyYW5zZm9ybUNvbG9yKC4uLk9iamVjdChjLmNvbnRyYXN0KShCKSl9ZHJvcFNoYWRvdyhCLHcsZD0wLE89WzAsMCwwLDFdKXtyZXR1cm4gQXJyYXkuaXNBcnJheShPKSYmKE89T2JqZWN0KGEuZGVmYXVsdCkoTykpLHRoaXNbJF0ucHVzaChgZHJvcC1zaGFkb3coJHtCfXB4ICR7d31weCAke2R9cHggJHtPfSlgKSx0aGlzfWdyYXlzY2FsZShCPTEpe3JldHVybiB0aGlzWyRdLnB1c2goYGdyYXlzY2FsZSgkezEwMCpCfSUpYCksdGhpcy50cmFuc2Zvcm1Db2xvciguLi5PYmplY3QoYy5ncmF5c2NhbGUpKEIpKX1odWVSb3RhdGUoQj0wKXtyZXR1cm4gdGhpc1skXS5wdXNoKGBodWUtcm90YXRlKCR7Qn1kZWcpYCksdGhpcy50cmFuc2Zvcm1Db2xvciguLi5PYmplY3QoYy5odWVSb3RhdGUpKEIpKX1pbnZlcnQoQj0xKXtyZXR1cm4gdGhpc1skXS5wdXNoKGBpbnZlcnQoJHsxMDAqQn0lKWApLHRoaXMudHJhbnNmb3JtQ29sb3IoLi4uT2JqZWN0KGMuaW52ZXJ0KShCKSl9b3BhY2l0eShCPTEpe3JldHVybiB0aGlzWyRdLnB1c2goYG9wYWNpdHkoJHsxMDAqQn0lKWApLHRoaXMudHJhbnNmb3JtQ29sb3IoLi4uT2JqZWN0KGMub3BhY2l0eSkoQikpfXNhdHVyYXRlKEI9MSl7cmV0dXJuIHRoaXNbJF0ucHVzaChgc2F0dXJhdGUoJHsxMDAqQn0lKWApLHRoaXMudHJhbnNmb3JtQ29sb3IoLi4uT2JqZWN0KGMuc2F0dXJhdGUpKEIpKX1zZXBpYShCPTEpe3JldHVybiB0aGlzWyRdLnB1c2goYHNlcGlhKCR7MTAwKkJ9JSlgKSx0aGlzLnRyYW5zZm9ybUNvbG9yKC4uLk9iamVjdChjLnNlcGlhKShCKSl9dXJsKEIpe3JldHVybiB0aGlzWyRdLnB1c2goYHVybCgke0J9KWApLHRoaXN9aXNQb2ludENvbGxpc2lvbihCLHcsZD0iYm90aCIpe2NvbnN0IE89dGhpcy5tZXNoRGF0YSx7cG9zaXRpb25zOk4sY2VsbHM6en09TyxLPXRoaXMuaW52ZXJ0TWF0cml4LFk9S1swXSpCK0tbMl0qdytLWzRdLFE9S1sxXSpCK0tbM10qdytLWzVdLGV0PXRoaXMuYm91bmRpbmdCb3g7aWYoWTxldFswXVswXXx8WT5ldFsxXVswXXx8UTxldFswXVsxXXx8UT5ldFsxXVsxXSlyZXR1cm4hMTtmdW5jdGlvbiBydChbb3QsbHRdLFtpdCxudF0sW2F0LGR0XSl7Y29uc3QgZ3Q9YXQtaXQsdXQ9ZHQtbnQsbXQ9KChvdC1pdCkqZ3QrKGx0LW50KSp1dCkvKGd0KioyK3V0KioyKTtyZXR1cm4gbXQ+PTAmJm10PD0xfWZvcihsZXQgb3Q9MDtvdDx6Lmxlbmd0aDtvdCsrKXtjb25zdCBsdD16W290XTtpZihkPT09ImZpbGwiJiZsdFswXT49Ty5maWxsUG9pbnRDb3VudClicmVhaztpZihkPT09InN0cm9rZSImJmx0WzBdPE8uZmlsbFBvaW50Q291bnQpY29udGludWU7Y29uc3RbW2l0LG50XSxbYXQsZHRdLFtndCx1dF1dPWx0Lm1hcChNdD0+TltNdF0pLG10PU1hdGguc2lnbigoQi1pdCkqKGR0LW50KS0oYXQtaXQpKih3LW50KSk7aWYobXQ9PT0wJiZydChbQix3XSxbaXQsbnRdLFthdCxkdF0pKXJldHVybiEwO2NvbnN0IFR0PU1hdGguc2lnbigoQi1hdCkqKHV0LWR0KS0oZ3QtYXQpKih3LWR0KSk7aWYoVHQ9PT0wJiZydChbQix3XSxbYXQsZHRdLFtndCx1dF0pKXJldHVybiEwO2NvbnN0IHh0PU1hdGguc2lnbigoQi1ndCkqKG50LXV0KS0oaXQtZ3QpKih3LXV0KSk7aWYoeHQ9PT0wJiZydChbQix3XSxbZ3QsdXRdLFtpdCxudF0pfHxtdD09PTEmJlR0PT09MSYmeHQ9PT0xfHxtdD09PS0xJiZUdD09PS0xJiZ4dD09PS0xKXJldHVybiEwfXJldHVybiExfWlzUG9pbnRJbkZpbGwoQix3KXtyZXR1cm4gdGhpcy5pc1BvaW50Q29sbGlzaW9uKEIsdywiZmlsbCIpfWlzUG9pbnRJblN0cm9rZShCLHcpe3JldHVybiB0aGlzLmlzUG9pbnRDb2xsaXNpb24oQix3LCJzdHJva2UiKX1hZGRQYXNzKEIsdz17fSl7bGV0e3dpZHRoOmQsaGVpZ2h0Ok99PXcsTj1vKHcsWyJ3aWR0aCIsImhlaWdodCJdKTtjb25zdCB6PW5ldyB5LmRlZmF1bHQ7ei5yZWN0KDAsMCxkLE8pO2NvbnN0IEs9bmV3IFYoeix7d2lkdGg6ZCxoZWlnaHQ6T30pO0suc2V0VW5pZm9ybXMoTiksSy5zZXRQcm9ncmFtKEIpLHRoaXNbc3RdLnB1c2goSyl9fX0sZnVuY3Rpb24oUyxlLHQpe3QucihlKTt2YXIgcj10KDU4KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSksZS5kZWZhdWx0PXIuU3Ryb2tlfSxmdW5jdGlvbihTLGUsdCl7dC5yKGUpLHQuZChlLCJTdHJva2UiLGZ1bmN0aW9uKCl7cmV0dXJuIHh9KTt2YXIgcj10KDQ5KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3QgaT1PYmplY3Qoci5jcmVhdGUpKCksaD1PYmplY3Qoci5jcmVhdGUpKCksZz1PYmplY3Qoci5jcmVhdGUpKCksdT1PYmplY3Qoci5jcmVhdGUpKCksYT1PYmplY3Qoci5jcmVhdGUpKCksYz0xZTIwO2NsYXNzIHh7Y29uc3RydWN0b3Ioe2xpbmVXaWR0aDpNPTEsbGluZUpvaW46bT0ibWl0ZXIiLG1pdGVyTGltaXQ6eT0xMCxsaW5lQ2FwOm49ImJ1dHQiLHJvdW5kU2VnbWVudHM6bz0yMH09e30pe3RoaXMubGluZVdpZHRoPU0sdGhpcy5saW5lSm9pbj1tLHRoaXMubWl0ZXJMaW1pdD15LHRoaXMubGluZUNhcD1uLHRoaXMucm91bmRTZWdtZW50cz1vLHRoaXMuX25vcm1hbD1udWxsfWJ1aWxkKE0sbT0hMSl7bGV0IHk9TS5sZW5ndGg7aWYoTT1bLi4uTV0seTwyKXJldHVybiBNO20mJigoTVswXVswXSE9PU1beS0xXVswXXx8TVswXVsxXSE9PU1beS0xXVsxXSkmJk0ucHVzaChbLi4uTVswXV0pLE0ucHVzaChbLi4uTVsxXV0pKSx5PU0ubGVuZ3RoLHRoaXMuX25vcm1hbD1udWxsO2NvbnN0IG49e2xlZnQ6W10scmlnaHQ6W119LG89dGhpcy5saW5lV2lkdGgvMixzPXRoaXMubGluZUNhcDtpZighbSYmcz09PSJzcXVhcmUiKXtPYmplY3Qoci5kaXJlY3Rpb24pKGgsTVswXSxNWzFdKSxPYmplY3Qoci5zY2FsZUFuZEFkZCkoTVswXSxNWzBdLGgsbyk7Y29uc3QgRT1NLmxlbmd0aC0xO09iamVjdChyLmRpcmVjdGlvbikoaCxNW0VdLE1bRS0xXSksT2JqZWN0KHIuc2NhbGVBbmRBZGQpKE1bRV0sTVtFXSxoLG8pfWZvcihsZXQgRT0xO0U8eTtFKyspe2NvbnN0IFQ9TVtFLTFdLGI9TVtFXSxJPU1bRSsxXTt0aGlzLl9zZWcobixULGIsSSxvLG0pfXJldHVybiFtJiZzPT09InJvdW5kIiYmcChuLHRoaXMucm91bmRTZWdtZW50cyksWy4uLm4ubGVmdCwuLi5uLnJpZ2h0LnJldmVyc2UoKV19X3NlZyhNLG0seSxuLG8scyl7Y29uc3QgbD10aGlzLmxpbmVKb2luPT09ImJldmVsIixFPXRoaXMubGluZUpvaW49PT0icm91bmQiO2lmKE9iamVjdChyLmRpcmVjdGlvbikoaCx5LG0pLHRoaXMuX25vcm1hbHx8KHRoaXMuX25vcm1hbD1PYmplY3Qoci5jcmVhdGUpKCksT2JqZWN0KHIubm9ybWFsKSh0aGlzLl9ub3JtYWwsaCkpLE0ubGVmdC5sZW5ndGh8fHYoTSxtLHRoaXMuX25vcm1hbCxvKSwhbilPYmplY3Qoci5ub3JtYWwpKHRoaXMuX25vcm1hbCxoKSxzP3YoTSxtLHRoaXMuX25vcm1hbCxvKTp2KE0seSx0aGlzLl9ub3JtYWwsbyk7ZWxzZXtPYmplY3Qoci5kaXJlY3Rpb24pKGcsbix5KTtsZXQgVD1PYmplY3Qoci5jb21wdXRlTWl0ZXIpKHUsYSxoLGcsbyk7VD1NYXRoLm1pbihULGMpO2NvbnN0IGI9T2JqZWN0KHIuZG90KSh1LHRoaXMuX25vcm1hbCk8MD8tMToxO2xldCBJPWx8fEU7aWYoIUkmJnRoaXMubGluZUpvaW49PT0ibWl0ZXIiJiZUL28+dGhpcy5taXRlckxpbWl0JiYoST0hMCksSSl7T2JqZWN0KHIuc2NhbGVBbmRBZGQpKGkseSx0aGlzLl9ub3JtYWwsLW8qYiksZihNLGksYik7bGV0IFA9MS8wO20mJihQPU1hdGgubWluKFAsTWF0aC5oeXBvdCh5WzBdLW1bMF0seVsxXS1tWzFdKSkpLG4mJihQPU1hdGgubWluKFAsTWF0aC5oeXBvdChuWzBdLXlbMF0sblsxXS15WzFdKSkpO2NvbnN0IEw9TWF0aC5tYXgobyxNYXRoLm1pbihULFApKTtpZihPYmplY3Qoci5zY2FsZUFuZEFkZCkoaSx5LGEsTCpiKSxmKE0saSwtYiksbilpZihPYmplY3Qoci5ub3JtYWwpKGksZyksT2JqZWN0KHIuY29weSkodGhpcy5fbm9ybWFsLGkpLE9iamVjdChyLnNjYWxlQW5kQWRkKShpLHksaSwtbypiKSxFKXtjb25zdCBEPU9iamVjdChyLmNsb25lKShpKSxSPWI+MD9NLmxlZnRbTS5sZWZ0Lmxlbmd0aC0xXTpNLnJpZ2h0W00ucmlnaHQubGVuZ3RoLTFdLEE9T2JqZWN0KHIuY2xvbmUpKHkpLGo9T2JqZWN0KHIuc3ViKShPYmplY3Qoci5jcmVhdGUpKCksUixBKSxHPU9iamVjdChyLnN1YikoT2JqZWN0KHIuY3JlYXRlKSgpLEQsQSksSD1NYXRoLlBJL3RoaXMucm91bmRTZWdtZW50cztmb3IobGV0IFo9MDtaPHRoaXMucm91bmRTZWdtZW50cyYmKE9iamVjdChyLnJvdGF0ZSkoaixqLFswLDBdLGIqSCksTWF0aC5zaWduKE9iamVjdChyLmNyb3NzKShpLGosRylbMl0pPT09Yik7WisrKU9iamVjdChyLmFkZCkoaSxqLEEpLGYoTSxpLGIpO2YoTSxELGIpfWVsc2UgZihNLGksYil9ZWxzZSB2KE0seSxhLFQpLE9iamVjdChyLmNvcHkpKHRoaXMuX25vcm1hbCxhKX19fWZ1bmN0aW9uIGYoQyxNLG0pe20+MD9DLmxlZnQucHVzaChPYmplY3Qoci5jbG9uZSkoTSkpOkMucmlnaHQucHVzaChPYmplY3Qoci5jbG9uZSkoTSkpfWZ1bmN0aW9uIHYoQyxNLG0seSxuPS0xKXtPYmplY3Qoci5zY2FsZUFuZEFkZCkoaSxNLG0sLXkpLGYoQyxpLC1uKSxPYmplY3Qoci5zY2FsZUFuZEFkZCkoaSxNLG0seSksZihDLGksbil9ZnVuY3Rpb24gcCh7bGVmdDpDLHJpZ2h0Ok19LG0pe2NvbnN0IHk9T2JqZWN0KHIuY3JlYXRlKSgpLG49T2JqZWN0KHIuY3JlYXRlKSgpO2xldCBvPUNbMF0scz1NWzBdLGw9Wy41KihvWzBdK3NbMF0pLC41KihvWzFdK3NbMV0pXTtPYmplY3Qoci5zdWIpKG4sbyxsKTtmb3IobGV0IEU9MTtFPD1tO0UrKyl7Y29uc3QgVD0tMSpNYXRoLlBJKkUvbTtPYmplY3Qoci5yb3RhdGUpKHksbixbMCwwXSxUKSxPYmplY3Qoci5hZGQpKGksbCx5KSxDLnVuc2hpZnQoT2JqZWN0KHIuY2xvbmUpKGkpKX1vPU1bTS5sZW5ndGgtMV0scz1DW0MubGVuZ3RoLTFdLGw9Wy41KihvWzBdK3NbMF0pLC41KihvWzFdK3NbMV0pXSxPYmplY3Qoci5zdWIpKG4sbyxsKTtmb3IobGV0IEU9MTtFPD1tO0UrKyl7Y29uc3QgVD0tMSpNYXRoLlBJKkUvbTtPYmplY3Qoci5yb3RhdGUpKHksbixbMCwwXSxUKSxPYmplY3Qoci5hZGQpKGksbCx5KSxNLnB1c2goT2JqZWN0KHIuY2xvbmUpKGkpKX19fSxmdW5jdGlvbihTLGUsdCl7dC5yKGUpLHQuZChlLCJpc1VuaXRUcmFuc2Zvcm0iLGZ1bmN0aW9uKCl7cmV0dXJuIHJ9KSx0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gcihpKXtyZXR1cm4gaVswXT09PTEmJmlbMV09PT0wJiZpWzJdPT09MCYmaVszXT09PTEmJmlbNF09PT0wJiZpWzVdPT09MH19LGZ1bmN0aW9uKFMsZSx0KXt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7dmFyIHI9dCg2MSksaT10KDYyKTtTLmV4cG9ydHM9ZnVuY3Rpb24oaCxnKXtpZihnPWd8fHt9LGg9aC5maWx0ZXIoZnVuY3Rpb24obSl7cmV0dXJuIG0ubGVuZ3RoPjJ9KSxoLmxlbmd0aD09PTApcmV0dXJue3Bvc2l0aW9uczpbXSxjZWxsczpbXX07dHlwZW9mIGcudmVydGV4U2l6ZSE9Im51bWJlciImJihnLnZlcnRleFNpemU9aFswXVswXS5sZW5ndGgpLGg9aC5tYXAoZnVuY3Rpb24obSl7cmV0dXJuIG0ucmVkdWNlKGZ1bmN0aW9uKHksbil7cmV0dXJuIHkuY29uY2F0KG4pfSl9KTtjb25zdCB1PWcucnVsZT09PSJldmVub2RkIj9yLldJTkRJTkdfT0REOnIuV0lORElOR19OT05aRVJPO2Zvcih2YXIgYT1yLnRlc3NlbGF0ZShpKHtjb250b3VyczpoLHdpbmRpbmdSdWxlOnUsZWxlbWVudFR5cGU6ci5QT0xZR09OUyxwb2x5U2l6ZTozLHZlcnRleFNpemU6Mn0sZykpLGM9W10seD0wO3g8YS52ZXJ0aWNlcy5sZW5ndGg7eCs9Zy52ZXJ0ZXhTaXplKXt2YXIgZj1hLnZlcnRpY2VzLnNsaWNlKHgseCtnLnZlcnRleFNpemUpO2MucHVzaChmKX12YXIgdj1bXTtmb3IoeD0wO3g8YS5lbGVtZW50cy5sZW5ndGg7eCs9Myl7dmFyIHA9YS5lbGVtZW50c1t4XSxDPWEuZWxlbWVudHNbeCsxXSxNPWEuZWxlbWVudHNbeCsyXTt2LnB1c2goW3AsQyxNXSl9cmV0dXJue3Bvc2l0aW9uczpjLGNlbGxzOnZ9fX0sZnVuY3Rpb24oUyxlLHQpe3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTt2YXIgcj17fSxpPXt9O1MuZXhwb3J0cz1yLHIuV0lORElOR19PREQ9MCxyLldJTkRJTkdfTk9OWkVSTz0xLHIuV0lORElOR19QT1NJVElWRT0yLHIuV0lORElOR19ORUdBVElWRT0zLHIuV0lORElOR19BQlNfR0VRX1RXTz00LHIuUE9MWUdPTlM9MCxyLkNPTk5FQ1RFRF9QT0xZR09OUz0xLHIuQk9VTkRBUllfQ09OVE9VUlM9MixyLnRlc3NlbGF0ZT1mdW5jdGlvbihuKXtmb3IodmFyIG89bi5kZWJ1Z3x8ITEscz1uZXcgeSxsPTA7bDxuLmNvbnRvdXJzLmxlbmd0aDtsKyspcy5hZGRDb250b3VyKG4udmVydGV4U2l6ZXx8MixuLmNvbnRvdXJzW2xdKTtyZXR1cm4gcy50ZXNzZWxhdGUobi53aW5kaW5nUnVsZXx8ci5XSU5ESU5HX09ERCxuLmVsZW1lbnRUeXBlfHxyLlBPTFlHT05TLG4ucG9seVNpemV8fDMsbi52ZXJ0ZXhTaXplfHwyLG4ubm9ybWFsfHxbMCwwLDFdKSx7dmVydGljZXM6cy52ZXJ0aWNlcyx2ZXJ0ZXhJbmRpY2VzOnMudmVydGV4SW5kaWNlcyx2ZXJ0ZXhDb3VudDpzLnZlcnRleENvdW50LGVsZW1lbnRzOnMuZWxlbWVudHMsZWxlbWVudENvdW50OnMuZWxlbWVudENvdW50LG1lc2g6bz9zLm1lc2g6dm9pZCAwfX07dmFyIGg9ZnVuY3Rpb24obil7aWYoIW4pdGhyb3ciQXNzZXJ0aW9uIEZhaWxlZCEifTtmdW5jdGlvbiBnKCl7dGhpcy5uZXh0PW51bGwsdGhpcy5wcmV2PW51bGwsdGhpcy5hbkVkZ2U9bnVsbCx0aGlzLmNvb3Jkcz1bMCwwLDBdLHRoaXMucz0wLHRoaXMudD0wLHRoaXMucHFIYW5kbGU9MCx0aGlzLm49MCx0aGlzLmlkeD0wfWZ1bmN0aW9uIHUoKXt0aGlzLm5leHQ9bnVsbCx0aGlzLnByZXY9bnVsbCx0aGlzLmFuRWRnZT1udWxsLHRoaXMudHJhaWw9bnVsbCx0aGlzLm49MCx0aGlzLm1hcmtlZD0hMSx0aGlzLmluc2lkZT0hMX1mdW5jdGlvbiBhKG4pe3RoaXMubmV4dD1udWxsLHRoaXMuU3ltPW51bGwsdGhpcy5PbmV4dD1udWxsLHRoaXMuTG5leHQ9bnVsbCx0aGlzLk9yZz1udWxsLHRoaXMuTGZhY2U9bnVsbCx0aGlzLmFjdGl2ZVJlZ2lvbj1udWxsLHRoaXMud2luZGluZz0wLHRoaXMuc2lkZT1ufWEucHJvdG90eXBlPXtnZXQgUmZhY2UoKXtyZXR1cm4gdGhpcy5TeW0uTGZhY2V9LHNldCBSZmFjZShuKXt0aGlzLlN5bS5MZmFjZT1ufSxnZXQgRHN0KCl7cmV0dXJuIHRoaXMuU3ltLk9yZ30sc2V0IERzdChuKXt0aGlzLlN5bS5Pcmc9bn0sZ2V0IE9wcmV2KCl7cmV0dXJuIHRoaXMuU3ltLkxuZXh0fSxzZXQgT3ByZXYobil7dGhpcy5TeW0uTG5leHQ9bn0sZ2V0IExwcmV2KCl7cmV0dXJuIHRoaXMuT25leHQuU3ltfSxzZXQgTHByZXYobil7dGhpcy5PbmV4dC5TeW09bn0sZ2V0IERwcmV2KCl7cmV0dXJuIHRoaXMuTG5leHQuU3ltfSxzZXQgRHByZXYobil7dGhpcy5MbmV4dC5TeW09bn0sZ2V0IFJwcmV2KCl7cmV0dXJuIHRoaXMuU3ltLk9uZXh0fSxzZXQgUnByZXYobil7dGhpcy5TeW0uT25leHQ9bn0sZ2V0IERuZXh0KCl7cmV0dXJuIHRoaXMuU3ltLk9uZXh0LlN5bX0sc2V0IERuZXh0KG4pe3RoaXMuU3ltLk9uZXh0LlN5bT1ufSxnZXQgUm5leHQoKXtyZXR1cm4gdGhpcy5TeW0uTG5leHQuU3ltfSxzZXQgUm5leHQobil7dGhpcy5TeW0uTG5leHQuU3ltPW59fTtmdW5jdGlvbiBjKCl7dmFyIG49bmV3IGcsbz1uZXcgdSxzPW5ldyBhKDApLGw9bmV3IGEoMSk7bi5uZXh0PW4ucHJldj1uLG4uYW5FZGdlPW51bGwsby5uZXh0PW8ucHJldj1vLG8uYW5FZGdlPW51bGwsby50cmFpbD1udWxsLG8ubWFya2VkPSExLG8uaW5zaWRlPSExLHMubmV4dD1zLHMuU3ltPWwscy5PbmV4dD1udWxsLHMuTG5leHQ9bnVsbCxzLk9yZz1udWxsLHMuTGZhY2U9bnVsbCxzLndpbmRpbmc9MCxzLmFjdGl2ZVJlZ2lvbj1udWxsLGwubmV4dD1sLGwuU3ltPXMsbC5PbmV4dD1udWxsLGwuTG5leHQ9bnVsbCxsLk9yZz1udWxsLGwuTGZhY2U9bnVsbCxsLndpbmRpbmc9MCxsLmFjdGl2ZVJlZ2lvbj1udWxsLHRoaXMudkhlYWQ9bix0aGlzLmZIZWFkPW8sdGhpcy5lSGVhZD1zLHRoaXMuZUhlYWRTeW09bH1jLnByb3RvdHlwZT17bWFrZUVkZ2VfOmZ1bmN0aW9uKG4pe3ZhciBvPW5ldyBhKDApLHM9bmV3IGEoMSk7bi5TeW0uc2lkZTxuLnNpZGUmJihuPW4uU3ltKTt2YXIgbD1uLlN5bS5uZXh0O3JldHVybiBzLm5leHQ9bCxsLlN5bS5uZXh0PW8sby5uZXh0PW4sbi5TeW0ubmV4dD1zLG8uU3ltPXMsby5PbmV4dD1vLG8uTG5leHQ9cyxvLk9yZz1udWxsLG8uTGZhY2U9bnVsbCxvLndpbmRpbmc9MCxvLmFjdGl2ZVJlZ2lvbj1udWxsLHMuU3ltPW8scy5PbmV4dD1zLHMuTG5leHQ9byxzLk9yZz1udWxsLHMuTGZhY2U9bnVsbCxzLndpbmRpbmc9MCxzLmFjdGl2ZVJlZ2lvbj1udWxsLG99LHNwbGljZV86ZnVuY3Rpb24obixvKXt2YXIgcz1uLk9uZXh0LGw9by5PbmV4dDtzLlN5bS5MbmV4dD1vLGwuU3ltLkxuZXh0PW4sbi5PbmV4dD1sLG8uT25leHQ9c30sbWFrZVZlcnRleF86ZnVuY3Rpb24obixvLHMpe3ZhciBsPW47aChsIT09bnVsbCk7dmFyIEU9cy5wcmV2O2wucHJldj1FLEUubmV4dD1sLGwubmV4dD1zLHMucHJldj1sLGwuYW5FZGdlPW87dmFyIFQ9bztkbyBULk9yZz1sLFQ9VC5PbmV4dDt3aGlsZShUIT09byl9LG1ha2VGYWNlXzpmdW5jdGlvbihuLG8scyl7dmFyIGw9bjtoKGwhPT1udWxsKTt2YXIgRT1zLnByZXY7bC5wcmV2PUUsRS5uZXh0PWwsbC5uZXh0PXMscy5wcmV2PWwsbC5hbkVkZ2U9byxsLnRyYWlsPW51bGwsbC5tYXJrZWQ9ITEsbC5pbnNpZGU9cy5pbnNpZGU7dmFyIFQ9bztkbyBULkxmYWNlPWwsVD1ULkxuZXh0O3doaWxlKFQhPT1vKX0sa2lsbEVkZ2VfOmZ1bmN0aW9uKG4pe24uU3ltLnNpZGU8bi5zaWRlJiYobj1uLlN5bSk7dmFyIG89bi5uZXh0LHM9bi5TeW0ubmV4dDtvLlN5bS5uZXh0PXMscy5TeW0ubmV4dD1vfSxraWxsVmVydGV4XzpmdW5jdGlvbihuLG8pe3ZhciBzPW4uYW5FZGdlLGw9cztkbyBsLk9yZz1vLGw9bC5PbmV4dDt3aGlsZShsIT09cyk7dmFyIEU9bi5wcmV2LFQ9bi5uZXh0O1QucHJldj1FLEUubmV4dD1UfSxraWxsRmFjZV86ZnVuY3Rpb24obixvKXt2YXIgcz1uLmFuRWRnZSxsPXM7ZG8gbC5MZmFjZT1vLGw9bC5MbmV4dDt3aGlsZShsIT09cyk7dmFyIEU9bi5wcmV2LFQ9bi5uZXh0O1QucHJldj1FLEUubmV4dD1UfSxtYWtlRWRnZTpmdW5jdGlvbigpe3ZhciBuPW5ldyBnLG89bmV3IGcscz1uZXcgdSxsPXRoaXMubWFrZUVkZ2VfKHRoaXMuZUhlYWQpO3JldHVybiB0aGlzLm1ha2VWZXJ0ZXhfKG4sbCx0aGlzLnZIZWFkKSx0aGlzLm1ha2VWZXJ0ZXhfKG8sbC5TeW0sdGhpcy52SGVhZCksdGhpcy5tYWtlRmFjZV8ocyxsLHRoaXMuZkhlYWQpLGx9LHNwbGljZTpmdW5jdGlvbihuLG8pe3ZhciBzPSExLGw9ITE7aWYobiE9PW8pe2lmKG8uT3JnIT09bi5PcmcmJihsPSEwLHRoaXMua2lsbFZlcnRleF8oby5Pcmcsbi5PcmcpKSxvLkxmYWNlIT09bi5MZmFjZSYmKHM9ITAsdGhpcy5raWxsRmFjZV8oby5MZmFjZSxuLkxmYWNlKSksdGhpcy5zcGxpY2VfKG8sbiksIWwpe3ZhciBFPW5ldyBnO3RoaXMubWFrZVZlcnRleF8oRSxvLG4uT3JnKSxuLk9yZy5hbkVkZ2U9bn1pZighcyl7dmFyIFQ9bmV3IHU7dGhpcy5tYWtlRmFjZV8oVCxvLG4uTGZhY2UpLG4uTGZhY2UuYW5FZGdlPW59fX0sZGVsZXRlOmZ1bmN0aW9uKG4pe3ZhciBvPW4uU3ltLHM9ITE7aWYobi5MZmFjZSE9PW4uUmZhY2UmJihzPSEwLHRoaXMua2lsbEZhY2VfKG4uTGZhY2Usbi5SZmFjZSkpLG4uT25leHQ9PT1uKXRoaXMua2lsbFZlcnRleF8obi5PcmcsbnVsbCk7ZWxzZSBpZihuLlJmYWNlLmFuRWRnZT1uLk9wcmV2LG4uT3JnLmFuRWRnZT1uLk9uZXh0LHRoaXMuc3BsaWNlXyhuLG4uT3ByZXYpLCFzKXt2YXIgbD1uZXcgdTt0aGlzLm1ha2VGYWNlXyhsLG4sbi5MZmFjZSl9by5PbmV4dD09PW8/KHRoaXMua2lsbFZlcnRleF8oby5PcmcsbnVsbCksdGhpcy5raWxsRmFjZV8oby5MZmFjZSxudWxsKSk6KG4uTGZhY2UuYW5FZGdlPW8uT3ByZXYsby5PcmcuYW5FZGdlPW8uT25leHQsdGhpcy5zcGxpY2VfKG8sby5PcHJldikpLHRoaXMua2lsbEVkZ2VfKG4pfSxhZGRFZGdlVmVydGV4OmZ1bmN0aW9uKG4pe3ZhciBvPXRoaXMubWFrZUVkZ2VfKG4pLHM9by5TeW07dGhpcy5zcGxpY2VfKG8sbi5MbmV4dCksby5Pcmc9bi5Ec3Q7dmFyIGw9bmV3IGc7cmV0dXJuIHRoaXMubWFrZVZlcnRleF8obCxzLG8uT3JnKSxvLkxmYWNlPXMuTGZhY2U9bi5MZmFjZSxvfSxzcGxpdEVkZ2U6ZnVuY3Rpb24obixvKXt2YXIgcz10aGlzLmFkZEVkZ2VWZXJ0ZXgobiksbD1zLlN5bTtyZXR1cm4gdGhpcy5zcGxpY2VfKG4uU3ltLG4uU3ltLk9wcmV2KSx0aGlzLnNwbGljZV8obi5TeW0sbCksbi5Ec3Q9bC5PcmcsbC5Ec3QuYW5FZGdlPWwuU3ltLGwuUmZhY2U9bi5SZmFjZSxsLndpbmRpbmc9bi53aW5kaW5nLGwuU3ltLndpbmRpbmc9bi5TeW0ud2luZGluZyxsfSxjb25uZWN0OmZ1bmN0aW9uKG4sbyl7dmFyIHM9ITEsbD10aGlzLm1ha2VFZGdlXyhuKSxFPWwuU3ltO2lmKG8uTGZhY2UhPT1uLkxmYWNlJiYocz0hMCx0aGlzLmtpbGxGYWNlXyhvLkxmYWNlLG4uTGZhY2UpKSx0aGlzLnNwbGljZV8obCxuLkxuZXh0KSx0aGlzLnNwbGljZV8oRSxvKSxsLk9yZz1uLkRzdCxFLk9yZz1vLk9yZyxsLkxmYWNlPUUuTGZhY2U9bi5MZmFjZSxuLkxmYWNlLmFuRWRnZT1FLCFzKXt2YXIgVD1uZXcgdTt0aGlzLm1ha2VGYWNlXyhULGwsbi5MZmFjZSl9cmV0dXJuIGx9LHphcEZhY2U6ZnVuY3Rpb24obil7dmFyIG89bi5hbkVkZ2UscyxsLEUsVCxiO2w9by5MbmV4dDtkbyBzPWwsbD1zLkxuZXh0LHMuTGZhY2U9bnVsbCxzLlJmYWNlPT09bnVsbCYmKHMuT25leHQ9PT1zP3RoaXMua2lsbFZlcnRleF8ocy5PcmcsbnVsbCk6KHMuT3JnLmFuRWRnZT1zLk9uZXh0LHRoaXMuc3BsaWNlXyhzLHMuT3ByZXYpKSxFPXMuU3ltLEUuT25leHQ9PT1FP3RoaXMua2lsbFZlcnRleF8oRS5PcmcsbnVsbCk6KEUuT3JnLmFuRWRnZT1FLk9uZXh0LHRoaXMuc3BsaWNlXyhFLEUuT3ByZXYpKSx0aGlzLmtpbGxFZGdlXyhzKSk7d2hpbGUocyE9byk7VD1uLnByZXYsYj1uLm5leHQsYi5wcmV2PVQsVC5uZXh0PWJ9LGNvdW50RmFjZVZlcnRzXzpmdW5jdGlvbihuKXt2YXIgbz1uLmFuRWRnZSxzPTA7ZG8gcysrLG89by5MbmV4dDt3aGlsZShvIT09bi5hbkVkZ2UpO3JldHVybiBzfSxtZXJnZUNvbnZleEZhY2VzOmZ1bmN0aW9uKG4pe3ZhciBvLHMsbCxFLFQsYixJO2ZvcihvPXRoaXMuZkhlYWQubmV4dDtvIT09dGhpcy5mSGVhZDtvPW8ubmV4dClpZihvLmluc2lkZSlmb3Iocz1vLmFuRWRnZSxUPXMuT3JnO2w9cy5MbmV4dCxFPXMuU3ltLEUmJkUuTGZhY2UmJkUuTGZhY2UuaW5zaWRlJiYoYj10aGlzLmNvdW50RmFjZVZlcnRzXyhvKSxJPXRoaXMuY291bnRGYWNlVmVydHNfKEUuTGZhY2UpLGIrSS0yPD1uJiZpLnZlcnRDQ1cocy5McHJldi5Pcmcscy5PcmcsRS5MbmV4dC5MbmV4dC5PcmcpJiZpLnZlcnRDQ1coRS5McHJldi5PcmcsRS5Pcmcscy5MbmV4dC5MbmV4dC5PcmcpJiYobD1FLkxuZXh0LHRoaXMuZGVsZXRlKEUpLHM9bnVsbCxFPW51bGwpKSwhKHMmJnMuTG5leHQuT3JnPT09VCk7KXM9bDtyZXR1cm4hMH0sY2hlY2s6ZnVuY3Rpb24oKXt2YXIgbj10aGlzLmZIZWFkLG89dGhpcy52SGVhZCxzPXRoaXMuZUhlYWQsbCxFLFQsYixJLFA7Zm9yKEU9bixFPW47KGw9RS5uZXh0KSE9PW47RT1sKXtoKGwucHJldj09PUUpLEk9bC5hbkVkZ2U7ZG8gaChJLlN5bSE9PUkpLGgoSS5TeW0uU3ltPT09SSksaChJLkxuZXh0Lk9uZXh0LlN5bT09PUkpLGgoSS5PbmV4dC5TeW0uTG5leHQ9PT1JKSxoKEkuTGZhY2U9PT1sKSxJPUkuTG5leHQ7d2hpbGUoSSE9PWwuYW5FZGdlKX1mb3IoaChsLnByZXY9PT1FJiZsLmFuRWRnZT09PW51bGwpLGI9byxiPW87KFQ9Yi5uZXh0KSE9PW87Yj1UKXtoKFQucHJldj09PWIpLEk9VC5hbkVkZ2U7ZG8gaChJLlN5bSE9PUkpLGgoSS5TeW0uU3ltPT09SSksaChJLkxuZXh0Lk9uZXh0LlN5bT09PUkpLGgoSS5PbmV4dC5TeW0uTG5leHQ9PT1JKSxoKEkuT3JnPT09VCksST1JLk9uZXh0O3doaWxlKEkhPT1ULmFuRWRnZSl9Zm9yKGgoVC5wcmV2PT09YiYmVC5hbkVkZ2U9PT1udWxsKSxQPXMsUD1zOyhJPVAubmV4dCkhPT1zO1A9SSloKEkuU3ltLm5leHQ9PT1QLlN5bSksaChJLlN5bSE9PUkpLGgoSS5TeW0uU3ltPT09SSksaChJLk9yZyE9PW51bGwpLGgoSS5Ec3QhPT1udWxsKSxoKEkuTG5leHQuT25leHQuU3ltPT09SSksaChJLk9uZXh0LlN5bS5MbmV4dD09PUkpO2goSS5TeW0ubmV4dD09PVAuU3ltJiZJLlN5bT09PXRoaXMuZUhlYWRTeW0mJkkuU3ltLlN5bT09PUkmJkkuT3JnPT09bnVsbCYmSS5Ec3Q9PT1udWxsJiZJLkxmYWNlPT09bnVsbCYmSS5SZmFjZT09PW51bGwpfX0saS52ZXJ0RXE9ZnVuY3Rpb24obixvKXtyZXR1cm4gbi5zPT09by5zJiZuLnQ9PT1vLnR9LGkudmVydExlcT1mdW5jdGlvbihuLG8pe3JldHVybiBuLnM8by5zfHxuLnM9PT1vLnMmJm4udDw9by50fSxpLnRyYW5zTGVxPWZ1bmN0aW9uKG4sbyl7cmV0dXJuIG4udDxvLnR8fG4udD09PW8udCYmbi5zPD1vLnN9LGkuZWRnZUdvZXNMZWZ0PWZ1bmN0aW9uKG4pe3JldHVybiBpLnZlcnRMZXEobi5Ec3Qsbi5PcmcpfSxpLmVkZ2VHb2VzUmlnaHQ9ZnVuY3Rpb24obil7cmV0dXJuIGkudmVydExlcShuLk9yZyxuLkRzdCl9LGkudmVydEwxZGlzdD1mdW5jdGlvbihuLG8pe3JldHVybiBNYXRoLmFicyhuLnMtby5zKStNYXRoLmFicyhuLnQtby50KX0saS5lZGdlRXZhbD1mdW5jdGlvbihuLG8scyl7aChpLnZlcnRMZXEobixvKSYmaS52ZXJ0TGVxKG8scykpO3ZhciBsPW8ucy1uLnMsRT1zLnMtby5zO3JldHVybiBsK0U+MD9sPEU/by50LW4udCsobi50LXMudCkqKGwvKGwrRSkpOm8udC1zLnQrKHMudC1uLnQpKihFLyhsK0UpKTowfSxpLmVkZ2VTaWduPWZ1bmN0aW9uKG4sbyxzKXtoKGkudmVydExlcShuLG8pJiZpLnZlcnRMZXEobyxzKSk7dmFyIGw9by5zLW4ucyxFPXMucy1vLnM7cmV0dXJuIGwrRT4wPyhvLnQtcy50KSpsKyhvLnQtbi50KSpFOjB9LGkudHJhbnNFdmFsPWZ1bmN0aW9uKG4sbyxzKXtoKGkudHJhbnNMZXEobixvKSYmaS50cmFuc0xlcShvLHMpKTt2YXIgbD1vLnQtbi50LEU9cy50LW8udDtyZXR1cm4gbCtFPjA/bDxFP28ucy1uLnMrKG4ucy1zLnMpKihsLyhsK0UpKTpvLnMtcy5zKyhzLnMtbi5zKSooRS8obCtFKSk6MH0saS50cmFuc1NpZ249ZnVuY3Rpb24obixvLHMpe2goaS50cmFuc0xlcShuLG8pJiZpLnRyYW5zTGVxKG8scykpO3ZhciBsPW8udC1uLnQsRT1zLnQtby50O3JldHVybiBsK0U+MD8oby5zLXMucykqbCsoby5zLW4ucykqRTowfSxpLnZlcnRDQ1c9ZnVuY3Rpb24obixvLHMpe3JldHVybiBuLnMqKG8udC1zLnQpK28ucyoocy50LW4udCkrcy5zKihuLnQtby50KT49MH0saS5pbnRlcnBvbGF0ZT1mdW5jdGlvbihuLG8scyxsKXtyZXR1cm4gbj1uPDA/MDpuLHM9czwwPzA6cyxuPD1zP3M9PT0wPyhvK2wpLzI6bysobC1vKSoobi8obitzKSk6bCsoby1sKSoocy8obitzKSl9LGkuaW50ZXJzZWN0PWZ1bmN0aW9uKG4sbyxzLGwsRSl7dmFyIFQsYixJO2kudmVydExlcShuLG8pfHwoST1uLG49byxvPUkpLGkudmVydExlcShzLGwpfHwoST1zLHM9bCxsPUkpLGkudmVydExlcShuLHMpfHwoST1uLG49cyxzPUksST1vLG89bCxsPUkpLGkudmVydExlcShzLG8pP2kudmVydExlcShvLGwpPyhUPWkuZWRnZUV2YWwobixzLG8pLGI9aS5lZGdlRXZhbChzLG8sbCksVCtiPDAmJihUPS1ULGI9LWIpLEUucz1pLmludGVycG9sYXRlKFQscy5zLGIsby5zKSk6KFQ9aS5lZGdlU2lnbihuLHMsbyksYj0taS5lZGdlU2lnbihuLGwsbyksVCtiPDAmJihUPS1ULGI9LWIpLEUucz1pLmludGVycG9sYXRlKFQscy5zLGIsbC5zKSk6RS5zPShzLnMrby5zKS8yLGkudHJhbnNMZXEobixvKXx8KEk9bixuPW8sbz1JKSxpLnRyYW5zTGVxKHMsbCl8fChJPXMscz1sLGw9SSksaS50cmFuc0xlcShuLHMpfHwoST1uLG49cyxzPUksST1vLG89bCxsPUkpLGkudHJhbnNMZXEocyxvKT9pLnRyYW5zTGVxKG8sbCk/KFQ9aS50cmFuc0V2YWwobixzLG8pLGI9aS50cmFuc0V2YWwocyxvLGwpLFQrYjwwJiYoVD0tVCxiPS1iKSxFLnQ9aS5pbnRlcnBvbGF0ZShULHMudCxiLG8udCkpOihUPWkudHJhbnNTaWduKG4scyxvKSxiPS1pLnRyYW5zU2lnbihuLGwsbyksVCtiPDAmJihUPS1ULGI9LWIpLEUudD1pLmludGVycG9sYXRlKFQscy50LGIsbC50KSk6RS50PShzLnQrby50KS8yfTtmdW5jdGlvbiB4KCl7dGhpcy5rZXk9bnVsbCx0aGlzLm5leHQ9bnVsbCx0aGlzLnByZXY9bnVsbH1mdW5jdGlvbiBmKG4sbyl7dGhpcy5oZWFkPW5ldyB4LHRoaXMuaGVhZC5uZXh0PXRoaXMuaGVhZCx0aGlzLmhlYWQucHJldj10aGlzLmhlYWQsdGhpcy5mcmFtZT1uLHRoaXMubGVxPW99Zi5wcm90b3R5cGU9e21pbjpmdW5jdGlvbigpe3JldHVybiB0aGlzLmhlYWQubmV4dH0sbWF4OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaGVhZC5wcmV2fSxpbnNlcnQ6ZnVuY3Rpb24obil7cmV0dXJuIHRoaXMuaW5zZXJ0QmVmb3JlKHRoaXMuaGVhZCxuKX0sc2VhcmNoOmZ1bmN0aW9uKG4pe3ZhciBvPXRoaXMuaGVhZDtkbyBvPW8ubmV4dDt3aGlsZShvLmtleSE9PW51bGwmJiF0aGlzLmxlcSh0aGlzLmZyYW1lLG4sby5rZXkpKTtyZXR1cm4gb30saW5zZXJ0QmVmb3JlOmZ1bmN0aW9uKG4sbyl7ZG8gbj1uLnByZXY7d2hpbGUobi5rZXkhPT1udWxsJiYhdGhpcy5sZXEodGhpcy5mcmFtZSxuLmtleSxvKSk7dmFyIHM9bmV3IHg7cmV0dXJuIHMua2V5PW8scy5uZXh0PW4ubmV4dCxuLm5leHQucHJldj1zLHMucHJldj1uLG4ubmV4dD1zLHN9LGRlbGV0ZTpmdW5jdGlvbihuKXtuLm5leHQucHJldj1uLnByZXYsbi5wcmV2Lm5leHQ9bi5uZXh0fX07ZnVuY3Rpb24gdigpe3RoaXMuaGFuZGxlPW51bGx9ZnVuY3Rpb24gcCgpe3RoaXMua2V5PW51bGwsdGhpcy5ub2RlPW51bGx9ZnVuY3Rpb24gQyhuLG8pe3RoaXMuc2l6ZT0wLHRoaXMubWF4PW4sdGhpcy5ub2Rlcz1bXSx0aGlzLm5vZGVzLmxlbmd0aD1uKzE7dmFyIHM7Zm9yKHM9MDtzPHRoaXMubm9kZXMubGVuZ3RoO3MrKyl0aGlzLm5vZGVzW3NdPW5ldyB2O2Zvcih0aGlzLmhhbmRsZXM9W10sdGhpcy5oYW5kbGVzLmxlbmd0aD1uKzEscz0wO3M8dGhpcy5oYW5kbGVzLmxlbmd0aDtzKyspdGhpcy5oYW5kbGVzW3NdPW5ldyBwO3RoaXMuaW5pdGlhbGl6ZWQ9ITEsdGhpcy5mcmVlTGlzdD0wLHRoaXMubGVxPW8sdGhpcy5ub2Rlc1sxXS5oYW5kbGU9MSx0aGlzLmhhbmRsZXNbMV0ua2V5PW51bGx9Qy5wcm90b3R5cGU9e2Zsb2F0RG93bl86ZnVuY3Rpb24obil7dmFyIG89dGhpcy5ub2RlcyxzPXRoaXMuaGFuZGxlcyxsLEUsVDtmb3IobD1vW25dLmhhbmRsZTs7KXtpZihUPW48PDEsVDx0aGlzLnNpemUmJnRoaXMubGVxKHNbb1tUKzFdLmhhbmRsZV0ua2V5LHNbb1tUXS5oYW5kbGVdLmtleSkmJisrVCxoKFQ8PXRoaXMubWF4KSxFPW9bVF0uaGFuZGxlLFQ+dGhpcy5zaXplfHx0aGlzLmxlcShzW2xdLmtleSxzW0VdLmtleSkpe29bbl0uaGFuZGxlPWwsc1tsXS5ub2RlPW47YnJlYWt9b1tuXS5oYW5kbGU9RSxzW0VdLm5vZGU9bixuPVR9fSxmbG9hdFVwXzpmdW5jdGlvbihuKXt2YXIgbz10aGlzLm5vZGVzLHM9dGhpcy5oYW5kbGVzLGwsRSxUO2ZvcihsPW9bbl0uaGFuZGxlOzspe2lmKFQ9bj4+MSxFPW9bVF0uaGFuZGxlLFQ9PT0wfHx0aGlzLmxlcShzW0VdLmtleSxzW2xdLmtleSkpe29bbl0uaGFuZGxlPWwsc1tsXS5ub2RlPW47YnJlYWt9b1tuXS5oYW5kbGU9RSxzW0VdLm5vZGU9bixuPVR9fSxpbml0OmZ1bmN0aW9uKCl7Zm9yKHZhciBuPXRoaXMuc2l6ZTtuPj0xOy0tbil0aGlzLmZsb2F0RG93bl8obik7dGhpcy5pbml0aWFsaXplZD0hMH0sbWluOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaGFuZGxlc1t0aGlzLm5vZGVzWzFdLmhhbmRsZV0ua2V5fSxpbnNlcnQ6ZnVuY3Rpb24obil7dmFyIG8scztpZihvPSsrdGhpcy5zaXplLG8qMj50aGlzLm1heCl7dGhpcy5tYXgqPTI7dmFyIGwsRTtmb3IoRT10aGlzLm5vZGVzLmxlbmd0aCx0aGlzLm5vZGVzLmxlbmd0aD10aGlzLm1heCsxLGw9RTtsPHRoaXMubm9kZXMubGVuZ3RoO2wrKyl0aGlzLm5vZGVzW2xdPW5ldyB2O2ZvcihFPXRoaXMuaGFuZGxlcy5sZW5ndGgsdGhpcy5oYW5kbGVzLmxlbmd0aD10aGlzLm1heCsxLGw9RTtsPHRoaXMuaGFuZGxlcy5sZW5ndGg7bCsrKXRoaXMuaGFuZGxlc1tsXT1uZXcgcH1yZXR1cm4gdGhpcy5mcmVlTGlzdD09PTA/cz1vOihzPXRoaXMuZnJlZUxpc3QsdGhpcy5mcmVlTGlzdD10aGlzLmhhbmRsZXNbc10ubm9kZSksdGhpcy5ub2Rlc1tvXS5oYW5kbGU9cyx0aGlzLmhhbmRsZXNbc10ubm9kZT1vLHRoaXMuaGFuZGxlc1tzXS5rZXk9bix0aGlzLmluaXRpYWxpemVkJiZ0aGlzLmZsb2F0VXBfKG8pLHN9LGV4dHJhY3RNaW46ZnVuY3Rpb24oKXt2YXIgbj10aGlzLm5vZGVzLG89dGhpcy5oYW5kbGVzLHM9blsxXS5oYW5kbGUsbD1vW3NdLmtleTtyZXR1cm4gdGhpcy5zaXplPjAmJihuWzFdLmhhbmRsZT1uW3RoaXMuc2l6ZV0uaGFuZGxlLG9bblsxXS5oYW5kbGVdLm5vZGU9MSxvW3NdLmtleT1udWxsLG9bc10ubm9kZT10aGlzLmZyZWVMaXN0LHRoaXMuZnJlZUxpc3Q9cywtLXRoaXMuc2l6ZSx0aGlzLnNpemU+MCYmdGhpcy5mbG9hdERvd25fKDEpKSxsfSxkZWxldGU6ZnVuY3Rpb24obil7dmFyIG89dGhpcy5ub2RlcyxzPXRoaXMuaGFuZGxlcyxsO2gobj49MSYmbjw9dGhpcy5tYXgmJnNbbl0ua2V5IT09bnVsbCksbD1zW25dLm5vZGUsb1tsXS5oYW5kbGU9b1t0aGlzLnNpemVdLmhhbmRsZSxzW29bbF0uaGFuZGxlXS5ub2RlPWwsLS10aGlzLnNpemUsbDw9dGhpcy5zaXplJiYobDw9MXx8dGhpcy5sZXEoc1tvW2w+PjFdLmhhbmRsZV0ua2V5LHNbb1tsXS5oYW5kbGVdLmtleSk/dGhpcy5mbG9hdERvd25fKGwpOnRoaXMuZmxvYXRVcF8obCkpLHNbbl0ua2V5PW51bGwsc1tuXS5ub2RlPXRoaXMuZnJlZUxpc3QsdGhpcy5mcmVlTGlzdD1ufX07ZnVuY3Rpb24gTSgpe3RoaXMuZVVwPW51bGwsdGhpcy5ub2RlVXA9bnVsbCx0aGlzLndpbmRpbmdOdW1iZXI9MCx0aGlzLmluc2lkZT0hMSx0aGlzLnNlbnRpbmVsPSExLHRoaXMuZGlydHk9ITEsdGhpcy5maXhVcHBlckVkZ2U9ITF9dmFyIG09e307bS5yZWdpb25CZWxvdz1mdW5jdGlvbihuKXtyZXR1cm4gbi5ub2RlVXAucHJldi5rZXl9LG0ucmVnaW9uQWJvdmU9ZnVuY3Rpb24obil7cmV0dXJuIG4ubm9kZVVwLm5leHQua2V5fSxtLmRlYnVnRXZlbnQ9ZnVuY3Rpb24obil7fSxtLmFkZFdpbmRpbmc9ZnVuY3Rpb24obixvKXtuLndpbmRpbmcrPW8ud2luZGluZyxuLlN5bS53aW5kaW5nKz1vLlN5bS53aW5kaW5nfSxtLmVkZ2VMZXE9ZnVuY3Rpb24obixvLHMpe3ZhciBsPW4uZXZlbnQsYixJLEU9by5lVXAsVD1zLmVVcDtpZihFLkRzdD09PWwpcmV0dXJuIFQuRHN0PT09bD9pLnZlcnRMZXEoRS5PcmcsVC5PcmcpP2kuZWRnZVNpZ24oVC5Ec3QsRS5PcmcsVC5PcmcpPD0wOmkuZWRnZVNpZ24oRS5Ec3QsVC5PcmcsRS5PcmcpPj0wOmkuZWRnZVNpZ24oVC5Ec3QsbCxULk9yZyk8PTA7aWYoVC5Ec3Q9PT1sKXJldHVybiBpLmVkZ2VTaWduKEUuRHN0LGwsRS5PcmcpPj0wO3ZhciBiPWkuZWRnZUV2YWwoRS5Ec3QsbCxFLk9yZyksST1pLmVkZ2VFdmFsKFQuRHN0LGwsVC5PcmcpO3JldHVybiBiPj1JfSxtLmRlbGV0ZVJlZ2lvbj1mdW5jdGlvbihuLG8pe28uZml4VXBwZXJFZGdlJiZoKG8uZVVwLndpbmRpbmc9PT0wKSxvLmVVcC5hY3RpdmVSZWdpb249bnVsbCxuLmRpY3QuZGVsZXRlKG8ubm9kZVVwKX0sbS5maXhVcHBlckVkZ2U9ZnVuY3Rpb24obixvLHMpe2goby5maXhVcHBlckVkZ2UpLG4ubWVzaC5kZWxldGUoby5lVXApLG8uZml4VXBwZXJFZGdlPSExLG8uZVVwPXMscy5hY3RpdmVSZWdpb249b30sbS50b3BMZWZ0UmVnaW9uPWZ1bmN0aW9uKG4sbyl7dmFyIHM9by5lVXAuT3JnLGw7ZG8gbz1tLnJlZ2lvbkFib3ZlKG8pO3doaWxlKG8uZVVwLk9yZz09PXMpO2lmKG8uZml4VXBwZXJFZGdlKXtpZihsPW4ubWVzaC5jb25uZWN0KG0ucmVnaW9uQmVsb3cobykuZVVwLlN5bSxvLmVVcC5MbmV4dCksbD09PW51bGwpcmV0dXJuIG51bGw7bS5maXhVcHBlckVkZ2UobixvLGwpLG89bS5yZWdpb25BYm92ZShvKX1yZXR1cm4gb30sbS50b3BSaWdodFJlZ2lvbj1mdW5jdGlvbihuKXt2YXIgbz1uLmVVcC5Ec3Q7ZG8gbj1tLnJlZ2lvbkFib3ZlKG4pO3doaWxlKG4uZVVwLkRzdD09PW8pO3JldHVybiBufSxtLmFkZFJlZ2lvbkJlbG93PWZ1bmN0aW9uKG4sbyxzKXt2YXIgbD1uZXcgTTtyZXR1cm4gbC5lVXA9cyxsLm5vZGVVcD1uLmRpY3QuaW5zZXJ0QmVmb3JlKG8ubm9kZVVwLGwpLGwuZml4VXBwZXJFZGdlPSExLGwuc2VudGluZWw9ITEsbC5kaXJ0eT0hMSxzLmFjdGl2ZVJlZ2lvbj1sLGx9LG0uaXNXaW5kaW5nSW5zaWRlPWZ1bmN0aW9uKG4sbyl7c3dpdGNoKG4ud2luZGluZ1J1bGUpe2Nhc2Ugci5XSU5ESU5HX09ERDpyZXR1cm4obyYxKSE9PTA7Y2FzZSByLldJTkRJTkdfTk9OWkVSTzpyZXR1cm4gbyE9PTA7Y2FzZSByLldJTkRJTkdfUE9TSVRJVkU6cmV0dXJuIG8+MDtjYXNlIHIuV0lORElOR19ORUdBVElWRTpyZXR1cm4gbzwwO2Nhc2Ugci5XSU5ESU5HX0FCU19HRVFfVFdPOnJldHVybiBvPj0yfHxvPD0tMn1yZXR1cm4gaCghMSksITF9LG0uY29tcHV0ZVdpbmRpbmc9ZnVuY3Rpb24obixvKXtvLndpbmRpbmdOdW1iZXI9bS5yZWdpb25BYm92ZShvKS53aW5kaW5nTnVtYmVyK28uZVVwLndpbmRpbmcsby5pbnNpZGU9bS5pc1dpbmRpbmdJbnNpZGUobixvLndpbmRpbmdOdW1iZXIpfSxtLmZpbmlzaFJlZ2lvbj1mdW5jdGlvbihuLG8pe3ZhciBzPW8uZVVwLGw9cy5MZmFjZTtsLmluc2lkZT1vLmluc2lkZSxsLmFuRWRnZT1zLG0uZGVsZXRlUmVnaW9uKG4sbyl9LG0uZmluaXNoTGVmdFJlZ2lvbnM9ZnVuY3Rpb24obixvLHMpe2Zvcih2YXIgbCxiLEU9bnVsbCxUPW8sYj1vLmVVcDtUIT09czspe2lmKFQuZml4VXBwZXJFZGdlPSExLEU9bS5yZWdpb25CZWxvdyhUKSxsPUUuZVVwLGwuT3JnIT1iLk9yZyl7aWYoIUUuZml4VXBwZXJFZGdlKXttLmZpbmlzaFJlZ2lvbihuLFQpO2JyZWFrfWw9bi5tZXNoLmNvbm5lY3QoYi5McHJldixsLlN5bSksbS5maXhVcHBlckVkZ2UobixFLGwpfWIuT25leHQhPT1sJiYobi5tZXNoLnNwbGljZShsLk9wcmV2LGwpLG4ubWVzaC5zcGxpY2UoYixsKSksbS5maW5pc2hSZWdpb24obixUKSxiPUUuZVVwLFQ9RX1yZXR1cm4gYn0sbS5hZGRSaWdodEVkZ2VzPWZ1bmN0aW9uKG4sbyxzLGwsRSxUKXt2YXIgYixJLFAsTCxEPSEwO1A9cztkbyBoKGkudmVydExlcShQLk9yZyxQLkRzdCkpLG0uYWRkUmVnaW9uQmVsb3cobixvLFAuU3ltKSxQPVAuT25leHQ7d2hpbGUoUCE9PWwpO2ZvcihFPT09bnVsbCYmKEU9bS5yZWdpb25CZWxvdyhvKS5lVXAuUnByZXYpLEk9byxMPUU7Yj1tLnJlZ2lvbkJlbG93KEkpLFA9Yi5lVXAuU3ltLFAuT3JnPT09TC5Pcmc7KVAuT25leHQhPT1MJiYobi5tZXNoLnNwbGljZShQLk9wcmV2LFApLG4ubWVzaC5zcGxpY2UoTC5PcHJldixQKSksYi53aW5kaW5nTnVtYmVyPUkud2luZGluZ051bWJlci1QLndpbmRpbmcsYi5pbnNpZGU9bS5pc1dpbmRpbmdJbnNpZGUobixiLndpbmRpbmdOdW1iZXIpLEkuZGlydHk9ITAsIUQmJm0uY2hlY2tGb3JSaWdodFNwbGljZShuLEkpJiYobS5hZGRXaW5kaW5nKFAsTCksbS5kZWxldGVSZWdpb24obixJKSxuLm1lc2guZGVsZXRlKEwpKSxEPSExLEk9YixMPVA7SS5kaXJ0eT0hMCxoKEkud2luZGluZ051bWJlci1QLndpbmRpbmc9PT1iLndpbmRpbmdOdW1iZXIpLFQmJm0ud2Fsa0RpcnR5UmVnaW9ucyhuLEkpfSxtLnNwbGljZU1lcmdlVmVydGljZXM9ZnVuY3Rpb24obixvLHMpe24ubWVzaC5zcGxpY2UobyxzKX0sbS52ZXJ0ZXhXZWlnaHRzPWZ1bmN0aW9uKG4sbyxzKXt2YXIgbD1pLnZlcnRMMWRpc3QobyxuKSxFPWkudmVydEwxZGlzdChzLG4pLFQ9LjUqRS8obCtFKSxiPS41KmwvKGwrRSk7bi5jb29yZHNbMF0rPVQqby5jb29yZHNbMF0rYipzLmNvb3Jkc1swXSxuLmNvb3Jkc1sxXSs9VCpvLmNvb3Jkc1sxXStiKnMuY29vcmRzWzFdLG4uY29vcmRzWzJdKz1UKm8uY29vcmRzWzJdK2Iqcy5jb29yZHNbMl19LG0uZ2V0SW50ZXJzZWN0RGF0YT1mdW5jdGlvbihuLG8scyxsLEUsVCl7by5jb29yZHNbMF09by5jb29yZHNbMV09by5jb29yZHNbMl09MCxvLmlkeD0tMSxtLnZlcnRleFdlaWdodHMobyxzLGwpLG0udmVydGV4V2VpZ2h0cyhvLEUsVCl9LG0uY2hlY2tGb3JSaWdodFNwbGljZT1mdW5jdGlvbihuLG8pe3ZhciBzPW0ucmVnaW9uQmVsb3cobyksbD1vLmVVcCxFPXMuZVVwO2lmKGkudmVydExlcShsLk9yZyxFLk9yZykpe2lmKGkuZWRnZVNpZ24oRS5Ec3QsbC5PcmcsRS5PcmcpPjApcmV0dXJuITE7aS52ZXJ0RXEobC5PcmcsRS5PcmcpP2wuT3JnIT09RS5PcmcmJihuLnBxLmRlbGV0ZShsLk9yZy5wcUhhbmRsZSksbS5zcGxpY2VNZXJnZVZlcnRpY2VzKG4sRS5PcHJldixsKSk6KG4ubWVzaC5zcGxpdEVkZ2UoRS5TeW0pLG4ubWVzaC5zcGxpY2UobCxFLk9wcmV2KSxvLmRpcnR5PXMuZGlydHk9ITApfWVsc2V7aWYoaS5lZGdlU2lnbihsLkRzdCxFLk9yZyxsLk9yZyk8MClyZXR1cm4hMTttLnJlZ2lvbkFib3ZlKG8pLmRpcnR5PW8uZGlydHk9ITAsbi5tZXNoLnNwbGl0RWRnZShsLlN5bSksbi5tZXNoLnNwbGljZShFLk9wcmV2LGwpfXJldHVybiEwfSxtLmNoZWNrRm9yTGVmdFNwbGljZT1mdW5jdGlvbihuLG8pe3ZhciBzPW0ucmVnaW9uQmVsb3cobyksbD1vLmVVcCxFPXMuZVVwLFQ7aWYoaCghaS52ZXJ0RXEobC5Ec3QsRS5Ec3QpKSxpLnZlcnRMZXEobC5Ec3QsRS5Ec3QpKXtpZihpLmVkZ2VTaWduKGwuRHN0LEUuRHN0LGwuT3JnKTwwKXJldHVybiExO20ucmVnaW9uQWJvdmUobykuZGlydHk9by5kaXJ0eT0hMCxUPW4ubWVzaC5zcGxpdEVkZ2UobCksbi5tZXNoLnNwbGljZShFLlN5bSxUKSxULkxmYWNlLmluc2lkZT1vLmluc2lkZX1lbHNle2lmKGkuZWRnZVNpZ24oRS5Ec3QsbC5Ec3QsRS5PcmcpPjApcmV0dXJuITE7by5kaXJ0eT1zLmRpcnR5PSEwLFQ9bi5tZXNoLnNwbGl0RWRnZShFKSxuLm1lc2guc3BsaWNlKGwuTG5leHQsRS5TeW0pLFQuUmZhY2UuaW5zaWRlPW8uaW5zaWRlfXJldHVybiEwfSxtLmNoZWNrRm9ySW50ZXJzZWN0PWZ1bmN0aW9uKG4sbyl7dmFyIHM9bS5yZWdpb25CZWxvdyhvKSxsPW8uZVVwLEU9cy5lVXAsVD1sLk9yZyxiPUUuT3JnLEk9bC5Ec3QsUD1FLkRzdCxMLEQsUj1uZXcgZyxBLGo7aWYoaCghaS52ZXJ0RXEoUCxJKSksaChpLmVkZ2VTaWduKEksbi5ldmVudCxUKTw9MCksaChpLmVkZ2VTaWduKFAsbi5ldmVudCxiKT49MCksaChUIT09bi5ldmVudCYmYiE9PW4uZXZlbnQpLGgoIW8uZml4VXBwZXJFZGdlJiYhcy5maXhVcHBlckVkZ2UpLFQ9PT1ifHwoTD1NYXRoLm1pbihULnQsSS50KSxEPU1hdGgubWF4KGIudCxQLnQpLEw+RCkpcmV0dXJuITE7aWYoaS52ZXJ0TGVxKFQsYikpe2lmKGkuZWRnZVNpZ24oUCxULGIpPjApcmV0dXJuITF9ZWxzZSBpZihpLmVkZ2VTaWduKEksYixUKTwwKXJldHVybiExO3JldHVybiBtLmRlYnVnRXZlbnQobiksaS5pbnRlcnNlY3QoSSxULFAsYixSKSxoKE1hdGgubWluKFQudCxJLnQpPD1SLnQpLGgoUi50PD1NYXRoLm1heChiLnQsUC50KSksaChNYXRoLm1pbihQLnMsSS5zKTw9Ui5zKSxoKFIuczw9TWF0aC5tYXgoYi5zLFQucykpLGkudmVydExlcShSLG4uZXZlbnQpJiYoUi5zPW4uZXZlbnQucyxSLnQ9bi5ldmVudC50KSxBPWkudmVydExlcShULGIpP1Q6YixpLnZlcnRMZXEoQSxSKSYmKFIucz1BLnMsUi50PUEudCksaS52ZXJ0RXEoUixUKXx8aS52ZXJ0RXEoUixiKT8obS5jaGVja0ZvclJpZ2h0U3BsaWNlKG4sbyksITEpOiFpLnZlcnRFcShJLG4uZXZlbnQpJiZpLmVkZ2VTaWduKEksbi5ldmVudCxSKT49MHx8IWkudmVydEVxKFAsbi5ldmVudCkmJmkuZWRnZVNpZ24oUCxuLmV2ZW50LFIpPD0wP1A9PT1uLmV2ZW50PyhuLm1lc2guc3BsaXRFZGdlKGwuU3ltKSxuLm1lc2guc3BsaWNlKEUuU3ltLGwpLG89bS50b3BMZWZ0UmVnaW9uKG4sbyksbD1tLnJlZ2lvbkJlbG93KG8pLmVVcCxtLmZpbmlzaExlZnRSZWdpb25zKG4sbS5yZWdpb25CZWxvdyhvKSxzKSxtLmFkZFJpZ2h0RWRnZXMobixvLGwuT3ByZXYsbCxsLCEwKSwhMCk6ST09PW4uZXZlbnQ/KG4ubWVzaC5zcGxpdEVkZ2UoRS5TeW0pLG4ubWVzaC5zcGxpY2UobC5MbmV4dCxFLk9wcmV2KSxzPW8sbz1tLnRvcFJpZ2h0UmVnaW9uKG8pLGo9bS5yZWdpb25CZWxvdyhvKS5lVXAuUnByZXYscy5lVXA9RS5PcHJldixFPW0uZmluaXNoTGVmdFJlZ2lvbnMobixzLG51bGwpLG0uYWRkUmlnaHRFZGdlcyhuLG8sRS5PbmV4dCxsLlJwcmV2LGosITApLCEwKTooaS5lZGdlU2lnbihJLG4uZXZlbnQsUik+PTAmJihtLnJlZ2lvbkFib3ZlKG8pLmRpcnR5PW8uZGlydHk9ITAsbi5tZXNoLnNwbGl0RWRnZShsLlN5bSksbC5Pcmcucz1uLmV2ZW50LnMsbC5PcmcudD1uLmV2ZW50LnQpLGkuZWRnZVNpZ24oUCxuLmV2ZW50LFIpPD0wJiYoby5kaXJ0eT1zLmRpcnR5PSEwLG4ubWVzaC5zcGxpdEVkZ2UoRS5TeW0pLEUuT3JnLnM9bi5ldmVudC5zLEUuT3JnLnQ9bi5ldmVudC50KSwhMSk6KG4ubWVzaC5zcGxpdEVkZ2UobC5TeW0pLG4ubWVzaC5zcGxpdEVkZ2UoRS5TeW0pLG4ubWVzaC5zcGxpY2UoRS5PcHJldixsKSxsLk9yZy5zPVIucyxsLk9yZy50PVIudCxsLk9yZy5wcUhhbmRsZT1uLnBxLmluc2VydChsLk9yZyksbS5nZXRJbnRlcnNlY3REYXRhKG4sbC5PcmcsVCxJLGIsUCksbS5yZWdpb25BYm92ZShvKS5kaXJ0eT1vLmRpcnR5PXMuZGlydHk9ITAsITEpfSxtLndhbGtEaXJ0eVJlZ2lvbnM9ZnVuY3Rpb24obixvKXtmb3IodmFyIHM9bS5yZWdpb25CZWxvdyhvKSxsLEU7Oyl7Zm9yKDtzLmRpcnR5OylvPXMscz1tLnJlZ2lvbkJlbG93KHMpO2lmKCFvLmRpcnR5JiYocz1vLG89bS5yZWdpb25BYm92ZShvKSxvPT09bnVsbHx8IW8uZGlydHkpKXJldHVybjtpZihvLmRpcnR5PSExLGw9by5lVXAsRT1zLmVVcCxsLkRzdCE9PUUuRHN0JiZtLmNoZWNrRm9yTGVmdFNwbGljZShuLG8pJiYocy5maXhVcHBlckVkZ2U/KG0uZGVsZXRlUmVnaW9uKG4scyksbi5tZXNoLmRlbGV0ZShFKSxzPW0ucmVnaW9uQmVsb3cobyksRT1zLmVVcCk6by5maXhVcHBlckVkZ2UmJihtLmRlbGV0ZVJlZ2lvbihuLG8pLG4ubWVzaC5kZWxldGUobCksbz1tLnJlZ2lvbkFib3ZlKHMpLGw9by5lVXApKSxsLk9yZyE9PUUuT3JnKWlmKGwuRHN0IT09RS5Ec3QmJiFvLmZpeFVwcGVyRWRnZSYmIXMuZml4VXBwZXJFZGdlJiYobC5Ec3Q9PT1uLmV2ZW50fHxFLkRzdD09PW4uZXZlbnQpKXtpZihtLmNoZWNrRm9ySW50ZXJzZWN0KG4sbykpcmV0dXJufWVsc2UgbS5jaGVja0ZvclJpZ2h0U3BsaWNlKG4sbyk7bC5Pcmc9PT1FLk9yZyYmbC5Ec3Q9PT1FLkRzdCYmKG0uYWRkV2luZGluZyhFLGwpLG0uZGVsZXRlUmVnaW9uKG4sbyksbi5tZXNoLmRlbGV0ZShsKSxvPW0ucmVnaW9uQWJvdmUocykpfX0sbS5jb25uZWN0UmlnaHRWZXJ0ZXg9ZnVuY3Rpb24obixvLHMpe3ZhciBsLEU9cy5PbmV4dCxUPW0ucmVnaW9uQmVsb3cobyksYj1vLmVVcCxJPVQuZVVwLFA9ITE7aWYoYi5Ec3QhPT1JLkRzdCYmbS5jaGVja0ZvckludGVyc2VjdChuLG8pLGkudmVydEVxKGIuT3JnLG4uZXZlbnQpJiYobi5tZXNoLnNwbGljZShFLk9wcmV2LGIpLG89bS50b3BMZWZ0UmVnaW9uKG4sbyksRT1tLnJlZ2lvbkJlbG93KG8pLmVVcCxtLmZpbmlzaExlZnRSZWdpb25zKG4sbS5yZWdpb25CZWxvdyhvKSxUKSxQPSEwKSxpLnZlcnRFcShJLk9yZyxuLmV2ZW50KSYmKG4ubWVzaC5zcGxpY2UocyxJLk9wcmV2KSxzPW0uZmluaXNoTGVmdFJlZ2lvbnMobixULG51bGwpLFA9ITApLFApe20uYWRkUmlnaHRFZGdlcyhuLG8scy5PbmV4dCxFLEUsITApO3JldHVybn1pLnZlcnRMZXEoSS5PcmcsYi5PcmcpP2w9SS5PcHJldjpsPWIsbD1uLm1lc2guY29ubmVjdChzLkxwcmV2LGwpLG0uYWRkUmlnaHRFZGdlcyhuLG8sbCxsLk9uZXh0LGwuT25leHQsITEpLGwuU3ltLmFjdGl2ZVJlZ2lvbi5maXhVcHBlckVkZ2U9ITAsbS53YWxrRGlydHlSZWdpb25zKG4sbyl9LG0uY29ubmVjdExlZnREZWdlbmVyYXRlPWZ1bmN0aW9uKG4sbyxzKXt2YXIgbCxFLFQsYixJO2lmKGw9by5lVXAsaS52ZXJ0RXEobC5Pcmcscykpe2goITEpLG0uc3BsaWNlTWVyZ2VWZXJ0aWNlcyhuLGwscy5hbkVkZ2UpO3JldHVybn1pZighaS52ZXJ0RXEobC5Ec3Qscykpe24ubWVzaC5zcGxpdEVkZ2UobC5TeW0pLG8uZml4VXBwZXJFZGdlJiYobi5tZXNoLmRlbGV0ZShsLk9uZXh0KSxvLmZpeFVwcGVyRWRnZT0hMSksbi5tZXNoLnNwbGljZShzLmFuRWRnZSxsKSxtLnN3ZWVwRXZlbnQobixzKTtyZXR1cm59aCghMSksbz1tLnRvcFJpZ2h0UmVnaW9uKG8pLEk9bS5yZWdpb25CZWxvdyhvKSxUPUkuZVVwLlN5bSxFPWI9VC5PbmV4dCxJLmZpeFVwcGVyRWRnZSYmKGgoRSE9PVQpLG0uZGVsZXRlUmVnaW9uKG4sSSksbi5tZXNoLmRlbGV0ZShUKSxUPUUuT3ByZXYpLG4ubWVzaC5zcGxpY2Uocy5hbkVkZ2UsVCksaS5lZGdlR29lc0xlZnQoRSl8fChFPW51bGwpLG0uYWRkUmlnaHRFZGdlcyhuLG8sVC5PbmV4dCxiLEUsITApfSxtLmNvbm5lY3RMZWZ0VmVydGV4PWZ1bmN0aW9uKG4sbyl7dmFyIHMsbCxFLFQsYixJLFA9bmV3IE07aWYoUC5lVXA9by5hbkVkZ2UuU3ltLHM9bi5kaWN0LnNlYXJjaChQKS5rZXksbD1tLnJlZ2lvbkJlbG93KHMpLCEhbCl7aWYoVD1zLmVVcCxiPWwuZVVwLGkuZWRnZVNpZ24oVC5Ec3QsbyxULk9yZyk9PT0wKXttLmNvbm5lY3RMZWZ0RGVnZW5lcmF0ZShuLHMsbyk7cmV0dXJufWlmKEU9aS52ZXJ0TGVxKGIuRHN0LFQuRHN0KT9zOmwscy5pbnNpZGV8fEUuZml4VXBwZXJFZGdlKXtpZihFPT09cylJPW4ubWVzaC5jb25uZWN0KG8uYW5FZGdlLlN5bSxULkxuZXh0KTtlbHNle3ZhciBMPW4ubWVzaC5jb25uZWN0KGIuRG5leHQsby5hbkVkZ2UpO0k9TC5TeW19RS5maXhVcHBlckVkZ2U/bS5maXhVcHBlckVkZ2UobixFLEkpOm0uY29tcHV0ZVdpbmRpbmcobixtLmFkZFJlZ2lvbkJlbG93KG4scyxJKSksbS5zd2VlcEV2ZW50KG4sbyl9ZWxzZSBtLmFkZFJpZ2h0RWRnZXMobixzLG8uYW5FZGdlLG8uYW5FZGdlLG51bGwsITApfX0sbS5zd2VlcEV2ZW50PWZ1bmN0aW9uKG4sbyl7bi5ldmVudD1vLG0uZGVidWdFdmVudChuKTtmb3IodmFyIHM9by5hbkVkZ2U7cy5hY3RpdmVSZWdpb249PT1udWxsOylpZihzPXMuT25leHQscz09PW8uYW5FZGdlKXttLmNvbm5lY3RMZWZ0VmVydGV4KG4sbyk7cmV0dXJufXZhciBsPW0udG9wTGVmdFJlZ2lvbihuLHMuYWN0aXZlUmVnaW9uKTtoKGwhPT1udWxsKTt2YXIgRT1tLnJlZ2lvbkJlbG93KGwpLFQ9RS5lVXAsYj1tLmZpbmlzaExlZnRSZWdpb25zKG4sRSxudWxsKTtiLk9uZXh0PT09VD9tLmNvbm5lY3RSaWdodFZlcnRleChuLGwsYik6bS5hZGRSaWdodEVkZ2VzKG4sbCxiLk9uZXh0LFQsVCwhMCl9LG0uYWRkU2VudGluZWw9ZnVuY3Rpb24obixvLHMsbCl7dmFyIEU9bmV3IE0sVD1uLm1lc2gubWFrZUVkZ2UoKTtULk9yZy5zPXMsVC5PcmcudD1sLFQuRHN0LnM9byxULkRzdC50PWwsbi5ldmVudD1ULkRzdCxFLmVVcD1ULEUud2luZGluZ051bWJlcj0wLEUuaW5zaWRlPSExLEUuZml4VXBwZXJFZGdlPSExLEUuc2VudGluZWw9ITAsRS5kaXJ0eT0hMSxFLm5vZGVVcD1uLmRpY3QuaW5zZXJ0KEUpfSxtLmluaXRFZGdlRGljdD1mdW5jdGlvbihuKXtuLmRpY3Q9bmV3IGYobixtLmVkZ2VMZXEpO3ZhciBvPW4uYm1heFswXS1uLmJtaW5bMF0scz1uLmJtYXhbMV0tbi5ibWluWzFdLGw9bi5ibWluWzBdLW8sRT1uLmJtYXhbMF0rbyxUPW4uYm1pblsxXS1zLGI9bi5ibWF4WzFdK3M7bS5hZGRTZW50aW5lbChuLGwsRSxUKSxtLmFkZFNlbnRpbmVsKG4sbCxFLGIpfSxtLmRvbmVFZGdlRGljdD1mdW5jdGlvbihuKXtmb3IodmFyIG8scz0wOyhvPW4uZGljdC5taW4oKS5rZXkpIT09bnVsbDspby5zZW50aW5lbHx8KGgoby5maXhVcHBlckVkZ2UpLGgoKytzPT09MSkpLGgoby53aW5kaW5nTnVtYmVyPT09MCksbS5kZWxldGVSZWdpb24obixvKX0sbS5yZW1vdmVEZWdlbmVyYXRlRWRnZXM9ZnVuY3Rpb24obil7dmFyIG8scyxsLEU9bi5tZXNoLmVIZWFkO2ZvcihvPUUubmV4dDtvIT09RTtvPXMpcz1vLm5leHQsbD1vLkxuZXh0LGkudmVydEVxKG8uT3JnLG8uRHN0KSYmby5MbmV4dC5MbmV4dCE9PW8mJihtLnNwbGljZU1lcmdlVmVydGljZXMobixsLG8pLG4ubWVzaC5kZWxldGUobyksbz1sLGw9by5MbmV4dCksbC5MbmV4dD09PW8mJihsIT09byYmKChsPT09c3x8bD09PXMuU3ltKSYmKHM9cy5uZXh0KSxuLm1lc2guZGVsZXRlKGwpKSwobz09PXN8fG89PT1zLlN5bSkmJihzPXMubmV4dCksbi5tZXNoLmRlbGV0ZShvKSl9LG0uaW5pdFByaW9yaXR5UT1mdW5jdGlvbihuKXt2YXIgbyxzLGwsRT0wO2ZvcihsPW4ubWVzaC52SGVhZCxzPWwubmV4dDtzIT09bDtzPXMubmV4dClFKys7Zm9yKEUrPTgsbz1uLnBxPW5ldyBDKEUsaS52ZXJ0TGVxKSxsPW4ubWVzaC52SGVhZCxzPWwubmV4dDtzIT09bDtzPXMubmV4dClzLnBxSGFuZGxlPW8uaW5zZXJ0KHMpO3JldHVybiBzIT09bD8hMTooby5pbml0KCksITApfSxtLmRvbmVQcmlvcml0eVE9ZnVuY3Rpb24obil7bi5wcT1udWxsfSxtLnJlbW92ZURlZ2VuZXJhdGVGYWNlcz1mdW5jdGlvbihuLG8pe3ZhciBzLGwsRTtmb3Iocz1vLmZIZWFkLm5leHQ7cyE9PW8uZkhlYWQ7cz1sKWw9cy5uZXh0LEU9cy5hbkVkZ2UsaChFLkxuZXh0IT09RSksRS5MbmV4dC5MbmV4dD09PUUmJihtLmFkZFdpbmRpbmcoRS5PbmV4dCxFKSxuLm1lc2guZGVsZXRlKEUpKTtyZXR1cm4hMH0sbS5jb21wdXRlSW50ZXJpb3I9ZnVuY3Rpb24obil7dmFyIG8scztpZihtLnJlbW92ZURlZ2VuZXJhdGVFZGdlcyhuKSwhbS5pbml0UHJpb3JpdHlRKG4pKXJldHVybiExO2ZvcihtLmluaXRFZGdlRGljdChuKTsobz1uLnBxLmV4dHJhY3RNaW4oKSkhPT1udWxsOyl7Zm9yKDtzPW4ucHEubWluKCksIShzPT09bnVsbHx8IWkudmVydEVxKHMsbykpOylzPW4ucHEuZXh0cmFjdE1pbigpLG0uc3BsaWNlTWVyZ2VWZXJ0aWNlcyhuLG8uYW5FZGdlLHMuYW5FZGdlKTttLnN3ZWVwRXZlbnQobixvKX1yZXR1cm4gbi5ldmVudD1uLmRpY3QubWluKCkua2V5LmVVcC5PcmcsbS5kZWJ1Z0V2ZW50KG4pLG0uZG9uZUVkZ2VEaWN0KG4pLG0uZG9uZVByaW9yaXR5UShuKSxtLnJlbW92ZURlZ2VuZXJhdGVGYWNlcyhuLG4ubWVzaCk/KG4ubWVzaC5jaGVjaygpLCEwKTohMX07ZnVuY3Rpb24geSgpe3RoaXMubWVzaD1udWxsLHRoaXMubm9ybWFsPVswLDAsMF0sdGhpcy5zVW5pdD1bMCwwLDBdLHRoaXMudFVuaXQ9WzAsMCwwXSx0aGlzLmJtaW49WzAsMF0sdGhpcy5ibWF4PVswLDBdLHRoaXMud2luZGluZ1J1bGU9ci5XSU5ESU5HX09ERCx0aGlzLmRpY3Q9bnVsbCx0aGlzLnBxPW51bGwsdGhpcy5ldmVudD1udWxsLHRoaXMudmVydGV4SW5kZXhDb3VudGVyPTAsdGhpcy52ZXJ0aWNlcz1bXSx0aGlzLnZlcnRleEluZGljZXM9W10sdGhpcy52ZXJ0ZXhDb3VudD0wLHRoaXMuZWxlbWVudHM9W10sdGhpcy5lbGVtZW50Q291bnQ9MH15LnByb3RvdHlwZT17ZG90XzpmdW5jdGlvbihuLG8pe3JldHVybiBuWzBdKm9bMF0rblsxXSpvWzFdK25bMl0qb1syXX0sbm9ybWFsaXplXzpmdW5jdGlvbihuKXt2YXIgbz1uWzBdKm5bMF0rblsxXSpuWzFdK25bMl0qblsyXTtoKG8+MCksbz1NYXRoLnNxcnQobyksblswXS89byxuWzFdLz1vLG5bMl0vPW99LGxvbmdBeGlzXzpmdW5jdGlvbihuKXt2YXIgbz0wO3JldHVybiBNYXRoLmFicyhuWzFdKT5NYXRoLmFicyhuWzBdKSYmKG89MSksTWF0aC5hYnMoblsyXSk+TWF0aC5hYnMobltvXSkmJihvPTIpLG99LGNvbXB1dGVOb3JtYWxfOmZ1bmN0aW9uKG4pe3ZhciBvLHMsbCxFLFQsYixJPVswLDAsMF0sUD1bMCwwLDBdLEw9WzAsMCwwXSxEPVswLDAsMF0sUj1bMCwwLDBdLEE9W251bGwsbnVsbCxudWxsXSxqPVtudWxsLG51bGwsbnVsbF0sRz10aGlzLm1lc2gudkhlYWQsSDtmb3Iobz1HLm5leHQsSD0wO0g8MzsrK0gpRT1vLmNvb3Jkc1tIXSxQW0hdPUUsaltIXT1vLElbSF09RSxBW0hdPW87Zm9yKG89Ry5uZXh0O28hPT1HO289by5uZXh0KWZvcihIPTA7SDwzOysrSClFPW8uY29vcmRzW0hdLEU8UFtIXSYmKFBbSF09RSxqW0hdPW8pLEU+SVtIXSYmKElbSF09RSxBW0hdPW8pO2lmKEg9MCxJWzFdLVBbMV0+SVswXS1QWzBdJiYoSD0xKSxJWzJdLVBbMl0+SVtIXS1QW0hdJiYoSD0yKSxQW0hdPj1JW0hdKXtuWzBdPTAsblsxXT0wLG5bMl09MTtyZXR1cm59Zm9yKGI9MCxzPWpbSF0sbD1BW0hdLExbMF09cy5jb29yZHNbMF0tbC5jb29yZHNbMF0sTFsxXT1zLmNvb3Jkc1sxXS1sLmNvb3Jkc1sxXSxMWzJdPXMuY29vcmRzWzJdLWwuY29vcmRzWzJdLG89Ry5uZXh0O28hPT1HO289by5uZXh0KURbMF09by5jb29yZHNbMF0tbC5jb29yZHNbMF0sRFsxXT1vLmNvb3Jkc1sxXS1sLmNvb3Jkc1sxXSxEWzJdPW8uY29vcmRzWzJdLWwuY29vcmRzWzJdLFJbMF09TFsxXSpEWzJdLUxbMl0qRFsxXSxSWzFdPUxbMl0qRFswXS1MWzBdKkRbMl0sUlsyXT1MWzBdKkRbMV0tTFsxXSpEWzBdLFQ9UlswXSpSWzBdK1JbMV0qUlsxXStSWzJdKlJbMl0sVD5iJiYoYj1ULG5bMF09UlswXSxuWzFdPVJbMV0sblsyXT1SWzJdKTtiPD0wJiYoblswXT1uWzFdPW5bMl09MCxuW3RoaXMubG9uZ0F4aXNfKEwpXT0xKX0sY2hlY2tPcmllbnRhdGlvbl86ZnVuY3Rpb24oKXt2YXIgbixvLHM9dGhpcy5tZXNoLmZIZWFkLGwsRT10aGlzLm1lc2gudkhlYWQsVDtmb3Iobj0wLG89cy5uZXh0O28hPT1zO289by5uZXh0KWlmKFQ9by5hbkVkZ2UsIShULndpbmRpbmc8PTApKWRvIG4rPShULk9yZy5zLVQuRHN0LnMpKihULk9yZy50K1QuRHN0LnQpLFQ9VC5MbmV4dDt3aGlsZShUIT09by5hbkVkZ2UpO2lmKG48MCl7Zm9yKGw9RS5uZXh0O2whPT1FO2w9bC5uZXh0KWwudD0tbC50O3RoaXMudFVuaXRbMF09LXRoaXMudFVuaXRbMF0sdGhpcy50VW5pdFsxXT0tdGhpcy50VW5pdFsxXSx0aGlzLnRVbml0WzJdPS10aGlzLnRVbml0WzJdfX0scHJvamVjdFBvbHlnb25fOmZ1bmN0aW9uKCl7dmFyIG4sbz10aGlzLm1lc2gudkhlYWQscz1bMCwwLDBdLGwsRSxULGIsST0hMTtmb3Ioc1swXT10aGlzLm5vcm1hbFswXSxzWzFdPXRoaXMubm9ybWFsWzFdLHNbMl09dGhpcy5ub3JtYWxbMl0sc1swXT09PTAmJnNbMV09PT0wJiZzWzJdPT09MCYmKHRoaXMuY29tcHV0ZU5vcm1hbF8ocyksST0hMCksbD10aGlzLnNVbml0LEU9dGhpcy50VW5pdCxUPXRoaXMubG9uZ0F4aXNfKHMpLGxbVF09MCxsWyhUKzEpJTNdPTEsbFsoVCsyKSUzXT0wLEVbVF09MCxFWyhUKzEpJTNdPTAsRVsoVCsyKSUzXT1zW1RdPjA/MTotMSxuPW8ubmV4dDtuIT09bztuPW4ubmV4dCluLnM9dGhpcy5kb3RfKG4uY29vcmRzLGwpLG4udD10aGlzLmRvdF8obi5jb29yZHMsRSk7Zm9yKEkmJnRoaXMuY2hlY2tPcmllbnRhdGlvbl8oKSxiPSEwLG49by5uZXh0O24hPT1vO249bi5uZXh0KWI/KHRoaXMuYm1pblswXT10aGlzLmJtYXhbMF09bi5zLHRoaXMuYm1pblsxXT10aGlzLmJtYXhbMV09bi50LGI9ITEpOihuLnM8dGhpcy5ibWluWzBdJiYodGhpcy5ibWluWzBdPW4ucyksbi5zPnRoaXMuYm1heFswXSYmKHRoaXMuYm1heFswXT1uLnMpLG4udDx0aGlzLmJtaW5bMV0mJih0aGlzLmJtaW5bMV09bi50KSxuLnQ+dGhpcy5ibWF4WzFdJiYodGhpcy5ibWF4WzFdPW4udCkpfSxhZGRXaW5kaW5nXzpmdW5jdGlvbihuLG8pe24ud2luZGluZys9by53aW5kaW5nLG4uU3ltLndpbmRpbmcrPW8uU3ltLndpbmRpbmd9LHRlc3NlbGxhdGVNb25vUmVnaW9uXzpmdW5jdGlvbihuLG8pe3ZhciBzLGw7Zm9yKHM9by5hbkVkZ2UsaChzLkxuZXh0IT09cyYmcy5MbmV4dC5MbmV4dCE9PXMpO2kudmVydExlcShzLkRzdCxzLk9yZyk7cz1zLkxwcmV2KTtmb3IoO2kudmVydExlcShzLk9yZyxzLkRzdCk7cz1zLkxuZXh0KTtmb3IobD1zLkxwcmV2O3MuTG5leHQhPT1sOylpZihpLnZlcnRMZXEocy5Ec3QsbC5PcmcpKXtmb3IoO2wuTG5leHQhPT1zJiYoaS5lZGdlR29lc0xlZnQobC5MbmV4dCl8fGkuZWRnZVNpZ24obC5PcmcsbC5Ec3QsbC5MbmV4dC5Ec3QpPD0wKTspe3ZhciBFPW4uY29ubmVjdChsLkxuZXh0LGwpO2w9RS5TeW19bD1sLkxwcmV2fWVsc2V7Zm9yKDtsLkxuZXh0IT09cyYmKGkuZWRnZUdvZXNSaWdodChzLkxwcmV2KXx8aS5lZGdlU2lnbihzLkRzdCxzLk9yZyxzLkxwcmV2Lk9yZyk+PTApOyl7dmFyIEU9bi5jb25uZWN0KHMscy5McHJldik7cz1FLlN5bX1zPXMuTG5leHR9Zm9yKGgobC5MbmV4dCE9PXMpO2wuTG5leHQuTG5leHQhPT1zOyl7dmFyIEU9bi5jb25uZWN0KGwuTG5leHQsbCk7bD1FLlN5bX1yZXR1cm4hMH0sdGVzc2VsbGF0ZUludGVyaW9yXzpmdW5jdGlvbihuKXt2YXIgbyxzO2ZvcihvPW4uZkhlYWQubmV4dDtvIT09bi5mSGVhZDtvPXMpaWYocz1vLm5leHQsby5pbnNpZGUmJiF0aGlzLnRlc3NlbGxhdGVNb25vUmVnaW9uXyhuLG8pKXJldHVybiExO3JldHVybiEwfSxkaXNjYXJkRXh0ZXJpb3JfOmZ1bmN0aW9uKG4pe3ZhciBvLHM7Zm9yKG89bi5mSGVhZC5uZXh0O28hPT1uLmZIZWFkO289cylzPW8ubmV4dCxvLmluc2lkZXx8bi56YXBGYWNlKG8pfSxzZXRXaW5kaW5nTnVtYmVyXzpmdW5jdGlvbihuLG8scyl7dmFyIGwsRTtmb3IobD1uLmVIZWFkLm5leHQ7bCE9PW4uZUhlYWQ7bD1FKUU9bC5uZXh0LGwuUmZhY2UuaW5zaWRlIT09bC5MZmFjZS5pbnNpZGU/bC53aW5kaW5nPWwuTGZhY2UuaW5zaWRlP286LW86cz9uLmRlbGV0ZShsKTpsLndpbmRpbmc9MH0sZ2V0TmVpZ2hib3VyRmFjZV86ZnVuY3Rpb24obil7cmV0dXJuIW4uUmZhY2V8fCFuLlJmYWNlLmluc2lkZT8tMTpuLlJmYWNlLm59LG91dHB1dFBvbHltZXNoXzpmdW5jdGlvbihuLG8scyxsKXt2YXIgRSxULGIsST0wLFA9MCxMLEQ7Zm9yKHM+MyYmbi5tZXJnZUNvbnZleEZhY2VzKHMpLEU9bi52SGVhZC5uZXh0O0UhPT1uLnZIZWFkO0U9RS5uZXh0KUUubj0tMTtmb3IoVD1uLmZIZWFkLm5leHQ7VCE9PW4uZkhlYWQ7VD1ULm5leHQpaWYoVC5uPS0xLCEhVC5pbnNpZGUpe2I9VC5hbkVkZ2UsTD0wO2RvIEU9Yi5PcmcsRS5uPT09LTEmJihFLm49UCxQKyspLEwrKyxiPWIuTG5leHQ7d2hpbGUoYiE9PVQuYW5FZGdlKTtoKEw8PXMpLFQubj1JLCsrSX1mb3IodGhpcy5lbGVtZW50Q291bnQ9SSxvPT09ci5DT05ORUNURURfUE9MWUdPTlMmJihJKj0yKSx0aGlzLmVsZW1lbnRzPVtdLHRoaXMuZWxlbWVudHMubGVuZ3RoPUkqcyx0aGlzLnZlcnRleENvdW50PVAsdGhpcy52ZXJ0aWNlcz1bXSx0aGlzLnZlcnRpY2VzLmxlbmd0aD1QKmwsdGhpcy52ZXJ0ZXhJbmRpY2VzPVtdLHRoaXMudmVydGV4SW5kaWNlcy5sZW5ndGg9UCxFPW4udkhlYWQubmV4dDtFIT09bi52SGVhZDtFPUUubmV4dClpZihFLm4hPT0tMSl7dmFyIFI9RS5uKmw7dGhpcy52ZXJ0aWNlc1tSKzBdPUUuY29vcmRzWzBdLHRoaXMudmVydGljZXNbUisxXT1FLmNvb3Jkc1sxXSxsPjImJih0aGlzLnZlcnRpY2VzW1IrMl09RS5jb29yZHNbMl0pLHRoaXMudmVydGV4SW5kaWNlc1tFLm5dPUUuaWR4fXZhciBBPTA7Zm9yKFQ9bi5mSGVhZC5uZXh0O1QhPT1uLmZIZWFkO1Q9VC5uZXh0KWlmKFQuaW5zaWRlKXtiPVQuYW5FZGdlLEw9MDtkbyBFPWIuT3JnLHRoaXMuZWxlbWVudHNbQSsrXT1FLm4sTCsrLGI9Yi5MbmV4dDt3aGlsZShiIT09VC5hbkVkZ2UpO2ZvcihEPUw7RDxzOysrRCl0aGlzLmVsZW1lbnRzW0ErK109LTE7aWYobz09PXIuQ09OTkVDVEVEX1BPTFlHT05TKXtiPVQuYW5FZGdlO2RvIHRoaXMuZWxlbWVudHNbQSsrXT10aGlzLmdldE5laWdoYm91ckZhY2VfKGIpLGI9Yi5MbmV4dDt3aGlsZShiIT09VC5hbkVkZ2UpO2ZvcihEPUw7RDxzOysrRCl0aGlzLmVsZW1lbnRzW0ErK109LTF9fX0sb3V0cHV0Q29udG91cnNfOmZ1bmN0aW9uKG4sbyl7dmFyIHMsbCxFLFQ9MCxiPTA7Zm9yKHRoaXMudmVydGV4Q291bnQ9MCx0aGlzLmVsZW1lbnRDb3VudD0wLHM9bi5mSGVhZC5uZXh0O3MhPT1uLmZIZWFkO3M9cy5uZXh0KWlmKHMuaW5zaWRlKXtFPWw9cy5hbkVkZ2U7ZG8gdGhpcy52ZXJ0ZXhDb3VudCsrLGw9bC5MbmV4dDt3aGlsZShsIT09RSk7dGhpcy5lbGVtZW50Q291bnQrK310aGlzLmVsZW1lbnRzPVtdLHRoaXMuZWxlbWVudHMubGVuZ3RoPXRoaXMuZWxlbWVudENvdW50KjIsdGhpcy52ZXJ0aWNlcz1bXSx0aGlzLnZlcnRpY2VzLmxlbmd0aD10aGlzLnZlcnRleENvdW50Km8sdGhpcy52ZXJ0ZXhJbmRpY2VzPVtdLHRoaXMudmVydGV4SW5kaWNlcy5sZW5ndGg9dGhpcy52ZXJ0ZXhDb3VudDt2YXIgST0wLFA9MCxMPTA7Zm9yKFQ9MCxzPW4uZkhlYWQubmV4dDtzIT09bi5mSGVhZDtzPXMubmV4dClpZihzLmluc2lkZSl7Yj0wLEU9bD1zLmFuRWRnZTtkbyB0aGlzLnZlcnRpY2VzW0krK109bC5PcmcuY29vcmRzWzBdLHRoaXMudmVydGljZXNbSSsrXT1sLk9yZy5jb29yZHNbMV0sbz4yJiYodGhpcy52ZXJ0aWNlc1tJKytdPWwuT3JnLmNvb3Jkc1syXSksdGhpcy52ZXJ0ZXhJbmRpY2VzW1ArK109bC5PcmcuaWR4LGIrKyxsPWwuTG5leHQ7d2hpbGUobCE9PUUpO3RoaXMuZWxlbWVudHNbTCsrXT1ULHRoaXMuZWxlbWVudHNbTCsrXT1iLFQrPWJ9fSxhZGRDb250b3VyOmZ1bmN0aW9uKG4sbyl7dmFyIHMsbDtmb3IodGhpcy5tZXNoPT09bnVsbCYmKHRoaXMubWVzaD1uZXcgYyksbjwyJiYobj0yKSxuPjMmJihuPTMpLHM9bnVsbCxsPTA7bDxvLmxlbmd0aDtsKz1uKXM9PT1udWxsPyhzPXRoaXMubWVzaC5tYWtlRWRnZSgpLHRoaXMubWVzaC5zcGxpY2UocyxzLlN5bSkpOih0aGlzLm1lc2guc3BsaXRFZGdlKHMpLHM9cy5MbmV4dCkscy5PcmcuY29vcmRzWzBdPW9bbCswXSxzLk9yZy5jb29yZHNbMV09b1tsKzFdLG4+Mj9zLk9yZy5jb29yZHNbMl09b1tsKzJdOnMuT3JnLmNvb3Jkc1syXT0wLHMuT3JnLmlkeD10aGlzLnZlcnRleEluZGV4Q291bnRlcisrLHMud2luZGluZz0xLHMuU3ltLndpbmRpbmc9LTF9LHRlc3NlbGF0ZTpmdW5jdGlvbihuLG8scyxsLEUpe2lmKHRoaXMudmVydGljZXM9W10sdGhpcy5lbGVtZW50cz1bXSx0aGlzLnZlcnRleEluZGljZXM9W10sdGhpcy52ZXJ0ZXhJbmRleENvdW50ZXI9MCxFJiYodGhpcy5ub3JtYWxbMF09RVswXSx0aGlzLm5vcm1hbFsxXT1FWzFdLHRoaXMubm9ybWFsWzJdPUVbMl0pLHRoaXMud2luZGluZ1J1bGU9bixsPDImJihsPTIpLGw+MyYmKGw9MyksIXRoaXMubWVzaClyZXR1cm4hMTt0aGlzLnByb2plY3RQb2x5Z29uXygpLG0uY29tcHV0ZUludGVyaW9yKHRoaXMpO3ZhciBUPXRoaXMubWVzaDtyZXR1cm4gbz09PXIuQk9VTkRBUllfQ09OVE9VUlM/dGhpcy5zZXRXaW5kaW5nTnVtYmVyXyhULDEsITApOnRoaXMudGVzc2VsbGF0ZUludGVyaW9yXyhUKSxULmNoZWNrKCksbz09PXIuQk9VTkRBUllfQ09OVE9VUlM/dGhpcy5vdXRwdXRDb250b3Vyc18oVCxsKTp0aGlzLm91dHB1dFBvbHltZXNoXyhULG8scyxsKSwhMH19fSxmdW5jdGlvbihTLGUpe1MuZXhwb3J0cz1yO3ZhciB0PU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7ZnVuY3Rpb24gcigpe2Zvcih2YXIgaT17fSxoPTA7aDxhcmd1bWVudHMubGVuZ3RoO2grKyl7dmFyIGc9YXJndW1lbnRzW2hdO2Zvcih2YXIgdSBpbiBnKXQuY2FsbChnLHUpJiYoaVt1XT1nW3VdKX1yZXR1cm4gaX19LGZ1bmN0aW9uKFMsZSx0KXt0LnIoZSksdC5kKGUsImNyZWF0ZVNoYWRlcnMiLGZ1bmN0aW9uKCl7cmV0dXJuIGF9KSx0LmQoZSwiYXBwbHlTaGFkZXIiLGZ1bmN0aW9uKCl7cmV0dXJuIGN9KSx0LmQoZSwiY3JlYXRlQ2xvdWRTaGFkZXJzIixmdW5jdGlvbigpe3JldHVybiBmfSksdC5kKGUsImFwcGx5Q2xvdWRTaGFkZXIiLGZ1bmN0aW9uKCl7cmV0dXJuIHZ9KTt2YXIgcj10KDY0KSxpPXQoNjUpLGg9dCg2NiksZz10KDY3KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3QgdT1TeW1ib2woInNoYWRlcnMiKTtmdW5jdGlvbiBhKHApe3BbdV09W107Zm9yKGxldCBDPTA7QzwxNjtDKyspe2NvbnN0IE09W10sbT0hIShDJjEpLHk9ISEoQyYyKSxuPSEhKEMmNCksbz0hIShDJjgpO20mJk0ucHVzaCgiI2RlZmluZSBURVhUVVJFIDEiKSx5JiZNLnB1c2goIiNkZWZpbmUgRklMVEVSIDEiKSxuJiZNLnB1c2goIiNkZWZpbmUgR1JBRElFTlQgMSIpLG8mJk0ucHVzaCgiI2RlZmluZSBDTElQUEFUSCAxIik7Y29uc3Qgcz1gJHtNLmpvaW4oYApgKX0KYCxsPVtdO20mJmwucHVzaCgidW5pZm9ybSBzYW1wbGVyMkQgdV90ZXhTYW1wbGVyOyIpLG8mJmwucHVzaCgidW5pZm9ybSBzYW1wbGVyMkQgdV9jbGlwU2FtcGxlcjsiKSxwW3VdW0NdPVtzK2wuam9pbihgCmApK2kuZGVmYXVsdCxzK3IuZGVmYXVsdF19fWZ1bmN0aW9uIGMocCx7aGFzVGV4dHVyZTpDPSExLGhhc0ZpbHRlcjpNPSExLGhhc0dyYWRpZW50Om09ITEsaGFzQ2xpcFBhdGg6eT0hMX09e30pe2NvbnN0IG49Q3xNPDwxfG08PDJ8eTw8MztsZXQgbz1wW3VdW25dO0FycmF5LmlzQXJyYXkobykmJihvPXAuY3JlYXRlUHJvZ3JhbSguLi5vKSxwW3VdW25dPW8pLHAucHJvZ3JhbSE9PW8mJnAudXNlUHJvZ3JhbShvLHthX2NvbG9yOnt0eXBlOiJVTlNJR05FRF9CWVRFIixub3JtYWxpemU6ITB9fSl9Y29uc3QgeD1bXTtmdW5jdGlvbiBmKHApe2ZvcihsZXQgQz0wO0M8NjQ7QysrKXtjb25zdCBNPVtdLG09ISEoQyYxKSx5PSEhKEMmMiksbj0hIShDJjQpLG89ISEoQyY4KSxzPSEhKEMmMTYpLGw9ISEoQyYzMik7bSYmTS5wdXNoKCIjZGVmaW5lIFRFWFRVUkUgMSIpLHkmJk0ucHVzaCgiI2RlZmluZSBGSUxURVIgMSIpLG4mJk0ucHVzaCgiI2RlZmluZSBHUkFESUVOVCAxIiksbyYmTS5wdXNoKCIjZGVmaW5lIENMT1VEQ09MT1IgMSIpLHMmJk0ucHVzaCgiI2RlZmluZSBDTE9VREZJTFRFUiAxIiksbCYmTS5wdXNoKCIjZGVmaW5lIENMSVBQQVRIIDEiKTtjb25zdCBFPWAke00uam9pbihgCmApfQpgLFQ9W107aWYobSl7VC5wdXNoKCJ1bmlmb3JtIHNhbXBsZXIyRCB1X3RleFNhbXBsZXI7Iik7Zm9yKGxldCBiPTA7YjwxMjtiKyspVC5wdXNoKGB1bmlmb3JtIHNhbXBsZXIyRCB1X3RleEZyYW1lJHtifTtgKX1sJiZULnB1c2goInVuaWZvcm0gc2FtcGxlcjJEIHVfY2xpcFNhbXBsZXI7IikseFtDXT1bRStULmpvaW4oYApgKStnLmRlZmF1bHQsRStoLmRlZmF1bHRdfX1mdW5jdGlvbiB2KHAse2hhc1RleHR1cmU6Qz0hMSxoYXNGaWx0ZXI6TT0hMSxoYXNHcmFkaWVudDptPSExLGhhc0Nsb3VkQ29sb3I6eT0hMSxoYXNDbG91ZEZpbHRlcjpuPSExLGhhc0NsaXBQYXRoOm89ITF9PXt9KXtjb25zdCBzPUN8TTw8MXxtPDwyfHk8PDN8bjw8NHxvPDw1O2xldCBsPXhbc107QXJyYXkuaXNBcnJheShsKSYmKGw9cC5jcmVhdGVQcm9ncmFtKC4uLmwpLHhbc109bCkscC5wcm9ncmFtIT09bCYmcC51c2VQcm9ncmFtKGwse2FfY29sb3I6e3R5cGU6IlVOU0lHTkVEX0JZVEUiLG5vcm1hbGl6ZTohMH0sYV9maWxsQ2xvdWRDb2xvcjp7dHlwZToiVU5TSUdORURfQllURSIsbm9ybWFsaXplOiEwfSxhX3N0cm9rZUNsb3VkQ29sb3I6e3R5cGU6IlVOU0lHTkVEX0JZVEUiLG5vcm1hbGl6ZTohMH0sYV9mcmFtZUluZGV4Ont0eXBlOiJVTlNJR05FRF9CWVRFIixub3JtYWxpemU6ITF9fSl9fSxmdW5jdGlvbihTLGUsdCl7dC5yKGUpLGUuZGVmYXVsdD1gYXR0cmlidXRlIHZlYzMgYV92ZXJ0ZXhQb3NpdGlvbjsKYXR0cmlidXRlIHZlYzQgYV9jb2xvcjsKdmFyeWluZyB2ZWM0IHZDb2xvcjsKdmFyeWluZyBmbG9hdCBmbGFnQmFja2dyb3VuZDsKdW5pZm9ybSB2ZWMyIHVfcmVzb2x1dGlvbjsKdW5pZm9ybSBtYXQzIHZpZXdNYXRyaXg7CnVuaWZvcm0gbWF0MyBwcm9qZWN0aW9uTWF0cml4OwoKI2lmZGVmIFRFWFRVUkUKYXR0cmlidXRlIHZlYzMgYV92ZXJ0ZXhUZXh0dXJlQ29vcmQ7CnZhcnlpbmcgdmVjMyB2VGV4dHVyZUNvb3JkOwphdHRyaWJ1dGUgdmVjNCBhX3NvdXJjZVJlY3Q7CnZhcnlpbmcgdmVjNCB2U291cmNlUmVjdDsKI2VuZGlmCgojaWZkZWYgQ0xJUFBBVEgKYXR0cmlidXRlIHZlYzIgYV9jbGlwVVY7CnZhcnlpbmcgdmVjMiB2Q2xpcFVWOwojZW5kaWYKCiNpZmRlZiBHUkFESUVOVAp1bmlmb3JtIGZsb2F0IHVfcmFkaWFsR3JhZGllbnRWZWN0b3JbNl07CnZhcnlpbmcgdmVjMyB2R3JhZGllbnRWZWN0b3IxOwp2YXJ5aW5nIHZlYzMgdkdyYWRpZW50VmVjdG9yMjsKI2VuZGlmCgp2b2lkIG1haW4oKSB7CiAgZ2xfUG9pbnRTaXplID0gMS4wOwoKICB2ZWMzIHBvcyA9IHByb2plY3Rpb25NYXRyaXggKiB2aWV3TWF0cml4ICogdmVjMyhhX3ZlcnRleFBvc2l0aW9uLnh5LCAxLjApOwogIGdsX1Bvc2l0aW9uID0gdmVjNChwb3MueHksIDEuMCwgMS4wKTsKCiNpZmRlZiBHUkFESUVOVAogIHZlYzMgdmcxID0gdmlld01hdHJpeCAqIHZlYzModV9yYWRpYWxHcmFkaWVudFZlY3RvclswXSwgdV9yYWRpYWxHcmFkaWVudFZlY3RvclsxXSwgMS4wKTsKICB2ZWMzIHZnMiA9IHZpZXdNYXRyaXggKiB2ZWMzKHVfcmFkaWFsR3JhZGllbnRWZWN0b3JbM10sIHVfcmFkaWFsR3JhZGllbnRWZWN0b3JbNF0sIDEuMCk7CiAgZmxvYXQgaCA9IHVfcmVzb2x1dGlvbi55OwogIHZnMS55ID0gaCAtIHZnMS55OwogIHZnMi55ID0gaCAtIHZnMi55OwogIHZHcmFkaWVudFZlY3RvcjEgPSB2ZWMzKHZnMS54eSwgdV9yYWRpYWxHcmFkaWVudFZlY3RvclsyXSk7CiAgdkdyYWRpZW50VmVjdG9yMiA9IHZlYzModmcyLnh5LCB1X3JhZGlhbEdyYWRpZW50VmVjdG9yWzVdKTsKI2VuZGlmCiAgCiAgZmxhZ0JhY2tncm91bmQgPSBhX3ZlcnRleFBvc2l0aW9uLno7CiAgdkNvbG9yID0gYV9jb2xvcjsKCiNpZmRlZiBURVhUVVJFCiAgdlRleHR1cmVDb29yZCA9IGFfdmVydGV4VGV4dHVyZUNvb3JkOwogIHZTb3VyY2VSZWN0ID0gYV9zb3VyY2VSZWN0OwojZW5kaWYKCiNpZmRlZiBDTElQUEFUSAogIHZDbGlwVVYgPSBhX2NsaXBVVjsKI2VuZGlmCn1gfSxmdW5jdGlvbihTLGUsdCl7dC5yKGUpLGUuZGVmYXVsdD1gcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7Cgp2YXJ5aW5nIHZlYzQgdkNvbG9yOwp2YXJ5aW5nIGZsb2F0IGZsYWdCYWNrZ3JvdW5kOwoKI2lmZGVmIFRFWFRVUkUKdmFyeWluZyB2ZWMzIHZUZXh0dXJlQ29vcmQ7CnZhcnlpbmcgdmVjNCB2U291cmNlUmVjdDsKI2VuZGlmCgojaWZkZWYgQ0xJUFBBVEgKdmFyeWluZyB2ZWMyIHZDbGlwVVY7CiNlbmRpZgoKI2lmZGVmIEZJTFRFUgp1bmlmb3JtIGludCB1X2ZpbHRlckZsYWc7CnVuaWZvcm0gZmxvYXQgdV9jb2xvck1hdHJpeFsyMF07CiNlbmRpZgoKI2lmZGVmIEdSQURJRU5UCnZhcnlpbmcgdmVjMyB2R3JhZGllbnRWZWN0b3IxOwp2YXJ5aW5nIHZlYzMgdkdyYWRpZW50VmVjdG9yMjsKdW5pZm9ybSBmbG9hdCB1X2NvbG9yU3RlcHNbNDBdOwp1bmlmb3JtIGludCB1X2dyYWRpZW50VHlwZTsKLy8gdW5pZm9ybSBmbG9hdCB1X3JhZGlhbEdyYWRpZW50VmVjdG9yWzZdOwoKdm9pZCBncmFkaWVudChpbm91dCB2ZWM0IGNvbG9yLCB2ZWMzIGd2MSwgdmVjMyBndjIsIGZsb2F0IGNvbG9yU3RlcHNbNDBdKSB7CiAgZmxvYXQgdDsKICAvLyBjZW50ZXIgY2lyY2xlIHJhZGl1cwogIGZsb2F0IGNyID0gZ3YxLno7CiAgLy8gZm9jYWwgY2lyY2xlIHJhZGl1cwogIGZsb2F0IGZyID0gZ3YyLno7CgogIGlmKGNyID4gMC4wIHx8IGZyID4gMC4wKSB7CiAgICAvLyByYWRpYWwgZ3JhZGllbnQKICAgIHZlYzIgY2VudGVyID0gZ3YxLnh5OwogICAgdmVjMiBmb2NhbCA9IGd2Mi54eTsKICAgIGZsb2F0IHggPSBmb2NhbC54IC0gZ2xfRnJhZ0Nvb3JkLng7CiAgICBmbG9hdCB5ID0gZm9jYWwueSAtIGdsX0ZyYWdDb29yZC55OwogICAgZmxvYXQgZHggPSBmb2NhbC54IC0gY2VudGVyLng7CiAgICBmbG9hdCBkeSA9IGZvY2FsLnkgLSBjZW50ZXIueTsKICAgIGZsb2F0IGRyID0gY3IgLSBmcjsKICAgIGZsb2F0IGEgPSBkeCAqIGR4ICsgZHkgKiBkeSAtIGRyICogZHI7CiAgICBmbG9hdCBiID0gLTIuMCAqICh5ICogZHkgKyB4ICogZHggKyBmciAqIGRyKTsKICAgIGZsb2F0IGMgPSB4ICogeCArIHkgKiB5IC0gZnIgKiBmcjsKICAgIHQgPSAxLjAgLSAwLjUgKiAoMS4wIC8gYSkgKiAoLWIgKyBzcXJ0KGIgKiBiIC0gNC4wICogYSAqIGMpKTsKICB9IGVsc2UgewogICAgLy8gbGluZWFyIGdyYWRpZW50CiAgICB2ZWMyIHYxID0gZ2xfRnJhZ0Nvb3JkLnh5IC0gZ3YxLnh5OwogICAgdmVjMiB2MiA9IGd2Mi54eSAtIGd2MS54eTsKICAgIHQgPSAodjEueCAqIHYyLnggKyB2MS55ICogdjIueSkgLyAodjIueCAqIHYyLnggKyB2Mi55ICogdjIueSk7CiAgfQoKICB2ZWM0IGNvbG9yc1s4XTsKICBjb2xvcnNbMF0gPSB2ZWM0KGNvbG9yU3RlcHNbMV0sIGNvbG9yU3RlcHNbMl0sIGNvbG9yU3RlcHNbM10sIGNvbG9yU3RlcHNbNF0pOwogIGNvbG9yc1sxXSA9IHZlYzQoY29sb3JTdGVwc1s2XSwgY29sb3JTdGVwc1s3XSwgY29sb3JTdGVwc1s4XSwgY29sb3JTdGVwc1s5XSk7CiAgY29sb3JzWzJdID0gdmVjNChjb2xvclN0ZXBzWzExXSwgY29sb3JTdGVwc1sxMl0sIGNvbG9yU3RlcHNbMTNdLCBjb2xvclN0ZXBzWzE0XSk7CiAgY29sb3JzWzNdID0gdmVjNChjb2xvclN0ZXBzWzE2XSwgY29sb3JTdGVwc1sxN10sIGNvbG9yU3RlcHNbMThdLCBjb2xvclN0ZXBzWzE5XSk7CiAgY29sb3JzWzRdID0gdmVjNChjb2xvclN0ZXBzWzIxXSwgY29sb3JTdGVwc1syMl0sIGNvbG9yU3RlcHNbMjNdLCBjb2xvclN0ZXBzWzI0XSk7CiAgY29sb3JzWzVdID0gdmVjNChjb2xvclN0ZXBzWzI2XSwgY29sb3JTdGVwc1syN10sIGNvbG9yU3RlcHNbMjhdLCBjb2xvclN0ZXBzWzI5XSk7CiAgY29sb3JzWzZdID0gdmVjNChjb2xvclN0ZXBzWzMxXSwgY29sb3JTdGVwc1szMl0sIGNvbG9yU3RlcHNbMzNdLCBjb2xvclN0ZXBzWzM0XSk7CiAgY29sb3JzWzddID0gdmVjNChjb2xvclN0ZXBzWzM2XSwgY29sb3JTdGVwc1szN10sIGNvbG9yU3RlcHNbMzhdLCBjb2xvclN0ZXBzWzM5XSk7CiAgCiAgZmxvYXQgc3RlcHNbOF07CiAgc3RlcHNbMF0gPSBjb2xvclN0ZXBzWzBdOwogIHN0ZXBzWzFdID0gY29sb3JTdGVwc1s1XTsKICBzdGVwc1syXSA9IGNvbG9yU3RlcHNbMTBdOwogIHN0ZXBzWzNdID0gY29sb3JTdGVwc1sxNV07CiAgc3RlcHNbNF0gPSBjb2xvclN0ZXBzWzIwXTsKICBzdGVwc1s1XSA9IGNvbG9yU3RlcHNbMjVdOwogIHN0ZXBzWzZdID0gY29sb3JTdGVwc1szMF07CiAgc3RlcHNbN10gPSBjb2xvclN0ZXBzWzM1XTsKCiAgY29sb3IgPSBjb2xvcnNbMF07CiAgZm9yIChpbnQgaSA9IDE7IGkgPCA4OyBpKyspIHsKICAgIGlmIChzdGVwc1tpXSA8IDAuMCB8fCBzdGVwc1tpXSA+IDEuMCkgewogICAgICBicmVhazsKICAgIH0KICAgIGlmKHN0ZXBzW2ldID09IHN0ZXBzW2kgLSAxXSkgewogICAgICBjb2xvciA9IGNvbG9yc1tpXTsKICAgIH0gZWxzZSB7CiAgICAgIGNvbG9yID0gbWl4KGNvbG9yLCBjb2xvcnNbaV0sIGNsYW1wKCh0IC0gc3RlcHNbaSAtIDFdKSAvIChzdGVwc1tpXSAtIHN0ZXBzW2kgLSAxXSksIDAuMCwgMS4wKSk7CiAgICB9CiAgICBpZiAoc3RlcHNbaV0gPj0gdCkgewogICAgICBicmVhazsKICAgIH0KICB9Cn0KI2VuZGlmCgojaWZkZWYgRklMVEVSCnZvaWQgdHJhbnNmb3JtQ29sb3IoaW5vdXQgdmVjNCBjb2xvciwgaW4gZmxvYXQgY29sb3JNYXRyaXhbMjBdKSB7CiAgZmxvYXQgciA9IGNvbG9yLnIsIGcgPSBjb2xvci5nLCBiID0gY29sb3IuYiwgYSA9IGNvbG9yLmE7CiAgY29sb3JbMF0gPSBjb2xvck1hdHJpeFswXSAqIHIgKyBjb2xvck1hdHJpeFsxXSAqIGcgKyBjb2xvck1hdHJpeFsyXSAqIGIgKyBjb2xvck1hdHJpeFszXSAqIGEgKyBjb2xvck1hdHJpeFs0XTsKICBjb2xvclsxXSA9IGNvbG9yTWF0cml4WzVdICogciArIGNvbG9yTWF0cml4WzZdICogZyArIGNvbG9yTWF0cml4WzddICogYiArIGNvbG9yTWF0cml4WzhdICogYSArIGNvbG9yTWF0cml4WzldOwogIGNvbG9yWzJdID0gY29sb3JNYXRyaXhbMTBdICogciArIGNvbG9yTWF0cml4WzExXSAqIGcgKyBjb2xvck1hdHJpeFsxMl0gKiBiICsgY29sb3JNYXRyaXhbMTNdICogYSArIGNvbG9yTWF0cml4WzE0XTsKICBjb2xvclszXSA9IGNvbG9yTWF0cml4WzE1XSAqIHIgKyBjb2xvck1hdHJpeFsxNl0gKiBnICsgY29sb3JNYXRyaXhbMTddICogYiArIGNvbG9yTWF0cml4WzE4XSAqIGEgKyBjb2xvck1hdHJpeFsxOV07Cn0KI2VuZGlmCgp2b2lkIG1haW4oKSB7CiAgdmVjNCBjb2xvciA9IHZDb2xvcjsKICBmbG9hdCBvcGFjaXR5ID0gYWJzKGZsYWdCYWNrZ3JvdW5kKTsKCiNpZmRlZiBHUkFESUVOVAogIGlmKHVfZ3JhZGllbnRUeXBlID4gMCAmJiBmbGFnQmFja2dyb3VuZCA+IDAuMCB8fCB1X2dyYWRpZW50VHlwZSA9PSAwICYmIGZsYWdCYWNrZ3JvdW5kIDw9IDAuMCkgewogICAgZ3JhZGllbnQoY29sb3IsIHZHcmFkaWVudFZlY3RvcjEsIHZHcmFkaWVudFZlY3RvcjIsIHVfY29sb3JTdGVwcyk7CiAgfQojZW5kaWYKCiAgaWYob3BhY2l0eSA8IDEuMCkgewogICAgY29sb3IuYSAqPSBvcGFjaXR5OwogIH0KCiNpZmRlZiBURVhUVVJFCiAgaWYoZmxhZ0JhY2tncm91bmQgPiAwLjApIHsKICAgIHZlYzMgdGV4Q29vcmQgPSB2VGV4dHVyZUNvb3JkOwoKICAgIGlmKHRleENvb3JkLnogPT0gMS4wKSB7CiAgICAgIHRleENvb3JkID0gZnJhY3QodGV4Q29vcmQpOwogICAgfQoKICAgIGlmKHRleENvb3JkLnggPD0gMS4wICYmIHRleENvb3JkLnggPj0gMC4wCiAgICAgICYmIHRleENvb3JkLnkgPD0gMS4wICYmIHRleENvb3JkLnkgPj0gMC4wKSB7CiAgICAgIGlmKHZTb3VyY2VSZWN0LnogPiAwLjApIHsKICAgICAgICB0ZXhDb29yZC54ID0gdlNvdXJjZVJlY3QueCArIHRleENvb3JkLnggKiB2U291cmNlUmVjdC56OwogICAgICAgIHRleENvb3JkLnkgPSAxLjAgLSAodlNvdXJjZVJlY3QueSArICgxLjAgLSB0ZXhDb29yZC55KSAqIHZTb3VyY2VSZWN0LncpOwogICAgICB9CiAgICAgIHZlYzQgdGV4Q29sb3IgPSB0ZXh0dXJlMkQodV90ZXhTYW1wbGVyLCB0ZXhDb29yZC54eSk7CiAgICAgIGZsb2F0IGFscGhhID0gdGV4Q29sb3IuYTsKICAgICAgaWYob3BhY2l0eSA8IDEuMCkgewogICAgICAgIHRleENvbG9yLmEgKj0gb3BhY2l0eTsKICAgICAgICBhbHBoYSAqPSBtaXgoMC40NjUsIDEuMCwgb3BhY2l0eSk7CiAgICAgIH0KICAgICAgLy8gY29sb3IgPSBtaXgoY29sb3IsIHRleENvbG9yLCB0ZXhDb2xvci5hKTsKICAgICAgY29sb3IucmdiID0gbWl4KGNvbG9yLnJnYiwgdGV4Q29sb3IucmdiLCBhbHBoYSk7CiAgICAgIC8vIGNvbG9yLnJnYiA9IG1peCh0ZXhDb2xvci5yZ2IsIGNvbG9yLnJnYiwgY29sb3IuYSk7CiAgICAgIGNvbG9yLnJnYiA9IG1peCh0ZXhDb2xvci5yZ2IsIGNvbG9yLnJnYiwgY2xhbXAoY29sb3IuYSAvIG1heCgwLjAwMDEsIHRleENvbG9yLmEpLCAwLjAsIDEuMCkpOwogICAgICBjb2xvci5hID0gdGV4Q29sb3IuYSArICgxLjAgLSB0ZXhDb2xvci5hKSAqIGNvbG9yLmE7CiAgICB9CiAgfQojZW5kaWYKCiNpZmRlZiBGSUxURVIKICBpZih1X2ZpbHRlckZsYWcgPiAwKSB7CiAgICB0cmFuc2Zvcm1Db2xvcihjb2xvciwgdV9jb2xvck1hdHJpeCk7CiAgfQojZW5kaWYKCiNpZmRlZiBDTElQUEFUSAogIGZsb2F0IGNsaXAgPSB0ZXh0dXJlMkQodV9jbGlwU2FtcGxlciwgdkNsaXBVVikucjsKICBjb2xvciAqPSBjbGlwOwojZW5kaWYKCiAgZ2xfRnJhZ0NvbG9yID0gY29sb3I7Cn1gfSxmdW5jdGlvbihTLGUsdCl7dC5yKGUpLGUuZGVmYXVsdD1gYXR0cmlidXRlIHZlYzMgYV92ZXJ0ZXhQb3NpdGlvbjsKYXR0cmlidXRlIHZlYzQgYV9jb2xvcjsKdmFyeWluZyB2ZWM0IHZDb2xvcjsKdmFyeWluZyBmbG9hdCBmbGFnQmFja2dyb3VuZDsKYXR0cmlidXRlIHZlYzMgYV90cmFuc2Zvcm0wOwphdHRyaWJ1dGUgdmVjMyBhX3RyYW5zZm9ybTE7CnVuaWZvcm0gdmVjMiB1X3Jlc29sdXRpb247CnVuaWZvcm0gbWF0MyB2aWV3TWF0cml4Owp1bmlmb3JtIG1hdDMgcHJvamVjdGlvbk1hdHJpeDsKCiNpZmRlZiBURVhUVVJFCmF0dHJpYnV0ZSB2ZWMzIGFfdmVydGV4VGV4dHVyZUNvb3JkOwp2YXJ5aW5nIHZlYzMgdlRleHR1cmVDb29yZDsKYXR0cmlidXRlIGZsb2F0IGFfZnJhbWVJbmRleDsKdmFyeWluZyBmbG9hdCBmcmFtZUluZGV4OwphdHRyaWJ1dGUgdmVjNCBhX3NvdXJjZVJlY3Q7CnZhcnlpbmcgdmVjNCB2U291cmNlUmVjdDsKI2VuZGlmCgojaWZkZWYgQ0xJUFBBVEgKYXR0cmlidXRlIHZlYzIgYV9jbGlwVVY7CnZhcnlpbmcgdmVjMiB2Q2xpcFVWOwojZW5kaWYKCiNpZmRlZiBDTE9VREZJTFRFUgphdHRyaWJ1dGUgdmVjNCBhX2NvbG9yQ2xvdWQwOwphdHRyaWJ1dGUgdmVjNCBhX2NvbG9yQ2xvdWQxOwphdHRyaWJ1dGUgdmVjNCBhX2NvbG9yQ2xvdWQyOwphdHRyaWJ1dGUgdmVjNCBhX2NvbG9yQ2xvdWQzOwphdHRyaWJ1dGUgdmVjNCBhX2NvbG9yQ2xvdWQ0Owp2YXJ5aW5nIHZlYzQgY29sb3JDbG91ZDA7CnZhcnlpbmcgdmVjNCBjb2xvckNsb3VkMTsKdmFyeWluZyB2ZWM0IGNvbG9yQ2xvdWQyOwp2YXJ5aW5nIHZlYzQgY29sb3JDbG91ZDM7CnZhcnlpbmcgdmVjNCBjb2xvckNsb3VkNDsKI2VuZGlmCgojaWZkZWYgQ0xPVURDT0xPUgphdHRyaWJ1dGUgdmVjNCBhX2ZpbGxDbG91ZENvbG9yOwphdHRyaWJ1dGUgdmVjNCBhX3N0cm9rZUNsb3VkQ29sb3I7CiNlbmRpZgoKI2lmZGVmIEdSQURJRU5UCnVuaWZvcm0gZmxvYXQgdV9yYWRpYWxHcmFkaWVudFZlY3Rvcls2XTsKdmFyeWluZyB2ZWMzIHZHcmFkaWVudFZlY3RvcjE7CnZhcnlpbmcgdmVjMyB2R3JhZGllbnRWZWN0b3IyOwojZW5kaWYKCnZvaWQgbWFpbigpIHsKICBnbF9Qb2ludFNpemUgPSAxLjA7CgogIG1hdDMgbW9kZWxNYXRyaXggPSBtYXQzKAogICAgYV90cmFuc2Zvcm0wLngsIGFfdHJhbnNmb3JtMS54LCAwLCAKICAgIGFfdHJhbnNmb3JtMC55LCBhX3RyYW5zZm9ybTEueSwgMCwKICAgIGFfdHJhbnNmb3JtMC56LCBhX3RyYW5zZm9ybTEueiwgMQogICk7CgogIHZlYzMgcG9zID0gcHJvamVjdGlvbk1hdHJpeCAqIHZpZXdNYXRyaXggKiBtb2RlbE1hdHJpeCAqIHZlYzMoYV92ZXJ0ZXhQb3NpdGlvbi54eSwgMS4wKTsKICBnbF9Qb3NpdGlvbiA9IHZlYzQocG9zLnh5LCAxLjAsIDEuMCk7CgojaWZkZWYgR1JBRElFTlQKICB2ZWMzIHZnMSA9IHZpZXdNYXRyaXggKiB2ZWMzKHVfcmFkaWFsR3JhZGllbnRWZWN0b3JbMF0sIHVfcmFkaWFsR3JhZGllbnRWZWN0b3JbMV0sIDEuMCk7CiAgdmVjMyB2ZzIgPSB2aWV3TWF0cml4ICogdmVjMyh1X3JhZGlhbEdyYWRpZW50VmVjdG9yWzNdLCB1X3JhZGlhbEdyYWRpZW50VmVjdG9yWzRdLCAxLjApOwogIGZsb2F0IGggPSB1X3Jlc29sdXRpb24ueTsKICB2ZzEueSA9IGggLSB2ZzEueTsKICB2ZzIueSA9IGggLSB2ZzIueTsKICB2R3JhZGllbnRWZWN0b3IxID0gdmVjMyh2ZzEueHksIHVfcmFkaWFsR3JhZGllbnRWZWN0b3JbMl0pOwogIHZHcmFkaWVudFZlY3RvcjIgPSB2ZWMzKHZnMi54eSwgdV9yYWRpYWxHcmFkaWVudFZlY3Rvcls1XSk7CiNlbmRpZgogIAogIGZsYWdCYWNrZ3JvdW5kID0gYV92ZXJ0ZXhQb3NpdGlvbi56OwoKI2lmZGVmIENMT1VEQ09MT1IKICBpZihmbGFnQmFja2dyb3VuZCA+IDAuMCkgewogICAgdkNvbG9yID0gbWl4KGFfY29sb3IsIGFfZmlsbENsb3VkQ29sb3IsIGFfZmlsbENsb3VkQ29sb3IuYSk7CiAgfSBlbHNlIHsKICAgIHZDb2xvciA9IG1peChhX2NvbG9yLCBhX3N0cm9rZUNsb3VkQ29sb3IsIGFfc3Ryb2tlQ2xvdWRDb2xvci5hKTsKICB9CiNlbHNlCiAgdkNvbG9yID0gYV9jb2xvcjsKI2VuZGlmCgojaWZkZWYgVEVYVFVSRQogIHZUZXh0dXJlQ29vcmQgPSBhX3ZlcnRleFRleHR1cmVDb29yZDsKICBmcmFtZUluZGV4ID0gYV9mcmFtZUluZGV4OwogIHZTb3VyY2VSZWN0ID0gYV9zb3VyY2VSZWN0OwojZW5kaWYKCiNpZmRlZiBDTElQUEFUSAogIHZDbGlwVVYgPSBhX2NsaXBVVjsKI2VuZGlmCgojaWZkZWYgQ0xPVURGSUxURVIKICBjb2xvckNsb3VkMCA9IGFfY29sb3JDbG91ZDA7CiAgY29sb3JDbG91ZDEgPSBhX2NvbG9yQ2xvdWQxOwogIGNvbG9yQ2xvdWQyID0gYV9jb2xvckNsb3VkMjsKICBjb2xvckNsb3VkMyA9IGFfY29sb3JDbG91ZDM7CiAgY29sb3JDbG91ZDQgPSBhX2NvbG9yQ2xvdWQ0OwojZW5kaWYKfWB9LGZ1bmN0aW9uKFMsZSx0KXt0LnIoZSksZS5kZWZhdWx0PWBwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDsKCnZhcnlpbmcgdmVjNCB2Q29sb3I7CnZhcnlpbmcgZmxvYXQgZmxhZ0JhY2tncm91bmQ7CgojaWZkZWYgVEVYVFVSRQp2YXJ5aW5nIGZsb2F0IGZyYW1lSW5kZXg7CnZhcnlpbmcgdmVjMyB2VGV4dHVyZUNvb3JkOwp2YXJ5aW5nIHZlYzQgdlNvdXJjZVJlY3Q7CiNlbmRpZgoKI2lmZGVmIENMSVBQQVRICnZhcnlpbmcgdmVjMiB2Q2xpcFVWOwojZW5kaWYKCiNpZmRlZiBGSUxURVIKdW5pZm9ybSBpbnQgdV9maWx0ZXJGbGFnOwp1bmlmb3JtIGZsb2F0IHVfY29sb3JNYXRyaXhbMjBdOwojZW5kaWYKCiNpZmRlZiBDTE9VREZJTFRFUgp2YXJ5aW5nIHZlYzQgY29sb3JDbG91ZDA7CnZhcnlpbmcgdmVjNCBjb2xvckNsb3VkMTsKdmFyeWluZyB2ZWM0IGNvbG9yQ2xvdWQyOwp2YXJ5aW5nIHZlYzQgY29sb3JDbG91ZDM7CnZhcnlpbmcgdmVjNCBjb2xvckNsb3VkNDsKI2VuZGlmCgojaWZkZWYgR1JBRElFTlQKdmFyeWluZyB2ZWMzIHZHcmFkaWVudFZlY3RvcjE7CnZhcnlpbmcgdmVjMyB2R3JhZGllbnRWZWN0b3IyOwp1bmlmb3JtIGZsb2F0IHVfY29sb3JTdGVwc1s0MF07CnVuaWZvcm0gaW50IHVfZ3JhZGllbnRUeXBlOwoKdm9pZCBncmFkaWVudChpbm91dCB2ZWM0IGNvbG9yLCB2ZWMzIGd2MSwgdmVjMyBndjIsIGZsb2F0IGNvbG9yU3RlcHNbNDBdKSB7CiAgZmxvYXQgdDsKICAvLyBjZW50ZXIgY2lyY2xlIHJhZGl1cwogIGZsb2F0IGNyID0gZ3YxLno7CiAgLy8gZm9jYWwgY2lyY2xlIHJhZGl1cwogIGZsb2F0IGZyID0gZ3YyLno7CgogIGlmKGNyID4gMC4wIHx8IGZyID4gMC4wKSB7CiAgICAvLyByYWRpYWwgZ3JhZGllbnQKICAgIHZlYzIgY2VudGVyID0gZ3YxLnh5OwogICAgdmVjMiBmb2NhbCA9IGd2Mi54eTsKICAgIGZsb2F0IHggPSBmb2NhbC54IC0gZ2xfRnJhZ0Nvb3JkLng7CiAgICBmbG9hdCB5ID0gZm9jYWwueSAtIGdsX0ZyYWdDb29yZC55OwogICAgZmxvYXQgZHggPSBmb2NhbC54IC0gY2VudGVyLng7CiAgICBmbG9hdCBkeSA9IGZvY2FsLnkgLSBjZW50ZXIueTsKICAgIGZsb2F0IGRyID0gY3IgLSBmcjsKICAgIGZsb2F0IGEgPSBkeCAqIGR4ICsgZHkgKiBkeSAtIGRyICogZHI7CiAgICBmbG9hdCBiID0gLTIuMCAqICh5ICogZHkgKyB4ICogZHggKyBmciAqIGRyKTsKICAgIGZsb2F0IGMgPSB4ICogeCArIHkgKiB5IC0gZnIgKiBmcjsKICAgIHQgPSAxLjAgLSAwLjUgKiAoMS4wIC8gYSkgKiAoLWIgKyBzcXJ0KGIgKiBiIC0gNC4wICogYSAqIGMpKTsKICB9IGVsc2UgewogICAgLy8gbGluZWFyIGdyYWRpZW50CiAgICB2ZWMyIHYxID0gZ2xfRnJhZ0Nvb3JkLnh5IC0gZ3YxLnh5OwogICAgdmVjMiB2MiA9IGd2Mi54eSAtIGd2MS54eTsKICAgIHQgPSAodjEueCAqIHYyLnggKyB2MS55ICogdjIueSkgLyAodjIueCAqIHYyLnggKyB2Mi55ICogdjIueSk7CiAgfQoKICB2ZWM0IGNvbG9yc1s4XTsKICBjb2xvcnNbMF0gPSB2ZWM0KGNvbG9yU3RlcHNbMV0sIGNvbG9yU3RlcHNbMl0sIGNvbG9yU3RlcHNbM10sIGNvbG9yU3RlcHNbNF0pOwogIGNvbG9yc1sxXSA9IHZlYzQoY29sb3JTdGVwc1s2XSwgY29sb3JTdGVwc1s3XSwgY29sb3JTdGVwc1s4XSwgY29sb3JTdGVwc1s5XSk7CiAgY29sb3JzWzJdID0gdmVjNChjb2xvclN0ZXBzWzExXSwgY29sb3JTdGVwc1sxMl0sIGNvbG9yU3RlcHNbMTNdLCBjb2xvclN0ZXBzWzE0XSk7CiAgY29sb3JzWzNdID0gdmVjNChjb2xvclN0ZXBzWzE2XSwgY29sb3JTdGVwc1sxN10sIGNvbG9yU3RlcHNbMThdLCBjb2xvclN0ZXBzWzE5XSk7CiAgY29sb3JzWzRdID0gdmVjNChjb2xvclN0ZXBzWzIxXSwgY29sb3JTdGVwc1syMl0sIGNvbG9yU3RlcHNbMjNdLCBjb2xvclN0ZXBzWzI0XSk7CiAgY29sb3JzWzVdID0gdmVjNChjb2xvclN0ZXBzWzI2XSwgY29sb3JTdGVwc1syN10sIGNvbG9yU3RlcHNbMjhdLCBjb2xvclN0ZXBzWzI5XSk7CiAgY29sb3JzWzZdID0gdmVjNChjb2xvclN0ZXBzWzMxXSwgY29sb3JTdGVwc1szMl0sIGNvbG9yU3RlcHNbMzNdLCBjb2xvclN0ZXBzWzM0XSk7CiAgY29sb3JzWzddID0gdmVjNChjb2xvclN0ZXBzWzM2XSwgY29sb3JTdGVwc1szN10sIGNvbG9yU3RlcHNbMzhdLCBjb2xvclN0ZXBzWzM5XSk7CiAgCiAgZmxvYXQgc3RlcHNbOF07CiAgc3RlcHNbMF0gPSBjb2xvclN0ZXBzWzBdOwogIHN0ZXBzWzFdID0gY29sb3JTdGVwc1s1XTsKICBzdGVwc1syXSA9IGNvbG9yU3RlcHNbMTBdOwogIHN0ZXBzWzNdID0gY29sb3JTdGVwc1sxNV07CiAgc3RlcHNbNF0gPSBjb2xvclN0ZXBzWzIwXTsKICBzdGVwc1s1XSA9IGNvbG9yU3RlcHNbMjVdOwogIHN0ZXBzWzZdID0gY29sb3JTdGVwc1szMF07CiAgc3RlcHNbN10gPSBjb2xvclN0ZXBzWzM1XTsKCiAgY29sb3IgPSBjb2xvcnNbMF07CiAgZm9yIChpbnQgaSA9IDE7IGkgPCA4OyBpKyspIHsKICAgIGlmIChzdGVwc1tpXSA8IDAuMCB8fCBzdGVwc1tpXSA+IDEuMCkgewogICAgICBicmVhazsKICAgIH0KICAgIGlmKHN0ZXBzW2ldID09IHN0ZXBzW2kgLSAxXSkgewogICAgICBjb2xvciA9IGNvbG9yc1tpXTsKICAgIH0gZWxzZSB7CiAgICAgIGNvbG9yID0gbWl4KGNvbG9yLCBjb2xvcnNbaV0sIGNsYW1wKCh0IC0gc3RlcHNbaSAtIDFdKSAvIChzdGVwc1tpXSAtIHN0ZXBzW2kgLSAxXSksIDAuMCwgMS4wKSk7CiAgICB9CiAgICBpZiAoc3RlcHNbaV0gPj0gdCkgewogICAgICBicmVhazsKICAgIH0KICB9Cn0KI2VuZGlmCgp2b2lkIHRyYW5zZm9ybUNvbG9yKGlub3V0IHZlYzQgY29sb3IsIGluIGZsb2F0IGNvbG9yTWF0cml4WzIwXSkgewogIGZsb2F0IHIgPSBjb2xvci5yLCBnID0gY29sb3IuZywgYiA9IGNvbG9yLmIsIGEgPSBjb2xvci5hOwogIGNvbG9yWzBdID0gY29sb3JNYXRyaXhbMF0gKiByICsgY29sb3JNYXRyaXhbMV0gKiBnICsgY29sb3JNYXRyaXhbMl0gKiBiICsgY29sb3JNYXRyaXhbM10gKiBhICsgY29sb3JNYXRyaXhbNF07CiAgY29sb3JbMV0gPSBjb2xvck1hdHJpeFs1XSAqIHIgKyBjb2xvck1hdHJpeFs2XSAqIGcgKyBjb2xvck1hdHJpeFs3XSAqIGIgKyBjb2xvck1hdHJpeFs4XSAqIGEgKyBjb2xvck1hdHJpeFs5XTsKICBjb2xvclsyXSA9IGNvbG9yTWF0cml4WzEwXSAqIHIgKyBjb2xvck1hdHJpeFsxMV0gKiBnICsgY29sb3JNYXRyaXhbMTJdICogYiArIGNvbG9yTWF0cml4WzEzXSAqIGEgKyBjb2xvck1hdHJpeFsxNF07CiAgY29sb3JbM10gPSBjb2xvck1hdHJpeFsxNV0gKiByICsgY29sb3JNYXRyaXhbMTZdICogZyArIGNvbG9yTWF0cml4WzE3XSAqIGIgKyBjb2xvck1hdHJpeFsxOF0gKiBhICsgY29sb3JNYXRyaXhbMTldOwp9CgojaWZkZWYgQ0xPVURGSUxURVIKdm9pZCBidWlsZENsb3VkQ29sb3IoaW5vdXQgZmxvYXQgY29sb3JDbG91ZE1hdHJpeFsyMF0pIHsKICBjb2xvckNsb3VkTWF0cml4WzBdID0gY29sb3JDbG91ZDBbMF07CiAgY29sb3JDbG91ZE1hdHJpeFsxXSA9IGNvbG9yQ2xvdWQxWzBdOwogIGNvbG9yQ2xvdWRNYXRyaXhbMl0gPSBjb2xvckNsb3VkMlswXTsKICBjb2xvckNsb3VkTWF0cml4WzNdID0gY29sb3JDbG91ZDNbMF07CiAgY29sb3JDbG91ZE1hdHJpeFs0XSA9IGNvbG9yQ2xvdWQ0WzBdOwoKICBjb2xvckNsb3VkTWF0cml4WzVdID0gY29sb3JDbG91ZDBbMV07CiAgY29sb3JDbG91ZE1hdHJpeFs2XSA9IGNvbG9yQ2xvdWQxWzFdOwogIGNvbG9yQ2xvdWRNYXRyaXhbN10gPSBjb2xvckNsb3VkMlsxXTsKICBjb2xvckNsb3VkTWF0cml4WzhdID0gY29sb3JDbG91ZDNbMV07CiAgY29sb3JDbG91ZE1hdHJpeFs5XSA9IGNvbG9yQ2xvdWQ0WzFdOwoKICBjb2xvckNsb3VkTWF0cml4WzEwXSA9IGNvbG9yQ2xvdWQwWzJdOwogIGNvbG9yQ2xvdWRNYXRyaXhbMTFdID0gY29sb3JDbG91ZDFbMl07CiAgY29sb3JDbG91ZE1hdHJpeFsxMl0gPSBjb2xvckNsb3VkMlsyXTsKICBjb2xvckNsb3VkTWF0cml4WzEzXSA9IGNvbG9yQ2xvdWQzWzJdOwogIGNvbG9yQ2xvdWRNYXRyaXhbMTRdID0gY29sb3JDbG91ZDRbMl07CgogIGNvbG9yQ2xvdWRNYXRyaXhbMTVdID0gY29sb3JDbG91ZDBbM107CiAgY29sb3JDbG91ZE1hdHJpeFsxNl0gPSBjb2xvckNsb3VkMVszXTsKICBjb2xvckNsb3VkTWF0cml4WzE3XSA9IGNvbG9yQ2xvdWQyWzNdOwogIGNvbG9yQ2xvdWRNYXRyaXhbMThdID0gY29sb3JDbG91ZDNbM107CiAgY29sb3JDbG91ZE1hdHJpeFsxOV0gPSBjb2xvckNsb3VkNFszXTsKfQojZW5kaWYKCnZvaWQgbWFpbigpIHsKICB2ZWM0IGNvbG9yID0gdkNvbG9yOwogIGZsb2F0IG9wYWNpdHkgPSBhYnMoZmxhZ0JhY2tncm91bmQpOwoKI2lmZGVmIEdSQURJRU5UCiAgaWYodV9ncmFkaWVudFR5cGUgPiAwICYmIGZsYWdCYWNrZ3JvdW5kID4gMC4wIHx8IHVfZ3JhZGllbnRUeXBlID09IDAgJiYgZmxhZ0JhY2tncm91bmQgPD0gMC4wKSB7CiAgICBncmFkaWVudChjb2xvciwgdkdyYWRpZW50VmVjdG9yMSwgdkdyYWRpZW50VmVjdG9yMiwgdV9jb2xvclN0ZXBzKTsKICB9CiNlbmRpZgoKICBpZihvcGFjaXR5IDwgMS4wKSB7CiAgICBjb2xvci5hICo9IG9wYWNpdHk7CiAgfQoKI2lmZGVmIFRFWFRVUkUKICBpZihmbGFnQmFja2dyb3VuZCA+IDAuMCkgewogICAgdmVjMyB0ZXhDb29yZCA9IHZUZXh0dXJlQ29vcmQ7CgogICAgaWYodGV4Q29vcmQueiA9PSAxLjApIHsKICAgICAgdGV4Q29vcmQgPSBmcmFjdCh0ZXhDb29yZCk7CiAgICB9CgogICAgaWYodGV4Q29vcmQueCA8PSAxLjAgJiYgdGV4Q29vcmQueCA+PSAwLjAKICAgICAgJiYgdGV4Q29vcmQueSA8PSAxLjAgJiYgdGV4Q29vcmQueSA+PSAwLjApIHsKICAgICAgaWYodlNvdXJjZVJlY3QueiA+IDAuMCkgewogICAgICAgIHRleENvb3JkLnggPSB2U291cmNlUmVjdC54ICsgdGV4Q29vcmQueCAqIHZTb3VyY2VSZWN0Lno7CiAgICAgICAgdGV4Q29vcmQueSA9IDEuMCAtICh2U291cmNlUmVjdC55ICsgKDEuMCAtIHRleENvb3JkLnkpICogdlNvdXJjZVJlY3Qudyk7CiAgICAgIH0KICAgICAgaWYoZnJhbWVJbmRleCA8IDAuMCkgewogICAgICAgIHZlYzQgdGV4Q29sb3IgPSB0ZXh0dXJlMkQodV90ZXhTYW1wbGVyLCB0ZXhDb29yZC54eSk7CiAgICAgICAgY29sb3IgPSBtaXgoY29sb3IsIHRleENvbG9yLCB0ZXhDb2xvci5hKTsKICAgICAgfSBlbHNlIHsKICAgICAgICBpbnQgaW5kZXggPSBpbnQoZmxvb3IoY2xhbXAoMC4wLCAxMS4wLCBmcmFtZUluZGV4KSkpOwogICAgICAgIHZlYzQgdGV4Q29sb3I7CiAgICAgICAgaWYoaW5kZXggPT0gMCkgdGV4Q29sb3IgPSB0ZXh0dXJlMkQodV90ZXhGcmFtZTAsIHRleENvb3JkLnh5KTsKICAgICAgICBlbHNlIGlmKGluZGV4ID09IDEpIHRleENvbG9yID0gdGV4dHVyZTJEKHVfdGV4RnJhbWUxLCB0ZXhDb29yZC54eSk7CiAgICAgICAgZWxzZSBpZihpbmRleCA9PSAyKSB0ZXhDb2xvciA9IHRleHR1cmUyRCh1X3RleEZyYW1lMiwgdGV4Q29vcmQueHkpOwogICAgICAgIGVsc2UgaWYoaW5kZXggPT0gMykgdGV4Q29sb3IgPSB0ZXh0dXJlMkQodV90ZXhGcmFtZTMsIHRleENvb3JkLnh5KTsKICAgICAgICBlbHNlIGlmKGluZGV4ID09IDQpIHRleENvbG9yID0gdGV4dHVyZTJEKHVfdGV4RnJhbWU0LCB0ZXhDb29yZC54eSk7CiAgICAgICAgZWxzZSBpZihpbmRleCA9PSA1KSB0ZXhDb2xvciA9IHRleHR1cmUyRCh1X3RleEZyYW1lNSwgdGV4Q29vcmQueHkpOwogICAgICAgIGVsc2UgaWYoaW5kZXggPT0gNikgdGV4Q29sb3IgPSB0ZXh0dXJlMkQodV90ZXhGcmFtZTYsIHRleENvb3JkLnh5KTsKICAgICAgICBlbHNlIGlmKGluZGV4ID09IDcpIHRleENvbG9yID0gdGV4dHVyZTJEKHVfdGV4RnJhbWU3LCB0ZXhDb29yZC54eSk7CiAgICAgICAgZWxzZSBpZihpbmRleCA9PSA4KSB0ZXhDb2xvciA9IHRleHR1cmUyRCh1X3RleEZyYW1lOCwgdGV4Q29vcmQueHkpOwogICAgICAgIGVsc2UgaWYoaW5kZXggPT0gOSkgdGV4Q29sb3IgPSB0ZXh0dXJlMkQodV90ZXhGcmFtZTksIHRleENvb3JkLnh5KTsKICAgICAgICBlbHNlIGlmKGluZGV4ID09IDEwKSB0ZXhDb2xvciA9IHRleHR1cmUyRCh1X3RleEZyYW1lMTAsIHRleENvb3JkLnh5KTsKICAgICAgICBlbHNlIHRleENvbG9yID0gdGV4dHVyZTJEKHVfdGV4RnJhbWUxMSwgdGV4Q29vcmQueHkpOwogICAgICAgIGZsb2F0IGFscGhhID0gdGV4Q29sb3IuYTsKICAgICAgICBpZihvcGFjaXR5IDwgMS4wKSB7CiAgICAgICAgICB0ZXhDb2xvci5hICo9IG9wYWNpdHk7CiAgICAgICAgICBhbHBoYSAqPSBtaXgoMC40NjUsIDEuMCwgb3BhY2l0eSk7CiAgICAgICAgfQogICAgICAgIC8vIGNvbG9yID0gbWl4KGNvbG9yLCB0ZXhDb2xvciwgdGV4Q29sb3IuYSk7CiAgICAgICAgY29sb3IucmdiID0gbWl4KGNvbG9yLnJnYiwgdGV4Q29sb3IucmdiLCBhbHBoYSk7CiAgICAgICAgLy8gY29sb3IucmdiID0gbWl4KHRleENvbG9yLnJnYiwgY29sb3IucmdiLCBjb2xvci5hKTsKICAgICAgICBjb2xvci5yZ2IgPSBtaXgodGV4Q29sb3IucmdiLCBjb2xvci5yZ2IsIGNsYW1wKGNvbG9yLmEgLyBtYXgoMC4wMDAxLCB0ZXhDb2xvci5hKSwgMC4wLCAxLjApKTsKICAgICAgICBjb2xvci5hID0gdGV4Q29sb3IuYSArICgxLjAgLSB0ZXhDb2xvci5hKSAqIGNvbG9yLmE7CiAgICAgIH0KICAgIH0KICB9CiNlbmRpZgoKI2lmZGVmIEZJTFRFUgogIGlmKHVfZmlsdGVyRmxhZyA+IDApIHsKICAgIHRyYW5zZm9ybUNvbG9yKGNvbG9yLCB1X2NvbG9yTWF0cml4KTsKICB9CiNlbmRpZgoKI2lmZGVmIENMT1VERklMVEVSCiAgZmxvYXQgY29sb3JDbG91ZE1hdHJpeFsyMF07CiAgYnVpbGRDbG91ZENvbG9yKGNvbG9yQ2xvdWRNYXRyaXgpOwogIHRyYW5zZm9ybUNvbG9yKGNvbG9yLCBjb2xvckNsb3VkTWF0cml4KTsKI2VuZGlmCgojaWZkZWYgQ0xJUFBBVEgKICBmbG9hdCBjbGlwID0gdGV4dHVyZTJEKHVfY2xpcFNhbXBsZXIsIHZDbGlwVVYpLnI7CiAgY29sb3IgKj0gY2xpcDsKI2VuZGlmCgogIGdsX0ZyYWdDb2xvciA9IGNvbG9yOwp9YH0sZnVuY3Rpb24oUyxlLHQpe3QucihlKSwoZnVuY3Rpb24ocixpKXt0LmQoZSwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIixmdW5jdGlvbigpe3JldHVybiBnfSksdC5kKGUsImNhbmNlbEFuaW1hdGlvbkZyYW1lIixmdW5jdGlvbigpe3JldHVybiB1fSksdCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIGgoKXtpZih0eXBlb2YgcGVyZm9ybWFuY2U8InUiJiZwZXJmb3JtYW5jZS5ub3cpcmV0dXJuIHBlcmZvcm1hbmNlLm5vdygpO2lmKHR5cGVvZiByPCJ1IiYmci5ocnRpbWUpe2NvbnN0W2EsY109ci5ocnRpbWUoKTtyZXR1cm4gYSoxZTMrYyoxZS02fXJldHVybiBEYXRlLm5vdz9EYXRlLm5vdygpOm5ldyBEYXRlKCkuZ2V0VGltZSgpfWxldCBnLHU7dHlwZW9mIGk8InUiJiZ0eXBlb2YgaS5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU9PSJmdW5jdGlvbiI/KGc9aS5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUsdT1pLmNhbmNlbEFuaW1hdGlvbkZyYW1lKTooZz1mdW5jdGlvbihhKXtyZXR1cm4gc2V0VGltZW91dCgoKT0+e2EoaCgpKX0sMTYpfSx1PWZ1bmN0aW9uKGEpe3JldHVybiBjbGVhclRpbWVvdXQoYSl9KX0pLmNhbGwodGhpcyx0KDY5KSx0KDIyKSl9LGZ1bmN0aW9uKFMsZSl7dmFyIHQ9Uy5leHBvcnRzPXt9LHIsaTtmdW5jdGlvbiBoKCl7dGhyb3cgbmV3IEVycm9yKCJzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkIil9ZnVuY3Rpb24gZygpe3Rocm93IG5ldyBFcnJvcigiY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkIil9KGZ1bmN0aW9uKCl7dHJ5e3R5cGVvZiBzZXRUaW1lb3V0PT0iZnVuY3Rpb24iP3I9c2V0VGltZW91dDpyPWh9Y2F0Y2h7cj1ofXRyeXt0eXBlb2YgY2xlYXJUaW1lb3V0PT0iZnVuY3Rpb24iP2k9Y2xlYXJUaW1lb3V0Omk9Z31jYXRjaHtpPWd9fSkoKTtmdW5jdGlvbiB1KHkpe2lmKHI9PT1zZXRUaW1lb3V0KXJldHVybiBzZXRUaW1lb3V0KHksMCk7aWYoKHI9PT1ofHwhcikmJnNldFRpbWVvdXQpcmV0dXJuIHI9c2V0VGltZW91dCxzZXRUaW1lb3V0KHksMCk7dHJ5e3JldHVybiByKHksMCl9Y2F0Y2h7dHJ5e3JldHVybiByLmNhbGwobnVsbCx5LDApfWNhdGNoe3JldHVybiByLmNhbGwodGhpcyx5LDApfX19ZnVuY3Rpb24gYSh5KXtpZihpPT09Y2xlYXJUaW1lb3V0KXJldHVybiBjbGVhclRpbWVvdXQoeSk7aWYoKGk9PT1nfHwhaSkmJmNsZWFyVGltZW91dClyZXR1cm4gaT1jbGVhclRpbWVvdXQsY2xlYXJUaW1lb3V0KHkpO3RyeXtyZXR1cm4gaSh5KX1jYXRjaHt0cnl7cmV0dXJuIGkuY2FsbChudWxsLHkpfWNhdGNoe3JldHVybiBpLmNhbGwodGhpcyx5KX19fXZhciBjPVtdLHg9ITEsZix2PS0xO2Z1bmN0aW9uIHAoKXsheHx8IWZ8fCh4PSExLGYubGVuZ3RoP2M9Zi5jb25jYXQoYyk6dj0tMSxjLmxlbmd0aCYmQygpKX1mdW5jdGlvbiBDKCl7aWYoIXgpe3ZhciB5PXUocCk7eD0hMDtmb3IodmFyIG49Yy5sZW5ndGg7bjspe2ZvcihmPWMsYz1bXTsrK3Y8bjspZiYmZlt2XS5ydW4oKTt2PS0xLG49Yy5sZW5ndGh9Zj1udWxsLHg9ITEsYSh5KX19dC5uZXh0VGljaz1mdW5jdGlvbih5KXt2YXIgbj1uZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aC0xKTtpZihhcmd1bWVudHMubGVuZ3RoPjEpZm9yKHZhciBvPTE7bzxhcmd1bWVudHMubGVuZ3RoO28rKyluW28tMV09YXJndW1lbnRzW29dO2MucHVzaChuZXcgTSh5LG4pKSxjLmxlbmd0aD09PTEmJiF4JiZ1KEMpfTtmdW5jdGlvbiBNKHksbil7dGhpcy5mdW49eSx0aGlzLmFycmF5PW59TS5wcm90b3R5cGUucnVuPWZ1bmN0aW9uKCl7dGhpcy5mdW4uYXBwbHkobnVsbCx0aGlzLmFycmF5KX0sdC50aXRsZT0iYnJvd3NlciIsdC5icm93c2VyPSEwLHQuZW52PXt9LHQuYXJndj1bXSx0LnZlcnNpb249IiIsdC52ZXJzaW9ucz17fTtmdW5jdGlvbiBtKCl7fXQub249bSx0LmFkZExpc3RlbmVyPW0sdC5vbmNlPW0sdC5vZmY9bSx0LnJlbW92ZUxpc3RlbmVyPW0sdC5yZW1vdmVBbGxMaXN0ZW5lcnM9bSx0LmVtaXQ9bSx0LnByZXBlbmRMaXN0ZW5lcj1tLHQucHJlcGVuZE9uY2VMaXN0ZW5lcj1tLHQubGlzdGVuZXJzPWZ1bmN0aW9uKHkpe3JldHVybltdfSx0LmJpbmRpbmc9ZnVuY3Rpb24oeSl7dGhyb3cgbmV3IEVycm9yKCJwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCIpfSx0LmN3ZD1mdW5jdGlvbigpe3JldHVybiIvIn0sdC5jaGRpcj1mdW5jdGlvbih5KXt0aHJvdyBuZXcgRXJyb3IoInByb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCIpfSx0LnVtYXNrPWZ1bmN0aW9uKCl7cmV0dXJuIDB9fSxmdW5jdGlvbihTLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBifSk7dmFyIHI9dCgxKSxpPXQoNzEpLGg9dCg3MyksZz10KDIxMyksdT10KDIxNCksYT10KDIxNSksYz10KDIxNik7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIHgoSSxQKXt2YXIgTD1PYmplY3Qua2V5cyhJKTtpZihPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKXt2YXIgRD1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKEkpO1AmJihEPUQuZmlsdGVyKGZ1bmN0aW9uKFIpe3JldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKEksUikuZW51bWVyYWJsZX0pKSxMLnB1c2guYXBwbHkoTCxEKX1yZXR1cm4gTH1mdW5jdGlvbiBmKEkpe2Zvcih2YXIgUD0xO1A8YXJndW1lbnRzLmxlbmd0aDtQKyspe3ZhciBMPWFyZ3VtZW50c1tQXSE9bnVsbD9hcmd1bWVudHNbUF06e307UCUyP3goT2JqZWN0KEwpLCEwKS5mb3JFYWNoKGZ1bmN0aW9uKEQpe3YoSSxELExbRF0pfSk6T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnM/T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoSSxPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhMKSk6eChPYmplY3QoTCkpLmZvckVhY2goZnVuY3Rpb24oRCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KEksRCxPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKEwsRCkpfSl9cmV0dXJuIEl9ZnVuY3Rpb24gdihJLFAsTCl7cmV0dXJuIFAgaW4gST9PYmplY3QuZGVmaW5lUHJvcGVydHkoSSxQLHt2YWx1ZTpMLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6SVtQXT1MLEl9Y29uc3QgcD1TeW1ib2wuZm9yKCJzcHJpdGVqc19jaGFuZ2VkQXR0cnMiKSxDPVN5bWJvbC5mb3IoInNwcml0ZWpzX2F0dHJpYnV0ZXMiKSxNPVN5bWJvbCgicmVzb2x1dGlvbiIpLG09U3ltYm9sKCJhbmltYXRpb25zIikseT1TeW1ib2woImV2ZW50TGlzdGVuZXJzIiksbj1TeW1ib2woImNhcHR1cmVFdmVudExpc3RlbmVycyIpLG89U3ltYm9sKCJmaWx0ZXJzIikscz1TeW1ib2woImRpc3BsYXkiKSxsPVN5bWJvbCgicHJvZ3JhbSIpLEU9U3ltYm9sKCJzaGFkZXJBdHRycyIpLFQ9U3ltYm9sKCJ1bmlmb3JtcyIpO2NsYXNzIGJ7Y29uc3RydWN0b3IoUD17fSl7dGhpcy5hdHRyaWJ1dGVzPW5ldyB0aGlzLmNvbnN0cnVjdG9yLkF0dHIodGhpcyksdGhpc1tNXT17d2lkdGg6MzAwLGhlaWdodDoxNTB9LE9iamVjdC5hc3NpZ24odGhpcy5hdHRyaWJ1dGVzLFApLHRoaXNbbV09bmV3IFNldCx0aGlzW3ldPXt9LHRoaXNbbl09e319Z2V0IGFuY2VzdG9ycygpe2xldCBQPXRoaXMucGFyZW50O2NvbnN0IEw9W107Zm9yKDtQOylMLnB1c2goUCksUD1QLnBhcmVudDtyZXR1cm4gTH1nZXQgYW5pbWF0aW9ucygpe3JldHVybiB0aGlzW21dfWdldCBmaWx0ZXJzKCl7cmV0dXJuIHRoaXNbb118fHRoaXMucGFyZW50JiZ0aGlzLnBhcmVudC5maWx0ZXJzfWdldCBpc1Zpc2libGUoKXtyZXR1cm4hMX1nZXQgbGF5ZXIoKXtyZXR1cm4gdGhpcy5wYXJlbnQ/dGhpcy5wYXJlbnQubGF5ZXI6bnVsbH1nZXQgbG9jYWxNYXRyaXgoKXtjb25zdCBQPXRoaXMudHJhbnNmb3JtTWF0cml4LHt4OkwseTpEfT10aGlzLmF0dHJpYnV0ZXM7cmV0dXJuIFBbNF0rPUwsUFs1XSs9RCxQfWdldCBvcGFjaXR5KCl7bGV0IFA9dGhpcy5hdHRyaWJ1dGVzLm9wYWNpdHk7cmV0dXJuIHRoaXMucGFyZW50JiZ0aGlzLnBhcmVudC5vcGFjaXR5IT1udWxsJiYoUCo9dGhpcy5wYXJlbnQub3BhY2l0eSksUH1nZXQgcGFyZW50Tm9kZSgpe3JldHVybiB0aGlzLnBhcmVudH1nZXQgbmV4dFNpYmxpbmcoKXtyZXR1cm4gdGhpcy5nZXROb2RlTmVhckJ5KDEpfWdldCBwcmV2aW91c1NpYmxpbmcoKXtyZXR1cm4gdGhpcy5nZXROb2RlTmVhckJ5KC0xKX1nZXQgcHJvZ3JhbSgpe3JldHVybiB0aGlzW2xdfWdldCByZW5kZXJlcigpe3JldHVybiB0aGlzLnBhcmVudD90aGlzLnBhcmVudC5yZW5kZXJlcjpudWxsfWdldCByZW5kZXJNYXRyaXgoKXtpZih0aGlzLl9fY2FjaGVSZW5kZXJNYXRyaXgpcmV0dXJuIHRoaXMuX19jYWNoZVJlbmRlck1hdHJpeDtsZXQgUD10aGlzLmxvY2FsTWF0cml4O2NvbnN0IEw9dGhpcy5wYXJlbnQ7aWYoTCl7Y29uc3QgRD1MLl9fY2FjaGVSZW5kZXJNYXRyaXh8fEwucmVuZGVyTWF0cml4O0QmJihQPXIubWF0MmQubXVsdGlwbHkoQXJyYXkub2YoMCwwLDAsMCwwLDApLEQsUCkpfXJldHVybiBQfWdldCB3b3JsZFNjYWxpbmcoKXtjb25zdCBQPXRoaXMucmVuZGVyTWF0cml4O3JldHVybltNYXRoLmh5cG90KFBbMF0sUFsxXSksTWF0aC5oeXBvdChQWzJdLFBbM10pXX1nZXQgd29ybGRSb3RhdGlvbigpe2NvbnN0IFA9dGhpcy5yZW5kZXJNYXRyaXg7cmV0dXJuIE1hdGguYXRhbjIoUFsxXSxQWzNdKX1nZXQgd29ybGRQb3NpdGlvbigpe2NvbnN0IFA9dGhpcy5yZW5kZXJNYXRyaXg7cmV0dXJuW1BbNF0sUFs1XV19Z2V0IHVuaWZvcm1zKCl7cmV0dXJuIHRoaXNbVF19Z2V0IGNsYXNzTmFtZSgpe3JldHVybiB0aGlzLmF0dHJpYnV0ZXMuY2xhc3NOYW1lfXNldCBjbGFzc05hbWUoUCl7dGhpcy5hdHRyaWJ1dGVzLmNsYXNzTmFtZT1QfWdldCBpZCgpe3JldHVybiB0aGlzLmF0dHJpYnV0ZXMuaWR9c2V0IGlkKFApe3RoaXMuYXR0cmlidXRlcy5pZD1QfWdldCBuYW1lKCl7cmV0dXJuIHRoaXMuYXR0cmlidXRlcy5uYW1lfXNldCBuYW1lKFApe3RoaXMuYXR0cmlidXRlcy5uYW1lPVB9Z2V0IHpJbmRleCgpe3JldHVybiB0aGlzLmF0dHJpYnV0ZXMuekluZGV4fXNldCB6SW5kZXgoUCl7dGhpcy5hdHRyaWJ1dGVzLnpJbmRleD1QfWdldCBtZXNoKCl7cmV0dXJuIG51bGx9Z2V0IHNoYWRlckF0dHJzKCl7cmV0dXJuIHRoaXNbRV18fHt9fWFjdGl2YXRlQW5pbWF0aW9ucygpe2NvbnN0IFA9dGhpcy5sYXllcjtpZihQKXtjb25zdCBMPXRoaXNbbV07TC5mb3JFYWNoKFI9PntSLmJhc2VUaW1lbGluZT1QLnRpbWVsaW5lLFIucGxheSgpLFIuZmluaXNoZWQudGhlbigoKT0+e0wuZGVsZXRlKFIpfSl9KTtjb25zdCBEPXRoaXMuY2hpbGRyZW47RCYmRC5mb3JFYWNoKFI9PntSLmFjdGl2YXRlQW5pbWF0aW9ucyYmUi5hY3RpdmF0ZUFuaW1hdGlvbnMoKX0pfX1hZGRFdmVudExpc3RlbmVyKFAsTCxEPXt9KXtQPT09Im1vdXNld2hlZWwiJiYoUD0id2hlZWwiKSx0eXBlb2YgRD09ImJvb2xlYW4iJiYoRD17Y2FwdHVyZTpEfSk7Y29uc3R7Y2FwdHVyZTpSLG9uY2U6QX09RCxqPVI/bjp5O3JldHVybiB0aGlzW2pdW1BdPXRoaXNbal1bUF18fFtdLHRoaXNbal1bUF0ucHVzaCh7bGlzdGVuZXI6TCxvbmNlOkF9KSx0aGlzfWFuaW1hdGUoUCxMKXtjb25zdCBEPW5ldyBoLmRlZmF1bHQodGhpcyxQLEwpO3JldHVybiB0aGlzLmVmZmVjdHMmJkQuYXBwbHlFZmZlY3RzKHRoaXMuZWZmZWN0cyksdGhpcy5sYXllciYmKEQuYmFzZVRpbWVsaW5lPXRoaXMubGF5ZXIudGltZWxpbmUsRC5wbGF5KCksRC5maW5pc2hlZC50aGVuKCgpPT57dGhpc1ttXS5kZWxldGUoRCl9KSksdGhpc1ttXS5hZGQoRCksRH1hdHRyKC4uLlApe2lmKFAubGVuZ3RoPT09MClyZXR1cm4gdGhpcy5hdHRyaWJ1dGVzW0NdO2lmKFAubGVuZ3RoPjEpe2xldFtMLERdPVA7cmV0dXJuIHR5cGVvZiBEPT0iZnVuY3Rpb24iJiYoRD1EKHRoaXMuYXR0cihMKSkpLHRoaXMuc2V0QXR0cmlidXRlKEwsRCksdGhpc31yZXR1cm4gdHlwZW9mIFBbMF09PSJzdHJpbmciP3RoaXMuZ2V0QXR0cmlidXRlKFBbMF0pOihPYmplY3QuYXNzaWduKHRoaXMuYXR0cmlidXRlcyxQWzBdKSx0aGlzKX1jbG9uZU5vZGUoKXtjb25zdCBQPW5ldyB0aGlzLmNvbnN0cnVjdG9yLEw9dGhpcy5hdHRyaWJ1dGVzW3BdO3JldHVybiBQLmF0dHIoTCksUH1jb25uZWN0KFAsTCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInBhcmVudCIse3ZhbHVlOlAsd3JpdGFibGU6ITEsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInpPcmRlciIse3ZhbHVlOkwsd3JpdGFibGU6ITEsY29uZmlndXJhYmxlOiEwfSksUC50aW1lbGluZSYmdGhpcy5hY3RpdmF0ZUFuaW1hdGlvbnMoKSx0aGlzLnNldFJlc29sdXRpb24oUC5nZXRSZXNvbHV0aW9uKCkpLHRoaXMuZm9yY2VVcGRhdGUoKSx0aGlzLmRpc3BhdGNoRXZlbnQoe3R5cGU6ImFwcGVuZCIsZGV0YWlsOntwYXJlbnQ6UCx6T3JkZXI6TH19KX1jb250YWlucyhQKXtmb3IoO1AmJnRoaXMhPT1QOylQPVAucGFyZW50O3JldHVybiEhUH1kZWFjdGl2YXRlQW5pbWF0aW9ucygpe3RoaXNbbV0uZm9yRWFjaChMPT5MLmNhbmNlbCgpKTtjb25zdCBQPXRoaXMuY2hpbGRyZW47UCYmUC5mb3JFYWNoKEw9PntMLmRlYWN0aXZhdGVBbmltYXRpb25zJiZMLmRlYWN0aXZhdGVBbmltYXRpb25zKCl9KX1kaXNjb25uZWN0KCl7Y29uc3R7cGFyZW50OlAsek9yZGVyOkx9PXRoaXM7ZGVsZXRlIHRoaXMucGFyZW50LGRlbGV0ZSB0aGlzLnpPcmRlcix0aGlzLmRlYWN0aXZhdGVBbmltYXRpb25zKCksdGhpcy5kaXNwYXRjaEV2ZW50KHt0eXBlOiJyZW1vdmUiLGRldGFpbDp7cGFyZW50OlAsek9yZGVyOkx9fSksUCYmUC5mb3JjZVVwZGF0ZSgpfWRpc3BhdGNoRXZlbnQoUCl7UCBpbnN0YW5jZW9mIHUuZGVmYXVsdHx8KFA9bmV3IHUuZGVmYXVsdChQKSksUC50YXJnZXQ9dGhpcztsZXQgTD1QLnR5cGU7TD09PSJtb3VzZXdoZWVsIiYmKEw9IndoZWVsIik7Y29uc3QgRD1bdGhpc107bGV0IFI9dGhpcy5wYXJlbnQ7Zm9yKDtQLmJ1YmJsZXMmJlI7KUQucHVzaChSKSxSPVIucGFyZW50O2ZvcihsZXQgQT1ELmxlbmd0aC0xO0E+PTA7QS0tKXtjb25zdCBqPURbQV0sRz1qW25dJiZqW25dW0xdO2lmKEcmJkcubGVuZ3RoJiYoUC5jdXJyZW50VGFyZ2V0PWosRy5mb3JFYWNoKCh7bGlzdGVuZXI6SCxvbmNlOlp9KT0+e0guY2FsbCh0aGlzLFApLFomJkQucmVtb3ZlRXZlbnRMaXN0ZW5lcihIKX0pLGRlbGV0ZSBQLmN1cnJlbnRUYXJnZXQpLCFQLmJ1YmJsZXMmJlAuY2FuY2VsQnViYmxlKWJyZWFrfWlmKCFQLmNhbmNlbEJ1YmJsZSlmb3IobGV0IEE9MDtBPEQubGVuZ3RoO0ErKyl7Y29uc3Qgaj1EW0FdLEc9alt5XSYmalt5XVtMXTtpZihHJiZHLmxlbmd0aCYmKFAuY3VycmVudFRhcmdldD1qLEcuZm9yRWFjaCgoe2xpc3RlbmVyOkgsb25jZTpafSk9PntILmNhbGwodGhpcyxQKSxaJiZELnJlbW92ZUV2ZW50TGlzdGVuZXIoSCl9KSxkZWxldGUgUC5jdXJyZW50VGFyZ2V0KSwhUC5idWJibGVzfHxQLmNhbmNlbEJ1YmJsZSlicmVha319ZGlzcGF0Y2hQb2ludGVyRXZlbnQoUCl7Y29uc3R7bGF5ZXJYOkwsbGF5ZXJZOkR9PVA7cmV0dXJuIHRoaXMuaXNQb2ludENvbGxpc2lvbihMLEQpPyh0aGlzLmRpc3BhdGNoRXZlbnQoUCksITApOiExfWRyYXcoUD1bXSl7Y29uc3QgTD10aGlzLm1lc2g7aWYoTCl7aWYoT2JqZWN0KGEuYXBwbHlGaWx0ZXJzKShMLHRoaXMuZmlsdGVycyksUC5wdXNoKEwpLHRoaXNbbF0pe0wuc2V0UHJvZ3JhbSh0aGlzW2xdKTtjb25zdCBEPXRoaXNbRV07RCYmT2JqZWN0LmVudHJpZXMoRCkuZm9yRWFjaCgoW0Esal0pPT57TC5zZXRBdHRyaWJ1dGUoQSxqKX0pO2NvbnN0IFI9dGhpc1tUXTtpZih0aGlzW1RdKXtjb25zdCBBPXt9O09iamVjdC5lbnRyaWVzKFIpLmZvckVhY2goKFtqLEddKT0+e3R5cGVvZiBHPT0iZnVuY3Rpb24iJiYoRz1HKHRoaXMsaikpLEFbal09R30pLEwuc2V0VW5pZm9ybXMoQSl9fU9iamVjdChjLmRlZmF1bHQpKHRoaXMsTCl9cmV0dXJuIFB9Zm9yY2VVcGRhdGUoKXt0aGlzLnBhcmVudCYmdGhpcy5wYXJlbnQuZm9yY2VVcGRhdGUoKX1nZXRBdHRyaWJ1dGUoUCl7cmV0dXJuIHRoaXMuYXR0cmlidXRlc1tQXX1nZXRMaXN0ZW5lcnMoUCx7Y2FwdHVyZTpMPSExfT17fSl7cmV0dXJuWy4uLnRoaXNbTD9uOnldW1BdfHxbXV19Z2V0Tm9kZU5lYXJCeShQPTEpe2lmKCF0aGlzLnBhcmVudClyZXR1cm4gbnVsbDtpZihQPT09MClyZXR1cm4gdGhpcztjb25zdCBMPXRoaXMucGFyZW50LmNoaWxkcmVuLEQ9TC5pbmRleE9mKHRoaXMpO3JldHVybiBMW0QrUF19Z2V0V29ybGRQb3NpdGlvbihQLEwpe2NvbnN0IEQ9dGhpcy5yZW5kZXJNYXRyaXgsUj1QKkRbMF0rTCpEWzJdK0RbNF0sQT1QKkRbMV0rTCpEWzNdK0RbNV07cmV0dXJuW1IsQV19Z2V0T2Zmc2V0UG9zaXRpb24oUCxMKXtjb25zdCBEPXIubWF0MmQuaW52ZXJ0KEFycmF5Lm9mKDAsMCwwLDAsMCwwKSx0aGlzLnJlbmRlck1hdHJpeCksUj1QKkRbMF0rTCpEWzJdK0RbNF0sQT1QKkRbMV0rTCpEWzNdK0RbNV07cmV0dXJuW1IsQV19Z2V0UmVzb2x1dGlvbigpe3JldHVybiBmKHt9LHRoaXNbTV0pfWlzUG9pbnRDb2xsaXNpb24oUCxMKXtpZighdGhpcy5tZXNoKXJldHVybiExO2NvbnN0IEQ9dGhpcy5hdHRyaWJ1dGVzLnBvaW50ZXJFdmVudHM7aWYoRD09PSJub25lInx8RCE9PSJhbGwiJiYhdGhpcy5pc1Zpc2libGUpcmV0dXJuITE7bGV0IFI9ImJvdGgiO3JldHVybiBEPT09InZpc2libGVGaWxsIiYmKFI9ImZpbGwiKSxEPT09InZpc2libGVTdHJva2UiJiYoUj0ic3Ryb2tlIiksdGhpcy5tZXNoLmlzUG9pbnRDb2xsaXNpb24oUCxMLFIpfW9uUHJvcGVydHlDaGFuZ2UoUCxMLEQpe1AhPT0iaWQiJiZQIT09Im5hbWUiJiZQIT09ImNsYXNzTmFtZSImJlAhPT0icG9pbnRlckV2ZW50cyImJlAhPT0icGFzc0V2ZW50cyImJnRoaXMuZm9yY2VVcGRhdGUoKSxQPT09ImZpbHRlciImJih0aGlzW29dPU9iamVjdChhLnBhcnNlRmlsdGVyU3RyaW5nKShMKSksUD09PSJ6SW5kZXgiJiZ0aGlzLnBhcmVudCYmdGhpcy5wYXJlbnQucmVvcmRlcigpfXNldEF0dHJpYnV0ZShQLEwpe1A9PT0iYXR0cnMiJiZ0aGlzLmF0dHIoTCksdGhpcy5hdHRyaWJ1dGVzW1BdPUx9c2V0TW91c2VDYXB0dXJlKCl7dGhpcy5sYXllciYmKHRoaXMubGF5ZXIuX19tb3VzZUNhcHR1cmVkVGFyZ2V0PXRoaXMpfXNldFByb2dyYW0oUCl7dGhpc1tsXT1QLHRoaXMuZm9yY2VVcGRhdGUoKX1zZXRTaGFkZXJBdHRyaWJ1dGUoUCxMKXt0aGlzW0VdPXRoaXNbRV18fHt9LHRoaXNbRV1bUF09TCx0aGlzLmZvcmNlVXBkYXRlKCl9c2V0VW5pZm9ybXMoUCl7dGhpc1tUXT10aGlzW1RdfHx7fSxPYmplY3QuYXNzaWduKHRoaXNbVF0sUCksdGhpcy5mb3JjZVVwZGF0ZSgpfXNldFJlc29sdXRpb24oe3dpZHRoOlAsaGVpZ2h0Okx9KXtjb25zdHt3aWR0aDpELGhlaWdodDpSfT10aGlzW01dOyhEIT09UHx8UiE9PUwpJiYodGhpc1tNXT17d2lkdGg6UCxoZWlnaHQ6TH0sdGhpcy5mb3JjZVVwZGF0ZSgpLHRoaXMuZGlzcGF0Y2hFdmVudCh7dHlwZToicmVzb2x1dGlvbmNoYW5nZSIsZGV0YWlsOnt3aWR0aDpQLGhlaWdodDpMfX0pKX1zaG93KCl7dGhpcy5hdHRyaWJ1dGVzLmRpc3BsYXk9PT0ibm9uZSImJih0aGlzLmF0dHJpYnV0ZXMuZGlzcGxheT10aGlzW3NdfHwiIil9aGlkZSgpe3RoaXMuYXR0cmlidXRlcy5kaXNwbGF5IT09Im5vbmUiJiYodGhpc1tzXT10aGlzLmF0dHJpYnV0ZXMuZGlzcGxheSx0aGlzLmF0dHJpYnV0ZXMuZGlzcGxheT0ibm9uZSIpfXJlbGVhc2VNb3VzZUNhcHR1cmUoKXt0aGlzLmxheWVyJiZ0aGlzLmxheWVyLl9fbW91c2VDYXB0dXJlZFRhcmdldD09PXRoaXMmJih0aGlzLmxheWVyLl9fbW91c2VDYXB0dXJlZFRhcmdldD1udWxsKX1yZW1vdmUoKXtyZXR1cm4gdGhpcy5wYXJlbnQmJnRoaXMucGFyZW50LnJlbW92ZUNoaWxkPyh0aGlzLnBhcmVudC5yZW1vdmVDaGlsZCh0aGlzKSwhMCk6ITF9cmVtb3ZlQWxsTGlzdGVuZXJzKFAsTD17fSl7dHlwZW9mIEw9PSJib29sZWFuIiYmKEw9e2NhcHR1cmU6TH0pO2NvbnN0IFI9TC5jYXB0dXJlP246eTtyZXR1cm4gdGhpc1tSXVtQXSYmKHRoaXNbUl1bUF09W10pLHRoaXN9cmVtb3ZlQXR0cmlidXRlKFApe3RoaXMuc2V0QXR0cmlidXRlKFAsbnVsbCl9cmVtb3ZlRXZlbnRMaXN0ZW5lcihQLEwsRD17fSl7dHlwZW9mIEQ9PSJib29sZWFuIiYmKEQ9e2NhcHR1cmU6RH0pO2NvbnN0IEE9RC5jYXB0dXJlP246eTtpZih0aGlzW0FdW1BdKXtjb25zdCBqPXRoaXNbQV1bUF07aWYoailmb3IobGV0IEc9MDtHPGoubGVuZ3RoO0crKyl7Y29uc3R7bGlzdGVuZXI6SH09altHXTtpZihIPT09TCl7dGhpc1tBXVtQXS5zcGxpY2UoRywxKTticmVha319fXJldHVybiB0aGlzfXRyYW5zaXRpb24oUCxMPSJsaW5lYXIiKXtjb25zdCBEPXRoaXMsUj1TeW1ib2woImFuaW1hdGlvbiIpO0w9THx8ImxpbmVhciI7bGV0IEE9MDtyZXR1cm4gdHlwZW9mIFA9PSJvYmplY3QiJiYoQT1QLmRlbGF5fHwwLFA9UC5kdXJhdGlvbikse1tSXTpudWxsLGNhbmNlbChqPSExKXtjb25zdCBHPXRoaXNbUl07RyYmRy5jYW5jZWwoail9LGVuZCgpe2NvbnN0IGo9dGhpc1tSXTtqJiYoai5wbGF5U3RhdGU9PT0icnVubmluZyJ8fGoucGxheVN0YXRlPT09InBlbmRpbmciKSYmai5maW5pc2goKX0scmV2ZXJzZSgpe2NvbnN0IGo9dGhpc1tSXTtpZihqKWlmKGoucGxheVN0YXRlPT09InJ1bm5pbmcifHxqLnBsYXlTdGF0ZT09PSJwZW5kaW5nIilqLnBsYXliYWNrUmF0ZT0tai5wbGF5YmFja1JhdGU7ZWxzZXtjb25zdCBHPWoudGltaW5nLmRpcmVjdGlvbjtqLnRpbWluZy5kaXJlY3Rpb249Rz09PSJyZXZlcnNlIj8ibm9ybWFsIjoicmV2ZXJzZSIsai5wbGF5KCl9cmV0dXJuIGouZmluaXNoZWR9LGF0dHIoaixHKXtyZXR1cm4gdGhpcy5lbmQoKSx0eXBlb2Ygaj09InN0cmluZyImJihqPXtbal06R30pLE9iamVjdC5lbnRyaWVzKGopLmZvckVhY2goKFtILFpdKT0+e3R5cGVvZiBaPT0iZnVuY3Rpb24iJiYoaltIXT1aKEQuYXR0cihIKSkpfSksdGhpc1tSXT1ELmFuaW1hdGUoW2pdLHtkdXJhdGlvbjpQKjFlMyxkZWxheTpBKjFlMyxmaWxsOiJmb3J3YXJkcyIsZWFzaW5nOkx9KSx0aGlzW1JdLmZpbmlzaGVkfX19dXBkYXRlQ29udG91cnMoKXt9fXYoYiwiQXR0ciIsaS5kZWZhdWx0KSxnLmRlZmF1bHQucmVnaXN0ZXJOb2RlKGIsIm5vZGUiKX0sZnVuY3Rpb24oUyxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gYn0pO3ZhciByPXQoMSksaT10KDEyKSxoPXQoNzIpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCBnPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZURlZmF1bHQiKSx1PVN5bWJvbC5mb3IoInNwcml0ZWpzX2RlY2xhcmVBbGlhcyIpLGE9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlIiksYz1TeW1ib2wuZm9yKCJzcHJpdGVqc19nZXRBdHRyaWJ1dGUiKSx4PVN5bWJvbC5mb3IoInNwcml0ZWpzX2F0dHJpYnV0ZXMiKSxmPVN5bWJvbC5mb3IoInNwcml0ZWpzX2NoYW5nZWRBdHRycyIpLHY9U3ltYm9sKCJzdWJqZWN0IikscD1TeW1ib2woImF0dHIiKSxDPVN5bWJvbCgiZGVmYXVsdCIpLE09U3ltYm9sKCJhbGlhcyIpO2Z1bmN0aW9uIG0oSSxbUCxMXSl7bGV0IEQ9ci5tYXQyZC5mcm9tVmFsdWVzKDEsMCwwLDEsMCwwKTtyZXR1cm5bLi4uSV0uZm9yRWFjaCgoW1IsQV0pPT57aWYoKFB8fEwpJiYoRD1yLm1hdDJkLnRyYW5zbGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCksRCxbUCxMXSkpLFI9PT0ibWF0cml4IilEPXIubWF0MmQubXVsdGlwbHkoRCxELEEpO2Vsc2UgaWYoUj09PSJvZmZzZXRUcmFuc2xhdGUiKURbNF0rPUFbMF0sRFs1XSs9QVsxXTtlbHNlIGlmKFI9PT0ib2Zmc2V0Um90YXRlIilEPXIubWF0MmQucm90YXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxELEEpO2Vsc2UgaWYoUj09PSJza2V3Iil7Y29uc3RbaixHXT1BO0Q9ci5tYXQyZC5tdWx0aXBseShELEQsci5tYXQyZC5mcm9tVmFsdWVzKDEsTWF0aC50YW4oRyksTWF0aC50YW4oaiksMSwwLDApKX1lbHNlIHIubWF0MmRbUl0oRCxELEEpOyhQfHxMKSYmKEQ9ci5tYXQyZC50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDApLEQsWy1QLC1MXSkpfSksRH1jb25zdCB5PVN5bWJvbCgidHJhbnNmb3JtTWF0cml4Iiksbj1TeW1ib2woInRyYW5zZm9ybXMiKSxvPVN5bWJvbCgiY2hhbmdlZEF0dHJzIikscz1TeW1ib2woImxhc3RDaGFuZ2VkQXR0ciIpLGw9U3ltYm9sKCJvZmZzZXRGaWd1cmUiKTtmdW5jdGlvbiBFKEksUCxMKXtjb25zdCBEPUlbcF1bUF07aWYoSVthXShQLEwsITEpfHxJW3NdIT09UCl7Y29uc3QgQT1JW25dO0EuaGFzKFApJiZBLmRlbGV0ZShQKSxMJiYoUD09PSJyb3RhdGUiJiYoTD1NYXRoLlBJKkwvMTgwKSxQPT09InNjYWxlIiYmKEw9TC5tYXAoaj0+TWF0aC5hYnMoaik+MWUtNT9qOjEvaj4wPzFlLTU6LTFlLTUpKSxBLnNldChQLEwpKSxJW3ldPW51bGwsSVt2XS5vblByb3BlcnR5Q2hhbmdlKFAsTCxELEkpfX1mdW5jdGlvbiBUKEkpe2NvbnN0IFA9SVtsXSxMPUkub2Zmc2V0RGlzdGFuY2UqUC5nZXRUb3RhbExlbmd0aCgpLEQ9UC5nZXRQb2ludEF0TGVuZ3RoKEwpO2lmKEQpe2NvbnN0IFI9SVtuXTtsZXQgQT1JLm9mZnNldFJvdGF0ZTtBPT09ImF1dG8iP0E9RC5hbmdsZTpBPT09InJldmVyc2UiP0E9TWF0aC5QSStELmFuZ2xlOkE9TWF0aC5QSSpBLzE4MCxSLnNldCgib2Zmc2V0Um90YXRlIixBKSxSLnNldCgib2Zmc2V0VHJhbnNsYXRlIixbRC54LEQueV0pLElbeV09bnVsbH19Y2xhc3MgYntzdGF0aWMgc2V0RGVmYXVsdChQLC4uLkwpe3JldHVybiBQW2ddKC4uLkwpfXN0YXRpYyBkZWNsYXJlQWxpYXMoUCwuLi5MKXtyZXR1cm4gUFt1XSguLi5MKX1zdGF0aWMgc2V0QXR0cmlidXRlKFAsLi4uTCl7cmV0dXJuIFBbYV0oLi4uTCl9c3RhdGljIGdldEF0dHJpYnV0ZShQLC4uLkwpe3JldHVybiBQW2NdKC4uLkwpfXN0YXRpYyBnZXRBdHRyaWJ1dGVzKFApe3JldHVybiBQW3hdfXN0YXRpYyBnZXRDaGFuZ2VkQXR0cmlidXRlcyhQKXtyZXR1cm4gUFtmXX1jb25zdHJ1Y3RvcihQKXt0aGlzW3ZdPVAsdGhpc1twXT17fSx0aGlzW3ldPXIubWF0MmQuZnJvbVZhbHVlcygxLDAsMCwxLDAsMCksdGhpc1tuXT1uZXcgTWFwLHRoaXNbQ109e30sdGhpc1tNXT1bXSxPYmplY3QuZGVmaW5lUHJvcGVydHkoUCwidHJhbnNmb3JtTWF0cml4Iix7Z2V0OigpPT4odGhpc1t5XXx8KHRoaXNbeV09bSh0aGlzW25dLHRoaXMudHJhbnNmb3JtT3JpZ2luKSksWy4uLnRoaXNbeV1dKX0pLHRoaXNbZ10oe2lkOiIiLG5hbWU6IiIsY2xhc3NOYW1lOiIiLHg6MCx5OjAsdHJhbnNmb3JtT3JpZ2luOlswLDBdLHRyYW5zZm9ybToiIix0cmFuc2xhdGU6WzAsMF0scm90YXRlOjAsc2NhbGU6WzEsMV0sc2tldzpbMCwwXSxvcGFjaXR5OjEsekluZGV4OjAsb2Zmc2V0UGF0aDp2b2lkIDAsb2Zmc2V0RGlzdGFuY2U6MCxvZmZzZXRSb3RhdGU6ImF1dG8iLHBvaW50ZXJFdmVudHM6InZpc2libGUiLGZpbHRlcjoibm9uZSIsZGlzcGxheToiIn0pLHRoaXNbdV0oImNsYXNzIiwicG9zIiksdGhpc1tvXT1uZXcgU2V0LHRoaXNbbF09bmV3IGkuRmlndXJlMkQoe3NjYWxlOjUsc2ltcGxpZnk6MH0pfWdldFtmXSgpe2NvbnN0IFA9e307cmV0dXJuWy4uLnRoaXNbb11dLmZvckVhY2goTD0+e1BbTF09dGhpc1twXVtMXX0pLFB9Z2V0W3hdKCl7Y29uc3QgUD1PYmplY3QuYXNzaWduKHt9LHRoaXNbcF0pO2ZvcihsZXQgTD0wO0w8dGhpc1tNXS5sZW5ndGg7TCsrKXtjb25zdCBEPXRoaXNbTV1bTF07UFtEXT10aGlzW0RdfXJldHVybiBQfVtnXShQKXtPYmplY3QuYXNzaWduKHRoaXNbQ10sUCksT2JqZWN0LmFzc2lnbih0aGlzW3BdLFApfVt1XSguLi5QKXt0aGlzW01dLnB1c2goLi4uUCl9W2FdKFAsTCxEPSEwKXtjb25zdCBSPXRoaXNbcF1bUF0sQT10aGlzW3ZdO3JldHVybiBMPT1udWxsJiYoTD10aGlzW0NdW1BdKSxPYmplY3QoaC5jb21wYXJlVmFsdWUpKFIsTCk/ITE6KHRoaXNbcF1bUF09TCx0aGlzW29dLmhhcyhQKSYmdGhpc1tvXS5kZWxldGUoUCksdGhpc1tvXS5hZGQoUCksdGhpc1tzXT1QLEQmJkEub25Qcm9wZXJ0eUNoYW5nZShQLEwsUix0aGlzKSwhMCl9W2NdKFApe3JldHVybiB0aGlzW3BdW1BdfXNldCBpZChQKXt0aGlzW2FdKCJpZCIsUCl9Z2V0IGlkKCl7cmV0dXJuIHRoaXNbY10oImlkIil9c2V0IG5hbWUoUCl7dGhpc1thXSgibmFtZSIsUCl9Z2V0IG5hbWUoKXtyZXR1cm4gdGhpc1tjXSgibmFtZSIpfXNldCBjbGFzc05hbWUoUCl7dGhpc1thXSgiY2xhc3NOYW1lIixQKX1nZXQgY2xhc3NOYW1lKCl7cmV0dXJuIHRoaXNbY10oImNsYXNzTmFtZSIpfXNldCBjbGFzcyhQKXt0aGlzLmNsYXNzTmFtZT1QfWdldCBjbGFzcygpe3JldHVybiB0aGlzLmNsYXNzTmFtZX1nZXQgeCgpe3JldHVybiB0aGlzW2NdKCJ4Iil9c2V0IHgoUCl7dGhpc1thXSgieCIsT2JqZWN0KGgudG9OdW1iZXIpKFApKX1nZXQgeSgpe3JldHVybiB0aGlzW2NdKCJ5Iil9c2V0IHkoUCl7dGhpc1thXSgieSIsT2JqZWN0KGgudG9OdW1iZXIpKFApKX1nZXQgcG9zKCl7cmV0dXJuW3RoaXMueCx0aGlzLnldfXNldCBwb3MoUCl7UD1PYmplY3QoaC50b0FycmF5KShQKSxBcnJheS5pc0FycmF5KFApfHwoUD1bUCxQXSksdGhpcy54PVBbMF0sdGhpcy55PVBbMV19Z2V0IHRyYW5zZm9ybSgpe3JldHVybiB0aGlzW2NdKCJ0cmFuc2Zvcm0iKX1zZXQgdHJhbnNmb3JtKFApe2xldCBMPW51bGw7aWYoQXJyYXkuaXNBcnJheShQKSYmKEw9UCxQPWBtYXRyaXgoJHtQLm1hcChoLnRvTnVtYmVyKS5qb2luKCl9KWApLHR5cGVvZiBQPT0ic3RyaW5nIilQPVAucmVwbGFjZSgvXHMqLFxzKi9nLCIsIik7ZWxzZSBpZihQIT1udWxsKXRocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgdHJhbnNmb3JtIHZhbHVlLiIpO2NvbnN0IEQ9dGhpc1twXS50cmFuc2Zvcm07aWYodGhpc1thXSgidHJhbnNmb3JtIixQLCExKSl7Y29uc3QgUj10aGlzW25dO2lmKFIuaGFzKCJtYXRyaXgiKSYmUi5kZWxldGUoIm1hdHJpeCIpLEwpUi5zZXQoIm1hdHJpeCIsTCk7ZWxzZSBpZihQKXtjb25zdCBBPVAubWF0Y2goLyhtYXRyaXh8dHJhbnNsYXRlfHJvdGF0ZXxzY2FsZXxza2V3KVwoW14oKV0rXCkvZyk7aWYoQSl7bGV0IGo9ci5tYXQyZC5mcm9tVmFsdWVzKDEsMCwwLDEsMCwwKTtmb3IobGV0IEc9MDtHPEEubGVuZ3RoO0crKyl7Y29uc3QgWj1BW0ddLm1hdGNoKC9eKG1hdHJpeHx0cmFuc2xhdGV8cm90YXRlfHNjYWxlfHNrZXcpXCgoW14oKV0rKVwpLyk7aWYoWil7bGV0WyxxLEZdPVo7cT09PSJyb3RhdGUiP0Y9TWF0aC5QSSpwYXJzZUZsb2F0KEYpLzE4MDpGPUYudHJpbSgpLnNwbGl0KC9bXHMsXSsvKS5tYXAoJD0+T2JqZWN0KGgudG9OdW1iZXIpKCQpKSxxPT09Im1hdHJpeCI/aj1yLm1hdDJkLm11bHRpcGx5KGosaixGKTpxPT09InNrZXciP2o9ci5tYXQyZC5tdWx0aXBseShqLGosci5tYXQyZC5mcm9tVmFsdWVzKDEsTWF0aC50YW4oRlsxXSksTWF0aC50YW4oRlswXSksMSwwLDApKTpyLm1hdDJkW3FdKGosaixGKSxSLnNldCgibWF0cml4IixqKX19fWVsc2UgdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCB0cmFuc2Zvcm0gdmFsdWUuIil9dGhpc1t5XT1udWxsLHRoaXNbdl0ub25Qcm9wZXJ0eUNoYW5nZSgidHJhbnNmb3JtIixQLEQsdGhpcyl9fWdldCB0cmFuc2Zvcm1PcmlnaW4oKXtyZXR1cm4gdGhpc1tjXSgidHJhbnNmb3JtT3JpZ2luIil9c2V0IHRyYW5zZm9ybU9yaWdpbihQKXtQPU9iamVjdChoLnRvQXJyYXkpKFAsITApLFAhPW51bGwmJiFBcnJheS5pc0FycmF5KFApJiYoUD1bUCxQXSksdGhpc1thXSgidHJhbnNmb3JtT3JpZ2luIixQKSYmKHRoaXNbeV09bnVsbCl9Z2V0IHJvdGF0ZSgpe3JldHVybiB0aGlzW2NdKCJyb3RhdGUiKX1zZXQgcm90YXRlKFApe0UodGhpcywicm90YXRlIixQKX1nZXQgdHJhbnNsYXRlKCl7cmV0dXJuIHRoaXNbY10oInRyYW5zbGF0ZSIpfXNldCB0cmFuc2xhdGUoUCl7UD1PYmplY3QoaC50b0FycmF5KShQLCEwKSxQIT1udWxsJiYhQXJyYXkuaXNBcnJheShQKSYmKFA9W1AsUF0pLEUodGhpcywidHJhbnNsYXRlIixQKX1nZXQgc2NhbGUoKXtyZXR1cm4gdGhpc1tjXSgic2NhbGUiKX1zZXQgc2NhbGUoUCl7UD1PYmplY3QoaC50b0FycmF5KShQLCEwKSxQIT1udWxsJiYhQXJyYXkuaXNBcnJheShQKSYmKFA9W1AsUF0pLEUodGhpcywic2NhbGUiLFApfWdldCBza2V3KCl7cmV0dXJuIHRoaXNbY10oInNrZXciKX1zZXQgc2tldyhQKXtQPU9iamVjdChoLnRvQXJyYXkpKFAsITApLFAhPW51bGwmJiFBcnJheS5pc0FycmF5KFApJiYoUD1bUCxQXSksRSh0aGlzLCJza2V3IixQKX1nZXQgb3BhY2l0eSgpe3JldHVybiB0aGlzW2NdKCJvcGFjaXR5Iil9c2V0IG9wYWNpdHkoUCl7UCE9bnVsbCYmKFA9TnVtYmVyKFApKSx0aGlzW2FdKCJvcGFjaXR5IixQKX1nZXQgekluZGV4KCl7cmV0dXJuIHRoaXNbY10oInpJbmRleCIpfXNldCB6SW5kZXgoUCl7UCE9bnVsbCYmKFA9TnVtYmVyKFApKSx0aGlzW2FdKCJ6SW5kZXgiLFApfWdldCBvZmZzZXRQYXRoKCl7cmV0dXJuIHRoaXNbY10oIm9mZnNldFBhdGgiKX1zZXQgb2Zmc2V0UGF0aChQKXt0aGlzW2FdKCJvZmZzZXRQYXRoIixQKSYmKHRoaXNbbF0uYmVnaW5QYXRoKCksUCE9bnVsbCYmdGhpc1tsXS5hZGRQYXRoKFApLFQodGhpcykpfWdldCBvZmZzZXREaXN0YW5jZSgpe3JldHVybiB0aGlzW2NdKCJvZmZzZXREaXN0YW5jZSIpfXNldCBvZmZzZXREaXN0YW5jZShQKXt0aGlzW2FdKCJvZmZzZXREaXN0YW5jZSIsT2JqZWN0KGgudG9OdW1iZXIpKFApKSYmVCh0aGlzKX1nZXQgb2Zmc2V0Um90YXRlKCl7cmV0dXJuIHRoaXNbY10oIm9mZnNldFJvdGF0ZSIpfXNldCBvZmZzZXRSb3RhdGUoUCl7dGhpc1thXSgib2Zmc2V0Um90YXRlIixQKSxUKHRoaXMpfWdldCBwb2ludGVyRXZlbnRzKCl7cmV0dXJuIHRoaXNbY10oInBvaW50ZXJFdmVudHMiKX1zZXQgcG9pbnRlckV2ZW50cyhQKXtpZihQIT1udWxsJiZQIT09Im5vbmUiJiZQIT09InZpc2libGUiJiZQIT09InZpc2libGVGaWxsIiYmUCE9PSJ2aXNpYmxlU3Ryb2tlIiYmUCE9PSJhbGwiKXRocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgcG9pbnRlckV2ZW50cyB0eXBlLiIpO3RoaXNbYV0oInBvaW50ZXJFdmVudHMiLFApfWdldCBmaWx0ZXIoKXtyZXR1cm4gdGhpc1tjXSgiZmlsdGVyIil9c2V0IGZpbHRlcihQKXt0aGlzW2FdKCJmaWx0ZXIiLFApfWdldCBkaXNwbGF5KCl7cmV0dXJuIHRoaXNbY10oImRpc3BsYXkiKX1zZXQgZGlzcGxheShQKXt0aGlzW2FdKCJkaXNwbGF5IixQKX1zZXQgb2Zmc2V0KFApe319fSxmdW5jdGlvbihTLGUsdCl7dC5yKGUpLHQuZChlLCJzaXplVG9QaXhlbCIsZnVuY3Rpb24oKXtyZXR1cm4gcn0pLHQuZChlLCJ0b1N0cmluZyIsZnVuY3Rpb24oKXtyZXR1cm4gaX0pLHQuZChlLCJ0b051bWJlciIsZnVuY3Rpb24oKXtyZXR1cm4gaH0pLHQuZChlLCJ0b0FycmF5IixmdW5jdGlvbigpe3JldHVybiBnfSksdC5kKGUsImNvbXBhcmVWYWx1ZSIsZnVuY3Rpb24oKXtyZXR1cm4gdX0pLHQoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiByKGEsYyl7Y29uc3QgeD1hLnRyaW0oKS5tYXRjaCgvXihbXGQuXSspKHB4fHB0fHBjfGlufGNtfG1tfGVtfGV4fHJlbXxxfHZ3fHZofHZtYXh8dm1pbikkLyk7eD9hPXtzaXplOnBhcnNlRmxvYXQoeFsxXSksdW5pdDp4WzJdfTphPXtzaXplOnBhcnNlRmxvYXQoYSksdW5pdDoicHgifTtsZXR7c2l6ZTpmLHVuaXQ6dn09YTtpZih2PT09InB0IilmLz0uNzU7ZWxzZSBpZih2PT09InBjIilmKj0xNjtlbHNlIGlmKHY9PT0iaW4iKWYqPTk2O2Vsc2UgaWYodj09PSJjbSIpZio9OTYvMi41NDtlbHNlIGlmKHY9PT0ibW0iKWYqPTk2LzI1LjQ7ZWxzZSBpZih2PT09ImVtInx8dj09PSJyZW0ifHx2PT09ImV4Iil7aWYoIWMmJnR5cGVvZiBnZXRDb21wdXRlZFN0eWxlPT0iZnVuY3Rpb24iJiZ0eXBlb2YgZG9jdW1lbnQ8InUiKXtjb25zdCBwPWdldENvbXB1dGVkU3R5bGUoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KS5mb250U2l6ZTtwP2M9cihwLDE2KTpjPTE2fWYqPWMsdj09PSJleCImJihmLz0yKX1lbHNlIGlmKHY9PT0icSIpZio9OTYvMjUuNC80O2Vsc2UgaWYodj09PSJ2dyJ8fHY9PT0idmgiKXtpZih0eXBlb2YgZG9jdW1lbnQ8InUiKXtjb25zdCBwPXY9PT0idnciP3dpbmRvdy5pbm5lcldpZHRofHxkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGg6d2luZG93LmlubmVySGVpZ2h0fHxkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0O2YqPXAvMTAwfX1lbHNlIGlmKCh2PT09InZtYXgifHx2PT09InZtaW4iKSYmdHlwZW9mIGRvY3VtZW50PCJ1Iil7Y29uc3QgcD13aW5kb3cuaW5uZXJXaWR0aHx8ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoLEM9d2luZG93LmlubmVySGVpZ2h0fHxkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0O3Y9PT0idm1heCI/Zio9TWF0aC5tYXgocCxDKS8xMDA6Zio9TWF0aC5taW4ocCxDKS8xMDB9cmV0dXJuIGZ9ZnVuY3Rpb24gaShhKXtyZXR1cm4gYT09bnVsbD9hOlN0cmluZyhhKX1mdW5jdGlvbiBoKGEpe2lmKGE9PW51bGwpcmV0dXJuIGE7aWYodHlwZW9mIGE9PSJzdHJpbmciJiYoYT1yKGEpKSwhTnVtYmVyLmlzRmluaXRlKGEpKXRocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgdmFsdWUiKTtyZXR1cm4gYX1mdW5jdGlvbiBnKGEsYz0hMSl7cmV0dXJuIGE9PT0iIj9udWxsOih0eXBlb2YgYT09InN0cmluZyImJihhPWEuc3BsaXQoL1tccyxdKy9nKSksQXJyYXkuaXNBcnJheShhKSYmKGMmJihhPWEubWFwKGgpKSxhLmxlbmd0aD09PTEpP2FbMF06YSl9ZnVuY3Rpb24gdShhLGMpe2lmKEFycmF5LmlzQXJyYXkoYSkmJkFycmF5LmlzQXJyYXkoYykpe2lmKGEubGVuZ3RoIT09Yy5sZW5ndGgpcmV0dXJuITE7Zm9yKGxldCB4PTA7eDxhLmxlbmd0aDt4KyspaWYoYVt4XSE9PWNbeF0pcmV0dXJuITE7cmV0dXJuITB9cmV0dXJuIGE9PW51bGwmJmM9PW51bGx8fGE9PT1jfX0sZnVuY3Rpb24oUyxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gdn0pO3ZhciByPXQoNzQpLGk9dCgzMiksaD10Lm4oaSksZz10KDY4KSx1PXQoNzIpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBhKCl7cmV0dXJuIGE9T2JqZWN0LmFzc2lnbnx8ZnVuY3Rpb24ocCl7Zm9yKHZhciBDPTE7Qzxhcmd1bWVudHMubGVuZ3RoO0MrKyl7dmFyIE09YXJndW1lbnRzW0NdO2Zvcih2YXIgbSBpbiBNKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChNLG0pJiYocFttXT1NW21dKX1yZXR1cm4gcH0sYS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9ZnVuY3Rpb24gYyhwKXtpZih0eXBlb2YgcD09InN0cmluZyIpe2lmKHA9cC50cmltKCksL15bMC05Ll0rJSQvLnRlc3QocCkpcmV0dXJuIHBhcnNlRmxvYXQocCkvMTAwO2lmKC9eKFtcZC5dKykocHh8cHR8cGN8aW58Y218bW18ZW18ZXh8cmVtfHF8dnd8dmh8dm1heHx2bWluKSQvLnRlc3QocCkpcmV0dXJuIE9iamVjdCh1LnNpemVUb1BpeGVsKShwKX1yZXR1cm4gcH1mdW5jdGlvbiB4KHAsQyxNLG0seSl7cmV0dXJuIHR5cGVvZiBwPT0ic3RyaW5nIiYmKHA9aCgpKHApKSx0eXBlb2YgQz09InN0cmluZyImJihDPWgoKShDKSksci5FZmZlY3RzLmRlZmF1bHQocCxDLE0sbSx5KX1mdW5jdGlvbiBmKHAsQyxNLG0seSl7cmV0dXJuIHIuRWZmZWN0cy5kZWZhdWx0KHAsQyxNLG0seSl9ci5FZmZlY3RzLmRlZmF1bHQ9ZnVuY3Rpb24ocCxDLE0sbSx5KXtyZXR1cm4gQXJyYXkuaXNBcnJheShwKSYmQXJyYXkuaXNBcnJheShDKT9wLm1hcCgobixvKT0+bisoTS1tKS8oeS1tKSooQ1tvXS1uKSk6dHlwZW9mIHA9PSJudW1iZXIiJiZ0eXBlb2YgQz09Im51bWJlciI/cCsoTS1tKS8oeS1tKSooQy1wKTpNLW0+eS1NP0M6cH0sci5FZmZlY3RzLmZpbGxDb2xvcj14LHIuRWZmZWN0cy5zdHJva2VDb2xvcj14LHIuRWZmZWN0cy5iZ2NvbG9yPXgsci5FZmZlY3RzLmJvcmRlckNvbG9yPXgsci5FZmZlY3RzLnRleHQ9ZjtjbGFzcyB2IGV4dGVuZHMgci5BbmltYXRvcntjb25zdHJ1Y3RvcihDLE0sbSl7Y29uc3QgeT1DLmF0dHIoKTtPYmplY3QuZW50cmllcyh5KS5mb3JFYWNoKChbbixvXSk9Pnt5W25dPXIuRWZmZWN0c1tuXT9vOmMobyl9KSxNPU0ubWFwKG49PntsZXQgbz1hKHt9LG4pO2NvbnN0IHM9e307cmV0dXJuIE9iamVjdC5lbnRyaWVzKG8pLmZvckVhY2goKFtsLEVdKT0+e3NbbF09ci5FZmZlY3RzW2xdP0U6YyhFKX0pLHN9KSxzdXBlcih5LE0sbSksdGhpcy50YXJnZXQ9Qyx0aGlzLnNldHRlcj1mdW5jdGlvbihuLG8pe28uYXR0cihuKX19Z2V0IHBsYXlTdGF0ZSgpe3JldHVybiB0aGlzLnRhcmdldC5wYXJlbnQ/c3VwZXIucGxheVN0YXRlOiJpZGxlIn1nZXQgZmluaXNoZWQoKXtyZXR1cm4gc3VwZXIuZmluaXNoZWQudGhlbigoKT0+e2NvbnN0IEM9dGhpcztyZXR1cm4gbmV3IFByb21pc2UoTT0+e2Z1bmN0aW9uIG0oKXtDLnNldHRlcihDLmZyYW1lLEMudGFyZ2V0KTtjb25zdCB5PUMucGxheVN0YXRlO3k9PT0iZmluaXNoZWQifHx5PT09ImlkbGUiPyhPYmplY3QoZy5jYW5jZWxBbmltYXRpb25GcmFtZSkoQy5yZXF1ZXN0SWQpLE0oKSk6T2JqZWN0KGcucmVxdWVzdEFuaW1hdGlvbkZyYW1lKShtKX1tKCl9KX0pfWZpbmlzaCgpe3N1cGVyLmZpbmlzaCgpLE9iamVjdChnLmNhbmNlbEFuaW1hdGlvbkZyYW1lKSh0aGlzLnJlcXVlc3RJZCksdGhpcy5zZXR0ZXIodGhpcy5mcmFtZSx0aGlzLnRhcmdldCl9cGxheSgpe2lmKCF0aGlzLnRhcmdldC5wYXJlbnR8fHRoaXMucGxheVN0YXRlPT09InJ1bm5pbmciKXJldHVybjtzdXBlci5wbGF5KCksdGhpcy5zZXR0ZXIodGhpcy5mcmFtZSx0aGlzLnRhcmdldCk7Y29uc3QgQz10aGlzO3RoaXMucmVhZHkudGhlbigoKT0+e0Muc2V0dGVyKEMuZnJhbWUsQy50YXJnZXQpLEMucmVxdWVzdElkPU9iamVjdChnLnJlcXVlc3RBbmltYXRpb25GcmFtZSkoZnVuY3Rpb24gTSgpe2NvbnN0IG09Qy50YXJnZXQ7aWYodHlwZW9mIGRvY3VtZW50PCJ1IiYmZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50JiZkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY29udGFpbnMmJm0ubGF5ZXImJm0ubGF5ZXIuY2FudmFzJiYhZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNvbnRhaW5zKG0ubGF5ZXIuY2FudmFzKSl7Qy5jYW5jZWwoKTtyZXR1cm59Y29uc3QgeT1DLnBsYXlTdGF0ZTtDLnNldHRlcihDLmZyYW1lLEMudGFyZ2V0KSx5IT09ImlkbGUiJiYoeT09PSJydW5uaW5nIj9DLnJlcXVlc3RJZD1PYmplY3QoZy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpKE0pOih5PT09InBhdXNlZCJ8fHk9PT0icGVuZGluZyImJkMudGltZWxpbmUuY3VycmVudFRpbWU8MCkmJkMucmVhZHkudGhlbigoKT0+e0Muc2V0dGVyKEMuZnJhbWUsQy50YXJnZXQpLEMucmVxdWVzdElkPU9iamVjdChnLnJlcXVlc3RBbmltYXRpb25GcmFtZSkoTSl9KSl9KX0pfWNhbmNlbChDPSExKXtPYmplY3QoZy5jYW5jZWxBbmltYXRpb25GcmFtZSkodGhpcy5yZXF1ZXN0SWQpLEM/KHRoaXMuc2V0dGVyKHRoaXMuZnJhbWUsdGhpcy50YXJnZXQpLHN1cGVyLmNhbmNlbCgpKTooc3VwZXIuY2FuY2VsKCksdGhpcy5zZXR0ZXIodGhpcy5mcmFtZSx0aGlzLnRhcmdldCkpfX19LGZ1bmN0aW9uKFMsZSx0KXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksZS5UaW1lbGluZT1lLkVmZmVjdHM9ZS5FYXNpbmdzPWUuQW5pbWF0b3I9dm9pZCAwO3ZhciByPXQoNzUpLGk9eChyKSxoPXQoMTg3KSxnPXgoaCksdT10KDE4OCksYT10KDE5MCksYz14KGEpO2Z1bmN0aW9uIHgoZil7cmV0dXJuIGYmJmYuX19lc01vZHVsZT9mOntkZWZhdWx0OmZ9fWUuQW5pbWF0b3I9Yy5kZWZhdWx0LGUuRWFzaW5ncz11LkVhc2luZ3MsZS5FZmZlY3RzPWcuZGVmYXVsdCxlLlRpbWVsaW5lPWkuZGVmYXVsdH0sZnVuY3Rpb24oUyxlLHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KTt2YXIgcj10KDc2KSxpPW4ociksaD10KDEzMyksZz1uKGgpLHU9dCgxNDEpLGE9bih1KSxjPXQoMTY0KSx4PW4oYyksZj10KDE3MCksdj1uKGYpLHA9dCgxNzEpLEM9bihwKSxNPXQoMTc1KSxtPW4oTSkseT10KDE4Nik7ZnVuY3Rpb24gbihEKXtyZXR1cm4gRCYmRC5fX2VzTW9kdWxlP0Q6e2RlZmF1bHQ6RH19dmFyIG89KDAseS5jcmVhdGVOb3dUaW1lKSgpLHM9e29yaWdpblRpbWU6MCxwbGF5YmFja1JhdGU6MX0sbD0oMCxtLmRlZmF1bHQpKCJ0aW1lTWFyayIpLEU9KDAsbS5kZWZhdWx0KSgicGxheWJhY2tSYXRlIiksVD0oMCxtLmRlZmF1bHQpKCJ0aW1lcnMiKSxiPSgwLG0uZGVmYXVsdCkoIm9yaWdpblRpbWUiKSxJPSgwLG0uZGVmYXVsdCkoInNldFRpbWVyIiksUD0oMCxtLmRlZmF1bHQpKCJwYXJlbnQiKSxMPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gRChSLEEpeygwLHYuZGVmYXVsdCkodGhpcyxEKSxSIGluc3RhbmNlb2YgRCYmKEE9UixSPXt9KSxSPSgwLHguZGVmYXVsdCkoe30scyxSKSxBJiYodGhpc1tQXT1BKTt2YXIgaj1SLm5vd3RpbWV8fG87aWYoQSlPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiZ2xvYmFsVGltZSIse2dldDpmdW5jdGlvbigpe3JldHVybiBBLmN1cnJlbnRUaW1lfX0pO2Vsc2V7dmFyIEc9aigpO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJnbG9iYWxUaW1lIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGooKS1HfX0pfXRoaXNbbF09W3tnbG9iYWxUaW1lOnRoaXMuZ2xvYmFsVGltZSxsb2NhbFRpbWU6LVIub3JpZ2luVGltZSxlbnRyb3B5Oi1SLm9yaWdpblRpbWUscGxheWJhY2tSYXRlOlIucGxheWJhY2tSYXRlLGdsb2JhbEVudHJvcHk6MH1dLHRoaXNbUF0mJih0aGlzW2xdWzBdLmdsb2JhbEVudHJvcHk9dGhpc1tQXS5lbnRyb3B5KSx0aGlzW2JdPVIub3JpZ2luVGltZSx0aGlzW0VdPVIucGxheWJhY2tSYXRlLHRoaXNbVF09bmV3IGEuZGVmYXVsdH1yZXR1cm4oMCxDLmRlZmF1bHQpKEQsW3trZXk6Im1hcmtUaW1lIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBBPWFyZ3VtZW50cy5sZW5ndGg+MCYmYXJndW1lbnRzWzBdIT09dm9pZCAwP2FyZ3VtZW50c1swXTp7fSxqPUEudGltZSxHPWo9PT12b2lkIDA/dGhpcy5jdXJyZW50VGltZTpqLEg9QS5lbnRyb3B5LFo9SD09PXZvaWQgMD90aGlzLmVudHJvcHk6SCxxPUEucGxheWJhY2tSYXRlLEY9cT09PXZvaWQgMD90aGlzLnBsYXliYWNrUmF0ZTpxLCQ9e2dsb2JhbFRpbWU6dGhpcy5nbG9iYWxUaW1lLGxvY2FsVGltZTpHLGVudHJvcHk6WixwbGF5YmFja1JhdGU6RixnbG9iYWxFbnRyb3B5OnRoaXMuZ2xvYmFsRW50cm9weX07dGhpc1tsXS5wdXNoKCQpfX0se2tleToiZm9yayIsdmFsdWU6ZnVuY3Rpb24oQSl7cmV0dXJuIG5ldyBEKEEsdGhpcyl9fSx7a2V5OiJzZWVrR2xvYmFsVGltZSIsdmFsdWU6ZnVuY3Rpb24oQSl7dmFyIGo9dGhpcy5zZWVrVGltZU1hcmsoQSksRz10aGlzW2xdW2pdLEg9Ry5lbnRyb3B5LFo9Ry5wbGF5YmFja1JhdGUscT1HLmdsb2JhbFRpbWU7cmV0dXJuIHErKEEtSCkvTWF0aC5hYnMoWil9fSx7a2V5OiJzZWVrTG9jYWxUaW1lIix2YWx1ZTpmdW5jdGlvbihBKXt2YXIgaj10aGlzLnNlZWtUaW1lTWFyayhBKSxHPXRoaXNbbF1bal0sSD1HLmxvY2FsVGltZSxaPUcuZW50cm9weSxxPUcucGxheWJhY2tSYXRlO3JldHVybiBxPjA/SCsoQS1aKTpILShBLVopfX0se2tleToic2Vla1RpbWVNYXJrIix2YWx1ZTpmdW5jdGlvbihBKXt2YXIgaj10aGlzW2xdLEc9MCxIPWoubGVuZ3RoLTE7aWYoQTw9altHXS5lbnRyb3B5KXJldHVybiBHO2lmKEE+PWpbSF0uZW50cm9weSlyZXR1cm4gSDtmb3IodmFyIFo9TWF0aC5mbG9vcigoRytIKS8yKTtaPkcmJlo8SDspe2lmKEE9PT1qW1pdLmVudHJvcHkpcmV0dXJuIFo7QTxqW1pdLmVudHJvcHk/SD1aOkE+altaXS5lbnRyb3B5JiYoRz1aKSxaPU1hdGguZmxvb3IoKEcrSCkvMil9cmV0dXJuIEd9fSx7a2V5OiJ1cGRhdGVUaW1lcnMiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIEE9dGhpcyxqPVtdLmNvbmNhdCgoMCxnLmRlZmF1bHQpKHRoaXNbVF0pKTtqLmZvckVhY2goZnVuY3Rpb24oRyl7dmFyIEg9KDAsaS5kZWZhdWx0KShHLDIpLFo9SFswXSxxPUhbMV07QVtJXShxLmhhbmRsZXIscS50aW1lLFopfSl9fSx7a2V5OiJjbGVhclRpbWVvdXQiLHZhbHVlOmZ1bmN0aW9uKFIpe2Z1bmN0aW9uIEEoail7cmV0dXJuIFIuYXBwbHkodGhpcyxhcmd1bWVudHMpfXJldHVybiBBLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIFIudG9TdHJpbmcoKX0sQX0oZnVuY3Rpb24oUil7dmFyIEE9dGhpc1tUXS5nZXQoUik7QSYmQS50aW1lcklEIT1udWxsJiYodGhpc1tQXT90aGlzW1BdLmNsZWFyVGltZW91dChBLnRpbWVySUQpOmNsZWFyVGltZW91dChBLnRpbWVySUQpKSx0aGlzW1RdLmRlbGV0ZShSKX0pfSx7a2V5OiJjbGVhckludGVydmFsIix2YWx1ZTpmdW5jdGlvbihBKXtyZXR1cm4gdGhpcy5jbGVhclRpbWVvdXQoQSl9fSx7a2V5OiJjbGVhciIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgQT10aGlzLGo9dGhpc1tUXTtbXS5jb25jYXQoKDAsZy5kZWZhdWx0KShqLmtleXMoKSkpLmZvckVhY2goZnVuY3Rpb24oRyl7QS5jbGVhclRpbWVvdXQoRyl9KX19LHtrZXk6InNldFRpbWVvdXQiLHZhbHVlOmZ1bmN0aW9uKEEpe3ZhciBqPWFyZ3VtZW50cy5sZW5ndGg+MSYmYXJndW1lbnRzWzFdIT09dm9pZCAwP2FyZ3VtZW50c1sxXTp7ZGVsYXk6MH07cmV0dXJuIHRoaXNbSV0oQSxqKX19LHtrZXk6InNldEludGVydmFsIix2YWx1ZTpmdW5jdGlvbihBKXt2YXIgaj1hcmd1bWVudHMubGVuZ3RoPjEmJmFyZ3VtZW50c1sxXSE9PXZvaWQgMD9hcmd1bWVudHNbMV06e2RlbGF5OjB9LEc9dGhpcyxIPXRoaXNbSV0oZnVuY3Rpb24gWigpe0dbSV0oWixqLEgpLEEoKX0saik7cmV0dXJuIEh9fSx7a2V5OkksdmFsdWU6ZnVuY3Rpb24oQSxqKXt2YXIgRz10aGlzLEg9YXJndW1lbnRzLmxlbmd0aD4yJiZhcmd1bWVudHNbMl0hPT12b2lkIDA/YXJndW1lbnRzWzJdOigwLG0uZGVmYXVsdCkoInRpbWVySUQiKTtqPSgwLHkuZm9ybWF0RGVsYXkpKGopO3ZhciBaPXRoaXNbVF0uZ2V0KEgpLHE9dm9pZCAwLEY9bnVsbCwkPXZvaWQgMCxKPXZvaWQgMDtaPyh0aGlzLmNsZWFyVGltZW91dChIKSxqLmlzRW50cm9weT9xPShqLmRlbGF5LSh0aGlzLmVudHJvcHktWi5zdGFydEVudHJvcHkpKS9NYXRoLmFicyh0aGlzLnBsYXliYWNrUmF0ZSk6cT0oai5kZWxheS0odGhpcy5jdXJyZW50VGltZS1aLnN0YXJ0VGltZSkpL3RoaXMucGxheWJhY2tSYXRlLCQ9Wi5zdGFydFRpbWUsSj1aLnN0YXJ0RW50cm9weSk6KHE9ai5kZWxheS8oai5pc0VudHJvcHk/TWF0aC5hYnModGhpcy5wbGF5YmFja1JhdGUpOnRoaXMucGxheWJhY2tSYXRlKSwkPXRoaXMuY3VycmVudFRpbWUsSj10aGlzLmVudHJvcHkpO3ZhciB0dD10aGlzW1BdLF89dHQ/dHQuc2V0VGltZW91dC5iaW5kKHR0KTpzZXRUaW1lb3V0LHN0PWouaGVhZGluZztyZXR1cm4hdHQmJnN0PT09ITEmJnE8MCYmKHE9MS8wKSwoaXNGaW5pdGUocSl8fHR0KSYmKHE9TWF0aC5jZWlsKHEpLF8hPT1zZXRUaW1lb3V0JiYocT17ZGVsYXk6cSxoZWFkaW5nOnN0fSksRj1fKGZ1bmN0aW9uKCl7R1tUXS5kZWxldGUoSCksQSgpfSxxKSksdGhpc1tUXS5zZXQoSCx7dGltZXJJRDpGLGhhbmRsZXI6QSx0aW1lOmosc3RhcnRUaW1lOiQsc3RhcnRFbnRyb3B5Okp9KSxIfX0se2tleToicGFyZW50IixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc1tQXX19LHtrZXk6Imxhc3RUaW1lTWFyayIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXNbbF1bdGhpc1tsXS5sZW5ndGgtMV19fSx7a2V5OiJjdXJyZW50VGltZSIsZ2V0OmZ1bmN0aW9uKCl7dmFyIEE9dGhpcy5sYXN0VGltZU1hcmssaj1BLmxvY2FsVGltZSxHPUEuZ2xvYmFsVGltZTtyZXR1cm4gaisodGhpcy5nbG9iYWxUaW1lLUcpKnRoaXMucGxheWJhY2tSYXRlfSxzZXQ6ZnVuY3Rpb24oQSl7dmFyIGo9dGhpcyxHPXRoaXMuY3VycmVudFRpbWUsSD1BLFo9dGhpc1tUXTt0aGlzLm1hcmtUaW1lKHt0aW1lOkF9KSxbXS5jb25jYXQoKDAsZy5kZWZhdWx0KShaKSkuZm9yRWFjaChmdW5jdGlvbihxKXt2YXIgRj0oMCxpLmRlZmF1bHQpKHEsMiksJD1GWzBdLEo9RlsxXTtpZihaLmhhcygkKSl7dmFyIHR0PUoudGltZSxfPXR0LmlzRW50cm9weSxzdD10dC5kZWxheSxrPXR0LmhlYWRpbmcsY3Q9Si5oYW5kbGVyLGZ0PUouc3RhcnRUaW1lO2lmKF8pc3Q9PT0wJiYoY3QoKSxqLmNsZWFyVGltZW91dCgkKSk7ZWxzZXt2YXIgVz1mdCtzdDsoc3Q9PT0wfHxrIT09ITEmJihILUcpKnN0PD0wfHxHPD1XJiZXPD1IfHxHPj1XJiZXPj1IKSYmKGN0KCksai5jbGVhclRpbWVvdXQoJCkpfX19KSx0aGlzLnVwZGF0ZVRpbWVycygpfX0se2tleToiZW50cm9weSIsZ2V0OmZ1bmN0aW9uKCl7dmFyIEE9dGhpcy5sYXN0VGltZU1hcmssaj1BLmVudHJvcHksRz1BLmdsb2JhbEVudHJvcHk7cmV0dXJuIGorTWF0aC5hYnMoKHRoaXMuZ2xvYmFsRW50cm9weS1HKSp0aGlzLnBsYXliYWNrUmF0ZSl9LHNldDpmdW5jdGlvbihBKXtpZih0aGlzLmVudHJvcHk+QSl7dmFyIGo9dGhpcy5zZWVrVGltZU1hcmsoQSk7dGhpc1tsXS5sZW5ndGg9aisxfXRoaXMubWFya1RpbWUoe2VudHJvcHk6QX0pLHRoaXMudXBkYXRlVGltZXJzKCl9fSx7a2V5OiJnbG9iYWxFbnRyb3B5IixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc1tQXT90aGlzW1BdLmVudHJvcHk6dGhpcy5nbG9iYWxUaW1lfX0se2tleToicGxheWJhY2tSYXRlIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc1tFXX0sc2V0OmZ1bmN0aW9uKEEpe0EhPT10aGlzLnBsYXliYWNrUmF0ZSYmKHRoaXMubWFya1RpbWUoe3BsYXliYWNrUmF0ZTpBfSksdGhpc1tFXT1BLHRoaXMudXBkYXRlVGltZXJzKCkpfX0se2tleToicGF1c2VkIixnZXQ6ZnVuY3Rpb24oKXtpZih0aGlzLnBsYXliYWNrUmF0ZT09PTApcmV0dXJuITA7Zm9yKHZhciBBPXRoaXMucGFyZW50O0E7KXtpZihBLnBsYXliYWNrUmF0ZT09PTApcmV0dXJuITA7QT1BLnBhcmVudH1yZXR1cm4hMX19XSksRH0oKTtlLmRlZmF1bHQ9TH0sZnVuY3Rpb24oUyxlLHQpe2UuX19lc01vZHVsZT0hMDt2YXIgcj10KDc3KSxpPXUociksaD10KDEyOSksZz11KGgpO2Z1bmN0aW9uIHUoYSl7cmV0dXJuIGEmJmEuX19lc01vZHVsZT9hOntkZWZhdWx0OmF9fWUuZGVmYXVsdD1mdW5jdGlvbigpe2Z1bmN0aW9uIGEoYyx4KXt2YXIgZj1bXSx2PSEwLHA9ITEsQz12b2lkIDA7dHJ5e2Zvcih2YXIgTT0oMCxnLmRlZmF1bHQpKGMpLG07ISh2PShtPU0ubmV4dCgpKS5kb25lKSYmKGYucHVzaChtLnZhbHVlKSwhKHgmJmYubGVuZ3RoPT09eCkpO3Y9ITApO31jYXRjaCh5KXtwPSEwLEM9eX1maW5hbGx5e3RyeXshdiYmTS5yZXR1cm4mJk0ucmV0dXJuKCl9ZmluYWxseXtpZihwKXRocm93IEN9fXJldHVybiBmfXJldHVybiBmdW5jdGlvbihjLHgpe2lmKEFycmF5LmlzQXJyYXkoYykpcmV0dXJuIGM7aWYoKDAsaS5kZWZhdWx0KShPYmplY3QoYykpKXJldHVybiBhKGMseCk7dGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZSIpfX0oKX0sZnVuY3Rpb24oUyxlLHQpe1MuZXhwb3J0cz17ZGVmYXVsdDp0KDc4KSxfX2VzTW9kdWxlOiEwfX0sZnVuY3Rpb24oUyxlLHQpe3QoNzkpLHQoMTI1KSxTLmV4cG9ydHM9dCgxMjcpfSxmdW5jdGlvbihTLGUsdCl7dCg4MCk7Zm9yKHZhciByPXQoOTEpLGk9dCg5NSksaD10KDgzKSxnPXQoMTIyKSgidG9TdHJpbmdUYWciKSx1PSJDU1NSdWxlTGlzdCxDU1NTdHlsZURlY2xhcmF0aW9uLENTU1ZhbHVlTGlzdCxDbGllbnRSZWN0TGlzdCxET01SZWN0TGlzdCxET01TdHJpbmdMaXN0LERPTVRva2VuTGlzdCxEYXRhVHJhbnNmZXJJdGVtTGlzdCxGaWxlTGlzdCxIVE1MQWxsQ29sbGVjdGlvbixIVE1MQ29sbGVjdGlvbixIVE1MRm9ybUVsZW1lbnQsSFRNTFNlbGVjdEVsZW1lbnQsTWVkaWFMaXN0LE1pbWVUeXBlQXJyYXksTmFtZWROb2RlTWFwLE5vZGVMaXN0LFBhaW50UmVxdWVzdExpc3QsUGx1Z2luLFBsdWdpbkFycmF5LFNWR0xlbmd0aExpc3QsU1ZHTnVtYmVyTGlzdCxTVkdQYXRoU2VnTGlzdCxTVkdQb2ludExpc3QsU1ZHU3RyaW5nTGlzdCxTVkdUcmFuc2Zvcm1MaXN0LFNvdXJjZUJ1ZmZlckxpc3QsU3R5bGVTaGVldExpc3QsVGV4dFRyYWNrQ3VlTGlzdCxUZXh0VHJhY2tMaXN0LFRvdWNoTGlzdCIuc3BsaXQoIiwiKSxhPTA7YTx1Lmxlbmd0aDthKyspe3ZhciBjPXVbYV0seD1yW2NdLGY9eCYmeC5wcm90b3R5cGU7ZiYmIWZbZ10mJmkoZixnLGMpLGhbY109aC5BcnJheX19LGZ1bmN0aW9uKFMsZSx0KXt2YXIgcj10KDgxKSxpPXQoODIpLGg9dCg4MyksZz10KDg0KTtTLmV4cG9ydHM9dCg4OCkoQXJyYXksIkFycmF5IixmdW5jdGlvbih1LGEpe3RoaXMuX3Q9Zyh1KSx0aGlzLl9pPTAsdGhpcy5faz1hfSxmdW5jdGlvbigpe3ZhciB1PXRoaXMuX3QsYT10aGlzLl9rLGM9dGhpcy5faSsrO3JldHVybiF1fHxjPj11Lmxlbmd0aD8odGhpcy5fdD12b2lkIDAsaSgxKSk6YT09ImtleXMiP2koMCxjKTphPT0idmFsdWVzIj9pKDAsdVtjXSk6aSgwLFtjLHVbY11dKX0sInZhbHVlcyIpLGguQXJndW1lbnRzPWguQXJyYXkscigia2V5cyIpLHIoInZhbHVlcyIpLHIoImVudHJpZXMiKX0sZnVuY3Rpb24oUyxlKXtTLmV4cG9ydHM9ZnVuY3Rpb24oKXt9fSxmdW5jdGlvbihTLGUpe1MuZXhwb3J0cz1mdW5jdGlvbih0LHIpe3JldHVybnt2YWx1ZTpyLGRvbmU6ISF0fX19LGZ1bmN0aW9uKFMsZSl7Uy5leHBvcnRzPXt9fSxmdW5jdGlvbihTLGUsdCl7dmFyIHI9dCg4NSksaT10KDg3KTtTLmV4cG9ydHM9ZnVuY3Rpb24oaCl7cmV0dXJuIHIoaShoKSl9fSxmdW5jdGlvbihTLGUsdCl7dmFyIHI9dCg4Nik7Uy5leHBvcnRzPU9iamVjdCgieiIpLnByb3BlcnR5SXNFbnVtZXJhYmxlKDApP09iamVjdDpmdW5jdGlvbihpKXtyZXR1cm4gcihpKT09IlN0cmluZyI/aS5zcGxpdCgiIik6T2JqZWN0KGkpfX0sZnVuY3Rpb24oUyxlKXt2YXIgdD17fS50b1N0cmluZztTLmV4cG9ydHM9ZnVuY3Rpb24ocil7cmV0dXJuIHQuY2FsbChyKS5zbGljZSg4LC0xKX19LGZ1bmN0aW9uKFMsZSl7Uy5leHBvcnRzPWZ1bmN0aW9uKHQpe2lmKHQ9PW51bGwpdGhyb3cgVHlwZUVycm9yKCJDYW4ndCBjYWxsIG1ldGhvZCBvbiAgIit0KTtyZXR1cm4gdH19LGZ1bmN0aW9uKFMsZSx0KXt2YXIgcj10KDg5KSxpPXQoOTApLGg9dCgxMDYpLGc9dCg5NSksdT10KDgzKSxhPXQoMTA3KSxjPXQoMTIxKSx4PXQoMTIzKSxmPXQoMTIyKSgiaXRlcmF0b3IiKSx2PSEoW10ua2V5cyYmIm5leHQiaW5bXS5rZXlzKCkpLHA9IkBAaXRlcmF0b3IiLEM9ImtleXMiLE09InZhbHVlcyIsbT1mdW5jdGlvbigpe3JldHVybiB0aGlzfTtTLmV4cG9ydHM9ZnVuY3Rpb24oeSxuLG8scyxsLEUsVCl7YShvLG4scyk7dmFyIGI9ZnVuY3Rpb24oRil7aWYoIXYmJkYgaW4gRClyZXR1cm4gRFtGXTtzd2l0Y2goRil7Y2FzZSBDOnJldHVybiBmdW5jdGlvbigpe3JldHVybiBuZXcgbyh0aGlzLEYpfTtjYXNlIE06cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBvKHRoaXMsRil9fXJldHVybiBmdW5jdGlvbigpe3JldHVybiBuZXcgbyh0aGlzLEYpfX0sST1uKyIgSXRlcmF0b3IiLFA9bD09TSxMPSExLEQ9eS5wcm90b3R5cGUsUj1EW2ZdfHxEW3BdfHxsJiZEW2xdLEE9Unx8YihsKSxqPWw/UD9iKCJlbnRyaWVzIik6QTp2b2lkIDAsRz1uPT0iQXJyYXkiJiZELmVudHJpZXN8fFIsSCxaLHE7aWYoRyYmKHE9eChHLmNhbGwobmV3IHkpKSxxIT09T2JqZWN0LnByb3RvdHlwZSYmcS5uZXh0JiYoYyhxLEksITApLCFyJiZ0eXBlb2YgcVtmXSE9ImZ1bmN0aW9uIiYmZyhxLGYsbSkpKSxQJiZSJiZSLm5hbWUhPT1NJiYoTD0hMCxBPWZ1bmN0aW9uKCl7cmV0dXJuIFIuY2FsbCh0aGlzKX0pLCghcnx8VCkmJih2fHxMfHwhRFtmXSkmJmcoRCxmLEEpLHVbbl09QSx1W0ldPW0sbClpZihIPXt2YWx1ZXM6UD9BOmIoTSksa2V5czpFP0E6YihDKSxlbnRyaWVzOmp9LFQpZm9yKFogaW4gSClaIGluIER8fGgoRCxaLEhbWl0pO2Vsc2UgaShpLlAraS5GKih2fHxMKSxuLEgpO3JldHVybiBIfX0sZnVuY3Rpb24oUyxlKXtTLmV4cG9ydHM9ITB9LGZ1bmN0aW9uKFMsZSx0KXt2YXIgcj10KDkxKSxpPXQoOTIpLGg9dCg5MyksZz10KDk1KSx1PXQoMTA1KSxhPSJwcm90b3R5cGUiLGM9ZnVuY3Rpb24oeCxmLHYpe3ZhciBwPXgmYy5GLEM9eCZjLkcsTT14JmMuUyxtPXgmYy5QLHk9eCZjLkIsbj14JmMuVyxvPUM/aTppW2ZdfHwoaVtmXT17fSkscz1vW2FdLGw9Qz9yOk0/cltmXToocltmXXx8e30pW2FdLEUsVCxiO0MmJih2PWYpO2ZvcihFIGluIHYpVD0hcCYmbCYmbFtFXSE9PXZvaWQgMCwhKFQmJnUobyxFKSkmJihiPVQ/bFtFXTp2W0VdLG9bRV09QyYmdHlwZW9mIGxbRV0hPSJmdW5jdGlvbiI/dltFXTp5JiZUP2goYixyKTpuJiZsW0VdPT1iP2Z1bmN0aW9uKEkpe3ZhciBQPWZ1bmN0aW9uKEwsRCxSKXtpZih0aGlzIGluc3RhbmNlb2YgSSl7c3dpdGNoKGFyZ3VtZW50cy5sZW5ndGgpe2Nhc2UgMDpyZXR1cm4gbmV3IEk7Y2FzZSAxOnJldHVybiBuZXcgSShMKTtjYXNlIDI6cmV0dXJuIG5ldyBJKEwsRCl9cmV0dXJuIG5ldyBJKEwsRCxSKX1yZXR1cm4gSS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O3JldHVybiBQW2FdPUlbYV0sUH0oYik6bSYmdHlwZW9mIGI9PSJmdW5jdGlvbiI/aChGdW5jdGlvbi5jYWxsLGIpOmIsbSYmKChvLnZpcnR1YWx8fChvLnZpcnR1YWw9e30pKVtFXT1iLHgmYy5SJiZzJiYhc1tFXSYmZyhzLEUsYikpKX07Yy5GPTEsYy5HPTIsYy5TPTQsYy5QPTgsYy5CPTE2LGMuVz0zMixjLlU9NjQsYy5SPTEyOCxTLmV4cG9ydHM9Y30sZnVuY3Rpb24oUyxlKXt2YXIgdD1TLmV4cG9ydHM9dHlwZW9mIHdpbmRvdzwidSImJndpbmRvdy5NYXRoPT1NYXRoP3dpbmRvdzp0eXBlb2Ygc2VsZjwidSImJnNlbGYuTWF0aD09TWF0aD9zZWxmOkZ1bmN0aW9uKCJyZXR1cm4gdGhpcyIpKCk7dHlwZW9mIF9fZz09Im51bWJlciImJihfX2c9dCl9LGZ1bmN0aW9uKFMsZSl7dmFyIHQ9Uy5leHBvcnRzPXt2ZXJzaW9uOiIyLjYuMTEifTt0eXBlb2YgX19lPT0ibnVtYmVyIiYmKF9fZT10KX0sZnVuY3Rpb24oUyxlLHQpe3ZhciByPXQoOTQpO1MuZXhwb3J0cz1mdW5jdGlvbihpLGgsZyl7aWYocihpKSxoPT09dm9pZCAwKXJldHVybiBpO3N3aXRjaChnKXtjYXNlIDE6cmV0dXJuIGZ1bmN0aW9uKHUpe3JldHVybiBpLmNhbGwoaCx1KX07Y2FzZSAyOnJldHVybiBmdW5jdGlvbih1LGEpe3JldHVybiBpLmNhbGwoaCx1LGEpfTtjYXNlIDM6cmV0dXJuIGZ1bmN0aW9uKHUsYSxjKXtyZXR1cm4gaS5jYWxsKGgsdSxhLGMpfX1yZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gaS5hcHBseShoLGFyZ3VtZW50cyl9fX0sZnVuY3Rpb24oUyxlKXtTLmV4cG9ydHM9ZnVuY3Rpb24odCl7aWYodHlwZW9mIHQhPSJmdW5jdGlvbiIpdGhyb3cgVHlwZUVycm9yKHQrIiBpcyBub3QgYSBmdW5jdGlvbiEiKTtyZXR1cm4gdH19LGZ1bmN0aW9uKFMsZSx0KXt2YXIgcj10KDk2KSxpPXQoMTA0KTtTLmV4cG9ydHM9dCgxMDApP2Z1bmN0aW9uKGgsZyx1KXtyZXR1cm4gci5mKGgsZyxpKDEsdSkpfTpmdW5jdGlvbihoLGcsdSl7cmV0dXJuIGhbZ109dSxofX0sZnVuY3Rpb24oUyxlLHQpe3ZhciByPXQoOTcpLGk9dCg5OSksaD10KDEwMyksZz1PYmplY3QuZGVmaW5lUHJvcGVydHk7ZS5mPXQoMTAwKT9PYmplY3QuZGVmaW5lUHJvcGVydHk6ZnVuY3Rpb24oYSxjLHgpe2lmKHIoYSksYz1oKGMsITApLHIoeCksaSl0cnl7cmV0dXJuIGcoYSxjLHgpfWNhdGNoe31pZigiZ2V0ImluIHh8fCJzZXQiaW4geCl0aHJvdyBUeXBlRXJyb3IoIkFjY2Vzc29ycyBub3Qgc3VwcG9ydGVkISIpO3JldHVybiJ2YWx1ZSJpbiB4JiYoYVtjXT14LnZhbHVlKSxhfX0sZnVuY3Rpb24oUyxlLHQpe3ZhciByPXQoOTgpO1MuZXhwb3J0cz1mdW5jdGlvbihpKXtpZighcihpKSl0aHJvdyBUeXBlRXJyb3IoaSsiIGlzIG5vdCBhbiBvYmplY3QhIik7cmV0dXJuIGl9fSxmdW5jdGlvbihTLGUpe1MuZXhwb3J0cz1mdW5jdGlvbih0KXtyZXR1cm4gdHlwZW9mIHQ9PSJvYmplY3QiP3QhPT1udWxsOnR5cGVvZiB0PT0iZnVuY3Rpb24ifX0sZnVuY3Rpb24oUyxlLHQpe1MuZXhwb3J0cz0hdCgxMDApJiYhdCgxMDEpKGZ1bmN0aW9uKCl7cmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0KDEwMikoImRpdiIpLCJhIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIDd9fSkuYSE9N30pfSxmdW5jdGlvbihTLGUsdCl7Uy5leHBvcnRzPSF0KDEwMSkoZnVuY3Rpb24oKXtyZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCJhIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIDd9fSkuYSE9N30pfSxmdW5jdGlvbihTLGUpe1MuZXhwb3J0cz1mdW5jdGlvbih0KXt0cnl7cmV0dXJuISF0KCl9Y2F0Y2h7cmV0dXJuITB9fX0sZnVuY3Rpb24oUyxlLHQpe3ZhciByPXQoOTgpLGk9dCg5MSkuZG9jdW1lbnQsaD1yKGkpJiZyKGkuY3JlYXRlRWxlbWVudCk7Uy5leHBvcnRzPWZ1bmN0aW9uKGcpe3JldHVybiBoP2kuY3JlYXRlRWxlbWVudChnKTp7fX19LGZ1bmN0aW9uKFMsZSx0KXt2YXIgcj10KDk4KTtTLmV4cG9ydHM9ZnVuY3Rpb24oaSxoKXtpZighcihpKSlyZXR1cm4gaTt2YXIgZyx1O2lmKGgmJnR5cGVvZihnPWkudG9TdHJpbmcpPT0iZnVuY3Rpb24iJiYhcih1PWcuY2FsbChpKSl8fHR5cGVvZihnPWkudmFsdWVPZik9PSJmdW5jdGlvbiImJiFyKHU9Zy5jYWxsKGkpKXx8IWgmJnR5cGVvZihnPWkudG9TdHJpbmcpPT0iZnVuY3Rpb24iJiYhcih1PWcuY2FsbChpKSkpcmV0dXJuIHU7dGhyb3cgVHlwZUVycm9yKCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWUiKX19LGZ1bmN0aW9uKFMsZSl7Uy5leHBvcnRzPWZ1bmN0aW9uKHQscil7cmV0dXJue2VudW1lcmFibGU6ISh0JjEpLGNvbmZpZ3VyYWJsZTohKHQmMiksd3JpdGFibGU6ISh0JjQpLHZhbHVlOnJ9fX0sZnVuY3Rpb24oUyxlKXt2YXIgdD17fS5oYXNPd25Qcm9wZXJ0eTtTLmV4cG9ydHM9ZnVuY3Rpb24ocixpKXtyZXR1cm4gdC5jYWxsKHIsaSl9fSxmdW5jdGlvbihTLGUsdCl7Uy5leHBvcnRzPXQoOTUpfSxmdW5jdGlvbihTLGUsdCl7dmFyIHI9dCgxMDgpLGk9dCgxMDQpLGg9dCgxMjEpLGc9e307dCg5NSkoZyx0KDEyMikoIml0ZXJhdG9yIiksZnVuY3Rpb24oKXtyZXR1cm4gdGhpc30pLFMuZXhwb3J0cz1mdW5jdGlvbih1LGEsYyl7dS5wcm90b3R5cGU9cihnLHtuZXh0OmkoMSxjKX0pLGgodSxhKyIgSXRlcmF0b3IiKX19LGZ1bmN0aW9uKFMsZSx0KXt2YXIgcj10KDk3KSxpPXQoMTA5KSxoPXQoMTE5KSxnPXQoMTE2KSgiSUVfUFJPVE8iKSx1PWZ1bmN0aW9uKCl7fSxhPSJwcm90b3R5cGUiLGM9ZnVuY3Rpb24oKXt2YXIgeD10KDEwMikoImlmcmFtZSIpLGY9aC5sZW5ndGgsdj0iPCIscD0iPiIsQztmb3IoeC5zdHlsZS5kaXNwbGF5PSJub25lIix0KDEyMCkuYXBwZW5kQ2hpbGQoeCkseC5zcmM9ImphdmFzY3JpcHQ6IixDPXguY29udGVudFdpbmRvdy5kb2N1bWVudCxDLm9wZW4oKSxDLndyaXRlKHYrInNjcmlwdCIrcCsiZG9jdW1lbnQuRj1PYmplY3QiK3YrIi9zY3JpcHQiK3ApLEMuY2xvc2UoKSxjPUMuRjtmLS07KWRlbGV0ZSBjW2FdW2hbZl1dO3JldHVybiBjKCl9O1MuZXhwb3J0cz1PYmplY3QuY3JlYXRlfHxmdW5jdGlvbihmLHYpe3ZhciBwO3JldHVybiBmIT09bnVsbD8odVthXT1yKGYpLHA9bmV3IHUsdVthXT1udWxsLHBbZ109Zik6cD1jKCksdj09PXZvaWQgMD9wOmkocCx2KX19LGZ1bmN0aW9uKFMsZSx0KXt2YXIgcj10KDk2KSxpPXQoOTcpLGg9dCgxMTApO1MuZXhwb3J0cz10KDEwMCk/T2JqZWN0LmRlZmluZVByb3BlcnRpZXM6ZnVuY3Rpb24odSxhKXtpKHUpO2Zvcih2YXIgYz1oKGEpLHg9Yy5sZW5ndGgsZj0wLHY7eD5mOylyLmYodSx2PWNbZisrXSxhW3ZdKTtyZXR1cm4gdX19LGZ1bmN0aW9uKFMsZSx0KXt2YXIgcj10KDExMSksaT10KDExOSk7Uy5leHBvcnRzPU9iamVjdC5rZXlzfHxmdW5jdGlvbihnKXtyZXR1cm4gcihnLGkpfX0sZnVuY3Rpb24oUyxlLHQpe3ZhciByPXQoMTA1KSxpPXQoODQpLGg9dCgxMTIpKCExKSxnPXQoMTE2KSgiSUVfUFJPVE8iKTtTLmV4cG9ydHM9ZnVuY3Rpb24odSxhKXt2YXIgYz1pKHUpLHg9MCxmPVtdLHY7Zm9yKHYgaW4gYyl2IT1nJiZyKGMsdikmJmYucHVzaCh2KTtmb3IoO2EubGVuZ3RoPng7KXIoYyx2PWFbeCsrXSkmJih+aChmLHYpfHxmLnB1c2godikpO3JldHVybiBmfX0sZnVuY3Rpb24oUyxlLHQpe3ZhciByPXQoODQpLGk9dCgxMTMpLGg9dCgxMTUpO1MuZXhwb3J0cz1mdW5jdGlvbihnKXtyZXR1cm4gZnVuY3Rpb24odSxhLGMpe3ZhciB4PXIodSksZj1pKHgubGVuZ3RoKSx2PWgoYyxmKSxwO2lmKGcmJmEhPWEpe2Zvcig7Zj52OylpZihwPXhbdisrXSxwIT1wKXJldHVybiEwfWVsc2UgZm9yKDtmPnY7disrKWlmKChnfHx2IGluIHgpJiZ4W3ZdPT09YSlyZXR1cm4gZ3x8dnx8MDtyZXR1cm4hZyYmLTF9fX0sZnVuY3Rpb24oUyxlLHQpe3ZhciByPXQoMTE0KSxpPU1hdGgubWluO1MuZXhwb3J0cz1mdW5jdGlvbihoKXtyZXR1cm4gaD4wP2kocihoKSw5MDA3MTk5MjU0NzQwOTkxKTowfX0sZnVuY3Rpb24oUyxlKXt2YXIgdD1NYXRoLmNlaWwscj1NYXRoLmZsb29yO1MuZXhwb3J0cz1mdW5jdGlvbihpKXtyZXR1cm4gaXNOYU4oaT0raSk/MDooaT4wP3I6dCkoaSl9fSxmdW5jdGlvbihTLGUsdCl7dmFyIHI9dCgxMTQpLGk9TWF0aC5tYXgsaD1NYXRoLm1pbjtTLmV4cG9ydHM9ZnVuY3Rpb24oZyx1KXtyZXR1cm4gZz1yKGcpLGc8MD9pKGcrdSwwKTpoKGcsdSl9fSxmdW5jdGlvbihTLGUsdCl7dmFyIHI9dCgxMTcpKCJrZXlzIiksaT10KDExOCk7Uy5leHBvcnRzPWZ1bmN0aW9uKGgpe3JldHVybiByW2hdfHwocltoXT1pKGgpKX19LGZ1bmN0aW9uKFMsZSx0KXt2YXIgcj10KDkyKSxpPXQoOTEpLGg9Il9fY29yZS1qc19zaGFyZWRfXyIsZz1pW2hdfHwoaVtoXT17fSk7KFMuZXhwb3J0cz1mdW5jdGlvbih1LGEpe3JldHVybiBnW3VdfHwoZ1t1XT1hIT09dm9pZCAwP2E6e30pfSkoInZlcnNpb25zIixbXSkucHVzaCh7dmVyc2lvbjpyLnZlcnNpb24sbW9kZTp0KDg5KT8icHVyZSI6Imdsb2JhbCIsY29weXJpZ2h0OiLCqSAyMDE5IERlbmlzIFB1c2hrYXJldiAoemxvaXJvY2sucnUpIn0pfSxmdW5jdGlvbihTLGUpe3ZhciB0PTAscj1NYXRoLnJhbmRvbSgpO1MuZXhwb3J0cz1mdW5jdGlvbihpKXtyZXR1cm4iU3ltYm9sKCIuY29uY2F0KGk9PT12b2lkIDA/IiI6aSwiKV8iLCgrK3QrcikudG9TdHJpbmcoMzYpKX19LGZ1bmN0aW9uKFMsZSl7Uy5leHBvcnRzPSJjb25zdHJ1Y3RvcixoYXNPd25Qcm9wZXJ0eSxpc1Byb3RvdHlwZU9mLHByb3BlcnR5SXNFbnVtZXJhYmxlLHRvTG9jYWxlU3RyaW5nLHRvU3RyaW5nLHZhbHVlT2YiLnNwbGl0KCIsIil9LGZ1bmN0aW9uKFMsZSx0KXt2YXIgcj10KDkxKS5kb2N1bWVudDtTLmV4cG9ydHM9ciYmci5kb2N1bWVudEVsZW1lbnR9LGZ1bmN0aW9uKFMsZSx0KXt2YXIgcj10KDk2KS5mLGk9dCgxMDUpLGg9dCgxMjIpKCJ0b1N0cmluZ1RhZyIpO1MuZXhwb3J0cz1mdW5jdGlvbihnLHUsYSl7ZyYmIWkoZz1hP2c6Zy5wcm90b3R5cGUsaCkmJnIoZyxoLHtjb25maWd1cmFibGU6ITAsdmFsdWU6dX0pfX0sZnVuY3Rpb24oUyxlLHQpe3ZhciByPXQoMTE3KSgid2tzIiksaT10KDExOCksaD10KDkxKS5TeW1ib2wsZz10eXBlb2YgaD09ImZ1bmN0aW9uIix1PVMuZXhwb3J0cz1mdW5jdGlvbihhKXtyZXR1cm4gclthXXx8KHJbYV09ZyYmaFthXXx8KGc/aDppKSgiU3ltYm9sLiIrYSkpfTt1LnN0b3JlPXJ9LGZ1bmN0aW9uKFMsZSx0KXt2YXIgcj10KDEwNSksaT10KDEyNCksaD10KDExNikoIklFX1BST1RPIiksZz1PYmplY3QucHJvdG90eXBlO1MuZXhwb3J0cz1PYmplY3QuZ2V0UHJvdG90eXBlT2Z8fGZ1bmN0aW9uKHUpe3JldHVybiB1PWkodSkscih1LGgpP3VbaF06dHlwZW9mIHUuY29uc3RydWN0b3I9PSJmdW5jdGlvbiImJnUgaW5zdGFuY2VvZiB1LmNvbnN0cnVjdG9yP3UuY29uc3RydWN0b3IucHJvdG90eXBlOnUgaW5zdGFuY2VvZiBPYmplY3Q/ZzpudWxsfX0sZnVuY3Rpb24oUyxlLHQpe3ZhciByPXQoODcpO1MuZXhwb3J0cz1mdW5jdGlvbihpKXtyZXR1cm4gT2JqZWN0KHIoaSkpfX0sZnVuY3Rpb24oUyxlLHQpe3ZhciByPXQoMTI2KSghMCk7dCg4OCkoU3RyaW5nLCJTdHJpbmciLGZ1bmN0aW9uKGkpe3RoaXMuX3Q9U3RyaW5nKGkpLHRoaXMuX2k9MH0sZnVuY3Rpb24oKXt2YXIgaT10aGlzLl90LGg9dGhpcy5faSxnO3JldHVybiBoPj1pLmxlbmd0aD97dmFsdWU6dm9pZCAwLGRvbmU6ITB9OihnPXIoaSxoKSx0aGlzLl9pKz1nLmxlbmd0aCx7dmFsdWU6Zyxkb25lOiExfSl9KX0sZnVuY3Rpb24oUyxlLHQpe3ZhciByPXQoMTE0KSxpPXQoODcpO1MuZXhwb3J0cz1mdW5jdGlvbihoKXtyZXR1cm4gZnVuY3Rpb24oZyx1KXt2YXIgYT1TdHJpbmcoaShnKSksYz1yKHUpLHg9YS5sZW5ndGgsZix2O3JldHVybiBjPDB8fGM+PXg/aD8iIjp2b2lkIDA6KGY9YS5jaGFyQ29kZUF0KGMpLGY8NTUyOTZ8fGY+NTYzMTl8fGMrMT09PXh8fCh2PWEuY2hhckNvZGVBdChjKzEpKTw1NjMyMHx8dj41NzM0Mz9oP2EuY2hhckF0KGMpOmY6aD9hLnNsaWNlKGMsYysyKTooZi01NTI5Njw8MTApKyh2LTU2MzIwKSs2NTUzNil9fX0sZnVuY3Rpb24oUyxlLHQpe3ZhciByPXQoMTI4KSxpPXQoMTIyKSgiaXRlcmF0b3IiKSxoPXQoODMpO1MuZXhwb3J0cz10KDkyKS5pc0l0ZXJhYmxlPWZ1bmN0aW9uKGcpe3ZhciB1PU9iamVjdChnKTtyZXR1cm4gdVtpXSE9PXZvaWQgMHx8IkBAaXRlcmF0b3IiaW4gdXx8aC5oYXNPd25Qcm9wZXJ0eShyKHUpKX19LGZ1bmN0aW9uKFMsZSx0KXt2YXIgcj10KDg2KSxpPXQoMTIyKSgidG9TdHJpbmdUYWciKSxoPXIoZnVuY3Rpb24oKXtyZXR1cm4gYXJndW1lbnRzfSgpKT09IkFyZ3VtZW50cyIsZz1mdW5jdGlvbih1LGEpe3RyeXtyZXR1cm4gdVthXX1jYXRjaHt9fTtTLmV4cG9ydHM9ZnVuY3Rpb24odSl7dmFyIGEsYyx4O3JldHVybiB1PT09dm9pZCAwPyJVbmRlZmluZWQiOnU9PT1udWxsPyJOdWxsIjp0eXBlb2YoYz1nKGE9T2JqZWN0KHUpLGkpKT09InN0cmluZyI/YzpoP3IoYSk6KHg9cihhKSk9PSJPYmplY3QiJiZ0eXBlb2YgYS5jYWxsZWU9PSJmdW5jdGlvbiI/IkFyZ3VtZW50cyI6eH19LGZ1bmN0aW9uKFMsZSx0KXtTLmV4cG9ydHM9e2RlZmF1bHQ6dCgxMzApLF9fZXNNb2R1bGU6ITB9fSxmdW5jdGlvbihTLGUsdCl7dCg3OSksdCgxMjUpLFMuZXhwb3J0cz10KDEzMSl9LGZ1bmN0aW9uKFMsZSx0KXt2YXIgcj10KDk3KSxpPXQoMTMyKTtTLmV4cG9ydHM9dCg5MikuZ2V0SXRlcmF0b3I9ZnVuY3Rpb24oaCl7dmFyIGc9aShoKTtpZih0eXBlb2YgZyE9ImZ1bmN0aW9uIil0aHJvdyBUeXBlRXJyb3IoaCsiIGlzIG5vdCBpdGVyYWJsZSEiKTtyZXR1cm4gcihnLmNhbGwoaCkpfX0sZnVuY3Rpb24oUyxlLHQpe3ZhciByPXQoMTI4KSxpPXQoMTIyKSgiaXRlcmF0b3IiKSxoPXQoODMpO1MuZXhwb3J0cz10KDkyKS5nZXRJdGVyYXRvck1ldGhvZD1mdW5jdGlvbihnKXtpZihnIT1udWxsKXJldHVybiBnW2ldfHxnWyJAQGl0ZXJhdG9yIl18fGhbcihnKV19fSxmdW5jdGlvbihTLGUsdCl7ZS5fX2VzTW9kdWxlPSEwO3ZhciByPXQoMTM0KSxpPWgocik7ZnVuY3Rpb24gaChnKXtyZXR1cm4gZyYmZy5fX2VzTW9kdWxlP2c6e2RlZmF1bHQ6Z319ZS5kZWZhdWx0PWZ1bmN0aW9uKGcpe2lmKEFycmF5LmlzQXJyYXkoZykpe2Zvcih2YXIgdT0wLGE9QXJyYXkoZy5sZW5ndGgpO3U8Zy5sZW5ndGg7dSsrKWFbdV09Z1t1XTtyZXR1cm4gYX1lbHNlIHJldHVybigwLGkuZGVmYXVsdCkoZyl9fSxmdW5jdGlvbihTLGUsdCl7Uy5leHBvcnRzPXtkZWZhdWx0OnQoMTM1KSxfX2VzTW9kdWxlOiEwfX0sZnVuY3Rpb24oUyxlLHQpe3QoMTI1KSx0KDEzNiksUy5leHBvcnRzPXQoOTIpLkFycmF5LmZyb219LGZ1bmN0aW9uKFMsZSx0KXt2YXIgcj10KDkzKSxpPXQoOTApLGg9dCgxMjQpLGc9dCgxMzcpLHU9dCgxMzgpLGE9dCgxMTMpLGM9dCgxMzkpLHg9dCgxMzIpO2koaS5TK2kuRiohdCgxNDApKGZ1bmN0aW9uKGYpe0FycmF5LmZyb20oZil9KSwiQXJyYXkiLHtmcm9tOmZ1bmN0aW9uKHYpe3ZhciBwPWgodiksQz10eXBlb2YgdGhpcz09ImZ1bmN0aW9uIj90aGlzOkFycmF5LE09YXJndW1lbnRzLmxlbmd0aCxtPU0+MT9hcmd1bWVudHNbMV06dm9pZCAwLHk9bSE9PXZvaWQgMCxuPTAsbz14KHApLHMsbCxFLFQ7aWYoeSYmKG09cihtLE0+Mj9hcmd1bWVudHNbMl06dm9pZCAwLDIpKSxvIT1udWxsJiYhKEM9PUFycmF5JiZ1KG8pKSlmb3IoVD1vLmNhbGwocCksbD1uZXcgQzshKEU9VC5uZXh0KCkpLmRvbmU7bisrKWMobCxuLHk/ZyhULG0sW0UudmFsdWUsbl0sITApOkUudmFsdWUpO2Vsc2UgZm9yKHM9YShwLmxlbmd0aCksbD1uZXcgQyhzKTtzPm47bisrKWMobCxuLHk/bShwW25dLG4pOnBbbl0pO3JldHVybiBsLmxlbmd0aD1uLGx9fSl9LGZ1bmN0aW9uKFMsZSx0KXt2YXIgcj10KDk3KTtTLmV4cG9ydHM9ZnVuY3Rpb24oaSxoLGcsdSl7dHJ5e3JldHVybiB1P2gocihnKVswXSxnWzFdKTpoKGcpfWNhdGNoKGMpe3ZhciBhPWkucmV0dXJuO3Rocm93IGEhPT12b2lkIDAmJnIoYS5jYWxsKGkpKSxjfX19LGZ1bmN0aW9uKFMsZSx0KXt2YXIgcj10KDgzKSxpPXQoMTIyKSgiaXRlcmF0b3IiKSxoPUFycmF5LnByb3RvdHlwZTtTLmV4cG9ydHM9ZnVuY3Rpb24oZyl7cmV0dXJuIGchPT12b2lkIDAmJihyLkFycmF5PT09Z3x8aFtpXT09PWcpfX0sZnVuY3Rpb24oUyxlLHQpe3ZhciByPXQoOTYpLGk9dCgxMDQpO1MuZXhwb3J0cz1mdW5jdGlvbihoLGcsdSl7ZyBpbiBoP3IuZihoLGcsaSgwLHUpKTpoW2ddPXV9fSxmdW5jdGlvbihTLGUsdCl7dmFyIHI9dCgxMjIpKCJpdGVyYXRvciIpLGk9ITE7dHJ5e3ZhciBoPVs3XVtyXSgpO2gucmV0dXJuPWZ1bmN0aW9uKCl7aT0hMH0sQXJyYXkuZnJvbShoLGZ1bmN0aW9uKCl7dGhyb3cgMn0pfWNhdGNoe31TLmV4cG9ydHM9ZnVuY3Rpb24oZyx1KXtpZighdSYmIWkpcmV0dXJuITE7dmFyIGE9ITE7dHJ5e3ZhciBjPVs3XSx4PWNbcl0oKTt4Lm5leHQ9ZnVuY3Rpb24oKXtyZXR1cm57ZG9uZTphPSEwfX0sY1tyXT1mdW5jdGlvbigpe3JldHVybiB4fSxnKGMpfWNhdGNoe31yZXR1cm4gYX19LGZ1bmN0aW9uKFMsZSx0KXtTLmV4cG9ydHM9e2RlZmF1bHQ6dCgxNDIpLF9fZXNNb2R1bGU6ITB9fSxmdW5jdGlvbihTLGUsdCl7dCgxNDMpLHQoMTI1KSx0KDc5KSx0KDE0NCksdCgxNTcpLHQoMTYwKSx0KDE2MiksUy5leHBvcnRzPXQoOTIpLk1hcH0sZnVuY3Rpb24oUyxlKXt9LGZ1bmN0aW9uKFMsZSx0KXt2YXIgcj10KDE0NSksaT10KDE1MSksaD0iTWFwIjtTLmV4cG9ydHM9dCgxNTIpKGgsZnVuY3Rpb24oZyl7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIGcodGhpcyxhcmd1bWVudHMubGVuZ3RoPjA/YXJndW1lbnRzWzBdOnZvaWQgMCl9fSx7Z2V0OmZ1bmN0aW9uKHUpe3ZhciBhPXIuZ2V0RW50cnkoaSh0aGlzLGgpLHUpO3JldHVybiBhJiZhLnZ9LHNldDpmdW5jdGlvbih1LGEpe3JldHVybiByLmRlZihpKHRoaXMsaCksdT09PTA/MDp1LGEpfX0sciwhMCl9LGZ1bmN0aW9uKFMsZSx0KXt2YXIgcj10KDk2KS5mLGk9dCgxMDgpLGg9dCgxNDYpLGc9dCg5MyksdT10KDE0NyksYT10KDE0OCksYz10KDg4KSx4PXQoODIpLGY9dCgxNDkpLHY9dCgxMDApLHA9dCgxNTApLmZhc3RLZXksQz10KDE1MSksTT12PyJfcyI6InNpemUiLG09ZnVuY3Rpb24oeSxuKXt2YXIgbz1wKG4pLHM7aWYobyE9PSJGIilyZXR1cm4geS5faVtvXTtmb3Iocz15Ll9mO3M7cz1zLm4paWYocy5rPT1uKXJldHVybiBzfTtTLmV4cG9ydHM9e2dldENvbnN0cnVjdG9yOmZ1bmN0aW9uKHksbixvLHMpe3ZhciBsPXkoZnVuY3Rpb24oRSxUKXt1KEUsbCxuLCJfaSIpLEUuX3Q9bixFLl9pPWkobnVsbCksRS5fZj12b2lkIDAsRS5fbD12b2lkIDAsRVtNXT0wLFQhPW51bGwmJmEoVCxvLEVbc10sRSl9KTtyZXR1cm4gaChsLnByb3RvdHlwZSx7Y2xlYXI6ZnVuY3Rpb24oKXtmb3IodmFyIFQ9Qyh0aGlzLG4pLGI9VC5faSxJPVQuX2Y7STtJPUkubilJLnI9ITAsSS5wJiYoSS5wPUkucC5uPXZvaWQgMCksZGVsZXRlIGJbSS5pXTtULl9mPVQuX2w9dm9pZCAwLFRbTV09MH0sZGVsZXRlOmZ1bmN0aW9uKEUpe3ZhciBUPUModGhpcyxuKSxiPW0oVCxFKTtpZihiKXt2YXIgST1iLm4sUD1iLnA7ZGVsZXRlIFQuX2lbYi5pXSxiLnI9ITAsUCYmKFAubj1JKSxJJiYoSS5wPVApLFQuX2Y9PWImJihULl9mPUkpLFQuX2w9PWImJihULl9sPVApLFRbTV0tLX1yZXR1cm4hIWJ9LGZvckVhY2g6ZnVuY3Rpb24oVCl7Qyh0aGlzLG4pO2Zvcih2YXIgYj1nKFQsYXJndW1lbnRzLmxlbmd0aD4xP2FyZ3VtZW50c1sxXTp2b2lkIDAsMyksSTtJPUk/SS5uOnRoaXMuX2Y7KWZvcihiKEkudixJLmssdGhpcyk7SSYmSS5yOylJPUkucH0saGFzOmZ1bmN0aW9uKFQpe3JldHVybiEhbShDKHRoaXMsbiksVCl9fSksdiYmcihsLnByb3RvdHlwZSwic2l6ZSIse2dldDpmdW5jdGlvbigpe3JldHVybiBDKHRoaXMsbilbTV19fSksbH0sZGVmOmZ1bmN0aW9uKHksbixvKXt2YXIgcz1tKHksbiksbCxFO3JldHVybiBzP3Mudj1vOih5Ll9sPXM9e2k6RT1wKG4sITApLGs6bix2Om8scDpsPXkuX2wsbjp2b2lkIDAscjohMX0seS5fZnx8KHkuX2Y9cyksbCYmKGwubj1zKSx5W01dKyssRSE9PSJGIiYmKHkuX2lbRV09cykpLHl9LGdldEVudHJ5Om0sc2V0U3Ryb25nOmZ1bmN0aW9uKHksbixvKXtjKHksbixmdW5jdGlvbihzLGwpe3RoaXMuX3Q9QyhzLG4pLHRoaXMuX2s9bCx0aGlzLl9sPXZvaWQgMH0sZnVuY3Rpb24oKXtmb3IodmFyIHM9dGhpcyxsPXMuX2ssRT1zLl9sO0UmJkUucjspRT1FLnA7cmV0dXJuIXMuX3R8fCEocy5fbD1FPUU/RS5uOnMuX3QuX2YpPyhzLl90PXZvaWQgMCx4KDEpKTpsPT0ia2V5cyI/eCgwLEUuayk6bD09InZhbHVlcyI/eCgwLEUudik6eCgwLFtFLmssRS52XSl9LG8/ImVudHJpZXMiOiJ2YWx1ZXMiLCFvLCEwKSxmKG4pfX19LGZ1bmN0aW9uKFMsZSx0KXt2YXIgcj10KDk1KTtTLmV4cG9ydHM9ZnVuY3Rpb24oaSxoLGcpe2Zvcih2YXIgdSBpbiBoKWcmJmlbdV0/aVt1XT1oW3VdOnIoaSx1LGhbdV0pO3JldHVybiBpfX0sZnVuY3Rpb24oUyxlKXtTLmV4cG9ydHM9ZnVuY3Rpb24odCxyLGksaCl7aWYoISh0IGluc3RhbmNlb2Ygcil8fGghPT12b2lkIDAmJmggaW4gdCl0aHJvdyBUeXBlRXJyb3IoaSsiOiBpbmNvcnJlY3QgaW52b2NhdGlvbiEiKTtyZXR1cm4gdH19LGZ1bmN0aW9uKFMsZix0KXt2YXIgcj10KDkzKSxpPXQoMTM3KSxoPXQoMTM4KSxnPXQoOTcpLHU9dCgxMTMpLGE9dCgxMzIpLGM9e30seD17fSxmPVMuZXhwb3J0cz1mdW5jdGlvbih2LHAsQyxNLG0pe3ZhciB5PW0/ZnVuY3Rpb24oKXtyZXR1cm4gdn06YSh2KSxuPXIoQyxNLHA/MjoxKSxvPTAscyxsLEUsVDtpZih0eXBlb2YgeSE9ImZ1bmN0aW9uIil0aHJvdyBUeXBlRXJyb3IodisiIGlzIG5vdCBpdGVyYWJsZSEiKTtpZihoKHkpKXtmb3Iocz11KHYubGVuZ3RoKTtzPm87bysrKWlmKFQ9cD9uKGcobD12W29dKVswXSxsWzFdKTpuKHZbb10pLFQ9PT1jfHxUPT09eClyZXR1cm4gVH1lbHNlIGZvcihFPXkuY2FsbCh2KTshKGw9RS5uZXh0KCkpLmRvbmU7KWlmKFQ9aShFLG4sbC52YWx1ZSxwKSxUPT09Y3x8VD09PXgpcmV0dXJuIFR9O2YuQlJFQUs9YyxmLlJFVFVSTj14fSxmdW5jdGlvbihTLGUsdCl7dmFyIHI9dCg5MSksaT10KDkyKSxoPXQoOTYpLGc9dCgxMDApLHU9dCgxMjIpKCJzcGVjaWVzIik7Uy5leHBvcnRzPWZ1bmN0aW9uKGEpe3ZhciBjPXR5cGVvZiBpW2FdPT0iZnVuY3Rpb24iP2lbYV06clthXTtnJiZjJiYhY1t1XSYmaC5mKGMsdSx7Y29uZmlndXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzfX0pfX0sZnVuY3Rpb24oUyxlLHQpe3ZhciByPXQoMTE4KSgibWV0YSIpLGk9dCg5OCksaD10KDEwNSksZz10KDk2KS5mLHU9MCxhPU9iamVjdC5pc0V4dGVuc2libGV8fGZ1bmN0aW9uKCl7cmV0dXJuITB9LGM9IXQoMTAxKShmdW5jdGlvbigpe3JldHVybiBhKE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh7fSkpfSkseD1mdW5jdGlvbihNKXtnKE0scix7dmFsdWU6e2k6Ik8iKyArK3Usdzp7fX19KX0sZj1mdW5jdGlvbihNLG0pe2lmKCFpKE0pKXJldHVybiB0eXBlb2YgTT09InN5bWJvbCI/TToodHlwZW9mIE09PSJzdHJpbmciPyJTIjoiUCIpK007aWYoIWgoTSxyKSl7aWYoIWEoTSkpcmV0dXJuIkYiO2lmKCFtKXJldHVybiJFIjt4KE0pfXJldHVybiBNW3JdLml9LHY9ZnVuY3Rpb24oTSxtKXtpZighaChNLHIpKXtpZighYShNKSlyZXR1cm4hMDtpZighbSlyZXR1cm4hMTt4KE0pfXJldHVybiBNW3JdLnd9LHA9ZnVuY3Rpb24oTSl7cmV0dXJuIGMmJkMuTkVFRCYmYShNKSYmIWgoTSxyKSYmeChNKSxNfSxDPVMuZXhwb3J0cz17S0VZOnIsTkVFRDohMSxmYXN0S2V5OmYsZ2V0V2Vhazp2LG9uRnJlZXplOnB9fSxmdW5jdGlvbihTLGUsdCl7dmFyIHI9dCg5OCk7Uy5leHBvcnRzPWZ1bmN0aW9uKGksaCl7aWYoIXIoaSl8fGkuX3QhPT1oKXRocm93IFR5cGVFcnJvcigiSW5jb21wYXRpYmxlIHJlY2VpdmVyLCAiK2grIiByZXF1aXJlZCEiKTtyZXR1cm4gaX19LGZ1bmN0aW9uKFMsZSx0KXt2YXIgcj10KDkxKSxpPXQoOTApLGg9dCgxNTApLGc9dCgxMDEpLHU9dCg5NSksYT10KDE0NiksYz10KDE0OCkseD10KDE0NyksZj10KDk4KSx2PXQoMTIxKSxwPXQoOTYpLmYsQz10KDE1MykoMCksTT10KDEwMCk7Uy5leHBvcnRzPWZ1bmN0aW9uKG0seSxuLG8scyxsKXt2YXIgRT1yW21dLFQ9RSxiPXM/InNldCI6ImFkZCIsST1UJiZULnByb3RvdHlwZSxQPXt9O3JldHVybiFNfHx0eXBlb2YgVCE9ImZ1bmN0aW9uInx8IShsfHxJLmZvckVhY2gmJiFnKGZ1bmN0aW9uKCl7bmV3IFQoKS5lbnRyaWVzKCkubmV4dCgpfSkpPyhUPW8uZ2V0Q29uc3RydWN0b3IoeSxtLHMsYiksYShULnByb3RvdHlwZSxuKSxoLk5FRUQ9ITApOihUPXkoZnVuY3Rpb24oTCxEKXt4KEwsVCxtLCJfYyIpLEwuX2M9bmV3IEUsRCE9bnVsbCYmYyhELHMsTFtiXSxMKX0pLEMoImFkZCxjbGVhcixkZWxldGUsZm9yRWFjaCxnZXQsaGFzLHNldCxrZXlzLHZhbHVlcyxlbnRyaWVzLHRvSlNPTiIuc3BsaXQoIiwiKSxmdW5jdGlvbihMKXt2YXIgRD1MPT0iYWRkInx8TD09InNldCI7TCBpbiBJJiYhKGwmJkw9PSJjbGVhciIpJiZ1KFQucHJvdG90eXBlLEwsZnVuY3Rpb24oUixBKXtpZih4KHRoaXMsVCxMKSwhRCYmbCYmIWYoUikpcmV0dXJuIEw9PSJnZXQiP3ZvaWQgMDohMTt2YXIgaj10aGlzLl9jW0xdKFI9PT0wPzA6UixBKTtyZXR1cm4gRD90aGlzOmp9KX0pLGx8fHAoVC5wcm90b3R5cGUsInNpemUiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fYy5zaXplfX0pKSx2KFQsbSksUFttXT1ULGkoaS5HK2kuVytpLkYsUCksbHx8by5zZXRTdHJvbmcoVCxtLHMpLFR9fSxmdW5jdGlvbihTLGUsdCl7dmFyIHI9dCg5MyksaT10KDg1KSxoPXQoMTI0KSxnPXQoMTEzKSx1PXQoMTU0KTtTLmV4cG9ydHM9ZnVuY3Rpb24oYSxjKXt2YXIgeD1hPT0xLGY9YT09Mix2PWE9PTMscD1hPT00LEM9YT09NixNPWE9PTV8fEMsbT1jfHx1O3JldHVybiBmdW5jdGlvbih5LG4sbyl7Zm9yKHZhciBzPWgoeSksbD1pKHMpLEU9cihuLG8sMyksVD1nKGwubGVuZ3RoKSxiPTAsST14P20oeSxUKTpmP20oeSwwKTp2b2lkIDAsUCxMO1Q+YjtiKyspaWYoKE18fGIgaW4gbCkmJihQPWxbYl0sTD1FKFAsYixzKSxhKSl7aWYoeClJW2JdPUw7ZWxzZSBpZihMKXN3aXRjaChhKXtjYXNlIDM6cmV0dXJuITA7Y2FzZSA1OnJldHVybiBQO2Nhc2UgNjpyZXR1cm4gYjtjYXNlIDI6SS5wdXNoKFApfWVsc2UgaWYocClyZXR1cm4hMX1yZXR1cm4gQz8tMTp2fHxwP3A6SX19fSxmdW5jdGlvbihTLGUsdCl7dmFyIHI9dCgxNTUpO1MuZXhwb3J0cz1mdW5jdGlvbihpLGgpe3JldHVybiBuZXcocihpKSkoaCl9fSxmdW5jdGlvbihTLGUsdCl7dmFyIHI9dCg5OCksaT10KDE1NiksaD10KDEyMikoInNwZWNpZXMiKTtTLmV4cG9ydHM9ZnVuY3Rpb24oZyl7dmFyIHU7cmV0dXJuIGkoZykmJih1PWcuY29uc3RydWN0b3IsdHlwZW9mIHU9PSJmdW5jdGlvbiImJih1PT09QXJyYXl8fGkodS5wcm90b3R5cGUpKSYmKHU9dm9pZCAwKSxyKHUpJiYodT11W2hdLHU9PT1udWxsJiYodT12b2lkIDApKSksdT09PXZvaWQgMD9BcnJheTp1fX0sZnVuY3Rpb24oUyxlLHQpe3ZhciByPXQoODYpO1MuZXhwb3J0cz1BcnJheS5pc0FycmF5fHxmdW5jdGlvbihoKXtyZXR1cm4gcihoKT09IkFycmF5In19LGZ1bmN0aW9uKFMsZSx0KXt2YXIgcj10KDkwKTtyKHIuUCtyLlIsIk1hcCIse3RvSlNPTjp0KDE1OCkoIk1hcCIpfSl9LGZ1bmN0aW9uKFMsZSx0KXt2YXIgcj10KDEyOCksaT10KDE1OSk7Uy5leHBvcnRzPWZ1bmN0aW9uKGgpe3JldHVybiBmdW5jdGlvbigpe2lmKHIodGhpcykhPWgpdGhyb3cgVHlwZUVycm9yKGgrIiN0b0pTT04gaXNuJ3QgZ2VuZXJpYyIpO3JldHVybiBpKHRoaXMpfX19LGZ1bmN0aW9uKFMsZSx0KXt2YXIgcj10KDE0OCk7Uy5leHBvcnRzPWZ1bmN0aW9uKGksaCl7dmFyIGc9W107cmV0dXJuIHIoaSwhMSxnLnB1c2gsZyxoKSxnfX0sZnVuY3Rpb24oUyxlLHQpe3QoMTYxKSgiTWFwIil9LGZ1bmN0aW9uKFMsZSx0KXt2YXIgcj10KDkwKTtTLmV4cG9ydHM9ZnVuY3Rpb24oaSl7cihyLlMsaSx7b2Y6ZnVuY3Rpb24oKXtmb3IodmFyIGc9YXJndW1lbnRzLmxlbmd0aCx1PW5ldyBBcnJheShnKTtnLS07KXVbZ109YXJndW1lbnRzW2ddO3JldHVybiBuZXcgdGhpcyh1KX19KX19LGZ1bmN0aW9uKFMsZSx0KXt0KDE2MykoIk1hcCIpfSxmdW5jdGlvbihTLGUsdCl7dmFyIHI9dCg5MCksaT10KDk0KSxoPXQoOTMpLGc9dCgxNDgpO1MuZXhwb3J0cz1mdW5jdGlvbih1KXtyKHIuUyx1LHtmcm9tOmZ1bmN0aW9uKGMpe3ZhciB4PWFyZ3VtZW50c1sxXSxmLHYscCxDO3JldHVybiBpKHRoaXMpLGY9eCE9PXZvaWQgMCxmJiZpKHgpLGM9PW51bGw/bmV3IHRoaXM6KHY9W10sZj8ocD0wLEM9aCh4LGFyZ3VtZW50c1syXSwyKSxnKGMsITEsZnVuY3Rpb24oTSl7di5wdXNoKEMoTSxwKyspKX0pKTpnKGMsITEsdi5wdXNoLHYpLG5ldyB0aGlzKHYpKX19KX19LGZ1bmN0aW9uKFMsZSx0KXtTLmV4cG9ydHM9e2RlZmF1bHQ6dCgxNjUpLF9fZXNNb2R1bGU6ITB9fSxmdW5jdGlvbihTLGUsdCl7dCgxNjYpLFMuZXhwb3J0cz10KDkyKS5PYmplY3QuYXNzaWdufSxmdW5jdGlvbihTLGUsdCl7dmFyIHI9dCg5MCk7cihyLlMrci5GLCJPYmplY3QiLHthc3NpZ246dCgxNjcpfSl9LGZ1bmN0aW9uKFMsZSx0KXt2YXIgcj10KDEwMCksaT10KDExMCksaD10KDE2OCksZz10KDE2OSksdT10KDEyNCksYT10KDg1KSxjPU9iamVjdC5hc3NpZ247Uy5leHBvcnRzPSFjfHx0KDEwMSkoZnVuY3Rpb24oKXt2YXIgeD17fSxmPXt9LHY9U3ltYm9sKCkscD0iYWJjZGVmZ2hpamtsbW5vcHFyc3QiO3JldHVybiB4W3ZdPTcscC5zcGxpdCgiIikuZm9yRWFjaChmdW5jdGlvbihDKXtmW0NdPUN9KSxjKHt9LHgpW3ZdIT03fHxPYmplY3Qua2V5cyhjKHt9LGYpKS5qb2luKCIiKSE9cH0pP2Z1bmN0aW9uKGYsdil7Zm9yKHZhciBwPXUoZiksQz1hcmd1bWVudHMubGVuZ3RoLE09MSxtPWguZix5PWcuZjtDPk07KWZvcih2YXIgbj1hKGFyZ3VtZW50c1tNKytdKSxvPW0/aShuKS5jb25jYXQobShuKSk6aShuKSxzPW8ubGVuZ3RoLGw9MCxFO3M+bDspRT1vW2wrK10sKCFyfHx5LmNhbGwobixFKSkmJihwW0VdPW5bRV0pO3JldHVybiBwfTpjfSxmdW5jdGlvbihTLGUpe2UuZj1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzfSxmdW5jdGlvbihTLGUpe2UuZj17fS5wcm9wZXJ0eUlzRW51bWVyYWJsZX0sZnVuY3Rpb24oUyxlLHQpe2UuX19lc01vZHVsZT0hMCxlLmRlZmF1bHQ9ZnVuY3Rpb24ocixpKXtpZighKHIgaW5zdGFuY2VvZiBpKSl0aHJvdyBuZXcgVHlwZUVycm9yKCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24iKX19LGZ1bmN0aW9uKFMsZSx0KXtlLl9fZXNNb2R1bGU9ITA7dmFyIHI9dCgxNzIpLGk9aChyKTtmdW5jdGlvbiBoKGcpe3JldHVybiBnJiZnLl9fZXNNb2R1bGU/Zzp7ZGVmYXVsdDpnfX1lLmRlZmF1bHQ9ZnVuY3Rpb24oKXtmdW5jdGlvbiBnKHUsYSl7Zm9yKHZhciBjPTA7YzxhLmxlbmd0aDtjKyspe3ZhciB4PWFbY107eC5lbnVtZXJhYmxlPXguZW51bWVyYWJsZXx8ITEseC5jb25maWd1cmFibGU9ITAsInZhbHVlImluIHgmJih4LndyaXRhYmxlPSEwKSwoMCxpLmRlZmF1bHQpKHUseC5rZXkseCl9fXJldHVybiBmdW5jdGlvbih1LGEsYyl7cmV0dXJuIGEmJmcodS5wcm90b3R5cGUsYSksYyYmZyh1LGMpLHV9fSgpfSxmdW5jdGlvbihTLGUsdCl7Uy5leHBvcnRzPXtkZWZhdWx0OnQoMTczKSxfX2VzTW9kdWxlOiEwfX0sZnVuY3Rpb24oUyxlLHQpe3QoMTc0KTt2YXIgcj10KDkyKS5PYmplY3Q7Uy5leHBvcnRzPWZ1bmN0aW9uKGgsZyx1KXtyZXR1cm4gci5kZWZpbmVQcm9wZXJ0eShoLGcsdSl9fSxmdW5jdGlvbihTLGUsdCl7dmFyIHI9dCg5MCk7cihyLlMrci5GKiF0KDEwMCksIk9iamVjdCIse2RlZmluZVByb3BlcnR5OnQoOTYpLmZ9KX0sZnVuY3Rpb24oUyxlLHQpe1MuZXhwb3J0cz17ZGVmYXVsdDp0KDE3NiksX19lc01vZHVsZTohMH19LGZ1bmN0aW9uKFMsZSx0KXt0KDE3NyksdCgxNDMpLHQoMTg0KSx0KDE4NSksUy5leHBvcnRzPXQoOTIpLlN5bWJvbH0sZnVuY3Rpb24oUyxlLHQpe3ZhciByPXQoOTEpLGk9dCgxMDUpLGg9dCgxMDApLGc9dCg5MCksdT10KDEwNiksYT10KDE1MCkuS0VZLGM9dCgxMDEpLHg9dCgxMTcpLGY9dCgxMjEpLHY9dCgxMTgpLHA9dCgxMjIpLEM9dCgxNzgpLE09dCgxNzkpLG09dCgxODApLHk9dCgxNTYpLG49dCg5Nyksbz10KDk4KSxzPXQoMTI0KSxsPXQoODQpLEU9dCgxMDMpLFQ9dCgxMDQpLGI9dCgxMDgpLEk9dCgxODEpLFA9dCgxODMpLEw9dCgxNjgpLEQ9dCg5NiksUj10KDExMCksQT1QLmYsaj1ELmYsRz1JLmYsSD1yLlN5bWJvbCxaPXIuSlNPTixxPVomJlouc3RyaW5naWZ5LEY9InByb3RvdHlwZSIsJD1wKCJfaGlkZGVuIiksSj1wKCJ0b1ByaW1pdGl2ZSIpLHR0PXt9LnByb3BlcnR5SXNFbnVtZXJhYmxlLF89eCgic3ltYm9sLXJlZ2lzdHJ5Iiksc3Q9eCgic3ltYm9scyIpLGs9eCgib3Atc3ltYm9scyIpLGN0PU9iamVjdFtGXSxmdD10eXBlb2YgSD09ImZ1bmN0aW9uIiYmISFMLmYsVz1yLlFPYmplY3QsVT0hV3x8IVdbRl18fCFXW0ZdLmZpbmRDaGlsZCxWPWgmJmMoZnVuY3Rpb24oKXtyZXR1cm4gYihqKHt9LCJhIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGoodGhpcywiYSIse3ZhbHVlOjd9KS5hfX0pKS5hIT03fSk/ZnVuY3Rpb24oaXQsbnQsYXQpe3ZhciBkdD1BKGN0LG50KTtkdCYmZGVsZXRlIGN0W250XSxqKGl0LG50LGF0KSxkdCYmaXQhPT1jdCYmaihjdCxudCxkdCl9OmosWD1mdW5jdGlvbihpdCl7dmFyIG50PXN0W2l0XT1iKEhbRl0pO3JldHVybiBudC5faz1pdCxudH0sQj1mdCYmdHlwZW9mIEguaXRlcmF0b3I9PSJzeW1ib2wiP2Z1bmN0aW9uKGl0KXtyZXR1cm4gdHlwZW9mIGl0PT0ic3ltYm9sIn06ZnVuY3Rpb24oaXQpe3JldHVybiBpdCBpbnN0YW5jZW9mIEh9LHc9ZnVuY3Rpb24obnQsYXQsZHQpe3JldHVybiBudD09PWN0JiZ3KGssYXQsZHQpLG4obnQpLGF0PUUoYXQsITApLG4oZHQpLGkoc3QsYXQpPyhkdC5lbnVtZXJhYmxlPyhpKG50LCQpJiZudFskXVthdF0mJihudFskXVthdF09ITEpLGR0PWIoZHQse2VudW1lcmFibGU6VCgwLCExKX0pKTooaShudCwkKXx8aihudCwkLFQoMSx7fSkpLG50WyRdW2F0XT0hMCksVihudCxhdCxkdCkpOmoobnQsYXQsZHQpfSxkPWZ1bmN0aW9uKG50LGF0KXtuKG50KTtmb3IodmFyIGR0PW0oYXQ9bChhdCkpLGd0PTAsdXQ9ZHQubGVuZ3RoLG10O3V0Pmd0Oyl3KG50LG10PWR0W2d0KytdLGF0W210XSk7cmV0dXJuIG50fSxPPWZ1bmN0aW9uKG50LGF0KXtyZXR1cm4gYXQ9PT12b2lkIDA/YihudCk6ZChiKG50KSxhdCl9LE49ZnVuY3Rpb24obnQpe3ZhciBhdD10dC5jYWxsKHRoaXMsbnQ9RShudCwhMCkpO3JldHVybiB0aGlzPT09Y3QmJmkoc3QsbnQpJiYhaShrLG50KT8hMTphdHx8IWkodGhpcyxudCl8fCFpKHN0LG50KXx8aSh0aGlzLCQpJiZ0aGlzWyRdW250XT9hdDohMH0sej1mdW5jdGlvbihudCxhdCl7aWYobnQ9bChudCksYXQ9RShhdCwhMCksIShudD09PWN0JiZpKHN0LGF0KSYmIWkoayxhdCkpKXt2YXIgZHQ9QShudCxhdCk7cmV0dXJuIGR0JiZpKHN0LGF0KSYmIShpKG50LCQpJiZudFskXVthdF0pJiYoZHQuZW51bWVyYWJsZT0hMCksZHR9fSxLPWZ1bmN0aW9uKG50KXtmb3IodmFyIGF0PUcobChudCkpLGR0PVtdLGd0PTAsdXQ7YXQubGVuZ3RoPmd0OykhaShzdCx1dD1hdFtndCsrXSkmJnV0IT0kJiZ1dCE9YSYmZHQucHVzaCh1dCk7cmV0dXJuIGR0fSxZPWZ1bmN0aW9uKG50KXtmb3IodmFyIGF0PW50PT09Y3QsZHQ9RyhhdD9rOmwobnQpKSxndD1bXSx1dD0wLG10O2R0Lmxlbmd0aD51dDspaShzdCxtdD1kdFt1dCsrXSkmJighYXR8fGkoY3QsbXQpKSYmZ3QucHVzaChzdFttdF0pO3JldHVybiBndH07ZnR8fChIPWZ1bmN0aW9uKCl7aWYodGhpcyBpbnN0YW5jZW9mIEgpdGhyb3cgVHlwZUVycm9yKCJTeW1ib2wgaXMgbm90IGEgY29uc3RydWN0b3IhIik7dmFyIG50PXYoYXJndW1lbnRzLmxlbmd0aD4wP2FyZ3VtZW50c1swXTp2b2lkIDApLGF0PWZ1bmN0aW9uKGR0KXt0aGlzPT09Y3QmJmF0LmNhbGwoayxkdCksaSh0aGlzLCQpJiZpKHRoaXNbJF0sbnQpJiYodGhpc1skXVtudF09ITEpLFYodGhpcyxudCxUKDEsZHQpKX07cmV0dXJuIGgmJlUmJlYoY3QsbnQse2NvbmZpZ3VyYWJsZTohMCxzZXQ6YXR9KSxYKG50KX0sdShIW0ZdLCJ0b1N0cmluZyIsZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fa30pLFAuZj16LEQuZj13LHQoMTgyKS5mPUkuZj1LLHQoMTY5KS5mPU4sTC5mPVksaCYmIXQoODkpJiZ1KGN0LCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsTiwhMCksQy5mPWZ1bmN0aW9uKGl0KXtyZXR1cm4gWChwKGl0KSl9KSxnKGcuRytnLlcrZy5GKiFmdCx7U3ltYm9sOkh9KTtmb3IodmFyIFE9Imhhc0luc3RhbmNlLGlzQ29uY2F0U3ByZWFkYWJsZSxpdGVyYXRvcixtYXRjaCxyZXBsYWNlLHNlYXJjaCxzcGVjaWVzLHNwbGl0LHRvUHJpbWl0aXZlLHRvU3RyaW5nVGFnLHVuc2NvcGFibGVzIi5zcGxpdCgiLCIpLGV0PTA7US5sZW5ndGg+ZXQ7KXAoUVtldCsrXSk7Zm9yKHZhciBydD1SKHAuc3RvcmUpLG90PTA7cnQubGVuZ3RoPm90OylNKHJ0W290KytdKTtnKGcuUytnLkYqIWZ0LCJTeW1ib2wiLHtmb3I6ZnVuY3Rpb24oaXQpe3JldHVybiBpKF8saXQrPSIiKT9fW2l0XTpfW2l0XT1IKGl0KX0sa2V5Rm9yOmZ1bmN0aW9uKG50KXtpZighQihudCkpdGhyb3cgVHlwZUVycm9yKG50KyIgaXMgbm90IGEgc3ltYm9sISIpO2Zvcih2YXIgYXQgaW4gXylpZihfW2F0XT09PW50KXJldHVybiBhdH0sdXNlU2V0dGVyOmZ1bmN0aW9uKCl7VT0hMH0sdXNlU2ltcGxlOmZ1bmN0aW9uKCl7VT0hMX19KSxnKGcuUytnLkYqIWZ0LCJPYmplY3QiLHtjcmVhdGU6TyxkZWZpbmVQcm9wZXJ0eTp3LGRlZmluZVByb3BlcnRpZXM6ZCxnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6eixnZXRPd25Qcm9wZXJ0eU5hbWVzOkssZ2V0T3duUHJvcGVydHlTeW1ib2xzOll9KTt2YXIgbHQ9YyhmdW5jdGlvbigpe0wuZigxKX0pO2coZy5TK2cuRipsdCwiT2JqZWN0Iix7Z2V0T3duUHJvcGVydHlTeW1ib2xzOmZ1bmN0aW9uKG50KXtyZXR1cm4gTC5mKHMobnQpKX19KSxaJiZnKGcuUytnLkYqKCFmdHx8YyhmdW5jdGlvbigpe3ZhciBpdD1IKCk7cmV0dXJuIHEoW2l0XSkhPSJbbnVsbF0ifHxxKHthOml0fSkhPSJ7fSJ8fHEoT2JqZWN0KGl0KSkhPSJ7fSJ9KSksIkpTT04iLHtzdHJpbmdpZnk6ZnVuY3Rpb24obnQpe2Zvcih2YXIgYXQ9W250XSxkdD0xLGd0LHV0O2FyZ3VtZW50cy5sZW5ndGg+ZHQ7KWF0LnB1c2goYXJndW1lbnRzW2R0KytdKTtpZih1dD1ndD1hdFsxXSwhKCFvKGd0KSYmbnQ9PT12b2lkIDB8fEIobnQpKSlyZXR1cm4geShndCl8fChndD1mdW5jdGlvbihtdCxUdCl7aWYodHlwZW9mIHV0PT0iZnVuY3Rpb24iJiYoVHQ9dXQuY2FsbCh0aGlzLG10LFR0KSksIUIoVHQpKXJldHVybiBUdH0pLGF0WzFdPWd0LHEuYXBwbHkoWixhdCl9fSksSFtGXVtKXXx8dCg5NSkoSFtGXSxKLEhbRl0udmFsdWVPZiksZihILCJTeW1ib2wiKSxmKE1hdGgsIk1hdGgiLCEwKSxmKHIuSlNPTiwiSlNPTiIsITApfSxmdW5jdGlvbihTLGUsdCl7ZS5mPXQoMTIyKX0sZnVuY3Rpb24oUyxlLHQpe3ZhciByPXQoOTEpLGk9dCg5MiksaD10KDg5KSxnPXQoMTc4KSx1PXQoOTYpLmY7Uy5leHBvcnRzPWZ1bmN0aW9uKGEpe3ZhciBjPWkuU3ltYm9sfHwoaS5TeW1ib2w9aD97fTpyLlN5bWJvbHx8e30pO2EuY2hhckF0KDApIT0iXyImJiEoYSBpbiBjKSYmdShjLGEse3ZhbHVlOmcuZihhKX0pfX0sZnVuY3Rpb24oUyxlLHQpe3ZhciByPXQoMTEwKSxpPXQoMTY4KSxoPXQoMTY5KTtTLmV4cG9ydHM9ZnVuY3Rpb24oZyl7dmFyIHU9cihnKSxhPWkuZjtpZihhKWZvcih2YXIgYz1hKGcpLHg9aC5mLGY9MCx2O2MubGVuZ3RoPmY7KXguY2FsbChnLHY9Y1tmKytdKSYmdS5wdXNoKHYpO3JldHVybiB1fX0sZnVuY3Rpb24oUyxlLHQpe3ZhciByPXQoODQpLGk9dCgxODIpLmYsaD17fS50b1N0cmluZyxnPXR5cGVvZiB3aW5kb3c9PSJvYmplY3QiJiZ3aW5kb3cmJk9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzP09iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHdpbmRvdyk6W10sdT1mdW5jdGlvbihhKXt0cnl7cmV0dXJuIGkoYSl9Y2F0Y2h7cmV0dXJuIGcuc2xpY2UoKX19O1MuZXhwb3J0cy5mPWZ1bmN0aW9uKGMpe3JldHVybiBnJiZoLmNhbGwoYyk9PSJbb2JqZWN0IFdpbmRvd10iP3UoYyk6aShyKGMpKX19LGZ1bmN0aW9uKFMsZSx0KXt2YXIgcj10KDExMSksaT10KDExOSkuY29uY2F0KCJsZW5ndGgiLCJwcm90b3R5cGUiKTtlLmY9T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXN8fGZ1bmN0aW9uKGcpe3JldHVybiByKGcsaSl9fSxmdW5jdGlvbihTLGUsdCl7dmFyIHI9dCgxNjkpLGk9dCgxMDQpLGg9dCg4NCksZz10KDEwMyksdT10KDEwNSksYT10KDk5KSxjPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7ZS5mPXQoMTAwKT9jOmZ1bmN0aW9uKGYsdil7aWYoZj1oKGYpLHY9Zyh2LCEwKSxhKXRyeXtyZXR1cm4gYyhmLHYpfWNhdGNoe31pZih1KGYsdikpcmV0dXJuIGkoIXIuZi5jYWxsKGYsdiksZlt2XSl9fSxmdW5jdGlvbihTLGUsdCl7dCgxNzkpKCJhc3luY0l0ZXJhdG9yIil9LGZ1bmN0aW9uKFMsZSx0KXt0KDE3OSkoIm9ic2VydmFibGUiKX0sZnVuY3Rpb24oUyxlLHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxlLmNyZWF0ZU5vd1RpbWU9cixlLmZvcm1hdERlbGF5PWk7ZnVuY3Rpb24gcigpe3ZhciBoPW51bGw7cmV0dXJuIERhdGUubm93P2g9RGF0ZS5ub3c6aD1mdW5jdGlvbigpe3JldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKX0saH1mdW5jdGlvbiBpKGgpe3JldHVybiB0eXBlb2YgaD09Im51bWJlciI/aD17ZGVsYXk6aH06ImVudHJvcHkiaW4gaCYmKGg9e2RlbGF5OmguZW50cm9weSxpc0VudHJvcHk6ITB9KSxofX0sZnVuY3Rpb24oUyxlLHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxlLmRlZmF1bHQ9e2RlZmF1bHQ6ZnVuY3Rpb24oaSxoLGcsdSxhKXtyZXR1cm4gdHlwZW9mIGk9PSJudW1iZXIiJiZ0eXBlb2YgaD09Im51bWJlciI/aSsoZy11KS8oYS11KSooaC1pKTpnLXU+YS1nP2g6aX19fSxmdW5jdGlvbihTLGUsdCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLGUucGFyc2VFYXNpbmc9ZS5FYXNpbmdzPXZvaWQgMDt2YXIgcj10KDc2KSxpPWMociksaD10KDEzMyksZz1jKGgpLHU9dCgxNDEpLGE9Yyh1KTtmdW5jdGlvbiBjKHkpe3JldHVybiB5JiZ5Ll9fZXNNb2R1bGU/eTp7ZGVmYXVsdDp5fX12YXIgeD10KDE4OSksZj1uZXcgYS5kZWZhdWx0O2Z1bmN0aW9uIHYoKXtmb3IodmFyIHk9YXJndW1lbnRzLmxlbmd0aCxuPUFycmF5KHkpLG89MDtvPHk7bysrKW5bb109YXJndW1lbnRzW29dO3ZhciBzPWYuZ2V0KG4pO3JldHVybiBzfHwocz14LmFwcGx5KHZvaWQgMCxuKSxmLnNldChuLHMpLHMpfWZ1bmN0aW9uIHAoeSl7dmFyIG49YXJndW1lbnRzLmxlbmd0aD4xJiZhcmd1bWVudHNbMV0hPT12b2lkIDA/YXJndW1lbnRzWzFdOiJlbmQiO3JldHVybiBmdW5jdGlvbihvLHMpe2Zvcih2YXIgbD0xO2w8cy5sZW5ndGg7bCsrKXt2YXIgRT1zW2xdLm9mZnNldDtpZihvPD1FKXt2YXIgVD1zW2wtMV0ub2Zmc2V0LGI9RSxJPShvLVQpLyhiLVQpLFA9MS95LEw9SS9QO3JldHVybiBuPT09ImVuZCI/TD1NYXRoLmZsb29yKEwpOkw9TWF0aC5jZWlsKEwpLFAqTCooYi1UKStUfX1yZXR1cm4gMH19ZnVuY3Rpb24gQyh5KXt2YXIgbj0vXmN1YmljLWJlemllclwoKC4qKVwpLyxvPXkubWF0Y2gobik7aWYobyl7dmFyIHM9b1sxXS50cmltKCk7cmV0dXJuIHM9cy5zcGxpdCgiLCIpLm1hcChmdW5jdGlvbihQKXtyZXR1cm4gcGFyc2VGbG9hdChQLnRyaW0oKSl9KSx2LmFwcGx5KHZvaWQgMCwoMCxnLmRlZmF1bHQpKHMpKX1pZihuPS9ec3RlcHNcKCguKilcKS8sbz15Lm1hdGNoKG4pLG8pe3ZhciBsPW9bMV0udHJpbSgpO2w9bC5zcGxpdCgiLCIpLm1hcChmdW5jdGlvbihQKXtyZXR1cm4gUC50cmltKCl9KTt2YXIgRT1sLFQ9KDAsaS5kZWZhdWx0KShFLDIpLGI9VFswXSxJPVRbMV07cmV0dXJuIHAocGFyc2VJbnQoYiwxMCksSSl9cmV0dXJuIHl9dmFyIE09e2xpbmVhcjpmdW5jdGlvbihuKXtyZXR1cm4gbn0sZWFzZTp2KC4yNSwuMSwuMjUsMSksImVhc2UtaW4iOnYoLjQyLDAsMSwxKSwiZWFzZS1vdXQiOnYoMCwwLC41OCwxKSwiZWFzZS1pbi1vdXQiOnYoLjQyLDAsLjU4LDEpLCJzdGVwLXN0YXJ0IjpwKDEsInN0YXJ0IiksInN0ZXAtZW5kIjpwKDEsImVuZCIpfTtmdW5jdGlvbiBtKHkpe3JldHVybiB0eXBlb2YgeT09InN0cmluZyI/TVt5XT95PU1beV06eT1DKHkpOnkudHlwZT09PSJjdWJpYy1iZXppZXIiP3k9di5hcHBseSh2b2lkIDAsKDAsZy5kZWZhdWx0KSh5LnZhbHVlKSk6eS50eXBlPT09InN0ZXBzIiYmKHk9cCh5LnN0ZXAseS5wb3MpKSx5fWUuRWFzaW5ncz1NLGUucGFyc2VFYXNpbmc9bX0sZnVuY3Rpb24oUyxlKXt2YXIgdD00LHI9LjAwMSxpPTFlLTcsaD0xMCxnPTExLHU9MS8oZy0xKSxhPXR5cGVvZiBGbG9hdDMyQXJyYXk9PSJmdW5jdGlvbiI7ZnVuY3Rpb24gYyh5LG4pe3JldHVybiAxLTMqbiszKnl9ZnVuY3Rpb24geCh5LG4pe3JldHVybiAzKm4tNip5fWZ1bmN0aW9uIGYoeSl7cmV0dXJuIDMqeX1mdW5jdGlvbiB2KHksbixvKXtyZXR1cm4oKGMobixvKSp5K3gobixvKSkqeStmKG4pKSp5fWZ1bmN0aW9uIHAoeSxuLG8pe3JldHVybiAzKmMobixvKSp5KnkrMip4KG4sbykqeStmKG4pfWZ1bmN0aW9uIEMoeSxuLG8scyxsKXt2YXIgRSxULGI9MDtkbyBUPW4rKG8tbikvMixFPXYoVCxzLGwpLXksRT4wP289VDpuPVQ7d2hpbGUoTWF0aC5hYnMoRSk+aSYmKytiPGgpO3JldHVybiBUfWZ1bmN0aW9uIE0oeSxuLG8scyl7Zm9yKHZhciBsPTA7bDx0OysrbCl7dmFyIEU9cChuLG8scyk7aWYoRT09PTApcmV0dXJuIG47dmFyIFQ9dihuLG8scykteTtuLT1UL0V9cmV0dXJuIG59ZnVuY3Rpb24gbSh5KXtyZXR1cm4geX1TLmV4cG9ydHM9ZnVuY3Rpb24obixvLHMsbCl7aWYoISgwPD1uJiZuPD0xJiYwPD1zJiZzPD0xKSl0aHJvdyBuZXcgRXJyb3IoImJlemllciB4IHZhbHVlcyBtdXN0IGJlIGluIFswLCAxXSByYW5nZSIpO2lmKG49PT1vJiZzPT09bClyZXR1cm4gbTtmb3IodmFyIEU9YT9uZXcgRmxvYXQzMkFycmF5KGcpOm5ldyBBcnJheShnKSxUPTA7VDxnOysrVClFW1RdPXYoVCp1LG4scyk7ZnVuY3Rpb24gYihJKXtmb3IodmFyIFA9MCxMPTEsRD1nLTE7TCE9PUQmJkVbTF08PUk7KytMKVArPXU7LS1MO3ZhciBSPShJLUVbTF0pLyhFW0wrMV0tRVtMXSksQT1QK1IqdSxqPXAoQSxuLHMpO3JldHVybiBqPj1yP00oSSxBLG4scyk6aj09PTA/QTpDKEksUCxQK3UsbixzKX1yZXR1cm4gZnVuY3Rpb24oUCl7cmV0dXJuIFA9PT0wPzA6UD09PTE/MTp2KGIoUCksbyxsKX19fSxmdW5jdGlvbihTLGUsdCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pO3ZhciByPXQoMTkxKSxpPW8ociksaD10KDIwNCksZz1vKGgpLHU9dCgxNjQpLGE9byh1KSxjPXQoMTcwKSx4PW8oYyksZj10KDE3MSksdj1vKGYpLHA9dCgxNzUpLEM9byhwKSxNPXQoNzUpLG09byhNKSx5PXQoMjA4KSxuPXQoMTg4KTtmdW5jdGlvbiBvKGope3JldHVybiBqJiZqLl9fZXNNb2R1bGU/ajp7ZGVmYXVsdDpqfX12YXIgcz0oMCxDLmRlZmF1bHQpKCJ0aW1pbmciKSxsPSgwLEMuZGVmYXVsdCkoImtleWZyYW1lcyIpLEU9KDAsQy5kZWZhdWx0KSgiaW5pdFN0YXRlIiksVD0oMCxDLmRlZmF1bHQpKCJyZWFkeURlZmVyIiksYj0oMCxDLmRlZmF1bHQpKCJmaW5pc2hlZERlZmVyIiksST0oMCxDLmRlZmF1bHQpKCJlZmZlY3RzIiksUD0oMCxDLmRlZmF1bHQpKCJhY3RpdmVSZWFkeVRpbWVyIiksTD0oMCxDLmRlZmF1bHQpKCJhY3RpdmVGaW5pc2hUaW1lciIpLEQ9KDAsQy5kZWZhdWx0KSgicmVtb3ZlRGVmZXIiKSxSPXtkZWxheTowLGVuZERlbGF5OjAsZmlsbDoiYXV0byIsaXRlcmF0aW9uczoxLHBsYXliYWNrUmF0ZToxLGRpcmVjdGlvbjoibm9ybWFsIixlYXNpbmc6ImxpbmVhciIsZWZmZWN0Om51bGx9LEE9ZnVuY3Rpb24oKXtmdW5jdGlvbiBqKEcsSCxaKXt2YXIgcT10aGlzO2lmKCgwLHguZGVmYXVsdCkodGhpcyxqKSxBcnJheS5pc0FycmF5KEcpKXt2YXIgRj1bR1swXSxHLEhdO0c9RlswXSxIPUZbMV0sWj1GWzJdfXR5cGVvZiBaPT0ibnVtYmVyIiYmKFo9e2R1cmF0aW9uOlp9KSx0aGlzW3NdPSgwLGEuZGVmYXVsdCkoe30sUixaKSx0aGlzW3NdLmVhc2luZz0oMCxuLnBhcnNlRWFzaW5nKSh0aGlzW3NdLmVhc2luZyksdGhpc1tsXT0oMCx5LmNhbGN1bGF0ZUZyYW1lc09mZnNldCkoSCk7dmFyICQ9dGhpc1tsXVt0aGlzW2xdLmxlbmd0aC0xXTt0aGlzW0VdPXt9LCgwLGcuZGVmYXVsdCkoJCkuZm9yRWFjaChmdW5jdGlvbihKKXtPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoRyxKKSYmSiE9PSJlYXNpbmciJiZKIT09Im9mZnNldCImJihxW0VdW0pdPUdbSl0pfSksdGhpc1tsXT10aGlzW2xdLm1hcChmdW5jdGlvbihKKXtyZXR1cm4oMCxhLmRlZmF1bHQpKHt9LHFbRV0sSil9KSx0aGlzW2xdWzBdLm9mZnNldCE9PTAmJnRoaXNbbF0udW5zaGlmdCgoMCxhLmRlZmF1bHQpKHt9LHRoaXNbRV0se29mZnNldDowfSkpLCQub2Zmc2V0PDEmJnRoaXNbbF0ucHVzaCgoMCxhLmRlZmF1bHQpKHt9LCQse29mZnNldDoxfSkpLHRoaXNbSV09e30sdGhpcy50aW1lbGluZT1udWxsfXJldHVybigwLHYuZGVmYXVsdCkoaixbe2tleToicGF1c2UiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy50aW1lbGluZS5wbGF5YmFja1JhdGU9MH19LHtrZXk6UCx2YWx1ZTpmdW5jdGlvbigpe3ZhciBIPXRoaXM7dGhpc1tUXSYmIXRoaXNbVF0udGltZXJJRCYmKHRoaXMudGltZWxpbmUuY3VycmVudFRpbWU8MD90aGlzW1RdLnRpbWVySUQ9dGhpcy50aW1lbGluZS5zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7SFtUXS5yZXNvbHZlKCksZGVsZXRlIEhbVF19LHtkZWxheTotdGhpcy50aW1lbGluZS5jdXJyZW50VGltZSxoZWFkaW5nOiExfSk6dGhpc1tUXS50aW1lcklEPXRoaXMudGltZWxpbmUuc2V0VGltZW91dChmdW5jdGlvbigpe0hbVF0ucmVzb2x2ZSgpLGRlbGV0ZSBIW1RdfSx7ZGVsYXk6MCxpc0VudHJvcHk6ITB9KSl9fSx7a2V5OkwsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgSD10aGlzLFo9dGhpc1tzXSxxPVouZHVyYXRpb24sRj1aLml0ZXJhdGlvbnMsJD1aLmVuZERlbGF5LEo9TWF0aC5jZWlsKHEqRiskLXRoaXMudGltZWxpbmUuY3VycmVudFRpbWUpKzE7dGhpc1tiXSYmIXRoaXNbYl0udGltZXJJRCYmKHRoaXNbYl0udGltZXJJRD10aGlzLnRpbWVsaW5lLnNldFRpbWVvdXQoZnVuY3Rpb24oKXtIW2JdLnJlc29sdmUoKSxIW0RdKFQpLEhbRF0oYil9LHtkZWxheTpKLGhlYWRpbmc6ITF9KSx0aGlzW2JdLnJldmVyc2VUaW1lcklEPXRoaXMudGltZWxpbmUuc2V0VGltZW91dChmdW5jdGlvbigpe0hbYl0ucmVzb2x2ZSgpLEhbRF0oVCksSFtEXShiKSxILnRpbWVsaW5lPW51bGx9LHtkZWxheTotdGhpc1tzXS5kZWxheS0xLGhlYWRpbmc6ITF9KSl9fSx7a2V5OiJwbGF5Iix2YWx1ZTpmdW5jdGlvbigpe2lmKHRoaXMucGxheVN0YXRlPT09ImZpbmlzaGVkIiYmdGhpcy5jYW5jZWwoKSx0aGlzLnBsYXlTdGF0ZT09PSJpZGxlIil7aWYodGhpcy5wbGF5YmFja1JhdGU8PTApcmV0dXJuO3ZhciBIPXRoaXNbc10sWj1ILmRlbGF5LHE9SC5wbGF5YmFja1JhdGUsRj1ILnRpbWVsaW5lO3RoaXMudGltZWxpbmU9bmV3IG0uZGVmYXVsdCh7b3JpZ2luVGltZTpaLHBsYXliYWNrUmF0ZTpxfSxGKSx0aGlzW1BdKCksdGhpc1tMXSgpfWVsc2UgdGhpcy5wbGF5U3RhdGU9PT0icGF1c2VkIiYmKHRoaXMudGltZWxpbmUucGxheWJhY2tSYXRlPXRoaXMucGxheWJhY2tSYXRlLHRoaXNbUF0oKSl9fSx7a2V5OkQsdmFsdWU6ZnVuY3Rpb24oSCl7dmFyIFo9dGhpc1tIXSxxPXRoaXMudGltZWxpbmU7WiYmcSYmKHEuY2xlYXJUaW1lb3V0KFoudGltZXJJRCksWi5yZXZlcnNlVGltZXJJRCYmcS5jbGVhclRpbWVvdXQoWi5yZXZlcnNlVGltZXJJRCkpLGRlbGV0ZSB0aGlzW0hdfX0se2tleToiY2FuY2VsIix2YWx1ZTpmdW5jdGlvbigpe3RoaXNbRF0oVCksdGhpc1tEXShiKSx0aGlzLnRpbWVsaW5lPW51bGx9fSx7a2V5OiJmaW5pc2giLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy50aW1lbGluZSYmKHRoaXMudGltZWxpbmUuY3VycmVudFRpbWU9MS8wL3RoaXMucGxheWJhY2tSYXRlKSx0aGlzW0RdKFQpLHRoaXNbRF0oYil9fSx7a2V5OiJhcHBseUVmZmVjdHMiLHZhbHVlOmZ1bmN0aW9uKEgpe3JldHVybigwLGEuZGVmYXVsdCkodGhpc1tJXSxIKX19LHtrZXk6InBsYXliYWNrUmF0ZSIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXNbc10ucGxheWJhY2tSYXRlfSxzZXQ6ZnVuY3Rpb24oSCl7dGhpcy50aW1lbGluZSYmKHRoaXMudGltZWxpbmUucGxheWJhY2tSYXRlPUgpLHRoaXNbc10ucGxheWJhY2tSYXRlPUh9fSx7a2V5OiJwbGF5U3RhdGUiLGdldDpmdW5jdGlvbigpe3ZhciBIPXRoaXMudGltZWxpbmUsWj10aGlzW3NdLHE9Wi5pdGVyYXRpb25zLEY9Wi5kdXJhdGlvbiwkPVouZW5kRGVsYXksSj0icnVubmluZyI7aWYoSD09bnVsbClKPSJpZGxlIjtlbHNlIGlmKEgucGF1c2VkKUo9InBhdXNlZCI7ZWxzZSBpZihILmN1cnJlbnRUaW1lPDApSj0icGVuZGluZyI7ZWxzZXt2YXIgdHQ9SC5jdXJyZW50VGltZS1xKkY7dHQ+MCYmdHQ8JD9KPSJwZW5kaW5nIjp0dD49JCYmKEo9ImZpbmlzaGVkIil9cmV0dXJuIEp9fSx7a2V5OiJwcm9ncmVzcyIsZ2V0OmZ1bmN0aW9uKCl7aWYoIXRoaXMudGltZWxpbmUpcmV0dXJuIDA7dmFyIEg9dGhpc1tzXSxaPUguZHVyYXRpb24scT1ILml0ZXJhdGlvbnMsRj10aGlzLnRpbWVsaW5lLCQ9dGhpcy5wbGF5U3RhdGUsSj12b2lkIDA7aWYoJD09PSJpZGxlIilKPTA7ZWxzZSBpZigkPT09InBhdXNlZCImJkYuY3VycmVudFRpbWU8MClKPTA7ZWxzZSBpZigkPT09InBlbmRpbmciKWlmKEYuY3VycmVudFRpbWU8MClKPTA7ZWxzZXt2YXIgdHQ9Ri5zZWVrTG9jYWxUaW1lKHEqWik7Sj0oMCx5LnBlcmlvZGljaXR5KSh0dCxaKVsxXS9afWVsc2UoJD09PSJydW5uaW5nInx8JD09PSJwYXVzZWQiKSYmKEo9KDAseS5wZXJpb2RpY2l0eSkoRi5jdXJyZW50VGltZSxaKVsxXS9aKTtyZXR1cm4gJD09PSJmaW5pc2hlZCImJihKPSgwLHkucGVyaW9kaWNpdHkpKHEsMSlbMV0pLEp9fSx7a2V5OiJmcmFtZSIsZ2V0OmZ1bmN0aW9uKCl7dmFyIEg9dGhpcy5wbGF5U3RhdGUsWj10aGlzW0VdLHE9dGhpc1tzXS5maWxsO2lmKEg9PT0iaWRsZSIpcmV0dXJuIFo7dmFyIEY9dGhpcy50aW1lbGluZS5jdXJyZW50VGltZSwkPXRoaXNbbF0uc2xpY2UoMCksSj0oMCx5LmdldFByb2dyZXNzKSh0aGlzLnRpbWVsaW5lLHRoaXNbc10sdGhpcy5wcm9ncmVzcyksdHQ9Si5wLF89Si5pbnZlcnRlZCxzdD1aO3JldHVybiBGPDAmJkg9PT0icGVuZGluZyI/KHE9PT0iYmFja3dhcmRzInx8cT09PSJib3RoIikmJihzdD1fPyRbJC5sZW5ndGgtMV06JFswXSk6KEghPT0icGVuZGluZyImJkghPT0iZmluaXNoZWQifHxxPT09ImZvcndhcmRzInx8cT09PSJib3RoIikmJihzdD0oMCx5LmdldEN1cnJlbnRGcmFtZSkodGhpc1tzXSwkLHRoaXNbSV0sdHQpKSxzdH19LHtrZXk6InRpbWluZyIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXNbc119fSx7a2V5OiJlZmZlY3RzIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc1tJXX19LHtrZXk6ImJhc2VUaW1lbGluZSIsc2V0OmZ1bmN0aW9uKEgpe3RoaXNbc10udGltZWxpbmU9SH0sZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXNbc10udGltZWxpbmV9fSx7a2V5OiJyZWFkeSIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXNbVF0/dGhpc1tUXS5wcm9taXNlOnRoaXMudGltZWxpbmUmJnRoaXMudGltZWxpbmUuY3VycmVudFRpbWU+PTAmJnRoaXMucGxheVN0YXRlIT09InBhdXNlZCI/aS5kZWZhdWx0LnJlc29sdmUoKToodGhpc1tUXT0oMCx5LmRlZmVyKSgpLHRoaXMudGltZWxpbmUmJnRoaXNbUF0oKSx0aGlzW1RdP3RoaXNbVF0ucHJvbWlzZTppLmRlZmF1bHQucmVzb2x2ZSgpKX19LHtrZXk6ImZpbmlzaGVkIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wbGF5U3RhdGU9PT0iZmluaXNoZWQiP2kuZGVmYXVsdC5yZXNvbHZlKCk6KHRoaXNbYl18fCh0aGlzW2JdPSgwLHkuZGVmZXIpKCksdGhpcy50aW1lbGluZSYmdGhpc1tMXSgpKSx0aGlzW2JdLnByb21pc2UpfX1dKSxqfSgpO2UuZGVmYXVsdD1BfSxmdW5jdGlvbihTLGUsdCl7Uy5leHBvcnRzPXtkZWZhdWx0OnQoMTkyKSxfX2VzTW9kdWxlOiEwfX0sZnVuY3Rpb24oUyxlLHQpe3QoMTQzKSx0KDEyNSksdCg3OSksdCgxOTMpLHQoMjAyKSx0KDIwMyksUy5leHBvcnRzPXQoOTIpLlByb21pc2V9LGZ1bmN0aW9uKFMsZSx0KXt2YXIgcj10KDg5KSxpPXQoOTEpLGg9dCg5MyksZz10KDEyOCksdT10KDkwKSxhPXQoOTgpLGM9dCg5NCkseD10KDE0NyksZj10KDE0OCksdj10KDE5NCkscD10KDE5NSkuc2V0LEM9dCgxOTcpKCksTT10KDE5OCksbT10KDE5OSkseT10KDIwMCksbj10KDIwMSksbz0iUHJvbWlzZSIscz1pLlR5cGVFcnJvcixsPWkucHJvY2VzcyxFPWwmJmwudmVyc2lvbnMsVD1FJiZFLnY4fHwiIixiPWlbb10sST1nKGwpPT0icHJvY2VzcyIsUD1mdW5jdGlvbigpe30sTCxELFIsQSxqPUQ9TS5mLEc9ISFmdW5jdGlvbigpe3RyeXt2YXIgXz1iLnJlc29sdmUoMSksc3Q9KF8uY29uc3RydWN0b3I9e30pW3QoMTIyKSgic3BlY2llcyIpXT1mdW5jdGlvbihrKXtrKFAsUCl9O3JldHVybihJfHx0eXBlb2YgUHJvbWlzZVJlamVjdGlvbkV2ZW50PT0iZnVuY3Rpb24iKSYmXy50aGVuKFApaW5zdGFuY2VvZiBzdCYmVC5pbmRleE9mKCI2LjYiKSE9PTAmJnkuaW5kZXhPZigiQ2hyb21lLzY2Iik9PT0tMX1jYXRjaHt9fSgpLEg9ZnVuY3Rpb24oXyl7dmFyIHN0O3JldHVybiBhKF8pJiZ0eXBlb2Yoc3Q9Xy50aGVuKT09ImZ1bmN0aW9uIj9zdDohMX0sWj1mdW5jdGlvbihfLHN0KXtpZighXy5fbil7Xy5fbj0hMDt2YXIgaz1fLl9jO0MoZnVuY3Rpb24oKXtmb3IodmFyIGN0PV8uX3YsZnQ9Xy5fcz09MSxXPTAsVT1mdW5jdGlvbihWKXt2YXIgWD1mdD9WLm9rOlYuZmFpbCxCPVYucmVzb2x2ZSx3PVYucmVqZWN0LGQ9Vi5kb21haW4sTyxOLHo7dHJ5e1g/KGZ0fHwoXy5faD09MiYmJChfKSxfLl9oPTEpLFg9PT0hMD9PPWN0OihkJiZkLmVudGVyKCksTz1YKGN0KSxkJiYoZC5leGl0KCksej0hMCkpLE89PT1WLnByb21pc2U/dyhzKCJQcm9taXNlLWNoYWluIGN5Y2xlIikpOihOPUgoTykpP04uY2FsbChPLEIsdyk6QihPKSk6dyhjdCl9Y2F0Y2goSyl7ZCYmIXomJmQuZXhpdCgpLHcoSyl9fTtrLmxlbmd0aD5XOylVKGtbVysrXSk7Xy5fYz1bXSxfLl9uPSExLHN0JiYhXy5faCYmcShfKX0pfX0scT1mdW5jdGlvbihfKXtwLmNhbGwoaSxmdW5jdGlvbigpe3ZhciBzdD1fLl92LGs9RihfKSxjdCxmdCxXO2lmKGsmJihjdD1tKGZ1bmN0aW9uKCl7ST9sLmVtaXQoInVuaGFuZGxlZFJlamVjdGlvbiIsc3QsXyk6KGZ0PWkub251bmhhbmRsZWRyZWplY3Rpb24pP2Z0KHtwcm9taXNlOl8scmVhc29uOnN0fSk6KFc9aS5jb25zb2xlKSYmVy5lcnJvciYmVy5lcnJvcigiVW5oYW5kbGVkIHByb21pc2UgcmVqZWN0aW9uIixzdCl9KSxfLl9oPUl8fEYoXyk/MjoxKSxfLl9hPXZvaWQgMCxrJiZjdC5lKXRocm93IGN0LnZ9KX0sRj1mdW5jdGlvbihfKXtyZXR1cm4gXy5faCE9PTEmJihfLl9hfHxfLl9jKS5sZW5ndGg9PT0wfSwkPWZ1bmN0aW9uKF8pe3AuY2FsbChpLGZ1bmN0aW9uKCl7dmFyIHN0O0k/bC5lbWl0KCJyZWplY3Rpb25IYW5kbGVkIixfKTooc3Q9aS5vbnJlamVjdGlvbmhhbmRsZWQpJiZzdCh7cHJvbWlzZTpfLHJlYXNvbjpfLl92fSl9KX0sSj1mdW5jdGlvbihfKXt2YXIgc3Q9dGhpcztzdC5fZHx8KHN0Ll9kPSEwLHN0PXN0Ll93fHxzdCxzdC5fdj1fLHN0Ll9zPTIsc3QuX2F8fChzdC5fYT1zdC5fYy5zbGljZSgpKSxaKHN0LCEwKSl9LHR0PWZ1bmN0aW9uKF8pe3ZhciBzdD10aGlzLGs7aWYoIXN0Ll9kKXtzdC5fZD0hMCxzdD1zdC5fd3x8c3Q7dHJ5e2lmKHN0PT09Xyl0aHJvdyBzKCJQcm9taXNlIGNhbid0IGJlIHJlc29sdmVkIGl0c2VsZiIpOyhrPUgoXykpP0MoZnVuY3Rpb24oKXt2YXIgY3Q9e193OnN0LF9kOiExfTt0cnl7ay5jYWxsKF8saCh0dCxjdCwxKSxoKEosY3QsMSkpfWNhdGNoKGZ0KXtKLmNhbGwoY3QsZnQpfX0pOihzdC5fdj1fLHN0Ll9zPTEsWihzdCwhMSkpfWNhdGNoKGN0KXtKLmNhbGwoe193OnN0LF9kOiExfSxjdCl9fX07R3x8KGI9ZnVuY3Rpb24oc3Qpe3godGhpcyxiLG8sIl9oIiksYyhzdCksTC5jYWxsKHRoaXMpO3RyeXtzdChoKHR0LHRoaXMsMSksaChKLHRoaXMsMSkpfWNhdGNoKGspe0ouY2FsbCh0aGlzLGspfX0sTD1mdW5jdGlvbihzdCl7dGhpcy5fYz1bXSx0aGlzLl9hPXZvaWQgMCx0aGlzLl9zPTAsdGhpcy5fZD0hMSx0aGlzLl92PXZvaWQgMCx0aGlzLl9oPTAsdGhpcy5fbj0hMX0sTC5wcm90b3R5cGU9dCgxNDYpKGIucHJvdG90eXBlLHt0aGVuOmZ1bmN0aW9uKHN0LGspe3ZhciBjdD1qKHYodGhpcyxiKSk7cmV0dXJuIGN0Lm9rPXR5cGVvZiBzdD09ImZ1bmN0aW9uIj9zdDohMCxjdC5mYWlsPXR5cGVvZiBrPT0iZnVuY3Rpb24iJiZrLGN0LmRvbWFpbj1JP2wuZG9tYWluOnZvaWQgMCx0aGlzLl9jLnB1c2goY3QpLHRoaXMuX2EmJnRoaXMuX2EucHVzaChjdCksdGhpcy5fcyYmWih0aGlzLCExKSxjdC5wcm9taXNlfSxjYXRjaDpmdW5jdGlvbihfKXtyZXR1cm4gdGhpcy50aGVuKHZvaWQgMCxfKX19KSxSPWZ1bmN0aW9uKCl7dmFyIF89bmV3IEw7dGhpcy5wcm9taXNlPV8sdGhpcy5yZXNvbHZlPWgodHQsXywxKSx0aGlzLnJlamVjdD1oKEosXywxKX0sTS5mPWo9ZnVuY3Rpb24oXyl7cmV0dXJuIF89PT1ifHxfPT09QT9uZXcgUihfKTpEKF8pfSksdSh1LkcrdS5XK3UuRiohRyx7UHJvbWlzZTpifSksdCgxMjEpKGIsbyksdCgxNDkpKG8pLEE9dCg5Milbb10sdSh1LlMrdS5GKiFHLG8se3JlamVjdDpmdW5jdGlvbihzdCl7dmFyIGs9aih0aGlzKSxjdD1rLnJlamVjdDtyZXR1cm4gY3Qoc3QpLGsucHJvbWlzZX19KSx1KHUuUyt1LkYqKHJ8fCFHKSxvLHtyZXNvbHZlOmZ1bmN0aW9uKHN0KXtyZXR1cm4gbihyJiZ0aGlzPT09QT9iOnRoaXMsc3QpfX0pLHUodS5TK3UuRiohKEcmJnQoMTQwKShmdW5jdGlvbihfKXtiLmFsbChfKS5jYXRjaChQKX0pKSxvLHthbGw6ZnVuY3Rpb24oc3Qpe3ZhciBrPXRoaXMsY3Q9aihrKSxmdD1jdC5yZXNvbHZlLFc9Y3QucmVqZWN0LFU9bShmdW5jdGlvbigpe3ZhciBWPVtdLFg9MCxCPTE7ZihzdCwhMSxmdW5jdGlvbih3KXt2YXIgZD1YKyssTz0hMTtWLnB1c2godm9pZCAwKSxCKyssay5yZXNvbHZlKHcpLnRoZW4oZnVuY3Rpb24oTil7T3x8KE89ITAsVltkXT1OLC0tQnx8ZnQoVikpfSxXKX0pLC0tQnx8ZnQoVil9KTtyZXR1cm4gVS5lJiZXKFUudiksY3QucHJvbWlzZX0scmFjZTpmdW5jdGlvbihzdCl7dmFyIGs9dGhpcyxjdD1qKGspLGZ0PWN0LnJlamVjdCxXPW0oZnVuY3Rpb24oKXtmKHN0LCExLGZ1bmN0aW9uKFUpe2sucmVzb2x2ZShVKS50aGVuKGN0LnJlc29sdmUsZnQpfSl9KTtyZXR1cm4gVy5lJiZmdChXLnYpLGN0LnByb21pc2V9fSl9LGZ1bmN0aW9uKFMsZSx0KXt2YXIgcj10KDk3KSxpPXQoOTQpLGg9dCgxMjIpKCJzcGVjaWVzIik7Uy5leHBvcnRzPWZ1bmN0aW9uKGcsdSl7dmFyIGE9cihnKS5jb25zdHJ1Y3RvcixjO3JldHVybiBhPT09dm9pZCAwfHwoYz1yKGEpW2hdKT09bnVsbD91OmkoYyl9fSxmdW5jdGlvbihTLGUsdCl7dmFyIHI9dCg5MyksaT10KDE5NiksaD10KDEyMCksZz10KDEwMiksdT10KDkxKSxhPXUucHJvY2VzcyxjPXUuc2V0SW1tZWRpYXRlLHg9dS5jbGVhckltbWVkaWF0ZSxmPXUuTWVzc2FnZUNoYW5uZWwsdj11LkRpc3BhdGNoLHA9MCxDPXt9LE09Im9ucmVhZHlzdGF0ZWNoYW5nZSIsbSx5LG4sbz1mdW5jdGlvbigpe3ZhciBsPSt0aGlzO2lmKEMuaGFzT3duUHJvcGVydHkobCkpe3ZhciBFPUNbbF07ZGVsZXRlIENbbF0sRSgpfX0scz1mdW5jdGlvbihsKXtvLmNhbGwobC5kYXRhKX07KCFjfHwheCkmJihjPWZ1bmN0aW9uKEUpe2Zvcih2YXIgVD1bXSxiPTE7YXJndW1lbnRzLmxlbmd0aD5iOylULnB1c2goYXJndW1lbnRzW2IrK10pO3JldHVybiBDWysrcF09ZnVuY3Rpb24oKXtpKHR5cGVvZiBFPT0iZnVuY3Rpb24iP0U6RnVuY3Rpb24oRSksVCl9LG0ocCkscH0seD1mdW5jdGlvbihFKXtkZWxldGUgQ1tFXX0sdCg4NikoYSk9PSJwcm9jZXNzIj9tPWZ1bmN0aW9uKGwpe2EubmV4dFRpY2socihvLGwsMSkpfTp2JiZ2Lm5vdz9tPWZ1bmN0aW9uKGwpe3Yubm93KHIobyxsLDEpKX06Zj8oeT1uZXcgZixuPXkucG9ydDIseS5wb3J0MS5vbm1lc3NhZ2U9cyxtPXIobi5wb3N0TWVzc2FnZSxuLDEpKTp1LmFkZEV2ZW50TGlzdGVuZXImJnR5cGVvZiBwb3N0TWVzc2FnZT09ImZ1bmN0aW9uIiYmIXUuaW1wb3J0U2NyaXB0cz8obT1mdW5jdGlvbihsKXt1LnBvc3RNZXNzYWdlKGwrIiIsIioiKX0sdS5hZGRFdmVudExpc3RlbmVyKCJtZXNzYWdlIixzLCExKSk6TSBpbiBnKCJzY3JpcHQiKT9tPWZ1bmN0aW9uKGwpe2guYXBwZW5kQ2hpbGQoZygic2NyaXB0IikpW01dPWZ1bmN0aW9uKCl7aC5yZW1vdmVDaGlsZCh0aGlzKSxvLmNhbGwobCl9fTptPWZ1bmN0aW9uKGwpe3NldFRpbWVvdXQocihvLGwsMSksMCl9KSxTLmV4cG9ydHM9e3NldDpjLGNsZWFyOnh9fSxmdW5jdGlvbihTLGUpe1MuZXhwb3J0cz1mdW5jdGlvbih0LHIsaSl7dmFyIGg9aT09PXZvaWQgMDtzd2l0Y2goci5sZW5ndGgpe2Nhc2UgMDpyZXR1cm4gaD90KCk6dC5jYWxsKGkpO2Nhc2UgMTpyZXR1cm4gaD90KHJbMF0pOnQuY2FsbChpLHJbMF0pO2Nhc2UgMjpyZXR1cm4gaD90KHJbMF0sclsxXSk6dC5jYWxsKGksclswXSxyWzFdKTtjYXNlIDM6cmV0dXJuIGg/dChyWzBdLHJbMV0sclsyXSk6dC5jYWxsKGksclswXSxyWzFdLHJbMl0pO2Nhc2UgNDpyZXR1cm4gaD90KHJbMF0sclsxXSxyWzJdLHJbM10pOnQuY2FsbChpLHJbMF0sclsxXSxyWzJdLHJbM10pfXJldHVybiB0LmFwcGx5KGkscil9fSxmdW5jdGlvbihTLGUsdCl7dmFyIHI9dCg5MSksaT10KDE5NSkuc2V0LGg9ci5NdXRhdGlvbk9ic2VydmVyfHxyLldlYktpdE11dGF0aW9uT2JzZXJ2ZXIsZz1yLnByb2Nlc3MsdT1yLlByb21pc2UsYT10KDg2KShnKT09InByb2Nlc3MiO1MuZXhwb3J0cz1mdW5jdGlvbigpe3ZhciBjLHgsZix2PWZ1bmN0aW9uKCl7dmFyIG0seTtmb3IoYSYmKG09Zy5kb21haW4pJiZtLmV4aXQoKTtjOyl7eT1jLmZuLGM9Yy5uZXh0O3RyeXt5KCl9Y2F0Y2gobil7dGhyb3cgYz9mKCk6eD12b2lkIDAsbn19eD12b2lkIDAsbSYmbS5lbnRlcigpfTtpZihhKWY9ZnVuY3Rpb24oKXtnLm5leHRUaWNrKHYpfTtlbHNlIGlmKGgmJiEoci5uYXZpZ2F0b3ImJnIubmF2aWdhdG9yLnN0YW5kYWxvbmUpKXt2YXIgcD0hMCxDPWRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCIiKTtuZXcgaCh2KS5vYnNlcnZlKEMse2NoYXJhY3RlckRhdGE6ITB9KSxmPWZ1bmN0aW9uKCl7Qy5kYXRhPXA9IXB9fWVsc2UgaWYodSYmdS5yZXNvbHZlKXt2YXIgTT11LnJlc29sdmUodm9pZCAwKTtmPWZ1bmN0aW9uKCl7TS50aGVuKHYpfX1lbHNlIGY9ZnVuY3Rpb24oKXtpLmNhbGwocix2KX07cmV0dXJuIGZ1bmN0aW9uKG0pe3ZhciB5PXtmbjptLG5leHQ6dm9pZCAwfTt4JiYoeC5uZXh0PXkpLGN8fChjPXksZigpKSx4PXl9fX0sZnVuY3Rpb24oUyxlLHQpe3ZhciByPXQoOTQpO2Z1bmN0aW9uIGkoaCl7dmFyIGcsdTt0aGlzLnByb21pc2U9bmV3IGgoZnVuY3Rpb24oYSxjKXtpZihnIT09dm9pZCAwfHx1IT09dm9pZCAwKXRocm93IFR5cGVFcnJvcigiQmFkIFByb21pc2UgY29uc3RydWN0b3IiKTtnPWEsdT1jfSksdGhpcy5yZXNvbHZlPXIoZyksdGhpcy5yZWplY3Q9cih1KX1TLmV4cG9ydHMuZj1mdW5jdGlvbihoKXtyZXR1cm4gbmV3IGkoaCl9fSxmdW5jdGlvbihTLGUpe1MuZXhwb3J0cz1mdW5jdGlvbih0KXt0cnl7cmV0dXJue2U6ITEsdjp0KCl9fWNhdGNoKHIpe3JldHVybntlOiEwLHY6cn19fX0sZnVuY3Rpb24oUyxlLHQpe3ZhciByPXQoOTEpLGk9ci5uYXZpZ2F0b3I7Uy5leHBvcnRzPWkmJmkudXNlckFnZW50fHwiIn0sZnVuY3Rpb24oUyxlLHQpe3ZhciByPXQoOTcpLGk9dCg5OCksaD10KDE5OCk7Uy5leHBvcnRzPWZ1bmN0aW9uKGcsdSl7aWYocihnKSxpKHUpJiZ1LmNvbnN0cnVjdG9yPT09ZylyZXR1cm4gdTt2YXIgYT1oLmYoZyksYz1hLnJlc29sdmU7cmV0dXJuIGModSksYS5wcm9taXNlfX0sZnVuY3Rpb24oUyxlLHQpe3ZhciByPXQoOTApLGk9dCg5MiksaD10KDkxKSxnPXQoMTk0KSx1PXQoMjAxKTtyKHIuUCtyLlIsIlByb21pc2UiLHtmaW5hbGx5OmZ1bmN0aW9uKGEpe3ZhciBjPWcodGhpcyxpLlByb21pc2V8fGguUHJvbWlzZSkseD10eXBlb2YgYT09ImZ1bmN0aW9uIjtyZXR1cm4gdGhpcy50aGVuKHg/ZnVuY3Rpb24oZil7cmV0dXJuIHUoYyxhKCkpLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gZn0pfTphLHg/ZnVuY3Rpb24oZil7cmV0dXJuIHUoYyxhKCkpLnRoZW4oZnVuY3Rpb24oKXt0aHJvdyBmfSl9OmEpfX0pfSxmdW5jdGlvbihTLGUsdCl7dmFyIHI9dCg5MCksaT10KDE5OCksaD10KDE5OSk7cihyLlMsIlByb21pc2UiLHt0cnk6ZnVuY3Rpb24oZyl7dmFyIHU9aS5mKHRoaXMpLGE9aChnKTtyZXR1cm4oYS5lP3UucmVqZWN0OnUucmVzb2x2ZSkoYS52KSx1LnByb21pc2V9fSl9LGZ1bmN0aW9uKFMsZSx0KXtTLmV4cG9ydHM9e2RlZmF1bHQ6dCgyMDUpLF9fZXNNb2R1bGU6ITB9fSxmdW5jdGlvbihTLGUsdCl7dCgyMDYpLFMuZXhwb3J0cz10KDkyKS5PYmplY3Qua2V5c30sZnVuY3Rpb24oUyxlLHQpe3ZhciByPXQoMTI0KSxpPXQoMTEwKTt0KDIwNykoImtleXMiLGZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKGcpe3JldHVybiBpKHIoZykpfX0pfSxmdW5jdGlvbihTLGUsdCl7dmFyIHI9dCg5MCksaT10KDkyKSxoPXQoMTAxKTtTLmV4cG9ydHM9ZnVuY3Rpb24oZyx1KXt2YXIgYT0oaS5PYmplY3R8fHt9KVtnXXx8T2JqZWN0W2ddLGM9e307Y1tnXT11KGEpLHIoci5TK3IuRipoKGZ1bmN0aW9uKCl7YSgxKX0pLCJPYmplY3QiLGMpfX0sZnVuY3Rpb24oUyxlLHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KTt2YXIgcj10KDc2KSxpPUMociksaD10KDIwOSksZz1DKGgpLHU9dCgxNjQpLGE9Qyh1KSxjPXQoMTkxKSx4PUMoYyk7ZS5kZWZlcj1NLGUucGVyaW9kaWNpdHk9bSxlLmNhbGN1bGF0ZUZyYW1lc09mZnNldD15LGUuZ2V0UHJvZ3Jlc3M9bixlLmdldEN1cnJlbnRGcmFtZT1zO3ZhciBmPXQoMTg4KSx2PXQoMTg3KSxwPUModik7ZnVuY3Rpb24gQyhsKXtyZXR1cm4gbCYmbC5fX2VzTW9kdWxlP2w6e2RlZmF1bHQ6bH19ZnVuY3Rpb24gTSgpe3ZhciBsPXt9O3JldHVybiBsLnByb21pc2U9bmV3IHguZGVmYXVsdChmdW5jdGlvbihFLFQpe2wucmVzb2x2ZT1FLGwucmVqZWN0PVR9KSxsfWZ1bmN0aW9uIG0obCxFKXt2YXIgVD1NYXRoLmZsb29yKGwvRSksYj1sLVQqRTtyZXR1cm4gYj09PTAmJlQ+MCYmKGI9RSxULS0pLFtULGJdfWZ1bmN0aW9uIHkobCl7bD1sLnNsaWNlKDApO3ZhciBFPWxbMF0sVD1sW2wubGVuZ3RoLTFdO1Qub2Zmc2V0PVQub2Zmc2V0fHwxLEUub2Zmc2V0PUUub2Zmc2V0fHwwO2Zvcih2YXIgYj0wLEk9LTEsUD0wO1A8bC5sZW5ndGg7UCsrKXt2YXIgTD1sW1BdO2lmKEwub2Zmc2V0IT1udWxsKXt2YXIgRD1QLUk7aWYoRD4xKWZvcih2YXIgUj0oTC5vZmZzZXQtYikvRCxBPTA7QTxELTE7QSsrKWxbSStBKzFdLm9mZnNldD1iK1IqKEErMSk7Yj1MLm9mZnNldCxJPVB9aWYoTC5lYXNpbmchPW51bGwmJihMLmVhc2luZz0oMCxmLnBhcnNlRWFzaW5nKShMLmVhc2luZykpLFA+MCl7dmFyIGo9bFtQXS5lYXNpbmchPW51bGw7bFtQXT0oMCxhLmRlZmF1bHQpKHt9LGxbUC0xXSxsW1BdKSxqfHxkZWxldGUgbFtQXS5lYXNpbmd9fXJldHVybiBsfWZ1bmN0aW9uIG4obCxFLFQpe3ZhciBiPWwuY3VycmVudFRpbWUsST1FLmRpcmVjdGlvbixQPUUuZHVyYXRpb24sTD0hMTtpZihJPT09InJldmVyc2UiKVQ9MS1ULEw9ITA7ZWxzZSBpZihJPT09ImFsdGVybmF0ZSJ8fEk9PT0iYWx0ZXJuYXRlLXJldmVyc2UiKXt2YXIgRD1NYXRoLmZsb29yKGIvUCk7VD09PTEmJkQtLSxEJTJeST09PSJhbHRlcm5hdGUtcmV2ZXJzZSImJihUPTEtVCxMPSEwKX1yZXR1cm57cDpULGludmVydGVkOkx9fWZ1bmN0aW9uIG8obCxFLFQsYil7dmFyIEk9e307cmV0dXJuKDAsZy5kZWZhdWx0KShFKS5mb3JFYWNoKGZ1bmN0aW9uKFApe3ZhciBMPSgwLGkuZGVmYXVsdCkoUCwyKSxEPUxbMF0sUj1MWzFdO2lmKEQhPT0ib2Zmc2V0IiYmRCE9PSJlYXNpbmciKXt2YXIgQT1UW0RdfHxULmRlZmF1bHQsaj1BKGxbRF0sUixiLGwub2Zmc2V0LEUub2Zmc2V0KTtqIT1udWxsJiYoSVtEXT1qKX19KSxJfWZ1bmN0aW9uIHMobCxFLFQsYil7dmFyIEk9bC5lYXNpbmcsUD1sLmVmZmVjdDtQfHwoVD0oMCxhLmRlZmF1bHQpKHt9LHAuZGVmYXVsdCxUKSk7dmFyIEw9e307Yj1JKGIsRSk7Zm9yKHZhciBEPTE7RDxFLmxlbmd0aDtEKyspe3ZhciBSPUVbRF0sQT1SLm9mZnNldDtpZihBPj1ifHxEPT09RS5sZW5ndGgtMSl7dmFyIGo9RVtELTFdLEc9ai5vZmZzZXQsSD1qLmVhc2luZyxaPWI7aWYoSCl7dmFyIHE9QS1HO1o9SCgoYi1HKS9xKSpxK0d9UD9MPVAoaixSLFosRyxBKTpMPW8oaixSLFQsWik7YnJlYWt9fXJldHVybiBMfX0sZnVuY3Rpb24oUyxlLHQpe1MuZXhwb3J0cz17ZGVmYXVsdDp0KDIxMCksX19lc01vZHVsZTohMH19LGZ1bmN0aW9uKFMsZSx0KXt0KDIxMSksUy5leHBvcnRzPXQoOTIpLk9iamVjdC5lbnRyaWVzfSxmdW5jdGlvbihTLGUsdCl7dmFyIHI9dCg5MCksaT10KDIxMikoITApO3Ioci5TLCJPYmplY3QiLHtlbnRyaWVzOmZ1bmN0aW9uKGcpe3JldHVybiBpKGcpfX0pfSxmdW5jdGlvbihTLGUsdCl7dmFyIHI9dCgxMDApLGk9dCgxMTApLGg9dCg4NCksZz10KDE2OSkuZjtTLmV4cG9ydHM9ZnVuY3Rpb24odSl7cmV0dXJuIGZ1bmN0aW9uKGEpe2Zvcih2YXIgYz1oKGEpLHg9aShjKSxmPXgubGVuZ3RoLHY9MCxwPVtdLEM7Zj52OylDPXhbdisrXSwoIXJ8fGcuY2FsbChjLEMpKSYmcC5wdXNoKHU/W0MsY1tDXV06Y1tDXSk7cmV0dXJuIHB9fX0sZnVuY3Rpb24oUyxlLHQpe3QucihlKSx0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3Qgcj1uZXcgTWFwO2Z1bmN0aW9uIGkoZyx1PXt9LGE9W10pe2c9Zy50b0xvd2VyQ2FzZSgpO2NvbnN0IGM9ci5nZXQoZyk7aWYoIWMpdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBub2RlOiAke2d9YCk7Y29uc3QgeD1uZXcgYyh1KTtyZXR1cm4gYS5mb3JFYWNoKGY9Pnt4LmFwcGVuZENoaWxkKGYpfSkseH1jb25zdCBoPXtyZWdpc3Rlck5vZGUoZyx1LGE9MTAwKXtpZih1PXUudG9Mb3dlckNhc2UoKSxyLmhhcyh1KSl0aHJvdyBuZXcgVHlwZUVycm9yKGBDYW5ub3QgcmVnaXN0ZXJOb2RlLCAke3V9IGhhcyBiZWVuIHRha2VuLmApO3Iuc2V0KHUsZyksT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZy5wcm90b3R5cGUse25vZGVUeXBlOnt2YWx1ZTphfSx0YWdOYW1lOnt2YWx1ZTp1LnRvVXBwZXJDYXNlKCl9LG5vZGVOYW1lOnt2YWx1ZTp1fSxvd25lckRvY3VtZW50Ont2YWx1ZTpofSxuYW1lc3BhY2VVUkk6e3ZhbHVlOmBodHRwOi8vc3ByaXRlanMuY29tLyR7dX1gfX0pfSxjcmVhdGVFbGVtZW50OmksY3JlYXRlRWxlbWVudE5TKGcsdSl7cmV0dXJuIGkodSl9LGlzU3ByaXRlTm9kZShnKXtyZXR1cm4gci5oYXMoZy50b0xvd2VyQ2FzZSgpKX19O2UuZGVmYXVsdD1ofSxmdW5jdGlvbihTLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiB1fSksdCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IHI9U3ltYm9sKCJ0eXBlIiksaT1TeW1ib2woImJ1YmJsZXMiKSxoPVN5bWJvbCgib3JpZ2luYWxFdmVudCIpLGc9U3ltYm9sKCJkZXRhaWwiKTtjbGFzcyB1e2NvbnN0cnVjdG9yKGMse2J1YmJsZXM6eD1udWxsfT17fSl7aWYodHlwZW9mIGM9PSJzdHJpbmciPyh0aGlzW3JdPWMsdGhpc1tpXT0hIXgpOih0aGlzW3JdPWMudHlwZSx0aGlzW2hdPWMsdGhpc1tpXT14IT1udWxsPyEheDohIWMuYnViYmxlcyxjLmRldGFpbCYmKHRoaXNbZ109Yy5kZXRhaWwpKSwhdGhpc1tyXSl0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIGV2ZW50IHR5cGUuIik7dGhpcy5jYW5jZWxCdWJibGU9ITF9c2V0T3JpZ2luYWxFdmVudChjKXt0aGlzW2hdPWN9Z2V0IG9yaWdpbmFsRXZlbnQoKXtyZXR1cm4gdGhpc1toXX1nZXQgdHlwZSgpe3JldHVybiB0aGlzW3JdfWdldCBidWJibGVzKCl7cmV0dXJuIHRoaXNbaV19Z2V0IGRldGFpbCgpe3JldHVybiB0aGlzW2ddfXN0b3BQcm9wYWdhdGlvbigpe3RoaXMuY2FuY2VsQnViYmxlPSEwfX19LGZ1bmN0aW9uKFMsZSx0KXt0LnIoZSksdC5kKGUsInBhcnNlRmlsdGVyU3RyaW5nIixmdW5jdGlvbigpe3JldHVybiBpfSksdC5kKGUsImFwcGx5RmlsdGVycyIsZnVuY3Rpb24oKXtyZXR1cm4gaH0pO3ZhciByPXQoNzIpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBpKGcpe2lmKGc9Zy50cmltKCksIWd8fGc9PT0ibm9uZSIpcmV0dXJuIG51bGw7Y29uc3QgdT0vXig/Oih1cmx8Ymx1cnxicmlnaHRuZXNzfGNvbnRyYXN0fGRyb3Atc2hhZG93fGdyYXlzY2FsZXxodWUtcm90YXRlfGludmVydHxvcGFjaXR5fHNhdHVyYXRlfHNlcGlhKVwoKFteKCldKig/OlwoLipcKSkqW14oKV0qKVwpKSskL2ksYT1nLm1hdGNoKC8oPzoodXJsfGJsdXJ8YnJpZ2h0bmVzc3xjb250cmFzdHxkcm9wLXNoYWRvd3xncmF5c2NhbGV8aHVlLXJvdGF0ZXxpbnZlcnR8b3BhY2l0eXxzYXR1cmF0ZXxzZXBpYSlcKChbXigpXSooPzpcKC4qXCkpKlteKCldKilcKSkrPy9pZyksYz1bXTtyZXR1cm4gYSYmYS5mb3JFYWNoKHg9Pntjb25zdCBmPXgubWF0Y2godSk7aWYoIWYpdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCBmaXRsZXIgc3RyaW5nLiIpO2xldFssdixwXT1mO3Y9di50b0xvd2VyQ2FzZSgpLHA9cC50cmltKCkubWF0Y2goLyhbXiggKV0rfChbXiggKV0rXCguKlwpKSkoPz1cc3wkKS9nKS5tYXAoKEMsTSk9PntsZXQgbTtyZXR1cm4gdj09PSJ1cmwifHx2PT09ImRyb3Atc2hhZG93IiYmTT09PTM/bT1DOm09T2JqZWN0KHIudG9OdW1iZXIpKEMpLC8lJC8udGVzdChDKSYmKG0vPTEwMCksbX0pLGMucHVzaCh7dHlwZTp2LGFyZ3M6cH0pfSksY31mdW5jdGlvbiBoKGcsdSl7Zy5jbGVhckZpbHRlcigpLHUmJnUuZm9yRWFjaCgoe3R5cGU6YSxhcmdzOmN9KT0+e2xldCB4PWE7eD09PSJkcm9wLXNoYWRvdyI/eD0iZHJvcFNoYWRvdyI6eD09PSJodWUtcm90YXRlIiYmKHg9Imh1ZVJvdGF0ZSIpLGdbeF0oLi4uYyl9KX19LGZ1bmN0aW9uKFMsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIHJ9KSx0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gcihpLGgpe2lmKCFoKXJldHVybjtjb25zdCBnPWkuZ2V0TGlzdGVuZXJzKCJiZWZvcmVyZW5kZXIiKSx1PWkuZ2V0TGlzdGVuZXJzKCJhZnRlcnJlbmRlciIpO2cubGVuZ3RoJiYhaC5iZWZvcmVSZW5kZXI/aC5iZWZvcmVSZW5kZXI9YT0+e2kuZGlzcGF0Y2hFdmVudCh7dHlwZToiYmVmb3JlcmVuZGVyIixkZXRhaWw6e2NvbnRleHQ6YX19KX06Zy5sZW5ndGh8fChoLmJlZm9yZVJlbmRlcj1udWxsKSx1Lmxlbmd0aCYmIWguYWZ0ZXJSZW5kZXI/aC5hZnRlclJlbmRlcj1hPT57aS5kaXNwYXRjaEV2ZW50KHt0eXBlOiJhZnRlcnJlbmRlciIsZGV0YWlsOntjb250ZXh0OmF9fSl9OnUubGVuZ3RofHwoaC5hZnRlclJlbmRlcj1udWxsKX19LGZ1bmN0aW9uKFMsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIGN9KTt2YXIgcj10KDEyKSxpPXQoMjE4KSxoPXQoNzApLGc9dCgyMTMpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCB1PVN5bWJvbCgiYW1vdW50IiksYT1TeW1ib2woIm1lc2hDbG91ZCIpO2NsYXNzIGMgZXh0ZW5kcyBoLmRlZmF1bHR7Y29uc3RydWN0b3IoZix2PTEpe3N1cGVyKCksdGhpcy5tZXNoTm9kZT1mLGYuY29ubmVjdCh0aGlzKSx0aGlzW3VdPXYsdGhpc1thXT1udWxsfWdldCBtZXNoQ2xvdWQoKXtjb25zdCBmPXRoaXMubWVzaE5vZGUsdj10aGlzW3VdO3JldHVybiF0aGlzW2FdJiZmLm1lc2gmJih0aGlzW2FdPW5ldyByLk1lc2hDbG91ZChmLm1lc2gsdikpLHRoaXNbYV19Z2V0IGlzVmlzaWJsZSgpe3JldHVybiEhdGhpcy5tZXNoTm9kZSYmdGhpcy5tZXNoTm9kZS5pc1Zpc2libGV9Z2V0IGFtb3VudCgpe3JldHVybiB0aGlzW3VdfXNldCBhbW91bnQoZil7dGhpc1t1XT1mLHRoaXNbYV0mJih0aGlzW2FdLmFtb3VudD1mKX1icmlnaHRuZXNzKGYsdil7dGhpcy5tZXNoQ2xvdWQmJih0aGlzLm1lc2hDbG91ZC5icmlnaHRuZXNzKGYsdiksdGhpcy5mb3JjZVVwZGF0ZSgpKX1jb250cmFzdChmLHYpe3RoaXMubWVzaENsb3VkJiYodGhpcy5tZXNoQ2xvdWQuY29udHJhc3QoZix2KSx0aGlzLmZvcmNlVXBkYXRlKCkpfWRlbGV0ZShmKXt0aGlzLm1lc2hDbG91ZCYmKHRoaXMubWVzaENsb3VkLmRlbGV0ZShmKSx0aGlzW3VdLS0sdGhpcy5mb3JjZVVwZGF0ZSgpKX1kcmF3KGY9W10pe2lmKHN1cGVyLmRyYXcoZiksdGhpcy5tZXNoQ2xvdWQpe2lmKHRoaXMucHJvZ3JhbSl7dGhpcy5tZXNoQ2xvdWQuc2V0UHJvZ3JhbSh0aGlzLnByb2dyYW0pO2NvbnN0IHY9dGhpcy5zaGFkZXJBdHRyczt2JiZPYmplY3QuZW50cmllcyh2KS5mb3JFYWNoKChbQyxNXSk9Pnt0aGlzLm1lc2hDbG91ZC5tZXNoLnNldEF0dHJpYnV0ZShDLE0pfSk7Y29uc3QgcD10aGlzLnVuaWZvcm1zO2lmKHRoaXMudW5pZm9ybXMpe2NvbnN0IEM9e307T2JqZWN0LmVudHJpZXMocCkuZm9yRWFjaCgoW00sbV0pPT57dHlwZW9mIG09PSJmdW5jdGlvbiImJihtPW0odGhpcyxNKSksQ1tNXT1tfSksdGhpcy5tZXNoQ2xvdWQubWVzaC5zZXRVbmlmb3JtcyhDKX19dGhpcy5tZXNoTm9kZS50ZXh0dXJlSW1hZ2UmJk9iamVjdChpLmRyYXdUZXh0dXJlKSh0aGlzLm1lc2hOb2RlLHRoaXMubWVzaE5vZGUubWVzaCksZi5wdXNoKHRoaXMubWVzaENsb3VkKX1yZXR1cm4gZn1nZXRUcmFuc2Zvcm0oZil7aWYodGhpcy5tZXNoQ2xvdWQpcmV0dXJuIHRoaXMubWVzaENsb3VkLmdldFRyYW5zZm9ybShmKX1ncmF5c2NhbGUoZix2KXt0aGlzLm1lc2hDbG91ZCYmKHRoaXMubWVzaENsb3VkLmdyYXlzY2FsZShmLHYpLHRoaXMuZm9yY2VVcGRhdGUoKSl9aHVlUm90YXRlKGYsdil7dGhpcy5tZXNoQ2xvdWQmJih0aGlzLm1lc2hDbG91ZC5odWVSb3RhdGUoZix2KSx0aGlzLmZvcmNlVXBkYXRlKCkpfWludmVydChmLHYpe3RoaXMubWVzaENsb3VkJiYodGhpcy5tZXNoQ2xvdWQuaW52ZXJ0KGYsdiksdGhpcy5mb3JjZVVwZGF0ZSgpKX1pc1BvaW50Q29sbGlzaW9uKGYsdil7aWYoIXRoaXMubWVzaENsb3VkKXJldHVybiExO2NvbnN0IHA9dGhpcy5hdHRyaWJ1dGVzLnBvaW50ZXJFdmVudHM7aWYocD09PSJub25lInx8cCE9PSJhbGwiJiYhdGhpcy5pc1Zpc2libGUpcmV0dXJuITE7bGV0IEM9ImJvdGgiO3A9PT0idmlzaWJsZUZpbGwiJiYoQz0iZmlsbCIpLHA9PT0idmlzaWJsZVN0cm9rZSImJihDPSJzdHJva2UiKTtmb3IobGV0IE09MDtNPHRoaXNbdV07TSsrKWlmKCF0aGlzLm1lc2hDbG91ZC5pc1BvaW50Q29sbGlzaW9uKE0sW2Ysdl0sQykpcmV0dXJuITE7cmV0dXJuITB9c2V0T3BhY2l0eShmLHYpe3RoaXMubWVzaENsb3VkJiYodGhpcy5tZXNoQ2xvdWQub3BhY2l0eShmLHYpLHRoaXMuZm9yY2VVcGRhdGUoKSl9cm90YXRlKGYsdixbcCxDXT1bMCwwXSl7Y29uc3QgTT1NYXRoLlBJKnYvMTgwO2lmKHRoaXMubWVzaENsb3VkKXtjb25zdHt4Om0seX09dGhpcy5tZXNoTm9kZS5hdHRyaWJ1dGVzO3RoaXMubWVzaENsb3VkLnJvdGF0ZShmLE0sW3ArbSxDK3ldKSx0aGlzLmZvcmNlVXBkYXRlKCl9fXNhdHVyYXRlKGYsdil7dGhpcy5tZXNoQ2xvdWQmJih0aGlzLm1lc2hDbG91ZC5zYXR1cmF0ZShmLHYpLHRoaXMuZm9yY2VVcGRhdGUoKSl9c2NhbGUoZixbdixwPXZdLFtDLE1dPVswLDBdKXtpZih0aGlzLm1lc2hDbG91ZCl7Y29uc3R7eDptLHl9PXRoaXMubWVzaE5vZGUuYXR0cmlidXRlcyxuPTFlLTU7TWF0aC5hYnModik8biYmKHY9MS92PjA/bjotbiksTWF0aC5hYnMocCk8biYmKHA9MS9wPjA/bjotbiksdGhpcy5tZXNoQ2xvdWQuc2NhbGUoZixbdixwXSxbQyttLE0reV0pLHRoaXMuZm9yY2VVcGRhdGUoKX19c2V0Q29sb3JUcmFuc2Zvcm0oZix2KXt0aGlzLm1lc2hDbG91ZCYmKHRoaXMubWVzaENsb3VkLnNldENvbG9yVHJhbnNmb3JtKGYsdiksdGhpcy5mb3JjZVVwZGF0ZSgpKX1zZXRGaWxsQ29sb3IoZix2KXt0aGlzLm1lc2hDbG91ZCYmKEFycmF5LmlzQXJyYXkodikmJih2PVsuLi52XSx2WzBdLz0yNTUsdlsxXS89MjU1LHZbMl0vPTI1NSksdGhpcy5tZXNoQ2xvdWQuc2V0RmlsbENvbG9yKGYsdiksdGhpcy5mb3JjZVVwZGF0ZSgpKX1zZXBpYShmLHYpe3RoaXMubWVzaENsb3VkJiYodGhpcy5tZXNoQ2xvdWQuc2VwaWEoZix2KSx0aGlzLmZvcmNlVXBkYXRlKCkpfXNldFJlc29sdXRpb24oe3dpZHRoOmYsaGVpZ2h0OnZ9KXtzdXBlci5zZXRSZXNvbHV0aW9uKHt3aWR0aDpmLGhlaWdodDp2fSksdGhpcy5tZXNoTm9kZS5zZXRSZXNvbHV0aW9uKHt3aWR0aDpmLGhlaWdodDp2fSl9c2V0U3Ryb2tlQ29sb3IoZix2KXt0aGlzLm1lc2hDbG91ZCYmKEFycmF5LmlzQXJyYXkodikmJih2PVsuLi52XSx2WzBdLz0yNTUsdlsxXS89MjU1LHZbMl0vPTI1NSksdGhpcy5tZXNoQ2xvdWQuc2V0U3Ryb2tlQ29sb3IoZix2KSx0aGlzLmZvcmNlVXBkYXRlKCkpfXNldFRyYW5zZm9ybShmLHYpe3RoaXMubWVzaENsb3VkJiYodGhpcy5tZXNoQ2xvdWQuc2V0VHJhbnNmb3JtKGYsdiksdGhpcy5mb3JjZVVwZGF0ZSgpKX1za2V3KGYsW3YscD12XSxbQyxNXT1bMCwwXSl7aWYodGhpcy5tZXNoQ2xvdWQpe2NvbnN0e3g6bSx5fT10aGlzLm1lc2hOb2RlLmF0dHJpYnV0ZXM7dGhpcy5tZXNoQ2xvdWQuc2tldyhmLFt2LHBdLFtDK20sTSt5XSksdGhpcy5mb3JjZVVwZGF0ZSgpfX10cmFuc2Zvcm0oZix2KXt0aGlzLm1lc2hDbG91ZCYmKHRoaXMubWVzaENsb3VkLnRyYW5zZm9ybShmLHYpLHRoaXMuZm9yY2VVcGRhdGUoKSl9dHJhbnNmb3JtQ29sb3IoZix2KXt0aGlzLm1lc2hDbG91ZCYmKHRoaXMubWVzaENsb3VkLnRyYW5zZm9ybUNvbG9yKGYsdiksdGhpcy5mb3JjZVVwZGF0ZSgpKX10cmFuc2xhdGUoZixbdixwXSl7dGhpcy5tZXNoQ2xvdWQmJih0aGlzLm1lc2hDbG91ZC50cmFuc2xhdGUoZixbdixwXSksdGhpcy5mb3JjZVVwZGF0ZSgpKX11cGRhdGVNZXNoKCl7dGhpc1thXSYmKHRoaXNbYV0ubWVzaD10aGlzLm1lc2hOb2RlLm1lc2gsdGhpcy5mb3JjZVVwZGF0ZSgpKX19Zy5kZWZhdWx0LnJlZ2lzdGVyTm9kZShjLCJjbG91ZCIpfSxmdW5jdGlvbihTLGUsdCl7dC5yKGUpLHQuZChlLCJsb2FkVGV4dHVyZSIsZnVuY3Rpb24oKXtyZXR1cm4gZ30pLHQuZChlLCJhcHBseVRleHR1cmUiLGZ1bmN0aW9uKCl7cmV0dXJuIHV9KSx0LmQoZSwiY3JlYXRlVGV4dHVyZSIsZnVuY3Rpb24oKXtyZXR1cm4gY30pLHQuZChlLCJkZWxldGVUZXh0dXJlIixmdW5jdGlvbigpe3JldHVybiB4fSksdC5kKGUsImRyYXdUZXh0dXJlIixmdW5jdGlvbigpe3JldHVybiB2fSksdC5kKGUsImxvYWRGcmFtZXMiLGZ1bmN0aW9uKCl7cmV0dXJuIHB9KTt2YXIgcj10KDEyKSxpPXQoNzIpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCBoPXt9O2Z1bmN0aW9uIGcoQyxNKXtpZihoW0NdKXJldHVybiBoW0NdO2NvbnN0IG09ci5FTlYubG9hZEltYWdlKEMse2FsaWFzOk0sdXNlSW1hZ2VCaXRtYXA6ITF9KTtyZXR1cm4gbT8/Q31hc3luYyBmdW5jdGlvbiB1KEMsTSxtKXtsZXQgeT1NO2lmKHR5cGVvZiBNPT0ic3RyaW5nIiYmKHk9ZyhNKSkseSYmdHlwZW9mIHkudGhlbj09ImZ1bmN0aW9uIiYmKHk9YXdhaXQgeSksTT09PUMuYXR0cmlidXRlcy50ZXh0dXJlKXt5JiZ5LmltYWdlJiYoeS5zb3VyY2VSZWN0JiYoQy5hdHRyaWJ1dGVzLnNvdXJjZVJlY3Q9eS5zb3VyY2VSZWN0KSxDLnRleHR1cmVJbWFnZVJvdGF0ZWQ9ISF5LnJvdGF0ZWQseT15LmltYWdlKTtjb25zdHt3aWR0aDpuLGhlaWdodDpvLHRleHR1cmVSZWN0OnN9PUMuYXR0cmlidXRlcyxsPUMudGV4dHVyZUltYWdlO0MudGV4dHVyZUltYWdlPXksbSYmbCE9PXkmJiFzJiYobj09bnVsbHx8bz09bnVsbCkmJkMudXBkYXRlQ29udG91cnMoKSxDLmZvcmNlVXBkYXRlKCl9cmV0dXJuIHl9Y29uc3QgYT1TeW1ib2woInRleHR1cmVNYXAiKTtmdW5jdGlvbiBjKEMsTSl7aWYoTVthXT1NW2FdfHxuZXcgTWFwLE1bYV0uaGFzKEMpKXJldHVybiBNW2FdLmdldChDKTtjb25zdCBtPU0uY3JlYXRlVGV4dHVyZShDKTtyZXR1cm4hL15ibG9iOi8udGVzdChDLnNyYykmJnR5cGVvZiBDLmdldENvbnRleHQhPSJmdW5jdGlvbiImJk1bYV0uc2V0KEMsbSksbX1mdW5jdGlvbiB4KEMsTSl7aWYoTVthXSYmTVthXS5oYXMoQykpe2NvbnN0IG09TVthXS5nZXQoQyk7cmV0dXJuIE0uZGVsZXRlVGV4dHVyZShtKSxNW2FdLmRlbGV0ZShDKSwhMH1yZXR1cm4hMX1jb25zdCBmPVN5bWJvbCgidGV4dHVyZUNvbnRleHQiKTtmdW5jdGlvbiB2KEMsTSl7Y29uc3QgbT1DLnRleHR1cmVJbWFnZSBpbnN0YW5jZW9mIFN0cmluZz9TdHJpbmcoQy50ZXh0dXJlSW1hZ2UpOkMudGV4dHVyZUltYWdlLHk9Qy50ZXh0dXJlSW1hZ2VSb3RhdGVkLG49TS50ZXh0dXJlLG89Qy5yZW5kZXJlcjtpZihtKXtjb25zdCBzPUMub3JpZ2luYWxDb250ZW50UmVjdDtsZXQgbD1DLmF0dHJpYnV0ZXMudGV4dHVyZVJlY3Q7Y29uc3QgRT1DLmF0dHJpYnV0ZXMudGV4dHVyZVJlcGVhdCxUPUMuYXR0cmlidXRlcy5zb3VyY2VSZWN0O2lmKCFufHxDW2ZdJiZDW2ZdIT09b3x8bi5pbWFnZSE9PW18fG4ub3B0aW9ucy5yZXBlYXQhPT1FfHwhT2JqZWN0KGkuY29tcGFyZVZhbHVlKShuLm9wdGlvbnMucmVjdCxsKXx8IU9iamVjdChpLmNvbXBhcmVWYWx1ZSkobi5vcHRpb25zLnNyY1JlY3QsVCkpe2NvbnN0IGI9YyhtLG8pO2w/KGxbMF0rPXNbMF0sbFsxXSs9c1sxXSk6bD1zO2xldCBJPW51bGw7biYmIW9bYV0uaGFzKG4uaW1hZ2UpJiYoIW4ub3B0aW9uc3x8IW4ub3B0aW9ucy5oaWRkZW4pJiYoST1NLnVuaWZvcm1zLnVfdGV4U2FtcGxlciksTS5zZXRUZXh0dXJlKGIse3JlY3Q6bCxyZXBlYXQ6RSxzcmNSZWN0OlQscm90YXRlZDp5fSksSSYmSS5kZWxldGUmJkkuZGVsZXRlKCksQ1tmXT1vfX1lbHNlIGlmKG4pe2xldCBzPW51bGw7IW9bYV0uaGFzKG4uaW1hZ2UpJiYoIW4ub3B0aW9uc3x8IW4ub3B0aW9ucy5oaWRkZW4pJiYocz1NLnVuaWZvcm1zLnVfdGV4U2FtcGxlciksTS5zZXRUZXh0dXJlKG51bGwpLHMmJnMuZGVsZXRlJiZzLmRlbGV0ZSgpfX1hc3luYyBmdW5jdGlvbiBwKEMsTSl7dHlwZW9mIE09PSJzdHJpbmciJiYoTT1hd2FpdChhd2FpdCBmZXRjaChNLHttZXRob2Q6IkdFVCIsbW9kZToiY29ycyIsY2FjaGU6ImRlZmF1bHQifSkpLmpzb24oKSk7Y29uc3QgbT1hd2FpdCBnKEMpLHk9TS5mcmFtZXM7cmV0dXJuIE9iamVjdC5lbnRyaWVzKHkpLmZvckVhY2goKFtuLG9dKT0+e2NvbnN0e3g6cyx5OmwsdzpFLGg6VH09by5mcmFtZTtsZXQgYj1bcyxsLEUsVF07Y29uc3QgST1vLnJvdGF0ZWQ7SSYmKGI9W2JbMF0sYlsxXSxiWzNdLGJbMl1dKSxoW25dPXtpbWFnZTptLHNvdXJjZVJlY3Q6Yixyb3RhdGVkOkl9fSksbX19LGZ1bmN0aW9uKFMsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIHB9KTt2YXIgcj10KDEpLGk9dCgxMiksaD10KDcwKSxnPXQoMjIwKSx1PXQoMjIxKSxhPXQoMjIyKSxjPXQoMjEzKSx4PXQoMjIzKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gZihDLE0sbSl7cmV0dXJuIE0gaW4gQz9PYmplY3QuZGVmaW5lUHJvcGVydHkoQyxNLHt2YWx1ZTptLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6Q1tNXT1tLEN9Y29uc3Qgdj1TeW1ib2woIm1lc2giKTtjbGFzcyBwIGV4dGVuZHMgaC5kZWZhdWx0e2NvbnN0cnVjdG9yKE09e30pe3N1cGVyKE0pfWdldCBib3JkZXJTaXplKCl7Y29uc3R7cGFkZGluZ1RvcDpNLHBhZGRpbmdSaWdodDptLHBhZGRpbmdCb3R0b206eSxwYWRkaW5nTGVmdDpuLGJvcmRlcldpZHRoOm99PXRoaXMuYXR0cmlidXRlcyxbcyxsXT10aGlzLmNvbnRlbnRTaXplO3JldHVybltuK3MrbStvLE0rbCt5K29dfWdldCBjbGllbnRTaXplKCl7Y29uc3R7cGFkZGluZ1RvcDpNLHBhZGRpbmdSaWdodDptLHBhZGRpbmdCb3R0b206eSxwYWRkaW5nTGVmdDpufT10aGlzLmF0dHJpYnV0ZXMsW28sc109dGhpcy5jb250ZW50U2l6ZTtyZXR1cm5bbitvK20sTStzK3ldfWdldCBjb250ZW50U2l6ZSgpe2xldHt3aWR0aDpNLGhlaWdodDptLGJveFNpemluZzp5LHBhZGRpbmdUb3A6bixwYWRkaW5nUmlnaHQ6byxwYWRkaW5nQm90dG9tOnMscGFkZGluZ0xlZnQ6bH09dGhpcy5hdHRyaWJ1dGVzO2lmKE09TXx8MCxtPW18fDAseT09PSJib3JkZXItYm94Iil7Y29uc3QgRT0yKnRoaXMuYXR0cmlidXRlcy5ib3JkZXJXaWR0aDtNLT1FK28rbCxtLT1FK24rcyxNPU1hdGgubWF4KDAsTSksbT1NYXRoLm1heCgwLG0pfXJldHVybltNLG1dfWdldCBoYXNCb3JkZXIoKXtyZXR1cm4gdGhpcy5hdHRyaWJ1dGVzLmJvcmRlcldpZHRoPjB9Z2V0IGlzVmlzaWJsZSgpe2NvbnN0W00sbV09dGhpcy5ib3JkZXJTaXplO3JldHVybiBNPjAmJm0+MH1nZXQgbWVzaCgpe2lmKHRoaXMuYXR0cmlidXRlcy5kaXNwbGF5PT09Im5vbmUiKXJldHVybiBudWxsO2NvbnN0IE09dGhpcy5jbGllbnRCb3g7aWYoTSl7bGV0IG09dGhpc1t2XTtpZihtKW0uYm94IT09TSYmKG0uY29udG91cnM9TS5jb250b3VycyxtLmJveD1NKTtlbHNle209bmV3IGkuTWVzaDJEKE0pLG0uYm94PU07Y29uc3Qgbj10aGlzLmF0dHJpYnV0ZXMuYmdjb2xvcjtpZihPYmplY3QodS5zZXRGaWxsQ29sb3IpKG0se2NvbG9yOm59KSx0aGlzLmhhc0JvcmRlcil7Y29uc3R7Ym9yZGVyQ29sb3I6cyxib3JkZXJXaWR0aDpsLGJvcmRlckRhc2g6RSxib3JkZXJEYXNoT2Zmc2V0OlR9PXRoaXMuYXR0cmlidXRlcztPYmplY3QodS5zZXRTdHJva2VDb2xvcikobSx7Y29sb3I6cyxsaW5lV2lkdGg6bCxsaW5lRGFzaDpFLGxpbmVEYXNoT2Zmc2V0OlR9KX10aGlzW3ZdPW07Y29uc3Qgbz10aGlzLmF0dHJpYnV0ZXMuY2xpcFBhdGg7byYmdGhpc1t2XS5zZXRDbGlwUGF0aChvKX1jb25zdCB5PXRoaXMub3BhY2l0eTtyZXR1cm4gbS5nZXRPcGFjaXR5KCkhPT15JiZtLnNldE9wYWNpdHkoeSksbS5zZXRUcmFuc2Zvcm0oLi4udGhpcy5yZW5kZXJNYXRyaXgpLG19cmV0dXJuIG51bGx9Z2V0IG9mZnNldFNpemUoKXtjb25zdHtwYWRkaW5nVG9wOk0scGFkZGluZ1JpZ2h0Om0scGFkZGluZ0JvdHRvbTp5LHBhZGRpbmdMZWZ0Om4sYm9yZGVyV2lkdGg6b309dGhpcy5hdHRyaWJ1dGVzLFtzLGxdPXRoaXMuY29udGVudFNpemUsRT0yKm87cmV0dXJuW24rcyttK0UsTStsK3krRV19Z2V0IG9yaWdpbmFsQ2xpZW50UmVjdCgpe2lmKHRoaXMubWVzaCl7Y29uc3QgTT10aGlzLm1lc2guYm91bmRpbmdCb3g7cmV0dXJuW01bMF1bMF0sTVswXVsxXSxNWzFdWzBdLU1bMF1bMF0sTVsxXVsxXS1NWzBdWzFdXX1yZXR1cm5bMCwwLDAsMF19Z2V0IG9yaWdpbmFsQ29udGVudFJlY3QoKXtjb25zdFtNLG0seSxuXT10aGlzLm9yaWdpbmFsQ2xpZW50UmVjdCxvPXRoaXMuYXR0cmlidXRlcy5wYWRkaW5nO3JldHVybltNK29bMF0sbStvWzFdLHktb1swXS1vWzJdLG4tb1sxXS1vWzNdXX1nZXRCb3VuZGluZ0NsaWVudFJlY3QoKXtsZXQgTT10aGlzLnJlbmRlck1hdHJpeDt0aGlzLmxheWVyJiZ0aGlzLmxheWVyLmxheWVyVHJhbnNmb3JtSW52ZXJ0JiYoTT1yLm1hdDJkLm11bHRpcGx5KEFycmF5Lm9mKDAsMCwwLDAsMCwwKSx0aGlzLmxheWVyLnRyYW5zZm9ybU1hdHJpeCxNKSk7bGV0IG09bnVsbDtpZih0aGlzLm1lc2gpe209Wy4uLnRoaXMubWVzaC5ib3VuZGluZ0JveF07Y29uc3QgeT10aGlzLmF0dHJpYnV0ZXMuYm9yZGVyV2lkdGg7eSYmKG1bMF09W21bMF1bMF0teSxtWzBdWzFdLXldLG1bMV09W21bMV1bMF0reSxtWzFdWzFdK3ldKX1yZXR1cm4gT2JqZWN0KHguZGVmYXVsdCkobSxNKX1vblByb3BlcnR5Q2hhbmdlKE0sbSx5KXtpZihzdXBlci5vblByb3BlcnR5Q2hhbmdlKE0sbSx5KSwoTT09PSJhbmNob3JYInx8TT09PSJhbmNob3JZInx8TT09PSJib3hTaXppbmcifHxNPT09IndpZHRoInx8TT09PSJoZWlnaHQifHxNPT09ImJvcmRlcldpZHRoInx8TT09PSJwYWRkaW5nTGVmdCJ8fE09PT0icGFkZGluZ1JpZ2h0Inx8TT09PSJwYWRkaW5nVG9wInx8TT09PSJwYWRkaW5nQm90dG9tInx8L15ib3JkZXIoVG9wTGVmdHxUb3BSaWdodHxCb3R0b21SaWdodHxCb3R0b21MZWZ0KVJhZGl1cyQvLnRlc3QoTSkpJiZ0aGlzLnVwZGF0ZUNvbnRvdXJzKCksdGhpc1t2XSYmTT09PSJjbGlwUGF0aCImJnRoaXNbdl0uc2V0Q2xpcFBhdGgobSksdGhpc1t2XSYmTT09PSJiZ2NvbG9yIiYmT2JqZWN0KHUuc2V0RmlsbENvbG9yKSh0aGlzW3ZdLHtjb2xvcjptfSksdGhpc1t2XSYmKE09PT0iYm9yZGVyQ29sb3IifHxNPT09ImJvcmRlcldpZHRoInx8TT09PSJib3JkZXJEYXNoInx8TT09PSJib3JkZXJEYXNoT2Zmc2V0Iikpe2NvbnN0e2JvcmRlckNvbG9yOm4sYm9yZGVyV2lkdGg6byxib3JkZXJEYXNoOnMsYm9yZGVyRGFzaE9mZnNldDpsfT10aGlzLmF0dHJpYnV0ZXM7T2JqZWN0KHUuc2V0U3Ryb2tlQ29sb3IpKHRoaXNbdl0se2NvbG9yOm4sbGluZVdpZHRoOm8sbGluZURhc2g6bz9zOjAsbGluZURhc2hPZmZzZXQ6bH0pfX11cGRhdGVDb250b3Vycygpe2NvbnN0e2FuY2hvclg6TSxhbmNob3JZOm0sYm9yZGVyV2lkdGg6eSxib3JkZXJSYWRpdXM6bn09dGhpcy5hdHRyaWJ1dGVzLFtvLHNdPXRoaXMuYm9yZGVyU2l6ZSxsPXRoaXMub2Zmc2V0U2l6ZSxFPS41KnksVD0tTSpsWzBdK0UsYj0tbSpsWzFdK0U7dGhpcy5jbGllbnRCb3g9bmV3IGkuRmlndXJlMkQsT2JqZWN0KGEuY3JlYXRlUmFkaXVzQm94KSh0aGlzLmNsaWVudEJveCxbVCxiLG8sc10sbil9fWYocCwiQXR0ciIsZy5kZWZhdWx0KSxjLmRlZmF1bHQucmVnaXN0ZXJOb2RlKHAsImJsb2NrIil9LGZ1bmN0aW9uKFMsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIHh9KTt2YXIgcj10KDcxKSxpPXQoNzIpLGg9dCgyMjEpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCBnPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZSIpLHU9U3ltYm9sLmZvcigic3ByaXRlanNfZ2V0QXR0cmlidXRlIiksYT1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGVEZWZhdWx0IiksYz1TeW1ib2wuZm9yKCJzcHJpdGVqc19kZWNsYXJlQWxpYXMiKTtjbGFzcyB4IGV4dGVuZHMgci5kZWZhdWx0e2NvbnN0cnVjdG9yKHYpe3N1cGVyKHYpLHRoaXNbYV0oe2FuY2hvclg6MCxhbmNob3JZOjAsd2lkdGg6dm9pZCAwLGhlaWdodDp2b2lkIDAsYm9yZGVyV2lkdGg6MCxib3JkZXJDb2xvcjoicmdiYSgwLDAsMCwxKSIsYm9yZGVyRGFzaDp2b2lkIDAsYm9yZGVyRGFzaE9mZnNldDowLGJvcmRlclRvcExlZnRSYWRpdXM6WzAsMF0sYm9yZGVyVG9wUmlnaHRSYWRpdXM6WzAsMF0sYm9yZGVyQm90dG9tUmlnaHRSYWRpdXM6WzAsMF0sYm9yZGVyQm90dG9tTGVmdFJhZGl1czpbMCwwXSxiZ2NvbG9yOiJyZ2JhKDAsMCwwLDApIixwYWRkaW5nVG9wOjAscGFkZGluZ1JpZ2h0OjAscGFkZGluZ0JvdHRvbTowLHBhZGRpbmdMZWZ0OjAsYm94U2l6aW5nOiJjb250ZW50LWJveCIsY2xpcFBhdGg6dm9pZCAwfSksdGhpc1tjXSgiYW5jaG9yIiwic2l6ZSIsImJvcmRlciIsImJvcmRlclJhZGl1cyIsInBhZGRpbmciKX1nZXQgYW5jaG9yWCgpe3JldHVybiB0aGlzW3VdKCJhbmNob3JYIil9c2V0IGFuY2hvclgodil7dGhpc1tnXSgiYW5jaG9yWCIsT2JqZWN0KGkudG9OdW1iZXIpKHYpKX1nZXQgYW5jaG9yWSgpe3JldHVybiB0aGlzW3VdKCJhbmNob3JZIil9c2V0IGFuY2hvclkodil7dGhpc1tnXSgiYW5jaG9yWSIsT2JqZWN0KGkudG9OdW1iZXIpKHYpKX1nZXQgYW5jaG9yKCl7cmV0dXJuW3RoaXMuYW5jaG9yWCx0aGlzLmFuY2hvclldfXNldCBhbmNob3Iodil7dj1PYmplY3QoaS50b0FycmF5KSh2KSxBcnJheS5pc0FycmF5KHYpfHwodj1bdix2XSksdGhpcy5hbmNob3JYPXZbMF0sdGhpcy5hbmNob3JZPXZbMV19Z2V0IHdpZHRoKCl7cmV0dXJuIHRoaXNbdV0oIndpZHRoIil9c2V0IHdpZHRoKHYpe3RoaXNbZ10oIndpZHRoIixPYmplY3QoaS50b051bWJlcikodikpfWdldCBoZWlnaHQoKXtyZXR1cm4gdGhpc1t1XSgiaGVpZ2h0Iil9c2V0IGhlaWdodCh2KXt0aGlzW2ddKCJoZWlnaHQiLE9iamVjdChpLnRvTnVtYmVyKSh2KSl9Z2V0IHNpemUoKXtyZXR1cm5bdGhpcy53aWR0aCx0aGlzLmhlaWdodF19c2V0IHNpemUodil7dj1PYmplY3QoaS50b0FycmF5KSh2KSxBcnJheS5pc0FycmF5KHYpfHwodj1bdix2XSksdGhpcy53aWR0aD12WzBdLHRoaXMuaGVpZ2h0PXZbMV19Z2V0IGJvcmRlcldpZHRoKCl7cmV0dXJuIHRoaXNbdV0oImJvcmRlcldpZHRoIil9c2V0IGJvcmRlcldpZHRoKHYpe3RoaXNbZ10oImJvcmRlcldpZHRoIixPYmplY3QoaS50b051bWJlcikodikpfWdldCBib3JkZXJDb2xvcigpe3JldHVybiB0aGlzW3VdKCJib3JkZXJDb2xvciIpfXNldCBib3JkZXJDb2xvcih2KXt0aGlzW2ddKCJib3JkZXJDb2xvciIsT2JqZWN0KGgucGFyc2VDb2xvcikodikpfWdldCBib3JkZXIoKXtyZXR1cm5bdGhpcy5ib3JkZXJXaWR0aCx0aGlzLmJvcmRlckNvbG9yXX1zZXQgYm9yZGVyKHYpe3Y9T2JqZWN0KGkudG9BcnJheSkodiksQXJyYXkuaXNBcnJheSh2KXx8KHY9W3ZdKSx0aGlzLmJvcmRlcldpZHRoPXZbMF0sdlsxXSE9bnVsbCYmKHRoaXMuYm9yZGVyQ29sb3I9dlsxXSl9Z2V0IGJvcmRlckRhc2goKXtyZXR1cm4gdGhpc1t1XSgiYm9yZGVyRGFzaCIpfXNldCBib3JkZXJEYXNoKHYpe3Y9T2JqZWN0KGkudG9BcnJheSkodiwhMCksdiE9bnVsbCYmIUFycmF5LmlzQXJyYXkodikmJih2PVt2XSksdGhpc1tnXSgiYm9yZGVyRGFzaCIsdj92Lm1hcChpLnRvTnVtYmVyKTpudWxsKX1nZXQgYm9yZGVyRGFzaE9mZnNldCgpe3JldHVybiB0aGlzW3VdKCJib3JkZXJEYXNoT2Zmc2V0Iil9c2V0IGJvcmRlckRhc2hPZmZzZXQodil7dGhpc1tnXSgiYm9yZGVyRGFzaE9mZnNldCIsT2JqZWN0KGkudG9OdW1iZXIpKHYpKX1nZXQgYm9yZGVyVG9wTGVmdFJhZGl1cygpe3JldHVybiB0aGlzW3VdKCJib3JkZXJUb3BMZWZ0UmFkaXVzIil9c2V0IGJvcmRlclRvcExlZnRSYWRpdXModil7dj1PYmplY3QoaS50b0FycmF5KSh2LCEwKSxBcnJheS5pc0FycmF5KHYpfHwodj1bdix2XSksdGhpc1tnXSgiYm9yZGVyVG9wTGVmdFJhZGl1cyIsdi5tYXAoaS50b051bWJlcikpfWdldCBib3JkZXJUb3BSaWdodFJhZGl1cygpe3JldHVybiB0aGlzW3VdKCJib3JkZXJUb3BSaWdodFJhZGl1cyIpfXNldCBib3JkZXJUb3BSaWdodFJhZGl1cyh2KXt2PU9iamVjdChpLnRvQXJyYXkpKHYsITApLEFycmF5LmlzQXJyYXkodil8fCh2PVt2LHZdKSx0aGlzW2ddKCJib3JkZXJUb3BSaWdodFJhZGl1cyIsdi5tYXAoaS50b051bWJlcikpfWdldCBib3JkZXJCb3R0b21SaWdodFJhZGl1cygpe3JldHVybiB0aGlzW3VdKCJib3JkZXJCb3R0b21SaWdodFJhZGl1cyIpfXNldCBib3JkZXJCb3R0b21SaWdodFJhZGl1cyh2KXt2PU9iamVjdChpLnRvQXJyYXkpKHYsITApLEFycmF5LmlzQXJyYXkodil8fCh2PVt2LHZdKSx0aGlzW2ddKCJib3JkZXJCb3R0b21SaWdodFJhZGl1cyIsdi5tYXAoaS50b051bWJlcikpfWdldCBib3JkZXJCb3R0b21MZWZ0UmFkaXVzKCl7cmV0dXJuIHRoaXNbdV0oImJvcmRlckJvdHRvbUxlZnRSYWRpdXMiKX1zZXQgYm9yZGVyQm90dG9tTGVmdFJhZGl1cyh2KXt2PU9iamVjdChpLnRvQXJyYXkpKHYsITApLEFycmF5LmlzQXJyYXkodil8fCh2PVt2LHZdKSx0aGlzW2ddKCJib3JkZXJCb3R0b21MZWZ0UmFkaXVzIix2Lm1hcChpLnRvTnVtYmVyKSl9Z2V0IGJvcmRlclJhZGl1cygpe3JldHVyblsuLi50aGlzLmJvcmRlclRvcExlZnRSYWRpdXMsLi4udGhpcy5ib3JkZXJUb3BSaWdodFJhZGl1cywuLi50aGlzLmJvcmRlckJvdHRvbVJpZ2h0UmFkaXVzLC4uLnRoaXMuYm9yZGVyQm90dG9tTGVmdFJhZGl1c119c2V0IGJvcmRlclJhZGl1cyh2KXtpZih2PU9iamVjdChpLnRvQXJyYXkpKHYpLCFBcnJheS5pc0FycmF5KHYpKXY9QXJyYXkoOCkuZmlsbCh2KTtlbHNlIGlmKHYubGVuZ3RoPT09Mil2PVt2WzBdLHZbMV0sdlswXSx2WzFdLHZbMF0sdlsxXSx2WzBdLHZbMV1dO2Vsc2UgaWYodi5sZW5ndGg9PT00KXY9W3ZbMF0sdlsxXSx2WzJdLHZbM10sdlswXSx2WzFdLHZbMl0sdlszXV07ZWxzZSBpZih2Lmxlbmd0aD09PTYpdj1bdlswXSx2WzFdLHZbMl0sdlszXSx2WzRdLHZbNV0sdlsyXSx2WzNdXTtlbHNlIGlmKHYubGVuZ3RoIT09OCl0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIGJvcmRlclJhZGl1cyB2YWx1ZS4iKTt0aGlzLmJvcmRlclRvcExlZnRSYWRpdXM9W3ZbMF0sdlsxXV0sdGhpcy5ib3JkZXJUb3BSaWdodFJhZGl1cz1bdlsyXSx2WzNdXSx0aGlzLmJvcmRlckJvdHRvbVJpZ2h0UmFkaXVzPVt2WzRdLHZbNV1dLHRoaXMuYm9yZGVyQm90dG9tTGVmdFJhZGl1cz1bdls2XSx2WzddXX1nZXQgYmdjb2xvcigpe3JldHVybiB0aGlzW3VdKCJiZ2NvbG9yIil9c2V0IGJnY29sb3Iodil7dGhpc1tnXSgiYmdjb2xvciIsT2JqZWN0KGgucGFyc2VDb2xvcikodikpfWdldCBwYWRkaW5nVG9wKCl7cmV0dXJuIHRoaXNbdV0oInBhZGRpbmdUb3AiKX1zZXQgcGFkZGluZ1RvcCh2KXt0aGlzW2ddKCJwYWRkaW5nVG9wIixPYmplY3QoaS50b051bWJlcikodikpfWdldCBwYWRkaW5nUmlnaHQoKXtyZXR1cm4gdGhpc1t1XSgicGFkZGluZ1JpZ2h0Iil9c2V0IHBhZGRpbmdSaWdodCh2KXt0aGlzW2ddKCJwYWRkaW5nUmlnaHQiLE9iamVjdChpLnRvTnVtYmVyKSh2KSl9Z2V0IHBhZGRpbmdCb3R0b20oKXtyZXR1cm4gdGhpc1t1XSgicGFkZGluZ0JvdHRvbSIpfXNldCBwYWRkaW5nQm90dG9tKHYpe3RoaXNbZ10oInBhZGRpbmdCb3R0b20iLE9iamVjdChpLnRvTnVtYmVyKSh2KSl9Z2V0IHBhZGRpbmdMZWZ0KCl7cmV0dXJuIHRoaXNbdV0oInBhZGRpbmdMZWZ0Iil9c2V0IHBhZGRpbmdMZWZ0KHYpe3RoaXNbZ10oInBhZGRpbmdMZWZ0IixPYmplY3QoaS50b051bWJlcikodikpfWdldCBwYWRkaW5nKCl7cmV0dXJuW3RoaXMucGFkZGluZ1RvcCx0aGlzLnBhZGRpbmdSaWdodCx0aGlzLnBhZGRpbmdCb3R0b20sdGhpcy5wYWRkaW5nTGVmdF19c2V0IHBhZGRpbmcodil7dj1PYmplY3QoaS50b0FycmF5KSh2KSxBcnJheS5pc0FycmF5KHYpP3YubGVuZ3RoPT09Mj92PVt2WzBdLHZbMV0sdlswXSx2WzFdXTp2Lmxlbmd0aD09PTMmJih2PVt2WzBdLHZbMV0sdlsyXSx2WzFdXSk6dj1bdix2LHYsdl0sdGhpcy5wYWRkaW5nVG9wPXZbMF0sdGhpcy5wYWRkaW5nUmlnaHQ9dlsxXSx0aGlzLnBhZGRpbmdCb3R0b209dlsyXSx0aGlzLnBhZGRpbmdMZWZ0PXZbM119Z2V0IGNsaXBQYXRoKCl7cmV0dXJuIHRoaXNbdV0oImNsaXBQYXRoIil9c2V0IGNsaXBQYXRoKHYpe3RoaXNbZ10oImNsaXBQYXRoIix2KX1nZXQgYm94U2l6aW5nKCl7cmV0dXJuIHRoaXNbdV0oImJveFNpemluZyIpfXNldCBib3hTaXppbmcodil7aWYodiE9bnVsbCYmdiE9PSJib3JkZXItYm94IiYmdiE9PSJjb250ZW50LWJveCIpdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCBib3hTaXppbmcgdHlwZS4iKTt0aGlzW2ddKCJib3hTaXppbmciLHYpfX19LGZ1bmN0aW9uKFMsZSx0KXt0LnIoZSksdC5kKGUsIkdyYWRpZW50IixmdW5jdGlvbigpe3JldHVybiBofSksdC5kKGUsImlzVHJhbnNwYXJlbnQiLGZ1bmN0aW9uKCl7cmV0dXJuIGd9KSx0LmQoZSwicGFyc2VDb2xvciIsZnVuY3Rpb24oKXtyZXR1cm4gdX0pLHQuZChlLCJzZXRGaWxsQ29sb3IiLGZ1bmN0aW9uKCl7cmV0dXJuIGN9KSx0LmQoZSwic2V0U3Ryb2tlQ29sb3IiLGZ1bmN0aW9uKCl7cmV0dXJuIHh9KSx0LmQoZSwiQ29sb3IiLGZ1bmN0aW9uKCl7cmV0dXJuIGZ9KTt2YXIgcj10KDMyKSxpPXQubihyKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y2xhc3MgaHtjb25zdHJ1Y3Rvcih7dmVjdG9yOnAsY29sb3JzOkN9KXtpZighQXJyYXkuaXNBcnJheShwKXx8cC5sZW5ndGghPT00JiZwLmxlbmd0aCE9PTYmJnAubGVuZ3RoIT09Myl0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIGdyYWRpZW50Iik7dGhpcy52ZWN0b3I9cCx0aGlzLmNvbG9ycz1DLm1hcCgoe29mZnNldDpNLGNvbG9yOm19KT0+KHtvZmZzZXQ6TSxjb2xvcjp1KG0pfSkpfXRvU3RyaW5nKCl7cmV0dXJuIEpTT04uc3RyaW5naWZ5KHt2ZWN0b3I6dGhpcy52ZWN0b3IsY29sb3JzOnRoaXMuY29sb3JzfSl9fWZ1bmN0aW9uIGcodil7cmV0dXJuIHYgaW5zdGFuY2VvZiBoPyExOnY9PW51bGw/ITA6aSgpKHYpWzNdPT09MH1mdW5jdGlvbiB1KHYpe2lmKHY9PW51bGx8fCh2fHwodj0idHJhbnNwYXJlbnQiKSx2IGluc3RhbmNlb2YgaCkpcmV0dXJuIHY7Y29uc3QgcD1pKCkodik7aWYoIXB8fCFwLmxlbmd0aCl0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIGNvbG9yIHZhbHVlLiIpO3JldHVybmByZ2JhKCR7cC5qb2luKCl9KWB9ZnVuY3Rpb24gYSh2LHAsQyl7Y29uc3QgTT12LmJvdW5kaW5nQm94WzBdO2lmKEMudmVjdG9yKXtsZXR7dmVjdG9yOm0sY29sb3JzOnl9PUM7bS5sZW5ndGg9PT00PyhtPVttWzBdK01bMF0sbVsxXStNWzFdLG1bMl0rTVswXSxtWzNdK01bMV1dLHYuc2V0TGluZWFyR3JhZGllbnQoe3ZlY3RvcjptLGNvbG9yczp5LHR5cGU6cH0pKTptLmxlbmd0aD09PTM/KG09W21bMF0rTVswXSxtWzFdK01bMV0sbVsyXV0sdi5zZXRDaXJjdWxhckdyYWRpZW50KHt2ZWN0b3I6bSxjb2xvcnM6eSx0eXBlOnB9KSk6KG09W21bMF0rTVswXSxtWzFdK01bMV0sbVsyXSxtWzNdK01bMF0sbVs0XStNWzFdLG1bNV1dLHYuc2V0UmFkaWFsR3JhZGllbnQoe3ZlY3RvcjptLGNvbG9yczp5LHR5cGU6cH0pKX1lbHNlIHYuZ3JhZGllbnQmJnYuZ3JhZGllbnRbcF0mJihkZWxldGUgdi5ncmFkaWVudFtwXSxkZWxldGUgdi51bmlmb3Jtcy51X3JhZGlhbEdyYWRpZW50VmVjdG9yKX1mdW5jdGlvbiBjKHYse2NvbG9yOnAscnVsZTpDPSJub256ZXJvIn0pe3JldHVybiBhKHYsImZpbGwiLHApLHAudmVjdG9yfHx2LnNldEZpbGwoe2NvbG9yOnAscnVsZTpDfSksdn1mdW5jdGlvbiB4KHYse2NvbG9yOnAsbGluZVdpZHRoOkMsbGluZUNhcDpNLGxpbmVKb2luOm0sbGluZURhc2g6eSxsaW5lRGFzaE9mZnNldDpuLG1pdGVyTGltaXQ6byxyb3VuZFNlZ21lbnRzOnN9KXthKHYsInN0cm9rZSIscCkscC52ZWN0b3ImJihwPVswLDAsMCwxXSksdi5zZXRTdHJva2Uoe2NvbG9yOnAsdGhpY2tuZXNzOkMsY2FwOk0sam9pbjptLG1pdGVyTGltaXQ6byxsaW5lRGFzaDp5LGxpbmVEYXNoT2Zmc2V0Om4scm91bmRTZWdtZW50czpzfSl9Y2xhc3MgZiBleHRlbmRzIEFycmF5e2NvbnN0cnVjdG9yKHA9MCxDPTAsTT0wLG09MCl7cmV0dXJuIEFycmF5LmlzQXJyYXkocCkmJihbcCxDLE0sbV09cCksdHlwZW9mIHA9PSJzdHJpbmciJiYoW3AsQyxNLG1dPWkoKShwKSxwLz0yNTUsQy89MjU1LE0vPTI1NSksc3VwZXIocCxDLE0sbSksdGhpc31nZXQgcigpe3JldHVybiBNYXRoLnJvdW5kKHRoaXNbMF0qMjU1KX1zZXQgcihwKXt0aGlzWzBdPXAvMjU1fWdldCBnKCl7cmV0dXJuIE1hdGgucm91bmQodGhpc1sxXSoyNTUpfXNldCBnKHApe3RoaXNbMV09cC8yNTV9Z2V0IGIoKXtyZXR1cm4gTWF0aC5yb3VuZCh0aGlzWzJdKjI1NSl9c2V0IGIocCl7dGhpc1syXT1wLzI1NX1nZXQgYSgpe3JldHVybiB0aGlzWzNdfXNldCBhKHApe3RoaXNbM109cH1nZXQgaGV4KCl7Y29uc3QgcD1gMCR7dGhpcy5yLnRvU3RyaW5nKDE2KX1gLnNsaWNlKC0yKSxDPWAwJHt0aGlzLmcudG9TdHJpbmcoMTYpfWAuc2xpY2UoLTIpLE09YDAke3RoaXMuYi50b1N0cmluZygxNil9YC5zbGljZSgtMik7bGV0IG07cmV0dXJuIHRoaXMuYTwxJiYobT1NYXRoLnJvdW5kKHRoaXNbM10qMjU1KSxtPWAwJHttLnRvU3RyaW5nKDE2KX1gLnNsaWNlKC0yKSksYCMke3B9JHtDfSR7TX0ke218fCIifWB9Z2V0IHJnYmEoKXtyZXR1cm5gcmdiYSgke3RoaXMucn0sJHt0aGlzLmd9LCR7dGhpcy5ifSwke3RoaXMuYX0pYH1mcm9tQ29sb3IocCl7cmV0dXJuIHR5cGVvZiBwPT0ic3RyaW5nIiYmKHA9aSgpKHApLHBbMF0vPTI1NSxwWzFdLz0yNTUscFsyXS89MjU1KSx0aGlzWzBdPXBbMF0sdGhpc1sxXT1wWzFdLHRoaXNbMl09cFsyXSx0aGlzWzNdPXBbM10sdGhpc319fSxmdW5jdGlvbihTLGUsdCl7dC5yKGUpLHQuZChlLCJjcmVhdGVSYWRpdXNCb3giLGZ1bmN0aW9uKCl7cmV0dXJuIGl9KSx0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gcihoLGcsdSxhLGMseD0ibGVmdFRvcCIpe2NvbnN0IGY9LjU1MjI4NDgsdj1hLzIqZixwPWMvMipmLEM9ZythLE09dStjLG09ZythLzIseT11K2MvMjt4PT09ImxlZnRUb3AiPyhoLm1vdmVUbyhnLHkpLGguYmV6aWVyQ3VydmVUbyhnLHktcCxtLXYsdSxtLHUpKTp4PT09InJpZ2h0VG9wIj9oLmJlemllckN1cnZlVG8obSt2LHUsQyx5LXAsQyx5KTp4PT09InJpZ2h0Qm90dG9tIj9oLmJlemllckN1cnZlVG8oQyx5K3AsbSt2LE0sbSxNKTp4PT09ImxlZnRCb3R0b20iJiZoLmJlemllckN1cnZlVG8obS12LE0sZyx5K3AsZyx5KX1mdW5jdGlvbiBpKGgsW2csdSxhLGNdLHgpe2lmKCF4fHxBcnJheS5pc0FycmF5KHgpJiZ4LmV2ZXJ5KGY9PmY9PT0wKSloLmJlZ2luUGF0aCgpLGgucmVjdChnLHUsYSxjKTtlbHNle3R5cGVvZiB4PT0ibnVtYmVyIiYmKHg9QXJyYXkoOCkuZmlsbCh4KSk7Y29uc3RbZix2LHAsQyxNLG0seSxuXT14Lm1hcCgobyxzKT0+cyUyP01hdGgubWluKG8sYy8yKTpNYXRoLm1pbihvLGEvMikpO2guYmVnaW5QYXRoKCksaC5tb3ZlVG8oZyx1K3YpLHIoaCxnLHUsZioyLHYqMiwibGVmdFRvcCIpLGgubGluZVRvKGcrYS1wLHUpLHIoaCxnK2EtcCoyLHUscCoyLEMqMiwicmlnaHRUb3AiKSxoLmxpbmVUbyhnK2EsdStjLW0pLHIoaCxnK2EtTSoyLHUrYy1tKjIsTSoyLG0qMiwicmlnaHRCb3R0b20iKSxoLmxpbmVUbyhnK3ksdStjKSxyKGgsZyx1K2MtbioyLHkqMixuKjIsImxlZnRCb3R0b20iKSxoLmNsb3NlUGF0aCgpfXJldHVybiBofX0sZnVuY3Rpb24oUyxlLHQpe3QucihlKSx0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSksZS5kZWZhdWx0PWZ1bmN0aW9uKHIsaSl7aWYoIXIpcmV0dXJue3g6MCx5OjAsd2lkdGg6MCxoZWlnaHQ6MCxsZWZ0OjAsdG9wOjAscmlnaHQ6MCxib3R0b206MH07Y29uc3RbW2gsZ10sW3UsYV1dPXIsYz1oKmlbMF0rZyppWzJdK2lbNF0seD1oKmlbMV0rZyppWzNdK2lbNV0sZj11KmlbMF0rZyppWzJdK2lbNF0sdj11KmlbMV0rZyppWzNdK2lbNV0scD11KmlbMF0rYSppWzJdK2lbNF0sQz11KmlbMV0rYSppWzNdK2lbNV0sTT1oKmlbMF0rYSppWzJdK2lbNF0sbT1oKmlbMV0rYSppWzNdK2lbNV0seT1NYXRoLm1pbihjLGYscCxNKSxuPU1hdGgubWluKHgsdixDLG0pLG89TWF0aC5tYXgoYyxmLHAsTSkscz1NYXRoLm1heCh4LHYsQyxtKTtyZXR1cm57eDp5LHk6bix3aWR0aDpvLXksaGVpZ2h0OnMtbixsZWZ0OnksdG9wOm4scmlnaHQ6byxib3R0b206c319fSxmdW5jdGlvbihTLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBjfSk7dmFyIHI9dCgyMTgpLGk9dCgyMTkpLGg9dCgyMjUpLGc9dCgyMTMpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiB1KHgsZix2KXtyZXR1cm4gZiBpbiB4P09iamVjdC5kZWZpbmVQcm9wZXJ0eSh4LGYse3ZhbHVlOnYsZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTp4W2ZdPXYseH1jb25zdCBhPVN5bWJvbCgidGV4dHVyZVRhc2siKTtjbGFzcyBjIGV4dGVuZHMgaS5kZWZhdWx0e2NvbnN0cnVjdG9yKGY9e30pe3R5cGVvZiBmPT0ic3RyaW5nIiYmKGY9e3RleHR1cmU6Zn0pLHN1cGVyKGYpfWdldCBjb250ZW50U2l6ZSgpe2xldFtmLHZdPXN1cGVyLmNvbnRlbnRTaXplO2NvbnN0e3dpZHRoOnAsaGVpZ2h0OkN9PXRoaXMuYXR0cmlidXRlcztpZihwPT1udWxsfHxDPT1udWxsKXtjb25zdCBNPXRoaXMudGV4dHVyZUltYWdlLG09dGhpcy5hdHRyaWJ1dGVzLnRleHR1cmVSZWN0LHk9dGhpcy5hdHRyaWJ1dGVzLnNvdXJjZVJlY3Q7aWYobSlwPT1udWxsJiYoZj1tWzBdK21bMl0pLEM9PW51bGwmJih2PW1bMV0rbVszXSk7ZWxzZSBpZih5KXtjb25zdCBuPXRoaXMubGF5ZXI/dGhpcy5sYXllci5kaXNwbGF5UmF0aW86MTtwPT1udWxsJiYoZj15WzJdL24pLEM9PW51bGwmJih2PXlbM10vbil9ZWxzZSBpZihNKXtjb25zdCBuPXRoaXMubGF5ZXI/dGhpcy5sYXllci5kaXNwbGF5UmF0aW86MTtwPT1udWxsJiYoZj1NLndpZHRoL24pLEM9PW51bGwmJih2PU0uaGVpZ2h0L24pfX1yZXR1cm5bZix2XX1nZXQgdGV4dHVyZUltYWdlUmVhZHkoKXtyZXR1cm4gdGhpc1thXXx8UHJvbWlzZS5yZXNvbHZlKCl9ZHJhdyhmPVtdKXtzdXBlci5kcmF3KGYpO2NvbnN0IHY9dGhpcy5tZXNoO3JldHVybiB2JiZPYmplY3Qoci5kcmF3VGV4dHVyZSkodGhpcyx2KSxmfW9uUHJvcGVydHlDaGFuZ2UoZix2LHApe2lmKHN1cGVyLm9uUHJvcGVydHlDaGFuZ2UoZix2LHApLGY9PT0idGV4dHVyZSImJih0aGlzW2FdPU9iamVjdChyLmFwcGx5VGV4dHVyZSkodGhpcyx2LCEwKSksZj09PSJ0ZXh0dXJlUmVjdCIpe2NvbnN0e3dpZHRoOkMsaGVpZ2h0Ok19PXRoaXMuYXR0cmlidXRlczsoQz09bnVsbHx8TT09bnVsbCkmJnRoaXMudXBkYXRlQ29udG91cnMoKX19fXUoYywiQXR0ciIsaC5kZWZhdWx0KSxnLmRlZmF1bHQucmVnaXN0ZXJOb2RlKGMsInNwcml0ZSIpfSxmdW5jdGlvbihTLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiB1fSk7dmFyIHI9dCgyMjApO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCBpPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZURlZmF1bHQiKSxoPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZSIpLGc9U3ltYm9sLmZvcigic3ByaXRlanNfZ2V0QXR0cmlidXRlIik7Y2xhc3MgdSBleHRlbmRzIHIuZGVmYXVsdHtjb25zdHJ1Y3RvcihjKXtzdXBlcihjKSx0aGlzW2ldKHt0ZXh0dXJlOnZvaWQgMCx0ZXh0dXJlUmVjdDp2b2lkIDAsdGV4dHVyZVJlcGVhdDohMSxzb3VyY2VSZWN0OnZvaWQgMH0pfWdldCB0ZXh0dXJlKCl7cmV0dXJuIHRoaXNbZ10oInRleHR1cmUiKX1zZXQgdGV4dHVyZShjKXt0aGlzW2hdKCJ0ZXh0dXJlIixjKX1nZXQgdGV4dHVyZVJlY3QoKXtyZXR1cm4gdGhpc1tnXSgidGV4dHVyZVJlY3QiKX1zZXQgdGV4dHVyZVJlY3QoYyl7dGhpc1toXSgidGV4dHVyZVJlY3QiLGMpfWdldCBzb3VyY2VSZWN0KCl7cmV0dXJuIHRoaXNbZ10oInNvdXJjZVJlY3QiKX1zZXQgc291cmNlUmVjdChjKXt0aGlzW2hdKCJzb3VyY2VSZWN0IixjKX1nZXQgdGV4dHVyZVJlcGVhdCgpe3JldHVybiB0aGlzW2ddKCJ0ZXh0dXJlUmVwZWF0Iil9c2V0IHRleHR1cmVSZXBlYXQoYyl7dGhpc1toXSgidGV4dHVyZVJlcGVhdCIsISFjKX19fSxmdW5jdGlvbihTLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBDfSk7dmFyIHI9dCgxMiksaT10KDIyNyksaD10Lm4oaSksZz10KDcwKSx1PXQoMjI4KSxhPXQoMjIxKSxjPXQoMjE4KSx4PXQoMjEzKSxmPXQoMjIzKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gdihNLG0seSl7cmV0dXJuIG0gaW4gTT9PYmplY3QuZGVmaW5lUHJvcGVydHkoTSxtLHt2YWx1ZTp5LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6TVttXT15LE19Y29uc3QgcD1TeW1ib2woIm1lc2giKTtjbGFzcyBDIGV4dGVuZHMgZy5kZWZhdWx0e2NvbnN0cnVjdG9yKG09e30pe3R5cGVvZiBtPT0ic3RyaW5nIiYmKG09e2Q6bX0pLHN1cGVyKG0pLHRoaXMuZWZmZWN0cz17ZCh5LG4sbyxzLGwpe2NvbnN0IEU9KG8tcykvKGwtcyk7aWYoRTw9MClyZXR1cm4geTtpZihFPj0xKXJldHVybiBuO2NvbnN0IFQ9aC5hLl9wcmVwcm9jZXNzaW5nKGguYS5wYXRoMnNoYXBlcyh5KSxoLmEucGF0aDJzaGFwZXMobikpLGI9aC5hLl9sZXJwKC4uLlQsRSlbMF07cmV0dXJuIGIucmVkdWNlKChQLEwpPT5gJHtQfSR7TC5zbGljZSgyKS5qb2luKCIgIil9IGAsYE0ke2JbMF1bMF19ICR7YlswXVsxXX1DYCkudHJpbSgpfX19Z2V0IGlzVmlzaWJsZSgpe3JldHVybiEhdGhpcy5kfWdldCBtZXNoKCl7aWYodGhpcy5hdHRyaWJ1dGVzLmRpc3BsYXk9PT0ibm9uZSIpcmV0dXJuIG51bGw7Y29uc3QgbT10aGlzLnBhdGg7aWYobSl7bGV0IHk9dGhpc1twXTtpZih5KXkucGF0aCE9PW0mJih5LmNvbnRvdXJzPW0uY29udG91cnMseS5wYXRoPW0pO2Vsc2V7eT1uZXcgci5NZXNoMkQodGhpcy5wYXRoKSx5LnBhdGg9bTtjb25zdCBvPXRoaXMuYXR0cmlidXRlcy5maWxsQ29sb3Iscz10aGlzLmF0dHJpYnV0ZXMuZmlsbFJ1bGU7byYmT2JqZWN0KGEuc2V0RmlsbENvbG9yKSh5LHtjb2xvcjpvLHJ1bGU6c30pO2NvbnN0IGw9dGhpcy5hdHRyaWJ1dGVzLmxpbmVXaWR0aCxFPXRoaXMuYXR0cmlidXRlcy5zdHJva2VDb2xvcjtpZihFJiZsPjApe2NvbnN0e2xpbmVDYXA6YixsaW5lSm9pbjpJLG1pdGVyTGltaXQ6UCxsaW5lRGFzaDpMLGxpbmVEYXNoT2Zmc2V0OkQscm91bmRTZWdtZW50czpSfT10aGlzLmF0dHJpYnV0ZXM7T2JqZWN0KGEuc2V0U3Ryb2tlQ29sb3IpKHkse2NvbG9yOkUsbGluZVdpZHRoOmwsbGluZUNhcDpiLGxpbmVKb2luOkksbWl0ZXJMaW1pdDpQLGxpbmVEYXNoOkwsbGluZURhc2hPZmZzZXQ6RCxyb3VuZFNlZ21lbnRzOlJ9KX10aGlzW3BdPXk7Y29uc3QgVD10aGlzLmF0dHJpYnV0ZXMuY2xpcFBhdGg7VCYmdGhpc1twXS5zZXRDbGlwUGF0aChUKX1jb25zdCBuPXRoaXMub3BhY2l0eTtyZXR1cm4geS5nZXRPcGFjaXR5KCkhPT1uJiZ5LnNldE9wYWNpdHkobikseS5zZXRUcmFuc2Zvcm0oLi4udGhpcy5yZW5kZXJNYXRyaXgpLHl9cmV0dXJuIG51bGx9Z2V0IG9yaWdpbmFsQ29udGVudFJlY3QoKXtpZih0aGlzLnBhdGgpe2NvbnN0IG09dGhpcy5wYXRoLmJvdW5kaW5nQm94O3JldHVyblttWzBdWzBdLG1bMF1bMV0sbVsxXVswXS1tWzBdWzBdLG1bMV1bMV0tbVswXVsxXV19cmV0dXJuWzAsMCwwLDBdfWdldCBvcmlnaW5hbENsaWVudFJlY3QoKXtpZih0aGlzLm1lc2gpe2NvbnN0IG09dGhpcy5tZXNoLmJvdW5kaW5nQm94O3JldHVyblttWzBdWzBdLG1bMF1bMV0sbVsxXVswXS1tWzBdWzBdLG1bMV1bMV0tbVswXVsxXV19cmV0dXJuWzAsMCwwLDBdfWdldCBvcmlnaW5hbENsaWVudENlbnRlcigpe3JldHVybiB0aGlzLm1lc2g/dGhpcy5tZXNoLmJvdW5kaW5nQ2VudGVyOlswLDBdfXNldCBkKG0pe3RoaXMuYXR0cmlidXRlcy5kPW19Z2V0IGQoKXtyZXR1cm4gdGhpcy5hdHRyaWJ1dGVzLmR9ZHJhdyhtPVtdKXtzdXBlci5kcmF3KG0pO2NvbnN0IHk9dGhpcy5tZXNoO3JldHVybiB5JiZPYmplY3QoYy5kcmF3VGV4dHVyZSkodGhpcyx5KSxtfWdldEJvdW5kaW5nQ2xpZW50UmVjdCgpe2xldCBtPW51bGw7cmV0dXJuIHRoaXMubWVzaCYmKG09dGhpcy5tZXNoLmJvdW5kaW5nQm94KSxPYmplY3QoZi5kZWZhdWx0KShtLHRoaXMucmVuZGVyTWF0cml4KX1nZXRQYXRoTGVuZ3RoKCl7cmV0dXJuIHRoaXMubWVzaD90aGlzLm1lc2guZ2V0VG90YWxMZW5ndGgoKTowfWdldFBvaW50QXRMZW5ndGgobSl7aWYodGhpcy5tZXNoKXtjb25zdCB5PXRoaXMubWVzaC5nZXRQb2ludEF0TGVuZ3RoKG0pO2lmKHkpcmV0dXJuW3kueCx5LnldfXJldHVyblswLDBdfW9uUHJvcGVydHlDaGFuZ2UobSx5LG4pe2lmKHN1cGVyLm9uUHJvcGVydHlDaGFuZ2UobSx5LG4pLChtPT09ImQifHxtPT09Im5vcm1hbGl6ZSIpJiZ0aGlzLnVwZGF0ZUNvbnRvdXJzKCksdGhpc1twXSYmKG09PT0iZmlsbENvbG9yInx8bT09PSJmaWxsUnVsZSIpKXtjb25zdHtmaWxsQ29sb3I6byxmaWxsUnVsZTpzfT10aGlzLmF0dHJpYnV0ZXM7T2JqZWN0KGEuc2V0RmlsbENvbG9yKSh0aGlzW3BdLHtjb2xvcjpvLHJ1bGU6c30pfWlmKHRoaXNbcF0mJihtPT09InN0cm9rZUNvbG9yInx8bT09PSJsaW5lV2lkdGgifHxtPT09ImxpbmVDYXAifHxtPT09ImxpbmVKb2luInx8bT09PSJsaW5lRGFzaCJ8fG09PT0ibGluZURhc2hPZmZzZXQifHxtPT09InJvdW5kU2VnbWVudHMiKSl7Y29uc3R7c3Ryb2tlQ29sb3I6byxsaW5lV2lkdGg6c309dGhpcy5hdHRyaWJ1dGVzO2lmKG8mJnM+MCl7Y29uc3R7bGluZUNhcDpsLGxpbmVKb2luOkUsbGluZURhc2g6VCxsaW5lRGFzaE9mZnNldDpiLG1pdGVyTGltaXQ6SSxyb3VuZFNlZ21lbnRzOlB9PXRoaXMuYXR0cmlidXRlcztPYmplY3QoYS5zZXRTdHJva2VDb2xvcikodGhpc1twXSx7Y29sb3I6byxsaW5lQ2FwOmwsbGluZUpvaW46RSxsaW5lV2lkdGg6cyxsaW5lRGFzaDpULGxpbmVEYXNoT2Zmc2V0OmIsbWl0ZXJMaW1pdDpJLHJvdW5kU2VnbWVudHM6UH0pfX10aGlzW3BdJiZtPT09ImNsaXBQYXRoIiYmdGhpc1twXS5zZXRDbGlwUGF0aCh5KSxtPT09InRleHR1cmUiJiZPYmplY3QoYy5hcHBseVRleHR1cmUpKHRoaXMseSl9dXBkYXRlQ29udG91cnMoKXt0aGlzLnBhdGg9bmV3IHIuRmlndXJlMkQsdGhpcy5wYXRoLmFkZFBhdGgodGhpcy5hdHRyaWJ1dGVzLmQpLHRoaXMuYXR0cmlidXRlcy5ub3JtYWxpemUmJnRoaXMucGF0aC5ub3JtYWxpemUoLi4udGhpcy5wYXRoLmJvdW5kaW5nQ2VudGVyKX19dihDLCJBdHRyIix1LmRlZmF1bHQpLHguZGVmYXVsdC5yZWdpc3Rlck5vZGUoQywicGF0aCIpfSxmdW5jdGlvbihTLGUsdCl7KGZ1bmN0aW9uKHIsaSl7Uy5leHBvcnRzPWkoKX0pKHRoaXMsZnVuY3Rpb24oKXt2YXIgcj1mdW5jdGlvbigpe2Z1bmN0aW9uIEwoRCxSKXt2YXIgQT1bXSxqPSEwLEc9ITEsSD12b2lkIDA7dHJ5e2Zvcih2YXIgWj1EW1N5bWJvbC5pdGVyYXRvcl0oKSxxOyEoaj0ocT1aLm5leHQoKSkuZG9uZSkmJihBLnB1c2gocS52YWx1ZSksIShSJiZBLmxlbmd0aD09PVIpKTtqPSEwKTt9Y2F0Y2goRil7Rz0hMCxIPUZ9ZmluYWxseXt0cnl7IWomJloucmV0dXJuJiZaLnJldHVybigpfWZpbmFsbHl7aWYoRyl0aHJvdyBIfX1yZXR1cm4gQX1yZXR1cm4gZnVuY3Rpb24oRCxSKXtpZihBcnJheS5pc0FycmF5KEQpKXJldHVybiBEO2lmKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoRCkpcmV0dXJuIEwoRCxSKTt0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlIil9fSgpLGk9TWF0aC5QSSoyLGg9ZnVuY3Rpb24oRCxSLEEsaixHLEgsWil7dmFyIHE9RC54LEY9RC55O3EqPVIsRio9QTt2YXIgJD1qKnEtRypGLEo9RypxK2oqRjtyZXR1cm57eDokK0gseTpKK1p9fSxnPWZ1bmN0aW9uKEQsUil7dmFyIEE9MS4zMzMzMzMzMzMzMzMzMzMzKk1hdGgudGFuKFIvNCksaj1NYXRoLmNvcyhEKSxHPU1hdGguc2luKEQpLEg9TWF0aC5jb3MoRCtSKSxaPU1hdGguc2luKEQrUik7cmV0dXJuW3t4OmotRypBLHk6RytqKkF9LHt4OkgrWipBLHk6Wi1IKkF9LHt4OkgseTpafV19LHU9ZnVuY3Rpb24oRCxSLEEsail7dmFyIEc9RCpqLVIqQTwwPy0xOjEsSD1NYXRoLnNxcnQoRCpEK1IqUiksWj1NYXRoLnNxcnQoRCpEK1IqUikscT1EKkErUipqLEY9cS8oSCpaKTtyZXR1cm4gRj4xJiYoRj0xKSxGPC0xJiYoRj0tMSksRypNYXRoLmFjb3MoRil9LGE9ZnVuY3Rpb24oRCxSLEEsaixHLEgsWixxLEYsJCxKLHR0KXt2YXIgXz1NYXRoLnBvdyhHLDIpLHN0PU1hdGgucG93KEgsMiksaz1NYXRoLnBvdyhKLDIpLGN0PU1hdGgucG93KHR0LDIpLGZ0PV8qc3QtXypjdC1zdCprO2Z0PDAmJihmdD0wKSxmdC89XypjdCtzdCprLGZ0PU1hdGguc3FydChmdCkqKFo9PT1xPy0xOjEpO3ZhciBXPWZ0KkcvSCp0dCxVPWZ0Ki1IL0cqSixWPSQqVy1GKlUrKEQrQSkvMixYPUYqVyskKlUrKFIraikvMixCPShKLVcpL0csdz0odHQtVSkvSCxkPSgtSi1XKS9HLE89KC10dC1VKS9ILE49dSgxLDAsQix3KSx6PXUoQix3LGQsTyk7cmV0dXJuIHE9PT0wJiZ6PjAmJih6LT1pKSxxPT09MSYmejwwJiYoeis9aSksW1YsWCxOLHpdfSxjPWZ1bmN0aW9uKEQpe3ZhciBSPUQucHgsQT1ELnB5LGo9RC5jeCxHPUQuY3ksSD1ELnJ4LFo9RC5yeSxxPUQueEF4aXNSb3RhdGlvbixGPXE9PT12b2lkIDA/MDpxLCQ9RC5sYXJnZUFyY0ZsYWcsSj0kPT09dm9pZCAwPzA6JCx0dD1ELnN3ZWVwRmxhZyxfPXR0PT09dm9pZCAwPzA6dHQsc3Q9W107aWYoSD09PTB8fFo9PT0wKXJldHVybltdO3ZhciBrPU1hdGguc2luKEYqaS8zNjApLGN0PU1hdGguY29zKEYqaS8zNjApLGZ0PWN0KihSLWopLzIrayooQS1HKS8yLFc9LWsqKFItaikvMitjdCooQS1HKS8yO2lmKGZ0PT09MCYmVz09PTApcmV0dXJuW107SD1NYXRoLmFicyhIKSxaPU1hdGguYWJzKFopO3ZhciBVPU1hdGgucG93KGZ0LDIpL01hdGgucG93KEgsMikrTWF0aC5wb3coVywyKS9NYXRoLnBvdyhaLDIpO1U+MSYmKEgqPU1hdGguc3FydChVKSxaKj1NYXRoLnNxcnQoVSkpO3ZhciBWPWEoUixBLGosRyxILFosSixfLGssY3QsZnQsVyksWD1yKFYsNCksQj1YWzBdLHc9WFsxXSxkPVhbMl0sTz1YWzNdLE49TWF0aC5tYXgoTWF0aC5jZWlsKE1hdGguYWJzKE8pLyhpLzQpKSwxKTtPLz1OO2Zvcih2YXIgej0wO3o8Tjt6Kyspc3QucHVzaChnKGQsTykpLGQrPU87cmV0dXJuIHN0Lm1hcChmdW5jdGlvbihLKXt2YXIgWT1oKEtbMF0sSCxaLGN0LGssQix3KSxRPVkueCxldD1ZLnkscnQ9aChLWzFdLEgsWixjdCxrLEIsdyksb3Q9cnQueCxsdD1ydC55LGl0PWgoS1syXSxILFosY3QsayxCLHcpLG50PWl0LngsYXQ9aXQueTtyZXR1cm57eDE6USx5MTpldCx4MjpvdCx5MjpsdCx4Om50LHk6YXR9fSl9LHg9e2E6NyxjOjYsaDoxLGw6MixtOjIscTo0LHM6NCx0OjIsdjoxLHo6MH0sZj0vKFthc3R2enFtaGxjXSkoW15hc3R2enFtaGxjXSopL2lnO2Z1bmN0aW9uIHYoTCl7dmFyIEQ9W107cmV0dXJuIEwucmVwbGFjZShmLGZ1bmN0aW9uKFIsQSxqKXt2YXIgRz1BLnRvTG93ZXJDYXNlKCk7Zm9yKGo9QyhqKSxHPT0ibSImJmoubGVuZ3RoPjImJihELnB1c2goW0FdLmNvbmNhdChqLnNwbGljZSgwLDIpKSksRz0ibCIsQT1BPT0ibSI/ImwiOiJMIik7Oyl7aWYoai5sZW5ndGg9PXhbR10pcmV0dXJuIGoudW5zaGlmdChBKSxELnB1c2goaik7aWYoai5sZW5ndGg8eFtHXSl0aHJvdyBuZXcgRXJyb3IoIm1hbGZvcm1lZCBwYXRoIGRhdGEiKTtELnB1c2goW0FdLmNvbmNhdChqLnNwbGljZSgwLHhbR10pKSl9fSksRH12YXIgcD0vLT9bMC05XSpcLj9bMC05XSsoPzplWy0rXT9cZCspPy9pZztmdW5jdGlvbiBDKEwpe3ZhciBEPUwubWF0Y2gocCk7cmV0dXJuIEQ/RC5tYXAoTnVtYmVyKTpbXX1mdW5jdGlvbiBNKEwpe3ZhciBEPUxbMF1bMF0sUj1MWzBdWzFdLEE9RCxqPVI7cmV0dXJuIEwuZm9yRWFjaChmdW5jdGlvbihHKXt2YXIgSD1HWzBdLFo9R1syXSxxPUdbNF0sRj1HWzZdLCQ9R1sxXSxKPUdbM10sdHQ9R1s1XSxfPUdbN107RD1NYXRoLm1pbihELEgsWixxLEYpLFI9TWF0aC5taW4oUiwkLEosdHQsXyksQT1NYXRoLm1heChBLEgsWixxLEYpLGo9TWF0aC5tYXgoaiwkLEosdHQsXyl9KSxbRCxSLEEsal19ZnVuY3Rpb24gbShMLEQpe3JldHVybiBNYXRoLnNxcnQoTWF0aC5wb3coTFswXS1EWzBdLDIpK01hdGgucG93KExbMV0tRFsxXSwyKSkrTWF0aC5zcXJ0KE1hdGgucG93KExbMl0tRFsyXSwyKStNYXRoLnBvdyhMWzNdLURbM10sMikpfWZ1bmN0aW9uIHkoTCxEKXt2YXIgUj1MWzBdLEE9TFsyXSxqPUxbNF0sRz1MWzZdLEg9TFsxXSxaPUxbM10scT1MWzVdLEY9TFs3XSwkPURbMF0sSj1EWzJdLHR0PURbNF0sXz1EWzZdLHN0PURbMV0saz1EWzNdLGN0PURbNV0sZnQ9RFs3XTtyZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KCQtUiwyKStNYXRoLnBvdyhzdC1ILDIpKStNYXRoLnNxcnQoTWF0aC5wb3coSi1BLDIpK01hdGgucG93KGstWiwyKSkrTWF0aC5zcXJ0KE1hdGgucG93KHR0LWosMikrTWF0aC5wb3coY3QtcSwyKSkrTWF0aC5zcXJ0KE1hdGgucG93KF8tRywyKStNYXRoLnBvdyhmdC1GLDIpKX1mdW5jdGlvbiBuKEwsRCl7dmFyIFI9cyhMLmxlbmd0aCksQT1bXTtSLmZvckVhY2goZnVuY3Rpb24oRyl7dmFyIEg9MCxaPTA7Ry5mb3JFYWNoKGZ1bmN0aW9uKHEpe0grPXkoTFtxXSxEW1orK10pfSksQS5wdXNoKHtpbmRleDpHLGRpc3RhbmNlOkh9KX0pLEEuc29ydChmdW5jdGlvbihHLEgpe3JldHVybiBHLmRpc3RhbmNlLUguZGlzdGFuY2V9KTt2YXIgaj1bXTtyZXR1cm4gQVswXS5pbmRleC5mb3JFYWNoKGZ1bmN0aW9uKEcpe2oucHVzaChMW0ddKX0pLGp9ZnVuY3Rpb24gbyhMLEQpe3ZhciBSPWwoTC5sZW5ndGgpLEE9W107Ui5mb3JFYWNoKGZ1bmN0aW9uKEcpe3ZhciBIPTA7Ry5mb3JFYWNoKGZ1bmN0aW9uKFope0grPW0oTShMW1pdKSxNKERbWl0pKX0pLEEucHVzaCh7aW5kZXg6RyxkaXN0YW5jZTpIfSl9KSxBLnNvcnQoZnVuY3Rpb24oRyxIKXtyZXR1cm4gRy5kaXN0YW5jZS1ILmRpc3RhbmNlfSk7dmFyIGo9W107cmV0dXJuIEFbMF0uaW5kZXguZm9yRWFjaChmdW5jdGlvbihHKXtqLnB1c2goTFtHXSl9KSxqfWZ1bmN0aW9uIHMoTCl7Zm9yKHZhciBEPVtdLFI9MDtSPEw7UisrKXtmb3IodmFyIEE9W10saj0wO2o8TDtqKyspe3ZhciBHPWorUjtHPkwtMSYmKEctPUwpLEFbR109an1ELnB1c2goQSl9cmV0dXJuIER9ZnVuY3Rpb24gbChMKXtmb3IodmFyIEQ9W10sUj0wO1I8TDtSKyspRC5wdXNoKFIpO3JldHVybiBFKEQpfWZ1bmN0aW9uIEUoTCl7dmFyIEQ9W10sUj1bXTtmdW5jdGlvbiBBKGope3ZhciBHLEg7Zm9yKEc9MDtHPGoubGVuZ3RoO0crKylIPWouc3BsaWNlKEcsMSlbMF0sUi5wdXNoKEgpLGoubGVuZ3RoPT0wJiZELnB1c2goUi5zbGljZSgpKSxBKGopLGouc3BsaWNlKEcsMCxIKSxSLnBvcCgpO3JldHVybiBEfXJldHVybiBBKEwpfXZhciBUPXt9O1QucGFyc2VyPXYsVC5sZXJwQ3VydmU9ZnVuY3Rpb24oTCxELFIpe3JldHVybiBULmxlcnBQb2ludHMoTFswXSxMWzFdLERbMF0sRFsxXSxSKS5jb25jYXQoVC5sZXJwUG9pbnRzKExbMl0sTFszXSxEWzJdLERbM10sUikpLmNvbmNhdChULmxlcnBQb2ludHMoTFs0XSxMWzVdLERbNF0sRFs1XSxSKSkuY29uY2F0KFQubGVycFBvaW50cyhMWzZdLExbN10sRFs2XSxEWzddLFIpKX0sVC5sZXJwUG9pbnRzPWZ1bmN0aW9uKEwsRCxSLEEsail7cmV0dXJuW0wrKFItTCkqaixEKyhBLUQpKmpdfSxULnEyYj1mdW5jdGlvbihMLEQsUixBLGosRyl7cmV0dXJuW0wsRCwoTCsyKlIpLzMsKEQrMipBKS8zLChqKzIqUikvMywoRysyKkEpLzMsaixHXX0sVC5wYXRoMnNoYXBlcz1mdW5jdGlvbihMKXtmb3IodmFyIEQ9VC5wYXJzZXIoTCksUj0wLEE9MCxqPTAsRz1ELmxlbmd0aCxIPVtdLFo9bnVsbCxxPXZvaWQgMCxGPXZvaWQgMCwkPXZvaWQgMCxKPXZvaWQgMCx0dD12b2lkIDAsXz12b2lkIDAsc3Q9dm9pZCAwO2o8RztqKyspe3ZhciBrPURbal0sY3Q9a1swXSxmdD1EW2otMV07c3dpdGNoKGN0KXtjYXNlIm0iOnR0PUgubGVuZ3RoLEhbdHRdPVtdLFo9SFt0dF0sUj1SK2tbMV0sQT1BK2tbMl07YnJlYWs7Y2FzZSJNIjp0dD1ILmxlbmd0aCxIW3R0XT1bXSxaPUhbdHRdLFI9a1sxXSxBPWtbMl07YnJlYWs7Y2FzZSJsIjpaLnB1c2goW1IsQSxSLEEsUixBLFIra1sxXSxBK2tbMl1dKSxSKz1rWzFdLEErPWtbMl07YnJlYWs7Y2FzZSJMIjpaLnB1c2goW1IsQSxrWzFdLGtbMl0sa1sxXSxrWzJdLGtbMV0sa1syXV0pLFI9a1sxXSxBPWtbMl07YnJlYWs7Y2FzZSJoIjpaLnB1c2goW1IsQSxSLEEsUixBLFIra1sxXSxBXSksUis9a1sxXTticmVhaztjYXNlIkgiOloucHVzaChbUixBLGtbMV0sQSxrWzFdLEEsa1sxXSxBXSksUj1rWzFdO2JyZWFrO2Nhc2UidiI6Wi5wdXNoKFtSLEEsUixBLFIsQSxSLEEra1sxXV0pLEErPWtbMV07YnJlYWs7Y2FzZSJWIjpaLnB1c2goW1IsQSxSLGtbMV0sUixrWzFdLFIsa1sxXV0pLEE9a1sxXTticmVhaztjYXNlIkMiOloucHVzaChbUixBLGtbMV0sa1syXSxrWzNdLGtbNF0sa1s1XSxrWzZdXSksUj1rWzVdLEE9a1s2XTticmVhaztjYXNlIlMiOmZ0WzBdPT09IkMifHxmdFswXT09PSJjIj9aLnB1c2goW1IsQSxSK2Z0WzVdLWZ0WzNdLEErZnRbNl0tZnRbNF0sa1sxXSxrWzJdLGtbM10sa1s0XV0pOihmdFswXT09PSJTInx8ZnRbMF09PT0icyIpJiZaLnB1c2goW1IsQSxSK2Z0WzNdLWZ0WzFdLEErZnRbNF0tZnRbMl0sa1sxXSxrWzJdLGtbM10sa1s0XV0pLFI9a1szXSxBPWtbNF07YnJlYWs7Y2FzZSJjIjpaLnB1c2goW1IsQSxSK2tbMV0sQStrWzJdLFIra1szXSxBK2tbNF0sUitrWzVdLEEra1s2XV0pLFI9UitrWzVdLEE9QStrWzZdO2JyZWFrO2Nhc2UicyI6ZnRbMF09PT0iQyJ8fGZ0WzBdPT09ImMiP1oucHVzaChbUixBLFIrZnRbNV0tZnRbM10sQStmdFs2XS1mdFs0XSxSK2tbMV0sQStrWzJdLFIra1szXSxBK2tbNF1dKTooZnRbMF09PT0iUyJ8fGZ0WzBdPT09InMiKSYmWi5wdXNoKFtSLEEsUitmdFszXS1mdFsxXSxBK2Z0WzRdLWZ0WzJdLFIra1sxXSxBK2tbMl0sUitrWzNdLEEra1s0XV0pLFI9UitrWzNdLEE9QStrWzRdO2JyZWFrO2Nhc2UiYSI6Xz1jKHtyeDprWzFdLHJ5OmtbMl0scHg6UixweTpBLHhBeGlzUm90YXRpb246a1szXSxsYXJnZUFyY0ZsYWc6a1s0XSxzd2VlcEZsYWc6a1s1XSxjeDpSK2tbNl0sY3k6QStrWzddfSksc3Q9X1tfLmxlbmd0aC0xXSxfLmZvckVhY2goZnVuY3Rpb24oVyxVKXtVPT09MD9aLnB1c2goW1IsQSxXLngxLFcueTEsVy54MixXLnkyLFcueCxXLnldKTpaLnB1c2goW19bVS0xXS54LF9bVS0xXS55LFcueDEsVy55MSxXLngyLFcueTIsVy54LFcueV0pfSksUj1zdC54LEE9c3QueTticmVhaztjYXNlIkEiOl89Yyh7cng6a1sxXSxyeTprWzJdLHB4OlIscHk6QSx4QXhpc1JvdGF0aW9uOmtbM10sbGFyZ2VBcmNGbGFnOmtbNF0sc3dlZXBGbGFnOmtbNV0sY3g6a1s2XSxjeTprWzddfSksc3Q9X1tfLmxlbmd0aC0xXSxfLmZvckVhY2goZnVuY3Rpb24oVyxVKXtVPT09MD9aLnB1c2goW1IsQSxXLngxLFcueTEsVy54MixXLnkyLFcueCxXLnldKTpaLnB1c2goW19bVS0xXS54LF9bVS0xXS55LFcueDEsVy55MSxXLngyLFcueTIsVy54LFcueV0pfSksUj1zdC54LEE9c3QueTticmVhaztjYXNlIlEiOloucHVzaChULnEyYihSLEEsa1sxXSxrWzJdLGtbM10sa1s0XSkpLFI9a1szXSxBPWtbNF07YnJlYWs7Y2FzZSJxIjpaLnB1c2goVC5xMmIoUixBLFIra1sxXSxBK2tbMl0sa1szXStSLGtbNF0rQSkpLFIrPWtbM10sQSs9a1s0XTticmVhaztjYXNlIlQiOmZ0WzBdPT09IlEifHxmdFswXT09PSJxIj8oJD1SK2Z0WzNdLWZ0WzFdLEo9QStmdFs0XS1mdFsyXSxaLnB1c2goVC5xMmIoUixBLCQsSixrWzFdLGtbMl0pKSk6KGZ0WzBdPT09IlQifHxmdFswXT09PSJ0IikmJihaLnB1c2goVC5xMmIoUixBLFIrUi0kLEErQS1KLGtbMV0sa1syXSkpLCQ9UitSLSQsSj1BK0EtSiksUj1rWzFdLEE9a1syXTticmVhaztjYXNlInQiOmZ0WzBdPT09IlEifHxmdFswXT09PSJxIj8oJD1SK2Z0WzNdLWZ0WzFdLEo9QStmdFs0XS1mdFsyXSxaLnB1c2goVC5xMmIoUixBLCQsSixSK2tbMV0sQStrWzJdKSkpOihmdFswXT09PSJUInx8ZnRbMF09PT0idCIpJiYoWi5wdXNoKFQucTJiKFIsQSxSK1ItJCxBK0EtSixSK2tbMV0sQStrWzJdKSksJD1SK1ItJCxKPUErQS1KKSxSKz1rWzFdLEErPWtbMl07YnJlYWs7Y2FzZSJaIjpxPVpbMF1bMF0sRj1aWzBdWzFdLFoucHVzaChbUixBLHEsRixxLEYscSxGXSk7YnJlYWs7Y2FzZSJ6IjpxPVpbMF1bMF0sRj1aWzBdWzFdLFoucHVzaChbUixBLHEsRixxLEYscSxGXSk7YnJlYWt9fXJldHVybiBIfSxULl91cEN1cnZlcz1mdW5jdGlvbihMLEQpe2Zvcih2YXIgUj0wLEE9MCxqPUwubGVuZ3RoO1I8RDtSKyspTC5wdXNoKExbQV0uc2xpY2UoMCkpLEErKyxBPmotMSYmKEEtPWopfTtmdW5jdGlvbiBiKEwsRCxSLEEsaixHLEgsWixxKXtyZXR1cm57bGVmdDpJKEwsRCxSLEEsaixHLEgsWixxKSxyaWdodDpJKEgsWixqLEcsUixBLEwsRCwxLXEsITApfX1mdW5jdGlvbiBJKEwsRCxSLEEsaixHLEgsWixxLEYpe3ZhciAkPShSLUwpKnErTCxKPShBLUQpKnErRCx0dD0oai1SKSpxK1IsXz0oRy1BKSpxK0Esc3Q9KEgtaikqcStqLGs9KFotRykqcStHLGN0PSh0dC0kKSpxKyQsZnQ9KF8tSikqcStKLFc9KHN0LXR0KSpxK3R0LFU9KGstXykqcStfLFY9KFctY3QpKnErY3QsWD0oVS1mdCkqcStmdDtyZXR1cm4gRj9bVixYLGN0LGZ0LCQsSixMLERdOltMLEQsJCxKLGN0LGZ0LFYsWF19VC5fc3BsaXRDdXJ2ZXM9ZnVuY3Rpb24oTCxEKXtmb3IodmFyIFI9MCxBPTA7UjxEO1IrKyl7dmFyIGo9TFtBXSxHPWIoalswXSxqWzFdLGpbMl0salszXSxqWzRdLGpbNV0sals2XSxqWzddLC41KTtMLnNwbGljZShBLDEpLEwuc3BsaWNlKEEsMCxHLmxlZnQsRy5yaWdodCksQSs9MixBPj1MLmxlbmd0aC0xJiYoQT0wKX19O2Z1bmN0aW9uIFAoTCxEKXtmb3IodmFyIFI9ZnVuY3Rpb24oRyl7dmFyIEg9TFtMLmxlbmd0aC0xXSxaPVtdO0guZm9yRWFjaChmdW5jdGlvbihxKXtaLnB1c2gocS5zbGljZSgwKSl9KSxMLnB1c2goWil9LEE9MDtBPEQ7QSsrKVIoKX1yZXR1cm4gVC5sZXJwPWZ1bmN0aW9uKEwsRCxSKXtyZXR1cm4gVC5fbGVycChULnBhdGgyc2hhcGVzKEwpLFQucGF0aDJzaGFwZXMoRCksUil9LFQuTUlNX0NVUlZFU19DT1VOVD0xMDAsVC5fcHJlcHJvY2Vzc2luZz1mdW5jdGlvbihMLEQpe3ZhciBSPUwubGVuZ3RoLEE9RC5sZW5ndGgsaj1KU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KEwpKSxHPUpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoRCkpO3JldHVybiBSPkE/UChHLFItQSk6UjxBJiZQKGosQS1SKSxqPW8oaixHKSxqLmZvckVhY2goZnVuY3Rpb24oSCxaKXt2YXIgcT1ILmxlbmd0aCxGPUdbWl0ubGVuZ3RoO3E+Rj9xPFQuTUlNX0NVUlZFU19DT1VOVD8oVC5fc3BsaXRDdXJ2ZXMoSCxULk1JTV9DVVJWRVNfQ09VTlQtcSksVC5fc3BsaXRDdXJ2ZXMoR1taXSxULk1JTV9DVVJWRVNfQ09VTlQtRikpOlQuX3NwbGl0Q3VydmVzKEdbWl0scS1GKTpxPEYmJihGPFQuTUlNX0NVUlZFU19DT1VOVD8oVC5fc3BsaXRDdXJ2ZXMoSCxULk1JTV9DVVJWRVNfQ09VTlQtcSksVC5fc3BsaXRDdXJ2ZXMoR1taXSxULk1JTV9DVVJWRVNfQ09VTlQtRikpOlQuX3NwbGl0Q3VydmVzKEgsRi1xKSl9KSxqLmZvckVhY2goZnVuY3Rpb24oSCxaKXtqW1pdPW4oSCxHW1pdKX0pLFtqLEddfSxULl9sZXJwPWZ1bmN0aW9uKEwsRCxSKXt2YXIgQT1bXTtyZXR1cm4gTC5mb3JFYWNoKGZ1bmN0aW9uKGosRyl7dmFyIEg9W107ai5mb3JFYWNoKGZ1bmN0aW9uKFoscSl7SC5wdXNoKFQubGVycEN1cnZlKFosRFtHXVtxXSxSKSl9KSxBLnB1c2goSCl9KSxBfSxULmFuaW1hdGU9ZnVuY3Rpb24oTCl7dmFyIEQ9VC5wYXRoMnNoYXBlcyhMLmZyb20pLFI9VC5wYXRoMnNoYXBlcyhMLnRvKSxBPVQuX3ByZXByb2Nlc3NpbmcoRCxSKSxqPW5ldyBEYXRlLEc9TC5lbmR8fGZ1bmN0aW9uKCl7fSxIPUwucHJvZ3Jlc3N8fGZ1bmN0aW9uKCl7fSxaPUwuYmVnaW58fGZ1bmN0aW9uKCl7fSxxPUwuZWFzaW5nfHxmdW5jdGlvbihfKXtyZXR1cm4gX30sRj1udWxsLCQ9bnVsbCxKPUwudGltZTtaKEQpO3ZhciB0dD1mdW5jdGlvbiBfKCl7dmFyIHN0PW5ldyBEYXRlLWo7aWYoc3Q+PUopeyQ9UixIKCQsMSksRygkKSxjYW5jZWxBbmltYXRpb25GcmFtZShGKTtyZXR1cm59dmFyIGs9cShzdC9KKTskPVQuX2xlcnAoQVswXSxBWzFdLGspLEgoJCxrKSxGPXJlcXVlc3RBbmltYXRpb25GcmFtZShfKX07dHQoKX0sVH0pfSxmdW5jdGlvbihTLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBjfSk7dmFyIHI9dCg3MSksaT10KDIyMSksaD10KDcyKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3QgZz1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGVEZWZhdWx0IiksdT1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGUiKSxhPVN5bWJvbC5mb3IoInNwcml0ZWpzX2dldEF0dHJpYnV0ZSIpO2NsYXNzIGMgZXh0ZW5kcyByLmRlZmF1bHR7Y29uc3RydWN0b3IoZil7c3VwZXIoZiksdGhpc1tnXSh7ZDoiIixub3JtYWxpemU6ITEsZmlsbENvbG9yOnZvaWQgMCxmaWxsUnVsZToibm9uemVybyIsc3Ryb2tlQ29sb3I6dm9pZCAwLGxpbmVXaWR0aDoxLGxpbmVKb2luOiJtaXRlciIsbGluZUNhcDoiYnV0dCIscm91bmRTZWdtZW50czoyMCxsaW5lRGFzaDp2b2lkIDAsbGluZURhc2hPZmZzZXQ6MCxtaXRlckxpbWl0OjEwLHRleHR1cmU6dm9pZCAwLHRleHR1cmVSZWN0OnZvaWQgMCx0ZXh0dXJlUmVwZWF0OiExLHNvdXJjZVJlY3Q6dm9pZCAwLGNsaXBQYXRoOnZvaWQgMH0pfWdldCBkKCl7cmV0dXJuIHRoaXNbYV0oImQiKX1zZXQgZChmKXt0aGlzW3VdKCJkIixmKX1nZXQgbm9ybWFsaXplKCl7cmV0dXJuIHRoaXNbYV0oIm5vcm1hbGl6ZSIpfXNldCBub3JtYWxpemUoZil7dGhpc1t1XSgibm9ybWFsaXplIiwhIWYpfWdldCBmaWxsQ29sb3IoKXtyZXR1cm4gdGhpc1thXSgiZmlsbENvbG9yIil9c2V0IGZpbGxDb2xvcihmKXt0aGlzW3VdKCJmaWxsQ29sb3IiLE9iamVjdChpLnBhcnNlQ29sb3IpKGYpKX1nZXQgZmlsbFJ1bGUoKXtyZXR1cm4gdGhpc1thXSgiZmlsbFJ1bGUiKX1zZXQgZmlsbFJ1bGUoZil7aWYoZiE9bnVsbCYmZiE9PSJub256ZXJvIiYmZiE9PSJldmVub2RkIil0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIGZpbGwgcnVsZS4iKTt0aGlzW3VdKCJmaWxsUnVsZSIsZil9Z2V0IHN0cm9rZUNvbG9yKCl7cmV0dXJuIHRoaXNbYV0oInN0cm9rZUNvbG9yIil9c2V0IHN0cm9rZUNvbG9yKGYpe3RoaXNbdV0oInN0cm9rZUNvbG9yIixPYmplY3QoaS5wYXJzZUNvbG9yKShmKSl9Z2V0IGxpbmVXaWR0aCgpe3JldHVybiB0aGlzW2FdKCJsaW5lV2lkdGgiKX1zZXQgbGluZVdpZHRoKGYpe3RoaXNbdV0oImxpbmVXaWR0aCIsT2JqZWN0KGgudG9OdW1iZXIpKGYpKX1nZXQgbGluZUpvaW4oKXtyZXR1cm4gdGhpc1thXSgibGluZUpvaW4iKX1zZXQgbGluZUpvaW4oZil7aWYoZiE9bnVsbCYmZiE9PSJtaXRlciImJmYhPT0iYmV2ZWwiJiZmIT09InJvdW5kIil0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIGxpbmVKb2luIHR5cGUuIik7dGhpc1t1XSgibGluZUpvaW4iLGYpfWdldCBsaW5lQ2FwKCl7cmV0dXJuIHRoaXNbYV0oImxpbmVDYXAiKX1zZXQgbGluZUNhcChmKXtpZihmIT1udWxsJiZmIT09ImJ1dHQiJiZmIT09InNxdWFyZSImJmYhPT0icm91bmQiKXRocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgbGluZUNhcCB0eXBlLiIpO3RoaXNbdV0oImxpbmVDYXAiLGYpfWdldCBsaW5lRGFzaCgpe3JldHVybiB0aGlzW2FdKCJsaW5lRGFzaCIpfXNldCBsaW5lRGFzaChmKXtmPU9iamVjdChoLnRvQXJyYXkpKGYsITApLGYhPW51bGwmJiFBcnJheS5pc0FycmF5KGYpJiYoZj1bZl0pLHRoaXNbdV0oImxpbmVEYXNoIixmP2YubWFwKGgudG9OdW1iZXIpOm51bGwpfWdldCBsaW5lRGFzaE9mZnNldCgpe3JldHVybiB0aGlzW2FdKCJsaW5lRGFzaE9mZnNldCIpfXNldCBsaW5lRGFzaE9mZnNldChmKXt0aGlzW3VdKCJsaW5lRGFzaE9mZnNldCIsT2JqZWN0KGgudG9OdW1iZXIpKGYpKX1nZXQgbWl0ZXJMaW1pdCgpe3JldHVybiB0aGlzW2FdKCJtaXRlckxpbWl0Iil9c2V0IG1pdGVyTGltaXQoZil7dGhpc1t1XSgibWl0ZXJMaW1pdCIsT2JqZWN0KGgudG9OdW1iZXIpKGYpKX1nZXQgcm91bmRTZWdtZW50cygpe3JldHVybiB0aGlzW2FdKCJyb3VuZFNlZ21lbnRzIil9c2V0IHJvdW5kU2VnbWVudHMoZil7dGhpc1t1XSgicm91bmRTZWdtZW50cyIsZil9Z2V0IHRleHR1cmUoKXtyZXR1cm4gdGhpc1thXSgidGV4dHVyZSIpfXNldCB0ZXh0dXJlKGYpe3RoaXNbdV0oInRleHR1cmUiLGYpfWdldCB0ZXh0dXJlUmVjdCgpe3JldHVybiB0aGlzW2FdKCJ0ZXh0dXJlUmVjdCIpfXNldCB0ZXh0dXJlUmVjdChmKXt0aGlzW3VdKCJ0ZXh0dXJlUmVjdCIsZil9Z2V0IHNvdXJjZVJlY3QoKXtyZXR1cm4gdGhpc1thXSgic291cmNlUmVjdCIpfXNldCBzb3VyY2VSZWN0KGYpe3RoaXNbdV0oInNvdXJjZVJlY3QiLGYpfWdldCB0ZXh0dXJlUmVwZWF0KCl7cmV0dXJuIHRoaXNbYV0oInRleHR1cmVSZXBlYXQiKX1zZXQgdGV4dHVyZVJlcGVhdChmKXt0aGlzW3VdKCJ0ZXh0dXJlUmVwZWF0IiwhIWYpfWdldCBjbGlwUGF0aCgpe3JldHVybiB0aGlzW2FdKCJjbGlwUGF0aCIpfXNldCBjbGlwUGF0aChmKXt0aGlzW3VdKCJjbGlwUGF0aCIsZil9fX0sZnVuY3Rpb24oUyxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gdX0pO3ZhciByPXQoMjI2KSxpPXQoMjEzKSxoPXQoMjMwKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gZyhhLGMseCl7cmV0dXJuIGMgaW4gYT9PYmplY3QuZGVmaW5lUHJvcGVydHkoYSxjLHt2YWx1ZTp4LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6YVtjXT14LGF9Y2xhc3MgdSBleHRlbmRzIHIuZGVmYXVsdHtnZXQgaXNWaXNpYmxlKCl7Y29uc3R7d2lkdGg6YyxoZWlnaHQ6eH09dGhpcy5hdHRyaWJ1dGVzO3JldHVybiBjPjAmJng+MCYmc3VwZXIuaXNWaXNpYmxlfX1nKHUsIkF0dHIiLGguZGVmYXVsdCksaS5kZWZhdWx0LnJlZ2lzdGVyTm9kZSh1LCJyZWN0Iil9LGZ1bmN0aW9uKFMsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIHh9KTt2YXIgcj10KDIyOCksaT10KDcyKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3QgaD1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGVEZWZhdWx0IiksZz1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGUiKSx1PVN5bWJvbC5mb3IoInNwcml0ZWpzX2dldEF0dHJpYnV0ZSIpLGE9U3ltYm9sLmZvcigic3ByaXRlanNfZGVjbGFyZUFsaWFzIik7ZnVuY3Rpb24gYyhmKXtjb25zdHt3aWR0aDp2LGhlaWdodDpwfT1mO3JldHVybmBNMCAwTCR7dn0gMEwke3Z9ICR7cH1MMCAke3B9WmB9Y2xhc3MgeCBleHRlbmRzIHIuZGVmYXVsdHtjb25zdHJ1Y3Rvcih2KXtzdXBlcih2KSx0aGlzW2hdKHt3aWR0aDowLGhlaWdodDowfSksdGhpc1thXSgic2l6ZSIpfWdldCBkKCl7cmV0dXJuIHRoaXNbdV0oImQiKX1zZXQgZCh2KXt9Z2V0IHdpZHRoKCl7cmV0dXJuIHRoaXNbdV0oIndpZHRoIil9c2V0IHdpZHRoKHYpe2lmKHY9T2JqZWN0KGkudG9OdW1iZXIpKHYpLHRoaXNbZ10oIndpZHRoIix2KSl7Y29uc3QgcD1jKHRoaXMpO3RoaXNbZ10oImQiLHApfX1nZXQgaGVpZ2h0KCl7cmV0dXJuIHRoaXNbdV0oImhlaWdodCIpfXNldCBoZWlnaHQodil7aWYodj1PYmplY3QoaS50b051bWJlcikodiksdGhpc1tnXSgiaGVpZ2h0Iix2KSl7Y29uc3QgcD1jKHRoaXMpO3RoaXNbZ10oImQiLHApfX1nZXQgc2l6ZSgpe3JldHVyblt0aGlzLndpZHRoLHRoaXMuaGVpZ2h0XX1zZXQgc2l6ZSh2KXt2PU9iamVjdChpLnRvQXJyYXkpKHYpLEFycmF5LmlzQXJyYXkodil8fCh2PVt2LHZdKSx0aGlzLndpZHRoPXZbMF0sdGhpcy5oZWlnaHQ9dlsxXX19fSxmdW5jdGlvbihTLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiB1fSk7dmFyIHI9dCgyMzIpLGk9dCgyMTMpLGg9dCgyMzUpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBnKGEsYyx4KXtyZXR1cm4gYyBpbiBhP09iamVjdC5kZWZpbmVQcm9wZXJ0eShhLGMse3ZhbHVlOngsZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTphW2NdPXgsYX1jbGFzcyB1IGV4dGVuZHMgci5kZWZhdWx0e2dldCBpc1Zpc2libGUoKXtjb25zdHtzaWRlczpjfT10aGlzLmF0dHJpYnV0ZXM7cmV0dXJuIGNbMF0+MCYmY1sxXT4wJiZzdXBlci5pc1Zpc2libGV9fWcodSwiQXR0ciIsaC5kZWZhdWx0KSxpLmRlZmF1bHQucmVnaXN0ZXJOb2RlKHUsInRyaWFuZ2xlIil9LGZ1bmN0aW9uKFMsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIHV9KTt2YXIgcj10KDIyNiksaT10KDIxMyksaD10KDIzMyk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIGcoYSxjLHgpe3JldHVybiBjIGluIGE/T2JqZWN0LmRlZmluZVByb3BlcnR5KGEsYyx7dmFsdWU6eCxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOmFbY109eCxhfWNsYXNzIHUgZXh0ZW5kcyByLmRlZmF1bHR7Z2V0IGlzVmlzaWJsZSgpe2NvbnN0e3BvaW50czpjfT10aGlzLmF0dHJpYnV0ZXM7cmV0dXJuIGMubGVuZ3RoPjAmJnN1cGVyLmlzVmlzaWJsZX19Zyh1LCJBdHRyIixoLmRlZmF1bHQpLGkuZGVmYXVsdC5yZWdpc3Rlck5vZGUodSwicG9seWxpbmUiKX0sZnVuY3Rpb24oUyxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gZn0pO3ZhciByPXQoMjI4KSxpPXQoNzIpLGg9dCgyMzQpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCBnPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZURlZmF1bHQiKSx1PVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZSIpLGE9U3ltYm9sLmZvcigic3ByaXRlanNfZ2V0QXR0cmlidXRlIiksYz1TeW1ib2wuZm9yKCJzcHJpdGVqc19kZWNsYXJlQWxpYXMiKTtmdW5jdGlvbiB4KHYpe2NvbnN0e3BvaW50czpwLHNtb290aDpDLHNtb290aFJhbmdlOk0sY2xvc2U6bX09dix5PVtdO2ZvcihsZXQgbz0wO288cC5sZW5ndGg7bys9Mil5LnB1c2goW3Bbb10scFtvKzFdXSk7bGV0IG49IiI7cmV0dXJuIEM/bj1PYmplY3QoaC5tYWtlU21vb3RoQ3VydmVMaW5lKSh5LE0pOnkubGVuZ3RoJiYobj1gTSR7eS5tYXAobz0+by5qb2luKCIgIikpLmpvaW4oIkwiKX1gKSxuJiZtJiYobis9IloiKSxufWNsYXNzIGYgZXh0ZW5kcyByLmRlZmF1bHR7Y29uc3RydWN0b3IocCl7c3VwZXIocCksdGhpc1tnXSh7cG9pbnRzOltdLHNtb290aDohMSxzbW9vdGhSYW5nZTpbMF0sY2xvc2VUeXBlOiJub25lIn0pLHRoaXNbY10oImNsb3NlIil9Z2V0IGQoKXtyZXR1cm4gdGhpc1thXSgiZCIpfXNldCBkKHApe31nZXQgY2xvc2UoKXtyZXR1cm4gdGhpcy5jbG9zZVR5cGUhPT0ibm9uZSJ9c2V0IGNsb3NlKHApe3A9cD8ibm9ybWFsIjoibm9uZSIsdGhpcy5jbG9zZVR5cGU9cH1nZXQgY2xvc2VUeXBlKCl7cmV0dXJuIHRoaXNbYV0oImNsb3NlVHlwZSIpfXNldCBjbG9zZVR5cGUocCl7aWYocCE9bnVsbCYmcCE9PSJub25lIiYmcCE9PSJub3JtYWwiKXRocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgY2xvc2VUeXBlIHR5cGUuIik7aWYodGhpc1t1XSgiY2xvc2VUeXBlIixwKSl7Y29uc3QgQz14KHRoaXMpO3RoaXNbdV0oImQiLEMpfX1nZXQgc21vb3RoKCl7cmV0dXJuIHRoaXNbYV0oInNtb290aCIpfXNldCBzbW9vdGgocCl7aWYodGhpc1t1XSgic21vb3RoIixwKSl7Y29uc3QgQz14KHRoaXMpO3RoaXNbdV0oImQiLEMpfX1nZXQgc21vb3RoUmFuZ2UoKXtyZXR1cm4gdGhpc1thXSgic21vb3RoUmFuZ2UiKX1zZXQgc21vb3RoUmFuZ2UocCl7aWYocCYmIUFycmF5LmlzQXJyYXkocCkmJihwPVtwXSksdGhpc1t1XSgic21vb3RoUmFuZ2UiLHApJiZ0aGlzLnNtb290aCl7Y29uc3QgQz14KHRoaXMpO3RoaXNbdV0oImQiLEMpfX1nZXQgcG9pbnRzKCl7cmV0dXJuIHRoaXNbYV0oInBvaW50cyIpfXNldCBwb2ludHMocCl7aWYocD1PYmplY3QoaS50b0FycmF5KShwKSxBcnJheS5pc0FycmF5KHApJiYocD1wLnJlZHVjZSgoQyxNKT0+QXJyYXkuaXNBcnJheShNKT9bLi4uQywuLi5NLm1hcChtPT5PYmplY3QoaS50b051bWJlcikobSkpXTpbLi4uQyxPYmplY3QoaS50b051bWJlcikoTSldLFtdKSksdGhpc1t1XSgicG9pbnRzIixwKSl7Y29uc3QgQz14KHRoaXMpO3RoaXNbdV0oImQiLEMpfX19fSxmdW5jdGlvbihTLGUsdCl7dC5yKGUpLHQuZChlLCJtYWtlU21vb3RoQ3VydmVMaW5lIixmdW5jdGlvbigpe3JldHVybiByfSksdCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIHIoaSxoPVswXSl7ZnVuY3Rpb24gZyhjLHg9LjE2OCxmPS4xNjgpe2xldCB2LHAsQyxNO2lmKChpW2NdLng9PT1pW2MrMV0ueHx8aVtjXS55PT09aVtjKzFdLnkpJiYoeD0wLGY9MCksYzwxPyh2PWlbMF0ueCsoaVsxXS54LWlbMF0ueCkqeCxwPWlbMF0ueSsoaVsxXS55LWlbMF0ueSkqeCk6KHY9aVtjXS54KyhpW2MrMV0ueC1pW2MtMV0ueCkqeCxwPWlbY10ueSsoaVtjKzFdLnktaVtjLTFdLnkpKngpLGM+aS5sZW5ndGgtMyl7Y29uc3QgbT1pLmxlbmd0aC0xO0M9aVttXS54LShpW21dLngtaVttLTFdLngpKmYsTT1pW21dLnktKGlbbV0ueS1pW20tMV0ueSkqZn1lbHNlIEM9aVtjKzFdLngtKGlbYysyXS54LWlbY10ueCkqZixNPWlbYysxXS55LShpW2MrMl0ueS1pW2NdLnkpKmY7cmV0dXJuW3t4OnYseTpwfSx7eDpDLHk6TX1dfWk9aS5tYXAoKFtjLHhdKT0+KHt4OmMseTp4fSkpO2xldCB1PSIiLGE9MDtyZXR1cm4gaS5mb3JFYWNoKChjLHgpPT57aWYoeD09PTApdSs9YE0ke2MueH0gJHtjLnl9YDtlbHNle2Zvcig7eD5oW2FdOylhKys7aWYoYSUyKXtjb25zdFtmLHZdPWcoeC0xKTt1Kz1gQyR7W2YueCxmLnksdi54LHYueSxjLngsYy55XS5qb2luKCIgIil9YH1lbHNlIHUrPWBMJHtjLnh9ICR7Yy55fWB9fSksdX19LGZ1bmN0aW9uKFMsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIGN9KTt2YXIgcj10KDIzMyksaT10KDcyKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3QgaD1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGVEZWZhdWx0IiksZz1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGUiKSx1PVN5bWJvbC5mb3IoInNwcml0ZWpzX2dldEF0dHJpYnV0ZSIpO2Z1bmN0aW9uIGEoeCl7Y29uc3RbZix2XT14LnNpZGVzO2xldCBwPXguYW5nbGUlMzYwO3JldHVybiBwPDAmJihwKz0zNjApLHA9TWF0aC5QSSpwLzE4MCxbMCwwLGYsMCx2Kk1hdGguY29zKHApLHYqTWF0aC5zaW4ocCldfWNsYXNzIGMgZXh0ZW5kcyByLmRlZmF1bHR7Y29uc3RydWN0b3IoZil7c3VwZXIoZiksdGhpc1toXSh7c2lkZXM6WzAsMF0sYW5nbGU6NjAsY2xvc2VUeXBlOiJub3JtYWwifSl9Z2V0IHBvaW50cygpe3JldHVybiBzdXBlci5wb2ludHN9c2V0IHBvaW50cyhmKXt9Z2V0IHNpZGVzKCl7cmV0dXJuIHRoaXNbdV0oInNpZGVzIil9c2V0IHNpZGVzKGYpe2lmKGY9T2JqZWN0KGkudG9BcnJheSkoZiwhMCksZiE9bnVsbCYmIUFycmF5LmlzQXJyYXkoZikmJihmPVtmLGZdKSx0aGlzW2ddKCJzaWRlcyIsZikpe2NvbnN0IHY9YSh0aGlzKTtzdXBlci5wb2ludHM9dn19Z2V0IGFuZ2xlKCl7cmV0dXJuIHRoaXNbdV0oImFuZ2xlIil9c2V0IGFuZ2xlKGYpe2lmKGY9T2JqZWN0KGkudG9OdW1iZXIpKGYpLHRoaXNbZ10oImFuZ2xlIixmKSl7Y29uc3Qgdj1hKHRoaXMpO3N1cGVyLnBvaW50cz12fX19fSxmdW5jdGlvbihTLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiB1fSk7dmFyIHI9dCgyMzIpLGk9dCgyMTMpLGg9dCgyMzcpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBnKGEsYyx4KXtyZXR1cm4gYyBpbiBhP09iamVjdC5kZWZpbmVQcm9wZXJ0eShhLGMse3ZhbHVlOngsZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTphW2NdPXgsYX1jbGFzcyB1IGV4dGVuZHMgci5kZWZhdWx0e2dldCBpc1Zpc2libGUoKXtjb25zdHtzaWRlczpjfT10aGlzLmF0dHJpYnV0ZXM7cmV0dXJuIGNbMF0+MCYmY1sxXT4wJiZzdXBlci5pc1Zpc2libGV9fWcodSwiQXR0ciIsaC5kZWZhdWx0KSxpLmRlZmF1bHQucmVnaXN0ZXJOb2RlKHUsInBhcmFsbGVsIil9LGZ1bmN0aW9uKFMsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIGN9KTt2YXIgcj10KDIzMyksaT10KDcyKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3QgaD1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGVEZWZhdWx0IiksZz1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGUiKSx1PVN5bWJvbC5mb3IoInNwcml0ZWpzX2dldEF0dHJpYnV0ZSIpO2Z1bmN0aW9uIGEoeCl7Y29uc3RbZix2XT14LnNpZGVzO2xldCBwPXguYW5nbGUlMzYwO3A8MCYmKHArPTM2MCkscD1NYXRoLlBJKnAvMTgwO2NvbnN0IEM9dipNYXRoLmNvcyhwKSxNPXYqTWF0aC5zaW4ocCk7cmV0dXJuWzAsMCxmLDAsQytmLE0sQyxNXX1jbGFzcyBjIGV4dGVuZHMgci5kZWZhdWx0e2NvbnN0cnVjdG9yKGYpe3N1cGVyKGYpLHRoaXNbaF0oe3NpZGVzOlswLDBdLGFuZ2xlOjkwLGNsb3NlVHlwZToibm9ybWFsIn0pfWdldCBwb2ludHMoKXtyZXR1cm4gc3VwZXIucG9pbnRzfXNldCBwb2ludHMoZil7fWdldCBzaWRlcygpe3JldHVybiB0aGlzW3VdKCJzaWRlcyIpfXNldCBzaWRlcyhmKXtpZihmPU9iamVjdChpLnRvQXJyYXkpKGYsITApLGYhPW51bGwmJiFBcnJheS5pc0FycmF5KGYpJiYoZj1bZixmXSksdGhpc1tnXSgic2lkZXMiLGYpKXtjb25zdCB2PWEodGhpcyk7c3VwZXIucG9pbnRzPXZ9fWdldCBhbmdsZSgpe3JldHVybiB0aGlzW3VdKCJhbmdsZSIpfXNldCBhbmdsZShmKXtpZihmPU9iamVjdChpLnRvTnVtYmVyKShmKSx0aGlzW2ddKCJhbmdsZSIsZikpe2NvbnN0IHY9YSh0aGlzKTtzdXBlci5wb2ludHM9dn19fX0sZnVuY3Rpb24oUyxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gdX0pO3ZhciByPXQoMjMyKSxpPXQoMjEzKSxoPXQoMjM5KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gZyhhLGMseCl7cmV0dXJuIGMgaW4gYT9PYmplY3QuZGVmaW5lUHJvcGVydHkoYSxjLHt2YWx1ZTp4LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6YVtjXT14LGF9Y2xhc3MgdSBleHRlbmRzIHIuZGVmYXVsdHt9Zyh1LCJBdHRyIixoLmRlZmF1bHQpLGkuZGVmYXVsdC5yZWdpc3Rlck5vZGUodSwicmVndWxhciIpfSxmdW5jdGlvbihTLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBjfSk7dmFyIHI9dCgyMzMpLGk9dCg3Mik7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IGg9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlRGVmYXVsdCIpLGc9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlIiksdT1TeW1ib2wuZm9yKCJzcHJpdGVqc19nZXRBdHRyaWJ1dGUiKTtmdW5jdGlvbiBhKHgpe2NvbnN0e2VkZ2VzOmYscmFkaXVzOnYsb2Zmc2V0QW5nbGU6cH09eCxDPU1hdGguUEkqcC8xODAtLjUqTWF0aC5QSTtpZihmPDN8fHY8PTApcmV0dXJuW107Y29uc3QgTT1bXTtmb3IobGV0IG09MDttPGY7bSsrKXtjb25zdCB5PW0qMipNYXRoLlBJL2YrQyxuPXYqTWF0aC5jb3MoeSksbz12Kk1hdGguc2luKHkpO00ucHVzaChuLG8pfXJldHVybiBNfWNsYXNzIGMgZXh0ZW5kcyByLmRlZmF1bHR7Y29uc3RydWN0b3IoZil7c3VwZXIoZiksdGhpc1toXSh7ZWRnZXM6MyxyYWRpdXM6MCxvZmZzZXRBbmdsZTowLGNsb3NlVHlwZToibm9ybWFsIn0pfWdldCBwb2ludHMoKXtyZXR1cm4gc3VwZXIucG9pbnRzfXNldCBwb2ludHMoZil7fWdldCBlZGdlcygpe3JldHVybiB0aGlzW3VdKCJlZGdlcyIpfXNldCBlZGdlcyhmKXtpZihmPU9iamVjdChpLnRvTnVtYmVyKShmKSx0aGlzW2ddKCJlZGdlcyIsZikpe2NvbnN0IHY9YSh0aGlzKTtzdXBlci5wb2ludHM9dn19Z2V0IHJhZGl1cygpe3JldHVybiB0aGlzW3VdKCJyYWRpdXMiKX1zZXQgcmFkaXVzKGYpe2lmKGY9T2JqZWN0KGkudG9OdW1iZXIpKGYpLHRoaXNbZ10oInJhZGl1cyIsZikpe2NvbnN0IHY9YSh0aGlzKTtzdXBlci5wb2ludHM9dn19Z2V0IG9mZnNldEFuZ2xlKCl7cmV0dXJuIHRoaXNbdV0oIm9mZnNldEFuZ2xlIil9c2V0IG9mZnNldEFuZ2xlKGYpe2lmKGY9T2JqZWN0KGkudG9OdW1iZXIpKGYpLHRoaXNbZ10oIm9mZnNldEFuZ2xlIixmKSl7Y29uc3Qgdj1hKHRoaXMpO3N1cGVyLnBvaW50cz12fX19fSxmdW5jdGlvbihTLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiB1fSk7dmFyIHI9dCgyMzIpLGk9dCgyMTMpLGg9dCgyNDEpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBnKGEsYyx4KXtyZXR1cm4gYyBpbiBhP09iamVjdC5kZWZpbmVQcm9wZXJ0eShhLGMse3ZhbHVlOngsZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTphW2NdPXgsYX1jbGFzcyB1IGV4dGVuZHMgci5kZWZhdWx0e31nKHUsIkF0dHIiLGguZGVmYXVsdCksaS5kZWZhdWx0LnJlZ2lzdGVyTm9kZSh1LCJzdGFyIil9LGZ1bmN0aW9uKFMsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIGN9KTt2YXIgcj10KDIzMyksaT10KDcyKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3QgaD1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGVEZWZhdWx0IiksZz1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGUiKSx1PVN5bWJvbC5mb3IoInNwcml0ZWpzX2dldEF0dHJpYnV0ZSIpO2Z1bmN0aW9uIGEoeCl7Y29uc3R7YW5nbGVzOmYsaW5uZXJSYWRpdXM6dixvdXRlclJhZGl1czpwLG9mZnNldEFuZ2xlOkN9PXgsTT1NYXRoLlBJKkMvMTgwLS41Kk1hdGguUEk7aWYoZjwzfHx2PD0wfHxwPD0wKXJldHVybltdO2NvbnN0IG09W107Zm9yKGxldCB5PTA7eTxmKjI7eSsrKXtjb25zdCBuPXkqTWF0aC5QSS9mK00sbz15JTI/djpwLHM9bypNYXRoLmNvcyhuKSxsPW8qTWF0aC5zaW4obik7bS5wdXNoKHMsbCl9cmV0dXJuIG19Y2xhc3MgYyBleHRlbmRzIHIuZGVmYXVsdHtjb25zdHJ1Y3RvcihmKXtzdXBlcihmKSx0aGlzW2hdKHthbmdsZXM6NSxpbm5lclJhZGl1czowLG91dGVyUmFkaXVzOjAsb2Zmc2V0QW5nbGU6MCxjbG9zZVR5cGU6Im5vcm1hbCJ9KX1nZXQgcG9pbnRzKCl7cmV0dXJuIHN1cGVyLnBvaW50c31zZXQgcG9pbnRzKGYpe31nZXQgYW5nbGVzKCl7cmV0dXJuIHRoaXNbdV0oImFuZ2xlcyIpfXNldCBhbmdsZXMoZil7aWYoZj1PYmplY3QoaS50b051bWJlcikoZiksdGhpc1tnXSgiYW5nbGVzIixmKSl7Y29uc3Qgdj1hKHRoaXMpO3N1cGVyLnBvaW50cz12fX1nZXQgaW5uZXJSYWRpdXMoKXtyZXR1cm4gdGhpc1t1XSgiaW5uZXJSYWRpdXMiKX1zZXQgaW5uZXJSYWRpdXMoZil7aWYoZj1PYmplY3QoaS50b051bWJlcikoZiksdGhpc1tnXSgiaW5uZXJSYWRpdXMiLGYpKXtjb25zdCB2PWEodGhpcyk7c3VwZXIucG9pbnRzPXZ9fWdldCBvdXRlclJhZGl1cygpe3JldHVybiB0aGlzW3VdKCJvdXRlclJhZGl1cyIpfXNldCBvdXRlclJhZGl1cyhmKXtpZihmPU9iamVjdChpLnRvTnVtYmVyKShmKSx0aGlzW2ddKCJvdXRlclJhZGl1cyIsZikpe2NvbnN0IHY9YSh0aGlzKTtzdXBlci5wb2ludHM9dn19Z2V0IHJhZGl1cygpe3JldHVyblt0aGlzLmlubmVyUmFkaXVzLHRoaXMub3V0ZXJSYWRpdXNdfXNldCByYWRpdXMoZil7Zj1PYmplY3QoaS50b0FycmF5KShmLCEwKSxBcnJheS5pc0FycmF5KGYpfHwoZj1bZixmXSksdGhpcy5pbm5lclJhZGl1cz1mWzBdLHRoaXMub3V0ZXJSYWRpdXM9ZlsxXX1nZXQgb2Zmc2V0QW5nbGUoKXtyZXR1cm4gdGhpc1t1XSgib2Zmc2V0QW5nbGUiKX1zZXQgb2Zmc2V0QW5nbGUoZil7aWYoZj1PYmplY3QoaS50b051bWJlcikoZiksdGhpc1tnXSgib2Zmc2V0QW5nbGUiLGYpKXtjb25zdCB2PWEodGhpcyk7c3VwZXIucG9pbnRzPXZ9fX19LGZ1bmN0aW9uKFMsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIHV9KTt2YXIgcj10KDIyNiksaT10KDIxMyksaD10KDI0Myk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIGcoYSxjLHgpe3JldHVybiBjIGluIGE/T2JqZWN0LmRlZmluZVByb3BlcnR5KGEsYyx7dmFsdWU6eCxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOmFbY109eCxhfWNsYXNzIHUgZXh0ZW5kcyByLmRlZmF1bHR7Z2V0IGlzVmlzaWJsZSgpe2NvbnN0e3JhZGl1c1g6YyxyYWRpdXNZOngsc3RhcnRBbmdsZTpmLGVuZEFuZ2xlOnZ9PXRoaXMuYXR0cmlidXRlcztyZXR1cm4gYz4wJiZ4PjAmJmYhPT12JiZzdXBlci5pc1Zpc2libGV9fWcodSwiQXR0ciIsaC5kZWZhdWx0KSxpLmRlZmF1bHQucmVnaXN0ZXJOb2RlKHUsImVsbGlwc2UiKX0sZnVuY3Rpb24oUyxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gZn0pO3ZhciByPXQoMTIpLGk9dCgyMjgpLGg9dCg3Mik7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IGc9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlRGVmYXVsdCIpLHU9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlIiksYT1TeW1ib2wuZm9yKCJzcHJpdGVqc19nZXRBdHRyaWJ1dGUiKSxjPVN5bWJvbC5mb3IoInNwcml0ZWpzX2RlY2xhcmVBbGlhcyIpO2Z1bmN0aW9uIHgodil7Y29uc3R7cmFkaXVzWDpwLHJhZGl1c1k6QyxzdGFydEFuZ2xlOk0sZW5kQW5nbGU6bSxkaXJlY3Rpb246eSxjbG9zZVR5cGU6bn09dixvPXk9PT0iYW5pdGNsb2Nrd2lzZSIscz1uZXcgci5GaWd1cmUyRDtyZXR1cm4gbj09PSJzZWN0b3IiJiZzLm1vdmVUbygwLDApLHMuZWxsaXBzZSgwLDAscCxDLDAsTWF0aC5QSSpNLzE4MCxNYXRoLlBJKm0vMTgwLG8pLG4hPT0ibm9uZSImJnMuY2xvc2VQYXRoKCkscy5wYXRoLnJlZHVjZSgoVCxiKT0+VCtiLmpvaW4oIiAiKSwiIil9Y2xhc3MgZiBleHRlbmRzIGkuZGVmYXVsdHtjb25zdHJ1Y3RvcihwKXtzdXBlcihwKSx0aGlzW2ddKHtyYWRpdXNYOjAscmFkaXVzWTowLHN0YXJ0QW5nbGU6MCxlbmRBbmdsZTozNjAsZGlyZWN0aW9uOiJjbG9ja3dpc2UiLGNsb3NlVHlwZToibm9uZSJ9KSx0aGlzW2NdKCJyYWRpdXMiLCJhbmdsZSIpfWdldCBkKCl7cmV0dXJuIHRoaXNbYV0oImQiKX1zZXQgZChwKXt9Z2V0IHJhZGl1c1goKXtyZXR1cm4gdGhpc1thXSgicmFkaXVzWCIpfXNldCByYWRpdXNYKHApe2lmKHA9T2JqZWN0KGgudG9OdW1iZXIpKHApLHRoaXNbdV0oInJhZGl1c1giLHApKXtjb25zdCBDPXgodGhpcyk7dGhpc1t1XSgiZCIsQyl9fWdldCByYWRpdXNZKCl7cmV0dXJuIHRoaXNbYV0oInJhZGl1c1kiKX1zZXQgcmFkaXVzWShwKXtpZihwPU9iamVjdChoLnRvTnVtYmVyKShwKSx0aGlzW3VdKCJyYWRpdXNZIixwKSl7Y29uc3QgQz14KHRoaXMpO3RoaXNbdV0oImQiLEMpfX1nZXQgcmFkaXVzKCl7cmV0dXJuW3RoaXMucmFkaXVzWCx0aGlzLnJhZGl1c1ldfXNldCByYWRpdXMocCl7cD1PYmplY3QoaC50b0FycmF5KShwLCEwKSxBcnJheS5pc0FycmF5KHApfHwocD1bcCxwXSksdGhpcy5yYWRpdXNYPXBbMF0sdGhpcy5yYWRpdXNZPXBbMV19Z2V0IGFuZ2xlKCl7cmV0dXJuW3RoaXMuc3RhcnRBbmdsZSx0aGlzLmVuZEFuZ2xlXX1zZXQgYW5nbGUocCl7cD1PYmplY3QoaC50b0FycmF5KShwKSxBcnJheS5pc0FycmF5KHApfHwocD1bcCxwXSksdGhpcy5zdGFydEFuZ2xlPXBbMF0sdGhpcy5lbmRBbmdsZT1wWzFdfWdldCBkaXJlY3Rpb24oKXtyZXR1cm4gdGhpc1thXSgiZGlyZWN0aW9uIil9c2V0IGRpcmVjdGlvbihwKXtpZihwIT1udWxsJiZwIT09ImNsb2Nrd2lzZSImJnAhPT0iYW50aWNsb2Nrd2lzZSIpdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCBkaXJlY3Rpb24gdHlwZS4iKTt0aGlzW3VdKCJkaXJlY3Rpb24iLHApfWdldCBzdGFydEFuZ2xlKCl7cmV0dXJuIHRoaXNbYV0oInN0YXJ0QW5nbGUiKX1zZXQgc3RhcnRBbmdsZShwKXtpZihwPU9iamVjdChoLnRvTnVtYmVyKShwKSx0aGlzW3VdKCJzdGFydEFuZ2xlIixwKSl7Y29uc3QgQz14KHRoaXMpO3RoaXNbdV0oImQiLEMpfX1nZXQgZW5kQW5nbGUoKXtyZXR1cm4gdGhpc1thXSgiZW5kQW5nbGUiKX1zZXQgZW5kQW5nbGUocCl7aWYocD1PYmplY3QoaC50b051bWJlcikocCksdGhpc1t1XSgiZW5kQW5nbGUiLHApKXtjb25zdCBDPXgodGhpcyk7dGhpc1t1XSgiZCIsQyl9fWdldCBjbG9zZVR5cGUoKXtyZXR1cm4gdGhpc1thXSgiY2xvc2VUeXBlIil9c2V0IGNsb3NlVHlwZShwKXtpZihwIT1udWxsJiZwIT09Im5vbmUiJiZwIT09InNlY3RvciImJnAhPT0ibm9ybWFsIil0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIGNsb3NlVHlwZSB0eXBlLiIpO2lmKHRoaXNbdV0oImNsb3NlVHlwZSIscCkpe2NvbnN0IEM9eCh0aGlzKTt0aGlzW3VdKCJkIixDKX19fX0sZnVuY3Rpb24oUyxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gdX0pO3ZhciByPXQoMjQyKSxpPXQoMjEzKSxoPXQoMjQ1KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gZyhhLGMseCl7cmV0dXJuIGMgaW4gYT9PYmplY3QuZGVmaW5lUHJvcGVydHkoYSxjLHt2YWx1ZTp4LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6YVtjXT14LGF9Y2xhc3MgdSBleHRlbmRzIHIuZGVmYXVsdHt9Zyh1LCJBdHRyIixoLmRlZmF1bHQpLGkuZGVmYXVsdC5yZWdpc3Rlck5vZGUodSwiYXJjIil9LGZ1bmN0aW9uKFMsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIGh9KTt2YXIgcj10KDI0MyksaT10KDcyKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y2xhc3MgaCBleHRlbmRzIHIuZGVmYXVsdHtnZXQgcmFkaXVzKCl7cmV0dXJuIHN1cGVyLnJhZGl1c1h9c2V0IHJhZGl1cyh1KXt1PU9iamVjdChpLnRvTnVtYmVyKSh1KSxzdXBlci5yYWRpdXNYPXUsc3VwZXIucmFkaXVzWT11fX19LGZ1bmN0aW9uKFMsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIHV9KTt2YXIgcj10KDIyNiksaT10KDIxMyksaD10KDI0Nyk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIGcoYSxjLHgpe3JldHVybiBjIGluIGE/T2JqZWN0LmRlZmluZVByb3BlcnR5KGEsYyx7dmFsdWU6eCxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOmFbY109eCxhfWNsYXNzIHUgZXh0ZW5kcyByLmRlZmF1bHR7Z2V0IGlzVmlzaWJsZSgpe2NvbnN0e2lubmVyUmFkaXVzOmMsb3V0ZXJSYWRpdXM6eCxzdGFydEFuZ2xlOmYsZW5kQW5nbGU6dn09dGhpcy5hdHRyaWJ1dGVzO3JldHVybihjPjB8fHg+MCkmJmYhPT12JiZzdXBlci5pc1Zpc2libGV9fWcodSwiQXR0ciIsaC5kZWZhdWx0KSxpLmRlZmF1bHQucmVnaXN0ZXJOb2RlKHUsInJpbmciKX0sZnVuY3Rpb24oUyxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gZn0pO3ZhciByPXQoMTIpLGk9dCgyMjgpLGg9dCg3Mik7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IGc9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlRGVmYXVsdCIpLHU9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlIiksYT1TeW1ib2wuZm9yKCJzcHJpdGVqc19nZXRBdHRyaWJ1dGUiKSxjPVN5bWJvbC5mb3IoInNwcml0ZWpzX2RlY2xhcmVBbGlhcyIpO2Z1bmN0aW9uIHgodil7bGV0e2lubmVyUmFkaXVzOnAsb3V0ZXJSYWRpdXM6QyxzdGFydEFuZ2xlOk0sZW5kQW5nbGU6bX09djtjb25zdCB5PW5ldyByLkZpZ3VyZTJEO2lmKE09TWF0aC5QSSpNLzE4MCxtPU1hdGguUEkqbS8xODAscD5DJiYoW3AsQ109W0MscF0pLHA8PTAmJnkubW92ZVRvKDAsMCkseS5hcmMoMCwwLEMsTSxtLCExKSxwPjApe2NvbnN0IHM9TWF0aC5QSSoyO208TSYmKG09TStzKyhtLU0pJXMpLG0tTT49cyYmKG09TStzLTFlLTYpLHkuYXJjKDAsMCxwLG0sTSwhMCl9cmV0dXJuIHkuY2xvc2VQYXRoKCkseS5wYXRoLnJlZHVjZSgocyxsKT0+cytsLmpvaW4oIiAiKSwiIil9Y2xhc3MgZiBleHRlbmRzIGkuZGVmYXVsdHtjb25zdHJ1Y3RvcihwKXtzdXBlcihwKSx0aGlzW2ddKHtpbm5lclJhZGl1czowLG91dGVyUmFkaXVzOjAsc3RhcnRBbmdsZTowLGVuZEFuZ2xlOjM2MH0pLHRoaXNbY10oInJhZGl1cyIsImFuZ2xlIil9Z2V0IGQoKXtyZXR1cm4gdGhpc1thXSgiZCIpfXNldCBkKHApe31nZXQgaW5uZXJSYWRpdXMoKXtyZXR1cm4gdGhpc1thXSgiaW5uZXJSYWRpdXMiKX1zZXQgaW5uZXJSYWRpdXMocCl7aWYocD1PYmplY3QoaC50b051bWJlcikocCksdGhpc1t1XSgiaW5uZXJSYWRpdXMiLHApKXtjb25zdCBDPXgodGhpcyk7dGhpc1t1XSgiZCIsQyl9fWdldCBvdXRlclJhZGl1cygpe3JldHVybiB0aGlzW2FdKCJvdXRlclJhZGl1cyIpfXNldCBvdXRlclJhZGl1cyhwKXtpZihwPU9iamVjdChoLnRvTnVtYmVyKShwKSx0aGlzW3VdKCJvdXRlclJhZGl1cyIscCkpe2NvbnN0IEM9eCh0aGlzKTt0aGlzW3VdKCJkIixDKX19Z2V0IHJhZGl1cygpe3JldHVyblt0aGlzLmlubmVyUmFkaXVzLHRoaXMub3V0ZXJSYWRpdXNdfXNldCByYWRpdXMocCl7cD1PYmplY3QoaC50b0FycmF5KShwLCEwKSxBcnJheS5pc0FycmF5KHApfHwocD1bcCxwXSksdGhpcy5pbm5lclJhZGl1cz1wWzBdLHRoaXMub3V0ZXJSYWRpdXM9cFsxXX1nZXQgc3RhcnRBbmdsZSgpe3JldHVybiB0aGlzW2FdKCJzdGFydEFuZ2xlIil9c2V0IHN0YXJ0QW5nbGUocCl7aWYocD1PYmplY3QoaC50b051bWJlcikocCksdGhpc1t1XSgic3RhcnRBbmdsZSIscCkpe2NvbnN0IEM9eCh0aGlzKTt0aGlzW3VdKCJkIixDKX19Z2V0IGVuZEFuZ2xlKCl7cmV0dXJuIHRoaXNbYV0oImVuZEFuZ2xlIil9c2V0IGVuZEFuZ2xlKHApe2lmKHA9T2JqZWN0KGgudG9OdW1iZXIpKHApLHRoaXNbdV0oImVuZEFuZ2xlIixwKSl7Y29uc3QgQz14KHRoaXMpO3RoaXNbdV0oImQiLEMpfX1nZXQgYW5nbGUoKXtyZXR1cm5bdGhpcy5zdGFydEFuZ2xlLHRoaXMuZW5kQW5nbGVdfXNldCBhbmdsZShwKXtwPU9iamVjdChoLnRvQXJyYXkpKHApLEFycmF5LmlzQXJyYXkocCl8fChwPVtwLHBdKSx0aGlzLnN0YXJ0QW5nbGU9cFswXSx0aGlzLmVuZEFuZ2xlPXBbMV19fX0sZnVuY3Rpb24oUyxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gQ30pO3ZhciByPXQoMTIpLGk9dCgyMTgpLGg9dCgyMTkpLGc9dCgyNDkpLHU9dCgyMTMpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBhKE0sbSx5KXtyZXR1cm4gbSBpbiBNP09iamVjdC5kZWZpbmVQcm9wZXJ0eShNLG0se3ZhbHVlOnksZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTpNW21dPXksTX1jb25zdCBjPVN5bWJvbCgidGV4dEltYWdlIikseD1TeW1ib2woInRleHRJbWFnZVRhc2siKSxmPVN5bWJvbCgidGV4dHVyZUNvbnRleHQiKSx2PVN5bWJvbCgidXBkYXRlVGV4dHVyZVJlY3QiKSxwPVN5bWJvbCgidGV4dENhbnZhcyIpO2NsYXNzIEMgZXh0ZW5kcyBoLmRlZmF1bHR7Y29uc3RydWN0b3IobT17fSl7dHlwZW9mIG09PSJzdHJpbmciJiYobT17dGV4dDptfSksc3VwZXIobSl9Z2V0IGNvbnRlbnRTaXplKCl7bGV0W20seV09c3VwZXIuY29udGVudFNpemU7Y29uc3R7d2lkdGg6bixoZWlnaHQ6b309dGhpcy5hdHRyaWJ1dGVzO2lmKG49PW51bGx8fG89PW51bGwpe2NvbnN0IHM9dGhpc1tjXTtzJiYobj09bnVsbCYmKG09cy5yZWN0WzJdKSxvPT1udWxsJiYoeT1zLnJlY3RbM10pKX1yZXR1cm5bbSx5XX1nZXQgdGV4dCgpe3JldHVybiB0aGlzLmF0dHJpYnV0ZXMudGV4dH1zZXQgdGV4dChtKXt0aGlzLmF0dHJpYnV0ZXMudGV4dD1tfWdldCB0ZXh0Q29udGVudCgpe3JldHVybiB0aGlzLmF0dHJpYnV0ZXMudGV4dH1zZXQgdGV4dENvbnRlbnQobSl7dGhpcy5hdHRyaWJ1dGVzLnRleHQ9bX1nZXQgdGV4dEltYWdlKCl7cmV0dXJuIHRoaXNbY118fHt9fWdldCB0ZXh0SW1hZ2VSZWFkeSgpe3JldHVybiB0aGlzW3hdfHxQcm9taXNlLnJlc29sdmUoKX1kcmF3KG0pe3N1cGVyLmRyYXcobSk7Y29uc3QgeT10aGlzLm1lc2g7aWYoeSl7Y29uc3Qgbj10aGlzW2NdO2lmKG4pe2xldCBvPXkudGV4dHVyZTtpZighb3x8dGhpc1tmXSYmdGhpc1tmXSE9PXRoaXMucmVuZGVyZXJ8fG4ubmVlZHNVcGRhdGU/KG4ubmVlZHNVcGRhdGU9ITEsT2JqZWN0KGkuZGVsZXRlVGV4dHVyZSkobi5pbWFnZSx0aGlzLnJlbmRlcmVyKSxvPU9iamVjdChpLmNyZWF0ZVRleHR1cmUpKG4uaW1hZ2UsdGhpcy5yZW5kZXJlciksdGhpc1t2XT0hMCk6bz15LnVuaWZvcm1zLnVfdGV4U2FtcGxlcix0aGlzW3ZdKXtjb25zdFtzLGxdPW4ucmVjdC5zbGljZSgyKSxbRSxUXT10aGlzLmNvbnRlbnRTaXplLGI9dGhpcy5hdHRyaWJ1dGVzLnRleHRBbGlnbixJPXRoaXMuYXR0cmlidXRlcy52ZXJ0aWNhbEFsaWduO2xldCBQPTA7Yj09PSJjZW50ZXIiP1A9KEUtcykvMjooYj09PSJyaWdodCJ8fGI9PT0iZW5kIikmJihQPUUtcyk7Y29uc3QgTD10aGlzLmF0dHJpYnV0ZXMuZm9udFNpemUsRD10aGlzLmF0dHJpYnV0ZXMubGluZUhlaWdodDtsZXQgUj0wO0k9PT0idG9wIj9SPShMLUQpLzI6ST09PSJib3R0b20iJiYoUj0oRC1MKS8yKTtjb25zdHtwYWRkaW5nTGVmdDpBLHBhZGRpbmdUb3A6an09dGhpcy5hdHRyaWJ1dGVzLHtib3JkZXJXaWR0aDpHfT10aGlzLmF0dHJpYnV0ZXM7UCs9QStHLFIrPWorRztjb25zdHthbmNob3JYOkgsYW5jaG9yWTpafT10aGlzLmF0dHJpYnV0ZXM7UC09dGhpcy5vZmZzZXRTaXplWzBdKkgsUi09dGhpcy5vZmZzZXRTaXplWzFdKloseS5zZXRUZXh0dXJlKG8se3JlY3Q6W1AsUixzLGxdfSksdGhpc1t2XT0hMSx0aGlzW2ZdPXRoaXMucmVuZGVyZXJ9fX1yZXR1cm4gbX1vblByb3BlcnR5Q2hhbmdlKG0seSxuKXttPT09InRleHQifHxtPT09ImZvbnRTaXplInx8bT09PSJmb250RmFtaWx5Inx8bT09PSJmb250U3R5bGUifHxtPT09ImZvbnRWYXJpYW50Inx8bT09PSJmb250V2VpZ2h0Inx8bT09PSJmb250U3RyZXRjaCJ8fG09PT0ibGluZUhlaWdodCJ8fG09PT0ic3Ryb2tlQ29sb3IifHxtPT09ImZpbGxDb2xvciJ8fG09PT0ic3Ryb2tlV2lkdGgiP3RoaXMudXBkYXRlVGV4dCgpOigobT09PSJ0ZXh0QWxpZ24ifHxtPT09InZlcnRpY2FsQWxpZ24iKSYmKHRoaXNbdl09ITApLHN1cGVyLm9uUHJvcGVydHlDaGFuZ2UobSx5LG4pKX11cGRhdGVDb250b3Vycygpe3N1cGVyLnVwZGF0ZUNvbnRvdXJzKCksdGhpc1t2XT0hMH11cGRhdGVUZXh0KCl7dGhpc1t4XXx8KHRoaXNbeF09UHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKT0+e3RoaXNbeF09bnVsbDtjb25zdHt0ZXh0Om0sZm9udDp5LGZpbGxDb2xvcjpuLHN0cm9rZUNvbG9yOm8sc3Ryb2tlV2lkdGg6c309dGhpcy5hdHRyaWJ1dGVzLGw9dGhpcy5sYXllcj90aGlzLmxheWVyLmRpc3BsYXlSYXRpbzoxO3JldHVybiB0aGlzW3BdPXRoaXNbcF18fHIuRU5WLmNyZWF0ZUNhbnZhcygxLDEpLHRoaXNbY109ci5FTlYuY3JlYXRlVGV4dChtLHtmb250OnksZmlsbENvbG9yOm4sc3Ryb2tlQ29sb3I6byxzdHJva2VXaWR0aDpzLHBhcnNlRm9udDpyLnBhcnNlRm9udCxyYXRpbzpsLHRleHRDYW52YXM6dGhpc1twXX0pLHRoaXNbY10ubmVlZHNVcGRhdGU9ITAsdGhpcy51cGRhdGVDb250b3VycygpLHRoaXMuZm9yY2VVcGRhdGUoKSx0aGlzW2NdfSkpfX1hKEMsIkF0dHIiLGcuZGVmYXVsdCksdS5kZWZhdWx0LnJlZ2lzdGVyTm9kZShDLCJsYWJlbCIpfSxmdW5jdGlvbihTLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBmfSk7dmFyIHI9dCgxMiksaT10KDcyKSxoPXQoMjIxKSxnPXQoMjIwKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3QgdT1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGVEZWZhdWx0IiksYT1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGUiKSxjPVN5bWJvbC5mb3IoInNwcml0ZWpzX2dldEF0dHJpYnV0ZSIpLHg9U3ltYm9sLmZvcigic3ByaXRlanNfZGVjbGFyZUFsaWFzIik7Y2xhc3MgZiBleHRlbmRzIGcuZGVmYXVsdHtjb25zdHJ1Y3RvcihwKXtzdXBlcihwKSx0aGlzW3VdKHt0ZXh0OiIiLGZvbnRTaXplOjE2LGZvbnRGYW1pbHk6IkhlbHZldGljYSxBcmlhbCxzYW5zLXNlcmlmIixmb250U3R5bGU6Im5vcm1hbCIsZm9udFZhcmlhbnQ6Im5vcm1hbCIsZm9udFdlaWdodDoibm9ybWFsIixmb250U3RyZXRjaDoibm9ybWFsIixsaW5lSGVpZ2h0OiIiLHRleHRBbGlnbjoibGVmdCIsc3Ryb2tlQ29sb3I6dm9pZCAwLHN0cm9rZVdpZHRoOjEsZmlsbENvbG9yOnZvaWQgMCx2ZXJ0aWNhbEFsaWduOiJtaWRkbGUifSksdGhpc1t4XSgiZm9udCIpfWdldCB0ZXh0KCl7cmV0dXJuIHRoaXNbY10oInRleHQiKXx8IiAifXNldCB0ZXh0KHApe3RoaXNbYV0oInRleHQiLHApfWdldCBmb250U2l6ZSgpe3JldHVybiB0aGlzW2NdKCJmb250U2l6ZSIpfXNldCBmb250U2l6ZShwKXt0aGlzW2FdKCJmb250U2l6ZSIsT2JqZWN0KGkudG9OdW1iZXIpKHApKX1nZXQgZm9udEZhbWlseSgpe3JldHVybiB0aGlzW2NdKCJmb250RmFtaWx5Iil9c2V0IGZvbnRGYW1pbHkocCl7dGhpc1thXSgiZm9udEZhbWlseSIscCl9Z2V0IGZvbnRTdHlsZSgpe3JldHVybiB0aGlzW2NdKCJmb250U3R5bGUiKX1zZXQgZm9udFN0eWxlKHApe3RoaXNbYV0oImZvbnRTdHlsZSIscCl9Z2V0IGZvbnRWYXJpYW50KCl7cmV0dXJuIHRoaXNbY10oImZvbnRWYXJpYW50Iil9c2V0IGZvbnRWYXJpYW50KHApe3RoaXNbYV0oImZvbnRWYXJpYW50IixwKX1nZXQgZm9udFdlaWdodCgpe3JldHVybiB0aGlzW2NdKCJmb250V2VpZ2h0Iil9c2V0IGZvbnRXZWlnaHQocCl7dGhpc1thXSgiZm9udFdlaWdodCIscCl9Z2V0IGZvbnRTdHJldGNoKCl7cmV0dXJuIHRoaXNbY10oImZvbnRTdHJldGNoIil9c2V0IGZvbnRTdHJldGNoKHApe3RoaXNbYV0oImZvbnRTdHJldGNoIixwKX1nZXQgbGluZUhlaWdodCgpe3JldHVybiB0aGlzW2NdKCJsaW5lSGVpZ2h0Iil8fHRoaXMuZm9udFNpemV9c2V0IGxpbmVIZWlnaHQocCl7dGhpc1thXSgibGluZUhlaWdodCIsT2JqZWN0KGkudG9OdW1iZXIpKHApKX1nZXQgdGV4dEFsaWduKCl7cmV0dXJuIHRoaXNbY10oInRleHRBbGlnbiIpfXNldCB0ZXh0QWxpZ24ocCl7dGhpc1thXSgidGV4dEFsaWduIixwKX1nZXQgc3Ryb2tlQ29sb3IoKXtyZXR1cm4gdGhpc1tjXSgic3Ryb2tlQ29sb3IiKX1zZXQgc3Ryb2tlQ29sb3IocCl7dGhpc1thXSgic3Ryb2tlQ29sb3IiLE9iamVjdChoLnBhcnNlQ29sb3IpKHApKX1nZXQgc3Ryb2tlV2lkdGgoKXtyZXR1cm4gdGhpc1tjXSgic3Ryb2tlV2lkdGgiKX1zZXQgc3Ryb2tlV2lkdGgocCl7dGhpc1thXSgic3Ryb2tlV2lkdGgiLE9iamVjdChpLnRvTnVtYmVyKShwKSl9Z2V0IHZlcnRpY2FsQWxpZ24oKXtyZXR1cm4gdGhpc1tjXSgidmVydGljYWxBbGlnbiIpfXNldCB2ZXJ0aWNhbEFsaWduKHApe3RoaXNbYV0oInZlcnRpY2FsQWxpZ24iLHApfWdldCBmaWxsQ29sb3IoKXtyZXR1cm4gdGhpc1tjXSgiZmlsbENvbG9yIil9c2V0IGZpbGxDb2xvcihwKXt0aGlzW2FdKCJmaWxsQ29sb3IiLE9iamVjdChoLnBhcnNlQ29sb3IpKHApKX1nZXQgZm9udCgpe2NvbnN0e2ZvbnRTdHlsZTpwLGZvbnRWYXJpYW50OkMsZm9udFdlaWdodDpNLGZvbnRTdHJldGNoOm0sZm9udFNpemU6eSxsaW5lSGVpZ2h0Om4sZm9udEZhbWlseTpvfT10aGlzO3JldHVybmAke3B9ICR7Q30gJHtNfSAke219ICR7eX1weC8ke259cHggJHtvfWB9c2V0IGZvbnQocCl7aWYocD09bnVsbCl0aGlzLmZvbnRTdHlsZT1udWxsLHRoaXMuZm9udFZhcmlhbnQ9bnVsbCx0aGlzLmZvbnRXZWlnaHQ9bnVsbCx0aGlzLmZvbnRTdHJldGNoPW51bGwsdGhpcy5mb250U2l6ZT1udWxsLHRoaXMubGluZUhlaWdodD1udWxsLHRoaXMuZm9udEZhbWlseT1udWxsO2Vsc2V7Y29uc3QgQz1PYmplY3Qoci5wYXJzZUZvbnQpKHApO3RoaXMuZm9udFN0eWxlPUMuc3R5bGUsdGhpcy5mb250VmFyaWFudD1DLnZhcmlhbnQsdGhpcy5mb250V2VpZ2h0PUMud2VpZ2h0LHRoaXMuZm9udFN0cmV0Y2g9Qy5zdHJldGNoLHRoaXMuZm9udFNpemU9T2JqZWN0KGkudG9OdW1iZXIpKGAke0Muc2l6ZX0ke0MudW5pdH1gKSxDLmxpbmVIZWlnaHQmJih0aGlzLmxpbmVIZWlnaHQ9Qy5weExpbmVIZWlnaHQpLHRoaXMuZm9udEZhbWlseT1DLmZhbWlseX19fX0sZnVuY3Rpb24oUyxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gcH0pO3ZhciByPXQoMTIpLGk9dCgyMTkpLGg9dCgyNTEpLGc9dCgyMTMpLHU9dCgyNTIpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBhKEMsTSxtKXtyZXR1cm4gTSBpbiBDP09iamVjdC5kZWZpbmVQcm9wZXJ0eShDLE0se3ZhbHVlOm0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTpDW01dPW0sQ31jb25zdCBjPVN5bWJvbCgiek9yZGVyIikseD1TeW1ib2woIm9yZGVyZWQiKSxmPVN5bWJvbCgiY2hpbGRyZW4iKSx2PVN5bWJvbCgic2VhbGVkIik7Y2xhc3MgcCBleHRlbmRzIGkuZGVmYXVsdHtjb25zdHJ1Y3RvcihNPXt9KXtzdXBlcihNKSx0aGlzW2ZdPVtdLHRoaXNbeF09bnVsbCx0aGlzW2NdPTB9Z2V0IGNoaWxkTm9kZXMoKXtyZXR1cm4gdGhpc1tmXX1nZXQgY2hpbGRyZW4oKXtyZXR1cm4gdGhpc1tmXX1nZXQgb3JkZXJlZENoaWxkcmVuKCl7cmV0dXJuIHRoaXNbeF18fCh0aGlzW3hdPVsuLi50aGlzW2ZdXSx0aGlzW3hdLnNvcnQoKE0sbSk9Pk0uekluZGV4LW0uekluZGV4fHxNLnpPcmRlci1tLnpPcmRlcikpLHRoaXNbeF19YXBwZW5kKC4uLk0pe3JldHVybiBNLm1hcChtPT50aGlzLmFwcGVuZENoaWxkKG0pKX1hcHBlbmRDaGlsZChNKXtyZXR1cm4gTS5yZW1vdmUoKSx0aGlzW2ZdLnB1c2goTSksTS5jb25uZWN0KHRoaXMsdGhpc1tjXSsrKSx0aGlzW3hdJiYodGhpc1t4XS5sZW5ndGgmJk0uekluZGV4PHRoaXNbeF1bdGhpc1t4XS5sZW5ndGgtMV0uekluZGV4P3RoaXMucmVvcmRlcigpOnRoaXNbeF0ucHVzaChNKSksTX1jbG9uZU5vZGUoTT0hMSl7Y29uc3QgbT1zdXBlci5jbG9uZU5vZGUoKTtyZXR1cm4gTSYmdGhpc1tmXS5mb3JFYWNoKHk9Pntjb25zdCBuPXkuY2xvbmVOb2RlKE0pO20uYXBwZW5kQ2hpbGQobil9KSxtfWRpc3BhdGNoUG9pbnRlckV2ZW50KE0pe2NvbnN0IG09dGhpcy5vcmRlcmVkQ2hpbGRyZW47Zm9yKGxldCB5PW0ubGVuZ3RoLTE7eT49MDt5LS0paWYobVt5XS5kaXNwYXRjaFBvaW50ZXJFdmVudChNKSlyZXR1cm4hMDtyZXR1cm4gc3VwZXIuZGlzcGF0Y2hQb2ludGVyRXZlbnQoTSl9ZHJhdyhNPVtdKXtpZih0aGlzLl9fY2FjaGVSZW5kZXJNYXRyaXg9dGhpcy5yZW5kZXJNYXRyaXgsc3VwZXIuZHJhdyhNKSwhdGhpc1t2XSYmdGhpcy5hdHRyaWJ1dGVzLmRpc3BsYXkhPT0ibm9uZSIpe2NvbnN0IG09dGhpcy5vcmRlcmVkQ2hpbGRyZW47Zm9yKGxldCB5PTA7eTxtLmxlbmd0aDt5KyspbVt5XS5kcmF3KE0pfXJldHVybiB0aGlzLl9fY2FjaGVSZW5kZXJNYXRyaXg9bnVsbCxNfWdldEVsZW1lbnRCeUlkKE0pe3JldHVybiBPYmplY3QodS5xdWVyeVNlbGVjdG9yKShgIyR7TX1gLHRoaXMpfWdldEVsZW1lbnRzQnlDbGFzc05hbWUoTSl7cmV0dXJuIE9iamVjdCh1LnF1ZXJ5U2VsZWN0b3JBbGwpKGAuJHtNfWAsdGhpcyl9Z2V0RWxlbWVudHNCeU5hbWUoTSl7cmV0dXJuIE9iamVjdCh1LnF1ZXJ5U2VsZWN0b3JBbGwpKGBbbmFtZT0iJHtNfSJdYCx0aGlzKX1nZXRFbGVtZW50c0J5VGFnTmFtZShNKXtyZXR1cm4gT2JqZWN0KHUucXVlcnlTZWxlY3RvckFsbCkoTSx0aGlzKX1pbnNlcnRCZWZvcmUoTSxtKXtpZihtPT1udWxsKXJldHVybiB0aGlzLmFwcGVuZENoaWxkKE0pO00ucmVtb3ZlKCk7Y29uc3QgeT10aGlzW2ZdLmluZGV4T2YobSk7aWYoeTwwKXRocm93IG5ldyBFcnJvcigiSW52YWxpZCByZWZlcmVuY2Ugbm9kZS4iKTtjb25zdCBuPW0uek9yZGVyO2ZvcihsZXQgbz15O288dGhpc1tmXS5sZW5ndGg7bysrKXtjb25zdCBzPXRoaXNbZl1bb10uek9yZGVyLGw9dGhpc1tmXVtvXTtkZWxldGUgbC56T3JkZXIsT2JqZWN0LmRlZmluZVByb3BlcnR5KGwsInpPcmRlciIse3ZhbHVlOnMrMSx3cml0YWJsZTohMSxjb25maWd1cmFibGU6ITB9KX1pZih0aGlzW2ZdLnNwbGljZSh5LDAsTSksTS5jb25uZWN0KHRoaXMsbiksdGhpc1t4XSlpZihNLnpJbmRleCE9PW0uekluZGV4KXRoaXMucmVvcmRlcigpO2Vsc2V7Y29uc3Qgbz10aGlzW3hdLmluZGV4T2YobSk7dGhpc1t4XS5zcGxpY2UobywwLE0pfXJldHVybiBNfXF1ZXJ5U2VsZWN0b3IoTSl7cmV0dXJuIE9iamVjdCh1LnF1ZXJ5U2VsZWN0b3IpKE0sdGhpcyl9cXVlcnlTZWxlY3RvckFsbChNKXtyZXR1cm4gT2JqZWN0KHUucXVlcnlTZWxlY3RvckFsbCkoTSx0aGlzKX1yZXBsYWNlQ2hpbGQoTSxtKXtNLnJlbW92ZSgpO2NvbnN0IHk9dGhpc1tmXS5pbmRleE9mKG0pO2lmKHk8MCl0aHJvdyBuZXcgRXJyb3IoIkludmFsaWQgcmVmZXJlbmNlIG5vZGUuIik7aWYodGhpc1tmXVt5XT1NLE0uY29ubmVjdCh0aGlzLG0uek9yZGVyKSx0aGlzW3hdKWlmKE0uekluZGV4IT09bS56SW5kZXgpdGhpcy5yZW9yZGVyKCk7ZWxzZXtjb25zdCBuPXRoaXNbeF0uaW5kZXhPZihtKTt0aGlzW3hdW25dPU19cmV0dXJuIG0uZGlzY29ubmVjdCh0aGlzKSxNfXJlbW92ZUFsbENoaWxkcmVuKCl7Y29uc3QgTT10aGlzW2ZdO2ZvcihsZXQgbT1NLmxlbmd0aC0xO20+PTA7bS0tKU1bbV0ucmVtb3ZlKCl9cmVtb3ZlQ2hpbGQoTSl7Y29uc3QgbT10aGlzW2ZdLmluZGV4T2YoTSk7aWYobT49MCl7aWYodGhpc1tmXS5zcGxpY2UobSwxKSx0aGlzW3hdKXtjb25zdCB5PXRoaXNbeF0uaW5kZXhPZihNKTt0aGlzW3hdLnNwbGljZSh5LDEpfXJldHVybiBNLmRpc2Nvbm5lY3QodGhpcyksTX1yZXR1cm4gbnVsbH1yZW9yZGVyKCl7dGhpc1t4XT1udWxsfXNlYWwoKXtmdW5jdGlvbiBNKG8scyl7Y29uc3QgbD1bXTtmb3IobGV0IEU9MDtFPG8ubGVuZ3RoO0UrKyl7Y29uc3QgVD1bLi4ub1tFXV07Zm9yKGxldCBiPTE7YjxULmxlbmd0aDtiKz0yKXtjb25zdCBJPVRbYl0sUD1UW2IrMV07VFtiXT1JKnNbMF0rUCpzWzJdK3NbNF0sVFtiKzFdPUkqc1sxXStQKnNbM10rc1s1XX1sLnB1c2goVCl9cmV0dXJuIGx9Y29uc3QgbT10aGlzLm9yZGVyZWRDaGlsZHJlbix5PW5ldyByLkZpZ3VyZTJELG49dGhpcy5sb2NhbE1hdHJpeDtmb3IobGV0IG89MDtvPG0ubGVuZ3RoO28rKyl7bGV0IHM9bVtvXTtpZihzIGluc3RhbmNlb2YgcCYmKHM9cy5zZWFsKCkpLHMuY2xpZW50Qm94KXtsZXQgbD1zLmNsaWVudEJveC5jb250b3Vycy5wYXRoO2w9TShsLHMubG9jYWxNYXRyaXgpLHkuYWRkUGF0aChsKX1pZihzLnBhdGgpe2xldCBsPXMucGF0aC5jb250b3Vycy5wYXRoO2w9TShsLHMubG9jYWxNYXRyaXgpLHkuYWRkUGF0aChsKX19cmV0dXJuIHRoaXNbdl09ITAsdGhpcy5jbGllbnRCb3g9eSx7Y2xpZW50Qm94OnksbG9jYWxNYXRyaXg6bn19c2V0UmVzb2x1dGlvbih7d2lkdGg6TSxoZWlnaHQ6bX0pe3N1cGVyLnNldFJlc29sdXRpb24oe3dpZHRoOk0saGVpZ2h0Om19KSx0aGlzW2ZdLmZvckVhY2goeT0+e3kuc2V0UmVzb2x1dGlvbih7d2lkdGg6TSxoZWlnaHQ6bX0pfSl9dXBkYXRlQ29udG91cnMoKXt0aGlzW3ZdfHxzdXBlci51cGRhdGVDb250b3VycygpfX1hKHAsIkF0dHIiLGguZGVmYXVsdCksZy5kZWZhdWx0LnJlZ2lzdGVyTm9kZShwLCJncm91cCIpfSxmdW5jdGlvbihTLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBpfSk7dmFyIHI9dCgyMjApO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjbGFzcyBpIGV4dGVuZHMgci5kZWZhdWx0e319LGZ1bmN0aW9uKFMsZSx0KXt0LnIoZSksdC5kKGUsInF1ZXJ5U2VsZWN0b3JBbGwiLGZ1bmN0aW9uKCl7cmV0dXJuIHZ9KSx0LmQoZSwicXVlcnlTZWxlY3RvciIsZnVuY3Rpb24oKXtyZXR1cm4gcH0pLHQuZChlLCJpc01hdGNoZWQiLGZ1bmN0aW9uKCl7cmV0dXJuIEN9KSx0LmQoZSwiY29tcGlsZSIsZnVuY3Rpb24oKXtyZXR1cm4gTX0pO3ZhciByPXQoMjIxKSxpPXQoMjEzKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3QgaD10KDI1Myk7ZnVuY3Rpb24gZyhtKXtyZXR1cm4gbS5ub2RlVHlwZT09PTF8fGkuZGVmYXVsdC5pc1Nwcml0ZU5vZGUobS5ub2RlTmFtZSl9ZnVuY3Rpb24gdShtKXtyZXR1cm4gQXJyYXkuZnJvbShtLmNoaWxkTm9kZXN8fFtdKX1mdW5jdGlvbiBhKG0pe3JldHVybiBpLmRlZmF1bHQuaXNTcHJpdGVOb2RlKG0ubm9kZU5hbWUpP20ucGFyZW50fHxtLmNhbnZhc3x8bS5jb250YWluZXI6bS5wYXJlbnRFbGVtZW50fWZ1bmN0aW9uIGMobSl7bGV0IHk9bS5sZW5ndGgsbixvLHM7Zm9yKDstLXk+LTE7KXtmb3Iobj1vPW1beV0sbVt5XT1udWxsLHM9ITA7bzspe2lmKG0uaW5kZXhPZihvKT4tMSl7cz0hMSxtLnNwbGljZSh5LDEpO2JyZWFrfW89YShvKX1zJiYobVt5XT1uKX1yZXR1cm4gbX1jb25zdCB4PXtpc1RhZzpnLGV4aXN0c09uZShtLHkpe3JldHVybiB5LnNvbWUobj0+ZyhuKT9tKG4pfHx4LmV4aXN0c09uZShtLHUobikpOiExKX0sZ2V0U2libGluZ3MobSl7Y29uc3QgeT1hKG0pO3JldHVybiB5JiZ1KHkpfSxnZXRDaGlsZHJlbjp1LGdldFBhcmVudDphLGdldEF0dHJpYnV0ZVZhbHVlKG0seSl7aWYobS5ub2RlVHlwZT09PTEmJnk9PT0iY2xhc3MifHx5PT09ImlkIilyZXR1cm4gbVt5XTtpZih0aGlzLmhhc0F0dHJpYihtLHkpKXtsZXQgbj1tLmF0dHJpYnV0ZXNbeV07cmV0dXJuIEFycmF5LmlzQXJyYXkobikmJihuPWBbJHtuLmpvaW4oKX1dYCksU3RyaW5nKG4pfX0saGFzQXR0cmliKG0seSl7cmV0dXJuIG0uYXR0cmlidXRlc1t5XSE9bnVsbH0scmVtb3ZlU3Vic2V0czpjLGdldE5hbWUobSl7cmV0dXJuIG0udGFnTmFtZT9tLnRhZ05hbWUudG9Mb3dlckNhc2UoKTpudWxsfSxmaW5kT25lOmZ1bmN0aW9uIG0oeSxuKXtsZXQgbz1udWxsO2ZvcihsZXQgcz0wLGw9bi5sZW5ndGg7czxsJiYhbztzKyspaWYoeShuW3NdKSlvPW5bc107ZWxzZXtjb25zdCBFPXUobltzXSk7RSYmRS5sZW5ndGg+MCYmKG89bSh5LEUpKX1yZXR1cm4gb30sZmluZEFsbDpmdW5jdGlvbiBtKHksbil7bGV0IG89W107Zm9yKGxldCBzPTAsbD1uLmxlbmd0aDtzPGw7cysrKXtpZighZyhuW3NdKSljb250aW51ZTt5KG5bc10pJiZvLnB1c2gobltzXSk7Y29uc3QgRT11KG5bc10pO0UmJihvPW8uY29uY2F0KG0oeSxFKSkpfXJldHVybiBvfSxnZXRUZXh0OmZ1bmN0aW9uIG0oeSl7cmV0dXJuIEFycmF5LmlzQXJyYXkoeSk/eS5tYXAobSkuam9pbigiIik6Zyh5KT9tKHUoeSkpOnkubm9kZVR5cGU9PT0zP3kubm9kZVZhbHVlOmkuZGVmYXVsdC5pc1Nwcml0ZU5vZGUoeS5ub2RlTmFtZSk/eS50ZXh0OiIifX07ZnVuY3Rpb24gZihtKXtpZih0eXBlb2YgbSE9InN0cmluZyIpcmV0dXJuIG07bGV0IHk9bS5tYXRjaCgvXFsoYmdjb2xvcnxmaWxsQ29sb3J8c3Ryb2tlQ29sb3J8Y29sb3IpXHMqPVxzKlsnIl0/XHcrWyciXT9cXS9nKTtyZXR1cm4geSYmKHk9eS5tYXAobj0+e2NvbnN0IG89bi5zbGljZSgxLC0xKS5zcGxpdCgiPSIpLHM9T2JqZWN0KHIucGFyc2VDb2xvcikob1sxXS5yZXBsYWNlKC9bJyJdL2csIiIpKTtyZXR1cm5bbixgWyR7b1swXX09IiR7c30iXWBdfSkseS5mb3JFYWNoKChbbixvXSk9PnttPW0ucmVwbGFjZShuLG8pfSkpLHk9bS5tYXRjaCgvXFtcdytccyo9XHMqWyciXVxbLis/XF1bJyJdXF0vZykseSYmKHk9eS5tYXAobj0+e2NvbnN0IG89bi5zbGljZSgxLC0xKS5zcGxpdCgiPSIpLHM9b1sxXS5zbGljZSgyLC0yKS5zcGxpdCgvLC9nKS5tYXAobD0+bC50cmltKCkpO3JldHVybltuLGBbJHtvWzBdfT0iWyR7c31dIl1gXX0pLHkuZm9yRWFjaCgoW24sb10pPT57bT1tLnJlcGxhY2UobixvKX0pKSxtfWZ1bmN0aW9uIHYobSx5KXtyZXR1cm4gaC5zZWxlY3RBbGwoZihtKSx5LHthZGFwdGVyOnh9KX1mdW5jdGlvbiBwKG0seSl7cmV0dXJuIGguc2VsZWN0T25lKGYobSkseSx7YWRhcHRlcjp4fSl9ZnVuY3Rpb24gQyhtLHkpe3JldHVybiBoLmlzKG0sZih5KSx7YWRhcHRlcjp4fSl9ZnVuY3Rpb24gTShtKXtyZXR1cm4gaC5jb21waWxlKGYobSkse2FkYXB0ZXI6eH0pfX0sZnVuY3Rpb24oUyxlLHQpe1MuZXhwb3J0cz1NO3ZhciByPXQoMjU0KSxpPXQoMjczKS5mYWxzZUZ1bmMsaD10KDI3NCk7ZnVuY3Rpb24gZyhtKXtyZXR1cm4gZnVuY3Rpb24obixvLHMpe3JldHVybiBvPW98fHt9LG8uYWRhcHRlcj1vLmFkYXB0ZXJ8fHIsbShuLG8scyl9fXZhciB1PWcoaCksYT1nKGguY29tcGlsZVVuc2FmZSk7ZnVuY3Rpb24gYyhtKXtyZXR1cm4gZnVuY3Rpb24obixvLHMpe3JldHVybiBzPXN8fHt9LHMuYWRhcHRlcj1zLmFkYXB0ZXJ8fHIsdHlwZW9mIG4hPSJmdW5jdGlvbiImJihuPWEobixzLG8pKSxuLnNob3VsZFRlc3ROZXh0U2libGluZ3MmJihvPWYocyYmcy5jb250ZXh0fHxvLHMuYWRhcHRlcikpLEFycmF5LmlzQXJyYXkobyk/bz1zLmFkYXB0ZXIucmVtb3ZlU3Vic2V0cyhvKTpvPXMuYWRhcHRlci5nZXRDaGlsZHJlbihvKSxtKG4sbyxzKX19ZnVuY3Rpb24geChtLHkpe3ZhciBuPXkuZ2V0U2libGluZ3MobSk7aWYoIUFycmF5LmlzQXJyYXkobikpcmV0dXJuW107Zm9yKG49bi5zbGljZSgwKTtuLnNoaWZ0KCkhPT1tOyk7cmV0dXJuIG59ZnVuY3Rpb24gZihtLHkpe0FycmF5LmlzQXJyYXkobSl8fChtPVttXSk7Zm9yKHZhciBuPW0uc2xpY2UoMCksbz0wLHM9bS5sZW5ndGg7bzxzO28rKyl7dmFyIGw9eChuW29dLHkpO24ucHVzaC5hcHBseShuLGwpfXJldHVybiBufXZhciB2PWMoZnVuY3Rpb24oeSxuLG8pe3JldHVybiB5PT09aXx8IW58fG4ubGVuZ3RoPT09MD9bXTpvLmFkYXB0ZXIuZmluZEFsbCh5LG4pfSkscD1jKGZ1bmN0aW9uKHksbixvKXtyZXR1cm4geT09PWl8fCFufHxuLmxlbmd0aD09PTA/bnVsbDpvLmFkYXB0ZXIuZmluZE9uZSh5LG4pfSk7ZnVuY3Rpb24gQyhtLHksbil7cmV0dXJuIG49bnx8e30sbi5hZGFwdGVyPW4uYWRhcHRlcnx8ciwodHlwZW9mIHk9PSJmdW5jdGlvbiI/eTp1KHksbikpKG0pfWZ1bmN0aW9uIE0obSx5LG4pe3JldHVybiB2KG0seSxuKX1NLmNvbXBpbGU9dSxNLmZpbHRlcnM9aC5Qc2V1ZG9zLmZpbHRlcnMsTS5wc2V1ZG9zPWguUHNldWRvcy5wc2V1ZG9zLE0uc2VsZWN0QWxsPXYsTS5zZWxlY3RPbmU9cCxNLmlzPUMsTS5wYXJzZT11LE0uaXRlcmF0ZT12LE0uX2NvbXBpbGVVbnNhZmU9YSxNLl9jb21waWxlVG9rZW49aC5jb21waWxlVG9rZW59LGZ1bmN0aW9uKFMsZSx0KXt2YXIgcj1TLmV4cG9ydHM7W3QoMjU1KSx0KDI2OCksdCgyNjkpLHQoMjcwKSx0KDI3MSksdCgyNzIpXS5mb3JFYWNoKGZ1bmN0aW9uKGkpe09iamVjdC5rZXlzKGkpLmZvckVhY2goZnVuY3Rpb24oaCl7cltoXT1pW2hdLmJpbmQocil9KX0pfSxmdW5jdGlvbihTLGUsdCl7dmFyIHI9dCgyNTYpLGk9dCgyNTcpLGg9ci5pc1RhZztTLmV4cG9ydHM9e2dldElubmVySFRNTDpnLGdldE91dGVySFRNTDppLGdldFRleHQ6dX07ZnVuY3Rpb24gZyhhLGMpe3JldHVybiBhLmNoaWxkcmVuP2EuY2hpbGRyZW4ubWFwKGZ1bmN0aW9uKHgpe3JldHVybiBpKHgsYyl9KS5qb2luKCIiKToiIn1mdW5jdGlvbiB1KGEpe3JldHVybiBBcnJheS5pc0FycmF5KGEpP2EubWFwKHUpLmpvaW4oIiIpOmgoYSk/YS5uYW1lPT09ImJyIj9gCmA6dShhLmNoaWxkcmVuKTphLnR5cGU9PT1yLkNEQVRBP3UoYS5jaGlsZHJlbik6YS50eXBlPT09ci5UZXh0P2EuZGF0YToiIn19LGZ1bmN0aW9uKFMsZSl7Uy5leHBvcnRzPXtUZXh0OiJ0ZXh0IixEaXJlY3RpdmU6ImRpcmVjdGl2ZSIsQ29tbWVudDoiY29tbWVudCIsU2NyaXB0OiJzY3JpcHQiLFN0eWxlOiJzdHlsZSIsVGFnOiJ0YWciLENEQVRBOiJjZGF0YSIsRG9jdHlwZToiZG9jdHlwZSIsaXNUYWc6ZnVuY3Rpb24odCl7cmV0dXJuIHQudHlwZT09PSJ0YWcifHx0LnR5cGU9PT0ic2NyaXB0Inx8dC50eXBlPT09InN0eWxlIn19fSxmdW5jdGlvbihTLGUsdCl7dmFyIHI9dCgyNTgpLGk9dCgyNTkpLGg9dCgyNjcpO2guZWxlbWVudE5hbWVzLl9fcHJvdG9fXz1udWxsLGguYXR0cmlidXRlTmFtZXMuX19wcm90b19fPW51bGw7dmFyIGc9e19fcHJvdG9fXzpudWxsLHN0eWxlOiEwLHNjcmlwdDohMCx4bXA6ITAsaWZyYW1lOiEwLG5vZW1iZWQ6ITAsbm9mcmFtZXM6ITAscGxhaW50ZXh0OiEwLG5vc2NyaXB0OiEwfTtmdW5jdGlvbiB1KG0seSl7aWYobSl7dmFyIG49IiIsbztmb3IodmFyIHMgaW4gbSlvPW1bc10sbiYmKG4rPSIgIikseS54bWxNb2RlPT09ImZvcmVpZ24iJiYocz1oLmF0dHJpYnV0ZU5hbWVzW3NdfHxzKSxuKz1zLChvIT09bnVsbCYmbyE9PSIifHx5LnhtbE1vZGUpJiYobis9Jz0iJysoeS5kZWNvZGVFbnRpdGllcz9pLmVuY29kZVhNTChvKTpvLnJlcGxhY2UoL1wiL2csIiZxdW90OyIpKSsnIicpO3JldHVybiBufX12YXIgYT17X19wcm90b19fOm51bGwsYXJlYTohMCxiYXNlOiEwLGJhc2Vmb250OiEwLGJyOiEwLGNvbDohMCxjb21tYW5kOiEwLGVtYmVkOiEwLGZyYW1lOiEwLGhyOiEwLGltZzohMCxpbnB1dDohMCxpc2luZGV4OiEwLGtleWdlbjohMCxsaW5rOiEwLG1ldGE6ITAscGFyYW06ITAsc291cmNlOiEwLHRyYWNrOiEwLHdicjohMH0sYz1TLmV4cG9ydHM9ZnVuY3Rpb24obSx5KXshQXJyYXkuaXNBcnJheShtKSYmIW0uY2hlZXJpbyYmKG09W21dKSx5PXl8fHt9O2Zvcih2YXIgbj0iIixvPTA7bzxtLmxlbmd0aDtvKyspe3ZhciBzPW1bb107cy50eXBlPT09InJvb3QiP24rPWMocy5jaGlsZHJlbix5KTpyLmlzVGFnKHMpP24rPWYocyx5KTpzLnR5cGU9PT1yLkRpcmVjdGl2ZT9uKz12KHMpOnMudHlwZT09PXIuQ29tbWVudD9uKz1NKHMpOnMudHlwZT09PXIuQ0RBVEE/bis9QyhzKTpuKz1wKHMseSl9cmV0dXJuIG59LHg9WyJtaSIsIm1vIiwibW4iLCJtcyIsIm10ZXh0IiwiYW5ub3RhdGlvbi14bWwiLCJmb3JlaWduT2JqZWN0IiwiZGVzYyIsInRpdGxlIl07ZnVuY3Rpb24gZihtLHkpe3kueG1sTW9kZT09PSJmb3JlaWduIiYmKG0ubmFtZT1oLmVsZW1lbnROYW1lc1ttLm5hbWVdfHxtLm5hbWUsbS5wYXJlbnQmJnguaW5kZXhPZihtLnBhcmVudC5uYW1lKT49MCYmKHk9T2JqZWN0LmFzc2lnbih7fSx5LHt4bWxNb2RlOiExfSkpKSwheS54bWxNb2RlJiZbInN2ZyIsIm1hdGgiXS5pbmRleE9mKG0ubmFtZSk+PTAmJih5PU9iamVjdC5hc3NpZ24oe30seSx7eG1sTW9kZToiZm9yZWlnbiJ9KSk7dmFyIG49IjwiK20ubmFtZSxvPXUobS5hdHRyaWJzLHkpO3JldHVybiBvJiYobis9IiAiK28pLHkueG1sTW9kZSYmKCFtLmNoaWxkcmVufHxtLmNoaWxkcmVuLmxlbmd0aD09PTApP24rPSIvPiI6KG4rPSI+IixtLmNoaWxkcmVuJiYobis9YyhtLmNoaWxkcmVuLHkpKSwoIWFbbS5uYW1lXXx8eS54bWxNb2RlKSYmKG4rPSI8LyIrbS5uYW1lKyI+IikpLG59ZnVuY3Rpb24gdihtKXtyZXR1cm4iPCIrbS5kYXRhKyI+In1mdW5jdGlvbiBwKG0seSl7dmFyIG49bS5kYXRhfHwiIjtyZXR1cm4geS5kZWNvZGVFbnRpdGllcyYmIShtLnBhcmVudCYmbS5wYXJlbnQubmFtZSBpbiBnKSYmKG49aS5lbmNvZGVYTUwobikpLG59ZnVuY3Rpb24gQyhtKXtyZXR1cm4iPCFbQ0RBVEFbIittLmNoaWxkcmVuWzBdLmRhdGErIl1dPiJ9ZnVuY3Rpb24gTShtKXtyZXR1cm4iPCEtLSIrbS5kYXRhKyItLT4ifX0sZnVuY3Rpb24oUyxlLHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KTtmdW5jdGlvbiByKGkpe3JldHVybiBpLnR5cGU9PT0idGFnInx8aS50eXBlPT09InNjcmlwdCJ8fGkudHlwZT09PSJzdHlsZSJ9ZS5pc1RhZz1yLGUuVGV4dD0idGV4dCIsZS5EaXJlY3RpdmU9ImRpcmVjdGl2ZSIsZS5Db21tZW50PSJjb21tZW50IixlLlNjcmlwdD0ic2NyaXB0IixlLlN0eWxlPSJzdHlsZSIsZS5UYWc9InRhZyIsZS5DREFUQT0iY2RhdGEiLGUuRG9jdHlwZT0iZG9jdHlwZSJ9LGZ1bmN0aW9uKFMsZSx0KXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksZS5lbmNvZGU9ZS5kZWNvZGVTdHJpY3Q9ZS5kZWNvZGU9dm9pZCAwO3ZhciByPXQoMjYwKSxpPXQoMjY2KTtmdW5jdGlvbiBoKHgsZil7cmV0dXJuKCFmfHxmPD0wP3IuZGVjb2RlWE1MOnIuZGVjb2RlSFRNTCkoeCl9ZS5kZWNvZGU9aDtmdW5jdGlvbiBnKHgsZil7cmV0dXJuKCFmfHxmPD0wP3IuZGVjb2RlWE1MOnIuZGVjb2RlSFRNTFN0cmljdCkoeCl9ZS5kZWNvZGVTdHJpY3Q9ZztmdW5jdGlvbiB1KHgsZil7cmV0dXJuKCFmfHxmPD0wP2kuZW5jb2RlWE1MOmkuZW5jb2RlSFRNTCkoeCl9ZS5lbmNvZGU9dTt2YXIgYT10KDI2Nik7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsImVuY29kZVhNTCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGEuZW5jb2RlWE1MfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJlbmNvZGVIVE1MIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gYS5lbmNvZGVIVE1MfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJlc2NhcGUiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBhLmVzY2FwZX19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiZW5jb2RlSFRNTDQiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBhLmVuY29kZUhUTUx9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsImVuY29kZUhUTUw1Iix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gYS5lbmNvZGVIVE1MfX0pO3ZhciBjPXQoMjYwKTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiZGVjb2RlWE1MIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gYy5kZWNvZGVYTUx9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsImRlY29kZUhUTUwiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBjLmRlY29kZUhUTUx9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsImRlY29kZUhUTUxTdHJpY3QiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBjLmRlY29kZUhUTUxTdHJpY3R9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsImRlY29kZUhUTUw0Iix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gYy5kZWNvZGVIVE1MfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJkZWNvZGVIVE1MNSIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGMuZGVjb2RlSFRNTH19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiZGVjb2RlSFRNTDRTdHJpY3QiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBjLmRlY29kZUhUTUxTdHJpY3R9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsImRlY29kZUhUTUw1U3RyaWN0Iix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gYy5kZWNvZGVIVE1MU3RyaWN0fX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJkZWNvZGVYTUxTdHJpY3QiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBjLmRlY29kZVhNTH19KX0sZnVuY3Rpb24oUyxlLHQpe3ZhciByPXRoaXMmJnRoaXMuX19pbXBvcnREZWZhdWx0fHxmdW5jdGlvbihmKXtyZXR1cm4gZiYmZi5fX2VzTW9kdWxlP2Y6e2RlZmF1bHQ6Zn19O09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxlLmRlY29kZUhUTUw9ZS5kZWNvZGVIVE1MU3RyaWN0PWUuZGVjb2RlWE1MPXZvaWQgMDt2YXIgaT1yKHQoMjYxKSksaD1yKHQoMjYyKSksZz1yKHQoMjYzKSksdT1yKHQoMjY0KSk7ZS5kZWNvZGVYTUw9YShnLmRlZmF1bHQpLGUuZGVjb2RlSFRNTFN0cmljdD1hKGkuZGVmYXVsdCk7ZnVuY3Rpb24gYShmKXt2YXIgdj1PYmplY3Qua2V5cyhmKS5qb2luKCJ8IikscD14KGYpO3YrPSJ8I1t4WF1bXFxkYS1mQS1GXSt8I1xcZCsiO3ZhciBDPW5ldyBSZWdFeHAoIiYoPzoiK3YrIik7IiwiZyIpO3JldHVybiBmdW5jdGlvbihNKXtyZXR1cm4gU3RyaW5nKE0pLnJlcGxhY2UoQyxwKX19dmFyIGM9ZnVuY3Rpb24oZix2KXtyZXR1cm4gZjx2PzE6LTF9O2UuZGVjb2RlSFRNTD1mdW5jdGlvbigpe2Zvcih2YXIgZj1PYmplY3Qua2V5cyhoLmRlZmF1bHQpLnNvcnQoYyksdj1PYmplY3Qua2V5cyhpLmRlZmF1bHQpLnNvcnQoYykscD0wLEM9MDtwPHYubGVuZ3RoO3ArKylmW0NdPT09dltwXT8odltwXSs9Ijs/IixDKyspOnZbcF0rPSI7Ijt2YXIgTT1uZXcgUmVnRXhwKCImKD86Iit2LmpvaW4oInwiKSsifCNbeFhdW1xcZGEtZkEtRl0rOz98I1xcZCs7PykiLCJnIiksbT14KGkuZGVmYXVsdCk7ZnVuY3Rpb24geShuKXtyZXR1cm4gbi5zdWJzdHIoLTEpIT09IjsiJiYobis9IjsiKSxtKG4pfXJldHVybiBmdW5jdGlvbihuKXtyZXR1cm4gU3RyaW5nKG4pLnJlcGxhY2UoTSx5KX19KCk7ZnVuY3Rpb24geChmKXtyZXR1cm4gZnVuY3Rpb24ocCl7aWYocC5jaGFyQXQoMSk9PT0iIyIpe3ZhciBDPXAuY2hhckF0KDIpO3JldHVybiBDPT09IlgifHxDPT09IngiP3UuZGVmYXVsdChwYXJzZUludChwLnN1YnN0cigzKSwxNikpOnUuZGVmYXVsdChwYXJzZUludChwLnN1YnN0cigyKSwxMCkpfXJldHVybiBmW3Auc2xpY2UoMSwtMSldfX19LGZ1bmN0aW9uKFMpe1MuZXhwb3J0cz1KU09OLnBhcnNlKCd7IkFhY3V0ZSI6IsOBIiwiYWFjdXRlIjoiw6EiLCJBYnJldmUiOiLEgiIsImFicmV2ZSI6IsSDIiwiYWMiOiLiiL4iLCJhY2QiOiLiiL8iLCJhY0UiOiLiiL7MsyIsIkFjaXJjIjoiw4IiLCJhY2lyYyI6IsOiIiwiYWN1dGUiOiLCtCIsIkFjeSI6ItCQIiwiYWN5Ijoi0LAiLCJBRWxpZyI6IsOGIiwiYWVsaWciOiLDpiIsImFmIjoi4oGhIiwiQWZyIjoi8J2UhCIsImFmciI6IvCdlJ4iLCJBZ3JhdmUiOiLDgCIsImFncmF2ZSI6IsOgIiwiYWxlZnN5bSI6IuKEtSIsImFsZXBoIjoi4oS1IiwiQWxwaGEiOiLOkSIsImFscGhhIjoizrEiLCJBbWFjciI6IsSAIiwiYW1hY3IiOiLEgSIsImFtYWxnIjoi4qi/IiwiYW1wIjoiJiIsIkFNUCI6IiYiLCJhbmRhbmQiOiLiqZUiLCJBbmQiOiLiqZMiLCJhbmQiOiLiiKciLCJhbmRkIjoi4qmcIiwiYW5kc2xvcGUiOiLiqZgiLCJhbmR2Ijoi4qmaIiwiYW5nIjoi4oigIiwiYW5nZSI6IuKmpCIsImFuZ2xlIjoi4oigIiwiYW5nbXNkYWEiOiLipqgiLCJhbmdtc2RhYiI6IuKmqSIsImFuZ21zZGFjIjoi4qaqIiwiYW5nbXNkYWQiOiLipqsiLCJhbmdtc2RhZSI6IuKmrCIsImFuZ21zZGFmIjoi4qatIiwiYW5nbXNkYWciOiLipq4iLCJhbmdtc2RhaCI6IuKmryIsImFuZ21zZCI6IuKIoSIsImFuZ3J0Ijoi4oifIiwiYW5ncnR2YiI6IuKKviIsImFuZ3J0dmJkIjoi4qadIiwiYW5nc3BoIjoi4oiiIiwiYW5nc3QiOiLDhSIsImFuZ3phcnIiOiLijbwiLCJBb2dvbiI6IsSEIiwiYW9nb24iOiLEhSIsIkFvcGYiOiLwnZS4IiwiYW9wZiI6IvCdlZIiLCJhcGFjaXIiOiLiqa8iLCJhcCI6IuKJiCIsImFwRSI6IuKpsCIsImFwZSI6IuKJiiIsImFwaWQiOiLiiYsiLCJhcG9zIjoiXCciLCJBcHBseUZ1bmN0aW9uIjoi4oGhIiwiYXBwcm94Ijoi4omIIiwiYXBwcm94ZXEiOiLiiYoiLCJBcmluZyI6IsOFIiwiYXJpbmciOiLDpSIsIkFzY3IiOiLwnZKcIiwiYXNjciI6IvCdkrYiLCJBc3NpZ24iOiLiiZQiLCJhc3QiOiIqIiwiYXN5bXAiOiLiiYgiLCJhc3ltcGVxIjoi4omNIiwiQXRpbGRlIjoiw4MiLCJhdGlsZGUiOiLDoyIsIkF1bWwiOiLDhCIsImF1bWwiOiLDpCIsImF3Y29uaW50Ijoi4oizIiwiYXdpbnQiOiLiqJEiLCJiYWNrY29uZyI6IuKJjCIsImJhY2tlcHNpbG9uIjoiz7YiLCJiYWNrcHJpbWUiOiLigLUiLCJiYWNrc2ltIjoi4oi9IiwiYmFja3NpbWVxIjoi4ouNIiwiQmFja3NsYXNoIjoi4oiWIiwiQmFydiI6IuKrpyIsImJhcnZlZSI6IuKKvSIsImJhcndlZCI6IuKMhSIsIkJhcndlZCI6IuKMhiIsImJhcndlZGdlIjoi4oyFIiwiYmJyayI6IuKOtSIsImJicmt0YnJrIjoi4o62IiwiYmNvbmciOiLiiYwiLCJCY3kiOiLQkSIsImJjeSI6ItCxIiwiYmRxdW8iOiLigJ4iLCJiZWNhdXMiOiLiiLUiLCJiZWNhdXNlIjoi4oi1IiwiQmVjYXVzZSI6IuKItSIsImJlbXB0eXYiOiLiprAiLCJiZXBzaSI6Is+2IiwiYmVybm91Ijoi4oSsIiwiQmVybm91bGxpcyI6IuKErCIsIkJldGEiOiLOkiIsImJldGEiOiLOsiIsImJldGgiOiLihLYiLCJiZXR3ZWVuIjoi4omsIiwiQmZyIjoi8J2UhSIsImJmciI6IvCdlJ8iLCJiaWdjYXAiOiLii4IiLCJiaWdjaXJjIjoi4pevIiwiYmlnY3VwIjoi4ouDIiwiYmlnb2RvdCI6IuKogCIsImJpZ29wbHVzIjoi4qiBIiwiYmlnb3RpbWVzIjoi4qiCIiwiYmlnc3FjdXAiOiLiqIYiLCJiaWdzdGFyIjoi4piFIiwiYmlndHJpYW5nbGVkb3duIjoi4pa9IiwiYmlndHJpYW5nbGV1cCI6IuKWsyIsImJpZ3VwbHVzIjoi4qiEIiwiYmlndmVlIjoi4ouBIiwiYmlnd2VkZ2UiOiLii4AiLCJia2Fyb3ciOiLipI0iLCJibGFja2xvemVuZ2UiOiLip6siLCJibGFja3NxdWFyZSI6IuKWqiIsImJsYWNrdHJpYW5nbGUiOiLilrQiLCJibGFja3RyaWFuZ2xlZG93biI6IuKWviIsImJsYWNrdHJpYW5nbGVsZWZ0Ijoi4peCIiwiYmxhY2t0cmlhbmdsZXJpZ2h0Ijoi4pa4IiwiYmxhbmsiOiLikKMiLCJibGsxMiI6IuKWkiIsImJsazE0Ijoi4paRIiwiYmxrMzQiOiLilpMiLCJibG9jayI6IuKWiCIsImJuZSI6Ij3ig6UiLCJibmVxdWl2Ijoi4omh4oOlIiwiYk5vdCI6IuKrrSIsImJub3QiOiLijJAiLCJCb3BmIjoi8J2UuSIsImJvcGYiOiLwnZWTIiwiYm90Ijoi4oqlIiwiYm90dG9tIjoi4oqlIiwiYm93dGllIjoi4ouIIiwiYm94Ym94Ijoi4qeJIiwiYm94ZGwiOiLilJAiLCJib3hkTCI6IuKVlSIsImJveERsIjoi4pWWIiwiYm94REwiOiLilZciLCJib3hkciI6IuKUjCIsImJveGRSIjoi4pWSIiwiYm94RHIiOiLilZMiLCJib3hEUiI6IuKVlCIsImJveGgiOiLilIAiLCJib3hIIjoi4pWQIiwiYm94aGQiOiLilKwiLCJib3hIZCI6IuKVpCIsImJveGhEIjoi4pWlIiwiYm94SEQiOiLilaYiLCJib3hodSI6IuKUtCIsImJveEh1Ijoi4pWnIiwiYm94aFUiOiLilagiLCJib3hIVSI6IuKVqSIsImJveG1pbnVzIjoi4oqfIiwiYm94cGx1cyI6IuKKniIsImJveHRpbWVzIjoi4oqgIiwiYm94dWwiOiLilJgiLCJib3h1TCI6IuKVmyIsImJveFVsIjoi4pWcIiwiYm94VUwiOiLilZ0iLCJib3h1ciI6IuKUlCIsImJveHVSIjoi4pWYIiwiYm94VXIiOiLilZkiLCJib3hVUiI6IuKVmiIsImJveHYiOiLilIIiLCJib3hWIjoi4pWRIiwiYm94dmgiOiLilLwiLCJib3h2SCI6IuKVqiIsImJveFZoIjoi4pWrIiwiYm94VkgiOiLilawiLCJib3h2bCI6IuKUpCIsImJveHZMIjoi4pWhIiwiYm94VmwiOiLilaIiLCJib3hWTCI6IuKVoyIsImJveHZyIjoi4pScIiwiYm94dlIiOiLilZ4iLCJib3hWciI6IuKVnyIsImJveFZSIjoi4pWgIiwiYnByaW1lIjoi4oC1IiwiYnJldmUiOiLLmCIsIkJyZXZlIjoiy5giLCJicnZiYXIiOiLCpiIsImJzY3IiOiLwnZK3IiwiQnNjciI6IuKErCIsImJzZW1pIjoi4oGPIiwiYnNpbSI6IuKIvSIsImJzaW1lIjoi4ouNIiwiYnNvbGIiOiLip4UiLCJic29sIjoiXFxcXCIsImJzb2xoc3ViIjoi4p+IIiwiYnVsbCI6IuKAoiIsImJ1bGxldCI6IuKAoiIsImJ1bXAiOiLiiY4iLCJidW1wRSI6IuKqriIsImJ1bXBlIjoi4omPIiwiQnVtcGVxIjoi4omOIiwiYnVtcGVxIjoi4omPIiwiQ2FjdXRlIjoixIYiLCJjYWN1dGUiOiLEhyIsImNhcGFuZCI6IuKphCIsImNhcGJyY3VwIjoi4qmJIiwiY2FwY2FwIjoi4qmLIiwiY2FwIjoi4oipIiwiQ2FwIjoi4ouSIiwiY2FwY3VwIjoi4qmHIiwiY2FwZG90Ijoi4qmAIiwiQ2FwaXRhbERpZmZlcmVudGlhbEQiOiLihYUiLCJjYXBzIjoi4oip77iAIiwiY2FyZXQiOiLigYEiLCJjYXJvbiI6IsuHIiwiQ2F5bGV5cyI6IuKErSIsImNjYXBzIjoi4qmNIiwiQ2Nhcm9uIjoixIwiLCJjY2Fyb24iOiLEjSIsIkNjZWRpbCI6IsOHIiwiY2NlZGlsIjoiw6ciLCJDY2lyYyI6IsSIIiwiY2NpcmMiOiLEiSIsIkNjb25pbnQiOiLiiLAiLCJjY3VwcyI6IuKpjCIsImNjdXBzc20iOiLiqZAiLCJDZG90IjoixIoiLCJjZG90IjoixIsiLCJjZWRpbCI6IsK4IiwiQ2VkaWxsYSI6IsK4IiwiY2VtcHR5diI6IuKmsiIsImNlbnQiOiLCoiIsImNlbnRlcmRvdCI6IsK3IiwiQ2VudGVyRG90IjoiwrciLCJjZnIiOiLwnZSgIiwiQ2ZyIjoi4oStIiwiQ0hjeSI6ItCnIiwiY2hjeSI6ItGHIiwiY2hlY2siOiLinJMiLCJjaGVja21hcmsiOiLinJMiLCJDaGkiOiLOpyIsImNoaSI6Is+HIiwiY2lyYyI6IsuGIiwiY2lyY2VxIjoi4omXIiwiY2lyY2xlYXJyb3dsZWZ0Ijoi4oa6IiwiY2lyY2xlYXJyb3dyaWdodCI6IuKGuyIsImNpcmNsZWRhc3QiOiLiipsiLCJjaXJjbGVkY2lyYyI6IuKKmiIsImNpcmNsZWRkYXNoIjoi4oqdIiwiQ2lyY2xlRG90Ijoi4oqZIiwiY2lyY2xlZFIiOiLCriIsImNpcmNsZWRTIjoi4pOIIiwiQ2lyY2xlTWludXMiOiLiipYiLCJDaXJjbGVQbHVzIjoi4oqVIiwiQ2lyY2xlVGltZXMiOiLiipciLCJjaXIiOiLil4siLCJjaXJFIjoi4qeDIiwiY2lyZSI6IuKJlyIsImNpcmZuaW50Ijoi4qiQIiwiY2lybWlkIjoi4quvIiwiY2lyc2NpciI6IuKngiIsIkNsb2Nrd2lzZUNvbnRvdXJJbnRlZ3JhbCI6IuKIsiIsIkNsb3NlQ3VybHlEb3VibGVRdW90ZSI6IuKAnSIsIkNsb3NlQ3VybHlRdW90ZSI6IuKAmSIsImNsdWJzIjoi4pmjIiwiY2x1YnN1aXQiOiLimaMiLCJjb2xvbiI6IjoiLCJDb2xvbiI6IuKItyIsIkNvbG9uZSI6IuKptCIsImNvbG9uZSI6IuKJlCIsImNvbG9uZXEiOiLiiZQiLCJjb21tYSI6IiwiLCJjb21tYXQiOiJAIiwiY29tcCI6IuKIgSIsImNvbXBmbiI6IuKImCIsImNvbXBsZW1lbnQiOiLiiIEiLCJjb21wbGV4ZXMiOiLihIIiLCJjb25nIjoi4omFIiwiY29uZ2RvdCI6IuKprSIsIkNvbmdydWVudCI6IuKJoSIsImNvbmludCI6IuKIriIsIkNvbmludCI6IuKIryIsIkNvbnRvdXJJbnRlZ3JhbCI6IuKIriIsImNvcGYiOiLwnZWUIiwiQ29wZiI6IuKEgiIsImNvcHJvZCI6IuKIkCIsIkNvcHJvZHVjdCI6IuKIkCIsImNvcHkiOiLCqSIsIkNPUFkiOiLCqSIsImNvcHlzciI6IuKElyIsIkNvdW50ZXJDbG9ja3dpc2VDb250b3VySW50ZWdyYWwiOiLiiLMiLCJjcmFyciI6IuKGtSIsImNyb3NzIjoi4pyXIiwiQ3Jvc3MiOiLiqK8iLCJDc2NyIjoi8J2SniIsImNzY3IiOiLwnZK4IiwiY3N1YiI6IuKrjyIsImNzdWJlIjoi4quRIiwiY3N1cCI6IuKrkCIsImNzdXBlIjoi4quSIiwiY3Rkb3QiOiLii68iLCJjdWRhcnJsIjoi4qS4IiwiY3VkYXJyciI6IuKktSIsImN1ZXByIjoi4oueIiwiY3Vlc2MiOiLii58iLCJjdWxhcnIiOiLihrYiLCJjdWxhcnJwIjoi4qS9IiwiY3VwYnJjYXAiOiLiqYgiLCJjdXBjYXAiOiLiqYYiLCJDdXBDYXAiOiLiiY0iLCJjdXAiOiLiiKoiLCJDdXAiOiLii5MiLCJjdXBjdXAiOiLiqYoiLCJjdXBkb3QiOiLiio0iLCJjdXBvciI6IuKphSIsImN1cHMiOiLiiKrvuIAiLCJjdXJhcnIiOiLihrciLCJjdXJhcnJtIjoi4qS8IiwiY3VybHllcXByZWMiOiLii54iLCJjdXJseWVxc3VjYyI6IuKLnyIsImN1cmx5dmVlIjoi4ouOIiwiY3VybHl3ZWRnZSI6IuKLjyIsImN1cnJlbiI6IsKkIiwiY3VydmVhcnJvd2xlZnQiOiLihrYiLCJjdXJ2ZWFycm93cmlnaHQiOiLihrciLCJjdXZlZSI6IuKLjiIsImN1d2VkIjoi4ouPIiwiY3djb25pbnQiOiLiiLIiLCJjd2ludCI6IuKIsSIsImN5bGN0eSI6IuKMrSIsImRhZ2dlciI6IuKAoCIsIkRhZ2dlciI6IuKAoSIsImRhbGV0aCI6IuKEuCIsImRhcnIiOiLihpMiLCJEYXJyIjoi4oahIiwiZEFyciI6IuKHkyIsImRhc2giOiLigJAiLCJEYXNodiI6IuKrpCIsImRhc2h2Ijoi4oqjIiwiZGJrYXJvdyI6IuKkjyIsImRibGFjIjoiy50iLCJEY2Fyb24iOiLEjiIsImRjYXJvbiI6IsSPIiwiRGN5Ijoi0JQiLCJkY3kiOiLQtCIsImRkYWdnZXIiOiLigKEiLCJkZGFyciI6IuKHiiIsIkREIjoi4oWFIiwiZGQiOiLihYYiLCJERG90cmFoZCI6IuKkkSIsImRkb3RzZXEiOiLiqbciLCJkZWciOiLCsCIsIkRlbCI6IuKIhyIsIkRlbHRhIjoizpQiLCJkZWx0YSI6Is60IiwiZGVtcHR5diI6IuKmsSIsImRmaXNodCI6IuKlvyIsIkRmciI6IvCdlIciLCJkZnIiOiLwnZShIiwiZEhhciI6IuKlpSIsImRoYXJsIjoi4oeDIiwiZGhhcnIiOiLih4IiLCJEaWFjcml0aWNhbEFjdXRlIjoiwrQiLCJEaWFjcml0aWNhbERvdCI6IsuZIiwiRGlhY3JpdGljYWxEb3VibGVBY3V0ZSI6IsudIiwiRGlhY3JpdGljYWxHcmF2ZSI6ImAiLCJEaWFjcml0aWNhbFRpbGRlIjoiy5wiLCJkaWFtIjoi4ouEIiwiZGlhbW9uZCI6IuKLhCIsIkRpYW1vbmQiOiLii4QiLCJkaWFtb25kc3VpdCI6IuKZpiIsImRpYW1zIjoi4pmmIiwiZGllIjoiwqgiLCJEaWZmZXJlbnRpYWxEIjoi4oWGIiwiZGlnYW1tYSI6Is+dIiwiZGlzaW4iOiLii7IiLCJkaXYiOiLDtyIsImRpdmlkZSI6IsO3IiwiZGl2aWRlb250aW1lcyI6IuKLhyIsImRpdm9ueCI6IuKLhyIsIkRKY3kiOiLQgiIsImRqY3kiOiLRkiIsImRsY29ybiI6IuKMniIsImRsY3JvcCI6IuKMjSIsImRvbGxhciI6IiQiLCJEb3BmIjoi8J2UuyIsImRvcGYiOiLwnZWVIiwiRG90IjoiwqgiLCJkb3QiOiLLmSIsIkRvdERvdCI6IuKDnCIsImRvdGVxIjoi4omQIiwiZG90ZXFkb3QiOiLiiZEiLCJEb3RFcXVhbCI6IuKJkCIsImRvdG1pbnVzIjoi4oi4IiwiZG90cGx1cyI6IuKIlCIsImRvdHNxdWFyZSI6IuKKoSIsImRvdWJsZWJhcndlZGdlIjoi4oyGIiwiRG91YmxlQ29udG91ckludGVncmFsIjoi4oivIiwiRG91YmxlRG90IjoiwqgiLCJEb3VibGVEb3duQXJyb3ciOiLih5MiLCJEb3VibGVMZWZ0QXJyb3ciOiLih5AiLCJEb3VibGVMZWZ0UmlnaHRBcnJvdyI6IuKHlCIsIkRvdWJsZUxlZnRUZWUiOiLiq6QiLCJEb3VibGVMb25nTGVmdEFycm93Ijoi4p+4IiwiRG91YmxlTG9uZ0xlZnRSaWdodEFycm93Ijoi4p+6IiwiRG91YmxlTG9uZ1JpZ2h0QXJyb3ciOiLin7kiLCJEb3VibGVSaWdodEFycm93Ijoi4oeSIiwiRG91YmxlUmlnaHRUZWUiOiLiiqgiLCJEb3VibGVVcEFycm93Ijoi4oeRIiwiRG91YmxlVXBEb3duQXJyb3ciOiLih5UiLCJEb3VibGVWZXJ0aWNhbEJhciI6IuKIpSIsIkRvd25BcnJvd0JhciI6IuKkkyIsImRvd25hcnJvdyI6IuKGkyIsIkRvd25BcnJvdyI6IuKGkyIsIkRvd25hcnJvdyI6IuKHkyIsIkRvd25BcnJvd1VwQXJyb3ciOiLih7UiLCJEb3duQnJldmUiOiLMkSIsImRvd25kb3duYXJyb3dzIjoi4oeKIiwiZG93bmhhcnBvb25sZWZ0Ijoi4oeDIiwiZG93bmhhcnBvb25yaWdodCI6IuKHgiIsIkRvd25MZWZ0UmlnaHRWZWN0b3IiOiLipZAiLCJEb3duTGVmdFRlZVZlY3RvciI6IuKlniIsIkRvd25MZWZ0VmVjdG9yQmFyIjoi4qWWIiwiRG93bkxlZnRWZWN0b3IiOiLihr0iLCJEb3duUmlnaHRUZWVWZWN0b3IiOiLipZ8iLCJEb3duUmlnaHRWZWN0b3JCYXIiOiLipZciLCJEb3duUmlnaHRWZWN0b3IiOiLih4EiLCJEb3duVGVlQXJyb3ciOiLihqciLCJEb3duVGVlIjoi4oqkIiwiZHJia2Fyb3ciOiLipJAiLCJkcmNvcm4iOiLijJ8iLCJkcmNyb3AiOiLijIwiLCJEc2NyIjoi8J2SnyIsImRzY3IiOiLwnZK5IiwiRFNjeSI6ItCFIiwiZHNjeSI6ItGVIiwiZHNvbCI6IuKntiIsIkRzdHJvayI6IsSQIiwiZHN0cm9rIjoixJEiLCJkdGRvdCI6IuKLsSIsImR0cmkiOiLilr8iLCJkdHJpZiI6IuKWviIsImR1YXJyIjoi4oe1IiwiZHVoYXIiOiLipa8iLCJkd2FuZ2xlIjoi4qamIiwiRFpjeSI6ItCPIiwiZHpjeSI6ItGfIiwiZHppZ3JhcnIiOiLin78iLCJFYWN1dGUiOiLDiSIsImVhY3V0ZSI6IsOpIiwiZWFzdGVyIjoi4qmuIiwiRWNhcm9uIjoixJoiLCJlY2Fyb24iOiLEmyIsIkVjaXJjIjoiw4oiLCJlY2lyYyI6IsOqIiwiZWNpciI6IuKJliIsImVjb2xvbiI6IuKJlSIsIkVjeSI6ItCtIiwiZWN5Ijoi0Y0iLCJlRERvdCI6IuKptyIsIkVkb3QiOiLEliIsImVkb3QiOiLElyIsImVEb3QiOiLiiZEiLCJlZSI6IuKFhyIsImVmRG90Ijoi4omSIiwiRWZyIjoi8J2UiCIsImVmciI6IvCdlKIiLCJlZyI6IuKqmiIsIkVncmF2ZSI6IsOIIiwiZWdyYXZlIjoiw6giLCJlZ3MiOiLiqpYiLCJlZ3Nkb3QiOiLiqpgiLCJlbCI6IuKqmSIsIkVsZW1lbnQiOiLiiIgiLCJlbGludGVycyI6IuKPpyIsImVsbCI6IuKEkyIsImVscyI6IuKqlSIsImVsc2RvdCI6IuKqlyIsIkVtYWNyIjoixJIiLCJlbWFjciI6IsSTIiwiZW1wdHkiOiLiiIUiLCJlbXB0eXNldCI6IuKIhSIsIkVtcHR5U21hbGxTcXVhcmUiOiLil7siLCJlbXB0eXYiOiLiiIUiLCJFbXB0eVZlcnlTbWFsbFNxdWFyZSI6IuKWqyIsImVtc3AxMyI6IuKAhCIsImVtc3AxNCI6IuKAhSIsImVtc3AiOiLigIMiLCJFTkciOiLFiiIsImVuZyI6IsWLIiwiZW5zcCI6IuKAgiIsIkVvZ29uIjoixJgiLCJlb2dvbiI6IsSZIiwiRW9wZiI6IvCdlLwiLCJlb3BmIjoi8J2VliIsImVwYXIiOiLii5UiLCJlcGFyc2wiOiLip6MiLCJlcGx1cyI6IuKpsSIsImVwc2kiOiLOtSIsIkVwc2lsb24iOiLOlSIsImVwc2lsb24iOiLOtSIsImVwc2l2Ijoiz7UiLCJlcWNpcmMiOiLiiZYiLCJlcWNvbG9uIjoi4omVIiwiZXFzaW0iOiLiiYIiLCJlcXNsYW50Z3RyIjoi4qqWIiwiZXFzbGFudGxlc3MiOiLiqpUiLCJFcXVhbCI6IuKptSIsImVxdWFscyI6Ij0iLCJFcXVhbFRpbGRlIjoi4omCIiwiZXF1ZXN0Ijoi4omfIiwiRXF1aWxpYnJpdW0iOiLih4wiLCJlcXVpdiI6IuKJoSIsImVxdWl2REQiOiLiqbgiLCJlcXZwYXJzbCI6IuKnpSIsImVyYXJyIjoi4qWxIiwiZXJEb3QiOiLiiZMiLCJlc2NyIjoi4oSvIiwiRXNjciI6IuKEsCIsImVzZG90Ijoi4omQIiwiRXNpbSI6IuKpsyIsImVzaW0iOiLiiYIiLCJFdGEiOiLOlyIsImV0YSI6Is63IiwiRVRIIjoiw5AiLCJldGgiOiLDsCIsIkV1bWwiOiLDiyIsImV1bWwiOiLDqyIsImV1cm8iOiLigqwiLCJleGNsIjoiISIsImV4aXN0Ijoi4oiDIiwiRXhpc3RzIjoi4oiDIiwiZXhwZWN0YXRpb24iOiLihLAiLCJleHBvbmVudGlhbGUiOiLihYciLCJFeHBvbmVudGlhbEUiOiLihYciLCJmYWxsaW5nZG90c2VxIjoi4omSIiwiRmN5Ijoi0KQiLCJmY3kiOiLRhCIsImZlbWFsZSI6IuKZgCIsImZmaWxpZyI6Iu+sgyIsImZmbGlnIjoi76yAIiwiZmZsbGlnIjoi76yEIiwiRmZyIjoi8J2UiSIsImZmciI6IvCdlKMiLCJmaWxpZyI6Iu+sgSIsIkZpbGxlZFNtYWxsU3F1YXJlIjoi4pe8IiwiRmlsbGVkVmVyeVNtYWxsU3F1YXJlIjoi4paqIiwiZmpsaWciOiJmaiIsImZsYXQiOiLima0iLCJmbGxpZyI6Iu+sgiIsImZsdG5zIjoi4paxIiwiZm5vZiI6IsaSIiwiRm9wZiI6IvCdlL0iLCJmb3BmIjoi8J2VlyIsImZvcmFsbCI6IuKIgCIsIkZvckFsbCI6IuKIgCIsImZvcmsiOiLii5QiLCJmb3JrdiI6IuKrmSIsIkZvdXJpZXJ0cmYiOiLihLEiLCJmcGFydGludCI6IuKojSIsImZyYWMxMiI6IsK9IiwiZnJhYzEzIjoi4oWTIiwiZnJhYzE0IjoiwrwiLCJmcmFjMTUiOiLihZUiLCJmcmFjMTYiOiLihZkiLCJmcmFjMTgiOiLihZsiLCJmcmFjMjMiOiLihZQiLCJmcmFjMjUiOiLihZYiLCJmcmFjMzQiOiLCviIsImZyYWMzNSI6IuKFlyIsImZyYWMzOCI6IuKFnCIsImZyYWM0NSI6IuKFmCIsImZyYWM1NiI6IuKFmiIsImZyYWM1OCI6IuKFnSIsImZyYWM3OCI6IuKFniIsImZyYXNsIjoi4oGEIiwiZnJvd24iOiLijKIiLCJmc2NyIjoi8J2SuyIsIkZzY3IiOiLihLEiLCJnYWN1dGUiOiLHtSIsIkdhbW1hIjoizpMiLCJnYW1tYSI6Is6zIiwiR2FtbWFkIjoiz5wiLCJnYW1tYWQiOiLPnSIsImdhcCI6IuKqhiIsIkdicmV2ZSI6IsSeIiwiZ2JyZXZlIjoixJ8iLCJHY2VkaWwiOiLEoiIsIkdjaXJjIjoixJwiLCJnY2lyYyI6IsSdIiwiR2N5Ijoi0JMiLCJnY3kiOiLQsyIsIkdkb3QiOiLEoCIsImdkb3QiOiLEoSIsImdlIjoi4omlIiwiZ0UiOiLiiaciLCJnRWwiOiLiqowiLCJnZWwiOiLii5siLCJnZXEiOiLiiaUiLCJnZXFxIjoi4omnIiwiZ2Vxc2xhbnQiOiLiqb4iLCJnZXNjYyI6IuKqqSIsImdlcyI6IuKpviIsImdlc2RvdCI6IuKqgCIsImdlc2RvdG8iOiLiqoIiLCJnZXNkb3RvbCI6IuKqhCIsImdlc2wiOiLii5vvuIAiLCJnZXNsZXMiOiLiqpQiLCJHZnIiOiLwnZSKIiwiZ2ZyIjoi8J2UpCIsImdnIjoi4omrIiwiR2ciOiLii5kiLCJnZ2ciOiLii5kiLCJnaW1lbCI6IuKEtyIsIkdKY3kiOiLQgyIsImdqY3kiOiLRkyIsImdsYSI6IuKqpSIsImdsIjoi4om3IiwiZ2xFIjoi4qqSIiwiZ2xqIjoi4qqkIiwiZ25hcCI6IuKqiiIsImduYXBwcm94Ijoi4qqKIiwiZ25lIjoi4qqIIiwiZ25FIjoi4ompIiwiZ25lcSI6IuKqiCIsImduZXFxIjoi4ompIiwiZ25zaW0iOiLii6ciLCJHb3BmIjoi8J2UviIsImdvcGYiOiLwnZWYIiwiZ3JhdmUiOiJgIiwiR3JlYXRlckVxdWFsIjoi4omlIiwiR3JlYXRlckVxdWFsTGVzcyI6IuKLmyIsIkdyZWF0ZXJGdWxsRXF1YWwiOiLiiaciLCJHcmVhdGVyR3JlYXRlciI6IuKqoiIsIkdyZWF0ZXJMZXNzIjoi4om3IiwiR3JlYXRlclNsYW50RXF1YWwiOiLiqb4iLCJHcmVhdGVyVGlsZGUiOiLiibMiLCJHc2NyIjoi8J2SoiIsImdzY3IiOiLihIoiLCJnc2ltIjoi4omzIiwiZ3NpbWUiOiLiqo4iLCJnc2ltbCI6IuKqkCIsImd0Y2MiOiLiqqciLCJndGNpciI6IuKpuiIsImd0IjoiPiIsIkdUIjoiPiIsIkd0Ijoi4omrIiwiZ3Rkb3QiOiLii5ciLCJndGxQYXIiOiLippUiLCJndHF1ZXN0Ijoi4qm8IiwiZ3RyYXBwcm94Ijoi4qqGIiwiZ3RyYXJyIjoi4qW4IiwiZ3RyZG90Ijoi4ouXIiwiZ3RyZXFsZXNzIjoi4oubIiwiZ3RyZXFxbGVzcyI6IuKqjCIsImd0cmxlc3MiOiLiibciLCJndHJzaW0iOiLiibMiLCJndmVydG5lcXEiOiLiianvuIAiLCJndm5FIjoi4omp77iAIiwiSGFjZWsiOiLLhyIsImhhaXJzcCI6IuKAiiIsImhhbGYiOiLCvSIsImhhbWlsdCI6IuKEiyIsIkhBUkRjeSI6ItCqIiwiaGFyZGN5Ijoi0YoiLCJoYXJyY2lyIjoi4qWIIiwiaGFyciI6IuKGlCIsImhBcnIiOiLih5QiLCJoYXJydyI6IuKGrSIsIkhhdCI6Il4iLCJoYmFyIjoi4oSPIiwiSGNpcmMiOiLEpCIsImhjaXJjIjoixKUiLCJoZWFydHMiOiLimaUiLCJoZWFydHN1aXQiOiLimaUiLCJoZWxsaXAiOiLigKYiLCJoZXJjb24iOiLiirkiLCJoZnIiOiLwnZSlIiwiSGZyIjoi4oSMIiwiSGlsYmVydFNwYWNlIjoi4oSLIiwiaGtzZWFyb3ciOiLipKUiLCJoa3N3YXJvdyI6IuKkpiIsImhvYXJyIjoi4oe/IiwiaG9tdGh0Ijoi4oi7IiwiaG9va2xlZnRhcnJvdyI6IuKGqSIsImhvb2tyaWdodGFycm93Ijoi4oaqIiwiaG9wZiI6IvCdlZkiLCJIb3BmIjoi4oSNIiwiaG9yYmFyIjoi4oCVIiwiSG9yaXpvbnRhbExpbmUiOiLilIAiLCJoc2NyIjoi8J2SvSIsIkhzY3IiOiLihIsiLCJoc2xhc2giOiLihI8iLCJIc3Ryb2siOiLEpiIsImhzdHJvayI6IsSnIiwiSHVtcERvd25IdW1wIjoi4omOIiwiSHVtcEVxdWFsIjoi4omPIiwiaHlidWxsIjoi4oGDIiwiaHlwaGVuIjoi4oCQIiwiSWFjdXRlIjoiw40iLCJpYWN1dGUiOiLDrSIsImljIjoi4oGjIiwiSWNpcmMiOiLDjiIsImljaXJjIjoiw64iLCJJY3kiOiLQmCIsImljeSI6ItC4IiwiSWRvdCI6IsSwIiwiSUVjeSI6ItCVIiwiaWVjeSI6ItC1IiwiaWV4Y2wiOiLCoSIsImlmZiI6IuKHlCIsImlmciI6IvCdlKYiLCJJZnIiOiLihJEiLCJJZ3JhdmUiOiLDjCIsImlncmF2ZSI6IsOsIiwiaWkiOiLihYgiLCJpaWlpbnQiOiLiqIwiLCJpaWludCI6IuKIrSIsImlpbmZpbiI6IuKnnCIsImlpb3RhIjoi4oSpIiwiSUpsaWciOiLEsiIsImlqbGlnIjoixLMiLCJJbWFjciI6IsSqIiwiaW1hY3IiOiLEqyIsImltYWdlIjoi4oSRIiwiSW1hZ2luYXJ5SSI6IuKFiCIsImltYWdsaW5lIjoi4oSQIiwiaW1hZ3BhcnQiOiLihJEiLCJpbWF0aCI6IsSxIiwiSW0iOiLihJEiLCJpbW9mIjoi4oq3IiwiaW1wZWQiOiLGtSIsIkltcGxpZXMiOiLih5IiLCJpbmNhcmUiOiLihIUiLCJpbiI6IuKIiCIsImluZmluIjoi4oieIiwiaW5maW50aWUiOiLip50iLCJpbm9kb3QiOiLEsSIsImludGNhbCI6IuKKuiIsImludCI6IuKIqyIsIkludCI6IuKIrCIsImludGVnZXJzIjoi4oSkIiwiSW50ZWdyYWwiOiLiiKsiLCJpbnRlcmNhbCI6IuKKuiIsIkludGVyc2VjdGlvbiI6IuKLgiIsImludGxhcmhrIjoi4qiXIiwiaW50cHJvZCI6IuKovCIsIkludmlzaWJsZUNvbW1hIjoi4oGjIiwiSW52aXNpYmxlVGltZXMiOiLigaIiLCJJT2N5Ijoi0IEiLCJpb2N5Ijoi0ZEiLCJJb2dvbiI6IsSuIiwiaW9nb24iOiLEryIsIklvcGYiOiLwnZWAIiwiaW9wZiI6IvCdlZoiLCJJb3RhIjoizpkiLCJpb3RhIjoizrkiLCJpcHJvZCI6IuKovCIsImlxdWVzdCI6IsK/IiwiaXNjciI6IvCdkr4iLCJJc2NyIjoi4oSQIiwiaXNpbiI6IuKIiCIsImlzaW5kb3QiOiLii7UiLCJpc2luRSI6IuKLuSIsImlzaW5zIjoi4ou0IiwiaXNpbnN2Ijoi4ouzIiwiaXNpbnYiOiLiiIgiLCJpdCI6IuKBoiIsIkl0aWxkZSI6IsSoIiwiaXRpbGRlIjoixKkiLCJJdWtjeSI6ItCGIiwiaXVrY3kiOiLRliIsIkl1bWwiOiLDjyIsIml1bWwiOiLDryIsIkpjaXJjIjoixLQiLCJqY2lyYyI6IsS1IiwiSmN5Ijoi0JkiLCJqY3kiOiLQuSIsIkpmciI6IvCdlI0iLCJqZnIiOiLwnZSnIiwiam1hdGgiOiLItyIsIkpvcGYiOiLwnZWBIiwiam9wZiI6IvCdlZsiLCJKc2NyIjoi8J2SpSIsImpzY3IiOiLwnZK/IiwiSnNlcmN5Ijoi0IgiLCJqc2VyY3kiOiLRmCIsIkp1a2N5Ijoi0IQiLCJqdWtjeSI6ItGUIiwiS2FwcGEiOiLOmiIsImthcHBhIjoizroiLCJrYXBwYXYiOiLPsCIsIktjZWRpbCI6IsS2Iiwia2NlZGlsIjoixLciLCJLY3kiOiLQmiIsImtjeSI6ItC6IiwiS2ZyIjoi8J2UjiIsImtmciI6IvCdlKgiLCJrZ3JlZW4iOiLEuCIsIktIY3kiOiLQpSIsImtoY3kiOiLRhSIsIktKY3kiOiLQjCIsImtqY3kiOiLRnCIsIktvcGYiOiLwnZWCIiwia29wZiI6IvCdlZwiLCJLc2NyIjoi8J2SpiIsImtzY3IiOiLwnZOAIiwibEFhcnIiOiLih5oiLCJMYWN1dGUiOiLEuSIsImxhY3V0ZSI6IsS6IiwibGFlbXB0eXYiOiLiprQiLCJsYWdyYW4iOiLihJIiLCJMYW1iZGEiOiLOmyIsImxhbWJkYSI6Is67IiwibGFuZyI6IuKfqCIsIkxhbmciOiLin6oiLCJsYW5nZCI6IuKmkSIsImxhbmdsZSI6IuKfqCIsImxhcCI6IuKqhSIsIkxhcGxhY2V0cmYiOiLihJIiLCJsYXF1byI6IsKrIiwibGFycmIiOiLih6QiLCJsYXJyYmZzIjoi4qSfIiwibGFyciI6IuKGkCIsIkxhcnIiOiLihp4iLCJsQXJyIjoi4oeQIiwibGFycmZzIjoi4qSdIiwibGFycmhrIjoi4oapIiwibGFycmxwIjoi4oarIiwibGFycnBsIjoi4qS5IiwibGFycnNpbSI6IuKlsyIsImxhcnJ0bCI6IuKGoiIsImxhdGFpbCI6IuKkmSIsImxBdGFpbCI6IuKkmyIsImxhdCI6IuKqqyIsImxhdGUiOiLiqq0iLCJsYXRlcyI6IuKqre+4gCIsImxiYXJyIjoi4qSMIiwibEJhcnIiOiLipI4iLCJsYmJyayI6IuKdsiIsImxicmFjZSI6InsiLCJsYnJhY2siOiJbIiwibGJya2UiOiLiposiLCJsYnJrc2xkIjoi4qaPIiwibGJya3NsdSI6IuKmjSIsIkxjYXJvbiI6IsS9IiwibGNhcm9uIjoixL4iLCJMY2VkaWwiOiLEuyIsImxjZWRpbCI6IsS8IiwibGNlaWwiOiLijIgiLCJsY3ViIjoieyIsIkxjeSI6ItCbIiwibGN5Ijoi0LsiLCJsZGNhIjoi4qS2IiwibGRxdW8iOiLigJwiLCJsZHF1b3IiOiLigJ4iLCJsZHJkaGFyIjoi4qWnIiwibGRydXNoYXIiOiLipYsiLCJsZHNoIjoi4oayIiwibGUiOiLiiaQiLCJsRSI6IuKJpiIsIkxlZnRBbmdsZUJyYWNrZXQiOiLin6giLCJMZWZ0QXJyb3dCYXIiOiLih6QiLCJsZWZ0YXJyb3ciOiLihpAiLCJMZWZ0QXJyb3ciOiLihpAiLCJMZWZ0YXJyb3ciOiLih5AiLCJMZWZ0QXJyb3dSaWdodEFycm93Ijoi4oeGIiwibGVmdGFycm93dGFpbCI6IuKGoiIsIkxlZnRDZWlsaW5nIjoi4oyIIiwiTGVmdERvdWJsZUJyYWNrZXQiOiLin6YiLCJMZWZ0RG93blRlZVZlY3RvciI6IuKloSIsIkxlZnREb3duVmVjdG9yQmFyIjoi4qWZIiwiTGVmdERvd25WZWN0b3IiOiLih4MiLCJMZWZ0Rmxvb3IiOiLijIoiLCJsZWZ0aGFycG9vbmRvd24iOiLihr0iLCJsZWZ0aGFycG9vbnVwIjoi4oa8IiwibGVmdGxlZnRhcnJvd3MiOiLih4ciLCJsZWZ0cmlnaHRhcnJvdyI6IuKGlCIsIkxlZnRSaWdodEFycm93Ijoi4oaUIiwiTGVmdHJpZ2h0YXJyb3ciOiLih5QiLCJsZWZ0cmlnaHRhcnJvd3MiOiLih4YiLCJsZWZ0cmlnaHRoYXJwb29ucyI6IuKHiyIsImxlZnRyaWdodHNxdWlnYXJyb3ciOiLihq0iLCJMZWZ0UmlnaHRWZWN0b3IiOiLipY4iLCJMZWZ0VGVlQXJyb3ciOiLihqQiLCJMZWZ0VGVlIjoi4oqjIiwiTGVmdFRlZVZlY3RvciI6IuKlmiIsImxlZnR0aHJlZXRpbWVzIjoi4ouLIiwiTGVmdFRyaWFuZ2xlQmFyIjoi4qePIiwiTGVmdFRyaWFuZ2xlIjoi4oqyIiwiTGVmdFRyaWFuZ2xlRXF1YWwiOiLiirQiLCJMZWZ0VXBEb3duVmVjdG9yIjoi4qWRIiwiTGVmdFVwVGVlVmVjdG9yIjoi4qWgIiwiTGVmdFVwVmVjdG9yQmFyIjoi4qWYIiwiTGVmdFVwVmVjdG9yIjoi4oa/IiwiTGVmdFZlY3RvckJhciI6IuKlkiIsIkxlZnRWZWN0b3IiOiLihrwiLCJsRWciOiLiqosiLCJsZWciOiLii5oiLCJsZXEiOiLiiaQiLCJsZXFxIjoi4ommIiwibGVxc2xhbnQiOiLiqb0iLCJsZXNjYyI6IuKqqCIsImxlcyI6IuKpvSIsImxlc2RvdCI6IuKpvyIsImxlc2RvdG8iOiLiqoEiLCJsZXNkb3RvciI6IuKqgyIsImxlc2ciOiLii5rvuIAiLCJsZXNnZXMiOiLiqpMiLCJsZXNzYXBwcm94Ijoi4qqFIiwibGVzc2RvdCI6IuKLliIsImxlc3NlcWd0ciI6IuKLmiIsImxlc3NlcXFndHIiOiLiqosiLCJMZXNzRXF1YWxHcmVhdGVyIjoi4ouaIiwiTGVzc0Z1bGxFcXVhbCI6IuKJpiIsIkxlc3NHcmVhdGVyIjoi4om2IiwibGVzc2d0ciI6IuKJtiIsIkxlc3NMZXNzIjoi4qqhIiwibGVzc3NpbSI6IuKJsiIsIkxlc3NTbGFudEVxdWFsIjoi4qm9IiwiTGVzc1RpbGRlIjoi4omyIiwibGZpc2h0Ijoi4qW8IiwibGZsb29yIjoi4oyKIiwiTGZyIjoi8J2UjyIsImxmciI6IvCdlKkiLCJsZyI6IuKJtiIsImxnRSI6IuKqkSIsImxIYXIiOiLipaIiLCJsaGFyZCI6IuKGvSIsImxoYXJ1Ijoi4oa8IiwibGhhcnVsIjoi4qWqIiwibGhibGsiOiLiloQiLCJMSmN5Ijoi0IkiLCJsamN5Ijoi0ZkiLCJsbGFyciI6IuKHhyIsImxsIjoi4omqIiwiTGwiOiLii5giLCJsbGNvcm5lciI6IuKMniIsIkxsZWZ0YXJyb3ciOiLih5oiLCJsbGhhcmQiOiLipasiLCJsbHRyaSI6IuKXuiIsIkxtaWRvdCI6IsS/IiwibG1pZG90IjoixYAiLCJsbW91c3RhY2hlIjoi4o6wIiwibG1vdXN0Ijoi4o6wIiwibG5hcCI6IuKqiSIsImxuYXBwcm94Ijoi4qqJIiwibG5lIjoi4qqHIiwibG5FIjoi4omoIiwibG5lcSI6IuKqhyIsImxuZXFxIjoi4omoIiwibG5zaW0iOiLii6YiLCJsb2FuZyI6IuKfrCIsImxvYXJyIjoi4oe9IiwibG9icmsiOiLin6YiLCJsb25nbGVmdGFycm93Ijoi4p+1IiwiTG9uZ0xlZnRBcnJvdyI6IuKftSIsIkxvbmdsZWZ0YXJyb3ciOiLin7giLCJsb25nbGVmdHJpZ2h0YXJyb3ciOiLin7ciLCJMb25nTGVmdFJpZ2h0QXJyb3ciOiLin7ciLCJMb25nbGVmdHJpZ2h0YXJyb3ciOiLin7oiLCJsb25nbWFwc3RvIjoi4p+8IiwibG9uZ3JpZ2h0YXJyb3ciOiLin7YiLCJMb25nUmlnaHRBcnJvdyI6IuKftiIsIkxvbmdyaWdodGFycm93Ijoi4p+5IiwibG9vcGFycm93bGVmdCI6IuKGqyIsImxvb3BhcnJvd3JpZ2h0Ijoi4oasIiwibG9wYXIiOiLipoUiLCJMb3BmIjoi8J2VgyIsImxvcGYiOiLwnZWdIiwibG9wbHVzIjoi4qitIiwibG90aW1lcyI6IuKotCIsImxvd2FzdCI6IuKIlyIsImxvd2JhciI6Il8iLCJMb3dlckxlZnRBcnJvdyI6IuKGmSIsIkxvd2VyUmlnaHRBcnJvdyI6IuKGmCIsImxveiI6IuKXiiIsImxvemVuZ2UiOiLil4oiLCJsb3pmIjoi4qerIiwibHBhciI6IigiLCJscGFybHQiOiLippMiLCJscmFyciI6IuKHhiIsImxyY29ybmVyIjoi4oyfIiwibHJoYXIiOiLih4siLCJscmhhcmQiOiLipa0iLCJscm0iOiLigI4iLCJscnRyaSI6IuKKvyIsImxzYXF1byI6IuKAuSIsImxzY3IiOiLwnZOBIiwiTHNjciI6IuKEkiIsImxzaCI6IuKGsCIsIkxzaCI6IuKGsCIsImxzaW0iOiLiibIiLCJsc2ltZSI6IuKqjSIsImxzaW1nIjoi4qqPIiwibHNxYiI6IlsiLCJsc3F1byI6IuKAmCIsImxzcXVvciI6IuKAmiIsIkxzdHJvayI6IsWBIiwibHN0cm9rIjoixYIiLCJsdGNjIjoi4qqmIiwibHRjaXIiOiLiqbkiLCJsdCI6IjwiLCJMVCI6IjwiLCJMdCI6IuKJqiIsImx0ZG90Ijoi4ouWIiwibHRocmVlIjoi4ouLIiwibHRpbWVzIjoi4ouJIiwibHRsYXJyIjoi4qW2IiwibHRxdWVzdCI6IuKpuyIsImx0cmkiOiLil4MiLCJsdHJpZSI6IuKKtCIsImx0cmlmIjoi4peCIiwibHRyUGFyIjoi4qaWIiwibHVyZHNoYXIiOiLipYoiLCJsdXJ1aGFyIjoi4qWmIiwibHZlcnRuZXFxIjoi4omo77iAIiwibHZuRSI6IuKJqO+4gCIsIm1hY3IiOiLCryIsIm1hbGUiOiLimYIiLCJtYWx0Ijoi4pygIiwibWFsdGVzZSI6IuKcoCIsIk1hcCI6IuKkhSIsIm1hcCI6IuKGpiIsIm1hcHN0byI6IuKGpiIsIm1hcHN0b2Rvd24iOiLihqciLCJtYXBzdG9sZWZ0Ijoi4oakIiwibWFwc3RvdXAiOiLihqUiLCJtYXJrZXIiOiLilq4iLCJtY29tbWEiOiLiqKkiLCJNY3kiOiLQnCIsIm1jeSI6ItC8IiwibWRhc2giOiLigJQiLCJtRERvdCI6IuKIuiIsIm1lYXN1cmVkYW5nbGUiOiLiiKEiLCJNZWRpdW1TcGFjZSI6IuKBnyIsIk1lbGxpbnRyZiI6IuKEsyIsIk1mciI6IvCdlJAiLCJtZnIiOiLwnZSqIiwibWhvIjoi4oSnIiwibWljcm8iOiLCtSIsIm1pZGFzdCI6IioiLCJtaWRjaXIiOiLiq7AiLCJtaWQiOiLiiKMiLCJtaWRkb3QiOiLCtyIsIm1pbnVzYiI6IuKKnyIsIm1pbnVzIjoi4oiSIiwibWludXNkIjoi4oi4IiwibWludXNkdSI6IuKoqiIsIk1pbnVzUGx1cyI6IuKIkyIsIm1sY3AiOiLiq5siLCJtbGRyIjoi4oCmIiwibW5wbHVzIjoi4oiTIiwibW9kZWxzIjoi4oqnIiwiTW9wZiI6IvCdlYQiLCJtb3BmIjoi8J2VniIsIm1wIjoi4oiTIiwibXNjciI6IvCdk4IiLCJNc2NyIjoi4oSzIiwibXN0cG9zIjoi4oi+IiwiTXUiOiLOnCIsIm11IjoizrwiLCJtdWx0aW1hcCI6IuKKuCIsIm11bWFwIjoi4oq4IiwibmFibGEiOiLiiIciLCJOYWN1dGUiOiLFgyIsIm5hY3V0ZSI6IsWEIiwibmFuZyI6IuKIoOKDkiIsIm5hcCI6IuKJiSIsIm5hcEUiOiLiqbDMuCIsIm5hcGlkIjoi4omLzLgiLCJuYXBvcyI6IsWJIiwibmFwcHJveCI6IuKJiSIsIm5hdHVyYWwiOiLima4iLCJuYXR1cmFscyI6IuKElSIsIm5hdHVyIjoi4pmuIiwibmJzcCI6IsKgIiwibmJ1bXAiOiLiiY7MuCIsIm5idW1wZSI6IuKJj8y4IiwibmNhcCI6IuKpgyIsIk5jYXJvbiI6IsWHIiwibmNhcm9uIjoixYgiLCJOY2VkaWwiOiLFhSIsIm5jZWRpbCI6IsWGIiwibmNvbmciOiLiiYciLCJuY29uZ2RvdCI6IuKprcy4IiwibmN1cCI6IuKpgiIsIk5jeSI6ItCdIiwibmN5Ijoi0L0iLCJuZGFzaCI6IuKAkyIsIm5lYXJoayI6IuKkpCIsIm5lYXJyIjoi4oaXIiwibmVBcnIiOiLih5ciLCJuZWFycm93Ijoi4oaXIiwibmUiOiLiiaAiLCJuZWRvdCI6IuKJkMy4IiwiTmVnYXRpdmVNZWRpdW1TcGFjZSI6IuKAiyIsIk5lZ2F0aXZlVGhpY2tTcGFjZSI6IuKAiyIsIk5lZ2F0aXZlVGhpblNwYWNlIjoi4oCLIiwiTmVnYXRpdmVWZXJ5VGhpblNwYWNlIjoi4oCLIiwibmVxdWl2Ijoi4omiIiwibmVzZWFyIjoi4qSoIiwibmVzaW0iOiLiiYLMuCIsIk5lc3RlZEdyZWF0ZXJHcmVhdGVyIjoi4omrIiwiTmVzdGVkTGVzc0xlc3MiOiLiiaoiLCJOZXdMaW5lIjoiXFxuIiwibmV4aXN0Ijoi4oiEIiwibmV4aXN0cyI6IuKIhCIsIk5mciI6IvCdlJEiLCJuZnIiOiLwnZSrIiwibmdFIjoi4omnzLgiLCJuZ2UiOiLiibEiLCJuZ2VxIjoi4omxIiwibmdlcXEiOiLiiafMuCIsIm5nZXFzbGFudCI6IuKpvsy4IiwibmdlcyI6IuKpvsy4IiwibkdnIjoi4ouZzLgiLCJuZ3NpbSI6IuKJtSIsIm5HdCI6IuKJq+KDkiIsIm5ndCI6IuKJryIsIm5ndHIiOiLiia8iLCJuR3R2Ijoi4omrzLgiLCJuaGFyciI6IuKGriIsIm5oQXJyIjoi4oeOIiwibmhwYXIiOiLiq7IiLCJuaSI6IuKIiyIsIm5pcyI6IuKLvCIsIm5pc2QiOiLii7oiLCJuaXYiOiLiiIsiLCJOSmN5Ijoi0IoiLCJuamN5Ijoi0ZoiLCJubGFyciI6IuKGmiIsIm5sQXJyIjoi4oeNIiwibmxkciI6IuKApSIsIm5sRSI6IuKJpsy4IiwibmxlIjoi4omwIiwibmxlZnRhcnJvdyI6IuKGmiIsIm5MZWZ0YXJyb3ciOiLih40iLCJubGVmdHJpZ2h0YXJyb3ciOiLihq4iLCJuTGVmdHJpZ2h0YXJyb3ciOiLih44iLCJubGVxIjoi4omwIiwibmxlcXEiOiLiiabMuCIsIm5sZXFzbGFudCI6IuKpvcy4IiwibmxlcyI6IuKpvcy4Iiwibmxlc3MiOiLiia4iLCJuTGwiOiLii5jMuCIsIm5sc2ltIjoi4om0Iiwibkx0Ijoi4omq4oOSIiwibmx0Ijoi4omuIiwibmx0cmkiOiLii6oiLCJubHRyaWUiOiLii6wiLCJuTHR2Ijoi4omqzLgiLCJubWlkIjoi4oikIiwiTm9CcmVhayI6IuKBoCIsIk5vbkJyZWFraW5nU3BhY2UiOiLCoCIsIm5vcGYiOiLwnZWfIiwiTm9wZiI6IuKElSIsIk5vdCI6IuKrrCIsIm5vdCI6IsKsIiwiTm90Q29uZ3J1ZW50Ijoi4omiIiwiTm90Q3VwQ2FwIjoi4omtIiwiTm90RG91YmxlVmVydGljYWxCYXIiOiLiiKYiLCJOb3RFbGVtZW50Ijoi4oiJIiwiTm90RXF1YWwiOiLiiaAiLCJOb3RFcXVhbFRpbGRlIjoi4omCzLgiLCJOb3RFeGlzdHMiOiLiiIQiLCJOb3RHcmVhdGVyIjoi4omvIiwiTm90R3JlYXRlckVxdWFsIjoi4omxIiwiTm90R3JlYXRlckZ1bGxFcXVhbCI6IuKJp8y4IiwiTm90R3JlYXRlckdyZWF0ZXIiOiLiiavMuCIsIk5vdEdyZWF0ZXJMZXNzIjoi4om5IiwiTm90R3JlYXRlclNsYW50RXF1YWwiOiLiqb7MuCIsIk5vdEdyZWF0ZXJUaWxkZSI6IuKJtSIsIk5vdEh1bXBEb3duSHVtcCI6IuKJjsy4IiwiTm90SHVtcEVxdWFsIjoi4omPzLgiLCJub3RpbiI6IuKIiSIsIm5vdGluZG90Ijoi4ou1zLgiLCJub3RpbkUiOiLii7nMuCIsIm5vdGludmEiOiLiiIkiLCJub3RpbnZiIjoi4ou3Iiwibm90aW52YyI6IuKLtiIsIk5vdExlZnRUcmlhbmdsZUJhciI6IuKnj8y4IiwiTm90TGVmdFRyaWFuZ2xlIjoi4ouqIiwiTm90TGVmdFRyaWFuZ2xlRXF1YWwiOiLii6wiLCJOb3RMZXNzIjoi4omuIiwiTm90TGVzc0VxdWFsIjoi4omwIiwiTm90TGVzc0dyZWF0ZXIiOiLiibgiLCJOb3RMZXNzTGVzcyI6IuKJqsy4IiwiTm90TGVzc1NsYW50RXF1YWwiOiLiqb3MuCIsIk5vdExlc3NUaWxkZSI6IuKJtCIsIk5vdE5lc3RlZEdyZWF0ZXJHcmVhdGVyIjoi4qqizLgiLCJOb3ROZXN0ZWRMZXNzTGVzcyI6IuKqocy4Iiwibm90bmkiOiLiiIwiLCJub3RuaXZhIjoi4oiMIiwibm90bml2YiI6IuKLviIsIm5vdG5pdmMiOiLii70iLCJOb3RQcmVjZWRlcyI6IuKKgCIsIk5vdFByZWNlZGVzRXF1YWwiOiLiqq/MuCIsIk5vdFByZWNlZGVzU2xhbnRFcXVhbCI6IuKLoCIsIk5vdFJldmVyc2VFbGVtZW50Ijoi4oiMIiwiTm90UmlnaHRUcmlhbmdsZUJhciI6IuKnkMy4IiwiTm90UmlnaHRUcmlhbmdsZSI6IuKLqyIsIk5vdFJpZ2h0VHJpYW5nbGVFcXVhbCI6IuKLrSIsIk5vdFNxdWFyZVN1YnNldCI6IuKKj8y4IiwiTm90U3F1YXJlU3Vic2V0RXF1YWwiOiLii6IiLCJOb3RTcXVhcmVTdXBlcnNldCI6IuKKkMy4IiwiTm90U3F1YXJlU3VwZXJzZXRFcXVhbCI6IuKLoyIsIk5vdFN1YnNldCI6IuKKguKDkiIsIk5vdFN1YnNldEVxdWFsIjoi4oqIIiwiTm90U3VjY2VlZHMiOiLiioEiLCJOb3RTdWNjZWVkc0VxdWFsIjoi4qqwzLgiLCJOb3RTdWNjZWVkc1NsYW50RXF1YWwiOiLii6EiLCJOb3RTdWNjZWVkc1RpbGRlIjoi4om/zLgiLCJOb3RTdXBlcnNldCI6IuKKg+KDkiIsIk5vdFN1cGVyc2V0RXF1YWwiOiLiiokiLCJOb3RUaWxkZSI6IuKJgSIsIk5vdFRpbGRlRXF1YWwiOiLiiYQiLCJOb3RUaWxkZUZ1bGxFcXVhbCI6IuKJhyIsIk5vdFRpbGRlVGlsZGUiOiLiiYkiLCJOb3RWZXJ0aWNhbEJhciI6IuKIpCIsIm5wYXJhbGxlbCI6IuKIpiIsIm5wYXIiOiLiiKYiLCJucGFyc2wiOiLiq73ig6UiLCJucGFydCI6IuKIgsy4IiwibnBvbGludCI6IuKolCIsIm5wciI6IuKKgCIsIm5wcmN1ZSI6IuKLoCIsIm5wcmVjIjoi4oqAIiwibnByZWNlcSI6IuKqr8y4IiwibnByZSI6IuKqr8y4IiwibnJhcnJjIjoi4qSzzLgiLCJucmFyciI6IuKGmyIsIm5yQXJyIjoi4oePIiwibnJhcnJ3Ijoi4oadzLgiLCJucmlnaHRhcnJvdyI6IuKGmyIsIm5SaWdodGFycm93Ijoi4oePIiwibnJ0cmkiOiLii6siLCJucnRyaWUiOiLii60iLCJuc2MiOiLiioEiLCJuc2NjdWUiOiLii6EiLCJuc2NlIjoi4qqwzLgiLCJOc2NyIjoi8J2SqSIsIm5zY3IiOiLwnZODIiwibnNob3J0bWlkIjoi4oikIiwibnNob3J0cGFyYWxsZWwiOiLiiKYiLCJuc2ltIjoi4omBIiwibnNpbWUiOiLiiYQiLCJuc2ltZXEiOiLiiYQiLCJuc21pZCI6IuKIpCIsIm5zcGFyIjoi4oimIiwibnNxc3ViZSI6IuKLoiIsIm5zcXN1cGUiOiLii6MiLCJuc3ViIjoi4oqEIiwibnN1YkUiOiLiq4XMuCIsIm5zdWJlIjoi4oqIIiwibnN1YnNldCI6IuKKguKDkiIsIm5zdWJzZXRlcSI6IuKKiCIsIm5zdWJzZXRlcXEiOiLiq4XMuCIsIm5zdWNjIjoi4oqBIiwibnN1Y2NlcSI6IuKqsMy4IiwibnN1cCI6IuKKhSIsIm5zdXBFIjoi4quGzLgiLCJuc3VwZSI6IuKKiSIsIm5zdXBzZXQiOiLiioPig5IiLCJuc3Vwc2V0ZXEiOiLiiokiLCJuc3Vwc2V0ZXFxIjoi4quGzLgiLCJudGdsIjoi4om5IiwiTnRpbGRlIjoiw5EiLCJudGlsZGUiOiLDsSIsIm50bGciOiLiibgiLCJudHJpYW5nbGVsZWZ0Ijoi4ouqIiwibnRyaWFuZ2xlbGVmdGVxIjoi4ousIiwibnRyaWFuZ2xlcmlnaHQiOiLii6siLCJudHJpYW5nbGVyaWdodGVxIjoi4outIiwiTnUiOiLOnSIsIm51Ijoizr0iLCJudW0iOiIjIiwibnVtZXJvIjoi4oSWIiwibnVtc3AiOiLigIciLCJudmFwIjoi4omN4oOSIiwibnZkYXNoIjoi4oqsIiwibnZEYXNoIjoi4oqtIiwiblZkYXNoIjoi4oquIiwiblZEYXNoIjoi4oqvIiwibnZnZSI6IuKJpeKDkiIsIm52Z3QiOiI+4oOSIiwibnZIYXJyIjoi4qSEIiwibnZpbmZpbiI6IuKnniIsIm52bEFyciI6IuKkgiIsIm52bGUiOiLiiaTig5IiLCJudmx0IjoiPOKDkiIsIm52bHRyaWUiOiLiirTig5IiLCJudnJBcnIiOiLipIMiLCJudnJ0cmllIjoi4oq14oOSIiwibnZzaW0iOiLiiLzig5IiLCJud2FyaGsiOiLipKMiLCJud2FyciI6IuKGliIsIm53QXJyIjoi4oeWIiwibndhcnJvdyI6IuKGliIsIm53bmVhciI6IuKkpyIsIk9hY3V0ZSI6IsOTIiwib2FjdXRlIjoiw7MiLCJvYXN0Ijoi4oqbIiwiT2NpcmMiOiLDlCIsIm9jaXJjIjoiw7QiLCJvY2lyIjoi4oqaIiwiT2N5Ijoi0J4iLCJvY3kiOiLQviIsIm9kYXNoIjoi4oqdIiwiT2RibGFjIjoixZAiLCJvZGJsYWMiOiLFkSIsIm9kaXYiOiLiqLgiLCJvZG90Ijoi4oqZIiwib2Rzb2xkIjoi4qa8IiwiT0VsaWciOiLFkiIsIm9lbGlnIjoixZMiLCJvZmNpciI6IuKmvyIsIk9mciI6IvCdlJIiLCJvZnIiOiLwnZSsIiwib2dvbiI6IsubIiwiT2dyYXZlIjoiw5IiLCJvZ3JhdmUiOiLDsiIsIm9ndCI6IuKngSIsIm9oYmFyIjoi4qa1Iiwib2htIjoizqkiLCJvaW50Ijoi4oiuIiwib2xhcnIiOiLihroiLCJvbGNpciI6IuKmviIsIm9sY3Jvc3MiOiLiprsiLCJvbGluZSI6IuKAviIsIm9sdCI6IuKngCIsIk9tYWNyIjoixYwiLCJvbWFjciI6IsWNIiwiT21lZ2EiOiLOqSIsIm9tZWdhIjoiz4kiLCJPbWljcm9uIjoizp8iLCJvbWljcm9uIjoizr8iLCJvbWlkIjoi4qa2Iiwib21pbnVzIjoi4oqWIiwiT29wZiI6IvCdlYYiLCJvb3BmIjoi8J2VoCIsIm9wYXIiOiLiprciLCJPcGVuQ3VybHlEb3VibGVRdW90ZSI6IuKAnCIsIk9wZW5DdXJseVF1b3RlIjoi4oCYIiwib3BlcnAiOiLiprkiLCJvcGx1cyI6IuKKlSIsIm9yYXJyIjoi4oa7IiwiT3IiOiLiqZQiLCJvciI6IuKIqCIsIm9yZCI6IuKpnSIsIm9yZGVyIjoi4oS0Iiwib3JkZXJvZiI6IuKEtCIsIm9yZGYiOiLCqiIsIm9yZG0iOiLCuiIsIm9yaWdvZiI6IuKKtiIsIm9yb3IiOiLiqZYiLCJvcnNsb3BlIjoi4qmXIiwib3J2Ijoi4qmbIiwib1MiOiLik4giLCJPc2NyIjoi8J2SqiIsIm9zY3IiOiLihLQiLCJPc2xhc2giOiLDmCIsIm9zbGFzaCI6IsO4Iiwib3NvbCI6IuKKmCIsIk90aWxkZSI6IsOVIiwib3RpbGRlIjoiw7UiLCJvdGltZXNhcyI6IuKotiIsIk90aW1lcyI6IuKotyIsIm90aW1lcyI6IuKKlyIsIk91bWwiOiLDliIsIm91bWwiOiLDtiIsIm92YmFyIjoi4oy9IiwiT3ZlckJhciI6IuKAviIsIk92ZXJCcmFjZSI6IuKPniIsIk92ZXJCcmFja2V0Ijoi4o60IiwiT3ZlclBhcmVudGhlc2lzIjoi4o+cIiwicGFyYSI6IsK2IiwicGFyYWxsZWwiOiLiiKUiLCJwYXIiOiLiiKUiLCJwYXJzaW0iOiLiq7MiLCJwYXJzbCI6IuKrvSIsInBhcnQiOiLiiIIiLCJQYXJ0aWFsRCI6IuKIgiIsIlBjeSI6ItCfIiwicGN5Ijoi0L8iLCJwZXJjbnQiOiIlIiwicGVyaW9kIjoiLiIsInBlcm1pbCI6IuKAsCIsInBlcnAiOiLiiqUiLCJwZXJ0ZW5rIjoi4oCxIiwiUGZyIjoi8J2UkyIsInBmciI6IvCdlK0iLCJQaGkiOiLOpiIsInBoaSI6Is+GIiwicGhpdiI6Is+VIiwicGhtbWF0Ijoi4oSzIiwicGhvbmUiOiLimI4iLCJQaSI6Is6gIiwicGkiOiLPgCIsInBpdGNoZm9yayI6IuKLlCIsInBpdiI6Is+WIiwicGxhbmNrIjoi4oSPIiwicGxhbmNraCI6IuKEjiIsInBsYW5rdiI6IuKEjyIsInBsdXNhY2lyIjoi4qijIiwicGx1c2IiOiLiip4iLCJwbHVzY2lyIjoi4qiiIiwicGx1cyI6IisiLCJwbHVzZG8iOiLiiJQiLCJwbHVzZHUiOiLiqKUiLCJwbHVzZSI6IuKpsiIsIlBsdXNNaW51cyI6IsKxIiwicGx1c21uIjoiwrEiLCJwbHVzc2ltIjoi4qimIiwicGx1c3R3byI6IuKopyIsInBtIjoiwrEiLCJQb2luY2FyZXBsYW5lIjoi4oSMIiwicG9pbnRpbnQiOiLiqJUiLCJwb3BmIjoi8J2VoSIsIlBvcGYiOiLihJkiLCJwb3VuZCI6IsKjIiwicHJhcCI6IuKqtyIsIlByIjoi4qq7IiwicHIiOiLiiboiLCJwcmN1ZSI6IuKJvCIsInByZWNhcHByb3giOiLiqrciLCJwcmVjIjoi4om6IiwicHJlY2N1cmx5ZXEiOiLiibwiLCJQcmVjZWRlcyI6IuKJuiIsIlByZWNlZGVzRXF1YWwiOiLiqq8iLCJQcmVjZWRlc1NsYW50RXF1YWwiOiLiibwiLCJQcmVjZWRlc1RpbGRlIjoi4om+IiwicHJlY2VxIjoi4qqvIiwicHJlY25hcHByb3giOiLiqrkiLCJwcmVjbmVxcSI6IuKqtSIsInByZWNuc2ltIjoi4ouoIiwicHJlIjoi4qqvIiwicHJFIjoi4qqzIiwicHJlY3NpbSI6IuKJviIsInByaW1lIjoi4oCyIiwiUHJpbWUiOiLigLMiLCJwcmltZXMiOiLihJkiLCJwcm5hcCI6IuKquSIsInBybkUiOiLiqrUiLCJwcm5zaW0iOiLii6giLCJwcm9kIjoi4oiPIiwiUHJvZHVjdCI6IuKIjyIsInByb2ZhbGFyIjoi4oyuIiwicHJvZmxpbmUiOiLijJIiLCJwcm9mc3VyZiI6IuKMkyIsInByb3AiOiLiiJ0iLCJQcm9wb3J0aW9uYWwiOiLiiJ0iLCJQcm9wb3J0aW9uIjoi4oi3IiwicHJvcHRvIjoi4oidIiwicHJzaW0iOiLiib4iLCJwcnVyZWwiOiLiirAiLCJQc2NyIjoi8J2SqyIsInBzY3IiOiLwnZOFIiwiUHNpIjoizqgiLCJwc2kiOiLPiCIsInB1bmNzcCI6IuKAiCIsIlFmciI6IvCdlJQiLCJxZnIiOiLwnZSuIiwicWludCI6IuKojCIsInFvcGYiOiLwnZWiIiwiUW9wZiI6IuKEmiIsInFwcmltZSI6IuKBlyIsIlFzY3IiOiLwnZKsIiwicXNjciI6IvCdk4YiLCJxdWF0ZXJuaW9ucyI6IuKEjSIsInF1YXRpbnQiOiLiqJYiLCJxdWVzdCI6Ij8iLCJxdWVzdGVxIjoi4omfIiwicXVvdCI6IlxcIiIsIlFVT1QiOiJcXCIiLCJyQWFyciI6IuKHmyIsInJhY2UiOiLiiL3MsSIsIlJhY3V0ZSI6IsWUIiwicmFjdXRlIjoixZUiLCJyYWRpYyI6IuKImiIsInJhZW1wdHl2Ijoi4qazIiwicmFuZyI6IuKfqSIsIlJhbmciOiLin6siLCJyYW5nZCI6IuKmkiIsInJhbmdlIjoi4qalIiwicmFuZ2xlIjoi4p+pIiwicmFxdW8iOiLCuyIsInJhcnJhcCI6IuKltSIsInJhcnJiIjoi4oelIiwicmFycmJmcyI6IuKkoCIsInJhcnJjIjoi4qSzIiwicmFyciI6IuKGkiIsIlJhcnIiOiLihqAiLCJyQXJyIjoi4oeSIiwicmFycmZzIjoi4qSeIiwicmFycmhrIjoi4oaqIiwicmFycmxwIjoi4oasIiwicmFycnBsIjoi4qWFIiwicmFycnNpbSI6IuKltCIsIlJhcnJ0bCI6IuKkliIsInJhcnJ0bCI6IuKGoyIsInJhcnJ3Ijoi4oadIiwicmF0YWlsIjoi4qSaIiwickF0YWlsIjoi4qScIiwicmF0aW8iOiLiiLYiLCJyYXRpb25hbHMiOiLihJoiLCJyYmFyciI6IuKkjSIsInJCYXJyIjoi4qSPIiwiUkJhcnIiOiLipJAiLCJyYmJyayI6IuKdsyIsInJicmFjZSI6In0iLCJyYnJhY2siOiJdIiwicmJya2UiOiLipowiLCJyYnJrc2xkIjoi4qaOIiwicmJya3NsdSI6IuKmkCIsIlJjYXJvbiI6IsWYIiwicmNhcm9uIjoixZkiLCJSY2VkaWwiOiLFliIsInJjZWRpbCI6IsWXIiwicmNlaWwiOiLijIkiLCJyY3ViIjoifSIsIlJjeSI6ItCgIiwicmN5Ijoi0YAiLCJyZGNhIjoi4qS3IiwicmRsZGhhciI6IuKlqSIsInJkcXVvIjoi4oCdIiwicmRxdW9yIjoi4oCdIiwicmRzaCI6IuKGsyIsInJlYWwiOiLihJwiLCJyZWFsaW5lIjoi4oSbIiwicmVhbHBhcnQiOiLihJwiLCJyZWFscyI6IuKEnSIsIlJlIjoi4oScIiwicmVjdCI6IuKWrSIsInJlZyI6IsKuIiwiUkVHIjoiwq4iLCJSZXZlcnNlRWxlbWVudCI6IuKIiyIsIlJldmVyc2VFcXVpbGlicml1bSI6IuKHiyIsIlJldmVyc2VVcEVxdWlsaWJyaXVtIjoi4qWvIiwicmZpc2h0Ijoi4qW9IiwicmZsb29yIjoi4oyLIiwicmZyIjoi8J2UryIsIlJmciI6IuKEnCIsInJIYXIiOiLipaQiLCJyaGFyZCI6IuKHgSIsInJoYXJ1Ijoi4oeAIiwicmhhcnVsIjoi4qWsIiwiUmhvIjoizqEiLCJyaG8iOiLPgSIsInJob3YiOiLPsSIsIlJpZ2h0QW5nbGVCcmFja2V0Ijoi4p+pIiwiUmlnaHRBcnJvd0JhciI6IuKHpSIsInJpZ2h0YXJyb3ciOiLihpIiLCJSaWdodEFycm93Ijoi4oaSIiwiUmlnaHRhcnJvdyI6IuKHkiIsIlJpZ2h0QXJyb3dMZWZ0QXJyb3ciOiLih4QiLCJyaWdodGFycm93dGFpbCI6IuKGoyIsIlJpZ2h0Q2VpbGluZyI6IuKMiSIsIlJpZ2h0RG91YmxlQnJhY2tldCI6IuKfpyIsIlJpZ2h0RG93blRlZVZlY3RvciI6IuKlnSIsIlJpZ2h0RG93blZlY3RvckJhciI6IuKllSIsIlJpZ2h0RG93blZlY3RvciI6IuKHgiIsIlJpZ2h0Rmxvb3IiOiLijIsiLCJyaWdodGhhcnBvb25kb3duIjoi4oeBIiwicmlnaHRoYXJwb29udXAiOiLih4AiLCJyaWdodGxlZnRhcnJvd3MiOiLih4QiLCJyaWdodGxlZnRoYXJwb29ucyI6IuKHjCIsInJpZ2h0cmlnaHRhcnJvd3MiOiLih4kiLCJyaWdodHNxdWlnYXJyb3ciOiLihp0iLCJSaWdodFRlZUFycm93Ijoi4oamIiwiUmlnaHRUZWUiOiLiiqIiLCJSaWdodFRlZVZlY3RvciI6IuKlmyIsInJpZ2h0dGhyZWV0aW1lcyI6IuKLjCIsIlJpZ2h0VHJpYW5nbGVCYXIiOiLip5AiLCJSaWdodFRyaWFuZ2xlIjoi4oqzIiwiUmlnaHRUcmlhbmdsZUVxdWFsIjoi4oq1IiwiUmlnaHRVcERvd25WZWN0b3IiOiLipY8iLCJSaWdodFVwVGVlVmVjdG9yIjoi4qWcIiwiUmlnaHRVcFZlY3RvckJhciI6IuKllCIsIlJpZ2h0VXBWZWN0b3IiOiLihr4iLCJSaWdodFZlY3RvckJhciI6IuKlkyIsIlJpZ2h0VmVjdG9yIjoi4oeAIiwicmluZyI6IsuaIiwicmlzaW5nZG90c2VxIjoi4omTIiwicmxhcnIiOiLih4QiLCJybGhhciI6IuKHjCIsInJsbSI6IuKAjyIsInJtb3VzdGFjaGUiOiLijrEiLCJybW91c3QiOiLijrEiLCJybm1pZCI6IuKrriIsInJvYW5nIjoi4p+tIiwicm9hcnIiOiLih74iLCJyb2JyayI6IuKfpyIsInJvcGFyIjoi4qaGIiwicm9wZiI6IvCdlaMiLCJSb3BmIjoi4oSdIiwicm9wbHVzIjoi4qiuIiwicm90aW1lcyI6IuKotSIsIlJvdW5kSW1wbGllcyI6IuKlsCIsInJwYXIiOiIpIiwicnBhcmd0Ijoi4qaUIiwicnBwb2xpbnQiOiLiqJIiLCJycmFyciI6IuKHiSIsIlJyaWdodGFycm93Ijoi4oebIiwicnNhcXVvIjoi4oC6IiwicnNjciI6IvCdk4ciLCJSc2NyIjoi4oSbIiwicnNoIjoi4oaxIiwiUnNoIjoi4oaxIiwicnNxYiI6Il0iLCJyc3F1byI6IuKAmSIsInJzcXVvciI6IuKAmSIsInJ0aHJlZSI6IuKLjCIsInJ0aW1lcyI6IuKLiiIsInJ0cmkiOiLilrkiLCJydHJpZSI6IuKKtSIsInJ0cmlmIjoi4pa4IiwicnRyaWx0cmkiOiLip44iLCJSdWxlRGVsYXllZCI6IuKntCIsInJ1bHVoYXIiOiLipagiLCJyeCI6IuKEniIsIlNhY3V0ZSI6IsWaIiwic2FjdXRlIjoixZsiLCJzYnF1byI6IuKAmiIsInNjYXAiOiLiqrgiLCJTY2Fyb24iOiLFoCIsInNjYXJvbiI6IsWhIiwiU2MiOiLiqrwiLCJzYyI6IuKJuyIsInNjY3VlIjoi4om9Iiwic2NlIjoi4qqwIiwic2NFIjoi4qq0IiwiU2NlZGlsIjoixZ4iLCJzY2VkaWwiOiLFnyIsIlNjaXJjIjoixZwiLCJzY2lyYyI6IsWdIiwic2NuYXAiOiLiqroiLCJzY25FIjoi4qq2Iiwic2Nuc2ltIjoi4oupIiwic2Nwb2xpbnQiOiLiqJMiLCJzY3NpbSI6IuKJvyIsIlNjeSI6ItChIiwic2N5Ijoi0YEiLCJzZG90YiI6IuKKoSIsInNkb3QiOiLii4UiLCJzZG90ZSI6IuKppiIsInNlYXJoayI6IuKkpSIsInNlYXJyIjoi4oaYIiwic2VBcnIiOiLih5giLCJzZWFycm93Ijoi4oaYIiwic2VjdCI6IsKnIiwic2VtaSI6IjsiLCJzZXN3YXIiOiLipKkiLCJzZXRtaW51cyI6IuKIliIsInNldG1uIjoi4oiWIiwic2V4dCI6IuKctiIsIlNmciI6IvCdlJYiLCJzZnIiOiLwnZSwIiwic2Zyb3duIjoi4oyiIiwic2hhcnAiOiLima8iLCJTSENIY3kiOiLQqSIsInNoY2hjeSI6ItGJIiwiU0hjeSI6ItCoIiwic2hjeSI6ItGIIiwiU2hvcnREb3duQXJyb3ciOiLihpMiLCJTaG9ydExlZnRBcnJvdyI6IuKGkCIsInNob3J0bWlkIjoi4oijIiwic2hvcnRwYXJhbGxlbCI6IuKIpSIsIlNob3J0UmlnaHRBcnJvdyI6IuKGkiIsIlNob3J0VXBBcnJvdyI6IuKGkSIsInNoeSI6IsKtIiwiU2lnbWEiOiLOoyIsInNpZ21hIjoiz4MiLCJzaWdtYWYiOiLPgiIsInNpZ21hdiI6Is+CIiwic2ltIjoi4oi8Iiwic2ltZG90Ijoi4qmqIiwic2ltZSI6IuKJgyIsInNpbWVxIjoi4omDIiwic2ltZyI6IuKqniIsInNpbWdFIjoi4qqgIiwic2ltbCI6IuKqnSIsInNpbWxFIjoi4qqfIiwic2ltbmUiOiLiiYYiLCJzaW1wbHVzIjoi4qikIiwic2ltcmFyciI6IuKlsiIsInNsYXJyIjoi4oaQIiwiU21hbGxDaXJjbGUiOiLiiJgiLCJzbWFsbHNldG1pbnVzIjoi4oiWIiwic21hc2hwIjoi4qizIiwic21lcGFyc2wiOiLip6QiLCJzbWlkIjoi4oijIiwic21pbGUiOiLijKMiLCJzbXQiOiLiqqoiLCJzbXRlIjoi4qqsIiwic210ZXMiOiLiqqzvuIAiLCJTT0ZUY3kiOiLQrCIsInNvZnRjeSI6ItGMIiwic29sYmFyIjoi4oy/Iiwic29sYiI6IuKnhCIsInNvbCI6Ii8iLCJTb3BmIjoi8J2ViiIsInNvcGYiOiLwnZWkIiwic3BhZGVzIjoi4pmgIiwic3BhZGVzdWl0Ijoi4pmgIiwic3BhciI6IuKIpSIsInNxY2FwIjoi4oqTIiwic3FjYXBzIjoi4oqT77iAIiwic3FjdXAiOiLiipQiLCJzcWN1cHMiOiLiipTvuIAiLCJTcXJ0Ijoi4oiaIiwic3FzdWIiOiLiio8iLCJzcXN1YmUiOiLiipEiLCJzcXN1YnNldCI6IuKKjyIsInNxc3Vic2V0ZXEiOiLiipEiLCJzcXN1cCI6IuKKkCIsInNxc3VwZSI6IuKKkiIsInNxc3Vwc2V0Ijoi4oqQIiwic3FzdXBzZXRlcSI6IuKKkiIsInNxdWFyZSI6IuKWoSIsIlNxdWFyZSI6IuKWoSIsIlNxdWFyZUludGVyc2VjdGlvbiI6IuKKkyIsIlNxdWFyZVN1YnNldCI6IuKKjyIsIlNxdWFyZVN1YnNldEVxdWFsIjoi4oqRIiwiU3F1YXJlU3VwZXJzZXQiOiLiipAiLCJTcXVhcmVTdXBlcnNldEVxdWFsIjoi4oqSIiwiU3F1YXJlVW5pb24iOiLiipQiLCJzcXVhcmYiOiLilqoiLCJzcXUiOiLilqEiLCJzcXVmIjoi4paqIiwic3JhcnIiOiLihpIiLCJTc2NyIjoi8J2SriIsInNzY3IiOiLwnZOIIiwic3NldG1uIjoi4oiWIiwic3NtaWxlIjoi4oyjIiwic3N0YXJmIjoi4ouGIiwiU3RhciI6IuKLhiIsInN0YXIiOiLimIYiLCJzdGFyZiI6IuKYhSIsInN0cmFpZ2h0ZXBzaWxvbiI6Is+1Iiwic3RyYWlnaHRwaGkiOiLPlSIsInN0cm5zIjoiwq8iLCJzdWIiOiLiioIiLCJTdWIiOiLii5AiLCJzdWJkb3QiOiLiqr0iLCJzdWJFIjoi4quFIiwic3ViZSI6IuKKhiIsInN1YmVkb3QiOiLiq4MiLCJzdWJtdWx0Ijoi4quBIiwic3VibkUiOiLiq4siLCJzdWJuZSI6IuKKiiIsInN1YnBsdXMiOiLiqr8iLCJzdWJyYXJyIjoi4qW5Iiwic3Vic2V0Ijoi4oqCIiwiU3Vic2V0Ijoi4ouQIiwic3Vic2V0ZXEiOiLiioYiLCJzdWJzZXRlcXEiOiLiq4UiLCJTdWJzZXRFcXVhbCI6IuKKhiIsInN1YnNldG5lcSI6IuKKiiIsInN1YnNldG5lcXEiOiLiq4siLCJzdWJzaW0iOiLiq4ciLCJzdWJzdWIiOiLiq5UiLCJzdWJzdXAiOiLiq5MiLCJzdWNjYXBwcm94Ijoi4qq4Iiwic3VjYyI6IuKJuyIsInN1Y2NjdXJseWVxIjoi4om9IiwiU3VjY2VlZHMiOiLiibsiLCJTdWNjZWVkc0VxdWFsIjoi4qqwIiwiU3VjY2VlZHNTbGFudEVxdWFsIjoi4om9IiwiU3VjY2VlZHNUaWxkZSI6IuKJvyIsInN1Y2NlcSI6IuKqsCIsInN1Y2NuYXBwcm94Ijoi4qq6Iiwic3VjY25lcXEiOiLiqrYiLCJzdWNjbnNpbSI6IuKLqSIsInN1Y2NzaW0iOiLiib8iLCJTdWNoVGhhdCI6IuKIiyIsInN1bSI6IuKIkSIsIlN1bSI6IuKIkSIsInN1bmciOiLimaoiLCJzdXAxIjoiwrkiLCJzdXAyIjoiwrIiLCJzdXAzIjoiwrMiLCJzdXAiOiLiioMiLCJTdXAiOiLii5EiLCJzdXBkb3QiOiLiqr4iLCJzdXBkc3ViIjoi4quYIiwic3VwRSI6IuKrhiIsInN1cGUiOiLiiociLCJzdXBlZG90Ijoi4quEIiwiU3VwZXJzZXQiOiLiioMiLCJTdXBlcnNldEVxdWFsIjoi4oqHIiwic3VwaHNvbCI6IuKfiSIsInN1cGhzdWIiOiLiq5ciLCJzdXBsYXJyIjoi4qW7Iiwic3VwbXVsdCI6IuKrgiIsInN1cG5FIjoi4quMIiwic3VwbmUiOiLiiosiLCJzdXBwbHVzIjoi4quAIiwic3Vwc2V0Ijoi4oqDIiwiU3Vwc2V0Ijoi4ouRIiwic3Vwc2V0ZXEiOiLiiociLCJzdXBzZXRlcXEiOiLiq4YiLCJzdXBzZXRuZXEiOiLiiosiLCJzdXBzZXRuZXFxIjoi4quMIiwic3Vwc2ltIjoi4quIIiwic3Vwc3ViIjoi4quUIiwic3Vwc3VwIjoi4quWIiwic3dhcmhrIjoi4qSmIiwic3dhcnIiOiLihpkiLCJzd0FyciI6IuKHmSIsInN3YXJyb3ciOiLihpkiLCJzd253YXIiOiLipKoiLCJzemxpZyI6IsOfIiwiVGFiIjoiXFx0IiwidGFyZ2V0Ijoi4oyWIiwiVGF1IjoizqQiLCJ0YXUiOiLPhCIsInRicmsiOiLijrQiLCJUY2Fyb24iOiLFpCIsInRjYXJvbiI6IsWlIiwiVGNlZGlsIjoixaIiLCJ0Y2VkaWwiOiLFoyIsIlRjeSI6ItCiIiwidGN5Ijoi0YIiLCJ0ZG90Ijoi4oObIiwidGVscmVjIjoi4oyVIiwiVGZyIjoi8J2UlyIsInRmciI6IvCdlLEiLCJ0aGVyZTQiOiLiiLQiLCJ0aGVyZWZvcmUiOiLiiLQiLCJUaGVyZWZvcmUiOiLiiLQiLCJUaGV0YSI6Is6YIiwidGhldGEiOiLOuCIsInRoZXRhc3ltIjoiz5EiLCJ0aGV0YXYiOiLPkSIsInRoaWNrYXBwcm94Ijoi4omIIiwidGhpY2tzaW0iOiLiiLwiLCJUaGlja1NwYWNlIjoi4oGf4oCKIiwiVGhpblNwYWNlIjoi4oCJIiwidGhpbnNwIjoi4oCJIiwidGhrYXAiOiLiiYgiLCJ0aGtzaW0iOiLiiLwiLCJUSE9STiI6IsOeIiwidGhvcm4iOiLDviIsInRpbGRlIjoiy5wiLCJUaWxkZSI6IuKIvCIsIlRpbGRlRXF1YWwiOiLiiYMiLCJUaWxkZUZ1bGxFcXVhbCI6IuKJhSIsIlRpbGRlVGlsZGUiOiLiiYgiLCJ0aW1lc2JhciI6IuKosSIsInRpbWVzYiI6IuKKoCIsInRpbWVzIjoiw5ciLCJ0aW1lc2QiOiLiqLAiLCJ0aW50Ijoi4oitIiwidG9lYSI6IuKkqCIsInRvcGJvdCI6IuKMtiIsInRvcGNpciI6IuKrsSIsInRvcCI6IuKKpCIsIlRvcGYiOiLwnZWLIiwidG9wZiI6IvCdlaUiLCJ0b3Bmb3JrIjoi4quaIiwidG9zYSI6IuKkqSIsInRwcmltZSI6IuKAtCIsInRyYWRlIjoi4oSiIiwiVFJBREUiOiLihKIiLCJ0cmlhbmdsZSI6IuKWtSIsInRyaWFuZ2xlZG93biI6IuKWvyIsInRyaWFuZ2xlbGVmdCI6IuKXgyIsInRyaWFuZ2xlbGVmdGVxIjoi4oq0IiwidHJpYW5nbGVxIjoi4omcIiwidHJpYW5nbGVyaWdodCI6IuKWuSIsInRyaWFuZ2xlcmlnaHRlcSI6IuKKtSIsInRyaWRvdCI6IuKXrCIsInRyaWUiOiLiiZwiLCJ0cmltaW51cyI6IuKouiIsIlRyaXBsZURvdCI6IuKDmyIsInRyaXBsdXMiOiLiqLkiLCJ0cmlzYiI6IuKnjSIsInRyaXRpbWUiOiLiqLsiLCJ0cnBleml1bSI6IuKPoiIsIlRzY3IiOiLwnZKvIiwidHNjciI6IvCdk4kiLCJUU2N5Ijoi0KYiLCJ0c2N5Ijoi0YYiLCJUU0hjeSI6ItCLIiwidHNoY3kiOiLRmyIsIlRzdHJvayI6IsWmIiwidHN0cm9rIjoixaciLCJ0d2l4dCI6IuKJrCIsInR3b2hlYWRsZWZ0YXJyb3ciOiLihp4iLCJ0d29oZWFkcmlnaHRhcnJvdyI6IuKGoCIsIlVhY3V0ZSI6IsOaIiwidWFjdXRlIjoiw7oiLCJ1YXJyIjoi4oaRIiwiVWFyciI6IuKGnyIsInVBcnIiOiLih5EiLCJVYXJyb2NpciI6IuKliSIsIlVicmN5Ijoi0I4iLCJ1YnJjeSI6ItGeIiwiVWJyZXZlIjoixawiLCJ1YnJldmUiOiLFrSIsIlVjaXJjIjoiw5siLCJ1Y2lyYyI6IsO7IiwiVWN5Ijoi0KMiLCJ1Y3kiOiLRgyIsInVkYXJyIjoi4oeFIiwiVWRibGFjIjoixbAiLCJ1ZGJsYWMiOiLFsSIsInVkaGFyIjoi4qWuIiwidWZpc2h0Ijoi4qW+IiwiVWZyIjoi8J2UmCIsInVmciI6IvCdlLIiLCJVZ3JhdmUiOiLDmSIsInVncmF2ZSI6IsO5IiwidUhhciI6IuKloyIsInVoYXJsIjoi4oa/IiwidWhhcnIiOiLihr4iLCJ1aGJsayI6IuKWgCIsInVsY29ybiI6IuKMnCIsInVsY29ybmVyIjoi4oycIiwidWxjcm9wIjoi4oyPIiwidWx0cmkiOiLil7giLCJVbWFjciI6IsWqIiwidW1hY3IiOiLFqyIsInVtbCI6IsKoIiwiVW5kZXJCYXIiOiJfIiwiVW5kZXJCcmFjZSI6IuKPnyIsIlVuZGVyQnJhY2tldCI6IuKOtSIsIlVuZGVyUGFyZW50aGVzaXMiOiLij50iLCJVbmlvbiI6IuKLgyIsIlVuaW9uUGx1cyI6IuKKjiIsIlVvZ29uIjoixbIiLCJ1b2dvbiI6IsWzIiwiVW9wZiI6IvCdlYwiLCJ1b3BmIjoi8J2VpiIsIlVwQXJyb3dCYXIiOiLipJIiLCJ1cGFycm93Ijoi4oaRIiwiVXBBcnJvdyI6IuKGkSIsIlVwYXJyb3ciOiLih5EiLCJVcEFycm93RG93bkFycm93Ijoi4oeFIiwidXBkb3duYXJyb3ciOiLihpUiLCJVcERvd25BcnJvdyI6IuKGlSIsIlVwZG93bmFycm93Ijoi4oeVIiwiVXBFcXVpbGlicml1bSI6IuKlriIsInVwaGFycG9vbmxlZnQiOiLihr8iLCJ1cGhhcnBvb25yaWdodCI6IuKGviIsInVwbHVzIjoi4oqOIiwiVXBwZXJMZWZ0QXJyb3ciOiLihpYiLCJVcHBlclJpZ2h0QXJyb3ciOiLihpciLCJ1cHNpIjoiz4UiLCJVcHNpIjoiz5IiLCJ1cHNpaCI6Is+SIiwiVXBzaWxvbiI6Is6lIiwidXBzaWxvbiI6Is+FIiwiVXBUZWVBcnJvdyI6IuKGpSIsIlVwVGVlIjoi4oqlIiwidXB1cGFycm93cyI6IuKHiCIsInVyY29ybiI6IuKMnSIsInVyY29ybmVyIjoi4oydIiwidXJjcm9wIjoi4oyOIiwiVXJpbmciOiLFriIsInVyaW5nIjoixa8iLCJ1cnRyaSI6IuKXuSIsIlVzY3IiOiLwnZKwIiwidXNjciI6IvCdk4oiLCJ1dGRvdCI6IuKLsCIsIlV0aWxkZSI6IsWoIiwidXRpbGRlIjoixakiLCJ1dHJpIjoi4pa1IiwidXRyaWYiOiLilrQiLCJ1dWFyciI6IuKHiCIsIlV1bWwiOiLDnCIsInV1bWwiOiLDvCIsInV3YW5nbGUiOiLipqciLCJ2YW5ncnQiOiLippwiLCJ2YXJlcHNpbG9uIjoiz7UiLCJ2YXJrYXBwYSI6Is+wIiwidmFybm90aGluZyI6IuKIhSIsInZhcnBoaSI6Is+VIiwidmFycGkiOiLPliIsInZhcnByb3B0byI6IuKInSIsInZhcnIiOiLihpUiLCJ2QXJyIjoi4oeVIiwidmFycmhvIjoiz7EiLCJ2YXJzaWdtYSI6Is+CIiwidmFyc3Vic2V0bmVxIjoi4oqK77iAIiwidmFyc3Vic2V0bmVxcSI6IuKri++4gCIsInZhcnN1cHNldG5lcSI6IuKKi++4gCIsInZhcnN1cHNldG5lcXEiOiLiq4zvuIAiLCJ2YXJ0aGV0YSI6Is+RIiwidmFydHJpYW5nbGVsZWZ0Ijoi4oqyIiwidmFydHJpYW5nbGVyaWdodCI6IuKKsyIsInZCYXIiOiLiq6giLCJWYmFyIjoi4qurIiwidkJhcnYiOiLiq6kiLCJWY3kiOiLQkiIsInZjeSI6ItCyIiwidmRhc2giOiLiiqIiLCJ2RGFzaCI6IuKKqCIsIlZkYXNoIjoi4oqpIiwiVkRhc2giOiLiiqsiLCJWZGFzaGwiOiLiq6YiLCJ2ZWViYXIiOiLiirsiLCJ2ZWUiOiLiiKgiLCJWZWUiOiLii4EiLCJ2ZWVlcSI6IuKJmiIsInZlbGxpcCI6IuKLriIsInZlcmJhciI6InwiLCJWZXJiYXIiOiLigJYiLCJ2ZXJ0IjoifCIsIlZlcnQiOiLigJYiLCJWZXJ0aWNhbEJhciI6IuKIoyIsIlZlcnRpY2FsTGluZSI6InwiLCJWZXJ0aWNhbFNlcGFyYXRvciI6IuKdmCIsIlZlcnRpY2FsVGlsZGUiOiLiiYAiLCJWZXJ5VGhpblNwYWNlIjoi4oCKIiwiVmZyIjoi8J2UmSIsInZmciI6IvCdlLMiLCJ2bHRyaSI6IuKKsiIsInZuc3ViIjoi4oqC4oOSIiwidm5zdXAiOiLiioPig5IiLCJWb3BmIjoi8J2VjSIsInZvcGYiOiLwnZWnIiwidnByb3AiOiLiiJ0iLCJ2cnRyaSI6IuKKsyIsIlZzY3IiOiLwnZKxIiwidnNjciI6IvCdk4siLCJ2c3VibkUiOiLiq4vvuIAiLCJ2c3VibmUiOiLiiorvuIAiLCJ2c3VwbkUiOiLiq4zvuIAiLCJ2c3VwbmUiOiLiiovvuIAiLCJWdmRhc2giOiLiiqoiLCJ2emlnemFnIjoi4qaaIiwiV2NpcmMiOiLFtCIsIndjaXJjIjoixbUiLCJ3ZWRiYXIiOiLiqZ8iLCJ3ZWRnZSI6IuKIpyIsIldlZGdlIjoi4ouAIiwid2VkZ2VxIjoi4omZIiwid2VpZXJwIjoi4oSYIiwiV2ZyIjoi8J2UmiIsIndmciI6IvCdlLQiLCJXb3BmIjoi8J2VjiIsIndvcGYiOiLwnZWoIiwid3AiOiLihJgiLCJ3ciI6IuKJgCIsIndyZWF0aCI6IuKJgCIsIldzY3IiOiLwnZKyIiwid3NjciI6IvCdk4wiLCJ4Y2FwIjoi4ouCIiwieGNpcmMiOiLil68iLCJ4Y3VwIjoi4ouDIiwieGR0cmkiOiLilr0iLCJYZnIiOiLwnZSbIiwieGZyIjoi8J2UtSIsInhoYXJyIjoi4p+3IiwieGhBcnIiOiLin7oiLCJYaSI6Is6eIiwieGkiOiLOviIsInhsYXJyIjoi4p+1IiwieGxBcnIiOiLin7giLCJ4bWFwIjoi4p+8IiwieG5pcyI6IuKLuyIsInhvZG90Ijoi4qiAIiwiWG9wZiI6IvCdlY8iLCJ4b3BmIjoi8J2VqSIsInhvcGx1cyI6IuKogSIsInhvdGltZSI6IuKogiIsInhyYXJyIjoi4p+2IiwieHJBcnIiOiLin7kiLCJYc2NyIjoi8J2SsyIsInhzY3IiOiLwnZONIiwieHNxY3VwIjoi4qiGIiwieHVwbHVzIjoi4qiEIiwieHV0cmkiOiLilrMiLCJ4dmVlIjoi4ouBIiwieHdlZGdlIjoi4ouAIiwiWWFjdXRlIjoiw50iLCJ5YWN1dGUiOiLDvSIsIllBY3kiOiLQryIsInlhY3kiOiLRjyIsIlljaXJjIjoixbYiLCJ5Y2lyYyI6IsW3IiwiWWN5Ijoi0KsiLCJ5Y3kiOiLRiyIsInllbiI6IsKlIiwiWWZyIjoi8J2UnCIsInlmciI6IvCdlLYiLCJZSWN5Ijoi0IciLCJ5aWN5Ijoi0ZciLCJZb3BmIjoi8J2VkCIsInlvcGYiOiLwnZWqIiwiWXNjciI6IvCdkrQiLCJ5c2NyIjoi8J2TjiIsIllVY3kiOiLQriIsInl1Y3kiOiLRjiIsInl1bWwiOiLDvyIsIll1bWwiOiLFuCIsIlphY3V0ZSI6IsW5IiwiemFjdXRlIjoixboiLCJaY2Fyb24iOiLFvSIsInpjYXJvbiI6IsW+IiwiWmN5Ijoi0JciLCJ6Y3kiOiLQtyIsIlpkb3QiOiLFuyIsInpkb3QiOiLFvCIsInplZXRyZiI6IuKEqCIsIlplcm9XaWR0aFNwYWNlIjoi4oCLIiwiWmV0YSI6Is6WIiwiemV0YSI6Is62IiwiemZyIjoi8J2UtyIsIlpmciI6IuKEqCIsIlpIY3kiOiLQliIsInpoY3kiOiLQtiIsInppZ3JhcnIiOiLih50iLCJ6b3BmIjoi8J2VqyIsIlpvcGYiOiLihKQiLCJac2NyIjoi8J2StSIsInpzY3IiOiLwnZOPIiwiendqIjoi4oCNIiwienduaiI6IuKAjCJ9Jyl9LGZ1bmN0aW9uKFMpe1MuZXhwb3J0cz1KU09OLnBhcnNlKCd7IkFhY3V0ZSI6IsOBIiwiYWFjdXRlIjoiw6EiLCJBY2lyYyI6IsOCIiwiYWNpcmMiOiLDoiIsImFjdXRlIjoiwrQiLCJBRWxpZyI6IsOGIiwiYWVsaWciOiLDpiIsIkFncmF2ZSI6IsOAIiwiYWdyYXZlIjoiw6AiLCJhbXAiOiImIiwiQU1QIjoiJiIsIkFyaW5nIjoiw4UiLCJhcmluZyI6IsOlIiwiQXRpbGRlIjoiw4MiLCJhdGlsZGUiOiLDoyIsIkF1bWwiOiLDhCIsImF1bWwiOiLDpCIsImJydmJhciI6IsKmIiwiQ2NlZGlsIjoiw4ciLCJjY2VkaWwiOiLDpyIsImNlZGlsIjoiwrgiLCJjZW50IjoiwqIiLCJjb3B5IjoiwqkiLCJDT1BZIjoiwqkiLCJjdXJyZW4iOiLCpCIsImRlZyI6IsKwIiwiZGl2aWRlIjoiw7ciLCJFYWN1dGUiOiLDiSIsImVhY3V0ZSI6IsOpIiwiRWNpcmMiOiLDiiIsImVjaXJjIjoiw6oiLCJFZ3JhdmUiOiLDiCIsImVncmF2ZSI6IsOoIiwiRVRIIjoiw5AiLCJldGgiOiLDsCIsIkV1bWwiOiLDiyIsImV1bWwiOiLDqyIsImZyYWMxMiI6IsK9IiwiZnJhYzE0IjoiwrwiLCJmcmFjMzQiOiLCviIsImd0IjoiPiIsIkdUIjoiPiIsIklhY3V0ZSI6IsONIiwiaWFjdXRlIjoiw60iLCJJY2lyYyI6IsOOIiwiaWNpcmMiOiLDriIsImlleGNsIjoiwqEiLCJJZ3JhdmUiOiLDjCIsImlncmF2ZSI6IsOsIiwiaXF1ZXN0Ijoiwr8iLCJJdW1sIjoiw48iLCJpdW1sIjoiw68iLCJsYXF1byI6IsKrIiwibHQiOiI8IiwiTFQiOiI8IiwibWFjciI6IsKvIiwibWljcm8iOiLCtSIsIm1pZGRvdCI6IsK3IiwibmJzcCI6IsKgIiwibm90IjoiwqwiLCJOdGlsZGUiOiLDkSIsIm50aWxkZSI6IsOxIiwiT2FjdXRlIjoiw5MiLCJvYWN1dGUiOiLDsyIsIk9jaXJjIjoiw5QiLCJvY2lyYyI6IsO0IiwiT2dyYXZlIjoiw5IiLCJvZ3JhdmUiOiLDsiIsIm9yZGYiOiLCqiIsIm9yZG0iOiLCuiIsIk9zbGFzaCI6IsOYIiwib3NsYXNoIjoiw7giLCJPdGlsZGUiOiLDlSIsIm90aWxkZSI6IsO1IiwiT3VtbCI6IsOWIiwib3VtbCI6IsO2IiwicGFyYSI6IsK2IiwicGx1c21uIjoiwrEiLCJwb3VuZCI6IsKjIiwicXVvdCI6IlxcIiIsIlFVT1QiOiJcXCIiLCJyYXF1byI6IsK7IiwicmVnIjoiwq4iLCJSRUciOiLCriIsInNlY3QiOiLCpyIsInNoeSI6IsKtIiwic3VwMSI6IsK5Iiwic3VwMiI6IsKyIiwic3VwMyI6IsKzIiwic3psaWciOiLDnyIsIlRIT1JOIjoiw54iLCJ0aG9ybiI6IsO+IiwidGltZXMiOiLDlyIsIlVhY3V0ZSI6IsOaIiwidWFjdXRlIjoiw7oiLCJVY2lyYyI6IsObIiwidWNpcmMiOiLDuyIsIlVncmF2ZSI6IsOZIiwidWdyYXZlIjoiw7kiLCJ1bWwiOiLCqCIsIlV1bWwiOiLDnCIsInV1bWwiOiLDvCIsIllhY3V0ZSI6IsOdIiwieWFjdXRlIjoiw70iLCJ5ZW4iOiLCpSIsInl1bWwiOiLDvyJ9Jyl9LGZ1bmN0aW9uKFMpe1MuZXhwb3J0cz1KU09OLnBhcnNlKGB7ImFtcCI6IiYiLCJhcG9zIjoiJyIsImd0IjoiPiIsImx0IjoiPCIsInF1b3QiOiJcXCIifWApfSxmdW5jdGlvbihTLGUsdCl7dmFyIHI9dGhpcyYmdGhpcy5fX2ltcG9ydERlZmF1bHR8fGZ1bmN0aW9uKGcpe3JldHVybiBnJiZnLl9fZXNNb2R1bGU/Zzp7ZGVmYXVsdDpnfX07T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pO3ZhciBpPXIodCgyNjUpKTtmdW5jdGlvbiBoKGcpe2lmKGc+PTU1Mjk2JiZnPD01NzM0M3x8Zz4xMTE0MTExKXJldHVybiLvv70iO2cgaW4gaS5kZWZhdWx0JiYoZz1pLmRlZmF1bHRbZ10pO3ZhciB1PSIiO3JldHVybiBnPjY1NTM1JiYoZy09NjU1MzYsdSs9U3RyaW5nLmZyb21DaGFyQ29kZShnPj4+MTAmMTAyM3w1NTI5NiksZz01NjMyMHxnJjEwMjMpLHUrPVN0cmluZy5mcm9tQ2hhckNvZGUoZyksdX1lLmRlZmF1bHQ9aH0sZnVuY3Rpb24oUyl7Uy5leHBvcnRzPUpTT04ucGFyc2UoJ3siMCI6NjU1MzMsIjEyOCI6ODM2NCwiMTMwIjo4MjE4LCIxMzEiOjQwMiwiMTMyIjo4MjIyLCIxMzMiOjgyMzAsIjEzNCI6ODIyNCwiMTM1Ijo4MjI1LCIxMzYiOjcxMCwiMTM3Ijo4MjQwLCIxMzgiOjM1MiwiMTM5Ijo4MjQ5LCIxNDAiOjMzOCwiMTQyIjozODEsIjE0NSI6ODIxNiwiMTQ2Ijo4MjE3LCIxNDciOjgyMjAsIjE0OCI6ODIyMSwiMTQ5Ijo4MjI2LCIxNTAiOjgyMTEsIjE1MSI6ODIxMiwiMTUyIjo3MzIsIjE1MyI6ODQ4MiwiMTU0IjozNTMsIjE1NSI6ODI1MCwiMTU2IjozMzksIjE1OCI6MzgyLCIxNTkiOjM3Nn0nKX0sZnVuY3Rpb24oUyxlLHQpe3ZhciByPXRoaXMmJnRoaXMuX19pbXBvcnREZWZhdWx0fHxmdW5jdGlvbih5KXtyZXR1cm4geSYmeS5fX2VzTW9kdWxlP3k6e2RlZmF1bHQ6eX19O09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxlLmVzY2FwZT1lLmVuY29kZUhUTUw9ZS5lbmNvZGVYTUw9dm9pZCAwO3ZhciBpPXIodCgyNjMpKSxoPXgoaS5kZWZhdWx0KSxnPWYoaCk7ZS5lbmNvZGVYTUw9QyhoLGcpO3ZhciB1PXIodCgyNjEpKSxhPXgodS5kZWZhdWx0KSxjPWYoYSk7ZS5lbmNvZGVIVE1MPUMoYSxjKTtmdW5jdGlvbiB4KHkpe3JldHVybiBPYmplY3Qua2V5cyh5KS5zb3J0KCkucmVkdWNlKGZ1bmN0aW9uKG4sbyl7cmV0dXJuIG5beVtvXV09IiYiK28rIjsiLG59LHt9KX1mdW5jdGlvbiBmKHkpe2Zvcih2YXIgbj1bXSxvPVtdLHM9MCxsPU9iamVjdC5rZXlzKHkpO3M8bC5sZW5ndGg7cysrKXt2YXIgRT1sW3NdO0UubGVuZ3RoPT09MT9uLnB1c2goIlxcIitFKTpvLnB1c2goRSl9bi5zb3J0KCk7Zm9yKHZhciBUPTA7VDxuLmxlbmd0aC0xO1QrKyl7Zm9yKHZhciBiPVQ7YjxuLmxlbmd0aC0xJiZuW2JdLmNoYXJDb2RlQXQoMSkrMT09PW5bYisxXS5jaGFyQ29kZUF0KDEpOyliKz0xO3ZhciBJPTErYi1UO0k8M3x8bi5zcGxpY2UoVCxJLG5bVF0rIi0iK25bYl0pfXJldHVybiBvLnVuc2hpZnQoIlsiK24uam9pbigiIikrIl0iKSxuZXcgUmVnRXhwKG8uam9pbigifCIpLCJnIil9dmFyIHY9Lyg/OltceDgwLVx1RDdGRlx1RTAwMC1cdUZGRkZdfFtcdUQ4MDAtXHVEQkZGXVtcdURDMDAtXHVERkZGXXxbXHVEODAwLVx1REJGRl0oPyFbXHVEQzAwLVx1REZGRl0pfCg/OlteXHVEODAwLVx1REJGRl18XilbXHVEQzAwLVx1REZGRl0pL2c7ZnVuY3Rpb24gcCh5KXtyZXR1cm4iJiN4Iit5LmNvZGVQb2ludEF0KDApLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpKyI7In1mdW5jdGlvbiBDKHksbil7cmV0dXJuIGZ1bmN0aW9uKG8pe3JldHVybiBvLnJlcGxhY2UobixmdW5jdGlvbihzKXtyZXR1cm4geVtzXX0pLnJlcGxhY2UodixwKX19dmFyIE09ZihoKTtmdW5jdGlvbiBtKHkpe3JldHVybiB5LnJlcGxhY2UoTSxwKS5yZXBsYWNlKHYscCl9ZS5lc2NhcGU9bX0sZnVuY3Rpb24oUyl7Uy5leHBvcnRzPUpTT04ucGFyc2UoJ3siZWxlbWVudE5hbWVzIjp7ImFsdGdseXBoIjoiYWx0R2x5cGgiLCJhbHRnbHlwaGRlZiI6ImFsdEdseXBoRGVmIiwiYWx0Z2x5cGhpdGVtIjoiYWx0R2x5cGhJdGVtIiwiYW5pbWF0ZWNvbG9yIjoiYW5pbWF0ZUNvbG9yIiwiYW5pbWF0ZW1vdGlvbiI6ImFuaW1hdGVNb3Rpb24iLCJhbmltYXRldHJhbnNmb3JtIjoiYW5pbWF0ZVRyYW5zZm9ybSIsImNsaXBwYXRoIjoiY2xpcFBhdGgiLCJmZWJsZW5kIjoiZmVCbGVuZCIsImZlY29sb3JtYXRyaXgiOiJmZUNvbG9yTWF0cml4IiwiZmVjb21wb25lbnR0cmFuc2ZlciI6ImZlQ29tcG9uZW50VHJhbnNmZXIiLCJmZWNvbXBvc2l0ZSI6ImZlQ29tcG9zaXRlIiwiZmVjb252b2x2ZW1hdHJpeCI6ImZlQ29udm9sdmVNYXRyaXgiLCJmZWRpZmZ1c2VsaWdodGluZyI6ImZlRGlmZnVzZUxpZ2h0aW5nIiwiZmVkaXNwbGFjZW1lbnRtYXAiOiJmZURpc3BsYWNlbWVudE1hcCIsImZlZGlzdGFudGxpZ2h0IjoiZmVEaXN0YW50TGlnaHQiLCJmZWRyb3BzaGFkb3ciOiJmZURyb3BTaGFkb3ciLCJmZWZsb29kIjoiZmVGbG9vZCIsImZlZnVuY2EiOiJmZUZ1bmNBIiwiZmVmdW5jYiI6ImZlRnVuY0IiLCJmZWZ1bmNnIjoiZmVGdW5jRyIsImZlZnVuY3IiOiJmZUZ1bmNSIiwiZmVnYXVzc2lhbmJsdXIiOiJmZUdhdXNzaWFuQmx1ciIsImZlaW1hZ2UiOiJmZUltYWdlIiwiZmVtZXJnZSI6ImZlTWVyZ2UiLCJmZW1lcmdlbm9kZSI6ImZlTWVyZ2VOb2RlIiwiZmVtb3JwaG9sb2d5IjoiZmVNb3JwaG9sb2d5IiwiZmVvZmZzZXQiOiJmZU9mZnNldCIsImZlcG9pbnRsaWdodCI6ImZlUG9pbnRMaWdodCIsImZlc3BlY3VsYXJsaWdodGluZyI6ImZlU3BlY3VsYXJMaWdodGluZyIsImZlc3BvdGxpZ2h0IjoiZmVTcG90TGlnaHQiLCJmZXRpbGUiOiJmZVRpbGUiLCJmZXR1cmJ1bGVuY2UiOiJmZVR1cmJ1bGVuY2UiLCJmb3JlaWdub2JqZWN0IjoiZm9yZWlnbk9iamVjdCIsImdseXBocmVmIjoiZ2x5cGhSZWYiLCJsaW5lYXJncmFkaWVudCI6ImxpbmVhckdyYWRpZW50IiwicmFkaWFsZ3JhZGllbnQiOiJyYWRpYWxHcmFkaWVudCIsInRleHRwYXRoIjoidGV4dFBhdGgifSwiYXR0cmlidXRlTmFtZXMiOnsiZGVmaW5pdGlvbnVybCI6ImRlZmluaXRpb25VUkwiLCJhdHRyaWJ1dGVuYW1lIjoiYXR0cmlidXRlTmFtZSIsImF0dHJpYnV0ZXR5cGUiOiJhdHRyaWJ1dGVUeXBlIiwiYmFzZWZyZXF1ZW5jeSI6ImJhc2VGcmVxdWVuY3kiLCJiYXNlcHJvZmlsZSI6ImJhc2VQcm9maWxlIiwiY2FsY21vZGUiOiJjYWxjTW9kZSIsImNsaXBwYXRodW5pdHMiOiJjbGlwUGF0aFVuaXRzIiwiZGlmZnVzZWNvbnN0YW50IjoiZGlmZnVzZUNvbnN0YW50IiwiZWRnZW1vZGUiOiJlZGdlTW9kZSIsImZpbHRlcnVuaXRzIjoiZmlsdGVyVW5pdHMiLCJnbHlwaHJlZiI6ImdseXBoUmVmIiwiZ3JhZGllbnR0cmFuc2Zvcm0iOiJncmFkaWVudFRyYW5zZm9ybSIsImdyYWRpZW50dW5pdHMiOiJncmFkaWVudFVuaXRzIiwia2VybmVsbWF0cml4Ijoia2VybmVsTWF0cml4Iiwia2VybmVsdW5pdGxlbmd0aCI6Imtlcm5lbFVuaXRMZW5ndGgiLCJrZXlwb2ludHMiOiJrZXlQb2ludHMiLCJrZXlzcGxpbmVzIjoia2V5U3BsaW5lcyIsImtleXRpbWVzIjoia2V5VGltZXMiLCJsZW5ndGhhZGp1c3QiOiJsZW5ndGhBZGp1c3QiLCJsaW1pdGluZ2NvbmVhbmdsZSI6ImxpbWl0aW5nQ29uZUFuZ2xlIiwibWFya2VyaGVpZ2h0IjoibWFya2VySGVpZ2h0IiwibWFya2VydW5pdHMiOiJtYXJrZXJVbml0cyIsIm1hcmtlcndpZHRoIjoibWFya2VyV2lkdGgiLCJtYXNrY29udGVudHVuaXRzIjoibWFza0NvbnRlbnRVbml0cyIsIm1hc2t1bml0cyI6Im1hc2tVbml0cyIsIm51bW9jdGF2ZXMiOiJudW1PY3RhdmVzIiwicGF0aGxlbmd0aCI6InBhdGhMZW5ndGgiLCJwYXR0ZXJuY29udGVudHVuaXRzIjoicGF0dGVybkNvbnRlbnRVbml0cyIsInBhdHRlcm50cmFuc2Zvcm0iOiJwYXR0ZXJuVHJhbnNmb3JtIiwicGF0dGVybnVuaXRzIjoicGF0dGVyblVuaXRzIiwicG9pbnRzYXR4IjoicG9pbnRzQXRYIiwicG9pbnRzYXR5IjoicG9pbnRzQXRZIiwicG9pbnRzYXR6IjoicG9pbnRzQXRaIiwicHJlc2VydmVhbHBoYSI6InByZXNlcnZlQWxwaGEiLCJwcmVzZXJ2ZWFzcGVjdHJhdGlvIjoicHJlc2VydmVBc3BlY3RSYXRpbyIsInByaW1pdGl2ZXVuaXRzIjoicHJpbWl0aXZlVW5pdHMiLCJyZWZ4IjoicmVmWCIsInJlZnkiOiJyZWZZIiwicmVwZWF0Y291bnQiOiJyZXBlYXRDb3VudCIsInJlcGVhdGR1ciI6InJlcGVhdER1ciIsInJlcXVpcmVkZXh0ZW5zaW9ucyI6InJlcXVpcmVkRXh0ZW5zaW9ucyIsInJlcXVpcmVkZmVhdHVyZXMiOiJyZXF1aXJlZEZlYXR1cmVzIiwic3BlY3VsYXJjb25zdGFudCI6InNwZWN1bGFyQ29uc3RhbnQiLCJzcGVjdWxhcmV4cG9uZW50Ijoic3BlY3VsYXJFeHBvbmVudCIsInNwcmVhZG1ldGhvZCI6InNwcmVhZE1ldGhvZCIsInN0YXJ0b2Zmc2V0Ijoic3RhcnRPZmZzZXQiLCJzdGRkZXZpYXRpb24iOiJzdGREZXZpYXRpb24iLCJzdGl0Y2h0aWxlcyI6InN0aXRjaFRpbGVzIiwic3VyZmFjZXNjYWxlIjoic3VyZmFjZVNjYWxlIiwic3lzdGVtbGFuZ3VhZ2UiOiJzeXN0ZW1MYW5ndWFnZSIsInRhYmxldmFsdWVzIjoidGFibGVWYWx1ZXMiLCJ0YXJnZXR4IjoidGFyZ2V0WCIsInRhcmdldHkiOiJ0YXJnZXRZIiwidGV4dGxlbmd0aCI6InRleHRMZW5ndGgiLCJ2aWV3Ym94Ijoidmlld0JveCIsInZpZXd0YXJnZXQiOiJ2aWV3VGFyZ2V0IiwieGNoYW5uZWxzZWxlY3RvciI6InhDaGFubmVsU2VsZWN0b3IiLCJ5Y2hhbm5lbHNlbGVjdG9yIjoieUNoYW5uZWxTZWxlY3RvciIsInpvb21hbmRwYW4iOiJ6b29tQW5kUGFuIn19Jyl9LGZ1bmN0aW9uKFMsZSl7dmFyIHQ9ZS5nZXRDaGlsZHJlbj1mdW5jdGlvbihpKXtyZXR1cm4gaS5jaGlsZHJlbn0scj1lLmdldFBhcmVudD1mdW5jdGlvbihpKXtyZXR1cm4gaS5wYXJlbnR9O2UuZ2V0U2libGluZ3M9ZnVuY3Rpb24oaSl7dmFyIGg9cihpKTtyZXR1cm4gaD90KGgpOltpXX0sZS5nZXRBdHRyaWJ1dGVWYWx1ZT1mdW5jdGlvbihpLGgpe3JldHVybiBpLmF0dHJpYnMmJmkuYXR0cmlic1toXX0sZS5oYXNBdHRyaWI9ZnVuY3Rpb24oaSxoKXtyZXR1cm4hIWkuYXR0cmlicyYmaGFzT3duUHJvcGVydHkuY2FsbChpLmF0dHJpYnMsaCl9LGUuZ2V0TmFtZT1mdW5jdGlvbihpKXtyZXR1cm4gaS5uYW1lfX0sZnVuY3Rpb24oUyxlKXtlLnJlbW92ZUVsZW1lbnQ9ZnVuY3Rpb24odCl7aWYodC5wcmV2JiYodC5wcmV2Lm5leHQ9dC5uZXh0KSx0Lm5leHQmJih0Lm5leHQucHJldj10LnByZXYpLHQucGFyZW50KXt2YXIgcj10LnBhcmVudC5jaGlsZHJlbjtyLnNwbGljZShyLmxhc3RJbmRleE9mKHQpLDEpfX0sZS5yZXBsYWNlRWxlbWVudD1mdW5jdGlvbih0LHIpe3ZhciBpPXIucHJldj10LnByZXY7aSYmKGkubmV4dD1yKTt2YXIgaD1yLm5leHQ9dC5uZXh0O2gmJihoLnByZXY9cik7dmFyIGc9ci5wYXJlbnQ9dC5wYXJlbnQ7aWYoZyl7dmFyIHU9Zy5jaGlsZHJlbjt1W3UubGFzdEluZGV4T2YodCldPXJ9fSxlLmFwcGVuZENoaWxkPWZ1bmN0aW9uKHQscil7aWYoci5wYXJlbnQ9dCx0LmNoaWxkcmVuLnB1c2gocikhPT0xKXt2YXIgaT10LmNoaWxkcmVuW3QuY2hpbGRyZW4ubGVuZ3RoLTJdO2kubmV4dD1yLHIucHJldj1pLHIubmV4dD1udWxsfX0sZS5hcHBlbmQ9ZnVuY3Rpb24odCxyKXt2YXIgaT10LnBhcmVudCxoPXQubmV4dDtpZihyLm5leHQ9aCxyLnByZXY9dCx0Lm5leHQ9cixyLnBhcmVudD1pLGgpe2lmKGgucHJldj1yLGkpe3ZhciBnPWkuY2hpbGRyZW47Zy5zcGxpY2UoZy5sYXN0SW5kZXhPZihoKSwwLHIpfX1lbHNlIGkmJmkuY2hpbGRyZW4ucHVzaChyKX0sZS5wcmVwZW5kPWZ1bmN0aW9uKHQscil7dmFyIGk9dC5wYXJlbnQ7aWYoaSl7dmFyIGg9aS5jaGlsZHJlbjtoLnNwbGljZShoLmxhc3RJbmRleE9mKHQpLDAscil9dC5wcmV2JiYodC5wcmV2Lm5leHQ9ciksci5wYXJlbnQ9aSxyLnByZXY9dC5wcmV2LHIubmV4dD10LHQucHJldj1yfX0sZnVuY3Rpb24oUyxlLHQpe3ZhciByPXQoMjU2KS5pc1RhZztTLmV4cG9ydHM9e2ZpbHRlcjppLGZpbmQ6aCxmaW5kT25lQ2hpbGQ6ZyxmaW5kT25lOnUsZXhpc3RzT25lOmEsZmluZEFsbDpjfTtmdW5jdGlvbiBpKHgsZix2LHApe3JldHVybiBBcnJheS5pc0FycmF5KGYpfHwoZj1bZl0pLCh0eXBlb2YgcCE9Im51bWJlciJ8fCFpc0Zpbml0ZShwKSkmJihwPTEvMCksaCh4LGYsdiE9PSExLHApfWZ1bmN0aW9uIGgoeCxmLHYscCl7Zm9yKHZhciBDPVtdLE0sbT0wLHk9Zi5sZW5ndGg7bTx5JiYhKHgoZlttXSkmJihDLnB1c2goZlttXSksLS1wPD0wKXx8KE09ZlttXS5jaGlsZHJlbix2JiZNJiZNLmxlbmd0aD4wJiYoTT1oKHgsTSx2LHApLEM9Qy5jb25jYXQoTSkscC09TS5sZW5ndGgscDw9MCkpKTttKyspO3JldHVybiBDfWZ1bmN0aW9uIGcoeCxmKXtmb3IodmFyIHY9MCxwPWYubGVuZ3RoO3Y8cDt2KyspaWYoeChmW3ZdKSlyZXR1cm4gZlt2XTtyZXR1cm4gbnVsbH1mdW5jdGlvbiB1KHgsZil7Zm9yKHZhciB2PW51bGwscD0wLEM9Zi5sZW5ndGg7cDxDJiYhdjtwKyspaWYocihmW3BdKSl4KGZbcF0pP3Y9ZltwXTpmW3BdLmNoaWxkcmVuLmxlbmd0aD4wJiYodj11KHgsZltwXS5jaGlsZHJlbikpO2Vsc2UgY29udGludWU7cmV0dXJuIHZ9ZnVuY3Rpb24gYSh4LGYpe2Zvcih2YXIgdj0wLHA9Zi5sZW5ndGg7djxwO3YrKylpZihyKGZbdl0pJiYoeChmW3ZdKXx8Zlt2XS5jaGlsZHJlbi5sZW5ndGg+MCYmYSh4LGZbdl0uY2hpbGRyZW4pKSlyZXR1cm4hMDtyZXR1cm4hMX1mdW5jdGlvbiBjKHgsZil7Zm9yKHZhciB2PVtdLHA9Zi5zbGljZSgpO3AubGVuZ3RoOyl7dmFyIEM9cC5zaGlmdCgpO3IoQykmJihDLmNoaWxkcmVuJiZDLmNoaWxkcmVuLmxlbmd0aD4wJiZwLnVuc2hpZnQuYXBwbHkocCxDLmNoaWxkcmVuKSx4KEMpJiZ2LnB1c2goQykpfXJldHVybiB2fX0sZnVuY3Rpb24oUyxlLHQpe3ZhciByPXQoMjU2KSxpPWUuaXNUYWc9ci5pc1RhZztlLnRlc3RFbGVtZW50PWZ1bmN0aW9uKGEsYyl7Zm9yKHZhciB4IGluIGEpaWYoYS5oYXNPd25Qcm9wZXJ0eSh4KSl7aWYoeD09PSJ0YWdfbmFtZSIpe2lmKCFpKGMpfHwhYS50YWdfbmFtZShjLm5hbWUpKXJldHVybiExfWVsc2UgaWYoeD09PSJ0YWdfdHlwZSIpe2lmKCFhLnRhZ190eXBlKGMudHlwZSkpcmV0dXJuITF9ZWxzZSBpZih4PT09InRhZ19jb250YWlucyIpe2lmKGkoYyl8fCFhLnRhZ19jb250YWlucyhjLmRhdGEpKXJldHVybiExfWVsc2UgaWYoIWMuYXR0cmlic3x8IWFbeF0oYy5hdHRyaWJzW3hdKSlyZXR1cm4hMX1yZXR1cm4hMH07dmFyIGg9e3RhZ19uYW1lOmZ1bmN0aW9uKGEpe3JldHVybiB0eXBlb2YgYT09ImZ1bmN0aW9uIj9mdW5jdGlvbihjKXtyZXR1cm4gaShjKSYmYShjLm5hbWUpfTphPT09IioiP2k6ZnVuY3Rpb24oYyl7cmV0dXJuIGkoYykmJmMubmFtZT09PWF9fSx0YWdfdHlwZTpmdW5jdGlvbihhKXtyZXR1cm4gdHlwZW9mIGE9PSJmdW5jdGlvbiI/ZnVuY3Rpb24oYyl7cmV0dXJuIGEoYy50eXBlKX06ZnVuY3Rpb24oYyl7cmV0dXJuIGMudHlwZT09PWF9fSx0YWdfY29udGFpbnM6ZnVuY3Rpb24oYSl7cmV0dXJuIHR5cGVvZiBhPT0iZnVuY3Rpb24iP2Z1bmN0aW9uKGMpe3JldHVybiFpKGMpJiZhKGMuZGF0YSl9OmZ1bmN0aW9uKGMpe3JldHVybiFpKGMpJiZjLmRhdGE9PT1hfX19O2Z1bmN0aW9uIGcoYSxjKXtyZXR1cm4gdHlwZW9mIGM9PSJmdW5jdGlvbiI/ZnVuY3Rpb24oeCl7cmV0dXJuIHguYXR0cmlicyYmYyh4LmF0dHJpYnNbYV0pfTpmdW5jdGlvbih4KXtyZXR1cm4geC5hdHRyaWJzJiZ4LmF0dHJpYnNbYV09PT1jfX1mdW5jdGlvbiB1KGEsYyl7cmV0dXJuIGZ1bmN0aW9uKHgpe3JldHVybiBhKHgpfHxjKHgpfX1lLmdldEVsZW1lbnRzPWZ1bmN0aW9uKGEsYyx4LGYpe3ZhciB2PU9iamVjdC5rZXlzKGEpLm1hcChmdW5jdGlvbihwKXt2YXIgQz1hW3BdO3JldHVybiBwIGluIGg/aFtwXShDKTpnKHAsQyl9KTtyZXR1cm4gdi5sZW5ndGg9PT0wP1tdOnRoaXMuZmlsdGVyKHYucmVkdWNlKHUpLGMseCxmKX0sZS5nZXRFbGVtZW50QnlJZD1mdW5jdGlvbihhLGMseCl7cmV0dXJuIEFycmF5LmlzQXJyYXkoYyl8fChjPVtjXSksdGhpcy5maW5kT25lKGcoImlkIixhKSxjLHghPT0hMSl9LGUuZ2V0RWxlbWVudHNCeVRhZ05hbWU9ZnVuY3Rpb24oYSxjLHgsZil7cmV0dXJuIHRoaXMuZmlsdGVyKGgudGFnX25hbWUoYSksYyx4LGYpfSxlLmdldEVsZW1lbnRzQnlUYWdUeXBlPWZ1bmN0aW9uKGEsYyx4LGYpe3JldHVybiB0aGlzLmZpbHRlcihoLnRhZ190eXBlKGEpLGMseCxmKX19LGZ1bmN0aW9uKFMsZSl7ZS5yZW1vdmVTdWJzZXRzPWZ1bmN0aW9uKGkpe2Zvcih2YXIgaD1pLmxlbmd0aCxnLHUsYTstLWg+LTE7KXtmb3IoZz11PWlbaF0saVtoXT1udWxsLGE9ITA7dTspe2lmKGkuaW5kZXhPZih1KT4tMSl7YT0hMSxpLnNwbGljZShoLDEpO2JyZWFrfXU9dS5wYXJlbnR9YSYmKGlbaF09Zyl9cmV0dXJuIGl9O3ZhciB0PXtESVNDT05ORUNURUQ6MSxQUkVDRURJTkc6MixGT0xMT1dJTkc6NCxDT05UQUlOUzo4LENPTlRBSU5FRF9CWToxNn0scj1lLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uPWZ1bmN0aW9uKGksaCl7dmFyIGc9W10sdT1bXSxhLGMseCxmLHYscDtpZihpPT09aClyZXR1cm4gMDtmb3IoYT1pO2E7KWcudW5zaGlmdChhKSxhPWEucGFyZW50O2ZvcihhPWg7YTspdS51bnNoaWZ0KGEpLGE9YS5wYXJlbnQ7Zm9yKHA9MDtnW3BdPT09dVtwXTspcCsrO3JldHVybiBwPT09MD90LkRJU0NPTk5FQ1RFRDooYz1nW3AtMV0seD1jLmNoaWxkcmVuLGY9Z1twXSx2PXVbcF0seC5pbmRleE9mKGYpPnguaW5kZXhPZih2KT9jPT09aD90LkZPTExPV0lOR3x0LkNPTlRBSU5FRF9CWTp0LkZPTExPV0lORzpjPT09aT90LlBSRUNFRElOR3x0LkNPTlRBSU5TOnQuUFJFQ0VESU5HKX07ZS51bmlxdWVTb3J0PWZ1bmN0aW9uKGkpe3ZhciBoPWkubGVuZ3RoLGcsdTtmb3IoaT1pLnNsaWNlKCk7LS1oPi0xOylnPWlbaF0sdT1pLmluZGV4T2YoZyksdT4tMSYmdTxoJiZpLnNwbGljZShoLDEpO3JldHVybiBpLnNvcnQoZnVuY3Rpb24oYSxjKXt2YXIgeD1yKGEsYyk7cmV0dXJuIHgmdC5QUkVDRURJTkc/LTE6eCZ0LkZPTExPV0lORz8xOjB9KSxpfX0sZnVuY3Rpb24oUyxlKXtTLmV4cG9ydHM9e3RydWVGdW5jOmZ1bmN0aW9uKCl7cmV0dXJuITB9LGZhbHNlRnVuYzpmdW5jdGlvbigpe3JldHVybiExfX19LGZ1bmN0aW9uKFMsZSx0KXtTLmV4cG9ydHM9djt2YXIgcj10KDI3NSkucGFyc2UsaT10KDI3MyksaD10KDI3OCksZz10KDI3OSksdT10KDI4MCksYT10KDI4MiksYz1pLnRydWVGdW5jLHg9aS5mYWxzZUZ1bmMsZj1hLmZpbHRlcnM7ZnVuY3Rpb24gdihQLEwsRCl7dmFyIFI9QyhQLEwsRCk7cmV0dXJuIHAoUixMKX1mdW5jdGlvbiBwKFAsTCl7dmFyIEQ9TC5hZGFwdGVyO3JldHVybiBmdW5jdGlvbihBKXtyZXR1cm4gRC5pc1RhZyhBKSYmUChBKX19ZnVuY3Rpb24gQyhQLEwsRCl7dmFyIFI9cihQLEwpO3JldHVybiBsKFIsTCxEKX1mdW5jdGlvbiBNKFApe3JldHVybiBQLnR5cGU9PT0icHNldWRvIiYmKFAubmFtZT09PSJzY29wZSJ8fEFycmF5LmlzQXJyYXkoUC5kYXRhKSYmUC5kYXRhLnNvbWUoZnVuY3Rpb24oTCl7cmV0dXJuIEwuc29tZShNKX0pKX12YXIgbT17dHlwZToiZGVzY2VuZGFudCJ9LHk9e3R5cGU6Il9mbGV4aWJsZURlc2NlbmRhbnQifSxuPXt0eXBlOiJwc2V1ZG8iLG5hbWU6InNjb3BlIn0sbz17fTtmdW5jdGlvbiBzKFAsTCxEKXt2YXIgUj1MLmFkYXB0ZXIsQT0hIUQmJiEhRC5sZW5ndGgmJkQuZXZlcnkoZnVuY3Rpb24oail7cmV0dXJuIGo9PT1vfHwhIVIuZ2V0UGFyZW50KGopfSk7UC5mb3JFYWNoKGZ1bmN0aW9uKGope2lmKCEoai5sZW5ndGg+MCYmRShqWzBdKSYmalswXS50eXBlIT09ImRlc2NlbmRhbnQiKSlpZihBJiYhKEFycmF5LmlzQXJyYXkoaik/ai5zb21lKE0pOk0oaikpKWoudW5zaGlmdChtKTtlbHNlIHJldHVybjtqLnVuc2hpZnQobil9KX1mdW5jdGlvbiBsKFAsTCxEKXtQPVAuZmlsdGVyKGZ1bmN0aW9uKEcpe3JldHVybiBHLmxlbmd0aD4wfSksUC5mb3JFYWNoKGgpO3ZhciBSPUFycmF5LmlzQXJyYXkoRCk7RD1MJiZMLmNvbnRleHR8fEQsRCYmIVImJihEPVtEXSkscyhQLEwsRCk7dmFyIEE9ITEsaj1QLm1hcChmdW5jdGlvbihHKXtpZihHWzBdJiZHWzFdJiZHWzBdLm5hbWU9PT0ic2NvcGUiKXt2YXIgSD1HWzFdLnR5cGU7UiYmSD09PSJkZXNjZW5kYW50Ij9HWzFdPXk6KEg9PT0iYWRqYWNlbnQifHxIPT09InNpYmxpbmciKSYmKEE9ITApfXJldHVybiBUKEcsTCxEKX0pLnJlZHVjZShiLHgpO3JldHVybiBqLnNob3VsZFRlc3ROZXh0U2libGluZ3M9QSxqfWZ1bmN0aW9uIEUoUCl7cmV0dXJuIGdbUC50eXBlXTwwfWZ1bmN0aW9uIFQoUCxMLEQpe3JldHVybiBQLnJlZHVjZShmdW5jdGlvbihSLEEpe2lmKFI9PT14KXJldHVybiBSO2lmKCEoQS50eXBlIGluIHUpKXRocm93IG5ldyBFcnJvcigiUnVsZSB0eXBlICIrQS50eXBlKyIgaXMgbm90IHN1cHBvcnRlZCBieSBjc3Mtc2VsZWN0Iik7cmV0dXJuIHVbQS50eXBlXShSLEEsTCxEKX0sTCYmTC5yb290RnVuY3x8Yyl9ZnVuY3Rpb24gYihQLEwpe3JldHVybiBMPT09eHx8UD09PWM/UDpQPT09eHx8TD09PWM/TDpmdW5jdGlvbihSKXtyZXR1cm4gUChSKXx8TChSKX19ZnVuY3Rpb24gSShQKXtyZXR1cm4gUC5zb21lKEUpfWYubm90PWZ1bmN0aW9uKFAsTCxELFIpe3ZhciBBPXt4bWxNb2RlOiEhKEQmJkQueG1sTW9kZSksc3RyaWN0OiEhKEQmJkQuc3RyaWN0KSxhZGFwdGVyOkQuYWRhcHRlcn07aWYoQS5zdHJpY3QmJihMLmxlbmd0aD4xfHxMLnNvbWUoSSkpKXRocm93IG5ldyBFcnJvcigiY29tcGxleCBzZWxlY3RvcnMgaW4gOm5vdCBhcmVuJ3QgYWxsb3dlZCBpbiBzdHJpY3QgbW9kZSIpO3ZhciBqPWwoTCxBLFIpO3JldHVybiBqPT09eD9QOmo9PT1jP3g6ZnVuY3Rpb24oSCl7cmV0dXJuIWooSCkmJlAoSCl9fSxmLmhhcz1mdW5jdGlvbihQLEwsRCl7dmFyIFI9RC5hZGFwdGVyLEE9e3htbE1vZGU6ISEoRCYmRC54bWxNb2RlKSxzdHJpY3Q6ISEoRCYmRC5zdHJpY3QpLGFkYXB0ZXI6Un0saj1MLnNvbWUoSSk/W29dOm51bGwsRz1sKEwsQSxqKTtyZXR1cm4gRz09PXg/eDpHPT09Yz9mdW5jdGlvbihaKXtyZXR1cm4gUi5nZXRDaGlsZHJlbihaKS5zb21lKFIuaXNUYWcpJiZQKFopfTooRz1wKEcsRCksaj9mdW5jdGlvbihaKXtyZXR1cm4gUChaKSYmKGpbMF09WixSLmV4aXN0c09uZShHLFIuZ2V0Q2hpbGRyZW4oWikpKX06ZnVuY3Rpb24oWil7cmV0dXJuIFAoWikmJlIuZXhpc3RzT25lKEcsUi5nZXRDaGlsZHJlbihaKSl9KX0sZi5tYXRjaGVzPWZ1bmN0aW9uKFAsTCxELFIpe3ZhciBBPXt4bWxNb2RlOiEhKEQmJkQueG1sTW9kZSksc3RyaWN0OiEhKEQmJkQuc3RyaWN0KSxyb290RnVuYzpQLGFkYXB0ZXI6RC5hZGFwdGVyfTtyZXR1cm4gbChMLEEsUil9LHYuY29tcGlsZVRva2VuPWwsdi5jb21waWxlVW5zYWZlPUMsdi5Qc2V1ZG9zPWF9LGZ1bmN0aW9uKFMsZSx0KXt2YXIgcj10aGlzJiZ0aGlzLl9fY3JlYXRlQmluZGluZ3x8KE9iamVjdC5jcmVhdGU/ZnVuY3Rpb24odSxhLGMseCl7eD09PXZvaWQgMCYmKHg9YyksT2JqZWN0LmRlZmluZVByb3BlcnR5KHUseCx7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gYVtjXX19KX06ZnVuY3Rpb24odSxhLGMseCl7eD09PXZvaWQgMCYmKHg9YyksdVt4XT1hW2NdfSksaT10aGlzJiZ0aGlzLl9fZXhwb3J0U3Rhcnx8ZnVuY3Rpb24odSxhKXtmb3IodmFyIGMgaW4gdSljIT09ImRlZmF1bHQiJiYhYS5oYXNPd25Qcm9wZXJ0eShjKSYmcihhLHUsYyl9O09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxpKHQoMjc2KSxlKTt2YXIgaD10KDI3Nik7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsInBhcnNlIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gaC5kZWZhdWx0fX0pO3ZhciBnPXQoMjc3KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwic3RyaW5naWZ5Iix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gZy5kZWZhdWx0fX0pfSxmdW5jdGlvbihTLGUsdCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLGUuZGVmYXVsdD1NO3ZhciByPS9eW15cXF0/KD86XFwoPzpbXGRhLWZdezEsNn1ccz98Lil8W1x3XC1cdTAwYjAtXHVGRkZGXSkrLyxpPS9cXChbXGRhLWZdezEsNn1ccz98KFxzKXwuKS9naSxoPS9eXHMqKCg/OlxcLnxbXHdcdTAwYjAtXHVGRkZGLV0pKylccyooPzooXFM/KT1ccyooPzooWyciXSkoW15dKj8pXDN8KCM/KD86XFwufFtcd1x1MDBiMC1cdUZGRkYtXSkqKXwpfClccyooaSk/XF0vLGc9e3VuZGVmaW5lZDoiZXhpc3RzIiwiIjoiZXF1YWxzIiwifiI6ImVsZW1lbnQiLCJeIjoic3RhcnQiLCQ6ImVuZCIsIioiOiJhbnkiLCIhIjoibm90IiwifCI6Imh5cGhlbiJ9LHU9eyI+IjoiY2hpbGQiLCI8IjoicGFyZW50IiwifiI6InNpYmxpbmciLCIrIjoiYWRqYWNlbnQifSxhPXsiIyI6WyJpZCIsImVxdWFscyJdLCIuIjpbImNsYXNzIiwiZWxlbWVudCJdfSxjPW5ldyBTZXQoWyJoYXMiLCJub3QiLCJtYXRjaGVzIl0pLHg9bmV3IFNldChbImNvbnRhaW5zIiwiaWNvbnRhaW5zIl0pLGY9bmV3IFNldChbJyInLCInIl0pO2Z1bmN0aW9uIHYobixvLHMpe3ZhciBsPXBhcnNlSW50KG8sMTYpLTY1NTM2O3JldHVybiBsIT09bHx8cz9vOmw8MD9TdHJpbmcuZnJvbUNoYXJDb2RlKGwrNjU1MzYpOlN0cmluZy5mcm9tQ2hhckNvZGUobD4+MTB8NTUyOTYsbCYxMDIzfDU2MzIwKX1mdW5jdGlvbiBwKG4pe3JldHVybiBuLnJlcGxhY2UoaSx2KX1mdW5jdGlvbiBDKG4pe3JldHVybiBuPT09IiAifHxuPT09YApgfHxuPT09IgkifHxuPT09IlxmInx8bj09PSJcciJ9ZnVuY3Rpb24gTShuLG8pe3ZhciBzPVtdO2lmKG49bShzLCIiK24sbyksbiE9PSIiKXRocm93IG5ldyBFcnJvcigiVW5tYXRjaGVkIHNlbGVjdG9yOiAiK24pO3JldHVybiBzfWZ1bmN0aW9uIG0obixvLHMpe3ZhciBsPVtdLEU9ITE7ZnVuY3Rpb24gVCgpe3ZhciBKPW8ubWF0Y2gocik7aWYoIUopdGhyb3cgbmV3IEVycm9yKCJFeHBlY3RlZCBuYW1lLCBmb3VuZCAiK28pO3ZhciB0dD1KWzBdO3JldHVybiBvPW8uc3Vic3RyKHR0Lmxlbmd0aCkscCh0dCl9ZnVuY3Rpb24gYihKKXtmb3IoO0Moby5jaGFyQXQoSikpOylKKys7bz1vLnN1YnN0cihKKX1mdW5jdGlvbiBJKEope2Zvcih2YXIgdHQ9MDtvLmNoYXJBdCgtLUopPT09IlxcIjspdHQrKztyZXR1cm4odHQmMSk9PT0xfWZvcihiKDApO28hPT0iIjspe3ZhciBQPW8uY2hhckF0KDApO2lmKEMoUCkpRT0hMCxiKDEpO2Vsc2UgaWYoUCBpbiB1KWwucHVzaCh7dHlwZTp1W1BdfSksRT0hMSxiKDEpO2Vsc2UgaWYoUD09PSIsIil7aWYobC5sZW5ndGg9PT0wKXRocm93IG5ldyBFcnJvcigiRW1wdHkgc3ViLXNlbGVjdG9yIik7bi5wdXNoKGwpLGw9W10sRT0hMSxiKDEpfWVsc2UgaWYoRSYmKGwubGVuZ3RoPjAmJmwucHVzaCh7dHlwZToiZGVzY2VuZGFudCJ9KSxFPSExKSxQPT09IioiKW89by5zdWJzdHIoMSksbC5wdXNoKHt0eXBlOiJ1bml2ZXJzYWwifSk7ZWxzZSBpZihQIGluIGEpe3ZhciBMPWFbUF0sRD1MWzBdLFI9TFsxXTtvPW8uc3Vic3RyKDEpLGwucHVzaCh7dHlwZToiYXR0cmlidXRlIixuYW1lOkQsYWN0aW9uOlIsdmFsdWU6VCgpLGlnbm9yZUNhc2U6ITF9KX1lbHNlIGlmKFA9PT0iWyIpe289by5zdWJzdHIoMSk7dmFyIEE9by5tYXRjaChoKTtpZighQSl0aHJvdyBuZXcgRXJyb3IoIk1hbGZvcm1lZCBhdHRyaWJ1dGUgc2VsZWN0b3I6ICIrbyk7bz1vLnN1YnN0cihBWzBdLmxlbmd0aCk7dmFyIGo9cChBWzFdKTsoIXN8fCgibG93ZXJDYXNlQXR0cmlidXRlTmFtZXMiaW4gcz9zLmxvd2VyQ2FzZUF0dHJpYnV0ZU5hbWVzOiFzLnhtbE1vZGUpKSYmKGo9ai50b0xvd2VyQ2FzZSgpKSxsLnB1c2goe3R5cGU6ImF0dHJpYnV0ZSIsbmFtZTpqLGFjdGlvbjpnW0FbMl1dLHZhbHVlOnAoQVs0XXx8QVs1XXx8IiIpLGlnbm9yZUNhc2U6ISFBWzZdfSl9ZWxzZSBpZihQPT09IjoiKXtpZihvLmNoYXJBdCgxKT09PSI6Iil7bz1vLnN1YnN0cigyKSxsLnB1c2goe3R5cGU6InBzZXVkby1lbGVtZW50IixuYW1lOlQoKS50b0xvd2VyQ2FzZSgpfSk7Y29udGludWV9bz1vLnN1YnN0cigxKTt2YXIgRz1UKCkudG9Mb3dlckNhc2UoKSxBPW51bGw7aWYoby5jaGFyQXQoMCk9PT0iKCIpaWYoYy5oYXMoRykpe3ZhciBIPW8uY2hhckF0KDEpLFo9Zi5oYXMoSCk7aWYobz1vLnN1YnN0cihaPzI6MSksQT1bXSxvPW0oQSxvLHMpLFope2lmKG8uY2hhckF0KDApIT09SCl0aHJvdyBuZXcgRXJyb3IoIlVubWF0Y2hlZCBxdW90ZXMgaW4gOiIrRyk7bz1vLnN1YnN0cigxKX1pZihvLmNoYXJBdCgwKSE9PSIpIil0aHJvdyBuZXcgRXJyb3IoIk1pc3NpbmcgY2xvc2luZyBwYXJlbnRoZXNpcyBpbiA6IitHKyIgKCIrbysiKSIpO289by5zdWJzdHIoMSl9ZWxzZXtmb3IodmFyIHE9MSxGPTE7Rj4wJiZxPG8ubGVuZ3RoO3ErKylvLmNoYXJBdChxKT09PSIoIiYmIUkocSk/RisrOm8uY2hhckF0KHEpPT09IikiJiYhSShxKSYmRi0tO2lmKEYpdGhyb3cgbmV3IEVycm9yKCJQYXJlbnRoZXNpcyBub3QgbWF0Y2hlZCIpO2lmKEE9by5zdWJzdHIoMSxxLTIpLG89by5zdWJzdHIocSkseC5oYXMoRykpe3ZhciBIPUEuY2hhckF0KDApO0g9PT1BLnNsaWNlKC0xKSYmZi5oYXMoSCkmJihBPUEuc2xpY2UoMSwtMSkpLEE9cChBKX19bC5wdXNoKHt0eXBlOiJwc2V1ZG8iLG5hbWU6RyxkYXRhOkF9KX1lbHNlIGlmKHIudGVzdChvKSl7dmFyICQ9VCgpOyghc3x8KCJsb3dlckNhc2VUYWdzImluIHM/cy5sb3dlckNhc2VUYWdzOiFzLnhtbE1vZGUpKSYmKCQ9JC50b0xvd2VyQ2FzZSgpKSxsLnB1c2goe3R5cGU6InRhZyIsbmFtZTokfSl9ZWxzZSByZXR1cm4gbC5sZW5ndGgmJmxbbC5sZW5ndGgtMV0udHlwZT09PSJkZXNjZW5kYW50IiYmbC5wb3AoKSx5KG4sbCksb31yZXR1cm4geShuLGwpLG99ZnVuY3Rpb24geShuLG8pe2lmKG4ubGVuZ3RoPjAmJm8ubGVuZ3RoPT09MCl0aHJvdyBuZXcgRXJyb3IoIkVtcHR5IHN1Yi1zZWxlY3RvciIpO24ucHVzaChvKX19LGZ1bmN0aW9uKFMsZSx0KXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSk7dmFyIHI9e2VxdWFsczoiIixlbGVtZW50OiJ+IixzdGFydDoiXiIsZW5kOiIkIixhbnk6IioiLG5vdDoiISIsaHlwaGVuOiJ8In07ZnVuY3Rpb24gaShhKXtyZXR1cm4gYS5tYXAoaCkuam9pbigiLCAiKX1lLmRlZmF1bHQ9aTtmdW5jdGlvbiBoKGEpe3JldHVybiBhLm1hcChnKS5qb2luKCIiKX1mdW5jdGlvbiBnKGEpe3N3aXRjaChhLnR5cGUpe2Nhc2UiY2hpbGQiOnJldHVybiIgPiAiO2Nhc2UicGFyZW50IjpyZXR1cm4iIDwgIjtjYXNlInNpYmxpbmciOnJldHVybiIgfiAiO2Nhc2UiYWRqYWNlbnQiOnJldHVybiIgKyAiO2Nhc2UiZGVzY2VuZGFudCI6cmV0dXJuIiAiO2Nhc2UidW5pdmVyc2FsIjpyZXR1cm4iKiI7Y2FzZSJ0YWciOnJldHVybiBhLm5hbWU7Y2FzZSJwc2V1ZG8tZWxlbWVudCI6cmV0dXJuIjo6IithLm5hbWU7Y2FzZSJwc2V1ZG8iOnJldHVybiBhLmRhdGE9PT1udWxsPyI6IithLm5hbWU6dHlwZW9mIGEuZGF0YT09InN0cmluZyI/IjoiK2EubmFtZSsiKCIrYS5kYXRhKyIpIjoiOiIrYS5uYW1lKyIoIitpKGEuZGF0YSkrIikiO2Nhc2UiYXR0cmlidXRlIjpyZXR1cm4gYS5hY3Rpb249PT0iZXhpc3RzIj8iWyIrYS5uYW1lKyJdIjphLm5hbWU9PT0iaWQiJiZhLmFjdGlvbj09PSJlcXVhbHMiJiYhYS5pZ25vcmVDYXNlPyIjIithLnZhbHVlOmEubmFtZT09PSJjbGFzcyImJmEuYWN0aW9uPT09ImVsZW1lbnQiJiYhYS5pZ25vcmVDYXNlPyIuIithLnZhbHVlOiJbIithLm5hbWUrclthLmFjdGlvbl0rIj0nIithLnZhbHVlKyInIisoYS5pZ25vcmVDYXNlPyJpIjoiIikrIl0iO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKCJVbmtub3duIHR5cGUiKX19ZnVuY3Rpb24gdShhKXtyZXR1cm4gYX19LGZ1bmN0aW9uKFMsZSx0KXtTLmV4cG9ydHM9aDt2YXIgcj10KDI3OSksaT17X19wcm90b19fOm51bGwsZXhpc3RzOjEwLGVxdWFsczo4LG5vdDo3LHN0YXJ0OjYsZW5kOjYsYW55OjUsaHlwaGVuOjQsZWxlbWVudDo0fTtmdW5jdGlvbiBoKHUpe2Zvcih2YXIgYT11Lm1hcChnKSxjPTE7Yzx1Lmxlbmd0aDtjKyspe3ZhciB4PWFbY107aWYoISh4PDApKWZvcih2YXIgZj1jLTE7Zj49MCYmeDxhW2ZdO2YtLSl7dmFyIHY9dVtmKzFdO3VbZisxXT11W2ZdLHVbZl09dixhW2YrMV09YVtmXSxhW2ZdPXh9fX1mdW5jdGlvbiBnKHUpe3ZhciBhPXJbdS50eXBlXTtpZihhPT09ci5hdHRyaWJ1dGUpYT1pW3UuYWN0aW9uXSxhPT09aS5lcXVhbHMmJnUubmFtZT09PSJpZCImJihhPTkpLHUuaWdub3JlQ2FzZSYmKGE+Pj0xKTtlbHNlIGlmKGE9PT1yLnBzZXVkbylpZighdS5kYXRhKWE9MztlbHNlIGlmKHUubmFtZT09PSJoYXMifHx1Lm5hbWU9PT0iY29udGFpbnMiKWE9MDtlbHNlIGlmKHUubmFtZT09PSJtYXRjaGVzInx8dS5uYW1lPT09Im5vdCIpe2E9MDtmb3IodmFyIGM9MDtjPHUuZGF0YS5sZW5ndGg7YysrKWlmKHUuZGF0YVtjXS5sZW5ndGg9PT0xKXt2YXIgeD1nKHUuZGF0YVtjXVswXSk7aWYoeD09PTApe2E9MDticmVha314PmEmJihhPXgpfXUuZGF0YS5sZW5ndGg+MSYmYT4wJiYoYS09MSl9ZWxzZSBhPTE7cmV0dXJuIGF9fSxmdW5jdGlvbihTKXtTLmV4cG9ydHM9SlNPTi5wYXJzZSgneyJ1bml2ZXJzYWwiOjUwLCJ0YWciOjMwLCJhdHRyaWJ1dGUiOjEsInBzZXVkbyI6MCwiZGVzY2VuZGFudCI6LTEsImNoaWxkIjotMSwicGFyZW50IjotMSwic2libGluZyI6LTEsImFkamFjZW50IjotMX0nKX0sZnVuY3Rpb24oUyxlLHQpe3ZhciByPXQoMjgxKSxpPXQoMjgyKTtTLmV4cG9ydHM9e19fcHJvdG9fXzpudWxsLGF0dHJpYnV0ZTpyLmNvbXBpbGUscHNldWRvOmkuY29tcGlsZSx0YWc6ZnVuY3Rpb24oaCxnLHUpe3ZhciBhPWcubmFtZSxjPXUuYWRhcHRlcjtyZXR1cm4gZnVuY3Rpb24oZil7cmV0dXJuIGMuZ2V0TmFtZShmKT09PWEmJmgoZil9fSxkZXNjZW5kYW50OmZ1bmN0aW9uKGgsZyx1KXt2YXIgYT10eXBlb2YgV2Vha1NldDwidSI/bmV3IFdlYWtTZXQ6bnVsbCxjPXUuYWRhcHRlcjtyZXR1cm4gZnVuY3Rpb24oZil7Zm9yKHZhciB2PSExOyF2JiYoZj1jLmdldFBhcmVudChmKSk7KSghYXx8IWEuaGFzKGYpKSYmKHY9aChmKSwhdiYmYSYmYS5hZGQoZikpO3JldHVybiB2fX0sX2ZsZXhpYmxlRGVzY2VuZGFudDpmdW5jdGlvbihoLGcsdSl7dmFyIGE9dS5hZGFwdGVyO3JldHVybiBmdW5jdGlvbih4KXtmb3IodmFyIGY9aCh4KTshZiYmKHg9YS5nZXRQYXJlbnQoeCkpOylmPWgoeCk7cmV0dXJuIGZ9fSxwYXJlbnQ6ZnVuY3Rpb24oaCxnLHUpe2lmKHUmJnUuc3RyaWN0KXRocm93IG5ldyBFcnJvcigiUGFyZW50IHNlbGVjdG9yIGlzbid0IHBhcnQgb2YgQ1NTMyIpO3ZhciBhPXUuYWRhcHRlcjtyZXR1cm4gZnVuY3Rpb24oZil7cmV0dXJuIGEuZ2V0Q2hpbGRyZW4oZikuc29tZShjKX07ZnVuY3Rpb24gYyh4KXtyZXR1cm4gYS5pc1RhZyh4KSYmaCh4KX19LGNoaWxkOmZ1bmN0aW9uKGgsZyx1KXt2YXIgYT11LmFkYXB0ZXI7cmV0dXJuIGZ1bmN0aW9uKHgpe3ZhciBmPWEuZ2V0UGFyZW50KHgpO3JldHVybiEhZiYmaChmKX19LHNpYmxpbmc6ZnVuY3Rpb24oaCxnLHUpe3ZhciBhPXUuYWRhcHRlcjtyZXR1cm4gZnVuY3Rpb24oeCl7Zm9yKHZhciBmPWEuZ2V0U2libGluZ3MoeCksdj0wO3Y8Zi5sZW5ndGg7disrKWlmKGEuaXNUYWcoZlt2XSkpe2lmKGZbdl09PT14KWJyZWFrO2lmKGgoZlt2XSkpcmV0dXJuITB9cmV0dXJuITF9fSxhZGphY2VudDpmdW5jdGlvbihoLGcsdSl7dmFyIGE9dS5hZGFwdGVyO3JldHVybiBmdW5jdGlvbih4KXtmb3IodmFyIGY9YS5nZXRTaWJsaW5ncyh4KSx2LHA9MDtwPGYubGVuZ3RoO3ArKylpZihhLmlzVGFnKGZbcF0pKXtpZihmW3BdPT09eClicmVhazt2PWZbcF19cmV0dXJuISF2JiZoKHYpfX0sdW5pdmVyc2FsOmZ1bmN0aW9uKGgpe3JldHVybiBofX19LGZ1bmN0aW9uKFMsZSx0KXt2YXIgcj10KDI3MykuZmFsc2VGdW5jLGk9L1stW1xde30oKSorPy4sXFxeJHwjXHNdL2csaD17X19wcm90b19fOm51bGwsZXF1YWxzOmZ1bmN0aW9uKGcsdSxhKXt2YXIgYz11Lm5hbWUseD11LnZhbHVlLGY9YS5hZGFwdGVyO3JldHVybiB1Lmlnbm9yZUNhc2U/KHg9eC50b0xvd2VyQ2FzZSgpLGZ1bmN0aW9uKHApe3ZhciBDPWYuZ2V0QXR0cmlidXRlVmFsdWUocCxjKTtyZXR1cm4gQyE9bnVsbCYmQy50b0xvd2VyQ2FzZSgpPT09eCYmZyhwKX0pOmZ1bmN0aW9uKHApe3JldHVybiBmLmdldEF0dHJpYnV0ZVZhbHVlKHAsYyk9PT14JiZnKHApfX0saHlwaGVuOmZ1bmN0aW9uKGcsdSxhKXt2YXIgYz11Lm5hbWUseD11LnZhbHVlLGY9eC5sZW5ndGgsdj1hLmFkYXB0ZXI7cmV0dXJuIHUuaWdub3JlQ2FzZT8oeD14LnRvTG93ZXJDYXNlKCksZnVuY3Rpb24oQyl7dmFyIE09di5nZXRBdHRyaWJ1dGVWYWx1ZShDLGMpO3JldHVybiBNIT1udWxsJiYoTS5sZW5ndGg9PT1mfHxNLmNoYXJBdChmKT09PSItIikmJk0uc3Vic3RyKDAsZikudG9Mb3dlckNhc2UoKT09PXgmJmcoQyl9KTpmdW5jdGlvbihDKXt2YXIgTT12LmdldEF0dHJpYnV0ZVZhbHVlKEMsYyk7cmV0dXJuIE0hPW51bGwmJk0uc3Vic3RyKDAsZik9PT14JiYoTS5sZW5ndGg9PT1mfHxNLmNoYXJBdChmKT09PSItIikmJmcoQyl9fSxlbGVtZW50OmZ1bmN0aW9uKGcsdSxhKXt2YXIgYz11Lm5hbWUseD11LnZhbHVlLGY9YS5hZGFwdGVyO2lmKC9ccy8udGVzdCh4KSlyZXR1cm4gcjt4PXgucmVwbGFjZShpLCJcXCQmIik7dmFyIHY9Iig/Ol58XFxzKSIreCsiKD86JHxcXHMpIixwPXUuaWdub3JlQ2FzZT8iaSI6IiIsQz1uZXcgUmVnRXhwKHYscCk7cmV0dXJuIGZ1bmN0aW9uKG0pe3ZhciB5PWYuZ2V0QXR0cmlidXRlVmFsdWUobSxjKTtyZXR1cm4geSE9bnVsbCYmQy50ZXN0KHkpJiZnKG0pfX0sZXhpc3RzOmZ1bmN0aW9uKGcsdSxhKXt2YXIgYz11Lm5hbWUseD1hLmFkYXB0ZXI7cmV0dXJuIGZ1bmN0aW9uKHYpe3JldHVybiB4Lmhhc0F0dHJpYih2LGMpJiZnKHYpfX0sc3RhcnQ6ZnVuY3Rpb24oZyx1LGEpe3ZhciBjPXUubmFtZSx4PXUudmFsdWUsZj14Lmxlbmd0aCx2PWEuYWRhcHRlcjtyZXR1cm4gZj09PTA/cjp1Lmlnbm9yZUNhc2U/KHg9eC50b0xvd2VyQ2FzZSgpLGZ1bmN0aW9uKEMpe3ZhciBNPXYuZ2V0QXR0cmlidXRlVmFsdWUoQyxjKTtyZXR1cm4gTSE9bnVsbCYmTS5zdWJzdHIoMCxmKS50b0xvd2VyQ2FzZSgpPT09eCYmZyhDKX0pOmZ1bmN0aW9uKEMpe3ZhciBNPXYuZ2V0QXR0cmlidXRlVmFsdWUoQyxjKTtyZXR1cm4gTSE9bnVsbCYmTS5zdWJzdHIoMCxmKT09PXgmJmcoQyl9fSxlbmQ6ZnVuY3Rpb24oZyx1LGEpe3ZhciBjPXUubmFtZSx4PXUudmFsdWUsZj0teC5sZW5ndGgsdj1hLmFkYXB0ZXI7cmV0dXJuIGY9PT0wP3I6dS5pZ25vcmVDYXNlPyh4PXgudG9Mb3dlckNhc2UoKSxmdW5jdGlvbihDKXt2YXIgTT12LmdldEF0dHJpYnV0ZVZhbHVlKEMsYyk7cmV0dXJuIE0hPW51bGwmJk0uc3Vic3RyKGYpLnRvTG93ZXJDYXNlKCk9PT14JiZnKEMpfSk6ZnVuY3Rpb24oQyl7dmFyIE09di5nZXRBdHRyaWJ1dGVWYWx1ZShDLGMpO3JldHVybiBNIT1udWxsJiZNLnN1YnN0cihmKT09PXgmJmcoQyl9fSxhbnk6ZnVuY3Rpb24oZyx1LGEpe3ZhciBjPXUubmFtZSx4PXUudmFsdWUsZj1hLmFkYXB0ZXI7aWYoeD09PSIiKXJldHVybiByO2lmKHUuaWdub3JlQ2FzZSl7dmFyIHY9bmV3IFJlZ0V4cCh4LnJlcGxhY2UoaSwiXFwkJiIpLCJpIik7cmV0dXJuIGZ1bmN0aW9uKEMpe3ZhciBNPWYuZ2V0QXR0cmlidXRlVmFsdWUoQyxjKTtyZXR1cm4gTSE9bnVsbCYmdi50ZXN0KE0pJiZnKEMpfX1yZXR1cm4gZnVuY3Rpb24oQyl7dmFyIE09Zi5nZXRBdHRyaWJ1dGVWYWx1ZShDLGMpO3JldHVybiBNIT1udWxsJiZNLmluZGV4T2YoeCk+PTAmJmcoQyl9fSxub3Q6ZnVuY3Rpb24oZyx1LGEpe3ZhciBjPXUubmFtZSx4PXUudmFsdWUsZj1hLmFkYXB0ZXI7cmV0dXJuIHg9PT0iIj9mdW5jdGlvbihwKXtyZXR1cm4hIWYuZ2V0QXR0cmlidXRlVmFsdWUocCxjKSYmZyhwKX06dS5pZ25vcmVDYXNlPyh4PXgudG9Mb3dlckNhc2UoKSxmdW5jdGlvbihwKXt2YXIgQz1mLmdldEF0dHJpYnV0ZVZhbHVlKHAsYyk7cmV0dXJuIEMhPW51bGwmJkMudG9Mb3dlckNhc2UoKSE9PXgmJmcocCl9KTpmdW5jdGlvbihwKXtyZXR1cm4gZi5nZXRBdHRyaWJ1dGVWYWx1ZShwLGMpIT09eCYmZyhwKX19fTtTLmV4cG9ydHM9e2NvbXBpbGU6ZnVuY3Rpb24oZyx1LGEpe2lmKGEmJmEuc3RyaWN0JiYodS5pZ25vcmVDYXNlfHx1LmFjdGlvbj09PSJub3QiKSl0aHJvdyBuZXcgRXJyb3IoIlVuc3VwcG9ydGVkIGF0dHJpYnV0ZSBzZWxlY3RvciIpO3JldHVybiBoW3UuYWN0aW9uXShnLHUsYSl9LHJ1bGVzOmh9fSxmdW5jdGlvbihTLGUsdCl7dmFyIHI9dCgyODMpLGk9dCgyNzMpLGg9dCgyODEpLGc9aS50cnVlRnVuYyx1PWkuZmFsc2VGdW5jLGE9aC5ydWxlcy5lcXVhbHM7ZnVuY3Rpb24gYyh5LG4pe3ZhciBvPXtuYW1lOnksdmFsdWU6bn07cmV0dXJuIGZ1bmN0aW9uKGwsRSxUKXtyZXR1cm4gYShsLG8sVCl9fWZ1bmN0aW9uIHgoeSxuKXtyZXR1cm4gZnVuY3Rpb24obyl7cmV0dXJuISFuLmdldFBhcmVudChvKSYmeShvKX19dmFyIGY9e2NvbnRhaW5zOmZ1bmN0aW9uKHksbixvKXt2YXIgcz1vLmFkYXB0ZXI7cmV0dXJuIGZ1bmN0aW9uKEUpe3JldHVybiB5KEUpJiZzLmdldFRleHQoRSkuaW5kZXhPZihuKT49MH19LGljb250YWluczpmdW5jdGlvbih5LG4sbyl7dmFyIHM9bi50b0xvd2VyQ2FzZSgpLGw9by5hZGFwdGVyO3JldHVybiBmdW5jdGlvbihUKXtyZXR1cm4geShUKSYmbC5nZXRUZXh0KFQpLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihzKT49MH19LCJudGgtY2hpbGQiOmZ1bmN0aW9uKHksbixvKXt2YXIgcz1yKG4pLGw9by5hZGFwdGVyO3JldHVybiBzPT09dT9zOnM9PT1nP3goeSxsKTpmdW5jdGlvbihUKXtmb3IodmFyIGI9bC5nZXRTaWJsaW5ncyhUKSxJPTAsUD0wO0k8Yi5sZW5ndGg7SSsrKWlmKGwuaXNUYWcoYltJXSkpe2lmKGJbSV09PT1UKWJyZWFrO1ArK31yZXR1cm4gcyhQKSYmeShUKX19LCJudGgtbGFzdC1jaGlsZCI6ZnVuY3Rpb24oeSxuLG8pe3ZhciBzPXIobiksbD1vLmFkYXB0ZXI7cmV0dXJuIHM9PT11P3M6cz09PWc/eCh5LGwpOmZ1bmN0aW9uKFQpe2Zvcih2YXIgYj1sLmdldFNpYmxpbmdzKFQpLEk9MCxQPWIubGVuZ3RoLTE7UD49MDtQLS0paWYobC5pc1RhZyhiW1BdKSl7aWYoYltQXT09PVQpYnJlYWs7SSsrfXJldHVybiBzKEkpJiZ5KFQpfX0sIm50aC1vZi10eXBlIjpmdW5jdGlvbih5LG4sbyl7dmFyIHM9cihuKSxsPW8uYWRhcHRlcjtyZXR1cm4gcz09PXU/czpzPT09Zz94KHksbCk6ZnVuY3Rpb24oVCl7Zm9yKHZhciBiPWwuZ2V0U2libGluZ3MoVCksST0wLFA9MDtQPGIubGVuZ3RoO1ArKylpZihsLmlzVGFnKGJbUF0pKXtpZihiW1BdPT09VClicmVhaztsLmdldE5hbWUoYltQXSk9PT1sLmdldE5hbWUoVCkmJkkrK31yZXR1cm4gcyhJKSYmeShUKX19LCJudGgtbGFzdC1vZi10eXBlIjpmdW5jdGlvbih5LG4sbyl7dmFyIHM9cihuKSxsPW8uYWRhcHRlcjtyZXR1cm4gcz09PXU/czpzPT09Zz94KHksbCk6ZnVuY3Rpb24oVCl7Zm9yKHZhciBiPWwuZ2V0U2libGluZ3MoVCksST0wLFA9Yi5sZW5ndGgtMTtQPj0wO1AtLSlpZihsLmlzVGFnKGJbUF0pKXtpZihiW1BdPT09VClicmVhaztsLmdldE5hbWUoYltQXSk9PT1sLmdldE5hbWUoVCkmJkkrK31yZXR1cm4gcyhJKSYmeShUKX19LHJvb3Q6ZnVuY3Rpb24oeSxuLG8pe3ZhciBzPW8uYWRhcHRlcjtyZXR1cm4gZnVuY3Rpb24obCl7cmV0dXJuIXMuZ2V0UGFyZW50KGwpJiZ5KGwpfX0sc2NvcGU6ZnVuY3Rpb24oeSxuLG8scyl7dmFyIGw9by5hZGFwdGVyO2lmKCFzfHxzLmxlbmd0aD09PTApcmV0dXJuIGYucm9vdCh5LG4sbyk7ZnVuY3Rpb24gRShULGIpe3JldHVybiB0eXBlb2YgbC5lcXVhbHM9PSJmdW5jdGlvbiI/bC5lcXVhbHMoVCxiKTpUPT09Yn1yZXR1cm4gcy5sZW5ndGg9PT0xP2Z1bmN0aW9uKFQpe3JldHVybiBFKHNbMF0sVCkmJnkoVCl9OmZ1bmN0aW9uKFQpe3JldHVybiBzLmluZGV4T2YoVCk+PTAmJnkoVCl9fSxjaGVja2JveDpjKCJ0eXBlIiwiY2hlY2tib3giKSxmaWxlOmMoInR5cGUiLCJmaWxlIikscGFzc3dvcmQ6YygidHlwZSIsInBhc3N3b3JkIikscmFkaW86YygidHlwZSIsInJhZGlvIikscmVzZXQ6YygidHlwZSIsInJlc2V0IiksaW1hZ2U6YygidHlwZSIsImltYWdlIiksc3VibWl0OmMoInR5cGUiLCJzdWJtaXQiKSxob3ZlcjpmdW5jdGlvbih5LG4sbyl7dmFyIHM9by5hZGFwdGVyO3JldHVybiB0eXBlb2Ygcy5pc0hvdmVyZWQ9PSJmdW5jdGlvbiI/ZnVuY3Rpb24oRSl7cmV0dXJuIHkoRSkmJnMuaXNIb3ZlcmVkKEUpfTp1fSx2aXNpdGVkOmZ1bmN0aW9uKHksbixvKXt2YXIgcz1vLmFkYXB0ZXI7cmV0dXJuIHR5cGVvZiBzLmlzVmlzaXRlZD09ImZ1bmN0aW9uIj9mdW5jdGlvbihFKXtyZXR1cm4geShFKSYmcy5pc1Zpc2l0ZWQoRSl9OnV9LGFjdGl2ZTpmdW5jdGlvbih5LG4sbyl7dmFyIHM9by5hZGFwdGVyO3JldHVybiB0eXBlb2Ygcy5pc0FjdGl2ZT09ImZ1bmN0aW9uIj9mdW5jdGlvbihFKXtyZXR1cm4geShFKSYmcy5pc0FjdGl2ZShFKX06dX19O2Z1bmN0aW9uIHYoeSxuKXtmb3IodmFyIG89MDt5JiZvPHkubGVuZ3RoO28rKylpZihuLmlzVGFnKHlbb10pKXJldHVybiB5W29dfXZhciBwPXtlbXB0eTpmdW5jdGlvbih5LG4pe3JldHVybiFuLmdldENoaWxkcmVuKHkpLnNvbWUoZnVuY3Rpb24obyl7cmV0dXJuIG4uaXNUYWcobyl8fG8udHlwZT09PSJ0ZXh0In0pfSwiZmlyc3QtY2hpbGQiOmZ1bmN0aW9uKHksbil7cmV0dXJuIHYobi5nZXRTaWJsaW5ncyh5KSxuKT09PXl9LCJsYXN0LWNoaWxkIjpmdW5jdGlvbih5LG4pe2Zvcih2YXIgbz1uLmdldFNpYmxpbmdzKHkpLHM9by5sZW5ndGgtMTtzPj0wO3MtLSl7aWYob1tzXT09PXkpcmV0dXJuITA7aWYobi5pc1RhZyhvW3NdKSlicmVha31yZXR1cm4hMX0sImZpcnN0LW9mLXR5cGUiOmZ1bmN0aW9uKHksbil7Zm9yKHZhciBvPW4uZ2V0U2libGluZ3MoeSkscz0wO3M8by5sZW5ndGg7cysrKWlmKG4uaXNUYWcob1tzXSkpe2lmKG9bc109PT15KXJldHVybiEwO2lmKG4uZ2V0TmFtZShvW3NdKT09PW4uZ2V0TmFtZSh5KSlicmVha31yZXR1cm4hMX0sImxhc3Qtb2YtdHlwZSI6ZnVuY3Rpb24oeSxuKXtmb3IodmFyIG89bi5nZXRTaWJsaW5ncyh5KSxzPW8ubGVuZ3RoLTE7cz49MDtzLS0paWYobi5pc1RhZyhvW3NdKSl7aWYob1tzXT09PXkpcmV0dXJuITA7aWYobi5nZXROYW1lKG9bc10pPT09bi5nZXROYW1lKHkpKWJyZWFrfXJldHVybiExfSwib25seS1vZi10eXBlIjpmdW5jdGlvbih5LG4pe2Zvcih2YXIgbz1uLmdldFNpYmxpbmdzKHkpLHM9MCxsPW8ubGVuZ3RoO3M8bDtzKyspaWYobi5pc1RhZyhvW3NdKSl7aWYob1tzXT09PXkpY29udGludWU7aWYobi5nZXROYW1lKG9bc10pPT09bi5nZXROYW1lKHkpKXJldHVybiExfXJldHVybiEwfSwib25seS1jaGlsZCI6ZnVuY3Rpb24oeSxuKXtmb3IodmFyIG89bi5nZXRTaWJsaW5ncyh5KSxzPTA7czxvLmxlbmd0aDtzKyspaWYobi5pc1RhZyhvW3NdKSYmb1tzXSE9PXkpcmV0dXJuITE7cmV0dXJuITB9LGxpbms6ZnVuY3Rpb24oeSxuKXtyZXR1cm4gbi5oYXNBdHRyaWIoeSwiaHJlZiIpfSxzZWxlY3RlZDpmdW5jdGlvbih5LG4pe2lmKG4uaGFzQXR0cmliKHksInNlbGVjdGVkIikpcmV0dXJuITA7aWYobi5nZXROYW1lKHkpIT09Im9wdGlvbiIpcmV0dXJuITE7dmFyIG89bi5nZXRQYXJlbnQoeSk7aWYoIW98fG4uZ2V0TmFtZShvKSE9PSJzZWxlY3QifHxuLmhhc0F0dHJpYihvLCJtdWx0aXBsZSIpKXJldHVybiExO2Zvcih2YXIgcz1uLmdldENoaWxkcmVuKG8pLGw9ITEsRT0wO0U8cy5sZW5ndGg7RSsrKWlmKG4uaXNUYWcoc1tFXSkpaWYoc1tFXT09PXkpbD0hMDtlbHNlIGlmKGwpe2lmKG4uaGFzQXR0cmliKHNbRV0sInNlbGVjdGVkIikpcmV0dXJuITF9ZWxzZSByZXR1cm4hMTtyZXR1cm4gbH0sZGlzYWJsZWQ6ZnVuY3Rpb24oeSxuKXtyZXR1cm4gbi5oYXNBdHRyaWIoeSwiZGlzYWJsZWQiKX0sZW5hYmxlZDpmdW5jdGlvbih5LG4pe3JldHVybiFuLmhhc0F0dHJpYih5LCJkaXNhYmxlZCIpfSxjaGVja2VkOmZ1bmN0aW9uKHksbil7cmV0dXJuIG4uaGFzQXR0cmliKHksImNoZWNrZWQiKXx8cC5zZWxlY3RlZCh5LG4pfSxyZXF1aXJlZDpmdW5jdGlvbih5LG4pe3JldHVybiBuLmhhc0F0dHJpYih5LCJyZXF1aXJlZCIpfSxvcHRpb25hbDpmdW5jdGlvbih5LG4pe3JldHVybiFuLmhhc0F0dHJpYih5LCJyZXF1aXJlZCIpfSxwYXJlbnQ6ZnVuY3Rpb24oeSxuKXtyZXR1cm4hcC5lbXB0eSh5LG4pfSxoZWFkZXI6QyhbImgxIiwiaDIiLCJoMyIsImg0IiwiaDUiLCJoNiJdKSxidXR0b246ZnVuY3Rpb24oeSxuKXt2YXIgbz1uLmdldE5hbWUoeSk7cmV0dXJuIG89PT0iYnV0dG9uInx8bz09PSJpbnB1dCImJm4uZ2V0QXR0cmlidXRlVmFsdWUoeSwidHlwZSIpPT09ImJ1dHRvbiJ9LGlucHV0OkMoWyJpbnB1dCIsInRleHRhcmVhIiwic2VsZWN0IiwiYnV0dG9uIl0pLHRleHQ6ZnVuY3Rpb24oeSxuKXt2YXIgbztyZXR1cm4gbi5nZXROYW1lKHkpPT09ImlucHV0IiYmKCEobz1uLmdldEF0dHJpYnV0ZVZhbHVlKHksInR5cGUiKSl8fG8udG9Mb3dlckNhc2UoKT09PSJ0ZXh0Iil9fTtmdW5jdGlvbiBDKHkpe2lmKHR5cGVvZiBTZXQ8InUiKXt2YXIgbj1uZXcgU2V0KHkpO3JldHVybiBmdW5jdGlvbihvLHMpe3JldHVybiBuLmhhcyhzLmdldE5hbWUobykpfX1yZXR1cm4gZnVuY3Rpb24obyxzKXtyZXR1cm4geS5pbmRleE9mKHMuZ2V0TmFtZShvKSk+PTB9fWZ1bmN0aW9uIE0oeSxuLG8pe2lmKG89PT1udWxsKXtpZih5Lmxlbmd0aD4yJiZuIT09InNjb3BlIil0aHJvdyBuZXcgRXJyb3IoInBzZXVkby1zZWxlY3RvciA6IituKyIgcmVxdWlyZXMgYW4gYXJndW1lbnQiKX1lbHNlIGlmKHkubGVuZ3RoPT09Mil0aHJvdyBuZXcgRXJyb3IoInBzZXVkby1zZWxlY3RvciA6IituKyIgZG9lc24ndCBoYXZlIGFueSBhcmd1bWVudHMiKX12YXIgbT0vXig/Oig/Om50aHxsYXN0fGZpcnN0fG9ubHkpLSg/OmNoaWxkfG9mLXR5cGUpfHJvb3R8ZW1wdHl8KD86ZW58ZGlzKWFibGVkfGNoZWNrZWR8bm90KSQvO1MuZXhwb3J0cz17Y29tcGlsZTpmdW5jdGlvbih5LG4sbyxzKXt2YXIgbD1uLm5hbWUsRT1uLmRhdGEsVD1vLmFkYXB0ZXI7aWYobyYmby5zdHJpY3QmJiFtLnRlc3QobCkpdGhyb3cgbmV3IEVycm9yKCI6IitsKyIgaXNuJ3QgcGFydCBvZiBDU1MzIik7aWYodHlwZW9mIGZbbF09PSJmdW5jdGlvbiIpcmV0dXJuIGZbbF0oeSxFLG8scyk7aWYodHlwZW9mIHBbbF09PSJmdW5jdGlvbiIpe3ZhciBiPXBbbF07cmV0dXJuIE0oYixsLEUpLGI9PT11P2I6eT09PWc/ZnVuY3Rpb24oUCl7cmV0dXJuIGIoUCxULEUpfTpmdW5jdGlvbihQKXtyZXR1cm4gYihQLFQsRSkmJnkoUCl9fWVsc2UgdGhyb3cgbmV3IEVycm9yKCJ1bm1hdGNoZWQgcHNldWRvLWNsYXNzIDoiK2wpfSxmaWx0ZXJzOmYscHNldWRvczpwfX0sZnVuY3Rpb24oUyxlLHQpe3ZhciByPXQoMjg0KSxpPXQoMjg1KTtTLmV4cG9ydHM9ZnVuY3Rpb24oZyl7cmV0dXJuIGkocihnKSl9LFMuZXhwb3J0cy5wYXJzZT1yLFMuZXhwb3J0cy5jb21waWxlPWl9LGZ1bmN0aW9uKFMsZSl7Uy5leHBvcnRzPXI7dmFyIHQ9L14oWytcLV0/XGQqbik/XHMqKD86KFsrXC1dPylccyooXGQrKSk/JC87ZnVuY3Rpb24gcihpKXtpZihpPWkudHJpbSgpLnRvTG93ZXJDYXNlKCksaT09PSJldmVuIilyZXR1cm5bMiwwXTtpZihpPT09Im9kZCIpcmV0dXJuWzIsMV07dmFyIGg9aS5tYXRjaCh0KTtpZighaCl0aHJvdyBuZXcgU3ludGF4RXJyb3IoIm4tdGggcnVsZSBjb3VsZG4ndCBiZSBwYXJzZWQgKCciK2krIicpIik7dmFyIGc7cmV0dXJuIGhbMV0/KGc9cGFyc2VJbnQoaFsxXSwxMCksaXNOYU4oZykmJihoWzFdLmNoYXJBdCgwKT09PSItIj9nPS0xOmc9MSkpOmc9MCxbZyxoWzNdP3BhcnNlSW50KChoWzJdfHwiIikraFszXSwxMCk6MF19fSxmdW5jdGlvbihTLGUsdCl7Uy5leHBvcnRzPWc7dmFyIHI9dCgyNzMpLGk9ci50cnVlRnVuYyxoPXIuZmFsc2VGdW5jO2Z1bmN0aW9uIGcodSl7dmFyIGE9dVswXSxjPXVbMV0tMTtpZihjPDAmJmE8PTApcmV0dXJuIGg7aWYoYT09PS0xKXJldHVybiBmdW5jdGlvbihmKXtyZXR1cm4gZjw9Y307aWYoYT09PTApcmV0dXJuIGZ1bmN0aW9uKGYpe3JldHVybiBmPT09Y307aWYoYT09PTEpcmV0dXJuIGM8MD9pOmZ1bmN0aW9uKGYpe3JldHVybiBmPj1jfTt2YXIgeD1jJWE7cmV0dXJuIHg8MCYmKHgrPWEpLGE+MT9mdW5jdGlvbihmKXtyZXR1cm4gZj49YyYmZiVhPT09eH06KGEqPS0xLGZ1bmN0aW9uKGYpe3JldHVybiBmPD1jJiZmJWE9PT14fSl9fSxmdW5jdGlvbihTLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBFfSk7dmFyIHI9dCgxMiksaT10KDc0KSxoPXQoMSksZz10KDY4KSx1PXQoMjUwKSxhPXQoMjEzKSxjPXQoMjE4KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24geChULGIpe2lmKFQ9PW51bGwpcmV0dXJue307dmFyIEk9ZihULGIpLFAsTDtpZihPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKXt2YXIgRD1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKFQpO2ZvcihMPTA7TDxELmxlbmd0aDtMKyspUD1EW0xdLCEoYi5pbmRleE9mKFApPj0wKSYmT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKFQsUCkmJihJW1BdPVRbUF0pfXJldHVybiBJfWZ1bmN0aW9uIGYoVCxiKXtpZihUPT1udWxsKXJldHVybnt9O3ZhciBJPXt9LFA9T2JqZWN0LmtleXMoVCksTCxEO2ZvcihEPTA7RDxQLmxlbmd0aDtEKyspTD1QW0RdLCEoYi5pbmRleE9mKEwpPj0wKSYmKElbTF09VFtMXSk7cmV0dXJuIEl9Y29uc3Qgdj17YW50aWFsaWFzOiEwLGF1dG9SZW5kZXI6ITAsYWxwaGE6ITB9LHA9U3ltYm9sKCJhdXRvUmVuZGVyIiksQz1TeW1ib2woInJlbmRlcmVyIiksTT1TeW1ib2woInRpbWVsaW5lIiksbT1TeW1ib2woInByZXBhcmVSZW5kZXIiKSx5PVN5bWJvbCgidGlja1JlbmRlciIpLG49U3ltYm9sKCJwYXNzIiksbz1TeW1ib2woImZibyIpLHM9U3ltYm9sKCJ0aWNrZXJzIiksbD1TeW1ib2woImxheWVyVHJhbnNmb3JtSW52ZXJ0Iik7Y2xhc3MgRSBleHRlbmRzIHUuZGVmYXVsdHtjb25zdHJ1Y3RvcihiPXt9KXtpZihzdXBlcigpLCFiLmNhbnZhcyl7Y29uc3R7d2lkdGg6RCxoZWlnaHQ6Un09dGhpcy5nZXRSZXNvbHV0aW9uKCksQT1yLkVOVi5jcmVhdGVDYW52YXMoRCxSLHtvZmZzY3JlZW46ISFiLm9mZnNjcmVlbixpZDpiLmlkLGV4dHJhOmIuZXh0cmF9KTtBLnN0eWxlJiYoQS5zdHlsZS5wb3NpdGlvbj0iYWJzb2x1dGUiKSxBLmRhdGFzZXQmJihBLmRhdGFzZXQubGF5ZXJJZD1iLmlkKSxBLmNvbnRleHRUeXBlJiYoYi5jb250ZXh0VHlwZT1BLmNvbnRleHRUeXBlKSxiLmNhbnZhcz1BfWNvbnN0IEk9Yi5jYW52YXMsUD1PYmplY3QuYXNzaWduKHt9LHYsYik7dGhpc1twXT1QLmF1dG9SZW5kZXIsZGVsZXRlIGIuYXV0b1JlbmRlcjtjb25zdCBMPVAuUmVuZGVyZXJ8fHIuUmVuZGVyZXI7dGhpc1tDXT1uZXcgTChJLFApLHRoaXMub3B0aW9ucz1iLHRoaXMuaWQ9Yi5pZCx0aGlzW25dPVtdLHRoaXMuc2V0UmVzb2x1dGlvbihJKSx0aGlzLmNhbnZhcz1JLHRoaXNbTV09bmV3IGkuVGltZWxpbmUsdGhpcy5fX21vdXNlQ2FwdHVyZWRUYXJnZXQ9bnVsbCx0aGlzW2xdPW51bGx9Z2V0IGF1dG9SZW5kZXIoKXtyZXR1cm4gdGhpc1twXX1nZXQgZGlzcGxheVJhdGlvKCl7cmV0dXJuIHRoaXMucGFyZW50JiZ0aGlzLnBhcmVudC5vcHRpb25zP3RoaXMucGFyZW50Lm9wdGlvbnMuZGlzcGxheVJhdGlvOjF9Z2V0IGhlaWdodCgpe2NvbnN0e2hlaWdodDpifT10aGlzLmdldFJlc29sdXRpb24oKTtyZXR1cm4gYi90aGlzLmRpc3BsYXlSYXRpb31nZXQgZ2woKXtyZXR1cm4gdGhpcy5yZW5kZXJlci5nbFJlbmRlcmVyP3RoaXMucmVuZGVyZXIuZ2xSZW5kZXJlci5nbDpudWxsfWdldCBsYXllcigpe3JldHVybiB0aGlzfWdldCBvZmZzY3JlZW4oKXtyZXR1cm4hIXRoaXMub3B0aW9ucy5vZmZzY3JlZW58fHRoaXMuY2FudmFzLl9vZmZzY3JlZW59Z2V0IHBhc3MoKXtyZXR1cm4gdGhpc1tuXX1nZXQgcHJlcGFyZVJlbmRlcigpe3JldHVybiB0aGlzW21dP3RoaXNbbV06UHJvbWlzZS5yZXNvbHZlKCl9Z2V0IHJlbmRlcmVyKCl7cmV0dXJuIHRoaXNbQ119Z2V0IHJlbmRlck9mZnNldCgpe2lmKHRoaXMucGFyZW50JiZ0aGlzLnBhcmVudC5vcHRpb25zKXtjb25zdHtsZWZ0OmIsdG9wOkl9PXRoaXMucGFyZW50Lm9wdGlvbnM7cmV0dXJuW2IsSV19cmV0dXJuW3RoaXMub3B0aW9ucy5sZWZ0fDAsdGhpcy5vcHRpb25zLnRvcHwwXX1nZXQgdGltZWxpbmUoKXtyZXR1cm4gdGhpc1tNXX1nZXQgd2lkdGgoKXtjb25zdHt3aWR0aDpifT10aGlzLmdldFJlc29sdXRpb24oKTtyZXR1cm4gYi90aGlzLmRpc3BsYXlSYXRpb31nZXQgbG9jYWxNYXRyaXgoKXtjb25zdHt4OmIseTpJfT10aGlzLmF0dHJpYnV0ZXM7cmV0dXJuWzEsMCwwLDEsYixJXX1nZXQgbGF5ZXJUcmFuc2Zvcm1JbnZlcnQoKXtpZih0aGlzW2xdKXJldHVybiB0aGlzW2xdO2NvbnN0IGI9dGhpcy50cmFuc2Zvcm1NYXRyaXg7cmV0dXJuIGJbMF09PT0xJiZiWzFdPT09MCYmYlsyXT09PTAmJmJbM109PT0xJiZiWzRdPT09MCYmYls1XT09PTA/bnVsbDoodGhpc1tsXT1oLm1hdDJkLmludmVydChBcnJheS5vZigwLDAsMCwwLDAsMCksYiksdGhpc1tsXSl9Zm9yY2VDb250ZXh0TG9zcygpe2NvbnN0IGI9dGhpcy5yZW5kZXJlci5nbFJlbmRlcmVyO2lmKGIpe2NvbnN0IEk9Yi5nZXRFeHRlbnNpb24oIldFQkdMX2xvc2VfY29udGV4dCIpO2lmKEkpcmV0dXJuIEkubG9zZUNvbnRleHQoKSwhMH1yZXR1cm4hMX1hZGRQYXNzKHt2ZXJ0ZXg6YixmcmFnbWVudDpJLG9wdGlvbnM6UCx1bmlmb3JtczpMfT17fSl7aWYodGhpcy5yZW5kZXJlci5nbFJlbmRlcmVyKXtjb25zdHt3aWR0aDpELGhlaWdodDpSfT10aGlzLmdldFJlc29sdXRpb24oKSxBPXRoaXMucmVuZGVyZXIuY3JlYXRlUGFzc1Byb2dyYW0oe3ZlcnRleDpiLGZyYWdtZW50Okksb3B0aW9uczpQfSksaj1uZXcgci5GaWd1cmUyRDtqLnJlY3QoMCwwLEQvdGhpcy5kaXNwbGF5UmF0aW8sUi90aGlzLmRpc3BsYXlSYXRpbyk7Y29uc3QgRz1uZXcgci5NZXNoMkQoaik7cmV0dXJuIEcuc2V0VW5pZm9ybXMoTCksRy5zZXRQcm9ncmFtKEEpLHRoaXNbbl0ucHVzaChHKSx0aGlzLmZvcmNlVXBkYXRlKCksR31yZXR1cm4gbnVsbH1kZWxldGVUZXh0dXJlKGIpe3JldHVybiBPYmplY3QoYy5kZWxldGVUZXh0dXJlKShiLHRoaXMucmVuZGVyZXIpfWRpc3BhdGNoUG9pbnRlckV2ZW50KGIpe2NvbnN0IEk9Yi50eXBlO2lmKEk9PT0ibW91c2Vkb3duInx8ST09PSJtb3VzZXVwInx8ST09PSJtb3VzZW1vdmUiKXtjb25zdCBBPXRoaXMuX19tb3VzZUNhcHR1cmVkVGFyZ2V0O2lmKEEpe2lmKEEubGF5ZXI9PT10aGlzKXJldHVybiBBLmRpc3BhdGNoRXZlbnQoYiksITA7dGhpcy5fX21vdXNlQ2FwdHVyZWRUYXJnZXQ9bnVsbH19bGV0IFAsTDtjb25zdCBEPXRoaXMubGF5ZXJUcmFuc2Zvcm1JbnZlcnQ7aWYoRCl7UD1iLngsTD1iLnk7Y29uc3QgQT1ELGo9QVswXSpQK0FbMl0qTCtBWzRdLEc9QVsxXSpQK0FbM10qTCtBWzVdO2RlbGV0ZSBiLngsZGVsZXRlIGIueSxkZWxldGUgYi5sYXllclgsZGVsZXRlIGIubGF5ZXJZLE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGIse2xheWVyWDp7dmFsdWU6aixjb25maWd1cmFibGU6ITB9LGxheWVyWTp7dmFsdWU6Ryxjb25maWd1cmFibGU6ITB9LHg6e3ZhbHVlOmosY29uZmlndXJhYmxlOiEwfSx5Ont2YWx1ZTpHLGNvbmZpZ3VyYWJsZTohMH19KX1jb25zdCBSPXN1cGVyLmRpc3BhdGNoUG9pbnRlckV2ZW50KGIpO3JldHVybiBEJiZPYmplY3QuZGVmaW5lUHJvcGVydGllcyhiLHtsYXllclg6e3ZhbHVlOlAsY29uZmlndXJhYmxlOiEwfSxsYXllclk6e3ZhbHVlOkwsY29uZmlndXJhYmxlOiEwfSx4Ont2YWx1ZTpQLGNvbmZpZ3VyYWJsZTohMH0seTp7dmFsdWU6TCxjb25maWd1cmFibGU6ITB9fSksUn1mb3JjZVVwZGF0ZSgpe2lmKCF0aGlzW21dKWlmKHRoaXMucGFyZW50JiZ0aGlzLnBhcmVudC5oYXNPZmZzY3JlZW5DYW52YXMpe3RoaXMucGFyZW50LmZvcmNlVXBkYXRlKCk7bGV0IGI9bnVsbDtjb25zdCBJPW5ldyBQcm9taXNlKFA9PntiPVB9KTtJLl9yZXNvbHZlPWIsdGhpc1ttXT1JfWVsc2V7bGV0IGI9bnVsbCxJPW51bGw7Y29uc3QgUD1uZXcgUHJvbWlzZShMPT57Yj1MLHRoaXNbcF0mJihJPU9iamVjdChnLnJlcXVlc3RBbmltYXRpb25GcmFtZSkoKCk9PntkZWxldGUgUC5fcmVxdWVzdElELHRoaXMucmVuZGVyKCl9KSl9KTtQLl9yZXNvbHZlPWIsUC5fcmVxdWVzdElEPUksdGhpc1ttXT1QfX1nZXRGQk8oKXtjb25zdCBiPXRoaXMucmVuZGVyZXIuZ2xSZW5kZXJlcix7d2lkdGg6SSxoZWlnaHQ6UH09dGhpcy5nZXRSZXNvbHV0aW9uKCk7cmV0dXJuIGImJighdGhpc1tvXXx8dGhpc1tvXS53aWR0aCE9PUl8fHRoaXNbb10uaGVpZ2h0IT09UCk/KHRoaXNbb109e3dpZHRoOkksaGVpZ2h0OlAsdGFyZ2V0OmIuY3JlYXRlRkJPKCksYnVmZmVyOmIuY3JlYXRlRkJPKCksc3dhcCgpe1t0aGlzLnRhcmdldCx0aGlzLmJ1ZmZlcl09W3RoaXMuYnVmZmVyLHRoaXMudGFyZ2V0XX19LHRoaXNbb10pOnRoaXNbb10/dGhpc1tvXTpudWxsfXVwZGF0ZUdsb2JhbFRyYW5zZm9ybSgpe2lmKHRoaXMubGF5ZXJUcmFuc2Zvcm1JbnZlcnQpe2NvbnN0IGI9dGhpcy5yZW5kZXJlcixJPWIuX19nbG9iYWxUcmFuc2Zvcm1NYXRyaXh8fGIuZ2xvYmFsVHJhbnNmb3JtTWF0cml4O2IuX19nbG9iYWxUcmFuc2Zvcm1NYXRyaXg9STtjb25zdCBQPWgubWF0MmQuZnJvbVZhbHVlcygxLDAsMCwxLDAsMCk7Yi5zZXRHbG9iYWxUcmFuc2Zvcm0oLi4uaC5tYXQyZC5tdWx0aXBseShQLEksdGhpcy50cmFuc2Zvcm1NYXRyaXgpKX19b25Qcm9wZXJ0eUNoYW5nZShiLEksUCl7aWYoc3VwZXIub25Qcm9wZXJ0eUNoYW5nZShiLEksUCksYj09PSJ6SW5kZXgiJiYodGhpcy5jYW52YXMuc3R5bGUuekluZGV4PUkpLGI9PT0idHJhbnNmb3JtInx8Yj09PSJ0cmFuc2xhdGUifHxiPT09InJvdGF0ZSJ8fGI9PT0ic2NhbGUifHxiPT09InNrZXciKXtjb25zdCBMPXRoaXNbbF07aWYodGhpc1tsXT1udWxsLHRoaXMudXBkYXRlR2xvYmFsVHJhbnNmb3JtKCksTCYmIXRoaXMubGF5ZXJUcmFuc2Zvcm1JbnZlcnQpe2NvbnN0IEQ9dGhpcy5yZW5kZXJlcixSPUQuX19nbG9iYWxUcmFuc2Zvcm1NYXRyaXh8fEQuZ2xvYmFsVHJhbnNmb3JtTWF0cml4O0Quc2V0R2xvYmFsVHJhbnNmb3JtKC4uLlIpfX19X3ByZXBhcmVSZW5kZXJGaW5pc2hlZCgpe3RoaXNbbV0mJih0aGlzW21dLl9yZXF1ZXN0SUQmJk9iamVjdChnLmNhbmNlbEFuaW1hdGlvbkZyYW1lKSh0aGlzW21dLl9yZXF1ZXN0SUQpLHRoaXNbbV0uX3Jlc29sdmUoKSxkZWxldGUgdGhpc1ttXSl9cmVuZGVyKHtjbGVhcjpiPSEwfT17fSl7Y29uc3QgST10aGlzW25dLmxlbmd0aD90aGlzLmdldEZCTygpOm51bGw7SSYmdGhpcy5yZW5kZXJlci5nbFJlbmRlcmVyLmJpbmRGQk8oSS50YXJnZXQpLGImJnRoaXNbQ10uY2xlYXIoKTtjb25zdCBQPXRoaXMuZHJhdygpO2lmKFAmJlAubGVuZ3RoJiYodGhpcy5yZW5kZXJlci5kcmF3TWVzaGVzKFApLHRoaXMuY2FudmFzLmRyYXcmJnRoaXMuY2FudmFzLmRyYXcoKSksSSl7Y29uc3QgTD10aGlzLnJlbmRlcmVyLmdsUmVuZGVyZXIsRD10aGlzW25dLmxlbmd0aCx7d2lkdGg6UixoZWlnaHQ6QX09dGhpcy5nZXRSZXNvbHV0aW9uKCksaj1bMCwwLFIvdGhpcy5kaXNwbGF5UmF0aW8sQS90aGlzLmRpc3BsYXlSYXRpb107dGhpc1tuXS5mb3JFYWNoKChHLEgpPT57Ry5ibGVuZD0hMCxHLnNldFRleHR1cmUoSS50YXJnZXQudGV4dHVyZSx7cmVjdDpqfSksSD09PUQtMT9MLmJpbmRGQk8obnVsbCk6KEkuc3dhcCgpLEwuYmluZEZCTyhJLnRhcmdldCkpLHRoaXNbQ10uY2xlYXIoKSx0aGlzLnJlbmRlcmVyLmRyYXdNZXNoZXMoW0ddKX0pfXRoaXMuX3ByZXBhcmVSZW5kZXJGaW5pc2hlZCgpfXNldFJlc29sdXRpb24oe3dpZHRoOmIsaGVpZ2h0Okl9KXtjb25zdCBQPXRoaXMucmVuZGVyZXIsTD1QLl9fZ2xvYmFsVHJhbnNmb3JtTWF0cml4fHxQLmdsb2JhbFRyYW5zZm9ybU1hdHJpeCxEPUxbNF0sUj1MWzVdLEE9TFswXSx7d2lkdGg6aixoZWlnaHQ6R309dGhpcy5nZXRSZXNvbHV0aW9uKCk7KGohPT1ifHxHIT09SSkmJihzdXBlci5zZXRSZXNvbHV0aW9uKHt3aWR0aDpiLGhlaWdodDpJfSksdGhpcy5jYW52YXMmJih0aGlzLmNhbnZhcy53aWR0aD1iLHRoaXMuY2FudmFzLmhlaWdodD1JLFAudXBkYXRlUmVzb2x1dGlvbiYmUC51cGRhdGVSZXNvbHV0aW9uKCkpLHRoaXMuYXR0cmlidXRlcy5zaXplPVtiLEldLHRoaXNbbl0ubGVuZ3RoJiZ0aGlzW25dLmZvckVhY2goRj0+e2NvbnN0ICQ9bmV3IHIuRmlndXJlMkQ7JC5yZWN0KDAsMCxiL3RoaXMuZGlzcGxheVJhdGlvLEkvdGhpcy5kaXNwbGF5UmF0aW8pLEYuY29udG91cnM9JC5jb250b3Vyc30pKTtjb25zdFtILFpdPXRoaXMucmVuZGVyT2Zmc2V0LHE9dGhpcy5kaXNwbGF5UmF0aW87KEQhPT1IfHxSIT09Wnx8QSE9PXEpJiYoUC5zZXRHbG9iYWxUcmFuc2Zvcm0ocSwwLDAscSxILFopLFAuX19nbG9iYWxUcmFuc2Zvcm1NYXRyaXg9bnVsbCx0aGlzW2xdPW51bGwsdGhpcy51cGRhdGVHbG9iYWxUcmFuc2Zvcm0oKSx0aGlzLmZvcmNlVXBkYXRlKCkpfXRpY2soYj1udWxsLEk9e30pe2xldHtkdXJhdGlvbjpQPTEvMH09SSxMPXgoSSxbImR1cmF0aW9uIl0pO2NvbnN0IEQ9dGhpcy50aW1lbGluZS5mb3JrKEwpLFI9dGhpczt0aGlzW3NdPXRoaXNbc118fFtdLHRoaXNbc10ucHVzaCh7aGFuZGxlcjpiLGR1cmF0aW9uOlB9KTtjb25zdCBBPSgpPT57bGV0IGo9bnVsbCxHPW51bGw7Y29uc3QgSD0oKT0+e2NvbnN0IFo9dGhpc1tzXS5tYXAoKHtoYW5kbGVyOnEsZHVyYXRpb246Rn0pPT57Y29uc3QgJD1NYXRoLm1pbigxLEQuY3VycmVudFRpbWUvRik7cmV0dXJue3ZhbHVlOnE/cShELmN1cnJlbnRUaW1lLCQpOm51bGwscDokfX0pO1JbeV18fChSW3ldPVByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCk9PntSW3BdJiZSLnJlbmRlcigpLGRlbGV0ZSBSW3ldO2ZvcihsZXQgcT1aLmxlbmd0aC0xO3E+PTA7cS0tKXtjb25zdHt2YWx1ZTpGLHA6JH09WltxXTsoRj09PSExfHwkPj0xKSYmdGhpc1tzXS5zcGxpY2UocSwxKX10aGlzW3NdLmxlbmd0aD4wJiZBKCl9KSl9O2lmKHRoaXNbbV0mJnRoaXNbbV0uX3R5cGUhPT0idGlja2VyIiYmKE9iamVjdChnLmNhbmNlbEFuaW1hdGlvbkZyYW1lKSh0aGlzW21dLl9yZXF1ZXN0SUQpLGRlbGV0ZSB0aGlzW21dKSwhdGhpc1ttXSl7Y29uc3QgWj1uZXcgUHJvbWlzZShxPT57aj1xLEc9T2JqZWN0KGcucmVxdWVzdEFuaW1hdGlvbkZyYW1lKShIKX0pO1ouX3Jlc29sdmU9aixaLl9yZXF1ZXN0SUQ9RyxaLl90eXBlPSJ0aWNrZXIiLHRoaXNbbV09Wn19O0EoKX10b0dsb2JhbFBvcyhiLEkpe2lmKHRoaXMubGF5ZXJUcmFuc2Zvcm1JbnZlcnQpe2NvbnN0IGo9dGhpcy50cmFuc2Zvcm1NYXRyaXg7Yj1qWzBdKmIralsyXSpJK2pbNF0sST1qWzFdKmIralszXSpJK2pbNV19Y29uc3R7d2lkdGg6UCxoZWlnaHQ6TH09dGhpcy5nZXRSZXNvbHV0aW9uKCksRD10aGlzLnJlbmRlck9mZnNldCxSPVt0aGlzLmNhbnZhcy5jbGllbnRXaWR0aCx0aGlzLmNhbnZhcy5jbGllbnRIZWlnaHRdO2I9YipSWzBdL1ArRFswXSxJPUkqUlsxXS9MK0RbMV07Y29uc3QgQT10aGlzLmRpc3BsYXlSYXRpbztyZXR1cm4gYio9QSxJKj1BLFtiLEldfXRvTG9jYWxQb3MoYixJKXtjb25zdHt3aWR0aDpQLGhlaWdodDpMfT10aGlzLmdldFJlc29sdXRpb24oKSxEPXRoaXMucmVuZGVyT2Zmc2V0LFI9W3RoaXMuY2FudmFzLmNsaWVudFdpZHRoLHRoaXMuY2FudmFzLmNsaWVudEhlaWdodF07Yj1iKlAvUlswXS1EWzBdLEk9SSpML1JbMV0tRFsxXTtjb25zdCBBPXRoaXMuZGlzcGxheVJhdGlvO2IvPUEsSS89QTtjb25zdCBqPXRoaXMubGF5ZXJUcmFuc2Zvcm1JbnZlcnQ7cmV0dXJuIGomJihiPWpbMF0qYitqWzJdKkkrals0XSxJPWpbMV0qYitqWzNdKkkrals1XSksW2IsSV19fWEuZGVmYXVsdC5yZWdpc3Rlck5vZGUoRSwibGF5ZXIiKX0sZnVuY3Rpb24oUyxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gbX0pO3ZhciByPXQoMjI0KSxpPXQoMjg4KSxoPXQoMjEzKSxnPXQoMjUyKSx1PXQoNzIpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBhKHksbil7aWYoeT09bnVsbClyZXR1cm57fTt2YXIgbz1jKHksbikscyxsO2lmKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpe3ZhciBFPU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoeSk7Zm9yKGw9MDtsPEUubGVuZ3RoO2wrKylzPUVbbF0sIShuLmluZGV4T2Yocyk+PTApJiZPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoeSxzKSYmKG9bc109eVtzXSl9cmV0dXJuIG99ZnVuY3Rpb24gYyh5LG4pe2lmKHk9PW51bGwpcmV0dXJue307dmFyIG89e30scz1PYmplY3Qua2V5cyh5KSxsLEU7Zm9yKEU9MDtFPHMubGVuZ3RoO0UrKylsPXNbRV0sIShuLmluZGV4T2YobCk+PTApJiYob1tsXT15W2xdKTtyZXR1cm4gb31mdW5jdGlvbiB4KHksbixvKXtyZXR1cm4gbiBpbiB5P09iamVjdC5kZWZpbmVQcm9wZXJ0eSh5LG4se3ZhbHVlOm8sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTp5W25dPW8seX1jb25zdCBmPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIsdj1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGUiKSxwPVN5bWJvbCgicm9vdCIpLEM9U3ltYm9sKCJ0YXNrIik7ZnVuY3Rpb24gTSh5LG49ITApe2NvbnN0IG89eVtwXTtpZihvJiZvLmNoaWxkcmVuWzBdKXtjb25zdCBzPXkuc3ZnLGw9eS5sYXllcj95LmxheWVyLmRpc3BsYXlSYXRpbzoxO2lmKCFzLmhhc0F0dHJpYnV0ZSgiZGF0YS1vcmlnaW5hbC13aWR0aCIpKXtsZXQgYj1zLmdldEF0dHJpYnV0ZSgid2lkdGgiKTtiPWI/T2JqZWN0KHUuc2l6ZVRvUGl4ZWwpKGIpOjMwMDtsZXQgST1zLmdldEF0dHJpYnV0ZSgiaGVpZ2h0Iik7ST1JP09iamVjdCh1LnNpemVUb1BpeGVsKShJKToxNTAscy5oYXNBdHRyaWJ1dGUoInZpZXdCb3giKXx8cy5zZXRBdHRyaWJ1dGUoInZpZXdCb3giLGAwIDAgJHtNYXRoLnJvdW5kKGIpfSAke01hdGgucm91bmQoSSl9YCkscy5zZXRBdHRyaWJ1dGUoImRhdGEtb3JpZ2luYWwtd2lkdGgiLGIpLHMuc2V0QXR0cmlidXRlKCJkYXRhLW9yaWdpbmFsLWhlaWdodCIsSSl9bGV0IEU9eS5hdHRyaWJ1dGVzLndpZHRofHxOdW1iZXIocy5nZXRBdHRyaWJ1dGUoImRhdGEtb3JpZ2luYWwtd2lkdGgiKSksVD15LmF0dHJpYnV0ZXMuaGVpZ2h0fHxOdW1iZXIocy5nZXRBdHRyaWJ1dGUoImRhdGEtb3JpZ2luYWwtaGVpZ2h0IikpO2lmKEUqPWwsVCo9bCxuJiZ5LmF0dHJpYnV0ZXMuZmxleGlibGUpe2NvbnN0IGI9eS5hdHRyaWJ1dGVzLnNjYWxlWzBdO2lmKEUqPWIsVCo9YixzLnNldEF0dHJpYnV0ZSgid2lkdGgiLEUpLHMuc2V0QXR0cmlidXRlKCJoZWlnaHQiLFQpLEUmJlQmJnkudGV4dHVyZUltYWdlKXtjb25zdCBJPXkudGV4dHVyZUltYWdlLndpZHRoLFA9eS50ZXh0dXJlSW1hZ2UuaGVpZ2h0LEw9eS5jbGllbnRTaXplO3kuYXR0cmlidXRlcy50ZXh0dXJlUmVjdD1bMCwwLE1hdGgucm91bmQoTFswXSpJL0UpLE1hdGgucm91bmQoTFsxXSpQL1QpXX19ZWxzZSB5W0NdfHwocy5zZXRBdHRyaWJ1dGUoIndpZHRoIixFKSxzLnNldEF0dHJpYnV0ZSgiaGVpZ2h0IixUKSx5W0NdPVByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCk9PntkZWxldGUgeVtDXTtjb25zdCBiPW8uaW5uZXJIVE1MLEk9bmV3IEJsb2IoW2JdLHt0eXBlOiJpbWFnZS9zdmcreG1sIn0pLFA9VVJMLmNyZWF0ZU9iamVjdFVSTChJKSxMPW5ldyBJbWFnZTtMLm9ubG9hZD1mdW5jdGlvbigpe0wud2lkdGgmJkwuaGVpZ2h0Pyh5LmF0dHJpYnV0ZXNbdl0oInRleHR1cmUiLEwpLHkuYXR0cmlidXRlcy5mbGV4aWJsZSYmKHkuYXR0cmlidXRlcy50ZXh0dXJlUmVjdD1udWxsKSk6eS5hdHRyaWJ1dGVzW3ZdKCJ0ZXh0dXJlIixudWxsKX0sTC5zcmM9UH0pKX19Y2xhc3MgbSBleHRlbmRzIHIuZGVmYXVsdHtjb25zdHJ1Y3RvcihuPXt9KXt0eXBlb2Ygbj09InN0cmluZyImJihuPXtzdmdUZXh0Om59KTtsZXR7c3ZnVGV4dDpvfT1uLHM9YShuLFsic3ZnVGV4dCJdKTtpZihzdXBlcihzKSx0aGlzW3BdPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpLG8pe3RoaXNbcF0uaW5uZXJIVE1MPW87Y29uc3QgbD10aGlzW3BdLmNoaWxkcmVuWzBdO2w/bC5zZXRBdHRyaWJ1dGUoInhtbG5zIixmKTooZmV0Y2gobykudGhlbihFPT5FLnRleHQoKSkudGhlbihFPT57dGhpc1twXS5pbm5lckhUTUw9RSwoIXRoaXMub2JzZXJ2ZXJ8fHRoaXMuYXR0cmlidXRlcy5mbGV4aWJsZSkmJk0odGhpcyl9KSxvPW51bGwpfWlmKCFvKXtjb25zdCBsPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhmLCJzdmciKTtsLnNldEF0dHJpYnV0ZSgieG1sbnMiLGYpLHRoaXNbcF0uYXBwZW5kQ2hpbGQobCl9aWYodHlwZW9mIE11dGF0aW9uT2JzZXJ2ZXI9PSJmdW5jdGlvbiIpe2NvbnN0IGw9bmV3IE11dGF0aW9uT2JzZXJ2ZXIoRT0+e00odGhpcywhMSl9KTtsLm9ic2VydmUodGhpc1twXSx7YXR0cmlidXRlczohMCxzdWJ0cmVlOiEwLGNoYXJhY3RlckRhdGE6ITAsY2hpbGRMaXN0OiEwfSksdGhpcy5vYnNlcnZlcj1sfX1nZXQgY2hpbGRyZW4oKXtyZXR1cm5bdGhpcy5zdmddfWdldCBjaGlsZE5vZGVzKCl7cmV0dXJuW3RoaXMuc3ZnXX1nZXQgc3ZnKCl7cmV0dXJuIHRoaXNbcF0/dGhpc1twXS5jaGlsZHJlblswXTpudWxsfXNldFJlc29sdXRpb24oe3dpZHRoOm4saGVpZ2h0Om99KXtzdXBlci5zZXRSZXNvbHV0aW9uKHt3aWR0aDpuLGhlaWdodDpvfSksTSh0aGlzKX1kaXNwYXRjaFBvaW50ZXJFdmVudChuKXtjb25zdCBvPXN1cGVyLmRpc3BhdGNoUG9pbnRlckV2ZW50KG4pO2lmKG8mJnRoaXMuYXR0cmlidXRlcy5wYXNzRXZlbnRzJiZ0eXBlb2YgTW91c2VFdmVudD09ImZ1bmN0aW9uIil7Y29uc3R7eDpzLHk6bH09bjtsZXRbRSxUXT10aGlzLmdldE9mZnNldFBvc2l0aW9uKHMsbCk7Y29uc3QgYj1uLm9yaWdpbmFsRXZlbnQsST10aGlzLmF0dHJpYnV0ZXMuYW5jaG9yLFA9dGhpcy5jbGllbnRTaXplO0U9KEUrSVswXSpQWzBdKS8yLFQ9KFQrSVsxXSpQWzFdKS8yO2NvbnN0IEw9bi50eXBlO2lmKEw9PT1iLnR5cGUpe2xldCBEPW51bGw7aWYoYiBpbnN0YW5jZW9mIE1vdXNlRXZlbnQpRD1uZXcgTW91c2VFdmVudChMLHtzY3JlZW5YOkUsc2NyZWVuWTpULGNsaWVudFg6RSxjbGllbnRZOlQsYnViYmxlczpiLmJ1YmJsZXMsYnV0dG9uOmIuYnV0dG9uLGJ1dHRvbnM6Yi5idXR0b25zLGNhbmNlbEJ1YmJsZTpiLmNhbmNlbEJ1YmJsZSxjYW5jZWxhYmxlOmIuY2FuY2VsYWJsZSxjdXJyZW50VGFyZ2V0OmIuY3VycmVudFRhcmdldCxmcm9tRWxlbWVudDpiLmZyb21FbGVtZW50LHJlbGF0ZWRUYXJnZXQ6Yi5yZWxhdGVkVGFyZ2V0LHJldHVyblZhbHVlOmIucmV0dXJuVmFsdWUsc3JjRWxlbWVudDpiLnNyY0VsZW1lbnQsdGFyZ2V0OmIudGFyZ2V0LHRvRWxlbWVudDpiLnRvRWxlbWVudCx3aGljaDpiLndpdGNofSk7ZWxzZSBpZihiIGluc3RhbmNlb2YgVG91Y2hFdmVudCl7bGV0IFI9bnVsbDtjb25zdCBBPWIuY2hhbmdlZFRvdWNoZXN8fFtiXTtmb3IobGV0IGo9MDtqPEEubGVuZ3RoO2orKyl7Y29uc3QgRz1BW2pdO2lmKG4uaWRlbnRpZmllcj09PUcuaWRlbnRpZmllcil7Uj1HO2JyZWFrfX1pZihSKXtjb25zdCBqPW5ldyBUb3VjaCh7aWRlbnRpZmllcjpSLmlkZW50aWZpZXIsdGFyZ2V0OlIudGFyZ2V0LGNsaWVudFg6RSxjbGllbnRZOlQsc2NyZWVuWDpFLHNjcmVlblk6VCxwYWdlWDpFLHBhZ2VZOlQscmFkaXVzWDpSLnJhZGl1c1gscmFkaXVzWTpSLnJhZGl1c1kscm90YXRpb25BbmdsZTpSLnJvdGF0aW9uQW5nbGUsZm9yY2U6Ui5mb3JjZX0pO0Q9bmV3IFRvdWNoRXZlbnQoTCx7Y2FuY2VsYWJsZTpiLmNhbmNlbGFibGUsYnViYmxlczpiLmJ1YmJsZXMsY29tcG9zZWQ6Yi5jb21wb3NlZCx0b3VjaGVzOltqXSx0YXJnZXRUb3VjaGVzOltqXSxjaGFuZ2VkVG91Y2hlczpbal19KX19ZWxzZSBEPWI7RCYmdGhpcy5zdmcuZGlzcGF0Y2hFdmVudChEKX19cmV0dXJuIG99Z2V0RWxlbWVudEJ5SWQobil7cmV0dXJuIE9iamVjdChnLnF1ZXJ5U2VsZWN0b3IpKGAjJHtufWAsdGhpcyl9Z2V0RWxlbWVudHNCeUNsYXNzTmFtZShuKXtyZXR1cm4gT2JqZWN0KGcucXVlcnlTZWxlY3RvckFsbCkoYC4ke259YCx0aGlzKX1nZXRFbGVtZW50c0J5TmFtZShuKXtyZXR1cm4gT2JqZWN0KGcucXVlcnlTZWxlY3RvckFsbCkoYFtuYW1lPSIke259Il1gLHRoaXMpfWdldEVsZW1lbnRzQnlUYWdOYW1lKG4pe3JldHVybiBPYmplY3QoZy5xdWVyeVNlbGVjdG9yQWxsKShuLHRoaXMpfXF1ZXJ5U2VsZWN0b3Iobil7cmV0dXJuIE9iamVjdChnLnF1ZXJ5U2VsZWN0b3IpKG4sdGhpcyl9cXVlcnlTZWxlY3RvckFsbChuKXtyZXR1cm4gT2JqZWN0KGcucXVlcnlTZWxlY3RvckFsbCkobix0aGlzKX1vblByb3BlcnR5Q2hhbmdlKG4sbyxzKXtzdXBlci5vblByb3BlcnR5Q2hhbmdlKG4sbyxzKSxuPT09ImZsZXhpYmxlIiYmTSh0aGlzKSx0aGlzLmF0dHJpYnV0ZXMuZmxleGlibGUmJihuPT09IndpZHRoInx8bj09PSJoZWlnaHQifHxuPT09InNjYWxlInx8bj09PSJ0cmFuc2Zvcm0iKSYmTSh0aGlzKX19eChtLCJBdHRyIixpLmRlZmF1bHQpLGguZGVmYXVsdC5yZWdpc3Rlck5vZGUobSwic3ByaXRlc3ZnIil9LGZ1bmN0aW9uKFMsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIHV9KTt2YXIgcj10KDIyNSk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IGk9U3ltYm9sLmZvcigic3ByaXRlanNfZ2V0QXR0cmlidXRlIiksaD1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGUiKSxnPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZURlZmF1bHQiKTtjbGFzcyB1IGV4dGVuZHMgci5kZWZhdWx0e2NvbnN0cnVjdG9yKGMpe3N1cGVyKGMpLHRoaXNbZ10oe3Bhc3NFdmVudHM6ITEsZmxleGlibGU6ITF9KX1nZXQgdGV4dHVyZSgpe3JldHVybiB0aGlzW2ldKCJ0ZXh0dXJlIil9c2V0IHRleHR1cmUoYyl7fWdldCBwYXNzRXZlbnRzKCl7cmV0dXJuIHRoaXNbaV0oInBhc3NFdmVudHMiKX1zZXQgcGFzc0V2ZW50cyhjKXtyZXR1cm4gdGhpc1toXSgicGFzc0V2ZW50cyIsYyl9Z2V0IGZsZXhpYmxlKCl7cmV0dXJuIHRoaXNbaV0oImZsZXhpYmxlIil9c2V0IGZsZXhpYmxlKGMpe3JldHVybiB0aGlzW2hdKCJmbGV4aWJsZSIsYyl9fX0sZnVuY3Rpb24oUyxlLHQpe3QucihlKTt2YXIgcj10KDEyKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gaShjLHgpe3ZhciBmPU9iamVjdC5rZXlzKGMpO2lmKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpe3ZhciB2PU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoYyk7eCYmKHY9di5maWx0ZXIoZnVuY3Rpb24ocCl7cmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYyxwKS5lbnVtZXJhYmxlfSkpLGYucHVzaC5hcHBseShmLHYpfXJldHVybiBmfWZ1bmN0aW9uIGgoYyl7Zm9yKHZhciB4PTE7eDxhcmd1bWVudHMubGVuZ3RoO3grKyl7dmFyIGY9YXJndW1lbnRzW3hdIT1udWxsP2FyZ3VtZW50c1t4XTp7fTt4JTI/aShPYmplY3QoZiksITApLmZvckVhY2goZnVuY3Rpb24odil7ZyhjLHYsZlt2XSl9KTpPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycz9PYmplY3QuZGVmaW5lUHJvcGVydGllcyhjLE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKGYpKTppKE9iamVjdChmKSkuZm9yRWFjaChmdW5jdGlvbih2KXtPYmplY3QuZGVmaW5lUHJvcGVydHkoYyx2LE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZix2KSl9KX1yZXR1cm4gY31mdW5jdGlvbiBnKGMseCxmKXtyZXR1cm4geCBpbiBjP09iamVjdC5kZWZpbmVQcm9wZXJ0eShjLHgse3ZhbHVlOmYsZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTpjW3hdPWYsY31jb25zdCB1PVN5bWJvbCgiaW5pdGVkIik7bGV0IGE9bnVsbDt0eXBlb2YgV29ya2VyPT0iZnVuY3Rpb24iJiYoYT1jbGFzcyBleHRlbmRzIFdvcmtlcntjb25zdHJ1Y3RvcihjKXtpZihjLndvcmtlcj09PSEwJiYoYy53b3JrZXI9YC4vJHtjLmlkfS53b3JrZXIuanNgKSxzdXBlcihjLndvcmtlciksdGhpcy5vcHRpb25zPWMsIWMuY2FudmFzKXtjb25zdHt3aWR0aDp4LGhlaWdodDpmfT10aGlzLmdldFJlc29sdXRpb24oKSx2PXIuRU5WLmNyZWF0ZUNhbnZhcyh4LGYse29mZnNjcmVlbjohMX0pO3Yuc3R5bGUmJih2LnN0eWxlLnBvc2l0aW9uPSJhYnNvbHV0ZSIpLHYuZGF0YXNldCYmKHYuZGF0YXNldC5sYXllcklkPWMuaWQpLGMuY2FudmFzPXZ9dGhpcy5jYW52YXM9Yy5jYW52YXN9Z2V0IGlkKCl7cmV0dXJuIHRoaXMub3B0aW9ucy5pZH1zZXRSZXNvbHV0aW9uKHt3aWR0aDpjLGhlaWdodDp4fSl7aWYodGhpc1t1XSl0aGlzLnBvc3RNZXNzYWdlKHt0eXBlOiJyZXNvbHV0aW9uX2NoYW5nZSIsd2lkdGg6YyxoZWlnaHQ6eH0pO2Vsc2V7dGhpcy5jYW52YXMud2lkdGg9Yyx0aGlzLmNhbnZhcy5oZWlnaHQ9eDtjb25zdCBmPXRoaXMub3B0aW9ucyx2PWYuY2FudmFzLnRyYW5zZmVyQ29udHJvbFRvT2Zmc2NyZWVuKCkscD1oKHt9LGYpO2RlbGV0ZSBwLmNvbnRhaW5lcixwLmNhbnZhcz12LHRoaXMucG9zdE1lc3NhZ2Uoe3R5cGU6ImNyZWF0ZSIsb3B0aW9uczpwfSxbdl0pLHRoaXNbdV09ITB9fWdldFJlc29sdXRpb24oKXtpZih0aGlzLmNhbnZhcyl7Y29uc3R7d2lkdGg6YyxoZWlnaHQ6eH09dGhpcy5jYW52YXM7cmV0dXJue3dpZHRoOmMsaGVpZ2h0Onh9fXJldHVybnt3aWR0aDozMDAsaGVpZ2h0OjE1MH19cmVtb3ZlKCl7cmV0dXJuIHRoaXMucGFyZW50JiZ0aGlzLnBhcmVudC5yZW1vdmVDaGlsZD8odGhpcy5wYXJlbnQucmVtb3ZlQ2hpbGQodGhpcyksITApOiExfWNvbm5lY3QoYyx4KXtPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywicGFyZW50Iix7dmFsdWU6Yyx3cml0YWJsZTohMSxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiek9yZGVyIix7dmFsdWU6eCx3cml0YWJsZTohMSxjb25maWd1cmFibGU6ITB9KX1kaXNjb25uZWN0KCl7ZGVsZXRlIHRoaXMucGFyZW50LGRlbGV0ZSB0aGlzLnpPcmRlcn1kaXNwYXRjaFBvaW50ZXJFdmVudChjKXt0aGlzLnBvc3RNZXNzYWdlKHt0eXBlOiJldmVudCIsZXZlbnQ6e2NhbmNlbEJ1YmJsZTpjLmNhbmNlbEJ1YmJsZSxidWJibGVzOmMuYnViYmxlcyxkZXRhaWw6Yy5kZXRhaWwsaWRlbnRpZmllcjpjLmlkZW50aWZpZXIsbGF5ZXJYOmMubGF5ZXJYLGxheWVyWTpjLmxheWVyWSxvcmlnaW5hbFg6Yy5vcmlnaW5hbFgsb3JpZ2luYWxZOmMub3JpZ2luYWxZLHR5cGU6Yy50eXBlLHg6Yy54LHk6Yy55fX0pfX0pLGUuZGVmYXVsdD1hfSxmdW5jdGlvbihTLGUsdCl7dC5yKGUpLChmdW5jdGlvbihyKXt0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gRX0pO3ZhciBpPXQoMTIpLGg9dCg2OCksZz10KDcwKSx1PXQoMjg2KSxhPXQoMjg5KSxjPXQoMjUwKSx4PXQoMjkxKSxmPXQoMjE0KSx2PXQoMjE4KSxwPXQoMjEzKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3QgQz1TeW1ib2woImVudGVyZWRUYXJnZXRzIik7ZnVuY3Rpb24gTShUKXtyZXR1cm4gVC5pZD1ULmlkfHxgX2xheWVyJHtNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyLDEyKX1gLFQuZGF0YXNldHx8KFQuZGF0YXNldD17fSksVC5kYXRhc2V0LmxheWVySWQ9VC5pZCxULmNvbm5lY3Q9KGIsSSk9PntULnBhcmVudD1iLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShULCJ6T3JkZXIiLHt2YWx1ZTpJLHdyaXRhYmxlOiExLGNvbmZpZ3VyYWJsZTohMH0pfSxULmRpc2Nvbm5lY3Q9Yj0+e2RlbGV0ZSBULnpPcmRlcn0sVC5jYW52YXM9VCxULmdldFJlc29sdXRpb249KCk9Pih7d2lkdGg6MCxoZWlnaHQ6MH0pLFQuc2V0UmVzb2x1dGlvbj0oKT0+ITEsVC5vcHRpb25zPXtoYW5kbGVFdmVudDohMX0sVH1mdW5jdGlvbiBtKFQsYil7Y29uc3QgST1ULmNoaWxkcmVuO2xldCBQPW51bGw7Zm9yKGxldCBMPTA7TDxJLmxlbmd0aDtMKyspe2NvbnN0IEQ9SVtMXTtpZigoYj09PUR8fFAhPW51bGwpJiYoUD1EKSxQJiZQIT09YiYmIVAub2Zmc2NyZWVuKXJldHVybiBQLmNhbnZhc31yZXR1cm4gbnVsbH1mdW5jdGlvbiB5KFQsYil7Y29uc3RbSSxQXT1ULnJlbmRlck9mZnNldCx7d2lkdGg6TCxoZWlnaHQ6RH09VC5nZXRSZXNvbHV0aW9uKCksUj1ULmRpc3BsYXlSYXRpbztULnJlbmRlcmVyLmRyYXdJbWFnZShiLmNhbnZhcywtSS9SLC1QL1IsTC9SLEQvUil9Y29uc3Qgbj17fTtmdW5jdGlvbiBvKFQpe2NvbnN0IGI9WyJtb3VzZWRvd24iLCJtb3VzZXVwIiwibW91c2Vtb3ZlIiwibW91c2V3aGVlbCIsIndoZWVsIiwidG91Y2hzdGFydCIsInRvdWNoZW5kIiwidG91Y2htb3ZlIiwidG91Y2hjYW5jZWwiLCJjbGljayIsImRibGNsaWNrIiwibG9uZ3ByZXNzIiwidGFwIiwiY29udGV4dG1lbnUiXSxJPVQuY29udGFpbmVyO0kuYWRkRXZlbnRMaXN0ZW5lcigibW91c2VsZWF2ZSIsUD0+e2NvbnN0IEw9VFtDXTtpZihMLnNpemUpe2NvbnN0IEQ9bmV3IGYuZGVmYXVsdCgibW91c2VsZWF2ZSIpO0Quc2V0T3JpZ2luYWxFdmVudChQKSxbLi4uTF0uZm9yRWFjaChSPT57Ui5kaXNwYXRjaEV2ZW50KEQpfSksVFtDXS5jbGVhcigpfX0se3Bhc3NpdmU6ITB9KSxiLmZvckVhY2goUD0+e0kuYWRkRXZlbnRMaXN0ZW5lcihQLEw9Pntjb25zdHtsZWZ0OkQsdG9wOlIsZGlzcGxheVJhdGlvOkF9PVQub3B0aW9ucyxqPVQub3JkZXJlZENoaWxkcmVuO09iamVjdCh4LmRlZmF1bHQpKEwse29mZnNldExlZnQ6RCxvZmZzZXRUb3A6UixkaXNwbGF5UmF0aW86QX0pLmZvckVhY2goSD0+e2NvbnN0IFo9SC5pZGVudGlmaWVyO2lmKEgudHlwZT09PSJ0b3VjaG1vdmUifHxILnR5cGU9PT0idG91Y2hlbmQiKXtjb25zdCBGPW5bWl07RiYmRi5kaXNwYXRjaEV2ZW50KEgpLEgudHlwZT09PSJ0b3VjaGVuZCImJmRlbGV0ZSBuW1pdfWVsc2V7Zm9yKGxldCBGPWoubGVuZ3RoLTE7Rj49MDtGLS0pe2NvbnN0ICQ9altGXTtpZigkLm9wdGlvbnMuaGFuZGxlRXZlbnQhPT0hMSl7aWYoJC5kaXNwYXRjaFBvaW50ZXJFdmVudChIKSYmSC50YXJnZXQhPT0kKWJyZWFrO0guY2FuY2VsQnViYmxlPSExfX1pZihILnRhcmdldD09PWpbMF0pZm9yKGxldCBGPWoubGVuZ3RoLTE7Rj49MDtGLS0pe2NvbnN0ICQ9altGXTtpZigkLm9wdGlvbnMuaGFuZGxlRXZlbnQhPT0hMSl7SC50YXJnZXQ9JDticmVha319fWNvbnN0IHE9SC50YXJnZXQ7aWYoSC50eXBlPT09InRvdWNoc3RhcnQiJiYobltaXT1ILnRhcmdldCksSC50eXBlPT09Im1vdXNlbW92ZSIpe2NvbnN0IEY9VFtDXTtsZXQgJDtpZihxKXtjb25zdCBfPXEuYW5jZXN0b3JzfHxbXTskPW5ldyBTZXQoW3EsLi4uX10pfWVsc2UgJD1uZXcgU2V0O2NvbnN0IEo9T2JqZWN0LmVudHJpZXMoTCk7aWYoIUYuaGFzKHEpJiZxKXtjb25zdCBfPW5ldyBmLmRlZmF1bHQoIm1vdXNlZW50ZXIiKTtfLnNldE9yaWdpbmFsRXZlbnQoTCksSi5mb3JFYWNoKChbayxjdF0pPT57X1trXT1jdH0pLEYuYWRkKHEpLHEuZGlzcGF0Y2hFdmVudChfKTtjb25zdCBzdD1xLmFuY2VzdG9ycztzdCYmc3QuZm9yRWFjaChrPT57ayBpbnN0YW5jZW9mIGcuZGVmYXVsdCYmIUYuaGFzKGspJiYoRi5hZGQoayksay5kaXNwYXRjaEV2ZW50KF8pKX0pfWNvbnN0IHR0PW5ldyBmLmRlZmF1bHQoIm1vdXNlbGVhdmUiKTt0dC5zZXRPcmlnaW5hbEV2ZW50KEwpLEouZm9yRWFjaCgoW18sc3RdKT0+e3R0W19dPXN0fSksWy4uLkZdLmZvckVhY2goXz0+eyQuaGFzKF8pfHwoRi5kZWxldGUoXyksXy5kaXNwYXRjaEV2ZW50KHR0KSl9KX19KX0se3Bhc3NpdmU6UCE9PSJjb250ZXh0bWVudSJ9KX0pfWZ1bmN0aW9uIHMoVCxiKXtpZihiJiZiLnN0eWxlKXtsZXR7d2lkdGg6SSxoZWlnaHQ6UCxtb2RlOkwsY29udGFpbmVyOkR9PVQ7Y29uc3R7Y2xpZW50V2lkdGg6UixjbGllbnRIZWlnaHQ6QX09RDtJPUl8fFIsUD1QfHxBLEw9PT0ic3RhdGljIj8oYi5zdHlsZS53aWR0aD1gJHtJfXB4YCxiLnN0eWxlLmhlaWdodD1gJHtQfXB4YCk6KGIuc3R5bGUudG9wPSIwIixiLnN0eWxlLmxlZnQ9IjAiLGIuc3R5bGUud2lkdGg9YCR7Un1weGAsYi5zdHlsZS5oZWlnaHQ9YCR7QX1weGAsYi5zdHlsZS50cmFuc2Zvcm09IiIsYi5zdHlsZS53ZWJraXRUcmFuc2Zvcm09IiIpfX1jb25zdCBsPVN5bWJvbCgib2Zmc2NyZWVuTGF5ZXJDb3VudCIpO2NsYXNzIEUgZXh0ZW5kcyBjLmRlZmF1bHR7Y29uc3RydWN0b3IoYj17fSl7aWYoc3VwZXIoKSwhYi5jb250YWluZXIpaWYodHlwZW9mIGkuRU5WLkNvbnRhaW5lcj09ImZ1bmN0aW9uIiliLmNvbnRhaW5lcj1uZXcgaS5FTlYuQ29udGFpbmVyKGIud2lkdGh8fDMwMCxiLmhlaWdodHx8MTUwKTtlbHNlIHRocm93IG5ldyBFcnJvcigiTm8gY29udGFpbmVyIHNwZWNpZmllZC4iKTtpZih0aGlzLmNvbnRhaW5lcj1iLmNvbnRhaW5lcix0aGlzLmNvbnRhaW5lci5zdHlsZSYmKHRoaXMuY29udGFpbmVyLnN0eWxlLm92ZXJmbG93fHwodGhpcy5jb250YWluZXIuc3R5bGUub3ZlcmZsb3c9ImhpZGRlbiIpLHRoaXMuY29udGFpbmVyLnN0eWxlLnBvc2l0aW9ufHwodGhpcy5jb250YWluZXIuc3R5bGUucG9zaXRpb249InJlbGF0aXZlIikpLHRoaXMub3B0aW9ucz1iLGIuZGlzcGxheVJhdGlvPWIuZGlzcGxheVJhdGlvfHwxLGIubW9kZT1iLm1vZGV8fCJzY2FsZSIsYi5sZWZ0PTAsYi50b3A9MCxiLmF1dG9SZXNpemU9Yi5hdXRvUmVzaXplIT09ITEsYi5hdXRvUmVzaXplKXtsZXQgSTtpZih0eXBlb2YgZ2xvYmFsVGhpczwidSI/ST1nbG9iYWxUaGlzOkk9dHlwZW9mIHdpbmRvdzwidSI/d2luZG93OnIsSS5hZGRFdmVudExpc3RlbmVyKXtjb25zdCBQPXRoaXM7SS5hZGRFdmVudExpc3RlbmVyKCJyZXNpemUiLGZ1bmN0aW9uIEwoKXt0eXBlb2YgZG9jdW1lbnQ8InUiJiZkb2N1bWVudC5jb250YWlucyhQLmNvbnRhaW5lcik/UC5yZXNpemUoKTpJLnJlbW92ZUV2ZW50TGlzdGVuZXIoInJlc2l6ZSIsTCl9KX19dGhpc1tDXT1uZXcgU2V0LHRoaXMuc2V0UmVzb2x1dGlvbihiKSxvKHRoaXMpLHRoaXNbbF09MH1nZXQgaGFzT2Zmc2NyZWVuQ2FudmFzKCl7cmV0dXJuIHRoaXNbbF0+MH1zZXQgZGlzcGxheVJhdGlvKGIpe3RoaXMub3B0aW9ucy5kaXNwbGF5UmF0aW8hPT1iJiYodGhpcy5vcHRpb25zLmRpc3BsYXlSYXRpbz1iLHRoaXMucmVzaXplKCkpfWdldCBkaXNwbGF5UmF0aW8oKXtyZXR1cm4gdGhpcy5vcHRpb25zLmRpc3BsYXlSYXRpb31zZXQgaGVpZ2h0KGIpe3RoaXMub3B0aW9ucy5oZWlnaHQhPT1iJiYodGhpcy5vcHRpb25zLmhlaWdodD1iLHRoaXMucmVzaXplKCkpfWdldCBoZWlnaHQoKXtyZXR1cm4gdGhpcy5vcHRpb25zLmhlaWdodH1zZXQgbW9kZShiKXt0aGlzLm9wdGlvbnMubW9kZSE9PWImJih0aGlzLm9wdGlvbnMubW9kZT1iLHRoaXMucmVzaXplKCkpfWdldCBtb2RlKCl7cmV0dXJuIHRoaXMub3B0aW9ucy5tb2RlfXNldCB3aWR0aChiKXt0aGlzLm9wdGlvbnMud2lkdGghPT1iJiYodGhpcy5vcHRpb25zLndpZHRoPWIsdGhpcy5yZXNpemUoKSl9Z2V0IHdpZHRoKCl7cmV0dXJuIHRoaXMub3B0aW9ucy53aWR0aH1hcHBlbmRDaGlsZChiKXshKGIgaW5zdGFuY2VvZiB1LmRlZmF1bHQpJiYhKGIgaW5zdGFuY2VvZiBhLmRlZmF1bHQpJiZNKGIpO2NvbnN0IEk9c3VwZXIuYXBwZW5kQ2hpbGQoYiksUD1iLmNhbnZhcztyZXR1cm4gYi5vZmZzY3JlZW4/dGhpc1tsXSsrOnRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKFApLHModGhpcy5vcHRpb25zLFApLGIuc2V0UmVzb2x1dGlvbih0aGlzLmdldFJlc29sdXRpb24oKSksSX1mb3JjZVVwZGF0ZSgpe3RoaXMuaGFzT2Zmc2NyZWVuQ2FudmFzJiYhdGhpcy5fcmVxdWVzdElEJiYodGhpcy5fcmVxdWVzdElEPU9iamVjdChoLnJlcXVlc3RBbmltYXRpb25GcmFtZSkoKCk9PntkZWxldGUgdGhpcy5fcmVxdWVzdElELHRoaXMucmVuZGVyKCl9KSl9aW5zZXJ0QmVmb3JlKGIsSSl7IShiIGluc3RhbmNlb2YgdS5kZWZhdWx0KSYmIShiIGluc3RhbmNlb2YgYS5kZWZhdWx0KSYmTShiKTtjb25zdCBQPXN1cGVyLmluc2VydEJlZm9yZShiLEkpLEw9Yi5jYW52YXM7aWYoIWIub2Zmc2NyZWVuKXtjb25zdCBEPW0odGhpcyxiKTt0aGlzLmNvbnRhaW5lci5pbnNlcnRCZWZvcmUoTCxEKX1yZXR1cm4gcyh0aGlzLm9wdGlvbnMsTCksYi5zZXRSZXNvbHV0aW9uKHRoaXMuZ2V0UmVzb2x1dGlvbigpKSxQfWxheWVyKGI9ImRlZmF1bHQiLEk9e30pe0k9T2JqZWN0LmFzc2lnbih7fSx0aGlzLm9wdGlvbnMsSSksSS5pZD1iO2NvbnN0IFA9dGhpcy5vcmRlcmVkQ2hpbGRyZW47Zm9yKGxldCBSPTA7UjxQLmxlbmd0aDtSKyspaWYoUFtSXS5pZD09PWIpcmV0dXJuIFBbUl07Y29uc3QgTD1JLndvcmtlcjtsZXQgRDtyZXR1cm4gTD9EPW5ldyBhLmRlZmF1bHQoSSk6RD1uZXcgdS5kZWZhdWx0KEkpLHRoaXMuYXBwZW5kQ2hpbGQoRCksRH1hc3luYyBwcmVsb2FkKC4uLmIpe2NvbnN0IEk9W10sUD1bXSxMPVtdO2ZvcihsZXQgRD0wO0Q8Yi5sZW5ndGg7RCsrKXtjb25zdCBSPWJbRF07bGV0IEE7aWYodHlwZW9mIFI9PSJzdHJpbmciKUE9T2JqZWN0KHYubG9hZFRleHR1cmUpKFIpO2Vsc2UgaWYoQXJyYXkuaXNBcnJheShSKSlBPU9iamVjdCh2LmxvYWRGcmFtZXMpKC4uLlIpO2Vsc2V7Y29uc3R7aWQ6aixzcmM6R309UjtBPU9iamVjdCh2LmxvYWRUZXh0dXJlKShHLGopfUEgaW5zdGFuY2VvZiBQcm9taXNlfHwoQT1Qcm9taXNlLnJlc29sdmUoQSkpLFAucHVzaChBLnRoZW4oaj0+e0kucHVzaChqKSxMW0RdPWo7Y29uc3QgRz1uZXcgZi5kZWZhdWx0KHt0eXBlOiJwcmVsb2FkIixkZXRhaWw6e2N1cnJlbnQ6aixsb2FkZWQ6SSxyZXNvdXJjZXM6Yn19KTt0aGlzLmRpc3BhdGNoRXZlbnQoRyl9KSl9cmV0dXJuIGF3YWl0IFByb21pc2UuYWxsKFApLEx9cmVtb3ZlQ2hpbGQoYil7Y29uc3QgST1zdXBlci5yZW1vdmVDaGlsZChiKTtpZihJKXtiLl9wcmVwYXJlUmVuZGVyRmluaXNoZWQmJmIuX3ByZXBhcmVSZW5kZXJGaW5pc2hlZCgpO2NvbnN0IFA9Yi5jYW52YXM7UCYmUC5yZW1vdmUmJlAucmVtb3ZlKCksYi5vZmZzY3JlZW4mJnRoaXNbbF0tLX1yZXR1cm4gSX1yZW5kZXIoKXtjb25zdCBiPXRoaXMub3JkZXJlZENoaWxkcmVuO2xldCBJPW51bGw7Y29uc3QgUD1bXTtmb3IobGV0IEw9MDtMPGIubGVuZ3RoO0wrKyl7Y29uc3QgRD1iW0xdLFI9UC5sZW5ndGg+MDtpZihEIGluc3RhbmNlb2YgdS5kZWZhdWx0JiYhRC5vZmZzY3JlZW4paWYoIUQuYXV0b1JlbmRlcilSJiYoY29uc29sZS53YXJuKCJTb21lIG9mZnNjcmVlbiBjYW52YXMgd2lsbCBub3QgYmUgcmVuZGVyZWQuIiksUC5sZW5ndGg9MCk7ZWxzZSBpZihJPUQsUil7RC5yZW5kZXJlci5jbGVhcigpO2ZvcihsZXQgQT0wO0E8UC5sZW5ndGg7QSsrKXtjb25zdCBqPVBbQV07ai5yZW5kZXIoKSx5KEQsail9UC5sZW5ndGg9MCxELnJlbmRlcih7Y2xlYXI6ITF9KX1lbHNlIEQucHJlcGFyZVJlbmRlciYmRC5yZW5kZXIoKTtlbHNlIEQub2Zmc2NyZWVuP0k/KEQucHJlcGFyZVJlbmRlciYmRC5yZW5kZXIoKSx5KEksRCkpOlAucHVzaChEKTpEIGluc3RhbmNlb2YgYS5kZWZhdWx0JiZSJiYoY29uc29sZS53YXJuKCJTb21lIG9mZnNjcmVlbiBjYW52YXMgd2lsbCBub3QgYmUgcmVuZGVyZWQuIiksUC5sZW5ndGg9MCl9fXJlcGxhY2VDaGlsZChiLEkpe2NvbnN0IFA9c3VwZXIucmVwbGFjZUNoaWxkKGIsSSk7SS5jYW52YXMucmVtb3ZlJiZJLmNhbnZhcy5yZW1vdmUoKSxJLm9mZnNjcmVlbiYmdGhpc1tsXS0tO2NvbnN0IEw9Yi5jYW52YXM7aWYoIWIub2Zmc2NyZWVuKXtjb25zdCBEPW0odGhpcyxiKTt0aGlzLmNvbnRhaW5lci5pbnNlcnRCZWZvcmUoTCxEKX1yZXR1cm4gcyh0aGlzLm9wdGlvbnMsTCksYi5zZXRSZXNvbHV0aW9uKHRoaXMuZ2V0UmVzb2x1dGlvbigpKSxQfXJlc2l6ZSgpe2NvbnN0IGI9dGhpcy5vcHRpb25zO3RoaXMuY2hpbGRyZW4uZm9yRWFjaChJPT57cyhiLEkuY2FudmFzKX0pLHRoaXMuc2V0UmVzb2x1dGlvbihiKSx0aGlzLmRpc3BhdGNoRXZlbnQoe3R5cGU6InJlc2l6ZSJ9KX1zZXRSZXNvbHV0aW9uKHt3aWR0aDpiLGhlaWdodDpJfT17fSl7Y29uc3QgUD10aGlzLmNvbnRhaW5lcix7Y2xpZW50V2lkdGg6TCxjbGllbnRIZWlnaHQ6RH09UDsoYj09bnVsbHx8ST09bnVsbCkmJihiPWI/P0wsST1JPz9EKTtjb25zdHttb2RlOlIsZGlzcGxheVJhdGlvOkF9PXRoaXMub3B0aW9ucztpZihiKj1BLEkqPUEsdGhpcy5vcHRpb25zLmxlZnQ9MCx0aGlzLm9wdGlvbnMudG9wPTAsUj09PSJzdGlja3lIZWlnaHQifHxSPT09InN0aWNreUxlZnQifHxSPT09InN0aWNreVJpZ2h0Iil7Y29uc3Qgaj1iO2I9TCpJL0QsUj09PSJzdGlja3lIZWlnaHQiJiYodGhpcy5vcHRpb25zLmxlZnQ9LjUqKGItaikpLFI9PT0ic3RpY2t5UmlnaHQiJiYodGhpcy5vcHRpb25zLmxlZnQ9Yi1qKX1lbHNlIGlmKFI9PT0ic3RpY2t5V2lkdGgifHxSPT09InN0aWNreVRvcCJ8fFI9PT0ic3RpY2t5Qm90dG9tIil7Y29uc3Qgaj1JO0k9RCpiL0wsUj09PSJzdGlja3lXaWR0aCImJih0aGlzLm9wdGlvbnMudG9wPS41KihJLWopKSxSPT09InN0aWNreUJvdHRvbSImJih0aGlzLm9wdGlvbnMudG9wPUktail9c3VwZXIuc2V0UmVzb2x1dGlvbih7d2lkdGg6YixoZWlnaHQ6SX0pfXNuYXBzaG90KHtvZmZzY3JlZW46Yj0hMSxsYXllcnM6SX09e30pe2NvbnN0IFA9Yj8ic25hcHNob3RPZmZTY3JlZW5DYW52YXMiOiJzbmFwc2hvdENhbnZhcyIse3dpZHRoOkwsaGVpZ2h0OkR9PXRoaXMuZ2V0UmVzb2x1dGlvbigpO3RoaXNbUF09dGhpc1tQXXx8aS5FTlYuY3JlYXRlQ2FudmFzKEwsRCx7b2Zmc2NyZWVuOmJ9KTtjb25zdCBSPXRoaXNbUF0uZ2V0Q29udGV4dCgiMmQiKTtJPUl8fHRoaXMub3JkZXJlZENoaWxkcmVuLHRoaXNbUF0ud2lkdGg9TCx0aGlzW1BdLmhlaWdodD1EO2ZvcihsZXQgQT0wO0E8SS5sZW5ndGg7QSsrKXtjb25zdCBqPUlbQV07aWYoIWoub3B0aW9ucy5pZ25vcmVTbmFwc2hvdCl7ai5yZW5kZXImJmoucmVuZGVyKCk7Y29uc3QgRz1qLmNhbnZhcztHJiZHIT09aiYmUi5kcmF3SW1hZ2UoRywwLDAsTCxEKX19cmV0dXJuIHRoaXNbUF19fXR5cGVvZiBkb2N1bWVudDwidSImJihFLnByb3RvdHlwZS5sYXllcjNkPWZ1bmN0aW9uKFQsYj17fSl7Y29uc3QgST1iLnVybHx8Imh0dHBzOi8vdW5wa2cuY29tL3Nwcml0ZS1leHRlbmQtM2QvZGlzdC9zcHJpdGUtZXh0ZW5kLTNkLm1pbi5qcyI7cmV0dXJuIG5ldyBQcm9taXNlKChQLEwpPT57Y29uc3QgRD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJzY3JpcHQiKTtELmFzeW5jPSExLEQuc3JjPUksRC5vbmxvYWQ9KCk9Pnt0cnl7UCh0aGlzLmxheWVyM2QoVCxiKSl9Y2F0Y2goUil7TChSKX19LGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZChEKX0pfSkscC5kZWZhdWx0LnJlZ2lzdGVyTm9kZShFLCJzY2VuZSIpfSkuY2FsbCh0aGlzLHQoMjIpKX0sZnVuY3Rpb24oUyxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gaX0pO3ZhciByPXQoMjE0KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gaShoLHtvZmZzZXRUb3A6Zz0wLG9mZnNldExlZnQ6dT0wLGRpc3BsYXlSYXRpbzphPTF9PXt9KXtsZXQgYyx4O2NvbnN0IGY9W10se2xlZnQ6dix0b3A6cCx3aWR0aDpDLGhlaWdodDpNfT1oLnRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxtPWgudGFyZ2V0LndpZHRoLHk9aC50YXJnZXQuaGVpZ2h0LG49aC5jaGFuZ2VkVG91Y2hlc3x8W2hdO2ZvcihsZXQgcz0wO3M8bi5sZW5ndGg7cysrKXtjb25zdCBsPW5bc10sRT1sLmlkZW50aWZpZXIse2NsaWVudFg6VCxjbGllbnRZOmJ9PWw7VCE9bnVsbCYmYiE9bnVsbCYmZi5wdXNoKHt4Ok1hdGgucm91bmQoKFR8MCktdikseTpNYXRoLnJvdW5kKChifDApLXApLGlkZW50aWZpZXI6RX0pfWYubGVuZ3RoPD0wJiZmLnB1c2goe3g6Yyx5Onh9KTtjb25zdCBvPVtdO3JldHVybiBmLmZvckVhY2gocz0+e3MueCE9bnVsbCYmcy55IT1udWxsJiYoYz0ocy54Km0vQy11KS9hLHg9KHMueSp5L00tZykvYSk7Y29uc3QgbD1uZXcgci5kZWZhdWx0KGgpO09iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGwse2xheWVyWDp7dmFsdWU6Yyxjb25maWd1cmFibGU6ITB9LGxheWVyWTp7dmFsdWU6eCxjb25maWd1cmFibGU6ITB9LG9yaWdpbmFsWDp7dmFsdWU6cy54fSxvcmlnaW5hbFk6e3ZhbHVlOnMueX0seDp7dmFsdWU6Yyxjb25maWd1cmFibGU6ITB9LHk6e3ZhbHVlOngsY29uZmlndXJhYmxlOiEwfSxpZGVudGlmaWVyOnt2YWx1ZTpzLmlkZW50aWZpZXJ9fSksby5wdXNoKGwpfSksb319XSk7YnQudmVyc2lvbixidC5BcmMsYnQuQmxvY2ssYnQuQ2xvdWQsYnQuQ29sb3IsYnQuRWxsaXBzZSxidC5HcmFkaWVudDtjb25zdCBvZT1idC5Hcm91cDtidC5MYWJlbCxidC5MYXllcixidC5MYXllcldvcmtlcixidC5Ob2RlLGJ0LlBhcmFsbGVsO2NvbnN0IGFlPWJ0LlBhdGg7YnQuUG9seWxpbmU7Y29uc3QgbWU9YnQuUmVjdDtidC5SZWd1bGFyLGJ0LlJpbmc7Y29uc3QgT2U9YnQuU2NlbmU7YnQuU3ByaXRlLGJ0LlNwcml0ZVN2ZyxidC5TdGFyLGJ0LlRyaWFuZ2xlLGJ0LmhlbHBlcnMsYnQuY3JlYXRlRWxlbWVudCxidC5pc1Nwcml0ZU5vZGUsYnQucmVnaXN0ZXJOb2RlLGJ0LnJlcXVlc3RBbmltYXRpb25GcmFtZSxidC5jYW5jZWxBbmltYXRpb25GcmFtZSxidC5FTlY7Y29uc3QgUGU9e2xpbmVhcjpTPT5TLGVhc2VJblF1YWQ6Uz0+UypTLGVhc2VPdXRRdWFkOlM9PlMqKDItUyksZWFzZUluT3V0UXVhZDpTPT5TPC41PzIqUypTOi0xKyg0LTIqUykqUyxlYXNlSW5DdWJpYzpTPT5TKlMqUyxlYXNlT3V0Q3ViaWM6Uz0+LS1TKlMqUysxLGVhc2VJbk91dEN1YmljOlM9PlM8LjU/NCpTKlMqUzooUy0xKSooMipTLTIpKigyKlMtMikrMSxlYXNlSW5RdWFydDpTPT5TKlMqUypTLGVhc2VPdXRRdWFydDpTPT4xLSAtLVMqUypTKlMsZWFzZUluT3V0UXVhcnQ6Uz0+UzwuNT84KlMqUypTKlM6MS04Ki0tUypTKlMqUyxlYXNlSW5RdWludDpTPT5TKlMqUypTKlMsZWFzZU91dFF1aW50OlM9PjErLS1TKlMqUypTKlMsZWFzZUluT3V0UXVpbnQ6Uz0+UzwuNT8xNipTKlMqUypTKlM6MSsxNiotLVMqUypTKlMqUyxlYXNlSW5TaW5lOlM9PjEtTWF0aC5jb3MoUypNYXRoLlBJLzIpLGVhc2VPdXRTaW5lOlM9Pk1hdGguc2luKFMqTWF0aC5QSS8yKSxlYXNlSW5PdXRTaW5lOlM9Pi0oTWF0aC5jb3MoTWF0aC5QSSpTKS0xKS8yLGVhc2VJbkV4cG86Uz0+Uzw9MD8wOk1hdGgucG93KDIsMTAqUy0xMCksZWFzZU91dEV4cG86Uz0+Uz49MT8xOjEtTWF0aC5wb3coMiwtMTAqUyksZWFzZUluT3V0RXhwbzpTPT5TPD0wPzA6Uz49MT8xOlM8LjU/TWF0aC5wb3coMiwyMCpTLTEwKS8yOigyLU1hdGgucG93KDIsLTIwKlMrMTApKS8yfTtjbGFzcyBodHtjb25zdHJ1Y3RvcihlPTAsdD0wLHI9MSl7T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIngiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTplfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInkiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp0fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInoiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpyfSl9Z2V0IFhZKCl7cmV0dXJuW3RoaXMueCx0aGlzLnldfXNldHooZSl7cmV0dXJuIHRoaXMuej1lLHRoaXN9c2V0WFkoZT10aGlzLngsdD10aGlzLnkpe3JldHVybiB0aGlzLng9ZSx0aGlzLnk9dCx0aGlzfXNldChlPXRoaXMueCx0PXRoaXMueSxyPXRoaXMueil7cmV0dXJuIHRoaXMueD1lLHRoaXMueT10LHRoaXMuej1yLHRoaXN9c2V0VG8oe3g6ZT0wLHk6dD0wLHo6cj0xfSl7cmV0dXJuIHRoaXMueD1lLHRoaXMueT10LHRoaXMuej1yLHRoaXN9cm90KGUpe2lmKGU9PT0wKXJldHVybiB0aGlzO2NvbnN0e3g6dCx5OnJ9PXRoaXMsaT1NYXRoLnNpbihlKSxoPU1hdGguY29zKGUpO3JldHVybiB0aGlzLng9dCpoLXIqaSx0aGlzLnk9dCppK3IqaCx0aGlzfXJvdFdpdGgoZSx0KXtpZih0PT09MClyZXR1cm4gdGhpcztjb25zdCByPXRoaXMueC1lLngsaT10aGlzLnktZS55LGg9TWF0aC5zaW4odCksZz1NYXRoLmNvcyh0KTtyZXR1cm4gdGhpcy54PWUueCsocipnLWkqaCksdGhpcy55PWUueSsocipoK2kqZyksdGhpc31jbG9uZSgpe2NvbnN0e3g6ZSx5OnQsejpyfT10aGlzO3JldHVybiBuZXcgaHQoZSx0LHIpfXN1YihlKXtyZXR1cm4gdGhpcy54LT1lLngsdGhpcy55LT1lLnksdGhpc31zdWJYWShlLHQpe3JldHVybiB0aGlzLngtPWUsdGhpcy55LT10LHRoaXN9c3ViU2NhbGFyKGUpe3JldHVybiB0aGlzLngtPWUsdGhpcy55LT1lLHRoaXN9YWRkKGUpe3JldHVybiB0aGlzLngrPWUueCx0aGlzLnkrPWUueSx0aGlzfWFkZFhZKGUsdCl7cmV0dXJuIHRoaXMueCs9ZSx0aGlzLnkrPXQsdGhpc31hZGRTY2FsYXIoZSl7cmV0dXJuIHRoaXMueCs9ZSx0aGlzLnkrPWUsdGhpc31jbGFtcChlLHQpe3JldHVybiB0aGlzLng9TWF0aC5tYXgodGhpcy54LGUpLHRoaXMueT1NYXRoLm1heCh0aGlzLnksZSksdCE9PXZvaWQgMCYmKHRoaXMueD1NYXRoLm1pbih0aGlzLngsdCksdGhpcy55PU1hdGgubWluKHRoaXMueSx0KSksdGhpc31kaXYoZSl7cmV0dXJuIHRoaXMueC89ZSx0aGlzLnkvPWUsdGhpc31kaXZWKGUpe3JldHVybiB0aGlzLngvPWUueCx0aGlzLnkvPWUueSx0aGlzfW11bChlKXtyZXR1cm4gdGhpcy54Kj1lLHRoaXMueSo9ZSx0aGlzfW11bFYoZSl7cmV0dXJuIHRoaXMueCo9ZS54LHRoaXMueSo9ZS55LHRoaXN9YWJzKCl7cmV0dXJuIHRoaXMueD1NYXRoLmFicyh0aGlzLngpLHRoaXMueT1NYXRoLmFicyh0aGlzLnkpLHRoaXN9bnVkZ2UoZSx0KXtjb25zdCByPWh0LlRhbihlLHRoaXMpO3JldHVybiB0aGlzLmFkZChyLm11bCh0KSl9bmVnKCl7cmV0dXJuIHRoaXMueCo9LTEsdGhpcy55Kj0tMSx0aGlzfWNyb3NzKGUpe3JldHVybiB0aGlzLng9dGhpcy55KmUuei10aGlzLnoqZS55LHRoaXMueT10aGlzLnoqZS54LXRoaXMueCplLnosdGhpc31kcHIoZSl7cmV0dXJuIGh0LkRwcih0aGlzLGUpfWNwcihlKXtyZXR1cm4gaHQuQ3ByKHRoaXMsZSl9bGVuMigpe3JldHVybiBodC5MZW4yKHRoaXMpfWxlbigpe3JldHVybiBodC5MZW4odGhpcyl9cHJ5KGUpe3JldHVybiBodC5QcnkodGhpcyxlKX1wZXIoKXtjb25zdHt4OmUseTp0fT10aGlzO3JldHVybiB0aGlzLng9dCx0aGlzLnk9LWUsdGhpc311bmkoKXtyZXR1cm4gaHQuVW5pKHRoaXMpfXRhbihlKXtyZXR1cm4gaHQuVGFuKHRoaXMsZSl9ZGlzdChlKXtyZXR1cm4gaHQuRGlzdCh0aGlzLGUpfWRpc3RhbmNlVG9MaW5lU2VnbWVudChlLHQpe3JldHVybiBodC5EaXN0YW5jZVRvTGluZVNlZ21lbnQoZSx0LHRoaXMpfXNsb3BlKGUpe3JldHVybiBodC5TbG9wZSh0aGlzLGUpfXNuYXBUb0dyaWQoZSl7cmV0dXJuIHRoaXMueD1NYXRoLnJvdW5kKHRoaXMueC9lKSplLHRoaXMueT1NYXRoLnJvdW5kKHRoaXMueS9lKSplLHRoaXN9YW5nbGUoZSl7cmV0dXJuIGh0LkFuZ2xlKHRoaXMsZSl9dG9BbmdsZSgpe3JldHVybiBodC5Ub0FuZ2xlKHRoaXMpfWxycChlLHQpe3JldHVybiB0aGlzLng9dGhpcy54KyhlLngtdGhpcy54KSp0LHRoaXMueT10aGlzLnkrKGUueS10aGlzLnkpKnQsdGhpc31lcXVhbHMoZSx0KXtyZXR1cm4gaHQuRXF1YWxzKHRoaXMsZSx0KX1lcXVhbHNYWShlLHQpe3JldHVybiBodC5FcXVhbHNYWSh0aGlzLGUsdCl9bm9ybSgpe2NvbnN0IGU9dGhpcy5sZW4oKTtyZXR1cm4gdGhpcy54PWU9PT0wPzA6dGhpcy54L2UsdGhpcy55PWU9PT0wPzA6dGhpcy55L2UsdGhpc310b0ZpeGVkKCl7cmV0dXJuIGh0LlRvRml4ZWQodGhpcyl9dG9TdHJpbmcoKXtyZXR1cm4gaHQuVG9TdHJpbmcoaHQuVG9GaXhlZCh0aGlzKSl9dG9Kc29uKCl7cmV0dXJuIGh0LlRvSnNvbih0aGlzKX10b0FycmF5KCl7cmV0dXJuIGh0LlRvQXJyYXkodGhpcyl9c3RhdGljIEFkZChlLHQpe3JldHVybiBuZXcgaHQoZS54K3QueCxlLnkrdC55KX1zdGF0aWMgQWRkWFkoZSx0LHIpe3JldHVybiBuZXcgaHQoZS54K3QsZS55K3IpfXN0YXRpYyBTdWIoZSx0KXtyZXR1cm4gbmV3IGh0KGUueC10LngsZS55LXQueSl9c3RhdGljIFN1YlhZKGUsdCxyKXtyZXR1cm4gbmV3IGh0KGUueC10LGUueS1yKX1zdGF0aWMgQWRkU2NhbGFyKGUsdCl7cmV0dXJuIG5ldyBodChlLngrdCxlLnkrdCl9c3RhdGljIFN1YlNjYWxhcihlLHQpe3JldHVybiBuZXcgaHQoZS54LXQsZS55LXQpfXN0YXRpYyBEaXYoZSx0KXtyZXR1cm4gbmV3IGh0KGUueC90LGUueS90KX1zdGF0aWMgTXVsKGUsdCl7cmV0dXJuIG5ldyBodChlLngqdCxlLnkqdCl9c3RhdGljIERpdlYoZSx0KXtyZXR1cm4gbmV3IGh0KGUueC90LngsZS55L3QueSl9c3RhdGljIE11bFYoZSx0KXtyZXR1cm4gbmV3IGh0KGUueCp0LngsZS55KnQueSl9c3RhdGljIE5lZyhlKXtyZXR1cm4gbmV3IGh0KC1lLngsLWUueSl9c3RhdGljIFBlcihlKXtyZXR1cm4gbmV3IGh0KGUueSwtZS54KX1zdGF0aWMgRGlzdDIoZSx0KXtyZXR1cm4gaHQuU3ViKGUsdCkubGVuMigpfXN0YXRpYyBBYnMoZSl7cmV0dXJuIG5ldyBodChNYXRoLmFicyhlLngpLE1hdGguYWJzKGUueSkpfXN0YXRpYyBEaXN0KGUsdCl7cmV0dXJuIE1hdGguaHlwb3QoZS55LXQueSxlLngtdC54KX1zdGF0aWMgRHByKGUsdCl7cmV0dXJuIGUueCp0LngrZS55KnQueX1zdGF0aWMgQ3Jvc3MoZSx0KXtyZXR1cm4gbmV3IGh0KGUueSp0LnotZS56KnQueSxlLnoqdC54LWUueCp0LnopfXN0YXRpYyBDcHIoZSx0KXtyZXR1cm4gZS54KnQueS10LngqZS55fXN0YXRpYyBMZW4yKGUpe3JldHVybiBlLngqZS54K2UueSplLnl9c3RhdGljIExlbihlKXtyZXR1cm4gTWF0aC5oeXBvdChlLngsZS55KX1zdGF0aWMgUHJ5KGUsdCl7cmV0dXJuIGh0LkRwcihlLHQpL2h0Lkxlbih0KX1zdGF0aWMgVW5pKGUpe3JldHVybiBodC5EaXYoZSxodC5MZW4oZSkpfXN0YXRpYyBUYW4oZSx0KXtyZXR1cm4gaHQuVW5pKGh0LlN1YihlLHQpKX1zdGF0aWMgTWluKGUsdCl7cmV0dXJuIG5ldyBodChNYXRoLm1pbihlLngsdC54KSxNYXRoLm1pbihlLnksdC55KSl9c3RhdGljIE1heChlLHQpe3JldHVybiBuZXcgaHQoTWF0aC5tYXgoZS54LHQueCksTWF0aC5tYXgoZS55LHQueSkpfXN0YXRpYyBGcm9tKGUpe3JldHVybiBuZXcgaHQoKS5hZGQoZSl9c3RhdGljIEZyb21BcnJheShlKXtyZXR1cm4gbmV3IGh0KGVbMF0sZVsxXSl9c3RhdGljIFJvdChlLHQ9MCl7Y29uc3Qgcj1NYXRoLnNpbih0KSxpPU1hdGguY29zKHQpO3JldHVybiBuZXcgaHQoZS54KmktZS55KnIsZS54KnIrZS55KmkpfXN0YXRpYyBSb3RXaXRoKGUsdCxyKXtjb25zdCBpPWUueC10LngsaD1lLnktdC55LGc9TWF0aC5zaW4ociksdT1NYXRoLmNvcyhyKTtyZXR1cm4gbmV3IGh0KHQueCsoaSp1LWgqZyksdC55KyhpKmcraCp1KSl9c3RhdGljIE5lYXJlc3RQb2ludE9uTGluZVRocm91Z2hQb2ludChlLHQscil7cmV0dXJuIGh0Lk11bCh0LGh0LlN1YihyLGUpLnByeSh0KSkuYWRkKGUpfXN0YXRpYyBOZWFyZXN0UG9pbnRPbkxpbmVTZWdtZW50KGUsdCxyLGk9ITApe2NvbnN0IGg9aHQuVGFuKHQsZSksZz1odC5BZGQoZSxodC5NdWwoaCxodC5TdWIocixlKS5wcnkoaCkpKTtpZihpKXtpZihnLng8TWF0aC5taW4oZS54LHQueCkpcmV0dXJuIGh0LkNhc3QoZS54PHQueD9lOnQpO2lmKGcueD5NYXRoLm1heChlLngsdC54KSlyZXR1cm4gaHQuQ2FzdChlLng+dC54P2U6dCk7aWYoZy55PE1hdGgubWluKGUueSx0LnkpKXJldHVybiBodC5DYXN0KGUueTx0Lnk/ZTp0KTtpZihnLnk+TWF0aC5tYXgoZS55LHQueSkpcmV0dXJuIGh0LkNhc3QoZS55PnQueT9lOnQpfXJldHVybiBnfXN0YXRpYyBEaXN0YW5jZVRvTGluZVRocm91Z2hQb2ludChlLHQscil7cmV0dXJuIGh0LkRpc3QocixodC5OZWFyZXN0UG9pbnRPbkxpbmVUaHJvdWdoUG9pbnQoZSx0LHIpKX1zdGF0aWMgRGlzdGFuY2VUb0xpbmVTZWdtZW50KGUsdCxyLGk9ITApe3JldHVybiBodC5EaXN0KHIsaHQuTmVhcmVzdFBvaW50T25MaW5lU2VnbWVudChlLHQscixpKSl9c3RhdGljIFNuYXAoZSx0PTEpe3JldHVybiBuZXcgaHQoTWF0aC5yb3VuZChlLngvdCkqdCxNYXRoLnJvdW5kKGUueS90KSp0KX1zdGF0aWMgQ2FzdChlKXtyZXR1cm4gZSBpbnN0YW5jZW9mIGh0P2U6aHQuRnJvbShlKX1zdGF0aWMgU2xvcGUoZSx0KXtyZXR1cm4gZS54PT09dC55P05hTjooZS55LXQueSkvKGUueC10LngpfXN0YXRpYyBBbmdsZShlLHQpe3JldHVybiBNYXRoLmF0YW4yKHQueS1lLnksdC54LWUueCl9c3RhdGljIExycChlLHQscil7cmV0dXJuIGh0LlN1Yih0LGUpLm11bChyKS5hZGQoZSl9c3RhdGljIE1lZChlLHQpe3JldHVybiBuZXcgaHQoKGUueCt0LngpLzIsKGUueSt0LnkpLzIpfXN0YXRpYyBFcXVhbHMoZSx0LHI9MWUtNCl7cmV0dXJuIE1hdGguYWJzKGUueC10LngpPHImJk1hdGguYWJzKGUueS10LnkpPHJ9c3RhdGljIEVxdWFsc1hZKGUsdCxyKXtyZXR1cm4gZS54PT09dCYmZS55PT09cn1zdGF0aWMgRXF1YWxzWFlaKGUsdCxyPTFlLTQpe3JldHVybiBodC5FcXVhbHMoZSx0LHIpJiZNYXRoLmFicygoZS56fHwwKS0odC56fHwwKSk8cn1zdGF0aWMgQ2xvY2t3aXNlKGUsdCxyKXtyZXR1cm4oci54LWUueCkqKHQueS1lLnkpLSh0LngtZS54KSooci55LWUueSk8MH1zdGF0aWMgUmVzY2FsZShlLHQpe2NvbnN0IHI9aHQuTGVuKGUpO3JldHVybiBuZXcgaHQodCplLngvcix0KmUueS9yKX1zdGF0aWMgU2NhbGVXaXRoT3JpZ2luKGUsdCxyKXtyZXR1cm4gaHQuU3ViKGUscikubXVsKHQpLmFkZChyKX1zdGF0aWMgU2NhbGVXT3JpZ2luKGUsdCxyKXtyZXR1cm4gaHQuU3ViKGUscikubXVsVih0KS5hZGQocil9c3RhdGljIFRvRml4ZWQoZSx0PTIpe3JldHVybiBuZXcgaHQoK2UueC50b0ZpeGVkKHQpLCtlLnkudG9GaXhlZCh0KSwrZS56LnRvRml4ZWQodCkpfXN0YXRpYyBOdWRnZShlLHQscil7cmV0dXJuIGh0LkFkZChlLGh0LlRhbih0LGUpLm11bChyKSl9c3RhdGljIFRvU3RyaW5nKGUpe3JldHVybmAke2UueH0sICR7ZS55fWB9c3RhdGljIFRvQW5nbGUoZSl7bGV0IHQ9TWF0aC5hdGFuMihlLnksZS54KTtyZXR1cm4gdDwwJiYodCs9TWF0aC5QSSoyKSx0fXN0YXRpYyBGcm9tQW5nbGUoZSx0PTEpe3JldHVybiBuZXcgaHQoTWF0aC5jb3MoZSkqdCxNYXRoLnNpbihlKSp0KX1zdGF0aWMgVG9BcnJheShlKXtyZXR1cm5bZS54LGUueSxlLnpdfXN0YXRpYyBUb0pzb24oZSl7Y29uc3R7eDp0LHk6cix6Oml9PWU7cmV0dXJue3g6dCx5OnIsejppfX1zdGF0aWMgQXZlcmFnZShlKXtjb25zdCB0PWUubGVuZ3RoLHI9bmV3IGh0KDAsMCk7Zm9yKGxldCBpPTA7aTx0O2krKylyLmFkZChlW2ldKTtyZXR1cm4gci5kaXYodCl9c3RhdGljIENsYW1wKGUsdCxyKXtyZXR1cm4gcj09PXZvaWQgMD9uZXcgaHQoTWF0aC5taW4oTWF0aC5tYXgoZS54LHQpKSxNYXRoLm1pbihNYXRoLm1heChlLnksdCkpKTpuZXcgaHQoTWF0aC5taW4oTWF0aC5tYXgoZS54LHQpLHIpLE1hdGgubWluKE1hdGgubWF4KGUueSx0KSxyKSl9c3RhdGljIFBvaW50c0JldHdlZW4oZSx0LHI9Nil7Y29uc3QgaT1bXTtmb3IobGV0IGg9MDtoPHI7aCsrKXtjb25zdCBnPVBlLmVhc2VJblF1YWQoaC8oci0xKSksdT1odC5McnAoZSx0LGcpO3Uuej1NYXRoLm1pbigxLC41K01hdGguYWJzKC41LVRlKGcpKSouNjUpLGkucHVzaCh1KX1yZXR1cm4gaX1zdGF0aWMgU25hcFRvR3JpZChlLHQ9OCl7cmV0dXJuIG5ldyBodChNYXRoLnJvdW5kKGUueC90KSp0LE1hdGgucm91bmQoZS55L3QpKnQpfX1jb25zdCBUZT1TPT5TPC41PzIqUypTOi0xKyg0LTIqUykqUztjbGFzcyBMdCBleHRlbmRzIGh0e2NvbnN0cnVjdG9yKGU9MCx0PTAscj0wLGk9e3g6MCx5OjB9LGg9MCxnPTApe3N1cGVyKGUsdCxyKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywieCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOmV9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywieSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnR9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywieiIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnJ9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidiIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOml9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOmh9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiYSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOmd9KX1nZXQgdGltZXN0YW1wKCl7cmV0dXJuIHRoaXMudH1nZXQgcHJlc3N1cmUoKXtyZXR1cm4gdGhpcy56fWdldCBhbmdsZU51bSgpe3JldHVybiB0aGlzLmF9Z2V0IFhZKCl7cmV0dXJuW3RoaXMueCx0aGlzLnldfXNldEEoZSl7dGhpcy5hPWV9c2V0VChlKXt0aGlzLnQ9ZX1zZXR2KGUpe3JldHVybiB0aGlzLnY9e3g6ZS54LHk6ZS55fSx0aGlzfXNldChlPXRoaXMueCx0PXRoaXMueSxyPXRoaXMueixpPXRoaXMudixoPXRoaXMudCxnPXRoaXMuYSl7cmV0dXJuIHRoaXMueD1lLHRoaXMueT10LHRoaXMuej1yLHRoaXMudj1pLHRoaXMudD1oLHRoaXMuYT1nLHRoaXN9Y2xvbmUoKXtjb25zdHt4OmUseTp0LHo6cix2OmksdDpoLGE6Z309dGhpcyx1PXt4OmkueCx5OmkueX07cmV0dXJuIG5ldyBMdChlLHQscix1LGgsZyl9ZGlzdGFuY2UoZSl7cmV0dXJuIEx0LkdldERpc3RhbmNlKHRoaXMsZSl9aXNOZWFyKGUsdCl7cmV0dXJuIEx0LklzTmVhcih0aGlzLGUsdCl9Z2V0QW5nbGVCeVBvaW50cyhlLHQpe3JldHVybiBMdC5HZXRBbmdsZUJ5UG9pbnRzKGUsdGhpcyx0KX1zdGF0aWMgU3ViKGUsdCl7cmV0dXJuIG5ldyBMdChlLngtdC54LGUueS10LnkpfXN0YXRpYyBBZGQoZSx0KXtyZXR1cm4gbmV3IEx0KGUueCt0LngsZS55K3QueSl9c3RhdGljIEdldERpc3RhbmNlKGUsdCl7cmV0dXJuIEx0LkxlbihlLmNsb25lKCkuc3ViKHQpKX1zdGF0aWMgR2V0QW5nbGVCeVBvaW50cyhlLHQscil7Y29uc3QgaT10LngtZS54LGg9ci54LXQueCxnPXQueS1lLnksdT1yLnktdC55O2xldCBhPTA7Y29uc3QgYz1NYXRoLnNxcnQoaSppK2cqZykseD1NYXRoLnNxcnQoaCpoK3UqdSk7aWYoYyYmeCl7Y29uc3QgZj1pKmgrZyp1O2E9TWF0aC5hY29zKGYvKGMqeCkpLGE9YS9NYXRoLlBJKjE4MDtsZXQgdj1pKnUtZypoO3Y9dj4wPzE6LTEsYT0xODArdiphfXJldHVybiBhfXN0YXRpYyBJc05lYXIoZSx0LHIpe3JldHVybiBMdC5MZW4oZS5jbG9uZSgpLnN1Yih0KSk8cn1zdGF0aWMgUm90V2l0aChlLHQscixpPTIpe2NvbnN0IGg9ZS54LXQueCxnPWUueS10LnksdT1NYXRoLnNpbihyKSxhPU1hdGguY29zKHIpLGM9TWF0aC5wb3coMTAsaSkseD1NYXRoLmZsb29yKCh0LngrKGgqYS1nKnUpKSpjKS9jLGY9TWF0aC5mbG9vcigodC55KyhoKnUrZyphKSkqYykvYztyZXR1cm4gbmV3IEx0KHgsZil9c3RhdGljIEdldERvdFN0cm9rZShlLHQscj0xNil7Y29uc3QgaT1uZXcgaHQoMSwxKSxoPU1hdGguUEkrLjAwMSxnPUx0LkFkZChlLEx0LlN1YihlLGkpLnVuaSgpLnBlcigpLm11bCgtdCkpLHU9W107Zm9yKGxldCBhPTEvcixjPWE7Yzw9MTtjKz1hKXUucHVzaChMdC5Sb3RXaXRoKGcsZSxoKjIqYykpO3JldHVybiB1fXN0YXRpYyBHZXRTZW1pY2lyY2xlU3Ryb2tlKGUsdCxyPS0xLGk9OCl7Y29uc3QgaD1yKihNYXRoLlBJKy4wMDEpLGc9W107Zm9yKGxldCB1PTEvaSxhPXU7YTw9MTthKz11KWcucHVzaChMdC5Sb3RXaXRoKHQsZSxoKmEpKTtyZXR1cm4gZ319dmFyIHZlOyhmdW5jdGlvbihTKXtTW1MucGVkZGluZz0wXT0icGVkZGluZyIsU1tTLm1vdW50ZWQ9MV09Im1vdW50ZWQiLFNbUy51cGRhdGU9Ml09InVwZGF0ZSIsU1tTLnVubW91bnRlZD0zXT0idW5tb3VudGVkIn0pKHZlfHwodmU9e30pKTt2YXIgRHQ7KGZ1bmN0aW9uKFMpe1NbUy5Ob3JtYWw9MF09Ik5vcm1hbCIsU1tTLlN0cm9rZT0xXT0iU3Ryb2tlIixTW1MuRG90dGVkPTJdPSJEb3R0ZWQiLFNbUy5Mb25nRG90dGVkPTNdPSJMb25nRG90dGVkIn0pKER0fHwoRHQ9e30pKTt2YXIgUnQ7KGZ1bmN0aW9uKFMpe1MuU2hvd0Zsb2F0QmFyPSJTaG93RmxvYXRCYXIiLFMuWkluZGV4RmxvYXRCYXI9IlpJbmRleEZsb2F0QmFyIixTLkRlbGV0ZU5vZGU9IkRlbGV0ZU5vZGUiLFMuQ29weU5vZGU9IkNvcHlOb2RlIixTLlpJbmRleEFjdGl2ZT0iWkluZGV4QWN0aXZlIixTLlpJbmRleE5vZGU9IlpJbmRleE5vZGUiLFMuUm90YXRlTm9kZT0iUm90YXRlTm9kZSIsUy5TZXRDb2xvck5vZGU9IlNldENvbG9yTm9kZSIsUy5UcmFuc2xhdGVOb2RlPSJUcmFuc2xhdGVOb2RlIixTLlNjYWxlTm9kZT0iU2NhbGVOb2RlIixTLk9yaWdpbmFsRXZlbnQ9Ik9yaWdpbmFsRXZlbnQiLFMuQ3JlYXRlU2NlbmU9ImNyZWF0ZVNjZW5lIixTLlVwZGF0ZVNjZW5lPSJVcGRhdGVTY2VuZSJ9KShSdHx8KFJ0PXt9KSk7dmFyIHllOyhmdW5jdGlvbihTKXtTLkRpc3BsYXlTdGF0ZT0iRGlzcGxheVN0YXRlIixTLkZsb2F0QmFyPSJGbG9hdEJhciIsUy5DYW52YXNTZWxlY3Rvcj0iQ2FudmFzU2VsZWN0b3IiLFMuTWFpbkVuZ2luZT0iTWFpbkVuZ2luZSJ9KSh5ZXx8KHllPXt9KSk7ZnVuY3Rpb24gUHQoUyxlKXtpZihTJiZlKXtjb25zdCB0PU1hdGgubWluKFM9PW51bGw/dm9pZCAwOlMueCxlLngpLHI9TWF0aC5taW4oUz09bnVsbD92b2lkIDA6Uy55LGUueSksaT1NYXRoLm1heChTLngrUy53LGUueCtlLncpLGg9TWF0aC5tYXgoUy55K1MuaCxlLnkrZS5oKSxnPWktdCx1PWgtcjtyZXR1cm57eDp0LHk6cix3OmcsaDp1fX1yZXR1cm4gZXx8U31mdW5jdGlvbiBWdChTLGU9MCl7Y29uc3QgdD17eDowLHk6MCx3OjAsaDowfTtsZXQgcj0xLzAsaT0xLzAsaD0tMS8wLGc9LTEvMDtyZXR1cm4gUy5mb3JFYWNoKHU9Pntjb25zdFthLGNdPXUuWFk7cj1NYXRoLm1pbihyLGEtZSksaT1NYXRoLm1pbihpLGMtZSksaD1NYXRoLm1heChoLGErZSksZz1NYXRoLm1heChnLGMrZSl9KSx0Lng9cix0Lnk9aSx0Lnc9aC1yLHQuaD1nLWksdH1mdW5jdGlvbiBsZShTLGUpe3JldHVybiEoUy54K1MudzxlLnh8fFMueD5lLngrZS53fHxTLnkrUy5oPGUueXx8Uy55PmUueStlLmgpfWZ1bmN0aW9uIEFlKFMsZSl7cmV0dXJuIFMubGVuZ3RoPT09ZS5sZW5ndGgmJlMuc29ydCgpLnRvU3RyaW5nKCk9PT1lLnNvcnQoKS50b1N0cmluZygpfWZ1bmN0aW9uIFNlKFMsZT0xMCl7cmV0dXJue3g6TWF0aC5mbG9vcihTLngtZSkseTpNYXRoLmZsb29yKFMueS1lKSx3Ok1hdGguZmxvb3IoUy53K2UqMiksaDpNYXRoLmZsb29yKFMuaCtlKjIpfX1mdW5jdGlvbiBSZShTLGUpe2NvbnN0IHQ9bmV3IGh0KFMueCxTLnkpLHI9bmV3IGh0KFMueCtTLncsUy55KSxpPW5ldyBodChTLngrUy53LFMueStTLmgpLGg9bmV3IGh0KFMueCxTLnkrUy5oKSxnPW5ldyBodChTLngrUy53LzIsUy55K1MuaC8yKSx1PU1hdGguUEkqZS8xODAsYT1odC5Sb3RXaXRoKHQsZyx1KSxjPWh0LlJvdFdpdGgocixnLHUpLHg9aHQuUm90V2l0aChpLGcsdSksZj1odC5Sb3RXaXRoKGgsZyx1KTtyZXR1cm4gVnQoW2EsYyx4LGZdKX1mdW5jdGlvbiBDZShTLGUpe2NvbnN0IHQ9bmV3IGh0KFMueCxTLnkpLHI9bmV3IGh0KFMueCtTLncsUy55KSxpPW5ldyBodChTLngrUy53LFMueStTLmgpLGg9bmV3IGh0KFMueCxTLnkrUy5oKSxnPW5ldyBodChTLngrUy53LzIsUy55K1MuaC8yKSx1PW5ldyBodChlWzBdLGVbMV0pLGE9aHQuU2NhbGVXT3JpZ2luKHQsdSxnKSxjPWh0LlNjYWxlV09yaWdpbihyLHUsZykseD1odC5TY2FsZVdPcmlnaW4oaSx1LGcpLGY9aHQuU2NhbGVXT3JpZ2luKGgsdSxnKTtyZXR1cm4gVnQoW2EsYyx4LGZdKX1mdW5jdGlvbiBiZShTLGUsdCl7Y29uc3Qgcj1uZXcgaHQoZVswXSxlWzFdKTtmb3IobGV0IGk9MDtpPFMubGVuZ3RoO2krPTMpe2NvbnN0IGg9bmV3IGh0KFNbaV0sU1tpKzFdKSxnPU1hdGguUEkqdC8xODAsdT1odC5Sb3RXaXRoKGgscixnKTtTW2ldPXUueCxTW2krMV09dS55fX1mdW5jdGlvbiBMZShTLGUsdCl7Y29uc3Qgcj1uZXcgaHQoZVswXSxlWzFdKTtmb3IobGV0IGk9MDtpPFMubGVuZ3RoO2krPTMpe2NvbnN0IGg9bmV3IGh0KFNbaV0sU1tpKzFdKSxnPW5ldyBodCh0WzBdLHRbMV0pO2lmKGk8Uy5sZW5ndGgtMyl7Y29uc3QgYT1uZXcgaHQoU1tpKzNdLFNbaSs0XSksYz1odC5UYW4oYSxoKS5wZXIoKS5tdWwoU1tpKzJdKS5tdWxWKGcpLmxlbigpO1NbaSsyXT1jfWVsc2UgaWYoaT09PVMubGVuZ3RoLTMpe2NvbnN0IGE9bmV3IGh0KFNbaS0zXSxTW2ktMl0pLGM9aHQuVGFuKGgsYSkucGVyKCkubXVsKFNbaSsyXSkubXVsVihnKS5sZW4oKTtTW2krMl09Y31jb25zdCB1PWh0LlNjYWxlV09yaWdpbihoLGcscik7U1tpXT11LngsU1tpKzFdPXUueX19ZnVuY3Rpb24gS3QoUyxlKXtsZXQgdDtyZXR1cm4gZT09bnVsbHx8ZS5nZXRFbGVtZW50c0J5TmFtZShTKS5mb3JFYWNoKHI9PntpZihyLnRhZ05hbWU9PT0iUEFUSCIpe2NvbnN0IGk9cj09bnVsbD92b2lkIDA6ci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtpJiYodD1QdCh0LHt4Ok1hdGguZmxvb3IoaS54KSx5Ok1hdGguZmxvb3IoaS55KSx3Ok1hdGgucm91bmQoaS53aWR0aCksaDpNYXRoLnJvdW5kKGkuaGVpZ2h0KX0pKX1lbHNlIGlmKHIudGFnTmFtZT09PSJHUk9VUCIpe2NvbnN0IGk9ci5jbGFzc05hbWUuc3BsaXQoIiwiKTtpZihpLmxlbmd0aD09PTMmJk51bWJlcihpWzJdKT09PUR0LlN0cm9rZSl7Y29uc3QgaD1yPT1udWxsP3ZvaWQgMDpyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO2gmJih0PVB0KHQse3g6TWF0aC5mbG9vcihoLngpLHk6TWF0aC5mbG9vcihoLnkpLHc6TWF0aC5yb3VuZChoLndpZHRoKSxoOk1hdGgucm91bmQoaC5oZWlnaHQpfSkpfWVsc2Ugci5jaGlsZHJlbi5mb3JFYWNoKGg9PntpZihoLnRhZ05hbWU9PT0iUEFUSCIpe2NvbnN0IGc9aD09bnVsbD92b2lkIDA6aC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtnJiYodD1QdCh0LHt4Ok1hdGguZmxvb3IoZy54KSx5Ok1hdGguZmxvb3IoZy55KSx3Ok1hdGgucm91bmQoZy53aWR0aCksaDpNYXRoLnJvdW5kKGcuaGVpZ2h0KX0pKX19KX19KSx0fWZ1bmN0aW9uIFp0KFMpe3JldHVybmAke3JlKFMueCl9LCR7cmUoUy55KX0gYH1mdW5jdGlvbiBKdChTLGUpe3JldHVybmAke3JlKChTLngrZS54KS8yKX0sJHtyZSgoUy55K2UueSkvMil9IGB9ZnVuY3Rpb24gcmUoUyl7cmV0dXJuK1MudG9GaXhlZCg0KX1mdW5jdGlvbiBuZShTLGU9ITApe2NvbnN0IHQ9Uy5sZW5ndGg7aWYodDwyKXJldHVybiIiO2xldCByPVNbMF0saT1TWzFdO2lmKHQ9PT0yKXJldHVybmBNJHtadChyKX1MJHtadChpKX1gO2xldCBoPSIiO2ZvcihsZXQgZz0yLHU9dC0xO2c8dTtnKyspcj1TW2ddLGk9U1tnKzFdLGgrPUp0KHIsaSk7cmV0dXJuIGU/YE0ke0p0KFNbMF0sU1sxXSl9USR7WnQoU1sxXSl9JHtKdChTWzFdLFNbMl0pfVQke2h9JHtKdChTW3QtMV0sU1swXSl9JHtKdChTWzBdLFNbMV0pfVpgOmBNJHtadChTWzBdKX1RJHtadChTWzFdKX0ke0p0KFNbMV0sU1syXSl9JHtTLmxlbmd0aD4zPyJUIjoiIn0ke2h9TCR7WnQoU1t0LTFdKX1gfWZ1bmN0aW9uIERlKFMpe3JldHVybiBTJiZTLl9fZXNNb2R1bGUmJk9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChTLCJkZWZhdWx0Iik/Uy5kZWZhdWx0OlN9dmFyIGZlPXtleHBvcnRzOnt9fTtmZS5leHBvcnRzLGZ1bmN0aW9uKFMpe3ZhciBlPWZ1bmN0aW9uKCl7dmFyIHQ9U3RyaW5nLmZyb21DaGFyQ29kZSxyPSJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPSIsaT0iQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLSQiLGg9e307ZnVuY3Rpb24gZyhhLGMpe2lmKCFoW2FdKXtoW2FdPXt9O2Zvcih2YXIgeD0wO3g8YS5sZW5ndGg7eCsrKWhbYV1bYS5jaGFyQXQoeCldPXh9cmV0dXJuIGhbYV1bY119dmFyIHU9e2NvbXByZXNzVG9CYXNlNjQ6ZnVuY3Rpb24oYSl7aWYoYT09bnVsbClyZXR1cm4iIjt2YXIgYz11Ll9jb21wcmVzcyhhLDYsZnVuY3Rpb24oeCl7cmV0dXJuIHIuY2hhckF0KHgpfSk7c3dpdGNoKGMubGVuZ3RoJTQpe2RlZmF1bHQ6Y2FzZSAwOnJldHVybiBjO2Nhc2UgMTpyZXR1cm4gYysiPT09IjtjYXNlIDI6cmV0dXJuIGMrIj09IjtjYXNlIDM6cmV0dXJuIGMrIj0ifX0sZGVjb21wcmVzc0Zyb21CYXNlNjQ6ZnVuY3Rpb24oYSl7cmV0dXJuIGE9PW51bGw/IiI6YT09IiI/bnVsbDp1Ll9kZWNvbXByZXNzKGEubGVuZ3RoLDMyLGZ1bmN0aW9uKGMpe3JldHVybiBnKHIsYS5jaGFyQXQoYykpfSl9LGNvbXByZXNzVG9VVEYxNjpmdW5jdGlvbihhKXtyZXR1cm4gYT09bnVsbD8iIjp1Ll9jb21wcmVzcyhhLDE1LGZ1bmN0aW9uKGMpe3JldHVybiB0KGMrMzIpfSkrIiAifSxkZWNvbXByZXNzRnJvbVVURjE2OmZ1bmN0aW9uKGEpe3JldHVybiBhPT1udWxsPyIiOmE9PSIiP251bGw6dS5fZGVjb21wcmVzcyhhLmxlbmd0aCwxNjM4NCxmdW5jdGlvbihjKXtyZXR1cm4gYS5jaGFyQ29kZUF0KGMpLTMyfSl9LGNvbXByZXNzVG9VaW50OEFycmF5OmZ1bmN0aW9uKGEpe2Zvcih2YXIgYz11LmNvbXByZXNzKGEpLHg9bmV3IFVpbnQ4QXJyYXkoYy5sZW5ndGgqMiksZj0wLHY9Yy5sZW5ndGg7Zjx2O2YrKyl7dmFyIHA9Yy5jaGFyQ29kZUF0KGYpO3hbZioyXT1wPj4+OCx4W2YqMisxXT1wJTI1Nn1yZXR1cm4geH0sZGVjb21wcmVzc0Zyb21VaW50OEFycmF5OmZ1bmN0aW9uKGEpe2lmKGE9PW51bGwpcmV0dXJuIHUuZGVjb21wcmVzcyhhKTtmb3IodmFyIGM9bmV3IEFycmF5KGEubGVuZ3RoLzIpLHg9MCxmPWMubGVuZ3RoO3g8Zjt4KyspY1t4XT1hW3gqMl0qMjU2K2FbeCoyKzFdO3ZhciB2PVtdO3JldHVybiBjLmZvckVhY2goZnVuY3Rpb24ocCl7di5wdXNoKHQocCkpfSksdS5kZWNvbXByZXNzKHYuam9pbigiIikpfSxjb21wcmVzc1RvRW5jb2RlZFVSSUNvbXBvbmVudDpmdW5jdGlvbihhKXtyZXR1cm4gYT09bnVsbD8iIjp1Ll9jb21wcmVzcyhhLDYsZnVuY3Rpb24oYyl7cmV0dXJuIGkuY2hhckF0KGMpfSl9LGRlY29tcHJlc3NGcm9tRW5jb2RlZFVSSUNvbXBvbmVudDpmdW5jdGlvbihhKXtyZXR1cm4gYT09bnVsbD8iIjphPT0iIj9udWxsOihhPWEucmVwbGFjZSgvIC9nLCIrIiksdS5fZGVjb21wcmVzcyhhLmxlbmd0aCwzMixmdW5jdGlvbihjKXtyZXR1cm4gZyhpLGEuY2hhckF0KGMpKX0pKX0sY29tcHJlc3M6ZnVuY3Rpb24oYSl7cmV0dXJuIHUuX2NvbXByZXNzKGEsMTYsZnVuY3Rpb24oYyl7cmV0dXJuIHQoYyl9KX0sX2NvbXByZXNzOmZ1bmN0aW9uKGEsYyx4KXtpZihhPT1udWxsKXJldHVybiIiO3ZhciBmLHYscD17fSxDPXt9LE09IiIsbT0iIix5PSIiLG49MixvPTMscz0yLGw9W10sRT0wLFQ9MCxiO2ZvcihiPTA7YjxhLmxlbmd0aDtiKz0xKWlmKE09YS5jaGFyQXQoYiksT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHAsTSl8fChwW01dPW8rKyxDW01dPSEwKSxtPXkrTSxPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocCxtKSl5PW07ZWxzZXtpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoQyx5KSl7aWYoeS5jaGFyQ29kZUF0KDApPDI1Nil7Zm9yKGY9MDtmPHM7ZisrKUU9RTw8MSxUPT1jLTE/KFQ9MCxsLnB1c2goeChFKSksRT0wKTpUKys7Zm9yKHY9eS5jaGFyQ29kZUF0KDApLGY9MDtmPDg7ZisrKUU9RTw8MXx2JjEsVD09Yy0xPyhUPTAsbC5wdXNoKHgoRSkpLEU9MCk6VCsrLHY9dj4+MX1lbHNle2Zvcih2PTEsZj0wO2Y8cztmKyspRT1FPDwxfHYsVD09Yy0xPyhUPTAsbC5wdXNoKHgoRSkpLEU9MCk6VCsrLHY9MDtmb3Iodj15LmNoYXJDb2RlQXQoMCksZj0wO2Y8MTY7ZisrKUU9RTw8MXx2JjEsVD09Yy0xPyhUPTAsbC5wdXNoKHgoRSkpLEU9MCk6VCsrLHY9dj4+MX1uLS0sbj09MCYmKG49TWF0aC5wb3coMixzKSxzKyspLGRlbGV0ZSBDW3ldfWVsc2UgZm9yKHY9cFt5XSxmPTA7ZjxzO2YrKylFPUU8PDF8diYxLFQ9PWMtMT8oVD0wLGwucHVzaCh4KEUpKSxFPTApOlQrKyx2PXY+PjE7bi0tLG49PTAmJihuPU1hdGgucG93KDIscykscysrKSxwW21dPW8rKyx5PVN0cmluZyhNKX1pZih5IT09IiIpe2lmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChDLHkpKXtpZih5LmNoYXJDb2RlQXQoMCk8MjU2KXtmb3IoZj0wO2Y8cztmKyspRT1FPDwxLFQ9PWMtMT8oVD0wLGwucHVzaCh4KEUpKSxFPTApOlQrKztmb3Iodj15LmNoYXJDb2RlQXQoMCksZj0wO2Y8ODtmKyspRT1FPDwxfHYmMSxUPT1jLTE/KFQ9MCxsLnB1c2goeChFKSksRT0wKTpUKyssdj12Pj4xfWVsc2V7Zm9yKHY9MSxmPTA7ZjxzO2YrKylFPUU8PDF8dixUPT1jLTE/KFQ9MCxsLnB1c2goeChFKSksRT0wKTpUKyssdj0wO2Zvcih2PXkuY2hhckNvZGVBdCgwKSxmPTA7ZjwxNjtmKyspRT1FPDwxfHYmMSxUPT1jLTE/KFQ9MCxsLnB1c2goeChFKSksRT0wKTpUKyssdj12Pj4xfW4tLSxuPT0wJiYobj1NYXRoLnBvdygyLHMpLHMrKyksZGVsZXRlIENbeV19ZWxzZSBmb3Iodj1wW3ldLGY9MDtmPHM7ZisrKUU9RTw8MXx2JjEsVD09Yy0xPyhUPTAsbC5wdXNoKHgoRSkpLEU9MCk6VCsrLHY9dj4+MTtuLS0sbj09MCYmKG49TWF0aC5wb3coMixzKSxzKyspfWZvcih2PTIsZj0wO2Y8cztmKyspRT1FPDwxfHYmMSxUPT1jLTE/KFQ9MCxsLnB1c2goeChFKSksRT0wKTpUKyssdj12Pj4xO2Zvcig7OylpZihFPUU8PDEsVD09Yy0xKXtsLnB1c2goeChFKSk7YnJlYWt9ZWxzZSBUKys7cmV0dXJuIGwuam9pbigiIil9LGRlY29tcHJlc3M6ZnVuY3Rpb24oYSl7cmV0dXJuIGE9PW51bGw/IiI6YT09IiI/bnVsbDp1Ll9kZWNvbXByZXNzKGEubGVuZ3RoLDMyNzY4LGZ1bmN0aW9uKGMpe3JldHVybiBhLmNoYXJDb2RlQXQoYyl9KX0sX2RlY29tcHJlc3M6ZnVuY3Rpb24oYSxjLHgpe3ZhciBmPVtdLHY9NCxwPTQsQz0zLE09IiIsbT1bXSx5LG4sbyxzLGwsRSxULGI9e3ZhbDp4KDApLHBvc2l0aW9uOmMsaW5kZXg6MX07Zm9yKHk9MDt5PDM7eSs9MSlmW3ldPXk7Zm9yKG89MCxsPU1hdGgucG93KDIsMiksRT0xO0UhPWw7KXM9Yi52YWwmYi5wb3NpdGlvbixiLnBvc2l0aW9uPj49MSxiLnBvc2l0aW9uPT0wJiYoYi5wb3NpdGlvbj1jLGIudmFsPXgoYi5pbmRleCsrKSksb3w9KHM+MD8xOjApKkUsRTw8PTE7c3dpdGNoKG8pe2Nhc2UgMDpmb3Iobz0wLGw9TWF0aC5wb3coMiw4KSxFPTE7RSE9bDspcz1iLnZhbCZiLnBvc2l0aW9uLGIucG9zaXRpb24+Pj0xLGIucG9zaXRpb249PTAmJihiLnBvc2l0aW9uPWMsYi52YWw9eChiLmluZGV4KyspKSxvfD0ocz4wPzE6MCkqRSxFPDw9MTtUPXQobyk7YnJlYWs7Y2FzZSAxOmZvcihvPTAsbD1NYXRoLnBvdygyLDE2KSxFPTE7RSE9bDspcz1iLnZhbCZiLnBvc2l0aW9uLGIucG9zaXRpb24+Pj0xLGIucG9zaXRpb249PTAmJihiLnBvc2l0aW9uPWMsYi52YWw9eChiLmluZGV4KyspKSxvfD0ocz4wPzE6MCkqRSxFPDw9MTtUPXQobyk7YnJlYWs7Y2FzZSAyOnJldHVybiIifWZvcihmWzNdPVQsbj1ULG0ucHVzaChUKTs7KXtpZihiLmluZGV4PmEpcmV0dXJuIiI7Zm9yKG89MCxsPU1hdGgucG93KDIsQyksRT0xO0UhPWw7KXM9Yi52YWwmYi5wb3NpdGlvbixiLnBvc2l0aW9uPj49MSxiLnBvc2l0aW9uPT0wJiYoYi5wb3NpdGlvbj1jLGIudmFsPXgoYi5pbmRleCsrKSksb3w9KHM+MD8xOjApKkUsRTw8PTE7c3dpdGNoKFQ9byl7Y2FzZSAwOmZvcihvPTAsbD1NYXRoLnBvdygyLDgpLEU9MTtFIT1sOylzPWIudmFsJmIucG9zaXRpb24sYi5wb3NpdGlvbj4+PTEsYi5wb3NpdGlvbj09MCYmKGIucG9zaXRpb249YyxiLnZhbD14KGIuaW5kZXgrKykpLG98PShzPjA/MTowKSpFLEU8PD0xO2ZbcCsrXT10KG8pLFQ9cC0xLHYtLTticmVhaztjYXNlIDE6Zm9yKG89MCxsPU1hdGgucG93KDIsMTYpLEU9MTtFIT1sOylzPWIudmFsJmIucG9zaXRpb24sYi5wb3NpdGlvbj4+PTEsYi5wb3NpdGlvbj09MCYmKGIucG9zaXRpb249YyxiLnZhbD14KGIuaW5kZXgrKykpLG98PShzPjA/MTowKSpFLEU8PD0xO2ZbcCsrXT10KG8pLFQ9cC0xLHYtLTticmVhaztjYXNlIDI6cmV0dXJuIG0uam9pbigiIil9aWYodj09MCYmKHY9TWF0aC5wb3coMixDKSxDKyspLGZbVF0pTT1mW1RdO2Vsc2UgaWYoVD09PXApTT1uK24uY2hhckF0KDApO2Vsc2UgcmV0dXJuIG51bGw7bS5wdXNoKE0pLGZbcCsrXT1uK00uY2hhckF0KDApLHYtLSxuPU0sdj09MCYmKHY9TWF0aC5wb3coMixDKSxDKyspfX19O3JldHVybiB1fSgpO1MhPW51bGw/Uy5leHBvcnRzPWU6dHlwZW9mIGFuZ3VsYXI8InUiJiZhbmd1bGFyIT1udWxsJiZhbmd1bGFyLm1vZHVsZSgiTFpTdHJpbmciLFtdKS5mYWN0b3J5KCJMWlN0cmluZyIsZnVuY3Rpb24oKXtyZXR1cm4gZX0pfShmZSk7dmFyIHBlPWZlLmV4cG9ydHM7ZnVuY3Rpb24gcXQoUyl7cmV0dXJuIEpTT04ucGFyc2UocGUuZGVjb21wcmVzcyhTKSl9ZnVuY3Rpb24gaWUoUyl7cmV0dXJuIHBlLmNvbXByZXNzKEpTT04uc3RyaW5naWZ5KFMpKX1jbGFzcyBJdCBleHRlbmRzIGVle2NvbnN0cnVjdG9yKGUsdCxyKXtzdXBlcih0LHIpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ0b29sc1R5cGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpTdC5QZW5jaWx9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywic3luY1RpbWVzdGFtcCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzeW5jSW5kZXgiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTowfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInRtcFBvaW50cyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOltdfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIk1BWF9SRVBFQVIiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZToxMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ1bmlUaGlja25lc3MiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywid29ya09wdGlvbnMiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiY2VudGVyUG9zIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6WzAsMF19KSx0aGlzLndvcmtPcHRpb25zPWUsdGhpcy51bmlUaGlja25lc3M9dGhpcy5NQVhfUkVQRUFSL2UudGhpY2tuZXNzLzEwLHRoaXMuc3luY1RpbWVzdGFtcD0wfWNvbWJpbmVDb25zdW1lKCl7dmFyIGg7Y29uc3QgZT0oaD10aGlzLndvcmtJZCk9PW51bGw/dm9pZCAwOmgudG9TdHJpbmcoKSx0PXRoaXMudHJhbnNmb3JtRGF0YUFsbCghMCkscj17bmFtZTplLGNsYXNzTmFtZToicGVuY2lsIn07bGV0IGk7cmV0dXJuIHQubGVuZ3RoJiYoaT10aGlzLmRyYXcoe2F0dHJzOnIsdGFza3M6dCxyZXBsYWNlSWQ6ZSxpc0Z1bGxXb3JrOiExLG5vcm1hbGl6ZTohMCxpc0NsZWFyQWxsOiEwfSkpLHtyZWN0OmksdHlwZTpwdC5EcmF3V29yayxkYXRhVHlwZTpBdC5Mb2NhbH19c2V0V29ya09wdGlvbnMoZSl7c3VwZXIuc2V0V29ya09wdGlvbnMoZSksdGhpcy5zeW5jVGltZXN0YW1wPURhdGUubm93KCl9Y29uc3VtZShlKXt2YXIgTTtjb25zdHtkYXRhOnQsaXNGdWxsV29yazpyLGlzQ2xlYXJBbGw6aSxpc1N1YldvcmtlcjpofT1lO2lmKCgoTT10Lm9wKT09bnVsbD92b2lkIDA6TS5sZW5ndGgpPT09MClyZXR1cm57dHlwZTpwdC5Ob25lfTtjb25zdHt3b3JrSWQ6Z309dCx7dGFza3M6dSxlZmZlY3RzOmEsY29uc3VtZUluZGV4OmN9PXRoaXMudHJhbnNmb3JtRGF0YSh0LCExKTt0aGlzLnN5bmNJbmRleD1NYXRoLm1pbih0aGlzLnN5bmNJbmRleCxjKTtjb25zdCB4PXtuYW1lOmc9PW51bGw/dm9pZCAwOmcudG9TdHJpbmcoKSxjbGFzc05hbWU6InBlbmNpbCJ9O2xldCBmLHY9ITE7Y29uc3QgcD10aGlzLnN5bmNJbmRleDtpZih0aGlzLnN5bmNUaW1lc3RhbXA9PT0wJiYodGhpcy5zeW5jVGltZXN0YW1wPURhdGUubm93KCkpLHUubGVuZ3RoJiYodVswXS50YXNrSWQtdGhpcy5zeW5jVGltZXN0YW1wPnRoaXMuc3luY1VuaXRUaW1lJiYodj0hMCx0aGlzLnN5bmNUaW1lc3RhbXA9dVswXS50YXNrSWQsdGhpcy5zeW5jSW5kZXg9dGhpcy50bXBQb2ludHMubGVuZ3RoKSxmPXRoaXMuZHJhdyh7YXR0cnM6eCx0YXNrczp1LGVmZmVjdHM6YSxpc0Z1bGxXb3JrOnIsaXNDbGVhckFsbDppfSkpLGgpcmV0dXJuIGM+MTAmJnRoaXMudG1wUG9pbnRzLnNwbGljZSgwLGMtMTApLHtyZWN0OmYsdHlwZTpwdC5EcmF3V29yayxkYXRhVHlwZTpBdC5Mb2NhbH07Y29uc3QgQz1bXTtyZXR1cm4gdGhpcy50bXBQb2ludHMuc2xpY2UocCkuZm9yRWFjaChtPT57Qy5wdXNoKG0ueCxtLnksdGhpcy5jb21wdXRSYWRpdXMobS56LHRoaXMud29ya09wdGlvbnMudGhpY2tuZXNzKSl9KSx7cmVjdDpmLHR5cGU6cHQuRHJhd1dvcmssZGF0YVR5cGU6QXQuTG9jYWwsd29ya0lkOnY/Zzp2b2lkIDAsb3A6dj9DOnZvaWQgMCxpbmRleDp2P3AqMzp2b2lkIDB9fWNvbnN1bWVBbGwoZSl7dmFyIHU7aWYoZS5kYXRhKXtjb25zdHtvcDphLHdvcmtTdGF0ZTpjfT1lLmRhdGE7YSE9bnVsbCYmYS5sZW5ndGgmJmM9PT13dC5Eb25lJiZ0aGlzLndvcmtPcHRpb25zLnN0cm9rZVR5cGU9PT1EdC5TdHJva2UmJnRoaXMudXBkYXRlVGVtcFBvaW50c1dpdGhQcmVzc3VyZVdoZW5Eb25lKGEpfWNvbnN0IHQ9KHU9dGhpcy53b3JrSWQpPT1udWxsP3ZvaWQgMDp1LnRvU3RyaW5nKCkscj10aGlzLnRyYW5zZm9ybURhdGFBbGwoITApLGk9e25hbWU6dCxjbGFzc05hbWU6InBlbmNpbCJ9O2xldCBoO3IubGVuZ3RoJiYoaD10aGlzLmRyYXcoe2F0dHJzOmksdGFza3M6cixyZXBsYWNlSWQ6dCxpc0Z1bGxXb3JrOiEwLG5vcm1hbGl6ZTohMCxpc0NsZWFyQWxsOiExfSkpO2NvbnN0IGc9W107cmV0dXJuIHRoaXMudG1wUG9pbnRzLm1hcChhPT57Zy5wdXNoKGEueCxhLnksdGhpcy5jb21wdXRSYWRpdXMoYS56LHRoaXMud29ya09wdGlvbnMudGhpY2tuZXNzKSl9KSx0aGlzLnN5bmNUaW1lc3RhbXA9MCx7cmVjdDpoLHR5cGU6cHQuRnVsbFdvcmssZGF0YVR5cGU6QXQuTG9jYWwsd29ya0lkOnQsb3BzOmllKGcpLHVwZGF0ZU5vZGVPcHQ6e3Bvczp0aGlzLmNlbnRlclBvcyx1c2VBbmltYXRpb246ITB9fX1jbGVhclRtcFBvaW50cygpe3RoaXMudG1wUG9pbnRzLmxlbmd0aD0wLHRoaXMuc3luY1RpbWVzdGFtcD0wLHRoaXMuc3luY0luZGV4PTB9Y29uc3VtZVNlcnZpY2UoZSl7dmFyIHg7Y29uc3R7b3A6dCxpc0Z1bGxXb3JrOnIscmVwbGFjZUlkOmksaXNDbGVhckFsbDpofT1lO3RoaXMudG1wUG9pbnRzLmxlbmd0aD0wO2ZvcihsZXQgZj0wO2Y8dC5sZW5ndGg7Zis9Myl7Y29uc3Qgdj1uZXcgTHQodFtmXSx0W2YrMV0sdFtmKzJdKTtpZih0aGlzLnRtcFBvaW50cy5sZW5ndGg+MCl7Y29uc3QgcD10aGlzLnRtcFBvaW50c1t0aGlzLnRtcFBvaW50cy5sZW5ndGgtMV0sQz1odC5TdWIodixwKS51bmkoKTt2LnNldHYoQyl9dGhpcy50bXBQb2ludHMucHVzaCh2KX1jb25zdCBnPXRoaXMudHJhbnNmb3JtRGF0YUFsbCghMSksYT17bmFtZTooeD10aGlzLndvcmtJZCk9PW51bGw/dm9pZCAwOngudG9TdHJpbmcoKSxjbGFzc05hbWU6InBlbmNpbCJ9O2xldCBjO3JldHVybiBnLmxlbmd0aCYmKGM9dGhpcy5kcmF3KHthdHRyczphLHRhc2tzOmcscmVwbGFjZUlkOmksaXNGdWxsV29yazpyLG5vcm1hbGl6ZTohMCxpc0NsZWFyQWxsOmh9KSksY310cmFuc2Zvcm1EYXRhQWxsKGU9ITApe3JldHVybiB0aGlzLmdldFRhc2tQb2ludHModGhpcy50bXBQb2ludHMsZSYmdGhpcy53b3JrT3B0aW9ucy50aGlja25lc3N8fHZvaWQgMCl9ZHJhdyhlKXt2YXIgbDtjb25zdHthdHRyczp0LHRhc2tzOnIscmVwbGFjZUlkOmksZWZmZWN0czpoLGlzRnVsbFdvcms6Zyxub3JtYWxpemU6dSxpc0NsZWFyQWxsOmF9PWUsYz1nP3RoaXMuZnVsbExheWVyOnRoaXMuZHJhd0xheWVyfHx0aGlzLmZ1bGxMYXllcix7Y29sb3I6eCxzdHJva2VUeXBlOmYsdGhpY2tuZXNzOnYsb3BhY2l0eTpwLHpJbmRleDpDLHNjYWxlOk0scm90YXRlOm19PXRoaXMud29ya09wdGlvbnM7YT9jLnJlbW92ZUFsbENoaWxkcmVuKCk6KGkmJihjLmdldEVsZW1lbnRzQnlOYW1lKGkrIiIpLm1hcChFPT5FLnJlbW92ZSgpKSwobD10aGlzLmRyYXdMYXllcik9PW51bGx8fGwuZ2V0RWxlbWVudHNCeU5hbWUoaSsiIikubWFwKEU9PkUucmVtb3ZlKCkpKSxoIT1udWxsJiZoLnNpemUmJihoLmZvckVhY2goRT0+e3ZhciBUOyhUPWMuZ2V0RWxlbWVudEJ5SWQoRSsiIikpPT1udWxsfHxULnJlbW92ZSgpfSksaC5jbGVhcigpKSk7bGV0IHk7Y29uc3Qgbj1bXSxvPWMud29ybGRQb3NpdGlvbixzPWMud29ybGRTY2FsaW5nO2ZvcihsZXQgRT0wO0U8ci5sZW5ndGg7RSsrKXtjb25zdHtwb3M6VCxwb2ludHM6Yix0YXNrSWQ6SX09cltFXTt0LmlkPUkudG9TdHJpbmcoKTtjb25zdHtwczpQLHJlY3Q6TH09dGhpcy5jb21wdXREcmF3UG9pbnRzKGIpO2xldCBEO2NvbnN0IFI9Yi5sZW5ndGg9PT0xO2Y9PT1EdC5TdHJva2V8fFI/RD1uZShQLCEwKTpEPW5lKFAsITEpO2NvbnN0IEE9e3BvczpULGQ6RCxmaWxsQ29sb3I6Zj09PUR0LlN0cm9rZXx8Uj94OnZvaWQgMCxvcGFjaXR5OnB8fDEsbGluZURhc2g6Zj09PUR0LkRvdHRlZCYmIVI/WzEsdioyXTpmPT09RHQuTG9uZ0RvdHRlZCYmIVI/W3YsdioyXTp2b2lkIDAsc3Ryb2tlQ29sb3I6eCxsaW5lQ2FwOmY9PT1EdC5TdHJva2V8fFI/dm9pZCAwOiJyb3VuZCIsbGluZVdpZHRoOmY9PT1EdC5TdHJva2V8fFI/MDp2LGNsYXNzTmFtZTpgJHtUWzBdfSwke1RbMV19LCR7Zn1gfTtpZihyLmxlbmd0aD09PTEmJnUpe2NvbnN0IGo9W0wueCtMLncvMixMLnkrTC5oLzJdO2lmKHRoaXMuY2VudGVyUG9zPVtqWzBdK1RbMF0salsxXStUWzFdXSxBLm5vcm1hbGl6ZT0hMCxBLnBvcz10aGlzLmNlbnRlclBvcyxBLmNsYXNzTmFtZT1gJHt0aGlzLmNlbnRlclBvc1swXX0sJHt0aGlzLmNlbnRlclBvc1sxXX0sJHtmfWAsQS5pZD10Lm5hbWUsQS56SW5kZXg9QyxNKXtBLnNjYWxlPU07Y29uc3QgRz1DZSh7eDpNYXRoLmZsb29yKEwueCtUWzBdK29bMF0tSXQuUGVuY2lsQm9yZGVyUGFkZGluZykseTpNYXRoLmZsb29yKEwueStUWzFdK29bMV0tSXQuUGVuY2lsQm9yZGVyUGFkZGluZyksdzpNYXRoLmZsb29yKEwudysyKkl0LlBlbmNpbEJvcmRlclBhZGRpbmcpLGg6TWF0aC5mbG9vcihMLmgrMipJdC5QZW5jaWxCb3JkZXJQYWRkaW5nKX0sTSk7eT1QdCh5LEcpfWlmKG0pe0Eucm90YXRlPW07Y29uc3QgRz1SZSh7eDpNYXRoLmZsb29yKEwueCtUWzBdK29bMF0tSXQuUGVuY2lsQm9yZGVyUGFkZGluZykseTpNYXRoLmZsb29yKEwueStUWzFdK29bMV0tSXQuUGVuY2lsQm9yZGVyUGFkZGluZyksdzpNYXRoLmZsb29yKEwudysyKkl0LlBlbmNpbEJvcmRlclBhZGRpbmcpLGg6TWF0aC5mbG9vcihMLmgrMipJdC5QZW5jaWxCb3JkZXJQYWRkaW5nKX0sbSk7eT1QdCh5LEcpfX15PVB0KHkse3g6TWF0aC5mbG9vcigoTC54K1RbMF0pKnNbMF0rb1swXS1JdC5QZW5jaWxCb3JkZXJQYWRkaW5nKSx5Ok1hdGguZmxvb3IoKEwueStUWzFdKSpzWzFdK29bMV0tSXQuUGVuY2lsQm9yZGVyUGFkZGluZyksdzpNYXRoLmZsb29yKEwudypzWzBdKzIqSXQuUGVuY2lsQm9yZGVyUGFkZGluZyksaDpNYXRoLmZsb29yKEwuaCpzWzFdKzIqSXQuUGVuY2lsQm9yZGVyUGFkZGluZyl9KSxuLnB1c2goQSl9aWYodSYmbi5sZW5ndGg+MSYmeSl7Y29uc3QgRT1uZXcgb2U7dGhpcy5jZW50ZXJQb3M9Wyh5LngreS53LzItb1swXSkvc1swXSwoeS55K3kuaC8yLW9bMV0pL3NbMV1dLEUuYXR0cih7Li4udCxpZDp0Lm5hbWUsYW5jaG9yOlsuNSwuNV0sYmdjb2xvcjpmPT09RHQuU3Ryb2tlP3g6dm9pZCAwLHNjYWxlOk0sb3BhY2l0eTpwLHBvczp0aGlzLmNlbnRlclBvcyxyb3RhdGU6bSxjbGFzc05hbWU6YCR7dGhpcy5jZW50ZXJQb3NbMF19LCR7dGhpcy5jZW50ZXJQb3NbMV19LCR7Zn1gLHNpemU6W3kudyx5LmhdLHpJbmRleDpDfSksbi5mb3JFYWNoKFQ9PntULnBvcz1bVC5wb3NbMF0tdGhpcy5jZW50ZXJQb3NbMF0sVC5wb3NbMV0tdGhpcy5jZW50ZXJQb3NbMV1dO2NvbnN0IGI9bmV3IGFlKFQpO0UuYXBwZW5kQ2hpbGQoYil9KSxmPT09RHQuU3Ryb2tlJiZFLnNlYWwoKSxjLmFwcGVuZChFKX1lbHNle2NvbnN0IEU9bi5tYXAoVD0+bmV3IGFlKHsuLi50LC4uLlR9KSk7Yy5hcHBlbmQoLi4uRSl9cmV0dXJuIHl9Y29tcHV0RHJhd1BvaW50cyhlKXtyZXR1cm4gdGhpcy53b3JrT3B0aW9ucy5zdHJva2VUeXBlPT09RHQuU3Ryb2tlfHxlLmxlbmd0aD09PTE/dGhpcy5jb21wdXRTdHJva2UoZSk6dGhpcy5jb21wdXROb21hbChlKX1jb21wdXROb21hbChlKXtsZXQgdD10aGlzLndvcmtPcHRpb25zLnRoaWNrbmVzcztjb25zdCByPWUubWFwKGk9Pih0PU1hdGgubWF4KHQsaS5yYWRpdXMpLGkucG9pbnQpKTtyZXR1cm57cHM6cixyZWN0OlZ0KHIsdCl9fWNvbXB1dFN0cm9rZShlKXtyZXR1cm4gZS5sZW5ndGg9PT0xP3RoaXMuY29tcHV0RG90U3Ryb2tlKGVbMF0pOnRoaXMuY29tcHV0TGluZVN0cm9rZShlKX1jb21wdXRMaW5lU3Ryb2tlKGUpe2NvbnN0IHQ9W10scj1bXTtmb3IobGV0IGE9MDthPGUubGVuZ3RoO2ErKyl7Y29uc3R7cG9pbnQ6YyxyYWRpdXM6eH09ZVthXTtsZXQgZj1jLnY7YT09PTAmJmUubGVuZ3RoPjEmJihmPWVbYSsxXS5wb2ludC52KTtjb25zdCB2PWh0LlBlcihmKS5tdWwoeCk7dC5wdXNoKEx0LlN1YihjLHYpKSxyLnB1c2goTHQuQWRkKGMsdikpfWNvbnN0IGk9ZVtlLmxlbmd0aC0xXSxoPUx0LkdldFNlbWljaXJjbGVTdHJva2UoaS5wb2ludCx0W3QubGVuZ3RoLTFdLC0xLDgpLGc9THQuR2V0U2VtaWNpcmNsZVN0cm9rZShlWzBdLnBvaW50LHJbMF0sLTEsOCksdT10LmNvbmNhdChoLHIucmV2ZXJzZSgpLGcpO3JldHVybntwczp1LHJlY3Q6VnQodSl9fWNvbXB1dERvdFN0cm9rZShlKXtjb25zdHtwb2ludDp0LHJhZGl1czpyfT1lLGk9e3g6dC54LXIseTp0Lnktcix3OnIqMixoOnIqMn07cmV0dXJue3BzOkx0LkdldERvdFN0cm9rZSh0LHIsOCkscmVjdDppfX10cmFuc2Zvcm1EYXRhKGUsdCl7Y29uc3R7b3A6cix3b3JrU3RhdGU6aX09ZTtsZXQgaD10aGlzLnRtcFBvaW50cy5sZW5ndGgtMSxnPVtdO2lmKHIhPW51bGwmJnIubGVuZ3RoJiZpKXtjb25zdHtzdHJva2VUeXBlOnUsdGhpY2tuZXNzOmF9PXRoaXMud29ya09wdGlvbnMsYz1uZXcgU2V0O2g9dT09PUR0LlN0cm9rZT90aGlzLnVwZGF0ZVRlbXBQb2ludHNXaXRoUHJlc3N1cmUocixhLGMpOnRoaXMudXBkYXRlVGVtcFBvaW50cyhyLGEsYyk7Y29uc3QgeD10P3RoaXMudG1wUG9pbnRzOnRoaXMudG1wUG9pbnRzLnNsaWNlKGgpO3JldHVybiBnPXRoaXMuZ2V0VGFza1BvaW50cyh4LGEpLHt0YXNrczpnLGVmZmVjdHM6Yyxjb25zdW1lSW5kZXg6aH19cmV0dXJue3Rhc2tzOmcsY29uc3VtZUluZGV4Omh9fWNvbXB1dFJhZGl1cyhlLHQpe3JldHVybiBlKi4zK3QqLjV9Z2V0VGFza1BvaW50cyhlLHQpe3ZhciB4O2NvbnN0IHI9W107aWYoZS5sZW5ndGg9PT0wKXJldHVybltdO2xldCBpPTAsaD1lWzBdLngsZz1lWzBdLnksdT1baCxnXSxhPVtdLGM9ZVswXS50O2Zvcig7aTxlLmxlbmd0aDspe2NvbnN0IGY9ZVtpXSx2PWYueC1oLHA9Zi55LWcsQz1mLnosTT10P3RoaXMuY29tcHV0UmFkaXVzKEMsdCk6Zi56O2lmKGEucHVzaCh7cG9pbnQ6bmV3IEx0KHYscCxDLGVbaV0udikscmFkaXVzOk19KSxpPjAmJmk8ZS5sZW5ndGgtMSl7Y29uc3QgbT1lW2ldLmdldEFuZ2xlQnlQb2ludHMoZVtpLTFdLGVbaSsxXSk7aWYobTw5MHx8bT4yNzApe2NvbnN0IHk9KHg9YS5wb3AoKSk9PW51bGw/dm9pZCAwOngucG9pbnQuY2xvbmUoKTt5JiZyLnB1c2goe3Rhc2tJZDpjLHBvczp1LHBvaW50czpbLi4uYSx7cG9pbnQ6eSxyYWRpdXM6TX1dfSksaD1lW2ldLngsZz1lW2ldLnksdT1baCxnXTtjb25zdCBuPWYueC1oLG89Zi55LWc7YT1be3BvaW50Om5ldyBMdChuLG8sQykscmFkaXVzOk19XSxjPURhdGUubm93KCl9fWkrK31yZXR1cm4gci5wdXNoKHt0YXNrSWQ6Yyxwb3M6dSxwb2ludHM6YX0pLHJ9dXBkYXRlVGVtcFBvaW50c1dpdGhQcmVzc3VyZShlLHQscil7Y29uc3QgaT1EYXRlLm5vdygpLGg9dGhpcy50bXBQb2ludHMubGVuZ3RoO2xldCBnPWg7Zm9yKGxldCBhPTA7YTxlLmxlbmd0aDthKz0yKXtnPU1hdGgubWluKGcsaCk7Y29uc3QgYz10aGlzLnRtcFBvaW50cy5sZW5ndGgseD1uZXcgTHQoZVthXSxlW2ErMV0pO2lmKGM9PT0wKXt0aGlzLnRtcFBvaW50cy5wdXNoKHgpO2NvbnRpbnVlfWNvbnN0IGY9Yy0xLHY9dGhpcy50bXBQb2ludHNbZl0scD1odC5TdWIoeCx2KS51bmkoKTtpZih4LmlzTmVhcih2LHQpKXtpZih2Lno8dGhpcy5NQVhfUkVQRUFSKXtpZih2LnNldHooTWF0aC5taW4odi56KzEsdGhpcy5NQVhfUkVQRUFSKSksZz1NYXRoLm1pbihnLGYpLGM+MSl7bGV0IG09Yy0xO2Zvcig7bT4wOyl7Y29uc3QgeT10aGlzLnRtcFBvaW50c1ttXS5kaXN0YW5jZSh0aGlzLnRtcFBvaW50c1ttLTFdKSxuPU1hdGgubWF4KHRoaXMudG1wUG9pbnRzW21dLnotdGhpcy51bmlUaGlja25lc3MqeSwwKTtpZih0aGlzLnRtcFBvaW50c1ttLTFdLno+PW4pYnJlYWs7dGhpcy50bXBQb2ludHNbbS0xXS5zZXR6KG4pLGc9TWF0aC5taW4oZyxtLTEpLG0tLX19fWVsc2UgZz0xLzA7Y29udGludWV9eC5zZXR2KHApO2NvbnN0IEM9eC5kaXN0YW5jZSh2KSxNPU1hdGgubWF4KHYuei10aGlzLnVuaVRoaWNrbmVzcypDLDApO2M+MSYmaHQuRXF1YWxzKHAsdi52LC4wMikmJihNPjB8fHYuejw9MCkmJihyJiZ2LnQmJnIuYWRkKHYudCksdGhpcy50bXBQb2ludHMucG9wKCksZz1NYXRoLm1pbihmLGcpKSx4LnNldHooTSksdGhpcy50bXBQb2ludHMucHVzaCh4KX1pZihnPT09MS8wKXJldHVybiB0aGlzLnRtcFBvaW50cy5sZW5ndGg7bGV0IHU9aDtpZihnPT09aCl7dT1NYXRoLm1heCh1LTEsMCk7Y29uc3QgYT10aGlzLnRtcFBvaW50c1t1XS50O2EmJihyPT1udWxsfHxyLmFkZChhKSl9ZWxzZXtsZXQgYT1oLTE7Zm9yKHU9ZzthPj0wOyl7Y29uc3QgYz10aGlzLnRtcFBvaW50c1thXS50O2lmKGMmJihyPT1udWxsfHxyLmFkZChjKSxhPD1nKSl7dT1hLGE9LTE7YnJlYWt9YS0tfX1yZXR1cm4gdGhpcy50bXBQb2ludHNbdV0uc2V0VChpKSx1fXVwZGF0ZVRlbXBQb2ludHMoZSx0LHIpe3ZhciBhO2NvbnN0IGk9RGF0ZS5ub3coKSxoPXRoaXMudG1wUG9pbnRzLmxlbmd0aDtsZXQgZz1oO2ZvcihsZXQgYz0wO2M8ZS5sZW5ndGg7Yys9Mil7Y29uc3QgeD10aGlzLnRtcFBvaW50cy5sZW5ndGgsZj1uZXcgTHQoZVtjXSxlW2MrMV0pO2lmKHg9PT0wKXt0aGlzLnRtcFBvaW50cy5wdXNoKGYpO2NvbnRpbnVlfWNvbnN0IHY9eC0xLHA9dGhpcy50bXBQb2ludHNbdl0sQz1odC5TdWIoZixwKS51bmkoKTtpZihodC5FcXVhbHMoQyxwLnYsLjAyKSl7ciYmcC50JiZyLmFkZChwLnQpLHRoaXMudG1wUG9pbnRzLnBvcCgpLGc9TWF0aC5taW4odixnKTtjb250aW51ZX1pZihmLmlzTmVhcihwLHQvMikpe2c9TWF0aC5taW4odixnKTtjb250aW51ZX1mLnNldHYoQyksdGhpcy50bXBQb2ludHMucHVzaChmKX1sZXQgdT1oO2lmKGc9PT1oKXt1PU1hdGgubWF4KHUtMSwwKTtjb25zdCBjPXRoaXMudG1wUG9pbnRzW3VdLnQ7YyYmKHI9PW51bGx8fHIuYWRkKGMpKX1lbHNle2xldCBjPU1hdGgubWluKGgtMSxnKTtmb3IodT1nO2M+PTA7KXtjb25zdCB4PShhPXRoaXMudG1wUG9pbnRzW2NdKT09bnVsbD92b2lkIDA6YS50O2lmKHgmJihyPT1udWxsfHxyLmFkZCh4KSxjPD1nKSl7dT1jLGM9LTE7YnJlYWt9Yy0tfX1yZXR1cm4gdGhpcy50bXBQb2ludHNbdV0uc2V0VChpKSx1fXVwZGF0ZVRlbXBQb2ludHNXaXRoUHJlc3N1cmVXaGVuRG9uZShlKXtjb25zdHt0aGlja25lc3M6dH09dGhpcy53b3JrT3B0aW9ucztmb3IobGV0IHI9MDtyPGUubGVuZ3RoO3IrPTIpe2NvbnN0IGk9dGhpcy50bXBQb2ludHMubGVuZ3RoLGg9bmV3IEx0KGVbcl0sZVtyKzFdKTtpZihpPT09MCl7dGhpcy50bXBQb2ludHMucHVzaChoKTtjb250aW51ZX1jb25zdCBnPWktMSx1PXRoaXMudG1wUG9pbnRzW2ddLGE9aHQuU3ViKGgsdSkudW5pKCk7aWYoaC5pc05lYXIodSx0LzQpKXtpZih1Lno8dGhpcy5NQVhfUkVQRUFSJiYodS5zZXR6KE1hdGgubWluKHUueisxLHRoaXMuTUFYX1JFUEVBUikpLGk+MSkpe2xldCBmPWktMTtmb3IoO2Y+MDspe2NvbnN0IHY9dGhpcy50bXBQb2ludHNbZl0uZGlzdGFuY2UodGhpcy50bXBQb2ludHNbZi0xXSkscD1NYXRoLm1heCh0aGlzLnRtcFBvaW50c1tmXS56LXRoaXMudW5pVGhpY2tuZXNzKnYsLXQvNCk7aWYodGhpcy50bXBQb2ludHNbZi0xXS56Pj1wKWJyZWFrO3RoaXMudG1wUG9pbnRzW2YtMV0uc2V0eihwKSxmLS19fWNvbnRpbnVlfWguc2V0dihhKTtjb25zdCBjPWguZGlzdGFuY2UodSkseD1NYXRoLm1heCh1LnotdGhpcy51bmlUaGlja25lc3MqNSpjLC10LzIpO2k+MSYmaHQuRXF1YWxzKGEsdS52LC4wMikmJnUuejw9MCYmdGhpcy50bXBQb2ludHMucG9wKCksaC5zZXR6KHgpLHRoaXMudG1wUG9pbnRzLnB1c2goaCl9fXVwZGF0YU9wdFNlcnZpY2UoZSl7dmFyIGk7bGV0IHQ7Y29uc3Qgcj0oaT10aGlzLndvcmtJZCk9PW51bGw/dm9pZCAwOmkudG9TdHJpbmcoKTtpZihyJiZlKXtjb25zdCBoPXRoaXMuZnVsbExheWVyLmdldEVsZW1lbnRzQnlOYW1lKHIpLHtwb3M6Zyx6SW5kZXg6dSxjb2xvcjphLHNjYWxlOmMsYW5nbGU6eCxvcGFjaXR5OmZ9PWUsdj17fTtpZih0eXBlb2YgdT09Im51bWJlciImJih2LnpJbmRleD11KSxnJiYodi5wb3M9W2dbMF0sZ1sxXV0saFswXSkpe2NvbnN0IHA9aFswXS5jbGFzc05hbWUuc3BsaXQoIiwiKTt2LmNsYXNzTmFtZT1gJHtnWzBdfSwke2dbMV19LCR7cFsyXX1gfXJldHVybiBhJiYodi5zdHJva2VDb2xvcj1hKSxjJiYodi5zY2FsZT1jKSxmJiYodi5vcGFjaXR5PWYpLHgmJih2LnJvdGF0ZT14KSxPYmplY3Qua2V5cyh2KS5sZW5ndGgmJmguZm9yRWFjaChwPT57Y29uc3QgQz1wLmF0dHIoImZpbGxDb2xvciIpO2EmJkM/cC5hdHRyKHsuLi52LGZpbGxDb2xvcjphfSk6cC5hdHRyKHYpO2NvbnN0IE09cD09bnVsbD92b2lkIDA6cC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtNJiYodD1QdCh0LHt4Ok1hdGguZmxvb3IoTS54LUl0LlBlbmNpbEJvcmRlclBhZGRpbmcpLHk6TWF0aC5mbG9vcihNLnktSXQuUGVuY2lsQm9yZGVyUGFkZGluZyksdzpNYXRoLmZsb29yKE0ud2lkdGgrSXQuUGVuY2lsQm9yZGVyUGFkZGluZyoyKSxoOk1hdGguZmxvb3IoTS5oZWlnaHQrSXQuUGVuY2lsQm9yZGVyUGFkZGluZyoyKX0pKX0pLHR9fX1PYmplY3QuZGVmaW5lUHJvcGVydHkoSXQsIlBlbmNpbEJvcmRlclBhZGRpbmciLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZToxMH0pO3ZhciBJZT1zZTtzZS5wb2x5bGluZT1zZSxzZS5wb2x5Z29uPU5lO2Z1bmN0aW9uIHNlKFMsZSx0KXt2YXIgcj1TLmxlbmd0aCxpPVF0KFNbMF0sZSksaD1bXSxnLHUsYSxjLHg7Zm9yKHR8fCh0PVtdKSxnPTE7ZzxyO2crKyl7Zm9yKHU9U1tnLTFdLGE9U1tnXSxjPXg9UXQoYSxlKTs7KWlmKGl8Yyl7aWYoaSZjKWJyZWFrO2k/KHU9dWUodSxhLGksZSksaT1RdCh1LGUpKTooYT11ZSh1LGEsYyxlKSxjPVF0KGEsZSkpfWVsc2V7aC5wdXNoKHUpLGMhPT14PyhoLnB1c2goYSksZzxyLTEmJih0LnB1c2goaCksaD1bXSkpOmc9PT1yLTEmJmgucHVzaChhKTticmVha31pPXh9cmV0dXJuIGgubGVuZ3RoJiZ0LnB1c2goaCksdH1mdW5jdGlvbiBOZShTLGUpe3ZhciB0LHIsaSxoLGcsdSxhO2ZvcihyPTE7cjw9ODtyKj0yKXtmb3IodD1bXSxpPVNbUy5sZW5ndGgtMV0saD0hKFF0KGksZSkmciksZz0wO2c8Uy5sZW5ndGg7ZysrKXU9U1tnXSxhPSEoUXQodSxlKSZyKSxhIT09aCYmdC5wdXNoKHVlKGksdSxyLGUpKSxhJiZ0LnB1c2godSksaT11LGg9YTtpZihTPXQsIVMubGVuZ3RoKWJyZWFrfXJldHVybiB0fWZ1bmN0aW9uIHVlKFMsZSx0LHIpe3JldHVybiB0Jjg/W1NbMF0rKGVbMF0tU1swXSkqKHJbM10tU1sxXSkvKGVbMV0tU1sxXSksclszXV06dCY0P1tTWzBdKyhlWzBdLVNbMF0pKihyWzFdLVNbMV0pLyhlWzFdLVNbMV0pLHJbMV1dOnQmMj9bclsyXSxTWzFdKyhlWzFdLVNbMV0pKihyWzJdLVNbMF0pLyhlWzBdLVNbMF0pXTp0JjE/W3JbMF0sU1sxXSsoZVsxXS1TWzFdKSooclswXS1TWzBdKS8oZVswXS1TWzBdKV06bnVsbH1mdW5jdGlvbiBRdChTLGUpe3ZhciB0PTA7cmV0dXJuIFNbMF08ZVswXT90fD0xOlNbMF0+ZVsyXSYmKHR8PTIpLFNbMV08ZVsxXT90fD00OlNbMV0+ZVszXSYmKHR8PTgpLHR9dmFyIEJlPURlKEllKTtjbGFzcyBZdCBleHRlbmRzIGVle3VwZGF0YU9wdFNlcnZpY2UoKXt9Y29uc3RydWN0b3IoZSx0KXtzdXBlcih0KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywic3luY1RpbWVzdGFtcCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ0b29sc1R5cGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpTdC5FcmFzZXJ9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidG1wUG9pbnRzIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6W119KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywid29ya09wdGlvbnMiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywicmVtb3ZlSWRzIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6W119KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywid29ybGRQb3NpdGlvbiIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ3b3JsZFNjYWxpbmciLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiZXJhc2VyUmVjdCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJlcmFzZXJQb2x5bGluZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJjdXJOb2RlTWFwIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6bmV3IE1hcH0pLHRoaXMud29ya09wdGlvbnM9ZSx0aGlzLnN5bmNUaW1lc3RhbXA9MCx0aGlzLndvcmxkUG9zaXRpb249dGhpcy5mdWxsTGF5ZXIud29ybGRQb3NpdGlvbix0aGlzLndvcmxkU2NhbGluZz10aGlzLmZ1bGxMYXllci53b3JsZFNjYWxpbmd9Y29tcHV0Tm9kZU1hcChlKXt0aGlzLmN1ck5vZGVNYXAuY2xlYXIoKSxlLmZvckVhY2godD0+e2NvbnN0IHI9dGhpcy5mdWxsTGF5ZXIuZ2V0RWxlbWVudHNCeU5hbWUodC5uYW1lKVswXSxpPXQub3BzJiZxdCh0Lm9wcyk7aWYociYmaS5sZW5ndGgpe2NvbnN0IGg9W107Zm9yKGxldCB1PTA7dTxpLmxlbmd0aDt1Kz0zKXtjb25zdCBhPW5ldyBodChpW3VdKnRoaXMud29ybGRTY2FsaW5nWzBdK3RoaXMud29ybGRQb3NpdGlvblswXSxpW3UrMV0qdGhpcy53b3JsZFNjYWxpbmdbMV0rdGhpcy53b3JsZFBvc2l0aW9uWzFdLGlbdSsyXSk7aC5wdXNoKGEpfWxldCBnPXQub3B0O2lmKCFnKXtsZXQgdT1yLmdldEF0dHJpYnV0ZSgic3Ryb2tlQ29sb3IiKTtjb25zdCBhPXIuY2xhc3NOYW1lLnNwbGl0KCIsIiksYz1OdW1iZXIoYVsyXSk7ci50YWdOYW1lPT09IkdST1VQIiYmKGM9PT1EdC5TdHJva2U/dT1yLmdldEF0dHJpYnV0ZSgiYmdjb2xvciIpOnU9ci5jaGlsZHJlblswXS5nZXRBdHRyaWJ1dGUoInN0cm9rZUNvbG9yIikpO2NvbnN0IHg9ci5nZXRBdHRyaWJ1dGUoIm9wYWNpdHkiKSxmPXIuZ2V0QXR0cmlidXRlKCJzY2FsZSIpLHY9ci5nZXRBdHRyaWJ1dGUoInpJbmRleCIpLHA9ci5nZXRBdHRyaWJ1dGUoInJvdGF0ZSIpLEM9dGhpcy53b3JrT3B0aW9ucy5zeW5jVW5pdFRpbWU7Zz17Y29sb3I6dSxvcGFjaXR5Ongsc3luY1VuaXRUaW1lOkMsekluZGV4OnYsc2NhbGU6Zixyb3RhdGU6cCxzdHJva2VUeXBlOmN9fXRoaXMuY3VyTm9kZU1hcC5zZXQodC5uYW1lLHtuYW1lOnQubmFtZSxyZWN0OnQucmVjdCxwb2x5bGluZTpoLG9wdDpnLHRvb2xzVHlwZTp0LnRvb2xzVHlwZXx8U3QuUGVuY2lsfSl9fSl9dXBkYXRhTm9kZU1hcChlLHQpe2NvbnN0IHI9dC5vcCxpPVtdO2ZvcihsZXQgaD0wO2g8ci5sZW5ndGg7aCs9Myl7Y29uc3QgZz1uZXcgaHQocltoXSp0aGlzLndvcmxkU2NhbGluZ1swXSt0aGlzLndvcmxkUG9zaXRpb25bMF0scltoKzFdKnRoaXMud29ybGRTY2FsaW5nWzFdK3RoaXMud29ybGRQb3NpdGlvblsxXSxyW2grMl0pO2kucHVzaChnKX10aGlzLmN1ck5vZGVNYXAuc2V0KGUse25hbWU6dC5uYW1lLHJlY3Q6dC5yZWN0LHBvbHlsaW5lOmksb3B0OnQub3B0LHRvb2xzVHlwZTp0LnRvb2xzVHlwZXx8U3QuUGVuY2lsfSl9Y29tYmluZUNvbnN1bWUoKXt9Y3JlYXRlRXJhc2VyUmVjdChlKXtjb25zdCB0PWVbMF0qdGhpcy53b3JsZFNjYWxpbmdbMF0rdGhpcy53b3JsZFBvc2l0aW9uWzBdLHI9ZVsxXSp0aGlzLndvcmxkU2NhbGluZ1sxXSt0aGlzLndvcmxkUG9zaXRpb25bMV0se3dpZHRoOmksaGVpZ2h0Omh9PVl0LmVyYXNlclNpemVzW3RoaXMud29ya09wdGlvbnMudGhpY2tuZXNzXTt0aGlzLmVyYXNlclJlY3Q9e3g6dC1pKi41LHk6ci1oKi41LHc6aSxofSx0aGlzLmVyYXNlclBvbHlsaW5lPVt0aGlzLmVyYXNlclJlY3QueCx0aGlzLmVyYXNlclJlY3QueSx0aGlzLmVyYXNlclJlY3QueCt0aGlzLmVyYXNlclJlY3Qudyx0aGlzLmVyYXNlclJlY3QueSt0aGlzLmVyYXNlclJlY3QuaF19Y29uc3VtZVNlcnZpY2UoKXt9c2V0V29ya09wdGlvbnMoZSl7c3VwZXIuc2V0V29ya09wdGlvbnMoZSksdGhpcy5zeW5jVGltZXN0YW1wPURhdGUubm93KCl9Y29uc3VtZShlKXtjb25zdHtvcDp0LHdvcmtTdGF0ZTpyfT1lLmRhdGE7aWYoIXR8fHQubGVuZ3RoPT09MClyZXR1cm57dHlwZTpwdC5Ob25lfTtpZihyPT09d3QuU3RhcnQmJmUubm9kZU1hcHMmJnRoaXMuY29tcHV0Tm9kZU1hcChlLm5vZGVNYXBzKSx0aGlzLmlzU2FtZVBvaW50KFt0WzBdLHRbMV1dLFt0aGlzLnRtcFBvaW50c1swXSx0aGlzLnRtcFBvaW50c1sxXV0pKXJldHVybnt0eXBlOnB0Lk5vbmV9O2lmKGUubm9kZU1hcHMpe3RoaXMudG1wUG9pbnRzPXQsdGhpcy5jcmVhdGVFcmFzZXJSZWN0KHQpO2NvbnN0e3JlY3Q6aSxyZW1vdmVJZHM6aCxuZXdXb3JrRGF0YXM6Z309dGhpcy5yZW1vdmUoKTtpZihpJiZoLmxlbmd0aClyZXR1cm57dHlwZTpwdC5SZW1vdmVOb2RlLGRhdGFUeXBlOkF0LkxvY2FsLHJlY3Q6aSxyZW1vdmVJZHM6aCxuZXdXb3JrRGF0YXM6Z319cmV0dXJue3R5cGU6cHQuTm9uZX19Y3V0UG9seWxpbmUoZSx0KXtsZXQgcj1bdF0saT0wO2Zvcig7aTxlLmxlbmd0aDspe2NvbnN0IHU9ZVtpXTtpZih1Lmxlbmd0aDwyKWJyZWFrO3I9aChyLHUpLGkrK31yZXR1cm4gcjtmdW5jdGlvbiBoKHUsYSl7Y29uc3QgYz11O2ZvcihsZXQgeD0wO3g8dS5sZW5ndGg7eCsrKXtjb25zdCBmPXVbeF0sdj1mLmZpbmRJbmRleCgocCxDKT0+QzxmLmxlbmd0aC0xP2coW3AsZltDKzFdXSxbYVswXSxhWzFdXSk6ITEpO2lmKHYhPT0tMSYmdj4tMSl7Y29uc3QgcD1bXSxDPWYuc2xpY2UoMCx2KzEpO2lmKGh0LkVxdWFscyhmW3ZdLGFbMF0pfHxDLnB1c2goYVswXS5jbG9uZSgpLnNldHooZlt2XS56KSksQy5sZW5ndGg+MSYmcC5wdXNoKEMpLHYrYS5sZW5ndGgtMTxmLmxlbmd0aC0xKXtjb25zdCBNPXYrYS5sZW5ndGgtMSxtPWYuc2xpY2UoTSkseT1hW2EubGVuZ3RoLTFdO2h0LkVxdWFscyhmW01dLHkpfHxtLnVuc2hpZnQoeS5jbG9uZSgpLnNldHooZltNXS56KSksbS5sZW5ndGg+MSYmcC5wdXNoKG0pfXJldHVybiBjLnNwbGljZSh4LDEsLi4ucCksY319cmV0dXJuIGN9ZnVuY3Rpb24gZyh1LGEpe2NvbnN0IGM9aHQuU3ViKHVbMV0sdVswXSkseD1odC5TdWIoYVsxXSxhWzBdKSxmPWh0LlN1YihhWzBdLHVbMF0pO3JldHVybiBNYXRoLmFicyhodC5DcHIoYyx4KSk8LjEmJk1hdGguYWJzKGh0LkNwcihjLGYpKTwuMX19aXNTYW1lUG9pbnQoZSx0KXtyZXR1cm4gZVswXT09PXRbMF0mJmVbMV09PT10WzFdfXRyYW5zbGF0ZUludGVyc2VjdChlKXtjb25zdCB0PVtdO2ZvcihsZXQgcj0wO3I8ZS5sZW5ndGg7cisrKXtjb25zdCBpPWVbcl0uZmlsdGVyKCh1LGEsYyk9PiEoYT4wJiZ0aGlzLmlzU2FtZVBvaW50KHUsY1thLTFdKSkpLGg9W107bGV0IGc9MDtmb3IoO2c8aS5sZW5ndGg7KXtjb25zdCB1PWlbZ10sYT1uZXcgaHQodVswXSx1WzFdKTtoLnB1c2goYSksZysrfXQucHVzaChoKX1yZXR1cm4gdH1yZW1vdmUoKXtjb25zdHtpc0xpbmU6ZX09dGhpcy53b3JrT3B0aW9ucztsZXQgdDtjb25zdCByPVtdLGk9W10saD1bXTtyZXR1cm4gdGhpcy5jdXJOb2RlTWFwLmZvckVhY2goKGcsdSk9Pntjb25zdCBhPXRoaXMuZnVsbExheWVyLmdldEVsZW1lbnRzQnlOYW1lKGcubmFtZSlbMF07aWYoYSYmZy5yZWN0JiZ0aGlzLmVyYXNlclJlY3QmJnRoaXMuZXJhc2VyUG9seWxpbmUmJmxlKHRoaXMuZXJhc2VyUmVjdCxnLnJlY3QpKXtpZihnLnBvbHlsaW5lLmxlbmd0aD4xKXtjb25zdCBjPUJlLnBvbHlsaW5lKGcucG9seWxpbmUubWFwKHg9PnguWFkpLHRoaXMuZXJhc2VyUG9seWxpbmUpO2lmKGMubGVuZ3RoJiYoaS5wdXNoKGEpLHIucHVzaChnLm5hbWUpLHRoaXMucmVtb3ZlSWRzLnB1c2goZy5uYW1lKSwhZSkpe2NvbnN0IHg9dGhpcy50cmFuc2xhdGVJbnRlcnNlY3QoYyksZj10aGlzLmN1dFBvbHlsaW5lKHgsZy5wb2x5bGluZSk7Zm9yKGxldCB2PTA7djxmLmxlbmd0aDt2Kyspe2NvbnN0IHA9YCR7dX1fc18ke3Z9YCxDPVtdO2Zbdl0uZm9yRWFjaChNPT57Qy5wdXNoKChNLngtdGhpcy53b3JsZFBvc2l0aW9uWzBdKS90aGlzLndvcmxkU2NhbGluZ1swXSwoTS55LXRoaXMud29ybGRQb3NpdGlvblsxXSkvdGhpcy53b3JsZFNjYWxpbmdbMV0sTS56KX0pLGgucHVzaCh7d29ya0lkOnAsb3A6QyxvcHQ6Zy5vcHQsdG9vbHNUeXBlOmcudG9vbHNUeXBlfSl9fX1lbHNlIGkucHVzaChhKSxyLnB1c2goZy5uYW1lKSx0aGlzLnJlbW92ZUlkcy5wdXNoKGcubmFtZSk7dD1QdCh0LGcucmVjdCl9fSksaS5mb3JFYWNoKGc9PmcucmVtb3ZlKCkpLHQmJih0LngtPVl0LlNhZmVCb3JkZXJQYWRkaW5nLHQueS09WXQuU2FmZUJvcmRlclBhZGRpbmcsdC53Kz1ZdC5TYWZlQm9yZGVyUGFkZGluZyoyLHQuaCs9WXQuU2FmZUJvcmRlclBhZGRpbmcqMikse3JlY3Q6dCxyZW1vdmVJZHM6cixuZXdXb3JrRGF0YXM6aH19Y29uc3VtZUFsbChlKXtyZXR1cm4gdGhpcy5jb25zdW1lKGUpfWNsZWFyVG1wUG9pbnRzKCl7dGhpcy50bXBQb2ludHMubGVuZ3RoPTAsdGhpcy5zeW5jVGltZXN0YW1wPTB9fU9iamVjdC5kZWZpbmVQcm9wZXJ0eShZdCwiU2FmZUJvcmRlclBhZGRpbmciLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZToxMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShZdCwiZXJhc2VyU2l6ZXMiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpPYmplY3QuZnJlZXplKFtPYmplY3QuZnJlZXplKHt3aWR0aDoxOCxoZWlnaHQ6MjZ9KSxPYmplY3QuZnJlZXplKHt3aWR0aDoyNixoZWlnaHQ6MzR9KSxPYmplY3QuZnJlZXplKHt3aWR0aDozNCxoZWlnaHQ6NTB9KV0pfSk7ZnVuY3Rpb24gamUoUyxlLHQpe3JldHVybiIjIisoKFM8PDE2KSsoZTw8OCkrdCkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDYsIjAiKX1mdW5jdGlvbiBXZShTKXtjb25zdCBlPVMuc3BsaXQoIiwiKSx0PXBhcnNlSW50KGVbMF0uc3BsaXQoIigiKVsxXSkscj1wYXJzZUludChlWzFdKSxpPXBhcnNlSW50KGVbMl0pLGg9cGFyc2VJbnQoZVszXS5zcGxpdCgiKSIpWzBdKTtyZXR1cm5bamUodCxyLGkpLGhdfWNsYXNzIHZ0IGV4dGVuZHMgZWV7dXBkYXRhT3B0U2VydmljZSgpe31jb25zdHJ1Y3RvcihlLHQscil7c3VwZXIodCxyKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidG1wUG9pbnRzIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6W119KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidG9vbHNUeXBlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6U3QuU2VsZWN0b3J9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywid29ya09wdGlvbnMiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywic3luY1RpbWVzdGFtcCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJjdXJOb2RlTWFwIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6bmV3IE1hcH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzZWxlY3RJZHMiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywib2xkUmVjdCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJub2RlQ29sb3IiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywib2xkU2VsZWN0UmVjdCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ3b3JsZFBvc2l0aW9uIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIndvcmxkU2NhbGluZyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLHRoaXMud29ya09wdGlvbnM9ZSx0aGlzLnN5bmNUaW1lc3RhbXA9MCx0aGlzLndvcmxkUG9zaXRpb249dGhpcy5mdWxsTGF5ZXIud29ybGRQb3NpdGlvbix0aGlzLndvcmxkU2NhbGluZz10aGlzLmZ1bGxMYXllci53b3JsZFNjYWxpbmd9Y29tcHV0Tm9kZU1hcChlKXt0aGlzLmN1ck5vZGVNYXAuY2xlYXIoKSxlLmZvckVhY2godD0+e2NvbnN0IHI9dGhpcy5mdWxsTGF5ZXIuZ2V0RWxlbWVudHNCeU5hbWUodC5uYW1lKVswXTtpZihyKXtjb25zdCBpPXIud29ybGRQb3NpdGlvbjtsZXQgaD1yLmdldEF0dHJpYnV0ZSgic3Ryb2tlQ29sb3IiKTtjb25zdCBnPXIuY2xhc3NOYW1lLnNwbGl0KCIsIik7ci50YWdOYW1lPT09IkdST1VQIiYmKE51bWJlcihnWzJdKT09PUR0LlN0cm9rZT9oPXIuZ2V0QXR0cmlidXRlKCJiZ2NvbG9yIik6aD1yLmNoaWxkcmVuWzBdLmdldEF0dHJpYnV0ZSgic3Ryb2tlQ29sb3IiKSksdGhpcy5jdXJOb2RlTWFwLnNldCh0Lm5hbWUse25hbWU6dC5uYW1lLHJlY3Q6dC5yZWN0LGNvbG9yOldlKGgpWzBdLHBvczppLHJvdGF0ZTpyLmdldEF0dHJpYnV0ZSgicm90YXRlIil8fDAsc2NhbGU6ci5nZXRBdHRyaWJ1dGUoInNjYWxlIil8fFsxLDFdfSl9fSl9Y29tcHV0U2VsZWN0b3IoKXtsZXQgZTtjb25zdCB0PVtdLHI9bmV3IE1hcCxpPW5ldyBTZXQsaD1uZXcgTWFwO2lmKHRoaXMudG1wUG9pbnRzLmxlbmd0aCYmdGhpcy5jdXJOb2RlTWFwLnNpemUpe2NvbnN0IGc9VnQodGhpcy50bXBQb2ludHMpO3RoaXMuY3VyTm9kZU1hcC5mb3JFYWNoKCh1LGEpPT57Y29uc3QgYz17eDp1LnJlY3QueCx5OnUucmVjdC55LHc6dS5yZWN0LncsaDp1LnJlY3QuaH0seD17eDpnLngseTpnLnksdzpnLncsaDpnLmh9O2xlKHgsYykmJih0LnB1c2goYSksZT1QdChlLGMpLHIuc2V0KGEsYyksaS5hZGQodS5jb2xvciksaC5zZXQoYSxbLi4udS5wb3MsdS5yb3RhdGVdKSl9KX1yZXR1cm57c2VsZWN0SWRzOnQsaW50ZXJzZWN0UmVjdDplLHN1YlJlY3RzOnIsbm9kZUNvbG9yczppLHN1YlBvczpofX11cGRhdGVUZW1wUG9pbnRzKGUpe2NvbnN0IHQ9dGhpcy50bXBQb2ludHMubGVuZ3RoLHI9ZS5sZW5ndGg7aWYocj4xKXtjb25zdCBpPW5ldyBMdChlW3ItMl0qdGhpcy53b3JsZFNjYWxpbmdbMF0rdGhpcy53b3JsZFBvc2l0aW9uWzBdLGVbci0xXSp0aGlzLndvcmxkU2NhbGluZ1swXSt0aGlzLndvcmxkUG9zaXRpb25bMV0pO3Q9PT0yP3RoaXMudG1wUG9pbnRzLnNwbGljZSgxLDEsaSk6dGhpcy50bXBQb2ludHMucHVzaChpKX19ZHJhdyhlKXt2YXIgaCxnLHU7Y29uc3R7aW50ZXJzZWN0UmVjdDp0LHN1YlJlY3RzOnIsc3ViUG9zOml9PWU7KHU9KGc9KGg9dGhpcy5kcmF3TGF5ZXIpPT1udWxsP3ZvaWQgMDpoLnBhcmVudCk9PW51bGw/dm9pZCAwOmcuZ2V0RWxlbWVudEJ5SWQodnQuc2VsZWN0b3JJZCkpPT1udWxsfHx1LnJlbW92ZSgpLHQmJnRoaXMuZHJhd0xheWVyJiZ0aGlzLmRyYXdTZWxlY3Rvcih7ZHJhd1JlY3Q6dCxzdWJSZWN0czpyLHN1YlBvczppLHNlbGVjdG9ySWQ6dnQuc2VsZWN0b3JJZCxsYXllcjp0aGlzLmRyYXdMYXllcn0pfWNvbnN1bWUoZSl7Y29uc3R7b3A6dCx3b3JrU3RhdGU6cn09ZS5kYXRhO2lmKHI9PT13dC5TdGFydCYmKHRoaXMub2xkUmVjdD10aGlzLmJhY2tUb0Z1bGxMYXllcigpLGUubm9kZU1hcHMmJnRoaXMuY29tcHV0Tm9kZU1hcChlLm5vZGVNYXBzKSksISh0IT1udWxsJiZ0Lmxlbmd0aCl8fCF0aGlzLmN1ck5vZGVNYXAuc2l6ZSlyZXR1cm57dHlwZTpwdC5Ob25lfTt0aGlzLnVwZGF0ZVRlbXBQb2ludHModCk7Y29uc3QgaT10aGlzLmNvbXB1dFNlbGVjdG9yKCk7aWYodGhpcy5zZWxlY3RJZHMmJkFlKHRoaXMuc2VsZWN0SWRzLGkuc2VsZWN0SWRzKSlyZXR1cm57dHlwZTpwdC5Ob25lfTt0aGlzLnNlbGVjdElkcz1pLnNlbGVjdElkcztjb25zdCBoPXRoaXMuZHJhd0xheWVyJiZ0aGlzLmdldFNlbGVjdG9yUmVjdCh0aGlzLmRyYXdMYXllcix2dC5zZWxlY3RvcklkLCEwKSxnPWkuaW50ZXJzZWN0UmVjdCYme3g6aS5pbnRlcnNlY3RSZWN0LngtdnQuU2VsZWN0Qm9yZGVyUGFkZGluZyx5OmkuaW50ZXJzZWN0UmVjdC55LXZ0LlNlbGVjdEJvcmRlclBhZGRpbmcsdzppLmludGVyc2VjdFJlY3Qudyt2dC5TZWxlY3RCb3JkZXJQYWRkaW5nKjIsaDppLmludGVyc2VjdFJlY3QuaCt2dC5TZWxlY3RCb3JkZXJQYWRkaW5nKjJ9fHx2b2lkIDA7cmV0dXJuIHRoaXMub2xkUmVjdD1QdChoLGcpLHRoaXMuZHJhdyhpKSx0aGlzLm5vZGVDb2xvcj1pLm5vZGVDb2xvcnMuc2l6ZT09PTE/aS5ub2RlQ29sb3JzLnZhbHVlcygpLm5leHQoKS52YWx1ZTp2b2lkIDAsdGhpcy5vbGRTZWxlY3RSZWN0PWcse3R5cGU6cHQuU2VsZWN0LGRhdGFUeXBlOkF0LkxvY2FsLHJlY3Q6dGhpcy5vbGRSZWN0LHNlbGVjdElkczppLnNlbGVjdElkcyxvcHQ6dGhpcy53b3JrT3B0aW9ucyxwYWRkaW5nOnZ0LlNlbGVjdEJvcmRlclBhZGRpbmcsc2VsZWN0UmVjdDpnLG5vZGVDb2xvcjp0aGlzLm5vZGVDb2xvcix3aWxsU3luY1NlcnZpY2U6ITB9fWNvbnN1bWVBbGwoKXt2YXIgZTtyZXR1cm4oZT10aGlzLnNlbGVjdElkcykhPW51bGwmJmUubGVuZ3RoJiZ0aGlzLnNlYWxUb0RyYXdMYXllcigpLHRoaXMub2xkU2VsZWN0UmVjdD97dHlwZTpwdC5TZWxlY3QsZGF0YVR5cGU6QXQuTG9jYWwscmVjdDp0aGlzLm9sZFJlY3Qsc2VsZWN0SWRzOnRoaXMuc2VsZWN0SWRzLG9wdDp0aGlzLndvcmtPcHRpb25zLHBhZGRpbmc6dnQuU2VsZWN0Qm9yZGVyUGFkZGluZyxzZWxlY3RSZWN0OnRoaXMub2xkU2VsZWN0UmVjdCxub2RlQ29sb3I6dGhpcy5ub2RlQ29sb3Isd2lsbFN5bmNTZXJ2aWNlOiExfTp7dHlwZTpwdC5Ob25lfX1jb25zdW1lU2VydmljZSgpe31jb21iaW5lQ29uc3VtZSgpe31jbGVhclRtcFBvaW50cygpe3RoaXMudG1wUG9pbnRzLmxlbmd0aD0wfWNsZWFyU2VsZWN0RGF0YSgpe3RoaXMuc2VsZWN0SWRzPXZvaWQgMCx0aGlzLm9sZFJlY3Q9dm9pZCAwLHRoaXMub2xkU2VsZWN0UmVjdD12b2lkIDB9YmFja1RvRnVsbExheWVyKCl7dmFyIGk7bGV0IGU7Y29uc3QgdD1bXSxyPVtdO3JldHVybihpPXRoaXMuZHJhd0xheWVyKT09bnVsbHx8aS5jaGlsZHJlbi5mb3JFYWNoKGg9PntpZihoLmlkIT09dnQuc2VsZWN0b3JJZCl7Y29uc3QgZz1oLmNsb25lTm9kZSghMCk7aWYoZy50YWdOYW1lPT09IkdST1VQIil7Y29uc3QgYT1oLmNsYXNzTmFtZS5zcGxpdCgiLCIpO2EubGVuZ3RoPT09MyYmTnVtYmVyKGFbMl0pPT09RHQuU3Ryb2tlJiZnLnNlYWwoKX10LnB1c2goZyksci5wdXNoKGgpO2NvbnN0IHU9S3QoaC5uYW1lLHRoaXMuZHJhd0xheWVyKTt1JiYoZT1QdChlLHUpKX19KSxyLmZvckVhY2goaD0+aC5yZW1vdmUoKSksdC5sZW5ndGgmJnRoaXMuZnVsbExheWVyLmFwcGVuZCguLi50KSxlJiYoZS54LT12dC5TZWxlY3RCb3JkZXJQYWRkaW5nLGUueS09dnQuU2VsZWN0Qm9yZGVyUGFkZGluZyxlLncrPXZ0LlNlbGVjdEJvcmRlclBhZGRpbmcqMixlLmgrPXZ0LlNlbGVjdEJvcmRlclBhZGRpbmcqMiksZX1zZWFsVG9EcmF3TGF5ZXIoKXt2YXIgcixpO2NvbnN0IGU9W10sdD1bXTsocj10aGlzLnNlbGVjdElkcyk9PW51bGx8fHIuZm9yRWFjaChoPT57dGhpcy5mdWxsTGF5ZXIuZ2V0RWxlbWVudHNCeU5hbWUoaC50b1N0cmluZygpKS5mb3JFYWNoKGc9Pntjb25zdCB1PWcuY2xvbmVOb2RlKCEwKTtpZih1LnRhZ05hbWU9PT0iR1JPVVAiKXtjb25zdCBhPWcuY2xhc3NOYW1lLnNwbGl0KCIsIik7YS5sZW5ndGg9PT0zJiZOdW1iZXIoYVsyXSk9PT1EdC5TdHJva2UmJnUuc2VhbCgpfWUucHVzaCh1KSx0LnB1c2goZyl9KX0pLHQuZm9yRWFjaChoPT5oLnJlbW92ZSgpKSxlJiYoKGk9dGhpcy5kcmF3TGF5ZXIpPT1udWxsfHxpLmFwcGVuZCguLi5lKSl9dXBkYXRlU2VsZWN0b3JTaXplKGUsdCxyKXtjb25zdCBpPW5ldyBNYXAsaD1lLmdldEF0dHJpYnV0ZSgicG9zIiksZz1lLmNsYXNzTmFtZS5zcGxpdCgiLCIpLHU9dC12dC5TZWxlY3RCb3JkZXJQYWRkaW5nKjIsYT1yLXZ0LlNlbGVjdEJvcmRlclBhZGRpbmcqMixjPWcubGVuZ3RoPT09MiYmW3UvTnVtYmVyKGdbMF0pLGEvTnVtYmVyKGdbMV0pXXx8WzEsMV07cmV0dXJuIGUuc2V0QXR0cmlidXRlKCJzaXplIixbdSxhXSksZS5jaGlsZHJlbi5mb3JFYWNoKHg9PntpZih4LmlkPT09dnQuc2VsZWN0b3JCb3JkZXJJZCl4LnNldEF0dHJpYnV0ZSgicG9zIixbdS8yLGEvMl0pLHguc2V0QXR0cmlidXRlKCJ3aWR0aCIsdSkseC5zZXRBdHRyaWJ1dGUoImhlaWdodCIsYSk7ZWxzZSBpZihjKXtjb25zdCBmPXguY2xhc3NOYW1lLnNwbGl0KCIsIiksdj1bTnVtYmVyKGZbMF0pKmNbMF0sTnVtYmVyKGZbMV0pKmNbMV1dLHA9eC5nZXRBdHRyaWJ1dGUoIndpZHRoIiksQz14LmdldEF0dHJpYnV0ZSgiaGVpZ2h0IiksTT1OdW1iZXIoZlsyXSkqY1swXSxtPU51bWJlcihmWzNdKSpjWzFdO3guc2V0QXR0cmlidXRlKCJwb3MiLHYpLHguc2V0QXR0cmlidXRlKCJ3aWR0aCIsTSkseC5zZXRBdHRyaWJ1dGUoImhlaWdodCIsbSk7Y29uc3QgeT14LmlkLnNwbGl0KCJzZWxlY3Rvci0iKVsxXTtpZih5KXtjb25zdCBuPVt2WzBdK2hbMF0sdlsxXStoWzFdXSxvPVtNL3AsbS9DXTtpLnNldCh5LFtuWzBdLG5bMV0sb1swXSxvWzFdXSl9fX0pLGl9dXBkYXRlU2VsZWN0b3JSZWN0KGUsdCl7Y29uc3R7dzpyLGg6aSx4OmgseTpnfT10LHU9ci12dC5TZWxlY3RCb3JkZXJQYWRkaW5nKjIsYT1pLXZ0LlNlbGVjdEJvcmRlclBhZGRpbmcqMixjPWgrdnQuU2VsZWN0Qm9yZGVyUGFkZGluZyx4PWcrdnQuU2VsZWN0Qm9yZGVyUGFkZGluZztlLnNldEF0dHJpYnV0ZSgic2l6ZSIsW3IsaV0pLGUuc2V0QXR0cmlidXRlKCJwb3MiLFtjLHhdKSxlLnNldEF0dHJpYnV0ZSgiY2xhc3NOYW1lIixgJHt0Lnd9LCR7dC5ofWApLGUuY2hpbGRyZW4uZm9yRWFjaChmPT57aWYoZi5zZXRBdHRyaWJ1dGUoInBvcyIsW3UvMixhLzJdKSxmLnNldEF0dHJpYnV0ZSgid2lkdGgiLHUpLGYuc2V0QXR0cmlidXRlKCJoZWlnaHQiLGEpLGYuaWQ9PT12dC5zZWxlY3RvckJvcmRlcklkKWYuc2V0QXR0cmlidXRlKCJjbGFzc05hbWUiLGAke3Qudy8yfSwke3QuaC8yfSwke3Qud30sJHt0Lmh9YCk7ZWxzZXtjb25zdCB2PWYuY2xhc3NOYW1lLnNwbGl0KCIsIikscD12JiZOdW1iZXIodls0XSl8fDA7Zi5zZXRBdHRyaWJ1dGUoImNsYXNzTmFtZSIsYCR7dS8yfSwke2EvMn0sJHt0Lnd9LCR7dC5ofSwke3B9YCl9fSl9Z2V0U2VsZWN0b3JSZWN0KGUsdCxyKXt2YXIgYTtsZXQgaTtjb25zdCBoPShhPWUucGFyZW50KT09bnVsbD92b2lkIDA6YS5nZXRFbGVtZW50QnlJZCh0KSxnPWg9PW51bGw/dm9pZCAwOmguZ2V0RWxlbWVudEJ5SWQodnQuc2VsZWN0b3JCb3JkZXJJZCksdT1nPT1udWxsP3ZvaWQgMDpnLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO3JldHVybiB1JiYoaT1QdChpLHt4Ok1hdGguZmxvb3IodS54KSx5Ok1hdGguZmxvb3IodS55KSx3Ok1hdGgucm91bmQodS53aWR0aCksaDpNYXRoLnJvdW5kKHUuaGVpZ2h0KX0pKSxpJiZyP3t4OmkueC12dC5TZWxlY3RCb3JkZXJQYWRkaW5nLHk6aS55LXZ0LlNlbGVjdEJvcmRlclBhZGRpbmcsdzppLncrdnQuU2VsZWN0Qm9yZGVyUGFkZGluZyoyLGg6aS5oK3Z0LlNlbGVjdEJvcmRlclBhZGRpbmcqMn06aX11cGRhdGVTZWxlY3RvcihlKXt2YXIgYSxjLHg7Y29uc3R7dXBkYXRlU2VsZWN0b3JPcHQ6dCxzZWxlY3RJZHM6cn09ZTtsZXQgaTtjb25zdCBoPW5ldyBNYXA7bGV0IGc7Y29uc3QgdT0oYz0oYT10aGlzLmRyYXdMYXllcik9PW51bGw/dm9pZCAwOmEucGFyZW50KT09bnVsbD92b2lkIDA6Yy5nZXRFbGVtZW50QnlJZCh2dC5zZWxlY3RvcklkKTtpZih1KXtsZXQgZjtpZih0LnBvcyl7Y29uc3Qgdj1bdC5wb3NbMF0qdGhpcy53b3JsZFNjYWxpbmdbMF0rdGhpcy53b3JsZFBvc2l0aW9uWzBdLHQucG9zWzFdKnRoaXMud29ybGRTY2FsaW5nWzFdK3RoaXMud29ybGRQb3NpdGlvblsxXV0scD11LmdldEF0dHJpYnV0ZSgicG9zIik7Zj1bdlswXS1wWzBdLHZbMV0tcFsxXV0sdS5zZXRBdHRyaWJ1dGUoInBvcyIsdil9aWYodC5zZWxlY3RvckNvbG9yJiYoKHg9dS5nZXRFbGVtZW50QnlJZCh2dC5zZWxlY3RvckJvcmRlcklkKSk9PW51bGx8fHguc2V0QXR0cmlidXRlKCJzdHJva2VDb2xvciIsdC5zZWxlY3RvckNvbG9yKSksdC5zaXplJiYoZz10aGlzLnVwZGF0ZVNlbGVjdG9yU2l6ZSh1LHQuc2l6ZS53aWR0aCx0LnNpemUuaGVpZ2h0KSksdC5hbmdsZSlyPT1udWxsfHxyLmZvckVhY2godj0+e3ZhciBwOyhwPXRoaXMuZHJhd0xheWVyKT09bnVsbHx8cC5nZXRFbGVtZW50c0J5TmFtZSh2KS5mb3JFYWNoKEM9PntpZihDKXtjb25zdCBNPXt1c2VBbmltYXRpb246ITF9O3QuYW5nbGUmJihNLmFuZ2xlPXQuYW5nbGUsTS5vcmlnaW5Qb3M9Qy5jbGFzc05hbWUuc3BsaXQoIiwiKS5tYXAoeT0+TnVtYmVyKHkpKSxDLnNldEF0dHJpYnV0ZSgicm90YXRlIixNLmFuZ2xlKSksaC5zZXQoQy5uYW1lLE0pO2NvbnN0IG09S3QoQy5uYW1lLHRoaXMuZHJhd0xheWVyKTtpPVB0KGksbSl9fSl9LHRoaXMpO2Vsc2V7cj09bnVsbHx8ci5mb3JFYWNoKEM9Pnt2YXIgTTsoTT10aGlzLmRyYXdMYXllcik9PW51bGx8fE0uZ2V0RWxlbWVudHNCeU5hbWUoQykuZm9yRWFjaChtPT57aWYobSl7Y29uc3QgeT17dXNlQW5pbWF0aW9uOiExfTtpZih0LnBvcyYmZil7Y29uc3Qgbz1tLmdldEF0dHJpYnV0ZSgicG9zIik7eS5wb3M9W2ZbMF0vdGhpcy53b3JsZFNjYWxpbmdbMF0rb1swXSxmWzFdL3RoaXMud29ybGRTY2FsaW5nWzBdK29bMV1dLHkub3JpZ2luUG9zPW0uY2xhc3NOYW1lLnNwbGl0KCIsIikubWFwKHM9Pk51bWJlcihzKSksbS5zZXRBdHRyaWJ1dGUoInBvcyIseS5wb3MpfWlmKHQuekluZGV4RGlzdGFuY2V8fHQuekluZGV4KXtpZih0LnpJbmRleERpc3RhbmNlKXtjb25zdCBvPW0uZ2V0QXR0cmlidXRlKCJ6SW5kZXgiKTt5LnpJbmRleD1vK3QuekluZGV4RGlzdGFuY2V9ZWxzZSB5LnpJbmRleD10LnpJbmRleDttLnNldEF0dHJpYnV0ZSgiekluZGV4Iix5LnpJbmRleCl9aWYodC5jb2xvcil7eS5jb2xvcj10LmNvbG9yO2NvbnN0IG89bS5jbGFzc05hbWUuc3BsaXQoIiwiKTttLnRhZ05hbWU9PT0iR1JPVVAiP051bWJlcihvWzJdKT09PUR0LlN0cm9rZT9tLnNldEF0dHJpYnV0ZSgiYmdjb2xvciIseS5jb2xvcik6bS5jaGlsZHJlbi5mb3JFYWNoKHM9PntzLnNldEF0dHJpYnV0ZSgic3Ryb2tlQ29sb3IiLHkuY29sb3IpfSk6bS50YWdOYW1lPT09IlBBVEgiJiYobS5zZXRBdHRyaWJ1dGUoInN0cm9rZUNvbG9yIix5LmNvbG9yKSxtLmdldEF0dHJpYnV0ZSgiZmlsbENvbG9yIikmJm0uc2V0QXR0cmlidXRlKCJmaWxsQ29sb3IiLHkuY29sb3IpKX10Lm9wYWNpdHkmJih5Lm9wYWNpdHk9dC5vcGFjaXR5LG0uc2V0QXR0cmlidXRlKCJvcGFjaXR5Iix5Lm9wYWNpdHkpKTtjb25zdCBuPWc9PW51bGw/dm9pZCAwOmcuZ2V0KG0ubmFtZSk7aWYobil7Y29uc3Qgbz1tLmdldEF0dHJpYnV0ZSgic2NhbGUiKSxzPVtuWzJdKm9bMF0sblszXSpvWzFdXTt5Lm9yaWdpblBvcz1tLmNsYXNzTmFtZS5zcGxpdCgiLCIpLm1hcChsPT5OdW1iZXIobCkpLHkucG9zPVsoblswXS10aGlzLndvcmxkUG9zaXRpb25bMF0pL3RoaXMud29ybGRTY2FsaW5nWzBdLChuWzFdLXRoaXMud29ybGRQb3NpdGlvblsxXSkvdGhpcy53b3JsZFNjYWxpbmdbMV1dLHkuc2NhbGU9cyxtLnNldEF0dHJpYnV0ZSgicG9zIix5LnBvcyksbS5zZXRBdHRyaWJ1dGUoInNjYWxlIix5LnNjYWxlKX1oLnNldChtLm5hbWUseSl9fSl9LHRoaXMpO2NvbnN0IHY9dS5nZXRFbGVtZW50QnlJZCh2dC5zZWxlY3RvckJvcmRlcklkKSxwPXY9PW51bGw/dm9pZCAwOnYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7cCYmKGk9UHQoaSx7eDpNYXRoLmZsb29yKHAueCkseTpNYXRoLmZsb29yKHAueSksdzpNYXRoLnJvdW5kKHAud2lkdGgpLGg6TWF0aC5yb3VuZChwLmhlaWdodCl9KSl9fWlmKGkpcmV0dXJuIGkueC09dnQuU2VsZWN0Qm9yZGVyUGFkZGluZyxpLnktPXZ0LlNlbGVjdEJvcmRlclBhZGRpbmcsaS53Kz12dC5TZWxlY3RCb3JkZXJQYWRkaW5nKjIsaS5oKz12dC5TZWxlY3RCb3JkZXJQYWRkaW5nKjIsdC5hbmdsZSYmdGhpcy51cGRhdGVTZWxlY3RvclJlY3QodSxpKSx0aGlzLm9sZFJlY3Q9UHQodGhpcy5vbGRSZWN0LGkpLHRoaXMub2xkU2VsZWN0UmVjdD1pLHt0eXBlOnB0LlVwZGF0ZU5vZGUsZGF0YVR5cGU6QXQuTG9jYWwscmVjdDppLHVwZGF0ZU5vZGVPcHRzOmh9fWJsdXJTZWxlY3Rvcigpe2NvbnN0IGU9dGhpcy5iYWNrVG9GdWxsTGF5ZXIoKTtyZXR1cm57dHlwZTpwdC5TZWxlY3QsZGF0YVR5cGU6QXQuTG9jYWwscmVjdDplLHNlbGVjdElkczpbXSx3aWxsU3luY1NlcnZpY2U6ITB9fWdldFJpZ2h0U2VydmljZUlkKGUpe3JldHVybiBlLnJlcGxhY2UoIisrKysiLCItIil9ZHJhd1NlbGVjdG9yKGUpe2NvbnN0e2RyYXdSZWN0OnQsc3ViUmVjdHM6cixzdWJQb3M6aSxzZWxlY3RvcklkOmgsbGF5ZXI6Z309ZSx1PW5ldyBvZSh7cG9zOlt0LngsdC55XSxhbmNob3I6WzAsMF0sc2l6ZTpbdC53LHQuaF0sY2xhc3NOYW1lOmAke3Qud30sJHt0Lmh9YCxpZDpoLG5hbWU6dnQuc2VsZWN0b3JJZCx6SW5kZXg6MWUzfSksYT1bXSxjPW5ldyBtZSh7bm9ybWFsaXplOiEwLHBvczpbdC53LzIsdC5oLzJdLGxpbmVXaWR0aDoxLHN0cm9rZUNvbG9yOnRoaXMud29ya09wdGlvbnMuY29sb3Isd2lkdGg6dC53LGhlaWdodDp0LmgsY2xhc3NOYW1lOmAke3Qudy8yfSwke3QuaC8yfSwke3Qud30sJHt0Lmh9YCxpZDp2dC5zZWxlY3RvckJvcmRlcklkfSk7YS5wdXNoKGMpLHIuZm9yRWFjaCgoeCxmKT0+e2NvbnN0IHY9aT09bnVsbD92b2lkIDA6aS5nZXQoZik7aWYodil7Y29uc3QgcD1bdlswXS10LngsdlsxXS10LnldLEM9YCR7cFswXX0sJHtwWzFdfSwke3gud30sJHt4Lmh9LCR7dlsyXX1gLE09bmV3IG1lKHtub3JtYWxpemU6ITAscG9zOnAsbGluZVdpZHRoOjEsc3Ryb2tlQ29sb3I6ci5zaXplPjE/dGhpcy53b3JrT3B0aW9ucy5jb2xvcjp2b2lkIDAsd2lkdGg6eC53LGhlaWdodDp4LmgsY2xhc3NOYW1lOkMsaWQ6YHNlbGVjdG9yLSR7Zn1gLG5hbWU6YHNlbGVjdG9yLSR7Zn1gfSk7YS5wdXNoKE0pfX0pLGEmJnUuYXBwZW5kKC4uLmEpLChnPT1udWxsP3ZvaWQgMDpnLnBhcmVudCkuYXBwZW5kQ2hpbGQodSl9c2VsZWN0U2VydmljZU5vZGUoZSx0LHIpe3ZhciB4O2NvbnN0e3NlbGVjdElkczppfT10LGg9dGhpcy5nZXRSaWdodFNlcnZpY2VJZChlKSxnPXRoaXMuZ2V0U2VsZWN0b3JSZWN0KHRoaXMuZnVsbExheWVyLGgsITApOyh4PXRoaXMuZnVsbExheWVyLnBhcmVudC5nZXRFbGVtZW50QnlJZChoKSk9PW51bGx8fHgucmVtb3ZlKCk7bGV0IHU7Y29uc3QgYT1uZXcgTWFwLGM9bmV3IE1hcDtyZXR1cm4gaT09bnVsbHx8aS5mb3JFYWNoKGY9Pnt2YXIgQztjb25zdCB2PXIuZ2V0KGYpLHA9dGhpcy5mdWxsTGF5ZXIuZ2V0RWxlbWVudHNCeU5hbWUoZilbMF07aWYodiYmcCl7dT1QdCh1LHYucmVjdCksYS5zZXQoZix2LnJlY3QpO2NvbnN0IE09cC53b3JsZFBvc2l0aW9uLG09KChDPXYub3B0KT09bnVsbD92b2lkIDA6Qy5yb3RhdGUpfHxwLmdldEF0dHJpYnV0ZSgicm90YXRlIil8fDA7Yy5zZXQoZixbLi4uTSxtXSl9fSksdSYmdGhpcy5mdWxsTGF5ZXImJnRoaXMuZHJhd1NlbGVjdG9yKHtkcmF3UmVjdDp1LHN1YlJlY3RzOmEsc3ViUG9zOmMsc2VsZWN0b3JJZDpoLGxheWVyOnRoaXMuZnVsbExheWVyfSksdT1QdCh1LGcpLHUmJih1LngtPXZ0LlNlbGVjdEJvcmRlclBhZGRpbmcsdS55LT12dC5TZWxlY3RCb3JkZXJQYWRkaW5nLHUudys9dnQuU2VsZWN0Qm9yZGVyUGFkZGluZyoyLHUuaCs9dnQuU2VsZWN0Qm9yZGVyUGFkZGluZyoyKSx1fXJlbW92ZVNlcnZpY2UoKXt0aHJvdyBuZXcgRXJyb3IoIk1ldGhvZCBub3QgaW1wbGVtZW50ZWQuIil9Z2V0U2VsZWN0b3IoZSl7dmFyIGg7bGV0IHQ7Y29uc3Qgcj1uZXcgTWFwLGk9bmV3IE1hcDtyZXR1cm4oaD10aGlzLnNlbGVjdElkcyk9PW51bGx8fGguZm9yRWFjaChnPT57dmFyIGM7Y29uc3QgdT1lLmdldChnKSxhPShjPXRoaXMuZHJhd0xheWVyKT09bnVsbD92b2lkIDA6Yy5nZXRFbGVtZW50c0J5TmFtZShnKVswXTtpZih1JiZhKXtjb25zdCB4PWEud29ybGRQb3NpdGlvbixmPWEuZ2V0QXR0cmlidXRlKCJyb3RhdGUiKXx8MDt0PVB0KHQsdS5yZWN0KSxyLnNldChnLHUucmVjdCksaS5zZXQoZyxbLi4ueCxmXSl9fSx0aGlzKSx0aGlzLm9sZFJlY3Q9UHQodCx0aGlzLm9sZFJlY3QpLHRoaXMuZHJhdyh7aW50ZXJzZWN0UmVjdDp0LHN1YlJlY3RzOnIsc3ViUG9zOml9KSx0aGlzLm9sZFNlbGVjdFJlY3Q9dCx0fX1PYmplY3QuZGVmaW5lUHJvcGVydHkodnQsInNlbGVjdG9ySWQiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZToic2VsZWN0b3IifSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHZ0LCJzZWxlY3RvckJvcmRlcklkIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6InNlbGVjdG9yLWJvcmRlciJ9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodnQsIlNlbGVjdEJvcmRlclBhZGRpbmciLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZToyfSk7Y2xhc3MgeGUgZXh0ZW5kcyBlZXt1cGRhdGFPcHRTZXJ2aWNlKCl7fWNvbnN0cnVjdG9yKGUsdCl7c3VwZXIodCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInN5bmNUaW1lc3RhbXAiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywic3luY0luZGV4Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6MH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ0b29sc1R5cGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpTdC5MYXNlclBlbn0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ0bXBQb2ludHMiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpbXX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ3b3JrT3B0aW9ucyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJjb25zdW1lSW5kZXgiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTowfSksdGhpcy53b3JrT3B0aW9ucz1lLHRoaXMuc3luY1RpbWVzdGFtcD0wfWNvbWJpbmVDb25zdW1lKCl7fXNldFdvcmtPcHRpb25zKGUpe3N1cGVyLnNldFdvcmtPcHRpb25zKGUpLHRoaXMuc3luY1RpbWVzdGFtcD1EYXRlLm5vdygpfWNvbnN1bWUoZSl7Y29uc3R7ZGF0YTp0LGlzRnVsbFdvcms6cn09ZSx7d29ya0lkOmksb3A6aH09dDtpZigoaD09bnVsbD92b2lkIDA6aC5sZW5ndGgpPT09MClyZXR1cm57dHlwZTpwdC5Ob25lfTtpZih0aGlzLnVwZGF0ZVRlbXBQb2ludHMoaHx8W10pLHRoaXMuY29uc3VtZUluZGV4PnRoaXMudG1wUG9pbnRzLmxlbmd0aC00KXJldHVybnt0eXBlOnB0Lk5vbmV9O2NvbnN0e2NvbG9yOmcsdGhpY2tuZXNzOnUsc3Ryb2tlVHlwZTphLG9wYWNpdHk6Y309dGhpcy53b3JrT3B0aW9ucyx4PVZ0KHRoaXMudG1wUG9pbnRzLHUpO2xldCBmPSExO2NvbnN0IHY9dGhpcy5zeW5jSW5kZXgscD10aGlzLnRtcFBvaW50cy5zbGljZSh0aGlzLmNvbnN1bWVJbmRleCk7dGhpcy5jb25zdW1lSW5kZXg9dGhpcy50bXBQb2ludHMubGVuZ3RoLTEsdGhpcy5zeW5jVGltZXN0YW1wPT09MCYmKHRoaXMuc3luY1RpbWVzdGFtcD1EYXRlLm5vdygpKTtjb25zdCBDPXtuYW1lOmk9PW51bGw/dm9pZCAwOmkudG9TdHJpbmcoKSxjbGFzc05hbWU6Ikxhc2VyUGVuIixvcGFjaXR5OmN8fDEsbGluZURhc2g6YT09PUR0LkRvdHRlZD9bMSx1KjJdOmE9PT1EdC5Mb25nRG90dGVkP1t1LHUqMl06dm9pZCAwLHN0cm9rZUNvbG9yOmcsbGluZUNhcDoicm91bmQiLGxpbmVXaWR0aDp1LGFuY2hvcjpbLjUsLjVdfSxNPXRoaXMuZ2V0VGFza1BvaW50cyhwKTtpZihNLmxlbmd0aCl7Y29uc3QgeT1EYXRlLm5vdygpO3ktdGhpcy5zeW5jVGltZXN0YW1wPnRoaXMuc3luY1VuaXRUaW1lJiYoZj0hMCx0aGlzLnN5bmNUaW1lc3RhbXA9eSx0aGlzLnN5bmNJbmRleD10aGlzLnRtcFBvaW50cy5sZW5ndGgpLCFyJiZ0aGlzLmRyYXcoe2F0dHJzOkMsdGFza3M6TSxpc0RvdDohMX0pfWNvbnN0IG09W107cmV0dXJuIHRoaXMudG1wUG9pbnRzLnNsaWNlKHYpLmZvckVhY2goeT0+e20ucHVzaCh5LngseS55KX0pLHtyZWN0Ont4OngueCp0aGlzLmZ1bGxMYXllci53b3JsZFNjYWxpbmdbMF0rdGhpcy5mdWxsTGF5ZXIud29ybGRQb3NpdGlvblswXSx5OngueSp0aGlzLmZ1bGxMYXllci53b3JsZFNjYWxpbmdbMV0rdGhpcy5mdWxsTGF5ZXIud29ybGRQb3NpdGlvblsxXSx3Ongudyp0aGlzLmZ1bGxMYXllci53b3JsZFNjYWxpbmdbMF0saDp4LmgqdGhpcy5mdWxsTGF5ZXIud29ybGRTY2FsaW5nWzFdfSx0eXBlOnB0LkRyYXdXb3JrLGRhdGFUeXBlOkF0LkxvY2FsLHdvcmtJZDpmP2k6dm9pZCAwLG9wOmY/bTp2b2lkIDAsaW5kZXg6Zj92KjI6dm9pZCAwfX1jb25zdW1lQWxsKCl7dmFyIGk7Y29uc3QgZT0oaT10aGlzLndvcmtJZCk9PW51bGw/dm9pZCAwOmkudG9TdHJpbmcoKTtsZXQgdDtpZih0aGlzLnRtcFBvaW50cy5sZW5ndGgtMT50aGlzLmNvbnN1bWVJbmRleCl7bGV0IGg9dGhpcy50bXBQb2ludHMuc2xpY2UodGhpcy5jb25zdW1lSW5kZXgpO2NvbnN0IGc9aC5sZW5ndGg9PT0xLHtjb2xvcjp1LHRoaWNrbmVzczphLHN0cm9rZVR5cGU6YyxvcGFjaXR5Onh9PXRoaXMud29ya09wdGlvbnM7aWYoZyl7Y29uc3QgcD10aGlzLmNvbXB1dERvdFN0cm9rZSh7cG9pbnQ6aFswXSxyYWRpdXM6YS8yfSk7aD1wLnBzLHQ9cC5yZWN0fWVsc2UgdD1WdCh0aGlzLnRtcFBvaW50cyxhKTtjb25zdCBmPXtuYW1lOmU9PW51bGw/dm9pZCAwOmUudG9TdHJpbmcoKSxjbGFzc05hbWU6Ikxhc2VyUGVuIixmaWxsQ29sb3I6Zz91OnZvaWQgMCxvcGFjaXR5Onh8fDEsbGluZURhc2g6Yz09PUR0LkRvdHRlZCYmIWc/WzEsYSoyXTpjPT09RHQuTG9uZ0RvdHRlZCYmIWc/W2EsYSoyXTp2b2lkIDAsc3Ryb2tlQ29sb3I6dSxsaW5lQ2FwOmc/dm9pZCAwOiJyb3VuZCIsbGluZVdpZHRoOmc/MDphLGFuY2hvcjpbLjUsLjVdfSx2PXRoaXMuZ2V0VGFza1BvaW50cyhoKTt2Lmxlbmd0aCYmdGhpcy5kcmF3KHthdHRyczpmLHRhc2tzOnYsaXNEb3Q6Z30pfWNvbnN0IHI9W107cmV0dXJuIHRoaXMudG1wUG9pbnRzLnNsaWNlKHRoaXMuc3luY0luZGV4KS5mb3JFYWNoKGg9PntyLnB1c2goaC54LGgueSl9KSx7cmVjdDp0JiZ7eDp0LngqdGhpcy5mdWxsTGF5ZXIud29ybGRTY2FsaW5nWzBdK3RoaXMuZnVsbExheWVyLndvcmxkUG9zaXRpb25bMF0seTp0LnkqdGhpcy5mdWxsTGF5ZXIud29ybGRTY2FsaW5nWzFdK3RoaXMuZnVsbExheWVyLndvcmxkUG9zaXRpb25bMV0sdzp0LncqdGhpcy5mdWxsTGF5ZXIud29ybGRTY2FsaW5nWzBdLGg6dC5oKnRoaXMuZnVsbExheWVyLndvcmxkU2NhbGluZ1sxXX0sdHlwZTpwdC5EcmF3V29yayxkYXRhVHlwZTpBdC5Mb2NhbCx3b3JrSWQ6ZSxvcDpyLGluZGV4OnRoaXMuc3luY0luZGV4KjJ9fWNsZWFyVG1wUG9pbnRzKCl7dGhpcy50bXBQb2ludHMubGVuZ3RoPTAsdGhpcy5zeW5jVGltZXN0YW1wPTAsdGhpcy5zeW5jSW5kZXg9MH1jb25zdW1lU2VydmljZShlKXt2YXIgcDtjb25zdHtvcDp0fT1lLHtjb2xvcjpyLHRoaWNrbmVzczppLHN0cm9rZVR5cGU6aCxvcGFjaXR5Omd9PXRoaXMud29ya09wdGlvbnM7aWYoIXQubGVuZ3RoKXtjb25zdCBDPVZ0KHRoaXMudG1wUG9pbnRzLGkpO3JldHVybnt4OkMueCp0aGlzLmZ1bGxMYXllci53b3JsZFNjYWxpbmdbMF0rdGhpcy5mdWxsTGF5ZXIud29ybGRQb3NpdGlvblswXSx5OkMueSp0aGlzLmZ1bGxMYXllci53b3JsZFNjYWxpbmdbMV0rdGhpcy5mdWxsTGF5ZXIud29ybGRQb3NpdGlvblsxXSx3OkMudyp0aGlzLmZ1bGxMYXllci53b3JsZFNjYWxpbmdbMF0saDpDLmgqdGhpcy5mdWxsTGF5ZXIud29ybGRTY2FsaW5nWzFdfX1jb25zdCB1PU1hdGgubWF4KDAsdGhpcy50bXBQb2ludHMubGVuZ3RoLTEpO3RoaXMudXBkYXRlVGVtcFBvaW50cyh0fHxbXSk7bGV0IGEsYz10aGlzLnRtcFBvaW50cy5zbGljZSh1KTtjb25zdCB4PWMubGVuZ3RoPT09MTtpZih4KXtjb25zdCBDPXRoaXMuY29tcHV0RG90U3Ryb2tlKHtwb2ludDpjWzBdLHJhZGl1czppLzJ9KTtjPUMucHMsYT1DLnJlY3R9ZWxzZSBhPVZ0KHRoaXMudG1wUG9pbnRzLGkpO2NvbnN0IGY9e25hbWU6KHA9dGhpcy53b3JrSWQpPT1udWxsP3ZvaWQgMDpwLnRvU3RyaW5nKCksY2xhc3NOYW1lOiJMYXNlclBlbiIsZmlsbENvbG9yOng/cjp2b2lkIDAsb3BhY2l0eTpnfHwxLGxpbmVEYXNoOmg9PT1EdC5Eb3R0ZWQmJiF4P1sxLGkqMl06aD09PUR0LkxvbmdEb3R0ZWQmJiF4P1tpLGkqMl06dm9pZCAwLHN0cm9rZUNvbG9yOnIsbGluZUNhcDp4P3ZvaWQgMDoicm91bmQiLGxpbmVXaWR0aDp4PzA6aSxhbmNob3I6Wy41LC41XX0sdj10aGlzLmdldFRhc2tQb2ludHMoYyk7cmV0dXJuIHYubGVuZ3RoJiZ0aGlzLmRyYXcoe2F0dHJzOmYsdGFza3M6dixpc0RvdDp4fSkse3g6YS54KnRoaXMuZnVsbExheWVyLndvcmxkU2NhbGluZ1swXSt0aGlzLmZ1bGxMYXllci53b3JsZFBvc2l0aW9uWzBdLHk6YS55KnRoaXMuZnVsbExheWVyLndvcmxkU2NhbGluZ1sxXSt0aGlzLmZ1bGxMYXllci53b3JsZFBvc2l0aW9uWzFdLHc6YS53KnRoaXMuZnVsbExheWVyLndvcmxkU2NhbGluZ1swXSxoOmEuaCp0aGlzLmZ1bGxMYXllci53b3JsZFNjYWxpbmdbMV19fWNvbXB1dERvdFN0cm9rZShlKXtjb25zdHtwb2ludDp0LHJhZGl1czpyfT1lLGk9e3g6dC54LXIseTp0Lnktcix3OnIqMixoOnIqMn07cmV0dXJue3BzOkx0LkdldERvdFN0cm9rZSh0LHIsOCkscmVjdDppfX11cGRhdGVUZW1wUG9pbnRzKGUpe2NvbnN0IHQ9dGhpcy50bXBQb2ludHMubGVuZ3RoO2ZvcihsZXQgcj0wO3I8ZS5sZW5ndGg7cis9Mil7aWYodCl7Y29uc3QgaT10aGlzLnRtcFBvaW50cy5zbGljZSgtMSlbMF07aSYmaS54PT09ZVtyXSYmaS55PT09ZVtyKzFdJiZ0aGlzLnRtcFBvaW50cy5wb3AoKX10aGlzLnRtcFBvaW50cy5wdXNoKG5ldyBMdChlW3JdLGVbcisxXSkpfX1hc3luYyBkcmF3KGUpe2NvbnN0e2F0dHJzOnQsdGFza3M6cixpc0RvdDppfT1lLGg9dGhpcy5mdWxsTGF5ZXIse2R1cmF0aW9uOmd9PXRoaXMud29ya09wdGlvbnMsdT1uZXcgYWU7Zm9yKGxldCBhPTA7YTxyLmxlbmd0aDthKyspe2NvbnN0e3BvczpjLHBvaW50czp4fT1yW2FdO2xldCBmO2k/Zj1uZSh4LCEwKTpmPW5lKHgsITEpLHUuYXR0cih7Li4udCxwb3M6YyxkOmZ9KTtjb25zdHt2ZXJ0ZXg6dixmcmFnbWVudDpwfT10aGlzLndvcmtPcHRpb25zO2lmKHYmJnApe2NvbnN0IEM9aC5yZW5kZXJlci5jcmVhdGVQcm9ncmFtKHt2ZXJ0ZXg6dixmcmFnbWVudDpwfSkse3dpZHRoOk0saGVpZ2h0Om19PWguZ2V0UmVzb2x1dGlvbigpO3Uuc2V0VW5pZm9ybXMoe3VfdGltZTowLHVfcmVzb2x1dGlvbjpbTSxtXX0pLHUuc2V0UHJvZ3JhbShDKX1oLmFwcGVuZENoaWxkKHUpLGF3YWl0IHUudHJhbnNpdGlvbihnKS5hdHRyKHtzY2FsZTppP1suMSwuMV06WzEsMV0sbGluZVdpZHRoOmk/MDoxfSksdS5yZW1vdmUoKX19Z2V0VGFza1BvaW50cyhlKXt2YXIgYTtjb25zdCB0PVtdO2lmKGUubGVuZ3RoPT09MClyZXR1cm5bXTtsZXQgcj0wLGk9ZVswXS54LGg9ZVswXS55LGc9W2ksaF0sdT1bXTtmb3IoO3I8ZS5sZW5ndGg7KXtjb25zdCBjPWVbcl0seD1jLngtaSxmPWMueS1oO2lmKHUucHVzaChuZXcgTHQoeCxmKSkscj4wJiZyPGUubGVuZ3RoLTEpe2NvbnN0IHY9ZVtyXS5nZXRBbmdsZUJ5UG9pbnRzKGVbci0xXSxlW3IrMV0pO2lmKHY8OTB8fHY+MjcwKXtjb25zdCBwPShhPXUucG9wKCkpPT1udWxsP3ZvaWQgMDphLmNsb25lKCk7cCYmdC5wdXNoKHtwb3M6Zyxwb2ludHM6Wy4uLnUscF19KSxpPWVbcl0ueCxoPWVbcl0ueSxnPVtpLGhdO2NvbnN0IEM9Yy54LWksTT1jLnktaDt1PVtuZXcgTHQoQyxNKV19fXIrK31yZXR1cm4gdC5wdXNoKHtwb3M6Zyxwb2ludHM6dX0pLHR9cmVtb3ZlTG9jYWwoKXt9cmVtb3ZlU2VydmljZShlKXtsZXQgdDtjb25zdCByPVtdO3JldHVybiB0aGlzLmZ1bGxMYXllci5nZXRFbGVtZW50c0J5TmFtZShlKS5mb3JFYWNoKGk9PntpZihpLm5hbWU9PT1lKXtjb25zdCBoPWkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7dD1QdCh0LHt4OmgueCx5OmgueSx3Omgud2lkdGgsaDpoLmhlaWdodH0pLHIucHVzaChpKX19KSxyLmxlbmd0aCYmci5mb3JFYWNoKGk9PmkucmVtb3ZlKCkpLHR9fWNsYXNzIFVle2NvbnN0cnVjdG9yKCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImN1ck5vZGVNYXAiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpuZXcgTWFwfSl9dXBkYXRlU2NlbmUoZSl7dGhpcy5zY2VuZS5hdHRyKHsuLi5lfSk7Y29uc3R7d2lkdGg6dCxoZWlnaHQ6cn09ZTt0aGlzLnNjZW5lLmNvbnRhaW5lci53aWR0aD10LHRoaXMuc2NlbmUuY29udGFpbmVyLmhlaWdodD1yLHRoaXMuc2NlbmUud2lkdGg9dCx0aGlzLnNjZW5lLmhlaWdodD1yLHRoaXMudXBkYXRlTGF5ZXIoe3dpZHRoOnQsaGVpZ2h0OnJ9KX11cGRhdGVMYXllcihlKXt2YXIgaSxoLGcsdTtjb25zdHt3aWR0aDp0LGhlaWdodDpyfT1lOyhpPXRoaXMuZnVsbExheWVyKT09bnVsbHx8aS5zZXRBdHRyaWJ1dGUoInNpemUiLFt0LHJdKSwoaD10aGlzLmZ1bGxMYXllcik9PW51bGx8fGguc2V0QXR0cmlidXRlKCJwb3MiLFt0Ki41LHIqLjVdKSwoZz10aGlzLmRyYXdMYXllcik9PW51bGx8fGcuc2V0QXR0cmlidXRlKCJzaXplIixbdCxyXSksKHU9dGhpcy5kcmF3TGF5ZXIpPT1udWxsfHx1LnNldEF0dHJpYnV0ZSgicG9zIixbdCouNSxyKi41XSl9Y3JlYXRlU2NlbmUoZSl7Y29uc3R7d2lkdGg6dCxoZWlnaHQ6cn09ZSxpPW5ldyBPZmZzY3JlZW5DYW52YXModCxyKTtyZXR1cm4gbmV3IE9lKHtjb250YWluZXI6aSxkaXNwbGF5UmF0aW86dGhpcy5kcHIsZGVwdGg6ITEsZGVzeW5jaHJvbml6ZWQ6ITAsLi4uZX0pfWNyZWF0ZUxheWVyKGUpe2NvbnN0e3dpZHRoOnQsaGVpZ2h0OnJ9PWUsaT0ib2Zmc2NyZWVuIitEYXRlLm5vdygpLGg9dGhpcy5zY2VuZS5sYXllcihpLGUpLGc9bmV3IG9lKHthbmNob3I6Wy41LC41XSxwb3M6W3QqLjUsciouNV0sc2l6ZTpbdCxyXSxuYW1lOiJ2aWV3cG9ydCJ9KTtyZXR1cm4gaC5hcHBlbmQoZyksZ31nZXROb2RlcyhlKXtyZXR1cm4gdGhpcy5mdWxsTGF5ZXIuZ2V0RWxlbWVudHNCeU5hbWUoZSsiIikuY29uY2F0KHRoaXMuZHJhd0xheWVyLmdldEVsZW1lbnRzQnlOYW1lKGUrIiIpKX19Y2xhc3MgRmV7Y29uc3RydWN0b3IoZSx0LHIpe09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJmdWxsTGF5ZXIiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiZHJhd0xheWVyIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImN1ck5vZGVNYXAiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidG1wV29ya1NoYXBlTm9kZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ0bXBPcHQiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiZWZmZWN0V29ya0lkIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksdGhpcy5jdXJOb2RlTWFwPWUsdGhpcy5mdWxsTGF5ZXI9dCx0aGlzLmRyYXdMYXllcj1yfWdldFdvcmtTaGFwZShlKXtyZXR1cm4gdGhpcy53b3JrU2hhcGVzLmdldChlKX1nZXRUbXBXb3JrU2hhcGVOb2RlKCl7cmV0dXJuIHRoaXMudG1wV29ya1NoYXBlTm9kZX1zZXRUbXBXb3JrSWQoZSl7aWYoZSYmdGhpcy50bXBXb3JrU2hhcGVOb2RlKXt0aGlzLnRtcFdvcmtTaGFwZU5vZGUuc2V0V29ya0lkKGUpLHRoaXMud29ya1NoYXBlcy5zZXQoZSx0aGlzLnRtcFdvcmtTaGFwZU5vZGUpLHRoaXMudG1wT3B0JiZ0aGlzLnNldFRvb2xzT3B0KHRoaXMudG1wT3B0KTtyZXR1cm59fXNldFRtcFdvcmtPcHRpb25zKGUpe3ZhciB0Oyh0PXRoaXMudG1wV29ya1NoYXBlTm9kZSk9PW51bGx8fHQuc2V0V29ya09wdGlvbnMoZSl9c2V0V29ya09wdGlvbnMoZSx0KXt2YXIgaTt0aGlzLndvcmtTaGFwZXMuZ2V0KGUpfHx0aGlzLnNldFRtcFdvcmtJZChlKSwoaT10aGlzLndvcmtTaGFwZXMuZ2V0KGUpKT09bnVsbHx8aS5zZXRXb3JrT3B0aW9ucyh0KX1jcmVhdGVXb3JrU2hhcGVOb2RlKGUpe2xldCB0O3N3aXRjaChlLnRvb2xzVHlwZSl7Y2FzZSBTdC5QZW5jaWw6dD1uZXcgSXQoZS50b29sc09wdCx0aGlzLmZ1bGxMYXllcix0aGlzLmRyYXdMYXllcik7YnJlYWs7Y2FzZSBTdC5MYXNlclBlbjp0PW5ldyB4ZShlLnRvb2xzT3B0LHRoaXMuZnVsbExheWVyKTticmVhaztjYXNlIFN0LkVyYXNlcjp0PW5ldyBZdChlLnRvb2xzT3B0LHRoaXMuZnVsbExheWVyKTticmVhaztjYXNlIFN0LlNlbGVjdG9yOnQ9bmV3IHZ0KGUudG9vbHNPcHQsdGhpcy5mdWxsTGF5ZXIsdGhpcy5kcmF3TGF5ZXIpO2JyZWFrO2RlZmF1bHQ6dD12b2lkIDA7YnJlYWt9cmV0dXJuIHR9c2V0VG9vbHNPcHQoZSl7dmFyIHQscixpOygodD10aGlzLnRtcE9wdCk9PW51bGw/dm9pZCAwOnQudG9vbHNUeXBlKSE9PWUudG9vbHNUeXBlJiYoKChyPXRoaXMudG1wT3B0KT09bnVsbD92b2lkIDA6ci50b29sc1R5cGUpPT09U3QuU2VsZWN0b3ImJnRoaXMuYmx1clNlbGVjdG9yKCksKGk9dGhpcy50bXBPcHQpIT1udWxsJiZpLnRvb2xzVHlwZSYmdGhpcy5jbGVhckFsbFdvcmtTaGFwZXNDYWNoZSgpKSx0aGlzLnRtcE9wdD1lLHRoaXMudG1wV29ya1NoYXBlTm9kZT10aGlzLmNyZWF0ZVdvcmtTaGFwZU5vZGUoZSl9Y2xlYXJXb3JrU2hhcGVOb2RlQ2FjaGUoZSl7dmFyIHQ7KHQ9dGhpcy5nZXRXb3JrU2hhcGUoZSkpPT1udWxsfHx0LmNsZWFyVG1wUG9pbnRzKCksdGhpcy53b3JrU2hhcGVzLmRlbGV0ZShlKX1jbGVhckFsbFdvcmtTaGFwZXNDYWNoZSgpe3RoaXMud29ya1NoYXBlcy5mb3JFYWNoKGU9PmUuY2xlYXJUbXBQb2ludHMoKSksdGhpcy53b3JrU2hhcGVzLmNsZWFyKCl9cnVuRWZmZWN0V29yayhlKXt0aGlzLmVmZmVjdFdvcmtJZCYmKGNsZWFyVGltZW91dCh0aGlzLmVmZmVjdFdvcmtJZCksdGhpcy5lZmZlY3RXb3JrSWQ9dm9pZCAwKSx0aGlzLmVmZmVjdFdvcmtJZD1zZXRUaW1lb3V0KCgpPT57dGhpcy5lZmZlY3RXb3JrSWQ9dm9pZCAwLHRoaXMuY29tcHV0Tm9kZU1hcCgpLHRoaXMucmVyUmVuZGVyU2VsZWN0b3IoKSxlJiZlKCl9LDUwKX1jb21wdXROb2RlTWFwKCl7dmFyIHQscjtjb25zdCBlPW5ldyBTZXQodGhpcy5jdXJOb2RlTWFwLmtleXMoKSk7aWYodGhpcy5mdWxsTGF5ZXIuY2hpbGRyZW4uZm9yRWFjaChpPT57aWYoaS5uYW1lIT09dnQuc2VsZWN0b3JJZCl7Y29uc3QgaD1LdChpLm5hbWUsdGhpcy5mdWxsTGF5ZXIpO2lmKGgpe2NvbnN0IGc9dGhpcy5jdXJOb2RlTWFwLmdldChpLm5hbWUpO2c/KGcucmVjdD1oLGUuZGVsZXRlKGkubmFtZSkpOnRoaXMuY3VyTm9kZU1hcC5zZXQoaS5uYW1lLHtuYW1lOmkubmFtZSxyZWN0Omh9KX19fSksKHI9KHQ9dGhpcy5kcmF3TGF5ZXIpPT1udWxsP3ZvaWQgMDp0LmNoaWxkcmVuKT09bnVsbHx8ci5mb3JFYWNoKGk9PntpZihpLm5hbWUhPT12dC5zZWxlY3RvcklkKXtjb25zdCBoPUt0KGkubmFtZSx0aGlzLmRyYXdMYXllcik7aWYoaCl7Y29uc3QgZz10aGlzLmN1ck5vZGVNYXAuZ2V0KGkubmFtZSk7Zz8oZy5yZWN0PWgsZS5kZWxldGUoaS5uYW1lKSk6dGhpcy5jdXJOb2RlTWFwLnNldChpLm5hbWUse25hbWU6aS5uYW1lLHJlY3Q6aH0pfX19KSxlLnNpemUpZm9yKGNvbnN0IGkgb2YgZS5rZXlzKCkpdGhpcy5jdXJOb2RlTWFwLmRlbGV0ZShpKX11cGRhdGFOb2RlTWFwKGUpe2NvbnN0e2tleTp0LG9wczpyLG9wdDppLHRvb2xzVHlwZTpofT1lO2xldCBnPUt0KHQsdGhpcy5mdWxsTGF5ZXIpO2NvbnN0IHU9dGhpcy5jdXJOb2RlTWFwLmdldCh0KXx8e25hbWU6dCxyZWN0Omd9O3ImJih1Lm9wcz1yKSxpJiYodS5vcHQ9aSksZyYmKHUucmVjdD1nKSxoJiYodS50b29sc1R5cGU9aCksdGhpcy5kcmF3TGF5ZXImJihnPUt0KHQsdGhpcy5kcmF3TGF5ZXIpLGcmJnRoaXMuZHJhd0xheWVyJiYodS5yZWN0PWcpKSx1LnJlY3Q/dGhpcy5jdXJOb2RlTWFwLnNldCh0LHUpOnRoaXMuY3VyTm9kZU1hcC5kZWxldGUodCl9cmVyUmVuZGVyU2VsZWN0b3IoKXt2YXIgdDtjb25zdCBlPXRoaXMud29ya1NoYXBlcy5nZXQodnQuc2VsZWN0b3JJZCk7aWYoKHQ9ZT09bnVsbD92b2lkIDA6ZS5zZWxlY3RJZHMpIT1udWxsJiZ0Lmxlbmd0aCYmdGhpcy5kcmF3TGF5ZXIpe2NvbnN0IHI9ZS5nZXRTZWxlY3Rvcih0aGlzLmN1ck5vZGVNYXApO3ImJnRoaXMuX3Bvc3Qoe3JlbmRlcjp7cmVjdDpyLGlzQ2xlYXI6ITAsaXNGdWxsV29yazohMSxjbGVhckNhbnZhczp5dC5TZWxlY3RvcixkcmF3Q2FudmFzOnl0LlNlbGVjdG9yfSxzcDpbe3R5cGU6cHQuU2VsZWN0LHNlbGVjdElkczplLnNlbGVjdElkcyxzZWxlY3RSZWN0OnIsd2lsbFN5bmNTZXJ2aWNlOiExfV19KX19fWNsYXNzIHple2NvbnN0cnVjdG9yKGUsdCxyKXtPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiZHJhd0xheWVyIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImZ1bGxMYXllciIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJjdXJOb2RlTWFwIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksdGhpcy5jdXJOb2RlTWFwPWUsdGhpcy5mdWxsTGF5ZXI9dCx0aGlzLmRyYXdMYXllcj1yfXVwZGF0YU5vZGVNYXAoZSx0LHIpe2xldCBpPUt0KGUsdGhpcy5mdWxsTGF5ZXIpO2NvbnN0IGg9dGhpcy5jdXJOb2RlTWFwLmdldChlKXx8e25hbWU6ZSxyZWN0Oml9O3QmJihoLm9wcz10KSxyJiYoaC5vcHQ9ciksaSYmKGgucmVjdD1pKSx0aGlzLmRyYXdMYXllciYmKGk9S3QoZSx0aGlzLmRyYXdMYXllciksaSYmdGhpcy5kcmF3TGF5ZXImJihoLnJlY3Q9aSkpLGgucmVjdD90aGlzLmN1ck5vZGVNYXAuc2V0KGUsaCk6dGhpcy5jdXJOb2RlTWFwLmRlbGV0ZShlKX19Y2xhc3Mgd2UgZXh0ZW5kcyBGZXtjb25zdHJ1Y3RvcihlLHQscixpKXtzdXBlcihlLHQsciksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIl9wb3N0Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIndvcmtTaGFwZXMiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpuZXcgTWFwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImNvbWJpbmVVbml0VGltZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOjYwMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJjb21iaW5lVGltZXJJZCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJkcmF3Q291bnQiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTowfSksdGhpcy5fcG9zdD1pfWRyYXdQZW5jaWxDb21iaW5lKGUpe3ZhciByO2NvbnN0IHQ9KHI9dGhpcy53b3JrU2hhcGVzLmdldChlKSk9PW51bGw/dm9pZCAwOnIuY29tYmluZUNvbnN1bWUoKTtpZih0KXtjb25zdCBpPXtyZW5kZXI6e3JlY3Q6dD09bnVsbD92b2lkIDA6dC5yZWN0LGlzQ2xlYXI6ITAsZHJhd0NhbnZhczp5dC5GbG9hdCxjbGVhckNhbnZhczp5dC5GbG9hdCxpc0Z1bGxXb3JrOiExfX07UHJvbWlzZS5yZXNvbHZlKGkpLnRoZW4oaD0+e2guZHJhd0NvdW50PXRoaXMuZHJhd0NvdW50LHRoaXMuX3Bvc3QoaCl9KX19ZHJhd1NlbGVjdG9yKGUsdCl7dmFyIHI7KHI9ZS5zZWxlY3RJZHMpIT1udWxsJiZyLmxlbmd0aCYmIXQmJih0aGlzLl9wb3N0KHtyZW5kZXI6ZS5yZWN0JiZ7cmVjdDplLnNlbGVjdFJlY3QsZHJhd0NhbnZhczp5dC5TZWxlY3Rvcixpc0NsZWFyOiEwLGNsZWFyQ2FudmFzOnl0LlNlbGVjdG9yLGlzRnVsbFdvcms6ITF9LHNwOltlXX0pLHRoaXMuX3Bvc3Qoe3JlbmRlcjplLnJlY3QmJntyZWN0OmUuc2VsZWN0UmVjdHx8ZS5yZWN0LGlzQ2xlYXI6ITAsY2xlYXJDYW52YXM6eXQuRmxvYXQsaXNGdWxsV29yazohMX0sc3A6W2VdfSksdGhpcy5fcG9zdCh7cmVuZGVyOmUucmVjdCYme3JlY3Q6ZS5yZWN0LGRyYXdDYW52YXM6eXQuQmcsaXNDbGVhcjohMCxjbGVhckNhbnZhczp5dC5CZyxpc0Z1bGxXb3JrOiEwfX0pKSx0JiYodGhpcy5fcG9zdCh7cmVuZGVyOmUucmVjdCYme3JlY3Q6ZS5yZWN0LGRyYXdDYW52YXM6eXQuRmxvYXQsaXNDbGVhcjohMCxjbGVhckNhbnZhczp5dC5GbG9hdCxpc0Z1bGxXb3JrOiExfSxzcDpbZV19KSx0aGlzLl9wb3N0KHtyZW5kZXI6ZS5yZWN0JiZ7cmVjdDplLnJlY3QsZHJhd0NhbnZhczp5dC5CZyxpc0NsZWFyOiEwLGNsZWFyQ2FudmFzOnl0LkJnLGlzRnVsbFdvcms6ITB9fSkpfWRyYXdFcmFzZXIoZSx0KXtQcm9taXNlLnJlc29sdmUoZSkudGhlbihyPT57dmFyIGgsZyx1LGE7Y29uc3QgaT1bXTsoaD1yLm5ld1dvcmtEYXRhcykhPW51bGwmJmgubGVuZ3RoJiYoaS5wdXNoKC4uLnIubmV3V29ya0RhdGFzLm1hcChjPT4oe3R5cGU6cHQuRnVsbFdvcmssd29ya0lkOmMud29ya0lkLG9wczppZShjLm9wKSxvcHQ6Yy5vcHQsdG9vbHNUeXBlOmMudG9vbHNUeXBlLHVwZGF0ZU5vZGVPcHQ6e3VzZUFuaW1hdGlvbjohMX19KSkpLGRlbGV0ZSByLm5ld1dvcmtEYXRhcyksaS5wdXNoKHIpLHRoaXMuX3Bvc3Qoe3JlbmRlcjp7cmVjdDpyLnJlY3QsZHJhd0NhbnZhczp5dC5CZyxpc0NsZWFyOiEwLGNsZWFyQ2FudmFzOnl0LkJnLGlzRnVsbFdvcms6ITB9LHNwOml9KTtmb3IobGV0IGM9MDtjPGkubGVuZ3RoO2MrKylpZigoZz1pW2NdLnJlbW92ZUlkcykhPW51bGwmJmcubGVuZ3RoKSh1PWlbY10ucmVtb3ZlSWRzKT09bnVsbHx8dS5mb3JFYWNoKHg9Pnt0aGlzLmN1ck5vZGVNYXAuZGVsZXRlKHgpLHQuY3VyTm9kZU1hcC5kZWxldGUoeCl9KTtlbHNlIGlmKGlbY10udHlwZT09PXB0LkZ1bGxXb3JrKXtjb25zdCB4PShhPWlbY10ud29ya0lkKT09bnVsbD92b2lkIDA6YS50b1N0cmluZygpO2lmKHgpe2NvbnN0IGY9aVtjXS5vcHMsdj1pW2NdLm9wdCxwPWlbY10udG9vbHNUeXBlO3RoaXMudXBkYXRhTm9kZU1hcCh7a2V5Ongsb3BzOmYsb3B0OnYsdG9vbHNUeXBlOnB9KX19fSl9ZHJhd1BlbmNpbChlKXt0aGlzLl9wb3N0KHtkcmF3Q291bnQ6dGhpcy5kcmF3Q291bnQsc3A6KGU9PW51bGw/dm9pZCAwOmUub3ApJiZbZV19KX1kcmF3UGVuY2lsRnVsbChlLHQpeyh0Lm9wYWNpdHl8fDEpPDEmJnRoaXMuX3Bvc3Qoe3JlbmRlcjplLnJlY3QmJntyZWN0OmUucmVjdCxpc0NsZWFyOiEwLGNsZWFyQ2FudmFzOnl0LkJnLGlzRnVsbFdvcms6ITB9fSksdGhpcy5fcG9zdCh7cmVuZGVyOmUucmVjdCYme3JlY3Q6ZS5yZWN0LGRyYXdDYW52YXM6eXQuQmcsaXNDbGVhcjohMCxjbGVhckNhbnZhczp5dC5GbG9hdCxpc0Z1bGxXb3JrOiEwfSxzcDpbZV19KSxlLndvcmtJZCYmdGhpcy51cGRhdGFOb2RlTWFwKHtrZXk6ZS53b3JrSWQudG9TdHJpbmcoKSxvcHM6ZS5vcHMsdG9vbHNUeXBlOlN0LlBlbmNpbCxvcHQ6dH0pfWNvbnN1bWVEcmF3KGUsdCl7dmFyIGg7Y29uc3R7b3A6cix3b3JrSWQ6aX09ZTtpZihyIT1udWxsJiZyLmxlbmd0aCYmaSl7Y29uc3QgZz10aGlzLndvcmtTaGFwZXMuZ2V0KGkpO2lmKCFnKXJldHVybjtjb25zdCB1PWcudG9vbHNUeXBlO2lmKHU9PT1TdC5MYXNlclBlbilyZXR1cm47Y29uc3QgYT1nLmNvbnN1bWUoe2RhdGE6ZSxpc0Z1bGxXb3JrOiEwLG5vZGVNYXBzOnRoaXMuY3VyTm9kZU1hcH0pO2lmKHU9PT1TdC5TZWxlY3Rvcil7YS50eXBlPT09cHQuU2VsZWN0JiYoYS5zZWxlY3RJZHMmJnQucnVuUmV2ZXJzZVNlbGVjdFdvcmsoYS5zZWxlY3RJZHMpLHRoaXMuZHJhd1NlbGVjdG9yKGEsITApKTtyZXR1cm59aWYodT09PVN0LkVyYXNlcil7aWYoKGg9YS5uZXdXb3JrRGF0YXMpIT1udWxsJiZoLmxlbmd0aCl7bGV0IGM9YT09bnVsbD92b2lkIDA6YS5yZWN0O2EubmV3V29ya0RhdGFzLmZvckVhY2goeD0+e2NvbnN0IGY9dGhpcy5zZXRGdWxsV29yayh4KSx2PWYmJmYuY29uc3VtZVNlcnZpY2Uoe29wOngub3AsaXNGdWxsV29yazohMH0pLHA9eC53b3JrSWQudG9TdHJpbmcoKTt2JiYoZy51cGRhdGFOb2RlTWFwKHAse25hbWU6cCxyZWN0OnYsb3B0Ongub3B0LHRvb2xzVHlwZTp4LnRvb2xzVHlwZSxvcDp4Lm9wfSksYz1QdChjLHYpKX0pLGMmJihhLnJlY3Q9Yyl9YSE9bnVsbCYmYS5yZWN0JiZ0aGlzLmRyYXdFcmFzZXIoYSxnKTtyZXR1cm59dT09PVN0LlBlbmNpbCYmKHRoaXMuY29tYmluZVRpbWVySWR8fCh0aGlzLmNvbWJpbmVUaW1lcklkPXNldFRpbWVvdXQoKCk9Pnt0aGlzLmNvbWJpbmVUaW1lcklkPXZvaWQgMCx0aGlzLmRyYXdQZW5jaWxDb21iaW5lKGkpfSxNYXRoLmZsb29yKGcuZ2V0V29ya09wdGlvbnMoKS5zeW5jVW5pdFRpbWV8fHRoaXMuY29tYmluZVVuaXRUaW1lLzIpKSksYSYmKHRoaXMuZHJhd0NvdW50KyssdGhpcy5kcmF3UGVuY2lsKGEpKSl9fWNvbnN1bWVEcmF3QWxsKGUsdCl7dmFyIGk7dGhpcy5jb21iaW5lVGltZXJJZCYmKGNsZWFyVGltZW91dCh0aGlzLmNvbWJpbmVUaW1lcklkKSx0aGlzLmNvbWJpbmVUaW1lcklkPXZvaWQgMCk7Y29uc3R7d29ya0lkOnJ9PWU7aWYocil7Y29uc3QgaD10aGlzLndvcmtTaGFwZXMuZ2V0KHIpO2lmKCFoKXJldHVybjt0aGlzLmRyYXdDb3VudD0wO2NvbnN0IGc9aC50b29sc1R5cGU7aWYoZz09PVN0Lkxhc2VyUGVuKXJldHVybjtjb25zdCB1PWguY29uc3VtZUFsbCh7ZGF0YTplLG5vZGVNYXBzOnRoaXMuY3VyTm9kZU1hcH0pO2lmKGc9PT1TdC5TZWxlY3Rvcil7dS5zZWxlY3RJZHMmJnQucnVuUmV2ZXJzZVNlbGVjdFdvcmsodS5zZWxlY3RJZHMpLHRoaXMuZHJhd1NlbGVjdG9yKHUsITEpLChpPWguc2VsZWN0SWRzKSE9bnVsbCYmaS5sZW5ndGg/aC5jbGVhclRtcFBvaW50cygpOnRoaXMuY2xlYXJXb3JrU2hhcGVOb2RlQ2FjaGUocik7cmV0dXJufWlmKGc9PT1TdC5FcmFzZXIpe3UhPW51bGwmJnUucmVjdCYmdGhpcy5kcmF3RXJhc2VyKHUsaCksaC5jbGVhclRtcFBvaW50cygpO3JldHVybn1nPT09U3QuUGVuY2lsJiYodSE9bnVsbCYmdS5yZWN0JiZ0aGlzLmRyYXdQZW5jaWxGdWxsKHUsaC5nZXRXb3JrT3B0aW9ucygpKSx0aGlzLmNsZWFyV29ya1NoYXBlTm9kZUNhY2hlKHIpKX19dXBkYXRlU2VsZWN0b3IoZSl7dmFyIE0sbSx5LG47Y29uc3QgdD10aGlzLndvcmtTaGFwZXMuZ2V0KHZ0LnNlbGVjdG9ySWQpO2lmKCEoKE09dC5zZWxlY3RJZHMpIT1udWxsJiZNLmxlbmd0aCkpcmV0dXJuO2NvbnN0e3VwZGF0ZVNlbGVjdG9yT3B0OnIsd2lsbFJlZnJlc2hTZWxlY3RvcjppLHdpbGxTeW5jU2VydmljZTpoLHdpbGxTZXJpYWxpemVEYXRhOmcsZW1pdEV2ZW50VHlwZTp1LHNlbGVjdFN0b3JlOmF9PWUsYz1yLndvcmtTdGF0ZTtsZXQgeDtjb25zdCBmPSh1PT09UnQuUm90YXRlTm9kZXx8dT09PVJ0LlNjYWxlTm9kZSkmJmM9PT13dC5Eb25lJiZnO2kmJnQmJih4PXQub2xkUmVjdCk7Y29uc3Qgdj10PT1udWxsP3ZvaWQgMDp0LnVwZGF0ZVNlbGVjdG9yKHt1cGRhdGVTZWxlY3Rvck9wdDpyLHNlbGVjdElkczp0LnNlbGVjdElkc30pO2xldCBwPXYmJmkmJntyZWN0OnU9PT1SdC5TY2FsZU5vZGUmJmMhPT13dC5Eb25lP1B0KHgsdi5yZWN0KTp2LnJlY3QsaXNDbGVhcjohMCxpc0Z1bGxXb3JrOiExLGNsZWFyQ2FudmFzOnU9PT1SdC5TY2FsZU5vZGU/eXQuRmxvYXQ6eXQuU2VsZWN0b3IsZHJhd0NhbnZhczp1PT09UnQuU2NhbGVOb2RlJiZjIT09d3QuRG9uZT95dC5GbG9hdDp5dC5TZWxlY3Rvcn18fHZvaWQgMDt2JiZpJiZnJiZwJiYhZiYmKHRoaXMuX3Bvc3Qoe3JlbmRlcjpwfSkscD12b2lkIDApO2NvbnN0IEM9bmV3IE1hcDtpZihnJiZ2IT1udWxsJiZ2LnVwZGF0ZU5vZGVPcHRzJiZhKWZvcihjb25zdFtvLHNdb2YgYS5lbnRyaWVzKCkpe2NvbnN0e29wczpsLG9wdDpFLHVwZGF0ZU5vZGVPcHQ6VCx0b29sc1R5cGU6Yn09cztsZXQgSTtjb25zdCBQPUUsTD17Li4uVCwuLi52LnVwZGF0ZU5vZGVPcHRzLmdldChvKX07bGV0IEQ9W107aWYoUCYmTC5jb2xvciYmKFAuY29sb3I9TC5jb2xvcixkZWxldGUgTC5jb2xvciksUCYmTC56SW5kZXgmJihQLnpJbmRleD1MLnpJbmRleCxkZWxldGUgTC56SW5kZXgpLFAmJkwub3BhY2l0eSYmKFAub3BhY2l0eT1MLm9wYWNpdHksZGVsZXRlIEwub3BhY2l0eSksbCYmKEwhPW51bGwmJkwucG9zKSYmKEwhPW51bGwmJkwub3JpZ2luUG9zKSl7Y29uc3QgUj1bTC5wb3NbMF0tTC5vcmlnaW5Qb3NbMF0sTC5wb3NbMV0tTC5vcmlnaW5Qb3NbMV1dLEE9cXQobCkubWFwKChqLEcpPT57Y29uc3QgSD1HJTM7cmV0dXJuIEg9PT0wP2orUlswXTpIPT09MT9qK1JbMV06an0pO0wuc2NhbGUmJihMZShBLEwucG9zLEwuc2NhbGUpLEQ9QSxkZWxldGUgTC5zY2FsZSksST1pZShBKSwobT10aGlzLmRyYXdMYXllcik9PW51bGx8fG0uZ2V0RWxlbWVudHNCeU5hbWUobykuZm9yRWFjaChqPT57aWYoTC5wb3Mpe2NvbnN0IEc9ai5jbGFzc05hbWUuc3BsaXQoIiwiKTtqLnNldEF0dHJpYnV0ZSgiY2xhc3NOYW1lIixgJHtMLnBvc1swXX0sICR7TC5wb3NbMV19LCAke0dbMl19YCl9fSksZGVsZXRlIEwub3JpZ2luUG9zfWlmKGwmJkwuYW5nbGUmJkwub3JpZ2luUG9zKXtjb25zdCBSPXF0KGwpO2JlKFIsTC5vcmlnaW5Qb3MsTC5hbmdsZSksRD1SLEk9aWUoUiksZGVsZXRlIEwuYW5nbGUsZGVsZXRlIEwub3JpZ2luUG9zfWlmKGImJmwmJkUmJkQubGVuZ3RoKXtjb25zdCBSPXRoaXMuY3JlYXRlV29ya1NoYXBlTm9kZSh7dG9vbHNUeXBlOmIsdG9vbHNPcHQ6RX0pO1I9PW51bGx8fFIuc2V0V29ya0lkKG8pLFI9PW51bGx8fFIuY29uc3VtZVNlcnZpY2Uoe29wOkQsaXNGdWxsV29yazohMSxyZXBsYWNlSWQ6byxpc0NsZWFyQWxsOiExfSl9Qy5zZXQobyx7b3BzOkksdXBkYXRlTm9kZU9wdDpMLG9wdDpQLHRvb2xzVHlwZTpifSl9aWYodiYmKCh5PXYudXBkYXRlTm9kZU9wdHMpIT1udWxsJiZ5LnNpemUpKXtkZWxldGUgci53b3JrU3RhdGU7Y29uc3Qgbz1bXTtpZihoKWlmKGcpe3U9PT1SdC5Sb3RhdGVOb2RlJiZjPT09d3QuRG9uZSYmby5wdXNoKHt0eXBlOnB0LlNlbGVjdCxzZWxlY3RJZHM6dC5zZWxlY3RJZHMsc2VsZWN0UmVjdDp2LnJlY3R9KTtmb3IoY29uc3RbcyxsXW9mIEMuZW50cmllcygpKW8ucHVzaCh7Li4ubCx3b3JrSWQ6cyx0eXBlOnB0LlVwZGF0ZU5vZGV9KX1lbHNlIGZvcihjb25zdFtzLGxdb2Ygdi51cGRhdGVOb2RlT3B0cy5lbnRyaWVzKCkpby5wdXNoKHt3b3JrSWQ6cyx0eXBlOnB0LlVwZGF0ZU5vZGUsdXBkYXRlTm9kZU9wdDpsfSk7aCYmdGhpcy5fcG9zdCh7cmVuZGVyOiFmJiZwfHx2b2lkIDAsc3A6aCYmb3x8dm9pZCAwfSksZiYmcCYmc2V0VGltZW91dCgoKT0+e3ZhciBzO3RoaXMuX3Bvc3Qoe3JlbmRlcjpwfSksYz09PXd0LkRvbmUmJigocz10LnNlbGVjdElkcyk9PW51bGx8fHMuZm9yRWFjaChsPT57Y29uc3QgRT1vPT1udWxsP3ZvaWQgMDpvLmZpbmQoVD0+KFQ9PW51bGw/dm9pZCAwOlQud29ya0lkKSYmVC53b3JrSWQ9PT1sKTt0aGlzLnVwZGF0YU5vZGVNYXAoe2tleTpsLG9wczpFPT1udWxsP3ZvaWQgMDpFLm9wcyxvcHQ6RT09bnVsbD92b2lkIDA6RS5vcHR9KX0pKX0sMjApLCFmJiZjPT09d3QuRG9uZSYmKChuPXQuc2VsZWN0SWRzKT09bnVsbHx8bi5mb3JFYWNoKHM9Pntjb25zdCBsPW89PW51bGw/dm9pZCAwOm8uZmluZChFPT4oRT09bnVsbD92b2lkIDA6RS53b3JrSWQpJiZFLndvcmtJZD09PXMpO3RoaXMudXBkYXRhTm9kZU1hcCh7a2V5OnMsb3BzOmw9PW51bGw/dm9pZCAwOmwub3BzLG9wdDpsPT1udWxsP3ZvaWQgMDpsLm9wdH0pfSkpfX1ibHVyU2VsZWN0b3IoKXtjb25zdCBlPXRoaXMud29ya1NoYXBlcy5nZXQodnQuc2VsZWN0b3JJZCk7aWYoZSl7Y29uc3QgdD1lPT1udWxsP3ZvaWQgMDplLmJsdXJTZWxlY3RvcigpO3RoaXMuY2xlYXJXb3JrU2hhcGVOb2RlQ2FjaGUodnQuc2VsZWN0b3JJZCksdGhpcy5fcG9zdCh7cmVuZGVyOih0PT1udWxsP3ZvaWQgMDp0LnJlY3QpJiZ7cmVjdDp0LnJlY3QsZHJhd0NhbnZhczp5dC5CZyxpc0NsZWFyOiEwLGNsZWFyQ2FudmFzOnl0LkJnLGlzRnVsbFdvcms6ITB9LHNwOlt0XX0pfX1zZXRGdWxsV29yayhlKXtjb25zdHt3b3JrSWQ6dCxvcHQ6cix0b29sc1R5cGU6aX09ZTtpZih0JiZyJiZpKXtjb25zdCBoPXQmJnRoaXMud29ya1NoYXBlcy5nZXQodCl8fHRoaXMuY3JlYXRlV29ya1NoYXBlTm9kZSh7dG9vbHNPcHQ6cix0b29sc1R5cGU6aX0pO3JldHVybiBoPyhoLnNldFdvcmtJZCh0KSx0aGlzLndvcmtTaGFwZXMuc2V0KHQsaCksaCk6dm9pZCAwfX1jb25zdW1lRnVsbChlKXt2YXIgaSxoO2NvbnN0IHQ9dGhpcy5zZXRGdWxsV29yayhlKSxyPWUub3BzJiZxdChlLm9wcyk7aWYodCl7bGV0IGc9dC5jb25zdW1lU2VydmljZSh7b3A6cixpc0Z1bGxXb3JrOiEwLHJlcGxhY2VJZDooaT10LmdldFdvcmtJZCgpKT09bnVsbD92b2lkIDA6aS50b1N0cmluZygpfSk7Zz1QdChnLChlPT1udWxsP3ZvaWQgMDplLnVwZGF0ZU5vZGVPcHQpJiZ0LnVwZGF0YU9wdFNlcnZpY2UoZS51cGRhdGVOb2RlT3B0KSksZyYmZS53aWxsUmVmcmVzaCYmKHRoaXMuX3Bvc3Qoe3JlbmRlcjp7cmVjdDpnLGRyYXdDYW52YXM6eXQuQmcsaXNGdWxsV29yazohMH0sc3A6ZS53aWxsU3luY1NlcnZpY2UmJlt7b3B0OmUub3B0LHRvb2xzVHlwZTplLnRvb2xzVHlwZSx0eXBlOnB0LkZ1bGxXb3JrLHdvcmtJZDplLndvcmtJZCxvcHM6ZS5vcHMsdXBkYXRlTm9kZU9wdDplLnVwZGF0ZU5vZGVPcHR9XXx8dm9pZCAwfSksZS53b3JrSWQmJnRoaXMudXBkYXRhTm9kZU1hcCh7a2V5OihoPWUud29ya0lkKT09bnVsbD92b2lkIDA6aC50b1N0cmluZygpLG9wczplLm9wcyxvcHQ6ZS5vcHQsdG9vbHNUeXBlOmUudG9vbHNUeXBlfSkpLGUud29ya0lkJiZ0aGlzLndvcmtTaGFwZXMuZGVsZXRlKGUud29ya0lkKX19dXBkYXRlTm9kZShlKXtjb25zdHt3b3JrSWQ6dCx1cGRhdGVOb2RlT3B0OnIsd2lsbFJlZnJlc2g6aSx3aWxsU3luY1NlcnZpY2U6aH09ZTtpZih0KXtjb25zdCBnPXQudG9TdHJpbmcoKTtsZXQgdTtjb25zdCBhPXt9O3RoaXMuZnVsbExheWVyLmdldEVsZW1lbnRzQnlOYW1lKGcpLmZvckVhY2goYz0+e2lmKGkpe2NvbnN0IHg9Yy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTt1PVB0KHUse3g6TWF0aC5mbG9vcih4LngtMTApLHk6TWF0aC5mbG9vcih4LnktMTApLHc6TWF0aC5mbG9vcih4LndpZHRoKzIwKSxoOk1hdGguZmxvb3IoeC5oZWlnaHQrMjApfSl9aWYoci5wb3MmJihhLnBvcz1yLnBvcyxjLnNldEF0dHJpYnV0ZSgicG9zIixyLnBvcykpLHIuekluZGV4RGlzdGFuY2V8fHIuekluZGV4KXtpZihyLnpJbmRleERpc3RhbmNlKXtjb25zdCB4PWMuZ2V0QXR0cmlidXRlKCJ6SW5kZXgiKTthLnpJbmRleD14K3IuekluZGV4fWVsc2UgYS56SW5kZXg9ci56SW5kZXg7Yy5zZXRBdHRyaWJ1dGUoInpJbmRleCIsYS56SW5kZXgpfWlmKHIuY29sb3ImJihhLmNvbG9yPXIuY29sb3IsYy5zZXRBdHRyaWJ1dGUoInN0cm9rZUNvbG9yIixhLmNvbG9yKSxjLmdldEF0dHJpYnV0ZSgiZmlsbENvbG9yIikmJmMuc2V0QXR0cmlidXRlKCJzdHJva2VDb2xvciIsYS5jb2xvcikpLGkpe2NvbnN0IHg9Yy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTt1PVB0KHUse3g6TWF0aC5mbG9vcih4LngtMTApLHk6TWF0aC5mbG9vcih4LnktMTApLHc6TWF0aC5mbG9vcih4LndpZHRoKzIwKSxoOk1hdGguZmxvb3IoeC5oZWlnaHQrMjApfSl9fSksKHV8fGgpJiZ0aGlzLl9wb3N0KHtyZW5kZXI6dSYme3JlY3Q6dSxkcmF3Q2FudmFzOnl0LkJnLGlzQ2xlYXI6ITAsY2xlYXJDYW52YXM6eXQuQmcsaXNGdWxsV29yazohMH0sc3A6aCYmW3t0eXBlOnB0LlVwZGF0ZU5vZGUsd29ya0lkOnQsdXBkYXRlTm9kZU9wdDphfV18fHZvaWQgMH0pfX1yZW1vdmVXb3JrKGUpe3ZhciBpO2NvbnN0e3dvcmtJZDp0fT1lLHI9dD09bnVsbD92b2lkIDA6dC50b1N0cmluZygpO2lmKHIpe3RoaXMud29ya1NoYXBlcy5oYXMocikmJnRoaXMuY2xlYXJXb3JrU2hhcGVOb2RlQ2FjaGUocik7bGV0IGg7Y29uc3QgZz1bXSx1PXRoaXMuY3VyTm9kZU1hcC5nZXQocik7dSYmdGhpcy5jdXJOb2RlTWFwLmRlbGV0ZShyKSx0aGlzLmZ1bGxMYXllci5nZXRFbGVtZW50c0J5TmFtZShyKS5jb25jYXQoKChpPXRoaXMuZHJhd0xheWVyKT09bnVsbD92b2lkIDA6aS5nZXRFbGVtZW50c0J5TmFtZShyKSl8fFtdKS5mb3JFYWNoKGE9PntpZih1KWg9UHQoaCx1LnJlY3QpO2Vsc2V7Y29uc3QgYz1hLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO2g9UHQoaCx7eDpjLngseTpjLnksdzpjLndpZHRoLGg6Yy5oZWlnaHR9KX1nLnB1c2goYSl9KSxnLmxlbmd0aCYmZy5mb3JFYWNoKGE9PmEucmVtb3ZlKCkpLGgmJnRoaXMuX3Bvc3Qoe3JlbmRlcjp7cmVjdDpoLGlzQ2xlYXI6ITAsaXNGdWxsV29yazohMCxjbGVhckNhbnZhczp5dC5CZyxkcmF3Q2FudmFzOnl0LkJnfX0pLHRoaXMuY3VyTm9kZU1hcC5kZWxldGUocil9fXJ1blJldmVyc2VTZWxlY3RXb3JrKGUpe2NvbnN0IHQ9dGhpcy53b3JrU2hhcGVzLmdldCh2dC5zZWxlY3RvcklkKSx7c2VsZWN0SWRzOnJ9PWUsaT1bXTtpZih0JiZyJiZ0LnNlbGVjdElkcyl7Zm9yKGNvbnN0IGggb2Ygcil7Y29uc3QgZz10LnNlbGVjdElkcy5maW5kSW5kZXgodT0+dT09PWgpO2c+LTEmJih0LnNlbGVjdElkcy5zcGxpY2UoZywxKSxpLnB1c2goaCkpfWlmKGkubGVuZ3RoKXtjb25zdCBoPVtdO3Quc2VsZWN0SWRzLmxlbmd0aCE9PTAmJnRoaXMucmVyUmVuZGVyU2VsZWN0b3IoKTtsZXQgZztpLmZvckVhY2godT0+e3ZhciBjO2NvbnN0IGE9KGM9dGhpcy5kcmF3TGF5ZXIpPT1udWxsP3ZvaWQgMDpjLmdldEVsZW1lbnRzQnlOYW1lKHUpWzBdO2lmKGEpe2NvbnN0IHg9YS5jbG9uZU5vZGUoITApO2lmKHgudGFnTmFtZT09PSJHUk9VUCIpe2NvbnN0IHY9YS5jbGFzc05hbWUuc3BsaXQoIiwiKTt2Lmxlbmd0aD09PTMmJk51bWJlcih2WzJdKT09PUR0LlN0cm9rZSYmeC5zZWFsKCl9aC5wdXNoKHgpLGEucmVtb3ZlKCk7Y29uc3QgZj10aGlzLmN1ck5vZGVNYXAuZ2V0KHUpO2YmJihnPVB0KGcsZi5yZWN0KSl9fSksaC5sZW5ndGgmJnRoaXMuZnVsbExheWVyLmFwcGVuZCguLi5oKSxnJiZ0aGlzLl9wb3N0KHtyZW5kZXI6e3JlY3Q6Zyxpc0NsZWFyOiEwLGlzRnVsbFdvcms6ITAsY2xlYXJDYW52YXM6eXQuQmcsZHJhd0NhbnZhczp5dC5CZ30sc3A6dC5zZWxlY3RJZHMubGVuZ3RoPT09MCYmW3t0eXBlOnB0LlNlbGVjdCxzZWxlY3RJZHM6W10sd2lsbFN5bmNTZXJ2aWNlOiExfV18fHZvaWQgMH0pfX19fWNsYXNzIEdlIGV4dGVuZHMgemV7Y29uc3RydWN0b3IoZSx0LHIsaSl7c3VwZXIoZSx0LHIpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ3b3JrU2hhcGVzIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6bmV3IE1hcH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJhbmltYXRpb25JZCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzZWxlY3RvcldvcmtTaGFwZXMiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpuZXcgTWFwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIl9wb3N0Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIndpbGxSdW5FZmZlY3RTZWxlY3RvcklkcyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOm5ldyBTZXR9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywicnVuRWZmZWN0SWQiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywibm9BbmltYXRpb25SZWN0Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksdGhpcy5fcG9zdD1pfWFjdGl2ZVdvcmtTaGFwZShlKXt2YXIgcCxDLE07Y29uc3R7d29ya0lkOnQsb3B0OnIsdG9vbHNUeXBlOmksdHlwZTpoLHVwZGF0ZU5vZGVPcHQ6ZyxvcHM6dSxvcDphLHVzZUFuaW1hdGlvbjpjLG5vUmVuZGVyOnh9PWU7aWYoIXQpcmV0dXJuO2NvbnN0IGY9dC50b1N0cmluZygpO2lmKCEoKHA9dGhpcy53b3JrU2hhcGVzKSE9bnVsbCYmcC5oYXMoZikpKXtsZXQgbT17dG9vbHNUeXBlOmksYW5pbWF0aW9uV29ya0RhdGE6YXx8W10sYW5pbWF0aW9uSW5kZXg6MCx0eXBlOmgsdXBkYXRlTm9kZU9wdDpnLG9wczp1LHVzZUFuaW1hdGlvbjp0eXBlb2YgYzwidSI/Yzp0eXBlb2YoZz09bnVsbD92b2lkIDA6Zy51c2VBbmltYXRpb24pPCJ1Ij9nPT1udWxsP3ZvaWQgMDpnLnVzZUFuaW1hdGlvbjohMCxvbGRSZWN0OnRoaXMuZ2V0Tm9kZVJlY3QoZiksbm9SZW5kZXI6eH07aSYmciYmKG09dGhpcy5zZXROb2RlS2V5KG0saSxyKSksKEM9dGhpcy53b3JrU2hhcGVzKT09bnVsbHx8Qy5zZXQoZixtKX1jb25zdCB2PShNPXRoaXMud29ya1NoYXBlcyk9PW51bGw/dm9pZCAwOk0uZ2V0KGYpO2gmJih2LnR5cGU9aCksdSYmKHYuYW5pbWF0aW9uV29ya0RhdGE9cXQodSksdi5vcHM9dSksZyYmKHYudXBkYXRlTm9kZU9wdD1nKSxhJiYodi5hbmltYXRpb25Xb3JrRGF0YT1hKSx4JiYodi5ub1JlbmRlcj14KSx2Lm5vZGUmJnYubm9kZS5nZXRXb3JrSWQoKSE9PWYmJnYubm9kZS5zZXRXb3JrSWQoZiksdi50b29sc1R5cGUhPT1pJiZpJiZyJiZ0aGlzLnNldE5vZGVLZXkodixpLHIpfWFjdGl2ZVNlbGVjdG9yU2hhcGUoZSl7dmFyIGMseCxmO2NvbnN0e3dvcmtJZDp0LG9wdDpyLHRvb2xzVHlwZTppLHR5cGU6aCxzZWxlY3RJZHM6Z309ZTtpZighdClyZXR1cm47Y29uc3QgdT10LnRvU3RyaW5nKCk7aWYoISgoYz10aGlzLnNlbGVjdG9yV29ya1NoYXBlcykhPW51bGwmJmMuaGFzKHUpKSl7bGV0IHY9e3Rvb2xzVHlwZTppLHNlbGVjdElkczpnLHR5cGU6aCxvcHQ6cn07aSYmciYmKHY9dGhpcy5zZXROb2RlS2V5KHYsaSxyKSksKHg9dGhpcy5zZWxlY3RvcldvcmtTaGFwZXMpPT1udWxsfHx4LnNldCh1LHYpfWNvbnN0IGE9KGY9dGhpcy5zZWxlY3RvcldvcmtTaGFwZXMpPT1udWxsP3ZvaWQgMDpmLmdldCh1KTtoJiYoYS50eXBlPWgpLGEubm9kZSYmYS5ub2RlLmdldFdvcmtJZCgpIT09dSYmYS5ub2RlLnNldFdvcmtJZCh1KSxhLnNlbGVjdElkcz1nfHxbXX1zZXROb2RlS2V5KGUsdCxyKXtzd2l0Y2goZS50b29sc1R5cGU9dCx0KXtjYXNlIFN0LlBlbmNpbDplLm5vZGU9bmV3IEl0KHIsdGhpcy5mdWxsTGF5ZXIsdGhpcy5kcmF3TGF5ZXIpO2JyZWFrO2Nhc2UgU3QuTGFzZXJQZW46ZS5ub2RlPW5ldyB4ZShyLHRoaXMuZHJhd0xheWVyKTticmVhaztjYXNlIFN0LlNlbGVjdG9yOmUubm9kZT1uZXcgdnQocix0aGlzLmZ1bGxMYXllcik7YnJlYWs7ZGVmYXVsdDplLm5vZGU9dm9pZCAwO2JyZWFrfXJldHVybiBlfWNvbXB1dE5leHRBbmltYXRpb25JbmRleChlLHQpe3ZhciBpO2NvbnN0IHI9TWF0aC5mbG9vcigoZS5hbmltYXRpb25Xb3JrRGF0YXx8W10pLnNsaWNlKGUuYW5pbWF0aW9uSW5kZXgpLmxlbmd0aCozMi90LygoKGk9ZS5ub2RlKT09bnVsbD92b2lkIDA6aS5zeW5jVW5pdFRpbWUpfHwxZTMpKSp0O3JldHVybiBNYXRoLm1pbigoZS5hbmltYXRpb25JbmRleHx8MCkrKHJ8fHQpLChlLmFuaW1hdGlvbldvcmtEYXRhfHxbXSkubGVuZ3RoKX1hbmltYXRpb25EcmF3KCl7dGhpcy5hbmltYXRpb25JZD12b2lkIDA7bGV0IGUsdCxyPSExLGk9ITEsaDt0aGlzLndvcmtTaGFwZXMuZm9yRWFjaCgoZyx1KT0+e3ZhciBhLGMseCxmLHYscCxDLE0sbSx5LG47aWYoZy51c2VBbmltYXRpb24pe2NvbnN0IG89Zy50b29sc1R5cGU9PT1TdC5QZW5jaWw/MzoyLHM9dGhpcy5jb21wdXROZXh0QW5pbWF0aW9uSW5kZXgoZyxvKSxsPU1hdGgubWF4KDAsKGcuYW5pbWF0aW9uSW5kZXh8fDApLW8pLEU9KGcuYW5pbWF0aW9uV29ya0RhdGF8fFtdKS5zbGljZShsLHMpO2xldCBUOyhnLmFuaW1hdGlvbkluZGV4fHwwKTxzPyhUPSh2PWcubm9kZSk9PW51bGw/dm9pZCAwOnYuY29uc3VtZVNlcnZpY2Uoe29wOkUsaXNGdWxsV29yazohMSxyZXBsYWNlSWQ6KGY9Zy5ub2RlLmdldFdvcmtJZCgpKT09bnVsbD92b2lkIDA6Zi50b1N0cmluZygpfSksZy50b29sc1R5cGU9PT1TdC5MYXNlclBlbj8odD1QdCh0LFQpLGcudGltZXImJihjbGVhclRpbWVvdXQoZy50aW1lciksZy50aW1lcj12b2lkIDApKTpnLm5vUmVuZGVyfHwoZT1QdChlLFQpLGcudG90YWxSZWN0PVB0KGcudG90YWxSZWN0LFQpKSxyPSEwLGcuYW5pbWF0aW9uSW5kZXg9cyk6Zy5pc0RlbD9nLmlzRGVsJiYoZy50b29sc1R5cGU9PT1TdC5MYXNlclBlbiYmKFQ9KHk9Zy5ub2RlKT09bnVsbD92b2lkIDA6eS5jb25zdW1lU2VydmljZSh7b3A6W10saXNGdWxsV29yazohMX0pLGcubm9SZW5kZXJ8fCh0PVB0KHQsVCkpKSx0aGlzLnVwZGF0YU5vZGVNYXAodSxnLm9wcywobj1nLm5vZGUpPT1udWxsP3ZvaWQgMDpuLmdldFdvcmtPcHRpb25zKCkpLHRoaXMud29ya1NoYXBlcy5kZWxldGUodSkpOihnLnRvb2xzVHlwZT09PVN0LlBlbmNpbCYmZy5vcHMmJihUPShDPWcubm9kZSk9PW51bGw/dm9pZCAwOkMuY29uc3VtZVNlcnZpY2Uoe29wOmcuYW5pbWF0aW9uV29ya0RhdGF8fFtdLGlzRnVsbFdvcms6ITAscmVwbGFjZUlkOihwPWcubm9kZS5nZXRXb3JrSWQoKSk9PW51bGw/dm9pZCAwOnAudG9TdHJpbmcoKX0pLGcuaXNEZWw9ITAsaT0hMCxnLm5vUmVuZGVyfHwodD1QdCh0LFQpLGcudG90YWxSZWN0PXQpKSxnLnRvb2xzVHlwZT09PVN0Lkxhc2VyUGVuJiYoZy50aW1lcnx8KGcudGltZXI9c2V0VGltZW91dCgoKT0+e2cudGltZXI9dm9pZCAwLGcuaXNEZWw9ITAsdGhpcy5ydW5BbmltYXRpb24oKX0sKChNPWcubm9kZSk9PW51bGw/dm9pZCAwOk0uZ2V0V29ya09wdGlvbnMoKSkuZHVyYXRpb24qMWUzKzEwMCkpLGk9ITEsVD0obT1nLm5vZGUpPT1udWxsP3ZvaWQgMDptLmNvbnN1bWVTZXJ2aWNlKHtvcDpbXSxpc0Z1bGxXb3JrOiExfSksdD1QdCh0LFQpKSxyPSEwKX1lbHNlIGlmKGcudG9vbHNUeXBlPT09U3QuUGVuY2lsJiZnLm9wcyl7bGV0IG89KGE9Zy5ub2RlKT09bnVsbD92b2lkIDA6YS5jb25zdW1lU2VydmljZSh7b3A6Zy5hbmltYXRpb25Xb3JrRGF0YXx8W10saXNGdWxsV29yazohMCxyZXBsYWNlSWQ6dX0pO289UHQoZy5vbGRSZWN0LG8pLG89UHQobywoYz1nLm5vZGUpPT1udWxsP3ZvaWQgMDpjLnVwZGF0YU9wdFNlcnZpY2UoZy51cGRhdGVOb2RlT3B0KSksZy5ub1JlbmRlcnx8KGg9UHQoaCxvKSksdGhpcy5zZWxlY3RvcldvcmtTaGFwZXMuZm9yRWFjaCgocyxsKT0+e3ZhciBFOyhFPXMuc2VsZWN0SWRzKSE9bnVsbCYmRS5pbmNsdWRlcyh1KSYmKHRoaXMud2lsbFJ1bkVmZmVjdFNlbGVjdG9ySWRzLmFkZChsKSx0aGlzLm5vQW5pbWF0aW9uUmVjdD1QdCh0aGlzLm5vQW5pbWF0aW9uUmVjdCxoKSxoPXZvaWQgMCx0aGlzLnJ1bkVmZmVjdCgpKX0pLHRoaXMudXBkYXRhTm9kZU1hcCh1LGcub3BzLCh4PWcubm9kZSk9PW51bGw/dm9pZCAwOnguZ2V0V29ya09wdGlvbnMoKSksdGhpcy53b3JrU2hhcGVzLmRlbGV0ZSh1KX19KSxyJiZ0aGlzLnJ1bkFuaW1hdGlvbigpLGUmJnRoaXMuX3Bvc3Qoe3JlbmRlcjp7cmVjdDplLGRyYXdDYW52YXM6aT95dC5CZzp5dC5GbG9hdCxpc0NsZWFyOmksY2xlYXJDYW52YXM6eXQuRmxvYXQsaXNGdWxsV29yazppfX0pLHQmJlByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCk9Pnt0aGlzLl9wb3N0KHtyZW5kZXI6e3JlY3Q6dCxkcmF3Q2FudmFzOmk/eXQuQmc6eXQuRmxvYXQsaXNDbGVhcjohMCxjbGVhckNhbnZhczp5dC5GbG9hdCxpc0Z1bGxXb3JrOml9fSl9KSxoJiZQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpPT57dGhpcy5fcG9zdCh7cmVuZGVyOntyZWN0OmgsZHJhd0NhbnZhczp5dC5CZyxpc0NsZWFyOiEwLGNsZWFyQ2FudmFzOnl0LkJnLGlzRnVsbFdvcms6ITB9fSl9KX1ydW5FZmZlY3QoKXt0aGlzLnJ1bkVmZmVjdElkfHwodGhpcy5ydW5FZmZlY3RJZD1zZXRUaW1lb3V0KHRoaXMuZWZmZWN0UnVuU2VsZWN0b3IuYmluZCh0aGlzKSwwKSl9cnVuQW5pbWF0aW9uKCl7dGhpcy5hbmltYXRpb25JZHx8KHRoaXMuYW5pbWF0aW9uSWQ9cmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuYW5pbWF0aW9uRHJhdy5iaW5kKHRoaXMpKSl9Y29uc3VtZURyYXcoZSl7dGhpcy5hY3RpdmVXb3JrU2hhcGUoZSksdGhpcy5ydW5BbmltYXRpb24oKX1jb25zdW1lRnVsbChlKXt0aGlzLmFjdGl2ZVdvcmtTaGFwZShlKSx0aGlzLnJ1bkFuaW1hdGlvbigpfWNsZWFyQWxsV29ya1NoYXBlc0NhY2hlKCl7dGhpcy53b3JrU2hhcGVzLmZvckVhY2goKGUsdCk9PntlLnRvb2xzVHlwZT09PVN0Lkxhc2VyUGVuP3NldFRpbWVvdXQoKCk9Pnt0aGlzLndvcmtTaGFwZXMuZGVsZXRlKHQpfSwyZTMpOnRoaXMud29ya1NoYXBlcy5kZWxldGUodCl9KX1ydW5TZWxlY3RXb3JrKGUpe3RoaXMuYWN0aXZlU2VsZWN0b3JTaGFwZShlKTtjb25zdHt3b3JrSWQ6dH09ZSxyPXQ9PW51bGw/dm9pZCAwOnQudG9TdHJpbmcoKTtyJiZ0aGlzLndpbGxSdW5FZmZlY3RTZWxlY3Rvcklkcy5hZGQociksdGhpcy5ydW5FZmZlY3QoKX1yZW1vdmVTZWxlY3RXb3JrKGUpe2NvbnN0e3dvcmtJZDp0fT1lLHI9dD09bnVsbD92b2lkIDA6dC50b1N0cmluZygpO3ImJih0aGlzLmFjdGl2ZVNlbGVjdG9yU2hhcGUoZSksdGhpcy53aWxsUnVuRWZmZWN0U2VsZWN0b3JJZHMuYWRkKHIpKSx0aGlzLnJ1bkVmZmVjdCgpfWVmZmVjdFJ1blNlbGVjdG9yKCl7dGhpcy5ydW5FZmZlY3RJZD12b2lkIDA7bGV0IGU9dGhpcy5ub0FuaW1hdGlvblJlY3Q7dGhpcy53aWxsUnVuRWZmZWN0U2VsZWN0b3JJZHMuZm9yRWFjaCh0PT57dmFyIGgsZztjb25zdCByPXRoaXMuc2VsZWN0b3JXb3JrU2hhcGVzLmdldCh0KSxpPXImJnIuc2VsZWN0SWRzJiYoKGg9ci5ub2RlKT09bnVsbD92b2lkIDA6aC5zZWxlY3RTZXJ2aWNlTm9kZSh0LHIsdGhpcy5jdXJOb2RlTWFwKSk7ZT1QdChlLGkpLChnPXI9PW51bGw/dm9pZCAwOnIuc2VsZWN0SWRzKSE9bnVsbCYmZy5sZW5ndGh8fHRoaXMuc2VsZWN0b3JXb3JrU2hhcGVzLmRlbGV0ZSh0KX0pLGUmJnRoaXMuX3Bvc3Qoe3JlbmRlcjp7cmVjdDplLGRyYXdDYW52YXM6eXQuQmcsaXNDbGVhcjohMCxjbGVhckNhbnZhczp5dC5CZyxpc0Z1bGxXb3JrOiEwfX0pLHRoaXMud2lsbFJ1bkVmZmVjdFNlbGVjdG9ySWRzLmNsZWFyKCksdGhpcy5ub0FuaW1hdGlvblJlY3Q9dm9pZCAwfXJlbW92ZVdvcmsoZSl7Y29uc3R7d29ya0lkOnR9PWUscj10PT1udWxsP3ZvaWQgMDp0LnRvU3RyaW5nKCk7aWYocil7Y29uc3QgaT10aGlzLndvcmtTaGFwZXMuZ2V0KHIpO2lmKGkpe3RoaXMud29ya1NoYXBlcy5kZWxldGUociksdGhpcy5yZW1vdmVOb2RlKHIsZSxpPT1udWxsP3ZvaWQgMDppLnRvdGFsUmVjdCwhMSk7cmV0dXJufXRoaXMucmVtb3ZlTm9kZShyLGUpfX1yZW1vdmVOb2RlKGUsdCxyLGk9ITApe3ZhciBhO2NvbnN0IGg9dGhpcy5mdWxsTGF5ZXIuZ2V0RWxlbWVudHNCeU5hbWUoZSkuY29uY2F0KChhPXRoaXMuZHJhd0xheWVyKT09bnVsbD92b2lkIDA6YS5nZXRFbGVtZW50c0J5TmFtZShlKSk7ZS5pbmRleE9mKHZ0LnNlbGVjdG9ySWQpPi0xJiZ0aGlzLnJlbW92ZVNlbGVjdFdvcmsodCk7Y29uc3QgZz1bXTtsZXQgdT1yO2guZm9yRWFjaChjPT57Y29uc3QgeD1jLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO3U9UHQodSx7eDpNYXRoLmZsb29yKHgueC0xMCkseTpNYXRoLmZsb29yKHgueS0xMCksdzpNYXRoLmZsb29yKHgud2lkdGgrMjApLGg6TWF0aC5mbG9vcih4LmhlaWdodCsyMCl9KSxnLnB1c2goYyl9KSxnLmxlbmd0aCYmZy5mb3JFYWNoKGM9PmMucmVtb3ZlKCkpLHUmJih0aGlzLl9wb3N0KHtyZW5kZXI6e3JlY3Q6dSxpc0NsZWFyOiEwLGlzRnVsbFdvcms6aSxjbGVhckNhbnZhczppP3l0LkJnOnl0LkZsb2F0LGRyYXdDYW52YXM6aT95dC5CZzp5dC5GbG9hdH19KSx0aGlzLmN1ck5vZGVNYXAuZGVsZXRlKGUpKX1nZXROb2RlUmVjdChlKXtsZXQgdDtyZXR1cm4gdGhpcy5mdWxsTGF5ZXIuZ2V0RWxlbWVudHNCeU5hbWUoZSkuZm9yRWFjaChyPT57Y29uc3QgaT1yLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLGg9TWF0aC5mbG9vcihpLmxlZnQtSXQuUGVuY2lsQm9yZGVyUGFkZGluZyksZz1NYXRoLmZsb29yKGkudG9wLUl0LlBlbmNpbEJvcmRlclBhZGRpbmcpLHU9TWF0aC5jZWlsKGkud2lkdGgrSXQuUGVuY2lsQm9yZGVyUGFkZGluZyoyKSxhPU1hdGguY2VpbChpLmhlaWdodCtJdC5QZW5jaWxCb3JkZXJQYWRkaW5nKjIpO3Q9UHQodCx7eDpoLHk6Zyx3OnUsaDphfSl9KSx0fXJ1blJldmVyc2VTZWxlY3RXb3JrKGUpe2UuZm9yRWFjaCh0PT57dGhpcy5zZWxlY3RvcldvcmtTaGFwZXMuZm9yRWFjaCgocixpKT0+e3ZhciBoO2lmKChoPXIuc2VsZWN0SWRzKSE9bnVsbCYmaC5sZW5ndGgpe2NvbnN0IGc9ci5zZWxlY3RJZHMuaW5kZXhPZih0KTtnPi0xJiYoci5zZWxlY3RJZHMuc3BsaWNlKGcsMSksdGhpcy53aWxsUnVuRWZmZWN0U2VsZWN0b3JJZHMuYWRkKGkpKX19KX0pLHRoaXMud2lsbFJ1bkVmZmVjdFNlbGVjdG9ySWRzLnNpemUmJnRoaXMucnVuRWZmZWN0KCl9fWNsYXNzIFh0e2NvbnN0cnVjdG9yKCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImxvY2FsV29yayIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzZXJ2aWNlV29yayIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pfXJlZ2lzdGVyRm9yV29ya2VyKGUsdCl7cmV0dXJuIHRoaXMubG9jYWxXb3JrPWUsdGhpcy5zZXJ2aWNlV29yaz10LHRoaXN9fWNsYXNzICRlIGV4dGVuZHMgWHR7Y29uc3RydWN0b3IoKXtzdXBlciguLi5hcmd1bWVudHMpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJlbWl0RXZlbnRUeXBlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6UnQuWkluZGV4QWN0aXZlfSl9Y29uc3VtZShlKXtjb25zdHttc2dUeXBlOnQsZGF0YVR5cGU6cixlbWl0RXZlbnRUeXBlOml9PWU7aWYodD09PXB0LlVwZGF0ZU5vZGUmJnI9PT1BdC5Mb2NhbCYmaT09PXRoaXMuZW1pdEV2ZW50VHlwZSlyZXR1cm4gdGhpcy5jb25zdW1lRm9yTG9jYWxXb3JrZXIoZSksITB9Y29uc3VtZUZvckxvY2FsV29ya2VyKGUpe3ZhciB1LGEsYyx4LGYsdixwLEM7Y29uc3R7d29ya0lkOnQsaXNBY3RpdmVaSW5kZXg6cix3aWxsUmVmcmVzaFNlbGVjdG9yOml9PWU7aWYodCE9PXZ0LnNlbGVjdG9ySWQpcmV0dXJuO2NvbnN0IGg9KHU9dGhpcy5sb2NhbFdvcmspPT1udWxsP3ZvaWQgMDp1LndvcmtTaGFwZXMuZ2V0KHZ0LnNlbGVjdG9ySWQpO2lmKCFoKXJldHVybjtjb25zdCBnPWgub2xkUmVjdDtpZihyJiZnKXtjb25zdCBNPVtdLG09W107aC5jdXJOb2RlTWFwLmZvckVhY2goKHksbik9Pnt2YXIgbztsZShnLHkucmVjdCkmJigobz10aGlzLmxvY2FsV29yayk9PW51bGx8fG8uZnVsbExheWVyLmdldEVsZW1lbnRzQnlOYW1lKG4pLmZvckVhY2gocz0+e2lmKHMpe2NvbnN0IGw9cy5jbG9uZU5vZGUoITApO00ucHVzaChzKSxtLnB1c2gobCl9fSkpfSksTS5sZW5ndGgmJihtLmZvckVhY2goeT0+eS5yZW1vdmUoKSksKGM9KGE9dGhpcy5sb2NhbFdvcmspPT1udWxsP3ZvaWQgMDphLmRyYXdMYXllcik9PW51bGx8fGMuYXBwZW5kKC4uLk0pKX1lbHNle2NvbnN0IE09W10sbT1bXTsoZj0oeD10aGlzLmxvY2FsV29yayk9PW51bGw/dm9pZCAwOnguZHJhd0xheWVyKT09bnVsbHx8Zi5jaGlsZHJlbi5maWx0ZXIoeT0+e3ZhciBuO3JldHVybiB5Lm5hbWUhPT12dC5zZWxlY3RvcklkJiYhKChuPWguc2VsZWN0SWRzKSE9bnVsbCYmbi5pbmNsdWRlcyh5Lm5hbWUpKX0pLmZvckVhY2goeT0+e2NvbnN0IG49eS5jbG9uZU5vZGUoITApO00ucHVzaChuKSxtLnB1c2goeSl9KSxNLmxlbmd0aCYmKG0uZm9yRWFjaCh5PT55LnJlbW92ZSgpKSwocD0odj10aGlzLmxvY2FsV29yayk9PW51bGw/dm9pZCAwOnYuZnVsbExheWVyKT09bnVsbHx8cC5hcHBlbmQoLi4uTSkpfWkmJigoQz10aGlzLmxvY2FsV29yayk9PW51bGx8fEMuX3Bvc3Qoe3JlbmRlcjp7cmVjdDpnLGRyYXdDYW52YXM6eXQuU2VsZWN0b3IsY2xlYXJDYW52YXM6eXQuU2VsZWN0b3IsaXNDbGVhcjohMCxpc0Z1bGxXb3JrOiExfSxzcDpbe3R5cGU6cHQuU2VsZWN0LHNlbGVjdElkczpoLnNlbGVjdElkcyxvcHQ6aC5nZXRXb3JrT3B0aW9ucygpLHBhZGRpbmc6dnQuU2VsZWN0Qm9yZGVyUGFkZGluZyxzZWxlY3RSZWN0Omgub2xkU2VsZWN0UmVjdCxub2RlQ29sb3I6aC5ub2RlQ29sb3Isd2lsbFN5bmNTZXJ2aWNlOiExfV19KSl9fWNsYXNzIEtlIGV4dGVuZHMgWHR7Y29uc3RydWN0b3IoKXtzdXBlciguLi5hcmd1bWVudHMpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJlbWl0RXZlbnRUeXBlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6UnQuQ29weU5vZGV9KX1jb25zdW1lKGUpe2NvbnN0e21zZ1R5cGU6dCxkYXRhVHlwZTpyLGVtaXRFdmVudFR5cGU6aX09ZTtpZih0PT09cHQuRnVsbFdvcmsmJnI9PT1BdC5Mb2NhbCYmaT09PXRoaXMuZW1pdEV2ZW50VHlwZSlyZXR1cm4gdGhpcy5jb25zdW1lRm9yTG9jYWxXb3JrZXIoZSksITB9Y29uc3VtZUZvckxvY2FsV29ya2VyKGUpe3ZhciByO2NvbnN0e3dvcmtJZDp0fT1lO3QmJigocj10aGlzLmxvY2FsV29yayk9PW51bGx8fHIuY29uc3VtZUZ1bGwoZSkpfX1jbGFzcyBIZSBleHRlbmRzIFh0e2NvbnN0cnVjdG9yKCl7c3VwZXIoLi4uYXJndW1lbnRzKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiZW1pdEV2ZW50VHlwZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOlJ0LlNldENvbG9yTm9kZX0pfWNvbnN1bWUoZSl7Y29uc3R7bXNnVHlwZTp0LGRhdGFUeXBlOnIsZW1pdEV2ZW50VHlwZTppfT1lO2lmKHQ9PT1wdC5VcGRhdGVOb2RlJiZyPT09QXQuTG9jYWwmJmk9PT10aGlzLmVtaXRFdmVudFR5cGUpcmV0dXJuIHRoaXMuY29uc3VtZUZvckxvY2FsV29ya2VyKGUpLCEwfWNvbnN1bWVGb3JMb2NhbFdvcmtlcihlKXt2YXIgYyx4O2NvbnN0e3dvcmtJZDp0LHVwZGF0ZU5vZGVPcHQ6cix3aWxsUmVmcmVzaFNlbGVjdG9yOmksd2lsbFN5bmNTZXJ2aWNlOmgsd2lsbFJlZnJlc2g6ZyxzZWxlY3RTdG9yZTp1LHdpbGxTZXJpYWxpemVEYXRhOmF9PWU7dD09PXZ0LnNlbGVjdG9ySWQmJnI/KGM9dGhpcy5sb2NhbFdvcmspPT1udWxsfHxjLnVwZGF0ZVNlbGVjdG9yKHt1cGRhdGVTZWxlY3Rvck9wdDpyLHdpbGxSZWZyZXNoU2VsZWN0b3I6aSx3aWxsU3luY1NlcnZpY2U6aCxzZWxlY3RTdG9yZTp1LHdpbGxTZXJpYWxpemVEYXRhOmF9KTp0JiZyJiYoKHg9dGhpcy5sb2NhbFdvcmspPT1udWxsfHx4LnVwZGF0ZU5vZGUoe3dvcmtJZDp0LHVwZGF0ZU5vZGVPcHQ6cix3aWxsUmVmcmVzaDpnLHdpbGxTeW5jU2VydmljZTpofSkpfX1jbGFzcyBWZSBleHRlbmRzIFh0e2NvbnN0cnVjdG9yKCl7c3VwZXIoLi4uYXJndW1lbnRzKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiZW1pdEV2ZW50VHlwZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOlJ0LlpJbmRleE5vZGV9KX1jb25zdW1lKGUpe2NvbnN0e21zZ1R5cGU6dCxkYXRhVHlwZTpyLGVtaXRFdmVudFR5cGU6aX09ZTtpZih0PT09cHQuVXBkYXRlTm9kZSYmcj09PUF0LkxvY2FsJiZpPT09dGhpcy5lbWl0RXZlbnRUeXBlKXJldHVybiB0aGlzLmNvbnN1bWVGb3JMb2NhbFdvcmtlcihlKSwhMH1jb25zdW1lRm9yTG9jYWxXb3JrZXIoZSl7dmFyIGMseDtjb25zdHt3b3JrSWQ6dCx1cGRhdGVOb2RlT3B0OnIsd2lsbFJlZnJlc2hTZWxlY3RvcjppLHdpbGxTeW5jU2VydmljZTpoLHdpbGxSZWZyZXNoOmcsc2VsZWN0U3RvcmU6dSx3aWxsU2VyaWFsaXplRGF0YTphfT1lO3Q9PT12dC5zZWxlY3RvcklkJiZyPyhjPXRoaXMubG9jYWxXb3JrKT09bnVsbHx8Yy51cGRhdGVTZWxlY3Rvcih7dXBkYXRlU2VsZWN0b3JPcHQ6cix3aWxsUmVmcmVzaFNlbGVjdG9yOmksd2lsbFN5bmNTZXJ2aWNlOmgsc2VsZWN0U3RvcmU6dSx3aWxsU2VyaWFsaXplRGF0YTphfSk6dCYmciYmKCh4PXRoaXMubG9jYWxXb3JrKT09bnVsbHx8eC51cGRhdGVOb2RlKHt3b3JrSWQ6dCx1cGRhdGVOb2RlT3B0OnIsd2lsbFJlZnJlc2g6Zyx3aWxsU3luY1NlcnZpY2U6aH0pKX19Y2xhc3MgWWUgZXh0ZW5kcyBYdHtjb25zdHJ1Y3Rvcigpe3N1cGVyKC4uLmFyZ3VtZW50cyksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImVtaXRFdmVudFR5cGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpSdC5UcmFuc2xhdGVOb2RlfSl9Y29uc3VtZShlKXtjb25zdHttc2dUeXBlOnQsZGF0YVR5cGU6cixlbWl0RXZlbnRUeXBlOml9PWU7aWYodD09PXB0LlVwZGF0ZU5vZGUmJnI9PT1BdC5Mb2NhbCYmaT09PXRoaXMuZW1pdEV2ZW50VHlwZSlyZXR1cm4gdGhpcy5jb25zdW1lRm9yTG9jYWxXb3JrZXIoZSksITB9Y29uc3VtZUZvckxvY2FsV29ya2VyKGUpe3ZhciBjLHg7Y29uc3R7d29ya0lkOnQsdXBkYXRlTm9kZU9wdDpyLHdpbGxSZWZyZXNoU2VsZWN0b3I6aSx3aWxsU3luY1NlcnZpY2U6aCx3aWxsUmVmcmVzaDpnLHNlbGVjdFN0b3JlOnUsd2lsbFNlcmlhbGl6ZURhdGE6YX09ZTt0PT09dnQuc2VsZWN0b3JJZCYmcj8oYz10aGlzLmxvY2FsV29yayk9PW51bGx8fGMudXBkYXRlU2VsZWN0b3Ioe3VwZGF0ZVNlbGVjdG9yT3B0OnIsd2lsbFJlZnJlc2hTZWxlY3RvcjppLHdpbGxTeW5jU2VydmljZTpoLHNlbGVjdFN0b3JlOnUsd2lsbFNlcmlhbGl6ZURhdGE6YX0pOnQmJnImJigoeD10aGlzLmxvY2FsV29yayk9PW51bGx8fHgudXBkYXRlTm9kZSh7d29ya0lkOnQsdXBkYXRlTm9kZU9wdDpyLHdpbGxSZWZyZXNoOmcsd2lsbFN5bmNTZXJ2aWNlOmh9KSl9fWNsYXNzIFhlIGV4dGVuZHMgWHR7Y29uc3RydWN0b3IoKXtzdXBlciguLi5hcmd1bWVudHMpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJlbWl0RXZlbnRUeXBlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6UnQuRGVsZXRlTm9kZX0pfWNvbnN1bWUoZSl7Y29uc3R7bXNnVHlwZTp0LGRhdGFUeXBlOnIsZW1pdEV2ZW50VHlwZTppfT1lO2lmKHQ9PT1wdC5SZW1vdmVOb2RlKXtpZihyPT09QXQuTG9jYWwmJmk9PT10aGlzLmVtaXRFdmVudFR5cGUpcmV0dXJuIHRoaXMuY29uc3VtZUZvckxvY2FsV29ya2VyKGUpLCEwO2lmKHI9PT1BdC5TZXJ2aWNlJiZpPT09dGhpcy5lbWl0RXZlbnRUeXBlKXJldHVybiB0aGlzLmNvbnN1bWVGb3JTZXJ2aWNlV29ya2VyKGUpLCEwfX1jb25zdW1lRm9yTG9jYWxXb3JrZXIoZSl7dmFyIGcsdSxhLGMseDtpZighdGhpcy5sb2NhbFdvcmspcmV0dXJuO2NvbnN0e3dvcmtJZDp0LHdpbGxSZWZyZXNoOnJ9PWU7aWYoIXQpcmV0dXJuO2xldCBpO2NvbnN0IGg9dGhpcy5sb2NhbFdvcmsud29ya1NoYXBlcy5nZXQodCk7aWYoaCYmdD09PXZ0LnNlbGVjdG9ySWQpe2NvbnN0IGY9aC5zZWxlY3RJZHM7Zj09bnVsbHx8Zi5mb3JFYWNoKHY9Pnt2YXIgcCxDLE07KEM9KHA9dGhpcy5sb2NhbFdvcmspPT1udWxsP3ZvaWQgMDpwLmRyYXdMYXllcik9PW51bGx8fEMuZ2V0RWxlbWVudHNCeU5hbWUodikuZm9yRWFjaChtPT57bS5yZW1vdmUoKX0pLChNPXRoaXMubG9jYWxXb3JrKT09bnVsbHx8TS5jdXJOb2RlTWFwLmRlbGV0ZSh2KX0pLGk9aC5vbGRSZWN0LChhPSh1PShnPXRoaXMubG9jYWxXb3JrLmRyYXdMYXllcik9PW51bGw/dm9pZCAwOmcucGFyZW50KT09bnVsbD92b2lkIDA6dS5nZXRFbGVtZW50QnlJZCh2dC5zZWxlY3RvcklkKSk9PW51bGx8fGEucmVtb3ZlKCksdGhpcy5sb2NhbFdvcmsud29ya1NoYXBlcy5kZWxldGUodnQuc2VsZWN0b3JJZCl9ZWxzZSBpZih0KXtjb25zdCBmPXQudG9TdHJpbmcoKTtsZXQgdj1LdChmLHRoaXMubG9jYWxXb3JrLmZ1bGxMYXllcik7diYmdGhpcy5sb2NhbFdvcmsuZnVsbExheWVyLmdldEVsZW1lbnRzQnlOYW1lKGYpLmZvckVhY2goQz0+Qy5yZW1vdmUoKSk7Y29uc3QgcD1LdChmLHRoaXMubG9jYWxXb3JrLmRyYXdMYXllcik7cCYmKHY9UHQodixwKSwoYz10aGlzLmxvY2FsV29yay5kcmF3TGF5ZXIpPT1udWxsfHxjLmdldEVsZW1lbnRzQnlOYW1lKGYpLmZvckVhY2goQz0+Qy5yZW1vdmUoKSkpLHYmJih2PVNlKHYpKSwoeD10aGlzLmxvY2FsV29yayk9PW51bGx8fHguY3VyTm9kZU1hcC5kZWxldGUoZil9aSYmciYmdGhpcy5sb2NhbFdvcmsuX3Bvc3Qoe3JlbmRlcjp7cmVjdDppLGRyYXdDYW52YXM6eXQuQmcsY2xlYXJDYW52YXM6eXQuQmcsaXNDbGVhcjohMCxpc0Z1bGxXb3JrOiEwfX0pfWNvbnN1bWVGb3JTZXJ2aWNlV29ya2VyKGUpe3RoaXMuc2VydmljZVdvcmsmJnRoaXMuc2VydmljZVdvcmsucmVtb3ZlU2VsZWN0V29yayhlKX19Y2xhc3MgWmUgZXh0ZW5kcyBYdHtjb25zdHJ1Y3Rvcigpe3N1cGVyKC4uLmFyZ3VtZW50cyksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImVtaXRFdmVudFR5cGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpSdC5TY2FsZU5vZGV9KX1jb25zdW1lKGUpe2NvbnN0e21zZ1R5cGU6dCxkYXRhVHlwZTpyLGVtaXRFdmVudFR5cGU6aX09ZTtpZih0PT09cHQuVXBkYXRlTm9kZSYmcj09PUF0LkxvY2FsJiZpPT09dGhpcy5lbWl0RXZlbnRUeXBlKXJldHVybiB0aGlzLmNvbnN1bWVGb3JMb2NhbFdvcmtlcihlKSwhMH1jb25zdW1lRm9yTG9jYWxXb3JrZXIoZSl7dmFyIGMseDtjb25zdHt3b3JrSWQ6dCx1cGRhdGVOb2RlT3B0OnIsd2lsbFJlZnJlc2hTZWxlY3RvcjppLHdpbGxTeW5jU2VydmljZTpoLHdpbGxSZWZyZXNoOmcsc2VsZWN0U3RvcmU6dSx3aWxsU2VyaWFsaXplRGF0YTphfT1lO3Q9PT12dC5zZWxlY3RvcklkJiZyPyhjPXRoaXMubG9jYWxXb3JrKT09bnVsbHx8Yy51cGRhdGVTZWxlY3Rvcih7dXBkYXRlU2VsZWN0b3JPcHQ6cix3aWxsUmVmcmVzaFNlbGVjdG9yOmksd2lsbFN5bmNTZXJ2aWNlOmgsZW1pdEV2ZW50VHlwZTp0aGlzLmVtaXRFdmVudFR5cGUsc2VsZWN0U3RvcmU6dSx3aWxsU2VyaWFsaXplRGF0YTphfSk6dCYmciYmKCh4PXRoaXMubG9jYWxXb3JrKT09bnVsbHx8eC51cGRhdGVOb2RlKHt3b3JrSWQ6dCx1cGRhdGVOb2RlT3B0OnIsd2lsbFJlZnJlc2g6Zyx3aWxsU3luY1NlcnZpY2U6aH0pKX19Y2xhc3MgSmUgZXh0ZW5kcyBYdHtjb25zdHJ1Y3Rvcigpe3N1cGVyKC4uLmFyZ3VtZW50cyksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImVtaXRFdmVudFR5cGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpSdC5Sb3RhdGVOb2RlfSl9Y29uc3VtZShlKXtjb25zdHttc2dUeXBlOnQsZGF0YVR5cGU6cixlbWl0RXZlbnRUeXBlOml9PWU7aWYodD09PXB0LlVwZGF0ZU5vZGUmJnI9PT1BdC5Mb2NhbCYmaT09PXRoaXMuZW1pdEV2ZW50VHlwZSlyZXR1cm4gdGhpcy5jb25zdW1lRm9yTG9jYWxXb3JrZXIoZSksITB9Y29uc3VtZUZvckxvY2FsV29ya2VyKGUpe3ZhciB4LGY7Y29uc3R7d29ya0lkOnQsdXBkYXRlTm9kZU9wdDpyLHdpbGxSZWZyZXNoU2VsZWN0b3I6aSx3aWxsU3luY1NlcnZpY2U6aCx3aWxsUmVmcmVzaDpnLHNlbGVjdFN0b3JlOnUsd2lsbFNlcmlhbGl6ZURhdGE6YSxlbWl0RXZlbnRUeXBlOmN9PWU7dD09PXZ0LnNlbGVjdG9ySWQmJnI/KHg9dGhpcy5sb2NhbFdvcmspPT1udWxsfHx4LnVwZGF0ZVNlbGVjdG9yKHt1cGRhdGVTZWxlY3Rvck9wdDpyLHdpbGxSZWZyZXNoU2VsZWN0b3I6aSx3aWxsU3luY1NlcnZpY2U6aCxzZWxlY3RTdG9yZTp1LHdpbGxTZXJpYWxpemVEYXRhOmEsZW1pdEV2ZW50VHlwZTpjfSk6dCYmciYmKChmPXRoaXMubG9jYWxXb3JrKT09bnVsbHx8Zi51cGRhdGVOb2RlKHt3b3JrSWQ6dCx1cGRhdGVOb2RlT3B0OnIsd2lsbFJlZnJlc2g6Zyx3aWxsU3luY1NlcnZpY2U6aH0pKX19Y2xhc3MgUWV7Y29uc3RydWN0b3IoZSl7T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImJ1aWxkZXJzIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6bmV3IE1hcH0pLHRoaXMuYnVpbGRlcnM9bmV3IE1hcChlLm1hcCh0PT5bdCx0aGlzLmJ1aWxkKHQpXSkpfWJ1aWxkKGUpe3N3aXRjaChlKXtjYXNlIFJ0LlRyYW5zbGF0ZU5vZGU6cmV0dXJuIG5ldyBZZTtjYXNlIFJ0LlpJbmRleE5vZGU6cmV0dXJuIG5ldyBWZTtjYXNlIFJ0LlpJbmRleEFjdGl2ZTpyZXR1cm4gbmV3ICRlO2Nhc2UgUnQuQ29weU5vZGU6cmV0dXJuIG5ldyBLZTtjYXNlIFJ0LlNldENvbG9yTm9kZTpyZXR1cm4gbmV3IEhlO2Nhc2UgUnQuRGVsZXRlTm9kZTpyZXR1cm4gbmV3IFhlO2Nhc2UgUnQuU2NhbGVOb2RlOnJldHVybiBuZXcgWmU7Y2FzZSBSdC5Sb3RhdGVOb2RlOnJldHVybiBuZXcgSmV9fXJlZ2lzdGVyRm9yV29ya2VyKGUsdCl7cmV0dXJuIHRoaXMuYnVpbGRlcnMuZm9yRWFjaChyPT57ciYmci5yZWdpc3RlckZvcldvcmtlcihlLHQpfSksdGhpc31jb25zdW1lRm9yV29ya2VyKGUpe2Zvcihjb25zdCB0IG9mIHRoaXMuYnVpbGRlcnMudmFsdWVzKCkpaWYodCE9bnVsbCYmdC5jb25zdW1lKGUpKXJldHVybiEwO3JldHVybiExfX1jb25zdCBrdD1jbGFzcyBrdCBleHRlbmRzIFVle2NvbnN0cnVjdG9yKCl7c3VwZXIoKTtIdCh0aGlzLCJjYW1lcmFPcHQiKTtIdCh0aGlzLCJkcHIiKTtIdCh0aGlzLCJzY2VuZSIpO0h0KHRoaXMsImRyYXdMYXllciIpO0h0KHRoaXMsImZ1bGxMYXllciIpO0h0KHRoaXMsImxvY2FsV29yayIpO0h0KHRoaXMsInNlcnZpY2VXb3JrIik7SHQodGhpcywibWV0aG9kQnVpbGRlciIpO3RoaXMucmVnaXN0ZXIoKX1pbml0KHQscixpKXt0aGlzLmRwcj10LHRoaXMuc2NlbmU9dGhpcy5jcmVhdGVTY2VuZShyKSx0aGlzLmRyYXdMYXllcj10aGlzLmNyZWF0ZUxheWVyKHsuLi5pLHdpZHRoOnIud2lkdGgsaGVpZ2h0OnIuaGVpZ2h0fSksdGhpcy5mdWxsTGF5ZXI9dGhpcy5jcmVhdGVMYXllcih7Li4uaSx3aWR0aDpyLndpZHRoLGhlaWdodDpyLmhlaWdodCxidWZmZXJTaXplOjVlM30pLHRoaXMubG9jYWxXb3JrPW5ldyB3ZSh0aGlzLmN1ck5vZGVNYXAsdGhpcy5mdWxsTGF5ZXIsdGhpcy5kcmF3TGF5ZXIsdGhpcy5wb3N0LmJpbmQodGhpcykpLHRoaXMuc2VydmljZVdvcms9bmV3IEdlKHRoaXMuY3VyTm9kZU1hcCx0aGlzLmZ1bGxMYXllcix0aGlzLmRyYXdMYXllcix0aGlzLnBvc3QuYmluZCh0aGlzKSksdGhpcy5tZXRob2RCdWlsZGVyPW5ldyBRZShbUnQuQ29weU5vZGUsUnQuU2V0Q29sb3JOb2RlLFJ0LkRlbGV0ZU5vZGUsUnQuUm90YXRlTm9kZSxSdC5TY2FsZU5vZGUsUnQuVHJhbnNsYXRlTm9kZSxSdC5aSW5kZXhBY3RpdmUsUnQuWkluZGV4Tm9kZV0pLnJlZ2lzdGVyRm9yV29ya2VyKHRoaXMubG9jYWxXb3JrLHRoaXMuc2VydmljZVdvcmspfWdldE9mZnNjcmVlbih0KXtyZXR1cm4odD90aGlzLmZ1bGxMYXllci5wYXJlbnQ6dGhpcy5kcmF3TGF5ZXIucGFyZW50KS5jYW52YXN9cmVnaXN0ZXIoKXt0aGlzLm9uKHQ9Pnt2YXIgcjtmb3IoY29uc3QgaSBvZiB0KXtjb25zdHt3b3JrU3RhdGU6aCxkYXRhVHlwZTpnLG1zZ1R5cGU6dSx3b3JrSWQ6YSx0b29sc1R5cGU6YyxvcHQ6eH09aTtpZighKChyPXRoaXMubWV0aG9kQnVpbGRlcikhPW51bGwmJnIuY29uc3VtZUZvcldvcmtlcihpKSkpc3dpdGNoKHUpe2Nhc2UgcHQuVXBkYXRlVG9vbHM6YyYmeCYmdGhpcy5zZXRUb29sc09wdCh7dG9vbHNUeXBlOmMsdG9vbHNPcHQ6eH0pO2JyZWFrO2Nhc2UgcHQuQ3JlYXRlV29yazphJiZ4JiYoIXRoaXMubG9jYWxXb3JrLmdldFRtcFdvcmtTaGFwZU5vZGUoKSYmYyYmdGhpcy5zZXRUb29sc09wdCh7dG9vbHNUeXBlOmMsdG9vbHNPcHQ6eH0pLHRoaXMuc2V0V29ya09wdCh7d29ya0lkOmEsdG9vbHNPcHQ6eH0pKTticmVhaztjYXNlIHB0LlNlbGVjdDpnPT09QXQuU2VydmljZSYmKHRoaXMubG9jYWxXb3JrLnJ1blJldmVyc2VTZWxlY3RXb3JrKGkpLHRoaXMuc2VydmljZVdvcmsucnVuU2VsZWN0V29yayhpKSk7YnJlYWs7Y2FzZSBwdC5SZW1vdmVOb2RlOnRoaXMucmVtb3ZlTm9kZShpKTticmVhaztjYXNlIHB0LlVwZGF0ZU5vZGU6dGhpcy51cGRhdGVOb2RlKGkpO2JyZWFrO2Nhc2UgcHQuRnVsbFdvcms6dGhpcy5jb25zdW1lRnVsbChnLGkpO2JyZWFrO2Nhc2UgcHQuRHJhd1dvcms6aD09PXd0LkRvbmUmJmc9PT1BdC5Mb2NhbD90aGlzLmNvbnN1bWVEcmF3QWxsKGcsaSk6dGhpcy5jb25zdW1lRHJhdyhnLGkpO2JyZWFrfX19KX11cGRhdGVOb2RlKHQpe2NvbnN0e2RhdGFUeXBlOnJ9PXQ7cj09PUF0LlNlcnZpY2UmJnRoaXMuc2VydmljZVdvcmsuY29uc3VtZUZ1bGwodCl9c2V0VG9vbHNPcHQodCl7dGhpcy5sb2NhbFdvcmsuc2V0VG9vbHNPcHQodCl9c2V0V29ya09wdCh0KXtjb25zdHt3b3JrSWQ6cix0b29sc09wdDppfT10O3ImJmkmJnRoaXMubG9jYWxXb3JrLnNldFdvcmtPcHRpb25zKHIsaSl9Y2xlYXJBbGwoKXtjb25zdCB0PVtdO3RoaXMubG9jYWxXb3JrLmNsZWFyQWxsV29ya1NoYXBlc0NhY2hlKCksdGhpcy5zZXJ2aWNlV29yay5jbGVhckFsbFdvcmtTaGFwZXNDYWNoZSgpLHRoaXMuZnVsbExheWVyLnBhcmVudC5jaGlsZHJlbi5mb3JFYWNoKHI9PntyLm5hbWUhPT0idmlld3BvcnQiJiZ0LnB1c2gocil9KSx0aGlzLmRyYXdMYXllci5wYXJlbnQuY2hpbGRyZW4uZm9yRWFjaChyPT57ci5uYW1lIT09InZpZXdwb3J0IiYmdC5wdXNoKHIpfSksdC5mb3JFYWNoKHI9PntyLnJlbW92ZSgpfSksdGhpcy5mdWxsTGF5ZXIucmVtb3ZlQWxsQ2hpbGRyZW4oKSx0aGlzLmRyYXdMYXllci5yZW1vdmVBbGxDaGlsZHJlbigpLHRoaXMubG9jYWxXb3JrLnJ1bkVmZmVjdFdvcmsoKX1zZXRDYW1lcmFPcHQodCl7dGhpcy5jYW1lcmFPcHQ9dDtjb25zdHtzY2FsZTpyLGNlbnRlclg6aSxjZW50ZXJZOmgsd2lkdGg6ZyxoZWlnaHQ6dX09dDsoZyE9PXRoaXMuc2NlbmUud2lkdGh8fHUhPT10aGlzLnNjZW5lLmhlaWdodCkmJnRoaXMudXBkYXRlU2NlbmUoe3dpZHRoOmcsaGVpZ2h0OnV9KSx0aGlzLmZ1bGxMYXllci5zZXRBdHRyaWJ1dGUoInNjYWxlIixbcixyXSksdGhpcy5mdWxsTGF5ZXIuc2V0QXR0cmlidXRlKCJ0cmFuc2xhdGUiLFstaSwtaF0pLHRoaXMuZHJhd0xheWVyLnNldEF0dHJpYnV0ZSgic2NhbGUiLFtyLHJdKSx0aGlzLmRyYXdMYXllci5zZXRBdHRyaWJ1dGUoInRyYW5zbGF0ZSIsWy1pLC1oXSksdGhpcy5sb2NhbFdvcmsucnVuRWZmZWN0V29yaygoKT0+e2lmKHRoaXMuc2VydmljZVdvcmsuc2VsZWN0b3JXb3JrU2hhcGVzLnNpemUpZm9yKGNvbnN0W2EsY11vZiB0aGlzLnNlcnZpY2VXb3JrLnNlbGVjdG9yV29ya1NoYXBlcy5lbnRyaWVzKCkpdGhpcy5zZXJ2aWNlV29yay5ydW5TZWxlY3RXb3JrKHt3b3JrSWQ6YSxzZWxlY3RJZHM6Yy5zZWxlY3RJZHMsbXNnVHlwZTpwdC5TZWxlY3QsZGF0YVR5cGU6QXQuU2VydmljZX0pfSl9Z2V0UmVjdEltYWdlQml0bWFwKHQscil7Y29uc3QgaT10LngqdGhpcy5kcHIsaD10LnkqdGhpcy5kcHIsZz10LncqdGhpcy5kcHIsdT10LmgqdGhpcy5kcHI7cmV0dXJuIGNyZWF0ZUltYWdlQml0bWFwKHRoaXMuZ2V0T2Zmc2NyZWVuKHIpLGksaCxnLHUse3Jlc2l6ZVF1YWxpdHk6ImxvdyJ9KX1wb3N0KHQpe3ZhciBpO2NvbnN0IHI9dC5yZW5kZXI7aWYociYmKCgoaT1yLmlzRnVsbFdvcms/dGhpcy5mdWxsTGF5ZXI6dGhpcy5kcmF3TGF5ZXIpPT1udWxsP3ZvaWQgMDppLnBhcmVudCkucmVuZGVyKCksci5yZWN0JiZyLmRyYXdDYW52YXMpKXt0aGlzLmdldFJlY3RJbWFnZUJpdG1hcChyLnJlY3QsISFyLmlzRnVsbFdvcmspLnRoZW4oaD0+e3IuaW1hZ2VCaXRtYXA9aCx0LnJlbmRlcj1yLGt0Ll9zZWxmLnBvc3RNZXNzYWdlKHQsW2hdKSxoLmNsb3NlKCl9KTtyZXR1cm59a3QuX3NlbGYucG9zdE1lc3NhZ2UodCl9b24odCl7b25tZXNzYWdlPXI9PntpZihyLmRhdGEpe2NvbnN0IGk9ci5kYXRhLmdldCgiSW5pdCIpO2lmKGkpe2NvbnN0e2RwcjphLG9mZnNjcmVlbkNhbnZhc09wdDpjLGxheWVyT3B0Onh9PWk7YyYmeCYmYSYmdGhpcy5pbml0KGEsYyx4KX10KHIuZGF0YS52YWx1ZXMoKSk7Y29uc3QgaD1yLmRhdGEuaGFzKCJDbGVhckFsbCIpLGc9ci5kYXRhLmdldCgiVXBkYXRlQ2FtZXJhIiksdT0hIShofHxnKTtpZihnKXtjb25zdHtjYW1lcmFPcHQ6YX09ZzthJiZ0aGlzLnNldENhbWVyYU9wdChhKX0haCYmdSYmdGhpcy5wb3N0KHtyZW5kZXI6e3JlY3Q6e3g6MCx5OjAsdzp0aGlzLnNjZW5lLndpZHRoLGg6dGhpcy5zY2VuZS5oZWlnaHR9LGRyYXdDYW52YXM6eXQuQmcsY2xlYXJDYW52YXM6eXQuQmcsaXNDbGVhcjohMCxpc0Z1bGxXb3JrOiEwfX0pLGgmJnRoaXMuY2xlYXJBbGwoKX19fWNvbnN1bWVEcmF3KHQscil7dD09PUF0LkxvY2FsJiZ0aGlzLmxvY2FsV29yay5jb25zdW1lRHJhdyhyLHRoaXMuc2VydmljZVdvcmspLHQ9PT1BdC5TZXJ2aWNlJiZ0aGlzLnNlcnZpY2VXb3JrLmNvbnN1bWVEcmF3KHIpfWNvbnN1bWVEcmF3QWxsKHQscil7dD09PUF0LkxvY2FsJiZ0aGlzLmxvY2FsV29yay5jb25zdW1lRHJhd0FsbChyLHRoaXMuc2VydmljZVdvcmspfWNvbnN1bWVGdWxsKHQscil7dD09PUF0LlNlcnZpY2UmJnRoaXMuc2VydmljZVdvcmsuY29uc3VtZUZ1bGwociksdD09PUF0LkxvY2FsJiZ0aGlzLmxvY2FsV29yay5jb25zdW1lRnVsbChyKX1yZW1vdmVOb2RlKHQpe2NvbnN0e2RhdGFUeXBlOnJ9PXQ7cj09PUF0LlNlcnZpY2UmJnRoaXMuc2VydmljZVdvcmsucmVtb3ZlV29yayh0KSxyPT09QXQuTG9jYWwmJnRoaXMubG9jYWxXb3JrLnJlbW92ZVdvcmsodCl9fTtIdChrdCwiX3NlbGYiLHNlbGYpO2xldCBjZT1rdDtuZXcgY2V9KSgpOwo=", ud = typeof window < "u" && window.Blob && new Blob([atob(Zs)], { type: "text/javascript;charset=utf-8" });
function lt(Z) {
  let l;
  try {
    if (l = ud && (window.URL || window.webkitURL).createObjectURL(ud), !l)
      throw "";
    const i = new Worker(l, {
      name: Z == null ? void 0 : Z.name
    });
    return i.addEventListener("error", () => {
      (window.URL || window.webkitURL).revokeObjectURL(l);
    }), i;
  } catch {
    return new Worker(
      "data:application/javascript;base64," + Zs,
      {
        name: Z == null ? void 0 : Z.name
      }
    );
  } finally {
    l && (window.URL || window.webkitURL).revokeObjectURL(l);
  }
}
const ms = "dmFyIFVlPU9iamVjdC5kZWZpbmVQcm9wZXJ0eTt2YXIgRmU9KFN0LHp0LEN0KT0+enQgaW4gU3Q/VWUoU3QsenQse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOkN0fSk6U3RbenRdPUN0O3ZhciBLdD0oU3QsenQsQ3QpPT4oRmUoU3QsdHlwZW9mIHp0IT0ic3ltYm9sIj96dCsiIjp6dCxDdCksQ3QpOyhmdW5jdGlvbigpeyJ1c2Ugc3RyaWN0Ijt2YXIgU3Q7KGZ1bmN0aW9uKFIpe1JbUi5QZW5jaWw9MV09IlBlbmNpbCIsUltSLkVyYXNlcj0yXT0iRXJhc2VyIixSW1IuU2VsZWN0b3I9M109IlNlbGVjdG9yIixSW1IuQ2xpY2tlcj00XT0iQ2xpY2tlciIsUltSLkFycm93PTVdPSJBcnJvdyIsUltSLkhhbmQ9Nl09IkhhbmQiLFJbUi5MYXNlclBlbj03XT0iTGFzZXJQZW4ifSkoU3R8fChTdD17fSkpO3ZhciB6dDsoZnVuY3Rpb24oUil7UltSLlBhdGg9MF09IlBhdGgiLFJbUi5SZWN0PTFdPSJSZWN0In0pKHp0fHwoenQ9e30pKTt2YXIgQ3Q7KGZ1bmN0aW9uKFIpe1JbUi5Mb2NhbD0xXT0iTG9jYWwiLFJbUi5TZXJ2aWNlPTJdPSJTZXJ2aWNlIn0pKEN0fHwoQ3Q9e30pKTt2YXIgd3Q7KGZ1bmN0aW9uKFIpe1JbUi5QZW5kaW5nPTBdPSJQZW5kaW5nIixSW1IuU3RhcnQ9MV09IlN0YXJ0IixSW1IuRG9pbmc9Ml09IkRvaW5nIixSW1IuRG9uZT0zXT0iRG9uZSIsUltSLkZyZWV6ZT00XT0iRnJlZXplIixSW1IuVW53cml0YWJsZT01XT0iVW53cml0YWJsZSJ9KSh3dHx8KHd0PXt9KSk7dmFyIFR0OyhmdW5jdGlvbihSKXtSW1IuSW5pdD0wXT0iSW5pdCIsUltSLlVwZGF0ZUNhbWVyYT0xXT0iVXBkYXRlQ2FtZXJhIixSW1IuVXBkYXRlVG9vbHM9Ml09IlVwZGF0ZVRvb2xzIixSW1IuVXBkYXRlU2NlbmU9M109IlVwZGF0ZVNjZW5lIixSW1IuQ3JlYXRlV29yaz00XT0iQ3JlYXRlV29yayIsUltSLkRyYXdXb3JrPTVdPSJEcmF3V29yayIsUltSLkZ1bGxXb3JrPTZdPSJGdWxsV29yayIsUltSLlVwZGF0ZVdvcms9N109IlVwZGF0ZVdvcmsiLFJbUi5VcGRhdGVOb2RlPThdPSJVcGRhdGVOb2RlIixSW1IuUmVtb3ZlTm9kZT05XT0iUmVtb3ZlTm9kZSIsUltSLkNsZWFyPTEwXT0iQ2xlYXIiLFJbUi5TZWxlY3Q9MTFdPSJTZWxlY3QiLFJbUi5EZXN0cm95PTEyXT0iRGVzdHJveSIsUltSLk5vbmU9MTNdPSJOb25lIixSW1IuQ29tYmluZURyYXc9MTRdPSJDb21iaW5lRHJhdyJ9KShUdHx8KFR0PXt9KSk7dmFyIGFlOyhmdW5jdGlvbihSKXtSW1IuUGF0aD0wXT0iUGF0aCIsUltSLlJlY3Q9MV09IlJlY3QiLFJbUi5UZXh0dXJlPTJdPSJUZXh0dXJlIn0pKGFlfHwoYWU9e30pKTt2YXIgbGU7KGZ1bmN0aW9uKFIpe1IuV2ViZ2wyPSJ3ZWJnbDIiLFIuV2ViZ2w9IndlYmdsIixSLkNhbnZhczJkPSIyZCJ9KShsZXx8KGxlPXt9KSk7dmFyIEh0OyhmdW5jdGlvbihSKXtSW1IuRmxvYXQ9MV09IkZsb2F0IixSW1IuQmc9Ml09IkJnIixSW1IuU2VsZWN0b3I9M109IlNlbGVjdG9yIn0pKEh0fHwoSHQ9e30pKTt2YXIgZmU7KGZ1bmN0aW9uKFIpe1IuTFQ9InRvcExlZnQiLFIuTEM9ImxlZnQiLFIuTEI9ImJvdHRvbUxlZnQiLFIuVEM9InRvcCIsUi5SVD0idG9wUmlnaHQiLFIuUkM9InJpZ2h0IixSLlJCPSJib3R0b21SaWdodCIsUi5CQz0iYm90dG9tIn0pKGZlfHwoZmU9e30pKTtjbGFzcyBrdHtjb25zdHJ1Y3RvcihlLHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzeW5jVW5pdFRpbWUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZToxZTN9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiZHJhd0xheWVyIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImZ1bGxMYXllciIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ3b3JrSWQiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSx0aGlzLmZ1bGxMYXllcj1lLHRoaXMuZHJhd0xheWVyPXR9c2V0V29ya0lkKGUpe3RoaXMud29ya0lkPWV9Z2V0V29ya0lkKCl7cmV0dXJuIHRoaXMud29ya0lkfWdldFdvcmtPcHRpb25zKCl7cmV0dXJuIHRoaXMud29ya09wdGlvbnN9c2V0V29ya09wdGlvbnMoZSl7dGhpcy53b3JrT3B0aW9ucz1lLHRoaXMuc3luY1VuaXRUaW1lPWUuc3luY1VuaXRUaW1lfHx0aGlzLnN5bmNVbml0VGltZX19dmFyIFB0PWZ1bmN0aW9uKFIpe3ZhciBlPXt9O2Z1bmN0aW9uIHQoaSl7aWYoZVtpXSlyZXR1cm4gZVtpXS5leHBvcnRzO3ZhciBvPWVbaV09e2ksbDohMSxleHBvcnRzOnt9fTtyZXR1cm4gUltpXS5jYWxsKG8uZXhwb3J0cyxvLG8uZXhwb3J0cyx0KSxvLmw9ITAsby5leHBvcnRzfXJldHVybiB0Lm09Uix0LmM9ZSx0LmQ9ZnVuY3Rpb24oaSxvLGcpe3QubyhpLG8pfHxPYmplY3QuZGVmaW5lUHJvcGVydHkoaSxvLHtlbnVtZXJhYmxlOiEwLGdldDpnfSl9LHQucj1mdW5jdGlvbihpKXt0eXBlb2YgU3ltYm9sPCJ1IiYmU3ltYm9sLnRvU3RyaW5nVGFnJiZPYmplY3QuZGVmaW5lUHJvcGVydHkoaSxTeW1ib2wudG9TdHJpbmdUYWcse3ZhbHVlOiJNb2R1bGUifSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGksIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pfSx0LnQ9ZnVuY3Rpb24oaSxvKXtpZihvJjEmJihpPXQoaSkpLG8mOHx8byY0JiZ0eXBlb2YgaT09Im9iamVjdCImJmkmJmkuX19lc01vZHVsZSlyZXR1cm4gaTt2YXIgZz1PYmplY3QuY3JlYXRlKG51bGwpO2lmKHQucihnKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZywiZGVmYXVsdCIse2VudW1lcmFibGU6ITAsdmFsdWU6aX0pLG8mMiYmdHlwZW9mIGkhPSJzdHJpbmciKWZvcih2YXIgdiBpbiBpKXQuZChnLHYsKGZ1bmN0aW9uKGMpe3JldHVybiBpW2NdfSkuYmluZChudWxsLHYpKTtyZXR1cm4gZ30sdC5uPWZ1bmN0aW9uKGkpe3ZhciBvPWkmJmkuX19lc01vZHVsZT9mdW5jdGlvbigpe3JldHVybiBpLmRlZmF1bHR9OmZ1bmN0aW9uKCl7cmV0dXJuIGl9O3JldHVybiB0LmQobywiYSIsbyksb30sdC5vPWZ1bmN0aW9uKGksbyl7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChpLG8pfSx0LnA9Ii9qcy8iLHQodC5zPTApfShbZnVuY3Rpb24oUixlLHQpe3QucihlKSx0LmQoZSwidmVyc2lvbiIsZnVuY3Rpb24oKXtyZXR1cm4gd30pLHQuZChlLCJoZWxwZXJzIixmdW5jdGlvbigpe3JldHVybiBqfSksdC5kKGUsImNyZWF0ZUVsZW1lbnQiLGZ1bmN0aW9uKCl7cmV0dXJuIEx9KSx0LmQoZSwiaXNTcHJpdGVOb2RlIixmdW5jdGlvbigpe3JldHVybiBTfSksdC5kKGUsInJlZ2lzdGVyTm9kZSIsZnVuY3Rpb24oKXtyZXR1cm4gVH0pO3ZhciBpPXQoMTIpO3QuZChlLCJFTlYiLGZ1bmN0aW9uKCl7cmV0dXJuIGkuRU5WfSk7dmFyIG89dCg2OCk7dC5kKGUsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsZnVuY3Rpb24oKXtyZXR1cm4gby5yZXF1ZXN0QW5pbWF0aW9uRnJhbWV9KSx0LmQoZSwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLGZ1bmN0aW9uKCl7cmV0dXJuIG8uY2FuY2VsQW5pbWF0aW9uRnJhbWV9KTt2YXIgZz10KDcwKTt0LmQoZSwiTm9kZSIsZnVuY3Rpb24oKXtyZXR1cm4gZy5kZWZhdWx0fSk7dmFyIHY9dCgyMTcpO3QuZChlLCJDbG91ZCIsZnVuY3Rpb24oKXtyZXR1cm4gdi5kZWZhdWx0fSk7dmFyIGM9dCgyMTkpO3QuZChlLCJCbG9jayIsZnVuY3Rpb24oKXtyZXR1cm4gYy5kZWZhdWx0fSk7dmFyIGY9dCgyMjQpO3QuZChlLCJTcHJpdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIGYuZGVmYXVsdH0pO3ZhciBoPXQoMjI2KTt0LmQoZSwiUGF0aCIsZnVuY3Rpb24oKXtyZXR1cm4gaC5kZWZhdWx0fSk7dmFyIEU9dCgyMjkpO3QuZChlLCJSZWN0IixmdW5jdGlvbigpe3JldHVybiBFLmRlZmF1bHR9KTt2YXIgbD10KDIzMSk7dC5kKGUsIlRyaWFuZ2xlIixmdW5jdGlvbigpe3JldHVybiBsLmRlZmF1bHR9KTt2YXIgbT10KDIzNik7dC5kKGUsIlBhcmFsbGVsIixmdW5jdGlvbigpe3JldHVybiBtLmRlZmF1bHR9KTt2YXIgcD10KDIzOCk7dC5kKGUsIlJlZ3VsYXIiLGZ1bmN0aW9uKCl7cmV0dXJuIHAuZGVmYXVsdH0pO3ZhciBDPXQoMjQwKTt0LmQoZSwiU3RhciIsZnVuY3Rpb24oKXtyZXR1cm4gQy5kZWZhdWx0fSk7dmFyIHg9dCgyNDIpO3QuZChlLCJFbGxpcHNlIixmdW5jdGlvbigpe3JldHVybiB4LmRlZmF1bHR9KTt2YXIgZD10KDI0NCk7dC5kKGUsIkFyYyIsZnVuY3Rpb24oKXtyZXR1cm4gZC5kZWZhdWx0fSk7dmFyIHk9dCgyNDYpO3QuZChlLCJSaW5nIixmdW5jdGlvbigpe3JldHVybiB5LmRlZmF1bHR9KTt2YXIgcj10KDIzMik7dC5kKGUsIlBvbHlsaW5lIixmdW5jdGlvbigpe3JldHVybiByLmRlZmF1bHR9KTt2YXIgcz10KDI0OCk7dC5kKGUsIkxhYmVsIixmdW5jdGlvbigpe3JldHVybiBzLmRlZmF1bHR9KTt2YXIgbj10KDI1MCk7dC5kKGUsIkdyb3VwIixmdW5jdGlvbigpe3JldHVybiBuLmRlZmF1bHR9KTt2YXIgYT10KDI4Nik7dC5kKGUsIkxheWVyIixmdW5jdGlvbigpe3JldHVybiBhLmRlZmF1bHR9KTt2YXIgTz10KDI4Nyk7dC5kKGUsIlNwcml0ZVN2ZyIsZnVuY3Rpb24oKXtyZXR1cm4gTy5kZWZhdWx0fSk7dmFyIEE9dCgyODkpO3QuZChlLCJMYXllcldvcmtlciIsZnVuY3Rpb24oKXtyZXR1cm4gQS5kZWZhdWx0fSk7dmFyIGI9dCgyOTApO3QuZChlLCJTY2VuZSIsZnVuY3Rpb24oKXtyZXR1cm4gYi5kZWZhdWx0fSk7dmFyIEk9dCgyMTMpLFA9dCgyMjEpO3QuZChlLCJDb2xvciIsZnVuY3Rpb24oKXtyZXR1cm4gUC5Db2xvcn0pLHQuZChlLCJHcmFkaWVudCIsZnVuY3Rpb24oKXtyZXR1cm4gUC5HcmFkaWVudH0pO3ZhciBEPXQoNzIpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCBMPUkuZGVmYXVsdC5jcmVhdGVFbGVtZW50LFM9SS5kZWZhdWx0LmlzU3ByaXRlTm9kZSxUPUkuZGVmYXVsdC5yZWdpc3Rlck5vZGUsaj17cGFyc2VDb2xvcjpQLnBhcnNlQ29sb3Isc2l6ZVRvUGl4ZWw6RC5zaXplVG9QaXhlbCx0b0FycmF5OkQudG9BcnJheSx0b1N0cmluZzpELnRvU3RyaW5nLHRvTnVtYmVyOkQudG9OdW1iZXJ9O2xldCAkOyQ9IjMuOC4zIjtjb25zdCB3PSR9LGZ1bmN0aW9uKFIsZSx0KXt0LnIoZSk7dmFyIGk9dCgyKTt0LmQoZSwiZ2xNYXRyaXgiLGZ1bmN0aW9uKCl7cmV0dXJuIGl9KTt2YXIgbz10KDMpO3QuZChlLCJtYXQyIixmdW5jdGlvbigpe3JldHVybiBvfSk7dmFyIGc9dCg0KTt0LmQoZSwibWF0MmQiLGZ1bmN0aW9uKCl7cmV0dXJuIGd9KTt2YXIgdj10KDUpO3QuZChlLCJtYXQzIixmdW5jdGlvbigpe3JldHVybiB2fSk7dmFyIGM9dCg2KTt0LmQoZSwibWF0NCIsZnVuY3Rpb24oKXtyZXR1cm4gY30pO3ZhciBmPXQoNyk7dC5kKGUsInF1YXQiLGZ1bmN0aW9uKCl7cmV0dXJuIGZ9KTt2YXIgaD10KDEwKTt0LmQoZSwicXVhdDIiLGZ1bmN0aW9uKCl7cmV0dXJuIGh9KTt2YXIgRT10KDExKTt0LmQoZSwidmVjMiIsZnVuY3Rpb24oKXtyZXR1cm4gRX0pO3ZhciBsPXQoOCk7dC5kKGUsInZlYzMiLGZ1bmN0aW9uKCl7cmV0dXJuIGx9KTt2YXIgbT10KDkpO3QuZChlLCJ2ZWM0IixmdW5jdGlvbigpe3JldHVybiBtfSl9LGZ1bmN0aW9uKFIsZSx0KXt0LnIoZSksdC5kKGUsIkVQU0lMT04iLGZ1bmN0aW9uKCl7cmV0dXJuIGl9KSx0LmQoZSwiQVJSQVlfVFlQRSIsZnVuY3Rpb24oKXtyZXR1cm4gb30pLHQuZChlLCJSQU5ET00iLGZ1bmN0aW9uKCl7cmV0dXJuIGd9KSx0LmQoZSwic2V0TWF0cml4QXJyYXlUeXBlIixmdW5jdGlvbigpe3JldHVybiB2fSksdC5kKGUsInRvUmFkaWFuIixmdW5jdGlvbigpe3JldHVybiBmfSksdC5kKGUsImVxdWFscyIsZnVuY3Rpb24oKXtyZXR1cm4gaH0pO3ZhciBpPTFlLTYsbz10eXBlb2YgRmxvYXQzMkFycmF5PCJ1Ij9GbG9hdDMyQXJyYXk6QXJyYXksZz1NYXRoLnJhbmRvbTtmdW5jdGlvbiB2KEUpe289RX12YXIgYz1NYXRoLlBJLzE4MDtmdW5jdGlvbiBmKEUpe3JldHVybiBFKmN9ZnVuY3Rpb24gaChFLGwpe3JldHVybiBNYXRoLmFicyhFLWwpPD1pKk1hdGgubWF4KDEsTWF0aC5hYnMoRSksTWF0aC5hYnMobCkpfU1hdGguaHlwb3R8fChNYXRoLmh5cG90PWZ1bmN0aW9uKCl7Zm9yKHZhciBFPTAsbD1hcmd1bWVudHMubGVuZ3RoO2wtLTspRSs9YXJndW1lbnRzW2xdKmFyZ3VtZW50c1tsXTtyZXR1cm4gTWF0aC5zcXJ0KEUpfSl9LGZ1bmN0aW9uKFIsZSx0KXt0LnIoZSksdC5kKGUsImNyZWF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gb30pLHQuZChlLCJjbG9uZSIsZnVuY3Rpb24oKXtyZXR1cm4gZ30pLHQuZChlLCJjb3B5IixmdW5jdGlvbigpe3JldHVybiB2fSksdC5kKGUsImlkZW50aXR5IixmdW5jdGlvbigpe3JldHVybiBjfSksdC5kKGUsImZyb21WYWx1ZXMiLGZ1bmN0aW9uKCl7cmV0dXJuIGZ9KSx0LmQoZSwic2V0IixmdW5jdGlvbigpe3JldHVybiBofSksdC5kKGUsInRyYW5zcG9zZSIsZnVuY3Rpb24oKXtyZXR1cm4gRX0pLHQuZChlLCJpbnZlcnQiLGZ1bmN0aW9uKCl7cmV0dXJuIGx9KSx0LmQoZSwiYWRqb2ludCIsZnVuY3Rpb24oKXtyZXR1cm4gbX0pLHQuZChlLCJkZXRlcm1pbmFudCIsZnVuY3Rpb24oKXtyZXR1cm4gcH0pLHQuZChlLCJtdWx0aXBseSIsZnVuY3Rpb24oKXtyZXR1cm4gQ30pLHQuZChlLCJyb3RhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIHh9KSx0LmQoZSwic2NhbGUiLGZ1bmN0aW9uKCl7cmV0dXJuIGR9KSx0LmQoZSwiZnJvbVJvdGF0aW9uIixmdW5jdGlvbigpe3JldHVybiB5fSksdC5kKGUsImZyb21TY2FsaW5nIixmdW5jdGlvbigpe3JldHVybiByfSksdC5kKGUsInN0ciIsZnVuY3Rpb24oKXtyZXR1cm4gc30pLHQuZChlLCJmcm9iIixmdW5jdGlvbigpe3JldHVybiBufSksdC5kKGUsIkxEVSIsZnVuY3Rpb24oKXtyZXR1cm4gYX0pLHQuZChlLCJhZGQiLGZ1bmN0aW9uKCl7cmV0dXJuIE99KSx0LmQoZSwic3VidHJhY3QiLGZ1bmN0aW9uKCl7cmV0dXJuIEF9KSx0LmQoZSwiZXhhY3RFcXVhbHMiLGZ1bmN0aW9uKCl7cmV0dXJuIGJ9KSx0LmQoZSwiZXF1YWxzIixmdW5jdGlvbigpe3JldHVybiBJfSksdC5kKGUsIm11bHRpcGx5U2NhbGFyIixmdW5jdGlvbigpe3JldHVybiBQfSksdC5kKGUsIm11bHRpcGx5U2NhbGFyQW5kQWRkIixmdW5jdGlvbigpe3JldHVybiBEfSksdC5kKGUsIm11bCIsZnVuY3Rpb24oKXtyZXR1cm4gTH0pLHQuZChlLCJzdWIiLGZ1bmN0aW9uKCl7cmV0dXJuIFN9KTt2YXIgaT10KDIpO2Z1bmN0aW9uIG8oKXt2YXIgVD1uZXcgaS5BUlJBWV9UWVBFKDQpO3JldHVybiBpLkFSUkFZX1RZUEUhPUZsb2F0MzJBcnJheSYmKFRbMV09MCxUWzJdPTApLFRbMF09MSxUWzNdPTEsVH1mdW5jdGlvbiBnKFQpe3ZhciBqPW5ldyBpLkFSUkFZX1RZUEUoNCk7cmV0dXJuIGpbMF09VFswXSxqWzFdPVRbMV0salsyXT1UWzJdLGpbM109VFszXSxqfWZ1bmN0aW9uIHYoVCxqKXtyZXR1cm4gVFswXT1qWzBdLFRbMV09alsxXSxUWzJdPWpbMl0sVFszXT1qWzNdLFR9ZnVuY3Rpb24gYyhUKXtyZXR1cm4gVFswXT0xLFRbMV09MCxUWzJdPTAsVFszXT0xLFR9ZnVuY3Rpb24gZihULGosJCx3KXt2YXIgSj1uZXcgaS5BUlJBWV9UWVBFKDQpO3JldHVybiBKWzBdPVQsSlsxXT1qLEpbMl09JCxKWzNdPXcsSn1mdW5jdGlvbiBoKFQsaiwkLHcsSil7cmV0dXJuIFRbMF09aixUWzFdPSQsVFsyXT13LFRbM109SixUfWZ1bmN0aW9uIEUoVCxqKXtpZihUPT09ail7dmFyICQ9alsxXTtUWzFdPWpbMl0sVFsyXT0kfWVsc2UgVFswXT1qWzBdLFRbMV09alsyXSxUWzJdPWpbMV0sVFszXT1qWzNdO3JldHVybiBUfWZ1bmN0aW9uIGwoVCxqKXt2YXIgJD1qWzBdLHc9alsxXSxKPWpbMl0scT1qWzNdLFc9JCpxLUoqdztyZXR1cm4gVz8oVz0xL1csVFswXT1xKlcsVFsxXT0tdypXLFRbMl09LUoqVyxUWzNdPSQqVyxUKTpudWxsfWZ1bmN0aW9uIG0oVCxqKXt2YXIgJD1qWzBdO3JldHVybiBUWzBdPWpbM10sVFsxXT0talsxXSxUWzJdPS1qWzJdLFRbM109JCxUfWZ1bmN0aW9uIHAoVCl7cmV0dXJuIFRbMF0qVFszXS1UWzJdKlRbMV19ZnVuY3Rpb24gQyhULGosJCl7dmFyIHc9alswXSxKPWpbMV0scT1qWzJdLFc9alszXSxLPSRbMF0sUT0kWzFdLHR0PSRbMl0sXz0kWzNdO3JldHVybiBUWzBdPXcqSytxKlEsVFsxXT1KKksrVypRLFRbMl09dyp0dCtxKl8sVFszXT1KKnR0K1cqXyxUfWZ1bmN0aW9uIHgoVCxqLCQpe3ZhciB3PWpbMF0sSj1qWzFdLHE9alsyXSxXPWpbM10sSz1NYXRoLnNpbigkKSxRPU1hdGguY29zKCQpO3JldHVybiBUWzBdPXcqUStxKkssVFsxXT1KKlErVypLLFRbMl09dyotSytxKlEsVFszXT1KKi1LK1cqUSxUfWZ1bmN0aW9uIGQoVCxqLCQpe3ZhciB3PWpbMF0sSj1qWzFdLHE9alsyXSxXPWpbM10sSz0kWzBdLFE9JFsxXTtyZXR1cm4gVFswXT13KkssVFsxXT1KKkssVFsyXT1xKlEsVFszXT1XKlEsVH1mdW5jdGlvbiB5KFQsail7dmFyICQ9TWF0aC5zaW4oaiksdz1NYXRoLmNvcyhqKTtyZXR1cm4gVFswXT13LFRbMV09JCxUWzJdPS0kLFRbM109dyxUfWZ1bmN0aW9uIHIoVCxqKXtyZXR1cm4gVFswXT1qWzBdLFRbMV09MCxUWzJdPTAsVFszXT1qWzFdLFR9ZnVuY3Rpb24gcyhUKXtyZXR1cm4ibWF0MigiK1RbMF0rIiwgIitUWzFdKyIsICIrVFsyXSsiLCAiK1RbM10rIikifWZ1bmN0aW9uIG4oVCl7cmV0dXJuIE1hdGguaHlwb3QoVFswXSxUWzFdLFRbMl0sVFszXSl9ZnVuY3Rpb24gYShULGosJCx3KXtyZXR1cm4gVFsyXT13WzJdL3dbMF0sJFswXT13WzBdLCRbMV09d1sxXSwkWzNdPXdbM10tVFsyXSokWzFdLFtULGosJF19ZnVuY3Rpb24gTyhULGosJCl7cmV0dXJuIFRbMF09alswXSskWzBdLFRbMV09alsxXSskWzFdLFRbMl09alsyXSskWzJdLFRbM109alszXSskWzNdLFR9ZnVuY3Rpb24gQShULGosJCl7cmV0dXJuIFRbMF09alswXS0kWzBdLFRbMV09alsxXS0kWzFdLFRbMl09alsyXS0kWzJdLFRbM109alszXS0kWzNdLFR9ZnVuY3Rpb24gYihULGope3JldHVybiBUWzBdPT09alswXSYmVFsxXT09PWpbMV0mJlRbMl09PT1qWzJdJiZUWzNdPT09alszXX1mdW5jdGlvbiBJKFQsail7dmFyICQ9VFswXSx3PVRbMV0sSj1UWzJdLHE9VFszXSxXPWpbMF0sSz1qWzFdLFE9alsyXSx0dD1qWzNdO3JldHVybiBNYXRoLmFicygkLVcpPD1pLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicygkKSxNYXRoLmFicyhXKSkmJk1hdGguYWJzKHctSyk8PWkuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKHcpLE1hdGguYWJzKEspKSYmTWF0aC5hYnMoSi1RKTw9aS5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoSiksTWF0aC5hYnMoUSkpJiZNYXRoLmFicyhxLXR0KTw9aS5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMocSksTWF0aC5hYnModHQpKX1mdW5jdGlvbiBQKFQsaiwkKXtyZXR1cm4gVFswXT1qWzBdKiQsVFsxXT1qWzFdKiQsVFsyXT1qWzJdKiQsVFszXT1qWzNdKiQsVH1mdW5jdGlvbiBEKFQsaiwkLHcpe3JldHVybiBUWzBdPWpbMF0rJFswXSp3LFRbMV09alsxXSskWzFdKncsVFsyXT1qWzJdKyRbMl0qdyxUWzNdPWpbM10rJFszXSp3LFR9dmFyIEw9QyxTPUF9LGZ1bmN0aW9uKFIsZSx0KXt0LnIoZSksdC5kKGUsImNyZWF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gb30pLHQuZChlLCJjbG9uZSIsZnVuY3Rpb24oKXtyZXR1cm4gZ30pLHQuZChlLCJjb3B5IixmdW5jdGlvbigpe3JldHVybiB2fSksdC5kKGUsImlkZW50aXR5IixmdW5jdGlvbigpe3JldHVybiBjfSksdC5kKGUsImZyb21WYWx1ZXMiLGZ1bmN0aW9uKCl7cmV0dXJuIGZ9KSx0LmQoZSwic2V0IixmdW5jdGlvbigpe3JldHVybiBofSksdC5kKGUsImludmVydCIsZnVuY3Rpb24oKXtyZXR1cm4gRX0pLHQuZChlLCJkZXRlcm1pbmFudCIsZnVuY3Rpb24oKXtyZXR1cm4gbH0pLHQuZChlLCJtdWx0aXBseSIsZnVuY3Rpb24oKXtyZXR1cm4gbX0pLHQuZChlLCJyb3RhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIHB9KSx0LmQoZSwic2NhbGUiLGZ1bmN0aW9uKCl7cmV0dXJuIEN9KSx0LmQoZSwidHJhbnNsYXRlIixmdW5jdGlvbigpe3JldHVybiB4fSksdC5kKGUsImZyb21Sb3RhdGlvbiIsZnVuY3Rpb24oKXtyZXR1cm4gZH0pLHQuZChlLCJmcm9tU2NhbGluZyIsZnVuY3Rpb24oKXtyZXR1cm4geX0pLHQuZChlLCJmcm9tVHJhbnNsYXRpb24iLGZ1bmN0aW9uKCl7cmV0dXJuIHJ9KSx0LmQoZSwic3RyIixmdW5jdGlvbigpe3JldHVybiBzfSksdC5kKGUsImZyb2IiLGZ1bmN0aW9uKCl7cmV0dXJuIG59KSx0LmQoZSwiYWRkIixmdW5jdGlvbigpe3JldHVybiBhfSksdC5kKGUsInN1YnRyYWN0IixmdW5jdGlvbigpe3JldHVybiBPfSksdC5kKGUsIm11bHRpcGx5U2NhbGFyIixmdW5jdGlvbigpe3JldHVybiBBfSksdC5kKGUsIm11bHRpcGx5U2NhbGFyQW5kQWRkIixmdW5jdGlvbigpe3JldHVybiBifSksdC5kKGUsImV4YWN0RXF1YWxzIixmdW5jdGlvbigpe3JldHVybiBJfSksdC5kKGUsImVxdWFscyIsZnVuY3Rpb24oKXtyZXR1cm4gUH0pLHQuZChlLCJtdWwiLGZ1bmN0aW9uKCl7cmV0dXJuIER9KSx0LmQoZSwic3ViIixmdW5jdGlvbigpe3JldHVybiBMfSk7dmFyIGk9dCgyKTtmdW5jdGlvbiBvKCl7dmFyIFM9bmV3IGkuQVJSQVlfVFlQRSg2KTtyZXR1cm4gaS5BUlJBWV9UWVBFIT1GbG9hdDMyQXJyYXkmJihTWzFdPTAsU1syXT0wLFNbNF09MCxTWzVdPTApLFNbMF09MSxTWzNdPTEsU31mdW5jdGlvbiBnKFMpe3ZhciBUPW5ldyBpLkFSUkFZX1RZUEUoNik7cmV0dXJuIFRbMF09U1swXSxUWzFdPVNbMV0sVFsyXT1TWzJdLFRbM109U1szXSxUWzRdPVNbNF0sVFs1XT1TWzVdLFR9ZnVuY3Rpb24gdihTLFQpe3JldHVybiBTWzBdPVRbMF0sU1sxXT1UWzFdLFNbMl09VFsyXSxTWzNdPVRbM10sU1s0XT1UWzRdLFNbNV09VFs1XSxTfWZ1bmN0aW9uIGMoUyl7cmV0dXJuIFNbMF09MSxTWzFdPTAsU1syXT0wLFNbM109MSxTWzRdPTAsU1s1XT0wLFN9ZnVuY3Rpb24gZihTLFQsaiwkLHcsSil7dmFyIHE9bmV3IGkuQVJSQVlfVFlQRSg2KTtyZXR1cm4gcVswXT1TLHFbMV09VCxxWzJdPWoscVszXT0kLHFbNF09dyxxWzVdPUoscX1mdW5jdGlvbiBoKFMsVCxqLCQsdyxKLHEpe3JldHVybiBTWzBdPVQsU1sxXT1qLFNbMl09JCxTWzNdPXcsU1s0XT1KLFNbNV09cSxTfWZ1bmN0aW9uIEUoUyxUKXt2YXIgaj1UWzBdLCQ9VFsxXSx3PVRbMl0sSj1UWzNdLHE9VFs0XSxXPVRbNV0sSz1qKkotJCp3O3JldHVybiBLPyhLPTEvSyxTWzBdPUoqSyxTWzFdPS0kKkssU1syXT0tdypLLFNbM109aipLLFNbNF09KHcqVy1KKnEpKkssU1s1XT0oJCpxLWoqVykqSyxTKTpudWxsfWZ1bmN0aW9uIGwoUyl7cmV0dXJuIFNbMF0qU1szXS1TWzFdKlNbMl19ZnVuY3Rpb24gbShTLFQsail7dmFyICQ9VFswXSx3PVRbMV0sSj1UWzJdLHE9VFszXSxXPVRbNF0sSz1UWzVdLFE9alswXSx0dD1qWzFdLF89alsyXSxzdD1qWzNdLGs9als0XSxjdD1qWzVdO3JldHVybiBTWzBdPSQqUStKKnR0LFNbMV09dypRK3EqdHQsU1syXT0kKl8rSipzdCxTWzNdPXcqXytxKnN0LFNbNF09JCprK0oqY3QrVyxTWzVdPXcqaytxKmN0K0ssU31mdW5jdGlvbiBwKFMsVCxqKXt2YXIgJD1UWzBdLHc9VFsxXSxKPVRbMl0scT1UWzNdLFc9VFs0XSxLPVRbNV0sUT1NYXRoLnNpbihqKSx0dD1NYXRoLmNvcyhqKTtyZXR1cm4gU1swXT0kKnR0K0oqUSxTWzFdPXcqdHQrcSpRLFNbMl09JCotUStKKnR0LFNbM109dyotUStxKnR0LFNbNF09VyxTWzVdPUssU31mdW5jdGlvbiBDKFMsVCxqKXt2YXIgJD1UWzBdLHc9VFsxXSxKPVRbMl0scT1UWzNdLFc9VFs0XSxLPVRbNV0sUT1qWzBdLHR0PWpbMV07cmV0dXJuIFNbMF09JCpRLFNbMV09dypRLFNbMl09Sip0dCxTWzNdPXEqdHQsU1s0XT1XLFNbNV09SyxTfWZ1bmN0aW9uIHgoUyxULGope3ZhciAkPVRbMF0sdz1UWzFdLEo9VFsyXSxxPVRbM10sVz1UWzRdLEs9VFs1XSxRPWpbMF0sdHQ9alsxXTtyZXR1cm4gU1swXT0kLFNbMV09dyxTWzJdPUosU1szXT1xLFNbNF09JCpRK0oqdHQrVyxTWzVdPXcqUStxKnR0K0ssU31mdW5jdGlvbiBkKFMsVCl7dmFyIGo9TWF0aC5zaW4oVCksJD1NYXRoLmNvcyhUKTtyZXR1cm4gU1swXT0kLFNbMV09aixTWzJdPS1qLFNbM109JCxTWzRdPTAsU1s1XT0wLFN9ZnVuY3Rpb24geShTLFQpe3JldHVybiBTWzBdPVRbMF0sU1sxXT0wLFNbMl09MCxTWzNdPVRbMV0sU1s0XT0wLFNbNV09MCxTfWZ1bmN0aW9uIHIoUyxUKXtyZXR1cm4gU1swXT0xLFNbMV09MCxTWzJdPTAsU1szXT0xLFNbNF09VFswXSxTWzVdPVRbMV0sU31mdW5jdGlvbiBzKFMpe3JldHVybiJtYXQyZCgiK1NbMF0rIiwgIitTWzFdKyIsICIrU1syXSsiLCAiK1NbM10rIiwgIitTWzRdKyIsICIrU1s1XSsiKSJ9ZnVuY3Rpb24gbihTKXtyZXR1cm4gTWF0aC5oeXBvdChTWzBdLFNbMV0sU1syXSxTWzNdLFNbNF0sU1s1XSwxKX1mdW5jdGlvbiBhKFMsVCxqKXtyZXR1cm4gU1swXT1UWzBdK2pbMF0sU1sxXT1UWzFdK2pbMV0sU1syXT1UWzJdK2pbMl0sU1szXT1UWzNdK2pbM10sU1s0XT1UWzRdK2pbNF0sU1s1XT1UWzVdK2pbNV0sU31mdW5jdGlvbiBPKFMsVCxqKXtyZXR1cm4gU1swXT1UWzBdLWpbMF0sU1sxXT1UWzFdLWpbMV0sU1syXT1UWzJdLWpbMl0sU1szXT1UWzNdLWpbM10sU1s0XT1UWzRdLWpbNF0sU1s1XT1UWzVdLWpbNV0sU31mdW5jdGlvbiBBKFMsVCxqKXtyZXR1cm4gU1swXT1UWzBdKmosU1sxXT1UWzFdKmosU1syXT1UWzJdKmosU1szXT1UWzNdKmosU1s0XT1UWzRdKmosU1s1XT1UWzVdKmosU31mdW5jdGlvbiBiKFMsVCxqLCQpe3JldHVybiBTWzBdPVRbMF0ralswXSokLFNbMV09VFsxXStqWzFdKiQsU1syXT1UWzJdK2pbMl0qJCxTWzNdPVRbM10ralszXSokLFNbNF09VFs0XStqWzRdKiQsU1s1XT1UWzVdK2pbNV0qJCxTfWZ1bmN0aW9uIEkoUyxUKXtyZXR1cm4gU1swXT09PVRbMF0mJlNbMV09PT1UWzFdJiZTWzJdPT09VFsyXSYmU1szXT09PVRbM10mJlNbNF09PT1UWzRdJiZTWzVdPT09VFs1XX1mdW5jdGlvbiBQKFMsVCl7dmFyIGo9U1swXSwkPVNbMV0sdz1TWzJdLEo9U1szXSxxPVNbNF0sVz1TWzVdLEs9VFswXSxRPVRbMV0sdHQ9VFsyXSxfPVRbM10sc3Q9VFs0XSxrPVRbNV07cmV0dXJuIE1hdGguYWJzKGotSyk8PWkuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKGopLE1hdGguYWJzKEspKSYmTWF0aC5hYnMoJC1RKTw9aS5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoJCksTWF0aC5hYnMoUSkpJiZNYXRoLmFicyh3LXR0KTw9aS5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnModyksTWF0aC5hYnModHQpKSYmTWF0aC5hYnMoSi1fKTw9aS5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoSiksTWF0aC5hYnMoXykpJiZNYXRoLmFicyhxLXN0KTw9aS5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMocSksTWF0aC5hYnMoc3QpKSYmTWF0aC5hYnMoVy1rKTw9aS5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoVyksTWF0aC5hYnMoaykpfXZhciBEPW0sTD1PfSxmdW5jdGlvbihSLGUsdCl7dC5yKGUpLHQuZChlLCJjcmVhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIG99KSx0LmQoZSwiZnJvbU1hdDQiLGZ1bmN0aW9uKCl7cmV0dXJuIGd9KSx0LmQoZSwiY2xvbmUiLGZ1bmN0aW9uKCl7cmV0dXJuIHZ9KSx0LmQoZSwiY29weSIsZnVuY3Rpb24oKXtyZXR1cm4gY30pLHQuZChlLCJmcm9tVmFsdWVzIixmdW5jdGlvbigpe3JldHVybiBmfSksdC5kKGUsInNldCIsZnVuY3Rpb24oKXtyZXR1cm4gaH0pLHQuZChlLCJpZGVudGl0eSIsZnVuY3Rpb24oKXtyZXR1cm4gRX0pLHQuZChlLCJ0cmFuc3Bvc2UiLGZ1bmN0aW9uKCl7cmV0dXJuIGx9KSx0LmQoZSwiaW52ZXJ0IixmdW5jdGlvbigpe3JldHVybiBtfSksdC5kKGUsImFkam9pbnQiLGZ1bmN0aW9uKCl7cmV0dXJuIHB9KSx0LmQoZSwiZGV0ZXJtaW5hbnQiLGZ1bmN0aW9uKCl7cmV0dXJuIEN9KSx0LmQoZSwibXVsdGlwbHkiLGZ1bmN0aW9uKCl7cmV0dXJuIHh9KSx0LmQoZSwidHJhbnNsYXRlIixmdW5jdGlvbigpe3JldHVybiBkfSksdC5kKGUsInJvdGF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4geX0pLHQuZChlLCJzY2FsZSIsZnVuY3Rpb24oKXtyZXR1cm4gcn0pLHQuZChlLCJmcm9tVHJhbnNsYXRpb24iLGZ1bmN0aW9uKCl7cmV0dXJuIHN9KSx0LmQoZSwiZnJvbVJvdGF0aW9uIixmdW5jdGlvbigpe3JldHVybiBufSksdC5kKGUsImZyb21TY2FsaW5nIixmdW5jdGlvbigpe3JldHVybiBhfSksdC5kKGUsImZyb21NYXQyZCIsZnVuY3Rpb24oKXtyZXR1cm4gT30pLHQuZChlLCJmcm9tUXVhdCIsZnVuY3Rpb24oKXtyZXR1cm4gQX0pLHQuZChlLCJub3JtYWxGcm9tTWF0NCIsZnVuY3Rpb24oKXtyZXR1cm4gYn0pLHQuZChlLCJwcm9qZWN0aW9uIixmdW5jdGlvbigpe3JldHVybiBJfSksdC5kKGUsInN0ciIsZnVuY3Rpb24oKXtyZXR1cm4gUH0pLHQuZChlLCJmcm9iIixmdW5jdGlvbigpe3JldHVybiBEfSksdC5kKGUsImFkZCIsZnVuY3Rpb24oKXtyZXR1cm4gTH0pLHQuZChlLCJzdWJ0cmFjdCIsZnVuY3Rpb24oKXtyZXR1cm4gU30pLHQuZChlLCJtdWx0aXBseVNjYWxhciIsZnVuY3Rpb24oKXtyZXR1cm4gVH0pLHQuZChlLCJtdWx0aXBseVNjYWxhckFuZEFkZCIsZnVuY3Rpb24oKXtyZXR1cm4gan0pLHQuZChlLCJleGFjdEVxdWFscyIsZnVuY3Rpb24oKXtyZXR1cm4gJH0pLHQuZChlLCJlcXVhbHMiLGZ1bmN0aW9uKCl7cmV0dXJuIHd9KSx0LmQoZSwibXVsIixmdW5jdGlvbigpe3JldHVybiBKfSksdC5kKGUsInN1YiIsZnVuY3Rpb24oKXtyZXR1cm4gcX0pO3ZhciBpPXQoMik7ZnVuY3Rpb24gbygpe3ZhciBXPW5ldyBpLkFSUkFZX1RZUEUoOSk7cmV0dXJuIGkuQVJSQVlfVFlQRSE9RmxvYXQzMkFycmF5JiYoV1sxXT0wLFdbMl09MCxXWzNdPTAsV1s1XT0wLFdbNl09MCxXWzddPTApLFdbMF09MSxXWzRdPTEsV1s4XT0xLFd9ZnVuY3Rpb24gZyhXLEspe3JldHVybiBXWzBdPUtbMF0sV1sxXT1LWzFdLFdbMl09S1syXSxXWzNdPUtbNF0sV1s0XT1LWzVdLFdbNV09S1s2XSxXWzZdPUtbOF0sV1s3XT1LWzldLFdbOF09S1sxMF0sV31mdW5jdGlvbiB2KFcpe3ZhciBLPW5ldyBpLkFSUkFZX1RZUEUoOSk7cmV0dXJuIEtbMF09V1swXSxLWzFdPVdbMV0sS1syXT1XWzJdLEtbM109V1szXSxLWzRdPVdbNF0sS1s1XT1XWzVdLEtbNl09V1s2XSxLWzddPVdbN10sS1s4XT1XWzhdLEt9ZnVuY3Rpb24gYyhXLEspe3JldHVybiBXWzBdPUtbMF0sV1sxXT1LWzFdLFdbMl09S1syXSxXWzNdPUtbM10sV1s0XT1LWzRdLFdbNV09S1s1XSxXWzZdPUtbNl0sV1s3XT1LWzddLFdbOF09S1s4XSxXfWZ1bmN0aW9uIGYoVyxLLFEsdHQsXyxzdCxrLGN0LGZ0KXt2YXIgVT1uZXcgaS5BUlJBWV9UWVBFKDkpO3JldHVybiBVWzBdPVcsVVsxXT1LLFVbMl09USxVWzNdPXR0LFVbNF09XyxVWzVdPXN0LFVbNl09ayxVWzddPWN0LFVbOF09ZnQsVX1mdW5jdGlvbiBoKFcsSyxRLHR0LF8sc3QsayxjdCxmdCxVKXtyZXR1cm4gV1swXT1LLFdbMV09USxXWzJdPXR0LFdbM109XyxXWzRdPXN0LFdbNV09ayxXWzZdPWN0LFdbN109ZnQsV1s4XT1VLFd9ZnVuY3Rpb24gRShXKXtyZXR1cm4gV1swXT0xLFdbMV09MCxXWzJdPTAsV1szXT0wLFdbNF09MSxXWzVdPTAsV1s2XT0wLFdbN109MCxXWzhdPTEsV31mdW5jdGlvbiBsKFcsSyl7aWYoVz09PUspe3ZhciBRPUtbMV0sdHQ9S1syXSxfPUtbNV07V1sxXT1LWzNdLFdbMl09S1s2XSxXWzNdPVEsV1s1XT1LWzddLFdbNl09dHQsV1s3XT1ffWVsc2UgV1swXT1LWzBdLFdbMV09S1szXSxXWzJdPUtbNl0sV1szXT1LWzFdLFdbNF09S1s0XSxXWzVdPUtbN10sV1s2XT1LWzJdLFdbN109S1s1XSxXWzhdPUtbOF07cmV0dXJuIFd9ZnVuY3Rpb24gbShXLEspe3ZhciBRPUtbMF0sdHQ9S1sxXSxfPUtbMl0sc3Q9S1szXSxrPUtbNF0sY3Q9S1s1XSxmdD1LWzZdLFU9S1s3XSxGPUtbOF0sVj1GKmstY3QqVSxYPS1GKnN0K2N0KmZ0LEI9VSpzdC1rKmZ0LEc9USpWK3R0KlgrXypCO3JldHVybiBHPyhHPTEvRyxXWzBdPVYqRyxXWzFdPSgtRip0dCtfKlUpKkcsV1syXT0oY3QqdHQtXyprKSpHLFdbM109WCpHLFdbNF09KEYqUS1fKmZ0KSpHLFdbNV09KC1jdCpRK18qc3QpKkcsV1s2XT1CKkcsV1s3XT0oLVUqUSt0dCpmdCkqRyxXWzhdPShrKlEtdHQqc3QpKkcsVyk6bnVsbH1mdW5jdGlvbiBwKFcsSyl7dmFyIFE9S1swXSx0dD1LWzFdLF89S1syXSxzdD1LWzNdLGs9S1s0XSxjdD1LWzVdLGZ0PUtbNl0sVT1LWzddLEY9S1s4XTtyZXR1cm4gV1swXT1rKkYtY3QqVSxXWzFdPV8qVS10dCpGLFdbMl09dHQqY3QtXyprLFdbM109Y3QqZnQtc3QqRixXWzRdPVEqRi1fKmZ0LFdbNV09XypzdC1RKmN0LFdbNl09c3QqVS1rKmZ0LFdbN109dHQqZnQtUSpVLFdbOF09USprLXR0KnN0LFd9ZnVuY3Rpb24gQyhXKXt2YXIgSz1XWzBdLFE9V1sxXSx0dD1XWzJdLF89V1szXSxzdD1XWzRdLGs9V1s1XSxjdD1XWzZdLGZ0PVdbN10sVT1XWzhdO3JldHVybiBLKihVKnN0LWsqZnQpK1EqKC1VKl8raypjdCkrdHQqKGZ0Kl8tc3QqY3QpfWZ1bmN0aW9uIHgoVyxLLFEpe3ZhciB0dD1LWzBdLF89S1sxXSxzdD1LWzJdLGs9S1szXSxjdD1LWzRdLGZ0PUtbNV0sVT1LWzZdLEY9S1s3XSxWPUtbOF0sWD1RWzBdLEI9UVsxXSxHPVFbMl0sdT1RWzNdLE09UVs0XSxOPVFbNV0sej1RWzZdLEg9UVs3XSxZPVFbOF07cmV0dXJuIFdbMF09WCp0dCtCKmsrRypVLFdbMV09WCpfK0IqY3QrRypGLFdbMl09WCpzdCtCKmZ0K0cqVixXWzNdPXUqdHQrTSprK04qVSxXWzRdPXUqXytNKmN0K04qRixXWzVdPXUqc3QrTSpmdCtOKlYsV1s2XT16KnR0K0gqaytZKlUsV1s3XT16Kl8rSCpjdCtZKkYsV1s4XT16KnN0K0gqZnQrWSpWLFd9ZnVuY3Rpb24gZChXLEssUSl7dmFyIHR0PUtbMF0sXz1LWzFdLHN0PUtbMl0saz1LWzNdLGN0PUtbNF0sZnQ9S1s1XSxVPUtbNl0sRj1LWzddLFY9S1s4XSxYPVFbMF0sQj1RWzFdO3JldHVybiBXWzBdPXR0LFdbMV09XyxXWzJdPXN0LFdbM109ayxXWzRdPWN0LFdbNV09ZnQsV1s2XT1YKnR0K0IqaytVLFdbN109WCpfK0IqY3QrRixXWzhdPVgqc3QrQipmdCtWLFd9ZnVuY3Rpb24geShXLEssUSl7dmFyIHR0PUtbMF0sXz1LWzFdLHN0PUtbMl0saz1LWzNdLGN0PUtbNF0sZnQ9S1s1XSxVPUtbNl0sRj1LWzddLFY9S1s4XSxYPU1hdGguc2luKFEpLEI9TWF0aC5jb3MoUSk7cmV0dXJuIFdbMF09Qip0dCtYKmssV1sxXT1CKl8rWCpjdCxXWzJdPUIqc3QrWCpmdCxXWzNdPUIqay1YKnR0LFdbNF09QipjdC1YKl8sV1s1XT1CKmZ0LVgqc3QsV1s2XT1VLFdbN109RixXWzhdPVYsV31mdW5jdGlvbiByKFcsSyxRKXt2YXIgdHQ9UVswXSxfPVFbMV07cmV0dXJuIFdbMF09dHQqS1swXSxXWzFdPXR0KktbMV0sV1syXT10dCpLWzJdLFdbM109XypLWzNdLFdbNF09XypLWzRdLFdbNV09XypLWzVdLFdbNl09S1s2XSxXWzddPUtbN10sV1s4XT1LWzhdLFd9ZnVuY3Rpb24gcyhXLEspe3JldHVybiBXWzBdPTEsV1sxXT0wLFdbMl09MCxXWzNdPTAsV1s0XT0xLFdbNV09MCxXWzZdPUtbMF0sV1s3XT1LWzFdLFdbOF09MSxXfWZ1bmN0aW9uIG4oVyxLKXt2YXIgUT1NYXRoLnNpbihLKSx0dD1NYXRoLmNvcyhLKTtyZXR1cm4gV1swXT10dCxXWzFdPVEsV1syXT0wLFdbM109LVEsV1s0XT10dCxXWzVdPTAsV1s2XT0wLFdbN109MCxXWzhdPTEsV31mdW5jdGlvbiBhKFcsSyl7cmV0dXJuIFdbMF09S1swXSxXWzFdPTAsV1syXT0wLFdbM109MCxXWzRdPUtbMV0sV1s1XT0wLFdbNl09MCxXWzddPTAsV1s4XT0xLFd9ZnVuY3Rpb24gTyhXLEspe3JldHVybiBXWzBdPUtbMF0sV1sxXT1LWzFdLFdbMl09MCxXWzNdPUtbMl0sV1s0XT1LWzNdLFdbNV09MCxXWzZdPUtbNF0sV1s3XT1LWzVdLFdbOF09MSxXfWZ1bmN0aW9uIEEoVyxLKXt2YXIgUT1LWzBdLHR0PUtbMV0sXz1LWzJdLHN0PUtbM10saz1RK1EsY3Q9dHQrdHQsZnQ9XytfLFU9USprLEY9dHQqayxWPXR0KmN0LFg9XyprLEI9XypjdCxHPV8qZnQsdT1zdCprLE09c3QqY3QsTj1zdCpmdDtyZXR1cm4gV1swXT0xLVYtRyxXWzNdPUYtTixXWzZdPVgrTSxXWzFdPUYrTixXWzRdPTEtVS1HLFdbN109Qi11LFdbMl09WC1NLFdbNV09Qit1LFdbOF09MS1VLVYsV31mdW5jdGlvbiBiKFcsSyl7dmFyIFE9S1swXSx0dD1LWzFdLF89S1syXSxzdD1LWzNdLGs9S1s0XSxjdD1LWzVdLGZ0PUtbNl0sVT1LWzddLEY9S1s4XSxWPUtbOV0sWD1LWzEwXSxCPUtbMTFdLEc9S1sxMl0sdT1LWzEzXSxNPUtbMTRdLE49S1sxNV0sej1RKmN0LXR0KmssSD1RKmZ0LV8qayxZPVEqVS1zdCprLFo9dHQqZnQtXypjdCxldD10dCpVLXN0KmN0LHJ0PV8qVS1zdCpmdCxvdD1GKnUtVipHLGx0PUYqTS1YKkcsaXQ9RipOLUIqRyxudD1WKk0tWCp1LGF0PVYqTi1CKnUsZHQ9WCpOLUIqTSxndD16KmR0LUgqYXQrWSpudCtaKml0LWV0Kmx0K3J0Km90O3JldHVybiBndD8oZ3Q9MS9ndCxXWzBdPShjdCpkdC1mdCphdCtVKm50KSpndCxXWzFdPShmdCppdC1rKmR0LVUqbHQpKmd0LFdbMl09KGsqYXQtY3QqaXQrVSpvdCkqZ3QsV1szXT0oXyphdC10dCpkdC1zdCpudCkqZ3QsV1s0XT0oUSpkdC1fKml0K3N0Kmx0KSpndCxXWzVdPSh0dCppdC1RKmF0LXN0Km90KSpndCxXWzZdPSh1KnJ0LU0qZXQrTipaKSpndCxXWzddPShNKlktRypydC1OKkgpKmd0LFdbOF09KEcqZXQtdSpZK04qeikqZ3QsVyk6bnVsbH1mdW5jdGlvbiBJKFcsSyxRKXtyZXR1cm4gV1swXT0yL0ssV1sxXT0wLFdbMl09MCxXWzNdPTAsV1s0XT0tMi9RLFdbNV09MCxXWzZdPS0xLFdbN109MSxXWzhdPTEsV31mdW5jdGlvbiBQKFcpe3JldHVybiJtYXQzKCIrV1swXSsiLCAiK1dbMV0rIiwgIitXWzJdKyIsICIrV1szXSsiLCAiK1dbNF0rIiwgIitXWzVdKyIsICIrV1s2XSsiLCAiK1dbN10rIiwgIitXWzhdKyIpIn1mdW5jdGlvbiBEKFcpe3JldHVybiBNYXRoLmh5cG90KFdbMF0sV1sxXSxXWzJdLFdbM10sV1s0XSxXWzVdLFdbNl0sV1s3XSxXWzhdKX1mdW5jdGlvbiBMKFcsSyxRKXtyZXR1cm4gV1swXT1LWzBdK1FbMF0sV1sxXT1LWzFdK1FbMV0sV1syXT1LWzJdK1FbMl0sV1szXT1LWzNdK1FbM10sV1s0XT1LWzRdK1FbNF0sV1s1XT1LWzVdK1FbNV0sV1s2XT1LWzZdK1FbNl0sV1s3XT1LWzddK1FbN10sV1s4XT1LWzhdK1FbOF0sV31mdW5jdGlvbiBTKFcsSyxRKXtyZXR1cm4gV1swXT1LWzBdLVFbMF0sV1sxXT1LWzFdLVFbMV0sV1syXT1LWzJdLVFbMl0sV1szXT1LWzNdLVFbM10sV1s0XT1LWzRdLVFbNF0sV1s1XT1LWzVdLVFbNV0sV1s2XT1LWzZdLVFbNl0sV1s3XT1LWzddLVFbN10sV1s4XT1LWzhdLVFbOF0sV31mdW5jdGlvbiBUKFcsSyxRKXtyZXR1cm4gV1swXT1LWzBdKlEsV1sxXT1LWzFdKlEsV1syXT1LWzJdKlEsV1szXT1LWzNdKlEsV1s0XT1LWzRdKlEsV1s1XT1LWzVdKlEsV1s2XT1LWzZdKlEsV1s3XT1LWzddKlEsV1s4XT1LWzhdKlEsV31mdW5jdGlvbiBqKFcsSyxRLHR0KXtyZXR1cm4gV1swXT1LWzBdK1FbMF0qdHQsV1sxXT1LWzFdK1FbMV0qdHQsV1syXT1LWzJdK1FbMl0qdHQsV1szXT1LWzNdK1FbM10qdHQsV1s0XT1LWzRdK1FbNF0qdHQsV1s1XT1LWzVdK1FbNV0qdHQsV1s2XT1LWzZdK1FbNl0qdHQsV1s3XT1LWzddK1FbN10qdHQsV1s4XT1LWzhdK1FbOF0qdHQsV31mdW5jdGlvbiAkKFcsSyl7cmV0dXJuIFdbMF09PT1LWzBdJiZXWzFdPT09S1sxXSYmV1syXT09PUtbMl0mJldbM109PT1LWzNdJiZXWzRdPT09S1s0XSYmV1s1XT09PUtbNV0mJldbNl09PT1LWzZdJiZXWzddPT09S1s3XSYmV1s4XT09PUtbOF19ZnVuY3Rpb24gdyhXLEspe3ZhciBRPVdbMF0sdHQ9V1sxXSxfPVdbMl0sc3Q9V1szXSxrPVdbNF0sY3Q9V1s1XSxmdD1XWzZdLFU9V1s3XSxGPVdbOF0sVj1LWzBdLFg9S1sxXSxCPUtbMl0sRz1LWzNdLHU9S1s0XSxNPUtbNV0sTj1LWzZdLHo9S1s3XSxIPUtbOF07cmV0dXJuIE1hdGguYWJzKFEtVik8PWkuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKFEpLE1hdGguYWJzKFYpKSYmTWF0aC5hYnModHQtWCk8PWkuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKHR0KSxNYXRoLmFicyhYKSkmJk1hdGguYWJzKF8tQik8PWkuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKF8pLE1hdGguYWJzKEIpKSYmTWF0aC5hYnMoc3QtRyk8PWkuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKHN0KSxNYXRoLmFicyhHKSkmJk1hdGguYWJzKGstdSk8PWkuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKGspLE1hdGguYWJzKHUpKSYmTWF0aC5hYnMoY3QtTSk8PWkuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKGN0KSxNYXRoLmFicyhNKSkmJk1hdGguYWJzKGZ0LU4pPD1pLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhmdCksTWF0aC5hYnMoTikpJiZNYXRoLmFicyhVLXopPD1pLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhVKSxNYXRoLmFicyh6KSkmJk1hdGguYWJzKEYtSCk8PWkuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKEYpLE1hdGguYWJzKEgpKX12YXIgSj14LHE9U30sZnVuY3Rpb24oUixlLHQpe3QucihlKSx0LmQoZSwiY3JlYXRlIixmdW5jdGlvbigpe3JldHVybiBvfSksdC5kKGUsImNsb25lIixmdW5jdGlvbigpe3JldHVybiBnfSksdC5kKGUsImNvcHkiLGZ1bmN0aW9uKCl7cmV0dXJuIHZ9KSx0LmQoZSwiZnJvbVZhbHVlcyIsZnVuY3Rpb24oKXtyZXR1cm4gY30pLHQuZChlLCJzZXQiLGZ1bmN0aW9uKCl7cmV0dXJuIGZ9KSx0LmQoZSwiaWRlbnRpdHkiLGZ1bmN0aW9uKCl7cmV0dXJuIGh9KSx0LmQoZSwidHJhbnNwb3NlIixmdW5jdGlvbigpe3JldHVybiBFfSksdC5kKGUsImludmVydCIsZnVuY3Rpb24oKXtyZXR1cm4gbH0pLHQuZChlLCJhZGpvaW50IixmdW5jdGlvbigpe3JldHVybiBtfSksdC5kKGUsImRldGVybWluYW50IixmdW5jdGlvbigpe3JldHVybiBwfSksdC5kKGUsIm11bHRpcGx5IixmdW5jdGlvbigpe3JldHVybiBDfSksdC5kKGUsInRyYW5zbGF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4geH0pLHQuZChlLCJzY2FsZSIsZnVuY3Rpb24oKXtyZXR1cm4gZH0pLHQuZChlLCJyb3RhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIHl9KSx0LmQoZSwicm90YXRlWCIsZnVuY3Rpb24oKXtyZXR1cm4gcn0pLHQuZChlLCJyb3RhdGVZIixmdW5jdGlvbigpe3JldHVybiBzfSksdC5kKGUsInJvdGF0ZVoiLGZ1bmN0aW9uKCl7cmV0dXJuIG59KSx0LmQoZSwiZnJvbVRyYW5zbGF0aW9uIixmdW5jdGlvbigpe3JldHVybiBhfSksdC5kKGUsImZyb21TY2FsaW5nIixmdW5jdGlvbigpe3JldHVybiBPfSksdC5kKGUsImZyb21Sb3RhdGlvbiIsZnVuY3Rpb24oKXtyZXR1cm4gQX0pLHQuZChlLCJmcm9tWFJvdGF0aW9uIixmdW5jdGlvbigpe3JldHVybiBifSksdC5kKGUsImZyb21ZUm90YXRpb24iLGZ1bmN0aW9uKCl7cmV0dXJuIEl9KSx0LmQoZSwiZnJvbVpSb3RhdGlvbiIsZnVuY3Rpb24oKXtyZXR1cm4gUH0pLHQuZChlLCJmcm9tUm90YXRpb25UcmFuc2xhdGlvbiIsZnVuY3Rpb24oKXtyZXR1cm4gRH0pLHQuZChlLCJmcm9tUXVhdDIiLGZ1bmN0aW9uKCl7cmV0dXJuIEx9KSx0LmQoZSwiZ2V0VHJhbnNsYXRpb24iLGZ1bmN0aW9uKCl7cmV0dXJuIFN9KSx0LmQoZSwiZ2V0U2NhbGluZyIsZnVuY3Rpb24oKXtyZXR1cm4gVH0pLHQuZChlLCJnZXRSb3RhdGlvbiIsZnVuY3Rpb24oKXtyZXR1cm4gan0pLHQuZChlLCJmcm9tUm90YXRpb25UcmFuc2xhdGlvblNjYWxlIixmdW5jdGlvbigpe3JldHVybiAkfSksdC5kKGUsImZyb21Sb3RhdGlvblRyYW5zbGF0aW9uU2NhbGVPcmlnaW4iLGZ1bmN0aW9uKCl7cmV0dXJuIHd9KSx0LmQoZSwiZnJvbVF1YXQiLGZ1bmN0aW9uKCl7cmV0dXJuIEp9KSx0LmQoZSwiZnJ1c3R1bSIsZnVuY3Rpb24oKXtyZXR1cm4gcX0pLHQuZChlLCJwZXJzcGVjdGl2ZSIsZnVuY3Rpb24oKXtyZXR1cm4gV30pLHQuZChlLCJwZXJzcGVjdGl2ZUZyb21GaWVsZE9mVmlldyIsZnVuY3Rpb24oKXtyZXR1cm4gS30pLHQuZChlLCJvcnRobyIsZnVuY3Rpb24oKXtyZXR1cm4gUX0pLHQuZChlLCJsb29rQXQiLGZ1bmN0aW9uKCl7cmV0dXJuIHR0fSksdC5kKGUsInRhcmdldFRvIixmdW5jdGlvbigpe3JldHVybiBffSksdC5kKGUsInN0ciIsZnVuY3Rpb24oKXtyZXR1cm4gc3R9KSx0LmQoZSwiZnJvYiIsZnVuY3Rpb24oKXtyZXR1cm4ga30pLHQuZChlLCJhZGQiLGZ1bmN0aW9uKCl7cmV0dXJuIGN0fSksdC5kKGUsInN1YnRyYWN0IixmdW5jdGlvbigpe3JldHVybiBmdH0pLHQuZChlLCJtdWx0aXBseVNjYWxhciIsZnVuY3Rpb24oKXtyZXR1cm4gVX0pLHQuZChlLCJtdWx0aXBseVNjYWxhckFuZEFkZCIsZnVuY3Rpb24oKXtyZXR1cm4gRn0pLHQuZChlLCJleGFjdEVxdWFscyIsZnVuY3Rpb24oKXtyZXR1cm4gVn0pLHQuZChlLCJlcXVhbHMiLGZ1bmN0aW9uKCl7cmV0dXJuIFh9KSx0LmQoZSwibXVsIixmdW5jdGlvbigpe3JldHVybiBCfSksdC5kKGUsInN1YiIsZnVuY3Rpb24oKXtyZXR1cm4gR30pO3ZhciBpPXQoMik7ZnVuY3Rpb24gbygpe3ZhciB1PW5ldyBpLkFSUkFZX1RZUEUoMTYpO3JldHVybiBpLkFSUkFZX1RZUEUhPUZsb2F0MzJBcnJheSYmKHVbMV09MCx1WzJdPTAsdVszXT0wLHVbNF09MCx1WzZdPTAsdVs3XT0wLHVbOF09MCx1WzldPTAsdVsxMV09MCx1WzEyXT0wLHVbMTNdPTAsdVsxNF09MCksdVswXT0xLHVbNV09MSx1WzEwXT0xLHVbMTVdPTEsdX1mdW5jdGlvbiBnKHUpe3ZhciBNPW5ldyBpLkFSUkFZX1RZUEUoMTYpO3JldHVybiBNWzBdPXVbMF0sTVsxXT11WzFdLE1bMl09dVsyXSxNWzNdPXVbM10sTVs0XT11WzRdLE1bNV09dVs1XSxNWzZdPXVbNl0sTVs3XT11WzddLE1bOF09dVs4XSxNWzldPXVbOV0sTVsxMF09dVsxMF0sTVsxMV09dVsxMV0sTVsxMl09dVsxMl0sTVsxM109dVsxM10sTVsxNF09dVsxNF0sTVsxNV09dVsxNV0sTX1mdW5jdGlvbiB2KHUsTSl7cmV0dXJuIHVbMF09TVswXSx1WzFdPU1bMV0sdVsyXT1NWzJdLHVbM109TVszXSx1WzRdPU1bNF0sdVs1XT1NWzVdLHVbNl09TVs2XSx1WzddPU1bN10sdVs4XT1NWzhdLHVbOV09TVs5XSx1WzEwXT1NWzEwXSx1WzExXT1NWzExXSx1WzEyXT1NWzEyXSx1WzEzXT1NWzEzXSx1WzE0XT1NWzE0XSx1WzE1XT1NWzE1XSx1fWZ1bmN0aW9uIGModSxNLE4seixILFksWixldCxydCxvdCxsdCxpdCxudCxhdCxkdCxndCl7dmFyIHV0PW5ldyBpLkFSUkFZX1RZUEUoMTYpO3JldHVybiB1dFswXT11LHV0WzFdPU0sdXRbMl09Tix1dFszXT16LHV0WzRdPUgsdXRbNV09WSx1dFs2XT1aLHV0WzddPWV0LHV0WzhdPXJ0LHV0WzldPW90LHV0WzEwXT1sdCx1dFsxMV09aXQsdXRbMTJdPW50LHV0WzEzXT1hdCx1dFsxNF09ZHQsdXRbMTVdPWd0LHV0fWZ1bmN0aW9uIGYodSxNLE4seixILFksWixldCxydCxvdCxsdCxpdCxudCxhdCxkdCxndCx1dCl7cmV0dXJuIHVbMF09TSx1WzFdPU4sdVsyXT16LHVbM109SCx1WzRdPVksdVs1XT1aLHVbNl09ZXQsdVs3XT1ydCx1WzhdPW90LHVbOV09bHQsdVsxMF09aXQsdVsxMV09bnQsdVsxMl09YXQsdVsxM109ZHQsdVsxNF09Z3QsdVsxNV09dXQsdX1mdW5jdGlvbiBoKHUpe3JldHVybiB1WzBdPTEsdVsxXT0wLHVbMl09MCx1WzNdPTAsdVs0XT0wLHVbNV09MSx1WzZdPTAsdVs3XT0wLHVbOF09MCx1WzldPTAsdVsxMF09MSx1WzExXT0wLHVbMTJdPTAsdVsxM109MCx1WzE0XT0wLHVbMTVdPTEsdX1mdW5jdGlvbiBFKHUsTSl7aWYodT09PU0pe3ZhciBOPU1bMV0sej1NWzJdLEg9TVszXSxZPU1bNl0sWj1NWzddLGV0PU1bMTFdO3VbMV09TVs0XSx1WzJdPU1bOF0sdVszXT1NWzEyXSx1WzRdPU4sdVs2XT1NWzldLHVbN109TVsxM10sdVs4XT16LHVbOV09WSx1WzExXT1NWzE0XSx1WzEyXT1ILHVbMTNdPVosdVsxNF09ZXR9ZWxzZSB1WzBdPU1bMF0sdVsxXT1NWzRdLHVbMl09TVs4XSx1WzNdPU1bMTJdLHVbNF09TVsxXSx1WzVdPU1bNV0sdVs2XT1NWzldLHVbN109TVsxM10sdVs4XT1NWzJdLHVbOV09TVs2XSx1WzEwXT1NWzEwXSx1WzExXT1NWzE0XSx1WzEyXT1NWzNdLHVbMTNdPU1bN10sdVsxNF09TVsxMV0sdVsxNV09TVsxNV07cmV0dXJuIHV9ZnVuY3Rpb24gbCh1LE0pe3ZhciBOPU1bMF0sej1NWzFdLEg9TVsyXSxZPU1bM10sWj1NWzRdLGV0PU1bNV0scnQ9TVs2XSxvdD1NWzddLGx0PU1bOF0saXQ9TVs5XSxudD1NWzEwXSxhdD1NWzExXSxkdD1NWzEyXSxndD1NWzEzXSx1dD1NWzE0XSxtdD1NWzE1XSxFdD1OKmV0LXoqWix5dD1OKnJ0LUgqWixwdD1OKm90LVkqWix4dD16KnJ0LUgqZXQsTXQ9eipvdC1ZKmV0LE50PUgqb3QtWSpydCxEdD1sdCpndC1pdCpkdCxMdD1sdCp1dC1udCpkdCxJdD1sdCptdC1hdCpkdCxqdD1pdCp1dC1udCpndCxVdD1pdCptdC1hdCpndCxGdD1udCptdC1hdCp1dCxPdD1FdCpGdC15dCpVdCtwdCpqdCt4dCpJdC1NdCpMdCtOdCpEdDtyZXR1cm4gT3Q/KE90PTEvT3QsdVswXT0oZXQqRnQtcnQqVXQrb3QqanQpKk90LHVbMV09KEgqVXQteipGdC1ZKmp0KSpPdCx1WzJdPShndCpOdC11dCpNdCttdCp4dCkqT3QsdVszXT0obnQqTXQtaXQqTnQtYXQqeHQpKk90LHVbNF09KHJ0Kkl0LVoqRnQtb3QqTHQpKk90LHVbNV09KE4qRnQtSCpJdCtZKkx0KSpPdCx1WzZdPSh1dCpwdC1kdCpOdC1tdCp5dCkqT3QsdVs3XT0obHQqTnQtbnQqcHQrYXQqeXQpKk90LHVbOF09KFoqVXQtZXQqSXQrb3QqRHQpKk90LHVbOV09KHoqSXQtTipVdC1ZKkR0KSpPdCx1WzEwXT0oZHQqTXQtZ3QqcHQrbXQqRXQpKk90LHVbMTFdPShpdCpwdC1sdCpNdC1hdCpFdCkqT3QsdVsxMl09KGV0Kkx0LVoqanQtcnQqRHQpKk90LHVbMTNdPShOKmp0LXoqTHQrSCpEdCkqT3QsdVsxNF09KGd0Knl0LWR0Knh0LXV0KkV0KSpPdCx1WzE1XT0obHQqeHQtaXQqeXQrbnQqRXQpKk90LHUpOm51bGx9ZnVuY3Rpb24gbSh1LE0pe3ZhciBOPU1bMF0sej1NWzFdLEg9TVsyXSxZPU1bM10sWj1NWzRdLGV0PU1bNV0scnQ9TVs2XSxvdD1NWzddLGx0PU1bOF0saXQ9TVs5XSxudD1NWzEwXSxhdD1NWzExXSxkdD1NWzEyXSxndD1NWzEzXSx1dD1NWzE0XSxtdD1NWzE1XTtyZXR1cm4gdVswXT1ldCoobnQqbXQtYXQqdXQpLWl0KihydCptdC1vdCp1dCkrZ3QqKHJ0KmF0LW90Km50KSx1WzFdPS0oeioobnQqbXQtYXQqdXQpLWl0KihIKm10LVkqdXQpK2d0KihIKmF0LVkqbnQpKSx1WzJdPXoqKHJ0Km10LW90KnV0KS1ldCooSCptdC1ZKnV0KStndCooSCpvdC1ZKnJ0KSx1WzNdPS0oeioocnQqYXQtb3QqbnQpLWV0KihIKmF0LVkqbnQpK2l0KihIKm90LVkqcnQpKSx1WzRdPS0oWioobnQqbXQtYXQqdXQpLWx0KihydCptdC1vdCp1dCkrZHQqKHJ0KmF0LW90Km50KSksdVs1XT1OKihudCptdC1hdCp1dCktbHQqKEgqbXQtWSp1dCkrZHQqKEgqYXQtWSpudCksdVs2XT0tKE4qKHJ0Km10LW90KnV0KS1aKihIKm10LVkqdXQpK2R0KihIKm90LVkqcnQpKSx1WzddPU4qKHJ0KmF0LW90Km50KS1aKihIKmF0LVkqbnQpK2x0KihIKm90LVkqcnQpLHVbOF09WiooaXQqbXQtYXQqZ3QpLWx0KihldCptdC1vdCpndCkrZHQqKGV0KmF0LW90Kml0KSx1WzldPS0oTiooaXQqbXQtYXQqZ3QpLWx0Kih6Km10LVkqZ3QpK2R0Kih6KmF0LVkqaXQpKSx1WzEwXT1OKihldCptdC1vdCpndCktWiooeiptdC1ZKmd0KStkdCooeipvdC1ZKmV0KSx1WzExXT0tKE4qKGV0KmF0LW90Kml0KS1aKih6KmF0LVkqaXQpK2x0Kih6Km90LVkqZXQpKSx1WzEyXT0tKFoqKGl0KnV0LW50Kmd0KS1sdCooZXQqdXQtcnQqZ3QpK2R0KihldCpudC1ydCppdCkpLHVbMTNdPU4qKGl0KnV0LW50Kmd0KS1sdCooeip1dC1IKmd0KStkdCooeipudC1IKml0KSx1WzE0XT0tKE4qKGV0KnV0LXJ0Kmd0KS1aKih6KnV0LUgqZ3QpK2R0Kih6KnJ0LUgqZXQpKSx1WzE1XT1OKihldCpudC1ydCppdCktWiooeipudC1IKml0KStsdCooeipydC1IKmV0KSx1fWZ1bmN0aW9uIHAodSl7dmFyIE09dVswXSxOPXVbMV0sej11WzJdLEg9dVszXSxZPXVbNF0sWj11WzVdLGV0PXVbNl0scnQ9dVs3XSxvdD11WzhdLGx0PXVbOV0saXQ9dVsxMF0sbnQ9dVsxMV0sYXQ9dVsxMl0sZHQ9dVsxM10sZ3Q9dVsxNF0sdXQ9dVsxNV0sbXQ9TSpaLU4qWSxFdD1NKmV0LXoqWSx5dD1NKnJ0LUgqWSxwdD1OKmV0LXoqWix4dD1OKnJ0LUgqWixNdD16KnJ0LUgqZXQsTnQ9b3QqZHQtbHQqYXQsRHQ9b3QqZ3QtaXQqYXQsTHQ9b3QqdXQtbnQqYXQsSXQ9bHQqZ3QtaXQqZHQsanQ9bHQqdXQtbnQqZHQsVXQ9aXQqdXQtbnQqZ3Q7cmV0dXJuIG10KlV0LUV0Kmp0K3l0Kkl0K3B0Kkx0LXh0KkR0K010Kk50fWZ1bmN0aW9uIEModSxNLE4pe3ZhciB6PU1bMF0sSD1NWzFdLFk9TVsyXSxaPU1bM10sZXQ9TVs0XSxydD1NWzVdLG90PU1bNl0sbHQ9TVs3XSxpdD1NWzhdLG50PU1bOV0sYXQ9TVsxMF0sZHQ9TVsxMV0sZ3Q9TVsxMl0sdXQ9TVsxM10sbXQ9TVsxNF0sRXQ9TVsxNV0seXQ9TlswXSxwdD1OWzFdLHh0PU5bMl0sTXQ9TlszXTtyZXR1cm4gdVswXT15dCp6K3B0KmV0K3h0Kml0K010Kmd0LHVbMV09eXQqSCtwdCpydCt4dCpudCtNdCp1dCx1WzJdPXl0KlkrcHQqb3QreHQqYXQrTXQqbXQsdVszXT15dCpaK3B0Kmx0K3h0KmR0K010KkV0LHl0PU5bNF0scHQ9Tls1XSx4dD1OWzZdLE10PU5bN10sdVs0XT15dCp6K3B0KmV0K3h0Kml0K010Kmd0LHVbNV09eXQqSCtwdCpydCt4dCpudCtNdCp1dCx1WzZdPXl0KlkrcHQqb3QreHQqYXQrTXQqbXQsdVs3XT15dCpaK3B0Kmx0K3h0KmR0K010KkV0LHl0PU5bOF0scHQ9Tls5XSx4dD1OWzEwXSxNdD1OWzExXSx1WzhdPXl0KnorcHQqZXQreHQqaXQrTXQqZ3QsdVs5XT15dCpIK3B0KnJ0K3h0Km50K010KnV0LHVbMTBdPXl0KlkrcHQqb3QreHQqYXQrTXQqbXQsdVsxMV09eXQqWitwdCpsdCt4dCpkdCtNdCpFdCx5dD1OWzEyXSxwdD1OWzEzXSx4dD1OWzE0XSxNdD1OWzE1XSx1WzEyXT15dCp6K3B0KmV0K3h0Kml0K010Kmd0LHVbMTNdPXl0KkgrcHQqcnQreHQqbnQrTXQqdXQsdVsxNF09eXQqWStwdCpvdCt4dCphdCtNdCptdCx1WzE1XT15dCpaK3B0Kmx0K3h0KmR0K010KkV0LHV9ZnVuY3Rpb24geCh1LE0sTil7dmFyIHo9TlswXSxIPU5bMV0sWT1OWzJdLFosZXQscnQsb3QsbHQsaXQsbnQsYXQsZHQsZ3QsdXQsbXQ7cmV0dXJuIE09PT11Pyh1WzEyXT1NWzBdKnorTVs0XSpIK01bOF0qWStNWzEyXSx1WzEzXT1NWzFdKnorTVs1XSpIK01bOV0qWStNWzEzXSx1WzE0XT1NWzJdKnorTVs2XSpIK01bMTBdKlkrTVsxNF0sdVsxNV09TVszXSp6K01bN10qSCtNWzExXSpZK01bMTVdKTooWj1NWzBdLGV0PU1bMV0scnQ9TVsyXSxvdD1NWzNdLGx0PU1bNF0saXQ9TVs1XSxudD1NWzZdLGF0PU1bN10sZHQ9TVs4XSxndD1NWzldLHV0PU1bMTBdLG10PU1bMTFdLHVbMF09Wix1WzFdPWV0LHVbMl09cnQsdVszXT1vdCx1WzRdPWx0LHVbNV09aXQsdVs2XT1udCx1WzddPWF0LHVbOF09ZHQsdVs5XT1ndCx1WzEwXT11dCx1WzExXT1tdCx1WzEyXT1aKnorbHQqSCtkdCpZK01bMTJdLHVbMTNdPWV0KnoraXQqSCtndCpZK01bMTNdLHVbMTRdPXJ0KnorbnQqSCt1dCpZK01bMTRdLHVbMTVdPW90KnorYXQqSCttdCpZK01bMTVdKSx1fWZ1bmN0aW9uIGQodSxNLE4pe3ZhciB6PU5bMF0sSD1OWzFdLFk9TlsyXTtyZXR1cm4gdVswXT1NWzBdKnosdVsxXT1NWzFdKnosdVsyXT1NWzJdKnosdVszXT1NWzNdKnosdVs0XT1NWzRdKkgsdVs1XT1NWzVdKkgsdVs2XT1NWzZdKkgsdVs3XT1NWzddKkgsdVs4XT1NWzhdKlksdVs5XT1NWzldKlksdVsxMF09TVsxMF0qWSx1WzExXT1NWzExXSpZLHVbMTJdPU1bMTJdLHVbMTNdPU1bMTNdLHVbMTRdPU1bMTRdLHVbMTVdPU1bMTVdLHV9ZnVuY3Rpb24geSh1LE0sTix6KXt2YXIgSD16WzBdLFk9elsxXSxaPXpbMl0sZXQ9TWF0aC5oeXBvdChILFksWikscnQsb3QsbHQsaXQsbnQsYXQsZHQsZ3QsdXQsbXQsRXQseXQscHQseHQsTXQsTnQsRHQsTHQsSXQsanQsVXQsRnQsT3QsV3Q7cmV0dXJuIGV0PGkuRVBTSUxPTj9udWxsOihldD0xL2V0LEgqPWV0LFkqPWV0LFoqPWV0LHJ0PU1hdGguc2luKE4pLG90PU1hdGguY29zKE4pLGx0PTEtb3QsaXQ9TVswXSxudD1NWzFdLGF0PU1bMl0sZHQ9TVszXSxndD1NWzRdLHV0PU1bNV0sbXQ9TVs2XSxFdD1NWzddLHl0PU1bOF0scHQ9TVs5XSx4dD1NWzEwXSxNdD1NWzExXSxOdD1IKkgqbHQrb3QsRHQ9WSpIKmx0K1oqcnQsTHQ9WipIKmx0LVkqcnQsSXQ9SCpZKmx0LVoqcnQsanQ9WSpZKmx0K290LFV0PVoqWSpsdCtIKnJ0LEZ0PUgqWipsdCtZKnJ0LE90PVkqWipsdC1IKnJ0LFd0PVoqWipsdCtvdCx1WzBdPWl0Kk50K2d0KkR0K3l0Kkx0LHVbMV09bnQqTnQrdXQqRHQrcHQqTHQsdVsyXT1hdCpOdCttdCpEdCt4dCpMdCx1WzNdPWR0Kk50K0V0KkR0K010Kkx0LHVbNF09aXQqSXQrZ3QqanQreXQqVXQsdVs1XT1udCpJdCt1dCpqdCtwdCpVdCx1WzZdPWF0Kkl0K210Kmp0K3h0KlV0LHVbN109ZHQqSXQrRXQqanQrTXQqVXQsdVs4XT1pdCpGdCtndCpPdCt5dCpXdCx1WzldPW50KkZ0K3V0Kk90K3B0Kld0LHVbMTBdPWF0KkZ0K210Kk90K3h0Kld0LHVbMTFdPWR0KkZ0K0V0Kk90K010Kld0LE0hPT11JiYodVsxMl09TVsxMl0sdVsxM109TVsxM10sdVsxNF09TVsxNF0sdVsxNV09TVsxNV0pLHUpfWZ1bmN0aW9uIHIodSxNLE4pe3ZhciB6PU1hdGguc2luKE4pLEg9TWF0aC5jb3MoTiksWT1NWzRdLFo9TVs1XSxldD1NWzZdLHJ0PU1bN10sb3Q9TVs4XSxsdD1NWzldLGl0PU1bMTBdLG50PU1bMTFdO3JldHVybiBNIT09dSYmKHVbMF09TVswXSx1WzFdPU1bMV0sdVsyXT1NWzJdLHVbM109TVszXSx1WzEyXT1NWzEyXSx1WzEzXT1NWzEzXSx1WzE0XT1NWzE0XSx1WzE1XT1NWzE1XSksdVs0XT1ZKkgrb3Qqeix1WzVdPVoqSCtsdCp6LHVbNl09ZXQqSCtpdCp6LHVbN109cnQqSCtudCp6LHVbOF09b3QqSC1ZKnosdVs5XT1sdCpILVoqeix1WzEwXT1pdCpILWV0KnosdVsxMV09bnQqSC1ydCp6LHV9ZnVuY3Rpb24gcyh1LE0sTil7dmFyIHo9TWF0aC5zaW4oTiksSD1NYXRoLmNvcyhOKSxZPU1bMF0sWj1NWzFdLGV0PU1bMl0scnQ9TVszXSxvdD1NWzhdLGx0PU1bOV0saXQ9TVsxMF0sbnQ9TVsxMV07cmV0dXJuIE0hPT11JiYodVs0XT1NWzRdLHVbNV09TVs1XSx1WzZdPU1bNl0sdVs3XT1NWzddLHVbMTJdPU1bMTJdLHVbMTNdPU1bMTNdLHVbMTRdPU1bMTRdLHVbMTVdPU1bMTVdKSx1WzBdPVkqSC1vdCp6LHVbMV09WipILWx0KnosdVsyXT1ldCpILWl0KnosdVszXT1ydCpILW50KnosdVs4XT1ZKnorb3QqSCx1WzldPVoqeitsdCpILHVbMTBdPWV0KnoraXQqSCx1WzExXT1ydCp6K250KkgsdX1mdW5jdGlvbiBuKHUsTSxOKXt2YXIgej1NYXRoLnNpbihOKSxIPU1hdGguY29zKE4pLFk9TVswXSxaPU1bMV0sZXQ9TVsyXSxydD1NWzNdLG90PU1bNF0sbHQ9TVs1XSxpdD1NWzZdLG50PU1bN107cmV0dXJuIE0hPT11JiYodVs4XT1NWzhdLHVbOV09TVs5XSx1WzEwXT1NWzEwXSx1WzExXT1NWzExXSx1WzEyXT1NWzEyXSx1WzEzXT1NWzEzXSx1WzE0XT1NWzE0XSx1WzE1XT1NWzE1XSksdVswXT1ZKkgrb3Qqeix1WzFdPVoqSCtsdCp6LHVbMl09ZXQqSCtpdCp6LHVbM109cnQqSCtudCp6LHVbNF09b3QqSC1ZKnosdVs1XT1sdCpILVoqeix1WzZdPWl0KkgtZXQqeix1WzddPW50KkgtcnQqeix1fWZ1bmN0aW9uIGEodSxNKXtyZXR1cm4gdVswXT0xLHVbMV09MCx1WzJdPTAsdVszXT0wLHVbNF09MCx1WzVdPTEsdVs2XT0wLHVbN109MCx1WzhdPTAsdVs5XT0wLHVbMTBdPTEsdVsxMV09MCx1WzEyXT1NWzBdLHVbMTNdPU1bMV0sdVsxNF09TVsyXSx1WzE1XT0xLHV9ZnVuY3Rpb24gTyh1LE0pe3JldHVybiB1WzBdPU1bMF0sdVsxXT0wLHVbMl09MCx1WzNdPTAsdVs0XT0wLHVbNV09TVsxXSx1WzZdPTAsdVs3XT0wLHVbOF09MCx1WzldPTAsdVsxMF09TVsyXSx1WzExXT0wLHVbMTJdPTAsdVsxM109MCx1WzE0XT0wLHVbMTVdPTEsdX1mdW5jdGlvbiBBKHUsTSxOKXt2YXIgej1OWzBdLEg9TlsxXSxZPU5bMl0sWj1NYXRoLmh5cG90KHosSCxZKSxldCxydCxvdDtyZXR1cm4gWjxpLkVQU0lMT04/bnVsbDooWj0xL1oseio9WixIKj1aLFkqPVosZXQ9TWF0aC5zaW4oTSkscnQ9TWF0aC5jb3MoTSksb3Q9MS1ydCx1WzBdPXoqeipvdCtydCx1WzFdPUgqeipvdCtZKmV0LHVbMl09WSp6Km90LUgqZXQsdVszXT0wLHVbNF09eipIKm90LVkqZXQsdVs1XT1IKkgqb3QrcnQsdVs2XT1ZKkgqb3QreipldCx1WzddPTAsdVs4XT16Klkqb3QrSCpldCx1WzldPUgqWSpvdC16KmV0LHVbMTBdPVkqWSpvdCtydCx1WzExXT0wLHVbMTJdPTAsdVsxM109MCx1WzE0XT0wLHVbMTVdPTEsdSl9ZnVuY3Rpb24gYih1LE0pe3ZhciBOPU1hdGguc2luKE0pLHo9TWF0aC5jb3MoTSk7cmV0dXJuIHVbMF09MSx1WzFdPTAsdVsyXT0wLHVbM109MCx1WzRdPTAsdVs1XT16LHVbNl09Tix1WzddPTAsdVs4XT0wLHVbOV09LU4sdVsxMF09eix1WzExXT0wLHVbMTJdPTAsdVsxM109MCx1WzE0XT0wLHVbMTVdPTEsdX1mdW5jdGlvbiBJKHUsTSl7dmFyIE49TWF0aC5zaW4oTSksej1NYXRoLmNvcyhNKTtyZXR1cm4gdVswXT16LHVbMV09MCx1WzJdPS1OLHVbM109MCx1WzRdPTAsdVs1XT0xLHVbNl09MCx1WzddPTAsdVs4XT1OLHVbOV09MCx1WzEwXT16LHVbMTFdPTAsdVsxMl09MCx1WzEzXT0wLHVbMTRdPTAsdVsxNV09MSx1fWZ1bmN0aW9uIFAodSxNKXt2YXIgTj1NYXRoLnNpbihNKSx6PU1hdGguY29zKE0pO3JldHVybiB1WzBdPXosdVsxXT1OLHVbMl09MCx1WzNdPTAsdVs0XT0tTix1WzVdPXosdVs2XT0wLHVbN109MCx1WzhdPTAsdVs5XT0wLHVbMTBdPTEsdVsxMV09MCx1WzEyXT0wLHVbMTNdPTAsdVsxNF09MCx1WzE1XT0xLHV9ZnVuY3Rpb24gRCh1LE0sTil7dmFyIHo9TVswXSxIPU1bMV0sWT1NWzJdLFo9TVszXSxldD16K3oscnQ9SCtILG90PVkrWSxsdD16KmV0LGl0PXoqcnQsbnQ9eipvdCxhdD1IKnJ0LGR0PUgqb3QsZ3Q9WSpvdCx1dD1aKmV0LG10PVoqcnQsRXQ9WipvdDtyZXR1cm4gdVswXT0xLShhdCtndCksdVsxXT1pdCtFdCx1WzJdPW50LW10LHVbM109MCx1WzRdPWl0LUV0LHVbNV09MS0obHQrZ3QpLHVbNl09ZHQrdXQsdVs3XT0wLHVbOF09bnQrbXQsdVs5XT1kdC11dCx1WzEwXT0xLShsdCthdCksdVsxMV09MCx1WzEyXT1OWzBdLHVbMTNdPU5bMV0sdVsxNF09TlsyXSx1WzE1XT0xLHV9ZnVuY3Rpb24gTCh1LE0pe3ZhciBOPW5ldyBpLkFSUkFZX1RZUEUoMyksej0tTVswXSxIPS1NWzFdLFk9LU1bMl0sWj1NWzNdLGV0PU1bNF0scnQ9TVs1XSxvdD1NWzZdLGx0PU1bN10saXQ9eip6K0gqSCtZKlkrWipaO3JldHVybiBpdD4wPyhOWzBdPShldCpaK2x0KnorcnQqWS1vdCpIKSoyL2l0LE5bMV09KHJ0KlorbHQqSCtvdCp6LWV0KlkpKjIvaXQsTlsyXT0ob3QqWitsdCpZK2V0KkgtcnQqeikqMi9pdCk6KE5bMF09KGV0KlorbHQqeitydCpZLW90KkgpKjIsTlsxXT0ocnQqWitsdCpIK290KnotZXQqWSkqMixOWzJdPShvdCpaK2x0KlkrZXQqSC1ydCp6KSoyKSxEKHUsTSxOKSx1fWZ1bmN0aW9uIFModSxNKXtyZXR1cm4gdVswXT1NWzEyXSx1WzFdPU1bMTNdLHVbMl09TVsxNF0sdX1mdW5jdGlvbiBUKHUsTSl7dmFyIE49TVswXSx6PU1bMV0sSD1NWzJdLFk9TVs0XSxaPU1bNV0sZXQ9TVs2XSxydD1NWzhdLG90PU1bOV0sbHQ9TVsxMF07cmV0dXJuIHVbMF09TWF0aC5oeXBvdChOLHosSCksdVsxXT1NYXRoLmh5cG90KFksWixldCksdVsyXT1NYXRoLmh5cG90KHJ0LG90LGx0KSx1fWZ1bmN0aW9uIGoodSxNKXt2YXIgTj1uZXcgaS5BUlJBWV9UWVBFKDMpO1QoTixNKTt2YXIgej0xL05bMF0sSD0xL05bMV0sWT0xL05bMl0sWj1NWzBdKnosZXQ9TVsxXSpILHJ0PU1bMl0qWSxvdD1NWzRdKnosbHQ9TVs1XSpILGl0PU1bNl0qWSxudD1NWzhdKnosYXQ9TVs5XSpILGR0PU1bMTBdKlksZ3Q9WitsdCtkdCx1dD0wO3JldHVybiBndD4wPyh1dD1NYXRoLnNxcnQoZ3QrMSkqMix1WzNdPS4yNSp1dCx1WzBdPShpdC1hdCkvdXQsdVsxXT0obnQtcnQpL3V0LHVbMl09KGV0LW90KS91dCk6Wj5sdCYmWj5kdD8odXQ9TWF0aC5zcXJ0KDErWi1sdC1kdCkqMix1WzNdPShpdC1hdCkvdXQsdVswXT0uMjUqdXQsdVsxXT0oZXQrb3QpL3V0LHVbMl09KG50K3J0KS91dCk6bHQ+ZHQ/KHV0PU1hdGguc3FydCgxK2x0LVotZHQpKjIsdVszXT0obnQtcnQpL3V0LHVbMF09KGV0K290KS91dCx1WzFdPS4yNSp1dCx1WzJdPShpdCthdCkvdXQpOih1dD1NYXRoLnNxcnQoMStkdC1aLWx0KSoyLHVbM109KGV0LW90KS91dCx1WzBdPShudCtydCkvdXQsdVsxXT0oaXQrYXQpL3V0LHVbMl09LjI1KnV0KSx1fWZ1bmN0aW9uICQodSxNLE4seil7dmFyIEg9TVswXSxZPU1bMV0sWj1NWzJdLGV0PU1bM10scnQ9SCtILG90PVkrWSxsdD1aK1osaXQ9SCpydCxudD1IKm90LGF0PUgqbHQsZHQ9WSpvdCxndD1ZKmx0LHV0PVoqbHQsbXQ9ZXQqcnQsRXQ9ZXQqb3QseXQ9ZXQqbHQscHQ9elswXSx4dD16WzFdLE10PXpbMl07cmV0dXJuIHVbMF09KDEtKGR0K3V0KSkqcHQsdVsxXT0obnQreXQpKnB0LHVbMl09KGF0LUV0KSpwdCx1WzNdPTAsdVs0XT0obnQteXQpKnh0LHVbNV09KDEtKGl0K3V0KSkqeHQsdVs2XT0oZ3QrbXQpKnh0LHVbN109MCx1WzhdPShhdCtFdCkqTXQsdVs5XT0oZ3QtbXQpKk10LHVbMTBdPSgxLShpdCtkdCkpKk10LHVbMTFdPTAsdVsxMl09TlswXSx1WzEzXT1OWzFdLHVbMTRdPU5bMl0sdVsxNV09MSx1fWZ1bmN0aW9uIHcodSxNLE4seixIKXt2YXIgWT1NWzBdLFo9TVsxXSxldD1NWzJdLHJ0PU1bM10sb3Q9WStZLGx0PVorWixpdD1ldCtldCxudD1ZKm90LGF0PVkqbHQsZHQ9WSppdCxndD1aKmx0LHV0PVoqaXQsbXQ9ZXQqaXQsRXQ9cnQqb3QseXQ9cnQqbHQscHQ9cnQqaXQseHQ9elswXSxNdD16WzFdLE50PXpbMl0sRHQ9SFswXSxMdD1IWzFdLEl0PUhbMl0sanQ9KDEtKGd0K210KSkqeHQsVXQ9KGF0K3B0KSp4dCxGdD0oZHQteXQpKnh0LE90PShhdC1wdCkqTXQsV3Q9KDEtKG50K210KSkqTXQsWnQ9KHV0K0V0KSpNdCxxdD0oZHQreXQpKk50LHZlPSh1dC1FdCkqTnQseWU9KDEtKG50K2d0KSkqTnQ7cmV0dXJuIHVbMF09anQsdVsxXT1VdCx1WzJdPUZ0LHVbM109MCx1WzRdPU90LHVbNV09V3QsdVs2XT1adCx1WzddPTAsdVs4XT1xdCx1WzldPXZlLHVbMTBdPXllLHVbMTFdPTAsdVsxMl09TlswXStEdC0oanQqRHQrT3QqTHQrcXQqSXQpLHVbMTNdPU5bMV0rTHQtKFV0KkR0K1d0Kkx0K3ZlKkl0KSx1WzE0XT1OWzJdK0l0LShGdCpEdCtadCpMdCt5ZSpJdCksdVsxNV09MSx1fWZ1bmN0aW9uIEoodSxNKXt2YXIgTj1NWzBdLHo9TVsxXSxIPU1bMl0sWT1NWzNdLFo9TitOLGV0PXoreixydD1IK0gsb3Q9TipaLGx0PXoqWixpdD16KmV0LG50PUgqWixhdD1IKmV0LGR0PUgqcnQsZ3Q9WSpaLHV0PVkqZXQsbXQ9WSpydDtyZXR1cm4gdVswXT0xLWl0LWR0LHVbMV09bHQrbXQsdVsyXT1udC11dCx1WzNdPTAsdVs0XT1sdC1tdCx1WzVdPTEtb3QtZHQsdVs2XT1hdCtndCx1WzddPTAsdVs4XT1udCt1dCx1WzldPWF0LWd0LHVbMTBdPTEtb3QtaXQsdVsxMV09MCx1WzEyXT0wLHVbMTNdPTAsdVsxNF09MCx1WzE1XT0xLHV9ZnVuY3Rpb24gcSh1LE0sTix6LEgsWSxaKXt2YXIgZXQ9MS8oTi1NKSxydD0xLyhILXopLG90PTEvKFktWik7cmV0dXJuIHVbMF09WSoyKmV0LHVbMV09MCx1WzJdPTAsdVszXT0wLHVbNF09MCx1WzVdPVkqMipydCx1WzZdPTAsdVs3XT0wLHVbOF09KE4rTSkqZXQsdVs5XT0oSCt6KSpydCx1WzEwXT0oWitZKSpvdCx1WzExXT0tMSx1WzEyXT0wLHVbMTNdPTAsdVsxNF09WipZKjIqb3QsdVsxNV09MCx1fWZ1bmN0aW9uIFcodSxNLE4seixIKXt2YXIgWT0xL01hdGgudGFuKE0vMiksWjtyZXR1cm4gdVswXT1ZL04sdVsxXT0wLHVbMl09MCx1WzNdPTAsdVs0XT0wLHVbNV09WSx1WzZdPTAsdVs3XT0wLHVbOF09MCx1WzldPTAsdVsxMV09LTEsdVsxMl09MCx1WzEzXT0wLHVbMTVdPTAsSCE9bnVsbCYmSCE9PTEvMD8oWj0xLyh6LUgpLHVbMTBdPShIK3opKlosdVsxNF09MipIKnoqWik6KHVbMTBdPS0xLHVbMTRdPS0yKnopLHV9ZnVuY3Rpb24gSyh1LE0sTix6KXt2YXIgSD1NYXRoLnRhbihNLnVwRGVncmVlcypNYXRoLlBJLzE4MCksWT1NYXRoLnRhbihNLmRvd25EZWdyZWVzKk1hdGguUEkvMTgwKSxaPU1hdGgudGFuKE0ubGVmdERlZ3JlZXMqTWF0aC5QSS8xODApLGV0PU1hdGgudGFuKE0ucmlnaHREZWdyZWVzKk1hdGguUEkvMTgwKSxydD0yLyhaK2V0KSxvdD0yLyhIK1kpO3JldHVybiB1WzBdPXJ0LHVbMV09MCx1WzJdPTAsdVszXT0wLHVbNF09MCx1WzVdPW90LHVbNl09MCx1WzddPTAsdVs4XT0tKChaLWV0KSpydCouNSksdVs5XT0oSC1ZKSpvdCouNSx1WzEwXT16LyhOLXopLHVbMTFdPS0xLHVbMTJdPTAsdVsxM109MCx1WzE0XT16Kk4vKE4teiksdVsxNV09MCx1fWZ1bmN0aW9uIFEodSxNLE4seixILFksWil7dmFyIGV0PTEvKE0tTikscnQ9MS8oei1IKSxvdD0xLyhZLVopO3JldHVybiB1WzBdPS0yKmV0LHVbMV09MCx1WzJdPTAsdVszXT0wLHVbNF09MCx1WzVdPS0yKnJ0LHVbNl09MCx1WzddPTAsdVs4XT0wLHVbOV09MCx1WzEwXT0yKm90LHVbMTFdPTAsdVsxMl09KE0rTikqZXQsdVsxM109KEgreikqcnQsdVsxNF09KForWSkqb3QsdVsxNV09MSx1fWZ1bmN0aW9uIHR0KHUsTSxOLHope3ZhciBILFksWixldCxydCxvdCxsdCxpdCxudCxhdCxkdD1NWzBdLGd0PU1bMV0sdXQ9TVsyXSxtdD16WzBdLEV0PXpbMV0seXQ9elsyXSxwdD1OWzBdLHh0PU5bMV0sTXQ9TlsyXTtyZXR1cm4gTWF0aC5hYnMoZHQtcHQpPGkuRVBTSUxPTiYmTWF0aC5hYnMoZ3QteHQpPGkuRVBTSUxPTiYmTWF0aC5hYnModXQtTXQpPGkuRVBTSUxPTj9oKHUpOihsdD1kdC1wdCxpdD1ndC14dCxudD11dC1NdCxhdD0xL01hdGguaHlwb3QobHQsaXQsbnQpLGx0Kj1hdCxpdCo9YXQsbnQqPWF0LEg9RXQqbnQteXQqaXQsWT15dCpsdC1tdCpudCxaPW10Kml0LUV0Kmx0LGF0PU1hdGguaHlwb3QoSCxZLFopLGF0PyhhdD0xL2F0LEgqPWF0LFkqPWF0LFoqPWF0KTooSD0wLFk9MCxaPTApLGV0PWl0KlotbnQqWSxydD1udCpILWx0Klosb3Q9bHQqWS1pdCpILGF0PU1hdGguaHlwb3QoZXQscnQsb3QpLGF0PyhhdD0xL2F0LGV0Kj1hdCxydCo9YXQsb3QqPWF0KTooZXQ9MCxydD0wLG90PTApLHVbMF09SCx1WzFdPWV0LHVbMl09bHQsdVszXT0wLHVbNF09WSx1WzVdPXJ0LHVbNl09aXQsdVs3XT0wLHVbOF09Wix1WzldPW90LHVbMTBdPW50LHVbMTFdPTAsdVsxMl09LShIKmR0K1kqZ3QrWip1dCksdVsxM109LShldCpkdCtydCpndCtvdCp1dCksdVsxNF09LShsdCpkdCtpdCpndCtudCp1dCksdVsxNV09MSx1KX1mdW5jdGlvbiBfKHUsTSxOLHope3ZhciBIPU1bMF0sWT1NWzFdLFo9TVsyXSxldD16WzBdLHJ0PXpbMV0sb3Q9elsyXSxsdD1ILU5bMF0saXQ9WS1OWzFdLG50PVotTlsyXSxhdD1sdCpsdCtpdCppdCtudCpudDthdD4wJiYoYXQ9MS9NYXRoLnNxcnQoYXQpLGx0Kj1hdCxpdCo9YXQsbnQqPWF0KTt2YXIgZHQ9cnQqbnQtb3QqaXQsZ3Q9b3QqbHQtZXQqbnQsdXQ9ZXQqaXQtcnQqbHQ7cmV0dXJuIGF0PWR0KmR0K2d0Kmd0K3V0KnV0LGF0PjAmJihhdD0xL01hdGguc3FydChhdCksZHQqPWF0LGd0Kj1hdCx1dCo9YXQpLHVbMF09ZHQsdVsxXT1ndCx1WzJdPXV0LHVbM109MCx1WzRdPWl0KnV0LW50Kmd0LHVbNV09bnQqZHQtbHQqdXQsdVs2XT1sdCpndC1pdCpkdCx1WzddPTAsdVs4XT1sdCx1WzldPWl0LHVbMTBdPW50LHVbMTFdPTAsdVsxMl09SCx1WzEzXT1ZLHVbMTRdPVosdVsxNV09MSx1fWZ1bmN0aW9uIHN0KHUpe3JldHVybiJtYXQ0KCIrdVswXSsiLCAiK3VbMV0rIiwgIit1WzJdKyIsICIrdVszXSsiLCAiK3VbNF0rIiwgIit1WzVdKyIsICIrdVs2XSsiLCAiK3VbN10rIiwgIit1WzhdKyIsICIrdVs5XSsiLCAiK3VbMTBdKyIsICIrdVsxMV0rIiwgIit1WzEyXSsiLCAiK3VbMTNdKyIsICIrdVsxNF0rIiwgIit1WzE1XSsiKSJ9ZnVuY3Rpb24gayh1KXtyZXR1cm4gTWF0aC5oeXBvdCh1WzBdLHVbMV0sdVsyXSx1WzNdLHVbNF0sdVs1XSx1WzZdLHVbN10sdVs4XSx1WzldLHVbMTBdLHVbMTFdLHVbMTJdLHVbMTNdLHVbMTRdLHVbMTVdKX1mdW5jdGlvbiBjdCh1LE0sTil7cmV0dXJuIHVbMF09TVswXStOWzBdLHVbMV09TVsxXStOWzFdLHVbMl09TVsyXStOWzJdLHVbM109TVszXStOWzNdLHVbNF09TVs0XStOWzRdLHVbNV09TVs1XStOWzVdLHVbNl09TVs2XStOWzZdLHVbN109TVs3XStOWzddLHVbOF09TVs4XStOWzhdLHVbOV09TVs5XStOWzldLHVbMTBdPU1bMTBdK05bMTBdLHVbMTFdPU1bMTFdK05bMTFdLHVbMTJdPU1bMTJdK05bMTJdLHVbMTNdPU1bMTNdK05bMTNdLHVbMTRdPU1bMTRdK05bMTRdLHVbMTVdPU1bMTVdK05bMTVdLHV9ZnVuY3Rpb24gZnQodSxNLE4pe3JldHVybiB1WzBdPU1bMF0tTlswXSx1WzFdPU1bMV0tTlsxXSx1WzJdPU1bMl0tTlsyXSx1WzNdPU1bM10tTlszXSx1WzRdPU1bNF0tTls0XSx1WzVdPU1bNV0tTls1XSx1WzZdPU1bNl0tTls2XSx1WzddPU1bN10tTls3XSx1WzhdPU1bOF0tTls4XSx1WzldPU1bOV0tTls5XSx1WzEwXT1NWzEwXS1OWzEwXSx1WzExXT1NWzExXS1OWzExXSx1WzEyXT1NWzEyXS1OWzEyXSx1WzEzXT1NWzEzXS1OWzEzXSx1WzE0XT1NWzE0XS1OWzE0XSx1WzE1XT1NWzE1XS1OWzE1XSx1fWZ1bmN0aW9uIFUodSxNLE4pe3JldHVybiB1WzBdPU1bMF0qTix1WzFdPU1bMV0qTix1WzJdPU1bMl0qTix1WzNdPU1bM10qTix1WzRdPU1bNF0qTix1WzVdPU1bNV0qTix1WzZdPU1bNl0qTix1WzddPU1bN10qTix1WzhdPU1bOF0qTix1WzldPU1bOV0qTix1WzEwXT1NWzEwXSpOLHVbMTFdPU1bMTFdKk4sdVsxMl09TVsxMl0qTix1WzEzXT1NWzEzXSpOLHVbMTRdPU1bMTRdKk4sdVsxNV09TVsxNV0qTix1fWZ1bmN0aW9uIEYodSxNLE4seil7cmV0dXJuIHVbMF09TVswXStOWzBdKnosdVsxXT1NWzFdK05bMV0qeix1WzJdPU1bMl0rTlsyXSp6LHVbM109TVszXStOWzNdKnosdVs0XT1NWzRdK05bNF0qeix1WzVdPU1bNV0rTls1XSp6LHVbNl09TVs2XStOWzZdKnosdVs3XT1NWzddK05bN10qeix1WzhdPU1bOF0rTls4XSp6LHVbOV09TVs5XStOWzldKnosdVsxMF09TVsxMF0rTlsxMF0qeix1WzExXT1NWzExXStOWzExXSp6LHVbMTJdPU1bMTJdK05bMTJdKnosdVsxM109TVsxM10rTlsxM10qeix1WzE0XT1NWzE0XStOWzE0XSp6LHVbMTVdPU1bMTVdK05bMTVdKnosdX1mdW5jdGlvbiBWKHUsTSl7cmV0dXJuIHVbMF09PT1NWzBdJiZ1WzFdPT09TVsxXSYmdVsyXT09PU1bMl0mJnVbM109PT1NWzNdJiZ1WzRdPT09TVs0XSYmdVs1XT09PU1bNV0mJnVbNl09PT1NWzZdJiZ1WzddPT09TVs3XSYmdVs4XT09PU1bOF0mJnVbOV09PT1NWzldJiZ1WzEwXT09PU1bMTBdJiZ1WzExXT09PU1bMTFdJiZ1WzEyXT09PU1bMTJdJiZ1WzEzXT09PU1bMTNdJiZ1WzE0XT09PU1bMTRdJiZ1WzE1XT09PU1bMTVdfWZ1bmN0aW9uIFgodSxNKXt2YXIgTj11WzBdLHo9dVsxXSxIPXVbMl0sWT11WzNdLFo9dVs0XSxldD11WzVdLHJ0PXVbNl0sb3Q9dVs3XSxsdD11WzhdLGl0PXVbOV0sbnQ9dVsxMF0sYXQ9dVsxMV0sZHQ9dVsxMl0sZ3Q9dVsxM10sdXQ9dVsxNF0sbXQ9dVsxNV0sRXQ9TVswXSx5dD1NWzFdLHB0PU1bMl0seHQ9TVszXSxNdD1NWzRdLE50PU1bNV0sRHQ9TVs2XSxMdD1NWzddLEl0PU1bOF0sanQ9TVs5XSxVdD1NWzEwXSxGdD1NWzExXSxPdD1NWzEyXSxXdD1NWzEzXSxadD1NWzE0XSxxdD1NWzE1XTtyZXR1cm4gTWF0aC5hYnMoTi1FdCk8PWkuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKE4pLE1hdGguYWJzKEV0KSkmJk1hdGguYWJzKHoteXQpPD1pLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyh6KSxNYXRoLmFicyh5dCkpJiZNYXRoLmFicyhILXB0KTw9aS5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoSCksTWF0aC5hYnMocHQpKSYmTWF0aC5hYnMoWS14dCk8PWkuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKFkpLE1hdGguYWJzKHh0KSkmJk1hdGguYWJzKFotTXQpPD1pLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhaKSxNYXRoLmFicyhNdCkpJiZNYXRoLmFicyhldC1OdCk8PWkuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKGV0KSxNYXRoLmFicyhOdCkpJiZNYXRoLmFicyhydC1EdCk8PWkuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKHJ0KSxNYXRoLmFicyhEdCkpJiZNYXRoLmFicyhvdC1MdCk8PWkuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKG90KSxNYXRoLmFicyhMdCkpJiZNYXRoLmFicyhsdC1JdCk8PWkuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKGx0KSxNYXRoLmFicyhJdCkpJiZNYXRoLmFicyhpdC1qdCk8PWkuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKGl0KSxNYXRoLmFicyhqdCkpJiZNYXRoLmFicyhudC1VdCk8PWkuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKG50KSxNYXRoLmFicyhVdCkpJiZNYXRoLmFicyhhdC1GdCk8PWkuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKGF0KSxNYXRoLmFicyhGdCkpJiZNYXRoLmFicyhkdC1PdCk8PWkuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKGR0KSxNYXRoLmFicyhPdCkpJiZNYXRoLmFicyhndC1XdCk8PWkuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKGd0KSxNYXRoLmFicyhXdCkpJiZNYXRoLmFicyh1dC1adCk8PWkuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKHV0KSxNYXRoLmFicyhadCkpJiZNYXRoLmFicyhtdC1xdCk8PWkuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKG10KSxNYXRoLmFicyhxdCkpfXZhciBCPUMsRz1mdH0sZnVuY3Rpb24oUixlLHQpe3QucihlKSx0LmQoZSwiY3JlYXRlIixmdW5jdGlvbigpe3JldHVybiBjfSksdC5kKGUsImlkZW50aXR5IixmdW5jdGlvbigpe3JldHVybiBmfSksdC5kKGUsInNldEF4aXNBbmdsZSIsZnVuY3Rpb24oKXtyZXR1cm4gaH0pLHQuZChlLCJnZXRBeGlzQW5nbGUiLGZ1bmN0aW9uKCl7cmV0dXJuIEV9KSx0LmQoZSwiZ2V0QW5nbGUiLGZ1bmN0aW9uKCl7cmV0dXJuIGx9KSx0LmQoZSwibXVsdGlwbHkiLGZ1bmN0aW9uKCl7cmV0dXJuIG19KSx0LmQoZSwicm90YXRlWCIsZnVuY3Rpb24oKXtyZXR1cm4gcH0pLHQuZChlLCJyb3RhdGVZIixmdW5jdGlvbigpe3JldHVybiBDfSksdC5kKGUsInJvdGF0ZVoiLGZ1bmN0aW9uKCl7cmV0dXJuIHh9KSx0LmQoZSwiY2FsY3VsYXRlVyIsZnVuY3Rpb24oKXtyZXR1cm4gZH0pLHQuZChlLCJleHAiLGZ1bmN0aW9uKCl7cmV0dXJuIHl9KSx0LmQoZSwibG4iLGZ1bmN0aW9uKCl7cmV0dXJuIHJ9KSx0LmQoZSwicG93IixmdW5jdGlvbigpe3JldHVybiBzfSksdC5kKGUsInNsZXJwIixmdW5jdGlvbigpe3JldHVybiBufSksdC5kKGUsInJhbmRvbSIsZnVuY3Rpb24oKXtyZXR1cm4gYX0pLHQuZChlLCJpbnZlcnQiLGZ1bmN0aW9uKCl7cmV0dXJuIE99KSx0LmQoZSwiY29uanVnYXRlIixmdW5jdGlvbigpe3JldHVybiBBfSksdC5kKGUsImZyb21NYXQzIixmdW5jdGlvbigpe3JldHVybiBifSksdC5kKGUsImZyb21FdWxlciIsZnVuY3Rpb24oKXtyZXR1cm4gSX0pLHQuZChlLCJzdHIiLGZ1bmN0aW9uKCl7cmV0dXJuIFB9KSx0LmQoZSwiY2xvbmUiLGZ1bmN0aW9uKCl7cmV0dXJuIER9KSx0LmQoZSwiZnJvbVZhbHVlcyIsZnVuY3Rpb24oKXtyZXR1cm4gTH0pLHQuZChlLCJjb3B5IixmdW5jdGlvbigpe3JldHVybiBTfSksdC5kKGUsInNldCIsZnVuY3Rpb24oKXtyZXR1cm4gVH0pLHQuZChlLCJhZGQiLGZ1bmN0aW9uKCl7cmV0dXJuIGp9KSx0LmQoZSwibXVsIixmdW5jdGlvbigpe3JldHVybiAkfSksdC5kKGUsInNjYWxlIixmdW5jdGlvbigpe3JldHVybiB3fSksdC5kKGUsImRvdCIsZnVuY3Rpb24oKXtyZXR1cm4gSn0pLHQuZChlLCJsZXJwIixmdW5jdGlvbigpe3JldHVybiBxfSksdC5kKGUsImxlbmd0aCIsZnVuY3Rpb24oKXtyZXR1cm4gV30pLHQuZChlLCJsZW4iLGZ1bmN0aW9uKCl7cmV0dXJuIEt9KSx0LmQoZSwic3F1YXJlZExlbmd0aCIsZnVuY3Rpb24oKXtyZXR1cm4gUX0pLHQuZChlLCJzcXJMZW4iLGZ1bmN0aW9uKCl7cmV0dXJuIHR0fSksdC5kKGUsIm5vcm1hbGl6ZSIsZnVuY3Rpb24oKXtyZXR1cm4gX30pLHQuZChlLCJleGFjdEVxdWFscyIsZnVuY3Rpb24oKXtyZXR1cm4gc3R9KSx0LmQoZSwiZXF1YWxzIixmdW5jdGlvbigpe3JldHVybiBrfSksdC5kKGUsInJvdGF0aW9uVG8iLGZ1bmN0aW9uKCl7cmV0dXJuIGN0fSksdC5kKGUsInNxbGVycCIsZnVuY3Rpb24oKXtyZXR1cm4gZnR9KSx0LmQoZSwic2V0QXhlcyIsZnVuY3Rpb24oKXtyZXR1cm4gVX0pO3ZhciBpPXQoMiksbz10KDUpLGc9dCg4KSx2PXQoOSk7ZnVuY3Rpb24gYygpe3ZhciBGPW5ldyBpLkFSUkFZX1RZUEUoNCk7cmV0dXJuIGkuQVJSQVlfVFlQRSE9RmxvYXQzMkFycmF5JiYoRlswXT0wLEZbMV09MCxGWzJdPTApLEZbM109MSxGfWZ1bmN0aW9uIGYoRil7cmV0dXJuIEZbMF09MCxGWzFdPTAsRlsyXT0wLEZbM109MSxGfWZ1bmN0aW9uIGgoRixWLFgpe1g9WCouNTt2YXIgQj1NYXRoLnNpbihYKTtyZXR1cm4gRlswXT1CKlZbMF0sRlsxXT1CKlZbMV0sRlsyXT1CKlZbMl0sRlszXT1NYXRoLmNvcyhYKSxGfWZ1bmN0aW9uIEUoRixWKXt2YXIgWD1NYXRoLmFjb3MoVlszXSkqMixCPU1hdGguc2luKFgvMik7cmV0dXJuIEI+aS5FUFNJTE9OPyhGWzBdPVZbMF0vQixGWzFdPVZbMV0vQixGWzJdPVZbMl0vQik6KEZbMF09MSxGWzFdPTAsRlsyXT0wKSxYfWZ1bmN0aW9uIGwoRixWKXt2YXIgWD1KKEYsVik7cmV0dXJuIE1hdGguYWNvcygyKlgqWC0xKX1mdW5jdGlvbiBtKEYsVixYKXt2YXIgQj1WWzBdLEc9VlsxXSx1PVZbMl0sTT1WWzNdLE49WFswXSx6PVhbMV0sSD1YWzJdLFk9WFszXTtyZXR1cm4gRlswXT1CKlkrTSpOK0cqSC11KnosRlsxXT1HKlkrTSp6K3UqTi1CKkgsRlsyXT11KlkrTSpIK0Iqei1HKk4sRlszXT1NKlktQipOLUcqei11KkgsRn1mdW5jdGlvbiBwKEYsVixYKXtYKj0uNTt2YXIgQj1WWzBdLEc9VlsxXSx1PVZbMl0sTT1WWzNdLE49TWF0aC5zaW4oWCksej1NYXRoLmNvcyhYKTtyZXR1cm4gRlswXT1CKnorTSpOLEZbMV09Ryp6K3UqTixGWzJdPXUqei1HKk4sRlszXT1NKnotQipOLEZ9ZnVuY3Rpb24gQyhGLFYsWCl7WCo9LjU7dmFyIEI9VlswXSxHPVZbMV0sdT1WWzJdLE09VlszXSxOPU1hdGguc2luKFgpLHo9TWF0aC5jb3MoWCk7cmV0dXJuIEZbMF09Qip6LXUqTixGWzFdPUcqeitNKk4sRlsyXT11KnorQipOLEZbM109TSp6LUcqTixGfWZ1bmN0aW9uIHgoRixWLFgpe1gqPS41O3ZhciBCPVZbMF0sRz1WWzFdLHU9VlsyXSxNPVZbM10sTj1NYXRoLnNpbihYKSx6PU1hdGguY29zKFgpO3JldHVybiBGWzBdPUIqeitHKk4sRlsxXT1HKnotQipOLEZbMl09dSp6K00qTixGWzNdPU0qei11Kk4sRn1mdW5jdGlvbiBkKEYsVil7dmFyIFg9VlswXSxCPVZbMV0sRz1WWzJdO3JldHVybiBGWzBdPVgsRlsxXT1CLEZbMl09RyxGWzNdPU1hdGguc3FydChNYXRoLmFicygxLVgqWC1CKkItRypHKSksRn1mdW5jdGlvbiB5KEYsVil7dmFyIFg9VlswXSxCPVZbMV0sRz1WWzJdLHU9VlszXSxNPU1hdGguc3FydChYKlgrQipCK0cqRyksTj1NYXRoLmV4cCh1KSx6PU0+MD9OKk1hdGguc2luKE0pL006MDtyZXR1cm4gRlswXT1YKnosRlsxXT1CKnosRlsyXT1HKnosRlszXT1OKk1hdGguY29zKE0pLEZ9ZnVuY3Rpb24gcihGLFYpe3ZhciBYPVZbMF0sQj1WWzFdLEc9VlsyXSx1PVZbM10sTT1NYXRoLnNxcnQoWCpYK0IqQitHKkcpLE49TT4wP01hdGguYXRhbjIoTSx1KS9NOjA7cmV0dXJuIEZbMF09WCpOLEZbMV09QipOLEZbMl09RypOLEZbM109LjUqTWF0aC5sb2coWCpYK0IqQitHKkcrdSp1KSxGfWZ1bmN0aW9uIHMoRixWLFgpe3JldHVybiByKEYsViksdyhGLEYsWCkseShGLEYpLEZ9ZnVuY3Rpb24gbihGLFYsWCxCKXt2YXIgRz1WWzBdLHU9VlsxXSxNPVZbMl0sTj1WWzNdLHo9WFswXSxIPVhbMV0sWT1YWzJdLFo9WFszXSxldCxydCxvdCxsdCxpdDtyZXR1cm4gcnQ9Ryp6K3UqSCtNKlkrTipaLHJ0PDAmJihydD0tcnQsej0teixIPS1ILFk9LVksWj0tWiksMS1ydD5pLkVQU0lMT04/KGV0PU1hdGguYWNvcyhydCksb3Q9TWF0aC5zaW4oZXQpLGx0PU1hdGguc2luKCgxLUIpKmV0KS9vdCxpdD1NYXRoLnNpbihCKmV0KS9vdCk6KGx0PTEtQixpdD1CKSxGWzBdPWx0KkcraXQqeixGWzFdPWx0KnUraXQqSCxGWzJdPWx0Kk0raXQqWSxGWzNdPWx0Kk4raXQqWixGfWZ1bmN0aW9uIGEoRil7dmFyIFY9aS5SQU5ET00oKSxYPWkuUkFORE9NKCksQj1pLlJBTkRPTSgpLEc9TWF0aC5zcXJ0KDEtViksdT1NYXRoLnNxcnQoVik7cmV0dXJuIEZbMF09RypNYXRoLnNpbigyKk1hdGguUEkqWCksRlsxXT1HKk1hdGguY29zKDIqTWF0aC5QSSpYKSxGWzJdPXUqTWF0aC5zaW4oMipNYXRoLlBJKkIpLEZbM109dSpNYXRoLmNvcygyKk1hdGguUEkqQiksRn1mdW5jdGlvbiBPKEYsVil7dmFyIFg9VlswXSxCPVZbMV0sRz1WWzJdLHU9VlszXSxNPVgqWCtCKkIrRypHK3UqdSxOPU0/MS9NOjA7cmV0dXJuIEZbMF09LVgqTixGWzFdPS1CKk4sRlsyXT0tRypOLEZbM109dSpOLEZ9ZnVuY3Rpb24gQShGLFYpe3JldHVybiBGWzBdPS1WWzBdLEZbMV09LVZbMV0sRlsyXT0tVlsyXSxGWzNdPVZbM10sRn1mdW5jdGlvbiBiKEYsVil7dmFyIFg9VlswXStWWzRdK1ZbOF0sQjtpZihYPjApQj1NYXRoLnNxcnQoWCsxKSxGWzNdPS41KkIsQj0uNS9CLEZbMF09KFZbNV0tVls3XSkqQixGWzFdPShWWzZdLVZbMl0pKkIsRlsyXT0oVlsxXS1WWzNdKSpCO2Vsc2V7dmFyIEc9MDtWWzRdPlZbMF0mJihHPTEpLFZbOF0+VltHKjMrR10mJihHPTIpO3ZhciB1PShHKzEpJTMsTT0oRysyKSUzO0I9TWF0aC5zcXJ0KFZbRyozK0ddLVZbdSozK3VdLVZbTSozK01dKzEpLEZbR109LjUqQixCPS41L0IsRlszXT0oVlt1KjMrTV0tVltNKjMrdV0pKkIsRlt1XT0oVlt1KjMrR10rVltHKjMrdV0pKkIsRltNXT0oVltNKjMrR10rVltHKjMrTV0pKkJ9cmV0dXJuIEZ9ZnVuY3Rpb24gSShGLFYsWCxCKXt2YXIgRz0uNSpNYXRoLlBJLzE4MDtWKj1HLFgqPUcsQio9Rzt2YXIgdT1NYXRoLnNpbihWKSxNPU1hdGguY29zKFYpLE49TWF0aC5zaW4oWCksej1NYXRoLmNvcyhYKSxIPU1hdGguc2luKEIpLFk9TWF0aC5jb3MoQik7cmV0dXJuIEZbMF09dSp6KlktTSpOKkgsRlsxXT1NKk4qWSt1KnoqSCxGWzJdPU0qeipILXUqTipZLEZbM109TSp6KlkrdSpOKkgsRn1mdW5jdGlvbiBQKEYpe3JldHVybiJxdWF0KCIrRlswXSsiLCAiK0ZbMV0rIiwgIitGWzJdKyIsICIrRlszXSsiKSJ9dmFyIEQ9di5jbG9uZSxMPXYuZnJvbVZhbHVlcyxTPXYuY29weSxUPXYuc2V0LGo9di5hZGQsJD1tLHc9di5zY2FsZSxKPXYuZG90LHE9di5sZXJwLFc9di5sZW5ndGgsSz1XLFE9di5zcXVhcmVkTGVuZ3RoLHR0PVEsXz12Lm5vcm1hbGl6ZSxzdD12LmV4YWN0RXF1YWxzLGs9di5lcXVhbHMsY3Q9ZnVuY3Rpb24oKXt2YXIgRj1nLmNyZWF0ZSgpLFY9Zy5mcm9tVmFsdWVzKDEsMCwwKSxYPWcuZnJvbVZhbHVlcygwLDEsMCk7cmV0dXJuIGZ1bmN0aW9uKEIsRyx1KXt2YXIgTT1nLmRvdChHLHUpO3JldHVybiBNPC0uOTk5OTk5PyhnLmNyb3NzKEYsVixHKSxnLmxlbihGKTwxZS02JiZnLmNyb3NzKEYsWCxHKSxnLm5vcm1hbGl6ZShGLEYpLGgoQixGLE1hdGguUEkpLEIpOk0+Ljk5OTk5OT8oQlswXT0wLEJbMV09MCxCWzJdPTAsQlszXT0xLEIpOihnLmNyb3NzKEYsRyx1KSxCWzBdPUZbMF0sQlsxXT1GWzFdLEJbMl09RlsyXSxCWzNdPTErTSxfKEIsQikpfX0oKSxmdD1mdW5jdGlvbigpe3ZhciBGPWMoKSxWPWMoKTtyZXR1cm4gZnVuY3Rpb24oWCxCLEcsdSxNLE4pe3JldHVybiBuKEYsQixNLE4pLG4oVixHLHUsTiksbihYLEYsViwyKk4qKDEtTikpLFh9fSgpLFU9ZnVuY3Rpb24oKXt2YXIgRj1vLmNyZWF0ZSgpO3JldHVybiBmdW5jdGlvbihWLFgsQixHKXtyZXR1cm4gRlswXT1CWzBdLEZbM109QlsxXSxGWzZdPUJbMl0sRlsxXT1HWzBdLEZbNF09R1sxXSxGWzddPUdbMl0sRlsyXT0tWFswXSxGWzVdPS1YWzFdLEZbOF09LVhbMl0sXyhWLGIoVixGKSl9fSgpfSxmdW5jdGlvbihSLGUsdCl7dC5yKGUpLHQuZChlLCJjcmVhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIG99KSx0LmQoZSwiY2xvbmUiLGZ1bmN0aW9uKCl7cmV0dXJuIGd9KSx0LmQoZSwibGVuZ3RoIixmdW5jdGlvbigpe3JldHVybiB2fSksdC5kKGUsImZyb21WYWx1ZXMiLGZ1bmN0aW9uKCl7cmV0dXJuIGN9KSx0LmQoZSwiY29weSIsZnVuY3Rpb24oKXtyZXR1cm4gZn0pLHQuZChlLCJzZXQiLGZ1bmN0aW9uKCl7cmV0dXJuIGh9KSx0LmQoZSwiYWRkIixmdW5jdGlvbigpe3JldHVybiBFfSksdC5kKGUsInN1YnRyYWN0IixmdW5jdGlvbigpe3JldHVybiBsfSksdC5kKGUsIm11bHRpcGx5IixmdW5jdGlvbigpe3JldHVybiBtfSksdC5kKGUsImRpdmlkZSIsZnVuY3Rpb24oKXtyZXR1cm4gcH0pLHQuZChlLCJjZWlsIixmdW5jdGlvbigpe3JldHVybiBDfSksdC5kKGUsImZsb29yIixmdW5jdGlvbigpe3JldHVybiB4fSksdC5kKGUsIm1pbiIsZnVuY3Rpb24oKXtyZXR1cm4gZH0pLHQuZChlLCJtYXgiLGZ1bmN0aW9uKCl7cmV0dXJuIHl9KSx0LmQoZSwicm91bmQiLGZ1bmN0aW9uKCl7cmV0dXJuIHJ9KSx0LmQoZSwic2NhbGUiLGZ1bmN0aW9uKCl7cmV0dXJuIHN9KSx0LmQoZSwic2NhbGVBbmRBZGQiLGZ1bmN0aW9uKCl7cmV0dXJuIG59KSx0LmQoZSwiZGlzdGFuY2UiLGZ1bmN0aW9uKCl7cmV0dXJuIGF9KSx0LmQoZSwic3F1YXJlZERpc3RhbmNlIixmdW5jdGlvbigpe3JldHVybiBPfSksdC5kKGUsInNxdWFyZWRMZW5ndGgiLGZ1bmN0aW9uKCl7cmV0dXJuIEF9KSx0LmQoZSwibmVnYXRlIixmdW5jdGlvbigpe3JldHVybiBifSksdC5kKGUsImludmVyc2UiLGZ1bmN0aW9uKCl7cmV0dXJuIEl9KSx0LmQoZSwibm9ybWFsaXplIixmdW5jdGlvbigpe3JldHVybiBQfSksdC5kKGUsImRvdCIsZnVuY3Rpb24oKXtyZXR1cm4gRH0pLHQuZChlLCJjcm9zcyIsZnVuY3Rpb24oKXtyZXR1cm4gTH0pLHQuZChlLCJsZXJwIixmdW5jdGlvbigpe3JldHVybiBTfSksdC5kKGUsImhlcm1pdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIFR9KSx0LmQoZSwiYmV6aWVyIixmdW5jdGlvbigpe3JldHVybiBqfSksdC5kKGUsInJhbmRvbSIsZnVuY3Rpb24oKXtyZXR1cm4gJH0pLHQuZChlLCJ0cmFuc2Zvcm1NYXQ0IixmdW5jdGlvbigpe3JldHVybiB3fSksdC5kKGUsInRyYW5zZm9ybU1hdDMiLGZ1bmN0aW9uKCl7cmV0dXJuIEp9KSx0LmQoZSwidHJhbnNmb3JtUXVhdCIsZnVuY3Rpb24oKXtyZXR1cm4gcX0pLHQuZChlLCJyb3RhdGVYIixmdW5jdGlvbigpe3JldHVybiBXfSksdC5kKGUsInJvdGF0ZVkiLGZ1bmN0aW9uKCl7cmV0dXJuIEt9KSx0LmQoZSwicm90YXRlWiIsZnVuY3Rpb24oKXtyZXR1cm4gUX0pLHQuZChlLCJhbmdsZSIsZnVuY3Rpb24oKXtyZXR1cm4gdHR9KSx0LmQoZSwiemVybyIsZnVuY3Rpb24oKXtyZXR1cm4gX30pLHQuZChlLCJzdHIiLGZ1bmN0aW9uKCl7cmV0dXJuIHN0fSksdC5kKGUsImV4YWN0RXF1YWxzIixmdW5jdGlvbigpe3JldHVybiBrfSksdC5kKGUsImVxdWFscyIsZnVuY3Rpb24oKXtyZXR1cm4gY3R9KSx0LmQoZSwic3ViIixmdW5jdGlvbigpe3JldHVybiBmdH0pLHQuZChlLCJtdWwiLGZ1bmN0aW9uKCl7cmV0dXJuIFV9KSx0LmQoZSwiZGl2IixmdW5jdGlvbigpe3JldHVybiBGfSksdC5kKGUsImRpc3QiLGZ1bmN0aW9uKCl7cmV0dXJuIFZ9KSx0LmQoZSwic3FyRGlzdCIsZnVuY3Rpb24oKXtyZXR1cm4gWH0pLHQuZChlLCJsZW4iLGZ1bmN0aW9uKCl7cmV0dXJuIEJ9KSx0LmQoZSwic3FyTGVuIixmdW5jdGlvbigpe3JldHVybiBHfSksdC5kKGUsImZvckVhY2giLGZ1bmN0aW9uKCl7cmV0dXJuIHV9KTt2YXIgaT10KDIpO2Z1bmN0aW9uIG8oKXt2YXIgTT1uZXcgaS5BUlJBWV9UWVBFKDMpO3JldHVybiBpLkFSUkFZX1RZUEUhPUZsb2F0MzJBcnJheSYmKE1bMF09MCxNWzFdPTAsTVsyXT0wKSxNfWZ1bmN0aW9uIGcoTSl7dmFyIE49bmV3IGkuQVJSQVlfVFlQRSgzKTtyZXR1cm4gTlswXT1NWzBdLE5bMV09TVsxXSxOWzJdPU1bMl0sTn1mdW5jdGlvbiB2KE0pe3ZhciBOPU1bMF0sej1NWzFdLEg9TVsyXTtyZXR1cm4gTWF0aC5oeXBvdChOLHosSCl9ZnVuY3Rpb24gYyhNLE4seil7dmFyIEg9bmV3IGkuQVJSQVlfVFlQRSgzKTtyZXR1cm4gSFswXT1NLEhbMV09TixIWzJdPXosSH1mdW5jdGlvbiBmKE0sTil7cmV0dXJuIE1bMF09TlswXSxNWzFdPU5bMV0sTVsyXT1OWzJdLE19ZnVuY3Rpb24gaChNLE4seixIKXtyZXR1cm4gTVswXT1OLE1bMV09eixNWzJdPUgsTX1mdW5jdGlvbiBFKE0sTix6KXtyZXR1cm4gTVswXT1OWzBdK3pbMF0sTVsxXT1OWzFdK3pbMV0sTVsyXT1OWzJdK3pbMl0sTX1mdW5jdGlvbiBsKE0sTix6KXtyZXR1cm4gTVswXT1OWzBdLXpbMF0sTVsxXT1OWzFdLXpbMV0sTVsyXT1OWzJdLXpbMl0sTX1mdW5jdGlvbiBtKE0sTix6KXtyZXR1cm4gTVswXT1OWzBdKnpbMF0sTVsxXT1OWzFdKnpbMV0sTVsyXT1OWzJdKnpbMl0sTX1mdW5jdGlvbiBwKE0sTix6KXtyZXR1cm4gTVswXT1OWzBdL3pbMF0sTVsxXT1OWzFdL3pbMV0sTVsyXT1OWzJdL3pbMl0sTX1mdW5jdGlvbiBDKE0sTil7cmV0dXJuIE1bMF09TWF0aC5jZWlsKE5bMF0pLE1bMV09TWF0aC5jZWlsKE5bMV0pLE1bMl09TWF0aC5jZWlsKE5bMl0pLE19ZnVuY3Rpb24geChNLE4pe3JldHVybiBNWzBdPU1hdGguZmxvb3IoTlswXSksTVsxXT1NYXRoLmZsb29yKE5bMV0pLE1bMl09TWF0aC5mbG9vcihOWzJdKSxNfWZ1bmN0aW9uIGQoTSxOLHope3JldHVybiBNWzBdPU1hdGgubWluKE5bMF0selswXSksTVsxXT1NYXRoLm1pbihOWzFdLHpbMV0pLE1bMl09TWF0aC5taW4oTlsyXSx6WzJdKSxNfWZ1bmN0aW9uIHkoTSxOLHope3JldHVybiBNWzBdPU1hdGgubWF4KE5bMF0selswXSksTVsxXT1NYXRoLm1heChOWzFdLHpbMV0pLE1bMl09TWF0aC5tYXgoTlsyXSx6WzJdKSxNfWZ1bmN0aW9uIHIoTSxOKXtyZXR1cm4gTVswXT1NYXRoLnJvdW5kKE5bMF0pLE1bMV09TWF0aC5yb3VuZChOWzFdKSxNWzJdPU1hdGgucm91bmQoTlsyXSksTX1mdW5jdGlvbiBzKE0sTix6KXtyZXR1cm4gTVswXT1OWzBdKnosTVsxXT1OWzFdKnosTVsyXT1OWzJdKnosTX1mdW5jdGlvbiBuKE0sTix6LEgpe3JldHVybiBNWzBdPU5bMF0relswXSpILE1bMV09TlsxXSt6WzFdKkgsTVsyXT1OWzJdK3pbMl0qSCxNfWZ1bmN0aW9uIGEoTSxOKXt2YXIgej1OWzBdLU1bMF0sSD1OWzFdLU1bMV0sWT1OWzJdLU1bMl07cmV0dXJuIE1hdGguaHlwb3QoeixILFkpfWZ1bmN0aW9uIE8oTSxOKXt2YXIgej1OWzBdLU1bMF0sSD1OWzFdLU1bMV0sWT1OWzJdLU1bMl07cmV0dXJuIHoqeitIKkgrWSpZfWZ1bmN0aW9uIEEoTSl7dmFyIE49TVswXSx6PU1bMV0sSD1NWzJdO3JldHVybiBOKk4reip6K0gqSH1mdW5jdGlvbiBiKE0sTil7cmV0dXJuIE1bMF09LU5bMF0sTVsxXT0tTlsxXSxNWzJdPS1OWzJdLE19ZnVuY3Rpb24gSShNLE4pe3JldHVybiBNWzBdPTEvTlswXSxNWzFdPTEvTlsxXSxNWzJdPTEvTlsyXSxNfWZ1bmN0aW9uIFAoTSxOKXt2YXIgej1OWzBdLEg9TlsxXSxZPU5bMl0sWj16KnorSCpIK1kqWTtyZXR1cm4gWj4wJiYoWj0xL01hdGguc3FydChaKSksTVswXT1OWzBdKlosTVsxXT1OWzFdKlosTVsyXT1OWzJdKlosTX1mdW5jdGlvbiBEKE0sTil7cmV0dXJuIE1bMF0qTlswXStNWzFdKk5bMV0rTVsyXSpOWzJdfWZ1bmN0aW9uIEwoTSxOLHope3ZhciBIPU5bMF0sWT1OWzFdLFo9TlsyXSxldD16WzBdLHJ0PXpbMV0sb3Q9elsyXTtyZXR1cm4gTVswXT1ZKm90LVoqcnQsTVsxXT1aKmV0LUgqb3QsTVsyXT1IKnJ0LVkqZXQsTX1mdW5jdGlvbiBTKE0sTix6LEgpe3ZhciBZPU5bMF0sWj1OWzFdLGV0PU5bMl07cmV0dXJuIE1bMF09WStIKih6WzBdLVkpLE1bMV09WitIKih6WzFdLVopLE1bMl09ZXQrSCooelsyXS1ldCksTX1mdW5jdGlvbiBUKE0sTix6LEgsWSxaKXt2YXIgZXQ9WipaLHJ0PWV0KigyKlotMykrMSxvdD1ldCooWi0yKStaLGx0PWV0KihaLTEpLGl0PWV0KigzLTIqWik7cmV0dXJuIE1bMF09TlswXSpydCt6WzBdKm90K0hbMF0qbHQrWVswXSppdCxNWzFdPU5bMV0qcnQrelsxXSpvdCtIWzFdKmx0K1lbMV0qaXQsTVsyXT1OWzJdKnJ0K3pbMl0qb3QrSFsyXSpsdCtZWzJdKml0LE19ZnVuY3Rpb24gaihNLE4seixILFksWil7dmFyIGV0PTEtWixydD1ldCpldCxvdD1aKlosbHQ9cnQqZXQsaXQ9MypaKnJ0LG50PTMqb3QqZXQsYXQ9b3QqWjtyZXR1cm4gTVswXT1OWzBdKmx0K3pbMF0qaXQrSFswXSpudCtZWzBdKmF0LE1bMV09TlsxXSpsdCt6WzFdKml0K0hbMV0qbnQrWVsxXSphdCxNWzJdPU5bMl0qbHQrelsyXSppdCtIWzJdKm50K1lbMl0qYXQsTX1mdW5jdGlvbiAkKE0sTil7Tj1OfHwxO3ZhciB6PWkuUkFORE9NKCkqMipNYXRoLlBJLEg9aS5SQU5ET00oKSoyLTEsWT1NYXRoLnNxcnQoMS1IKkgpKk47cmV0dXJuIE1bMF09TWF0aC5jb3MoeikqWSxNWzFdPU1hdGguc2luKHopKlksTVsyXT1IKk4sTX1mdW5jdGlvbiB3KE0sTix6KXt2YXIgSD1OWzBdLFk9TlsxXSxaPU5bMl0sZXQ9elszXSpIK3pbN10qWSt6WzExXSpaK3pbMTVdO3JldHVybiBldD1ldHx8MSxNWzBdPSh6WzBdKkgrels0XSpZK3pbOF0qWit6WzEyXSkvZXQsTVsxXT0oelsxXSpIK3pbNV0qWSt6WzldKlorelsxM10pL2V0LE1bMl09KHpbMl0qSCt6WzZdKlkrelsxMF0qWit6WzE0XSkvZXQsTX1mdW5jdGlvbiBKKE0sTix6KXt2YXIgSD1OWzBdLFk9TlsxXSxaPU5bMl07cmV0dXJuIE1bMF09SCp6WzBdK1kqelszXStaKnpbNl0sTVsxXT1IKnpbMV0rWSp6WzRdK1oqels3XSxNWzJdPUgqelsyXStZKnpbNV0rWip6WzhdLE19ZnVuY3Rpb24gcShNLE4seil7dmFyIEg9elswXSxZPXpbMV0sWj16WzJdLGV0PXpbM10scnQ9TlswXSxvdD1OWzFdLGx0PU5bMl0saXQ9WSpsdC1aKm90LG50PVoqcnQtSCpsdCxhdD1IKm90LVkqcnQsZHQ9WSphdC1aKm50LGd0PVoqaXQtSCphdCx1dD1IKm50LVkqaXQsbXQ9ZXQqMjtyZXR1cm4gaXQqPW10LG50Kj1tdCxhdCo9bXQsZHQqPTIsZ3QqPTIsdXQqPTIsTVswXT1ydCtpdCtkdCxNWzFdPW90K250K2d0LE1bMl09bHQrYXQrdXQsTX1mdW5jdGlvbiBXKE0sTix6LEgpe3ZhciBZPVtdLFo9W107cmV0dXJuIFlbMF09TlswXS16WzBdLFlbMV09TlsxXS16WzFdLFlbMl09TlsyXS16WzJdLFpbMF09WVswXSxaWzFdPVlbMV0qTWF0aC5jb3MoSCktWVsyXSpNYXRoLnNpbihIKSxaWzJdPVlbMV0qTWF0aC5zaW4oSCkrWVsyXSpNYXRoLmNvcyhIKSxNWzBdPVpbMF0relswXSxNWzFdPVpbMV0relsxXSxNWzJdPVpbMl0relsyXSxNfWZ1bmN0aW9uIEsoTSxOLHosSCl7dmFyIFk9W10sWj1bXTtyZXR1cm4gWVswXT1OWzBdLXpbMF0sWVsxXT1OWzFdLXpbMV0sWVsyXT1OWzJdLXpbMl0sWlswXT1ZWzJdKk1hdGguc2luKEgpK1lbMF0qTWF0aC5jb3MoSCksWlsxXT1ZWzFdLFpbMl09WVsyXSpNYXRoLmNvcyhIKS1ZWzBdKk1hdGguc2luKEgpLE1bMF09WlswXSt6WzBdLE1bMV09WlsxXSt6WzFdLE1bMl09WlsyXSt6WzJdLE19ZnVuY3Rpb24gUShNLE4seixIKXt2YXIgWT1bXSxaPVtdO3JldHVybiBZWzBdPU5bMF0telswXSxZWzFdPU5bMV0telsxXSxZWzJdPU5bMl0telsyXSxaWzBdPVlbMF0qTWF0aC5jb3MoSCktWVsxXSpNYXRoLnNpbihIKSxaWzFdPVlbMF0qTWF0aC5zaW4oSCkrWVsxXSpNYXRoLmNvcyhIKSxaWzJdPVlbMl0sTVswXT1aWzBdK3pbMF0sTVsxXT1aWzFdK3pbMV0sTVsyXT1aWzJdK3pbMl0sTX1mdW5jdGlvbiB0dChNLE4pe3ZhciB6PU1bMF0sSD1NWzFdLFk9TVsyXSxaPU5bMF0sZXQ9TlsxXSxydD1OWzJdLG90PU1hdGguc3FydCh6KnorSCpIK1kqWSksbHQ9TWF0aC5zcXJ0KFoqWitldCpldCtydCpydCksaXQ9b3QqbHQsbnQ9aXQmJkQoTSxOKS9pdDtyZXR1cm4gTWF0aC5hY29zKE1hdGgubWluKE1hdGgubWF4KG50LC0xKSwxKSl9ZnVuY3Rpb24gXyhNKXtyZXR1cm4gTVswXT0wLE1bMV09MCxNWzJdPTAsTX1mdW5jdGlvbiBzdChNKXtyZXR1cm4idmVjMygiK01bMF0rIiwgIitNWzFdKyIsICIrTVsyXSsiKSJ9ZnVuY3Rpb24gayhNLE4pe3JldHVybiBNWzBdPT09TlswXSYmTVsxXT09PU5bMV0mJk1bMl09PT1OWzJdfWZ1bmN0aW9uIGN0KE0sTil7dmFyIHo9TVswXSxIPU1bMV0sWT1NWzJdLFo9TlswXSxldD1OWzFdLHJ0PU5bMl07cmV0dXJuIE1hdGguYWJzKHotWik8PWkuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKHopLE1hdGguYWJzKFopKSYmTWF0aC5hYnMoSC1ldCk8PWkuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKEgpLE1hdGguYWJzKGV0KSkmJk1hdGguYWJzKFktcnQpPD1pLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhZKSxNYXRoLmFicyhydCkpfXZhciBmdD1sLFU9bSxGPXAsVj1hLFg9TyxCPXYsRz1BLHU9ZnVuY3Rpb24oKXt2YXIgTT1vKCk7cmV0dXJuIGZ1bmN0aW9uKE4seixILFksWixldCl7dmFyIHJ0LG90O2Zvcih6fHwoej0zKSxIfHwoSD0wKSxZP290PU1hdGgubWluKFkqeitILE4ubGVuZ3RoKTpvdD1OLmxlbmd0aCxydD1IO3J0PG90O3J0Kz16KU1bMF09TltydF0sTVsxXT1OW3J0KzFdLE1bMl09TltydCsyXSxaKE0sTSxldCksTltydF09TVswXSxOW3J0KzFdPU1bMV0sTltydCsyXT1NWzJdO3JldHVybiBOfX0oKX0sZnVuY3Rpb24oUixlLHQpe3QucihlKSx0LmQoZSwiY3JlYXRlIixmdW5jdGlvbigpe3JldHVybiBvfSksdC5kKGUsImNsb25lIixmdW5jdGlvbigpe3JldHVybiBnfSksdC5kKGUsImZyb21WYWx1ZXMiLGZ1bmN0aW9uKCl7cmV0dXJuIHZ9KSx0LmQoZSwiY29weSIsZnVuY3Rpb24oKXtyZXR1cm4gY30pLHQuZChlLCJzZXQiLGZ1bmN0aW9uKCl7cmV0dXJuIGZ9KSx0LmQoZSwiYWRkIixmdW5jdGlvbigpe3JldHVybiBofSksdC5kKGUsInN1YnRyYWN0IixmdW5jdGlvbigpe3JldHVybiBFfSksdC5kKGUsIm11bHRpcGx5IixmdW5jdGlvbigpe3JldHVybiBsfSksdC5kKGUsImRpdmlkZSIsZnVuY3Rpb24oKXtyZXR1cm4gbX0pLHQuZChlLCJjZWlsIixmdW5jdGlvbigpe3JldHVybiBwfSksdC5kKGUsImZsb29yIixmdW5jdGlvbigpe3JldHVybiBDfSksdC5kKGUsIm1pbiIsZnVuY3Rpb24oKXtyZXR1cm4geH0pLHQuZChlLCJtYXgiLGZ1bmN0aW9uKCl7cmV0dXJuIGR9KSx0LmQoZSwicm91bmQiLGZ1bmN0aW9uKCl7cmV0dXJuIHl9KSx0LmQoZSwic2NhbGUiLGZ1bmN0aW9uKCl7cmV0dXJuIHJ9KSx0LmQoZSwic2NhbGVBbmRBZGQiLGZ1bmN0aW9uKCl7cmV0dXJuIHN9KSx0LmQoZSwiZGlzdGFuY2UiLGZ1bmN0aW9uKCl7cmV0dXJuIG59KSx0LmQoZSwic3F1YXJlZERpc3RhbmNlIixmdW5jdGlvbigpe3JldHVybiBhfSksdC5kKGUsImxlbmd0aCIsZnVuY3Rpb24oKXtyZXR1cm4gT30pLHQuZChlLCJzcXVhcmVkTGVuZ3RoIixmdW5jdGlvbigpe3JldHVybiBBfSksdC5kKGUsIm5lZ2F0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gYn0pLHQuZChlLCJpbnZlcnNlIixmdW5jdGlvbigpe3JldHVybiBJfSksdC5kKGUsIm5vcm1hbGl6ZSIsZnVuY3Rpb24oKXtyZXR1cm4gUH0pLHQuZChlLCJkb3QiLGZ1bmN0aW9uKCl7cmV0dXJuIER9KSx0LmQoZSwiY3Jvc3MiLGZ1bmN0aW9uKCl7cmV0dXJuIEx9KSx0LmQoZSwibGVycCIsZnVuY3Rpb24oKXtyZXR1cm4gU30pLHQuZChlLCJyYW5kb20iLGZ1bmN0aW9uKCl7cmV0dXJuIFR9KSx0LmQoZSwidHJhbnNmb3JtTWF0NCIsZnVuY3Rpb24oKXtyZXR1cm4gan0pLHQuZChlLCJ0cmFuc2Zvcm1RdWF0IixmdW5jdGlvbigpe3JldHVybiAkfSksdC5kKGUsInplcm8iLGZ1bmN0aW9uKCl7cmV0dXJuIHd9KSx0LmQoZSwic3RyIixmdW5jdGlvbigpe3JldHVybiBKfSksdC5kKGUsImV4YWN0RXF1YWxzIixmdW5jdGlvbigpe3JldHVybiBxfSksdC5kKGUsImVxdWFscyIsZnVuY3Rpb24oKXtyZXR1cm4gV30pLHQuZChlLCJzdWIiLGZ1bmN0aW9uKCl7cmV0dXJuIEt9KSx0LmQoZSwibXVsIixmdW5jdGlvbigpe3JldHVybiBRfSksdC5kKGUsImRpdiIsZnVuY3Rpb24oKXtyZXR1cm4gdHR9KSx0LmQoZSwiZGlzdCIsZnVuY3Rpb24oKXtyZXR1cm4gX30pLHQuZChlLCJzcXJEaXN0IixmdW5jdGlvbigpe3JldHVybiBzdH0pLHQuZChlLCJsZW4iLGZ1bmN0aW9uKCl7cmV0dXJuIGt9KSx0LmQoZSwic3FyTGVuIixmdW5jdGlvbigpe3JldHVybiBjdH0pLHQuZChlLCJmb3JFYWNoIixmdW5jdGlvbigpe3JldHVybiBmdH0pO3ZhciBpPXQoMik7ZnVuY3Rpb24gbygpe3ZhciBVPW5ldyBpLkFSUkFZX1RZUEUoNCk7cmV0dXJuIGkuQVJSQVlfVFlQRSE9RmxvYXQzMkFycmF5JiYoVVswXT0wLFVbMV09MCxVWzJdPTAsVVszXT0wKSxVfWZ1bmN0aW9uIGcoVSl7dmFyIEY9bmV3IGkuQVJSQVlfVFlQRSg0KTtyZXR1cm4gRlswXT1VWzBdLEZbMV09VVsxXSxGWzJdPVVbMl0sRlszXT1VWzNdLEZ9ZnVuY3Rpb24gdihVLEYsVixYKXt2YXIgQj1uZXcgaS5BUlJBWV9UWVBFKDQpO3JldHVybiBCWzBdPVUsQlsxXT1GLEJbMl09VixCWzNdPVgsQn1mdW5jdGlvbiBjKFUsRil7cmV0dXJuIFVbMF09RlswXSxVWzFdPUZbMV0sVVsyXT1GWzJdLFVbM109RlszXSxVfWZ1bmN0aW9uIGYoVSxGLFYsWCxCKXtyZXR1cm4gVVswXT1GLFVbMV09VixVWzJdPVgsVVszXT1CLFV9ZnVuY3Rpb24gaChVLEYsVil7cmV0dXJuIFVbMF09RlswXStWWzBdLFVbMV09RlsxXStWWzFdLFVbMl09RlsyXStWWzJdLFVbM109RlszXStWWzNdLFV9ZnVuY3Rpb24gRShVLEYsVil7cmV0dXJuIFVbMF09RlswXS1WWzBdLFVbMV09RlsxXS1WWzFdLFVbMl09RlsyXS1WWzJdLFVbM109RlszXS1WWzNdLFV9ZnVuY3Rpb24gbChVLEYsVil7cmV0dXJuIFVbMF09RlswXSpWWzBdLFVbMV09RlsxXSpWWzFdLFVbMl09RlsyXSpWWzJdLFVbM109RlszXSpWWzNdLFV9ZnVuY3Rpb24gbShVLEYsVil7cmV0dXJuIFVbMF09RlswXS9WWzBdLFVbMV09RlsxXS9WWzFdLFVbMl09RlsyXS9WWzJdLFVbM109RlszXS9WWzNdLFV9ZnVuY3Rpb24gcChVLEYpe3JldHVybiBVWzBdPU1hdGguY2VpbChGWzBdKSxVWzFdPU1hdGguY2VpbChGWzFdKSxVWzJdPU1hdGguY2VpbChGWzJdKSxVWzNdPU1hdGguY2VpbChGWzNdKSxVfWZ1bmN0aW9uIEMoVSxGKXtyZXR1cm4gVVswXT1NYXRoLmZsb29yKEZbMF0pLFVbMV09TWF0aC5mbG9vcihGWzFdKSxVWzJdPU1hdGguZmxvb3IoRlsyXSksVVszXT1NYXRoLmZsb29yKEZbM10pLFV9ZnVuY3Rpb24geChVLEYsVil7cmV0dXJuIFVbMF09TWF0aC5taW4oRlswXSxWWzBdKSxVWzFdPU1hdGgubWluKEZbMV0sVlsxXSksVVsyXT1NYXRoLm1pbihGWzJdLFZbMl0pLFVbM109TWF0aC5taW4oRlszXSxWWzNdKSxVfWZ1bmN0aW9uIGQoVSxGLFYpe3JldHVybiBVWzBdPU1hdGgubWF4KEZbMF0sVlswXSksVVsxXT1NYXRoLm1heChGWzFdLFZbMV0pLFVbMl09TWF0aC5tYXgoRlsyXSxWWzJdKSxVWzNdPU1hdGgubWF4KEZbM10sVlszXSksVX1mdW5jdGlvbiB5KFUsRil7cmV0dXJuIFVbMF09TWF0aC5yb3VuZChGWzBdKSxVWzFdPU1hdGgucm91bmQoRlsxXSksVVsyXT1NYXRoLnJvdW5kKEZbMl0pLFVbM109TWF0aC5yb3VuZChGWzNdKSxVfWZ1bmN0aW9uIHIoVSxGLFYpe3JldHVybiBVWzBdPUZbMF0qVixVWzFdPUZbMV0qVixVWzJdPUZbMl0qVixVWzNdPUZbM10qVixVfWZ1bmN0aW9uIHMoVSxGLFYsWCl7cmV0dXJuIFVbMF09RlswXStWWzBdKlgsVVsxXT1GWzFdK1ZbMV0qWCxVWzJdPUZbMl0rVlsyXSpYLFVbM109RlszXStWWzNdKlgsVX1mdW5jdGlvbiBuKFUsRil7dmFyIFY9RlswXS1VWzBdLFg9RlsxXS1VWzFdLEI9RlsyXS1VWzJdLEc9RlszXS1VWzNdO3JldHVybiBNYXRoLmh5cG90KFYsWCxCLEcpfWZ1bmN0aW9uIGEoVSxGKXt2YXIgVj1GWzBdLVVbMF0sWD1GWzFdLVVbMV0sQj1GWzJdLVVbMl0sRz1GWzNdLVVbM107cmV0dXJuIFYqVitYKlgrQipCK0cqR31mdW5jdGlvbiBPKFUpe3ZhciBGPVVbMF0sVj1VWzFdLFg9VVsyXSxCPVVbM107cmV0dXJuIE1hdGguaHlwb3QoRixWLFgsQil9ZnVuY3Rpb24gQShVKXt2YXIgRj1VWzBdLFY9VVsxXSxYPVVbMl0sQj1VWzNdO3JldHVybiBGKkYrVipWK1gqWCtCKkJ9ZnVuY3Rpb24gYihVLEYpe3JldHVybiBVWzBdPS1GWzBdLFVbMV09LUZbMV0sVVsyXT0tRlsyXSxVWzNdPS1GWzNdLFV9ZnVuY3Rpb24gSShVLEYpe3JldHVybiBVWzBdPTEvRlswXSxVWzFdPTEvRlsxXSxVWzJdPTEvRlsyXSxVWzNdPTEvRlszXSxVfWZ1bmN0aW9uIFAoVSxGKXt2YXIgVj1GWzBdLFg9RlsxXSxCPUZbMl0sRz1GWzNdLHU9VipWK1gqWCtCKkIrRypHO3JldHVybiB1PjAmJih1PTEvTWF0aC5zcXJ0KHUpKSxVWzBdPVYqdSxVWzFdPVgqdSxVWzJdPUIqdSxVWzNdPUcqdSxVfWZ1bmN0aW9uIEQoVSxGKXtyZXR1cm4gVVswXSpGWzBdK1VbMV0qRlsxXStVWzJdKkZbMl0rVVszXSpGWzNdfWZ1bmN0aW9uIEwoVSxGLFYsWCl7dmFyIEI9VlswXSpYWzFdLVZbMV0qWFswXSxHPVZbMF0qWFsyXS1WWzJdKlhbMF0sdT1WWzBdKlhbM10tVlszXSpYWzBdLE09VlsxXSpYWzJdLVZbMl0qWFsxXSxOPVZbMV0qWFszXS1WWzNdKlhbMV0sej1WWzJdKlhbM10tVlszXSpYWzJdLEg9RlswXSxZPUZbMV0sWj1GWzJdLGV0PUZbM107cmV0dXJuIFVbMF09WSp6LVoqTitldCpNLFVbMV09LShIKnopK1oqdS1ldCpHLFVbMl09SCpOLVkqdStldCpCLFVbM109LShIKk0pK1kqRy1aKkIsVX1mdW5jdGlvbiBTKFUsRixWLFgpe3ZhciBCPUZbMF0sRz1GWzFdLHU9RlsyXSxNPUZbM107cmV0dXJuIFVbMF09QitYKihWWzBdLUIpLFVbMV09RytYKihWWzFdLUcpLFVbMl09dStYKihWWzJdLXUpLFVbM109TStYKihWWzNdLU0pLFV9ZnVuY3Rpb24gVChVLEYpe0Y9Rnx8MTt2YXIgVixYLEIsRyx1LE07ZG8gVj1pLlJBTkRPTSgpKjItMSxYPWkuUkFORE9NKCkqMi0xLHU9VipWK1gqWDt3aGlsZSh1Pj0xKTtkbyBCPWkuUkFORE9NKCkqMi0xLEc9aS5SQU5ET00oKSoyLTEsTT1CKkIrRypHO3doaWxlKE0+PTEpO3ZhciBOPU1hdGguc3FydCgoMS11KS9NKTtyZXR1cm4gVVswXT1GKlYsVVsxXT1GKlgsVVsyXT1GKkIqTixVWzNdPUYqRypOLFV9ZnVuY3Rpb24gaihVLEYsVil7dmFyIFg9RlswXSxCPUZbMV0sRz1GWzJdLHU9RlszXTtyZXR1cm4gVVswXT1WWzBdKlgrVls0XSpCK1ZbOF0qRytWWzEyXSp1LFVbMV09VlsxXSpYK1ZbNV0qQitWWzldKkcrVlsxM10qdSxVWzJdPVZbMl0qWCtWWzZdKkIrVlsxMF0qRytWWzE0XSp1LFVbM109VlszXSpYK1ZbN10qQitWWzExXSpHK1ZbMTVdKnUsVX1mdW5jdGlvbiAkKFUsRixWKXt2YXIgWD1GWzBdLEI9RlsxXSxHPUZbMl0sdT1WWzBdLE09VlsxXSxOPVZbMl0sej1WWzNdLEg9eipYK00qRy1OKkIsWT16KkIrTipYLXUqRyxaPXoqRyt1KkItTSpYLGV0PS11KlgtTSpCLU4qRztyZXR1cm4gVVswXT1IKnorZXQqLXUrWSotTi1aKi1NLFVbMV09WSp6K2V0Ki1NK1oqLXUtSCotTixVWzJdPVoqeitldCotTitIKi1NLVkqLXUsVVszXT1GWzNdLFV9ZnVuY3Rpb24gdyhVKXtyZXR1cm4gVVswXT0wLFVbMV09MCxVWzJdPTAsVVszXT0wLFV9ZnVuY3Rpb24gSihVKXtyZXR1cm4idmVjNCgiK1VbMF0rIiwgIitVWzFdKyIsICIrVVsyXSsiLCAiK1VbM10rIikifWZ1bmN0aW9uIHEoVSxGKXtyZXR1cm4gVVswXT09PUZbMF0mJlVbMV09PT1GWzFdJiZVWzJdPT09RlsyXSYmVVszXT09PUZbM119ZnVuY3Rpb24gVyhVLEYpe3ZhciBWPVVbMF0sWD1VWzFdLEI9VVsyXSxHPVVbM10sdT1GWzBdLE09RlsxXSxOPUZbMl0sej1GWzNdO3JldHVybiBNYXRoLmFicyhWLXUpPD1pLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhWKSxNYXRoLmFicyh1KSkmJk1hdGguYWJzKFgtTSk8PWkuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKFgpLE1hdGguYWJzKE0pKSYmTWF0aC5hYnMoQi1OKTw9aS5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoQiksTWF0aC5hYnMoTikpJiZNYXRoLmFicyhHLXopPD1pLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhHKSxNYXRoLmFicyh6KSl9dmFyIEs9RSxRPWwsdHQ9bSxfPW4sc3Q9YSxrPU8sY3Q9QSxmdD1mdW5jdGlvbigpe3ZhciBVPW8oKTtyZXR1cm4gZnVuY3Rpb24oRixWLFgsQixHLHUpe3ZhciBNLE47Zm9yKFZ8fChWPTQpLFh8fChYPTApLEI/Tj1NYXRoLm1pbihCKlYrWCxGLmxlbmd0aCk6Tj1GLmxlbmd0aCxNPVg7TTxOO00rPVYpVVswXT1GW01dLFVbMV09RltNKzFdLFVbMl09RltNKzJdLFVbM109RltNKzNdLEcoVSxVLHUpLEZbTV09VVswXSxGW00rMV09VVsxXSxGW00rMl09VVsyXSxGW00rM109VVszXTtyZXR1cm4gRn19KCl9LGZ1bmN0aW9uKFIsZSx0KXt0LnIoZSksdC5kKGUsImNyZWF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gdn0pLHQuZChlLCJjbG9uZSIsZnVuY3Rpb24oKXtyZXR1cm4gY30pLHQuZChlLCJmcm9tVmFsdWVzIixmdW5jdGlvbigpe3JldHVybiBmfSksdC5kKGUsImZyb21Sb3RhdGlvblRyYW5zbGF0aW9uVmFsdWVzIixmdW5jdGlvbigpe3JldHVybiBofSksdC5kKGUsImZyb21Sb3RhdGlvblRyYW5zbGF0aW9uIixmdW5jdGlvbigpe3JldHVybiBFfSksdC5kKGUsImZyb21UcmFuc2xhdGlvbiIsZnVuY3Rpb24oKXtyZXR1cm4gbH0pLHQuZChlLCJmcm9tUm90YXRpb24iLGZ1bmN0aW9uKCl7cmV0dXJuIG19KSx0LmQoZSwiZnJvbU1hdDQiLGZ1bmN0aW9uKCl7cmV0dXJuIHB9KSx0LmQoZSwiY29weSIsZnVuY3Rpb24oKXtyZXR1cm4gQ30pLHQuZChlLCJpZGVudGl0eSIsZnVuY3Rpb24oKXtyZXR1cm4geH0pLHQuZChlLCJzZXQiLGZ1bmN0aW9uKCl7cmV0dXJuIGR9KSx0LmQoZSwiZ2V0UmVhbCIsZnVuY3Rpb24oKXtyZXR1cm4geX0pLHQuZChlLCJnZXREdWFsIixmdW5jdGlvbigpe3JldHVybiByfSksdC5kKGUsInNldFJlYWwiLGZ1bmN0aW9uKCl7cmV0dXJuIHN9KSx0LmQoZSwic2V0RHVhbCIsZnVuY3Rpb24oKXtyZXR1cm4gbn0pLHQuZChlLCJnZXRUcmFuc2xhdGlvbiIsZnVuY3Rpb24oKXtyZXR1cm4gYX0pLHQuZChlLCJ0cmFuc2xhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIE99KSx0LmQoZSwicm90YXRlWCIsZnVuY3Rpb24oKXtyZXR1cm4gQX0pLHQuZChlLCJyb3RhdGVZIixmdW5jdGlvbigpe3JldHVybiBifSksdC5kKGUsInJvdGF0ZVoiLGZ1bmN0aW9uKCl7cmV0dXJuIEl9KSx0LmQoZSwicm90YXRlQnlRdWF0QXBwZW5kIixmdW5jdGlvbigpe3JldHVybiBQfSksdC5kKGUsInJvdGF0ZUJ5UXVhdFByZXBlbmQiLGZ1bmN0aW9uKCl7cmV0dXJuIER9KSx0LmQoZSwicm90YXRlQXJvdW5kQXhpcyIsZnVuY3Rpb24oKXtyZXR1cm4gTH0pLHQuZChlLCJhZGQiLGZ1bmN0aW9uKCl7cmV0dXJuIFN9KSx0LmQoZSwibXVsdGlwbHkiLGZ1bmN0aW9uKCl7cmV0dXJuIFR9KSx0LmQoZSwibXVsIixmdW5jdGlvbigpe3JldHVybiBqfSksdC5kKGUsInNjYWxlIixmdW5jdGlvbigpe3JldHVybiAkfSksdC5kKGUsImRvdCIsZnVuY3Rpb24oKXtyZXR1cm4gd30pLHQuZChlLCJsZXJwIixmdW5jdGlvbigpe3JldHVybiBKfSksdC5kKGUsImludmVydCIsZnVuY3Rpb24oKXtyZXR1cm4gcX0pLHQuZChlLCJjb25qdWdhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIFd9KSx0LmQoZSwibGVuZ3RoIixmdW5jdGlvbigpe3JldHVybiBLfSksdC5kKGUsImxlbiIsZnVuY3Rpb24oKXtyZXR1cm4gUX0pLHQuZChlLCJzcXVhcmVkTGVuZ3RoIixmdW5jdGlvbigpe3JldHVybiB0dH0pLHQuZChlLCJzcXJMZW4iLGZ1bmN0aW9uKCl7cmV0dXJuIF99KSx0LmQoZSwibm9ybWFsaXplIixmdW5jdGlvbigpe3JldHVybiBzdH0pLHQuZChlLCJzdHIiLGZ1bmN0aW9uKCl7cmV0dXJuIGt9KSx0LmQoZSwiZXhhY3RFcXVhbHMiLGZ1bmN0aW9uKCl7cmV0dXJuIGN0fSksdC5kKGUsImVxdWFscyIsZnVuY3Rpb24oKXtyZXR1cm4gZnR9KTt2YXIgaT10KDIpLG89dCg3KSxnPXQoNik7ZnVuY3Rpb24gdigpe3ZhciBVPW5ldyBpLkFSUkFZX1RZUEUoOCk7cmV0dXJuIGkuQVJSQVlfVFlQRSE9RmxvYXQzMkFycmF5JiYoVVswXT0wLFVbMV09MCxVWzJdPTAsVVs0XT0wLFVbNV09MCxVWzZdPTAsVVs3XT0wKSxVWzNdPTEsVX1mdW5jdGlvbiBjKFUpe3ZhciBGPW5ldyBpLkFSUkFZX1RZUEUoOCk7cmV0dXJuIEZbMF09VVswXSxGWzFdPVVbMV0sRlsyXT1VWzJdLEZbM109VVszXSxGWzRdPVVbNF0sRls1XT1VWzVdLEZbNl09VVs2XSxGWzddPVVbN10sRn1mdW5jdGlvbiBmKFUsRixWLFgsQixHLHUsTSl7dmFyIE49bmV3IGkuQVJSQVlfVFlQRSg4KTtyZXR1cm4gTlswXT1VLE5bMV09RixOWzJdPVYsTlszXT1YLE5bNF09QixOWzVdPUcsTls2XT11LE5bN109TSxOfWZ1bmN0aW9uIGgoVSxGLFYsWCxCLEcsdSl7dmFyIE09bmV3IGkuQVJSQVlfVFlQRSg4KTtNWzBdPVUsTVsxXT1GLE1bMl09VixNWzNdPVg7dmFyIE49QiouNSx6PUcqLjUsSD11Ki41O3JldHVybiBNWzRdPU4qWCt6KlYtSCpGLE1bNV09eipYK0gqVS1OKlYsTVs2XT1IKlgrTipGLXoqVSxNWzddPS1OKlUteipGLUgqVixNfWZ1bmN0aW9uIEUoVSxGLFYpe3ZhciBYPVZbMF0qLjUsQj1WWzFdKi41LEc9VlsyXSouNSx1PUZbMF0sTT1GWzFdLE49RlsyXSx6PUZbM107cmV0dXJuIFVbMF09dSxVWzFdPU0sVVsyXT1OLFVbM109eixVWzRdPVgqeitCKk4tRypNLFVbNV09Qip6K0cqdS1YKk4sVVs2XT1HKnorWCpNLUIqdSxVWzddPS1YKnUtQipNLUcqTixVfWZ1bmN0aW9uIGwoVSxGKXtyZXR1cm4gVVswXT0wLFVbMV09MCxVWzJdPTAsVVszXT0xLFVbNF09RlswXSouNSxVWzVdPUZbMV0qLjUsVVs2XT1GWzJdKi41LFVbN109MCxVfWZ1bmN0aW9uIG0oVSxGKXtyZXR1cm4gVVswXT1GWzBdLFVbMV09RlsxXSxVWzJdPUZbMl0sVVszXT1GWzNdLFVbNF09MCxVWzVdPTAsVVs2XT0wLFVbN109MCxVfWZ1bmN0aW9uIHAoVSxGKXt2YXIgVj1vLmNyZWF0ZSgpO2cuZ2V0Um90YXRpb24oVixGKTt2YXIgWD1uZXcgaS5BUlJBWV9UWVBFKDMpO3JldHVybiBnLmdldFRyYW5zbGF0aW9uKFgsRiksRShVLFYsWCksVX1mdW5jdGlvbiBDKFUsRil7cmV0dXJuIFVbMF09RlswXSxVWzFdPUZbMV0sVVsyXT1GWzJdLFVbM109RlszXSxVWzRdPUZbNF0sVVs1XT1GWzVdLFVbNl09Rls2XSxVWzddPUZbN10sVX1mdW5jdGlvbiB4KFUpe3JldHVybiBVWzBdPTAsVVsxXT0wLFVbMl09MCxVWzNdPTEsVVs0XT0wLFVbNV09MCxVWzZdPTAsVVs3XT0wLFV9ZnVuY3Rpb24gZChVLEYsVixYLEIsRyx1LE0sTil7cmV0dXJuIFVbMF09RixVWzFdPVYsVVsyXT1YLFVbM109QixVWzRdPUcsVVs1XT11LFVbNl09TSxVWzddPU4sVX12YXIgeT1vLmNvcHk7ZnVuY3Rpb24gcihVLEYpe3JldHVybiBVWzBdPUZbNF0sVVsxXT1GWzVdLFVbMl09Rls2XSxVWzNdPUZbN10sVX12YXIgcz1vLmNvcHk7ZnVuY3Rpb24gbihVLEYpe3JldHVybiBVWzRdPUZbMF0sVVs1XT1GWzFdLFVbNl09RlsyXSxVWzddPUZbM10sVX1mdW5jdGlvbiBhKFUsRil7dmFyIFY9Rls0XSxYPUZbNV0sQj1GWzZdLEc9Rls3XSx1PS1GWzBdLE09LUZbMV0sTj0tRlsyXSx6PUZbM107cmV0dXJuIFVbMF09KFYqeitHKnUrWCpOLUIqTSkqMixVWzFdPShYKnorRypNK0IqdS1WKk4pKjIsVVsyXT0oQip6K0cqTitWKk0tWCp1KSoyLFV9ZnVuY3Rpb24gTyhVLEYsVil7dmFyIFg9RlswXSxCPUZbMV0sRz1GWzJdLHU9RlszXSxNPVZbMF0qLjUsTj1WWzFdKi41LHo9VlsyXSouNSxIPUZbNF0sWT1GWzVdLFo9Rls2XSxldD1GWzddO3JldHVybiBVWzBdPVgsVVsxXT1CLFVbMl09RyxVWzNdPXUsVVs0XT11Kk0rQip6LUcqTitILFVbNV09dSpOK0cqTS1YKnorWSxVWzZdPXUqeitYKk4tQipNK1osVVs3XT0tWCpNLUIqTi1HKnorZXQsVX1mdW5jdGlvbiBBKFUsRixWKXt2YXIgWD0tRlswXSxCPS1GWzFdLEc9LUZbMl0sdT1GWzNdLE09Rls0XSxOPUZbNV0sej1GWzZdLEg9Rls3XSxZPU0qdStIKlgrTipHLXoqQixaPU4qdStIKkIreipYLU0qRyxldD16KnUrSCpHK00qQi1OKlgscnQ9SCp1LU0qWC1OKkIteipHO3JldHVybiBvLnJvdGF0ZVgoVSxGLFYpLFg9VVswXSxCPVVbMV0sRz1VWzJdLHU9VVszXSxVWzRdPVkqdStydCpYK1oqRy1ldCpCLFVbNV09Wip1K3J0KkIrZXQqWC1ZKkcsVVs2XT1ldCp1K3J0KkcrWSpCLVoqWCxVWzddPXJ0KnUtWSpYLVoqQi1ldCpHLFV9ZnVuY3Rpb24gYihVLEYsVil7dmFyIFg9LUZbMF0sQj0tRlsxXSxHPS1GWzJdLHU9RlszXSxNPUZbNF0sTj1GWzVdLHo9Rls2XSxIPUZbN10sWT1NKnUrSCpYK04qRy16KkIsWj1OKnUrSCpCK3oqWC1NKkcsZXQ9eip1K0gqRytNKkItTipYLHJ0PUgqdS1NKlgtTipCLXoqRztyZXR1cm4gby5yb3RhdGVZKFUsRixWKSxYPVVbMF0sQj1VWzFdLEc9VVsyXSx1PVVbM10sVVs0XT1ZKnUrcnQqWCtaKkctZXQqQixVWzVdPVoqdStydCpCK2V0KlgtWSpHLFVbNl09ZXQqdStydCpHK1kqQi1aKlgsVVs3XT1ydCp1LVkqWC1aKkItZXQqRyxVfWZ1bmN0aW9uIEkoVSxGLFYpe3ZhciBYPS1GWzBdLEI9LUZbMV0sRz0tRlsyXSx1PUZbM10sTT1GWzRdLE49Rls1XSx6PUZbNl0sSD1GWzddLFk9TSp1K0gqWCtOKkcteipCLFo9Tip1K0gqQit6KlgtTSpHLGV0PXoqdStIKkcrTSpCLU4qWCxydD1IKnUtTSpYLU4qQi16Kkc7cmV0dXJuIG8ucm90YXRlWihVLEYsViksWD1VWzBdLEI9VVsxXSxHPVVbMl0sdT1VWzNdLFVbNF09WSp1K3J0KlgrWipHLWV0KkIsVVs1XT1aKnUrcnQqQitldCpYLVkqRyxVWzZdPWV0KnUrcnQqRytZKkItWipYLFVbN109cnQqdS1ZKlgtWipCLWV0KkcsVX1mdW5jdGlvbiBQKFUsRixWKXt2YXIgWD1WWzBdLEI9VlsxXSxHPVZbMl0sdT1WWzNdLE09RlswXSxOPUZbMV0sej1GWzJdLEg9RlszXTtyZXR1cm4gVVswXT1NKnUrSCpYK04qRy16KkIsVVsxXT1OKnUrSCpCK3oqWC1NKkcsVVsyXT16KnUrSCpHK00qQi1OKlgsVVszXT1IKnUtTSpYLU4qQi16KkcsTT1GWzRdLE49Rls1XSx6PUZbNl0sSD1GWzddLFVbNF09TSp1K0gqWCtOKkcteipCLFVbNV09Tip1K0gqQit6KlgtTSpHLFVbNl09eip1K0gqRytNKkItTipYLFVbN109SCp1LU0qWC1OKkIteipHLFV9ZnVuY3Rpb24gRChVLEYsVil7dmFyIFg9RlswXSxCPUZbMV0sRz1GWzJdLHU9RlszXSxNPVZbMF0sTj1WWzFdLHo9VlsyXSxIPVZbM107cmV0dXJuIFVbMF09WCpIK3UqTStCKnotRypOLFVbMV09QipIK3UqTitHKk0tWCp6LFVbMl09RypIK3UqeitYKk4tQipNLFVbM109dSpILVgqTS1CKk4tRyp6LE09Vls0XSxOPVZbNV0sej1WWzZdLEg9Vls3XSxVWzRdPVgqSCt1Kk0rQip6LUcqTixVWzVdPUIqSCt1Kk4rRypNLVgqeixVWzZdPUcqSCt1KnorWCpOLUIqTSxVWzddPXUqSC1YKk0tQipOLUcqeixVfWZ1bmN0aW9uIEwoVSxGLFYsWCl7aWYoTWF0aC5hYnMoWCk8aS5FUFNJTE9OKXJldHVybiBDKFUsRik7dmFyIEI9TWF0aC5oeXBvdChWWzBdLFZbMV0sVlsyXSk7WD1YKi41O3ZhciBHPU1hdGguc2luKFgpLHU9RypWWzBdL0IsTT1HKlZbMV0vQixOPUcqVlsyXS9CLHo9TWF0aC5jb3MoWCksSD1GWzBdLFk9RlsxXSxaPUZbMl0sZXQ9RlszXTtVWzBdPUgqeitldCp1K1kqTi1aKk0sVVsxXT1ZKnorZXQqTStaKnUtSCpOLFVbMl09Wip6K2V0Kk4rSCpNLVkqdSxVWzNdPWV0KnotSCp1LVkqTS1aKk47dmFyIHJ0PUZbNF0sb3Q9Rls1XSxsdD1GWzZdLGl0PUZbN107cmV0dXJuIFVbNF09cnQqeitpdCp1K290Kk4tbHQqTSxVWzVdPW90KnoraXQqTStsdCp1LXJ0Kk4sVVs2XT1sdCp6K2l0Kk4rcnQqTS1vdCp1LFVbN109aXQqei1ydCp1LW90Kk0tbHQqTixVfWZ1bmN0aW9uIFMoVSxGLFYpe3JldHVybiBVWzBdPUZbMF0rVlswXSxVWzFdPUZbMV0rVlsxXSxVWzJdPUZbMl0rVlsyXSxVWzNdPUZbM10rVlszXSxVWzRdPUZbNF0rVls0XSxVWzVdPUZbNV0rVls1XSxVWzZdPUZbNl0rVls2XSxVWzddPUZbN10rVls3XSxVfWZ1bmN0aW9uIFQoVSxGLFYpe3ZhciBYPUZbMF0sQj1GWzFdLEc9RlsyXSx1PUZbM10sTT1WWzRdLE49Vls1XSx6PVZbNl0sSD1WWzddLFk9Rls0XSxaPUZbNV0sZXQ9Rls2XSxydD1GWzddLG90PVZbMF0sbHQ9VlsxXSxpdD1WWzJdLG50PVZbM107cmV0dXJuIFVbMF09WCpudCt1Km90K0IqaXQtRypsdCxVWzFdPUIqbnQrdSpsdCtHKm90LVgqaXQsVVsyXT1HKm50K3UqaXQrWCpsdC1CKm90LFVbM109dSpudC1YKm90LUIqbHQtRyppdCxVWzRdPVgqSCt1Kk0rQip6LUcqTitZKm50K3J0Km90K1oqaXQtZXQqbHQsVVs1XT1CKkgrdSpOK0cqTS1YKnorWipudCtydCpsdCtldCpvdC1ZKml0LFVbNl09RypIK3UqeitYKk4tQipNK2V0Km50K3J0Kml0K1kqbHQtWipvdCxVWzddPXUqSC1YKk0tQipOLUcqeitydCpudC1ZKm90LVoqbHQtZXQqaXQsVX12YXIgaj1UO2Z1bmN0aW9uICQoVSxGLFYpe3JldHVybiBVWzBdPUZbMF0qVixVWzFdPUZbMV0qVixVWzJdPUZbMl0qVixVWzNdPUZbM10qVixVWzRdPUZbNF0qVixVWzVdPUZbNV0qVixVWzZdPUZbNl0qVixVWzddPUZbN10qVixVfXZhciB3PW8uZG90O2Z1bmN0aW9uIEooVSxGLFYsWCl7dmFyIEI9MS1YO3JldHVybiB3KEYsVik8MCYmKFg9LVgpLFVbMF09RlswXSpCK1ZbMF0qWCxVWzFdPUZbMV0qQitWWzFdKlgsVVsyXT1GWzJdKkIrVlsyXSpYLFVbM109RlszXSpCK1ZbM10qWCxVWzRdPUZbNF0qQitWWzRdKlgsVVs1XT1GWzVdKkIrVls1XSpYLFVbNl09Rls2XSpCK1ZbNl0qWCxVWzddPUZbN10qQitWWzddKlgsVX1mdW5jdGlvbiBxKFUsRil7dmFyIFY9dHQoRik7cmV0dXJuIFVbMF09LUZbMF0vVixVWzFdPS1GWzFdL1YsVVsyXT0tRlsyXS9WLFVbM109RlszXS9WLFVbNF09LUZbNF0vVixVWzVdPS1GWzVdL1YsVVs2XT0tRls2XS9WLFVbN109Rls3XS9WLFV9ZnVuY3Rpb24gVyhVLEYpe3JldHVybiBVWzBdPS1GWzBdLFVbMV09LUZbMV0sVVsyXT0tRlsyXSxVWzNdPUZbM10sVVs0XT0tRls0XSxVWzVdPS1GWzVdLFVbNl09LUZbNl0sVVs3XT1GWzddLFV9dmFyIEs9by5sZW5ndGgsUT1LLHR0PW8uc3F1YXJlZExlbmd0aCxfPXR0O2Z1bmN0aW9uIHN0KFUsRil7dmFyIFY9dHQoRik7aWYoVj4wKXtWPU1hdGguc3FydChWKTt2YXIgWD1GWzBdL1YsQj1GWzFdL1YsRz1GWzJdL1YsdT1GWzNdL1YsTT1GWzRdLE49Rls1XSx6PUZbNl0sSD1GWzddLFk9WCpNK0IqTitHKnordSpIO1VbMF09WCxVWzFdPUIsVVsyXT1HLFVbM109dSxVWzRdPShNLVgqWSkvVixVWzVdPShOLUIqWSkvVixVWzZdPSh6LUcqWSkvVixVWzddPShILXUqWSkvVn1yZXR1cm4gVX1mdW5jdGlvbiBrKFUpe3JldHVybiJxdWF0MigiK1VbMF0rIiwgIitVWzFdKyIsICIrVVsyXSsiLCAiK1VbM10rIiwgIitVWzRdKyIsICIrVVs1XSsiLCAiK1VbNl0rIiwgIitVWzddKyIpIn1mdW5jdGlvbiBjdChVLEYpe3JldHVybiBVWzBdPT09RlswXSYmVVsxXT09PUZbMV0mJlVbMl09PT1GWzJdJiZVWzNdPT09RlszXSYmVVs0XT09PUZbNF0mJlVbNV09PT1GWzVdJiZVWzZdPT09Rls2XSYmVVs3XT09PUZbN119ZnVuY3Rpb24gZnQoVSxGKXt2YXIgVj1VWzBdLFg9VVsxXSxCPVVbMl0sRz1VWzNdLHU9VVs0XSxNPVVbNV0sTj1VWzZdLHo9VVs3XSxIPUZbMF0sWT1GWzFdLFo9RlsyXSxldD1GWzNdLHJ0PUZbNF0sb3Q9Rls1XSxsdD1GWzZdLGl0PUZbN107cmV0dXJuIE1hdGguYWJzKFYtSCk8PWkuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKFYpLE1hdGguYWJzKEgpKSYmTWF0aC5hYnMoWC1ZKTw9aS5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoWCksTWF0aC5hYnMoWSkpJiZNYXRoLmFicyhCLVopPD1pLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhCKSxNYXRoLmFicyhaKSkmJk1hdGguYWJzKEctZXQpPD1pLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhHKSxNYXRoLmFicyhldCkpJiZNYXRoLmFicyh1LXJ0KTw9aS5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnModSksTWF0aC5hYnMocnQpKSYmTWF0aC5hYnMoTS1vdCk8PWkuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKE0pLE1hdGguYWJzKG90KSkmJk1hdGguYWJzKE4tbHQpPD1pLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhOKSxNYXRoLmFicyhsdCkpJiZNYXRoLmFicyh6LWl0KTw9aS5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoeiksTWF0aC5hYnMoaXQpKX19LGZ1bmN0aW9uKFIsZSx0KXt0LnIoZSksdC5kKGUsImNyZWF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gb30pLHQuZChlLCJjbG9uZSIsZnVuY3Rpb24oKXtyZXR1cm4gZ30pLHQuZChlLCJmcm9tVmFsdWVzIixmdW5jdGlvbigpe3JldHVybiB2fSksdC5kKGUsImNvcHkiLGZ1bmN0aW9uKCl7cmV0dXJuIGN9KSx0LmQoZSwic2V0IixmdW5jdGlvbigpe3JldHVybiBmfSksdC5kKGUsImFkZCIsZnVuY3Rpb24oKXtyZXR1cm4gaH0pLHQuZChlLCJzdWJ0cmFjdCIsZnVuY3Rpb24oKXtyZXR1cm4gRX0pLHQuZChlLCJtdWx0aXBseSIsZnVuY3Rpb24oKXtyZXR1cm4gbH0pLHQuZChlLCJkaXZpZGUiLGZ1bmN0aW9uKCl7cmV0dXJuIG19KSx0LmQoZSwiY2VpbCIsZnVuY3Rpb24oKXtyZXR1cm4gcH0pLHQuZChlLCJmbG9vciIsZnVuY3Rpb24oKXtyZXR1cm4gQ30pLHQuZChlLCJtaW4iLGZ1bmN0aW9uKCl7cmV0dXJuIHh9KSx0LmQoZSwibWF4IixmdW5jdGlvbigpe3JldHVybiBkfSksdC5kKGUsInJvdW5kIixmdW5jdGlvbigpe3JldHVybiB5fSksdC5kKGUsInNjYWxlIixmdW5jdGlvbigpe3JldHVybiByfSksdC5kKGUsInNjYWxlQW5kQWRkIixmdW5jdGlvbigpe3JldHVybiBzfSksdC5kKGUsImRpc3RhbmNlIixmdW5jdGlvbigpe3JldHVybiBufSksdC5kKGUsInNxdWFyZWREaXN0YW5jZSIsZnVuY3Rpb24oKXtyZXR1cm4gYX0pLHQuZChlLCJsZW5ndGgiLGZ1bmN0aW9uKCl7cmV0dXJuIE99KSx0LmQoZSwic3F1YXJlZExlbmd0aCIsZnVuY3Rpb24oKXtyZXR1cm4gQX0pLHQuZChlLCJuZWdhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIGJ9KSx0LmQoZSwiaW52ZXJzZSIsZnVuY3Rpb24oKXtyZXR1cm4gSX0pLHQuZChlLCJub3JtYWxpemUiLGZ1bmN0aW9uKCl7cmV0dXJuIFB9KSx0LmQoZSwiZG90IixmdW5jdGlvbigpe3JldHVybiBEfSksdC5kKGUsImNyb3NzIixmdW5jdGlvbigpe3JldHVybiBMfSksdC5kKGUsImxlcnAiLGZ1bmN0aW9uKCl7cmV0dXJuIFN9KSx0LmQoZSwicmFuZG9tIixmdW5jdGlvbigpe3JldHVybiBUfSksdC5kKGUsInRyYW5zZm9ybU1hdDIiLGZ1bmN0aW9uKCl7cmV0dXJuIGp9KSx0LmQoZSwidHJhbnNmb3JtTWF0MmQiLGZ1bmN0aW9uKCl7cmV0dXJuICR9KSx0LmQoZSwidHJhbnNmb3JtTWF0MyIsZnVuY3Rpb24oKXtyZXR1cm4gd30pLHQuZChlLCJ0cmFuc2Zvcm1NYXQ0IixmdW5jdGlvbigpe3JldHVybiBKfSksdC5kKGUsInJvdGF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gcX0pLHQuZChlLCJhbmdsZSIsZnVuY3Rpb24oKXtyZXR1cm4gV30pLHQuZChlLCJ6ZXJvIixmdW5jdGlvbigpe3JldHVybiBLfSksdC5kKGUsInN0ciIsZnVuY3Rpb24oKXtyZXR1cm4gUX0pLHQuZChlLCJleGFjdEVxdWFscyIsZnVuY3Rpb24oKXtyZXR1cm4gdHR9KSx0LmQoZSwiZXF1YWxzIixmdW5jdGlvbigpe3JldHVybiBffSksdC5kKGUsImxlbiIsZnVuY3Rpb24oKXtyZXR1cm4gc3R9KSx0LmQoZSwic3ViIixmdW5jdGlvbigpe3JldHVybiBrfSksdC5kKGUsIm11bCIsZnVuY3Rpb24oKXtyZXR1cm4gY3R9KSx0LmQoZSwiZGl2IixmdW5jdGlvbigpe3JldHVybiBmdH0pLHQuZChlLCJkaXN0IixmdW5jdGlvbigpe3JldHVybiBVfSksdC5kKGUsInNxckRpc3QiLGZ1bmN0aW9uKCl7cmV0dXJuIEZ9KSx0LmQoZSwic3FyTGVuIixmdW5jdGlvbigpe3JldHVybiBWfSksdC5kKGUsImZvckVhY2giLGZ1bmN0aW9uKCl7cmV0dXJuIFh9KTt2YXIgaT10KDIpO2Z1bmN0aW9uIG8oKXt2YXIgQj1uZXcgaS5BUlJBWV9UWVBFKDIpO3JldHVybiBpLkFSUkFZX1RZUEUhPUZsb2F0MzJBcnJheSYmKEJbMF09MCxCWzFdPTApLEJ9ZnVuY3Rpb24gZyhCKXt2YXIgRz1uZXcgaS5BUlJBWV9UWVBFKDIpO3JldHVybiBHWzBdPUJbMF0sR1sxXT1CWzFdLEd9ZnVuY3Rpb24gdihCLEcpe3ZhciB1PW5ldyBpLkFSUkFZX1RZUEUoMik7cmV0dXJuIHVbMF09Qix1WzFdPUcsdX1mdW5jdGlvbiBjKEIsRyl7cmV0dXJuIEJbMF09R1swXSxCWzFdPUdbMV0sQn1mdW5jdGlvbiBmKEIsRyx1KXtyZXR1cm4gQlswXT1HLEJbMV09dSxCfWZ1bmN0aW9uIGgoQixHLHUpe3JldHVybiBCWzBdPUdbMF0rdVswXSxCWzFdPUdbMV0rdVsxXSxCfWZ1bmN0aW9uIEUoQixHLHUpe3JldHVybiBCWzBdPUdbMF0tdVswXSxCWzFdPUdbMV0tdVsxXSxCfWZ1bmN0aW9uIGwoQixHLHUpe3JldHVybiBCWzBdPUdbMF0qdVswXSxCWzFdPUdbMV0qdVsxXSxCfWZ1bmN0aW9uIG0oQixHLHUpe3JldHVybiBCWzBdPUdbMF0vdVswXSxCWzFdPUdbMV0vdVsxXSxCfWZ1bmN0aW9uIHAoQixHKXtyZXR1cm4gQlswXT1NYXRoLmNlaWwoR1swXSksQlsxXT1NYXRoLmNlaWwoR1sxXSksQn1mdW5jdGlvbiBDKEIsRyl7cmV0dXJuIEJbMF09TWF0aC5mbG9vcihHWzBdKSxCWzFdPU1hdGguZmxvb3IoR1sxXSksQn1mdW5jdGlvbiB4KEIsRyx1KXtyZXR1cm4gQlswXT1NYXRoLm1pbihHWzBdLHVbMF0pLEJbMV09TWF0aC5taW4oR1sxXSx1WzFdKSxCfWZ1bmN0aW9uIGQoQixHLHUpe3JldHVybiBCWzBdPU1hdGgubWF4KEdbMF0sdVswXSksQlsxXT1NYXRoLm1heChHWzFdLHVbMV0pLEJ9ZnVuY3Rpb24geShCLEcpe3JldHVybiBCWzBdPU1hdGgucm91bmQoR1swXSksQlsxXT1NYXRoLnJvdW5kKEdbMV0pLEJ9ZnVuY3Rpb24gcihCLEcsdSl7cmV0dXJuIEJbMF09R1swXSp1LEJbMV09R1sxXSp1LEJ9ZnVuY3Rpb24gcyhCLEcsdSxNKXtyZXR1cm4gQlswXT1HWzBdK3VbMF0qTSxCWzFdPUdbMV0rdVsxXSpNLEJ9ZnVuY3Rpb24gbihCLEcpe3ZhciB1PUdbMF0tQlswXSxNPUdbMV0tQlsxXTtyZXR1cm4gTWF0aC5oeXBvdCh1LE0pfWZ1bmN0aW9uIGEoQixHKXt2YXIgdT1HWzBdLUJbMF0sTT1HWzFdLUJbMV07cmV0dXJuIHUqdStNKk19ZnVuY3Rpb24gTyhCKXt2YXIgRz1CWzBdLHU9QlsxXTtyZXR1cm4gTWF0aC5oeXBvdChHLHUpfWZ1bmN0aW9uIEEoQil7dmFyIEc9QlswXSx1PUJbMV07cmV0dXJuIEcqRyt1KnV9ZnVuY3Rpb24gYihCLEcpe3JldHVybiBCWzBdPS1HWzBdLEJbMV09LUdbMV0sQn1mdW5jdGlvbiBJKEIsRyl7cmV0dXJuIEJbMF09MS9HWzBdLEJbMV09MS9HWzFdLEJ9ZnVuY3Rpb24gUChCLEcpe3ZhciB1PUdbMF0sTT1HWzFdLE49dSp1K00qTTtyZXR1cm4gTj4wJiYoTj0xL01hdGguc3FydChOKSksQlswXT1HWzBdKk4sQlsxXT1HWzFdKk4sQn1mdW5jdGlvbiBEKEIsRyl7cmV0dXJuIEJbMF0qR1swXStCWzFdKkdbMV19ZnVuY3Rpb24gTChCLEcsdSl7dmFyIE09R1swXSp1WzFdLUdbMV0qdVswXTtyZXR1cm4gQlswXT1CWzFdPTAsQlsyXT1NLEJ9ZnVuY3Rpb24gUyhCLEcsdSxNKXt2YXIgTj1HWzBdLHo9R1sxXTtyZXR1cm4gQlswXT1OK00qKHVbMF0tTiksQlsxXT16K00qKHVbMV0teiksQn1mdW5jdGlvbiBUKEIsRyl7Rz1HfHwxO3ZhciB1PWkuUkFORE9NKCkqMipNYXRoLlBJO3JldHVybiBCWzBdPU1hdGguY29zKHUpKkcsQlsxXT1NYXRoLnNpbih1KSpHLEJ9ZnVuY3Rpb24gaihCLEcsdSl7dmFyIE09R1swXSxOPUdbMV07cmV0dXJuIEJbMF09dVswXSpNK3VbMl0qTixCWzFdPXVbMV0qTSt1WzNdKk4sQn1mdW5jdGlvbiAkKEIsRyx1KXt2YXIgTT1HWzBdLE49R1sxXTtyZXR1cm4gQlswXT11WzBdKk0rdVsyXSpOK3VbNF0sQlsxXT11WzFdKk0rdVszXSpOK3VbNV0sQn1mdW5jdGlvbiB3KEIsRyx1KXt2YXIgTT1HWzBdLE49R1sxXTtyZXR1cm4gQlswXT11WzBdKk0rdVszXSpOK3VbNl0sQlsxXT11WzFdKk0rdVs0XSpOK3VbN10sQn1mdW5jdGlvbiBKKEIsRyx1KXt2YXIgTT1HWzBdLE49R1sxXTtyZXR1cm4gQlswXT11WzBdKk0rdVs0XSpOK3VbMTJdLEJbMV09dVsxXSpNK3VbNV0qTit1WzEzXSxCfWZ1bmN0aW9uIHEoQixHLHUsTSl7dmFyIE49R1swXS11WzBdLHo9R1sxXS11WzFdLEg9TWF0aC5zaW4oTSksWT1NYXRoLmNvcyhNKTtyZXR1cm4gQlswXT1OKlkteipIK3VbMF0sQlsxXT1OKkgreipZK3VbMV0sQn1mdW5jdGlvbiBXKEIsRyl7dmFyIHU9QlswXSxNPUJbMV0sTj1HWzBdLHo9R1sxXSxIPU1hdGguc3FydCh1KnUrTSpNKSpNYXRoLnNxcnQoTipOK3oqeiksWT1IJiYodSpOK00qeikvSDtyZXR1cm4gTWF0aC5hY29zKE1hdGgubWluKE1hdGgubWF4KFksLTEpLDEpKX1mdW5jdGlvbiBLKEIpe3JldHVybiBCWzBdPTAsQlsxXT0wLEJ9ZnVuY3Rpb24gUShCKXtyZXR1cm4idmVjMigiK0JbMF0rIiwgIitCWzFdKyIpIn1mdW5jdGlvbiB0dChCLEcpe3JldHVybiBCWzBdPT09R1swXSYmQlsxXT09PUdbMV19ZnVuY3Rpb24gXyhCLEcpe3ZhciB1PUJbMF0sTT1CWzFdLE49R1swXSx6PUdbMV07cmV0dXJuIE1hdGguYWJzKHUtTik8PWkuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKHUpLE1hdGguYWJzKE4pKSYmTWF0aC5hYnMoTS16KTw9aS5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoTSksTWF0aC5hYnMoeikpfXZhciBzdD1PLGs9RSxjdD1sLGZ0PW0sVT1uLEY9YSxWPUEsWD1mdW5jdGlvbigpe3ZhciBCPW8oKTtyZXR1cm4gZnVuY3Rpb24oRyx1LE0sTix6LEgpe3ZhciBZLFo7Zm9yKHV8fCh1PTIpLE18fChNPTApLE4/Wj1NYXRoLm1pbihOKnUrTSxHLmxlbmd0aCk6Wj1HLmxlbmd0aCxZPU07WTxaO1krPXUpQlswXT1HW1ldLEJbMV09R1tZKzFdLHooQixCLEgpLEdbWV09QlswXSxHW1krMV09QlsxXTtyZXR1cm4gR319KCl9LGZ1bmN0aW9uKFIsZSx0KXt0LnIoZSk7dmFyIGk9dCgxMyk7dC5kKGUsIlJlbmRlcmVyIixmdW5jdGlvbigpe3JldHVybiBpLmRlZmF1bHR9KTt2YXIgbz10KDQwKTt0LmQoZSwiRmlndXJlMkQiLGZ1bmN0aW9uKCl7cmV0dXJuIG8uZGVmYXVsdH0pO3ZhciBnPXQoNTYpO3QuZChlLCJNZXNoMkQiLGZ1bmN0aW9uKCl7cmV0dXJuIGcuZGVmYXVsdH0pO3ZhciB2PXQoMjkpO3QuZChlLCJNZXNoQ2xvdWQiLGZ1bmN0aW9uKCl7cmV0dXJuIHYuZGVmYXVsdH0pO3ZhciBjPXQoMjMpO3QuZChlLCJwYXJzZUZvbnQiLGZ1bmN0aW9uKCl7cmV0dXJuIGMuZGVmYXVsdH0pO3ZhciBmPXQoMzEpO3QuZChlLCJwYXJzZUNvbG9yIixmdW5jdGlvbigpe3JldHVybiBmLmRlZmF1bHR9KTt2YXIgaD10KDIxKTt0LmQoZSwiRU5WIixmdW5jdGlvbigpe3JldHVybiBoLmRlZmF1bHR9KSx0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSl9LGZ1bmN0aW9uKFIsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIEl9KTt2YXIgaT10KDE0KSxvPXQoMSksZz10KDIwKSx2PXQoMjcpLGM9dCgyNSksZj10KDQwKSxoPXQoNTYpLEU9dCgyOSksbD10KDU5KSxtPXQoMjEpLHA9dCg2Myk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IEM9e2F1dG9VcGRhdGU6ITEscHJlc2VydmVEcmF3aW5nQnVmZmVyOiExLGJ1ZmZlclNpemU6MTUwMH0seD1gYXR0cmlidXRlIHZlYzMgYV92ZXJ0ZXhQb3NpdGlvbjsKYXR0cmlidXRlIHZlYzMgYV92ZXJ0ZXhUZXh0dXJlQ29vcmQ7CnZhcnlpbmcgdmVjMyB2VGV4dHVyZUNvb3JkOwp1bmlmb3JtIG1hdDMgdmlld01hdHJpeDsKdW5pZm9ybSBtYXQzIHByb2plY3Rpb25NYXRyaXg7Cgp2b2lkIG1haW4oKSB7CiAgZ2xfUG9pbnRTaXplID0gMS4wOwogIHZlYzMgcG9zID0gcHJvamVjdGlvbk1hdHJpeCAqIHZpZXdNYXRyaXggKiB2ZWMzKGFfdmVydGV4UG9zaXRpb24ueHksIDEuMCk7CiAgZ2xfUG9zaXRpb24gPSB2ZWM0KHBvcy54eSwgMS4wLCAxLjApOyAgICAKICB2VGV4dHVyZUNvb3JkID0gYV92ZXJ0ZXhUZXh0dXJlQ29vcmQ7ICAgICAgICAgICAgICAKfQpgLGQ9YHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0Owp2YXJ5aW5nIHZlYzMgdlRleHR1cmVDb29yZDsKdW5pZm9ybSBzYW1wbGVyMkQgdV90ZXhTYW1wbGVyOwp2b2lkIG1haW4oKSB7CiAgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKHVfdGV4U2FtcGxlciwgdlRleHR1cmVDb29yZC54eSk7Cn0KYCx5PVN5bWJvbCgiZ2xSZW5kZXJlciIpLHI9U3ltYm9sKCJjYW52YXNSZW5kZXJlciIpLHM9U3ltYm9sKCJvcHRpb25zIiksbj1TeW1ib2woImdsb2JhbFRyYW5zZm9ybSIpLGE9U3ltYm9sKCJhcHBseUdsb2JhbFRyYW5zZm9ybSIpLE89U3ltYm9sKCJjYW52YXMiKTtmdW5jdGlvbiBBKFApe2NvbnN0IEQ9UC5nbCxMPVAuZmJvO0wmJkQuYmluZEZyYW1lYnVmZmVyKEQuRlJBTUVCVUZGRVIsTCksUC5fZHJhdygpLEwmJkQuYmluZEZyYW1lYnVmZmVyKEQuRlJBTUVCVUZGRVIsbnVsbCl9ZnVuY3Rpb24gYihQLEQsTCxTKXtjb25zdCBUPVAuY3JlYXRlVGV4dHVyZShELmNhbnZhcyksaj1bW1swLDBdLFtMLDBdLFtMLFNdLFswLFNdLFswLDBdXV07ai5jbG9zZWQ9ITA7Y29uc3QgJD1uZXcgaC5kZWZhdWx0KHtjb250b3VyczpqfSk7JC5zZXRUZXh0dXJlKFQpLFAuc2V0TWVzaERhdGEoWyQubWVzaERhdGFdKSxBKFApLFQuZGVsZXRlKCksRC5jbGVhclJlY3QoMCwwLEwsUyksZGVsZXRlIEQuX2ZpbHRlcn1jbGFzcyBJe2NvbnN0cnVjdG9yKEQsTD17fSl7bGV0IFM9TC5jb250ZXh0VHlwZTtpZihTfHwodHlwZW9mIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQ9PSJmdW5jdGlvbiI/Uz0id2ViZ2wyIjp0eXBlb2YgV2ViR0xSZW5kZXJpbmdDb250ZXh0PT0iZnVuY3Rpb24iP1M9IndlYmdsIjpTPSIyZCIpLCFELmdldENvbnRleHQpe2NvbnN0IFQ9RDtEPXtnZXRDb250ZXh0KCl7cmV0dXJuIFR9LHdpZHRoOkwud2lkdGgsaGVpZ2h0OkwuaGVpZ2h0fSxULmNhbnZhcz1ELFM9IjJkIn1pZih0aGlzW09dPUQsUyE9PSJ3ZWJnbCImJlMhPT0id2ViZ2wyIiYmUyE9PSIyZCIpdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGNvbnRleHQgdHlwZSAke1N9YCk7aWYoTC5jb250ZXh0VHlwZT1TLHRoaXNbc109T2JqZWN0LmFzc2lnbih7fSxDLEwpLFM9PT0id2ViZ2wifHxTPT09IndlYmdsMiIpe1M9PT0id2ViZ2wyIiYmKHRoaXNbc10ud2ViZ2wyPSEwKTtjb25zdCBUPW5ldyBpLmRlZmF1bHQoRCx0aGlzW3NdKTtTPT09IndlYmdsMiImJiFULmlzV2ViR0wyJiYoTC5jb250ZXh0VHlwZT0id2ViZ2wiKSxPYmplY3QocC5jcmVhdGVTaGFkZXJzKShUKSxPYmplY3QocC5hcHBseVNoYWRlcikoVCksT2JqZWN0KHAuY3JlYXRlQ2xvdWRTaGFkZXJzKShUKTtjb25zdCBqPVQuZ2w7ai5jbGVhckNvbG9yKDAsMCwwLDApLGouYmxlbmRGdW5jU2VwYXJhdGUoai5TUkNfQUxQSEEsai5PTkVfTUlOVVNfU1JDX0FMUEhBLGouT05FLGouT05FX01JTlVTX1NSQ19BTFBIQSksdGhpc1t5XT1UfWVsc2UgdGhpc1tyXT1uZXcgZy5kZWZhdWx0KEQsdGhpc1tzXSk7dGhpc1tuXT1bMSwwLDAsMCwxLDAsMCwwLDFdLHRoaXMudXBkYXRlUmVzb2x1dGlvbigpfWdldCBjYW52YXMoKXtyZXR1cm4gdGhpc1tPXX1nZXQgY2FudmFzUmVuZGVyZXIoKXtyZXR1cm4gdGhpc1tyXX1nZXQgZ2xSZW5kZXJlcigpe3JldHVybiB0aGlzW3ldfWdldCBpc1dlYkdMMigpe3JldHVybiB0aGlzW3ldJiZ0aGlzW3ldLmlzV2ViR0wyfWdldCBvcHRpb25zKCl7cmV0dXJuIHRoaXNbc119Z2V0IGdsb2JhbFRyYW5zZm9ybU1hdHJpeCgpe2NvbnN0IEQ9dGhpc1tuXTtyZXR1cm5bRFswXSxEWzFdLERbM10sRFs0XSxEWzZdLERbN11dfWdldCB2aWV3TWF0cml4KCl7cmV0dXJuIHRoaXNbbl19W2FdKCl7Y29uc3QgRD10aGlzW3ldfHx0aGlzW3JdO2lmKHRoaXNbeV0pe2NvbnN0e3dpZHRoOkwsaGVpZ2h0OlN9PXRoaXMuY2FudmFzO0QudW5pZm9ybXMudmlld01hdHJpeD10aGlzLnZpZXdNYXRyaXgsRC51bmlmb3Jtcy5wcm9qZWN0aW9uTWF0cml4PXRoaXMucHJvamVjdGlvbk1hdHJpeCxELnVuaWZvcm1zLnVfcmVzb2x1dGlvbj1bTCxTXX19dXBkYXRlUmVzb2x1dGlvbigpe2NvbnN0e3dpZHRoOkQsaGVpZ2h0Okx9PXRoaXMuY2FudmFzLFM9WzEsMCwwLDAsMSwwLC1ELzIsLUwvMiwxXSxUPVsyL0QsMCwwLDAsLTIvTCwwLDAsMCwxXSxqPW8ubWF0My5tdWx0aXBseShBcnJheS5vZigwLDAsMCwwLDAsMCwwLDAsMCksVCxTKTt0aGlzLnByb2plY3Rpb25NYXRyaXg9aix0aGlzW3ldJiZ0aGlzW3ldLmdsLnZpZXdwb3J0KDAsMCxELEwpfWNyZWF0ZVRleHR1cmUoRCxMKXtyZXR1cm4odGhpc1t5XXx8dGhpc1tyXSkuY3JlYXRlVGV4dHVyZShELEwpfWxvYWRUZXh0dXJlKEQse3VzZUltYWdlQml0bWFwOkw9ITF9PXt9KXtyZXR1cm4odGhpc1t5XXx8dGhpc1tyXSkubG9hZFRleHR1cmUoRCx7dXNlSW1hZ2VCaXRtYXA6TH0pfWNyZWF0ZVRleHQoRCx7Zm9udDpMPSIxNnB4IGFyaWFsIixmaWxsQ29sb3I6Uz1udWxsLHN0cm9rZUNvbG9yOlQ9bnVsbCxzdHJva2VXaWR0aDpqPTF9PXt9KXtpZih0aGlzW3ldKXtjb25zdCAkPW0uZGVmYXVsdC5jcmVhdGVUZXh0KEQse2ZvbnQ6TCxmaWxsQ29sb3I6UyxzdHJva2VDb2xvcjpULHN0cm9rZVdpZHRoOmp9KTtyZXR1cm57aW1hZ2U6dGhpcy5jcmVhdGVUZXh0dXJlKCQuaW1hZ2UpLHJlY3Q6JC5yZWN0fX1yZXR1cm57X2ltZzp7Zm9udDpMLGZpbGxDb2xvcjpTLHN0cm9rZUNvbG9yOlQsc3Ryb2tlV2lkdGg6aix0ZXh0OkR9fX1jcmVhdGVQcm9ncmFtKHt2ZXJ0ZXg6RCxmcmFnbWVudDpMLG9wdGlvbnM6U309e30pe2lmKHRoaXNbeV0pe2NvbnN0IFQ9dGhpc1t5XS5jb21waWxlU3luYyhMLEQpO3JldHVybiBULl9hdHRyaWJPcHRzPVMsVH10aHJvdyBuZXcgRXJyb3IoIkNvbnRleHQgMkQgY2Fubm90IGNyZWF0ZSB3ZWJnbCBwcm9ncmFtLiIpfWNyZWF0ZVBhc3NQcm9ncmFtKHt2ZXJ0ZXg6RD14LGZyYWdtZW50Okw9ZCxvcHRpb25zOlN9PXt9KXtyZXR1cm4gdGhpcy5jcmVhdGVQcm9ncmFtKHt2ZXJ0ZXg6RCxmcmFnbWVudDpMLG9wdGlvbnM6U30pfXVzZVByb2dyYW0oRCxMPXt9KXtpZih0aGlzW3ldKXtjb25zdCBTPU9iamVjdC5hc3NpZ24oe30sRC5fYXR0cmliT3B0cyxMKTtyZXR1cm4gdGhpc1t5XS51c2VQcm9ncmFtKEQsUyl9dGhyb3cgbmV3IEVycm9yKCJDb250ZXh0IDJEIGNhbm5vdCB1c2Ugd2ViZ2wgcHJvZ3JhbS4iKX1kZWxldGVUZXh0dXJlKEQpe3JldHVybih0aGlzW3ldfHx0aGlzW3JdKS5kZWxldGVUZXh0dXJlKEQpfWNsZWFyKC4uLkQpe2lmKHRoaXNbeV0pe2NvbnN0IEw9dGhpc1t5XS5nbDtMLmNsZWFyKEwuQ09MT1JfQlVGRkVSX0JJVCl9ZWxzZSB0aGlzW3JdLmNsZWFyKC4uLkQpfWRyYXdNZXNoQ2xvdWQoRCx7Y2xlYXI6TD0hMSxwcm9ncmFtOlM9bnVsbH09e30pe2NvbnN0IFQ9dGhpc1t5XXx8dGhpc1tyXSxqPVN8fEQucHJvZ3JhbTtpZih0aGlzW3ldKXtjb25zdCAkPVQuZ2w7aWYoTCYmJC5jbGVhcigkLkNPTE9SX0JVRkZFUl9CSVQpLGopVC5wcm9ncmFtIT09aiYmdGhpcy51c2VQcm9ncmFtKGose2FfY29sb3I6e3R5cGU6IlVOU0lHTkVEX0JZVEUiLG5vcm1hbGl6ZTohMH0sYV9maWxsQ2xvdWRDb2xvcjp7dHlwZToiVU5TSUdORURfQllURSIsbm9ybWFsaXplOiEwfSxhX3N0cm9rZUNsb3VkQ29sb3I6e3R5cGU6IlVOU0lHTkVEX0JZVEUiLG5vcm1hbGl6ZTohMH0sYV9mcmFtZUluZGV4Ont0eXBlOiJVTlNJR05FRF9CWVRFIixub3JtYWxpemU6ITF9fSk7ZWxzZXtjb25zdCB3PUQubWVzaC5tZXNoRGF0YSxKPSEhdy51bmlmb3Jtcy51X3RleFNhbXBsZXIscT0hIXcudW5pZm9ybXMudV9maWx0ZXJGbGFnLFc9ISF3LnVuaWZvcm1zLnVfcmFkaWFsR3JhZGllbnRWZWN0b3IsSz1ELmhhc0Nsb3VkQ29sb3IsUT1ELmhhc0Nsb3VkRmlsdGVyLHR0PSEhdy51bmlmb3Jtcy51X2NsaXBTYW1wbGVyO09iamVjdChwLmFwcGx5Q2xvdWRTaGFkZXIpKFQse2hhc1RleHR1cmU6SixoYXNGaWx0ZXI6cSxoYXNHcmFkaWVudDpXLGhhc0Nsb3VkQ29sb3I6SyxoYXNDbG91ZEZpbHRlcjpRLGhhc0NsaXBQYXRoOnR0fSl9dGhpc1thXSgpLFQuc2V0TWVzaERhdGEoW0QubWVzaERhdGFdKSxELmJlZm9yZVJlbmRlciYmRC5iZWZvcmVSZW5kZXIoJCxEKSxBKFQpLEQuYWZ0ZXJSZW5kZXImJkQuYWZ0ZXJSZW5kZXIoJCxEKX1lbHNlIFQuc2V0VHJhbnNmb3JtKHRoaXMuZ2xvYmFsVHJhbnNmb3JtTWF0cml4KSxULmRyYXdNZXNoQ2xvdWQoRCx7Y2xlYXI6TCxob29rOiExfSl9ZHJhd01lc2hlcyhELHtjbGVhcjpMPSExLHByb2dyYW06Uz1udWxsfT17fSl7Y29uc3QgVD10aGlzW3ldfHx0aGlzW3JdO2lmKHRoaXNbeV0pe2NvbnN0IGo9VC5mYm8sJD1PYmplY3Qodi5kZWZhdWx0KSh0aGlzLEQsUz09bnVsbCksdz1ULmdsO0wmJncuY2xlYXIody5DT0xPUl9CVUZGRVJfQklUKTtjb25zdCBKPSFPYmplY3QobC5pc1VuaXRUcmFuc2Zvcm0pKHRoaXMuZ2xvYmFsVHJhbnNmb3JtTWF0cml4KTt0aGlzLl9kcmF3Q2FsbHM9MDtmb3IoY29uc3QgcSBvZiAkKXt0aGlzLl9kcmF3Q2FsbHMrKztjb25zdCBXPVN8fHEucHJvZ3JhbTtpZihxIGluc3RhbmNlb2YgRS5kZWZhdWx0KXRoaXMuZHJhd01lc2hDbG91ZChxLHtjbGVhcjpMLHByb2dyYW06V30pO2Vsc2V7Y29uc3R7d2lkdGg6SyxoZWlnaHQ6UX09dGhpcy5jYW52YXM7aWYocS5iZWZvcmVSZW5kZXImJnEuYmVmb3JlUmVuZGVyKHcscSkscS5wYXNzLmxlbmd0aCYmKCghdGhpcy5mYm98fHRoaXMuZmJvLndpZHRoIT09S3x8dGhpcy5mYm8uaGVpZ2h0IT09USkmJih0aGlzLmZibz17d2lkdGg6SyxoZWlnaHQ6USx0YXJnZXQ6VC5jcmVhdGVGQk8oKSxidWZmZXI6VC5jcmVhdGVGQk8oKSxzd2FwKCl7W3RoaXMudGFyZ2V0LHRoaXMuYnVmZmVyXT1bdGhpcy5idWZmZXIsdGhpcy50YXJnZXRdfX0pLFQuYmluZEZCTyh0aGlzLmZiby50YXJnZXQpKSwhVyYmcS5maWx0ZXJDYW52YXMpe09iamVjdChwLmFwcGx5U2hhZGVyKShULHtoYXNUZXh0dXJlOiEwfSk7bGV0IHR0PXRoaXMuZmlsdGVyQ29udGV4dDt0dHx8KHR0PW0uZGVmYXVsdC5jcmVhdGVDYW52YXMoSyxRKS5nZXRDb250ZXh0KCIyZCIpLHRoaXMuZmlsdGVyQ29udGV4dD10dCk7Y29uc3QgXz1EW3EucGFja0luZGV4XSxzdD1fLmZpbHRlcixrPURbcS5wYWNrSW5kZXgrMV0sY3Q9RFtxLnBhY2tJbmRleC0xXTsoIWN0fHwhY3QuZmlsdGVyQ2FudmFzfHxjdC5maWx0ZXIhPT1zdCkmJigha3x8IWsuZmlsdGVyQ2FudmFzfHxrLmZpbHRlciE9PXN0KT8oSj8odHQuc2F2ZSgpLE9iamVjdChjLmRyYXdNZXNoMkQpKF8sdHQsITEpLHR0LnJlc3RvcmUoKSxPYmplY3QoYy5hcHBseUZpbHRlcikodHQsc3QpKTpPYmplY3QoYy5kcmF3TWVzaDJEKShfLHR0LCEwKSx0aGlzW2FdKCksYihULHR0LEssUSkpOihKJiZ0dC5zYXZlKCksT2JqZWN0KGMuZHJhd01lc2gyRCkoXyx0dCwhMSksSiYmdHQucmVzdG9yZSgpLCgha3x8IWsuZmlsdGVyQ2FudmFzfHxfLmZpbHRlciE9PWsuZmlsdGVyKSYmKE9iamVjdChjLmFwcGx5RmlsdGVyKSh0dCxzdCksdGhpc1thXSgpLGIoVCx0dCxLLFEpKSl9ZWxzZXtpZihXKVQucHJvZ3JhbSE9PVcmJnRoaXMudXNlUHJvZ3JhbShXLHthX2NvbG9yOnt0eXBlOiJVTlNJR05FRF9CWVRFIixub3JtYWxpemU6ITB9fSk7ZWxzZXtjb25zdCB0dD0hIXEudW5pZm9ybXMudV90ZXhTYW1wbGVyLF89ISFxLnVuaWZvcm1zLnVfZmlsdGVyRmxhZyxzdD0hIXEudW5pZm9ybXMudV9yYWRpYWxHcmFkaWVudFZlY3RvcixrPSEhcS51bmlmb3Jtcy51X2NsaXBTYW1wbGVyO09iamVjdChwLmFwcGx5U2hhZGVyKShULHtoYXNUZXh0dXJlOnR0LGhhc0ZpbHRlcjpfLGhhc0dyYWRpZW50OnN0LGhhc0NsaXBQYXRoOmt9KX1xLmZpbHRlckNhbnZhcyYmY29uc29sZS53YXJuKCJVc2VyIHByb2dyYW0gaWdub3JlZCBzb21lIGZpbHRlciBlZmZlY3RzLiIpLHRoaXNbYV0oKSxULnNldE1lc2hEYXRhKFtxXSksQShUKX1pZihxLnBhc3MubGVuZ3RoKXtjb25zdCB0dD1xLnBhc3MubGVuZ3RoO3EucGFzcy5mb3JFYWNoKChfLHN0KT0+e18uYmxlbmQ9cS5lbmFibGVCbGVuZCxfLnNldFRleHR1cmUoVC5mYm8udGV4dHVyZSksc3Q9PT10dC0xP1QuYmluZEZCTyhqKToodGhpcy5mYm8uc3dhcCgpLFQuYmluZEZCTyh0aGlzLmZiby50YXJnZXQpKSxfLnByb2dyYW0/VC51c2VQcm9ncmFtKF8ucHJvZ3JhbSk6KHRoaXMuZGVmYXVsdFBhc3NQcm9ncmFtPXRoaXMuZGVmYXVsdFBhc3NQcm9ncmFtfHx0aGlzLmNyZWF0ZVBhc3NQcm9ncmFtKCksVC51c2VQcm9ncmFtKHRoaXMuZGVmYXVsdFBhc3NQcm9ncmFtKSksVC5zZXRNZXNoRGF0YShbXy5tZXNoRGF0YV0pLHcuY2xlYXIody5DT0xPUl9CVUZGRVJfQklUKSxBKFQpfSl9cS5hZnRlclJlbmRlciYmcS5hZnRlclJlbmRlcih3LHEpfX19ZWxzZSBULnNldFRyYW5zZm9ybSh0aGlzLmdsb2JhbFRyYW5zZm9ybU1hdHJpeCksVC5kcmF3TWVzaGVzKEQse2NsZWFyOkx9KX1kcmF3SW1hZ2UoRCwuLi5MKXtjb25zdCBTPUwubGVuZ3RoO2lmKFM8Mil0aHJvdyBuZXcgVHlwZUVycm9yKGBGYWlsZWQgdG8gZXhlY3V0ZSAnZHJhd0ltYWdlJyBvbiAnUmVuZGVyZXInOiAzIGFyZ3VtZW50cyByZXF1aXJlZCwgYnV0IG9ubHkgJHtMLmxlbmd0aCsxfSBwcmVzZW50LmApO2lmKFMhPT0yJiZTIT09NCYmUyE9PTgpdGhyb3cgbmV3IFR5cGVFcnJvcihgRmFpbGVkIHRvIGV4ZWN1dGUgJ2RyYXdJbWFnZScgb24gJ1JlbmRlcmVyJzogVmFsaWQgYXJpdGllcyBhcmU6IFszLCA1LCA5XSwgYnV0ICR7TC5sZW5ndGgrMX0gYXJndW1lbnRzIHByb3ZpZGVkLmApO2xldCBUPW51bGwsaj1udWxsO1M9PT0yP1Q9W0xbMF0sTFsxXSxELndpZHRoLEQuaGVpZ2h0XTpTPT09ND9UPUw6Uz09PTgmJihqPUwuc2xpY2UoMCw0KSxUPUwuc2xpY2UoNCkpO2NvbnN0ICQ9dGhpcy5jcmVhdGVUZXh0dXJlKEQpLHt3aWR0aDp3LGhlaWdodDpKfT10aGlzLmNhbnZhcyxxPW5ldyBmLmRlZmF1bHQ7cS5yZWN0KFRbMF0sVFsxXSx3LEopO2NvbnN0IFc9bmV3IGguZGVmYXVsdChxLHt3aWR0aDp3LGhlaWdodDpKfSk7Vy5zZXRUZXh0dXJlKCQse3JlY3Q6VCxzcmNSZWN0Omp9KSx0aGlzLmRyYXdNZXNoZXMoW1ddKSx0aGlzLmRlbGV0ZVRleHR1cmUoJCl9c2V0R2xvYmFsVHJhbnNmb3JtKC4uLkQpe3JldHVybiB0aGlzW25dPVtEWzBdLERbMV0sMCxEWzJdLERbM10sMCxEWzRdLERbNV0sMV0sdGhpc31nbG9iYWxUcmFuc2Zvcm0oLi4uRCl7Y29uc3QgTD10aGlzW25dO3JldHVybiB0aGlzW25dPW8ubWF0My5tdWx0aXBseShBcnJheS5vZigwLDAsMCwwLDAsMCwwLDAsMCksTCxEKSx0aGlzfWdsb2JhbFRyYW5zbGF0ZShELEwpe2xldCBTPW8ubWF0My5jcmVhdGUoKTtyZXR1cm4gUz1vLm1hdDMudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwLDAsMCwwKSxTLFtELExdKSx0aGlzLmdsb2JhbFRyYW5zZm9ybSguLi5TKX1nbG9iYWxSb3RhdGUoRCxbTCxTXT1bMCwwXSl7bGV0IFQ9by5tYXQzLmNyZWF0ZSgpO3JldHVybiBUPW8ubWF0My50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDAsMCwwLDApLFQsW0wsU10pLFQ9by5tYXQzLnJvdGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCwwLDAsMCksVCxEKSxUPW8ubWF0My50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDAsMCwwLDApLFQsWy1MLC1TXSksdGhpcy5nbG9iYWxUcmFuc2Zvcm0oLi4uVCl9Z2xvYmFsU2NhbGUoRCxMPUQsW1MsVF09WzAsMF0pe2xldCBqPW8ubWF0My5jcmVhdGUoKTtyZXR1cm4gaj1vLm1hdDMudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwLDAsMCwwKSxqLFtTLFRdKSxqPW8ubWF0My5zY2FsZShBcnJheS5vZigwLDAsMCwwLDAsMCwwLDAsMCksaixbRCxMXSksaj1vLm1hdDMudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwLDAsMCwwKSxqLFstUywtVF0pLHRoaXMuZ2xvYmFsVHJhbnNmb3JtKC4uLmopfWdsb2JhbFNrZXcoRCxMPUQsW1MsVF09WzAsMF0pe2xldCBqPW8ubWF0My5jcmVhdGUoKTtyZXR1cm4gaj1vLm1hdDMudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwLDAsMCwwKSxqLFtTLFRdKSxqPW8ubWF0My5tdWx0aXBseShBcnJheS5vZigwLDAsMCwwLDAsMCwwLDAsMCksaixvLm1hdDMuZnJvbVZhbHVlcygxLE1hdGgudGFuKEwpLE1hdGgudGFuKEQpLDEsMCwwKSksaj1vLm1hdDMudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwLDAsMCwwKSxqLFstUywtVF0pLHRoaXMuZ2xvYmFsVHJhbnNmb3JtKC4uLmopfXRyYW5zZm9ybVBvaW50KEQsTCxTKXtsZXQgVD10aGlzLmdsb2JhbFRyYW5zZm9ybU1hdHJpeDtTJiYoVD1vLm1hdDMubXVsdGlwbHkoQXJyYXkub2YoMCwwLDAsMCwwLDAsMCwwLDApLFQsUykpO2NvbnN0IGo9RCpUWzBdK0wqVFsyXStUWzRdLCQ9RCpUWzFdK0wqVFszXStUWzVdO3JldHVybltqLCRdfX19LGZ1bmN0aW9uKFIsZSx0KXt0LnIoZSk7dmFyIGk9dCgxNSk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpLGUuZGVmYXVsdD1pLmRlZmF1bHR9LGZ1bmN0aW9uKFIsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIHB9KTt2YXIgaT10KDE2KSxvPXQoMTcpLGc9dCgxOCksdj10KDE5KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gYyhDLHgsZCl7cmV0dXJuIHggaW4gQz9PYmplY3QuZGVmaW5lUHJvcGVydHkoQyx4LHt2YWx1ZTpkLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6Q1t4XT1kLEN9Y29uc3QgZj17fTtmdW5jdGlvbiBoKEMseD0zKXtjb25zdCBkPVtdLHk9Qy5sZW5ndGg7Zm9yKGxldCByPTA7cjx5O3IrKylyJXg8MiYmZC5wdXNoKC41KihDW3JdKzEpKTtyZXR1cm4gZH1mdW5jdGlvbiBFKEMseCl7Y29uc3QgZD14Ll9idWZmZXJzO09iamVjdC52YWx1ZXMoZCkuZm9yRWFjaCh5PT57Qy5kZWxldGVCdWZmZXIoeSl9KSx4Ll9idWZmZXJzPXt9fWZ1bmN0aW9uIGwoQyx4LGQpe3JldHVybiBDLmFjdGl2ZVRleHR1cmUoQy5URVhUVVJFMCtkKSxBcnJheS5pc0FycmF5KHguX2ltZyk/Qy5iaW5kVGV4dHVyZShDLlRFWFRVUkVfQ1VCRV9NQVAseCk6Qy5iaW5kVGV4dHVyZShDLlRFWFRVUkVfMkQseCkseH1jb25zdCBtPXtpbnQ6IjFpIixpdmVjMjoiMmkiLGl2ZWMzOiIzaSIsaXZlYzQ6IjRpIixmbG9hdDoiMWYiLHZlYzI6IjJmIix2ZWMzOiIzZiIsdmVjNDoiNGYiLG1hdDI6Ik1hdHJpeDJmdiIsbWF0MzoiTWF0cml4M2Z2IixtYXQ0OiJNYXRyaXg0ZnYiLHNhbXBsZXIxRDoic2FtcGxlcjFEIixzYW1wbGVyMkQ6InNhbXBsZXIyRCIsc2FtcGxlcjNEOiJzYW1wbGVyM0QiLHNhbXBsZXJDdWJlOiJzYW1wbGVyQ3ViZSIsc2FtcGxlcjFEU2hhZG93OiJzYW1wbGVyMURTaGFkb3ciLHNhbXBsZXIyRFNoYWRvdzoic2FtcGxlcjJEU2hhZG93IixzYW1wbGVyMkRSZWN0OiJzYW1wbGVyMkRSZWN0IixzYW1wbGVyMkRSZWN0U2hhZG93OiJzYW1wbGVyMkRSZWN0U2hhZG93In07Y2xhc3MgcHtzdGF0aWMgYWRkTGlicyh4PXt9KXtPYmplY3QuYXNzaWduKGYseCl9c3RhdGljIEZMT0FUKHgsZCl7cmV0dXJuIE9iamVjdChpLnBvaW50c1RvQnVmZmVyKSh4LEZsb2F0MzJBcnJheSxkKX1zdGF0aWMgVU5TSUdORURfQllURSh4LGQpe3JldHVybiBPYmplY3QoaS5wb2ludHNUb0J1ZmZlcikoeCxVaW50OEFycmF5LGQpfXN0YXRpYyBVTlNJR05FRF9TSE9SVCh4LGQpe3JldHVybiBPYmplY3QoaS5wb2ludHNUb0J1ZmZlcikoeCxVaW50MTZBcnJheSxkKX1zdGF0aWMgQllURSh4LGQpe3JldHVybiBPYmplY3QoaS5wb2ludHNUb0J1ZmZlcikoeCxJbnQ4QXJyYXksZCl9c3RhdGljIFNIT1JUKHgsZCl7cmV0dXJuIE9iamVjdChpLnBvaW50c1RvQnVmZmVyKSh4LEludDE2QXJyYXksZCl9Y29uc3RydWN0b3IoeCxkPXt9KXt0aGlzLm9wdGlvbnM9T2JqZWN0LmFzc2lnbih7fSxwLmRlZmF1bHRPcHRpb25zLGQpLHRoaXMuY2FudmFzPXg7bGV0IHk7dGhpcy5vcHRpb25zLndlYmdsMiYmKHk9eC5nZXRDb250ZXh0KCJ3ZWJnbDIiLHRoaXMub3B0aW9ucykpLHk9PW51bGwmJih5PU9iamVjdChpLnNldHVwV2ViR0wpKHgsdGhpcy5vcHRpb25zKSx0aGlzLmFpYV9leHQ9eS5nZXRFeHRlbnNpb24oIkFOR0xFX2luc3RhbmNlZF9hcnJheXMiKSksdGhpcy5nbD15LHkudmlld3BvcnQoMCwwLHgud2lkdGgseC5oZWlnaHQpLHkuY2xlYXJDb2xvcigwLDAsMCwwKSx5LmJsZW5kRnVuY1NlcGFyYXRlKHkuU1JDX0FMUEhBLHkuT05FX01JTlVTX1NSQ19BTFBIQSx5Lk9ORSx5Lk9ORV9NSU5VU19TUkNfQUxQSEEpLHRoaXMucHJvZ3JhbXM9W10sdGhpcy5fZXZlbnRzPXt9fWdldCBwcm9ncmFtKCl7Y29uc3QgeD10aGlzLmdsO3JldHVybiB4LmdldFBhcmFtZXRlcih4LkNVUlJFTlRfUFJPR1JBTSl9X2RlY2xhcmVVbmlmb3JtKHgsZCx5PSIxZiIpe2NvbnN0IHI9dGhpcy5nbCxzPXIuZ2V0VW5pZm9ybUxvY2F0aW9uKHgsZCk7bGV0IG47Y29uc3QgYT10aGlzO2lmKC9ec2FtcGxlci8udGVzdCh5KSl7Y29uc3QgTz14Ll9zYW1wbGVyTWFwLEE9eC5fYmluZFRleHR1cmVzO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh4LnVuaWZvcm1zLGQse2dldCgpe3JldHVybiBufSxzZXQoYil7bj1iO2NvbnN0IEk9T1tkXSE9bnVsbD9PW2RdOkEubGVuZ3RoO0FbSV09YixsKHIsYixJKSxPW2RdfHwoT1tkXT1JLHIudW5pZm9ybTFpKHMsSSkpLGEub3B0aW9ucy5hdXRvVXBkYXRlJiZhLnVwZGF0ZSgpfSxjb25maWd1cmFibGU6ITEsZW51bWVyYWJsZTohMH0pfWVsc2V7Y29uc3QgTz15LmluZGV4T2YoIk1hdHJpeCIpPT09MCxBPSFPJiYvdiQvLnRlc3QoeSksYj1yW2B1bmlmb3JtJHt5fWBdLmJpbmQocik7T2JqZWN0LmRlZmluZVByb3BlcnR5KHgudW5pZm9ybXMsZCx7Z2V0KCl7cmV0dXJuIG59LHNldChJKXtuPUksdHlwZW9mIEk9PSJudW1iZXIiJiYoST1bSV0pLE8/YihzLCExLEkpOkE/YihzLEkpOmIocywuLi5JKSxhLm9wdGlvbnMuYXV0b1VwZGF0ZSYmYS51cGRhdGUoKX0sY29uZmlndXJhYmxlOiExLGVudW1lcmFibGU6ITB9KX19X2RyYXcoKXtjb25zdCB4PXRoaXMucHJvZ3JhbTt4Lm1lc2hEYXRhLmZvckVhY2goKGQseSk9Pntjb25zdHtwb3NpdGlvbnM6cixjZWxsczpzLGluc3RhbmNlQ291bnQ6bixjZWxsc0NvdW50OmEsYXR0cmlidXRlczpPLHVuaWZvcm1zOkEsdGV4dHVyZUNvb3JkOmIsZW5hYmxlQmxlbmQ6SX09ZCxQPXRoaXMuZ2w7bGV0IEQ9ZC5tb2RlIT1udWxsP2QubW9kZTpQLlRSSUFOR0xFUzt0eXBlb2YgRD09InN0cmluZyImJihEPVBbRF0pLEk/UC5lbmFibGUoUC5CTEVORCk6UC5kaXNhYmxlKFAuQkxFTkQpLFAuYmluZEJ1ZmZlcihQLkFSUkFZX0JVRkZFUix4Ll9idWZmZXJzLnZlcnRpY2VzQnVmZmVyKSxQLmJ1ZmZlckRhdGEoUC5BUlJBWV9CVUZGRVIscixQLlNUQVRJQ19EUkFXKSxzJiYoUC5iaW5kQnVmZmVyKFAuRUxFTUVOVF9BUlJBWV9CVUZGRVIseC5fYnVmZmVycy5jZWxsc0J1ZmZlciksUC5idWZmZXJEYXRhKFAuRUxFTUVOVF9BUlJBWV9CVUZGRVIscyxQLlNUQVRJQ19EUkFXKSk7Y29uc3QgTD1bXTtPJiZPYmplY3QudmFsdWVzKE8pLmZvckVhY2goKHtuYW1lOlQsZGF0YTpqLGRpdmlzb3I6JH0pPT57aWYoUC5iaW5kQnVmZmVyKFAuQVJSQVlfQlVGRkVSLHguX2J1ZmZlcnNbVF0pLFAuYnVmZmVyRGF0YShQLkFSUkFZX0JVRkZFUixqLFAuU1RBVElDX0RSQVcpLCQhPW51bGwpe2NvbnN0IHc9UC5nZXRBdHRyaWJMb2NhdGlvbih4LFQpO3c+PTAmJihQLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHcpLEwucHVzaCh3KSxQLnZlcnRleEF0dHJpYkRpdmlzb3I/UC52ZXJ0ZXhBdHRyaWJEaXZpc29yKHcsJCk6dGhpcy5haWFfZXh0JiZ0aGlzLmFpYV9leHQudmVydGV4QXR0cmliRGl2aXNvckFOR0xFKHcsJCkpfX0pLEEmJk9iamVjdC5lbnRyaWVzKEEpLmZvckVhY2goKFtULGpdKT0+e3RoaXMudW5pZm9ybXNbVF09an0pO2xldCBTO2lmKCFzKXtjb25zdCBUPXguX2RpbWVuc2lvbjtTPXIubGVuZ3RoL1R9aWYoeC5fZW5hYmxlVGV4dHVyZXMmJnguX2J1ZmZlcnMudGV4Q29vcmRCdWZmZXIpe2NvbnN0IFQ9Ynx8aChyLHguX2RpbWVuc2lvbik7UC5iaW5kQnVmZmVyKFAuQVJSQVlfQlVGRkVSLHguX2J1ZmZlcnMudGV4Q29vcmRCdWZmZXIpLFAuYnVmZmVyRGF0YShQLkFSUkFZX0JVRkZFUixwLkZMT0FUKFQpLFAuU1RBVElDX0RSQVcpfW4hPW51bGw/KHM/UC5kcmF3RWxlbWVudHNJbnN0YW5jZWQ/UC5kcmF3RWxlbWVudHNJbnN0YW5jZWQoRCxhLFAuVU5TSUdORURfU0hPUlQsMCxuKTp0aGlzLmFpYV9leHQmJnRoaXMuYWlhX2V4dC5kcmF3RWxlbWVudHNJbnN0YW5jZWRBTkdMRShELGEsUC5VTlNJR05FRF9TSE9SVCwwLG4pOlAuZHJhd0FycmF5c0luc3RhbmNlZD9QLmRyYXdBcnJheXNJbnN0YW5jZWQoRCwwLFMsbik6dGhpcy5haWFfZXh0LmRyYXdBcnJheXNJbnN0YW5jZWRBTkdMRShELDAsUyxuKSxMLmZvckVhY2goVD0+e1AudmVydGV4QXR0cmliRGl2aXNvcj9QLnZlcnRleEF0dHJpYkRpdmlzb3IoVCxudWxsKTp0aGlzLmFpYV9leHQmJnRoaXMuYWlhX2V4dC52ZXJ0ZXhBdHRyaWJEaXZpc29yQU5HTEUoVCxudWxsKX0pKTpzP1AuZHJhd0VsZW1lbnRzKEQsYSxQLlVOU0lHTkVEX1NIT1JULDApOlAuZHJhd0FycmF5cyhELDAsUyl9KX1nZXQgaXNXZWJHTDIoKXtyZXR1cm4gdHlwZW9mIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQ8InUiJiZ0aGlzLmdsIGluc3RhbmNlb2YgV2ViR0wyUmVuZGVyaW5nQ29udGV4dH1nZXQgZW5hYmxlVGV4dHVyZXMoKXtyZXR1cm4gdGhpcy5wcm9ncmFtJiZ0aGlzLnByb2dyYW0uX2VuYWJsZVRleHR1cmVzfWdldCB1bmlmb3Jtcygpe2NvbnN0IHg9dGhpcy5wcm9ncmFtO2lmKCF4fHwheC51bmlmb3Jtcyl0aHJvdyBFcnJvcigiTm8gYXZhbGlhYmxlIHByb2dyYW0uIik7cmV0dXJuIHgudW5pZm9ybXN9ZGVsZXRlUHJvZ3JhbSh4KXtjb25zdCBkPXRoaXMuZ2w7dGhpcy5wcm9ncmFtPT09eCYmKHRoaXMuc3RhcnRSZW5kZXI9ITEsdGhpcy5fcmVuZGVyRnJhbWVJRCYmKGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuX3JlbmRlckZyYW1lSUQpLGRlbGV0ZSB0aGlzLl9yZW5kZXJGcmFtZUlEKSxkLnVzZVByb2dyYW0obnVsbCkpO2NvbnN0IHk9dGhpcy5wcm9ncmFtcy5pbmRleE9mKHgpO3k+PTAmJnRoaXMucHJvZ3JhbXMuc3BsaWNlKHksMSksRShkLHgpLGQuZGVsZXRlUHJvZ3JhbSh4KX1zZXRNZXNoRGF0YSh4KXtBcnJheS5pc0FycmF5KHgpfHwoeD1beF0pO2NvbnN0IGQ9dGhpcy5wcm9ncmFtO2QubWVzaERhdGE9eC5tYXAoKHttb2RlOnkscG9zaXRpb25zOnIsaW5zdGFuY2VDb3VudDpzLGNlbGxzOm4sY2VsbHNDb3VudDphLGF0dHJpYnV0ZXM6Tyx1bmlmb3JtczpBLHRleHR1cmVDb29yZDpiLGVuYWJsZUJsZW5kOkl9KT0+e2NvbnN0IFA9e3Bvc2l0aW9uczpwLkZMT0FUKHIpLHVuaWZvcm1zOkEsZW5hYmxlQmxlbmQ6ISFJLHRleHR1cmVDb29yZDpwLkZMT0FUKGIpfTtpZihuJiYoUC5jZWxscz1wLlVTSE9SVChuKSxQLmNlbGxzQ291bnQ9YXx8UC5jZWxscy5sZW5ndGgpLHkhPW51bGwmJihQLm1vZGU9eSkscyE9bnVsbCl7aWYoIXRoaXMuaXNXZWJHTDImJiF0aGlzLmFpYV9leHQpdGhyb3cgbmV3IEVycm9yKCJDYW5ub3QgdXNlIGluc3RhbmNlQ291bnQgaW4gdGhpcyByZW5kZXJpbmcgY29udGV4dCwgdXNlIHdlYmdsMiBjb250ZXh0IGluc3RlYWQuIik7UC5pbnN0YW5jZUNvdW50PXN9aWYoTyl7Y29uc3QgRD17fTtPYmplY3QuZW50cmllcyhPKS5mb3JFYWNoKChbTCxTXSk9PntpZighZC5fYXR0cmlidXRlW0xdKWQuX2F0dHJpYnV0ZVtMXT0iaWdub3JlZCI7ZWxzZSBpZihkLl9hdHRyaWJ1dGVbTF0hPT0iaWdub3JlZCIpe2NvbnN0e25hbWU6VCx0eXBlOmp9PWQuX2F0dHJpYnV0ZVtMXTtsZXQgJD1TLmRhdGF8fFM7aWYoQXJyYXkuaXNBcnJheSgkKSYmKCQ9cFtqXSgkKSksRFtMXT17bmFtZTpULGRhdGE6JH0sUy5kaXZpc29yIT1udWxsKXtpZighdGhpcy5pc1dlYkdMMiYmIXRoaXMuYWlhX2V4dCl0aHJvdyBuZXcgRXJyb3IoIkNhbm5vdCB1c2UgZGl2aXNvciBpbiB0aGlzIHJlbmRlcmluZyBjb250ZXh0LCB1c2Ugd2ViZ2wyIGNvbnRleHQgaW5zdGVhZC4iKTtEW0xdLmRpdmlzb3I9Uy5kaXZpc29yfX19KSxQLmF0dHJpYnV0ZXM9RH1yZXR1cm4gUH0pLHRoaXMub3B0aW9ucy5hdXRvVXBkYXRlJiZ0aGlzLnVwZGF0ZSgpfWNyZWF0ZVByb2dyYW0oeCxkKXtjb25zdCB5PS9eXHMqdW5pZm9ybVxzK3NhbXBsZXIvbWcudGVzdCh4KTt4PT1udWxsJiYoeD1nLmRlZmF1bHQpLGQ9PW51bGwmJihkPXk/di5kZWZhdWx0Om8uZGVmYXVsdCk7Y29uc3Qgcj10aGlzLmdsLHM9T2JqZWN0KGkuY3JlYXRlUHJvZ3JhbSkocixkLHgpO3Muc2hhZGVyVGV4dD17dmVydGV4U2hhZGVyOmQsZnJhZ21lbnRTaGFkZXI6eH0scy5fYnVmZmVycz17fSxzLl9hdHRyaWJ1dGU9e30scy51bmlmb3Jtcz17fSxzLl9zYW1wbGVyTWFwPXt9LHMuX2JpbmRUZXh0dXJlcz1bXTtjb25zdCBuPW5ldyBSZWdFeHAoYCg/OmF0dHJpYnV0ZXxpbikgdmVjKFxcZCkgJHt0aGlzLm9wdGlvbnMudmVydGV4UG9zaXRpb259YCwiaW0iKTtsZXQgYT1kLm1hdGNoKG4pO2EmJihzLl9kaW1lbnNpb249TnVtYmVyKGFbMV0pKTtjb25zdCBPPW5ldyBSZWdFeHAoYCg/OmF0dHJpYnV0ZXxpbikgdmVjKFxcZCkgJHt0aGlzLm9wdGlvbnMudmVydGV4VGV4dHVyZUNvb3JkfWAsImltIik7YT1kLm1hdGNoKE8pLGEmJihzLl90ZXhDb29yZFNpemU9TnVtYmVyKGFbMV0pKTtjb25zdCBBPS9eXHMqKD86YXR0cmlidXRlfGluKSAoXHcrPykoXGQqKSAoXHcrKS9naW07aWYoYT1kLm1hdGNoKEEpLGEpZm9yKGxldCBQPTA7UDxhLmxlbmd0aDtQKyspe2NvbnN0IEQ9L15ccyooPzphdHRyaWJ1dGV8aW4pIChcdys/KShcZCopIChcdyspL2ltLEw9YVtQXS5tYXRjaChEKTtpZihMJiZMWzNdIT09dGhpcy5vcHRpb25zLnZlcnRleFBvc2l0aW9uJiZMWzNdIT09dGhpcy5vcHRpb25zLnZlcnRleFRleHR1cmVDb29yZCl7bGV0WyxTLFQsal09TDtTPT09Im1hdCImJihUKio9Mikscy5fYnVmZmVyc1tqXT1yLmNyZWF0ZUJ1ZmZlcigpLHMuX2F0dHJpYnV0ZVtqXT17bmFtZTpqLHR5cGU6UyxzaXplOk51bWJlcihUKXx8MX19fWNvbnN0IGI9L15ccyp1bmlmb3JtXHMrKFx3KylccysoXHcrKShcW1xkK1xdKT8vbWc7YT1kLm1hdGNoKGIpfHxbXSxhPWEuY29uY2F0KHgubWF0Y2goYil8fFtdKSxhLmZvckVhY2goUD0+e2NvbnN0IEQ9UC5tYXRjaCgvXlxzKnVuaWZvcm1ccysoXHcrKVxzKyhcdyspKFxbXGQrXF0pPy8pO2xldFtMLFMsVF09RC5zbGljZSgxKTtMPW1bTF0sVD0hIVQsTC5pbmRleE9mKCJNYXRyaXgiKSE9PTAmJlQmJihMKz0idiIpLHRoaXMuX2RlY2xhcmVVbmlmb3JtKHMsUyxMKX0pLHMuX2J1ZmZlcnMudmVydGljZXNCdWZmZXI9ci5jcmVhdGVCdWZmZXIoKSxzLl9idWZmZXJzLmNlbGxzQnVmZmVyPXIuY3JlYXRlQnVmZmVyKCk7Y29uc3QgST1yLmdldEF0dHJpYkxvY2F0aW9uKHMsdGhpcy5vcHRpb25zLnZlcnRleFRleHR1cmVDb29yZCk7cmV0dXJuIHMuX2VuYWJsZVRleHR1cmVzPUk+PTAscy5fZW5hYmxlVGV4dHVyZXMmJihzLl9idWZmZXJzLnRleENvb3JkQnVmZmVyPXIuY3JlYXRlQnVmZmVyKCkpLHRoaXMucHJvZ3JhbXMucHVzaChzKSxzfXVzZVByb2dyYW0oeCxkPXt9KXt0aGlzLnN0YXJ0UmVuZGVyPSExLHRoaXMuX3JlbmRlckZyYW1lSUQmJihjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLl9yZW5kZXJGcmFtZUlEKSxkZWxldGUgdGhpcy5fcmVuZGVyRnJhbWVJRCk7Y29uc3QgeT10aGlzLmdsO3kudXNlUHJvZ3JhbSh4KTtjb25zdCByPXguX2RpbWVuc2lvbjt5LmJpbmRCdWZmZXIoeS5BUlJBWV9CVUZGRVIseC5fYnVmZmVycy52ZXJ0aWNlc0J1ZmZlcik7Y29uc3Qgcz15LmdldEF0dHJpYkxvY2F0aW9uKHgsdGhpcy5vcHRpb25zLnZlcnRleFBvc2l0aW9uKTtpZih5LnZlcnRleEF0dHJpYlBvaW50ZXIocyxyLHkuRkxPQVQsITEsMCwwKSx5LmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHMpLHguX2VuYWJsZVRleHR1cmVzKXt5LmJpbmRCdWZmZXIoeS5BUlJBWV9CVUZGRVIseC5fYnVmZmVycy50ZXhDb29yZEJ1ZmZlcik7Y29uc3Qgbj15LmdldEF0dHJpYkxvY2F0aW9uKHgsdGhpcy5vcHRpb25zLnZlcnRleFRleHR1cmVDb29yZCk7eS52ZXJ0ZXhBdHRyaWJQb2ludGVyKG4seC5fdGV4Q29vcmRTaXplfHwyLHkuRkxPQVQsITEsMCwwKSx5LmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KG4pfWlmKE9iamVjdC5lbnRyaWVzKHguX2F0dHJpYnV0ZSkuZm9yRWFjaCgoW24sYV0pPT57aWYoYSE9PSJpZ25vcmVkIil7Y29uc3QgTz1hLnNpemUsQT1kW25dfHx7fSxiPSEhQS5ub3JtYWxpemU7bGV0IEk9QS50eXBlfHwiRkxPQVQiO2NvbnN0IFA9QS5rZXl8fG47ST09PSJVQllURSImJihJPSJVTlNJR05FRF9CWVRFIiksST09PSJVU0hPUlQiJiYoST0iVU5TSUdORURfU0hPUlQiKSxhLnR5cGU9SSxQJiZQIT09biYmKHguX2F0dHJpYnV0ZVtQXT1hKSx5LmJpbmRCdWZmZXIoeS5BUlJBWV9CVUZGRVIseC5fYnVmZmVyc1tuXSk7Y29uc3QgRD15LmdldEF0dHJpYkxvY2F0aW9uKHgsbik7RD49MCYmKHkudmVydGV4QXR0cmliUG9pbnRlcihELE8seVtJXSxiLDAsMCkseS5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShEKSl9fSksIXgubWVzaERhdGEpe2NvbnN0IG49W1stMSwtMSwwLDFdLnNsaWNlKDAsciksWzEsLTEsMCwxXS5zbGljZSgwLHIpLFsxLDEsMCwxXS5zbGljZSgwLHIpLFstMSwxLDAsMV0uc2xpY2UoMCxyKV0sYT1bWzAsMSwzXSxbMywxLDJdXTt0aGlzLnNldE1lc2hEYXRhKHtwb3NpdGlvbnM6bixjZWxsczphfSl9cmV0dXJuIHh9Y29tcGlsZVN5bmMoeCxkKXt4PXh8fGcuZGVmYXVsdDtjb25zdCB5PXt9O2Z1bmN0aW9uIHIoTyl7Tz1PLnJlcGxhY2UoL15ccyovbWcsIiIpO2NvbnN0IEE9W10sYj1PLm1hdGNoKC9eI3ByYWdtYVxzK2luY2x1ZGVccysuKi9tZyk7aWYoYil7Zm9yKGxldCBJPTA7STxiLmxlbmd0aDtJKyspe2NvbnN0IEQ9YltJXS5tYXRjaCgvKD86PHwiKSguKikoPzo+fCIpLyk7aWYoRCl7Y29uc3QgTD1EWzBdLmluZGV4T2YoIjwiKT09PTA/ImxpYiI6ImxpbmsiO2xldCBTPURbMV07aWYoUz09PSJncmFwaCImJihTPSJncmFwaGljcyIpLHlbU10pQS5wdXNoKGAvKiBpbmNsdWRlZCAke1N9ICovYCk7ZWxzZSBpZih5W1NdPSEwLEw9PT0ibGliIil7Y29uc3QgVD1yKGZbU10pO0EucHVzaChUKX1lbHNlIGlmKEw9PT0ibGluayIpdGhyb3cgbmV3IEVycm9yKCJDYW5ub3QgbG9hZCBleHRlcm5hbCBsaW5rcyBzeW5jaHJvbm91c2x5LiBVc2UgY29tcGlsZSBpbnN0ZWFkIG9mIGNvbXBpbGVTeW5jLiIpfX1BLmZvckVhY2goST0+e089Ty5yZXBsYWNlKC9eI3ByYWdtYVxzK2luY2x1ZGVccysuKi9tLEkpfSl9cmV0dXJuIE99Y29uc3Qgcz1yKHgpLG49ZD9yKGQpOm51bGw7cmV0dXJuIHRoaXMuY3JlYXRlUHJvZ3JhbShzLG4pfWFzeW5jIGNvbXBpbGUoeCxkKXt4PXh8fGcuZGVmYXVsdDtjb25zdCB5PXt9O2FzeW5jIGZ1bmN0aW9uIHIoTyl7Tz1PLnJlcGxhY2UoL15ccyovbWcsIiIpO2NvbnN0IEE9W10sYj1PLm1hdGNoKC9eI3ByYWdtYVxzK2luY2x1ZGVccysuKi9tZyk7aWYoYil7Zm9yKGxldCBJPTA7STxiLmxlbmd0aDtJKyspe2NvbnN0IEQ9YltJXS5tYXRjaCgvKD86PHwiKSguKikoPzo+fCIpLyk7aWYoRCl7Y29uc3QgTD1EWzBdLmluZGV4T2YoIjwiKT09PTA/ImxpYiI6ImxpbmsiO2xldCBTPURbMV07aWYoUz09PSJncmFwaCImJihTPSJncmFwaGljcyIpLHlbU10pQS5wdXNoKGAvKiBpbmNsdWRlZCAke1N9ICovYCk7ZWxzZSBpZih5W1NdPSEwLEw9PT0ibGliIil7Y29uc3QgVD1hd2FpdCByKGZbU10pO0EucHVzaChUKX1lbHNlIGlmKEw9PT0ibGluayIpe2xldCBUPWF3YWl0IHAuZmV0Y2hTaGFkZXIoUyk7VD1hd2FpdCByKFQpLEEucHVzaChUKX19fUEuZm9yRWFjaChJPT57Tz1PLnJlcGxhY2UoL14jcHJhZ21hXHMraW5jbHVkZVxzKy4qL20sSSl9KX1yZXR1cm4gT31jb25zdCBzPWF3YWl0IHIoeCksbj1kP2F3YWl0IHIoZCk6bnVsbDtyZXR1cm4gdGhpcy5jcmVhdGVQcm9ncmFtKHMsbil9YXN5bmMgbG9hZCh4LGQ9bnVsbCl7cmV0dXJuIHg9YXdhaXQgcC5mZXRjaFNoYWRlcih4KSxkJiYoZD1hd2FpdCBwLmZldGNoU2hhZGVyKGQpKSx0aGlzLmNvbXBpbGUoeCxkKX1jcmVhdGVUZXh0dXJlKHg9bnVsbCx7d3JhcFM6ZD10aGlzLmdsLkNMQU1QX1RPX0VER0Usd3JhcFQ6eT10aGlzLmdsLkNMQU1QX1RPX0VER0UsbWluRmlsdGVyOnI9dGhpcy5nbC5MSU5FQVIsbWFnRmlsdGVyOnM9dGhpcy5nbC5MSU5FQVJ9PXt9KXtjb25zdCBuPXRoaXMuZ2wsYT1BcnJheS5pc0FycmF5KHgpP24uVEVYVFVSRV9DVUJFX01BUDpuLlRFWFRVUkVfMkQ7dGhpcy5fbWF4X3RleHR1cmVfaW1hZ2VfdW5pdHM9dGhpcy5fbWF4X3RleHR1cmVfaW1hZ2VfdW5pdHN8fG4uZ2V0UGFyYW1ldGVyKG4uTUFYX0NPTUJJTkVEX1RFWFRVUkVfSU1BR0VfVU5JVFMpLG4uYWN0aXZlVGV4dHVyZShuLlRFWFRVUkUwK3RoaXMuX21heF90ZXh0dXJlX2ltYWdlX3VuaXRzLTEpO2NvbnN0IE89bi5jcmVhdGVUZXh0dXJlKCk7bi5iaW5kVGV4dHVyZShhLE8pLG4ucGl4ZWxTdG9yZWkobi5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCEwKTtjb25zdHt3aWR0aDpBLGhlaWdodDpifT10aGlzLmNhbnZhcztpZih4KWlmKGE9PT1uLlRFWFRVUkVfQ1VCRV9NQVApZm9yKGxldCBJPTA7STw2O0krKyluLnRleEltYWdlMkQobi5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1grSSwwLG4uUkdCQSxuLlJHQkEsbi5VTlNJR05FRF9CWVRFLHhbSV0pO2Vsc2Ugbi50ZXhJbWFnZTJEKGEsMCxuLlJHQkEsbi5SR0JBLG4uVU5TSUdORURfQllURSx4KTtlbHNlIGlmKGE9PT1uLlRFWFRVUkVfQ1VCRV9NQVApZm9yKGxldCBJPTA7STw2O0krKyl0aGlzLmdsLnRleEltYWdlMkQodGhpcy5nbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1grSSwwLG4uUkdCQSxBLGIsMCxuLlJHQkEsbi5VTlNJR05FRF9CWVRFLG51bGwpO2Vsc2Ugbi50ZXhJbWFnZTJEKGEsMCxuLlJHQkEsQSxiLDAsbi5SR0JBLG4uVU5TSUdORURfQllURSxudWxsKTtyZXR1cm4gbi50ZXhQYXJhbWV0ZXJpKGEsbi5URVhUVVJFX01JTl9GSUxURVIsciksbi50ZXhQYXJhbWV0ZXJpKGEsbi5URVhUVVJFX01BR19GSUxURVIscyksbi50ZXhQYXJhbWV0ZXJpKGEsbi5URVhUVVJFX1dSQVBfUyxkKSxuLnRleFBhcmFtZXRlcmkoYSxuLlRFWFRVUkVfV1JBUF9ULHkpLGE9PT1uLlRFWFRVUkVfQ1VCRV9NQVAmJih4LndpZHRoPXhbMF0ud2lkdGgseC5oZWlnaHQ9eFswXS5oZWlnaHQpLG4uYmluZFRleHR1cmUoYSxudWxsKSxPLl9pbWc9eHx8e3dpZHRoOkEsaGVpZ2h0OmJ9LE8uZGVsZXRlPSgpPT57dGhpcy5kZWxldGVUZXh0dXJlKE8pfSxPfWRlbGV0ZVRleHR1cmUoeCl7Y29uc3QgZD14Ll9pbWc7dGhpcy5nbC5kZWxldGVUZXh0dXJlKHgpLHR5cGVvZiBkLmNsb3NlPT0iZnVuY3Rpb24iJiZkLmNsb3NlKCl9YXN5bmMgbG9hZFRleHR1cmUoeCx7dXNlSW1hZ2VCaXRtYXA6ZD0hMH09e30pe2NvbnN0IHk9YXdhaXQgcC5sb2FkSW1hZ2UoeCx7dXNlSW1hZ2VCaXRtYXA6ZH0pO3JldHVybiB0aGlzLmNyZWF0ZVRleHR1cmUoeSl9Y3JlYXRlRkJPKHtjb2xvcjp4PTEsYmxlbmQ6ZD0hMSxkZXB0aDp5PXRoaXMub3B0aW9ucy5kZXB0aCE9PSExLHN0ZW5jaWw6cj0hIXRoaXMub3B0aW9ucy5zdGVuY2lsfT17fSl7Y29uc3Qgcz10aGlzLmdsLG49cy5jcmVhdGVGcmFtZWJ1ZmZlcigpO3MuYmluZEZyYW1lYnVmZmVyKHMuRlJBTUVCVUZGRVIsbik7Y29uc3QgYT1bXTtmb3IobGV0IGI9MDtiPHg7YisrKXtjb25zdCBJPXRoaXMuY3JlYXRlVGV4dHVyZSgpO3MuZnJhbWVidWZmZXJUZXh0dXJlMkQocy5GUkFNRUJVRkZFUixzLkNPTE9SX0FUVEFDSE1FTlQwK2Iscy5URVhUVVJFXzJELEksMCksYS5wdXNoKEkpfW4udGV4dHVyZXM9YSxuLnRleHR1cmU9YVswXSxuLmJsZW5kPWQ7Y29uc3R7d2lkdGg6TyxoZWlnaHQ6QX09dGhpcy5jYW52YXM7cmV0dXJuIHkmJiFyJiYobi5kZXB0aEJ1ZmZlcj1zLmNyZWF0ZVJlbmRlcmJ1ZmZlcigpLHMuYmluZFJlbmRlcmJ1ZmZlcihzLlJFTkRFUkJVRkZFUixuLmRlcHRoQnVmZmVyKSxzLnJlbmRlcmJ1ZmZlclN0b3JhZ2Uocy5SRU5ERVJCVUZGRVIscy5ERVBUSF9DT01QT05FTlQxNixPLEEpLHMuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIocy5GUkFNRUJVRkZFUixzLkRFUFRIX0FUVEFDSE1FTlQscy5SRU5ERVJCVUZGRVIsbi5kZXB0aEJ1ZmZlcikpLHImJiF5JiYobi5zdGVuY2lsQnVmZmVyPXMuY3JlYXRlUmVuZGVyYnVmZmVyKCkscy5iaW5kUmVuZGVyYnVmZmVyKHMuUkVOREVSQlVGRkVSLG4uc3RlbmNpbEJ1ZmZlcikscy5yZW5kZXJidWZmZXJTdG9yYWdlKHMuUkVOREVSQlVGRkVSLHMuU1RFTkNJTF9JTkRFWDgsTyxBKSxzLmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKHMuRlJBTUVCVUZGRVIscy5TVEVOQ0lMX0FUVEFDSE1FTlQscy5SRU5ERVJCVUZGRVIsbi5zdGVuY2lsQnVmZmVyKSkseSYmciYmKG4uZGVwdGhTdGVuY2lsQnVmZmVyPXMuY3JlYXRlUmVuZGVyYnVmZmVyKCkscy5iaW5kUmVuZGVyYnVmZmVyKHMuUkVOREVSQlVGRkVSLG4uZGVwdGhTdGVuY2lsQnVmZmVyKSxzLnJlbmRlcmJ1ZmZlclN0b3JhZ2Uocy5SRU5ERVJCVUZGRVIscy5ERVBUSF9TVEVOQ0lMLE8sQSkscy5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlcihzLkZSQU1FQlVGRkVSLHMuREVQVEhfU1RFTkNJTF9BVFRBQ0hNRU5ULHMuUkVOREVSQlVGRkVSLG4uZGVwdGhTdGVuY2lsQnVmZmVyKSkscy5iaW5kRnJhbWVidWZmZXIocy5GUkFNRUJVRkZFUixudWxsKSxufWJpbmRGQk8oeD1udWxsKXt0aGlzLmZibz14fXJlbmRlcih7Y2xlYXJCdWZmZXI6eD0hMH09e30pe3RoaXMuc3RhcnRSZW5kZXI9ITA7Y29uc3QgZD10aGlzLmdsO2xldCB5PXRoaXMucHJvZ3JhbTt5fHwoeT10aGlzLmNyZWF0ZVByb2dyYW0oKSx0aGlzLnVzZVByb2dyYW0oeSkpLHRoaXMuZmJvJiZkLmJpbmRGcmFtZWJ1ZmZlcihkLkZSQU1FQlVGRkVSLHRoaXMuZmJvKTtjb25zdCByPXRoaXMub3B0aW9ucy5kZXB0aDtyJiZkLmVuYWJsZShkLkRFUFRIX1RFU1QpLHRoaXMuZ2wuY2xlYXIodGhpcy5nbC5DT0xPUl9CVUZGRVJfQklUfChyP3RoaXMuZ2wuREVQVEhfQlVGRkVSX0JJVDowKXwodGhpcy5vcHRpb25zLnN0ZW5jaWw/dGhpcy5nbC5TVEVOQ0lMX0JVRkZFUl9CSVQ6MCkpO2NvbnN0IHM9dGhpcy5fcmVuZGVyRnJhbWVJRDt0aGlzLl9kcmF3KCksdGhpcy5mYm8mJmQuYmluZEZyYW1lYnVmZmVyKGQuRlJBTUVCVUZGRVIsbnVsbCksdGhpcy5fcmVuZGVyRnJhbWVJRD09PXMmJih0aGlzLl9yZW5kZXJGcmFtZUlEPW51bGwpfXVwZGF0ZSgpe3RoaXMuc3RhcnRSZW5kZXImJnRoaXMuX3JlbmRlckZyYW1lSUQ9PW51bGwmJih0aGlzLl9yZW5kZXJGcmFtZUlEPXJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLnJlbmRlci5iaW5kKHRoaXMpKSl9fWMocCwiZGVmYXVsdE9wdGlvbnMiLHtwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6ITAsYXV0b1VwZGF0ZTohMCx2ZXJ0ZXhQb3NpdGlvbjoiYV92ZXJ0ZXhQb3NpdGlvbiIsdmVydGV4VGV4dHVyZUNvb3JkOiJhX3ZlcnRleFRleHR1cmVDb29yZCIsd2ViZ2wyOiExfSksYyhwLCJVQllURSIscC5VTlNJR05FRF9CWVRFKSxjKHAsIlVTSE9SVCIscC5VTlNJR05FRF9TSE9SVCksYyhwLCJmZXRjaFNoYWRlciIsaS5mZXRjaFNoYWRlciksYyhwLCJsb2FkSW1hZ2UiLGkubG9hZEltYWdlKX0sZnVuY3Rpb24oUixlLHQpe3QucihlKSx0LmQoZSwic2V0dXBXZWJHTCIsZnVuY3Rpb24oKXtyZXR1cm4gb30pLHQuZChlLCJjcmVhdGVQcm9ncmFtIixmdW5jdGlvbigpe3JldHVybiBnfSksdC5kKGUsInBvaW50c1RvQnVmZmVyIixmdW5jdGlvbigpe3JldHVybiB2fSksdC5kKGUsImxvYWRJbWFnZSIsZnVuY3Rpb24oKXtyZXR1cm4gZn0pLHQuZChlLCJmZXRjaFNoYWRlciIsZnVuY3Rpb24oKXtyZXR1cm4gRX0pLHQoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBpKGwsbSl7Y29uc3QgcD1bIndlYmdsIiwiZXhwZXJpbWVudGFsLXdlYmdsIiwid2Via2l0LTNkIiwibW96LXdlYmdsIl07bGV0IEM9bnVsbDtmb3IobGV0IHg9MDt4PHAubGVuZ3RoOysreCl7dHJ5e0M9bC5nZXRDb250ZXh0KHBbeF0sbSl9Y2F0Y2h7fWlmKEMpYnJlYWt9cmV0dXJuIEN9ZnVuY3Rpb24gbyhsLG0pe2NvbnN0IHA9aShsLG0pO2lmKCFwKXRocm93IG5ldyBFcnJvcigiU29ycnksIHlvdXIgYnJvd3NlciBkb2Vzbid0IHN1cHBvcnQgV2ViR0wuIik7cmV0dXJuIHB9ZnVuY3Rpb24gZyhsLG0scCl7Y29uc3QgQz1sLmNyZWF0ZVNoYWRlcihsLlZFUlRFWF9TSEFERVIpO2lmKGwuc2hhZGVyU291cmNlKEMsbSksbC5jb21waWxlU2hhZGVyKEMpLCFsLmdldFNoYWRlclBhcmFtZXRlcihDLGwuQ09NUElMRV9TVEFUVVMpKXtjb25zdCB5PWBWZXJ0ZXggc2hhZGVyIGZhaWxlZCB0byBjb21waWxlLiAgVGhlIGVycm9yIGxvZyBpczoke2wuZ2V0U2hhZGVySW5mb0xvZyhDKX1gO3Rocm93IG5ldyBFcnJvcih5KX1jb25zdCB4PWwuY3JlYXRlU2hhZGVyKGwuRlJBR01FTlRfU0hBREVSKTtpZihsLnNoYWRlclNvdXJjZSh4LHApLGwuY29tcGlsZVNoYWRlcih4KSwhbC5nZXRTaGFkZXJQYXJhbWV0ZXIoeCxsLkNPTVBJTEVfU1RBVFVTKSl7Y29uc3QgeT1gRnJhZ21lbnQgc2hhZGVyIGZhaWxlZCB0byBjb21waWxlLiAgVGhlIGVycm9yIGxvZyBpczoke2wuZ2V0U2hhZGVySW5mb0xvZyh4KX1gO3Rocm93IG5ldyBFcnJvcih5KX1jb25zdCBkPWwuY3JlYXRlUHJvZ3JhbSgpO2lmKGwuYXR0YWNoU2hhZGVyKGQsQyksbC5hdHRhY2hTaGFkZXIoZCx4KSxsLmxpbmtQcm9ncmFtKGQpLCFsLmdldFByb2dyYW1QYXJhbWV0ZXIoZCxsLkxJTktfU1RBVFVTKSl7Y29uc3QgeT1gU2hhZGVyIHByb2dyYW0gZmFpbGVkIHRvIGxpbmsuICBUaGUgZXJyb3IgbG9nIGlzOiR7bC5nZXRQcm9ncmFtSW5mb0xvZyhkKX1gO3Rocm93IG5ldyBFcnJvcih5KX1yZXR1cm4gbC5kZWxldGVTaGFkZXIoQyksbC5kZWxldGVTaGFkZXIoeCksZH1mdW5jdGlvbiB2KGwsbT1GbG9hdDMyQXJyYXkscD1udWxsKXtpZihwJiYhKHAgaW5zdGFuY2VvZiBtKSl0aHJvdyBuZXcgVHlwZUVycm9yKCJXcm9uZyBidWZmZXIgdHlwZS4iKTtpZihsPT1udWxsfHxsIGluc3RhbmNlb2YgbSlyZXR1cm4gbDtpZihsWzBdPT1udWxsfHxsWzBdLmxlbmd0aD09bnVsbClyZXR1cm4gcD8ocC5zZXQobCwwKSxwKTpuZXcgbShsKTtjb25zdCBDPWxbMF0ubGVuZ3RoLHg9bC5sZW5ndGg7cHx8KHA9bmV3IG0oQyp4KSk7bGV0IGQ9MDtmb3IobGV0IHk9MDt5PHg7eSsrKWZvcihsZXQgcj0wO3I8QztyKyspcFtkKytdPWxbeV1bcl07cmV0dXJuIHB9Y29uc3QgYz17fTtmdW5jdGlvbiBmKGwse3VzZUltYWdlQml0bWFwOm09ITAsYWxpYXM6cD1udWxsfT17fSl7aWYoIWNbbF0pe2lmKHR5cGVvZiBJbWFnZT09ImZ1bmN0aW9uIil7Y29uc3QgQz1uZXcgSW1hZ2U7dHlwZW9mIGw9PSJzdHJpbmciJiYhKHR5cGVvZiBsb2NhdGlvbj09Im9iamVjdCImJi9eZmlsZTovLnRlc3QobG9jYXRpb24uaHJlZikpJiYhL15kYXRhOi8udGVzdChsKSYmKEMuY3Jvc3NPcmlnaW49ImFub255bW91cyIpLGNbbF09bmV3IFByb21pc2UoeD0+e0Mub25sb2FkPWZ1bmN0aW9uKCl7bSYmdHlwZW9mIGNyZWF0ZUltYWdlQml0bWFwPT0iZnVuY3Rpb24iP2NyZWF0ZUltYWdlQml0bWFwKEMse2ltYWdlT3JpZW50YXRpb246ImZsaXBZIn0pLnRoZW4oZD0+e2NbbF09ZCxwJiYoY1twXT1kKSx4KGQpfSk6KGNbbF09QyxwJiYoY1twXT1DKSx4KEMpKX0sQy5zcmM9bH0pLHAmJihjW3BdPWNbbF0pfWVsc2UgaWYodHlwZW9mIGZldGNoPT0iZnVuY3Rpb24iKXJldHVybiBmZXRjaChsLHttZXRob2Q6IkdFVCIsbW9kZToiY29ycyIsY2FjaGU6ImRlZmF1bHQifSkudGhlbihDPT5DLmJsb2IoKSkudGhlbihDPT5jcmVhdGVJbWFnZUJpdG1hcChDLHtpbWFnZU9yaWVudGF0aW9uOiJmbGlwWSJ9KS50aGVuKHg9PihjW2xdPXgscCYmKGNbcF09eCkseCkpKX1yZXR1cm4gY1tsXX1jb25zdCBoPXt9O2FzeW5jIGZ1bmN0aW9uIEUobCl7aWYoaFtsXSlyZXR1cm4gaFtsXTtjb25zdCBtPWF3YWl0IGZldGNoKGwpO2lmKG0uc3RhdHVzPj0yMDAmJm0uc3RhdHVzPDMwMCl7Y29uc3QgcD1hd2FpdCBtLnRleHQoKTtyZXR1cm4gaFtsXT1wLHB9dGhyb3cgbmV3IEVycm9yKCJTaGFkZXIgbG9hZGVkIGVycm9yLiIpfX0sZnVuY3Rpb24oUixlLHQpe3QucihlKSxlLmRlZmF1bHQ9YGF0dHJpYnV0ZSB2ZWMzIGFfdmVydGV4UG9zaXRpb247Cgp2b2lkIG1haW4oKSB7CiAgZ2xfUG9pbnRTaXplID0gMS4wOwogIGdsX1Bvc2l0aW9uID0gdmVjNChhX3ZlcnRleFBvc2l0aW9uLCAxKTsKfWB9LGZ1bmN0aW9uKFIsZSx0KXt0LnIoZSksZS5kZWZhdWx0PWAjaWZkZWYgR0xfRVMKcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7CiNlbmRpZgoKdm9pZCBtYWluKCkgewogIGdsX0ZyYWdDb2xvciA9IHZlYzQoMC4wLCAwLjAsIDAuMCwgMC4xKTsKfWB9LGZ1bmN0aW9uKFIsZSx0KXt0LnIoZSksZS5kZWZhdWx0PWBhdHRyaWJ1dGUgdmVjNCBhX3ZlcnRleFBvc2l0aW9uOwphdHRyaWJ1dGUgdmVjMiBhX3ZlcnRleFRleHR1cmVDb29yZDsKdmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7Cgp2b2lkIG1haW4oKSB7CiAgZ2xfUG9pbnRTaXplID0gMS4wOwogIGdsX1Bvc2l0aW9uID0gYV92ZXJ0ZXhQb3NpdGlvbjsKICB2VGV4dHVyZUNvb3JkID0gYV92ZXJ0ZXhUZXh0dXJlQ29vcmQ7Cn1gfSxmdW5jdGlvbihSLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiB2fSk7dmFyIGk9dCgyMSksbz10KDI1KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3QgZz1TeW1ib2woInRyYW5zZm9ybSIpO2NsYXNzIHZ7Y29uc3RydWN0b3IoZixoKXt0aGlzLmNvbnRleHQ9Zi5nZXRDb250ZXh0KCIyZCIpLHRoaXMub3B0aW9ucz1oLHRoaXNbZ109WzEsMCwwLDEsMCwwXX1jcmVhdGVUZXh0dXJlKGYpe3JldHVybntfaW1nOmZ9fWFzeW5jIGxvYWRUZXh0dXJlKGYpe2NvbnN0IGg9YXdhaXQgaS5kZWZhdWx0LmxvYWRJbWFnZShmLHt1c2VJbWFnZUJpdG1hcDohMX0pO3JldHVybiB0aGlzLmNyZWF0ZVRleHR1cmUoaCl9ZGVsZXRlVGV4dHVyZShmKXtyZXR1cm4gZn1jbGVhcihmLGgsRSxsKXtjb25zdCBtPXRoaXMuY29udGV4dDtmPWZ8fDAsaD1ofHwwLEU9RXx8bS5jYW52YXMud2lkdGgtZixsPWx8fG0uY2FudmFzLmhlaWdodC1oLG0uY2xlYXJSZWN0KGYsaCxFLGwpfWRyYXdNZXNoQ2xvdWQoZix7Y2xlYXI6aD0hMX09e30pe2NvbnN0IEU9W107Zm9yKGxldCBsPTA7bDxmLmFtb3VudDtsKyspe2NvbnN0IG09Zi5nZXRUcmFuc2Zvcm0obCk7bGV0IHA9Zi5nZXRUZXh0dXJlRnJhbWUobCk7cCYmKHA9cC5faW1nKTtjb25zdCBDPWYuZ2V0RmlsdGVyKGwpLHtmaWxsOngsc3Ryb2tlOmR9PWYuZ2V0Q2xvdWRSR0JBKGwpO0UucHVzaCh7bWVzaDpmLm1lc2gsX2Nsb3VkT3B0aW9uczpbeCxkLHAsbSxDXX0pfWYuYmVmb3JlUmVuZGVyJiZmLmJlZm9yZVJlbmRlcih0aGlzLmNvbnRleHQsZiksdGhpcy5kcmF3TWVzaGVzKEUse2NsZWFyOmgsaG9vazohMX0pLGYuYWZ0ZXJSZW5kZXImJmYuYWZ0ZXJSZW5kZXIodGhpcy5jb250ZXh0LGYpfWRyYXdNZXNoZXMoZix7Y2xlYXI6aD0hMSxob29rOkU9ITB9PXt9KXtjb25zdCBsPXRoaXMuY29udGV4dDtoJiZsLmNsZWFyUmVjdCgwLDAsbC5jYW52YXMud2lkdGgsbC5jYW52YXMuaGVpZ2h0KTtsZXQgbT1udWxsO2NvbnN0e3dpZHRoOnAsaGVpZ2h0OkN9PWwuY2FudmFzLHg9Zi5sZW5ndGg7Zi5mb3JFYWNoKChkLHkpPT57bGV0IHIscyxuLGEsTztFJiZkLmJlZm9yZVJlbmRlciYmZC5iZWZvcmVSZW5kZXIobCxkKSxkLl9jbG91ZE9wdGlvbnMmJihbcixzLG4sYSxPXT1kLl9jbG91ZE9wdGlvbnMsZD1kLm1lc2gpO2xldCBBPWQuZmlsdGVyO2lmKE8mJihBPUE/YCR7QX0gJHtPfWA6TyksQSYmIXRoaXMuZmlsdGVyQnVmZmVyJiZ0aGlzLmZpbHRlckJ1ZmZlciE9PSExKXtjb25zdCBiPWkuZGVmYXVsdC5jcmVhdGVDYW52YXMocCxDKTtiP3RoaXMuZmlsdGVyQnVmZmVyPWIuZ2V0Q29udGV4dCgiMmQiKTp0aGlzLmZpbHRlckJ1ZmZlcj0hMX1tJiZtIT09QSYmKE9iamVjdChvLmFwcGx5RmlsdGVyKSh0aGlzLmZpbHRlckJ1ZmZlcixtKSxsLmRyYXdJbWFnZSh0aGlzLmZpbHRlckJ1ZmZlci5jYW52YXMsMCwwLHAsQyksdGhpcy5maWx0ZXJCdWZmZXIuY2xlYXJSZWN0KDAsMCxwLEMpLG09bnVsbCksQSYmdGhpcy5maWx0ZXJCdWZmZXI/KHRoaXMuZmlsdGVyQnVmZmVyLnNhdmUoKSx0aGlzLmZpbHRlckJ1ZmZlci50cmFuc2Zvcm0oLi4udGhpc1tnXSksT2JqZWN0KG8uZHJhd01lc2gyRCkoZCx0aGlzLmZpbHRlckJ1ZmZlciwhMSxyLHMsbixhKSx0aGlzLmZpbHRlckJ1ZmZlci5yZXN0b3JlKCkseT09PXgtMT8oT2JqZWN0KG8uYXBwbHlGaWx0ZXIpKHRoaXMuZmlsdGVyQnVmZmVyLEEpLGwuZHJhd0ltYWdlKHRoaXMuZmlsdGVyQnVmZmVyLmNhbnZhcywwLDAscCxDKSx0aGlzLmZpbHRlckJ1ZmZlci5jbGVhclJlY3QoMCwwLHAsQykpOm09QSk6KGwuc2F2ZSgpLGwudHJhbnNmb3JtKC4uLnRoaXNbZ10pLE9iamVjdChvLmRyYXdNZXNoMkQpKGQsbCwhMSxyLHMsbixhKSxsLnJlc3RvcmUoKSksRSYmZC5hZnRlclJlbmRlciYmZC5hZnRlclJlbmRlcihsLGQpfSl9c2V0VHJhbnNmb3JtKGYpe3RoaXNbZ109Zn19fSxmdW5jdGlvbihSLGUsdCl7dC5yKGUpLChmdW5jdGlvbihpKXt2YXIgbz10KDE0KSxnPXQoMjMpLHY9dCgyNCk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IGM9e307ZnVuY3Rpb24gZihwLEMpe2NvbnN0e3N0eWxlOngsdmFyaWFudDpkLHdlaWdodDp5LHN0cmV0Y2g6cixzaXplOnMscHhMaW5lSGVpZ2h0Om4sZmFtaWx5OmF9PXA7cmV0dXJuIHI9PT0ibm9ybWFsIj9gJHt4fSAke2R9ICR7eX0gJHtzKkN9cHgvJHtuKkN9cHggJHthfWA6YCR7eH0gJHtkfSAke3l9ICR7cn0gJHtzKkN9cHgvJHtuKkN9cHggJHthfWB9ZnVuY3Rpb24gaChwLHtmb250OkMsZmlsbENvbG9yOngsc3Ryb2tlQ29sb3I6ZCxzdHJva2VXaWR0aDp5LHJhdGlvOnI9MSx0ZXh0Q2FudmFzOnMsY2FjaGFibGU6bj0hMX0pe2xldCBhO2lmKG4pe2E9W3AsQyxTdHJpbmcoeCksU3RyaW5nKGQpLFN0cmluZyh5KV0uam9pbigiIyMjIik7Y29uc3QgJD1jW2FdO2lmKCQpcmV0dXJuICR9c3x8KHM9bCgxLDEpKTtjb25zdCBPPXMuZ2V0Q29udGV4dCgiMmQiKTtPLnNhdmUoKSxPLmZvbnQ9QztsZXR7d2lkdGg6QX09Ty5tZWFzdXJlVGV4dChwKTtPLnJlc3RvcmUoKTtjb25zdCBiPU9iamVjdChnLmRlZmF1bHQpKEMpLEk9TWF0aC5tYXgoYi5weExpbmVIZWlnaHQsYi5weEhlaWdodCoxLjEzKTsvaXRhbGljfG9ibGlxdWUvLnRlc3QoQykmJihBKz1JKk1hdGgudGFuKDE1Kk1hdGguUEkvMTgwKSksIXgmJiFkJiYoeD0iIzAwMCIpO2NvbnN0IFA9Ty5jYW52YXMsRD1NYXRoLmNlaWwoQSksTD1NYXRoLmNlaWwoSSk7UC53aWR0aD1NYXRoLnJvdW5kKEQqciksUC5oZWlnaHQ9TWF0aC5yb3VuZChMKnIpLE8uc2F2ZSgpLE8uZm9udD1mKGIsciksTy50ZXh0QWxpZ249ImNlbnRlciIsTy50ZXh0QmFzZWxpbmU9Im1pZGRsZSI7Y29uc3QgUz1QLmhlaWdodCouNStiLnB4SGVpZ2h0Ki4wNSpyLFQ9UC53aWR0aCouNTtpZih4KXtpZihBcnJheS5pc0FycmF5KHgpKXg9T2JqZWN0KHYuZGVmYXVsdCkoeCk7ZWxzZSBpZih4LnZlY3Rvcil7bGV0ICQ7Y29uc3R7dmVjdG9yOncsY29sb3JzOkp9PXg7dy5sZW5ndGg9PT02PyQ9Ty5jcmVhdGVSYWRpYWxHcmFkaWVudCguLi53KTokPU8uY3JlYXRlTGluZWFyR3JhZGllbnQoLi4udyksSi5mb3JFYWNoKCh7b2Zmc2V0OnEsY29sb3I6V30pPT57JC5hZGRDb2xvclN0b3AocSxXKX0pLHg9JH1PLmZpbGxTdHlsZT14LE8uZmlsbFRleHQocCxULFMpfWlmKGQpe2lmKE8ubGluZVdpZHRoPXkqcixBcnJheS5pc0FycmF5KGQpKWQ9T2JqZWN0KHYuZGVmYXVsdCkoZCk7ZWxzZSBpZihkLnZlY3Rvcil7bGV0ICQ7Y29uc3R7dmVjdG9yOncsY29sb3JzOkp9PWQ7dy5sZW5ndGg9PT02PyQ9Ty5jcmVhdGVSYWRpYWxHcmFkaWVudCguLi53KTokPU8uY3JlYXRlTGluZWFyR3JhZGllbnQoLi4udyksSi5mb3JFYWNoKCh7b2Zmc2V0OnEsY29sb3I6V30pPT57JC5hZGRDb2xvclN0b3AocSxXKX0pLGQ9JH1PLnN0cm9rZVN0eWxlPWQsTy5zdHJva2VUZXh0KHAsVCxTKX1PLnJlc3RvcmUoKTtjb25zdCBqPXtpbWFnZTpzLHJlY3Q6WzAsMCxELExdfTtyZXR1cm4gbiYmKGNbYV09aiksan1sZXQgRT0hMTtpZih0eXBlb2YgbmF2aWdhdG9yPT0ib2JqZWN0IiYmdHlwZW9mIG5hdmlnYXRvci51c2VyQWdlbnQ9PSJzdHJpbmciKXtjb25zdCBwPW5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvY2hyb21lXC8oXGQrKS8pO3AmJihFPU51bWJlcihwWzFdKTw3MCl9ZnVuY3Rpb24gbChwLEMseD17fSl7Y29uc3QgZD14Lm9mZnNjcmVlbnx8IUUmJngub2Zmc2NyZWVuIT09ITE7bGV0IHk7cmV0dXJuIHR5cGVvZiBpPCJ1IiYmdHlwZW9mIGkuY3JlYXRlQ2FudmFzPT0iZnVuY3Rpb24iP3k9aS5jcmVhdGVDYW52YXMocCxDLHgpOmQmJnR5cGVvZiBPZmZzY3JlZW5DYW52YXM9PSJmdW5jdGlvbiI/eT1uZXcgT2Zmc2NyZWVuQ2FudmFzKHAsQyk6KHk9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiY2FudmFzIikseS53aWR0aD1wLHkuaGVpZ2h0PUMpLHl9Y29uc3QgbT17Y3JlYXRlQ2FudmFzOmwsY3JlYXRlVGV4dDpoLGxvYWRJbWFnZTpvLmRlZmF1bHQubG9hZEltYWdlfTtlLmRlZmF1bHQ9bX0pLmNhbGwodGhpcyx0KDIyKSl9LGZ1bmN0aW9uKFIsZSl7dmFyIHQ7dD1mdW5jdGlvbigpe3JldHVybiB0aGlzfSgpO3RyeXt0PXR8fG5ldyBGdW5jdGlvbigicmV0dXJuIHRoaXMiKSgpfWNhdGNoe3R5cGVvZiB3aW5kb3c9PSJvYmplY3QiJiYodD13aW5kb3cpfVIuZXhwb3J0cz10fSxmdW5jdGlvbihSLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiB4fSksdCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIGkoZCx5KXtpZih0eXBlb2YgZD09InN0cmluZyIpe2NvbnN0IG49ZC50cmltKCkubWF0Y2goL14oW1xkLl0rKShweHxwdHxwY3xpbnxjbXxtbXxlbXxleHxyZW18cXx2d3x2aHx2bWF4fHZtaW58JSkkLyk7bj9kPXtzaXplOnBhcnNlRmxvYXQoblsxXSksdW5pdDpuWzJdfTpkPXtzaXplOnBhcnNlSW50KGQsMTApLHVuaXQ6InB4In19bGV0e3NpemU6cix1bml0OnN9PWQ7aWYocz09PSJwdCIpci89Ljc1O2Vsc2UgaWYocz09PSJwYyIpcio9MTY7ZWxzZSBpZihzPT09ImluIilyKj05NjtlbHNlIGlmKHM9PT0iY20iKXIqPTk2LzIuNTQ7ZWxzZSBpZihzPT09Im1tIilyKj05Ni8yNS40O2Vsc2UgaWYocz09PSJlbSJ8fHM9PT0icmVtInx8cz09PSJleCIpe2lmKCF5JiZ0eXBlb2YgZ2V0Q29tcHV0ZWRTdHlsZT09ImZ1bmN0aW9uIiYmdHlwZW9mIGRvY3VtZW50PCJ1Iil7Y29uc3Qgbj1nZXRDb21wdXRlZFN0eWxlKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkuZm9udFNpemU7eT1pKG4sMTYpfXIqPXkscz09PSJleCImJihyLz0yKX1lbHNlIGlmKHM9PT0icSIpcio9OTYvMjUuNC80O2Vsc2UgaWYocz09PSJ2dyJ8fHM9PT0idmgiKXtpZih0eXBlb2YgZG9jdW1lbnQ8InUiKXtjb25zdCBuPXM9PT0idnciP2RvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aDpkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0O3IqPW4vMTAwfX1lbHNlIGlmKChzPT09InZtYXgifHxzPT09InZtaW4iKSYmdHlwZW9mIGRvY3VtZW50PCJ1Iil7Y29uc3Qgbj1kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGgsYT1kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0O3M9PT0idm1heCI/cio9TWF0aC5tYXgobixhKS8xMDA6cio9TWF0aC5taW4obixhKS8xMDB9cmV0dXJuIHJ9Y29uc3Qgbz0iYm9sZHxib2xkZXJ8bGlnaHRlcnxbMS05XTAwIixnPSJpdGFsaWN8b2JsaXF1ZSIsdj0ic21hbGwtY2FwcyIsYz0idWx0cmEtY29uZGVuc2VkfGV4dHJhLWNvbmRlbnNlZHxjb25kZW5zZWR8c2VtaS1jb25kZW5zZWR8c2VtaS1leHBhbmRlZHxleHBhbmRlZHxleHRyYS1leHBhbmRlZHx1bHRyYS1leHBhbmRlZCIsZj0icHh8cHR8cGN8aW58Y218bW18ZW18ZXh8cmVtfHF8dnd8dmh8dm1heHx2bWlufCUiLGg9YCcoW14nXSspJ3wiKFteIl0rKSJ8KFtcXHctXXxb5LiALem+pV0pK2AsRT1uZXcgUmVnRXhwKGAoJHtvfSkgK2AsImkiKSxsPW5ldyBSZWdFeHAoYCgke2d9KSArYCwiaSIpLG09bmV3IFJlZ0V4cChgKCR7dn0pICtgLCJpIikscD1uZXcgUmVnRXhwKGAoJHtjfSkgK2AsImkiKSxDPW5ldyBSZWdFeHAoIihbXFxkXFwuXSspKCIrZisiKSg/OlxcLyhbXFxkXFwuXSspKCIrZisiKSk/ICooKD86IitoKyIpKCAqLCAqKD86IitoKyIpKSopIik7ZnVuY3Rpb24geChkLHkpe2NvbnN0IHI9Qy5leGVjKGQpO2lmKCFyKXJldHVybjtjb25zdCBzPXBhcnNlRmxvYXQoclszXSksbj17d2VpZ2h0OiJub3JtYWwiLHN0eWxlOiJub3JtYWwiLHN0cmV0Y2g6Im5vcm1hbCIsdmFyaWFudDoibm9ybWFsIixzaXplOnBhcnNlRmxvYXQoclsxXSksdW5pdDpyWzJdLGxpbmVIZWlnaHQ6TnVtYmVyLmlzRmluaXRlKHMpP3M6dm9pZCAwLGxpbmVIZWlnaHRVbml0OnJbNF0sZmFtaWx5OnJbNV0ucmVwbGFjZSgvICosICovZywiLCIpfSxhPWQuc3Vic3RyaW5nKDAsci5pbmRleCksTz1FLmV4ZWMoYSksQT1sLmV4ZWMoYSksYj1tLmV4ZWMoYSksST1wLmV4ZWMoYSk7cmV0dXJuIE8mJihuLndlaWdodD1PWzFdKSxBJiYobi5zdHlsZT1BWzFdKSxiJiYobi52YXJpYW50PWJbMV0pLEkmJihuLnN0cmV0Y2g9SVsxXSksbi5weEhlaWdodD1pKHtzaXplOm4uc2l6ZSx1bml0Om4udW5pdH0seSksbi5weExpbmVIZWlnaHQ9aSh7c2l6ZTpuLmxpbmVIZWlnaHR8fG4uc2l6ZSx1bml0Om4ubGluZUhlaWdodFVuaXR8fG4udW5pdH0seSksbn19LGZ1bmN0aW9uKFIsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIGl9KSx0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gaShvKXtyZXR1cm5gcmdiYSgke28ubWFwKChnLHYpPT52PDM/TWF0aC5yb3VuZChnKjI1NSk6Zykuam9pbigpfSlgfX0sZnVuY3Rpb24oUixlLHQpe3QucihlKSx0LmQoZSwiYXBwbHlGaWx0ZXIiLGZ1bmN0aW9uKCl7cmV0dXJuIGN9KSx0LmQoZSwiZHJhd01lc2gyRCIsZnVuY3Rpb24oKXtyZXR1cm4gaH0pO3ZhciBpPXQoMSksbz10KDI0KSxnPXQoMjMpLHY9dCgyNik7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIGMoRSxsKXtjb25zdCBtPUUuY2FudmFzO0Uuc2F2ZSgpLEUuZmlsdGVyPWwsRS5kcmF3SW1hZ2UobSwwLDAsbS53aWR0aCxtLmhlaWdodCksRS5yZXN0b3JlKCl9ZnVuY3Rpb24gZihFLGwpe2NvbnN0IG09L3JnYmFcKChcZCspLChcZCspLChcZCspLChcZCspXCkvO0U9RS5tYXRjaChtKS5zbGljZSgxLDUpLm1hcChOdW1iZXIpLGw9bC5tYXRjaChtKS5zbGljZSgxLDUpLm1hcChOdW1iZXIpO2NvbnN0IHA9W10sQz1sWzNdO2ZvcihsZXQgeD0wO3g8NDt4KyspcFt4XT1PYmplY3Qodi5taXgpKEVbeF0sbFt4XSxDKTtyZXR1cm5gcmdiYSgke3Auam9pbigpfSlgfWZ1bmN0aW9uIGgoRSxsLG09ITAscD1udWxsLEM9bnVsbCx4PW51bGwsZD1udWxsKXtsLnNhdmUoKTtsZXQgeT0hMSxyPSExO2lmKGwuZ2xvYmFsQWxwaGE9RS5nZXRPcGFjaXR5KCksRS5fdXBkYXRlTWF0cml4JiZFLnRyYW5zZm9ybVNjYWxlL0UuY29udG91cnMuc2NhbGU+MS41JiZFLmFjY3VyYXRlKEUudHJhbnNmb3JtU2NhbGUpLEUubGluZVdpZHRoKXtsZXQgYT1FLmdyYWRpZW50JiZFLmdyYWRpZW50LnN0cm9rZTtpZihhKXtjb25zdHt2ZWN0b3I6Tyxjb2xvcnM6QX09YTtpZihPLmxlbmd0aD09PTYpYT1sLmNyZWF0ZVJhZGlhbEdyYWRpZW50KC4uLk8pO2Vsc2UgaWYoTy5sZW5ndGg9PT00KWE9bC5jcmVhdGVMaW5lYXJHcmFkaWVudCguLi5PKTtlbHNlIGlmKE8ubGVuZ3RoPT09MylhPWwuY3JlYXRlQ2lyY3VsYXJHcmFkaWVudCguLi5PKTtlbHNlIHRocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgdmVjdG9yIGRpbWVuc2lvbi4iKTtBLmZvckVhY2goKHtvZmZzZXQ6Yixjb2xvcjpJfSk9PntsZXQgUD1PYmplY3Qoby5kZWZhdWx0KShJKTtDJiYoUD1mKFAsQykpLGEuYWRkQ29sb3JTdG9wKGIsUCl9KSxsLnN0cm9rZVN0eWxlPWEseT0hMH1lbHNlIEUuc3Ryb2tlU3R5bGUmJihDP2wuc3Ryb2tlU3R5bGU9ZihFLnN0cm9rZVN0eWxlLEMpOmwuc3Ryb2tlU3R5bGU9RS5zdHJva2VTdHlsZSx5PSEwKX15JiYobC5saW5lV2lkdGg9RS5saW5lV2lkdGgsbC5saW5lSm9pbj1FLmxpbmVKb2luLGwubGluZUNhcD1FLmxpbmVDYXAsbC5taXRlckxpbWl0PUUubWl0ZXJMaW1pdCxFLmxpbmVEYXNoJiYobC5zZXRMaW5lRGFzaChFLmxpbmVEYXNoKSxFLmxpbmVEYXNoT2Zmc2V0JiYobC5saW5lRGFzaE9mZnNldD1FLmxpbmVEYXNoT2Zmc2V0KSkpO2xldCBzPUUuZ3JhZGllbnQmJkUuZ3JhZGllbnQuZmlsbDtpZihzKXtjb25zdHt2ZWN0b3I6YSxjb2xvcnM6T309cztpZihhLmxlbmd0aD09PTYpcz1sLmNyZWF0ZVJhZGlhbEdyYWRpZW50KC4uLmEpO2Vsc2UgaWYoYS5sZW5ndGg9PT00KXM9bC5jcmVhdGVMaW5lYXJHcmFkaWVudCguLi5hKTtlbHNlIGlmKGEubGVuZ3RoPT09MylzPWwuY3JlYXRlQ2lyY3VsYXJHcmFkaWVudCguLi5hKTtlbHNlIHRocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgdmVjdG9yIGRpbWVuc2lvbi4iKTtPLmZvckVhY2goKHtvZmZzZXQ6QSxjb2xvcjpifSk9PntsZXQgST1PYmplY3Qoby5kZWZhdWx0KShiKTtDJiYoST1mKEksQykpLHMuYWRkQ29sb3JTdG9wKEEsSSl9KSxsLmZpbGxTdHlsZT1zLHI9ITB9ZWxzZSBFLmZpbGxTdHlsZSYmKHA/bC5maWxsU3R5bGU9ZihFLmZpbGxTdHlsZSxwKTpsLmZpbGxTdHlsZT1FLmZpbGxTdHlsZSxyPSEwKTtpZihkJiZsLnRyYW5zZm9ybSguLi5kKSxsLnRyYW5zZm9ybSguLi5FLnRyYW5zZm9ybU1hdHJpeCksRS5jbGlwUGF0aCl7Y29uc3QgYT1FLmNsaXBQYXRoLE89bmV3IFBhdGgyRChhKTtsLmNsaXAoTyl9Y29uc3Qgbj1FLmNvbnRvdXJzLmxlbmd0aDtpZihFLmNvbnRvdXJzLmZvckVhY2goKGEsTyk9Pntjb25zdCBBPWEubGVuZ3RoLGI9QT4xJiZpLnZlYzIuZXF1YWxzKGFbMF0sYVtBLTFdKSxJPU89PT1uLTEmJkUudGV4dHVyZTtpZihhJiZBPjApe2lmKHJ8fHl8fEkpe2wuYmVnaW5QYXRoKCksbC5tb3ZlVG8oLi4uYVswXSk7Zm9yKGxldCBQPTE7UDxBO1ArKylQPT09QS0xJiZiP2wuY2xvc2VQYXRoKCk6bC5saW5lVG8oLi4uYVtQXSl9aWYociYmbC5maWxsKEUuZmlsbFJ1bGUpLEkpe2wuc2F2ZSgpLGwuY2xpcCgpO2xldHtpbWFnZTpQLG9wdGlvbnM6RH09RS50ZXh0dXJlO2lmKHgmJihQPXgpLEQucmVwZWF0JiZjb25zb2xlLndhcm4oIkNvbnRleHQgMkQgbm90IHN1cHBvcnRlZCBpbWFnZSByZXBlYXQgeWV0LiIpLFAuZm9udCl7RC5zY2FsZSYmY29uc29sZS53YXJuKCJDb250ZXh0IDJEIG5vdCBzdXBwb3J0ZWQgdGV4dCBzY2FsZSB5ZXQuIiksRC5zcmNSZWN0JiZjb25zb2xlLndhcm4oIkNvbnRleHQgMkQgbm90IHN1cHBvcnRlZCB0ZXh0IHNyY1JlY3QgeWV0LiIpO2xldHtmb250OkwsZmlsbENvbG9yOlMsc3Ryb2tlQ29sb3I6VCxzdHJva2VXaWR0aDpqLHRleHQ6JH09UDshUyYmIVQmJihTPSIjMDAwIiksQXJyYXkuaXNBcnJheShTKSYmKFM9T2JqZWN0KG8uZGVmYXVsdCkoUykpLEFycmF5LmlzQXJyYXkoVCkmJihUPU9iamVjdChvLmRlZmF1bHQpKFQpKSxsLmZvbnQ9TDtjb25zdHt3aWR0aDp3fT1sLm1lYXN1cmVUZXh0KCQpLEo9T2JqZWN0KGcuZGVmYXVsdCkoTCkscT1NYXRoLm1heChKLnB4TGluZUhlaWdodCxKLnB4SGVpZ2h0KjEuMTMpO2wudGV4dEFsaWduPSJjZW50ZXIiLGwudGV4dEJhc2VsaW5lPSJtaWRkbGUiO2NvbnN0IFc9RC5yZWN0LEs9V1swXStxKi41K0oucHhIZWlnaHQqLjA2LFE9V1sxXSt3Ki41O1dbMl0hPW51bGwmJmwuc2NhbGUoV1syXS93LFdbM10vcSksUyYmKGwuZmlsbFN0eWxlPVMsbC5maWxsVGV4dCgkLFEsSykpLFQmJihsLmxpbmVXaWR0aD1qLGwuc3Ryb2tlU3R5bGU9VCxsLnN0cm9rZVRleHQoJCxRLEspKX1lbHNle2xldCBMPUQucmVjdDtjb25zdCBTPUQuc3JjUmVjdDtELnNjYWxlJiYoTD1bMCwwLGwuY2FudmFzLndpZHRoLGwuY2FudmFzLmhlaWdodF0pLEQucm90YXRlZCYmTCYmKEw9Wy1MWzFdLExbMF0sTFszXSxMWzJdXSksUyYmKEw9THx8WzAsMCxTWzJdLFNbM11dKSxELnJvdGF0ZWQmJihsLnRyYW5zbGF0ZSgwLEw/TFsyXTpQLndpZHRoKSxsLnJvdGF0ZSgtLjUqTWF0aC5QSSkpLFM/bC5kcmF3SW1hZ2UoUCwuLi5TLC4uLkwpOkw/bC5kcmF3SW1hZ2UoUCwuLi5MKTpsLmRyYXdJbWFnZShQLDAsMCl9bC5yZXN0b3JlKCl9eSYmbC5zdHJva2UoKX19KSxsLnJlc3RvcmUoKSxtKXtjb25zdCBhPUUuZmlsdGVyO2EmJmMobCxhKX19fSxmdW5jdGlvbihSLGUsdCl7dC5yKGUpLHQuZChlLCJjbGFtcCIsZnVuY3Rpb24oKXtyZXR1cm4gaX0pLHQuZChlLCJtaXgiLGZ1bmN0aW9uKCl7cmV0dXJuIG99KSx0LmQoZSwidHJhbnNmb3JtUG9pbnQiLGZ1bmN0aW9uKCl7cmV0dXJuIGd9KSx0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gaSh2LGMsZil7cmV0dXJuIGM+ZiYmKFtjLGZdPVtmLGNdKSx2PGM/Yzp2PmY/Zjp2fWZ1bmN0aW9uIG8odixjLGYpe3JldHVybiB2KigxLWYpK2MqZn1mdW5jdGlvbiBnKHYsYyl7Y29uc3RbZixoXT12O3JldHVybltmKmNbMF0raCpjWzJdK2NbNF0sZipjWzFdK2gqY1szXStjWzVdXX19LGZ1bmN0aW9uKFIsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIGZ9KTt2YXIgaT10KDI4KSxvPXQoMjkpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBnKGgsRSxsKXtjb25zdCBtPWgudW5pZm9ybXN8fHt9LHA9RS51bmlmb3Jtc3x8e307aWYobS51X3RleFNhbXBsZXImJnAudV90ZXhTYW1wbGVyJiZtLnVfdGV4U2FtcGxlciE9PXAudV90ZXhTYW1wbGVyKXJldHVybiExO2NvbnN0IEM9T2JqZWN0LmtleXMobSkseD1PYmplY3Qua2V5cyhwKSxkPUMuaW5kZXhPZigidV90ZXhTYW1wbGVyIikseT14LmluZGV4T2YoInVfdGV4U2FtcGxlciIpO2lmKGQ+PTAmJkMuc3BsaWNlKGQsMSkseT49MCYmeC5zcGxpY2UoeSwxKSxDLmxlbmd0aCE9PXgubGVuZ3RoKXJldHVybiExO2NvbnN0IHI9Qy5ldmVyeShzPT57Y29uc3Qgbj1tW3NdLGE9cFtzXTtpZihuPT09YSlyZXR1cm4hMDtpZihuLmxlbmd0aCYmYS5sZW5ndGgmJm4ubGVuZ3RoPT09YS5sZW5ndGgpe2ZvcihsZXQgTz0wO088bi5sZW5ndGg7TysrKWlmKG5bT10hPT1hW09dKXJldHVybiExO3JldHVybiEwfXJldHVybiExfSk7aWYocil7aWYobS51X3RleFNhbXBsZXImJiFwLnVfdGV4U2FtcGxlcilFLnNldFRleHR1cmUobS51X3RleFNhbXBsZXIse2hpZGRlbjohMH0pO2Vsc2UgaWYoIW0udV90ZXhTYW1wbGVyJiZwLnVfdGV4U2FtcGxlcilmb3IobGV0IHM9MDtzPGwubGVuZ3RoO3MrKylsW3NdLnNldFRleHR1cmUocC51X3RleFNhbXBsZXIse2hpZGRlbjohMH0pfXJldHVybiByfWNvbnN0IHY9e307ZnVuY3Rpb24gYyhoLEUpe2lmKGgubGVuZ3RoKXtjb25zdCBsPU9iamVjdChpLmRlZmF1bHQpKGgsdik7cmV0dXJuIGwuZW5hYmxlQmxlbmQ9RSxoWzBdLmZpbHRlckNhbnZhcyYmKGwuZmlsdGVyQ2FudmFzPSEwKSxsLnBhY2tJbmRleD1oWzBdLnBhY2tJbmRleCxsLnBhY2tMZW5ndGg9aC5sZW5ndGgsbC5iZWZvcmVSZW5kZXI9aFswXS5iZWZvcmVSZW5kZXIsbC5wYXNzPWhbMF0ucGFzcyxsLmFmdGVyUmVuZGVyPWhbaC5sZW5ndGgtMV0uYWZ0ZXJSZW5kZXIsaC5sZW5ndGg9MCxsfX1mdW5jdGlvbipmKGgsRSxsPSExKXtjb25zdCBtPVtdLHA9aC5vcHRpb25zLmJ1ZmZlclNpemU7bGV0IEM9MCx4PSExO2ZvcihsZXQgZD0wO2Q8RS5sZW5ndGg7ZCsrKXtjb25zdCB5PUVbZF07aWYoeSBpbnN0YW5jZW9mIG8uZGVmYXVsdCltLmxlbmd0aCYmKHlpZWxkIGMobSx4KSksQz0wLHg9ITEseWllbGQgeTtlbHNle2NvbnN0IHI9eS5tZXNoRGF0YTtpZihyLmNsaXBQYXRoJiYhci51bmlmb3Jtcy51X2NsaXBTYW1wbGVyKXtjb25zdCBuPWguY3JlYXRlVGV4dHVyZShyLmNsaXBQYXRoKTtyLnVuaWZvcm1zLnVfY2xpcFNhbXBsZXI9bn1sZXQgcz0wO2lmKCghbHx8IXkuY2FuSWdub3JlKCkpJiZyJiZyLnBvc2l0aW9ucy5sZW5ndGgpe3kucGFja0luZGV4PWQ7Y29uc3Qgbj15LmZpbHRlckNhbnZhcztpZihzPXIucG9zaXRpb25zLmxlbmd0aCxufHxDK3M+cCltLmxlbmd0aCYmKHlpZWxkIGMobSx4KSksQz0wLHg9ITE7ZWxzZSBpZihDKXtjb25zdCBhPW1bbS5sZW5ndGgtMV07YSYmKGEuZmlsdGVyQ2FudmFzfHxhLmFmdGVyUmVuZGVyfHx5LmJlZm9yZVJlbmRlcnx8YS5wYXNzLmxlbmd0aHx8eS5wYXNzLmxlbmd0aHx8YS5wcm9ncmFtIT09eS5wcm9ncmFtfHwhZyhhLHksbSkpJiYoeWllbGQgYyhtLHgpLEM9MCx4PSExKX1tLnB1c2goeSkseD14fHx5LmVuYWJsZUJsZW5kLEMrPXN9ZD09PUUubGVuZ3RoLTEmJm0ubGVuZ3RoJiYoeWllbGQgYyhtLHgpKX19fX0sZnVuY3Rpb24oUixlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gZ30pLHQoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCBpPXtVTlNJR05FRF9CWVRFOlVpbnQ4QXJyYXksVU5TSUdORURfU0hPUlQ6VWludDE2QXJyYXksQllURTpJbnQ4QXJyYXksU0hPUlQ6SW50MTZBcnJheSxGTE9BVDpGbG9hdDMyQXJyYXl9O2Z1bmN0aW9uIG8odixjKXtsZXQgZj0wLGg9MCxFPTAsbD0wLG09MCxwPTAsQz0wO2NvbnN0IHg9dlswXS5wcm9ncmFtO2ZvcihsZXQgZD0wO2Q8di5sZW5ndGg7ZCsrKXtjb25zdCB5PXZbZF0ubWVzaERhdGE7aWYoeSl7Qys9eS5wb3NpdGlvbnMubGVuZ3RoO2NvbnN0IHI9eS5wb3NpdGlvbnNbMF0ubGVuZ3RoO2YrPXkucG9zaXRpb25zLmxlbmd0aCpyLGgrPXkuY2VsbHMubGVuZ3RoKjMscCs9eS5hdHRyaWJ1dGVzLmFfY29sb3IubGVuZ3RoKjQ7Y29uc3Qgcz15LnRleHR1cmVDb29yZDtzJiYoRSs9cy5sZW5ndGgqc1swXS5sZW5ndGgpO2NvbnN0IG49eS5hdHRyaWJ1dGVzLmFfc291cmNlUmVjdDtuJiYobCs9bi5sZW5ndGgqNCk7Y29uc3QgYT15LmF0dHJpYnV0ZXMuYV9jbGlwVVY7YSYmKG0rPWEubGVuZ3RoKjIpfX1pZigoIWMucG9zaXRpb25zfHxjLnBvc2l0aW9ucy5sZW5ndGg8ZikmJihjLnBvc2l0aW9ucz1uZXcgRmxvYXQzMkFycmF5KGYpKSwoIWMuY2VsbHN8fGMuY2VsbHMubGVuZ3RoPGgpJiYoYy5jZWxscz1uZXcgVWludDE2QXJyYXkoaCkpLEUmJighYy50ZXh0dXJlQ29vcmR8fGMudGV4dHVyZUNvb3JkLmxlbmd0aDxFKSYmKGMudGV4dHVyZUNvb3JkPW5ldyBGbG9hdDMyQXJyYXkoRSkpLCghYy5hX2NvbG9yfHxjLmFfY29sb3IubGVuZ3RoPHApJiYoYy5hX2NvbG9yPW5ldyBVaW50OEFycmF5KHApKSxsJiYoIWMuYV9zb3VyY2VSZWN0fHxjLmFfc291cmNlUmVjdC5sZW5ndGg8bCkmJihjLmFfc291cmNlUmVjdD1uZXcgRmxvYXQzMkFycmF5KGwpKSxtJiYoIWMuYV9jbGlwVVZ8fGMuYV9jbGlwVVYubGVuZ3RoPG0pJiYoYy5hX2NsaXBVVj1uZXcgRmxvYXQzMkFycmF5KG0pKSx4KXtjb25zdCBkPU9iamVjdC5lbnRyaWVzKHguX2F0dHJpYnV0ZSkseT14Ll9hdHRyaWJPcHRzfHx7fTtmb3IobGV0IHI9MDtyPGQubGVuZ3RoO3IrKyl7Y29uc3RbcyxuXT1kW3JdO2lmKHMhPT0iYV9jb2xvciImJnMhPT0iYV9zb3VyY2VSZWN0IiYmbiE9PSJpZ25vcmVkIil7Y29uc3QgYT15W3NdP3lbc10udHlwZToiRkxPQVQiLE89aVthXSxBPW4uc2l6ZSpDOyghY1tzXXx8Y1tzXS5sZW5ndGg8QSkmJihjW3NdPW5ldyBPKEEpKX19fXJldHVybiBjfWZ1bmN0aW9uIGcodixjKXtsZXQgZj1bXSxoPVtdLEU9W10sbD1bXSxtPVtdLHA9W10sQz0wLHg9MDtjb25zdCBkPXZbMF0/dlswXS51bmlmb3Jtc3x8e306e30seT12WzBdP3ZbMF0ucHJvZ3JhbTpudWxsO2MmJihvKHYsYyksaD1jLmNlbGxzLGY9Yy5wb3NpdGlvbnMsRT1jLnRleHR1cmVDb29yZCxsPWMuYV9jb2xvcixtPWMuYV9zb3VyY2VSZWN0LHA9Yy5hX2NsaXBVVik7bGV0IHI9ITEscz0hMTtjb25zdCBuPXt9O2ZvcihsZXQgTz0wO088di5sZW5ndGg7TysrKXtsZXQgQT12W09dO2lmKEEpe2lmKEEubWVzaERhdGEmJihBPUEubWVzaERhdGEpLGMpe2NvbnN0IEk9QS5wb3NpdGlvbnM7Zm9yKGxldCBQPTA7UDxJLmxlbmd0aDtQKyspe2NvbnN0IEQ9SVtQXSxMPTMqKEMrUCk7Zm9yKGxldCBTPTA7UzxELmxlbmd0aDtTKyspZltMK1NdPURbU119fWVsc2UgZi5wdXNoKC4uLkEucG9zaXRpb25zKTtjb25zdCBiPUEuY2VsbHM7Zm9yKGxldCBJPTA7STxiLmxlbmd0aDtJKyspe2NvbnN0IFA9YltJXTtpZihjKXtjb25zdCBEPTMqKHgrSSk7aFtEXT1QWzBdK0MsaFtEKzFdPVBbMV0rQyxoW0QrMl09UFsyXStDfWVsc2UgaC5wdXNoKFtQWzBdK0MsUFsxXStDLFBbMl0rQ10pfWlmKGMpe2NvbnN0IEk9QS5hdHRyaWJ1dGVzLmFfY29sb3I7Zm9yKGxldCBQPTA7UDxJLmxlbmd0aDtQKyspe2NvbnN0IEQ9SVtQXSxMPTQqKEMrUCk7bFtMXT1EWzBdLGxbTCsxXT1EWzFdLGxbTCsyXT1EWzJdLGxbTCszXT1EWzNdfX1lbHNlIGwucHVzaCguLi5BLmF0dHJpYnV0ZXMuYV9jb2xvcik7aWYoQS5hdHRyaWJ1dGVzLmFfc291cmNlUmVjdClpZihyPSEwLGMpe2NvbnN0IEk9QS5hdHRyaWJ1dGVzLmFfc291cmNlUmVjdDtmb3IobGV0IFA9MDtQPEkubGVuZ3RoO1ArKyl7Y29uc3QgRD1JW1BdLEw9NCooQytQKTttW0xdPURbMF0sbVtMKzFdPURbMV0sbVtMKzJdPURbMl0sbVtMKzNdPURbM119fWVsc2UgbS5wdXNoKC4uLkEuYXR0cmlidXRlcy5hX3NvdXJjZVJlY3QpO2lmKEEuYXR0cmlidXRlcy5hX2NsaXBVVilpZihzPSEwLGMpe2NvbnN0IEk9QS5hdHRyaWJ1dGVzLmFfY2xpcFVWO2ZvcihsZXQgUD0wO1A8SS5sZW5ndGg7UCsrKXtjb25zdCBEPUlbUF0sTD0yKihDK1ApO3BbTF09RFswXSxwW0wrMV09RFsxXX19ZWxzZSBwLnB1c2goLi4uQS5hdHRyaWJ1dGVzLmFfY2xpcFVWKTtpZihBLnRleHR1cmVDb29yZClpZihjKXtjb25zdCBJPUEudGV4dHVyZUNvb3JkO2ZvcihsZXQgUD0wO1A8SS5sZW5ndGg7UCsrKXtjb25zdCBEPUlbUF0sTD0zKihDK1ApO2ZvcihsZXQgUz0wO1M8RC5sZW5ndGg7UysrKUVbTCtTXT1EW1NdfX1lbHNlIEUucHVzaCguLi5BLnRleHR1cmVDb29yZCk7aWYoeSl7Y29uc3QgST1PYmplY3QuZW50cmllcyh5Ll9hdHRyaWJ1dGUpO2ZvcihsZXQgUD0wO1A8SS5sZW5ndGg7UCsrKXtjb25zdFtELExdPUlbUF07aWYoRCE9PSJhX2NvbG9yIiYmRCE9PSJhX3NvdXJjZVJlY3QiJiZMIT09Imlnbm9yZWQiKWlmKG5bRF09W10sYyl7bltEXT1jW0RdO2NvbnN0IFM9QS5hdHRyaWJ1dGVzW0RdLFQ9U1swXS5sZW5ndGg7Zm9yKGxldCBqPTA7ajxTLmxlbmd0aDtqKyspe2NvbnN0ICQ9U1tqXSx3PVQqKEMraik7Zm9yKGxldCBKPTA7SjwkLmxlbmd0aDtKKyspbltEXVt3K0pdPSRbSl19fWVsc2UgbltEXS5wdXNoKC4uLkEuYXR0cmlidXRlc1tEXSl9fUMrPUEucG9zaXRpb25zLmxlbmd0aCx4Kz1BLmNlbGxzLmxlbmd0aH19bi5hX2NvbG9yPWwsciYmbSYmbS5sZW5ndGg+MCYmKG4uYV9zb3VyY2VSZWN0PW0pO2NvbnN0IGE9e3Bvc2l0aW9uczpmLGNlbGxzOmgsYXR0cmlidXRlczpuLHVuaWZvcm1zOmQsY2VsbHNDb3VudDp4KjMscHJvZ3JhbTp5fTtyZXR1cm4gRSYmRS5sZW5ndGgmJihhLnRleHR1cmVDb29yZD1FKSxzJiZwLmxlbmd0aD4wJiYobi5hX2NsaXBVVj1wKSxhfX0sZnVuY3Rpb24oUixlLHQpe3QucihlKTt2YXIgaT10KDEpLG89dCgzMCksZz10KDI2KSx2PXQoMzEpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBjKG4sYSl7dmFyIE89T2JqZWN0LmtleXMobik7aWYoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyl7dmFyIEE9T2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhuKTthJiYoQT1BLmZpbHRlcihmdW5jdGlvbihiKXtyZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihuLGIpLmVudW1lcmFibGV9KSksTy5wdXNoLmFwcGx5KE8sQSl9cmV0dXJuIE99ZnVuY3Rpb24gZihuKXtmb3IodmFyIGE9MTthPGFyZ3VtZW50cy5sZW5ndGg7YSsrKXt2YXIgTz1hcmd1bWVudHNbYV0hPW51bGw/YXJndW1lbnRzW2FdOnt9O2ElMj9jKE9iamVjdChPKSwhMCkuZm9yRWFjaChmdW5jdGlvbihBKXtoKG4sQSxPW0FdKX0pOk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzP09iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKG4sT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoTykpOmMoT2JqZWN0KE8pKS5mb3JFYWNoKGZ1bmN0aW9uKEEpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShuLEEsT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLEEpKX0pfXJldHVybiBufWZ1bmN0aW9uIGgobixhLE8pe3JldHVybiBhIGluIG4/T2JqZWN0LmRlZmluZVByb3BlcnR5KG4sYSx7dmFsdWU6TyxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOm5bYV09TyxufWNvbnN0IEU9U3ltYm9sKCJtZXNoIiksbD1TeW1ib2woImNvdW50IiksbT1TeW1ib2woImJsZW5kIikscD1TeW1ib2woImZpbHRlciIpLEM9U3ltYm9sKCJ0ZXh0dXJlcyIpLHg9U3ltYm9sKCJ0ZXh0dXJlT3B0aW9ucyIpLGQ9U3ltYm9sKCJjbG91ZENvbG9yIikseT1TeW1ib2woImNsb3VkRmlsdGVyIikscj1TeW1ib2woImJ1ZmZlciIpO2Z1bmN0aW9uIHMobixhPW51bGwpe2NvbnN0IE89bmV3IEZsb2F0MzJBcnJheSgzKm4pLEE9bmV3IEZsb2F0MzJBcnJheSgzKm4pLGI9bmV3IEZsb2F0MzJBcnJheSg0Km4pLEk9bmV3IEZsb2F0MzJBcnJheSg0Km4pLFA9bmV3IEZsb2F0MzJBcnJheSg0Km4pLEQ9bmV3IEZsb2F0MzJBcnJheSg0Km4pLEw9bmV3IEZsb2F0MzJBcnJheSg0Km4pLFM9bmV3IFVpbnQ4QXJyYXkobiksVD1uZXcgVWludDhBcnJheSg0Km4pLGo9bmV3IFVpbnQ4QXJyYXkoNCpuKTtyZXR1cm4gYSYmKE8uc2V0KGEudHJhbnNmb3JtMCwwKSxBLnNldChhLnRyYW5zZm9ybTEsMCksYi5zZXQoYS5jb2xvcjAsMCksSS5zZXQoYS5jb2xvcjEsMCksUC5zZXQoYS5jb2xvcjIsMCksRC5zZXQoYS5jb2xvcjMsMCksTC5zZXQoYS5jb2xvcjQsMCksUy5zZXQoYS5mcmFtZUluZGV4LDApLFQuc2V0KGEuZmlsbENvbG9yLDApLGouc2V0KGEuc3Ryb2tlQ29sb3IsMCkpLHtidWZmZXJTaXplOm4sdHJhbnNmb3JtMDpPLHRyYW5zZm9ybTE6QSxjb2xvcjA6Yixjb2xvcjE6SSxjb2xvcjI6UCxjb2xvcjM6RCxjb2xvcjQ6TCxmcmFtZUluZGV4OlMsZmlsbENvbG9yOlQsc3Ryb2tlQ29sb3I6an19ZS5kZWZhdWx0PWNsYXNze2NvbnN0cnVjdG9yKG4sYT0xLHtidWZmZXI6Tz0xZTN9PXt9KXtPPU1hdGgubWF4KE8sYSksdGhpc1tsXT1hLHRoaXNbRV09bix0aGlzW3JdPXMoTyksdGhpc1tDXT1bXSx0aGlzW3BdPVtdLHRoaXNbZF09ITEsdGhpc1t5XT0hMSx0aGlzW21dPSExLHRoaXMuaW5pdEJ1ZmZlcigpfWluaXRCdWZmZXIobj0wKXtjb25zdCBhPXRoaXNbbF07Zm9yKGxldCBPPW47TzxhO08rKyl0aGlzW3JdLnRyYW5zZm9ybTAuc2V0KFsxLDAsMF0sTyozKSx0aGlzW3JdLnRyYW5zZm9ybTEuc2V0KFswLDEsMF0sTyozKSx0aGlzW3JdLmZyYW1lSW5kZXguc2V0KFstMV0sTyksdGhpc1tyXS5maWxsQ29sb3Iuc2V0KFswLDAsMCwwXSxPKjQpLHRoaXNbcl0uc3Ryb2tlQ29sb3Iuc2V0KFswLDAsMCwwXSxPKjQpLHRoaXMuc2V0Q29sb3JUcmFuc2Zvcm0oTyxudWxsKX1nZXQgYnVmZmVyU2l6ZSgpe3JldHVybiB0aGlzW3JdLmJ1ZmZlclNpemV9Z2V0IG1lc2goKXtyZXR1cm4gdGhpc1tFXX1zZXQgbWVzaChuKXt0aGlzW0VdPW4sdGhpc1tDXSYmdGhpcy5zZXRUZXh0dXJlRnJhbWVzKHRoaXNbQ10sdGhpc1t4XSl9Z2V0IGhhc0Nsb3VkQ29sb3IoKXtyZXR1cm4gdGhpc1tkXX1nZXQgaGFzQ2xvdWRGaWx0ZXIoKXtyZXR1cm4gdGhpc1t5XX1fZ2V0RmlsdGVyKG4pe3JldHVybiB0aGlzW3BdW25dPXRoaXNbcF1bbl18fFtdLHRoaXNbcF1bbl19Z2V0RmlsdGVyKG4pe3JldHVybiB0aGlzLl9nZXRGaWx0ZXIobikuam9pbigiICIpfWdldCBlbmFibGVCbGVuZCgpe3JldHVybiB0aGlzW0VdLmVuYWJsZUJsZW5kfHx0aGlzW21dfWNhbklnbm9yZSgpe3JldHVybiB0aGlzW0VdLmNhbklnbm9yZSgpfWRlbGV0ZShuKXtpZihuPj10aGlzW2xdfHxuPDApdGhyb3cgbmV3IEVycm9yKCJPdXQgb2YgcmFuZ2UuIik7Y29uc3R7dHJhbnNmb3JtMDphLHRyYW5zZm9ybTE6Tyxjb2xvcjA6QSxjb2xvcjE6Yixjb2xvcjI6SSxjb2xvcjM6UCxjb2xvcjQ6RCxmcmFtZUluZGV4OkwsZmlsbENvbG9yOlMsc3Ryb2tlQ29sb3I6VH09dGhpc1tyXTthLnNldChhLnN1YmFycmF5KDMqKG4rMSkpLDMqbiksTy5zZXQoTy5zdWJhcnJheSgzKihuKzEpKSwzKm4pLEEuc2V0KEEuc3ViYXJyYXkoNCoobisxKSksNCpuKSxiLnNldChiLnN1YmFycmF5KDQqKG4rMSkpLDQqbiksSS5zZXQoSS5zdWJhcnJheSg0KihuKzEpKSw0Km4pLFAuc2V0KFAuc3ViYXJyYXkoNCoobisxKSksNCpuKSxELnNldChELnN1YmFycmF5KDQqKG4rMSkpLDQqbiksTC5zZXQoTC5zdWJhcnJheShuKzEpLG4pLFMuc2V0KFMuc3ViYXJyYXkoNCoobisxKSksNCpuKSxULnNldChULnN1YmFycmF5KDQqKG4rMSkpLDQqbik7Zm9yKGNvbnN0IGogaW4gdGhpc1twXSlqPT09bj9kZWxldGUgdGhpc1twXVtqXTpqPm4mJih0aGlzW3BdW2otMV09dGhpc1twXVtqXSxkZWxldGUgdGhpc1twXVtqXSk7dGhpc1tsXS0tfXNldENvbG9yVHJhbnNmb3JtKG4sYSl7aWYobj49dGhpc1tsXXx8bjwwKXRocm93IG5ldyBFcnJvcigiT3V0IG9mIHJhbmdlLiIpO24qPTQ7Y29uc3R7Y29sb3IwOk8sY29sb3IxOkEsY29sb3IyOmIsY29sb3IzOkksY29sb3I0OlB9PXRoaXNbcl07cmV0dXJuIGEhPW51bGw/KE8uc2V0KFthWzBdLGFbNV0sYVsxMF0sYVsxNV1dLG4pLEEuc2V0KFthWzFdLGFbNl0sYVsxMV0sYVsxNl1dLG4pLGIuc2V0KFthWzJdLGFbN10sYVsxMl0sYVsxN11dLG4pLEkuc2V0KFthWzNdLGFbOF0sYVsxM10sYVsxOF1dLG4pLFAuc2V0KFthWzRdLGFbOV0sYVsxNF0sYVsxOV1dLG4pLHRoaXNbbV09dGhpc1ttXXx8YVsxOF08MSx0aGlzW3ldPSEwKTooTy5zZXQoWzEsMCwwLDBdLG4pLEEuc2V0KFswLDEsMCwwXSxuKSxiLnNldChbMCwwLDEsMF0sbiksSS5zZXQoWzAsMCwwLDFdLG4pLFAuc2V0KFswLDAsMCwwXSxuKSksdGhpc31nZXRDb2xvclRyYW5zZm9ybShuKXtpZihuPj10aGlzW2xdfHxuPDApdGhyb3cgbmV3IEVycm9yKCJPdXQgb2YgcmFuZ2UuIik7bio9NDtjb25zdHtjb2xvcjA6YSxjb2xvcjE6Tyxjb2xvcjI6QSxjb2xvcjM6Yixjb2xvcjQ6SX09dGhpc1tyXTtyZXR1cm5bYVtuXSxPW25dLEFbbl0sYltuXSxJW25dLGFbbisxXSxPW24rMV0sQVtuKzFdLGJbbisxXSxJW24rMV0sYVtuKzJdLE9bbisyXSxBW24rMl0sYltuKzJdLElbbisyXSxhW24rM10sT1tuKzNdLEFbbiszXSxiW24rM10sSVtuKzNdXX10cmFuc2Zvcm1Db2xvcihuLGEpe2xldCBPPXRoaXMuZ2V0Q29sb3JUcmFuc2Zvcm0obik7cmV0dXJuIE89T2JqZWN0KG8ubXVsdGlwbHkpKE8sYSksdGhpcy5zZXRDb2xvclRyYW5zZm9ybShuLE8pLHRoaXN9c2V0RmlsbENvbG9yKG4sYSl7aWYobj49dGhpc1tsXXx8bjwwKXRocm93IG5ldyBFcnJvcigiT3V0IG9mIHJhbmdlLiIpO3R5cGVvZiBhPT0ic3RyaW5nIiYmKGE9T2JqZWN0KHYuZGVmYXVsdCkoYSkpLGFbM10+MCYmKHRoaXNbZF09ITApLHRoaXNbcl0uZmlsbENvbG9yLnNldChhLm1hcChPPT5NYXRoLnJvdW5kKDI1NSpPKSksNCpuKX1zZXRTdHJva2VDb2xvcihuLGEpe2lmKG4+PXRoaXNbbF18fG48MCl0aHJvdyBuZXcgRXJyb3IoIk91dCBvZiByYW5nZS4iKTt0eXBlb2YgYT09InN0cmluZyImJihhPU9iamVjdCh2LmRlZmF1bHQpKGEpKSxhWzNdPjAmJih0aGlzW2RdPSEwKSx0aGlzW3JdLnN0cm9rZUNvbG9yLnNldChhLm1hcChPPT5NYXRoLnJvdW5kKDI1NSpPKSksNCpuKX1nZXRDbG91ZFJHQkEobil7aWYobj49dGhpc1tsXXx8bjwwKXRocm93IG5ldyBFcnJvcigiT3V0IG9mIHJhbmdlLiIpO24qPTQ7Y29uc3R7ZmlsbENvbG9yOmEsc3Ryb2tlQ29sb3I6T309dGhpc1tyXSxBPVthW25dLGFbbisxXSxhW24rMl0sYVtuKzNdXSxiPVtPW25dLE9bbisxXSxPW24rMl0sT1tuKzNdXTtyZXR1cm4gQVszXS89MjU1LGJbM10vPTI1NSx7ZmlsbDpgcmdiYSgke0Euam9pbigpfSlgLHN0cm9rZTpgcmdiYSgke2Iuam9pbigpfSlgfX1ncmF5c2NhbGUobixhKXt0aGlzLnRyYW5zZm9ybUNvbG9yKG4sT2JqZWN0KG8uZ3JheXNjYWxlKShhKSksdGhpcy5fZ2V0RmlsdGVyKG4pLnB1c2goYGdyYXlzY2FsZSgkezEwMCphfSUpYCl9YnJpZ2h0bmVzcyhuLGEpe3RoaXMudHJhbnNmb3JtQ29sb3IobixPYmplY3Qoby5icmlnaHRuZXNzKShhKSksdGhpcy5fZ2V0RmlsdGVyKG4pLnB1c2goYGJyaWdodG5lc3MoJHsxMDAqYX0lKWApfXNhdHVyYXRlKG4sYSl7dGhpcy50cmFuc2Zvcm1Db2xvcihuLE9iamVjdChvLnNhdHVyYXRlKShhKSksdGhpcy5fZ2V0RmlsdGVyKG4pLnB1c2goYHNhdHVyYXRlKCR7MTAwKmF9JSlgKX1jb250cmFzdChuLGEpe3RoaXMudHJhbnNmb3JtQ29sb3IobixPYmplY3Qoby5jb250cmFzdCkoYSkpLHRoaXMuX2dldEZpbHRlcihuKS5wdXNoKGBjb250cmFzdCgkezEwMCphfSUpYCl9aW52ZXJ0KG4sYSl7dGhpcy50cmFuc2Zvcm1Db2xvcihuLE9iamVjdChvLmludmVydCkoYSkpLHRoaXMuX2dldEZpbHRlcihuKS5wdXNoKGBpbnZlcnQoJHsxMDAqYX0lKWApfXNlcGlhKG4sYSl7dGhpcy50cmFuc2Zvcm1Db2xvcihuLE9iamVjdChvLnNlcGlhKShhKSksdGhpcy5fZ2V0RmlsdGVyKG4pLnB1c2goYHNlcGlhKCR7MTAwKmF9JSlgKX1vcGFjaXR5KG4sYSl7dGhpcy50cmFuc2Zvcm1Db2xvcihuLE9iamVjdChvLm9wYWNpdHkpKGEpKSx0aGlzLl9nZXRGaWx0ZXIobikucHVzaChgb3BhY2l0eSgkezEwMCphfSUpYCl9aHVlUm90YXRlKG4sYSl7dGhpcy50cmFuc2Zvcm1Db2xvcihuLE9iamVjdChvLmh1ZVJvdGF0ZSkoYSkpLHRoaXMuX2dldEZpbHRlcihuKS5wdXNoKGBodWUtcm90YXRlKCR7YX1kZWcpYCl9c2V0VHJhbnNmb3JtKG4sYSl7aWYobj49dGhpc1tsXXx8bjwwKXRocm93IG5ldyBFcnJvcigiT3V0IG9mIHJhbmdlLiIpO24qPTMsYT09bnVsbCYmKGE9WzEsMCwwLDEsMCwwXSk7Y29uc3R7dHJhbnNmb3JtMDpPLHRyYW5zZm9ybTE6QX09dGhpc1tyXTtyZXR1cm4gTy5zZXQoW2FbMF0sYVsyXSxhWzRdXSxuKSxBLnNldChbYVsxXSxhWzNdLGFbNV1dLG4pLHRoaXN9Z2V0VHJhbnNmb3JtKG4pe2lmKG4+PXRoaXNbbF18fG48MCl0aHJvdyBuZXcgRXJyb3IoIk91dCBvZiByYW5nZS4iKTtuKj0zO2NvbnN0e3RyYW5zZm9ybTA6YSx0cmFuc2Zvcm0xOk99PXRoaXNbcl07cmV0dXJuW2Fbbl0sT1tuXSxhW24rMV0sT1tuKzFdLGFbbisyXSxPW24rMl1dfWdldFRleHR1cmVGcmFtZShuKXtyZXR1cm4gdGhpc1tDXVt0aGlzW3JdLmZyYW1lSW5kZXhbbl1dfXNldFRleHR1cmVGcmFtZXMobj1bXSxhPXt9KXtpZihuLmxlbmd0aD4xMil0aHJvdyBuZXcgRXJyb3IoIk1heCBmcmFtZXMgZXhjZWVkLiBBbGxvdyAxMiBmcmFtZXMuIik7bi5sZW5ndGgmJnRoaXNbRV0uc2V0VGV4dHVyZShuWzBdLGEpLHRoaXNbQ109bix0aGlzW3hdPWF9c2V0RnJhbWVJbmRleChuLGEpe2lmKG4+PXRoaXNbbF18fG48MCl0aHJvdyBuZXcgRXJyb3IoIk91dCBvZiByYW5nZS4iKTtjb25zdCBPPXRoaXNbQ10ubGVuZ3RoO2lmKE88PTApdGhyb3cgbmV3IEVycm9yKCJObyBmcmFtZXMiKTt0aGlzW3JdLmZyYW1lSW5kZXhbbl09YSVPfWdldCBhbW91bnQoKXtyZXR1cm4gdGhpc1tsXX1zZXQgYW1vdW50KG4pe2NvbnN0IGE9dGhpc1tsXTtuIT09YSYmKG4+dGhpc1tyXS5idWZmZXJTaXplJiYodGhpc1tyXT1zKE1hdGgubWF4KG4sdGhpc1tyXS5idWZmZXJTaXplKzFlMyksdGhpc1tyXSkpLHRoaXNbbF09bixuPmEmJnRoaXMuaW5pdEJ1ZmZlcihhKSl9Z2V0IG1lc2hEYXRhKCl7Y29uc3R7YXR0cmlidXRlczpuLGNlbGxzOmEscG9zaXRpb25zOk8sdGV4dHVyZUNvb3JkOkEsdW5pZm9ybXM6Yn09dGhpc1tFXS5tZXNoRGF0YSxJPXRoaXNbQ10sUD17YXR0cmlidXRlczpmKHt9LG4pLGNlbGxzOmEscG9zaXRpb25zOk8sdGV4dHVyZUNvb3JkOkEsdW5pZm9ybXM6Zih7fSxiKSxpbnN0YW5jZUNvdW50OnRoaXNbbF0sZW5hYmxlQmxlbmQ6dGhpcy5lbmFibGVCbGVuZH07SS5sZW5ndGgmJkkuZm9yRWFjaCgoSyxRKT0+e1AudW5pZm9ybXNbYHVfdGV4RnJhbWUke1F9YF09S30pO2NvbnN0e3RyYW5zZm9ybTA6RCx0cmFuc2Zvcm0xOkwsY29sb3IwOlMsY29sb3IxOlQsY29sb3IyOmosY29sb3IzOiQsY29sb3I0OncsZmlsbENvbG9yOkosc3Ryb2tlQ29sb3I6cSxmcmFtZUluZGV4Old9PXRoaXNbcl07cmV0dXJuIHRoaXNbRV0udW5pZm9ybXMudV90ZXhTYW1wbGVyJiYoUC5hdHRyaWJ1dGVzLmFfZnJhbWVJbmRleD17ZGF0YTpXLGRpdmlzb3I6MX0pLFAuYXR0cmlidXRlcy5hX3RyYW5zZm9ybTA9e2RhdGE6RCxkaXZpc29yOjF9LFAuYXR0cmlidXRlcy5hX3RyYW5zZm9ybTE9e2RhdGE6TCxkaXZpc29yOjF9LFAuYXR0cmlidXRlcy5hX2NvbG9yQ2xvdWQwPXtkYXRhOlMsZGl2aXNvcjoxfSxQLmF0dHJpYnV0ZXMuYV9jb2xvckNsb3VkMT17ZGF0YTpULGRpdmlzb3I6MX0sUC5hdHRyaWJ1dGVzLmFfY29sb3JDbG91ZDI9e2RhdGE6aixkaXZpc29yOjF9LFAuYXR0cmlidXRlcy5hX2NvbG9yQ2xvdWQzPXtkYXRhOiQsZGl2aXNvcjoxfSxQLmF0dHJpYnV0ZXMuYV9jb2xvckNsb3VkND17ZGF0YTp3LGRpdmlzb3I6MX0sdGhpcy5oYXNDbG91ZENvbG9yJiYoUC5hdHRyaWJ1dGVzLmFfZmlsbENsb3VkQ29sb3I9e2RhdGE6SixkaXZpc29yOjF9LFAuYXR0cmlidXRlcy5hX3N0cm9rZUNsb3VkQ29sb3I9e2RhdGE6cSxkaXZpc29yOjF9KSxQfXNldFByb2dyYW0obil7dGhpc1tFXS5zZXRQcm9ncmFtKG4pfWdldCBwcm9ncmFtKCl7cmV0dXJuIHRoaXNbRV0ucHJvZ3JhbX10cmFuc2Zvcm0obixhKXtjb25zdCBPPXRoaXMuZ2V0VHJhbnNmb3JtKG4pO3JldHVybiBhPWkubWF0MmQubXVsdGlwbHkoQXJyYXkub2YoMCwwLDAsMCwwLDApLE8sYSksdGhpcy5zZXRUcmFuc2Zvcm0obixhKSx0aGlzfXRyYW5zbGF0ZShuLFthLE9dKXtsZXQgQT1pLm1hdDJkLmNyZWF0ZSgpO3JldHVybiBBPWkubWF0MmQudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxBLFthLE9dKSx0aGlzLnRyYW5zZm9ybShuLEEpfXJvdGF0ZShuLGEsW08sQV09WzAsMF0pe2xldCBiPWkubWF0MmQuY3JlYXRlKCk7cmV0dXJuIGI9aS5tYXQyZC50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDApLGIsW08sQV0pLGI9aS5tYXQyZC5yb3RhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDApLGIsYSksYj1pLm1hdDJkLnRyYW5zbGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCksYixbLU8sLUFdKSx0aGlzLnRyYW5zZm9ybShuLGIpfXNjYWxlKG4sW2EsTz1hXSxbQSxiXT1bMCwwXSl7bGV0IEk9aS5tYXQyZC5jcmVhdGUoKTtyZXR1cm4gST1pLm1hdDJkLnRyYW5zbGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCksSSxbQSxiXSksST1pLm1hdDJkLnNjYWxlKEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxJLFthLE9dKSxJPWkubWF0MmQudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxJLFstQSwtYl0pLHRoaXMudHJhbnNmb3JtKG4sSSl9c2tldyhuLFthLE89YV0sW0EsYl09WzAsMF0pe2xldCBJPWkubWF0MmQuY3JlYXRlKCk7cmV0dXJuIEk9aS5tYXQyZC50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDApLEksW0EsYl0pLEk9aS5tYXQyZC5tdWx0aXBseShBcnJheS5vZigwLDAsMCwwLDAsMCksSSxpLm1hdDJkLmZyb21WYWx1ZXMoMSxNYXRoLnRhbihPKSxNYXRoLnRhbihhKSwxLDAsMCkpLEk9aS5tYXQyZC50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDApLEksWy1BLC1iXSksdGhpcy50cmFuc2Zvcm0obixJKX1pc1BvaW50Q29sbGlzaW9uKG4sW2EsT10sQT0iYm90aCIpe2NvbnN0IGI9dGhpcy5nZXRUcmFuc2Zvcm0obiksST1PYmplY3QoZy50cmFuc2Zvcm1Qb2ludCkoW2EsT10saS5tYXQyZC5pbnZlcnQoQXJyYXkub2YoMCwwLDAsMCwwLDApLGIpKTtyZXR1cm4gdGhpc1tFXS5pc1BvaW50Q29sbGlzaW9uKC4uLkksQSl9aXNQb2ludEluRmlsbChuLFthLE9dKXtyZXR1cm4gdGhpcy5pc1BvaW50Q29sbGlzaW9uKG4sW2EsT10sImZpbGwiKX1pc1BvaW50SW5TdHJva2UobixbYSxPXSl7cmV0dXJuIHRoaXMuaXNQb2ludENvbGxpc2lvbihuLFthLE9dLCJzdHJva2UiKX19fSxmdW5jdGlvbihSLGUsdCl7dC5yKGUpLHQuZChlLCJtdWx0aXBseSIsZnVuY3Rpb24oKXtyZXR1cm4gb30pLHQuZChlLCJncmF5c2NhbGUiLGZ1bmN0aW9uKCl7cmV0dXJuIGd9KSx0LmQoZSwiYnJpZ2h0bmVzcyIsZnVuY3Rpb24oKXtyZXR1cm4gdn0pLHQuZChlLCJzYXR1cmF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gY30pLHQuZChlLCJjb250cmFzdCIsZnVuY3Rpb24oKXtyZXR1cm4gZn0pLHQuZChlLCJpbnZlcnQiLGZ1bmN0aW9uKCl7cmV0dXJuIGh9KSx0LmQoZSwic2VwaWEiLGZ1bmN0aW9uKCl7cmV0dXJuIEV9KSx0LmQoZSwib3BhY2l0eSIsZnVuY3Rpb24oKXtyZXR1cm4gbH0pLHQuZChlLCJodWVSb3RhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIG19KTt2YXIgaT10KDI2KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gbyhwLEMpe2NvbnN0IHg9W10sZD1wWzBdLHk9cFsxXSxyPXBbMl0scz1wWzNdLG49cFs0XSxhPXBbNV0sTz1wWzZdLEE9cFs3XSxiPXBbOF0sST1wWzldLFA9cFsxMF0sRD1wWzExXSxMPXBbMTJdLFM9cFsxM10sVD1wWzE0XSxqPXBbMTVdLCQ9cFsxNl0sdz1wWzE3XSxKPXBbMThdLHE9cFsxOV07bGV0IFc9Q1swXSxLPUNbMV0sUT1DWzJdLHR0PUNbM10sXz1DWzRdO3JldHVybiB4WzBdPVcqZCtLKmErUSpQK3R0KmoseFsxXT1XKnkrSypPK1EqRCt0dCokLHhbMl09VypyK0sqQStRKkwrdHQqdyx4WzNdPVcqcytLKmIrUSpTK3R0KkoseFs0XT1XKm4rSypJK1EqVCt0dCpxK18sVz1DWzVdLEs9Q1s2XSxRPUNbN10sdHQ9Q1s4XSxfPUNbOV0seFs1XT1XKmQrSyphK1EqUCt0dCpqLHhbNl09Vyp5K0sqTytRKkQrdHQqJCx4WzddPVcqcitLKkErUSpMK3R0KncseFs4XT1XKnMrSypiK1EqUyt0dCpKLHhbOV09VypuK0sqSStRKlQrdHQqcStfLFc9Q1sxMF0sSz1DWzExXSxRPUNbMTJdLHR0PUNbMTNdLF89Q1sxNF0seFsxMF09VypkK0sqYStRKlArdHQqaix4WzExXT1XKnkrSypPK1EqRCt0dCokLHhbMTJdPVcqcitLKkErUSpMK3R0KncseFsxM109VypzK0sqYitRKlMrdHQqSix4WzE0XT1XKm4rSypJK1EqVCt0dCpxK18sVz1DWzE1XSxLPUNbMTZdLFE9Q1sxN10sdHQ9Q1sxOF0sXz1DWzE5XSx4WzE1XT1XKmQrSyphK1EqUCt0dCpqLHhbMTZdPVcqeStLKk8rUSpEK3R0KiQseFsxN109VypyK0sqQStRKkwrdHQqdyx4WzE4XT1XKnMrSypiK1EqUyt0dCpKLHhbMTldPVcqbitLKkkrUSpUK3R0KnErXyx4fWZ1bmN0aW9uIGcocCl7cD1PYmplY3QoaS5jbGFtcCkoMCwxLHApO2NvbnN0IEM9LjIxMjYqcCx4PS43MTUyKnAsZD0uMDcyMipwO3JldHVybltDKzEtcCx4LGQsMCwwLEMseCsxLXAsZCwwLDAsQyx4LGQrMS1wLDAsMCwwLDAsMCwxLDBdfWZ1bmN0aW9uIHYocCl7cmV0dXJuW3AsMCwwLDAsMCwwLHAsMCwwLDAsMCwwLHAsMCwwLDAsMCwwLDEsMF19ZnVuY3Rpb24gYyhwKXtjb25zdCBDPS4yMTI2KigxLXApLHg9LjcxNTIqKDEtcCksZD0uMDcyMiooMS1wKTtyZXR1cm5bQytwLHgsZCwwLDAsQyx4K3AsZCwwLDAsQyx4LGQrcCwwLDAsMCwwLDAsMSwwXX1mdW5jdGlvbiBmKHApe2NvbnN0IEM9LjUqKDEtcCk7cmV0dXJuW3AsMCwwLDAsQywwLHAsMCwwLEMsMCwwLHAsMCxDLDAsMCwwLDEsMF19ZnVuY3Rpb24gaChwKXtjb25zdCBDPTEtMipwO3JldHVybltDLDAsMCwwLHAsMCxDLDAsMCxwLDAsMCxDLDAscCwwLDAsMCwxLDBdfWZ1bmN0aW9uIEUocCl7cmV0dXJuWzEtLjYwNypwLC43NjkqcCwuMTg5KnAsMCwwLC4zNDkqcCwxLS4zMTQqcCwuMTY4KnAsMCwwLC4yNzIqcCwuNTM0KnAsMS0uODY5KnAsMCwwLDAsMCwwLDEsMF19ZnVuY3Rpb24gbChwKXtyZXR1cm5bMSwwLDAsMCwwLDAsMSwwLDAsMCwwLDAsMSwwLDAsMCwwLDAscCwwXX1mdW5jdGlvbiBtKHApe2NvbnN0IEM9cC8xODAqTWF0aC5QSSx4PU1hdGguY29zKEMpLGQ9TWF0aC5zaW4oQykseT0uMjEyNixyPS43MTUyLHM9LjA3MjI7cmV0dXJuW3kreCooMS15KStkKi15LHIreCotcitkKi1yLHMreCotcytkKigxLXMpLDAsMCx5K3gqLXkrZCouMTQzLHIreCooMS1yKStkKi4xNCxzK3gqLXMrZCotLjI4MywwLDAseSt4Ki15K2QqLSgxLXkpLHIreCotcitkKnIscyt4KigxLXMpK2QqcywwLDAsMCwwLDAsMSwwXX19LGZ1bmN0aW9uKFIsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIGd9KTt2YXIgaT10KDMyKSxvPXQubihpKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gZyh2KXtjb25zdCBjPW8oKSh2KTtpZighY3x8IWMubGVuZ3RoKXRocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgY29sb3IgdmFsdWUuIik7cmV0dXJuW2NbMF0vMjU1LGNbMV0vMjU1LGNbMl0vMjU1LGNbM11dfX0sZnVuY3Rpb24oUixlLHQpe3ZhciBpPXQoMzMpLG89dCgzNyksZz10KDM5KTtSLmV4cG9ydHM9ZnVuY3Rpb24oYyl7dmFyIGYsaD1pKGMpO3JldHVybiBoLnNwYWNlPyhmPUFycmF5KDMpLGZbMF09ZyhoLnZhbHVlc1swXSwwLDI1NSksZlsxXT1nKGgudmFsdWVzWzFdLDAsMjU1KSxmWzJdPWcoaC52YWx1ZXNbMl0sMCwyNTUpLGguc3BhY2VbMF09PT0iaCImJihmPW8ucmdiKGYpKSxmLnB1c2goZyhoLmFscGhhLDAsMSkpLGYpOltdfX0sZnVuY3Rpb24oUixlLHQpeyhmdW5jdGlvbihpKXt2YXIgbz10KDM0KSxnPXQoMzUpLHY9dCgzNik7Ui5leHBvcnRzPWY7dmFyIGM9e3JlZDowLG9yYW5nZTo2MCx5ZWxsb3c6MTIwLGdyZWVuOjE4MCxibHVlOjI0MCxwdXJwbGU6MzAwfTtmdW5jdGlvbiBmKGgpe3ZhciBFLGw9W10sbT0xLHA7aWYodHlwZW9mIGg9PSJzdHJpbmciKWlmKG9baF0pbD1vW2hdLnNsaWNlKCkscD0icmdiIjtlbHNlIGlmKGg9PT0idHJhbnNwYXJlbnQiKW09MCxwPSJyZ2IiLGw9WzAsMCwwXTtlbHNlIGlmKC9eI1tBLUZhLWYwLTldKyQvLnRlc3QoaCkpe3ZhciBDPWguc2xpY2UoMSkseD1DLmxlbmd0aCxkPXg8PTQ7bT0xLGQ/KGw9W3BhcnNlSW50KENbMF0rQ1swXSwxNikscGFyc2VJbnQoQ1sxXStDWzFdLDE2KSxwYXJzZUludChDWzJdK0NbMl0sMTYpXSx4PT09NCYmKG09cGFyc2VJbnQoQ1szXStDWzNdLDE2KS8yNTUpKToobD1bcGFyc2VJbnQoQ1swXStDWzFdLDE2KSxwYXJzZUludChDWzJdK0NbM10sMTYpLHBhcnNlSW50KENbNF0rQ1s1XSwxNildLHg9PT04JiYobT1wYXJzZUludChDWzZdK0NbN10sMTYpLzI1NSkpLGxbMF18fChsWzBdPTApLGxbMV18fChsWzFdPTApLGxbMl18fChsWzJdPTApLHA9InJnYiJ9ZWxzZSBpZihFPS9eKCg/OnJnYnxoc1tsdmJdfGh3YnxjbXlrP3x4eVt6eV18Z3JheXxsYWJ8bGNodT92P3xbbHlddXZ8bG1zKWE/KVxzKlwoKFteXCldKilcKS8uZXhlYyhoKSl7dmFyIHk9RVsxXSxyPXk9PT0icmdiIixDPXkucmVwbGFjZSgvYSQvLCIiKTtwPUM7dmFyIHg9Qz09PSJjbXlrIj80OkM9PT0iZ3JheSI/MTozO2w9RVsyXS50cmltKCkuc3BsaXQoL1xzKixccyovKS5tYXAoZnVuY3Rpb24oTyxBKXtpZigvJSQvLnRlc3QoTykpcmV0dXJuIEE9PT14P3BhcnNlRmxvYXQoTykvMTAwOkM9PT0icmdiIj9wYXJzZUZsb2F0KE8pKjI1NS8xMDA6cGFyc2VGbG9hdChPKTtpZihDW0FdPT09ImgiKXtpZigvZGVnJC8udGVzdChPKSlyZXR1cm4gcGFyc2VGbG9hdChPKTtpZihjW09dIT09dm9pZCAwKXJldHVybiBjW09dfXJldHVybiBwYXJzZUZsb2F0KE8pfSkseT09PUMmJmwucHVzaCgxKSxtPXJ8fGxbeF09PT12b2lkIDA/MTpsW3hdLGw9bC5zbGljZSgwLHgpfWVsc2UgaC5sZW5ndGg+MTAmJi9bMC05XSg/OlxzfFwvKS8udGVzdChoKSYmKGw9aC5tYXRjaCgvKFswLTldKykvZykubWFwKGZ1bmN0aW9uKG4pe3JldHVybiBwYXJzZUZsb2F0KG4pfSkscD1oLm1hdGNoKC8oW2Etel0pL2lnKS5qb2luKCIiKS50b0xvd2VyQ2FzZSgpKTtlbHNlIGlmKCFpc05hTihoKSlwPSJyZ2IiLGw9W2g+Pj4xNiwoaCY2NTI4MCk+Pj44LGgmMjU1XTtlbHNlIGlmKGcoaCkpe3ZhciBzPXYoaC5yLGgucmVkLGguUixudWxsKTtzIT09bnVsbD8ocD0icmdiIixsPVtzLHYoaC5nLGguZ3JlZW4saC5HKSx2KGguYixoLmJsdWUsaC5CKV0pOihwPSJoc2wiLGw9W3YoaC5oLGguaHVlLGguSCksdihoLnMsaC5zYXR1cmF0aW9uLGguUyksdihoLmwsaC5saWdodG5lc3MsaC5MLGguYixoLmJyaWdodG5lc3MpXSksbT12KGguYSxoLmFscGhhLGgub3BhY2l0eSwxKSxoLm9wYWNpdHkhPW51bGwmJihtLz0xMDApfWVsc2UoQXJyYXkuaXNBcnJheShoKXx8aS5BcnJheUJ1ZmZlciYmQXJyYXlCdWZmZXIuaXNWaWV3JiZBcnJheUJ1ZmZlci5pc1ZpZXcoaCkpJiYobD1baFswXSxoWzFdLGhbMl1dLHA9InJnYiIsbT1oLmxlbmd0aD09PTQ/aFszXToxKTtyZXR1cm57c3BhY2U6cCx2YWx1ZXM6bCxhbHBoYTptfX19KS5jYWxsKHRoaXMsdCgyMikpfSxmdW5jdGlvbihSLGUsdCl7Ui5leHBvcnRzPXthbGljZWJsdWU6WzI0MCwyNDgsMjU1XSxhbnRpcXVld2hpdGU6WzI1MCwyMzUsMjE1XSxhcXVhOlswLDI1NSwyNTVdLGFxdWFtYXJpbmU6WzEyNywyNTUsMjEyXSxhenVyZTpbMjQwLDI1NSwyNTVdLGJlaWdlOlsyNDUsMjQ1LDIyMF0sYmlzcXVlOlsyNTUsMjI4LDE5Nl0sYmxhY2s6WzAsMCwwXSxibGFuY2hlZGFsbW9uZDpbMjU1LDIzNSwyMDVdLGJsdWU6WzAsMCwyNTVdLGJsdWV2aW9sZXQ6WzEzOCw0MywyMjZdLGJyb3duOlsxNjUsNDIsNDJdLGJ1cmx5d29vZDpbMjIyLDE4NCwxMzVdLGNhZGV0Ymx1ZTpbOTUsMTU4LDE2MF0sY2hhcnRyZXVzZTpbMTI3LDI1NSwwXSxjaG9jb2xhdGU6WzIxMCwxMDUsMzBdLGNvcmFsOlsyNTUsMTI3LDgwXSxjb3JuZmxvd2VyYmx1ZTpbMTAwLDE0OSwyMzddLGNvcm5zaWxrOlsyNTUsMjQ4LDIyMF0sY3JpbXNvbjpbMjIwLDIwLDYwXSxjeWFuOlswLDI1NSwyNTVdLGRhcmtibHVlOlswLDAsMTM5XSxkYXJrY3lhbjpbMCwxMzksMTM5XSxkYXJrZ29sZGVucm9kOlsxODQsMTM0LDExXSxkYXJrZ3JheTpbMTY5LDE2OSwxNjldLGRhcmtncmVlbjpbMCwxMDAsMF0sZGFya2dyZXk6WzE2OSwxNjksMTY5XSxkYXJra2hha2k6WzE4OSwxODMsMTA3XSxkYXJrbWFnZW50YTpbMTM5LDAsMTM5XSxkYXJrb2xpdmVncmVlbjpbODUsMTA3LDQ3XSxkYXJrb3JhbmdlOlsyNTUsMTQwLDBdLGRhcmtvcmNoaWQ6WzE1Myw1MCwyMDRdLGRhcmtyZWQ6WzEzOSwwLDBdLGRhcmtzYWxtb246WzIzMywxNTAsMTIyXSxkYXJrc2VhZ3JlZW46WzE0MywxODgsMTQzXSxkYXJrc2xhdGVibHVlOls3Miw2MSwxMzldLGRhcmtzbGF0ZWdyYXk6WzQ3LDc5LDc5XSxkYXJrc2xhdGVncmV5Ols0Nyw3OSw3OV0sZGFya3R1cnF1b2lzZTpbMCwyMDYsMjA5XSxkYXJrdmlvbGV0OlsxNDgsMCwyMTFdLGRlZXBwaW5rOlsyNTUsMjAsMTQ3XSxkZWVwc2t5Ymx1ZTpbMCwxOTEsMjU1XSxkaW1ncmF5OlsxMDUsMTA1LDEwNV0sZGltZ3JleTpbMTA1LDEwNSwxMDVdLGRvZGdlcmJsdWU6WzMwLDE0NCwyNTVdLGZpcmVicmljazpbMTc4LDM0LDM0XSxmbG9yYWx3aGl0ZTpbMjU1LDI1MCwyNDBdLGZvcmVzdGdyZWVuOlszNCwxMzksMzRdLGZ1Y2hzaWE6WzI1NSwwLDI1NV0sZ2FpbnNib3JvOlsyMjAsMjIwLDIyMF0sZ2hvc3R3aGl0ZTpbMjQ4LDI0OCwyNTVdLGdvbGQ6WzI1NSwyMTUsMF0sZ29sZGVucm9kOlsyMTgsMTY1LDMyXSxncmF5OlsxMjgsMTI4LDEyOF0sZ3JlZW46WzAsMTI4LDBdLGdyZWVueWVsbG93OlsxNzMsMjU1LDQ3XSxncmV5OlsxMjgsMTI4LDEyOF0saG9uZXlkZXc6WzI0MCwyNTUsMjQwXSxob3RwaW5rOlsyNTUsMTA1LDE4MF0saW5kaWFucmVkOlsyMDUsOTIsOTJdLGluZGlnbzpbNzUsMCwxMzBdLGl2b3J5OlsyNTUsMjU1LDI0MF0sa2hha2k6WzI0MCwyMzAsMTQwXSxsYXZlbmRlcjpbMjMwLDIzMCwyNTBdLGxhdmVuZGVyYmx1c2g6WzI1NSwyNDAsMjQ1XSxsYXduZ3JlZW46WzEyNCwyNTIsMF0sbGVtb25jaGlmZm9uOlsyNTUsMjUwLDIwNV0sbGlnaHRibHVlOlsxNzMsMjE2LDIzMF0sbGlnaHRjb3JhbDpbMjQwLDEyOCwxMjhdLGxpZ2h0Y3lhbjpbMjI0LDI1NSwyNTVdLGxpZ2h0Z29sZGVucm9keWVsbG93OlsyNTAsMjUwLDIxMF0sbGlnaHRncmF5OlsyMTEsMjExLDIxMV0sbGlnaHRncmVlbjpbMTQ0LDIzOCwxNDRdLGxpZ2h0Z3JleTpbMjExLDIxMSwyMTFdLGxpZ2h0cGluazpbMjU1LDE4MiwxOTNdLGxpZ2h0c2FsbW9uOlsyNTUsMTYwLDEyMl0sbGlnaHRzZWFncmVlbjpbMzIsMTc4LDE3MF0sbGlnaHRza3libHVlOlsxMzUsMjA2LDI1MF0sbGlnaHRzbGF0ZWdyYXk6WzExOSwxMzYsMTUzXSxsaWdodHNsYXRlZ3JleTpbMTE5LDEzNiwxNTNdLGxpZ2h0c3RlZWxibHVlOlsxNzYsMTk2LDIyMl0sbGlnaHR5ZWxsb3c6WzI1NSwyNTUsMjI0XSxsaW1lOlswLDI1NSwwXSxsaW1lZ3JlZW46WzUwLDIwNSw1MF0sbGluZW46WzI1MCwyNDAsMjMwXSxtYWdlbnRhOlsyNTUsMCwyNTVdLG1hcm9vbjpbMTI4LDAsMF0sbWVkaXVtYXF1YW1hcmluZTpbMTAyLDIwNSwxNzBdLG1lZGl1bWJsdWU6WzAsMCwyMDVdLG1lZGl1bW9yY2hpZDpbMTg2LDg1LDIxMV0sbWVkaXVtcHVycGxlOlsxNDcsMTEyLDIxOV0sbWVkaXVtc2VhZ3JlZW46WzYwLDE3OSwxMTNdLG1lZGl1bXNsYXRlYmx1ZTpbMTIzLDEwNCwyMzhdLG1lZGl1bXNwcmluZ2dyZWVuOlswLDI1MCwxNTRdLG1lZGl1bXR1cnF1b2lzZTpbNzIsMjA5LDIwNF0sbWVkaXVtdmlvbGV0cmVkOlsxOTksMjEsMTMzXSxtaWRuaWdodGJsdWU6WzI1LDI1LDExMl0sbWludGNyZWFtOlsyNDUsMjU1LDI1MF0sbWlzdHlyb3NlOlsyNTUsMjI4LDIyNV0sbW9jY2FzaW46WzI1NSwyMjgsMTgxXSxuYXZham93aGl0ZTpbMjU1LDIyMiwxNzNdLG5hdnk6WzAsMCwxMjhdLG9sZGxhY2U6WzI1MywyNDUsMjMwXSxvbGl2ZTpbMTI4LDEyOCwwXSxvbGl2ZWRyYWI6WzEwNywxNDIsMzVdLG9yYW5nZTpbMjU1LDE2NSwwXSxvcmFuZ2VyZWQ6WzI1NSw2OSwwXSxvcmNoaWQ6WzIxOCwxMTIsMjE0XSxwYWxlZ29sZGVucm9kOlsyMzgsMjMyLDE3MF0scGFsZWdyZWVuOlsxNTIsMjUxLDE1Ml0scGFsZXR1cnF1b2lzZTpbMTc1LDIzOCwyMzhdLHBhbGV2aW9sZXRyZWQ6WzIxOSwxMTIsMTQ3XSxwYXBheWF3aGlwOlsyNTUsMjM5LDIxM10scGVhY2hwdWZmOlsyNTUsMjE4LDE4NV0scGVydTpbMjA1LDEzMyw2M10scGluazpbMjU1LDE5MiwyMDNdLHBsdW06WzIyMSwxNjAsMjIxXSxwb3dkZXJibHVlOlsxNzYsMjI0LDIzMF0scHVycGxlOlsxMjgsMCwxMjhdLHJlYmVjY2FwdXJwbGU6WzEwMiw1MSwxNTNdLHJlZDpbMjU1LDAsMF0scm9zeWJyb3duOlsxODgsMTQzLDE0M10scm95YWxibHVlOls2NSwxMDUsMjI1XSxzYWRkbGVicm93bjpbMTM5LDY5LDE5XSxzYWxtb246WzI1MCwxMjgsMTE0XSxzYW5keWJyb3duOlsyNDQsMTY0LDk2XSxzZWFncmVlbjpbNDYsMTM5LDg3XSxzZWFzaGVsbDpbMjU1LDI0NSwyMzhdLHNpZW5uYTpbMTYwLDgyLDQ1XSxzaWx2ZXI6WzE5MiwxOTIsMTkyXSxza3libHVlOlsxMzUsMjA2LDIzNV0sc2xhdGVibHVlOlsxMDYsOTAsMjA1XSxzbGF0ZWdyYXk6WzExMiwxMjgsMTQ0XSxzbGF0ZWdyZXk6WzExMiwxMjgsMTQ0XSxzbm93OlsyNTUsMjUwLDI1MF0sc3ByaW5nZ3JlZW46WzAsMjU1LDEyN10sc3RlZWxibHVlOls3MCwxMzAsMTgwXSx0YW46WzIxMCwxODAsMTQwXSx0ZWFsOlswLDEyOCwxMjhdLHRoaXN0bGU6WzIxNiwxOTEsMjE2XSx0b21hdG86WzI1NSw5OSw3MV0sdHVycXVvaXNlOls2NCwyMjQsMjA4XSx2aW9sZXQ6WzIzOCwxMzAsMjM4XSx3aGVhdDpbMjQ1LDIyMiwxNzldLHdoaXRlOlsyNTUsMjU1LDI1NV0sd2hpdGVzbW9rZTpbMjQ1LDI0NSwyNDVdLHllbGxvdzpbMjU1LDI1NSwwXSx5ZWxsb3dncmVlbjpbMTU0LDIwNSw1MF19fSxmdW5jdGlvbihSLGUsdCl7dmFyIGk9T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztSLmV4cG9ydHM9ZnVuY3Rpb24obyl7dmFyIGc7cmV0dXJuIGkuY2FsbChvKT09PSJbb2JqZWN0IE9iamVjdF0iJiYoZz1PYmplY3QuZ2V0UHJvdG90eXBlT2YobyksZz09PW51bGx8fGc9PT1PYmplY3QuZ2V0UHJvdG90eXBlT2Yoe30pKX19LGZ1bmN0aW9uKFIsZSl7Ui5leHBvcnRzPWZ1bmN0aW9uKCl7Zm9yKHZhciB0PTA7dDxhcmd1bWVudHMubGVuZ3RoO3QrKylpZihhcmd1bWVudHNbdF0hPT12b2lkIDApcmV0dXJuIGFyZ3VtZW50c1t0XX19LGZ1bmN0aW9uKFIsZSx0KXt2YXIgaT10KDM4KTtSLmV4cG9ydHM9e25hbWU6ImhzbCIsbWluOlswLDAsMF0sbWF4OlszNjAsMTAwLDEwMF0sY2hhbm5lbDpbImh1ZSIsInNhdHVyYXRpb24iLCJsaWdodG5lc3MiXSxhbGlhczpbIkhTTCJdLHJnYjpmdW5jdGlvbihvKXt2YXIgZz1vWzBdLzM2MCx2PW9bMV0vMTAwLGM9b1syXS8xMDAsZixoLEUsbCxtO2lmKHY9PT0wKXJldHVybiBtPWMqMjU1LFttLG0sbV07YzwuNT9oPWMqKDErdik6aD1jK3YtYyp2LGY9MipjLWgsbD1bMCwwLDBdO2Zvcih2YXIgcD0wO3A8MztwKyspRT1nKzEvMyotKHAtMSksRTwwP0UrKzpFPjEmJkUtLSw2KkU8MT9tPWYrKGgtZikqNipFOjIqRTwxP209aDozKkU8Mj9tPWYrKGgtZikqKDIvMy1FKSo2Om09ZixsW3BdPW0qMjU1O3JldHVybiBsfX0saS5oc2w9ZnVuY3Rpb24obyl7dmFyIGc9b1swXS8yNTUsdj1vWzFdLzI1NSxjPW9bMl0vMjU1LGY9TWF0aC5taW4oZyx2LGMpLGg9TWF0aC5tYXgoZyx2LGMpLEU9aC1mLGwsbSxwO3JldHVybiBoPT09Zj9sPTA6Zz09PWg/bD0odi1jKS9FOnY9PT1oP2w9MisoYy1nKS9FOmM9PT1oJiYobD00KyhnLXYpL0UpLGw9TWF0aC5taW4obCo2MCwzNjApLGw8MCYmKGwrPTM2MCkscD0oZitoKS8yLGg9PT1mP209MDpwPD0uNT9tPUUvKGgrZik6bT1FLygyLWgtZiksW2wsbSoxMDAscCoxMDBdfX0sZnVuY3Rpb24oUixlLHQpe1IuZXhwb3J0cz17bmFtZToicmdiIixtaW46WzAsMCwwXSxtYXg6WzI1NSwyNTUsMjU1XSxjaGFubmVsOlsicmVkIiwiZ3JlZW4iLCJibHVlIl0sYWxpYXM6WyJSR0IiXX19LGZ1bmN0aW9uKFIsZSl7Ui5leHBvcnRzPXQ7ZnVuY3Rpb24gdChpLG8sZyl7cmV0dXJuIG88Zz9pPG8/bzppPmc/ZzppOmk8Zz9nOmk+bz9vOml9fSxmdW5jdGlvbihSLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBzfSk7dmFyIGk9dCg0MSksbz10Lm4oaSksZz10KDQyKSx2PXQubihnKSxjPXQoNDMpLGY9dC5uKGMpLGg9dCg0NCksRT10KDQ2KSxsPXQubihFKSxtPXQoNTMpLHA9dCg1NSk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IEM9U3ltYm9sKCJjb250b3VycyIpLHg9U3ltYm9sKCJwYXRoIiksZD1TeW1ib2woInNpbXBsaWZ5IikseT1TeW1ib2woInNjYWxlIikscj0yKk1hdGguUEk7Y2xhc3Mgc3tjb25zdHJ1Y3RvcihhPXt9KXt0eXBlb2YgYT09InN0cmluZyImJihhPXtwYXRoOmF9KSxhLnBhdGg/dGhpc1t4XT1vKCkoYS5wYXRoKTp0aGlzW3hdPVtdLHRoaXNbQ109bnVsbCx0aGlzW2RdPWEuc2ltcGxpZnkhPW51bGw/YS5zaW1wbGlmeTowLHRoaXNbeV09YS5zY2FsZSE9bnVsbD9hLnNjYWxlOjJ9Z2V0IGNvbnRvdXJzKCl7bGV0IGE9bnVsbDtpZighdGhpc1tDXSYmdGhpc1t4XSl7Y29uc3QgTz1PYmplY3QoaC5kZWZhdWx0KShmKCkodGhpc1t4XSkpO3RoaXNbQ109bCgpKE8sdGhpc1t5XSx0aGlzW2RdKSx0aGlzW0NdLnBhdGg9Tyx0aGlzW0NdLnNpbXBsaWZ5PXRoaXNbZF0sdGhpc1tDXS5zY2FsZT10aGlzW3ldfXJldHVybiB0aGlzW0NdJiYoYT10aGlzW0NdLm1hcChPPT5bLi4uT10pLGEucGF0aD10aGlzW0NdLnBhdGgsYS5zaW1wbGlmeT10aGlzW0NdLnNpbXBsaWZ5LGEuc2NhbGU9dGhpc1tDXS5zY2FsZSksYX1nZXQgcGF0aCgpe3JldHVybiB0aGlzW3hdfWdldCBzaW1wbGlmeSgpe3JldHVybiB0aGlzW2RdfWdldCBib3VuZGluZ0JveCgpe2NvbnN0IGE9dGhpcy5jb250b3VycztpZihhJiZhLmxlbmd0aCl7Y29uc3QgTz1hLnJlZHVjZSgoQSxiKT0+Wy4uLkEsLi4uYl0pO3JldHVybiB2KCkoTyl9cmV0dXJuW1swLDBdLFswLDBdXX1nZXQgYm91bmRpbmdDZW50ZXIoKXtjb25zdCBhPXRoaXMuYm91bmRpbmdCb3g7cmV0dXJuIGE/Wy41KihhWzBdWzBdK2FbMV1bMF0pLC41KihhWzBdWzFdK2FbMV1bMV0pXTpbMCwwXX1ub3JtYWxpemUoYT0wLE89MCl7Y29uc3QgQT1PYmplY3QoaC5kZWZhdWx0KShmKCkodGhpc1t4XSkpLm1hcCgoW2IsLi4uSV0pPT57Y29uc3QgUD1bYl07Zm9yKGxldCBEPTA7RDxJLmxlbmd0aDtEKz0yKXtjb25zdCBMPUlbRF0tYSxTPUlbRCsxXS1PO1AucHVzaChMLFMpfXJldHVybiBQfSk7cmV0dXJuIHRoaXMuYmVnaW5QYXRoKCksdGhpc1t4XS5wdXNoKC4uLkEpLHRoaXN9Z2V0UG9pbnRBdExlbmd0aChhKXtyZXR1cm4gdGhpcy5jb250b3Vycz9PYmplY3QobS5nZXRQb2ludEF0TGVuZ3RoKSh0aGlzW0NdLGEpOm51bGx9Z2V0VG90YWxMZW5ndGgoKXtyZXR1cm4gdGhpcy5jb250b3Vycz9PYmplY3QobS5nZXRUb3RhbExlbmd0aCkodGhpc1tDXSk6MH1hZGRQYXRoKGEpe3RoaXNbQ109bnVsbCx0eXBlb2YgYT09InN0cmluZyImJihhPW8oKShhKSksdGhpc1t4XS5wdXNoKC4uLmEpfWJlZ2luUGF0aCgpe3RoaXNbeF09W10sdGhpc1tDXT1udWxsfWNsZWFyKCl7dGhpcy5iZWdpblBhdGgoKX1lbGxpcHNlKGEsTyxBLGIsSSxQLEQsTD0wKXtpZihQKz1JLEQrPUksQTw9MHx8Yjw9MHx8RD09PVApcmV0dXJuO0Q8UCYmKEQ9UCtyKyhELVApJXIpLEQtUD5yJiYoRD1QK3IpO2NvbnN0IFM9RC1QO1M+PXImJihELT0uMDAxKTtsZXQgVD10aGlzW3hdLmxlbmd0aD4wJiZTPHI/IkwiOiJNIjtjb25zdCBqPU9iamVjdChwLmdldFBvaW50KShhLE8sQSxiLFApLCQ9T2JqZWN0KHAuZ2V0UG9pbnQpKGEsTyxBLGIsRCksdz0rIUw7bGV0IEo9Uz5NYXRoLlBJPzE6MDtMJiYoSj0xLUopLFQrPWouam9pbigiICIpLFQrPWBBJHtBfSAke2J9IDAgJHtKfSAke3d9ICR7JC5qb2luKCIgIil9YCxTPj1yJiYoVCs9IloiKSx0aGlzLmFkZFBhdGgoVCl9YXJjKGEsTyxBLGIsSSxQPTApe3JldHVybiB0aGlzLmVsbGlwc2UoYSxPLEEsQSwwLGIsSSxQKX1hcmNUbyhhLE8sQSxiLEksUCxEKXt0aGlzW0NdPW51bGwsdGhpc1t4XS5wdXNoKFsiQSIsYSxPLEEsYixJLFAsRF0pfW1vdmVUbyhhLE8pe3RoaXNbQ109bnVsbCx0aGlzW3hdLnB1c2goWyJNIixhLE9dKX1saW5lVG8oYSxPKXt0aGlzW0NdPW51bGwsdGhpc1t4XS5wdXNoKFsiTCIsYSxPXSl9YmV6aWVyQ3VydmVUbyhhLE8sQSxiLEksUCl7dGhpc1tDXT1udWxsLHRoaXNbeF0ucHVzaChbIkMiLGEsTyxBLGIsSSxQXSl9cXVhZHJhdGljQ3VydmVUbyhhLE8sQSxiKXt0aGlzW0NdPW51bGwsdGhpc1t4XS5wdXNoKFsiUSIsYSxPLEEsYl0pfXJlY3QoYSxPLEEsYil7Y29uc3QgST1gTSR7YX0gJHtPfUwke2ErQX0gJHtPfUwke2ErQX0gJHtPK2J9TCR7YX0gJHtPK2J9WmA7dGhpcy5hZGRQYXRoKEkpfWNsb3NlUGF0aCgpe3RoaXNbQ109bnVsbDtsZXQgYT1bXTtjb25zdCBPPXRoaXNbeF0ubGVuZ3RoO08+MCYmKGE9dGhpc1t4XVtPLTFdKSxhWzBdIT09IloiJiZhWzBdIT09InoiJiZ0aGlzW3hdLnB1c2goWyJaIl0pfX19LGZ1bmN0aW9uKFIsZSl7Ui5leHBvcnRzPW87dmFyIHQ9e2E6NyxjOjYsaDoxLGw6MixtOjIscTo0LHM6NCx0OjIsdjoxLHo6MH0saT0vKFthc3R2enFtaGxjXSkoW15hc3R2enFtaGxjXSopL2lnO2Z1bmN0aW9uIG8oYyl7dmFyIGY9W107cmV0dXJuIGMucmVwbGFjZShpLGZ1bmN0aW9uKGgsRSxsKXt2YXIgbT1FLnRvTG93ZXJDYXNlKCk7Zm9yKGw9dihsKSxtPT0ibSImJmwubGVuZ3RoPjImJihmLnB1c2goW0VdLmNvbmNhdChsLnNwbGljZSgwLDIpKSksbT0ibCIsRT1FPT0ibSI/ImwiOiJMIik7Oyl7aWYobC5sZW5ndGg9PXRbbV0pcmV0dXJuIGwudW5zaGlmdChFKSxmLnB1c2gobCk7aWYobC5sZW5ndGg8dFttXSl0aHJvdyBuZXcgRXJyb3IoIm1hbGZvcm1lZCBwYXRoIGRhdGEiKTtmLnB1c2goW0VdLmNvbmNhdChsLnNwbGljZSgwLHRbbV0pKSl9fSksZn12YXIgZz0vLT9bMC05XSpcLj9bMC05XSsoPzplWy0rXT9cZCspPy9pZztmdW5jdGlvbiB2KGMpe3ZhciBmPWMubWF0Y2goZyk7cmV0dXJuIGY/Zi5tYXAoTnVtYmVyKTpbXX19LGZ1bmN0aW9uKFIsZSx0KXtSLmV4cG9ydHM9aTtmdW5jdGlvbiBpKG8pe3ZhciBnPW8ubGVuZ3RoO2lmKGc9PT0wKXJldHVybltbXSxbXV07Zm9yKHZhciB2PW9bMF0ubGVuZ3RoLGM9b1swXS5zbGljZSgpLGY9b1swXS5zbGljZSgpLGg9MTtoPGc7KytoKWZvcih2YXIgRT1vW2hdLGw9MDtsPHY7KytsKXt2YXIgbT1FW2xdO2NbbF09TWF0aC5taW4oY1tsXSxtKSxmW2xdPU1hdGgubWF4KGZbbF0sbSl9cmV0dXJuW2MsZl19fSxmdW5jdGlvbihSLGUpe1IuZXhwb3J0cz10O2Z1bmN0aW9uIHQoaSl7dmFyIG89MCxnPTAsdj0wLGM9MDtyZXR1cm4gaS5tYXAoZnVuY3Rpb24oZil7Zj1mLnNsaWNlKCk7dmFyIGg9ZlswXSxFPWgudG9VcHBlckNhc2UoKTtpZihoIT1FKXN3aXRjaChmWzBdPUUsaCl7Y2FzZSJhIjpmWzZdKz12LGZbN10rPWM7YnJlYWs7Y2FzZSJ2IjpmWzFdKz1jO2JyZWFrO2Nhc2UiaCI6ZlsxXSs9djticmVhaztkZWZhdWx0OmZvcih2YXIgbD0xO2w8Zi5sZW5ndGg7KWZbbCsrXSs9dixmW2wrK10rPWN9c3dpdGNoKEUpe2Nhc2UiWiI6dj1vLGM9ZzticmVhaztjYXNlIkgiOnY9ZlsxXTticmVhaztjYXNlIlYiOmM9ZlsxXTticmVhaztjYXNlIk0iOnY9bz1mWzFdLGM9Zz1mWzJdO2JyZWFrO2RlZmF1bHQ6dj1mW2YubGVuZ3RoLTJdLGM9ZltmLmxlbmd0aC0xXX1yZXR1cm4gZn0pfX0sZnVuY3Rpb24oUixlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gb30pO3ZhciBpPXQoNDUpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBvKGMpe2Zvcih2YXIgZixoPVtdLEU9MCxsPTAsbT0wLHA9MCxDPW51bGwseD1udWxsLGQ9MCx5PTAscj0wLHM9Yy5sZW5ndGg7cjxzO3IrKyl7dmFyIG49Y1tyXSxhPW5bMF07c3dpdGNoKGEpe2Nhc2UiTSI6bT1uWzFdLHA9blsyXTticmVhaztjYXNlIkEiOnZhciBPPU9iamVjdChpLmRlZmF1bHQpKGQseSxuWzZdLG5bN10sbls0XSxuWzVdLG5bMV0sblsyXSxuWzNdKTtpZighTy5sZW5ndGgpY29udGludWU7Tz1PLm1hcChEPT57Y29uc3RbTCxTLFQsaiwkLHcsSixxXT1EO3JldHVybnt4MTpULHkxOmoseDI6JCx5Mjp3LHg6Six5OnF9fSk7Zm9yKHZhciBBPTAsYjtBPE8ubGVuZ3RoO0ErKyliPU9bQV0sbj1bIkMiLGIueDEsYi55MSxiLngyLGIueTIsYi54LGIueV0sQTxPLmxlbmd0aC0xJiZoLnB1c2gobik7YnJlYWs7Y2FzZSJTIjp2YXIgST1kLFA9eTsoZj09IkMifHxmPT0iUyIpJiYoSSs9SS1FLFArPVAtbCksbj1bIkMiLEksUCxuWzFdLG5bMl0sblszXSxuWzRdXTticmVhaztjYXNlIlQiOmY9PSJRInx8Zj09IlQiPyhDPWQqMi1DLHg9eSoyLXgpOihDPWQseD15KSxuPXYoZCx5LEMseCxuWzFdLG5bMl0pO2JyZWFrO2Nhc2UiUSI6Qz1uWzFdLHg9blsyXSxuPXYoZCx5LG5bMV0sblsyXSxuWzNdLG5bNF0pO2JyZWFrO2Nhc2UiTCI6bj1nKGQseSxuWzFdLG5bMl0pO2JyZWFrO2Nhc2UiSCI6bj1nKGQseSxuWzFdLHkpO2JyZWFrO2Nhc2UiViI6bj1nKGQseSxkLG5bMV0pO2JyZWFrO2Nhc2UiWiI6bj1nKGQseSxtLHApO2JyZWFrfWY9YSxkPW5bbi5sZW5ndGgtMl0seT1uW24ubGVuZ3RoLTFdLG4ubGVuZ3RoPjQ/KEU9bltuLmxlbmd0aC00XSxsPW5bbi5sZW5ndGgtM10pOihFPWQsbD15KSxoLnB1c2gobil9cmV0dXJuIGh9ZnVuY3Rpb24gZyhjLGYsaCxFKXtyZXR1cm5bIkMiLGMsZixoLEUsaCxFXX1mdW5jdGlvbiB2KGMsZixoLEUsbCxtKXtyZXR1cm5bIkMiLGMvMysyLzMqaCxmLzMrMi8zKkUsbC8zKzIvMypoLG0vMysyLzMqRSxsLG1dfX0sZnVuY3Rpb24oUixlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gY30pLHQoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCBpPU1hdGguUEkqMjtmdW5jdGlvbiBvKGYsaCxFLGwpe2NvbnN0IG09ZipsLWgqRTwwPy0xOjE7bGV0IHA9ZipFK2gqbDtyZXR1cm4gcD4xJiYocD0xKSxwPC0xJiYocD0tMSksbSpNYXRoLmFjb3MocCl9ZnVuY3Rpb24gZyhmLGgsRSxsLG0scCxDLHgsZCx5KXtjb25zdCByPXkqKGYtRSkvMitkKihoLWwpLzIscz0tZCooZi1FKS8yK3kqKGgtbCkvMixuPUMqQyxhPXgqeCxPPXIqcixBPXMqcztsZXQgYj1uKmEtbipBLWEqTztiPDAmJihiPTApLGIvPW4qQSthKk8sYj1NYXRoLnNxcnQoYikqKG09PT1wPy0xOjEpO2NvbnN0IEk9YipDL3gqcyxQPWIqLXgvQypyLEQ9eSpJLWQqUCsoZitFKS8yLEw9ZCpJK3kqUCsoaCtsKS8yLFM9KHItSSkvQyxUPShzLVApL3gsaj0oLXItSSkvQywkPSgtcy1QKS94LHc9bygxLDAsUyxUKTtsZXQgSj1vKFMsVCxqLCQpO3JldHVybiBwPT09MCYmSj4wJiYoSi09aSkscD09PTEmJko8MCYmKEorPWkpLFtELEwsdyxKXX1mdW5jdGlvbiB2KGYsaCl7Y29uc3QgRT0xLjMzMzMzMzMzMzMzMzMzMzMqTWF0aC50YW4oaC80KSxsPU1hdGguY29zKGYpLG09TWF0aC5zaW4oZikscD1NYXRoLmNvcyhmK2gpLEM9TWF0aC5zaW4oZitoKTtyZXR1cm5bbCxtLGwtbSpFLG0rbCpFLHArQypFLEMtcCpFLHAsQ119ZnVuY3Rpb24gYyhmLGgsRSxsLG0scCxDLHgsZCl7Y29uc3QgeT1NYXRoLnNpbihkKmkvMzYwKSxyPU1hdGguY29zKGQqaS8zNjApLHM9ciooZi1FKS8yK3kqKGgtbCkvMixuPS15KihmLUUpLzIrciooaC1sKS8yO2lmKHM9PT0wJiZuPT09MClyZXR1cm5bXTtpZihDPT09MHx8eD09PTApcmV0dXJuW107Qz1NYXRoLmFicyhDKSx4PU1hdGguYWJzKHgpO2NvbnN0IGE9cypzLyhDKkMpK24qbi8oeCp4KTthPjEmJihDKj1NYXRoLnNxcnQoYSkseCo9TWF0aC5zcXJ0KGEpKTtjb25zdCBPPWcoZixoLEUsbCxtLHAsQyx4LHksciksQT1bXTtsZXQgYj1PWzJdLEk9T1szXTtjb25zdCBQPU1hdGgubWF4KE1hdGguY2VpbChNYXRoLmFicyhJKS8oaS80KSksMSk7SS89UDtmb3IobGV0IEQ9MDtEPFA7RCsrKUEucHVzaCh2KGIsSSkpLGIrPUk7cmV0dXJuIEEubWFwKEQ9Pntmb3IobGV0IEw9MDtMPEQubGVuZ3RoO0wrPTIpe2xldCBTPURbTCswXSxUPURbTCsxXTtTKj1DLFQqPXg7Y29uc3Qgaj1yKlMteSpULCQ9eSpTK3IqVDtEW0wrMF09aitPWzBdLERbTCsxXT0kK09bMV19cmV0dXJuIER9KX19LGZ1bmN0aW9uKFIsZSx0KXt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7dmFyIGk9dCg0Nykse2NvcHk6b309dCg0OSksZz10KDUwKTtmdW5jdGlvbiB2KGwsbSxwKXtyZXR1cm4gbFswXT1tLGxbMV09cCxsfXZhciBjPVswLDBdLGY9WzAsMF0saD1bMCwwXTtmdW5jdGlvbiBFKGwsbSxwLEMpe2kocCx2KGMsQ1sxXSxDWzJdKSx2KGYsQ1szXSxDWzRdKSx2KGgsQ1s1XSxDWzZdKSxtLGwpfVIuZXhwb3J0cz1mdW5jdGlvbihtLHAsQyl7dmFyIHg9W10sZD1bXSx5PVswLDBdO3JldHVybiBtLmZvckVhY2goZnVuY3Rpb24ocixzLG4pe2lmKHJbMF09PT0iTSIpbyh5LHIuc2xpY2UoMSkpLGQubGVuZ3RoPjAmJih4LnB1c2goZCksZD1bXSk7ZWxzZSBpZihyWzBdPT09IkMiKUUoZCxwLHksciksdih5LHJbNV0scls2XSk7ZWxzZSB0aHJvdyBuZXcgRXJyb3IoImlsbGVnYWwgdHlwZSBpbiBTVkc6ICIrclswXSl9KSxkLmxlbmd0aD4wJiZ4LnB1c2goZCkseC5tYXAoZnVuY3Rpb24ocil7cmV0dXJuIGcocixDfHwwKX0pfX0sZnVuY3Rpb24oUixlLHQpe1IuZXhwb3J0cz10KDQ4KSgpfSxmdW5jdGlvbihSLGUpe2Z1bmN0aW9uIHQobyl7cmV0dXJuW29bMF0sb1sxXV19ZnVuY3Rpb24gaShvLGcpe3JldHVybltvLGddfVIuZXhwb3J0cz1mdW5jdGlvbihnKXtnPWd8fHt9O3ZhciB2PXR5cGVvZiBnLnJlY3Vyc2lvbj09Im51bWJlciI/Zy5yZWN1cnNpb246OCxjPXR5cGVvZiBnLmVwc2lsb249PSJudW1iZXIiP2cuZXBzaWxvbjoxMTkyMDkyOWUtMTQsZj10eXBlb2YgZy5wYXRoRXBzaWxvbj09Im51bWJlciI/Zy5wYXRoRXBzaWxvbjoxLGg9dHlwZW9mIGcuYW5nbGVFcHNpbG9uPT0ibnVtYmVyIj9nLmFuZ2xlRXBzaWxvbjouMDEsRT1nLmFuZ2xlVG9sZXJhbmNlfHwwLGw9Zy5jdXNwTGltaXR8fDA7cmV0dXJuIGZ1bmN0aW9uKHgsZCx5LHIscyxuKXtufHwobj1bXSkscz10eXBlb2Ygcz09Im51bWJlciI/czoxO3ZhciBhPWYvcztyZXR1cm4gYSo9YSxtKHgsZCx5LHIsbixhKSxufTtmdW5jdGlvbiBtKEMseCxkLHkscixzKXtyLnB1c2godChDKSk7dmFyIG49Q1swXSxhPUNbMV0sTz14WzBdLEE9eFsxXSxiPWRbMF0sST1kWzFdLFA9eVswXSxEPXlbMV07cChuLGEsTyxBLGIsSSxQLEQscixzLDApLHIucHVzaCh0KHkpKX1mdW5jdGlvbiBwKEMseCxkLHkscixzLG4sYSxPLEEsYil7aWYoIShiPnYpKXt2YXIgST1NYXRoLlBJLFA9KEMrZCkvMixEPSh4K3kpLzIsTD0oZCtyKS8yLFM9KHkrcykvMixUPShyK24pLzIsaj0ocythKS8yLCQ9KFArTCkvMix3PShEK1MpLzIsSj0oTCtUKS8yLHE9KFMraikvMixXPSgkK0opLzIsSz0odytxKS8yO2lmKGI+MCl7dmFyIFE9bi1DLHR0PWEteCxfPU1hdGguYWJzKChkLW4pKnR0LSh5LWEpKlEpLHN0PU1hdGguYWJzKChyLW4pKnR0LShzLWEpKlEpLGssY3Q7aWYoXz5jJiZzdD5jKXtpZigoXytzdCkqKF8rc3QpPD1BKihRKlErdHQqdHQpKXtpZihFPGgpe08ucHVzaChpKFcsSykpO3JldHVybn12YXIgZnQ9TWF0aC5hdGFuMihzLXksci1kKTtpZihrPU1hdGguYWJzKGZ0LU1hdGguYXRhbjIoeS14LGQtQykpLGN0PU1hdGguYWJzKE1hdGguYXRhbjIoYS1zLG4tciktZnQpLGs+PUkmJihrPTIqSS1rKSxjdD49SSYmKGN0PTIqSS1jdCksaytjdDxFKXtPLnB1c2goaShXLEspKTtyZXR1cm59aWYobCE9PTApe2lmKGs+bCl7Ty5wdXNoKGkoZCx5KSk7cmV0dXJufWlmKGN0Pmwpe08ucHVzaChpKHIscykpO3JldHVybn19fX1lbHNlIGlmKF8+Yyl7aWYoXypfPD1BKihRKlErdHQqdHQpKXtpZihFPGgpe08ucHVzaChpKFcsSykpO3JldHVybn1pZihrPU1hdGguYWJzKE1hdGguYXRhbjIocy15LHItZCktTWF0aC5hdGFuMih5LXgsZC1DKSksaz49SSYmKGs9MipJLWspLGs8RSl7Ty5wdXNoKGkoZCx5KSksTy5wdXNoKGkocixzKSk7cmV0dXJufWlmKGwhPT0wJiZrPmwpe08ucHVzaChpKGQseSkpO3JldHVybn19fWVsc2UgaWYoc3Q+Yyl7aWYoc3Qqc3Q8PUEqKFEqUSt0dCp0dCkpe2lmKEU8aCl7Ty5wdXNoKGkoVyxLKSk7cmV0dXJufWlmKGs9TWF0aC5hYnMoTWF0aC5hdGFuMihhLXMsbi1yKS1NYXRoLmF0YW4yKHMteSxyLWQpKSxrPj1JJiYoaz0yKkktayksazxFKXtPLnB1c2goaShkLHkpKSxPLnB1c2goaShyLHMpKTtyZXR1cm59aWYobCE9PTAmJms+bCl7Ty5wdXNoKGkocixzKSk7cmV0dXJufX19ZWxzZSBpZihRPVctKEMrbikvMix0dD1LLSh4K2EpLzIsUSpRK3R0KnR0PD1BKXtPLnB1c2goaShXLEspKTtyZXR1cm59fXAoQyx4LFAsRCwkLHcsVyxLLE8sQSxiKzEpLHAoVyxLLEoscSxULGosbixhLE8sQSxiKzEpfX19fSxmdW5jdGlvbihSLGUsdCl7dC5yKGUpLHQuZChlLCJjcmVhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIGd9KSx0LmQoZSwiY2xvbmUiLGZ1bmN0aW9uKCl7cmV0dXJuIG99KSx0LmQoZSwiY29weSIsZnVuY3Rpb24oKXtyZXR1cm4gdn0pLHQuZChlLCJzY2FsZUFuZEFkZCIsZnVuY3Rpb24oKXtyZXR1cm4gY30pLHQuZChlLCJkb3QiLGZ1bmN0aW9uKCl7cmV0dXJuIGZ9KSx0LmQoZSwicm90YXRlIixmdW5jdGlvbigpe3JldHVybiBofSksdC5kKGUsImNyb3NzIixmdW5jdGlvbigpe3JldHVybiBFfSksdC5kKGUsInN1YiIsZnVuY3Rpb24oKXtyZXR1cm4gbH0pLHQuZChlLCJhZGQiLGZ1bmN0aW9uKCl7cmV0dXJuIG19KSx0LmQoZSwiY29tcHV0ZU1pdGVyIixmdW5jdGlvbigpe3JldHVybiBkfSksdC5kKGUsIm5vcm1hbCIsZnVuY3Rpb24oKXtyZXR1cm4geX0pLHQuZChlLCJkaXJlY3Rpb24iLGZ1bmN0aW9uKCl7cmV0dXJuIHJ9KTt2YXIgaT10KDEpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBvKHMpe3JldHVybltzWzBdLHNbMV1dfWZ1bmN0aW9uIGcoKXtyZXR1cm5bMCwwXX1jb25zdCB2PWkudmVjMi5jb3B5LGM9aS52ZWMyLnNjYWxlQW5kQWRkLGY9aS52ZWMyLmRvdCxoPWkudmVjMi5yb3RhdGUsRT1pLnZlYzIuY3Jvc3MsbD1pLnZlYzIuc3ViLG09aS52ZWMyLmFkZCxwPWkudmVjMi5ub3JtYWxpemUsQz1pLnZlYzIuc2V0LHg9ZygpO2Z1bmN0aW9uIGQocyxuLGEsTyxBKXttKHMsYSxPKSxwKHMscyksQyhuLC1zWzFdLHNbMF0pLEMoeCwtYVsxXSxhWzBdKTtjb25zdCBiPUEvZihuLHgpO3JldHVybiBNYXRoLmFicyhiKX1mdW5jdGlvbiB5KHMsbil7cmV0dXJuIEMocywtblsxXSxuWzBdKSxzfWZ1bmN0aW9uIHIocyxuLGEpe3JldHVybiBsKHMsbixhKSxwKHMscyksc319LGZ1bmN0aW9uKFIsZSx0KXt2YXIgaT10KDUxKSxvPXQoNTIpO1IuZXhwb3J0cz1mdW5jdGlvbih2LGMpe3JldHVybiB2PWkodixjKSx2PW8odixjKSx2fSxSLmV4cG9ydHMucmFkaWFsRGlzdGFuY2U9aSxSLmV4cG9ydHMuZG91Z2xhc1BldWNrZXI9b30sZnVuY3Rpb24oUixlKXtmdW5jdGlvbiB0KGksbyl7dmFyIGc9aVswXS1vWzBdLHY9aVsxXS1vWzFdO3JldHVybiBnKmcrdip2fVIuZXhwb3J0cz1mdW5jdGlvbihvLGcpe2lmKG8ubGVuZ3RoPD0xKXJldHVybiBvO2c9dHlwZW9mIGc9PSJudW1iZXIiP2c6MTtmb3IodmFyIHY9ZypnLGM9b1swXSxmPVtjXSxoLEU9MSxsPW8ubGVuZ3RoO0U8bDtFKyspaD1vW0VdLHQoaCxjKT52JiYoZi5wdXNoKGgpLGM9aCk7cmV0dXJuIGMhPT1oJiZmLnB1c2goaCksZn19LGZ1bmN0aW9uKFIsZSl7ZnVuY3Rpb24gdChvLGcsdil7dmFyIGM9Z1swXSxmPWdbMV0saD12WzBdLWMsRT12WzFdLWY7aWYoaCE9PTB8fEUhPT0wKXt2YXIgbD0oKG9bMF0tYykqaCsob1sxXS1mKSpFKS8oaCpoK0UqRSk7bD4xPyhjPXZbMF0sZj12WzFdKTpsPjAmJihjKz1oKmwsZis9RSpsKX1yZXR1cm4gaD1vWzBdLWMsRT1vWzFdLWYsaCpoK0UqRX1mdW5jdGlvbiBpKG8sZyx2LGMsZil7Zm9yKHZhciBoPWMsRSxsPWcrMTtsPHY7bCsrKXt2YXIgbT10KG9bbF0sb1tnXSxvW3ZdKTttPmgmJihFPWwsaD1tKX1oPmMmJihFLWc+MSYmaShvLGcsRSxjLGYpLGYucHVzaChvW0VdKSx2LUU+MSYmaShvLEUsdixjLGYpKX1SLmV4cG9ydHM9ZnVuY3Rpb24oZyx2KXtpZihnLmxlbmd0aDw9MSlyZXR1cm4gZzt2PXR5cGVvZiB2PT0ibnVtYmVyIj92OjE7dmFyIGM9dip2LGY9Zy5sZW5ndGgtMSxoPVtnWzBdXTtyZXR1cm4gaShnLDAsZixjLGgpLGgucHVzaChnW2ZdKSxofX0sZnVuY3Rpb24oUixlLHQpe3QucihlKSx0LmQoZSwiZ2V0VG90YWxMZW5ndGgiLGZ1bmN0aW9uKCl7cmV0dXJuIG99KSx0LmQoZSwiZ2V0UG9pbnRBdExlbmd0aCIsZnVuY3Rpb24oKXtyZXR1cm4gdn0pLHQuZChlLCJnZXREYXNoQ29udG91cnMiLGZ1bmN0aW9uKCl7cmV0dXJuIGN9KTt2YXIgaT10KDU0KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gbyhmKXtpZihmLnRvdGFsTGVuZ3RoIT1udWxsKXJldHVybiBmLnRvdGFsTGVuZ3RoO2xldCBoPTA7cmV0dXJuIGYuZm9yRWFjaChFPT57bGV0IGw9RVswXTtmb3IobGV0IG09MTttPEUubGVuZ3RoO20rKyl7Y29uc3QgcD1FW21dO2grPU9iamVjdChpLmRpc3RhbmNlKShsLHApLGw9cH19KSxmLnRvdGFsTGVuZ3RoPWgsaH1mdW5jdGlvbiBnKGYsaCxFPSEwKXtpZihoPU51bWJlcihoKSwhTnVtYmVyLmlzRmluaXRlKGgpKXRocm93IG5ldyBUeXBlRXJyb3IoIkZhaWxlZCB0byBleGVjdXRlICdnZXRQb2ludEF0TGVuZ3RoJyBvbiBmaWd1cmU6IFRoZSBwcm92aWRlZCBmbG9hdCB2YWx1ZSBpcyBub24tZmluaXRlLiIpO2lmKGg8PTApdGhyb3cgbmV3IFR5cGVFcnJvcigiTGVuZ3RoIG11c3QgPiAwIik7Y29uc3QgbD1vKGYpO2lmKGg+PWwpe2NvbnN0IHA9ZltmLmxlbmd0aC0xXSxDPXBbcC5sZW5ndGgtMl0seD1wW3AubGVuZ3RoLTFdLGQ9TWF0aC5hdGFuMih4WzFdLUNbMV0seFswXS1DWzBdKTtyZXR1cm57Y3VycmVudDpmLm1hcCh5PT5bLi4ueV0pLHBvaW50Ont4OnhbMF0seTp4WzFdLGFuZ2xlOmR9fX1jb25zdCBtPVtdO2ZvcihsZXQgcD0wO3A8Zi5sZW5ndGg7cCsrKXttW3BdPVtdO2NvbnN0IEM9ZltwXTtsZXQgeD1DWzBdO2ZvcihsZXQgZD0xO2Q8Qy5sZW5ndGg7ZCsrKXtjb25zdCB5PUNbZF0scj1PYmplY3QoaS5kaXN0YW5jZSkoeCx5KTtpZihoPHIpe2NvbnN0IHM9aC9yLG49TWF0aC5hdGFuMih5WzFdLXhbMV0seVswXS14WzBdKSxhPXt4OnhbMF0qKDEtcykreVswXSpzLHk6eFsxXSooMS1zKSt5WzFdKnMsYW5nbGU6bn07aWYobVtwXS5wdXNoKHgpLGg+MCYmbVtwXS5wdXNoKFthLngsYS55XSksIUUpcmV0dXJue2N1cnJlbnQ6bSxwb2ludDphfTtjb25zdCBPPVtdLEE9cDtmb3IoO3A8Zi5sZW5ndGg7cCsrKXtmb3IoT1twLUFdPVtdLHA9PT1BJiZPWzBdLnB1c2goW2EueCxhLnldKTtkPEMubGVuZ3RoO2QrKylPW3AtQV0ucHVzaChDW2RdKTtkPTB9cmV0dXJue2N1cnJlbnQ6bSxwb2ludDphLHJlc3Q6T319aC09cixtW3BdLnB1c2goeCkseD15fX19ZnVuY3Rpb24gdihmLGgpe2lmKGg9TnVtYmVyKGgpLCFOdW1iZXIuaXNGaW5pdGUoaCkpdGhyb3cgbmV3IFR5cGVFcnJvcigiRmFpbGVkIHRvIGV4ZWN1dGUgJ2dldFBvaW50QXRMZW5ndGgnIG9uIGZpZ3VyZTogVGhlIHByb3ZpZGVkIGZsb2F0IHZhbHVlIGlzIG5vbi1maW5pdGUuIik7aWYoZi5sZW5ndGg8PTApcmV0dXJue3g6MCx5OjAsYW5nbGU6MH07aWYoaDw9MCl7Y29uc3QgRT1mWzBdWzBdLGw9ZlswXVsxXSxtPU1hdGguYXRhbjIobFsxXS1FWzFdLGxbMF0tRVswXSk7cmV0dXJue3g6RVswXSx5OkVbMV0sYW5nbGU6bX19cmV0dXJuIGcoZixoLCExKS5wb2ludH1mdW5jdGlvbiBjKGYsaCxFKXtsZXQgbD0wLG09aFswXSxwPWY7Y29uc3QgQz1bXSx4PWgubGVuZ3RoO2lmKEU+MCl7ZG8gRS09aFtsJXhdLGwrKzt3aGlsZShFPjApO0U8MCYmKG09LUUsbC0tKX1lbHNlIGlmKEU8MCl7bD0tMTtkbyBFKz1oW2wleCt4LTFdLGwtLTt3aGlsZShFPDApO0U+PTAmJihsKyssbT1oW2wleCt4LTFdLUUpfWRve2NvbnN0IGQ9ZyhwLG0pO3A9ZC5yZXN0LCsrbCUyJiZDLnB1c2goLi4uZC5jdXJyZW50KTtsZXQgeT1sJXg7eTwwJiYoeSs9eCksbT1oW3ldfXdoaWxlKHApO3JldHVybiBDfX0sZnVuY3Rpb24oUixlLHQpe3QucihlKSx0LmQoZSwibm9ybWFsaXplIixmdW5jdGlvbigpe3JldHVybiBpfSksdC5kKGUsImRpc3RhbmNlIixmdW5jdGlvbigpe3JldHVybiBvfSksdCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIGkoW2csdixjXSxmLGgsRSl7cmV0dXJuIGc9ZyoyL2YtMSx2PTEtdioyL2gsTnVtYmVyLmlzRmluaXRlKEUpPyhjPWMqMi9FLTEsW2csdixjXSk6W2csdl19ZnVuY3Rpb24gbyhbZyx2LGM9MF0sW2YsaCxFPTBdKXtyZXR1cm4gTWF0aC5oeXBvdChmLWcsaC12LEUtYyl9fSxmdW5jdGlvbihSLGUsdCl7dC5yKGUpLHQuZChlLCJnZXRQb2ludCIsZnVuY3Rpb24oKXtyZXR1cm4gb30pLHQoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCBpPU1hdGguUEkqMjtmdW5jdGlvbiBvKGcsdixjLGYsaCl7aCU9aSxoPDAmJihoKz1pKTtjb25zdCBFPU1hdGgudGFuKGgpO2lmKE1hdGguYWJzKEUpPDFlNSl7Y29uc3QgbD12LUUqZyxtPTEvYyoqMitFKioyL2YqKjI7bGV0IHA9LTE7KGg8PU1hdGguUEkvMnx8aD4zKk1hdGguUEkvMikmJihwPTEpO2NvbnN0IEM9cCpNYXRoLnNxcnQoMS9tKStnLHg9RSpDK2w7cmV0dXJuW0MseF19cmV0dXJuIGg8TWF0aC5QST9bZyx2K2ZdOltnLHYtZl19fSxmdW5jdGlvbihSLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBWfSk7dmFyIGk9dCgxKSxvPXQoNDIpLGc9dC5uKG8pLHY9dCg1NyksYz10KDI4KSxmPXQoMjQpLGg9dCgzMCksRT10KDU5KSxsPXQoNTMpLG09dCg2MCkscD10Lm4obSksQz10KDQ2KSx4PXQubihDKSxkPXQoMzEpLHk9dCg0MCkscj10KDIxKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gcyhYLEIpe2lmKFg9PW51bGwpcmV0dXJue307dmFyIEc9bihYLEIpLHUsTTtpZihPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKXt2YXIgTj1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKFgpO2ZvcihNPTA7TTxOLmxlbmd0aDtNKyspdT1OW01dLCEoQi5pbmRleE9mKHUpPj0wKSYmT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKFgsdSkmJihHW3VdPVhbdV0pfXJldHVybiBHfWZ1bmN0aW9uIG4oWCxCKXtpZihYPT1udWxsKXJldHVybnt9O3ZhciBHPXt9LHU9T2JqZWN0LmtleXMoWCksTSxOO2ZvcihOPTA7Tjx1Lmxlbmd0aDtOKyspTT11W05dLCEoQi5pbmRleE9mKE0pPj0wKSYmKEdbTV09WFtNXSk7cmV0dXJuIEd9Y29uc3QgYT1TeW1ib2woIm1lc2giKSxPPVN5bWJvbCgiY29udG91cnMiKSxBPVN5bWJvbCgic3Ryb2tlIiksYj1TeW1ib2woImZpbGwiKSxJPVN5bWJvbCgic3Ryb2tlQ29sb3IiKSxQPVN5bWJvbCgiZmlsbENvbG9yIiksRD1TeW1ib2woInRyYW5zZm9ybSIpLEw9U3ltYm9sKCJpbnZlcnRUcmFuc2Zvcm0iKSxTPVN5bWJvbCgidW5pZm9ybXMiKSxUPVN5bWJvbCgidGV4T3B0aW9ucyIpLGo9U3ltYm9sKCJibGVuZCIpLCQ9U3ltYm9sKCJhcHBseVRleHR1cmUiKSx3PVN5bWJvbCgiYXBwbHlUcmFuc2Zvcm0iKSxKPVN5bWJvbCgiYXBwbHlHcmFkaWVudFRyYW5zZm9ybSIpLHE9U3ltYm9sKCJhcHBseVByb2dyYW0iKSxXPVN5bWJvbCgiZ3JhZGllbnQiKSxLPVN5bWJvbCgiZmlsdGVyIiksUT1TeW1ib2woIm9wYWNpdHkiKSx0dD1TeW1ib2woInByb2dyYW0iKSxfPVN5bWJvbCgiYXR0cmlidXRlcyIpLHN0PVN5bWJvbCgicGFzcyIpLGs9U3ltYm9sKCJjbGlwQ29udGV4dCIpLGN0PVN5bWJvbCgiYXBwbHlDbGlwUGF0aCIpO2Z1bmN0aW9uIGZ0KFgsQil7Y29uc3RbRyx1XT1bWFsxXVswXS1YWzBdWzBdLFhbMV1bMV0tWFswXVsxXV0sTT1bXTtmb3IobGV0IE49MDtOPEIubGVuZ3RoO04rKyl7Y29uc3Qgej1CW05dLEg9Wyh6WzBdLVhbMF1bMF0pL0csMS0oelsxXS1YWzBdWzFdKS91XTtNLnB1c2goSCl9cmV0dXJuIE19ZnVuY3Rpb24gVShbWCxCXSxbRyx1LE0sTl0se3NjYWxlOnp9KXtyZXR1cm4genx8KFgvPU0sQj0xLUIvTixYLT1HLEIrPXUpLFtYLEIsMF19ZnVuY3Rpb24gRihYLEIsRyl7Y29uc3QgdT14KCkoWCxCLEcpO3JldHVybiB1LnBhdGg9WCx1LnNpbXBsaWZ5PUcsdS5zY2FsZT1CLHV9Y2xhc3MgVntjb25zdHJ1Y3RvcihCKXt0aGlzW0FdPW51bGwsdGhpc1tiXT1udWxsLHRoaXNbRF09WzEsMCwwLDEsMCwwXSx0aGlzW1FdPTEsdGhpc1tTXT17fSx0aGlzW0tdPVtdLHRoaXNbal09bnVsbCx0aGlzW1RdPXt9LHRoaXMuY29udG91cnM9Qi5jb250b3Vycyx0aGlzW3R0XT1udWxsLHRoaXNbX109e30sdGhpc1tzdF09W119Z2V0IGNvbnRvdXJzKCl7cmV0dXJuIHRoaXNbT119c2V0IGNvbnRvdXJzKEIpe3RoaXNbYV09bnVsbCx0aGlzW09dPUI7Y29uc3QgRz1CLnNjYWxlO3RoaXMudHJhbnNmb3JtU2NhbGUvRz4xLjUmJnRoaXMuYWNjdXJhdGUodGhpcy50cmFuc2Zvcm1TY2FsZSl9c2V0UHJvZ3JhbShCKXt0aGlzW3R0XT1CLHRoaXNbYV0mJnRoaXNbcV0oQil9Z2V0IHByb2dyYW0oKXtyZXR1cm4gdGhpc1t0dF19c2V0QXR0cmlidXRlKEIsRyl7Rz09bnVsbD9kZWxldGUgdGhpc1tfXVtCXTp0aGlzW19dW0JdPUd9Z2V0T3BhY2l0eSgpe3JldHVybiB0aGlzW1FdfXNldE9wYWNpdHkoQil7aWYoQjwwfHxCPjEpdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCBvcGFjaXR5IHZhbHVlLiIpO3RoaXNbYV0mJnRoaXNbYV0ucG9zaXRpb25zLmZvckVhY2goRz0+e0dbMl09MS9HWzJdPjA/QjotQn0pLHRoaXNbUV09Qn1zZXRDbGlwUGF0aChCKXt0aGlzLmNsaXBQYXRoPUIsdGhpc1tTXS51X2NsaXBTYW1wbGVyJiZ0aGlzW1NdLnVfY2xpcFNhbXBsZXIuZGVsZXRlKCksdGhpcy5zZXRVbmlmb3Jtcyh7dV9jbGlwU2FtcGxlcjpudWxsfSksdGhpc1thXSYmZGVsZXRlIHRoaXNbYV0uYXR0cmlidXRlcy5hX2NsaXBVVixCJiZ0aGlzW2FdJiZ0aGlzW2N0XSgpfVtjdF0oKXtpZih0aGlzLmNsaXBQYXRoKXt0aGlzW2tdfHwodGhpc1trXT1yLmRlZmF1bHQuY3JlYXRlQ2FudmFzKDEsMSkpO2NvbnN0W1tCLEddLFt1LE1dXT10aGlzLmJvdW5kaW5nQm94O3UmJk0mJih0aGlzW2tdLndpZHRoPXUtQix0aGlzW2tdLmhlaWdodD1NLUcpO2NvbnN0IE49dGhpc1trXS5nZXRDb250ZXh0KCIyZCIpLHo9bmV3IFBhdGgyRCh0aGlzLmNsaXBQYXRoKTtOLmNsZWFyUmVjdCgwLDAsdGhpc1trXS53aWR0aCx0aGlzW2tdLmhlaWdodCksTi5zYXZlKCksTi50cmFuc2xhdGUoLUIsLUcpLE4uZmlsbFN0eWxlPSJ3aGl0ZSIsTi5maWxsKHopLE4ucmVzdG9yZSgpLHRoaXNbYV0uY2xpcFBhdGg9dGhpc1trXTtjb25zdCBIPWZ0KHRoaXMuYm91bmRpbmdCb3gsdGhpc1thXS5wb3NpdGlvbjApO3RoaXNbYV0uYXR0cmlidXRlcy5hX2NsaXBVVj1IfX1nZXRQb2ludEF0TGVuZ3RoKEIpe3JldHVybiBPYmplY3QobC5nZXRQb2ludEF0TGVuZ3RoKSh0aGlzW09dLEIpfWdldFRvdGFsTGVuZ3RoKCl7cmV0dXJuIE9iamVjdChsLmdldFRvdGFsTGVuZ3RoKSh0aGlzW09dKX1nZXQgYmxlbmQoKXtyZXR1cm4gdGhpc1tqXT09bnVsbD8iYXV0byI6dGhpc1tqXX1zZXQgYmxlbmQoQil7dGhpc1tqXT1CLHRoaXNbYV0mJih0aGlzW2FdLmVuYWJsZUJsZW5kPXRoaXMuZW5hYmxlQmxlbmQpfWdldCBib3VuZGluZ0JveCgpe2lmKHRoaXNbYV0mJnRoaXNbYV0uYm91bmRpbmdCb3gpcmV0dXJuIHRoaXNbYV0uYm91bmRpbmdCb3g7Y29uc3QgQj10aGlzLm1lc2hEYXRhO2lmKEIpe2NvbnN0IEc9Qi5wb3NpdGlvbjA7aWYoRy5sZW5ndGgpQi5ib3VuZGluZ0JveD1nKCkoRyk7ZWxzZSByZXR1cm5bWzAsMF0sWzAsMF1dO3JldHVybiBCLmJvdW5kaW5nQm94fXJldHVybltbMCwwXSxbMCwwXV19Z2V0IGJvdW5kaW5nQ2VudGVyKCl7Y29uc3QgQj10aGlzLmJvdW5kaW5nQm94O3JldHVybiBCP1suNSooQlswXVswXStCWzFdWzBdKSwuNSooQlswXVsxXStCWzFdWzFdKV06WzAsMF19Z2V0IGZpbGxSdWxlKCl7cmV0dXJuIHRoaXNbYl0/dGhpc1tiXS5ydWxlOiJub256ZXJvIn1nZXQgbGluZVdpZHRoKCl7cmV0dXJuIHRoaXNbQV0/dGhpc1tBXS5saW5lV2lkdGg6MH1nZXQgbGluZUNhcCgpe3JldHVybiB0aGlzW0FdP3RoaXNbQV0ubGluZUNhcDoiIn1nZXQgbGluZUpvaW4oKXtyZXR1cm4gdGhpc1tBXT90aGlzW0FdLmxpbmVKb2luOiIifWdldCBtaXRlckxpbWl0KCl7cmV0dXJuIHRoaXNbQV0/dGhpc1tBXS5taXRlckxpbWl0OjB9Z2V0IHN0cm9rZVN0eWxlKCl7cmV0dXJuIHRoaXNbSV0mJnRoaXNbSV1bM10hPT0wP09iamVjdChmLmRlZmF1bHQpKHRoaXNbSV0pOiIifWdldCBsaW5lRGFzaCgpe3JldHVybiB0aGlzW0FdP3RoaXNbQV0ubGluZURhc2g6bnVsbH1nZXQgbGluZURhc2hPZmZzZXQoKXtyZXR1cm4gdGhpc1tBXT90aGlzW0FdLmxpbmVEYXNoT2Zmc2V0OjB9Z2V0IGZpbGxTdHlsZSgpe3JldHVybiB0aGlzW1BdJiZ0aGlzW1BdWzNdIT09MD9PYmplY3QoZi5kZWZhdWx0KSh0aGlzW1BdKToiIn1nZXQgZ3JhZGllbnQoKXtyZXR1cm4gdGhpc1tXXX1nZXQgdGV4dHVyZSgpe3JldHVybiB0aGlzW1NdLnVfdGV4U2FtcGxlcj97aW1hZ2U6dGhpc1tTXS51X3RleFNhbXBsZXIuX2ltZyxvcHRpb25zOnRoaXNbVF19Om51bGx9Z2V0IGVuYWJsZUJsZW5kKCl7cmV0dXJuIHRoaXNbal09PT0hMHx8dGhpc1tqXT09PSExP3RoaXNbal06dGhpc1tRXTwxfHx0aGlzW0ldIT1udWxsJiZ0aGlzW0ldWzNdPDF8fHRoaXNbUF0hPW51bGwmJnRoaXNbUF1bM108MXx8dGhpc1tTXS51X2NvbG9yTWF0cml4IT1udWxsJiZ0aGlzW1NdLnVfY29sb3JNYXRyaXhbMThdPDF8fHRoaXNbU10udV9yYWRpYWxHcmFkaWVudFZlY3RvciE9bnVsbHx8dGhpcy5iZWZvcmVSZW5kZXJ8fHRoaXMuYWZ0ZXJSZW5kZXJ9Z2V0IGZpbHRlckNhbnZhcygpe3JldHVybi9ibHVyfGRyb3Atc2hhZG93fHVybC8udGVzdCh0aGlzLmZpbHRlcil9Z2V0IGZpbHRlcigpe3JldHVybiB0aGlzW0tdLmpvaW4oIiAiKX1nZXQgdHJhbnNmb3JtTWF0cml4KCl7cmV0dXJuIHRoaXNbRF19Z2V0IGludmVydE1hdHJpeCgpe2lmKCF0aGlzW0xdKXtjb25zdCBCPWkubWF0MmQuaW52ZXJ0KEFycmF5Lm9mKDAsMCwwLDAsMCwwKSx0aGlzW0RdKTt0aGlzW0xdPUJ9cmV0dXJuIHRoaXNbTF19Z2V0IHRyYW5zZm9ybVNjYWxlKCl7Y29uc3QgQj10aGlzW0RdO3JldHVybiBNYXRoLm1heChNYXRoLmh5cG90KEJbMF0sQlsxXSksTWF0aC5oeXBvdChCWzJdLEJbM10pKX1nZXQgdW5pZm9ybXMoKXtyZXR1cm4gdGhpc1tTXX1nZXQgcGFzcygpe3JldHVybiB0aGlzW3N0XX1bcV0oQil7Y29uc3QgRz10aGlzW19dLHU9dGhpc1thXS5wb3NpdGlvbjAsTT1PYmplY3QuZW50cmllcyhCLl9hdHRyaWJ1dGUpO2ZvcihsZXQgTj0wO048TS5sZW5ndGg7TisrKXtjb25zdFt6LEhdPU1bTl07aWYoeiE9PSJhX2NvbG9yIiYmeiE9PSJhX3NvdXJjZVJlY3QiJiZIIT09Imlnbm9yZWQiKXtjb25zdCBZPUdbel07aWYoej09PSJ1diImJiFZKXtjb25zdCBaPXRoaXNbYV0uYm91bmRpbmdCb3h8fGcoKSh1KTt0aGlzW2FdLmF0dHJpYnV0ZXNbel09ZnQoWix1KX1lbHNle3RoaXNbYV0uYXR0cmlidXRlc1t6XT1bXTtmb3IobGV0IFo9MDtaPHUubGVuZ3RoO1orKyl7Y29uc3QgZXQ9dVtaXTt0aGlzW2FdLmF0dHJpYnV0ZXNbel0ucHVzaChZP1koZXQsTix1KTpBcnJheShILnNpemUpLmZpbGwoMCkpfX19fX1nZXQgbWVzaERhdGEoKXtpZih0aGlzLl91cGRhdGVNYXRyaXgmJnRoaXMudHJhbnNmb3JtU2NhbGUvdGhpcy5jb250b3Vycy5zY2FsZT4xLjUmJnRoaXMuYWNjdXJhdGUodGhpcy50cmFuc2Zvcm1TY2FsZSksIXRoaXNbYV0peyF0aGlzW2JdJiYhdGhpc1tBXSYmdGhpcy5zZXRGaWxsKCk7Y29uc3QgQj10aGlzW09dLEc9e307aWYoQiYmQi5sZW5ndGgpe2lmKHRoaXNbYl0pdHJ5e2NvbnN0IE49cCgpKEIsdGhpc1tiXSk7Ti5wb3NpdGlvbnM9Ti5wb3NpdGlvbnMubWFwKHo9Pih6LnB1c2godGhpc1tRXSkseikpLE4uYXR0cmlidXRlcz17YV9jb2xvcjpBcnJheS5mcm9tKHtsZW5ndGg6Ti5wb3NpdGlvbnMubGVuZ3RofSkubWFwKCgpPT50aGlzW1BdLm1hcCh6PT5NYXRoLnJvdW5kKDI1NSp6KSkpfSxHLmZpbGw9Tn1jYXRjaHt9aWYodGhpc1tBXSl7Y29uc3QgTj10aGlzW0FdLmxpbmVEYXNoO2xldCB6PUI7aWYoTil7Y29uc3QgWT10aGlzW0FdLmxpbmVEYXNoT2Zmc2V0O3o9T2JqZWN0KGwuZ2V0RGFzaENvbnRvdXJzKShCLE4sWSl9Y29uc3QgSD16Lm1hcCgoWSxaKT0+e2NvbnN0IGV0PVkubGVuZ3RoPjEmJmkudmVjMi5lcXVhbHMoWVswXSxZW1kubGVuZ3RoLTFdKSxydD10aGlzW0FdLmJ1aWxkKFksZXQpO3JldHVybiBwKCkoW3J0XSl9KTtILmZvckVhY2goWT0+e1kucG9zaXRpb25zPVkucG9zaXRpb25zLm1hcChaPT4oWi5wdXNoKC10aGlzW1FdKSxaKSksWS5hdHRyaWJ1dGVzPXthX2NvbG9yOkFycmF5LmZyb20oe2xlbmd0aDpZLnBvc2l0aW9ucy5sZW5ndGh9KS5tYXAoKCk9PnRoaXNbSV0ubWFwKFo9Pk1hdGgucm91bmQoMjU1KlopKSl9fSksRy5zdHJva2U9T2JqZWN0KGMuZGVmYXVsdCkoSCl9fWNvbnN0IHU9T2JqZWN0KGMuZGVmYXVsdCkoW0cuZmlsbCxHLnN0cm9rZV0pO3UuZmlsbFBvaW50Q291bnQ9Ry5maWxsP0cuZmlsbC5wb3NpdGlvbnMubGVuZ3RoOjAsdS5lbmFibGVCbGVuZD10aGlzLmVuYWJsZUJsZW5kLHUucG9zaXRpb24wPXUucG9zaXRpb25zLm1hcCgoW04seixIXSk9PltOLHosSF0pLHUudW5pZm9ybXM9dGhpc1tTXSx0aGlzW2FdPXUsdGhpc1tTXS51X3RleFNhbXBsZXImJnRoaXNbJF0odSx0aGlzW1RdKTtjb25zdCBNPXRoaXNbRF07T2JqZWN0KEUuaXNVbml0VHJhbnNmb3JtKShNKXx8KHRoaXNbd10odSxNKSx0aGlzW1NdLnVfcmFkaWFsR3JhZGllbnRWZWN0b3ImJnRoaXNbSl0oKSksdGhpcy5jbGlwUGF0aCYmdGhpc1tjdF0oKSx0aGlzW3R0XSYmdGhpc1txXSh0aGlzW3R0XSl9cmV0dXJuIHRoaXMuX3VwZGF0ZU1hdHJpeCYmKHRoaXNbYV0ubWF0cml4PXRoaXNbRF0sdGhpc1t3XSh0aGlzW2FdLHRoaXNbRF0pLHRoaXNbU10udV9yYWRpYWxHcmFkaWVudFZlY3RvciYmdGhpc1tKXSgpKSx0aGlzW2FdfVt3XShCLEcpe2NvbnN0e3Bvc2l0aW9uczp1LHBvc2l0aW9uMDpNfT1CO2ZvcihsZXQgTj0wO048dS5sZW5ndGg7TisrKXtjb25zdFt6LEhdPU1bTl0sWT11W05dO1lbMF09eipHWzBdK0gqR1syXStHWzRdLFlbMV09eipHWzFdK0gqR1szXStHWzVdfXRoaXMuX3VwZGF0ZU1hdHJpeD0hMX1bSl0oKXtjb25zdCBCPXRoaXNbRF0sRz1bLi4udGhpcy5fcmFkaWFsR3JhZGllbnRWZWN0b3JdO2lmKEcpe2NvbnN0W3UsTSwsTix6XT1HO0dbMF09dSpCWzBdK00qQlsyXStCWzRdLEdbMV09dSpCWzFdK00qQlszXStCWzVdLEdbM109TipCWzBdK3oqQlsyXStCWzRdLEdbNF09TipCWzFdK3oqQlszXStCWzVdLHRoaXNbU10udV9yYWRpYWxHcmFkaWVudFZlY3Rvcj1HfX1bJF0oQixHKXtmdW5jdGlvbiB1KFosZXQpe3JldHVybiBaPT1udWxsJiZldD09bnVsbD8hMDpaPT1udWxsfHxldD09bnVsbD8hMTpaWzBdPT09ZXRbMF0mJlpbMV09PT1ldFsxXSYmWlsyXT09PWV0WzJdJiZaWzNdPT09ZXRbM119Y29uc3QgTT10aGlzW1NdLnVfdGV4U2FtcGxlcjtpZighTSlyZXR1cm47Y29uc3R7d2lkdGg6TixoZWlnaHQ6en09TS5faW1nLEg9Ry5zcmNSZWN0O2xldCBZPUcucmVjdHx8WzAsMF07aWYoRy5yb3RhdGVkJiYoWT1bLVlbMV0sWVswXSxZWzNdLFlbMl1dKSxZWzJdPT1udWxsJiYoWVsyXT1IP0hbMl06TiksWVszXT09bnVsbCYmKFlbM109SD9IWzNdOnopLEcuaGlkZGVuKUIudGV4dHVyZUNvb3JkPUIucG9zaXRpb25zLm1hcCgoKT0+Wy0xLC0xLC0xXSk7ZWxzZSBpZighQi50ZXh0dXJlQ29vcmR8fCF1KHRoaXNbVF0ucmVjdCxHLnJlY3QpfHx0aGlzW1RdLmhpZGRlbiE9PUcuaGlkZGVufHx0aGlzW1RdLnJvdGF0ZWQhPT1HLnJvdGF0ZWQpe2xldCBaPW51bGw7Ry5yb3RhdGVkJiYoWj1pLm1hdDJkLnJvdGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCksaS5tYXQyZC5mcm9tVmFsdWVzKDEsMCwwLDEsMCwwKSwuNSpNYXRoLlBJKSxaPWkubWF0MmQudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxaLFswLC1ZWzJdXSkpLEIudGV4dHVyZUNvb3JkPUIucG9zaXRpb24wLm1hcCgoW2V0LHJ0LG90XSk9PntpZigxL290PjApe2lmKEcucm90YXRlZCl7Y29uc3QgaXQ9ZXQqWlswXStydCpaWzJdK1pbNF0sbnQ9ZXQqWlsxXStydCpaWzNdK1pbNV07W2V0LHJ0XT1baXQsbnRdfWNvbnN0IGx0PVUoW2V0LHJ0XSxbWVswXS9ZWzJdLFlbMV0vWVszXSxZWzJdLFlbM11dLEcpO3JldHVybiBHLnJlcGVhdCYmKGx0WzJdPTEpLGx0fXJldHVyblstMSwtMSwtMV19KX1pZihIKXtjb25zdCBaPVtIWzBdL04sSFsxXS96LEhbMl0vTixIWzNdL3pdO0IuYXR0cmlidXRlcy5hX3NvdXJjZVJlY3Q9Qi5wb3NpdGlvbnMubWFwKCgpPT5bLi4uWl0pfWVsc2UgQi5hdHRyaWJ1dGVzLmFfc291cmNlUmVjdD1CLnBvc2l0aW9ucy5tYXAoKCk9PlswLDAsMCwwXSl9YWNjdXJhdGUoQil7aWYoIXRoaXMuY29udG91cnMpcmV0dXJuO2lmKHRoaXMuY29udG91cnMucGF0aCl7Y29uc3QgdT10aGlzLmNvbnRvdXJzLnNpbXBsaWZ5LE09Rih0aGlzLmNvbnRvdXJzLnBhdGgsMipCLHUpO3RoaXNbYV09bnVsbCx0aGlzW09dPU19fWNhbklnbm9yZSgpe2NvbnN0IEI9dGhpc1tBXT09bnVsbHx8dGhpc1tBXS5saW5lV2lkdGg9PT0wfHx0aGlzW0ldWzNdPT09MCxHPXRoaXNbYl09PW51bGx8fHRoaXNbUF1bM109PT0wLHU9dGhpc1tTXS51X3JhZGlhbEdyYWRpZW50VmVjdG9yPT1udWxsLE09dGhpc1tTXS51X3RleFNhbXBsZXI9PW51bGw7cmV0dXJuIHRoaXNbUV09PT0wfHx0aGlzW3R0XT09bnVsbCYmQiYmRyYmdSYmTSYmIXRoaXMuYmVmb3JlUmVuZGVyJiYhdGhpcy5hZnRlclJlbmRlcn1zZXRTdHJva2Uoe3RoaWNrbmVzczpCPTEsY2FwOkc9ImJ1dHQiLGpvaW46dT0ibWl0ZXIiLG1pdGVyTGltaXQ6TT0xMCxjb2xvcjpOPVswLDAsMCwwXSxsaW5lRGFzaDp6PW51bGwsbGluZURhc2hPZmZzZXQ6SD0wLHJvdW5kU2VnbWVudHM6WT0yMH09e30pe3JldHVybiB0aGlzW2FdPW51bGwsdGhpc1tBXT1uZXcgdi5kZWZhdWx0KHtsaW5lV2lkdGg6QixsaW5lQ2FwOkcsbGluZUpvaW46dSxtaXRlckxpbWl0Ok0scm91bmRTZWdtZW50czpZfSksdHlwZW9mIE49PSJzdHJpbmciJiYoTj1PYmplY3QoZC5kZWZhdWx0KShOKSksdGhpc1tJXT1OLHRoaXNbQV0ubGluZURhc2g9eix0aGlzW0FdLmxpbmVEYXNoT2Zmc2V0PUgsdGhpc31zZXRGaWxsKHtydWxlOkI9dGhpcy5maWxsUnVsZSxjb2xvcjpHPVswLDAsMCwwXX09e30pe3JldHVybiB0aGlzW2FdPW51bGwsdGhpc1tiXT17cnVsZTpCfSx0eXBlb2YgRz09InN0cmluZyImJihHPU9iamVjdChkLmRlZmF1bHQpKEcpKSx0aGlzW1BdPUcsdGhpc31zZXRUZXh0dXJlKEIsRz17fSl7aWYoQiYmQi5pbWFnZSl7Y29uc3R7aW1hZ2U6dSxyZWN0Ok19PUI7aWYoQj11LEcucmVjdClmb3IobGV0IE49MDtOPEcucmVjdC5sZW5ndGg7TisrKU1bTl09Ry5yZWN0W05dO0cucmVjdD1NfXJldHVybiB0aGlzW2JdfHx0aGlzLnNldEZpbGwoKSx0aGlzLnNldFVuaWZvcm1zKHt1X3RleFNhbXBsZXI6Qn0pLHRoaXNbYV0mJnRoaXNbJF0odGhpc1thXSxHKSx0aGlzW1RdPUcsdGhpc31zZXRDaXJjdWxhckdyYWRpZW50KHt2ZWN0b3I6Qixjb2xvcnM6Ryx0eXBlOnU9ImZpbGwifT17fSl7aWYoQi5sZW5ndGghPT0zKXRocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgbGluZWFyR3JhZGllbnQuIik7dGhpcy5zZXRHcmFkaWVudCh7dmVjdG9yOkIsY29sb3JzOkcsdHlwZTp1fSl9c2V0TGluZWFyR3JhZGllbnQoe3ZlY3RvcjpCLGNvbG9yczpHLHR5cGU6dT0iZmlsbCJ9PXt9KXtpZihCLmxlbmd0aCE9PTQpdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCBsaW5lYXJHcmFkaWVudC4iKTt0aGlzLnNldEdyYWRpZW50KHt2ZWN0b3I6Qixjb2xvcnM6Ryx0eXBlOnV9KX1zZXRSYWRpYWxHcmFkaWVudCh7dmVjdG9yOkIsY29sb3JzOkcsdHlwZTp1PSJmaWxsIn09e30pe2lmKEIubGVuZ3RoIT09Nil0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIHJhZGlhbEdyYWRpZW50LiIpO3RoaXMuc2V0R3JhZGllbnQoe3ZlY3RvcjpCLGNvbG9yczpHLHR5cGU6dX0pfXNldEdyYWRpZW50KHt2ZWN0b3I6Qixjb2xvcnM6Ryx0eXBlOnU9ImZpbGwifT17fSl7Rz1HLm1hcCgoe29mZnNldDp6LGNvbG9yOkh9KT0+KHR5cGVvZiBIPT0ic3RyaW5nIiYmKEg9T2JqZWN0KGQuZGVmYXVsdCkoSCkpLHtvZmZzZXQ6eixjb2xvcjpIfSkpLHRoaXNbV109dGhpc1tXXXx8e30sdGhpc1tXXVt1XT17dmVjdG9yOkIsY29sb3JzOkd9LEcuc29ydCgoeixIKT0+ei5vZmZzZXQtSC5vZmZzZXQpO2NvbnN0IE09W107Ry5mb3JFYWNoKCh7b2Zmc2V0OnosY29sb3I6SH0pPT57TS5wdXNoKHosLi4uSCl9KTtsZXQgTjtpZihCLmxlbmd0aD09PTQ/Tj1bQlswXSxCWzFdLDAsQlsyXSxCWzNdLDBdOk49Wy4uLkJdLE0ubGVuZ3RoPDQwJiZNLnB1c2goLTEpLE0ubGVuZ3RoPjQwKXRocm93IG5ldyBFcnJvcigiVG9vIG1hbnkgY29sb3JzLCBzaG91bGQgYmUgbGVzcyB0aGFuIDggY29sb3JzIik7cmV0dXJuIHRoaXMuX3JhZGlhbEdyYWRpZW50VmVjdG9yPU4sdGhpc1tTXS51X2NvbG9yU3RlcHM9TSx1PT09ImZpbGwiP3RoaXNbU10udV9ncmFkaWVudFR5cGU9MTp0aGlzW1NdLnVfZ3JhZGllbnRUeXBlPTAsdGhpc1tKXSgpLHRoaXN9c2V0VW5pZm9ybXMoQj17fSl7cmV0dXJuIE9iamVjdC5hc3NpZ24odGhpc1tTXSxCKSx0aGlzfXNldFRyYW5zZm9ybSguLi5CKXtjb25zdCBHPXRoaXNbRF07cmV0dXJuIGkubWF0MmQuZXF1YWxzKEIsRyl8fCh0aGlzW0RdPUIsZGVsZXRlIHRoaXNbTF0sdGhpcy5fdXBkYXRlTWF0cml4PSEwKSx0aGlzfXRyYW5zZm9ybSguLi5CKXtjb25zdCBHPXRoaXNbRF07cmV0dXJuIHRoaXNbRF09aS5tYXQyZC5tdWx0aXBseShBcnJheS5vZigwLDAsMCwwLDAsMCksRyxCKSxkZWxldGUgdGhpc1tMXSx0aGlzLl91cGRhdGVNYXRyaXg9ITAsdGhpc310cmFuc2xhdGUoQixHKXtsZXQgdT1pLm1hdDJkLmNyZWF0ZSgpO3JldHVybiB1PWkubWF0MmQudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwKSx1LFtCLEddKSx0aGlzLnRyYW5zZm9ybSguLi51KX1yb3RhdGUoQixbRyx1XT1bMCwwXSl7bGV0IE09aS5tYXQyZC5jcmVhdGUoKTtyZXR1cm4gTT1pLm1hdDJkLnRyYW5zbGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCksTSxbRyx1XSksTT1pLm1hdDJkLnJvdGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCksTSxCKSxNPWkubWF0MmQudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxNLFstRywtdV0pLHRoaXMudHJhbnNmb3JtKC4uLk0pfXNjYWxlKEIsRz1CLFt1LE1dPVswLDBdKXtsZXQgTj1pLm1hdDJkLmNyZWF0ZSgpO3JldHVybiBOPWkubWF0MmQudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxOLFt1LE1dKSxOPWkubWF0MmQuc2NhbGUoQXJyYXkub2YoMCwwLDAsMCwwLDApLE4sW0IsR10pLE49aS5tYXQyZC50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDApLE4sWy11LC1NXSksdGhpcy50cmFuc2Zvcm0oLi4uTil9c2tldyhCLEc9QixbdSxNXT1bMCwwXSl7bGV0IE49aS5tYXQyZC5jcmVhdGUoKTtyZXR1cm4gTj1pLm1hdDJkLnRyYW5zbGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCksTixbdSxNXSksTj1pLm1hdDJkLm11bHRpcGx5KEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxOLGkubWF0MmQuZnJvbVZhbHVlcygxLE1hdGgudGFuKEcpLE1hdGgudGFuKEIpLDEsMCwwKSksTj1pLm1hdDJkLnRyYW5zbGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCksTixbLXUsLU1dKSx0aGlzLnRyYW5zZm9ybSguLi5OKX1jbGVhckZpbHRlcigpe3JldHVybiB0aGlzLnNldENvbG9yVHJhbnNmb3JtKG51bGwpLHRoaXNbS10ubGVuZ3RoPTAsdGhpc31zZXRDb2xvclRyYW5zZm9ybSguLi5CKXtyZXR1cm4gQlswXT09PW51bGw/dGhpcy5zZXRVbmlmb3Jtcyh7dV9maWx0ZXJGbGFnOjAsdV9jb2xvck1hdHJpeDowfSk6dGhpcy5zZXRVbmlmb3Jtcyh7dV9maWx0ZXJGbGFnOjEsdV9jb2xvck1hdHJpeDpCfSksdGhpc310cmFuc2Zvcm1Db2xvciguLi5CKXtsZXQgRz10aGlzLnVuaWZvcm1zLnVfY29sb3JNYXRyaXg7cmV0dXJuIEc/Rz1PYmplY3QoaC5tdWx0aXBseSkoRyxCKTpHPUIsdGhpcy5zZXRDb2xvclRyYW5zZm9ybSguLi5HKSx0aGlzfWJsdXIoQil7cmV0dXJuIHRoaXNbS10ucHVzaChgYmx1cigke0J9cHgpYCksdGhpc31icmlnaHRuZXNzKEI9MSl7cmV0dXJuIHRoaXNbS10ucHVzaChgYnJpZ2h0bmVzcygkezEwMCpCfSUpYCksdGhpcy50cmFuc2Zvcm1Db2xvciguLi5PYmplY3QoaC5icmlnaHRuZXNzKShCKSl9Y29udHJhc3QoQj0xKXtyZXR1cm4gdGhpc1tLXS5wdXNoKGBjb250cmFzdCgkezEwMCpCfSUpYCksdGhpcy50cmFuc2Zvcm1Db2xvciguLi5PYmplY3QoaC5jb250cmFzdCkoQikpfWRyb3BTaGFkb3coQixHLHU9MCxNPVswLDAsMCwxXSl7cmV0dXJuIEFycmF5LmlzQXJyYXkoTSkmJihNPU9iamVjdChmLmRlZmF1bHQpKE0pKSx0aGlzW0tdLnB1c2goYGRyb3Atc2hhZG93KCR7Qn1weCAke0d9cHggJHt1fXB4ICR7TX0pYCksdGhpc31ncmF5c2NhbGUoQj0xKXtyZXR1cm4gdGhpc1tLXS5wdXNoKGBncmF5c2NhbGUoJHsxMDAqQn0lKWApLHRoaXMudHJhbnNmb3JtQ29sb3IoLi4uT2JqZWN0KGguZ3JheXNjYWxlKShCKSl9aHVlUm90YXRlKEI9MCl7cmV0dXJuIHRoaXNbS10ucHVzaChgaHVlLXJvdGF0ZSgke0J9ZGVnKWApLHRoaXMudHJhbnNmb3JtQ29sb3IoLi4uT2JqZWN0KGguaHVlUm90YXRlKShCKSl9aW52ZXJ0KEI9MSl7cmV0dXJuIHRoaXNbS10ucHVzaChgaW52ZXJ0KCR7MTAwKkJ9JSlgKSx0aGlzLnRyYW5zZm9ybUNvbG9yKC4uLk9iamVjdChoLmludmVydCkoQikpfW9wYWNpdHkoQj0xKXtyZXR1cm4gdGhpc1tLXS5wdXNoKGBvcGFjaXR5KCR7MTAwKkJ9JSlgKSx0aGlzLnRyYW5zZm9ybUNvbG9yKC4uLk9iamVjdChoLm9wYWNpdHkpKEIpKX1zYXR1cmF0ZShCPTEpe3JldHVybiB0aGlzW0tdLnB1c2goYHNhdHVyYXRlKCR7MTAwKkJ9JSlgKSx0aGlzLnRyYW5zZm9ybUNvbG9yKC4uLk9iamVjdChoLnNhdHVyYXRlKShCKSl9c2VwaWEoQj0xKXtyZXR1cm4gdGhpc1tLXS5wdXNoKGBzZXBpYSgkezEwMCpCfSUpYCksdGhpcy50cmFuc2Zvcm1Db2xvciguLi5PYmplY3QoaC5zZXBpYSkoQikpfXVybChCKXtyZXR1cm4gdGhpc1tLXS5wdXNoKGB1cmwoJHtCfSlgKSx0aGlzfWlzUG9pbnRDb2xsaXNpb24oQixHLHU9ImJvdGgiKXtjb25zdCBNPXRoaXMubWVzaERhdGEse3Bvc2l0aW9uczpOLGNlbGxzOnp9PU0sSD10aGlzLmludmVydE1hdHJpeCxZPUhbMF0qQitIWzJdKkcrSFs0XSxaPUhbMV0qQitIWzNdKkcrSFs1XSxldD10aGlzLmJvdW5kaW5nQm94O2lmKFk8ZXRbMF1bMF18fFk+ZXRbMV1bMF18fFo8ZXRbMF1bMV18fFo+ZXRbMV1bMV0pcmV0dXJuITE7ZnVuY3Rpb24gcnQoW290LGx0XSxbaXQsbnRdLFthdCxkdF0pe2NvbnN0IGd0PWF0LWl0LHV0PWR0LW50LG10PSgob3QtaXQpKmd0KyhsdC1udCkqdXQpLyhndCoqMit1dCoqMik7cmV0dXJuIG10Pj0wJiZtdDw9MX1mb3IobGV0IG90PTA7b3Q8ei5sZW5ndGg7b3QrKyl7Y29uc3QgbHQ9eltvdF07aWYodT09PSJmaWxsIiYmbHRbMF0+PU0uZmlsbFBvaW50Q291bnQpYnJlYWs7aWYodT09PSJzdHJva2UiJiZsdFswXTxNLmZpbGxQb2ludENvdW50KWNvbnRpbnVlO2NvbnN0W1tpdCxudF0sW2F0LGR0XSxbZ3QsdXRdXT1sdC5tYXAocHQ9Pk5bcHRdKSxtdD1NYXRoLnNpZ24oKEItaXQpKihkdC1udCktKGF0LWl0KSooRy1udCkpO2lmKG10PT09MCYmcnQoW0IsR10sW2l0LG50XSxbYXQsZHRdKSlyZXR1cm4hMDtjb25zdCBFdD1NYXRoLnNpZ24oKEItYXQpKih1dC1kdCktKGd0LWF0KSooRy1kdCkpO2lmKEV0PT09MCYmcnQoW0IsR10sW2F0LGR0XSxbZ3QsdXRdKSlyZXR1cm4hMDtjb25zdCB5dD1NYXRoLnNpZ24oKEItZ3QpKihudC11dCktKGl0LWd0KSooRy11dCkpO2lmKHl0PT09MCYmcnQoW0IsR10sW2d0LHV0XSxbaXQsbnRdKXx8bXQ9PT0xJiZFdD09PTEmJnl0PT09MXx8bXQ9PT0tMSYmRXQ9PT0tMSYmeXQ9PT0tMSlyZXR1cm4hMH1yZXR1cm4hMX1pc1BvaW50SW5GaWxsKEIsRyl7cmV0dXJuIHRoaXMuaXNQb2ludENvbGxpc2lvbihCLEcsImZpbGwiKX1pc1BvaW50SW5TdHJva2UoQixHKXtyZXR1cm4gdGhpcy5pc1BvaW50Q29sbGlzaW9uKEIsRywic3Ryb2tlIil9YWRkUGFzcyhCLEc9e30pe2xldHt3aWR0aDp1LGhlaWdodDpNfT1HLE49cyhHLFsid2lkdGgiLCJoZWlnaHQiXSk7Y29uc3Qgej1uZXcgeS5kZWZhdWx0O3oucmVjdCgwLDAsdSxNKTtjb25zdCBIPW5ldyBWKHose3dpZHRoOnUsaGVpZ2h0Ok19KTtILnNldFVuaWZvcm1zKE4pLEguc2V0UHJvZ3JhbShCKSx0aGlzW3N0XS5wdXNoKEgpfX19LGZ1bmN0aW9uKFIsZSx0KXt0LnIoZSk7dmFyIGk9dCg1OCk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpLGUuZGVmYXVsdD1pLlN0cm9rZX0sZnVuY3Rpb24oUixlLHQpe3QucihlKSx0LmQoZSwiU3Ryb2tlIixmdW5jdGlvbigpe3JldHVybiBFfSk7dmFyIGk9dCg0OSk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IG89T2JqZWN0KGkuY3JlYXRlKSgpLGc9T2JqZWN0KGkuY3JlYXRlKSgpLHY9T2JqZWN0KGkuY3JlYXRlKSgpLGM9T2JqZWN0KGkuY3JlYXRlKSgpLGY9T2JqZWN0KGkuY3JlYXRlKSgpLGg9MWUyMDtjbGFzcyBFe2NvbnN0cnVjdG9yKHtsaW5lV2lkdGg6eD0xLGxpbmVKb2luOmQ9Im1pdGVyIixtaXRlckxpbWl0Onk9MTAsbGluZUNhcDpyPSJidXR0Iixyb3VuZFNlZ21lbnRzOnM9MjB9PXt9KXt0aGlzLmxpbmVXaWR0aD14LHRoaXMubGluZUpvaW49ZCx0aGlzLm1pdGVyTGltaXQ9eSx0aGlzLmxpbmVDYXA9cix0aGlzLnJvdW5kU2VnbWVudHM9cyx0aGlzLl9ub3JtYWw9bnVsbH1idWlsZCh4LGQ9ITEpe2xldCB5PXgubGVuZ3RoO2lmKHg9Wy4uLnhdLHk8MilyZXR1cm4geDtkJiYoKHhbMF1bMF0hPT14W3ktMV1bMF18fHhbMF1bMV0hPT14W3ktMV1bMV0pJiZ4LnB1c2goWy4uLnhbMF1dKSx4LnB1c2goWy4uLnhbMV1dKSkseT14Lmxlbmd0aCx0aGlzLl9ub3JtYWw9bnVsbDtjb25zdCByPXtsZWZ0OltdLHJpZ2h0OltdfSxzPXRoaXMubGluZVdpZHRoLzIsbj10aGlzLmxpbmVDYXA7aWYoIWQmJm49PT0ic3F1YXJlIil7T2JqZWN0KGkuZGlyZWN0aW9uKShnLHhbMF0seFsxXSksT2JqZWN0KGkuc2NhbGVBbmRBZGQpKHhbMF0seFswXSxnLHMpO2NvbnN0IE89eC5sZW5ndGgtMTtPYmplY3QoaS5kaXJlY3Rpb24pKGcseFtPXSx4W08tMV0pLE9iamVjdChpLnNjYWxlQW5kQWRkKSh4W09dLHhbT10sZyxzKX1mb3IobGV0IE89MTtPPHk7TysrKXtjb25zdCBBPXhbTy0xXSxiPXhbT10sST14W08rMV07dGhpcy5fc2VnKHIsQSxiLEkscyxkKX1yZXR1cm4hZCYmbj09PSJyb3VuZCImJnAocix0aGlzLnJvdW5kU2VnbWVudHMpLFsuLi5yLmxlZnQsLi4uci5yaWdodC5yZXZlcnNlKCldfV9zZWcoeCxkLHkscixzLG4pe2NvbnN0IGE9dGhpcy5saW5lSm9pbj09PSJiZXZlbCIsTz10aGlzLmxpbmVKb2luPT09InJvdW5kIjtpZihPYmplY3QoaS5kaXJlY3Rpb24pKGcseSxkKSx0aGlzLl9ub3JtYWx8fCh0aGlzLl9ub3JtYWw9T2JqZWN0KGkuY3JlYXRlKSgpLE9iamVjdChpLm5vcm1hbCkodGhpcy5fbm9ybWFsLGcpKSx4LmxlZnQubGVuZ3RofHxtKHgsZCx0aGlzLl9ub3JtYWwscyksIXIpT2JqZWN0KGkubm9ybWFsKSh0aGlzLl9ub3JtYWwsZyksbj9tKHgsZCx0aGlzLl9ub3JtYWwscyk6bSh4LHksdGhpcy5fbm9ybWFsLHMpO2Vsc2V7T2JqZWN0KGkuZGlyZWN0aW9uKSh2LHIseSk7bGV0IEE9T2JqZWN0KGkuY29tcHV0ZU1pdGVyKShjLGYsZyx2LHMpO0E9TWF0aC5taW4oQSxoKTtjb25zdCBiPU9iamVjdChpLmRvdCkoYyx0aGlzLl9ub3JtYWwpPDA/LTE6MTtsZXQgST1hfHxPO2lmKCFJJiZ0aGlzLmxpbmVKb2luPT09Im1pdGVyIiYmQS9zPnRoaXMubWl0ZXJMaW1pdCYmKEk9ITApLEkpe09iamVjdChpLnNjYWxlQW5kQWRkKShvLHksdGhpcy5fbm9ybWFsLC1zKmIpLGwoeCxvLGIpO2xldCBQPTEvMDtkJiYoUD1NYXRoLm1pbihQLE1hdGguaHlwb3QoeVswXS1kWzBdLHlbMV0tZFsxXSkpKSxyJiYoUD1NYXRoLm1pbihQLE1hdGguaHlwb3QoclswXS15WzBdLHJbMV0teVsxXSkpKTtjb25zdCBEPU1hdGgubWF4KHMsTWF0aC5taW4oQSxQKSk7aWYoT2JqZWN0KGkuc2NhbGVBbmRBZGQpKG8seSxmLEQqYiksbCh4LG8sLWIpLHIpaWYoT2JqZWN0KGkubm9ybWFsKShvLHYpLE9iamVjdChpLmNvcHkpKHRoaXMuX25vcm1hbCxvKSxPYmplY3QoaS5zY2FsZUFuZEFkZCkobyx5LG8sLXMqYiksTyl7Y29uc3QgTD1PYmplY3QoaS5jbG9uZSkobyksUz1iPjA/eC5sZWZ0W3gubGVmdC5sZW5ndGgtMV06eC5yaWdodFt4LnJpZ2h0Lmxlbmd0aC0xXSxUPU9iamVjdChpLmNsb25lKSh5KSxqPU9iamVjdChpLnN1YikoT2JqZWN0KGkuY3JlYXRlKSgpLFMsVCksJD1PYmplY3QoaS5zdWIpKE9iamVjdChpLmNyZWF0ZSkoKSxMLFQpLHc9TWF0aC5QSS90aGlzLnJvdW5kU2VnbWVudHM7Zm9yKGxldCBKPTA7Sjx0aGlzLnJvdW5kU2VnbWVudHMmJihPYmplY3QoaS5yb3RhdGUpKGosaixbMCwwXSxiKncpLE1hdGguc2lnbihPYmplY3QoaS5jcm9zcykobyxqLCQpWzJdKT09PWIpO0orKylPYmplY3QoaS5hZGQpKG8saixUKSxsKHgsbyxiKTtsKHgsTCxiKX1lbHNlIGwoeCxvLGIpfWVsc2UgbSh4LHksZixBKSxPYmplY3QoaS5jb3B5KSh0aGlzLl9ub3JtYWwsZil9fX1mdW5jdGlvbiBsKEMseCxkKXtkPjA/Qy5sZWZ0LnB1c2goT2JqZWN0KGkuY2xvbmUpKHgpKTpDLnJpZ2h0LnB1c2goT2JqZWN0KGkuY2xvbmUpKHgpKX1mdW5jdGlvbiBtKEMseCxkLHkscj0tMSl7T2JqZWN0KGkuc2NhbGVBbmRBZGQpKG8seCxkLC15KSxsKEMsbywtciksT2JqZWN0KGkuc2NhbGVBbmRBZGQpKG8seCxkLHkpLGwoQyxvLHIpfWZ1bmN0aW9uIHAoe2xlZnQ6QyxyaWdodDp4fSxkKXtjb25zdCB5PU9iamVjdChpLmNyZWF0ZSkoKSxyPU9iamVjdChpLmNyZWF0ZSkoKTtsZXQgcz1DWzBdLG49eFswXSxhPVsuNSooc1swXStuWzBdKSwuNSooc1sxXStuWzFdKV07T2JqZWN0KGkuc3ViKShyLHMsYSk7Zm9yKGxldCBPPTE7Tzw9ZDtPKyspe2NvbnN0IEE9LTEqTWF0aC5QSSpPL2Q7T2JqZWN0KGkucm90YXRlKSh5LHIsWzAsMF0sQSksT2JqZWN0KGkuYWRkKShvLGEseSksQy51bnNoaWZ0KE9iamVjdChpLmNsb25lKShvKSl9cz14W3gubGVuZ3RoLTFdLG49Q1tDLmxlbmd0aC0xXSxhPVsuNSooc1swXStuWzBdKSwuNSooc1sxXStuWzFdKV0sT2JqZWN0KGkuc3ViKShyLHMsYSk7Zm9yKGxldCBPPTE7Tzw9ZDtPKyspe2NvbnN0IEE9LTEqTWF0aC5QSSpPL2Q7T2JqZWN0KGkucm90YXRlKSh5LHIsWzAsMF0sQSksT2JqZWN0KGkuYWRkKShvLGEseSkseC5wdXNoKE9iamVjdChpLmNsb25lKShvKSl9fX0sZnVuY3Rpb24oUixlLHQpe3QucihlKSx0LmQoZSwiaXNVbml0VHJhbnNmb3JtIixmdW5jdGlvbigpe3JldHVybiBpfSksdCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIGkobyl7cmV0dXJuIG9bMF09PT0xJiZvWzFdPT09MCYmb1syXT09PTAmJm9bM109PT0xJiZvWzRdPT09MCYmb1s1XT09PTB9fSxmdW5jdGlvbihSLGUsdCl7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO3ZhciBpPXQoNjEpLG89dCg2Mik7Ui5leHBvcnRzPWZ1bmN0aW9uKGcsdil7aWYodj12fHx7fSxnPWcuZmlsdGVyKGZ1bmN0aW9uKGQpe3JldHVybiBkLmxlbmd0aD4yfSksZy5sZW5ndGg9PT0wKXJldHVybntwb3NpdGlvbnM6W10sY2VsbHM6W119O3R5cGVvZiB2LnZlcnRleFNpemUhPSJudW1iZXIiJiYodi52ZXJ0ZXhTaXplPWdbMF1bMF0ubGVuZ3RoKSxnPWcubWFwKGZ1bmN0aW9uKGQpe3JldHVybiBkLnJlZHVjZShmdW5jdGlvbih5LHIpe3JldHVybiB5LmNvbmNhdChyKX0pfSk7Y29uc3QgYz12LnJ1bGU9PT0iZXZlbm9kZCI/aS5XSU5ESU5HX09ERDppLldJTkRJTkdfTk9OWkVSTztmb3IodmFyIGY9aS50ZXNzZWxhdGUobyh7Y29udG91cnM6Zyx3aW5kaW5nUnVsZTpjLGVsZW1lbnRUeXBlOmkuUE9MWUdPTlMscG9seVNpemU6Myx2ZXJ0ZXhTaXplOjJ9LHYpKSxoPVtdLEU9MDtFPGYudmVydGljZXMubGVuZ3RoO0UrPXYudmVydGV4U2l6ZSl7dmFyIGw9Zi52ZXJ0aWNlcy5zbGljZShFLEUrdi52ZXJ0ZXhTaXplKTtoLnB1c2gobCl9dmFyIG09W107Zm9yKEU9MDtFPGYuZWxlbWVudHMubGVuZ3RoO0UrPTMpe3ZhciBwPWYuZWxlbWVudHNbRV0sQz1mLmVsZW1lbnRzW0UrMV0seD1mLmVsZW1lbnRzW0UrMl07bS5wdXNoKFtwLEMseF0pfXJldHVybntwb3NpdGlvbnM6aCxjZWxsczptfX19LGZ1bmN0aW9uKFIsZSx0KXt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7dmFyIGk9e30sbz17fTtSLmV4cG9ydHM9aSxpLldJTkRJTkdfT0REPTAsaS5XSU5ESU5HX05PTlpFUk89MSxpLldJTkRJTkdfUE9TSVRJVkU9MixpLldJTkRJTkdfTkVHQVRJVkU9MyxpLldJTkRJTkdfQUJTX0dFUV9UV089NCxpLlBPTFlHT05TPTAsaS5DT05ORUNURURfUE9MWUdPTlM9MSxpLkJPVU5EQVJZX0NPTlRPVVJTPTIsaS50ZXNzZWxhdGU9ZnVuY3Rpb24ocil7Zm9yKHZhciBzPXIuZGVidWd8fCExLG49bmV3IHksYT0wO2E8ci5jb250b3Vycy5sZW5ndGg7YSsrKW4uYWRkQ29udG91cihyLnZlcnRleFNpemV8fDIsci5jb250b3Vyc1thXSk7cmV0dXJuIG4udGVzc2VsYXRlKHIud2luZGluZ1J1bGV8fGkuV0lORElOR19PREQsci5lbGVtZW50VHlwZXx8aS5QT0xZR09OUyxyLnBvbHlTaXplfHwzLHIudmVydGV4U2l6ZXx8MixyLm5vcm1hbHx8WzAsMCwxXSkse3ZlcnRpY2VzOm4udmVydGljZXMsdmVydGV4SW5kaWNlczpuLnZlcnRleEluZGljZXMsdmVydGV4Q291bnQ6bi52ZXJ0ZXhDb3VudCxlbGVtZW50czpuLmVsZW1lbnRzLGVsZW1lbnRDb3VudDpuLmVsZW1lbnRDb3VudCxtZXNoOnM/bi5tZXNoOnZvaWQgMH19O3ZhciBnPWZ1bmN0aW9uKHIpe2lmKCFyKXRocm93IkFzc2VydGlvbiBGYWlsZWQhIn07ZnVuY3Rpb24gdigpe3RoaXMubmV4dD1udWxsLHRoaXMucHJldj1udWxsLHRoaXMuYW5FZGdlPW51bGwsdGhpcy5jb29yZHM9WzAsMCwwXSx0aGlzLnM9MCx0aGlzLnQ9MCx0aGlzLnBxSGFuZGxlPTAsdGhpcy5uPTAsdGhpcy5pZHg9MH1mdW5jdGlvbiBjKCl7dGhpcy5uZXh0PW51bGwsdGhpcy5wcmV2PW51bGwsdGhpcy5hbkVkZ2U9bnVsbCx0aGlzLnRyYWlsPW51bGwsdGhpcy5uPTAsdGhpcy5tYXJrZWQ9ITEsdGhpcy5pbnNpZGU9ITF9ZnVuY3Rpb24gZihyKXt0aGlzLm5leHQ9bnVsbCx0aGlzLlN5bT1udWxsLHRoaXMuT25leHQ9bnVsbCx0aGlzLkxuZXh0PW51bGwsdGhpcy5Pcmc9bnVsbCx0aGlzLkxmYWNlPW51bGwsdGhpcy5hY3RpdmVSZWdpb249bnVsbCx0aGlzLndpbmRpbmc9MCx0aGlzLnNpZGU9cn1mLnByb3RvdHlwZT17Z2V0IFJmYWNlKCl7cmV0dXJuIHRoaXMuU3ltLkxmYWNlfSxzZXQgUmZhY2Uocil7dGhpcy5TeW0uTGZhY2U9cn0sZ2V0IERzdCgpe3JldHVybiB0aGlzLlN5bS5Pcmd9LHNldCBEc3Qocil7dGhpcy5TeW0uT3JnPXJ9LGdldCBPcHJldigpe3JldHVybiB0aGlzLlN5bS5MbmV4dH0sc2V0IE9wcmV2KHIpe3RoaXMuU3ltLkxuZXh0PXJ9LGdldCBMcHJldigpe3JldHVybiB0aGlzLk9uZXh0LlN5bX0sc2V0IExwcmV2KHIpe3RoaXMuT25leHQuU3ltPXJ9LGdldCBEcHJldigpe3JldHVybiB0aGlzLkxuZXh0LlN5bX0sc2V0IERwcmV2KHIpe3RoaXMuTG5leHQuU3ltPXJ9LGdldCBScHJldigpe3JldHVybiB0aGlzLlN5bS5PbmV4dH0sc2V0IFJwcmV2KHIpe3RoaXMuU3ltLk9uZXh0PXJ9LGdldCBEbmV4dCgpe3JldHVybiB0aGlzLlN5bS5PbmV4dC5TeW19LHNldCBEbmV4dChyKXt0aGlzLlN5bS5PbmV4dC5TeW09cn0sZ2V0IFJuZXh0KCl7cmV0dXJuIHRoaXMuU3ltLkxuZXh0LlN5bX0sc2V0IFJuZXh0KHIpe3RoaXMuU3ltLkxuZXh0LlN5bT1yfX07ZnVuY3Rpb24gaCgpe3ZhciByPW5ldyB2LHM9bmV3IGMsbj1uZXcgZigwKSxhPW5ldyBmKDEpO3IubmV4dD1yLnByZXY9cixyLmFuRWRnZT1udWxsLHMubmV4dD1zLnByZXY9cyxzLmFuRWRnZT1udWxsLHMudHJhaWw9bnVsbCxzLm1hcmtlZD0hMSxzLmluc2lkZT0hMSxuLm5leHQ9bixuLlN5bT1hLG4uT25leHQ9bnVsbCxuLkxuZXh0PW51bGwsbi5Pcmc9bnVsbCxuLkxmYWNlPW51bGwsbi53aW5kaW5nPTAsbi5hY3RpdmVSZWdpb249bnVsbCxhLm5leHQ9YSxhLlN5bT1uLGEuT25leHQ9bnVsbCxhLkxuZXh0PW51bGwsYS5Pcmc9bnVsbCxhLkxmYWNlPW51bGwsYS53aW5kaW5nPTAsYS5hY3RpdmVSZWdpb249bnVsbCx0aGlzLnZIZWFkPXIsdGhpcy5mSGVhZD1zLHRoaXMuZUhlYWQ9bix0aGlzLmVIZWFkU3ltPWF9aC5wcm90b3R5cGU9e21ha2VFZGdlXzpmdW5jdGlvbihyKXt2YXIgcz1uZXcgZigwKSxuPW5ldyBmKDEpO3IuU3ltLnNpZGU8ci5zaWRlJiYocj1yLlN5bSk7dmFyIGE9ci5TeW0ubmV4dDtyZXR1cm4gbi5uZXh0PWEsYS5TeW0ubmV4dD1zLHMubmV4dD1yLHIuU3ltLm5leHQ9bixzLlN5bT1uLHMuT25leHQ9cyxzLkxuZXh0PW4scy5Pcmc9bnVsbCxzLkxmYWNlPW51bGwscy53aW5kaW5nPTAscy5hY3RpdmVSZWdpb249bnVsbCxuLlN5bT1zLG4uT25leHQ9bixuLkxuZXh0PXMsbi5Pcmc9bnVsbCxuLkxmYWNlPW51bGwsbi53aW5kaW5nPTAsbi5hY3RpdmVSZWdpb249bnVsbCxzfSxzcGxpY2VfOmZ1bmN0aW9uKHIscyl7dmFyIG49ci5PbmV4dCxhPXMuT25leHQ7bi5TeW0uTG5leHQ9cyxhLlN5bS5MbmV4dD1yLHIuT25leHQ9YSxzLk9uZXh0PW59LG1ha2VWZXJ0ZXhfOmZ1bmN0aW9uKHIscyxuKXt2YXIgYT1yO2coYSE9PW51bGwpO3ZhciBPPW4ucHJldjthLnByZXY9TyxPLm5leHQ9YSxhLm5leHQ9bixuLnByZXY9YSxhLmFuRWRnZT1zO3ZhciBBPXM7ZG8gQS5Pcmc9YSxBPUEuT25leHQ7d2hpbGUoQSE9PXMpfSxtYWtlRmFjZV86ZnVuY3Rpb24ocixzLG4pe3ZhciBhPXI7ZyhhIT09bnVsbCk7dmFyIE89bi5wcmV2O2EucHJldj1PLE8ubmV4dD1hLGEubmV4dD1uLG4ucHJldj1hLGEuYW5FZGdlPXMsYS50cmFpbD1udWxsLGEubWFya2VkPSExLGEuaW5zaWRlPW4uaW5zaWRlO3ZhciBBPXM7ZG8gQS5MZmFjZT1hLEE9QS5MbmV4dDt3aGlsZShBIT09cyl9LGtpbGxFZGdlXzpmdW5jdGlvbihyKXtyLlN5bS5zaWRlPHIuc2lkZSYmKHI9ci5TeW0pO3ZhciBzPXIubmV4dCxuPXIuU3ltLm5leHQ7cy5TeW0ubmV4dD1uLG4uU3ltLm5leHQ9c30sa2lsbFZlcnRleF86ZnVuY3Rpb24ocixzKXt2YXIgbj1yLmFuRWRnZSxhPW47ZG8gYS5Pcmc9cyxhPWEuT25leHQ7d2hpbGUoYSE9PW4pO3ZhciBPPXIucHJldixBPXIubmV4dDtBLnByZXY9TyxPLm5leHQ9QX0sa2lsbEZhY2VfOmZ1bmN0aW9uKHIscyl7dmFyIG49ci5hbkVkZ2UsYT1uO2RvIGEuTGZhY2U9cyxhPWEuTG5leHQ7d2hpbGUoYSE9PW4pO3ZhciBPPXIucHJldixBPXIubmV4dDtBLnByZXY9TyxPLm5leHQ9QX0sbWFrZUVkZ2U6ZnVuY3Rpb24oKXt2YXIgcj1uZXcgdixzPW5ldyB2LG49bmV3IGMsYT10aGlzLm1ha2VFZGdlXyh0aGlzLmVIZWFkKTtyZXR1cm4gdGhpcy5tYWtlVmVydGV4XyhyLGEsdGhpcy52SGVhZCksdGhpcy5tYWtlVmVydGV4XyhzLGEuU3ltLHRoaXMudkhlYWQpLHRoaXMubWFrZUZhY2VfKG4sYSx0aGlzLmZIZWFkKSxhfSxzcGxpY2U6ZnVuY3Rpb24ocixzKXt2YXIgbj0hMSxhPSExO2lmKHIhPT1zKXtpZihzLk9yZyE9PXIuT3JnJiYoYT0hMCx0aGlzLmtpbGxWZXJ0ZXhfKHMuT3JnLHIuT3JnKSkscy5MZmFjZSE9PXIuTGZhY2UmJihuPSEwLHRoaXMua2lsbEZhY2VfKHMuTGZhY2Usci5MZmFjZSkpLHRoaXMuc3BsaWNlXyhzLHIpLCFhKXt2YXIgTz1uZXcgdjt0aGlzLm1ha2VWZXJ0ZXhfKE8scyxyLk9yZyksci5PcmcuYW5FZGdlPXJ9aWYoIW4pe3ZhciBBPW5ldyBjO3RoaXMubWFrZUZhY2VfKEEscyxyLkxmYWNlKSxyLkxmYWNlLmFuRWRnZT1yfX19LGRlbGV0ZTpmdW5jdGlvbihyKXt2YXIgcz1yLlN5bSxuPSExO2lmKHIuTGZhY2UhPT1yLlJmYWNlJiYobj0hMCx0aGlzLmtpbGxGYWNlXyhyLkxmYWNlLHIuUmZhY2UpKSxyLk9uZXh0PT09cil0aGlzLmtpbGxWZXJ0ZXhfKHIuT3JnLG51bGwpO2Vsc2UgaWYoci5SZmFjZS5hbkVkZ2U9ci5PcHJldixyLk9yZy5hbkVkZ2U9ci5PbmV4dCx0aGlzLnNwbGljZV8ocixyLk9wcmV2KSwhbil7dmFyIGE9bmV3IGM7dGhpcy5tYWtlRmFjZV8oYSxyLHIuTGZhY2UpfXMuT25leHQ9PT1zPyh0aGlzLmtpbGxWZXJ0ZXhfKHMuT3JnLG51bGwpLHRoaXMua2lsbEZhY2VfKHMuTGZhY2UsbnVsbCkpOihyLkxmYWNlLmFuRWRnZT1zLk9wcmV2LHMuT3JnLmFuRWRnZT1zLk9uZXh0LHRoaXMuc3BsaWNlXyhzLHMuT3ByZXYpKSx0aGlzLmtpbGxFZGdlXyhyKX0sYWRkRWRnZVZlcnRleDpmdW5jdGlvbihyKXt2YXIgcz10aGlzLm1ha2VFZGdlXyhyKSxuPXMuU3ltO3RoaXMuc3BsaWNlXyhzLHIuTG5leHQpLHMuT3JnPXIuRHN0O3ZhciBhPW5ldyB2O3JldHVybiB0aGlzLm1ha2VWZXJ0ZXhfKGEsbixzLk9yZykscy5MZmFjZT1uLkxmYWNlPXIuTGZhY2Usc30sc3BsaXRFZGdlOmZ1bmN0aW9uKHIscyl7dmFyIG49dGhpcy5hZGRFZGdlVmVydGV4KHIpLGE9bi5TeW07cmV0dXJuIHRoaXMuc3BsaWNlXyhyLlN5bSxyLlN5bS5PcHJldiksdGhpcy5zcGxpY2VfKHIuU3ltLGEpLHIuRHN0PWEuT3JnLGEuRHN0LmFuRWRnZT1hLlN5bSxhLlJmYWNlPXIuUmZhY2UsYS53aW5kaW5nPXIud2luZGluZyxhLlN5bS53aW5kaW5nPXIuU3ltLndpbmRpbmcsYX0sY29ubmVjdDpmdW5jdGlvbihyLHMpe3ZhciBuPSExLGE9dGhpcy5tYWtlRWRnZV8ociksTz1hLlN5bTtpZihzLkxmYWNlIT09ci5MZmFjZSYmKG49ITAsdGhpcy5raWxsRmFjZV8ocy5MZmFjZSxyLkxmYWNlKSksdGhpcy5zcGxpY2VfKGEsci5MbmV4dCksdGhpcy5zcGxpY2VfKE8scyksYS5Pcmc9ci5Ec3QsTy5Pcmc9cy5PcmcsYS5MZmFjZT1PLkxmYWNlPXIuTGZhY2Usci5MZmFjZS5hbkVkZ2U9Tywhbil7dmFyIEE9bmV3IGM7dGhpcy5tYWtlRmFjZV8oQSxhLHIuTGZhY2UpfXJldHVybiBhfSx6YXBGYWNlOmZ1bmN0aW9uKHIpe3ZhciBzPXIuYW5FZGdlLG4sYSxPLEEsYjthPXMuTG5leHQ7ZG8gbj1hLGE9bi5MbmV4dCxuLkxmYWNlPW51bGwsbi5SZmFjZT09PW51bGwmJihuLk9uZXh0PT09bj90aGlzLmtpbGxWZXJ0ZXhfKG4uT3JnLG51bGwpOihuLk9yZy5hbkVkZ2U9bi5PbmV4dCx0aGlzLnNwbGljZV8obixuLk9wcmV2KSksTz1uLlN5bSxPLk9uZXh0PT09Tz90aGlzLmtpbGxWZXJ0ZXhfKE8uT3JnLG51bGwpOihPLk9yZy5hbkVkZ2U9Ty5PbmV4dCx0aGlzLnNwbGljZV8oTyxPLk9wcmV2KSksdGhpcy5raWxsRWRnZV8obikpO3doaWxlKG4hPXMpO0E9ci5wcmV2LGI9ci5uZXh0LGIucHJldj1BLEEubmV4dD1ifSxjb3VudEZhY2VWZXJ0c186ZnVuY3Rpb24ocil7dmFyIHM9ci5hbkVkZ2Usbj0wO2RvIG4rKyxzPXMuTG5leHQ7d2hpbGUocyE9PXIuYW5FZGdlKTtyZXR1cm4gbn0sbWVyZ2VDb252ZXhGYWNlczpmdW5jdGlvbihyKXt2YXIgcyxuLGEsTyxBLGIsSTtmb3Iocz10aGlzLmZIZWFkLm5leHQ7cyE9PXRoaXMuZkhlYWQ7cz1zLm5leHQpaWYocy5pbnNpZGUpZm9yKG49cy5hbkVkZ2UsQT1uLk9yZzthPW4uTG5leHQsTz1uLlN5bSxPJiZPLkxmYWNlJiZPLkxmYWNlLmluc2lkZSYmKGI9dGhpcy5jb3VudEZhY2VWZXJ0c18ocyksST10aGlzLmNvdW50RmFjZVZlcnRzXyhPLkxmYWNlKSxiK0ktMjw9ciYmby52ZXJ0Q0NXKG4uTHByZXYuT3JnLG4uT3JnLE8uTG5leHQuTG5leHQuT3JnKSYmby52ZXJ0Q0NXKE8uTHByZXYuT3JnLE8uT3JnLG4uTG5leHQuTG5leHQuT3JnKSYmKGE9Ty5MbmV4dCx0aGlzLmRlbGV0ZShPKSxuPW51bGwsTz1udWxsKSksIShuJiZuLkxuZXh0Lk9yZz09PUEpOyluPWE7cmV0dXJuITB9LGNoZWNrOmZ1bmN0aW9uKCl7dmFyIHI9dGhpcy5mSGVhZCxzPXRoaXMudkhlYWQsbj10aGlzLmVIZWFkLGEsTyxBLGIsSSxQO2ZvcihPPXIsTz1yOyhhPU8ubmV4dCkhPT1yO089YSl7ZyhhLnByZXY9PT1PKSxJPWEuYW5FZGdlO2RvIGcoSS5TeW0hPT1JKSxnKEkuU3ltLlN5bT09PUkpLGcoSS5MbmV4dC5PbmV4dC5TeW09PT1JKSxnKEkuT25leHQuU3ltLkxuZXh0PT09SSksZyhJLkxmYWNlPT09YSksST1JLkxuZXh0O3doaWxlKEkhPT1hLmFuRWRnZSl9Zm9yKGcoYS5wcmV2PT09TyYmYS5hbkVkZ2U9PT1udWxsKSxiPXMsYj1zOyhBPWIubmV4dCkhPT1zO2I9QSl7ZyhBLnByZXY9PT1iKSxJPUEuYW5FZGdlO2RvIGcoSS5TeW0hPT1JKSxnKEkuU3ltLlN5bT09PUkpLGcoSS5MbmV4dC5PbmV4dC5TeW09PT1JKSxnKEkuT25leHQuU3ltLkxuZXh0PT09SSksZyhJLk9yZz09PUEpLEk9SS5PbmV4dDt3aGlsZShJIT09QS5hbkVkZ2UpfWZvcihnKEEucHJldj09PWImJkEuYW5FZGdlPT09bnVsbCksUD1uLFA9bjsoST1QLm5leHQpIT09bjtQPUkpZyhJLlN5bS5uZXh0PT09UC5TeW0pLGcoSS5TeW0hPT1JKSxnKEkuU3ltLlN5bT09PUkpLGcoSS5PcmchPT1udWxsKSxnKEkuRHN0IT09bnVsbCksZyhJLkxuZXh0Lk9uZXh0LlN5bT09PUkpLGcoSS5PbmV4dC5TeW0uTG5leHQ9PT1JKTtnKEkuU3ltLm5leHQ9PT1QLlN5bSYmSS5TeW09PT10aGlzLmVIZWFkU3ltJiZJLlN5bS5TeW09PT1JJiZJLk9yZz09PW51bGwmJkkuRHN0PT09bnVsbCYmSS5MZmFjZT09PW51bGwmJkkuUmZhY2U9PT1udWxsKX19LG8udmVydEVxPWZ1bmN0aW9uKHIscyl7cmV0dXJuIHIucz09PXMucyYmci50PT09cy50fSxvLnZlcnRMZXE9ZnVuY3Rpb24ocixzKXtyZXR1cm4gci5zPHMuc3x8ci5zPT09cy5zJiZyLnQ8PXMudH0sby50cmFuc0xlcT1mdW5jdGlvbihyLHMpe3JldHVybiByLnQ8cy50fHxyLnQ9PT1zLnQmJnIuczw9cy5zfSxvLmVkZ2VHb2VzTGVmdD1mdW5jdGlvbihyKXtyZXR1cm4gby52ZXJ0TGVxKHIuRHN0LHIuT3JnKX0sby5lZGdlR29lc1JpZ2h0PWZ1bmN0aW9uKHIpe3JldHVybiBvLnZlcnRMZXEoci5Pcmcsci5Ec3QpfSxvLnZlcnRMMWRpc3Q9ZnVuY3Rpb24ocixzKXtyZXR1cm4gTWF0aC5hYnMoci5zLXMucykrTWF0aC5hYnMoci50LXMudCl9LG8uZWRnZUV2YWw9ZnVuY3Rpb24ocixzLG4pe2coby52ZXJ0TGVxKHIscykmJm8udmVydExlcShzLG4pKTt2YXIgYT1zLnMtci5zLE89bi5zLXMucztyZXR1cm4gYStPPjA/YTxPP3MudC1yLnQrKHIudC1uLnQpKihhLyhhK08pKTpzLnQtbi50KyhuLnQtci50KSooTy8oYStPKSk6MH0sby5lZGdlU2lnbj1mdW5jdGlvbihyLHMsbil7ZyhvLnZlcnRMZXEocixzKSYmby52ZXJ0TGVxKHMsbikpO3ZhciBhPXMucy1yLnMsTz1uLnMtcy5zO3JldHVybiBhK08+MD8ocy50LW4udCkqYSsocy50LXIudCkqTzowfSxvLnRyYW5zRXZhbD1mdW5jdGlvbihyLHMsbil7ZyhvLnRyYW5zTGVxKHIscykmJm8udHJhbnNMZXEocyxuKSk7dmFyIGE9cy50LXIudCxPPW4udC1zLnQ7cmV0dXJuIGErTz4wP2E8Tz9zLnMtci5zKyhyLnMtbi5zKSooYS8oYStPKSk6cy5zLW4ucysobi5zLXIucykqKE8vKGErTykpOjB9LG8udHJhbnNTaWduPWZ1bmN0aW9uKHIscyxuKXtnKG8udHJhbnNMZXEocixzKSYmby50cmFuc0xlcShzLG4pKTt2YXIgYT1zLnQtci50LE89bi50LXMudDtyZXR1cm4gYStPPjA/KHMucy1uLnMpKmErKHMucy1yLnMpKk86MH0sby52ZXJ0Q0NXPWZ1bmN0aW9uKHIscyxuKXtyZXR1cm4gci5zKihzLnQtbi50KStzLnMqKG4udC1yLnQpK24ucyooci50LXMudCk+PTB9LG8uaW50ZXJwb2xhdGU9ZnVuY3Rpb24ocixzLG4sYSl7cmV0dXJuIHI9cjwwPzA6cixuPW48MD8wOm4scjw9bj9uPT09MD8ocythKS8yOnMrKGEtcykqKHIvKHIrbikpOmErKHMtYSkqKG4vKHIrbikpfSxvLmludGVyc2VjdD1mdW5jdGlvbihyLHMsbixhLE8pe3ZhciBBLGIsSTtvLnZlcnRMZXEocixzKXx8KEk9cixyPXMscz1JKSxvLnZlcnRMZXEobixhKXx8KEk9bixuPWEsYT1JKSxvLnZlcnRMZXEocixuKXx8KEk9cixyPW4sbj1JLEk9cyxzPWEsYT1JKSxvLnZlcnRMZXEobixzKT9vLnZlcnRMZXEocyxhKT8oQT1vLmVkZ2VFdmFsKHIsbixzKSxiPW8uZWRnZUV2YWwobixzLGEpLEErYjwwJiYoQT0tQSxiPS1iKSxPLnM9by5pbnRlcnBvbGF0ZShBLG4ucyxiLHMucykpOihBPW8uZWRnZVNpZ24ocixuLHMpLGI9LW8uZWRnZVNpZ24ocixhLHMpLEErYjwwJiYoQT0tQSxiPS1iKSxPLnM9by5pbnRlcnBvbGF0ZShBLG4ucyxiLGEucykpOk8ucz0obi5zK3MucykvMixvLnRyYW5zTGVxKHIscyl8fChJPXIscj1zLHM9SSksby50cmFuc0xlcShuLGEpfHwoST1uLG49YSxhPUkpLG8udHJhbnNMZXEocixuKXx8KEk9cixyPW4sbj1JLEk9cyxzPWEsYT1JKSxvLnRyYW5zTGVxKG4scyk/by50cmFuc0xlcShzLGEpPyhBPW8udHJhbnNFdmFsKHIsbixzKSxiPW8udHJhbnNFdmFsKG4scyxhKSxBK2I8MCYmKEE9LUEsYj0tYiksTy50PW8uaW50ZXJwb2xhdGUoQSxuLnQsYixzLnQpKTooQT1vLnRyYW5zU2lnbihyLG4scyksYj0tby50cmFuc1NpZ24ocixhLHMpLEErYjwwJiYoQT0tQSxiPS1iKSxPLnQ9by5pbnRlcnBvbGF0ZShBLG4udCxiLGEudCkpOk8udD0obi50K3MudCkvMn07ZnVuY3Rpb24gRSgpe3RoaXMua2V5PW51bGwsdGhpcy5uZXh0PW51bGwsdGhpcy5wcmV2PW51bGx9ZnVuY3Rpb24gbChyLHMpe3RoaXMuaGVhZD1uZXcgRSx0aGlzLmhlYWQubmV4dD10aGlzLmhlYWQsdGhpcy5oZWFkLnByZXY9dGhpcy5oZWFkLHRoaXMuZnJhbWU9cix0aGlzLmxlcT1zfWwucHJvdG90eXBlPXttaW46ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5oZWFkLm5leHR9LG1heDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmhlYWQucHJldn0saW5zZXJ0OmZ1bmN0aW9uKHIpe3JldHVybiB0aGlzLmluc2VydEJlZm9yZSh0aGlzLmhlYWQscil9LHNlYXJjaDpmdW5jdGlvbihyKXt2YXIgcz10aGlzLmhlYWQ7ZG8gcz1zLm5leHQ7d2hpbGUocy5rZXkhPT1udWxsJiYhdGhpcy5sZXEodGhpcy5mcmFtZSxyLHMua2V5KSk7cmV0dXJuIHN9LGluc2VydEJlZm9yZTpmdW5jdGlvbihyLHMpe2RvIHI9ci5wcmV2O3doaWxlKHIua2V5IT09bnVsbCYmIXRoaXMubGVxKHRoaXMuZnJhbWUsci5rZXkscykpO3ZhciBuPW5ldyBFO3JldHVybiBuLmtleT1zLG4ubmV4dD1yLm5leHQsci5uZXh0LnByZXY9bixuLnByZXY9cixyLm5leHQ9bixufSxkZWxldGU6ZnVuY3Rpb24ocil7ci5uZXh0LnByZXY9ci5wcmV2LHIucHJldi5uZXh0PXIubmV4dH19O2Z1bmN0aW9uIG0oKXt0aGlzLmhhbmRsZT1udWxsfWZ1bmN0aW9uIHAoKXt0aGlzLmtleT1udWxsLHRoaXMubm9kZT1udWxsfWZ1bmN0aW9uIEMocixzKXt0aGlzLnNpemU9MCx0aGlzLm1heD1yLHRoaXMubm9kZXM9W10sdGhpcy5ub2Rlcy5sZW5ndGg9cisxO3ZhciBuO2ZvcihuPTA7bjx0aGlzLm5vZGVzLmxlbmd0aDtuKyspdGhpcy5ub2Rlc1tuXT1uZXcgbTtmb3IodGhpcy5oYW5kbGVzPVtdLHRoaXMuaGFuZGxlcy5sZW5ndGg9cisxLG49MDtuPHRoaXMuaGFuZGxlcy5sZW5ndGg7bisrKXRoaXMuaGFuZGxlc1tuXT1uZXcgcDt0aGlzLmluaXRpYWxpemVkPSExLHRoaXMuZnJlZUxpc3Q9MCx0aGlzLmxlcT1zLHRoaXMubm9kZXNbMV0uaGFuZGxlPTEsdGhpcy5oYW5kbGVzWzFdLmtleT1udWxsfUMucHJvdG90eXBlPXtmbG9hdERvd25fOmZ1bmN0aW9uKHIpe3ZhciBzPXRoaXMubm9kZXMsbj10aGlzLmhhbmRsZXMsYSxPLEE7Zm9yKGE9c1tyXS5oYW5kbGU7Oyl7aWYoQT1yPDwxLEE8dGhpcy5zaXplJiZ0aGlzLmxlcShuW3NbQSsxXS5oYW5kbGVdLmtleSxuW3NbQV0uaGFuZGxlXS5rZXkpJiYrK0EsZyhBPD10aGlzLm1heCksTz1zW0FdLmhhbmRsZSxBPnRoaXMuc2l6ZXx8dGhpcy5sZXEoblthXS5rZXksbltPXS5rZXkpKXtzW3JdLmhhbmRsZT1hLG5bYV0ubm9kZT1yO2JyZWFrfXNbcl0uaGFuZGxlPU8sbltPXS5ub2RlPXIscj1BfX0sZmxvYXRVcF86ZnVuY3Rpb24ocil7dmFyIHM9dGhpcy5ub2RlcyxuPXRoaXMuaGFuZGxlcyxhLE8sQTtmb3IoYT1zW3JdLmhhbmRsZTs7KXtpZihBPXI+PjEsTz1zW0FdLmhhbmRsZSxBPT09MHx8dGhpcy5sZXEobltPXS5rZXksblthXS5rZXkpKXtzW3JdLmhhbmRsZT1hLG5bYV0ubm9kZT1yO2JyZWFrfXNbcl0uaGFuZGxlPU8sbltPXS5ub2RlPXIscj1BfX0saW5pdDpmdW5jdGlvbigpe2Zvcih2YXIgcj10aGlzLnNpemU7cj49MTstLXIpdGhpcy5mbG9hdERvd25fKHIpO3RoaXMuaW5pdGlhbGl6ZWQ9ITB9LG1pbjpmdW5jdGlvbigpe3JldHVybiB0aGlzLmhhbmRsZXNbdGhpcy5ub2Rlc1sxXS5oYW5kbGVdLmtleX0saW5zZXJ0OmZ1bmN0aW9uKHIpe3ZhciBzLG47aWYocz0rK3RoaXMuc2l6ZSxzKjI+dGhpcy5tYXgpe3RoaXMubWF4Kj0yO3ZhciBhLE87Zm9yKE89dGhpcy5ub2Rlcy5sZW5ndGgsdGhpcy5ub2Rlcy5sZW5ndGg9dGhpcy5tYXgrMSxhPU87YTx0aGlzLm5vZGVzLmxlbmd0aDthKyspdGhpcy5ub2Rlc1thXT1uZXcgbTtmb3IoTz10aGlzLmhhbmRsZXMubGVuZ3RoLHRoaXMuaGFuZGxlcy5sZW5ndGg9dGhpcy5tYXgrMSxhPU87YTx0aGlzLmhhbmRsZXMubGVuZ3RoO2ErKyl0aGlzLmhhbmRsZXNbYV09bmV3IHB9cmV0dXJuIHRoaXMuZnJlZUxpc3Q9PT0wP249czoobj10aGlzLmZyZWVMaXN0LHRoaXMuZnJlZUxpc3Q9dGhpcy5oYW5kbGVzW25dLm5vZGUpLHRoaXMubm9kZXNbc10uaGFuZGxlPW4sdGhpcy5oYW5kbGVzW25dLm5vZGU9cyx0aGlzLmhhbmRsZXNbbl0ua2V5PXIsdGhpcy5pbml0aWFsaXplZCYmdGhpcy5mbG9hdFVwXyhzKSxufSxleHRyYWN0TWluOmZ1bmN0aW9uKCl7dmFyIHI9dGhpcy5ub2RlcyxzPXRoaXMuaGFuZGxlcyxuPXJbMV0uaGFuZGxlLGE9c1tuXS5rZXk7cmV0dXJuIHRoaXMuc2l6ZT4wJiYoclsxXS5oYW5kbGU9clt0aGlzLnNpemVdLmhhbmRsZSxzW3JbMV0uaGFuZGxlXS5ub2RlPTEsc1tuXS5rZXk9bnVsbCxzW25dLm5vZGU9dGhpcy5mcmVlTGlzdCx0aGlzLmZyZWVMaXN0PW4sLS10aGlzLnNpemUsdGhpcy5zaXplPjAmJnRoaXMuZmxvYXREb3duXygxKSksYX0sZGVsZXRlOmZ1bmN0aW9uKHIpe3ZhciBzPXRoaXMubm9kZXMsbj10aGlzLmhhbmRsZXMsYTtnKHI+PTEmJnI8PXRoaXMubWF4JiZuW3JdLmtleSE9PW51bGwpLGE9bltyXS5ub2RlLHNbYV0uaGFuZGxlPXNbdGhpcy5zaXplXS5oYW5kbGUsbltzW2FdLmhhbmRsZV0ubm9kZT1hLC0tdGhpcy5zaXplLGE8PXRoaXMuc2l6ZSYmKGE8PTF8fHRoaXMubGVxKG5bc1thPj4xXS5oYW5kbGVdLmtleSxuW3NbYV0uaGFuZGxlXS5rZXkpP3RoaXMuZmxvYXREb3duXyhhKTp0aGlzLmZsb2F0VXBfKGEpKSxuW3JdLmtleT1udWxsLG5bcl0ubm9kZT10aGlzLmZyZWVMaXN0LHRoaXMuZnJlZUxpc3Q9cn19O2Z1bmN0aW9uIHgoKXt0aGlzLmVVcD1udWxsLHRoaXMubm9kZVVwPW51bGwsdGhpcy53aW5kaW5nTnVtYmVyPTAsdGhpcy5pbnNpZGU9ITEsdGhpcy5zZW50aW5lbD0hMSx0aGlzLmRpcnR5PSExLHRoaXMuZml4VXBwZXJFZGdlPSExfXZhciBkPXt9O2QucmVnaW9uQmVsb3c9ZnVuY3Rpb24ocil7cmV0dXJuIHIubm9kZVVwLnByZXYua2V5fSxkLnJlZ2lvbkFib3ZlPWZ1bmN0aW9uKHIpe3JldHVybiByLm5vZGVVcC5uZXh0LmtleX0sZC5kZWJ1Z0V2ZW50PWZ1bmN0aW9uKHIpe30sZC5hZGRXaW5kaW5nPWZ1bmN0aW9uKHIscyl7ci53aW5kaW5nKz1zLndpbmRpbmcsci5TeW0ud2luZGluZys9cy5TeW0ud2luZGluZ30sZC5lZGdlTGVxPWZ1bmN0aW9uKHIscyxuKXt2YXIgYT1yLmV2ZW50LGIsSSxPPXMuZVVwLEE9bi5lVXA7aWYoTy5Ec3Q9PT1hKXJldHVybiBBLkRzdD09PWE/by52ZXJ0TGVxKE8uT3JnLEEuT3JnKT9vLmVkZ2VTaWduKEEuRHN0LE8uT3JnLEEuT3JnKTw9MDpvLmVkZ2VTaWduKE8uRHN0LEEuT3JnLE8uT3JnKT49MDpvLmVkZ2VTaWduKEEuRHN0LGEsQS5PcmcpPD0wO2lmKEEuRHN0PT09YSlyZXR1cm4gby5lZGdlU2lnbihPLkRzdCxhLE8uT3JnKT49MDt2YXIgYj1vLmVkZ2VFdmFsKE8uRHN0LGEsTy5PcmcpLEk9by5lZGdlRXZhbChBLkRzdCxhLEEuT3JnKTtyZXR1cm4gYj49SX0sZC5kZWxldGVSZWdpb249ZnVuY3Rpb24ocixzKXtzLmZpeFVwcGVyRWRnZSYmZyhzLmVVcC53aW5kaW5nPT09MCkscy5lVXAuYWN0aXZlUmVnaW9uPW51bGwsci5kaWN0LmRlbGV0ZShzLm5vZGVVcCl9LGQuZml4VXBwZXJFZGdlPWZ1bmN0aW9uKHIscyxuKXtnKHMuZml4VXBwZXJFZGdlKSxyLm1lc2guZGVsZXRlKHMuZVVwKSxzLmZpeFVwcGVyRWRnZT0hMSxzLmVVcD1uLG4uYWN0aXZlUmVnaW9uPXN9LGQudG9wTGVmdFJlZ2lvbj1mdW5jdGlvbihyLHMpe3ZhciBuPXMuZVVwLk9yZyxhO2RvIHM9ZC5yZWdpb25BYm92ZShzKTt3aGlsZShzLmVVcC5Pcmc9PT1uKTtpZihzLmZpeFVwcGVyRWRnZSl7aWYoYT1yLm1lc2guY29ubmVjdChkLnJlZ2lvbkJlbG93KHMpLmVVcC5TeW0scy5lVXAuTG5leHQpLGE9PT1udWxsKXJldHVybiBudWxsO2QuZml4VXBwZXJFZGdlKHIscyxhKSxzPWQucmVnaW9uQWJvdmUocyl9cmV0dXJuIHN9LGQudG9wUmlnaHRSZWdpb249ZnVuY3Rpb24ocil7dmFyIHM9ci5lVXAuRHN0O2RvIHI9ZC5yZWdpb25BYm92ZShyKTt3aGlsZShyLmVVcC5Ec3Q9PT1zKTtyZXR1cm4gcn0sZC5hZGRSZWdpb25CZWxvdz1mdW5jdGlvbihyLHMsbil7dmFyIGE9bmV3IHg7cmV0dXJuIGEuZVVwPW4sYS5ub2RlVXA9ci5kaWN0Lmluc2VydEJlZm9yZShzLm5vZGVVcCxhKSxhLmZpeFVwcGVyRWRnZT0hMSxhLnNlbnRpbmVsPSExLGEuZGlydHk9ITEsbi5hY3RpdmVSZWdpb249YSxhfSxkLmlzV2luZGluZ0luc2lkZT1mdW5jdGlvbihyLHMpe3N3aXRjaChyLndpbmRpbmdSdWxlKXtjYXNlIGkuV0lORElOR19PREQ6cmV0dXJuKHMmMSkhPT0wO2Nhc2UgaS5XSU5ESU5HX05PTlpFUk86cmV0dXJuIHMhPT0wO2Nhc2UgaS5XSU5ESU5HX1BPU0lUSVZFOnJldHVybiBzPjA7Y2FzZSBpLldJTkRJTkdfTkVHQVRJVkU6cmV0dXJuIHM8MDtjYXNlIGkuV0lORElOR19BQlNfR0VRX1RXTzpyZXR1cm4gcz49Mnx8czw9LTJ9cmV0dXJuIGcoITEpLCExfSxkLmNvbXB1dGVXaW5kaW5nPWZ1bmN0aW9uKHIscyl7cy53aW5kaW5nTnVtYmVyPWQucmVnaW9uQWJvdmUocykud2luZGluZ051bWJlcitzLmVVcC53aW5kaW5nLHMuaW5zaWRlPWQuaXNXaW5kaW5nSW5zaWRlKHIscy53aW5kaW5nTnVtYmVyKX0sZC5maW5pc2hSZWdpb249ZnVuY3Rpb24ocixzKXt2YXIgbj1zLmVVcCxhPW4uTGZhY2U7YS5pbnNpZGU9cy5pbnNpZGUsYS5hbkVkZ2U9bixkLmRlbGV0ZVJlZ2lvbihyLHMpfSxkLmZpbmlzaExlZnRSZWdpb25zPWZ1bmN0aW9uKHIscyxuKXtmb3IodmFyIGEsYixPPW51bGwsQT1zLGI9cy5lVXA7QSE9PW47KXtpZihBLmZpeFVwcGVyRWRnZT0hMSxPPWQucmVnaW9uQmVsb3coQSksYT1PLmVVcCxhLk9yZyE9Yi5Pcmcpe2lmKCFPLmZpeFVwcGVyRWRnZSl7ZC5maW5pc2hSZWdpb24ocixBKTticmVha31hPXIubWVzaC5jb25uZWN0KGIuTHByZXYsYS5TeW0pLGQuZml4VXBwZXJFZGdlKHIsTyxhKX1iLk9uZXh0IT09YSYmKHIubWVzaC5zcGxpY2UoYS5PcHJldixhKSxyLm1lc2guc3BsaWNlKGIsYSkpLGQuZmluaXNoUmVnaW9uKHIsQSksYj1PLmVVcCxBPU99cmV0dXJuIGJ9LGQuYWRkUmlnaHRFZGdlcz1mdW5jdGlvbihyLHMsbixhLE8sQSl7dmFyIGIsSSxQLEQsTD0hMDtQPW47ZG8gZyhvLnZlcnRMZXEoUC5PcmcsUC5Ec3QpKSxkLmFkZFJlZ2lvbkJlbG93KHIscyxQLlN5bSksUD1QLk9uZXh0O3doaWxlKFAhPT1hKTtmb3IoTz09PW51bGwmJihPPWQucmVnaW9uQmVsb3cocykuZVVwLlJwcmV2KSxJPXMsRD1PO2I9ZC5yZWdpb25CZWxvdyhJKSxQPWIuZVVwLlN5bSxQLk9yZz09PUQuT3JnOylQLk9uZXh0IT09RCYmKHIubWVzaC5zcGxpY2UoUC5PcHJldixQKSxyLm1lc2guc3BsaWNlKEQuT3ByZXYsUCkpLGIud2luZGluZ051bWJlcj1JLndpbmRpbmdOdW1iZXItUC53aW5kaW5nLGIuaW5zaWRlPWQuaXNXaW5kaW5nSW5zaWRlKHIsYi53aW5kaW5nTnVtYmVyKSxJLmRpcnR5PSEwLCFMJiZkLmNoZWNrRm9yUmlnaHRTcGxpY2UocixJKSYmKGQuYWRkV2luZGluZyhQLEQpLGQuZGVsZXRlUmVnaW9uKHIsSSksci5tZXNoLmRlbGV0ZShEKSksTD0hMSxJPWIsRD1QO0kuZGlydHk9ITAsZyhJLndpbmRpbmdOdW1iZXItUC53aW5kaW5nPT09Yi53aW5kaW5nTnVtYmVyKSxBJiZkLndhbGtEaXJ0eVJlZ2lvbnMocixJKX0sZC5zcGxpY2VNZXJnZVZlcnRpY2VzPWZ1bmN0aW9uKHIscyxuKXtyLm1lc2guc3BsaWNlKHMsbil9LGQudmVydGV4V2VpZ2h0cz1mdW5jdGlvbihyLHMsbil7dmFyIGE9by52ZXJ0TDFkaXN0KHMsciksTz1vLnZlcnRMMWRpc3QobixyKSxBPS41Kk8vKGErTyksYj0uNSphLyhhK08pO3IuY29vcmRzWzBdKz1BKnMuY29vcmRzWzBdK2Iqbi5jb29yZHNbMF0sci5jb29yZHNbMV0rPUEqcy5jb29yZHNbMV0rYipuLmNvb3Jkc1sxXSxyLmNvb3Jkc1syXSs9QSpzLmNvb3Jkc1syXStiKm4uY29vcmRzWzJdfSxkLmdldEludGVyc2VjdERhdGE9ZnVuY3Rpb24ocixzLG4sYSxPLEEpe3MuY29vcmRzWzBdPXMuY29vcmRzWzFdPXMuY29vcmRzWzJdPTAscy5pZHg9LTEsZC52ZXJ0ZXhXZWlnaHRzKHMsbixhKSxkLnZlcnRleFdlaWdodHMocyxPLEEpfSxkLmNoZWNrRm9yUmlnaHRTcGxpY2U9ZnVuY3Rpb24ocixzKXt2YXIgbj1kLnJlZ2lvbkJlbG93KHMpLGE9cy5lVXAsTz1uLmVVcDtpZihvLnZlcnRMZXEoYS5PcmcsTy5PcmcpKXtpZihvLmVkZ2VTaWduKE8uRHN0LGEuT3JnLE8uT3JnKT4wKXJldHVybiExO28udmVydEVxKGEuT3JnLE8uT3JnKT9hLk9yZyE9PU8uT3JnJiYoci5wcS5kZWxldGUoYS5PcmcucHFIYW5kbGUpLGQuc3BsaWNlTWVyZ2VWZXJ0aWNlcyhyLE8uT3ByZXYsYSkpOihyLm1lc2guc3BsaXRFZGdlKE8uU3ltKSxyLm1lc2guc3BsaWNlKGEsTy5PcHJldikscy5kaXJ0eT1uLmRpcnR5PSEwKX1lbHNle2lmKG8uZWRnZVNpZ24oYS5Ec3QsTy5PcmcsYS5PcmcpPDApcmV0dXJuITE7ZC5yZWdpb25BYm92ZShzKS5kaXJ0eT1zLmRpcnR5PSEwLHIubWVzaC5zcGxpdEVkZ2UoYS5TeW0pLHIubWVzaC5zcGxpY2UoTy5PcHJldixhKX1yZXR1cm4hMH0sZC5jaGVja0ZvckxlZnRTcGxpY2U9ZnVuY3Rpb24ocixzKXt2YXIgbj1kLnJlZ2lvbkJlbG93KHMpLGE9cy5lVXAsTz1uLmVVcCxBO2lmKGcoIW8udmVydEVxKGEuRHN0LE8uRHN0KSksby52ZXJ0TGVxKGEuRHN0LE8uRHN0KSl7aWYoby5lZGdlU2lnbihhLkRzdCxPLkRzdCxhLk9yZyk8MClyZXR1cm4hMTtkLnJlZ2lvbkFib3ZlKHMpLmRpcnR5PXMuZGlydHk9ITAsQT1yLm1lc2guc3BsaXRFZGdlKGEpLHIubWVzaC5zcGxpY2UoTy5TeW0sQSksQS5MZmFjZS5pbnNpZGU9cy5pbnNpZGV9ZWxzZXtpZihvLmVkZ2VTaWduKE8uRHN0LGEuRHN0LE8uT3JnKT4wKXJldHVybiExO3MuZGlydHk9bi5kaXJ0eT0hMCxBPXIubWVzaC5zcGxpdEVkZ2UoTyksci5tZXNoLnNwbGljZShhLkxuZXh0LE8uU3ltKSxBLlJmYWNlLmluc2lkZT1zLmluc2lkZX1yZXR1cm4hMH0sZC5jaGVja0ZvckludGVyc2VjdD1mdW5jdGlvbihyLHMpe3ZhciBuPWQucmVnaW9uQmVsb3cocyksYT1zLmVVcCxPPW4uZVVwLEE9YS5PcmcsYj1PLk9yZyxJPWEuRHN0LFA9Ty5Ec3QsRCxMLFM9bmV3IHYsVCxqO2lmKGcoIW8udmVydEVxKFAsSSkpLGcoby5lZGdlU2lnbihJLHIuZXZlbnQsQSk8PTApLGcoby5lZGdlU2lnbihQLHIuZXZlbnQsYik+PTApLGcoQSE9PXIuZXZlbnQmJmIhPT1yLmV2ZW50KSxnKCFzLmZpeFVwcGVyRWRnZSYmIW4uZml4VXBwZXJFZGdlKSxBPT09Ynx8KEQ9TWF0aC5taW4oQS50LEkudCksTD1NYXRoLm1heChiLnQsUC50KSxEPkwpKXJldHVybiExO2lmKG8udmVydExlcShBLGIpKXtpZihvLmVkZ2VTaWduKFAsQSxiKT4wKXJldHVybiExfWVsc2UgaWYoby5lZGdlU2lnbihJLGIsQSk8MClyZXR1cm4hMTtyZXR1cm4gZC5kZWJ1Z0V2ZW50KHIpLG8uaW50ZXJzZWN0KEksQSxQLGIsUyksZyhNYXRoLm1pbihBLnQsSS50KTw9Uy50KSxnKFMudDw9TWF0aC5tYXgoYi50LFAudCkpLGcoTWF0aC5taW4oUC5zLEkucyk8PVMucyksZyhTLnM8PU1hdGgubWF4KGIucyxBLnMpKSxvLnZlcnRMZXEoUyxyLmV2ZW50KSYmKFMucz1yLmV2ZW50LnMsUy50PXIuZXZlbnQudCksVD1vLnZlcnRMZXEoQSxiKT9BOmIsby52ZXJ0TGVxKFQsUykmJihTLnM9VC5zLFMudD1ULnQpLG8udmVydEVxKFMsQSl8fG8udmVydEVxKFMsYik/KGQuY2hlY2tGb3JSaWdodFNwbGljZShyLHMpLCExKTohby52ZXJ0RXEoSSxyLmV2ZW50KSYmby5lZGdlU2lnbihJLHIuZXZlbnQsUyk+PTB8fCFvLnZlcnRFcShQLHIuZXZlbnQpJiZvLmVkZ2VTaWduKFAsci5ldmVudCxTKTw9MD9QPT09ci5ldmVudD8oci5tZXNoLnNwbGl0RWRnZShhLlN5bSksci5tZXNoLnNwbGljZShPLlN5bSxhKSxzPWQudG9wTGVmdFJlZ2lvbihyLHMpLGE9ZC5yZWdpb25CZWxvdyhzKS5lVXAsZC5maW5pc2hMZWZ0UmVnaW9ucyhyLGQucmVnaW9uQmVsb3cocyksbiksZC5hZGRSaWdodEVkZ2VzKHIscyxhLk9wcmV2LGEsYSwhMCksITApOkk9PT1yLmV2ZW50PyhyLm1lc2guc3BsaXRFZGdlKE8uU3ltKSxyLm1lc2guc3BsaWNlKGEuTG5leHQsTy5PcHJldiksbj1zLHM9ZC50b3BSaWdodFJlZ2lvbihzKSxqPWQucmVnaW9uQmVsb3cocykuZVVwLlJwcmV2LG4uZVVwPU8uT3ByZXYsTz1kLmZpbmlzaExlZnRSZWdpb25zKHIsbixudWxsKSxkLmFkZFJpZ2h0RWRnZXMocixzLE8uT25leHQsYS5ScHJldixqLCEwKSwhMCk6KG8uZWRnZVNpZ24oSSxyLmV2ZW50LFMpPj0wJiYoZC5yZWdpb25BYm92ZShzKS5kaXJ0eT1zLmRpcnR5PSEwLHIubWVzaC5zcGxpdEVkZ2UoYS5TeW0pLGEuT3JnLnM9ci5ldmVudC5zLGEuT3JnLnQ9ci5ldmVudC50KSxvLmVkZ2VTaWduKFAsci5ldmVudCxTKTw9MCYmKHMuZGlydHk9bi5kaXJ0eT0hMCxyLm1lc2guc3BsaXRFZGdlKE8uU3ltKSxPLk9yZy5zPXIuZXZlbnQucyxPLk9yZy50PXIuZXZlbnQudCksITEpOihyLm1lc2guc3BsaXRFZGdlKGEuU3ltKSxyLm1lc2guc3BsaXRFZGdlKE8uU3ltKSxyLm1lc2guc3BsaWNlKE8uT3ByZXYsYSksYS5Pcmcucz1TLnMsYS5PcmcudD1TLnQsYS5PcmcucHFIYW5kbGU9ci5wcS5pbnNlcnQoYS5PcmcpLGQuZ2V0SW50ZXJzZWN0RGF0YShyLGEuT3JnLEEsSSxiLFApLGQucmVnaW9uQWJvdmUocykuZGlydHk9cy5kaXJ0eT1uLmRpcnR5PSEwLCExKX0sZC53YWxrRGlydHlSZWdpb25zPWZ1bmN0aW9uKHIscyl7Zm9yKHZhciBuPWQucmVnaW9uQmVsb3cocyksYSxPOzspe2Zvcig7bi5kaXJ0eTspcz1uLG49ZC5yZWdpb25CZWxvdyhuKTtpZighcy5kaXJ0eSYmKG49cyxzPWQucmVnaW9uQWJvdmUocykscz09PW51bGx8fCFzLmRpcnR5KSlyZXR1cm47aWYocy5kaXJ0eT0hMSxhPXMuZVVwLE89bi5lVXAsYS5Ec3QhPT1PLkRzdCYmZC5jaGVja0ZvckxlZnRTcGxpY2UocixzKSYmKG4uZml4VXBwZXJFZGdlPyhkLmRlbGV0ZVJlZ2lvbihyLG4pLHIubWVzaC5kZWxldGUoTyksbj1kLnJlZ2lvbkJlbG93KHMpLE89bi5lVXApOnMuZml4VXBwZXJFZGdlJiYoZC5kZWxldGVSZWdpb24ocixzKSxyLm1lc2guZGVsZXRlKGEpLHM9ZC5yZWdpb25BYm92ZShuKSxhPXMuZVVwKSksYS5PcmchPT1PLk9yZylpZihhLkRzdCE9PU8uRHN0JiYhcy5maXhVcHBlckVkZ2UmJiFuLmZpeFVwcGVyRWRnZSYmKGEuRHN0PT09ci5ldmVudHx8Ty5Ec3Q9PT1yLmV2ZW50KSl7aWYoZC5jaGVja0ZvckludGVyc2VjdChyLHMpKXJldHVybn1lbHNlIGQuY2hlY2tGb3JSaWdodFNwbGljZShyLHMpO2EuT3JnPT09Ty5PcmcmJmEuRHN0PT09Ty5Ec3QmJihkLmFkZFdpbmRpbmcoTyxhKSxkLmRlbGV0ZVJlZ2lvbihyLHMpLHIubWVzaC5kZWxldGUoYSkscz1kLnJlZ2lvbkFib3ZlKG4pKX19LGQuY29ubmVjdFJpZ2h0VmVydGV4PWZ1bmN0aW9uKHIscyxuKXt2YXIgYSxPPW4uT25leHQsQT1kLnJlZ2lvbkJlbG93KHMpLGI9cy5lVXAsST1BLmVVcCxQPSExO2lmKGIuRHN0IT09SS5Ec3QmJmQuY2hlY2tGb3JJbnRlcnNlY3QocixzKSxvLnZlcnRFcShiLk9yZyxyLmV2ZW50KSYmKHIubWVzaC5zcGxpY2UoTy5PcHJldixiKSxzPWQudG9wTGVmdFJlZ2lvbihyLHMpLE89ZC5yZWdpb25CZWxvdyhzKS5lVXAsZC5maW5pc2hMZWZ0UmVnaW9ucyhyLGQucmVnaW9uQmVsb3cocyksQSksUD0hMCksby52ZXJ0RXEoSS5Pcmcsci5ldmVudCkmJihyLm1lc2guc3BsaWNlKG4sSS5PcHJldiksbj1kLmZpbmlzaExlZnRSZWdpb25zKHIsQSxudWxsKSxQPSEwKSxQKXtkLmFkZFJpZ2h0RWRnZXMocixzLG4uT25leHQsTyxPLCEwKTtyZXR1cm59by52ZXJ0TGVxKEkuT3JnLGIuT3JnKT9hPUkuT3ByZXY6YT1iLGE9ci5tZXNoLmNvbm5lY3Qobi5McHJldixhKSxkLmFkZFJpZ2h0RWRnZXMocixzLGEsYS5PbmV4dCxhLk9uZXh0LCExKSxhLlN5bS5hY3RpdmVSZWdpb24uZml4VXBwZXJFZGdlPSEwLGQud2Fsa0RpcnR5UmVnaW9ucyhyLHMpfSxkLmNvbm5lY3RMZWZ0RGVnZW5lcmF0ZT1mdW5jdGlvbihyLHMsbil7dmFyIGEsTyxBLGIsSTtpZihhPXMuZVVwLG8udmVydEVxKGEuT3JnLG4pKXtnKCExKSxkLnNwbGljZU1lcmdlVmVydGljZXMocixhLG4uYW5FZGdlKTtyZXR1cm59aWYoIW8udmVydEVxKGEuRHN0LG4pKXtyLm1lc2guc3BsaXRFZGdlKGEuU3ltKSxzLmZpeFVwcGVyRWRnZSYmKHIubWVzaC5kZWxldGUoYS5PbmV4dCkscy5maXhVcHBlckVkZ2U9ITEpLHIubWVzaC5zcGxpY2Uobi5hbkVkZ2UsYSksZC5zd2VlcEV2ZW50KHIsbik7cmV0dXJufWcoITEpLHM9ZC50b3BSaWdodFJlZ2lvbihzKSxJPWQucmVnaW9uQmVsb3cocyksQT1JLmVVcC5TeW0sTz1iPUEuT25leHQsSS5maXhVcHBlckVkZ2UmJihnKE8hPT1BKSxkLmRlbGV0ZVJlZ2lvbihyLEkpLHIubWVzaC5kZWxldGUoQSksQT1PLk9wcmV2KSxyLm1lc2guc3BsaWNlKG4uYW5FZGdlLEEpLG8uZWRnZUdvZXNMZWZ0KE8pfHwoTz1udWxsKSxkLmFkZFJpZ2h0RWRnZXMocixzLEEuT25leHQsYixPLCEwKX0sZC5jb25uZWN0TGVmdFZlcnRleD1mdW5jdGlvbihyLHMpe3ZhciBuLGEsTyxBLGIsSSxQPW5ldyB4O2lmKFAuZVVwPXMuYW5FZGdlLlN5bSxuPXIuZGljdC5zZWFyY2goUCkua2V5LGE9ZC5yZWdpb25CZWxvdyhuKSwhIWEpe2lmKEE9bi5lVXAsYj1hLmVVcCxvLmVkZ2VTaWduKEEuRHN0LHMsQS5PcmcpPT09MCl7ZC5jb25uZWN0TGVmdERlZ2VuZXJhdGUocixuLHMpO3JldHVybn1pZihPPW8udmVydExlcShiLkRzdCxBLkRzdCk/bjphLG4uaW5zaWRlfHxPLmZpeFVwcGVyRWRnZSl7aWYoTz09PW4pST1yLm1lc2guY29ubmVjdChzLmFuRWRnZS5TeW0sQS5MbmV4dCk7ZWxzZXt2YXIgRD1yLm1lc2guY29ubmVjdChiLkRuZXh0LHMuYW5FZGdlKTtJPUQuU3ltfU8uZml4VXBwZXJFZGdlP2QuZml4VXBwZXJFZGdlKHIsTyxJKTpkLmNvbXB1dGVXaW5kaW5nKHIsZC5hZGRSZWdpb25CZWxvdyhyLG4sSSkpLGQuc3dlZXBFdmVudChyLHMpfWVsc2UgZC5hZGRSaWdodEVkZ2VzKHIsbixzLmFuRWRnZSxzLmFuRWRnZSxudWxsLCEwKX19LGQuc3dlZXBFdmVudD1mdW5jdGlvbihyLHMpe3IuZXZlbnQ9cyxkLmRlYnVnRXZlbnQocik7Zm9yKHZhciBuPXMuYW5FZGdlO24uYWN0aXZlUmVnaW9uPT09bnVsbDspaWYobj1uLk9uZXh0LG49PT1zLmFuRWRnZSl7ZC5jb25uZWN0TGVmdFZlcnRleChyLHMpO3JldHVybn12YXIgYT1kLnRvcExlZnRSZWdpb24ocixuLmFjdGl2ZVJlZ2lvbik7ZyhhIT09bnVsbCk7dmFyIE89ZC5yZWdpb25CZWxvdyhhKSxBPU8uZVVwLGI9ZC5maW5pc2hMZWZ0UmVnaW9ucyhyLE8sbnVsbCk7Yi5PbmV4dD09PUE/ZC5jb25uZWN0UmlnaHRWZXJ0ZXgocixhLGIpOmQuYWRkUmlnaHRFZGdlcyhyLGEsYi5PbmV4dCxBLEEsITApfSxkLmFkZFNlbnRpbmVsPWZ1bmN0aW9uKHIscyxuLGEpe3ZhciBPPW5ldyB4LEE9ci5tZXNoLm1ha2VFZGdlKCk7QS5Pcmcucz1uLEEuT3JnLnQ9YSxBLkRzdC5zPXMsQS5Ec3QudD1hLHIuZXZlbnQ9QS5Ec3QsTy5lVXA9QSxPLndpbmRpbmdOdW1iZXI9MCxPLmluc2lkZT0hMSxPLmZpeFVwcGVyRWRnZT0hMSxPLnNlbnRpbmVsPSEwLE8uZGlydHk9ITEsTy5ub2RlVXA9ci5kaWN0Lmluc2VydChPKX0sZC5pbml0RWRnZURpY3Q9ZnVuY3Rpb24ocil7ci5kaWN0PW5ldyBsKHIsZC5lZGdlTGVxKTt2YXIgcz1yLmJtYXhbMF0tci5ibWluWzBdLG49ci5ibWF4WzFdLXIuYm1pblsxXSxhPXIuYm1pblswXS1zLE89ci5ibWF4WzBdK3MsQT1yLmJtaW5bMV0tbixiPXIuYm1heFsxXStuO2QuYWRkU2VudGluZWwocixhLE8sQSksZC5hZGRTZW50aW5lbChyLGEsTyxiKX0sZC5kb25lRWRnZURpY3Q9ZnVuY3Rpb24ocil7Zm9yKHZhciBzLG49MDsocz1yLmRpY3QubWluKCkua2V5KSE9PW51bGw7KXMuc2VudGluZWx8fChnKHMuZml4VXBwZXJFZGdlKSxnKCsrbj09PTEpKSxnKHMud2luZGluZ051bWJlcj09PTApLGQuZGVsZXRlUmVnaW9uKHIscyl9LGQucmVtb3ZlRGVnZW5lcmF0ZUVkZ2VzPWZ1bmN0aW9uKHIpe3ZhciBzLG4sYSxPPXIubWVzaC5lSGVhZDtmb3Iocz1PLm5leHQ7cyE9PU87cz1uKW49cy5uZXh0LGE9cy5MbmV4dCxvLnZlcnRFcShzLk9yZyxzLkRzdCkmJnMuTG5leHQuTG5leHQhPT1zJiYoZC5zcGxpY2VNZXJnZVZlcnRpY2VzKHIsYSxzKSxyLm1lc2guZGVsZXRlKHMpLHM9YSxhPXMuTG5leHQpLGEuTG5leHQ9PT1zJiYoYSE9PXMmJigoYT09PW58fGE9PT1uLlN5bSkmJihuPW4ubmV4dCksci5tZXNoLmRlbGV0ZShhKSksKHM9PT1ufHxzPT09bi5TeW0pJiYobj1uLm5leHQpLHIubWVzaC5kZWxldGUocykpfSxkLmluaXRQcmlvcml0eVE9ZnVuY3Rpb24ocil7dmFyIHMsbixhLE89MDtmb3IoYT1yLm1lc2gudkhlYWQsbj1hLm5leHQ7biE9PWE7bj1uLm5leHQpTysrO2ZvcihPKz04LHM9ci5wcT1uZXcgQyhPLG8udmVydExlcSksYT1yLm1lc2gudkhlYWQsbj1hLm5leHQ7biE9PWE7bj1uLm5leHQpbi5wcUhhbmRsZT1zLmluc2VydChuKTtyZXR1cm4gbiE9PWE/ITE6KHMuaW5pdCgpLCEwKX0sZC5kb25lUHJpb3JpdHlRPWZ1bmN0aW9uKHIpe3IucHE9bnVsbH0sZC5yZW1vdmVEZWdlbmVyYXRlRmFjZXM9ZnVuY3Rpb24ocixzKXt2YXIgbixhLE87Zm9yKG49cy5mSGVhZC5uZXh0O24hPT1zLmZIZWFkO249YSlhPW4ubmV4dCxPPW4uYW5FZGdlLGcoTy5MbmV4dCE9PU8pLE8uTG5leHQuTG5leHQ9PT1PJiYoZC5hZGRXaW5kaW5nKE8uT25leHQsTyksci5tZXNoLmRlbGV0ZShPKSk7cmV0dXJuITB9LGQuY29tcHV0ZUludGVyaW9yPWZ1bmN0aW9uKHIpe3ZhciBzLG47aWYoZC5yZW1vdmVEZWdlbmVyYXRlRWRnZXMociksIWQuaW5pdFByaW9yaXR5UShyKSlyZXR1cm4hMTtmb3IoZC5pbml0RWRnZURpY3Qocik7KHM9ci5wcS5leHRyYWN0TWluKCkpIT09bnVsbDspe2Zvcig7bj1yLnBxLm1pbigpLCEobj09PW51bGx8fCFvLnZlcnRFcShuLHMpKTspbj1yLnBxLmV4dHJhY3RNaW4oKSxkLnNwbGljZU1lcmdlVmVydGljZXMocixzLmFuRWRnZSxuLmFuRWRnZSk7ZC5zd2VlcEV2ZW50KHIscyl9cmV0dXJuIHIuZXZlbnQ9ci5kaWN0Lm1pbigpLmtleS5lVXAuT3JnLGQuZGVidWdFdmVudChyKSxkLmRvbmVFZGdlRGljdChyKSxkLmRvbmVQcmlvcml0eVEociksZC5yZW1vdmVEZWdlbmVyYXRlRmFjZXMocixyLm1lc2gpPyhyLm1lc2guY2hlY2soKSwhMCk6ITF9O2Z1bmN0aW9uIHkoKXt0aGlzLm1lc2g9bnVsbCx0aGlzLm5vcm1hbD1bMCwwLDBdLHRoaXMuc1VuaXQ9WzAsMCwwXSx0aGlzLnRVbml0PVswLDAsMF0sdGhpcy5ibWluPVswLDBdLHRoaXMuYm1heD1bMCwwXSx0aGlzLndpbmRpbmdSdWxlPWkuV0lORElOR19PREQsdGhpcy5kaWN0PW51bGwsdGhpcy5wcT1udWxsLHRoaXMuZXZlbnQ9bnVsbCx0aGlzLnZlcnRleEluZGV4Q291bnRlcj0wLHRoaXMudmVydGljZXM9W10sdGhpcy52ZXJ0ZXhJbmRpY2VzPVtdLHRoaXMudmVydGV4Q291bnQ9MCx0aGlzLmVsZW1lbnRzPVtdLHRoaXMuZWxlbWVudENvdW50PTB9eS5wcm90b3R5cGU9e2RvdF86ZnVuY3Rpb24ocixzKXtyZXR1cm4gclswXSpzWzBdK3JbMV0qc1sxXStyWzJdKnNbMl19LG5vcm1hbGl6ZV86ZnVuY3Rpb24ocil7dmFyIHM9clswXSpyWzBdK3JbMV0qclsxXStyWzJdKnJbMl07ZyhzPjApLHM9TWF0aC5zcXJ0KHMpLHJbMF0vPXMsclsxXS89cyxyWzJdLz1zfSxsb25nQXhpc186ZnVuY3Rpb24ocil7dmFyIHM9MDtyZXR1cm4gTWF0aC5hYnMoclsxXSk+TWF0aC5hYnMoclswXSkmJihzPTEpLE1hdGguYWJzKHJbMl0pPk1hdGguYWJzKHJbc10pJiYocz0yKSxzfSxjb21wdXRlTm9ybWFsXzpmdW5jdGlvbihyKXt2YXIgcyxuLGEsTyxBLGIsST1bMCwwLDBdLFA9WzAsMCwwXSxEPVswLDAsMF0sTD1bMCwwLDBdLFM9WzAsMCwwXSxUPVtudWxsLG51bGwsbnVsbF0saj1bbnVsbCxudWxsLG51bGxdLCQ9dGhpcy5tZXNoLnZIZWFkLHc7Zm9yKHM9JC5uZXh0LHc9MDt3PDM7Kyt3KU89cy5jb29yZHNbd10sUFt3XT1PLGpbd109cyxJW3ddPU8sVFt3XT1zO2ZvcihzPSQubmV4dDtzIT09JDtzPXMubmV4dClmb3Iodz0wO3c8MzsrK3cpTz1zLmNvb3Jkc1t3XSxPPFBbd10mJihQW3ddPU8salt3XT1zKSxPPklbd10mJihJW3ddPU8sVFt3XT1zKTtpZih3PTAsSVsxXS1QWzFdPklbMF0tUFswXSYmKHc9MSksSVsyXS1QWzJdPklbd10tUFt3XSYmKHc9MiksUFt3XT49SVt3XSl7clswXT0wLHJbMV09MCxyWzJdPTE7cmV0dXJufWZvcihiPTAsbj1qW3ddLGE9VFt3XSxEWzBdPW4uY29vcmRzWzBdLWEuY29vcmRzWzBdLERbMV09bi5jb29yZHNbMV0tYS5jb29yZHNbMV0sRFsyXT1uLmNvb3Jkc1syXS1hLmNvb3Jkc1syXSxzPSQubmV4dDtzIT09JDtzPXMubmV4dClMWzBdPXMuY29vcmRzWzBdLWEuY29vcmRzWzBdLExbMV09cy5jb29yZHNbMV0tYS5jb29yZHNbMV0sTFsyXT1zLmNvb3Jkc1syXS1hLmNvb3Jkc1syXSxTWzBdPURbMV0qTFsyXS1EWzJdKkxbMV0sU1sxXT1EWzJdKkxbMF0tRFswXSpMWzJdLFNbMl09RFswXSpMWzFdLURbMV0qTFswXSxBPVNbMF0qU1swXStTWzFdKlNbMV0rU1syXSpTWzJdLEE+YiYmKGI9QSxyWzBdPVNbMF0sclsxXT1TWzFdLHJbMl09U1syXSk7Yjw9MCYmKHJbMF09clsxXT1yWzJdPTAsclt0aGlzLmxvbmdBeGlzXyhEKV09MSl9LGNoZWNrT3JpZW50YXRpb25fOmZ1bmN0aW9uKCl7dmFyIHIscyxuPXRoaXMubWVzaC5mSGVhZCxhLE89dGhpcy5tZXNoLnZIZWFkLEE7Zm9yKHI9MCxzPW4ubmV4dDtzIT09bjtzPXMubmV4dClpZihBPXMuYW5FZGdlLCEoQS53aW5kaW5nPD0wKSlkbyByKz0oQS5Pcmcucy1BLkRzdC5zKSooQS5PcmcudCtBLkRzdC50KSxBPUEuTG5leHQ7d2hpbGUoQSE9PXMuYW5FZGdlKTtpZihyPDApe2ZvcihhPU8ubmV4dDthIT09TzthPWEubmV4dClhLnQ9LWEudDt0aGlzLnRVbml0WzBdPS10aGlzLnRVbml0WzBdLHRoaXMudFVuaXRbMV09LXRoaXMudFVuaXRbMV0sdGhpcy50VW5pdFsyXT0tdGhpcy50VW5pdFsyXX19LHByb2plY3RQb2x5Z29uXzpmdW5jdGlvbigpe3ZhciByLHM9dGhpcy5tZXNoLnZIZWFkLG49WzAsMCwwXSxhLE8sQSxiLEk9ITE7Zm9yKG5bMF09dGhpcy5ub3JtYWxbMF0sblsxXT10aGlzLm5vcm1hbFsxXSxuWzJdPXRoaXMubm9ybWFsWzJdLG5bMF09PT0wJiZuWzFdPT09MCYmblsyXT09PTAmJih0aGlzLmNvbXB1dGVOb3JtYWxfKG4pLEk9ITApLGE9dGhpcy5zVW5pdCxPPXRoaXMudFVuaXQsQT10aGlzLmxvbmdBeGlzXyhuKSxhW0FdPTAsYVsoQSsxKSUzXT0xLGFbKEErMiklM109MCxPW0FdPTAsT1soQSsxKSUzXT0wLE9bKEErMiklM109bltBXT4wPzE6LTEscj1zLm5leHQ7ciE9PXM7cj1yLm5leHQpci5zPXRoaXMuZG90XyhyLmNvb3JkcyxhKSxyLnQ9dGhpcy5kb3RfKHIuY29vcmRzLE8pO2ZvcihJJiZ0aGlzLmNoZWNrT3JpZW50YXRpb25fKCksYj0hMCxyPXMubmV4dDtyIT09cztyPXIubmV4dCliPyh0aGlzLmJtaW5bMF09dGhpcy5ibWF4WzBdPXIucyx0aGlzLmJtaW5bMV09dGhpcy5ibWF4WzFdPXIudCxiPSExKTooci5zPHRoaXMuYm1pblswXSYmKHRoaXMuYm1pblswXT1yLnMpLHIucz50aGlzLmJtYXhbMF0mJih0aGlzLmJtYXhbMF09ci5zKSxyLnQ8dGhpcy5ibWluWzFdJiYodGhpcy5ibWluWzFdPXIudCksci50PnRoaXMuYm1heFsxXSYmKHRoaXMuYm1heFsxXT1yLnQpKX0sYWRkV2luZGluZ186ZnVuY3Rpb24ocixzKXtyLndpbmRpbmcrPXMud2luZGluZyxyLlN5bS53aW5kaW5nKz1zLlN5bS53aW5kaW5nfSx0ZXNzZWxsYXRlTW9ub1JlZ2lvbl86ZnVuY3Rpb24ocixzKXt2YXIgbixhO2ZvcihuPXMuYW5FZGdlLGcobi5MbmV4dCE9PW4mJm4uTG5leHQuTG5leHQhPT1uKTtvLnZlcnRMZXEobi5Ec3Qsbi5PcmcpO249bi5McHJldik7Zm9yKDtvLnZlcnRMZXEobi5Pcmcsbi5Ec3QpO249bi5MbmV4dCk7Zm9yKGE9bi5McHJldjtuLkxuZXh0IT09YTspaWYoby52ZXJ0TGVxKG4uRHN0LGEuT3JnKSl7Zm9yKDthLkxuZXh0IT09biYmKG8uZWRnZUdvZXNMZWZ0KGEuTG5leHQpfHxvLmVkZ2VTaWduKGEuT3JnLGEuRHN0LGEuTG5leHQuRHN0KTw9MCk7KXt2YXIgTz1yLmNvbm5lY3QoYS5MbmV4dCxhKTthPU8uU3ltfWE9YS5McHJldn1lbHNle2Zvcig7YS5MbmV4dCE9PW4mJihvLmVkZ2VHb2VzUmlnaHQobi5McHJldil8fG8uZWRnZVNpZ24obi5Ec3Qsbi5Pcmcsbi5McHJldi5PcmcpPj0wKTspe3ZhciBPPXIuY29ubmVjdChuLG4uTHByZXYpO249Ty5TeW19bj1uLkxuZXh0fWZvcihnKGEuTG5leHQhPT1uKTthLkxuZXh0LkxuZXh0IT09bjspe3ZhciBPPXIuY29ubmVjdChhLkxuZXh0LGEpO2E9Ty5TeW19cmV0dXJuITB9LHRlc3NlbGxhdGVJbnRlcmlvcl86ZnVuY3Rpb24ocil7dmFyIHMsbjtmb3Iocz1yLmZIZWFkLm5leHQ7cyE9PXIuZkhlYWQ7cz1uKWlmKG49cy5uZXh0LHMuaW5zaWRlJiYhdGhpcy50ZXNzZWxsYXRlTW9ub1JlZ2lvbl8ocixzKSlyZXR1cm4hMTtyZXR1cm4hMH0sZGlzY2FyZEV4dGVyaW9yXzpmdW5jdGlvbihyKXt2YXIgcyxuO2ZvcihzPXIuZkhlYWQubmV4dDtzIT09ci5mSGVhZDtzPW4pbj1zLm5leHQscy5pbnNpZGV8fHIuemFwRmFjZShzKX0sc2V0V2luZGluZ051bWJlcl86ZnVuY3Rpb24ocixzLG4pe3ZhciBhLE87Zm9yKGE9ci5lSGVhZC5uZXh0O2EhPT1yLmVIZWFkO2E9TylPPWEubmV4dCxhLlJmYWNlLmluc2lkZSE9PWEuTGZhY2UuaW5zaWRlP2Eud2luZGluZz1hLkxmYWNlLmluc2lkZT9zOi1zOm4/ci5kZWxldGUoYSk6YS53aW5kaW5nPTB9LGdldE5laWdoYm91ckZhY2VfOmZ1bmN0aW9uKHIpe3JldHVybiFyLlJmYWNlfHwhci5SZmFjZS5pbnNpZGU/LTE6ci5SZmFjZS5ufSxvdXRwdXRQb2x5bWVzaF86ZnVuY3Rpb24ocixzLG4sYSl7dmFyIE8sQSxiLEk9MCxQPTAsRCxMO2ZvcihuPjMmJnIubWVyZ2VDb252ZXhGYWNlcyhuKSxPPXIudkhlYWQubmV4dDtPIT09ci52SGVhZDtPPU8ubmV4dClPLm49LTE7Zm9yKEE9ci5mSGVhZC5uZXh0O0EhPT1yLmZIZWFkO0E9QS5uZXh0KWlmKEEubj0tMSwhIUEuaW5zaWRlKXtiPUEuYW5FZGdlLEQ9MDtkbyBPPWIuT3JnLE8ubj09PS0xJiYoTy5uPVAsUCsrKSxEKyssYj1iLkxuZXh0O3doaWxlKGIhPT1BLmFuRWRnZSk7ZyhEPD1uKSxBLm49SSwrK0l9Zm9yKHRoaXMuZWxlbWVudENvdW50PUkscz09PWkuQ09OTkVDVEVEX1BPTFlHT05TJiYoSSo9MiksdGhpcy5lbGVtZW50cz1bXSx0aGlzLmVsZW1lbnRzLmxlbmd0aD1JKm4sdGhpcy52ZXJ0ZXhDb3VudD1QLHRoaXMudmVydGljZXM9W10sdGhpcy52ZXJ0aWNlcy5sZW5ndGg9UCphLHRoaXMudmVydGV4SW5kaWNlcz1bXSx0aGlzLnZlcnRleEluZGljZXMubGVuZ3RoPVAsTz1yLnZIZWFkLm5leHQ7TyE9PXIudkhlYWQ7Tz1PLm5leHQpaWYoTy5uIT09LTEpe3ZhciBTPU8ubiphO3RoaXMudmVydGljZXNbUyswXT1PLmNvb3Jkc1swXSx0aGlzLnZlcnRpY2VzW1MrMV09Ty5jb29yZHNbMV0sYT4yJiYodGhpcy52ZXJ0aWNlc1tTKzJdPU8uY29vcmRzWzJdKSx0aGlzLnZlcnRleEluZGljZXNbTy5uXT1PLmlkeH12YXIgVD0wO2ZvcihBPXIuZkhlYWQubmV4dDtBIT09ci5mSGVhZDtBPUEubmV4dClpZihBLmluc2lkZSl7Yj1BLmFuRWRnZSxEPTA7ZG8gTz1iLk9yZyx0aGlzLmVsZW1lbnRzW1QrK109Ty5uLEQrKyxiPWIuTG5leHQ7d2hpbGUoYiE9PUEuYW5FZGdlKTtmb3IoTD1EO0w8bjsrK0wpdGhpcy5lbGVtZW50c1tUKytdPS0xO2lmKHM9PT1pLkNPTk5FQ1RFRF9QT0xZR09OUyl7Yj1BLmFuRWRnZTtkbyB0aGlzLmVsZW1lbnRzW1QrK109dGhpcy5nZXROZWlnaGJvdXJGYWNlXyhiKSxiPWIuTG5leHQ7d2hpbGUoYiE9PUEuYW5FZGdlKTtmb3IoTD1EO0w8bjsrK0wpdGhpcy5lbGVtZW50c1tUKytdPS0xfX19LG91dHB1dENvbnRvdXJzXzpmdW5jdGlvbihyLHMpe3ZhciBuLGEsTyxBPTAsYj0wO2Zvcih0aGlzLnZlcnRleENvdW50PTAsdGhpcy5lbGVtZW50Q291bnQ9MCxuPXIuZkhlYWQubmV4dDtuIT09ci5mSGVhZDtuPW4ubmV4dClpZihuLmluc2lkZSl7Tz1hPW4uYW5FZGdlO2RvIHRoaXMudmVydGV4Q291bnQrKyxhPWEuTG5leHQ7d2hpbGUoYSE9PU8pO3RoaXMuZWxlbWVudENvdW50Kyt9dGhpcy5lbGVtZW50cz1bXSx0aGlzLmVsZW1lbnRzLmxlbmd0aD10aGlzLmVsZW1lbnRDb3VudCoyLHRoaXMudmVydGljZXM9W10sdGhpcy52ZXJ0aWNlcy5sZW5ndGg9dGhpcy52ZXJ0ZXhDb3VudCpzLHRoaXMudmVydGV4SW5kaWNlcz1bXSx0aGlzLnZlcnRleEluZGljZXMubGVuZ3RoPXRoaXMudmVydGV4Q291bnQ7dmFyIEk9MCxQPTAsRD0wO2ZvcihBPTAsbj1yLmZIZWFkLm5leHQ7biE9PXIuZkhlYWQ7bj1uLm5leHQpaWYobi5pbnNpZGUpe2I9MCxPPWE9bi5hbkVkZ2U7ZG8gdGhpcy52ZXJ0aWNlc1tJKytdPWEuT3JnLmNvb3Jkc1swXSx0aGlzLnZlcnRpY2VzW0krK109YS5PcmcuY29vcmRzWzFdLHM+MiYmKHRoaXMudmVydGljZXNbSSsrXT1hLk9yZy5jb29yZHNbMl0pLHRoaXMudmVydGV4SW5kaWNlc1tQKytdPWEuT3JnLmlkeCxiKyssYT1hLkxuZXh0O3doaWxlKGEhPT1PKTt0aGlzLmVsZW1lbnRzW0QrK109QSx0aGlzLmVsZW1lbnRzW0QrK109YixBKz1ifX0sYWRkQ29udG91cjpmdW5jdGlvbihyLHMpe3ZhciBuLGE7Zm9yKHRoaXMubWVzaD09PW51bGwmJih0aGlzLm1lc2g9bmV3IGgpLHI8MiYmKHI9Mikscj4zJiYocj0zKSxuPW51bGwsYT0wO2E8cy5sZW5ndGg7YSs9ciluPT09bnVsbD8obj10aGlzLm1lc2gubWFrZUVkZ2UoKSx0aGlzLm1lc2guc3BsaWNlKG4sbi5TeW0pKToodGhpcy5tZXNoLnNwbGl0RWRnZShuKSxuPW4uTG5leHQpLG4uT3JnLmNvb3Jkc1swXT1zW2ErMF0sbi5PcmcuY29vcmRzWzFdPXNbYSsxXSxyPjI/bi5PcmcuY29vcmRzWzJdPXNbYSsyXTpuLk9yZy5jb29yZHNbMl09MCxuLk9yZy5pZHg9dGhpcy52ZXJ0ZXhJbmRleENvdW50ZXIrKyxuLndpbmRpbmc9MSxuLlN5bS53aW5kaW5nPS0xfSx0ZXNzZWxhdGU6ZnVuY3Rpb24ocixzLG4sYSxPKXtpZih0aGlzLnZlcnRpY2VzPVtdLHRoaXMuZWxlbWVudHM9W10sdGhpcy52ZXJ0ZXhJbmRpY2VzPVtdLHRoaXMudmVydGV4SW5kZXhDb3VudGVyPTAsTyYmKHRoaXMubm9ybWFsWzBdPU9bMF0sdGhpcy5ub3JtYWxbMV09T1sxXSx0aGlzLm5vcm1hbFsyXT1PWzJdKSx0aGlzLndpbmRpbmdSdWxlPXIsYTwyJiYoYT0yKSxhPjMmJihhPTMpLCF0aGlzLm1lc2gpcmV0dXJuITE7dGhpcy5wcm9qZWN0UG9seWdvbl8oKSxkLmNvbXB1dGVJbnRlcmlvcih0aGlzKTt2YXIgQT10aGlzLm1lc2g7cmV0dXJuIHM9PT1pLkJPVU5EQVJZX0NPTlRPVVJTP3RoaXMuc2V0V2luZGluZ051bWJlcl8oQSwxLCEwKTp0aGlzLnRlc3NlbGxhdGVJbnRlcmlvcl8oQSksQS5jaGVjaygpLHM9PT1pLkJPVU5EQVJZX0NPTlRPVVJTP3RoaXMub3V0cHV0Q29udG91cnNfKEEsYSk6dGhpcy5vdXRwdXRQb2x5bWVzaF8oQSxzLG4sYSksITB9fX0sZnVuY3Rpb24oUixlKXtSLmV4cG9ydHM9aTt2YXIgdD1PYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O2Z1bmN0aW9uIGkoKXtmb3IodmFyIG89e30sZz0wO2c8YXJndW1lbnRzLmxlbmd0aDtnKyspe3ZhciB2PWFyZ3VtZW50c1tnXTtmb3IodmFyIGMgaW4gdil0LmNhbGwodixjKSYmKG9bY109dltjXSl9cmV0dXJuIG99fSxmdW5jdGlvbihSLGUsdCl7dC5yKGUpLHQuZChlLCJjcmVhdGVTaGFkZXJzIixmdW5jdGlvbigpe3JldHVybiBmfSksdC5kKGUsImFwcGx5U2hhZGVyIixmdW5jdGlvbigpe3JldHVybiBofSksdC5kKGUsImNyZWF0ZUNsb3VkU2hhZGVycyIsZnVuY3Rpb24oKXtyZXR1cm4gbH0pLHQuZChlLCJhcHBseUNsb3VkU2hhZGVyIixmdW5jdGlvbigpe3JldHVybiBtfSk7dmFyIGk9dCg2NCksbz10KDY1KSxnPXQoNjYpLHY9dCg2Nyk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IGM9U3ltYm9sKCJzaGFkZXJzIik7ZnVuY3Rpb24gZihwKXtwW2NdPVtdO2ZvcihsZXQgQz0wO0M8MTY7QysrKXtjb25zdCB4PVtdLGQ9ISEoQyYxKSx5PSEhKEMmMikscj0hIShDJjQpLHM9ISEoQyY4KTtkJiZ4LnB1c2goIiNkZWZpbmUgVEVYVFVSRSAxIikseSYmeC5wdXNoKCIjZGVmaW5lIEZJTFRFUiAxIiksciYmeC5wdXNoKCIjZGVmaW5lIEdSQURJRU5UIDEiKSxzJiZ4LnB1c2goIiNkZWZpbmUgQ0xJUFBBVEggMSIpO2NvbnN0IG49YCR7eC5qb2luKGAKYCl9CmAsYT1bXTtkJiZhLnB1c2goInVuaWZvcm0gc2FtcGxlcjJEIHVfdGV4U2FtcGxlcjsiKSxzJiZhLnB1c2goInVuaWZvcm0gc2FtcGxlcjJEIHVfY2xpcFNhbXBsZXI7IikscFtjXVtDXT1bbithLmpvaW4oYApgKStvLmRlZmF1bHQsbitpLmRlZmF1bHRdfX1mdW5jdGlvbiBoKHAse2hhc1RleHR1cmU6Qz0hMSxoYXNGaWx0ZXI6eD0hMSxoYXNHcmFkaWVudDpkPSExLGhhc0NsaXBQYXRoOnk9ITF9PXt9KXtjb25zdCByPUN8eDw8MXxkPDwyfHk8PDM7bGV0IHM9cFtjXVtyXTtBcnJheS5pc0FycmF5KHMpJiYocz1wLmNyZWF0ZVByb2dyYW0oLi4ucykscFtjXVtyXT1zKSxwLnByb2dyYW0hPT1zJiZwLnVzZVByb2dyYW0ocyx7YV9jb2xvcjp7dHlwZToiVU5TSUdORURfQllURSIsbm9ybWFsaXplOiEwfX0pfWNvbnN0IEU9W107ZnVuY3Rpb24gbChwKXtmb3IobGV0IEM9MDtDPDY0O0MrKyl7Y29uc3QgeD1bXSxkPSEhKEMmMSkseT0hIShDJjIpLHI9ISEoQyY0KSxzPSEhKEMmOCksbj0hIShDJjE2KSxhPSEhKEMmMzIpO2QmJngucHVzaCgiI2RlZmluZSBURVhUVVJFIDEiKSx5JiZ4LnB1c2goIiNkZWZpbmUgRklMVEVSIDEiKSxyJiZ4LnB1c2goIiNkZWZpbmUgR1JBRElFTlQgMSIpLHMmJngucHVzaCgiI2RlZmluZSBDTE9VRENPTE9SIDEiKSxuJiZ4LnB1c2goIiNkZWZpbmUgQ0xPVURGSUxURVIgMSIpLGEmJngucHVzaCgiI2RlZmluZSBDTElQUEFUSCAxIik7Y29uc3QgTz1gJHt4LmpvaW4oYApgKX0KYCxBPVtdO2lmKGQpe0EucHVzaCgidW5pZm9ybSBzYW1wbGVyMkQgdV90ZXhTYW1wbGVyOyIpO2ZvcihsZXQgYj0wO2I8MTI7YisrKUEucHVzaChgdW5pZm9ybSBzYW1wbGVyMkQgdV90ZXhGcmFtZSR7Yn07YCl9YSYmQS5wdXNoKCJ1bmlmb3JtIHNhbXBsZXIyRCB1X2NsaXBTYW1wbGVyOyIpLEVbQ109W08rQS5qb2luKGAKYCkrdi5kZWZhdWx0LE8rZy5kZWZhdWx0XX19ZnVuY3Rpb24gbShwLHtoYXNUZXh0dXJlOkM9ITEsaGFzRmlsdGVyOng9ITEsaGFzR3JhZGllbnQ6ZD0hMSxoYXNDbG91ZENvbG9yOnk9ITEsaGFzQ2xvdWRGaWx0ZXI6cj0hMSxoYXNDbGlwUGF0aDpzPSExfT17fSl7Y29uc3Qgbj1DfHg8PDF8ZDw8Mnx5PDwzfHI8PDR8czw8NTtsZXQgYT1FW25dO0FycmF5LmlzQXJyYXkoYSkmJihhPXAuY3JlYXRlUHJvZ3JhbSguLi5hKSxFW25dPWEpLHAucHJvZ3JhbSE9PWEmJnAudXNlUHJvZ3JhbShhLHthX2NvbG9yOnt0eXBlOiJVTlNJR05FRF9CWVRFIixub3JtYWxpemU6ITB9LGFfZmlsbENsb3VkQ29sb3I6e3R5cGU6IlVOU0lHTkVEX0JZVEUiLG5vcm1hbGl6ZTohMH0sYV9zdHJva2VDbG91ZENvbG9yOnt0eXBlOiJVTlNJR05FRF9CWVRFIixub3JtYWxpemU6ITB9LGFfZnJhbWVJbmRleDp7dHlwZToiVU5TSUdORURfQllURSIsbm9ybWFsaXplOiExfX0pfX0sZnVuY3Rpb24oUixlLHQpe3QucihlKSxlLmRlZmF1bHQ9YGF0dHJpYnV0ZSB2ZWMzIGFfdmVydGV4UG9zaXRpb247CmF0dHJpYnV0ZSB2ZWM0IGFfY29sb3I7CnZhcnlpbmcgdmVjNCB2Q29sb3I7CnZhcnlpbmcgZmxvYXQgZmxhZ0JhY2tncm91bmQ7CnVuaWZvcm0gdmVjMiB1X3Jlc29sdXRpb247CnVuaWZvcm0gbWF0MyB2aWV3TWF0cml4Owp1bmlmb3JtIG1hdDMgcHJvamVjdGlvbk1hdHJpeDsKCiNpZmRlZiBURVhUVVJFCmF0dHJpYnV0ZSB2ZWMzIGFfdmVydGV4VGV4dHVyZUNvb3JkOwp2YXJ5aW5nIHZlYzMgdlRleHR1cmVDb29yZDsKYXR0cmlidXRlIHZlYzQgYV9zb3VyY2VSZWN0Owp2YXJ5aW5nIHZlYzQgdlNvdXJjZVJlY3Q7CiNlbmRpZgoKI2lmZGVmIENMSVBQQVRICmF0dHJpYnV0ZSB2ZWMyIGFfY2xpcFVWOwp2YXJ5aW5nIHZlYzIgdkNsaXBVVjsKI2VuZGlmCgojaWZkZWYgR1JBRElFTlQKdW5pZm9ybSBmbG9hdCB1X3JhZGlhbEdyYWRpZW50VmVjdG9yWzZdOwp2YXJ5aW5nIHZlYzMgdkdyYWRpZW50VmVjdG9yMTsKdmFyeWluZyB2ZWMzIHZHcmFkaWVudFZlY3RvcjI7CiNlbmRpZgoKdm9pZCBtYWluKCkgewogIGdsX1BvaW50U2l6ZSA9IDEuMDsKCiAgdmVjMyBwb3MgPSBwcm9qZWN0aW9uTWF0cml4ICogdmlld01hdHJpeCAqIHZlYzMoYV92ZXJ0ZXhQb3NpdGlvbi54eSwgMS4wKTsKICBnbF9Qb3NpdGlvbiA9IHZlYzQocG9zLnh5LCAxLjAsIDEuMCk7CgojaWZkZWYgR1JBRElFTlQKICB2ZWMzIHZnMSA9IHZpZXdNYXRyaXggKiB2ZWMzKHVfcmFkaWFsR3JhZGllbnRWZWN0b3JbMF0sIHVfcmFkaWFsR3JhZGllbnRWZWN0b3JbMV0sIDEuMCk7CiAgdmVjMyB2ZzIgPSB2aWV3TWF0cml4ICogdmVjMyh1X3JhZGlhbEdyYWRpZW50VmVjdG9yWzNdLCB1X3JhZGlhbEdyYWRpZW50VmVjdG9yWzRdLCAxLjApOwogIGZsb2F0IGggPSB1X3Jlc29sdXRpb24ueTsKICB2ZzEueSA9IGggLSB2ZzEueTsKICB2ZzIueSA9IGggLSB2ZzIueTsKICB2R3JhZGllbnRWZWN0b3IxID0gdmVjMyh2ZzEueHksIHVfcmFkaWFsR3JhZGllbnRWZWN0b3JbMl0pOwogIHZHcmFkaWVudFZlY3RvcjIgPSB2ZWMzKHZnMi54eSwgdV9yYWRpYWxHcmFkaWVudFZlY3Rvcls1XSk7CiNlbmRpZgogIAogIGZsYWdCYWNrZ3JvdW5kID0gYV92ZXJ0ZXhQb3NpdGlvbi56OwogIHZDb2xvciA9IGFfY29sb3I7CgojaWZkZWYgVEVYVFVSRQogIHZUZXh0dXJlQ29vcmQgPSBhX3ZlcnRleFRleHR1cmVDb29yZDsKICB2U291cmNlUmVjdCA9IGFfc291cmNlUmVjdDsKI2VuZGlmCgojaWZkZWYgQ0xJUFBBVEgKICB2Q2xpcFVWID0gYV9jbGlwVVY7CiNlbmRpZgp9YH0sZnVuY3Rpb24oUixlLHQpe3QucihlKSxlLmRlZmF1bHQ9YHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0OwoKdmFyeWluZyB2ZWM0IHZDb2xvcjsKdmFyeWluZyBmbG9hdCBmbGFnQmFja2dyb3VuZDsKCiNpZmRlZiBURVhUVVJFCnZhcnlpbmcgdmVjMyB2VGV4dHVyZUNvb3JkOwp2YXJ5aW5nIHZlYzQgdlNvdXJjZVJlY3Q7CiNlbmRpZgoKI2lmZGVmIENMSVBQQVRICnZhcnlpbmcgdmVjMiB2Q2xpcFVWOwojZW5kaWYKCiNpZmRlZiBGSUxURVIKdW5pZm9ybSBpbnQgdV9maWx0ZXJGbGFnOwp1bmlmb3JtIGZsb2F0IHVfY29sb3JNYXRyaXhbMjBdOwojZW5kaWYKCiNpZmRlZiBHUkFESUVOVAp2YXJ5aW5nIHZlYzMgdkdyYWRpZW50VmVjdG9yMTsKdmFyeWluZyB2ZWMzIHZHcmFkaWVudFZlY3RvcjI7CnVuaWZvcm0gZmxvYXQgdV9jb2xvclN0ZXBzWzQwXTsKdW5pZm9ybSBpbnQgdV9ncmFkaWVudFR5cGU7Ci8vIHVuaWZvcm0gZmxvYXQgdV9yYWRpYWxHcmFkaWVudFZlY3Rvcls2XTsKCnZvaWQgZ3JhZGllbnQoaW5vdXQgdmVjNCBjb2xvciwgdmVjMyBndjEsIHZlYzMgZ3YyLCBmbG9hdCBjb2xvclN0ZXBzWzQwXSkgewogIGZsb2F0IHQ7CiAgLy8gY2VudGVyIGNpcmNsZSByYWRpdXMKICBmbG9hdCBjciA9IGd2MS56OwogIC8vIGZvY2FsIGNpcmNsZSByYWRpdXMKICBmbG9hdCBmciA9IGd2Mi56OwoKICBpZihjciA+IDAuMCB8fCBmciA+IDAuMCkgewogICAgLy8gcmFkaWFsIGdyYWRpZW50CiAgICB2ZWMyIGNlbnRlciA9IGd2MS54eTsKICAgIHZlYzIgZm9jYWwgPSBndjIueHk7CiAgICBmbG9hdCB4ID0gZm9jYWwueCAtIGdsX0ZyYWdDb29yZC54OwogICAgZmxvYXQgeSA9IGZvY2FsLnkgLSBnbF9GcmFnQ29vcmQueTsKICAgIGZsb2F0IGR4ID0gZm9jYWwueCAtIGNlbnRlci54OwogICAgZmxvYXQgZHkgPSBmb2NhbC55IC0gY2VudGVyLnk7CiAgICBmbG9hdCBkciA9IGNyIC0gZnI7CiAgICBmbG9hdCBhID0gZHggKiBkeCArIGR5ICogZHkgLSBkciAqIGRyOwogICAgZmxvYXQgYiA9IC0yLjAgKiAoeSAqIGR5ICsgeCAqIGR4ICsgZnIgKiBkcik7CiAgICBmbG9hdCBjID0geCAqIHggKyB5ICogeSAtIGZyICogZnI7CiAgICB0ID0gMS4wIC0gMC41ICogKDEuMCAvIGEpICogKC1iICsgc3FydChiICogYiAtIDQuMCAqIGEgKiBjKSk7CiAgfSBlbHNlIHsKICAgIC8vIGxpbmVhciBncmFkaWVudAogICAgdmVjMiB2MSA9IGdsX0ZyYWdDb29yZC54eSAtIGd2MS54eTsKICAgIHZlYzIgdjIgPSBndjIueHkgLSBndjEueHk7CiAgICB0ID0gKHYxLnggKiB2Mi54ICsgdjEueSAqIHYyLnkpIC8gKHYyLnggKiB2Mi54ICsgdjIueSAqIHYyLnkpOwogIH0KCiAgdmVjNCBjb2xvcnNbOF07CiAgY29sb3JzWzBdID0gdmVjNChjb2xvclN0ZXBzWzFdLCBjb2xvclN0ZXBzWzJdLCBjb2xvclN0ZXBzWzNdLCBjb2xvclN0ZXBzWzRdKTsKICBjb2xvcnNbMV0gPSB2ZWM0KGNvbG9yU3RlcHNbNl0sIGNvbG9yU3RlcHNbN10sIGNvbG9yU3RlcHNbOF0sIGNvbG9yU3RlcHNbOV0pOwogIGNvbG9yc1syXSA9IHZlYzQoY29sb3JTdGVwc1sxMV0sIGNvbG9yU3RlcHNbMTJdLCBjb2xvclN0ZXBzWzEzXSwgY29sb3JTdGVwc1sxNF0pOwogIGNvbG9yc1szXSA9IHZlYzQoY29sb3JTdGVwc1sxNl0sIGNvbG9yU3RlcHNbMTddLCBjb2xvclN0ZXBzWzE4XSwgY29sb3JTdGVwc1sxOV0pOwogIGNvbG9yc1s0XSA9IHZlYzQoY29sb3JTdGVwc1syMV0sIGNvbG9yU3RlcHNbMjJdLCBjb2xvclN0ZXBzWzIzXSwgY29sb3JTdGVwc1syNF0pOwogIGNvbG9yc1s1XSA9IHZlYzQoY29sb3JTdGVwc1syNl0sIGNvbG9yU3RlcHNbMjddLCBjb2xvclN0ZXBzWzI4XSwgY29sb3JTdGVwc1syOV0pOwogIGNvbG9yc1s2XSA9IHZlYzQoY29sb3JTdGVwc1szMV0sIGNvbG9yU3RlcHNbMzJdLCBjb2xvclN0ZXBzWzMzXSwgY29sb3JTdGVwc1szNF0pOwogIGNvbG9yc1s3XSA9IHZlYzQoY29sb3JTdGVwc1szNl0sIGNvbG9yU3RlcHNbMzddLCBjb2xvclN0ZXBzWzM4XSwgY29sb3JTdGVwc1szOV0pOwogIAogIGZsb2F0IHN0ZXBzWzhdOwogIHN0ZXBzWzBdID0gY29sb3JTdGVwc1swXTsKICBzdGVwc1sxXSA9IGNvbG9yU3RlcHNbNV07CiAgc3RlcHNbMl0gPSBjb2xvclN0ZXBzWzEwXTsKICBzdGVwc1szXSA9IGNvbG9yU3RlcHNbMTVdOwogIHN0ZXBzWzRdID0gY29sb3JTdGVwc1syMF07CiAgc3RlcHNbNV0gPSBjb2xvclN0ZXBzWzI1XTsKICBzdGVwc1s2XSA9IGNvbG9yU3RlcHNbMzBdOwogIHN0ZXBzWzddID0gY29sb3JTdGVwc1szNV07CgogIGNvbG9yID0gY29sb3JzWzBdOwogIGZvciAoaW50IGkgPSAxOyBpIDwgODsgaSsrKSB7CiAgICBpZiAoc3RlcHNbaV0gPCAwLjAgfHwgc3RlcHNbaV0gPiAxLjApIHsKICAgICAgYnJlYWs7CiAgICB9CiAgICBpZihzdGVwc1tpXSA9PSBzdGVwc1tpIC0gMV0pIHsKICAgICAgY29sb3IgPSBjb2xvcnNbaV07CiAgICB9IGVsc2UgewogICAgICBjb2xvciA9IG1peChjb2xvciwgY29sb3JzW2ldLCBjbGFtcCgodCAtIHN0ZXBzW2kgLSAxXSkgLyAoc3RlcHNbaV0gLSBzdGVwc1tpIC0gMV0pLCAwLjAsIDEuMCkpOwogICAgfQogICAgaWYgKHN0ZXBzW2ldID49IHQpIHsKICAgICAgYnJlYWs7CiAgICB9CiAgfQp9CiNlbmRpZgoKI2lmZGVmIEZJTFRFUgp2b2lkIHRyYW5zZm9ybUNvbG9yKGlub3V0IHZlYzQgY29sb3IsIGluIGZsb2F0IGNvbG9yTWF0cml4WzIwXSkgewogIGZsb2F0IHIgPSBjb2xvci5yLCBnID0gY29sb3IuZywgYiA9IGNvbG9yLmIsIGEgPSBjb2xvci5hOwogIGNvbG9yWzBdID0gY29sb3JNYXRyaXhbMF0gKiByICsgY29sb3JNYXRyaXhbMV0gKiBnICsgY29sb3JNYXRyaXhbMl0gKiBiICsgY29sb3JNYXRyaXhbM10gKiBhICsgY29sb3JNYXRyaXhbNF07CiAgY29sb3JbMV0gPSBjb2xvck1hdHJpeFs1XSAqIHIgKyBjb2xvck1hdHJpeFs2XSAqIGcgKyBjb2xvck1hdHJpeFs3XSAqIGIgKyBjb2xvck1hdHJpeFs4XSAqIGEgKyBjb2xvck1hdHJpeFs5XTsKICBjb2xvclsyXSA9IGNvbG9yTWF0cml4WzEwXSAqIHIgKyBjb2xvck1hdHJpeFsxMV0gKiBnICsgY29sb3JNYXRyaXhbMTJdICogYiArIGNvbG9yTWF0cml4WzEzXSAqIGEgKyBjb2xvck1hdHJpeFsxNF07CiAgY29sb3JbM10gPSBjb2xvck1hdHJpeFsxNV0gKiByICsgY29sb3JNYXRyaXhbMTZdICogZyArIGNvbG9yTWF0cml4WzE3XSAqIGIgKyBjb2xvck1hdHJpeFsxOF0gKiBhICsgY29sb3JNYXRyaXhbMTldOwp9CiNlbmRpZgoKdm9pZCBtYWluKCkgewogIHZlYzQgY29sb3IgPSB2Q29sb3I7CiAgZmxvYXQgb3BhY2l0eSA9IGFicyhmbGFnQmFja2dyb3VuZCk7CgojaWZkZWYgR1JBRElFTlQKICBpZih1X2dyYWRpZW50VHlwZSA+IDAgJiYgZmxhZ0JhY2tncm91bmQgPiAwLjAgfHwgdV9ncmFkaWVudFR5cGUgPT0gMCAmJiBmbGFnQmFja2dyb3VuZCA8PSAwLjApIHsKICAgIGdyYWRpZW50KGNvbG9yLCB2R3JhZGllbnRWZWN0b3IxLCB2R3JhZGllbnRWZWN0b3IyLCB1X2NvbG9yU3RlcHMpOwogIH0KI2VuZGlmCgogIGlmKG9wYWNpdHkgPCAxLjApIHsKICAgIGNvbG9yLmEgKj0gb3BhY2l0eTsKICB9CgojaWZkZWYgVEVYVFVSRQogIGlmKGZsYWdCYWNrZ3JvdW5kID4gMC4wKSB7CiAgICB2ZWMzIHRleENvb3JkID0gdlRleHR1cmVDb29yZDsKCiAgICBpZih0ZXhDb29yZC56ID09IDEuMCkgewogICAgICB0ZXhDb29yZCA9IGZyYWN0KHRleENvb3JkKTsKICAgIH0KCiAgICBpZih0ZXhDb29yZC54IDw9IDEuMCAmJiB0ZXhDb29yZC54ID49IDAuMAogICAgICAmJiB0ZXhDb29yZC55IDw9IDEuMCAmJiB0ZXhDb29yZC55ID49IDAuMCkgewogICAgICBpZih2U291cmNlUmVjdC56ID4gMC4wKSB7CiAgICAgICAgdGV4Q29vcmQueCA9IHZTb3VyY2VSZWN0LnggKyB0ZXhDb29yZC54ICogdlNvdXJjZVJlY3QuejsKICAgICAgICB0ZXhDb29yZC55ID0gMS4wIC0gKHZTb3VyY2VSZWN0LnkgKyAoMS4wIC0gdGV4Q29vcmQueSkgKiB2U291cmNlUmVjdC53KTsKICAgICAgfQogICAgICB2ZWM0IHRleENvbG9yID0gdGV4dHVyZTJEKHVfdGV4U2FtcGxlciwgdGV4Q29vcmQueHkpOwogICAgICBmbG9hdCBhbHBoYSA9IHRleENvbG9yLmE7CiAgICAgIGlmKG9wYWNpdHkgPCAxLjApIHsKICAgICAgICB0ZXhDb2xvci5hICo9IG9wYWNpdHk7CiAgICAgICAgYWxwaGEgKj0gbWl4KDAuNDY1LCAxLjAsIG9wYWNpdHkpOwogICAgICB9CiAgICAgIC8vIGNvbG9yID0gbWl4KGNvbG9yLCB0ZXhDb2xvciwgdGV4Q29sb3IuYSk7CiAgICAgIGNvbG9yLnJnYiA9IG1peChjb2xvci5yZ2IsIHRleENvbG9yLnJnYiwgYWxwaGEpOwogICAgICAvLyBjb2xvci5yZ2IgPSBtaXgodGV4Q29sb3IucmdiLCBjb2xvci5yZ2IsIGNvbG9yLmEpOwogICAgICBjb2xvci5yZ2IgPSBtaXgodGV4Q29sb3IucmdiLCBjb2xvci5yZ2IsIGNsYW1wKGNvbG9yLmEgLyBtYXgoMC4wMDAxLCB0ZXhDb2xvci5hKSwgMC4wLCAxLjApKTsKICAgICAgY29sb3IuYSA9IHRleENvbG9yLmEgKyAoMS4wIC0gdGV4Q29sb3IuYSkgKiBjb2xvci5hOwogICAgfQogIH0KI2VuZGlmCgojaWZkZWYgRklMVEVSCiAgaWYodV9maWx0ZXJGbGFnID4gMCkgewogICAgdHJhbnNmb3JtQ29sb3IoY29sb3IsIHVfY29sb3JNYXRyaXgpOwogIH0KI2VuZGlmCgojaWZkZWYgQ0xJUFBBVEgKICBmbG9hdCBjbGlwID0gdGV4dHVyZTJEKHVfY2xpcFNhbXBsZXIsIHZDbGlwVVYpLnI7CiAgY29sb3IgKj0gY2xpcDsKI2VuZGlmCgogIGdsX0ZyYWdDb2xvciA9IGNvbG9yOwp9YH0sZnVuY3Rpb24oUixlLHQpe3QucihlKSxlLmRlZmF1bHQ9YGF0dHJpYnV0ZSB2ZWMzIGFfdmVydGV4UG9zaXRpb247CmF0dHJpYnV0ZSB2ZWM0IGFfY29sb3I7CnZhcnlpbmcgdmVjNCB2Q29sb3I7CnZhcnlpbmcgZmxvYXQgZmxhZ0JhY2tncm91bmQ7CmF0dHJpYnV0ZSB2ZWMzIGFfdHJhbnNmb3JtMDsKYXR0cmlidXRlIHZlYzMgYV90cmFuc2Zvcm0xOwp1bmlmb3JtIHZlYzIgdV9yZXNvbHV0aW9uOwp1bmlmb3JtIG1hdDMgdmlld01hdHJpeDsKdW5pZm9ybSBtYXQzIHByb2plY3Rpb25NYXRyaXg7CgojaWZkZWYgVEVYVFVSRQphdHRyaWJ1dGUgdmVjMyBhX3ZlcnRleFRleHR1cmVDb29yZDsKdmFyeWluZyB2ZWMzIHZUZXh0dXJlQ29vcmQ7CmF0dHJpYnV0ZSBmbG9hdCBhX2ZyYW1lSW5kZXg7CnZhcnlpbmcgZmxvYXQgZnJhbWVJbmRleDsKYXR0cmlidXRlIHZlYzQgYV9zb3VyY2VSZWN0Owp2YXJ5aW5nIHZlYzQgdlNvdXJjZVJlY3Q7CiNlbmRpZgoKI2lmZGVmIENMSVBQQVRICmF0dHJpYnV0ZSB2ZWMyIGFfY2xpcFVWOwp2YXJ5aW5nIHZlYzIgdkNsaXBVVjsKI2VuZGlmCgojaWZkZWYgQ0xPVURGSUxURVIKYXR0cmlidXRlIHZlYzQgYV9jb2xvckNsb3VkMDsKYXR0cmlidXRlIHZlYzQgYV9jb2xvckNsb3VkMTsKYXR0cmlidXRlIHZlYzQgYV9jb2xvckNsb3VkMjsKYXR0cmlidXRlIHZlYzQgYV9jb2xvckNsb3VkMzsKYXR0cmlidXRlIHZlYzQgYV9jb2xvckNsb3VkNDsKdmFyeWluZyB2ZWM0IGNvbG9yQ2xvdWQwOwp2YXJ5aW5nIHZlYzQgY29sb3JDbG91ZDE7CnZhcnlpbmcgdmVjNCBjb2xvckNsb3VkMjsKdmFyeWluZyB2ZWM0IGNvbG9yQ2xvdWQzOwp2YXJ5aW5nIHZlYzQgY29sb3JDbG91ZDQ7CiNlbmRpZgoKI2lmZGVmIENMT1VEQ09MT1IKYXR0cmlidXRlIHZlYzQgYV9maWxsQ2xvdWRDb2xvcjsKYXR0cmlidXRlIHZlYzQgYV9zdHJva2VDbG91ZENvbG9yOwojZW5kaWYKCiNpZmRlZiBHUkFESUVOVAp1bmlmb3JtIGZsb2F0IHVfcmFkaWFsR3JhZGllbnRWZWN0b3JbNl07CnZhcnlpbmcgdmVjMyB2R3JhZGllbnRWZWN0b3IxOwp2YXJ5aW5nIHZlYzMgdkdyYWRpZW50VmVjdG9yMjsKI2VuZGlmCgp2b2lkIG1haW4oKSB7CiAgZ2xfUG9pbnRTaXplID0gMS4wOwoKICBtYXQzIG1vZGVsTWF0cml4ID0gbWF0MygKICAgIGFfdHJhbnNmb3JtMC54LCBhX3RyYW5zZm9ybTEueCwgMCwgCiAgICBhX3RyYW5zZm9ybTAueSwgYV90cmFuc2Zvcm0xLnksIDAsCiAgICBhX3RyYW5zZm9ybTAueiwgYV90cmFuc2Zvcm0xLnosIDEKICApOwoKICB2ZWMzIHBvcyA9IHByb2plY3Rpb25NYXRyaXggKiB2aWV3TWF0cml4ICogbW9kZWxNYXRyaXggKiB2ZWMzKGFfdmVydGV4UG9zaXRpb24ueHksIDEuMCk7CiAgZ2xfUG9zaXRpb24gPSB2ZWM0KHBvcy54eSwgMS4wLCAxLjApOwoKI2lmZGVmIEdSQURJRU5UCiAgdmVjMyB2ZzEgPSB2aWV3TWF0cml4ICogdmVjMyh1X3JhZGlhbEdyYWRpZW50VmVjdG9yWzBdLCB1X3JhZGlhbEdyYWRpZW50VmVjdG9yWzFdLCAxLjApOwogIHZlYzMgdmcyID0gdmlld01hdHJpeCAqIHZlYzModV9yYWRpYWxHcmFkaWVudFZlY3RvclszXSwgdV9yYWRpYWxHcmFkaWVudFZlY3Rvcls0XSwgMS4wKTsKICBmbG9hdCBoID0gdV9yZXNvbHV0aW9uLnk7CiAgdmcxLnkgPSBoIC0gdmcxLnk7CiAgdmcyLnkgPSBoIC0gdmcyLnk7CiAgdkdyYWRpZW50VmVjdG9yMSA9IHZlYzModmcxLnh5LCB1X3JhZGlhbEdyYWRpZW50VmVjdG9yWzJdKTsKICB2R3JhZGllbnRWZWN0b3IyID0gdmVjMyh2ZzIueHksIHVfcmFkaWFsR3JhZGllbnRWZWN0b3JbNV0pOwojZW5kaWYKICAKICBmbGFnQmFja2dyb3VuZCA9IGFfdmVydGV4UG9zaXRpb24uejsKCiNpZmRlZiBDTE9VRENPTE9SCiAgaWYoZmxhZ0JhY2tncm91bmQgPiAwLjApIHsKICAgIHZDb2xvciA9IG1peChhX2NvbG9yLCBhX2ZpbGxDbG91ZENvbG9yLCBhX2ZpbGxDbG91ZENvbG9yLmEpOwogIH0gZWxzZSB7CiAgICB2Q29sb3IgPSBtaXgoYV9jb2xvciwgYV9zdHJva2VDbG91ZENvbG9yLCBhX3N0cm9rZUNsb3VkQ29sb3IuYSk7CiAgfQojZWxzZQogIHZDb2xvciA9IGFfY29sb3I7CiNlbmRpZgoKI2lmZGVmIFRFWFRVUkUKICB2VGV4dHVyZUNvb3JkID0gYV92ZXJ0ZXhUZXh0dXJlQ29vcmQ7CiAgZnJhbWVJbmRleCA9IGFfZnJhbWVJbmRleDsKICB2U291cmNlUmVjdCA9IGFfc291cmNlUmVjdDsKI2VuZGlmCgojaWZkZWYgQ0xJUFBBVEgKICB2Q2xpcFVWID0gYV9jbGlwVVY7CiNlbmRpZgoKI2lmZGVmIENMT1VERklMVEVSCiAgY29sb3JDbG91ZDAgPSBhX2NvbG9yQ2xvdWQwOwogIGNvbG9yQ2xvdWQxID0gYV9jb2xvckNsb3VkMTsKICBjb2xvckNsb3VkMiA9IGFfY29sb3JDbG91ZDI7CiAgY29sb3JDbG91ZDMgPSBhX2NvbG9yQ2xvdWQzOwogIGNvbG9yQ2xvdWQ0ID0gYV9jb2xvckNsb3VkNDsKI2VuZGlmCn1gfSxmdW5jdGlvbihSLGUsdCl7dC5yKGUpLGUuZGVmYXVsdD1gcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7Cgp2YXJ5aW5nIHZlYzQgdkNvbG9yOwp2YXJ5aW5nIGZsb2F0IGZsYWdCYWNrZ3JvdW5kOwoKI2lmZGVmIFRFWFRVUkUKdmFyeWluZyBmbG9hdCBmcmFtZUluZGV4Owp2YXJ5aW5nIHZlYzMgdlRleHR1cmVDb29yZDsKdmFyeWluZyB2ZWM0IHZTb3VyY2VSZWN0OwojZW5kaWYKCiNpZmRlZiBDTElQUEFUSAp2YXJ5aW5nIHZlYzIgdkNsaXBVVjsKI2VuZGlmCgojaWZkZWYgRklMVEVSCnVuaWZvcm0gaW50IHVfZmlsdGVyRmxhZzsKdW5pZm9ybSBmbG9hdCB1X2NvbG9yTWF0cml4WzIwXTsKI2VuZGlmCgojaWZkZWYgQ0xPVURGSUxURVIKdmFyeWluZyB2ZWM0IGNvbG9yQ2xvdWQwOwp2YXJ5aW5nIHZlYzQgY29sb3JDbG91ZDE7CnZhcnlpbmcgdmVjNCBjb2xvckNsb3VkMjsKdmFyeWluZyB2ZWM0IGNvbG9yQ2xvdWQzOwp2YXJ5aW5nIHZlYzQgY29sb3JDbG91ZDQ7CiNlbmRpZgoKI2lmZGVmIEdSQURJRU5UCnZhcnlpbmcgdmVjMyB2R3JhZGllbnRWZWN0b3IxOwp2YXJ5aW5nIHZlYzMgdkdyYWRpZW50VmVjdG9yMjsKdW5pZm9ybSBmbG9hdCB1X2NvbG9yU3RlcHNbNDBdOwp1bmlmb3JtIGludCB1X2dyYWRpZW50VHlwZTsKCnZvaWQgZ3JhZGllbnQoaW5vdXQgdmVjNCBjb2xvciwgdmVjMyBndjEsIHZlYzMgZ3YyLCBmbG9hdCBjb2xvclN0ZXBzWzQwXSkgewogIGZsb2F0IHQ7CiAgLy8gY2VudGVyIGNpcmNsZSByYWRpdXMKICBmbG9hdCBjciA9IGd2MS56OwogIC8vIGZvY2FsIGNpcmNsZSByYWRpdXMKICBmbG9hdCBmciA9IGd2Mi56OwoKICBpZihjciA+IDAuMCB8fCBmciA+IDAuMCkgewogICAgLy8gcmFkaWFsIGdyYWRpZW50CiAgICB2ZWMyIGNlbnRlciA9IGd2MS54eTsKICAgIHZlYzIgZm9jYWwgPSBndjIueHk7CiAgICBmbG9hdCB4ID0gZm9jYWwueCAtIGdsX0ZyYWdDb29yZC54OwogICAgZmxvYXQgeSA9IGZvY2FsLnkgLSBnbF9GcmFnQ29vcmQueTsKICAgIGZsb2F0IGR4ID0gZm9jYWwueCAtIGNlbnRlci54OwogICAgZmxvYXQgZHkgPSBmb2NhbC55IC0gY2VudGVyLnk7CiAgICBmbG9hdCBkciA9IGNyIC0gZnI7CiAgICBmbG9hdCBhID0gZHggKiBkeCArIGR5ICogZHkgLSBkciAqIGRyOwogICAgZmxvYXQgYiA9IC0yLjAgKiAoeSAqIGR5ICsgeCAqIGR4ICsgZnIgKiBkcik7CiAgICBmbG9hdCBjID0geCAqIHggKyB5ICogeSAtIGZyICogZnI7CiAgICB0ID0gMS4wIC0gMC41ICogKDEuMCAvIGEpICogKC1iICsgc3FydChiICogYiAtIDQuMCAqIGEgKiBjKSk7CiAgfSBlbHNlIHsKICAgIC8vIGxpbmVhciBncmFkaWVudAogICAgdmVjMiB2MSA9IGdsX0ZyYWdDb29yZC54eSAtIGd2MS54eTsKICAgIHZlYzIgdjIgPSBndjIueHkgLSBndjEueHk7CiAgICB0ID0gKHYxLnggKiB2Mi54ICsgdjEueSAqIHYyLnkpIC8gKHYyLnggKiB2Mi54ICsgdjIueSAqIHYyLnkpOwogIH0KCiAgdmVjNCBjb2xvcnNbOF07CiAgY29sb3JzWzBdID0gdmVjNChjb2xvclN0ZXBzWzFdLCBjb2xvclN0ZXBzWzJdLCBjb2xvclN0ZXBzWzNdLCBjb2xvclN0ZXBzWzRdKTsKICBjb2xvcnNbMV0gPSB2ZWM0KGNvbG9yU3RlcHNbNl0sIGNvbG9yU3RlcHNbN10sIGNvbG9yU3RlcHNbOF0sIGNvbG9yU3RlcHNbOV0pOwogIGNvbG9yc1syXSA9IHZlYzQoY29sb3JTdGVwc1sxMV0sIGNvbG9yU3RlcHNbMTJdLCBjb2xvclN0ZXBzWzEzXSwgY29sb3JTdGVwc1sxNF0pOwogIGNvbG9yc1szXSA9IHZlYzQoY29sb3JTdGVwc1sxNl0sIGNvbG9yU3RlcHNbMTddLCBjb2xvclN0ZXBzWzE4XSwgY29sb3JTdGVwc1sxOV0pOwogIGNvbG9yc1s0XSA9IHZlYzQoY29sb3JTdGVwc1syMV0sIGNvbG9yU3RlcHNbMjJdLCBjb2xvclN0ZXBzWzIzXSwgY29sb3JTdGVwc1syNF0pOwogIGNvbG9yc1s1XSA9IHZlYzQoY29sb3JTdGVwc1syNl0sIGNvbG9yU3RlcHNbMjddLCBjb2xvclN0ZXBzWzI4XSwgY29sb3JTdGVwc1syOV0pOwogIGNvbG9yc1s2XSA9IHZlYzQoY29sb3JTdGVwc1szMV0sIGNvbG9yU3RlcHNbMzJdLCBjb2xvclN0ZXBzWzMzXSwgY29sb3JTdGVwc1szNF0pOwogIGNvbG9yc1s3XSA9IHZlYzQoY29sb3JTdGVwc1szNl0sIGNvbG9yU3RlcHNbMzddLCBjb2xvclN0ZXBzWzM4XSwgY29sb3JTdGVwc1szOV0pOwogIAogIGZsb2F0IHN0ZXBzWzhdOwogIHN0ZXBzWzBdID0gY29sb3JTdGVwc1swXTsKICBzdGVwc1sxXSA9IGNvbG9yU3RlcHNbNV07CiAgc3RlcHNbMl0gPSBjb2xvclN0ZXBzWzEwXTsKICBzdGVwc1szXSA9IGNvbG9yU3RlcHNbMTVdOwogIHN0ZXBzWzRdID0gY29sb3JTdGVwc1syMF07CiAgc3RlcHNbNV0gPSBjb2xvclN0ZXBzWzI1XTsKICBzdGVwc1s2XSA9IGNvbG9yU3RlcHNbMzBdOwogIHN0ZXBzWzddID0gY29sb3JTdGVwc1szNV07CgogIGNvbG9yID0gY29sb3JzWzBdOwogIGZvciAoaW50IGkgPSAxOyBpIDwgODsgaSsrKSB7CiAgICBpZiAoc3RlcHNbaV0gPCAwLjAgfHwgc3RlcHNbaV0gPiAxLjApIHsKICAgICAgYnJlYWs7CiAgICB9CiAgICBpZihzdGVwc1tpXSA9PSBzdGVwc1tpIC0gMV0pIHsKICAgICAgY29sb3IgPSBjb2xvcnNbaV07CiAgICB9IGVsc2UgewogICAgICBjb2xvciA9IG1peChjb2xvciwgY29sb3JzW2ldLCBjbGFtcCgodCAtIHN0ZXBzW2kgLSAxXSkgLyAoc3RlcHNbaV0gLSBzdGVwc1tpIC0gMV0pLCAwLjAsIDEuMCkpOwogICAgfQogICAgaWYgKHN0ZXBzW2ldID49IHQpIHsKICAgICAgYnJlYWs7CiAgICB9CiAgfQp9CiNlbmRpZgoKdm9pZCB0cmFuc2Zvcm1Db2xvcihpbm91dCB2ZWM0IGNvbG9yLCBpbiBmbG9hdCBjb2xvck1hdHJpeFsyMF0pIHsKICBmbG9hdCByID0gY29sb3IuciwgZyA9IGNvbG9yLmcsIGIgPSBjb2xvci5iLCBhID0gY29sb3IuYTsKICBjb2xvclswXSA9IGNvbG9yTWF0cml4WzBdICogciArIGNvbG9yTWF0cml4WzFdICogZyArIGNvbG9yTWF0cml4WzJdICogYiArIGNvbG9yTWF0cml4WzNdICogYSArIGNvbG9yTWF0cml4WzRdOwogIGNvbG9yWzFdID0gY29sb3JNYXRyaXhbNV0gKiByICsgY29sb3JNYXRyaXhbNl0gKiBnICsgY29sb3JNYXRyaXhbN10gKiBiICsgY29sb3JNYXRyaXhbOF0gKiBhICsgY29sb3JNYXRyaXhbOV07CiAgY29sb3JbMl0gPSBjb2xvck1hdHJpeFsxMF0gKiByICsgY29sb3JNYXRyaXhbMTFdICogZyArIGNvbG9yTWF0cml4WzEyXSAqIGIgKyBjb2xvck1hdHJpeFsxM10gKiBhICsgY29sb3JNYXRyaXhbMTRdOwogIGNvbG9yWzNdID0gY29sb3JNYXRyaXhbMTVdICogciArIGNvbG9yTWF0cml4WzE2XSAqIGcgKyBjb2xvck1hdHJpeFsxN10gKiBiICsgY29sb3JNYXRyaXhbMThdICogYSArIGNvbG9yTWF0cml4WzE5XTsKfQoKI2lmZGVmIENMT1VERklMVEVSCnZvaWQgYnVpbGRDbG91ZENvbG9yKGlub3V0IGZsb2F0IGNvbG9yQ2xvdWRNYXRyaXhbMjBdKSB7CiAgY29sb3JDbG91ZE1hdHJpeFswXSA9IGNvbG9yQ2xvdWQwWzBdOwogIGNvbG9yQ2xvdWRNYXRyaXhbMV0gPSBjb2xvckNsb3VkMVswXTsKICBjb2xvckNsb3VkTWF0cml4WzJdID0gY29sb3JDbG91ZDJbMF07CiAgY29sb3JDbG91ZE1hdHJpeFszXSA9IGNvbG9yQ2xvdWQzWzBdOwogIGNvbG9yQ2xvdWRNYXRyaXhbNF0gPSBjb2xvckNsb3VkNFswXTsKCiAgY29sb3JDbG91ZE1hdHJpeFs1XSA9IGNvbG9yQ2xvdWQwWzFdOwogIGNvbG9yQ2xvdWRNYXRyaXhbNl0gPSBjb2xvckNsb3VkMVsxXTsKICBjb2xvckNsb3VkTWF0cml4WzddID0gY29sb3JDbG91ZDJbMV07CiAgY29sb3JDbG91ZE1hdHJpeFs4XSA9IGNvbG9yQ2xvdWQzWzFdOwogIGNvbG9yQ2xvdWRNYXRyaXhbOV0gPSBjb2xvckNsb3VkNFsxXTsKCiAgY29sb3JDbG91ZE1hdHJpeFsxMF0gPSBjb2xvckNsb3VkMFsyXTsKICBjb2xvckNsb3VkTWF0cml4WzExXSA9IGNvbG9yQ2xvdWQxWzJdOwogIGNvbG9yQ2xvdWRNYXRyaXhbMTJdID0gY29sb3JDbG91ZDJbMl07CiAgY29sb3JDbG91ZE1hdHJpeFsxM10gPSBjb2xvckNsb3VkM1syXTsKICBjb2xvckNsb3VkTWF0cml4WzE0XSA9IGNvbG9yQ2xvdWQ0WzJdOwoKICBjb2xvckNsb3VkTWF0cml4WzE1XSA9IGNvbG9yQ2xvdWQwWzNdOwogIGNvbG9yQ2xvdWRNYXRyaXhbMTZdID0gY29sb3JDbG91ZDFbM107CiAgY29sb3JDbG91ZE1hdHJpeFsxN10gPSBjb2xvckNsb3VkMlszXTsKICBjb2xvckNsb3VkTWF0cml4WzE4XSA9IGNvbG9yQ2xvdWQzWzNdOwogIGNvbG9yQ2xvdWRNYXRyaXhbMTldID0gY29sb3JDbG91ZDRbM107Cn0KI2VuZGlmCgp2b2lkIG1haW4oKSB7CiAgdmVjNCBjb2xvciA9IHZDb2xvcjsKICBmbG9hdCBvcGFjaXR5ID0gYWJzKGZsYWdCYWNrZ3JvdW5kKTsKCiNpZmRlZiBHUkFESUVOVAogIGlmKHVfZ3JhZGllbnRUeXBlID4gMCAmJiBmbGFnQmFja2dyb3VuZCA+IDAuMCB8fCB1X2dyYWRpZW50VHlwZSA9PSAwICYmIGZsYWdCYWNrZ3JvdW5kIDw9IDAuMCkgewogICAgZ3JhZGllbnQoY29sb3IsIHZHcmFkaWVudFZlY3RvcjEsIHZHcmFkaWVudFZlY3RvcjIsIHVfY29sb3JTdGVwcyk7CiAgfQojZW5kaWYKCiAgaWYob3BhY2l0eSA8IDEuMCkgewogICAgY29sb3IuYSAqPSBvcGFjaXR5OwogIH0KCiNpZmRlZiBURVhUVVJFCiAgaWYoZmxhZ0JhY2tncm91bmQgPiAwLjApIHsKICAgIHZlYzMgdGV4Q29vcmQgPSB2VGV4dHVyZUNvb3JkOwoKICAgIGlmKHRleENvb3JkLnogPT0gMS4wKSB7CiAgICAgIHRleENvb3JkID0gZnJhY3QodGV4Q29vcmQpOwogICAgfQoKICAgIGlmKHRleENvb3JkLnggPD0gMS4wICYmIHRleENvb3JkLnggPj0gMC4wCiAgICAgICYmIHRleENvb3JkLnkgPD0gMS4wICYmIHRleENvb3JkLnkgPj0gMC4wKSB7CiAgICAgIGlmKHZTb3VyY2VSZWN0LnogPiAwLjApIHsKICAgICAgICB0ZXhDb29yZC54ID0gdlNvdXJjZVJlY3QueCArIHRleENvb3JkLnggKiB2U291cmNlUmVjdC56OwogICAgICAgIHRleENvb3JkLnkgPSAxLjAgLSAodlNvdXJjZVJlY3QueSArICgxLjAgLSB0ZXhDb29yZC55KSAqIHZTb3VyY2VSZWN0LncpOwogICAgICB9CiAgICAgIGlmKGZyYW1lSW5kZXggPCAwLjApIHsKICAgICAgICB2ZWM0IHRleENvbG9yID0gdGV4dHVyZTJEKHVfdGV4U2FtcGxlciwgdGV4Q29vcmQueHkpOwogICAgICAgIGNvbG9yID0gbWl4KGNvbG9yLCB0ZXhDb2xvciwgdGV4Q29sb3IuYSk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgaW50IGluZGV4ID0gaW50KGZsb29yKGNsYW1wKDAuMCwgMTEuMCwgZnJhbWVJbmRleCkpKTsKICAgICAgICB2ZWM0IHRleENvbG9yOwogICAgICAgIGlmKGluZGV4ID09IDApIHRleENvbG9yID0gdGV4dHVyZTJEKHVfdGV4RnJhbWUwLCB0ZXhDb29yZC54eSk7CiAgICAgICAgZWxzZSBpZihpbmRleCA9PSAxKSB0ZXhDb2xvciA9IHRleHR1cmUyRCh1X3RleEZyYW1lMSwgdGV4Q29vcmQueHkpOwogICAgICAgIGVsc2UgaWYoaW5kZXggPT0gMikgdGV4Q29sb3IgPSB0ZXh0dXJlMkQodV90ZXhGcmFtZTIsIHRleENvb3JkLnh5KTsKICAgICAgICBlbHNlIGlmKGluZGV4ID09IDMpIHRleENvbG9yID0gdGV4dHVyZTJEKHVfdGV4RnJhbWUzLCB0ZXhDb29yZC54eSk7CiAgICAgICAgZWxzZSBpZihpbmRleCA9PSA0KSB0ZXhDb2xvciA9IHRleHR1cmUyRCh1X3RleEZyYW1lNCwgdGV4Q29vcmQueHkpOwogICAgICAgIGVsc2UgaWYoaW5kZXggPT0gNSkgdGV4Q29sb3IgPSB0ZXh0dXJlMkQodV90ZXhGcmFtZTUsIHRleENvb3JkLnh5KTsKICAgICAgICBlbHNlIGlmKGluZGV4ID09IDYpIHRleENvbG9yID0gdGV4dHVyZTJEKHVfdGV4RnJhbWU2LCB0ZXhDb29yZC54eSk7CiAgICAgICAgZWxzZSBpZihpbmRleCA9PSA3KSB0ZXhDb2xvciA9IHRleHR1cmUyRCh1X3RleEZyYW1lNywgdGV4Q29vcmQueHkpOwogICAgICAgIGVsc2UgaWYoaW5kZXggPT0gOCkgdGV4Q29sb3IgPSB0ZXh0dXJlMkQodV90ZXhGcmFtZTgsIHRleENvb3JkLnh5KTsKICAgICAgICBlbHNlIGlmKGluZGV4ID09IDkpIHRleENvbG9yID0gdGV4dHVyZTJEKHVfdGV4RnJhbWU5LCB0ZXhDb29yZC54eSk7CiAgICAgICAgZWxzZSBpZihpbmRleCA9PSAxMCkgdGV4Q29sb3IgPSB0ZXh0dXJlMkQodV90ZXhGcmFtZTEwLCB0ZXhDb29yZC54eSk7CiAgICAgICAgZWxzZSB0ZXhDb2xvciA9IHRleHR1cmUyRCh1X3RleEZyYW1lMTEsIHRleENvb3JkLnh5KTsKICAgICAgICBmbG9hdCBhbHBoYSA9IHRleENvbG9yLmE7CiAgICAgICAgaWYob3BhY2l0eSA8IDEuMCkgewogICAgICAgICAgdGV4Q29sb3IuYSAqPSBvcGFjaXR5OwogICAgICAgICAgYWxwaGEgKj0gbWl4KDAuNDY1LCAxLjAsIG9wYWNpdHkpOwogICAgICAgIH0KICAgICAgICAvLyBjb2xvciA9IG1peChjb2xvciwgdGV4Q29sb3IsIHRleENvbG9yLmEpOwogICAgICAgIGNvbG9yLnJnYiA9IG1peChjb2xvci5yZ2IsIHRleENvbG9yLnJnYiwgYWxwaGEpOwogICAgICAgIC8vIGNvbG9yLnJnYiA9IG1peCh0ZXhDb2xvci5yZ2IsIGNvbG9yLnJnYiwgY29sb3IuYSk7CiAgICAgICAgY29sb3IucmdiID0gbWl4KHRleENvbG9yLnJnYiwgY29sb3IucmdiLCBjbGFtcChjb2xvci5hIC8gbWF4KDAuMDAwMSwgdGV4Q29sb3IuYSksIDAuMCwgMS4wKSk7CiAgICAgICAgY29sb3IuYSA9IHRleENvbG9yLmEgKyAoMS4wIC0gdGV4Q29sb3IuYSkgKiBjb2xvci5hOwogICAgICB9CiAgICB9CiAgfQojZW5kaWYKCiNpZmRlZiBGSUxURVIKICBpZih1X2ZpbHRlckZsYWcgPiAwKSB7CiAgICB0cmFuc2Zvcm1Db2xvcihjb2xvciwgdV9jb2xvck1hdHJpeCk7CiAgfQojZW5kaWYKCiNpZmRlZiBDTE9VREZJTFRFUgogIGZsb2F0IGNvbG9yQ2xvdWRNYXRyaXhbMjBdOwogIGJ1aWxkQ2xvdWRDb2xvcihjb2xvckNsb3VkTWF0cml4KTsKICB0cmFuc2Zvcm1Db2xvcihjb2xvciwgY29sb3JDbG91ZE1hdHJpeCk7CiNlbmRpZgoKI2lmZGVmIENMSVBQQVRICiAgZmxvYXQgY2xpcCA9IHRleHR1cmUyRCh1X2NsaXBTYW1wbGVyLCB2Q2xpcFVWKS5yOwogIGNvbG9yICo9IGNsaXA7CiNlbmRpZgoKICBnbF9GcmFnQ29sb3IgPSBjb2xvcjsKfWB9LGZ1bmN0aW9uKFIsZSx0KXt0LnIoZSksKGZ1bmN0aW9uKGksbyl7dC5kKGUsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsZnVuY3Rpb24oKXtyZXR1cm4gdn0pLHQuZChlLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsZnVuY3Rpb24oKXtyZXR1cm4gY30pLHQoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBnKCl7aWYodHlwZW9mIHBlcmZvcm1hbmNlPCJ1IiYmcGVyZm9ybWFuY2Uubm93KXJldHVybiBwZXJmb3JtYW5jZS5ub3coKTtpZih0eXBlb2YgaTwidSImJmkuaHJ0aW1lKXtjb25zdFtmLGhdPWkuaHJ0aW1lKCk7cmV0dXJuIGYqMWUzK2gqMWUtNn1yZXR1cm4gRGF0ZS5ub3c/RGF0ZS5ub3coKTpuZXcgRGF0ZSgpLmdldFRpbWUoKX1sZXQgdixjO3R5cGVvZiBvPCJ1IiYmdHlwZW9mIG8ucmVxdWVzdEFuaW1hdGlvbkZyYW1lPT0iZnVuY3Rpb24iPyh2PW8ucmVxdWVzdEFuaW1hdGlvbkZyYW1lLGM9by5jYW5jZWxBbmltYXRpb25GcmFtZSk6KHY9ZnVuY3Rpb24oZil7cmV0dXJuIHNldFRpbWVvdXQoKCk9PntmKGcoKSl9LDE2KX0sYz1mdW5jdGlvbihmKXtyZXR1cm4gY2xlYXJUaW1lb3V0KGYpfSl9KS5jYWxsKHRoaXMsdCg2OSksdCgyMikpfSxmdW5jdGlvbihSLGUpe3ZhciB0PVIuZXhwb3J0cz17fSxpLG87ZnVuY3Rpb24gZygpe3Rocm93IG5ldyBFcnJvcigic2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCIpfWZ1bmN0aW9uIHYoKXt0aHJvdyBuZXcgRXJyb3IoImNsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCIpfShmdW5jdGlvbigpe3RyeXt0eXBlb2Ygc2V0VGltZW91dD09ImZ1bmN0aW9uIj9pPXNldFRpbWVvdXQ6aT1nfWNhdGNoe2k9Z310cnl7dHlwZW9mIGNsZWFyVGltZW91dD09ImZ1bmN0aW9uIj9vPWNsZWFyVGltZW91dDpvPXZ9Y2F0Y2h7bz12fX0pKCk7ZnVuY3Rpb24gYyh5KXtpZihpPT09c2V0VGltZW91dClyZXR1cm4gc2V0VGltZW91dCh5LDApO2lmKChpPT09Z3x8IWkpJiZzZXRUaW1lb3V0KXJldHVybiBpPXNldFRpbWVvdXQsc2V0VGltZW91dCh5LDApO3RyeXtyZXR1cm4gaSh5LDApfWNhdGNoe3RyeXtyZXR1cm4gaS5jYWxsKG51bGwseSwwKX1jYXRjaHtyZXR1cm4gaS5jYWxsKHRoaXMseSwwKX19fWZ1bmN0aW9uIGYoeSl7aWYobz09PWNsZWFyVGltZW91dClyZXR1cm4gY2xlYXJUaW1lb3V0KHkpO2lmKChvPT09dnx8IW8pJiZjbGVhclRpbWVvdXQpcmV0dXJuIG89Y2xlYXJUaW1lb3V0LGNsZWFyVGltZW91dCh5KTt0cnl7cmV0dXJuIG8oeSl9Y2F0Y2h7dHJ5e3JldHVybiBvLmNhbGwobnVsbCx5KX1jYXRjaHtyZXR1cm4gby5jYWxsKHRoaXMseSl9fX12YXIgaD1bXSxFPSExLGwsbT0tMTtmdW5jdGlvbiBwKCl7IUV8fCFsfHwoRT0hMSxsLmxlbmd0aD9oPWwuY29uY2F0KGgpOm09LTEsaC5sZW5ndGgmJkMoKSl9ZnVuY3Rpb24gQygpe2lmKCFFKXt2YXIgeT1jKHApO0U9ITA7Zm9yKHZhciByPWgubGVuZ3RoO3I7KXtmb3IobD1oLGg9W107KyttPHI7KWwmJmxbbV0ucnVuKCk7bT0tMSxyPWgubGVuZ3RofWw9bnVsbCxFPSExLGYoeSl9fXQubmV4dFRpY2s9ZnVuY3Rpb24oeSl7dmFyIHI9bmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgtMSk7aWYoYXJndW1lbnRzLmxlbmd0aD4xKWZvcih2YXIgcz0xO3M8YXJndW1lbnRzLmxlbmd0aDtzKyspcltzLTFdPWFyZ3VtZW50c1tzXTtoLnB1c2gobmV3IHgoeSxyKSksaC5sZW5ndGg9PT0xJiYhRSYmYyhDKX07ZnVuY3Rpb24geCh5LHIpe3RoaXMuZnVuPXksdGhpcy5hcnJheT1yfXgucHJvdG90eXBlLnJ1bj1mdW5jdGlvbigpe3RoaXMuZnVuLmFwcGx5KG51bGwsdGhpcy5hcnJheSl9LHQudGl0bGU9ImJyb3dzZXIiLHQuYnJvd3Nlcj0hMCx0LmVudj17fSx0LmFyZ3Y9W10sdC52ZXJzaW9uPSIiLHQudmVyc2lvbnM9e307ZnVuY3Rpb24gZCgpe310Lm9uPWQsdC5hZGRMaXN0ZW5lcj1kLHQub25jZT1kLHQub2ZmPWQsdC5yZW1vdmVMaXN0ZW5lcj1kLHQucmVtb3ZlQWxsTGlzdGVuZXJzPWQsdC5lbWl0PWQsdC5wcmVwZW5kTGlzdGVuZXI9ZCx0LnByZXBlbmRPbmNlTGlzdGVuZXI9ZCx0Lmxpc3RlbmVycz1mdW5jdGlvbih5KXtyZXR1cm5bXX0sdC5iaW5kaW5nPWZ1bmN0aW9uKHkpe3Rocm93IG5ldyBFcnJvcigicHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQiKX0sdC5jd2Q9ZnVuY3Rpb24oKXtyZXR1cm4iLyJ9LHQuY2hkaXI9ZnVuY3Rpb24oeSl7dGhyb3cgbmV3IEVycm9yKCJwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQiKX0sdC51bWFzaz1mdW5jdGlvbigpe3JldHVybiAwfX0sZnVuY3Rpb24oUixlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gYn0pO3ZhciBpPXQoMSksbz10KDcxKSxnPXQoNzMpLHY9dCgyMTMpLGM9dCgyMTQpLGY9dCgyMTUpLGg9dCgyMTYpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBFKEksUCl7dmFyIEQ9T2JqZWN0LmtleXMoSSk7aWYoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyl7dmFyIEw9T2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhJKTtQJiYoTD1MLmZpbHRlcihmdW5jdGlvbihTKXtyZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihJLFMpLmVudW1lcmFibGV9KSksRC5wdXNoLmFwcGx5KEQsTCl9cmV0dXJuIER9ZnVuY3Rpb24gbChJKXtmb3IodmFyIFA9MTtQPGFyZ3VtZW50cy5sZW5ndGg7UCsrKXt2YXIgRD1hcmd1bWVudHNbUF0hPW51bGw/YXJndW1lbnRzW1BdOnt9O1AlMj9FKE9iamVjdChEKSwhMCkuZm9yRWFjaChmdW5jdGlvbihMKXttKEksTCxEW0xdKX0pOk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzP09iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEksT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoRCkpOkUoT2JqZWN0KEQpKS5mb3JFYWNoKGZ1bmN0aW9uKEwpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShJLEwsT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihELEwpKX0pfXJldHVybiBJfWZ1bmN0aW9uIG0oSSxQLEQpe3JldHVybiBQIGluIEk/T2JqZWN0LmRlZmluZVByb3BlcnR5KEksUCx7dmFsdWU6RCxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOklbUF09RCxJfWNvbnN0IHA9U3ltYm9sLmZvcigic3ByaXRlanNfY2hhbmdlZEF0dHJzIiksQz1TeW1ib2wuZm9yKCJzcHJpdGVqc19hdHRyaWJ1dGVzIikseD1TeW1ib2woInJlc29sdXRpb24iKSxkPVN5bWJvbCgiYW5pbWF0aW9ucyIpLHk9U3ltYm9sKCJldmVudExpc3RlbmVycyIpLHI9U3ltYm9sKCJjYXB0dXJlRXZlbnRMaXN0ZW5lcnMiKSxzPVN5bWJvbCgiZmlsdGVycyIpLG49U3ltYm9sKCJkaXNwbGF5IiksYT1TeW1ib2woInByb2dyYW0iKSxPPVN5bWJvbCgic2hhZGVyQXR0cnMiKSxBPVN5bWJvbCgidW5pZm9ybXMiKTtjbGFzcyBie2NvbnN0cnVjdG9yKFA9e30pe3RoaXMuYXR0cmlidXRlcz1uZXcgdGhpcy5jb25zdHJ1Y3Rvci5BdHRyKHRoaXMpLHRoaXNbeF09e3dpZHRoOjMwMCxoZWlnaHQ6MTUwfSxPYmplY3QuYXNzaWduKHRoaXMuYXR0cmlidXRlcyxQKSx0aGlzW2RdPW5ldyBTZXQsdGhpc1t5XT17fSx0aGlzW3JdPXt9fWdldCBhbmNlc3RvcnMoKXtsZXQgUD10aGlzLnBhcmVudDtjb25zdCBEPVtdO2Zvcig7UDspRC5wdXNoKFApLFA9UC5wYXJlbnQ7cmV0dXJuIER9Z2V0IGFuaW1hdGlvbnMoKXtyZXR1cm4gdGhpc1tkXX1nZXQgZmlsdGVycygpe3JldHVybiB0aGlzW3NdfHx0aGlzLnBhcmVudCYmdGhpcy5wYXJlbnQuZmlsdGVyc31nZXQgaXNWaXNpYmxlKCl7cmV0dXJuITF9Z2V0IGxheWVyKCl7cmV0dXJuIHRoaXMucGFyZW50P3RoaXMucGFyZW50LmxheWVyOm51bGx9Z2V0IGxvY2FsTWF0cml4KCl7Y29uc3QgUD10aGlzLnRyYW5zZm9ybU1hdHJpeCx7eDpELHk6TH09dGhpcy5hdHRyaWJ1dGVzO3JldHVybiBQWzRdKz1ELFBbNV0rPUwsUH1nZXQgb3BhY2l0eSgpe2xldCBQPXRoaXMuYXR0cmlidXRlcy5vcGFjaXR5O3JldHVybiB0aGlzLnBhcmVudCYmdGhpcy5wYXJlbnQub3BhY2l0eSE9bnVsbCYmKFAqPXRoaXMucGFyZW50Lm9wYWNpdHkpLFB9Z2V0IHBhcmVudE5vZGUoKXtyZXR1cm4gdGhpcy5wYXJlbnR9Z2V0IG5leHRTaWJsaW5nKCl7cmV0dXJuIHRoaXMuZ2V0Tm9kZU5lYXJCeSgxKX1nZXQgcHJldmlvdXNTaWJsaW5nKCl7cmV0dXJuIHRoaXMuZ2V0Tm9kZU5lYXJCeSgtMSl9Z2V0IHByb2dyYW0oKXtyZXR1cm4gdGhpc1thXX1nZXQgcmVuZGVyZXIoKXtyZXR1cm4gdGhpcy5wYXJlbnQ/dGhpcy5wYXJlbnQucmVuZGVyZXI6bnVsbH1nZXQgcmVuZGVyTWF0cml4KCl7aWYodGhpcy5fX2NhY2hlUmVuZGVyTWF0cml4KXJldHVybiB0aGlzLl9fY2FjaGVSZW5kZXJNYXRyaXg7bGV0IFA9dGhpcy5sb2NhbE1hdHJpeDtjb25zdCBEPXRoaXMucGFyZW50O2lmKEQpe2NvbnN0IEw9RC5fX2NhY2hlUmVuZGVyTWF0cml4fHxELnJlbmRlck1hdHJpeDtMJiYoUD1pLm1hdDJkLm11bHRpcGx5KEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxMLFApKX1yZXR1cm4gUH1nZXQgd29ybGRTY2FsaW5nKCl7Y29uc3QgUD10aGlzLnJlbmRlck1hdHJpeDtyZXR1cm5bTWF0aC5oeXBvdChQWzBdLFBbMV0pLE1hdGguaHlwb3QoUFsyXSxQWzNdKV19Z2V0IHdvcmxkUm90YXRpb24oKXtjb25zdCBQPXRoaXMucmVuZGVyTWF0cml4O3JldHVybiBNYXRoLmF0YW4yKFBbMV0sUFszXSl9Z2V0IHdvcmxkUG9zaXRpb24oKXtjb25zdCBQPXRoaXMucmVuZGVyTWF0cml4O3JldHVybltQWzRdLFBbNV1dfWdldCB1bmlmb3Jtcygpe3JldHVybiB0aGlzW0FdfWdldCBjbGFzc05hbWUoKXtyZXR1cm4gdGhpcy5hdHRyaWJ1dGVzLmNsYXNzTmFtZX1zZXQgY2xhc3NOYW1lKFApe3RoaXMuYXR0cmlidXRlcy5jbGFzc05hbWU9UH1nZXQgaWQoKXtyZXR1cm4gdGhpcy5hdHRyaWJ1dGVzLmlkfXNldCBpZChQKXt0aGlzLmF0dHJpYnV0ZXMuaWQ9UH1nZXQgbmFtZSgpe3JldHVybiB0aGlzLmF0dHJpYnV0ZXMubmFtZX1zZXQgbmFtZShQKXt0aGlzLmF0dHJpYnV0ZXMubmFtZT1QfWdldCB6SW5kZXgoKXtyZXR1cm4gdGhpcy5hdHRyaWJ1dGVzLnpJbmRleH1zZXQgekluZGV4KFApe3RoaXMuYXR0cmlidXRlcy56SW5kZXg9UH1nZXQgbWVzaCgpe3JldHVybiBudWxsfWdldCBzaGFkZXJBdHRycygpe3JldHVybiB0aGlzW09dfHx7fX1hY3RpdmF0ZUFuaW1hdGlvbnMoKXtjb25zdCBQPXRoaXMubGF5ZXI7aWYoUCl7Y29uc3QgRD10aGlzW2RdO0QuZm9yRWFjaChTPT57Uy5iYXNlVGltZWxpbmU9UC50aW1lbGluZSxTLnBsYXkoKSxTLmZpbmlzaGVkLnRoZW4oKCk9PntELmRlbGV0ZShTKX0pfSk7Y29uc3QgTD10aGlzLmNoaWxkcmVuO0wmJkwuZm9yRWFjaChTPT57Uy5hY3RpdmF0ZUFuaW1hdGlvbnMmJlMuYWN0aXZhdGVBbmltYXRpb25zKCl9KX19YWRkRXZlbnRMaXN0ZW5lcihQLEQsTD17fSl7UD09PSJtb3VzZXdoZWVsIiYmKFA9IndoZWVsIiksdHlwZW9mIEw9PSJib29sZWFuIiYmKEw9e2NhcHR1cmU6TH0pO2NvbnN0e2NhcHR1cmU6UyxvbmNlOlR9PUwsaj1TP3I6eTtyZXR1cm4gdGhpc1tqXVtQXT10aGlzW2pdW1BdfHxbXSx0aGlzW2pdW1BdLnB1c2goe2xpc3RlbmVyOkQsb25jZTpUfSksdGhpc31hbmltYXRlKFAsRCl7Y29uc3QgTD1uZXcgZy5kZWZhdWx0KHRoaXMsUCxEKTtyZXR1cm4gdGhpcy5lZmZlY3RzJiZMLmFwcGx5RWZmZWN0cyh0aGlzLmVmZmVjdHMpLHRoaXMubGF5ZXImJihMLmJhc2VUaW1lbGluZT10aGlzLmxheWVyLnRpbWVsaW5lLEwucGxheSgpLEwuZmluaXNoZWQudGhlbigoKT0+e3RoaXNbZF0uZGVsZXRlKEwpfSkpLHRoaXNbZF0uYWRkKEwpLEx9YXR0ciguLi5QKXtpZihQLmxlbmd0aD09PTApcmV0dXJuIHRoaXMuYXR0cmlidXRlc1tDXTtpZihQLmxlbmd0aD4xKXtsZXRbRCxMXT1QO3JldHVybiB0eXBlb2YgTD09ImZ1bmN0aW9uIiYmKEw9TCh0aGlzLmF0dHIoRCkpKSx0aGlzLnNldEF0dHJpYnV0ZShELEwpLHRoaXN9cmV0dXJuIHR5cGVvZiBQWzBdPT0ic3RyaW5nIj90aGlzLmdldEF0dHJpYnV0ZShQWzBdKTooT2JqZWN0LmFzc2lnbih0aGlzLmF0dHJpYnV0ZXMsUFswXSksdGhpcyl9Y2xvbmVOb2RlKCl7Y29uc3QgUD1uZXcgdGhpcy5jb25zdHJ1Y3RvcixEPXRoaXMuYXR0cmlidXRlc1twXTtyZXR1cm4gUC5hdHRyKEQpLFB9Y29ubmVjdChQLEQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJwYXJlbnQiLHt2YWx1ZTpQLHdyaXRhYmxlOiExLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ6T3JkZXIiLHt2YWx1ZTpELHdyaXRhYmxlOiExLGNvbmZpZ3VyYWJsZTohMH0pLFAudGltZWxpbmUmJnRoaXMuYWN0aXZhdGVBbmltYXRpb25zKCksdGhpcy5zZXRSZXNvbHV0aW9uKFAuZ2V0UmVzb2x1dGlvbigpKSx0aGlzLmZvcmNlVXBkYXRlKCksdGhpcy5kaXNwYXRjaEV2ZW50KHt0eXBlOiJhcHBlbmQiLGRldGFpbDp7cGFyZW50OlAsek9yZGVyOkR9fSl9Y29udGFpbnMoUCl7Zm9yKDtQJiZ0aGlzIT09UDspUD1QLnBhcmVudDtyZXR1cm4hIVB9ZGVhY3RpdmF0ZUFuaW1hdGlvbnMoKXt0aGlzW2RdLmZvckVhY2goRD0+RC5jYW5jZWwoKSk7Y29uc3QgUD10aGlzLmNoaWxkcmVuO1AmJlAuZm9yRWFjaChEPT57RC5kZWFjdGl2YXRlQW5pbWF0aW9ucyYmRC5kZWFjdGl2YXRlQW5pbWF0aW9ucygpfSl9ZGlzY29ubmVjdCgpe2NvbnN0e3BhcmVudDpQLHpPcmRlcjpEfT10aGlzO2RlbGV0ZSB0aGlzLnBhcmVudCxkZWxldGUgdGhpcy56T3JkZXIsdGhpcy5kZWFjdGl2YXRlQW5pbWF0aW9ucygpLHRoaXMuZGlzcGF0Y2hFdmVudCh7dHlwZToicmVtb3ZlIixkZXRhaWw6e3BhcmVudDpQLHpPcmRlcjpEfX0pLFAmJlAuZm9yY2VVcGRhdGUoKX1kaXNwYXRjaEV2ZW50KFApe1AgaW5zdGFuY2VvZiBjLmRlZmF1bHR8fChQPW5ldyBjLmRlZmF1bHQoUCkpLFAudGFyZ2V0PXRoaXM7bGV0IEQ9UC50eXBlO0Q9PT0ibW91c2V3aGVlbCImJihEPSJ3aGVlbCIpO2NvbnN0IEw9W3RoaXNdO2xldCBTPXRoaXMucGFyZW50O2Zvcig7UC5idWJibGVzJiZTOylMLnB1c2goUyksUz1TLnBhcmVudDtmb3IobGV0IFQ9TC5sZW5ndGgtMTtUPj0wO1QtLSl7Y29uc3Qgaj1MW1RdLCQ9altyXSYmaltyXVtEXTtpZigkJiYkLmxlbmd0aCYmKFAuY3VycmVudFRhcmdldD1qLCQuZm9yRWFjaCgoe2xpc3RlbmVyOncsb25jZTpKfSk9Pnt3LmNhbGwodGhpcyxQKSxKJiZMLnJlbW92ZUV2ZW50TGlzdGVuZXIodyl9KSxkZWxldGUgUC5jdXJyZW50VGFyZ2V0KSwhUC5idWJibGVzJiZQLmNhbmNlbEJ1YmJsZSlicmVha31pZighUC5jYW5jZWxCdWJibGUpZm9yKGxldCBUPTA7VDxMLmxlbmd0aDtUKyspe2NvbnN0IGo9TFtUXSwkPWpbeV0mJmpbeV1bRF07aWYoJCYmJC5sZW5ndGgmJihQLmN1cnJlbnRUYXJnZXQ9aiwkLmZvckVhY2goKHtsaXN0ZW5lcjp3LG9uY2U6Sn0pPT57dy5jYWxsKHRoaXMsUCksSiYmTC5yZW1vdmVFdmVudExpc3RlbmVyKHcpfSksZGVsZXRlIFAuY3VycmVudFRhcmdldCksIVAuYnViYmxlc3x8UC5jYW5jZWxCdWJibGUpYnJlYWt9fWRpc3BhdGNoUG9pbnRlckV2ZW50KFApe2NvbnN0e2xheWVyWDpELGxheWVyWTpMfT1QO3JldHVybiB0aGlzLmlzUG9pbnRDb2xsaXNpb24oRCxMKT8odGhpcy5kaXNwYXRjaEV2ZW50KFApLCEwKTohMX1kcmF3KFA9W10pe2NvbnN0IEQ9dGhpcy5tZXNoO2lmKEQpe2lmKE9iamVjdChmLmFwcGx5RmlsdGVycykoRCx0aGlzLmZpbHRlcnMpLFAucHVzaChEKSx0aGlzW2FdKXtELnNldFByb2dyYW0odGhpc1thXSk7Y29uc3QgTD10aGlzW09dO0wmJk9iamVjdC5lbnRyaWVzKEwpLmZvckVhY2goKFtULGpdKT0+e0Quc2V0QXR0cmlidXRlKFQsail9KTtjb25zdCBTPXRoaXNbQV07aWYodGhpc1tBXSl7Y29uc3QgVD17fTtPYmplY3QuZW50cmllcyhTKS5mb3JFYWNoKChbaiwkXSk9Pnt0eXBlb2YgJD09ImZ1bmN0aW9uIiYmKCQ9JCh0aGlzLGopKSxUW2pdPSR9KSxELnNldFVuaWZvcm1zKFQpfX1PYmplY3QoaC5kZWZhdWx0KSh0aGlzLEQpfXJldHVybiBQfWZvcmNlVXBkYXRlKCl7dGhpcy5wYXJlbnQmJnRoaXMucGFyZW50LmZvcmNlVXBkYXRlKCl9Z2V0QXR0cmlidXRlKFApe3JldHVybiB0aGlzLmF0dHJpYnV0ZXNbUF19Z2V0TGlzdGVuZXJzKFAse2NhcHR1cmU6RD0hMX09e30pe3JldHVyblsuLi50aGlzW0Q/cjp5XVtQXXx8W11dfWdldE5vZGVOZWFyQnkoUD0xKXtpZighdGhpcy5wYXJlbnQpcmV0dXJuIG51bGw7aWYoUD09PTApcmV0dXJuIHRoaXM7Y29uc3QgRD10aGlzLnBhcmVudC5jaGlsZHJlbixMPUQuaW5kZXhPZih0aGlzKTtyZXR1cm4gRFtMK1BdfWdldFdvcmxkUG9zaXRpb24oUCxEKXtjb25zdCBMPXRoaXMucmVuZGVyTWF0cml4LFM9UCpMWzBdK0QqTFsyXStMWzRdLFQ9UCpMWzFdK0QqTFszXStMWzVdO3JldHVybltTLFRdfWdldE9mZnNldFBvc2l0aW9uKFAsRCl7Y29uc3QgTD1pLm1hdDJkLmludmVydChBcnJheS5vZigwLDAsMCwwLDAsMCksdGhpcy5yZW5kZXJNYXRyaXgpLFM9UCpMWzBdK0QqTFsyXStMWzRdLFQ9UCpMWzFdK0QqTFszXStMWzVdO3JldHVybltTLFRdfWdldFJlc29sdXRpb24oKXtyZXR1cm4gbCh7fSx0aGlzW3hdKX1pc1BvaW50Q29sbGlzaW9uKFAsRCl7aWYoIXRoaXMubWVzaClyZXR1cm4hMTtjb25zdCBMPXRoaXMuYXR0cmlidXRlcy5wb2ludGVyRXZlbnRzO2lmKEw9PT0ibm9uZSJ8fEwhPT0iYWxsIiYmIXRoaXMuaXNWaXNpYmxlKXJldHVybiExO2xldCBTPSJib3RoIjtyZXR1cm4gTD09PSJ2aXNpYmxlRmlsbCImJihTPSJmaWxsIiksTD09PSJ2aXNpYmxlU3Ryb2tlIiYmKFM9InN0cm9rZSIpLHRoaXMubWVzaC5pc1BvaW50Q29sbGlzaW9uKFAsRCxTKX1vblByb3BlcnR5Q2hhbmdlKFAsRCxMKXtQIT09ImlkIiYmUCE9PSJuYW1lIiYmUCE9PSJjbGFzc05hbWUiJiZQIT09InBvaW50ZXJFdmVudHMiJiZQIT09InBhc3NFdmVudHMiJiZ0aGlzLmZvcmNlVXBkYXRlKCksUD09PSJmaWx0ZXIiJiYodGhpc1tzXT1PYmplY3QoZi5wYXJzZUZpbHRlclN0cmluZykoRCkpLFA9PT0iekluZGV4IiYmdGhpcy5wYXJlbnQmJnRoaXMucGFyZW50LnJlb3JkZXIoKX1zZXRBdHRyaWJ1dGUoUCxEKXtQPT09ImF0dHJzIiYmdGhpcy5hdHRyKEQpLHRoaXMuYXR0cmlidXRlc1tQXT1EfXNldE1vdXNlQ2FwdHVyZSgpe3RoaXMubGF5ZXImJih0aGlzLmxheWVyLl9fbW91c2VDYXB0dXJlZFRhcmdldD10aGlzKX1zZXRQcm9ncmFtKFApe3RoaXNbYV09UCx0aGlzLmZvcmNlVXBkYXRlKCl9c2V0U2hhZGVyQXR0cmlidXRlKFAsRCl7dGhpc1tPXT10aGlzW09dfHx7fSx0aGlzW09dW1BdPUQsdGhpcy5mb3JjZVVwZGF0ZSgpfXNldFVuaWZvcm1zKFApe3RoaXNbQV09dGhpc1tBXXx8e30sT2JqZWN0LmFzc2lnbih0aGlzW0FdLFApLHRoaXMuZm9yY2VVcGRhdGUoKX1zZXRSZXNvbHV0aW9uKHt3aWR0aDpQLGhlaWdodDpEfSl7Y29uc3R7d2lkdGg6TCxoZWlnaHQ6U309dGhpc1t4XTsoTCE9PVB8fFMhPT1EKSYmKHRoaXNbeF09e3dpZHRoOlAsaGVpZ2h0OkR9LHRoaXMuZm9yY2VVcGRhdGUoKSx0aGlzLmRpc3BhdGNoRXZlbnQoe3R5cGU6InJlc29sdXRpb25jaGFuZ2UiLGRldGFpbDp7d2lkdGg6UCxoZWlnaHQ6RH19KSl9c2hvdygpe3RoaXMuYXR0cmlidXRlcy5kaXNwbGF5PT09Im5vbmUiJiYodGhpcy5hdHRyaWJ1dGVzLmRpc3BsYXk9dGhpc1tuXXx8IiIpfWhpZGUoKXt0aGlzLmF0dHJpYnV0ZXMuZGlzcGxheSE9PSJub25lIiYmKHRoaXNbbl09dGhpcy5hdHRyaWJ1dGVzLmRpc3BsYXksdGhpcy5hdHRyaWJ1dGVzLmRpc3BsYXk9Im5vbmUiKX1yZWxlYXNlTW91c2VDYXB0dXJlKCl7dGhpcy5sYXllciYmdGhpcy5sYXllci5fX21vdXNlQ2FwdHVyZWRUYXJnZXQ9PT10aGlzJiYodGhpcy5sYXllci5fX21vdXNlQ2FwdHVyZWRUYXJnZXQ9bnVsbCl9cmVtb3ZlKCl7cmV0dXJuIHRoaXMucGFyZW50JiZ0aGlzLnBhcmVudC5yZW1vdmVDaGlsZD8odGhpcy5wYXJlbnQucmVtb3ZlQ2hpbGQodGhpcyksITApOiExfXJlbW92ZUFsbExpc3RlbmVycyhQLEQ9e30pe3R5cGVvZiBEPT0iYm9vbGVhbiImJihEPXtjYXB0dXJlOkR9KTtjb25zdCBTPUQuY2FwdHVyZT9yOnk7cmV0dXJuIHRoaXNbU11bUF0mJih0aGlzW1NdW1BdPVtdKSx0aGlzfXJlbW92ZUF0dHJpYnV0ZShQKXt0aGlzLnNldEF0dHJpYnV0ZShQLG51bGwpfXJlbW92ZUV2ZW50TGlzdGVuZXIoUCxELEw9e30pe3R5cGVvZiBMPT0iYm9vbGVhbiImJihMPXtjYXB0dXJlOkx9KTtjb25zdCBUPUwuY2FwdHVyZT9yOnk7aWYodGhpc1tUXVtQXSl7Y29uc3Qgaj10aGlzW1RdW1BdO2lmKGopZm9yKGxldCAkPTA7JDxqLmxlbmd0aDskKyspe2NvbnN0e2xpc3RlbmVyOnd9PWpbJF07aWYodz09PUQpe3RoaXNbVF1bUF0uc3BsaWNlKCQsMSk7YnJlYWt9fX1yZXR1cm4gdGhpc310cmFuc2l0aW9uKFAsRD0ibGluZWFyIil7Y29uc3QgTD10aGlzLFM9U3ltYm9sKCJhbmltYXRpb24iKTtEPUR8fCJsaW5lYXIiO2xldCBUPTA7cmV0dXJuIHR5cGVvZiBQPT0ib2JqZWN0IiYmKFQ9UC5kZWxheXx8MCxQPVAuZHVyYXRpb24pLHtbU106bnVsbCxjYW5jZWwoaj0hMSl7Y29uc3QgJD10aGlzW1NdOyQmJiQuY2FuY2VsKGopfSxlbmQoKXtjb25zdCBqPXRoaXNbU107aiYmKGoucGxheVN0YXRlPT09InJ1bm5pbmcifHxqLnBsYXlTdGF0ZT09PSJwZW5kaW5nIikmJmouZmluaXNoKCl9LHJldmVyc2UoKXtjb25zdCBqPXRoaXNbU107aWYoailpZihqLnBsYXlTdGF0ZT09PSJydW5uaW5nInx8ai5wbGF5U3RhdGU9PT0icGVuZGluZyIpai5wbGF5YmFja1JhdGU9LWoucGxheWJhY2tSYXRlO2Vsc2V7Y29uc3QgJD1qLnRpbWluZy5kaXJlY3Rpb247ai50aW1pbmcuZGlyZWN0aW9uPSQ9PT0icmV2ZXJzZSI/Im5vcm1hbCI6InJldmVyc2UiLGoucGxheSgpfXJldHVybiBqLmZpbmlzaGVkfSxhdHRyKGosJCl7cmV0dXJuIHRoaXMuZW5kKCksdHlwZW9mIGo9PSJzdHJpbmciJiYoaj17W2pdOiR9KSxPYmplY3QuZW50cmllcyhqKS5mb3JFYWNoKChbdyxKXSk9Pnt0eXBlb2YgSj09ImZ1bmN0aW9uIiYmKGpbd109SihMLmF0dHIodykpKX0pLHRoaXNbU109TC5hbmltYXRlKFtqXSx7ZHVyYXRpb246UCoxZTMsZGVsYXk6VCoxZTMsZmlsbDoiZm9yd2FyZHMiLGVhc2luZzpEfSksdGhpc1tTXS5maW5pc2hlZH19fXVwZGF0ZUNvbnRvdXJzKCl7fX1tKGIsIkF0dHIiLG8uZGVmYXVsdCksdi5kZWZhdWx0LnJlZ2lzdGVyTm9kZShiLCJub2RlIil9LGZ1bmN0aW9uKFIsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIGJ9KTt2YXIgaT10KDEpLG89dCgxMiksZz10KDcyKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3Qgdj1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGVEZWZhdWx0IiksYz1TeW1ib2wuZm9yKCJzcHJpdGVqc19kZWNsYXJlQWxpYXMiKSxmPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZSIpLGg9U3ltYm9sLmZvcigic3ByaXRlanNfZ2V0QXR0cmlidXRlIiksRT1TeW1ib2wuZm9yKCJzcHJpdGVqc19hdHRyaWJ1dGVzIiksbD1TeW1ib2wuZm9yKCJzcHJpdGVqc19jaGFuZ2VkQXR0cnMiKSxtPVN5bWJvbCgic3ViamVjdCIpLHA9U3ltYm9sKCJhdHRyIiksQz1TeW1ib2woImRlZmF1bHQiKSx4PVN5bWJvbCgiYWxpYXMiKTtmdW5jdGlvbiBkKEksW1AsRF0pe2xldCBMPWkubWF0MmQuZnJvbVZhbHVlcygxLDAsMCwxLDAsMCk7cmV0dXJuWy4uLkldLmZvckVhY2goKFtTLFRdKT0+e2lmKChQfHxEKSYmKEw9aS5tYXQyZC50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDApLEwsW1AsRF0pKSxTPT09Im1hdHJpeCIpTD1pLm1hdDJkLm11bHRpcGx5KEwsTCxUKTtlbHNlIGlmKFM9PT0ib2Zmc2V0VHJhbnNsYXRlIilMWzRdKz1UWzBdLExbNV0rPVRbMV07ZWxzZSBpZihTPT09Im9mZnNldFJvdGF0ZSIpTD1pLm1hdDJkLnJvdGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCksTCxUKTtlbHNlIGlmKFM9PT0ic2tldyIpe2NvbnN0W2osJF09VDtMPWkubWF0MmQubXVsdGlwbHkoTCxMLGkubWF0MmQuZnJvbVZhbHVlcygxLE1hdGgudGFuKCQpLE1hdGgudGFuKGopLDEsMCwwKSl9ZWxzZSBpLm1hdDJkW1NdKEwsTCxUKTsoUHx8RCkmJihMPWkubWF0MmQudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxMLFstUCwtRF0pKX0pLEx9Y29uc3QgeT1TeW1ib2woInRyYW5zZm9ybU1hdHJpeCIpLHI9U3ltYm9sKCJ0cmFuc2Zvcm1zIikscz1TeW1ib2woImNoYW5nZWRBdHRycyIpLG49U3ltYm9sKCJsYXN0Q2hhbmdlZEF0dHIiKSxhPVN5bWJvbCgib2Zmc2V0RmlndXJlIik7ZnVuY3Rpb24gTyhJLFAsRCl7Y29uc3QgTD1JW3BdW1BdO2lmKElbZl0oUCxELCExKXx8SVtuXSE9PVApe2NvbnN0IFQ9SVtyXTtULmhhcyhQKSYmVC5kZWxldGUoUCksRCYmKFA9PT0icm90YXRlIiYmKEQ9TWF0aC5QSSpELzE4MCksUD09PSJzY2FsZSImJihEPUQubWFwKGo9Pk1hdGguYWJzKGopPjFlLTU/ajoxL2o+MD8xZS01Oi0xZS01KSksVC5zZXQoUCxEKSksSVt5XT1udWxsLElbbV0ub25Qcm9wZXJ0eUNoYW5nZShQLEQsTCxJKX19ZnVuY3Rpb24gQShJKXtjb25zdCBQPUlbYV0sRD1JLm9mZnNldERpc3RhbmNlKlAuZ2V0VG90YWxMZW5ndGgoKSxMPVAuZ2V0UG9pbnRBdExlbmd0aChEKTtpZihMKXtjb25zdCBTPUlbcl07bGV0IFQ9SS5vZmZzZXRSb3RhdGU7VD09PSJhdXRvIj9UPUwuYW5nbGU6VD09PSJyZXZlcnNlIj9UPU1hdGguUEkrTC5hbmdsZTpUPU1hdGguUEkqVC8xODAsUy5zZXQoIm9mZnNldFJvdGF0ZSIsVCksUy5zZXQoIm9mZnNldFRyYW5zbGF0ZSIsW0wueCxMLnldKSxJW3ldPW51bGx9fWNsYXNzIGJ7c3RhdGljIHNldERlZmF1bHQoUCwuLi5EKXtyZXR1cm4gUFt2XSguLi5EKX1zdGF0aWMgZGVjbGFyZUFsaWFzKFAsLi4uRCl7cmV0dXJuIFBbY10oLi4uRCl9c3RhdGljIHNldEF0dHJpYnV0ZShQLC4uLkQpe3JldHVybiBQW2ZdKC4uLkQpfXN0YXRpYyBnZXRBdHRyaWJ1dGUoUCwuLi5EKXtyZXR1cm4gUFtoXSguLi5EKX1zdGF0aWMgZ2V0QXR0cmlidXRlcyhQKXtyZXR1cm4gUFtFXX1zdGF0aWMgZ2V0Q2hhbmdlZEF0dHJpYnV0ZXMoUCl7cmV0dXJuIFBbbF19Y29uc3RydWN0b3IoUCl7dGhpc1ttXT1QLHRoaXNbcF09e30sdGhpc1t5XT1pLm1hdDJkLmZyb21WYWx1ZXMoMSwwLDAsMSwwLDApLHRoaXNbcl09bmV3IE1hcCx0aGlzW0NdPXt9LHRoaXNbeF09W10sT2JqZWN0LmRlZmluZVByb3BlcnR5KFAsInRyYW5zZm9ybU1hdHJpeCIse2dldDooKT0+KHRoaXNbeV18fCh0aGlzW3ldPWQodGhpc1tyXSx0aGlzLnRyYW5zZm9ybU9yaWdpbikpLFsuLi50aGlzW3ldXSl9KSx0aGlzW3ZdKHtpZDoiIixuYW1lOiIiLGNsYXNzTmFtZToiIix4OjAseTowLHRyYW5zZm9ybU9yaWdpbjpbMCwwXSx0cmFuc2Zvcm06IiIsdHJhbnNsYXRlOlswLDBdLHJvdGF0ZTowLHNjYWxlOlsxLDFdLHNrZXc6WzAsMF0sb3BhY2l0eToxLHpJbmRleDowLG9mZnNldFBhdGg6dm9pZCAwLG9mZnNldERpc3RhbmNlOjAsb2Zmc2V0Um90YXRlOiJhdXRvIixwb2ludGVyRXZlbnRzOiJ2aXNpYmxlIixmaWx0ZXI6Im5vbmUiLGRpc3BsYXk6IiJ9KSx0aGlzW2NdKCJjbGFzcyIsInBvcyIpLHRoaXNbc109bmV3IFNldCx0aGlzW2FdPW5ldyBvLkZpZ3VyZTJEKHtzY2FsZTo1LHNpbXBsaWZ5OjB9KX1nZXRbbF0oKXtjb25zdCBQPXt9O3JldHVyblsuLi50aGlzW3NdXS5mb3JFYWNoKEQ9PntQW0RdPXRoaXNbcF1bRF19KSxQfWdldFtFXSgpe2NvbnN0IFA9T2JqZWN0LmFzc2lnbih7fSx0aGlzW3BdKTtmb3IobGV0IEQ9MDtEPHRoaXNbeF0ubGVuZ3RoO0QrKyl7Y29uc3QgTD10aGlzW3hdW0RdO1BbTF09dGhpc1tMXX1yZXR1cm4gUH1bdl0oUCl7T2JqZWN0LmFzc2lnbih0aGlzW0NdLFApLE9iamVjdC5hc3NpZ24odGhpc1twXSxQKX1bY10oLi4uUCl7dGhpc1t4XS5wdXNoKC4uLlApfVtmXShQLEQsTD0hMCl7Y29uc3QgUz10aGlzW3BdW1BdLFQ9dGhpc1ttXTtyZXR1cm4gRD09bnVsbCYmKEQ9dGhpc1tDXVtQXSksT2JqZWN0KGcuY29tcGFyZVZhbHVlKShTLEQpPyExOih0aGlzW3BdW1BdPUQsdGhpc1tzXS5oYXMoUCkmJnRoaXNbc10uZGVsZXRlKFApLHRoaXNbc10uYWRkKFApLHRoaXNbbl09UCxMJiZULm9uUHJvcGVydHlDaGFuZ2UoUCxELFMsdGhpcyksITApfVtoXShQKXtyZXR1cm4gdGhpc1twXVtQXX1zZXQgaWQoUCl7dGhpc1tmXSgiaWQiLFApfWdldCBpZCgpe3JldHVybiB0aGlzW2hdKCJpZCIpfXNldCBuYW1lKFApe3RoaXNbZl0oIm5hbWUiLFApfWdldCBuYW1lKCl7cmV0dXJuIHRoaXNbaF0oIm5hbWUiKX1zZXQgY2xhc3NOYW1lKFApe3RoaXNbZl0oImNsYXNzTmFtZSIsUCl9Z2V0IGNsYXNzTmFtZSgpe3JldHVybiB0aGlzW2hdKCJjbGFzc05hbWUiKX1zZXQgY2xhc3MoUCl7dGhpcy5jbGFzc05hbWU9UH1nZXQgY2xhc3MoKXtyZXR1cm4gdGhpcy5jbGFzc05hbWV9Z2V0IHgoKXtyZXR1cm4gdGhpc1toXSgieCIpfXNldCB4KFApe3RoaXNbZl0oIngiLE9iamVjdChnLnRvTnVtYmVyKShQKSl9Z2V0IHkoKXtyZXR1cm4gdGhpc1toXSgieSIpfXNldCB5KFApe3RoaXNbZl0oInkiLE9iamVjdChnLnRvTnVtYmVyKShQKSl9Z2V0IHBvcygpe3JldHVyblt0aGlzLngsdGhpcy55XX1zZXQgcG9zKFApe1A9T2JqZWN0KGcudG9BcnJheSkoUCksQXJyYXkuaXNBcnJheShQKXx8KFA9W1AsUF0pLHRoaXMueD1QWzBdLHRoaXMueT1QWzFdfWdldCB0cmFuc2Zvcm0oKXtyZXR1cm4gdGhpc1toXSgidHJhbnNmb3JtIil9c2V0IHRyYW5zZm9ybShQKXtsZXQgRD1udWxsO2lmKEFycmF5LmlzQXJyYXkoUCkmJihEPVAsUD1gbWF0cml4KCR7UC5tYXAoZy50b051bWJlcikuam9pbigpfSlgKSx0eXBlb2YgUD09InN0cmluZyIpUD1QLnJlcGxhY2UoL1xzKixccyovZywiLCIpO2Vsc2UgaWYoUCE9bnVsbCl0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIHRyYW5zZm9ybSB2YWx1ZS4iKTtjb25zdCBMPXRoaXNbcF0udHJhbnNmb3JtO2lmKHRoaXNbZl0oInRyYW5zZm9ybSIsUCwhMSkpe2NvbnN0IFM9dGhpc1tyXTtpZihTLmhhcygibWF0cml4IikmJlMuZGVsZXRlKCJtYXRyaXgiKSxEKVMuc2V0KCJtYXRyaXgiLEQpO2Vsc2UgaWYoUCl7Y29uc3QgVD1QLm1hdGNoKC8obWF0cml4fHRyYW5zbGF0ZXxyb3RhdGV8c2NhbGV8c2tldylcKFteKCldK1wpL2cpO2lmKFQpe2xldCBqPWkubWF0MmQuZnJvbVZhbHVlcygxLDAsMCwxLDAsMCk7Zm9yKGxldCAkPTA7JDxULmxlbmd0aDskKyspe2NvbnN0IEo9VFskXS5tYXRjaCgvXihtYXRyaXh8dHJhbnNsYXRlfHJvdGF0ZXxzY2FsZXxza2V3KVwoKFteKCldKylcKS8pO2lmKEope2xldFsscSxXXT1KO3E9PT0icm90YXRlIj9XPU1hdGguUEkqcGFyc2VGbG9hdChXKS8xODA6Vz1XLnRyaW0oKS5zcGxpdCgvW1xzLF0rLykubWFwKEs9Pk9iamVjdChnLnRvTnVtYmVyKShLKSkscT09PSJtYXRyaXgiP2o9aS5tYXQyZC5tdWx0aXBseShqLGosVyk6cT09PSJza2V3Ij9qPWkubWF0MmQubXVsdGlwbHkoaixqLGkubWF0MmQuZnJvbVZhbHVlcygxLE1hdGgudGFuKFdbMV0pLE1hdGgudGFuKFdbMF0pLDEsMCwwKSk6aS5tYXQyZFtxXShqLGosVyksUy5zZXQoIm1hdHJpeCIsail9fX1lbHNlIHRocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgdHJhbnNmb3JtIHZhbHVlLiIpfXRoaXNbeV09bnVsbCx0aGlzW21dLm9uUHJvcGVydHlDaGFuZ2UoInRyYW5zZm9ybSIsUCxMLHRoaXMpfX1nZXQgdHJhbnNmb3JtT3JpZ2luKCl7cmV0dXJuIHRoaXNbaF0oInRyYW5zZm9ybU9yaWdpbiIpfXNldCB0cmFuc2Zvcm1PcmlnaW4oUCl7UD1PYmplY3QoZy50b0FycmF5KShQLCEwKSxQIT1udWxsJiYhQXJyYXkuaXNBcnJheShQKSYmKFA9W1AsUF0pLHRoaXNbZl0oInRyYW5zZm9ybU9yaWdpbiIsUCkmJih0aGlzW3ldPW51bGwpfWdldCByb3RhdGUoKXtyZXR1cm4gdGhpc1toXSgicm90YXRlIil9c2V0IHJvdGF0ZShQKXtPKHRoaXMsInJvdGF0ZSIsUCl9Z2V0IHRyYW5zbGF0ZSgpe3JldHVybiB0aGlzW2hdKCJ0cmFuc2xhdGUiKX1zZXQgdHJhbnNsYXRlKFApe1A9T2JqZWN0KGcudG9BcnJheSkoUCwhMCksUCE9bnVsbCYmIUFycmF5LmlzQXJyYXkoUCkmJihQPVtQLFBdKSxPKHRoaXMsInRyYW5zbGF0ZSIsUCl9Z2V0IHNjYWxlKCl7cmV0dXJuIHRoaXNbaF0oInNjYWxlIil9c2V0IHNjYWxlKFApe1A9T2JqZWN0KGcudG9BcnJheSkoUCwhMCksUCE9bnVsbCYmIUFycmF5LmlzQXJyYXkoUCkmJihQPVtQLFBdKSxPKHRoaXMsInNjYWxlIixQKX1nZXQgc2tldygpe3JldHVybiB0aGlzW2hdKCJza2V3Iil9c2V0IHNrZXcoUCl7UD1PYmplY3QoZy50b0FycmF5KShQLCEwKSxQIT1udWxsJiYhQXJyYXkuaXNBcnJheShQKSYmKFA9W1AsUF0pLE8odGhpcywic2tldyIsUCl9Z2V0IG9wYWNpdHkoKXtyZXR1cm4gdGhpc1toXSgib3BhY2l0eSIpfXNldCBvcGFjaXR5KFApe1AhPW51bGwmJihQPU51bWJlcihQKSksdGhpc1tmXSgib3BhY2l0eSIsUCl9Z2V0IHpJbmRleCgpe3JldHVybiB0aGlzW2hdKCJ6SW5kZXgiKX1zZXQgekluZGV4KFApe1AhPW51bGwmJihQPU51bWJlcihQKSksdGhpc1tmXSgiekluZGV4IixQKX1nZXQgb2Zmc2V0UGF0aCgpe3JldHVybiB0aGlzW2hdKCJvZmZzZXRQYXRoIil9c2V0IG9mZnNldFBhdGgoUCl7dGhpc1tmXSgib2Zmc2V0UGF0aCIsUCkmJih0aGlzW2FdLmJlZ2luUGF0aCgpLFAhPW51bGwmJnRoaXNbYV0uYWRkUGF0aChQKSxBKHRoaXMpKX1nZXQgb2Zmc2V0RGlzdGFuY2UoKXtyZXR1cm4gdGhpc1toXSgib2Zmc2V0RGlzdGFuY2UiKX1zZXQgb2Zmc2V0RGlzdGFuY2UoUCl7dGhpc1tmXSgib2Zmc2V0RGlzdGFuY2UiLE9iamVjdChnLnRvTnVtYmVyKShQKSkmJkEodGhpcyl9Z2V0IG9mZnNldFJvdGF0ZSgpe3JldHVybiB0aGlzW2hdKCJvZmZzZXRSb3RhdGUiKX1zZXQgb2Zmc2V0Um90YXRlKFApe3RoaXNbZl0oIm9mZnNldFJvdGF0ZSIsUCksQSh0aGlzKX1nZXQgcG9pbnRlckV2ZW50cygpe3JldHVybiB0aGlzW2hdKCJwb2ludGVyRXZlbnRzIil9c2V0IHBvaW50ZXJFdmVudHMoUCl7aWYoUCE9bnVsbCYmUCE9PSJub25lIiYmUCE9PSJ2aXNpYmxlIiYmUCE9PSJ2aXNpYmxlRmlsbCImJlAhPT0idmlzaWJsZVN0cm9rZSImJlAhPT0iYWxsIil0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIHBvaW50ZXJFdmVudHMgdHlwZS4iKTt0aGlzW2ZdKCJwb2ludGVyRXZlbnRzIixQKX1nZXQgZmlsdGVyKCl7cmV0dXJuIHRoaXNbaF0oImZpbHRlciIpfXNldCBmaWx0ZXIoUCl7dGhpc1tmXSgiZmlsdGVyIixQKX1nZXQgZGlzcGxheSgpe3JldHVybiB0aGlzW2hdKCJkaXNwbGF5Iil9c2V0IGRpc3BsYXkoUCl7dGhpc1tmXSgiZGlzcGxheSIsUCl9c2V0IG9mZnNldChQKXt9fX0sZnVuY3Rpb24oUixlLHQpe3QucihlKSx0LmQoZSwic2l6ZVRvUGl4ZWwiLGZ1bmN0aW9uKCl7cmV0dXJuIGl9KSx0LmQoZSwidG9TdHJpbmciLGZ1bmN0aW9uKCl7cmV0dXJuIG99KSx0LmQoZSwidG9OdW1iZXIiLGZ1bmN0aW9uKCl7cmV0dXJuIGd9KSx0LmQoZSwidG9BcnJheSIsZnVuY3Rpb24oKXtyZXR1cm4gdn0pLHQuZChlLCJjb21wYXJlVmFsdWUiLGZ1bmN0aW9uKCl7cmV0dXJuIGN9KSx0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gaShmLGgpe2NvbnN0IEU9Zi50cmltKCkubWF0Y2goL14oW1xkLl0rKShweHxwdHxwY3xpbnxjbXxtbXxlbXxleHxyZW18cXx2d3x2aHx2bWF4fHZtaW4pJC8pO0U/Zj17c2l6ZTpwYXJzZUZsb2F0KEVbMV0pLHVuaXQ6RVsyXX06Zj17c2l6ZTpwYXJzZUZsb2F0KGYpLHVuaXQ6InB4In07bGV0e3NpemU6bCx1bml0Om19PWY7aWYobT09PSJwdCIpbC89Ljc1O2Vsc2UgaWYobT09PSJwYyIpbCo9MTY7ZWxzZSBpZihtPT09ImluIilsKj05NjtlbHNlIGlmKG09PT0iY20iKWwqPTk2LzIuNTQ7ZWxzZSBpZihtPT09Im1tIilsKj05Ni8yNS40O2Vsc2UgaWYobT09PSJlbSJ8fG09PT0icmVtInx8bT09PSJleCIpe2lmKCFoJiZ0eXBlb2YgZ2V0Q29tcHV0ZWRTdHlsZT09ImZ1bmN0aW9uIiYmdHlwZW9mIGRvY3VtZW50PCJ1Iil7Y29uc3QgcD1nZXRDb21wdXRlZFN0eWxlKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkuZm9udFNpemU7cD9oPWkocCwxNik6aD0xNn1sKj1oLG09PT0iZXgiJiYobC89Mil9ZWxzZSBpZihtPT09InEiKWwqPTk2LzI1LjQvNDtlbHNlIGlmKG09PT0idncifHxtPT09InZoIil7aWYodHlwZW9mIGRvY3VtZW50PCJ1Iil7Y29uc3QgcD1tPT09InZ3Ij93aW5kb3cuaW5uZXJXaWR0aHx8ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoOndpbmRvdy5pbm5lckhlaWdodHx8ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodDtsKj1wLzEwMH19ZWxzZSBpZigobT09PSJ2bWF4Inx8bT09PSJ2bWluIikmJnR5cGVvZiBkb2N1bWVudDwidSIpe2NvbnN0IHA9d2luZG93LmlubmVyV2lkdGh8fGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCxDPXdpbmRvdy5pbm5lckhlaWdodHx8ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodDttPT09InZtYXgiP2wqPU1hdGgubWF4KHAsQykvMTAwOmwqPU1hdGgubWluKHAsQykvMTAwfXJldHVybiBsfWZ1bmN0aW9uIG8oZil7cmV0dXJuIGY9PW51bGw/ZjpTdHJpbmcoZil9ZnVuY3Rpb24gZyhmKXtpZihmPT1udWxsKXJldHVybiBmO2lmKHR5cGVvZiBmPT0ic3RyaW5nIiYmKGY9aShmKSksIU51bWJlci5pc0Zpbml0ZShmKSl0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIHZhbHVlIik7cmV0dXJuIGZ9ZnVuY3Rpb24gdihmLGg9ITEpe3JldHVybiBmPT09IiI/bnVsbDoodHlwZW9mIGY9PSJzdHJpbmciJiYoZj1mLnNwbGl0KC9bXHMsXSsvZykpLEFycmF5LmlzQXJyYXkoZikmJihoJiYoZj1mLm1hcChnKSksZi5sZW5ndGg9PT0xKT9mWzBdOmYpfWZ1bmN0aW9uIGMoZixoKXtpZihBcnJheS5pc0FycmF5KGYpJiZBcnJheS5pc0FycmF5KGgpKXtpZihmLmxlbmd0aCE9PWgubGVuZ3RoKXJldHVybiExO2ZvcihsZXQgRT0wO0U8Zi5sZW5ndGg7RSsrKWlmKGZbRV0hPT1oW0VdKXJldHVybiExO3JldHVybiEwfXJldHVybiBmPT1udWxsJiZoPT1udWxsfHxmPT09aH19LGZ1bmN0aW9uKFIsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIG19KTt2YXIgaT10KDc0KSxvPXQoMzIpLGc9dC5uKG8pLHY9dCg2OCksYz10KDcyKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gZigpe3JldHVybiBmPU9iamVjdC5hc3NpZ258fGZ1bmN0aW9uKHApe2Zvcih2YXIgQz0xO0M8YXJndW1lbnRzLmxlbmd0aDtDKyspe3ZhciB4PWFyZ3VtZW50c1tDXTtmb3IodmFyIGQgaW4geClPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCxkKSYmKHBbZF09eFtkXSl9cmV0dXJuIHB9LGYuYXBwbHkodGhpcyxhcmd1bWVudHMpfWZ1bmN0aW9uIGgocCl7aWYodHlwZW9mIHA9PSJzdHJpbmciKXtpZihwPXAudHJpbSgpLC9eWzAtOS5dKyUkLy50ZXN0KHApKXJldHVybiBwYXJzZUZsb2F0KHApLzEwMDtpZigvXihbXGQuXSspKHB4fHB0fHBjfGlufGNtfG1tfGVtfGV4fHJlbXxxfHZ3fHZofHZtYXh8dm1pbikkLy50ZXN0KHApKXJldHVybiBPYmplY3QoYy5zaXplVG9QaXhlbCkocCl9cmV0dXJuIHB9ZnVuY3Rpb24gRShwLEMseCxkLHkpe3JldHVybiB0eXBlb2YgcD09InN0cmluZyImJihwPWcoKShwKSksdHlwZW9mIEM9PSJzdHJpbmciJiYoQz1nKCkoQykpLGkuRWZmZWN0cy5kZWZhdWx0KHAsQyx4LGQseSl9ZnVuY3Rpb24gbChwLEMseCxkLHkpe3JldHVybiBpLkVmZmVjdHMuZGVmYXVsdChwLEMseCxkLHkpfWkuRWZmZWN0cy5kZWZhdWx0PWZ1bmN0aW9uKHAsQyx4LGQseSl7cmV0dXJuIEFycmF5LmlzQXJyYXkocCkmJkFycmF5LmlzQXJyYXkoQyk/cC5tYXAoKHIscyk9PnIrKHgtZCkvKHktZCkqKENbc10tcikpOnR5cGVvZiBwPT0ibnVtYmVyIiYmdHlwZW9mIEM9PSJudW1iZXIiP3ArKHgtZCkvKHktZCkqKEMtcCk6eC1kPnkteD9DOnB9LGkuRWZmZWN0cy5maWxsQ29sb3I9RSxpLkVmZmVjdHMuc3Ryb2tlQ29sb3I9RSxpLkVmZmVjdHMuYmdjb2xvcj1FLGkuRWZmZWN0cy5ib3JkZXJDb2xvcj1FLGkuRWZmZWN0cy50ZXh0PWw7Y2xhc3MgbSBleHRlbmRzIGkuQW5pbWF0b3J7Y29uc3RydWN0b3IoQyx4LGQpe2NvbnN0IHk9Qy5hdHRyKCk7T2JqZWN0LmVudHJpZXMoeSkuZm9yRWFjaCgoW3Isc10pPT57eVtyXT1pLkVmZmVjdHNbcl0/czpoKHMpfSkseD14Lm1hcChyPT57bGV0IHM9Zih7fSxyKTtjb25zdCBuPXt9O3JldHVybiBPYmplY3QuZW50cmllcyhzKS5mb3JFYWNoKChbYSxPXSk9PntuW2FdPWkuRWZmZWN0c1thXT9POmgoTyl9KSxufSksc3VwZXIoeSx4LGQpLHRoaXMudGFyZ2V0PUMsdGhpcy5zZXR0ZXI9ZnVuY3Rpb24ocixzKXtzLmF0dHIocil9fWdldCBwbGF5U3RhdGUoKXtyZXR1cm4gdGhpcy50YXJnZXQucGFyZW50P3N1cGVyLnBsYXlTdGF0ZToiaWRsZSJ9Z2V0IGZpbmlzaGVkKCl7cmV0dXJuIHN1cGVyLmZpbmlzaGVkLnRoZW4oKCk9Pntjb25zdCBDPXRoaXM7cmV0dXJuIG5ldyBQcm9taXNlKHg9PntmdW5jdGlvbiBkKCl7Qy5zZXR0ZXIoQy5mcmFtZSxDLnRhcmdldCk7Y29uc3QgeT1DLnBsYXlTdGF0ZTt5PT09ImZpbmlzaGVkInx8eT09PSJpZGxlIj8oT2JqZWN0KHYuY2FuY2VsQW5pbWF0aW9uRnJhbWUpKEMucmVxdWVzdElkKSx4KCkpOk9iamVjdCh2LnJlcXVlc3RBbmltYXRpb25GcmFtZSkoZCl9ZCgpfSl9KX1maW5pc2goKXtzdXBlci5maW5pc2goKSxPYmplY3Qodi5jYW5jZWxBbmltYXRpb25GcmFtZSkodGhpcy5yZXF1ZXN0SWQpLHRoaXMuc2V0dGVyKHRoaXMuZnJhbWUsdGhpcy50YXJnZXQpfXBsYXkoKXtpZighdGhpcy50YXJnZXQucGFyZW50fHx0aGlzLnBsYXlTdGF0ZT09PSJydW5uaW5nIilyZXR1cm47c3VwZXIucGxheSgpLHRoaXMuc2V0dGVyKHRoaXMuZnJhbWUsdGhpcy50YXJnZXQpO2NvbnN0IEM9dGhpczt0aGlzLnJlYWR5LnRoZW4oKCk9PntDLnNldHRlcihDLmZyYW1lLEMudGFyZ2V0KSxDLnJlcXVlc3RJZD1PYmplY3Qodi5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpKGZ1bmN0aW9uIHgoKXtjb25zdCBkPUMudGFyZ2V0O2lmKHR5cGVvZiBkb2N1bWVudDwidSImJmRvY3VtZW50LmRvY3VtZW50RWxlbWVudCYmZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNvbnRhaW5zJiZkLmxheWVyJiZkLmxheWVyLmNhbnZhcyYmIWRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jb250YWlucyhkLmxheWVyLmNhbnZhcykpe0MuY2FuY2VsKCk7cmV0dXJufWNvbnN0IHk9Qy5wbGF5U3RhdGU7Qy5zZXR0ZXIoQy5mcmFtZSxDLnRhcmdldCkseSE9PSJpZGxlIiYmKHk9PT0icnVubmluZyI/Qy5yZXF1ZXN0SWQ9T2JqZWN0KHYucmVxdWVzdEFuaW1hdGlvbkZyYW1lKSh4KTooeT09PSJwYXVzZWQifHx5PT09InBlbmRpbmciJiZDLnRpbWVsaW5lLmN1cnJlbnRUaW1lPDApJiZDLnJlYWR5LnRoZW4oKCk9PntDLnNldHRlcihDLmZyYW1lLEMudGFyZ2V0KSxDLnJlcXVlc3RJZD1PYmplY3Qodi5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpKHgpfSkpfSl9KX1jYW5jZWwoQz0hMSl7T2JqZWN0KHYuY2FuY2VsQW5pbWF0aW9uRnJhbWUpKHRoaXMucmVxdWVzdElkKSxDPyh0aGlzLnNldHRlcih0aGlzLmZyYW1lLHRoaXMudGFyZ2V0KSxzdXBlci5jYW5jZWwoKSk6KHN1cGVyLmNhbmNlbCgpLHRoaXMuc2V0dGVyKHRoaXMuZnJhbWUsdGhpcy50YXJnZXQpKX19fSxmdW5jdGlvbihSLGUsdCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLGUuVGltZWxpbmU9ZS5FZmZlY3RzPWUuRWFzaW5ncz1lLkFuaW1hdG9yPXZvaWQgMDt2YXIgaT10KDc1KSxvPUUoaSksZz10KDE4Nyksdj1FKGcpLGM9dCgxODgpLGY9dCgxOTApLGg9RShmKTtmdW5jdGlvbiBFKGwpe3JldHVybiBsJiZsLl9fZXNNb2R1bGU/bDp7ZGVmYXVsdDpsfX1lLkFuaW1hdG9yPWguZGVmYXVsdCxlLkVhc2luZ3M9Yy5FYXNpbmdzLGUuRWZmZWN0cz12LmRlZmF1bHQsZS5UaW1lbGluZT1vLmRlZmF1bHR9LGZ1bmN0aW9uKFIsZSx0KXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSk7dmFyIGk9dCg3Niksbz1yKGkpLGc9dCgxMzMpLHY9cihnKSxjPXQoMTQxKSxmPXIoYyksaD10KDE2NCksRT1yKGgpLGw9dCgxNzApLG09cihsKSxwPXQoMTcxKSxDPXIocCkseD10KDE3NSksZD1yKHgpLHk9dCgxODYpO2Z1bmN0aW9uIHIoTCl7cmV0dXJuIEwmJkwuX19lc01vZHVsZT9MOntkZWZhdWx0Okx9fXZhciBzPSgwLHkuY3JlYXRlTm93VGltZSkoKSxuPXtvcmlnaW5UaW1lOjAscGxheWJhY2tSYXRlOjF9LGE9KDAsZC5kZWZhdWx0KSgidGltZU1hcmsiKSxPPSgwLGQuZGVmYXVsdCkoInBsYXliYWNrUmF0ZSIpLEE9KDAsZC5kZWZhdWx0KSgidGltZXJzIiksYj0oMCxkLmRlZmF1bHQpKCJvcmlnaW5UaW1lIiksST0oMCxkLmRlZmF1bHQpKCJzZXRUaW1lciIpLFA9KDAsZC5kZWZhdWx0KSgicGFyZW50IiksRD1mdW5jdGlvbigpe2Z1bmN0aW9uIEwoUyxUKXsoMCxtLmRlZmF1bHQpKHRoaXMsTCksUyBpbnN0YW5jZW9mIEwmJihUPVMsUz17fSksUz0oMCxFLmRlZmF1bHQpKHt9LG4sUyksVCYmKHRoaXNbUF09VCk7dmFyIGo9Uy5ub3d0aW1lfHxzO2lmKFQpT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImdsb2JhbFRpbWUiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gVC5jdXJyZW50VGltZX19KTtlbHNle3ZhciAkPWooKTtPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiZ2xvYmFsVGltZSIse2dldDpmdW5jdGlvbigpe3JldHVybiBqKCktJH19KX10aGlzW2FdPVt7Z2xvYmFsVGltZTp0aGlzLmdsb2JhbFRpbWUsbG9jYWxUaW1lOi1TLm9yaWdpblRpbWUsZW50cm9weTotUy5vcmlnaW5UaW1lLHBsYXliYWNrUmF0ZTpTLnBsYXliYWNrUmF0ZSxnbG9iYWxFbnRyb3B5OjB9XSx0aGlzW1BdJiYodGhpc1thXVswXS5nbG9iYWxFbnRyb3B5PXRoaXNbUF0uZW50cm9weSksdGhpc1tiXT1TLm9yaWdpblRpbWUsdGhpc1tPXT1TLnBsYXliYWNrUmF0ZSx0aGlzW0FdPW5ldyBmLmRlZmF1bHR9cmV0dXJuKDAsQy5kZWZhdWx0KShMLFt7a2V5OiJtYXJrVGltZSIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgVD1hcmd1bWVudHMubGVuZ3RoPjAmJmFyZ3VtZW50c1swXSE9PXZvaWQgMD9hcmd1bWVudHNbMF06e30saj1ULnRpbWUsJD1qPT09dm9pZCAwP3RoaXMuY3VycmVudFRpbWU6aix3PVQuZW50cm9weSxKPXc9PT12b2lkIDA/dGhpcy5lbnRyb3B5OncscT1ULnBsYXliYWNrUmF0ZSxXPXE9PT12b2lkIDA/dGhpcy5wbGF5YmFja1JhdGU6cSxLPXtnbG9iYWxUaW1lOnRoaXMuZ2xvYmFsVGltZSxsb2NhbFRpbWU6JCxlbnRyb3B5OkoscGxheWJhY2tSYXRlOlcsZ2xvYmFsRW50cm9weTp0aGlzLmdsb2JhbEVudHJvcHl9O3RoaXNbYV0ucHVzaChLKX19LHtrZXk6ImZvcmsiLHZhbHVlOmZ1bmN0aW9uKFQpe3JldHVybiBuZXcgTChULHRoaXMpfX0se2tleToic2Vla0dsb2JhbFRpbWUiLHZhbHVlOmZ1bmN0aW9uKFQpe3ZhciBqPXRoaXMuc2Vla1RpbWVNYXJrKFQpLCQ9dGhpc1thXVtqXSx3PSQuZW50cm9weSxKPSQucGxheWJhY2tSYXRlLHE9JC5nbG9iYWxUaW1lO3JldHVybiBxKyhULXcpL01hdGguYWJzKEopfX0se2tleToic2Vla0xvY2FsVGltZSIsdmFsdWU6ZnVuY3Rpb24oVCl7dmFyIGo9dGhpcy5zZWVrVGltZU1hcmsoVCksJD10aGlzW2FdW2pdLHc9JC5sb2NhbFRpbWUsSj0kLmVudHJvcHkscT0kLnBsYXliYWNrUmF0ZTtyZXR1cm4gcT4wP3crKFQtSik6dy0oVC1KKX19LHtrZXk6InNlZWtUaW1lTWFyayIsdmFsdWU6ZnVuY3Rpb24oVCl7dmFyIGo9dGhpc1thXSwkPTAsdz1qLmxlbmd0aC0xO2lmKFQ8PWpbJF0uZW50cm9weSlyZXR1cm4gJDtpZihUPj1qW3ddLmVudHJvcHkpcmV0dXJuIHc7Zm9yKHZhciBKPU1hdGguZmxvb3IoKCQrdykvMik7Sj4kJiZKPHc7KXtpZihUPT09altKXS5lbnRyb3B5KXJldHVybiBKO1Q8altKXS5lbnRyb3B5P3c9SjpUPmpbSl0uZW50cm9weSYmKCQ9SiksSj1NYXRoLmZsb29yKCgkK3cpLzIpfXJldHVybiAkfX0se2tleToidXBkYXRlVGltZXJzIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBUPXRoaXMsaj1bXS5jb25jYXQoKDAsdi5kZWZhdWx0KSh0aGlzW0FdKSk7ai5mb3JFYWNoKGZ1bmN0aW9uKCQpe3ZhciB3PSgwLG8uZGVmYXVsdCkoJCwyKSxKPXdbMF0scT13WzFdO1RbSV0ocS5oYW5kbGVyLHEudGltZSxKKX0pfX0se2tleToiY2xlYXJUaW1lb3V0Iix2YWx1ZTpmdW5jdGlvbihTKXtmdW5jdGlvbiBUKGope3JldHVybiBTLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1yZXR1cm4gVC50b1N0cmluZz1mdW5jdGlvbigpe3JldHVybiBTLnRvU3RyaW5nKCl9LFR9KGZ1bmN0aW9uKFMpe3ZhciBUPXRoaXNbQV0uZ2V0KFMpO1QmJlQudGltZXJJRCE9bnVsbCYmKHRoaXNbUF0/dGhpc1tQXS5jbGVhclRpbWVvdXQoVC50aW1lcklEKTpjbGVhclRpbWVvdXQoVC50aW1lcklEKSksdGhpc1tBXS5kZWxldGUoUyl9KX0se2tleToiY2xlYXJJbnRlcnZhbCIsdmFsdWU6ZnVuY3Rpb24oVCl7cmV0dXJuIHRoaXMuY2xlYXJUaW1lb3V0KFQpfX0se2tleToiY2xlYXIiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIFQ9dGhpcyxqPXRoaXNbQV07W10uY29uY2F0KCgwLHYuZGVmYXVsdCkoai5rZXlzKCkpKS5mb3JFYWNoKGZ1bmN0aW9uKCQpe1QuY2xlYXJUaW1lb3V0KCQpfSl9fSx7a2V5OiJzZXRUaW1lb3V0Iix2YWx1ZTpmdW5jdGlvbihUKXt2YXIgaj1hcmd1bWVudHMubGVuZ3RoPjEmJmFyZ3VtZW50c1sxXSE9PXZvaWQgMD9hcmd1bWVudHNbMV06e2RlbGF5OjB9O3JldHVybiB0aGlzW0ldKFQsail9fSx7a2V5OiJzZXRJbnRlcnZhbCIsdmFsdWU6ZnVuY3Rpb24oVCl7dmFyIGo9YXJndW1lbnRzLmxlbmd0aD4xJiZhcmd1bWVudHNbMV0hPT12b2lkIDA/YXJndW1lbnRzWzFdOntkZWxheTowfSwkPXRoaXMsdz10aGlzW0ldKGZ1bmN0aW9uIEooKXskW0ldKEosaix3KSxUKCl9LGopO3JldHVybiB3fX0se2tleTpJLHZhbHVlOmZ1bmN0aW9uKFQsail7dmFyICQ9dGhpcyx3PWFyZ3VtZW50cy5sZW5ndGg+MiYmYXJndW1lbnRzWzJdIT09dm9pZCAwP2FyZ3VtZW50c1syXTooMCxkLmRlZmF1bHQpKCJ0aW1lcklEIik7aj0oMCx5LmZvcm1hdERlbGF5KShqKTt2YXIgSj10aGlzW0FdLmdldCh3KSxxPXZvaWQgMCxXPW51bGwsSz12b2lkIDAsUT12b2lkIDA7Sj8odGhpcy5jbGVhclRpbWVvdXQodyksai5pc0VudHJvcHk/cT0oai5kZWxheS0odGhpcy5lbnRyb3B5LUouc3RhcnRFbnRyb3B5KSkvTWF0aC5hYnModGhpcy5wbGF5YmFja1JhdGUpOnE9KGouZGVsYXktKHRoaXMuY3VycmVudFRpbWUtSi5zdGFydFRpbWUpKS90aGlzLnBsYXliYWNrUmF0ZSxLPUouc3RhcnRUaW1lLFE9Si5zdGFydEVudHJvcHkpOihxPWouZGVsYXkvKGouaXNFbnRyb3B5P01hdGguYWJzKHRoaXMucGxheWJhY2tSYXRlKTp0aGlzLnBsYXliYWNrUmF0ZSksSz10aGlzLmN1cnJlbnRUaW1lLFE9dGhpcy5lbnRyb3B5KTt2YXIgdHQ9dGhpc1tQXSxfPXR0P3R0LnNldFRpbWVvdXQuYmluZCh0dCk6c2V0VGltZW91dCxzdD1qLmhlYWRpbmc7cmV0dXJuIXR0JiZzdD09PSExJiZxPDAmJihxPTEvMCksKGlzRmluaXRlKHEpfHx0dCkmJihxPU1hdGguY2VpbChxKSxfIT09c2V0VGltZW91dCYmKHE9e2RlbGF5OnEsaGVhZGluZzpzdH0pLFc9XyhmdW5jdGlvbigpeyRbQV0uZGVsZXRlKHcpLFQoKX0scSkpLHRoaXNbQV0uc2V0KHcse3RpbWVySUQ6VyxoYW5kbGVyOlQsdGltZTpqLHN0YXJ0VGltZTpLLHN0YXJ0RW50cm9weTpRfSksd319LHtrZXk6InBhcmVudCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXNbUF19fSx7a2V5OiJsYXN0VGltZU1hcmsiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzW2FdW3RoaXNbYV0ubGVuZ3RoLTFdfX0se2tleToiY3VycmVudFRpbWUiLGdldDpmdW5jdGlvbigpe3ZhciBUPXRoaXMubGFzdFRpbWVNYXJrLGo9VC5sb2NhbFRpbWUsJD1ULmdsb2JhbFRpbWU7cmV0dXJuIGorKHRoaXMuZ2xvYmFsVGltZS0kKSp0aGlzLnBsYXliYWNrUmF0ZX0sc2V0OmZ1bmN0aW9uKFQpe3ZhciBqPXRoaXMsJD10aGlzLmN1cnJlbnRUaW1lLHc9VCxKPXRoaXNbQV07dGhpcy5tYXJrVGltZSh7dGltZTpUfSksW10uY29uY2F0KCgwLHYuZGVmYXVsdCkoSikpLmZvckVhY2goZnVuY3Rpb24ocSl7dmFyIFc9KDAsby5kZWZhdWx0KShxLDIpLEs9V1swXSxRPVdbMV07aWYoSi5oYXMoSykpe3ZhciB0dD1RLnRpbWUsXz10dC5pc0VudHJvcHksc3Q9dHQuZGVsYXksaz10dC5oZWFkaW5nLGN0PVEuaGFuZGxlcixmdD1RLnN0YXJ0VGltZTtpZihfKXN0PT09MCYmKGN0KCksai5jbGVhclRpbWVvdXQoSykpO2Vsc2V7dmFyIFU9ZnQrc3Q7KHN0PT09MHx8ayE9PSExJiYody0kKSpzdDw9MHx8JDw9VSYmVTw9d3x8JD49VSYmVT49dykmJihjdCgpLGouY2xlYXJUaW1lb3V0KEspKX19fSksdGhpcy51cGRhdGVUaW1lcnMoKX19LHtrZXk6ImVudHJvcHkiLGdldDpmdW5jdGlvbigpe3ZhciBUPXRoaXMubGFzdFRpbWVNYXJrLGo9VC5lbnRyb3B5LCQ9VC5nbG9iYWxFbnRyb3B5O3JldHVybiBqK01hdGguYWJzKCh0aGlzLmdsb2JhbEVudHJvcHktJCkqdGhpcy5wbGF5YmFja1JhdGUpfSxzZXQ6ZnVuY3Rpb24oVCl7aWYodGhpcy5lbnRyb3B5PlQpe3ZhciBqPXRoaXMuc2Vla1RpbWVNYXJrKFQpO3RoaXNbYV0ubGVuZ3RoPWorMX10aGlzLm1hcmtUaW1lKHtlbnRyb3B5OlR9KSx0aGlzLnVwZGF0ZVRpbWVycygpfX0se2tleToiZ2xvYmFsRW50cm9weSIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXNbUF0/dGhpc1tQXS5lbnRyb3B5OnRoaXMuZ2xvYmFsVGltZX19LHtrZXk6InBsYXliYWNrUmF0ZSIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXNbT119LHNldDpmdW5jdGlvbihUKXtUIT09dGhpcy5wbGF5YmFja1JhdGUmJih0aGlzLm1hcmtUaW1lKHtwbGF5YmFja1JhdGU6VH0pLHRoaXNbT109VCx0aGlzLnVwZGF0ZVRpbWVycygpKX19LHtrZXk6InBhdXNlZCIsZ2V0OmZ1bmN0aW9uKCl7aWYodGhpcy5wbGF5YmFja1JhdGU9PT0wKXJldHVybiEwO2Zvcih2YXIgVD10aGlzLnBhcmVudDtUOyl7aWYoVC5wbGF5YmFja1JhdGU9PT0wKXJldHVybiEwO1Q9VC5wYXJlbnR9cmV0dXJuITF9fV0pLEx9KCk7ZS5kZWZhdWx0PUR9LGZ1bmN0aW9uKFIsZSx0KXtlLl9fZXNNb2R1bGU9ITA7dmFyIGk9dCg3Nyksbz1jKGkpLGc9dCgxMjkpLHY9YyhnKTtmdW5jdGlvbiBjKGYpe3JldHVybiBmJiZmLl9fZXNNb2R1bGU/Zjp7ZGVmYXVsdDpmfX1lLmRlZmF1bHQ9ZnVuY3Rpb24oKXtmdW5jdGlvbiBmKGgsRSl7dmFyIGw9W10sbT0hMCxwPSExLEM9dm9pZCAwO3RyeXtmb3IodmFyIHg9KDAsdi5kZWZhdWx0KShoKSxkOyEobT0oZD14Lm5leHQoKSkuZG9uZSkmJihsLnB1c2goZC52YWx1ZSksIShFJiZsLmxlbmd0aD09PUUpKTttPSEwKTt9Y2F0Y2goeSl7cD0hMCxDPXl9ZmluYWxseXt0cnl7IW0mJngucmV0dXJuJiZ4LnJldHVybigpfWZpbmFsbHl7aWYocCl0aHJvdyBDfX1yZXR1cm4gbH1yZXR1cm4gZnVuY3Rpb24oaCxFKXtpZihBcnJheS5pc0FycmF5KGgpKXJldHVybiBoO2lmKCgwLG8uZGVmYXVsdCkoT2JqZWN0KGgpKSlyZXR1cm4gZihoLEUpO3Rocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UiKX19KCl9LGZ1bmN0aW9uKFIsZSx0KXtSLmV4cG9ydHM9e2RlZmF1bHQ6dCg3OCksX19lc01vZHVsZTohMH19LGZ1bmN0aW9uKFIsZSx0KXt0KDc5KSx0KDEyNSksUi5leHBvcnRzPXQoMTI3KX0sZnVuY3Rpb24oUixlLHQpe3QoODApO2Zvcih2YXIgaT10KDkxKSxvPXQoOTUpLGc9dCg4Myksdj10KDEyMikoInRvU3RyaW5nVGFnIiksYz0iQ1NTUnVsZUxpc3QsQ1NTU3R5bGVEZWNsYXJhdGlvbixDU1NWYWx1ZUxpc3QsQ2xpZW50UmVjdExpc3QsRE9NUmVjdExpc3QsRE9NU3RyaW5nTGlzdCxET01Ub2tlbkxpc3QsRGF0YVRyYW5zZmVySXRlbUxpc3QsRmlsZUxpc3QsSFRNTEFsbENvbGxlY3Rpb24sSFRNTENvbGxlY3Rpb24sSFRNTEZvcm1FbGVtZW50LEhUTUxTZWxlY3RFbGVtZW50LE1lZGlhTGlzdCxNaW1lVHlwZUFycmF5LE5hbWVkTm9kZU1hcCxOb2RlTGlzdCxQYWludFJlcXVlc3RMaXN0LFBsdWdpbixQbHVnaW5BcnJheSxTVkdMZW5ndGhMaXN0LFNWR051bWJlckxpc3QsU1ZHUGF0aFNlZ0xpc3QsU1ZHUG9pbnRMaXN0LFNWR1N0cmluZ0xpc3QsU1ZHVHJhbnNmb3JtTGlzdCxTb3VyY2VCdWZmZXJMaXN0LFN0eWxlU2hlZXRMaXN0LFRleHRUcmFja0N1ZUxpc3QsVGV4dFRyYWNrTGlzdCxUb3VjaExpc3QiLnNwbGl0KCIsIiksZj0wO2Y8Yy5sZW5ndGg7ZisrKXt2YXIgaD1jW2ZdLEU9aVtoXSxsPUUmJkUucHJvdG90eXBlO2wmJiFsW3ZdJiZvKGwsdixoKSxnW2hdPWcuQXJyYXl9fSxmdW5jdGlvbihSLGUsdCl7dmFyIGk9dCg4MSksbz10KDgyKSxnPXQoODMpLHY9dCg4NCk7Ui5leHBvcnRzPXQoODgpKEFycmF5LCJBcnJheSIsZnVuY3Rpb24oYyxmKXt0aGlzLl90PXYoYyksdGhpcy5faT0wLHRoaXMuX2s9Zn0sZnVuY3Rpb24oKXt2YXIgYz10aGlzLl90LGY9dGhpcy5fayxoPXRoaXMuX2krKztyZXR1cm4hY3x8aD49Yy5sZW5ndGg/KHRoaXMuX3Q9dm9pZCAwLG8oMSkpOmY9PSJrZXlzIj9vKDAsaCk6Zj09InZhbHVlcyI/bygwLGNbaF0pOm8oMCxbaCxjW2hdXSl9LCJ2YWx1ZXMiKSxnLkFyZ3VtZW50cz1nLkFycmF5LGkoImtleXMiKSxpKCJ2YWx1ZXMiKSxpKCJlbnRyaWVzIil9LGZ1bmN0aW9uKFIsZSl7Ui5leHBvcnRzPWZ1bmN0aW9uKCl7fX0sZnVuY3Rpb24oUixlKXtSLmV4cG9ydHM9ZnVuY3Rpb24odCxpKXtyZXR1cm57dmFsdWU6aSxkb25lOiEhdH19fSxmdW5jdGlvbihSLGUpe1IuZXhwb3J0cz17fX0sZnVuY3Rpb24oUixlLHQpe3ZhciBpPXQoODUpLG89dCg4Nyk7Ui5leHBvcnRzPWZ1bmN0aW9uKGcpe3JldHVybiBpKG8oZykpfX0sZnVuY3Rpb24oUixlLHQpe3ZhciBpPXQoODYpO1IuZXhwb3J0cz1PYmplY3QoInoiKS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgwKT9PYmplY3Q6ZnVuY3Rpb24obyl7cmV0dXJuIGkobyk9PSJTdHJpbmciP28uc3BsaXQoIiIpOk9iamVjdChvKX19LGZ1bmN0aW9uKFIsZSl7dmFyIHQ9e30udG9TdHJpbmc7Ui5leHBvcnRzPWZ1bmN0aW9uKGkpe3JldHVybiB0LmNhbGwoaSkuc2xpY2UoOCwtMSl9fSxmdW5jdGlvbihSLGUpe1IuZXhwb3J0cz1mdW5jdGlvbih0KXtpZih0PT1udWxsKXRocm93IFR5cGVFcnJvcigiQ2FuJ3QgY2FsbCBtZXRob2Qgb24gICIrdCk7cmV0dXJuIHR9fSxmdW5jdGlvbihSLGUsdCl7dmFyIGk9dCg4OSksbz10KDkwKSxnPXQoMTA2KSx2PXQoOTUpLGM9dCg4MyksZj10KDEwNyksaD10KDEyMSksRT10KDEyMyksbD10KDEyMikoIml0ZXJhdG9yIiksbT0hKFtdLmtleXMmJiJuZXh0ImluW10ua2V5cygpKSxwPSJAQGl0ZXJhdG9yIixDPSJrZXlzIix4PSJ2YWx1ZXMiLGQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc307Ui5leHBvcnRzPWZ1bmN0aW9uKHkscixzLG4sYSxPLEEpe2YocyxyLG4pO3ZhciBiPWZ1bmN0aW9uKFcpe2lmKCFtJiZXIGluIEwpcmV0dXJuIExbV107c3dpdGNoKFcpe2Nhc2UgQzpyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gbmV3IHModGhpcyxXKX07Y2FzZSB4OnJldHVybiBmdW5jdGlvbigpe3JldHVybiBuZXcgcyh0aGlzLFcpfX1yZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gbmV3IHModGhpcyxXKX19LEk9cisiIEl0ZXJhdG9yIixQPWE9PXgsRD0hMSxMPXkucHJvdG90eXBlLFM9TFtsXXx8TFtwXXx8YSYmTFthXSxUPVN8fGIoYSksaj1hP1A/YigiZW50cmllcyIpOlQ6dm9pZCAwLCQ9cj09IkFycmF5IiYmTC5lbnRyaWVzfHxTLHcsSixxO2lmKCQmJihxPUUoJC5jYWxsKG5ldyB5KSkscSE9PU9iamVjdC5wcm90b3R5cGUmJnEubmV4dCYmKGgocSxJLCEwKSwhaSYmdHlwZW9mIHFbbF0hPSJmdW5jdGlvbiImJnYocSxsLGQpKSksUCYmUyYmUy5uYW1lIT09eCYmKEQ9ITAsVD1mdW5jdGlvbigpe3JldHVybiBTLmNhbGwodGhpcyl9KSwoIWl8fEEpJiYobXx8RHx8IUxbbF0pJiZ2KEwsbCxUKSxjW3JdPVQsY1tJXT1kLGEpaWYodz17dmFsdWVzOlA/VDpiKHgpLGtleXM6Tz9UOmIoQyksZW50cmllczpqfSxBKWZvcihKIGluIHcpSiBpbiBMfHxnKEwsSix3W0pdKTtlbHNlIG8oby5QK28uRioobXx8RCkscix3KTtyZXR1cm4gd319LGZ1bmN0aW9uKFIsZSl7Ui5leHBvcnRzPSEwfSxmdW5jdGlvbihSLGUsdCl7dmFyIGk9dCg5MSksbz10KDkyKSxnPXQoOTMpLHY9dCg5NSksYz10KDEwNSksZj0icHJvdG90eXBlIixoPWZ1bmN0aW9uKEUsbCxtKXt2YXIgcD1FJmguRixDPUUmaC5HLHg9RSZoLlMsZD1FJmguUCx5PUUmaC5CLHI9RSZoLlcscz1DP286b1tsXXx8KG9bbF09e30pLG49c1tmXSxhPUM/aTp4P2lbbF06KGlbbF18fHt9KVtmXSxPLEEsYjtDJiYobT1sKTtmb3IoTyBpbiBtKUE9IXAmJmEmJmFbT10hPT12b2lkIDAsIShBJiZjKHMsTykpJiYoYj1BP2FbT106bVtPXSxzW09dPUMmJnR5cGVvZiBhW09dIT0iZnVuY3Rpb24iP21bT106eSYmQT9nKGIsaSk6ciYmYVtPXT09Yj9mdW5jdGlvbihJKXt2YXIgUD1mdW5jdGlvbihELEwsUyl7aWYodGhpcyBpbnN0YW5jZW9mIEkpe3N3aXRjaChhcmd1bWVudHMubGVuZ3RoKXtjYXNlIDA6cmV0dXJuIG5ldyBJO2Nhc2UgMTpyZXR1cm4gbmV3IEkoRCk7Y2FzZSAyOnJldHVybiBuZXcgSShELEwpfXJldHVybiBuZXcgSShELEwsUyl9cmV0dXJuIEkuYXBwbHkodGhpcyxhcmd1bWVudHMpfTtyZXR1cm4gUFtmXT1JW2ZdLFB9KGIpOmQmJnR5cGVvZiBiPT0iZnVuY3Rpb24iP2coRnVuY3Rpb24uY2FsbCxiKTpiLGQmJigocy52aXJ0dWFsfHwocy52aXJ0dWFsPXt9KSlbT109YixFJmguUiYmbiYmIW5bT10mJnYobixPLGIpKSl9O2guRj0xLGguRz0yLGguUz00LGguUD04LGguQj0xNixoLlc9MzIsaC5VPTY0LGguUj0xMjgsUi5leHBvcnRzPWh9LGZ1bmN0aW9uKFIsZSl7dmFyIHQ9Ui5leHBvcnRzPXR5cGVvZiB3aW5kb3c8InUiJiZ3aW5kb3cuTWF0aD09TWF0aD93aW5kb3c6dHlwZW9mIHNlbGY8InUiJiZzZWxmLk1hdGg9PU1hdGg/c2VsZjpGdW5jdGlvbigicmV0dXJuIHRoaXMiKSgpO3R5cGVvZiBfX2c9PSJudW1iZXIiJiYoX19nPXQpfSxmdW5jdGlvbihSLGUpe3ZhciB0PVIuZXhwb3J0cz17dmVyc2lvbjoiMi42LjExIn07dHlwZW9mIF9fZT09Im51bWJlciImJihfX2U9dCl9LGZ1bmN0aW9uKFIsZSx0KXt2YXIgaT10KDk0KTtSLmV4cG9ydHM9ZnVuY3Rpb24obyxnLHYpe2lmKGkobyksZz09PXZvaWQgMClyZXR1cm4gbztzd2l0Y2godil7Y2FzZSAxOnJldHVybiBmdW5jdGlvbihjKXtyZXR1cm4gby5jYWxsKGcsYyl9O2Nhc2UgMjpyZXR1cm4gZnVuY3Rpb24oYyxmKXtyZXR1cm4gby5jYWxsKGcsYyxmKX07Y2FzZSAzOnJldHVybiBmdW5jdGlvbihjLGYsaCl7cmV0dXJuIG8uY2FsbChnLGMsZixoKX19cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIG8uYXBwbHkoZyxhcmd1bWVudHMpfX19LGZ1bmN0aW9uKFIsZSl7Ui5leHBvcnRzPWZ1bmN0aW9uKHQpe2lmKHR5cGVvZiB0IT0iZnVuY3Rpb24iKXRocm93IFR5cGVFcnJvcih0KyIgaXMgbm90IGEgZnVuY3Rpb24hIik7cmV0dXJuIHR9fSxmdW5jdGlvbihSLGUsdCl7dmFyIGk9dCg5Niksbz10KDEwNCk7Ui5leHBvcnRzPXQoMTAwKT9mdW5jdGlvbihnLHYsYyl7cmV0dXJuIGkuZihnLHYsbygxLGMpKX06ZnVuY3Rpb24oZyx2LGMpe3JldHVybiBnW3ZdPWMsZ319LGZ1bmN0aW9uKFIsZSx0KXt2YXIgaT10KDk3KSxvPXQoOTkpLGc9dCgxMDMpLHY9T2JqZWN0LmRlZmluZVByb3BlcnR5O2UuZj10KDEwMCk/T2JqZWN0LmRlZmluZVByb3BlcnR5OmZ1bmN0aW9uKGYsaCxFKXtpZihpKGYpLGg9ZyhoLCEwKSxpKEUpLG8pdHJ5e3JldHVybiB2KGYsaCxFKX1jYXRjaHt9aWYoImdldCJpbiBFfHwic2V0ImluIEUpdGhyb3cgVHlwZUVycm9yKCJBY2Nlc3NvcnMgbm90IHN1cHBvcnRlZCEiKTtyZXR1cm4idmFsdWUiaW4gRSYmKGZbaF09RS52YWx1ZSksZn19LGZ1bmN0aW9uKFIsZSx0KXt2YXIgaT10KDk4KTtSLmV4cG9ydHM9ZnVuY3Rpb24obyl7aWYoIWkobykpdGhyb3cgVHlwZUVycm9yKG8rIiBpcyBub3QgYW4gb2JqZWN0ISIpO3JldHVybiBvfX0sZnVuY3Rpb24oUixlKXtSLmV4cG9ydHM9ZnVuY3Rpb24odCl7cmV0dXJuIHR5cGVvZiB0PT0ib2JqZWN0Ij90IT09bnVsbDp0eXBlb2YgdD09ImZ1bmN0aW9uIn19LGZ1bmN0aW9uKFIsZSx0KXtSLmV4cG9ydHM9IXQoMTAwKSYmIXQoMTAxKShmdW5jdGlvbigpe3JldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkodCgxMDIpKCJkaXYiKSwiYSIse2dldDpmdW5jdGlvbigpe3JldHVybiA3fX0pLmEhPTd9KX0sZnVuY3Rpb24oUixlLHQpe1IuZXhwb3J0cz0hdCgxMDEpKGZ1bmN0aW9uKCl7cmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwiYSIse2dldDpmdW5jdGlvbigpe3JldHVybiA3fX0pLmEhPTd9KX0sZnVuY3Rpb24oUixlKXtSLmV4cG9ydHM9ZnVuY3Rpb24odCl7dHJ5e3JldHVybiEhdCgpfWNhdGNoe3JldHVybiEwfX19LGZ1bmN0aW9uKFIsZSx0KXt2YXIgaT10KDk4KSxvPXQoOTEpLmRvY3VtZW50LGc9aShvKSYmaShvLmNyZWF0ZUVsZW1lbnQpO1IuZXhwb3J0cz1mdW5jdGlvbih2KXtyZXR1cm4gZz9vLmNyZWF0ZUVsZW1lbnQodik6e319fSxmdW5jdGlvbihSLGUsdCl7dmFyIGk9dCg5OCk7Ui5leHBvcnRzPWZ1bmN0aW9uKG8sZyl7aWYoIWkobykpcmV0dXJuIG87dmFyIHYsYztpZihnJiZ0eXBlb2Yodj1vLnRvU3RyaW5nKT09ImZ1bmN0aW9uIiYmIWkoYz12LmNhbGwobykpfHx0eXBlb2Yodj1vLnZhbHVlT2YpPT0iZnVuY3Rpb24iJiYhaShjPXYuY2FsbChvKSl8fCFnJiZ0eXBlb2Yodj1vLnRvU3RyaW5nKT09ImZ1bmN0aW9uIiYmIWkoYz12LmNhbGwobykpKXJldHVybiBjO3Rocm93IFR5cGVFcnJvcigiQ2FuJ3QgY29udmVydCBvYmplY3QgdG8gcHJpbWl0aXZlIHZhbHVlIil9fSxmdW5jdGlvbihSLGUpe1IuZXhwb3J0cz1mdW5jdGlvbih0LGkpe3JldHVybntlbnVtZXJhYmxlOiEodCYxKSxjb25maWd1cmFibGU6ISh0JjIpLHdyaXRhYmxlOiEodCY0KSx2YWx1ZTppfX19LGZ1bmN0aW9uKFIsZSl7dmFyIHQ9e30uaGFzT3duUHJvcGVydHk7Ui5leHBvcnRzPWZ1bmN0aW9uKGksbyl7cmV0dXJuIHQuY2FsbChpLG8pfX0sZnVuY3Rpb24oUixlLHQpe1IuZXhwb3J0cz10KDk1KX0sZnVuY3Rpb24oUixlLHQpe3ZhciBpPXQoMTA4KSxvPXQoMTA0KSxnPXQoMTIxKSx2PXt9O3QoOTUpKHYsdCgxMjIpKCJpdGVyYXRvciIpLGZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9KSxSLmV4cG9ydHM9ZnVuY3Rpb24oYyxmLGgpe2MucHJvdG90eXBlPWkodix7bmV4dDpvKDEsaCl9KSxnKGMsZisiIEl0ZXJhdG9yIil9fSxmdW5jdGlvbihSLGUsdCl7dmFyIGk9dCg5Nyksbz10KDEwOSksZz10KDExOSksdj10KDExNikoIklFX1BST1RPIiksYz1mdW5jdGlvbigpe30sZj0icHJvdG90eXBlIixoPWZ1bmN0aW9uKCl7dmFyIEU9dCgxMDIpKCJpZnJhbWUiKSxsPWcubGVuZ3RoLG09IjwiLHA9Ij4iLEM7Zm9yKEUuc3R5bGUuZGlzcGxheT0ibm9uZSIsdCgxMjApLmFwcGVuZENoaWxkKEUpLEUuc3JjPSJqYXZhc2NyaXB0OiIsQz1FLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQsQy5vcGVuKCksQy53cml0ZShtKyJzY3JpcHQiK3ArImRvY3VtZW50LkY9T2JqZWN0IittKyIvc2NyaXB0IitwKSxDLmNsb3NlKCksaD1DLkY7bC0tOylkZWxldGUgaFtmXVtnW2xdXTtyZXR1cm4gaCgpfTtSLmV4cG9ydHM9T2JqZWN0LmNyZWF0ZXx8ZnVuY3Rpb24obCxtKXt2YXIgcDtyZXR1cm4gbCE9PW51bGw/KGNbZl09aShsKSxwPW5ldyBjLGNbZl09bnVsbCxwW3ZdPWwpOnA9aCgpLG09PT12b2lkIDA/cDpvKHAsbSl9fSxmdW5jdGlvbihSLGUsdCl7dmFyIGk9dCg5Niksbz10KDk3KSxnPXQoMTEwKTtSLmV4cG9ydHM9dCgxMDApP09iamVjdC5kZWZpbmVQcm9wZXJ0aWVzOmZ1bmN0aW9uKGMsZil7byhjKTtmb3IodmFyIGg9ZyhmKSxFPWgubGVuZ3RoLGw9MCxtO0U+bDspaS5mKGMsbT1oW2wrK10sZlttXSk7cmV0dXJuIGN9fSxmdW5jdGlvbihSLGUsdCl7dmFyIGk9dCgxMTEpLG89dCgxMTkpO1IuZXhwb3J0cz1PYmplY3Qua2V5c3x8ZnVuY3Rpb24odil7cmV0dXJuIGkodixvKX19LGZ1bmN0aW9uKFIsZSx0KXt2YXIgaT10KDEwNSksbz10KDg0KSxnPXQoMTEyKSghMSksdj10KDExNikoIklFX1BST1RPIik7Ui5leHBvcnRzPWZ1bmN0aW9uKGMsZil7dmFyIGg9byhjKSxFPTAsbD1bXSxtO2ZvcihtIGluIGgpbSE9diYmaShoLG0pJiZsLnB1c2gobSk7Zm9yKDtmLmxlbmd0aD5FOylpKGgsbT1mW0UrK10pJiYofmcobCxtKXx8bC5wdXNoKG0pKTtyZXR1cm4gbH19LGZ1bmN0aW9uKFIsZSx0KXt2YXIgaT10KDg0KSxvPXQoMTEzKSxnPXQoMTE1KTtSLmV4cG9ydHM9ZnVuY3Rpb24odil7cmV0dXJuIGZ1bmN0aW9uKGMsZixoKXt2YXIgRT1pKGMpLGw9byhFLmxlbmd0aCksbT1nKGgsbCkscDtpZih2JiZmIT1mKXtmb3IoO2w+bTspaWYocD1FW20rK10scCE9cClyZXR1cm4hMH1lbHNlIGZvcig7bD5tO20rKylpZigodnx8bSBpbiBFKSYmRVttXT09PWYpcmV0dXJuIHZ8fG18fDA7cmV0dXJuIXYmJi0xfX19LGZ1bmN0aW9uKFIsZSx0KXt2YXIgaT10KDExNCksbz1NYXRoLm1pbjtSLmV4cG9ydHM9ZnVuY3Rpb24oZyl7cmV0dXJuIGc+MD9vKGkoZyksOTAwNzE5OTI1NDc0MDk5MSk6MH19LGZ1bmN0aW9uKFIsZSl7dmFyIHQ9TWF0aC5jZWlsLGk9TWF0aC5mbG9vcjtSLmV4cG9ydHM9ZnVuY3Rpb24obyl7cmV0dXJuIGlzTmFOKG89K28pPzA6KG8+MD9pOnQpKG8pfX0sZnVuY3Rpb24oUixlLHQpe3ZhciBpPXQoMTE0KSxvPU1hdGgubWF4LGc9TWF0aC5taW47Ui5leHBvcnRzPWZ1bmN0aW9uKHYsYyl7cmV0dXJuIHY9aSh2KSx2PDA/byh2K2MsMCk6Zyh2LGMpfX0sZnVuY3Rpb24oUixlLHQpe3ZhciBpPXQoMTE3KSgia2V5cyIpLG89dCgxMTgpO1IuZXhwb3J0cz1mdW5jdGlvbihnKXtyZXR1cm4gaVtnXXx8KGlbZ109byhnKSl9fSxmdW5jdGlvbihSLGUsdCl7dmFyIGk9dCg5Miksbz10KDkxKSxnPSJfX2NvcmUtanNfc2hhcmVkX18iLHY9b1tnXXx8KG9bZ109e30pOyhSLmV4cG9ydHM9ZnVuY3Rpb24oYyxmKXtyZXR1cm4gdltjXXx8KHZbY109ZiE9PXZvaWQgMD9mOnt9KX0pKCJ2ZXJzaW9ucyIsW10pLnB1c2goe3ZlcnNpb246aS52ZXJzaW9uLG1vZGU6dCg4OSk/InB1cmUiOiJnbG9iYWwiLGNvcHlyaWdodDoiwqkgMjAxOSBEZW5pcyBQdXNoa2FyZXYgKHpsb2lyb2NrLnJ1KSJ9KX0sZnVuY3Rpb24oUixlKXt2YXIgdD0wLGk9TWF0aC5yYW5kb20oKTtSLmV4cG9ydHM9ZnVuY3Rpb24obyl7cmV0dXJuIlN5bWJvbCgiLmNvbmNhdChvPT09dm9pZCAwPyIiOm8sIilfIiwoKyt0K2kpLnRvU3RyaW5nKDM2KSl9fSxmdW5jdGlvbihSLGUpe1IuZXhwb3J0cz0iY29uc3RydWN0b3IsaGFzT3duUHJvcGVydHksaXNQcm90b3R5cGVPZixwcm9wZXJ0eUlzRW51bWVyYWJsZSx0b0xvY2FsZVN0cmluZyx0b1N0cmluZyx2YWx1ZU9mIi5zcGxpdCgiLCIpfSxmdW5jdGlvbihSLGUsdCl7dmFyIGk9dCg5MSkuZG9jdW1lbnQ7Ui5leHBvcnRzPWkmJmkuZG9jdW1lbnRFbGVtZW50fSxmdW5jdGlvbihSLGUsdCl7dmFyIGk9dCg5NikuZixvPXQoMTA1KSxnPXQoMTIyKSgidG9TdHJpbmdUYWciKTtSLmV4cG9ydHM9ZnVuY3Rpb24odixjLGYpe3YmJiFvKHY9Zj92OnYucHJvdG90eXBlLGcpJiZpKHYsZyx7Y29uZmlndXJhYmxlOiEwLHZhbHVlOmN9KX19LGZ1bmN0aW9uKFIsZSx0KXt2YXIgaT10KDExNykoIndrcyIpLG89dCgxMTgpLGc9dCg5MSkuU3ltYm9sLHY9dHlwZW9mIGc9PSJmdW5jdGlvbiIsYz1SLmV4cG9ydHM9ZnVuY3Rpb24oZil7cmV0dXJuIGlbZl18fChpW2ZdPXYmJmdbZl18fCh2P2c6bykoIlN5bWJvbC4iK2YpKX07Yy5zdG9yZT1pfSxmdW5jdGlvbihSLGUsdCl7dmFyIGk9dCgxMDUpLG89dCgxMjQpLGc9dCgxMTYpKCJJRV9QUk9UTyIpLHY9T2JqZWN0LnByb3RvdHlwZTtSLmV4cG9ydHM9T2JqZWN0LmdldFByb3RvdHlwZU9mfHxmdW5jdGlvbihjKXtyZXR1cm4gYz1vKGMpLGkoYyxnKT9jW2ddOnR5cGVvZiBjLmNvbnN0cnVjdG9yPT0iZnVuY3Rpb24iJiZjIGluc3RhbmNlb2YgYy5jb25zdHJ1Y3Rvcj9jLmNvbnN0cnVjdG9yLnByb3RvdHlwZTpjIGluc3RhbmNlb2YgT2JqZWN0P3Y6bnVsbH19LGZ1bmN0aW9uKFIsZSx0KXt2YXIgaT10KDg3KTtSLmV4cG9ydHM9ZnVuY3Rpb24obyl7cmV0dXJuIE9iamVjdChpKG8pKX19LGZ1bmN0aW9uKFIsZSx0KXt2YXIgaT10KDEyNikoITApO3QoODgpKFN0cmluZywiU3RyaW5nIixmdW5jdGlvbihvKXt0aGlzLl90PVN0cmluZyhvKSx0aGlzLl9pPTB9LGZ1bmN0aW9uKCl7dmFyIG89dGhpcy5fdCxnPXRoaXMuX2ksdjtyZXR1cm4gZz49by5sZW5ndGg/e3ZhbHVlOnZvaWQgMCxkb25lOiEwfToodj1pKG8sZyksdGhpcy5faSs9di5sZW5ndGgse3ZhbHVlOnYsZG9uZTohMX0pfSl9LGZ1bmN0aW9uKFIsZSx0KXt2YXIgaT10KDExNCksbz10KDg3KTtSLmV4cG9ydHM9ZnVuY3Rpb24oZyl7cmV0dXJuIGZ1bmN0aW9uKHYsYyl7dmFyIGY9U3RyaW5nKG8odikpLGg9aShjKSxFPWYubGVuZ3RoLGwsbTtyZXR1cm4gaDwwfHxoPj1FP2c/IiI6dm9pZCAwOihsPWYuY2hhckNvZGVBdChoKSxsPDU1Mjk2fHxsPjU2MzE5fHxoKzE9PT1FfHwobT1mLmNoYXJDb2RlQXQoaCsxKSk8NTYzMjB8fG0+NTczNDM/Zz9mLmNoYXJBdChoKTpsOmc/Zi5zbGljZShoLGgrMik6KGwtNTUyOTY8PDEwKSsobS01NjMyMCkrNjU1MzYpfX19LGZ1bmN0aW9uKFIsZSx0KXt2YXIgaT10KDEyOCksbz10KDEyMikoIml0ZXJhdG9yIiksZz10KDgzKTtSLmV4cG9ydHM9dCg5MikuaXNJdGVyYWJsZT1mdW5jdGlvbih2KXt2YXIgYz1PYmplY3Qodik7cmV0dXJuIGNbb10hPT12b2lkIDB8fCJAQGl0ZXJhdG9yImluIGN8fGcuaGFzT3duUHJvcGVydHkoaShjKSl9fSxmdW5jdGlvbihSLGUsdCl7dmFyIGk9dCg4Niksbz10KDEyMikoInRvU3RyaW5nVGFnIiksZz1pKGZ1bmN0aW9uKCl7cmV0dXJuIGFyZ3VtZW50c30oKSk9PSJBcmd1bWVudHMiLHY9ZnVuY3Rpb24oYyxmKXt0cnl7cmV0dXJuIGNbZl19Y2F0Y2h7fX07Ui5leHBvcnRzPWZ1bmN0aW9uKGMpe3ZhciBmLGgsRTtyZXR1cm4gYz09PXZvaWQgMD8iVW5kZWZpbmVkIjpjPT09bnVsbD8iTnVsbCI6dHlwZW9mKGg9dihmPU9iamVjdChjKSxvKSk9PSJzdHJpbmciP2g6Zz9pKGYpOihFPWkoZikpPT0iT2JqZWN0IiYmdHlwZW9mIGYuY2FsbGVlPT0iZnVuY3Rpb24iPyJBcmd1bWVudHMiOkV9fSxmdW5jdGlvbihSLGUsdCl7Ui5leHBvcnRzPXtkZWZhdWx0OnQoMTMwKSxfX2VzTW9kdWxlOiEwfX0sZnVuY3Rpb24oUixlLHQpe3QoNzkpLHQoMTI1KSxSLmV4cG9ydHM9dCgxMzEpfSxmdW5jdGlvbihSLGUsdCl7dmFyIGk9dCg5Nyksbz10KDEzMik7Ui5leHBvcnRzPXQoOTIpLmdldEl0ZXJhdG9yPWZ1bmN0aW9uKGcpe3ZhciB2PW8oZyk7aWYodHlwZW9mIHYhPSJmdW5jdGlvbiIpdGhyb3cgVHlwZUVycm9yKGcrIiBpcyBub3QgaXRlcmFibGUhIik7cmV0dXJuIGkodi5jYWxsKGcpKX19LGZ1bmN0aW9uKFIsZSx0KXt2YXIgaT10KDEyOCksbz10KDEyMikoIml0ZXJhdG9yIiksZz10KDgzKTtSLmV4cG9ydHM9dCg5MikuZ2V0SXRlcmF0b3JNZXRob2Q9ZnVuY3Rpb24odil7aWYodiE9bnVsbClyZXR1cm4gdltvXXx8dlsiQEBpdGVyYXRvciJdfHxnW2kodildfX0sZnVuY3Rpb24oUixlLHQpe2UuX19lc01vZHVsZT0hMDt2YXIgaT10KDEzNCksbz1nKGkpO2Z1bmN0aW9uIGcodil7cmV0dXJuIHYmJnYuX19lc01vZHVsZT92OntkZWZhdWx0OnZ9fWUuZGVmYXVsdD1mdW5jdGlvbih2KXtpZihBcnJheS5pc0FycmF5KHYpKXtmb3IodmFyIGM9MCxmPUFycmF5KHYubGVuZ3RoKTtjPHYubGVuZ3RoO2MrKylmW2NdPXZbY107cmV0dXJuIGZ9ZWxzZSByZXR1cm4oMCxvLmRlZmF1bHQpKHYpfX0sZnVuY3Rpb24oUixlLHQpe1IuZXhwb3J0cz17ZGVmYXVsdDp0KDEzNSksX19lc01vZHVsZTohMH19LGZ1bmN0aW9uKFIsZSx0KXt0KDEyNSksdCgxMzYpLFIuZXhwb3J0cz10KDkyKS5BcnJheS5mcm9tfSxmdW5jdGlvbihSLGUsdCl7dmFyIGk9dCg5Myksbz10KDkwKSxnPXQoMTI0KSx2PXQoMTM3KSxjPXQoMTM4KSxmPXQoMTEzKSxoPXQoMTM5KSxFPXQoMTMyKTtvKG8uUytvLkYqIXQoMTQwKShmdW5jdGlvbihsKXtBcnJheS5mcm9tKGwpfSksIkFycmF5Iix7ZnJvbTpmdW5jdGlvbihtKXt2YXIgcD1nKG0pLEM9dHlwZW9mIHRoaXM9PSJmdW5jdGlvbiI/dGhpczpBcnJheSx4PWFyZ3VtZW50cy5sZW5ndGgsZD14PjE/YXJndW1lbnRzWzFdOnZvaWQgMCx5PWQhPT12b2lkIDAscj0wLHM9RShwKSxuLGEsTyxBO2lmKHkmJihkPWkoZCx4PjI/YXJndW1lbnRzWzJdOnZvaWQgMCwyKSkscyE9bnVsbCYmIShDPT1BcnJheSYmYyhzKSkpZm9yKEE9cy5jYWxsKHApLGE9bmV3IEM7IShPPUEubmV4dCgpKS5kb25lO3IrKyloKGEscix5P3YoQSxkLFtPLnZhbHVlLHJdLCEwKTpPLnZhbHVlKTtlbHNlIGZvcihuPWYocC5sZW5ndGgpLGE9bmV3IEMobik7bj5yO3IrKyloKGEscix5P2QocFtyXSxyKTpwW3JdKTtyZXR1cm4gYS5sZW5ndGg9cixhfX0pfSxmdW5jdGlvbihSLGUsdCl7dmFyIGk9dCg5Nyk7Ui5leHBvcnRzPWZ1bmN0aW9uKG8sZyx2LGMpe3RyeXtyZXR1cm4gYz9nKGkodilbMF0sdlsxXSk6Zyh2KX1jYXRjaChoKXt2YXIgZj1vLnJldHVybjt0aHJvdyBmIT09dm9pZCAwJiZpKGYuY2FsbChvKSksaH19fSxmdW5jdGlvbihSLGUsdCl7dmFyIGk9dCg4Myksbz10KDEyMikoIml0ZXJhdG9yIiksZz1BcnJheS5wcm90b3R5cGU7Ui5leHBvcnRzPWZ1bmN0aW9uKHYpe3JldHVybiB2IT09dm9pZCAwJiYoaS5BcnJheT09PXZ8fGdbb109PT12KX19LGZ1bmN0aW9uKFIsZSx0KXt2YXIgaT10KDk2KSxvPXQoMTA0KTtSLmV4cG9ydHM9ZnVuY3Rpb24oZyx2LGMpe3YgaW4gZz9pLmYoZyx2LG8oMCxjKSk6Z1t2XT1jfX0sZnVuY3Rpb24oUixlLHQpe3ZhciBpPXQoMTIyKSgiaXRlcmF0b3IiKSxvPSExO3RyeXt2YXIgZz1bN11baV0oKTtnLnJldHVybj1mdW5jdGlvbigpe289ITB9LEFycmF5LmZyb20oZyxmdW5jdGlvbigpe3Rocm93IDJ9KX1jYXRjaHt9Ui5leHBvcnRzPWZ1bmN0aW9uKHYsYyl7aWYoIWMmJiFvKXJldHVybiExO3ZhciBmPSExO3RyeXt2YXIgaD1bN10sRT1oW2ldKCk7RS5uZXh0PWZ1bmN0aW9uKCl7cmV0dXJue2RvbmU6Zj0hMH19LGhbaV09ZnVuY3Rpb24oKXtyZXR1cm4gRX0sdihoKX1jYXRjaHt9cmV0dXJuIGZ9fSxmdW5jdGlvbihSLGUsdCl7Ui5leHBvcnRzPXtkZWZhdWx0OnQoMTQyKSxfX2VzTW9kdWxlOiEwfX0sZnVuY3Rpb24oUixlLHQpe3QoMTQzKSx0KDEyNSksdCg3OSksdCgxNDQpLHQoMTU3KSx0KDE2MCksdCgxNjIpLFIuZXhwb3J0cz10KDkyKS5NYXB9LGZ1bmN0aW9uKFIsZSl7fSxmdW5jdGlvbihSLGUsdCl7dmFyIGk9dCgxNDUpLG89dCgxNTEpLGc9Ik1hcCI7Ui5leHBvcnRzPXQoMTUyKShnLGZ1bmN0aW9uKHYpe3JldHVybiBmdW5jdGlvbigpe3JldHVybiB2KHRoaXMsYXJndW1lbnRzLmxlbmd0aD4wP2FyZ3VtZW50c1swXTp2b2lkIDApfX0se2dldDpmdW5jdGlvbihjKXt2YXIgZj1pLmdldEVudHJ5KG8odGhpcyxnKSxjKTtyZXR1cm4gZiYmZi52fSxzZXQ6ZnVuY3Rpb24oYyxmKXtyZXR1cm4gaS5kZWYobyh0aGlzLGcpLGM9PT0wPzA6YyxmKX19LGksITApfSxmdW5jdGlvbihSLGUsdCl7dmFyIGk9dCg5NikuZixvPXQoMTA4KSxnPXQoMTQ2KSx2PXQoOTMpLGM9dCgxNDcpLGY9dCgxNDgpLGg9dCg4OCksRT10KDgyKSxsPXQoMTQ5KSxtPXQoMTAwKSxwPXQoMTUwKS5mYXN0S2V5LEM9dCgxNTEpLHg9bT8iX3MiOiJzaXplIixkPWZ1bmN0aW9uKHkscil7dmFyIHM9cChyKSxuO2lmKHMhPT0iRiIpcmV0dXJuIHkuX2lbc107Zm9yKG49eS5fZjtuO249bi5uKWlmKG4uaz09cilyZXR1cm4gbn07Ui5leHBvcnRzPXtnZXRDb25zdHJ1Y3RvcjpmdW5jdGlvbih5LHIscyxuKXt2YXIgYT15KGZ1bmN0aW9uKE8sQSl7YyhPLGEsciwiX2kiKSxPLl90PXIsTy5faT1vKG51bGwpLE8uX2Y9dm9pZCAwLE8uX2w9dm9pZCAwLE9beF09MCxBIT1udWxsJiZmKEEscyxPW25dLE8pfSk7cmV0dXJuIGcoYS5wcm90b3R5cGUse2NsZWFyOmZ1bmN0aW9uKCl7Zm9yKHZhciBBPUModGhpcyxyKSxiPUEuX2ksST1BLl9mO0k7ST1JLm4pSS5yPSEwLEkucCYmKEkucD1JLnAubj12b2lkIDApLGRlbGV0ZSBiW0kuaV07QS5fZj1BLl9sPXZvaWQgMCxBW3hdPTB9LGRlbGV0ZTpmdW5jdGlvbihPKXt2YXIgQT1DKHRoaXMsciksYj1kKEEsTyk7aWYoYil7dmFyIEk9Yi5uLFA9Yi5wO2RlbGV0ZSBBLl9pW2IuaV0sYi5yPSEwLFAmJihQLm49SSksSSYmKEkucD1QKSxBLl9mPT1iJiYoQS5fZj1JKSxBLl9sPT1iJiYoQS5fbD1QKSxBW3hdLS19cmV0dXJuISFifSxmb3JFYWNoOmZ1bmN0aW9uKEEpe0ModGhpcyxyKTtmb3IodmFyIGI9dihBLGFyZ3VtZW50cy5sZW5ndGg+MT9hcmd1bWVudHNbMV06dm9pZCAwLDMpLEk7ST1JP0kubjp0aGlzLl9mOylmb3IoYihJLnYsSS5rLHRoaXMpO0kmJkkucjspST1JLnB9LGhhczpmdW5jdGlvbihBKXtyZXR1cm4hIWQoQyh0aGlzLHIpLEEpfX0pLG0mJmkoYS5wcm90b3R5cGUsInNpemUiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gQyh0aGlzLHIpW3hdfX0pLGF9LGRlZjpmdW5jdGlvbih5LHIscyl7dmFyIG49ZCh5LHIpLGEsTztyZXR1cm4gbj9uLnY9czooeS5fbD1uPXtpOk89cChyLCEwKSxrOnIsdjpzLHA6YT15Ll9sLG46dm9pZCAwLHI6ITF9LHkuX2Z8fCh5Ll9mPW4pLGEmJihhLm49bikseVt4XSsrLE8hPT0iRiImJih5Ll9pW09dPW4pKSx5fSxnZXRFbnRyeTpkLHNldFN0cm9uZzpmdW5jdGlvbih5LHIscyl7aCh5LHIsZnVuY3Rpb24obixhKXt0aGlzLl90PUMobixyKSx0aGlzLl9rPWEsdGhpcy5fbD12b2lkIDB9LGZ1bmN0aW9uKCl7Zm9yKHZhciBuPXRoaXMsYT1uLl9rLE89bi5fbDtPJiZPLnI7KU89Ty5wO3JldHVybiFuLl90fHwhKG4uX2w9Tz1PP08ubjpuLl90Ll9mKT8obi5fdD12b2lkIDAsRSgxKSk6YT09ImtleXMiP0UoMCxPLmspOmE9PSJ2YWx1ZXMiP0UoMCxPLnYpOkUoMCxbTy5rLE8udl0pfSxzPyJlbnRyaWVzIjoidmFsdWVzIiwhcywhMCksbChyKX19fSxmdW5jdGlvbihSLGUsdCl7dmFyIGk9dCg5NSk7Ui5leHBvcnRzPWZ1bmN0aW9uKG8sZyx2KXtmb3IodmFyIGMgaW4gZyl2JiZvW2NdP29bY109Z1tjXTppKG8sYyxnW2NdKTtyZXR1cm4gb319LGZ1bmN0aW9uKFIsZSl7Ui5leHBvcnRzPWZ1bmN0aW9uKHQsaSxvLGcpe2lmKCEodCBpbnN0YW5jZW9mIGkpfHxnIT09dm9pZCAwJiZnIGluIHQpdGhyb3cgVHlwZUVycm9yKG8rIjogaW5jb3JyZWN0IGludm9jYXRpb24hIik7cmV0dXJuIHR9fSxmdW5jdGlvbihSLGwsdCl7dmFyIGk9dCg5Myksbz10KDEzNyksZz10KDEzOCksdj10KDk3KSxjPXQoMTEzKSxmPXQoMTMyKSxoPXt9LEU9e30sbD1SLmV4cG9ydHM9ZnVuY3Rpb24obSxwLEMseCxkKXt2YXIgeT1kP2Z1bmN0aW9uKCl7cmV0dXJuIG19OmYobSkscj1pKEMseCxwPzI6MSkscz0wLG4sYSxPLEE7aWYodHlwZW9mIHkhPSJmdW5jdGlvbiIpdGhyb3cgVHlwZUVycm9yKG0rIiBpcyBub3QgaXRlcmFibGUhIik7aWYoZyh5KSl7Zm9yKG49YyhtLmxlbmd0aCk7bj5zO3MrKylpZihBPXA/cih2KGE9bVtzXSlbMF0sYVsxXSk6cihtW3NdKSxBPT09aHx8QT09PUUpcmV0dXJuIEF9ZWxzZSBmb3IoTz15LmNhbGwobSk7IShhPU8ubmV4dCgpKS5kb25lOylpZihBPW8oTyxyLGEudmFsdWUscCksQT09PWh8fEE9PT1FKXJldHVybiBBfTtsLkJSRUFLPWgsbC5SRVRVUk49RX0sZnVuY3Rpb24oUixlLHQpe3ZhciBpPXQoOTEpLG89dCg5MiksZz10KDk2KSx2PXQoMTAwKSxjPXQoMTIyKSgic3BlY2llcyIpO1IuZXhwb3J0cz1mdW5jdGlvbihmKXt2YXIgaD10eXBlb2Ygb1tmXT09ImZ1bmN0aW9uIj9vW2ZdOmlbZl07diYmaCYmIWhbY10mJmcuZihoLGMse2NvbmZpZ3VyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc319KX19LGZ1bmN0aW9uKFIsZSx0KXt2YXIgaT10KDExOCkoIm1ldGEiKSxvPXQoOTgpLGc9dCgxMDUpLHY9dCg5NikuZixjPTAsZj1PYmplY3QuaXNFeHRlbnNpYmxlfHxmdW5jdGlvbigpe3JldHVybiEwfSxoPSF0KDEwMSkoZnVuY3Rpb24oKXtyZXR1cm4gZihPYmplY3QucHJldmVudEV4dGVuc2lvbnMoe30pKX0pLEU9ZnVuY3Rpb24oeCl7dih4LGkse3ZhbHVlOntpOiJPIisgKytjLHc6e319fSl9LGw9ZnVuY3Rpb24oeCxkKXtpZighbyh4KSlyZXR1cm4gdHlwZW9mIHg9PSJzeW1ib2wiP3g6KHR5cGVvZiB4PT0ic3RyaW5nIj8iUyI6IlAiKSt4O2lmKCFnKHgsaSkpe2lmKCFmKHgpKXJldHVybiJGIjtpZighZClyZXR1cm4iRSI7RSh4KX1yZXR1cm4geFtpXS5pfSxtPWZ1bmN0aW9uKHgsZCl7aWYoIWcoeCxpKSl7aWYoIWYoeCkpcmV0dXJuITA7aWYoIWQpcmV0dXJuITE7RSh4KX1yZXR1cm4geFtpXS53fSxwPWZ1bmN0aW9uKHgpe3JldHVybiBoJiZDLk5FRUQmJmYoeCkmJiFnKHgsaSkmJkUoeCkseH0sQz1SLmV4cG9ydHM9e0tFWTppLE5FRUQ6ITEsZmFzdEtleTpsLGdldFdlYWs6bSxvbkZyZWV6ZTpwfX0sZnVuY3Rpb24oUixlLHQpe3ZhciBpPXQoOTgpO1IuZXhwb3J0cz1mdW5jdGlvbihvLGcpe2lmKCFpKG8pfHxvLl90IT09Zyl0aHJvdyBUeXBlRXJyb3IoIkluY29tcGF0aWJsZSByZWNlaXZlciwgIitnKyIgcmVxdWlyZWQhIik7cmV0dXJuIG99fSxmdW5jdGlvbihSLGUsdCl7dmFyIGk9dCg5MSksbz10KDkwKSxnPXQoMTUwKSx2PXQoMTAxKSxjPXQoOTUpLGY9dCgxNDYpLGg9dCgxNDgpLEU9dCgxNDcpLGw9dCg5OCksbT10KDEyMSkscD10KDk2KS5mLEM9dCgxNTMpKDApLHg9dCgxMDApO1IuZXhwb3J0cz1mdW5jdGlvbihkLHkscixzLG4sYSl7dmFyIE89aVtkXSxBPU8sYj1uPyJzZXQiOiJhZGQiLEk9QSYmQS5wcm90b3R5cGUsUD17fTtyZXR1cm4heHx8dHlwZW9mIEEhPSJmdW5jdGlvbiJ8fCEoYXx8SS5mb3JFYWNoJiYhdihmdW5jdGlvbigpe25ldyBBKCkuZW50cmllcygpLm5leHQoKX0pKT8oQT1zLmdldENvbnN0cnVjdG9yKHksZCxuLGIpLGYoQS5wcm90b3R5cGUsciksZy5ORUVEPSEwKTooQT15KGZ1bmN0aW9uKEQsTCl7RShELEEsZCwiX2MiKSxELl9jPW5ldyBPLEwhPW51bGwmJmgoTCxuLERbYl0sRCl9KSxDKCJhZGQsY2xlYXIsZGVsZXRlLGZvckVhY2gsZ2V0LGhhcyxzZXQsa2V5cyx2YWx1ZXMsZW50cmllcyx0b0pTT04iLnNwbGl0KCIsIiksZnVuY3Rpb24oRCl7dmFyIEw9RD09ImFkZCJ8fEQ9PSJzZXQiO0QgaW4gSSYmIShhJiZEPT0iY2xlYXIiKSYmYyhBLnByb3RvdHlwZSxELGZ1bmN0aW9uKFMsVCl7aWYoRSh0aGlzLEEsRCksIUwmJmEmJiFsKFMpKXJldHVybiBEPT0iZ2V0Ij92b2lkIDA6ITE7dmFyIGo9dGhpcy5fY1tEXShTPT09MD8wOlMsVCk7cmV0dXJuIEw/dGhpczpqfSl9KSxhfHxwKEEucHJvdG90eXBlLCJzaXplIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2Muc2l6ZX19KSksbShBLGQpLFBbZF09QSxvKG8uRytvLlcrby5GLFApLGF8fHMuc2V0U3Ryb25nKEEsZCxuKSxBfX0sZnVuY3Rpb24oUixlLHQpe3ZhciBpPXQoOTMpLG89dCg4NSksZz10KDEyNCksdj10KDExMyksYz10KDE1NCk7Ui5leHBvcnRzPWZ1bmN0aW9uKGYsaCl7dmFyIEU9Zj09MSxsPWY9PTIsbT1mPT0zLHA9Zj09NCxDPWY9PTYseD1mPT01fHxDLGQ9aHx8YztyZXR1cm4gZnVuY3Rpb24oeSxyLHMpe2Zvcih2YXIgbj1nKHkpLGE9byhuKSxPPWkocixzLDMpLEE9dihhLmxlbmd0aCksYj0wLEk9RT9kKHksQSk6bD9kKHksMCk6dm9pZCAwLFAsRDtBPmI7YisrKWlmKCh4fHxiIGluIGEpJiYoUD1hW2JdLEQ9TyhQLGIsbiksZikpe2lmKEUpSVtiXT1EO2Vsc2UgaWYoRClzd2l0Y2goZil7Y2FzZSAzOnJldHVybiEwO2Nhc2UgNTpyZXR1cm4gUDtjYXNlIDY6cmV0dXJuIGI7Y2FzZSAyOkkucHVzaChQKX1lbHNlIGlmKHApcmV0dXJuITF9cmV0dXJuIEM/LTE6bXx8cD9wOkl9fX0sZnVuY3Rpb24oUixlLHQpe3ZhciBpPXQoMTU1KTtSLmV4cG9ydHM9ZnVuY3Rpb24obyxnKXtyZXR1cm4gbmV3KGkobykpKGcpfX0sZnVuY3Rpb24oUixlLHQpe3ZhciBpPXQoOTgpLG89dCgxNTYpLGc9dCgxMjIpKCJzcGVjaWVzIik7Ui5leHBvcnRzPWZ1bmN0aW9uKHYpe3ZhciBjO3JldHVybiBvKHYpJiYoYz12LmNvbnN0cnVjdG9yLHR5cGVvZiBjPT0iZnVuY3Rpb24iJiYoYz09PUFycmF5fHxvKGMucHJvdG90eXBlKSkmJihjPXZvaWQgMCksaShjKSYmKGM9Y1tnXSxjPT09bnVsbCYmKGM9dm9pZCAwKSkpLGM9PT12b2lkIDA/QXJyYXk6Y319LGZ1bmN0aW9uKFIsZSx0KXt2YXIgaT10KDg2KTtSLmV4cG9ydHM9QXJyYXkuaXNBcnJheXx8ZnVuY3Rpb24oZyl7cmV0dXJuIGkoZyk9PSJBcnJheSJ9fSxmdW5jdGlvbihSLGUsdCl7dmFyIGk9dCg5MCk7aShpLlAraS5SLCJNYXAiLHt0b0pTT046dCgxNTgpKCJNYXAiKX0pfSxmdW5jdGlvbihSLGUsdCl7dmFyIGk9dCgxMjgpLG89dCgxNTkpO1IuZXhwb3J0cz1mdW5jdGlvbihnKXtyZXR1cm4gZnVuY3Rpb24oKXtpZihpKHRoaXMpIT1nKXRocm93IFR5cGVFcnJvcihnKyIjdG9KU09OIGlzbid0IGdlbmVyaWMiKTtyZXR1cm4gbyh0aGlzKX19fSxmdW5jdGlvbihSLGUsdCl7dmFyIGk9dCgxNDgpO1IuZXhwb3J0cz1mdW5jdGlvbihvLGcpe3ZhciB2PVtdO3JldHVybiBpKG8sITEsdi5wdXNoLHYsZyksdn19LGZ1bmN0aW9uKFIsZSx0KXt0KDE2MSkoIk1hcCIpfSxmdW5jdGlvbihSLGUsdCl7dmFyIGk9dCg5MCk7Ui5leHBvcnRzPWZ1bmN0aW9uKG8pe2koaS5TLG8se29mOmZ1bmN0aW9uKCl7Zm9yKHZhciB2PWFyZ3VtZW50cy5sZW5ndGgsYz1uZXcgQXJyYXkodik7di0tOyljW3ZdPWFyZ3VtZW50c1t2XTtyZXR1cm4gbmV3IHRoaXMoYyl9fSl9fSxmdW5jdGlvbihSLGUsdCl7dCgxNjMpKCJNYXAiKX0sZnVuY3Rpb24oUixlLHQpe3ZhciBpPXQoOTApLG89dCg5NCksZz10KDkzKSx2PXQoMTQ4KTtSLmV4cG9ydHM9ZnVuY3Rpb24oYyl7aShpLlMsYyx7ZnJvbTpmdW5jdGlvbihoKXt2YXIgRT1hcmd1bWVudHNbMV0sbCxtLHAsQztyZXR1cm4gbyh0aGlzKSxsPUUhPT12b2lkIDAsbCYmbyhFKSxoPT1udWxsP25ldyB0aGlzOihtPVtdLGw/KHA9MCxDPWcoRSxhcmd1bWVudHNbMl0sMiksdihoLCExLGZ1bmN0aW9uKHgpe20ucHVzaChDKHgscCsrKSl9KSk6dihoLCExLG0ucHVzaCxtKSxuZXcgdGhpcyhtKSl9fSl9fSxmdW5jdGlvbihSLGUsdCl7Ui5leHBvcnRzPXtkZWZhdWx0OnQoMTY1KSxfX2VzTW9kdWxlOiEwfX0sZnVuY3Rpb24oUixlLHQpe3QoMTY2KSxSLmV4cG9ydHM9dCg5MikuT2JqZWN0LmFzc2lnbn0sZnVuY3Rpb24oUixlLHQpe3ZhciBpPXQoOTApO2koaS5TK2kuRiwiT2JqZWN0Iix7YXNzaWduOnQoMTY3KX0pfSxmdW5jdGlvbihSLGUsdCl7dmFyIGk9dCgxMDApLG89dCgxMTApLGc9dCgxNjgpLHY9dCgxNjkpLGM9dCgxMjQpLGY9dCg4NSksaD1PYmplY3QuYXNzaWduO1IuZXhwb3J0cz0haHx8dCgxMDEpKGZ1bmN0aW9uKCl7dmFyIEU9e30sbD17fSxtPVN5bWJvbCgpLHA9ImFiY2RlZmdoaWprbG1ub3BxcnN0IjtyZXR1cm4gRVttXT03LHAuc3BsaXQoIiIpLmZvckVhY2goZnVuY3Rpb24oQyl7bFtDXT1DfSksaCh7fSxFKVttXSE9N3x8T2JqZWN0LmtleXMoaCh7fSxsKSkuam9pbigiIikhPXB9KT9mdW5jdGlvbihsLG0pe2Zvcih2YXIgcD1jKGwpLEM9YXJndW1lbnRzLmxlbmd0aCx4PTEsZD1nLmYseT12LmY7Qz54Oylmb3IodmFyIHI9Zihhcmd1bWVudHNbeCsrXSkscz1kP28ocikuY29uY2F0KGQocikpOm8ociksbj1zLmxlbmd0aCxhPTAsTztuPmE7KU89c1thKytdLCghaXx8eS5jYWxsKHIsTykpJiYocFtPXT1yW09dKTtyZXR1cm4gcH06aH0sZnVuY3Rpb24oUixlKXtlLmY9T2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9sc30sZnVuY3Rpb24oUixlKXtlLmY9e30ucHJvcGVydHlJc0VudW1lcmFibGV9LGZ1bmN0aW9uKFIsZSx0KXtlLl9fZXNNb2R1bGU9ITAsZS5kZWZhdWx0PWZ1bmN0aW9uKGksbyl7aWYoIShpIGluc3RhbmNlb2YgbykpdGhyb3cgbmV3IFR5cGVFcnJvcigiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uIil9fSxmdW5jdGlvbihSLGUsdCl7ZS5fX2VzTW9kdWxlPSEwO3ZhciBpPXQoMTcyKSxvPWcoaSk7ZnVuY3Rpb24gZyh2KXtyZXR1cm4gdiYmdi5fX2VzTW9kdWxlP3Y6e2RlZmF1bHQ6dn19ZS5kZWZhdWx0PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdihjLGYpe2Zvcih2YXIgaD0wO2g8Zi5sZW5ndGg7aCsrKXt2YXIgRT1mW2hdO0UuZW51bWVyYWJsZT1FLmVudW1lcmFibGV8fCExLEUuY29uZmlndXJhYmxlPSEwLCJ2YWx1ZSJpbiBFJiYoRS53cml0YWJsZT0hMCksKDAsby5kZWZhdWx0KShjLEUua2V5LEUpfX1yZXR1cm4gZnVuY3Rpb24oYyxmLGgpe3JldHVybiBmJiZ2KGMucHJvdG90eXBlLGYpLGgmJnYoYyxoKSxjfX0oKX0sZnVuY3Rpb24oUixlLHQpe1IuZXhwb3J0cz17ZGVmYXVsdDp0KDE3MyksX19lc01vZHVsZTohMH19LGZ1bmN0aW9uKFIsZSx0KXt0KDE3NCk7dmFyIGk9dCg5MikuT2JqZWN0O1IuZXhwb3J0cz1mdW5jdGlvbihnLHYsYyl7cmV0dXJuIGkuZGVmaW5lUHJvcGVydHkoZyx2LGMpfX0sZnVuY3Rpb24oUixlLHQpe3ZhciBpPXQoOTApO2koaS5TK2kuRiohdCgxMDApLCJPYmplY3QiLHtkZWZpbmVQcm9wZXJ0eTp0KDk2KS5mfSl9LGZ1bmN0aW9uKFIsZSx0KXtSLmV4cG9ydHM9e2RlZmF1bHQ6dCgxNzYpLF9fZXNNb2R1bGU6ITB9fSxmdW5jdGlvbihSLGUsdCl7dCgxNzcpLHQoMTQzKSx0KDE4NCksdCgxODUpLFIuZXhwb3J0cz10KDkyKS5TeW1ib2x9LGZ1bmN0aW9uKFIsZSx0KXt2YXIgaT10KDkxKSxvPXQoMTA1KSxnPXQoMTAwKSx2PXQoOTApLGM9dCgxMDYpLGY9dCgxNTApLktFWSxoPXQoMTAxKSxFPXQoMTE3KSxsPXQoMTIxKSxtPXQoMTE4KSxwPXQoMTIyKSxDPXQoMTc4KSx4PXQoMTc5KSxkPXQoMTgwKSx5PXQoMTU2KSxyPXQoOTcpLHM9dCg5OCksbj10KDEyNCksYT10KDg0KSxPPXQoMTAzKSxBPXQoMTA0KSxiPXQoMTA4KSxJPXQoMTgxKSxQPXQoMTgzKSxEPXQoMTY4KSxMPXQoOTYpLFM9dCgxMTApLFQ9UC5mLGo9TC5mLCQ9SS5mLHc9aS5TeW1ib2wsSj1pLkpTT04scT1KJiZKLnN0cmluZ2lmeSxXPSJwcm90b3R5cGUiLEs9cCgiX2hpZGRlbiIpLFE9cCgidG9QcmltaXRpdmUiKSx0dD17fS5wcm9wZXJ0eUlzRW51bWVyYWJsZSxfPUUoInN5bWJvbC1yZWdpc3RyeSIpLHN0PUUoInN5bWJvbHMiKSxrPUUoIm9wLXN5bWJvbHMiKSxjdD1PYmplY3RbV10sZnQ9dHlwZW9mIHc9PSJmdW5jdGlvbiImJiEhRC5mLFU9aS5RT2JqZWN0LEY9IVV8fCFVW1ddfHwhVVtXXS5maW5kQ2hpbGQsVj1nJiZoKGZ1bmN0aW9uKCl7cmV0dXJuIGIoaih7fSwiYSIse2dldDpmdW5jdGlvbigpe3JldHVybiBqKHRoaXMsImEiLHt2YWx1ZTo3fSkuYX19KSkuYSE9N30pP2Z1bmN0aW9uKGl0LG50LGF0KXt2YXIgZHQ9VChjdCxudCk7ZHQmJmRlbGV0ZSBjdFtudF0saihpdCxudCxhdCksZHQmJml0IT09Y3QmJmooY3QsbnQsZHQpfTpqLFg9ZnVuY3Rpb24oaXQpe3ZhciBudD1zdFtpdF09Yih3W1ddKTtyZXR1cm4gbnQuX2s9aXQsbnR9LEI9ZnQmJnR5cGVvZiB3Lml0ZXJhdG9yPT0ic3ltYm9sIj9mdW5jdGlvbihpdCl7cmV0dXJuIHR5cGVvZiBpdD09InN5bWJvbCJ9OmZ1bmN0aW9uKGl0KXtyZXR1cm4gaXQgaW5zdGFuY2VvZiB3fSxHPWZ1bmN0aW9uKG50LGF0LGR0KXtyZXR1cm4gbnQ9PT1jdCYmRyhrLGF0LGR0KSxyKG50KSxhdD1PKGF0LCEwKSxyKGR0KSxvKHN0LGF0KT8oZHQuZW51bWVyYWJsZT8obyhudCxLKSYmbnRbS11bYXRdJiYobnRbS11bYXRdPSExKSxkdD1iKGR0LHtlbnVtZXJhYmxlOkEoMCwhMSl9KSk6KG8obnQsSyl8fGoobnQsSyxBKDEse30pKSxudFtLXVthdF09ITApLFYobnQsYXQsZHQpKTpqKG50LGF0LGR0KX0sdT1mdW5jdGlvbihudCxhdCl7cihudCk7Zm9yKHZhciBkdD1kKGF0PWEoYXQpKSxndD0wLHV0PWR0Lmxlbmd0aCxtdDt1dD5ndDspRyhudCxtdD1kdFtndCsrXSxhdFttdF0pO3JldHVybiBudH0sTT1mdW5jdGlvbihudCxhdCl7cmV0dXJuIGF0PT09dm9pZCAwP2IobnQpOnUoYihudCksYXQpfSxOPWZ1bmN0aW9uKG50KXt2YXIgYXQ9dHQuY2FsbCh0aGlzLG50PU8obnQsITApKTtyZXR1cm4gdGhpcz09PWN0JiZvKHN0LG50KSYmIW8oayxudCk/ITE6YXR8fCFvKHRoaXMsbnQpfHwhbyhzdCxudCl8fG8odGhpcyxLKSYmdGhpc1tLXVtudF0/YXQ6ITB9LHo9ZnVuY3Rpb24obnQsYXQpe2lmKG50PWEobnQpLGF0PU8oYXQsITApLCEobnQ9PT1jdCYmbyhzdCxhdCkmJiFvKGssYXQpKSl7dmFyIGR0PVQobnQsYXQpO3JldHVybiBkdCYmbyhzdCxhdCkmJiEobyhudCxLKSYmbnRbS11bYXRdKSYmKGR0LmVudW1lcmFibGU9ITApLGR0fX0sSD1mdW5jdGlvbihudCl7Zm9yKHZhciBhdD0kKGEobnQpKSxkdD1bXSxndD0wLHV0O2F0Lmxlbmd0aD5ndDspIW8oc3QsdXQ9YXRbZ3QrK10pJiZ1dCE9SyYmdXQhPWYmJmR0LnB1c2godXQpO3JldHVybiBkdH0sWT1mdW5jdGlvbihudCl7Zm9yKHZhciBhdD1udD09PWN0LGR0PSQoYXQ/azphKG50KSksZ3Q9W10sdXQ9MCxtdDtkdC5sZW5ndGg+dXQ7KW8oc3QsbXQ9ZHRbdXQrK10pJiYoIWF0fHxvKGN0LG10KSkmJmd0LnB1c2goc3RbbXRdKTtyZXR1cm4gZ3R9O2Z0fHwodz1mdW5jdGlvbigpe2lmKHRoaXMgaW5zdGFuY2VvZiB3KXRocm93IFR5cGVFcnJvcigiU3ltYm9sIGlzIG5vdCBhIGNvbnN0cnVjdG9yISIpO3ZhciBudD1tKGFyZ3VtZW50cy5sZW5ndGg+MD9hcmd1bWVudHNbMF06dm9pZCAwKSxhdD1mdW5jdGlvbihkdCl7dGhpcz09PWN0JiZhdC5jYWxsKGssZHQpLG8odGhpcyxLKSYmbyh0aGlzW0tdLG50KSYmKHRoaXNbS11bbnRdPSExKSxWKHRoaXMsbnQsQSgxLGR0KSl9O3JldHVybiBnJiZGJiZWKGN0LG50LHtjb25maWd1cmFibGU6ITAsc2V0OmF0fSksWChudCl9LGMod1tXXSwidG9TdHJpbmciLGZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2t9KSxQLmY9eixMLmY9Ryx0KDE4MikuZj1JLmY9SCx0KDE2OSkuZj1OLEQuZj1ZLGcmJiF0KDg5KSYmYyhjdCwicHJvcGVydHlJc0VudW1lcmFibGUiLE4sITApLEMuZj1mdW5jdGlvbihpdCl7cmV0dXJuIFgocChpdCkpfSksdih2Lkcrdi5XK3YuRiohZnQse1N5bWJvbDp3fSk7Zm9yKHZhciBaPSJoYXNJbnN0YW5jZSxpc0NvbmNhdFNwcmVhZGFibGUsaXRlcmF0b3IsbWF0Y2gscmVwbGFjZSxzZWFyY2gsc3BlY2llcyxzcGxpdCx0b1ByaW1pdGl2ZSx0b1N0cmluZ1RhZyx1bnNjb3BhYmxlcyIuc3BsaXQoIiwiKSxldD0wO1oubGVuZ3RoPmV0OylwKFpbZXQrK10pO2Zvcih2YXIgcnQ9UyhwLnN0b3JlKSxvdD0wO3J0Lmxlbmd0aD5vdDspeChydFtvdCsrXSk7dih2LlMrdi5GKiFmdCwiU3ltYm9sIix7Zm9yOmZ1bmN0aW9uKGl0KXtyZXR1cm4gbyhfLGl0Kz0iIik/X1tpdF06X1tpdF09dyhpdCl9LGtleUZvcjpmdW5jdGlvbihudCl7aWYoIUIobnQpKXRocm93IFR5cGVFcnJvcihudCsiIGlzIG5vdCBhIHN5bWJvbCEiKTtmb3IodmFyIGF0IGluIF8paWYoX1thdF09PT1udClyZXR1cm4gYXR9LHVzZVNldHRlcjpmdW5jdGlvbigpe0Y9ITB9LHVzZVNpbXBsZTpmdW5jdGlvbigpe0Y9ITF9fSksdih2LlMrdi5GKiFmdCwiT2JqZWN0Iix7Y3JlYXRlOk0sZGVmaW5lUHJvcGVydHk6RyxkZWZpbmVQcm9wZXJ0aWVzOnUsZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOnosZ2V0T3duUHJvcGVydHlOYW1lczpILGdldE93blByb3BlcnR5U3ltYm9sczpZfSk7dmFyIGx0PWgoZnVuY3Rpb24oKXtELmYoMSl9KTt2KHYuUyt2LkYqbHQsIk9iamVjdCIse2dldE93blByb3BlcnR5U3ltYm9sczpmdW5jdGlvbihudCl7cmV0dXJuIEQuZihuKG50KSl9fSksSiYmdih2LlMrdi5GKighZnR8fGgoZnVuY3Rpb24oKXt2YXIgaXQ9dygpO3JldHVybiBxKFtpdF0pIT0iW251bGxdInx8cSh7YTppdH0pIT0ie30ifHxxKE9iamVjdChpdCkpIT0ie30ifSkpLCJKU09OIix7c3RyaW5naWZ5OmZ1bmN0aW9uKG50KXtmb3IodmFyIGF0PVtudF0sZHQ9MSxndCx1dDthcmd1bWVudHMubGVuZ3RoPmR0OylhdC5wdXNoKGFyZ3VtZW50c1tkdCsrXSk7aWYodXQ9Z3Q9YXRbMV0sISghcyhndCkmJm50PT09dm9pZCAwfHxCKG50KSkpcmV0dXJuIHkoZ3QpfHwoZ3Q9ZnVuY3Rpb24obXQsRXQpe2lmKHR5cGVvZiB1dD09ImZ1bmN0aW9uIiYmKEV0PXV0LmNhbGwodGhpcyxtdCxFdCkpLCFCKEV0KSlyZXR1cm4gRXR9KSxhdFsxXT1ndCxxLmFwcGx5KEosYXQpfX0pLHdbV11bUV18fHQoOTUpKHdbV10sUSx3W1ddLnZhbHVlT2YpLGwodywiU3ltYm9sIiksbChNYXRoLCJNYXRoIiwhMCksbChpLkpTT04sIkpTT04iLCEwKX0sZnVuY3Rpb24oUixlLHQpe2UuZj10KDEyMil9LGZ1bmN0aW9uKFIsZSx0KXt2YXIgaT10KDkxKSxvPXQoOTIpLGc9dCg4OSksdj10KDE3OCksYz10KDk2KS5mO1IuZXhwb3J0cz1mdW5jdGlvbihmKXt2YXIgaD1vLlN5bWJvbHx8KG8uU3ltYm9sPWc/e306aS5TeW1ib2x8fHt9KTtmLmNoYXJBdCgwKSE9Il8iJiYhKGYgaW4gaCkmJmMoaCxmLHt2YWx1ZTp2LmYoZil9KX19LGZ1bmN0aW9uKFIsZSx0KXt2YXIgaT10KDExMCksbz10KDE2OCksZz10KDE2OSk7Ui5leHBvcnRzPWZ1bmN0aW9uKHYpe3ZhciBjPWkodiksZj1vLmY7aWYoZilmb3IodmFyIGg9Zih2KSxFPWcuZixsPTAsbTtoLmxlbmd0aD5sOylFLmNhbGwodixtPWhbbCsrXSkmJmMucHVzaChtKTtyZXR1cm4gY319LGZ1bmN0aW9uKFIsZSx0KXt2YXIgaT10KDg0KSxvPXQoMTgyKS5mLGc9e30udG9TdHJpbmcsdj10eXBlb2Ygd2luZG93PT0ib2JqZWN0IiYmd2luZG93JiZPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcz9PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh3aW5kb3cpOltdLGM9ZnVuY3Rpb24oZil7dHJ5e3JldHVybiBvKGYpfWNhdGNoe3JldHVybiB2LnNsaWNlKCl9fTtSLmV4cG9ydHMuZj1mdW5jdGlvbihoKXtyZXR1cm4gdiYmZy5jYWxsKGgpPT0iW29iamVjdCBXaW5kb3ddIj9jKGgpOm8oaShoKSl9fSxmdW5jdGlvbihSLGUsdCl7dmFyIGk9dCgxMTEpLG89dCgxMTkpLmNvbmNhdCgibGVuZ3RoIiwicHJvdG90eXBlIik7ZS5mPU9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzfHxmdW5jdGlvbih2KXtyZXR1cm4gaSh2LG8pfX0sZnVuY3Rpb24oUixlLHQpe3ZhciBpPXQoMTY5KSxvPXQoMTA0KSxnPXQoODQpLHY9dCgxMDMpLGM9dCgxMDUpLGY9dCg5OSksaD1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO2UuZj10KDEwMCk/aDpmdW5jdGlvbihsLG0pe2lmKGw9ZyhsKSxtPXYobSwhMCksZil0cnl7cmV0dXJuIGgobCxtKX1jYXRjaHt9aWYoYyhsLG0pKXJldHVybiBvKCFpLmYuY2FsbChsLG0pLGxbbV0pfX0sZnVuY3Rpb24oUixlLHQpe3QoMTc5KSgiYXN5bmNJdGVyYXRvciIpfSxmdW5jdGlvbihSLGUsdCl7dCgxNzkpKCJvYnNlcnZhYmxlIil9LGZ1bmN0aW9uKFIsZSx0KXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksZS5jcmVhdGVOb3dUaW1lPWksZS5mb3JtYXREZWxheT1vO2Z1bmN0aW9uIGkoKXt2YXIgZz1udWxsO3JldHVybiBEYXRlLm5vdz9nPURhdGUubm93Omc9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCl9LGd9ZnVuY3Rpb24gbyhnKXtyZXR1cm4gdHlwZW9mIGc9PSJudW1iZXIiP2c9e2RlbGF5Omd9OiJlbnRyb3B5ImluIGcmJihnPXtkZWxheTpnLmVudHJvcHksaXNFbnRyb3B5OiEwfSksZ319LGZ1bmN0aW9uKFIsZSx0KXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksZS5kZWZhdWx0PXtkZWZhdWx0OmZ1bmN0aW9uKG8sZyx2LGMsZil7cmV0dXJuIHR5cGVvZiBvPT0ibnVtYmVyIiYmdHlwZW9mIGc9PSJudW1iZXIiP28rKHYtYykvKGYtYykqKGctbyk6di1jPmYtdj9nOm99fX0sZnVuY3Rpb24oUixlLHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxlLnBhcnNlRWFzaW5nPWUuRWFzaW5ncz12b2lkIDA7dmFyIGk9dCg3Niksbz1oKGkpLGc9dCgxMzMpLHY9aChnKSxjPXQoMTQxKSxmPWgoYyk7ZnVuY3Rpb24gaCh5KXtyZXR1cm4geSYmeS5fX2VzTW9kdWxlP3k6e2RlZmF1bHQ6eX19dmFyIEU9dCgxODkpLGw9bmV3IGYuZGVmYXVsdDtmdW5jdGlvbiBtKCl7Zm9yKHZhciB5PWFyZ3VtZW50cy5sZW5ndGgscj1BcnJheSh5KSxzPTA7czx5O3MrKylyW3NdPWFyZ3VtZW50c1tzXTt2YXIgbj1sLmdldChyKTtyZXR1cm4gbnx8KG49RS5hcHBseSh2b2lkIDAsciksbC5zZXQocixuKSxuKX1mdW5jdGlvbiBwKHkpe3ZhciByPWFyZ3VtZW50cy5sZW5ndGg+MSYmYXJndW1lbnRzWzFdIT09dm9pZCAwP2FyZ3VtZW50c1sxXToiZW5kIjtyZXR1cm4gZnVuY3Rpb24ocyxuKXtmb3IodmFyIGE9MTthPG4ubGVuZ3RoO2ErKyl7dmFyIE89blthXS5vZmZzZXQ7aWYoczw9Tyl7dmFyIEE9blthLTFdLm9mZnNldCxiPU8sST0ocy1BKS8oYi1BKSxQPTEveSxEPUkvUDtyZXR1cm4gcj09PSJlbmQiP0Q9TWF0aC5mbG9vcihEKTpEPU1hdGguY2VpbChEKSxQKkQqKGItQSkrQX19cmV0dXJuIDB9fWZ1bmN0aW9uIEMoeSl7dmFyIHI9L15jdWJpYy1iZXppZXJcKCguKilcKS8scz15Lm1hdGNoKHIpO2lmKHMpe3ZhciBuPXNbMV0udHJpbSgpO3JldHVybiBuPW4uc3BsaXQoIiwiKS5tYXAoZnVuY3Rpb24oUCl7cmV0dXJuIHBhcnNlRmxvYXQoUC50cmltKCkpfSksbS5hcHBseSh2b2lkIDAsKDAsdi5kZWZhdWx0KShuKSl9aWYocj0vXnN0ZXBzXCgoLiopXCkvLHM9eS5tYXRjaChyKSxzKXt2YXIgYT1zWzFdLnRyaW0oKTthPWEuc3BsaXQoIiwiKS5tYXAoZnVuY3Rpb24oUCl7cmV0dXJuIFAudHJpbSgpfSk7dmFyIE89YSxBPSgwLG8uZGVmYXVsdCkoTywyKSxiPUFbMF0sST1BWzFdO3JldHVybiBwKHBhcnNlSW50KGIsMTApLEkpfXJldHVybiB5fXZhciB4PXtsaW5lYXI6ZnVuY3Rpb24ocil7cmV0dXJuIHJ9LGVhc2U6bSguMjUsLjEsLjI1LDEpLCJlYXNlLWluIjptKC40MiwwLDEsMSksImVhc2Utb3V0IjptKDAsMCwuNTgsMSksImVhc2UtaW4tb3V0IjptKC40MiwwLC41OCwxKSwic3RlcC1zdGFydCI6cCgxLCJzdGFydCIpLCJzdGVwLWVuZCI6cCgxLCJlbmQiKX07ZnVuY3Rpb24gZCh5KXtyZXR1cm4gdHlwZW9mIHk9PSJzdHJpbmciP3hbeV0/eT14W3ldOnk9Qyh5KTp5LnR5cGU9PT0iY3ViaWMtYmV6aWVyIj95PW0uYXBwbHkodm9pZCAwLCgwLHYuZGVmYXVsdCkoeS52YWx1ZSkpOnkudHlwZT09PSJzdGVwcyImJih5PXAoeS5zdGVwLHkucG9zKSkseX1lLkVhc2luZ3M9eCxlLnBhcnNlRWFzaW5nPWR9LGZ1bmN0aW9uKFIsZSl7dmFyIHQ9NCxpPS4wMDEsbz0xZS03LGc9MTAsdj0xMSxjPTEvKHYtMSksZj10eXBlb2YgRmxvYXQzMkFycmF5PT0iZnVuY3Rpb24iO2Z1bmN0aW9uIGgoeSxyKXtyZXR1cm4gMS0zKnIrMyp5fWZ1bmN0aW9uIEUoeSxyKXtyZXR1cm4gMypyLTYqeX1mdW5jdGlvbiBsKHkpe3JldHVybiAzKnl9ZnVuY3Rpb24gbSh5LHIscyl7cmV0dXJuKChoKHIscykqeStFKHIscykpKnkrbChyKSkqeX1mdW5jdGlvbiBwKHkscixzKXtyZXR1cm4gMypoKHIscykqeSp5KzIqRShyLHMpKnkrbChyKX1mdW5jdGlvbiBDKHkscixzLG4sYSl7dmFyIE8sQSxiPTA7ZG8gQT1yKyhzLXIpLzIsTz1tKEEsbixhKS15LE8+MD9zPUE6cj1BO3doaWxlKE1hdGguYWJzKE8pPm8mJisrYjxnKTtyZXR1cm4gQX1mdW5jdGlvbiB4KHkscixzLG4pe2Zvcih2YXIgYT0wO2E8dDsrK2Epe3ZhciBPPXAocixzLG4pO2lmKE89PT0wKXJldHVybiByO3ZhciBBPW0ocixzLG4pLXk7ci09QS9PfXJldHVybiByfWZ1bmN0aW9uIGQoeSl7cmV0dXJuIHl9Ui5leHBvcnRzPWZ1bmN0aW9uKHIscyxuLGEpe2lmKCEoMDw9ciYmcjw9MSYmMDw9biYmbjw9MSkpdGhyb3cgbmV3IEVycm9yKCJiZXppZXIgeCB2YWx1ZXMgbXVzdCBiZSBpbiBbMCwgMV0gcmFuZ2UiKTtpZihyPT09cyYmbj09PWEpcmV0dXJuIGQ7Zm9yKHZhciBPPWY/bmV3IEZsb2F0MzJBcnJheSh2KTpuZXcgQXJyYXkodiksQT0wO0E8djsrK0EpT1tBXT1tKEEqYyxyLG4pO2Z1bmN0aW9uIGIoSSl7Zm9yKHZhciBQPTAsRD0xLEw9di0xO0QhPT1MJiZPW0RdPD1JOysrRClQKz1jOy0tRDt2YXIgUz0oSS1PW0RdKS8oT1tEKzFdLU9bRF0pLFQ9UCtTKmMsaj1wKFQscixuKTtyZXR1cm4gaj49aT94KEksVCxyLG4pOmo9PT0wP1Q6QyhJLFAsUCtjLHIsbil9cmV0dXJuIGZ1bmN0aW9uKFApe3JldHVybiBQPT09MD8wOlA9PT0xPzE6bShiKFApLHMsYSl9fX0sZnVuY3Rpb24oUixlLHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KTt2YXIgaT10KDE5MSksbz1zKGkpLGc9dCgyMDQpLHY9cyhnKSxjPXQoMTY0KSxmPXMoYyksaD10KDE3MCksRT1zKGgpLGw9dCgxNzEpLG09cyhsKSxwPXQoMTc1KSxDPXMocCkseD10KDc1KSxkPXMoeCkseT10KDIwOCkscj10KDE4OCk7ZnVuY3Rpb24gcyhqKXtyZXR1cm4gaiYmai5fX2VzTW9kdWxlP2o6e2RlZmF1bHQ6an19dmFyIG49KDAsQy5kZWZhdWx0KSgidGltaW5nIiksYT0oMCxDLmRlZmF1bHQpKCJrZXlmcmFtZXMiKSxPPSgwLEMuZGVmYXVsdCkoImluaXRTdGF0ZSIpLEE9KDAsQy5kZWZhdWx0KSgicmVhZHlEZWZlciIpLGI9KDAsQy5kZWZhdWx0KSgiZmluaXNoZWREZWZlciIpLEk9KDAsQy5kZWZhdWx0KSgiZWZmZWN0cyIpLFA9KDAsQy5kZWZhdWx0KSgiYWN0aXZlUmVhZHlUaW1lciIpLEQ9KDAsQy5kZWZhdWx0KSgiYWN0aXZlRmluaXNoVGltZXIiKSxMPSgwLEMuZGVmYXVsdCkoInJlbW92ZURlZmVyIiksUz17ZGVsYXk6MCxlbmREZWxheTowLGZpbGw6ImF1dG8iLGl0ZXJhdGlvbnM6MSxwbGF5YmFja1JhdGU6MSxkaXJlY3Rpb246Im5vcm1hbCIsZWFzaW5nOiJsaW5lYXIiLGVmZmVjdDpudWxsfSxUPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gaigkLHcsSil7dmFyIHE9dGhpcztpZigoMCxFLmRlZmF1bHQpKHRoaXMsaiksQXJyYXkuaXNBcnJheSgkKSl7dmFyIFc9WyRbMF0sJCx3XTskPVdbMF0sdz1XWzFdLEo9V1syXX10eXBlb2YgSj09Im51bWJlciImJihKPXtkdXJhdGlvbjpKfSksdGhpc1tuXT0oMCxmLmRlZmF1bHQpKHt9LFMsSiksdGhpc1tuXS5lYXNpbmc9KDAsci5wYXJzZUVhc2luZykodGhpc1tuXS5lYXNpbmcpLHRoaXNbYV09KDAseS5jYWxjdWxhdGVGcmFtZXNPZmZzZXQpKHcpO3ZhciBLPXRoaXNbYV1bdGhpc1thXS5sZW5ndGgtMV07dGhpc1tPXT17fSwoMCx2LmRlZmF1bHQpKEspLmZvckVhY2goZnVuY3Rpb24oUSl7T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKCQsUSkmJlEhPT0iZWFzaW5nIiYmUSE9PSJvZmZzZXQiJiYocVtPXVtRXT0kW1FdKX0pLHRoaXNbYV09dGhpc1thXS5tYXAoZnVuY3Rpb24oUSl7cmV0dXJuKDAsZi5kZWZhdWx0KSh7fSxxW09dLFEpfSksdGhpc1thXVswXS5vZmZzZXQhPT0wJiZ0aGlzW2FdLnVuc2hpZnQoKDAsZi5kZWZhdWx0KSh7fSx0aGlzW09dLHtvZmZzZXQ6MH0pKSxLLm9mZnNldDwxJiZ0aGlzW2FdLnB1c2goKDAsZi5kZWZhdWx0KSh7fSxLLHtvZmZzZXQ6MX0pKSx0aGlzW0ldPXt9LHRoaXMudGltZWxpbmU9bnVsbH1yZXR1cm4oMCxtLmRlZmF1bHQpKGosW3trZXk6InBhdXNlIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMudGltZWxpbmUucGxheWJhY2tSYXRlPTB9fSx7a2V5OlAsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdz10aGlzO3RoaXNbQV0mJiF0aGlzW0FdLnRpbWVySUQmJih0aGlzLnRpbWVsaW5lLmN1cnJlbnRUaW1lPDA/dGhpc1tBXS50aW1lcklEPXRoaXMudGltZWxpbmUuc2V0VGltZW91dChmdW5jdGlvbigpe3dbQV0ucmVzb2x2ZSgpLGRlbGV0ZSB3W0FdfSx7ZGVsYXk6LXRoaXMudGltZWxpbmUuY3VycmVudFRpbWUsaGVhZGluZzohMX0pOnRoaXNbQV0udGltZXJJRD10aGlzLnRpbWVsaW5lLnNldFRpbWVvdXQoZnVuY3Rpb24oKXt3W0FdLnJlc29sdmUoKSxkZWxldGUgd1tBXX0se2RlbGF5OjAsaXNFbnRyb3B5OiEwfSkpfX0se2tleTpELHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHc9dGhpcyxKPXRoaXNbbl0scT1KLmR1cmF0aW9uLFc9Si5pdGVyYXRpb25zLEs9Si5lbmREZWxheSxRPU1hdGguY2VpbChxKlcrSy10aGlzLnRpbWVsaW5lLmN1cnJlbnRUaW1lKSsxO3RoaXNbYl0mJiF0aGlzW2JdLnRpbWVySUQmJih0aGlzW2JdLnRpbWVySUQ9dGhpcy50aW1lbGluZS5zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7d1tiXS5yZXNvbHZlKCksd1tMXShBKSx3W0xdKGIpfSx7ZGVsYXk6USxoZWFkaW5nOiExfSksdGhpc1tiXS5yZXZlcnNlVGltZXJJRD10aGlzLnRpbWVsaW5lLnNldFRpbWVvdXQoZnVuY3Rpb24oKXt3W2JdLnJlc29sdmUoKSx3W0xdKEEpLHdbTF0oYiksdy50aW1lbGluZT1udWxsfSx7ZGVsYXk6LXRoaXNbbl0uZGVsYXktMSxoZWFkaW5nOiExfSkpfX0se2tleToicGxheSIsdmFsdWU6ZnVuY3Rpb24oKXtpZih0aGlzLnBsYXlTdGF0ZT09PSJmaW5pc2hlZCImJnRoaXMuY2FuY2VsKCksdGhpcy5wbGF5U3RhdGU9PT0iaWRsZSIpe2lmKHRoaXMucGxheWJhY2tSYXRlPD0wKXJldHVybjt2YXIgdz10aGlzW25dLEo9dy5kZWxheSxxPXcucGxheWJhY2tSYXRlLFc9dy50aW1lbGluZTt0aGlzLnRpbWVsaW5lPW5ldyBkLmRlZmF1bHQoe29yaWdpblRpbWU6SixwbGF5YmFja1JhdGU6cX0sVyksdGhpc1tQXSgpLHRoaXNbRF0oKX1lbHNlIHRoaXMucGxheVN0YXRlPT09InBhdXNlZCImJih0aGlzLnRpbWVsaW5lLnBsYXliYWNrUmF0ZT10aGlzLnBsYXliYWNrUmF0ZSx0aGlzW1BdKCkpfX0se2tleTpMLHZhbHVlOmZ1bmN0aW9uKHcpe3ZhciBKPXRoaXNbd10scT10aGlzLnRpbWVsaW5lO0omJnEmJihxLmNsZWFyVGltZW91dChKLnRpbWVySUQpLEoucmV2ZXJzZVRpbWVySUQmJnEuY2xlYXJUaW1lb3V0KEoucmV2ZXJzZVRpbWVySUQpKSxkZWxldGUgdGhpc1t3XX19LHtrZXk6ImNhbmNlbCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzW0xdKEEpLHRoaXNbTF0oYiksdGhpcy50aW1lbGluZT1udWxsfX0se2tleToiZmluaXNoIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMudGltZWxpbmUmJih0aGlzLnRpbWVsaW5lLmN1cnJlbnRUaW1lPTEvMC90aGlzLnBsYXliYWNrUmF0ZSksdGhpc1tMXShBKSx0aGlzW0xdKGIpfX0se2tleToiYXBwbHlFZmZlY3RzIix2YWx1ZTpmdW5jdGlvbih3KXtyZXR1cm4oMCxmLmRlZmF1bHQpKHRoaXNbSV0sdyl9fSx7a2V5OiJwbGF5YmFja1JhdGUiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzW25dLnBsYXliYWNrUmF0ZX0sc2V0OmZ1bmN0aW9uKHcpe3RoaXMudGltZWxpbmUmJih0aGlzLnRpbWVsaW5lLnBsYXliYWNrUmF0ZT13KSx0aGlzW25dLnBsYXliYWNrUmF0ZT13fX0se2tleToicGxheVN0YXRlIixnZXQ6ZnVuY3Rpb24oKXt2YXIgdz10aGlzLnRpbWVsaW5lLEo9dGhpc1tuXSxxPUouaXRlcmF0aW9ucyxXPUouZHVyYXRpb24sSz1KLmVuZERlbGF5LFE9InJ1bm5pbmciO2lmKHc9PW51bGwpUT0iaWRsZSI7ZWxzZSBpZih3LnBhdXNlZClRPSJwYXVzZWQiO2Vsc2UgaWYody5jdXJyZW50VGltZTwwKVE9InBlbmRpbmciO2Vsc2V7dmFyIHR0PXcuY3VycmVudFRpbWUtcSpXO3R0PjAmJnR0PEs/UT0icGVuZGluZyI6dHQ+PUsmJihRPSJmaW5pc2hlZCIpfXJldHVybiBRfX0se2tleToicHJvZ3Jlc3MiLGdldDpmdW5jdGlvbigpe2lmKCF0aGlzLnRpbWVsaW5lKXJldHVybiAwO3ZhciB3PXRoaXNbbl0sSj13LmR1cmF0aW9uLHE9dy5pdGVyYXRpb25zLFc9dGhpcy50aW1lbGluZSxLPXRoaXMucGxheVN0YXRlLFE9dm9pZCAwO2lmKEs9PT0iaWRsZSIpUT0wO2Vsc2UgaWYoSz09PSJwYXVzZWQiJiZXLmN1cnJlbnRUaW1lPDApUT0wO2Vsc2UgaWYoSz09PSJwZW5kaW5nIilpZihXLmN1cnJlbnRUaW1lPDApUT0wO2Vsc2V7dmFyIHR0PVcuc2Vla0xvY2FsVGltZShxKkopO1E9KDAseS5wZXJpb2RpY2l0eSkodHQsSilbMV0vSn1lbHNlKEs9PT0icnVubmluZyJ8fEs9PT0icGF1c2VkIikmJihRPSgwLHkucGVyaW9kaWNpdHkpKFcuY3VycmVudFRpbWUsSilbMV0vSik7cmV0dXJuIEs9PT0iZmluaXNoZWQiJiYoUT0oMCx5LnBlcmlvZGljaXR5KShxLDEpWzFdKSxRfX0se2tleToiZnJhbWUiLGdldDpmdW5jdGlvbigpe3ZhciB3PXRoaXMucGxheVN0YXRlLEo9dGhpc1tPXSxxPXRoaXNbbl0uZmlsbDtpZih3PT09ImlkbGUiKXJldHVybiBKO3ZhciBXPXRoaXMudGltZWxpbmUuY3VycmVudFRpbWUsSz10aGlzW2FdLnNsaWNlKDApLFE9KDAseS5nZXRQcm9ncmVzcykodGhpcy50aW1lbGluZSx0aGlzW25dLHRoaXMucHJvZ3Jlc3MpLHR0PVEucCxfPVEuaW52ZXJ0ZWQsc3Q9SjtyZXR1cm4gVzwwJiZ3PT09InBlbmRpbmciPyhxPT09ImJhY2t3YXJkcyJ8fHE9PT0iYm90aCIpJiYoc3Q9Xz9LW0subGVuZ3RoLTFdOktbMF0pOih3IT09InBlbmRpbmciJiZ3IT09ImZpbmlzaGVkInx8cT09PSJmb3J3YXJkcyJ8fHE9PT0iYm90aCIpJiYoc3Q9KDAseS5nZXRDdXJyZW50RnJhbWUpKHRoaXNbbl0sSyx0aGlzW0ldLHR0KSksc3R9fSx7a2V5OiJ0aW1pbmciLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzW25dfX0se2tleToiZWZmZWN0cyIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXNbSV19fSx7a2V5OiJiYXNlVGltZWxpbmUiLHNldDpmdW5jdGlvbih3KXt0aGlzW25dLnRpbWVsaW5lPXd9LGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzW25dLnRpbWVsaW5lfX0se2tleToicmVhZHkiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzW0FdP3RoaXNbQV0ucHJvbWlzZTp0aGlzLnRpbWVsaW5lJiZ0aGlzLnRpbWVsaW5lLmN1cnJlbnRUaW1lPj0wJiZ0aGlzLnBsYXlTdGF0ZSE9PSJwYXVzZWQiP28uZGVmYXVsdC5yZXNvbHZlKCk6KHRoaXNbQV09KDAseS5kZWZlcikoKSx0aGlzLnRpbWVsaW5lJiZ0aGlzW1BdKCksdGhpc1tBXT90aGlzW0FdLnByb21pc2U6by5kZWZhdWx0LnJlc29sdmUoKSl9fSx7a2V5OiJmaW5pc2hlZCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucGxheVN0YXRlPT09ImZpbmlzaGVkIj9vLmRlZmF1bHQucmVzb2x2ZSgpOih0aGlzW2JdfHwodGhpc1tiXT0oMCx5LmRlZmVyKSgpLHRoaXMudGltZWxpbmUmJnRoaXNbRF0oKSksdGhpc1tiXS5wcm9taXNlKX19XSksan0oKTtlLmRlZmF1bHQ9VH0sZnVuY3Rpb24oUixlLHQpe1IuZXhwb3J0cz17ZGVmYXVsdDp0KDE5MiksX19lc01vZHVsZTohMH19LGZ1bmN0aW9uKFIsZSx0KXt0KDE0MyksdCgxMjUpLHQoNzkpLHQoMTkzKSx0KDIwMiksdCgyMDMpLFIuZXhwb3J0cz10KDkyKS5Qcm9taXNlfSxmdW5jdGlvbihSLGUsdCl7dmFyIGk9dCg4OSksbz10KDkxKSxnPXQoOTMpLHY9dCgxMjgpLGM9dCg5MCksZj10KDk4KSxoPXQoOTQpLEU9dCgxNDcpLGw9dCgxNDgpLG09dCgxOTQpLHA9dCgxOTUpLnNldCxDPXQoMTk3KSgpLHg9dCgxOTgpLGQ9dCgxOTkpLHk9dCgyMDApLHI9dCgyMDEpLHM9IlByb21pc2UiLG49by5UeXBlRXJyb3IsYT1vLnByb2Nlc3MsTz1hJiZhLnZlcnNpb25zLEE9TyYmTy52OHx8IiIsYj1vW3NdLEk9dihhKT09InByb2Nlc3MiLFA9ZnVuY3Rpb24oKXt9LEQsTCxTLFQsaj1MPXguZiwkPSEhZnVuY3Rpb24oKXt0cnl7dmFyIF89Yi5yZXNvbHZlKDEpLHN0PShfLmNvbnN0cnVjdG9yPXt9KVt0KDEyMikoInNwZWNpZXMiKV09ZnVuY3Rpb24oayl7ayhQLFApfTtyZXR1cm4oSXx8dHlwZW9mIFByb21pc2VSZWplY3Rpb25FdmVudD09ImZ1bmN0aW9uIikmJl8udGhlbihQKWluc3RhbmNlb2Ygc3QmJkEuaW5kZXhPZigiNi42IikhPT0wJiZ5LmluZGV4T2YoIkNocm9tZS82NiIpPT09LTF9Y2F0Y2h7fX0oKSx3PWZ1bmN0aW9uKF8pe3ZhciBzdDtyZXR1cm4gZihfKSYmdHlwZW9mKHN0PV8udGhlbik9PSJmdW5jdGlvbiI/c3Q6ITF9LEo9ZnVuY3Rpb24oXyxzdCl7aWYoIV8uX24pe18uX249ITA7dmFyIGs9Xy5fYztDKGZ1bmN0aW9uKCl7Zm9yKHZhciBjdD1fLl92LGZ0PV8uX3M9PTEsVT0wLEY9ZnVuY3Rpb24oVil7dmFyIFg9ZnQ/Vi5vazpWLmZhaWwsQj1WLnJlc29sdmUsRz1WLnJlamVjdCx1PVYuZG9tYWluLE0sTix6O3RyeXtYPyhmdHx8KF8uX2g9PTImJksoXyksXy5faD0xKSxYPT09ITA/TT1jdDoodSYmdS5lbnRlcigpLE09WChjdCksdSYmKHUuZXhpdCgpLHo9ITApKSxNPT09Vi5wcm9taXNlP0cobigiUHJvbWlzZS1jaGFpbiBjeWNsZSIpKTooTj13KE0pKT9OLmNhbGwoTSxCLEcpOkIoTSkpOkcoY3QpfWNhdGNoKEgpe3UmJiF6JiZ1LmV4aXQoKSxHKEgpfX07ay5sZW5ndGg+VTspRihrW1UrK10pO18uX2M9W10sXy5fbj0hMSxzdCYmIV8uX2gmJnEoXyl9KX19LHE9ZnVuY3Rpb24oXyl7cC5jYWxsKG8sZnVuY3Rpb24oKXt2YXIgc3Q9Xy5fdixrPVcoXyksY3QsZnQsVTtpZihrJiYoY3Q9ZChmdW5jdGlvbigpe0k/YS5lbWl0KCJ1bmhhbmRsZWRSZWplY3Rpb24iLHN0LF8pOihmdD1vLm9udW5oYW5kbGVkcmVqZWN0aW9uKT9mdCh7cHJvbWlzZTpfLHJlYXNvbjpzdH0pOihVPW8uY29uc29sZSkmJlUuZXJyb3ImJlUuZXJyb3IoIlVuaGFuZGxlZCBwcm9taXNlIHJlamVjdGlvbiIsc3QpfSksXy5faD1JfHxXKF8pPzI6MSksXy5fYT12b2lkIDAsayYmY3QuZSl0aHJvdyBjdC52fSl9LFc9ZnVuY3Rpb24oXyl7cmV0dXJuIF8uX2ghPT0xJiYoXy5fYXx8Xy5fYykubGVuZ3RoPT09MH0sSz1mdW5jdGlvbihfKXtwLmNhbGwobyxmdW5jdGlvbigpe3ZhciBzdDtJP2EuZW1pdCgicmVqZWN0aW9uSGFuZGxlZCIsXyk6KHN0PW8ub25yZWplY3Rpb25oYW5kbGVkKSYmc3Qoe3Byb21pc2U6XyxyZWFzb246Xy5fdn0pfSl9LFE9ZnVuY3Rpb24oXyl7dmFyIHN0PXRoaXM7c3QuX2R8fChzdC5fZD0hMCxzdD1zdC5fd3x8c3Qsc3QuX3Y9XyxzdC5fcz0yLHN0Ll9hfHwoc3QuX2E9c3QuX2Muc2xpY2UoKSksSihzdCwhMCkpfSx0dD1mdW5jdGlvbihfKXt2YXIgc3Q9dGhpcyxrO2lmKCFzdC5fZCl7c3QuX2Q9ITAsc3Q9c3QuX3d8fHN0O3RyeXtpZihzdD09PV8pdGhyb3cgbigiUHJvbWlzZSBjYW4ndCBiZSByZXNvbHZlZCBpdHNlbGYiKTsoaz13KF8pKT9DKGZ1bmN0aW9uKCl7dmFyIGN0PXtfdzpzdCxfZDohMX07dHJ5e2suY2FsbChfLGcodHQsY3QsMSksZyhRLGN0LDEpKX1jYXRjaChmdCl7US5jYWxsKGN0LGZ0KX19KTooc3QuX3Y9XyxzdC5fcz0xLEooc3QsITEpKX1jYXRjaChjdCl7US5jYWxsKHtfdzpzdCxfZDohMX0sY3QpfX19OyR8fChiPWZ1bmN0aW9uKHN0KXtFKHRoaXMsYixzLCJfaCIpLGgoc3QpLEQuY2FsbCh0aGlzKTt0cnl7c3QoZyh0dCx0aGlzLDEpLGcoUSx0aGlzLDEpKX1jYXRjaChrKXtRLmNhbGwodGhpcyxrKX19LEQ9ZnVuY3Rpb24oc3Qpe3RoaXMuX2M9W10sdGhpcy5fYT12b2lkIDAsdGhpcy5fcz0wLHRoaXMuX2Q9ITEsdGhpcy5fdj12b2lkIDAsdGhpcy5faD0wLHRoaXMuX249ITF9LEQucHJvdG90eXBlPXQoMTQ2KShiLnByb3RvdHlwZSx7dGhlbjpmdW5jdGlvbihzdCxrKXt2YXIgY3Q9aihtKHRoaXMsYikpO3JldHVybiBjdC5vaz10eXBlb2Ygc3Q9PSJmdW5jdGlvbiI/c3Q6ITAsY3QuZmFpbD10eXBlb2Ygaz09ImZ1bmN0aW9uIiYmayxjdC5kb21haW49ST9hLmRvbWFpbjp2b2lkIDAsdGhpcy5fYy5wdXNoKGN0KSx0aGlzLl9hJiZ0aGlzLl9hLnB1c2goY3QpLHRoaXMuX3MmJkoodGhpcywhMSksY3QucHJvbWlzZX0sY2F0Y2g6ZnVuY3Rpb24oXyl7cmV0dXJuIHRoaXMudGhlbih2b2lkIDAsXyl9fSksUz1mdW5jdGlvbigpe3ZhciBfPW5ldyBEO3RoaXMucHJvbWlzZT1fLHRoaXMucmVzb2x2ZT1nKHR0LF8sMSksdGhpcy5yZWplY3Q9ZyhRLF8sMSl9LHguZj1qPWZ1bmN0aW9uKF8pe3JldHVybiBfPT09Ynx8Xz09PVQ/bmV3IFMoXyk6TChfKX0pLGMoYy5HK2MuVytjLkYqISQse1Byb21pc2U6Yn0pLHQoMTIxKShiLHMpLHQoMTQ5KShzKSxUPXQoOTIpW3NdLGMoYy5TK2MuRiohJCxzLHtyZWplY3Q6ZnVuY3Rpb24oc3Qpe3ZhciBrPWoodGhpcyksY3Q9ay5yZWplY3Q7cmV0dXJuIGN0KHN0KSxrLnByb21pc2V9fSksYyhjLlMrYy5GKihpfHwhJCkscyx7cmVzb2x2ZTpmdW5jdGlvbihzdCl7cmV0dXJuIHIoaSYmdGhpcz09PVQ/Yjp0aGlzLHN0KX19KSxjKGMuUytjLkYqISgkJiZ0KDE0MCkoZnVuY3Rpb24oXyl7Yi5hbGwoXykuY2F0Y2goUCl9KSkscyx7YWxsOmZ1bmN0aW9uKHN0KXt2YXIgaz10aGlzLGN0PWooayksZnQ9Y3QucmVzb2x2ZSxVPWN0LnJlamVjdCxGPWQoZnVuY3Rpb24oKXt2YXIgVj1bXSxYPTAsQj0xO2woc3QsITEsZnVuY3Rpb24oRyl7dmFyIHU9WCsrLE09ITE7Vi5wdXNoKHZvaWQgMCksQisrLGsucmVzb2x2ZShHKS50aGVuKGZ1bmN0aW9uKE4pe018fChNPSEwLFZbdV09TiwtLUJ8fGZ0KFYpKX0sVSl9KSwtLUJ8fGZ0KFYpfSk7cmV0dXJuIEYuZSYmVShGLnYpLGN0LnByb21pc2V9LHJhY2U6ZnVuY3Rpb24oc3Qpe3ZhciBrPXRoaXMsY3Q9aihrKSxmdD1jdC5yZWplY3QsVT1kKGZ1bmN0aW9uKCl7bChzdCwhMSxmdW5jdGlvbihGKXtrLnJlc29sdmUoRikudGhlbihjdC5yZXNvbHZlLGZ0KX0pfSk7cmV0dXJuIFUuZSYmZnQoVS52KSxjdC5wcm9taXNlfX0pfSxmdW5jdGlvbihSLGUsdCl7dmFyIGk9dCg5Nyksbz10KDk0KSxnPXQoMTIyKSgic3BlY2llcyIpO1IuZXhwb3J0cz1mdW5jdGlvbih2LGMpe3ZhciBmPWkodikuY29uc3RydWN0b3IsaDtyZXR1cm4gZj09PXZvaWQgMHx8KGg9aShmKVtnXSk9PW51bGw/YzpvKGgpfX0sZnVuY3Rpb24oUixlLHQpe3ZhciBpPXQoOTMpLG89dCgxOTYpLGc9dCgxMjApLHY9dCgxMDIpLGM9dCg5MSksZj1jLnByb2Nlc3MsaD1jLnNldEltbWVkaWF0ZSxFPWMuY2xlYXJJbW1lZGlhdGUsbD1jLk1lc3NhZ2VDaGFubmVsLG09Yy5EaXNwYXRjaCxwPTAsQz17fSx4PSJvbnJlYWR5c3RhdGVjaGFuZ2UiLGQseSxyLHM9ZnVuY3Rpb24oKXt2YXIgYT0rdGhpcztpZihDLmhhc093blByb3BlcnR5KGEpKXt2YXIgTz1DW2FdO2RlbGV0ZSBDW2FdLE8oKX19LG49ZnVuY3Rpb24oYSl7cy5jYWxsKGEuZGF0YSl9OyghaHx8IUUpJiYoaD1mdW5jdGlvbihPKXtmb3IodmFyIEE9W10sYj0xO2FyZ3VtZW50cy5sZW5ndGg+YjspQS5wdXNoKGFyZ3VtZW50c1tiKytdKTtyZXR1cm4gQ1srK3BdPWZ1bmN0aW9uKCl7byh0eXBlb2YgTz09ImZ1bmN0aW9uIj9POkZ1bmN0aW9uKE8pLEEpfSxkKHApLHB9LEU9ZnVuY3Rpb24oTyl7ZGVsZXRlIENbT119LHQoODYpKGYpPT0icHJvY2VzcyI/ZD1mdW5jdGlvbihhKXtmLm5leHRUaWNrKGkocyxhLDEpKX06bSYmbS5ub3c/ZD1mdW5jdGlvbihhKXttLm5vdyhpKHMsYSwxKSl9Omw/KHk9bmV3IGwscj15LnBvcnQyLHkucG9ydDEub25tZXNzYWdlPW4sZD1pKHIucG9zdE1lc3NhZ2UsciwxKSk6Yy5hZGRFdmVudExpc3RlbmVyJiZ0eXBlb2YgcG9zdE1lc3NhZ2U9PSJmdW5jdGlvbiImJiFjLmltcG9ydFNjcmlwdHM/KGQ9ZnVuY3Rpb24oYSl7Yy5wb3N0TWVzc2FnZShhKyIiLCIqIil9LGMuYWRkRXZlbnRMaXN0ZW5lcigibWVzc2FnZSIsbiwhMSkpOnggaW4gdigic2NyaXB0Iik/ZD1mdW5jdGlvbihhKXtnLmFwcGVuZENoaWxkKHYoInNjcmlwdCIpKVt4XT1mdW5jdGlvbigpe2cucmVtb3ZlQ2hpbGQodGhpcykscy5jYWxsKGEpfX06ZD1mdW5jdGlvbihhKXtzZXRUaW1lb3V0KGkocyxhLDEpLDApfSksUi5leHBvcnRzPXtzZXQ6aCxjbGVhcjpFfX0sZnVuY3Rpb24oUixlKXtSLmV4cG9ydHM9ZnVuY3Rpb24odCxpLG8pe3ZhciBnPW89PT12b2lkIDA7c3dpdGNoKGkubGVuZ3RoKXtjYXNlIDA6cmV0dXJuIGc/dCgpOnQuY2FsbChvKTtjYXNlIDE6cmV0dXJuIGc/dChpWzBdKTp0LmNhbGwobyxpWzBdKTtjYXNlIDI6cmV0dXJuIGc/dChpWzBdLGlbMV0pOnQuY2FsbChvLGlbMF0saVsxXSk7Y2FzZSAzOnJldHVybiBnP3QoaVswXSxpWzFdLGlbMl0pOnQuY2FsbChvLGlbMF0saVsxXSxpWzJdKTtjYXNlIDQ6cmV0dXJuIGc/dChpWzBdLGlbMV0saVsyXSxpWzNdKTp0LmNhbGwobyxpWzBdLGlbMV0saVsyXSxpWzNdKX1yZXR1cm4gdC5hcHBseShvLGkpfX0sZnVuY3Rpb24oUixlLHQpe3ZhciBpPXQoOTEpLG89dCgxOTUpLnNldCxnPWkuTXV0YXRpb25PYnNlcnZlcnx8aS5XZWJLaXRNdXRhdGlvbk9ic2VydmVyLHY9aS5wcm9jZXNzLGM9aS5Qcm9taXNlLGY9dCg4Nikodik9PSJwcm9jZXNzIjtSLmV4cG9ydHM9ZnVuY3Rpb24oKXt2YXIgaCxFLGwsbT1mdW5jdGlvbigpe3ZhciBkLHk7Zm9yKGYmJihkPXYuZG9tYWluKSYmZC5leGl0KCk7aDspe3k9aC5mbixoPWgubmV4dDt0cnl7eSgpfWNhdGNoKHIpe3Rocm93IGg/bCgpOkU9dm9pZCAwLHJ9fUU9dm9pZCAwLGQmJmQuZW50ZXIoKX07aWYoZilsPWZ1bmN0aW9uKCl7di5uZXh0VGljayhtKX07ZWxzZSBpZihnJiYhKGkubmF2aWdhdG9yJiZpLm5hdmlnYXRvci5zdGFuZGFsb25lKSl7dmFyIHA9ITAsQz1kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgiIik7bmV3IGcobSkub2JzZXJ2ZShDLHtjaGFyYWN0ZXJEYXRhOiEwfSksbD1mdW5jdGlvbigpe0MuZGF0YT1wPSFwfX1lbHNlIGlmKGMmJmMucmVzb2x2ZSl7dmFyIHg9Yy5yZXNvbHZlKHZvaWQgMCk7bD1mdW5jdGlvbigpe3gudGhlbihtKX19ZWxzZSBsPWZ1bmN0aW9uKCl7by5jYWxsKGksbSl9O3JldHVybiBmdW5jdGlvbihkKXt2YXIgeT17Zm46ZCxuZXh0OnZvaWQgMH07RSYmKEUubmV4dD15KSxofHwoaD15LGwoKSksRT15fX19LGZ1bmN0aW9uKFIsZSx0KXt2YXIgaT10KDk0KTtmdW5jdGlvbiBvKGcpe3ZhciB2LGM7dGhpcy5wcm9taXNlPW5ldyBnKGZ1bmN0aW9uKGYsaCl7aWYodiE9PXZvaWQgMHx8YyE9PXZvaWQgMCl0aHJvdyBUeXBlRXJyb3IoIkJhZCBQcm9taXNlIGNvbnN0cnVjdG9yIik7dj1mLGM9aH0pLHRoaXMucmVzb2x2ZT1pKHYpLHRoaXMucmVqZWN0PWkoYyl9Ui5leHBvcnRzLmY9ZnVuY3Rpb24oZyl7cmV0dXJuIG5ldyBvKGcpfX0sZnVuY3Rpb24oUixlKXtSLmV4cG9ydHM9ZnVuY3Rpb24odCl7dHJ5e3JldHVybntlOiExLHY6dCgpfX1jYXRjaChpKXtyZXR1cm57ZTohMCx2Oml9fX19LGZ1bmN0aW9uKFIsZSx0KXt2YXIgaT10KDkxKSxvPWkubmF2aWdhdG9yO1IuZXhwb3J0cz1vJiZvLnVzZXJBZ2VudHx8IiJ9LGZ1bmN0aW9uKFIsZSx0KXt2YXIgaT10KDk3KSxvPXQoOTgpLGc9dCgxOTgpO1IuZXhwb3J0cz1mdW5jdGlvbih2LGMpe2lmKGkodiksbyhjKSYmYy5jb25zdHJ1Y3Rvcj09PXYpcmV0dXJuIGM7dmFyIGY9Zy5mKHYpLGg9Zi5yZXNvbHZlO3JldHVybiBoKGMpLGYucHJvbWlzZX19LGZ1bmN0aW9uKFIsZSx0KXt2YXIgaT10KDkwKSxvPXQoOTIpLGc9dCg5MSksdj10KDE5NCksYz10KDIwMSk7aShpLlAraS5SLCJQcm9taXNlIix7ZmluYWxseTpmdW5jdGlvbihmKXt2YXIgaD12KHRoaXMsby5Qcm9taXNlfHxnLlByb21pc2UpLEU9dHlwZW9mIGY9PSJmdW5jdGlvbiI7cmV0dXJuIHRoaXMudGhlbihFP2Z1bmN0aW9uKGwpe3JldHVybiBjKGgsZigpKS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIGx9KX06ZixFP2Z1bmN0aW9uKGwpe3JldHVybiBjKGgsZigpKS50aGVuKGZ1bmN0aW9uKCl7dGhyb3cgbH0pfTpmKX19KX0sZnVuY3Rpb24oUixlLHQpe3ZhciBpPXQoOTApLG89dCgxOTgpLGc9dCgxOTkpO2koaS5TLCJQcm9taXNlIix7dHJ5OmZ1bmN0aW9uKHYpe3ZhciBjPW8uZih0aGlzKSxmPWcodik7cmV0dXJuKGYuZT9jLnJlamVjdDpjLnJlc29sdmUpKGYudiksYy5wcm9taXNlfX0pfSxmdW5jdGlvbihSLGUsdCl7Ui5leHBvcnRzPXtkZWZhdWx0OnQoMjA1KSxfX2VzTW9kdWxlOiEwfX0sZnVuY3Rpb24oUixlLHQpe3QoMjA2KSxSLmV4cG9ydHM9dCg5MikuT2JqZWN0LmtleXN9LGZ1bmN0aW9uKFIsZSx0KXt2YXIgaT10KDEyNCksbz10KDExMCk7dCgyMDcpKCJrZXlzIixmdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbih2KXtyZXR1cm4gbyhpKHYpKX19KX0sZnVuY3Rpb24oUixlLHQpe3ZhciBpPXQoOTApLG89dCg5MiksZz10KDEwMSk7Ui5leHBvcnRzPWZ1bmN0aW9uKHYsYyl7dmFyIGY9KG8uT2JqZWN0fHx7fSlbdl18fE9iamVjdFt2XSxoPXt9O2hbdl09YyhmKSxpKGkuUytpLkYqZyhmdW5jdGlvbigpe2YoMSl9KSwiT2JqZWN0IixoKX19LGZ1bmN0aW9uKFIsZSx0KXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSk7dmFyIGk9dCg3Niksbz1DKGkpLGc9dCgyMDkpLHY9QyhnKSxjPXQoMTY0KSxmPUMoYyksaD10KDE5MSksRT1DKGgpO2UuZGVmZXI9eCxlLnBlcmlvZGljaXR5PWQsZS5jYWxjdWxhdGVGcmFtZXNPZmZzZXQ9eSxlLmdldFByb2dyZXNzPXIsZS5nZXRDdXJyZW50RnJhbWU9bjt2YXIgbD10KDE4OCksbT10KDE4NykscD1DKG0pO2Z1bmN0aW9uIEMoYSl7cmV0dXJuIGEmJmEuX19lc01vZHVsZT9hOntkZWZhdWx0OmF9fWZ1bmN0aW9uIHgoKXt2YXIgYT17fTtyZXR1cm4gYS5wcm9taXNlPW5ldyBFLmRlZmF1bHQoZnVuY3Rpb24oTyxBKXthLnJlc29sdmU9TyxhLnJlamVjdD1BfSksYX1mdW5jdGlvbiBkKGEsTyl7dmFyIEE9TWF0aC5mbG9vcihhL08pLGI9YS1BKk87cmV0dXJuIGI9PT0wJiZBPjAmJihiPU8sQS0tKSxbQSxiXX1mdW5jdGlvbiB5KGEpe2E9YS5zbGljZSgwKTt2YXIgTz1hWzBdLEE9YVthLmxlbmd0aC0xXTtBLm9mZnNldD1BLm9mZnNldHx8MSxPLm9mZnNldD1PLm9mZnNldHx8MDtmb3IodmFyIGI9MCxJPS0xLFA9MDtQPGEubGVuZ3RoO1ArKyl7dmFyIEQ9YVtQXTtpZihELm9mZnNldCE9bnVsbCl7dmFyIEw9UC1JO2lmKEw+MSlmb3IodmFyIFM9KEQub2Zmc2V0LWIpL0wsVD0wO1Q8TC0xO1QrKylhW0krVCsxXS5vZmZzZXQ9YitTKihUKzEpO2I9RC5vZmZzZXQsST1QfWlmKEQuZWFzaW5nIT1udWxsJiYoRC5lYXNpbmc9KDAsbC5wYXJzZUVhc2luZykoRC5lYXNpbmcpKSxQPjApe3ZhciBqPWFbUF0uZWFzaW5nIT1udWxsO2FbUF09KDAsZi5kZWZhdWx0KSh7fSxhW1AtMV0sYVtQXSksanx8ZGVsZXRlIGFbUF0uZWFzaW5nfX1yZXR1cm4gYX1mdW5jdGlvbiByKGEsTyxBKXt2YXIgYj1hLmN1cnJlbnRUaW1lLEk9Ty5kaXJlY3Rpb24sUD1PLmR1cmF0aW9uLEQ9ITE7aWYoST09PSJyZXZlcnNlIilBPTEtQSxEPSEwO2Vsc2UgaWYoST09PSJhbHRlcm5hdGUifHxJPT09ImFsdGVybmF0ZS1yZXZlcnNlIil7dmFyIEw9TWF0aC5mbG9vcihiL1ApO0E9PT0xJiZMLS0sTCUyXkk9PT0iYWx0ZXJuYXRlLXJldmVyc2UiJiYoQT0xLUEsRD0hMCl9cmV0dXJue3A6QSxpbnZlcnRlZDpEfX1mdW5jdGlvbiBzKGEsTyxBLGIpe3ZhciBJPXt9O3JldHVybigwLHYuZGVmYXVsdCkoTykuZm9yRWFjaChmdW5jdGlvbihQKXt2YXIgRD0oMCxvLmRlZmF1bHQpKFAsMiksTD1EWzBdLFM9RFsxXTtpZihMIT09Im9mZnNldCImJkwhPT0iZWFzaW5nIil7dmFyIFQ9QVtMXXx8QS5kZWZhdWx0LGo9VChhW0xdLFMsYixhLm9mZnNldCxPLm9mZnNldCk7aiE9bnVsbCYmKElbTF09ail9fSksSX1mdW5jdGlvbiBuKGEsTyxBLGIpe3ZhciBJPWEuZWFzaW5nLFA9YS5lZmZlY3Q7UHx8KEE9KDAsZi5kZWZhdWx0KSh7fSxwLmRlZmF1bHQsQSkpO3ZhciBEPXt9O2I9SShiLE8pO2Zvcih2YXIgTD0xO0w8Ty5sZW5ndGg7TCsrKXt2YXIgUz1PW0xdLFQ9Uy5vZmZzZXQ7aWYoVD49Ynx8TD09PU8ubGVuZ3RoLTEpe3ZhciBqPU9bTC0xXSwkPWoub2Zmc2V0LHc9ai5lYXNpbmcsSj1iO2lmKHcpe3ZhciBxPVQtJDtKPXcoKGItJCkvcSkqcSskfVA/RD1QKGosUyxKLCQsVCk6RD1zKGosUyxBLEopO2JyZWFrfX1yZXR1cm4gRH19LGZ1bmN0aW9uKFIsZSx0KXtSLmV4cG9ydHM9e2RlZmF1bHQ6dCgyMTApLF9fZXNNb2R1bGU6ITB9fSxmdW5jdGlvbihSLGUsdCl7dCgyMTEpLFIuZXhwb3J0cz10KDkyKS5PYmplY3QuZW50cmllc30sZnVuY3Rpb24oUixlLHQpe3ZhciBpPXQoOTApLG89dCgyMTIpKCEwKTtpKGkuUywiT2JqZWN0Iix7ZW50cmllczpmdW5jdGlvbih2KXtyZXR1cm4gbyh2KX19KX0sZnVuY3Rpb24oUixlLHQpe3ZhciBpPXQoMTAwKSxvPXQoMTEwKSxnPXQoODQpLHY9dCgxNjkpLmY7Ui5leHBvcnRzPWZ1bmN0aW9uKGMpe3JldHVybiBmdW5jdGlvbihmKXtmb3IodmFyIGg9ZyhmKSxFPW8oaCksbD1FLmxlbmd0aCxtPTAscD1bXSxDO2w+bTspQz1FW20rK10sKCFpfHx2LmNhbGwoaCxDKSkmJnAucHVzaChjP1tDLGhbQ11dOmhbQ10pO3JldHVybiBwfX19LGZ1bmN0aW9uKFIsZSx0KXt0LnIoZSksdCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IGk9bmV3IE1hcDtmdW5jdGlvbiBvKHYsYz17fSxmPVtdKXt2PXYudG9Mb3dlckNhc2UoKTtjb25zdCBoPWkuZ2V0KHYpO2lmKCFoKXRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgbm9kZTogJHt2fWApO2NvbnN0IEU9bmV3IGgoYyk7cmV0dXJuIGYuZm9yRWFjaChsPT57RS5hcHBlbmRDaGlsZChsKX0pLEV9Y29uc3QgZz17cmVnaXN0ZXJOb2RlKHYsYyxmPTEwMCl7aWYoYz1jLnRvTG93ZXJDYXNlKCksaS5oYXMoYykpdGhyb3cgbmV3IFR5cGVFcnJvcihgQ2Fubm90IHJlZ2lzdGVyTm9kZSwgJHtjfSBoYXMgYmVlbiB0YWtlbi5gKTtpLnNldChjLHYpLE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHYucHJvdG90eXBlLHtub2RlVHlwZTp7dmFsdWU6Zn0sdGFnTmFtZTp7dmFsdWU6Yy50b1VwcGVyQ2FzZSgpfSxub2RlTmFtZTp7dmFsdWU6Y30sb3duZXJEb2N1bWVudDp7dmFsdWU6Z30sbmFtZXNwYWNlVVJJOnt2YWx1ZTpgaHR0cDovL3Nwcml0ZWpzLmNvbS8ke2N9YH19KX0sY3JlYXRlRWxlbWVudDpvLGNyZWF0ZUVsZW1lbnROUyh2LGMpe3JldHVybiBvKGMpfSxpc1Nwcml0ZU5vZGUodil7cmV0dXJuIGkuaGFzKHYudG9Mb3dlckNhc2UoKSl9fTtlLmRlZmF1bHQ9Z30sZnVuY3Rpb24oUixlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gY30pLHQoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCBpPVN5bWJvbCgidHlwZSIpLG89U3ltYm9sKCJidWJibGVzIiksZz1TeW1ib2woIm9yaWdpbmFsRXZlbnQiKSx2PVN5bWJvbCgiZGV0YWlsIik7Y2xhc3MgY3tjb25zdHJ1Y3RvcihoLHtidWJibGVzOkU9bnVsbH09e30pe2lmKHR5cGVvZiBoPT0ic3RyaW5nIj8odGhpc1tpXT1oLHRoaXNbb109ISFFKToodGhpc1tpXT1oLnR5cGUsdGhpc1tnXT1oLHRoaXNbb109RSE9bnVsbD8hIUU6ISFoLmJ1YmJsZXMsaC5kZXRhaWwmJih0aGlzW3ZdPWguZGV0YWlsKSksIXRoaXNbaV0pdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCBldmVudCB0eXBlLiIpO3RoaXMuY2FuY2VsQnViYmxlPSExfXNldE9yaWdpbmFsRXZlbnQoaCl7dGhpc1tnXT1ofWdldCBvcmlnaW5hbEV2ZW50KCl7cmV0dXJuIHRoaXNbZ119Z2V0IHR5cGUoKXtyZXR1cm4gdGhpc1tpXX1nZXQgYnViYmxlcygpe3JldHVybiB0aGlzW29dfWdldCBkZXRhaWwoKXtyZXR1cm4gdGhpc1t2XX1zdG9wUHJvcGFnYXRpb24oKXt0aGlzLmNhbmNlbEJ1YmJsZT0hMH19fSxmdW5jdGlvbihSLGUsdCl7dC5yKGUpLHQuZChlLCJwYXJzZUZpbHRlclN0cmluZyIsZnVuY3Rpb24oKXtyZXR1cm4gb30pLHQuZChlLCJhcHBseUZpbHRlcnMiLGZ1bmN0aW9uKCl7cmV0dXJuIGd9KTt2YXIgaT10KDcyKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gbyh2KXtpZih2PXYudHJpbSgpLCF2fHx2PT09Im5vbmUiKXJldHVybiBudWxsO2NvbnN0IGM9L14oPzoodXJsfGJsdXJ8YnJpZ2h0bmVzc3xjb250cmFzdHxkcm9wLXNoYWRvd3xncmF5c2NhbGV8aHVlLXJvdGF0ZXxpbnZlcnR8b3BhY2l0eXxzYXR1cmF0ZXxzZXBpYSlcKChbXigpXSooPzpcKC4qXCkpKlteKCldKilcKSkrJC9pLGY9di5tYXRjaCgvKD86KHVybHxibHVyfGJyaWdodG5lc3N8Y29udHJhc3R8ZHJvcC1zaGFkb3d8Z3JheXNjYWxlfGh1ZS1yb3RhdGV8aW52ZXJ0fG9wYWNpdHl8c2F0dXJhdGV8c2VwaWEpXCgoW14oKV0qKD86XCguKlwpKSpbXigpXSopXCkpKz8vaWcpLGg9W107cmV0dXJuIGYmJmYuZm9yRWFjaChFPT57Y29uc3QgbD1FLm1hdGNoKGMpO2lmKCFsKXRocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgZml0bGVyIHN0cmluZy4iKTtsZXRbLG0scF09bDttPW0udG9Mb3dlckNhc2UoKSxwPXAudHJpbSgpLm1hdGNoKC8oW14oICldK3woW14oICldK1woLipcKSkpKD89XHN8JCkvZykubWFwKChDLHgpPT57bGV0IGQ7cmV0dXJuIG09PT0idXJsInx8bT09PSJkcm9wLXNoYWRvdyImJng9PT0zP2Q9QzpkPU9iamVjdChpLnRvTnVtYmVyKShDKSwvJSQvLnRlc3QoQykmJihkLz0xMDApLGR9KSxoLnB1c2goe3R5cGU6bSxhcmdzOnB9KX0pLGh9ZnVuY3Rpb24gZyh2LGMpe3YuY2xlYXJGaWx0ZXIoKSxjJiZjLmZvckVhY2goKHt0eXBlOmYsYXJnczpofSk9PntsZXQgRT1mO0U9PT0iZHJvcC1zaGFkb3ciP0U9ImRyb3BTaGFkb3ciOkU9PT0iaHVlLXJvdGF0ZSImJihFPSJodWVSb3RhdGUiKSx2W0VdKC4uLmgpfSl9fSxmdW5jdGlvbihSLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBpfSksdCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIGkobyxnKXtpZighZylyZXR1cm47Y29uc3Qgdj1vLmdldExpc3RlbmVycygiYmVmb3JlcmVuZGVyIiksYz1vLmdldExpc3RlbmVycygiYWZ0ZXJyZW5kZXIiKTt2Lmxlbmd0aCYmIWcuYmVmb3JlUmVuZGVyP2cuYmVmb3JlUmVuZGVyPWY9PntvLmRpc3BhdGNoRXZlbnQoe3R5cGU6ImJlZm9yZXJlbmRlciIsZGV0YWlsOntjb250ZXh0OmZ9fSl9OnYubGVuZ3RofHwoZy5iZWZvcmVSZW5kZXI9bnVsbCksYy5sZW5ndGgmJiFnLmFmdGVyUmVuZGVyP2cuYWZ0ZXJSZW5kZXI9Zj0+e28uZGlzcGF0Y2hFdmVudCh7dHlwZToiYWZ0ZXJyZW5kZXIiLGRldGFpbDp7Y29udGV4dDpmfX0pfTpjLmxlbmd0aHx8KGcuYWZ0ZXJSZW5kZXI9bnVsbCl9fSxmdW5jdGlvbihSLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBofSk7dmFyIGk9dCgxMiksbz10KDIxOCksZz10KDcwKSx2PXQoMjEzKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3QgYz1TeW1ib2woImFtb3VudCIpLGY9U3ltYm9sKCJtZXNoQ2xvdWQiKTtjbGFzcyBoIGV4dGVuZHMgZy5kZWZhdWx0e2NvbnN0cnVjdG9yKGwsbT0xKXtzdXBlcigpLHRoaXMubWVzaE5vZGU9bCxsLmNvbm5lY3QodGhpcyksdGhpc1tjXT1tLHRoaXNbZl09bnVsbH1nZXQgbWVzaENsb3VkKCl7Y29uc3QgbD10aGlzLm1lc2hOb2RlLG09dGhpc1tjXTtyZXR1cm4hdGhpc1tmXSYmbC5tZXNoJiYodGhpc1tmXT1uZXcgaS5NZXNoQ2xvdWQobC5tZXNoLG0pKSx0aGlzW2ZdfWdldCBpc1Zpc2libGUoKXtyZXR1cm4hIXRoaXMubWVzaE5vZGUmJnRoaXMubWVzaE5vZGUuaXNWaXNpYmxlfWdldCBhbW91bnQoKXtyZXR1cm4gdGhpc1tjXX1zZXQgYW1vdW50KGwpe3RoaXNbY109bCx0aGlzW2ZdJiYodGhpc1tmXS5hbW91bnQ9bCl9YnJpZ2h0bmVzcyhsLG0pe3RoaXMubWVzaENsb3VkJiYodGhpcy5tZXNoQ2xvdWQuYnJpZ2h0bmVzcyhsLG0pLHRoaXMuZm9yY2VVcGRhdGUoKSl9Y29udHJhc3QobCxtKXt0aGlzLm1lc2hDbG91ZCYmKHRoaXMubWVzaENsb3VkLmNvbnRyYXN0KGwsbSksdGhpcy5mb3JjZVVwZGF0ZSgpKX1kZWxldGUobCl7dGhpcy5tZXNoQ2xvdWQmJih0aGlzLm1lc2hDbG91ZC5kZWxldGUobCksdGhpc1tjXS0tLHRoaXMuZm9yY2VVcGRhdGUoKSl9ZHJhdyhsPVtdKXtpZihzdXBlci5kcmF3KGwpLHRoaXMubWVzaENsb3VkKXtpZih0aGlzLnByb2dyYW0pe3RoaXMubWVzaENsb3VkLnNldFByb2dyYW0odGhpcy5wcm9ncmFtKTtjb25zdCBtPXRoaXMuc2hhZGVyQXR0cnM7bSYmT2JqZWN0LmVudHJpZXMobSkuZm9yRWFjaCgoW0MseF0pPT57dGhpcy5tZXNoQ2xvdWQubWVzaC5zZXRBdHRyaWJ1dGUoQyx4KX0pO2NvbnN0IHA9dGhpcy51bmlmb3JtcztpZih0aGlzLnVuaWZvcm1zKXtjb25zdCBDPXt9O09iamVjdC5lbnRyaWVzKHApLmZvckVhY2goKFt4LGRdKT0+e3R5cGVvZiBkPT0iZnVuY3Rpb24iJiYoZD1kKHRoaXMseCkpLENbeF09ZH0pLHRoaXMubWVzaENsb3VkLm1lc2guc2V0VW5pZm9ybXMoQyl9fXRoaXMubWVzaE5vZGUudGV4dHVyZUltYWdlJiZPYmplY3Qoby5kcmF3VGV4dHVyZSkodGhpcy5tZXNoTm9kZSx0aGlzLm1lc2hOb2RlLm1lc2gpLGwucHVzaCh0aGlzLm1lc2hDbG91ZCl9cmV0dXJuIGx9Z2V0VHJhbnNmb3JtKGwpe2lmKHRoaXMubWVzaENsb3VkKXJldHVybiB0aGlzLm1lc2hDbG91ZC5nZXRUcmFuc2Zvcm0obCl9Z3JheXNjYWxlKGwsbSl7dGhpcy5tZXNoQ2xvdWQmJih0aGlzLm1lc2hDbG91ZC5ncmF5c2NhbGUobCxtKSx0aGlzLmZvcmNlVXBkYXRlKCkpfWh1ZVJvdGF0ZShsLG0pe3RoaXMubWVzaENsb3VkJiYodGhpcy5tZXNoQ2xvdWQuaHVlUm90YXRlKGwsbSksdGhpcy5mb3JjZVVwZGF0ZSgpKX1pbnZlcnQobCxtKXt0aGlzLm1lc2hDbG91ZCYmKHRoaXMubWVzaENsb3VkLmludmVydChsLG0pLHRoaXMuZm9yY2VVcGRhdGUoKSl9aXNQb2ludENvbGxpc2lvbihsLG0pe2lmKCF0aGlzLm1lc2hDbG91ZClyZXR1cm4hMTtjb25zdCBwPXRoaXMuYXR0cmlidXRlcy5wb2ludGVyRXZlbnRzO2lmKHA9PT0ibm9uZSJ8fHAhPT0iYWxsIiYmIXRoaXMuaXNWaXNpYmxlKXJldHVybiExO2xldCBDPSJib3RoIjtwPT09InZpc2libGVGaWxsIiYmKEM9ImZpbGwiKSxwPT09InZpc2libGVTdHJva2UiJiYoQz0ic3Ryb2tlIik7Zm9yKGxldCB4PTA7eDx0aGlzW2NdO3grKylpZighdGhpcy5tZXNoQ2xvdWQuaXNQb2ludENvbGxpc2lvbih4LFtsLG1dLEMpKXJldHVybiExO3JldHVybiEwfXNldE9wYWNpdHkobCxtKXt0aGlzLm1lc2hDbG91ZCYmKHRoaXMubWVzaENsb3VkLm9wYWNpdHkobCxtKSx0aGlzLmZvcmNlVXBkYXRlKCkpfXJvdGF0ZShsLG0sW3AsQ109WzAsMF0pe2NvbnN0IHg9TWF0aC5QSSptLzE4MDtpZih0aGlzLm1lc2hDbG91ZCl7Y29uc3R7eDpkLHl9PXRoaXMubWVzaE5vZGUuYXR0cmlidXRlczt0aGlzLm1lc2hDbG91ZC5yb3RhdGUobCx4LFtwK2QsQyt5XSksdGhpcy5mb3JjZVVwZGF0ZSgpfX1zYXR1cmF0ZShsLG0pe3RoaXMubWVzaENsb3VkJiYodGhpcy5tZXNoQ2xvdWQuc2F0dXJhdGUobCxtKSx0aGlzLmZvcmNlVXBkYXRlKCkpfXNjYWxlKGwsW20scD1tXSxbQyx4XT1bMCwwXSl7aWYodGhpcy5tZXNoQ2xvdWQpe2NvbnN0e3g6ZCx5fT10aGlzLm1lc2hOb2RlLmF0dHJpYnV0ZXMscj0xZS01O01hdGguYWJzKG0pPHImJihtPTEvbT4wP3I6LXIpLE1hdGguYWJzKHApPHImJihwPTEvcD4wP3I6LXIpLHRoaXMubWVzaENsb3VkLnNjYWxlKGwsW20scF0sW0MrZCx4K3ldKSx0aGlzLmZvcmNlVXBkYXRlKCl9fXNldENvbG9yVHJhbnNmb3JtKGwsbSl7dGhpcy5tZXNoQ2xvdWQmJih0aGlzLm1lc2hDbG91ZC5zZXRDb2xvclRyYW5zZm9ybShsLG0pLHRoaXMuZm9yY2VVcGRhdGUoKSl9c2V0RmlsbENvbG9yKGwsbSl7dGhpcy5tZXNoQ2xvdWQmJihBcnJheS5pc0FycmF5KG0pJiYobT1bLi4ubV0sbVswXS89MjU1LG1bMV0vPTI1NSxtWzJdLz0yNTUpLHRoaXMubWVzaENsb3VkLnNldEZpbGxDb2xvcihsLG0pLHRoaXMuZm9yY2VVcGRhdGUoKSl9c2VwaWEobCxtKXt0aGlzLm1lc2hDbG91ZCYmKHRoaXMubWVzaENsb3VkLnNlcGlhKGwsbSksdGhpcy5mb3JjZVVwZGF0ZSgpKX1zZXRSZXNvbHV0aW9uKHt3aWR0aDpsLGhlaWdodDptfSl7c3VwZXIuc2V0UmVzb2x1dGlvbih7d2lkdGg6bCxoZWlnaHQ6bX0pLHRoaXMubWVzaE5vZGUuc2V0UmVzb2x1dGlvbih7d2lkdGg6bCxoZWlnaHQ6bX0pfXNldFN0cm9rZUNvbG9yKGwsbSl7dGhpcy5tZXNoQ2xvdWQmJihBcnJheS5pc0FycmF5KG0pJiYobT1bLi4ubV0sbVswXS89MjU1LG1bMV0vPTI1NSxtWzJdLz0yNTUpLHRoaXMubWVzaENsb3VkLnNldFN0cm9rZUNvbG9yKGwsbSksdGhpcy5mb3JjZVVwZGF0ZSgpKX1zZXRUcmFuc2Zvcm0obCxtKXt0aGlzLm1lc2hDbG91ZCYmKHRoaXMubWVzaENsb3VkLnNldFRyYW5zZm9ybShsLG0pLHRoaXMuZm9yY2VVcGRhdGUoKSl9c2tldyhsLFttLHA9bV0sW0MseF09WzAsMF0pe2lmKHRoaXMubWVzaENsb3VkKXtjb25zdHt4OmQseX09dGhpcy5tZXNoTm9kZS5hdHRyaWJ1dGVzO3RoaXMubWVzaENsb3VkLnNrZXcobCxbbSxwXSxbQytkLHgreV0pLHRoaXMuZm9yY2VVcGRhdGUoKX19dHJhbnNmb3JtKGwsbSl7dGhpcy5tZXNoQ2xvdWQmJih0aGlzLm1lc2hDbG91ZC50cmFuc2Zvcm0obCxtKSx0aGlzLmZvcmNlVXBkYXRlKCkpfXRyYW5zZm9ybUNvbG9yKGwsbSl7dGhpcy5tZXNoQ2xvdWQmJih0aGlzLm1lc2hDbG91ZC50cmFuc2Zvcm1Db2xvcihsLG0pLHRoaXMuZm9yY2VVcGRhdGUoKSl9dHJhbnNsYXRlKGwsW20scF0pe3RoaXMubWVzaENsb3VkJiYodGhpcy5tZXNoQ2xvdWQudHJhbnNsYXRlKGwsW20scF0pLHRoaXMuZm9yY2VVcGRhdGUoKSl9dXBkYXRlTWVzaCgpe3RoaXNbZl0mJih0aGlzW2ZdLm1lc2g9dGhpcy5tZXNoTm9kZS5tZXNoLHRoaXMuZm9yY2VVcGRhdGUoKSl9fXYuZGVmYXVsdC5yZWdpc3Rlck5vZGUoaCwiY2xvdWQiKX0sZnVuY3Rpb24oUixlLHQpe3QucihlKSx0LmQoZSwibG9hZFRleHR1cmUiLGZ1bmN0aW9uKCl7cmV0dXJuIHZ9KSx0LmQoZSwiYXBwbHlUZXh0dXJlIixmdW5jdGlvbigpe3JldHVybiBjfSksdC5kKGUsImNyZWF0ZVRleHR1cmUiLGZ1bmN0aW9uKCl7cmV0dXJuIGh9KSx0LmQoZSwiZGVsZXRlVGV4dHVyZSIsZnVuY3Rpb24oKXtyZXR1cm4gRX0pLHQuZChlLCJkcmF3VGV4dHVyZSIsZnVuY3Rpb24oKXtyZXR1cm4gbX0pLHQuZChlLCJsb2FkRnJhbWVzIixmdW5jdGlvbigpe3JldHVybiBwfSk7dmFyIGk9dCgxMiksbz10KDcyKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3QgZz17fTtmdW5jdGlvbiB2KEMseCl7aWYoZ1tDXSlyZXR1cm4gZ1tDXTtjb25zdCBkPWkuRU5WLmxvYWRJbWFnZShDLHthbGlhczp4LHVzZUltYWdlQml0bWFwOiExfSk7cmV0dXJuIGQ/P0N9YXN5bmMgZnVuY3Rpb24gYyhDLHgsZCl7bGV0IHk9eDtpZih0eXBlb2YgeD09InN0cmluZyImJih5PXYoeCkpLHkmJnR5cGVvZiB5LnRoZW49PSJmdW5jdGlvbiImJih5PWF3YWl0IHkpLHg9PT1DLmF0dHJpYnV0ZXMudGV4dHVyZSl7eSYmeS5pbWFnZSYmKHkuc291cmNlUmVjdCYmKEMuYXR0cmlidXRlcy5zb3VyY2VSZWN0PXkuc291cmNlUmVjdCksQy50ZXh0dXJlSW1hZ2VSb3RhdGVkPSEheS5yb3RhdGVkLHk9eS5pbWFnZSk7Y29uc3R7d2lkdGg6cixoZWlnaHQ6cyx0ZXh0dXJlUmVjdDpufT1DLmF0dHJpYnV0ZXMsYT1DLnRleHR1cmVJbWFnZTtDLnRleHR1cmVJbWFnZT15LGQmJmEhPT15JiYhbiYmKHI9PW51bGx8fHM9PW51bGwpJiZDLnVwZGF0ZUNvbnRvdXJzKCksQy5mb3JjZVVwZGF0ZSgpfXJldHVybiB5fWNvbnN0IGY9U3ltYm9sKCJ0ZXh0dXJlTWFwIik7ZnVuY3Rpb24gaChDLHgpe2lmKHhbZl09eFtmXXx8bmV3IE1hcCx4W2ZdLmhhcyhDKSlyZXR1cm4geFtmXS5nZXQoQyk7Y29uc3QgZD14LmNyZWF0ZVRleHR1cmUoQyk7cmV0dXJuIS9eYmxvYjovLnRlc3QoQy5zcmMpJiZ0eXBlb2YgQy5nZXRDb250ZXh0IT0iZnVuY3Rpb24iJiZ4W2ZdLnNldChDLGQpLGR9ZnVuY3Rpb24gRShDLHgpe2lmKHhbZl0mJnhbZl0uaGFzKEMpKXtjb25zdCBkPXhbZl0uZ2V0KEMpO3JldHVybiB4LmRlbGV0ZVRleHR1cmUoZCkseFtmXS5kZWxldGUoQyksITB9cmV0dXJuITF9Y29uc3QgbD1TeW1ib2woInRleHR1cmVDb250ZXh0Iik7ZnVuY3Rpb24gbShDLHgpe2NvbnN0IGQ9Qy50ZXh0dXJlSW1hZ2UgaW5zdGFuY2VvZiBTdHJpbmc/U3RyaW5nKEMudGV4dHVyZUltYWdlKTpDLnRleHR1cmVJbWFnZSx5PUMudGV4dHVyZUltYWdlUm90YXRlZCxyPXgudGV4dHVyZSxzPUMucmVuZGVyZXI7aWYoZCl7Y29uc3Qgbj1DLm9yaWdpbmFsQ29udGVudFJlY3Q7bGV0IGE9Qy5hdHRyaWJ1dGVzLnRleHR1cmVSZWN0O2NvbnN0IE89Qy5hdHRyaWJ1dGVzLnRleHR1cmVSZXBlYXQsQT1DLmF0dHJpYnV0ZXMuc291cmNlUmVjdDtpZighcnx8Q1tsXSYmQ1tsXSE9PXN8fHIuaW1hZ2UhPT1kfHxyLm9wdGlvbnMucmVwZWF0IT09T3x8IU9iamVjdChvLmNvbXBhcmVWYWx1ZSkoci5vcHRpb25zLnJlY3QsYSl8fCFPYmplY3Qoby5jb21wYXJlVmFsdWUpKHIub3B0aW9ucy5zcmNSZWN0LEEpKXtjb25zdCBiPWgoZCxzKTthPyhhWzBdKz1uWzBdLGFbMV0rPW5bMV0pOmE9bjtsZXQgST1udWxsO3ImJiFzW2ZdLmhhcyhyLmltYWdlKSYmKCFyLm9wdGlvbnN8fCFyLm9wdGlvbnMuaGlkZGVuKSYmKEk9eC51bmlmb3Jtcy51X3RleFNhbXBsZXIpLHguc2V0VGV4dHVyZShiLHtyZWN0OmEscmVwZWF0Ok8sc3JjUmVjdDpBLHJvdGF0ZWQ6eX0pLEkmJkkuZGVsZXRlJiZJLmRlbGV0ZSgpLENbbF09c319ZWxzZSBpZihyKXtsZXQgbj1udWxsOyFzW2ZdLmhhcyhyLmltYWdlKSYmKCFyLm9wdGlvbnN8fCFyLm9wdGlvbnMuaGlkZGVuKSYmKG49eC51bmlmb3Jtcy51X3RleFNhbXBsZXIpLHguc2V0VGV4dHVyZShudWxsKSxuJiZuLmRlbGV0ZSYmbi5kZWxldGUoKX19YXN5bmMgZnVuY3Rpb24gcChDLHgpe3R5cGVvZiB4PT0ic3RyaW5nIiYmKHg9YXdhaXQoYXdhaXQgZmV0Y2goeCx7bWV0aG9kOiJHRVQiLG1vZGU6ImNvcnMiLGNhY2hlOiJkZWZhdWx0In0pKS5qc29uKCkpO2NvbnN0IGQ9YXdhaXQgdihDKSx5PXguZnJhbWVzO3JldHVybiBPYmplY3QuZW50cmllcyh5KS5mb3JFYWNoKChbcixzXSk9Pntjb25zdHt4Om4seTphLHc6TyxoOkF9PXMuZnJhbWU7bGV0IGI9W24sYSxPLEFdO2NvbnN0IEk9cy5yb3RhdGVkO0kmJihiPVtiWzBdLGJbMV0sYlszXSxiWzJdXSksZ1tyXT17aW1hZ2U6ZCxzb3VyY2VSZWN0OmIscm90YXRlZDpJfX0pLGR9fSxmdW5jdGlvbihSLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBwfSk7dmFyIGk9dCgxKSxvPXQoMTIpLGc9dCg3MCksdj10KDIyMCksYz10KDIyMSksZj10KDIyMiksaD10KDIxMyksRT10KDIyMyk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIGwoQyx4LGQpe3JldHVybiB4IGluIEM/T2JqZWN0LmRlZmluZVByb3BlcnR5KEMseCx7dmFsdWU6ZCxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOkNbeF09ZCxDfWNvbnN0IG09U3ltYm9sKCJtZXNoIik7Y2xhc3MgcCBleHRlbmRzIGcuZGVmYXVsdHtjb25zdHJ1Y3Rvcih4PXt9KXtzdXBlcih4KX1nZXQgYm9yZGVyU2l6ZSgpe2NvbnN0e3BhZGRpbmdUb3A6eCxwYWRkaW5nUmlnaHQ6ZCxwYWRkaW5nQm90dG9tOnkscGFkZGluZ0xlZnQ6cixib3JkZXJXaWR0aDpzfT10aGlzLmF0dHJpYnV0ZXMsW24sYV09dGhpcy5jb250ZW50U2l6ZTtyZXR1cm5bcituK2Qrcyx4K2EreStzXX1nZXQgY2xpZW50U2l6ZSgpe2NvbnN0e3BhZGRpbmdUb3A6eCxwYWRkaW5nUmlnaHQ6ZCxwYWRkaW5nQm90dG9tOnkscGFkZGluZ0xlZnQ6cn09dGhpcy5hdHRyaWJ1dGVzLFtzLG5dPXRoaXMuY29udGVudFNpemU7cmV0dXJuW3IrcytkLHgrbit5XX1nZXQgY29udGVudFNpemUoKXtsZXR7d2lkdGg6eCxoZWlnaHQ6ZCxib3hTaXppbmc6eSxwYWRkaW5nVG9wOnIscGFkZGluZ1JpZ2h0OnMscGFkZGluZ0JvdHRvbTpuLHBhZGRpbmdMZWZ0OmF9PXRoaXMuYXR0cmlidXRlcztpZih4PXh8fDAsZD1kfHwwLHk9PT0iYm9yZGVyLWJveCIpe2NvbnN0IE89Mip0aGlzLmF0dHJpYnV0ZXMuYm9yZGVyV2lkdGg7eC09TytzK2EsZC09TytyK24seD1NYXRoLm1heCgwLHgpLGQ9TWF0aC5tYXgoMCxkKX1yZXR1cm5beCxkXX1nZXQgaGFzQm9yZGVyKCl7cmV0dXJuIHRoaXMuYXR0cmlidXRlcy5ib3JkZXJXaWR0aD4wfWdldCBpc1Zpc2libGUoKXtjb25zdFt4LGRdPXRoaXMuYm9yZGVyU2l6ZTtyZXR1cm4geD4wJiZkPjB9Z2V0IG1lc2goKXtpZih0aGlzLmF0dHJpYnV0ZXMuZGlzcGxheT09PSJub25lIilyZXR1cm4gbnVsbDtjb25zdCB4PXRoaXMuY2xpZW50Qm94O2lmKHgpe2xldCBkPXRoaXNbbV07aWYoZClkLmJveCE9PXgmJihkLmNvbnRvdXJzPXguY29udG91cnMsZC5ib3g9eCk7ZWxzZXtkPW5ldyBvLk1lc2gyRCh4KSxkLmJveD14O2NvbnN0IHI9dGhpcy5hdHRyaWJ1dGVzLmJnY29sb3I7aWYoT2JqZWN0KGMuc2V0RmlsbENvbG9yKShkLHtjb2xvcjpyfSksdGhpcy5oYXNCb3JkZXIpe2NvbnN0e2JvcmRlckNvbG9yOm4sYm9yZGVyV2lkdGg6YSxib3JkZXJEYXNoOk8sYm9yZGVyRGFzaE9mZnNldDpBfT10aGlzLmF0dHJpYnV0ZXM7T2JqZWN0KGMuc2V0U3Ryb2tlQ29sb3IpKGQse2NvbG9yOm4sbGluZVdpZHRoOmEsbGluZURhc2g6TyxsaW5lRGFzaE9mZnNldDpBfSl9dGhpc1ttXT1kO2NvbnN0IHM9dGhpcy5hdHRyaWJ1dGVzLmNsaXBQYXRoO3MmJnRoaXNbbV0uc2V0Q2xpcFBhdGgocyl9Y29uc3QgeT10aGlzLm9wYWNpdHk7cmV0dXJuIGQuZ2V0T3BhY2l0eSgpIT09eSYmZC5zZXRPcGFjaXR5KHkpLGQuc2V0VHJhbnNmb3JtKC4uLnRoaXMucmVuZGVyTWF0cml4KSxkfXJldHVybiBudWxsfWdldCBvZmZzZXRTaXplKCl7Y29uc3R7cGFkZGluZ1RvcDp4LHBhZGRpbmdSaWdodDpkLHBhZGRpbmdCb3R0b206eSxwYWRkaW5nTGVmdDpyLGJvcmRlcldpZHRoOnN9PXRoaXMuYXR0cmlidXRlcyxbbixhXT10aGlzLmNvbnRlbnRTaXplLE89MipzO3JldHVybltyK24rZCtPLHgrYSt5K09dfWdldCBvcmlnaW5hbENsaWVudFJlY3QoKXtpZih0aGlzLm1lc2gpe2NvbnN0IHg9dGhpcy5tZXNoLmJvdW5kaW5nQm94O3JldHVyblt4WzBdWzBdLHhbMF1bMV0seFsxXVswXS14WzBdWzBdLHhbMV1bMV0teFswXVsxXV19cmV0dXJuWzAsMCwwLDBdfWdldCBvcmlnaW5hbENvbnRlbnRSZWN0KCl7Y29uc3RbeCxkLHkscl09dGhpcy5vcmlnaW5hbENsaWVudFJlY3Qscz10aGlzLmF0dHJpYnV0ZXMucGFkZGluZztyZXR1cm5beCtzWzBdLGQrc1sxXSx5LXNbMF0tc1syXSxyLXNbMV0tc1szXV19Z2V0Qm91bmRpbmdDbGllbnRSZWN0KCl7bGV0IHg9dGhpcy5yZW5kZXJNYXRyaXg7dGhpcy5sYXllciYmdGhpcy5sYXllci5sYXllclRyYW5zZm9ybUludmVydCYmKHg9aS5tYXQyZC5tdWx0aXBseShBcnJheS5vZigwLDAsMCwwLDAsMCksdGhpcy5sYXllci50cmFuc2Zvcm1NYXRyaXgseCkpO2xldCBkPW51bGw7aWYodGhpcy5tZXNoKXtkPVsuLi50aGlzLm1lc2guYm91bmRpbmdCb3hdO2NvbnN0IHk9dGhpcy5hdHRyaWJ1dGVzLmJvcmRlcldpZHRoO3kmJihkWzBdPVtkWzBdWzBdLXksZFswXVsxXS15XSxkWzFdPVtkWzFdWzBdK3ksZFsxXVsxXSt5XSl9cmV0dXJuIE9iamVjdChFLmRlZmF1bHQpKGQseCl9b25Qcm9wZXJ0eUNoYW5nZSh4LGQseSl7aWYoc3VwZXIub25Qcm9wZXJ0eUNoYW5nZSh4LGQseSksKHg9PT0iYW5jaG9yWCJ8fHg9PT0iYW5jaG9yWSJ8fHg9PT0iYm94U2l6aW5nInx8eD09PSJ3aWR0aCJ8fHg9PT0iaGVpZ2h0Inx8eD09PSJib3JkZXJXaWR0aCJ8fHg9PT0icGFkZGluZ0xlZnQifHx4PT09InBhZGRpbmdSaWdodCJ8fHg9PT0icGFkZGluZ1RvcCJ8fHg9PT0icGFkZGluZ0JvdHRvbSJ8fC9eYm9yZGVyKFRvcExlZnR8VG9wUmlnaHR8Qm90dG9tUmlnaHR8Qm90dG9tTGVmdClSYWRpdXMkLy50ZXN0KHgpKSYmdGhpcy51cGRhdGVDb250b3VycygpLHRoaXNbbV0mJng9PT0iY2xpcFBhdGgiJiZ0aGlzW21dLnNldENsaXBQYXRoKGQpLHRoaXNbbV0mJng9PT0iYmdjb2xvciImJk9iamVjdChjLnNldEZpbGxDb2xvcikodGhpc1ttXSx7Y29sb3I6ZH0pLHRoaXNbbV0mJih4PT09ImJvcmRlckNvbG9yInx8eD09PSJib3JkZXJXaWR0aCJ8fHg9PT0iYm9yZGVyRGFzaCJ8fHg9PT0iYm9yZGVyRGFzaE9mZnNldCIpKXtjb25zdHtib3JkZXJDb2xvcjpyLGJvcmRlcldpZHRoOnMsYm9yZGVyRGFzaDpuLGJvcmRlckRhc2hPZmZzZXQ6YX09dGhpcy5hdHRyaWJ1dGVzO09iamVjdChjLnNldFN0cm9rZUNvbG9yKSh0aGlzW21dLHtjb2xvcjpyLGxpbmVXaWR0aDpzLGxpbmVEYXNoOnM/bjowLGxpbmVEYXNoT2Zmc2V0OmF9KX19dXBkYXRlQ29udG91cnMoKXtjb25zdHthbmNob3JYOngsYW5jaG9yWTpkLGJvcmRlcldpZHRoOnksYm9yZGVyUmFkaXVzOnJ9PXRoaXMuYXR0cmlidXRlcyxbcyxuXT10aGlzLmJvcmRlclNpemUsYT10aGlzLm9mZnNldFNpemUsTz0uNSp5LEE9LXgqYVswXStPLGI9LWQqYVsxXStPO3RoaXMuY2xpZW50Qm94PW5ldyBvLkZpZ3VyZTJELE9iamVjdChmLmNyZWF0ZVJhZGl1c0JveCkodGhpcy5jbGllbnRCb3gsW0EsYixzLG5dLHIpfX1sKHAsIkF0dHIiLHYuZGVmYXVsdCksaC5kZWZhdWx0LnJlZ2lzdGVyTm9kZShwLCJibG9jayIpfSxmdW5jdGlvbihSLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBFfSk7dmFyIGk9dCg3MSksbz10KDcyKSxnPXQoMjIxKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3Qgdj1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGUiKSxjPVN5bWJvbC5mb3IoInNwcml0ZWpzX2dldEF0dHJpYnV0ZSIpLGY9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlRGVmYXVsdCIpLGg9U3ltYm9sLmZvcigic3ByaXRlanNfZGVjbGFyZUFsaWFzIik7Y2xhc3MgRSBleHRlbmRzIGkuZGVmYXVsdHtjb25zdHJ1Y3RvcihtKXtzdXBlcihtKSx0aGlzW2ZdKHthbmNob3JYOjAsYW5jaG9yWTowLHdpZHRoOnZvaWQgMCxoZWlnaHQ6dm9pZCAwLGJvcmRlcldpZHRoOjAsYm9yZGVyQ29sb3I6InJnYmEoMCwwLDAsMSkiLGJvcmRlckRhc2g6dm9pZCAwLGJvcmRlckRhc2hPZmZzZXQ6MCxib3JkZXJUb3BMZWZ0UmFkaXVzOlswLDBdLGJvcmRlclRvcFJpZ2h0UmFkaXVzOlswLDBdLGJvcmRlckJvdHRvbVJpZ2h0UmFkaXVzOlswLDBdLGJvcmRlckJvdHRvbUxlZnRSYWRpdXM6WzAsMF0sYmdjb2xvcjoicmdiYSgwLDAsMCwwKSIscGFkZGluZ1RvcDowLHBhZGRpbmdSaWdodDowLHBhZGRpbmdCb3R0b206MCxwYWRkaW5nTGVmdDowLGJveFNpemluZzoiY29udGVudC1ib3giLGNsaXBQYXRoOnZvaWQgMH0pLHRoaXNbaF0oImFuY2hvciIsInNpemUiLCJib3JkZXIiLCJib3JkZXJSYWRpdXMiLCJwYWRkaW5nIil9Z2V0IGFuY2hvclgoKXtyZXR1cm4gdGhpc1tjXSgiYW5jaG9yWCIpfXNldCBhbmNob3JYKG0pe3RoaXNbdl0oImFuY2hvclgiLE9iamVjdChvLnRvTnVtYmVyKShtKSl9Z2V0IGFuY2hvclkoKXtyZXR1cm4gdGhpc1tjXSgiYW5jaG9yWSIpfXNldCBhbmNob3JZKG0pe3RoaXNbdl0oImFuY2hvclkiLE9iamVjdChvLnRvTnVtYmVyKShtKSl9Z2V0IGFuY2hvcigpe3JldHVyblt0aGlzLmFuY2hvclgsdGhpcy5hbmNob3JZXX1zZXQgYW5jaG9yKG0pe209T2JqZWN0KG8udG9BcnJheSkobSksQXJyYXkuaXNBcnJheShtKXx8KG09W20sbV0pLHRoaXMuYW5jaG9yWD1tWzBdLHRoaXMuYW5jaG9yWT1tWzFdfWdldCB3aWR0aCgpe3JldHVybiB0aGlzW2NdKCJ3aWR0aCIpfXNldCB3aWR0aChtKXt0aGlzW3ZdKCJ3aWR0aCIsT2JqZWN0KG8udG9OdW1iZXIpKG0pKX1nZXQgaGVpZ2h0KCl7cmV0dXJuIHRoaXNbY10oImhlaWdodCIpfXNldCBoZWlnaHQobSl7dGhpc1t2XSgiaGVpZ2h0IixPYmplY3Qoby50b051bWJlcikobSkpfWdldCBzaXplKCl7cmV0dXJuW3RoaXMud2lkdGgsdGhpcy5oZWlnaHRdfXNldCBzaXplKG0pe209T2JqZWN0KG8udG9BcnJheSkobSksQXJyYXkuaXNBcnJheShtKXx8KG09W20sbV0pLHRoaXMud2lkdGg9bVswXSx0aGlzLmhlaWdodD1tWzFdfWdldCBib3JkZXJXaWR0aCgpe3JldHVybiB0aGlzW2NdKCJib3JkZXJXaWR0aCIpfXNldCBib3JkZXJXaWR0aChtKXt0aGlzW3ZdKCJib3JkZXJXaWR0aCIsT2JqZWN0KG8udG9OdW1iZXIpKG0pKX1nZXQgYm9yZGVyQ29sb3IoKXtyZXR1cm4gdGhpc1tjXSgiYm9yZGVyQ29sb3IiKX1zZXQgYm9yZGVyQ29sb3IobSl7dGhpc1t2XSgiYm9yZGVyQ29sb3IiLE9iamVjdChnLnBhcnNlQ29sb3IpKG0pKX1nZXQgYm9yZGVyKCl7cmV0dXJuW3RoaXMuYm9yZGVyV2lkdGgsdGhpcy5ib3JkZXJDb2xvcl19c2V0IGJvcmRlcihtKXttPU9iamVjdChvLnRvQXJyYXkpKG0pLEFycmF5LmlzQXJyYXkobSl8fChtPVttXSksdGhpcy5ib3JkZXJXaWR0aD1tWzBdLG1bMV0hPW51bGwmJih0aGlzLmJvcmRlckNvbG9yPW1bMV0pfWdldCBib3JkZXJEYXNoKCl7cmV0dXJuIHRoaXNbY10oImJvcmRlckRhc2giKX1zZXQgYm9yZGVyRGFzaChtKXttPU9iamVjdChvLnRvQXJyYXkpKG0sITApLG0hPW51bGwmJiFBcnJheS5pc0FycmF5KG0pJiYobT1bbV0pLHRoaXNbdl0oImJvcmRlckRhc2giLG0/bS5tYXAoby50b051bWJlcik6bnVsbCl9Z2V0IGJvcmRlckRhc2hPZmZzZXQoKXtyZXR1cm4gdGhpc1tjXSgiYm9yZGVyRGFzaE9mZnNldCIpfXNldCBib3JkZXJEYXNoT2Zmc2V0KG0pe3RoaXNbdl0oImJvcmRlckRhc2hPZmZzZXQiLE9iamVjdChvLnRvTnVtYmVyKShtKSl9Z2V0IGJvcmRlclRvcExlZnRSYWRpdXMoKXtyZXR1cm4gdGhpc1tjXSgiYm9yZGVyVG9wTGVmdFJhZGl1cyIpfXNldCBib3JkZXJUb3BMZWZ0UmFkaXVzKG0pe209T2JqZWN0KG8udG9BcnJheSkobSwhMCksQXJyYXkuaXNBcnJheShtKXx8KG09W20sbV0pLHRoaXNbdl0oImJvcmRlclRvcExlZnRSYWRpdXMiLG0ubWFwKG8udG9OdW1iZXIpKX1nZXQgYm9yZGVyVG9wUmlnaHRSYWRpdXMoKXtyZXR1cm4gdGhpc1tjXSgiYm9yZGVyVG9wUmlnaHRSYWRpdXMiKX1zZXQgYm9yZGVyVG9wUmlnaHRSYWRpdXMobSl7bT1PYmplY3Qoby50b0FycmF5KShtLCEwKSxBcnJheS5pc0FycmF5KG0pfHwobT1bbSxtXSksdGhpc1t2XSgiYm9yZGVyVG9wUmlnaHRSYWRpdXMiLG0ubWFwKG8udG9OdW1iZXIpKX1nZXQgYm9yZGVyQm90dG9tUmlnaHRSYWRpdXMoKXtyZXR1cm4gdGhpc1tjXSgiYm9yZGVyQm90dG9tUmlnaHRSYWRpdXMiKX1zZXQgYm9yZGVyQm90dG9tUmlnaHRSYWRpdXMobSl7bT1PYmplY3Qoby50b0FycmF5KShtLCEwKSxBcnJheS5pc0FycmF5KG0pfHwobT1bbSxtXSksdGhpc1t2XSgiYm9yZGVyQm90dG9tUmlnaHRSYWRpdXMiLG0ubWFwKG8udG9OdW1iZXIpKX1nZXQgYm9yZGVyQm90dG9tTGVmdFJhZGl1cygpe3JldHVybiB0aGlzW2NdKCJib3JkZXJCb3R0b21MZWZ0UmFkaXVzIil9c2V0IGJvcmRlckJvdHRvbUxlZnRSYWRpdXMobSl7bT1PYmplY3Qoby50b0FycmF5KShtLCEwKSxBcnJheS5pc0FycmF5KG0pfHwobT1bbSxtXSksdGhpc1t2XSgiYm9yZGVyQm90dG9tTGVmdFJhZGl1cyIsbS5tYXAoby50b051bWJlcikpfWdldCBib3JkZXJSYWRpdXMoKXtyZXR1cm5bLi4udGhpcy5ib3JkZXJUb3BMZWZ0UmFkaXVzLC4uLnRoaXMuYm9yZGVyVG9wUmlnaHRSYWRpdXMsLi4udGhpcy5ib3JkZXJCb3R0b21SaWdodFJhZGl1cywuLi50aGlzLmJvcmRlckJvdHRvbUxlZnRSYWRpdXNdfXNldCBib3JkZXJSYWRpdXMobSl7aWYobT1PYmplY3Qoby50b0FycmF5KShtKSwhQXJyYXkuaXNBcnJheShtKSltPUFycmF5KDgpLmZpbGwobSk7ZWxzZSBpZihtLmxlbmd0aD09PTIpbT1bbVswXSxtWzFdLG1bMF0sbVsxXSxtWzBdLG1bMV0sbVswXSxtWzFdXTtlbHNlIGlmKG0ubGVuZ3RoPT09NCltPVttWzBdLG1bMV0sbVsyXSxtWzNdLG1bMF0sbVsxXSxtWzJdLG1bM11dO2Vsc2UgaWYobS5sZW5ndGg9PT02KW09W21bMF0sbVsxXSxtWzJdLG1bM10sbVs0XSxtWzVdLG1bMl0sbVszXV07ZWxzZSBpZihtLmxlbmd0aCE9PTgpdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCBib3JkZXJSYWRpdXMgdmFsdWUuIik7dGhpcy5ib3JkZXJUb3BMZWZ0UmFkaXVzPVttWzBdLG1bMV1dLHRoaXMuYm9yZGVyVG9wUmlnaHRSYWRpdXM9W21bMl0sbVszXV0sdGhpcy5ib3JkZXJCb3R0b21SaWdodFJhZGl1cz1bbVs0XSxtWzVdXSx0aGlzLmJvcmRlckJvdHRvbUxlZnRSYWRpdXM9W21bNl0sbVs3XV19Z2V0IGJnY29sb3IoKXtyZXR1cm4gdGhpc1tjXSgiYmdjb2xvciIpfXNldCBiZ2NvbG9yKG0pe3RoaXNbdl0oImJnY29sb3IiLE9iamVjdChnLnBhcnNlQ29sb3IpKG0pKX1nZXQgcGFkZGluZ1RvcCgpe3JldHVybiB0aGlzW2NdKCJwYWRkaW5nVG9wIil9c2V0IHBhZGRpbmdUb3AobSl7dGhpc1t2XSgicGFkZGluZ1RvcCIsT2JqZWN0KG8udG9OdW1iZXIpKG0pKX1nZXQgcGFkZGluZ1JpZ2h0KCl7cmV0dXJuIHRoaXNbY10oInBhZGRpbmdSaWdodCIpfXNldCBwYWRkaW5nUmlnaHQobSl7dGhpc1t2XSgicGFkZGluZ1JpZ2h0IixPYmplY3Qoby50b051bWJlcikobSkpfWdldCBwYWRkaW5nQm90dG9tKCl7cmV0dXJuIHRoaXNbY10oInBhZGRpbmdCb3R0b20iKX1zZXQgcGFkZGluZ0JvdHRvbShtKXt0aGlzW3ZdKCJwYWRkaW5nQm90dG9tIixPYmplY3Qoby50b051bWJlcikobSkpfWdldCBwYWRkaW5nTGVmdCgpe3JldHVybiB0aGlzW2NdKCJwYWRkaW5nTGVmdCIpfXNldCBwYWRkaW5nTGVmdChtKXt0aGlzW3ZdKCJwYWRkaW5nTGVmdCIsT2JqZWN0KG8udG9OdW1iZXIpKG0pKX1nZXQgcGFkZGluZygpe3JldHVyblt0aGlzLnBhZGRpbmdUb3AsdGhpcy5wYWRkaW5nUmlnaHQsdGhpcy5wYWRkaW5nQm90dG9tLHRoaXMucGFkZGluZ0xlZnRdfXNldCBwYWRkaW5nKG0pe209T2JqZWN0KG8udG9BcnJheSkobSksQXJyYXkuaXNBcnJheShtKT9tLmxlbmd0aD09PTI/bT1bbVswXSxtWzFdLG1bMF0sbVsxXV06bS5sZW5ndGg9PT0zJiYobT1bbVswXSxtWzFdLG1bMl0sbVsxXV0pOm09W20sbSxtLG1dLHRoaXMucGFkZGluZ1RvcD1tWzBdLHRoaXMucGFkZGluZ1JpZ2h0PW1bMV0sdGhpcy5wYWRkaW5nQm90dG9tPW1bMl0sdGhpcy5wYWRkaW5nTGVmdD1tWzNdfWdldCBjbGlwUGF0aCgpe3JldHVybiB0aGlzW2NdKCJjbGlwUGF0aCIpfXNldCBjbGlwUGF0aChtKXt0aGlzW3ZdKCJjbGlwUGF0aCIsbSl9Z2V0IGJveFNpemluZygpe3JldHVybiB0aGlzW2NdKCJib3hTaXppbmciKX1zZXQgYm94U2l6aW5nKG0pe2lmKG0hPW51bGwmJm0hPT0iYm9yZGVyLWJveCImJm0hPT0iY29udGVudC1ib3giKXRocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgYm94U2l6aW5nIHR5cGUuIik7dGhpc1t2XSgiYm94U2l6aW5nIixtKX19fSxmdW5jdGlvbihSLGUsdCl7dC5yKGUpLHQuZChlLCJHcmFkaWVudCIsZnVuY3Rpb24oKXtyZXR1cm4gZ30pLHQuZChlLCJpc1RyYW5zcGFyZW50IixmdW5jdGlvbigpe3JldHVybiB2fSksdC5kKGUsInBhcnNlQ29sb3IiLGZ1bmN0aW9uKCl7cmV0dXJuIGN9KSx0LmQoZSwic2V0RmlsbENvbG9yIixmdW5jdGlvbigpe3JldHVybiBofSksdC5kKGUsInNldFN0cm9rZUNvbG9yIixmdW5jdGlvbigpe3JldHVybiBFfSksdC5kKGUsIkNvbG9yIixmdW5jdGlvbigpe3JldHVybiBsfSk7dmFyIGk9dCgzMiksbz10Lm4oaSk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NsYXNzIGd7Y29uc3RydWN0b3Ioe3ZlY3RvcjpwLGNvbG9yczpDfSl7aWYoIUFycmF5LmlzQXJyYXkocCl8fHAubGVuZ3RoIT09NCYmcC5sZW5ndGghPT02JiZwLmxlbmd0aCE9PTMpdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCBncmFkaWVudCIpO3RoaXMudmVjdG9yPXAsdGhpcy5jb2xvcnM9Qy5tYXAoKHtvZmZzZXQ6eCxjb2xvcjpkfSk9Pih7b2Zmc2V0OngsY29sb3I6YyhkKX0pKX10b1N0cmluZygpe3JldHVybiBKU09OLnN0cmluZ2lmeSh7dmVjdG9yOnRoaXMudmVjdG9yLGNvbG9yczp0aGlzLmNvbG9yc30pfX1mdW5jdGlvbiB2KG0pe3JldHVybiBtIGluc3RhbmNlb2YgZz8hMTptPT1udWxsPyEwOm8oKShtKVszXT09PTB9ZnVuY3Rpb24gYyhtKXtpZihtPT1udWxsfHwobXx8KG09InRyYW5zcGFyZW50IiksbSBpbnN0YW5jZW9mIGcpKXJldHVybiBtO2NvbnN0IHA9bygpKG0pO2lmKCFwfHwhcC5sZW5ndGgpdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCBjb2xvciB2YWx1ZS4iKTtyZXR1cm5gcmdiYSgke3Auam9pbigpfSlgfWZ1bmN0aW9uIGYobSxwLEMpe2NvbnN0IHg9bS5ib3VuZGluZ0JveFswXTtpZihDLnZlY3Rvcil7bGV0e3ZlY3RvcjpkLGNvbG9yczp5fT1DO2QubGVuZ3RoPT09ND8oZD1bZFswXSt4WzBdLGRbMV0reFsxXSxkWzJdK3hbMF0sZFszXSt4WzFdXSxtLnNldExpbmVhckdyYWRpZW50KHt2ZWN0b3I6ZCxjb2xvcnM6eSx0eXBlOnB9KSk6ZC5sZW5ndGg9PT0zPyhkPVtkWzBdK3hbMF0sZFsxXSt4WzFdLGRbMl1dLG0uc2V0Q2lyY3VsYXJHcmFkaWVudCh7dmVjdG9yOmQsY29sb3JzOnksdHlwZTpwfSkpOihkPVtkWzBdK3hbMF0sZFsxXSt4WzFdLGRbMl0sZFszXSt4WzBdLGRbNF0reFsxXSxkWzVdXSxtLnNldFJhZGlhbEdyYWRpZW50KHt2ZWN0b3I6ZCxjb2xvcnM6eSx0eXBlOnB9KSl9ZWxzZSBtLmdyYWRpZW50JiZtLmdyYWRpZW50W3BdJiYoZGVsZXRlIG0uZ3JhZGllbnRbcF0sZGVsZXRlIG0udW5pZm9ybXMudV9yYWRpYWxHcmFkaWVudFZlY3Rvcil9ZnVuY3Rpb24gaChtLHtjb2xvcjpwLHJ1bGU6Qz0ibm9uemVybyJ9KXtyZXR1cm4gZihtLCJmaWxsIixwKSxwLnZlY3Rvcnx8bS5zZXRGaWxsKHtjb2xvcjpwLHJ1bGU6Q30pLG19ZnVuY3Rpb24gRShtLHtjb2xvcjpwLGxpbmVXaWR0aDpDLGxpbmVDYXA6eCxsaW5lSm9pbjpkLGxpbmVEYXNoOnksbGluZURhc2hPZmZzZXQ6cixtaXRlckxpbWl0OnMscm91bmRTZWdtZW50czpufSl7ZihtLCJzdHJva2UiLHApLHAudmVjdG9yJiYocD1bMCwwLDAsMV0pLG0uc2V0U3Ryb2tlKHtjb2xvcjpwLHRoaWNrbmVzczpDLGNhcDp4LGpvaW46ZCxtaXRlckxpbWl0OnMsbGluZURhc2g6eSxsaW5lRGFzaE9mZnNldDpyLHJvdW5kU2VnbWVudHM6bn0pfWNsYXNzIGwgZXh0ZW5kcyBBcnJheXtjb25zdHJ1Y3RvcihwPTAsQz0wLHg9MCxkPTApe3JldHVybiBBcnJheS5pc0FycmF5KHApJiYoW3AsQyx4LGRdPXApLHR5cGVvZiBwPT0ic3RyaW5nIiYmKFtwLEMseCxkXT1vKCkocCkscC89MjU1LEMvPTI1NSx4Lz0yNTUpLHN1cGVyKHAsQyx4LGQpLHRoaXN9Z2V0IHIoKXtyZXR1cm4gTWF0aC5yb3VuZCh0aGlzWzBdKjI1NSl9c2V0IHIocCl7dGhpc1swXT1wLzI1NX1nZXQgZygpe3JldHVybiBNYXRoLnJvdW5kKHRoaXNbMV0qMjU1KX1zZXQgZyhwKXt0aGlzWzFdPXAvMjU1fWdldCBiKCl7cmV0dXJuIE1hdGgucm91bmQodGhpc1syXSoyNTUpfXNldCBiKHApe3RoaXNbMl09cC8yNTV9Z2V0IGEoKXtyZXR1cm4gdGhpc1szXX1zZXQgYShwKXt0aGlzWzNdPXB9Z2V0IGhleCgpe2NvbnN0IHA9YDAke3RoaXMuci50b1N0cmluZygxNil9YC5zbGljZSgtMiksQz1gMCR7dGhpcy5nLnRvU3RyaW5nKDE2KX1gLnNsaWNlKC0yKSx4PWAwJHt0aGlzLmIudG9TdHJpbmcoMTYpfWAuc2xpY2UoLTIpO2xldCBkO3JldHVybiB0aGlzLmE8MSYmKGQ9TWF0aC5yb3VuZCh0aGlzWzNdKjI1NSksZD1gMCR7ZC50b1N0cmluZygxNil9YC5zbGljZSgtMikpLGAjJHtwfSR7Q30ke3h9JHtkfHwiIn1gfWdldCByZ2JhKCl7cmV0dXJuYHJnYmEoJHt0aGlzLnJ9LCR7dGhpcy5nfSwke3RoaXMuYn0sJHt0aGlzLmF9KWB9ZnJvbUNvbG9yKHApe3JldHVybiB0eXBlb2YgcD09InN0cmluZyImJihwPW8oKShwKSxwWzBdLz0yNTUscFsxXS89MjU1LHBbMl0vPTI1NSksdGhpc1swXT1wWzBdLHRoaXNbMV09cFsxXSx0aGlzWzJdPXBbMl0sdGhpc1szXT1wWzNdLHRoaXN9fX0sZnVuY3Rpb24oUixlLHQpe3QucihlKSx0LmQoZSwiY3JlYXRlUmFkaXVzQm94IixmdW5jdGlvbigpe3JldHVybiBvfSksdCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIGkoZyx2LGMsZixoLEU9ImxlZnRUb3AiKXtjb25zdCBsPS41NTIyODQ4LG09Zi8yKmwscD1oLzIqbCxDPXYrZix4PWMraCxkPXYrZi8yLHk9YytoLzI7RT09PSJsZWZ0VG9wIj8oZy5tb3ZlVG8odix5KSxnLmJlemllckN1cnZlVG8odix5LXAsZC1tLGMsZCxjKSk6RT09PSJyaWdodFRvcCI/Zy5iZXppZXJDdXJ2ZVRvKGQrbSxjLEMseS1wLEMseSk6RT09PSJyaWdodEJvdHRvbSI/Zy5iZXppZXJDdXJ2ZVRvKEMseStwLGQrbSx4LGQseCk6RT09PSJsZWZ0Qm90dG9tIiYmZy5iZXppZXJDdXJ2ZVRvKGQtbSx4LHYseStwLHYseSl9ZnVuY3Rpb24gbyhnLFt2LGMsZixoXSxFKXtpZighRXx8QXJyYXkuaXNBcnJheShFKSYmRS5ldmVyeShsPT5sPT09MCkpZy5iZWdpblBhdGgoKSxnLnJlY3QodixjLGYsaCk7ZWxzZXt0eXBlb2YgRT09Im51bWJlciImJihFPUFycmF5KDgpLmZpbGwoRSkpO2NvbnN0W2wsbSxwLEMseCxkLHkscl09RS5tYXAoKHMsbik9Pm4lMj9NYXRoLm1pbihzLGgvMik6TWF0aC5taW4ocyxmLzIpKTtnLmJlZ2luUGF0aCgpLGcubW92ZVRvKHYsYyttKSxpKGcsdixjLGwqMixtKjIsImxlZnRUb3AiKSxnLmxpbmVUbyh2K2YtcCxjKSxpKGcsditmLXAqMixjLHAqMixDKjIsInJpZ2h0VG9wIiksZy5saW5lVG8oditmLGMraC1kKSxpKGcsditmLXgqMixjK2gtZCoyLHgqMixkKjIsInJpZ2h0Qm90dG9tIiksZy5saW5lVG8odit5LGMraCksaShnLHYsYytoLXIqMix5KjIscioyLCJsZWZ0Qm90dG9tIiksZy5jbG9zZVBhdGgoKX1yZXR1cm4gZ319LGZ1bmN0aW9uKFIsZSx0KXt0LnIoZSksdCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpLGUuZGVmYXVsdD1mdW5jdGlvbihpLG8pe2lmKCFpKXJldHVybnt4OjAseTowLHdpZHRoOjAsaGVpZ2h0OjAsbGVmdDowLHRvcDowLHJpZ2h0OjAsYm90dG9tOjB9O2NvbnN0W1tnLHZdLFtjLGZdXT1pLGg9ZypvWzBdK3Yqb1syXStvWzRdLEU9ZypvWzFdK3Yqb1szXStvWzVdLGw9YypvWzBdK3Yqb1syXStvWzRdLG09YypvWzFdK3Yqb1szXStvWzVdLHA9YypvWzBdK2Yqb1syXStvWzRdLEM9YypvWzFdK2Yqb1szXStvWzVdLHg9ZypvWzBdK2Yqb1syXStvWzRdLGQ9ZypvWzFdK2Yqb1szXStvWzVdLHk9TWF0aC5taW4oaCxsLHAseCkscj1NYXRoLm1pbihFLG0sQyxkKSxzPU1hdGgubWF4KGgsbCxwLHgpLG49TWF0aC5tYXgoRSxtLEMsZCk7cmV0dXJue3g6eSx5OnIsd2lkdGg6cy15LGhlaWdodDpuLXIsbGVmdDp5LHRvcDpyLHJpZ2h0OnMsYm90dG9tOm59fX0sZnVuY3Rpb24oUixlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gaH0pO3ZhciBpPXQoMjE4KSxvPXQoMjE5KSxnPXQoMjI1KSx2PXQoMjEzKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gYyhFLGwsbSl7cmV0dXJuIGwgaW4gRT9PYmplY3QuZGVmaW5lUHJvcGVydHkoRSxsLHt2YWx1ZTptLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6RVtsXT1tLEV9Y29uc3QgZj1TeW1ib2woInRleHR1cmVUYXNrIik7Y2xhc3MgaCBleHRlbmRzIG8uZGVmYXVsdHtjb25zdHJ1Y3RvcihsPXt9KXt0eXBlb2YgbD09InN0cmluZyImJihsPXt0ZXh0dXJlOmx9KSxzdXBlcihsKX1nZXQgY29udGVudFNpemUoKXtsZXRbbCxtXT1zdXBlci5jb250ZW50U2l6ZTtjb25zdHt3aWR0aDpwLGhlaWdodDpDfT10aGlzLmF0dHJpYnV0ZXM7aWYocD09bnVsbHx8Qz09bnVsbCl7Y29uc3QgeD10aGlzLnRleHR1cmVJbWFnZSxkPXRoaXMuYXR0cmlidXRlcy50ZXh0dXJlUmVjdCx5PXRoaXMuYXR0cmlidXRlcy5zb3VyY2VSZWN0O2lmKGQpcD09bnVsbCYmKGw9ZFswXStkWzJdKSxDPT1udWxsJiYobT1kWzFdK2RbM10pO2Vsc2UgaWYoeSl7Y29uc3Qgcj10aGlzLmxheWVyP3RoaXMubGF5ZXIuZGlzcGxheVJhdGlvOjE7cD09bnVsbCYmKGw9eVsyXS9yKSxDPT1udWxsJiYobT15WzNdL3IpfWVsc2UgaWYoeCl7Y29uc3Qgcj10aGlzLmxheWVyP3RoaXMubGF5ZXIuZGlzcGxheVJhdGlvOjE7cD09bnVsbCYmKGw9eC53aWR0aC9yKSxDPT1udWxsJiYobT14LmhlaWdodC9yKX19cmV0dXJuW2wsbV19Z2V0IHRleHR1cmVJbWFnZVJlYWR5KCl7cmV0dXJuIHRoaXNbZl18fFByb21pc2UucmVzb2x2ZSgpfWRyYXcobD1bXSl7c3VwZXIuZHJhdyhsKTtjb25zdCBtPXRoaXMubWVzaDtyZXR1cm4gbSYmT2JqZWN0KGkuZHJhd1RleHR1cmUpKHRoaXMsbSksbH1vblByb3BlcnR5Q2hhbmdlKGwsbSxwKXtpZihzdXBlci5vblByb3BlcnR5Q2hhbmdlKGwsbSxwKSxsPT09InRleHR1cmUiJiYodGhpc1tmXT1PYmplY3QoaS5hcHBseVRleHR1cmUpKHRoaXMsbSwhMCkpLGw9PT0idGV4dHVyZVJlY3QiKXtjb25zdHt3aWR0aDpDLGhlaWdodDp4fT10aGlzLmF0dHJpYnV0ZXM7KEM9PW51bGx8fHg9PW51bGwpJiZ0aGlzLnVwZGF0ZUNvbnRvdXJzKCl9fX1jKGgsIkF0dHIiLGcuZGVmYXVsdCksdi5kZWZhdWx0LnJlZ2lzdGVyTm9kZShoLCJzcHJpdGUiKX0sZnVuY3Rpb24oUixlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gY30pO3ZhciBpPXQoMjIwKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3Qgbz1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGVEZWZhdWx0IiksZz1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGUiKSx2PVN5bWJvbC5mb3IoInNwcml0ZWpzX2dldEF0dHJpYnV0ZSIpO2NsYXNzIGMgZXh0ZW5kcyBpLmRlZmF1bHR7Y29uc3RydWN0b3IoaCl7c3VwZXIoaCksdGhpc1tvXSh7dGV4dHVyZTp2b2lkIDAsdGV4dHVyZVJlY3Q6dm9pZCAwLHRleHR1cmVSZXBlYXQ6ITEsc291cmNlUmVjdDp2b2lkIDB9KX1nZXQgdGV4dHVyZSgpe3JldHVybiB0aGlzW3ZdKCJ0ZXh0dXJlIil9c2V0IHRleHR1cmUoaCl7dGhpc1tnXSgidGV4dHVyZSIsaCl9Z2V0IHRleHR1cmVSZWN0KCl7cmV0dXJuIHRoaXNbdl0oInRleHR1cmVSZWN0Iil9c2V0IHRleHR1cmVSZWN0KGgpe3RoaXNbZ10oInRleHR1cmVSZWN0IixoKX1nZXQgc291cmNlUmVjdCgpe3JldHVybiB0aGlzW3ZdKCJzb3VyY2VSZWN0Iil9c2V0IHNvdXJjZVJlY3QoaCl7dGhpc1tnXSgic291cmNlUmVjdCIsaCl9Z2V0IHRleHR1cmVSZXBlYXQoKXtyZXR1cm4gdGhpc1t2XSgidGV4dHVyZVJlcGVhdCIpfXNldCB0ZXh0dXJlUmVwZWF0KGgpe3RoaXNbZ10oInRleHR1cmVSZXBlYXQiLCEhaCl9fX0sZnVuY3Rpb24oUixlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gQ30pO3ZhciBpPXQoMTIpLG89dCgyMjcpLGc9dC5uKG8pLHY9dCg3MCksYz10KDIyOCksZj10KDIyMSksaD10KDIxOCksRT10KDIxMyksbD10KDIyMyk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIG0oeCxkLHkpe3JldHVybiBkIGluIHg/T2JqZWN0LmRlZmluZVByb3BlcnR5KHgsZCx7dmFsdWU6eSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOnhbZF09eSx4fWNvbnN0IHA9U3ltYm9sKCJtZXNoIik7Y2xhc3MgQyBleHRlbmRzIHYuZGVmYXVsdHtjb25zdHJ1Y3RvcihkPXt9KXt0eXBlb2YgZD09InN0cmluZyImJihkPXtkfSksc3VwZXIoZCksdGhpcy5lZmZlY3RzPXtkKHkscixzLG4sYSl7Y29uc3QgTz0ocy1uKS8oYS1uKTtpZihPPD0wKXJldHVybiB5O2lmKE8+PTEpcmV0dXJuIHI7Y29uc3QgQT1nLmEuX3ByZXByb2Nlc3NpbmcoZy5hLnBhdGgyc2hhcGVzKHkpLGcuYS5wYXRoMnNoYXBlcyhyKSksYj1nLmEuX2xlcnAoLi4uQSxPKVswXTtyZXR1cm4gYi5yZWR1Y2UoKFAsRCk9PmAke1B9JHtELnNsaWNlKDIpLmpvaW4oIiAiKX0gYCxgTSR7YlswXVswXX0gJHtiWzBdWzFdfUNgKS50cmltKCl9fX1nZXQgaXNWaXNpYmxlKCl7cmV0dXJuISF0aGlzLmR9Z2V0IG1lc2goKXtpZih0aGlzLmF0dHJpYnV0ZXMuZGlzcGxheT09PSJub25lIilyZXR1cm4gbnVsbDtjb25zdCBkPXRoaXMucGF0aDtpZihkKXtsZXQgeT10aGlzW3BdO2lmKHkpeS5wYXRoIT09ZCYmKHkuY29udG91cnM9ZC5jb250b3Vycyx5LnBhdGg9ZCk7ZWxzZXt5PW5ldyBpLk1lc2gyRCh0aGlzLnBhdGgpLHkucGF0aD1kO2NvbnN0IHM9dGhpcy5hdHRyaWJ1dGVzLmZpbGxDb2xvcixuPXRoaXMuYXR0cmlidXRlcy5maWxsUnVsZTtzJiZPYmplY3QoZi5zZXRGaWxsQ29sb3IpKHkse2NvbG9yOnMscnVsZTpufSk7Y29uc3QgYT10aGlzLmF0dHJpYnV0ZXMubGluZVdpZHRoLE89dGhpcy5hdHRyaWJ1dGVzLnN0cm9rZUNvbG9yO2lmKE8mJmE+MCl7Y29uc3R7bGluZUNhcDpiLGxpbmVKb2luOkksbWl0ZXJMaW1pdDpQLGxpbmVEYXNoOkQsbGluZURhc2hPZmZzZXQ6TCxyb3VuZFNlZ21lbnRzOlN9PXRoaXMuYXR0cmlidXRlcztPYmplY3QoZi5zZXRTdHJva2VDb2xvcikoeSx7Y29sb3I6TyxsaW5lV2lkdGg6YSxsaW5lQ2FwOmIsbGluZUpvaW46SSxtaXRlckxpbWl0OlAsbGluZURhc2g6RCxsaW5lRGFzaE9mZnNldDpMLHJvdW5kU2VnbWVudHM6U30pfXRoaXNbcF09eTtjb25zdCBBPXRoaXMuYXR0cmlidXRlcy5jbGlwUGF0aDtBJiZ0aGlzW3BdLnNldENsaXBQYXRoKEEpfWNvbnN0IHI9dGhpcy5vcGFjaXR5O3JldHVybiB5LmdldE9wYWNpdHkoKSE9PXImJnkuc2V0T3BhY2l0eShyKSx5LnNldFRyYW5zZm9ybSguLi50aGlzLnJlbmRlck1hdHJpeCkseX1yZXR1cm4gbnVsbH1nZXQgb3JpZ2luYWxDb250ZW50UmVjdCgpe2lmKHRoaXMucGF0aCl7Y29uc3QgZD10aGlzLnBhdGguYm91bmRpbmdCb3g7cmV0dXJuW2RbMF1bMF0sZFswXVsxXSxkWzFdWzBdLWRbMF1bMF0sZFsxXVsxXS1kWzBdWzFdXX1yZXR1cm5bMCwwLDAsMF19Z2V0IG9yaWdpbmFsQ2xpZW50UmVjdCgpe2lmKHRoaXMubWVzaCl7Y29uc3QgZD10aGlzLm1lc2guYm91bmRpbmdCb3g7cmV0dXJuW2RbMF1bMF0sZFswXVsxXSxkWzFdWzBdLWRbMF1bMF0sZFsxXVsxXS1kWzBdWzFdXX1yZXR1cm5bMCwwLDAsMF19Z2V0IG9yaWdpbmFsQ2xpZW50Q2VudGVyKCl7cmV0dXJuIHRoaXMubWVzaD90aGlzLm1lc2guYm91bmRpbmdDZW50ZXI6WzAsMF19c2V0IGQoZCl7dGhpcy5hdHRyaWJ1dGVzLmQ9ZH1nZXQgZCgpe3JldHVybiB0aGlzLmF0dHJpYnV0ZXMuZH1kcmF3KGQ9W10pe3N1cGVyLmRyYXcoZCk7Y29uc3QgeT10aGlzLm1lc2g7cmV0dXJuIHkmJk9iamVjdChoLmRyYXdUZXh0dXJlKSh0aGlzLHkpLGR9Z2V0Qm91bmRpbmdDbGllbnRSZWN0KCl7bGV0IGQ9bnVsbDtyZXR1cm4gdGhpcy5tZXNoJiYoZD10aGlzLm1lc2guYm91bmRpbmdCb3gpLE9iamVjdChsLmRlZmF1bHQpKGQsdGhpcy5yZW5kZXJNYXRyaXgpfWdldFBhdGhMZW5ndGgoKXtyZXR1cm4gdGhpcy5tZXNoP3RoaXMubWVzaC5nZXRUb3RhbExlbmd0aCgpOjB9Z2V0UG9pbnRBdExlbmd0aChkKXtpZih0aGlzLm1lc2gpe2NvbnN0IHk9dGhpcy5tZXNoLmdldFBvaW50QXRMZW5ndGgoZCk7aWYoeSlyZXR1cm5beS54LHkueV19cmV0dXJuWzAsMF19b25Qcm9wZXJ0eUNoYW5nZShkLHkscil7aWYoc3VwZXIub25Qcm9wZXJ0eUNoYW5nZShkLHksciksKGQ9PT0iZCJ8fGQ9PT0ibm9ybWFsaXplIikmJnRoaXMudXBkYXRlQ29udG91cnMoKSx0aGlzW3BdJiYoZD09PSJmaWxsQ29sb3IifHxkPT09ImZpbGxSdWxlIikpe2NvbnN0e2ZpbGxDb2xvcjpzLGZpbGxSdWxlOm59PXRoaXMuYXR0cmlidXRlcztPYmplY3QoZi5zZXRGaWxsQ29sb3IpKHRoaXNbcF0se2NvbG9yOnMscnVsZTpufSl9aWYodGhpc1twXSYmKGQ9PT0ic3Ryb2tlQ29sb3IifHxkPT09ImxpbmVXaWR0aCJ8fGQ9PT0ibGluZUNhcCJ8fGQ9PT0ibGluZUpvaW4ifHxkPT09ImxpbmVEYXNoInx8ZD09PSJsaW5lRGFzaE9mZnNldCJ8fGQ9PT0icm91bmRTZWdtZW50cyIpKXtjb25zdHtzdHJva2VDb2xvcjpzLGxpbmVXaWR0aDpufT10aGlzLmF0dHJpYnV0ZXM7aWYocyYmbj4wKXtjb25zdHtsaW5lQ2FwOmEsbGluZUpvaW46TyxsaW5lRGFzaDpBLGxpbmVEYXNoT2Zmc2V0OmIsbWl0ZXJMaW1pdDpJLHJvdW5kU2VnbWVudHM6UH09dGhpcy5hdHRyaWJ1dGVzO09iamVjdChmLnNldFN0cm9rZUNvbG9yKSh0aGlzW3BdLHtjb2xvcjpzLGxpbmVDYXA6YSxsaW5lSm9pbjpPLGxpbmVXaWR0aDpuLGxpbmVEYXNoOkEsbGluZURhc2hPZmZzZXQ6YixtaXRlckxpbWl0Okkscm91bmRTZWdtZW50czpQfSl9fXRoaXNbcF0mJmQ9PT0iY2xpcFBhdGgiJiZ0aGlzW3BdLnNldENsaXBQYXRoKHkpLGQ9PT0idGV4dHVyZSImJk9iamVjdChoLmFwcGx5VGV4dHVyZSkodGhpcyx5KX11cGRhdGVDb250b3Vycygpe3RoaXMucGF0aD1uZXcgaS5GaWd1cmUyRCx0aGlzLnBhdGguYWRkUGF0aCh0aGlzLmF0dHJpYnV0ZXMuZCksdGhpcy5hdHRyaWJ1dGVzLm5vcm1hbGl6ZSYmdGhpcy5wYXRoLm5vcm1hbGl6ZSguLi50aGlzLnBhdGguYm91bmRpbmdDZW50ZXIpfX1tKEMsIkF0dHIiLGMuZGVmYXVsdCksRS5kZWZhdWx0LnJlZ2lzdGVyTm9kZShDLCJwYXRoIil9LGZ1bmN0aW9uKFIsZSx0KXsoZnVuY3Rpb24oaSxvKXtSLmV4cG9ydHM9bygpfSkodGhpcyxmdW5jdGlvbigpe3ZhciBpPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gRChMLFMpe3ZhciBUPVtdLGo9ITAsJD0hMSx3PXZvaWQgMDt0cnl7Zm9yKHZhciBKPUxbU3ltYm9sLml0ZXJhdG9yXSgpLHE7IShqPShxPUoubmV4dCgpKS5kb25lKSYmKFQucHVzaChxLnZhbHVlKSwhKFMmJlQubGVuZ3RoPT09UykpO2o9ITApO31jYXRjaChXKXskPSEwLHc9V31maW5hbGx5e3RyeXshaiYmSi5yZXR1cm4mJkoucmV0dXJuKCl9ZmluYWxseXtpZigkKXRocm93IHd9fXJldHVybiBUfXJldHVybiBmdW5jdGlvbihMLFMpe2lmKEFycmF5LmlzQXJyYXkoTCkpcmV0dXJuIEw7aWYoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChMKSlyZXR1cm4gRChMLFMpO3Rocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UiKX19KCksbz1NYXRoLlBJKjIsZz1mdW5jdGlvbihMLFMsVCxqLCQsdyxKKXt2YXIgcT1MLngsVz1MLnk7cSo9UyxXKj1UO3ZhciBLPWoqcS0kKlcsUT0kKnEraipXO3JldHVybnt4Oksrdyx5OlErSn19LHY9ZnVuY3Rpb24oTCxTKXt2YXIgVD0xLjMzMzMzMzMzMzMzMzMzMzMqTWF0aC50YW4oUy80KSxqPU1hdGguY29zKEwpLCQ9TWF0aC5zaW4oTCksdz1NYXRoLmNvcyhMK1MpLEo9TWF0aC5zaW4oTCtTKTtyZXR1cm5be3g6ai0kKlQseTokK2oqVH0se3g6dytKKlQseTpKLXcqVH0se3g6dyx5Okp9XX0sYz1mdW5jdGlvbihMLFMsVCxqKXt2YXIgJD1MKmotUypUPDA/LTE6MSx3PU1hdGguc3FydChMKkwrUypTKSxKPU1hdGguc3FydChMKkwrUypTKSxxPUwqVCtTKmosVz1xLyh3KkopO3JldHVybiBXPjEmJihXPTEpLFc8LTEmJihXPS0xKSwkKk1hdGguYWNvcyhXKX0sZj1mdW5jdGlvbihMLFMsVCxqLCQsdyxKLHEsVyxLLFEsdHQpe3ZhciBfPU1hdGgucG93KCQsMiksc3Q9TWF0aC5wb3codywyKSxrPU1hdGgucG93KFEsMiksY3Q9TWF0aC5wb3codHQsMiksZnQ9XypzdC1fKmN0LXN0Kms7ZnQ8MCYmKGZ0PTApLGZ0Lz1fKmN0K3N0KmssZnQ9TWF0aC5zcXJ0KGZ0KSooSj09PXE/LTE6MSk7dmFyIFU9ZnQqJC93KnR0LEY9ZnQqLXcvJCpRLFY9SypVLVcqRisoTCtUKS8yLFg9VypVK0sqRisoUytqKS8yLEI9KFEtVSkvJCxHPSh0dC1GKS93LHU9KC1RLVUpLyQsTT0oLXR0LUYpL3csTj1jKDEsMCxCLEcpLHo9YyhCLEcsdSxNKTtyZXR1cm4gcT09PTAmJno+MCYmKHotPW8pLHE9PT0xJiZ6PDAmJih6Kz1vKSxbVixYLE4sel19LGg9ZnVuY3Rpb24oTCl7dmFyIFM9TC5weCxUPUwucHksaj1MLmN4LCQ9TC5jeSx3PUwucngsSj1MLnJ5LHE9TC54QXhpc1JvdGF0aW9uLFc9cT09PXZvaWQgMD8wOnEsSz1MLmxhcmdlQXJjRmxhZyxRPUs9PT12b2lkIDA/MDpLLHR0PUwuc3dlZXBGbGFnLF89dHQ9PT12b2lkIDA/MDp0dCxzdD1bXTtpZih3PT09MHx8Sj09PTApcmV0dXJuW107dmFyIGs9TWF0aC5zaW4oVypvLzM2MCksY3Q9TWF0aC5jb3MoVypvLzM2MCksZnQ9Y3QqKFMtaikvMitrKihULSQpLzIsVT0tayooUy1qKS8yK2N0KihULSQpLzI7aWYoZnQ9PT0wJiZVPT09MClyZXR1cm5bXTt3PU1hdGguYWJzKHcpLEo9TWF0aC5hYnMoSik7dmFyIEY9TWF0aC5wb3coZnQsMikvTWF0aC5wb3codywyKStNYXRoLnBvdyhVLDIpL01hdGgucG93KEosMik7Rj4xJiYodyo9TWF0aC5zcXJ0KEYpLEoqPU1hdGguc3FydChGKSk7dmFyIFY9ZihTLFQsaiwkLHcsSixRLF8sayxjdCxmdCxVKSxYPWkoViw0KSxCPVhbMF0sRz1YWzFdLHU9WFsyXSxNPVhbM10sTj1NYXRoLm1heChNYXRoLmNlaWwoTWF0aC5hYnMoTSkvKG8vNCkpLDEpO00vPU47Zm9yKHZhciB6PTA7ejxOO3orKylzdC5wdXNoKHYodSxNKSksdSs9TTtyZXR1cm4gc3QubWFwKGZ1bmN0aW9uKEgpe3ZhciBZPWcoSFswXSx3LEosY3QsayxCLEcpLFo9WS54LGV0PVkueSxydD1nKEhbMV0sdyxKLGN0LGssQixHKSxvdD1ydC54LGx0PXJ0LnksaXQ9ZyhIWzJdLHcsSixjdCxrLEIsRyksbnQ9aXQueCxhdD1pdC55O3JldHVybnt4MTpaLHkxOmV0LHgyOm90LHkyOmx0LHg6bnQseTphdH19KX0sRT17YTo3LGM6NixoOjEsbDoyLG06MixxOjQsczo0LHQ6Mix2OjEsejowfSxsPS8oW2FzdHZ6cW1obGNdKShbXmFzdHZ6cW1obGNdKikvaWc7ZnVuY3Rpb24gbShEKXt2YXIgTD1bXTtyZXR1cm4gRC5yZXBsYWNlKGwsZnVuY3Rpb24oUyxULGope3ZhciAkPVQudG9Mb3dlckNhc2UoKTtmb3Ioaj1DKGopLCQ9PSJtIiYmai5sZW5ndGg+MiYmKEwucHVzaChbVF0uY29uY2F0KGouc3BsaWNlKDAsMikpKSwkPSJsIixUPVQ9PSJtIj8ibCI6IkwiKTs7KXtpZihqLmxlbmd0aD09RVskXSlyZXR1cm4gai51bnNoaWZ0KFQpLEwucHVzaChqKTtpZihqLmxlbmd0aDxFWyRdKXRocm93IG5ldyBFcnJvcigibWFsZm9ybWVkIHBhdGggZGF0YSIpO0wucHVzaChbVF0uY29uY2F0KGouc3BsaWNlKDAsRVskXSkpKX19KSxMfXZhciBwPS8tP1swLTldKlwuP1swLTldKyg/OmVbLStdP1xkKyk/L2lnO2Z1bmN0aW9uIEMoRCl7dmFyIEw9RC5tYXRjaChwKTtyZXR1cm4gTD9MLm1hcChOdW1iZXIpOltdfWZ1bmN0aW9uIHgoRCl7dmFyIEw9RFswXVswXSxTPURbMF1bMV0sVD1MLGo9UztyZXR1cm4gRC5mb3JFYWNoKGZ1bmN0aW9uKCQpe3ZhciB3PSRbMF0sSj0kWzJdLHE9JFs0XSxXPSRbNl0sSz0kWzFdLFE9JFszXSx0dD0kWzVdLF89JFs3XTtMPU1hdGgubWluKEwsdyxKLHEsVyksUz1NYXRoLm1pbihTLEssUSx0dCxfKSxUPU1hdGgubWF4KFQsdyxKLHEsVyksaj1NYXRoLm1heChqLEssUSx0dCxfKX0pLFtMLFMsVCxqXX1mdW5jdGlvbiBkKEQsTCl7cmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyhEWzBdLUxbMF0sMikrTWF0aC5wb3coRFsxXS1MWzFdLDIpKStNYXRoLnNxcnQoTWF0aC5wb3coRFsyXS1MWzJdLDIpK01hdGgucG93KERbM10tTFszXSwyKSl9ZnVuY3Rpb24geShELEwpe3ZhciBTPURbMF0sVD1EWzJdLGo9RFs0XSwkPURbNl0sdz1EWzFdLEo9RFszXSxxPURbNV0sVz1EWzddLEs9TFswXSxRPUxbMl0sdHQ9TFs0XSxfPUxbNl0sc3Q9TFsxXSxrPUxbM10sY3Q9TFs1XSxmdD1MWzddO3JldHVybiBNYXRoLnNxcnQoTWF0aC5wb3coSy1TLDIpK01hdGgucG93KHN0LXcsMikpK01hdGguc3FydChNYXRoLnBvdyhRLVQsMikrTWF0aC5wb3coay1KLDIpKStNYXRoLnNxcnQoTWF0aC5wb3codHQtaiwyKStNYXRoLnBvdyhjdC1xLDIpKStNYXRoLnNxcnQoTWF0aC5wb3coXy0kLDIpK01hdGgucG93KGZ0LVcsMikpfWZ1bmN0aW9uIHIoRCxMKXt2YXIgUz1uKEQubGVuZ3RoKSxUPVtdO1MuZm9yRWFjaChmdW5jdGlvbigkKXt2YXIgdz0wLEo9MDskLmZvckVhY2goZnVuY3Rpb24ocSl7dys9eShEW3FdLExbSisrXSl9KSxULnB1c2goe2luZGV4OiQsZGlzdGFuY2U6d30pfSksVC5zb3J0KGZ1bmN0aW9uKCQsdyl7cmV0dXJuICQuZGlzdGFuY2Utdy5kaXN0YW5jZX0pO3ZhciBqPVtdO3JldHVybiBUWzBdLmluZGV4LmZvckVhY2goZnVuY3Rpb24oJCl7ai5wdXNoKERbJF0pfSksan1mdW5jdGlvbiBzKEQsTCl7dmFyIFM9YShELmxlbmd0aCksVD1bXTtTLmZvckVhY2goZnVuY3Rpb24oJCl7dmFyIHc9MDskLmZvckVhY2goZnVuY3Rpb24oSil7dys9ZCh4KERbSl0pLHgoTFtKXSkpfSksVC5wdXNoKHtpbmRleDokLGRpc3RhbmNlOnd9KX0pLFQuc29ydChmdW5jdGlvbigkLHcpe3JldHVybiAkLmRpc3RhbmNlLXcuZGlzdGFuY2V9KTt2YXIgaj1bXTtyZXR1cm4gVFswXS5pbmRleC5mb3JFYWNoKGZ1bmN0aW9uKCQpe2oucHVzaChEWyRdKX0pLGp9ZnVuY3Rpb24gbihEKXtmb3IodmFyIEw9W10sUz0wO1M8RDtTKyspe2Zvcih2YXIgVD1bXSxqPTA7ajxEO2orKyl7dmFyICQ9aitTOyQ+RC0xJiYoJC09RCksVFskXT1qfUwucHVzaChUKX1yZXR1cm4gTH1mdW5jdGlvbiBhKEQpe2Zvcih2YXIgTD1bXSxTPTA7UzxEO1MrKylMLnB1c2goUyk7cmV0dXJuIE8oTCl9ZnVuY3Rpb24gTyhEKXt2YXIgTD1bXSxTPVtdO2Z1bmN0aW9uIFQoail7dmFyICQsdztmb3IoJD0wOyQ8ai5sZW5ndGg7JCsrKXc9ai5zcGxpY2UoJCwxKVswXSxTLnB1c2godyksai5sZW5ndGg9PTAmJkwucHVzaChTLnNsaWNlKCkpLFQoaiksai5zcGxpY2UoJCwwLHcpLFMucG9wKCk7cmV0dXJuIEx9cmV0dXJuIFQoRCl9dmFyIEE9e307QS5wYXJzZXI9bSxBLmxlcnBDdXJ2ZT1mdW5jdGlvbihELEwsUyl7cmV0dXJuIEEubGVycFBvaW50cyhEWzBdLERbMV0sTFswXSxMWzFdLFMpLmNvbmNhdChBLmxlcnBQb2ludHMoRFsyXSxEWzNdLExbMl0sTFszXSxTKSkuY29uY2F0KEEubGVycFBvaW50cyhEWzRdLERbNV0sTFs0XSxMWzVdLFMpKS5jb25jYXQoQS5sZXJwUG9pbnRzKERbNl0sRFs3XSxMWzZdLExbN10sUykpfSxBLmxlcnBQb2ludHM9ZnVuY3Rpb24oRCxMLFMsVCxqKXtyZXR1cm5bRCsoUy1EKSpqLEwrKFQtTCkqal19LEEucTJiPWZ1bmN0aW9uKEQsTCxTLFQsaiwkKXtyZXR1cm5bRCxMLChEKzIqUykvMywoTCsyKlQpLzMsKGorMipTKS8zLCgkKzIqVCkvMyxqLCRdfSxBLnBhdGgyc2hhcGVzPWZ1bmN0aW9uKEQpe2Zvcih2YXIgTD1BLnBhcnNlcihEKSxTPTAsVD0wLGo9MCwkPUwubGVuZ3RoLHc9W10sSj1udWxsLHE9dm9pZCAwLFc9dm9pZCAwLEs9dm9pZCAwLFE9dm9pZCAwLHR0PXZvaWQgMCxfPXZvaWQgMCxzdD12b2lkIDA7ajwkO2orKyl7dmFyIGs9TFtqXSxjdD1rWzBdLGZ0PUxbai0xXTtzd2l0Y2goY3Qpe2Nhc2UibSI6dHQ9dy5sZW5ndGgsd1t0dF09W10sSj13W3R0XSxTPVMra1sxXSxUPVQra1syXTticmVhaztjYXNlIk0iOnR0PXcubGVuZ3RoLHdbdHRdPVtdLEo9d1t0dF0sUz1rWzFdLFQ9a1syXTticmVhaztjYXNlImwiOkoucHVzaChbUyxULFMsVCxTLFQsUytrWzFdLFQra1syXV0pLFMrPWtbMV0sVCs9a1syXTticmVhaztjYXNlIkwiOkoucHVzaChbUyxULGtbMV0sa1syXSxrWzFdLGtbMl0sa1sxXSxrWzJdXSksUz1rWzFdLFQ9a1syXTticmVhaztjYXNlImgiOkoucHVzaChbUyxULFMsVCxTLFQsUytrWzFdLFRdKSxTKz1rWzFdO2JyZWFrO2Nhc2UiSCI6Si5wdXNoKFtTLFQsa1sxXSxULGtbMV0sVCxrWzFdLFRdKSxTPWtbMV07YnJlYWs7Y2FzZSJ2IjpKLnB1c2goW1MsVCxTLFQsUyxULFMsVCtrWzFdXSksVCs9a1sxXTticmVhaztjYXNlIlYiOkoucHVzaChbUyxULFMsa1sxXSxTLGtbMV0sUyxrWzFdXSksVD1rWzFdO2JyZWFrO2Nhc2UiQyI6Si5wdXNoKFtTLFQsa1sxXSxrWzJdLGtbM10sa1s0XSxrWzVdLGtbNl1dKSxTPWtbNV0sVD1rWzZdO2JyZWFrO2Nhc2UiUyI6ZnRbMF09PT0iQyJ8fGZ0WzBdPT09ImMiP0oucHVzaChbUyxULFMrZnRbNV0tZnRbM10sVCtmdFs2XS1mdFs0XSxrWzFdLGtbMl0sa1szXSxrWzRdXSk6KGZ0WzBdPT09IlMifHxmdFswXT09PSJzIikmJkoucHVzaChbUyxULFMrZnRbM10tZnRbMV0sVCtmdFs0XS1mdFsyXSxrWzFdLGtbMl0sa1szXSxrWzRdXSksUz1rWzNdLFQ9a1s0XTticmVhaztjYXNlImMiOkoucHVzaChbUyxULFMra1sxXSxUK2tbMl0sUytrWzNdLFQra1s0XSxTK2tbNV0sVCtrWzZdXSksUz1TK2tbNV0sVD1UK2tbNl07YnJlYWs7Y2FzZSJzIjpmdFswXT09PSJDInx8ZnRbMF09PT0iYyI/Si5wdXNoKFtTLFQsUytmdFs1XS1mdFszXSxUK2Z0WzZdLWZ0WzRdLFMra1sxXSxUK2tbMl0sUytrWzNdLFQra1s0XV0pOihmdFswXT09PSJTInx8ZnRbMF09PT0icyIpJiZKLnB1c2goW1MsVCxTK2Z0WzNdLWZ0WzFdLFQrZnRbNF0tZnRbMl0sUytrWzFdLFQra1syXSxTK2tbM10sVCtrWzRdXSksUz1TK2tbM10sVD1UK2tbNF07YnJlYWs7Y2FzZSJhIjpfPWgoe3J4OmtbMV0scnk6a1syXSxweDpTLHB5OlQseEF4aXNSb3RhdGlvbjprWzNdLGxhcmdlQXJjRmxhZzprWzRdLHN3ZWVwRmxhZzprWzVdLGN4OlMra1s2XSxjeTpUK2tbN119KSxzdD1fW18ubGVuZ3RoLTFdLF8uZm9yRWFjaChmdW5jdGlvbihVLEYpe0Y9PT0wP0oucHVzaChbUyxULFUueDEsVS55MSxVLngyLFUueTIsVS54LFUueV0pOkoucHVzaChbX1tGLTFdLngsX1tGLTFdLnksVS54MSxVLnkxLFUueDIsVS55MixVLngsVS55XSl9KSxTPXN0LngsVD1zdC55O2JyZWFrO2Nhc2UiQSI6Xz1oKHtyeDprWzFdLHJ5OmtbMl0scHg6UyxweTpULHhBeGlzUm90YXRpb246a1szXSxsYXJnZUFyY0ZsYWc6a1s0XSxzd2VlcEZsYWc6a1s1XSxjeDprWzZdLGN5OmtbN119KSxzdD1fW18ubGVuZ3RoLTFdLF8uZm9yRWFjaChmdW5jdGlvbihVLEYpe0Y9PT0wP0oucHVzaChbUyxULFUueDEsVS55MSxVLngyLFUueTIsVS54LFUueV0pOkoucHVzaChbX1tGLTFdLngsX1tGLTFdLnksVS54MSxVLnkxLFUueDIsVS55MixVLngsVS55XSl9KSxTPXN0LngsVD1zdC55O2JyZWFrO2Nhc2UiUSI6Si5wdXNoKEEucTJiKFMsVCxrWzFdLGtbMl0sa1szXSxrWzRdKSksUz1rWzNdLFQ9a1s0XTticmVhaztjYXNlInEiOkoucHVzaChBLnEyYihTLFQsUytrWzFdLFQra1syXSxrWzNdK1Msa1s0XStUKSksUys9a1szXSxUKz1rWzRdO2JyZWFrO2Nhc2UiVCI6ZnRbMF09PT0iUSJ8fGZ0WzBdPT09InEiPyhLPVMrZnRbM10tZnRbMV0sUT1UK2Z0WzRdLWZ0WzJdLEoucHVzaChBLnEyYihTLFQsSyxRLGtbMV0sa1syXSkpKTooZnRbMF09PT0iVCJ8fGZ0WzBdPT09InQiKSYmKEoucHVzaChBLnEyYihTLFQsUytTLUssVCtULVEsa1sxXSxrWzJdKSksSz1TK1MtSyxRPVQrVC1RKSxTPWtbMV0sVD1rWzJdO2JyZWFrO2Nhc2UidCI6ZnRbMF09PT0iUSJ8fGZ0WzBdPT09InEiPyhLPVMrZnRbM10tZnRbMV0sUT1UK2Z0WzRdLWZ0WzJdLEoucHVzaChBLnEyYihTLFQsSyxRLFMra1sxXSxUK2tbMl0pKSk6KGZ0WzBdPT09IlQifHxmdFswXT09PSJ0IikmJihKLnB1c2goQS5xMmIoUyxULFMrUy1LLFQrVC1RLFMra1sxXSxUK2tbMl0pKSxLPVMrUy1LLFE9VCtULVEpLFMrPWtbMV0sVCs9a1syXTticmVhaztjYXNlIloiOnE9SlswXVswXSxXPUpbMF1bMV0sSi5wdXNoKFtTLFQscSxXLHEsVyxxLFddKTticmVhaztjYXNlInoiOnE9SlswXVswXSxXPUpbMF1bMV0sSi5wdXNoKFtTLFQscSxXLHEsVyxxLFddKTticmVha319cmV0dXJuIHd9LEEuX3VwQ3VydmVzPWZ1bmN0aW9uKEQsTCl7Zm9yKHZhciBTPTAsVD0wLGo9RC5sZW5ndGg7UzxMO1MrKylELnB1c2goRFtUXS5zbGljZSgwKSksVCsrLFQ+ai0xJiYoVC09ail9O2Z1bmN0aW9uIGIoRCxMLFMsVCxqLCQsdyxKLHEpe3JldHVybntsZWZ0OkkoRCxMLFMsVCxqLCQsdyxKLHEpLHJpZ2h0OkkodyxKLGosJCxTLFQsRCxMLDEtcSwhMCl9fWZ1bmN0aW9uIEkoRCxMLFMsVCxqLCQsdyxKLHEsVyl7dmFyIEs9KFMtRCkqcStELFE9KFQtTCkqcStMLHR0PShqLVMpKnErUyxfPSgkLVQpKnErVCxzdD0ody1qKSpxK2osaz0oSi0kKSpxKyQsY3Q9KHR0LUspKnErSyxmdD0oXy1RKSpxK1EsVT0oc3QtdHQpKnErdHQsRj0oay1fKSpxK18sVj0oVS1jdCkqcStjdCxYPShGLWZ0KSpxK2Z0O3JldHVybiBXP1tWLFgsY3QsZnQsSyxRLEQsTF06W0QsTCxLLFEsY3QsZnQsVixYXX1BLl9zcGxpdEN1cnZlcz1mdW5jdGlvbihELEwpe2Zvcih2YXIgUz0wLFQ9MDtTPEw7UysrKXt2YXIgaj1EW1RdLCQ9YihqWzBdLGpbMV0salsyXSxqWzNdLGpbNF0sals1XSxqWzZdLGpbN10sLjUpO0Quc3BsaWNlKFQsMSksRC5zcGxpY2UoVCwwLCQubGVmdCwkLnJpZ2h0KSxUKz0yLFQ+PUQubGVuZ3RoLTEmJihUPTApfX07ZnVuY3Rpb24gUChELEwpe2Zvcih2YXIgUz1mdW5jdGlvbigkKXt2YXIgdz1EW0QubGVuZ3RoLTFdLEo9W107dy5mb3JFYWNoKGZ1bmN0aW9uKHEpe0oucHVzaChxLnNsaWNlKDApKX0pLEQucHVzaChKKX0sVD0wO1Q8TDtUKyspUygpfXJldHVybiBBLmxlcnA9ZnVuY3Rpb24oRCxMLFMpe3JldHVybiBBLl9sZXJwKEEucGF0aDJzaGFwZXMoRCksQS5wYXRoMnNoYXBlcyhMKSxTKX0sQS5NSU1fQ1VSVkVTX0NPVU5UPTEwMCxBLl9wcmVwcm9jZXNzaW5nPWZ1bmN0aW9uKEQsTCl7dmFyIFM9RC5sZW5ndGgsVD1MLmxlbmd0aCxqPUpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoRCkpLCQ9SlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShMKSk7cmV0dXJuIFM+VD9QKCQsUy1UKTpTPFQmJlAoaixULVMpLGo9cyhqLCQpLGouZm9yRWFjaChmdW5jdGlvbih3LEope3ZhciBxPXcubGVuZ3RoLFc9JFtKXS5sZW5ndGg7cT5XP3E8QS5NSU1fQ1VSVkVTX0NPVU5UPyhBLl9zcGxpdEN1cnZlcyh3LEEuTUlNX0NVUlZFU19DT1VOVC1xKSxBLl9zcGxpdEN1cnZlcygkW0pdLEEuTUlNX0NVUlZFU19DT1VOVC1XKSk6QS5fc3BsaXRDdXJ2ZXMoJFtKXSxxLVcpOnE8VyYmKFc8QS5NSU1fQ1VSVkVTX0NPVU5UPyhBLl9zcGxpdEN1cnZlcyh3LEEuTUlNX0NVUlZFU19DT1VOVC1xKSxBLl9zcGxpdEN1cnZlcygkW0pdLEEuTUlNX0NVUlZFU19DT1VOVC1XKSk6QS5fc3BsaXRDdXJ2ZXModyxXLXEpKX0pLGouZm9yRWFjaChmdW5jdGlvbih3LEope2pbSl09cih3LCRbSl0pfSksW2osJF19LEEuX2xlcnA9ZnVuY3Rpb24oRCxMLFMpe3ZhciBUPVtdO3JldHVybiBELmZvckVhY2goZnVuY3Rpb24oaiwkKXt2YXIgdz1bXTtqLmZvckVhY2goZnVuY3Rpb24oSixxKXt3LnB1c2goQS5sZXJwQ3VydmUoSixMWyRdW3FdLFMpKX0pLFQucHVzaCh3KX0pLFR9LEEuYW5pbWF0ZT1mdW5jdGlvbihEKXt2YXIgTD1BLnBhdGgyc2hhcGVzKEQuZnJvbSksUz1BLnBhdGgyc2hhcGVzKEQudG8pLFQ9QS5fcHJlcHJvY2Vzc2luZyhMLFMpLGo9bmV3IERhdGUsJD1ELmVuZHx8ZnVuY3Rpb24oKXt9LHc9RC5wcm9ncmVzc3x8ZnVuY3Rpb24oKXt9LEo9RC5iZWdpbnx8ZnVuY3Rpb24oKXt9LHE9RC5lYXNpbmd8fGZ1bmN0aW9uKF8pe3JldHVybiBffSxXPW51bGwsSz1udWxsLFE9RC50aW1lO0ooTCk7dmFyIHR0PWZ1bmN0aW9uIF8oKXt2YXIgc3Q9bmV3IERhdGUtajtpZihzdD49USl7Sz1TLHcoSywxKSwkKEspLGNhbmNlbEFuaW1hdGlvbkZyYW1lKFcpO3JldHVybn12YXIgaz1xKHN0L1EpO0s9QS5fbGVycChUWzBdLFRbMV0sayksdyhLLGspLFc9cmVxdWVzdEFuaW1hdGlvbkZyYW1lKF8pfTt0dCgpfSxBfSl9LGZ1bmN0aW9uKFIsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIGh9KTt2YXIgaT10KDcxKSxvPXQoMjIxKSxnPXQoNzIpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCB2PVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZURlZmF1bHQiKSxjPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZSIpLGY9U3ltYm9sLmZvcigic3ByaXRlanNfZ2V0QXR0cmlidXRlIik7Y2xhc3MgaCBleHRlbmRzIGkuZGVmYXVsdHtjb25zdHJ1Y3RvcihsKXtzdXBlcihsKSx0aGlzW3ZdKHtkOiIiLG5vcm1hbGl6ZTohMSxmaWxsQ29sb3I6dm9pZCAwLGZpbGxSdWxlOiJub256ZXJvIixzdHJva2VDb2xvcjp2b2lkIDAsbGluZVdpZHRoOjEsbGluZUpvaW46Im1pdGVyIixsaW5lQ2FwOiJidXR0Iixyb3VuZFNlZ21lbnRzOjIwLGxpbmVEYXNoOnZvaWQgMCxsaW5lRGFzaE9mZnNldDowLG1pdGVyTGltaXQ6MTAsdGV4dHVyZTp2b2lkIDAsdGV4dHVyZVJlY3Q6dm9pZCAwLHRleHR1cmVSZXBlYXQ6ITEsc291cmNlUmVjdDp2b2lkIDAsY2xpcFBhdGg6dm9pZCAwfSl9Z2V0IGQoKXtyZXR1cm4gdGhpc1tmXSgiZCIpfXNldCBkKGwpe3RoaXNbY10oImQiLGwpfWdldCBub3JtYWxpemUoKXtyZXR1cm4gdGhpc1tmXSgibm9ybWFsaXplIil9c2V0IG5vcm1hbGl6ZShsKXt0aGlzW2NdKCJub3JtYWxpemUiLCEhbCl9Z2V0IGZpbGxDb2xvcigpe3JldHVybiB0aGlzW2ZdKCJmaWxsQ29sb3IiKX1zZXQgZmlsbENvbG9yKGwpe3RoaXNbY10oImZpbGxDb2xvciIsT2JqZWN0KG8ucGFyc2VDb2xvcikobCkpfWdldCBmaWxsUnVsZSgpe3JldHVybiB0aGlzW2ZdKCJmaWxsUnVsZSIpfXNldCBmaWxsUnVsZShsKXtpZihsIT1udWxsJiZsIT09Im5vbnplcm8iJiZsIT09ImV2ZW5vZGQiKXRocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgZmlsbCBydWxlLiIpO3RoaXNbY10oImZpbGxSdWxlIixsKX1nZXQgc3Ryb2tlQ29sb3IoKXtyZXR1cm4gdGhpc1tmXSgic3Ryb2tlQ29sb3IiKX1zZXQgc3Ryb2tlQ29sb3IobCl7dGhpc1tjXSgic3Ryb2tlQ29sb3IiLE9iamVjdChvLnBhcnNlQ29sb3IpKGwpKX1nZXQgbGluZVdpZHRoKCl7cmV0dXJuIHRoaXNbZl0oImxpbmVXaWR0aCIpfXNldCBsaW5lV2lkdGgobCl7dGhpc1tjXSgibGluZVdpZHRoIixPYmplY3QoZy50b051bWJlcikobCkpfWdldCBsaW5lSm9pbigpe3JldHVybiB0aGlzW2ZdKCJsaW5lSm9pbiIpfXNldCBsaW5lSm9pbihsKXtpZihsIT1udWxsJiZsIT09Im1pdGVyIiYmbCE9PSJiZXZlbCImJmwhPT0icm91bmQiKXRocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgbGluZUpvaW4gdHlwZS4iKTt0aGlzW2NdKCJsaW5lSm9pbiIsbCl9Z2V0IGxpbmVDYXAoKXtyZXR1cm4gdGhpc1tmXSgibGluZUNhcCIpfXNldCBsaW5lQ2FwKGwpe2lmKGwhPW51bGwmJmwhPT0iYnV0dCImJmwhPT0ic3F1YXJlIiYmbCE9PSJyb3VuZCIpdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCBsaW5lQ2FwIHR5cGUuIik7dGhpc1tjXSgibGluZUNhcCIsbCl9Z2V0IGxpbmVEYXNoKCl7cmV0dXJuIHRoaXNbZl0oImxpbmVEYXNoIil9c2V0IGxpbmVEYXNoKGwpe2w9T2JqZWN0KGcudG9BcnJheSkobCwhMCksbCE9bnVsbCYmIUFycmF5LmlzQXJyYXkobCkmJihsPVtsXSksdGhpc1tjXSgibGluZURhc2giLGw/bC5tYXAoZy50b051bWJlcik6bnVsbCl9Z2V0IGxpbmVEYXNoT2Zmc2V0KCl7cmV0dXJuIHRoaXNbZl0oImxpbmVEYXNoT2Zmc2V0Iil9c2V0IGxpbmVEYXNoT2Zmc2V0KGwpe3RoaXNbY10oImxpbmVEYXNoT2Zmc2V0IixPYmplY3QoZy50b051bWJlcikobCkpfWdldCBtaXRlckxpbWl0KCl7cmV0dXJuIHRoaXNbZl0oIm1pdGVyTGltaXQiKX1zZXQgbWl0ZXJMaW1pdChsKXt0aGlzW2NdKCJtaXRlckxpbWl0IixPYmplY3QoZy50b051bWJlcikobCkpfWdldCByb3VuZFNlZ21lbnRzKCl7cmV0dXJuIHRoaXNbZl0oInJvdW5kU2VnbWVudHMiKX1zZXQgcm91bmRTZWdtZW50cyhsKXt0aGlzW2NdKCJyb3VuZFNlZ21lbnRzIixsKX1nZXQgdGV4dHVyZSgpe3JldHVybiB0aGlzW2ZdKCJ0ZXh0dXJlIil9c2V0IHRleHR1cmUobCl7dGhpc1tjXSgidGV4dHVyZSIsbCl9Z2V0IHRleHR1cmVSZWN0KCl7cmV0dXJuIHRoaXNbZl0oInRleHR1cmVSZWN0Iil9c2V0IHRleHR1cmVSZWN0KGwpe3RoaXNbY10oInRleHR1cmVSZWN0IixsKX1nZXQgc291cmNlUmVjdCgpe3JldHVybiB0aGlzW2ZdKCJzb3VyY2VSZWN0Iil9c2V0IHNvdXJjZVJlY3QobCl7dGhpc1tjXSgic291cmNlUmVjdCIsbCl9Z2V0IHRleHR1cmVSZXBlYXQoKXtyZXR1cm4gdGhpc1tmXSgidGV4dHVyZVJlcGVhdCIpfXNldCB0ZXh0dXJlUmVwZWF0KGwpe3RoaXNbY10oInRleHR1cmVSZXBlYXQiLCEhbCl9Z2V0IGNsaXBQYXRoKCl7cmV0dXJuIHRoaXNbZl0oImNsaXBQYXRoIil9c2V0IGNsaXBQYXRoKGwpe3RoaXNbY10oImNsaXBQYXRoIixsKX19fSxmdW5jdGlvbihSLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBjfSk7dmFyIGk9dCgyMjYpLG89dCgyMTMpLGc9dCgyMzApO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiB2KGYsaCxFKXtyZXR1cm4gaCBpbiBmP09iamVjdC5kZWZpbmVQcm9wZXJ0eShmLGgse3ZhbHVlOkUsZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTpmW2hdPUUsZn1jbGFzcyBjIGV4dGVuZHMgaS5kZWZhdWx0e2dldCBpc1Zpc2libGUoKXtjb25zdHt3aWR0aDpoLGhlaWdodDpFfT10aGlzLmF0dHJpYnV0ZXM7cmV0dXJuIGg+MCYmRT4wJiZzdXBlci5pc1Zpc2libGV9fXYoYywiQXR0ciIsZy5kZWZhdWx0KSxvLmRlZmF1bHQucmVnaXN0ZXJOb2RlKGMsInJlY3QiKX0sZnVuY3Rpb24oUixlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gRX0pO3ZhciBpPXQoMjI4KSxvPXQoNzIpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCBnPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZURlZmF1bHQiKSx2PVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZSIpLGM9U3ltYm9sLmZvcigic3ByaXRlanNfZ2V0QXR0cmlidXRlIiksZj1TeW1ib2wuZm9yKCJzcHJpdGVqc19kZWNsYXJlQWxpYXMiKTtmdW5jdGlvbiBoKGwpe2NvbnN0e3dpZHRoOm0saGVpZ2h0OnB9PWw7cmV0dXJuYE0wIDBMJHttfSAwTCR7bX0gJHtwfUwwICR7cH1aYH1jbGFzcyBFIGV4dGVuZHMgaS5kZWZhdWx0e2NvbnN0cnVjdG9yKG0pe3N1cGVyKG0pLHRoaXNbZ10oe3dpZHRoOjAsaGVpZ2h0OjB9KSx0aGlzW2ZdKCJzaXplIil9Z2V0IGQoKXtyZXR1cm4gdGhpc1tjXSgiZCIpfXNldCBkKG0pe31nZXQgd2lkdGgoKXtyZXR1cm4gdGhpc1tjXSgid2lkdGgiKX1zZXQgd2lkdGgobSl7aWYobT1PYmplY3Qoby50b051bWJlcikobSksdGhpc1t2XSgid2lkdGgiLG0pKXtjb25zdCBwPWgodGhpcyk7dGhpc1t2XSgiZCIscCl9fWdldCBoZWlnaHQoKXtyZXR1cm4gdGhpc1tjXSgiaGVpZ2h0Iil9c2V0IGhlaWdodChtKXtpZihtPU9iamVjdChvLnRvTnVtYmVyKShtKSx0aGlzW3ZdKCJoZWlnaHQiLG0pKXtjb25zdCBwPWgodGhpcyk7dGhpc1t2XSgiZCIscCl9fWdldCBzaXplKCl7cmV0dXJuW3RoaXMud2lkdGgsdGhpcy5oZWlnaHRdfXNldCBzaXplKG0pe209T2JqZWN0KG8udG9BcnJheSkobSksQXJyYXkuaXNBcnJheShtKXx8KG09W20sbV0pLHRoaXMud2lkdGg9bVswXSx0aGlzLmhlaWdodD1tWzFdfX19LGZ1bmN0aW9uKFIsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIGN9KTt2YXIgaT10KDIzMiksbz10KDIxMyksZz10KDIzNSk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIHYoZixoLEUpe3JldHVybiBoIGluIGY/T2JqZWN0LmRlZmluZVByb3BlcnR5KGYsaCx7dmFsdWU6RSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOmZbaF09RSxmfWNsYXNzIGMgZXh0ZW5kcyBpLmRlZmF1bHR7Z2V0IGlzVmlzaWJsZSgpe2NvbnN0e3NpZGVzOmh9PXRoaXMuYXR0cmlidXRlcztyZXR1cm4gaFswXT4wJiZoWzFdPjAmJnN1cGVyLmlzVmlzaWJsZX19dihjLCJBdHRyIixnLmRlZmF1bHQpLG8uZGVmYXVsdC5yZWdpc3Rlck5vZGUoYywidHJpYW5nbGUiKX0sZnVuY3Rpb24oUixlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gY30pO3ZhciBpPXQoMjI2KSxvPXQoMjEzKSxnPXQoMjMzKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gdihmLGgsRSl7cmV0dXJuIGggaW4gZj9PYmplY3QuZGVmaW5lUHJvcGVydHkoZixoLHt2YWx1ZTpFLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6ZltoXT1FLGZ9Y2xhc3MgYyBleHRlbmRzIGkuZGVmYXVsdHtnZXQgaXNWaXNpYmxlKCl7Y29uc3R7cG9pbnRzOmh9PXRoaXMuYXR0cmlidXRlcztyZXR1cm4gaC5sZW5ndGg+MCYmc3VwZXIuaXNWaXNpYmxlfX12KGMsIkF0dHIiLGcuZGVmYXVsdCksby5kZWZhdWx0LnJlZ2lzdGVyTm9kZShjLCJwb2x5bGluZSIpfSxmdW5jdGlvbihSLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBsfSk7dmFyIGk9dCgyMjgpLG89dCg3MiksZz10KDIzNCk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IHY9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlRGVmYXVsdCIpLGM9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlIiksZj1TeW1ib2wuZm9yKCJzcHJpdGVqc19nZXRBdHRyaWJ1dGUiKSxoPVN5bWJvbC5mb3IoInNwcml0ZWpzX2RlY2xhcmVBbGlhcyIpO2Z1bmN0aW9uIEUobSl7Y29uc3R7cG9pbnRzOnAsc21vb3RoOkMsc21vb3RoUmFuZ2U6eCxjbG9zZTpkfT1tLHk9W107Zm9yKGxldCBzPTA7czxwLmxlbmd0aDtzKz0yKXkucHVzaChbcFtzXSxwW3MrMV1dKTtsZXQgcj0iIjtyZXR1cm4gQz9yPU9iamVjdChnLm1ha2VTbW9vdGhDdXJ2ZUxpbmUpKHkseCk6eS5sZW5ndGgmJihyPWBNJHt5Lm1hcChzPT5zLmpvaW4oIiAiKSkuam9pbigiTCIpfWApLHImJmQmJihyKz0iWiIpLHJ9Y2xhc3MgbCBleHRlbmRzIGkuZGVmYXVsdHtjb25zdHJ1Y3RvcihwKXtzdXBlcihwKSx0aGlzW3ZdKHtwb2ludHM6W10sc21vb3RoOiExLHNtb290aFJhbmdlOlswXSxjbG9zZVR5cGU6Im5vbmUifSksdGhpc1toXSgiY2xvc2UiKX1nZXQgZCgpe3JldHVybiB0aGlzW2ZdKCJkIil9c2V0IGQocCl7fWdldCBjbG9zZSgpe3JldHVybiB0aGlzLmNsb3NlVHlwZSE9PSJub25lIn1zZXQgY2xvc2UocCl7cD1wPyJub3JtYWwiOiJub25lIix0aGlzLmNsb3NlVHlwZT1wfWdldCBjbG9zZVR5cGUoKXtyZXR1cm4gdGhpc1tmXSgiY2xvc2VUeXBlIil9c2V0IGNsb3NlVHlwZShwKXtpZihwIT1udWxsJiZwIT09Im5vbmUiJiZwIT09Im5vcm1hbCIpdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCBjbG9zZVR5cGUgdHlwZS4iKTtpZih0aGlzW2NdKCJjbG9zZVR5cGUiLHApKXtjb25zdCBDPUUodGhpcyk7dGhpc1tjXSgiZCIsQyl9fWdldCBzbW9vdGgoKXtyZXR1cm4gdGhpc1tmXSgic21vb3RoIil9c2V0IHNtb290aChwKXtpZih0aGlzW2NdKCJzbW9vdGgiLHApKXtjb25zdCBDPUUodGhpcyk7dGhpc1tjXSgiZCIsQyl9fWdldCBzbW9vdGhSYW5nZSgpe3JldHVybiB0aGlzW2ZdKCJzbW9vdGhSYW5nZSIpfXNldCBzbW9vdGhSYW5nZShwKXtpZihwJiYhQXJyYXkuaXNBcnJheShwKSYmKHA9W3BdKSx0aGlzW2NdKCJzbW9vdGhSYW5nZSIscCkmJnRoaXMuc21vb3RoKXtjb25zdCBDPUUodGhpcyk7dGhpc1tjXSgiZCIsQyl9fWdldCBwb2ludHMoKXtyZXR1cm4gdGhpc1tmXSgicG9pbnRzIil9c2V0IHBvaW50cyhwKXtpZihwPU9iamVjdChvLnRvQXJyYXkpKHApLEFycmF5LmlzQXJyYXkocCkmJihwPXAucmVkdWNlKChDLHgpPT5BcnJheS5pc0FycmF5KHgpP1suLi5DLC4uLngubWFwKGQ9Pk9iamVjdChvLnRvTnVtYmVyKShkKSldOlsuLi5DLE9iamVjdChvLnRvTnVtYmVyKSh4KV0sW10pKSx0aGlzW2NdKCJwb2ludHMiLHApKXtjb25zdCBDPUUodGhpcyk7dGhpc1tjXSgiZCIsQyl9fX19LGZ1bmN0aW9uKFIsZSx0KXt0LnIoZSksdC5kKGUsIm1ha2VTbW9vdGhDdXJ2ZUxpbmUiLGZ1bmN0aW9uKCl7cmV0dXJuIGl9KSx0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gaShvLGc9WzBdKXtmdW5jdGlvbiB2KGgsRT0uMTY4LGw9LjE2OCl7bGV0IG0scCxDLHg7aWYoKG9baF0ueD09PW9baCsxXS54fHxvW2hdLnk9PT1vW2grMV0ueSkmJihFPTAsbD0wKSxoPDE/KG09b1swXS54KyhvWzFdLngtb1swXS54KSpFLHA9b1swXS55KyhvWzFdLnktb1swXS55KSpFKToobT1vW2hdLngrKG9baCsxXS54LW9baC0xXS54KSpFLHA9b1toXS55KyhvW2grMV0ueS1vW2gtMV0ueSkqRSksaD5vLmxlbmd0aC0zKXtjb25zdCBkPW8ubGVuZ3RoLTE7Qz1vW2RdLngtKG9bZF0ueC1vW2QtMV0ueCkqbCx4PW9bZF0ueS0ob1tkXS55LW9bZC0xXS55KSpsfWVsc2UgQz1vW2grMV0ueC0ob1toKzJdLngtb1toXS54KSpsLHg9b1toKzFdLnktKG9baCsyXS55LW9baF0ueSkqbDtyZXR1cm5be3g6bSx5OnB9LHt4OkMseTp4fV19bz1vLm1hcCgoW2gsRV0pPT4oe3g6aCx5OkV9KSk7bGV0IGM9IiIsZj0wO3JldHVybiBvLmZvckVhY2goKGgsRSk9PntpZihFPT09MCljKz1gTSR7aC54fSAke2gueX1gO2Vsc2V7Zm9yKDtFPmdbZl07KWYrKztpZihmJTIpe2NvbnN0W2wsbV09dihFLTEpO2MrPWBDJHtbbC54LGwueSxtLngsbS55LGgueCxoLnldLmpvaW4oIiAiKX1gfWVsc2UgYys9YEwke2gueH0gJHtoLnl9YH19KSxjfX0sZnVuY3Rpb24oUixlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gaH0pO3ZhciBpPXQoMjMzKSxvPXQoNzIpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCBnPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZURlZmF1bHQiKSx2PVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZSIpLGM9U3ltYm9sLmZvcigic3ByaXRlanNfZ2V0QXR0cmlidXRlIik7ZnVuY3Rpb24gZihFKXtjb25zdFtsLG1dPUUuc2lkZXM7bGV0IHA9RS5hbmdsZSUzNjA7cmV0dXJuIHA8MCYmKHArPTM2MCkscD1NYXRoLlBJKnAvMTgwLFswLDAsbCwwLG0qTWF0aC5jb3MocCksbSpNYXRoLnNpbihwKV19Y2xhc3MgaCBleHRlbmRzIGkuZGVmYXVsdHtjb25zdHJ1Y3RvcihsKXtzdXBlcihsKSx0aGlzW2ddKHtzaWRlczpbMCwwXSxhbmdsZTo2MCxjbG9zZVR5cGU6Im5vcm1hbCJ9KX1nZXQgcG9pbnRzKCl7cmV0dXJuIHN1cGVyLnBvaW50c31zZXQgcG9pbnRzKGwpe31nZXQgc2lkZXMoKXtyZXR1cm4gdGhpc1tjXSgic2lkZXMiKX1zZXQgc2lkZXMobCl7aWYobD1PYmplY3Qoby50b0FycmF5KShsLCEwKSxsIT1udWxsJiYhQXJyYXkuaXNBcnJheShsKSYmKGw9W2wsbF0pLHRoaXNbdl0oInNpZGVzIixsKSl7Y29uc3QgbT1mKHRoaXMpO3N1cGVyLnBvaW50cz1tfX1nZXQgYW5nbGUoKXtyZXR1cm4gdGhpc1tjXSgiYW5nbGUiKX1zZXQgYW5nbGUobCl7aWYobD1PYmplY3Qoby50b051bWJlcikobCksdGhpc1t2XSgiYW5nbGUiLGwpKXtjb25zdCBtPWYodGhpcyk7c3VwZXIucG9pbnRzPW19fX19LGZ1bmN0aW9uKFIsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIGN9KTt2YXIgaT10KDIzMiksbz10KDIxMyksZz10KDIzNyk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIHYoZixoLEUpe3JldHVybiBoIGluIGY/T2JqZWN0LmRlZmluZVByb3BlcnR5KGYsaCx7dmFsdWU6RSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOmZbaF09RSxmfWNsYXNzIGMgZXh0ZW5kcyBpLmRlZmF1bHR7Z2V0IGlzVmlzaWJsZSgpe2NvbnN0e3NpZGVzOmh9PXRoaXMuYXR0cmlidXRlcztyZXR1cm4gaFswXT4wJiZoWzFdPjAmJnN1cGVyLmlzVmlzaWJsZX19dihjLCJBdHRyIixnLmRlZmF1bHQpLG8uZGVmYXVsdC5yZWdpc3Rlck5vZGUoYywicGFyYWxsZWwiKX0sZnVuY3Rpb24oUixlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gaH0pO3ZhciBpPXQoMjMzKSxvPXQoNzIpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCBnPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZURlZmF1bHQiKSx2PVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZSIpLGM9U3ltYm9sLmZvcigic3ByaXRlanNfZ2V0QXR0cmlidXRlIik7ZnVuY3Rpb24gZihFKXtjb25zdFtsLG1dPUUuc2lkZXM7bGV0IHA9RS5hbmdsZSUzNjA7cDwwJiYocCs9MzYwKSxwPU1hdGguUEkqcC8xODA7Y29uc3QgQz1tKk1hdGguY29zKHApLHg9bSpNYXRoLnNpbihwKTtyZXR1cm5bMCwwLGwsMCxDK2wseCxDLHhdfWNsYXNzIGggZXh0ZW5kcyBpLmRlZmF1bHR7Y29uc3RydWN0b3IobCl7c3VwZXIobCksdGhpc1tnXSh7c2lkZXM6WzAsMF0sYW5nbGU6OTAsY2xvc2VUeXBlOiJub3JtYWwifSl9Z2V0IHBvaW50cygpe3JldHVybiBzdXBlci5wb2ludHN9c2V0IHBvaW50cyhsKXt9Z2V0IHNpZGVzKCl7cmV0dXJuIHRoaXNbY10oInNpZGVzIil9c2V0IHNpZGVzKGwpe2lmKGw9T2JqZWN0KG8udG9BcnJheSkobCwhMCksbCE9bnVsbCYmIUFycmF5LmlzQXJyYXkobCkmJihsPVtsLGxdKSx0aGlzW3ZdKCJzaWRlcyIsbCkpe2NvbnN0IG09Zih0aGlzKTtzdXBlci5wb2ludHM9bX19Z2V0IGFuZ2xlKCl7cmV0dXJuIHRoaXNbY10oImFuZ2xlIil9c2V0IGFuZ2xlKGwpe2lmKGw9T2JqZWN0KG8udG9OdW1iZXIpKGwpLHRoaXNbdl0oImFuZ2xlIixsKSl7Y29uc3QgbT1mKHRoaXMpO3N1cGVyLnBvaW50cz1tfX19fSxmdW5jdGlvbihSLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBjfSk7dmFyIGk9dCgyMzIpLG89dCgyMTMpLGc9dCgyMzkpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiB2KGYsaCxFKXtyZXR1cm4gaCBpbiBmP09iamVjdC5kZWZpbmVQcm9wZXJ0eShmLGgse3ZhbHVlOkUsZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTpmW2hdPUUsZn1jbGFzcyBjIGV4dGVuZHMgaS5kZWZhdWx0e312KGMsIkF0dHIiLGcuZGVmYXVsdCksby5kZWZhdWx0LnJlZ2lzdGVyTm9kZShjLCJyZWd1bGFyIil9LGZ1bmN0aW9uKFIsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIGh9KTt2YXIgaT10KDIzMyksbz10KDcyKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3QgZz1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGVEZWZhdWx0Iiksdj1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGUiKSxjPVN5bWJvbC5mb3IoInNwcml0ZWpzX2dldEF0dHJpYnV0ZSIpO2Z1bmN0aW9uIGYoRSl7Y29uc3R7ZWRnZXM6bCxyYWRpdXM6bSxvZmZzZXRBbmdsZTpwfT1FLEM9TWF0aC5QSSpwLzE4MC0uNSpNYXRoLlBJO2lmKGw8M3x8bTw9MClyZXR1cm5bXTtjb25zdCB4PVtdO2ZvcihsZXQgZD0wO2Q8bDtkKyspe2NvbnN0IHk9ZCoyKk1hdGguUEkvbCtDLHI9bSpNYXRoLmNvcyh5KSxzPW0qTWF0aC5zaW4oeSk7eC5wdXNoKHIscyl9cmV0dXJuIHh9Y2xhc3MgaCBleHRlbmRzIGkuZGVmYXVsdHtjb25zdHJ1Y3RvcihsKXtzdXBlcihsKSx0aGlzW2ddKHtlZGdlczozLHJhZGl1czowLG9mZnNldEFuZ2xlOjAsY2xvc2VUeXBlOiJub3JtYWwifSl9Z2V0IHBvaW50cygpe3JldHVybiBzdXBlci5wb2ludHN9c2V0IHBvaW50cyhsKXt9Z2V0IGVkZ2VzKCl7cmV0dXJuIHRoaXNbY10oImVkZ2VzIil9c2V0IGVkZ2VzKGwpe2lmKGw9T2JqZWN0KG8udG9OdW1iZXIpKGwpLHRoaXNbdl0oImVkZ2VzIixsKSl7Y29uc3QgbT1mKHRoaXMpO3N1cGVyLnBvaW50cz1tfX1nZXQgcmFkaXVzKCl7cmV0dXJuIHRoaXNbY10oInJhZGl1cyIpfXNldCByYWRpdXMobCl7aWYobD1PYmplY3Qoby50b051bWJlcikobCksdGhpc1t2XSgicmFkaXVzIixsKSl7Y29uc3QgbT1mKHRoaXMpO3N1cGVyLnBvaW50cz1tfX1nZXQgb2Zmc2V0QW5nbGUoKXtyZXR1cm4gdGhpc1tjXSgib2Zmc2V0QW5nbGUiKX1zZXQgb2Zmc2V0QW5nbGUobCl7aWYobD1PYmplY3Qoby50b051bWJlcikobCksdGhpc1t2XSgib2Zmc2V0QW5nbGUiLGwpKXtjb25zdCBtPWYodGhpcyk7c3VwZXIucG9pbnRzPW19fX19LGZ1bmN0aW9uKFIsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIGN9KTt2YXIgaT10KDIzMiksbz10KDIxMyksZz10KDI0MSk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIHYoZixoLEUpe3JldHVybiBoIGluIGY/T2JqZWN0LmRlZmluZVByb3BlcnR5KGYsaCx7dmFsdWU6RSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOmZbaF09RSxmfWNsYXNzIGMgZXh0ZW5kcyBpLmRlZmF1bHR7fXYoYywiQXR0ciIsZy5kZWZhdWx0KSxvLmRlZmF1bHQucmVnaXN0ZXJOb2RlKGMsInN0YXIiKX0sZnVuY3Rpb24oUixlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gaH0pO3ZhciBpPXQoMjMzKSxvPXQoNzIpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCBnPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZURlZmF1bHQiKSx2PVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZSIpLGM9U3ltYm9sLmZvcigic3ByaXRlanNfZ2V0QXR0cmlidXRlIik7ZnVuY3Rpb24gZihFKXtjb25zdHthbmdsZXM6bCxpbm5lclJhZGl1czptLG91dGVyUmFkaXVzOnAsb2Zmc2V0QW5nbGU6Q309RSx4PU1hdGguUEkqQy8xODAtLjUqTWF0aC5QSTtpZihsPDN8fG08PTB8fHA8PTApcmV0dXJuW107Y29uc3QgZD1bXTtmb3IobGV0IHk9MDt5PGwqMjt5Kyspe2NvbnN0IHI9eSpNYXRoLlBJL2wreCxzPXklMj9tOnAsbj1zKk1hdGguY29zKHIpLGE9cypNYXRoLnNpbihyKTtkLnB1c2gobixhKX1yZXR1cm4gZH1jbGFzcyBoIGV4dGVuZHMgaS5kZWZhdWx0e2NvbnN0cnVjdG9yKGwpe3N1cGVyKGwpLHRoaXNbZ10oe2FuZ2xlczo1LGlubmVyUmFkaXVzOjAsb3V0ZXJSYWRpdXM6MCxvZmZzZXRBbmdsZTowLGNsb3NlVHlwZToibm9ybWFsIn0pfWdldCBwb2ludHMoKXtyZXR1cm4gc3VwZXIucG9pbnRzfXNldCBwb2ludHMobCl7fWdldCBhbmdsZXMoKXtyZXR1cm4gdGhpc1tjXSgiYW5nbGVzIil9c2V0IGFuZ2xlcyhsKXtpZihsPU9iamVjdChvLnRvTnVtYmVyKShsKSx0aGlzW3ZdKCJhbmdsZXMiLGwpKXtjb25zdCBtPWYodGhpcyk7c3VwZXIucG9pbnRzPW19fWdldCBpbm5lclJhZGl1cygpe3JldHVybiB0aGlzW2NdKCJpbm5lclJhZGl1cyIpfXNldCBpbm5lclJhZGl1cyhsKXtpZihsPU9iamVjdChvLnRvTnVtYmVyKShsKSx0aGlzW3ZdKCJpbm5lclJhZGl1cyIsbCkpe2NvbnN0IG09Zih0aGlzKTtzdXBlci5wb2ludHM9bX19Z2V0IG91dGVyUmFkaXVzKCl7cmV0dXJuIHRoaXNbY10oIm91dGVyUmFkaXVzIil9c2V0IG91dGVyUmFkaXVzKGwpe2lmKGw9T2JqZWN0KG8udG9OdW1iZXIpKGwpLHRoaXNbdl0oIm91dGVyUmFkaXVzIixsKSl7Y29uc3QgbT1mKHRoaXMpO3N1cGVyLnBvaW50cz1tfX1nZXQgcmFkaXVzKCl7cmV0dXJuW3RoaXMuaW5uZXJSYWRpdXMsdGhpcy5vdXRlclJhZGl1c119c2V0IHJhZGl1cyhsKXtsPU9iamVjdChvLnRvQXJyYXkpKGwsITApLEFycmF5LmlzQXJyYXkobCl8fChsPVtsLGxdKSx0aGlzLmlubmVyUmFkaXVzPWxbMF0sdGhpcy5vdXRlclJhZGl1cz1sWzFdfWdldCBvZmZzZXRBbmdsZSgpe3JldHVybiB0aGlzW2NdKCJvZmZzZXRBbmdsZSIpfXNldCBvZmZzZXRBbmdsZShsKXtpZihsPU9iamVjdChvLnRvTnVtYmVyKShsKSx0aGlzW3ZdKCJvZmZzZXRBbmdsZSIsbCkpe2NvbnN0IG09Zih0aGlzKTtzdXBlci5wb2ludHM9bX19fX0sZnVuY3Rpb24oUixlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gY30pO3ZhciBpPXQoMjI2KSxvPXQoMjEzKSxnPXQoMjQzKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gdihmLGgsRSl7cmV0dXJuIGggaW4gZj9PYmplY3QuZGVmaW5lUHJvcGVydHkoZixoLHt2YWx1ZTpFLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6ZltoXT1FLGZ9Y2xhc3MgYyBleHRlbmRzIGkuZGVmYXVsdHtnZXQgaXNWaXNpYmxlKCl7Y29uc3R7cmFkaXVzWDpoLHJhZGl1c1k6RSxzdGFydEFuZ2xlOmwsZW5kQW5nbGU6bX09dGhpcy5hdHRyaWJ1dGVzO3JldHVybiBoPjAmJkU+MCYmbCE9PW0mJnN1cGVyLmlzVmlzaWJsZX19dihjLCJBdHRyIixnLmRlZmF1bHQpLG8uZGVmYXVsdC5yZWdpc3Rlck5vZGUoYywiZWxsaXBzZSIpfSxmdW5jdGlvbihSLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBsfSk7dmFyIGk9dCgxMiksbz10KDIyOCksZz10KDcyKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3Qgdj1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGVEZWZhdWx0IiksYz1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGUiKSxmPVN5bWJvbC5mb3IoInNwcml0ZWpzX2dldEF0dHJpYnV0ZSIpLGg9U3ltYm9sLmZvcigic3ByaXRlanNfZGVjbGFyZUFsaWFzIik7ZnVuY3Rpb24gRShtKXtjb25zdHtyYWRpdXNYOnAscmFkaXVzWTpDLHN0YXJ0QW5nbGU6eCxlbmRBbmdsZTpkLGRpcmVjdGlvbjp5LGNsb3NlVHlwZTpyfT1tLHM9eT09PSJhbml0Y2xvY2t3aXNlIixuPW5ldyBpLkZpZ3VyZTJEO3JldHVybiByPT09InNlY3RvciImJm4ubW92ZVRvKDAsMCksbi5lbGxpcHNlKDAsMCxwLEMsMCxNYXRoLlBJKngvMTgwLE1hdGguUEkqZC8xODAscyksciE9PSJub25lIiYmbi5jbG9zZVBhdGgoKSxuLnBhdGgucmVkdWNlKChBLGIpPT5BK2Iuam9pbigiICIpLCIiKX1jbGFzcyBsIGV4dGVuZHMgby5kZWZhdWx0e2NvbnN0cnVjdG9yKHApe3N1cGVyKHApLHRoaXNbdl0oe3JhZGl1c1g6MCxyYWRpdXNZOjAsc3RhcnRBbmdsZTowLGVuZEFuZ2xlOjM2MCxkaXJlY3Rpb246ImNsb2Nrd2lzZSIsY2xvc2VUeXBlOiJub25lIn0pLHRoaXNbaF0oInJhZGl1cyIsImFuZ2xlIil9Z2V0IGQoKXtyZXR1cm4gdGhpc1tmXSgiZCIpfXNldCBkKHApe31nZXQgcmFkaXVzWCgpe3JldHVybiB0aGlzW2ZdKCJyYWRpdXNYIil9c2V0IHJhZGl1c1gocCl7aWYocD1PYmplY3QoZy50b051bWJlcikocCksdGhpc1tjXSgicmFkaXVzWCIscCkpe2NvbnN0IEM9RSh0aGlzKTt0aGlzW2NdKCJkIixDKX19Z2V0IHJhZGl1c1koKXtyZXR1cm4gdGhpc1tmXSgicmFkaXVzWSIpfXNldCByYWRpdXNZKHApe2lmKHA9T2JqZWN0KGcudG9OdW1iZXIpKHApLHRoaXNbY10oInJhZGl1c1kiLHApKXtjb25zdCBDPUUodGhpcyk7dGhpc1tjXSgiZCIsQyl9fWdldCByYWRpdXMoKXtyZXR1cm5bdGhpcy5yYWRpdXNYLHRoaXMucmFkaXVzWV19c2V0IHJhZGl1cyhwKXtwPU9iamVjdChnLnRvQXJyYXkpKHAsITApLEFycmF5LmlzQXJyYXkocCl8fChwPVtwLHBdKSx0aGlzLnJhZGl1c1g9cFswXSx0aGlzLnJhZGl1c1k9cFsxXX1nZXQgYW5nbGUoKXtyZXR1cm5bdGhpcy5zdGFydEFuZ2xlLHRoaXMuZW5kQW5nbGVdfXNldCBhbmdsZShwKXtwPU9iamVjdChnLnRvQXJyYXkpKHApLEFycmF5LmlzQXJyYXkocCl8fChwPVtwLHBdKSx0aGlzLnN0YXJ0QW5nbGU9cFswXSx0aGlzLmVuZEFuZ2xlPXBbMV19Z2V0IGRpcmVjdGlvbigpe3JldHVybiB0aGlzW2ZdKCJkaXJlY3Rpb24iKX1zZXQgZGlyZWN0aW9uKHApe2lmKHAhPW51bGwmJnAhPT0iY2xvY2t3aXNlIiYmcCE9PSJhbnRpY2xvY2t3aXNlIil0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIGRpcmVjdGlvbiB0eXBlLiIpO3RoaXNbY10oImRpcmVjdGlvbiIscCl9Z2V0IHN0YXJ0QW5nbGUoKXtyZXR1cm4gdGhpc1tmXSgic3RhcnRBbmdsZSIpfXNldCBzdGFydEFuZ2xlKHApe2lmKHA9T2JqZWN0KGcudG9OdW1iZXIpKHApLHRoaXNbY10oInN0YXJ0QW5nbGUiLHApKXtjb25zdCBDPUUodGhpcyk7dGhpc1tjXSgiZCIsQyl9fWdldCBlbmRBbmdsZSgpe3JldHVybiB0aGlzW2ZdKCJlbmRBbmdsZSIpfXNldCBlbmRBbmdsZShwKXtpZihwPU9iamVjdChnLnRvTnVtYmVyKShwKSx0aGlzW2NdKCJlbmRBbmdsZSIscCkpe2NvbnN0IEM9RSh0aGlzKTt0aGlzW2NdKCJkIixDKX19Z2V0IGNsb3NlVHlwZSgpe3JldHVybiB0aGlzW2ZdKCJjbG9zZVR5cGUiKX1zZXQgY2xvc2VUeXBlKHApe2lmKHAhPW51bGwmJnAhPT0ibm9uZSImJnAhPT0ic2VjdG9yIiYmcCE9PSJub3JtYWwiKXRocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgY2xvc2VUeXBlIHR5cGUuIik7aWYodGhpc1tjXSgiY2xvc2VUeXBlIixwKSl7Y29uc3QgQz1FKHRoaXMpO3RoaXNbY10oImQiLEMpfX19fSxmdW5jdGlvbihSLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBjfSk7dmFyIGk9dCgyNDIpLG89dCgyMTMpLGc9dCgyNDUpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiB2KGYsaCxFKXtyZXR1cm4gaCBpbiBmP09iamVjdC5kZWZpbmVQcm9wZXJ0eShmLGgse3ZhbHVlOkUsZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTpmW2hdPUUsZn1jbGFzcyBjIGV4dGVuZHMgaS5kZWZhdWx0e312KGMsIkF0dHIiLGcuZGVmYXVsdCksby5kZWZhdWx0LnJlZ2lzdGVyTm9kZShjLCJhcmMiKX0sZnVuY3Rpb24oUixlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gZ30pO3ZhciBpPXQoMjQzKSxvPXQoNzIpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjbGFzcyBnIGV4dGVuZHMgaS5kZWZhdWx0e2dldCByYWRpdXMoKXtyZXR1cm4gc3VwZXIucmFkaXVzWH1zZXQgcmFkaXVzKGMpe2M9T2JqZWN0KG8udG9OdW1iZXIpKGMpLHN1cGVyLnJhZGl1c1g9YyxzdXBlci5yYWRpdXNZPWN9fX0sZnVuY3Rpb24oUixlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gY30pO3ZhciBpPXQoMjI2KSxvPXQoMjEzKSxnPXQoMjQ3KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gdihmLGgsRSl7cmV0dXJuIGggaW4gZj9PYmplY3QuZGVmaW5lUHJvcGVydHkoZixoLHt2YWx1ZTpFLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6ZltoXT1FLGZ9Y2xhc3MgYyBleHRlbmRzIGkuZGVmYXVsdHtnZXQgaXNWaXNpYmxlKCl7Y29uc3R7aW5uZXJSYWRpdXM6aCxvdXRlclJhZGl1czpFLHN0YXJ0QW5nbGU6bCxlbmRBbmdsZTptfT10aGlzLmF0dHJpYnV0ZXM7cmV0dXJuKGg+MHx8RT4wKSYmbCE9PW0mJnN1cGVyLmlzVmlzaWJsZX19dihjLCJBdHRyIixnLmRlZmF1bHQpLG8uZGVmYXVsdC5yZWdpc3Rlck5vZGUoYywicmluZyIpfSxmdW5jdGlvbihSLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBsfSk7dmFyIGk9dCgxMiksbz10KDIyOCksZz10KDcyKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3Qgdj1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGVEZWZhdWx0IiksYz1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGUiKSxmPVN5bWJvbC5mb3IoInNwcml0ZWpzX2dldEF0dHJpYnV0ZSIpLGg9U3ltYm9sLmZvcigic3ByaXRlanNfZGVjbGFyZUFsaWFzIik7ZnVuY3Rpb24gRShtKXtsZXR7aW5uZXJSYWRpdXM6cCxvdXRlclJhZGl1czpDLHN0YXJ0QW5nbGU6eCxlbmRBbmdsZTpkfT1tO2NvbnN0IHk9bmV3IGkuRmlndXJlMkQ7aWYoeD1NYXRoLlBJKngvMTgwLGQ9TWF0aC5QSSpkLzE4MCxwPkMmJihbcCxDXT1bQyxwXSkscDw9MCYmeS5tb3ZlVG8oMCwwKSx5LmFyYygwLDAsQyx4LGQsITEpLHA+MCl7Y29uc3Qgbj1NYXRoLlBJKjI7ZDx4JiYoZD14K24rKGQteCklbiksZC14Pj1uJiYoZD14K24tMWUtNikseS5hcmMoMCwwLHAsZCx4LCEwKX1yZXR1cm4geS5jbG9zZVBhdGgoKSx5LnBhdGgucmVkdWNlKChuLGEpPT5uK2Euam9pbigiICIpLCIiKX1jbGFzcyBsIGV4dGVuZHMgby5kZWZhdWx0e2NvbnN0cnVjdG9yKHApe3N1cGVyKHApLHRoaXNbdl0oe2lubmVyUmFkaXVzOjAsb3V0ZXJSYWRpdXM6MCxzdGFydEFuZ2xlOjAsZW5kQW5nbGU6MzYwfSksdGhpc1toXSgicmFkaXVzIiwiYW5nbGUiKX1nZXQgZCgpe3JldHVybiB0aGlzW2ZdKCJkIil9c2V0IGQocCl7fWdldCBpbm5lclJhZGl1cygpe3JldHVybiB0aGlzW2ZdKCJpbm5lclJhZGl1cyIpfXNldCBpbm5lclJhZGl1cyhwKXtpZihwPU9iamVjdChnLnRvTnVtYmVyKShwKSx0aGlzW2NdKCJpbm5lclJhZGl1cyIscCkpe2NvbnN0IEM9RSh0aGlzKTt0aGlzW2NdKCJkIixDKX19Z2V0IG91dGVyUmFkaXVzKCl7cmV0dXJuIHRoaXNbZl0oIm91dGVyUmFkaXVzIil9c2V0IG91dGVyUmFkaXVzKHApe2lmKHA9T2JqZWN0KGcudG9OdW1iZXIpKHApLHRoaXNbY10oIm91dGVyUmFkaXVzIixwKSl7Y29uc3QgQz1FKHRoaXMpO3RoaXNbY10oImQiLEMpfX1nZXQgcmFkaXVzKCl7cmV0dXJuW3RoaXMuaW5uZXJSYWRpdXMsdGhpcy5vdXRlclJhZGl1c119c2V0IHJhZGl1cyhwKXtwPU9iamVjdChnLnRvQXJyYXkpKHAsITApLEFycmF5LmlzQXJyYXkocCl8fChwPVtwLHBdKSx0aGlzLmlubmVyUmFkaXVzPXBbMF0sdGhpcy5vdXRlclJhZGl1cz1wWzFdfWdldCBzdGFydEFuZ2xlKCl7cmV0dXJuIHRoaXNbZl0oInN0YXJ0QW5nbGUiKX1zZXQgc3RhcnRBbmdsZShwKXtpZihwPU9iamVjdChnLnRvTnVtYmVyKShwKSx0aGlzW2NdKCJzdGFydEFuZ2xlIixwKSl7Y29uc3QgQz1FKHRoaXMpO3RoaXNbY10oImQiLEMpfX1nZXQgZW5kQW5nbGUoKXtyZXR1cm4gdGhpc1tmXSgiZW5kQW5nbGUiKX1zZXQgZW5kQW5nbGUocCl7aWYocD1PYmplY3QoZy50b051bWJlcikocCksdGhpc1tjXSgiZW5kQW5nbGUiLHApKXtjb25zdCBDPUUodGhpcyk7dGhpc1tjXSgiZCIsQyl9fWdldCBhbmdsZSgpe3JldHVyblt0aGlzLnN0YXJ0QW5nbGUsdGhpcy5lbmRBbmdsZV19c2V0IGFuZ2xlKHApe3A9T2JqZWN0KGcudG9BcnJheSkocCksQXJyYXkuaXNBcnJheShwKXx8KHA9W3AscF0pLHRoaXMuc3RhcnRBbmdsZT1wWzBdLHRoaXMuZW5kQW5nbGU9cFsxXX19fSxmdW5jdGlvbihSLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBDfSk7dmFyIGk9dCgxMiksbz10KDIxOCksZz10KDIxOSksdj10KDI0OSksYz10KDIxMyk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIGYoeCxkLHkpe3JldHVybiBkIGluIHg/T2JqZWN0LmRlZmluZVByb3BlcnR5KHgsZCx7dmFsdWU6eSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOnhbZF09eSx4fWNvbnN0IGg9U3ltYm9sKCJ0ZXh0SW1hZ2UiKSxFPVN5bWJvbCgidGV4dEltYWdlVGFzayIpLGw9U3ltYm9sKCJ0ZXh0dXJlQ29udGV4dCIpLG09U3ltYm9sKCJ1cGRhdGVUZXh0dXJlUmVjdCIpLHA9U3ltYm9sKCJ0ZXh0Q2FudmFzIik7Y2xhc3MgQyBleHRlbmRzIGcuZGVmYXVsdHtjb25zdHJ1Y3RvcihkPXt9KXt0eXBlb2YgZD09InN0cmluZyImJihkPXt0ZXh0OmR9KSxzdXBlcihkKX1nZXQgY29udGVudFNpemUoKXtsZXRbZCx5XT1zdXBlci5jb250ZW50U2l6ZTtjb25zdHt3aWR0aDpyLGhlaWdodDpzfT10aGlzLmF0dHJpYnV0ZXM7aWYocj09bnVsbHx8cz09bnVsbCl7Y29uc3Qgbj10aGlzW2hdO24mJihyPT1udWxsJiYoZD1uLnJlY3RbMl0pLHM9PW51bGwmJih5PW4ucmVjdFszXSkpfXJldHVybltkLHldfWdldCB0ZXh0KCl7cmV0dXJuIHRoaXMuYXR0cmlidXRlcy50ZXh0fXNldCB0ZXh0KGQpe3RoaXMuYXR0cmlidXRlcy50ZXh0PWR9Z2V0IHRleHRDb250ZW50KCl7cmV0dXJuIHRoaXMuYXR0cmlidXRlcy50ZXh0fXNldCB0ZXh0Q29udGVudChkKXt0aGlzLmF0dHJpYnV0ZXMudGV4dD1kfWdldCB0ZXh0SW1hZ2UoKXtyZXR1cm4gdGhpc1toXXx8e319Z2V0IHRleHRJbWFnZVJlYWR5KCl7cmV0dXJuIHRoaXNbRV18fFByb21pc2UucmVzb2x2ZSgpfWRyYXcoZCl7c3VwZXIuZHJhdyhkKTtjb25zdCB5PXRoaXMubWVzaDtpZih5KXtjb25zdCByPXRoaXNbaF07aWYocil7bGV0IHM9eS50ZXh0dXJlO2lmKCFzfHx0aGlzW2xdJiZ0aGlzW2xdIT09dGhpcy5yZW5kZXJlcnx8ci5uZWVkc1VwZGF0ZT8oci5uZWVkc1VwZGF0ZT0hMSxPYmplY3Qoby5kZWxldGVUZXh0dXJlKShyLmltYWdlLHRoaXMucmVuZGVyZXIpLHM9T2JqZWN0KG8uY3JlYXRlVGV4dHVyZSkoci5pbWFnZSx0aGlzLnJlbmRlcmVyKSx0aGlzW21dPSEwKTpzPXkudW5pZm9ybXMudV90ZXhTYW1wbGVyLHRoaXNbbV0pe2NvbnN0W24sYV09ci5yZWN0LnNsaWNlKDIpLFtPLEFdPXRoaXMuY29udGVudFNpemUsYj10aGlzLmF0dHJpYnV0ZXMudGV4dEFsaWduLEk9dGhpcy5hdHRyaWJ1dGVzLnZlcnRpY2FsQWxpZ247bGV0IFA9MDtiPT09ImNlbnRlciI/UD0oTy1uKS8yOihiPT09InJpZ2h0Inx8Yj09PSJlbmQiKSYmKFA9Ty1uKTtjb25zdCBEPXRoaXMuYXR0cmlidXRlcy5mb250U2l6ZSxMPXRoaXMuYXR0cmlidXRlcy5saW5lSGVpZ2h0O2xldCBTPTA7ST09PSJ0b3AiP1M9KEQtTCkvMjpJPT09ImJvdHRvbSImJihTPShMLUQpLzIpO2NvbnN0e3BhZGRpbmdMZWZ0OlQscGFkZGluZ1RvcDpqfT10aGlzLmF0dHJpYnV0ZXMse2JvcmRlcldpZHRoOiR9PXRoaXMuYXR0cmlidXRlcztQKz1UKyQsUys9aiskO2NvbnN0e2FuY2hvclg6dyxhbmNob3JZOkp9PXRoaXMuYXR0cmlidXRlcztQLT10aGlzLm9mZnNldFNpemVbMF0qdyxTLT10aGlzLm9mZnNldFNpemVbMV0qSix5LnNldFRleHR1cmUocyx7cmVjdDpbUCxTLG4sYV19KSx0aGlzW21dPSExLHRoaXNbbF09dGhpcy5yZW5kZXJlcn19fXJldHVybiBkfW9uUHJvcGVydHlDaGFuZ2UoZCx5LHIpe2Q9PT0idGV4dCJ8fGQ9PT0iZm9udFNpemUifHxkPT09ImZvbnRGYW1pbHkifHxkPT09ImZvbnRTdHlsZSJ8fGQ9PT0iZm9udFZhcmlhbnQifHxkPT09ImZvbnRXZWlnaHQifHxkPT09ImZvbnRTdHJldGNoInx8ZD09PSJsaW5lSGVpZ2h0Inx8ZD09PSJzdHJva2VDb2xvciJ8fGQ9PT0iZmlsbENvbG9yInx8ZD09PSJzdHJva2VXaWR0aCI/dGhpcy51cGRhdGVUZXh0KCk6KChkPT09InRleHRBbGlnbiJ8fGQ9PT0idmVydGljYWxBbGlnbiIpJiYodGhpc1ttXT0hMCksc3VwZXIub25Qcm9wZXJ0eUNoYW5nZShkLHkscikpfXVwZGF0ZUNvbnRvdXJzKCl7c3VwZXIudXBkYXRlQ29udG91cnMoKSx0aGlzW21dPSEwfXVwZGF0ZVRleHQoKXt0aGlzW0VdfHwodGhpc1tFXT1Qcm9taXNlLnJlc29sdmUoKS50aGVuKCgpPT57dGhpc1tFXT1udWxsO2NvbnN0e3RleHQ6ZCxmb250OnksZmlsbENvbG9yOnIsc3Ryb2tlQ29sb3I6cyxzdHJva2VXaWR0aDpufT10aGlzLmF0dHJpYnV0ZXMsYT10aGlzLmxheWVyP3RoaXMubGF5ZXIuZGlzcGxheVJhdGlvOjE7cmV0dXJuIHRoaXNbcF09dGhpc1twXXx8aS5FTlYuY3JlYXRlQ2FudmFzKDEsMSksdGhpc1toXT1pLkVOVi5jcmVhdGVUZXh0KGQse2ZvbnQ6eSxmaWxsQ29sb3I6cixzdHJva2VDb2xvcjpzLHN0cm9rZVdpZHRoOm4scGFyc2VGb250OmkucGFyc2VGb250LHJhdGlvOmEsdGV4dENhbnZhczp0aGlzW3BdfSksdGhpc1toXS5uZWVkc1VwZGF0ZT0hMCx0aGlzLnVwZGF0ZUNvbnRvdXJzKCksdGhpcy5mb3JjZVVwZGF0ZSgpLHRoaXNbaF19KSl9fWYoQywiQXR0ciIsdi5kZWZhdWx0KSxjLmRlZmF1bHQucmVnaXN0ZXJOb2RlKEMsImxhYmVsIil9LGZ1bmN0aW9uKFIsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIGx9KTt2YXIgaT10KDEyKSxvPXQoNzIpLGc9dCgyMjEpLHY9dCgyMjApO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCBjPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZURlZmF1bHQiKSxmPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZSIpLGg9U3ltYm9sLmZvcigic3ByaXRlanNfZ2V0QXR0cmlidXRlIiksRT1TeW1ib2wuZm9yKCJzcHJpdGVqc19kZWNsYXJlQWxpYXMiKTtjbGFzcyBsIGV4dGVuZHMgdi5kZWZhdWx0e2NvbnN0cnVjdG9yKHApe3N1cGVyKHApLHRoaXNbY10oe3RleHQ6IiIsZm9udFNpemU6MTYsZm9udEZhbWlseToiSGVsdmV0aWNhLEFyaWFsLHNhbnMtc2VyaWYiLGZvbnRTdHlsZToibm9ybWFsIixmb250VmFyaWFudDoibm9ybWFsIixmb250V2VpZ2h0OiJub3JtYWwiLGZvbnRTdHJldGNoOiJub3JtYWwiLGxpbmVIZWlnaHQ6IiIsdGV4dEFsaWduOiJsZWZ0IixzdHJva2VDb2xvcjp2b2lkIDAsc3Ryb2tlV2lkdGg6MSxmaWxsQ29sb3I6dm9pZCAwLHZlcnRpY2FsQWxpZ246Im1pZGRsZSJ9KSx0aGlzW0VdKCJmb250Iil9Z2V0IHRleHQoKXtyZXR1cm4gdGhpc1toXSgidGV4dCIpfHwiICJ9c2V0IHRleHQocCl7dGhpc1tmXSgidGV4dCIscCl9Z2V0IGZvbnRTaXplKCl7cmV0dXJuIHRoaXNbaF0oImZvbnRTaXplIil9c2V0IGZvbnRTaXplKHApe3RoaXNbZl0oImZvbnRTaXplIixPYmplY3Qoby50b051bWJlcikocCkpfWdldCBmb250RmFtaWx5KCl7cmV0dXJuIHRoaXNbaF0oImZvbnRGYW1pbHkiKX1zZXQgZm9udEZhbWlseShwKXt0aGlzW2ZdKCJmb250RmFtaWx5IixwKX1nZXQgZm9udFN0eWxlKCl7cmV0dXJuIHRoaXNbaF0oImZvbnRTdHlsZSIpfXNldCBmb250U3R5bGUocCl7dGhpc1tmXSgiZm9udFN0eWxlIixwKX1nZXQgZm9udFZhcmlhbnQoKXtyZXR1cm4gdGhpc1toXSgiZm9udFZhcmlhbnQiKX1zZXQgZm9udFZhcmlhbnQocCl7dGhpc1tmXSgiZm9udFZhcmlhbnQiLHApfWdldCBmb250V2VpZ2h0KCl7cmV0dXJuIHRoaXNbaF0oImZvbnRXZWlnaHQiKX1zZXQgZm9udFdlaWdodChwKXt0aGlzW2ZdKCJmb250V2VpZ2h0IixwKX1nZXQgZm9udFN0cmV0Y2goKXtyZXR1cm4gdGhpc1toXSgiZm9udFN0cmV0Y2giKX1zZXQgZm9udFN0cmV0Y2gocCl7dGhpc1tmXSgiZm9udFN0cmV0Y2giLHApfWdldCBsaW5lSGVpZ2h0KCl7cmV0dXJuIHRoaXNbaF0oImxpbmVIZWlnaHQiKXx8dGhpcy5mb250U2l6ZX1zZXQgbGluZUhlaWdodChwKXt0aGlzW2ZdKCJsaW5lSGVpZ2h0IixPYmplY3Qoby50b051bWJlcikocCkpfWdldCB0ZXh0QWxpZ24oKXtyZXR1cm4gdGhpc1toXSgidGV4dEFsaWduIil9c2V0IHRleHRBbGlnbihwKXt0aGlzW2ZdKCJ0ZXh0QWxpZ24iLHApfWdldCBzdHJva2VDb2xvcigpe3JldHVybiB0aGlzW2hdKCJzdHJva2VDb2xvciIpfXNldCBzdHJva2VDb2xvcihwKXt0aGlzW2ZdKCJzdHJva2VDb2xvciIsT2JqZWN0KGcucGFyc2VDb2xvcikocCkpfWdldCBzdHJva2VXaWR0aCgpe3JldHVybiB0aGlzW2hdKCJzdHJva2VXaWR0aCIpfXNldCBzdHJva2VXaWR0aChwKXt0aGlzW2ZdKCJzdHJva2VXaWR0aCIsT2JqZWN0KG8udG9OdW1iZXIpKHApKX1nZXQgdmVydGljYWxBbGlnbigpe3JldHVybiB0aGlzW2hdKCJ2ZXJ0aWNhbEFsaWduIil9c2V0IHZlcnRpY2FsQWxpZ24ocCl7dGhpc1tmXSgidmVydGljYWxBbGlnbiIscCl9Z2V0IGZpbGxDb2xvcigpe3JldHVybiB0aGlzW2hdKCJmaWxsQ29sb3IiKX1zZXQgZmlsbENvbG9yKHApe3RoaXNbZl0oImZpbGxDb2xvciIsT2JqZWN0KGcucGFyc2VDb2xvcikocCkpfWdldCBmb250KCl7Y29uc3R7Zm9udFN0eWxlOnAsZm9udFZhcmlhbnQ6Qyxmb250V2VpZ2h0OngsZm9udFN0cmV0Y2g6ZCxmb250U2l6ZTp5LGxpbmVIZWlnaHQ6cixmb250RmFtaWx5OnN9PXRoaXM7cmV0dXJuYCR7cH0gJHtDfSAke3h9ICR7ZH0gJHt5fXB4LyR7cn1weCAke3N9YH1zZXQgZm9udChwKXtpZihwPT1udWxsKXRoaXMuZm9udFN0eWxlPW51bGwsdGhpcy5mb250VmFyaWFudD1udWxsLHRoaXMuZm9udFdlaWdodD1udWxsLHRoaXMuZm9udFN0cmV0Y2g9bnVsbCx0aGlzLmZvbnRTaXplPW51bGwsdGhpcy5saW5lSGVpZ2h0PW51bGwsdGhpcy5mb250RmFtaWx5PW51bGw7ZWxzZXtjb25zdCBDPU9iamVjdChpLnBhcnNlRm9udCkocCk7dGhpcy5mb250U3R5bGU9Qy5zdHlsZSx0aGlzLmZvbnRWYXJpYW50PUMudmFyaWFudCx0aGlzLmZvbnRXZWlnaHQ9Qy53ZWlnaHQsdGhpcy5mb250U3RyZXRjaD1DLnN0cmV0Y2gsdGhpcy5mb250U2l6ZT1PYmplY3Qoby50b051bWJlcikoYCR7Qy5zaXplfSR7Qy51bml0fWApLEMubGluZUhlaWdodCYmKHRoaXMubGluZUhlaWdodD1DLnB4TGluZUhlaWdodCksdGhpcy5mb250RmFtaWx5PUMuZmFtaWx5fX19fSxmdW5jdGlvbihSLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBwfSk7dmFyIGk9dCgxMiksbz10KDIxOSksZz10KDI1MSksdj10KDIxMyksYz10KDI1Mik7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIGYoQyx4LGQpe3JldHVybiB4IGluIEM/T2JqZWN0LmRlZmluZVByb3BlcnR5KEMseCx7dmFsdWU6ZCxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOkNbeF09ZCxDfWNvbnN0IGg9U3ltYm9sKCJ6T3JkZXIiKSxFPVN5bWJvbCgib3JkZXJlZCIpLGw9U3ltYm9sKCJjaGlsZHJlbiIpLG09U3ltYm9sKCJzZWFsZWQiKTtjbGFzcyBwIGV4dGVuZHMgby5kZWZhdWx0e2NvbnN0cnVjdG9yKHg9e30pe3N1cGVyKHgpLHRoaXNbbF09W10sdGhpc1tFXT1udWxsLHRoaXNbaF09MH1nZXQgY2hpbGROb2Rlcygpe3JldHVybiB0aGlzW2xdfWdldCBjaGlsZHJlbigpe3JldHVybiB0aGlzW2xdfWdldCBvcmRlcmVkQ2hpbGRyZW4oKXtyZXR1cm4gdGhpc1tFXXx8KHRoaXNbRV09Wy4uLnRoaXNbbF1dLHRoaXNbRV0uc29ydCgoeCxkKT0+eC56SW5kZXgtZC56SW5kZXh8fHguek9yZGVyLWQuek9yZGVyKSksdGhpc1tFXX1hcHBlbmQoLi4ueCl7cmV0dXJuIHgubWFwKGQ9PnRoaXMuYXBwZW5kQ2hpbGQoZCkpfWFwcGVuZENoaWxkKHgpe3JldHVybiB4LnJlbW92ZSgpLHRoaXNbbF0ucHVzaCh4KSx4LmNvbm5lY3QodGhpcyx0aGlzW2hdKyspLHRoaXNbRV0mJih0aGlzW0VdLmxlbmd0aCYmeC56SW5kZXg8dGhpc1tFXVt0aGlzW0VdLmxlbmd0aC0xXS56SW5kZXg/dGhpcy5yZW9yZGVyKCk6dGhpc1tFXS5wdXNoKHgpKSx4fWNsb25lTm9kZSh4PSExKXtjb25zdCBkPXN1cGVyLmNsb25lTm9kZSgpO3JldHVybiB4JiZ0aGlzW2xdLmZvckVhY2goeT0+e2NvbnN0IHI9eS5jbG9uZU5vZGUoeCk7ZC5hcHBlbmRDaGlsZChyKX0pLGR9ZGlzcGF0Y2hQb2ludGVyRXZlbnQoeCl7Y29uc3QgZD10aGlzLm9yZGVyZWRDaGlsZHJlbjtmb3IobGV0IHk9ZC5sZW5ndGgtMTt5Pj0wO3ktLSlpZihkW3ldLmRpc3BhdGNoUG9pbnRlckV2ZW50KHgpKXJldHVybiEwO3JldHVybiBzdXBlci5kaXNwYXRjaFBvaW50ZXJFdmVudCh4KX1kcmF3KHg9W10pe2lmKHRoaXMuX19jYWNoZVJlbmRlck1hdHJpeD10aGlzLnJlbmRlck1hdHJpeCxzdXBlci5kcmF3KHgpLCF0aGlzW21dJiZ0aGlzLmF0dHJpYnV0ZXMuZGlzcGxheSE9PSJub25lIil7Y29uc3QgZD10aGlzLm9yZGVyZWRDaGlsZHJlbjtmb3IobGV0IHk9MDt5PGQubGVuZ3RoO3krKylkW3ldLmRyYXcoeCl9cmV0dXJuIHRoaXMuX19jYWNoZVJlbmRlck1hdHJpeD1udWxsLHh9Z2V0RWxlbWVudEJ5SWQoeCl7cmV0dXJuIE9iamVjdChjLnF1ZXJ5U2VsZWN0b3IpKGAjJHt4fWAsdGhpcyl9Z2V0RWxlbWVudHNCeUNsYXNzTmFtZSh4KXtyZXR1cm4gT2JqZWN0KGMucXVlcnlTZWxlY3RvckFsbCkoYC4ke3h9YCx0aGlzKX1nZXRFbGVtZW50c0J5TmFtZSh4KXtyZXR1cm4gT2JqZWN0KGMucXVlcnlTZWxlY3RvckFsbCkoYFtuYW1lPSIke3h9Il1gLHRoaXMpfWdldEVsZW1lbnRzQnlUYWdOYW1lKHgpe3JldHVybiBPYmplY3QoYy5xdWVyeVNlbGVjdG9yQWxsKSh4LHRoaXMpfWluc2VydEJlZm9yZSh4LGQpe2lmKGQ9PW51bGwpcmV0dXJuIHRoaXMuYXBwZW5kQ2hpbGQoeCk7eC5yZW1vdmUoKTtjb25zdCB5PXRoaXNbbF0uaW5kZXhPZihkKTtpZih5PDApdGhyb3cgbmV3IEVycm9yKCJJbnZhbGlkIHJlZmVyZW5jZSBub2RlLiIpO2NvbnN0IHI9ZC56T3JkZXI7Zm9yKGxldCBzPXk7czx0aGlzW2xdLmxlbmd0aDtzKyspe2NvbnN0IG49dGhpc1tsXVtzXS56T3JkZXIsYT10aGlzW2xdW3NdO2RlbGV0ZSBhLnpPcmRlcixPYmplY3QuZGVmaW5lUHJvcGVydHkoYSwiek9yZGVyIix7dmFsdWU6bisxLHdyaXRhYmxlOiExLGNvbmZpZ3VyYWJsZTohMH0pfWlmKHRoaXNbbF0uc3BsaWNlKHksMCx4KSx4LmNvbm5lY3QodGhpcyxyKSx0aGlzW0VdKWlmKHguekluZGV4IT09ZC56SW5kZXgpdGhpcy5yZW9yZGVyKCk7ZWxzZXtjb25zdCBzPXRoaXNbRV0uaW5kZXhPZihkKTt0aGlzW0VdLnNwbGljZShzLDAseCl9cmV0dXJuIHh9cXVlcnlTZWxlY3Rvcih4KXtyZXR1cm4gT2JqZWN0KGMucXVlcnlTZWxlY3RvcikoeCx0aGlzKX1xdWVyeVNlbGVjdG9yQWxsKHgpe3JldHVybiBPYmplY3QoYy5xdWVyeVNlbGVjdG9yQWxsKSh4LHRoaXMpfXJlcGxhY2VDaGlsZCh4LGQpe3gucmVtb3ZlKCk7Y29uc3QgeT10aGlzW2xdLmluZGV4T2YoZCk7aWYoeTwwKXRocm93IG5ldyBFcnJvcigiSW52YWxpZCByZWZlcmVuY2Ugbm9kZS4iKTtpZih0aGlzW2xdW3ldPXgseC5jb25uZWN0KHRoaXMsZC56T3JkZXIpLHRoaXNbRV0paWYoeC56SW5kZXghPT1kLnpJbmRleCl0aGlzLnJlb3JkZXIoKTtlbHNle2NvbnN0IHI9dGhpc1tFXS5pbmRleE9mKGQpO3RoaXNbRV1bcl09eH1yZXR1cm4gZC5kaXNjb25uZWN0KHRoaXMpLHh9cmVtb3ZlQWxsQ2hpbGRyZW4oKXtjb25zdCB4PXRoaXNbbF07Zm9yKGxldCBkPXgubGVuZ3RoLTE7ZD49MDtkLS0peFtkXS5yZW1vdmUoKX1yZW1vdmVDaGlsZCh4KXtjb25zdCBkPXRoaXNbbF0uaW5kZXhPZih4KTtpZihkPj0wKXtpZih0aGlzW2xdLnNwbGljZShkLDEpLHRoaXNbRV0pe2NvbnN0IHk9dGhpc1tFXS5pbmRleE9mKHgpO3RoaXNbRV0uc3BsaWNlKHksMSl9cmV0dXJuIHguZGlzY29ubmVjdCh0aGlzKSx4fXJldHVybiBudWxsfXJlb3JkZXIoKXt0aGlzW0VdPW51bGx9c2VhbCgpe2Z1bmN0aW9uIHgocyxuKXtjb25zdCBhPVtdO2ZvcihsZXQgTz0wO088cy5sZW5ndGg7TysrKXtjb25zdCBBPVsuLi5zW09dXTtmb3IobGV0IGI9MTtiPEEubGVuZ3RoO2IrPTIpe2NvbnN0IEk9QVtiXSxQPUFbYisxXTtBW2JdPUkqblswXStQKm5bMl0rbls0XSxBW2IrMV09SSpuWzFdK1AqblszXStuWzVdfWEucHVzaChBKX1yZXR1cm4gYX1jb25zdCBkPXRoaXMub3JkZXJlZENoaWxkcmVuLHk9bmV3IGkuRmlndXJlMkQscj10aGlzLmxvY2FsTWF0cml4O2ZvcihsZXQgcz0wO3M8ZC5sZW5ndGg7cysrKXtsZXQgbj1kW3NdO2lmKG4gaW5zdGFuY2VvZiBwJiYobj1uLnNlYWwoKSksbi5jbGllbnRCb3gpe2xldCBhPW4uY2xpZW50Qm94LmNvbnRvdXJzLnBhdGg7YT14KGEsbi5sb2NhbE1hdHJpeCkseS5hZGRQYXRoKGEpfWlmKG4ucGF0aCl7bGV0IGE9bi5wYXRoLmNvbnRvdXJzLnBhdGg7YT14KGEsbi5sb2NhbE1hdHJpeCkseS5hZGRQYXRoKGEpfX1yZXR1cm4gdGhpc1ttXT0hMCx0aGlzLmNsaWVudEJveD15LHtjbGllbnRCb3g6eSxsb2NhbE1hdHJpeDpyfX1zZXRSZXNvbHV0aW9uKHt3aWR0aDp4LGhlaWdodDpkfSl7c3VwZXIuc2V0UmVzb2x1dGlvbih7d2lkdGg6eCxoZWlnaHQ6ZH0pLHRoaXNbbF0uZm9yRWFjaCh5PT57eS5zZXRSZXNvbHV0aW9uKHt3aWR0aDp4LGhlaWdodDpkfSl9KX11cGRhdGVDb250b3Vycygpe3RoaXNbbV18fHN1cGVyLnVwZGF0ZUNvbnRvdXJzKCl9fWYocCwiQXR0ciIsZy5kZWZhdWx0KSx2LmRlZmF1bHQucmVnaXN0ZXJOb2RlKHAsImdyb3VwIil9LGZ1bmN0aW9uKFIsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIG99KTt2YXIgaT10KDIyMCk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NsYXNzIG8gZXh0ZW5kcyBpLmRlZmF1bHR7fX0sZnVuY3Rpb24oUixlLHQpe3QucihlKSx0LmQoZSwicXVlcnlTZWxlY3RvckFsbCIsZnVuY3Rpb24oKXtyZXR1cm4gbX0pLHQuZChlLCJxdWVyeVNlbGVjdG9yIixmdW5jdGlvbigpe3JldHVybiBwfSksdC5kKGUsImlzTWF0Y2hlZCIsZnVuY3Rpb24oKXtyZXR1cm4gQ30pLHQuZChlLCJjb21waWxlIixmdW5jdGlvbigpe3JldHVybiB4fSk7dmFyIGk9dCgyMjEpLG89dCgyMTMpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCBnPXQoMjUzKTtmdW5jdGlvbiB2KGQpe3JldHVybiBkLm5vZGVUeXBlPT09MXx8by5kZWZhdWx0LmlzU3ByaXRlTm9kZShkLm5vZGVOYW1lKX1mdW5jdGlvbiBjKGQpe3JldHVybiBBcnJheS5mcm9tKGQuY2hpbGROb2Rlc3x8W10pfWZ1bmN0aW9uIGYoZCl7cmV0dXJuIG8uZGVmYXVsdC5pc1Nwcml0ZU5vZGUoZC5ub2RlTmFtZSk/ZC5wYXJlbnR8fGQuY2FudmFzfHxkLmNvbnRhaW5lcjpkLnBhcmVudEVsZW1lbnR9ZnVuY3Rpb24gaChkKXtsZXQgeT1kLmxlbmd0aCxyLHMsbjtmb3IoOy0teT4tMTspe2ZvcihyPXM9ZFt5XSxkW3ldPW51bGwsbj0hMDtzOyl7aWYoZC5pbmRleE9mKHMpPi0xKXtuPSExLGQuc3BsaWNlKHksMSk7YnJlYWt9cz1mKHMpfW4mJihkW3ldPXIpfXJldHVybiBkfWNvbnN0IEU9e2lzVGFnOnYsZXhpc3RzT25lKGQseSl7cmV0dXJuIHkuc29tZShyPT52KHIpP2Qocil8fEUuZXhpc3RzT25lKGQsYyhyKSk6ITEpfSxnZXRTaWJsaW5ncyhkKXtjb25zdCB5PWYoZCk7cmV0dXJuIHkmJmMoeSl9LGdldENoaWxkcmVuOmMsZ2V0UGFyZW50OmYsZ2V0QXR0cmlidXRlVmFsdWUoZCx5KXtpZihkLm5vZGVUeXBlPT09MSYmeT09PSJjbGFzcyJ8fHk9PT0iaWQiKXJldHVybiBkW3ldO2lmKHRoaXMuaGFzQXR0cmliKGQseSkpe2xldCByPWQuYXR0cmlidXRlc1t5XTtyZXR1cm4gQXJyYXkuaXNBcnJheShyKSYmKHI9YFske3Iuam9pbigpfV1gKSxTdHJpbmcocil9fSxoYXNBdHRyaWIoZCx5KXtyZXR1cm4gZC5hdHRyaWJ1dGVzW3ldIT1udWxsfSxyZW1vdmVTdWJzZXRzOmgsZ2V0TmFtZShkKXtyZXR1cm4gZC50YWdOYW1lP2QudGFnTmFtZS50b0xvd2VyQ2FzZSgpOm51bGx9LGZpbmRPbmU6ZnVuY3Rpb24gZCh5LHIpe2xldCBzPW51bGw7Zm9yKGxldCBuPTAsYT1yLmxlbmd0aDtuPGEmJiFzO24rKylpZih5KHJbbl0pKXM9cltuXTtlbHNle2NvbnN0IE89YyhyW25dKTtPJiZPLmxlbmd0aD4wJiYocz1kKHksTykpfXJldHVybiBzfSxmaW5kQWxsOmZ1bmN0aW9uIGQoeSxyKXtsZXQgcz1bXTtmb3IobGV0IG49MCxhPXIubGVuZ3RoO248YTtuKyspe2lmKCF2KHJbbl0pKWNvbnRpbnVlO3kocltuXSkmJnMucHVzaChyW25dKTtjb25zdCBPPWMocltuXSk7TyYmKHM9cy5jb25jYXQoZCh5LE8pKSl9cmV0dXJuIHN9LGdldFRleHQ6ZnVuY3Rpb24gZCh5KXtyZXR1cm4gQXJyYXkuaXNBcnJheSh5KT95Lm1hcChkKS5qb2luKCIiKTp2KHkpP2QoYyh5KSk6eS5ub2RlVHlwZT09PTM/eS5ub2RlVmFsdWU6by5kZWZhdWx0LmlzU3ByaXRlTm9kZSh5Lm5vZGVOYW1lKT95LnRleHQ6IiJ9fTtmdW5jdGlvbiBsKGQpe2lmKHR5cGVvZiBkIT0ic3RyaW5nIilyZXR1cm4gZDtsZXQgeT1kLm1hdGNoKC9cWyhiZ2NvbG9yfGZpbGxDb2xvcnxzdHJva2VDb2xvcnxjb2xvcilccyo9XHMqWyciXT9cdytbJyJdP1xdL2cpO3JldHVybiB5JiYoeT15Lm1hcChyPT57Y29uc3Qgcz1yLnNsaWNlKDEsLTEpLnNwbGl0KCI9Iiksbj1PYmplY3QoaS5wYXJzZUNvbG9yKShzWzFdLnJlcGxhY2UoL1snIl0vZywiIikpO3JldHVybltyLGBbJHtzWzBdfT0iJHtufSJdYF19KSx5LmZvckVhY2goKFtyLHNdKT0+e2Q9ZC5yZXBsYWNlKHIscyl9KSkseT1kLm1hdGNoKC9cW1x3K1xzKj1ccypbJyJdXFsuKz9cXVsnIl1cXS9nKSx5JiYoeT15Lm1hcChyPT57Y29uc3Qgcz1yLnNsaWNlKDEsLTEpLnNwbGl0KCI9Iiksbj1zWzFdLnNsaWNlKDIsLTIpLnNwbGl0KC8sL2cpLm1hcChhPT5hLnRyaW0oKSk7cmV0dXJuW3IsYFske3NbMF19PSJbJHtufV0iXWBdfSkseS5mb3JFYWNoKChbcixzXSk9PntkPWQucmVwbGFjZShyLHMpfSkpLGR9ZnVuY3Rpb24gbShkLHkpe3JldHVybiBnLnNlbGVjdEFsbChsKGQpLHkse2FkYXB0ZXI6RX0pfWZ1bmN0aW9uIHAoZCx5KXtyZXR1cm4gZy5zZWxlY3RPbmUobChkKSx5LHthZGFwdGVyOkV9KX1mdW5jdGlvbiBDKGQseSl7cmV0dXJuIGcuaXMoZCxsKHkpLHthZGFwdGVyOkV9KX1mdW5jdGlvbiB4KGQpe3JldHVybiBnLmNvbXBpbGUobChkKSx7YWRhcHRlcjpFfSl9fSxmdW5jdGlvbihSLGUsdCl7Ui5leHBvcnRzPXg7dmFyIGk9dCgyNTQpLG89dCgyNzMpLmZhbHNlRnVuYyxnPXQoMjc0KTtmdW5jdGlvbiB2KGQpe3JldHVybiBmdW5jdGlvbihyLHMsbil7cmV0dXJuIHM9c3x8e30scy5hZGFwdGVyPXMuYWRhcHRlcnx8aSxkKHIscyxuKX19dmFyIGM9dihnKSxmPXYoZy5jb21waWxlVW5zYWZlKTtmdW5jdGlvbiBoKGQpe3JldHVybiBmdW5jdGlvbihyLHMsbil7cmV0dXJuIG49bnx8e30sbi5hZGFwdGVyPW4uYWRhcHRlcnx8aSx0eXBlb2YgciE9ImZ1bmN0aW9uIiYmKHI9ZihyLG4scykpLHIuc2hvdWxkVGVzdE5leHRTaWJsaW5ncyYmKHM9bChuJiZuLmNvbnRleHR8fHMsbi5hZGFwdGVyKSksQXJyYXkuaXNBcnJheShzKT9zPW4uYWRhcHRlci5yZW1vdmVTdWJzZXRzKHMpOnM9bi5hZGFwdGVyLmdldENoaWxkcmVuKHMpLGQocixzLG4pfX1mdW5jdGlvbiBFKGQseSl7dmFyIHI9eS5nZXRTaWJsaW5ncyhkKTtpZighQXJyYXkuaXNBcnJheShyKSlyZXR1cm5bXTtmb3Iocj1yLnNsaWNlKDApO3Iuc2hpZnQoKSE9PWQ7KTtyZXR1cm4gcn1mdW5jdGlvbiBsKGQseSl7QXJyYXkuaXNBcnJheShkKXx8KGQ9W2RdKTtmb3IodmFyIHI9ZC5zbGljZSgwKSxzPTAsbj1kLmxlbmd0aDtzPG47cysrKXt2YXIgYT1FKHJbc10seSk7ci5wdXNoLmFwcGx5KHIsYSl9cmV0dXJuIHJ9dmFyIG09aChmdW5jdGlvbih5LHIscyl7cmV0dXJuIHk9PT1vfHwhcnx8ci5sZW5ndGg9PT0wP1tdOnMuYWRhcHRlci5maW5kQWxsKHkscil9KSxwPWgoZnVuY3Rpb24oeSxyLHMpe3JldHVybiB5PT09b3x8IXJ8fHIubGVuZ3RoPT09MD9udWxsOnMuYWRhcHRlci5maW5kT25lKHkscil9KTtmdW5jdGlvbiBDKGQseSxyKXtyZXR1cm4gcj1yfHx7fSxyLmFkYXB0ZXI9ci5hZGFwdGVyfHxpLCh0eXBlb2YgeT09ImZ1bmN0aW9uIj95OmMoeSxyKSkoZCl9ZnVuY3Rpb24geChkLHkscil7cmV0dXJuIG0oZCx5LHIpfXguY29tcGlsZT1jLHguZmlsdGVycz1nLlBzZXVkb3MuZmlsdGVycyx4LnBzZXVkb3M9Zy5Qc2V1ZG9zLnBzZXVkb3MseC5zZWxlY3RBbGw9bSx4LnNlbGVjdE9uZT1wLHguaXM9Qyx4LnBhcnNlPWMseC5pdGVyYXRlPW0seC5fY29tcGlsZVVuc2FmZT1mLHguX2NvbXBpbGVUb2tlbj1nLmNvbXBpbGVUb2tlbn0sZnVuY3Rpb24oUixlLHQpe3ZhciBpPVIuZXhwb3J0cztbdCgyNTUpLHQoMjY4KSx0KDI2OSksdCgyNzApLHQoMjcxKSx0KDI3MildLmZvckVhY2goZnVuY3Rpb24obyl7T2JqZWN0LmtleXMobykuZm9yRWFjaChmdW5jdGlvbihnKXtpW2ddPW9bZ10uYmluZChpKX0pfSl9LGZ1bmN0aW9uKFIsZSx0KXt2YXIgaT10KDI1Niksbz10KDI1NyksZz1pLmlzVGFnO1IuZXhwb3J0cz17Z2V0SW5uZXJIVE1MOnYsZ2V0T3V0ZXJIVE1MOm8sZ2V0VGV4dDpjfTtmdW5jdGlvbiB2KGYsaCl7cmV0dXJuIGYuY2hpbGRyZW4/Zi5jaGlsZHJlbi5tYXAoZnVuY3Rpb24oRSl7cmV0dXJuIG8oRSxoKX0pLmpvaW4oIiIpOiIifWZ1bmN0aW9uIGMoZil7cmV0dXJuIEFycmF5LmlzQXJyYXkoZik/Zi5tYXAoYykuam9pbigiIik6ZyhmKT9mLm5hbWU9PT0iYnIiP2AKYDpjKGYuY2hpbGRyZW4pOmYudHlwZT09PWkuQ0RBVEE/YyhmLmNoaWxkcmVuKTpmLnR5cGU9PT1pLlRleHQ/Zi5kYXRhOiIifX0sZnVuY3Rpb24oUixlKXtSLmV4cG9ydHM9e1RleHQ6InRleHQiLERpcmVjdGl2ZToiZGlyZWN0aXZlIixDb21tZW50OiJjb21tZW50IixTY3JpcHQ6InNjcmlwdCIsU3R5bGU6InN0eWxlIixUYWc6InRhZyIsQ0RBVEE6ImNkYXRhIixEb2N0eXBlOiJkb2N0eXBlIixpc1RhZzpmdW5jdGlvbih0KXtyZXR1cm4gdC50eXBlPT09InRhZyJ8fHQudHlwZT09PSJzY3JpcHQifHx0LnR5cGU9PT0ic3R5bGUifX19LGZ1bmN0aW9uKFIsZSx0KXt2YXIgaT10KDI1OCksbz10KDI1OSksZz10KDI2Nyk7Zy5lbGVtZW50TmFtZXMuX19wcm90b19fPW51bGwsZy5hdHRyaWJ1dGVOYW1lcy5fX3Byb3RvX189bnVsbDt2YXIgdj17X19wcm90b19fOm51bGwsc3R5bGU6ITAsc2NyaXB0OiEwLHhtcDohMCxpZnJhbWU6ITAsbm9lbWJlZDohMCxub2ZyYW1lczohMCxwbGFpbnRleHQ6ITAsbm9zY3JpcHQ6ITB9O2Z1bmN0aW9uIGMoZCx5KXtpZihkKXt2YXIgcj0iIixzO2Zvcih2YXIgbiBpbiBkKXM9ZFtuXSxyJiYocis9IiAiKSx5LnhtbE1vZGU9PT0iZm9yZWlnbiImJihuPWcuYXR0cmlidXRlTmFtZXNbbl18fG4pLHIrPW4sKHMhPT1udWxsJiZzIT09IiJ8fHkueG1sTW9kZSkmJihyKz0nPSInKyh5LmRlY29kZUVudGl0aWVzP28uZW5jb2RlWE1MKHMpOnMucmVwbGFjZSgvXCIvZywiJnF1b3Q7IikpKyciJyk7cmV0dXJuIHJ9fXZhciBmPXtfX3Byb3RvX186bnVsbCxhcmVhOiEwLGJhc2U6ITAsYmFzZWZvbnQ6ITAsYnI6ITAsY29sOiEwLGNvbW1hbmQ6ITAsZW1iZWQ6ITAsZnJhbWU6ITAsaHI6ITAsaW1nOiEwLGlucHV0OiEwLGlzaW5kZXg6ITAsa2V5Z2VuOiEwLGxpbms6ITAsbWV0YTohMCxwYXJhbTohMCxzb3VyY2U6ITAsdHJhY2s6ITAsd2JyOiEwfSxoPVIuZXhwb3J0cz1mdW5jdGlvbihkLHkpeyFBcnJheS5pc0FycmF5KGQpJiYhZC5jaGVlcmlvJiYoZD1bZF0pLHk9eXx8e307Zm9yKHZhciByPSIiLHM9MDtzPGQubGVuZ3RoO3MrKyl7dmFyIG49ZFtzXTtuLnR5cGU9PT0icm9vdCI/cis9aChuLmNoaWxkcmVuLHkpOmkuaXNUYWcobik/cis9bChuLHkpOm4udHlwZT09PWkuRGlyZWN0aXZlP3IrPW0obik6bi50eXBlPT09aS5Db21tZW50P3IrPXgobik6bi50eXBlPT09aS5DREFUQT9yKz1DKG4pOnIrPXAobix5KX1yZXR1cm4gcn0sRT1bIm1pIiwibW8iLCJtbiIsIm1zIiwibXRleHQiLCJhbm5vdGF0aW9uLXhtbCIsImZvcmVpZ25PYmplY3QiLCJkZXNjIiwidGl0bGUiXTtmdW5jdGlvbiBsKGQseSl7eS54bWxNb2RlPT09ImZvcmVpZ24iJiYoZC5uYW1lPWcuZWxlbWVudE5hbWVzW2QubmFtZV18fGQubmFtZSxkLnBhcmVudCYmRS5pbmRleE9mKGQucGFyZW50Lm5hbWUpPj0wJiYoeT1PYmplY3QuYXNzaWduKHt9LHkse3htbE1vZGU6ITF9KSkpLCF5LnhtbE1vZGUmJlsic3ZnIiwibWF0aCJdLmluZGV4T2YoZC5uYW1lKT49MCYmKHk9T2JqZWN0LmFzc2lnbih7fSx5LHt4bWxNb2RlOiJmb3JlaWduIn0pKTt2YXIgcj0iPCIrZC5uYW1lLHM9YyhkLmF0dHJpYnMseSk7cmV0dXJuIHMmJihyKz0iICIrcykseS54bWxNb2RlJiYoIWQuY2hpbGRyZW58fGQuY2hpbGRyZW4ubGVuZ3RoPT09MCk/cis9Ii8+Ijoocis9Ij4iLGQuY2hpbGRyZW4mJihyKz1oKGQuY2hpbGRyZW4seSkpLCghZltkLm5hbWVdfHx5LnhtbE1vZGUpJiYocis9IjwvIitkLm5hbWUrIj4iKSkscn1mdW5jdGlvbiBtKGQpe3JldHVybiI8IitkLmRhdGErIj4ifWZ1bmN0aW9uIHAoZCx5KXt2YXIgcj1kLmRhdGF8fCIiO3JldHVybiB5LmRlY29kZUVudGl0aWVzJiYhKGQucGFyZW50JiZkLnBhcmVudC5uYW1lIGluIHYpJiYocj1vLmVuY29kZVhNTChyKSkscn1mdW5jdGlvbiBDKGQpe3JldHVybiI8IVtDREFUQVsiK2QuY2hpbGRyZW5bMF0uZGF0YSsiXV0+In1mdW5jdGlvbiB4KGQpe3JldHVybiI8IS0tIitkLmRhdGErIi0tPiJ9fSxmdW5jdGlvbihSLGUsdCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pO2Z1bmN0aW9uIGkobyl7cmV0dXJuIG8udHlwZT09PSJ0YWcifHxvLnR5cGU9PT0ic2NyaXB0Inx8by50eXBlPT09InN0eWxlIn1lLmlzVGFnPWksZS5UZXh0PSJ0ZXh0IixlLkRpcmVjdGl2ZT0iZGlyZWN0aXZlIixlLkNvbW1lbnQ9ImNvbW1lbnQiLGUuU2NyaXB0PSJzY3JpcHQiLGUuU3R5bGU9InN0eWxlIixlLlRhZz0idGFnIixlLkNEQVRBPSJjZGF0YSIsZS5Eb2N0eXBlPSJkb2N0eXBlIn0sZnVuY3Rpb24oUixlLHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxlLmVuY29kZT1lLmRlY29kZVN0cmljdD1lLmRlY29kZT12b2lkIDA7dmFyIGk9dCgyNjApLG89dCgyNjYpO2Z1bmN0aW9uIGcoRSxsKXtyZXR1cm4oIWx8fGw8PTA/aS5kZWNvZGVYTUw6aS5kZWNvZGVIVE1MKShFKX1lLmRlY29kZT1nO2Z1bmN0aW9uIHYoRSxsKXtyZXR1cm4oIWx8fGw8PTA/aS5kZWNvZGVYTUw6aS5kZWNvZGVIVE1MU3RyaWN0KShFKX1lLmRlY29kZVN0cmljdD12O2Z1bmN0aW9uIGMoRSxsKXtyZXR1cm4oIWx8fGw8PTA/by5lbmNvZGVYTUw6by5lbmNvZGVIVE1MKShFKX1lLmVuY29kZT1jO3ZhciBmPXQoMjY2KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiZW5jb2RlWE1MIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gZi5lbmNvZGVYTUx9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsImVuY29kZUhUTUwiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBmLmVuY29kZUhUTUx9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsImVzY2FwZSIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGYuZXNjYXBlfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJlbmNvZGVIVE1MNCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGYuZW5jb2RlSFRNTH19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiZW5jb2RlSFRNTDUiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBmLmVuY29kZUhUTUx9fSk7dmFyIGg9dCgyNjApO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJkZWNvZGVYTUwiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBoLmRlY29kZVhNTH19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiZGVjb2RlSFRNTCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGguZGVjb2RlSFRNTH19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiZGVjb2RlSFRNTFN0cmljdCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGguZGVjb2RlSFRNTFN0cmljdH19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiZGVjb2RlSFRNTDQiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBoLmRlY29kZUhUTUx9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsImRlY29kZUhUTUw1Iix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gaC5kZWNvZGVIVE1MfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJkZWNvZGVIVE1MNFN0cmljdCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGguZGVjb2RlSFRNTFN0cmljdH19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiZGVjb2RlSFRNTDVTdHJpY3QiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBoLmRlY29kZUhUTUxTdHJpY3R9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsImRlY29kZVhNTFN0cmljdCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGguZGVjb2RlWE1MfX0pfSxmdW5jdGlvbihSLGUsdCl7dmFyIGk9dGhpcyYmdGhpcy5fX2ltcG9ydERlZmF1bHR8fGZ1bmN0aW9uKGwpe3JldHVybiBsJiZsLl9fZXNNb2R1bGU/bDp7ZGVmYXVsdDpsfX07T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLGUuZGVjb2RlSFRNTD1lLmRlY29kZUhUTUxTdHJpY3Q9ZS5kZWNvZGVYTUw9dm9pZCAwO3ZhciBvPWkodCgyNjEpKSxnPWkodCgyNjIpKSx2PWkodCgyNjMpKSxjPWkodCgyNjQpKTtlLmRlY29kZVhNTD1mKHYuZGVmYXVsdCksZS5kZWNvZGVIVE1MU3RyaWN0PWYoby5kZWZhdWx0KTtmdW5jdGlvbiBmKGwpe3ZhciBtPU9iamVjdC5rZXlzKGwpLmpvaW4oInwiKSxwPUUobCk7bSs9InwjW3hYXVtcXGRhLWZBLUZdK3wjXFxkKyI7dmFyIEM9bmV3IFJlZ0V4cCgiJig/OiIrbSsiKTsiLCJnIik7cmV0dXJuIGZ1bmN0aW9uKHgpe3JldHVybiBTdHJpbmcoeCkucmVwbGFjZShDLHApfX12YXIgaD1mdW5jdGlvbihsLG0pe3JldHVybiBsPG0/MTotMX07ZS5kZWNvZGVIVE1MPWZ1bmN0aW9uKCl7Zm9yKHZhciBsPU9iamVjdC5rZXlzKGcuZGVmYXVsdCkuc29ydChoKSxtPU9iamVjdC5rZXlzKG8uZGVmYXVsdCkuc29ydChoKSxwPTAsQz0wO3A8bS5sZW5ndGg7cCsrKWxbQ109PT1tW3BdPyhtW3BdKz0iOz8iLEMrKyk6bVtwXSs9IjsiO3ZhciB4PW5ldyBSZWdFeHAoIiYoPzoiK20uam9pbigifCIpKyJ8I1t4WF1bXFxkYS1mQS1GXSs7P3wjXFxkKzs/KSIsImciKSxkPUUoby5kZWZhdWx0KTtmdW5jdGlvbiB5KHIpe3JldHVybiByLnN1YnN0cigtMSkhPT0iOyImJihyKz0iOyIpLGQocil9cmV0dXJuIGZ1bmN0aW9uKHIpe3JldHVybiBTdHJpbmcocikucmVwbGFjZSh4LHkpfX0oKTtmdW5jdGlvbiBFKGwpe3JldHVybiBmdW5jdGlvbihwKXtpZihwLmNoYXJBdCgxKT09PSIjIil7dmFyIEM9cC5jaGFyQXQoMik7cmV0dXJuIEM9PT0iWCJ8fEM9PT0ieCI/Yy5kZWZhdWx0KHBhcnNlSW50KHAuc3Vic3RyKDMpLDE2KSk6Yy5kZWZhdWx0KHBhcnNlSW50KHAuc3Vic3RyKDIpLDEwKSl9cmV0dXJuIGxbcC5zbGljZSgxLC0xKV19fX0sZnVuY3Rpb24oUil7Ui5leHBvcnRzPUpTT04ucGFyc2UoJ3siQWFjdXRlIjoiw4EiLCJhYWN1dGUiOiLDoSIsIkFicmV2ZSI6IsSCIiwiYWJyZXZlIjoixIMiLCJhYyI6IuKIviIsImFjZCI6IuKIvyIsImFjRSI6IuKIvsyzIiwiQWNpcmMiOiLDgiIsImFjaXJjIjoiw6IiLCJhY3V0ZSI6IsK0IiwiQWN5Ijoi0JAiLCJhY3kiOiLQsCIsIkFFbGlnIjoiw4YiLCJhZWxpZyI6IsOmIiwiYWYiOiLigaEiLCJBZnIiOiLwnZSEIiwiYWZyIjoi8J2UniIsIkFncmF2ZSI6IsOAIiwiYWdyYXZlIjoiw6AiLCJhbGVmc3ltIjoi4oS1IiwiYWxlcGgiOiLihLUiLCJBbHBoYSI6Is6RIiwiYWxwaGEiOiLOsSIsIkFtYWNyIjoixIAiLCJhbWFjciI6IsSBIiwiYW1hbGciOiLiqL8iLCJhbXAiOiImIiwiQU1QIjoiJiIsImFuZGFuZCI6IuKplSIsIkFuZCI6IuKpkyIsImFuZCI6IuKIpyIsImFuZGQiOiLiqZwiLCJhbmRzbG9wZSI6IuKpmCIsImFuZHYiOiLiqZoiLCJhbmciOiLiiKAiLCJhbmdlIjoi4qakIiwiYW5nbGUiOiLiiKAiLCJhbmdtc2RhYSI6IuKmqCIsImFuZ21zZGFiIjoi4qapIiwiYW5nbXNkYWMiOiLipqoiLCJhbmdtc2RhZCI6IuKmqyIsImFuZ21zZGFlIjoi4qasIiwiYW5nbXNkYWYiOiLipq0iLCJhbmdtc2RhZyI6IuKmriIsImFuZ21zZGFoIjoi4qavIiwiYW5nbXNkIjoi4oihIiwiYW5ncnQiOiLiiJ8iLCJhbmdydHZiIjoi4oq+IiwiYW5ncnR2YmQiOiLipp0iLCJhbmdzcGgiOiLiiKIiLCJhbmdzdCI6IsOFIiwiYW5nemFyciI6IuKNvCIsIkFvZ29uIjoixIQiLCJhb2dvbiI6IsSFIiwiQW9wZiI6IvCdlLgiLCJhb3BmIjoi8J2VkiIsImFwYWNpciI6IuKpryIsImFwIjoi4omIIiwiYXBFIjoi4qmwIiwiYXBlIjoi4omKIiwiYXBpZCI6IuKJiyIsImFwb3MiOiJcJyIsIkFwcGx5RnVuY3Rpb24iOiLigaEiLCJhcHByb3giOiLiiYgiLCJhcHByb3hlcSI6IuKJiiIsIkFyaW5nIjoiw4UiLCJhcmluZyI6IsOlIiwiQXNjciI6IvCdkpwiLCJhc2NyIjoi8J2StiIsIkFzc2lnbiI6IuKJlCIsImFzdCI6IioiLCJhc3ltcCI6IuKJiCIsImFzeW1wZXEiOiLiiY0iLCJBdGlsZGUiOiLDgyIsImF0aWxkZSI6IsOjIiwiQXVtbCI6IsOEIiwiYXVtbCI6IsOkIiwiYXdjb25pbnQiOiLiiLMiLCJhd2ludCI6IuKokSIsImJhY2tjb25nIjoi4omMIiwiYmFja2Vwc2lsb24iOiLPtiIsImJhY2twcmltZSI6IuKAtSIsImJhY2tzaW0iOiLiiL0iLCJiYWNrc2ltZXEiOiLii40iLCJCYWNrc2xhc2giOiLiiJYiLCJCYXJ2Ijoi4qunIiwiYmFydmVlIjoi4oq9IiwiYmFyd2VkIjoi4oyFIiwiQmFyd2VkIjoi4oyGIiwiYmFyd2VkZ2UiOiLijIUiLCJiYnJrIjoi4o61IiwiYmJya3RicmsiOiLijrYiLCJiY29uZyI6IuKJjCIsIkJjeSI6ItCRIiwiYmN5Ijoi0LEiLCJiZHF1byI6IuKAniIsImJlY2F1cyI6IuKItSIsImJlY2F1c2UiOiLiiLUiLCJCZWNhdXNlIjoi4oi1IiwiYmVtcHR5diI6IuKmsCIsImJlcHNpIjoiz7YiLCJiZXJub3UiOiLihKwiLCJCZXJub3VsbGlzIjoi4oSsIiwiQmV0YSI6Is6SIiwiYmV0YSI6Is6yIiwiYmV0aCI6IuKEtiIsImJldHdlZW4iOiLiiawiLCJCZnIiOiLwnZSFIiwiYmZyIjoi8J2UnyIsImJpZ2NhcCI6IuKLgiIsImJpZ2NpcmMiOiLil68iLCJiaWdjdXAiOiLii4MiLCJiaWdvZG90Ijoi4qiAIiwiYmlnb3BsdXMiOiLiqIEiLCJiaWdvdGltZXMiOiLiqIIiLCJiaWdzcWN1cCI6IuKohiIsImJpZ3N0YXIiOiLimIUiLCJiaWd0cmlhbmdsZWRvd24iOiLilr0iLCJiaWd0cmlhbmdsZXVwIjoi4pazIiwiYmlndXBsdXMiOiLiqIQiLCJiaWd2ZWUiOiLii4EiLCJiaWd3ZWRnZSI6IuKLgCIsImJrYXJvdyI6IuKkjSIsImJsYWNrbG96ZW5nZSI6IuKnqyIsImJsYWNrc3F1YXJlIjoi4paqIiwiYmxhY2t0cmlhbmdsZSI6IuKWtCIsImJsYWNrdHJpYW5nbGVkb3duIjoi4pa+IiwiYmxhY2t0cmlhbmdsZWxlZnQiOiLil4IiLCJibGFja3RyaWFuZ2xlcmlnaHQiOiLilrgiLCJibGFuayI6IuKQoyIsImJsazEyIjoi4paSIiwiYmxrMTQiOiLilpEiLCJibGszNCI6IuKWkyIsImJsb2NrIjoi4paIIiwiYm5lIjoiPeKDpSIsImJuZXF1aXYiOiLiiaHig6UiLCJiTm90Ijoi4qutIiwiYm5vdCI6IuKMkCIsIkJvcGYiOiLwnZS5IiwiYm9wZiI6IvCdlZMiLCJib3QiOiLiiqUiLCJib3R0b20iOiLiiqUiLCJib3d0aWUiOiLii4giLCJib3hib3giOiLip4kiLCJib3hkbCI6IuKUkCIsImJveGRMIjoi4pWVIiwiYm94RGwiOiLilZYiLCJib3hETCI6IuKVlyIsImJveGRyIjoi4pSMIiwiYm94ZFIiOiLilZIiLCJib3hEciI6IuKVkyIsImJveERSIjoi4pWUIiwiYm94aCI6IuKUgCIsImJveEgiOiLilZAiLCJib3hoZCI6IuKUrCIsImJveEhkIjoi4pWkIiwiYm94aEQiOiLilaUiLCJib3hIRCI6IuKVpiIsImJveGh1Ijoi4pS0IiwiYm94SHUiOiLilaciLCJib3hoVSI6IuKVqCIsImJveEhVIjoi4pWpIiwiYm94bWludXMiOiLiip8iLCJib3hwbHVzIjoi4oqeIiwiYm94dGltZXMiOiLiiqAiLCJib3h1bCI6IuKUmCIsImJveHVMIjoi4pWbIiwiYm94VWwiOiLilZwiLCJib3hVTCI6IuKVnSIsImJveHVyIjoi4pSUIiwiYm94dVIiOiLilZgiLCJib3hVciI6IuKVmSIsImJveFVSIjoi4pWaIiwiYm94diI6IuKUgiIsImJveFYiOiLilZEiLCJib3h2aCI6IuKUvCIsImJveHZIIjoi4pWqIiwiYm94VmgiOiLilasiLCJib3hWSCI6IuKVrCIsImJveHZsIjoi4pSkIiwiYm94dkwiOiLilaEiLCJib3hWbCI6IuKVoiIsImJveFZMIjoi4pWjIiwiYm94dnIiOiLilJwiLCJib3h2UiI6IuKVniIsImJveFZyIjoi4pWfIiwiYm94VlIiOiLilaAiLCJicHJpbWUiOiLigLUiLCJicmV2ZSI6IsuYIiwiQnJldmUiOiLLmCIsImJydmJhciI6IsKmIiwiYnNjciI6IvCdkrciLCJCc2NyIjoi4oSsIiwiYnNlbWkiOiLigY8iLCJic2ltIjoi4oi9IiwiYnNpbWUiOiLii40iLCJic29sYiI6IuKnhSIsImJzb2wiOiJcXFxcIiwiYnNvbGhzdWIiOiLin4giLCJidWxsIjoi4oCiIiwiYnVsbGV0Ijoi4oCiIiwiYnVtcCI6IuKJjiIsImJ1bXBFIjoi4qquIiwiYnVtcGUiOiLiiY8iLCJCdW1wZXEiOiLiiY4iLCJidW1wZXEiOiLiiY8iLCJDYWN1dGUiOiLEhiIsImNhY3V0ZSI6IsSHIiwiY2FwYW5kIjoi4qmEIiwiY2FwYnJjdXAiOiLiqYkiLCJjYXBjYXAiOiLiqYsiLCJjYXAiOiLiiKkiLCJDYXAiOiLii5IiLCJjYXBjdXAiOiLiqYciLCJjYXBkb3QiOiLiqYAiLCJDYXBpdGFsRGlmZmVyZW50aWFsRCI6IuKFhSIsImNhcHMiOiLiiKnvuIAiLCJjYXJldCI6IuKBgSIsImNhcm9uIjoiy4ciLCJDYXlsZXlzIjoi4oStIiwiY2NhcHMiOiLiqY0iLCJDY2Fyb24iOiLEjCIsImNjYXJvbiI6IsSNIiwiQ2NlZGlsIjoiw4ciLCJjY2VkaWwiOiLDpyIsIkNjaXJjIjoixIgiLCJjY2lyYyI6IsSJIiwiQ2NvbmludCI6IuKIsCIsImNjdXBzIjoi4qmMIiwiY2N1cHNzbSI6IuKpkCIsIkNkb3QiOiLEiiIsImNkb3QiOiLEiyIsImNlZGlsIjoiwrgiLCJDZWRpbGxhIjoiwrgiLCJjZW1wdHl2Ijoi4qayIiwiY2VudCI6IsKiIiwiY2VudGVyZG90IjoiwrciLCJDZW50ZXJEb3QiOiLCtyIsImNmciI6IvCdlKAiLCJDZnIiOiLihK0iLCJDSGN5Ijoi0KciLCJjaGN5Ijoi0YciLCJjaGVjayI6IuKckyIsImNoZWNrbWFyayI6IuKckyIsIkNoaSI6Is6nIiwiY2hpIjoiz4ciLCJjaXJjIjoiy4YiLCJjaXJjZXEiOiLiiZciLCJjaXJjbGVhcnJvd2xlZnQiOiLihroiLCJjaXJjbGVhcnJvd3JpZ2h0Ijoi4oa7IiwiY2lyY2xlZGFzdCI6IuKKmyIsImNpcmNsZWRjaXJjIjoi4oqaIiwiY2lyY2xlZGRhc2giOiLiip0iLCJDaXJjbGVEb3QiOiLiipkiLCJjaXJjbGVkUiI6IsKuIiwiY2lyY2xlZFMiOiLik4giLCJDaXJjbGVNaW51cyI6IuKKliIsIkNpcmNsZVBsdXMiOiLiipUiLCJDaXJjbGVUaW1lcyI6IuKKlyIsImNpciI6IuKXiyIsImNpckUiOiLip4MiLCJjaXJlIjoi4omXIiwiY2lyZm5pbnQiOiLiqJAiLCJjaXJtaWQiOiLiq68iLCJjaXJzY2lyIjoi4qeCIiwiQ2xvY2t3aXNlQ29udG91ckludGVncmFsIjoi4oiyIiwiQ2xvc2VDdXJseURvdWJsZVF1b3RlIjoi4oCdIiwiQ2xvc2VDdXJseVF1b3RlIjoi4oCZIiwiY2x1YnMiOiLimaMiLCJjbHVic3VpdCI6IuKZoyIsImNvbG9uIjoiOiIsIkNvbG9uIjoi4oi3IiwiQ29sb25lIjoi4qm0IiwiY29sb25lIjoi4omUIiwiY29sb25lcSI6IuKJlCIsImNvbW1hIjoiLCIsImNvbW1hdCI6IkAiLCJjb21wIjoi4oiBIiwiY29tcGZuIjoi4oiYIiwiY29tcGxlbWVudCI6IuKIgSIsImNvbXBsZXhlcyI6IuKEgiIsImNvbmciOiLiiYUiLCJjb25nZG90Ijoi4qmtIiwiQ29uZ3J1ZW50Ijoi4omhIiwiY29uaW50Ijoi4oiuIiwiQ29uaW50Ijoi4oivIiwiQ29udG91ckludGVncmFsIjoi4oiuIiwiY29wZiI6IvCdlZQiLCJDb3BmIjoi4oSCIiwiY29wcm9kIjoi4oiQIiwiQ29wcm9kdWN0Ijoi4oiQIiwiY29weSI6IsKpIiwiQ09QWSI6IsKpIiwiY29weXNyIjoi4oSXIiwiQ291bnRlckNsb2Nrd2lzZUNvbnRvdXJJbnRlZ3JhbCI6IuKIsyIsImNyYXJyIjoi4oa1IiwiY3Jvc3MiOiLinJciLCJDcm9zcyI6IuKoryIsIkNzY3IiOiLwnZKeIiwiY3NjciI6IvCdkrgiLCJjc3ViIjoi4quPIiwiY3N1YmUiOiLiq5EiLCJjc3VwIjoi4quQIiwiY3N1cGUiOiLiq5IiLCJjdGRvdCI6IuKLryIsImN1ZGFycmwiOiLipLgiLCJjdWRhcnJyIjoi4qS1IiwiY3VlcHIiOiLii54iLCJjdWVzYyI6IuKLnyIsImN1bGFyciI6IuKGtiIsImN1bGFycnAiOiLipL0iLCJjdXBicmNhcCI6IuKpiCIsImN1cGNhcCI6IuKphiIsIkN1cENhcCI6IuKJjSIsImN1cCI6IuKIqiIsIkN1cCI6IuKLkyIsImN1cGN1cCI6IuKpiiIsImN1cGRvdCI6IuKKjSIsImN1cG9yIjoi4qmFIiwiY3VwcyI6IuKIqu+4gCIsImN1cmFyciI6IuKGtyIsImN1cmFycm0iOiLipLwiLCJjdXJseWVxcHJlYyI6IuKLniIsImN1cmx5ZXFzdWNjIjoi4oufIiwiY3VybHl2ZWUiOiLii44iLCJjdXJseXdlZGdlIjoi4ouPIiwiY3VycmVuIjoiwqQiLCJjdXJ2ZWFycm93bGVmdCI6IuKGtiIsImN1cnZlYXJyb3dyaWdodCI6IuKGtyIsImN1dmVlIjoi4ouOIiwiY3V3ZWQiOiLii48iLCJjd2NvbmludCI6IuKIsiIsImN3aW50Ijoi4oixIiwiY3lsY3R5Ijoi4oytIiwiZGFnZ2VyIjoi4oCgIiwiRGFnZ2VyIjoi4oChIiwiZGFsZXRoIjoi4oS4IiwiZGFyciI6IuKGkyIsIkRhcnIiOiLihqEiLCJkQXJyIjoi4oeTIiwiZGFzaCI6IuKAkCIsIkRhc2h2Ijoi4qukIiwiZGFzaHYiOiLiiqMiLCJkYmthcm93Ijoi4qSPIiwiZGJsYWMiOiLLnSIsIkRjYXJvbiI6IsSOIiwiZGNhcm9uIjoixI8iLCJEY3kiOiLQlCIsImRjeSI6ItC0IiwiZGRhZ2dlciI6IuKAoSIsImRkYXJyIjoi4oeKIiwiREQiOiLihYUiLCJkZCI6IuKFhiIsIkREb3RyYWhkIjoi4qSRIiwiZGRvdHNlcSI6IuKptyIsImRlZyI6IsKwIiwiRGVsIjoi4oiHIiwiRGVsdGEiOiLOlCIsImRlbHRhIjoizrQiLCJkZW1wdHl2Ijoi4qaxIiwiZGZpc2h0Ijoi4qW/IiwiRGZyIjoi8J2UhyIsImRmciI6IvCdlKEiLCJkSGFyIjoi4qWlIiwiZGhhcmwiOiLih4MiLCJkaGFyciI6IuKHgiIsIkRpYWNyaXRpY2FsQWN1dGUiOiLCtCIsIkRpYWNyaXRpY2FsRG90Ijoiy5kiLCJEaWFjcml0aWNhbERvdWJsZUFjdXRlIjoiy50iLCJEaWFjcml0aWNhbEdyYXZlIjoiYCIsIkRpYWNyaXRpY2FsVGlsZGUiOiLLnCIsImRpYW0iOiLii4QiLCJkaWFtb25kIjoi4ouEIiwiRGlhbW9uZCI6IuKLhCIsImRpYW1vbmRzdWl0Ijoi4pmmIiwiZGlhbXMiOiLimaYiLCJkaWUiOiLCqCIsIkRpZmZlcmVudGlhbEQiOiLihYYiLCJkaWdhbW1hIjoiz50iLCJkaXNpbiI6IuKLsiIsImRpdiI6IsO3IiwiZGl2aWRlIjoiw7ciLCJkaXZpZGVvbnRpbWVzIjoi4ouHIiwiZGl2b254Ijoi4ouHIiwiREpjeSI6ItCCIiwiZGpjeSI6ItGSIiwiZGxjb3JuIjoi4oyeIiwiZGxjcm9wIjoi4oyNIiwiZG9sbGFyIjoiJCIsIkRvcGYiOiLwnZS7IiwiZG9wZiI6IvCdlZUiLCJEb3QiOiLCqCIsImRvdCI6IsuZIiwiRG90RG90Ijoi4oOcIiwiZG90ZXEiOiLiiZAiLCJkb3RlcWRvdCI6IuKJkSIsIkRvdEVxdWFsIjoi4omQIiwiZG90bWludXMiOiLiiLgiLCJkb3RwbHVzIjoi4oiUIiwiZG90c3F1YXJlIjoi4oqhIiwiZG91YmxlYmFyd2VkZ2UiOiLijIYiLCJEb3VibGVDb250b3VySW50ZWdyYWwiOiLiiK8iLCJEb3VibGVEb3QiOiLCqCIsIkRvdWJsZURvd25BcnJvdyI6IuKHkyIsIkRvdWJsZUxlZnRBcnJvdyI6IuKHkCIsIkRvdWJsZUxlZnRSaWdodEFycm93Ijoi4oeUIiwiRG91YmxlTGVmdFRlZSI6IuKrpCIsIkRvdWJsZUxvbmdMZWZ0QXJyb3ciOiLin7giLCJEb3VibGVMb25nTGVmdFJpZ2h0QXJyb3ciOiLin7oiLCJEb3VibGVMb25nUmlnaHRBcnJvdyI6IuKfuSIsIkRvdWJsZVJpZ2h0QXJyb3ciOiLih5IiLCJEb3VibGVSaWdodFRlZSI6IuKKqCIsIkRvdWJsZVVwQXJyb3ciOiLih5EiLCJEb3VibGVVcERvd25BcnJvdyI6IuKHlSIsIkRvdWJsZVZlcnRpY2FsQmFyIjoi4oilIiwiRG93bkFycm93QmFyIjoi4qSTIiwiZG93bmFycm93Ijoi4oaTIiwiRG93bkFycm93Ijoi4oaTIiwiRG93bmFycm93Ijoi4oeTIiwiRG93bkFycm93VXBBcnJvdyI6IuKHtSIsIkRvd25CcmV2ZSI6IsyRIiwiZG93bmRvd25hcnJvd3MiOiLih4oiLCJkb3duaGFycG9vbmxlZnQiOiLih4MiLCJkb3duaGFycG9vbnJpZ2h0Ijoi4oeCIiwiRG93bkxlZnRSaWdodFZlY3RvciI6IuKlkCIsIkRvd25MZWZ0VGVlVmVjdG9yIjoi4qWeIiwiRG93bkxlZnRWZWN0b3JCYXIiOiLipZYiLCJEb3duTGVmdFZlY3RvciI6IuKGvSIsIkRvd25SaWdodFRlZVZlY3RvciI6IuKlnyIsIkRvd25SaWdodFZlY3RvckJhciI6IuKllyIsIkRvd25SaWdodFZlY3RvciI6IuKHgSIsIkRvd25UZWVBcnJvdyI6IuKGpyIsIkRvd25UZWUiOiLiiqQiLCJkcmJrYXJvdyI6IuKkkCIsImRyY29ybiI6IuKMnyIsImRyY3JvcCI6IuKMjCIsIkRzY3IiOiLwnZKfIiwiZHNjciI6IvCdkrkiLCJEU2N5Ijoi0IUiLCJkc2N5Ijoi0ZUiLCJkc29sIjoi4qe2IiwiRHN0cm9rIjoixJAiLCJkc3Ryb2siOiLEkSIsImR0ZG90Ijoi4ouxIiwiZHRyaSI6IuKWvyIsImR0cmlmIjoi4pa+IiwiZHVhcnIiOiLih7UiLCJkdWhhciI6IuKlryIsImR3YW5nbGUiOiLipqYiLCJEWmN5Ijoi0I8iLCJkemN5Ijoi0Z8iLCJkemlncmFyciI6IuKfvyIsIkVhY3V0ZSI6IsOJIiwiZWFjdXRlIjoiw6kiLCJlYXN0ZXIiOiLiqa4iLCJFY2Fyb24iOiLEmiIsImVjYXJvbiI6IsSbIiwiRWNpcmMiOiLDiiIsImVjaXJjIjoiw6oiLCJlY2lyIjoi4omWIiwiZWNvbG9uIjoi4omVIiwiRWN5Ijoi0K0iLCJlY3kiOiLRjSIsImVERG90Ijoi4qm3IiwiRWRvdCI6IsSWIiwiZWRvdCI6IsSXIiwiZURvdCI6IuKJkSIsImVlIjoi4oWHIiwiZWZEb3QiOiLiiZIiLCJFZnIiOiLwnZSIIiwiZWZyIjoi8J2UoiIsImVnIjoi4qqaIiwiRWdyYXZlIjoiw4giLCJlZ3JhdmUiOiLDqCIsImVncyI6IuKqliIsImVnc2RvdCI6IuKqmCIsImVsIjoi4qqZIiwiRWxlbWVudCI6IuKIiCIsImVsaW50ZXJzIjoi4o+nIiwiZWxsIjoi4oSTIiwiZWxzIjoi4qqVIiwiZWxzZG90Ijoi4qqXIiwiRW1hY3IiOiLEkiIsImVtYWNyIjoixJMiLCJlbXB0eSI6IuKIhSIsImVtcHR5c2V0Ijoi4oiFIiwiRW1wdHlTbWFsbFNxdWFyZSI6IuKXuyIsImVtcHR5diI6IuKIhSIsIkVtcHR5VmVyeVNtYWxsU3F1YXJlIjoi4parIiwiZW1zcDEzIjoi4oCEIiwiZW1zcDE0Ijoi4oCFIiwiZW1zcCI6IuKAgyIsIkVORyI6IsWKIiwiZW5nIjoixYsiLCJlbnNwIjoi4oCCIiwiRW9nb24iOiLEmCIsImVvZ29uIjoixJkiLCJFb3BmIjoi8J2UvCIsImVvcGYiOiLwnZWWIiwiZXBhciI6IuKLlSIsImVwYXJzbCI6IuKnoyIsImVwbHVzIjoi4qmxIiwiZXBzaSI6Is61IiwiRXBzaWxvbiI6Is6VIiwiZXBzaWxvbiI6Is61IiwiZXBzaXYiOiLPtSIsImVxY2lyYyI6IuKJliIsImVxY29sb24iOiLiiZUiLCJlcXNpbSI6IuKJgiIsImVxc2xhbnRndHIiOiLiqpYiLCJlcXNsYW50bGVzcyI6IuKqlSIsIkVxdWFsIjoi4qm1IiwiZXF1YWxzIjoiPSIsIkVxdWFsVGlsZGUiOiLiiYIiLCJlcXVlc3QiOiLiiZ8iLCJFcXVpbGlicml1bSI6IuKHjCIsImVxdWl2Ijoi4omhIiwiZXF1aXZERCI6IuKpuCIsImVxdnBhcnNsIjoi4qelIiwiZXJhcnIiOiLipbEiLCJlckRvdCI6IuKJkyIsImVzY3IiOiLihK8iLCJFc2NyIjoi4oSwIiwiZXNkb3QiOiLiiZAiLCJFc2ltIjoi4qmzIiwiZXNpbSI6IuKJgiIsIkV0YSI6Is6XIiwiZXRhIjoizrciLCJFVEgiOiLDkCIsImV0aCI6IsOwIiwiRXVtbCI6IsOLIiwiZXVtbCI6IsOrIiwiZXVybyI6IuKCrCIsImV4Y2wiOiIhIiwiZXhpc3QiOiLiiIMiLCJFeGlzdHMiOiLiiIMiLCJleHBlY3RhdGlvbiI6IuKEsCIsImV4cG9uZW50aWFsZSI6IuKFhyIsIkV4cG9uZW50aWFsRSI6IuKFhyIsImZhbGxpbmdkb3RzZXEiOiLiiZIiLCJGY3kiOiLQpCIsImZjeSI6ItGEIiwiZmVtYWxlIjoi4pmAIiwiZmZpbGlnIjoi76yDIiwiZmZsaWciOiLvrIAiLCJmZmxsaWciOiLvrIQiLCJGZnIiOiLwnZSJIiwiZmZyIjoi8J2UoyIsImZpbGlnIjoi76yBIiwiRmlsbGVkU21hbGxTcXVhcmUiOiLil7wiLCJGaWxsZWRWZXJ5U21hbGxTcXVhcmUiOiLilqoiLCJmamxpZyI6ImZqIiwiZmxhdCI6IuKZrSIsImZsbGlnIjoi76yCIiwiZmx0bnMiOiLilrEiLCJmbm9mIjoixpIiLCJGb3BmIjoi8J2UvSIsImZvcGYiOiLwnZWXIiwiZm9yYWxsIjoi4oiAIiwiRm9yQWxsIjoi4oiAIiwiZm9yayI6IuKLlCIsImZvcmt2Ijoi4quZIiwiRm91cmllcnRyZiI6IuKEsSIsImZwYXJ0aW50Ijoi4qiNIiwiZnJhYzEyIjoiwr0iLCJmcmFjMTMiOiLihZMiLCJmcmFjMTQiOiLCvCIsImZyYWMxNSI6IuKFlSIsImZyYWMxNiI6IuKFmSIsImZyYWMxOCI6IuKFmyIsImZyYWMyMyI6IuKFlCIsImZyYWMyNSI6IuKFliIsImZyYWMzNCI6IsK+IiwiZnJhYzM1Ijoi4oWXIiwiZnJhYzM4Ijoi4oWcIiwiZnJhYzQ1Ijoi4oWYIiwiZnJhYzU2Ijoi4oWaIiwiZnJhYzU4Ijoi4oWdIiwiZnJhYzc4Ijoi4oWeIiwiZnJhc2wiOiLigYQiLCJmcm93biI6IuKMoiIsImZzY3IiOiLwnZK7IiwiRnNjciI6IuKEsSIsImdhY3V0ZSI6Ise1IiwiR2FtbWEiOiLOkyIsImdhbW1hIjoizrMiLCJHYW1tYWQiOiLPnCIsImdhbW1hZCI6Is+dIiwiZ2FwIjoi4qqGIiwiR2JyZXZlIjoixJ4iLCJnYnJldmUiOiLEnyIsIkdjZWRpbCI6IsSiIiwiR2NpcmMiOiLEnCIsImdjaXJjIjoixJ0iLCJHY3kiOiLQkyIsImdjeSI6ItCzIiwiR2RvdCI6IsSgIiwiZ2RvdCI6IsShIiwiZ2UiOiLiiaUiLCJnRSI6IuKJpyIsImdFbCI6IuKqjCIsImdlbCI6IuKLmyIsImdlcSI6IuKJpSIsImdlcXEiOiLiiaciLCJnZXFzbGFudCI6IuKpviIsImdlc2NjIjoi4qqpIiwiZ2VzIjoi4qm+IiwiZ2VzZG90Ijoi4qqAIiwiZ2VzZG90byI6IuKqgiIsImdlc2RvdG9sIjoi4qqEIiwiZ2VzbCI6IuKLm++4gCIsImdlc2xlcyI6IuKqlCIsIkdmciI6IvCdlIoiLCJnZnIiOiLwnZSkIiwiZ2ciOiLiiasiLCJHZyI6IuKLmSIsImdnZyI6IuKLmSIsImdpbWVsIjoi4oS3IiwiR0pjeSI6ItCDIiwiZ2pjeSI6ItGTIiwiZ2xhIjoi4qqlIiwiZ2wiOiLiibciLCJnbEUiOiLiqpIiLCJnbGoiOiLiqqQiLCJnbmFwIjoi4qqKIiwiZ25hcHByb3giOiLiqooiLCJnbmUiOiLiqogiLCJnbkUiOiLiiakiLCJnbmVxIjoi4qqIIiwiZ25lcXEiOiLiiakiLCJnbnNpbSI6IuKLpyIsIkdvcGYiOiLwnZS+IiwiZ29wZiI6IvCdlZgiLCJncmF2ZSI6ImAiLCJHcmVhdGVyRXF1YWwiOiLiiaUiLCJHcmVhdGVyRXF1YWxMZXNzIjoi4oubIiwiR3JlYXRlckZ1bGxFcXVhbCI6IuKJpyIsIkdyZWF0ZXJHcmVhdGVyIjoi4qqiIiwiR3JlYXRlckxlc3MiOiLiibciLCJHcmVhdGVyU2xhbnRFcXVhbCI6IuKpviIsIkdyZWF0ZXJUaWxkZSI6IuKJsyIsIkdzY3IiOiLwnZKiIiwiZ3NjciI6IuKEiiIsImdzaW0iOiLiibMiLCJnc2ltZSI6IuKqjiIsImdzaW1sIjoi4qqQIiwiZ3RjYyI6IuKqpyIsImd0Y2lyIjoi4qm6IiwiZ3QiOiI+IiwiR1QiOiI+IiwiR3QiOiLiiasiLCJndGRvdCI6IuKLlyIsImd0bFBhciI6IuKmlSIsImd0cXVlc3QiOiLiqbwiLCJndHJhcHByb3giOiLiqoYiLCJndHJhcnIiOiLipbgiLCJndHJkb3QiOiLii5ciLCJndHJlcWxlc3MiOiLii5siLCJndHJlcXFsZXNzIjoi4qqMIiwiZ3RybGVzcyI6IuKJtyIsImd0cnNpbSI6IuKJsyIsImd2ZXJ0bmVxcSI6IuKJqe+4gCIsImd2bkUiOiLiianvuIAiLCJIYWNlayI6IsuHIiwiaGFpcnNwIjoi4oCKIiwiaGFsZiI6IsK9IiwiaGFtaWx0Ijoi4oSLIiwiSEFSRGN5Ijoi0KoiLCJoYXJkY3kiOiLRiiIsImhhcnJjaXIiOiLipYgiLCJoYXJyIjoi4oaUIiwiaEFyciI6IuKHlCIsImhhcnJ3Ijoi4oatIiwiSGF0IjoiXiIsImhiYXIiOiLihI8iLCJIY2lyYyI6IsSkIiwiaGNpcmMiOiLEpSIsImhlYXJ0cyI6IuKZpSIsImhlYXJ0c3VpdCI6IuKZpSIsImhlbGxpcCI6IuKApiIsImhlcmNvbiI6IuKKuSIsImhmciI6IvCdlKUiLCJIZnIiOiLihIwiLCJIaWxiZXJ0U3BhY2UiOiLihIsiLCJoa3NlYXJvdyI6IuKkpSIsImhrc3dhcm93Ijoi4qSmIiwiaG9hcnIiOiLih78iLCJob210aHQiOiLiiLsiLCJob29rbGVmdGFycm93Ijoi4oapIiwiaG9va3JpZ2h0YXJyb3ciOiLihqoiLCJob3BmIjoi8J2VmSIsIkhvcGYiOiLihI0iLCJob3JiYXIiOiLigJUiLCJIb3Jpem9udGFsTGluZSI6IuKUgCIsImhzY3IiOiLwnZK9IiwiSHNjciI6IuKEiyIsImhzbGFzaCI6IuKEjyIsIkhzdHJvayI6IsSmIiwiaHN0cm9rIjoixKciLCJIdW1wRG93bkh1bXAiOiLiiY4iLCJIdW1wRXF1YWwiOiLiiY8iLCJoeWJ1bGwiOiLigYMiLCJoeXBoZW4iOiLigJAiLCJJYWN1dGUiOiLDjSIsImlhY3V0ZSI6IsOtIiwiaWMiOiLigaMiLCJJY2lyYyI6IsOOIiwiaWNpcmMiOiLDriIsIkljeSI6ItCYIiwiaWN5Ijoi0LgiLCJJZG90IjoixLAiLCJJRWN5Ijoi0JUiLCJpZWN5Ijoi0LUiLCJpZXhjbCI6IsKhIiwiaWZmIjoi4oeUIiwiaWZyIjoi8J2UpiIsIklmciI6IuKEkSIsIklncmF2ZSI6IsOMIiwiaWdyYXZlIjoiw6wiLCJpaSI6IuKFiCIsImlpaWludCI6IuKojCIsImlpaW50Ijoi4oitIiwiaWluZmluIjoi4qecIiwiaWlvdGEiOiLihKkiLCJJSmxpZyI6IsSyIiwiaWpsaWciOiLEsyIsIkltYWNyIjoixKoiLCJpbWFjciI6IsSrIiwiaW1hZ2UiOiLihJEiLCJJbWFnaW5hcnlJIjoi4oWIIiwiaW1hZ2xpbmUiOiLihJAiLCJpbWFncGFydCI6IuKEkSIsImltYXRoIjoixLEiLCJJbSI6IuKEkSIsImltb2YiOiLiirciLCJpbXBlZCI6Isa1IiwiSW1wbGllcyI6IuKHkiIsImluY2FyZSI6IuKEhSIsImluIjoi4oiIIiwiaW5maW4iOiLiiJ4iLCJpbmZpbnRpZSI6IuKnnSIsImlub2RvdCI6IsSxIiwiaW50Y2FsIjoi4oq6IiwiaW50Ijoi4oirIiwiSW50Ijoi4oisIiwiaW50ZWdlcnMiOiLihKQiLCJJbnRlZ3JhbCI6IuKIqyIsImludGVyY2FsIjoi4oq6IiwiSW50ZXJzZWN0aW9uIjoi4ouCIiwiaW50bGFyaGsiOiLiqJciLCJpbnRwcm9kIjoi4qi8IiwiSW52aXNpYmxlQ29tbWEiOiLigaMiLCJJbnZpc2libGVUaW1lcyI6IuKBoiIsIklPY3kiOiLQgSIsImlvY3kiOiLRkSIsIklvZ29uIjoixK4iLCJpb2dvbiI6IsSvIiwiSW9wZiI6IvCdlYAiLCJpb3BmIjoi8J2VmiIsIklvdGEiOiLOmSIsImlvdGEiOiLOuSIsImlwcm9kIjoi4qi8IiwiaXF1ZXN0Ijoiwr8iLCJpc2NyIjoi8J2SviIsIklzY3IiOiLihJAiLCJpc2luIjoi4oiIIiwiaXNpbmRvdCI6IuKLtSIsImlzaW5FIjoi4ou5IiwiaXNpbnMiOiLii7QiLCJpc2luc3YiOiLii7MiLCJpc2ludiI6IuKIiCIsIml0Ijoi4oGiIiwiSXRpbGRlIjoixKgiLCJpdGlsZGUiOiLEqSIsIkl1a2N5Ijoi0IYiLCJpdWtjeSI6ItGWIiwiSXVtbCI6IsOPIiwiaXVtbCI6IsOvIiwiSmNpcmMiOiLEtCIsImpjaXJjIjoixLUiLCJKY3kiOiLQmSIsImpjeSI6ItC5IiwiSmZyIjoi8J2UjSIsImpmciI6IvCdlKciLCJqbWF0aCI6Isi3IiwiSm9wZiI6IvCdlYEiLCJqb3BmIjoi8J2VmyIsIkpzY3IiOiLwnZKlIiwianNjciI6IvCdkr8iLCJKc2VyY3kiOiLQiCIsImpzZXJjeSI6ItGYIiwiSnVrY3kiOiLQhCIsImp1a2N5Ijoi0ZQiLCJLYXBwYSI6Is6aIiwia2FwcGEiOiLOuiIsImthcHBhdiI6Is+wIiwiS2NlZGlsIjoixLYiLCJrY2VkaWwiOiLEtyIsIktjeSI6ItCaIiwia2N5Ijoi0LoiLCJLZnIiOiLwnZSOIiwia2ZyIjoi8J2UqCIsImtncmVlbiI6IsS4IiwiS0hjeSI6ItClIiwia2hjeSI6ItGFIiwiS0pjeSI6ItCMIiwia2pjeSI6ItGcIiwiS29wZiI6IvCdlYIiLCJrb3BmIjoi8J2VnCIsIktzY3IiOiLwnZKmIiwia3NjciI6IvCdk4AiLCJsQWFyciI6IuKHmiIsIkxhY3V0ZSI6IsS5IiwibGFjdXRlIjoixLoiLCJsYWVtcHR5diI6IuKmtCIsImxhZ3JhbiI6IuKEkiIsIkxhbWJkYSI6Is6bIiwibGFtYmRhIjoizrsiLCJsYW5nIjoi4p+oIiwiTGFuZyI6IuKfqiIsImxhbmdkIjoi4qaRIiwibGFuZ2xlIjoi4p+oIiwibGFwIjoi4qqFIiwiTGFwbGFjZXRyZiI6IuKEkiIsImxhcXVvIjoiwqsiLCJsYXJyYiI6IuKHpCIsImxhcnJiZnMiOiLipJ8iLCJsYXJyIjoi4oaQIiwiTGFyciI6IuKGniIsImxBcnIiOiLih5AiLCJsYXJyZnMiOiLipJ0iLCJsYXJyaGsiOiLihqkiLCJsYXJybHAiOiLihqsiLCJsYXJycGwiOiLipLkiLCJsYXJyc2ltIjoi4qWzIiwibGFycnRsIjoi4oaiIiwibGF0YWlsIjoi4qSZIiwibEF0YWlsIjoi4qSbIiwibGF0Ijoi4qqrIiwibGF0ZSI6IuKqrSIsImxhdGVzIjoi4qqt77iAIiwibGJhcnIiOiLipIwiLCJsQmFyciI6IuKkjiIsImxiYnJrIjoi4p2yIiwibGJyYWNlIjoieyIsImxicmFjayI6IlsiLCJsYnJrZSI6IuKmiyIsImxicmtzbGQiOiLipo8iLCJsYnJrc2x1Ijoi4qaNIiwiTGNhcm9uIjoixL0iLCJsY2Fyb24iOiLEviIsIkxjZWRpbCI6IsS7IiwibGNlZGlsIjoixLwiLCJsY2VpbCI6IuKMiCIsImxjdWIiOiJ7IiwiTGN5Ijoi0JsiLCJsY3kiOiLQuyIsImxkY2EiOiLipLYiLCJsZHF1byI6IuKAnCIsImxkcXVvciI6IuKAniIsImxkcmRoYXIiOiLipaciLCJsZHJ1c2hhciI6IuKliyIsImxkc2giOiLihrIiLCJsZSI6IuKJpCIsImxFIjoi4ommIiwiTGVmdEFuZ2xlQnJhY2tldCI6IuKfqCIsIkxlZnRBcnJvd0JhciI6IuKHpCIsImxlZnRhcnJvdyI6IuKGkCIsIkxlZnRBcnJvdyI6IuKGkCIsIkxlZnRhcnJvdyI6IuKHkCIsIkxlZnRBcnJvd1JpZ2h0QXJyb3ciOiLih4YiLCJsZWZ0YXJyb3d0YWlsIjoi4oaiIiwiTGVmdENlaWxpbmciOiLijIgiLCJMZWZ0RG91YmxlQnJhY2tldCI6IuKfpiIsIkxlZnREb3duVGVlVmVjdG9yIjoi4qWhIiwiTGVmdERvd25WZWN0b3JCYXIiOiLipZkiLCJMZWZ0RG93blZlY3RvciI6IuKHgyIsIkxlZnRGbG9vciI6IuKMiiIsImxlZnRoYXJwb29uZG93biI6IuKGvSIsImxlZnRoYXJwb29udXAiOiLihrwiLCJsZWZ0bGVmdGFycm93cyI6IuKHhyIsImxlZnRyaWdodGFycm93Ijoi4oaUIiwiTGVmdFJpZ2h0QXJyb3ciOiLihpQiLCJMZWZ0cmlnaHRhcnJvdyI6IuKHlCIsImxlZnRyaWdodGFycm93cyI6IuKHhiIsImxlZnRyaWdodGhhcnBvb25zIjoi4oeLIiwibGVmdHJpZ2h0c3F1aWdhcnJvdyI6IuKGrSIsIkxlZnRSaWdodFZlY3RvciI6IuKljiIsIkxlZnRUZWVBcnJvdyI6IuKGpCIsIkxlZnRUZWUiOiLiiqMiLCJMZWZ0VGVlVmVjdG9yIjoi4qWaIiwibGVmdHRocmVldGltZXMiOiLii4siLCJMZWZ0VHJpYW5nbGVCYXIiOiLip48iLCJMZWZ0VHJpYW5nbGUiOiLiirIiLCJMZWZ0VHJpYW5nbGVFcXVhbCI6IuKKtCIsIkxlZnRVcERvd25WZWN0b3IiOiLipZEiLCJMZWZ0VXBUZWVWZWN0b3IiOiLipaAiLCJMZWZ0VXBWZWN0b3JCYXIiOiLipZgiLCJMZWZ0VXBWZWN0b3IiOiLihr8iLCJMZWZ0VmVjdG9yQmFyIjoi4qWSIiwiTGVmdFZlY3RvciI6IuKGvCIsImxFZyI6IuKqiyIsImxlZyI6IuKLmiIsImxlcSI6IuKJpCIsImxlcXEiOiLiiaYiLCJsZXFzbGFudCI6IuKpvSIsImxlc2NjIjoi4qqoIiwibGVzIjoi4qm9IiwibGVzZG90Ijoi4qm/IiwibGVzZG90byI6IuKqgSIsImxlc2RvdG9yIjoi4qqDIiwibGVzZyI6IuKLmu+4gCIsImxlc2dlcyI6IuKqkyIsImxlc3NhcHByb3giOiLiqoUiLCJsZXNzZG90Ijoi4ouWIiwibGVzc2VxZ3RyIjoi4ouaIiwibGVzc2VxcWd0ciI6IuKqiyIsIkxlc3NFcXVhbEdyZWF0ZXIiOiLii5oiLCJMZXNzRnVsbEVxdWFsIjoi4ommIiwiTGVzc0dyZWF0ZXIiOiLiibYiLCJsZXNzZ3RyIjoi4om2IiwiTGVzc0xlc3MiOiLiqqEiLCJsZXNzc2ltIjoi4omyIiwiTGVzc1NsYW50RXF1YWwiOiLiqb0iLCJMZXNzVGlsZGUiOiLiibIiLCJsZmlzaHQiOiLipbwiLCJsZmxvb3IiOiLijIoiLCJMZnIiOiLwnZSPIiwibGZyIjoi8J2UqSIsImxnIjoi4om2IiwibGdFIjoi4qqRIiwibEhhciI6IuKloiIsImxoYXJkIjoi4oa9IiwibGhhcnUiOiLihrwiLCJsaGFydWwiOiLipaoiLCJsaGJsayI6IuKWhCIsIkxKY3kiOiLQiSIsImxqY3kiOiLRmSIsImxsYXJyIjoi4oeHIiwibGwiOiLiiaoiLCJMbCI6IuKLmCIsImxsY29ybmVyIjoi4oyeIiwiTGxlZnRhcnJvdyI6IuKHmiIsImxsaGFyZCI6IuKlqyIsImxsdHJpIjoi4pe6IiwiTG1pZG90IjoixL8iLCJsbWlkb3QiOiLFgCIsImxtb3VzdGFjaGUiOiLijrAiLCJsbW91c3QiOiLijrAiLCJsbmFwIjoi4qqJIiwibG5hcHByb3giOiLiqokiLCJsbmUiOiLiqociLCJsbkUiOiLiiagiLCJsbmVxIjoi4qqHIiwibG5lcXEiOiLiiagiLCJsbnNpbSI6IuKLpiIsImxvYW5nIjoi4p+sIiwibG9hcnIiOiLih70iLCJsb2JyayI6IuKfpiIsImxvbmdsZWZ0YXJyb3ciOiLin7UiLCJMb25nTGVmdEFycm93Ijoi4p+1IiwiTG9uZ2xlZnRhcnJvdyI6IuKfuCIsImxvbmdsZWZ0cmlnaHRhcnJvdyI6IuKftyIsIkxvbmdMZWZ0UmlnaHRBcnJvdyI6IuKftyIsIkxvbmdsZWZ0cmlnaHRhcnJvdyI6IuKfuiIsImxvbmdtYXBzdG8iOiLin7wiLCJsb25ncmlnaHRhcnJvdyI6IuKftiIsIkxvbmdSaWdodEFycm93Ijoi4p+2IiwiTG9uZ3JpZ2h0YXJyb3ciOiLin7kiLCJsb29wYXJyb3dsZWZ0Ijoi4oarIiwibG9vcGFycm93cmlnaHQiOiLihqwiLCJsb3BhciI6IuKmhSIsIkxvcGYiOiLwnZWDIiwibG9wZiI6IvCdlZ0iLCJsb3BsdXMiOiLiqK0iLCJsb3RpbWVzIjoi4qi0IiwibG93YXN0Ijoi4oiXIiwibG93YmFyIjoiXyIsIkxvd2VyTGVmdEFycm93Ijoi4oaZIiwiTG93ZXJSaWdodEFycm93Ijoi4oaYIiwibG96Ijoi4peKIiwibG96ZW5nZSI6IuKXiiIsImxvemYiOiLip6siLCJscGFyIjoiKCIsImxwYXJsdCI6IuKmkyIsImxyYXJyIjoi4oeGIiwibHJjb3JuZXIiOiLijJ8iLCJscmhhciI6IuKHiyIsImxyaGFyZCI6IuKlrSIsImxybSI6IuKAjiIsImxydHJpIjoi4oq/IiwibHNhcXVvIjoi4oC5IiwibHNjciI6IvCdk4EiLCJMc2NyIjoi4oSSIiwibHNoIjoi4oawIiwiTHNoIjoi4oawIiwibHNpbSI6IuKJsiIsImxzaW1lIjoi4qqNIiwibHNpbWciOiLiqo8iLCJsc3FiIjoiWyIsImxzcXVvIjoi4oCYIiwibHNxdW9yIjoi4oCaIiwiTHN0cm9rIjoixYEiLCJsc3Ryb2siOiLFgiIsImx0Y2MiOiLiqqYiLCJsdGNpciI6IuKpuSIsImx0IjoiPCIsIkxUIjoiPCIsIkx0Ijoi4omqIiwibHRkb3QiOiLii5YiLCJsdGhyZWUiOiLii4siLCJsdGltZXMiOiLii4kiLCJsdGxhcnIiOiLipbYiLCJsdHF1ZXN0Ijoi4qm7IiwibHRyaSI6IuKXgyIsImx0cmllIjoi4oq0IiwibHRyaWYiOiLil4IiLCJsdHJQYXIiOiLippYiLCJsdXJkc2hhciI6IuKliiIsImx1cnVoYXIiOiLipaYiLCJsdmVydG5lcXEiOiLiiajvuIAiLCJsdm5FIjoi4omo77iAIiwibWFjciI6IsKvIiwibWFsZSI6IuKZgiIsIm1hbHQiOiLinKAiLCJtYWx0ZXNlIjoi4pygIiwiTWFwIjoi4qSFIiwibWFwIjoi4oamIiwibWFwc3RvIjoi4oamIiwibWFwc3RvZG93biI6IuKGpyIsIm1hcHN0b2xlZnQiOiLihqQiLCJtYXBzdG91cCI6IuKGpSIsIm1hcmtlciI6IuKWriIsIm1jb21tYSI6IuKoqSIsIk1jeSI6ItCcIiwibWN5Ijoi0LwiLCJtZGFzaCI6IuKAlCIsIm1ERG90Ijoi4oi6IiwibWVhc3VyZWRhbmdsZSI6IuKIoSIsIk1lZGl1bVNwYWNlIjoi4oGfIiwiTWVsbGludHJmIjoi4oSzIiwiTWZyIjoi8J2UkCIsIm1mciI6IvCdlKoiLCJtaG8iOiLihKciLCJtaWNybyI6IsK1IiwibWlkYXN0IjoiKiIsIm1pZGNpciI6IuKrsCIsIm1pZCI6IuKIoyIsIm1pZGRvdCI6IsK3IiwibWludXNiIjoi4oqfIiwibWludXMiOiLiiJIiLCJtaW51c2QiOiLiiLgiLCJtaW51c2R1Ijoi4qiqIiwiTWludXNQbHVzIjoi4oiTIiwibWxjcCI6IuKrmyIsIm1sZHIiOiLigKYiLCJtbnBsdXMiOiLiiJMiLCJtb2RlbHMiOiLiiqciLCJNb3BmIjoi8J2VhCIsIm1vcGYiOiLwnZWeIiwibXAiOiLiiJMiLCJtc2NyIjoi8J2TgiIsIk1zY3IiOiLihLMiLCJtc3Rwb3MiOiLiiL4iLCJNdSI6Is6cIiwibXUiOiLOvCIsIm11bHRpbWFwIjoi4oq4IiwibXVtYXAiOiLiirgiLCJuYWJsYSI6IuKIhyIsIk5hY3V0ZSI6IsWDIiwibmFjdXRlIjoixYQiLCJuYW5nIjoi4oig4oOSIiwibmFwIjoi4omJIiwibmFwRSI6IuKpsMy4IiwibmFwaWQiOiLiiYvMuCIsIm5hcG9zIjoixYkiLCJuYXBwcm94Ijoi4omJIiwibmF0dXJhbCI6IuKZriIsIm5hdHVyYWxzIjoi4oSVIiwibmF0dXIiOiLima4iLCJuYnNwIjoiwqAiLCJuYnVtcCI6IuKJjsy4IiwibmJ1bXBlIjoi4omPzLgiLCJuY2FwIjoi4qmDIiwiTmNhcm9uIjoixYciLCJuY2Fyb24iOiLFiCIsIk5jZWRpbCI6IsWFIiwibmNlZGlsIjoixYYiLCJuY29uZyI6IuKJhyIsIm5jb25nZG90Ijoi4qmtzLgiLCJuY3VwIjoi4qmCIiwiTmN5Ijoi0J0iLCJuY3kiOiLQvSIsIm5kYXNoIjoi4oCTIiwibmVhcmhrIjoi4qSkIiwibmVhcnIiOiLihpciLCJuZUFyciI6IuKHlyIsIm5lYXJyb3ciOiLihpciLCJuZSI6IuKJoCIsIm5lZG90Ijoi4omQzLgiLCJOZWdhdGl2ZU1lZGl1bVNwYWNlIjoi4oCLIiwiTmVnYXRpdmVUaGlja1NwYWNlIjoi4oCLIiwiTmVnYXRpdmVUaGluU3BhY2UiOiLigIsiLCJOZWdhdGl2ZVZlcnlUaGluU3BhY2UiOiLigIsiLCJuZXF1aXYiOiLiiaIiLCJuZXNlYXIiOiLipKgiLCJuZXNpbSI6IuKJgsy4IiwiTmVzdGVkR3JlYXRlckdyZWF0ZXIiOiLiiasiLCJOZXN0ZWRMZXNzTGVzcyI6IuKJqiIsIk5ld0xpbmUiOiJcXG4iLCJuZXhpc3QiOiLiiIQiLCJuZXhpc3RzIjoi4oiEIiwiTmZyIjoi8J2UkSIsIm5mciI6IvCdlKsiLCJuZ0UiOiLiiafMuCIsIm5nZSI6IuKJsSIsIm5nZXEiOiLiibEiLCJuZ2VxcSI6IuKJp8y4IiwibmdlcXNsYW50Ijoi4qm+zLgiLCJuZ2VzIjoi4qm+zLgiLCJuR2ciOiLii5nMuCIsIm5nc2ltIjoi4om1Iiwibkd0Ijoi4omr4oOSIiwibmd0Ijoi4omvIiwibmd0ciI6IuKJryIsIm5HdHYiOiLiiavMuCIsIm5oYXJyIjoi4oauIiwibmhBcnIiOiLih44iLCJuaHBhciI6IuKrsiIsIm5pIjoi4oiLIiwibmlzIjoi4ou8IiwibmlzZCI6IuKLuiIsIm5pdiI6IuKIiyIsIk5KY3kiOiLQiiIsIm5qY3kiOiLRmiIsIm5sYXJyIjoi4oaaIiwibmxBcnIiOiLih40iLCJubGRyIjoi4oClIiwibmxFIjoi4ommzLgiLCJubGUiOiLiibAiLCJubGVmdGFycm93Ijoi4oaaIiwibkxlZnRhcnJvdyI6IuKHjSIsIm5sZWZ0cmlnaHRhcnJvdyI6IuKGriIsIm5MZWZ0cmlnaHRhcnJvdyI6IuKHjiIsIm5sZXEiOiLiibAiLCJubGVxcSI6IuKJpsy4IiwibmxlcXNsYW50Ijoi4qm9zLgiLCJubGVzIjoi4qm9zLgiLCJubGVzcyI6IuKJriIsIm5MbCI6IuKLmMy4IiwibmxzaW0iOiLiibQiLCJuTHQiOiLiiarig5IiLCJubHQiOiLiia4iLCJubHRyaSI6IuKLqiIsIm5sdHJpZSI6IuKLrCIsIm5MdHYiOiLiiarMuCIsIm5taWQiOiLiiKQiLCJOb0JyZWFrIjoi4oGgIiwiTm9uQnJlYWtpbmdTcGFjZSI6IsKgIiwibm9wZiI6IvCdlZ8iLCJOb3BmIjoi4oSVIiwiTm90Ijoi4qusIiwibm90IjoiwqwiLCJOb3RDb25ncnVlbnQiOiLiiaIiLCJOb3RDdXBDYXAiOiLiia0iLCJOb3REb3VibGVWZXJ0aWNhbEJhciI6IuKIpiIsIk5vdEVsZW1lbnQiOiLiiIkiLCJOb3RFcXVhbCI6IuKJoCIsIk5vdEVxdWFsVGlsZGUiOiLiiYLMuCIsIk5vdEV4aXN0cyI6IuKIhCIsIk5vdEdyZWF0ZXIiOiLiia8iLCJOb3RHcmVhdGVyRXF1YWwiOiLiibEiLCJOb3RHcmVhdGVyRnVsbEVxdWFsIjoi4omnzLgiLCJOb3RHcmVhdGVyR3JlYXRlciI6IuKJq8y4IiwiTm90R3JlYXRlckxlc3MiOiLiibkiLCJOb3RHcmVhdGVyU2xhbnRFcXVhbCI6IuKpvsy4IiwiTm90R3JlYXRlclRpbGRlIjoi4om1IiwiTm90SHVtcERvd25IdW1wIjoi4omOzLgiLCJOb3RIdW1wRXF1YWwiOiLiiY/MuCIsIm5vdGluIjoi4oiJIiwibm90aW5kb3QiOiLii7XMuCIsIm5vdGluRSI6IuKLucy4Iiwibm90aW52YSI6IuKIiSIsIm5vdGludmIiOiLii7ciLCJub3RpbnZjIjoi4ou2IiwiTm90TGVmdFRyaWFuZ2xlQmFyIjoi4qePzLgiLCJOb3RMZWZ0VHJpYW5nbGUiOiLii6oiLCJOb3RMZWZ0VHJpYW5nbGVFcXVhbCI6IuKLrCIsIk5vdExlc3MiOiLiia4iLCJOb3RMZXNzRXF1YWwiOiLiibAiLCJOb3RMZXNzR3JlYXRlciI6IuKJuCIsIk5vdExlc3NMZXNzIjoi4omqzLgiLCJOb3RMZXNzU2xhbnRFcXVhbCI6IuKpvcy4IiwiTm90TGVzc1RpbGRlIjoi4om0IiwiTm90TmVzdGVkR3JlYXRlckdyZWF0ZXIiOiLiqqLMuCIsIk5vdE5lc3RlZExlc3NMZXNzIjoi4qqhzLgiLCJub3RuaSI6IuKIjCIsIm5vdG5pdmEiOiLiiIwiLCJub3RuaXZiIjoi4ou+Iiwibm90bml2YyI6IuKLvSIsIk5vdFByZWNlZGVzIjoi4oqAIiwiTm90UHJlY2VkZXNFcXVhbCI6IuKqr8y4IiwiTm90UHJlY2VkZXNTbGFudEVxdWFsIjoi4ougIiwiTm90UmV2ZXJzZUVsZW1lbnQiOiLiiIwiLCJOb3RSaWdodFRyaWFuZ2xlQmFyIjoi4qeQzLgiLCJOb3RSaWdodFRyaWFuZ2xlIjoi4ourIiwiTm90UmlnaHRUcmlhbmdsZUVxdWFsIjoi4outIiwiTm90U3F1YXJlU3Vic2V0Ijoi4oqPzLgiLCJOb3RTcXVhcmVTdWJzZXRFcXVhbCI6IuKLoiIsIk5vdFNxdWFyZVN1cGVyc2V0Ijoi4oqQzLgiLCJOb3RTcXVhcmVTdXBlcnNldEVxdWFsIjoi4oujIiwiTm90U3Vic2V0Ijoi4oqC4oOSIiwiTm90U3Vic2V0RXF1YWwiOiLiiogiLCJOb3RTdWNjZWVkcyI6IuKKgSIsIk5vdFN1Y2NlZWRzRXF1YWwiOiLiqrDMuCIsIk5vdFN1Y2NlZWRzU2xhbnRFcXVhbCI6IuKLoSIsIk5vdFN1Y2NlZWRzVGlsZGUiOiLiib/MuCIsIk5vdFN1cGVyc2V0Ijoi4oqD4oOSIiwiTm90U3VwZXJzZXRFcXVhbCI6IuKKiSIsIk5vdFRpbGRlIjoi4omBIiwiTm90VGlsZGVFcXVhbCI6IuKJhCIsIk5vdFRpbGRlRnVsbEVxdWFsIjoi4omHIiwiTm90VGlsZGVUaWxkZSI6IuKJiSIsIk5vdFZlcnRpY2FsQmFyIjoi4oikIiwibnBhcmFsbGVsIjoi4oimIiwibnBhciI6IuKIpiIsIm5wYXJzbCI6IuKrveKDpSIsIm5wYXJ0Ijoi4oiCzLgiLCJucG9saW50Ijoi4qiUIiwibnByIjoi4oqAIiwibnByY3VlIjoi4ougIiwibnByZWMiOiLiioAiLCJucHJlY2VxIjoi4qqvzLgiLCJucHJlIjoi4qqvzLgiLCJucmFycmMiOiLipLPMuCIsIm5yYXJyIjoi4oabIiwibnJBcnIiOiLih48iLCJucmFycnciOiLihp3MuCIsIm5yaWdodGFycm93Ijoi4oabIiwiblJpZ2h0YXJyb3ciOiLih48iLCJucnRyaSI6IuKLqyIsIm5ydHJpZSI6IuKLrSIsIm5zYyI6IuKKgSIsIm5zY2N1ZSI6IuKLoSIsIm5zY2UiOiLiqrDMuCIsIk5zY3IiOiLwnZKpIiwibnNjciI6IvCdk4MiLCJuc2hvcnRtaWQiOiLiiKQiLCJuc2hvcnRwYXJhbGxlbCI6IuKIpiIsIm5zaW0iOiLiiYEiLCJuc2ltZSI6IuKJhCIsIm5zaW1lcSI6IuKJhCIsIm5zbWlkIjoi4oikIiwibnNwYXIiOiLiiKYiLCJuc3FzdWJlIjoi4ouiIiwibnNxc3VwZSI6IuKLoyIsIm5zdWIiOiLiioQiLCJuc3ViRSI6IuKrhcy4IiwibnN1YmUiOiLiiogiLCJuc3Vic2V0Ijoi4oqC4oOSIiwibnN1YnNldGVxIjoi4oqIIiwibnN1YnNldGVxcSI6IuKrhcy4IiwibnN1Y2MiOiLiioEiLCJuc3VjY2VxIjoi4qqwzLgiLCJuc3VwIjoi4oqFIiwibnN1cEUiOiLiq4bMuCIsIm5zdXBlIjoi4oqJIiwibnN1cHNldCI6IuKKg+KDkiIsIm5zdXBzZXRlcSI6IuKKiSIsIm5zdXBzZXRlcXEiOiLiq4bMuCIsIm50Z2wiOiLiibkiLCJOdGlsZGUiOiLDkSIsIm50aWxkZSI6IsOxIiwibnRsZyI6IuKJuCIsIm50cmlhbmdsZWxlZnQiOiLii6oiLCJudHJpYW5nbGVsZWZ0ZXEiOiLii6wiLCJudHJpYW5nbGVyaWdodCI6IuKLqyIsIm50cmlhbmdsZXJpZ2h0ZXEiOiLii60iLCJOdSI6Is6dIiwibnUiOiLOvSIsIm51bSI6IiMiLCJudW1lcm8iOiLihJYiLCJudW1zcCI6IuKAhyIsIm52YXAiOiLiiY3ig5IiLCJudmRhc2giOiLiiqwiLCJudkRhc2giOiLiiq0iLCJuVmRhc2giOiLiiq4iLCJuVkRhc2giOiLiiq8iLCJudmdlIjoi4oml4oOSIiwibnZndCI6Ij7ig5IiLCJudkhhcnIiOiLipIQiLCJudmluZmluIjoi4qeeIiwibnZsQXJyIjoi4qSCIiwibnZsZSI6IuKJpOKDkiIsIm52bHQiOiI84oOSIiwibnZsdHJpZSI6IuKKtOKDkiIsIm52ckFyciI6IuKkgyIsIm52cnRyaWUiOiLiirXig5IiLCJudnNpbSI6IuKIvOKDkiIsIm53YXJoayI6IuKkoyIsIm53YXJyIjoi4oaWIiwibndBcnIiOiLih5YiLCJud2Fycm93Ijoi4oaWIiwibnduZWFyIjoi4qSnIiwiT2FjdXRlIjoiw5MiLCJvYWN1dGUiOiLDsyIsIm9hc3QiOiLiipsiLCJPY2lyYyI6IsOUIiwib2NpcmMiOiLDtCIsIm9jaXIiOiLiipoiLCJPY3kiOiLQniIsIm9jeSI6ItC+Iiwib2Rhc2giOiLiip0iLCJPZGJsYWMiOiLFkCIsIm9kYmxhYyI6IsWRIiwib2RpdiI6IuKouCIsIm9kb3QiOiLiipkiLCJvZHNvbGQiOiLiprwiLCJPRWxpZyI6IsWSIiwib2VsaWciOiLFkyIsIm9mY2lyIjoi4qa/IiwiT2ZyIjoi8J2UkiIsIm9mciI6IvCdlKwiLCJvZ29uIjoiy5siLCJPZ3JhdmUiOiLDkiIsIm9ncmF2ZSI6IsOyIiwib2d0Ijoi4qeBIiwib2hiYXIiOiLiprUiLCJvaG0iOiLOqSIsIm9pbnQiOiLiiK4iLCJvbGFyciI6IuKGuiIsIm9sY2lyIjoi4qa+Iiwib2xjcm9zcyI6IuKmuyIsIm9saW5lIjoi4oC+Iiwib2x0Ijoi4qeAIiwiT21hY3IiOiLFjCIsIm9tYWNyIjoixY0iLCJPbWVnYSI6Is6pIiwib21lZ2EiOiLPiSIsIk9taWNyb24iOiLOnyIsIm9taWNyb24iOiLOvyIsIm9taWQiOiLiprYiLCJvbWludXMiOiLiipYiLCJPb3BmIjoi8J2VhiIsIm9vcGYiOiLwnZWgIiwib3BhciI6IuKmtyIsIk9wZW5DdXJseURvdWJsZVF1b3RlIjoi4oCcIiwiT3BlbkN1cmx5UXVvdGUiOiLigJgiLCJvcGVycCI6IuKmuSIsIm9wbHVzIjoi4oqVIiwib3JhcnIiOiLihrsiLCJPciI6IuKplCIsIm9yIjoi4oioIiwib3JkIjoi4qmdIiwib3JkZXIiOiLihLQiLCJvcmRlcm9mIjoi4oS0Iiwib3JkZiI6IsKqIiwib3JkbSI6IsK6Iiwib3JpZ29mIjoi4oq2Iiwib3JvciI6IuKpliIsIm9yc2xvcGUiOiLiqZciLCJvcnYiOiLiqZsiLCJvUyI6IuKTiCIsIk9zY3IiOiLwnZKqIiwib3NjciI6IuKEtCIsIk9zbGFzaCI6IsOYIiwib3NsYXNoIjoiw7giLCJvc29sIjoi4oqYIiwiT3RpbGRlIjoiw5UiLCJvdGlsZGUiOiLDtSIsIm90aW1lc2FzIjoi4qi2IiwiT3RpbWVzIjoi4qi3Iiwib3RpbWVzIjoi4oqXIiwiT3VtbCI6IsOWIiwib3VtbCI6IsO2Iiwib3ZiYXIiOiLijL0iLCJPdmVyQmFyIjoi4oC+IiwiT3ZlckJyYWNlIjoi4o+eIiwiT3ZlckJyYWNrZXQiOiLijrQiLCJPdmVyUGFyZW50aGVzaXMiOiLij5wiLCJwYXJhIjoiwrYiLCJwYXJhbGxlbCI6IuKIpSIsInBhciI6IuKIpSIsInBhcnNpbSI6IuKrsyIsInBhcnNsIjoi4qu9IiwicGFydCI6IuKIgiIsIlBhcnRpYWxEIjoi4oiCIiwiUGN5Ijoi0J8iLCJwY3kiOiLQvyIsInBlcmNudCI6IiUiLCJwZXJpb2QiOiIuIiwicGVybWlsIjoi4oCwIiwicGVycCI6IuKKpSIsInBlcnRlbmsiOiLigLEiLCJQZnIiOiLwnZSTIiwicGZyIjoi8J2UrSIsIlBoaSI6Is6mIiwicGhpIjoiz4YiLCJwaGl2Ijoiz5UiLCJwaG1tYXQiOiLihLMiLCJwaG9uZSI6IuKYjiIsIlBpIjoizqAiLCJwaSI6Is+AIiwicGl0Y2hmb3JrIjoi4ouUIiwicGl2Ijoiz5YiLCJwbGFuY2siOiLihI8iLCJwbGFuY2toIjoi4oSOIiwicGxhbmt2Ijoi4oSPIiwicGx1c2FjaXIiOiLiqKMiLCJwbHVzYiI6IuKKniIsInBsdXNjaXIiOiLiqKIiLCJwbHVzIjoiKyIsInBsdXNkbyI6IuKIlCIsInBsdXNkdSI6IuKopSIsInBsdXNlIjoi4qmyIiwiUGx1c01pbnVzIjoiwrEiLCJwbHVzbW4iOiLCsSIsInBsdXNzaW0iOiLiqKYiLCJwbHVzdHdvIjoi4qinIiwicG0iOiLCsSIsIlBvaW5jYXJlcGxhbmUiOiLihIwiLCJwb2ludGludCI6IuKolSIsInBvcGYiOiLwnZWhIiwiUG9wZiI6IuKEmSIsInBvdW5kIjoiwqMiLCJwcmFwIjoi4qq3IiwiUHIiOiLiqrsiLCJwciI6IuKJuiIsInByY3VlIjoi4om8IiwicHJlY2FwcHJveCI6IuKqtyIsInByZWMiOiLiiboiLCJwcmVjY3VybHllcSI6IuKJvCIsIlByZWNlZGVzIjoi4om6IiwiUHJlY2VkZXNFcXVhbCI6IuKqryIsIlByZWNlZGVzU2xhbnRFcXVhbCI6IuKJvCIsIlByZWNlZGVzVGlsZGUiOiLiib4iLCJwcmVjZXEiOiLiqq8iLCJwcmVjbmFwcHJveCI6IuKquSIsInByZWNuZXFxIjoi4qq1IiwicHJlY25zaW0iOiLii6giLCJwcmUiOiLiqq8iLCJwckUiOiLiqrMiLCJwcmVjc2ltIjoi4om+IiwicHJpbWUiOiLigLIiLCJQcmltZSI6IuKAsyIsInByaW1lcyI6IuKEmSIsInBybmFwIjoi4qq5IiwicHJuRSI6IuKqtSIsInBybnNpbSI6IuKLqCIsInByb2QiOiLiiI8iLCJQcm9kdWN0Ijoi4oiPIiwicHJvZmFsYXIiOiLijK4iLCJwcm9mbGluZSI6IuKMkiIsInByb2ZzdXJmIjoi4oyTIiwicHJvcCI6IuKInSIsIlByb3BvcnRpb25hbCI6IuKInSIsIlByb3BvcnRpb24iOiLiiLciLCJwcm9wdG8iOiLiiJ0iLCJwcnNpbSI6IuKJviIsInBydXJlbCI6IuKKsCIsIlBzY3IiOiLwnZKrIiwicHNjciI6IvCdk4UiLCJQc2kiOiLOqCIsInBzaSI6Is+IIiwicHVuY3NwIjoi4oCIIiwiUWZyIjoi8J2UlCIsInFmciI6IvCdlK4iLCJxaW50Ijoi4qiMIiwicW9wZiI6IvCdlaIiLCJRb3BmIjoi4oSaIiwicXByaW1lIjoi4oGXIiwiUXNjciI6IvCdkqwiLCJxc2NyIjoi8J2ThiIsInF1YXRlcm5pb25zIjoi4oSNIiwicXVhdGludCI6IuKoliIsInF1ZXN0IjoiPyIsInF1ZXN0ZXEiOiLiiZ8iLCJxdW90IjoiXFwiIiwiUVVPVCI6IlxcIiIsInJBYXJyIjoi4oebIiwicmFjZSI6IuKIvcyxIiwiUmFjdXRlIjoixZQiLCJyYWN1dGUiOiLFlSIsInJhZGljIjoi4oiaIiwicmFlbXB0eXYiOiLiprMiLCJyYW5nIjoi4p+pIiwiUmFuZyI6IuKfqyIsInJhbmdkIjoi4qaSIiwicmFuZ2UiOiLipqUiLCJyYW5nbGUiOiLin6kiLCJyYXF1byI6IsK7IiwicmFycmFwIjoi4qW1IiwicmFycmIiOiLih6UiLCJyYXJyYmZzIjoi4qSgIiwicmFycmMiOiLipLMiLCJyYXJyIjoi4oaSIiwiUmFyciI6IuKGoCIsInJBcnIiOiLih5IiLCJyYXJyZnMiOiLipJ4iLCJyYXJyaGsiOiLihqoiLCJyYXJybHAiOiLihqwiLCJyYXJycGwiOiLipYUiLCJyYXJyc2ltIjoi4qW0IiwiUmFycnRsIjoi4qSWIiwicmFycnRsIjoi4oajIiwicmFycnciOiLihp0iLCJyYXRhaWwiOiLipJoiLCJyQXRhaWwiOiLipJwiLCJyYXRpbyI6IuKItiIsInJhdGlvbmFscyI6IuKEmiIsInJiYXJyIjoi4qSNIiwickJhcnIiOiLipI8iLCJSQmFyciI6IuKkkCIsInJiYnJrIjoi4p2zIiwicmJyYWNlIjoifSIsInJicmFjayI6Il0iLCJyYnJrZSI6IuKmjCIsInJicmtzbGQiOiLipo4iLCJyYnJrc2x1Ijoi4qaQIiwiUmNhcm9uIjoixZgiLCJyY2Fyb24iOiLFmSIsIlJjZWRpbCI6IsWWIiwicmNlZGlsIjoixZciLCJyY2VpbCI6IuKMiSIsInJjdWIiOiJ9IiwiUmN5Ijoi0KAiLCJyY3kiOiLRgCIsInJkY2EiOiLipLciLCJyZGxkaGFyIjoi4qWpIiwicmRxdW8iOiLigJ0iLCJyZHF1b3IiOiLigJ0iLCJyZHNoIjoi4oazIiwicmVhbCI6IuKEnCIsInJlYWxpbmUiOiLihJsiLCJyZWFscGFydCI6IuKEnCIsInJlYWxzIjoi4oSdIiwiUmUiOiLihJwiLCJyZWN0Ijoi4patIiwicmVnIjoiwq4iLCJSRUciOiLCriIsIlJldmVyc2VFbGVtZW50Ijoi4oiLIiwiUmV2ZXJzZUVxdWlsaWJyaXVtIjoi4oeLIiwiUmV2ZXJzZVVwRXF1aWxpYnJpdW0iOiLipa8iLCJyZmlzaHQiOiLipb0iLCJyZmxvb3IiOiLijIsiLCJyZnIiOiLwnZSvIiwiUmZyIjoi4oScIiwickhhciI6IuKlpCIsInJoYXJkIjoi4oeBIiwicmhhcnUiOiLih4AiLCJyaGFydWwiOiLipawiLCJSaG8iOiLOoSIsInJobyI6Is+BIiwicmhvdiI6Is+xIiwiUmlnaHRBbmdsZUJyYWNrZXQiOiLin6kiLCJSaWdodEFycm93QmFyIjoi4oelIiwicmlnaHRhcnJvdyI6IuKGkiIsIlJpZ2h0QXJyb3ciOiLihpIiLCJSaWdodGFycm93Ijoi4oeSIiwiUmlnaHRBcnJvd0xlZnRBcnJvdyI6IuKHhCIsInJpZ2h0YXJyb3d0YWlsIjoi4oajIiwiUmlnaHRDZWlsaW5nIjoi4oyJIiwiUmlnaHREb3VibGVCcmFja2V0Ijoi4p+nIiwiUmlnaHREb3duVGVlVmVjdG9yIjoi4qWdIiwiUmlnaHREb3duVmVjdG9yQmFyIjoi4qWVIiwiUmlnaHREb3duVmVjdG9yIjoi4oeCIiwiUmlnaHRGbG9vciI6IuKMiyIsInJpZ2h0aGFycG9vbmRvd24iOiLih4EiLCJyaWdodGhhcnBvb251cCI6IuKHgCIsInJpZ2h0bGVmdGFycm93cyI6IuKHhCIsInJpZ2h0bGVmdGhhcnBvb25zIjoi4oeMIiwicmlnaHRyaWdodGFycm93cyI6IuKHiSIsInJpZ2h0c3F1aWdhcnJvdyI6IuKGnSIsIlJpZ2h0VGVlQXJyb3ciOiLihqYiLCJSaWdodFRlZSI6IuKKoiIsIlJpZ2h0VGVlVmVjdG9yIjoi4qWbIiwicmlnaHR0aHJlZXRpbWVzIjoi4ouMIiwiUmlnaHRUcmlhbmdsZUJhciI6IuKnkCIsIlJpZ2h0VHJpYW5nbGUiOiLiirMiLCJSaWdodFRyaWFuZ2xlRXF1YWwiOiLiirUiLCJSaWdodFVwRG93blZlY3RvciI6IuKljyIsIlJpZ2h0VXBUZWVWZWN0b3IiOiLipZwiLCJSaWdodFVwVmVjdG9yQmFyIjoi4qWUIiwiUmlnaHRVcFZlY3RvciI6IuKGviIsIlJpZ2h0VmVjdG9yQmFyIjoi4qWTIiwiUmlnaHRWZWN0b3IiOiLih4AiLCJyaW5nIjoiy5oiLCJyaXNpbmdkb3RzZXEiOiLiiZMiLCJybGFyciI6IuKHhCIsInJsaGFyIjoi4oeMIiwicmxtIjoi4oCPIiwicm1vdXN0YWNoZSI6IuKOsSIsInJtb3VzdCI6IuKOsSIsInJubWlkIjoi4quuIiwicm9hbmciOiLin60iLCJyb2FyciI6IuKHviIsInJvYnJrIjoi4p+nIiwicm9wYXIiOiLipoYiLCJyb3BmIjoi8J2VoyIsIlJvcGYiOiLihJ0iLCJyb3BsdXMiOiLiqK4iLCJyb3RpbWVzIjoi4qi1IiwiUm91bmRJbXBsaWVzIjoi4qWwIiwicnBhciI6IikiLCJycGFyZ3QiOiLippQiLCJycHBvbGludCI6IuKokiIsInJyYXJyIjoi4oeJIiwiUnJpZ2h0YXJyb3ciOiLih5siLCJyc2FxdW8iOiLigLoiLCJyc2NyIjoi8J2ThyIsIlJzY3IiOiLihJsiLCJyc2giOiLihrEiLCJSc2giOiLihrEiLCJyc3FiIjoiXSIsInJzcXVvIjoi4oCZIiwicnNxdW9yIjoi4oCZIiwicnRocmVlIjoi4ouMIiwicnRpbWVzIjoi4ouKIiwicnRyaSI6IuKWuSIsInJ0cmllIjoi4oq1IiwicnRyaWYiOiLilrgiLCJydHJpbHRyaSI6IuKnjiIsIlJ1bGVEZWxheWVkIjoi4qe0IiwicnVsdWhhciI6IuKlqCIsInJ4Ijoi4oSeIiwiU2FjdXRlIjoixZoiLCJzYWN1dGUiOiLFmyIsInNicXVvIjoi4oCaIiwic2NhcCI6IuKquCIsIlNjYXJvbiI6IsWgIiwic2Nhcm9uIjoixaEiLCJTYyI6IuKqvCIsInNjIjoi4om7Iiwic2NjdWUiOiLiib0iLCJzY2UiOiLiqrAiLCJzY0UiOiLiqrQiLCJTY2VkaWwiOiLFniIsInNjZWRpbCI6IsWfIiwiU2NpcmMiOiLFnCIsInNjaXJjIjoixZ0iLCJzY25hcCI6IuKquiIsInNjbkUiOiLiqrYiLCJzY25zaW0iOiLii6kiLCJzY3BvbGludCI6IuKokyIsInNjc2ltIjoi4om/IiwiU2N5Ijoi0KEiLCJzY3kiOiLRgSIsInNkb3RiIjoi4oqhIiwic2RvdCI6IuKLhSIsInNkb3RlIjoi4qmmIiwic2VhcmhrIjoi4qSlIiwic2VhcnIiOiLihpgiLCJzZUFyciI6IuKHmCIsInNlYXJyb3ciOiLihpgiLCJzZWN0IjoiwqciLCJzZW1pIjoiOyIsInNlc3dhciI6IuKkqSIsInNldG1pbnVzIjoi4oiWIiwic2V0bW4iOiLiiJYiLCJzZXh0Ijoi4py2IiwiU2ZyIjoi8J2UliIsInNmciI6IvCdlLAiLCJzZnJvd24iOiLijKIiLCJzaGFycCI6IuKZryIsIlNIQ0hjeSI6ItCpIiwic2hjaGN5Ijoi0YkiLCJTSGN5Ijoi0KgiLCJzaGN5Ijoi0YgiLCJTaG9ydERvd25BcnJvdyI6IuKGkyIsIlNob3J0TGVmdEFycm93Ijoi4oaQIiwic2hvcnRtaWQiOiLiiKMiLCJzaG9ydHBhcmFsbGVsIjoi4oilIiwiU2hvcnRSaWdodEFycm93Ijoi4oaSIiwiU2hvcnRVcEFycm93Ijoi4oaRIiwic2h5Ijoiwq0iLCJTaWdtYSI6Is6jIiwic2lnbWEiOiLPgyIsInNpZ21hZiI6Is+CIiwic2lnbWF2Ijoiz4IiLCJzaW0iOiLiiLwiLCJzaW1kb3QiOiLiqaoiLCJzaW1lIjoi4omDIiwic2ltZXEiOiLiiYMiLCJzaW1nIjoi4qqeIiwic2ltZ0UiOiLiqqAiLCJzaW1sIjoi4qqdIiwic2ltbEUiOiLiqp8iLCJzaW1uZSI6IuKJhiIsInNpbXBsdXMiOiLiqKQiLCJzaW1yYXJyIjoi4qWyIiwic2xhcnIiOiLihpAiLCJTbWFsbENpcmNsZSI6IuKImCIsInNtYWxsc2V0bWludXMiOiLiiJYiLCJzbWFzaHAiOiLiqLMiLCJzbWVwYXJzbCI6IuKnpCIsInNtaWQiOiLiiKMiLCJzbWlsZSI6IuKMoyIsInNtdCI6IuKqqiIsInNtdGUiOiLiqqwiLCJzbXRlcyI6IuKqrO+4gCIsIlNPRlRjeSI6ItCsIiwic29mdGN5Ijoi0YwiLCJzb2xiYXIiOiLijL8iLCJzb2xiIjoi4qeEIiwic29sIjoiLyIsIlNvcGYiOiLwnZWKIiwic29wZiI6IvCdlaQiLCJzcGFkZXMiOiLimaAiLCJzcGFkZXN1aXQiOiLimaAiLCJzcGFyIjoi4oilIiwic3FjYXAiOiLiipMiLCJzcWNhcHMiOiLiipPvuIAiLCJzcWN1cCI6IuKKlCIsInNxY3VwcyI6IuKKlO+4gCIsIlNxcnQiOiLiiJoiLCJzcXN1YiI6IuKKjyIsInNxc3ViZSI6IuKKkSIsInNxc3Vic2V0Ijoi4oqPIiwic3FzdWJzZXRlcSI6IuKKkSIsInNxc3VwIjoi4oqQIiwic3FzdXBlIjoi4oqSIiwic3FzdXBzZXQiOiLiipAiLCJzcXN1cHNldGVxIjoi4oqSIiwic3F1YXJlIjoi4pahIiwiU3F1YXJlIjoi4pahIiwiU3F1YXJlSW50ZXJzZWN0aW9uIjoi4oqTIiwiU3F1YXJlU3Vic2V0Ijoi4oqPIiwiU3F1YXJlU3Vic2V0RXF1YWwiOiLiipEiLCJTcXVhcmVTdXBlcnNldCI6IuKKkCIsIlNxdWFyZVN1cGVyc2V0RXF1YWwiOiLiipIiLCJTcXVhcmVVbmlvbiI6IuKKlCIsInNxdWFyZiI6IuKWqiIsInNxdSI6IuKWoSIsInNxdWYiOiLilqoiLCJzcmFyciI6IuKGkiIsIlNzY3IiOiLwnZKuIiwic3NjciI6IvCdk4giLCJzc2V0bW4iOiLiiJYiLCJzc21pbGUiOiLijKMiLCJzc3RhcmYiOiLii4YiLCJTdGFyIjoi4ouGIiwic3RhciI6IuKYhiIsInN0YXJmIjoi4piFIiwic3RyYWlnaHRlcHNpbG9uIjoiz7UiLCJzdHJhaWdodHBoaSI6Is+VIiwic3RybnMiOiLCryIsInN1YiI6IuKKgiIsIlN1YiI6IuKLkCIsInN1YmRvdCI6IuKqvSIsInN1YkUiOiLiq4UiLCJzdWJlIjoi4oqGIiwic3ViZWRvdCI6IuKrgyIsInN1Ym11bHQiOiLiq4EiLCJzdWJuRSI6IuKriyIsInN1Ym5lIjoi4oqKIiwic3VicGx1cyI6IuKqvyIsInN1YnJhcnIiOiLipbkiLCJzdWJzZXQiOiLiioIiLCJTdWJzZXQiOiLii5AiLCJzdWJzZXRlcSI6IuKKhiIsInN1YnNldGVxcSI6IuKrhSIsIlN1YnNldEVxdWFsIjoi4oqGIiwic3Vic2V0bmVxIjoi4oqKIiwic3Vic2V0bmVxcSI6IuKriyIsInN1YnNpbSI6IuKrhyIsInN1YnN1YiI6IuKrlSIsInN1YnN1cCI6IuKrkyIsInN1Y2NhcHByb3giOiLiqrgiLCJzdWNjIjoi4om7Iiwic3VjY2N1cmx5ZXEiOiLiib0iLCJTdWNjZWVkcyI6IuKJuyIsIlN1Y2NlZWRzRXF1YWwiOiLiqrAiLCJTdWNjZWVkc1NsYW50RXF1YWwiOiLiib0iLCJTdWNjZWVkc1RpbGRlIjoi4om/Iiwic3VjY2VxIjoi4qqwIiwic3VjY25hcHByb3giOiLiqroiLCJzdWNjbmVxcSI6IuKqtiIsInN1Y2Nuc2ltIjoi4oupIiwic3VjY3NpbSI6IuKJvyIsIlN1Y2hUaGF0Ijoi4oiLIiwic3VtIjoi4oiRIiwiU3VtIjoi4oiRIiwic3VuZyI6IuKZqiIsInN1cDEiOiLCuSIsInN1cDIiOiLCsiIsInN1cDMiOiLCsyIsInN1cCI6IuKKgyIsIlN1cCI6IuKLkSIsInN1cGRvdCI6IuKqviIsInN1cGRzdWIiOiLiq5giLCJzdXBFIjoi4quGIiwic3VwZSI6IuKKhyIsInN1cGVkb3QiOiLiq4QiLCJTdXBlcnNldCI6IuKKgyIsIlN1cGVyc2V0RXF1YWwiOiLiiociLCJzdXBoc29sIjoi4p+JIiwic3VwaHN1YiI6IuKrlyIsInN1cGxhcnIiOiLipbsiLCJzdXBtdWx0Ijoi4quCIiwic3VwbkUiOiLiq4wiLCJzdXBuZSI6IuKKiyIsInN1cHBsdXMiOiLiq4AiLCJzdXBzZXQiOiLiioMiLCJTdXBzZXQiOiLii5EiLCJzdXBzZXRlcSI6IuKKhyIsInN1cHNldGVxcSI6IuKrhiIsInN1cHNldG5lcSI6IuKKiyIsInN1cHNldG5lcXEiOiLiq4wiLCJzdXBzaW0iOiLiq4giLCJzdXBzdWIiOiLiq5QiLCJzdXBzdXAiOiLiq5YiLCJzd2FyaGsiOiLipKYiLCJzd2FyciI6IuKGmSIsInN3QXJyIjoi4oeZIiwic3dhcnJvdyI6IuKGmSIsInN3bndhciI6IuKkqiIsInN6bGlnIjoiw58iLCJUYWIiOiJcXHQiLCJ0YXJnZXQiOiLijJYiLCJUYXUiOiLOpCIsInRhdSI6Is+EIiwidGJyayI6IuKOtCIsIlRjYXJvbiI6IsWkIiwidGNhcm9uIjoixaUiLCJUY2VkaWwiOiLFoiIsInRjZWRpbCI6IsWjIiwiVGN5Ijoi0KIiLCJ0Y3kiOiLRgiIsInRkb3QiOiLig5siLCJ0ZWxyZWMiOiLijJUiLCJUZnIiOiLwnZSXIiwidGZyIjoi8J2UsSIsInRoZXJlNCI6IuKItCIsInRoZXJlZm9yZSI6IuKItCIsIlRoZXJlZm9yZSI6IuKItCIsIlRoZXRhIjoizpgiLCJ0aGV0YSI6Is64IiwidGhldGFzeW0iOiLPkSIsInRoZXRhdiI6Is+RIiwidGhpY2thcHByb3giOiLiiYgiLCJ0aGlja3NpbSI6IuKIvCIsIlRoaWNrU3BhY2UiOiLigZ/igIoiLCJUaGluU3BhY2UiOiLigIkiLCJ0aGluc3AiOiLigIkiLCJ0aGthcCI6IuKJiCIsInRoa3NpbSI6IuKIvCIsIlRIT1JOIjoiw54iLCJ0aG9ybiI6IsO+IiwidGlsZGUiOiLLnCIsIlRpbGRlIjoi4oi8IiwiVGlsZGVFcXVhbCI6IuKJgyIsIlRpbGRlRnVsbEVxdWFsIjoi4omFIiwiVGlsZGVUaWxkZSI6IuKJiCIsInRpbWVzYmFyIjoi4qixIiwidGltZXNiIjoi4oqgIiwidGltZXMiOiLDlyIsInRpbWVzZCI6IuKosCIsInRpbnQiOiLiiK0iLCJ0b2VhIjoi4qSoIiwidG9wYm90Ijoi4oy2IiwidG9wY2lyIjoi4quxIiwidG9wIjoi4oqkIiwiVG9wZiI6IvCdlYsiLCJ0b3BmIjoi8J2VpSIsInRvcGZvcmsiOiLiq5oiLCJ0b3NhIjoi4qSpIiwidHByaW1lIjoi4oC0IiwidHJhZGUiOiLihKIiLCJUUkFERSI6IuKEoiIsInRyaWFuZ2xlIjoi4pa1IiwidHJpYW5nbGVkb3duIjoi4pa/IiwidHJpYW5nbGVsZWZ0Ijoi4peDIiwidHJpYW5nbGVsZWZ0ZXEiOiLiirQiLCJ0cmlhbmdsZXEiOiLiiZwiLCJ0cmlhbmdsZXJpZ2h0Ijoi4pa5IiwidHJpYW5nbGVyaWdodGVxIjoi4oq1IiwidHJpZG90Ijoi4pesIiwidHJpZSI6IuKJnCIsInRyaW1pbnVzIjoi4qi6IiwiVHJpcGxlRG90Ijoi4oObIiwidHJpcGx1cyI6IuKouSIsInRyaXNiIjoi4qeNIiwidHJpdGltZSI6IuKouyIsInRycGV6aXVtIjoi4o+iIiwiVHNjciI6IvCdkq8iLCJ0c2NyIjoi8J2TiSIsIlRTY3kiOiLQpiIsInRzY3kiOiLRhiIsIlRTSGN5Ijoi0IsiLCJ0c2hjeSI6ItGbIiwiVHN0cm9rIjoixaYiLCJ0c3Ryb2siOiLFpyIsInR3aXh0Ijoi4omsIiwidHdvaGVhZGxlZnRhcnJvdyI6IuKGniIsInR3b2hlYWRyaWdodGFycm93Ijoi4oagIiwiVWFjdXRlIjoiw5oiLCJ1YWN1dGUiOiLDuiIsInVhcnIiOiLihpEiLCJVYXJyIjoi4oafIiwidUFyciI6IuKHkSIsIlVhcnJvY2lyIjoi4qWJIiwiVWJyY3kiOiLQjiIsInVicmN5Ijoi0Z4iLCJVYnJldmUiOiLFrCIsInVicmV2ZSI6IsWtIiwiVWNpcmMiOiLDmyIsInVjaXJjIjoiw7siLCJVY3kiOiLQoyIsInVjeSI6ItGDIiwidWRhcnIiOiLih4UiLCJVZGJsYWMiOiLFsCIsInVkYmxhYyI6IsWxIiwidWRoYXIiOiLipa4iLCJ1ZmlzaHQiOiLipb4iLCJVZnIiOiLwnZSYIiwidWZyIjoi8J2UsiIsIlVncmF2ZSI6IsOZIiwidWdyYXZlIjoiw7kiLCJ1SGFyIjoi4qWjIiwidWhhcmwiOiLihr8iLCJ1aGFyciI6IuKGviIsInVoYmxrIjoi4paAIiwidWxjb3JuIjoi4oycIiwidWxjb3JuZXIiOiLijJwiLCJ1bGNyb3AiOiLijI8iLCJ1bHRyaSI6IuKXuCIsIlVtYWNyIjoixaoiLCJ1bWFjciI6IsWrIiwidW1sIjoiwqgiLCJVbmRlckJhciI6Il8iLCJVbmRlckJyYWNlIjoi4o+fIiwiVW5kZXJCcmFja2V0Ijoi4o61IiwiVW5kZXJQYXJlbnRoZXNpcyI6IuKPnSIsIlVuaW9uIjoi4ouDIiwiVW5pb25QbHVzIjoi4oqOIiwiVW9nb24iOiLFsiIsInVvZ29uIjoixbMiLCJVb3BmIjoi8J2VjCIsInVvcGYiOiLwnZWmIiwiVXBBcnJvd0JhciI6IuKkkiIsInVwYXJyb3ciOiLihpEiLCJVcEFycm93Ijoi4oaRIiwiVXBhcnJvdyI6IuKHkSIsIlVwQXJyb3dEb3duQXJyb3ciOiLih4UiLCJ1cGRvd25hcnJvdyI6IuKGlSIsIlVwRG93bkFycm93Ijoi4oaVIiwiVXBkb3duYXJyb3ciOiLih5UiLCJVcEVxdWlsaWJyaXVtIjoi4qWuIiwidXBoYXJwb29ubGVmdCI6IuKGvyIsInVwaGFycG9vbnJpZ2h0Ijoi4oa+IiwidXBsdXMiOiLiio4iLCJVcHBlckxlZnRBcnJvdyI6IuKGliIsIlVwcGVyUmlnaHRBcnJvdyI6IuKGlyIsInVwc2kiOiLPhSIsIlVwc2kiOiLPkiIsInVwc2loIjoiz5IiLCJVcHNpbG9uIjoizqUiLCJ1cHNpbG9uIjoiz4UiLCJVcFRlZUFycm93Ijoi4oalIiwiVXBUZWUiOiLiiqUiLCJ1cHVwYXJyb3dzIjoi4oeIIiwidXJjb3JuIjoi4oydIiwidXJjb3JuZXIiOiLijJ0iLCJ1cmNyb3AiOiLijI4iLCJVcmluZyI6IsWuIiwidXJpbmciOiLFryIsInVydHJpIjoi4pe5IiwiVXNjciI6IvCdkrAiLCJ1c2NyIjoi8J2TiiIsInV0ZG90Ijoi4ouwIiwiVXRpbGRlIjoixagiLCJ1dGlsZGUiOiLFqSIsInV0cmkiOiLilrUiLCJ1dHJpZiI6IuKWtCIsInV1YXJyIjoi4oeIIiwiVXVtbCI6IsOcIiwidXVtbCI6IsO8IiwidXdhbmdsZSI6IuKmpyIsInZhbmdydCI6IuKmnCIsInZhcmVwc2lsb24iOiLPtSIsInZhcmthcHBhIjoiz7AiLCJ2YXJub3RoaW5nIjoi4oiFIiwidmFycGhpIjoiz5UiLCJ2YXJwaSI6Is+WIiwidmFycHJvcHRvIjoi4oidIiwidmFyciI6IuKGlSIsInZBcnIiOiLih5UiLCJ2YXJyaG8iOiLPsSIsInZhcnNpZ21hIjoiz4IiLCJ2YXJzdWJzZXRuZXEiOiLiiorvuIAiLCJ2YXJzdWJzZXRuZXFxIjoi4quL77iAIiwidmFyc3Vwc2V0bmVxIjoi4oqL77iAIiwidmFyc3Vwc2V0bmVxcSI6IuKrjO+4gCIsInZhcnRoZXRhIjoiz5EiLCJ2YXJ0cmlhbmdsZWxlZnQiOiLiirIiLCJ2YXJ0cmlhbmdsZXJpZ2h0Ijoi4oqzIiwidkJhciI6IuKrqCIsIlZiYXIiOiLiq6siLCJ2QmFydiI6IuKrqSIsIlZjeSI6ItCSIiwidmN5Ijoi0LIiLCJ2ZGFzaCI6IuKKoiIsInZEYXNoIjoi4oqoIiwiVmRhc2giOiLiiqkiLCJWRGFzaCI6IuKKqyIsIlZkYXNobCI6IuKrpiIsInZlZWJhciI6IuKKuyIsInZlZSI6IuKIqCIsIlZlZSI6IuKLgSIsInZlZWVxIjoi4omaIiwidmVsbGlwIjoi4ouuIiwidmVyYmFyIjoifCIsIlZlcmJhciI6IuKAliIsInZlcnQiOiJ8IiwiVmVydCI6IuKAliIsIlZlcnRpY2FsQmFyIjoi4oijIiwiVmVydGljYWxMaW5lIjoifCIsIlZlcnRpY2FsU2VwYXJhdG9yIjoi4p2YIiwiVmVydGljYWxUaWxkZSI6IuKJgCIsIlZlcnlUaGluU3BhY2UiOiLigIoiLCJWZnIiOiLwnZSZIiwidmZyIjoi8J2UsyIsInZsdHJpIjoi4oqyIiwidm5zdWIiOiLiioLig5IiLCJ2bnN1cCI6IuKKg+KDkiIsIlZvcGYiOiLwnZWNIiwidm9wZiI6IvCdlaciLCJ2cHJvcCI6IuKInSIsInZydHJpIjoi4oqzIiwiVnNjciI6IvCdkrEiLCJ2c2NyIjoi8J2TiyIsInZzdWJuRSI6IuKri++4gCIsInZzdWJuZSI6IuKKiu+4gCIsInZzdXBuRSI6IuKrjO+4gCIsInZzdXBuZSI6IuKKi++4gCIsIlZ2ZGFzaCI6IuKKqiIsInZ6aWd6YWciOiLippoiLCJXY2lyYyI6IsW0Iiwid2NpcmMiOiLFtSIsIndlZGJhciI6IuKpnyIsIndlZGdlIjoi4oinIiwiV2VkZ2UiOiLii4AiLCJ3ZWRnZXEiOiLiiZkiLCJ3ZWllcnAiOiLihJgiLCJXZnIiOiLwnZSaIiwid2ZyIjoi8J2UtCIsIldvcGYiOiLwnZWOIiwid29wZiI6IvCdlagiLCJ3cCI6IuKEmCIsIndyIjoi4omAIiwid3JlYXRoIjoi4omAIiwiV3NjciI6IvCdkrIiLCJ3c2NyIjoi8J2TjCIsInhjYXAiOiLii4IiLCJ4Y2lyYyI6IuKXryIsInhjdXAiOiLii4MiLCJ4ZHRyaSI6IuKWvSIsIlhmciI6IvCdlJsiLCJ4ZnIiOiLwnZS1IiwieGhhcnIiOiLin7ciLCJ4aEFyciI6IuKfuiIsIlhpIjoizp4iLCJ4aSI6Is6+IiwieGxhcnIiOiLin7UiLCJ4bEFyciI6IuKfuCIsInhtYXAiOiLin7wiLCJ4bmlzIjoi4ou7IiwieG9kb3QiOiLiqIAiLCJYb3BmIjoi8J2VjyIsInhvcGYiOiLwnZWpIiwieG9wbHVzIjoi4qiBIiwieG90aW1lIjoi4qiCIiwieHJhcnIiOiLin7YiLCJ4ckFyciI6IuKfuSIsIlhzY3IiOiLwnZKzIiwieHNjciI6IvCdk40iLCJ4c3FjdXAiOiLiqIYiLCJ4dXBsdXMiOiLiqIQiLCJ4dXRyaSI6IuKWsyIsInh2ZWUiOiLii4EiLCJ4d2VkZ2UiOiLii4AiLCJZYWN1dGUiOiLDnSIsInlhY3V0ZSI6IsO9IiwiWUFjeSI6ItCvIiwieWFjeSI6ItGPIiwiWWNpcmMiOiLFtiIsInljaXJjIjoixbciLCJZY3kiOiLQqyIsInljeSI6ItGLIiwieWVuIjoiwqUiLCJZZnIiOiLwnZScIiwieWZyIjoi8J2UtiIsIllJY3kiOiLQhyIsInlpY3kiOiLRlyIsIllvcGYiOiLwnZWQIiwieW9wZiI6IvCdlaoiLCJZc2NyIjoi8J2StCIsInlzY3IiOiLwnZOOIiwiWVVjeSI6ItCuIiwieXVjeSI6ItGOIiwieXVtbCI6IsO/IiwiWXVtbCI6IsW4IiwiWmFjdXRlIjoixbkiLCJ6YWN1dGUiOiLFuiIsIlpjYXJvbiI6IsW9IiwiemNhcm9uIjoixb4iLCJaY3kiOiLQlyIsInpjeSI6ItC3IiwiWmRvdCI6IsW7IiwiemRvdCI6IsW8IiwiemVldHJmIjoi4oSoIiwiWmVyb1dpZHRoU3BhY2UiOiLigIsiLCJaZXRhIjoizpYiLCJ6ZXRhIjoizrYiLCJ6ZnIiOiLwnZS3IiwiWmZyIjoi4oSoIiwiWkhjeSI6ItCWIiwiemhjeSI6ItC2IiwiemlncmFyciI6IuKHnSIsInpvcGYiOiLwnZWrIiwiWm9wZiI6IuKEpCIsIlpzY3IiOiLwnZK1IiwienNjciI6IvCdk48iLCJ6d2oiOiLigI0iLCJ6d25qIjoi4oCMIn0nKX0sZnVuY3Rpb24oUil7Ui5leHBvcnRzPUpTT04ucGFyc2UoJ3siQWFjdXRlIjoiw4EiLCJhYWN1dGUiOiLDoSIsIkFjaXJjIjoiw4IiLCJhY2lyYyI6IsOiIiwiYWN1dGUiOiLCtCIsIkFFbGlnIjoiw4YiLCJhZWxpZyI6IsOmIiwiQWdyYXZlIjoiw4AiLCJhZ3JhdmUiOiLDoCIsImFtcCI6IiYiLCJBTVAiOiImIiwiQXJpbmciOiLDhSIsImFyaW5nIjoiw6UiLCJBdGlsZGUiOiLDgyIsImF0aWxkZSI6IsOjIiwiQXVtbCI6IsOEIiwiYXVtbCI6IsOkIiwiYnJ2YmFyIjoiwqYiLCJDY2VkaWwiOiLDhyIsImNjZWRpbCI6IsOnIiwiY2VkaWwiOiLCuCIsImNlbnQiOiLCoiIsImNvcHkiOiLCqSIsIkNPUFkiOiLCqSIsImN1cnJlbiI6IsKkIiwiZGVnIjoiwrAiLCJkaXZpZGUiOiLDtyIsIkVhY3V0ZSI6IsOJIiwiZWFjdXRlIjoiw6kiLCJFY2lyYyI6IsOKIiwiZWNpcmMiOiLDqiIsIkVncmF2ZSI6IsOIIiwiZWdyYXZlIjoiw6giLCJFVEgiOiLDkCIsImV0aCI6IsOwIiwiRXVtbCI6IsOLIiwiZXVtbCI6IsOrIiwiZnJhYzEyIjoiwr0iLCJmcmFjMTQiOiLCvCIsImZyYWMzNCI6IsK+IiwiZ3QiOiI+IiwiR1QiOiI+IiwiSWFjdXRlIjoiw40iLCJpYWN1dGUiOiLDrSIsIkljaXJjIjoiw44iLCJpY2lyYyI6IsOuIiwiaWV4Y2wiOiLCoSIsIklncmF2ZSI6IsOMIiwiaWdyYXZlIjoiw6wiLCJpcXVlc3QiOiLCvyIsIkl1bWwiOiLDjyIsIml1bWwiOiLDryIsImxhcXVvIjoiwqsiLCJsdCI6IjwiLCJMVCI6IjwiLCJtYWNyIjoiwq8iLCJtaWNybyI6IsK1IiwibWlkZG90IjoiwrciLCJuYnNwIjoiwqAiLCJub3QiOiLCrCIsIk50aWxkZSI6IsORIiwibnRpbGRlIjoiw7EiLCJPYWN1dGUiOiLDkyIsIm9hY3V0ZSI6IsOzIiwiT2NpcmMiOiLDlCIsIm9jaXJjIjoiw7QiLCJPZ3JhdmUiOiLDkiIsIm9ncmF2ZSI6IsOyIiwib3JkZiI6IsKqIiwib3JkbSI6IsK6IiwiT3NsYXNoIjoiw5giLCJvc2xhc2giOiLDuCIsIk90aWxkZSI6IsOVIiwib3RpbGRlIjoiw7UiLCJPdW1sIjoiw5YiLCJvdW1sIjoiw7YiLCJwYXJhIjoiwrYiLCJwbHVzbW4iOiLCsSIsInBvdW5kIjoiwqMiLCJxdW90IjoiXFwiIiwiUVVPVCI6IlxcIiIsInJhcXVvIjoiwrsiLCJyZWciOiLCriIsIlJFRyI6IsKuIiwic2VjdCI6IsKnIiwic2h5Ijoiwq0iLCJzdXAxIjoiwrkiLCJzdXAyIjoiwrIiLCJzdXAzIjoiwrMiLCJzemxpZyI6IsOfIiwiVEhPUk4iOiLDniIsInRob3JuIjoiw74iLCJ0aW1lcyI6IsOXIiwiVWFjdXRlIjoiw5oiLCJ1YWN1dGUiOiLDuiIsIlVjaXJjIjoiw5siLCJ1Y2lyYyI6IsO7IiwiVWdyYXZlIjoiw5kiLCJ1Z3JhdmUiOiLDuSIsInVtbCI6IsKoIiwiVXVtbCI6IsOcIiwidXVtbCI6IsO8IiwiWWFjdXRlIjoiw50iLCJ5YWN1dGUiOiLDvSIsInllbiI6IsKlIiwieXVtbCI6IsO/In0nKX0sZnVuY3Rpb24oUil7Ui5leHBvcnRzPUpTT04ucGFyc2UoYHsiYW1wIjoiJiIsImFwb3MiOiInIiwiZ3QiOiI+IiwibHQiOiI8IiwicXVvdCI6IlxcIiJ9YCl9LGZ1bmN0aW9uKFIsZSx0KXt2YXIgaT10aGlzJiZ0aGlzLl9faW1wb3J0RGVmYXVsdHx8ZnVuY3Rpb24odil7cmV0dXJuIHYmJnYuX19lc01vZHVsZT92OntkZWZhdWx0OnZ9fTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSk7dmFyIG89aSh0KDI2NSkpO2Z1bmN0aW9uIGcodil7aWYodj49NTUyOTYmJnY8PTU3MzQzfHx2PjExMTQxMTEpcmV0dXJuIu+/vSI7diBpbiBvLmRlZmF1bHQmJih2PW8uZGVmYXVsdFt2XSk7dmFyIGM9IiI7cmV0dXJuIHY+NjU1MzUmJih2LT02NTUzNixjKz1TdHJpbmcuZnJvbUNoYXJDb2RlKHY+Pj4xMCYxMDIzfDU1Mjk2KSx2PTU2MzIwfHYmMTAyMyksYys9U3RyaW5nLmZyb21DaGFyQ29kZSh2KSxjfWUuZGVmYXVsdD1nfSxmdW5jdGlvbihSKXtSLmV4cG9ydHM9SlNPTi5wYXJzZSgneyIwIjo2NTUzMywiMTI4Ijo4MzY0LCIxMzAiOjgyMTgsIjEzMSI6NDAyLCIxMzIiOjgyMjIsIjEzMyI6ODIzMCwiMTM0Ijo4MjI0LCIxMzUiOjgyMjUsIjEzNiI6NzEwLCIxMzciOjgyNDAsIjEzOCI6MzUyLCIxMzkiOjgyNDksIjE0MCI6MzM4LCIxNDIiOjM4MSwiMTQ1Ijo4MjE2LCIxNDYiOjgyMTcsIjE0NyI6ODIyMCwiMTQ4Ijo4MjIxLCIxNDkiOjgyMjYsIjE1MCI6ODIxMSwiMTUxIjo4MjEyLCIxNTIiOjczMiwiMTUzIjo4NDgyLCIxNTQiOjM1MywiMTU1Ijo4MjUwLCIxNTYiOjMzOSwiMTU4IjozODIsIjE1OSI6Mzc2fScpfSxmdW5jdGlvbihSLGUsdCl7dmFyIGk9dGhpcyYmdGhpcy5fX2ltcG9ydERlZmF1bHR8fGZ1bmN0aW9uKHkpe3JldHVybiB5JiZ5Ll9fZXNNb2R1bGU/eTp7ZGVmYXVsdDp5fX07T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLGUuZXNjYXBlPWUuZW5jb2RlSFRNTD1lLmVuY29kZVhNTD12b2lkIDA7dmFyIG89aSh0KDI2MykpLGc9RShvLmRlZmF1bHQpLHY9bChnKTtlLmVuY29kZVhNTD1DKGcsdik7dmFyIGM9aSh0KDI2MSkpLGY9RShjLmRlZmF1bHQpLGg9bChmKTtlLmVuY29kZUhUTUw9QyhmLGgpO2Z1bmN0aW9uIEUoeSl7cmV0dXJuIE9iamVjdC5rZXlzKHkpLnNvcnQoKS5yZWR1Y2UoZnVuY3Rpb24ocixzKXtyZXR1cm4gclt5W3NdXT0iJiIrcysiOyIscn0se30pfWZ1bmN0aW9uIGwoeSl7Zm9yKHZhciByPVtdLHM9W10sbj0wLGE9T2JqZWN0LmtleXMoeSk7bjxhLmxlbmd0aDtuKyspe3ZhciBPPWFbbl07Ty5sZW5ndGg9PT0xP3IucHVzaCgiXFwiK08pOnMucHVzaChPKX1yLnNvcnQoKTtmb3IodmFyIEE9MDtBPHIubGVuZ3RoLTE7QSsrKXtmb3IodmFyIGI9QTtiPHIubGVuZ3RoLTEmJnJbYl0uY2hhckNvZGVBdCgxKSsxPT09cltiKzFdLmNoYXJDb2RlQXQoMSk7KWIrPTE7dmFyIEk9MStiLUE7STwzfHxyLnNwbGljZShBLEkscltBXSsiLSIrcltiXSl9cmV0dXJuIHMudW5zaGlmdCgiWyIrci5qb2luKCIiKSsiXSIpLG5ldyBSZWdFeHAocy5qb2luKCJ8IiksImciKX12YXIgbT0vKD86W1x4ODAtXHVEN0ZGXHVFMDAwLVx1RkZGRl18W1x1RDgwMC1cdURCRkZdW1x1REMwMC1cdURGRkZdfFtcdUQ4MDAtXHVEQkZGXSg/IVtcdURDMDAtXHVERkZGXSl8KD86W15cdUQ4MDAtXHVEQkZGXXxeKVtcdURDMDAtXHVERkZGXSkvZztmdW5jdGlvbiBwKHkpe3JldHVybiImI3giK3kuY29kZVBvaW50QXQoMCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkrIjsifWZ1bmN0aW9uIEMoeSxyKXtyZXR1cm4gZnVuY3Rpb24ocyl7cmV0dXJuIHMucmVwbGFjZShyLGZ1bmN0aW9uKG4pe3JldHVybiB5W25dfSkucmVwbGFjZShtLHApfX12YXIgeD1sKGcpO2Z1bmN0aW9uIGQoeSl7cmV0dXJuIHkucmVwbGFjZSh4LHApLnJlcGxhY2UobSxwKX1lLmVzY2FwZT1kfSxmdW5jdGlvbihSKXtSLmV4cG9ydHM9SlNPTi5wYXJzZSgneyJlbGVtZW50TmFtZXMiOnsiYWx0Z2x5cGgiOiJhbHRHbHlwaCIsImFsdGdseXBoZGVmIjoiYWx0R2x5cGhEZWYiLCJhbHRnbHlwaGl0ZW0iOiJhbHRHbHlwaEl0ZW0iLCJhbmltYXRlY29sb3IiOiJhbmltYXRlQ29sb3IiLCJhbmltYXRlbW90aW9uIjoiYW5pbWF0ZU1vdGlvbiIsImFuaW1hdGV0cmFuc2Zvcm0iOiJhbmltYXRlVHJhbnNmb3JtIiwiY2xpcHBhdGgiOiJjbGlwUGF0aCIsImZlYmxlbmQiOiJmZUJsZW5kIiwiZmVjb2xvcm1hdHJpeCI6ImZlQ29sb3JNYXRyaXgiLCJmZWNvbXBvbmVudHRyYW5zZmVyIjoiZmVDb21wb25lbnRUcmFuc2ZlciIsImZlY29tcG9zaXRlIjoiZmVDb21wb3NpdGUiLCJmZWNvbnZvbHZlbWF0cml4IjoiZmVDb252b2x2ZU1hdHJpeCIsImZlZGlmZnVzZWxpZ2h0aW5nIjoiZmVEaWZmdXNlTGlnaHRpbmciLCJmZWRpc3BsYWNlbWVudG1hcCI6ImZlRGlzcGxhY2VtZW50TWFwIiwiZmVkaXN0YW50bGlnaHQiOiJmZURpc3RhbnRMaWdodCIsImZlZHJvcHNoYWRvdyI6ImZlRHJvcFNoYWRvdyIsImZlZmxvb2QiOiJmZUZsb29kIiwiZmVmdW5jYSI6ImZlRnVuY0EiLCJmZWZ1bmNiIjoiZmVGdW5jQiIsImZlZnVuY2ciOiJmZUZ1bmNHIiwiZmVmdW5jciI6ImZlRnVuY1IiLCJmZWdhdXNzaWFuYmx1ciI6ImZlR2F1c3NpYW5CbHVyIiwiZmVpbWFnZSI6ImZlSW1hZ2UiLCJmZW1lcmdlIjoiZmVNZXJnZSIsImZlbWVyZ2Vub2RlIjoiZmVNZXJnZU5vZGUiLCJmZW1vcnBob2xvZ3kiOiJmZU1vcnBob2xvZ3kiLCJmZW9mZnNldCI6ImZlT2Zmc2V0IiwiZmVwb2ludGxpZ2h0IjoiZmVQb2ludExpZ2h0IiwiZmVzcGVjdWxhcmxpZ2h0aW5nIjoiZmVTcGVjdWxhckxpZ2h0aW5nIiwiZmVzcG90bGlnaHQiOiJmZVNwb3RMaWdodCIsImZldGlsZSI6ImZlVGlsZSIsImZldHVyYnVsZW5jZSI6ImZlVHVyYnVsZW5jZSIsImZvcmVpZ25vYmplY3QiOiJmb3JlaWduT2JqZWN0IiwiZ2x5cGhyZWYiOiJnbHlwaFJlZiIsImxpbmVhcmdyYWRpZW50IjoibGluZWFyR3JhZGllbnQiLCJyYWRpYWxncmFkaWVudCI6InJhZGlhbEdyYWRpZW50IiwidGV4dHBhdGgiOiJ0ZXh0UGF0aCJ9LCJhdHRyaWJ1dGVOYW1lcyI6eyJkZWZpbml0aW9udXJsIjoiZGVmaW5pdGlvblVSTCIsImF0dHJpYnV0ZW5hbWUiOiJhdHRyaWJ1dGVOYW1lIiwiYXR0cmlidXRldHlwZSI6ImF0dHJpYnV0ZVR5cGUiLCJiYXNlZnJlcXVlbmN5IjoiYmFzZUZyZXF1ZW5jeSIsImJhc2Vwcm9maWxlIjoiYmFzZVByb2ZpbGUiLCJjYWxjbW9kZSI6ImNhbGNNb2RlIiwiY2xpcHBhdGh1bml0cyI6ImNsaXBQYXRoVW5pdHMiLCJkaWZmdXNlY29uc3RhbnQiOiJkaWZmdXNlQ29uc3RhbnQiLCJlZGdlbW9kZSI6ImVkZ2VNb2RlIiwiZmlsdGVydW5pdHMiOiJmaWx0ZXJVbml0cyIsImdseXBocmVmIjoiZ2x5cGhSZWYiLCJncmFkaWVudHRyYW5zZm9ybSI6ImdyYWRpZW50VHJhbnNmb3JtIiwiZ3JhZGllbnR1bml0cyI6ImdyYWRpZW50VW5pdHMiLCJrZXJuZWxtYXRyaXgiOiJrZXJuZWxNYXRyaXgiLCJrZXJuZWx1bml0bGVuZ3RoIjoia2VybmVsVW5pdExlbmd0aCIsImtleXBvaW50cyI6ImtleVBvaW50cyIsImtleXNwbGluZXMiOiJrZXlTcGxpbmVzIiwia2V5dGltZXMiOiJrZXlUaW1lcyIsImxlbmd0aGFkanVzdCI6Imxlbmd0aEFkanVzdCIsImxpbWl0aW5nY29uZWFuZ2xlIjoibGltaXRpbmdDb25lQW5nbGUiLCJtYXJrZXJoZWlnaHQiOiJtYXJrZXJIZWlnaHQiLCJtYXJrZXJ1bml0cyI6Im1hcmtlclVuaXRzIiwibWFya2Vyd2lkdGgiOiJtYXJrZXJXaWR0aCIsIm1hc2tjb250ZW50dW5pdHMiOiJtYXNrQ29udGVudFVuaXRzIiwibWFza3VuaXRzIjoibWFza1VuaXRzIiwibnVtb2N0YXZlcyI6Im51bU9jdGF2ZXMiLCJwYXRobGVuZ3RoIjoicGF0aExlbmd0aCIsInBhdHRlcm5jb250ZW50dW5pdHMiOiJwYXR0ZXJuQ29udGVudFVuaXRzIiwicGF0dGVybnRyYW5zZm9ybSI6InBhdHRlcm5UcmFuc2Zvcm0iLCJwYXR0ZXJudW5pdHMiOiJwYXR0ZXJuVW5pdHMiLCJwb2ludHNhdHgiOiJwb2ludHNBdFgiLCJwb2ludHNhdHkiOiJwb2ludHNBdFkiLCJwb2ludHNhdHoiOiJwb2ludHNBdFoiLCJwcmVzZXJ2ZWFscGhhIjoicHJlc2VydmVBbHBoYSIsInByZXNlcnZlYXNwZWN0cmF0aW8iOiJwcmVzZXJ2ZUFzcGVjdFJhdGlvIiwicHJpbWl0aXZldW5pdHMiOiJwcmltaXRpdmVVbml0cyIsInJlZngiOiJyZWZYIiwicmVmeSI6InJlZlkiLCJyZXBlYXRjb3VudCI6InJlcGVhdENvdW50IiwicmVwZWF0ZHVyIjoicmVwZWF0RHVyIiwicmVxdWlyZWRleHRlbnNpb25zIjoicmVxdWlyZWRFeHRlbnNpb25zIiwicmVxdWlyZWRmZWF0dXJlcyI6InJlcXVpcmVkRmVhdHVyZXMiLCJzcGVjdWxhcmNvbnN0YW50Ijoic3BlY3VsYXJDb25zdGFudCIsInNwZWN1bGFyZXhwb25lbnQiOiJzcGVjdWxhckV4cG9uZW50Iiwic3ByZWFkbWV0aG9kIjoic3ByZWFkTWV0aG9kIiwic3RhcnRvZmZzZXQiOiJzdGFydE9mZnNldCIsInN0ZGRldmlhdGlvbiI6InN0ZERldmlhdGlvbiIsInN0aXRjaHRpbGVzIjoic3RpdGNoVGlsZXMiLCJzdXJmYWNlc2NhbGUiOiJzdXJmYWNlU2NhbGUiLCJzeXN0ZW1sYW5ndWFnZSI6InN5c3RlbUxhbmd1YWdlIiwidGFibGV2YWx1ZXMiOiJ0YWJsZVZhbHVlcyIsInRhcmdldHgiOiJ0YXJnZXRYIiwidGFyZ2V0eSI6InRhcmdldFkiLCJ0ZXh0bGVuZ3RoIjoidGV4dExlbmd0aCIsInZpZXdib3giOiJ2aWV3Qm94Iiwidmlld3RhcmdldCI6InZpZXdUYXJnZXQiLCJ4Y2hhbm5lbHNlbGVjdG9yIjoieENoYW5uZWxTZWxlY3RvciIsInljaGFubmVsc2VsZWN0b3IiOiJ5Q2hhbm5lbFNlbGVjdG9yIiwiem9vbWFuZHBhbiI6Inpvb21BbmRQYW4ifX0nKX0sZnVuY3Rpb24oUixlKXt2YXIgdD1lLmdldENoaWxkcmVuPWZ1bmN0aW9uKG8pe3JldHVybiBvLmNoaWxkcmVufSxpPWUuZ2V0UGFyZW50PWZ1bmN0aW9uKG8pe3JldHVybiBvLnBhcmVudH07ZS5nZXRTaWJsaW5ncz1mdW5jdGlvbihvKXt2YXIgZz1pKG8pO3JldHVybiBnP3QoZyk6W29dfSxlLmdldEF0dHJpYnV0ZVZhbHVlPWZ1bmN0aW9uKG8sZyl7cmV0dXJuIG8uYXR0cmlicyYmby5hdHRyaWJzW2ddfSxlLmhhc0F0dHJpYj1mdW5jdGlvbihvLGcpe3JldHVybiEhby5hdHRyaWJzJiZoYXNPd25Qcm9wZXJ0eS5jYWxsKG8uYXR0cmlicyxnKX0sZS5nZXROYW1lPWZ1bmN0aW9uKG8pe3JldHVybiBvLm5hbWV9fSxmdW5jdGlvbihSLGUpe2UucmVtb3ZlRWxlbWVudD1mdW5jdGlvbih0KXtpZih0LnByZXYmJih0LnByZXYubmV4dD10Lm5leHQpLHQubmV4dCYmKHQubmV4dC5wcmV2PXQucHJldiksdC5wYXJlbnQpe3ZhciBpPXQucGFyZW50LmNoaWxkcmVuO2kuc3BsaWNlKGkubGFzdEluZGV4T2YodCksMSl9fSxlLnJlcGxhY2VFbGVtZW50PWZ1bmN0aW9uKHQsaSl7dmFyIG89aS5wcmV2PXQucHJldjtvJiYoby5uZXh0PWkpO3ZhciBnPWkubmV4dD10Lm5leHQ7ZyYmKGcucHJldj1pKTt2YXIgdj1pLnBhcmVudD10LnBhcmVudDtpZih2KXt2YXIgYz12LmNoaWxkcmVuO2NbYy5sYXN0SW5kZXhPZih0KV09aX19LGUuYXBwZW5kQ2hpbGQ9ZnVuY3Rpb24odCxpKXtpZihpLnBhcmVudD10LHQuY2hpbGRyZW4ucHVzaChpKSE9PTEpe3ZhciBvPXQuY2hpbGRyZW5bdC5jaGlsZHJlbi5sZW5ndGgtMl07by5uZXh0PWksaS5wcmV2PW8saS5uZXh0PW51bGx9fSxlLmFwcGVuZD1mdW5jdGlvbih0LGkpe3ZhciBvPXQucGFyZW50LGc9dC5uZXh0O2lmKGkubmV4dD1nLGkucHJldj10LHQubmV4dD1pLGkucGFyZW50PW8sZyl7aWYoZy5wcmV2PWksbyl7dmFyIHY9by5jaGlsZHJlbjt2LnNwbGljZSh2Lmxhc3RJbmRleE9mKGcpLDAsaSl9fWVsc2UgbyYmby5jaGlsZHJlbi5wdXNoKGkpfSxlLnByZXBlbmQ9ZnVuY3Rpb24odCxpKXt2YXIgbz10LnBhcmVudDtpZihvKXt2YXIgZz1vLmNoaWxkcmVuO2cuc3BsaWNlKGcubGFzdEluZGV4T2YodCksMCxpKX10LnByZXYmJih0LnByZXYubmV4dD1pKSxpLnBhcmVudD1vLGkucHJldj10LnByZXYsaS5uZXh0PXQsdC5wcmV2PWl9fSxmdW5jdGlvbihSLGUsdCl7dmFyIGk9dCgyNTYpLmlzVGFnO1IuZXhwb3J0cz17ZmlsdGVyOm8sZmluZDpnLGZpbmRPbmVDaGlsZDp2LGZpbmRPbmU6YyxleGlzdHNPbmU6ZixmaW5kQWxsOmh9O2Z1bmN0aW9uIG8oRSxsLG0scCl7cmV0dXJuIEFycmF5LmlzQXJyYXkobCl8fChsPVtsXSksKHR5cGVvZiBwIT0ibnVtYmVyInx8IWlzRmluaXRlKHApKSYmKHA9MS8wKSxnKEUsbCxtIT09ITEscCl9ZnVuY3Rpb24gZyhFLGwsbSxwKXtmb3IodmFyIEM9W10seCxkPTAseT1sLmxlbmd0aDtkPHkmJiEoRShsW2RdKSYmKEMucHVzaChsW2RdKSwtLXA8PTApfHwoeD1sW2RdLmNoaWxkcmVuLG0mJngmJngubGVuZ3RoPjAmJih4PWcoRSx4LG0scCksQz1DLmNvbmNhdCh4KSxwLT14Lmxlbmd0aCxwPD0wKSkpO2QrKyk7cmV0dXJuIEN9ZnVuY3Rpb24gdihFLGwpe2Zvcih2YXIgbT0wLHA9bC5sZW5ndGg7bTxwO20rKylpZihFKGxbbV0pKXJldHVybiBsW21dO3JldHVybiBudWxsfWZ1bmN0aW9uIGMoRSxsKXtmb3IodmFyIG09bnVsbCxwPTAsQz1sLmxlbmd0aDtwPEMmJiFtO3ArKylpZihpKGxbcF0pKUUobFtwXSk/bT1sW3BdOmxbcF0uY2hpbGRyZW4ubGVuZ3RoPjAmJihtPWMoRSxsW3BdLmNoaWxkcmVuKSk7ZWxzZSBjb250aW51ZTtyZXR1cm4gbX1mdW5jdGlvbiBmKEUsbCl7Zm9yKHZhciBtPTAscD1sLmxlbmd0aDttPHA7bSsrKWlmKGkobFttXSkmJihFKGxbbV0pfHxsW21dLmNoaWxkcmVuLmxlbmd0aD4wJiZmKEUsbFttXS5jaGlsZHJlbikpKXJldHVybiEwO3JldHVybiExfWZ1bmN0aW9uIGgoRSxsKXtmb3IodmFyIG09W10scD1sLnNsaWNlKCk7cC5sZW5ndGg7KXt2YXIgQz1wLnNoaWZ0KCk7aShDKSYmKEMuY2hpbGRyZW4mJkMuY2hpbGRyZW4ubGVuZ3RoPjAmJnAudW5zaGlmdC5hcHBseShwLEMuY2hpbGRyZW4pLEUoQykmJm0ucHVzaChDKSl9cmV0dXJuIG19fSxmdW5jdGlvbihSLGUsdCl7dmFyIGk9dCgyNTYpLG89ZS5pc1RhZz1pLmlzVGFnO2UudGVzdEVsZW1lbnQ9ZnVuY3Rpb24oZixoKXtmb3IodmFyIEUgaW4gZilpZihmLmhhc093blByb3BlcnR5KEUpKXtpZihFPT09InRhZ19uYW1lIil7aWYoIW8oaCl8fCFmLnRhZ19uYW1lKGgubmFtZSkpcmV0dXJuITF9ZWxzZSBpZihFPT09InRhZ190eXBlIil7aWYoIWYudGFnX3R5cGUoaC50eXBlKSlyZXR1cm4hMX1lbHNlIGlmKEU9PT0idGFnX2NvbnRhaW5zIil7aWYobyhoKXx8IWYudGFnX2NvbnRhaW5zKGguZGF0YSkpcmV0dXJuITF9ZWxzZSBpZighaC5hdHRyaWJzfHwhZltFXShoLmF0dHJpYnNbRV0pKXJldHVybiExfXJldHVybiEwfTt2YXIgZz17dGFnX25hbWU6ZnVuY3Rpb24oZil7cmV0dXJuIHR5cGVvZiBmPT0iZnVuY3Rpb24iP2Z1bmN0aW9uKGgpe3JldHVybiBvKGgpJiZmKGgubmFtZSl9OmY9PT0iKiI/bzpmdW5jdGlvbihoKXtyZXR1cm4gbyhoKSYmaC5uYW1lPT09Zn19LHRhZ190eXBlOmZ1bmN0aW9uKGYpe3JldHVybiB0eXBlb2YgZj09ImZ1bmN0aW9uIj9mdW5jdGlvbihoKXtyZXR1cm4gZihoLnR5cGUpfTpmdW5jdGlvbihoKXtyZXR1cm4gaC50eXBlPT09Zn19LHRhZ19jb250YWluczpmdW5jdGlvbihmKXtyZXR1cm4gdHlwZW9mIGY9PSJmdW5jdGlvbiI/ZnVuY3Rpb24oaCl7cmV0dXJuIW8oaCkmJmYoaC5kYXRhKX06ZnVuY3Rpb24oaCl7cmV0dXJuIW8oaCkmJmguZGF0YT09PWZ9fX07ZnVuY3Rpb24gdihmLGgpe3JldHVybiB0eXBlb2YgaD09ImZ1bmN0aW9uIj9mdW5jdGlvbihFKXtyZXR1cm4gRS5hdHRyaWJzJiZoKEUuYXR0cmlic1tmXSl9OmZ1bmN0aW9uKEUpe3JldHVybiBFLmF0dHJpYnMmJkUuYXR0cmlic1tmXT09PWh9fWZ1bmN0aW9uIGMoZixoKXtyZXR1cm4gZnVuY3Rpb24oRSl7cmV0dXJuIGYoRSl8fGgoRSl9fWUuZ2V0RWxlbWVudHM9ZnVuY3Rpb24oZixoLEUsbCl7dmFyIG09T2JqZWN0LmtleXMoZikubWFwKGZ1bmN0aW9uKHApe3ZhciBDPWZbcF07cmV0dXJuIHAgaW4gZz9nW3BdKEMpOnYocCxDKX0pO3JldHVybiBtLmxlbmd0aD09PTA/W106dGhpcy5maWx0ZXIobS5yZWR1Y2UoYyksaCxFLGwpfSxlLmdldEVsZW1lbnRCeUlkPWZ1bmN0aW9uKGYsaCxFKXtyZXR1cm4gQXJyYXkuaXNBcnJheShoKXx8KGg9W2hdKSx0aGlzLmZpbmRPbmUodigiaWQiLGYpLGgsRSE9PSExKX0sZS5nZXRFbGVtZW50c0J5VGFnTmFtZT1mdW5jdGlvbihmLGgsRSxsKXtyZXR1cm4gdGhpcy5maWx0ZXIoZy50YWdfbmFtZShmKSxoLEUsbCl9LGUuZ2V0RWxlbWVudHNCeVRhZ1R5cGU9ZnVuY3Rpb24oZixoLEUsbCl7cmV0dXJuIHRoaXMuZmlsdGVyKGcudGFnX3R5cGUoZiksaCxFLGwpfX0sZnVuY3Rpb24oUixlKXtlLnJlbW92ZVN1YnNldHM9ZnVuY3Rpb24obyl7Zm9yKHZhciBnPW8ubGVuZ3RoLHYsYyxmOy0tZz4tMTspe2Zvcih2PWM9b1tnXSxvW2ddPW51bGwsZj0hMDtjOyl7aWYoby5pbmRleE9mKGMpPi0xKXtmPSExLG8uc3BsaWNlKGcsMSk7YnJlYWt9Yz1jLnBhcmVudH1mJiYob1tnXT12KX1yZXR1cm4gb307dmFyIHQ9e0RJU0NPTk5FQ1RFRDoxLFBSRUNFRElORzoyLEZPTExPV0lORzo0LENPTlRBSU5TOjgsQ09OVEFJTkVEX0JZOjE2fSxpPWUuY29tcGFyZURvY3VtZW50UG9zaXRpb249ZnVuY3Rpb24obyxnKXt2YXIgdj1bXSxjPVtdLGYsaCxFLGwsbSxwO2lmKG89PT1nKXJldHVybiAwO2ZvcihmPW87Zjspdi51bnNoaWZ0KGYpLGY9Zi5wYXJlbnQ7Zm9yKGY9ZztmOyljLnVuc2hpZnQoZiksZj1mLnBhcmVudDtmb3IocD0wO3ZbcF09PT1jW3BdOylwKys7cmV0dXJuIHA9PT0wP3QuRElTQ09OTkVDVEVEOihoPXZbcC0xXSxFPWguY2hpbGRyZW4sbD12W3BdLG09Y1twXSxFLmluZGV4T2YobCk+RS5pbmRleE9mKG0pP2g9PT1nP3QuRk9MTE9XSU5HfHQuQ09OVEFJTkVEX0JZOnQuRk9MTE9XSU5HOmg9PT1vP3QuUFJFQ0VESU5HfHQuQ09OVEFJTlM6dC5QUkVDRURJTkcpfTtlLnVuaXF1ZVNvcnQ9ZnVuY3Rpb24obyl7dmFyIGc9by5sZW5ndGgsdixjO2ZvcihvPW8uc2xpY2UoKTstLWc+LTE7KXY9b1tnXSxjPW8uaW5kZXhPZih2KSxjPi0xJiZjPGcmJm8uc3BsaWNlKGcsMSk7cmV0dXJuIG8uc29ydChmdW5jdGlvbihmLGgpe3ZhciBFPWkoZixoKTtyZXR1cm4gRSZ0LlBSRUNFRElORz8tMTpFJnQuRk9MTE9XSU5HPzE6MH0pLG99fSxmdW5jdGlvbihSLGUpe1IuZXhwb3J0cz17dHJ1ZUZ1bmM6ZnVuY3Rpb24oKXtyZXR1cm4hMH0sZmFsc2VGdW5jOmZ1bmN0aW9uKCl7cmV0dXJuITF9fX0sZnVuY3Rpb24oUixlLHQpe1IuZXhwb3J0cz1tO3ZhciBpPXQoMjc1KS5wYXJzZSxvPXQoMjczKSxnPXQoMjc4KSx2PXQoMjc5KSxjPXQoMjgwKSxmPXQoMjgyKSxoPW8udHJ1ZUZ1bmMsRT1vLmZhbHNlRnVuYyxsPWYuZmlsdGVycztmdW5jdGlvbiBtKFAsRCxMKXt2YXIgUz1DKFAsRCxMKTtyZXR1cm4gcChTLEQpfWZ1bmN0aW9uIHAoUCxEKXt2YXIgTD1ELmFkYXB0ZXI7cmV0dXJuIGZ1bmN0aW9uKFQpe3JldHVybiBMLmlzVGFnKFQpJiZQKFQpfX1mdW5jdGlvbiBDKFAsRCxMKXt2YXIgUz1pKFAsRCk7cmV0dXJuIGEoUyxELEwpfWZ1bmN0aW9uIHgoUCl7cmV0dXJuIFAudHlwZT09PSJwc2V1ZG8iJiYoUC5uYW1lPT09InNjb3BlInx8QXJyYXkuaXNBcnJheShQLmRhdGEpJiZQLmRhdGEuc29tZShmdW5jdGlvbihEKXtyZXR1cm4gRC5zb21lKHgpfSkpfXZhciBkPXt0eXBlOiJkZXNjZW5kYW50In0seT17dHlwZToiX2ZsZXhpYmxlRGVzY2VuZGFudCJ9LHI9e3R5cGU6InBzZXVkbyIsbmFtZToic2NvcGUifSxzPXt9O2Z1bmN0aW9uIG4oUCxELEwpe3ZhciBTPUQuYWRhcHRlcixUPSEhTCYmISFMLmxlbmd0aCYmTC5ldmVyeShmdW5jdGlvbihqKXtyZXR1cm4gaj09PXN8fCEhUy5nZXRQYXJlbnQoail9KTtQLmZvckVhY2goZnVuY3Rpb24oail7aWYoIShqLmxlbmd0aD4wJiZPKGpbMF0pJiZqWzBdLnR5cGUhPT0iZGVzY2VuZGFudCIpKWlmKFQmJiEoQXJyYXkuaXNBcnJheShqKT9qLnNvbWUoeCk6eChqKSkpai51bnNoaWZ0KGQpO2Vsc2UgcmV0dXJuO2oudW5zaGlmdChyKX0pfWZ1bmN0aW9uIGEoUCxELEwpe1A9UC5maWx0ZXIoZnVuY3Rpb24oJCl7cmV0dXJuICQubGVuZ3RoPjB9KSxQLmZvckVhY2goZyk7dmFyIFM9QXJyYXkuaXNBcnJheShMKTtMPUQmJkQuY29udGV4dHx8TCxMJiYhUyYmKEw9W0xdKSxuKFAsRCxMKTt2YXIgVD0hMSxqPVAubWFwKGZ1bmN0aW9uKCQpe2lmKCRbMF0mJiRbMV0mJiRbMF0ubmFtZT09PSJzY29wZSIpe3ZhciB3PSRbMV0udHlwZTtTJiZ3PT09ImRlc2NlbmRhbnQiPyRbMV09eToodz09PSJhZGphY2VudCJ8fHc9PT0ic2libGluZyIpJiYoVD0hMCl9cmV0dXJuIEEoJCxELEwpfSkucmVkdWNlKGIsRSk7cmV0dXJuIGouc2hvdWxkVGVzdE5leHRTaWJsaW5ncz1ULGp9ZnVuY3Rpb24gTyhQKXtyZXR1cm4gdltQLnR5cGVdPDB9ZnVuY3Rpb24gQShQLEQsTCl7cmV0dXJuIFAucmVkdWNlKGZ1bmN0aW9uKFMsVCl7aWYoUz09PUUpcmV0dXJuIFM7aWYoIShULnR5cGUgaW4gYykpdGhyb3cgbmV3IEVycm9yKCJSdWxlIHR5cGUgIitULnR5cGUrIiBpcyBub3Qgc3VwcG9ydGVkIGJ5IGNzcy1zZWxlY3QiKTtyZXR1cm4gY1tULnR5cGVdKFMsVCxELEwpfSxEJiZELnJvb3RGdW5jfHxoKX1mdW5jdGlvbiBiKFAsRCl7cmV0dXJuIEQ9PT1FfHxQPT09aD9QOlA9PT1FfHxEPT09aD9EOmZ1bmN0aW9uKFMpe3JldHVybiBQKFMpfHxEKFMpfX1mdW5jdGlvbiBJKFApe3JldHVybiBQLnNvbWUoTyl9bC5ub3Q9ZnVuY3Rpb24oUCxELEwsUyl7dmFyIFQ9e3htbE1vZGU6ISEoTCYmTC54bWxNb2RlKSxzdHJpY3Q6ISEoTCYmTC5zdHJpY3QpLGFkYXB0ZXI6TC5hZGFwdGVyfTtpZihULnN0cmljdCYmKEQubGVuZ3RoPjF8fEQuc29tZShJKSkpdGhyb3cgbmV3IEVycm9yKCJjb21wbGV4IHNlbGVjdG9ycyBpbiA6bm90IGFyZW4ndCBhbGxvd2VkIGluIHN0cmljdCBtb2RlIik7dmFyIGo9YShELFQsUyk7cmV0dXJuIGo9PT1FP1A6aj09PWg/RTpmdW5jdGlvbih3KXtyZXR1cm4haih3KSYmUCh3KX19LGwuaGFzPWZ1bmN0aW9uKFAsRCxMKXt2YXIgUz1MLmFkYXB0ZXIsVD17eG1sTW9kZTohIShMJiZMLnhtbE1vZGUpLHN0cmljdDohIShMJiZMLnN0cmljdCksYWRhcHRlcjpTfSxqPUQuc29tZShJKT9bc106bnVsbCwkPWEoRCxULGopO3JldHVybiAkPT09RT9FOiQ9PT1oP2Z1bmN0aW9uKEope3JldHVybiBTLmdldENoaWxkcmVuKEopLnNvbWUoUy5pc1RhZykmJlAoSil9OigkPXAoJCxMKSxqP2Z1bmN0aW9uKEope3JldHVybiBQKEopJiYoalswXT1KLFMuZXhpc3RzT25lKCQsUy5nZXRDaGlsZHJlbihKKSkpfTpmdW5jdGlvbihKKXtyZXR1cm4gUChKKSYmUy5leGlzdHNPbmUoJCxTLmdldENoaWxkcmVuKEopKX0pfSxsLm1hdGNoZXM9ZnVuY3Rpb24oUCxELEwsUyl7dmFyIFQ9e3htbE1vZGU6ISEoTCYmTC54bWxNb2RlKSxzdHJpY3Q6ISEoTCYmTC5zdHJpY3QpLHJvb3RGdW5jOlAsYWRhcHRlcjpMLmFkYXB0ZXJ9O3JldHVybiBhKEQsVCxTKX0sbS5jb21waWxlVG9rZW49YSxtLmNvbXBpbGVVbnNhZmU9QyxtLlBzZXVkb3M9Zn0sZnVuY3Rpb24oUixlLHQpe3ZhciBpPXRoaXMmJnRoaXMuX19jcmVhdGVCaW5kaW5nfHwoT2JqZWN0LmNyZWF0ZT9mdW5jdGlvbihjLGYsaCxFKXtFPT09dm9pZCAwJiYoRT1oKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoYyxFLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBmW2hdfX0pfTpmdW5jdGlvbihjLGYsaCxFKXtFPT09dm9pZCAwJiYoRT1oKSxjW0VdPWZbaF19KSxvPXRoaXMmJnRoaXMuX19leHBvcnRTdGFyfHxmdW5jdGlvbihjLGYpe2Zvcih2YXIgaCBpbiBjKWghPT0iZGVmYXVsdCImJiFmLmhhc093blByb3BlcnR5KGgpJiZpKGYsYyxoKX07T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLG8odCgyNzYpLGUpO3ZhciBnPXQoMjc2KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwicGFyc2UiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBnLmRlZmF1bHR9fSk7dmFyIHY9dCgyNzcpO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJzdHJpbmdpZnkiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiB2LmRlZmF1bHR9fSl9LGZ1bmN0aW9uKFIsZSx0KXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksZS5kZWZhdWx0PXg7dmFyIGk9L15bXlxcXT8oPzpcXCg/OltcZGEtZl17MSw2fVxzP3wuKXxbXHdcLVx1MDBiMC1cdUZGRkZdKSsvLG89L1xcKFtcZGEtZl17MSw2fVxzP3woXHMpfC4pL2dpLGc9L15ccyooKD86XFwufFtcd1x1MDBiMC1cdUZGRkYtXSkrKVxzKig/OihcUz8pPVxzKig/OihbJyJdKShbXl0qPylcM3woIz8oPzpcXC58W1x3XHUwMGIwLVx1RkZGRi1dKSopfCl8KVxzKihpKT9cXS8sdj17dW5kZWZpbmVkOiJleGlzdHMiLCIiOiJlcXVhbHMiLCJ+IjoiZWxlbWVudCIsIl4iOiJzdGFydCIsJDoiZW5kIiwiKiI6ImFueSIsIiEiOiJub3QiLCJ8IjoiaHlwaGVuIn0sYz17Ij4iOiJjaGlsZCIsIjwiOiJwYXJlbnQiLCJ+Ijoic2libGluZyIsIisiOiJhZGphY2VudCJ9LGY9eyIjIjpbImlkIiwiZXF1YWxzIl0sIi4iOlsiY2xhc3MiLCJlbGVtZW50Il19LGg9bmV3IFNldChbImhhcyIsIm5vdCIsIm1hdGNoZXMiXSksRT1uZXcgU2V0KFsiY29udGFpbnMiLCJpY29udGFpbnMiXSksbD1uZXcgU2V0KFsnIicsIiciXSk7ZnVuY3Rpb24gbShyLHMsbil7dmFyIGE9cGFyc2VJbnQocywxNiktNjU1MzY7cmV0dXJuIGEhPT1hfHxuP3M6YTwwP1N0cmluZy5mcm9tQ2hhckNvZGUoYSs2NTUzNik6U3RyaW5nLmZyb21DaGFyQ29kZShhPj4xMHw1NTI5NixhJjEwMjN8NTYzMjApfWZ1bmN0aW9uIHAocil7cmV0dXJuIHIucmVwbGFjZShvLG0pfWZ1bmN0aW9uIEMocil7cmV0dXJuIHI9PT0iICJ8fHI9PT1gCmB8fHI9PT0iCSJ8fHI9PT0iXGYifHxyPT09IlxyIn1mdW5jdGlvbiB4KHIscyl7dmFyIG49W107aWYocj1kKG4sIiIrcixzKSxyIT09IiIpdGhyb3cgbmV3IEVycm9yKCJVbm1hdGNoZWQgc2VsZWN0b3I6ICIrcik7cmV0dXJuIG59ZnVuY3Rpb24gZChyLHMsbil7dmFyIGE9W10sTz0hMTtmdW5jdGlvbiBBKCl7dmFyIFE9cy5tYXRjaChpKTtpZighUSl0aHJvdyBuZXcgRXJyb3IoIkV4cGVjdGVkIG5hbWUsIGZvdW5kICIrcyk7dmFyIHR0PVFbMF07cmV0dXJuIHM9cy5zdWJzdHIodHQubGVuZ3RoKSxwKHR0KX1mdW5jdGlvbiBiKFEpe2Zvcig7QyhzLmNoYXJBdChRKSk7KVErKztzPXMuc3Vic3RyKFEpfWZ1bmN0aW9uIEkoUSl7Zm9yKHZhciB0dD0wO3MuY2hhckF0KC0tUSk9PT0iXFwiOyl0dCsrO3JldHVybih0dCYxKT09PTF9Zm9yKGIoMCk7cyE9PSIiOyl7dmFyIFA9cy5jaGFyQXQoMCk7aWYoQyhQKSlPPSEwLGIoMSk7ZWxzZSBpZihQIGluIGMpYS5wdXNoKHt0eXBlOmNbUF19KSxPPSExLGIoMSk7ZWxzZSBpZihQPT09IiwiKXtpZihhLmxlbmd0aD09PTApdGhyb3cgbmV3IEVycm9yKCJFbXB0eSBzdWItc2VsZWN0b3IiKTtyLnB1c2goYSksYT1bXSxPPSExLGIoMSl9ZWxzZSBpZihPJiYoYS5sZW5ndGg+MCYmYS5wdXNoKHt0eXBlOiJkZXNjZW5kYW50In0pLE89ITEpLFA9PT0iKiIpcz1zLnN1YnN0cigxKSxhLnB1c2goe3R5cGU6InVuaXZlcnNhbCJ9KTtlbHNlIGlmKFAgaW4gZil7dmFyIEQ9ZltQXSxMPURbMF0sUz1EWzFdO3M9cy5zdWJzdHIoMSksYS5wdXNoKHt0eXBlOiJhdHRyaWJ1dGUiLG5hbWU6TCxhY3Rpb246Uyx2YWx1ZTpBKCksaWdub3JlQ2FzZTohMX0pfWVsc2UgaWYoUD09PSJbIil7cz1zLnN1YnN0cigxKTt2YXIgVD1zLm1hdGNoKGcpO2lmKCFUKXRocm93IG5ldyBFcnJvcigiTWFsZm9ybWVkIGF0dHJpYnV0ZSBzZWxlY3RvcjogIitzKTtzPXMuc3Vic3RyKFRbMF0ubGVuZ3RoKTt2YXIgaj1wKFRbMV0pOyghbnx8KCJsb3dlckNhc2VBdHRyaWJ1dGVOYW1lcyJpbiBuP24ubG93ZXJDYXNlQXR0cmlidXRlTmFtZXM6IW4ueG1sTW9kZSkpJiYoaj1qLnRvTG93ZXJDYXNlKCkpLGEucHVzaCh7dHlwZToiYXR0cmlidXRlIixuYW1lOmosYWN0aW9uOnZbVFsyXV0sdmFsdWU6cChUWzRdfHxUWzVdfHwiIiksaWdub3JlQ2FzZTohIVRbNl19KX1lbHNlIGlmKFA9PT0iOiIpe2lmKHMuY2hhckF0KDEpPT09IjoiKXtzPXMuc3Vic3RyKDIpLGEucHVzaCh7dHlwZToicHNldWRvLWVsZW1lbnQiLG5hbWU6QSgpLnRvTG93ZXJDYXNlKCl9KTtjb250aW51ZX1zPXMuc3Vic3RyKDEpO3ZhciAkPUEoKS50b0xvd2VyQ2FzZSgpLFQ9bnVsbDtpZihzLmNoYXJBdCgwKT09PSIoIilpZihoLmhhcygkKSl7dmFyIHc9cy5jaGFyQXQoMSksSj1sLmhhcyh3KTtpZihzPXMuc3Vic3RyKEo/MjoxKSxUPVtdLHM9ZChULHMsbiksSil7aWYocy5jaGFyQXQoMCkhPT13KXRocm93IG5ldyBFcnJvcigiVW5tYXRjaGVkIHF1b3RlcyBpbiA6IiskKTtzPXMuc3Vic3RyKDEpfWlmKHMuY2hhckF0KDApIT09IikiKXRocm93IG5ldyBFcnJvcigiTWlzc2luZyBjbG9zaW5nIHBhcmVudGhlc2lzIGluIDoiKyQrIiAoIitzKyIpIik7cz1zLnN1YnN0cigxKX1lbHNle2Zvcih2YXIgcT0xLFc9MTtXPjAmJnE8cy5sZW5ndGg7cSsrKXMuY2hhckF0KHEpPT09IigiJiYhSShxKT9XKys6cy5jaGFyQXQocSk9PT0iKSImJiFJKHEpJiZXLS07aWYoVyl0aHJvdyBuZXcgRXJyb3IoIlBhcmVudGhlc2lzIG5vdCBtYXRjaGVkIik7aWYoVD1zLnN1YnN0cigxLHEtMikscz1zLnN1YnN0cihxKSxFLmhhcygkKSl7dmFyIHc9VC5jaGFyQXQoMCk7dz09PVQuc2xpY2UoLTEpJiZsLmhhcyh3KSYmKFQ9VC5zbGljZSgxLC0xKSksVD1wKFQpfX1hLnB1c2goe3R5cGU6InBzZXVkbyIsbmFtZTokLGRhdGE6VH0pfWVsc2UgaWYoaS50ZXN0KHMpKXt2YXIgSz1BKCk7KCFufHwoImxvd2VyQ2FzZVRhZ3MiaW4gbj9uLmxvd2VyQ2FzZVRhZ3M6IW4ueG1sTW9kZSkpJiYoSz1LLnRvTG93ZXJDYXNlKCkpLGEucHVzaCh7dHlwZToidGFnIixuYW1lOkt9KX1lbHNlIHJldHVybiBhLmxlbmd0aCYmYVthLmxlbmd0aC0xXS50eXBlPT09ImRlc2NlbmRhbnQiJiZhLnBvcCgpLHkocixhKSxzfXJldHVybiB5KHIsYSksc31mdW5jdGlvbiB5KHIscyl7aWYoci5sZW5ndGg+MCYmcy5sZW5ndGg9PT0wKXRocm93IG5ldyBFcnJvcigiRW1wdHkgc3ViLXNlbGVjdG9yIik7ci5wdXNoKHMpfX0sZnVuY3Rpb24oUixlLHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KTt2YXIgaT17ZXF1YWxzOiIiLGVsZW1lbnQ6In4iLHN0YXJ0OiJeIixlbmQ6IiQiLGFueToiKiIsbm90OiIhIixoeXBoZW46InwifTtmdW5jdGlvbiBvKGYpe3JldHVybiBmLm1hcChnKS5qb2luKCIsICIpfWUuZGVmYXVsdD1vO2Z1bmN0aW9uIGcoZil7cmV0dXJuIGYubWFwKHYpLmpvaW4oIiIpfWZ1bmN0aW9uIHYoZil7c3dpdGNoKGYudHlwZSl7Y2FzZSJjaGlsZCI6cmV0dXJuIiA+ICI7Y2FzZSJwYXJlbnQiOnJldHVybiIgPCAiO2Nhc2Uic2libGluZyI6cmV0dXJuIiB+ICI7Y2FzZSJhZGphY2VudCI6cmV0dXJuIiArICI7Y2FzZSJkZXNjZW5kYW50IjpyZXR1cm4iICI7Y2FzZSJ1bml2ZXJzYWwiOnJldHVybiIqIjtjYXNlInRhZyI6cmV0dXJuIGYubmFtZTtjYXNlInBzZXVkby1lbGVtZW50IjpyZXR1cm4iOjoiK2YubmFtZTtjYXNlInBzZXVkbyI6cmV0dXJuIGYuZGF0YT09PW51bGw/IjoiK2YubmFtZTp0eXBlb2YgZi5kYXRhPT0ic3RyaW5nIj8iOiIrZi5uYW1lKyIoIitmLmRhdGErIikiOiI6IitmLm5hbWUrIigiK28oZi5kYXRhKSsiKSI7Y2FzZSJhdHRyaWJ1dGUiOnJldHVybiBmLmFjdGlvbj09PSJleGlzdHMiPyJbIitmLm5hbWUrIl0iOmYubmFtZT09PSJpZCImJmYuYWN0aW9uPT09ImVxdWFscyImJiFmLmlnbm9yZUNhc2U/IiMiK2YudmFsdWU6Zi5uYW1lPT09ImNsYXNzIiYmZi5hY3Rpb249PT0iZWxlbWVudCImJiFmLmlnbm9yZUNhc2U/Ii4iK2YudmFsdWU6IlsiK2YubmFtZStpW2YuYWN0aW9uXSsiPSciK2YudmFsdWUrIiciKyhmLmlnbm9yZUNhc2U/ImkiOiIiKSsiXSI7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoIlVua25vd24gdHlwZSIpfX1mdW5jdGlvbiBjKGYpe3JldHVybiBmfX0sZnVuY3Rpb24oUixlLHQpe1IuZXhwb3J0cz1nO3ZhciBpPXQoMjc5KSxvPXtfX3Byb3RvX186bnVsbCxleGlzdHM6MTAsZXF1YWxzOjgsbm90Ojcsc3RhcnQ6NixlbmQ6Nixhbnk6NSxoeXBoZW46NCxlbGVtZW50OjR9O2Z1bmN0aW9uIGcoYyl7Zm9yKHZhciBmPWMubWFwKHYpLGg9MTtoPGMubGVuZ3RoO2grKyl7dmFyIEU9ZltoXTtpZighKEU8MCkpZm9yKHZhciBsPWgtMTtsPj0wJiZFPGZbbF07bC0tKXt2YXIgbT1jW2wrMV07Y1tsKzFdPWNbbF0sY1tsXT1tLGZbbCsxXT1mW2xdLGZbbF09RX19fWZ1bmN0aW9uIHYoYyl7dmFyIGY9aVtjLnR5cGVdO2lmKGY9PT1pLmF0dHJpYnV0ZSlmPW9bYy5hY3Rpb25dLGY9PT1vLmVxdWFscyYmYy5uYW1lPT09ImlkIiYmKGY9OSksYy5pZ25vcmVDYXNlJiYoZj4+PTEpO2Vsc2UgaWYoZj09PWkucHNldWRvKWlmKCFjLmRhdGEpZj0zO2Vsc2UgaWYoYy5uYW1lPT09ImhhcyJ8fGMubmFtZT09PSJjb250YWlucyIpZj0wO2Vsc2UgaWYoYy5uYW1lPT09Im1hdGNoZXMifHxjLm5hbWU9PT0ibm90Iil7Zj0wO2Zvcih2YXIgaD0wO2g8Yy5kYXRhLmxlbmd0aDtoKyspaWYoYy5kYXRhW2hdLmxlbmd0aD09PTEpe3ZhciBFPXYoYy5kYXRhW2hdWzBdKTtpZihFPT09MCl7Zj0wO2JyZWFrfUU+ZiYmKGY9RSl9Yy5kYXRhLmxlbmd0aD4xJiZmPjAmJihmLT0xKX1lbHNlIGY9MTtyZXR1cm4gZn19LGZ1bmN0aW9uKFIpe1IuZXhwb3J0cz1KU09OLnBhcnNlKCd7InVuaXZlcnNhbCI6NTAsInRhZyI6MzAsImF0dHJpYnV0ZSI6MSwicHNldWRvIjowLCJkZXNjZW5kYW50IjotMSwiY2hpbGQiOi0xLCJwYXJlbnQiOi0xLCJzaWJsaW5nIjotMSwiYWRqYWNlbnQiOi0xfScpfSxmdW5jdGlvbihSLGUsdCl7dmFyIGk9dCgyODEpLG89dCgyODIpO1IuZXhwb3J0cz17X19wcm90b19fOm51bGwsYXR0cmlidXRlOmkuY29tcGlsZSxwc2V1ZG86by5jb21waWxlLHRhZzpmdW5jdGlvbihnLHYsYyl7dmFyIGY9di5uYW1lLGg9Yy5hZGFwdGVyO3JldHVybiBmdW5jdGlvbihsKXtyZXR1cm4gaC5nZXROYW1lKGwpPT09ZiYmZyhsKX19LGRlc2NlbmRhbnQ6ZnVuY3Rpb24oZyx2LGMpe3ZhciBmPXR5cGVvZiBXZWFrU2V0PCJ1Ij9uZXcgV2Vha1NldDpudWxsLGg9Yy5hZGFwdGVyO3JldHVybiBmdW5jdGlvbihsKXtmb3IodmFyIG09ITE7IW0mJihsPWguZ2V0UGFyZW50KGwpKTspKCFmfHwhZi5oYXMobCkpJiYobT1nKGwpLCFtJiZmJiZmLmFkZChsKSk7cmV0dXJuIG19fSxfZmxleGlibGVEZXNjZW5kYW50OmZ1bmN0aW9uKGcsdixjKXt2YXIgZj1jLmFkYXB0ZXI7cmV0dXJuIGZ1bmN0aW9uKEUpe2Zvcih2YXIgbD1nKEUpOyFsJiYoRT1mLmdldFBhcmVudChFKSk7KWw9ZyhFKTtyZXR1cm4gbH19LHBhcmVudDpmdW5jdGlvbihnLHYsYyl7aWYoYyYmYy5zdHJpY3QpdGhyb3cgbmV3IEVycm9yKCJQYXJlbnQgc2VsZWN0b3IgaXNuJ3QgcGFydCBvZiBDU1MzIik7dmFyIGY9Yy5hZGFwdGVyO3JldHVybiBmdW5jdGlvbihsKXtyZXR1cm4gZi5nZXRDaGlsZHJlbihsKS5zb21lKGgpfTtmdW5jdGlvbiBoKEUpe3JldHVybiBmLmlzVGFnKEUpJiZnKEUpfX0sY2hpbGQ6ZnVuY3Rpb24oZyx2LGMpe3ZhciBmPWMuYWRhcHRlcjtyZXR1cm4gZnVuY3Rpb24oRSl7dmFyIGw9Zi5nZXRQYXJlbnQoRSk7cmV0dXJuISFsJiZnKGwpfX0sc2libGluZzpmdW5jdGlvbihnLHYsYyl7dmFyIGY9Yy5hZGFwdGVyO3JldHVybiBmdW5jdGlvbihFKXtmb3IodmFyIGw9Zi5nZXRTaWJsaW5ncyhFKSxtPTA7bTxsLmxlbmd0aDttKyspaWYoZi5pc1RhZyhsW21dKSl7aWYobFttXT09PUUpYnJlYWs7aWYoZyhsW21dKSlyZXR1cm4hMH1yZXR1cm4hMX19LGFkamFjZW50OmZ1bmN0aW9uKGcsdixjKXt2YXIgZj1jLmFkYXB0ZXI7cmV0dXJuIGZ1bmN0aW9uKEUpe2Zvcih2YXIgbD1mLmdldFNpYmxpbmdzKEUpLG0scD0wO3A8bC5sZW5ndGg7cCsrKWlmKGYuaXNUYWcobFtwXSkpe2lmKGxbcF09PT1FKWJyZWFrO209bFtwXX1yZXR1cm4hIW0mJmcobSl9fSx1bml2ZXJzYWw6ZnVuY3Rpb24oZyl7cmV0dXJuIGd9fX0sZnVuY3Rpb24oUixlLHQpe3ZhciBpPXQoMjczKS5mYWxzZUZ1bmMsbz0vWy1bXF17fSgpKis/LixcXF4kfCNcc10vZyxnPXtfX3Byb3RvX186bnVsbCxlcXVhbHM6ZnVuY3Rpb24odixjLGYpe3ZhciBoPWMubmFtZSxFPWMudmFsdWUsbD1mLmFkYXB0ZXI7cmV0dXJuIGMuaWdub3JlQ2FzZT8oRT1FLnRvTG93ZXJDYXNlKCksZnVuY3Rpb24ocCl7dmFyIEM9bC5nZXRBdHRyaWJ1dGVWYWx1ZShwLGgpO3JldHVybiBDIT1udWxsJiZDLnRvTG93ZXJDYXNlKCk9PT1FJiZ2KHApfSk6ZnVuY3Rpb24ocCl7cmV0dXJuIGwuZ2V0QXR0cmlidXRlVmFsdWUocCxoKT09PUUmJnYocCl9fSxoeXBoZW46ZnVuY3Rpb24odixjLGYpe3ZhciBoPWMubmFtZSxFPWMudmFsdWUsbD1FLmxlbmd0aCxtPWYuYWRhcHRlcjtyZXR1cm4gYy5pZ25vcmVDYXNlPyhFPUUudG9Mb3dlckNhc2UoKSxmdW5jdGlvbihDKXt2YXIgeD1tLmdldEF0dHJpYnV0ZVZhbHVlKEMsaCk7cmV0dXJuIHghPW51bGwmJih4Lmxlbmd0aD09PWx8fHguY2hhckF0KGwpPT09Ii0iKSYmeC5zdWJzdHIoMCxsKS50b0xvd2VyQ2FzZSgpPT09RSYmdihDKX0pOmZ1bmN0aW9uKEMpe3ZhciB4PW0uZ2V0QXR0cmlidXRlVmFsdWUoQyxoKTtyZXR1cm4geCE9bnVsbCYmeC5zdWJzdHIoMCxsKT09PUUmJih4Lmxlbmd0aD09PWx8fHguY2hhckF0KGwpPT09Ii0iKSYmdihDKX19LGVsZW1lbnQ6ZnVuY3Rpb24odixjLGYpe3ZhciBoPWMubmFtZSxFPWMudmFsdWUsbD1mLmFkYXB0ZXI7aWYoL1xzLy50ZXN0KEUpKXJldHVybiBpO0U9RS5yZXBsYWNlKG8sIlxcJCYiKTt2YXIgbT0iKD86XnxcXHMpIitFKyIoPzokfFxccykiLHA9Yy5pZ25vcmVDYXNlPyJpIjoiIixDPW5ldyBSZWdFeHAobSxwKTtyZXR1cm4gZnVuY3Rpb24oZCl7dmFyIHk9bC5nZXRBdHRyaWJ1dGVWYWx1ZShkLGgpO3JldHVybiB5IT1udWxsJiZDLnRlc3QoeSkmJnYoZCl9fSxleGlzdHM6ZnVuY3Rpb24odixjLGYpe3ZhciBoPWMubmFtZSxFPWYuYWRhcHRlcjtyZXR1cm4gZnVuY3Rpb24obSl7cmV0dXJuIEUuaGFzQXR0cmliKG0saCkmJnYobSl9fSxzdGFydDpmdW5jdGlvbih2LGMsZil7dmFyIGg9Yy5uYW1lLEU9Yy52YWx1ZSxsPUUubGVuZ3RoLG09Zi5hZGFwdGVyO3JldHVybiBsPT09MD9pOmMuaWdub3JlQ2FzZT8oRT1FLnRvTG93ZXJDYXNlKCksZnVuY3Rpb24oQyl7dmFyIHg9bS5nZXRBdHRyaWJ1dGVWYWx1ZShDLGgpO3JldHVybiB4IT1udWxsJiZ4LnN1YnN0cigwLGwpLnRvTG93ZXJDYXNlKCk9PT1FJiZ2KEMpfSk6ZnVuY3Rpb24oQyl7dmFyIHg9bS5nZXRBdHRyaWJ1dGVWYWx1ZShDLGgpO3JldHVybiB4IT1udWxsJiZ4LnN1YnN0cigwLGwpPT09RSYmdihDKX19LGVuZDpmdW5jdGlvbih2LGMsZil7dmFyIGg9Yy5uYW1lLEU9Yy52YWx1ZSxsPS1FLmxlbmd0aCxtPWYuYWRhcHRlcjtyZXR1cm4gbD09PTA/aTpjLmlnbm9yZUNhc2U/KEU9RS50b0xvd2VyQ2FzZSgpLGZ1bmN0aW9uKEMpe3ZhciB4PW0uZ2V0QXR0cmlidXRlVmFsdWUoQyxoKTtyZXR1cm4geCE9bnVsbCYmeC5zdWJzdHIobCkudG9Mb3dlckNhc2UoKT09PUUmJnYoQyl9KTpmdW5jdGlvbihDKXt2YXIgeD1tLmdldEF0dHJpYnV0ZVZhbHVlKEMsaCk7cmV0dXJuIHghPW51bGwmJnguc3Vic3RyKGwpPT09RSYmdihDKX19LGFueTpmdW5jdGlvbih2LGMsZil7dmFyIGg9Yy5uYW1lLEU9Yy52YWx1ZSxsPWYuYWRhcHRlcjtpZihFPT09IiIpcmV0dXJuIGk7aWYoYy5pZ25vcmVDYXNlKXt2YXIgbT1uZXcgUmVnRXhwKEUucmVwbGFjZShvLCJcXCQmIiksImkiKTtyZXR1cm4gZnVuY3Rpb24oQyl7dmFyIHg9bC5nZXRBdHRyaWJ1dGVWYWx1ZShDLGgpO3JldHVybiB4IT1udWxsJiZtLnRlc3QoeCkmJnYoQyl9fXJldHVybiBmdW5jdGlvbihDKXt2YXIgeD1sLmdldEF0dHJpYnV0ZVZhbHVlKEMsaCk7cmV0dXJuIHghPW51bGwmJnguaW5kZXhPZihFKT49MCYmdihDKX19LG5vdDpmdW5jdGlvbih2LGMsZil7dmFyIGg9Yy5uYW1lLEU9Yy52YWx1ZSxsPWYuYWRhcHRlcjtyZXR1cm4gRT09PSIiP2Z1bmN0aW9uKHApe3JldHVybiEhbC5nZXRBdHRyaWJ1dGVWYWx1ZShwLGgpJiZ2KHApfTpjLmlnbm9yZUNhc2U/KEU9RS50b0xvd2VyQ2FzZSgpLGZ1bmN0aW9uKHApe3ZhciBDPWwuZ2V0QXR0cmlidXRlVmFsdWUocCxoKTtyZXR1cm4gQyE9bnVsbCYmQy50b0xvd2VyQ2FzZSgpIT09RSYmdihwKX0pOmZ1bmN0aW9uKHApe3JldHVybiBsLmdldEF0dHJpYnV0ZVZhbHVlKHAsaCkhPT1FJiZ2KHApfX19O1IuZXhwb3J0cz17Y29tcGlsZTpmdW5jdGlvbih2LGMsZil7aWYoZiYmZi5zdHJpY3QmJihjLmlnbm9yZUNhc2V8fGMuYWN0aW9uPT09Im5vdCIpKXRocm93IG5ldyBFcnJvcigiVW5zdXBwb3J0ZWQgYXR0cmlidXRlIHNlbGVjdG9yIik7cmV0dXJuIGdbYy5hY3Rpb25dKHYsYyxmKX0scnVsZXM6Z319LGZ1bmN0aW9uKFIsZSx0KXt2YXIgaT10KDI4Myksbz10KDI3MyksZz10KDI4MSksdj1vLnRydWVGdW5jLGM9by5mYWxzZUZ1bmMsZj1nLnJ1bGVzLmVxdWFscztmdW5jdGlvbiBoKHkscil7dmFyIHM9e25hbWU6eSx2YWx1ZTpyfTtyZXR1cm4gZnVuY3Rpb24oYSxPLEEpe3JldHVybiBmKGEscyxBKX19ZnVuY3Rpb24gRSh5LHIpe3JldHVybiBmdW5jdGlvbihzKXtyZXR1cm4hIXIuZ2V0UGFyZW50KHMpJiZ5KHMpfX12YXIgbD17Y29udGFpbnM6ZnVuY3Rpb24oeSxyLHMpe3ZhciBuPXMuYWRhcHRlcjtyZXR1cm4gZnVuY3Rpb24oTyl7cmV0dXJuIHkoTykmJm4uZ2V0VGV4dChPKS5pbmRleE9mKHIpPj0wfX0saWNvbnRhaW5zOmZ1bmN0aW9uKHkscixzKXt2YXIgbj1yLnRvTG93ZXJDYXNlKCksYT1zLmFkYXB0ZXI7cmV0dXJuIGZ1bmN0aW9uKEEpe3JldHVybiB5KEEpJiZhLmdldFRleHQoQSkudG9Mb3dlckNhc2UoKS5pbmRleE9mKG4pPj0wfX0sIm50aC1jaGlsZCI6ZnVuY3Rpb24oeSxyLHMpe3ZhciBuPWkociksYT1zLmFkYXB0ZXI7cmV0dXJuIG49PT1jP246bj09PXY/RSh5LGEpOmZ1bmN0aW9uKEEpe2Zvcih2YXIgYj1hLmdldFNpYmxpbmdzKEEpLEk9MCxQPTA7STxiLmxlbmd0aDtJKyspaWYoYS5pc1RhZyhiW0ldKSl7aWYoYltJXT09PUEpYnJlYWs7UCsrfXJldHVybiBuKFApJiZ5KEEpfX0sIm50aC1sYXN0LWNoaWxkIjpmdW5jdGlvbih5LHIscyl7dmFyIG49aShyKSxhPXMuYWRhcHRlcjtyZXR1cm4gbj09PWM/bjpuPT09dj9FKHksYSk6ZnVuY3Rpb24oQSl7Zm9yKHZhciBiPWEuZ2V0U2libGluZ3MoQSksST0wLFA9Yi5sZW5ndGgtMTtQPj0wO1AtLSlpZihhLmlzVGFnKGJbUF0pKXtpZihiW1BdPT09QSlicmVhaztJKyt9cmV0dXJuIG4oSSkmJnkoQSl9fSwibnRoLW9mLXR5cGUiOmZ1bmN0aW9uKHkscixzKXt2YXIgbj1pKHIpLGE9cy5hZGFwdGVyO3JldHVybiBuPT09Yz9uOm49PT12P0UoeSxhKTpmdW5jdGlvbihBKXtmb3IodmFyIGI9YS5nZXRTaWJsaW5ncyhBKSxJPTAsUD0wO1A8Yi5sZW5ndGg7UCsrKWlmKGEuaXNUYWcoYltQXSkpe2lmKGJbUF09PT1BKWJyZWFrO2EuZ2V0TmFtZShiW1BdKT09PWEuZ2V0TmFtZShBKSYmSSsrfXJldHVybiBuKEkpJiZ5KEEpfX0sIm50aC1sYXN0LW9mLXR5cGUiOmZ1bmN0aW9uKHkscixzKXt2YXIgbj1pKHIpLGE9cy5hZGFwdGVyO3JldHVybiBuPT09Yz9uOm49PT12P0UoeSxhKTpmdW5jdGlvbihBKXtmb3IodmFyIGI9YS5nZXRTaWJsaW5ncyhBKSxJPTAsUD1iLmxlbmd0aC0xO1A+PTA7UC0tKWlmKGEuaXNUYWcoYltQXSkpe2lmKGJbUF09PT1BKWJyZWFrO2EuZ2V0TmFtZShiW1BdKT09PWEuZ2V0TmFtZShBKSYmSSsrfXJldHVybiBuKEkpJiZ5KEEpfX0scm9vdDpmdW5jdGlvbih5LHIscyl7dmFyIG49cy5hZGFwdGVyO3JldHVybiBmdW5jdGlvbihhKXtyZXR1cm4hbi5nZXRQYXJlbnQoYSkmJnkoYSl9fSxzY29wZTpmdW5jdGlvbih5LHIscyxuKXt2YXIgYT1zLmFkYXB0ZXI7aWYoIW58fG4ubGVuZ3RoPT09MClyZXR1cm4gbC5yb290KHkscixzKTtmdW5jdGlvbiBPKEEsYil7cmV0dXJuIHR5cGVvZiBhLmVxdWFscz09ImZ1bmN0aW9uIj9hLmVxdWFscyhBLGIpOkE9PT1ifXJldHVybiBuLmxlbmd0aD09PTE/ZnVuY3Rpb24oQSl7cmV0dXJuIE8oblswXSxBKSYmeShBKX06ZnVuY3Rpb24oQSl7cmV0dXJuIG4uaW5kZXhPZihBKT49MCYmeShBKX19LGNoZWNrYm94OmgoInR5cGUiLCJjaGVja2JveCIpLGZpbGU6aCgidHlwZSIsImZpbGUiKSxwYXNzd29yZDpoKCJ0eXBlIiwicGFzc3dvcmQiKSxyYWRpbzpoKCJ0eXBlIiwicmFkaW8iKSxyZXNldDpoKCJ0eXBlIiwicmVzZXQiKSxpbWFnZTpoKCJ0eXBlIiwiaW1hZ2UiKSxzdWJtaXQ6aCgidHlwZSIsInN1Ym1pdCIpLGhvdmVyOmZ1bmN0aW9uKHkscixzKXt2YXIgbj1zLmFkYXB0ZXI7cmV0dXJuIHR5cGVvZiBuLmlzSG92ZXJlZD09ImZ1bmN0aW9uIj9mdW5jdGlvbihPKXtyZXR1cm4geShPKSYmbi5pc0hvdmVyZWQoTyl9OmN9LHZpc2l0ZWQ6ZnVuY3Rpb24oeSxyLHMpe3ZhciBuPXMuYWRhcHRlcjtyZXR1cm4gdHlwZW9mIG4uaXNWaXNpdGVkPT0iZnVuY3Rpb24iP2Z1bmN0aW9uKE8pe3JldHVybiB5KE8pJiZuLmlzVmlzaXRlZChPKX06Y30sYWN0aXZlOmZ1bmN0aW9uKHkscixzKXt2YXIgbj1zLmFkYXB0ZXI7cmV0dXJuIHR5cGVvZiBuLmlzQWN0aXZlPT0iZnVuY3Rpb24iP2Z1bmN0aW9uKE8pe3JldHVybiB5KE8pJiZuLmlzQWN0aXZlKE8pfTpjfX07ZnVuY3Rpb24gbSh5LHIpe2Zvcih2YXIgcz0wO3kmJnM8eS5sZW5ndGg7cysrKWlmKHIuaXNUYWcoeVtzXSkpcmV0dXJuIHlbc119dmFyIHA9e2VtcHR5OmZ1bmN0aW9uKHkscil7cmV0dXJuIXIuZ2V0Q2hpbGRyZW4oeSkuc29tZShmdW5jdGlvbihzKXtyZXR1cm4gci5pc1RhZyhzKXx8cy50eXBlPT09InRleHQifSl9LCJmaXJzdC1jaGlsZCI6ZnVuY3Rpb24oeSxyKXtyZXR1cm4gbShyLmdldFNpYmxpbmdzKHkpLHIpPT09eX0sImxhc3QtY2hpbGQiOmZ1bmN0aW9uKHkscil7Zm9yKHZhciBzPXIuZ2V0U2libGluZ3MoeSksbj1zLmxlbmd0aC0xO24+PTA7bi0tKXtpZihzW25dPT09eSlyZXR1cm4hMDtpZihyLmlzVGFnKHNbbl0pKWJyZWFrfXJldHVybiExfSwiZmlyc3Qtb2YtdHlwZSI6ZnVuY3Rpb24oeSxyKXtmb3IodmFyIHM9ci5nZXRTaWJsaW5ncyh5KSxuPTA7bjxzLmxlbmd0aDtuKyspaWYoci5pc1RhZyhzW25dKSl7aWYoc1tuXT09PXkpcmV0dXJuITA7aWYoci5nZXROYW1lKHNbbl0pPT09ci5nZXROYW1lKHkpKWJyZWFrfXJldHVybiExfSwibGFzdC1vZi10eXBlIjpmdW5jdGlvbih5LHIpe2Zvcih2YXIgcz1yLmdldFNpYmxpbmdzKHkpLG49cy5sZW5ndGgtMTtuPj0wO24tLSlpZihyLmlzVGFnKHNbbl0pKXtpZihzW25dPT09eSlyZXR1cm4hMDtpZihyLmdldE5hbWUoc1tuXSk9PT1yLmdldE5hbWUoeSkpYnJlYWt9cmV0dXJuITF9LCJvbmx5LW9mLXR5cGUiOmZ1bmN0aW9uKHkscil7Zm9yKHZhciBzPXIuZ2V0U2libGluZ3MoeSksbj0wLGE9cy5sZW5ndGg7bjxhO24rKylpZihyLmlzVGFnKHNbbl0pKXtpZihzW25dPT09eSljb250aW51ZTtpZihyLmdldE5hbWUoc1tuXSk9PT1yLmdldE5hbWUoeSkpcmV0dXJuITF9cmV0dXJuITB9LCJvbmx5LWNoaWxkIjpmdW5jdGlvbih5LHIpe2Zvcih2YXIgcz1yLmdldFNpYmxpbmdzKHkpLG49MDtuPHMubGVuZ3RoO24rKylpZihyLmlzVGFnKHNbbl0pJiZzW25dIT09eSlyZXR1cm4hMTtyZXR1cm4hMH0sbGluazpmdW5jdGlvbih5LHIpe3JldHVybiByLmhhc0F0dHJpYih5LCJocmVmIil9LHNlbGVjdGVkOmZ1bmN0aW9uKHkscil7aWYoci5oYXNBdHRyaWIoeSwic2VsZWN0ZWQiKSlyZXR1cm4hMDtpZihyLmdldE5hbWUoeSkhPT0ib3B0aW9uIilyZXR1cm4hMTt2YXIgcz1yLmdldFBhcmVudCh5KTtpZighc3x8ci5nZXROYW1lKHMpIT09InNlbGVjdCJ8fHIuaGFzQXR0cmliKHMsIm11bHRpcGxlIikpcmV0dXJuITE7Zm9yKHZhciBuPXIuZ2V0Q2hpbGRyZW4ocyksYT0hMSxPPTA7TzxuLmxlbmd0aDtPKyspaWYoci5pc1RhZyhuW09dKSlpZihuW09dPT09eSlhPSEwO2Vsc2UgaWYoYSl7aWYoci5oYXNBdHRyaWIobltPXSwic2VsZWN0ZWQiKSlyZXR1cm4hMX1lbHNlIHJldHVybiExO3JldHVybiBhfSxkaXNhYmxlZDpmdW5jdGlvbih5LHIpe3JldHVybiByLmhhc0F0dHJpYih5LCJkaXNhYmxlZCIpfSxlbmFibGVkOmZ1bmN0aW9uKHkscil7cmV0dXJuIXIuaGFzQXR0cmliKHksImRpc2FibGVkIil9LGNoZWNrZWQ6ZnVuY3Rpb24oeSxyKXtyZXR1cm4gci5oYXNBdHRyaWIoeSwiY2hlY2tlZCIpfHxwLnNlbGVjdGVkKHkscil9LHJlcXVpcmVkOmZ1bmN0aW9uKHkscil7cmV0dXJuIHIuaGFzQXR0cmliKHksInJlcXVpcmVkIil9LG9wdGlvbmFsOmZ1bmN0aW9uKHkscil7cmV0dXJuIXIuaGFzQXR0cmliKHksInJlcXVpcmVkIil9LHBhcmVudDpmdW5jdGlvbih5LHIpe3JldHVybiFwLmVtcHR5KHkscil9LGhlYWRlcjpDKFsiaDEiLCJoMiIsImgzIiwiaDQiLCJoNSIsImg2Il0pLGJ1dHRvbjpmdW5jdGlvbih5LHIpe3ZhciBzPXIuZ2V0TmFtZSh5KTtyZXR1cm4gcz09PSJidXR0b24ifHxzPT09ImlucHV0IiYmci5nZXRBdHRyaWJ1dGVWYWx1ZSh5LCJ0eXBlIik9PT0iYnV0dG9uIn0saW5wdXQ6QyhbImlucHV0IiwidGV4dGFyZWEiLCJzZWxlY3QiLCJidXR0b24iXSksdGV4dDpmdW5jdGlvbih5LHIpe3ZhciBzO3JldHVybiByLmdldE5hbWUoeSk9PT0iaW5wdXQiJiYoIShzPXIuZ2V0QXR0cmlidXRlVmFsdWUoeSwidHlwZSIpKXx8cy50b0xvd2VyQ2FzZSgpPT09InRleHQiKX19O2Z1bmN0aW9uIEMoeSl7aWYodHlwZW9mIFNldDwidSIpe3ZhciByPW5ldyBTZXQoeSk7cmV0dXJuIGZ1bmN0aW9uKHMsbil7cmV0dXJuIHIuaGFzKG4uZ2V0TmFtZShzKSl9fXJldHVybiBmdW5jdGlvbihzLG4pe3JldHVybiB5LmluZGV4T2Yobi5nZXROYW1lKHMpKT49MH19ZnVuY3Rpb24geCh5LHIscyl7aWYocz09PW51bGwpe2lmKHkubGVuZ3RoPjImJnIhPT0ic2NvcGUiKXRocm93IG5ldyBFcnJvcigicHNldWRvLXNlbGVjdG9yIDoiK3IrIiByZXF1aXJlcyBhbiBhcmd1bWVudCIpfWVsc2UgaWYoeS5sZW5ndGg9PT0yKXRocm93IG5ldyBFcnJvcigicHNldWRvLXNlbGVjdG9yIDoiK3IrIiBkb2Vzbid0IGhhdmUgYW55IGFyZ3VtZW50cyIpfXZhciBkPS9eKD86KD86bnRofGxhc3R8Zmlyc3R8b25seSktKD86Y2hpbGR8b2YtdHlwZSl8cm9vdHxlbXB0eXwoPzplbnxkaXMpYWJsZWR8Y2hlY2tlZHxub3QpJC87Ui5leHBvcnRzPXtjb21waWxlOmZ1bmN0aW9uKHkscixzLG4pe3ZhciBhPXIubmFtZSxPPXIuZGF0YSxBPXMuYWRhcHRlcjtpZihzJiZzLnN0cmljdCYmIWQudGVzdChhKSl0aHJvdyBuZXcgRXJyb3IoIjoiK2ErIiBpc24ndCBwYXJ0IG9mIENTUzMiKTtpZih0eXBlb2YgbFthXT09ImZ1bmN0aW9uIilyZXR1cm4gbFthXSh5LE8scyxuKTtpZih0eXBlb2YgcFthXT09ImZ1bmN0aW9uIil7dmFyIGI9cFthXTtyZXR1cm4geChiLGEsTyksYj09PWM/Yjp5PT09dj9mdW5jdGlvbihQKXtyZXR1cm4gYihQLEEsTyl9OmZ1bmN0aW9uKFApe3JldHVybiBiKFAsQSxPKSYmeShQKX19ZWxzZSB0aHJvdyBuZXcgRXJyb3IoInVubWF0Y2hlZCBwc2V1ZG8tY2xhc3MgOiIrYSl9LGZpbHRlcnM6bCxwc2V1ZG9zOnB9fSxmdW5jdGlvbihSLGUsdCl7dmFyIGk9dCgyODQpLG89dCgyODUpO1IuZXhwb3J0cz1mdW5jdGlvbih2KXtyZXR1cm4gbyhpKHYpKX0sUi5leHBvcnRzLnBhcnNlPWksUi5leHBvcnRzLmNvbXBpbGU9b30sZnVuY3Rpb24oUixlKXtSLmV4cG9ydHM9aTt2YXIgdD0vXihbK1wtXT9cZCpuKT9ccyooPzooWytcLV0/KVxzKihcZCspKT8kLztmdW5jdGlvbiBpKG8pe2lmKG89by50cmltKCkudG9Mb3dlckNhc2UoKSxvPT09ImV2ZW4iKXJldHVyblsyLDBdO2lmKG89PT0ib2RkIilyZXR1cm5bMiwxXTt2YXIgZz1vLm1hdGNoKHQpO2lmKCFnKXRocm93IG5ldyBTeW50YXhFcnJvcigibi10aCBydWxlIGNvdWxkbid0IGJlIHBhcnNlZCAoJyIrbysiJykiKTt2YXIgdjtyZXR1cm4gZ1sxXT8odj1wYXJzZUludChnWzFdLDEwKSxpc05hTih2KSYmKGdbMV0uY2hhckF0KDApPT09Ii0iP3Y9LTE6dj0xKSk6dj0wLFt2LGdbM10/cGFyc2VJbnQoKGdbMl18fCIiKStnWzNdLDEwKTowXX19LGZ1bmN0aW9uKFIsZSx0KXtSLmV4cG9ydHM9djt2YXIgaT10KDI3Myksbz1pLnRydWVGdW5jLGc9aS5mYWxzZUZ1bmM7ZnVuY3Rpb24gdihjKXt2YXIgZj1jWzBdLGg9Y1sxXS0xO2lmKGg8MCYmZjw9MClyZXR1cm4gZztpZihmPT09LTEpcmV0dXJuIGZ1bmN0aW9uKGwpe3JldHVybiBsPD1ofTtpZihmPT09MClyZXR1cm4gZnVuY3Rpb24obCl7cmV0dXJuIGw9PT1ofTtpZihmPT09MSlyZXR1cm4gaDwwP286ZnVuY3Rpb24obCl7cmV0dXJuIGw+PWh9O3ZhciBFPWglZjtyZXR1cm4gRTwwJiYoRSs9ZiksZj4xP2Z1bmN0aW9uKGwpe3JldHVybiBsPj1oJiZsJWY9PT1FfTooZio9LTEsZnVuY3Rpb24obCl7cmV0dXJuIGw8PWgmJmwlZj09PUV9KX19LGZ1bmN0aW9uKFIsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIE99KTt2YXIgaT10KDEyKSxvPXQoNzQpLGc9dCgxKSx2PXQoNjgpLGM9dCgyNTApLGY9dCgyMTMpLGg9dCgyMTgpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBFKEEsYil7aWYoQT09bnVsbClyZXR1cm57fTt2YXIgST1sKEEsYiksUCxEO2lmKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpe3ZhciBMPU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoQSk7Zm9yKEQ9MDtEPEwubGVuZ3RoO0QrKylQPUxbRF0sIShiLmluZGV4T2YoUCk+PTApJiZPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoQSxQKSYmKElbUF09QVtQXSl9cmV0dXJuIEl9ZnVuY3Rpb24gbChBLGIpe2lmKEE9PW51bGwpcmV0dXJue307dmFyIEk9e30sUD1PYmplY3Qua2V5cyhBKSxELEw7Zm9yKEw9MDtMPFAubGVuZ3RoO0wrKylEPVBbTF0sIShiLmluZGV4T2YoRCk+PTApJiYoSVtEXT1BW0RdKTtyZXR1cm4gSX1jb25zdCBtPXthbnRpYWxpYXM6ITAsYXV0b1JlbmRlcjohMCxhbHBoYTohMH0scD1TeW1ib2woImF1dG9SZW5kZXIiKSxDPVN5bWJvbCgicmVuZGVyZXIiKSx4PVN5bWJvbCgidGltZWxpbmUiKSxkPVN5bWJvbCgicHJlcGFyZVJlbmRlciIpLHk9U3ltYm9sKCJ0aWNrUmVuZGVyIikscj1TeW1ib2woInBhc3MiKSxzPVN5bWJvbCgiZmJvIiksbj1TeW1ib2woInRpY2tlcnMiKSxhPVN5bWJvbCgibGF5ZXJUcmFuc2Zvcm1JbnZlcnQiKTtjbGFzcyBPIGV4dGVuZHMgYy5kZWZhdWx0e2NvbnN0cnVjdG9yKGI9e30pe2lmKHN1cGVyKCksIWIuY2FudmFzKXtjb25zdHt3aWR0aDpMLGhlaWdodDpTfT10aGlzLmdldFJlc29sdXRpb24oKSxUPWkuRU5WLmNyZWF0ZUNhbnZhcyhMLFMse29mZnNjcmVlbjohIWIub2Zmc2NyZWVuLGlkOmIuaWQsZXh0cmE6Yi5leHRyYX0pO1Quc3R5bGUmJihULnN0eWxlLnBvc2l0aW9uPSJhYnNvbHV0ZSIpLFQuZGF0YXNldCYmKFQuZGF0YXNldC5sYXllcklkPWIuaWQpLFQuY29udGV4dFR5cGUmJihiLmNvbnRleHRUeXBlPVQuY29udGV4dFR5cGUpLGIuY2FudmFzPVR9Y29uc3QgST1iLmNhbnZhcyxQPU9iamVjdC5hc3NpZ24oe30sbSxiKTt0aGlzW3BdPVAuYXV0b1JlbmRlcixkZWxldGUgYi5hdXRvUmVuZGVyO2NvbnN0IEQ9UC5SZW5kZXJlcnx8aS5SZW5kZXJlcjt0aGlzW0NdPW5ldyBEKEksUCksdGhpcy5vcHRpb25zPWIsdGhpcy5pZD1iLmlkLHRoaXNbcl09W10sdGhpcy5zZXRSZXNvbHV0aW9uKEkpLHRoaXMuY2FudmFzPUksdGhpc1t4XT1uZXcgby5UaW1lbGluZSx0aGlzLl9fbW91c2VDYXB0dXJlZFRhcmdldD1udWxsLHRoaXNbYV09bnVsbH1nZXQgYXV0b1JlbmRlcigpe3JldHVybiB0aGlzW3BdfWdldCBkaXNwbGF5UmF0aW8oKXtyZXR1cm4gdGhpcy5wYXJlbnQmJnRoaXMucGFyZW50Lm9wdGlvbnM/dGhpcy5wYXJlbnQub3B0aW9ucy5kaXNwbGF5UmF0aW86MX1nZXQgaGVpZ2h0KCl7Y29uc3R7aGVpZ2h0OmJ9PXRoaXMuZ2V0UmVzb2x1dGlvbigpO3JldHVybiBiL3RoaXMuZGlzcGxheVJhdGlvfWdldCBnbCgpe3JldHVybiB0aGlzLnJlbmRlcmVyLmdsUmVuZGVyZXI/dGhpcy5yZW5kZXJlci5nbFJlbmRlcmVyLmdsOm51bGx9Z2V0IGxheWVyKCl7cmV0dXJuIHRoaXN9Z2V0IG9mZnNjcmVlbigpe3JldHVybiEhdGhpcy5vcHRpb25zLm9mZnNjcmVlbnx8dGhpcy5jYW52YXMuX29mZnNjcmVlbn1nZXQgcGFzcygpe3JldHVybiB0aGlzW3JdfWdldCBwcmVwYXJlUmVuZGVyKCl7cmV0dXJuIHRoaXNbZF0/dGhpc1tkXTpQcm9taXNlLnJlc29sdmUoKX1nZXQgcmVuZGVyZXIoKXtyZXR1cm4gdGhpc1tDXX1nZXQgcmVuZGVyT2Zmc2V0KCl7aWYodGhpcy5wYXJlbnQmJnRoaXMucGFyZW50Lm9wdGlvbnMpe2NvbnN0e2xlZnQ6Yix0b3A6SX09dGhpcy5wYXJlbnQub3B0aW9ucztyZXR1cm5bYixJXX1yZXR1cm5bdGhpcy5vcHRpb25zLmxlZnR8MCx0aGlzLm9wdGlvbnMudG9wfDBdfWdldCB0aW1lbGluZSgpe3JldHVybiB0aGlzW3hdfWdldCB3aWR0aCgpe2NvbnN0e3dpZHRoOmJ9PXRoaXMuZ2V0UmVzb2x1dGlvbigpO3JldHVybiBiL3RoaXMuZGlzcGxheVJhdGlvfWdldCBsb2NhbE1hdHJpeCgpe2NvbnN0e3g6Yix5Okl9PXRoaXMuYXR0cmlidXRlcztyZXR1cm5bMSwwLDAsMSxiLEldfWdldCBsYXllclRyYW5zZm9ybUludmVydCgpe2lmKHRoaXNbYV0pcmV0dXJuIHRoaXNbYV07Y29uc3QgYj10aGlzLnRyYW5zZm9ybU1hdHJpeDtyZXR1cm4gYlswXT09PTEmJmJbMV09PT0wJiZiWzJdPT09MCYmYlszXT09PTEmJmJbNF09PT0wJiZiWzVdPT09MD9udWxsOih0aGlzW2FdPWcubWF0MmQuaW52ZXJ0KEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxiKSx0aGlzW2FdKX1mb3JjZUNvbnRleHRMb3NzKCl7Y29uc3QgYj10aGlzLnJlbmRlcmVyLmdsUmVuZGVyZXI7aWYoYil7Y29uc3QgST1iLmdldEV4dGVuc2lvbigiV0VCR0xfbG9zZV9jb250ZXh0Iik7aWYoSSlyZXR1cm4gSS5sb3NlQ29udGV4dCgpLCEwfXJldHVybiExfWFkZFBhc3Moe3ZlcnRleDpiLGZyYWdtZW50Okksb3B0aW9uczpQLHVuaWZvcm1zOkR9PXt9KXtpZih0aGlzLnJlbmRlcmVyLmdsUmVuZGVyZXIpe2NvbnN0e3dpZHRoOkwsaGVpZ2h0OlN9PXRoaXMuZ2V0UmVzb2x1dGlvbigpLFQ9dGhpcy5yZW5kZXJlci5jcmVhdGVQYXNzUHJvZ3JhbSh7dmVydGV4OmIsZnJhZ21lbnQ6SSxvcHRpb25zOlB9KSxqPW5ldyBpLkZpZ3VyZTJEO2oucmVjdCgwLDAsTC90aGlzLmRpc3BsYXlSYXRpbyxTL3RoaXMuZGlzcGxheVJhdGlvKTtjb25zdCAkPW5ldyBpLk1lc2gyRChqKTtyZXR1cm4gJC5zZXRVbmlmb3JtcyhEKSwkLnNldFByb2dyYW0oVCksdGhpc1tyXS5wdXNoKCQpLHRoaXMuZm9yY2VVcGRhdGUoKSwkfXJldHVybiBudWxsfWRlbGV0ZVRleHR1cmUoYil7cmV0dXJuIE9iamVjdChoLmRlbGV0ZVRleHR1cmUpKGIsdGhpcy5yZW5kZXJlcil9ZGlzcGF0Y2hQb2ludGVyRXZlbnQoYil7Y29uc3QgST1iLnR5cGU7aWYoST09PSJtb3VzZWRvd24ifHxJPT09Im1vdXNldXAifHxJPT09Im1vdXNlbW92ZSIpe2NvbnN0IFQ9dGhpcy5fX21vdXNlQ2FwdHVyZWRUYXJnZXQ7aWYoVCl7aWYoVC5sYXllcj09PXRoaXMpcmV0dXJuIFQuZGlzcGF0Y2hFdmVudChiKSwhMDt0aGlzLl9fbW91c2VDYXB0dXJlZFRhcmdldD1udWxsfX1sZXQgUCxEO2NvbnN0IEw9dGhpcy5sYXllclRyYW5zZm9ybUludmVydDtpZihMKXtQPWIueCxEPWIueTtjb25zdCBUPUwsaj1UWzBdKlArVFsyXSpEK1RbNF0sJD1UWzFdKlArVFszXSpEK1RbNV07ZGVsZXRlIGIueCxkZWxldGUgYi55LGRlbGV0ZSBiLmxheWVyWCxkZWxldGUgYi5sYXllclksT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoYix7bGF5ZXJYOnt2YWx1ZTpqLGNvbmZpZ3VyYWJsZTohMH0sbGF5ZXJZOnt2YWx1ZTokLGNvbmZpZ3VyYWJsZTohMH0seDp7dmFsdWU6aixjb25maWd1cmFibGU6ITB9LHk6e3ZhbHVlOiQsY29uZmlndXJhYmxlOiEwfX0pfWNvbnN0IFM9c3VwZXIuZGlzcGF0Y2hQb2ludGVyRXZlbnQoYik7cmV0dXJuIEwmJk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGIse2xheWVyWDp7dmFsdWU6UCxjb25maWd1cmFibGU6ITB9LGxheWVyWTp7dmFsdWU6RCxjb25maWd1cmFibGU6ITB9LHg6e3ZhbHVlOlAsY29uZmlndXJhYmxlOiEwfSx5Ont2YWx1ZTpELGNvbmZpZ3VyYWJsZTohMH19KSxTfWZvcmNlVXBkYXRlKCl7aWYoIXRoaXNbZF0paWYodGhpcy5wYXJlbnQmJnRoaXMucGFyZW50Lmhhc09mZnNjcmVlbkNhbnZhcyl7dGhpcy5wYXJlbnQuZm9yY2VVcGRhdGUoKTtsZXQgYj1udWxsO2NvbnN0IEk9bmV3IFByb21pc2UoUD0+e2I9UH0pO0kuX3Jlc29sdmU9Yix0aGlzW2RdPUl9ZWxzZXtsZXQgYj1udWxsLEk9bnVsbDtjb25zdCBQPW5ldyBQcm9taXNlKEQ9PntiPUQsdGhpc1twXSYmKEk9T2JqZWN0KHYucmVxdWVzdEFuaW1hdGlvbkZyYW1lKSgoKT0+e2RlbGV0ZSBQLl9yZXF1ZXN0SUQsdGhpcy5yZW5kZXIoKX0pKX0pO1AuX3Jlc29sdmU9YixQLl9yZXF1ZXN0SUQ9SSx0aGlzW2RdPVB9fWdldEZCTygpe2NvbnN0IGI9dGhpcy5yZW5kZXJlci5nbFJlbmRlcmVyLHt3aWR0aDpJLGhlaWdodDpQfT10aGlzLmdldFJlc29sdXRpb24oKTtyZXR1cm4gYiYmKCF0aGlzW3NdfHx0aGlzW3NdLndpZHRoIT09SXx8dGhpc1tzXS5oZWlnaHQhPT1QKT8odGhpc1tzXT17d2lkdGg6SSxoZWlnaHQ6UCx0YXJnZXQ6Yi5jcmVhdGVGQk8oKSxidWZmZXI6Yi5jcmVhdGVGQk8oKSxzd2FwKCl7W3RoaXMudGFyZ2V0LHRoaXMuYnVmZmVyXT1bdGhpcy5idWZmZXIsdGhpcy50YXJnZXRdfX0sdGhpc1tzXSk6dGhpc1tzXT90aGlzW3NdOm51bGx9dXBkYXRlR2xvYmFsVHJhbnNmb3JtKCl7aWYodGhpcy5sYXllclRyYW5zZm9ybUludmVydCl7Y29uc3QgYj10aGlzLnJlbmRlcmVyLEk9Yi5fX2dsb2JhbFRyYW5zZm9ybU1hdHJpeHx8Yi5nbG9iYWxUcmFuc2Zvcm1NYXRyaXg7Yi5fX2dsb2JhbFRyYW5zZm9ybU1hdHJpeD1JO2NvbnN0IFA9Zy5tYXQyZC5mcm9tVmFsdWVzKDEsMCwwLDEsMCwwKTtiLnNldEdsb2JhbFRyYW5zZm9ybSguLi5nLm1hdDJkLm11bHRpcGx5KFAsSSx0aGlzLnRyYW5zZm9ybU1hdHJpeCkpfX1vblByb3BlcnR5Q2hhbmdlKGIsSSxQKXtpZihzdXBlci5vblByb3BlcnR5Q2hhbmdlKGIsSSxQKSxiPT09InpJbmRleCImJih0aGlzLmNhbnZhcy5zdHlsZS56SW5kZXg9SSksYj09PSJ0cmFuc2Zvcm0ifHxiPT09InRyYW5zbGF0ZSJ8fGI9PT0icm90YXRlInx8Yj09PSJzY2FsZSJ8fGI9PT0ic2tldyIpe2NvbnN0IEQ9dGhpc1thXTtpZih0aGlzW2FdPW51bGwsdGhpcy51cGRhdGVHbG9iYWxUcmFuc2Zvcm0oKSxEJiYhdGhpcy5sYXllclRyYW5zZm9ybUludmVydCl7Y29uc3QgTD10aGlzLnJlbmRlcmVyLFM9TC5fX2dsb2JhbFRyYW5zZm9ybU1hdHJpeHx8TC5nbG9iYWxUcmFuc2Zvcm1NYXRyaXg7TC5zZXRHbG9iYWxUcmFuc2Zvcm0oLi4uUyl9fX1fcHJlcGFyZVJlbmRlckZpbmlzaGVkKCl7dGhpc1tkXSYmKHRoaXNbZF0uX3JlcXVlc3RJRCYmT2JqZWN0KHYuY2FuY2VsQW5pbWF0aW9uRnJhbWUpKHRoaXNbZF0uX3JlcXVlc3RJRCksdGhpc1tkXS5fcmVzb2x2ZSgpLGRlbGV0ZSB0aGlzW2RdKX1yZW5kZXIoe2NsZWFyOmI9ITB9PXt9KXtjb25zdCBJPXRoaXNbcl0ubGVuZ3RoP3RoaXMuZ2V0RkJPKCk6bnVsbDtJJiZ0aGlzLnJlbmRlcmVyLmdsUmVuZGVyZXIuYmluZEZCTyhJLnRhcmdldCksYiYmdGhpc1tDXS5jbGVhcigpO2NvbnN0IFA9dGhpcy5kcmF3KCk7aWYoUCYmUC5sZW5ndGgmJih0aGlzLnJlbmRlcmVyLmRyYXdNZXNoZXMoUCksdGhpcy5jYW52YXMuZHJhdyYmdGhpcy5jYW52YXMuZHJhdygpKSxJKXtjb25zdCBEPXRoaXMucmVuZGVyZXIuZ2xSZW5kZXJlcixMPXRoaXNbcl0ubGVuZ3RoLHt3aWR0aDpTLGhlaWdodDpUfT10aGlzLmdldFJlc29sdXRpb24oKSxqPVswLDAsUy90aGlzLmRpc3BsYXlSYXRpbyxUL3RoaXMuZGlzcGxheVJhdGlvXTt0aGlzW3JdLmZvckVhY2goKCQsdyk9PnskLmJsZW5kPSEwLCQuc2V0VGV4dHVyZShJLnRhcmdldC50ZXh0dXJlLHtyZWN0Omp9KSx3PT09TC0xP0QuYmluZEZCTyhudWxsKTooSS5zd2FwKCksRC5iaW5kRkJPKEkudGFyZ2V0KSksdGhpc1tDXS5jbGVhcigpLHRoaXMucmVuZGVyZXIuZHJhd01lc2hlcyhbJF0pfSl9dGhpcy5fcHJlcGFyZVJlbmRlckZpbmlzaGVkKCl9c2V0UmVzb2x1dGlvbih7d2lkdGg6YixoZWlnaHQ6SX0pe2NvbnN0IFA9dGhpcy5yZW5kZXJlcixEPVAuX19nbG9iYWxUcmFuc2Zvcm1NYXRyaXh8fFAuZ2xvYmFsVHJhbnNmb3JtTWF0cml4LEw9RFs0XSxTPURbNV0sVD1EWzBdLHt3aWR0aDpqLGhlaWdodDokfT10aGlzLmdldFJlc29sdXRpb24oKTsoaiE9PWJ8fCQhPT1JKSYmKHN1cGVyLnNldFJlc29sdXRpb24oe3dpZHRoOmIsaGVpZ2h0Okl9KSx0aGlzLmNhbnZhcyYmKHRoaXMuY2FudmFzLndpZHRoPWIsdGhpcy5jYW52YXMuaGVpZ2h0PUksUC51cGRhdGVSZXNvbHV0aW9uJiZQLnVwZGF0ZVJlc29sdXRpb24oKSksdGhpcy5hdHRyaWJ1dGVzLnNpemU9W2IsSV0sdGhpc1tyXS5sZW5ndGgmJnRoaXNbcl0uZm9yRWFjaChXPT57Y29uc3QgSz1uZXcgaS5GaWd1cmUyRDtLLnJlY3QoMCwwLGIvdGhpcy5kaXNwbGF5UmF0aW8sSS90aGlzLmRpc3BsYXlSYXRpbyksVy5jb250b3Vycz1LLmNvbnRvdXJzfSkpO2NvbnN0W3csSl09dGhpcy5yZW5kZXJPZmZzZXQscT10aGlzLmRpc3BsYXlSYXRpbzsoTCE9PXd8fFMhPT1KfHxUIT09cSkmJihQLnNldEdsb2JhbFRyYW5zZm9ybShxLDAsMCxxLHcsSiksUC5fX2dsb2JhbFRyYW5zZm9ybU1hdHJpeD1udWxsLHRoaXNbYV09bnVsbCx0aGlzLnVwZGF0ZUdsb2JhbFRyYW5zZm9ybSgpLHRoaXMuZm9yY2VVcGRhdGUoKSl9dGljayhiPW51bGwsST17fSl7bGV0e2R1cmF0aW9uOlA9MS8wfT1JLEQ9RShJLFsiZHVyYXRpb24iXSk7Y29uc3QgTD10aGlzLnRpbWVsaW5lLmZvcmsoRCksUz10aGlzO3RoaXNbbl09dGhpc1tuXXx8W10sdGhpc1tuXS5wdXNoKHtoYW5kbGVyOmIsZHVyYXRpb246UH0pO2NvbnN0IFQ9KCk9PntsZXQgaj1udWxsLCQ9bnVsbDtjb25zdCB3PSgpPT57Y29uc3QgSj10aGlzW25dLm1hcCgoe2hhbmRsZXI6cSxkdXJhdGlvbjpXfSk9Pntjb25zdCBLPU1hdGgubWluKDEsTC5jdXJyZW50VGltZS9XKTtyZXR1cm57dmFsdWU6cT9xKEwuY3VycmVudFRpbWUsSyk6bnVsbCxwOkt9fSk7U1t5XXx8KFNbeV09UHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKT0+e1NbcF0mJlMucmVuZGVyKCksZGVsZXRlIFNbeV07Zm9yKGxldCBxPUoubGVuZ3RoLTE7cT49MDtxLS0pe2NvbnN0e3ZhbHVlOlcscDpLfT1KW3FdOyhXPT09ITF8fEs+PTEpJiZ0aGlzW25dLnNwbGljZShxLDEpfXRoaXNbbl0ubGVuZ3RoPjAmJlQoKX0pKX07aWYodGhpc1tkXSYmdGhpc1tkXS5fdHlwZSE9PSJ0aWNrZXIiJiYoT2JqZWN0KHYuY2FuY2VsQW5pbWF0aW9uRnJhbWUpKHRoaXNbZF0uX3JlcXVlc3RJRCksZGVsZXRlIHRoaXNbZF0pLCF0aGlzW2RdKXtjb25zdCBKPW5ldyBQcm9taXNlKHE9PntqPXEsJD1PYmplY3Qodi5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpKHcpfSk7Si5fcmVzb2x2ZT1qLEouX3JlcXVlc3RJRD0kLEouX3R5cGU9InRpY2tlciIsdGhpc1tkXT1KfX07VCgpfXRvR2xvYmFsUG9zKGIsSSl7aWYodGhpcy5sYXllclRyYW5zZm9ybUludmVydCl7Y29uc3Qgaj10aGlzLnRyYW5zZm9ybU1hdHJpeDtiPWpbMF0qYitqWzJdKkkrals0XSxJPWpbMV0qYitqWzNdKkkrals1XX1jb25zdHt3aWR0aDpQLGhlaWdodDpEfT10aGlzLmdldFJlc29sdXRpb24oKSxMPXRoaXMucmVuZGVyT2Zmc2V0LFM9W3RoaXMuY2FudmFzLmNsaWVudFdpZHRoLHRoaXMuY2FudmFzLmNsaWVudEhlaWdodF07Yj1iKlNbMF0vUCtMWzBdLEk9SSpTWzFdL0QrTFsxXTtjb25zdCBUPXRoaXMuZGlzcGxheVJhdGlvO3JldHVybiBiKj1ULEkqPVQsW2IsSV19dG9Mb2NhbFBvcyhiLEkpe2NvbnN0e3dpZHRoOlAsaGVpZ2h0OkR9PXRoaXMuZ2V0UmVzb2x1dGlvbigpLEw9dGhpcy5yZW5kZXJPZmZzZXQsUz1bdGhpcy5jYW52YXMuY2xpZW50V2lkdGgsdGhpcy5jYW52YXMuY2xpZW50SGVpZ2h0XTtiPWIqUC9TWzBdLUxbMF0sST1JKkQvU1sxXS1MWzFdO2NvbnN0IFQ9dGhpcy5kaXNwbGF5UmF0aW87Yi89VCxJLz1UO2NvbnN0IGo9dGhpcy5sYXllclRyYW5zZm9ybUludmVydDtyZXR1cm4gaiYmKGI9alswXSpiK2pbMl0qSStqWzRdLEk9alsxXSpiK2pbM10qSStqWzVdKSxbYixJXX19Zi5kZWZhdWx0LnJlZ2lzdGVyTm9kZShPLCJsYXllciIpfSxmdW5jdGlvbihSLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBkfSk7dmFyIGk9dCgyMjQpLG89dCgyODgpLGc9dCgyMTMpLHY9dCgyNTIpLGM9dCg3Mik7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIGYoeSxyKXtpZih5PT1udWxsKXJldHVybnt9O3ZhciBzPWgoeSxyKSxuLGE7aWYoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyl7dmFyIE89T2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyh5KTtmb3IoYT0wO2E8Ty5sZW5ndGg7YSsrKW49T1thXSwhKHIuaW5kZXhPZihuKT49MCkmJk9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh5LG4pJiYoc1tuXT15W25dKX1yZXR1cm4gc31mdW5jdGlvbiBoKHkscil7aWYoeT09bnVsbClyZXR1cm57fTt2YXIgcz17fSxuPU9iamVjdC5rZXlzKHkpLGEsTztmb3IoTz0wO088bi5sZW5ndGg7TysrKWE9bltPXSwhKHIuaW5kZXhPZihhKT49MCkmJihzW2FdPXlbYV0pO3JldHVybiBzfWZ1bmN0aW9uIEUoeSxyLHMpe3JldHVybiByIGluIHk/T2JqZWN0LmRlZmluZVByb3BlcnR5KHkscix7dmFsdWU6cyxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOnlbcl09cyx5fWNvbnN0IGw9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIixtPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZSIpLHA9U3ltYm9sKCJyb290IiksQz1TeW1ib2woInRhc2siKTtmdW5jdGlvbiB4KHkscj0hMCl7Y29uc3Qgcz15W3BdO2lmKHMmJnMuY2hpbGRyZW5bMF0pe2NvbnN0IG49eS5zdmcsYT15LmxheWVyP3kubGF5ZXIuZGlzcGxheVJhdGlvOjE7aWYoIW4uaGFzQXR0cmlidXRlKCJkYXRhLW9yaWdpbmFsLXdpZHRoIikpe2xldCBiPW4uZ2V0QXR0cmlidXRlKCJ3aWR0aCIpO2I9Yj9PYmplY3QoYy5zaXplVG9QaXhlbCkoYik6MzAwO2xldCBJPW4uZ2V0QXR0cmlidXRlKCJoZWlnaHQiKTtJPUk/T2JqZWN0KGMuc2l6ZVRvUGl4ZWwpKEkpOjE1MCxuLmhhc0F0dHJpYnV0ZSgidmlld0JveCIpfHxuLnNldEF0dHJpYnV0ZSgidmlld0JveCIsYDAgMCAke01hdGgucm91bmQoYil9ICR7TWF0aC5yb3VuZChJKX1gKSxuLnNldEF0dHJpYnV0ZSgiZGF0YS1vcmlnaW5hbC13aWR0aCIsYiksbi5zZXRBdHRyaWJ1dGUoImRhdGEtb3JpZ2luYWwtaGVpZ2h0IixJKX1sZXQgTz15LmF0dHJpYnV0ZXMud2lkdGh8fE51bWJlcihuLmdldEF0dHJpYnV0ZSgiZGF0YS1vcmlnaW5hbC13aWR0aCIpKSxBPXkuYXR0cmlidXRlcy5oZWlnaHR8fE51bWJlcihuLmdldEF0dHJpYnV0ZSgiZGF0YS1vcmlnaW5hbC1oZWlnaHQiKSk7aWYoTyo9YSxBKj1hLHImJnkuYXR0cmlidXRlcy5mbGV4aWJsZSl7Y29uc3QgYj15LmF0dHJpYnV0ZXMuc2NhbGVbMF07aWYoTyo9YixBKj1iLG4uc2V0QXR0cmlidXRlKCJ3aWR0aCIsTyksbi5zZXRBdHRyaWJ1dGUoImhlaWdodCIsQSksTyYmQSYmeS50ZXh0dXJlSW1hZ2Upe2NvbnN0IEk9eS50ZXh0dXJlSW1hZ2Uud2lkdGgsUD15LnRleHR1cmVJbWFnZS5oZWlnaHQsRD15LmNsaWVudFNpemU7eS5hdHRyaWJ1dGVzLnRleHR1cmVSZWN0PVswLDAsTWF0aC5yb3VuZChEWzBdKkkvTyksTWF0aC5yb3VuZChEWzFdKlAvQSldfX1lbHNlIHlbQ118fChuLnNldEF0dHJpYnV0ZSgid2lkdGgiLE8pLG4uc2V0QXR0cmlidXRlKCJoZWlnaHQiLEEpLHlbQ109UHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKT0+e2RlbGV0ZSB5W0NdO2NvbnN0IGI9cy5pbm5lckhUTUwsST1uZXcgQmxvYihbYl0se3R5cGU6ImltYWdlL3N2Zyt4bWwifSksUD1VUkwuY3JlYXRlT2JqZWN0VVJMKEkpLEQ9bmV3IEltYWdlO0Qub25sb2FkPWZ1bmN0aW9uKCl7RC53aWR0aCYmRC5oZWlnaHQ/KHkuYXR0cmlidXRlc1ttXSgidGV4dHVyZSIsRCkseS5hdHRyaWJ1dGVzLmZsZXhpYmxlJiYoeS5hdHRyaWJ1dGVzLnRleHR1cmVSZWN0PW51bGwpKTp5LmF0dHJpYnV0ZXNbbV0oInRleHR1cmUiLG51bGwpfSxELnNyYz1QfSkpfX1jbGFzcyBkIGV4dGVuZHMgaS5kZWZhdWx0e2NvbnN0cnVjdG9yKHI9e30pe3R5cGVvZiByPT0ic3RyaW5nIiYmKHI9e3N2Z1RleHQ6cn0pO2xldHtzdmdUZXh0OnN9PXIsbj1mKHIsWyJzdmdUZXh0Il0pO2lmKHN1cGVyKG4pLHRoaXNbcF09ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiZGl2Iikscyl7dGhpc1twXS5pbm5lckhUTUw9cztjb25zdCBhPXRoaXNbcF0uY2hpbGRyZW5bMF07YT9hLnNldEF0dHJpYnV0ZSgieG1sbnMiLGwpOihmZXRjaChzKS50aGVuKE89Pk8udGV4dCgpKS50aGVuKE89Pnt0aGlzW3BdLmlubmVySFRNTD1PLCghdGhpcy5vYnNlcnZlcnx8dGhpcy5hdHRyaWJ1dGVzLmZsZXhpYmxlKSYmeCh0aGlzKX0pLHM9bnVsbCl9aWYoIXMpe2NvbnN0IGE9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKGwsInN2ZyIpO2Euc2V0QXR0cmlidXRlKCJ4bWxucyIsbCksdGhpc1twXS5hcHBlbmRDaGlsZChhKX1pZih0eXBlb2YgTXV0YXRpb25PYnNlcnZlcj09ImZ1bmN0aW9uIil7Y29uc3QgYT1uZXcgTXV0YXRpb25PYnNlcnZlcihPPT57eCh0aGlzLCExKX0pO2Eub2JzZXJ2ZSh0aGlzW3BdLHthdHRyaWJ1dGVzOiEwLHN1YnRyZWU6ITAsY2hhcmFjdGVyRGF0YTohMCxjaGlsZExpc3Q6ITB9KSx0aGlzLm9ic2VydmVyPWF9fWdldCBjaGlsZHJlbigpe3JldHVyblt0aGlzLnN2Z119Z2V0IGNoaWxkTm9kZXMoKXtyZXR1cm5bdGhpcy5zdmddfWdldCBzdmcoKXtyZXR1cm4gdGhpc1twXT90aGlzW3BdLmNoaWxkcmVuWzBdOm51bGx9c2V0UmVzb2x1dGlvbih7d2lkdGg6cixoZWlnaHQ6c30pe3N1cGVyLnNldFJlc29sdXRpb24oe3dpZHRoOnIsaGVpZ2h0OnN9KSx4KHRoaXMpfWRpc3BhdGNoUG9pbnRlckV2ZW50KHIpe2NvbnN0IHM9c3VwZXIuZGlzcGF0Y2hQb2ludGVyRXZlbnQocik7aWYocyYmdGhpcy5hdHRyaWJ1dGVzLnBhc3NFdmVudHMmJnR5cGVvZiBNb3VzZUV2ZW50PT0iZnVuY3Rpb24iKXtjb25zdHt4Om4seTphfT1yO2xldFtPLEFdPXRoaXMuZ2V0T2Zmc2V0UG9zaXRpb24obixhKTtjb25zdCBiPXIub3JpZ2luYWxFdmVudCxJPXRoaXMuYXR0cmlidXRlcy5hbmNob3IsUD10aGlzLmNsaWVudFNpemU7Tz0oTytJWzBdKlBbMF0pLzIsQT0oQStJWzFdKlBbMV0pLzI7Y29uc3QgRD1yLnR5cGU7aWYoRD09PWIudHlwZSl7bGV0IEw9bnVsbDtpZihiIGluc3RhbmNlb2YgTW91c2VFdmVudClMPW5ldyBNb3VzZUV2ZW50KEQse3NjcmVlblg6TyxzY3JlZW5ZOkEsY2xpZW50WDpPLGNsaWVudFk6QSxidWJibGVzOmIuYnViYmxlcyxidXR0b246Yi5idXR0b24sYnV0dG9uczpiLmJ1dHRvbnMsY2FuY2VsQnViYmxlOmIuY2FuY2VsQnViYmxlLGNhbmNlbGFibGU6Yi5jYW5jZWxhYmxlLGN1cnJlbnRUYXJnZXQ6Yi5jdXJyZW50VGFyZ2V0LGZyb21FbGVtZW50OmIuZnJvbUVsZW1lbnQscmVsYXRlZFRhcmdldDpiLnJlbGF0ZWRUYXJnZXQscmV0dXJuVmFsdWU6Yi5yZXR1cm5WYWx1ZSxzcmNFbGVtZW50OmIuc3JjRWxlbWVudCx0YXJnZXQ6Yi50YXJnZXQsdG9FbGVtZW50OmIudG9FbGVtZW50LHdoaWNoOmIud2l0Y2h9KTtlbHNlIGlmKGIgaW5zdGFuY2VvZiBUb3VjaEV2ZW50KXtsZXQgUz1udWxsO2NvbnN0IFQ9Yi5jaGFuZ2VkVG91Y2hlc3x8W2JdO2ZvcihsZXQgaj0wO2o8VC5sZW5ndGg7aisrKXtjb25zdCAkPVRbal07aWYoci5pZGVudGlmaWVyPT09JC5pZGVudGlmaWVyKXtTPSQ7YnJlYWt9fWlmKFMpe2NvbnN0IGo9bmV3IFRvdWNoKHtpZGVudGlmaWVyOlMuaWRlbnRpZmllcix0YXJnZXQ6Uy50YXJnZXQsY2xpZW50WDpPLGNsaWVudFk6QSxzY3JlZW5YOk8sc2NyZWVuWTpBLHBhZ2VYOk8scGFnZVk6QSxyYWRpdXNYOlMucmFkaXVzWCxyYWRpdXNZOlMucmFkaXVzWSxyb3RhdGlvbkFuZ2xlOlMucm90YXRpb25BbmdsZSxmb3JjZTpTLmZvcmNlfSk7TD1uZXcgVG91Y2hFdmVudChELHtjYW5jZWxhYmxlOmIuY2FuY2VsYWJsZSxidWJibGVzOmIuYnViYmxlcyxjb21wb3NlZDpiLmNvbXBvc2VkLHRvdWNoZXM6W2pdLHRhcmdldFRvdWNoZXM6W2pdLGNoYW5nZWRUb3VjaGVzOltqXX0pfX1lbHNlIEw9YjtMJiZ0aGlzLnN2Zy5kaXNwYXRjaEV2ZW50KEwpfX1yZXR1cm4gc31nZXRFbGVtZW50QnlJZChyKXtyZXR1cm4gT2JqZWN0KHYucXVlcnlTZWxlY3RvcikoYCMke3J9YCx0aGlzKX1nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKHIpe3JldHVybiBPYmplY3Qodi5xdWVyeVNlbGVjdG9yQWxsKShgLiR7cn1gLHRoaXMpfWdldEVsZW1lbnRzQnlOYW1lKHIpe3JldHVybiBPYmplY3Qodi5xdWVyeVNlbGVjdG9yQWxsKShgW25hbWU9IiR7cn0iXWAsdGhpcyl9Z2V0RWxlbWVudHNCeVRhZ05hbWUocil7cmV0dXJuIE9iamVjdCh2LnF1ZXJ5U2VsZWN0b3JBbGwpKHIsdGhpcyl9cXVlcnlTZWxlY3RvcihyKXtyZXR1cm4gT2JqZWN0KHYucXVlcnlTZWxlY3Rvcikocix0aGlzKX1xdWVyeVNlbGVjdG9yQWxsKHIpe3JldHVybiBPYmplY3Qodi5xdWVyeVNlbGVjdG9yQWxsKShyLHRoaXMpfW9uUHJvcGVydHlDaGFuZ2UocixzLG4pe3N1cGVyLm9uUHJvcGVydHlDaGFuZ2UocixzLG4pLHI9PT0iZmxleGlibGUiJiZ4KHRoaXMpLHRoaXMuYXR0cmlidXRlcy5mbGV4aWJsZSYmKHI9PT0id2lkdGgifHxyPT09ImhlaWdodCJ8fHI9PT0ic2NhbGUifHxyPT09InRyYW5zZm9ybSIpJiZ4KHRoaXMpfX1FKGQsIkF0dHIiLG8uZGVmYXVsdCksZy5kZWZhdWx0LnJlZ2lzdGVyTm9kZShkLCJzcHJpdGVzdmciKX0sZnVuY3Rpb24oUixlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gY30pO3ZhciBpPXQoMjI1KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3Qgbz1TeW1ib2wuZm9yKCJzcHJpdGVqc19nZXRBdHRyaWJ1dGUiKSxnPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZSIpLHY9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlRGVmYXVsdCIpO2NsYXNzIGMgZXh0ZW5kcyBpLmRlZmF1bHR7Y29uc3RydWN0b3IoaCl7c3VwZXIoaCksdGhpc1t2XSh7cGFzc0V2ZW50czohMSxmbGV4aWJsZTohMX0pfWdldCB0ZXh0dXJlKCl7cmV0dXJuIHRoaXNbb10oInRleHR1cmUiKX1zZXQgdGV4dHVyZShoKXt9Z2V0IHBhc3NFdmVudHMoKXtyZXR1cm4gdGhpc1tvXSgicGFzc0V2ZW50cyIpfXNldCBwYXNzRXZlbnRzKGgpe3JldHVybiB0aGlzW2ddKCJwYXNzRXZlbnRzIixoKX1nZXQgZmxleGlibGUoKXtyZXR1cm4gdGhpc1tvXSgiZmxleGlibGUiKX1zZXQgZmxleGlibGUoaCl7cmV0dXJuIHRoaXNbZ10oImZsZXhpYmxlIixoKX19fSxmdW5jdGlvbihSLGUsdCl7dC5yKGUpO3ZhciBpPXQoMTIpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBvKGgsRSl7dmFyIGw9T2JqZWN0LmtleXMoaCk7aWYoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyl7dmFyIG09T2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhoKTtFJiYobT1tLmZpbHRlcihmdW5jdGlvbihwKXtyZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihoLHApLmVudW1lcmFibGV9KSksbC5wdXNoLmFwcGx5KGwsbSl9cmV0dXJuIGx9ZnVuY3Rpb24gZyhoKXtmb3IodmFyIEU9MTtFPGFyZ3VtZW50cy5sZW5ndGg7RSsrKXt2YXIgbD1hcmd1bWVudHNbRV0hPW51bGw/YXJndW1lbnRzW0VdOnt9O0UlMj9vKE9iamVjdChsKSwhMCkuZm9yRWFjaChmdW5jdGlvbihtKXt2KGgsbSxsW21dKX0pOk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzP09iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGgsT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMobCkpOm8oT2JqZWN0KGwpKS5mb3JFYWNoKGZ1bmN0aW9uKG0pe09iamVjdC5kZWZpbmVQcm9wZXJ0eShoLG0sT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihsLG0pKX0pfXJldHVybiBofWZ1bmN0aW9uIHYoaCxFLGwpe3JldHVybiBFIGluIGg/T2JqZWN0LmRlZmluZVByb3BlcnR5KGgsRSx7dmFsdWU6bCxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOmhbRV09bCxofWNvbnN0IGM9U3ltYm9sKCJpbml0ZWQiKTtsZXQgZj1udWxsO3R5cGVvZiBXb3JrZXI9PSJmdW5jdGlvbiImJihmPWNsYXNzIGV4dGVuZHMgV29ya2Vye2NvbnN0cnVjdG9yKGgpe2lmKGgud29ya2VyPT09ITAmJihoLndvcmtlcj1gLi8ke2guaWR9Lndvcmtlci5qc2ApLHN1cGVyKGgud29ya2VyKSx0aGlzLm9wdGlvbnM9aCwhaC5jYW52YXMpe2NvbnN0e3dpZHRoOkUsaGVpZ2h0Omx9PXRoaXMuZ2V0UmVzb2x1dGlvbigpLG09aS5FTlYuY3JlYXRlQ2FudmFzKEUsbCx7b2Zmc2NyZWVuOiExfSk7bS5zdHlsZSYmKG0uc3R5bGUucG9zaXRpb249ImFic29sdXRlIiksbS5kYXRhc2V0JiYobS5kYXRhc2V0LmxheWVySWQ9aC5pZCksaC5jYW52YXM9bX10aGlzLmNhbnZhcz1oLmNhbnZhc31nZXQgaWQoKXtyZXR1cm4gdGhpcy5vcHRpb25zLmlkfXNldFJlc29sdXRpb24oe3dpZHRoOmgsaGVpZ2h0OkV9KXtpZih0aGlzW2NdKXRoaXMucG9zdE1lc3NhZ2Uoe3R5cGU6InJlc29sdXRpb25fY2hhbmdlIix3aWR0aDpoLGhlaWdodDpFfSk7ZWxzZXt0aGlzLmNhbnZhcy53aWR0aD1oLHRoaXMuY2FudmFzLmhlaWdodD1FO2NvbnN0IGw9dGhpcy5vcHRpb25zLG09bC5jYW52YXMudHJhbnNmZXJDb250cm9sVG9PZmZzY3JlZW4oKSxwPWcoe30sbCk7ZGVsZXRlIHAuY29udGFpbmVyLHAuY2FudmFzPW0sdGhpcy5wb3N0TWVzc2FnZSh7dHlwZToiY3JlYXRlIixvcHRpb25zOnB9LFttXSksdGhpc1tjXT0hMH19Z2V0UmVzb2x1dGlvbigpe2lmKHRoaXMuY2FudmFzKXtjb25zdHt3aWR0aDpoLGhlaWdodDpFfT10aGlzLmNhbnZhcztyZXR1cm57d2lkdGg6aCxoZWlnaHQ6RX19cmV0dXJue3dpZHRoOjMwMCxoZWlnaHQ6MTUwfX1yZW1vdmUoKXtyZXR1cm4gdGhpcy5wYXJlbnQmJnRoaXMucGFyZW50LnJlbW92ZUNoaWxkPyh0aGlzLnBhcmVudC5yZW1vdmVDaGlsZCh0aGlzKSwhMCk6ITF9Y29ubmVjdChoLEUpe09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJwYXJlbnQiLHt2YWx1ZTpoLHdyaXRhYmxlOiExLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ6T3JkZXIiLHt2YWx1ZTpFLHdyaXRhYmxlOiExLGNvbmZpZ3VyYWJsZTohMH0pfWRpc2Nvbm5lY3QoKXtkZWxldGUgdGhpcy5wYXJlbnQsZGVsZXRlIHRoaXMuek9yZGVyfWRpc3BhdGNoUG9pbnRlckV2ZW50KGgpe3RoaXMucG9zdE1lc3NhZ2Uoe3R5cGU6ImV2ZW50IixldmVudDp7Y2FuY2VsQnViYmxlOmguY2FuY2VsQnViYmxlLGJ1YmJsZXM6aC5idWJibGVzLGRldGFpbDpoLmRldGFpbCxpZGVudGlmaWVyOmguaWRlbnRpZmllcixsYXllclg6aC5sYXllclgsbGF5ZXJZOmgubGF5ZXJZLG9yaWdpbmFsWDpoLm9yaWdpbmFsWCxvcmlnaW5hbFk6aC5vcmlnaW5hbFksdHlwZTpoLnR5cGUseDpoLngseTpoLnl9fSl9fSksZS5kZWZhdWx0PWZ9LGZ1bmN0aW9uKFIsZSx0KXt0LnIoZSksKGZ1bmN0aW9uKGkpe3QuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBPfSk7dmFyIG89dCgxMiksZz10KDY4KSx2PXQoNzApLGM9dCgyODYpLGY9dCgyODkpLGg9dCgyNTApLEU9dCgyOTEpLGw9dCgyMTQpLG09dCgyMTgpLHA9dCgyMTMpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCBDPVN5bWJvbCgiZW50ZXJlZFRhcmdldHMiKTtmdW5jdGlvbiB4KEEpe3JldHVybiBBLmlkPUEuaWR8fGBfbGF5ZXIke01hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIsMTIpfWAsQS5kYXRhc2V0fHwoQS5kYXRhc2V0PXt9KSxBLmRhdGFzZXQubGF5ZXJJZD1BLmlkLEEuY29ubmVjdD0oYixJKT0+e0EucGFyZW50PWIsT2JqZWN0LmRlZmluZVByb3BlcnR5KEEsInpPcmRlciIse3ZhbHVlOkksd3JpdGFibGU6ITEsY29uZmlndXJhYmxlOiEwfSl9LEEuZGlzY29ubmVjdD1iPT57ZGVsZXRlIEEuek9yZGVyfSxBLmNhbnZhcz1BLEEuZ2V0UmVzb2x1dGlvbj0oKT0+KHt3aWR0aDowLGhlaWdodDowfSksQS5zZXRSZXNvbHV0aW9uPSgpPT4hMSxBLm9wdGlvbnM9e2hhbmRsZUV2ZW50OiExfSxBfWZ1bmN0aW9uIGQoQSxiKXtjb25zdCBJPUEuY2hpbGRyZW47bGV0IFA9bnVsbDtmb3IobGV0IEQ9MDtEPEkubGVuZ3RoO0QrKyl7Y29uc3QgTD1JW0RdO2lmKChiPT09THx8UCE9bnVsbCkmJihQPUwpLFAmJlAhPT1iJiYhUC5vZmZzY3JlZW4pcmV0dXJuIFAuY2FudmFzfXJldHVybiBudWxsfWZ1bmN0aW9uIHkoQSxiKXtjb25zdFtJLFBdPUEucmVuZGVyT2Zmc2V0LHt3aWR0aDpELGhlaWdodDpMfT1BLmdldFJlc29sdXRpb24oKSxTPUEuZGlzcGxheVJhdGlvO0EucmVuZGVyZXIuZHJhd0ltYWdlKGIuY2FudmFzLC1JL1MsLVAvUyxEL1MsTC9TKX1jb25zdCByPXt9O2Z1bmN0aW9uIHMoQSl7Y29uc3QgYj1bIm1vdXNlZG93biIsIm1vdXNldXAiLCJtb3VzZW1vdmUiLCJtb3VzZXdoZWVsIiwid2hlZWwiLCJ0b3VjaHN0YXJ0IiwidG91Y2hlbmQiLCJ0b3VjaG1vdmUiLCJ0b3VjaGNhbmNlbCIsImNsaWNrIiwiZGJsY2xpY2siLCJsb25ncHJlc3MiLCJ0YXAiLCJjb250ZXh0bWVudSJdLEk9QS5jb250YWluZXI7SS5hZGRFdmVudExpc3RlbmVyKCJtb3VzZWxlYXZlIixQPT57Y29uc3QgRD1BW0NdO2lmKEQuc2l6ZSl7Y29uc3QgTD1uZXcgbC5kZWZhdWx0KCJtb3VzZWxlYXZlIik7TC5zZXRPcmlnaW5hbEV2ZW50KFApLFsuLi5EXS5mb3JFYWNoKFM9PntTLmRpc3BhdGNoRXZlbnQoTCl9KSxBW0NdLmNsZWFyKCl9fSx7cGFzc2l2ZTohMH0pLGIuZm9yRWFjaChQPT57SS5hZGRFdmVudExpc3RlbmVyKFAsRD0+e2NvbnN0e2xlZnQ6TCx0b3A6UyxkaXNwbGF5UmF0aW86VH09QS5vcHRpb25zLGo9QS5vcmRlcmVkQ2hpbGRyZW47T2JqZWN0KEUuZGVmYXVsdCkoRCx7b2Zmc2V0TGVmdDpMLG9mZnNldFRvcDpTLGRpc3BsYXlSYXRpbzpUfSkuZm9yRWFjaCh3PT57Y29uc3QgSj13LmlkZW50aWZpZXI7aWYody50eXBlPT09InRvdWNobW92ZSJ8fHcudHlwZT09PSJ0b3VjaGVuZCIpe2NvbnN0IFc9cltKXTtXJiZXLmRpc3BhdGNoRXZlbnQodyksdy50eXBlPT09InRvdWNoZW5kIiYmZGVsZXRlIHJbSl19ZWxzZXtmb3IobGV0IFc9ai5sZW5ndGgtMTtXPj0wO1ctLSl7Y29uc3QgSz1qW1ddO2lmKEsub3B0aW9ucy5oYW5kbGVFdmVudCE9PSExKXtpZihLLmRpc3BhdGNoUG9pbnRlckV2ZW50KHcpJiZ3LnRhcmdldCE9PUspYnJlYWs7dy5jYW5jZWxCdWJibGU9ITF9fWlmKHcudGFyZ2V0PT09alswXSlmb3IobGV0IFc9ai5sZW5ndGgtMTtXPj0wO1ctLSl7Y29uc3QgSz1qW1ddO2lmKEsub3B0aW9ucy5oYW5kbGVFdmVudCE9PSExKXt3LnRhcmdldD1LO2JyZWFrfX19Y29uc3QgcT13LnRhcmdldDtpZih3LnR5cGU9PT0idG91Y2hzdGFydCImJihyW0pdPXcudGFyZ2V0KSx3LnR5cGU9PT0ibW91c2Vtb3ZlIil7Y29uc3QgVz1BW0NdO2xldCBLO2lmKHEpe2NvbnN0IF89cS5hbmNlc3RvcnN8fFtdO0s9bmV3IFNldChbcSwuLi5fXSl9ZWxzZSBLPW5ldyBTZXQ7Y29uc3QgUT1PYmplY3QuZW50cmllcyhEKTtpZighVy5oYXMocSkmJnEpe2NvbnN0IF89bmV3IGwuZGVmYXVsdCgibW91c2VlbnRlciIpO18uc2V0T3JpZ2luYWxFdmVudChEKSxRLmZvckVhY2goKFtrLGN0XSk9PntfW2tdPWN0fSksVy5hZGQocSkscS5kaXNwYXRjaEV2ZW50KF8pO2NvbnN0IHN0PXEuYW5jZXN0b3JzO3N0JiZzdC5mb3JFYWNoKGs9PntrIGluc3RhbmNlb2Ygdi5kZWZhdWx0JiYhVy5oYXMoaykmJihXLmFkZChrKSxrLmRpc3BhdGNoRXZlbnQoXykpfSl9Y29uc3QgdHQ9bmV3IGwuZGVmYXVsdCgibW91c2VsZWF2ZSIpO3R0LnNldE9yaWdpbmFsRXZlbnQoRCksUS5mb3JFYWNoKChbXyxzdF0pPT57dHRbX109c3R9KSxbLi4uV10uZm9yRWFjaChfPT57Sy5oYXMoXyl8fChXLmRlbGV0ZShfKSxfLmRpc3BhdGNoRXZlbnQodHQpKX0pfX0pfSx7cGFzc2l2ZTpQIT09ImNvbnRleHRtZW51In0pfSl9ZnVuY3Rpb24gbihBLGIpe2lmKGImJmIuc3R5bGUpe2xldHt3aWR0aDpJLGhlaWdodDpQLG1vZGU6RCxjb250YWluZXI6TH09QTtjb25zdHtjbGllbnRXaWR0aDpTLGNsaWVudEhlaWdodDpUfT1MO0k9SXx8UyxQPVB8fFQsRD09PSJzdGF0aWMiPyhiLnN0eWxlLndpZHRoPWAke0l9cHhgLGIuc3R5bGUuaGVpZ2h0PWAke1B9cHhgKTooYi5zdHlsZS50b3A9IjAiLGIuc3R5bGUubGVmdD0iMCIsYi5zdHlsZS53aWR0aD1gJHtTfXB4YCxiLnN0eWxlLmhlaWdodD1gJHtUfXB4YCxiLnN0eWxlLnRyYW5zZm9ybT0iIixiLnN0eWxlLndlYmtpdFRyYW5zZm9ybT0iIil9fWNvbnN0IGE9U3ltYm9sKCJvZmZzY3JlZW5MYXllckNvdW50Iik7Y2xhc3MgTyBleHRlbmRzIGguZGVmYXVsdHtjb25zdHJ1Y3RvcihiPXt9KXtpZihzdXBlcigpLCFiLmNvbnRhaW5lcilpZih0eXBlb2Ygby5FTlYuQ29udGFpbmVyPT0iZnVuY3Rpb24iKWIuY29udGFpbmVyPW5ldyBvLkVOVi5Db250YWluZXIoYi53aWR0aHx8MzAwLGIuaGVpZ2h0fHwxNTApO2Vsc2UgdGhyb3cgbmV3IEVycm9yKCJObyBjb250YWluZXIgc3BlY2lmaWVkLiIpO2lmKHRoaXMuY29udGFpbmVyPWIuY29udGFpbmVyLHRoaXMuY29udGFpbmVyLnN0eWxlJiYodGhpcy5jb250YWluZXIuc3R5bGUub3ZlcmZsb3d8fCh0aGlzLmNvbnRhaW5lci5zdHlsZS5vdmVyZmxvdz0iaGlkZGVuIiksdGhpcy5jb250YWluZXIuc3R5bGUucG9zaXRpb258fCh0aGlzLmNvbnRhaW5lci5zdHlsZS5wb3NpdGlvbj0icmVsYXRpdmUiKSksdGhpcy5vcHRpb25zPWIsYi5kaXNwbGF5UmF0aW89Yi5kaXNwbGF5UmF0aW98fDEsYi5tb2RlPWIubW9kZXx8InNjYWxlIixiLmxlZnQ9MCxiLnRvcD0wLGIuYXV0b1Jlc2l6ZT1iLmF1dG9SZXNpemUhPT0hMSxiLmF1dG9SZXNpemUpe2xldCBJO2lmKHR5cGVvZiBnbG9iYWxUaGlzPCJ1Ij9JPWdsb2JhbFRoaXM6ST10eXBlb2Ygd2luZG93PCJ1Ij93aW5kb3c6aSxJLmFkZEV2ZW50TGlzdGVuZXIpe2NvbnN0IFA9dGhpcztJLmFkZEV2ZW50TGlzdGVuZXIoInJlc2l6ZSIsZnVuY3Rpb24gRCgpe3R5cGVvZiBkb2N1bWVudDwidSImJmRvY3VtZW50LmNvbnRhaW5zKFAuY29udGFpbmVyKT9QLnJlc2l6ZSgpOkkucmVtb3ZlRXZlbnRMaXN0ZW5lcigicmVzaXplIixEKX0pfX10aGlzW0NdPW5ldyBTZXQsdGhpcy5zZXRSZXNvbHV0aW9uKGIpLHModGhpcyksdGhpc1thXT0wfWdldCBoYXNPZmZzY3JlZW5DYW52YXMoKXtyZXR1cm4gdGhpc1thXT4wfXNldCBkaXNwbGF5UmF0aW8oYil7dGhpcy5vcHRpb25zLmRpc3BsYXlSYXRpbyE9PWImJih0aGlzLm9wdGlvbnMuZGlzcGxheVJhdGlvPWIsdGhpcy5yZXNpemUoKSl9Z2V0IGRpc3BsYXlSYXRpbygpe3JldHVybiB0aGlzLm9wdGlvbnMuZGlzcGxheVJhdGlvfXNldCBoZWlnaHQoYil7dGhpcy5vcHRpb25zLmhlaWdodCE9PWImJih0aGlzLm9wdGlvbnMuaGVpZ2h0PWIsdGhpcy5yZXNpemUoKSl9Z2V0IGhlaWdodCgpe3JldHVybiB0aGlzLm9wdGlvbnMuaGVpZ2h0fXNldCBtb2RlKGIpe3RoaXMub3B0aW9ucy5tb2RlIT09YiYmKHRoaXMub3B0aW9ucy5tb2RlPWIsdGhpcy5yZXNpemUoKSl9Z2V0IG1vZGUoKXtyZXR1cm4gdGhpcy5vcHRpb25zLm1vZGV9c2V0IHdpZHRoKGIpe3RoaXMub3B0aW9ucy53aWR0aCE9PWImJih0aGlzLm9wdGlvbnMud2lkdGg9Yix0aGlzLnJlc2l6ZSgpKX1nZXQgd2lkdGgoKXtyZXR1cm4gdGhpcy5vcHRpb25zLndpZHRofWFwcGVuZENoaWxkKGIpeyEoYiBpbnN0YW5jZW9mIGMuZGVmYXVsdCkmJiEoYiBpbnN0YW5jZW9mIGYuZGVmYXVsdCkmJngoYik7Y29uc3QgST1zdXBlci5hcHBlbmRDaGlsZChiKSxQPWIuY2FudmFzO3JldHVybiBiLm9mZnNjcmVlbj90aGlzW2FdKys6dGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQoUCksbih0aGlzLm9wdGlvbnMsUCksYi5zZXRSZXNvbHV0aW9uKHRoaXMuZ2V0UmVzb2x1dGlvbigpKSxJfWZvcmNlVXBkYXRlKCl7dGhpcy5oYXNPZmZzY3JlZW5DYW52YXMmJiF0aGlzLl9yZXF1ZXN0SUQmJih0aGlzLl9yZXF1ZXN0SUQ9T2JqZWN0KGcucmVxdWVzdEFuaW1hdGlvbkZyYW1lKSgoKT0+e2RlbGV0ZSB0aGlzLl9yZXF1ZXN0SUQsdGhpcy5yZW5kZXIoKX0pKX1pbnNlcnRCZWZvcmUoYixJKXshKGIgaW5zdGFuY2VvZiBjLmRlZmF1bHQpJiYhKGIgaW5zdGFuY2VvZiBmLmRlZmF1bHQpJiZ4KGIpO2NvbnN0IFA9c3VwZXIuaW5zZXJ0QmVmb3JlKGIsSSksRD1iLmNhbnZhcztpZighYi5vZmZzY3JlZW4pe2NvbnN0IEw9ZCh0aGlzLGIpO3RoaXMuY29udGFpbmVyLmluc2VydEJlZm9yZShELEwpfXJldHVybiBuKHRoaXMub3B0aW9ucyxEKSxiLnNldFJlc29sdXRpb24odGhpcy5nZXRSZXNvbHV0aW9uKCkpLFB9bGF5ZXIoYj0iZGVmYXVsdCIsST17fSl7ST1PYmplY3QuYXNzaWduKHt9LHRoaXMub3B0aW9ucyxJKSxJLmlkPWI7Y29uc3QgUD10aGlzLm9yZGVyZWRDaGlsZHJlbjtmb3IobGV0IFM9MDtTPFAubGVuZ3RoO1MrKylpZihQW1NdLmlkPT09YilyZXR1cm4gUFtTXTtjb25zdCBEPUkud29ya2VyO2xldCBMO3JldHVybiBEP0w9bmV3IGYuZGVmYXVsdChJKTpMPW5ldyBjLmRlZmF1bHQoSSksdGhpcy5hcHBlbmRDaGlsZChMKSxMfWFzeW5jIHByZWxvYWQoLi4uYil7Y29uc3QgST1bXSxQPVtdLEQ9W107Zm9yKGxldCBMPTA7TDxiLmxlbmd0aDtMKyspe2NvbnN0IFM9YltMXTtsZXQgVDtpZih0eXBlb2YgUz09InN0cmluZyIpVD1PYmplY3QobS5sb2FkVGV4dHVyZSkoUyk7ZWxzZSBpZihBcnJheS5pc0FycmF5KFMpKVQ9T2JqZWN0KG0ubG9hZEZyYW1lcykoLi4uUyk7ZWxzZXtjb25zdHtpZDpqLHNyYzokfT1TO1Q9T2JqZWN0KG0ubG9hZFRleHR1cmUpKCQsail9VCBpbnN0YW5jZW9mIFByb21pc2V8fChUPVByb21pc2UucmVzb2x2ZShUKSksUC5wdXNoKFQudGhlbihqPT57SS5wdXNoKGopLERbTF09ajtjb25zdCAkPW5ldyBsLmRlZmF1bHQoe3R5cGU6InByZWxvYWQiLGRldGFpbDp7Y3VycmVudDpqLGxvYWRlZDpJLHJlc291cmNlczpifX0pO3RoaXMuZGlzcGF0Y2hFdmVudCgkKX0pKX1yZXR1cm4gYXdhaXQgUHJvbWlzZS5hbGwoUCksRH1yZW1vdmVDaGlsZChiKXtjb25zdCBJPXN1cGVyLnJlbW92ZUNoaWxkKGIpO2lmKEkpe2IuX3ByZXBhcmVSZW5kZXJGaW5pc2hlZCYmYi5fcHJlcGFyZVJlbmRlckZpbmlzaGVkKCk7Y29uc3QgUD1iLmNhbnZhcztQJiZQLnJlbW92ZSYmUC5yZW1vdmUoKSxiLm9mZnNjcmVlbiYmdGhpc1thXS0tfXJldHVybiBJfXJlbmRlcigpe2NvbnN0IGI9dGhpcy5vcmRlcmVkQ2hpbGRyZW47bGV0IEk9bnVsbDtjb25zdCBQPVtdO2ZvcihsZXQgRD0wO0Q8Yi5sZW5ndGg7RCsrKXtjb25zdCBMPWJbRF0sUz1QLmxlbmd0aD4wO2lmKEwgaW5zdGFuY2VvZiBjLmRlZmF1bHQmJiFMLm9mZnNjcmVlbilpZighTC5hdXRvUmVuZGVyKVMmJihjb25zb2xlLndhcm4oIlNvbWUgb2Zmc2NyZWVuIGNhbnZhcyB3aWxsIG5vdCBiZSByZW5kZXJlZC4iKSxQLmxlbmd0aD0wKTtlbHNlIGlmKEk9TCxTKXtMLnJlbmRlcmVyLmNsZWFyKCk7Zm9yKGxldCBUPTA7VDxQLmxlbmd0aDtUKyspe2NvbnN0IGo9UFtUXTtqLnJlbmRlcigpLHkoTCxqKX1QLmxlbmd0aD0wLEwucmVuZGVyKHtjbGVhcjohMX0pfWVsc2UgTC5wcmVwYXJlUmVuZGVyJiZMLnJlbmRlcigpO2Vsc2UgTC5vZmZzY3JlZW4/ST8oTC5wcmVwYXJlUmVuZGVyJiZMLnJlbmRlcigpLHkoSSxMKSk6UC5wdXNoKEwpOkwgaW5zdGFuY2VvZiBmLmRlZmF1bHQmJlMmJihjb25zb2xlLndhcm4oIlNvbWUgb2Zmc2NyZWVuIGNhbnZhcyB3aWxsIG5vdCBiZSByZW5kZXJlZC4iKSxQLmxlbmd0aD0wKX19cmVwbGFjZUNoaWxkKGIsSSl7Y29uc3QgUD1zdXBlci5yZXBsYWNlQ2hpbGQoYixJKTtJLmNhbnZhcy5yZW1vdmUmJkkuY2FudmFzLnJlbW92ZSgpLEkub2Zmc2NyZWVuJiZ0aGlzW2FdLS07Y29uc3QgRD1iLmNhbnZhcztpZighYi5vZmZzY3JlZW4pe2NvbnN0IEw9ZCh0aGlzLGIpO3RoaXMuY29udGFpbmVyLmluc2VydEJlZm9yZShELEwpfXJldHVybiBuKHRoaXMub3B0aW9ucyxEKSxiLnNldFJlc29sdXRpb24odGhpcy5nZXRSZXNvbHV0aW9uKCkpLFB9cmVzaXplKCl7Y29uc3QgYj10aGlzLm9wdGlvbnM7dGhpcy5jaGlsZHJlbi5mb3JFYWNoKEk9PntuKGIsSS5jYW52YXMpfSksdGhpcy5zZXRSZXNvbHV0aW9uKGIpLHRoaXMuZGlzcGF0Y2hFdmVudCh7dHlwZToicmVzaXplIn0pfXNldFJlc29sdXRpb24oe3dpZHRoOmIsaGVpZ2h0Okl9PXt9KXtjb25zdCBQPXRoaXMuY29udGFpbmVyLHtjbGllbnRXaWR0aDpELGNsaWVudEhlaWdodDpMfT1QOyhiPT1udWxsfHxJPT1udWxsKSYmKGI9Yj8/RCxJPUk/P0wpO2NvbnN0e21vZGU6UyxkaXNwbGF5UmF0aW86VH09dGhpcy5vcHRpb25zO2lmKGIqPVQsSSo9VCx0aGlzLm9wdGlvbnMubGVmdD0wLHRoaXMub3B0aW9ucy50b3A9MCxTPT09InN0aWNreUhlaWdodCJ8fFM9PT0ic3RpY2t5TGVmdCJ8fFM9PT0ic3RpY2t5UmlnaHQiKXtjb25zdCBqPWI7Yj1EKkkvTCxTPT09InN0aWNreUhlaWdodCImJih0aGlzLm9wdGlvbnMubGVmdD0uNSooYi1qKSksUz09PSJzdGlja3lSaWdodCImJih0aGlzLm9wdGlvbnMubGVmdD1iLWopfWVsc2UgaWYoUz09PSJzdGlja3lXaWR0aCJ8fFM9PT0ic3RpY2t5VG9wInx8Uz09PSJzdGlja3lCb3R0b20iKXtjb25zdCBqPUk7ST1MKmIvRCxTPT09InN0aWNreVdpZHRoIiYmKHRoaXMub3B0aW9ucy50b3A9LjUqKEktaikpLFM9PT0ic3RpY2t5Qm90dG9tIiYmKHRoaXMub3B0aW9ucy50b3A9SS1qKX1zdXBlci5zZXRSZXNvbHV0aW9uKHt3aWR0aDpiLGhlaWdodDpJfSl9c25hcHNob3Qoe29mZnNjcmVlbjpiPSExLGxheWVyczpJfT17fSl7Y29uc3QgUD1iPyJzbmFwc2hvdE9mZlNjcmVlbkNhbnZhcyI6InNuYXBzaG90Q2FudmFzIix7d2lkdGg6RCxoZWlnaHQ6TH09dGhpcy5nZXRSZXNvbHV0aW9uKCk7dGhpc1tQXT10aGlzW1BdfHxvLkVOVi5jcmVhdGVDYW52YXMoRCxMLHtvZmZzY3JlZW46Yn0pO2NvbnN0IFM9dGhpc1tQXS5nZXRDb250ZXh0KCIyZCIpO0k9SXx8dGhpcy5vcmRlcmVkQ2hpbGRyZW4sdGhpc1tQXS53aWR0aD1ELHRoaXNbUF0uaGVpZ2h0PUw7Zm9yKGxldCBUPTA7VDxJLmxlbmd0aDtUKyspe2NvbnN0IGo9SVtUXTtpZighai5vcHRpb25zLmlnbm9yZVNuYXBzaG90KXtqLnJlbmRlciYmai5yZW5kZXIoKTtjb25zdCAkPWouY2FudmFzOyQmJiQhPT1qJiZTLmRyYXdJbWFnZSgkLDAsMCxELEwpfX1yZXR1cm4gdGhpc1tQXX19dHlwZW9mIGRvY3VtZW50PCJ1IiYmKE8ucHJvdG90eXBlLmxheWVyM2Q9ZnVuY3Rpb24oQSxiPXt9KXtjb25zdCBJPWIudXJsfHwiaHR0cHM6Ly91bnBrZy5jb20vc3ByaXRlLWV4dGVuZC0zZC9kaXN0L3Nwcml0ZS1leHRlbmQtM2QubWluLmpzIjtyZXR1cm4gbmV3IFByb21pc2UoKFAsRCk9Pntjb25zdCBMPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoInNjcmlwdCIpO0wuYXN5bmM9ITEsTC5zcmM9SSxMLm9ubG9hZD0oKT0+e3RyeXtQKHRoaXMubGF5ZXIzZChBLGIpKX1jYXRjaChTKXtEKFMpfX0sZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmFwcGVuZENoaWxkKEwpfSl9KSxwLmRlZmF1bHQucmVnaXN0ZXJOb2RlKE8sInNjZW5lIil9KS5jYWxsKHRoaXMsdCgyMikpfSxmdW5jdGlvbihSLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBvfSk7dmFyIGk9dCgyMTQpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBvKGcse29mZnNldFRvcDp2PTAsb2Zmc2V0TGVmdDpjPTAsZGlzcGxheVJhdGlvOmY9MX09e30pe2xldCBoLEU7Y29uc3QgbD1bXSx7bGVmdDptLHRvcDpwLHdpZHRoOkMsaGVpZ2h0Onh9PWcudGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLGQ9Zy50YXJnZXQud2lkdGgseT1nLnRhcmdldC5oZWlnaHQscj1nLmNoYW5nZWRUb3VjaGVzfHxbZ107Zm9yKGxldCBuPTA7bjxyLmxlbmd0aDtuKyspe2NvbnN0IGE9cltuXSxPPWEuaWRlbnRpZmllcix7Y2xpZW50WDpBLGNsaWVudFk6Yn09YTtBIT1udWxsJiZiIT1udWxsJiZsLnB1c2goe3g6TWF0aC5yb3VuZCgoQXwwKS1tKSx5Ok1hdGgucm91bmQoKGJ8MCktcCksaWRlbnRpZmllcjpPfSl9bC5sZW5ndGg8PTAmJmwucHVzaCh7eDpoLHk6RX0pO2NvbnN0IHM9W107cmV0dXJuIGwuZm9yRWFjaChuPT57bi54IT1udWxsJiZuLnkhPW51bGwmJihoPShuLngqZC9DLWMpL2YsRT0obi55KnkveC12KS9mKTtjb25zdCBhPW5ldyBpLmRlZmF1bHQoZyk7T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoYSx7bGF5ZXJYOnt2YWx1ZTpoLGNvbmZpZ3VyYWJsZTohMH0sbGF5ZXJZOnt2YWx1ZTpFLGNvbmZpZ3VyYWJsZTohMH0sb3JpZ2luYWxYOnt2YWx1ZTpuLnh9LG9yaWdpbmFsWTp7dmFsdWU6bi55fSx4Ont2YWx1ZTpoLGNvbmZpZ3VyYWJsZTohMH0seTp7dmFsdWU6RSxjb25maWd1cmFibGU6ITB9LGlkZW50aWZpZXI6e3ZhbHVlOm4uaWRlbnRpZmllcn19KSxzLnB1c2goYSl9KSxzfX1dKTtQdC52ZXJzaW9uLFB0LkFyYyxQdC5CbG9jayxQdC5DbG91ZCxQdC5Db2xvcixQdC5FbGxpcHNlLFB0LkdyYWRpZW50O2NvbnN0IHJlPVB0Lkdyb3VwO1B0LkxhYmVsLFB0LkxheWVyLFB0LkxheWVyV29ya2VyLFB0Lk5vZGUsUHQuUGFyYWxsZWw7Y29uc3QgbmU9UHQuUGF0aDtQdC5Qb2x5bGluZTtjb25zdCB1ZT1QdC5SZWN0O1B0LlJlZ3VsYXIsUHQuUmluZztjb25zdCBwZT1QdC5TY2VuZTtQdC5TcHJpdGUsUHQuU3ByaXRlU3ZnLFB0LlN0YXIsUHQuVHJpYW5nbGUsUHQuaGVscGVycyxQdC5jcmVhdGVFbGVtZW50LFB0LmlzU3ByaXRlTm9kZSxQdC5yZWdpc3Rlck5vZGUsUHQucmVxdWVzdEFuaW1hdGlvbkZyYW1lLFB0LmNhbmNlbEFuaW1hdGlvbkZyYW1lLFB0LkVOVjtjb25zdCB4ZT17bGluZWFyOlI9PlIsZWFzZUluUXVhZDpSPT5SKlIsZWFzZU91dFF1YWQ6Uj0+UiooMi1SKSxlYXNlSW5PdXRRdWFkOlI9PlI8LjU/MipSKlI6LTErKDQtMipSKSpSLGVhc2VJbkN1YmljOlI9PlIqUipSLGVhc2VPdXRDdWJpYzpSPT4tLVIqUipSKzEsZWFzZUluT3V0Q3ViaWM6Uj0+UjwuNT80KlIqUipSOihSLTEpKigyKlItMikqKDIqUi0yKSsxLGVhc2VJblF1YXJ0OlI9PlIqUipSKlIsZWFzZU91dFF1YXJ0OlI9PjEtIC0tUipSKlIqUixlYXNlSW5PdXRRdWFydDpSPT5SPC41PzgqUipSKlIqUjoxLTgqLS1SKlIqUipSLGVhc2VJblF1aW50OlI9PlIqUipSKlIqUixlYXNlT3V0UXVpbnQ6Uj0+MSstLVIqUipSKlIqUixlYXNlSW5PdXRRdWludDpSPT5SPC41PzE2KlIqUipSKlIqUjoxKzE2Ki0tUipSKlIqUipSLGVhc2VJblNpbmU6Uj0+MS1NYXRoLmNvcyhSKk1hdGguUEkvMiksZWFzZU91dFNpbmU6Uj0+TWF0aC5zaW4oUipNYXRoLlBJLzIpLGVhc2VJbk91dFNpbmU6Uj0+LShNYXRoLmNvcyhNYXRoLlBJKlIpLTEpLzIsZWFzZUluRXhwbzpSPT5SPD0wPzA6TWF0aC5wb3coMiwxMCpSLTEwKSxlYXNlT3V0RXhwbzpSPT5SPj0xPzE6MS1NYXRoLnBvdygyLC0xMCpSKSxlYXNlSW5PdXRFeHBvOlI9PlI8PTA/MDpSPj0xPzE6UjwuNT9NYXRoLnBvdygyLDIwKlItMTApLzI6KDItTWF0aC5wb3coMiwtMjAqUisxMCkpLzJ9O2NsYXNzIGh0e2NvbnN0cnVjdG9yKGU9MCx0PTAsaT0xKXtPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywieCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOmV9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywieSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnR9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywieiIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOml9KX1nZXQgWFkoKXtyZXR1cm5bdGhpcy54LHRoaXMueV19c2V0eihlKXtyZXR1cm4gdGhpcy56PWUsdGhpc31zZXRYWShlPXRoaXMueCx0PXRoaXMueSl7cmV0dXJuIHRoaXMueD1lLHRoaXMueT10LHRoaXN9c2V0KGU9dGhpcy54LHQ9dGhpcy55LGk9dGhpcy56KXtyZXR1cm4gdGhpcy54PWUsdGhpcy55PXQsdGhpcy56PWksdGhpc31zZXRUbyh7eDplPTAseTp0PTAsejppPTF9KXtyZXR1cm4gdGhpcy54PWUsdGhpcy55PXQsdGhpcy56PWksdGhpc31yb3QoZSl7aWYoZT09PTApcmV0dXJuIHRoaXM7Y29uc3R7eDp0LHk6aX09dGhpcyxvPU1hdGguc2luKGUpLGc9TWF0aC5jb3MoZSk7cmV0dXJuIHRoaXMueD10KmctaSpvLHRoaXMueT10Km8raSpnLHRoaXN9cm90V2l0aChlLHQpe2lmKHQ9PT0wKXJldHVybiB0aGlzO2NvbnN0IGk9dGhpcy54LWUueCxvPXRoaXMueS1lLnksZz1NYXRoLnNpbih0KSx2PU1hdGguY29zKHQpO3JldHVybiB0aGlzLng9ZS54KyhpKnYtbypnKSx0aGlzLnk9ZS55KyhpKmcrbyp2KSx0aGlzfWNsb25lKCl7Y29uc3R7eDplLHk6dCx6Oml9PXRoaXM7cmV0dXJuIG5ldyBodChlLHQsaSl9c3ViKGUpe3JldHVybiB0aGlzLngtPWUueCx0aGlzLnktPWUueSx0aGlzfXN1YlhZKGUsdCl7cmV0dXJuIHRoaXMueC09ZSx0aGlzLnktPXQsdGhpc31zdWJTY2FsYXIoZSl7cmV0dXJuIHRoaXMueC09ZSx0aGlzLnktPWUsdGhpc31hZGQoZSl7cmV0dXJuIHRoaXMueCs9ZS54LHRoaXMueSs9ZS55LHRoaXN9YWRkWFkoZSx0KXtyZXR1cm4gdGhpcy54Kz1lLHRoaXMueSs9dCx0aGlzfWFkZFNjYWxhcihlKXtyZXR1cm4gdGhpcy54Kz1lLHRoaXMueSs9ZSx0aGlzfWNsYW1wKGUsdCl7cmV0dXJuIHRoaXMueD1NYXRoLm1heCh0aGlzLngsZSksdGhpcy55PU1hdGgubWF4KHRoaXMueSxlKSx0IT09dm9pZCAwJiYodGhpcy54PU1hdGgubWluKHRoaXMueCx0KSx0aGlzLnk9TWF0aC5taW4odGhpcy55LHQpKSx0aGlzfWRpdihlKXtyZXR1cm4gdGhpcy54Lz1lLHRoaXMueS89ZSx0aGlzfWRpdlYoZSl7cmV0dXJuIHRoaXMueC89ZS54LHRoaXMueS89ZS55LHRoaXN9bXVsKGUpe3JldHVybiB0aGlzLngqPWUsdGhpcy55Kj1lLHRoaXN9bXVsVihlKXtyZXR1cm4gdGhpcy54Kj1lLngsdGhpcy55Kj1lLnksdGhpc31hYnMoKXtyZXR1cm4gdGhpcy54PU1hdGguYWJzKHRoaXMueCksdGhpcy55PU1hdGguYWJzKHRoaXMueSksdGhpc31udWRnZShlLHQpe2NvbnN0IGk9aHQuVGFuKGUsdGhpcyk7cmV0dXJuIHRoaXMuYWRkKGkubXVsKHQpKX1uZWcoKXtyZXR1cm4gdGhpcy54Kj0tMSx0aGlzLnkqPS0xLHRoaXN9Y3Jvc3MoZSl7cmV0dXJuIHRoaXMueD10aGlzLnkqZS56LXRoaXMueiplLnksdGhpcy55PXRoaXMueiplLngtdGhpcy54KmUueix0aGlzfWRwcihlKXtyZXR1cm4gaHQuRHByKHRoaXMsZSl9Y3ByKGUpe3JldHVybiBodC5DcHIodGhpcyxlKX1sZW4yKCl7cmV0dXJuIGh0LkxlbjIodGhpcyl9bGVuKCl7cmV0dXJuIGh0Lkxlbih0aGlzKX1wcnkoZSl7cmV0dXJuIGh0LlByeSh0aGlzLGUpfXBlcigpe2NvbnN0e3g6ZSx5OnR9PXRoaXM7cmV0dXJuIHRoaXMueD10LHRoaXMueT0tZSx0aGlzfXVuaSgpe3JldHVybiBodC5VbmkodGhpcyl9dGFuKGUpe3JldHVybiBodC5UYW4odGhpcyxlKX1kaXN0KGUpe3JldHVybiBodC5EaXN0KHRoaXMsZSl9ZGlzdGFuY2VUb0xpbmVTZWdtZW50KGUsdCl7cmV0dXJuIGh0LkRpc3RhbmNlVG9MaW5lU2VnbWVudChlLHQsdGhpcyl9c2xvcGUoZSl7cmV0dXJuIGh0LlNsb3BlKHRoaXMsZSl9c25hcFRvR3JpZChlKXtyZXR1cm4gdGhpcy54PU1hdGgucm91bmQodGhpcy54L2UpKmUsdGhpcy55PU1hdGgucm91bmQodGhpcy55L2UpKmUsdGhpc31hbmdsZShlKXtyZXR1cm4gaHQuQW5nbGUodGhpcyxlKX10b0FuZ2xlKCl7cmV0dXJuIGh0LlRvQW5nbGUodGhpcyl9bHJwKGUsdCl7cmV0dXJuIHRoaXMueD10aGlzLngrKGUueC10aGlzLngpKnQsdGhpcy55PXRoaXMueSsoZS55LXRoaXMueSkqdCx0aGlzfWVxdWFscyhlLHQpe3JldHVybiBodC5FcXVhbHModGhpcyxlLHQpfWVxdWFsc1hZKGUsdCl7cmV0dXJuIGh0LkVxdWFsc1hZKHRoaXMsZSx0KX1ub3JtKCl7Y29uc3QgZT10aGlzLmxlbigpO3JldHVybiB0aGlzLng9ZT09PTA/MDp0aGlzLngvZSx0aGlzLnk9ZT09PTA/MDp0aGlzLnkvZSx0aGlzfXRvRml4ZWQoKXtyZXR1cm4gaHQuVG9GaXhlZCh0aGlzKX10b1N0cmluZygpe3JldHVybiBodC5Ub1N0cmluZyhodC5Ub0ZpeGVkKHRoaXMpKX10b0pzb24oKXtyZXR1cm4gaHQuVG9Kc29uKHRoaXMpfXRvQXJyYXkoKXtyZXR1cm4gaHQuVG9BcnJheSh0aGlzKX1zdGF0aWMgQWRkKGUsdCl7cmV0dXJuIG5ldyBodChlLngrdC54LGUueSt0LnkpfXN0YXRpYyBBZGRYWShlLHQsaSl7cmV0dXJuIG5ldyBodChlLngrdCxlLnkraSl9c3RhdGljIFN1YihlLHQpe3JldHVybiBuZXcgaHQoZS54LXQueCxlLnktdC55KX1zdGF0aWMgU3ViWFkoZSx0LGkpe3JldHVybiBuZXcgaHQoZS54LXQsZS55LWkpfXN0YXRpYyBBZGRTY2FsYXIoZSx0KXtyZXR1cm4gbmV3IGh0KGUueCt0LGUueSt0KX1zdGF0aWMgU3ViU2NhbGFyKGUsdCl7cmV0dXJuIG5ldyBodChlLngtdCxlLnktdCl9c3RhdGljIERpdihlLHQpe3JldHVybiBuZXcgaHQoZS54L3QsZS55L3QpfXN0YXRpYyBNdWwoZSx0KXtyZXR1cm4gbmV3IGh0KGUueCp0LGUueSp0KX1zdGF0aWMgRGl2VihlLHQpe3JldHVybiBuZXcgaHQoZS54L3QueCxlLnkvdC55KX1zdGF0aWMgTXVsVihlLHQpe3JldHVybiBuZXcgaHQoZS54KnQueCxlLnkqdC55KX1zdGF0aWMgTmVnKGUpe3JldHVybiBuZXcgaHQoLWUueCwtZS55KX1zdGF0aWMgUGVyKGUpe3JldHVybiBuZXcgaHQoZS55LC1lLngpfXN0YXRpYyBEaXN0MihlLHQpe3JldHVybiBodC5TdWIoZSx0KS5sZW4yKCl9c3RhdGljIEFicyhlKXtyZXR1cm4gbmV3IGh0KE1hdGguYWJzKGUueCksTWF0aC5hYnMoZS55KSl9c3RhdGljIERpc3QoZSx0KXtyZXR1cm4gTWF0aC5oeXBvdChlLnktdC55LGUueC10LngpfXN0YXRpYyBEcHIoZSx0KXtyZXR1cm4gZS54KnQueCtlLnkqdC55fXN0YXRpYyBDcm9zcyhlLHQpe3JldHVybiBuZXcgaHQoZS55KnQuei1lLnoqdC55LGUueip0LngtZS54KnQueil9c3RhdGljIENwcihlLHQpe3JldHVybiBlLngqdC55LXQueCplLnl9c3RhdGljIExlbjIoZSl7cmV0dXJuIGUueCplLngrZS55KmUueX1zdGF0aWMgTGVuKGUpe3JldHVybiBNYXRoLmh5cG90KGUueCxlLnkpfXN0YXRpYyBQcnkoZSx0KXtyZXR1cm4gaHQuRHByKGUsdCkvaHQuTGVuKHQpfXN0YXRpYyBVbmkoZSl7cmV0dXJuIGh0LkRpdihlLGh0LkxlbihlKSl9c3RhdGljIFRhbihlLHQpe3JldHVybiBodC5VbmkoaHQuU3ViKGUsdCkpfXN0YXRpYyBNaW4oZSx0KXtyZXR1cm4gbmV3IGh0KE1hdGgubWluKGUueCx0LngpLE1hdGgubWluKGUueSx0LnkpKX1zdGF0aWMgTWF4KGUsdCl7cmV0dXJuIG5ldyBodChNYXRoLm1heChlLngsdC54KSxNYXRoLm1heChlLnksdC55KSl9c3RhdGljIEZyb20oZSl7cmV0dXJuIG5ldyBodCgpLmFkZChlKX1zdGF0aWMgRnJvbUFycmF5KGUpe3JldHVybiBuZXcgaHQoZVswXSxlWzFdKX1zdGF0aWMgUm90KGUsdD0wKXtjb25zdCBpPU1hdGguc2luKHQpLG89TWF0aC5jb3ModCk7cmV0dXJuIG5ldyBodChlLngqby1lLnkqaSxlLngqaStlLnkqbyl9c3RhdGljIFJvdFdpdGgoZSx0LGkpe2NvbnN0IG89ZS54LXQueCxnPWUueS10Lnksdj1NYXRoLnNpbihpKSxjPU1hdGguY29zKGkpO3JldHVybiBuZXcgaHQodC54KyhvKmMtZyp2KSx0LnkrKG8qditnKmMpKX1zdGF0aWMgTmVhcmVzdFBvaW50T25MaW5lVGhyb3VnaFBvaW50KGUsdCxpKXtyZXR1cm4gaHQuTXVsKHQsaHQuU3ViKGksZSkucHJ5KHQpKS5hZGQoZSl9c3RhdGljIE5lYXJlc3RQb2ludE9uTGluZVNlZ21lbnQoZSx0LGksbz0hMCl7Y29uc3QgZz1odC5UYW4odCxlKSx2PWh0LkFkZChlLGh0Lk11bChnLGh0LlN1YihpLGUpLnByeShnKSkpO2lmKG8pe2lmKHYueDxNYXRoLm1pbihlLngsdC54KSlyZXR1cm4gaHQuQ2FzdChlLng8dC54P2U6dCk7aWYodi54Pk1hdGgubWF4KGUueCx0LngpKXJldHVybiBodC5DYXN0KGUueD50Lng/ZTp0KTtpZih2Lnk8TWF0aC5taW4oZS55LHQueSkpcmV0dXJuIGh0LkNhc3QoZS55PHQueT9lOnQpO2lmKHYueT5NYXRoLm1heChlLnksdC55KSlyZXR1cm4gaHQuQ2FzdChlLnk+dC55P2U6dCl9cmV0dXJuIHZ9c3RhdGljIERpc3RhbmNlVG9MaW5lVGhyb3VnaFBvaW50KGUsdCxpKXtyZXR1cm4gaHQuRGlzdChpLGh0Lk5lYXJlc3RQb2ludE9uTGluZVRocm91Z2hQb2ludChlLHQsaSkpfXN0YXRpYyBEaXN0YW5jZVRvTGluZVNlZ21lbnQoZSx0LGksbz0hMCl7cmV0dXJuIGh0LkRpc3QoaSxodC5OZWFyZXN0UG9pbnRPbkxpbmVTZWdtZW50KGUsdCxpLG8pKX1zdGF0aWMgU25hcChlLHQ9MSl7cmV0dXJuIG5ldyBodChNYXRoLnJvdW5kKGUueC90KSp0LE1hdGgucm91bmQoZS55L3QpKnQpfXN0YXRpYyBDYXN0KGUpe3JldHVybiBlIGluc3RhbmNlb2YgaHQ/ZTpodC5Gcm9tKGUpfXN0YXRpYyBTbG9wZShlLHQpe3JldHVybiBlLng9PT10Lnk/TmFOOihlLnktdC55KS8oZS54LXQueCl9c3RhdGljIEFuZ2xlKGUsdCl7cmV0dXJuIE1hdGguYXRhbjIodC55LWUueSx0LngtZS54KX1zdGF0aWMgTHJwKGUsdCxpKXtyZXR1cm4gaHQuU3ViKHQsZSkubXVsKGkpLmFkZChlKX1zdGF0aWMgTWVkKGUsdCl7cmV0dXJuIG5ldyBodCgoZS54K3QueCkvMiwoZS55K3QueSkvMil9c3RhdGljIEVxdWFscyhlLHQsaT0xZS00KXtyZXR1cm4gTWF0aC5hYnMoZS54LXQueCk8aSYmTWF0aC5hYnMoZS55LXQueSk8aX1zdGF0aWMgRXF1YWxzWFkoZSx0LGkpe3JldHVybiBlLng9PT10JiZlLnk9PT1pfXN0YXRpYyBFcXVhbHNYWVooZSx0LGk9MWUtNCl7cmV0dXJuIGh0LkVxdWFscyhlLHQsaSkmJk1hdGguYWJzKChlLnp8fDApLSh0Lnp8fDApKTxpfXN0YXRpYyBDbG9ja3dpc2UoZSx0LGkpe3JldHVybihpLngtZS54KSoodC55LWUueSktKHQueC1lLngpKihpLnktZS55KTwwfXN0YXRpYyBSZXNjYWxlKGUsdCl7Y29uc3QgaT1odC5MZW4oZSk7cmV0dXJuIG5ldyBodCh0KmUueC9pLHQqZS55L2kpfXN0YXRpYyBTY2FsZVdpdGhPcmlnaW4oZSx0LGkpe3JldHVybiBodC5TdWIoZSxpKS5tdWwodCkuYWRkKGkpfXN0YXRpYyBTY2FsZVdPcmlnaW4oZSx0LGkpe3JldHVybiBodC5TdWIoZSxpKS5tdWxWKHQpLmFkZChpKX1zdGF0aWMgVG9GaXhlZChlLHQ9Mil7cmV0dXJuIG5ldyBodCgrZS54LnRvRml4ZWQodCksK2UueS50b0ZpeGVkKHQpLCtlLnoudG9GaXhlZCh0KSl9c3RhdGljIE51ZGdlKGUsdCxpKXtyZXR1cm4gaHQuQWRkKGUsaHQuVGFuKHQsZSkubXVsKGkpKX1zdGF0aWMgVG9TdHJpbmcoZSl7cmV0dXJuYCR7ZS54fSwgJHtlLnl9YH1zdGF0aWMgVG9BbmdsZShlKXtsZXQgdD1NYXRoLmF0YW4yKGUueSxlLngpO3JldHVybiB0PDAmJih0Kz1NYXRoLlBJKjIpLHR9c3RhdGljIEZyb21BbmdsZShlLHQ9MSl7cmV0dXJuIG5ldyBodChNYXRoLmNvcyhlKSp0LE1hdGguc2luKGUpKnQpfXN0YXRpYyBUb0FycmF5KGUpe3JldHVybltlLngsZS55LGUuel19c3RhdGljIFRvSnNvbihlKXtjb25zdHt4OnQseTppLHo6b309ZTtyZXR1cm57eDp0LHk6aSx6Om99fXN0YXRpYyBBdmVyYWdlKGUpe2NvbnN0IHQ9ZS5sZW5ndGgsaT1uZXcgaHQoMCwwKTtmb3IobGV0IG89MDtvPHQ7bysrKWkuYWRkKGVbb10pO3JldHVybiBpLmRpdih0KX1zdGF0aWMgQ2xhbXAoZSx0LGkpe3JldHVybiBpPT09dm9pZCAwP25ldyBodChNYXRoLm1pbihNYXRoLm1heChlLngsdCkpLE1hdGgubWluKE1hdGgubWF4KGUueSx0KSkpOm5ldyBodChNYXRoLm1pbihNYXRoLm1heChlLngsdCksaSksTWF0aC5taW4oTWF0aC5tYXgoZS55LHQpLGkpKX1zdGF0aWMgUG9pbnRzQmV0d2VlbihlLHQsaT02KXtjb25zdCBvPVtdO2ZvcihsZXQgZz0wO2c8aTtnKyspe2NvbnN0IHY9eGUuZWFzZUluUXVhZChnLyhpLTEpKSxjPWh0LkxycChlLHQsdik7Yy56PU1hdGgubWluKDEsLjUrTWF0aC5hYnMoLjUtTWUodikpKi42NSksby5wdXNoKGMpfXJldHVybiBvfXN0YXRpYyBTbmFwVG9HcmlkKGUsdD04KXtyZXR1cm4gbmV3IGh0KE1hdGgucm91bmQoZS54L3QpKnQsTWF0aC5yb3VuZChlLnkvdCkqdCl9fWNvbnN0IE1lPVI9PlI8LjU/MipSKlI6LTErKDQtMipSKSpSO2NsYXNzIEF0IGV4dGVuZHMgaHR7Y29uc3RydWN0b3IoZT0wLHQ9MCxpPTAsbz17eDowLHk6MH0sZz0wLHY9MCl7c3VwZXIoZSx0LGkpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ4Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6ZX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ5Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ6Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6aX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ2Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6b30pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ0Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6Z30pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJhIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dn0pfWdldCB0aW1lc3RhbXAoKXtyZXR1cm4gdGhpcy50fWdldCBwcmVzc3VyZSgpe3JldHVybiB0aGlzLnp9Z2V0IGFuZ2xlTnVtKCl7cmV0dXJuIHRoaXMuYX1nZXQgWFkoKXtyZXR1cm5bdGhpcy54LHRoaXMueV19c2V0QShlKXt0aGlzLmE9ZX1zZXRUKGUpe3RoaXMudD1lfXNldHYoZSl7cmV0dXJuIHRoaXMudj17eDplLngseTplLnl9LHRoaXN9c2V0KGU9dGhpcy54LHQ9dGhpcy55LGk9dGhpcy56LG89dGhpcy52LGc9dGhpcy50LHY9dGhpcy5hKXtyZXR1cm4gdGhpcy54PWUsdGhpcy55PXQsdGhpcy56PWksdGhpcy52PW8sdGhpcy50PWcsdGhpcy5hPXYsdGhpc31jbG9uZSgpe2NvbnN0e3g6ZSx5OnQsejppLHY6byx0OmcsYTp2fT10aGlzLGM9e3g6by54LHk6by55fTtyZXR1cm4gbmV3IEF0KGUsdCxpLGMsZyx2KX1kaXN0YW5jZShlKXtyZXR1cm4gQXQuR2V0RGlzdGFuY2UodGhpcyxlKX1pc05lYXIoZSx0KXtyZXR1cm4gQXQuSXNOZWFyKHRoaXMsZSx0KX1nZXRBbmdsZUJ5UG9pbnRzKGUsdCl7cmV0dXJuIEF0LkdldEFuZ2xlQnlQb2ludHMoZSx0aGlzLHQpfXN0YXRpYyBTdWIoZSx0KXtyZXR1cm4gbmV3IEF0KGUueC10LngsZS55LXQueSl9c3RhdGljIEFkZChlLHQpe3JldHVybiBuZXcgQXQoZS54K3QueCxlLnkrdC55KX1zdGF0aWMgR2V0RGlzdGFuY2UoZSx0KXtyZXR1cm4gQXQuTGVuKGUuY2xvbmUoKS5zdWIodCkpfXN0YXRpYyBHZXRBbmdsZUJ5UG9pbnRzKGUsdCxpKXtjb25zdCBvPXQueC1lLngsZz1pLngtdC54LHY9dC55LWUueSxjPWkueS10Lnk7bGV0IGY9MDtjb25zdCBoPU1hdGguc3FydChvKm8rdip2KSxFPU1hdGguc3FydChnKmcrYypjKTtpZihoJiZFKXtjb25zdCBsPW8qZyt2KmM7Zj1NYXRoLmFjb3MobC8oaCpFKSksZj1mL01hdGguUEkqMTgwO2xldCBtPW8qYy12Kmc7bT1tPjA/MTotMSxmPTE4MCttKmZ9cmV0dXJuIGZ9c3RhdGljIElzTmVhcihlLHQsaSl7cmV0dXJuIEF0LkxlbihlLmNsb25lKCkuc3ViKHQpKTxpfXN0YXRpYyBSb3RXaXRoKGUsdCxpLG89Mil7Y29uc3QgZz1lLngtdC54LHY9ZS55LXQueSxjPU1hdGguc2luKGkpLGY9TWF0aC5jb3MoaSksaD1NYXRoLnBvdygxMCxvKSxFPU1hdGguZmxvb3IoKHQueCsoZypmLXYqYykpKmgpL2gsbD1NYXRoLmZsb29yKCh0LnkrKGcqYyt2KmYpKSpoKS9oO3JldHVybiBuZXcgQXQoRSxsKX1zdGF0aWMgR2V0RG90U3Ryb2tlKGUsdCxpPTE2KXtjb25zdCBvPW5ldyBodCgxLDEpLGc9TWF0aC5QSSsuMDAxLHY9QXQuQWRkKGUsQXQuU3ViKGUsbykudW5pKCkucGVyKCkubXVsKC10KSksYz1bXTtmb3IobGV0IGY9MS9pLGg9ZjtoPD0xO2grPWYpYy5wdXNoKEF0LlJvdFdpdGgodixlLGcqMipoKSk7cmV0dXJuIGN9c3RhdGljIEdldFNlbWljaXJjbGVTdHJva2UoZSx0LGk9LTEsbz04KXtjb25zdCBnPWkqKE1hdGguUEkrLjAwMSksdj1bXTtmb3IobGV0IGM9MS9vLGY9YztmPD0xO2YrPWMpdi5wdXNoKEF0LlJvdFdpdGgodCxlLGcqZikpO3JldHVybiB2fX12YXIgY2U7KGZ1bmN0aW9uKFIpe1JbUi5wZWRkaW5nPTBdPSJwZWRkaW5nIixSW1IubW91bnRlZD0xXT0ibW91bnRlZCIsUltSLnVwZGF0ZT0yXT0idXBkYXRlIixSW1IudW5tb3VudGVkPTNdPSJ1bm1vdW50ZWQifSkoY2V8fChjZT17fSkpO3ZhciBSdDsoZnVuY3Rpb24oUil7UltSLk5vcm1hbD0wXT0iTm9ybWFsIixSW1IuU3Ryb2tlPTFdPSJTdHJva2UiLFJbUi5Eb3R0ZWQ9Ml09IkRvdHRlZCIsUltSLkxvbmdEb3R0ZWQ9M109IkxvbmdEb3R0ZWQifSkoUnR8fChSdD17fSkpO3ZhciBoZTsoZnVuY3Rpb24oUil7Ui5TaG93RmxvYXRCYXI9IlNob3dGbG9hdEJhciIsUi5aSW5kZXhGbG9hdEJhcj0iWkluZGV4RmxvYXRCYXIiLFIuRGVsZXRlTm9kZT0iRGVsZXRlTm9kZSIsUi5Db3B5Tm9kZT0iQ29weU5vZGUiLFIuWkluZGV4QWN0aXZlPSJaSW5kZXhBY3RpdmUiLFIuWkluZGV4Tm9kZT0iWkluZGV4Tm9kZSIsUi5Sb3RhdGVOb2RlPSJSb3RhdGVOb2RlIixSLlNldENvbG9yTm9kZT0iU2V0Q29sb3JOb2RlIixSLlRyYW5zbGF0ZU5vZGU9IlRyYW5zbGF0ZU5vZGUiLFIuU2NhbGVOb2RlPSJTY2FsZU5vZGUiLFIuT3JpZ2luYWxFdmVudD0iT3JpZ2luYWxFdmVudCIsUi5DcmVhdGVTY2VuZT0iY3JlYXRlU2NlbmUiLFIuVXBkYXRlU2NlbmU9IlVwZGF0ZVNjZW5lIn0pKGhlfHwoaGU9e30pKTt2YXIgZGU7KGZ1bmN0aW9uKFIpe1IuRGlzcGxheVN0YXRlPSJEaXNwbGF5U3RhdGUiLFIuRmxvYXRCYXI9IkZsb2F0QmFyIixSLkNhbnZhc1NlbGVjdG9yPSJDYW52YXNTZWxlY3RvciIsUi5NYWluRW5naW5lPSJNYWluRW5naW5lIn0pKGRlfHwoZGU9e30pKTtmdW5jdGlvbiBidChSLGUpe2lmKFImJmUpe2NvbnN0IHQ9TWF0aC5taW4oUj09bnVsbD92b2lkIDA6Ui54LGUueCksaT1NYXRoLm1pbihSPT1udWxsP3ZvaWQgMDpSLnksZS55KSxvPU1hdGgubWF4KFIueCtSLncsZS54K2UudyksZz1NYXRoLm1heChSLnkrUi5oLGUueStlLmgpLHY9by10LGM9Zy1pO3JldHVybnt4OnQseTppLHc6dixoOmN9fXJldHVybiBlfHxSfWZ1bmN0aW9uIEd0KFIsZT0wKXtjb25zdCB0PXt4OjAseTowLHc6MCxoOjB9O2xldCBpPTEvMCxvPTEvMCxnPS0xLzAsdj0tMS8wO3JldHVybiBSLmZvckVhY2goYz0+e2NvbnN0W2YsaF09Yy5YWTtpPU1hdGgubWluKGksZi1lKSxvPU1hdGgubWluKG8saC1lKSxnPU1hdGgubWF4KGcsZitlKSx2PU1hdGgubWF4KHYsaCtlKX0pLHQueD1pLHQueT1vLHQudz1nLWksdC5oPXYtbyx0fWZ1bmN0aW9uIGdlKFIsZSl7cmV0dXJuIShSLngrUi53PGUueHx8Ui54PmUueCtlLnd8fFIueStSLmg8ZS55fHxSLnk+ZS55K2UuaCl9ZnVuY3Rpb24gRWUoUixlKXtyZXR1cm4gUi5sZW5ndGg9PT1lLmxlbmd0aCYmUi5zb3J0KCkudG9TdHJpbmcoKT09PWUuc29ydCgpLnRvU3RyaW5nKCl9ZnVuY3Rpb24gT2UoUixlKXtjb25zdCB0PW5ldyBodChSLngsUi55KSxpPW5ldyBodChSLngrUi53LFIueSksbz1uZXcgaHQoUi54K1IudyxSLnkrUi5oKSxnPW5ldyBodChSLngsUi55K1IuaCksdj1uZXcgaHQoUi54K1Iudy8yLFIueStSLmgvMiksYz1NYXRoLlBJKmUvMTgwLGY9aHQuUm90V2l0aCh0LHYsYyksaD1odC5Sb3RXaXRoKGksdixjKSxFPWh0LlJvdFdpdGgobyx2LGMpLGw9aHQuUm90V2l0aChnLHYsYyk7cmV0dXJuIEd0KFtmLGgsRSxsXSl9ZnVuY3Rpb24gUGUoUixlKXtjb25zdCB0PW5ldyBodChSLngsUi55KSxpPW5ldyBodChSLngrUi53LFIueSksbz1uZXcgaHQoUi54K1IudyxSLnkrUi5oKSxnPW5ldyBodChSLngsUi55K1IuaCksdj1uZXcgaHQoUi54K1Iudy8yLFIueStSLmgvMiksYz1uZXcgaHQoZVswXSxlWzFdKSxmPWh0LlNjYWxlV09yaWdpbih0LGMsdiksaD1odC5TY2FsZVdPcmlnaW4oaSxjLHYpLEU9aHQuU2NhbGVXT3JpZ2luKG8sYyx2KSxsPWh0LlNjYWxlV09yaWdpbihnLGMsdik7cmV0dXJuIEd0KFtmLGgsRSxsXSl9ZnVuY3Rpb24gVnQoUixlKXtsZXQgdDtyZXR1cm4gZT09bnVsbHx8ZS5nZXRFbGVtZW50c0J5TmFtZShSKS5mb3JFYWNoKGk9PntpZihpLnRhZ05hbWU9PT0iUEFUSCIpe2NvbnN0IG89aT09bnVsbD92b2lkIDA6aS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtvJiYodD1idCh0LHt4Ok1hdGguZmxvb3Ioby54KSx5Ok1hdGguZmxvb3Ioby55KSx3Ok1hdGgucm91bmQoby53aWR0aCksaDpNYXRoLnJvdW5kKG8uaGVpZ2h0KX0pKX1lbHNlIGlmKGkudGFnTmFtZT09PSJHUk9VUCIpe2NvbnN0IG89aS5jbGFzc05hbWUuc3BsaXQoIiwiKTtpZihvLmxlbmd0aD09PTMmJk51bWJlcihvWzJdKT09PVJ0LlN0cm9rZSl7Y29uc3QgZz1pPT1udWxsP3ZvaWQgMDppLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO2cmJih0PWJ0KHQse3g6TWF0aC5mbG9vcihnLngpLHk6TWF0aC5mbG9vcihnLnkpLHc6TWF0aC5yb3VuZChnLndpZHRoKSxoOk1hdGgucm91bmQoZy5oZWlnaHQpfSkpfWVsc2UgaS5jaGlsZHJlbi5mb3JFYWNoKGc9PntpZihnLnRhZ05hbWU9PT0iUEFUSCIpe2NvbnN0IHY9Zz09bnVsbD92b2lkIDA6Zy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTt2JiYodD1idCh0LHt4Ok1hdGguZmxvb3Iodi54KSx5Ok1hdGguZmxvb3Iodi55KSx3Ok1hdGgucm91bmQodi53aWR0aCksaDpNYXRoLnJvdW5kKHYuaGVpZ2h0KX0pKX19KX19KSx0fWZ1bmN0aW9uIFl0KFIpe3JldHVybmAke190KFIueCl9LCR7X3QoUi55KX0gYH1mdW5jdGlvbiBYdChSLGUpe3JldHVybmAke190KChSLngrZS54KS8yKX0sJHtfdCgoUi55K2UueSkvMil9IGB9ZnVuY3Rpb24gX3QoUil7cmV0dXJuK1IudG9GaXhlZCg0KX1mdW5jdGlvbiB0ZShSLGU9ITApe2NvbnN0IHQ9Ui5sZW5ndGg7aWYodDwyKXJldHVybiIiO2xldCBpPVJbMF0sbz1SWzFdO2lmKHQ9PT0yKXJldHVybmBNJHtZdChpKX1MJHtZdChvKX1gO2xldCBnPSIiO2ZvcihsZXQgdj0yLGM9dC0xO3Y8Yzt2KyspaT1SW3ZdLG89Ult2KzFdLGcrPVh0KGksbyk7cmV0dXJuIGU/YE0ke1h0KFJbMF0sUlsxXSl9USR7WXQoUlsxXSl9JHtYdChSWzFdLFJbMl0pfVQke2d9JHtYdChSW3QtMV0sUlswXSl9JHtYdChSWzBdLFJbMV0pfVpgOmBNJHtZdChSWzBdKX1RJHtZdChSWzFdKX0ke1h0KFJbMV0sUlsyXSl9JHtSLmxlbmd0aD4zPyJUIjoiIn0ke2d9TCR7WXQoUlt0LTFdKX1gfWZ1bmN0aW9uIEFlKFIpe3JldHVybiBSJiZSLl9fZXNNb2R1bGUmJk9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChSLCJkZWZhdWx0Iik/Ui5kZWZhdWx0OlJ9dmFyIGllPXtleHBvcnRzOnt9fTtpZS5leHBvcnRzLGZ1bmN0aW9uKFIpe3ZhciBlPWZ1bmN0aW9uKCl7dmFyIHQ9U3RyaW5nLmZyb21DaGFyQ29kZSxpPSJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPSIsbz0iQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLSQiLGc9e307ZnVuY3Rpb24gdihmLGgpe2lmKCFnW2ZdKXtnW2ZdPXt9O2Zvcih2YXIgRT0wO0U8Zi5sZW5ndGg7RSsrKWdbZl1bZi5jaGFyQXQoRSldPUV9cmV0dXJuIGdbZl1baF19dmFyIGM9e2NvbXByZXNzVG9CYXNlNjQ6ZnVuY3Rpb24oZil7aWYoZj09bnVsbClyZXR1cm4iIjt2YXIgaD1jLl9jb21wcmVzcyhmLDYsZnVuY3Rpb24oRSl7cmV0dXJuIGkuY2hhckF0KEUpfSk7c3dpdGNoKGgubGVuZ3RoJTQpe2RlZmF1bHQ6Y2FzZSAwOnJldHVybiBoO2Nhc2UgMTpyZXR1cm4gaCsiPT09IjtjYXNlIDI6cmV0dXJuIGgrIj09IjtjYXNlIDM6cmV0dXJuIGgrIj0ifX0sZGVjb21wcmVzc0Zyb21CYXNlNjQ6ZnVuY3Rpb24oZil7cmV0dXJuIGY9PW51bGw/IiI6Zj09IiI/bnVsbDpjLl9kZWNvbXByZXNzKGYubGVuZ3RoLDMyLGZ1bmN0aW9uKGgpe3JldHVybiB2KGksZi5jaGFyQXQoaCkpfSl9LGNvbXByZXNzVG9VVEYxNjpmdW5jdGlvbihmKXtyZXR1cm4gZj09bnVsbD8iIjpjLl9jb21wcmVzcyhmLDE1LGZ1bmN0aW9uKGgpe3JldHVybiB0KGgrMzIpfSkrIiAifSxkZWNvbXByZXNzRnJvbVVURjE2OmZ1bmN0aW9uKGYpe3JldHVybiBmPT1udWxsPyIiOmY9PSIiP251bGw6Yy5fZGVjb21wcmVzcyhmLmxlbmd0aCwxNjM4NCxmdW5jdGlvbihoKXtyZXR1cm4gZi5jaGFyQ29kZUF0KGgpLTMyfSl9LGNvbXByZXNzVG9VaW50OEFycmF5OmZ1bmN0aW9uKGYpe2Zvcih2YXIgaD1jLmNvbXByZXNzKGYpLEU9bmV3IFVpbnQ4QXJyYXkoaC5sZW5ndGgqMiksbD0wLG09aC5sZW5ndGg7bDxtO2wrKyl7dmFyIHA9aC5jaGFyQ29kZUF0KGwpO0VbbCoyXT1wPj4+OCxFW2wqMisxXT1wJTI1Nn1yZXR1cm4gRX0sZGVjb21wcmVzc0Zyb21VaW50OEFycmF5OmZ1bmN0aW9uKGYpe2lmKGY9PW51bGwpcmV0dXJuIGMuZGVjb21wcmVzcyhmKTtmb3IodmFyIGg9bmV3IEFycmF5KGYubGVuZ3RoLzIpLEU9MCxsPWgubGVuZ3RoO0U8bDtFKyspaFtFXT1mW0UqMl0qMjU2K2ZbRSoyKzFdO3ZhciBtPVtdO3JldHVybiBoLmZvckVhY2goZnVuY3Rpb24ocCl7bS5wdXNoKHQocCkpfSksYy5kZWNvbXByZXNzKG0uam9pbigiIikpfSxjb21wcmVzc1RvRW5jb2RlZFVSSUNvbXBvbmVudDpmdW5jdGlvbihmKXtyZXR1cm4gZj09bnVsbD8iIjpjLl9jb21wcmVzcyhmLDYsZnVuY3Rpb24oaCl7cmV0dXJuIG8uY2hhckF0KGgpfSl9LGRlY29tcHJlc3NGcm9tRW5jb2RlZFVSSUNvbXBvbmVudDpmdW5jdGlvbihmKXtyZXR1cm4gZj09bnVsbD8iIjpmPT0iIj9udWxsOihmPWYucmVwbGFjZSgvIC9nLCIrIiksYy5fZGVjb21wcmVzcyhmLmxlbmd0aCwzMixmdW5jdGlvbihoKXtyZXR1cm4gdihvLGYuY2hhckF0KGgpKX0pKX0sY29tcHJlc3M6ZnVuY3Rpb24oZil7cmV0dXJuIGMuX2NvbXByZXNzKGYsMTYsZnVuY3Rpb24oaCl7cmV0dXJuIHQoaCl9KX0sX2NvbXByZXNzOmZ1bmN0aW9uKGYsaCxFKXtpZihmPT1udWxsKXJldHVybiIiO3ZhciBsLG0scD17fSxDPXt9LHg9IiIsZD0iIix5PSIiLHI9MixzPTMsbj0yLGE9W10sTz0wLEE9MCxiO2ZvcihiPTA7YjxmLmxlbmd0aDtiKz0xKWlmKHg9Zi5jaGFyQXQoYiksT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHAseCl8fChwW3hdPXMrKyxDW3hdPSEwKSxkPXkreCxPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocCxkKSl5PWQ7ZWxzZXtpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoQyx5KSl7aWYoeS5jaGFyQ29kZUF0KDApPDI1Nil7Zm9yKGw9MDtsPG47bCsrKU89Tzw8MSxBPT1oLTE/KEE9MCxhLnB1c2goRShPKSksTz0wKTpBKys7Zm9yKG09eS5jaGFyQ29kZUF0KDApLGw9MDtsPDg7bCsrKU89Tzw8MXxtJjEsQT09aC0xPyhBPTAsYS5wdXNoKEUoTykpLE89MCk6QSsrLG09bT4+MX1lbHNle2ZvcihtPTEsbD0wO2w8bjtsKyspTz1PPDwxfG0sQT09aC0xPyhBPTAsYS5wdXNoKEUoTykpLE89MCk6QSsrLG09MDtmb3IobT15LmNoYXJDb2RlQXQoMCksbD0wO2w8MTY7bCsrKU89Tzw8MXxtJjEsQT09aC0xPyhBPTAsYS5wdXNoKEUoTykpLE89MCk6QSsrLG09bT4+MX1yLS0scj09MCYmKHI9TWF0aC5wb3coMixuKSxuKyspLGRlbGV0ZSBDW3ldfWVsc2UgZm9yKG09cFt5XSxsPTA7bDxuO2wrKylPPU88PDF8bSYxLEE9PWgtMT8oQT0wLGEucHVzaChFKE8pKSxPPTApOkErKyxtPW0+PjE7ci0tLHI9PTAmJihyPU1hdGgucG93KDIsbiksbisrKSxwW2RdPXMrKyx5PVN0cmluZyh4KX1pZih5IT09IiIpe2lmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChDLHkpKXtpZih5LmNoYXJDb2RlQXQoMCk8MjU2KXtmb3IobD0wO2w8bjtsKyspTz1PPDwxLEE9PWgtMT8oQT0wLGEucHVzaChFKE8pKSxPPTApOkErKztmb3IobT15LmNoYXJDb2RlQXQoMCksbD0wO2w8ODtsKyspTz1PPDwxfG0mMSxBPT1oLTE/KEE9MCxhLnB1c2goRShPKSksTz0wKTpBKyssbT1tPj4xfWVsc2V7Zm9yKG09MSxsPTA7bDxuO2wrKylPPU88PDF8bSxBPT1oLTE/KEE9MCxhLnB1c2goRShPKSksTz0wKTpBKyssbT0wO2ZvcihtPXkuY2hhckNvZGVBdCgwKSxsPTA7bDwxNjtsKyspTz1PPDwxfG0mMSxBPT1oLTE/KEE9MCxhLnB1c2goRShPKSksTz0wKTpBKyssbT1tPj4xfXItLSxyPT0wJiYocj1NYXRoLnBvdygyLG4pLG4rKyksZGVsZXRlIENbeV19ZWxzZSBmb3IobT1wW3ldLGw9MDtsPG47bCsrKU89Tzw8MXxtJjEsQT09aC0xPyhBPTAsYS5wdXNoKEUoTykpLE89MCk6QSsrLG09bT4+MTtyLS0scj09MCYmKHI9TWF0aC5wb3coMixuKSxuKyspfWZvcihtPTIsbD0wO2w8bjtsKyspTz1PPDwxfG0mMSxBPT1oLTE/KEE9MCxhLnB1c2goRShPKSksTz0wKTpBKyssbT1tPj4xO2Zvcig7OylpZihPPU88PDEsQT09aC0xKXthLnB1c2goRShPKSk7YnJlYWt9ZWxzZSBBKys7cmV0dXJuIGEuam9pbigiIil9LGRlY29tcHJlc3M6ZnVuY3Rpb24oZil7cmV0dXJuIGY9PW51bGw/IiI6Zj09IiI/bnVsbDpjLl9kZWNvbXByZXNzKGYubGVuZ3RoLDMyNzY4LGZ1bmN0aW9uKGgpe3JldHVybiBmLmNoYXJDb2RlQXQoaCl9KX0sX2RlY29tcHJlc3M6ZnVuY3Rpb24oZixoLEUpe3ZhciBsPVtdLG09NCxwPTQsQz0zLHg9IiIsZD1bXSx5LHIscyxuLGEsTyxBLGI9e3ZhbDpFKDApLHBvc2l0aW9uOmgsaW5kZXg6MX07Zm9yKHk9MDt5PDM7eSs9MSlsW3ldPXk7Zm9yKHM9MCxhPU1hdGgucG93KDIsMiksTz0xO08hPWE7KW49Yi52YWwmYi5wb3NpdGlvbixiLnBvc2l0aW9uPj49MSxiLnBvc2l0aW9uPT0wJiYoYi5wb3NpdGlvbj1oLGIudmFsPUUoYi5pbmRleCsrKSksc3w9KG4+MD8xOjApKk8sTzw8PTE7c3dpdGNoKHMpe2Nhc2UgMDpmb3Iocz0wLGE9TWF0aC5wb3coMiw4KSxPPTE7TyE9YTspbj1iLnZhbCZiLnBvc2l0aW9uLGIucG9zaXRpb24+Pj0xLGIucG9zaXRpb249PTAmJihiLnBvc2l0aW9uPWgsYi52YWw9RShiLmluZGV4KyspKSxzfD0obj4wPzE6MCkqTyxPPDw9MTtBPXQocyk7YnJlYWs7Y2FzZSAxOmZvcihzPTAsYT1NYXRoLnBvdygyLDE2KSxPPTE7TyE9YTspbj1iLnZhbCZiLnBvc2l0aW9uLGIucG9zaXRpb24+Pj0xLGIucG9zaXRpb249PTAmJihiLnBvc2l0aW9uPWgsYi52YWw9RShiLmluZGV4KyspKSxzfD0obj4wPzE6MCkqTyxPPDw9MTtBPXQocyk7YnJlYWs7Y2FzZSAyOnJldHVybiIifWZvcihsWzNdPUEscj1BLGQucHVzaChBKTs7KXtpZihiLmluZGV4PmYpcmV0dXJuIiI7Zm9yKHM9MCxhPU1hdGgucG93KDIsQyksTz0xO08hPWE7KW49Yi52YWwmYi5wb3NpdGlvbixiLnBvc2l0aW9uPj49MSxiLnBvc2l0aW9uPT0wJiYoYi5wb3NpdGlvbj1oLGIudmFsPUUoYi5pbmRleCsrKSksc3w9KG4+MD8xOjApKk8sTzw8PTE7c3dpdGNoKEE9cyl7Y2FzZSAwOmZvcihzPTAsYT1NYXRoLnBvdygyLDgpLE89MTtPIT1hOyluPWIudmFsJmIucG9zaXRpb24sYi5wb3NpdGlvbj4+PTEsYi5wb3NpdGlvbj09MCYmKGIucG9zaXRpb249aCxiLnZhbD1FKGIuaW5kZXgrKykpLHN8PShuPjA/MTowKSpPLE88PD0xO2xbcCsrXT10KHMpLEE9cC0xLG0tLTticmVhaztjYXNlIDE6Zm9yKHM9MCxhPU1hdGgucG93KDIsMTYpLE89MTtPIT1hOyluPWIudmFsJmIucG9zaXRpb24sYi5wb3NpdGlvbj4+PTEsYi5wb3NpdGlvbj09MCYmKGIucG9zaXRpb249aCxiLnZhbD1FKGIuaW5kZXgrKykpLHN8PShuPjA/MTowKSpPLE88PD0xO2xbcCsrXT10KHMpLEE9cC0xLG0tLTticmVhaztjYXNlIDI6cmV0dXJuIGQuam9pbigiIil9aWYobT09MCYmKG09TWF0aC5wb3coMixDKSxDKyspLGxbQV0peD1sW0FdO2Vsc2UgaWYoQT09PXApeD1yK3IuY2hhckF0KDApO2Vsc2UgcmV0dXJuIG51bGw7ZC5wdXNoKHgpLGxbcCsrXT1yK3guY2hhckF0KDApLG0tLSxyPXgsbT09MCYmKG09TWF0aC5wb3coMixDKSxDKyspfX19O3JldHVybiBjfSgpO1IhPW51bGw/Ui5leHBvcnRzPWU6dHlwZW9mIGFuZ3VsYXI8InUiJiZhbmd1bGFyIT1udWxsJiZhbmd1bGFyLm1vZHVsZSgiTFpTdHJpbmciLFtdKS5mYWN0b3J5KCJMWlN0cmluZyIsZnVuY3Rpb24oKXtyZXR1cm4gZX0pfShpZSk7dmFyIG1lPWllLmV4cG9ydHM7ZnVuY3Rpb24gVGUoUil7cmV0dXJuIEpTT04ucGFyc2UobWUuZGVjb21wcmVzcyhSKSl9ZnVuY3Rpb24gUmUoUil7cmV0dXJuIG1lLmNvbXByZXNzKEpTT04uc3RyaW5naWZ5KFIpKX1jbGFzcyBCdCBleHRlbmRzIGt0e2NvbnN0cnVjdG9yKGUsdCxpKXtzdXBlcih0LGkpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ0b29sc1R5cGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpTdC5QZW5jaWx9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywic3luY1RpbWVzdGFtcCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzeW5jSW5kZXgiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTowfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInRtcFBvaW50cyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOltdfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIk1BWF9SRVBFQVIiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZToxMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ1bmlUaGlja25lc3MiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywid29ya09wdGlvbnMiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiY2VudGVyUG9zIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6WzAsMF19KSx0aGlzLndvcmtPcHRpb25zPWUsdGhpcy51bmlUaGlja25lc3M9dGhpcy5NQVhfUkVQRUFSL2UudGhpY2tuZXNzLzEwLHRoaXMuc3luY1RpbWVzdGFtcD0wfWNvbWJpbmVDb25zdW1lKCl7dmFyIGc7Y29uc3QgZT0oZz10aGlzLndvcmtJZCk9PW51bGw/dm9pZCAwOmcudG9TdHJpbmcoKSx0PXRoaXMudHJhbnNmb3JtRGF0YUFsbCghMCksaT17bmFtZTplLGNsYXNzTmFtZToicGVuY2lsIn07bGV0IG87cmV0dXJuIHQubGVuZ3RoJiYobz10aGlzLmRyYXcoe2F0dHJzOmksdGFza3M6dCxyZXBsYWNlSWQ6ZSxpc0Z1bGxXb3JrOiExLG5vcm1hbGl6ZTohMCxpc0NsZWFyQWxsOiEwfSkpLHtyZWN0Om8sdHlwZTpUdC5EcmF3V29yayxkYXRhVHlwZTpDdC5Mb2NhbH19c2V0V29ya09wdGlvbnMoZSl7c3VwZXIuc2V0V29ya09wdGlvbnMoZSksdGhpcy5zeW5jVGltZXN0YW1wPURhdGUubm93KCl9Y29uc3VtZShlKXt2YXIgeDtjb25zdHtkYXRhOnQsaXNGdWxsV29yazppLGlzQ2xlYXJBbGw6byxpc1N1YldvcmtlcjpnfT1lO2lmKCgoeD10Lm9wKT09bnVsbD92b2lkIDA6eC5sZW5ndGgpPT09MClyZXR1cm57dHlwZTpUdC5Ob25lfTtjb25zdHt3b3JrSWQ6dn09dCx7dGFza3M6YyxlZmZlY3RzOmYsY29uc3VtZUluZGV4Omh9PXRoaXMudHJhbnNmb3JtRGF0YSh0LCExKTt0aGlzLnN5bmNJbmRleD1NYXRoLm1pbih0aGlzLnN5bmNJbmRleCxoKTtjb25zdCBFPXtuYW1lOnY9PW51bGw/dm9pZCAwOnYudG9TdHJpbmcoKSxjbGFzc05hbWU6InBlbmNpbCJ9O2xldCBsLG09ITE7Y29uc3QgcD10aGlzLnN5bmNJbmRleDtpZih0aGlzLnN5bmNUaW1lc3RhbXA9PT0wJiYodGhpcy5zeW5jVGltZXN0YW1wPURhdGUubm93KCkpLGMubGVuZ3RoJiYoY1swXS50YXNrSWQtdGhpcy5zeW5jVGltZXN0YW1wPnRoaXMuc3luY1VuaXRUaW1lJiYobT0hMCx0aGlzLnN5bmNUaW1lc3RhbXA9Y1swXS50YXNrSWQsdGhpcy5zeW5jSW5kZXg9dGhpcy50bXBQb2ludHMubGVuZ3RoKSxsPXRoaXMuZHJhdyh7YXR0cnM6RSx0YXNrczpjLGVmZmVjdHM6Zixpc0Z1bGxXb3JrOmksaXNDbGVhckFsbDpvfSkpLGcpcmV0dXJuIGg+MTAmJnRoaXMudG1wUG9pbnRzLnNwbGljZSgwLGgtMTApLHtyZWN0OmwsdHlwZTpUdC5EcmF3V29yayxkYXRhVHlwZTpDdC5Mb2NhbH07Y29uc3QgQz1bXTtyZXR1cm4gdGhpcy50bXBQb2ludHMuc2xpY2UocCkuZm9yRWFjaChkPT57Qy5wdXNoKGQueCxkLnksdGhpcy5jb21wdXRSYWRpdXMoZC56LHRoaXMud29ya09wdGlvbnMudGhpY2tuZXNzKSl9KSx7cmVjdDpsLHR5cGU6VHQuRHJhd1dvcmssZGF0YVR5cGU6Q3QuTG9jYWwsd29ya0lkOm0/djp2b2lkIDAsb3A6bT9DOnZvaWQgMCxpbmRleDptP3AqMzp2b2lkIDB9fWNvbnN1bWVBbGwoZSl7dmFyIGM7aWYoZS5kYXRhKXtjb25zdHtvcDpmLHdvcmtTdGF0ZTpofT1lLmRhdGE7ZiE9bnVsbCYmZi5sZW5ndGgmJmg9PT13dC5Eb25lJiZ0aGlzLndvcmtPcHRpb25zLnN0cm9rZVR5cGU9PT1SdC5TdHJva2UmJnRoaXMudXBkYXRlVGVtcFBvaW50c1dpdGhQcmVzc3VyZVdoZW5Eb25lKGYpfWNvbnN0IHQ9KGM9dGhpcy53b3JrSWQpPT1udWxsP3ZvaWQgMDpjLnRvU3RyaW5nKCksaT10aGlzLnRyYW5zZm9ybURhdGFBbGwoITApLG89e25hbWU6dCxjbGFzc05hbWU6InBlbmNpbCJ9O2xldCBnO2kubGVuZ3RoJiYoZz10aGlzLmRyYXcoe2F0dHJzOm8sdGFza3M6aSxyZXBsYWNlSWQ6dCxpc0Z1bGxXb3JrOiEwLG5vcm1hbGl6ZTohMCxpc0NsZWFyQWxsOiExfSkpO2NvbnN0IHY9W107cmV0dXJuIHRoaXMudG1wUG9pbnRzLm1hcChmPT57di5wdXNoKGYueCxmLnksdGhpcy5jb21wdXRSYWRpdXMoZi56LHRoaXMud29ya09wdGlvbnMudGhpY2tuZXNzKSl9KSx0aGlzLnN5bmNUaW1lc3RhbXA9MCx7cmVjdDpnLHR5cGU6VHQuRnVsbFdvcmssZGF0YVR5cGU6Q3QuTG9jYWwsd29ya0lkOnQsb3BzOlJlKHYpLHVwZGF0ZU5vZGVPcHQ6e3Bvczp0aGlzLmNlbnRlclBvcyx1c2VBbmltYXRpb246ITB9fX1jbGVhclRtcFBvaW50cygpe3RoaXMudG1wUG9pbnRzLmxlbmd0aD0wLHRoaXMuc3luY1RpbWVzdGFtcD0wLHRoaXMuc3luY0luZGV4PTB9Y29uc3VtZVNlcnZpY2UoZSl7dmFyIEU7Y29uc3R7b3A6dCxpc0Z1bGxXb3JrOmkscmVwbGFjZUlkOm8saXNDbGVhckFsbDpnfT1lO3RoaXMudG1wUG9pbnRzLmxlbmd0aD0wO2ZvcihsZXQgbD0wO2w8dC5sZW5ndGg7bCs9Myl7Y29uc3QgbT1uZXcgQXQodFtsXSx0W2wrMV0sdFtsKzJdKTtpZih0aGlzLnRtcFBvaW50cy5sZW5ndGg+MCl7Y29uc3QgcD10aGlzLnRtcFBvaW50c1t0aGlzLnRtcFBvaW50cy5sZW5ndGgtMV0sQz1odC5TdWIobSxwKS51bmkoKTttLnNldHYoQyl9dGhpcy50bXBQb2ludHMucHVzaChtKX1jb25zdCB2PXRoaXMudHJhbnNmb3JtRGF0YUFsbCghMSksZj17bmFtZTooRT10aGlzLndvcmtJZCk9PW51bGw/dm9pZCAwOkUudG9TdHJpbmcoKSxjbGFzc05hbWU6InBlbmNpbCJ9O2xldCBoO3JldHVybiB2Lmxlbmd0aCYmKGg9dGhpcy5kcmF3KHthdHRyczpmLHRhc2tzOnYscmVwbGFjZUlkOm8saXNGdWxsV29yazppLG5vcm1hbGl6ZTohMCxpc0NsZWFyQWxsOmd9KSksaH10cmFuc2Zvcm1EYXRhQWxsKGU9ITApe3JldHVybiB0aGlzLmdldFRhc2tQb2ludHModGhpcy50bXBQb2ludHMsZSYmdGhpcy53b3JrT3B0aW9ucy50aGlja25lc3N8fHZvaWQgMCl9ZHJhdyhlKXt2YXIgYTtjb25zdHthdHRyczp0LHRhc2tzOmkscmVwbGFjZUlkOm8sZWZmZWN0czpnLGlzRnVsbFdvcms6dixub3JtYWxpemU6Yyxpc0NsZWFyQWxsOmZ9PWUsaD12P3RoaXMuZnVsbExheWVyOnRoaXMuZHJhd0xheWVyfHx0aGlzLmZ1bGxMYXllcix7Y29sb3I6RSxzdHJva2VUeXBlOmwsdGhpY2tuZXNzOm0sb3BhY2l0eTpwLHpJbmRleDpDLHNjYWxlOngscm90YXRlOmR9PXRoaXMud29ya09wdGlvbnM7Zj9oLnJlbW92ZUFsbENoaWxkcmVuKCk6KG8mJihoLmdldEVsZW1lbnRzQnlOYW1lKG8rIiIpLm1hcChPPT5PLnJlbW92ZSgpKSwoYT10aGlzLmRyYXdMYXllcik9PW51bGx8fGEuZ2V0RWxlbWVudHNCeU5hbWUobysiIikubWFwKE89Pk8ucmVtb3ZlKCkpKSxnIT1udWxsJiZnLnNpemUmJihnLmZvckVhY2goTz0+e3ZhciBBOyhBPWguZ2V0RWxlbWVudEJ5SWQoTysiIikpPT1udWxsfHxBLnJlbW92ZSgpfSksZy5jbGVhcigpKSk7bGV0IHk7Y29uc3Qgcj1bXSxzPWgud29ybGRQb3NpdGlvbixuPWgud29ybGRTY2FsaW5nO2ZvcihsZXQgTz0wO088aS5sZW5ndGg7TysrKXtjb25zdHtwb3M6QSxwb2ludHM6Yix0YXNrSWQ6SX09aVtPXTt0LmlkPUkudG9TdHJpbmcoKTtjb25zdHtwczpQLHJlY3Q6RH09dGhpcy5jb21wdXREcmF3UG9pbnRzKGIpO2xldCBMO2NvbnN0IFM9Yi5sZW5ndGg9PT0xO2w9PT1SdC5TdHJva2V8fFM/TD10ZShQLCEwKTpMPXRlKFAsITEpO2NvbnN0IFQ9e3BvczpBLGQ6TCxmaWxsQ29sb3I6bD09PVJ0LlN0cm9rZXx8Uz9FOnZvaWQgMCxvcGFjaXR5OnB8fDEsbGluZURhc2g6bD09PVJ0LkRvdHRlZCYmIVM/WzEsbSoyXTpsPT09UnQuTG9uZ0RvdHRlZCYmIVM/W20sbSoyXTp2b2lkIDAsc3Ryb2tlQ29sb3I6RSxsaW5lQ2FwOmw9PT1SdC5TdHJva2V8fFM/dm9pZCAwOiJyb3VuZCIsbGluZVdpZHRoOmw9PT1SdC5TdHJva2V8fFM/MDptLGNsYXNzTmFtZTpgJHtBWzBdfSwke0FbMV19LCR7bH1gfTtpZihpLmxlbmd0aD09PTEmJmMpe2NvbnN0IGo9W0QueCtELncvMixELnkrRC5oLzJdO2lmKHRoaXMuY2VudGVyUG9zPVtqWzBdK0FbMF0salsxXStBWzFdXSxULm5vcm1hbGl6ZT0hMCxULnBvcz10aGlzLmNlbnRlclBvcyxULmNsYXNzTmFtZT1gJHt0aGlzLmNlbnRlclBvc1swXX0sJHt0aGlzLmNlbnRlclBvc1sxXX0sJHtsfWAsVC5pZD10Lm5hbWUsVC56SW5kZXg9Qyx4KXtULnNjYWxlPXg7Y29uc3QgJD1QZSh7eDpNYXRoLmZsb29yKEQueCtBWzBdK3NbMF0tQnQuUGVuY2lsQm9yZGVyUGFkZGluZykseTpNYXRoLmZsb29yKEQueStBWzFdK3NbMV0tQnQuUGVuY2lsQm9yZGVyUGFkZGluZyksdzpNYXRoLmZsb29yKEQudysyKkJ0LlBlbmNpbEJvcmRlclBhZGRpbmcpLGg6TWF0aC5mbG9vcihELmgrMipCdC5QZW5jaWxCb3JkZXJQYWRkaW5nKX0seCk7eT1idCh5LCQpfWlmKGQpe1Qucm90YXRlPWQ7Y29uc3QgJD1PZSh7eDpNYXRoLmZsb29yKEQueCtBWzBdK3NbMF0tQnQuUGVuY2lsQm9yZGVyUGFkZGluZykseTpNYXRoLmZsb29yKEQueStBWzFdK3NbMV0tQnQuUGVuY2lsQm9yZGVyUGFkZGluZyksdzpNYXRoLmZsb29yKEQudysyKkJ0LlBlbmNpbEJvcmRlclBhZGRpbmcpLGg6TWF0aC5mbG9vcihELmgrMipCdC5QZW5jaWxCb3JkZXJQYWRkaW5nKX0sZCk7eT1idCh5LCQpfX15PWJ0KHkse3g6TWF0aC5mbG9vcigoRC54K0FbMF0pKm5bMF0rc1swXS1CdC5QZW5jaWxCb3JkZXJQYWRkaW5nKSx5Ok1hdGguZmxvb3IoKEQueStBWzFdKSpuWzFdK3NbMV0tQnQuUGVuY2lsQm9yZGVyUGFkZGluZyksdzpNYXRoLmZsb29yKEQudypuWzBdKzIqQnQuUGVuY2lsQm9yZGVyUGFkZGluZyksaDpNYXRoLmZsb29yKEQuaCpuWzFdKzIqQnQuUGVuY2lsQm9yZGVyUGFkZGluZyl9KSxyLnB1c2goVCl9aWYoYyYmci5sZW5ndGg+MSYmeSl7Y29uc3QgTz1uZXcgcmU7dGhpcy5jZW50ZXJQb3M9Wyh5LngreS53LzItc1swXSkvblswXSwoeS55K3kuaC8yLXNbMV0pL25bMV1dLE8uYXR0cih7Li4udCxpZDp0Lm5hbWUsYW5jaG9yOlsuNSwuNV0sYmdjb2xvcjpsPT09UnQuU3Ryb2tlP0U6dm9pZCAwLHNjYWxlOngsb3BhY2l0eTpwLHBvczp0aGlzLmNlbnRlclBvcyxyb3RhdGU6ZCxjbGFzc05hbWU6YCR7dGhpcy5jZW50ZXJQb3NbMF19LCR7dGhpcy5jZW50ZXJQb3NbMV19LCR7bH1gLHNpemU6W3kudyx5LmhdLHpJbmRleDpDfSksci5mb3JFYWNoKEE9PntBLnBvcz1bQS5wb3NbMF0tdGhpcy5jZW50ZXJQb3NbMF0sQS5wb3NbMV0tdGhpcy5jZW50ZXJQb3NbMV1dO2NvbnN0IGI9bmV3IG5lKEEpO08uYXBwZW5kQ2hpbGQoYil9KSxsPT09UnQuU3Ryb2tlJiZPLnNlYWwoKSxoLmFwcGVuZChPKX1lbHNle2NvbnN0IE89ci5tYXAoQT0+bmV3IG5lKHsuLi50LC4uLkF9KSk7aC5hcHBlbmQoLi4uTyl9cmV0dXJuIHl9Y29tcHV0RHJhd1BvaW50cyhlKXtyZXR1cm4gdGhpcy53b3JrT3B0aW9ucy5zdHJva2VUeXBlPT09UnQuU3Ryb2tlfHxlLmxlbmd0aD09PTE/dGhpcy5jb21wdXRTdHJva2UoZSk6dGhpcy5jb21wdXROb21hbChlKX1jb21wdXROb21hbChlKXtsZXQgdD10aGlzLndvcmtPcHRpb25zLnRoaWNrbmVzcztjb25zdCBpPWUubWFwKG89Pih0PU1hdGgubWF4KHQsby5yYWRpdXMpLG8ucG9pbnQpKTtyZXR1cm57cHM6aSxyZWN0Okd0KGksdCl9fWNvbXB1dFN0cm9rZShlKXtyZXR1cm4gZS5sZW5ndGg9PT0xP3RoaXMuY29tcHV0RG90U3Ryb2tlKGVbMF0pOnRoaXMuY29tcHV0TGluZVN0cm9rZShlKX1jb21wdXRMaW5lU3Ryb2tlKGUpe2NvbnN0IHQ9W10saT1bXTtmb3IobGV0IGY9MDtmPGUubGVuZ3RoO2YrKyl7Y29uc3R7cG9pbnQ6aCxyYWRpdXM6RX09ZVtmXTtsZXQgbD1oLnY7Zj09PTAmJmUubGVuZ3RoPjEmJihsPWVbZisxXS5wb2ludC52KTtjb25zdCBtPWh0LlBlcihsKS5tdWwoRSk7dC5wdXNoKEF0LlN1YihoLG0pKSxpLnB1c2goQXQuQWRkKGgsbSkpfWNvbnN0IG89ZVtlLmxlbmd0aC0xXSxnPUF0LkdldFNlbWljaXJjbGVTdHJva2Uoby5wb2ludCx0W3QubGVuZ3RoLTFdLC0xLDgpLHY9QXQuR2V0U2VtaWNpcmNsZVN0cm9rZShlWzBdLnBvaW50LGlbMF0sLTEsOCksYz10LmNvbmNhdChnLGkucmV2ZXJzZSgpLHYpO3JldHVybntwczpjLHJlY3Q6R3QoYyl9fWNvbXB1dERvdFN0cm9rZShlKXtjb25zdHtwb2ludDp0LHJhZGl1czppfT1lLG89e3g6dC54LWkseTp0LnktaSx3OmkqMixoOmkqMn07cmV0dXJue3BzOkF0LkdldERvdFN0cm9rZSh0LGksOCkscmVjdDpvfX10cmFuc2Zvcm1EYXRhKGUsdCl7Y29uc3R7b3A6aSx3b3JrU3RhdGU6b309ZTtsZXQgZz10aGlzLnRtcFBvaW50cy5sZW5ndGgtMSx2PVtdO2lmKGkhPW51bGwmJmkubGVuZ3RoJiZvKXtjb25zdHtzdHJva2VUeXBlOmMsdGhpY2tuZXNzOmZ9PXRoaXMud29ya09wdGlvbnMsaD1uZXcgU2V0O2c9Yz09PVJ0LlN0cm9rZT90aGlzLnVwZGF0ZVRlbXBQb2ludHNXaXRoUHJlc3N1cmUoaSxmLGgpOnRoaXMudXBkYXRlVGVtcFBvaW50cyhpLGYsaCk7Y29uc3QgRT10P3RoaXMudG1wUG9pbnRzOnRoaXMudG1wUG9pbnRzLnNsaWNlKGcpO3JldHVybiB2PXRoaXMuZ2V0VGFza1BvaW50cyhFLGYpLHt0YXNrczp2LGVmZmVjdHM6aCxjb25zdW1lSW5kZXg6Z319cmV0dXJue3Rhc2tzOnYsY29uc3VtZUluZGV4Omd9fWNvbXB1dFJhZGl1cyhlLHQpe3JldHVybiBlKi4zK3QqLjV9Z2V0VGFza1BvaW50cyhlLHQpe3ZhciBFO2NvbnN0IGk9W107aWYoZS5sZW5ndGg9PT0wKXJldHVybltdO2xldCBvPTAsZz1lWzBdLngsdj1lWzBdLnksYz1bZyx2XSxmPVtdLGg9ZVswXS50O2Zvcig7bzxlLmxlbmd0aDspe2NvbnN0IGw9ZVtvXSxtPWwueC1nLHA9bC55LXYsQz1sLnoseD10P3RoaXMuY29tcHV0UmFkaXVzKEMsdCk6bC56O2lmKGYucHVzaCh7cG9pbnQ6bmV3IEF0KG0scCxDLGVbb10udikscmFkaXVzOnh9KSxvPjAmJm88ZS5sZW5ndGgtMSl7Y29uc3QgZD1lW29dLmdldEFuZ2xlQnlQb2ludHMoZVtvLTFdLGVbbysxXSk7aWYoZDw5MHx8ZD4yNzApe2NvbnN0IHk9KEU9Zi5wb3AoKSk9PW51bGw/dm9pZCAwOkUucG9pbnQuY2xvbmUoKTt5JiZpLnB1c2goe3Rhc2tJZDpoLHBvczpjLHBvaW50czpbLi4uZix7cG9pbnQ6eSxyYWRpdXM6eH1dfSksZz1lW29dLngsdj1lW29dLnksYz1bZyx2XTtjb25zdCByPWwueC1nLHM9bC55LXY7Zj1be3BvaW50Om5ldyBBdChyLHMsQykscmFkaXVzOnh9XSxoPURhdGUubm93KCl9fW8rK31yZXR1cm4gaS5wdXNoKHt0YXNrSWQ6aCxwb3M6Yyxwb2ludHM6Zn0pLGl9dXBkYXRlVGVtcFBvaW50c1dpdGhQcmVzc3VyZShlLHQsaSl7Y29uc3Qgbz1EYXRlLm5vdygpLGc9dGhpcy50bXBQb2ludHMubGVuZ3RoO2xldCB2PWc7Zm9yKGxldCBmPTA7ZjxlLmxlbmd0aDtmKz0yKXt2PU1hdGgubWluKHYsZyk7Y29uc3QgaD10aGlzLnRtcFBvaW50cy5sZW5ndGgsRT1uZXcgQXQoZVtmXSxlW2YrMV0pO2lmKGg9PT0wKXt0aGlzLnRtcFBvaW50cy5wdXNoKEUpO2NvbnRpbnVlfWNvbnN0IGw9aC0xLG09dGhpcy50bXBQb2ludHNbbF0scD1odC5TdWIoRSxtKS51bmkoKTtpZihFLmlzTmVhcihtLHQpKXtpZihtLno8dGhpcy5NQVhfUkVQRUFSKXtpZihtLnNldHooTWF0aC5taW4obS56KzEsdGhpcy5NQVhfUkVQRUFSKSksdj1NYXRoLm1pbih2LGwpLGg+MSl7bGV0IGQ9aC0xO2Zvcig7ZD4wOyl7Y29uc3QgeT10aGlzLnRtcFBvaW50c1tkXS5kaXN0YW5jZSh0aGlzLnRtcFBvaW50c1tkLTFdKSxyPU1hdGgubWF4KHRoaXMudG1wUG9pbnRzW2RdLnotdGhpcy51bmlUaGlja25lc3MqeSwwKTtpZih0aGlzLnRtcFBvaW50c1tkLTFdLno+PXIpYnJlYWs7dGhpcy50bXBQb2ludHNbZC0xXS5zZXR6KHIpLHY9TWF0aC5taW4odixkLTEpLGQtLX19fWVsc2Ugdj0xLzA7Y29udGludWV9RS5zZXR2KHApO2NvbnN0IEM9RS5kaXN0YW5jZShtKSx4PU1hdGgubWF4KG0uei10aGlzLnVuaVRoaWNrbmVzcypDLDApO2g+MSYmaHQuRXF1YWxzKHAsbS52LC4wMikmJih4PjB8fG0uejw9MCkmJihpJiZtLnQmJmkuYWRkKG0udCksdGhpcy50bXBQb2ludHMucG9wKCksdj1NYXRoLm1pbihsLHYpKSxFLnNldHooeCksdGhpcy50bXBQb2ludHMucHVzaChFKX1pZih2PT09MS8wKXJldHVybiB0aGlzLnRtcFBvaW50cy5sZW5ndGg7bGV0IGM9ZztpZih2PT09Zyl7Yz1NYXRoLm1heChjLTEsMCk7Y29uc3QgZj10aGlzLnRtcFBvaW50c1tjXS50O2YmJihpPT1udWxsfHxpLmFkZChmKSl9ZWxzZXtsZXQgZj1nLTE7Zm9yKGM9djtmPj0wOyl7Y29uc3QgaD10aGlzLnRtcFBvaW50c1tmXS50O2lmKGgmJihpPT1udWxsfHxpLmFkZChoKSxmPD12KSl7Yz1mLGY9LTE7YnJlYWt9Zi0tfX1yZXR1cm4gdGhpcy50bXBQb2ludHNbY10uc2V0VChvKSxjfXVwZGF0ZVRlbXBQb2ludHMoZSx0LGkpe3ZhciBmO2NvbnN0IG89RGF0ZS5ub3coKSxnPXRoaXMudG1wUG9pbnRzLmxlbmd0aDtsZXQgdj1nO2ZvcihsZXQgaD0wO2g8ZS5sZW5ndGg7aCs9Mil7Y29uc3QgRT10aGlzLnRtcFBvaW50cy5sZW5ndGgsbD1uZXcgQXQoZVtoXSxlW2grMV0pO2lmKEU9PT0wKXt0aGlzLnRtcFBvaW50cy5wdXNoKGwpO2NvbnRpbnVlfWNvbnN0IG09RS0xLHA9dGhpcy50bXBQb2ludHNbbV0sQz1odC5TdWIobCxwKS51bmkoKTtpZihodC5FcXVhbHMoQyxwLnYsLjAyKSl7aSYmcC50JiZpLmFkZChwLnQpLHRoaXMudG1wUG9pbnRzLnBvcCgpLHY9TWF0aC5taW4obSx2KTtjb250aW51ZX1pZihsLmlzTmVhcihwLHQvMikpe3Y9TWF0aC5taW4obSx2KTtjb250aW51ZX1sLnNldHYoQyksdGhpcy50bXBQb2ludHMucHVzaChsKX1sZXQgYz1nO2lmKHY9PT1nKXtjPU1hdGgubWF4KGMtMSwwKTtjb25zdCBoPXRoaXMudG1wUG9pbnRzW2NdLnQ7aCYmKGk9PW51bGx8fGkuYWRkKGgpKX1lbHNle2xldCBoPU1hdGgubWluKGctMSx2KTtmb3IoYz12O2g+PTA7KXtjb25zdCBFPShmPXRoaXMudG1wUG9pbnRzW2hdKT09bnVsbD92b2lkIDA6Zi50O2lmKEUmJihpPT1udWxsfHxpLmFkZChFKSxoPD12KSl7Yz1oLGg9LTE7YnJlYWt9aC0tfX1yZXR1cm4gdGhpcy50bXBQb2ludHNbY10uc2V0VChvKSxjfXVwZGF0ZVRlbXBQb2ludHNXaXRoUHJlc3N1cmVXaGVuRG9uZShlKXtjb25zdHt0aGlja25lc3M6dH09dGhpcy53b3JrT3B0aW9ucztmb3IobGV0IGk9MDtpPGUubGVuZ3RoO2krPTIpe2NvbnN0IG89dGhpcy50bXBQb2ludHMubGVuZ3RoLGc9bmV3IEF0KGVbaV0sZVtpKzFdKTtpZihvPT09MCl7dGhpcy50bXBQb2ludHMucHVzaChnKTtjb250aW51ZX1jb25zdCB2PW8tMSxjPXRoaXMudG1wUG9pbnRzW3ZdLGY9aHQuU3ViKGcsYykudW5pKCk7aWYoZy5pc05lYXIoYyx0LzQpKXtpZihjLno8dGhpcy5NQVhfUkVQRUFSJiYoYy5zZXR6KE1hdGgubWluKGMueisxLHRoaXMuTUFYX1JFUEVBUikpLG8+MSkpe2xldCBsPW8tMTtmb3IoO2w+MDspe2NvbnN0IG09dGhpcy50bXBQb2ludHNbbF0uZGlzdGFuY2UodGhpcy50bXBQb2ludHNbbC0xXSkscD1NYXRoLm1heCh0aGlzLnRtcFBvaW50c1tsXS56LXRoaXMudW5pVGhpY2tuZXNzKm0sLXQvNCk7aWYodGhpcy50bXBQb2ludHNbbC0xXS56Pj1wKWJyZWFrO3RoaXMudG1wUG9pbnRzW2wtMV0uc2V0eihwKSxsLS19fWNvbnRpbnVlfWcuc2V0dihmKTtjb25zdCBoPWcuZGlzdGFuY2UoYyksRT1NYXRoLm1heChjLnotdGhpcy51bmlUaGlja25lc3MqNSpoLC10LzIpO28+MSYmaHQuRXF1YWxzKGYsYy52LC4wMikmJmMuejw9MCYmdGhpcy50bXBQb2ludHMucG9wKCksZy5zZXR6KEUpLHRoaXMudG1wUG9pbnRzLnB1c2goZyl9fXVwZGF0YU9wdFNlcnZpY2UoZSl7dmFyIG87bGV0IHQ7Y29uc3QgaT0obz10aGlzLndvcmtJZCk9PW51bGw/dm9pZCAwOm8udG9TdHJpbmcoKTtpZihpJiZlKXtjb25zdCBnPXRoaXMuZnVsbExheWVyLmdldEVsZW1lbnRzQnlOYW1lKGkpLHtwb3M6dix6SW5kZXg6Yyxjb2xvcjpmLHNjYWxlOmgsYW5nbGU6RSxvcGFjaXR5Omx9PWUsbT17fTtpZih0eXBlb2YgYz09Im51bWJlciImJihtLnpJbmRleD1jKSx2JiYobS5wb3M9W3ZbMF0sdlsxXV0sZ1swXSkpe2NvbnN0IHA9Z1swXS5jbGFzc05hbWUuc3BsaXQoIiwiKTttLmNsYXNzTmFtZT1gJHt2WzBdfSwke3ZbMV19LCR7cFsyXX1gfXJldHVybiBmJiYobS5zdHJva2VDb2xvcj1mKSxoJiYobS5zY2FsZT1oKSxsJiYobS5vcGFjaXR5PWwpLEUmJihtLnJvdGF0ZT1FKSxPYmplY3Qua2V5cyhtKS5sZW5ndGgmJmcuZm9yRWFjaChwPT57Y29uc3QgQz1wLmF0dHIoImZpbGxDb2xvciIpO2YmJkM/cC5hdHRyKHsuLi5tLGZpbGxDb2xvcjpmfSk6cC5hdHRyKG0pO2NvbnN0IHg9cD09bnVsbD92b2lkIDA6cC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTt4JiYodD1idCh0LHt4Ok1hdGguZmxvb3IoeC54LUJ0LlBlbmNpbEJvcmRlclBhZGRpbmcpLHk6TWF0aC5mbG9vcih4LnktQnQuUGVuY2lsQm9yZGVyUGFkZGluZyksdzpNYXRoLmZsb29yKHgud2lkdGgrQnQuUGVuY2lsQm9yZGVyUGFkZGluZyoyKSxoOk1hdGguZmxvb3IoeC5oZWlnaHQrQnQuUGVuY2lsQm9yZGVyUGFkZGluZyoyKX0pKX0pLHR9fX1PYmplY3QuZGVmaW5lUHJvcGVydHkoQnQsIlBlbmNpbEJvcmRlclBhZGRpbmciLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZToxMH0pO3ZhciBTZT1lZTtlZS5wb2x5bGluZT1lZSxlZS5wb2x5Z29uPUNlO2Z1bmN0aW9uIGVlKFIsZSx0KXt2YXIgaT1SLmxlbmd0aCxvPUp0KFJbMF0sZSksZz1bXSx2LGMsZixoLEU7Zm9yKHR8fCh0PVtdKSx2PTE7djxpO3YrKyl7Zm9yKGM9Ult2LTFdLGY9Ult2XSxoPUU9SnQoZixlKTs7KWlmKG98aCl7aWYobyZoKWJyZWFrO28/KGM9c2UoYyxmLG8sZSksbz1KdChjLGUpKTooZj1zZShjLGYsaCxlKSxoPUp0KGYsZSkpfWVsc2V7Zy5wdXNoKGMpLGghPT1FPyhnLnB1c2goZiksdjxpLTEmJih0LnB1c2goZyksZz1bXSkpOnY9PT1pLTEmJmcucHVzaChmKTticmVha31vPUV9cmV0dXJuIGcubGVuZ3RoJiZ0LnB1c2goZyksdH1mdW5jdGlvbiBDZShSLGUpe3ZhciB0LGksbyxnLHYsYyxmO2ZvcihpPTE7aTw9ODtpKj0yKXtmb3IodD1bXSxvPVJbUi5sZW5ndGgtMV0sZz0hKEp0KG8sZSkmaSksdj0wO3Y8Ui5sZW5ndGg7disrKWM9Ult2XSxmPSEoSnQoYyxlKSZpKSxmIT09ZyYmdC5wdXNoKHNlKG8sYyxpLGUpKSxmJiZ0LnB1c2goYyksbz1jLGc9ZjtpZihSPXQsIVIubGVuZ3RoKWJyZWFrfXJldHVybiB0fWZ1bmN0aW9uIHNlKFIsZSx0LGkpe3JldHVybiB0Jjg/W1JbMF0rKGVbMF0tUlswXSkqKGlbM10tUlsxXSkvKGVbMV0tUlsxXSksaVszXV06dCY0P1tSWzBdKyhlWzBdLVJbMF0pKihpWzFdLVJbMV0pLyhlWzFdLVJbMV0pLGlbMV1dOnQmMj9baVsyXSxSWzFdKyhlWzFdLVJbMV0pKihpWzJdLVJbMF0pLyhlWzBdLVJbMF0pXTp0JjE/W2lbMF0sUlsxXSsoZVsxXS1SWzFdKSooaVswXS1SWzBdKS8oZVswXS1SWzBdKV06bnVsbH1mdW5jdGlvbiBKdChSLGUpe3ZhciB0PTA7cmV0dXJuIFJbMF08ZVswXT90fD0xOlJbMF0+ZVsyXSYmKHR8PTIpLFJbMV08ZVsxXT90fD00OlJbMV0+ZVszXSYmKHR8PTgpLHR9dmFyIGJlPUFlKFNlKTtjbGFzcyAkdCBleHRlbmRzIGt0e3VwZGF0YU9wdFNlcnZpY2UoKXt9Y29uc3RydWN0b3IoZSx0KXtzdXBlcih0KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywic3luY1RpbWVzdGFtcCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ0b29sc1R5cGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpTdC5FcmFzZXJ9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidG1wUG9pbnRzIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6W119KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywid29ya09wdGlvbnMiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywicmVtb3ZlSWRzIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6W119KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywid29ybGRQb3NpdGlvbiIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ3b3JsZFNjYWxpbmciLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiZXJhc2VyUmVjdCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJlcmFzZXJQb2x5bGluZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJjdXJOb2RlTWFwIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6bmV3IE1hcH0pLHRoaXMud29ya09wdGlvbnM9ZSx0aGlzLnN5bmNUaW1lc3RhbXA9MCx0aGlzLndvcmxkUG9zaXRpb249dGhpcy5mdWxsTGF5ZXIud29ybGRQb3NpdGlvbix0aGlzLndvcmxkU2NhbGluZz10aGlzLmZ1bGxMYXllci53b3JsZFNjYWxpbmd9Y29tcHV0Tm9kZU1hcChlKXt0aGlzLmN1ck5vZGVNYXAuY2xlYXIoKSxlLmZvckVhY2godD0+e2NvbnN0IGk9dGhpcy5mdWxsTGF5ZXIuZ2V0RWxlbWVudHNCeU5hbWUodC5uYW1lKVswXSxvPXQub3BzJiZUZSh0Lm9wcyk7aWYoaSYmby5sZW5ndGgpe2NvbnN0IGc9W107Zm9yKGxldCBjPTA7YzxvLmxlbmd0aDtjKz0zKXtjb25zdCBmPW5ldyBodChvW2NdKnRoaXMud29ybGRTY2FsaW5nWzBdK3RoaXMud29ybGRQb3NpdGlvblswXSxvW2MrMV0qdGhpcy53b3JsZFNjYWxpbmdbMV0rdGhpcy53b3JsZFBvc2l0aW9uWzFdLG9bYysyXSk7Zy5wdXNoKGYpfWxldCB2PXQub3B0O2lmKCF2KXtsZXQgYz1pLmdldEF0dHJpYnV0ZSgic3Ryb2tlQ29sb3IiKTtjb25zdCBmPWkuY2xhc3NOYW1lLnNwbGl0KCIsIiksaD1OdW1iZXIoZlsyXSk7aS50YWdOYW1lPT09IkdST1VQIiYmKGg9PT1SdC5TdHJva2U/Yz1pLmdldEF0dHJpYnV0ZSgiYmdjb2xvciIpOmM9aS5jaGlsZHJlblswXS5nZXRBdHRyaWJ1dGUoInN0cm9rZUNvbG9yIikpO2NvbnN0IEU9aS5nZXRBdHRyaWJ1dGUoIm9wYWNpdHkiKSxsPWkuZ2V0QXR0cmlidXRlKCJzY2FsZSIpLG09aS5nZXRBdHRyaWJ1dGUoInpJbmRleCIpLHA9aS5nZXRBdHRyaWJ1dGUoInJvdGF0ZSIpLEM9dGhpcy53b3JrT3B0aW9ucy5zeW5jVW5pdFRpbWU7dj17Y29sb3I6YyxvcGFjaXR5OkUsc3luY1VuaXRUaW1lOkMsekluZGV4Om0sc2NhbGU6bCxyb3RhdGU6cCxzdHJva2VUeXBlOmh9fXRoaXMuY3VyTm9kZU1hcC5zZXQodC5uYW1lLHtuYW1lOnQubmFtZSxyZWN0OnQucmVjdCxwb2x5bGluZTpnLG9wdDp2LHRvb2xzVHlwZTp0LnRvb2xzVHlwZXx8U3QuUGVuY2lsfSl9fSl9dXBkYXRhTm9kZU1hcChlLHQpe2NvbnN0IGk9dC5vcCxvPVtdO2ZvcihsZXQgZz0wO2c8aS5sZW5ndGg7Zys9Myl7Y29uc3Qgdj1uZXcgaHQoaVtnXSp0aGlzLndvcmxkU2NhbGluZ1swXSt0aGlzLndvcmxkUG9zaXRpb25bMF0saVtnKzFdKnRoaXMud29ybGRTY2FsaW5nWzFdK3RoaXMud29ybGRQb3NpdGlvblsxXSxpW2crMl0pO28ucHVzaCh2KX10aGlzLmN1ck5vZGVNYXAuc2V0KGUse25hbWU6dC5uYW1lLHJlY3Q6dC5yZWN0LHBvbHlsaW5lOm8sb3B0OnQub3B0LHRvb2xzVHlwZTp0LnRvb2xzVHlwZXx8U3QuUGVuY2lsfSl9Y29tYmluZUNvbnN1bWUoKXt9Y3JlYXRlRXJhc2VyUmVjdChlKXtjb25zdCB0PWVbMF0qdGhpcy53b3JsZFNjYWxpbmdbMF0rdGhpcy53b3JsZFBvc2l0aW9uWzBdLGk9ZVsxXSp0aGlzLndvcmxkU2NhbGluZ1sxXSt0aGlzLndvcmxkUG9zaXRpb25bMV0se3dpZHRoOm8saGVpZ2h0Omd9PSR0LmVyYXNlclNpemVzW3RoaXMud29ya09wdGlvbnMudGhpY2tuZXNzXTt0aGlzLmVyYXNlclJlY3Q9e3g6dC1vKi41LHk6aS1nKi41LHc6byxoOmd9LHRoaXMuZXJhc2VyUG9seWxpbmU9W3RoaXMuZXJhc2VyUmVjdC54LHRoaXMuZXJhc2VyUmVjdC55LHRoaXMuZXJhc2VyUmVjdC54K3RoaXMuZXJhc2VyUmVjdC53LHRoaXMuZXJhc2VyUmVjdC55K3RoaXMuZXJhc2VyUmVjdC5oXX1jb25zdW1lU2VydmljZSgpe31zZXRXb3JrT3B0aW9ucyhlKXtzdXBlci5zZXRXb3JrT3B0aW9ucyhlKSx0aGlzLnN5bmNUaW1lc3RhbXA9RGF0ZS5ub3coKX1jb25zdW1lKGUpe2NvbnN0e29wOnQsd29ya1N0YXRlOml9PWUuZGF0YTtpZighdHx8dC5sZW5ndGg9PT0wKXJldHVybnt0eXBlOlR0Lk5vbmV9O2lmKGk9PT13dC5TdGFydCYmZS5ub2RlTWFwcyYmdGhpcy5jb21wdXROb2RlTWFwKGUubm9kZU1hcHMpLHRoaXMuaXNTYW1lUG9pbnQoW3RbMF0sdFsxXV0sW3RoaXMudG1wUG9pbnRzWzBdLHRoaXMudG1wUG9pbnRzWzFdXSkpcmV0dXJue3R5cGU6VHQuTm9uZX07aWYoZS5ub2RlTWFwcyl7dGhpcy50bXBQb2ludHM9dCx0aGlzLmNyZWF0ZUVyYXNlclJlY3QodCk7Y29uc3R7cmVjdDpvLHJlbW92ZUlkczpnLG5ld1dvcmtEYXRhczp2fT10aGlzLnJlbW92ZSgpO2lmKG8mJmcubGVuZ3RoKXJldHVybnt0eXBlOlR0LlJlbW92ZU5vZGUsZGF0YVR5cGU6Q3QuTG9jYWwscmVjdDpvLHJlbW92ZUlkczpnLG5ld1dvcmtEYXRhczp2fX1yZXR1cm57dHlwZTpUdC5Ob25lfX1jdXRQb2x5bGluZShlLHQpe2xldCBpPVt0XSxvPTA7Zm9yKDtvPGUubGVuZ3RoOyl7Y29uc3QgYz1lW29dO2lmKGMubGVuZ3RoPDIpYnJlYWs7aT1nKGksYyksbysrfXJldHVybiBpO2Z1bmN0aW9uIGcoYyxmKXtjb25zdCBoPWM7Zm9yKGxldCBFPTA7RTxjLmxlbmd0aDtFKyspe2NvbnN0IGw9Y1tFXSxtPWwuZmluZEluZGV4KChwLEMpPT5DPGwubGVuZ3RoLTE/dihbcCxsW0MrMV1dLFtmWzBdLGZbMV1dKTohMSk7aWYobSE9PS0xJiZtPi0xKXtjb25zdCBwPVtdLEM9bC5zbGljZSgwLG0rMSk7aWYoaHQuRXF1YWxzKGxbbV0sZlswXSl8fEMucHVzaChmWzBdLmNsb25lKCkuc2V0eihsW21dLnopKSxDLmxlbmd0aD4xJiZwLnB1c2goQyksbStmLmxlbmd0aC0xPGwubGVuZ3RoLTEpe2NvbnN0IHg9bStmLmxlbmd0aC0xLGQ9bC5zbGljZSh4KSx5PWZbZi5sZW5ndGgtMV07aHQuRXF1YWxzKGxbeF0seSl8fGQudW5zaGlmdCh5LmNsb25lKCkuc2V0eihsW3hdLnopKSxkLmxlbmd0aD4xJiZwLnB1c2goZCl9cmV0dXJuIGguc3BsaWNlKEUsMSwuLi5wKSxofX1yZXR1cm4gaH1mdW5jdGlvbiB2KGMsZil7Y29uc3QgaD1odC5TdWIoY1sxXSxjWzBdKSxFPWh0LlN1YihmWzFdLGZbMF0pLGw9aHQuU3ViKGZbMF0sY1swXSk7cmV0dXJuIE1hdGguYWJzKGh0LkNwcihoLEUpKTwuMSYmTWF0aC5hYnMoaHQuQ3ByKGgsbCkpPC4xfX1pc1NhbWVQb2ludChlLHQpe3JldHVybiBlWzBdPT09dFswXSYmZVsxXT09PXRbMV19dHJhbnNsYXRlSW50ZXJzZWN0KGUpe2NvbnN0IHQ9W107Zm9yKGxldCBpPTA7aTxlLmxlbmd0aDtpKyspe2NvbnN0IG89ZVtpXS5maWx0ZXIoKGMsZixoKT0+IShmPjAmJnRoaXMuaXNTYW1lUG9pbnQoYyxoW2YtMV0pKSksZz1bXTtsZXQgdj0wO2Zvcig7djxvLmxlbmd0aDspe2NvbnN0IGM9b1t2XSxmPW5ldyBodChjWzBdLGNbMV0pO2cucHVzaChmKSx2Kyt9dC5wdXNoKGcpfXJldHVybiB0fXJlbW92ZSgpe2NvbnN0e2lzTGluZTplfT10aGlzLndvcmtPcHRpb25zO2xldCB0O2NvbnN0IGk9W10sbz1bXSxnPVtdO3JldHVybiB0aGlzLmN1ck5vZGVNYXAuZm9yRWFjaCgodixjKT0+e2NvbnN0IGY9dGhpcy5mdWxsTGF5ZXIuZ2V0RWxlbWVudHNCeU5hbWUodi5uYW1lKVswXTtpZihmJiZ2LnJlY3QmJnRoaXMuZXJhc2VyUmVjdCYmdGhpcy5lcmFzZXJQb2x5bGluZSYmZ2UodGhpcy5lcmFzZXJSZWN0LHYucmVjdCkpe2lmKHYucG9seWxpbmUubGVuZ3RoPjEpe2NvbnN0IGg9YmUucG9seWxpbmUodi5wb2x5bGluZS5tYXAoRT0+RS5YWSksdGhpcy5lcmFzZXJQb2x5bGluZSk7aWYoaC5sZW5ndGgmJihvLnB1c2goZiksaS5wdXNoKHYubmFtZSksdGhpcy5yZW1vdmVJZHMucHVzaCh2Lm5hbWUpLCFlKSl7Y29uc3QgRT10aGlzLnRyYW5zbGF0ZUludGVyc2VjdChoKSxsPXRoaXMuY3V0UG9seWxpbmUoRSx2LnBvbHlsaW5lKTtmb3IobGV0IG09MDttPGwubGVuZ3RoO20rKyl7Y29uc3QgcD1gJHtjfV9zXyR7bX1gLEM9W107bFttXS5mb3JFYWNoKHg9PntDLnB1c2goKHgueC10aGlzLndvcmxkUG9zaXRpb25bMF0pL3RoaXMud29ybGRTY2FsaW5nWzBdLCh4LnktdGhpcy53b3JsZFBvc2l0aW9uWzFdKS90aGlzLndvcmxkU2NhbGluZ1sxXSx4LnopfSksZy5wdXNoKHt3b3JrSWQ6cCxvcDpDLG9wdDp2Lm9wdCx0b29sc1R5cGU6di50b29sc1R5cGV9KX19fWVsc2Ugby5wdXNoKGYpLGkucHVzaCh2Lm5hbWUpLHRoaXMucmVtb3ZlSWRzLnB1c2godi5uYW1lKTt0PWJ0KHQsdi5yZWN0KX19KSxvLmZvckVhY2godj0+di5yZW1vdmUoKSksdCYmKHQueC09JHQuU2FmZUJvcmRlclBhZGRpbmcsdC55LT0kdC5TYWZlQm9yZGVyUGFkZGluZyx0LncrPSR0LlNhZmVCb3JkZXJQYWRkaW5nKjIsdC5oKz0kdC5TYWZlQm9yZGVyUGFkZGluZyoyKSx7cmVjdDp0LHJlbW92ZUlkczppLG5ld1dvcmtEYXRhczpnfX1jb25zdW1lQWxsKGUpe3JldHVybiB0aGlzLmNvbnN1bWUoZSl9Y2xlYXJUbXBQb2ludHMoKXt0aGlzLnRtcFBvaW50cy5sZW5ndGg9MCx0aGlzLnN5bmNUaW1lc3RhbXA9MH19T2JqZWN0LmRlZmluZVByb3BlcnR5KCR0LCJTYWZlQm9yZGVyUGFkZGluZyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOjEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KCR0LCJlcmFzZXJTaXplcyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOk9iamVjdC5mcmVlemUoW09iamVjdC5mcmVlemUoe3dpZHRoOjE4LGhlaWdodDoyNn0pLE9iamVjdC5mcmVlemUoe3dpZHRoOjI2LGhlaWdodDozNH0pLE9iamVjdC5mcmVlemUoe3dpZHRoOjM0LGhlaWdodDo1MH0pXSl9KTtmdW5jdGlvbiBEZShSLGUsdCl7cmV0dXJuIiMiKygoUjw8MTYpKyhlPDw4KSt0KS50b1N0cmluZygxNikucGFkU3RhcnQoNiwiMCIpfWZ1bmN0aW9uIExlKFIpe2NvbnN0IGU9Ui5zcGxpdCgiLCIpLHQ9cGFyc2VJbnQoZVswXS5zcGxpdCgiKCIpWzFdKSxpPXBhcnNlSW50KGVbMV0pLG89cGFyc2VJbnQoZVsyXSksZz1wYXJzZUludChlWzNdLnNwbGl0KCIpIilbMF0pO3JldHVybltEZSh0LGksbyksZ119Y2xhc3MgdnQgZXh0ZW5kcyBrdHt1cGRhdGFPcHRTZXJ2aWNlKCl7fWNvbnN0cnVjdG9yKGUsdCxpKXtzdXBlcih0LGkpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ0bXBQb2ludHMiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpbXX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ0b29sc1R5cGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpTdC5TZWxlY3Rvcn0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ3b3JrT3B0aW9ucyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzeW5jVGltZXN0YW1wIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImN1ck5vZGVNYXAiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpuZXcgTWFwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInNlbGVjdElkcyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJvbGRSZWN0Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIm5vZGVDb2xvciIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJvbGRTZWxlY3RSZWN0Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIndvcmxkUG9zaXRpb24iLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywid29ybGRTY2FsaW5nIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksdGhpcy53b3JrT3B0aW9ucz1lLHRoaXMuc3luY1RpbWVzdGFtcD0wLHRoaXMud29ybGRQb3NpdGlvbj10aGlzLmZ1bGxMYXllci53b3JsZFBvc2l0aW9uLHRoaXMud29ybGRTY2FsaW5nPXRoaXMuZnVsbExheWVyLndvcmxkU2NhbGluZ31jb21wdXROb2RlTWFwKGUpe3RoaXMuY3VyTm9kZU1hcC5jbGVhcigpLGUuZm9yRWFjaCh0PT57Y29uc3QgaT10aGlzLmZ1bGxMYXllci5nZXRFbGVtZW50c0J5TmFtZSh0Lm5hbWUpWzBdO2lmKGkpe2NvbnN0IG89aS53b3JsZFBvc2l0aW9uO2xldCBnPWkuZ2V0QXR0cmlidXRlKCJzdHJva2VDb2xvciIpO2NvbnN0IHY9aS5jbGFzc05hbWUuc3BsaXQoIiwiKTtpLnRhZ05hbWU9PT0iR1JPVVAiJiYoTnVtYmVyKHZbMl0pPT09UnQuU3Ryb2tlP2c9aS5nZXRBdHRyaWJ1dGUoImJnY29sb3IiKTpnPWkuY2hpbGRyZW5bMF0uZ2V0QXR0cmlidXRlKCJzdHJva2VDb2xvciIpKSx0aGlzLmN1ck5vZGVNYXAuc2V0KHQubmFtZSx7bmFtZTp0Lm5hbWUscmVjdDp0LnJlY3QsY29sb3I6TGUoZylbMF0scG9zOm8scm90YXRlOmkuZ2V0QXR0cmlidXRlKCJyb3RhdGUiKXx8MCxzY2FsZTppLmdldEF0dHJpYnV0ZSgic2NhbGUiKXx8WzEsMV19KX19KX1jb21wdXRTZWxlY3Rvcigpe2xldCBlO2NvbnN0IHQ9W10saT1uZXcgTWFwLG89bmV3IFNldCxnPW5ldyBNYXA7aWYodGhpcy50bXBQb2ludHMubGVuZ3RoJiZ0aGlzLmN1ck5vZGVNYXAuc2l6ZSl7Y29uc3Qgdj1HdCh0aGlzLnRtcFBvaW50cyk7dGhpcy5jdXJOb2RlTWFwLmZvckVhY2goKGMsZik9Pntjb25zdCBoPXt4OmMucmVjdC54LHk6Yy5yZWN0LnksdzpjLnJlY3QudyxoOmMucmVjdC5ofSxFPXt4OnYueCx5OnYueSx3OnYudyxoOnYuaH07Z2UoRSxoKSYmKHQucHVzaChmKSxlPWJ0KGUsaCksaS5zZXQoZixoKSxvLmFkZChjLmNvbG9yKSxnLnNldChmLFsuLi5jLnBvcyxjLnJvdGF0ZV0pKX0pfXJldHVybntzZWxlY3RJZHM6dCxpbnRlcnNlY3RSZWN0OmUsc3ViUmVjdHM6aSxub2RlQ29sb3JzOm8sc3ViUG9zOmd9fXVwZGF0ZVRlbXBQb2ludHMoZSl7Y29uc3QgdD10aGlzLnRtcFBvaW50cy5sZW5ndGgsaT1lLmxlbmd0aDtpZihpPjEpe2NvbnN0IG89bmV3IEF0KGVbaS0yXSp0aGlzLndvcmxkU2NhbGluZ1swXSt0aGlzLndvcmxkUG9zaXRpb25bMF0sZVtpLTFdKnRoaXMud29ybGRTY2FsaW5nWzBdK3RoaXMud29ybGRQb3NpdGlvblsxXSk7dD09PTI/dGhpcy50bXBQb2ludHMuc3BsaWNlKDEsMSxvKTp0aGlzLnRtcFBvaW50cy5wdXNoKG8pfX1kcmF3KGUpe3ZhciBnLHYsYztjb25zdHtpbnRlcnNlY3RSZWN0OnQsc3ViUmVjdHM6aSxzdWJQb3M6b309ZTsoYz0odj0oZz10aGlzLmRyYXdMYXllcik9PW51bGw/dm9pZCAwOmcucGFyZW50KT09bnVsbD92b2lkIDA6di5nZXRFbGVtZW50QnlJZCh2dC5zZWxlY3RvcklkKSk9PW51bGx8fGMucmVtb3ZlKCksdCYmdGhpcy5kcmF3TGF5ZXImJnRoaXMuZHJhd1NlbGVjdG9yKHtkcmF3UmVjdDp0LHN1YlJlY3RzOmksc3ViUG9zOm8sc2VsZWN0b3JJZDp2dC5zZWxlY3RvcklkLGxheWVyOnRoaXMuZHJhd0xheWVyfSl9Y29uc3VtZShlKXtjb25zdHtvcDp0LHdvcmtTdGF0ZTppfT1lLmRhdGE7aWYoaT09PXd0LlN0YXJ0JiYodGhpcy5vbGRSZWN0PXRoaXMuYmFja1RvRnVsbExheWVyKCksZS5ub2RlTWFwcyYmdGhpcy5jb21wdXROb2RlTWFwKGUubm9kZU1hcHMpKSwhKHQhPW51bGwmJnQubGVuZ3RoKXx8IXRoaXMuY3VyTm9kZU1hcC5zaXplKXJldHVybnt0eXBlOlR0Lk5vbmV9O3RoaXMudXBkYXRlVGVtcFBvaW50cyh0KTtjb25zdCBvPXRoaXMuY29tcHV0U2VsZWN0b3IoKTtpZih0aGlzLnNlbGVjdElkcyYmRWUodGhpcy5zZWxlY3RJZHMsby5zZWxlY3RJZHMpKXJldHVybnt0eXBlOlR0Lk5vbmV9O3RoaXMuc2VsZWN0SWRzPW8uc2VsZWN0SWRzO2NvbnN0IGc9dGhpcy5kcmF3TGF5ZXImJnRoaXMuZ2V0U2VsZWN0b3JSZWN0KHRoaXMuZHJhd0xheWVyLHZ0LnNlbGVjdG9ySWQsITApLHY9by5pbnRlcnNlY3RSZWN0JiZ7eDpvLmludGVyc2VjdFJlY3QueC12dC5TZWxlY3RCb3JkZXJQYWRkaW5nLHk6by5pbnRlcnNlY3RSZWN0LnktdnQuU2VsZWN0Qm9yZGVyUGFkZGluZyx3Om8uaW50ZXJzZWN0UmVjdC53K3Z0LlNlbGVjdEJvcmRlclBhZGRpbmcqMixoOm8uaW50ZXJzZWN0UmVjdC5oK3Z0LlNlbGVjdEJvcmRlclBhZGRpbmcqMn18fHZvaWQgMDtyZXR1cm4gdGhpcy5vbGRSZWN0PWJ0KGcsdiksdGhpcy5kcmF3KG8pLHRoaXMubm9kZUNvbG9yPW8ubm9kZUNvbG9ycy5zaXplPT09MT9vLm5vZGVDb2xvcnMudmFsdWVzKCkubmV4dCgpLnZhbHVlOnZvaWQgMCx0aGlzLm9sZFNlbGVjdFJlY3Q9dix7dHlwZTpUdC5TZWxlY3QsZGF0YVR5cGU6Q3QuTG9jYWwscmVjdDp0aGlzLm9sZFJlY3Qsc2VsZWN0SWRzOm8uc2VsZWN0SWRzLG9wdDp0aGlzLndvcmtPcHRpb25zLHBhZGRpbmc6dnQuU2VsZWN0Qm9yZGVyUGFkZGluZyxzZWxlY3RSZWN0OnYsbm9kZUNvbG9yOnRoaXMubm9kZUNvbG9yLHdpbGxTeW5jU2VydmljZTohMH19Y29uc3VtZUFsbCgpe3ZhciBlO3JldHVybihlPXRoaXMuc2VsZWN0SWRzKSE9bnVsbCYmZS5sZW5ndGgmJnRoaXMuc2VhbFRvRHJhd0xheWVyKCksdGhpcy5vbGRTZWxlY3RSZWN0P3t0eXBlOlR0LlNlbGVjdCxkYXRhVHlwZTpDdC5Mb2NhbCxyZWN0OnRoaXMub2xkUmVjdCxzZWxlY3RJZHM6dGhpcy5zZWxlY3RJZHMsb3B0OnRoaXMud29ya09wdGlvbnMscGFkZGluZzp2dC5TZWxlY3RCb3JkZXJQYWRkaW5nLHNlbGVjdFJlY3Q6dGhpcy5vbGRTZWxlY3RSZWN0LG5vZGVDb2xvcjp0aGlzLm5vZGVDb2xvcix3aWxsU3luY1NlcnZpY2U6ITF9Ont0eXBlOlR0Lk5vbmV9fWNvbnN1bWVTZXJ2aWNlKCl7fWNvbWJpbmVDb25zdW1lKCl7fWNsZWFyVG1wUG9pbnRzKCl7dGhpcy50bXBQb2ludHMubGVuZ3RoPTB9Y2xlYXJTZWxlY3REYXRhKCl7dGhpcy5zZWxlY3RJZHM9dm9pZCAwLHRoaXMub2xkUmVjdD12b2lkIDAsdGhpcy5vbGRTZWxlY3RSZWN0PXZvaWQgMH1iYWNrVG9GdWxsTGF5ZXIoKXt2YXIgbztsZXQgZTtjb25zdCB0PVtdLGk9W107cmV0dXJuKG89dGhpcy5kcmF3TGF5ZXIpPT1udWxsfHxvLmNoaWxkcmVuLmZvckVhY2goZz0+e2lmKGcuaWQhPT12dC5zZWxlY3RvcklkKXtjb25zdCB2PWcuY2xvbmVOb2RlKCEwKTtpZih2LnRhZ05hbWU9PT0iR1JPVVAiKXtjb25zdCBmPWcuY2xhc3NOYW1lLnNwbGl0KCIsIik7Zi5sZW5ndGg9PT0zJiZOdW1iZXIoZlsyXSk9PT1SdC5TdHJva2UmJnYuc2VhbCgpfXQucHVzaCh2KSxpLnB1c2goZyk7Y29uc3QgYz1WdChnLm5hbWUsdGhpcy5kcmF3TGF5ZXIpO2MmJihlPWJ0KGUsYykpfX0pLGkuZm9yRWFjaChnPT5nLnJlbW92ZSgpKSx0Lmxlbmd0aCYmdGhpcy5mdWxsTGF5ZXIuYXBwZW5kKC4uLnQpLGUmJihlLngtPXZ0LlNlbGVjdEJvcmRlclBhZGRpbmcsZS55LT12dC5TZWxlY3RCb3JkZXJQYWRkaW5nLGUudys9dnQuU2VsZWN0Qm9yZGVyUGFkZGluZyoyLGUuaCs9dnQuU2VsZWN0Qm9yZGVyUGFkZGluZyoyKSxlfXNlYWxUb0RyYXdMYXllcigpe3ZhciBpLG87Y29uc3QgZT1bXSx0PVtdOyhpPXRoaXMuc2VsZWN0SWRzKT09bnVsbHx8aS5mb3JFYWNoKGc9Pnt0aGlzLmZ1bGxMYXllci5nZXRFbGVtZW50c0J5TmFtZShnLnRvU3RyaW5nKCkpLmZvckVhY2godj0+e2NvbnN0IGM9di5jbG9uZU5vZGUoITApO2lmKGMudGFnTmFtZT09PSJHUk9VUCIpe2NvbnN0IGY9di5jbGFzc05hbWUuc3BsaXQoIiwiKTtmLmxlbmd0aD09PTMmJk51bWJlcihmWzJdKT09PVJ0LlN0cm9rZSYmYy5zZWFsKCl9ZS5wdXNoKGMpLHQucHVzaCh2KX0pfSksdC5mb3JFYWNoKGc9PmcucmVtb3ZlKCkpLGUmJigobz10aGlzLmRyYXdMYXllcik9PW51bGx8fG8uYXBwZW5kKC4uLmUpKX11cGRhdGVTZWxlY3RvclNpemUoZSx0LGkpe2NvbnN0IG89bmV3IE1hcCxnPWUuZ2V0QXR0cmlidXRlKCJwb3MiKSx2PWUuY2xhc3NOYW1lLnNwbGl0KCIsIiksYz10LXZ0LlNlbGVjdEJvcmRlclBhZGRpbmcqMixmPWktdnQuU2VsZWN0Qm9yZGVyUGFkZGluZyoyLGg9di5sZW5ndGg9PT0yJiZbYy9OdW1iZXIodlswXSksZi9OdW1iZXIodlsxXSldfHxbMSwxXTtyZXR1cm4gZS5zZXRBdHRyaWJ1dGUoInNpemUiLFtjLGZdKSxlLmNoaWxkcmVuLmZvckVhY2goRT0+e2lmKEUuaWQ9PT12dC5zZWxlY3RvckJvcmRlcklkKUUuc2V0QXR0cmlidXRlKCJwb3MiLFtjLzIsZi8yXSksRS5zZXRBdHRyaWJ1dGUoIndpZHRoIixjKSxFLnNldEF0dHJpYnV0ZSgiaGVpZ2h0IixmKTtlbHNlIGlmKGgpe2NvbnN0IGw9RS5jbGFzc05hbWUuc3BsaXQoIiwiKSxtPVtOdW1iZXIobFswXSkqaFswXSxOdW1iZXIobFsxXSkqaFsxXV0scD1FLmdldEF0dHJpYnV0ZSgid2lkdGgiKSxDPUUuZ2V0QXR0cmlidXRlKCJoZWlnaHQiKSx4PU51bWJlcihsWzJdKSpoWzBdLGQ9TnVtYmVyKGxbM10pKmhbMV07RS5zZXRBdHRyaWJ1dGUoInBvcyIsbSksRS5zZXRBdHRyaWJ1dGUoIndpZHRoIix4KSxFLnNldEF0dHJpYnV0ZSgiaGVpZ2h0IixkKTtjb25zdCB5PUUuaWQuc3BsaXQoInNlbGVjdG9yLSIpWzFdO2lmKHkpe2NvbnN0IHI9W21bMF0rZ1swXSxtWzFdK2dbMV1dLHM9W3gvcCxkL0NdO28uc2V0KHksW3JbMF0sclsxXSxzWzBdLHNbMV1dKX19fSksb311cGRhdGVTZWxlY3RvclJlY3QoZSx0KXtjb25zdHt3OmksaDpvLHg6Zyx5OnZ9PXQsYz1pLXZ0LlNlbGVjdEJvcmRlclBhZGRpbmcqMixmPW8tdnQuU2VsZWN0Qm9yZGVyUGFkZGluZyoyLGg9Zyt2dC5TZWxlY3RCb3JkZXJQYWRkaW5nLEU9dit2dC5TZWxlY3RCb3JkZXJQYWRkaW5nO2Uuc2V0QXR0cmlidXRlKCJzaXplIixbaSxvXSksZS5zZXRBdHRyaWJ1dGUoInBvcyIsW2gsRV0pLGUuc2V0QXR0cmlidXRlKCJjbGFzc05hbWUiLGAke3Qud30sJHt0Lmh9YCksZS5jaGlsZHJlbi5mb3JFYWNoKGw9PntpZihsLnNldEF0dHJpYnV0ZSgicG9zIixbYy8yLGYvMl0pLGwuc2V0QXR0cmlidXRlKCJ3aWR0aCIsYyksbC5zZXRBdHRyaWJ1dGUoImhlaWdodCIsZiksbC5pZD09PXZ0LnNlbGVjdG9yQm9yZGVySWQpbC5zZXRBdHRyaWJ1dGUoImNsYXNzTmFtZSIsYCR7dC53LzJ9LCR7dC5oLzJ9LCR7dC53fSwke3QuaH1gKTtlbHNle2NvbnN0IG09bC5jbGFzc05hbWUuc3BsaXQoIiwiKSxwPW0mJk51bWJlcihtWzRdKXx8MDtsLnNldEF0dHJpYnV0ZSgiY2xhc3NOYW1lIixgJHtjLzJ9LCR7Zi8yfSwke3Qud30sJHt0Lmh9LCR7cH1gKX19KX1nZXRTZWxlY3RvclJlY3QoZSx0LGkpe3ZhciBmO2xldCBvO2NvbnN0IGc9KGY9ZS5wYXJlbnQpPT1udWxsP3ZvaWQgMDpmLmdldEVsZW1lbnRCeUlkKHQpLHY9Zz09bnVsbD92b2lkIDA6Zy5nZXRFbGVtZW50QnlJZCh2dC5zZWxlY3RvckJvcmRlcklkKSxjPXY9PW51bGw/dm9pZCAwOnYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7cmV0dXJuIGMmJihvPWJ0KG8se3g6TWF0aC5mbG9vcihjLngpLHk6TWF0aC5mbG9vcihjLnkpLHc6TWF0aC5yb3VuZChjLndpZHRoKSxoOk1hdGgucm91bmQoYy5oZWlnaHQpfSkpLG8mJmk/e3g6by54LXZ0LlNlbGVjdEJvcmRlclBhZGRpbmcseTpvLnktdnQuU2VsZWN0Qm9yZGVyUGFkZGluZyx3Om8udyt2dC5TZWxlY3RCb3JkZXJQYWRkaW5nKjIsaDpvLmgrdnQuU2VsZWN0Qm9yZGVyUGFkZGluZyoyfTpvfXVwZGF0ZVNlbGVjdG9yKGUpe3ZhciBmLGgsRTtjb25zdHt1cGRhdGVTZWxlY3Rvck9wdDp0LHNlbGVjdElkczppfT1lO2xldCBvO2NvbnN0IGc9bmV3IE1hcDtsZXQgdjtjb25zdCBjPShoPShmPXRoaXMuZHJhd0xheWVyKT09bnVsbD92b2lkIDA6Zi5wYXJlbnQpPT1udWxsP3ZvaWQgMDpoLmdldEVsZW1lbnRCeUlkKHZ0LnNlbGVjdG9ySWQpO2lmKGMpe2xldCBsO2lmKHQucG9zKXtjb25zdCBtPVt0LnBvc1swXSp0aGlzLndvcmxkU2NhbGluZ1swXSt0aGlzLndvcmxkUG9zaXRpb25bMF0sdC5wb3NbMV0qdGhpcy53b3JsZFNjYWxpbmdbMV0rdGhpcy53b3JsZFBvc2l0aW9uWzFdXSxwPWMuZ2V0QXR0cmlidXRlKCJwb3MiKTtsPVttWzBdLXBbMF0sbVsxXS1wWzFdXSxjLnNldEF0dHJpYnV0ZSgicG9zIixtKX1pZih0LnNlbGVjdG9yQ29sb3ImJigoRT1jLmdldEVsZW1lbnRCeUlkKHZ0LnNlbGVjdG9yQm9yZGVySWQpKT09bnVsbHx8RS5zZXRBdHRyaWJ1dGUoInN0cm9rZUNvbG9yIix0LnNlbGVjdG9yQ29sb3IpKSx0LnNpemUmJih2PXRoaXMudXBkYXRlU2VsZWN0b3JTaXplKGMsdC5zaXplLndpZHRoLHQuc2l6ZS5oZWlnaHQpKSx0LmFuZ2xlKWk9PW51bGx8fGkuZm9yRWFjaChtPT57dmFyIHA7KHA9dGhpcy5kcmF3TGF5ZXIpPT1udWxsfHxwLmdldEVsZW1lbnRzQnlOYW1lKG0pLmZvckVhY2goQz0+e2lmKEMpe2NvbnN0IHg9e3VzZUFuaW1hdGlvbjohMX07dC5hbmdsZSYmKHguYW5nbGU9dC5hbmdsZSx4Lm9yaWdpblBvcz1DLmNsYXNzTmFtZS5zcGxpdCgiLCIpLm1hcCh5PT5OdW1iZXIoeSkpLEMuc2V0QXR0cmlidXRlKCJyb3RhdGUiLHguYW5nbGUpKSxnLnNldChDLm5hbWUseCk7Y29uc3QgZD1WdChDLm5hbWUsdGhpcy5kcmF3TGF5ZXIpO289YnQobyxkKX19KX0sdGhpcyk7ZWxzZXtpPT1udWxsfHxpLmZvckVhY2goQz0+e3ZhciB4Oyh4PXRoaXMuZHJhd0xheWVyKT09bnVsbHx8eC5nZXRFbGVtZW50c0J5TmFtZShDKS5mb3JFYWNoKGQ9PntpZihkKXtjb25zdCB5PXt1c2VBbmltYXRpb246ITF9O2lmKHQucG9zJiZsKXtjb25zdCBzPWQuZ2V0QXR0cmlidXRlKCJwb3MiKTt5LnBvcz1bbFswXS90aGlzLndvcmxkU2NhbGluZ1swXStzWzBdLGxbMV0vdGhpcy53b3JsZFNjYWxpbmdbMF0rc1sxXV0seS5vcmlnaW5Qb3M9ZC5jbGFzc05hbWUuc3BsaXQoIiwiKS5tYXAobj0+TnVtYmVyKG4pKSxkLnNldEF0dHJpYnV0ZSgicG9zIix5LnBvcyl9aWYodC56SW5kZXhEaXN0YW5jZXx8dC56SW5kZXgpe2lmKHQuekluZGV4RGlzdGFuY2Upe2NvbnN0IHM9ZC5nZXRBdHRyaWJ1dGUoInpJbmRleCIpO3kuekluZGV4PXMrdC56SW5kZXhEaXN0YW5jZX1lbHNlIHkuekluZGV4PXQuekluZGV4O2Quc2V0QXR0cmlidXRlKCJ6SW5kZXgiLHkuekluZGV4KX1pZih0LmNvbG9yKXt5LmNvbG9yPXQuY29sb3I7Y29uc3Qgcz1kLmNsYXNzTmFtZS5zcGxpdCgiLCIpO2QudGFnTmFtZT09PSJHUk9VUCI/TnVtYmVyKHNbMl0pPT09UnQuU3Ryb2tlP2Quc2V0QXR0cmlidXRlKCJiZ2NvbG9yIix5LmNvbG9yKTpkLmNoaWxkcmVuLmZvckVhY2gobj0+e24uc2V0QXR0cmlidXRlKCJzdHJva2VDb2xvciIseS5jb2xvcil9KTpkLnRhZ05hbWU9PT0iUEFUSCImJihkLnNldEF0dHJpYnV0ZSgic3Ryb2tlQ29sb3IiLHkuY29sb3IpLGQuZ2V0QXR0cmlidXRlKCJmaWxsQ29sb3IiKSYmZC5zZXRBdHRyaWJ1dGUoImZpbGxDb2xvciIseS5jb2xvcikpfXQub3BhY2l0eSYmKHkub3BhY2l0eT10Lm9wYWNpdHksZC5zZXRBdHRyaWJ1dGUoIm9wYWNpdHkiLHkub3BhY2l0eSkpO2NvbnN0IHI9dj09bnVsbD92b2lkIDA6di5nZXQoZC5uYW1lKTtpZihyKXtjb25zdCBzPWQuZ2V0QXR0cmlidXRlKCJzY2FsZSIpLG49W3JbMl0qc1swXSxyWzNdKnNbMV1dO3kub3JpZ2luUG9zPWQuY2xhc3NOYW1lLnNwbGl0KCIsIikubWFwKGE9Pk51bWJlcihhKSkseS5wb3M9WyhyWzBdLXRoaXMud29ybGRQb3NpdGlvblswXSkvdGhpcy53b3JsZFNjYWxpbmdbMF0sKHJbMV0tdGhpcy53b3JsZFBvc2l0aW9uWzFdKS90aGlzLndvcmxkU2NhbGluZ1sxXV0seS5zY2FsZT1uLGQuc2V0QXR0cmlidXRlKCJwb3MiLHkucG9zKSxkLnNldEF0dHJpYnV0ZSgic2NhbGUiLHkuc2NhbGUpfWcuc2V0KGQubmFtZSx5KX19KX0sdGhpcyk7Y29uc3QgbT1jLmdldEVsZW1lbnRCeUlkKHZ0LnNlbGVjdG9yQm9yZGVySWQpLHA9bT09bnVsbD92b2lkIDA6bS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtwJiYobz1idChvLHt4Ok1hdGguZmxvb3IocC54KSx5Ok1hdGguZmxvb3IocC55KSx3Ok1hdGgucm91bmQocC53aWR0aCksaDpNYXRoLnJvdW5kKHAuaGVpZ2h0KX0pKX19aWYobylyZXR1cm4gby54LT12dC5TZWxlY3RCb3JkZXJQYWRkaW5nLG8ueS09dnQuU2VsZWN0Qm9yZGVyUGFkZGluZyxvLncrPXZ0LlNlbGVjdEJvcmRlclBhZGRpbmcqMixvLmgrPXZ0LlNlbGVjdEJvcmRlclBhZGRpbmcqMix0LmFuZ2xlJiZ0aGlzLnVwZGF0ZVNlbGVjdG9yUmVjdChjLG8pLHRoaXMub2xkUmVjdD1idCh0aGlzLm9sZFJlY3QsbyksdGhpcy5vbGRTZWxlY3RSZWN0PW8se3R5cGU6VHQuVXBkYXRlTm9kZSxkYXRhVHlwZTpDdC5Mb2NhbCxyZWN0Om8sdXBkYXRlTm9kZU9wdHM6Z319Ymx1clNlbGVjdG9yKCl7Y29uc3QgZT10aGlzLmJhY2tUb0Z1bGxMYXllcigpO3JldHVybnt0eXBlOlR0LlNlbGVjdCxkYXRhVHlwZTpDdC5Mb2NhbCxyZWN0OmUsc2VsZWN0SWRzOltdLHdpbGxTeW5jU2VydmljZTohMH19Z2V0UmlnaHRTZXJ2aWNlSWQoZSl7cmV0dXJuIGUucmVwbGFjZSgiKysrKyIsIi0iKX1kcmF3U2VsZWN0b3IoZSl7Y29uc3R7ZHJhd1JlY3Q6dCxzdWJSZWN0czppLHN1YlBvczpvLHNlbGVjdG9ySWQ6ZyxsYXllcjp2fT1lLGM9bmV3IHJlKHtwb3M6W3QueCx0LnldLGFuY2hvcjpbMCwwXSxzaXplOlt0LncsdC5oXSxjbGFzc05hbWU6YCR7dC53fSwke3QuaH1gLGlkOmcsbmFtZTp2dC5zZWxlY3RvcklkLHpJbmRleDoxZTN9KSxmPVtdLGg9bmV3IHVlKHtub3JtYWxpemU6ITAscG9zOlt0LncvMix0LmgvMl0sbGluZVdpZHRoOjEsc3Ryb2tlQ29sb3I6dGhpcy53b3JrT3B0aW9ucy5jb2xvcix3aWR0aDp0LncsaGVpZ2h0OnQuaCxjbGFzc05hbWU6YCR7dC53LzJ9LCR7dC5oLzJ9LCR7dC53fSwke3QuaH1gLGlkOnZ0LnNlbGVjdG9yQm9yZGVySWR9KTtmLnB1c2goaCksaS5mb3JFYWNoKChFLGwpPT57Y29uc3QgbT1vPT1udWxsP3ZvaWQgMDpvLmdldChsKTtpZihtKXtjb25zdCBwPVttWzBdLXQueCxtWzFdLXQueV0sQz1gJHtwWzBdfSwke3BbMV19LCR7RS53fSwke0UuaH0sJHttWzJdfWAseD1uZXcgdWUoe25vcm1hbGl6ZTohMCxwb3M6cCxsaW5lV2lkdGg6MSxzdHJva2VDb2xvcjppLnNpemU+MT90aGlzLndvcmtPcHRpb25zLmNvbG9yOnZvaWQgMCx3aWR0aDpFLncsaGVpZ2h0OkUuaCxjbGFzc05hbWU6QyxpZDpgc2VsZWN0b3ItJHtsfWAsbmFtZTpgc2VsZWN0b3ItJHtsfWB9KTtmLnB1c2goeCl9fSksZiYmYy5hcHBlbmQoLi4uZiksKHY9PW51bGw/dm9pZCAwOnYucGFyZW50KS5hcHBlbmRDaGlsZChjKX1zZWxlY3RTZXJ2aWNlTm9kZShlLHQsaSl7dmFyIEU7Y29uc3R7c2VsZWN0SWRzOm99PXQsZz10aGlzLmdldFJpZ2h0U2VydmljZUlkKGUpLHY9dGhpcy5nZXRTZWxlY3RvclJlY3QodGhpcy5mdWxsTGF5ZXIsZywhMCk7KEU9dGhpcy5mdWxsTGF5ZXIucGFyZW50LmdldEVsZW1lbnRCeUlkKGcpKT09bnVsbHx8RS5yZW1vdmUoKTtsZXQgYztjb25zdCBmPW5ldyBNYXAsaD1uZXcgTWFwO3JldHVybiBvPT1udWxsfHxvLmZvckVhY2gobD0+e3ZhciBDO2NvbnN0IG09aS5nZXQobCkscD10aGlzLmZ1bGxMYXllci5nZXRFbGVtZW50c0J5TmFtZShsKVswXTtpZihtJiZwKXtjPWJ0KGMsbS5yZWN0KSxmLnNldChsLG0ucmVjdCk7Y29uc3QgeD1wLndvcmxkUG9zaXRpb24sZD0oKEM9bS5vcHQpPT1udWxsP3ZvaWQgMDpDLnJvdGF0ZSl8fHAuZ2V0QXR0cmlidXRlKCJyb3RhdGUiKXx8MDtoLnNldChsLFsuLi54LGRdKX19KSxjJiZ0aGlzLmZ1bGxMYXllciYmdGhpcy5kcmF3U2VsZWN0b3Ioe2RyYXdSZWN0OmMsc3ViUmVjdHM6ZixzdWJQb3M6aCxzZWxlY3RvcklkOmcsbGF5ZXI6dGhpcy5mdWxsTGF5ZXJ9KSxjPWJ0KGMsdiksYyYmKGMueC09dnQuU2VsZWN0Qm9yZGVyUGFkZGluZyxjLnktPXZ0LlNlbGVjdEJvcmRlclBhZGRpbmcsYy53Kz12dC5TZWxlY3RCb3JkZXJQYWRkaW5nKjIsYy5oKz12dC5TZWxlY3RCb3JkZXJQYWRkaW5nKjIpLGN9cmVtb3ZlU2VydmljZSgpe3Rocm93IG5ldyBFcnJvcigiTWV0aG9kIG5vdCBpbXBsZW1lbnRlZC4iKX1nZXRTZWxlY3RvcihlKXt2YXIgZztsZXQgdDtjb25zdCBpPW5ldyBNYXAsbz1uZXcgTWFwO3JldHVybihnPXRoaXMuc2VsZWN0SWRzKT09bnVsbHx8Zy5mb3JFYWNoKHY9Pnt2YXIgaDtjb25zdCBjPWUuZ2V0KHYpLGY9KGg9dGhpcy5kcmF3TGF5ZXIpPT1udWxsP3ZvaWQgMDpoLmdldEVsZW1lbnRzQnlOYW1lKHYpWzBdO2lmKGMmJmYpe2NvbnN0IEU9Zi53b3JsZFBvc2l0aW9uLGw9Zi5nZXRBdHRyaWJ1dGUoInJvdGF0ZSIpfHwwO3Q9YnQodCxjLnJlY3QpLGkuc2V0KHYsYy5yZWN0KSxvLnNldCh2LFsuLi5FLGxdKX19LHRoaXMpLHRoaXMub2xkUmVjdD1idCh0LHRoaXMub2xkUmVjdCksdGhpcy5kcmF3KHtpbnRlcnNlY3RSZWN0OnQsc3ViUmVjdHM6aSxzdWJQb3M6b30pLHRoaXMub2xkU2VsZWN0UmVjdD10LHR9fU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh2dCwic2VsZWN0b3JJZCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOiJzZWxlY3RvciJ9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodnQsInNlbGVjdG9yQm9yZGVySWQiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZToic2VsZWN0b3ItYm9yZGVyIn0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh2dCwiU2VsZWN0Qm9yZGVyUGFkZGluZyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOjJ9KTtjbGFzcyBJZSBleHRlbmRzIGt0e3VwZGF0YU9wdFNlcnZpY2UoKXt9Y29uc3RydWN0b3IoZSx0KXtzdXBlcih0KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywic3luY1RpbWVzdGFtcCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzeW5jSW5kZXgiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTowfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInRvb2xzVHlwZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOlN0Lkxhc2VyUGVufSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInRtcFBvaW50cyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOltdfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIndvcmtPcHRpb25zIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImNvbnN1bWVJbmRleCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOjB9KSx0aGlzLndvcmtPcHRpb25zPWUsdGhpcy5zeW5jVGltZXN0YW1wPTB9Y29tYmluZUNvbnN1bWUoKXt9c2V0V29ya09wdGlvbnMoZSl7c3VwZXIuc2V0V29ya09wdGlvbnMoZSksdGhpcy5zeW5jVGltZXN0YW1wPURhdGUubm93KCl9Y29uc3VtZShlKXtjb25zdHtkYXRhOnQsaXNGdWxsV29yazppfT1lLHt3b3JrSWQ6byxvcDpnfT10O2lmKChnPT1udWxsP3ZvaWQgMDpnLmxlbmd0aCk9PT0wKXJldHVybnt0eXBlOlR0Lk5vbmV9O2lmKHRoaXMudXBkYXRlVGVtcFBvaW50cyhnfHxbXSksdGhpcy5jb25zdW1lSW5kZXg+dGhpcy50bXBQb2ludHMubGVuZ3RoLTQpcmV0dXJue3R5cGU6VHQuTm9uZX07Y29uc3R7Y29sb3I6dix0aGlja25lc3M6YyxzdHJva2VUeXBlOmYsb3BhY2l0eTpofT10aGlzLndvcmtPcHRpb25zLEU9R3QodGhpcy50bXBQb2ludHMsYyk7bGV0IGw9ITE7Y29uc3QgbT10aGlzLnN5bmNJbmRleCxwPXRoaXMudG1wUG9pbnRzLnNsaWNlKHRoaXMuY29uc3VtZUluZGV4KTt0aGlzLmNvbnN1bWVJbmRleD10aGlzLnRtcFBvaW50cy5sZW5ndGgtMSx0aGlzLnN5bmNUaW1lc3RhbXA9PT0wJiYodGhpcy5zeW5jVGltZXN0YW1wPURhdGUubm93KCkpO2NvbnN0IEM9e25hbWU6bz09bnVsbD92b2lkIDA6by50b1N0cmluZygpLGNsYXNzTmFtZToiTGFzZXJQZW4iLG9wYWNpdHk6aHx8MSxsaW5lRGFzaDpmPT09UnQuRG90dGVkP1sxLGMqMl06Zj09PVJ0LkxvbmdEb3R0ZWQ/W2MsYyoyXTp2b2lkIDAsc3Ryb2tlQ29sb3I6dixsaW5lQ2FwOiJyb3VuZCIsbGluZVdpZHRoOmMsYW5jaG9yOlsuNSwuNV19LHg9dGhpcy5nZXRUYXNrUG9pbnRzKHApO2lmKHgubGVuZ3RoKXtjb25zdCB5PURhdGUubm93KCk7eS10aGlzLnN5bmNUaW1lc3RhbXA+dGhpcy5zeW5jVW5pdFRpbWUmJihsPSEwLHRoaXMuc3luY1RpbWVzdGFtcD15LHRoaXMuc3luY0luZGV4PXRoaXMudG1wUG9pbnRzLmxlbmd0aCksIWkmJnRoaXMuZHJhdyh7YXR0cnM6Qyx0YXNrczp4LGlzRG90OiExfSl9Y29uc3QgZD1bXTtyZXR1cm4gdGhpcy50bXBQb2ludHMuc2xpY2UobSkuZm9yRWFjaCh5PT57ZC5wdXNoKHkueCx5LnkpfSkse3JlY3Q6e3g6RS54KnRoaXMuZnVsbExheWVyLndvcmxkU2NhbGluZ1swXSt0aGlzLmZ1bGxMYXllci53b3JsZFBvc2l0aW9uWzBdLHk6RS55KnRoaXMuZnVsbExheWVyLndvcmxkU2NhbGluZ1sxXSt0aGlzLmZ1bGxMYXllci53b3JsZFBvc2l0aW9uWzFdLHc6RS53KnRoaXMuZnVsbExheWVyLndvcmxkU2NhbGluZ1swXSxoOkUuaCp0aGlzLmZ1bGxMYXllci53b3JsZFNjYWxpbmdbMV19LHR5cGU6VHQuRHJhd1dvcmssZGF0YVR5cGU6Q3QuTG9jYWwsd29ya0lkOmw/bzp2b2lkIDAsb3A6bD9kOnZvaWQgMCxpbmRleDpsP20qMjp2b2lkIDB9fWNvbnN1bWVBbGwoKXt2YXIgbztjb25zdCBlPShvPXRoaXMud29ya0lkKT09bnVsbD92b2lkIDA6by50b1N0cmluZygpO2xldCB0O2lmKHRoaXMudG1wUG9pbnRzLmxlbmd0aC0xPnRoaXMuY29uc3VtZUluZGV4KXtsZXQgZz10aGlzLnRtcFBvaW50cy5zbGljZSh0aGlzLmNvbnN1bWVJbmRleCk7Y29uc3Qgdj1nLmxlbmd0aD09PTEse2NvbG9yOmMsdGhpY2tuZXNzOmYsc3Ryb2tlVHlwZTpoLG9wYWNpdHk6RX09dGhpcy53b3JrT3B0aW9ucztpZih2KXtjb25zdCBwPXRoaXMuY29tcHV0RG90U3Ryb2tlKHtwb2ludDpnWzBdLHJhZGl1czpmLzJ9KTtnPXAucHMsdD1wLnJlY3R9ZWxzZSB0PUd0KHRoaXMudG1wUG9pbnRzLGYpO2NvbnN0IGw9e25hbWU6ZT09bnVsbD92b2lkIDA6ZS50b1N0cmluZygpLGNsYXNzTmFtZToiTGFzZXJQZW4iLGZpbGxDb2xvcjp2P2M6dm9pZCAwLG9wYWNpdHk6RXx8MSxsaW5lRGFzaDpoPT09UnQuRG90dGVkJiYhdj9bMSxmKjJdOmg9PT1SdC5Mb25nRG90dGVkJiYhdj9bZixmKjJdOnZvaWQgMCxzdHJva2VDb2xvcjpjLGxpbmVDYXA6dj92b2lkIDA6InJvdW5kIixsaW5lV2lkdGg6dj8wOmYsYW5jaG9yOlsuNSwuNV19LG09dGhpcy5nZXRUYXNrUG9pbnRzKGcpO20ubGVuZ3RoJiZ0aGlzLmRyYXcoe2F0dHJzOmwsdGFza3M6bSxpc0RvdDp2fSl9Y29uc3QgaT1bXTtyZXR1cm4gdGhpcy50bXBQb2ludHMuc2xpY2UodGhpcy5zeW5jSW5kZXgpLmZvckVhY2goZz0+e2kucHVzaChnLngsZy55KX0pLHtyZWN0OnQmJnt4OnQueCp0aGlzLmZ1bGxMYXllci53b3JsZFNjYWxpbmdbMF0rdGhpcy5mdWxsTGF5ZXIud29ybGRQb3NpdGlvblswXSx5OnQueSp0aGlzLmZ1bGxMYXllci53b3JsZFNjYWxpbmdbMV0rdGhpcy5mdWxsTGF5ZXIud29ybGRQb3NpdGlvblsxXSx3OnQudyp0aGlzLmZ1bGxMYXllci53b3JsZFNjYWxpbmdbMF0saDp0LmgqdGhpcy5mdWxsTGF5ZXIud29ybGRTY2FsaW5nWzFdfSx0eXBlOlR0LkRyYXdXb3JrLGRhdGFUeXBlOkN0LkxvY2FsLHdvcmtJZDplLG9wOmksaW5kZXg6dGhpcy5zeW5jSW5kZXgqMn19Y2xlYXJUbXBQb2ludHMoKXt0aGlzLnRtcFBvaW50cy5sZW5ndGg9MCx0aGlzLnN5bmNUaW1lc3RhbXA9MCx0aGlzLnN5bmNJbmRleD0wfWNvbnN1bWVTZXJ2aWNlKGUpe3ZhciBwO2NvbnN0e29wOnR9PWUse2NvbG9yOmksdGhpY2tuZXNzOm8sc3Ryb2tlVHlwZTpnLG9wYWNpdHk6dn09dGhpcy53b3JrT3B0aW9ucztpZighdC5sZW5ndGgpe2NvbnN0IEM9R3QodGhpcy50bXBQb2ludHMsbyk7cmV0dXJue3g6Qy54KnRoaXMuZnVsbExheWVyLndvcmxkU2NhbGluZ1swXSt0aGlzLmZ1bGxMYXllci53b3JsZFBvc2l0aW9uWzBdLHk6Qy55KnRoaXMuZnVsbExheWVyLndvcmxkU2NhbGluZ1sxXSt0aGlzLmZ1bGxMYXllci53b3JsZFBvc2l0aW9uWzFdLHc6Qy53KnRoaXMuZnVsbExheWVyLndvcmxkU2NhbGluZ1swXSxoOkMuaCp0aGlzLmZ1bGxMYXllci53b3JsZFNjYWxpbmdbMV19fWNvbnN0IGM9TWF0aC5tYXgoMCx0aGlzLnRtcFBvaW50cy5sZW5ndGgtMSk7dGhpcy51cGRhdGVUZW1wUG9pbnRzKHR8fFtdKTtsZXQgZixoPXRoaXMudG1wUG9pbnRzLnNsaWNlKGMpO2NvbnN0IEU9aC5sZW5ndGg9PT0xO2lmKEUpe2NvbnN0IEM9dGhpcy5jb21wdXREb3RTdHJva2Uoe3BvaW50OmhbMF0scmFkaXVzOm8vMn0pO2g9Qy5wcyxmPUMucmVjdH1lbHNlIGY9R3QodGhpcy50bXBQb2ludHMsbyk7Y29uc3QgbD17bmFtZToocD10aGlzLndvcmtJZCk9PW51bGw/dm9pZCAwOnAudG9TdHJpbmcoKSxjbGFzc05hbWU6Ikxhc2VyUGVuIixmaWxsQ29sb3I6RT9pOnZvaWQgMCxvcGFjaXR5OnZ8fDEsbGluZURhc2g6Zz09PVJ0LkRvdHRlZCYmIUU/WzEsbyoyXTpnPT09UnQuTG9uZ0RvdHRlZCYmIUU/W28sbyoyXTp2b2lkIDAsc3Ryb2tlQ29sb3I6aSxsaW5lQ2FwOkU/dm9pZCAwOiJyb3VuZCIsbGluZVdpZHRoOkU/MDpvLGFuY2hvcjpbLjUsLjVdfSxtPXRoaXMuZ2V0VGFza1BvaW50cyhoKTtyZXR1cm4gbS5sZW5ndGgmJnRoaXMuZHJhdyh7YXR0cnM6bCx0YXNrczptLGlzRG90OkV9KSx7eDpmLngqdGhpcy5mdWxsTGF5ZXIud29ybGRTY2FsaW5nWzBdK3RoaXMuZnVsbExheWVyLndvcmxkUG9zaXRpb25bMF0seTpmLnkqdGhpcy5mdWxsTGF5ZXIud29ybGRTY2FsaW5nWzFdK3RoaXMuZnVsbExheWVyLndvcmxkUG9zaXRpb25bMV0sdzpmLncqdGhpcy5mdWxsTGF5ZXIud29ybGRTY2FsaW5nWzBdLGg6Zi5oKnRoaXMuZnVsbExheWVyLndvcmxkU2NhbGluZ1sxXX19Y29tcHV0RG90U3Ryb2tlKGUpe2NvbnN0e3BvaW50OnQscmFkaXVzOml9PWUsbz17eDp0LngtaSx5OnQueS1pLHc6aSoyLGg6aSoyfTtyZXR1cm57cHM6QXQuR2V0RG90U3Ryb2tlKHQsaSw4KSxyZWN0Om99fXVwZGF0ZVRlbXBQb2ludHMoZSl7Y29uc3QgdD10aGlzLnRtcFBvaW50cy5sZW5ndGg7Zm9yKGxldCBpPTA7aTxlLmxlbmd0aDtpKz0yKXtpZih0KXtjb25zdCBvPXRoaXMudG1wUG9pbnRzLnNsaWNlKC0xKVswXTtvJiZvLng9PT1lW2ldJiZvLnk9PT1lW2krMV0mJnRoaXMudG1wUG9pbnRzLnBvcCgpfXRoaXMudG1wUG9pbnRzLnB1c2gobmV3IEF0KGVbaV0sZVtpKzFdKSl9fWFzeW5jIGRyYXcoZSl7Y29uc3R7YXR0cnM6dCx0YXNrczppLGlzRG90Om99PWUsZz10aGlzLmZ1bGxMYXllcix7ZHVyYXRpb246dn09dGhpcy53b3JrT3B0aW9ucyxjPW5ldyBuZTtmb3IobGV0IGY9MDtmPGkubGVuZ3RoO2YrKyl7Y29uc3R7cG9zOmgscG9pbnRzOkV9PWlbZl07bGV0IGw7bz9sPXRlKEUsITApOmw9dGUoRSwhMSksYy5hdHRyKHsuLi50LHBvczpoLGQ6bH0pO2NvbnN0e3ZlcnRleDptLGZyYWdtZW50OnB9PXRoaXMud29ya09wdGlvbnM7aWYobSYmcCl7Y29uc3QgQz1nLnJlbmRlcmVyLmNyZWF0ZVByb2dyYW0oe3ZlcnRleDptLGZyYWdtZW50OnB9KSx7d2lkdGg6eCxoZWlnaHQ6ZH09Zy5nZXRSZXNvbHV0aW9uKCk7Yy5zZXRVbmlmb3Jtcyh7dV90aW1lOjAsdV9yZXNvbHV0aW9uOlt4LGRdfSksYy5zZXRQcm9ncmFtKEMpfWcuYXBwZW5kQ2hpbGQoYyksYXdhaXQgYy50cmFuc2l0aW9uKHYpLmF0dHIoe3NjYWxlOm8/Wy4xLC4xXTpbMSwxXSxsaW5lV2lkdGg6bz8wOjF9KSxjLnJlbW92ZSgpfX1nZXRUYXNrUG9pbnRzKGUpe3ZhciBmO2NvbnN0IHQ9W107aWYoZS5sZW5ndGg9PT0wKXJldHVybltdO2xldCBpPTAsbz1lWzBdLngsZz1lWzBdLnksdj1bbyxnXSxjPVtdO2Zvcig7aTxlLmxlbmd0aDspe2NvbnN0IGg9ZVtpXSxFPWgueC1vLGw9aC55LWc7aWYoYy5wdXNoKG5ldyBBdChFLGwpKSxpPjAmJmk8ZS5sZW5ndGgtMSl7Y29uc3QgbT1lW2ldLmdldEFuZ2xlQnlQb2ludHMoZVtpLTFdLGVbaSsxXSk7aWYobTw5MHx8bT4yNzApe2NvbnN0IHA9KGY9Yy5wb3AoKSk9PW51bGw/dm9pZCAwOmYuY2xvbmUoKTtwJiZ0LnB1c2goe3Bvczp2LHBvaW50czpbLi4uYyxwXX0pLG89ZVtpXS54LGc9ZVtpXS55LHY9W28sZ107Y29uc3QgQz1oLngtbyx4PWgueS1nO2M9W25ldyBBdChDLHgpXX19aSsrfXJldHVybiB0LnB1c2goe3Bvczp2LHBvaW50czpjfSksdH1yZW1vdmVMb2NhbCgpe31yZW1vdmVTZXJ2aWNlKGUpe2xldCB0O2NvbnN0IGk9W107cmV0dXJuIHRoaXMuZnVsbExheWVyLmdldEVsZW1lbnRzQnlOYW1lKGUpLmZvckVhY2gobz0+e2lmKG8ubmFtZT09PWUpe2NvbnN0IGc9by5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTt0PWJ0KHQse3g6Zy54LHk6Zy55LHc6Zy53aWR0aCxoOmcuaGVpZ2h0fSksaS5wdXNoKG8pfX0pLGkubGVuZ3RoJiZpLmZvckVhY2gobz0+by5yZW1vdmUoKSksdH19Y2xhc3MgTmV7Y29uc3RydWN0b3IoKXtPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiY3VyTm9kZU1hcCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOm5ldyBNYXB9KX11cGRhdGVTY2VuZShlKXt0aGlzLnNjZW5lLmF0dHIoey4uLmV9KTtjb25zdHt3aWR0aDp0LGhlaWdodDppfT1lO3RoaXMuc2NlbmUuY29udGFpbmVyLndpZHRoPXQsdGhpcy5zY2VuZS5jb250YWluZXIuaGVpZ2h0PWksdGhpcy5zY2VuZS53aWR0aD10LHRoaXMuc2NlbmUuaGVpZ2h0PWksdGhpcy51cGRhdGVMYXllcih7d2lkdGg6dCxoZWlnaHQ6aX0pfXVwZGF0ZUxheWVyKGUpe3ZhciBvLGcsdixjO2NvbnN0e3dpZHRoOnQsaGVpZ2h0Oml9PWU7KG89dGhpcy5mdWxsTGF5ZXIpPT1udWxsfHxvLnNldEF0dHJpYnV0ZSgic2l6ZSIsW3QsaV0pLChnPXRoaXMuZnVsbExheWVyKT09bnVsbHx8Zy5zZXRBdHRyaWJ1dGUoInBvcyIsW3QqLjUsaSouNV0pLCh2PXRoaXMuZHJhd0xheWVyKT09bnVsbHx8di5zZXRBdHRyaWJ1dGUoInNpemUiLFt0LGldKSwoYz10aGlzLmRyYXdMYXllcik9PW51bGx8fGMuc2V0QXR0cmlidXRlKCJwb3MiLFt0Ki41LGkqLjVdKX1jcmVhdGVTY2VuZShlKXtjb25zdHt3aWR0aDp0LGhlaWdodDppfT1lLG89bmV3IE9mZnNjcmVlbkNhbnZhcyh0LGkpO3JldHVybiBuZXcgcGUoe2NvbnRhaW5lcjpvLGRpc3BsYXlSYXRpbzp0aGlzLmRwcixkZXB0aDohMSxkZXN5bmNocm9uaXplZDohMCwuLi5lfSl9Y3JlYXRlTGF5ZXIoZSl7Y29uc3R7d2lkdGg6dCxoZWlnaHQ6aX09ZSxvPSJvZmZzY3JlZW4iK0RhdGUubm93KCksZz10aGlzLnNjZW5lLmxheWVyKG8sZSksdj1uZXcgcmUoe2FuY2hvcjpbLjUsLjVdLHBvczpbdCouNSxpKi41XSxzaXplOlt0LGldLG5hbWU6InZpZXdwb3J0In0pO3JldHVybiBnLmFwcGVuZCh2KSx2fWdldE5vZGVzKGUpe3JldHVybiB0aGlzLmZ1bGxMYXllci5nZXRFbGVtZW50c0J5TmFtZShlKyIiKS5jb25jYXQodGhpcy5kcmF3TGF5ZXIuZ2V0RWxlbWVudHNCeU5hbWUoZSsiIikpfX1jbGFzcyBCZXtjb25zdHJ1Y3RvcihlLHQsaSl7T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImZ1bGxMYXllciIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJkcmF3TGF5ZXIiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiY3VyTm9kZU1hcCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ0bXBXb3JrU2hhcGVOb2RlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInRtcE9wdCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJlZmZlY3RXb3JrSWQiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSx0aGlzLmN1ck5vZGVNYXA9ZSx0aGlzLmZ1bGxMYXllcj10LHRoaXMuZHJhd0xheWVyPWl9Z2V0V29ya1NoYXBlKGUpe3JldHVybiB0aGlzLndvcmtTaGFwZXMuZ2V0KGUpfWdldFRtcFdvcmtTaGFwZU5vZGUoKXtyZXR1cm4gdGhpcy50bXBXb3JrU2hhcGVOb2RlfXNldFRtcFdvcmtJZChlKXtpZihlJiZ0aGlzLnRtcFdvcmtTaGFwZU5vZGUpe3RoaXMudG1wV29ya1NoYXBlTm9kZS5zZXRXb3JrSWQoZSksdGhpcy53b3JrU2hhcGVzLnNldChlLHRoaXMudG1wV29ya1NoYXBlTm9kZSksdGhpcy50bXBPcHQmJnRoaXMuc2V0VG9vbHNPcHQodGhpcy50bXBPcHQpO3JldHVybn19c2V0VG1wV29ya09wdGlvbnMoZSl7dmFyIHQ7KHQ9dGhpcy50bXBXb3JrU2hhcGVOb2RlKT09bnVsbHx8dC5zZXRXb3JrT3B0aW9ucyhlKX1zZXRXb3JrT3B0aW9ucyhlLHQpe3ZhciBvO3RoaXMud29ya1NoYXBlcy5nZXQoZSl8fHRoaXMuc2V0VG1wV29ya0lkKGUpLChvPXRoaXMud29ya1NoYXBlcy5nZXQoZSkpPT1udWxsfHxvLnNldFdvcmtPcHRpb25zKHQpfWNyZWF0ZVdvcmtTaGFwZU5vZGUoZSl7bGV0IHQ7c3dpdGNoKGUudG9vbHNUeXBlKXtjYXNlIFN0LlBlbmNpbDp0PW5ldyBCdChlLnRvb2xzT3B0LHRoaXMuZnVsbExheWVyLHRoaXMuZHJhd0xheWVyKTticmVhaztjYXNlIFN0Lkxhc2VyUGVuOnQ9bmV3IEllKGUudG9vbHNPcHQsdGhpcy5mdWxsTGF5ZXIpO2JyZWFrO2Nhc2UgU3QuRXJhc2VyOnQ9bmV3ICR0KGUudG9vbHNPcHQsdGhpcy5mdWxsTGF5ZXIpO2JyZWFrO2Nhc2UgU3QuU2VsZWN0b3I6dD1uZXcgdnQoZS50b29sc09wdCx0aGlzLmZ1bGxMYXllcix0aGlzLmRyYXdMYXllcik7YnJlYWs7ZGVmYXVsdDp0PXZvaWQgMDticmVha31yZXR1cm4gdH1zZXRUb29sc09wdChlKXt2YXIgdCxpLG87KCh0PXRoaXMudG1wT3B0KT09bnVsbD92b2lkIDA6dC50b29sc1R5cGUpIT09ZS50b29sc1R5cGUmJigoKGk9dGhpcy50bXBPcHQpPT1udWxsP3ZvaWQgMDppLnRvb2xzVHlwZSk9PT1TdC5TZWxlY3RvciYmdGhpcy5ibHVyU2VsZWN0b3IoKSwobz10aGlzLnRtcE9wdCkhPW51bGwmJm8udG9vbHNUeXBlJiZ0aGlzLmNsZWFyQWxsV29ya1NoYXBlc0NhY2hlKCkpLHRoaXMudG1wT3B0PWUsdGhpcy50bXBXb3JrU2hhcGVOb2RlPXRoaXMuY3JlYXRlV29ya1NoYXBlTm9kZShlKX1jbGVhcldvcmtTaGFwZU5vZGVDYWNoZShlKXt2YXIgdDsodD10aGlzLmdldFdvcmtTaGFwZShlKSk9PW51bGx8fHQuY2xlYXJUbXBQb2ludHMoKSx0aGlzLndvcmtTaGFwZXMuZGVsZXRlKGUpfWNsZWFyQWxsV29ya1NoYXBlc0NhY2hlKCl7dGhpcy53b3JrU2hhcGVzLmZvckVhY2goZT0+ZS5jbGVhclRtcFBvaW50cygpKSx0aGlzLndvcmtTaGFwZXMuY2xlYXIoKX1ydW5FZmZlY3RXb3JrKGUpe3RoaXMuZWZmZWN0V29ya0lkJiYoY2xlYXJUaW1lb3V0KHRoaXMuZWZmZWN0V29ya0lkKSx0aGlzLmVmZmVjdFdvcmtJZD12b2lkIDApLHRoaXMuZWZmZWN0V29ya0lkPXNldFRpbWVvdXQoKCk9Pnt0aGlzLmVmZmVjdFdvcmtJZD12b2lkIDAsdGhpcy5jb21wdXROb2RlTWFwKCksdGhpcy5yZXJSZW5kZXJTZWxlY3RvcigpLGUmJmUoKX0sNTApfWNvbXB1dE5vZGVNYXAoKXt2YXIgdCxpO2NvbnN0IGU9bmV3IFNldCh0aGlzLmN1ck5vZGVNYXAua2V5cygpKTtpZih0aGlzLmZ1bGxMYXllci5jaGlsZHJlbi5mb3JFYWNoKG89PntpZihvLm5hbWUhPT12dC5zZWxlY3RvcklkKXtjb25zdCBnPVZ0KG8ubmFtZSx0aGlzLmZ1bGxMYXllcik7aWYoZyl7Y29uc3Qgdj10aGlzLmN1ck5vZGVNYXAuZ2V0KG8ubmFtZSk7dj8odi5yZWN0PWcsZS5kZWxldGUoby5uYW1lKSk6dGhpcy5jdXJOb2RlTWFwLnNldChvLm5hbWUse25hbWU6by5uYW1lLHJlY3Q6Z30pfX19KSwoaT0odD10aGlzLmRyYXdMYXllcik9PW51bGw/dm9pZCAwOnQuY2hpbGRyZW4pPT1udWxsfHxpLmZvckVhY2gobz0+e2lmKG8ubmFtZSE9PXZ0LnNlbGVjdG9ySWQpe2NvbnN0IGc9VnQoby5uYW1lLHRoaXMuZHJhd0xheWVyKTtpZihnKXtjb25zdCB2PXRoaXMuY3VyTm9kZU1hcC5nZXQoby5uYW1lKTt2Pyh2LnJlY3Q9ZyxlLmRlbGV0ZShvLm5hbWUpKTp0aGlzLmN1ck5vZGVNYXAuc2V0KG8ubmFtZSx7bmFtZTpvLm5hbWUscmVjdDpnfSl9fX0pLGUuc2l6ZSlmb3IoY29uc3QgbyBvZiBlLmtleXMoKSl0aGlzLmN1ck5vZGVNYXAuZGVsZXRlKG8pfXVwZGF0YU5vZGVNYXAoZSl7Y29uc3R7a2V5OnQsb3BzOmksb3B0Om8sdG9vbHNUeXBlOmd9PWU7bGV0IHY9VnQodCx0aGlzLmZ1bGxMYXllcik7Y29uc3QgYz10aGlzLmN1ck5vZGVNYXAuZ2V0KHQpfHx7bmFtZTp0LHJlY3Q6dn07aSYmKGMub3BzPWkpLG8mJihjLm9wdD1vKSx2JiYoYy5yZWN0PXYpLGcmJihjLnRvb2xzVHlwZT1nKSx0aGlzLmRyYXdMYXllciYmKHY9VnQodCx0aGlzLmRyYXdMYXllciksdiYmdGhpcy5kcmF3TGF5ZXImJihjLnJlY3Q9dikpLGMucmVjdD90aGlzLmN1ck5vZGVNYXAuc2V0KHQsYyk6dGhpcy5jdXJOb2RlTWFwLmRlbGV0ZSh0KX1yZXJSZW5kZXJTZWxlY3Rvcigpe3ZhciB0O2NvbnN0IGU9dGhpcy53b3JrU2hhcGVzLmdldCh2dC5zZWxlY3RvcklkKTtpZigodD1lPT1udWxsP3ZvaWQgMDplLnNlbGVjdElkcykhPW51bGwmJnQubGVuZ3RoJiZ0aGlzLmRyYXdMYXllcil7Y29uc3QgaT1lLmdldFNlbGVjdG9yKHRoaXMuY3VyTm9kZU1hcCk7aSYmdGhpcy5fcG9zdCh7cmVuZGVyOntyZWN0OmksaXNDbGVhcjohMCxpc0Z1bGxXb3JrOiExLGNsZWFyQ2FudmFzOkh0LlNlbGVjdG9yLGRyYXdDYW52YXM6SHQuU2VsZWN0b3J9LHNwOlt7dHlwZTpUdC5TZWxlY3Qsc2VsZWN0SWRzOmUuc2VsZWN0SWRzLHNlbGVjdFJlY3Q6aSx3aWxsU3luY1NlcnZpY2U6ITF9XX0pfX19Y2xhc3MgamUgZXh0ZW5kcyBCZXtjb25zdHJ1Y3RvcihlLHQsaSl7c3VwZXIoZSx0KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiX3Bvc3QiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywid29ya1NoYXBlcyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOm5ldyBNYXB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiY29tYmluZURyYXdUaW1lciIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJkcmF3Q291bnQiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTowfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImFuaW1hdGlvbldvcmtSZWN0cyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOm5ldyBNYXB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiYW5pbWF0aW9uSWQiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiY2xvc2VBbmltYXRpb25UaW1lIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6MTEwMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJydW5MYXNlclBlblN0ZXAiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTowfSksdGhpcy5fcG9zdD1pfWJsdXJTZWxlY3Rvcigpe31ydW5MYXNlclBlbkFuaW1hdGlvbigpe3RoaXMuYW5pbWF0aW9uSWR8fCh0aGlzLmFuaW1hdGlvbklkPXJlcXVlc3RBbmltYXRpb25GcmFtZSgoKT0+e3ZhciBpLG87aWYodGhpcy5hbmltYXRpb25JZD12b2lkIDAsdGhpcy5ydW5MYXNlclBlblN0ZXArKyx0aGlzLnJ1bkxhc2VyUGVuU3RlcD4xKXt0aGlzLnJ1bkxhc2VyUGVuU3RlcD0wLHRoaXMucnVuTGFzZXJQZW5BbmltYXRpb24oKTtyZXR1cm59bGV0IGU7Y29uc3QgdD1bXTsoaT10aGlzLmFuaW1hdGlvbldvcmtSZWN0cyk9PW51bGx8fGkuZm9yRWFjaCgoZyx2LGMpPT57Zy5pc1JlY3QmJihlPWJ0KGUsZy5yZXMucmVjdCkpLGcucmVzLndvcmtJZCYmdC5wdXNoKGcucmVzKSx0aGlzLmZ1bGxMYXllci5nZXRFbGVtZW50c0J5TmFtZSh2LnRvU3RyaW5nKCkpLmxlbmd0aD9nLmlzUmVjdD0hMDpnLmlzUmVjdD0hMSxnLmNhbkRlbCYmYy5kZWxldGUodil9KSwobz10aGlzLmFuaW1hdGlvbldvcmtSZWN0cykhPW51bGwmJm8uc2l6ZSYmdGhpcy5ydW5MYXNlclBlbkFuaW1hdGlvbigpLGUmJnRoaXMuX3Bvc3Qoe3JlbmRlcjp7cmVjdDplLGRyYXdDYW52YXM6SHQuRmxvYXQsaXNDbGVhcjohMCxjbGVhckNhbnZhczpIdC5GbG9hdCxpc0Z1bGxXb3JrOiExfSxzcDp0Lmxlbmd0aD90OnZvaWQgMH0pfSkpfWRyYXdQZW5jaWwoZSl7dGhpcy5fcG9zdCh7ZHJhd0NvdW50OnRoaXMuZHJhd0NvdW50LHJlbmRlcjp7cmVjdDplPT1udWxsP3ZvaWQgMDplLnJlY3QsZHJhd0NhbnZhczpIdC5GbG9hdCxpc0NsZWFyOiExLGlzRnVsbFdvcms6ITF9LHNwOihlPT1udWxsP3ZvaWQgMDplLm9wKSYmW2VdfSl9Y29uc3VtZURyYXcoZSl7dmFyIG87Y29uc3R7b3A6dCx3b3JrSWQ6aX09ZTtpZih0IT1udWxsJiZ0Lmxlbmd0aCYmaSl7Y29uc3QgZz10aGlzLndvcmtTaGFwZXMuZ2V0KGkpO2lmKCFnKXJldHVybjtjb25zdCB2PWcudG9vbHNUeXBlLGM9Zy5jb25zdW1lKHtkYXRhOmUsaXNGdWxsV29yazohMSxpc0NsZWFyQWxsOiEwLGlzU3ViV29ya2VyOiEwfSk7aWYodj09PVN0Lkxhc2VyUGVuKXtjIT1udWxsJiZjLnJlY3QmJigobz10aGlzLmFuaW1hdGlvbldvcmtSZWN0cyk9PW51bGx8fG8uc2V0KGkse3JlczpjLGNhbkRlbDohMSxpc1JlY3Q6ITB9KSksdGhpcy5ydW5MYXNlclBlbkFuaW1hdGlvbigpO3JldHVybn1jJiYodGhpcy5kcmF3Q291bnQrKyx0aGlzLmRyYXdQZW5jaWwoYykpfX1jb25zdW1lRHJhd0FsbChlKXt2YXIgaSxvO2NvbnN0e3dvcmtJZDp0fT1lO2lmKHQpe2NvbnN0IGc9dGhpcy53b3JrU2hhcGVzLmdldCh0KTtpZighZylyZXR1cm47Y29uc3Qgdj1nLnRvb2xzVHlwZTtpZih2PT09U3QuTGFzZXJQZW4mJnRoaXMuYW5pbWF0aW9uSWQpe2NvbnN0IGM9Zy5jb25zdW1lQWxsKHtkYXRhOmV9KTtjIT1udWxsJiZjLm9wJiYoYyE9bnVsbCYmYy5yZWN0JiYoKGk9dGhpcy5hbmltYXRpb25Xb3JrUmVjdHMpPT1udWxsfHxpLnNldCh0LHtyZXM6YyxjYW5EZWw6ITEsaXNSZWN0OiEwfSksdGhpcy5ydW5MYXNlclBlbkFuaW1hdGlvbigpKSx0aGlzLl9wb3N0KHtzcDpbY119KSk7Y29uc3QgZj0obz1nLmdldFdvcmtPcHRpb25zKCkpPT1udWxsP3ZvaWQgMDpvLmR1cmF0aW9uO3RoaXMuY2xvc2VBbmltYXRpb25UaW1lPWY/ZioxZTMrMTAwOnRoaXMuY2xvc2VBbmltYXRpb25UaW1lLHNldFRpbWVvdXQoKCk9Pnt2YXIgRTt0aGlzLmZ1bGxMYXllci5nZXRFbGVtZW50c0J5TmFtZSh0LnRvU3RyaW5nKCkpLm1hcChsPT5sLnJlbW92ZSgpKSx0aGlzLmNsZWFyV29ya1NoYXBlTm9kZUNhY2hlKHQpO2NvbnN0IGg9KEU9dGhpcy5hbmltYXRpb25Xb3JrUmVjdHMpPT1udWxsP3ZvaWQgMDpFLmdldCh0KTtoJiYoaC5jYW5EZWw9ITApLHNldFRpbWVvdXQoKCk9Pnt0aGlzLl9wb3N0KHtzcDpbe3JlbW92ZUlkczpbdC50b1N0cmluZygpXSx0eXBlOlR0LlJlbW92ZU5vZGV9XX0pfSxnLmdldFdvcmtPcHRpb25zKCkuc3luY1VuaXRUaW1lfHx0aGlzLmNsb3NlQW5pbWF0aW9uVGltZSl9LHRoaXMuY2xvc2VBbmltYXRpb25UaW1lKTtyZXR1cm59dj09PVN0LlBlbmNpbCYmKHRoaXMuZHJhd0NvdW50PTAsdGhpcy5mdWxsTGF5ZXIucmVtb3ZlQWxsQ2hpbGRyZW4oKSx0aGlzLmNsZWFyV29ya1NoYXBlTm9kZUNhY2hlKHQpKX19fWNvbnN0IFF0PWNsYXNzIFF0IGV4dGVuZHMgTmV7Y29uc3RydWN0b3IoKXtzdXBlcigpO0t0KHRoaXMsImNhbWVyYU9wdCIpO0t0KHRoaXMsImxvY2tJZCIpO0t0KHRoaXMsImRwciIpO0t0KHRoaXMsInNjZW5lIik7S3QodGhpcywiZHJhd0xheWVyIik7S3QodGhpcywiZnVsbExheWVyIik7S3QodGhpcywibG9jYWxXb3JrIik7dGhpcy5yZWdpc3RlcigpfWluaXQodCxpLG8pe3RoaXMuZHByPXQsdGhpcy5zY2VuZT10aGlzLmNyZWF0ZVNjZW5lKGkpLHRoaXMuc2NlbmU9dGhpcy5jcmVhdGVTY2VuZShpKSx0aGlzLmRyYXdMYXllcj10aGlzLmNyZWF0ZUxheWVyKHsuLi5vLHdpZHRoOmkud2lkdGgsaGVpZ2h0OmkuaGVpZ2h0fSksdGhpcy5sb2NhbFdvcms9bmV3IGplKHRoaXMuY3VyTm9kZU1hcCx0aGlzLmRyYXdMYXllcix0aGlzLnBvc3QuYmluZCh0aGlzKSl9Z2V0T2Zmc2NyZWVuKCl7dmFyIHQ7cmV0dXJuKHQ9dGhpcy5kcmF3TGF5ZXIucGFyZW50KT09bnVsbD92b2lkIDA6dC5jYW52YXN9cmVnaXN0ZXIoKXt0aGlzLm9uKHQ9Pntmb3IoY29uc3QgaSBvZiB0KXtjb25zdHt3b3JrU3RhdGU6byxkYXRhVHlwZTpnLG1zZ1R5cGU6dix3b3JrSWQ6Yyx0b29sc1R5cGU6ZixvcHQ6aH09aTtzd2l0Y2godil7Y2FzZSBUdC5VcGRhdGVUb29sczpmJiZoJiZ0aGlzLnNldFRvb2xzT3B0KHt0b29sc1R5cGU6Zix0b29sc09wdDpofSk7YnJlYWs7Y2FzZSBUdC5DcmVhdGVXb3JrOmMmJmgmJighdGhpcy5sb2NhbFdvcmsuZ2V0VG1wV29ya1NoYXBlTm9kZSgpJiZmJiZ0aGlzLnNldFRvb2xzT3B0KHt0b29sc1R5cGU6Zix0b29sc09wdDpofSksdGhpcy5zZXRXb3JrT3B0KHt3b3JrSWQ6Yyx0b29sc09wdDpofSkpO2JyZWFrO2Nhc2UgVHQuRHJhd1dvcms6bz09PXd0LkRvbmUmJmc9PT1DdC5Mb2NhbD90aGlzLmNvbnN1bWVEcmF3QWxsKGcsaSk6dGhpcy5jb25zdW1lRHJhdyhnLGkpO2JyZWFrfX19KX1zZXRUb29sc09wdCh0KXt0aGlzLmxvY2FsV29yay5zZXRUb29sc09wdCh0KX1zZXRXb3JrT3B0KHQpe2NvbnN0e3dvcmtJZDppLHRvb2xzT3B0Om99PXQ7aSYmbyYmdGhpcy5sb2NhbFdvcmsuc2V0V29ya09wdGlvbnMoaSxvKX1jbGVhckFsbCgpe3RoaXMuZHJhd0xheWVyLnJlbW92ZUFsbENoaWxkcmVuKCksdGhpcy5sb2NhbFdvcmsuY2xlYXJBbGxXb3JrU2hhcGVzQ2FjaGUoKX1zZXRDYW1lcmFPcHQodCl7dGhpcy5jYW1lcmFPcHQ9dDtjb25zdHtzY2FsZTppLGNlbnRlclg6byxjZW50ZXJZOmcsd2lkdGg6dixoZWlnaHQ6Y309dDsodiE9PXRoaXMuc2NlbmUud2lkdGh8fGMhPT10aGlzLnNjZW5lLmhlaWdodCkmJnRoaXMudXBkYXRlU2NlbmUoe3dpZHRoOnYsaGVpZ2h0OmN9KSx0aGlzLmRyYXdMYXllci5zZXRBdHRyaWJ1dGUoInNjYWxlIixbaSxpXSksdGhpcy5kcmF3TGF5ZXIuc2V0QXR0cmlidXRlKCJ0cmFuc2xhdGUiLFstbywtZ10pfWdldFJlY3RJbWFnZUJpdG1hcCh0KXtjb25zdCBpPXQueCp0aGlzLmRwcixvPXQueSp0aGlzLmRwcixnPXQudyp0aGlzLmRwcix2PXQuaCp0aGlzLmRwcjtyZXR1cm4gY3JlYXRlSW1hZ2VCaXRtYXAodGhpcy5nZXRPZmZzY3JlZW4oKSxpLG8sZyx2LHtyZXNpemVRdWFsaXR5OiJsb3cifSl9cG9zdCh0KXt0aGlzLmxvY2tJZCYmKHQubG9ja0lkPXRoaXMubG9ja0lkLHRoaXMubG9ja0lkPXZvaWQgMCk7Y29uc3QgaT10LnJlbmRlcjtpZihpJiYodGhpcy5kcmF3TGF5ZXIucGFyZW50LnJlbmRlcigpLGkucmVjdCkpe3RoaXMuZ2V0UmVjdEltYWdlQml0bWFwKGkucmVjdCkudGhlbihvPT57aS5pbWFnZUJpdG1hcD1vLHQucmVuZGVyPWksUXQuX3NlbGYucG9zdE1lc3NhZ2UodCxbb10pLG8uY2xvc2UoKX0pO3JldHVybn1RdC5fc2VsZi5wb3N0TWVzc2FnZSh0KX1vbih0KXtvbm1lc3NhZ2U9aT0+e2lmKGkuZGF0YSl7Y29uc3Qgbz1pLmRhdGEuZ2V0KCJJbml0Iik7aWYobyl7Y29uc3R7ZHByOmMsb2Zmc2NyZWVuQ2FudmFzT3B0OmYsbGF5ZXJPcHQ6aH09bztmJiZoJiZjJiZ0aGlzLmluaXQoYyxmLGgpfXQoaS5kYXRhLnZhbHVlcygpKTtjb25zdCBnPWkuZGF0YS5oYXMoIkNsZWFyQWxsIiksdj1pLmRhdGEuZ2V0KCJVcGRhdGVDYW1lcmEiKTtpZih2KXtjb25zdHtjYW1lcmFPcHQ6Y309djtjJiZ0aGlzLnNldENhbWVyYU9wdChjKX1nJiZ0aGlzLmNsZWFyQWxsKCl9fX1jb25zdW1lRHJhdyh0LGkpe3Q9PT1DdC5Mb2NhbCYmdGhpcy5sb2NhbFdvcmsuY29uc3VtZURyYXcoaSl9Y29uc3VtZURyYXdBbGwodCxpKXt0aGlzLmxvY2FsV29yay5jb25zdW1lRHJhd0FsbChpKX1jb25zdW1lRnVsbCgpe319O0t0KFF0LCJfc2VsZiIsc2VsZik7bGV0IG9lPVF0O25ldyBvZX0pKCk7Cg==", Vd = typeof window < "u" && window.Blob && new Blob([atob(ms)], { type: "text/javascript;charset=utf-8" });
function dt(Z) {
  let l;
  try {
    if (l = Vd && (window.URL || window.webkitURL).createObjectURL(Vd), !l)
      throw "";
    const i = new Worker(l, {
      name: Z == null ? void 0 : Z.name
    });
    return i.addEventListener("error", () => {
      (window.URL || window.webkitURL).revokeObjectURL(l);
    }), i;
  } catch {
    return new Worker(
      "data:application/javascript;base64," + ms,
      {
        name: Z == null ? void 0 : Z.name
      }
    );
  } finally {
    l && (window.URL || window.webkitURL).revokeObjectURL(l);
  }
}
var Ll = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function $l(Z) {
  return Z && Z.__esModule && Object.prototype.hasOwnProperty.call(Z, "default") ? Z.default : Z;
}
function st() {
  this.__data__ = [], this.size = 0;
}
var tt = st;
function bt(Z, l) {
  return Z === l || Z !== Z && l !== l;
}
var _l = bt, ct = _l;
function Zt(Z, l) {
  for (var i = Z.length; i--; )
    if (ct(Z[i][0], l))
      return i;
  return -1;
}
var Cl = Zt, mt = Cl, nt = Array.prototype, Xt = nt.splice;
function ot(Z) {
  var l = this.__data__, i = mt(l, Z);
  if (i < 0)
    return !1;
  var s = l.length - 1;
  return i == s ? l.pop() : Xt.call(l, i, 1), --this.size, !0;
}
var at = ot, et = Cl;
function Wt(Z) {
  var l = this.__data__, i = et(l, Z);
  return i < 0 ? void 0 : l[i][1];
}
var Gt = Wt, ut = Cl;
function Vt(Z) {
  return ut(this.__data__, Z) > -1;
}
var ht = Vt, It = Cl;
function pt(Z, l) {
  var i = this.__data__, s = It(i, Z);
  return s < 0 ? (++this.size, i.push([Z, l])) : i[s][1] = l, this;
}
var Lt = pt, yt = tt, Kt = at, Rt = Gt, xt = ht, rt = Lt;
function nl(Z) {
  var l = -1, i = Z == null ? 0 : Z.length;
  for (this.clear(); ++l < i; ) {
    var s = Z[l];
    this.set(s[0], s[1]);
  }
}
nl.prototype.clear = yt;
nl.prototype.delete = Kt;
nl.prototype.get = Rt;
nl.prototype.has = xt;
nl.prototype.set = rt;
var Jl = nl, St = Jl;
function Yt() {
  this.__data__ = new St(), this.size = 0;
}
var Ct = Yt;
function Jt(Z) {
  var l = this.__data__, i = l.delete(Z);
  return this.size = l.size, i;
}
var Ft = Jt;
function Tt(Z) {
  return this.__data__.get(Z);
}
var Nt = Tt;
function gt(Z) {
  return this.__data__.has(Z);
}
var Ht = gt, zt = typeof Ll == "object" && Ll && Ll.Object === Object && Ll, ns = zt, Mt = ns, kt = typeof self == "object" && self && self.Object === Object && self, vt = Mt || kt || Function("return this")(), Bi = vt, Ut = Bi, Qt = Ut.Symbol, Fl = Qt, hd = Fl, Xs = Object.prototype, ft = Xs.hasOwnProperty, Pt = Xs.toString, ul = hd ? hd.toStringTag : void 0;
function wt(Z) {
  var l = ft.call(Z, ul), i = Z[ul];
  try {
    Z[ul] = void 0;
    var s = !0;
  } catch {
  }
  var c = Pt.call(Z);
  return s && (l ? Z[ul] = i : delete Z[ul]), c;
}
var Et = wt, jt = Object.prototype, Bt = jt.toString;
function Ot(Z) {
  return Bt.call(Z);
}
var Dt = Ot, Id = Fl, At = Et, qt = Dt, $t = "[object Null]", _t = "[object Undefined]", pd = Id ? Id.toStringTag : void 0;
function ib(Z) {
  return Z == null ? Z === void 0 ? _t : $t : pd && pd in Object(Z) ? At(Z) : qt(Z);
}
var pl = ib;
function lb(Z) {
  var l = typeof Z;
  return Z != null && (l == "object" || l == "function");
}
var ll = lb, db = pl, sb = ll, tb = "[object AsyncFunction]", bb = "[object Function]", cb = "[object GeneratorFunction]", Zb = "[object Proxy]";
function mb(Z) {
  if (!sb(Z))
    return !1;
  var l = db(Z);
  return l == bb || l == cb || l == tb || l == Zb;
}
var os = mb, nb = Bi, Xb = nb["__core-js_shared__"], ob = Xb, kl = ob, Ld = function() {
  var Z = /[^.]+$/.exec(kl && kl.keys && kl.keys.IE_PROTO || "");
  return Z ? "Symbol(src)_1." + Z : "";
}();
function ab(Z) {
  return !!Ld && Ld in Z;
}
var eb = ab, Wb = Function.prototype, Gb = Wb.toString;
function ub(Z) {
  if (Z != null) {
    try {
      return Gb.call(Z);
    } catch {
    }
    try {
      return Z + "";
    } catch {
    }
  }
  return "";
}
var as = ub, Vb = os, hb = eb, Ib = ll, pb = as, Lb = /[\\^$.*+?()[\]{}|]/g, yb = /^\[object .+?Constructor\]$/, Kb = Function.prototype, Rb = Object.prototype, xb = Kb.toString, rb = Rb.hasOwnProperty, Sb = RegExp(
  "^" + xb.call(rb).replace(Lb, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function Yb(Z) {
  if (!Ib(Z) || hb(Z))
    return !1;
  var l = Vb(Z) ? Sb : yb;
  return l.test(pb(Z));
}
var Cb = Yb;
function Jb(Z, l) {
  return Z == null ? void 0 : Z[l];
}
var Fb = Jb, Tb = Cb, Nb = Fb;
function gb(Z, l) {
  var i = Nb(Z, l);
  return Tb(i) ? i : void 0;
}
var tl = gb, Hb = tl, zb = Bi, Mb = Hb(zb, "Map"), id = Mb, kb = tl, vb = kb(Object, "create"), Tl = vb, yd = Tl;
function Ub() {
  this.__data__ = yd ? yd(null) : {}, this.size = 0;
}
var Qb = Ub;
function fb(Z) {
  var l = this.has(Z) && delete this.__data__[Z];
  return this.size -= l ? 1 : 0, l;
}
var Pb = fb, wb = Tl, Eb = "__lodash_hash_undefined__", jb = Object.prototype, Bb = jb.hasOwnProperty;
function Ob(Z) {
  var l = this.__data__;
  if (wb) {
    var i = l[Z];
    return i === Eb ? void 0 : i;
  }
  return Bb.call(l, Z) ? l[Z] : void 0;
}
var Db = Ob, Ab = Tl, qb = Object.prototype, $b = qb.hasOwnProperty;
function _b(Z) {
  var l = this.__data__;
  return Ab ? l[Z] !== void 0 : $b.call(l, Z);
}
var ic = _b, lc = Tl, dc = "__lodash_hash_undefined__";
function sc(Z, l) {
  var i = this.__data__;
  return this.size += this.has(Z) ? 0 : 1, i[Z] = lc && l === void 0 ? dc : l, this;
}
var tc = sc, bc = Qb, cc = Pb, Zc = Db, mc = ic, nc = tc;
function Xl(Z) {
  var l = -1, i = Z == null ? 0 : Z.length;
  for (this.clear(); ++l < i; ) {
    var s = Z[l];
    this.set(s[0], s[1]);
  }
}
Xl.prototype.clear = bc;
Xl.prototype.delete = cc;
Xl.prototype.get = Zc;
Xl.prototype.has = mc;
Xl.prototype.set = nc;
var Xc = Xl, Kd = Xc, oc = Jl, ac = id;
function ec() {
  this.size = 0, this.__data__ = {
    hash: new Kd(),
    map: new (ac || oc)(),
    string: new Kd()
  };
}
var Wc = ec;
function Gc(Z) {
  var l = typeof Z;
  return l == "string" || l == "number" || l == "symbol" || l == "boolean" ? Z !== "__proto__" : Z === null;
}
var uc = Gc, Vc = uc;
function hc(Z, l) {
  var i = Z.__data__;
  return Vc(l) ? i[typeof l == "string" ? "string" : "hash"] : i.map;
}
var Nl = hc, Ic = Nl;
function pc(Z) {
  var l = Ic(this, Z).delete(Z);
  return this.size -= l ? 1 : 0, l;
}
var Lc = pc, yc = Nl;
function Kc(Z) {
  return yc(this, Z).get(Z);
}
var Rc = Kc, xc = Nl;
function rc(Z) {
  return xc(this, Z).has(Z);
}
var Sc = rc, Yc = Nl;
function Cc(Z, l) {
  var i = Yc(this, Z), s = i.size;
  return i.set(Z, l), this.size += i.size == s ? 0 : 1, this;
}
var Jc = Cc, Fc = Wc, Tc = Lc, Nc = Rc, gc = Sc, Hc = Jc;
function ol(Z) {
  var l = -1, i = Z == null ? 0 : Z.length;
  for (this.clear(); ++l < i; ) {
    var s = Z[l];
    this.set(s[0], s[1]);
  }
}
ol.prototype.clear = Fc;
ol.prototype.delete = Tc;
ol.prototype.get = Nc;
ol.prototype.has = gc;
ol.prototype.set = Hc;
var es = ol, zc = Jl, Mc = id, kc = es, vc = 200;
function Uc(Z, l) {
  var i = this.__data__;
  if (i instanceof zc) {
    var s = i.__data__;
    if (!Mc || s.length < vc - 1)
      return s.push([Z, l]), this.size = ++i.size, this;
    i = this.__data__ = new kc(s);
  }
  return i.set(Z, l), this.size = i.size, this;
}
var Qc = Uc, fc = Jl, Pc = Ct, wc = Ft, Ec = Nt, jc = Ht, Bc = Qc;
function al(Z) {
  var l = this.__data__ = new fc(Z);
  this.size = l.size;
}
al.prototype.clear = Pc;
al.prototype.delete = wc;
al.prototype.get = Ec;
al.prototype.has = jc;
al.prototype.set = Bc;
var Ws = al;
function Oc(Z, l) {
  for (var i = -1, s = Z == null ? 0 : Z.length; ++i < s && l(Z[i], i, Z) !== !1; )
    ;
  return Z;
}
var Dc = Oc, Ac = tl, qc = function() {
  try {
    var Z = Ac(Object, "defineProperty");
    return Z({}, "", {}), Z;
  } catch {
  }
}(), $c = qc, Rd = $c;
function _c(Z, l, i) {
  l == "__proto__" && Rd ? Rd(Z, l, {
    configurable: !0,
    enumerable: !0,
    value: i,
    writable: !0
  }) : Z[l] = i;
}
var Gs = _c, i0 = Gs, l0 = _l, d0 = Object.prototype, s0 = d0.hasOwnProperty;
function t0(Z, l, i) {
  var s = Z[l];
  (!(s0.call(Z, l) && l0(s, i)) || i === void 0 && !(l in Z)) && i0(Z, l, i);
}
var us = t0, b0 = us, c0 = Gs;
function Z0(Z, l, i, s) {
  var c = !i;
  i || (i = {});
  for (var W = -1, h = l.length; ++W < h; ) {
    var e = l[W], a = s ? s(i[e], Z[e], e, i, Z) : void 0;
    a === void 0 && (a = Z[e]), c ? c0(i, e, a) : b0(i, e, a);
  }
  return i;
}
var gl = Z0;
function m0(Z, l) {
  for (var i = -1, s = Array(Z); ++i < Z; )
    s[i] = l(i);
  return s;
}
var n0 = m0;
function X0(Z) {
  return Z != null && typeof Z == "object";
}
var bl = X0, o0 = pl, a0 = bl, e0 = "[object Arguments]";
function W0(Z) {
  return a0(Z) && o0(Z) == e0;
}
var G0 = W0, xd = G0, u0 = bl, Vs = Object.prototype, V0 = Vs.hasOwnProperty, h0 = Vs.propertyIsEnumerable, I0 = xd(/* @__PURE__ */ function() {
  return arguments;
}()) ? xd : function(Z) {
  return u0(Z) && V0.call(Z, "callee") && !h0.call(Z, "callee");
}, p0 = I0, L0 = Array.isArray, Hl = L0, Rl = { exports: {} };
function y0() {
  return !1;
}
var K0 = y0;
Rl.exports;
(function(Z, l) {
  var i = Bi, s = K0, c = l && !l.nodeType && l, W = c && !0 && Z && !Z.nodeType && Z, h = W && W.exports === c, e = h ? i.Buffer : void 0, a = e ? e.isBuffer : void 0, G = a || s;
  Z.exports = G;
})(Rl, Rl.exports);
var ld = Rl.exports, R0 = 9007199254740991, x0 = /^(?:0|[1-9]\d*)$/;
function r0(Z, l) {
  var i = typeof Z;
  return l = l ?? R0, !!l && (i == "number" || i != "symbol" && x0.test(Z)) && Z > -1 && Z % 1 == 0 && Z < l;
}
var S0 = r0, Y0 = 9007199254740991;
function C0(Z) {
  return typeof Z == "number" && Z > -1 && Z % 1 == 0 && Z <= Y0;
}
var hs = C0, J0 = pl, F0 = hs, T0 = bl, N0 = "[object Arguments]", g0 = "[object Array]", H0 = "[object Boolean]", z0 = "[object Date]", M0 = "[object Error]", k0 = "[object Function]", v0 = "[object Map]", U0 = "[object Number]", Q0 = "[object Object]", f0 = "[object RegExp]", P0 = "[object Set]", w0 = "[object String]", E0 = "[object WeakMap]", j0 = "[object ArrayBuffer]", B0 = "[object DataView]", O0 = "[object Float32Array]", D0 = "[object Float64Array]", A0 = "[object Int8Array]", q0 = "[object Int16Array]", $0 = "[object Int32Array]", _0 = "[object Uint8Array]", iZ = "[object Uint8ClampedArray]", lZ = "[object Uint16Array]", dZ = "[object Uint32Array]", gi = {};
gi[O0] = gi[D0] = gi[A0] = gi[q0] = gi[$0] = gi[_0] = gi[iZ] = gi[lZ] = gi[dZ] = !0;
gi[N0] = gi[g0] = gi[j0] = gi[H0] = gi[B0] = gi[z0] = gi[M0] = gi[k0] = gi[v0] = gi[U0] = gi[Q0] = gi[f0] = gi[P0] = gi[w0] = gi[E0] = !1;
function sZ(Z) {
  return T0(Z) && F0(Z.length) && !!gi[J0(Z)];
}
var tZ = sZ;
function bZ(Z) {
  return function(l) {
    return Z(l);
  };
}
var dd = bZ, xl = { exports: {} };
xl.exports;
(function(Z, l) {
  var i = ns, s = l && !l.nodeType && l, c = s && !0 && Z && !Z.nodeType && Z, W = c && c.exports === s, h = W && i.process, e = function() {
    try {
      var a = c && c.require && c.require("util").types;
      return a || h && h.binding && h.binding("util");
    } catch {
    }
  }();
  Z.exports = e;
})(xl, xl.exports);
var sd = xl.exports, cZ = tZ, ZZ = dd, rd = sd, Sd = rd && rd.isTypedArray, mZ = Sd ? ZZ(Sd) : cZ, Is = mZ, nZ = n0, XZ = p0, oZ = Hl, aZ = ld, eZ = S0, WZ = Is, GZ = Object.prototype, uZ = GZ.hasOwnProperty;
function VZ(Z, l) {
  var i = oZ(Z), s = !i && XZ(Z), c = !i && !s && aZ(Z), W = !i && !s && !c && WZ(Z), h = i || s || c || W, e = h ? nZ(Z.length, String) : [], a = e.length;
  for (var G in Z)
    (l || uZ.call(Z, G)) && !(h && // Safari 9 has enumerable `arguments.length` in strict mode.
    (G == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    c && (G == "offset" || G == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    W && (G == "buffer" || G == "byteLength" || G == "byteOffset") || // Skip index properties.
    eZ(G, a))) && e.push(G);
  return e;
}
var ps = VZ, hZ = Object.prototype;
function IZ(Z) {
  var l = Z && Z.constructor, i = typeof l == "function" && l.prototype || hZ;
  return Z === i;
}
var td = IZ;
function pZ(Z, l) {
  return function(i) {
    return Z(l(i));
  };
}
var Ls = pZ, LZ = Ls, yZ = LZ(Object.keys, Object), KZ = yZ, RZ = td, xZ = KZ, rZ = Object.prototype, SZ = rZ.hasOwnProperty;
function YZ(Z) {
  if (!RZ(Z))
    return xZ(Z);
  var l = [];
  for (var i in Object(Z))
    SZ.call(Z, i) && i != "constructor" && l.push(i);
  return l;
}
var CZ = YZ, JZ = os, FZ = hs;
function TZ(Z) {
  return Z != null && FZ(Z.length) && !JZ(Z);
}
var ys = TZ, NZ = ps, gZ = CZ, HZ = ys;
function zZ(Z) {
  return HZ(Z) ? NZ(Z) : gZ(Z);
}
var bd = zZ, MZ = gl, kZ = bd;
function vZ(Z, l) {
  return Z && MZ(l, kZ(l), Z);
}
var UZ = vZ;
function QZ(Z) {
  var l = [];
  if (Z != null)
    for (var i in Object(Z))
      l.push(i);
  return l;
}
var fZ = QZ, PZ = ll, wZ = td, EZ = fZ, jZ = Object.prototype, BZ = jZ.hasOwnProperty;
function OZ(Z) {
  if (!PZ(Z))
    return EZ(Z);
  var l = wZ(Z), i = [];
  for (var s in Z)
    s == "constructor" && (l || !BZ.call(Z, s)) || i.push(s);
  return i;
}
var DZ = OZ, AZ = ps, qZ = DZ, $Z = ys;
function _Z(Z) {
  return $Z(Z) ? AZ(Z, !0) : qZ(Z);
}
var cd = _Z, im = gl, lm = cd;
function dm(Z, l) {
  return Z && im(l, lm(l), Z);
}
var sm = dm, rl = { exports: {} };
rl.exports;
(function(Z, l) {
  var i = Bi, s = l && !l.nodeType && l, c = s && !0 && Z && !Z.nodeType && Z, W = c && c.exports === s, h = W ? i.Buffer : void 0, e = h ? h.allocUnsafe : void 0;
  function a(G, y) {
    if (y)
      return G.slice();
    var n = G.length, V = e ? e(n) : new G.constructor(n);
    return G.copy(V), V;
  }
  Z.exports = a;
})(rl, rl.exports);
var tm = rl.exports;
function bm(Z, l) {
  var i = -1, s = Z.length;
  for (l || (l = Array(s)); ++i < s; )
    l[i] = Z[i];
  return l;
}
var cm = bm;
function Zm(Z, l) {
  for (var i = -1, s = Z == null ? 0 : Z.length, c = 0, W = []; ++i < s; ) {
    var h = Z[i];
    l(h, i, Z) && (W[c++] = h);
  }
  return W;
}
var mm = Zm;
function nm() {
  return [];
}
var Ks = nm, Xm = mm, om = Ks, am = Object.prototype, em = am.propertyIsEnumerable, Yd = Object.getOwnPropertySymbols, Wm = Yd ? function(Z) {
  return Z == null ? [] : (Z = Object(Z), Xm(Yd(Z), function(l) {
    return em.call(Z, l);
  }));
} : om, Zd = Wm, Gm = gl, um = Zd;
function Vm(Z, l) {
  return Gm(Z, um(Z), l);
}
var hm = Vm;
function Im(Z, l) {
  for (var i = -1, s = l.length, c = Z.length; ++i < s; )
    Z[c + i] = l[i];
  return Z;
}
var Rs = Im, pm = Ls, Lm = pm(Object.getPrototypeOf, Object), xs = Lm, ym = Rs, Km = xs, Rm = Zd, xm = Ks, rm = Object.getOwnPropertySymbols, Sm = rm ? function(Z) {
  for (var l = []; Z; )
    ym(l, Rm(Z)), Z = Km(Z);
  return l;
} : xm, rs = Sm, Ym = gl, Cm = rs;
function Jm(Z, l) {
  return Ym(Z, Cm(Z), l);
}
var Fm = Jm, Tm = Rs, Nm = Hl;
function gm(Z, l, i) {
  var s = l(Z);
  return Nm(Z) ? s : Tm(s, i(Z));
}
var Ss = gm, Hm = Ss, zm = Zd, Mm = bd;
function km(Z) {
  return Hm(Z, Mm, zm);
}
var Ys = km, vm = Ss, Um = rs, Qm = cd;
function fm(Z) {
  return vm(Z, Qm, Um);
}
var Pm = fm, wm = tl, Em = Bi, jm = wm(Em, "DataView"), Bm = jm, Om = tl, Dm = Bi, Am = Om(Dm, "Promise"), qm = Am, $m = tl, _m = Bi, ln = $m(_m, "Set"), dn = ln, sn = tl, tn = Bi, bn = sn(tn, "WeakMap"), cn = bn, wl = Bm, El = id, jl = qm, Bl = dn, Ol = cn, Cs = pl, el = as, Cd = "[object Map]", Zn = "[object Object]", Jd = "[object Promise]", Fd = "[object Set]", Td = "[object WeakMap]", Nd = "[object DataView]", mn = el(wl), nn = el(El), Xn = el(jl), on = el(Bl), an = el(Ol), dl = Cs;
(wl && dl(new wl(new ArrayBuffer(1))) != Nd || El && dl(new El()) != Cd || jl && dl(jl.resolve()) != Jd || Bl && dl(new Bl()) != Fd || Ol && dl(new Ol()) != Td) && (dl = function(Z) {
  var l = Cs(Z), i = l == Zn ? Z.constructor : void 0, s = i ? el(i) : "";
  if (s)
    switch (s) {
      case mn:
        return Nd;
      case nn:
        return Cd;
      case Xn:
        return Jd;
      case on:
        return Fd;
      case an:
        return Td;
    }
  return l;
});
var zl = dl, en = Object.prototype, Wn = en.hasOwnProperty;
function Gn(Z) {
  var l = Z.length, i = new Z.constructor(l);
  return l && typeof Z[0] == "string" && Wn.call(Z, "index") && (i.index = Z.index, i.input = Z.input), i;
}
var un = Gn, Vn = Bi, hn = Vn.Uint8Array, Js = hn, gd = Js;
function In(Z) {
  var l = new Z.constructor(Z.byteLength);
  return new gd(l).set(new gd(Z)), l;
}
var md = In, pn = md;
function Ln(Z, l) {
  var i = l ? pn(Z.buffer) : Z.buffer;
  return new Z.constructor(i, Z.byteOffset, Z.byteLength);
}
var yn = Ln, Kn = /\w*$/;
function Rn(Z) {
  var l = new Z.constructor(Z.source, Kn.exec(Z));
  return l.lastIndex = Z.lastIndex, l;
}
var xn = Rn, Hd = Fl, zd = Hd ? Hd.prototype : void 0, Md = zd ? zd.valueOf : void 0;
function rn(Z) {
  return Md ? Object(Md.call(Z)) : {};
}
var Sn = rn, Yn = md;
function Cn(Z, l) {
  var i = l ? Yn(Z.buffer) : Z.buffer;
  return new Z.constructor(i, Z.byteOffset, Z.length);
}
var Jn = Cn, Fn = md, Tn = yn, Nn = xn, gn = Sn, Hn = Jn, zn = "[object Boolean]", Mn = "[object Date]", kn = "[object Map]", vn = "[object Number]", Un = "[object RegExp]", Qn = "[object Set]", fn = "[object String]", Pn = "[object Symbol]", wn = "[object ArrayBuffer]", En = "[object DataView]", jn = "[object Float32Array]", Bn = "[object Float64Array]", On = "[object Int8Array]", Dn = "[object Int16Array]", An = "[object Int32Array]", qn = "[object Uint8Array]", $n = "[object Uint8ClampedArray]", _n = "[object Uint16Array]", iX = "[object Uint32Array]";
function lX(Z, l, i) {
  var s = Z.constructor;
  switch (l) {
    case wn:
      return Fn(Z);
    case zn:
    case Mn:
      return new s(+Z);
    case En:
      return Tn(Z, i);
    case jn:
    case Bn:
    case On:
    case Dn:
    case An:
    case qn:
    case $n:
    case _n:
    case iX:
      return Hn(Z, i);
    case kn:
      return new s();
    case vn:
    case fn:
      return new s(Z);
    case Un:
      return Nn(Z);
    case Qn:
      return new s();
    case Pn:
      return gn(Z);
  }
}
var dX = lX, sX = ll, kd = Object.create, tX = /* @__PURE__ */ function() {
  function Z() {
  }
  return function(l) {
    if (!sX(l))
      return {};
    if (kd)
      return kd(l);
    Z.prototype = l;
    var i = new Z();
    return Z.prototype = void 0, i;
  };
}(), bX = tX, cX = bX, ZX = xs, mX = td;
function nX(Z) {
  return typeof Z.constructor == "function" && !mX(Z) ? cX(ZX(Z)) : {};
}
var XX = nX, oX = zl, aX = bl, eX = "[object Map]";
function WX(Z) {
  return aX(Z) && oX(Z) == eX;
}
var GX = WX, uX = GX, VX = dd, vd = sd, Ud = vd && vd.isMap, hX = Ud ? VX(Ud) : uX, IX = hX, pX = zl, LX = bl, yX = "[object Set]";
function KX(Z) {
  return LX(Z) && pX(Z) == yX;
}
var RX = KX, xX = RX, rX = dd, Qd = sd, fd = Qd && Qd.isSet, SX = fd ? rX(fd) : xX, YX = SX, CX = Ws, JX = Dc, FX = us, TX = UZ, NX = sm, gX = tm, HX = cm, zX = hm, MX = Fm, kX = Ys, vX = Pm, UX = zl, QX = un, fX = dX, PX = XX, wX = Hl, EX = ld, jX = IX, BX = ll, OX = YX, DX = bd, AX = cd, qX = 1, $X = 2, _X = 4, Fs = "[object Arguments]", io = "[object Array]", lo = "[object Boolean]", so = "[object Date]", to = "[object Error]", Ts = "[object Function]", bo = "[object GeneratorFunction]", co = "[object Map]", Zo = "[object Number]", Ns = "[object Object]", mo = "[object RegExp]", no = "[object Set]", Xo = "[object String]", oo = "[object Symbol]", ao = "[object WeakMap]", eo = "[object ArrayBuffer]", Wo = "[object DataView]", Go = "[object Float32Array]", uo = "[object Float64Array]", Vo = "[object Int8Array]", ho = "[object Int16Array]", Io = "[object Int32Array]", po = "[object Uint8Array]", Lo = "[object Uint8ClampedArray]", yo = "[object Uint16Array]", Ko = "[object Uint32Array]", Ti = {};
Ti[Fs] = Ti[io] = Ti[eo] = Ti[Wo] = Ti[lo] = Ti[so] = Ti[Go] = Ti[uo] = Ti[Vo] = Ti[ho] = Ti[Io] = Ti[co] = Ti[Zo] = Ti[Ns] = Ti[mo] = Ti[no] = Ti[Xo] = Ti[oo] = Ti[po] = Ti[Lo] = Ti[yo] = Ti[Ko] = !0;
Ti[to] = Ti[Ts] = Ti[ao] = !1;
function Kl(Z, l, i, s, c, W) {
  var h, e = l & qX, a = l & $X, G = l & _X;
  if (i && (h = c ? i(Z, s, c, W) : i(Z)), h !== void 0)
    return h;
  if (!BX(Z))
    return Z;
  var y = wX(Z);
  if (y) {
    if (h = QX(Z), !e)
      return HX(Z, h);
  } else {
    var n = UX(Z), V = n == Ts || n == bo;
    if (EX(Z))
      return gX(Z, e);
    if (n == Ns || n == Fs || V && !c) {
      if (h = a || V ? {} : PX(Z), !e)
        return a ? MX(Z, NX(h, Z)) : zX(Z, TX(h, Z));
    } else {
      if (!Ti[n])
        return c ? Z : {};
      h = fX(Z, n, e);
    }
  }
  W || (W = new CX());
  var I = W.get(Z);
  if (I)
    return I;
  W.set(Z, h), OX(Z) ? Z.forEach(function(o) {
    h.add(Kl(o, l, i, o, Z, W));
  }) : jX(Z) && Z.forEach(function(o, u) {
    h.set(u, Kl(o, l, i, u, Z, W));
  });
  var r = G ? a ? vX : kX : a ? AX : DX, p = y ? void 0 : r(Z);
  return JX(p || Z, function(o, u) {
    p && (u = o, o = Z[u]), FX(h, u, Kl(o, l, i, u, Z, W));
  }), h;
}
var Ro = Kl, xo = Ro, ro = 1, So = 4;
function Yo(Z) {
  return xo(Z, ro | So);
}
var Co = Yo;
const _i = /* @__PURE__ */ $l(Co);
class Ai {
  constructor() {
    Object.defineProperty(this, "emtType", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "emitter", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "mainEngine", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "serviceColloctor", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
  }
  static dispatch(l, i, s, c) {
    l == null || l.emit([i, s], c);
  }
  registerForMainEngine(l, i, s, c) {
    var W;
    return this.emitter = l, this.emtType = i, this.mainEngine = s, this.serviceColloctor = c, this.emtType && ((W = this.emitter) == null || W.on([this.emtType, this.emitEventType], this.collect.bind(this))), this;
  }
  destroy() {
    var l;
    this.emtType && ((l = this.emitter) == null || l.off([this.emtType, this.emitEventType], this.collect.bind(this)));
  }
  collectForLocalWorker(l) {
    var i;
    l.forEach((s) => {
      var c;
      (c = this.mainEngine) == null || c.taskBatchData.set(`${s.msgType},${s.workId}`, s);
    }), (i = this.mainEngine) == null || i.runAnimation();
  }
  collectForServiceWorker(l) {
    requestIdleCallback(() => {
      l.forEach((i) => {
        var s;
        (s = this.serviceColloctor) == null || s.dispatch(i);
      });
    }, { timeout: wi.maxLastSyncTime });
  }
}
class Jo extends Ai {
  constructor() {
    super(...arguments), Object.defineProperty(this, "emitEventType", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: Gi.ZIndexActive
    });
  }
  collect(l) {
    if (!this.serviceColloctor || !this.mainEngine)
      return;
    const { workId: i, isActive: s } = l, c = [], W = [];
    i === Li.selectorId && c.push({
      workId: i,
      msgType: hi.UpdateNode,
      dataType: Ji.Local,
      isActiveZIndex: s,
      emitEventType: this.emitEventType,
      willRefreshSelector: !0,
      willSyncService: !1
    }), c.length && this.collectForLocalWorker(c), W.length && this.collectForServiceWorker(W);
  }
}
class Fo extends Ai {
  constructor() {
    super(...arguments), Object.defineProperty(this, "emitEventType", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: Gi.CopyNode
    });
  }
  collect(l) {
    var G;
    if (!this.serviceColloctor || !this.mainEngine)
      return;
    const { workIds: i } = l, s = [...i], c = (G = this.serviceColloctor) == null ? void 0 : G.storage, W = [], h = [], e = Math.floor(Math.random() * 20 + 10);
    let a;
    for (; s.length; ) {
      const y = s.pop();
      if (!y)
        continue;
      const n = y.toString(), V = this.serviceColloctor.isLocalId(n), I = V ? this.serviceColloctor.transformKey(y) : n, r = _i(c[I]);
      let p = n;
      if (!V && this.serviceColloctor.isOwn(p) && (p = this.serviceColloctor.getLocalId(p)), r && p === Li.selectorId) {
        r.selectIds && s.push(...r.selectIds);
        continue;
      }
      if (r) {
        const o = Date.now(), u = (V ? y : this.serviceColloctor.getLocalId(y.toString())) + "-" + o, d = r.updateNodeOpt || {}, b = d.pos || [0, 0];
        a || (a = [-b[0], -b[1]]), d.pos = [b[0] + a[0] + e, b[1] + a[1] + e], d.useAnimation = !1;
        const t = [d.pos[0] - b[0], d.pos[1] - b[1]];
        if (r.ops) {
          const m = bs(r.ops).map((S, C) => {
            const F = C % 3;
            return F === 0 ? S + t[0] : F === 1 ? S + t[1] : S;
          }), R = cs(m);
          r.ops = R, h.push({
            ...r,
            updateNodeOpt: d,
            type: hi.FullWork,
            workId: u
          }), W.push({
            ...r,
            workId: u,
            msgType: hi.FullWork,
            dataType: Ji.Local,
            updateNodeOpt: d,
            emitEventType: this.emitEventType,
            willSyncService: !1,
            willRefresh: !0
          });
        }
      }
    }
    W.length && this.collectForLocalWorker(W), h.length && this.collectForServiceWorker(h);
  }
}
class To extends Ai {
  constructor() {
    super(...arguments), Object.defineProperty(this, "emitEventType", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: Gi.SetColorNode
    });
  }
  collect(l) {
    if (!this.serviceColloctor || !this.mainEngine)
      return;
    const { workIds: i, color: s, opacity: c } = l, W = [...i], h = this.serviceColloctor.storage, e = [], a = [], G = [];
    for (; W.length; ) {
      const y = W.pop();
      if (!y)
        continue;
      const n = y.toString(), V = this.serviceColloctor.isLocalId(n), I = V ? this.serviceColloctor.transformKey(y) : n, r = _i(h[I]);
      let p = n;
      if (!V && this.serviceColloctor.isOwn(p) && (p = this.serviceColloctor.getLocalId(p)), r && p === Li.selectorId) {
        if (r.selectIds) {
          G.push(...r.selectIds);
          const o = r.updateNodeOpt || {};
          o.color = s, c && (o.opacity = c);
          const u = {
            workId: y,
            msgType: hi.UpdateNode,
            dataType: Ji.Local,
            updateNodeOpt: o,
            emitEventType: this.emitEventType,
            willRefreshSelector: !0,
            willSyncService: !0
          }, d = /* @__PURE__ */ new Map();
          G.forEach((b) => {
            var S, C, F;
            const t = (S = this.serviceColloctor) == null ? void 0 : S.isLocalId(b);
            let m = t && ((C = this.serviceColloctor) == null ? void 0 : C.transformKey(b)) || b;
            const R = h[m];
            !t && ((F = this.serviceColloctor) != null && F.isOwn(m)) && (m = this.serviceColloctor.getLocalId(m)), R != null && R.opt && d.set(m, {
              updateNodeOpt: R.updateNodeOpt,
              opt: R.opt
            });
          }), u.selectStore = d, u.willSerializeData = !0, e.push(u);
        }
        continue;
      }
      if (r) {
        const o = r.opt, u = r.updateNodeOpt || {};
        if (o && (u.color = s, u.opacity = c, a.push({
          ...r,
          type: hi.UpdateNode,
          updateNodeOpt: u
        }), !G.includes(n))) {
          let d = n;
          !V && this.serviceColloctor.isOwn(d) && (d = this.serviceColloctor.getLocalId(d)), e.push({
            workId: d,
            msgType: hi.UpdateNode,
            dataType: Ji.Local,
            updateNodeOpt: u,
            emitEventType: this.emitEventType,
            willSyncService: !1,
            willRefresh: !0
          });
        }
      }
    }
    e.length && this.collectForLocalWorker(e), a.length && this.collectForServiceWorker(a);
  }
}
class No extends Ai {
  constructor() {
    super(...arguments), Object.defineProperty(this, "emitEventType", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: Gi.ZIndexNode
    });
  }
  collect(l) {
    if (!this.serviceColloctor || !this.mainEngine)
      return;
    const { workIds: i, num: s } = l, c = [...i], W = this.serviceColloctor.storage, h = [], e = [], a = [];
    for (; c.length; ) {
      const G = c.pop();
      if (!G)
        continue;
      const y = G.toString(), n = this.serviceColloctor.isLocalId(y), V = n ? this.serviceColloctor.transformKey(G) : y, I = _i(W[V]);
      let r = y;
      if (!n && this.serviceColloctor.isOwn(r) && (r = this.serviceColloctor.getLocalId(r)), I && r === Li.selectorId) {
        if (I.selectIds) {
          a.push(...I.selectIds);
          const p = I.updateNodeOpt || {};
          p.zIndexDistance = s;
          const o = {
            workId: G,
            msgType: hi.UpdateNode,
            dataType: Ji.Local,
            updateNodeOpt: p,
            emitEventType: this.emitEventType,
            willRefreshSelector: !0,
            willSyncService: !0
          }, u = /* @__PURE__ */ new Map();
          a.forEach((d) => {
            var R, S, C;
            const b = (R = this.serviceColloctor) == null ? void 0 : R.isLocalId(d);
            let t = b && ((S = this.serviceColloctor) == null ? void 0 : S.transformKey(d)) || d;
            const m = W[t];
            !b && ((C = this.serviceColloctor) != null && C.isOwn(t)) && (t = this.serviceColloctor.getLocalId(t)), m != null && m.opt && u.set(t, {
              updateNodeOpt: m.updateNodeOpt,
              opt: m.opt
            });
          }), o.selectStore = u, o.willSerializeData = !0, h.push(o);
        }
        continue;
      }
      if (I) {
        const p = I.opt, o = I.updateNodeOpt || {};
        let u = o.zIndex || (p == null ? void 0 : p.zIndex) || 0;
        if (p && (u = u + s, o.zIndex = u, e.push({
          ...I,
          type: hi.UpdateNode,
          updateNodeOpt: o
        }), !a.includes(y))) {
          let d = y;
          !n && this.serviceColloctor.isOwn(d) && (d = this.serviceColloctor.getLocalId(d)), h.push({
            workId: d,
            msgType: hi.UpdateNode,
            dataType: Ji.Local,
            updateNodeOpt: o,
            emitEventType: this.emitEventType,
            willSyncService: !1,
            willRefresh: !0
          });
        }
      }
    }
    h.length && this.collectForLocalWorker(h), e.length && this.collectForServiceWorker(e);
  }
}
class go extends Ai {
  constructor() {
    super(...arguments), Object.defineProperty(this, "emitEventType", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: Gi.TranslateNode
    }), Object.defineProperty(this, "oldRect", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
  }
  collect(l) {
    var I, r, p, o, u;
    if (!this.serviceColloctor || !this.mainEngine)
      return;
    const { workIds: i, position: s, workState: c } = l, W = [...i], h = (I = this.serviceColloctor) == null ? void 0 : I.storage, e = [], a = [], G = [], y = (p = (r = this.mainEngine.displayer) == null ? void 0 : r.canvasBgRef) == null ? void 0 : p.getBoundingClientRect(), n = (u = (o = this.mainEngine.displayer) == null ? void 0 : o.floatBarCanvasRef.current) == null ? void 0 : u.getBoundingClientRect();
    let V = !1;
    for (y && n && this.oldRect && (this.oldRect.x < y.x && n.x > this.oldRect.x || this.oldRect.y < y.y && n.y > this.oldRect.y || this.oldRect.x + this.oldRect.width > y.x + y.width && n.x < this.oldRect.x || this.oldRect.y + this.oldRect.height > y.y + y.height && n.y < this.oldRect.y) && (V = !0), n && (this.oldRect = n); W.length; ) {
      const d = W.pop();
      if (!d)
        continue;
      const b = d.toString(), t = this.serviceColloctor.isLocalId(b), m = t && this.serviceColloctor.transformKey(d) || b, R = _i(h[m]);
      let S = b;
      if (!t && this.serviceColloctor.isOwn(S) && (S = this.serviceColloctor.getLocalId(S)), R && S === Li.selectorId) {
        if (R.selectIds && (G.push(...R.selectIds), c !== pi.Start)) {
          const C = R.updateNodeOpt || {};
          C.pos = this.mainEngine.transformToScenePoint([s.x, s.y]), C.workState = c;
          const F = {
            workId: d,
            msgType: hi.UpdateNode,
            dataType: Ji.Local,
            updateNodeOpt: C,
            emitEventType: this.emitEventType,
            willRefreshSelector: V,
            willSyncService: !0
          };
          if (c === pi.Done) {
            const K = /* @__PURE__ */ new Map();
            G.forEach((J) => {
              var H, Q, w;
              const T = (H = this.serviceColloctor) == null ? void 0 : H.isLocalId(J);
              let Y = T && ((Q = this.serviceColloctor) == null ? void 0 : Q.transformKey(J)) || J;
              const x = h[Y];
              !T && ((w = this.serviceColloctor) != null && w.isOwn(Y)) && (Y = this.serviceColloctor.getLocalId(Y)), x != null && x.ops && K.set(Y, {
                ops: x.ops,
                updateNodeOpt: x.updateNodeOpt
              });
            }), F.selectStore = K, F.willSerializeData = !0;
          }
          e.push(F);
        }
        continue;
      }
      if (R) {
        const C = R.opt, F = R.updateNodeOpt || {};
        if (C && (F.pos = this.mainEngine.transformToScenePoint([s.x, s.y]), a.push({
          ...R,
          type: hi.UpdateNode,
          updateNodeOpt: F
        }), !G.includes(b))) {
          let K = b;
          !t && this.serviceColloctor.isOwn(K) && (K = this.serviceColloctor.getLocalId(K)), e.push({
            workId: K,
            msgType: hi.UpdateNode,
            dataType: Ji.Local,
            updateNodeOpt: F,
            emitEventType: this.emitEventType,
            willSyncService: !1,
            willRefresh: !0
          });
        }
      }
    }
    e.length && this.collectForLocalWorker(e), a.length && this.collectForServiceWorker(a);
  }
}
class Ho extends Ai {
  constructor() {
    super(...arguments), Object.defineProperty(this, "emitEventType", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: Gi.DeleteNode
    });
  }
  collect(l) {
    var a;
    if (!this.serviceColloctor || !this.mainEngine)
      return;
    const { workIds: i } = l, s = this.serviceColloctor.storage, c = [...i], W = [], h = [], e = [];
    for (; c.length; ) {
      const G = c.pop();
      if (!G)
        continue;
      const y = G.toString(), n = this.serviceColloctor.isLocalId(y), V = n ? this.serviceColloctor.transformKey(G) : y, I = s[V];
      let r = y;
      if (!n && this.serviceColloctor.isOwn(r) && (r = this.serviceColloctor.getLocalId(r)), I && r === Li.selectorId) {
        e.push(V), (a = this.emitter) == null || a.emit([Ii.FloatBar, Gi.ShowFloatBar], !1), I.selectIds && (e.push(...I.selectIds), W.push({
          msgType: hi.RemoveNode,
          workId: r,
          dataType: Ji.Local,
          emitEventType: Gi.DeleteNode
        }));
        continue;
      }
      I && e.push(V), W.push({
        msgType: hi.RemoveNode,
        emitEventType: Gi.DeleteNode,
        workId: G,
        dataType: Ji.Local,
        willSyncService: !1,
        willRefresh: !0
      });
    }
    W.length && this.collectForLocalWorker(W), e.length && (h.push({
      type: hi.RemoveNode,
      removeIds: e
    }), this.collectForServiceWorker(h));
  }
}
class zo extends Ai {
  constructor() {
    super(...arguments), Object.defineProperty(this, "emitEventType", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: Gi.ScaleNode
    });
  }
  collect(l) {
    var y;
    if (!this.serviceColloctor || !this.mainEngine)
      return;
    const { workIds: i, size: s, workState: c } = l, W = [...i], h = (y = this.serviceColloctor) == null ? void 0 : y.storage, e = [], a = [], G = [];
    for (; W.length; ) {
      const n = W.pop();
      if (!n)
        continue;
      const V = n.toString(), I = this.serviceColloctor.isLocalId(V), r = I ? this.serviceColloctor.transformKey(n) : V, p = _i(h[r]);
      let o = V;
      if (!I && this.serviceColloctor.isOwn(o) && (o = this.serviceColloctor.getLocalId(o)), p && o === Li.selectorId) {
        if (p.selectIds && (G.push(...p.selectIds), c !== pi.Start)) {
          const u = p.updateNodeOpt || {};
          u.size = s, u.workState = c;
          const d = {
            workId: n,
            msgType: hi.UpdateNode,
            dataType: Ji.Local,
            updateNodeOpt: u,
            emitEventType: this.emitEventType,
            willRefreshSelector: !0,
            willSyncService: !0
          };
          if (c === pi.Done) {
            const b = /* @__PURE__ */ new Map();
            G.forEach((t) => {
              var C, F, K;
              const m = (C = this.serviceColloctor) == null ? void 0 : C.isLocalId(t);
              let R = m && ((F = this.serviceColloctor) == null ? void 0 : F.transformKey(t)) || t;
              const S = h[R];
              !m && ((K = this.serviceColloctor) != null && K.isOwn(R)) && (R = this.serviceColloctor.getLocalId(R)), S != null && S.ops && b.set(R, {
                ops: S.ops,
                updateNodeOpt: S.updateNodeOpt,
                opt: S.opt,
                toolsType: S.toolsType
              });
            }), d.selectStore = b, d.willSerializeData = !0;
          }
          e.push(d);
        }
        continue;
      }
      if (p) {
        const u = p.opt, d = p.updateNodeOpt || {};
        if (u && (d.size = s, a.push({
          ...p,
          type: hi.UpdateNode,
          updateNodeOpt: d
        }), !G.includes(V))) {
          let b = V;
          !I && this.serviceColloctor.isOwn(b) && (b = this.serviceColloctor.getLocalId(b)), e.push({
            workId: b,
            msgType: hi.UpdateNode,
            dataType: Ji.Local,
            updateNodeOpt: d,
            emitEventType: this.emitEventType,
            willSyncService: !1,
            willRefresh: !0
          });
        }
      }
    }
    e.length && this.collectForLocalWorker(e), a.length && this.collectForServiceWorker(a);
  }
}
class Mo extends Ai {
  constructor() {
    super(...arguments), Object.defineProperty(this, "emitEventType", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: Gi.RotateNode
    });
  }
  collect(l) {
    var y;
    if (!this.serviceColloctor || !this.mainEngine)
      return;
    const { workIds: i, angle: s, workState: c } = l, W = [...i], h = (y = this.serviceColloctor) == null ? void 0 : y.storage, e = [], a = [], G = [];
    for (; W.length; ) {
      const n = W.pop();
      if (!n)
        continue;
      const V = n.toString(), I = this.serviceColloctor.isLocalId(V), r = I && this.serviceColloctor.transformKey(n) || V, p = _i(h[r]);
      let o = V;
      if (!I && this.serviceColloctor.isOwn(o) && (o = this.serviceColloctor.getLocalId(o)), p && o === Li.selectorId) {
        if (p.selectIds && (G.push(...p.selectIds), c !== pi.Start)) {
          const u = p.updateNodeOpt || {};
          u.angle = s, u.workState = c;
          const d = {
            workId: n,
            msgType: hi.UpdateNode,
            dataType: Ji.Local,
            updateNodeOpt: u,
            emitEventType: this.emitEventType,
            willRefreshSelector: !1,
            willSyncService: !0
          };
          if (c === pi.Done) {
            const b = /* @__PURE__ */ new Map();
            G.forEach((t) => {
              var C, F, K;
              const m = (C = this.serviceColloctor) == null ? void 0 : C.isLocalId(t);
              let R = m && ((F = this.serviceColloctor) == null ? void 0 : F.transformKey(t)) || t;
              const S = h[R];
              !m && ((K = this.serviceColloctor) != null && K.isOwn(R)) && (R = this.serviceColloctor.getLocalId(R)), S != null && S.ops && b.set(R, {
                ops: S.ops,
                updateNodeOpt: S.updateNodeOpt,
                opt: S.opt,
                toolsType: S.toolsType
              });
            }), d.willRefreshSelector = !0, d.selectStore = b, d.willSerializeData = !0;
          }
          e.push(d);
        }
        continue;
      }
      if (p) {
        const u = p.opt, d = p.updateNodeOpt || {};
        if (u && (d.angle = s, a.push({
          ...p,
          type: hi.UpdateNode,
          updateNodeOpt: d
        }), !G.includes(V))) {
          let b = V;
          !I && this.serviceColloctor.isOwn(b) && (b = this.serviceColloctor.getLocalId(b)), e.push({
            workId: b,
            msgType: hi.UpdateNode,
            dataType: Ji.Local,
            updateNodeOpt: d,
            emitEventType: this.emitEventType,
            willSyncService: !1,
            willRefresh: !0
          });
        }
      }
    }
    e.length && this.collectForLocalWorker(e), a.length && this.collectForServiceWorker(a);
  }
}
class zi {
  constructor(l) {
    Object.defineProperty(this, "builders", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: /* @__PURE__ */ new Map()
    }), this.builders = new Map(l.map((i) => [i, this.build(i)]));
  }
  build(l) {
    switch (l) {
      case Gi.TranslateNode:
        return new go();
      case Gi.ZIndexNode:
        return new No();
      case Gi.ZIndexActive:
        return new Jo();
      case Gi.CopyNode:
        return new Fo();
      case Gi.SetColorNode:
        return new To();
      case Gi.DeleteNode:
        return new Ho();
      case Gi.ScaleNode:
        return new zo();
      case Gi.RotateNode:
        return new Mo();
    }
  }
  registerForMainEngine(l, i, s, c) {
    return this.builders.forEach((W) => {
      W && W.registerForMainEngine(l, i, s, c);
    }), this;
  }
  destroy() {
    this.builders.forEach((l) => {
      l && l.destroy();
    });
  }
  static emitMethod(l, i, s, c) {
    Ai.dispatch(l, i, s, c);
  }
}
class wi extends it {
  constructor(l, i, s, c) {
    var W, h;
    if (super(l, i), Object.defineProperty(this, "dpr", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 1
    }), Object.defineProperty(this, "InternalMsgEmitter", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "threadEngine", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "pluginOptions", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "layerOpt", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "msgEmitter", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "offscreenCanvasOpt", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "originalPoint", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: [0, 0]
    }), Object.defineProperty(this, "cameraOpt", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "localPointsBatchData", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "taskBatchData", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: /* @__PURE__ */ new Map()
    }), Object.defineProperty(this, "currentToolsData", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "currentLocalWorkData", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "animationId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "workerLockId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "subWorker", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "maxDrawCount", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "wokerDrawCount", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "cacheDrawCount", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "reRenders", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "bgCanvas", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "floatCanvas", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "maxLayerIndex", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "methodBuilder", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.bgCanvas = l.canvasBgRef, this.floatCanvas = l.canvasFloatRef, this.bgCanvas && this.floatCanvas) {
      this.pluginOptions = s, wi.maxLastSyncTime = ((W = s == null ? void 0 : s.syncOpt) == null ? void 0 : W.interval) || wi.maxLastSyncTime, this.msgEmitter = new lt();
      const e = {
        ...wi.defaultScreenCanvasOpt,
        ...(h = this.pluginOptions) == null ? void 0 : h.canvasOpt,
        width: this.bgCanvas.offsetWidth,
        height: this.bgCanvas.offsetHeight
      };
      this.offscreenCanvasOpt = e, this.layerOpt = wi.defauleLayerOpt, this.setLayerOpt(this.layerOpt), this.setCurrentLocalWorkData({
        workId: void 0,
        workState: pi.Pending
      }), this.InternalMsgEmitter = c, this.internalMsgEmitterListener(), this.on();
    }
  }
  internalMsgEmitterListener() {
    var l, i, s;
    this.InternalMsgEmitter && this.collector && (this.methodBuilder = new zi([
      Gi.CopyNode,
      Gi.SetColorNode,
      Gi.DeleteNode,
      Gi.RotateNode,
      Gi.ScaleNode,
      Gi.TranslateNode,
      Gi.ZIndexActive,
      Gi.ZIndexNode,
      Gi.RotateNode
    ]).registerForMainEngine(this.InternalMsgEmitter, Ii.MainEngine, this, this.collector)), (l = this.InternalMsgEmitter) == null || l.on([Ii.MainEngine, Gi.CreateScene], this.createSceneLintener.bind(this)), (i = this.InternalMsgEmitter) == null || i.on([Ii.MainEngine, Gi.OriginalEvent], this.originalEventLintener.bind(this)), (s = this.InternalMsgEmitter) == null || s.on([Ii.FloatBar, Gi.ShowFloatBar], this.showFloatBar.bind(this));
  }
  showFloatBar(l) {
    l ? window.addEventListener("beforeunload", this.removeSelectorFromStore.bind(this)) : window.removeEventListener("beforeunload", this.removeSelectorFromStore.bind(this));
  }
  removeSelectorFromStore() {
    this.collector.dispatch({
      type: hi.Select,
      selectIds: void 0
    });
  }
  internalMsgEmitterRemoveListener() {
    var l, i, s;
    (l = this.methodBuilder) == null || l.destroy(), (i = this.InternalMsgEmitter) == null || i.off([Ii.MainEngine, Gi.CreateScene], this.createSceneLintener.bind(this)), (s = this.InternalMsgEmitter) == null || s.off([Ii.MainEngine, Gi.OriginalEvent], this.originalEventLintener.bind(this));
  }
  createSceneLintener(l, i, s) {
    this.offscreenCanvasOpt = {
      ...this.offscreenCanvasOpt,
      width: l,
      height: i
    }, this.dpr = s, this.originalPoint = [l / 2, i / 2], this.cameraOpt = {
      centerX: 0,
      centerY: 0,
      scale: 1,
      width: l,
      height: i
    }, this.createThreadEngine(), this.createOptimizationWorker();
  }
  originalEventLintener(l, i) {
    switch (l) {
      case pi.Start:
        this.onLocalEventStart(i);
        break;
      case pi.Doing:
        this.onLocalEventDoing(i);
        break;
      case pi.Done:
        this.onLocalEventEnd(i);
        break;
    }
  }
  createOptimizationWorker() {
    this.subWorker = new dt(), this.subWorker.onmessage = (l) => {
      if (l.data) {
        const { render: i, drawCount: s, sp: c } = l.data;
        if (c != null && c.length && this.collectorSyncData(c), !s && i) {
          this.render(i);
          return;
        }
        s && (s > this.maxDrawCount && (this.maxDrawCount = s), i && (s > this.wokerDrawCount && (i.isUnClose = !0, this.reRenders.push(i)), this.render(i)));
      }
    };
  }
  destroySubWorker() {
    this.subWorker && (this.subWorker.terminate(), this.subWorker = void 0);
  }
  createThreadEngine() {
    this.taskBatchData.set("Init", {
      msgType: hi.Init,
      dataType: Ji.Local,
      offscreenCanvasOpt: this.offscreenCanvasOpt,
      layerOpt: this.layerOpt,
      dpr: this.dpr,
      isRunSubWork: !0
    }), this.runAnimation();
  }
  render(l) {
    var a, G, y, n, V, I, r, p;
    const { rect: i, imageBitmap: s, isClear: c, isUnClose: W, drawCanvas: h, clearCanvas: e } = l;
    if (i) {
      const o = i.w * this.dpr, u = i.h * this.dpr, d = i.x * this.dpr, b = i.y * this.dpr;
      if (c)
        if (e === Zl.Selector)
          (G = (a = this.displayer.floatBarCanvasRef.current) == null ? void 0 : a.getContext("2d")) == null || G.clearRect(0, 0, o, u);
        else {
          const t = e === Zl.Float ? (y = this.floatCanvas) == null ? void 0 : y.getContext("2d") : (n = this.bgCanvas) == null ? void 0 : n.getContext("2d");
          t == null || t.clearRect(d, b, o, u);
        }
      if (h && s)
        if (h === Zl.Selector)
          (I = (V = this.displayer.floatBarCanvasRef.current) == null ? void 0 : V.getContext("2d")) == null || I.drawImage(s, 0, 0, o, u, 0, 0, o, u);
        else {
          const t = h === Zl.Float ? (r = this.floatCanvas) == null ? void 0 : r.getContext("2d") : (p = this.bgCanvas) == null ? void 0 : p.getContext("2d");
          t == null || t.drawImage(s, 0, 0, o, u, d, b, o, u);
        }
      if (W)
        return;
      s == null || s.close();
    }
  }
  runAnimation() {
    this.animationId || (this.animationId = requestAnimationFrame(this.consume.bind(this)));
  }
  setLayerOpt(l) {
    this.layerOpt = l;
  }
  updateCanvas(l) {
    const { width: i, height: s } = l;
    this.bgCanvas && this.floatCanvas && (this.bgCanvas.width = i * this.dpr, this.bgCanvas.height = s * this.dpr, this.floatCanvas.width = i * this.dpr, this.floatCanvas.height = s * this.dpr), this.originalPoint = [i * 0.5, s * 0.5], this.offscreenCanvasOpt.width = i, this.offscreenCanvasOpt.height = s;
  }
  pushPoint(l) {
    this.localPointsBatchData.push(l[0], l[1]);
  }
  transformToScenePoint(l) {
    const i = l, { scale: s, centerX: c, centerY: W } = this.cameraOpt;
    return this.originalPoint && (i[0] = (l[0] - this.originalPoint[0]) / s + c, i[1] = (l[1] - this.originalPoint[1]) / s + W), i;
  }
  initSyncData(l) {
    var s, c, W;
    const i = (s = this.collector) == null ? void 0 : s.storage;
    if (i) {
      for (const h of Object.keys(i).filter((e) => this.collector.getLocalId(e) !== "selector")) {
        l && l(h, i[h]);
        const e = (c = i[h]) == null ? void 0 : c.type;
        if (e && h) {
          const a = _i(i[h]);
          a.workId = h, a.msgType = e, a.dataType = Ji.Service, a.useAnimation = !1, this.taskBatchData.set(`${a.dataType},${a.msgType},${a.workId}`, a), (W = a.opt) != null && W.zIndex && (this.maxLayerIndex = Math.max(this.maxLayerIndex, a.opt.zIndex));
        }
      }
      this.runAnimation();
    }
  }
  getRelevantWork(l) {
    let i;
    for (const [s, c] of Object.entries(l))
      if (c) {
        const { newValue: W, oldValue: h } = c;
        if (!W && h && Object.keys(l).some((a) => a !== s && a.indexOf(`${s}_s_`) > -1 ? (i = s, !0) : !1))
          break;
      }
    return i;
  }
  onServiceDerive(l, i, s) {
    const { newValue: c, oldValue: W } = i, h = _i(c) || {}, e = l;
    let a = h.type;
    if (!(!c && W && (a = hi.RemoveNode, W.toolsType === Yi.LaserPen))) {
      if (a && e) {
        const G = h;
        G.workId = this.collector.isOwn(l) ? this.collector.getLocalId(l) : e, G.msgType = a, G.dataType = Ji.Service, G.selectIds && (G.selectIds = G.selectIds.map((y) => this.collector.isOwn(y) ? this.collector.getLocalId(y) : y)), s === l ? setTimeout(() => {
          this.taskBatchData.set(`${G.dataType},${G.msgType},${G.workId}`, G), this.runAnimation();
        }, 32) : this.taskBatchData.set(`${G.dataType},${G.msgType},${G.workId}`, G);
      }
      this.runAnimation();
    }
  }
  onLocalEventEnd(l) {
    var s;
    const i = this.currentLocalWorkData.workState;
    if (!(i === pi.Freeze || i === pi.Unwritable) && (i === pi.Start || i === pi.Doing)) {
      const c = this.transformToScenePoint(l);
      this.pushPoint(c), this.setCurrentLocalWorkData({ workId: this.currentLocalWorkData.workId, workState: pi.Done }), this.currentToolsData.toolsType === Yi.Selector && ((s = this.InternalMsgEmitter) == null || s.emit([Ii.FloatBar, Gi.ZIndexFloatBar], 2));
    }
  }
  onLocalEventDoing(l) {
    let i = this.currentLocalWorkData.workState;
    if (!(i === pi.Freeze || i === pi.Unwritable) && (i === pi.Start && (i = pi.Doing, this.setCurrentLocalWorkData({ workId: this.currentLocalWorkData.workId, workState: i })), i === pi.Doing)) {
      const s = this.transformToScenePoint(l);
      this.pushPoint(s);
    }
  }
  onLocalEventStart(l) {
    var h, e;
    const { workState: i } = this.currentLocalWorkData;
    if (i === pi.Freeze || i === pi.Unwritable)
      return;
    const s = this.currentToolsData.toolsType === Yi.Selector ? "selector" : Date.now(), c = this.currentToolsData.toolsOpt;
    this.currentToolsData.toolsType === Yi.Pencil && (this.maxLayerIndex = this.maxLayerIndex + 10, c.zIndex = this.maxLayerIndex), this.setCurrentLocalWorkData({
      workId: s,
      workState: pi.Start
    }, hi.CreateWork);
    const W = this.transformToScenePoint(l);
    this.pushPoint(W), this.maxDrawCount = 0, this.wokerDrawCount = 0, this.reRenders.length = 0, this.consume(), this.currentToolsData.toolsType === Yi.Pencil || this.currentToolsData.toolsType === Yi.LaserPen ? (h = this.collector) == null || h.dispatch({
      type: hi.CreateWork,
      workId: s,
      toolsType: this.currentToolsData.toolsType,
      opt: this.currentToolsData.toolsOpt
    }) : this.currentToolsData.toolsType === Yi.Selector && ((e = this.InternalMsgEmitter) == null || e.emit([Ii.FloatBar, Gi.ZIndexFloatBar], -1));
  }
  consume() {
    this.animationId = void 0;
    const l = this.currentLocalWorkData.workState;
    if (!this.workerLockId) {
      if (this.localPointsBatchData.length) {
        const i = this.currentToolsData.toolsType === Yi.Pencil || this.currentToolsData.toolsType === Yi.LaserPen;
        i ? (this.maxDrawCount && this.maxDrawCount !== this.cacheDrawCount || !this.maxDrawCount) && (this.cacheDrawCount = this.maxDrawCount, this.taskBatchData.set(this.currentLocalWorkData.workId, {
          op: this.localPointsBatchData,
          workState: l,
          workId: this.currentLocalWorkData.workId,
          dataType: Ji.Local,
          msgType: hi.DrawWork,
          drawCount: this.maxDrawCount,
          isRunSubWork: i
        })) : this.taskBatchData.set(this.currentLocalWorkData.workId, {
          op: this.localPointsBatchData,
          workState: l,
          workId: this.currentLocalWorkData.workId,
          dataType: Ji.Local,
          msgType: hi.DrawWork,
          drawCount: this.maxDrawCount,
          isRunSubWork: i
        });
      }
      this.taskBatchData.size && (this.post(this.taskBatchData), this.taskBatchData.clear(), this.localPointsBatchData.length = 0);
    }
    (l === pi.Doing || l === pi.Start || this.taskBatchData.size || this.localPointsBatchData.length) && (this.animationId = requestAnimationFrame(this.consume.bind(this)));
  }
  clearAll(l = !1) {
    var i;
    this.taskBatchData.set("ClearAll", {
      dataType: Ji.Local,
      msgType: hi.Clear
    }), this.runAnimation(), setTimeout(() => {
      var s;
      if (this.bgCanvas && this.floatCanvas) {
        const c = this.bgCanvas.getContext("2d");
        c == null || c.clearRect(0, 0, this.bgCanvas.width, this.bgCanvas.height);
        const W = this.floatCanvas.getContext("2d");
        W == null || W.clearRect(0, 0, this.floatCanvas.width, this.floatCanvas.height), (s = this.InternalMsgEmitter) == null || s.emit([Ii.FloatBar, Gi.ShowFloatBar], !1);
      }
    }, 100), l || (i = this.collector) == null || i.dispatch({
      type: hi.Clear
    }), this.maxLayerIndex = 0;
  }
  unabled() {
    this.setCurrentLocalWorkData({ workState: pi.Freeze, workId: void 0 });
  }
  abled() {
    this.setCurrentLocalWorkData({ workState: pi.Pending, workId: void 0 });
  }
  destroy() {
    var l;
    (l = this.msgEmitter) == null || l.terminate(), this.destroySubWorker(), this.internalMsgEmitterRemoveListener();
  }
  post(l) {
    var s;
    this.msgEmitter.postMessage(l);
    const i = /* @__PURE__ */ new Map();
    for (const [c, W] of l.entries())
      (c === "Init" || c === "ClearAll" || c === "UpdateScene" || c === "UpdateCamera" || W.isRunSubWork) && i.set(c, W);
    i.size && ((s = this.subWorker) == null || s.postMessage(i));
  }
  on() {
    this.msgEmitter.onmessage = (l) => {
      if (l.data) {
        const { render: i, sp: s, drawCount: c } = l.data;
        if (s != null && s.length && this.collectorSyncData(s), !c && i) {
          this.render(i);
          return;
        }
        c && (this.wokerDrawCount = c, c > this.maxDrawCount && (this.maxDrawCount = c), i && (this.render(i), c < this.maxDrawCount && (this.reRenders.forEach((W) => {
          W.isUnClose = !1, this.render(W);
        }), this.reRenders.length = 0)));
      }
    };
  }
  collectorSyncData(l) {
    var i;
    for (const s of l) {
      const { type: c, op: W, workId: h, index: e, removeIds: a, ops: G, selectIds: y, opt: n, padding: V, selectRect: I, updateNodeOpt: r, nodeColor: p, willSyncService: o, toolsType: u } = s;
      switch (c) {
        case hi.DrawWork:
          W != null && W.length && h && typeof e == "number" && requestIdleCallback(() => {
            var b;
            (b = this.collector) == null || b.dispatch({
              type: c,
              op: W,
              workId: h,
              index: e
            });
          }, { timeout: wi.maxLastSyncTime });
          break;
        case hi.FullWork:
          G && requestIdleCallback(() => {
            var b;
            (b = this.collector) == null || b.dispatch({ type: c, ops: G, workId: h, updateNodeOpt: r, opt: n, toolsType: u });
          }, { timeout: wi.maxLastSyncTime });
          break;
        case hi.UpdateNode:
          (r || n || G) && requestIdleCallback(() => {
            var b;
            (b = this.collector) == null || b.dispatch({ type: c, updateNodeOpt: r, workId: h, opt: n, ops: G });
          }, { timeout: wi.maxLastSyncTime });
          break;
        case hi.RemoveNode:
          (W || a != null && a.length) && requestIdleCallback(() => {
            var b;
            (b = this.collector) == null || b.dispatch({ type: c, removeIds: a });
          }, { timeout: wi.maxLastSyncTime });
          break;
        case hi.Select:
          const d = y != null && y.length ? { ...I, selectIds: y } : void 0;
          d && (n != null && n.color) && (d.color = n.color), d && (n != null && n.opacity) && (d.opacity = n.opacity), d && V && (d.padding = V), d && p && (d.nodeColor = p), (i = this.InternalMsgEmitter) == null || i.emit([Ii.FloatBar, Gi.ShowFloatBar], !!d, d), o && requestIdleCallback(() => {
            var b;
            (b = this.collector) == null || b.dispatch({ type: c, selectIds: y, opt: n });
          }, { timeout: wi.maxLastSyncTime });
          break;
      }
    }
  }
  updateNode(l, i) {
    this.taskBatchData.set(`${hi.UpdateNode},${l}`, {
      msgType: hi.UpdateNode,
      workId: l,
      updateNodeOpt: i,
      dataType: Ji.Local
    }), this.runAnimation();
  }
  setCurrentLocalWorkData(l, i = hi.None) {
    super.setCurrentLocalWorkData(l);
    const { workState: s, workId: c } = l;
    if (s !== pi.Unwritable && i !== hi.None) {
      const W = this.currentToolsData.toolsType;
      this.taskBatchData.set(`${i},${c}`, {
        msgType: i,
        workId: c,
        toolsType: W,
        opt: { ...this.currentToolsData.toolsOpt, syncUnitTime: wi.maxLastSyncTime },
        dataType: Ji.Local,
        isRunSubWork: W === Yi.Pencil || W === Yi.LaserPen
      }), this.runAnimation();
    }
  }
  setCurrentToolsData(l) {
    super.setCurrentToolsData(l);
    const i = l.toolsType;
    this.taskBatchData.set("UpdateTools", {
      msgType: hi.UpdateTools,
      dataType: Ji.Local,
      toolsType: i,
      opt: { ...l.toolsOpt, syncUnitTime: wi.maxLastSyncTime },
      isRunSubWork: i === Yi.Pencil || i === Yi.LaserPen
    }), this.runAnimation();
  }
  setCameraOpt(l) {
    super.setCameraOpt(l);
    const { width: i, height: s } = l;
    (i !== this.offscreenCanvasOpt.width || s !== this.offscreenCanvasOpt.height) && (this.bgCanvas && (this.bgCanvas.style.width = `${i}px`, this.bgCanvas.style.height = `${s}px`), this.floatCanvas && (this.floatCanvas.style.width = `${i}px`, this.floatCanvas.style.height = `${s}px`), this.updateCanvas({ width: i, height: s })), this.taskBatchData.set("UpdateCamera", {
      msgType: hi.UpdateCamera,
      dataType: Ji.Local,
      cameraOpt: l,
      isRunSubWork: !0
    }), this.runAnimation();
  }
}
Object.defineProperty(wi, "defaultScreenCanvasOpt", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: {
    autoRender: !1,
    contextType: Pl.Canvas2d
    // bufferSize: 5000
  }
});
Object.defineProperty(wi, "defauleLayerOpt", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: {
    offscreen: !0,
    handleEvent: !1,
    depth: !1
  }
});
Object.defineProperty(wi, "maxLastSyncTime", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 500
});
const ko = "index-module__Container__nLsM3", vo = "index-module__CanvasBox__j2Xe-", Uo = "index-module__FloatCanvas__d1YR7", Qo = "index-module__FloatBar__cm-EL", fo = "index-module__RotateBtn__HSSkf", Vl = {
  Container: ko,
  CanvasBox: vo,
  FloatCanvas: Uo,
  FloatBar: Qo,
  RotateBtn: fo
};
var Po = Bi, wo = function() {
  return Po.Date.now();
}, Eo = wo, jo = /\s/;
function Bo(Z) {
  for (var l = Z.length; l-- && jo.test(Z.charAt(l)); )
    ;
  return l;
}
var Oo = Bo, Do = Oo, Ao = /^\s+/;
function qo(Z) {
  return Z && Z.slice(0, Do(Z) + 1).replace(Ao, "");
}
var $o = qo, _o = pl, ia = bl, la = "[object Symbol]";
function da(Z) {
  return typeof Z == "symbol" || ia(Z) && _o(Z) == la;
}
var sa = da, ta = $o, Pd = ll, ba = sa, wd = NaN, ca = /^[-+]0x[0-9a-f]+$/i, Za = /^0b[01]+$/i, ma = /^0o[0-7]+$/i, na = parseInt;
function Xa(Z) {
  if (typeof Z == "number")
    return Z;
  if (ba(Z))
    return wd;
  if (Pd(Z)) {
    var l = typeof Z.valueOf == "function" ? Z.valueOf() : Z;
    Z = Pd(l) ? l + "" : l;
  }
  if (typeof Z != "string")
    return Z === 0 ? Z : +Z;
  Z = ta(Z);
  var i = Za.test(Z);
  return i || ma.test(Z) ? na(Z.slice(2), i ? 2 : 8) : ca.test(Z) ? wd : +Z;
}
var oa = Xa, aa = ll, vl = Eo, Ed = oa, ea = "Expected a function", Wa = Math.max, Ga = Math.min;
function ua(Z, l, i) {
  var s, c, W, h, e, a, G = 0, y = !1, n = !1, V = !0;
  if (typeof Z != "function")
    throw new TypeError(ea);
  l = Ed(l) || 0, aa(i) && (y = !!i.leading, n = "maxWait" in i, W = n ? Wa(Ed(i.maxWait) || 0, l) : W, V = "trailing" in i ? !!i.trailing : V);
  function I(R) {
    var S = s, C = c;
    return s = c = void 0, G = R, h = Z.apply(C, S), h;
  }
  function r(R) {
    return G = R, e = setTimeout(u, l), y ? I(R) : h;
  }
  function p(R) {
    var S = R - a, C = R - G, F = l - S;
    return n ? Ga(F, W - C) : F;
  }
  function o(R) {
    var S = R - a, C = R - G;
    return a === void 0 || S >= l || S < 0 || n && C >= W;
  }
  function u() {
    var R = vl();
    if (o(R))
      return d(R);
    e = setTimeout(u, p(R));
  }
  function d(R) {
    return e = void 0, V && s ? I(R) : (s = c = void 0, h);
  }
  function b() {
    e !== void 0 && clearTimeout(e), G = 0, s = a = c = e = void 0;
  }
  function t() {
    return e === void 0 ? h : d(vl());
  }
  function m() {
    var R = vl(), S = o(R);
    if (s = arguments, c = this, a = R, S) {
      if (e === void 0)
        return r(a);
      if (n)
        return clearTimeout(e), e = setTimeout(u, l), I(a);
    }
    return e === void 0 && (e = setTimeout(u, l)), h;
  }
  return m.cancel = b, m.flush = t, m;
}
var Va = ua, ha = Va, Ia = ll, pa = "Expected a function";
function La(Z, l, i) {
  var s = !0, c = !0;
  if (typeof Z != "function")
    throw new TypeError(pa);
  return Ia(i) && (s = "leading" in i ? !!i.leading : s, c = "trailing" in i ? !!i.trailing : c), ha(Z, l, {
    leading: s,
    maxWait: l,
    trailing: c
  });
}
var ya = La;
const Di = /* @__PURE__ */ $l(ya), Ka = {
  delete: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTEyIDZ2NmEyIDIgMCAwIDEtMiAySDZhMiAyIDAgMCAxLTItMlY2aDBtMS0yYTIgMiAwIDAgMSAyLTJoMmEyIDIgMCAwIDEgMiAyaDBNMyA0aDEwIiBzdHJva2U9IiM0NDRFNjAiIGZpbGw9Im5vbmUiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIvPjwvc3ZnPg==",
  duplicate: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgc3Ryb2tlPSIjNDQ0RTYwIiBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiPjxwYXRoIGQ9Ik0xMSAySDZhMSAxIDAgMCAwLTEgMXY4YTEgMSAwIDAgMCAxIDFoNmExIDEgMCAwIDAgMS0xVjRoMGwtMi0yeiIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIi8+PHBhdGggZD0iTTExIDJ2MWExIDEgMCAwIDAgMSAxaDFsLTItMnoiLz48cGF0aCBkPSJNOSAxNEg0YTEgMSAwIDAgMS0xLTFWNWgwIiBzdHJva2UtbGluZWNhcD0icm91bmQiLz48L2c+PC9zdmc+",
  "layer-pressed": "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0ibTE2IDEwLTYgNCA2IDQgNi00em0tNiA4IDYgNCA2LTQiIHN0cm9rZT0iIzMzODFGRiIgZmlsbD0ibm9uZSIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIi8+PC9zdmc+",
  layer: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0ibTE2IDEwLTYgNCA2IDQgNi00em0tNiA4IDYgNCA2LTQiIHN0cm9rZT0iIzQ0NEU2MCIgZmlsbD0ibm9uZSIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIi8+PC9zdmc+",
  rotate: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjUiIGhlaWdodD0iMjQiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgc3Ryb2tlPSIjNDQ0RTYwIiBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCI+PHBhdGggZD0iTTEzIDZhNiA2IDAgMSAxLTMuNzA5IDEuMjgzIi8+PHBhdGggZD0ibTEzIDYgMS40MTQgMi40NUwxMyA2bDIuNDUtMS40MTQiLz48L2c+PC9zdmc+",
  "rotation-button": "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgZmlsbD0iI0ZGRiIgZmlsbC1ydWxlPSJldmVub2RkIj48cGF0aCBvcGFjaXR5PSIuMDEiIGQ9Ik0wIDI0VjBoMjR2MjR6Ii8+PHBhdGggZD0iTTUuNzI0IDUuNzI0QTguODQ3IDguODQ3IDAgMCAxIDEyIDMuMTI1YzIuMjcxIDAgNC41NDMuODY2IDYuMjc2IDIuNmE4Ljg0NiA4Ljg0NiAwIDAgMSAyLjU5OCA2LjE0IDguODQ5IDguODQ5IDAgMCAxLTIuNTU5IDYuMzdsLTEuNS0uOTgzQTcuMTA1IDcuMTA1IDAgMCAwIDE5LjEyNSAxMmE3LjEwMyA3LjEwMyAwIDAgMC0yLjA4Ny01LjAzOEE3LjEwMyA3LjEwMyAwIDAgMCAxMiA0Ljg3NWE3LjEwMyA3LjEwMyAwIDAgMC01LjAzOCAyLjA4NyA3LjEwMSA3LjEwMSAwIDAgMC0yLjA4NiA0LjkyIDcuMTAzIDcuMTAzIDAgMCAwIDEuNzY2IDQuODE1bDEuOTQ1LTEuNTg0IDIuMzk0IDcuMTgyLTcuMjIyLTIuNDA4IDEuNzkxLTEuNzlBOC44NDYgOC44NDYgMCAwIDEgMy4xMjUgMTJjMC0yLjI3MS44NjYtNC41NDMgMi42LTYuMjc2eiIgc3Ryb2tlPSIjRkZGIiBzdHJva2Utd2lkdGg9Ii41IiBmaWxsLXJ1bGU9Im5vbnplcm8iLz48L2c+PC9zdmc+",
  rotation: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIj48cGF0aCBmaWxsPSIjRkZGIiBvcGFjaXR5PSIuMDEiIGQ9Ik0wIDI0VjBoMjR2MjR6Ii8+PHBhdGggZD0iTTUuNzI0IDUuNzI0QTguODQ3IDguODQ3IDAgMCAxIDEyIDMuMTI1YzIuMjcxIDAgNC41NDMuODY2IDYuMjc2IDIuNmE4Ljg0NiA4Ljg0NiAwIDAgMSAyLjU5OCA2LjE0IDguODQ5IDguODQ5IDAgMCAxLTIuNTU5IDYuMzdsLTEuNS0uOTgzQTcuMTA1IDcuMTA1IDAgMCAwIDE5LjEyNSAxMmE3LjEwMyA3LjEwMyAwIDAgMC0yLjA4Ny01LjAzOEE3LjEwMyA3LjEwMyAwIDAgMCAxMiA0Ljg3NWE3LjEwMyA3LjEwMyAwIDAgMC01LjAzOCAyLjA4NyA3LjEwMSA3LjEwMSAwIDAgMC0yLjA4NiA0LjkyIDcuMTAzIDcuMTAzIDAgMCAwIDEuNzY2IDQuODE1bDEuOTQ1LTEuNTg0IDIuMzk0IDcuMTgyLTcuMjIyLTIuNDA4IDEuNzkxLTEuNzlBOC44NDYgOC44NDYgMCAwIDEgMy4xMjUgMTJjMC0yLjI3MS44NjYtNC41NDMgMi42LTYuMjc2eiIgc3Ryb2tlPSIjRkZGIiBzdHJva2Utd2lkdGg9Ii41IiBmaWxsPSIjMDAwIiBmaWxsLXJ1bGU9Im5vbnplcm8iLz48L2c+PC9zdmc+",
  "font-colors-active": "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0ibTQgMTEgNC05IDQgOU02IDdoNCIgc3Ryb2tlPSIjMzM4MUZGIiBmaWxsPSJub25lIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiLz48L3N2Zz4=",
  "font-colors": "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0ibTQgMTEgNC05IDQgOU02IDdoNCIgc3Ryb2tlPSIjNDQ0RTYwIiBmaWxsPSJub25lIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiLz48L3N2Zz4=",
  "to-bottom": "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTEyIDEwdjhtMCAwLTItMm0yIDIgMi0ybS00IDZoMTJtLTYtNGg2bS02LTRoNm0tNi00aDYiIHN0cm9rZT0iIzQ0NEU2MCIgZmlsbD0ibm9uZSIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIi8+PC9zdmc+",
  "to-top": "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTEyIDIydi04bTAgMC0yIDJtMi0yIDIgMm0tNC02aDEybS02IDRoNm0tNiA0aDZtLTYgNGg2IiBzdHJva2U9IiM0NDRFNjAiIGZpbGw9Im5vbmUiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIvPjwvc3ZnPg=="
};
function sl(Z) {
  return Ka[Z];
}
const Ra = () => {
  const { InternalMsgEmitter: Z } = il(qi);
  return Vi.createElement(
    "div",
    { className: "button normal-button", onClick: (l) => {
      l.preventDefault(), l.stopPropagation(), Z && zi.emitMethod(Z, Ii.MainEngine, Gi.DeleteNode, { workIds: ["selector"] });
    }, onTouchEnd: (l) => {
      l.stopPropagation(), Z && zi.emitMethod(Z, Ii.MainEngine, Gi.DeleteNode, { workIds: ["selector"] });
    } },
    Vi.createElement("img", { alt: "icon", src: sl("delete") })
  );
}, xa = () => {
  const { InternalMsgEmitter: Z } = il(qi);
  return Vi.createElement(
    "div",
    { className: "button normal-button", onClick: (l) => {
      l.preventDefault(), l.stopPropagation(), Z && zi.emitMethod(Z, Ii.MainEngine, Gi.CopyNode, { workIds: ["selector"] });
    }, onTouchEnd: (l) => {
      l.stopPropagation(), Z && zi.emitMethod(Z, Ii.MainEngine, Gi.CopyNode, { workIds: ["selector"] });
    } },
    Vi.createElement("img", { alt: "icon", src: sl("duplicate") })
  );
}, jd = (Z) => {
  const { icon: l, onClickHandler: i, onTouchEndHandler: s } = Z;
  return Vi.createElement(
    "div",
    { className: "button normal-button", onClick: i, onTouchEnd: s },
    Vi.createElement("img", { src: sl(l) })
  );
}, ra = () => {
  const { InternalMsgEmitter: Z, floatBarData: l } = il(qi), [i, s] = $i(!1), c = hl(() => i ? Vi.createElement(
    "div",
    { className: "image-layer-menu" },
    Vi.createElement(jd, { icon: "to-top", onClickHandler: (e) => {
      e.preventDefault(), e.stopPropagation(), Z && zi.emitMethod(Z, Ii.MainEngine, Gi.ZIndexNode, { workIds: ["selector"], num: 11 });
    }, onTouchEndHandler: (e) => {
      e.stopPropagation(), Z && zi.emitMethod(Z, Ii.MainEngine, Gi.ZIndexNode, { workIds: ["selector"], num: 11 });
    } }),
    Vi.createElement(jd, { icon: "to-bottom", onClickHandler: (e) => {
      e.preventDefault(), e.stopPropagation(), Z && zi.emitMethod(Z, Ii.MainEngine, Gi.ZIndexNode, { workIds: ["selector"], num: -11 });
    }, onTouchEndHandler: (e) => {
      e.stopPropagation(), Z && zi.emitMethod(Z, Ii.MainEngine, Gi.ZIndexNode, { workIds: ["selector"], num: -11 });
    } })
  ) : null, [Z, i]), W = (e) => {
    e.preventDefault(), e.stopPropagation(), e.nativeEvent.stopImmediatePropagation();
    const a = !i;
    s(!i), Z && zi.emitMethod(Z, Ii.MainEngine, Gi.ZIndexActive, { workId: "selector", isActive: a });
  }, h = (e) => {
    e.stopPropagation(), e.nativeEvent.stopImmediatePropagation();
    const a = !i;
    s(!i), Z && zi.emitMethod(Z, Ii.MainEngine, Gi.ZIndexActive, { workId: "selector", isActive: a });
  };
  return Yl(() => () => {
    i && Z && zi.emitMethod(Z, Ii.MainEngine, Gi.ZIndexActive, { workId: "selector", isActive: !1 });
  }, [Z, i, l == null ? void 0 : l.x, l == null ? void 0 : l.y]), Vi.createElement(
    "div",
    { className: `button normal-button ${i && "active"}`, onClick: W, onTouchEnd: h },
    c,
    Vi.createElement("img", { alt: "icon", src: sl(i ? "layer-pressed" : "layer") })
  );
}, Sa = (Z) => {
  const { color: l, opacity: i, activeColor: s, onClickHandler: c, onTouchEndHandler: W } = Z;
  return Vi.createElement(
    "div",
    { className: `font-color-button ${l === s ? "active" : ""}`, onClick: c, onTouchEnd: W },
    Vi.createElement("div", { className: "circle", style: { backgroundColor: s && Il(l, i) } })
  );
}, Ya = (Z) => {
  const { opacity: l, activeColor: i, setCurOpacity: s } = Z;
  if (!i)
    return null;
  const c = Di((e, a) => {
    e.preventDefault(), e.stopPropagation();
    const G = Math.min(Math.max(l * 100 + a.x, 0.01), 100) / 100;
    l !== G && s(G, pi.Doing);
  }, 100, { leading: !1 }), W = (e) => {
    e.preventDefault(), e.stopPropagation(), s(l, pi.Start);
  }, h = Di((e, a) => {
    e.preventDefault(), e.stopPropagation();
    const G = Math.min(Math.max(l * 100 + a.x, 0.01), 100) / 100;
    s(G, pi.Done);
  }, 100, { leading: !1 });
  return Vi.createElement(
    "div",
    { className: "font-color-opacity" },
    Vi.createElement("div", { className: "range-color", style: {
      background: `linear-gradient(to right, ${Il(i, 0)}, ${Il(i, 1)})`
    } }),
    Vi.createElement(
      "div",
      { className: "range-opacity" },
      Vi.createElement(
        Al,
        { bounds: "parent", axis: "x", onDrag: c, onStart: W, onStop: h },
        Vi.createElement("div", { className: "circle", style: {
          left: `calc(${l * 100}% - 13px)`,
          backgroundColor: Il(i, l)
        } })
      )
    )
  );
}, Ca = () => {
  const { InternalMsgEmitter: Z, floatBarData: l, floatBarColors: i } = il(qi), [s, c] = $i(!1), [W, h] = $i(l == null ? void 0 : l.nodeColor), [e, a] = $i((l == null ? void 0 : l.opacity) || 1);
  Yl(() => {
    l && (h(l.nodeColor), a(l.opacity || 1));
  }, [l]);
  const G = hl(() => Vi.createElement(Ya, { opacity: (l == null ? void 0 : l.opacity) || 1, activeColor: W, setCurOpacity: (V, I) => {
    a(V), Z && zi.emitMethod(Z, Ii.MainEngine, Gi.SetColorNode, { workIds: ["selector"], color: W, opacity: V, workState: I });
  } }), [Z, W, l == null ? void 0 : l.opacity]), y = hl(() => s ? Vi.createElement(
    "div",
    { className: "font-colors-menu", onTouchEnd: (V) => {
      V.stopPropagation(), V.nativeEvent.stopImmediatePropagation();
    }, onClick: (V) => {
      V.preventDefault(), V.stopPropagation(), V.nativeEvent.stopImmediatePropagation();
    } },
    i.map((V, I) => {
      const r = ql(...V);
      return Vi.createElement(Sa, { key: I, color: r, opacity: e, activeColor: W, onTouchEndHandler: (p) => {
        p.stopPropagation(), h(r), Z && zi.emitMethod(Z, Ii.MainEngine, Gi.SetColorNode, { workIds: ["selector"], color: r });
      }, onClickHandler: (p) => {
        p.preventDefault(), p.stopPropagation(), h(r), Z && zi.emitMethod(Z, Ii.MainEngine, Gi.SetColorNode, { workIds: ["selector"], color: r });
      } });
    }),
    G
  ) : null, [s, i, G, e, W, Z]), n = hl(() => W && e ? Vi.createElement("div", { className: "color-bar", style: { backgroundColor: Il(W, e) } }) : null, [W, e]);
  return Vi.createElement(
    "div",
    { className: `button normal-button font-colors-icon ${s && "active"}`, onTouchEnd: (V) => {
      V.stopPropagation(), V.nativeEvent.stopImmediatePropagation(), c(!s);
    }, onClick: (V) => {
      V.preventDefault(), V.stopPropagation(), V.nativeEvent.stopImmediatePropagation(), c(!s);
    } },
    Vi.createElement("img", { alt: "icon", src: sl("font-colors") }),
    n,
    y
  );
}, Ja = Vi.memo(() => {
  const { position: Z } = il(qi);
  return Vi.createElement(
    "div",
    { className: "bezier-pencil-plugin-floatbtns", style: Z && Z.y < 80 ? {
      bottom: "-120px"
    } : void 0 },
    Vi.createElement(Ra, null),
    Vi.createElement(ra, null),
    Vi.createElement(xa, null),
    Vi.createElement(Ca, null)
  );
}, () => !0), Fa = () => {
  const [Z, l] = $i({ width: 0, height: 0 }), { floatBarData: i, InternalMsgEmitter: s, setSize: c } = il(qi);
  Yl(() => {
    i && l({ width: i.w, height: i.h });
  }, [i]);
  const W = (a, G, y) => {
    a.preventDefault(), a.stopPropagation();
    const n = y.offsetWidth, V = y.offsetHeight, I = { width: n, height: V, workState: pi.Start };
    c(I), l(I), s && zi.emitMethod(s, Ii.MainEngine, Gi.ScaleNode, { workIds: ["selector"], size: I, workState: pi.Start });
  }, h = Di((a, G, y) => {
    a.preventDefault(), a.stopPropagation();
    const n = y.offsetWidth, V = y.offsetHeight, I = { width: n, height: V, workState: pi.Doing };
    (I.width !== Z.width || I.height !== Z.height) && (c(I), l(I), s && zi.emitMethod(s, Ii.MainEngine, Gi.ScaleNode, { workIds: ["selector"], size: I, workState: pi.Doing }));
  }, 100, { leading: !1 }), e = (a, G, y) => {
    a.preventDefault(), a.stopPropagation();
    const n = y.offsetWidth, V = y.offsetHeight, I = { width: n, height: V, workState: pi.Done };
    c(I), l(I), s && zi.emitMethod(s, Ii.MainEngine, Gi.ScaleNode, { workIds: ["selector"], size: I, workState: pi.Done });
  };
  return Vi.createElement(
    ws,
    { className: "bezier-pencil-plugin-hightlight-box", boundsByDirection: !0, size: {
      width: Z.width,
      height: Z.height
    }, onResizeStart: W, onResize: h, onResizeStop: e },
    Vi.createElement("div", { className: "point LT nwse-resize", style: { backgroundColor: i == null ? void 0 : i.color } }),
    Vi.createElement("div", { className: "point LC ew-resize", style: { backgroundColor: i == null ? void 0 : i.color } }),
    Vi.createElement("div", { className: "point LB nesw-resize", style: { backgroundColor: i == null ? void 0 : i.color } }),
    Vi.createElement("div", { className: "point TC ns-resize", style: { backgroundColor: i == null ? void 0 : i.color } }),
    Vi.createElement("div", { className: "point RT nesw-resize", style: { backgroundColor: i == null ? void 0 : i.color } }),
    Vi.createElement("div", { className: "point RC ew-resize", style: { backgroundColor: i == null ? void 0 : i.color } }),
    Vi.createElement("div", { className: "point RB nwse-resize", style: { backgroundColor: i == null ? void 0 : i.color } }),
    Vi.createElement("div", { className: "point BC ns-resize", style: { backgroundColor: i == null ? void 0 : i.color } })
  );
}, Ta = Vi.forwardRef((Z, l) => {
  const { floatBarData: i, zIndex: s, InternalMsgEmitter: c, position: W, showFloatBarBtn: h, angle: e, isRotating: a, setShowFloatBarBtn: G, setPosition: y } = il(qi), { className: n } = Z, V = (o) => {
    o.preventDefault(), o.stopPropagation(), c && zi.emitMethod(c, Ii.MainEngine, Gi.TranslateNode, { workIds: ["selector"], position: W, workState: pi.Start });
  }, I = Di((o, u) => {
    o.preventDefault(), o.stopPropagation(), G(!0);
    const d = { x: u.x, y: u.y };
    y(d), c && zi.emitMethod(c, Ii.MainEngine, Gi.TranslateNode, { workIds: ["selector"], position: d, workState: pi.Done });
  }, 100, { leading: !1 }), r = Di((o, u) => {
    o.preventDefault(), o.stopPropagation(), G(!1);
    const d = { x: u.x, y: u.y };
    (u.x !== (W == null ? void 0 : W.x) || u.y !== (W == null ? void 0 : W.y)) && (y(d), c && zi.emitMethod(c, Ii.MainEngine, Gi.TranslateNode, { workIds: ["selector"], position: d, workState: pi.Doing }));
  }, 100, { leading: !1 }), p = hl(() => h && !a ? Vi.createElement(Ja, null) : null, [h, a]);
  return Vi.createElement(
    Al,
    { position: W, onStart: V, onDrag: r, onStop: I, handle: "canvas" },
    Vi.createElement(
      "div",
      { className: `${n}`, style: i ? {
        width: i.w,
        height: i.h,
        zIndex: s,
        pointerEvents: s < 2 ? "none" : "auto"
      } : void 0 },
      p,
      Vi.createElement("canvas", { ref: l, className: "bezier-pencil-plugin-floatCanvas", style: {
        width: "100%",
        height: "100%",
        transform: `rotate(${e}deg)`
      } }),
      !a && Vi.createElement(Fa, null)
    )
  );
}), Na = (Z) => {
  const { className: l } = Z, { floatBarData: i, InternalMsgEmitter: s, angle: c, setAngle: W, setRotateState: h, position: e, setShowRotateBtn: a } = il(qi), [G, y] = $i(!1), [n, V] = $i(new Hi()), [I, r] = $i(new Hi());
  Yl(() => {
    if (i) {
      const d = Math.floor(i.w / 2), b = Math.floor(-i.h / 2);
      r(new Hi(d, b)), V(new Hi());
    }
  }, [i, e]);
  const p = (d, b) => {
    d.preventDefault(), d.stopPropagation(), y(!0);
    const t = Math.round(Hi.GetAngleByPoints(n, I, new Hi(b.x, b.y))) || 0;
    W(t), h(!0), s && zi.emitMethod(s, Ii.MainEngine, Gi.RotateNode, { workIds: ["selector"], angle: t, workState: pi.Start });
  }, o = Di((d, b) => {
    d.preventDefault(), d.stopPropagation(), y(!1);
    const t = Math.round(Hi.GetAngleByPoints(n, I, new Hi(b.x, b.y))) || 0;
    W(t), h(!1), a(!1), s && zi.emitMethod(s, Ii.MainEngine, Gi.RotateNode, { workIds: ["selector"], angle: t, workState: pi.Done });
  }, 100, { leading: !1 }), u = Di((d, b) => {
    d.preventDefault(), d.stopPropagation(), y(!0);
    const t = Math.round(Hi.GetAngleByPoints(n, I, new Hi(b.x, b.y))) || 0;
    W(t), h(!0), s && zi.emitMethod(s, Ii.MainEngine, Gi.RotateNode, { workIds: ["selector"], angle: t, workState: pi.Doing });
  }, 100, { leading: !1 });
  return Vi.createElement(
    Al,
    { handle: ".bezier-pencil-plugin-rotate-mouse-pointer", onStart: p, onDrag: u, onStop: o },
    Vi.createElement(
      "div",
      { className: `${l}`, style: e && i ? {
        left: e.x - 30,
        top: e.y + i.h + 20
      } : void 0 },
      !G && Vi.createElement(
        "div",
        { className: "bezier-pencil-plugin-rotate-btn", style: { backgroundColor: i == null ? void 0 : i.color } },
        Vi.createElement("img", { alt: "icon", src: sl("rotation-button") })
      ),
      Vi.createElement(
        "div",
        { className: `bezier-pencil-plugin-rotate-mouse-pointer ${G ? "active" : ""}` },
        Vi.createElement("img", { alt: "icon", src: sl("rotation") }),
        Vi.createElement(
          "div",
          { className: "angle-icon" },
          c,
          "°"
        )
      )
    )
  );
}, qi = Vi.createContext({
  floatBarColors: [],
  InternalMsgEmitter: void 0,
  floatBarData: void 0,
  zIndex: -1,
  dpr: 1,
  position: void 0,
  angle: 0,
  isRotating: !1,
  showFloatBarBtn: !1,
  setPosition: () => {
  },
  setSize: () => {
  },
  setAngle: () => {
  },
  setRotateState: () => {
  },
  setShowRotateBtn: () => {
  },
  setShowFloatBarBtn: () => {
  }
});
class Si extends Vi.Component {
  constructor(l) {
    super(l), Object.defineProperty(this, "containerRef", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: null
    }), Object.defineProperty(this, "canvasFloatRef", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: null
    }), Object.defineProperty(this, "canvasBgRef", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: null
    }), Object.defineProperty(this, "floatBarRef", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: null
    }), Object.defineProperty(this, "floatBarCanvasRef", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: Vi.createRef()
    }), Object.defineProperty(this, "containerOffset", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: { x: 0, y: 0 }
    }), Object.defineProperty(this, "mousedown", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (i) => {
        i.button === 0 && Si.InternalMsgEmitter.emit([Ii.MainEngine, Gi.OriginalEvent], pi.Start, [i.pageX - this.containerOffset.x, i.pageY - this.containerOffset.y]);
      }
    }), Object.defineProperty(this, "mousemove", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (i) => {
        Si.InternalMsgEmitter.emit([Ii.MainEngine, Gi.OriginalEvent], pi.Doing, [i.pageX - this.containerOffset.x, i.pageY - this.containerOffset.y]);
      }
    }), Object.defineProperty(this, "mouseup", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (i) => {
        i.button === 0 && Si.InternalMsgEmitter.emit([Ii.MainEngine, Gi.OriginalEvent], pi.Done, [i.pageX - this.containerOffset.x, i.pageY - this.containerOffset.y]);
      }
    }), Object.defineProperty(this, "touchstart", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (i) => {
        Si.InternalMsgEmitter.emit([Ii.MainEngine, Gi.OriginalEvent], pi.Start, [i.targetTouches[0].pageX - this.containerOffset.x, i.targetTouches[0].pageY - this.containerOffset.y]);
      }
    }), Object.defineProperty(this, "touchmove", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (i) => {
        Si.InternalMsgEmitter.emit([Ii.MainEngine, Gi.OriginalEvent], pi.Doing, [i.targetTouches[0].pageX - this.containerOffset.x, i.targetTouches[0].pageY - this.containerOffset.y]);
      }
    }), Object.defineProperty(this, "touchend", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (i) => {
        Si.InternalMsgEmitter.emit([Ii.MainEngine, Gi.OriginalEvent], pi.Done, [i.changedTouches[0].pageX - this.containerOffset.x, i.changedTouches[0].pageY - this.containerOffset.y]);
      }
    }), Object.defineProperty(this, "setPosition", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (i) => {
        this.setState({ position: i });
      }
    }), Object.defineProperty(this, "setAngle", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (i) => {
        this.setState({ angle: i });
      }
    }), Object.defineProperty(this, "setRotateState", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (i) => {
        this.setState({ isRotating: i });
      }
    }), Object.defineProperty(this, "setShowRotateBtn", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (i) => {
        this.setState({ showRotateBtn: i });
      }
    }), Object.defineProperty(this, "setShowFloatBarBtn", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (i) => {
        this.setState({ showFloatBarBtn: i });
      }
    }), this.state = {
      showRotateBtn: !1,
      floatBarData: void 0,
      showFloatBar: !1,
      zIndex: -1,
      dpr: 1,
      position: void 0,
      angle: 0,
      isRotating: !1,
      showFloatBarBtn: !1
    };
  }
  showFloatBar(l, i) {
    const s = l && i && { ...this.state.floatBarData, ...i } || void 0;
    this.setState({
      showFloatBar: l,
      floatBarData: s,
      position: i && { x: i.x, y: i.y },
      angle: 0,
      showRotateBtn: l,
      showFloatBarBtn: !0
    }), i && this.floatBarCanvasRef.current && (this.floatBarCanvasRef.current.width = i.w * this.state.dpr, this.floatBarCanvasRef.current.height = i.h * this.state.dpr);
  }
  setSize(l) {
    var i;
    (i = this.floatBarCanvasRef) != null && i.current && (this.floatBarCanvasRef.current.width = l.width * this.state.dpr, this.floatBarCanvasRef.current.height = l.height * this.state.dpr), this.state.floatBarData && this.setState({ floatBarData: { ...this.state.floatBarData, w: l.width, h: l.height } });
  }
  setFloatZIndex(l) {
    this.setState({ zIndex: l });
  }
  componentDidMount() {
    var l;
    Si.instance = this, Si.InternalMsgEmitter.emit(Ii.DisplayState, ml.mounted), Si.InternalMsgEmitter.on([Ii.FloatBar, Gi.ShowFloatBar], this.showFloatBar.bind(this)), (l = Si.InternalMsgEmitter) == null || l.on([Ii.FloatBar, Gi.ZIndexFloatBar], this.setFloatZIndex.bind(this)), this.init();
  }
  componentWillUnmount() {
    var i, s, c;
    Si.InternalMsgEmitter.emit(Ii.DisplayState, ml.unmounted), Si.InternalMsgEmitter.off([Ii.FloatBar, Gi.ShowFloatBar], this.showFloatBar.bind(this)), (i = Si.InternalMsgEmitter) == null || i.off([Ii.FloatBar, Gi.ZIndexFloatBar], this.setFloatZIndex.bind(this));
    const l = (s = Si.instance) == null ? void 0 : s.containerRef;
    if (l) {
      const W = (c = l.parentNode) == null ? void 0 : c.children[0];
      this.removeDisplayerEvent(W);
    }
  }
  getRatioWithContext(l) {
    const i = l.webkitBackingStorePixelRatio || l.mozBackingStorePixelRatio || l.msBackingStorePixelRatio || l.oBackingStorePixelRatio || l.backingStorePixelRatio || 1;
    return Math.max(1, (window.devicePixelRatio || 1) / i);
  }
  init() {
    var c;
    const l = this.containerRef, i = this.canvasFloatRef, s = this.canvasBgRef;
    if (l && i && s) {
      const W = l.offsetWidth, h = l.offsetHeight;
      if (W && h) {
        i.style.width = `${W}px`, i.style.height = `${h}px`, s.style.width = `${W}px`, s.style.height = `${h}px`;
        const e = this.getRatioWithContext(s.getContext("2d"));
        i.width = W * e, i.height = h * e, s.width = W * e, s.height = h * e, Si.InternalMsgEmitter.emit([Ii.MainEngine, Gi.CreateScene], l.offsetWidth, l.offsetHeight, e);
        const a = (c = l.parentNode) == null ? void 0 : c.children[0];
        a && (this.containerOffset = this.getContainerOffset(l, this.containerOffset), this.bindDisplayerEvent(a)), this.setState({ dpr: e });
      }
    }
  }
  getContainerOffset(l, i) {
    var c;
    let s = {
      x: i.x + l.offsetLeft,
      y: i.y + l.offsetTop
    };
    return (c = l.offsetParent) != null && c.nodeName && l.offsetParent.nodeName !== "BODY" && (s = this.getContainerOffset(l.offsetParent, s)), s;
  }
  bindDisplayerEvent(l) {
    l.addEventListener("mousedown", this.mousedown, !1), window.addEventListener("mousemove", this.mousemove, !1), window.addEventListener("mouseup", this.mouseup, !1), window.addEventListener("mouseleave", this.mouseup, !1), l.addEventListener("touchstart", this.touchstart, !1), window.addEventListener("touchmove", this.touchmove, !1), window.addEventListener("touchend", this.touchend, !1);
  }
  removeDisplayerEvent(l) {
    l.removeEventListener("mousedown", this.mousedown), window.removeEventListener("mousemove", this.mousemove), window.removeEventListener("mouseup", this.mouseup), window.removeEventListener("mouseleave", this.mouseup), l.removeEventListener("touchstart", this.touchstart), window.removeEventListener("touchmove", this.touchmove), window.removeEventListener("touchend", this.touchend);
  }
  render() {
    var l, i;
    return Vi.createElement(
      Vi.Fragment,
      null,
      this.props.children,
      Vi.createElement(
        "div",
        { id: "bezier-pencil-plugin", className: Vl.Container, ref: (s) => this.containerRef = s, onMouseDown: (s) => {
          s.preventDefault(), s.stopPropagation();
        }, onTouchStart: (s) => {
          s.stopPropagation();
        } },
        Vi.createElement(
          "div",
          { className: Vl.CanvasBox },
          Vi.createElement("canvas", { id: "bezier-pencil-float-canvas", className: Vl.FloatCanvas, ref: (s) => this.canvasFloatRef = s }),
          Vi.createElement("canvas", { id: "bezier-pencil-bg-canvas", ref: (s) => this.canvasBgRef = s })
        ),
        Vi.createElement(
          qi.Provider,
          { value: {
            InternalMsgEmitter: Si.InternalMsgEmitter,
            floatBarColors: Si.floatBarColors,
            floatBarData: this.state.floatBarData,
            zIndex: this.state.zIndex,
            dpr: this.state.dpr,
            position: this.state.position,
            angle: this.state.angle,
            isRotating: this.state.isRotating,
            showFloatBarBtn: this.state.showFloatBarBtn,
            setPosition: this.setPosition.bind(this),
            setSize: this.setSize.bind(this),
            setAngle: this.setAngle.bind(this),
            setRotateState: this.setRotateState.bind(this),
            setShowRotateBtn: this.setShowRotateBtn.bind(this),
            setShowFloatBarBtn: this.setShowFloatBarBtn.bind(this)
          } },
          this.state.showFloatBar && Vi.createElement(Ta, { className: Vl.FloatBar, ref: this.floatBarCanvasRef }),
          this.state.showFloatBarBtn && this.state.showRotateBtn && ((i = (l = this.state.floatBarData) == null ? void 0 : l.selectIds) == null ? void 0 : i.length) === 1 && Vi.createElement(Na, { className: Vl.RotateBtn })
        )
      )
    );
  }
}
Object.defineProperty(Si, "InternalMsgEmitter", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: new Es()
});
Object.defineProperty(Si, "floatBarColors", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: []
});
class ga {
  setNamespace(l) {
    this.namespace = l, this.storage = Dl(this.plugin.attributes[l]) || {};
  }
  isLocalId(l) {
    return l.split("++++").length === 1;
  }
  getLocalId(l) {
    return l.split("++++")[1];
  }
}
var Ha = "__lodash_hash_undefined__";
function za(Z) {
  return this.__data__.set(Z, Ha), this;
}
var Ma = za;
function ka(Z) {
  return this.__data__.has(Z);
}
var va = ka, Ua = es, Qa = Ma, fa = va;
function Sl(Z) {
  var l = -1, i = Z == null ? 0 : Z.length;
  for (this.__data__ = new Ua(); ++l < i; )
    this.add(Z[l]);
}
Sl.prototype.add = Sl.prototype.push = Qa;
Sl.prototype.has = fa;
var Pa = Sl;
function wa(Z, l) {
  for (var i = -1, s = Z == null ? 0 : Z.length; ++i < s; )
    if (l(Z[i], i, Z))
      return !0;
  return !1;
}
var Ea = wa;
function ja(Z, l) {
  return Z.has(l);
}
var Ba = ja, Oa = Pa, Da = Ea, Aa = Ba, qa = 1, $a = 2;
function _a(Z, l, i, s, c, W) {
  var h = i & qa, e = Z.length, a = l.length;
  if (e != a && !(h && a > e))
    return !1;
  var G = W.get(Z), y = W.get(l);
  if (G && y)
    return G == l && y == Z;
  var n = -1, V = !0, I = i & $a ? new Oa() : void 0;
  for (W.set(Z, l), W.set(l, Z); ++n < e; ) {
    var r = Z[n], p = l[n];
    if (s)
      var o = h ? s(p, r, n, l, Z, W) : s(r, p, n, Z, l, W);
    if (o !== void 0) {
      if (o)
        continue;
      V = !1;
      break;
    }
    if (I) {
      if (!Da(l, function(u, d) {
        if (!Aa(I, d) && (r === u || c(r, u, i, s, W)))
          return I.push(d);
      })) {
        V = !1;
        break;
      }
    } else if (!(r === p || c(r, p, i, s, W))) {
      V = !1;
      break;
    }
  }
  return W.delete(Z), W.delete(l), V;
}
var gs = _a;
function ie(Z) {
  var l = -1, i = Array(Z.size);
  return Z.forEach(function(s, c) {
    i[++l] = [c, s];
  }), i;
}
var le = ie;
function de(Z) {
  var l = -1, i = Array(Z.size);
  return Z.forEach(function(s) {
    i[++l] = s;
  }), i;
}
var se = de, Bd = Fl, Od = Js, te = _l, be = gs, ce = le, Ze = se, me = 1, ne = 2, Xe = "[object Boolean]", oe = "[object Date]", ae = "[object Error]", ee = "[object Map]", We = "[object Number]", Ge = "[object RegExp]", ue = "[object Set]", Ve = "[object String]", he = "[object Symbol]", Ie = "[object ArrayBuffer]", pe = "[object DataView]", Dd = Bd ? Bd.prototype : void 0, Ul = Dd ? Dd.valueOf : void 0;
function Le(Z, l, i, s, c, W, h) {
  switch (i) {
    case pe:
      if (Z.byteLength != l.byteLength || Z.byteOffset != l.byteOffset)
        return !1;
      Z = Z.buffer, l = l.buffer;
    case Ie:
      return !(Z.byteLength != l.byteLength || !W(new Od(Z), new Od(l)));
    case Xe:
    case oe:
    case We:
      return te(+Z, +l);
    case ae:
      return Z.name == l.name && Z.message == l.message;
    case Ge:
    case Ve:
      return Z == l + "";
    case ee:
      var e = ce;
    case ue:
      var a = s & me;
      if (e || (e = Ze), Z.size != l.size && !a)
        return !1;
      var G = h.get(Z);
      if (G)
        return G == l;
      s |= ne, h.set(Z, l);
      var y = be(e(Z), e(l), s, c, W, h);
      return h.delete(Z), y;
    case he:
      if (Ul)
        return Ul.call(Z) == Ul.call(l);
  }
  return !1;
}
var ye = Le, Ad = Ys, Ke = 1, Re = Object.prototype, xe = Re.hasOwnProperty;
function re(Z, l, i, s, c, W) {
  var h = i & Ke, e = Ad(Z), a = e.length, G = Ad(l), y = G.length;
  if (a != y && !h)
    return !1;
  for (var n = a; n--; ) {
    var V = e[n];
    if (!(h ? V in l : xe.call(l, V)))
      return !1;
  }
  var I = W.get(Z), r = W.get(l);
  if (I && r)
    return I == l && r == Z;
  var p = !0;
  W.set(Z, l), W.set(l, Z);
  for (var o = h; ++n < a; ) {
    V = e[n];
    var u = Z[V], d = l[V];
    if (s)
      var b = h ? s(d, u, V, l, Z, W) : s(u, d, V, Z, l, W);
    if (!(b === void 0 ? u === d || c(u, d, i, s, W) : b)) {
      p = !1;
      break;
    }
    o || (o = V == "constructor");
  }
  if (p && !o) {
    var t = Z.constructor, m = l.constructor;
    t != m && "constructor" in Z && "constructor" in l && !(typeof t == "function" && t instanceof t && typeof m == "function" && m instanceof m) && (p = !1);
  }
  return W.delete(Z), W.delete(l), p;
}
var Se = re, Ql = Ws, Ye = gs, Ce = ye, Je = Se, qd = zl, $d = Hl, _d = ld, Fe = Is, Te = 1, is = "[object Arguments]", ls = "[object Array]", yl = "[object Object]", Ne = Object.prototype, ds = Ne.hasOwnProperty;
function ge(Z, l, i, s, c, W) {
  var h = $d(Z), e = $d(l), a = h ? ls : qd(Z), G = e ? ls : qd(l);
  a = a == is ? yl : a, G = G == is ? yl : G;
  var y = a == yl, n = G == yl, V = a == G;
  if (V && _d(Z)) {
    if (!_d(l))
      return !1;
    h = !0, y = !1;
  }
  if (V && !y)
    return W || (W = new Ql()), h || Fe(Z) ? Ye(Z, l, i, s, c, W) : Ce(Z, l, a, i, s, c, W);
  if (!(i & Te)) {
    var I = y && ds.call(Z, "__wrapped__"), r = n && ds.call(l, "__wrapped__");
    if (I || r) {
      var p = I ? Z.value() : Z, o = r ? l.value() : l;
      return W || (W = new Ql()), c(p, o, i, s, W);
    }
  }
  return V ? (W || (W = new Ql()), Je(Z, l, i, s, c, W)) : !1;
}
var He = ge, ze = He, ss = bl;
function Hs(Z, l, i, s, c) {
  return Z === l ? !0 : Z == null || l == null || !ss(Z) && !ss(l) ? Z !== Z && l !== l : ze(Z, l, i, s, Hs, c);
}
var Me = Hs, ke = Me;
function ve(Z, l) {
  return ke(Z, l);
}
var Ue = ve;
const ts = /* @__PURE__ */ $l(Ue);
class Qe extends ga {
  // private syncBatchMap: Map<string, BaseCollectorReducerAction> = new Map();
  constructor(l) {
    super(), Object.defineProperty(this, "storage", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "uid", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "plugin", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "namespace", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ""
    }), Object.defineProperty(this, "stateDisposer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.plugin = l, this.uid = l.displayer.uid;
    const i = l.displayer.state.sceneState.sceneName;
    this.setNamespace(i);
  }
<<<<<<< HEAD
<<<<<<< HEAD
  addStorageStateListener(l) {
    this.stateDisposer = M0(async () => {
      const i = gd(this.plugin.attributes[this.namespace]) || {}, c = this.diffFun(this.storage, i);
      this.storage = i;
      for (const m of Object.keys(c)) {
        const L = c[m];
        L && l(m, L);
      }
=======
  addStorageStateListener(d) {
    this.stateDisposer = Hb(async () => {
      const l = Ed(this.plugin.attributes[this.namespace]) || {}, Z = this.diffFun(this.storage, l);
      this.storage = l, d(Z);
>>>>>>> d63f88a (udpate:finish this feature)
=======
  addStorageStateListener(l) {
    this.stateDisposer = ks(async () => {
      const i = Dl(this.plugin.attributes[this.namespace]) || {}, s = this.diffFun(this.storage, i);
      this.storage = i, l(s);
>>>>>>> 7b53da8 (fix:fix some bug)
    });
  }
  removeStorageStateListener() {
    this.stateDisposer && this.stateDisposer();
  }
  diffFun(l, i) {
    const s = Ml(l), c = Ml(i), W = {};
    for (const h of s) {
      if (c.includes(h)) {
        if (ts(l[h], i[h]))
          continue;
        W[h] = {
          oldValue: l[h],
          newValue: i[h]
        };
        continue;
      }
      W[h] = {
        oldValue: l[h],
        newValue: void 0
      };
    }
    for (const h of c) {
      if (s.includes(h)) {
        if (ts(l[h], i[h]))
          continue;
        continue;
      }
      W[h] = {
        oldValue: void 0,
        newValue: i[h]
      };
    }
    return W;
  }
  transformKey(l) {
    return this.uid + "++++" + l;
  }
  isOwn(l) {
    return l.split("++++")[0] === this.uid;
  }
  dispatch(l) {
    const { type: i, workId: s, ops: c, index: W, opt: h, toolsType: e, removeIds: a, updateNodeOpt: G, op: y, selectIds: n } = l;
    switch (i) {
      case hi.Clear:
        const V = {};
        Object.keys(this.storage).map((u) => {
          V[u] = void 0;
        }), this.setState(V);
        break;
      case hi.CreateWork:
        if (s && e && h) {
          const u = this.isLocalId(s.toString()) ? this.transformKey(s) : s;
          this.updateValue(u.toString(), {
            type: hi.CreateWork,
            workId: s,
            toolsType: e,
            opt: h
          });
        }
        break;
      case hi.UpdateWork:
        if (s && e && h) {
          const u = this.isLocalId(s.toString()) ? this.transformKey(s) : s, d = this.storage[u], b = G || (d == null ? void 0 : d.updateNodeOpt);
          this.updateValue(u.toString(), {
            ...d,
            type: hi.UpdateWork,
            workId: s,
            toolsType: e,
            opt: h,
            updateNodeOpt: b
          });
        }
        break;
      case hi.DrawWork:
        if (s && typeof W == "number" && (y != null && y.length)) {
          const u = this.isLocalId(s.toString()) ? this.transformKey(s) : s, d = this.storage[u], b = ((d == null ? void 0 : d.op) || []).slice(0, W).concat(y);
          d && b && this.updateValue(u.toString(), {
            ...d,
            type: hi.DrawWork,
            op: b,
            index: W
          });
        }
        break;
      case hi.FullWork:
        if (s) {
          const u = this.isLocalId(s.toString()) ? this.transformKey(s) : s, d = this.storage[u], b = G || (d == null ? void 0 : d.updateNodeOpt), t = e || (d == null ? void 0 : d.toolsType), m = h || (d == null ? void 0 : d.opt), R = c || (d == null ? void 0 : d.ops);
          t && m && R && this.updateValue(u.toString(), {
            type: hi.FullWork,
            updateNodeOpt: b,
            workId: u,
            toolsType: t,
            opt: m,
            ops: R
          });
        }
        break;
      case hi.RemoveNode:
        if (a != null && a.length) {
          const u = a.map((d) => this.isLocalId(d + "") ? this.transformKey(d) : d);
          Object.keys(this.storage).map((d) => {
            u != null && u.includes(d) && this.updateValue(d, void 0);
          });
        }
        break;
      case hi.UpdateNode:
        if (s && (G || c || h)) {
          const u = this.isLocalId(s.toString()) ? this.transformKey(s) : s, d = this.storage[u];
          d && (d.type = i, d.updateNodeOpt = G, c && (d.ops = c), G && (d.updateNodeOpt = G), h && (d.opt = h), this.updateValue(u.toString(), d));
        }
        break;
      case hi.Select:
        let I;
        n != null && n.length && (I = n.map((u) => this.isLocalId(u + "") ? this.transformKey(u) : u));
        const r = this.transformKey(Li.selectorId), p = this.storage[r], o = h || (p == null ? void 0 : p.opt);
        this.updateValue(r, I && {
          type: hi.Select,
          toolsType: Yi.Selector,
          opt: o,
          selectIds: I
        });
        break;
    }
  }
  setState(l) {
    const i = Ml(l);
    for (let c = 0; c < i.length; c++) {
      const W = i[c], h = l[W];
      typeof h < "u" ? this.storage[W] = h : delete this.storage[W];
    }
    const s = {};
    s[this.namespace] = this.storage, this.plugin.setAttributes(s);
  }
<<<<<<< HEAD
<<<<<<< HEAD
  updateValue(l, i) {
    const c = Object.keys(this.storage).length;
    this.storage[l] = i, c ? this.plugin.updateAttributes([this.namespace, l], i) : this.setState(this.storage);
=======
  updateValue(d, l) {
    const Z = Object.keys(this.storage).length;
    l === void 0 ? delete this.storage[d] : this.storage[d] = l, Z ? this.plugin.updateAttributes([this.namespace, d], l) : this.setState(this.storage);
>>>>>>> d63f88a (udpate:finish this feature)
=======
  updateValue(l, i) {
    const s = Object.keys(this.storage).length;
    i === void 0 ? delete this.storage[l] : this.storage[l] = i, s ? this.plugin.updateAttributes([this.namespace, l], i) : this.setState(this.storage);
>>>>>>> 7b53da8 (fix:fix some bug)
  }
  transformToSerializableData(l) {
    return cs(l);
  }
  transformToNormalData(l) {
    return bs(l);
  }
  keyTransformWorkId(l) {
    const i = l.split("++++");
    return i.length === 2 ? i[1] : l;
  }
  destroy() {
  }
}
class fe {
  constructor(l, i) {
    Object.defineProperty(this, "plugin", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "pluginOptions", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "collector", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "worker", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "room", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "onCameraChange", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (s) => {
        var c;
        (c = this.worker) == null || c.setCameraOpt(Dl(s));
      }
    }), Object.defineProperty(this, "onSceneChange", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: Di((s) => {
        var c, W, h;
        (c = this.collector) == null || c.setNamespace(s.sceneName), (W = this.worker) == null || W.clearAll(!0), (h = this.worker) == null || h.initSyncData(() => {
        });
      }, 100, { leading: !1 })
    }), Object.defineProperty(this, "onMemberChange", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: Di((s) => {
        var e, a, G, y, n, V, I, r, p, o, u;
        if (!this.room)
          return;
        const c = s.currentApplianceName, W = c === cl.pencil && s.useLaserPen ? Yi.LaserPen : c === cl.eraser || c === cl.pencilEraser ? Yi.Eraser : c === cl.pencil && s.useNewPencil ? Yi.Pencil : c === cl.selector ? Yi.Selector : Yi.Clicker, h = {
          color: ql(s.strokeColor[0], s.strokeColor[1], s.strokeColor[2]),
          opacity: (s == null ? void 0 : s.strokeOpacity) || 1
        };
        if (W === Yi.Pencil ? (h.thickness = s.strokeWidth, h.strokeType = (s == null ? void 0 : s.strokeType) || Oi.Normal) : W === Yi.Eraser ? (h.thickness = Math.min(3, Math.max(1, Math.floor(s.pencilEraserSize || 3))) - 1, h.isLine = c === cl.eraser && !0) : W === Yi.LaserPen && (h.thickness = s.strokeWidth, h.duration = (s == null ? void 0 : s.duration) || 1, h.strokeType = (s == null ? void 0 : s.strokeType) || Oi.Normal), (e = this.worker) == null || e.setCurrentToolsData({
          toolsType: W,
          toolsOpt: h
        }), W === Yi.Selector ? ((a = Si.InternalMsgEmitter) == null || a.on([Ii.MainEngine, Gi.TranslateNode], this.linstenerSelector.bind(this)), (G = Si.InternalMsgEmitter) == null || G.on([Ii.MainEngine, Gi.SetColorNode], this.linstenerSelector.bind(this)), (y = Si.InternalMsgEmitter) == null || y.on([Ii.MainEngine, Gi.ScaleNode], this.linstenerSelector.bind(this)), (n = Si.InternalMsgEmitter) == null || n.on([Ii.MainEngine, Gi.RotateNode], this.linstenerSelector.bind(this))) : ((V = Si.InternalMsgEmitter) == null || V.off([Ii.MainEngine, Gi.TranslateNode], this.linstenerSelector.bind(this)), (I = Si.InternalMsgEmitter) == null || I.off([Ii.MainEngine, Gi.SetColorNode], this.linstenerSelector.bind(this)), (r = Si.InternalMsgEmitter) == null || r.off([Ii.MainEngine, Gi.ScaleNode], this.linstenerSelector.bind(this)), (p = Si.InternalMsgEmitter) == null || p.off([Ii.MainEngine, Gi.RotateNode], this.linstenerSelector.bind(this))), W === Yi.Eraser || W === Yi.Pencil || W === Yi.LaserPen || W === Yi.Selector) {
          W === Yi.Pencil || W === Yi.LaserPen ? (this.room.disableDeviceInputs = !0, setTimeout(() => {
            var b, t;
            const d = (t = (b = Si.instance.containerRef) == null ? void 0 : b.parentNode) == null ? void 0 : t.children[0];
            d && (d.className = d.className + " cursor-pencil");
          }, 0)) : this.room.disableDeviceInputs = !1, (o = this.worker) == null || o.abled();
          return;
        }
        this.room.disableDeviceInputs = !1, (u = this.worker) == null || u.unabled();
      }, 100, { leading: !1 })
    }), this.plugin = l, this.room = fl(l.displayer) ? l.displayer : void 0, this.pluginOptions = i, window.onbeforeunload = () => {
      this.onUnMountDisplayer();
    };
  }
  init() {
    var l, i;
    Si.floatBarColors = ((i = (l = this.room) == null ? void 0 : l.floatBarOptions) == null ? void 0 : i.colors) || [], Si.InternalMsgEmitter.on(Ii.DisplayState, this.displayStateListener.bind(this));
  }
  cleanCurrentScene() {
    var l;
    (l = this.worker) == null || l.clearAll();
  }
  destroy() {
    Si.InternalMsgEmitter.off(Ii.DisplayState, this.displayStateListener.bind(this));
  }
  displayStateListener(l) {
    l === ml.mounted && this.onMountDisplayer(), l === ml.unmounted && this.onUnMountDisplayer();
  }
  linstenerSelector(l) {
    this.room && l.workState === pi.Start ? this.room.disableDeviceInputs = !0 : this.room && l.workState === pi.Done && (this.room.disableDeviceInputs = !1);
  }
  onWritableChange(l) {
    var i, s;
    l ? (s = this.worker) == null || s.abled() : (i = this.worker) == null || i.unabled();
  }
  onMountDisplayer() {
    var c, W, h;
    const l = (c = Si.instance) == null ? void 0 : c.containerRef, i = (W = Si.instance) == null ? void 0 : W.canvasFloatRef, s = (h = Si.instance) == null ? void 0 : h.canvasBgRef;
    i && s && l && (this.collector = new Qe(this.plugin), this.worker = new wi(Si.instance, this.collector, this.pluginOptions, Si.InternalMsgEmitter), this.collector.addStorageStateListener((e) => {
      var a, G, y;
      if (e) {
        if ((a = this.collector) != null && a.storage) {
          const n = Object.keys(this.collector.storage);
          if (n.length === 0) {
            (G = this.worker) == null || G.clearAll(!0);
            return;
          }
          if (this.worker) {
            let V = 0;
            for (const I of n) {
              const r = this.collector.storage[I];
              r && (V = Math.max(V, ((y = r.opt) == null ? void 0 : y.zIndex) || 0));
            }
            this.worker.maxLayerIndex = V;
          }
        }
        if (this.worker) {
          const n = this.worker.getRelevantWork(e);
          Object.keys(e).forEach((V) => {
            var r;
            const I = e[V];
            I && ((r = this.worker) == null || r.onServiceDerive(V, I, n));
          });
        }
      }
    }), setTimeout(() => {
      var e;
      (e = this.worker) == null || e.initSyncData();
    }, 200));
  }
  onUnMountDisplayer() {
    var l, i;
    (l = this.collector) == null || l.destroy(), (i = this.worker) == null || i.destroy(), this.collector = void 0, this.worker = void 0;
  }
}
class Ni extends vs {
  static async getInstance(l, i) {
    i != null && i.logger && (Ni.logger = i.logger), i != null && i.options && (Ni.options = i.options);
    let s = l.getInvisiblePlugin(Ni.kind);
    if (!s)
      if (fl(l) && l.isWritable) {
        if (!l.isWritable)
          return l;
        s = await l.createInvisiblePlugin(Ni, {});
      } else
        return l;
    return s == null || s.init(l), Ni.effectInstance(l), l;
  }
  /**
   * 房间实例化时，将当前实例对displayer外部API的添加内部处理逻辑;
   * @param displayer
   */
  static effectInstance(l) {
    const i = l.cleanCurrentScene;
    return l.cleanCurrentScene = function(s) {
      Ni.currentManager.cleanCurrentScene(), Ni.logger.info("[Projector plugin] cleanCurrentScene"), i.call(l, s);
    }, l;
  }
  constructor(l) {
    super(l), Object.defineProperty(this, "onPhaseChanged", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (s) => {
        s === Us.Disconnected && (this.displayer.callbacks.off(this.callbackName, this.roomStateChangeListener), this.displayer.callbacks.off("onEnableWriteNowChanged", this.updateRoomWritable), this.displayer.callbacks.off("onPhaseChanged", this.onPhaseChanged), Ni.invisiblePlugins.delete(this.displayer), Ni.currentManager.destroy());
      }
    }), Object.defineProperty(this, "updateRoomWritable", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: () => {
        Ni.currentManager.onWritableChange(this.displayer.isWritable);
      }
    }), Object.defineProperty(this, "roomStateChangeListener", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: async (s) => {
        s.cameraState && Ni.currentManager.onCameraChange(s.cameraState), s.memberState && Ni.currentManager.onMemberChange(s.memberState), s.sceneState && Ni.currentManager.onSceneChange(s.sceneState);
      }
    }), Object.defineProperty(this, "createCurrentManager", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: () => {
        Ni.currentManager && Ni.currentManager.destroy();
        const s = new fe(this, Ni.options);
        s.init(), Ni.currentManager = s, Ni.logger.info("[Projector plugin] refresh currentSlideManager object");
      }
    });
    const i = Ni.invisiblePlugins.get(this.displayer);
    i && fs(i, this);
  }
  get isReplay() {
    return Qs(this.displayer);
  }
  get callbackName() {
    return this.isReplay ? "onPlayerStateChanged" : "onRoomStateChanged";
  }
  init(l) {
    const i = Ps(l.getInvisiblePlugin(Ni.kind));
    if (Ni.invisiblePlugins.set(l, i), fl(l)) {
      this.createCurrentManager();
      const s = l.state;
      s != null && s.memberState && Ni.currentManager.onMemberChange(s.memberState);
    }
    this.displayer.callbacks.on(this.callbackName, this.roomStateChangeListener), this.displayer.callbacks.on("onEnableWriteNowChanged", this.updateRoomWritable), this.displayer.callbacks.on("onPhaseChanged", this.onPhaseChanged);
  }
}
Object.defineProperty(Ni, "kind", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "bezier-pencil-plugin"
});
Object.defineProperty(Ni, "invisiblePlugins", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /* @__PURE__ */ new WeakMap()
});
Object.defineProperty(Ni, "logger", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: {
    info: console.log,
    warn: console.warn,
    error: console.error
  }
});
export {
  Si as BezierPencilDisplayer,
  Ni as BezierPencilPlugin,
  ml as DisplayStateEnum,
  Pl as ECanvasContextType,
  Zl as ECanvasShowType,
  Ji as EDataType,
  hi as EPostMessageType,
  ed as EScaleDirection,
  ad as EShapeDataTypeKey,
  od as ESpriteNodeKey,
  Oi as EStrokeType,
  Yi as EToolsKey,
  Gi as EmitEventType,
  pi as EvevtWorkState,
  Ii as InternalMsgEmitterType,
  wi as MainEngineForWorker
};
