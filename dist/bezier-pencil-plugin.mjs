import * as zd from "react";
import ad, { useContext as el, useState as Dd, useMemo as Bd, useEffect as nl, useRef as Nb } from "react";
import gb from "eventemitter2";
import { toJS as kb, autorun as zb, isRoom as ml, ApplianceNames as gd, InvisiblePlugin as hZ, RoomPhase as pZ, isPlayer as yZ } from "white-web-sdk";
import { decompress as IZ, compress as LZ } from "lz-string";
import { debounce as RZ, cloneDeep as xZ, isEqual as YZ } from "lodash";
import "lineclip";
import Ii from "react-dom";
import Li from "react-draggable";
import { Resizable as KZ } from "re-resizable";
import { WindowManager as Xi } from "@netless/window-manager";
var jl;
(function(s) {
  s[s.pedding = 0] = "pedding", s[s.mounted = 1] = "mounted", s[s.update = 2] = "update", s[s.unmounted = 3] = "unmounted";
})(jl || (jl = {}));
var Ol;
(function(s) {
  s[s.Normal = 0] = "Normal", s[s.Stroke = 1] = "Stroke", s[s.Dotted = 2] = "Dotted", s[s.LongDotted = 3] = "LongDotted";
})(Ol || (Ol = {}));
var ll;
(function(s) {
  s.Triangle = "triangle", s.Rhombus = "rhombus", s.Pentagram = "pentagram", s.SpeechBalloon = "speechBalloon", s.Star = "star", s.Polygon = "polygon";
})(ll || (ll = {}));
var pd;
(function(s) {
  s.None = "None", s.ShowFloatBar = "ShowFloatBar", s.ZIndexFloatBar = "ZIndexFloatBar", s.DeleteNode = "DeleteNode", s.CopyNode = "CopyNode", s.ZIndexActive = "ZIndexActive", s.ZIndexNode = "ZIndexNode", s.RotateNode = "RotateNode", s.SetColorNode = "SetColorNode", s.TranslateNode = "TranslateNode", s.ScaleNode = "ScaleNode", s.OriginalEvent = "OriginalEvent", s.CreateScene = "CreateScene", s.ActiveCursor = "ActiveCursor", s.MoveCursor = "MoveCursor", s.CommandEditor = "CommandEditor", s.SetEditorData = "SetEditorData";
})(pd || (pd = {}));
var rd;
(function(s) {
  s.DisplayState = "DisplayState", s.FloatBar = "FloatBar", s.CanvasSelector = "CanvasSelector", s.MainEngine = "MainEngine", s.DisplayContainer = "DisplayContainer", s.Cursor = "Cursor", s.TextEditor = "TextEditor", s.BindMainView = "BindMainView", s.MountMainView = "MountMainView", s.MountAppView = "MountAppView";
})(rd || (rd = {}));
var vi;
(function(s) {
  s[s.MainView = 0] = "MainView", s[s.Plugin = 1] = "Plugin", s[s.Both = 2] = "Both";
})(vi || (vi = {}));
const pl = "++", Ld = "selector", SZ = "all";
class Mb {
  constructor(l) {
    Object.defineProperty(this, "plugin", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "uid", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.plugin = l, this.uid = l.displayer.uid;
  }
  getNamespaceData() {
    var l;
    return kb((l = this.plugin) == null ? void 0 : l.attributes[this.namespace]) || {};
  }
  getUidFromKey(l) {
    return l.split(pl).length === 2 && l.split(pl)[0] || this.uid;
  }
  isLocalId(l) {
    return l.split(pl).length === 1;
  }
  getLocalId(l) {
    return l.split(pl)[1];
  }
  isSelector(l) {
    return this.getLocalId(l) === Ld;
  }
}
var Gd;
(function(s) {
  s[s.Pencil = 1] = "Pencil", s[s.Eraser = 2] = "Eraser", s[s.Selector = 3] = "Selector", s[s.Clicker = 4] = "Clicker", s[s.Arrow = 5] = "Arrow", s[s.Hand = 6] = "Hand", s[s.LaserPen = 7] = "LaserPen", s[s.Text = 8] = "Text", s[s.Straight = 9] = "Straight", s[s.Rectangle = 10] = "Rectangle", s[s.Ellipse = 11] = "Ellipse", s[s.Star = 12] = "Star", s[s.Triangle = 13] = "Triangle", s[s.Rhombus = 14] = "Rhombus", s[s.Polygon = 15] = "Polygon", s[s.SpeechBalloon = 16] = "SpeechBalloon";
})(Gd || (Gd = {}));
var Fd;
(function(s) {
  s[s.Local = 1] = "Local", s[s.Service = 2] = "Service", s[s.Worker = 3] = "Worker";
})(Fd || (Fd = {}));
var ud;
(function(s) {
  s[s.Pending = 0] = "Pending", s[s.Start = 1] = "Start", s[s.Doing = 2] = "Doing", s[s.Done = 3] = "Done", s[s.Freeze = 4] = "Freeze", s[s.Unwritable = 5] = "Unwritable";
})(ud || (ud = {}));
var yd;
(function(s) {
  s[s.Init = 0] = "Init", s[s.UpdateCamera = 1] = "UpdateCamera", s[s.UpdateTools = 2] = "UpdateTools", s[s.CreateWork = 3] = "CreateWork", s[s.DrawWork = 4] = "DrawWork", s[s.FullWork = 5] = "FullWork", s[s.UpdateNode = 6] = "UpdateNode", s[s.RemoveNode = 7] = "RemoveNode", s[s.Clear = 8] = "Clear", s[s.Select = 9] = "Select", s[s.Destroy = 10] = "Destroy", s[s.None = 11] = "None", s[s.Snapshot = 12] = "Snapshot", s[s.BoundingBox = 13] = "BoundingBox", s[s.Cursor = 14] = "Cursor", s[s.TextUpdate = 15] = "TextUpdate", s[s.GetTextActive = 16] = "GetTextActive", s[s.TasksQueue = 17] = "TasksQueue";
})(yd || (yd = {}));
var Gi;
(function(s) {
  s.Webgl2 = "webgl2", s.Webgl = "webgl", s.Canvas2d = "2d";
})(Gi || (Gi = {}));
var Xl;
(function(s) {
  s[s.Float = 1] = "Float", s[s.Bg = 2] = "Bg", s[s.Selector = 3] = "Selector", s[s.None = 4] = "None";
})(Xl || (Xl = {}));
var Yl;
(function(s) {
  s[s.Cursor = 1] = "Cursor", s[s.TextCreate = 2] = "TextCreate";
})(Yl || (Yl = {}));
var Rl;
(function(s) {
  s[s.Top = 1] = "Top", s[s.Bottom = 2] = "Bottom";
})(Rl || (Rl = {}));
var Dl;
(function(s) {
  s[s.none = 1] = "none", s[s.all = 2] = "all", s[s.both = 3] = "both";
})(Dl || (Dl = {}));
function rZ(s) {
  return JSON.parse(IZ(s));
}
function JZ(s) {
  return LZ(JSON.stringify(s));
}
const $d = Object.keys;
var fl = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Pl(s) {
  return s && s.__esModule && Object.prototype.hasOwnProperty.call(s, "default") ? s.default : s;
}
function CZ() {
  this.__data__ = [], this.size = 0;
}
var FZ = CZ;
function HZ(s, l) {
  return s === l || s !== s && l !== l;
}
var Ri = HZ, TZ = Ri;
function NZ(s, l) {
  for (var d = s.length; d--; )
    if (TZ(s[d][0], l))
      return d;
  return -1;
}
var di = NZ, gZ = di, kZ = Array.prototype, zZ = kZ.splice;
function MZ(s) {
  var l = this.__data__, d = gZ(l, s);
  if (d < 0)
    return !1;
  var i = l.length - 1;
  return d == i ? l.pop() : zZ.call(l, d, 1), --this.size, !0;
}
var UZ = MZ, QZ = di;
function vZ(s) {
  var l = this.__data__, d = QZ(l, s);
  return d < 0 ? void 0 : l[d][1];
}
var PZ = vZ, wZ = di;
function fZ(s) {
  return wZ(this.__data__, s) > -1;
}
var EZ = fZ, BZ = di;
function jZ(s, l) {
  var d = this.__data__, i = BZ(d, s);
  return i < 0 ? (++this.size, d.push([s, l])) : d[i][1] = l, this;
}
var OZ = jZ, DZ = FZ, AZ = UZ, qZ = PZ, $Z = EZ, _Z = OZ;
function Hl(s) {
  var l = -1, d = s == null ? 0 : s.length;
  for (this.clear(); ++l < d; ) {
    var i = s[l];
    this.set(i[0], i[1]);
  }
}
Hl.prototype.clear = DZ;
Hl.prototype.delete = AZ;
Hl.prototype.get = qZ;
Hl.prototype.has = $Z;
Hl.prototype.set = _Z;
var li = Hl, dc = li;
function lc() {
  this.__data__ = new dc(), this.size = 0;
}
var ic = lc;
function bc(s) {
  var l = this.__data__, d = l.delete(s);
  return this.size = l.size, d;
}
var Zc = bc;
function cc(s) {
  return this.__data__.get(s);
}
var sc = cc;
function mc(s) {
  return this.__data__.has(s);
}
var tc = mc, Xc = typeof fl == "object" && fl && fl.Object === Object && fl, Ub = Xc, nc = Ub, Wc = typeof self == "object" && self && self.Object === Object && self, oc = nc || Wc || Function("return this")(), sl = oc, ac = sl, ec = ac.Symbol, ii = ec, Pi = ii, Qb = Object.prototype, Gc = Qb.hasOwnProperty, uc = Qb.toString, Ql = Pi ? Pi.toStringTag : void 0;
function Vc(s) {
  var l = Gc.call(s, Ql), d = s[Ql];
  try {
    s[Ql] = void 0;
    var i = !0;
  } catch {
  }
  var b = uc.call(s);
  return i && (l ? s[Ql] = d : delete s[Ql]), b;
}
var hc = Vc, pc = Object.prototype, yc = pc.toString;
function Ic(s) {
  return yc.call(s);
}
var Lc = Ic, wi = ii, Rc = hc, xc = Lc, Yc = "[object Null]", Kc = "[object Undefined]", fi = wi ? wi.toStringTag : void 0;
function Sc(s) {
  return s == null ? s === void 0 ? Kc : Yc : fi && fi in Object(s) ? Rc(s) : xc(s);
}
var Tl = Sc;
function rc(s) {
  var l = typeof s;
  return s != null && (l == "object" || l == "function");
}
var yl = rc, Jc = Tl, Cc = yl, Fc = "[object AsyncFunction]", Hc = "[object Function]", Tc = "[object GeneratorFunction]", Nc = "[object Proxy]";
function gc(s) {
  if (!Cc(s))
    return !1;
  var l = Jc(s);
  return l == Hc || l == Tc || l == Fc || l == Nc;
}
var vb = gc, kc = sl, zc = kc["__core-js_shared__"], Mc = zc, ni = Mc, Ei = function() {
  var s = /[^.]+$/.exec(ni && ni.keys && ni.keys.IE_PROTO || "");
  return s ? "Symbol(src)_1." + s : "";
}();
function Uc(s) {
  return !!Ei && Ei in s;
}
var Qc = Uc, vc = Function.prototype, Pc = vc.toString;
function wc(s) {
  if (s != null) {
    try {
      return Pc.call(s);
    } catch {
    }
    try {
      return s + "";
    } catch {
    }
  }
  return "";
}
var Pb = wc, fc = vb, Ec = Qc, Bc = yl, jc = Pb, Oc = /[\\^$.*+?()[\]{}|]/g, Dc = /^\[object .+?Constructor\]$/, Ac = Function.prototype, qc = Object.prototype, $c = Ac.toString, _c = qc.hasOwnProperty, ds = RegExp(
  "^" + $c.call(_c).replace(Oc, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function ls(s) {
  if (!Bc(s) || Ec(s))
    return !1;
  var l = fc(s) ? ds : Dc;
  return l.test(jc(s));
}
var is = ls;
function bs(s, l) {
  return s == null ? void 0 : s[l];
}
var Zs = bs, cs = is, ss = Zs;
function ms(s, l) {
  var d = ss(s, l);
  return cs(d) ? d : void 0;
}
var Jl = ms, ts = Jl, Xs = sl, ns = ts(Xs, "Map"), xi = ns, Ws = Jl, os = Ws(Object, "create"), bi = os, Bi = bi;
function as() {
  this.__data__ = Bi ? Bi(null) : {}, this.size = 0;
}
var es = as;
function Gs(s) {
  var l = this.has(s) && delete this.__data__[s];
  return this.size -= l ? 1 : 0, l;
}
var us = Gs, Vs = bi, hs = "__lodash_hash_undefined__", ps = Object.prototype, ys = ps.hasOwnProperty;
function Is(s) {
  var l = this.__data__;
  if (Vs) {
    var d = l[s];
    return d === hs ? void 0 : d;
  }
  return ys.call(l, s) ? l[s] : void 0;
}
var Ls = Is, Rs = bi, xs = Object.prototype, Ys = xs.hasOwnProperty;
function Ks(s) {
  var l = this.__data__;
  return Rs ? l[s] !== void 0 : Ys.call(l, s);
}
var Ss = Ks, rs = bi, Js = "__lodash_hash_undefined__";
function Cs(s, l) {
  var d = this.__data__;
  return this.size += this.has(s) ? 0 : 1, d[s] = rs && l === void 0 ? Js : l, this;
}
var Fs = Cs, Hs = es, Ts = us, Ns = Ls, gs = Ss, ks = Fs;
function Nl(s) {
  var l = -1, d = s == null ? 0 : s.length;
  for (this.clear(); ++l < d; ) {
    var i = s[l];
    this.set(i[0], i[1]);
  }
}
Nl.prototype.clear = Hs;
Nl.prototype.delete = Ts;
Nl.prototype.get = Ns;
Nl.prototype.has = gs;
Nl.prototype.set = ks;
var zs = Nl, ji = zs, Ms = li, Us = xi;
function Qs() {
  this.size = 0, this.__data__ = {
    hash: new ji(),
    map: new (Us || Ms)(),
    string: new ji()
  };
}
var vs = Qs;
function Ps(s) {
  var l = typeof s;
  return l == "string" || l == "number" || l == "symbol" || l == "boolean" ? s !== "__proto__" : s === null;
}
var ws = Ps, fs = ws;
function Es(s, l) {
  var d = s.__data__;
  return fs(l) ? d[typeof l == "string" ? "string" : "hash"] : d.map;
}
var Zi = Es, Bs = Zi;
function js(s) {
  var l = Bs(this, s).delete(s);
  return this.size -= l ? 1 : 0, l;
}
var Os = js, Ds = Zi;
function As(s) {
  return Ds(this, s).get(s);
}
var qs = As, $s = Zi;
function _s(s) {
  return $s(this, s).has(s);
}
var d0 = _s, l0 = Zi;
function i0(s, l) {
  var d = l0(this, s), i = d.size;
  return d.set(s, l), this.size += d.size == i ? 0 : 1, this;
}
var b0 = i0, Z0 = vs, c0 = Os, s0 = qs, m0 = d0, t0 = b0;
function gl(s) {
  var l = -1, d = s == null ? 0 : s.length;
  for (this.clear(); ++l < d; ) {
    var i = s[l];
    this.set(i[0], i[1]);
  }
}
gl.prototype.clear = Z0;
gl.prototype.delete = c0;
gl.prototype.get = s0;
gl.prototype.has = m0;
gl.prototype.set = t0;
var wb = gl, X0 = li, n0 = xi, W0 = wb, o0 = 200;
function a0(s, l) {
  var d = this.__data__;
  if (d instanceof X0) {
    var i = d.__data__;
    if (!n0 || i.length < o0 - 1)
      return i.push([s, l]), this.size = ++d.size, this;
    d = this.__data__ = new W0(i);
  }
  return d.set(s, l), this.size = d.size, this;
}
var e0 = a0, G0 = li, u0 = ic, V0 = Zc, h0 = sc, p0 = tc, y0 = e0;
function kl(s) {
  var l = this.__data__ = new G0(s);
  this.size = l.size;
}
kl.prototype.clear = u0;
kl.prototype.delete = V0;
kl.prototype.get = h0;
kl.prototype.has = p0;
kl.prototype.set = y0;
var fb = kl, I0 = "__lodash_hash_undefined__";
function L0(s) {
  return this.__data__.set(s, I0), this;
}
var R0 = L0;
function x0(s) {
  return this.__data__.has(s);
}
var Y0 = x0, K0 = wb, S0 = R0, r0 = Y0;
function Al(s) {
  var l = -1, d = s == null ? 0 : s.length;
  for (this.__data__ = new K0(); ++l < d; )
    this.add(s[l]);
}
Al.prototype.add = Al.prototype.push = S0;
Al.prototype.has = r0;
var J0 = Al;
function C0(s, l) {
  for (var d = -1, i = s == null ? 0 : s.length; ++d < i; )
    if (l(s[d], d, s))
      return !0;
  return !1;
}
var F0 = C0;
function H0(s, l) {
  return s.has(l);
}
var T0 = H0, N0 = J0, g0 = F0, k0 = T0, z0 = 1, M0 = 2;
function U0(s, l, d, i, b, m) {
  var o = d & z0, n = s.length, W = l.length;
  if (n != W && !(o && W > n))
    return !1;
  var e = m.get(s), I = m.get(l);
  if (e && I)
    return e == l && I == s;
  var a = -1, V = !0, h = d & M0 ? new N0() : void 0;
  for (m.set(s, l), m.set(l, s); ++a < n; ) {
    var Y = s[a], p = l[a];
    if (i)
      var G = o ? i(p, Y, a, l, s, m) : i(Y, p, a, s, l, m);
    if (G !== void 0) {
      if (G)
        continue;
      V = !1;
      break;
    }
    if (h) {
      if (!g0(l, function(y, Z) {
        if (!k0(h, Z) && (Y === y || b(Y, y, d, i, m)))
          return h.push(Z);
      })) {
        V = !1;
        break;
      }
    } else if (!(Y === p || b(Y, p, d, i, m))) {
      V = !1;
      break;
    }
  }
  return m.delete(s), m.delete(l), V;
}
var Eb = U0, Q0 = sl, v0 = Q0.Uint8Array, Bb = v0;
function P0(s) {
  var l = -1, d = Array(s.size);
  return s.forEach(function(i, b) {
    d[++l] = [b, i];
  }), d;
}
var w0 = P0;
function f0(s) {
  var l = -1, d = Array(s.size);
  return s.forEach(function(i) {
    d[++l] = i;
  }), d;
}
var E0 = f0, Oi = ii, Di = Bb, B0 = Ri, j0 = Eb, O0 = w0, D0 = E0, A0 = 1, q0 = 2, $0 = "[object Boolean]", _0 = "[object Date]", dm = "[object Error]", lm = "[object Map]", im = "[object Number]", bm = "[object RegExp]", Zm = "[object Set]", cm = "[object String]", sm = "[object Symbol]", mm = "[object ArrayBuffer]", tm = "[object DataView]", Ai = Oi ? Oi.prototype : void 0, Wi = Ai ? Ai.valueOf : void 0;
function Xm(s, l, d, i, b, m, o) {
  switch (d) {
    case tm:
      if (s.byteLength != l.byteLength || s.byteOffset != l.byteOffset)
        return !1;
      s = s.buffer, l = l.buffer;
    case mm:
      return !(s.byteLength != l.byteLength || !m(new Di(s), new Di(l)));
    case $0:
    case _0:
    case im:
      return B0(+s, +l);
    case dm:
      return s.name == l.name && s.message == l.message;
    case bm:
    case cm:
      return s == l + "";
    case lm:
      var n = O0;
    case Zm:
      var W = i & A0;
      if (n || (n = D0), s.size != l.size && !W)
        return !1;
      var e = o.get(s);
      if (e)
        return e == l;
      i |= q0, o.set(s, l);
      var I = j0(n(s), n(l), i, b, m, o);
      return o.delete(s), I;
    case sm:
      if (Wi)
        return Wi.call(s) == Wi.call(l);
  }
  return !1;
}
var nm = Xm;
function Wm(s, l) {
  for (var d = -1, i = l.length, b = s.length; ++d < i; )
    s[b + d] = l[d];
  return s;
}
var jb = Wm, om = Array.isArray, ci = om, am = jb, em = ci;
function Gm(s, l, d) {
  var i = l(s);
  return em(s) ? i : am(i, d(s));
}
var Ob = Gm;
function um(s, l) {
  for (var d = -1, i = s == null ? 0 : s.length, b = 0, m = []; ++d < i; ) {
    var o = s[d];
    l(o, d, s) && (m[b++] = o);
  }
  return m;
}
var Vm = um;
function hm() {
  return [];
}
var Db = hm, pm = Vm, ym = Db, Im = Object.prototype, Lm = Im.propertyIsEnumerable, qi = Object.getOwnPropertySymbols, Rm = qi ? function(s) {
  return s == null ? [] : (s = Object(s), pm(qi(s), function(l) {
    return Lm.call(s, l);
  }));
} : ym, Yi = Rm;
function xm(s, l) {
  for (var d = -1, i = Array(s); ++d < s; )
    i[d] = l(d);
  return i;
}
var Ym = xm;
function Km(s) {
  return s != null && typeof s == "object";
}
var Il = Km, Sm = Tl, rm = Il, Jm = "[object Arguments]";
function Cm(s) {
  return rm(s) && Sm(s) == Jm;
}
var Fm = Cm, $i = Fm, Hm = Il, Ab = Object.prototype, Tm = Ab.hasOwnProperty, Nm = Ab.propertyIsEnumerable, gm = $i(/* @__PURE__ */ function() {
  return arguments;
}()) ? $i : function(s) {
  return Hm(s) && Tm.call(s, "callee") && !Nm.call(s, "callee");
}, km = gm, ql = { exports: {} };
function zm() {
  return !1;
}
var Mm = zm;
ql.exports;
(function(s, l) {
  var d = sl, i = Mm, b = l && !l.nodeType && l, m = b && !0 && s && !s.nodeType && s, o = m && m.exports === b, n = o ? d.Buffer : void 0, W = n ? n.isBuffer : void 0, e = W || i;
  s.exports = e;
})(ql, ql.exports);
var Ki = ql.exports, Um = 9007199254740991, Qm = /^(?:0|[1-9]\d*)$/;
function vm(s, l) {
  var d = typeof s;
  return l = l ?? Um, !!l && (d == "number" || d != "symbol" && Qm.test(s)) && s > -1 && s % 1 == 0 && s < l;
}
var Pm = vm, wm = 9007199254740991;
function fm(s) {
  return typeof s == "number" && s > -1 && s % 1 == 0 && s <= wm;
}
var qb = fm, Em = Tl, Bm = qb, jm = Il, Om = "[object Arguments]", Dm = "[object Array]", Am = "[object Boolean]", qm = "[object Date]", $m = "[object Error]", _m = "[object Function]", dt = "[object Map]", lt = "[object Number]", it = "[object Object]", bt = "[object RegExp]", Zt = "[object Set]", ct = "[object String]", st = "[object WeakMap]", mt = "[object ArrayBuffer]", tt = "[object DataView]", Xt = "[object Float32Array]", nt = "[object Float64Array]", Wt = "[object Int8Array]", ot = "[object Int16Array]", at = "[object Int32Array]", et = "[object Uint8Array]", Gt = "[object Uint8ClampedArray]", ut = "[object Uint16Array]", Vt = "[object Uint32Array]", Nd = {};
Nd[Xt] = Nd[nt] = Nd[Wt] = Nd[ot] = Nd[at] = Nd[et] = Nd[Gt] = Nd[ut] = Nd[Vt] = !0;
Nd[Om] = Nd[Dm] = Nd[mt] = Nd[Am] = Nd[tt] = Nd[qm] = Nd[$m] = Nd[_m] = Nd[dt] = Nd[lt] = Nd[it] = Nd[bt] = Nd[Zt] = Nd[ct] = Nd[st] = !1;
function ht(s) {
  return jm(s) && Bm(s.length) && !!Nd[Em(s)];
}
var pt = ht;
function yt(s) {
  return function(l) {
    return s(l);
  };
}
var Si = yt, $l = { exports: {} };
$l.exports;
(function(s, l) {
  var d = Ub, i = l && !l.nodeType && l, b = i && !0 && s && !s.nodeType && s, m = b && b.exports === i, o = m && d.process, n = function() {
    try {
      var W = b && b.require && b.require("util").types;
      return W || o && o.binding && o.binding("util");
    } catch {
    }
  }();
  s.exports = n;
})($l, $l.exports);
var ri = $l.exports, It = pt, Lt = Si, _i = ri, db = _i && _i.isTypedArray, Rt = db ? Lt(db) : It, $b = Rt, xt = Ym, Yt = km, Kt = ci, St = Ki, rt = Pm, Jt = $b, Ct = Object.prototype, Ft = Ct.hasOwnProperty;
function Ht(s, l) {
  var d = Kt(s), i = !d && Yt(s), b = !d && !i && St(s), m = !d && !i && !b && Jt(s), o = d || i || b || m, n = o ? xt(s.length, String) : [], W = n.length;
  for (var e in s)
    (l || Ft.call(s, e)) && !(o && // Safari 9 has enumerable `arguments.length` in strict mode.
    (e == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    b && (e == "offset" || e == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    m && (e == "buffer" || e == "byteLength" || e == "byteOffset") || // Skip index properties.
    rt(e, W))) && n.push(e);
  return n;
}
var _b = Ht, Tt = Object.prototype;
function Nt(s) {
  var l = s && s.constructor, d = typeof l == "function" && l.prototype || Tt;
  return s === d;
}
var Ji = Nt;
function gt(s, l) {
  return function(d) {
    return s(l(d));
  };
}
var dZ = gt, kt = dZ, zt = kt(Object.keys, Object), Mt = zt, Ut = Ji, Qt = Mt, vt = Object.prototype, Pt = vt.hasOwnProperty;
function wt(s) {
  if (!Ut(s))
    return Qt(s);
  var l = [];
  for (var d in Object(s))
    Pt.call(s, d) && d != "constructor" && l.push(d);
  return l;
}
var ft = wt, Et = vb, Bt = qb;
function jt(s) {
  return s != null && Bt(s.length) && !Et(s);
}
var lZ = jt, Ot = _b, Dt = ft, At = lZ;
function qt(s) {
  return At(s) ? Ot(s) : Dt(s);
}
var Ci = qt, $t = Ob, _t = Yi, dX = Ci;
function lX(s) {
  return $t(s, dX, _t);
}
var iZ = lX, lb = iZ, iX = 1, bX = Object.prototype, ZX = bX.hasOwnProperty;
function cX(s, l, d, i, b, m) {
  var o = d & iX, n = lb(s), W = n.length, e = lb(l), I = e.length;
  if (W != I && !o)
    return !1;
  for (var a = W; a--; ) {
    var V = n[a];
    if (!(o ? V in l : ZX.call(l, V)))
      return !1;
  }
  var h = m.get(s), Y = m.get(l);
  if (h && Y)
    return h == l && Y == s;
  var p = !0;
  m.set(s, l), m.set(l, s);
  for (var G = o; ++a < W; ) {
    V = n[a];
    var y = s[V], Z = l[V];
    if (i)
      var X = o ? i(Z, y, V, l, s, m) : i(y, Z, V, s, l, m);
    if (!(X === void 0 ? y === Z || b(y, Z, d, i, m) : X)) {
      p = !1;
      break;
    }
    G || (G = V == "constructor");
  }
  if (p && !G) {
    var c = s.constructor, t = l.constructor;
    c != t && "constructor" in s && "constructor" in l && !(typeof c == "function" && c instanceof c && typeof t == "function" && t instanceof t) && (p = !1);
  }
  return m.delete(s), m.delete(l), p;
}
var sX = cX, mX = Jl, tX = sl, XX = mX(tX, "DataView"), nX = XX, WX = Jl, oX = sl, aX = WX(oX, "Promise"), eX = aX, GX = Jl, uX = sl, VX = GX(uX, "Set"), hX = VX, pX = Jl, yX = sl, IX = pX(yX, "WeakMap"), LX = IX, ui = nX, Vi = xi, hi = eX, pi = hX, yi = LX, bZ = Tl, zl = Pb, ib = "[object Map]", RX = "[object Object]", bb = "[object Promise]", Zb = "[object Set]", cb = "[object WeakMap]", sb = "[object DataView]", xX = zl(ui), YX = zl(Vi), KX = zl(hi), SX = zl(pi), rX = zl(yi), Ll = bZ;
(ui && Ll(new ui(new ArrayBuffer(1))) != sb || Vi && Ll(new Vi()) != ib || hi && Ll(hi.resolve()) != bb || pi && Ll(new pi()) != Zb || yi && Ll(new yi()) != cb) && (Ll = function(s) {
  var l = bZ(s), d = l == RX ? s.constructor : void 0, i = d ? zl(d) : "";
  if (i)
    switch (i) {
      case xX:
        return sb;
      case YX:
        return ib;
      case KX:
        return bb;
      case SX:
        return Zb;
      case rX:
        return cb;
    }
  return l;
});
var si = Ll, oi = fb, JX = Eb, CX = nm, FX = sX, mb = si, tb = ci, Xb = Ki, HX = $b, TX = 1, nb = "[object Arguments]", Wb = "[object Array]", El = "[object Object]", NX = Object.prototype, ob = NX.hasOwnProperty;
function gX(s, l, d, i, b, m) {
  var o = tb(s), n = tb(l), W = o ? Wb : mb(s), e = n ? Wb : mb(l);
  W = W == nb ? El : W, e = e == nb ? El : e;
  var I = W == El, a = e == El, V = W == e;
  if (V && Xb(s)) {
    if (!Xb(l))
      return !1;
    o = !0, I = !1;
  }
  if (V && !I)
    return m || (m = new oi()), o || HX(s) ? JX(s, l, d, i, b, m) : CX(s, l, W, d, i, b, m);
  if (!(d & TX)) {
    var h = I && ob.call(s, "__wrapped__"), Y = a && ob.call(l, "__wrapped__");
    if (h || Y) {
      var p = h ? s.value() : s, G = Y ? l.value() : l;
      return m || (m = new oi()), b(p, G, d, i, m);
    }
  }
  return V ? (m || (m = new oi()), FX(s, l, d, i, b, m)) : !1;
}
var kX = gX, zX = kX, ab = Il;
function ZZ(s, l, d, i, b) {
  return s === l ? !0 : s == null || l == null || !ab(s) && !ab(l) ? s !== s && l !== l : zX(s, l, d, i, ZZ, b);
}
var MX = ZZ, UX = MX;
function QX(s, l) {
  return UX(s, l);
}
var vX = QX;
const _d = /* @__PURE__ */ Pl(vX);
function PX(s, l) {
  for (var d = -1, i = s == null ? 0 : s.length; ++d < i && l(s[d], d, s) !== !1; )
    ;
  return s;
}
var wX = PX, fX = Jl, EX = function() {
  try {
    var s = fX(Object, "defineProperty");
    return s({}, "", {}), s;
  } catch {
  }
}(), BX = EX, eb = BX;
function jX(s, l, d) {
  l == "__proto__" && eb ? eb(s, l, {
    configurable: !0,
    enumerable: !0,
    value: d,
    writable: !0
  }) : s[l] = d;
}
var cZ = jX, OX = cZ, DX = Ri, AX = Object.prototype, qX = AX.hasOwnProperty;
function $X(s, l, d) {
  var i = s[l];
  (!(qX.call(s, l) && DX(i, d)) || d === void 0 && !(l in s)) && OX(s, l, d);
}
var sZ = $X, _X = sZ, dn = cZ;
function ln(s, l, d, i) {
  var b = !d;
  d || (d = {});
  for (var m = -1, o = l.length; ++m < o; ) {
    var n = l[m], W = i ? i(d[n], s[n], n, d, s) : void 0;
    W === void 0 && (W = s[n]), b ? dn(d, n, W) : _X(d, n, W);
  }
  return d;
}
var mi = ln, bn = mi, Zn = Ci;
function cn(s, l) {
  return s && bn(l, Zn(l), s);
}
var sn = cn;
function mn(s) {
  var l = [];
  if (s != null)
    for (var d in Object(s))
      l.push(d);
  return l;
}
var tn = mn, Xn = yl, nn = Ji, Wn = tn, on = Object.prototype, an = on.hasOwnProperty;
function en(s) {
  if (!Xn(s))
    return Wn(s);
  var l = nn(s), d = [];
  for (var i in s)
    i == "constructor" && (l || !an.call(s, i)) || d.push(i);
  return d;
}
var Gn = en, un = _b, Vn = Gn, hn = lZ;
function pn(s) {
  return hn(s) ? un(s, !0) : Vn(s);
}
var Fi = pn, yn = mi, In = Fi;
function Ln(s, l) {
  return s && yn(l, In(l), s);
}
var Rn = Ln, _l = { exports: {} };
_l.exports;
(function(s, l) {
  var d = sl, i = l && !l.nodeType && l, b = i && !0 && s && !s.nodeType && s, m = b && b.exports === i, o = m ? d.Buffer : void 0, n = o ? o.allocUnsafe : void 0;
  function W(e, I) {
    if (I)
      return e.slice();
    var a = e.length, V = n ? n(a) : new e.constructor(a);
    return e.copy(V), V;
  }
  s.exports = W;
})(_l, _l.exports);
var xn = _l.exports;
function Yn(s, l) {
  var d = -1, i = s.length;
  for (l || (l = Array(i)); ++d < i; )
    l[d] = s[d];
  return l;
}
var Kn = Yn, Sn = mi, rn = Yi;
function Jn(s, l) {
  return Sn(s, rn(s), l);
}
var Cn = Jn, Fn = dZ, Hn = Fn(Object.getPrototypeOf, Object), mZ = Hn, Tn = jb, Nn = mZ, gn = Yi, kn = Db, zn = Object.getOwnPropertySymbols, Mn = zn ? function(s) {
  for (var l = []; s; )
    Tn(l, gn(s)), s = Nn(s);
  return l;
} : kn, tZ = Mn, Un = mi, Qn = tZ;
function vn(s, l) {
  return Un(s, Qn(s), l);
}
var Pn = vn, wn = Ob, fn = tZ, En = Fi;
function Bn(s) {
  return wn(s, En, fn);
}
var jn = Bn, On = Object.prototype, Dn = On.hasOwnProperty;
function An(s) {
  var l = s.length, d = new s.constructor(l);
  return l && typeof s[0] == "string" && Dn.call(s, "index") && (d.index = s.index, d.input = s.input), d;
}
var qn = An, Gb = Bb;
function $n(s) {
  var l = new s.constructor(s.byteLength);
  return new Gb(l).set(new Gb(s)), l;
}
var Hi = $n, _n = Hi;
function dW(s, l) {
  var d = l ? _n(s.buffer) : s.buffer;
  return new s.constructor(d, s.byteOffset, s.byteLength);
}
var lW = dW, iW = /\w*$/;
function bW(s) {
  var l = new s.constructor(s.source, iW.exec(s));
  return l.lastIndex = s.lastIndex, l;
}
var ZW = bW, ub = ii, Vb = ub ? ub.prototype : void 0, hb = Vb ? Vb.valueOf : void 0;
function cW(s) {
  return hb ? Object(hb.call(s)) : {};
}
var sW = cW, mW = Hi;
function tW(s, l) {
  var d = l ? mW(s.buffer) : s.buffer;
  return new s.constructor(d, s.byteOffset, s.length);
}
var XW = tW, nW = Hi, WW = lW, oW = ZW, aW = sW, eW = XW, GW = "[object Boolean]", uW = "[object Date]", VW = "[object Map]", hW = "[object Number]", pW = "[object RegExp]", yW = "[object Set]", IW = "[object String]", LW = "[object Symbol]", RW = "[object ArrayBuffer]", xW = "[object DataView]", YW = "[object Float32Array]", KW = "[object Float64Array]", SW = "[object Int8Array]", rW = "[object Int16Array]", JW = "[object Int32Array]", CW = "[object Uint8Array]", FW = "[object Uint8ClampedArray]", HW = "[object Uint16Array]", TW = "[object Uint32Array]";
function NW(s, l, d) {
  var i = s.constructor;
  switch (l) {
    case RW:
      return nW(s);
    case GW:
    case uW:
      return new i(+s);
    case xW:
      return WW(s, d);
    case YW:
    case KW:
    case SW:
    case rW:
    case JW:
    case CW:
    case FW:
    case HW:
    case TW:
      return eW(s, d);
    case VW:
      return new i();
    case hW:
    case IW:
      return new i(s);
    case pW:
      return oW(s);
    case yW:
      return new i();
    case LW:
      return aW(s);
  }
}
var gW = NW, kW = yl, pb = Object.create, zW = /* @__PURE__ */ function() {
  function s() {
  }
  return function(l) {
    if (!kW(l))
      return {};
    if (pb)
      return pb(l);
    s.prototype = l;
    var d = new s();
    return s.prototype = void 0, d;
  };
}(), MW = zW, UW = MW, QW = mZ, vW = Ji;
function PW(s) {
  return typeof s.constructor == "function" && !vW(s) ? UW(QW(s)) : {};
}
var wW = PW, fW = si, EW = Il, BW = "[object Map]";
function jW(s) {
  return EW(s) && fW(s) == BW;
}
var OW = jW, DW = OW, AW = Si, yb = ri, Ib = yb && yb.isMap, qW = Ib ? AW(Ib) : DW, $W = qW, _W = si, lo = Il, io = "[object Set]";
function bo(s) {
  return lo(s) && _W(s) == io;
}
var Zo = bo, co = Zo, so = Si, Lb = ri, Rb = Lb && Lb.isSet, mo = Rb ? so(Rb) : co, to = mo, Xo = fb, no = wX, Wo = sZ, oo = sn, ao = Rn, eo = xn, Go = Kn, uo = Cn, Vo = Pn, ho = iZ, po = jn, yo = si, Io = qn, Lo = gW, Ro = wW, xo = ci, Yo = Ki, Ko = $W, So = yl, ro = to, Jo = Ci, Co = Fi, Fo = 1, Ho = 2, To = 4, XZ = "[object Arguments]", No = "[object Array]", go = "[object Boolean]", ko = "[object Date]", zo = "[object Error]", nZ = "[object Function]", Mo = "[object GeneratorFunction]", Uo = "[object Map]", Qo = "[object Number]", WZ = "[object Object]", vo = "[object RegExp]", Po = "[object Set]", wo = "[object String]", fo = "[object Symbol]", Eo = "[object WeakMap]", Bo = "[object ArrayBuffer]", jo = "[object DataView]", Oo = "[object Float32Array]", Do = "[object Float64Array]", Ao = "[object Int8Array]", qo = "[object Int16Array]", $o = "[object Int32Array]", _o = "[object Uint8Array]", da = "[object Uint8ClampedArray]", la = "[object Uint16Array]", ia = "[object Uint32Array]", Td = {};
Td[XZ] = Td[No] = Td[Bo] = Td[jo] = Td[go] = Td[ko] = Td[Oo] = Td[Do] = Td[Ao] = Td[qo] = Td[$o] = Td[Uo] = Td[Qo] = Td[WZ] = Td[vo] = Td[Po] = Td[wo] = Td[fo] = Td[_o] = Td[da] = Td[la] = Td[ia] = !0;
Td[zo] = Td[nZ] = Td[Eo] = !1;
function Bl(s, l, d, i, b, m) {
  var o, n = l & Fo, W = l & Ho, e = l & To;
  if (d && (o = b ? d(s, i, b, m) : d(s)), o !== void 0)
    return o;
  if (!So(s))
    return s;
  var I = xo(s);
  if (I) {
    if (o = Io(s), !n)
      return Go(s, o);
  } else {
    var a = yo(s), V = a == nZ || a == Mo;
    if (Yo(s))
      return eo(s, n);
    if (a == WZ || a == XZ || V && !b) {
      if (o = W || V ? {} : Ro(s), !n)
        return W ? Vo(s, ao(o, s)) : uo(s, oo(o, s));
    } else {
      if (!Td[a])
        return b ? s : {};
      o = Lo(s, a, n);
    }
  }
  m || (m = new Xo());
  var h = m.get(s);
  if (h)
    return h;
  m.set(s, o), ro(s) ? s.forEach(function(G) {
    o.add(Bl(G, l, d, G, s, m));
  }) : Ko(s) && s.forEach(function(G, y) {
    o.set(y, Bl(G, l, d, y, s, m));
  });
  var Y = e ? W ? po : ho : W ? Co : Jo, p = I ? void 0 : Y(s);
  return no(p || s, function(G, y) {
    p && (y = G, G = s[y]), Wo(o, y, Bl(G, l, d, y, s, m));
  }), o;
}
var oZ = Bl, ba = oZ, Za = 1, ca = 4;
function sa(s) {
  return ba(s, Za | ca);
}
var ma = sa;
const qd = /* @__PURE__ */ Pl(ma), ta = {
  linear: (s) => s,
  easeInQuad: (s) => s * s,
  easeOutQuad: (s) => s * (2 - s),
  easeInOutQuad: (s) => s < 0.5 ? 2 * s * s : -1 + (4 - 2 * s) * s,
  easeInCubic: (s) => s * s * s,
  easeOutCubic: (s) => --s * s * s + 1,
  easeInOutCubic: (s) => s < 0.5 ? 4 * s * s * s : (s - 1) * (2 * s - 2) * (2 * s - 2) + 1,
  easeInQuart: (s) => s * s * s * s,
  easeOutQuart: (s) => 1 - --s * s * s * s,
  easeInOutQuart: (s) => s < 0.5 ? 8 * s * s * s * s : 1 - 8 * --s * s * s * s,
  easeInQuint: (s) => s * s * s * s * s,
  easeOutQuint: (s) => 1 + --s * s * s * s * s,
  easeInOutQuint: (s) => s < 0.5 ? 16 * s * s * s * s * s : 1 + 16 * --s * s * s * s * s,
  easeInSine: (s) => 1 - Math.cos(s * Math.PI / 2),
  easeOutSine: (s) => Math.sin(s * Math.PI / 2),
  easeInOutSine: (s) => -(Math.cos(Math.PI * s) - 1) / 2,
  easeInExpo: (s) => s <= 0 ? 0 : Math.pow(2, 10 * s - 10),
  easeOutExpo: (s) => s >= 1 ? 1 : 1 - Math.pow(2, -10 * s),
  easeInOutExpo: (s) => s <= 0 ? 0 : s >= 1 ? 1 : s < 0.5 ? Math.pow(2, 20 * s - 10) / 2 : (2 - Math.pow(2, -20 * s + 10)) / 2
};
class Vd {
  constructor(l = 0, d = 0, i = 1) {
    Object.defineProperty(this, "x", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: l
    }), Object.defineProperty(this, "y", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: d
    }), Object.defineProperty(this, "z", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: i
    });
  }
  get XY() {
    return [this.x, this.y];
  }
  setz(l) {
    return this.z = l, this;
  }
  setXY(l = this.x, d = this.y) {
    return this.x = l, this.y = d, this;
  }
  set(l = this.x, d = this.y, i = this.z) {
    return this.x = l, this.y = d, this.z = i, this;
  }
  setTo({ x: l = 0, y: d = 0, z: i = 1 }) {
    return this.x = l, this.y = d, this.z = i, this;
  }
  rot(l) {
    if (l === 0)
      return this;
    const { x: d, y: i } = this, b = Math.sin(l), m = Math.cos(l);
    return this.x = d * m - i * b, this.y = d * b + i * m, this;
  }
  rotWith(l, d) {
    if (d === 0)
      return this;
    const i = this.x - l.x, b = this.y - l.y, m = Math.sin(d), o = Math.cos(d);
    return this.x = l.x + (i * o - b * m), this.y = l.y + (i * m + b * o), this;
  }
  clone() {
    const { x: l, y: d, z: i } = this;
    return new Vd(l, d, i);
  }
  sub(l) {
    return this.x -= l.x, this.y -= l.y, this;
  }
  subXY(l, d) {
    return this.x -= l, this.y -= d, this;
  }
  subScalar(l) {
    return this.x -= l, this.y -= l, this;
  }
  add(l) {
    return this.x += l.x, this.y += l.y, this;
  }
  addXY(l, d) {
    return this.x += l, this.y += d, this;
  }
  addScalar(l) {
    return this.x += l, this.y += l, this;
  }
  clamp(l, d) {
    return this.x = Math.max(this.x, l), this.y = Math.max(this.y, l), d !== void 0 && (this.x = Math.min(this.x, d), this.y = Math.min(this.y, d)), this;
  }
  div(l) {
    return this.x /= l, this.y /= l, this;
  }
  divV(l) {
    return this.x /= l.x, this.y /= l.y, this;
  }
  mul(l) {
    return this.x *= l, this.y *= l, this;
  }
  mulV(l) {
    return this.x *= l.x, this.y *= l.y, this;
  }
  abs() {
    return this.x = Math.abs(this.x), this.y = Math.abs(this.y), this;
  }
  nudge(l, d) {
    const i = Vd.Tan(l, this);
    return this.add(i.mul(d));
  }
  neg() {
    return this.x *= -1, this.y *= -1, this;
  }
  cross(l) {
    return this.x = this.y * l.z - this.z * l.y, this.y = this.z * l.x - this.x * l.z, this;
  }
  dpr(l) {
    return Vd.Dpr(this, l);
  }
  cpr(l) {
    return Vd.Cpr(this, l);
  }
  len2() {
    return Vd.Len2(this);
  }
  len() {
    return Vd.Len(this);
  }
  pry(l) {
    return Vd.Pry(this, l);
  }
  per() {
    const { x: l, y: d } = this;
    return this.x = d, this.y = -l, this;
  }
  uni() {
    return Vd.Uni(this);
  }
  tan(l) {
    return Vd.Tan(this, l);
  }
  dist(l) {
    return Vd.Dist(this, l);
  }
  distanceToLineSegment(l, d) {
    return Vd.DistanceToLineSegment(l, d, this);
  }
  slope(l) {
    return Vd.Slope(this, l);
  }
  snapToGrid(l) {
    return this.x = Math.round(this.x / l) * l, this.y = Math.round(this.y / l) * l, this;
  }
  angle(l) {
    return Vd.Angle(this, l);
  }
  toAngle() {
    return Vd.ToAngle(this);
  }
  lrp(l, d) {
    return this.x = this.x + (l.x - this.x) * d, this.y = this.y + (l.y - this.y) * d, this;
  }
  equals(l, d) {
    return Vd.Equals(this, l, d);
  }
  equalsXY(l, d) {
    return Vd.EqualsXY(this, l, d);
  }
  norm() {
    const l = this.len();
    return this.x = l === 0 ? 0 : this.x / l, this.y = l === 0 ? 0 : this.y / l, this;
  }
  toFixed() {
    return Vd.ToFixed(this);
  }
  toString() {
    return Vd.ToString(Vd.ToFixed(this));
  }
  toJson() {
    return Vd.ToJson(this);
  }
  toArray() {
    return Vd.ToArray(this);
  }
  static Add(l, d) {
    return new Vd(l.x + d.x, l.y + d.y);
  }
  static AddXY(l, d, i) {
    return new Vd(l.x + d, l.y + i);
  }
  static Sub(l, d) {
    return new Vd(l.x - d.x, l.y - d.y);
  }
  static SubXY(l, d, i) {
    return new Vd(l.x - d, l.y - i);
  }
  static AddScalar(l, d) {
    return new Vd(l.x + d, l.y + d);
  }
  static SubScalar(l, d) {
    return new Vd(l.x - d, l.y - d);
  }
  static Div(l, d) {
    return new Vd(l.x / d, l.y / d);
  }
  static Mul(l, d) {
    return new Vd(l.x * d, l.y * d);
  }
  static DivV(l, d) {
    return new Vd(l.x / d.x, l.y / d.y);
  }
  static MulV(l, d) {
    return new Vd(l.x * d.x, l.y * d.y);
  }
  static Neg(l) {
    return new Vd(-l.x, -l.y);
  }
  static Per(l) {
    return new Vd(l.y, -l.x);
  }
  static Dist2(l, d) {
    return Vd.Sub(l, d).len2();
  }
  static Abs(l) {
    return new Vd(Math.abs(l.x), Math.abs(l.y));
  }
  static Dist(l, d) {
    return Math.hypot(l.y - d.y, l.x - d.x);
  }
  static Dpr(l, d) {
    return l.x * d.x + l.y * d.y;
  }
  static Cross(l, d) {
    return new Vd(
      l.y * d.z - l.z * d.y,
      l.z * d.x - l.x * d.z
      // A.z = A.x * V.y - A.y * V.x
    );
  }
  static Cpr(l, d) {
    return l.x * d.y - d.x * l.y;
  }
  static Len2(l) {
    return l.x * l.x + l.y * l.y;
  }
  static Len(l) {
    return Math.hypot(l.x, l.y);
  }
  static Pry(l, d) {
    return Vd.Dpr(l, d) / Vd.Len(d);
  }
  static Uni(l) {
    return Vd.Div(l, Vd.Len(l));
  }
  static Tan(l, d) {
    return Vd.Uni(Vd.Sub(l, d));
  }
  static Min(l, d) {
    return new Vd(Math.min(l.x, d.x), Math.min(l.y, d.y));
  }
  static Max(l, d) {
    return new Vd(Math.max(l.x, d.x), Math.max(l.y, d.y));
  }
  static From(l) {
    return new Vd().add(l);
  }
  static FromArray(l) {
    return new Vd(l[0], l[1]);
  }
  static Rot(l, d = 0) {
    const i = Math.sin(d), b = Math.cos(d);
    return new Vd(l.x * b - l.y * i, l.x * i + l.y * b);
  }
  static RotWith(l, d, i) {
    const b = l.x - d.x, m = l.y - d.y, o = Math.sin(i), n = Math.cos(i);
    return new Vd(d.x + (b * n - m * o), d.y + (b * o + m * n));
  }
  /**
   * Get the nearest point on a line with a known unit vector that passes through point A
   *
   * ```ts
   * Vec.nearestPointOnLineThroughPoint(A, u, Point)
   * ```
   *
   * @param A - Any point on the line
   * @param u - The unit vector for the line.
   * @param P - A point not on the line to test.
   */
  static NearestPointOnLineThroughPoint(l, d, i) {
    return Vd.Mul(d, Vd.Sub(i, l).pry(d)).add(l);
  }
  static NearestPointOnLineSegment(l, d, i, b = !0) {
    const m = Vd.Tan(d, l), o = Vd.Add(l, Vd.Mul(m, Vd.Sub(i, l).pry(m)));
    if (b) {
      if (o.x < Math.min(l.x, d.x))
        return Vd.Cast(l.x < d.x ? l : d);
      if (o.x > Math.max(l.x, d.x))
        return Vd.Cast(l.x > d.x ? l : d);
      if (o.y < Math.min(l.y, d.y))
        return Vd.Cast(l.y < d.y ? l : d);
      if (o.y > Math.max(l.y, d.y))
        return Vd.Cast(l.y > d.y ? l : d);
    }
    return o;
  }
  static DistanceToLineThroughPoint(l, d, i) {
    return Vd.Dist(i, Vd.NearestPointOnLineThroughPoint(l, d, i));
  }
  static DistanceToLineSegment(l, d, i, b = !0) {
    return Vd.Dist(i, Vd.NearestPointOnLineSegment(l, d, i, b));
  }
  static Snap(l, d = 1) {
    return new Vd(Math.round(l.x / d) * d, Math.round(l.y / d) * d);
  }
  static Cast(l) {
    return l instanceof Vd ? l : Vd.From(l);
  }
  static Slope(l, d) {
    return l.x === d.y ? NaN : (l.y - d.y) / (l.x - d.x);
  }
  static Angle(l, d) {
    return Math.atan2(d.y - l.y, d.x - l.x);
  }
  static Lrp(l, d, i) {
    return Vd.Sub(d, l).mul(i).add(l);
  }
  static Med(l, d) {
    return new Vd((l.x + d.x) / 2, (l.y + d.y) / 2);
  }
  static Equals(l, d, i = 1e-4) {
    return Math.abs(l.x - d.x) < i && Math.abs(l.y - d.y) < i;
  }
  static EqualsXY(l, d, i) {
    return l.x === d && l.y === i;
  }
  static EqualsXYZ(l, d, i = 1e-4) {
    return Vd.Equals(l, d, i) && Math.abs((l.z || 0) - (d.z || 0)) < i;
  }
  static Clockwise(l, d, i) {
    return (i.x - l.x) * (d.y - l.y) - (d.x - l.x) * (i.y - l.y) < 0;
  }
  static Rescale(l, d) {
    const i = Vd.Len(l);
    return new Vd(d * l.x / i, d * l.y / i);
  }
  static ScaleWithOrigin(l, d, i) {
    return Vd.Sub(l, i).mul(d).add(i);
  }
  static ScaleWOrigin(l, d, i) {
    return Vd.Sub(l, i).mulV(d).add(i);
  }
  static ToFixed(l, d = 2) {
    return new Vd(+l.x.toFixed(d), +l.y.toFixed(d), +l.z.toFixed(d));
  }
  static Nudge(l, d, i) {
    return Vd.Add(l, Vd.Tan(d, l).mul(i));
  }
  static ToString(l) {
    return `${l.x}, ${l.y}`;
  }
  static ToAngle(l) {
    let d = Math.atan2(l.y, l.x);
    return d < 0 && (d += Math.PI * 2), d;
  }
  static FromAngle(l, d = 1) {
    return new Vd(Math.cos(l) * d, Math.sin(l) * d);
  }
  static ToArray(l) {
    return [l.x, l.y, l.z];
  }
  static ToJson(l) {
    const { x: d, y: i, z: b } = l;
    return { x: d, y: i, z: b };
  }
  static Average(l) {
    const d = l.length, i = new Vd(0, 0);
    for (let b = 0; b < d; b++)
      i.add(l[b]);
    return i.div(d);
  }
  static Clamp(l, d, i) {
    return i === void 0 ? new Vd(Math.min(Math.max(l.x, d)), Math.min(Math.max(l.y, d))) : new Vd(Math.min(Math.max(l.x, d), i), Math.min(Math.max(l.y, d), i));
  }
  /**
   * Get an array of points (with simulated pressure) between two points.
   *
   * @param A - The first point.
   * @param B - The second point.
   * @param steps - The number of points to return.
   */
  static PointsBetween(l, d, i = 6) {
    const b = [];
    for (let m = 0; m < i; m++) {
      const o = ta.easeInQuad(m / (i - 1)), n = Vd.Lrp(l, d, o);
      n.z = Math.min(1, 0.5 + Math.abs(0.5 - Xa(o)) * 0.65), b.push(n);
    }
    return b;
  }
  static SnapToGrid(l, d = 8) {
    return new Vd(Math.round(l.x / d) * d, Math.round(l.y / d) * d);
  }
}
const Xa = (s) => s < 0.5 ? 2 * s * s : -1 + (4 - 2 * s) * s;
class kd extends Vd {
  constructor(l = 0, d = 0, i = 0, b = { x: 0, y: 0 }, m = 0, o = 0) {
    super(l, d, i), Object.defineProperty(this, "x", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: l
    }), Object.defineProperty(this, "y", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: d
    }), Object.defineProperty(this, "z", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: i
    }), Object.defineProperty(this, "v", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: b
    }), Object.defineProperty(this, "t", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: m
    }), Object.defineProperty(this, "a", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: o
    });
  }
  get timestamp() {
    return this.t;
  }
  get pressure() {
    return this.z;
  }
  get angleNum() {
    return this.a;
  }
  get XY() {
    return [this.x, this.y];
  }
  setA(l) {
    this.a = l;
  }
  setT(l) {
    this.t = l;
  }
  setv(l) {
    return this.v = { x: l.x, y: l.y }, this;
  }
  set(l = this.x, d = this.y, i = this.z, b = this.v, m = this.t, o = this.a) {
    return this.x = l, this.y = d, this.z = i, this.v = b, this.t = m, this.a = o, this;
  }
  clone() {
    const { x: l, y: d, z: i, v: b, t: m, a: o } = this, n = { x: b.x, y: b.y };
    return new kd(l, d, i, n, m, o);
  }
  distance(l) {
    return kd.GetDistance(this, l);
  }
  isNear(l, d) {
    return kd.IsNear(this, l, d);
  }
  getAngleByPoints(l, d) {
    return kd.GetAngleByPoints(l, this, d);
  }
  static Sub(l, d) {
    return new kd(l.x - d.x, l.y - d.y);
  }
  static Add(l, d) {
    return new kd(l.x + d.x, l.y + d.y);
  }
  static GetDistance(l, d) {
    return kd.Len(l.clone().sub(d));
  }
  static GetAngleByPoints(l, d, i) {
    const b = d.x - l.x, m = i.x - d.x, o = d.y - l.y, n = i.y - d.y;
    let W = 0;
    const e = Math.sqrt(b * b + o * o), I = Math.sqrt(m * m + n * n);
    if (e && I) {
      const a = b * m + o * n;
      W = Math.acos(a / (e * I)), W = W / Math.PI * 180;
      let V = b * n - o * m;
      V = V > 0 ? 1 : -1, W = 180 + V * W;
    }
    return W;
  }
  static IsNear(l, d, i) {
    return kd.Len(l.clone().sub(d)) < i;
  }
  static RotWith(l, d, i, b = 2) {
    const m = l.x - d.x, o = l.y - d.y, n = Math.sin(i), W = Math.cos(i), e = Math.pow(10, b), I = Math.floor((d.x + (m * W - o * n)) * e) / e, a = Math.floor((d.y + (m * n + o * W)) * e) / e;
    return new kd(I, a);
  }
  /**
   * 根据圆心和半径，获取圆上的等份点
   * @param o 圆心
   * @param radius 半径
   * @param average 均分数
   * @returns
   */
  static GetDotStroke(l, d, i = 16) {
    const b = new Vd(1, 1), m = Math.PI + 1e-3, o = kd.Add(l, kd.Sub(l, b).uni().per().mul(-d)), n = [];
    for (let W = 1 / i, e = W; e <= 1; e += W)
      n.push(kd.RotWith(o, l, m * 2 * e));
    return n;
  }
  /**
   * 根据圆心和园上的起始点，获取半圆上的等份点
   * @param o 圆心
   * @param p 圆弧起始点
   * @param radian 1，逆时针180度 -1，顺时针
   * @param average 均分数
   * @returns
   */
  static GetSemicircleStroke(l, d, i = -1, b = 8) {
    const m = i * (Math.PI + 1e-3), o = [];
    for (let n = 1 / b, W = n; W <= 1; W += n)
      o.push(kd.RotWith(d, l, m * W));
    return o;
  }
}
var na = Tl, Wa = Il, oa = "[object Number]";
function aa(s) {
  return typeof s == "number" || Wa(s) && na(s) == oa;
}
var ea = aa;
const il = /* @__PURE__ */ Pl(ea);
var Hd = (
  /******/
  function(s) {
    var l = {};
    function d(i) {
      if (l[i])
        return l[i].exports;
      var b = l[i] = {
        /******/
        i,
        /******/
        l: !1,
        /******/
        exports: {}
        /******/
      };
      return s[i].call(b.exports, b, b.exports, d), b.l = !0, b.exports;
    }
    return d.m = s, d.c = l, d.d = function(i, b, m) {
      d.o(i, b) || Object.defineProperty(i, b, { enumerable: !0, get: m });
    }, d.r = function(i) {
      typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(i, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(i, "__esModule", { value: !0 });
    }, d.t = function(i, b) {
      if (b & 1 && (i = d(i)), b & 8 || b & 4 && typeof i == "object" && i && i.__esModule)
        return i;
      var m = /* @__PURE__ */ Object.create(null);
      if (d.r(m), Object.defineProperty(m, "default", { enumerable: !0, value: i }), b & 2 && typeof i != "string")
        for (var o in i)
          d.d(m, o, (function(n) {
            return i[n];
          }).bind(null, o));
      return m;
    }, d.n = function(i) {
      var b = i && i.__esModule ? (
        /******/
        function() {
          return i.default;
        }
      ) : (
        /******/
        function() {
          return i;
        }
      );
      return d.d(b, "a", b), b;
    }, d.o = function(i, b) {
      return Object.prototype.hasOwnProperty.call(i, b);
    }, d.p = "/js/", d(d.s = 0);
  }([
    /* 0 */
    /***/
    function(s, l, d) {
      d.r(l), d.d(l, "version", function() {
        return f;
      }), d.d(l, "helpers", function() {
        return g;
      }), d.d(l, "createElement", function() {
        return F;
      }), d.d(l, "isSpriteNode", function() {
        return r;
      }), d.d(l, "registerNode", function() {
        return K;
      });
      var i = d(12);
      d.d(l, "ENV", function() {
        return i.ENV;
      });
      var b = d(68);
      d.d(l, "requestAnimationFrame", function() {
        return b.requestAnimationFrame;
      }), d.d(l, "cancelAnimationFrame", function() {
        return b.cancelAnimationFrame;
      });
      var m = d(70);
      d.d(l, "Node", function() {
        return m.default;
      });
      var o = d(217);
      d.d(l, "Cloud", function() {
        return o.default;
      });
      var n = d(219);
      d.d(l, "Block", function() {
        return n.default;
      });
      var W = d(224);
      d.d(l, "Sprite", function() {
        return W.default;
      });
      var e = d(226);
      d.d(l, "Path", function() {
        return e.default;
      });
      var I = d(229);
      d.d(l, "Rect", function() {
        return I.default;
      });
      var a = d(231);
      d.d(l, "Triangle", function() {
        return a.default;
      });
      var V = d(236);
      d.d(l, "Parallel", function() {
        return V.default;
      });
      var h = d(238);
      d.d(l, "Regular", function() {
        return h.default;
      });
      var Y = d(240);
      d.d(l, "Star", function() {
        return Y.default;
      });
      var p = d(242);
      d.d(l, "Ellipse", function() {
        return p.default;
      });
      var G = d(244);
      d.d(l, "Arc", function() {
        return G.default;
      });
      var y = d(246);
      d.d(l, "Ring", function() {
        return y.default;
      });
      var Z = d(232);
      d.d(l, "Polyline", function() {
        return Z.default;
      });
      var X = d(248);
      d.d(l, "Label", function() {
        return X.default;
      });
      var c = d(250);
      d.d(l, "Group", function() {
        return c.default;
      });
      var t = d(286);
      d.d(l, "Layer", function() {
        return t.default;
      });
      var R = d(287);
      d.d(l, "SpriteSvg", function() {
        return R.default;
      });
      var S = d(289);
      d.d(l, "LayerWorker", function() {
        return S.default;
      });
      var J = d(290);
      d.d(l, "Scene", function() {
        return J.default;
      });
      var H = d(213), L = d(221);
      d.d(l, "Color", function() {
        return L.Color;
      }), d.d(l, "Gradient", function() {
        return L.Gradient;
      });
      var C = d(72);
      d(1).glMatrix.setMatrixArrayType(Array);
      const F = H.default.createElement, r = H.default.isSpriteNode, K = H.default.registerNode, g = {
        parseColor: L.parseColor,
        sizeToPixel: C.sizeToPixel,
        toArray: C.toArray,
        toString: C.toString,
        toNumber: C.toNumber
      };
      let v;
      v = "3.8.3";
      const f = v;
    },
    /* 1 */
    /***/
    function(s, l, d) {
      d.r(l);
      var i = d(2);
      d.d(l, "glMatrix", function() {
        return i;
      });
      var b = d(3);
      d.d(l, "mat2", function() {
        return b;
      });
      var m = d(4);
      d.d(l, "mat2d", function() {
        return m;
      });
      var o = d(5);
      d.d(l, "mat3", function() {
        return o;
      });
      var n = d(6);
      d.d(l, "mat4", function() {
        return n;
      });
      var W = d(7);
      d.d(l, "quat", function() {
        return W;
      });
      var e = d(10);
      d.d(l, "quat2", function() {
        return e;
      });
      var I = d(11);
      d.d(l, "vec2", function() {
        return I;
      });
      var a = d(8);
      d.d(l, "vec3", function() {
        return a;
      });
      var V = d(9);
      d.d(l, "vec4", function() {
        return V;
      });
    },
    /* 2 */
    /***/
    function(s, l, d) {
      d.r(l), d.d(l, "EPSILON", function() {
        return i;
      }), d.d(l, "ARRAY_TYPE", function() {
        return b;
      }), d.d(l, "RANDOM", function() {
        return m;
      }), d.d(l, "setMatrixArrayType", function() {
        return o;
      }), d.d(l, "toRadian", function() {
        return W;
      }), d.d(l, "equals", function() {
        return e;
      });
      var i = 1e-6, b = typeof Float32Array < "u" ? Float32Array : Array, m = Math.random;
      function o(I) {
        b = I;
      }
      var n = Math.PI / 180;
      function W(I) {
        return I * n;
      }
      function e(I, a) {
        return Math.abs(I - a) <= i * Math.max(1, Math.abs(I), Math.abs(a));
      }
      Math.hypot || (Math.hypot = function() {
        for (var I = 0, a = arguments.length; a--; )
          I += arguments[a] * arguments[a];
        return Math.sqrt(I);
      });
    },
    /* 3 */
    /***/
    function(s, l, d) {
      d.r(l), d.d(l, "create", function() {
        return b;
      }), d.d(l, "clone", function() {
        return m;
      }), d.d(l, "copy", function() {
        return o;
      }), d.d(l, "identity", function() {
        return n;
      }), d.d(l, "fromValues", function() {
        return W;
      }), d.d(l, "set", function() {
        return e;
      }), d.d(l, "transpose", function() {
        return I;
      }), d.d(l, "invert", function() {
        return a;
      }), d.d(l, "adjoint", function() {
        return V;
      }), d.d(l, "determinant", function() {
        return h;
      }), d.d(l, "multiply", function() {
        return Y;
      }), d.d(l, "rotate", function() {
        return p;
      }), d.d(l, "scale", function() {
        return G;
      }), d.d(l, "fromRotation", function() {
        return y;
      }), d.d(l, "fromScaling", function() {
        return Z;
      }), d.d(l, "str", function() {
        return X;
      }), d.d(l, "frob", function() {
        return c;
      }), d.d(l, "LDU", function() {
        return t;
      }), d.d(l, "add", function() {
        return R;
      }), d.d(l, "subtract", function() {
        return S;
      }), d.d(l, "exactEquals", function() {
        return J;
      }), d.d(l, "equals", function() {
        return H;
      }), d.d(l, "multiplyScalar", function() {
        return L;
      }), d.d(l, "multiplyScalarAndAdd", function() {
        return C;
      }), d.d(l, "mul", function() {
        return F;
      }), d.d(l, "sub", function() {
        return r;
      });
      var i = d(2);
      function b() {
        var K = new i.ARRAY_TYPE(4);
        return i.ARRAY_TYPE != Float32Array && (K[1] = 0, K[2] = 0), K[0] = 1, K[3] = 1, K;
      }
      function m(K) {
        var g = new i.ARRAY_TYPE(4);
        return g[0] = K[0], g[1] = K[1], g[2] = K[2], g[3] = K[3], g;
      }
      function o(K, g) {
        return K[0] = g[0], K[1] = g[1], K[2] = g[2], K[3] = g[3], K;
      }
      function n(K) {
        return K[0] = 1, K[1] = 0, K[2] = 0, K[3] = 1, K;
      }
      function W(K, g, v, f) {
        var O = new i.ARRAY_TYPE(4);
        return O[0] = K, O[1] = g, O[2] = v, O[3] = f, O;
      }
      function e(K, g, v, f, O) {
        return K[0] = g, K[1] = v, K[2] = f, K[3] = O, K;
      }
      function I(K, g) {
        if (K === g) {
          var v = g[1];
          K[1] = g[2], K[2] = v;
        } else
          K[0] = g[0], K[1] = g[2], K[2] = g[1], K[3] = g[3];
        return K;
      }
      function a(K, g) {
        var v = g[0], f = g[1], O = g[2], q = g[3], M = v * q - O * f;
        return M ? (M = 1 / M, K[0] = q * M, K[1] = -f * M, K[2] = -O * M, K[3] = v * M, K) : null;
      }
      function V(K, g) {
        var v = g[0];
        return K[0] = g[3], K[1] = -g[1], K[2] = -g[2], K[3] = v, K;
      }
      function h(K) {
        return K[0] * K[3] - K[2] * K[1];
      }
      function Y(K, g, v) {
        var f = g[0], O = g[1], q = g[2], M = g[3], P = v[0], D = v[1], dd = v[2], _ = v[3];
        return K[0] = f * P + q * D, K[1] = O * P + M * D, K[2] = f * dd + q * _, K[3] = O * dd + M * _, K;
      }
      function p(K, g, v) {
        var f = g[0], O = g[1], q = g[2], M = g[3], P = Math.sin(v), D = Math.cos(v);
        return K[0] = f * D + q * P, K[1] = O * D + M * P, K[2] = f * -P + q * D, K[3] = O * -P + M * D, K;
      }
      function G(K, g, v) {
        var f = g[0], O = g[1], q = g[2], M = g[3], P = v[0], D = v[1];
        return K[0] = f * P, K[1] = O * P, K[2] = q * D, K[3] = M * D, K;
      }
      function y(K, g) {
        var v = Math.sin(g), f = Math.cos(g);
        return K[0] = f, K[1] = v, K[2] = -v, K[3] = f, K;
      }
      function Z(K, g) {
        return K[0] = g[0], K[1] = 0, K[2] = 0, K[3] = g[1], K;
      }
      function X(K) {
        return "mat2(" + K[0] + ", " + K[1] + ", " + K[2] + ", " + K[3] + ")";
      }
      function c(K) {
        return Math.hypot(K[0], K[1], K[2], K[3]);
      }
      function t(K, g, v, f) {
        return K[2] = f[2] / f[0], v[0] = f[0], v[1] = f[1], v[3] = f[3] - K[2] * v[1], [K, g, v];
      }
      function R(K, g, v) {
        return K[0] = g[0] + v[0], K[1] = g[1] + v[1], K[2] = g[2] + v[2], K[3] = g[3] + v[3], K;
      }
      function S(K, g, v) {
        return K[0] = g[0] - v[0], K[1] = g[1] - v[1], K[2] = g[2] - v[2], K[3] = g[3] - v[3], K;
      }
      function J(K, g) {
        return K[0] === g[0] && K[1] === g[1] && K[2] === g[2] && K[3] === g[3];
      }
      function H(K, g) {
        var v = K[0], f = K[1], O = K[2], q = K[3], M = g[0], P = g[1], D = g[2], dd = g[3];
        return Math.abs(v - M) <= i.EPSILON * Math.max(1, Math.abs(v), Math.abs(M)) && Math.abs(f - P) <= i.EPSILON * Math.max(1, Math.abs(f), Math.abs(P)) && Math.abs(O - D) <= i.EPSILON * Math.max(1, Math.abs(O), Math.abs(D)) && Math.abs(q - dd) <= i.EPSILON * Math.max(1, Math.abs(q), Math.abs(dd));
      }
      function L(K, g, v) {
        return K[0] = g[0] * v, K[1] = g[1] * v, K[2] = g[2] * v, K[3] = g[3] * v, K;
      }
      function C(K, g, v, f) {
        return K[0] = g[0] + v[0] * f, K[1] = g[1] + v[1] * f, K[2] = g[2] + v[2] * f, K[3] = g[3] + v[3] * f, K;
      }
      var F = Y, r = S;
    },
    /* 4 */
    /***/
    function(s, l, d) {
      d.r(l), d.d(l, "create", function() {
        return b;
      }), d.d(l, "clone", function() {
        return m;
      }), d.d(l, "copy", function() {
        return o;
      }), d.d(l, "identity", function() {
        return n;
      }), d.d(l, "fromValues", function() {
        return W;
      }), d.d(l, "set", function() {
        return e;
      }), d.d(l, "invert", function() {
        return I;
      }), d.d(l, "determinant", function() {
        return a;
      }), d.d(l, "multiply", function() {
        return V;
      }), d.d(l, "rotate", function() {
        return h;
      }), d.d(l, "scale", function() {
        return Y;
      }), d.d(l, "translate", function() {
        return p;
      }), d.d(l, "fromRotation", function() {
        return G;
      }), d.d(l, "fromScaling", function() {
        return y;
      }), d.d(l, "fromTranslation", function() {
        return Z;
      }), d.d(l, "str", function() {
        return X;
      }), d.d(l, "frob", function() {
        return c;
      }), d.d(l, "add", function() {
        return t;
      }), d.d(l, "subtract", function() {
        return R;
      }), d.d(l, "multiplyScalar", function() {
        return S;
      }), d.d(l, "multiplyScalarAndAdd", function() {
        return J;
      }), d.d(l, "exactEquals", function() {
        return H;
      }), d.d(l, "equals", function() {
        return L;
      }), d.d(l, "mul", function() {
        return C;
      }), d.d(l, "sub", function() {
        return F;
      });
      var i = d(2);
      function b() {
        var r = new i.ARRAY_TYPE(6);
        return i.ARRAY_TYPE != Float32Array && (r[1] = 0, r[2] = 0, r[4] = 0, r[5] = 0), r[0] = 1, r[3] = 1, r;
      }
      function m(r) {
        var K = new i.ARRAY_TYPE(6);
        return K[0] = r[0], K[1] = r[1], K[2] = r[2], K[3] = r[3], K[4] = r[4], K[5] = r[5], K;
      }
      function o(r, K) {
        return r[0] = K[0], r[1] = K[1], r[2] = K[2], r[3] = K[3], r[4] = K[4], r[5] = K[5], r;
      }
      function n(r) {
        return r[0] = 1, r[1] = 0, r[2] = 0, r[3] = 1, r[4] = 0, r[5] = 0, r;
      }
      function W(r, K, g, v, f, O) {
        var q = new i.ARRAY_TYPE(6);
        return q[0] = r, q[1] = K, q[2] = g, q[3] = v, q[4] = f, q[5] = O, q;
      }
      function e(r, K, g, v, f, O, q) {
        return r[0] = K, r[1] = g, r[2] = v, r[3] = f, r[4] = O, r[5] = q, r;
      }
      function I(r, K) {
        var g = K[0], v = K[1], f = K[2], O = K[3], q = K[4], M = K[5], P = g * O - v * f;
        return P ? (P = 1 / P, r[0] = O * P, r[1] = -v * P, r[2] = -f * P, r[3] = g * P, r[4] = (f * M - O * q) * P, r[5] = (v * q - g * M) * P, r) : null;
      }
      function a(r) {
        return r[0] * r[3] - r[1] * r[2];
      }
      function V(r, K, g) {
        var v = K[0], f = K[1], O = K[2], q = K[3], M = K[4], P = K[5], D = g[0], dd = g[1], _ = g[2], cd = g[3], $ = g[4], Wd = g[5];
        return r[0] = v * D + O * dd, r[1] = f * D + q * dd, r[2] = v * _ + O * cd, r[3] = f * _ + q * cd, r[4] = v * $ + O * Wd + M, r[5] = f * $ + q * Wd + P, r;
      }
      function h(r, K, g) {
        var v = K[0], f = K[1], O = K[2], q = K[3], M = K[4], P = K[5], D = Math.sin(g), dd = Math.cos(g);
        return r[0] = v * dd + O * D, r[1] = f * dd + q * D, r[2] = v * -D + O * dd, r[3] = f * -D + q * dd, r[4] = M, r[5] = P, r;
      }
      function Y(r, K, g) {
        var v = K[0], f = K[1], O = K[2], q = K[3], M = K[4], P = K[5], D = g[0], dd = g[1];
        return r[0] = v * D, r[1] = f * D, r[2] = O * dd, r[3] = q * dd, r[4] = M, r[5] = P, r;
      }
      function p(r, K, g) {
        var v = K[0], f = K[1], O = K[2], q = K[3], M = K[4], P = K[5], D = g[0], dd = g[1];
        return r[0] = v, r[1] = f, r[2] = O, r[3] = q, r[4] = v * D + O * dd + M, r[5] = f * D + q * dd + P, r;
      }
      function G(r, K) {
        var g = Math.sin(K), v = Math.cos(K);
        return r[0] = v, r[1] = g, r[2] = -g, r[3] = v, r[4] = 0, r[5] = 0, r;
      }
      function y(r, K) {
        return r[0] = K[0], r[1] = 0, r[2] = 0, r[3] = K[1], r[4] = 0, r[5] = 0, r;
      }
      function Z(r, K) {
        return r[0] = 1, r[1] = 0, r[2] = 0, r[3] = 1, r[4] = K[0], r[5] = K[1], r;
      }
      function X(r) {
        return "mat2d(" + r[0] + ", " + r[1] + ", " + r[2] + ", " + r[3] + ", " + r[4] + ", " + r[5] + ")";
      }
      function c(r) {
        return Math.hypot(r[0], r[1], r[2], r[3], r[4], r[5], 1);
      }
      function t(r, K, g) {
        return r[0] = K[0] + g[0], r[1] = K[1] + g[1], r[2] = K[2] + g[2], r[3] = K[3] + g[3], r[4] = K[4] + g[4], r[5] = K[5] + g[5], r;
      }
      function R(r, K, g) {
        return r[0] = K[0] - g[0], r[1] = K[1] - g[1], r[2] = K[2] - g[2], r[3] = K[3] - g[3], r[4] = K[4] - g[4], r[5] = K[5] - g[5], r;
      }
      function S(r, K, g) {
        return r[0] = K[0] * g, r[1] = K[1] * g, r[2] = K[2] * g, r[3] = K[3] * g, r[4] = K[4] * g, r[5] = K[5] * g, r;
      }
      function J(r, K, g, v) {
        return r[0] = K[0] + g[0] * v, r[1] = K[1] + g[1] * v, r[2] = K[2] + g[2] * v, r[3] = K[3] + g[3] * v, r[4] = K[4] + g[4] * v, r[5] = K[5] + g[5] * v, r;
      }
      function H(r, K) {
        return r[0] === K[0] && r[1] === K[1] && r[2] === K[2] && r[3] === K[3] && r[4] === K[4] && r[5] === K[5];
      }
      function L(r, K) {
        var g = r[0], v = r[1], f = r[2], O = r[3], q = r[4], M = r[5], P = K[0], D = K[1], dd = K[2], _ = K[3], cd = K[4], $ = K[5];
        return Math.abs(g - P) <= i.EPSILON * Math.max(1, Math.abs(g), Math.abs(P)) && Math.abs(v - D) <= i.EPSILON * Math.max(1, Math.abs(v), Math.abs(D)) && Math.abs(f - dd) <= i.EPSILON * Math.max(1, Math.abs(f), Math.abs(dd)) && Math.abs(O - _) <= i.EPSILON * Math.max(1, Math.abs(O), Math.abs(_)) && Math.abs(q - cd) <= i.EPSILON * Math.max(1, Math.abs(q), Math.abs(cd)) && Math.abs(M - $) <= i.EPSILON * Math.max(1, Math.abs(M), Math.abs($));
      }
      var C = V, F = R;
    },
    /* 5 */
    /***/
    function(s, l, d) {
      d.r(l), d.d(l, "create", function() {
        return b;
      }), d.d(l, "fromMat4", function() {
        return m;
      }), d.d(l, "clone", function() {
        return o;
      }), d.d(l, "copy", function() {
        return n;
      }), d.d(l, "fromValues", function() {
        return W;
      }), d.d(l, "set", function() {
        return e;
      }), d.d(l, "identity", function() {
        return I;
      }), d.d(l, "transpose", function() {
        return a;
      }), d.d(l, "invert", function() {
        return V;
      }), d.d(l, "adjoint", function() {
        return h;
      }), d.d(l, "determinant", function() {
        return Y;
      }), d.d(l, "multiply", function() {
        return p;
      }), d.d(l, "translate", function() {
        return G;
      }), d.d(l, "rotate", function() {
        return y;
      }), d.d(l, "scale", function() {
        return Z;
      }), d.d(l, "fromTranslation", function() {
        return X;
      }), d.d(l, "fromRotation", function() {
        return c;
      }), d.d(l, "fromScaling", function() {
        return t;
      }), d.d(l, "fromMat2d", function() {
        return R;
      }), d.d(l, "fromQuat", function() {
        return S;
      }), d.d(l, "normalFromMat4", function() {
        return J;
      }), d.d(l, "projection", function() {
        return H;
      }), d.d(l, "str", function() {
        return L;
      }), d.d(l, "frob", function() {
        return C;
      }), d.d(l, "add", function() {
        return F;
      }), d.d(l, "subtract", function() {
        return r;
      }), d.d(l, "multiplyScalar", function() {
        return K;
      }), d.d(l, "multiplyScalarAndAdd", function() {
        return g;
      }), d.d(l, "exactEquals", function() {
        return v;
      }), d.d(l, "equals", function() {
        return f;
      }), d.d(l, "mul", function() {
        return O;
      }), d.d(l, "sub", function() {
        return q;
      });
      var i = d(2);
      function b() {
        var M = new i.ARRAY_TYPE(9);
        return i.ARRAY_TYPE != Float32Array && (M[1] = 0, M[2] = 0, M[3] = 0, M[5] = 0, M[6] = 0, M[7] = 0), M[0] = 1, M[4] = 1, M[8] = 1, M;
      }
      function m(M, P) {
        return M[0] = P[0], M[1] = P[1], M[2] = P[2], M[3] = P[4], M[4] = P[5], M[5] = P[6], M[6] = P[8], M[7] = P[9], M[8] = P[10], M;
      }
      function o(M) {
        var P = new i.ARRAY_TYPE(9);
        return P[0] = M[0], P[1] = M[1], P[2] = M[2], P[3] = M[3], P[4] = M[4], P[5] = M[5], P[6] = M[6], P[7] = M[7], P[8] = M[8], P;
      }
      function n(M, P) {
        return M[0] = P[0], M[1] = P[1], M[2] = P[2], M[3] = P[3], M[4] = P[4], M[5] = P[5], M[6] = P[6], M[7] = P[7], M[8] = P[8], M;
      }
      function W(M, P, D, dd, _, cd, $, Wd, Xd) {
        var k = new i.ARRAY_TYPE(9);
        return k[0] = M, k[1] = P, k[2] = D, k[3] = dd, k[4] = _, k[5] = cd, k[6] = $, k[7] = Wd, k[8] = Xd, k;
      }
      function e(M, P, D, dd, _, cd, $, Wd, Xd, k) {
        return M[0] = P, M[1] = D, M[2] = dd, M[3] = _, M[4] = cd, M[5] = $, M[6] = Wd, M[7] = Xd, M[8] = k, M;
      }
      function I(M) {
        return M[0] = 1, M[1] = 0, M[2] = 0, M[3] = 0, M[4] = 1, M[5] = 0, M[6] = 0, M[7] = 0, M[8] = 1, M;
      }
      function a(M, P) {
        if (M === P) {
          var D = P[1], dd = P[2], _ = P[5];
          M[1] = P[3], M[2] = P[6], M[3] = D, M[5] = P[7], M[6] = dd, M[7] = _;
        } else
          M[0] = P[0], M[1] = P[3], M[2] = P[6], M[3] = P[1], M[4] = P[4], M[5] = P[7], M[6] = P[2], M[7] = P[5], M[8] = P[8];
        return M;
      }
      function V(M, P) {
        var D = P[0], dd = P[1], _ = P[2], cd = P[3], $ = P[4], Wd = P[5], Xd = P[6], k = P[7], z = P[8], E = z * $ - Wd * k, j = -z * cd + Wd * Xd, N = k * cd - $ * Xd, Q = D * E + dd * j + _ * N;
        return Q ? (Q = 1 / Q, M[0] = E * Q, M[1] = (-z * dd + _ * k) * Q, M[2] = (Wd * dd - _ * $) * Q, M[3] = j * Q, M[4] = (z * D - _ * Xd) * Q, M[5] = (-Wd * D + _ * cd) * Q, M[6] = N * Q, M[7] = (-k * D + dd * Xd) * Q, M[8] = ($ * D - dd * cd) * Q, M) : null;
      }
      function h(M, P) {
        var D = P[0], dd = P[1], _ = P[2], cd = P[3], $ = P[4], Wd = P[5], Xd = P[6], k = P[7], z = P[8];
        return M[0] = $ * z - Wd * k, M[1] = _ * k - dd * z, M[2] = dd * Wd - _ * $, M[3] = Wd * Xd - cd * z, M[4] = D * z - _ * Xd, M[5] = _ * cd - D * Wd, M[6] = cd * k - $ * Xd, M[7] = dd * Xd - D * k, M[8] = D * $ - dd * cd, M;
      }
      function Y(M) {
        var P = M[0], D = M[1], dd = M[2], _ = M[3], cd = M[4], $ = M[5], Wd = M[6], Xd = M[7], k = M[8];
        return P * (k * cd - $ * Xd) + D * (-k * _ + $ * Wd) + dd * (Xd * _ - cd * Wd);
      }
      function p(M, P, D) {
        var dd = P[0], _ = P[1], cd = P[2], $ = P[3], Wd = P[4], Xd = P[5], k = P[6], z = P[7], E = P[8], j = D[0], N = D[1], Q = D[2], u = D[3], x = D[4], T = D[5], U = D[6], w = D[7], B = D[8];
        return M[0] = j * dd + N * $ + Q * k, M[1] = j * _ + N * Wd + Q * z, M[2] = j * cd + N * Xd + Q * E, M[3] = u * dd + x * $ + T * k, M[4] = u * _ + x * Wd + T * z, M[5] = u * cd + x * Xd + T * E, M[6] = U * dd + w * $ + B * k, M[7] = U * _ + w * Wd + B * z, M[8] = U * cd + w * Xd + B * E, M;
      }
      function G(M, P, D) {
        var dd = P[0], _ = P[1], cd = P[2], $ = P[3], Wd = P[4], Xd = P[5], k = P[6], z = P[7], E = P[8], j = D[0], N = D[1];
        return M[0] = dd, M[1] = _, M[2] = cd, M[3] = $, M[4] = Wd, M[5] = Xd, M[6] = j * dd + N * $ + k, M[7] = j * _ + N * Wd + z, M[8] = j * cd + N * Xd + E, M;
      }
      function y(M, P, D) {
        var dd = P[0], _ = P[1], cd = P[2], $ = P[3], Wd = P[4], Xd = P[5], k = P[6], z = P[7], E = P[8], j = Math.sin(D), N = Math.cos(D);
        return M[0] = N * dd + j * $, M[1] = N * _ + j * Wd, M[2] = N * cd + j * Xd, M[3] = N * $ - j * dd, M[4] = N * Wd - j * _, M[5] = N * Xd - j * cd, M[6] = k, M[7] = z, M[8] = E, M;
      }
      function Z(M, P, D) {
        var dd = D[0], _ = D[1];
        return M[0] = dd * P[0], M[1] = dd * P[1], M[2] = dd * P[2], M[3] = _ * P[3], M[4] = _ * P[4], M[5] = _ * P[5], M[6] = P[6], M[7] = P[7], M[8] = P[8], M;
      }
      function X(M, P) {
        return M[0] = 1, M[1] = 0, M[2] = 0, M[3] = 0, M[4] = 1, M[5] = 0, M[6] = P[0], M[7] = P[1], M[8] = 1, M;
      }
      function c(M, P) {
        var D = Math.sin(P), dd = Math.cos(P);
        return M[0] = dd, M[1] = D, M[2] = 0, M[3] = -D, M[4] = dd, M[5] = 0, M[6] = 0, M[7] = 0, M[8] = 1, M;
      }
      function t(M, P) {
        return M[0] = P[0], M[1] = 0, M[2] = 0, M[3] = 0, M[4] = P[1], M[5] = 0, M[6] = 0, M[7] = 0, M[8] = 1, M;
      }
      function R(M, P) {
        return M[0] = P[0], M[1] = P[1], M[2] = 0, M[3] = P[2], M[4] = P[3], M[5] = 0, M[6] = P[4], M[7] = P[5], M[8] = 1, M;
      }
      function S(M, P) {
        var D = P[0], dd = P[1], _ = P[2], cd = P[3], $ = D + D, Wd = dd + dd, Xd = _ + _, k = D * $, z = dd * $, E = dd * Wd, j = _ * $, N = _ * Wd, Q = _ * Xd, u = cd * $, x = cd * Wd, T = cd * Xd;
        return M[0] = 1 - E - Q, M[3] = z - T, M[6] = j + x, M[1] = z + T, M[4] = 1 - k - Q, M[7] = N - u, M[2] = j - x, M[5] = N + u, M[8] = 1 - k - E, M;
      }
      function J(M, P) {
        var D = P[0], dd = P[1], _ = P[2], cd = P[3], $ = P[4], Wd = P[5], Xd = P[6], k = P[7], z = P[8], E = P[9], j = P[10], N = P[11], Q = P[12], u = P[13], x = P[14], T = P[15], U = D * Wd - dd * $, w = D * Xd - _ * $, B = D * k - cd * $, A = dd * Xd - _ * Wd, ld = dd * k - cd * Wd, id = _ * k - cd * Xd, sd = z * u - E * Q, td = z * x - j * Q, Zd = z * T - N * Q, bd = E * x - j * u, md = E * T - N * u, od = j * T - N * x, ed = U * od - w * md + B * bd + A * Zd - ld * td + id * sd;
        return ed ? (ed = 1 / ed, M[0] = (Wd * od - Xd * md + k * bd) * ed, M[1] = (Xd * Zd - $ * od - k * td) * ed, M[2] = ($ * md - Wd * Zd + k * sd) * ed, M[3] = (_ * md - dd * od - cd * bd) * ed, M[4] = (D * od - _ * Zd + cd * td) * ed, M[5] = (dd * Zd - D * md - cd * sd) * ed, M[6] = (u * id - x * ld + T * A) * ed, M[7] = (x * B - Q * id - T * w) * ed, M[8] = (Q * ld - u * B + T * U) * ed, M) : null;
      }
      function H(M, P, D) {
        return M[0] = 2 / P, M[1] = 0, M[2] = 0, M[3] = 0, M[4] = -2 / D, M[5] = 0, M[6] = -1, M[7] = 1, M[8] = 1, M;
      }
      function L(M) {
        return "mat3(" + M[0] + ", " + M[1] + ", " + M[2] + ", " + M[3] + ", " + M[4] + ", " + M[5] + ", " + M[6] + ", " + M[7] + ", " + M[8] + ")";
      }
      function C(M) {
        return Math.hypot(M[0], M[1], M[2], M[3], M[4], M[5], M[6], M[7], M[8]);
      }
      function F(M, P, D) {
        return M[0] = P[0] + D[0], M[1] = P[1] + D[1], M[2] = P[2] + D[2], M[3] = P[3] + D[3], M[4] = P[4] + D[4], M[5] = P[5] + D[5], M[6] = P[6] + D[6], M[7] = P[7] + D[7], M[8] = P[8] + D[8], M;
      }
      function r(M, P, D) {
        return M[0] = P[0] - D[0], M[1] = P[1] - D[1], M[2] = P[2] - D[2], M[3] = P[3] - D[3], M[4] = P[4] - D[4], M[5] = P[5] - D[5], M[6] = P[6] - D[6], M[7] = P[7] - D[7], M[8] = P[8] - D[8], M;
      }
      function K(M, P, D) {
        return M[0] = P[0] * D, M[1] = P[1] * D, M[2] = P[2] * D, M[3] = P[3] * D, M[4] = P[4] * D, M[5] = P[5] * D, M[6] = P[6] * D, M[7] = P[7] * D, M[8] = P[8] * D, M;
      }
      function g(M, P, D, dd) {
        return M[0] = P[0] + D[0] * dd, M[1] = P[1] + D[1] * dd, M[2] = P[2] + D[2] * dd, M[3] = P[3] + D[3] * dd, M[4] = P[4] + D[4] * dd, M[5] = P[5] + D[5] * dd, M[6] = P[6] + D[6] * dd, M[7] = P[7] + D[7] * dd, M[8] = P[8] + D[8] * dd, M;
      }
      function v(M, P) {
        return M[0] === P[0] && M[1] === P[1] && M[2] === P[2] && M[3] === P[3] && M[4] === P[4] && M[5] === P[5] && M[6] === P[6] && M[7] === P[7] && M[8] === P[8];
      }
      function f(M, P) {
        var D = M[0], dd = M[1], _ = M[2], cd = M[3], $ = M[4], Wd = M[5], Xd = M[6], k = M[7], z = M[8], E = P[0], j = P[1], N = P[2], Q = P[3], u = P[4], x = P[5], T = P[6], U = P[7], w = P[8];
        return Math.abs(D - E) <= i.EPSILON * Math.max(1, Math.abs(D), Math.abs(E)) && Math.abs(dd - j) <= i.EPSILON * Math.max(1, Math.abs(dd), Math.abs(j)) && Math.abs(_ - N) <= i.EPSILON * Math.max(1, Math.abs(_), Math.abs(N)) && Math.abs(cd - Q) <= i.EPSILON * Math.max(1, Math.abs(cd), Math.abs(Q)) && Math.abs($ - u) <= i.EPSILON * Math.max(1, Math.abs($), Math.abs(u)) && Math.abs(Wd - x) <= i.EPSILON * Math.max(1, Math.abs(Wd), Math.abs(x)) && Math.abs(Xd - T) <= i.EPSILON * Math.max(1, Math.abs(Xd), Math.abs(T)) && Math.abs(k - U) <= i.EPSILON * Math.max(1, Math.abs(k), Math.abs(U)) && Math.abs(z - w) <= i.EPSILON * Math.max(1, Math.abs(z), Math.abs(w));
      }
      var O = p, q = r;
    },
    /* 6 */
    /***/
    function(s, l, d) {
      d.r(l), d.d(l, "create", function() {
        return b;
      }), d.d(l, "clone", function() {
        return m;
      }), d.d(l, "copy", function() {
        return o;
      }), d.d(l, "fromValues", function() {
        return n;
      }), d.d(l, "set", function() {
        return W;
      }), d.d(l, "identity", function() {
        return e;
      }), d.d(l, "transpose", function() {
        return I;
      }), d.d(l, "invert", function() {
        return a;
      }), d.d(l, "adjoint", function() {
        return V;
      }), d.d(l, "determinant", function() {
        return h;
      }), d.d(l, "multiply", function() {
        return Y;
      }), d.d(l, "translate", function() {
        return p;
      }), d.d(l, "scale", function() {
        return G;
      }), d.d(l, "rotate", function() {
        return y;
      }), d.d(l, "rotateX", function() {
        return Z;
      }), d.d(l, "rotateY", function() {
        return X;
      }), d.d(l, "rotateZ", function() {
        return c;
      }), d.d(l, "fromTranslation", function() {
        return t;
      }), d.d(l, "fromScaling", function() {
        return R;
      }), d.d(l, "fromRotation", function() {
        return S;
      }), d.d(l, "fromXRotation", function() {
        return J;
      }), d.d(l, "fromYRotation", function() {
        return H;
      }), d.d(l, "fromZRotation", function() {
        return L;
      }), d.d(l, "fromRotationTranslation", function() {
        return C;
      }), d.d(l, "fromQuat2", function() {
        return F;
      }), d.d(l, "getTranslation", function() {
        return r;
      }), d.d(l, "getScaling", function() {
        return K;
      }), d.d(l, "getRotation", function() {
        return g;
      }), d.d(l, "fromRotationTranslationScale", function() {
        return v;
      }), d.d(l, "fromRotationTranslationScaleOrigin", function() {
        return f;
      }), d.d(l, "fromQuat", function() {
        return O;
      }), d.d(l, "frustum", function() {
        return q;
      }), d.d(l, "perspective", function() {
        return M;
      }), d.d(l, "perspectiveFromFieldOfView", function() {
        return P;
      }), d.d(l, "ortho", function() {
        return D;
      }), d.d(l, "lookAt", function() {
        return dd;
      }), d.d(l, "targetTo", function() {
        return _;
      }), d.d(l, "str", function() {
        return cd;
      }), d.d(l, "frob", function() {
        return $;
      }), d.d(l, "add", function() {
        return Wd;
      }), d.d(l, "subtract", function() {
        return Xd;
      }), d.d(l, "multiplyScalar", function() {
        return k;
      }), d.d(l, "multiplyScalarAndAdd", function() {
        return z;
      }), d.d(l, "exactEquals", function() {
        return E;
      }), d.d(l, "equals", function() {
        return j;
      }), d.d(l, "mul", function() {
        return N;
      }), d.d(l, "sub", function() {
        return Q;
      });
      var i = d(2);
      function b() {
        var u = new i.ARRAY_TYPE(16);
        return i.ARRAY_TYPE != Float32Array && (u[1] = 0, u[2] = 0, u[3] = 0, u[4] = 0, u[6] = 0, u[7] = 0, u[8] = 0, u[9] = 0, u[11] = 0, u[12] = 0, u[13] = 0, u[14] = 0), u[0] = 1, u[5] = 1, u[10] = 1, u[15] = 1, u;
      }
      function m(u) {
        var x = new i.ARRAY_TYPE(16);
        return x[0] = u[0], x[1] = u[1], x[2] = u[2], x[3] = u[3], x[4] = u[4], x[5] = u[5], x[6] = u[6], x[7] = u[7], x[8] = u[8], x[9] = u[9], x[10] = u[10], x[11] = u[11], x[12] = u[12], x[13] = u[13], x[14] = u[14], x[15] = u[15], x;
      }
      function o(u, x) {
        return u[0] = x[0], u[1] = x[1], u[2] = x[2], u[3] = x[3], u[4] = x[4], u[5] = x[5], u[6] = x[6], u[7] = x[7], u[8] = x[8], u[9] = x[9], u[10] = x[10], u[11] = x[11], u[12] = x[12], u[13] = x[13], u[14] = x[14], u[15] = x[15], u;
      }
      function n(u, x, T, U, w, B, A, ld, id, sd, td, Zd, bd, md, od, ed) {
        var nd = new i.ARRAY_TYPE(16);
        return nd[0] = u, nd[1] = x, nd[2] = T, nd[3] = U, nd[4] = w, nd[5] = B, nd[6] = A, nd[7] = ld, nd[8] = id, nd[9] = sd, nd[10] = td, nd[11] = Zd, nd[12] = bd, nd[13] = md, nd[14] = od, nd[15] = ed, nd;
      }
      function W(u, x, T, U, w, B, A, ld, id, sd, td, Zd, bd, md, od, ed, nd) {
        return u[0] = x, u[1] = T, u[2] = U, u[3] = w, u[4] = B, u[5] = A, u[6] = ld, u[7] = id, u[8] = sd, u[9] = td, u[10] = Zd, u[11] = bd, u[12] = md, u[13] = od, u[14] = ed, u[15] = nd, u;
      }
      function e(u) {
        return u[0] = 1, u[1] = 0, u[2] = 0, u[3] = 0, u[4] = 0, u[5] = 1, u[6] = 0, u[7] = 0, u[8] = 0, u[9] = 0, u[10] = 1, u[11] = 0, u[12] = 0, u[13] = 0, u[14] = 0, u[15] = 1, u;
      }
      function I(u, x) {
        if (u === x) {
          var T = x[1], U = x[2], w = x[3], B = x[6], A = x[7], ld = x[11];
          u[1] = x[4], u[2] = x[8], u[3] = x[12], u[4] = T, u[6] = x[9], u[7] = x[13], u[8] = U, u[9] = B, u[11] = x[14], u[12] = w, u[13] = A, u[14] = ld;
        } else
          u[0] = x[0], u[1] = x[4], u[2] = x[8], u[3] = x[12], u[4] = x[1], u[5] = x[5], u[6] = x[9], u[7] = x[13], u[8] = x[2], u[9] = x[6], u[10] = x[10], u[11] = x[14], u[12] = x[3], u[13] = x[7], u[14] = x[11], u[15] = x[15];
        return u;
      }
      function a(u, x) {
        var T = x[0], U = x[1], w = x[2], B = x[3], A = x[4], ld = x[5], id = x[6], sd = x[7], td = x[8], Zd = x[9], bd = x[10], md = x[11], od = x[12], ed = x[13], nd = x[14], hd = x[15], Sd = T * ld - U * A, Rd = T * id - w * A, xd = T * sd - B * A, Yd = U * id - w * ld, Kd = U * sd - B * ld, vd = w * sd - B * id, Md = td * ed - Zd * od, Ud = td * nd - bd * od, Qd = td * hd - md * od, Pd = Zd * nd - bd * ed, wd = Zd * hd - md * ed, Ed = bd * hd - md * nd, Cd = Sd * Ed - Rd * wd + xd * Pd + Yd * Qd - Kd * Ud + vd * Md;
        return Cd ? (Cd = 1 / Cd, u[0] = (ld * Ed - id * wd + sd * Pd) * Cd, u[1] = (w * wd - U * Ed - B * Pd) * Cd, u[2] = (ed * vd - nd * Kd + hd * Yd) * Cd, u[3] = (bd * Kd - Zd * vd - md * Yd) * Cd, u[4] = (id * Qd - A * Ed - sd * Ud) * Cd, u[5] = (T * Ed - w * Qd + B * Ud) * Cd, u[6] = (nd * xd - od * vd - hd * Rd) * Cd, u[7] = (td * vd - bd * xd + md * Rd) * Cd, u[8] = (A * wd - ld * Qd + sd * Md) * Cd, u[9] = (U * Qd - T * wd - B * Md) * Cd, u[10] = (od * Kd - ed * xd + hd * Sd) * Cd, u[11] = (Zd * xd - td * Kd - md * Sd) * Cd, u[12] = (ld * Ud - A * Pd - id * Md) * Cd, u[13] = (T * Pd - U * Ud + w * Md) * Cd, u[14] = (ed * Rd - od * Yd - nd * Sd) * Cd, u[15] = (td * Yd - Zd * Rd + bd * Sd) * Cd, u) : null;
      }
      function V(u, x) {
        var T = x[0], U = x[1], w = x[2], B = x[3], A = x[4], ld = x[5], id = x[6], sd = x[7], td = x[8], Zd = x[9], bd = x[10], md = x[11], od = x[12], ed = x[13], nd = x[14], hd = x[15];
        return u[0] = ld * (bd * hd - md * nd) - Zd * (id * hd - sd * nd) + ed * (id * md - sd * bd), u[1] = -(U * (bd * hd - md * nd) - Zd * (w * hd - B * nd) + ed * (w * md - B * bd)), u[2] = U * (id * hd - sd * nd) - ld * (w * hd - B * nd) + ed * (w * sd - B * id), u[3] = -(U * (id * md - sd * bd) - ld * (w * md - B * bd) + Zd * (w * sd - B * id)), u[4] = -(A * (bd * hd - md * nd) - td * (id * hd - sd * nd) + od * (id * md - sd * bd)), u[5] = T * (bd * hd - md * nd) - td * (w * hd - B * nd) + od * (w * md - B * bd), u[6] = -(T * (id * hd - sd * nd) - A * (w * hd - B * nd) + od * (w * sd - B * id)), u[7] = T * (id * md - sd * bd) - A * (w * md - B * bd) + td * (w * sd - B * id), u[8] = A * (Zd * hd - md * ed) - td * (ld * hd - sd * ed) + od * (ld * md - sd * Zd), u[9] = -(T * (Zd * hd - md * ed) - td * (U * hd - B * ed) + od * (U * md - B * Zd)), u[10] = T * (ld * hd - sd * ed) - A * (U * hd - B * ed) + od * (U * sd - B * ld), u[11] = -(T * (ld * md - sd * Zd) - A * (U * md - B * Zd) + td * (U * sd - B * ld)), u[12] = -(A * (Zd * nd - bd * ed) - td * (ld * nd - id * ed) + od * (ld * bd - id * Zd)), u[13] = T * (Zd * nd - bd * ed) - td * (U * nd - w * ed) + od * (U * bd - w * Zd), u[14] = -(T * (ld * nd - id * ed) - A * (U * nd - w * ed) + od * (U * id - w * ld)), u[15] = T * (ld * bd - id * Zd) - A * (U * bd - w * Zd) + td * (U * id - w * ld), u;
      }
      function h(u) {
        var x = u[0], T = u[1], U = u[2], w = u[3], B = u[4], A = u[5], ld = u[6], id = u[7], sd = u[8], td = u[9], Zd = u[10], bd = u[11], md = u[12], od = u[13], ed = u[14], nd = u[15], hd = x * A - T * B, Sd = x * ld - U * B, Rd = x * id - w * B, xd = T * ld - U * A, Yd = T * id - w * A, Kd = U * id - w * ld, vd = sd * od - td * md, Md = sd * ed - Zd * md, Ud = sd * nd - bd * md, Qd = td * ed - Zd * od, Pd = td * nd - bd * od, wd = Zd * nd - bd * ed;
        return hd * wd - Sd * Pd + Rd * Qd + xd * Ud - Yd * Md + Kd * vd;
      }
      function Y(u, x, T) {
        var U = x[0], w = x[1], B = x[2], A = x[3], ld = x[4], id = x[5], sd = x[6], td = x[7], Zd = x[8], bd = x[9], md = x[10], od = x[11], ed = x[12], nd = x[13], hd = x[14], Sd = x[15], Rd = T[0], xd = T[1], Yd = T[2], Kd = T[3];
        return u[0] = Rd * U + xd * ld + Yd * Zd + Kd * ed, u[1] = Rd * w + xd * id + Yd * bd + Kd * nd, u[2] = Rd * B + xd * sd + Yd * md + Kd * hd, u[3] = Rd * A + xd * td + Yd * od + Kd * Sd, Rd = T[4], xd = T[5], Yd = T[6], Kd = T[7], u[4] = Rd * U + xd * ld + Yd * Zd + Kd * ed, u[5] = Rd * w + xd * id + Yd * bd + Kd * nd, u[6] = Rd * B + xd * sd + Yd * md + Kd * hd, u[7] = Rd * A + xd * td + Yd * od + Kd * Sd, Rd = T[8], xd = T[9], Yd = T[10], Kd = T[11], u[8] = Rd * U + xd * ld + Yd * Zd + Kd * ed, u[9] = Rd * w + xd * id + Yd * bd + Kd * nd, u[10] = Rd * B + xd * sd + Yd * md + Kd * hd, u[11] = Rd * A + xd * td + Yd * od + Kd * Sd, Rd = T[12], xd = T[13], Yd = T[14], Kd = T[15], u[12] = Rd * U + xd * ld + Yd * Zd + Kd * ed, u[13] = Rd * w + xd * id + Yd * bd + Kd * nd, u[14] = Rd * B + xd * sd + Yd * md + Kd * hd, u[15] = Rd * A + xd * td + Yd * od + Kd * Sd, u;
      }
      function p(u, x, T) {
        var U = T[0], w = T[1], B = T[2], A, ld, id, sd, td, Zd, bd, md, od, ed, nd, hd;
        return x === u ? (u[12] = x[0] * U + x[4] * w + x[8] * B + x[12], u[13] = x[1] * U + x[5] * w + x[9] * B + x[13], u[14] = x[2] * U + x[6] * w + x[10] * B + x[14], u[15] = x[3] * U + x[7] * w + x[11] * B + x[15]) : (A = x[0], ld = x[1], id = x[2], sd = x[3], td = x[4], Zd = x[5], bd = x[6], md = x[7], od = x[8], ed = x[9], nd = x[10], hd = x[11], u[0] = A, u[1] = ld, u[2] = id, u[3] = sd, u[4] = td, u[5] = Zd, u[6] = bd, u[7] = md, u[8] = od, u[9] = ed, u[10] = nd, u[11] = hd, u[12] = A * U + td * w + od * B + x[12], u[13] = ld * U + Zd * w + ed * B + x[13], u[14] = id * U + bd * w + nd * B + x[14], u[15] = sd * U + md * w + hd * B + x[15]), u;
      }
      function G(u, x, T) {
        var U = T[0], w = T[1], B = T[2];
        return u[0] = x[0] * U, u[1] = x[1] * U, u[2] = x[2] * U, u[3] = x[3] * U, u[4] = x[4] * w, u[5] = x[5] * w, u[6] = x[6] * w, u[7] = x[7] * w, u[8] = x[8] * B, u[9] = x[9] * B, u[10] = x[10] * B, u[11] = x[11] * B, u[12] = x[12], u[13] = x[13], u[14] = x[14], u[15] = x[15], u;
      }
      function y(u, x, T, U) {
        var w = U[0], B = U[1], A = U[2], ld = Math.hypot(w, B, A), id, sd, td, Zd, bd, md, od, ed, nd, hd, Sd, Rd, xd, Yd, Kd, vd, Md, Ud, Qd, Pd, wd, Ed, Cd, Zl;
        return ld < i.EPSILON ? null : (ld = 1 / ld, w *= ld, B *= ld, A *= ld, id = Math.sin(T), sd = Math.cos(T), td = 1 - sd, Zd = x[0], bd = x[1], md = x[2], od = x[3], ed = x[4], nd = x[5], hd = x[6], Sd = x[7], Rd = x[8], xd = x[9], Yd = x[10], Kd = x[11], vd = w * w * td + sd, Md = B * w * td + A * id, Ud = A * w * td - B * id, Qd = w * B * td - A * id, Pd = B * B * td + sd, wd = A * B * td + w * id, Ed = w * A * td + B * id, Cd = B * A * td - w * id, Zl = A * A * td + sd, u[0] = Zd * vd + ed * Md + Rd * Ud, u[1] = bd * vd + nd * Md + xd * Ud, u[2] = md * vd + hd * Md + Yd * Ud, u[3] = od * vd + Sd * Md + Kd * Ud, u[4] = Zd * Qd + ed * Pd + Rd * wd, u[5] = bd * Qd + nd * Pd + xd * wd, u[6] = md * Qd + hd * Pd + Yd * wd, u[7] = od * Qd + Sd * Pd + Kd * wd, u[8] = Zd * Ed + ed * Cd + Rd * Zl, u[9] = bd * Ed + nd * Cd + xd * Zl, u[10] = md * Ed + hd * Cd + Yd * Zl, u[11] = od * Ed + Sd * Cd + Kd * Zl, x !== u && (u[12] = x[12], u[13] = x[13], u[14] = x[14], u[15] = x[15]), u);
      }
      function Z(u, x, T) {
        var U = Math.sin(T), w = Math.cos(T), B = x[4], A = x[5], ld = x[6], id = x[7], sd = x[8], td = x[9], Zd = x[10], bd = x[11];
        return x !== u && (u[0] = x[0], u[1] = x[1], u[2] = x[2], u[3] = x[3], u[12] = x[12], u[13] = x[13], u[14] = x[14], u[15] = x[15]), u[4] = B * w + sd * U, u[5] = A * w + td * U, u[6] = ld * w + Zd * U, u[7] = id * w + bd * U, u[8] = sd * w - B * U, u[9] = td * w - A * U, u[10] = Zd * w - ld * U, u[11] = bd * w - id * U, u;
      }
      function X(u, x, T) {
        var U = Math.sin(T), w = Math.cos(T), B = x[0], A = x[1], ld = x[2], id = x[3], sd = x[8], td = x[9], Zd = x[10], bd = x[11];
        return x !== u && (u[4] = x[4], u[5] = x[5], u[6] = x[6], u[7] = x[7], u[12] = x[12], u[13] = x[13], u[14] = x[14], u[15] = x[15]), u[0] = B * w - sd * U, u[1] = A * w - td * U, u[2] = ld * w - Zd * U, u[3] = id * w - bd * U, u[8] = B * U + sd * w, u[9] = A * U + td * w, u[10] = ld * U + Zd * w, u[11] = id * U + bd * w, u;
      }
      function c(u, x, T) {
        var U = Math.sin(T), w = Math.cos(T), B = x[0], A = x[1], ld = x[2], id = x[3], sd = x[4], td = x[5], Zd = x[6], bd = x[7];
        return x !== u && (u[8] = x[8], u[9] = x[9], u[10] = x[10], u[11] = x[11], u[12] = x[12], u[13] = x[13], u[14] = x[14], u[15] = x[15]), u[0] = B * w + sd * U, u[1] = A * w + td * U, u[2] = ld * w + Zd * U, u[3] = id * w + bd * U, u[4] = sd * w - B * U, u[5] = td * w - A * U, u[6] = Zd * w - ld * U, u[7] = bd * w - id * U, u;
      }
      function t(u, x) {
        return u[0] = 1, u[1] = 0, u[2] = 0, u[3] = 0, u[4] = 0, u[5] = 1, u[6] = 0, u[7] = 0, u[8] = 0, u[9] = 0, u[10] = 1, u[11] = 0, u[12] = x[0], u[13] = x[1], u[14] = x[2], u[15] = 1, u;
      }
      function R(u, x) {
        return u[0] = x[0], u[1] = 0, u[2] = 0, u[3] = 0, u[4] = 0, u[5] = x[1], u[6] = 0, u[7] = 0, u[8] = 0, u[9] = 0, u[10] = x[2], u[11] = 0, u[12] = 0, u[13] = 0, u[14] = 0, u[15] = 1, u;
      }
      function S(u, x, T) {
        var U = T[0], w = T[1], B = T[2], A = Math.hypot(U, w, B), ld, id, sd;
        return A < i.EPSILON ? null : (A = 1 / A, U *= A, w *= A, B *= A, ld = Math.sin(x), id = Math.cos(x), sd = 1 - id, u[0] = U * U * sd + id, u[1] = w * U * sd + B * ld, u[2] = B * U * sd - w * ld, u[3] = 0, u[4] = U * w * sd - B * ld, u[5] = w * w * sd + id, u[6] = B * w * sd + U * ld, u[7] = 0, u[8] = U * B * sd + w * ld, u[9] = w * B * sd - U * ld, u[10] = B * B * sd + id, u[11] = 0, u[12] = 0, u[13] = 0, u[14] = 0, u[15] = 1, u);
      }
      function J(u, x) {
        var T = Math.sin(x), U = Math.cos(x);
        return u[0] = 1, u[1] = 0, u[2] = 0, u[3] = 0, u[4] = 0, u[5] = U, u[6] = T, u[7] = 0, u[8] = 0, u[9] = -T, u[10] = U, u[11] = 0, u[12] = 0, u[13] = 0, u[14] = 0, u[15] = 1, u;
      }
      function H(u, x) {
        var T = Math.sin(x), U = Math.cos(x);
        return u[0] = U, u[1] = 0, u[2] = -T, u[3] = 0, u[4] = 0, u[5] = 1, u[6] = 0, u[7] = 0, u[8] = T, u[9] = 0, u[10] = U, u[11] = 0, u[12] = 0, u[13] = 0, u[14] = 0, u[15] = 1, u;
      }
      function L(u, x) {
        var T = Math.sin(x), U = Math.cos(x);
        return u[0] = U, u[1] = T, u[2] = 0, u[3] = 0, u[4] = -T, u[5] = U, u[6] = 0, u[7] = 0, u[8] = 0, u[9] = 0, u[10] = 1, u[11] = 0, u[12] = 0, u[13] = 0, u[14] = 0, u[15] = 1, u;
      }
      function C(u, x, T) {
        var U = x[0], w = x[1], B = x[2], A = x[3], ld = U + U, id = w + w, sd = B + B, td = U * ld, Zd = U * id, bd = U * sd, md = w * id, od = w * sd, ed = B * sd, nd = A * ld, hd = A * id, Sd = A * sd;
        return u[0] = 1 - (md + ed), u[1] = Zd + Sd, u[2] = bd - hd, u[3] = 0, u[4] = Zd - Sd, u[5] = 1 - (td + ed), u[6] = od + nd, u[7] = 0, u[8] = bd + hd, u[9] = od - nd, u[10] = 1 - (td + md), u[11] = 0, u[12] = T[0], u[13] = T[1], u[14] = T[2], u[15] = 1, u;
      }
      function F(u, x) {
        var T = new i.ARRAY_TYPE(3), U = -x[0], w = -x[1], B = -x[2], A = x[3], ld = x[4], id = x[5], sd = x[6], td = x[7], Zd = U * U + w * w + B * B + A * A;
        return Zd > 0 ? (T[0] = (ld * A + td * U + id * B - sd * w) * 2 / Zd, T[1] = (id * A + td * w + sd * U - ld * B) * 2 / Zd, T[2] = (sd * A + td * B + ld * w - id * U) * 2 / Zd) : (T[0] = (ld * A + td * U + id * B - sd * w) * 2, T[1] = (id * A + td * w + sd * U - ld * B) * 2, T[2] = (sd * A + td * B + ld * w - id * U) * 2), C(u, x, T), u;
      }
      function r(u, x) {
        return u[0] = x[12], u[1] = x[13], u[2] = x[14], u;
      }
      function K(u, x) {
        var T = x[0], U = x[1], w = x[2], B = x[4], A = x[5], ld = x[6], id = x[8], sd = x[9], td = x[10];
        return u[0] = Math.hypot(T, U, w), u[1] = Math.hypot(B, A, ld), u[2] = Math.hypot(id, sd, td), u;
      }
      function g(u, x) {
        var T = new i.ARRAY_TYPE(3);
        K(T, x);
        var U = 1 / T[0], w = 1 / T[1], B = 1 / T[2], A = x[0] * U, ld = x[1] * w, id = x[2] * B, sd = x[4] * U, td = x[5] * w, Zd = x[6] * B, bd = x[8] * U, md = x[9] * w, od = x[10] * B, ed = A + td + od, nd = 0;
        return ed > 0 ? (nd = Math.sqrt(ed + 1) * 2, u[3] = 0.25 * nd, u[0] = (Zd - md) / nd, u[1] = (bd - id) / nd, u[2] = (ld - sd) / nd) : A > td && A > od ? (nd = Math.sqrt(1 + A - td - od) * 2, u[3] = (Zd - md) / nd, u[0] = 0.25 * nd, u[1] = (ld + sd) / nd, u[2] = (bd + id) / nd) : td > od ? (nd = Math.sqrt(1 + td - A - od) * 2, u[3] = (bd - id) / nd, u[0] = (ld + sd) / nd, u[1] = 0.25 * nd, u[2] = (Zd + md) / nd) : (nd = Math.sqrt(1 + od - A - td) * 2, u[3] = (ld - sd) / nd, u[0] = (bd + id) / nd, u[1] = (Zd + md) / nd, u[2] = 0.25 * nd), u;
      }
      function v(u, x, T, U) {
        var w = x[0], B = x[1], A = x[2], ld = x[3], id = w + w, sd = B + B, td = A + A, Zd = w * id, bd = w * sd, md = w * td, od = B * sd, ed = B * td, nd = A * td, hd = ld * id, Sd = ld * sd, Rd = ld * td, xd = U[0], Yd = U[1], Kd = U[2];
        return u[0] = (1 - (od + nd)) * xd, u[1] = (bd + Rd) * xd, u[2] = (md - Sd) * xd, u[3] = 0, u[4] = (bd - Rd) * Yd, u[5] = (1 - (Zd + nd)) * Yd, u[6] = (ed + hd) * Yd, u[7] = 0, u[8] = (md + Sd) * Kd, u[9] = (ed - hd) * Kd, u[10] = (1 - (Zd + od)) * Kd, u[11] = 0, u[12] = T[0], u[13] = T[1], u[14] = T[2], u[15] = 1, u;
      }
      function f(u, x, T, U, w) {
        var B = x[0], A = x[1], ld = x[2], id = x[3], sd = B + B, td = A + A, Zd = ld + ld, bd = B * sd, md = B * td, od = B * Zd, ed = A * td, nd = A * Zd, hd = ld * Zd, Sd = id * sd, Rd = id * td, xd = id * Zd, Yd = U[0], Kd = U[1], vd = U[2], Md = w[0], Ud = w[1], Qd = w[2], Pd = (1 - (ed + hd)) * Yd, wd = (md + xd) * Yd, Ed = (od - Rd) * Yd, Cd = (md - xd) * Kd, Zl = (1 - (bd + hd)) * Kd, Ml = (nd + Sd) * Kd, Ul = (od + Rd) * vd, Ui = (nd - Sd) * vd, Qi = (1 - (bd + ed)) * vd;
        return u[0] = Pd, u[1] = wd, u[2] = Ed, u[3] = 0, u[4] = Cd, u[5] = Zl, u[6] = Ml, u[7] = 0, u[8] = Ul, u[9] = Ui, u[10] = Qi, u[11] = 0, u[12] = T[0] + Md - (Pd * Md + Cd * Ud + Ul * Qd), u[13] = T[1] + Ud - (wd * Md + Zl * Ud + Ui * Qd), u[14] = T[2] + Qd - (Ed * Md + Ml * Ud + Qi * Qd), u[15] = 1, u;
      }
      function O(u, x) {
        var T = x[0], U = x[1], w = x[2], B = x[3], A = T + T, ld = U + U, id = w + w, sd = T * A, td = U * A, Zd = U * ld, bd = w * A, md = w * ld, od = w * id, ed = B * A, nd = B * ld, hd = B * id;
        return u[0] = 1 - Zd - od, u[1] = td + hd, u[2] = bd - nd, u[3] = 0, u[4] = td - hd, u[5] = 1 - sd - od, u[6] = md + ed, u[7] = 0, u[8] = bd + nd, u[9] = md - ed, u[10] = 1 - sd - Zd, u[11] = 0, u[12] = 0, u[13] = 0, u[14] = 0, u[15] = 1, u;
      }
      function q(u, x, T, U, w, B, A) {
        var ld = 1 / (T - x), id = 1 / (w - U), sd = 1 / (B - A);
        return u[0] = B * 2 * ld, u[1] = 0, u[2] = 0, u[3] = 0, u[4] = 0, u[5] = B * 2 * id, u[6] = 0, u[7] = 0, u[8] = (T + x) * ld, u[9] = (w + U) * id, u[10] = (A + B) * sd, u[11] = -1, u[12] = 0, u[13] = 0, u[14] = A * B * 2 * sd, u[15] = 0, u;
      }
      function M(u, x, T, U, w) {
        var B = 1 / Math.tan(x / 2), A;
        return u[0] = B / T, u[1] = 0, u[2] = 0, u[3] = 0, u[4] = 0, u[5] = B, u[6] = 0, u[7] = 0, u[8] = 0, u[9] = 0, u[11] = -1, u[12] = 0, u[13] = 0, u[15] = 0, w != null && w !== 1 / 0 ? (A = 1 / (U - w), u[10] = (w + U) * A, u[14] = 2 * w * U * A) : (u[10] = -1, u[14] = -2 * U), u;
      }
      function P(u, x, T, U) {
        var w = Math.tan(x.upDegrees * Math.PI / 180), B = Math.tan(x.downDegrees * Math.PI / 180), A = Math.tan(x.leftDegrees * Math.PI / 180), ld = Math.tan(x.rightDegrees * Math.PI / 180), id = 2 / (A + ld), sd = 2 / (w + B);
        return u[0] = id, u[1] = 0, u[2] = 0, u[3] = 0, u[4] = 0, u[5] = sd, u[6] = 0, u[7] = 0, u[8] = -((A - ld) * id * 0.5), u[9] = (w - B) * sd * 0.5, u[10] = U / (T - U), u[11] = -1, u[12] = 0, u[13] = 0, u[14] = U * T / (T - U), u[15] = 0, u;
      }
      function D(u, x, T, U, w, B, A) {
        var ld = 1 / (x - T), id = 1 / (U - w), sd = 1 / (B - A);
        return u[0] = -2 * ld, u[1] = 0, u[2] = 0, u[3] = 0, u[4] = 0, u[5] = -2 * id, u[6] = 0, u[7] = 0, u[8] = 0, u[9] = 0, u[10] = 2 * sd, u[11] = 0, u[12] = (x + T) * ld, u[13] = (w + U) * id, u[14] = (A + B) * sd, u[15] = 1, u;
      }
      function dd(u, x, T, U) {
        var w, B, A, ld, id, sd, td, Zd, bd, md, od = x[0], ed = x[1], nd = x[2], hd = U[0], Sd = U[1], Rd = U[2], xd = T[0], Yd = T[1], Kd = T[2];
        return Math.abs(od - xd) < i.EPSILON && Math.abs(ed - Yd) < i.EPSILON && Math.abs(nd - Kd) < i.EPSILON ? e(u) : (td = od - xd, Zd = ed - Yd, bd = nd - Kd, md = 1 / Math.hypot(td, Zd, bd), td *= md, Zd *= md, bd *= md, w = Sd * bd - Rd * Zd, B = Rd * td - hd * bd, A = hd * Zd - Sd * td, md = Math.hypot(w, B, A), md ? (md = 1 / md, w *= md, B *= md, A *= md) : (w = 0, B = 0, A = 0), ld = Zd * A - bd * B, id = bd * w - td * A, sd = td * B - Zd * w, md = Math.hypot(ld, id, sd), md ? (md = 1 / md, ld *= md, id *= md, sd *= md) : (ld = 0, id = 0, sd = 0), u[0] = w, u[1] = ld, u[2] = td, u[3] = 0, u[4] = B, u[5] = id, u[6] = Zd, u[7] = 0, u[8] = A, u[9] = sd, u[10] = bd, u[11] = 0, u[12] = -(w * od + B * ed + A * nd), u[13] = -(ld * od + id * ed + sd * nd), u[14] = -(td * od + Zd * ed + bd * nd), u[15] = 1, u);
      }
      function _(u, x, T, U) {
        var w = x[0], B = x[1], A = x[2], ld = U[0], id = U[1], sd = U[2], td = w - T[0], Zd = B - T[1], bd = A - T[2], md = td * td + Zd * Zd + bd * bd;
        md > 0 && (md = 1 / Math.sqrt(md), td *= md, Zd *= md, bd *= md);
        var od = id * bd - sd * Zd, ed = sd * td - ld * bd, nd = ld * Zd - id * td;
        return md = od * od + ed * ed + nd * nd, md > 0 && (md = 1 / Math.sqrt(md), od *= md, ed *= md, nd *= md), u[0] = od, u[1] = ed, u[2] = nd, u[3] = 0, u[4] = Zd * nd - bd * ed, u[5] = bd * od - td * nd, u[6] = td * ed - Zd * od, u[7] = 0, u[8] = td, u[9] = Zd, u[10] = bd, u[11] = 0, u[12] = w, u[13] = B, u[14] = A, u[15] = 1, u;
      }
      function cd(u) {
        return "mat4(" + u[0] + ", " + u[1] + ", " + u[2] + ", " + u[3] + ", " + u[4] + ", " + u[5] + ", " + u[6] + ", " + u[7] + ", " + u[8] + ", " + u[9] + ", " + u[10] + ", " + u[11] + ", " + u[12] + ", " + u[13] + ", " + u[14] + ", " + u[15] + ")";
      }
      function $(u) {
        return Math.hypot(u[0], u[1], u[2], u[3], u[4], u[5], u[6], u[7], u[8], u[9], u[10], u[11], u[12], u[13], u[14], u[15]);
      }
      function Wd(u, x, T) {
        return u[0] = x[0] + T[0], u[1] = x[1] + T[1], u[2] = x[2] + T[2], u[3] = x[3] + T[3], u[4] = x[4] + T[4], u[5] = x[5] + T[5], u[6] = x[6] + T[6], u[7] = x[7] + T[7], u[8] = x[8] + T[8], u[9] = x[9] + T[9], u[10] = x[10] + T[10], u[11] = x[11] + T[11], u[12] = x[12] + T[12], u[13] = x[13] + T[13], u[14] = x[14] + T[14], u[15] = x[15] + T[15], u;
      }
      function Xd(u, x, T) {
        return u[0] = x[0] - T[0], u[1] = x[1] - T[1], u[2] = x[2] - T[2], u[3] = x[3] - T[3], u[4] = x[4] - T[4], u[5] = x[5] - T[5], u[6] = x[6] - T[6], u[7] = x[7] - T[7], u[8] = x[8] - T[8], u[9] = x[9] - T[9], u[10] = x[10] - T[10], u[11] = x[11] - T[11], u[12] = x[12] - T[12], u[13] = x[13] - T[13], u[14] = x[14] - T[14], u[15] = x[15] - T[15], u;
      }
      function k(u, x, T) {
        return u[0] = x[0] * T, u[1] = x[1] * T, u[2] = x[2] * T, u[3] = x[3] * T, u[4] = x[4] * T, u[5] = x[5] * T, u[6] = x[6] * T, u[7] = x[7] * T, u[8] = x[8] * T, u[9] = x[9] * T, u[10] = x[10] * T, u[11] = x[11] * T, u[12] = x[12] * T, u[13] = x[13] * T, u[14] = x[14] * T, u[15] = x[15] * T, u;
      }
      function z(u, x, T, U) {
        return u[0] = x[0] + T[0] * U, u[1] = x[1] + T[1] * U, u[2] = x[2] + T[2] * U, u[3] = x[3] + T[3] * U, u[4] = x[4] + T[4] * U, u[5] = x[5] + T[5] * U, u[6] = x[6] + T[6] * U, u[7] = x[7] + T[7] * U, u[8] = x[8] + T[8] * U, u[9] = x[9] + T[9] * U, u[10] = x[10] + T[10] * U, u[11] = x[11] + T[11] * U, u[12] = x[12] + T[12] * U, u[13] = x[13] + T[13] * U, u[14] = x[14] + T[14] * U, u[15] = x[15] + T[15] * U, u;
      }
      function E(u, x) {
        return u[0] === x[0] && u[1] === x[1] && u[2] === x[2] && u[3] === x[3] && u[4] === x[4] && u[5] === x[5] && u[6] === x[6] && u[7] === x[7] && u[8] === x[8] && u[9] === x[9] && u[10] === x[10] && u[11] === x[11] && u[12] === x[12] && u[13] === x[13] && u[14] === x[14] && u[15] === x[15];
      }
      function j(u, x) {
        var T = u[0], U = u[1], w = u[2], B = u[3], A = u[4], ld = u[5], id = u[6], sd = u[7], td = u[8], Zd = u[9], bd = u[10], md = u[11], od = u[12], ed = u[13], nd = u[14], hd = u[15], Sd = x[0], Rd = x[1], xd = x[2], Yd = x[3], Kd = x[4], vd = x[5], Md = x[6], Ud = x[7], Qd = x[8], Pd = x[9], wd = x[10], Ed = x[11], Cd = x[12], Zl = x[13], Ml = x[14], Ul = x[15];
        return Math.abs(T - Sd) <= i.EPSILON * Math.max(1, Math.abs(T), Math.abs(Sd)) && Math.abs(U - Rd) <= i.EPSILON * Math.max(1, Math.abs(U), Math.abs(Rd)) && Math.abs(w - xd) <= i.EPSILON * Math.max(1, Math.abs(w), Math.abs(xd)) && Math.abs(B - Yd) <= i.EPSILON * Math.max(1, Math.abs(B), Math.abs(Yd)) && Math.abs(A - Kd) <= i.EPSILON * Math.max(1, Math.abs(A), Math.abs(Kd)) && Math.abs(ld - vd) <= i.EPSILON * Math.max(1, Math.abs(ld), Math.abs(vd)) && Math.abs(id - Md) <= i.EPSILON * Math.max(1, Math.abs(id), Math.abs(Md)) && Math.abs(sd - Ud) <= i.EPSILON * Math.max(1, Math.abs(sd), Math.abs(Ud)) && Math.abs(td - Qd) <= i.EPSILON * Math.max(1, Math.abs(td), Math.abs(Qd)) && Math.abs(Zd - Pd) <= i.EPSILON * Math.max(1, Math.abs(Zd), Math.abs(Pd)) && Math.abs(bd - wd) <= i.EPSILON * Math.max(1, Math.abs(bd), Math.abs(wd)) && Math.abs(md - Ed) <= i.EPSILON * Math.max(1, Math.abs(md), Math.abs(Ed)) && Math.abs(od - Cd) <= i.EPSILON * Math.max(1, Math.abs(od), Math.abs(Cd)) && Math.abs(ed - Zl) <= i.EPSILON * Math.max(1, Math.abs(ed), Math.abs(Zl)) && Math.abs(nd - Ml) <= i.EPSILON * Math.max(1, Math.abs(nd), Math.abs(Ml)) && Math.abs(hd - Ul) <= i.EPSILON * Math.max(1, Math.abs(hd), Math.abs(Ul));
      }
      var N = Y, Q = Xd;
    },
    /* 7 */
    /***/
    function(s, l, d) {
      d.r(l), d.d(l, "create", function() {
        return n;
      }), d.d(l, "identity", function() {
        return W;
      }), d.d(l, "setAxisAngle", function() {
        return e;
      }), d.d(l, "getAxisAngle", function() {
        return I;
      }), d.d(l, "getAngle", function() {
        return a;
      }), d.d(l, "multiply", function() {
        return V;
      }), d.d(l, "rotateX", function() {
        return h;
      }), d.d(l, "rotateY", function() {
        return Y;
      }), d.d(l, "rotateZ", function() {
        return p;
      }), d.d(l, "calculateW", function() {
        return G;
      }), d.d(l, "exp", function() {
        return y;
      }), d.d(l, "ln", function() {
        return Z;
      }), d.d(l, "pow", function() {
        return X;
      }), d.d(l, "slerp", function() {
        return c;
      }), d.d(l, "random", function() {
        return t;
      }), d.d(l, "invert", function() {
        return R;
      }), d.d(l, "conjugate", function() {
        return S;
      }), d.d(l, "fromMat3", function() {
        return J;
      }), d.d(l, "fromEuler", function() {
        return H;
      }), d.d(l, "str", function() {
        return L;
      }), d.d(l, "clone", function() {
        return C;
      }), d.d(l, "fromValues", function() {
        return F;
      }), d.d(l, "copy", function() {
        return r;
      }), d.d(l, "set", function() {
        return K;
      }), d.d(l, "add", function() {
        return g;
      }), d.d(l, "mul", function() {
        return v;
      }), d.d(l, "scale", function() {
        return f;
      }), d.d(l, "dot", function() {
        return O;
      }), d.d(l, "lerp", function() {
        return q;
      }), d.d(l, "length", function() {
        return M;
      }), d.d(l, "len", function() {
        return P;
      }), d.d(l, "squaredLength", function() {
        return D;
      }), d.d(l, "sqrLen", function() {
        return dd;
      }), d.d(l, "normalize", function() {
        return _;
      }), d.d(l, "exactEquals", function() {
        return cd;
      }), d.d(l, "equals", function() {
        return $;
      }), d.d(l, "rotationTo", function() {
        return Wd;
      }), d.d(l, "sqlerp", function() {
        return Xd;
      }), d.d(l, "setAxes", function() {
        return k;
      });
      var i = d(2), b = d(5), m = d(8), o = d(9);
      function n() {
        var z = new i.ARRAY_TYPE(4);
        return i.ARRAY_TYPE != Float32Array && (z[0] = 0, z[1] = 0, z[2] = 0), z[3] = 1, z;
      }
      function W(z) {
        return z[0] = 0, z[1] = 0, z[2] = 0, z[3] = 1, z;
      }
      function e(z, E, j) {
        j = j * 0.5;
        var N = Math.sin(j);
        return z[0] = N * E[0], z[1] = N * E[1], z[2] = N * E[2], z[3] = Math.cos(j), z;
      }
      function I(z, E) {
        var j = Math.acos(E[3]) * 2, N = Math.sin(j / 2);
        return N > i.EPSILON ? (z[0] = E[0] / N, z[1] = E[1] / N, z[2] = E[2] / N) : (z[0] = 1, z[1] = 0, z[2] = 0), j;
      }
      function a(z, E) {
        var j = O(z, E);
        return Math.acos(2 * j * j - 1);
      }
      function V(z, E, j) {
        var N = E[0], Q = E[1], u = E[2], x = E[3], T = j[0], U = j[1], w = j[2], B = j[3];
        return z[0] = N * B + x * T + Q * w - u * U, z[1] = Q * B + x * U + u * T - N * w, z[2] = u * B + x * w + N * U - Q * T, z[3] = x * B - N * T - Q * U - u * w, z;
      }
      function h(z, E, j) {
        j *= 0.5;
        var N = E[0], Q = E[1], u = E[2], x = E[3], T = Math.sin(j), U = Math.cos(j);
        return z[0] = N * U + x * T, z[1] = Q * U + u * T, z[2] = u * U - Q * T, z[3] = x * U - N * T, z;
      }
      function Y(z, E, j) {
        j *= 0.5;
        var N = E[0], Q = E[1], u = E[2], x = E[3], T = Math.sin(j), U = Math.cos(j);
        return z[0] = N * U - u * T, z[1] = Q * U + x * T, z[2] = u * U + N * T, z[3] = x * U - Q * T, z;
      }
      function p(z, E, j) {
        j *= 0.5;
        var N = E[0], Q = E[1], u = E[2], x = E[3], T = Math.sin(j), U = Math.cos(j);
        return z[0] = N * U + Q * T, z[1] = Q * U - N * T, z[2] = u * U + x * T, z[3] = x * U - u * T, z;
      }
      function G(z, E) {
        var j = E[0], N = E[1], Q = E[2];
        return z[0] = j, z[1] = N, z[2] = Q, z[3] = Math.sqrt(Math.abs(1 - j * j - N * N - Q * Q)), z;
      }
      function y(z, E) {
        var j = E[0], N = E[1], Q = E[2], u = E[3], x = Math.sqrt(j * j + N * N + Q * Q), T = Math.exp(u), U = x > 0 ? T * Math.sin(x) / x : 0;
        return z[0] = j * U, z[1] = N * U, z[2] = Q * U, z[3] = T * Math.cos(x), z;
      }
      function Z(z, E) {
        var j = E[0], N = E[1], Q = E[2], u = E[3], x = Math.sqrt(j * j + N * N + Q * Q), T = x > 0 ? Math.atan2(x, u) / x : 0;
        return z[0] = j * T, z[1] = N * T, z[2] = Q * T, z[3] = 0.5 * Math.log(j * j + N * N + Q * Q + u * u), z;
      }
      function X(z, E, j) {
        return Z(z, E), f(z, z, j), y(z, z), z;
      }
      function c(z, E, j, N) {
        var Q = E[0], u = E[1], x = E[2], T = E[3], U = j[0], w = j[1], B = j[2], A = j[3], ld, id, sd, td, Zd;
        return id = Q * U + u * w + x * B + T * A, id < 0 && (id = -id, U = -U, w = -w, B = -B, A = -A), 1 - id > i.EPSILON ? (ld = Math.acos(id), sd = Math.sin(ld), td = Math.sin((1 - N) * ld) / sd, Zd = Math.sin(N * ld) / sd) : (td = 1 - N, Zd = N), z[0] = td * Q + Zd * U, z[1] = td * u + Zd * w, z[2] = td * x + Zd * B, z[3] = td * T + Zd * A, z;
      }
      function t(z) {
        var E = i.RANDOM(), j = i.RANDOM(), N = i.RANDOM(), Q = Math.sqrt(1 - E), u = Math.sqrt(E);
        return z[0] = Q * Math.sin(2 * Math.PI * j), z[1] = Q * Math.cos(2 * Math.PI * j), z[2] = u * Math.sin(2 * Math.PI * N), z[3] = u * Math.cos(2 * Math.PI * N), z;
      }
      function R(z, E) {
        var j = E[0], N = E[1], Q = E[2], u = E[3], x = j * j + N * N + Q * Q + u * u, T = x ? 1 / x : 0;
        return z[0] = -j * T, z[1] = -N * T, z[2] = -Q * T, z[3] = u * T, z;
      }
      function S(z, E) {
        return z[0] = -E[0], z[1] = -E[1], z[2] = -E[2], z[3] = E[3], z;
      }
      function J(z, E) {
        var j = E[0] + E[4] + E[8], N;
        if (j > 0)
          N = Math.sqrt(j + 1), z[3] = 0.5 * N, N = 0.5 / N, z[0] = (E[5] - E[7]) * N, z[1] = (E[6] - E[2]) * N, z[2] = (E[1] - E[3]) * N;
        else {
          var Q = 0;
          E[4] > E[0] && (Q = 1), E[8] > E[Q * 3 + Q] && (Q = 2);
          var u = (Q + 1) % 3, x = (Q + 2) % 3;
          N = Math.sqrt(E[Q * 3 + Q] - E[u * 3 + u] - E[x * 3 + x] + 1), z[Q] = 0.5 * N, N = 0.5 / N, z[3] = (E[u * 3 + x] - E[x * 3 + u]) * N, z[u] = (E[u * 3 + Q] + E[Q * 3 + u]) * N, z[x] = (E[x * 3 + Q] + E[Q * 3 + x]) * N;
        }
        return z;
      }
      function H(z, E, j, N) {
        var Q = 0.5 * Math.PI / 180;
        E *= Q, j *= Q, N *= Q;
        var u = Math.sin(E), x = Math.cos(E), T = Math.sin(j), U = Math.cos(j), w = Math.sin(N), B = Math.cos(N);
        return z[0] = u * U * B - x * T * w, z[1] = x * T * B + u * U * w, z[2] = x * U * w - u * T * B, z[3] = x * U * B + u * T * w, z;
      }
      function L(z) {
        return "quat(" + z[0] + ", " + z[1] + ", " + z[2] + ", " + z[3] + ")";
      }
      var C = o.clone, F = o.fromValues, r = o.copy, K = o.set, g = o.add, v = V, f = o.scale, O = o.dot, q = o.lerp, M = o.length, P = M, D = o.squaredLength, dd = D, _ = o.normalize, cd = o.exactEquals, $ = o.equals, Wd = function() {
        var z = m.create(), E = m.fromValues(1, 0, 0), j = m.fromValues(0, 1, 0);
        return function(N, Q, u) {
          var x = m.dot(Q, u);
          return x < -0.999999 ? (m.cross(z, E, Q), m.len(z) < 1e-6 && m.cross(z, j, Q), m.normalize(z, z), e(N, z, Math.PI), N) : x > 0.999999 ? (N[0] = 0, N[1] = 0, N[2] = 0, N[3] = 1, N) : (m.cross(z, Q, u), N[0] = z[0], N[1] = z[1], N[2] = z[2], N[3] = 1 + x, _(N, N));
        };
      }(), Xd = function() {
        var z = n(), E = n();
        return function(j, N, Q, u, x, T) {
          return c(z, N, x, T), c(E, Q, u, T), c(j, z, E, 2 * T * (1 - T)), j;
        };
      }(), k = function() {
        var z = b.create();
        return function(E, j, N, Q) {
          return z[0] = N[0], z[3] = N[1], z[6] = N[2], z[1] = Q[0], z[4] = Q[1], z[7] = Q[2], z[2] = -j[0], z[5] = -j[1], z[8] = -j[2], _(E, J(E, z));
        };
      }();
    },
    /* 8 */
    /***/
    function(s, l, d) {
      d.r(l), d.d(l, "create", function() {
        return b;
      }), d.d(l, "clone", function() {
        return m;
      }), d.d(l, "length", function() {
        return o;
      }), d.d(l, "fromValues", function() {
        return n;
      }), d.d(l, "copy", function() {
        return W;
      }), d.d(l, "set", function() {
        return e;
      }), d.d(l, "add", function() {
        return I;
      }), d.d(l, "subtract", function() {
        return a;
      }), d.d(l, "multiply", function() {
        return V;
      }), d.d(l, "divide", function() {
        return h;
      }), d.d(l, "ceil", function() {
        return Y;
      }), d.d(l, "floor", function() {
        return p;
      }), d.d(l, "min", function() {
        return G;
      }), d.d(l, "max", function() {
        return y;
      }), d.d(l, "round", function() {
        return Z;
      }), d.d(l, "scale", function() {
        return X;
      }), d.d(l, "scaleAndAdd", function() {
        return c;
      }), d.d(l, "distance", function() {
        return t;
      }), d.d(l, "squaredDistance", function() {
        return R;
      }), d.d(l, "squaredLength", function() {
        return S;
      }), d.d(l, "negate", function() {
        return J;
      }), d.d(l, "inverse", function() {
        return H;
      }), d.d(l, "normalize", function() {
        return L;
      }), d.d(l, "dot", function() {
        return C;
      }), d.d(l, "cross", function() {
        return F;
      }), d.d(l, "lerp", function() {
        return r;
      }), d.d(l, "hermite", function() {
        return K;
      }), d.d(l, "bezier", function() {
        return g;
      }), d.d(l, "random", function() {
        return v;
      }), d.d(l, "transformMat4", function() {
        return f;
      }), d.d(l, "transformMat3", function() {
        return O;
      }), d.d(l, "transformQuat", function() {
        return q;
      }), d.d(l, "rotateX", function() {
        return M;
      }), d.d(l, "rotateY", function() {
        return P;
      }), d.d(l, "rotateZ", function() {
        return D;
      }), d.d(l, "angle", function() {
        return dd;
      }), d.d(l, "zero", function() {
        return _;
      }), d.d(l, "str", function() {
        return cd;
      }), d.d(l, "exactEquals", function() {
        return $;
      }), d.d(l, "equals", function() {
        return Wd;
      }), d.d(l, "sub", function() {
        return Xd;
      }), d.d(l, "mul", function() {
        return k;
      }), d.d(l, "div", function() {
        return z;
      }), d.d(l, "dist", function() {
        return E;
      }), d.d(l, "sqrDist", function() {
        return j;
      }), d.d(l, "len", function() {
        return N;
      }), d.d(l, "sqrLen", function() {
        return Q;
      }), d.d(l, "forEach", function() {
        return u;
      });
      var i = d(2);
      function b() {
        var x = new i.ARRAY_TYPE(3);
        return i.ARRAY_TYPE != Float32Array && (x[0] = 0, x[1] = 0, x[2] = 0), x;
      }
      function m(x) {
        var T = new i.ARRAY_TYPE(3);
        return T[0] = x[0], T[1] = x[1], T[2] = x[2], T;
      }
      function o(x) {
        var T = x[0], U = x[1], w = x[2];
        return Math.hypot(T, U, w);
      }
      function n(x, T, U) {
        var w = new i.ARRAY_TYPE(3);
        return w[0] = x, w[1] = T, w[2] = U, w;
      }
      function W(x, T) {
        return x[0] = T[0], x[1] = T[1], x[2] = T[2], x;
      }
      function e(x, T, U, w) {
        return x[0] = T, x[1] = U, x[2] = w, x;
      }
      function I(x, T, U) {
        return x[0] = T[0] + U[0], x[1] = T[1] + U[1], x[2] = T[2] + U[2], x;
      }
      function a(x, T, U) {
        return x[0] = T[0] - U[0], x[1] = T[1] - U[1], x[2] = T[2] - U[2], x;
      }
      function V(x, T, U) {
        return x[0] = T[0] * U[0], x[1] = T[1] * U[1], x[2] = T[2] * U[2], x;
      }
      function h(x, T, U) {
        return x[0] = T[0] / U[0], x[1] = T[1] / U[1], x[2] = T[2] / U[2], x;
      }
      function Y(x, T) {
        return x[0] = Math.ceil(T[0]), x[1] = Math.ceil(T[1]), x[2] = Math.ceil(T[2]), x;
      }
      function p(x, T) {
        return x[0] = Math.floor(T[0]), x[1] = Math.floor(T[1]), x[2] = Math.floor(T[2]), x;
      }
      function G(x, T, U) {
        return x[0] = Math.min(T[0], U[0]), x[1] = Math.min(T[1], U[1]), x[2] = Math.min(T[2], U[2]), x;
      }
      function y(x, T, U) {
        return x[0] = Math.max(T[0], U[0]), x[1] = Math.max(T[1], U[1]), x[2] = Math.max(T[2], U[2]), x;
      }
      function Z(x, T) {
        return x[0] = Math.round(T[0]), x[1] = Math.round(T[1]), x[2] = Math.round(T[2]), x;
      }
      function X(x, T, U) {
        return x[0] = T[0] * U, x[1] = T[1] * U, x[2] = T[2] * U, x;
      }
      function c(x, T, U, w) {
        return x[0] = T[0] + U[0] * w, x[1] = T[1] + U[1] * w, x[2] = T[2] + U[2] * w, x;
      }
      function t(x, T) {
        var U = T[0] - x[0], w = T[1] - x[1], B = T[2] - x[2];
        return Math.hypot(U, w, B);
      }
      function R(x, T) {
        var U = T[0] - x[0], w = T[1] - x[1], B = T[2] - x[2];
        return U * U + w * w + B * B;
      }
      function S(x) {
        var T = x[0], U = x[1], w = x[2];
        return T * T + U * U + w * w;
      }
      function J(x, T) {
        return x[0] = -T[0], x[1] = -T[1], x[2] = -T[2], x;
      }
      function H(x, T) {
        return x[0] = 1 / T[0], x[1] = 1 / T[1], x[2] = 1 / T[2], x;
      }
      function L(x, T) {
        var U = T[0], w = T[1], B = T[2], A = U * U + w * w + B * B;
        return A > 0 && (A = 1 / Math.sqrt(A)), x[0] = T[0] * A, x[1] = T[1] * A, x[2] = T[2] * A, x;
      }
      function C(x, T) {
        return x[0] * T[0] + x[1] * T[1] + x[2] * T[2];
      }
      function F(x, T, U) {
        var w = T[0], B = T[1], A = T[2], ld = U[0], id = U[1], sd = U[2];
        return x[0] = B * sd - A * id, x[1] = A * ld - w * sd, x[2] = w * id - B * ld, x;
      }
      function r(x, T, U, w) {
        var B = T[0], A = T[1], ld = T[2];
        return x[0] = B + w * (U[0] - B), x[1] = A + w * (U[1] - A), x[2] = ld + w * (U[2] - ld), x;
      }
      function K(x, T, U, w, B, A) {
        var ld = A * A, id = ld * (2 * A - 3) + 1, sd = ld * (A - 2) + A, td = ld * (A - 1), Zd = ld * (3 - 2 * A);
        return x[0] = T[0] * id + U[0] * sd + w[0] * td + B[0] * Zd, x[1] = T[1] * id + U[1] * sd + w[1] * td + B[1] * Zd, x[2] = T[2] * id + U[2] * sd + w[2] * td + B[2] * Zd, x;
      }
      function g(x, T, U, w, B, A) {
        var ld = 1 - A, id = ld * ld, sd = A * A, td = id * ld, Zd = 3 * A * id, bd = 3 * sd * ld, md = sd * A;
        return x[0] = T[0] * td + U[0] * Zd + w[0] * bd + B[0] * md, x[1] = T[1] * td + U[1] * Zd + w[1] * bd + B[1] * md, x[2] = T[2] * td + U[2] * Zd + w[2] * bd + B[2] * md, x;
      }
      function v(x, T) {
        T = T || 1;
        var U = i.RANDOM() * 2 * Math.PI, w = i.RANDOM() * 2 - 1, B = Math.sqrt(1 - w * w) * T;
        return x[0] = Math.cos(U) * B, x[1] = Math.sin(U) * B, x[2] = w * T, x;
      }
      function f(x, T, U) {
        var w = T[0], B = T[1], A = T[2], ld = U[3] * w + U[7] * B + U[11] * A + U[15];
        return ld = ld || 1, x[0] = (U[0] * w + U[4] * B + U[8] * A + U[12]) / ld, x[1] = (U[1] * w + U[5] * B + U[9] * A + U[13]) / ld, x[2] = (U[2] * w + U[6] * B + U[10] * A + U[14]) / ld, x;
      }
      function O(x, T, U) {
        var w = T[0], B = T[1], A = T[2];
        return x[0] = w * U[0] + B * U[3] + A * U[6], x[1] = w * U[1] + B * U[4] + A * U[7], x[2] = w * U[2] + B * U[5] + A * U[8], x;
      }
      function q(x, T, U) {
        var w = U[0], B = U[1], A = U[2], ld = U[3], id = T[0], sd = T[1], td = T[2], Zd = B * td - A * sd, bd = A * id - w * td, md = w * sd - B * id, od = B * md - A * bd, ed = A * Zd - w * md, nd = w * bd - B * Zd, hd = ld * 2;
        return Zd *= hd, bd *= hd, md *= hd, od *= 2, ed *= 2, nd *= 2, x[0] = id + Zd + od, x[1] = sd + bd + ed, x[2] = td + md + nd, x;
      }
      function M(x, T, U, w) {
        var B = [], A = [];
        return B[0] = T[0] - U[0], B[1] = T[1] - U[1], B[2] = T[2] - U[2], A[0] = B[0], A[1] = B[1] * Math.cos(w) - B[2] * Math.sin(w), A[2] = B[1] * Math.sin(w) + B[2] * Math.cos(w), x[0] = A[0] + U[0], x[1] = A[1] + U[1], x[2] = A[2] + U[2], x;
      }
      function P(x, T, U, w) {
        var B = [], A = [];
        return B[0] = T[0] - U[0], B[1] = T[1] - U[1], B[2] = T[2] - U[2], A[0] = B[2] * Math.sin(w) + B[0] * Math.cos(w), A[1] = B[1], A[2] = B[2] * Math.cos(w) - B[0] * Math.sin(w), x[0] = A[0] + U[0], x[1] = A[1] + U[1], x[2] = A[2] + U[2], x;
      }
      function D(x, T, U, w) {
        var B = [], A = [];
        return B[0] = T[0] - U[0], B[1] = T[1] - U[1], B[2] = T[2] - U[2], A[0] = B[0] * Math.cos(w) - B[1] * Math.sin(w), A[1] = B[0] * Math.sin(w) + B[1] * Math.cos(w), A[2] = B[2], x[0] = A[0] + U[0], x[1] = A[1] + U[1], x[2] = A[2] + U[2], x;
      }
      function dd(x, T) {
        var U = x[0], w = x[1], B = x[2], A = T[0], ld = T[1], id = T[2], sd = Math.sqrt(U * U + w * w + B * B), td = Math.sqrt(A * A + ld * ld + id * id), Zd = sd * td, bd = Zd && C(x, T) / Zd;
        return Math.acos(Math.min(Math.max(bd, -1), 1));
      }
      function _(x) {
        return x[0] = 0, x[1] = 0, x[2] = 0, x;
      }
      function cd(x) {
        return "vec3(" + x[0] + ", " + x[1] + ", " + x[2] + ")";
      }
      function $(x, T) {
        return x[0] === T[0] && x[1] === T[1] && x[2] === T[2];
      }
      function Wd(x, T) {
        var U = x[0], w = x[1], B = x[2], A = T[0], ld = T[1], id = T[2];
        return Math.abs(U - A) <= i.EPSILON * Math.max(1, Math.abs(U), Math.abs(A)) && Math.abs(w - ld) <= i.EPSILON * Math.max(1, Math.abs(w), Math.abs(ld)) && Math.abs(B - id) <= i.EPSILON * Math.max(1, Math.abs(B), Math.abs(id));
      }
      var Xd = a, k = V, z = h, E = t, j = R, N = o, Q = S, u = function() {
        var x = b();
        return function(T, U, w, B, A, ld) {
          var id, sd;
          for (U || (U = 3), w || (w = 0), B ? sd = Math.min(B * U + w, T.length) : sd = T.length, id = w; id < sd; id += U)
            x[0] = T[id], x[1] = T[id + 1], x[2] = T[id + 2], A(x, x, ld), T[id] = x[0], T[id + 1] = x[1], T[id + 2] = x[2];
          return T;
        };
      }();
    },
    /* 9 */
    /***/
    function(s, l, d) {
      d.r(l), d.d(l, "create", function() {
        return b;
      }), d.d(l, "clone", function() {
        return m;
      }), d.d(l, "fromValues", function() {
        return o;
      }), d.d(l, "copy", function() {
        return n;
      }), d.d(l, "set", function() {
        return W;
      }), d.d(l, "add", function() {
        return e;
      }), d.d(l, "subtract", function() {
        return I;
      }), d.d(l, "multiply", function() {
        return a;
      }), d.d(l, "divide", function() {
        return V;
      }), d.d(l, "ceil", function() {
        return h;
      }), d.d(l, "floor", function() {
        return Y;
      }), d.d(l, "min", function() {
        return p;
      }), d.d(l, "max", function() {
        return G;
      }), d.d(l, "round", function() {
        return y;
      }), d.d(l, "scale", function() {
        return Z;
      }), d.d(l, "scaleAndAdd", function() {
        return X;
      }), d.d(l, "distance", function() {
        return c;
      }), d.d(l, "squaredDistance", function() {
        return t;
      }), d.d(l, "length", function() {
        return R;
      }), d.d(l, "squaredLength", function() {
        return S;
      }), d.d(l, "negate", function() {
        return J;
      }), d.d(l, "inverse", function() {
        return H;
      }), d.d(l, "normalize", function() {
        return L;
      }), d.d(l, "dot", function() {
        return C;
      }), d.d(l, "cross", function() {
        return F;
      }), d.d(l, "lerp", function() {
        return r;
      }), d.d(l, "random", function() {
        return K;
      }), d.d(l, "transformMat4", function() {
        return g;
      }), d.d(l, "transformQuat", function() {
        return v;
      }), d.d(l, "zero", function() {
        return f;
      }), d.d(l, "str", function() {
        return O;
      }), d.d(l, "exactEquals", function() {
        return q;
      }), d.d(l, "equals", function() {
        return M;
      }), d.d(l, "sub", function() {
        return P;
      }), d.d(l, "mul", function() {
        return D;
      }), d.d(l, "div", function() {
        return dd;
      }), d.d(l, "dist", function() {
        return _;
      }), d.d(l, "sqrDist", function() {
        return cd;
      }), d.d(l, "len", function() {
        return $;
      }), d.d(l, "sqrLen", function() {
        return Wd;
      }), d.d(l, "forEach", function() {
        return Xd;
      });
      var i = d(2);
      function b() {
        var k = new i.ARRAY_TYPE(4);
        return i.ARRAY_TYPE != Float32Array && (k[0] = 0, k[1] = 0, k[2] = 0, k[3] = 0), k;
      }
      function m(k) {
        var z = new i.ARRAY_TYPE(4);
        return z[0] = k[0], z[1] = k[1], z[2] = k[2], z[3] = k[3], z;
      }
      function o(k, z, E, j) {
        var N = new i.ARRAY_TYPE(4);
        return N[0] = k, N[1] = z, N[2] = E, N[3] = j, N;
      }
      function n(k, z) {
        return k[0] = z[0], k[1] = z[1], k[2] = z[2], k[3] = z[3], k;
      }
      function W(k, z, E, j, N) {
        return k[0] = z, k[1] = E, k[2] = j, k[3] = N, k;
      }
      function e(k, z, E) {
        return k[0] = z[0] + E[0], k[1] = z[1] + E[1], k[2] = z[2] + E[2], k[3] = z[3] + E[3], k;
      }
      function I(k, z, E) {
        return k[0] = z[0] - E[0], k[1] = z[1] - E[1], k[2] = z[2] - E[2], k[3] = z[3] - E[3], k;
      }
      function a(k, z, E) {
        return k[0] = z[0] * E[0], k[1] = z[1] * E[1], k[2] = z[2] * E[2], k[3] = z[3] * E[3], k;
      }
      function V(k, z, E) {
        return k[0] = z[0] / E[0], k[1] = z[1] / E[1], k[2] = z[2] / E[2], k[3] = z[3] / E[3], k;
      }
      function h(k, z) {
        return k[0] = Math.ceil(z[0]), k[1] = Math.ceil(z[1]), k[2] = Math.ceil(z[2]), k[3] = Math.ceil(z[3]), k;
      }
      function Y(k, z) {
        return k[0] = Math.floor(z[0]), k[1] = Math.floor(z[1]), k[2] = Math.floor(z[2]), k[3] = Math.floor(z[3]), k;
      }
      function p(k, z, E) {
        return k[0] = Math.min(z[0], E[0]), k[1] = Math.min(z[1], E[1]), k[2] = Math.min(z[2], E[2]), k[3] = Math.min(z[3], E[3]), k;
      }
      function G(k, z, E) {
        return k[0] = Math.max(z[0], E[0]), k[1] = Math.max(z[1], E[1]), k[2] = Math.max(z[2], E[2]), k[3] = Math.max(z[3], E[3]), k;
      }
      function y(k, z) {
        return k[0] = Math.round(z[0]), k[1] = Math.round(z[1]), k[2] = Math.round(z[2]), k[3] = Math.round(z[3]), k;
      }
      function Z(k, z, E) {
        return k[0] = z[0] * E, k[1] = z[1] * E, k[2] = z[2] * E, k[3] = z[3] * E, k;
      }
      function X(k, z, E, j) {
        return k[0] = z[0] + E[0] * j, k[1] = z[1] + E[1] * j, k[2] = z[2] + E[2] * j, k[3] = z[3] + E[3] * j, k;
      }
      function c(k, z) {
        var E = z[0] - k[0], j = z[1] - k[1], N = z[2] - k[2], Q = z[3] - k[3];
        return Math.hypot(E, j, N, Q);
      }
      function t(k, z) {
        var E = z[0] - k[0], j = z[1] - k[1], N = z[2] - k[2], Q = z[3] - k[3];
        return E * E + j * j + N * N + Q * Q;
      }
      function R(k) {
        var z = k[0], E = k[1], j = k[2], N = k[3];
        return Math.hypot(z, E, j, N);
      }
      function S(k) {
        var z = k[0], E = k[1], j = k[2], N = k[3];
        return z * z + E * E + j * j + N * N;
      }
      function J(k, z) {
        return k[0] = -z[0], k[1] = -z[1], k[2] = -z[2], k[3] = -z[3], k;
      }
      function H(k, z) {
        return k[0] = 1 / z[0], k[1] = 1 / z[1], k[2] = 1 / z[2], k[3] = 1 / z[3], k;
      }
      function L(k, z) {
        var E = z[0], j = z[1], N = z[2], Q = z[3], u = E * E + j * j + N * N + Q * Q;
        return u > 0 && (u = 1 / Math.sqrt(u)), k[0] = E * u, k[1] = j * u, k[2] = N * u, k[3] = Q * u, k;
      }
      function C(k, z) {
        return k[0] * z[0] + k[1] * z[1] + k[2] * z[2] + k[3] * z[3];
      }
      function F(k, z, E, j) {
        var N = E[0] * j[1] - E[1] * j[0], Q = E[0] * j[2] - E[2] * j[0], u = E[0] * j[3] - E[3] * j[0], x = E[1] * j[2] - E[2] * j[1], T = E[1] * j[3] - E[3] * j[1], U = E[2] * j[3] - E[3] * j[2], w = z[0], B = z[1], A = z[2], ld = z[3];
        return k[0] = B * U - A * T + ld * x, k[1] = -(w * U) + A * u - ld * Q, k[2] = w * T - B * u + ld * N, k[3] = -(w * x) + B * Q - A * N, k;
      }
      function r(k, z, E, j) {
        var N = z[0], Q = z[1], u = z[2], x = z[3];
        return k[0] = N + j * (E[0] - N), k[1] = Q + j * (E[1] - Q), k[2] = u + j * (E[2] - u), k[3] = x + j * (E[3] - x), k;
      }
      function K(k, z) {
        z = z || 1;
        var E, j, N, Q, u, x;
        do
          E = i.RANDOM() * 2 - 1, j = i.RANDOM() * 2 - 1, u = E * E + j * j;
        while (u >= 1);
        do
          N = i.RANDOM() * 2 - 1, Q = i.RANDOM() * 2 - 1, x = N * N + Q * Q;
        while (x >= 1);
        var T = Math.sqrt((1 - u) / x);
        return k[0] = z * E, k[1] = z * j, k[2] = z * N * T, k[3] = z * Q * T, k;
      }
      function g(k, z, E) {
        var j = z[0], N = z[1], Q = z[2], u = z[3];
        return k[0] = E[0] * j + E[4] * N + E[8] * Q + E[12] * u, k[1] = E[1] * j + E[5] * N + E[9] * Q + E[13] * u, k[2] = E[2] * j + E[6] * N + E[10] * Q + E[14] * u, k[3] = E[3] * j + E[7] * N + E[11] * Q + E[15] * u, k;
      }
      function v(k, z, E) {
        var j = z[0], N = z[1], Q = z[2], u = E[0], x = E[1], T = E[2], U = E[3], w = U * j + x * Q - T * N, B = U * N + T * j - u * Q, A = U * Q + u * N - x * j, ld = -u * j - x * N - T * Q;
        return k[0] = w * U + ld * -u + B * -T - A * -x, k[1] = B * U + ld * -x + A * -u - w * -T, k[2] = A * U + ld * -T + w * -x - B * -u, k[3] = z[3], k;
      }
      function f(k) {
        return k[0] = 0, k[1] = 0, k[2] = 0, k[3] = 0, k;
      }
      function O(k) {
        return "vec4(" + k[0] + ", " + k[1] + ", " + k[2] + ", " + k[3] + ")";
      }
      function q(k, z) {
        return k[0] === z[0] && k[1] === z[1] && k[2] === z[2] && k[3] === z[3];
      }
      function M(k, z) {
        var E = k[0], j = k[1], N = k[2], Q = k[3], u = z[0], x = z[1], T = z[2], U = z[3];
        return Math.abs(E - u) <= i.EPSILON * Math.max(1, Math.abs(E), Math.abs(u)) && Math.abs(j - x) <= i.EPSILON * Math.max(1, Math.abs(j), Math.abs(x)) && Math.abs(N - T) <= i.EPSILON * Math.max(1, Math.abs(N), Math.abs(T)) && Math.abs(Q - U) <= i.EPSILON * Math.max(1, Math.abs(Q), Math.abs(U));
      }
      var P = I, D = a, dd = V, _ = c, cd = t, $ = R, Wd = S, Xd = function() {
        var k = b();
        return function(z, E, j, N, Q, u) {
          var x, T;
          for (E || (E = 4), j || (j = 0), N ? T = Math.min(N * E + j, z.length) : T = z.length, x = j; x < T; x += E)
            k[0] = z[x], k[1] = z[x + 1], k[2] = z[x + 2], k[3] = z[x + 3], Q(k, k, u), z[x] = k[0], z[x + 1] = k[1], z[x + 2] = k[2], z[x + 3] = k[3];
          return z;
        };
      }();
    },
    /* 10 */
    /***/
    function(s, l, d) {
      d.r(l), d.d(l, "create", function() {
        return o;
      }), d.d(l, "clone", function() {
        return n;
      }), d.d(l, "fromValues", function() {
        return W;
      }), d.d(l, "fromRotationTranslationValues", function() {
        return e;
      }), d.d(l, "fromRotationTranslation", function() {
        return I;
      }), d.d(l, "fromTranslation", function() {
        return a;
      }), d.d(l, "fromRotation", function() {
        return V;
      }), d.d(l, "fromMat4", function() {
        return h;
      }), d.d(l, "copy", function() {
        return Y;
      }), d.d(l, "identity", function() {
        return p;
      }), d.d(l, "set", function() {
        return G;
      }), d.d(l, "getReal", function() {
        return y;
      }), d.d(l, "getDual", function() {
        return Z;
      }), d.d(l, "setReal", function() {
        return X;
      }), d.d(l, "setDual", function() {
        return c;
      }), d.d(l, "getTranslation", function() {
        return t;
      }), d.d(l, "translate", function() {
        return R;
      }), d.d(l, "rotateX", function() {
        return S;
      }), d.d(l, "rotateY", function() {
        return J;
      }), d.d(l, "rotateZ", function() {
        return H;
      }), d.d(l, "rotateByQuatAppend", function() {
        return L;
      }), d.d(l, "rotateByQuatPrepend", function() {
        return C;
      }), d.d(l, "rotateAroundAxis", function() {
        return F;
      }), d.d(l, "add", function() {
        return r;
      }), d.d(l, "multiply", function() {
        return K;
      }), d.d(l, "mul", function() {
        return g;
      }), d.d(l, "scale", function() {
        return v;
      }), d.d(l, "dot", function() {
        return f;
      }), d.d(l, "lerp", function() {
        return O;
      }), d.d(l, "invert", function() {
        return q;
      }), d.d(l, "conjugate", function() {
        return M;
      }), d.d(l, "length", function() {
        return P;
      }), d.d(l, "len", function() {
        return D;
      }), d.d(l, "squaredLength", function() {
        return dd;
      }), d.d(l, "sqrLen", function() {
        return _;
      }), d.d(l, "normalize", function() {
        return cd;
      }), d.d(l, "str", function() {
        return $;
      }), d.d(l, "exactEquals", function() {
        return Wd;
      }), d.d(l, "equals", function() {
        return Xd;
      });
      var i = d(2), b = d(7), m = d(6);
      function o() {
        var k = new i.ARRAY_TYPE(8);
        return i.ARRAY_TYPE != Float32Array && (k[0] = 0, k[1] = 0, k[2] = 0, k[4] = 0, k[5] = 0, k[6] = 0, k[7] = 0), k[3] = 1, k;
      }
      function n(k) {
        var z = new i.ARRAY_TYPE(8);
        return z[0] = k[0], z[1] = k[1], z[2] = k[2], z[3] = k[3], z[4] = k[4], z[5] = k[5], z[6] = k[6], z[7] = k[7], z;
      }
      function W(k, z, E, j, N, Q, u, x) {
        var T = new i.ARRAY_TYPE(8);
        return T[0] = k, T[1] = z, T[2] = E, T[3] = j, T[4] = N, T[5] = Q, T[6] = u, T[7] = x, T;
      }
      function e(k, z, E, j, N, Q, u) {
        var x = new i.ARRAY_TYPE(8);
        x[0] = k, x[1] = z, x[2] = E, x[3] = j;
        var T = N * 0.5, U = Q * 0.5, w = u * 0.5;
        return x[4] = T * j + U * E - w * z, x[5] = U * j + w * k - T * E, x[6] = w * j + T * z - U * k, x[7] = -T * k - U * z - w * E, x;
      }
      function I(k, z, E) {
        var j = E[0] * 0.5, N = E[1] * 0.5, Q = E[2] * 0.5, u = z[0], x = z[1], T = z[2], U = z[3];
        return k[0] = u, k[1] = x, k[2] = T, k[3] = U, k[4] = j * U + N * T - Q * x, k[5] = N * U + Q * u - j * T, k[6] = Q * U + j * x - N * u, k[7] = -j * u - N * x - Q * T, k;
      }
      function a(k, z) {
        return k[0] = 0, k[1] = 0, k[2] = 0, k[3] = 1, k[4] = z[0] * 0.5, k[5] = z[1] * 0.5, k[6] = z[2] * 0.5, k[7] = 0, k;
      }
      function V(k, z) {
        return k[0] = z[0], k[1] = z[1], k[2] = z[2], k[3] = z[3], k[4] = 0, k[5] = 0, k[6] = 0, k[7] = 0, k;
      }
      function h(k, z) {
        var E = b.create();
        m.getRotation(E, z);
        var j = new i.ARRAY_TYPE(3);
        return m.getTranslation(j, z), I(k, E, j), k;
      }
      function Y(k, z) {
        return k[0] = z[0], k[1] = z[1], k[2] = z[2], k[3] = z[3], k[4] = z[4], k[5] = z[5], k[6] = z[6], k[7] = z[7], k;
      }
      function p(k) {
        return k[0] = 0, k[1] = 0, k[2] = 0, k[3] = 1, k[4] = 0, k[5] = 0, k[6] = 0, k[7] = 0, k;
      }
      function G(k, z, E, j, N, Q, u, x, T) {
        return k[0] = z, k[1] = E, k[2] = j, k[3] = N, k[4] = Q, k[5] = u, k[6] = x, k[7] = T, k;
      }
      var y = b.copy;
      function Z(k, z) {
        return k[0] = z[4], k[1] = z[5], k[2] = z[6], k[3] = z[7], k;
      }
      var X = b.copy;
      function c(k, z) {
        return k[4] = z[0], k[5] = z[1], k[6] = z[2], k[7] = z[3], k;
      }
      function t(k, z) {
        var E = z[4], j = z[5], N = z[6], Q = z[7], u = -z[0], x = -z[1], T = -z[2], U = z[3];
        return k[0] = (E * U + Q * u + j * T - N * x) * 2, k[1] = (j * U + Q * x + N * u - E * T) * 2, k[2] = (N * U + Q * T + E * x - j * u) * 2, k;
      }
      function R(k, z, E) {
        var j = z[0], N = z[1], Q = z[2], u = z[3], x = E[0] * 0.5, T = E[1] * 0.5, U = E[2] * 0.5, w = z[4], B = z[5], A = z[6], ld = z[7];
        return k[0] = j, k[1] = N, k[2] = Q, k[3] = u, k[4] = u * x + N * U - Q * T + w, k[5] = u * T + Q * x - j * U + B, k[6] = u * U + j * T - N * x + A, k[7] = -j * x - N * T - Q * U + ld, k;
      }
      function S(k, z, E) {
        var j = -z[0], N = -z[1], Q = -z[2], u = z[3], x = z[4], T = z[5], U = z[6], w = z[7], B = x * u + w * j + T * Q - U * N, A = T * u + w * N + U * j - x * Q, ld = U * u + w * Q + x * N - T * j, id = w * u - x * j - T * N - U * Q;
        return b.rotateX(k, z, E), j = k[0], N = k[1], Q = k[2], u = k[3], k[4] = B * u + id * j + A * Q - ld * N, k[5] = A * u + id * N + ld * j - B * Q, k[6] = ld * u + id * Q + B * N - A * j, k[7] = id * u - B * j - A * N - ld * Q, k;
      }
      function J(k, z, E) {
        var j = -z[0], N = -z[1], Q = -z[2], u = z[3], x = z[4], T = z[5], U = z[6], w = z[7], B = x * u + w * j + T * Q - U * N, A = T * u + w * N + U * j - x * Q, ld = U * u + w * Q + x * N - T * j, id = w * u - x * j - T * N - U * Q;
        return b.rotateY(k, z, E), j = k[0], N = k[1], Q = k[2], u = k[3], k[4] = B * u + id * j + A * Q - ld * N, k[5] = A * u + id * N + ld * j - B * Q, k[6] = ld * u + id * Q + B * N - A * j, k[7] = id * u - B * j - A * N - ld * Q, k;
      }
      function H(k, z, E) {
        var j = -z[0], N = -z[1], Q = -z[2], u = z[3], x = z[4], T = z[5], U = z[6], w = z[7], B = x * u + w * j + T * Q - U * N, A = T * u + w * N + U * j - x * Q, ld = U * u + w * Q + x * N - T * j, id = w * u - x * j - T * N - U * Q;
        return b.rotateZ(k, z, E), j = k[0], N = k[1], Q = k[2], u = k[3], k[4] = B * u + id * j + A * Q - ld * N, k[5] = A * u + id * N + ld * j - B * Q, k[6] = ld * u + id * Q + B * N - A * j, k[7] = id * u - B * j - A * N - ld * Q, k;
      }
      function L(k, z, E) {
        var j = E[0], N = E[1], Q = E[2], u = E[3], x = z[0], T = z[1], U = z[2], w = z[3];
        return k[0] = x * u + w * j + T * Q - U * N, k[1] = T * u + w * N + U * j - x * Q, k[2] = U * u + w * Q + x * N - T * j, k[3] = w * u - x * j - T * N - U * Q, x = z[4], T = z[5], U = z[6], w = z[7], k[4] = x * u + w * j + T * Q - U * N, k[5] = T * u + w * N + U * j - x * Q, k[6] = U * u + w * Q + x * N - T * j, k[7] = w * u - x * j - T * N - U * Q, k;
      }
      function C(k, z, E) {
        var j = z[0], N = z[1], Q = z[2], u = z[3], x = E[0], T = E[1], U = E[2], w = E[3];
        return k[0] = j * w + u * x + N * U - Q * T, k[1] = N * w + u * T + Q * x - j * U, k[2] = Q * w + u * U + j * T - N * x, k[3] = u * w - j * x - N * T - Q * U, x = E[4], T = E[5], U = E[6], w = E[7], k[4] = j * w + u * x + N * U - Q * T, k[5] = N * w + u * T + Q * x - j * U, k[6] = Q * w + u * U + j * T - N * x, k[7] = u * w - j * x - N * T - Q * U, k;
      }
      function F(k, z, E, j) {
        if (Math.abs(j) < i.EPSILON)
          return Y(k, z);
        var N = Math.hypot(E[0], E[1], E[2]);
        j = j * 0.5;
        var Q = Math.sin(j), u = Q * E[0] / N, x = Q * E[1] / N, T = Q * E[2] / N, U = Math.cos(j), w = z[0], B = z[1], A = z[2], ld = z[3];
        k[0] = w * U + ld * u + B * T - A * x, k[1] = B * U + ld * x + A * u - w * T, k[2] = A * U + ld * T + w * x - B * u, k[3] = ld * U - w * u - B * x - A * T;
        var id = z[4], sd = z[5], td = z[6], Zd = z[7];
        return k[4] = id * U + Zd * u + sd * T - td * x, k[5] = sd * U + Zd * x + td * u - id * T, k[6] = td * U + Zd * T + id * x - sd * u, k[7] = Zd * U - id * u - sd * x - td * T, k;
      }
      function r(k, z, E) {
        return k[0] = z[0] + E[0], k[1] = z[1] + E[1], k[2] = z[2] + E[2], k[3] = z[3] + E[3], k[4] = z[4] + E[4], k[5] = z[5] + E[5], k[6] = z[6] + E[6], k[7] = z[7] + E[7], k;
      }
      function K(k, z, E) {
        var j = z[0], N = z[1], Q = z[2], u = z[3], x = E[4], T = E[5], U = E[6], w = E[7], B = z[4], A = z[5], ld = z[6], id = z[7], sd = E[0], td = E[1], Zd = E[2], bd = E[3];
        return k[0] = j * bd + u * sd + N * Zd - Q * td, k[1] = N * bd + u * td + Q * sd - j * Zd, k[2] = Q * bd + u * Zd + j * td - N * sd, k[3] = u * bd - j * sd - N * td - Q * Zd, k[4] = j * w + u * x + N * U - Q * T + B * bd + id * sd + A * Zd - ld * td, k[5] = N * w + u * T + Q * x - j * U + A * bd + id * td + ld * sd - B * Zd, k[6] = Q * w + u * U + j * T - N * x + ld * bd + id * Zd + B * td - A * sd, k[7] = u * w - j * x - N * T - Q * U + id * bd - B * sd - A * td - ld * Zd, k;
      }
      var g = K;
      function v(k, z, E) {
        return k[0] = z[0] * E, k[1] = z[1] * E, k[2] = z[2] * E, k[3] = z[3] * E, k[4] = z[4] * E, k[5] = z[5] * E, k[6] = z[6] * E, k[7] = z[7] * E, k;
      }
      var f = b.dot;
      function O(k, z, E, j) {
        var N = 1 - j;
        return f(z, E) < 0 && (j = -j), k[0] = z[0] * N + E[0] * j, k[1] = z[1] * N + E[1] * j, k[2] = z[2] * N + E[2] * j, k[3] = z[3] * N + E[3] * j, k[4] = z[4] * N + E[4] * j, k[5] = z[5] * N + E[5] * j, k[6] = z[6] * N + E[6] * j, k[7] = z[7] * N + E[7] * j, k;
      }
      function q(k, z) {
        var E = dd(z);
        return k[0] = -z[0] / E, k[1] = -z[1] / E, k[2] = -z[2] / E, k[3] = z[3] / E, k[4] = -z[4] / E, k[5] = -z[5] / E, k[6] = -z[6] / E, k[7] = z[7] / E, k;
      }
      function M(k, z) {
        return k[0] = -z[0], k[1] = -z[1], k[2] = -z[2], k[3] = z[3], k[4] = -z[4], k[5] = -z[5], k[6] = -z[6], k[7] = z[7], k;
      }
      var P = b.length, D = P, dd = b.squaredLength, _ = dd;
      function cd(k, z) {
        var E = dd(z);
        if (E > 0) {
          E = Math.sqrt(E);
          var j = z[0] / E, N = z[1] / E, Q = z[2] / E, u = z[3] / E, x = z[4], T = z[5], U = z[6], w = z[7], B = j * x + N * T + Q * U + u * w;
          k[0] = j, k[1] = N, k[2] = Q, k[3] = u, k[4] = (x - j * B) / E, k[5] = (T - N * B) / E, k[6] = (U - Q * B) / E, k[7] = (w - u * B) / E;
        }
        return k;
      }
      function $(k) {
        return "quat2(" + k[0] + ", " + k[1] + ", " + k[2] + ", " + k[3] + ", " + k[4] + ", " + k[5] + ", " + k[6] + ", " + k[7] + ")";
      }
      function Wd(k, z) {
        return k[0] === z[0] && k[1] === z[1] && k[2] === z[2] && k[3] === z[3] && k[4] === z[4] && k[5] === z[5] && k[6] === z[6] && k[7] === z[7];
      }
      function Xd(k, z) {
        var E = k[0], j = k[1], N = k[2], Q = k[3], u = k[4], x = k[5], T = k[6], U = k[7], w = z[0], B = z[1], A = z[2], ld = z[3], id = z[4], sd = z[5], td = z[6], Zd = z[7];
        return Math.abs(E - w) <= i.EPSILON * Math.max(1, Math.abs(E), Math.abs(w)) && Math.abs(j - B) <= i.EPSILON * Math.max(1, Math.abs(j), Math.abs(B)) && Math.abs(N - A) <= i.EPSILON * Math.max(1, Math.abs(N), Math.abs(A)) && Math.abs(Q - ld) <= i.EPSILON * Math.max(1, Math.abs(Q), Math.abs(ld)) && Math.abs(u - id) <= i.EPSILON * Math.max(1, Math.abs(u), Math.abs(id)) && Math.abs(x - sd) <= i.EPSILON * Math.max(1, Math.abs(x), Math.abs(sd)) && Math.abs(T - td) <= i.EPSILON * Math.max(1, Math.abs(T), Math.abs(td)) && Math.abs(U - Zd) <= i.EPSILON * Math.max(1, Math.abs(U), Math.abs(Zd));
      }
    },
    /* 11 */
    /***/
    function(s, l, d) {
      d.r(l), d.d(l, "create", function() {
        return b;
      }), d.d(l, "clone", function() {
        return m;
      }), d.d(l, "fromValues", function() {
        return o;
      }), d.d(l, "copy", function() {
        return n;
      }), d.d(l, "set", function() {
        return W;
      }), d.d(l, "add", function() {
        return e;
      }), d.d(l, "subtract", function() {
        return I;
      }), d.d(l, "multiply", function() {
        return a;
      }), d.d(l, "divide", function() {
        return V;
      }), d.d(l, "ceil", function() {
        return h;
      }), d.d(l, "floor", function() {
        return Y;
      }), d.d(l, "min", function() {
        return p;
      }), d.d(l, "max", function() {
        return G;
      }), d.d(l, "round", function() {
        return y;
      }), d.d(l, "scale", function() {
        return Z;
      }), d.d(l, "scaleAndAdd", function() {
        return X;
      }), d.d(l, "distance", function() {
        return c;
      }), d.d(l, "squaredDistance", function() {
        return t;
      }), d.d(l, "length", function() {
        return R;
      }), d.d(l, "squaredLength", function() {
        return S;
      }), d.d(l, "negate", function() {
        return J;
      }), d.d(l, "inverse", function() {
        return H;
      }), d.d(l, "normalize", function() {
        return L;
      }), d.d(l, "dot", function() {
        return C;
      }), d.d(l, "cross", function() {
        return F;
      }), d.d(l, "lerp", function() {
        return r;
      }), d.d(l, "random", function() {
        return K;
      }), d.d(l, "transformMat2", function() {
        return g;
      }), d.d(l, "transformMat2d", function() {
        return v;
      }), d.d(l, "transformMat3", function() {
        return f;
      }), d.d(l, "transformMat4", function() {
        return O;
      }), d.d(l, "rotate", function() {
        return q;
      }), d.d(l, "angle", function() {
        return M;
      }), d.d(l, "zero", function() {
        return P;
      }), d.d(l, "str", function() {
        return D;
      }), d.d(l, "exactEquals", function() {
        return dd;
      }), d.d(l, "equals", function() {
        return _;
      }), d.d(l, "len", function() {
        return cd;
      }), d.d(l, "sub", function() {
        return $;
      }), d.d(l, "mul", function() {
        return Wd;
      }), d.d(l, "div", function() {
        return Xd;
      }), d.d(l, "dist", function() {
        return k;
      }), d.d(l, "sqrDist", function() {
        return z;
      }), d.d(l, "sqrLen", function() {
        return E;
      }), d.d(l, "forEach", function() {
        return j;
      });
      var i = d(2);
      function b() {
        var N = new i.ARRAY_TYPE(2);
        return i.ARRAY_TYPE != Float32Array && (N[0] = 0, N[1] = 0), N;
      }
      function m(N) {
        var Q = new i.ARRAY_TYPE(2);
        return Q[0] = N[0], Q[1] = N[1], Q;
      }
      function o(N, Q) {
        var u = new i.ARRAY_TYPE(2);
        return u[0] = N, u[1] = Q, u;
      }
      function n(N, Q) {
        return N[0] = Q[0], N[1] = Q[1], N;
      }
      function W(N, Q, u) {
        return N[0] = Q, N[1] = u, N;
      }
      function e(N, Q, u) {
        return N[0] = Q[0] + u[0], N[1] = Q[1] + u[1], N;
      }
      function I(N, Q, u) {
        return N[0] = Q[0] - u[0], N[1] = Q[1] - u[1], N;
      }
      function a(N, Q, u) {
        return N[0] = Q[0] * u[0], N[1] = Q[1] * u[1], N;
      }
      function V(N, Q, u) {
        return N[0] = Q[0] / u[0], N[1] = Q[1] / u[1], N;
      }
      function h(N, Q) {
        return N[0] = Math.ceil(Q[0]), N[1] = Math.ceil(Q[1]), N;
      }
      function Y(N, Q) {
        return N[0] = Math.floor(Q[0]), N[1] = Math.floor(Q[1]), N;
      }
      function p(N, Q, u) {
        return N[0] = Math.min(Q[0], u[0]), N[1] = Math.min(Q[1], u[1]), N;
      }
      function G(N, Q, u) {
        return N[0] = Math.max(Q[0], u[0]), N[1] = Math.max(Q[1], u[1]), N;
      }
      function y(N, Q) {
        return N[0] = Math.round(Q[0]), N[1] = Math.round(Q[1]), N;
      }
      function Z(N, Q, u) {
        return N[0] = Q[0] * u, N[1] = Q[1] * u, N;
      }
      function X(N, Q, u, x) {
        return N[0] = Q[0] + u[0] * x, N[1] = Q[1] + u[1] * x, N;
      }
      function c(N, Q) {
        var u = Q[0] - N[0], x = Q[1] - N[1];
        return Math.hypot(u, x);
      }
      function t(N, Q) {
        var u = Q[0] - N[0], x = Q[1] - N[1];
        return u * u + x * x;
      }
      function R(N) {
        var Q = N[0], u = N[1];
        return Math.hypot(Q, u);
      }
      function S(N) {
        var Q = N[0], u = N[1];
        return Q * Q + u * u;
      }
      function J(N, Q) {
        return N[0] = -Q[0], N[1] = -Q[1], N;
      }
      function H(N, Q) {
        return N[0] = 1 / Q[0], N[1] = 1 / Q[1], N;
      }
      function L(N, Q) {
        var u = Q[0], x = Q[1], T = u * u + x * x;
        return T > 0 && (T = 1 / Math.sqrt(T)), N[0] = Q[0] * T, N[1] = Q[1] * T, N;
      }
      function C(N, Q) {
        return N[0] * Q[0] + N[1] * Q[1];
      }
      function F(N, Q, u) {
        var x = Q[0] * u[1] - Q[1] * u[0];
        return N[0] = N[1] = 0, N[2] = x, N;
      }
      function r(N, Q, u, x) {
        var T = Q[0], U = Q[1];
        return N[0] = T + x * (u[0] - T), N[1] = U + x * (u[1] - U), N;
      }
      function K(N, Q) {
        Q = Q || 1;
        var u = i.RANDOM() * 2 * Math.PI;
        return N[0] = Math.cos(u) * Q, N[1] = Math.sin(u) * Q, N;
      }
      function g(N, Q, u) {
        var x = Q[0], T = Q[1];
        return N[0] = u[0] * x + u[2] * T, N[1] = u[1] * x + u[3] * T, N;
      }
      function v(N, Q, u) {
        var x = Q[0], T = Q[1];
        return N[0] = u[0] * x + u[2] * T + u[4], N[1] = u[1] * x + u[3] * T + u[5], N;
      }
      function f(N, Q, u) {
        var x = Q[0], T = Q[1];
        return N[0] = u[0] * x + u[3] * T + u[6], N[1] = u[1] * x + u[4] * T + u[7], N;
      }
      function O(N, Q, u) {
        var x = Q[0], T = Q[1];
        return N[0] = u[0] * x + u[4] * T + u[12], N[1] = u[1] * x + u[5] * T + u[13], N;
      }
      function q(N, Q, u, x) {
        var T = Q[0] - u[0], U = Q[1] - u[1], w = Math.sin(x), B = Math.cos(x);
        return N[0] = T * B - U * w + u[0], N[1] = T * w + U * B + u[1], N;
      }
      function M(N, Q) {
        var u = N[0], x = N[1], T = Q[0], U = Q[1], w = Math.sqrt(u * u + x * x) * Math.sqrt(T * T + U * U), B = w && (u * T + x * U) / w;
        return Math.acos(Math.min(Math.max(B, -1), 1));
      }
      function P(N) {
        return N[0] = 0, N[1] = 0, N;
      }
      function D(N) {
        return "vec2(" + N[0] + ", " + N[1] + ")";
      }
      function dd(N, Q) {
        return N[0] === Q[0] && N[1] === Q[1];
      }
      function _(N, Q) {
        var u = N[0], x = N[1], T = Q[0], U = Q[1];
        return Math.abs(u - T) <= i.EPSILON * Math.max(1, Math.abs(u), Math.abs(T)) && Math.abs(x - U) <= i.EPSILON * Math.max(1, Math.abs(x), Math.abs(U));
      }
      var cd = R, $ = I, Wd = a, Xd = V, k = c, z = t, E = S, j = function() {
        var N = b();
        return function(Q, u, x, T, U, w) {
          var B, A;
          for (u || (u = 2), x || (x = 0), T ? A = Math.min(T * u + x, Q.length) : A = Q.length, B = x; B < A; B += u)
            N[0] = Q[B], N[1] = Q[B + 1], U(N, N, w), Q[B] = N[0], Q[B + 1] = N[1];
          return Q;
        };
      }();
    },
    /* 12 */
    /***/
    function(s, l, d) {
      d.r(l);
      var i = d(13);
      d.d(l, "Renderer", function() {
        return i.default;
      });
      var b = d(40);
      d.d(l, "Figure2D", function() {
        return b.default;
      });
      var m = d(56);
      d.d(l, "Mesh2D", function() {
        return m.default;
      });
      var o = d(29);
      d.d(l, "MeshCloud", function() {
        return o.default;
      });
      var n = d(23);
      d.d(l, "parseFont", function() {
        return n.default;
      });
      var W = d(31);
      d.d(l, "parseColor", function() {
        return W.default;
      });
      var e = d(21);
      d.d(l, "ENV", function() {
        return e.default;
      }), d(1).glMatrix.setMatrixArrayType(Array);
    },
    /* 13 */
    /***/
    function(s, l, d) {
      d.r(l), d.d(l, "default", function() {
        return H;
      });
      var i = d(14), b = d(1), m = d(20), o = d(27), n = d(25), W = d(40), e = d(56), I = d(29), a = d(59), V = d(21), h = d(63);
      d(1).glMatrix.setMatrixArrayType(Array);
      const Y = {
        autoUpdate: !1,
        // premultipliedAlpha: true,
        preserveDrawingBuffer: !1,
        // depth: false,
        // antialias: false,
        bufferSize: 1500
      }, p = `attribute vec3 a_vertexPosition;
attribute vec3 a_vertexTextureCoord;
varying vec3 vTextureCoord;
uniform mat3 viewMatrix;
uniform mat3 projectionMatrix;

void main() {
  gl_PointSize = 1.0;
  vec3 pos = projectionMatrix * viewMatrix * vec3(a_vertexPosition.xy, 1.0);
  gl_Position = vec4(pos.xy, 1.0, 1.0);    
  vTextureCoord = a_vertexTextureCoord;              
}
`, G = `precision mediump float;
varying vec3 vTextureCoord;
uniform sampler2D u_texSampler;
void main() {
  gl_FragColor = texture2D(u_texSampler, vTextureCoord.xy);
}
`, y = Symbol("glRenderer"), Z = Symbol("canvasRenderer"), X = Symbol("options"), c = Symbol("globalTransform"), t = Symbol("applyGlobalTransform"), R = Symbol("canvas");
      function S(L) {
        const C = L.gl, F = L.fbo;
        F && C.bindFramebuffer(C.FRAMEBUFFER, F), L._draw(), F && C.bindFramebuffer(C.FRAMEBUFFER, null);
      }
      function J(L, C, F, r) {
        const K = L.createTexture(C.canvas), g = [[[0, 0], [F, 0], [F, r], [0, r], [0, 0]]];
        g.closed = !0;
        const v = new e.default({
          contours: g
        });
        v.setTexture(K), L.setMeshData([v.meshData]), S(L), K.delete(), C.clearRect(0, 0, F, r), delete C._filter;
      }
      class H {
        constructor(C, F = {}) {
          let r = F.contextType;
          if (r || (typeof WebGL2RenderingContext == "function" ? r = "webgl2" : typeof WebGLRenderingContext == "function" ? r = "webgl" : r = "2d"), !C.getContext) {
            const K = C;
            C = {
              getContext() {
                return K;
              },
              width: F.width,
              height: F.height
            }, K.canvas = C, r = "2d";
          }
          if (this[R] = C, r !== "webgl" && r !== "webgl2" && r !== "2d")
            throw new Error(`Unknown context type ${r}`);
          if (F.contextType = r, this[X] = Object.assign({}, Y, F), r === "webgl" || r === "webgl2") {
            r === "webgl2" && (this[X].webgl2 = !0);
            const K = new i.default(C, this[X]);
            r === "webgl2" && !K.isWebGL2 && (F.contextType = "webgl"), Object(h.createShaders)(K), Object(h.applyShader)(K), Object(h.createCloudShaders)(K);
            const g = K.gl;
            g.clearColor(0, 0, 0, 0), g.blendFuncSeparate(g.SRC_ALPHA, g.ONE_MINUS_SRC_ALPHA, g.ONE, g.ONE_MINUS_SRC_ALPHA), this[y] = K;
          } else
            this[Z] = new m.default(C, this[X]);
          this[c] = [1, 0, 0, 0, 1, 0, 0, 0, 1], this.updateResolution();
        }
        get canvas() {
          return this[R];
        }
        get canvasRenderer() {
          return this[Z];
        }
        get glRenderer() {
          return this[y];
        }
        get isWebGL2() {
          return this[y] && this[y].isWebGL2;
        }
        get options() {
          return this[X];
        }
        get globalTransformMatrix() {
          const C = this[c];
          return [C[0], C[1], C[3], C[4], C[6], C[7]];
        }
        get viewMatrix() {
          return this[c];
        }
        [t]() {
          const C = this[y] || this[Z];
          if (this[y]) {
            const {
              width: F,
              height: r
            } = this.canvas;
            C.uniforms.viewMatrix = this.viewMatrix, C.uniforms.projectionMatrix = this.projectionMatrix, C.uniforms.u_resolution = [F, r];
          }
        }
        updateResolution() {
          const {
            width: C,
            height: F
          } = this.canvas, r = [
            // translation
            1,
            0,
            0,
            0,
            1,
            0,
            -C / 2,
            -F / 2,
            1
          ], K = [
            // scale
            2 / C,
            0,
            0,
            0,
            -2 / F,
            0,
            0,
            0,
            1
          ], g = b.mat3.multiply(Array.of(0, 0, 0, 0, 0, 0, 0, 0, 0), K, r);
          this.projectionMatrix = g, this[y] && this[y].gl.viewport(0, 0, C, F);
        }
        createTexture(C, F) {
          return (this[y] || this[Z]).createTexture(C, F);
        }
        /* async */
        loadTexture(C, {
          useImageBitmap: F = !1
        } = {}) {
          return (this[y] || this[Z]).loadTexture(C, {
            useImageBitmap: F
          });
        }
        createText(C, {
          font: F = "16px arial",
          fillColor: r = null,
          strokeColor: K = null,
          strokeWidth: g = 1
        } = {}) {
          if (this[y]) {
            const v = V.default.createText(C, {
              font: F,
              fillColor: r,
              strokeColor: K,
              strokeWidth: g
            });
            return {
              image: this.createTexture(v.image),
              rect: v.rect
            };
          }
          return {
            _img: {
              font: F,
              fillColor: r,
              strokeColor: K,
              strokeWidth: g,
              text: C
            }
          };
        }
        createProgram({
          vertex: C,
          fragment: F,
          options: r
        } = {}) {
          if (this[y]) {
            const K = this[y].compileSync(F, C);
            return K._attribOpts = r, K;
          }
          throw new Error("Context 2D cannot create webgl program.");
        }
        createPassProgram({
          vertex: C = p,
          fragment: F = G,
          options: r
        } = {}) {
          return this.createProgram({
            vertex: C,
            fragment: F,
            options: r
          });
        }
        useProgram(C, F = {}) {
          if (this[y]) {
            const r = Object.assign({}, C._attribOpts, F);
            return this[y].useProgram(C, r);
          }
          throw new Error("Context 2D cannot use webgl program.");
        }
        deleteTexture(C) {
          return (this[y] || this[Z]).deleteTexture(C);
        }
        clear(...C) {
          if (this[y]) {
            const F = this[y].gl;
            F.clear(F.COLOR_BUFFER_BIT);
          } else
            this[Z].clear(...C);
        }
        drawMeshCloud(C, {
          clear: F = !1,
          program: r = null
        } = {}) {
          const K = this[y] || this[Z], g = r || C.program;
          if (this[y]) {
            const v = K.gl;
            if (F && v.clear(v.COLOR_BUFFER_BIT), g)
              K.program !== g && this.useProgram(g, {
                a_color: {
                  type: "UNSIGNED_BYTE",
                  normalize: !0
                },
                a_fillCloudColor: {
                  type: "UNSIGNED_BYTE",
                  normalize: !0
                },
                a_strokeCloudColor: {
                  type: "UNSIGNED_BYTE",
                  normalize: !0
                },
                a_frameIndex: {
                  type: "UNSIGNED_BYTE",
                  normalize: !1
                }
              });
            else {
              const f = C.mesh.meshData, O = !!f.uniforms.u_texSampler, q = !!f.uniforms.u_filterFlag, M = !!f.uniforms.u_radialGradientVector, P = C.hasCloudColor, D = C.hasCloudFilter, dd = !!f.uniforms.u_clipSampler;
              Object(h.applyCloudShader)(K, {
                hasTexture: O,
                hasFilter: q,
                hasGradient: M,
                hasCloudColor: P,
                hasCloudFilter: D,
                hasClipPath: dd
              });
            }
            this[t](), K.setMeshData([C.meshData]), C.beforeRender && C.beforeRender(v, C), S(K), C.afterRender && C.afterRender(v, C);
          } else
            K.setTransform(this.globalTransformMatrix), K.drawMeshCloud(C, {
              clear: F,
              hook: !1
            });
        }
        drawMeshes(C, {
          clear: F = !1,
          program: r = null
        } = {}) {
          const K = this[y] || this[Z];
          if (this[y]) {
            const g = K.fbo, v = Object(o.default)(this, C, r == null), f = K.gl;
            F && f.clear(f.COLOR_BUFFER_BIT);
            const O = !Object(a.isUnitTransform)(this.globalTransformMatrix);
            this._drawCalls = 0;
            for (const q of v) {
              this._drawCalls++;
              const M = r || q.program;
              if (q instanceof I.default)
                this.drawMeshCloud(q, {
                  clear: F,
                  program: M
                });
              else {
                const {
                  width: P,
                  height: D
                } = this.canvas;
                if (q.beforeRender && q.beforeRender(f, q), q.pass.length && ((!this.fbo || this.fbo.width !== P || this.fbo.height !== D) && (this.fbo = {
                  width: P,
                  height: D,
                  target: K.createFBO(),
                  buffer: K.createFBO(),
                  swap() {
                    [this.target, this.buffer] = [this.buffer, this.target];
                  }
                }), K.bindFBO(this.fbo.target)), !M && q.filterCanvas) {
                  Object(h.applyShader)(K, {
                    hasTexture: !0
                  });
                  let dd = this.filterContext;
                  dd || (dd = V.default.createCanvas(P, D).getContext("2d"), this.filterContext = dd);
                  const _ = C[q.packIndex], cd = _.filter, $ = C[q.packIndex + 1], Wd = C[q.packIndex - 1];
                  (!Wd || !Wd.filterCanvas || Wd.filter !== cd) && (!$ || !$.filterCanvas || $.filter !== cd) ? (O ? (dd.save(), Object(n.drawMesh2D)(_, dd, !1), dd.restore(), Object(n.applyFilter)(dd, cd)) : Object(n.drawMesh2D)(_, dd, !0), this[t](), J(K, dd, P, D)) : (O && dd.save(), Object(n.drawMesh2D)(_, dd, !1), O && dd.restore(), (!$ || !$.filterCanvas || _.filter !== $.filter) && (Object(n.applyFilter)(dd, cd), this[t](), J(K, dd, P, D)));
                } else {
                  if (M)
                    K.program !== M && this.useProgram(M, {
                      a_color: {
                        type: "UNSIGNED_BYTE",
                        normalize: !0
                      }
                    });
                  else {
                    const dd = !!q.uniforms.u_texSampler, _ = !!q.uniforms.u_filterFlag, cd = !!q.uniforms.u_radialGradientVector, $ = !!q.uniforms.u_clipSampler;
                    Object(h.applyShader)(K, {
                      hasTexture: dd,
                      hasFilter: _,
                      hasGradient: cd,
                      hasClipPath: $
                    });
                  }
                  q.filterCanvas && console.warn("User program ignored some filter effects."), this[t](), K.setMeshData([q]), S(K);
                }
                if (q.pass.length) {
                  const dd = q.pass.length;
                  q.pass.forEach((_, cd) => {
                    _.blend = q.enableBlend, _.setTexture(K.fbo.texture), cd === dd - 1 ? K.bindFBO(g) : (this.fbo.swap(), K.bindFBO(this.fbo.target)), _.program ? K.useProgram(_.program) : (this.defaultPassProgram = this.defaultPassProgram || this.createPassProgram(), K.useProgram(this.defaultPassProgram)), K.setMeshData([_.meshData]), f.clear(f.COLOR_BUFFER_BIT), S(K);
                  });
                }
                q.afterRender && q.afterRender(f, q);
              }
            }
          } else
            K.setTransform(this.globalTransformMatrix), K.drawMeshes(C, {
              clear: F
            });
        }
        drawImage(C, ...F) {
          const r = F.length;
          if (r < 2)
            throw new TypeError(`Failed to execute 'drawImage' on 'Renderer': 3 arguments required, but only ${F.length + 1} present.`);
          if (r !== 2 && r !== 4 && r !== 8)
            throw new TypeError(`Failed to execute 'drawImage' on 'Renderer': Valid arities are: [3, 5, 9], but ${F.length + 1} arguments provided.`);
          let K = null, g = null;
          r === 2 ? K = [F[0], F[1], C.width, C.height] : r === 4 ? K = F : r === 8 && (g = F.slice(0, 4), K = F.slice(4));
          const v = this.createTexture(C), {
            width: f,
            height: O
          } = this.canvas, q = new W.default();
          q.rect(K[0], K[1], f, O);
          const M = new e.default(q, {
            width: f,
            height: O
          });
          M.setTexture(v, {
            rect: K,
            srcRect: g
          }), this.drawMeshes([M]), this.deleteTexture(v);
        }
        setGlobalTransform(...C) {
          return this[c] = [C[0], C[1], 0, C[2], C[3], 0, C[4], C[5], 1], this;
        }
        globalTransform(...C) {
          const F = this[c];
          return this[c] = b.mat3.multiply(Array.of(0, 0, 0, 0, 0, 0, 0, 0, 0), F, C), this;
        }
        globalTranslate(C, F) {
          let r = b.mat3.create();
          return r = b.mat3.translate(Array.of(0, 0, 0, 0, 0, 0, 0, 0, 0), r, [C, F]), this.globalTransform(...r);
        }
        globalRotate(C, [F, r] = [0, 0]) {
          let K = b.mat3.create();
          return K = b.mat3.translate(Array.of(0, 0, 0, 0, 0, 0, 0, 0, 0), K, [F, r]), K = b.mat3.rotate(Array.of(0, 0, 0, 0, 0, 0, 0, 0, 0), K, C), K = b.mat3.translate(Array.of(0, 0, 0, 0, 0, 0, 0, 0, 0), K, [-F, -r]), this.globalTransform(...K);
        }
        globalScale(C, F = C, [r, K] = [0, 0]) {
          let g = b.mat3.create();
          return g = b.mat3.translate(Array.of(0, 0, 0, 0, 0, 0, 0, 0, 0), g, [r, K]), g = b.mat3.scale(Array.of(0, 0, 0, 0, 0, 0, 0, 0, 0), g, [C, F]), g = b.mat3.translate(Array.of(0, 0, 0, 0, 0, 0, 0, 0, 0), g, [-r, -K]), this.globalTransform(...g);
        }
        globalSkew(C, F = C, [r, K] = [0, 0]) {
          let g = b.mat3.create();
          return g = b.mat3.translate(Array.of(0, 0, 0, 0, 0, 0, 0, 0, 0), g, [r, K]), g = b.mat3.multiply(Array.of(0, 0, 0, 0, 0, 0, 0, 0, 0), g, b.mat3.fromValues(1, Math.tan(F), Math.tan(C), 1, 0, 0)), g = b.mat3.translate(Array.of(0, 0, 0, 0, 0, 0, 0, 0, 0), g, [-r, -K]), this.globalTransform(...g);
        }
        transformPoint(C, F, r) {
          let K = this.globalTransformMatrix;
          r && (K = b.mat3.multiply(Array.of(0, 0, 0, 0, 0, 0, 0, 0, 0), K, r));
          const g = C * K[0] + F * K[2] + K[4], v = C * K[1] + F * K[3] + K[5];
          return [g, v];
        }
      }
    },
    /* 14 */
    /***/
    function(s, l, d) {
      d.r(l);
      var i = d(15);
      d(1).glMatrix.setMatrixArrayType(Array), l.default = i.default;
    },
    /* 15 */
    /***/
    function(s, l, d) {
      d.r(l), d.d(l, "default", function() {
        return h;
      });
      var i = d(16), b = d(17), m = d(18), o = d(19);
      d(1).glMatrix.setMatrixArrayType(Array);
      function n(Y, p, G) {
        return p in Y ? Object.defineProperty(Y, p, { value: G, enumerable: !0, configurable: !0, writable: !0 }) : Y[p] = G, Y;
      }
      const W = {};
      function e(Y, p = 3) {
        const G = [], y = Y.length;
        for (let Z = 0; Z < y; Z++)
          Z % p < 2 && G.push(0.5 * (Y[Z] + 1));
        return G;
      }
      function I(Y, p) {
        const G = p._buffers;
        Object.values(G).forEach((y) => {
          Y.deleteBuffer(y);
        }), p._buffers = {};
      }
      function a(Y, p, G) {
        return Y.activeTexture(Y.TEXTURE0 + G), Array.isArray(p._img) ? Y.bindTexture(Y.TEXTURE_CUBE_MAP, p) : Y.bindTexture(Y.TEXTURE_2D, p), p;
      }
      const V = {
        int: "1i",
        ivec2: "2i",
        ivec3: "3i",
        ivec4: "4i",
        float: "1f",
        vec2: "2f",
        vec3: "3f",
        vec4: "4f",
        mat2: "Matrix2fv",
        mat3: "Matrix3fv",
        mat4: "Matrix4fv",
        sampler1D: "sampler1D",
        sampler2D: "sampler2D",
        sampler3D: "sampler3D",
        samplerCube: "samplerCube",
        sampler1DShadow: "sampler1DShadow",
        sampler2DShadow: "sampler2DShadow",
        sampler2DRect: "sampler2DRect",
        sampler2DRectShadow: "sampler2DRectShadow"
      };
      class h {
        static addLibs(p = {}) {
          Object.assign(W, p);
        }
        static FLOAT(p, G) {
          return Object(i.pointsToBuffer)(p, Float32Array, G);
        }
        static UNSIGNED_BYTE(p, G) {
          return Object(i.pointsToBuffer)(p, Uint8Array, G);
        }
        static UNSIGNED_SHORT(p, G) {
          return Object(i.pointsToBuffer)(p, Uint16Array, G);
        }
        static BYTE(p, G) {
          return Object(i.pointsToBuffer)(p, Int8Array, G);
        }
        static SHORT(p, G) {
          return Object(i.pointsToBuffer)(p, Int16Array, G);
        }
        constructor(p, G = {}) {
          this.options = Object.assign({}, h.defaultOptions, G), this.canvas = p;
          let y;
          this.options.webgl2 && (y = p.getContext("webgl2", this.options)), y == null && (y = Object(i.setupWebGL)(p, this.options), this.aia_ext = y.getExtension("ANGLE_instanced_arrays")), this.gl = y, y.viewport(0, 0, p.width, p.height), y.clearColor(0, 0, 0, 0), y.blendFuncSeparate(y.SRC_ALPHA, y.ONE_MINUS_SRC_ALPHA, y.ONE, y.ONE_MINUS_SRC_ALPHA), this.programs = [], this._events = {};
        }
        get program() {
          const p = this.gl;
          return p.getParameter(p.CURRENT_PROGRAM);
        }
        // WebGLRenderingContext.uniform[1234][fi][v]()
        // WebGLRenderingContext.uniformMatrix[234]fv()
        _declareUniform(p, G, y = "1f") {
          const Z = this.gl, X = Z.getUniformLocation(p, G);
          let c;
          const t = this;
          if (/^sampler/.test(y)) {
            const R = p._samplerMap, S = p._bindTextures;
            Object.defineProperty(p.uniforms, G, {
              get() {
                return c;
              },
              set(J) {
                c = J;
                const H = R[G] != null ? R[G] : S.length;
                S[H] = J, a(Z, J, H), R[G] || (R[G] = H, Z.uniform1i(X, H)), t.options.autoUpdate && t.update();
              },
              configurable: !1,
              enumerable: !0
            });
          } else {
            const R = y.indexOf("Matrix") === 0, S = !R && /v$/.test(y), J = Z[`uniform${y}`].bind(Z);
            Object.defineProperty(p.uniforms, G, {
              get() {
                return c;
              },
              set(H) {
                c = H, typeof H == "number" && (H = [H]), R ? J(X, !1, H) : S ? J(X, H) : J(X, ...H), t.options.autoUpdate && t.update();
              },
              configurable: !1,
              enumerable: !0
            });
          }
        }
        _draw() {
          const p = this.program;
          p.meshData.forEach((G, y) => {
            const {
              positions: Z,
              cells: X,
              instanceCount: c,
              cellsCount: t,
              attributes: R,
              uniforms: S,
              textureCoord: J,
              enableBlend: H
            } = G, L = this.gl;
            let C = G.mode != null ? G.mode : L.TRIANGLES;
            typeof C == "string" && (C = L[C]), H ? L.enable(L.BLEND) : L.disable(L.BLEND), L.bindBuffer(L.ARRAY_BUFFER, p._buffers.verticesBuffer), L.bufferData(L.ARRAY_BUFFER, Z, L.STATIC_DRAW), X && (L.bindBuffer(L.ELEMENT_ARRAY_BUFFER, p._buffers.cellsBuffer), L.bufferData(L.ELEMENT_ARRAY_BUFFER, X, L.STATIC_DRAW));
            const F = [];
            R && Object.values(R).forEach(({
              name: K,
              data: g,
              divisor: v
            }) => {
              if (L.bindBuffer(L.ARRAY_BUFFER, p._buffers[K]), L.bufferData(L.ARRAY_BUFFER, g, L.STATIC_DRAW), v != null) {
                const f = L.getAttribLocation(p, K);
                f >= 0 && (L.enableVertexAttribArray(f), F.push(f), L.vertexAttribDivisor ? L.vertexAttribDivisor(f, v) : this.aia_ext && this.aia_ext.vertexAttribDivisorANGLE(f, v));
              }
            }), S && Object.entries(S).forEach(([K, g]) => {
              this.uniforms[K] = g;
            });
            let r;
            if (!X) {
              const K = p._dimension;
              r = Z.length / K;
            }
            if (p._enableTextures && p._buffers.texCoordBuffer) {
              const K = J || e(Z, p._dimension);
              L.bindBuffer(L.ARRAY_BUFFER, p._buffers.texCoordBuffer), L.bufferData(L.ARRAY_BUFFER, h.FLOAT(K), L.STATIC_DRAW);
            }
            c != null ? (X ? L.drawElementsInstanced ? L.drawElementsInstanced(C, t, L.UNSIGNED_SHORT, 0, c) : this.aia_ext && this.aia_ext.drawElementsInstancedANGLE(C, t, L.UNSIGNED_SHORT, 0, c) : L.drawArraysInstanced ? L.drawArraysInstanced(C, 0, r, c) : this.aia_ext.drawArraysInstancedANGLE(C, 0, r, c), F.forEach((K) => {
              L.vertexAttribDivisor ? L.vertexAttribDivisor(K, null) : this.aia_ext && this.aia_ext.vertexAttribDivisorANGLE(K, null);
            })) : X ? L.drawElements(C, t, L.UNSIGNED_SHORT, 0) : L.drawArrays(C, 0, r);
          });
        }
        get isWebGL2() {
          return typeof WebGL2RenderingContext < "u" && this.gl instanceof WebGL2RenderingContext;
        }
        get enableTextures() {
          return this.program && this.program._enableTextures;
        }
        get uniforms() {
          const p = this.program;
          if (!p || !p.uniforms)
            throw Error("No avaliable program.");
          return p.uniforms;
        }
        deleteProgram(p) {
          const G = this.gl;
          this.program === p && (this.startRender = !1, this._renderFrameID && (cancelAnimationFrame(this._renderFrameID), delete this._renderFrameID), G.useProgram(null));
          const y = this.programs.indexOf(p);
          y >= 0 && this.programs.splice(y, 1), I(G, p), G.deleteProgram(p);
        }
        /**
          [{
            positions: ...
            cells: ...
            textureCoord: ...
            attributes: {name: {data:..., normalize: true}},
            uniforms: ...
          }]
         */
        setMeshData(p) {
          Array.isArray(p) || (p = [p]);
          const G = this.program;
          G.meshData = p.map(({
            mode: y,
            positions: Z,
            instanceCount: X,
            cells: c,
            cellsCount: t,
            attributes: R,
            uniforms: S,
            textureCoord: J,
            enableBlend: H
          }) => {
            const L = {
              positions: h.FLOAT(Z),
              uniforms: S,
              enableBlend: !!H,
              textureCoord: h.FLOAT(J)
            };
            if (c && (L.cells = h.USHORT(c), L.cellsCount = t || L.cells.length), y != null && (L.mode = y), X != null) {
              if (!this.isWebGL2 && !this.aia_ext)
                throw new Error("Cannot use instanceCount in this rendering context, use webgl2 context instead.");
              L.instanceCount = X;
            }
            if (R) {
              const C = {};
              Object.entries(R).forEach(([F, r]) => {
                if (!G._attribute[F])
                  G._attribute[F] = "ignored";
                else if (G._attribute[F] !== "ignored") {
                  const {
                    name: K,
                    type: g
                  } = G._attribute[F];
                  let v = r.data || r;
                  if (Array.isArray(v) && (v = h[g](v)), C[F] = {
                    name: K,
                    data: v
                  }, r.divisor != null) {
                    if (!this.isWebGL2 && !this.aia_ext)
                      throw new Error("Cannot use divisor in this rendering context, use webgl2 context instead.");
                    C[F].divisor = r.divisor;
                  }
                }
              }), L.attributes = C;
            }
            return L;
          }), this.options.autoUpdate && this.update();
        }
        createProgram(p, G) {
          const y = /^\s*uniform\s+sampler/mg.test(p);
          p == null && (p = m.default), G == null && (G = y ? o.default : b.default);
          const Z = this.gl, X = Object(i.createProgram)(Z, G, p);
          X.shaderText = {
            vertexShader: G,
            fragmentShader: p
          }, X._buffers = {}, X._attribute = {}, X.uniforms = {}, X._samplerMap = {}, X._bindTextures = [];
          const c = new RegExp(`(?:attribute|in) vec(\\d) ${this.options.vertexPosition}`, "im");
          let t = G.match(c);
          t && (X._dimension = Number(t[1]));
          const R = new RegExp(`(?:attribute|in) vec(\\d) ${this.options.vertexTextureCoord}`, "im");
          t = G.match(R), t && (X._texCoordSize = Number(t[1]));
          const S = /^\s*(?:attribute|in) (\w+?)(\d*) (\w+)/gim;
          if (t = G.match(S), t)
            for (let L = 0; L < t.length; L++) {
              const C = /^\s*(?:attribute|in) (\w+?)(\d*) (\w+)/im, F = t[L].match(C);
              if (F && F[3] !== this.options.vertexPosition && F[3] !== this.options.vertexTextureCoord) {
                let [, r, K, g] = F;
                r === "mat" && (K **= 2), X._buffers[g] = Z.createBuffer(), X._attribute[g] = {
                  name: g,
                  type: r,
                  size: Number(K) || 1
                };
              }
            }
          const J = /^\s*uniform\s+(\w+)\s+(\w+)(\[\d+\])?/mg;
          t = G.match(J) || [], t = t.concat(p.match(J) || []), t.forEach((L) => {
            const C = L.match(/^\s*uniform\s+(\w+)\s+(\w+)(\[\d+\])?/);
            let [F, r, K] = C.slice(1);
            F = V[F], K = !!K, F.indexOf("Matrix") !== 0 && K && (F += "v"), this._declareUniform(X, r, F);
          }), X._buffers.verticesBuffer = Z.createBuffer(), X._buffers.cellsBuffer = Z.createBuffer();
          const H = Z.getAttribLocation(X, this.options.vertexTextureCoord);
          return X._enableTextures = H >= 0, X._enableTextures && (X._buffers.texCoordBuffer = Z.createBuffer()), this.programs.push(X), X;
        }
        useProgram(p, G = {}) {
          this.startRender = !1, this._renderFrameID && (cancelAnimationFrame(this._renderFrameID), delete this._renderFrameID);
          const y = this.gl;
          y.useProgram(p);
          const Z = p._dimension;
          y.bindBuffer(y.ARRAY_BUFFER, p._buffers.verticesBuffer);
          const X = y.getAttribLocation(p, this.options.vertexPosition);
          if (y.vertexAttribPointer(X, Z, y.FLOAT, !1, 0, 0), y.enableVertexAttribArray(X), p._enableTextures) {
            y.bindBuffer(y.ARRAY_BUFFER, p._buffers.texCoordBuffer);
            const c = y.getAttribLocation(p, this.options.vertexTextureCoord);
            y.vertexAttribPointer(c, p._texCoordSize || 2, y.FLOAT, !1, 0, 0), y.enableVertexAttribArray(c);
          }
          if (Object.entries(p._attribute).forEach(([c, t]) => {
            if (t !== "ignored") {
              const R = t.size, S = G[c] || {}, J = !!S.normalize;
              let H = S.type || "FLOAT";
              const L = S.key || c;
              H === "UBYTE" && (H = "UNSIGNED_BYTE"), H === "USHORT" && (H = "UNSIGNED_SHORT"), t.type = H, L && L !== c && (p._attribute[L] = t), y.bindBuffer(y.ARRAY_BUFFER, p._buffers[c]);
              const C = y.getAttribLocation(p, c);
              C >= 0 && (y.vertexAttribPointer(C, R, y[H], J, 0, 0), y.enableVertexAttribArray(C));
            }
          }), !p.meshData) {
            const c = [[-1, -1, 0, 1].slice(0, Z), [1, -1, 0, 1].slice(0, Z), [1, 1, 0, 1].slice(0, Z), [-1, 1, 0, 1].slice(0, Z)], t = [[0, 1, 3], [3, 1, 2]];
            this.setMeshData({
              positions: c,
              cells: t
            });
          }
          return p;
        }
        compileSync(p, G) {
          p = p || m.default;
          const y = {};
          function Z(R) {
            R = R.replace(/^\s*/mg, "");
            const S = [], J = R.match(/^#pragma\s+include\s+.*/mg);
            if (J) {
              for (let H = 0; H < J.length; H++) {
                const C = J[H].match(/(?:<|")(.*)(?:>|")/);
                if (C) {
                  const F = C[0].indexOf("<") === 0 ? "lib" : "link";
                  let r = C[1];
                  if (r === "graph" && (r = "graphics"), y[r])
                    S.push(`/* included ${r} */`);
                  else if (y[r] = !0, F === "lib") {
                    const K = Z(W[r]);
                    S.push(K);
                  } else if (F === "link")
                    throw new Error("Cannot load external links synchronously. Use compile instead of compileSync.");
                }
              }
              S.forEach((H) => {
                R = R.replace(/^#pragma\s+include\s+.*/m, H);
              });
            }
            return R;
          }
          const X = Z(p), c = G ? Z(G) : null;
          return this.createProgram(X, c);
        }
        async compile(p, G) {
          p = p || m.default;
          const y = {};
          async function Z(R) {
            R = R.replace(/^\s*/mg, "");
            const S = [], J = R.match(/^#pragma\s+include\s+.*/mg);
            if (J) {
              for (let H = 0; H < J.length; H++) {
                const C = J[H].match(/(?:<|")(.*)(?:>|")/);
                if (C) {
                  const F = C[0].indexOf("<") === 0 ? "lib" : "link";
                  let r = C[1];
                  if (r === "graph" && (r = "graphics"), y[r])
                    S.push(`/* included ${r} */`);
                  else if (y[r] = !0, F === "lib") {
                    const K = await Z(W[r]);
                    S.push(K);
                  } else if (F === "link") {
                    let K = await h.fetchShader(r);
                    K = await Z(K), S.push(K);
                  }
                }
              }
              S.forEach((H) => {
                R = R.replace(/^#pragma\s+include\s+.*/m, H);
              });
            }
            return R;
          }
          const X = await Z(p), c = G ? await Z(G) : null;
          return this.createProgram(X, c);
        }
        async load(p, G = null) {
          return p = await h.fetchShader(p), G && (G = await h.fetchShader(G)), this.compile(p, G);
        }
        createTexture(p = null, {
          wrapS: G = this.gl.CLAMP_TO_EDGE,
          wrapT: y = this.gl.CLAMP_TO_EDGE,
          minFilter: Z = this.gl.LINEAR,
          magFilter: X = this.gl.LINEAR
        } = {}) {
          const c = this.gl, t = Array.isArray(p) ? c.TEXTURE_CUBE_MAP : c.TEXTURE_2D;
          this._max_texture_image_units = this._max_texture_image_units || c.getParameter(c.MAX_COMBINED_TEXTURE_IMAGE_UNITS), c.activeTexture(c.TEXTURE0 + this._max_texture_image_units - 1);
          const R = c.createTexture();
          c.bindTexture(t, R), c.pixelStorei(c.UNPACK_FLIP_Y_WEBGL, !0);
          const {
            width: S,
            height: J
          } = this.canvas;
          if (p)
            if (t === c.TEXTURE_CUBE_MAP)
              for (let H = 0; H < 6; H++)
                c.texImage2D(c.TEXTURE_CUBE_MAP_POSITIVE_X + H, 0, c.RGBA, c.RGBA, c.UNSIGNED_BYTE, p[H]);
            else
              c.texImage2D(t, 0, c.RGBA, c.RGBA, c.UNSIGNED_BYTE, p);
          else if (t === c.TEXTURE_CUBE_MAP)
            for (let H = 0; H < 6; H++)
              this.gl.texImage2D(this.gl.TEXTURE_CUBE_MAP_POSITIVE_X + H, 0, c.RGBA, S, J, 0, c.RGBA, c.UNSIGNED_BYTE, null);
          else
            c.texImage2D(t, 0, c.RGBA, S, J, 0, c.RGBA, c.UNSIGNED_BYTE, null);
          return c.texParameteri(t, c.TEXTURE_MIN_FILTER, Z), c.texParameteri(t, c.TEXTURE_MAG_FILTER, X), c.texParameteri(t, c.TEXTURE_WRAP_S, G), c.texParameteri(t, c.TEXTURE_WRAP_T, y), t === c.TEXTURE_CUBE_MAP && (p.width = p[0].width, p.height = p[0].height), c.bindTexture(t, null), R._img = p || {
            width: S,
            height: J
          }, R.delete = () => {
            this.deleteTexture(R);
          }, R;
        }
        deleteTexture(p) {
          const G = p._img;
          this.gl.deleteTexture(p), typeof G.close == "function" && G.close();
        }
        async loadTexture(p, {
          useImageBitmap: G = !0
        } = {}) {
          const y = await h.loadImage(p, {
            useImageBitmap: G
          });
          return this.createTexture(y);
        }
        createFBO({
          color: p = 1,
          blend: G = !1,
          depth: y = this.options.depth !== !1,
          stencil: Z = !!this.options.stencil
        } = {}) {
          const X = this.gl, c = X.createFramebuffer();
          X.bindFramebuffer(X.FRAMEBUFFER, c);
          const t = [];
          for (let J = 0; J < p; J++) {
            const H = this.createTexture();
            X.framebufferTexture2D(
              X.FRAMEBUFFER,
              X.COLOR_ATTACHMENT0 + J,
              X.TEXTURE_2D,
              H,
              0
              /* level */
            ), t.push(H);
          }
          c.textures = t, c.texture = t[0], c.blend = G;
          const {
            width: R,
            height: S
          } = this.canvas;
          return y && !Z && (c.depthBuffer = X.createRenderbuffer(), X.bindRenderbuffer(X.RENDERBUFFER, c.depthBuffer), X.renderbufferStorage(X.RENDERBUFFER, X.DEPTH_COMPONENT16, R, S), X.framebufferRenderbuffer(X.FRAMEBUFFER, X.DEPTH_ATTACHMENT, X.RENDERBUFFER, c.depthBuffer)), Z && !y && (c.stencilBuffer = X.createRenderbuffer(), X.bindRenderbuffer(X.RENDERBUFFER, c.stencilBuffer), X.renderbufferStorage(X.RENDERBUFFER, X.STENCIL_INDEX8, R, S), X.framebufferRenderbuffer(X.FRAMEBUFFER, X.STENCIL_ATTACHMENT, X.RENDERBUFFER, c.stencilBuffer)), y && Z && (c.depthStencilBuffer = X.createRenderbuffer(), X.bindRenderbuffer(X.RENDERBUFFER, c.depthStencilBuffer), X.renderbufferStorage(X.RENDERBUFFER, X.DEPTH_STENCIL, R, S), X.framebufferRenderbuffer(X.FRAMEBUFFER, X.DEPTH_STENCIL_ATTACHMENT, X.RENDERBUFFER, c.depthStencilBuffer)), X.bindFramebuffer(X.FRAMEBUFFER, null), c;
        }
        bindFBO(p = null) {
          this.fbo = p;
        }
        render({
          clearBuffer: p = !0
        } = {}) {
          this.startRender = !0;
          const G = this.gl;
          let y = this.program;
          y || (y = this.createProgram(), this.useProgram(y)), this.fbo && G.bindFramebuffer(G.FRAMEBUFFER, this.fbo);
          const Z = this.options.depth;
          Z && G.enable(G.DEPTH_TEST), this.gl.clear(this.gl.COLOR_BUFFER_BIT | (Z ? this.gl.DEPTH_BUFFER_BIT : 0) | (this.options.stencil ? this.gl.STENCIL_BUFFER_BIT : 0));
          const X = this._renderFrameID;
          this._draw(), this.fbo && G.bindFramebuffer(G.FRAMEBUFFER, null), this._renderFrameID === X && (this._renderFrameID = null);
        }
        update() {
          this.startRender && this._renderFrameID == null && (this._renderFrameID = requestAnimationFrame(this.render.bind(this)));
        }
      }
      n(h, "defaultOptions", {
        preserveDrawingBuffer: !0,
        autoUpdate: !0,
        vertexPosition: "a_vertexPosition",
        vertexTextureCoord: "a_vertexTextureCoord",
        webgl2: !1
      }), n(h, "UBYTE", h.UNSIGNED_BYTE), n(h, "USHORT", h.UNSIGNED_SHORT), n(h, "fetchShader", i.fetchShader), n(h, "loadImage", i.loadImage);
    },
    /* 16 */
    /***/
    function(s, l, d) {
      d.r(l), d.d(l, "setupWebGL", function() {
        return b;
      }), d.d(l, "createProgram", function() {
        return m;
      }), d.d(l, "pointsToBuffer", function() {
        return o;
      }), d.d(l, "loadImage", function() {
        return W;
      }), d.d(l, "fetchShader", function() {
        return I;
      }), d(1).glMatrix.setMatrixArrayType(Array);
      function i(a, V) {
        const h = ["webgl", "experimental-webgl", "webkit-3d", "moz-webgl"];
        let Y = null;
        for (let p = 0; p < h.length; ++p) {
          try {
            Y = a.getContext(h[p], V);
          } catch {
          }
          if (Y)
            break;
        }
        return Y;
      }
      function b(a, V) {
        const h = i(a, V);
        if (!h)
          throw new Error("Sorry, your browser doesn't support WebGL.");
        return h;
      }
      function m(a, V, h) {
        const Y = a.createShader(a.VERTEX_SHADER);
        if (a.shaderSource(Y, V), a.compileShader(Y), !a.getShaderParameter(Y, a.COMPILE_STATUS)) {
          const y = `Vertex shader failed to compile.  The error log is:${a.getShaderInfoLog(Y)}`;
          throw new Error(y);
        }
        const p = a.createShader(a.FRAGMENT_SHADER);
        if (a.shaderSource(p, h), a.compileShader(p), !a.getShaderParameter(p, a.COMPILE_STATUS)) {
          const y = `Fragment shader failed to compile.  The error log is:${a.getShaderInfoLog(p)}`;
          throw new Error(y);
        }
        const G = a.createProgram();
        if (a.attachShader(G, Y), a.attachShader(G, p), a.linkProgram(G), !a.getProgramParameter(G, a.LINK_STATUS)) {
          const y = `Shader program failed to link.  The error log is:${a.getProgramInfoLog(G)}`;
          throw new Error(y);
        }
        return a.deleteShader(Y), a.deleteShader(p), G;
      }
      function o(a, V = Float32Array, h = null) {
        if (h && !(h instanceof V))
          throw new TypeError("Wrong buffer type.");
        if (a == null || a instanceof V)
          return a;
        if (a[0] == null || a[0].length == null)
          return h ? (h.set(a, 0), h) : new V(a);
        const Y = a[0].length, p = a.length;
        h || (h = new V(Y * p));
        let G = 0;
        for (let y = 0; y < p; y++)
          for (let Z = 0; Z < Y; Z++)
            h[G++] = a[y][Z];
        return h;
      }
      const n = {};
      function W(a, {
        useImageBitmap: V = !0,
        alias: h = null
      } = {}) {
        if (!n[a]) {
          if (typeof Image == "function") {
            const Y = new Image();
            typeof a == "string" && !(typeof location == "object" && /^file:/.test(location.href)) && !/^data:/.test(a) && (Y.crossOrigin = "anonymous"), n[a] = new Promise((p) => {
              Y.onload = function() {
                V && typeof createImageBitmap == "function" ? createImageBitmap(Y, {
                  imageOrientation: "flipY"
                }).then((G) => {
                  n[a] = G, h && (n[h] = G), p(G);
                }) : (n[a] = Y, h && (n[h] = Y), p(Y));
              }, Y.src = a;
            }), h && (n[h] = n[a]);
          } else if (typeof fetch == "function")
            return fetch(a, {
              method: "GET",
              mode: "cors",
              cache: "default"
            }).then((Y) => Y.blob()).then((Y) => createImageBitmap(Y, {
              imageOrientation: "flipY"
            }).then((p) => (n[a] = p, h && (n[h] = p), p)));
        }
        return n[a];
      }
      const e = {};
      async function I(a) {
        if (e[a])
          return e[a];
        const V = await fetch(a);
        if (V.status >= 200 && V.status < 300) {
          const h = await V.text();
          return e[a] = h, h;
        }
        throw new Error("Shader loaded error.");
      }
    },
    /* 17 */
    /***/
    function(s, l, d) {
      d.r(l), l.default = `attribute vec3 a_vertexPosition;

void main() {
  gl_PointSize = 1.0;
  gl_Position = vec4(a_vertexPosition, 1);
}`;
    },
    /* 18 */
    /***/
    function(s, l, d) {
      d.r(l), l.default = `#ifdef GL_ES
precision mediump float;
#endif

void main() {
  gl_FragColor = vec4(0.0, 0.0, 0.0, 0.1);
}`;
    },
    /* 19 */
    /***/
    function(s, l, d) {
      d.r(l), l.default = `attribute vec4 a_vertexPosition;
attribute vec2 a_vertexTextureCoord;
varying vec2 vTextureCoord;

void main() {
  gl_PointSize = 1.0;
  gl_Position = a_vertexPosition;
  vTextureCoord = a_vertexTextureCoord;
}`;
    },
    /* 20 */
    /***/
    function(s, l, d) {
      d.r(l), d.d(l, "default", function() {
        return o;
      });
      var i = d(21), b = d(25);
      d(1).glMatrix.setMatrixArrayType(Array);
      const m = Symbol("transform");
      class o {
        constructor(W, e) {
          this.context = W.getContext("2d"), this.options = e, this[m] = [1, 0, 0, 1, 0, 0];
        }
        createTexture(W) {
          return {
            _img: W
          };
        }
        async loadTexture(W) {
          const e = await i.default.loadImage(W, {
            useImageBitmap: !1
          });
          return this.createTexture(e);
        }
        deleteTexture(W) {
          return W;
        }
        clear(W, e, I, a) {
          const V = this.context;
          W = W || 0, e = e || 0, I = I || V.canvas.width - W, a = a || V.canvas.height - e, V.clearRect(W, e, I, a);
        }
        drawMeshCloud(W, {
          clear: e = !1
        } = {}) {
          const I = [];
          for (let a = 0; a < W.amount; a++) {
            const V = W.getTransform(a);
            let h = W.getTextureFrame(a);
            h && (h = h._img);
            const Y = W.getFilter(a), {
              fill: p,
              stroke: G
            } = W.getCloudRGBA(a);
            I.push({
              mesh: W.mesh,
              _cloudOptions: [p, G, h, V, Y]
            });
          }
          W.beforeRender && W.beforeRender(this.context, W), this.drawMeshes(I, {
            clear: e,
            hook: !1
          }), W.afterRender && W.afterRender(this.context, W);
        }
        drawMeshes(W, {
          clear: e = !1,
          hook: I = !0
        } = {}) {
          const a = this.context;
          e && a.clearRect(0, 0, a.canvas.width, a.canvas.height);
          let V = null;
          const {
            width: h,
            height: Y
          } = a.canvas, p = W.length;
          W.forEach((G, y) => {
            let Z, X, c, t, R;
            I && G.beforeRender && G.beforeRender(a, G), G._cloudOptions && ([Z, X, c, t, R] = G._cloudOptions, G = G.mesh);
            let S = G.filter;
            if (R && (S = S ? `${S} ${R}` : R), S && !this.filterBuffer && this.filterBuffer !== !1) {
              const J = i.default.createCanvas(h, Y);
              J ? this.filterBuffer = J.getContext("2d") : this.filterBuffer = !1;
            }
            V && V !== S && (Object(b.applyFilter)(this.filterBuffer, V), a.drawImage(this.filterBuffer.canvas, 0, 0, h, Y), this.filterBuffer.clearRect(0, 0, h, Y), V = null), S && this.filterBuffer ? (this.filterBuffer.save(), this.filterBuffer.transform(...this[m]), Object(b.drawMesh2D)(G, this.filterBuffer, !1, Z, X, c, t), this.filterBuffer.restore(), y === p - 1 ? (Object(b.applyFilter)(this.filterBuffer, S), a.drawImage(this.filterBuffer.canvas, 0, 0, h, Y), this.filterBuffer.clearRect(0, 0, h, Y)) : V = S) : (a.save(), a.transform(...this[m]), Object(b.drawMesh2D)(G, a, !1, Z, X, c, t), a.restore()), I && G.afterRender && G.afterRender(a, G);
          });
        }
        setTransform(W) {
          this[m] = W;
        }
      }
    },
    /* 21 */
    /***/
    function(s, l, d) {
      d.r(l), (function(i) {
        var b = d(14), m = d(23), o = d(24);
        d(1).glMatrix.setMatrixArrayType(Array);
        const n = {};
        function W(h, Y) {
          const {
            style: p,
            variant: G,
            weight: y,
            stretch: Z,
            size: X,
            pxLineHeight: c,
            family: t
          } = h;
          return Z === "normal" ? `${p} ${G} ${y} ${X * Y}px/${c * Y}px ${t}` : `${p} ${G} ${y} ${Z} ${X * Y}px/${c * Y}px ${t}`;
        }
        function e(h, {
          font: Y,
          fillColor: p,
          strokeColor: G,
          strokeWidth: y,
          ratio: Z = 1,
          textCanvas: X,
          cachable: c = !1
        }) {
          let t;
          if (c) {
            t = [h, Y, String(p), String(G), String(y)].join("###");
            const v = n[t];
            if (v)
              return v;
          }
          X || (X = a(1, 1));
          const R = X.getContext("2d");
          R.save(), R.font = Y;
          let {
            width: S
          } = R.measureText(h);
          R.restore();
          const J = Object(m.default)(Y), H = Math.max(J.pxLineHeight, J.pxHeight * 1.13);
          /italic|oblique/.test(Y) && (S += H * Math.tan(15 * Math.PI / 180)), !p && !G && (p = "#000");
          const L = R.canvas, C = Math.ceil(S), F = Math.ceil(H);
          L.width = Math.round(C * Z), L.height = Math.round(F * Z), R.save(), R.font = W(J, Z), R.textAlign = "center", R.textBaseline = "middle";
          const r = L.height * 0.5 + J.pxHeight * 0.05 * Z, K = L.width * 0.5;
          if (p) {
            if (Array.isArray(p))
              p = Object(o.default)(p);
            else if (p.vector) {
              let v;
              const {
                vector: f,
                colors: O
              } = p;
              f.length === 6 ? v = R.createRadialGradient(...f) : v = R.createLinearGradient(...f), O.forEach(({
                offset: q,
                color: M
              }) => {
                v.addColorStop(q, M);
              }), p = v;
            }
            R.fillStyle = p, R.fillText(h, K, r);
          }
          if (G) {
            if (R.lineWidth = y * Z, Array.isArray(G))
              G = Object(o.default)(G);
            else if (G.vector) {
              let v;
              const {
                vector: f,
                colors: O
              } = G;
              f.length === 6 ? v = R.createRadialGradient(...f) : v = R.createLinearGradient(...f), O.forEach(({
                offset: q,
                color: M
              }) => {
                v.addColorStop(q, M);
              }), G = v;
            }
            R.strokeStyle = G, R.strokeText(h, K, r);
          }
          R.restore();
          const g = {
            image: X,
            rect: [0, 0, C, F]
          };
          return c && (n[t] = g), g;
        }
        let I = !1;
        if (typeof navigator == "object" && typeof navigator.userAgent == "string") {
          const h = navigator.userAgent.toLowerCase().match(/chrome\/(\d+)/);
          h && (I = Number(h[1]) < 70);
        }
        function a(h, Y, p = {}) {
          const G = p.offscreen || !I && p.offscreen !== !1;
          let y;
          return typeof i < "u" && typeof i.createCanvas == "function" ? y = i.createCanvas(h, Y, p) : G && typeof OffscreenCanvas == "function" ? y = new OffscreenCanvas(h, Y) : (y = document.createElement("canvas"), y.width = h, y.height = Y), y;
        }
        const V = {
          createCanvas: a,
          createText: e,
          loadImage: b.default.loadImage
        };
        l.default = V;
      }).call(this, d(22));
    },
    /* 22 */
    /***/
    function(s, l) {
      var d;
      d = /* @__PURE__ */ function() {
        return this;
      }();
      try {
        d = d || new Function("return this")();
      } catch {
        typeof window == "object" && (d = window);
      }
      s.exports = d;
    },
    /* 23 */
    /***/
    function(s, l, d) {
      d.r(l), d.d(l, "default", function() {
        return p;
      }), d(1).glMatrix.setMatrixArrayType(Array);
      function i(G, y) {
        if (typeof G == "string") {
          const c = G.trim().match(/^([\d.]+)(px|pt|pc|in|cm|mm|em|ex|rem|q|vw|vh|vmax|vmin|%)$/);
          c ? G = {
            size: parseFloat(c[1]),
            unit: c[2]
          } : G = {
            size: parseInt(G, 10),
            unit: "px"
          };
        }
        let {
          size: Z,
          unit: X
        } = G;
        if (X === "pt")
          Z /= 0.75;
        else if (X === "pc")
          Z *= 16;
        else if (X === "in")
          Z *= 96;
        else if (X === "cm")
          Z *= 96 / 2.54;
        else if (X === "mm")
          Z *= 96 / 25.4;
        else if (X === "em" || X === "rem" || X === "ex") {
          if (!y && typeof getComputedStyle == "function" && typeof document < "u") {
            const c = getComputedStyle(document.documentElement).fontSize;
            y = i(c, 16);
          }
          Z *= y, X === "ex" && (Z /= 2);
        } else if (X === "q")
          Z *= 96 / 25.4 / 4;
        else if (X === "vw" || X === "vh") {
          if (typeof document < "u") {
            const c = X === "vw" ? document.documentElement.clientWidth : document.documentElement.clientHeight;
            Z *= c / 100;
          }
        } else if ((X === "vmax" || X === "vmin") && typeof document < "u") {
          const c = document.documentElement.clientWidth, t = document.documentElement.clientHeight;
          X === "vmax" ? Z *= Math.max(c, t) / 100 : Z *= Math.min(c, t) / 100;
        }
        return Z;
      }
      const b = "bold|bolder|lighter|[1-9]00", m = "italic|oblique", o = "small-caps", n = "ultra-condensed|extra-condensed|condensed|semi-condensed|semi-expanded|expanded|extra-expanded|ultra-expanded", W = "px|pt|pc|in|cm|mm|em|ex|rem|q|vw|vh|vmax|vmin|%", e = `'([^']+)'|"([^"]+)"|([\\w-]|[一-龥])+`, I = new RegExp(`(${b}) +`, "i"), a = new RegExp(`(${m}) +`, "i"), V = new RegExp(`(${o}) +`, "i"), h = new RegExp(`(${n}) +`, "i"), Y = new RegExp("([\\d\\.]+)(" + W + ")(?:\\/([\\d\\.]+)(" + W + "))? *((?:" + e + ")( *, *(?:" + e + "))*)");
      function p(G, y) {
        const Z = Y.exec(G);
        if (!Z)
          return;
        const X = parseFloat(Z[3]), c = {
          weight: "normal",
          style: "normal",
          stretch: "normal",
          variant: "normal",
          size: parseFloat(Z[1]),
          unit: Z[2],
          lineHeight: Number.isFinite(X) ? X : void 0,
          lineHeightUnit: Z[4],
          family: Z[5].replace(/ *, */g, ",")
        }, t = G.substring(0, Z.index), R = I.exec(t), S = a.exec(t), J = V.exec(t), H = h.exec(t);
        return R && (c.weight = R[1]), S && (c.style = S[1]), J && (c.variant = J[1]), H && (c.stretch = H[1]), c.pxHeight = i({
          size: c.size,
          unit: c.unit
        }, y), c.pxLineHeight = i({
          size: c.lineHeight || c.size,
          unit: c.lineHeightUnit || c.unit
        }, y), c;
      }
    },
    /* 24 */
    /***/
    function(s, l, d) {
      d.r(l), d.d(l, "default", function() {
        return i;
      }), d(1).glMatrix.setMatrixArrayType(Array);
      function i(b) {
        return `rgba(${b.map((m, o) => o < 3 ? Math.round(m * 255) : m).join()})`;
      }
    },
    /* 25 */
    /***/
    function(s, l, d) {
      d.r(l), d.d(l, "applyFilter", function() {
        return n;
      }), d.d(l, "drawMesh2D", function() {
        return e;
      });
      var i = d(1), b = d(24), m = d(23), o = d(26);
      d(1).glMatrix.setMatrixArrayType(Array);
      function n(I, a) {
        const V = I.canvas;
        I.save(), I.filter = a, I.drawImage(V, 0, 0, V.width, V.height), I.restore();
      }
      function W(I, a) {
        const V = /rgba\((\d+),(\d+),(\d+),(\d+)\)/;
        I = I.match(V).slice(1, 5).map(Number), a = a.match(V).slice(1, 5).map(Number);
        const h = [], Y = a[3];
        for (let p = 0; p < 4; p++)
          h[p] = Object(o.mix)(I[p], a[p], Y);
        return `rgba(${h.join()})`;
      }
      function e(I, a, V = !0, h = null, Y = null, p = null, G = null) {
        a.save();
        let y = !1, Z = !1;
        if (a.globalAlpha = I.getOpacity(), I._updateMatrix && I.transformScale / I.contours.scale > 1.5 && I.accurate(I.transformScale), I.lineWidth) {
          let t = I.gradient && I.gradient.stroke;
          if (t) {
            const {
              vector: R,
              colors: S
            } = t;
            if (R.length === 6)
              t = a.createRadialGradient(...R);
            else if (R.length === 4)
              t = a.createLinearGradient(...R);
            else if (R.length === 3)
              t = a.createCircularGradient(...R);
            else
              throw new TypeError("Invalid vector dimension.");
            S.forEach(({
              offset: J,
              color: H
            }) => {
              let L = Object(b.default)(H);
              Y && (L = W(L, Y)), t.addColorStop(J, L);
            }), a.strokeStyle = t, y = !0;
          } else
            I.strokeStyle && (Y ? a.strokeStyle = W(I.strokeStyle, Y) : a.strokeStyle = I.strokeStyle, y = !0);
        }
        y && (a.lineWidth = I.lineWidth, a.lineJoin = I.lineJoin, a.lineCap = I.lineCap, a.miterLimit = I.miterLimit, I.lineDash && (a.setLineDash(I.lineDash), I.lineDashOffset && (a.lineDashOffset = I.lineDashOffset)));
        let X = I.gradient && I.gradient.fill;
        if (X) {
          const {
            vector: t,
            colors: R
          } = X;
          if (t.length === 6)
            X = a.createRadialGradient(...t);
          else if (t.length === 4)
            X = a.createLinearGradient(...t);
          else if (t.length === 3)
            X = a.createCircularGradient(...t);
          else
            throw new TypeError("Invalid vector dimension.");
          R.forEach(({
            offset: S,
            color: J
          }) => {
            let H = Object(b.default)(J);
            Y && (H = W(H, Y)), X.addColorStop(S, H);
          }), a.fillStyle = X, Z = !0;
        } else
          I.fillStyle && (h ? a.fillStyle = W(I.fillStyle, h) : a.fillStyle = I.fillStyle, Z = !0);
        if (G && a.transform(...G), a.transform(...I.transformMatrix), I.clipPath) {
          const t = I.clipPath, R = new Path2D(t);
          a.clip(R);
        }
        const c = I.contours.length;
        if (I.contours.forEach((t, R) => {
          const S = t.length, J = S > 1 && i.vec2.equals(t[0], t[S - 1]), H = R === c - 1 && I.texture;
          if (t && S > 0) {
            if (Z || y || H) {
              a.beginPath(), a.moveTo(...t[0]);
              for (let L = 1; L < S; L++)
                L === S - 1 && J ? a.closePath() : a.lineTo(...t[L]);
            }
            if (Z && a.fill(I.fillRule), H) {
              a.save(), a.clip();
              let {
                image: L,
                options: C
              } = I.texture;
              if (p && (L = p), C.repeat && console.warn("Context 2D not supported image repeat yet."), L.font) {
                C.scale && console.warn("Context 2D not supported text scale yet."), C.srcRect && console.warn("Context 2D not supported text srcRect yet.");
                let {
                  font: F,
                  fillColor: r,
                  strokeColor: K,
                  strokeWidth: g,
                  text: v
                } = L;
                !r && !K && (r = "#000"), Array.isArray(r) && (r = Object(b.default)(r)), Array.isArray(K) && (K = Object(b.default)(K)), a.font = F;
                const {
                  width: f
                } = a.measureText(v), O = Object(m.default)(F), q = Math.max(O.pxLineHeight, O.pxHeight * 1.13);
                a.textAlign = "center", a.textBaseline = "middle";
                const M = C.rect, P = M[0] + q * 0.5 + O.pxHeight * 0.06, D = M[1] + f * 0.5;
                M[2] != null && a.scale(M[2] / f, M[3] / q), r && (a.fillStyle = r, a.fillText(v, D, P)), K && (a.lineWidth = g, a.strokeStyle = K, a.strokeText(v, D, P));
              } else {
                let F = C.rect;
                const r = C.srcRect;
                C.scale && (F = [0, 0, a.canvas.width, a.canvas.height]), C.rotated && F && (F = [-F[1], F[0], F[3], F[2]]), r && (F = F || [0, 0, r[2], r[3]]), C.rotated && (a.translate(0, F ? F[2] : L.width), a.rotate(-0.5 * Math.PI)), r ? a.drawImage(L, ...r, ...F) : F ? a.drawImage(L, ...F) : a.drawImage(L, 0, 0);
              }
              a.restore();
            }
            y && a.stroke();
          }
        }), a.restore(), V) {
          const t = I.filter;
          t && n(a, t);
        }
      }
    },
    /* 26 */
    /***/
    function(s, l, d) {
      d.r(l), d.d(l, "clamp", function() {
        return i;
      }), d.d(l, "mix", function() {
        return b;
      }), d.d(l, "transformPoint", function() {
        return m;
      }), d(1).glMatrix.setMatrixArrayType(Array);
      function i(o, n, W) {
        return n > W && ([n, W] = [W, n]), o < n ? n : o > W ? W : o;
      }
      function b(o, n, W) {
        return o * (1 - W) + n * W;
      }
      function m(o, n) {
        const [W, e] = o;
        return [W * n[0] + e * n[2] + n[4], W * n[1] + e * n[3] + n[5]];
      }
    },
    /* 27 */
    /***/
    function(s, l, d) {
      d.r(l), d.d(l, "default", function() {
        return W;
      });
      var i = d(28), b = d(29);
      d(1).glMatrix.setMatrixArrayType(Array);
      function m(e, I, a) {
        const V = e.uniforms || {}, h = I.uniforms || {};
        if (V.u_texSampler && h.u_texSampler && V.u_texSampler !== h.u_texSampler)
          return !1;
        const Y = Object.keys(V), p = Object.keys(h), G = Y.indexOf("u_texSampler"), y = p.indexOf("u_texSampler");
        if (G >= 0 && Y.splice(G, 1), y >= 0 && p.splice(y, 1), Y.length !== p.length)
          return !1;
        const Z = Y.every((X) => {
          const c = V[X], t = h[X];
          if (c === t)
            return !0;
          if (c.length && t.length && c.length === t.length) {
            for (let R = 0; R < c.length; R++)
              if (c[R] !== t[R])
                return !1;
            return !0;
          }
          return !1;
        });
        if (Z) {
          if (V.u_texSampler && !h.u_texSampler)
            I.setTexture(V.u_texSampler, {
              hidden: !0
            });
          else if (!V.u_texSampler && h.u_texSampler)
            for (let X = 0; X < a.length; X++)
              a[X].setTexture(h.u_texSampler, {
                hidden: !0
              });
        }
        return Z;
      }
      const o = {};
      function n(e, I) {
        if (e.length) {
          const a = Object(i.default)(e, o);
          return a.enableBlend = I, e[0].filterCanvas && (a.filterCanvas = !0), a.packIndex = e[0].packIndex, a.packLength = e.length, a.beforeRender = e[0].beforeRender, a.pass = e[0].pass, a.afterRender = e[e.length - 1].afterRender, e.length = 0, a;
        }
      }
      function* W(e, I, a = !1) {
        const V = [], h = e.options.bufferSize;
        let Y = 0, p = !1;
        for (let G = 0; G < I.length; G++) {
          const y = I[G];
          if (y instanceof b.default)
            V.length && (yield n(V, p)), Y = 0, p = !1, yield y;
          else {
            const Z = y.meshData;
            if (Z.clipPath && !Z.uniforms.u_clipSampler) {
              const c = e.createTexture(Z.clipPath);
              Z.uniforms.u_clipSampler = c;
            }
            let X = 0;
            if ((!a || !y.canIgnore()) && Z && Z.positions.length) {
              y.packIndex = G;
              const c = y.filterCanvas;
              if (X = Z.positions.length, c || Y + X > h)
                V.length && (yield n(V, p)), Y = 0, p = !1;
              else if (Y) {
                const t = V[V.length - 1];
                t && (t.filterCanvas || t.afterRender || y.beforeRender || t.pass.length || y.pass.length || t.program !== y.program || !m(t, y, V)) && (yield n(V, p), Y = 0, p = !1);
              }
              V.push(y), p = p || y.enableBlend, Y += X;
            }
            G === I.length - 1 && V.length && (yield n(V, p));
          }
        }
      }
    },
    /* 28 */
    /***/
    function(s, l, d) {
      d.r(l), d.d(l, "default", function() {
        return m;
      }), d(1).glMatrix.setMatrixArrayType(Array);
      const i = {
        UNSIGNED_BYTE: Uint8Array,
        UNSIGNED_SHORT: Uint16Array,
        BYTE: Int8Array,
        SHORT: Int16Array,
        FLOAT: Float32Array
      };
      function b(o, n) {
        let W = 0, e = 0, I = 0, a = 0, V = 0, h = 0, Y = 0;
        const p = o[0].program;
        for (let G = 0; G < o.length; G++) {
          const y = o[G].meshData;
          if (y) {
            Y += y.positions.length;
            const Z = y.positions[0].length;
            W += y.positions.length * Z, e += y.cells.length * 3, h += y.attributes.a_color.length * 4;
            const X = y.textureCoord;
            X && (I += X.length * X[0].length);
            const c = y.attributes.a_sourceRect;
            c && (a += c.length * 4);
            const t = y.attributes.a_clipUV;
            t && (V += t.length * 2);
          }
        }
        if ((!n.positions || n.positions.length < W) && (n.positions = new Float32Array(W)), (!n.cells || n.cells.length < e) && (n.cells = new Uint16Array(e)), I && (!n.textureCoord || n.textureCoord.length < I) && (n.textureCoord = new Float32Array(I)), (!n.a_color || n.a_color.length < h) && (n.a_color = new Uint8Array(h)), a && (!n.a_sourceRect || n.a_sourceRect.length < a) && (n.a_sourceRect = new Float32Array(a)), V && (!n.a_clipUV || n.a_clipUV.length < V) && (n.a_clipUV = new Float32Array(V)), p) {
          const G = Object.entries(p._attribute), y = p._attribOpts || {};
          for (let Z = 0; Z < G.length; Z++) {
            const [X, c] = G[Z];
            if (X !== "a_color" && X !== "a_sourceRect" && c !== "ignored") {
              const t = y[X] ? y[X].type : "FLOAT", R = i[t], S = c.size * Y;
              (!n[X] || n[X].length < S) && (n[X] = new R(S));
            }
          }
        }
        return n;
      }
      function m(o, n) {
        let W = [], e = [], I = [], a = [], V = [], h = [], Y = 0, p = 0;
        const G = o[0] ? o[0].uniforms || {} : {}, y = o[0] ? o[0].program : null;
        n && (b(o, n), e = n.cells, W = n.positions, I = n.textureCoord, a = n.a_color, V = n.a_sourceRect, h = n.a_clipUV);
        let Z = !1, X = !1;
        const c = {};
        for (let R = 0; R < o.length; R++) {
          let S = o[R];
          if (S) {
            if (S.meshData && (S = S.meshData), n) {
              const H = S.positions;
              for (let L = 0; L < H.length; L++) {
                const C = H[L], F = 3 * (Y + L);
                for (let r = 0; r < C.length; r++)
                  W[F + r] = C[r];
              }
            } else
              W.push(...S.positions);
            const J = S.cells;
            for (let H = 0; H < J.length; H++) {
              const L = J[H];
              if (n) {
                const C = 3 * (p + H);
                e[C] = L[0] + Y, e[C + 1] = L[1] + Y, e[C + 2] = L[2] + Y;
              } else
                e.push([L[0] + Y, L[1] + Y, L[2] + Y]);
            }
            if (n) {
              const H = S.attributes.a_color;
              for (let L = 0; L < H.length; L++) {
                const C = H[L], F = 4 * (Y + L);
                a[F] = C[0], a[F + 1] = C[1], a[F + 2] = C[2], a[F + 3] = C[3];
              }
            } else
              a.push(...S.attributes.a_color);
            if (S.attributes.a_sourceRect)
              if (Z = !0, n) {
                const H = S.attributes.a_sourceRect;
                for (let L = 0; L < H.length; L++) {
                  const C = H[L], F = 4 * (Y + L);
                  V[F] = C[0], V[F + 1] = C[1], V[F + 2] = C[2], V[F + 3] = C[3];
                }
              } else
                V.push(...S.attributes.a_sourceRect);
            if (S.attributes.a_clipUV)
              if (X = !0, n) {
                const H = S.attributes.a_clipUV;
                for (let L = 0; L < H.length; L++) {
                  const C = H[L], F = 2 * (Y + L);
                  h[F] = C[0], h[F + 1] = C[1];
                }
              } else
                h.push(...S.attributes.a_clipUV);
            if (S.textureCoord)
              if (n) {
                const H = S.textureCoord;
                for (let L = 0; L < H.length; L++) {
                  const C = H[L], F = 3 * (Y + L);
                  for (let r = 0; r < C.length; r++)
                    I[F + r] = C[r];
                }
              } else
                I.push(...S.textureCoord);
            if (y) {
              const H = Object.entries(y._attribute);
              for (let L = 0; L < H.length; L++) {
                const [C, F] = H[L];
                if (C !== "a_color" && C !== "a_sourceRect" && F !== "ignored")
                  if (c[C] = [], n) {
                    c[C] = n[C];
                    const r = S.attributes[C], K = r[0].length;
                    for (let g = 0; g < r.length; g++) {
                      const v = r[g], f = K * (Y + g);
                      for (let O = 0; O < v.length; O++)
                        c[C][f + O] = v[O];
                    }
                  } else
                    c[C].push(...S.attributes[C]);
              }
            }
            Y += S.positions.length, p += S.cells.length;
          }
        }
        c.a_color = a, Z && V && V.length > 0 && (c.a_sourceRect = V);
        const t = {
          positions: W,
          cells: e,
          attributes: c,
          uniforms: G,
          cellsCount: p * 3,
          program: y
        };
        return I && I.length && (t.textureCoord = I), X && h.length > 0 && (c.a_clipUV = h), t;
      }
    },
    /* 29 */
    /***/
    function(s, l, d) {
      d.r(l);
      var i = d(1), b = d(30), m = d(26), o = d(31);
      d(1).glMatrix.setMatrixArrayType(Array);
      function n(c, t) {
        var R = Object.keys(c);
        if (Object.getOwnPropertySymbols) {
          var S = Object.getOwnPropertySymbols(c);
          t && (S = S.filter(function(J) {
            return Object.getOwnPropertyDescriptor(c, J).enumerable;
          })), R.push.apply(R, S);
        }
        return R;
      }
      function W(c) {
        for (var t = 1; t < arguments.length; t++) {
          var R = arguments[t] != null ? arguments[t] : {};
          t % 2 ? n(Object(R), !0).forEach(function(S) {
            e(c, S, R[S]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(c, Object.getOwnPropertyDescriptors(R)) : n(Object(R)).forEach(function(S) {
            Object.defineProperty(c, S, Object.getOwnPropertyDescriptor(R, S));
          });
        }
        return c;
      }
      function e(c, t, R) {
        return t in c ? Object.defineProperty(c, t, { value: R, enumerable: !0, configurable: !0, writable: !0 }) : c[t] = R, c;
      }
      const I = Symbol("mesh"), a = Symbol("count"), V = Symbol("blend"), h = Symbol("filter"), Y = Symbol("textures"), p = Symbol("textureOptions"), G = Symbol("cloudColor"), y = Symbol("cloudFilter"), Z = Symbol("buffer");
      function X(c, t = null) {
        const R = new Float32Array(3 * c), S = new Float32Array(3 * c), J = new Float32Array(4 * c), H = new Float32Array(4 * c), L = new Float32Array(4 * c), C = new Float32Array(4 * c), F = new Float32Array(4 * c), r = new Uint8Array(c), K = new Uint8Array(4 * c), g = new Uint8Array(4 * c);
        return t && (R.set(t.transform0, 0), S.set(t.transform1, 0), J.set(t.color0, 0), H.set(t.color1, 0), L.set(t.color2, 0), C.set(t.color3, 0), F.set(t.color4, 0), r.set(t.frameIndex, 0), K.set(t.fillColor, 0), g.set(t.strokeColor, 0)), {
          bufferSize: c,
          transform0: R,
          transform1: S,
          color0: J,
          color1: H,
          color2: L,
          color3: C,
          color4: F,
          frameIndex: r,
          fillColor: K,
          strokeColor: g
        };
      }
      l.default = class {
        constructor(c, t = 1, {
          buffer: R = 1e3
        } = {}) {
          R = Math.max(R, t), this[a] = t, this[I] = c, this[Z] = X(R), this[Y] = [], this[h] = [], this[G] = !1, this[y] = !1, this[V] = !1, this.initBuffer();
        }
        initBuffer(c = 0) {
          const t = this[a];
          for (let R = c; R < t; R++)
            this[Z].transform0.set([1, 0, 0], R * 3), this[Z].transform1.set([0, 1, 0], R * 3), this[Z].frameIndex.set([-1], R), this[Z].fillColor.set([0, 0, 0, 0], R * 4), this[Z].strokeColor.set([0, 0, 0, 0], R * 4), this.setColorTransform(R, null);
        }
        get bufferSize() {
          return this[Z].bufferSize;
        }
        get mesh() {
          return this[I];
        }
        set mesh(c) {
          this[I] = c, this[Y] && this.setTextureFrames(this[Y], this[p]);
        }
        get hasCloudColor() {
          return this[G];
        }
        get hasCloudFilter() {
          return this[y];
        }
        _getFilter(c) {
          return this[h][c] = this[h][c] || [], this[h][c];
        }
        getFilter(c) {
          return this._getFilter(c).join(" ");
        }
        get enableBlend() {
          return this[I].enableBlend || this[V];
        }
        canIgnore() {
          return this[I].canIgnore();
        }
        delete(c) {
          if (c >= this[a] || c < 0)
            throw new Error("Out of range.");
          const {
            transform0: t,
            transform1: R,
            color0: S,
            color1: J,
            color2: H,
            color3: L,
            color4: C,
            frameIndex: F,
            fillColor: r,
            strokeColor: K
          } = this[Z];
          t.set(t.subarray(3 * (c + 1)), 3 * c), R.set(R.subarray(3 * (c + 1)), 3 * c), S.set(S.subarray(4 * (c + 1)), 4 * c), J.set(J.subarray(4 * (c + 1)), 4 * c), H.set(H.subarray(4 * (c + 1)), 4 * c), L.set(L.subarray(4 * (c + 1)), 4 * c), C.set(C.subarray(4 * (c + 1)), 4 * c), F.set(F.subarray(c + 1), c), r.set(r.subarray(4 * (c + 1)), 4 * c), K.set(K.subarray(4 * (c + 1)), 4 * c);
          for (const g in this[h])
            g === c ? delete this[h][g] : g > c && (this[h][g - 1] = this[h][g], delete this[h][g]);
          this[a]--;
        }
        setColorTransform(c, t) {
          if (c >= this[a] || c < 0)
            throw new Error("Out of range.");
          c *= 4;
          const {
            color0: R,
            color1: S,
            color2: J,
            color3: H,
            color4: L
          } = this[Z];
          return t != null ? (R.set([t[0], t[5], t[10], t[15]], c), S.set([t[1], t[6], t[11], t[16]], c), J.set([t[2], t[7], t[12], t[17]], c), H.set([t[3], t[8], t[13], t[18]], c), L.set([t[4], t[9], t[14], t[19]], c), this[V] = this[V] || t[18] < 1, this[y] = !0) : (R.set([1, 0, 0, 0], c), S.set([0, 1, 0, 0], c), J.set([0, 0, 1, 0], c), H.set([0, 0, 0, 1], c), L.set([0, 0, 0, 0], c)), this;
        }
        getColorTransform(c) {
          if (c >= this[a] || c < 0)
            throw new Error("Out of range.");
          c *= 4;
          const {
            color0: t,
            color1: R,
            color2: S,
            color3: J,
            color4: H
          } = this[Z];
          return [t[c], R[c], S[c], J[c], H[c], t[c + 1], R[c + 1], S[c + 1], J[c + 1], H[c + 1], t[c + 2], R[c + 2], S[c + 2], J[c + 2], H[c + 2], t[c + 3], R[c + 3], S[c + 3], J[c + 3], H[c + 3]];
        }
        transformColor(c, t) {
          let R = this.getColorTransform(c);
          return R = Object(b.multiply)(R, t), this.setColorTransform(c, R), this;
        }
        setFillColor(c, t) {
          if (c >= this[a] || c < 0)
            throw new Error("Out of range.");
          typeof t == "string" && (t = Object(o.default)(t)), t[3] > 0 && (this[G] = !0), this[Z].fillColor.set(t.map((R) => Math.round(255 * R)), 4 * c);
        }
        setStrokeColor(c, t) {
          if (c >= this[a] || c < 0)
            throw new Error("Out of range.");
          typeof t == "string" && (t = Object(o.default)(t)), t[3] > 0 && (this[G] = !0), this[Z].strokeColor.set(t.map((R) => Math.round(255 * R)), 4 * c);
        }
        getCloudRGBA(c) {
          if (c >= this[a] || c < 0)
            throw new Error("Out of range.");
          c *= 4;
          const {
            fillColor: t,
            strokeColor: R
          } = this[Z], S = [t[c], t[c + 1], t[c + 2], t[c + 3]], J = [R[c], R[c + 1], R[c + 2], R[c + 3]];
          return S[3] /= 255, J[3] /= 255, {
            fill: `rgba(${S.join()})`,
            stroke: `rgba(${J.join()})`
          };
        }
        grayscale(c, t) {
          this.transformColor(c, Object(b.grayscale)(t)), this._getFilter(c).push(`grayscale(${100 * t}%)`);
        }
        brightness(c, t) {
          this.transformColor(c, Object(b.brightness)(t)), this._getFilter(c).push(`brightness(${100 * t}%)`);
        }
        saturate(c, t) {
          this.transformColor(c, Object(b.saturate)(t)), this._getFilter(c).push(`saturate(${100 * t}%)`);
        }
        contrast(c, t) {
          this.transformColor(c, Object(b.contrast)(t)), this._getFilter(c).push(`contrast(${100 * t}%)`);
        }
        invert(c, t) {
          this.transformColor(c, Object(b.invert)(t)), this._getFilter(c).push(`invert(${100 * t}%)`);
        }
        sepia(c, t) {
          this.transformColor(c, Object(b.sepia)(t)), this._getFilter(c).push(`sepia(${100 * t}%)`);
        }
        opacity(c, t) {
          this.transformColor(c, Object(b.opacity)(t)), this._getFilter(c).push(`opacity(${100 * t}%)`);
        }
        hueRotate(c, t) {
          this.transformColor(c, Object(b.hueRotate)(t)), this._getFilter(c).push(`hue-rotate(${t}deg)`);
        }
        setTransform(c, t) {
          if (c >= this[a] || c < 0)
            throw new Error("Out of range.");
          c *= 3, t == null && (t = [1, 0, 0, 1, 0, 0]);
          const {
            transform0: R,
            transform1: S
          } = this[Z];
          return R.set([t[0], t[2], t[4]], c), S.set([t[1], t[3], t[5]], c), this;
        }
        getTransform(c) {
          if (c >= this[a] || c < 0)
            throw new Error("Out of range.");
          c *= 3;
          const {
            transform0: t,
            transform1: R
          } = this[Z];
          return [t[c], R[c], t[c + 1], R[c + 1], t[c + 2], R[c + 2]];
        }
        getTextureFrame(c) {
          return this[Y][this[Z].frameIndex[c]];
        }
        setTextureFrames(c = [], t = {}) {
          if (c.length > 12)
            throw new Error("Max frames exceed. Allow 12 frames.");
          c.length && this[I].setTexture(c[0], t), this[Y] = c, this[p] = t;
        }
        setFrameIndex(c, t) {
          if (c >= this[a] || c < 0)
            throw new Error("Out of range.");
          const R = this[Y].length;
          if (R <= 0)
            throw new Error("No frames");
          this[Z].frameIndex[c] = t % R;
        }
        get amount() {
          return this[a];
        }
        set amount(c) {
          const t = this[a];
          c !== t && (c > this[Z].bufferSize && (this[Z] = X(Math.max(c, this[Z].bufferSize + 1e3), this[Z])), this[a] = c, c > t && this.initBuffer(t));
        }
        get meshData() {
          const {
            attributes: c,
            cells: t,
            positions: R,
            textureCoord: S,
            uniforms: J
          } = this[I].meshData, H = this[Y], L = {
            attributes: W({}, c),
            cells: t,
            positions: R,
            textureCoord: S,
            uniforms: W({}, J),
            instanceCount: this[a],
            enableBlend: this.enableBlend
          };
          H.length && H.forEach((P, D) => {
            L.uniforms[`u_texFrame${D}`] = P;
          });
          const {
            transform0: C,
            transform1: F,
            color0: r,
            color1: K,
            color2: g,
            color3: v,
            color4: f,
            fillColor: O,
            strokeColor: q,
            frameIndex: M
          } = this[Z];
          return this[I].uniforms.u_texSampler && (L.attributes.a_frameIndex = {
            data: M,
            divisor: 1
          }), L.attributes.a_transform0 = {
            data: C,
            divisor: 1
          }, L.attributes.a_transform1 = {
            data: F,
            divisor: 1
          }, L.attributes.a_colorCloud0 = {
            data: r,
            divisor: 1
          }, L.attributes.a_colorCloud1 = {
            data: K,
            divisor: 1
          }, L.attributes.a_colorCloud2 = {
            data: g,
            divisor: 1
          }, L.attributes.a_colorCloud3 = {
            data: v,
            divisor: 1
          }, L.attributes.a_colorCloud4 = {
            data: f,
            divisor: 1
          }, this.hasCloudColor && (L.attributes.a_fillCloudColor = {
            data: O,
            divisor: 1
          }, L.attributes.a_strokeCloudColor = {
            data: q,
            divisor: 1
          }), L;
        }
        setProgram(c) {
          this[I].setProgram(c);
        }
        get program() {
          return this[I].program;
        }
        transform(c, t) {
          const R = this.getTransform(c);
          return t = i.mat2d.multiply(Array.of(0, 0, 0, 0, 0, 0), R, t), this.setTransform(c, t), this;
        }
        translate(c, [t, R]) {
          let S = i.mat2d.create();
          return S = i.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), S, [t, R]), this.transform(c, S);
        }
        rotate(c, t, [R, S] = [0, 0]) {
          let J = i.mat2d.create();
          return J = i.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), J, [R, S]), J = i.mat2d.rotate(Array.of(0, 0, 0, 0, 0, 0), J, t), J = i.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), J, [-R, -S]), this.transform(c, J);
        }
        scale(c, [t, R = t], [S, J] = [0, 0]) {
          let H = i.mat2d.create();
          return H = i.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), H, [S, J]), H = i.mat2d.scale(Array.of(0, 0, 0, 0, 0, 0), H, [t, R]), H = i.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), H, [-S, -J]), this.transform(c, H);
        }
        skew(c, [t, R = t], [S, J] = [0, 0]) {
          let H = i.mat2d.create();
          return H = i.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), H, [S, J]), H = i.mat2d.multiply(Array.of(0, 0, 0, 0, 0, 0), H, i.mat2d.fromValues(1, Math.tan(R), Math.tan(t), 1, 0, 0)), H = i.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), H, [-S, -J]), this.transform(c, H);
        }
        isPointCollision(c, [t, R], S = "both") {
          const J = this.getTransform(c), H = Object(m.transformPoint)([t, R], i.mat2d.invert(Array.of(0, 0, 0, 0, 0, 0), J));
          return this[I].isPointCollision(...H, S);
        }
        isPointInFill(c, [t, R]) {
          return this.isPointCollision(c, [t, R], "fill");
        }
        isPointInStroke(c, [t, R]) {
          return this.isPointCollision(c, [t, R], "stroke");
        }
      };
    },
    /* 30 */
    /***/
    function(s, l, d) {
      d.r(l), d.d(l, "multiply", function() {
        return b;
      }), d.d(l, "grayscale", function() {
        return m;
      }), d.d(l, "brightness", function() {
        return o;
      }), d.d(l, "saturate", function() {
        return n;
      }), d.d(l, "contrast", function() {
        return W;
      }), d.d(l, "invert", function() {
        return e;
      }), d.d(l, "sepia", function() {
        return I;
      }), d.d(l, "opacity", function() {
        return a;
      }), d.d(l, "hueRotate", function() {
        return V;
      });
      var i = d(26);
      d(1).glMatrix.setMatrixArrayType(Array);
      function b(h, Y) {
        const p = [], G = h[0], y = h[1], Z = h[2], X = h[3], c = h[4], t = h[5], R = h[6], S = h[7], J = h[8], H = h[9], L = h[10], C = h[11], F = h[12], r = h[13], K = h[14], g = h[15], v = h[16], f = h[17], O = h[18], q = h[19];
        let M = Y[0], P = Y[1], D = Y[2], dd = Y[3], _ = Y[4];
        return p[0] = M * G + P * t + D * L + dd * g, p[1] = M * y + P * R + D * C + dd * v, p[2] = M * Z + P * S + D * F + dd * f, p[3] = M * X + P * J + D * r + dd * O, p[4] = M * c + P * H + D * K + dd * q + _, M = Y[5], P = Y[6], D = Y[7], dd = Y[8], _ = Y[9], p[5] = M * G + P * t + D * L + dd * g, p[6] = M * y + P * R + D * C + dd * v, p[7] = M * Z + P * S + D * F + dd * f, p[8] = M * X + P * J + D * r + dd * O, p[9] = M * c + P * H + D * K + dd * q + _, M = Y[10], P = Y[11], D = Y[12], dd = Y[13], _ = Y[14], p[10] = M * G + P * t + D * L + dd * g, p[11] = M * y + P * R + D * C + dd * v, p[12] = M * Z + P * S + D * F + dd * f, p[13] = M * X + P * J + D * r + dd * O, p[14] = M * c + P * H + D * K + dd * q + _, M = Y[15], P = Y[16], D = Y[17], dd = Y[18], _ = Y[19], p[15] = M * G + P * t + D * L + dd * g, p[16] = M * y + P * R + D * C + dd * v, p[17] = M * Z + P * S + D * F + dd * f, p[18] = M * X + P * J + D * r + dd * O, p[19] = M * c + P * H + D * K + dd * q + _, p;
      }
      function m(h) {
        h = Object(i.clamp)(0, 1, h);
        const Y = 0.2126 * h, p = 0.7152 * h, G = 0.0722 * h;
        return [Y + 1 - h, p, G, 0, 0, Y, p + 1 - h, G, 0, 0, Y, p, G + 1 - h, 0, 0, 0, 0, 0, 1, 0];
      }
      function o(h) {
        return [h, 0, 0, 0, 0, 0, h, 0, 0, 0, 0, 0, h, 0, 0, 0, 0, 0, 1, 0];
      }
      function n(h) {
        const Y = 0.2126 * (1 - h), p = 0.7152 * (1 - h), G = 0.0722 * (1 - h);
        return [Y + h, p, G, 0, 0, Y, p + h, G, 0, 0, Y, p, G + h, 0, 0, 0, 0, 0, 1, 0];
      }
      function W(h) {
        const Y = 0.5 * (1 - h);
        return [h, 0, 0, 0, Y, 0, h, 0, 0, Y, 0, 0, h, 0, Y, 0, 0, 0, 1, 0];
      }
      function e(h) {
        const Y = 1 - 2 * h;
        return [Y, 0, 0, 0, h, 0, Y, 0, 0, h, 0, 0, Y, 0, h, 0, 0, 0, 1, 0];
      }
      function I(h) {
        return [1 - 0.607 * h, 0.769 * h, 0.189 * h, 0, 0, 0.349 * h, 1 - 0.314 * h, 0.168 * h, 0, 0, 0.272 * h, 0.534 * h, 1 - 0.869 * h, 0, 0, 0, 0, 0, 1, 0];
      }
      function a(h) {
        return [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, h, 0];
      }
      function V(h) {
        const Y = h / 180 * Math.PI, p = Math.cos(Y), G = Math.sin(Y), y = 0.2126, Z = 0.7152, X = 0.0722;
        return [y + p * (1 - y) + G * -y, Z + p * -Z + G * -Z, X + p * -X + G * (1 - X), 0, 0, y + p * -y + G * 0.143, Z + p * (1 - Z) + G * 0.14, X + p * -X + G * -0.283, 0, 0, y + p * -y + G * -(1 - y), Z + p * -Z + G * Z, X + p * (1 - X) + G * X, 0, 0, 0, 0, 0, 1, 0];
      }
    },
    /* 31 */
    /***/
    function(s, l, d) {
      d.r(l), d.d(l, "default", function() {
        return m;
      });
      var i = d(32), b = /* @__PURE__ */ d.n(i);
      d(1).glMatrix.setMatrixArrayType(Array);
      function m(o) {
        const n = b()(o);
        if (!n || !n.length)
          throw new TypeError("Invalid color value.");
        return [n[0] / 255, n[1] / 255, n[2] / 255, n[3]];
      }
    },
    /* 32 */
    /***/
    function(s, l, d) {
      var i = d(33), b = d(37), m = d(39);
      s.exports = function(n) {
        var W, e = i(n);
        return e.space ? (W = Array(3), W[0] = m(e.values[0], 0, 255), W[1] = m(e.values[1], 0, 255), W[2] = m(e.values[2], 0, 255), e.space[0] === "h" && (W = b.rgb(W)), W.push(m(e.alpha, 0, 1)), W) : [];
      };
    },
    /* 33 */
    /***/
    function(s, l, d) {
      (function(i) {
        var b = d(34), m = d(35), o = d(36);
        s.exports = W;
        var n = {
          red: 0,
          orange: 60,
          yellow: 120,
          green: 180,
          blue: 240,
          purple: 300
        };
        function W(e) {
          var I, a = [], V = 1, h;
          if (typeof e == "string")
            if (b[e])
              a = b[e].slice(), h = "rgb";
            else if (e === "transparent")
              V = 0, h = "rgb", a = [0, 0, 0];
            else if (/^#[A-Fa-f0-9]+$/.test(e)) {
              var Y = e.slice(1), p = Y.length, G = p <= 4;
              V = 1, G ? (a = [
                parseInt(Y[0] + Y[0], 16),
                parseInt(Y[1] + Y[1], 16),
                parseInt(Y[2] + Y[2], 16)
              ], p === 4 && (V = parseInt(Y[3] + Y[3], 16) / 255)) : (a = [
                parseInt(Y[0] + Y[1], 16),
                parseInt(Y[2] + Y[3], 16),
                parseInt(Y[4] + Y[5], 16)
              ], p === 8 && (V = parseInt(Y[6] + Y[7], 16) / 255)), a[0] || (a[0] = 0), a[1] || (a[1] = 0), a[2] || (a[2] = 0), h = "rgb";
            } else if (I = /^((?:rgb|hs[lvb]|hwb|cmyk?|xy[zy]|gray|lab|lchu?v?|[ly]uv|lms)a?)\s*\(([^\)]*)\)/.exec(e)) {
              var y = I[1], Z = y === "rgb", Y = y.replace(/a$/, "");
              h = Y;
              var p = Y === "cmyk" ? 4 : Y === "gray" ? 1 : 3;
              a = I[2].trim().split(/\s*,\s*/).map(function(R, S) {
                if (/%$/.test(R))
                  return S === p ? parseFloat(R) / 100 : Y === "rgb" ? parseFloat(R) * 255 / 100 : parseFloat(R);
                if (Y[S] === "h") {
                  if (/deg$/.test(R))
                    return parseFloat(R);
                  if (n[R] !== void 0)
                    return n[R];
                }
                return parseFloat(R);
              }), y === Y && a.push(1), V = Z || a[p] === void 0 ? 1 : a[p], a = a.slice(0, p);
            } else
              e.length > 10 && /[0-9](?:\s|\/)/.test(e) && (a = e.match(/([0-9]+)/g).map(function(c) {
                return parseFloat(c);
              }), h = e.match(/([a-z])/ig).join("").toLowerCase());
          else if (!isNaN(e))
            h = "rgb", a = [e >>> 16, (e & 65280) >>> 8, e & 255];
          else if (m(e)) {
            var X = o(e.r, e.red, e.R, null);
            X !== null ? (h = "rgb", a = [
              X,
              o(e.g, e.green, e.G),
              o(e.b, e.blue, e.B)
            ]) : (h = "hsl", a = [
              o(e.h, e.hue, e.H),
              o(e.s, e.saturation, e.S),
              o(e.l, e.lightness, e.L, e.b, e.brightness)
            ]), V = o(e.a, e.alpha, e.opacity, 1), e.opacity != null && (V /= 100);
          } else
            (Array.isArray(e) || i.ArrayBuffer && ArrayBuffer.isView && ArrayBuffer.isView(e)) && (a = [e[0], e[1], e[2]], h = "rgb", V = e.length === 4 ? e[3] : 1);
          return {
            space: h,
            values: a,
            alpha: V
          };
        }
      }).call(this, d(22));
    },
    /* 34 */
    /***/
    function(s, l, d) {
      s.exports = {
        aliceblue: [240, 248, 255],
        antiquewhite: [250, 235, 215],
        aqua: [0, 255, 255],
        aquamarine: [127, 255, 212],
        azure: [240, 255, 255],
        beige: [245, 245, 220],
        bisque: [255, 228, 196],
        black: [0, 0, 0],
        blanchedalmond: [255, 235, 205],
        blue: [0, 0, 255],
        blueviolet: [138, 43, 226],
        brown: [165, 42, 42],
        burlywood: [222, 184, 135],
        cadetblue: [95, 158, 160],
        chartreuse: [127, 255, 0],
        chocolate: [210, 105, 30],
        coral: [255, 127, 80],
        cornflowerblue: [100, 149, 237],
        cornsilk: [255, 248, 220],
        crimson: [220, 20, 60],
        cyan: [0, 255, 255],
        darkblue: [0, 0, 139],
        darkcyan: [0, 139, 139],
        darkgoldenrod: [184, 134, 11],
        darkgray: [169, 169, 169],
        darkgreen: [0, 100, 0],
        darkgrey: [169, 169, 169],
        darkkhaki: [189, 183, 107],
        darkmagenta: [139, 0, 139],
        darkolivegreen: [85, 107, 47],
        darkorange: [255, 140, 0],
        darkorchid: [153, 50, 204],
        darkred: [139, 0, 0],
        darksalmon: [233, 150, 122],
        darkseagreen: [143, 188, 143],
        darkslateblue: [72, 61, 139],
        darkslategray: [47, 79, 79],
        darkslategrey: [47, 79, 79],
        darkturquoise: [0, 206, 209],
        darkviolet: [148, 0, 211],
        deeppink: [255, 20, 147],
        deepskyblue: [0, 191, 255],
        dimgray: [105, 105, 105],
        dimgrey: [105, 105, 105],
        dodgerblue: [30, 144, 255],
        firebrick: [178, 34, 34],
        floralwhite: [255, 250, 240],
        forestgreen: [34, 139, 34],
        fuchsia: [255, 0, 255],
        gainsboro: [220, 220, 220],
        ghostwhite: [248, 248, 255],
        gold: [255, 215, 0],
        goldenrod: [218, 165, 32],
        gray: [128, 128, 128],
        green: [0, 128, 0],
        greenyellow: [173, 255, 47],
        grey: [128, 128, 128],
        honeydew: [240, 255, 240],
        hotpink: [255, 105, 180],
        indianred: [205, 92, 92],
        indigo: [75, 0, 130],
        ivory: [255, 255, 240],
        khaki: [240, 230, 140],
        lavender: [230, 230, 250],
        lavenderblush: [255, 240, 245],
        lawngreen: [124, 252, 0],
        lemonchiffon: [255, 250, 205],
        lightblue: [173, 216, 230],
        lightcoral: [240, 128, 128],
        lightcyan: [224, 255, 255],
        lightgoldenrodyellow: [250, 250, 210],
        lightgray: [211, 211, 211],
        lightgreen: [144, 238, 144],
        lightgrey: [211, 211, 211],
        lightpink: [255, 182, 193],
        lightsalmon: [255, 160, 122],
        lightseagreen: [32, 178, 170],
        lightskyblue: [135, 206, 250],
        lightslategray: [119, 136, 153],
        lightslategrey: [119, 136, 153],
        lightsteelblue: [176, 196, 222],
        lightyellow: [255, 255, 224],
        lime: [0, 255, 0],
        limegreen: [50, 205, 50],
        linen: [250, 240, 230],
        magenta: [255, 0, 255],
        maroon: [128, 0, 0],
        mediumaquamarine: [102, 205, 170],
        mediumblue: [0, 0, 205],
        mediumorchid: [186, 85, 211],
        mediumpurple: [147, 112, 219],
        mediumseagreen: [60, 179, 113],
        mediumslateblue: [123, 104, 238],
        mediumspringgreen: [0, 250, 154],
        mediumturquoise: [72, 209, 204],
        mediumvioletred: [199, 21, 133],
        midnightblue: [25, 25, 112],
        mintcream: [245, 255, 250],
        mistyrose: [255, 228, 225],
        moccasin: [255, 228, 181],
        navajowhite: [255, 222, 173],
        navy: [0, 0, 128],
        oldlace: [253, 245, 230],
        olive: [128, 128, 0],
        olivedrab: [107, 142, 35],
        orange: [255, 165, 0],
        orangered: [255, 69, 0],
        orchid: [218, 112, 214],
        palegoldenrod: [238, 232, 170],
        palegreen: [152, 251, 152],
        paleturquoise: [175, 238, 238],
        palevioletred: [219, 112, 147],
        papayawhip: [255, 239, 213],
        peachpuff: [255, 218, 185],
        peru: [205, 133, 63],
        pink: [255, 192, 203],
        plum: [221, 160, 221],
        powderblue: [176, 224, 230],
        purple: [128, 0, 128],
        rebeccapurple: [102, 51, 153],
        red: [255, 0, 0],
        rosybrown: [188, 143, 143],
        royalblue: [65, 105, 225],
        saddlebrown: [139, 69, 19],
        salmon: [250, 128, 114],
        sandybrown: [244, 164, 96],
        seagreen: [46, 139, 87],
        seashell: [255, 245, 238],
        sienna: [160, 82, 45],
        silver: [192, 192, 192],
        skyblue: [135, 206, 235],
        slateblue: [106, 90, 205],
        slategray: [112, 128, 144],
        slategrey: [112, 128, 144],
        snow: [255, 250, 250],
        springgreen: [0, 255, 127],
        steelblue: [70, 130, 180],
        tan: [210, 180, 140],
        teal: [0, 128, 128],
        thistle: [216, 191, 216],
        tomato: [255, 99, 71],
        turquoise: [64, 224, 208],
        violet: [238, 130, 238],
        wheat: [245, 222, 179],
        white: [255, 255, 255],
        whitesmoke: [245, 245, 245],
        yellow: [255, 255, 0],
        yellowgreen: [154, 205, 50]
      };
    },
    /* 35 */
    /***/
    function(s, l, d) {
      var i = Object.prototype.toString;
      s.exports = function(b) {
        var m;
        return i.call(b) === "[object Object]" && (m = Object.getPrototypeOf(b), m === null || m === Object.getPrototypeOf({}));
      };
    },
    /* 36 */
    /***/
    function(s, l) {
      s.exports = function() {
        for (var d = 0; d < arguments.length; d++)
          if (arguments[d] !== void 0)
            return arguments[d];
      };
    },
    /* 37 */
    /***/
    function(s, l, d) {
      var i = d(38);
      s.exports = {
        name: "hsl",
        min: [0, 0, 0],
        max: [360, 100, 100],
        channel: ["hue", "saturation", "lightness"],
        alias: ["HSL"],
        rgb: function(b) {
          var m = b[0] / 360, o = b[1] / 100, n = b[2] / 100, W, e, I, a, V;
          if (o === 0)
            return V = n * 255, [V, V, V];
          n < 0.5 ? e = n * (1 + o) : e = n + o - n * o, W = 2 * n - e, a = [0, 0, 0];
          for (var h = 0; h < 3; h++)
            I = m + 1 / 3 * -(h - 1), I < 0 ? I++ : I > 1 && I--, 6 * I < 1 ? V = W + (e - W) * 6 * I : 2 * I < 1 ? V = e : 3 * I < 2 ? V = W + (e - W) * (2 / 3 - I) * 6 : V = W, a[h] = V * 255;
          return a;
        }
      }, i.hsl = function(b) {
        var m = b[0] / 255, o = b[1] / 255, n = b[2] / 255, W = Math.min(m, o, n), e = Math.max(m, o, n), I = e - W, a, V, h;
        return e === W ? a = 0 : m === e ? a = (o - n) / I : o === e ? a = 2 + (n - m) / I : n === e && (a = 4 + (m - o) / I), a = Math.min(a * 60, 360), a < 0 && (a += 360), h = (W + e) / 2, e === W ? V = 0 : h <= 0.5 ? V = I / (e + W) : V = I / (2 - e - W), [a, V * 100, h * 100];
      };
    },
    /* 38 */
    /***/
    function(s, l, d) {
      s.exports = {
        name: "rgb",
        min: [0, 0, 0],
        max: [255, 255, 255],
        channel: ["red", "green", "blue"],
        alias: ["RGB"]
      };
    },
    /* 39 */
    /***/
    function(s, l) {
      s.exports = d;
      function d(i, b, m) {
        return b < m ? i < b ? b : i > m ? m : i : i < m ? m : i > b ? b : i;
      }
    },
    /* 40 */
    /***/
    function(s, l, d) {
      d.r(l), d.d(l, "default", function() {
        return X;
      });
      var i = d(41), b = /* @__PURE__ */ d.n(i), m = d(42), o = /* @__PURE__ */ d.n(m), n = d(43), W = /* @__PURE__ */ d.n(n), e = d(44), I = d(46), a = /* @__PURE__ */ d.n(I), V = d(53), h = d(55);
      d(1).glMatrix.setMatrixArrayType(Array);
      const Y = Symbol("contours"), p = Symbol("path"), G = Symbol("simplify"), y = Symbol("scale"), Z = 2 * Math.PI;
      class X {
        constructor(t = {}) {
          typeof t == "string" && (t = {
            path: t
          }), t.path ? this[p] = b()(t.path) : this[p] = [], this[Y] = null, this[G] = t.simplify != null ? t.simplify : 0, this[y] = t.scale != null ? t.scale : 2;
        }
        get contours() {
          let t = null;
          if (!this[Y] && this[p]) {
            const R = Object(e.default)(W()(this[p]));
            this[Y] = a()(R, this[y], this[G]), this[Y].path = R, this[Y].simplify = this[G], this[Y].scale = this[y];
          }
          return this[Y] && (t = this[Y].map((R) => [...R]), t.path = this[Y].path, t.simplify = this[Y].simplify, t.scale = this[Y].scale), t;
        }
        get path() {
          return this[p];
        }
        get simplify() {
          return this[G];
        }
        get boundingBox() {
          const t = this.contours;
          if (t && t.length) {
            const R = t.reduce((S, J) => [...S, ...J]);
            return o()(R);
          }
          return [[0, 0], [0, 0]];
        }
        get boundingCenter() {
          const t = this.boundingBox;
          return t ? [0.5 * (t[0][0] + t[1][0]), 0.5 * (t[0][1] + t[1][1])] : [0, 0];
        }
        normalize(t = 0, R = 0) {
          const S = Object(e.default)(W()(this[p])).map(([J, ...H]) => {
            const L = [J];
            for (let C = 0; C < H.length; C += 2) {
              const F = H[C] - t, r = H[C + 1] - R;
              L.push(F, r);
            }
            return L;
          });
          return this.beginPath(), this[p].push(...S), this;
        }
        getPointAtLength(t) {
          return this.contours ? Object(V.getPointAtLength)(this[Y], t) : null;
        }
        getTotalLength() {
          return this.contours ? Object(V.getTotalLength)(this[Y]) : 0;
        }
        addPath(t) {
          this[Y] = null, typeof t == "string" && (t = b()(t)), this[p].push(...t);
        }
        beginPath() {
          this[p] = [], this[Y] = null;
        }
        clear() {
          this.beginPath();
        }
        ellipse(t, R, S, J, H, L, C, F = 0) {
          if (L += H, C += H, S <= 0 || J <= 0 || C === L)
            return;
          C < L && (C = L + Z + (C - L) % Z), C - L > Z && (C = L + Z);
          const r = C - L;
          r >= Z && (C -= 1e-3);
          let K = this[p].length > 0 && r < Z ? "L" : "M";
          const g = Object(h.getPoint)(t, R, S, J, L), v = Object(h.getPoint)(t, R, S, J, C), f = +!F;
          let O = r > Math.PI ? 1 : 0;
          F && (O = 1 - O), K += g.join(" "), K += `A${S} ${J} 0 ${O} ${f} ${v.join(" ")}`, r >= Z && (K += "Z"), this.addPath(K);
        }
        arc(t, R, S, J, H, L = 0) {
          return this.ellipse(t, R, S, S, 0, J, H, L);
        }
        arcTo(t, R, S, J, H, L, C) {
          this[Y] = null, this[p].push(["A", t, R, S, J, H, L, C]);
        }
        moveTo(t, R) {
          this[Y] = null, this[p].push(["M", t, R]);
        }
        lineTo(t, R) {
          this[Y] = null, this[p].push(["L", t, R]);
        }
        bezierCurveTo(t, R, S, J, H, L) {
          this[Y] = null, this[p].push(["C", t, R, S, J, H, L]);
        }
        quadraticCurveTo(t, R, S, J) {
          this[Y] = null, this[p].push(["Q", t, R, S, J]);
        }
        rect(t, R, S, J) {
          const H = `M${t} ${R}L${t + S} ${R}L${t + S} ${R + J}L${t} ${R + J}Z`;
          this.addPath(H);
        }
        closePath() {
          this[Y] = null;
          let t = [];
          const R = this[p].length;
          R > 0 && (t = this[p][R - 1]), t[0] !== "Z" && t[0] !== "z" && this[p].push(["Z"]);
        }
      }
    },
    /* 41 */
    /***/
    function(s, l) {
      s.exports = b;
      var d = { a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0 }, i = /([astvzqmhlc])([^astvzqmhlc]*)/ig;
      function b(n) {
        var W = [];
        return n.replace(i, function(e, I, a) {
          var V = I.toLowerCase();
          for (a = o(a), V == "m" && a.length > 2 && (W.push([I].concat(a.splice(0, 2))), V = "l", I = I == "m" ? "l" : "L"); ; ) {
            if (a.length == d[V])
              return a.unshift(I), W.push(a);
            if (a.length < d[V])
              throw new Error("malformed path data");
            W.push([I].concat(a.splice(0, d[V])));
          }
        }), W;
      }
      var m = /-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/ig;
      function o(n) {
        var W = n.match(m);
        return W ? W.map(Number) : [];
      }
    },
    /* 42 */
    /***/
    function(s, l, d) {
      s.exports = i;
      function i(b) {
        var m = b.length;
        if (m === 0)
          return [[], []];
        for (var o = b[0].length, n = b[0].slice(), W = b[0].slice(), e = 1; e < m; ++e)
          for (var I = b[e], a = 0; a < o; ++a) {
            var V = I[a];
            n[a] = Math.min(n[a], V), W[a] = Math.max(W[a], V);
          }
        return [n, W];
      }
    },
    /* 43 */
    /***/
    function(s, l) {
      s.exports = d;
      function d(i) {
        var b = 0, m = 0, o = 0, n = 0;
        return i.map(function(W) {
          W = W.slice();
          var e = W[0], I = e.toUpperCase();
          if (e != I)
            switch (W[0] = I, e) {
              case "a":
                W[6] += o, W[7] += n;
                break;
              case "v":
                W[1] += n;
                break;
              case "h":
                W[1] += o;
                break;
              default:
                for (var a = 1; a < W.length; )
                  W[a++] += o, W[a++] += n;
            }
          switch (I) {
            case "Z":
              o = b, n = m;
              break;
            case "H":
              o = W[1];
              break;
            case "V":
              n = W[1];
              break;
            case "M":
              o = b = W[1], n = m = W[2];
              break;
            default:
              o = W[W.length - 2], n = W[W.length - 1];
          }
          return W;
        });
      }
    },
    /* 44 */
    /***/
    function(s, l, d) {
      d.r(l), d.d(l, "default", function() {
        return b;
      });
      var i = d(45);
      d(1).glMatrix.setMatrixArrayType(Array);
      function b(n) {
        for (var W, e = [], I = 0, a = 0, V = 0, h = 0, Y = null, p = null, G = 0, y = 0, Z = 0, X = n.length; Z < X; Z++) {
          var c = n[Z], t = c[0];
          switch (t) {
            case "M":
              V = c[1], h = c[2];
              break;
            case "A":
              var R = Object(i.default)(G, y, c[6], c[7], c[4], c[5], c[1], c[2], c[3]);
              if (!R.length)
                continue;
              R = R.map((C) => {
                const [F, r, K, g, v, f, O, q] = C;
                return {
                  x1: K,
                  y1: g,
                  x2: v,
                  y2: f,
                  x: O,
                  y: q
                };
              });
              for (var S = 0, J; S < R.length; S++)
                J = R[S], c = ["C", J.x1, J.y1, J.x2, J.y2, J.x, J.y], S < R.length - 1 && e.push(c);
              break;
            case "S":
              var H = G, L = y;
              (W == "C" || W == "S") && (H += H - I, L += L - a), c = ["C", H, L, c[1], c[2], c[3], c[4]];
              break;
            case "T":
              W == "Q" || W == "T" ? (Y = G * 2 - Y, p = y * 2 - p) : (Y = G, p = y), c = o(G, y, Y, p, c[1], c[2]);
              break;
            case "Q":
              Y = c[1], p = c[2], c = o(G, y, c[1], c[2], c[3], c[4]);
              break;
            case "L":
              c = m(G, y, c[1], c[2]);
              break;
            case "H":
              c = m(G, y, c[1], y);
              break;
            case "V":
              c = m(G, y, G, c[1]);
              break;
            case "Z":
              c = m(G, y, V, h);
              break;
          }
          W = t, G = c[c.length - 2], y = c[c.length - 1], c.length > 4 ? (I = c[c.length - 4], a = c[c.length - 3]) : (I = G, a = y), e.push(c);
        }
        return e;
      }
      function m(n, W, e, I) {
        return ["C", n, W, e, I, e, I];
      }
      function o(n, W, e, I, a, V) {
        return ["C", n / 3 + 2 / 3 * e, W / 3 + 2 / 3 * I, a / 3 + 2 / 3 * e, V / 3 + 2 / 3 * I, a, V];
      }
    },
    /* 45 */
    /***/
    function(s, l, d) {
      d.r(l), d.d(l, "default", function() {
        return n;
      }), d(1).glMatrix.setMatrixArrayType(Array);
      const i = Math.PI * 2;
      function b(W, e, I, a) {
        const V = W * a - e * I < 0 ? -1 : 1;
        let h = W * I + e * a;
        return h > 1 && (h = 1), h < -1 && (h = -1), V * Math.acos(h);
      }
      function m(W, e, I, a, V, h, Y, p, G, y) {
        const Z = y * (W - I) / 2 + G * (e - a) / 2, X = -G * (W - I) / 2 + y * (e - a) / 2, c = Y * Y, t = p * p, R = Z * Z, S = X * X;
        let J = c * t - c * S - t * R;
        J < 0 && (J = 0), J /= c * S + t * R, J = Math.sqrt(J) * (V === h ? -1 : 1);
        const H = J * Y / p * X, L = J * -p / Y * Z, C = y * H - G * L + (W + I) / 2, F = G * H + y * L + (e + a) / 2, r = (Z - H) / Y, K = (X - L) / p, g = (-Z - H) / Y, v = (-X - L) / p, f = b(1, 0, r, K);
        let O = b(r, K, g, v);
        return h === 0 && O > 0 && (O -= i), h === 1 && O < 0 && (O += i), [C, F, f, O];
      }
      function o(W, e) {
        const I = 1.3333333333333333 * Math.tan(e / 4), a = Math.cos(W), V = Math.sin(W), h = Math.cos(W + e), Y = Math.sin(W + e);
        return [a, V, a - V * I, V + a * I, h + Y * I, Y - h * I, h, Y];
      }
      function n(W, e, I, a, V, h, Y, p, G) {
        const y = Math.sin(G * i / 360), Z = Math.cos(G * i / 360), X = Z * (W - I) / 2 + y * (e - a) / 2, c = -y * (W - I) / 2 + Z * (e - a) / 2;
        if (X === 0 && c === 0)
          return [];
        if (Y === 0 || p === 0)
          return [];
        Y = Math.abs(Y), p = Math.abs(p);
        const t = X * X / (Y * Y) + c * c / (p * p);
        t > 1 && (Y *= Math.sqrt(t), p *= Math.sqrt(t));
        const R = m(W, e, I, a, V, h, Y, p, y, Z), S = [];
        let J = R[2], H = R[3];
        const L = Math.max(Math.ceil(Math.abs(H) / (i / 4)), 1);
        H /= L;
        for (let C = 0; C < L; C++)
          S.push(o(J, H)), J += H;
        return S.map((C) => {
          for (let F = 0; F < C.length; F += 2) {
            let r = C[F + 0], K = C[F + 1];
            r *= Y, K *= p;
            const g = Z * r - y * K, v = y * r + Z * K;
            C[F + 0] = g + R[0], C[F + 1] = v + R[1];
          }
          return C;
        });
      }
    },
    /* 46 */
    /***/
    function(s, l, d) {
      d(1).glMatrix.setMatrixArrayType(Array);
      var i = d(47), {
        copy: b
      } = d(49), m = d(50);
      function o(a, V, h) {
        return a[0] = V, a[1] = h, a;
      }
      var n = [0, 0], W = [0, 0], e = [0, 0];
      function I(a, V, h, Y) {
        i(h, o(n, Y[1], Y[2]), o(W, Y[3], Y[4]), o(e, Y[5], Y[6]), V, a);
      }
      s.exports = function(V, h, Y) {
        var p = [], G = [], y = [0, 0];
        return V.forEach(function(Z, X, c) {
          if (Z[0] === "M")
            b(y, Z.slice(1)), G.length > 0 && (p.push(G), G = []);
          else if (Z[0] === "C")
            I(G, h, y, Z), o(y, Z[5], Z[6]);
          else
            throw new Error("illegal type in SVG: " + Z[0]);
        }), G.length > 0 && p.push(G), p.map(function(Z) {
          return m(Z, Y || 0);
        });
      };
    },
    /* 47 */
    /***/
    function(s, l, d) {
      s.exports = d(48)();
    },
    /* 48 */
    /***/
    function(s, l) {
      function d(b) {
        return [b[0], b[1]];
      }
      function i(b, m) {
        return [b, m];
      }
      s.exports = function(m) {
        m = m || {};
        var o = typeof m.recursion == "number" ? m.recursion : 8, n = typeof m.epsilon == "number" ? m.epsilon : 11920929e-14, W = typeof m.pathEpsilon == "number" ? m.pathEpsilon : 1, e = typeof m.angleEpsilon == "number" ? m.angleEpsilon : 0.01, I = m.angleTolerance || 0, a = m.cuspLimit || 0;
        return function(p, G, y, Z, X, c) {
          c || (c = []), X = typeof X == "number" ? X : 1;
          var t = W / X;
          return t *= t, V(p, G, y, Z, c, t), c;
        };
        function V(Y, p, G, y, Z, X) {
          Z.push(d(Y));
          var c = Y[0], t = Y[1], R = p[0], S = p[1], J = G[0], H = G[1], L = y[0], C = y[1];
          h(c, t, R, S, J, H, L, C, Z, X, 0), Z.push(d(y));
        }
        function h(Y, p, G, y, Z, X, c, t, R, S, J) {
          if (!(J > o)) {
            var H = Math.PI, L = (Y + G) / 2, C = (p + y) / 2, F = (G + Z) / 2, r = (y + X) / 2, K = (Z + c) / 2, g = (X + t) / 2, v = (L + F) / 2, f = (C + r) / 2, O = (F + K) / 2, q = (r + g) / 2, M = (v + O) / 2, P = (f + q) / 2;
            if (J > 0) {
              var D = c - Y, dd = t - p, _ = Math.abs((G - c) * dd - (y - t) * D), cd = Math.abs((Z - c) * dd - (X - t) * D), $, Wd;
              if (_ > n && cd > n) {
                if ((_ + cd) * (_ + cd) <= S * (D * D + dd * dd)) {
                  if (I < e) {
                    R.push(i(M, P));
                    return;
                  }
                  var Xd = Math.atan2(X - y, Z - G);
                  if ($ = Math.abs(Xd - Math.atan2(y - p, G - Y)), Wd = Math.abs(Math.atan2(t - X, c - Z) - Xd), $ >= H && ($ = 2 * H - $), Wd >= H && (Wd = 2 * H - Wd), $ + Wd < I) {
                    R.push(i(M, P));
                    return;
                  }
                  if (a !== 0) {
                    if ($ > a) {
                      R.push(i(G, y));
                      return;
                    }
                    if (Wd > a) {
                      R.push(i(Z, X));
                      return;
                    }
                  }
                }
              } else if (_ > n) {
                if (_ * _ <= S * (D * D + dd * dd)) {
                  if (I < e) {
                    R.push(i(M, P));
                    return;
                  }
                  if ($ = Math.abs(Math.atan2(X - y, Z - G) - Math.atan2(y - p, G - Y)), $ >= H && ($ = 2 * H - $), $ < I) {
                    R.push(i(G, y)), R.push(i(Z, X));
                    return;
                  }
                  if (a !== 0 && $ > a) {
                    R.push(i(G, y));
                    return;
                  }
                }
              } else if (cd > n) {
                if (cd * cd <= S * (D * D + dd * dd)) {
                  if (I < e) {
                    R.push(i(M, P));
                    return;
                  }
                  if ($ = Math.abs(Math.atan2(t - X, c - Z) - Math.atan2(X - y, Z - G)), $ >= H && ($ = 2 * H - $), $ < I) {
                    R.push(i(G, y)), R.push(i(Z, X));
                    return;
                  }
                  if (a !== 0 && $ > a) {
                    R.push(i(Z, X));
                    return;
                  }
                }
              } else if (D = M - (Y + c) / 2, dd = P - (p + t) / 2, D * D + dd * dd <= S) {
                R.push(i(M, P));
                return;
              }
            }
            h(Y, p, L, C, v, f, M, P, R, S, J + 1), h(M, P, O, q, K, g, c, t, R, S, J + 1);
          }
        }
      };
    },
    /* 49 */
    /***/
    function(s, l, d) {
      d.r(l), d.d(l, "create", function() {
        return m;
      }), d.d(l, "clone", function() {
        return b;
      }), d.d(l, "copy", function() {
        return o;
      }), d.d(l, "scaleAndAdd", function() {
        return n;
      }), d.d(l, "dot", function() {
        return W;
      }), d.d(l, "rotate", function() {
        return e;
      }), d.d(l, "cross", function() {
        return I;
      }), d.d(l, "sub", function() {
        return a;
      }), d.d(l, "add", function() {
        return V;
      }), d.d(l, "computeMiter", function() {
        return G;
      }), d.d(l, "normal", function() {
        return y;
      }), d.d(l, "direction", function() {
        return Z;
      });
      var i = d(1);
      d(1).glMatrix.setMatrixArrayType(Array);
      function b(X) {
        return [X[0], X[1]];
      }
      function m() {
        return [0, 0];
      }
      const o = i.vec2.copy, n = i.vec2.scaleAndAdd, W = i.vec2.dot, e = i.vec2.rotate, I = i.vec2.cross, a = i.vec2.sub, V = i.vec2.add, h = i.vec2.normalize, Y = i.vec2.set, p = m();
      function G(X, c, t, R, S) {
        V(X, t, R), h(X, X), Y(c, -X[1], X[0]), Y(p, -t[1], t[0]);
        const J = S / W(c, p);
        return Math.abs(J);
      }
      function y(X, c) {
        return Y(X, -c[1], c[0]), X;
      }
      function Z(X, c, t) {
        return a(X, c, t), h(X, X), X;
      }
    },
    /* 50 */
    /***/
    function(s, l, d) {
      var i = d(51), b = d(52);
      s.exports = function(o, n) {
        return o = i(o, n), o = b(o, n), o;
      }, s.exports.radialDistance = i, s.exports.douglasPeucker = b;
    },
    /* 51 */
    /***/
    function(s, l) {
      function d(i, b) {
        var m = i[0] - b[0], o = i[1] - b[1];
        return m * m + o * o;
      }
      s.exports = function(b, m) {
        if (b.length <= 1)
          return b;
        m = typeof m == "number" ? m : 1;
        for (var o = m * m, n = b[0], W = [n], e, I = 1, a = b.length; I < a; I++)
          e = b[I], d(e, n) > o && (W.push(e), n = e);
        return n !== e && W.push(e), W;
      };
    },
    /* 52 */
    /***/
    function(s, l) {
      function d(b, m, o) {
        var n = m[0], W = m[1], e = o[0] - n, I = o[1] - W;
        if (e !== 0 || I !== 0) {
          var a = ((b[0] - n) * e + (b[1] - W) * I) / (e * e + I * I);
          a > 1 ? (n = o[0], W = o[1]) : a > 0 && (n += e * a, W += I * a);
        }
        return e = b[0] - n, I = b[1] - W, e * e + I * I;
      }
      function i(b, m, o, n, W) {
        for (var e = n, I, a = m + 1; a < o; a++) {
          var V = d(b[a], b[m], b[o]);
          V > e && (I = a, e = V);
        }
        e > n && (I - m > 1 && i(b, m, I, n, W), W.push(b[I]), o - I > 1 && i(b, I, o, n, W));
      }
      s.exports = function(m, o) {
        if (m.length <= 1)
          return m;
        o = typeof o == "number" ? o : 1;
        var n = o * o, W = m.length - 1, e = [m[0]];
        return i(m, 0, W, n, e), e.push(m[W]), e;
      };
    },
    /* 53 */
    /***/
    function(s, l, d) {
      d.r(l), d.d(l, "getTotalLength", function() {
        return b;
      }), d.d(l, "getPointAtLength", function() {
        return o;
      }), d.d(l, "getDashContours", function() {
        return n;
      });
      var i = d(54);
      d(1).glMatrix.setMatrixArrayType(Array);
      function b(W) {
        if (W.totalLength != null)
          return W.totalLength;
        let e = 0;
        return W.forEach((I) => {
          let a = I[0];
          for (let V = 1; V < I.length; V++) {
            const h = I[V];
            e += Object(i.distance)(a, h), a = h;
          }
        }), W.totalLength = e, e;
      }
      function m(W, e, I = !0) {
        if (e = Number(e), !Number.isFinite(e))
          throw new TypeError("Failed to execute 'getPointAtLength' on figure: The provided float value is non-finite.");
        if (e <= 0)
          throw new TypeError("Length must > 0");
        const a = b(W);
        if (e >= a) {
          const h = W[W.length - 1], Y = h[h.length - 2], p = h[h.length - 1], G = Math.atan2(p[1] - Y[1], p[0] - Y[0]);
          return {
            current: W.map((y) => [...y]),
            point: {
              x: p[0],
              y: p[1],
              angle: G
            }
          };
        }
        const V = [];
        for (let h = 0; h < W.length; h++) {
          V[h] = [];
          const Y = W[h];
          let p = Y[0];
          for (let G = 1; G < Y.length; G++) {
            const y = Y[G], Z = Object(i.distance)(p, y);
            if (e < Z) {
              const X = e / Z, c = Math.atan2(y[1] - p[1], y[0] - p[0]), t = {
                x: p[0] * (1 - X) + y[0] * X,
                y: p[1] * (1 - X) + y[1] * X,
                angle: c
              };
              if (V[h].push(p), e > 0 && V[h].push([t.x, t.y]), !I)
                return {
                  current: V,
                  point: t
                };
              const R = [], S = h;
              for (; h < W.length; h++) {
                for (R[h - S] = [], h === S && R[0].push([t.x, t.y]); G < Y.length; G++)
                  R[h - S].push(Y[G]);
                G = 0;
              }
              return {
                current: V,
                point: t,
                rest: R
              };
            }
            e -= Z, V[h].push(p), p = y;
          }
        }
      }
      function o(W, e) {
        if (e = Number(e), !Number.isFinite(e))
          throw new TypeError("Failed to execute 'getPointAtLength' on figure: The provided float value is non-finite.");
        if (W.length <= 0)
          return {
            x: 0,
            y: 0,
            angle: 0
          };
        if (e <= 0) {
          const I = W[0][0], a = W[0][1], V = Math.atan2(a[1] - I[1], a[0] - I[0]);
          return {
            x: I[0],
            y: I[1],
            angle: V
          };
        }
        return m(W, e, !1).point;
      }
      function n(W, e, I) {
        let a = 0, V = e[0], h = W;
        const Y = [], p = e.length;
        if (I > 0) {
          do
            I -= e[a % p], a++;
          while (I > 0);
          I < 0 && (V = -I, a--);
        } else if (I < 0) {
          a = -1;
          do
            I += e[a % p + p - 1], a--;
          while (I < 0);
          I >= 0 && (a++, V = e[a % p + p - 1] - I);
        }
        do {
          const G = m(h, V);
          h = G.rest, ++a % 2 && Y.push(...G.current);
          let y = a % p;
          y < 0 && (y += p), V = e[y];
        } while (h);
        return Y;
      }
    },
    /* 54 */
    /***/
    function(s, l, d) {
      d.r(l), d.d(l, "normalize", function() {
        return i;
      }), d.d(l, "distance", function() {
        return b;
      }), d(1).glMatrix.setMatrixArrayType(Array);
      function i([m, o, n], W, e, I) {
        return m = m * 2 / W - 1, o = 1 - o * 2 / e, Number.isFinite(I) ? (n = n * 2 / I - 1, [m, o, n]) : [m, o];
      }
      function b([m, o, n = 0], [W, e, I = 0]) {
        return Math.hypot(W - m, e - o, I - n);
      }
    },
    /* 55 */
    /***/
    function(s, l, d) {
      d.r(l), d.d(l, "getPoint", function() {
        return b;
      }), d(1).glMatrix.setMatrixArrayType(Array);
      const i = Math.PI * 2;
      function b(m, o, n, W, e) {
        e %= i, e < 0 && (e += i);
        const I = Math.tan(e);
        if (Math.abs(I) < 1e5) {
          const a = o - I * m, V = 1 / n ** 2 + I ** 2 / W ** 2;
          let h = -1;
          (e <= Math.PI / 2 || e > 3 * Math.PI / 2) && (h = 1);
          const Y = h * Math.sqrt(1 / V) + m, p = I * Y + a;
          return [Y, p];
        }
        return e < Math.PI ? [m, o + W] : [m, o - W];
      }
    },
    /* 56 */
    /***/
    function(s, l, d) {
      d.r(l), d.d(l, "default", function() {
        return E;
      });
      var i = d(1), b = d(42), m = /* @__PURE__ */ d.n(b), o = d(57), n = d(28), W = d(24), e = d(30), I = d(59), a = d(53), V = d(60), h = /* @__PURE__ */ d.n(V), Y = d(46), p = /* @__PURE__ */ d.n(Y), G = d(31), y = d(40), Z = d(21);
      d(1).glMatrix.setMatrixArrayType(Array);
      function X(j, N) {
        if (j == null)
          return {};
        var Q = c(j, N), u, x;
        if (Object.getOwnPropertySymbols) {
          var T = Object.getOwnPropertySymbols(j);
          for (x = 0; x < T.length; x++)
            u = T[x], !(N.indexOf(u) >= 0) && Object.prototype.propertyIsEnumerable.call(j, u) && (Q[u] = j[u]);
        }
        return Q;
      }
      function c(j, N) {
        if (j == null)
          return {};
        var Q = {}, u = Object.keys(j), x, T;
        for (T = 0; T < u.length; T++)
          x = u[T], !(N.indexOf(x) >= 0) && (Q[x] = j[x]);
        return Q;
      }
      const t = Symbol("mesh"), R = Symbol("contours"), S = Symbol("stroke"), J = Symbol("fill"), H = Symbol("strokeColor"), L = Symbol("fillColor"), C = Symbol("transform"), F = Symbol("invertTransform"), r = Symbol("uniforms"), K = Symbol("texOptions"), g = Symbol("blend"), v = Symbol("applyTexture"), f = Symbol("applyTransform"), O = Symbol("applyGradientTransform"), q = Symbol("applyProgram"), M = Symbol("gradient"), P = Symbol("filter"), D = Symbol("opacity"), dd = Symbol("program"), _ = Symbol("attributes"), cd = Symbol("pass"), $ = Symbol("clipContext"), Wd = Symbol("applyClipPath");
      function Xd(j, N) {
        const [Q, u] = [j[1][0] - j[0][0], j[1][1] - j[0][1]], x = [];
        for (let T = 0; T < N.length; T++) {
          const U = N[T], w = [(U[0] - j[0][0]) / Q, 1 - (U[1] - j[0][1]) / u];
          x.push(w);
        }
        return x;
      }
      function k([j, N], [Q, u, x, T], {
        scale: U
      }) {
        return U || (j /= x, N = 1 - N / T, j -= Q, N += u), [j, N, 0];
      }
      function z(j, N, Q) {
        const u = p()(j, N, Q);
        return u.path = j, u.simplify = Q, u.scale = N, u;
      }
      class E {
        constructor(N) {
          this[S] = null, this[J] = null, this[C] = [1, 0, 0, 1, 0, 0], this[D] = 1, this[r] = {}, this[P] = [], this[g] = null, this[K] = {}, this.contours = N.contours, this[dd] = null, this[_] = {}, this[cd] = [];
        }
        get contours() {
          return this[R];
        }
        set contours(N) {
          this[t] = null, this[R] = N;
          const Q = N.scale;
          this.transformScale / Q > 1.5 && this.accurate(this.transformScale);
        }
        setProgram(N) {
          this[dd] = N, this[t] && this[q](N);
        }
        get program() {
          return this[dd];
        }
        setAttribute(N, Q) {
          Q == null ? delete this[_][N] : this[_][N] = Q;
        }
        getOpacity() {
          return this[D];
        }
        setOpacity(N) {
          if (N < 0 || N > 1)
            throw new TypeError("Invalid opacity value.");
          this[t] && this[t].positions.forEach((Q) => {
            Q[2] = 1 / Q[2] > 0 ? N : -N;
          }), this[D] = N;
        }
        setClipPath(N) {
          this.clipPath = N, this[r].u_clipSampler && this[r].u_clipSampler.delete(), this.setUniforms({
            u_clipSampler: null
          }), this[t] && delete this[t].attributes.a_clipUV, N && this[t] && this[Wd]();
        }
        [Wd]() {
          if (this.clipPath) {
            this[$] || (this[$] = Z.default.createCanvas(1, 1));
            const [[N, Q], [u, x]] = this.boundingBox;
            u && x && (this[$].width = u - N, this[$].height = x - Q);
            const T = this[$].getContext("2d"), U = new Path2D(this.clipPath);
            T.clearRect(0, 0, this[$].width, this[$].height), T.save(), T.translate(-N, -Q), T.fillStyle = "white", T.fill(U), T.restore(), this[t].clipPath = this[$];
            const w = Xd(this.boundingBox, this[t].position0);
            this[t].attributes.a_clipUV = w;
          }
        }
        getPointAtLength(N) {
          return Object(a.getPointAtLength)(this[R], N);
        }
        getTotalLength() {
          return Object(a.getTotalLength)(this[R]);
        }
        get blend() {
          return this[g] == null ? "auto" : this[g];
        }
        set blend(N) {
          this[g] = N, this[t] && (this[t].enableBlend = this.enableBlend);
        }
        get boundingBox() {
          if (this[t] && this[t].boundingBox)
            return this[t].boundingBox;
          const N = this.meshData;
          if (N) {
            const Q = N.position0;
            if (Q.length)
              N.boundingBox = m()(Q);
            else
              return [[0, 0], [0, 0]];
            return N.boundingBox;
          }
          return [[0, 0], [0, 0]];
        }
        get boundingCenter() {
          const N = this.boundingBox;
          return N ? [0.5 * (N[0][0] + N[1][0]), 0.5 * (N[0][1] + N[1][1])] : [0, 0];
        }
        get fillRule() {
          return this[J] ? this[J].rule : "nonzero";
        }
        get lineWidth() {
          return this[S] ? this[S].lineWidth : 0;
        }
        get lineCap() {
          return this[S] ? this[S].lineCap : "";
        }
        get lineJoin() {
          return this[S] ? this[S].lineJoin : "";
        }
        get miterLimit() {
          return this[S] ? this[S].miterLimit : 0;
        }
        get strokeStyle() {
          return this[H] && this[H][3] !== 0 ? Object(W.default)(this[H]) : "";
        }
        get lineDash() {
          return this[S] ? this[S].lineDash : null;
        }
        get lineDashOffset() {
          return this[S] ? this[S].lineDashOffset : 0;
        }
        get fillStyle() {
          return this[L] && this[L][3] !== 0 ? Object(W.default)(this[L]) : "";
        }
        get gradient() {
          return this[M];
        }
        get texture() {
          return this[r].u_texSampler ? {
            image: this[r].u_texSampler._img,
            options: this[K]
          } : null;
        }
        get enableBlend() {
          return this[g] === !0 || this[g] === !1 ? this[g] : this[D] < 1 || this[H] != null && this[H][3] < 1 || this[L] != null && this[L][3] < 1 || this[r].u_colorMatrix != null && this[r].u_colorMatrix[18] < 1 || this[r].u_radialGradientVector != null || this.beforeRender || this.afterRender;
        }
        get filterCanvas() {
          return /blur|drop-shadow|url/.test(this.filter);
        }
        get filter() {
          return this[P].join(" ");
        }
        get transformMatrix() {
          return this[C];
        }
        get invertMatrix() {
          if (!this[F]) {
            const N = i.mat2d.invert(Array.of(0, 0, 0, 0, 0, 0), this[C]);
            this[F] = N;
          }
          return this[F];
        }
        get transformScale() {
          const N = this[C];
          return Math.max(Math.hypot(N[0], N[1]), Math.hypot(N[2], N[3]));
        }
        get uniforms() {
          return this[r];
        }
        get pass() {
          return this[cd];
        }
        [q](N) {
          const Q = this[_], u = this[t].position0, x = Object.entries(N._attribute);
          for (let T = 0; T < x.length; T++) {
            const [U, w] = x[T];
            if (U !== "a_color" && U !== "a_sourceRect" && w !== "ignored") {
              const B = Q[U];
              if (U === "uv" && !B) {
                const A = this[t].boundingBox || m()(u);
                this[t].attributes[U] = Xd(A, u);
              } else {
                this[t].attributes[U] = [];
                for (let A = 0; A < u.length; A++) {
                  const ld = u[A];
                  this[t].attributes[U].push(B ? B(ld, T, u) : Array(w.size).fill(0));
                }
              }
            }
          }
        }
        // {stroke, fill}
        get meshData() {
          if (this._updateMatrix && this.transformScale / this.contours.scale > 1.5 && this.accurate(this.transformScale), !this[t]) {
            !this[J] && !this[S] && this.setFill();
            const N = this[R], Q = {};
            if (N && N.length) {
              if (this[J])
                try {
                  const T = h()(N, this[J]);
                  T.positions = T.positions.map((U) => (U.push(this[D]), U)), T.attributes = {
                    a_color: Array.from({
                      length: T.positions.length
                    }).map(() => this[L].map((U) => Math.round(255 * U)))
                    // a_sourceRect: Array.from({length: mesh.positions.length}).map(() => [0, 0, 0, 0]),
                  }, Q.fill = T;
                } catch {
                }
              if (this[S]) {
                const T = this[S].lineDash;
                let U = N;
                if (T) {
                  const B = this[S].lineDashOffset;
                  U = Object(a.getDashContours)(N, T, B);
                }
                const w = U.map((B, A) => {
                  const ld = B.length > 1 && i.vec2.equals(B[0], B[B.length - 1]), id = this[S].build(B, ld);
                  return h()([id]);
                });
                w.forEach((B) => {
                  B.positions = B.positions.map((A) => (A.push(-this[D]), A)), B.attributes = {
                    a_color: Array.from({
                      length: B.positions.length
                    }).map(() => this[H].map((A) => Math.round(255 * A)))
                  };
                }), Q.stroke = Object(n.default)(w);
              }
            }
            const u = Object(n.default)([Q.fill, Q.stroke]);
            u.fillPointCount = Q.fill ? Q.fill.positions.length : 0, u.enableBlend = this.enableBlend, u.position0 = u.positions.map(([T, U, w]) => [T, U, w]), u.uniforms = this[r], this[t] = u, this[r].u_texSampler && this[v](u, this[K]);
            const x = this[C];
            Object(I.isUnitTransform)(x) || (this[f](u, x), this[r].u_radialGradientVector && this[O]()), this.clipPath && this[Wd](), this[dd] && this[q](this[dd]);
          }
          return this._updateMatrix && (this[t].matrix = this[C], this[f](this[t], this[C]), this[r].u_radialGradientVector && this[O]()), this[t];
        }
        [f](N, Q) {
          const {
            positions: u,
            position0: x
          } = N;
          for (let T = 0; T < u.length; T++) {
            const [U, w] = x[T], B = u[T];
            B[0] = U * Q[0] + w * Q[2] + Q[4], B[1] = U * Q[1] + w * Q[3] + Q[5];
          }
          this._updateMatrix = !1;
        }
        [O]() {
          const N = this[C], Q = [...this._radialGradientVector];
          if (Q) {
            const [u, x, , T, U] = Q;
            Q[0] = u * N[0] + x * N[2] + N[4], Q[1] = u * N[1] + x * N[3] + N[5], Q[3] = T * N[0] + U * N[2] + N[4], Q[4] = T * N[1] + U * N[3] + N[5], this[r].u_radialGradientVector = Q;
          }
        }
        [v](N, Q) {
          function u(A, ld) {
            return A == null && ld == null ? !0 : A == null || ld == null ? !1 : A[0] === ld[0] && A[1] === ld[1] && A[2] === ld[2] && A[3] === ld[3];
          }
          const x = this[r].u_texSampler;
          if (!x)
            return;
          const {
            width: T,
            height: U
          } = x._img, w = Q.srcRect;
          let B = Q.rect || [0, 0];
          if (Q.rotated && (B = [-B[1], B[0], B[3], B[2]]), B[2] == null && (B[2] = w ? w[2] : T), B[3] == null && (B[3] = w ? w[3] : U), Q.hidden)
            N.textureCoord = N.positions.map(() => [-1, -1, -1]);
          else if (!N.textureCoord || !u(this[K].rect, Q.rect) || this[K].hidden !== Q.hidden || this[K].rotated !== Q.rotated) {
            let A = null;
            Q.rotated && (A = i.mat2d.rotate(Array.of(0, 0, 0, 0, 0, 0), i.mat2d.fromValues(1, 0, 0, 1, 0, 0), 0.5 * Math.PI), A = i.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), A, [0, -B[2]])), N.textureCoord = N.position0.map(([ld, id, sd]) => {
              if (1 / sd > 0) {
                if (Q.rotated) {
                  const Zd = ld * A[0] + id * A[2] + A[4], bd = ld * A[1] + id * A[3] + A[5];
                  [ld, id] = [Zd, bd];
                }
                const td = k([ld, id], [B[0] / B[2], B[1] / B[3], B[2], B[3]], Q);
                return Q.repeat && (td[2] = 1), td;
              }
              return [-1, -1, -1];
            });
          }
          if (w) {
            const A = [w[0] / T, w[1] / U, w[2] / T, w[3] / U];
            N.attributes.a_sourceRect = N.positions.map(() => [...A]);
          } else
            N.attributes.a_sourceRect = N.positions.map(() => [0, 0, 0, 0]);
        }
        accurate(N) {
          if (!this.contours)
            return;
          if (this.contours.path) {
            const u = this.contours.simplify, x = z(this.contours.path, 2 * N, u);
            this[t] = null, this[R] = x;
          }
        }
        canIgnore() {
          const N = this[S] == null || this[S].lineWidth === 0 || this[H][3] === 0, Q = this[J] == null || this[L][3] === 0, u = this[r].u_radialGradientVector == null, x = this[r].u_texSampler == null;
          return this[D] === 0 || this[dd] == null && N && Q && u && x && !this.beforeRender && !this.afterRender;
        }
        // join: 'miter' or 'bevel'
        // cap: 'butt' or 'square'
        // lineDash: null
        // lineDashOffset: 0
        setStroke({
          thickness: N = 1,
          cap: Q = "butt",
          join: u = "miter",
          miterLimit: x = 10,
          color: T = [0, 0, 0, 0],
          lineDash: U = null,
          lineDashOffset: w = 0,
          roundSegments: B = 20
        } = {}) {
          return this[t] = null, this[S] = new o.default({
            lineWidth: N,
            lineCap: Q,
            lineJoin: u,
            miterLimit: x,
            roundSegments: B
          }), typeof T == "string" && (T = Object(G.default)(T)), this[H] = T, this[S].lineDash = U, this[S].lineDashOffset = w, this;
        }
        setFill({
          rule: N = this.fillRule,
          color: Q = [0, 0, 0, 0]
        } = {}) {
          return this[t] = null, this[J] = {
            rule: N
          }, typeof Q == "string" && (Q = Object(G.default)(Q)), this[L] = Q, this;
        }
        /**
          options: {
            scale: false,
            repeat: false,
            rotated: false,
            rect: [10, 10],
            srcRect: [...],
            hidden: false,
          }
         */
        setTexture(N, Q = {}) {
          if (N && N.image) {
            const {
              image: u,
              rect: x
            } = N;
            if (N = u, Q.rect)
              for (let T = 0; T < Q.rect.length; T++)
                x[T] = Q.rect[T];
            Q.rect = x;
          }
          return this[J] || this.setFill(), this.setUniforms({
            u_texSampler: N
          }), this[t] && this[v](this[t], Q), this[K] = Q, this;
        }
        setCircularGradient({
          vector: N,
          colors: Q,
          type: u = "fill"
        } = {}) {
          if (N.length !== 3)
            throw new TypeError("Invalid linearGradient.");
          this.setGradient({
            vector: N,
            colors: Q,
            type: u
          });
        }
        setLinearGradient({
          vector: N,
          colors: Q,
          type: u = "fill"
        } = {}) {
          if (N.length !== 4)
            throw new TypeError("Invalid linearGradient.");
          this.setGradient({
            vector: N,
            colors: Q,
            type: u
          });
        }
        setRadialGradient({
          vector: N,
          colors: Q,
          type: u = "fill"
        } = {}) {
          if (N.length !== 6)
            throw new TypeError("Invalid radialGradient.");
          this.setGradient({
            vector: N,
            colors: Q,
            type: u
          });
        }
        /**
          vector: [x0, y0, r0, x1, y1, r1],
          colors: [{offset:0, color}, {offset:1, color}, ...],
         */
        setGradient({
          vector: N,
          colors: Q,
          type: u = "fill"
        } = {}) {
          Q = Q.map(({
            offset: U,
            color: w
          }) => (typeof w == "string" && (w = Object(G.default)(w)), {
            offset: U,
            color: w
          })), this[M] = this[M] || {}, this[M][u] = {
            vector: N,
            colors: Q
          }, Q.sort((U, w) => U.offset - w.offset);
          const x = [];
          Q.forEach(({
            offset: U,
            color: w
          }) => {
            x.push(U, ...w);
          });
          let T;
          if (N.length === 4 ? T = [N[0], N[1], 0, N[2], N[3], 0] : T = [...N], x.length < 40 && x.push(-1), x.length > 40)
            throw new Error("Too many colors, should be less than 8 colors");
          return this._radialGradientVector = T, this[r].u_colorSteps = x, u === "fill" ? this[r].u_gradientType = 1 : this[r].u_gradientType = 0, this[O](), this;
        }
        setUniforms(N = {}) {
          return Object.assign(this[r], N), this;
        }
        setTransform(...N) {
          const Q = this[C];
          return i.mat2d.equals(N, Q) || (this[C] = N, delete this[F], this._updateMatrix = !0), this;
        }
        transform(...N) {
          const Q = this[C];
          return this[C] = i.mat2d.multiply(Array.of(0, 0, 0, 0, 0, 0), Q, N), delete this[F], this._updateMatrix = !0, this;
        }
        translate(N, Q) {
          let u = i.mat2d.create();
          return u = i.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), u, [N, Q]), this.transform(...u);
        }
        rotate(N, [Q, u] = [0, 0]) {
          let x = i.mat2d.create();
          return x = i.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), x, [Q, u]), x = i.mat2d.rotate(Array.of(0, 0, 0, 0, 0, 0), x, N), x = i.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), x, [-Q, -u]), this.transform(...x);
        }
        scale(N, Q = N, [u, x] = [0, 0]) {
          let T = i.mat2d.create();
          return T = i.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), T, [u, x]), T = i.mat2d.scale(Array.of(0, 0, 0, 0, 0, 0), T, [N, Q]), T = i.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), T, [-u, -x]), this.transform(...T);
        }
        skew(N, Q = N, [u, x] = [0, 0]) {
          let T = i.mat2d.create();
          return T = i.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), T, [u, x]), T = i.mat2d.multiply(Array.of(0, 0, 0, 0, 0, 0), T, i.mat2d.fromValues(1, Math.tan(Q), Math.tan(N), 1, 0, 0)), T = i.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), T, [-u, -x]), this.transform(...T);
        }
        clearFilter() {
          return this.setColorTransform(null), this[P].length = 0, this;
        }
        setColorTransform(...N) {
          return N[0] === null ? this.setUniforms({
            u_filterFlag: 0,
            u_colorMatrix: 0
          }) : this.setUniforms({
            u_filterFlag: 1,
            u_colorMatrix: N
          }), this;
        }
        // apply linear color transform
        transformColor(...N) {
          let Q = this.uniforms.u_colorMatrix;
          return Q ? Q = Object(e.multiply)(Q, N) : Q = N, this.setColorTransform(...Q), this;
        }
        blur(N) {
          return this[P].push(`blur(${N}px)`), this;
        }
        brightness(N = 1) {
          return this[P].push(`brightness(${100 * N}%)`), this.transformColor(...Object(e.brightness)(N));
        }
        contrast(N = 1) {
          return this[P].push(`contrast(${100 * N}%)`), this.transformColor(...Object(e.contrast)(N));
        }
        dropShadow(N, Q, u = 0, x = [0, 0, 0, 1]) {
          return Array.isArray(x) && (x = Object(W.default)(x)), this[P].push(`drop-shadow(${N}px ${Q}px ${u}px ${x})`), this;
        }
        grayscale(N = 1) {
          return this[P].push(`grayscale(${100 * N}%)`), this.transformColor(...Object(e.grayscale)(N));
        }
        // https://github.com/phoboslab/WebGLImageFilter/blob/master/webgl-image-filter.js#L371
        hueRotate(N = 0) {
          return this[P].push(`hue-rotate(${N}deg)`), this.transformColor(...Object(e.hueRotate)(N));
        }
        invert(N = 1) {
          return this[P].push(`invert(${100 * N}%)`), this.transformColor(...Object(e.invert)(N));
        }
        opacity(N = 1) {
          return this[P].push(`opacity(${100 * N}%)`), this.transformColor(...Object(e.opacity)(N));
        }
        saturate(N = 1) {
          return this[P].push(`saturate(${100 * N}%)`), this.transformColor(...Object(e.saturate)(N));
        }
        sepia(N = 1) {
          return this[P].push(`sepia(${100 * N}%)`), this.transformColor(...Object(e.sepia)(N));
        }
        url(N) {
          return this[P].push(`url(${N})`), this;
        }
        isPointCollision(N, Q, u = "both") {
          const x = this.meshData, {
            positions: T,
            cells: U
          } = x, w = this.invertMatrix, B = w[0] * N + w[2] * Q + w[4], A = w[1] * N + w[3] * Q + w[5], ld = this.boundingBox;
          if (B < ld[0][0] || B > ld[1][0] || A < ld[0][1] || A > ld[1][1])
            return !1;
          function id([sd, td], [Zd, bd], [md, od]) {
            const ed = md - Zd, nd = od - bd, hd = ((sd - Zd) * ed + (td - bd) * nd) / (ed ** 2 + nd ** 2);
            return hd >= 0 && hd <= 1;
          }
          for (let sd = 0; sd < U.length; sd++) {
            const td = U[sd];
            if (u === "fill" && td[0] >= x.fillPointCount)
              break;
            if (u === "stroke" && td[0] < x.fillPointCount)
              continue;
            const [[Zd, bd], [md, od], [ed, nd]] = td.map((xd) => T[xd]), hd = Math.sign((N - Zd) * (od - bd) - (md - Zd) * (Q - bd));
            if (hd === 0 && id([N, Q], [Zd, bd], [md, od]))
              return !0;
            const Sd = Math.sign((N - md) * (nd - od) - (ed - md) * (Q - od));
            if (Sd === 0 && id([N, Q], [md, od], [ed, nd]))
              return !0;
            const Rd = Math.sign((N - ed) * (bd - nd) - (Zd - ed) * (Q - nd));
            if (Rd === 0 && id([N, Q], [ed, nd], [Zd, bd]) || hd === 1 && Sd === 1 && Rd === 1 || hd === -1 && Sd === -1 && Rd === -1)
              return !0;
          }
          return !1;
        }
        isPointInFill(N, Q) {
          return this.isPointCollision(N, Q, "fill");
        }
        isPointInStroke(N, Q) {
          return this.isPointCollision(N, Q, "stroke");
        }
        addPass(N, Q = {}) {
          let {
            width: u,
            height: x
          } = Q, T = X(Q, ["width", "height"]);
          const U = new y.default();
          U.rect(0, 0, u, x);
          const w = new E(U, {
            width: u,
            height: x
          });
          w.setUniforms(T), w.setProgram(N), this[cd].push(w);
        }
      }
    },
    /* 57 */
    /***/
    function(s, l, d) {
      d.r(l);
      var i = d(58);
      d(1).glMatrix.setMatrixArrayType(Array), l.default = i.Stroke;
    },
    /* 58 */
    /***/
    function(s, l, d) {
      d.r(l), d.d(l, "Stroke", function() {
        return I;
      });
      var i = d(49);
      d(1).glMatrix.setMatrixArrayType(Array);
      const b = Object(i.create)(), m = Object(i.create)(), o = Object(i.create)(), n = Object(i.create)(), W = Object(i.create)(), e = 1e20;
      class I {
        constructor({
          lineWidth: p = 1,
          lineJoin: G = "miter",
          miterLimit: y = 10,
          lineCap: Z = "butt",
          roundSegments: X = 20
        } = {}) {
          this.lineWidth = p, this.lineJoin = G, this.miterLimit = y, this.lineCap = Z, this.roundSegments = X, this._normal = null;
        }
        build(p, G = !1) {
          let y = p.length;
          if (p = [...p], y < 2)
            return p;
          G && ((p[0][0] !== p[y - 1][0] || p[0][1] !== p[y - 1][1]) && p.push([...p[0]]), p.push([...p[1]])), y = p.length, this._normal = null;
          const Z = {
            left: [],
            right: []
          }, X = this.lineWidth / 2, c = this.lineCap;
          if (!G && c === "square") {
            Object(i.direction)(m, p[0], p[1]), Object(i.scaleAndAdd)(p[0], p[0], m, X);
            const R = p.length - 1;
            Object(i.direction)(m, p[R], p[R - 1]), Object(i.scaleAndAdd)(p[R], p[R], m, X);
          }
          for (let R = 1; R < y; R++) {
            const S = p[R - 1], J = p[R], H = p[R + 1];
            this._seg(Z, S, J, H, X, G);
          }
          return !G && c === "round" && h(Z, this.roundSegments), [...Z.left, ...Z.right.reverse()];
        }
        _seg(p, G, y, Z, X, c) {
          const t = this.lineJoin === "bevel", R = this.lineJoin === "round";
          if (Object(i.direction)(m, y, G), this._normal || (this._normal = Object(i.create)(), Object(i.normal)(this._normal, m)), p.left.length || V(p, G, this._normal, X), !Z)
            Object(i.normal)(this._normal, m), c ? V(p, G, this._normal, X) : V(p, y, this._normal, X);
          else {
            Object(i.direction)(o, Z, y);
            let S = Object(i.computeMiter)(n, W, m, o, X);
            S = Math.min(S, e);
            const J = Object(i.dot)(n, this._normal) < 0 ? -1 : 1;
            let H = t || R;
            if (!H && this.lineJoin === "miter" && S / X > this.miterLimit && (H = !0), H) {
              Object(i.scaleAndAdd)(b, y, this._normal, -X * J), a(p, b, J);
              let L = 1 / 0;
              G && (L = Math.min(L, Math.hypot(y[0] - G[0], y[1] - G[1]))), Z && (L = Math.min(L, Math.hypot(Z[0] - y[0], Z[1] - y[1])));
              const C = Math.max(X, Math.min(S, L));
              if (Object(i.scaleAndAdd)(b, y, W, C * J), a(p, b, -J), Z)
                if (Object(i.normal)(b, o), Object(i.copy)(this._normal, b), Object(i.scaleAndAdd)(b, y, b, -X * J), R) {
                  const F = Object(i.clone)(b), r = J > 0 ? p.left[p.left.length - 1] : p.right[p.right.length - 1], K = Object(i.clone)(y), g = Object(i.sub)(Object(i.create)(), r, K), v = Object(i.sub)(Object(i.create)(), F, K), f = Math.PI / this.roundSegments;
                  for (let O = 0; O < this.roundSegments && (Object(i.rotate)(g, g, [0, 0], J * f), Math.sign(Object(i.cross)(b, g, v)[2]) === J); O++)
                    Object(i.add)(b, g, K), a(p, b, J);
                  a(p, F, J);
                } else
                  a(p, b, J);
            } else
              V(p, y, W, S), Object(i.copy)(this._normal, W);
          }
        }
      }
      function a(Y, p, G) {
        G > 0 ? Y.left.push(Object(i.clone)(p)) : Y.right.push(Object(i.clone)(p));
      }
      function V(Y, p, G, y, Z = -1) {
        Object(i.scaleAndAdd)(b, p, G, -y), a(Y, b, -Z), Object(i.scaleAndAdd)(b, p, G, y), a(Y, b, Z);
      }
      function h({
        left: Y,
        right: p
      }, G) {
        const y = Object(i.create)(), Z = Object(i.create)();
        let X = Y[0], c = p[0], t = [0.5 * (X[0] + c[0]), 0.5 * (X[1] + c[1])];
        Object(i.sub)(Z, X, t);
        for (let R = 1; R <= G; R++) {
          const S = -1 * Math.PI * R / G;
          Object(i.rotate)(y, Z, [0, 0], S), Object(i.add)(b, t, y), Y.unshift(Object(i.clone)(b));
        }
        X = p[p.length - 1], c = Y[Y.length - 1], t = [0.5 * (X[0] + c[0]), 0.5 * (X[1] + c[1])], Object(i.sub)(Z, X, t);
        for (let R = 1; R <= G; R++) {
          const S = -1 * Math.PI * R / G;
          Object(i.rotate)(y, Z, [0, 0], S), Object(i.add)(b, t, y), p.push(Object(i.clone)(b));
        }
      }
    },
    /* 59 */
    /***/
    function(s, l, d) {
      d.r(l), d.d(l, "isUnitTransform", function() {
        return i;
      }), d(1).glMatrix.setMatrixArrayType(Array);
      function i(b) {
        return b[0] === 1 && b[1] === 0 && b[2] === 0 && b[3] === 1 && b[4] === 0 && b[5] === 0;
      }
    },
    /* 60 */
    /***/
    function(s, l, d) {
      d(1).glMatrix.setMatrixArrayType(Array);
      var i = d(61), b = d(62);
      s.exports = function(m, o) {
        if (o = o || {}, m = m.filter(function(G) {
          return G.length > 2;
        }), m.length === 0)
          return {
            positions: [],
            cells: []
          };
        typeof o.vertexSize != "number" && (o.vertexSize = m[0][0].length), m = m.map(function(G) {
          return G.reduce(function(y, Z) {
            return y.concat(Z);
          });
        });
        const n = o.rule === "evenodd" ? i.WINDING_ODD : i.WINDING_NONZERO;
        for (var W = i.tesselate(b({
          contours: m,
          windingRule: n,
          elementType: i.POLYGONS,
          polySize: 3,
          vertexSize: 2
        }, o)), e = [], I = 0; I < W.vertices.length; I += o.vertexSize) {
          var a = W.vertices.slice(I, I + o.vertexSize);
          e.push(a);
        }
        var V = [];
        for (I = 0; I < W.elements.length; I += 3) {
          var h = W.elements[I], Y = W.elements[I + 1], p = W.elements[I + 2];
          V.push([h, Y, p]);
        }
        return {
          positions: e,
          cells: V
        };
      };
    },
    /* 61 */
    /***/
    function(s, l, d) {
      d(1).glMatrix.setMatrixArrayType(Array);
      var i = {}, b = {};
      s.exports = i, i.WINDING_ODD = 0, i.WINDING_NONZERO = 1, i.WINDING_POSITIVE = 2, i.WINDING_NEGATIVE = 3, i.WINDING_ABS_GEQ_TWO = 4, i.POLYGONS = 0, i.CONNECTED_POLYGONS = 1, i.BOUNDARY_CONTOURS = 2, i.tesselate = function(Z) {
        for (var X = Z.debug || !1, c = new y(), t = 0; t < Z.contours.length; t++)
          c.addContour(Z.vertexSize || 2, Z.contours[t]);
        return c.tesselate(Z.windingRule || i.WINDING_ODD, Z.elementType || i.POLYGONS, Z.polySize || 3, Z.vertexSize || 2, Z.normal || [0, 0, 1]), {
          vertices: c.vertices,
          vertexIndices: c.vertexIndices,
          vertexCount: c.vertexCount,
          elements: c.elements,
          elementCount: c.elementCount,
          mesh: X ? c.mesh : void 0
        };
      };
      var m = function(Z) {
        if (!Z)
          throw "Assertion Failed!";
      };
      function o() {
        this.next = null, this.prev = null, this.anEdge = null, this.coords = [0, 0, 0], this.s = 0, this.t = 0, this.pqHandle = 0, this.n = 0, this.idx = 0;
      }
      function n() {
        this.next = null, this.prev = null, this.anEdge = null, this.trail = null, this.n = 0, this.marked = !1, this.inside = !1;
      }
      function W(Z) {
        this.next = null, this.Sym = null, this.Onext = null, this.Lnext = null, this.Org = null, this.Lface = null, this.activeRegion = null, this.winding = 0, this.side = Z;
      }
      W.prototype = {
        get Rface() {
          return this.Sym.Lface;
        },
        set Rface(Z) {
          this.Sym.Lface = Z;
        },
        get Dst() {
          return this.Sym.Org;
        },
        set Dst(Z) {
          this.Sym.Org = Z;
        },
        get Oprev() {
          return this.Sym.Lnext;
        },
        set Oprev(Z) {
          this.Sym.Lnext = Z;
        },
        get Lprev() {
          return this.Onext.Sym;
        },
        set Lprev(Z) {
          this.Onext.Sym = Z;
        },
        get Dprev() {
          return this.Lnext.Sym;
        },
        set Dprev(Z) {
          this.Lnext.Sym = Z;
        },
        get Rprev() {
          return this.Sym.Onext;
        },
        set Rprev(Z) {
          this.Sym.Onext = Z;
        },
        get Dnext() {
          return (
            /*this.Rprev*/
            this.Sym.Onext.Sym
          );
        },
        /* 3 pointers */
        set Dnext(Z) {
          this.Sym.Onext.Sym = Z;
        },
        /* 3 pointers */
        get Rnext() {
          return (
            /*this.Oprev*/
            this.Sym.Lnext.Sym
          );
        },
        /* 3 pointers */
        set Rnext(Z) {
          this.Sym.Lnext.Sym = Z;
        }
        /* 3 pointers */
      };
      function e() {
        var Z = new o(), X = new n(), c = new W(0), t = new W(1);
        Z.next = Z.prev = Z, Z.anEdge = null, X.next = X.prev = X, X.anEdge = null, X.trail = null, X.marked = !1, X.inside = !1, c.next = c, c.Sym = t, c.Onext = null, c.Lnext = null, c.Org = null, c.Lface = null, c.winding = 0, c.activeRegion = null, t.next = t, t.Sym = c, t.Onext = null, t.Lnext = null, t.Org = null, t.Lface = null, t.winding = 0, t.activeRegion = null, this.vHead = Z, this.fHead = X, this.eHead = c, this.eHeadSym = t;
      }
      e.prototype = {
        /* MakeEdge creates a new pair of half-edges which form their own loop.
        * No vertex or face structures are allocated, but these must be assigned
        * before the current edge operation is completed.
        */
        //static TESShalfEdge *MakeEdge( TESSmesh* mesh, TESShalfEdge *eNext )
        makeEdge_: function(Z) {
          var X = new W(0), c = new W(1);
          Z.Sym.side < Z.side && (Z = Z.Sym);
          var t = Z.Sym.next;
          return c.next = t, t.Sym.next = X, X.next = Z, Z.Sym.next = c, X.Sym = c, X.Onext = X, X.Lnext = c, X.Org = null, X.Lface = null, X.winding = 0, X.activeRegion = null, c.Sym = X, c.Onext = c, c.Lnext = X, c.Org = null, c.Lface = null, c.winding = 0, c.activeRegion = null, X;
        },
        /* Splice( a, b ) is best described by the Guibas/Stolfi paper or the
        * CS348a notes (see mesh.h).  Basically it modifies the mesh so that
        * a->Onext and b->Onext are exchanged.  This can have various effects
        * depending on whether a and b belong to different face or vertex rings.
        * For more explanation see tessMeshSplice() below.
        */
        // static void Splice( TESShalfEdge *a, TESShalfEdge *b )
        splice_: function(Z, X) {
          var c = Z.Onext, t = X.Onext;
          c.Sym.Lnext = X, t.Sym.Lnext = Z, Z.Onext = t, X.Onext = c;
        },
        /* MakeVertex( newVertex, eOrig, vNext ) attaches a new vertex and makes it the
        * origin of all edges in the vertex loop to which eOrig belongs. "vNext" gives
        * a place to insert the new vertex in the global vertex list.  We insert
        * the new vertex *before* vNext so that algorithms which walk the vertex
        * list will not see the newly created vertices.
        */
        //static void MakeVertex( TESSvertex *newVertex, TESShalfEdge *eOrig, TESSvertex *vNext )
        makeVertex_: function(Z, X, c) {
          var t = Z;
          m(t !== null);
          var R = c.prev;
          t.prev = R, R.next = t, t.next = c, c.prev = t, t.anEdge = X;
          var S = X;
          do
            S.Org = t, S = S.Onext;
          while (S !== X);
        },
        /* MakeFace( newFace, eOrig, fNext ) attaches a new face and makes it the left
        * face of all edges in the face loop to which eOrig belongs.  "fNext" gives
        * a place to insert the new face in the global face list.  We insert
        * the new face *before* fNext so that algorithms which walk the face
        * list will not see the newly created faces.
        */
        // static void MakeFace( TESSface *newFace, TESShalfEdge *eOrig, TESSface *fNext )
        makeFace_: function(Z, X, c) {
          var t = Z;
          m(t !== null);
          var R = c.prev;
          t.prev = R, R.next = t, t.next = c, c.prev = t, t.anEdge = X, t.trail = null, t.marked = !1, t.inside = c.inside;
          var S = X;
          do
            S.Lface = t, S = S.Lnext;
          while (S !== X);
        },
        /* KillEdge( eDel ) destroys an edge (the half-edges eDel and eDel->Sym),
        * and removes from the global edge list.
        */
        //static void KillEdge( TESSmesh *mesh, TESShalfEdge *eDel )
        killEdge_: function(Z) {
          Z.Sym.side < Z.side && (Z = Z.Sym);
          var X = Z.next, c = Z.Sym.next;
          X.Sym.next = c, c.Sym.next = X;
        },
        /* KillVertex( vDel ) destroys a vertex and removes it from the global
        * vertex list.  It updates the vertex loop to point to a given new vertex.
        */
        //static void KillVertex( TESSmesh *mesh, TESSvertex *vDel, TESSvertex *newOrg )
        killVertex_: function(Z, X) {
          var c = Z.anEdge, t = c;
          do
            t.Org = X, t = t.Onext;
          while (t !== c);
          var R = Z.prev, S = Z.next;
          S.prev = R, R.next = S;
        },
        /* KillFace( fDel ) destroys a face and removes it from the global face
        * list.  It updates the face loop to point to a given new face.
        */
        //static void KillFace( TESSmesh *mesh, TESSface *fDel, TESSface *newLface )
        killFace_: function(Z, X) {
          var c = Z.anEdge, t = c;
          do
            t.Lface = X, t = t.Lnext;
          while (t !== c);
          var R = Z.prev, S = Z.next;
          S.prev = R, R.next = S;
        },
        /****************** Basic Edge Operations **********************/
        /* tessMeshMakeEdge creates one edge, two vertices, and a loop (face).
        * The loop consists of the two new half-edges.
        */
        //TESShalfEdge *tessMeshMakeEdge( TESSmesh *mesh )
        makeEdge: function() {
          var Z = new o(), X = new o(), c = new n(), t = this.makeEdge_(this.eHead);
          return this.makeVertex_(Z, t, this.vHead), this.makeVertex_(X, t.Sym, this.vHead), this.makeFace_(c, t, this.fHead), t;
        },
        /* tessMeshSplice( eOrg, eDst ) is the basic operation for changing the
        * mesh connectivity and topology.  It changes the mesh so that
        *	eOrg->Onext <- OLD( eDst->Onext )
        *	eDst->Onext <- OLD( eOrg->Onext )
        * where OLD(...) means the value before the meshSplice operation.
        *
        * This can have two effects on the vertex structure:
        *  - if eOrg->Org != eDst->Org, the two vertices are merged together
        *  - if eOrg->Org == eDst->Org, the origin is split into two vertices
        * In both cases, eDst->Org is changed and eOrg->Org is untouched.
        *
        * Similarly (and independently) for the face structure,
        *  - if eOrg->Lface == eDst->Lface, one loop is split into two
        *  - if eOrg->Lface != eDst->Lface, two distinct loops are joined into one
        * In both cases, eDst->Lface is changed and eOrg->Lface is unaffected.
        *
        * Some special cases:
        * If eDst == eOrg, the operation has no effect.
        * If eDst == eOrg->Lnext, the new face will have a single edge.
        * If eDst == eOrg->Lprev, the old face will have a single edge.
        * If eDst == eOrg->Onext, the new vertex will have a single edge.
        * If eDst == eOrg->Oprev, the old vertex will have a single edge.
        */
        //int tessMeshSplice( TESSmesh* mesh, TESShalfEdge *eOrg, TESShalfEdge *eDst )
        splice: function(Z, X) {
          var c = !1, t = !1;
          if (Z !== X) {
            if (X.Org !== Z.Org && (t = !0, this.killVertex_(X.Org, Z.Org)), X.Lface !== Z.Lface && (c = !0, this.killFace_(X.Lface, Z.Lface)), this.splice_(X, Z), !t) {
              var R = new o();
              this.makeVertex_(R, X, Z.Org), Z.Org.anEdge = Z;
            }
            if (!c) {
              var S = new n();
              this.makeFace_(S, X, Z.Lface), Z.Lface.anEdge = Z;
            }
          }
        },
        /* tessMeshDelete( eDel ) removes the edge eDel.  There are several cases:
        * if (eDel->Lface != eDel->Rface), we join two loops into one; the loop
        * eDel->Lface is deleted.  Otherwise, we are splitting one loop into two;
        * the newly created loop will contain eDel->Dst.  If the deletion of eDel
        * would create isolated vertices, those are deleted as well.
        *
        * This function could be implemented as two calls to tessMeshSplice
        * plus a few calls to memFree, but this would allocate and delete
        * unnecessary vertices and faces.
        */
        //int tessMeshDelete( TESSmesh *mesh, TESShalfEdge *eDel )
        delete: function(Z) {
          var X = Z.Sym, c = !1;
          if (Z.Lface !== Z.Rface && (c = !0, this.killFace_(Z.Lface, Z.Rface)), Z.Onext === Z)
            this.killVertex_(Z.Org, null);
          else if (Z.Rface.anEdge = Z.Oprev, Z.Org.anEdge = Z.Onext, this.splice_(Z, Z.Oprev), !c) {
            var t = new n();
            this.makeFace_(t, Z, Z.Lface);
          }
          X.Onext === X ? (this.killVertex_(X.Org, null), this.killFace_(X.Lface, null)) : (Z.Lface.anEdge = X.Oprev, X.Org.anEdge = X.Onext, this.splice_(X, X.Oprev)), this.killEdge_(Z);
        },
        /******************** Other Edge Operations **********************/
        /* All these routines can be implemented with the basic edge
        * operations above.  They are provided for convenience and efficiency.
        */
        /* tessMeshAddEdgeVertex( eOrg ) creates a new edge eNew such that
        * eNew == eOrg->Lnext, and eNew->Dst is a newly created vertex.
        * eOrg and eNew will have the same left face.
        */
        // TESShalfEdge *tessMeshAddEdgeVertex( TESSmesh *mesh, TESShalfEdge *eOrg );
        addEdgeVertex: function(Z) {
          var X = this.makeEdge_(Z), c = X.Sym;
          this.splice_(X, Z.Lnext), X.Org = Z.Dst;
          var t = new o();
          return this.makeVertex_(t, c, X.Org), X.Lface = c.Lface = Z.Lface, X;
        },
        /* tessMeshSplitEdge( eOrg ) splits eOrg into two edges eOrg and eNew,
        * such that eNew == eOrg->Lnext.  The new vertex is eOrg->Dst == eNew->Org.
        * eOrg and eNew will have the same left face.
        */
        // TESShalfEdge *tessMeshSplitEdge( TESSmesh *mesh, TESShalfEdge *eOrg );
        splitEdge: function(Z, X) {
          var c = this.addEdgeVertex(Z), t = c.Sym;
          return this.splice_(Z.Sym, Z.Sym.Oprev), this.splice_(Z.Sym, t), Z.Dst = t.Org, t.Dst.anEdge = t.Sym, t.Rface = Z.Rface, t.winding = Z.winding, t.Sym.winding = Z.Sym.winding, t;
        },
        /* tessMeshConnect( eOrg, eDst ) creates a new edge from eOrg->Dst
        * to eDst->Org, and returns the corresponding half-edge eNew.
        * If eOrg->Lface == eDst->Lface, this splits one loop into two,
        * and the newly created loop is eNew->Lface.  Otherwise, two disjoint
        * loops are merged into one, and the loop eDst->Lface is destroyed.
        *
        * If (eOrg == eDst), the new face will have only two edges.
        * If (eOrg->Lnext == eDst), the old face is reduced to a single edge.
        * If (eOrg->Lnext->Lnext == eDst), the old face is reduced to two edges.
        */
        // TESShalfEdge *tessMeshConnect( TESSmesh *mesh, TESShalfEdge *eOrg, TESShalfEdge *eDst );
        connect: function(Z, X) {
          var c = !1, t = this.makeEdge_(Z), R = t.Sym;
          if (X.Lface !== Z.Lface && (c = !0, this.killFace_(X.Lface, Z.Lface)), this.splice_(t, Z.Lnext), this.splice_(R, X), t.Org = Z.Dst, R.Org = X.Org, t.Lface = R.Lface = Z.Lface, Z.Lface.anEdge = R, !c) {
            var S = new n();
            this.makeFace_(S, t, Z.Lface);
          }
          return t;
        },
        /* tessMeshZapFace( fZap ) destroys a face and removes it from the
        * global face list.  All edges of fZap will have a NULL pointer as their
        * left face.  Any edges which also have a NULL pointer as their right face
        * are deleted entirely (along with any isolated vertices this produces).
        * An entire mesh can be deleted by zapping its faces, one at a time,
        * in any order.  Zapped faces cannot be used in further mesh operations!
        */
        zapFace: function(Z) {
          var X = Z.anEdge, c, t, R, S, J;
          t = X.Lnext;
          do
            c = t, t = c.Lnext, c.Lface = null, c.Rface === null && (c.Onext === c ? this.killVertex_(c.Org, null) : (c.Org.anEdge = c.Onext, this.splice_(c, c.Oprev)), R = c.Sym, R.Onext === R ? this.killVertex_(R.Org, null) : (R.Org.anEdge = R.Onext, this.splice_(R, R.Oprev)), this.killEdge_(c));
          while (c != X);
          S = Z.prev, J = Z.next, J.prev = S, S.next = J;
        },
        countFaceVerts_: function(Z) {
          var X = Z.anEdge, c = 0;
          do
            c++, X = X.Lnext;
          while (X !== Z.anEdge);
          return c;
        },
        //int tessMeshMergeConvexFaces( TESSmesh *mesh, int maxVertsPerFace )
        mergeConvexFaces: function(Z) {
          var X, c, t, R, S, J, H;
          for (X = this.fHead.next; X !== this.fHead; X = X.next)
            if (X.inside)
              for (c = X.anEdge, S = c.Org; t = c.Lnext, R = c.Sym, R && R.Lface && R.Lface.inside && (J = this.countFaceVerts_(X), H = this.countFaceVerts_(R.Lface), J + H - 2 <= Z && b.vertCCW(c.Lprev.Org, c.Org, R.Lnext.Lnext.Org) && b.vertCCW(R.Lprev.Org, R.Org, c.Lnext.Lnext.Org) && (t = R.Lnext, this.delete(R), c = null, R = null)), !(c && c.Lnext.Org === S); )
                c = t;
          return !0;
        },
        /* tessMeshCheckMesh( mesh ) checks a mesh for self-consistency.
        */
        check: function() {
          var Z = this.fHead, X = this.vHead, c = this.eHead, t, R, S, J, H, L;
          for (R = Z, R = Z; (t = R.next) !== Z; R = t) {
            m(t.prev === R), H = t.anEdge;
            do
              m(H.Sym !== H), m(H.Sym.Sym === H), m(H.Lnext.Onext.Sym === H), m(H.Onext.Sym.Lnext === H), m(H.Lface === t), H = H.Lnext;
            while (H !== t.anEdge);
          }
          for (m(t.prev === R && t.anEdge === null), J = X, J = X; (S = J.next) !== X; J = S) {
            m(S.prev === J), H = S.anEdge;
            do
              m(H.Sym !== H), m(H.Sym.Sym === H), m(H.Lnext.Onext.Sym === H), m(H.Onext.Sym.Lnext === H), m(H.Org === S), H = H.Onext;
            while (H !== S.anEdge);
          }
          for (m(S.prev === J && S.anEdge === null), L = c, L = c; (H = L.next) !== c; L = H)
            m(H.Sym.next === L.Sym), m(H.Sym !== H), m(H.Sym.Sym === H), m(H.Org !== null), m(H.Dst !== null), m(H.Lnext.Onext.Sym === H), m(H.Onext.Sym.Lnext === H);
          m(H.Sym.next === L.Sym && H.Sym === this.eHeadSym && H.Sym.Sym === H && H.Org === null && H.Dst === null && H.Lface === null && H.Rface === null);
        }
      }, b.vertEq = function(Z, X) {
        return Z.s === X.s && Z.t === X.t;
      }, b.vertLeq = function(Z, X) {
        return Z.s < X.s || Z.s === X.s && Z.t <= X.t;
      }, b.transLeq = function(Z, X) {
        return Z.t < X.t || Z.t === X.t && Z.s <= X.s;
      }, b.edgeGoesLeft = function(Z) {
        return b.vertLeq(Z.Dst, Z.Org);
      }, b.edgeGoesRight = function(Z) {
        return b.vertLeq(Z.Org, Z.Dst);
      }, b.vertL1dist = function(Z, X) {
        return Math.abs(Z.s - X.s) + Math.abs(Z.t - X.t);
      }, b.edgeEval = function(Z, X, c) {
        m(b.vertLeq(Z, X) && b.vertLeq(X, c));
        var t = X.s - Z.s, R = c.s - X.s;
        return t + R > 0 ? t < R ? X.t - Z.t + (Z.t - c.t) * (t / (t + R)) : X.t - c.t + (c.t - Z.t) * (R / (t + R)) : 0;
      }, b.edgeSign = function(Z, X, c) {
        m(b.vertLeq(Z, X) && b.vertLeq(X, c));
        var t = X.s - Z.s, R = c.s - X.s;
        return t + R > 0 ? (X.t - c.t) * t + (X.t - Z.t) * R : 0;
      }, b.transEval = function(Z, X, c) {
        m(b.transLeq(Z, X) && b.transLeq(X, c));
        var t = X.t - Z.t, R = c.t - X.t;
        return t + R > 0 ? t < R ? X.s - Z.s + (Z.s - c.s) * (t / (t + R)) : X.s - c.s + (c.s - Z.s) * (R / (t + R)) : 0;
      }, b.transSign = function(Z, X, c) {
        m(b.transLeq(Z, X) && b.transLeq(X, c));
        var t = X.t - Z.t, R = c.t - X.t;
        return t + R > 0 ? (X.s - c.s) * t + (X.s - Z.s) * R : 0;
      }, b.vertCCW = function(Z, X, c) {
        return Z.s * (X.t - c.t) + X.s * (c.t - Z.t) + c.s * (Z.t - X.t) >= 0;
      }, b.interpolate = function(Z, X, c, t) {
        return Z = Z < 0 ? 0 : Z, c = c < 0 ? 0 : c, Z <= c ? c === 0 ? (X + t) / 2 : X + (t - X) * (Z / (Z + c)) : t + (X - t) * (c / (Z + c));
      }, b.intersect = function(Z, X, c, t, R) {
        var S, J, H;
        b.vertLeq(Z, X) || (H = Z, Z = X, X = H), b.vertLeq(c, t) || (H = c, c = t, t = H), b.vertLeq(Z, c) || (H = Z, Z = c, c = H, H = X, X = t, t = H), b.vertLeq(c, X) ? b.vertLeq(X, t) ? (S = b.edgeEval(Z, c, X), J = b.edgeEval(c, X, t), S + J < 0 && (S = -S, J = -J), R.s = b.interpolate(S, c.s, J, X.s)) : (S = b.edgeSign(Z, c, X), J = -b.edgeSign(Z, t, X), S + J < 0 && (S = -S, J = -J), R.s = b.interpolate(S, c.s, J, t.s)) : R.s = (c.s + X.s) / 2, b.transLeq(Z, X) || (H = Z, Z = X, X = H), b.transLeq(c, t) || (H = c, c = t, t = H), b.transLeq(Z, c) || (H = Z, Z = c, c = H, H = X, X = t, t = H), b.transLeq(c, X) ? b.transLeq(X, t) ? (S = b.transEval(Z, c, X), J = b.transEval(c, X, t), S + J < 0 && (S = -S, J = -J), R.t = b.interpolate(S, c.t, J, X.t)) : (S = b.transSign(Z, c, X), J = -b.transSign(Z, t, X), S + J < 0 && (S = -S, J = -J), R.t = b.interpolate(S, c.t, J, t.t)) : R.t = (c.t + X.t) / 2;
      };
      function I() {
        this.key = null, this.next = null, this.prev = null;
      }
      function a(Z, X) {
        this.head = new I(), this.head.next = this.head, this.head.prev = this.head, this.frame = Z, this.leq = X;
      }
      a.prototype = {
        min: function() {
          return this.head.next;
        },
        max: function() {
          return this.head.prev;
        },
        insert: function(Z) {
          return this.insertBefore(this.head, Z);
        },
        search: function(Z) {
          var X = this.head;
          do
            X = X.next;
          while (X.key !== null && !this.leq(this.frame, Z, X.key));
          return X;
        },
        insertBefore: function(Z, X) {
          do
            Z = Z.prev;
          while (Z.key !== null && !this.leq(this.frame, Z.key, X));
          var c = new I();
          return c.key = X, c.next = Z.next, Z.next.prev = c, c.prev = Z, Z.next = c, c;
        },
        delete: function(Z) {
          Z.next.prev = Z.prev, Z.prev.next = Z.next;
        }
      };
      function V() {
        this.handle = null;
      }
      function h() {
        this.key = null, this.node = null;
      }
      function Y(Z, X) {
        this.size = 0, this.max = Z, this.nodes = [], this.nodes.length = Z + 1;
        var c;
        for (c = 0; c < this.nodes.length; c++)
          this.nodes[c] = new V();
        for (this.handles = [], this.handles.length = Z + 1, c = 0; c < this.handles.length; c++)
          this.handles[c] = new h();
        this.initialized = !1, this.freeList = 0, this.leq = X, this.nodes[1].handle = 1, this.handles[1].key = null;
      }
      Y.prototype = {
        floatDown_: function(Z) {
          var X = this.nodes, c = this.handles, t, R, S;
          for (t = X[Z].handle; ; ) {
            if (S = Z << 1, S < this.size && this.leq(c[X[S + 1].handle].key, c[X[S].handle].key) && ++S, m(S <= this.max), R = X[S].handle, S > this.size || this.leq(c[t].key, c[R].key)) {
              X[Z].handle = t, c[t].node = Z;
              break;
            }
            X[Z].handle = R, c[R].node = Z, Z = S;
          }
        },
        floatUp_: function(Z) {
          var X = this.nodes, c = this.handles, t, R, S;
          for (t = X[Z].handle; ; ) {
            if (S = Z >> 1, R = X[S].handle, S === 0 || this.leq(c[R].key, c[t].key)) {
              X[Z].handle = t, c[t].node = Z;
              break;
            }
            X[Z].handle = R, c[R].node = Z, Z = S;
          }
        },
        init: function() {
          for (var Z = this.size; Z >= 1; --Z)
            this.floatDown_(Z);
          this.initialized = !0;
        },
        min: function() {
          return this.handles[this.nodes[1].handle].key;
        },
        /* really pqHeapInsert */
        /* returns INV_HANDLE iff out of memory */
        //PQhandle pqHeapInsert( TESSalloc* alloc, PriorityQHeap *pq, PQkey keyNew )
        insert: function(Z) {
          var X, c;
          if (X = ++this.size, X * 2 > this.max) {
            this.max *= 2;
            var t, R;
            for (R = this.nodes.length, this.nodes.length = this.max + 1, t = R; t < this.nodes.length; t++)
              this.nodes[t] = new V();
            for (R = this.handles.length, this.handles.length = this.max + 1, t = R; t < this.handles.length; t++)
              this.handles[t] = new h();
          }
          return this.freeList === 0 ? c = X : (c = this.freeList, this.freeList = this.handles[c].node), this.nodes[X].handle = c, this.handles[c].node = X, this.handles[c].key = Z, this.initialized && this.floatUp_(X), c;
        },
        //PQkey pqHeapExtractMin( PriorityQHeap *pq )
        extractMin: function() {
          var Z = this.nodes, X = this.handles, c = Z[1].handle, t = X[c].key;
          return this.size > 0 && (Z[1].handle = Z[this.size].handle, X[Z[1].handle].node = 1, X[c].key = null, X[c].node = this.freeList, this.freeList = c, --this.size, this.size > 0 && this.floatDown_(1)), t;
        },
        delete: function(Z) {
          var X = this.nodes, c = this.handles, t;
          m(Z >= 1 && Z <= this.max && c[Z].key !== null), t = c[Z].node, X[t].handle = X[this.size].handle, c[X[t].handle].node = t, --this.size, t <= this.size && (t <= 1 || this.leq(c[X[t >> 1].handle].key, c[X[t].handle].key) ? this.floatDown_(t) : this.floatUp_(t)), c[Z].key = null, c[Z].node = this.freeList, this.freeList = Z;
        }
      };
      function p() {
        this.eUp = null, this.nodeUp = null, this.windingNumber = 0, this.inside = !1, this.sentinel = !1, this.dirty = !1, this.fixUpperEdge = !1;
      }
      var G = {};
      G.regionBelow = function(Z) {
        return Z.nodeUp.prev.key;
      }, G.regionAbove = function(Z) {
        return Z.nodeUp.next.key;
      }, G.debugEvent = function(Z) {
      }, G.addWinding = function(Z, X) {
        Z.winding += X.winding, Z.Sym.winding += X.Sym.winding;
      }, G.edgeLeq = function(Z, X, c) {
        var t = Z.event, J, H, R = X.eUp, S = c.eUp;
        if (R.Dst === t)
          return S.Dst === t ? b.vertLeq(R.Org, S.Org) ? b.edgeSign(S.Dst, R.Org, S.Org) <= 0 : b.edgeSign(R.Dst, S.Org, R.Org) >= 0 : b.edgeSign(S.Dst, t, S.Org) <= 0;
        if (S.Dst === t)
          return b.edgeSign(R.Dst, t, R.Org) >= 0;
        var J = b.edgeEval(R.Dst, t, R.Org), H = b.edgeEval(S.Dst, t, S.Org);
        return J >= H;
      }, G.deleteRegion = function(Z, X) {
        X.fixUpperEdge && m(X.eUp.winding === 0), X.eUp.activeRegion = null, Z.dict.delete(X.nodeUp);
      }, G.fixUpperEdge = function(Z, X, c) {
        m(X.fixUpperEdge), Z.mesh.delete(X.eUp), X.fixUpperEdge = !1, X.eUp = c, c.activeRegion = X;
      }, G.topLeftRegion = function(Z, X) {
        var c = X.eUp.Org, t;
        do
          X = G.regionAbove(X);
        while (X.eUp.Org === c);
        if (X.fixUpperEdge) {
          if (t = Z.mesh.connect(G.regionBelow(X).eUp.Sym, X.eUp.Lnext), t === null)
            return null;
          G.fixUpperEdge(Z, X, t), X = G.regionAbove(X);
        }
        return X;
      }, G.topRightRegion = function(Z) {
        var X = Z.eUp.Dst;
        do
          Z = G.regionAbove(Z);
        while (Z.eUp.Dst === X);
        return Z;
      }, G.addRegionBelow = function(Z, X, c) {
        var t = new p();
        return t.eUp = c, t.nodeUp = Z.dict.insertBefore(X.nodeUp, t), t.fixUpperEdge = !1, t.sentinel = !1, t.dirty = !1, c.activeRegion = t, t;
      }, G.isWindingInside = function(Z, X) {
        switch (Z.windingRule) {
          case i.WINDING_ODD:
            return (X & 1) !== 0;
          case i.WINDING_NONZERO:
            return X !== 0;
          case i.WINDING_POSITIVE:
            return X > 0;
          case i.WINDING_NEGATIVE:
            return X < 0;
          case i.WINDING_ABS_GEQ_TWO:
            return X >= 2 || X <= -2;
        }
        return m(!1), !1;
      }, G.computeWinding = function(Z, X) {
        X.windingNumber = G.regionAbove(X).windingNumber + X.eUp.winding, X.inside = G.isWindingInside(Z, X.windingNumber);
      }, G.finishRegion = function(Z, X) {
        var c = X.eUp, t = c.Lface;
        t.inside = X.inside, t.anEdge = c, G.deleteRegion(Z, X);
      }, G.finishLeftRegions = function(Z, X, c) {
        for (var t, J, R = null, S = X, J = X.eUp; S !== c; ) {
          if (S.fixUpperEdge = !1, R = G.regionBelow(S), t = R.eUp, t.Org != J.Org) {
            if (!R.fixUpperEdge) {
              G.finishRegion(Z, S);
              break;
            }
            t = Z.mesh.connect(J.Lprev, t.Sym), G.fixUpperEdge(Z, R, t);
          }
          J.Onext !== t && (Z.mesh.splice(t.Oprev, t), Z.mesh.splice(J, t)), G.finishRegion(Z, S), J = R.eUp, S = R;
        }
        return J;
      }, G.addRightEdges = function(Z, X, c, t, R, S) {
        var J, H, L, C, F = !0;
        L = c;
        do
          m(b.vertLeq(L.Org, L.Dst)), G.addRegionBelow(Z, X, L.Sym), L = L.Onext;
        while (L !== t);
        for (R === null && (R = G.regionBelow(X).eUp.Rprev), H = X, C = R; J = G.regionBelow(H), L = J.eUp.Sym, L.Org === C.Org; )
          L.Onext !== C && (Z.mesh.splice(L.Oprev, L), Z.mesh.splice(C.Oprev, L)), J.windingNumber = H.windingNumber - L.winding, J.inside = G.isWindingInside(Z, J.windingNumber), H.dirty = !0, !F && G.checkForRightSplice(Z, H) && (G.addWinding(L, C), G.deleteRegion(Z, H), Z.mesh.delete(C)), F = !1, H = J, C = L;
        H.dirty = !0, m(H.windingNumber - L.winding === J.windingNumber), S && G.walkDirtyRegions(Z, H);
      }, G.spliceMergeVertices = function(Z, X, c) {
        Z.mesh.splice(X, c);
      }, G.vertexWeights = function(Z, X, c) {
        var t = b.vertL1dist(X, Z), R = b.vertL1dist(c, Z), S = 0.5 * R / (t + R), J = 0.5 * t / (t + R);
        Z.coords[0] += S * X.coords[0] + J * c.coords[0], Z.coords[1] += S * X.coords[1] + J * c.coords[1], Z.coords[2] += S * X.coords[2] + J * c.coords[2];
      }, G.getIntersectData = function(Z, X, c, t, R, S) {
        X.coords[0] = X.coords[1] = X.coords[2] = 0, X.idx = -1, G.vertexWeights(X, c, t), G.vertexWeights(X, R, S);
      }, G.checkForRightSplice = function(Z, X) {
        var c = G.regionBelow(X), t = X.eUp, R = c.eUp;
        if (b.vertLeq(t.Org, R.Org)) {
          if (b.edgeSign(R.Dst, t.Org, R.Org) > 0)
            return !1;
          b.vertEq(t.Org, R.Org) ? t.Org !== R.Org && (Z.pq.delete(t.Org.pqHandle), G.spliceMergeVertices(Z, R.Oprev, t)) : (Z.mesh.splitEdge(R.Sym), Z.mesh.splice(t, R.Oprev), X.dirty = c.dirty = !0);
        } else {
          if (b.edgeSign(t.Dst, R.Org, t.Org) < 0)
            return !1;
          G.regionAbove(X).dirty = X.dirty = !0, Z.mesh.splitEdge(t.Sym), Z.mesh.splice(R.Oprev, t);
        }
        return !0;
      }, G.checkForLeftSplice = function(Z, X) {
        var c = G.regionBelow(X), t = X.eUp, R = c.eUp, S;
        if (m(!b.vertEq(t.Dst, R.Dst)), b.vertLeq(t.Dst, R.Dst)) {
          if (b.edgeSign(t.Dst, R.Dst, t.Org) < 0)
            return !1;
          G.regionAbove(X).dirty = X.dirty = !0, S = Z.mesh.splitEdge(t), Z.mesh.splice(R.Sym, S), S.Lface.inside = X.inside;
        } else {
          if (b.edgeSign(R.Dst, t.Dst, R.Org) > 0)
            return !1;
          X.dirty = c.dirty = !0, S = Z.mesh.splitEdge(R), Z.mesh.splice(t.Lnext, R.Sym), S.Rface.inside = X.inside;
        }
        return !0;
      }, G.checkForIntersect = function(Z, X) {
        var c = G.regionBelow(X), t = X.eUp, R = c.eUp, S = t.Org, J = R.Org, H = t.Dst, L = R.Dst, C, F, r = new o(), K, g;
        if (m(!b.vertEq(L, H)), m(b.edgeSign(H, Z.event, S) <= 0), m(b.edgeSign(L, Z.event, J) >= 0), m(S !== Z.event && J !== Z.event), m(!X.fixUpperEdge && !c.fixUpperEdge), S === J || (C = Math.min(S.t, H.t), F = Math.max(J.t, L.t), C > F))
          return !1;
        if (b.vertLeq(S, J)) {
          if (b.edgeSign(L, S, J) > 0)
            return !1;
        } else if (b.edgeSign(H, J, S) < 0)
          return !1;
        return G.debugEvent(Z), b.intersect(H, S, L, J, r), m(Math.min(S.t, H.t) <= r.t), m(r.t <= Math.max(J.t, L.t)), m(Math.min(L.s, H.s) <= r.s), m(r.s <= Math.max(J.s, S.s)), b.vertLeq(r, Z.event) && (r.s = Z.event.s, r.t = Z.event.t), K = b.vertLeq(S, J) ? S : J, b.vertLeq(K, r) && (r.s = K.s, r.t = K.t), b.vertEq(r, S) || b.vertEq(r, J) ? (G.checkForRightSplice(Z, X), !1) : !b.vertEq(H, Z.event) && b.edgeSign(H, Z.event, r) >= 0 || !b.vertEq(L, Z.event) && b.edgeSign(L, Z.event, r) <= 0 ? L === Z.event ? (Z.mesh.splitEdge(t.Sym), Z.mesh.splice(R.Sym, t), X = G.topLeftRegion(Z, X), t = G.regionBelow(X).eUp, G.finishLeftRegions(Z, G.regionBelow(X), c), G.addRightEdges(Z, X, t.Oprev, t, t, !0), !0) : H === Z.event ? (Z.mesh.splitEdge(R.Sym), Z.mesh.splice(t.Lnext, R.Oprev), c = X, X = G.topRightRegion(X), g = G.regionBelow(X).eUp.Rprev, c.eUp = R.Oprev, R = G.finishLeftRegions(Z, c, null), G.addRightEdges(Z, X, R.Onext, t.Rprev, g, !0), !0) : (b.edgeSign(H, Z.event, r) >= 0 && (G.regionAbove(X).dirty = X.dirty = !0, Z.mesh.splitEdge(t.Sym), t.Org.s = Z.event.s, t.Org.t = Z.event.t), b.edgeSign(L, Z.event, r) <= 0 && (X.dirty = c.dirty = !0, Z.mesh.splitEdge(R.Sym), R.Org.s = Z.event.s, R.Org.t = Z.event.t), !1) : (Z.mesh.splitEdge(t.Sym), Z.mesh.splitEdge(R.Sym), Z.mesh.splice(R.Oprev, t), t.Org.s = r.s, t.Org.t = r.t, t.Org.pqHandle = Z.pq.insert(t.Org), G.getIntersectData(Z, t.Org, S, H, J, L), G.regionAbove(X).dirty = X.dirty = c.dirty = !0, !1);
      }, G.walkDirtyRegions = function(Z, X) {
        for (var c = G.regionBelow(X), t, R; ; ) {
          for (; c.dirty; )
            X = c, c = G.regionBelow(c);
          if (!X.dirty && (c = X, X = G.regionAbove(X), X === null || !X.dirty))
            return;
          if (X.dirty = !1, t = X.eUp, R = c.eUp, t.Dst !== R.Dst && G.checkForLeftSplice(Z, X) && (c.fixUpperEdge ? (G.deleteRegion(Z, c), Z.mesh.delete(R), c = G.regionBelow(X), R = c.eUp) : X.fixUpperEdge && (G.deleteRegion(Z, X), Z.mesh.delete(t), X = G.regionAbove(c), t = X.eUp)), t.Org !== R.Org)
            if (t.Dst !== R.Dst && !X.fixUpperEdge && !c.fixUpperEdge && (t.Dst === Z.event || R.Dst === Z.event)) {
              if (G.checkForIntersect(Z, X))
                return;
            } else
              G.checkForRightSplice(Z, X);
          t.Org === R.Org && t.Dst === R.Dst && (G.addWinding(R, t), G.deleteRegion(Z, X), Z.mesh.delete(t), X = G.regionAbove(c));
        }
      }, G.connectRightVertex = function(Z, X, c) {
        var t, R = c.Onext, S = G.regionBelow(X), J = X.eUp, H = S.eUp, L = !1;
        if (J.Dst !== H.Dst && G.checkForIntersect(Z, X), b.vertEq(J.Org, Z.event) && (Z.mesh.splice(R.Oprev, J), X = G.topLeftRegion(Z, X), R = G.regionBelow(X).eUp, G.finishLeftRegions(Z, G.regionBelow(X), S), L = !0), b.vertEq(H.Org, Z.event) && (Z.mesh.splice(c, H.Oprev), c = G.finishLeftRegions(Z, S, null), L = !0), L) {
          G.addRightEdges(Z, X, c.Onext, R, R, !0);
          return;
        }
        b.vertLeq(H.Org, J.Org) ? t = H.Oprev : t = J, t = Z.mesh.connect(c.Lprev, t), G.addRightEdges(Z, X, t, t.Onext, t.Onext, !1), t.Sym.activeRegion.fixUpperEdge = !0, G.walkDirtyRegions(Z, X);
      }, G.connectLeftDegenerate = function(Z, X, c) {
        var t, R, S, J, H;
        if (t = X.eUp, b.vertEq(t.Org, c)) {
          m(
            !1
            /*TOLERANCE_NONZERO*/
          ), G.spliceMergeVertices(Z, t, c.anEdge);
          return;
        }
        if (!b.vertEq(t.Dst, c)) {
          Z.mesh.splitEdge(t.Sym), X.fixUpperEdge && (Z.mesh.delete(t.Onext), X.fixUpperEdge = !1), Z.mesh.splice(c.anEdge, t), G.sweepEvent(Z, c);
          return;
        }
        m(
          !1
          /*TOLERANCE_NONZERO*/
        ), X = G.topRightRegion(X), H = G.regionBelow(X), S = H.eUp.Sym, R = J = S.Onext, H.fixUpperEdge && (m(R !== S), G.deleteRegion(Z, H), Z.mesh.delete(S), S = R.Oprev), Z.mesh.splice(c.anEdge, S), b.edgeGoesLeft(R) || (R = null), G.addRightEdges(Z, X, S.Onext, J, R, !0);
      }, G.connectLeftVertex = function(Z, X) {
        var c, t, R, S, J, H, L = new p();
        if (L.eUp = X.anEdge.Sym, c = Z.dict.search(L).key, t = G.regionBelow(c), !!t) {
          if (S = c.eUp, J = t.eUp, b.edgeSign(S.Dst, X, S.Org) === 0) {
            G.connectLeftDegenerate(Z, c, X);
            return;
          }
          if (R = b.vertLeq(J.Dst, S.Dst) ? c : t, c.inside || R.fixUpperEdge) {
            if (R === c)
              H = Z.mesh.connect(X.anEdge.Sym, S.Lnext);
            else {
              var C = Z.mesh.connect(J.Dnext, X.anEdge);
              H = C.Sym;
            }
            R.fixUpperEdge ? G.fixUpperEdge(Z, R, H) : G.computeWinding(Z, G.addRegionBelow(Z, c, H)), G.sweepEvent(Z, X);
          } else
            G.addRightEdges(Z, c, X.anEdge, X.anEdge, null, !0);
        }
      }, G.sweepEvent = function(Z, X) {
        Z.event = X, G.debugEvent(Z);
        for (var c = X.anEdge; c.activeRegion === null; )
          if (c = c.Onext, c === X.anEdge) {
            G.connectLeftVertex(Z, X);
            return;
          }
        var t = G.topLeftRegion(Z, c.activeRegion);
        m(t !== null);
        var R = G.regionBelow(t), S = R.eUp, J = G.finishLeftRegions(Z, R, null);
        J.Onext === S ? G.connectRightVertex(Z, t, J) : G.addRightEdges(Z, t, J.Onext, S, S, !0);
      }, G.addSentinel = function(Z, X, c, t) {
        var R = new p(), S = Z.mesh.makeEdge();
        S.Org.s = c, S.Org.t = t, S.Dst.s = X, S.Dst.t = t, Z.event = S.Dst, R.eUp = S, R.windingNumber = 0, R.inside = !1, R.fixUpperEdge = !1, R.sentinel = !0, R.dirty = !1, R.nodeUp = Z.dict.insert(R);
      }, G.initEdgeDict = function(Z) {
        Z.dict = new a(Z, G.edgeLeq);
        var X = Z.bmax[0] - Z.bmin[0], c = Z.bmax[1] - Z.bmin[1], t = Z.bmin[0] - X, R = Z.bmax[0] + X, S = Z.bmin[1] - c, J = Z.bmax[1] + c;
        G.addSentinel(Z, t, R, S), G.addSentinel(Z, t, R, J);
      }, G.doneEdgeDict = function(Z) {
        for (var X, c = 0; (X = Z.dict.min().key) !== null; )
          X.sentinel || (m(X.fixUpperEdge), m(++c === 1)), m(X.windingNumber === 0), G.deleteRegion(Z, X);
      }, G.removeDegenerateEdges = function(Z) {
        var X, c, t, R = Z.mesh.eHead;
        for (X = R.next; X !== R; X = c)
          c = X.next, t = X.Lnext, b.vertEq(X.Org, X.Dst) && X.Lnext.Lnext !== X && (G.spliceMergeVertices(Z, t, X), Z.mesh.delete(X), X = t, t = X.Lnext), t.Lnext === X && (t !== X && ((t === c || t === c.Sym) && (c = c.next), Z.mesh.delete(t)), (X === c || X === c.Sym) && (c = c.next), Z.mesh.delete(X));
      }, G.initPriorityQ = function(Z) {
        var X, c, t, R = 0;
        for (t = Z.mesh.vHead, c = t.next; c !== t; c = c.next)
          R++;
        for (R += 8, X = Z.pq = new Y(R, b.vertLeq), t = Z.mesh.vHead, c = t.next; c !== t; c = c.next)
          c.pqHandle = X.insert(c);
        return c !== t ? !1 : (X.init(), !0);
      }, G.donePriorityQ = function(Z) {
        Z.pq = null;
      }, G.removeDegenerateFaces = function(Z, X) {
        var c, t, R;
        for (c = X.fHead.next; c !== X.fHead; c = t)
          t = c.next, R = c.anEdge, m(R.Lnext !== R), R.Lnext.Lnext === R && (G.addWinding(R.Onext, R), Z.mesh.delete(R));
        return !0;
      }, G.computeInterior = function(Z) {
        var X, c;
        if (G.removeDegenerateEdges(Z), !G.initPriorityQ(Z))
          return !1;
        for (G.initEdgeDict(Z); (X = Z.pq.extractMin()) !== null; ) {
          for (; c = Z.pq.min(), !(c === null || !b.vertEq(c, X)); )
            c = Z.pq.extractMin(), G.spliceMergeVertices(Z, X.anEdge, c.anEdge);
          G.sweepEvent(Z, X);
        }
        return Z.event = Z.dict.min().key.eUp.Org, G.debugEvent(Z), G.doneEdgeDict(Z), G.donePriorityQ(Z), G.removeDegenerateFaces(Z, Z.mesh) ? (Z.mesh.check(), !0) : !1;
      };
      function y() {
        this.mesh = null, this.normal = [0, 0, 0], this.sUnit = [0, 0, 0], this.tUnit = [0, 0, 0], this.bmin = [0, 0], this.bmax = [0, 0], this.windingRule = i.WINDING_ODD, this.dict = null, this.pq = null, this.event = null, this.vertexIndexCounter = 0, this.vertices = [], this.vertexIndices = [], this.vertexCount = 0, this.elements = [], this.elementCount = 0;
      }
      y.prototype = {
        dot_: function(Z, X) {
          return Z[0] * X[0] + Z[1] * X[1] + Z[2] * X[2];
        },
        normalize_: function(Z) {
          var X = Z[0] * Z[0] + Z[1] * Z[1] + Z[2] * Z[2];
          m(X > 0), X = Math.sqrt(X), Z[0] /= X, Z[1] /= X, Z[2] /= X;
        },
        longAxis_: function(Z) {
          var X = 0;
          return Math.abs(Z[1]) > Math.abs(Z[0]) && (X = 1), Math.abs(Z[2]) > Math.abs(Z[X]) && (X = 2), X;
        },
        computeNormal_: function(Z) {
          var X, c, t, R, S, J, H = [0, 0, 0], L = [0, 0, 0], C = [0, 0, 0], F = [0, 0, 0], r = [0, 0, 0], K = [null, null, null], g = [null, null, null], v = this.mesh.vHead, f;
          for (X = v.next, f = 0; f < 3; ++f)
            R = X.coords[f], L[f] = R, g[f] = X, H[f] = R, K[f] = X;
          for (X = v.next; X !== v; X = X.next)
            for (f = 0; f < 3; ++f)
              R = X.coords[f], R < L[f] && (L[f] = R, g[f] = X), R > H[f] && (H[f] = R, K[f] = X);
          if (f = 0, H[1] - L[1] > H[0] - L[0] && (f = 1), H[2] - L[2] > H[f] - L[f] && (f = 2), L[f] >= H[f]) {
            Z[0] = 0, Z[1] = 0, Z[2] = 1;
            return;
          }
          for (J = 0, c = g[f], t = K[f], C[0] = c.coords[0] - t.coords[0], C[1] = c.coords[1] - t.coords[1], C[2] = c.coords[2] - t.coords[2], X = v.next; X !== v; X = X.next)
            F[0] = X.coords[0] - t.coords[0], F[1] = X.coords[1] - t.coords[1], F[2] = X.coords[2] - t.coords[2], r[0] = C[1] * F[2] - C[2] * F[1], r[1] = C[2] * F[0] - C[0] * F[2], r[2] = C[0] * F[1] - C[1] * F[0], S = r[0] * r[0] + r[1] * r[1] + r[2] * r[2], S > J && (J = S, Z[0] = r[0], Z[1] = r[1], Z[2] = r[2]);
          J <= 0 && (Z[0] = Z[1] = Z[2] = 0, Z[this.longAxis_(C)] = 1);
        },
        checkOrientation_: function() {
          var Z, X, c = this.mesh.fHead, t, R = this.mesh.vHead, S;
          for (Z = 0, X = c.next; X !== c; X = X.next)
            if (S = X.anEdge, !(S.winding <= 0))
              do
                Z += (S.Org.s - S.Dst.s) * (S.Org.t + S.Dst.t), S = S.Lnext;
              while (S !== X.anEdge);
          if (Z < 0) {
            for (t = R.next; t !== R; t = t.next)
              t.t = -t.t;
            this.tUnit[0] = -this.tUnit[0], this.tUnit[1] = -this.tUnit[1], this.tUnit[2] = -this.tUnit[2];
          }
        },
        /*	#ifdef FOR_TRITE_TEST_PROGRAM
          #include <stdlib.h>
          extern int RandomSweep;
          #define S_UNIT_X	(RandomSweep ? (2*drand48()-1) : 1.0)
          #define S_UNIT_Y	(RandomSweep ? (2*drand48()-1) : 0.0)
          #else
          #if defined(SLANTED_SWEEP) */
        /* The "feature merging" is not intended to be complete.  There are
        * special cases where edges are nearly parallel to the sweep line
        * which are not implemented.  The algorithm should still behave
        * robustly (ie. produce a reasonable tesselation) in the presence
        * of such edges, however it may miss features which could have been
        * merged.  We could minimize this effect by choosing the sweep line
        * direction to be something unusual (ie. not parallel to one of the
        * coordinate axes).
        */
        /*	#define S_UNIT_X	(TESSreal)0.50941539564955385	// Pre-normalized
          #define S_UNIT_Y	(TESSreal)0.86052074622010633
          #else
          #define S_UNIT_X	(TESSreal)1.0
          #define S_UNIT_Y	(TESSreal)0.0
          #endif
          #endif*/
        /* Determine the polygon normal and project vertices onto the plane
        * of the polygon.
        */
        projectPolygon_: function() {
          var Z, X = this.mesh.vHead, c = [0, 0, 0], t, R, S, J, H = !1;
          for (c[0] = this.normal[0], c[1] = this.normal[1], c[2] = this.normal[2], c[0] === 0 && c[1] === 0 && c[2] === 0 && (this.computeNormal_(c), H = !0), t = this.sUnit, R = this.tUnit, S = this.longAxis_(c), t[S] = 0, t[(S + 1) % 3] = 1, t[(S + 2) % 3] = 0, R[S] = 0, R[(S + 1) % 3] = 0, R[(S + 2) % 3] = c[S] > 0 ? 1 : -1, Z = X.next; Z !== X; Z = Z.next)
            Z.s = this.dot_(Z.coords, t), Z.t = this.dot_(Z.coords, R);
          for (H && this.checkOrientation_(), J = !0, Z = X.next; Z !== X; Z = Z.next)
            J ? (this.bmin[0] = this.bmax[0] = Z.s, this.bmin[1] = this.bmax[1] = Z.t, J = !1) : (Z.s < this.bmin[0] && (this.bmin[0] = Z.s), Z.s > this.bmax[0] && (this.bmax[0] = Z.s), Z.t < this.bmin[1] && (this.bmin[1] = Z.t), Z.t > this.bmax[1] && (this.bmax[1] = Z.t));
        },
        addWinding_: function(Z, X) {
          Z.winding += X.winding, Z.Sym.winding += X.Sym.winding;
        },
        /* tessMeshTessellateMonoRegion( face ) tessellates a monotone region
        * (what else would it do??)  The region must consist of a single
        * loop of half-edges (see mesh.h) oriented CCW.  "Monotone" in this
        * case means that any vertical line intersects the interior of the
        * region in a single interval.  
        *
        * Tessellation consists of adding interior edges (actually pairs of
        * half-edges), to split the region into non-overlapping triangles.
        *
        * The basic idea is explained in Preparata and Shamos (which I don''t
        * have handy right now), although their implementation is more
        * complicated than this one.  The are two edge chains, an upper chain
        * and a lower chain.  We process all vertices from both chains in order,
        * from right to left.
        *
        * The algorithm ensures that the following invariant holds after each
        * vertex is processed: the untessellated region consists of two
        * chains, where one chain (say the upper) is a single edge, and
        * the other chain is concave.  The left vertex of the single edge
        * is always to the left of all vertices in the concave chain.
        *
        * Each step consists of adding the rightmost unprocessed vertex to one
        * of the two chains, and forming a fan of triangles from the rightmost
        * of two chain endpoints.  Determining whether we can add each triangle
        * to the fan is a simple orientation test.  By making the fan as large
        * as possible, we restore the invariant (check it yourself).
        */
        //	int tessMeshTessellateMonoRegion( TESSmesh *mesh, TESSface *face )
        tessellateMonoRegion_: function(Z, X) {
          var c, t;
          for (c = X.anEdge, m(c.Lnext !== c && c.Lnext.Lnext !== c); b.vertLeq(c.Dst, c.Org); c = c.Lprev)
            ;
          for (; b.vertLeq(c.Org, c.Dst); c = c.Lnext)
            ;
          for (t = c.Lprev; c.Lnext !== t; )
            if (b.vertLeq(c.Dst, t.Org)) {
              for (; t.Lnext !== c && (b.edgeGoesLeft(t.Lnext) || b.edgeSign(t.Org, t.Dst, t.Lnext.Dst) <= 0); ) {
                var R = Z.connect(t.Lnext, t);
                t = R.Sym;
              }
              t = t.Lprev;
            } else {
              for (; t.Lnext !== c && (b.edgeGoesRight(c.Lprev) || b.edgeSign(c.Dst, c.Org, c.Lprev.Org) >= 0); ) {
                var R = Z.connect(c, c.Lprev);
                c = R.Sym;
              }
              c = c.Lnext;
            }
          for (m(t.Lnext !== c); t.Lnext.Lnext !== c; ) {
            var R = Z.connect(t.Lnext, t);
            t = R.Sym;
          }
          return !0;
        },
        /* tessMeshTessellateInterior( mesh ) tessellates each region of
        * the mesh which is marked "inside" the polygon.  Each such region
        * must be monotone.
        */
        //int tessMeshTessellateInterior( TESSmesh *mesh )
        tessellateInterior_: function(Z) {
          var X, c;
          for (X = Z.fHead.next; X !== Z.fHead; X = c)
            if (c = X.next, X.inside && !this.tessellateMonoRegion_(Z, X))
              return !1;
          return !0;
        },
        /* tessMeshDiscardExterior( mesh ) zaps (ie. sets to NULL) all faces
        * which are not marked "inside" the polygon.  Since further mesh operations
        * on NULL faces are not allowed, the main purpose is to clean up the
        * mesh so that exterior loops are not represented in the data structure.
        */
        //void tessMeshDiscardExterior( TESSmesh *mesh )
        discardExterior_: function(Z) {
          var X, c;
          for (X = Z.fHead.next; X !== Z.fHead; X = c)
            c = X.next, X.inside || Z.zapFace(X);
        },
        /* tessMeshSetWindingNumber( mesh, value, keepOnlyBoundary ) resets the
        * winding numbers on all edges so that regions marked "inside" the
        * polygon have a winding number of "value", and regions outside
        * have a winding number of 0.
        *
        * If keepOnlyBoundary is TRUE, it also deletes all edges which do not
        * separate an interior region from an exterior one.
        */
        //	int tessMeshSetWindingNumber( TESSmesh *mesh, int value, int keepOnlyBoundary )
        setWindingNumber_: function(Z, X, c) {
          var t, R;
          for (t = Z.eHead.next; t !== Z.eHead; t = R)
            R = t.next, t.Rface.inside !== t.Lface.inside ? t.winding = t.Lface.inside ? X : -X : c ? Z.delete(t) : t.winding = 0;
        },
        getNeighbourFace_: function(Z) {
          return !Z.Rface || !Z.Rface.inside ? -1 : Z.Rface.n;
        },
        outputPolymesh_: function(Z, X, c, t) {
          var R, S, J, H = 0, L = 0, C, F;
          for (c > 3 && Z.mergeConvexFaces(c), R = Z.vHead.next; R !== Z.vHead; R = R.next)
            R.n = -1;
          for (S = Z.fHead.next; S !== Z.fHead; S = S.next)
            if (S.n = -1, !!S.inside) {
              J = S.anEdge, C = 0;
              do
                R = J.Org, R.n === -1 && (R.n = L, L++), C++, J = J.Lnext;
              while (J !== S.anEdge);
              m(C <= c), S.n = H, ++H;
            }
          for (this.elementCount = H, X === i.CONNECTED_POLYGONS && (H *= 2), this.elements = [], this.elements.length = H * c, this.vertexCount = L, this.vertices = [], this.vertices.length = L * t, this.vertexIndices = [], this.vertexIndices.length = L, R = Z.vHead.next; R !== Z.vHead; R = R.next)
            if (R.n !== -1) {
              var r = R.n * t;
              this.vertices[r + 0] = R.coords[0], this.vertices[r + 1] = R.coords[1], t > 2 && (this.vertices[r + 2] = R.coords[2]), this.vertexIndices[R.n] = R.idx;
            }
          var K = 0;
          for (S = Z.fHead.next; S !== Z.fHead; S = S.next)
            if (S.inside) {
              J = S.anEdge, C = 0;
              do
                R = J.Org, this.elements[K++] = R.n, C++, J = J.Lnext;
              while (J !== S.anEdge);
              for (F = C; F < c; ++F)
                this.elements[K++] = -1;
              if (X === i.CONNECTED_POLYGONS) {
                J = S.anEdge;
                do
                  this.elements[K++] = this.getNeighbourFace_(J), J = J.Lnext;
                while (J !== S.anEdge);
                for (F = C; F < c; ++F)
                  this.elements[K++] = -1;
              }
            }
        },
        //	void OutputContours( TESStesselator *tess, TESSmesh *mesh, int vertexSize )
        outputContours_: function(Z, X) {
          var c, t, R, S = 0, J = 0;
          for (this.vertexCount = 0, this.elementCount = 0, c = Z.fHead.next; c !== Z.fHead; c = c.next)
            if (c.inside) {
              R = t = c.anEdge;
              do
                this.vertexCount++, t = t.Lnext;
              while (t !== R);
              this.elementCount++;
            }
          this.elements = [], this.elements.length = this.elementCount * 2, this.vertices = [], this.vertices.length = this.vertexCount * X, this.vertexIndices = [], this.vertexIndices.length = this.vertexCount;
          var H = 0, L = 0, C = 0;
          for (S = 0, c = Z.fHead.next; c !== Z.fHead; c = c.next)
            if (c.inside) {
              J = 0, R = t = c.anEdge;
              do
                this.vertices[H++] = t.Org.coords[0], this.vertices[H++] = t.Org.coords[1], X > 2 && (this.vertices[H++] = t.Org.coords[2]), this.vertexIndices[L++] = t.Org.idx, J++, t = t.Lnext;
              while (t !== R);
              this.elements[C++] = S, this.elements[C++] = J, S += J;
            }
        },
        addContour: function(Z, X) {
          var c, t;
          for (this.mesh === null && (this.mesh = new e()), Z < 2 && (Z = 2), Z > 3 && (Z = 3), c = null, t = 0; t < X.length; t += Z)
            c === null ? (c = this.mesh.makeEdge(), this.mesh.splice(c, c.Sym)) : (this.mesh.splitEdge(c), c = c.Lnext), c.Org.coords[0] = X[t + 0], c.Org.coords[1] = X[t + 1], Z > 2 ? c.Org.coords[2] = X[t + 2] : c.Org.coords[2] = 0, c.Org.idx = this.vertexIndexCounter++, c.winding = 1, c.Sym.winding = -1;
        },
        //	int tessTesselate( TESStesselator *tess, int windingRule, int elementType, int polySize, int vertexSize, const TESSreal* normal )
        tesselate: function(Z, X, c, t, R) {
          if (this.vertices = [], this.elements = [], this.vertexIndices = [], this.vertexIndexCounter = 0, R && (this.normal[0] = R[0], this.normal[1] = R[1], this.normal[2] = R[2]), this.windingRule = Z, t < 2 && (t = 2), t > 3 && (t = 3), !this.mesh)
            return !1;
          this.projectPolygon_(), G.computeInterior(this);
          var S = this.mesh;
          return X === i.BOUNDARY_CONTOURS ? this.setWindingNumber_(S, 1, !0) : this.tessellateInterior_(S), S.check(), X === i.BOUNDARY_CONTOURS ? this.outputContours_(S, t) : this.outputPolymesh_(S, X, c, t), !0;
        }
      };
    },
    /* 62 */
    /***/
    function(s, l) {
      s.exports = i;
      var d = Object.prototype.hasOwnProperty;
      function i() {
        for (var b = {}, m = 0; m < arguments.length; m++) {
          var o = arguments[m];
          for (var n in o)
            d.call(o, n) && (b[n] = o[n]);
        }
        return b;
      }
    },
    /* 63 */
    /***/
    function(s, l, d) {
      d.r(l), d.d(l, "createShaders", function() {
        return W;
      }), d.d(l, "applyShader", function() {
        return e;
      }), d.d(l, "createCloudShaders", function() {
        return a;
      }), d.d(l, "applyCloudShader", function() {
        return V;
      });
      var i = d(64), b = d(65), m = d(66), o = d(67);
      d(1).glMatrix.setMatrixArrayType(Array);
      const n = Symbol("shaders");
      function W(h) {
        h[n] = [];
        for (let Y = 0; Y < 16; Y++) {
          const p = [], G = !!(Y & 1), y = !!(Y & 2), Z = !!(Y & 4), X = !!(Y & 8);
          G && p.push("#define TEXTURE 1"), y && p.push("#define FILTER 1"), Z && p.push("#define GRADIENT 1"), X && p.push("#define CLIPPATH 1");
          const c = `${p.join(`
`)}
`, t = [];
          G && t.push("uniform sampler2D u_texSampler;"), X && t.push("uniform sampler2D u_clipSampler;"), h[n][Y] = [c + t.join(`
`) + b.default, c + i.default];
        }
      }
      function e(h, {
        hasTexture: Y = !1,
        hasFilter: p = !1,
        hasGradient: G = !1,
        hasClipPath: y = !1
      } = {}) {
        const Z = Y | p << 1 | G << 2 | y << 3;
        let X = h[n][Z];
        Array.isArray(X) && (X = h.createProgram(...X), h[n][Z] = X), h.program !== X && h.useProgram(X, {
          a_color: {
            type: "UNSIGNED_BYTE",
            normalize: !0
          }
        });
      }
      const I = [];
      function a(h) {
        for (let Y = 0; Y < 64; Y++) {
          const p = [], G = !!(Y & 1), y = !!(Y & 2), Z = !!(Y & 4), X = !!(Y & 8), c = !!(Y & 16), t = !!(Y & 32);
          G && p.push("#define TEXTURE 1"), y && p.push("#define FILTER 1"), Z && p.push("#define GRADIENT 1"), X && p.push("#define CLOUDCOLOR 1"), c && p.push("#define CLOUDFILTER 1"), t && p.push("#define CLIPPATH 1");
          const R = `${p.join(`
`)}
`, S = [];
          if (G) {
            S.push("uniform sampler2D u_texSampler;");
            for (let J = 0; J < 12; J++)
              S.push(`uniform sampler2D u_texFrame${J};`);
          }
          t && S.push("uniform sampler2D u_clipSampler;"), I[Y] = [R + S.join(`
`) + o.default, R + m.default];
        }
      }
      function V(h, {
        hasTexture: Y = !1,
        hasFilter: p = !1,
        hasGradient: G = !1,
        hasCloudColor: y = !1,
        hasCloudFilter: Z = !1,
        hasClipPath: X = !1
      } = {}) {
        const c = Y | p << 1 | G << 2 | y << 3 | Z << 4 | X << 5;
        let t = I[c];
        Array.isArray(t) && (t = h.createProgram(...t), I[c] = t), h.program !== t && h.useProgram(t, {
          a_color: {
            type: "UNSIGNED_BYTE",
            normalize: !0
          },
          a_fillCloudColor: {
            type: "UNSIGNED_BYTE",
            normalize: !0
          },
          a_strokeCloudColor: {
            type: "UNSIGNED_BYTE",
            normalize: !0
          },
          a_frameIndex: {
            type: "UNSIGNED_BYTE",
            normalize: !1
          }
        });
      }
    },
    /* 64 */
    /***/
    function(s, l, d) {
      d.r(l), l.default = `attribute vec3 a_vertexPosition;
attribute vec4 a_color;
varying vec4 vColor;
varying float flagBackground;
uniform vec2 u_resolution;
uniform mat3 viewMatrix;
uniform mat3 projectionMatrix;

#ifdef TEXTURE
attribute vec3 a_vertexTextureCoord;
varying vec3 vTextureCoord;
attribute vec4 a_sourceRect;
varying vec4 vSourceRect;
#endif

#ifdef CLIPPATH
attribute vec2 a_clipUV;
varying vec2 vClipUV;
#endif

#ifdef GRADIENT
uniform float u_radialGradientVector[6];
varying vec3 vGradientVector1;
varying vec3 vGradientVector2;
#endif

void main() {
  gl_PointSize = 1.0;

  vec3 pos = projectionMatrix * viewMatrix * vec3(a_vertexPosition.xy, 1.0);
  gl_Position = vec4(pos.xy, 1.0, 1.0);

#ifdef GRADIENT
  vec3 vg1 = viewMatrix * vec3(u_radialGradientVector[0], u_radialGradientVector[1], 1.0);
  vec3 vg2 = viewMatrix * vec3(u_radialGradientVector[3], u_radialGradientVector[4], 1.0);
  float h = u_resolution.y;
  vg1.y = h - vg1.y;
  vg2.y = h - vg2.y;
  vGradientVector1 = vec3(vg1.xy, u_radialGradientVector[2]);
  vGradientVector2 = vec3(vg2.xy, u_radialGradientVector[5]);
#endif
  
  flagBackground = a_vertexPosition.z;
  vColor = a_color;

#ifdef TEXTURE
  vTextureCoord = a_vertexTextureCoord;
  vSourceRect = a_sourceRect;
#endif

#ifdef CLIPPATH
  vClipUV = a_clipUV;
#endif
}`;
    },
    /* 65 */
    /***/
    function(s, l, d) {
      d.r(l), l.default = `precision mediump float;

varying vec4 vColor;
varying float flagBackground;

#ifdef TEXTURE
varying vec3 vTextureCoord;
varying vec4 vSourceRect;
#endif

#ifdef CLIPPATH
varying vec2 vClipUV;
#endif

#ifdef FILTER
uniform int u_filterFlag;
uniform float u_colorMatrix[20];
#endif

#ifdef GRADIENT
varying vec3 vGradientVector1;
varying vec3 vGradientVector2;
uniform float u_colorSteps[40];
uniform int u_gradientType;
// uniform float u_radialGradientVector[6];

void gradient(inout vec4 color, vec3 gv1, vec3 gv2, float colorSteps[40]) {
  float t;
  // center circle radius
  float cr = gv1.z;
  // focal circle radius
  float fr = gv2.z;

  if(cr > 0.0 || fr > 0.0) {
    // radial gradient
    vec2 center = gv1.xy;
    vec2 focal = gv2.xy;
    float x = focal.x - gl_FragCoord.x;
    float y = focal.y - gl_FragCoord.y;
    float dx = focal.x - center.x;
    float dy = focal.y - center.y;
    float dr = cr - fr;
    float a = dx * dx + dy * dy - dr * dr;
    float b = -2.0 * (y * dy + x * dx + fr * dr);
    float c = x * x + y * y - fr * fr;
    t = 1.0 - 0.5 * (1.0 / a) * (-b + sqrt(b * b - 4.0 * a * c));
  } else {
    // linear gradient
    vec2 v1 = gl_FragCoord.xy - gv1.xy;
    vec2 v2 = gv2.xy - gv1.xy;
    t = (v1.x * v2.x + v1.y * v2.y) / (v2.x * v2.x + v2.y * v2.y);
  }

  vec4 colors[8];
  colors[0] = vec4(colorSteps[1], colorSteps[2], colorSteps[3], colorSteps[4]);
  colors[1] = vec4(colorSteps[6], colorSteps[7], colorSteps[8], colorSteps[9]);
  colors[2] = vec4(colorSteps[11], colorSteps[12], colorSteps[13], colorSteps[14]);
  colors[3] = vec4(colorSteps[16], colorSteps[17], colorSteps[18], colorSteps[19]);
  colors[4] = vec4(colorSteps[21], colorSteps[22], colorSteps[23], colorSteps[24]);
  colors[5] = vec4(colorSteps[26], colorSteps[27], colorSteps[28], colorSteps[29]);
  colors[6] = vec4(colorSteps[31], colorSteps[32], colorSteps[33], colorSteps[34]);
  colors[7] = vec4(colorSteps[36], colorSteps[37], colorSteps[38], colorSteps[39]);
  
  float steps[8];
  steps[0] = colorSteps[0];
  steps[1] = colorSteps[5];
  steps[2] = colorSteps[10];
  steps[3] = colorSteps[15];
  steps[4] = colorSteps[20];
  steps[5] = colorSteps[25];
  steps[6] = colorSteps[30];
  steps[7] = colorSteps[35];

  color = colors[0];
  for (int i = 1; i < 8; i++) {
    if (steps[i] < 0.0 || steps[i] > 1.0) {
      break;
    }
    if(steps[i] == steps[i - 1]) {
      color = colors[i];
    } else {
      color = mix(color, colors[i], clamp((t - steps[i - 1]) / (steps[i] - steps[i - 1]), 0.0, 1.0));
    }
    if (steps[i] >= t) {
      break;
    }
  }
}
#endif

#ifdef FILTER
void transformColor(inout vec4 color, in float colorMatrix[20]) {
  float r = color.r, g = color.g, b = color.b, a = color.a;
  color[0] = colorMatrix[0] * r + colorMatrix[1] * g + colorMatrix[2] * b + colorMatrix[3] * a + colorMatrix[4];
  color[1] = colorMatrix[5] * r + colorMatrix[6] * g + colorMatrix[7] * b + colorMatrix[8] * a + colorMatrix[9];
  color[2] = colorMatrix[10] * r + colorMatrix[11] * g + colorMatrix[12] * b + colorMatrix[13] * a + colorMatrix[14];
  color[3] = colorMatrix[15] * r + colorMatrix[16] * g + colorMatrix[17] * b + colorMatrix[18] * a + colorMatrix[19];
}
#endif

void main() {
  vec4 color = vColor;
  float opacity = abs(flagBackground);

#ifdef GRADIENT
  if(u_gradientType > 0 && flagBackground > 0.0 || u_gradientType == 0 && flagBackground <= 0.0) {
    gradient(color, vGradientVector1, vGradientVector2, u_colorSteps);
  }
#endif

  if(opacity < 1.0) {
    color.a *= opacity;
  }

#ifdef TEXTURE
  if(flagBackground > 0.0) {
    vec3 texCoord = vTextureCoord;

    if(texCoord.z == 1.0) {
      texCoord = fract(texCoord);
    }

    if(texCoord.x <= 1.0 && texCoord.x >= 0.0
      && texCoord.y <= 1.0 && texCoord.y >= 0.0) {
      if(vSourceRect.z > 0.0) {
        texCoord.x = vSourceRect.x + texCoord.x * vSourceRect.z;
        texCoord.y = 1.0 - (vSourceRect.y + (1.0 - texCoord.y) * vSourceRect.w);
      }
      vec4 texColor = texture2D(u_texSampler, texCoord.xy);
      float alpha = texColor.a;
      if(opacity < 1.0) {
        texColor.a *= opacity;
        alpha *= mix(0.465, 1.0, opacity);
      }
      // color = mix(color, texColor, texColor.a);
      color.rgb = mix(color.rgb, texColor.rgb, alpha);
      // color.rgb = mix(texColor.rgb, color.rgb, color.a);
      color.rgb = mix(texColor.rgb, color.rgb, clamp(color.a / max(0.0001, texColor.a), 0.0, 1.0));
      color.a = texColor.a + (1.0 - texColor.a) * color.a;
    }
  }
#endif

#ifdef FILTER
  if(u_filterFlag > 0) {
    transformColor(color, u_colorMatrix);
  }
#endif

#ifdef CLIPPATH
  float clip = texture2D(u_clipSampler, vClipUV).r;
  color *= clip;
#endif

  gl_FragColor = color;
}`;
    },
    /* 66 */
    /***/
    function(s, l, d) {
      d.r(l), l.default = `attribute vec3 a_vertexPosition;
attribute vec4 a_color;
varying vec4 vColor;
varying float flagBackground;
attribute vec3 a_transform0;
attribute vec3 a_transform1;
uniform vec2 u_resolution;
uniform mat3 viewMatrix;
uniform mat3 projectionMatrix;

#ifdef TEXTURE
attribute vec3 a_vertexTextureCoord;
varying vec3 vTextureCoord;
attribute float a_frameIndex;
varying float frameIndex;
attribute vec4 a_sourceRect;
varying vec4 vSourceRect;
#endif

#ifdef CLIPPATH
attribute vec2 a_clipUV;
varying vec2 vClipUV;
#endif

#ifdef CLOUDFILTER
attribute vec4 a_colorCloud0;
attribute vec4 a_colorCloud1;
attribute vec4 a_colorCloud2;
attribute vec4 a_colorCloud3;
attribute vec4 a_colorCloud4;
varying vec4 colorCloud0;
varying vec4 colorCloud1;
varying vec4 colorCloud2;
varying vec4 colorCloud3;
varying vec4 colorCloud4;
#endif

#ifdef CLOUDCOLOR
attribute vec4 a_fillCloudColor;
attribute vec4 a_strokeCloudColor;
#endif

#ifdef GRADIENT
uniform float u_radialGradientVector[6];
varying vec3 vGradientVector1;
varying vec3 vGradientVector2;
#endif

void main() {
  gl_PointSize = 1.0;

  mat3 modelMatrix = mat3(
    a_transform0.x, a_transform1.x, 0, 
    a_transform0.y, a_transform1.y, 0,
    a_transform0.z, a_transform1.z, 1
  );

  vec3 pos = projectionMatrix * viewMatrix * modelMatrix * vec3(a_vertexPosition.xy, 1.0);
  gl_Position = vec4(pos.xy, 1.0, 1.0);

#ifdef GRADIENT
  vec3 vg1 = viewMatrix * vec3(u_radialGradientVector[0], u_radialGradientVector[1], 1.0);
  vec3 vg2 = viewMatrix * vec3(u_radialGradientVector[3], u_radialGradientVector[4], 1.0);
  float h = u_resolution.y;
  vg1.y = h - vg1.y;
  vg2.y = h - vg2.y;
  vGradientVector1 = vec3(vg1.xy, u_radialGradientVector[2]);
  vGradientVector2 = vec3(vg2.xy, u_radialGradientVector[5]);
#endif
  
  flagBackground = a_vertexPosition.z;

#ifdef CLOUDCOLOR
  if(flagBackground > 0.0) {
    vColor = mix(a_color, a_fillCloudColor, a_fillCloudColor.a);
  } else {
    vColor = mix(a_color, a_strokeCloudColor, a_strokeCloudColor.a);
  }
#else
  vColor = a_color;
#endif

#ifdef TEXTURE
  vTextureCoord = a_vertexTextureCoord;
  frameIndex = a_frameIndex;
  vSourceRect = a_sourceRect;
#endif

#ifdef CLIPPATH
  vClipUV = a_clipUV;
#endif

#ifdef CLOUDFILTER
  colorCloud0 = a_colorCloud0;
  colorCloud1 = a_colorCloud1;
  colorCloud2 = a_colorCloud2;
  colorCloud3 = a_colorCloud3;
  colorCloud4 = a_colorCloud4;
#endif
}`;
    },
    /* 67 */
    /***/
    function(s, l, d) {
      d.r(l), l.default = `precision mediump float;

varying vec4 vColor;
varying float flagBackground;

#ifdef TEXTURE
varying float frameIndex;
varying vec3 vTextureCoord;
varying vec4 vSourceRect;
#endif

#ifdef CLIPPATH
varying vec2 vClipUV;
#endif

#ifdef FILTER
uniform int u_filterFlag;
uniform float u_colorMatrix[20];
#endif

#ifdef CLOUDFILTER
varying vec4 colorCloud0;
varying vec4 colorCloud1;
varying vec4 colorCloud2;
varying vec4 colorCloud3;
varying vec4 colorCloud4;
#endif

#ifdef GRADIENT
varying vec3 vGradientVector1;
varying vec3 vGradientVector2;
uniform float u_colorSteps[40];
uniform int u_gradientType;

void gradient(inout vec4 color, vec3 gv1, vec3 gv2, float colorSteps[40]) {
  float t;
  // center circle radius
  float cr = gv1.z;
  // focal circle radius
  float fr = gv2.z;

  if(cr > 0.0 || fr > 0.0) {
    // radial gradient
    vec2 center = gv1.xy;
    vec2 focal = gv2.xy;
    float x = focal.x - gl_FragCoord.x;
    float y = focal.y - gl_FragCoord.y;
    float dx = focal.x - center.x;
    float dy = focal.y - center.y;
    float dr = cr - fr;
    float a = dx * dx + dy * dy - dr * dr;
    float b = -2.0 * (y * dy + x * dx + fr * dr);
    float c = x * x + y * y - fr * fr;
    t = 1.0 - 0.5 * (1.0 / a) * (-b + sqrt(b * b - 4.0 * a * c));
  } else {
    // linear gradient
    vec2 v1 = gl_FragCoord.xy - gv1.xy;
    vec2 v2 = gv2.xy - gv1.xy;
    t = (v1.x * v2.x + v1.y * v2.y) / (v2.x * v2.x + v2.y * v2.y);
  }

  vec4 colors[8];
  colors[0] = vec4(colorSteps[1], colorSteps[2], colorSteps[3], colorSteps[4]);
  colors[1] = vec4(colorSteps[6], colorSteps[7], colorSteps[8], colorSteps[9]);
  colors[2] = vec4(colorSteps[11], colorSteps[12], colorSteps[13], colorSteps[14]);
  colors[3] = vec4(colorSteps[16], colorSteps[17], colorSteps[18], colorSteps[19]);
  colors[4] = vec4(colorSteps[21], colorSteps[22], colorSteps[23], colorSteps[24]);
  colors[5] = vec4(colorSteps[26], colorSteps[27], colorSteps[28], colorSteps[29]);
  colors[6] = vec4(colorSteps[31], colorSteps[32], colorSteps[33], colorSteps[34]);
  colors[7] = vec4(colorSteps[36], colorSteps[37], colorSteps[38], colorSteps[39]);
  
  float steps[8];
  steps[0] = colorSteps[0];
  steps[1] = colorSteps[5];
  steps[2] = colorSteps[10];
  steps[3] = colorSteps[15];
  steps[4] = colorSteps[20];
  steps[5] = colorSteps[25];
  steps[6] = colorSteps[30];
  steps[7] = colorSteps[35];

  color = colors[0];
  for (int i = 1; i < 8; i++) {
    if (steps[i] < 0.0 || steps[i] > 1.0) {
      break;
    }
    if(steps[i] == steps[i - 1]) {
      color = colors[i];
    } else {
      color = mix(color, colors[i], clamp((t - steps[i - 1]) / (steps[i] - steps[i - 1]), 0.0, 1.0));
    }
    if (steps[i] >= t) {
      break;
    }
  }
}
#endif

void transformColor(inout vec4 color, in float colorMatrix[20]) {
  float r = color.r, g = color.g, b = color.b, a = color.a;
  color[0] = colorMatrix[0] * r + colorMatrix[1] * g + colorMatrix[2] * b + colorMatrix[3] * a + colorMatrix[4];
  color[1] = colorMatrix[5] * r + colorMatrix[6] * g + colorMatrix[7] * b + colorMatrix[8] * a + colorMatrix[9];
  color[2] = colorMatrix[10] * r + colorMatrix[11] * g + colorMatrix[12] * b + colorMatrix[13] * a + colorMatrix[14];
  color[3] = colorMatrix[15] * r + colorMatrix[16] * g + colorMatrix[17] * b + colorMatrix[18] * a + colorMatrix[19];
}

#ifdef CLOUDFILTER
void buildCloudColor(inout float colorCloudMatrix[20]) {
  colorCloudMatrix[0] = colorCloud0[0];
  colorCloudMatrix[1] = colorCloud1[0];
  colorCloudMatrix[2] = colorCloud2[0];
  colorCloudMatrix[3] = colorCloud3[0];
  colorCloudMatrix[4] = colorCloud4[0];

  colorCloudMatrix[5] = colorCloud0[1];
  colorCloudMatrix[6] = colorCloud1[1];
  colorCloudMatrix[7] = colorCloud2[1];
  colorCloudMatrix[8] = colorCloud3[1];
  colorCloudMatrix[9] = colorCloud4[1];

  colorCloudMatrix[10] = colorCloud0[2];
  colorCloudMatrix[11] = colorCloud1[2];
  colorCloudMatrix[12] = colorCloud2[2];
  colorCloudMatrix[13] = colorCloud3[2];
  colorCloudMatrix[14] = colorCloud4[2];

  colorCloudMatrix[15] = colorCloud0[3];
  colorCloudMatrix[16] = colorCloud1[3];
  colorCloudMatrix[17] = colorCloud2[3];
  colorCloudMatrix[18] = colorCloud3[3];
  colorCloudMatrix[19] = colorCloud4[3];
}
#endif

void main() {
  vec4 color = vColor;
  float opacity = abs(flagBackground);

#ifdef GRADIENT
  if(u_gradientType > 0 && flagBackground > 0.0 || u_gradientType == 0 && flagBackground <= 0.0) {
    gradient(color, vGradientVector1, vGradientVector2, u_colorSteps);
  }
#endif

  if(opacity < 1.0) {
    color.a *= opacity;
  }

#ifdef TEXTURE
  if(flagBackground > 0.0) {
    vec3 texCoord = vTextureCoord;

    if(texCoord.z == 1.0) {
      texCoord = fract(texCoord);
    }

    if(texCoord.x <= 1.0 && texCoord.x >= 0.0
      && texCoord.y <= 1.0 && texCoord.y >= 0.0) {
      if(vSourceRect.z > 0.0) {
        texCoord.x = vSourceRect.x + texCoord.x * vSourceRect.z;
        texCoord.y = 1.0 - (vSourceRect.y + (1.0 - texCoord.y) * vSourceRect.w);
      }
      if(frameIndex < 0.0) {
        vec4 texColor = texture2D(u_texSampler, texCoord.xy);
        color = mix(color, texColor, texColor.a);
      } else {
        int index = int(floor(clamp(0.0, 11.0, frameIndex)));
        vec4 texColor;
        if(index == 0) texColor = texture2D(u_texFrame0, texCoord.xy);
        else if(index == 1) texColor = texture2D(u_texFrame1, texCoord.xy);
        else if(index == 2) texColor = texture2D(u_texFrame2, texCoord.xy);
        else if(index == 3) texColor = texture2D(u_texFrame3, texCoord.xy);
        else if(index == 4) texColor = texture2D(u_texFrame4, texCoord.xy);
        else if(index == 5) texColor = texture2D(u_texFrame5, texCoord.xy);
        else if(index == 6) texColor = texture2D(u_texFrame6, texCoord.xy);
        else if(index == 7) texColor = texture2D(u_texFrame7, texCoord.xy);
        else if(index == 8) texColor = texture2D(u_texFrame8, texCoord.xy);
        else if(index == 9) texColor = texture2D(u_texFrame9, texCoord.xy);
        else if(index == 10) texColor = texture2D(u_texFrame10, texCoord.xy);
        else texColor = texture2D(u_texFrame11, texCoord.xy);
        float alpha = texColor.a;
        if(opacity < 1.0) {
          texColor.a *= opacity;
          alpha *= mix(0.465, 1.0, opacity);
        }
        // color = mix(color, texColor, texColor.a);
        color.rgb = mix(color.rgb, texColor.rgb, alpha);
        // color.rgb = mix(texColor.rgb, color.rgb, color.a);
        color.rgb = mix(texColor.rgb, color.rgb, clamp(color.a / max(0.0001, texColor.a), 0.0, 1.0));
        color.a = texColor.a + (1.0 - texColor.a) * color.a;
      }
    }
  }
#endif

#ifdef FILTER
  if(u_filterFlag > 0) {
    transformColor(color, u_colorMatrix);
  }
#endif

#ifdef CLOUDFILTER
  float colorCloudMatrix[20];
  buildCloudColor(colorCloudMatrix);
  transformColor(color, colorCloudMatrix);
#endif

#ifdef CLIPPATH
  float clip = texture2D(u_clipSampler, vClipUV).r;
  color *= clip;
#endif

  gl_FragColor = color;
}`;
    },
    /* 68 */
    /***/
    function(s, l, d) {
      d.r(l), (function(i, b) {
        d.d(l, "requestAnimationFrame", function() {
          return o;
        }), d.d(l, "cancelAnimationFrame", function() {
          return n;
        }), d(1).glMatrix.setMatrixArrayType(Array);
        function m() {
          if (typeof performance < "u" && performance.now)
            return performance.now();
          if (typeof i < "u" && i.hrtime) {
            const [W, e] = i.hrtime();
            return W * 1e3 + e * 1e-6;
          }
          return Date.now ? Date.now() : (/* @__PURE__ */ new Date()).getTime();
        }
        let o, n;
        typeof b < "u" && typeof b.requestAnimationFrame == "function" ? (o = b.requestAnimationFrame, n = b.cancelAnimationFrame) : (o = function(W) {
          return setTimeout(() => {
            W(m());
          }, 16);
        }, n = function(W) {
          return clearTimeout(W);
        });
      }).call(this, d(69), d(22));
    },
    /* 69 */
    /***/
    function(s, l) {
      var d = s.exports = {}, i, b;
      function m() {
        throw new Error("setTimeout has not been defined");
      }
      function o() {
        throw new Error("clearTimeout has not been defined");
      }
      (function() {
        try {
          typeof setTimeout == "function" ? i = setTimeout : i = m;
        } catch {
          i = m;
        }
        try {
          typeof clearTimeout == "function" ? b = clearTimeout : b = o;
        } catch {
          b = o;
        }
      })();
      function n(y) {
        if (i === setTimeout)
          return setTimeout(y, 0);
        if ((i === m || !i) && setTimeout)
          return i = setTimeout, setTimeout(y, 0);
        try {
          return i(y, 0);
        } catch {
          try {
            return i.call(null, y, 0);
          } catch {
            return i.call(this, y, 0);
          }
        }
      }
      function W(y) {
        if (b === clearTimeout)
          return clearTimeout(y);
        if ((b === o || !b) && clearTimeout)
          return b = clearTimeout, clearTimeout(y);
        try {
          return b(y);
        } catch {
          try {
            return b.call(null, y);
          } catch {
            return b.call(this, y);
          }
        }
      }
      var e = [], I = !1, a, V = -1;
      function h() {
        !I || !a || (I = !1, a.length ? e = a.concat(e) : V = -1, e.length && Y());
      }
      function Y() {
        if (!I) {
          var y = n(h);
          I = !0;
          for (var Z = e.length; Z; ) {
            for (a = e, e = []; ++V < Z; )
              a && a[V].run();
            V = -1, Z = e.length;
          }
          a = null, I = !1, W(y);
        }
      }
      d.nextTick = function(y) {
        var Z = new Array(arguments.length - 1);
        if (arguments.length > 1)
          for (var X = 1; X < arguments.length; X++)
            Z[X - 1] = arguments[X];
        e.push(new p(y, Z)), e.length === 1 && !I && n(Y);
      };
      function p(y, Z) {
        this.fun = y, this.array = Z;
      }
      p.prototype.run = function() {
        this.fun.apply(null, this.array);
      }, d.title = "browser", d.browser = !0, d.env = {}, d.argv = [], d.version = "", d.versions = {};
      function G() {
      }
      d.on = G, d.addListener = G, d.once = G, d.off = G, d.removeListener = G, d.removeAllListeners = G, d.emit = G, d.prependListener = G, d.prependOnceListener = G, d.listeners = function(y) {
        return [];
      }, d.binding = function(y) {
        throw new Error("process.binding is not supported");
      }, d.cwd = function() {
        return "/";
      }, d.chdir = function(y) {
        throw new Error("process.chdir is not supported");
      }, d.umask = function() {
        return 0;
      };
    },
    /* 70 */
    /***/
    function(s, l, d) {
      d.r(l), d.d(l, "default", function() {
        return J;
      });
      var i = d(1), b = d(71), m = d(73), o = d(213), n = d(214), W = d(215), e = d(216);
      d(1).glMatrix.setMatrixArrayType(Array);
      function I(H, L) {
        var C = Object.keys(H);
        if (Object.getOwnPropertySymbols) {
          var F = Object.getOwnPropertySymbols(H);
          L && (F = F.filter(function(r) {
            return Object.getOwnPropertyDescriptor(H, r).enumerable;
          })), C.push.apply(C, F);
        }
        return C;
      }
      function a(H) {
        for (var L = 1; L < arguments.length; L++) {
          var C = arguments[L] != null ? arguments[L] : {};
          L % 2 ? I(Object(C), !0).forEach(function(F) {
            V(H, F, C[F]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(H, Object.getOwnPropertyDescriptors(C)) : I(Object(C)).forEach(function(F) {
            Object.defineProperty(H, F, Object.getOwnPropertyDescriptor(C, F));
          });
        }
        return H;
      }
      function V(H, L, C) {
        return L in H ? Object.defineProperty(H, L, { value: C, enumerable: !0, configurable: !0, writable: !0 }) : H[L] = C, H;
      }
      const h = Symbol.for("spritejs_changedAttrs"), Y = Symbol.for("spritejs_attributes"), p = Symbol("resolution"), G = Symbol("animations"), y = Symbol("eventListeners"), Z = Symbol("captureEventListeners"), X = Symbol("filters"), c = Symbol("display"), t = Symbol("program"), R = Symbol("shaderAttrs"), S = Symbol("uniforms");
      class J {
        constructor(L = {}) {
          this.attributes = new this.constructor.Attr(this), this[p] = {
            width: 300,
            height: 150
          }, Object.assign(this.attributes, L), this[G] = /* @__PURE__ */ new Set(), this[y] = {}, this[Z] = {};
        }
        get ancestors() {
          let L = this.parent;
          const C = [];
          for (; L; )
            C.push(L), L = L.parent;
          return C;
        }
        get animations() {
          return this[G];
        }
        get filters() {
          return this[X] || this.parent && this.parent.filters;
        }
        get isVisible() {
          return !1;
        }
        get layer() {
          return this.parent ? this.parent.layer : null;
        }
        get localMatrix() {
          const L = this.transformMatrix, {
            x: C,
            y: F
          } = this.attributes;
          return L[4] += C, L[5] += F, L;
        }
        get opacity() {
          let L = this.attributes.opacity;
          return this.parent && this.parent.opacity != null && (L *= this.parent.opacity), L;
        }
        get parentNode() {
          return this.parent;
        }
        get nextSibling() {
          return this.getNodeNearBy(1);
        }
        get previousSibling() {
          return this.getNodeNearBy(-1);
        }
        get program() {
          return this[t];
        }
        /* get parent defined by connect method */
        get renderer() {
          return this.parent ? this.parent.renderer : null;
        }
        get renderMatrix() {
          if (this.__cacheRenderMatrix)
            return this.__cacheRenderMatrix;
          let L = this.localMatrix;
          const C = this.parent;
          if (C) {
            const F = C.__cacheRenderMatrix || C.renderMatrix;
            F && (L = i.mat2d.multiply(Array.of(0, 0, 0, 0, 0, 0), F, L));
          }
          return L;
        }
        get worldScaling() {
          const L = this.renderMatrix;
          return [Math.hypot(L[0], L[1]), Math.hypot(L[2], L[3])];
        }
        get worldRotation() {
          const L = this.renderMatrix;
          return Math.atan2(L[1], L[3]);
        }
        get worldPosition() {
          const L = this.renderMatrix;
          return [L[4], L[5]];
        }
        get uniforms() {
          return this[S];
        }
        /* get zOrder defined by connect method */
        /* attributes */
        get className() {
          return this.attributes.className;
        }
        set className(L) {
          this.attributes.className = L;
        }
        get id() {
          return this.attributes.id;
        }
        set id(L) {
          this.attributes.id = L;
        }
        get name() {
          return this.attributes.name;
        }
        set name(L) {
          this.attributes.name = L;
        }
        get zIndex() {
          return this.attributes.zIndex;
        }
        set zIndex(L) {
          this.attributes.zIndex = L;
        }
        get mesh() {
          return null;
        }
        get shaderAttrs() {
          return this[R] || {};
        }
        activateAnimations() {
          const L = this.layer;
          if (L) {
            const C = this[G];
            C.forEach((r) => {
              r.baseTimeline = L.timeline, r.play(), r.finished.then(() => {
                C.delete(r);
              });
            });
            const F = this.children;
            F && F.forEach((r) => {
              r.activateAnimations && r.activateAnimations();
            });
          }
        }
        addEventListener(L, C, F = {}) {
          L === "mousewheel" && (L = "wheel"), typeof F == "boolean" && (F = {
            capture: F
          });
          const {
            capture: r,
            once: K
          } = F, g = r ? Z : y;
          return this[g][L] = this[g][L] || [], this[g][L].push({
            listener: C,
            once: K
          }), this;
        }
        animate(L, C) {
          const F = new m.default(this, L, C);
          return this.effects && F.applyEffects(this.effects), this.layer && (F.baseTimeline = this.layer.timeline, F.play(), F.finished.then(() => {
            this[G].delete(F);
          })), this[G].add(F), F;
        }
        attr(...L) {
          if (L.length === 0)
            return this.attributes[Y];
          if (L.length > 1) {
            let [C, F] = L;
            return typeof F == "function" && (F = F(this.attr(C))), this.setAttribute(C, F), this;
          }
          return typeof L[0] == "string" ? this.getAttribute(L[0]) : (Object.assign(this.attributes, L[0]), this);
        }
        cloneNode() {
          const L = new this.constructor(), C = this.attributes[h];
          return L.attr(C), L;
        }
        connect(L, C) {
          Object.defineProperty(this, "parent", {
            value: L,
            writable: !1,
            configurable: !0
          }), Object.defineProperty(this, "zOrder", {
            value: C,
            writable: !1,
            configurable: !0
          }), L.timeline && this.activateAnimations(), this.setResolution(L.getResolution()), this.forceUpdate(), this.dispatchEvent({
            type: "append",
            detail: {
              parent: L,
              zOrder: C
            }
          });
        }
        contains(L) {
          for (; L && this !== L; )
            L = L.parent;
          return !!L;
        }
        deactivateAnimations() {
          this[G].forEach((C) => C.cancel());
          const L = this.children;
          L && L.forEach((C) => {
            C.deactivateAnimations && C.deactivateAnimations();
          });
        }
        disconnect() {
          const {
            parent: L,
            zOrder: C
          } = this;
          delete this.parent, delete this.zOrder, this.deactivateAnimations(), this.dispatchEvent({
            type: "remove",
            detail: {
              parent: L,
              zOrder: C
            }
          }), L && L.forceUpdate();
        }
        dispatchEvent(L) {
          L instanceof n.default || (L = new n.default(L)), L.target = this;
          let C = L.type;
          C === "mousewheel" && (C = "wheel");
          const F = [this];
          let r = this.parent;
          for (; L.bubbles && r; )
            F.push(r), r = r.parent;
          for (let K = F.length - 1; K >= 0; K--) {
            const g = F[K], v = g[Z] && g[Z][C];
            if (v && v.length && (L.currentTarget = g, v.forEach(({
              listener: f,
              once: O
            }) => {
              f.call(this, L), O && F.removeEventListener(f);
            }), delete L.currentTarget), !L.bubbles && L.cancelBubble)
              break;
          }
          if (!L.cancelBubble)
            for (let K = 0; K < F.length; K++) {
              const g = F[K], v = g[y] && g[y][C];
              if (v && v.length && (L.currentTarget = g, v.forEach(({
                listener: f,
                once: O
              }) => {
                f.call(this, L), O && F.removeEventListener(f);
              }), delete L.currentTarget), !L.bubbles || L.cancelBubble)
                break;
            }
        }
        dispatchPointerEvent(L) {
          const {
            layerX: C,
            layerY: F
          } = L;
          return this.isPointCollision(C, F) ? (this.dispatchEvent(L), !0) : !1;
        }
        draw(L = []) {
          const C = this.mesh;
          if (C) {
            if (Object(W.applyFilters)(C, this.filters), L.push(C), this[t]) {
              C.setProgram(this[t]);
              const F = this[R];
              F && Object.entries(F).forEach(([K, g]) => {
                C.setAttribute(K, g);
              });
              const r = this[S];
              if (this[S]) {
                const K = {};
                Object.entries(r).forEach(([g, v]) => {
                  typeof v == "function" && (v = v(this, g)), K[g] = v;
                }), C.setUniforms(K);
              }
            }
            Object(e.default)(this, C);
          }
          return L;
        }
        forceUpdate() {
          this.parent && this.parent.forceUpdate();
        }
        getAttribute(L) {
          return this.attributes[L];
        }
        getListeners(L, {
          capture: C = !1
        } = {}) {
          return [...this[C ? Z : y][L] || []];
        }
        getNodeNearBy(L = 1) {
          if (!this.parent)
            return null;
          if (L === 0)
            return this;
          const C = this.parent.children, F = C.indexOf(this);
          return C[F + L];
        }
        getWorldPosition(L, C) {
          const F = this.renderMatrix, r = L * F[0] + C * F[2] + F[4], K = L * F[1] + C * F[3] + F[5];
          return [r, K];
        }
        getOffsetPosition(L, C) {
          const F = i.mat2d.invert(Array.of(0, 0, 0, 0, 0, 0), this.renderMatrix), r = L * F[0] + C * F[2] + F[4], K = L * F[1] + C * F[3] + F[5];
          return [r, K];
        }
        getResolution() {
          return a({}, this[p]);
        }
        isPointCollision(L, C) {
          if (!this.mesh)
            return !1;
          const F = this.attributes.pointerEvents;
          if (F === "none" || F !== "all" && !this.isVisible)
            return !1;
          let r = "both";
          return F === "visibleFill" && (r = "fill"), F === "visibleStroke" && (r = "stroke"), this.mesh.isPointCollision(L, C, r);
        }
        onPropertyChange(L, C, F) {
          L !== "id" && L !== "name" && L !== "className" && L !== "pointerEvents" && L !== "passEvents" && this.forceUpdate(), L === "filter" && (this[X] = Object(W.parseFilterString)(C)), L === "zIndex" && this.parent && this.parent.reorder();
        }
        setAttribute(L, C) {
          L === "attrs" && this.attr(C), this.attributes[L] = C;
        }
        setMouseCapture() {
          this.layer && (this.layer.__mouseCapturedTarget = this);
        }
        // layer.renderer.createProgram(fragmentShader, vertexShader, attributeOptions)
        setProgram(L) {
          this[t] = L, this.forceUpdate();
        }
        setShaderAttribute(L, C) {
          this[R] = this[R] || {}, this[R][L] = C, this.forceUpdate();
        }
        setUniforms(L) {
          this[S] = this[S] || {}, Object.assign(this[S], L), this.forceUpdate();
        }
        setResolution({
          width: L,
          height: C
        }) {
          const {
            width: F,
            height: r
          } = this[p];
          (F !== L || r !== C) && (this[p] = {
            width: L,
            height: C
          }, this.forceUpdate(), this.dispatchEvent({
            type: "resolutionchange",
            detail: {
              width: L,
              height: C
            }
          }));
        }
        show() {
          this.attributes.display === "none" && (this.attributes.display = this[c] || "");
        }
        hide() {
          this.attributes.display !== "none" && (this[c] = this.attributes.display, this.attributes.display = "none");
        }
        releaseMouseCapture() {
          this.layer && this.layer.__mouseCapturedTarget === this && (this.layer.__mouseCapturedTarget = null);
        }
        remove() {
          return this.parent && this.parent.removeChild ? (this.parent.removeChild(this), !0) : !1;
        }
        removeAllListeners(L, C = {}) {
          typeof C == "boolean" && (C = {
            capture: C
          });
          const r = C.capture ? Z : y;
          return this[r][L] && (this[r][L] = []), this;
        }
        removeAttribute(L) {
          this.setAttribute(L, null);
        }
        removeEventListener(L, C, F = {}) {
          typeof F == "boolean" && (F = {
            capture: F
          });
          const K = F.capture ? Z : y;
          if (this[K][L]) {
            const g = this[K][L];
            if (g)
              for (let v = 0; v < g.length; v++) {
                const {
                  listener: f
                } = g[v];
                if (f === C) {
                  this[K][L].splice(v, 1);
                  break;
                }
              }
          }
          return this;
        }
        transition(L, C = "linear") {
          const F = this, r = Symbol("animation");
          C = C || "linear";
          let K = 0;
          return typeof L == "object" && (K = L.delay || 0, L = L.duration), {
            [r]: null,
            cancel(g = !1) {
              const v = this[r];
              v && v.cancel(g);
            },
            end() {
              const g = this[r];
              g && (g.playState === "running" || g.playState === "pending") && g.finish();
            },
            reverse() {
              const g = this[r];
              if (g)
                if (g.playState === "running" || g.playState === "pending")
                  g.playbackRate = -g.playbackRate;
                else {
                  const v = g.timing.direction;
                  g.timing.direction = v === "reverse" ? "normal" : "reverse", g.play();
                }
              return g.finished;
            },
            attr(g, v) {
              return this.end(), typeof g == "string" && (g = {
                [g]: v
              }), Object.entries(g).forEach(([f, O]) => {
                typeof O == "function" && (g[f] = O(F.attr(f)));
              }), this[r] = F.animate([g], {
                duration: L * 1e3,
                delay: K * 1e3,
                fill: "forwards",
                easing: C
              }), this[r].finished;
            }
          };
        }
        updateContours() {
        }
      }
      V(J, "Attr", b.default), o.default.registerNode(J, "node");
    },
    /* 71 */
    /***/
    function(s, l, d) {
      d.r(l), d.d(l, "default", function() {
        return J;
      });
      var i = d(1), b = d(12), m = d(72);
      d(1).glMatrix.setMatrixArrayType(Array);
      const o = Symbol.for("spritejs_setAttributeDefault"), n = Symbol.for("spritejs_declareAlias"), W = Symbol.for("spritejs_setAttribute"), e = Symbol.for("spritejs_getAttribute"), I = Symbol.for("spritejs_attributes"), a = Symbol.for("spritejs_changedAttrs"), V = Symbol("subject"), h = Symbol("attr"), Y = Symbol("default"), p = Symbol("alias");
      function G(H, [L, C]) {
        let F = i.mat2d.fromValues(1, 0, 0, 1, 0, 0);
        return [...H].forEach(([r, K]) => {
          if ((L || C) && (F = i.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), F, [L, C])), r === "matrix")
            F = i.mat2d.multiply(F, F, K);
          else if (r === "offsetTranslate")
            F[4] += K[0], F[5] += K[1];
          else if (r === "offsetRotate")
            F = i.mat2d.rotate(Array.of(0, 0, 0, 0, 0, 0), F, K);
          else if (r === "skew") {
            const [g, v] = K;
            F = i.mat2d.multiply(F, F, i.mat2d.fromValues(1, Math.tan(v), Math.tan(g), 1, 0, 0));
          } else
            i.mat2d[r](F, F, K);
          (L || C) && (F = i.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), F, [-L, -C]));
        }), F;
      }
      const y = Symbol("transformMatrix"), Z = Symbol("transforms"), X = Symbol("changedAttrs"), c = Symbol("lastChangedAttr"), t = Symbol("offsetFigure");
      function R(H, L, C) {
        const F = H[h][L];
        if (H[W](L, C, !1) || H[c] !== L) {
          const K = H[Z];
          K.has(L) && K.delete(L), C && (L === "rotate" && (C = Math.PI * C / 180), L === "scale" && (C = C.map((g) => Math.abs(g) > 1e-5 ? g : 1 / g > 0 ? 1e-5 : -1e-5)), K.set(L, C)), H[y] = null, H[V].onPropertyChange(L, C, F, H);
        }
      }
      function S(H) {
        const L = H[t], C = H.offsetDistance * L.getTotalLength(), F = L.getPointAtLength(C);
        if (F) {
          const r = H[Z];
          let K = H.offsetRotate;
          K === "auto" ? K = F.angle : K === "reverse" ? K = Math.PI + F.angle : K = Math.PI * K / 180, r.set("offsetRotate", K), r.set("offsetTranslate", [F.x, F.y]), H[y] = null;
        }
      }
      class J {
        static setDefault(L, ...C) {
          return L[o](...C);
        }
        static declareAlias(L, ...C) {
          return L[n](...C);
        }
        static setAttribute(L, ...C) {
          return L[W](...C);
        }
        static getAttribute(L, ...C) {
          return L[e](...C);
        }
        static getAttributes(L) {
          return L[I];
        }
        static getChangedAttributes(L) {
          return L[a];
        }
        constructor(L) {
          this[V] = L, this[h] = {}, this[y] = i.mat2d.fromValues(1, 0, 0, 1, 0, 0), this[Z] = /* @__PURE__ */ new Map(), this[Y] = {}, this[p] = [], Object.defineProperty(L, "transformMatrix", {
            get: () => (this[y] || (this[y] = G(this[Z], this.transformOrigin)), [...this[y]])
          }), this[o]({
            id: "",
            name: "",
            className: "",
            /* class */
            x: 0,
            y: 0,
            /* pos */
            transformOrigin: [0, 0],
            transform: "",
            translate: [0, 0],
            rotate: 0,
            scale: [1, 1],
            skew: [0, 0],
            opacity: 1,
            zIndex: 0,
            offsetPath: void 0,
            offsetDistance: 0,
            offsetRotate: "auto",
            pointerEvents: "visible",
            // none | visible | visibleFill | visibleStroke | all
            filter: "none",
            display: ""
          }), this[n]("class", "pos"), this[X] = /* @__PURE__ */ new Set(), this[t] = new b.Figure2D({
            scale: 5,
            simplify: 0
          });
        }
        get [a]() {
          const L = {};
          return [...this[X]].forEach((C) => {
            L[C] = this[h][C];
          }), L;
        }
        get [I]() {
          const L = Object.assign({}, this[h]);
          for (let C = 0; C < this[p].length; C++) {
            const F = this[p][C];
            L[F] = this[F];
          }
          return L;
        }
        [o](L) {
          Object.assign(this[Y], L), Object.assign(this[h], L);
        }
        [n](...L) {
          this[p].push(...L);
        }
        [W](L, C, F = !0) {
          const r = this[h][L], K = this[V];
          return C == null && (C = this[Y][L]), Object(m.compareValue)(r, C) ? !1 : (this[h][L] = C, this[X].has(L) && this[X].delete(L), this[X].add(L), this[c] = L, F && K.onPropertyChange(L, C, r, this), !0);
        }
        [e](L) {
          return this[h][L];
        }
        set id(L) {
          this[W]("id", L);
        }
        get id() {
          return this[e]("id");
        }
        set name(L) {
          this[W]("name", L);
        }
        get name() {
          return this[e]("name");
        }
        set className(L) {
          this[W]("className", L);
        }
        get className() {
          return this[e]("className");
        }
        set class(L) {
          this.className = L;
        }
        get class() {
          return this.className;
        }
        get x() {
          return this[e]("x");
        }
        set x(L) {
          this[W]("x", Object(m.toNumber)(L));
        }
        get y() {
          return this[e]("y");
        }
        set y(L) {
          this[W]("y", Object(m.toNumber)(L));
        }
        get pos() {
          return [this.x, this.y];
        }
        set pos(L) {
          L = Object(m.toArray)(L), Array.isArray(L) || (L = [L, L]), this.x = L[0], this.y = L[1];
        }
        get transform() {
          return this[e]("transform");
        }
        set transform(L) {
          let C = null;
          if (Array.isArray(L) && (C = L, L = `matrix(${L.map(m.toNumber).join()})`), typeof L == "string")
            L = L.replace(/\s*,\s*/g, ",");
          else if (L != null)
            throw new TypeError("Invalid transform value.");
          const F = this[h].transform;
          if (this[W]("transform", L, !1)) {
            const r = this[Z];
            if (r.has("matrix") && r.delete("matrix"), C)
              r.set("matrix", C);
            else if (L) {
              const K = L.match(/(matrix|translate|rotate|scale|skew)\([^()]+\)/g);
              if (K) {
                let g = i.mat2d.fromValues(1, 0, 0, 1, 0, 0);
                for (let v = 0; v < K.length; v++) {
                  const O = K[v].match(/^(matrix|translate|rotate|scale|skew)\(([^()]+)\)/);
                  if (O) {
                    let [, q, M] = O;
                    q === "rotate" ? M = Math.PI * parseFloat(M) / 180 : M = M.trim().split(/[\s,]+/).map((P) => Object(m.toNumber)(P)), q === "matrix" ? g = i.mat2d.multiply(g, g, M) : q === "skew" ? g = i.mat2d.multiply(g, g, i.mat2d.fromValues(1, Math.tan(M[1]), Math.tan(M[0]), 1, 0, 0)) : i.mat2d[q](g, g, M), r.set("matrix", g);
                  }
                }
              } else
                throw new TypeError("Invalid transform value.");
            }
            this[y] = null, this[V].onPropertyChange("transform", L, F, this);
          }
        }
        get transformOrigin() {
          return this[e]("transformOrigin");
        }
        set transformOrigin(L) {
          L = Object(m.toArray)(L, !0), L != null && !Array.isArray(L) && (L = [L, L]), this[W]("transformOrigin", L) && (this[y] = null);
        }
        get rotate() {
          return this[e]("rotate");
        }
        set rotate(L) {
          R(this, "rotate", L);
        }
        get translate() {
          return this[e]("translate");
        }
        set translate(L) {
          L = Object(m.toArray)(L, !0), L != null && !Array.isArray(L) && (L = [L, L]), R(this, "translate", L);
        }
        get scale() {
          return this[e]("scale");
        }
        set scale(L) {
          L = Object(m.toArray)(L, !0), L != null && !Array.isArray(L) && (L = [L, L]), R(this, "scale", L);
        }
        get skew() {
          return this[e]("skew");
        }
        set skew(L) {
          L = Object(m.toArray)(L, !0), L != null && !Array.isArray(L) && (L = [L, L]), R(this, "skew", L);
        }
        get opacity() {
          return this[e]("opacity");
        }
        set opacity(L) {
          L != null && (L = Number(L)), this[W]("opacity", L);
        }
        get zIndex() {
          return this[e]("zIndex");
        }
        set zIndex(L) {
          L != null && (L = Number(L)), this[W]("zIndex", L);
        }
        get offsetPath() {
          return this[e]("offsetPath");
        }
        set offsetPath(L) {
          this[W]("offsetPath", L) && (this[t].beginPath(), L != null && this[t].addPath(L), S(this));
        }
        get offsetDistance() {
          return this[e]("offsetDistance");
        }
        set offsetDistance(L) {
          this[W]("offsetDistance", Object(m.toNumber)(L)) && S(this);
        }
        get offsetRotate() {
          return this[e]("offsetRotate");
        }
        set offsetRotate(L) {
          this[W]("offsetRotate", L), S(this);
        }
        get pointerEvents() {
          return this[e]("pointerEvents");
        }
        set pointerEvents(L) {
          if (L != null && L !== "none" && L !== "visible" && L !== "visibleFill" && L !== "visibleStroke" && L !== "all")
            throw new TypeError("Invalid pointerEvents type.");
          this[W]("pointerEvents", L);
        }
        get filter() {
          return this[e]("filter");
        }
        set filter(L) {
          this[W]("filter", L);
        }
        get display() {
          return this[e]("display");
        }
        set display(L) {
          this[W]("display", L);
        }
        /* istanbul ignore next */
        set offset(L) {
        }
      }
    },
    /* 72 */
    /***/
    function(s, l, d) {
      d.r(l), d.d(l, "sizeToPixel", function() {
        return i;
      }), d.d(l, "toString", function() {
        return b;
      }), d.d(l, "toNumber", function() {
        return m;
      }), d.d(l, "toArray", function() {
        return o;
      }), d.d(l, "compareValue", function() {
        return n;
      }), d(1).glMatrix.setMatrixArrayType(Array);
      function i(W, e) {
        const I = W.trim().match(/^([\d.]+)(px|pt|pc|in|cm|mm|em|ex|rem|q|vw|vh|vmax|vmin)$/);
        I ? W = {
          size: parseFloat(I[1]),
          unit: I[2]
        } : W = {
          size: parseFloat(W),
          unit: "px"
        };
        let {
          size: a,
          unit: V
        } = W;
        if (V === "pt")
          a /= 0.75;
        else if (V === "pc")
          a *= 16;
        else if (V === "in")
          a *= 96;
        else if (V === "cm")
          a *= 96 / 2.54;
        else if (V === "mm")
          a *= 96 / 25.4;
        else if (V === "em" || V === "rem" || V === "ex") {
          if (!e && typeof getComputedStyle == "function" && typeof document < "u") {
            const h = getComputedStyle(document.documentElement).fontSize;
            h ? e = i(h, 16) : e = 16;
          }
          a *= e, V === "ex" && (a /= 2);
        } else if (V === "q")
          a *= 96 / 25.4 / 4;
        else if (V === "vw" || V === "vh") {
          if (typeof document < "u") {
            const h = V === "vw" ? window.innerWidth || document.documentElement.clientWidth : window.innerHeight || document.documentElement.clientHeight;
            a *= h / 100;
          }
        } else if ((V === "vmax" || V === "vmin") && typeof document < "u") {
          const h = window.innerWidth || document.documentElement.clientWidth, Y = window.innerHeight || document.documentElement.clientHeight;
          V === "vmax" ? a *= Math.max(h, Y) / 100 : a *= Math.min(h, Y) / 100;
        }
        return a;
      }
      function b(W) {
        return W == null ? W : String(W);
      }
      function m(W) {
        if (W == null)
          return W;
        if (typeof W == "string" && (W = i(W)), !Number.isFinite(W))
          throw new TypeError("Invalid value");
        return W;
      }
      function o(W, e = !1) {
        return W === "" ? null : (typeof W == "string" && (W = W.split(/[\s,]+/g)), Array.isArray(W) && (e && (W = W.map(m)), W.length === 1) ? W[0] : W);
      }
      function n(W, e) {
        if (Array.isArray(W) && Array.isArray(e)) {
          if (W.length !== e.length)
            return !1;
          for (let I = 0; I < W.length; I++)
            if (W[I] !== e[I])
              return !1;
          return !0;
        }
        return W == null && e == null || W === e;
      }
    },
    /* 73 */
    /***/
    function(s, l, d) {
      d.r(l), d.d(l, "default", function() {
        return V;
      });
      var i = d(74), b = d(32), m = /* @__PURE__ */ d.n(b), o = d(68), n = d(72);
      d(1).glMatrix.setMatrixArrayType(Array);
      function W() {
        return W = Object.assign || function(h) {
          for (var Y = 1; Y < arguments.length; Y++) {
            var p = arguments[Y];
            for (var G in p)
              Object.prototype.hasOwnProperty.call(p, G) && (h[G] = p[G]);
          }
          return h;
        }, W.apply(this, arguments);
      }
      function e(h) {
        if (typeof h == "string") {
          if (h = h.trim(), /^[0-9.]+%$/.test(h))
            return parseFloat(h) / 100;
          if (/^([\d.]+)(px|pt|pc|in|cm|mm|em|ex|rem|q|vw|vh|vmax|vmin)$/.test(h))
            return Object(n.sizeToPixel)(h);
        }
        return h;
      }
      function I(h, Y, p, G, y) {
        return typeof h == "string" && (h = m()(h)), typeof Y == "string" && (Y = m()(Y)), i.Effects.default(h, Y, p, G, y);
      }
      function a(h, Y, p, G, y) {
        return i.Effects.default(h, Y, p, G, y);
      }
      i.Effects.default = function(h, Y, p, G, y) {
        return Array.isArray(h) && Array.isArray(Y) ? h.map((Z, X) => Z + (p - G) / (y - G) * (Y[X] - Z)) : typeof h == "number" && typeof Y == "number" ? h + (p - G) / (y - G) * (Y - h) : p - G > y - p ? Y : h;
      }, i.Effects.fillColor = I, i.Effects.strokeColor = I, i.Effects.bgcolor = I, i.Effects.borderColor = I, i.Effects.text = a;
      class V extends i.Animator {
        constructor(Y, p, G) {
          const y = Y.attr();
          Object.entries(y).forEach(([Z, X]) => {
            y[Z] = i.Effects[Z] ? X : e(X);
          }), p = p.map((Z) => {
            let X = W({}, Z);
            const c = {};
            return Object.entries(X).forEach(([t, R]) => {
              c[t] = i.Effects[t] ? R : e(R);
            }), c;
          }), super(y, p, G), this.target = Y, this.setter = function(Z, X) {
            X.attr(Z);
          };
        }
        get playState() {
          return this.target.parent ? super.playState : "idle";
        }
        get finished() {
          return super.finished.then(() => {
            const Y = this;
            return new Promise((p) => {
              function G() {
                Y.setter(Y.frame, Y.target);
                const y = Y.playState;
                y === "finished" || y === "idle" ? (Object(o.cancelAnimationFrame)(Y.requestId), p()) : Object(o.requestAnimationFrame)(G);
              }
              G();
            });
          });
        }
        finish() {
          super.finish(), Object(o.cancelAnimationFrame)(this.requestId), this.setter(this.frame, this.target);
        }
        play() {
          if (!this.target.parent || this.playState === "running")
            return;
          super.play(), this.setter(this.frame, this.target);
          const Y = this;
          this.ready.then(() => {
            Y.setter(Y.frame, Y.target), Y.requestId = Object(o.requestAnimationFrame)(function p() {
              const G = Y.target;
              if (typeof document < "u" && document.documentElement && document.documentElement.contains && G.layer && G.layer.canvas && !document.documentElement.contains(G.layer.canvas)) {
                Y.cancel();
                return;
              }
              const y = Y.playState;
              Y.setter(Y.frame, Y.target), y !== "idle" && (y === "running" ? Y.requestId = Object(o.requestAnimationFrame)(p) : (y === "paused" || y === "pending" && Y.timeline.currentTime < 0) && Y.ready.then(() => {
                Y.setter(Y.frame, Y.target), Y.requestId = Object(o.requestAnimationFrame)(p);
              }));
            });
          });
        }
        cancel(Y = !1) {
          Object(o.cancelAnimationFrame)(this.requestId), Y ? (this.setter(this.frame, this.target), super.cancel()) : (super.cancel(), this.setter(this.frame, this.target));
        }
      }
    },
    /* 74 */
    /***/
    function(s, l, d) {
      Object.defineProperty(l, "__esModule", {
        value: !0
      }), l.Timeline = l.Effects = l.Easings = l.Animator = void 0;
      var i = d(75), b = I(i), m = d(187), o = I(m), n = d(188), W = d(190), e = I(W);
      function I(a) {
        return a && a.__esModule ? a : { default: a };
      }
      l.Animator = e.default, l.Easings = n.Easings, l.Effects = o.default, l.Timeline = b.default;
    },
    /* 75 */
    /***/
    function(s, l, d) {
      Object.defineProperty(l, "__esModule", {
        value: !0
      });
      var i = d(76), b = Z(i), m = d(133), o = Z(m), n = d(141), W = Z(n), e = d(164), I = Z(e), a = d(170), V = Z(a), h = d(171), Y = Z(h), p = d(175), G = Z(p), y = d(186);
      function Z(F) {
        return F && F.__esModule ? F : { default: F };
      }
      var X = (0, y.createNowTime)(), c = {
        originTime: 0,
        playbackRate: 1
      }, t = (0, G.default)("timeMark"), R = (0, G.default)("playbackRate"), S = (0, G.default)("timers"), J = (0, G.default)("originTime"), H = (0, G.default)("setTimer"), L = (0, G.default)("parent"), C = function() {
        function F(r, K) {
          (0, V.default)(this, F), r instanceof F && (K = r, r = {}), r = (0, I.default)({}, c, r), K && (this[L] = K);
          var g = r.nowtime || X;
          if (K)
            Object.defineProperty(this, "globalTime", {
              get: function() {
                return K.currentTime;
              }
            });
          else {
            var v = g();
            Object.defineProperty(this, "globalTime", {
              get: function() {
                return g() - v;
              }
            });
          }
          this[t] = [{
            globalTime: this.globalTime,
            localTime: -r.originTime,
            entropy: -r.originTime,
            playbackRate: r.playbackRate,
            globalEntropy: 0
          }], this[L] && (this[t][0].globalEntropy = this[L].entropy), this[J] = r.originTime, this[R] = r.playbackRate, this[S] = new W.default();
        }
        return (0, Y.default)(F, [{
          key: "markTime",
          value: function() {
            var K = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, g = K.time, v = g === void 0 ? this.currentTime : g, f = K.entropy, O = f === void 0 ? this.entropy : f, q = K.playbackRate, M = q === void 0 ? this.playbackRate : q, P = {
              globalTime: this.globalTime,
              localTime: v,
              entropy: O,
              playbackRate: M,
              globalEntropy: this.globalEntropy
            };
            this[t].push(P);
          }
        }, {
          key: "fork",
          value: function(K) {
            return new F(K, this);
          }
        }, {
          key: "seekGlobalTime",
          value: function(K) {
            var g = this.seekTimeMark(K), v = this[t][g], f = v.entropy, O = v.playbackRate, q = v.globalTime;
            return q + (K - f) / Math.abs(O);
          }
        }, {
          key: "seekLocalTime",
          value: function(K) {
            var g = this.seekTimeMark(K), v = this[t][g], f = v.localTime, O = v.entropy, q = v.playbackRate;
            return q > 0 ? f + (K - O) : f - (K - O);
          }
        }, {
          key: "seekTimeMark",
          value: function(K) {
            var g = this[t], v = 0, f = g.length - 1;
            if (K <= g[v].entropy)
              return v;
            if (K >= g[f].entropy)
              return f;
            for (var O = Math.floor((v + f) / 2); O > v && O < f; ) {
              if (K === g[O].entropy)
                return O;
              K < g[O].entropy ? f = O : K > g[O].entropy && (v = O), O = Math.floor((v + f) / 2);
            }
            return v;
          }
        }, {
          key: "updateTimers",
          value: function() {
            var K = this, g = [].concat((0, o.default)(this[S]));
            g.forEach(function(v) {
              var f = (0, b.default)(v, 2), O = f[0], q = f[1];
              K[H](q.handler, q.time, O);
            });
          }
        }, {
          key: "clearTimeout",
          value: function(r) {
            function K(g) {
              return r.apply(this, arguments);
            }
            return K.toString = function() {
              return r.toString();
            }, K;
          }(function(r) {
            var K = this[S].get(r);
            K && K.timerID != null && (this[L] ? this[L].clearTimeout(K.timerID) : clearTimeout(K.timerID)), this[S].delete(r);
          })
        }, {
          key: "clearInterval",
          value: function(K) {
            return this.clearTimeout(K);
          }
        }, {
          key: "clear",
          value: function() {
            var K = this, g = this[S];
            [].concat((0, o.default)(g.keys())).forEach(function(v) {
              K.clearTimeout(v);
            });
          }
          /*
            setTimeout(func, {delay: 100, isEntropy: true})
            setTimeout(func, {entropy: 100})
            setTimeout(func, 100})
           */
        }, {
          key: "setTimeout",
          value: function(K) {
            var g = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : { delay: 0 };
            return this[H](K, g);
          }
        }, {
          key: "setInterval",
          value: function(K) {
            var g = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : { delay: 0 }, v = this, f = this[H](function O() {
              v[H](O, g, f), K();
            }, g);
            return f;
          }
        }, {
          key: H,
          value: function(K, g) {
            var v = this, f = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : (0, G.default)("timerID");
            g = (0, y.formatDelay)(g);
            var O = this[S].get(f), q = void 0, M = null, P = void 0, D = void 0;
            O ? (this.clearTimeout(f), g.isEntropy ? q = (g.delay - (this.entropy - O.startEntropy)) / Math.abs(this.playbackRate) : q = (g.delay - (this.currentTime - O.startTime)) / this.playbackRate, P = O.startTime, D = O.startEntropy) : (q = g.delay / (g.isEntropy ? Math.abs(this.playbackRate) : this.playbackRate), P = this.currentTime, D = this.entropy);
            var dd = this[L], _ = dd ? dd.setTimeout.bind(dd) : setTimeout, cd = g.heading;
            return !dd && cd === !1 && q < 0 && (q = 1 / 0), (isFinite(q) || dd) && (q = Math.ceil(q), _ !== setTimeout && (q = { delay: q, heading: cd }), M = _(function() {
              v[S].delete(f), K();
            }, q)), this[S].set(f, {
              timerID: M,
              handler: K,
              time: g,
              startTime: P,
              startEntropy: D
            }), f;
          }
        }, {
          key: "parent",
          get: function() {
            return this[L];
          }
        }, {
          key: "lastTimeMark",
          get: function() {
            return this[t][this[t].length - 1];
          }
        }, {
          key: "currentTime",
          get: function() {
            var K = this.lastTimeMark, g = K.localTime, v = K.globalTime;
            return g + (this.globalTime - v) * this.playbackRate;
          },
          set: function(K) {
            var g = this, v = this.currentTime, f = K, O = this[S];
            this.markTime({ time: K }), [].concat((0, o.default)(O)).forEach(function(q) {
              var M = (0, b.default)(q, 2), P = M[0], D = M[1];
              if (O.has(P)) {
                var dd = D.time, _ = dd.isEntropy, cd = dd.delay, $ = dd.heading, Wd = D.handler, Xd = D.startTime;
                if (_)
                  cd === 0 && (Wd(), g.clearTimeout(P));
                else {
                  var k = Xd + cd;
                  (cd === 0 || $ !== !1 && (f - v) * cd <= 0 || v <= k && k <= f || v >= k && k >= f) && (Wd(), g.clearTimeout(P));
                }
              }
            }), this.updateTimers();
          }
          // Both currentTime and entropy should be influenced by playbackRate.
          // If current playbackRate is negative, the currentTime should go backwards
          // while the entropy remain to go forwards.
          // Both of the initial values is set to -originTime
        }, {
          key: "entropy",
          get: function() {
            var K = this.lastTimeMark, g = K.entropy, v = K.globalEntropy;
            return g + Math.abs((this.globalEntropy - v) * this.playbackRate);
          },
          // get globalTime() {
          //   if(this[_parent]) {
          //     return this[_parent].currentTime;
          //   }
          //   return nowtime();
          // }
          // change entropy will NOT cause currentTime changing but may influence the pass
          // and the future of the timeline. (It may change the result of seek***Time)
          // While entropy is set, all the marks behind will be droped
          set: function(K) {
            if (this.entropy > K) {
              var g = this.seekTimeMark(K);
              this[t].length = g + 1;
            }
            this.markTime({ entropy: K }), this.updateTimers();
          }
        }, {
          key: "globalEntropy",
          get: function() {
            return this[L] ? this[L].entropy : this.globalTime;
          }
        }, {
          key: "playbackRate",
          get: function() {
            return this[R];
          },
          set: function(K) {
            K !== this.playbackRate && (this.markTime({ playbackRate: K }), this[R] = K, this.updateTimers());
          }
        }, {
          key: "paused",
          get: function() {
            if (this.playbackRate === 0)
              return !0;
            for (var K = this.parent; K; ) {
              if (K.playbackRate === 0)
                return !0;
              K = K.parent;
            }
            return !1;
          }
        }]), F;
      }();
      l.default = C;
    },
    /* 76 */
    /***/
    function(s, l, d) {
      l.__esModule = !0;
      var i = d(77), b = n(i), m = d(129), o = n(m);
      function n(W) {
        return W && W.__esModule ? W : { default: W };
      }
      l.default = /* @__PURE__ */ function() {
        function W(e, I) {
          var a = [], V = !0, h = !1, Y = void 0;
          try {
            for (var p = (0, o.default)(e), G; !(V = (G = p.next()).done) && (a.push(G.value), !(I && a.length === I)); V = !0)
              ;
          } catch (y) {
            h = !0, Y = y;
          } finally {
            try {
              !V && p.return && p.return();
            } finally {
              if (h)
                throw Y;
            }
          }
          return a;
        }
        return function(e, I) {
          if (Array.isArray(e))
            return e;
          if ((0, b.default)(Object(e)))
            return W(e, I);
          throw new TypeError("Invalid attempt to destructure non-iterable instance");
        };
      }();
    },
    /* 77 */
    /***/
    function(s, l, d) {
      s.exports = { default: d(78), __esModule: !0 };
    },
    /* 78 */
    /***/
    function(s, l, d) {
      d(79), d(125), s.exports = d(127);
    },
    /* 79 */
    /***/
    function(s, l, d) {
      d(80);
      for (var i = d(91), b = d(95), m = d(83), o = d(122)("toStringTag"), n = "CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,TextTrackList,TouchList".split(","), W = 0; W < n.length; W++) {
        var e = n[W], I = i[e], a = I && I.prototype;
        a && !a[o] && b(a, o, e), m[e] = m.Array;
      }
    },
    /* 80 */
    /***/
    function(s, l, d) {
      var i = d(81), b = d(82), m = d(83), o = d(84);
      s.exports = d(88)(Array, "Array", function(n, W) {
        this._t = o(n), this._i = 0, this._k = W;
      }, function() {
        var n = this._t, W = this._k, e = this._i++;
        return !n || e >= n.length ? (this._t = void 0, b(1)) : W == "keys" ? b(0, e) : W == "values" ? b(0, n[e]) : b(0, [e, n[e]]);
      }, "values"), m.Arguments = m.Array, i("keys"), i("values"), i("entries");
    },
    /* 81 */
    /***/
    function(s, l) {
      s.exports = function() {
      };
    },
    /* 82 */
    /***/
    function(s, l) {
      s.exports = function(d, i) {
        return { value: i, done: !!d };
      };
    },
    /* 83 */
    /***/
    function(s, l) {
      s.exports = {};
    },
    /* 84 */
    /***/
    function(s, l, d) {
      var i = d(85), b = d(87);
      s.exports = function(m) {
        return i(b(m));
      };
    },
    /* 85 */
    /***/
    function(s, l, d) {
      var i = d(86);
      s.exports = Object("z").propertyIsEnumerable(0) ? Object : function(b) {
        return i(b) == "String" ? b.split("") : Object(b);
      };
    },
    /* 86 */
    /***/
    function(s, l) {
      var d = {}.toString;
      s.exports = function(i) {
        return d.call(i).slice(8, -1);
      };
    },
    /* 87 */
    /***/
    function(s, l) {
      s.exports = function(d) {
        if (d == null)
          throw TypeError("Can't call method on  " + d);
        return d;
      };
    },
    /* 88 */
    /***/
    function(s, l, d) {
      var i = d(89), b = d(90), m = d(106), o = d(95), n = d(83), W = d(107), e = d(121), I = d(123), a = d(122)("iterator"), V = !([].keys && "next" in [].keys()), h = "@@iterator", Y = "keys", p = "values", G = function() {
        return this;
      };
      s.exports = function(y, Z, X, c, t, R, S) {
        W(X, Z, c);
        var J = function(M) {
          if (!V && M in F)
            return F[M];
          switch (M) {
            case Y:
              return function() {
                return new X(this, M);
              };
            case p:
              return function() {
                return new X(this, M);
              };
          }
          return function() {
            return new X(this, M);
          };
        }, H = Z + " Iterator", L = t == p, C = !1, F = y.prototype, r = F[a] || F[h] || t && F[t], K = r || J(t), g = t ? L ? J("entries") : K : void 0, v = Z == "Array" && F.entries || r, f, O, q;
        if (v && (q = I(v.call(new y())), q !== Object.prototype && q.next && (e(q, H, !0), !i && typeof q[a] != "function" && o(q, a, G))), L && r && r.name !== p && (C = !0, K = function() {
          return r.call(this);
        }), (!i || S) && (V || C || !F[a]) && o(F, a, K), n[Z] = K, n[H] = G, t)
          if (f = {
            values: L ? K : J(p),
            keys: R ? K : J(Y),
            entries: g
          }, S)
            for (O in f)
              O in F || m(F, O, f[O]);
          else
            b(b.P + b.F * (V || C), Z, f);
        return f;
      };
    },
    /* 89 */
    /***/
    function(s, l) {
      s.exports = !0;
    },
    /* 90 */
    /***/
    function(s, l, d) {
      var i = d(91), b = d(92), m = d(93), o = d(95), n = d(105), W = "prototype", e = function(I, a, V) {
        var h = I & e.F, Y = I & e.G, p = I & e.S, G = I & e.P, y = I & e.B, Z = I & e.W, X = Y ? b : b[a] || (b[a] = {}), c = X[W], t = Y ? i : p ? i[a] : (i[a] || {})[W], R, S, J;
        Y && (V = a);
        for (R in V)
          S = !h && t && t[R] !== void 0, !(S && n(X, R)) && (J = S ? t[R] : V[R], X[R] = Y && typeof t[R] != "function" ? V[R] : y && S ? m(J, i) : Z && t[R] == J ? function(H) {
            var L = function(C, F, r) {
              if (this instanceof H) {
                switch (arguments.length) {
                  case 0:
                    return new H();
                  case 1:
                    return new H(C);
                  case 2:
                    return new H(C, F);
                }
                return new H(C, F, r);
              }
              return H.apply(this, arguments);
            };
            return L[W] = H[W], L;
          }(J) : G && typeof J == "function" ? m(Function.call, J) : J, G && ((X.virtual || (X.virtual = {}))[R] = J, I & e.R && c && !c[R] && o(c, R, J)));
      };
      e.F = 1, e.G = 2, e.S = 4, e.P = 8, e.B = 16, e.W = 32, e.U = 64, e.R = 128, s.exports = e;
    },
    /* 91 */
    /***/
    function(s, l) {
      var d = s.exports = typeof window < "u" && window.Math == Math ? window : typeof self < "u" && self.Math == Math ? self : Function("return this")();
      typeof __g == "number" && (__g = d);
    },
    /* 92 */
    /***/
    function(s, l) {
      var d = s.exports = { version: "2.6.11" };
      typeof __e == "number" && (__e = d);
    },
    /* 93 */
    /***/
    function(s, l, d) {
      var i = d(94);
      s.exports = function(b, m, o) {
        if (i(b), m === void 0)
          return b;
        switch (o) {
          case 1:
            return function(n) {
              return b.call(m, n);
            };
          case 2:
            return function(n, W) {
              return b.call(m, n, W);
            };
          case 3:
            return function(n, W, e) {
              return b.call(m, n, W, e);
            };
        }
        return function() {
          return b.apply(m, arguments);
        };
      };
    },
    /* 94 */
    /***/
    function(s, l) {
      s.exports = function(d) {
        if (typeof d != "function")
          throw TypeError(d + " is not a function!");
        return d;
      };
    },
    /* 95 */
    /***/
    function(s, l, d) {
      var i = d(96), b = d(104);
      s.exports = d(100) ? function(m, o, n) {
        return i.f(m, o, b(1, n));
      } : function(m, o, n) {
        return m[o] = n, m;
      };
    },
    /* 96 */
    /***/
    function(s, l, d) {
      var i = d(97), b = d(99), m = d(103), o = Object.defineProperty;
      l.f = d(100) ? Object.defineProperty : function(W, e, I) {
        if (i(W), e = m(e, !0), i(I), b)
          try {
            return o(W, e, I);
          } catch {
          }
        if ("get" in I || "set" in I)
          throw TypeError("Accessors not supported!");
        return "value" in I && (W[e] = I.value), W;
      };
    },
    /* 97 */
    /***/
    function(s, l, d) {
      var i = d(98);
      s.exports = function(b) {
        if (!i(b))
          throw TypeError(b + " is not an object!");
        return b;
      };
    },
    /* 98 */
    /***/
    function(s, l) {
      s.exports = function(d) {
        return typeof d == "object" ? d !== null : typeof d == "function";
      };
    },
    /* 99 */
    /***/
    function(s, l, d) {
      s.exports = !d(100) && !d(101)(function() {
        return Object.defineProperty(d(102)("div"), "a", { get: function() {
          return 7;
        } }).a != 7;
      });
    },
    /* 100 */
    /***/
    function(s, l, d) {
      s.exports = !d(101)(function() {
        return Object.defineProperty({}, "a", { get: function() {
          return 7;
        } }).a != 7;
      });
    },
    /* 101 */
    /***/
    function(s, l) {
      s.exports = function(d) {
        try {
          return !!d();
        } catch {
          return !0;
        }
      };
    },
    /* 102 */
    /***/
    function(s, l, d) {
      var i = d(98), b = d(91).document, m = i(b) && i(b.createElement);
      s.exports = function(o) {
        return m ? b.createElement(o) : {};
      };
    },
    /* 103 */
    /***/
    function(s, l, d) {
      var i = d(98);
      s.exports = function(b, m) {
        if (!i(b))
          return b;
        var o, n;
        if (m && typeof (o = b.toString) == "function" && !i(n = o.call(b)) || typeof (o = b.valueOf) == "function" && !i(n = o.call(b)) || !m && typeof (o = b.toString) == "function" && !i(n = o.call(b)))
          return n;
        throw TypeError("Can't convert object to primitive value");
      };
    },
    /* 104 */
    /***/
    function(s, l) {
      s.exports = function(d, i) {
        return {
          enumerable: !(d & 1),
          configurable: !(d & 2),
          writable: !(d & 4),
          value: i
        };
      };
    },
    /* 105 */
    /***/
    function(s, l) {
      var d = {}.hasOwnProperty;
      s.exports = function(i, b) {
        return d.call(i, b);
      };
    },
    /* 106 */
    /***/
    function(s, l, d) {
      s.exports = d(95);
    },
    /* 107 */
    /***/
    function(s, l, d) {
      var i = d(108), b = d(104), m = d(121), o = {};
      d(95)(o, d(122)("iterator"), function() {
        return this;
      }), s.exports = function(n, W, e) {
        n.prototype = i(o, { next: b(1, e) }), m(n, W + " Iterator");
      };
    },
    /* 108 */
    /***/
    function(s, l, d) {
      var i = d(97), b = d(109), m = d(119), o = d(116)("IE_PROTO"), n = function() {
      }, W = "prototype", e = function() {
        var I = d(102)("iframe"), a = m.length, V = "<", h = ">", Y;
        for (I.style.display = "none", d(120).appendChild(I), I.src = "javascript:", Y = I.contentWindow.document, Y.open(), Y.write(V + "script" + h + "document.F=Object" + V + "/script" + h), Y.close(), e = Y.F; a--; )
          delete e[W][m[a]];
        return e();
      };
      s.exports = Object.create || function(a, V) {
        var h;
        return a !== null ? (n[W] = i(a), h = new n(), n[W] = null, h[o] = a) : h = e(), V === void 0 ? h : b(h, V);
      };
    },
    /* 109 */
    /***/
    function(s, l, d) {
      var i = d(96), b = d(97), m = d(110);
      s.exports = d(100) ? Object.defineProperties : function(n, W) {
        b(n);
        for (var e = m(W), I = e.length, a = 0, V; I > a; )
          i.f(n, V = e[a++], W[V]);
        return n;
      };
    },
    /* 110 */
    /***/
    function(s, l, d) {
      var i = d(111), b = d(119);
      s.exports = Object.keys || function(o) {
        return i(o, b);
      };
    },
    /* 111 */
    /***/
    function(s, l, d) {
      var i = d(105), b = d(84), m = d(112)(!1), o = d(116)("IE_PROTO");
      s.exports = function(n, W) {
        var e = b(n), I = 0, a = [], V;
        for (V in e)
          V != o && i(e, V) && a.push(V);
        for (; W.length > I; )
          i(e, V = W[I++]) && (~m(a, V) || a.push(V));
        return a;
      };
    },
    /* 112 */
    /***/
    function(s, l, d) {
      var i = d(84), b = d(113), m = d(115);
      s.exports = function(o) {
        return function(n, W, e) {
          var I = i(n), a = b(I.length), V = m(e, a), h;
          if (o && W != W) {
            for (; a > V; )
              if (h = I[V++], h != h)
                return !0;
          } else
            for (; a > V; V++)
              if ((o || V in I) && I[V] === W)
                return o || V || 0;
          return !o && -1;
        };
      };
    },
    /* 113 */
    /***/
    function(s, l, d) {
      var i = d(114), b = Math.min;
      s.exports = function(m) {
        return m > 0 ? b(i(m), 9007199254740991) : 0;
      };
    },
    /* 114 */
    /***/
    function(s, l) {
      var d = Math.ceil, i = Math.floor;
      s.exports = function(b) {
        return isNaN(b = +b) ? 0 : (b > 0 ? i : d)(b);
      };
    },
    /* 115 */
    /***/
    function(s, l, d) {
      var i = d(114), b = Math.max, m = Math.min;
      s.exports = function(o, n) {
        return o = i(o), o < 0 ? b(o + n, 0) : m(o, n);
      };
    },
    /* 116 */
    /***/
    function(s, l, d) {
      var i = d(117)("keys"), b = d(118);
      s.exports = function(m) {
        return i[m] || (i[m] = b(m));
      };
    },
    /* 117 */
    /***/
    function(s, l, d) {
      var i = d(92), b = d(91), m = "__core-js_shared__", o = b[m] || (b[m] = {});
      (s.exports = function(n, W) {
        return o[n] || (o[n] = W !== void 0 ? W : {});
      })("versions", []).push({
        version: i.version,
        mode: d(89) ? "pure" : "global",
        copyright: "© 2019 Denis Pushkarev (zloirock.ru)"
      });
    },
    /* 118 */
    /***/
    function(s, l) {
      var d = 0, i = Math.random();
      s.exports = function(b) {
        return "Symbol(".concat(b === void 0 ? "" : b, ")_", (++d + i).toString(36));
      };
    },
    /* 119 */
    /***/
    function(s, l) {
      s.exports = "constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",");
    },
    /* 120 */
    /***/
    function(s, l, d) {
      var i = d(91).document;
      s.exports = i && i.documentElement;
    },
    /* 121 */
    /***/
    function(s, l, d) {
      var i = d(96).f, b = d(105), m = d(122)("toStringTag");
      s.exports = function(o, n, W) {
        o && !b(o = W ? o : o.prototype, m) && i(o, m, { configurable: !0, value: n });
      };
    },
    /* 122 */
    /***/
    function(s, l, d) {
      var i = d(117)("wks"), b = d(118), m = d(91).Symbol, o = typeof m == "function", n = s.exports = function(W) {
        return i[W] || (i[W] = o && m[W] || (o ? m : b)("Symbol." + W));
      };
      n.store = i;
    },
    /* 123 */
    /***/
    function(s, l, d) {
      var i = d(105), b = d(124), m = d(116)("IE_PROTO"), o = Object.prototype;
      s.exports = Object.getPrototypeOf || function(n) {
        return n = b(n), i(n, m) ? n[m] : typeof n.constructor == "function" && n instanceof n.constructor ? n.constructor.prototype : n instanceof Object ? o : null;
      };
    },
    /* 124 */
    /***/
    function(s, l, d) {
      var i = d(87);
      s.exports = function(b) {
        return Object(i(b));
      };
    },
    /* 125 */
    /***/
    function(s, l, d) {
      var i = d(126)(!0);
      d(88)(String, "String", function(b) {
        this._t = String(b), this._i = 0;
      }, function() {
        var b = this._t, m = this._i, o;
        return m >= b.length ? { value: void 0, done: !0 } : (o = i(b, m), this._i += o.length, { value: o, done: !1 });
      });
    },
    /* 126 */
    /***/
    function(s, l, d) {
      var i = d(114), b = d(87);
      s.exports = function(m) {
        return function(o, n) {
          var W = String(b(o)), e = i(n), I = W.length, a, V;
          return e < 0 || e >= I ? m ? "" : void 0 : (a = W.charCodeAt(e), a < 55296 || a > 56319 || e + 1 === I || (V = W.charCodeAt(e + 1)) < 56320 || V > 57343 ? m ? W.charAt(e) : a : m ? W.slice(e, e + 2) : (a - 55296 << 10) + (V - 56320) + 65536);
        };
      };
    },
    /* 127 */
    /***/
    function(s, l, d) {
      var i = d(128), b = d(122)("iterator"), m = d(83);
      s.exports = d(92).isIterable = function(o) {
        var n = Object(o);
        return n[b] !== void 0 || "@@iterator" in n || m.hasOwnProperty(i(n));
      };
    },
    /* 128 */
    /***/
    function(s, l, d) {
      var i = d(86), b = d(122)("toStringTag"), m = i(/* @__PURE__ */ function() {
        return arguments;
      }()) == "Arguments", o = function(n, W) {
        try {
          return n[W];
        } catch {
        }
      };
      s.exports = function(n) {
        var W, e, I;
        return n === void 0 ? "Undefined" : n === null ? "Null" : typeof (e = o(W = Object(n), b)) == "string" ? e : m ? i(W) : (I = i(W)) == "Object" && typeof W.callee == "function" ? "Arguments" : I;
      };
    },
    /* 129 */
    /***/
    function(s, l, d) {
      s.exports = { default: d(130), __esModule: !0 };
    },
    /* 130 */
    /***/
    function(s, l, d) {
      d(79), d(125), s.exports = d(131);
    },
    /* 131 */
    /***/
    function(s, l, d) {
      var i = d(97), b = d(132);
      s.exports = d(92).getIterator = function(m) {
        var o = b(m);
        if (typeof o != "function")
          throw TypeError(m + " is not iterable!");
        return i(o.call(m));
      };
    },
    /* 132 */
    /***/
    function(s, l, d) {
      var i = d(128), b = d(122)("iterator"), m = d(83);
      s.exports = d(92).getIteratorMethod = function(o) {
        if (o != null)
          return o[b] || o["@@iterator"] || m[i(o)];
      };
    },
    /* 133 */
    /***/
    function(s, l, d) {
      l.__esModule = !0;
      var i = d(134), b = m(i);
      function m(o) {
        return o && o.__esModule ? o : { default: o };
      }
      l.default = function(o) {
        if (Array.isArray(o)) {
          for (var n = 0, W = Array(o.length); n < o.length; n++)
            W[n] = o[n];
          return W;
        } else
          return (0, b.default)(o);
      };
    },
    /* 134 */
    /***/
    function(s, l, d) {
      s.exports = { default: d(135), __esModule: !0 };
    },
    /* 135 */
    /***/
    function(s, l, d) {
      d(125), d(136), s.exports = d(92).Array.from;
    },
    /* 136 */
    /***/
    function(s, l, d) {
      var i = d(93), b = d(90), m = d(124), o = d(137), n = d(138), W = d(113), e = d(139), I = d(132);
      b(b.S + b.F * !d(140)(function(a) {
        Array.from(a);
      }), "Array", {
        // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
        from: function(V) {
          var h = m(V), Y = typeof this == "function" ? this : Array, p = arguments.length, G = p > 1 ? arguments[1] : void 0, y = G !== void 0, Z = 0, X = I(h), c, t, R, S;
          if (y && (G = i(G, p > 2 ? arguments[2] : void 0, 2)), X != null && !(Y == Array && n(X)))
            for (S = X.call(h), t = new Y(); !(R = S.next()).done; Z++)
              e(t, Z, y ? o(S, G, [R.value, Z], !0) : R.value);
          else
            for (c = W(h.length), t = new Y(c); c > Z; Z++)
              e(t, Z, y ? G(h[Z], Z) : h[Z]);
          return t.length = Z, t;
        }
      });
    },
    /* 137 */
    /***/
    function(s, l, d) {
      var i = d(97);
      s.exports = function(b, m, o, n) {
        try {
          return n ? m(i(o)[0], o[1]) : m(o);
        } catch (e) {
          var W = b.return;
          throw W !== void 0 && i(W.call(b)), e;
        }
      };
    },
    /* 138 */
    /***/
    function(s, l, d) {
      var i = d(83), b = d(122)("iterator"), m = Array.prototype;
      s.exports = function(o) {
        return o !== void 0 && (i.Array === o || m[b] === o);
      };
    },
    /* 139 */
    /***/
    function(s, l, d) {
      var i = d(96), b = d(104);
      s.exports = function(m, o, n) {
        o in m ? i.f(m, o, b(0, n)) : m[o] = n;
      };
    },
    /* 140 */
    /***/
    function(s, l, d) {
      var i = d(122)("iterator"), b = !1;
      try {
        var m = [7][i]();
        m.return = function() {
          b = !0;
        }, Array.from(m, function() {
          throw 2;
        });
      } catch {
      }
      s.exports = function(o, n) {
        if (!n && !b)
          return !1;
        var W = !1;
        try {
          var e = [7], I = e[i]();
          I.next = function() {
            return { done: W = !0 };
          }, e[i] = function() {
            return I;
          }, o(e);
        } catch {
        }
        return W;
      };
    },
    /* 141 */
    /***/
    function(s, l, d) {
      s.exports = { default: d(142), __esModule: !0 };
    },
    /* 142 */
    /***/
    function(s, l, d) {
      d(143), d(125), d(79), d(144), d(157), d(160), d(162), s.exports = d(92).Map;
    },
    /* 143 */
    /***/
    function(s, l) {
    },
    /* 144 */
    /***/
    function(s, l, d) {
      var i = d(145), b = d(151), m = "Map";
      s.exports = d(152)(m, function(o) {
        return function() {
          return o(this, arguments.length > 0 ? arguments[0] : void 0);
        };
      }, {
        // 23.1.3.6 Map.prototype.get(key)
        get: function(n) {
          var W = i.getEntry(b(this, m), n);
          return W && W.v;
        },
        // 23.1.3.9 Map.prototype.set(key, value)
        set: function(n, W) {
          return i.def(b(this, m), n === 0 ? 0 : n, W);
        }
      }, i, !0);
    },
    /* 145 */
    /***/
    function(s, l, d) {
      var i = d(96).f, b = d(108), m = d(146), o = d(93), n = d(147), W = d(148), e = d(88), I = d(82), a = d(149), V = d(100), h = d(150).fastKey, Y = d(151), p = V ? "_s" : "size", G = function(y, Z) {
        var X = h(Z), c;
        if (X !== "F")
          return y._i[X];
        for (c = y._f; c; c = c.n)
          if (c.k == Z)
            return c;
      };
      s.exports = {
        getConstructor: function(y, Z, X, c) {
          var t = y(function(R, S) {
            n(R, t, Z, "_i"), R._t = Z, R._i = b(null), R._f = void 0, R._l = void 0, R[p] = 0, S != null && W(S, X, R[c], R);
          });
          return m(t.prototype, {
            // 23.1.3.1 Map.prototype.clear()
            // 23.2.3.2 Set.prototype.clear()
            clear: function() {
              for (var S = Y(this, Z), J = S._i, H = S._f; H; H = H.n)
                H.r = !0, H.p && (H.p = H.p.n = void 0), delete J[H.i];
              S._f = S._l = void 0, S[p] = 0;
            },
            // 23.1.3.3 Map.prototype.delete(key)
            // 23.2.3.4 Set.prototype.delete(value)
            delete: function(R) {
              var S = Y(this, Z), J = G(S, R);
              if (J) {
                var H = J.n, L = J.p;
                delete S._i[J.i], J.r = !0, L && (L.n = H), H && (H.p = L), S._f == J && (S._f = H), S._l == J && (S._l = L), S[p]--;
              }
              return !!J;
            },
            // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
            // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
            forEach: function(S) {
              Y(this, Z);
              for (var J = o(S, arguments.length > 1 ? arguments[1] : void 0, 3), H; H = H ? H.n : this._f; )
                for (J(H.v, H.k, this); H && H.r; )
                  H = H.p;
            },
            // 23.1.3.7 Map.prototype.has(key)
            // 23.2.3.7 Set.prototype.has(value)
            has: function(S) {
              return !!G(Y(this, Z), S);
            }
          }), V && i(t.prototype, "size", {
            get: function() {
              return Y(this, Z)[p];
            }
          }), t;
        },
        def: function(y, Z, X) {
          var c = G(y, Z), t, R;
          return c ? c.v = X : (y._l = c = {
            i: R = h(Z, !0),
            // <- index
            k: Z,
            // <- key
            v: X,
            // <- value
            p: t = y._l,
            // <- previous entry
            n: void 0,
            // <- next entry
            r: !1
            // <- removed
          }, y._f || (y._f = c), t && (t.n = c), y[p]++, R !== "F" && (y._i[R] = c)), y;
        },
        getEntry: G,
        setStrong: function(y, Z, X) {
          e(y, Z, function(c, t) {
            this._t = Y(c, Z), this._k = t, this._l = void 0;
          }, function() {
            for (var c = this, t = c._k, R = c._l; R && R.r; )
              R = R.p;
            return !c._t || !(c._l = R = R ? R.n : c._t._f) ? (c._t = void 0, I(1)) : t == "keys" ? I(0, R.k) : t == "values" ? I(0, R.v) : I(0, [R.k, R.v]);
          }, X ? "entries" : "values", !X, !0), a(Z);
        }
      };
    },
    /* 146 */
    /***/
    function(s, l, d) {
      var i = d(95);
      s.exports = function(b, m, o) {
        for (var n in m)
          o && b[n] ? b[n] = m[n] : i(b, n, m[n]);
        return b;
      };
    },
    /* 147 */
    /***/
    function(s, l) {
      s.exports = function(d, i, b, m) {
        if (!(d instanceof i) || m !== void 0 && m in d)
          throw TypeError(b + ": incorrect invocation!");
        return d;
      };
    },
    /* 148 */
    /***/
    function(s, a, d) {
      var i = d(93), b = d(137), m = d(138), o = d(97), n = d(113), W = d(132), e = {}, I = {}, a = s.exports = function(V, h, Y, p, G) {
        var y = G ? function() {
          return V;
        } : W(V), Z = i(Y, p, h ? 2 : 1), X = 0, c, t, R, S;
        if (typeof y != "function")
          throw TypeError(V + " is not iterable!");
        if (m(y)) {
          for (c = n(V.length); c > X; X++)
            if (S = h ? Z(o(t = V[X])[0], t[1]) : Z(V[X]), S === e || S === I)
              return S;
        } else
          for (R = y.call(V); !(t = R.next()).done; )
            if (S = b(R, Z, t.value, h), S === e || S === I)
              return S;
      };
      a.BREAK = e, a.RETURN = I;
    },
    /* 149 */
    /***/
    function(s, l, d) {
      var i = d(91), b = d(92), m = d(96), o = d(100), n = d(122)("species");
      s.exports = function(W) {
        var e = typeof b[W] == "function" ? b[W] : i[W];
        o && e && !e[n] && m.f(e, n, {
          configurable: !0,
          get: function() {
            return this;
          }
        });
      };
    },
    /* 150 */
    /***/
    function(s, l, d) {
      var i = d(118)("meta"), b = d(98), m = d(105), o = d(96).f, n = 0, W = Object.isExtensible || function() {
        return !0;
      }, e = !d(101)(function() {
        return W(Object.preventExtensions({}));
      }), I = function(p) {
        o(p, i, { value: {
          i: "O" + ++n,
          // object ID
          w: {}
          // weak collections IDs
        } });
      }, a = function(p, G) {
        if (!b(p))
          return typeof p == "symbol" ? p : (typeof p == "string" ? "S" : "P") + p;
        if (!m(p, i)) {
          if (!W(p))
            return "F";
          if (!G)
            return "E";
          I(p);
        }
        return p[i].i;
      }, V = function(p, G) {
        if (!m(p, i)) {
          if (!W(p))
            return !0;
          if (!G)
            return !1;
          I(p);
        }
        return p[i].w;
      }, h = function(p) {
        return e && Y.NEED && W(p) && !m(p, i) && I(p), p;
      }, Y = s.exports = {
        KEY: i,
        NEED: !1,
        fastKey: a,
        getWeak: V,
        onFreeze: h
      };
    },
    /* 151 */
    /***/
    function(s, l, d) {
      var i = d(98);
      s.exports = function(b, m) {
        if (!i(b) || b._t !== m)
          throw TypeError("Incompatible receiver, " + m + " required!");
        return b;
      };
    },
    /* 152 */
    /***/
    function(s, l, d) {
      var i = d(91), b = d(90), m = d(150), o = d(101), n = d(95), W = d(146), e = d(148), I = d(147), a = d(98), V = d(121), h = d(96).f, Y = d(153)(0), p = d(100);
      s.exports = function(G, y, Z, X, c, t) {
        var R = i[G], S = R, J = c ? "set" : "add", H = S && S.prototype, L = {};
        return !p || typeof S != "function" || !(t || H.forEach && !o(function() {
          new S().entries().next();
        })) ? (S = X.getConstructor(y, G, c, J), W(S.prototype, Z), m.NEED = !0) : (S = y(function(C, F) {
          I(C, S, G, "_c"), C._c = new R(), F != null && e(F, c, C[J], C);
        }), Y("add,clear,delete,forEach,get,has,set,keys,values,entries,toJSON".split(","), function(C) {
          var F = C == "add" || C == "set";
          C in H && !(t && C == "clear") && n(S.prototype, C, function(r, K) {
            if (I(this, S, C), !F && t && !a(r))
              return C == "get" ? void 0 : !1;
            var g = this._c[C](r === 0 ? 0 : r, K);
            return F ? this : g;
          });
        }), t || h(S.prototype, "size", {
          get: function() {
            return this._c.size;
          }
        })), V(S, G), L[G] = S, b(b.G + b.W + b.F, L), t || X.setStrong(S, G, c), S;
      };
    },
    /* 153 */
    /***/
    function(s, l, d) {
      var i = d(93), b = d(85), m = d(124), o = d(113), n = d(154);
      s.exports = function(W, e) {
        var I = W == 1, a = W == 2, V = W == 3, h = W == 4, Y = W == 6, p = W == 5 || Y, G = e || n;
        return function(y, Z, X) {
          for (var c = m(y), t = b(c), R = i(Z, X, 3), S = o(t.length), J = 0, H = I ? G(y, S) : a ? G(y, 0) : void 0, L, C; S > J; J++)
            if ((p || J in t) && (L = t[J], C = R(L, J, c), W)) {
              if (I)
                H[J] = C;
              else if (C)
                switch (W) {
                  case 3:
                    return !0;
                  case 5:
                    return L;
                  case 6:
                    return J;
                  case 2:
                    H.push(L);
                }
              else if (h)
                return !1;
            }
          return Y ? -1 : V || h ? h : H;
        };
      };
    },
    /* 154 */
    /***/
    function(s, l, d) {
      var i = d(155);
      s.exports = function(b, m) {
        return new (i(b))(m);
      };
    },
    /* 155 */
    /***/
    function(s, l, d) {
      var i = d(98), b = d(156), m = d(122)("species");
      s.exports = function(o) {
        var n;
        return b(o) && (n = o.constructor, typeof n == "function" && (n === Array || b(n.prototype)) && (n = void 0), i(n) && (n = n[m], n === null && (n = void 0))), n === void 0 ? Array : n;
      };
    },
    /* 156 */
    /***/
    function(s, l, d) {
      var i = d(86);
      s.exports = Array.isArray || function(m) {
        return i(m) == "Array";
      };
    },
    /* 157 */
    /***/
    function(s, l, d) {
      var i = d(90);
      i(i.P + i.R, "Map", { toJSON: d(158)("Map") });
    },
    /* 158 */
    /***/
    function(s, l, d) {
      var i = d(128), b = d(159);
      s.exports = function(m) {
        return function() {
          if (i(this) != m)
            throw TypeError(m + "#toJSON isn't generic");
          return b(this);
        };
      };
    },
    /* 159 */
    /***/
    function(s, l, d) {
      var i = d(148);
      s.exports = function(b, m) {
        var o = [];
        return i(b, !1, o.push, o, m), o;
      };
    },
    /* 160 */
    /***/
    function(s, l, d) {
      d(161)("Map");
    },
    /* 161 */
    /***/
    function(s, l, d) {
      var i = d(90);
      s.exports = function(b) {
        i(i.S, b, { of: function() {
          for (var o = arguments.length, n = new Array(o); o--; )
            n[o] = arguments[o];
          return new this(n);
        } });
      };
    },
    /* 162 */
    /***/
    function(s, l, d) {
      d(163)("Map");
    },
    /* 163 */
    /***/
    function(s, l, d) {
      var i = d(90), b = d(94), m = d(93), o = d(148);
      s.exports = function(n) {
        i(i.S, n, { from: function(e) {
          var I = arguments[1], a, V, h, Y;
          return b(this), a = I !== void 0, a && b(I), e == null ? new this() : (V = [], a ? (h = 0, Y = m(I, arguments[2], 2), o(e, !1, function(p) {
            V.push(Y(p, h++));
          })) : o(e, !1, V.push, V), new this(V));
        } });
      };
    },
    /* 164 */
    /***/
    function(s, l, d) {
      s.exports = { default: d(165), __esModule: !0 };
    },
    /* 165 */
    /***/
    function(s, l, d) {
      d(166), s.exports = d(92).Object.assign;
    },
    /* 166 */
    /***/
    function(s, l, d) {
      var i = d(90);
      i(i.S + i.F, "Object", { assign: d(167) });
    },
    /* 167 */
    /***/
    function(s, l, d) {
      var i = d(100), b = d(110), m = d(168), o = d(169), n = d(124), W = d(85), e = Object.assign;
      s.exports = !e || d(101)(function() {
        var I = {}, a = {}, V = Symbol(), h = "abcdefghijklmnopqrst";
        return I[V] = 7, h.split("").forEach(function(Y) {
          a[Y] = Y;
        }), e({}, I)[V] != 7 || Object.keys(e({}, a)).join("") != h;
      }) ? function(a, V) {
        for (var h = n(a), Y = arguments.length, p = 1, G = m.f, y = o.f; Y > p; )
          for (var Z = W(arguments[p++]), X = G ? b(Z).concat(G(Z)) : b(Z), c = X.length, t = 0, R; c > t; )
            R = X[t++], (!i || y.call(Z, R)) && (h[R] = Z[R]);
        return h;
      } : e;
    },
    /* 168 */
    /***/
    function(s, l) {
      l.f = Object.getOwnPropertySymbols;
    },
    /* 169 */
    /***/
    function(s, l) {
      l.f = {}.propertyIsEnumerable;
    },
    /* 170 */
    /***/
    function(s, l, d) {
      l.__esModule = !0, l.default = function(i, b) {
        if (!(i instanceof b))
          throw new TypeError("Cannot call a class as a function");
      };
    },
    /* 171 */
    /***/
    function(s, l, d) {
      l.__esModule = !0;
      var i = d(172), b = m(i);
      function m(o) {
        return o && o.__esModule ? o : { default: o };
      }
      l.default = /* @__PURE__ */ function() {
        function o(n, W) {
          for (var e = 0; e < W.length; e++) {
            var I = W[e];
            I.enumerable = I.enumerable || !1, I.configurable = !0, "value" in I && (I.writable = !0), (0, b.default)(n, I.key, I);
          }
        }
        return function(n, W, e) {
          return W && o(n.prototype, W), e && o(n, e), n;
        };
      }();
    },
    /* 172 */
    /***/
    function(s, l, d) {
      s.exports = { default: d(173), __esModule: !0 };
    },
    /* 173 */
    /***/
    function(s, l, d) {
      d(174);
      var i = d(92).Object;
      s.exports = function(m, o, n) {
        return i.defineProperty(m, o, n);
      };
    },
    /* 174 */
    /***/
    function(s, l, d) {
      var i = d(90);
      i(i.S + i.F * !d(100), "Object", { defineProperty: d(96).f });
    },
    /* 175 */
    /***/
    function(s, l, d) {
      s.exports = { default: d(176), __esModule: !0 };
    },
    /* 176 */
    /***/
    function(s, l, d) {
      d(177), d(143), d(184), d(185), s.exports = d(92).Symbol;
    },
    /* 177 */
    /***/
    function(s, l, d) {
      var i = d(91), b = d(105), m = d(100), o = d(90), n = d(106), W = d(150).KEY, e = d(101), I = d(117), a = d(121), V = d(118), h = d(122), Y = d(178), p = d(179), G = d(180), y = d(156), Z = d(97), X = d(98), c = d(124), t = d(84), R = d(103), S = d(104), J = d(108), H = d(181), L = d(183), C = d(168), F = d(96), r = d(110), K = L.f, g = F.f, v = H.f, f = i.Symbol, O = i.JSON, q = O && O.stringify, M = "prototype", P = h("_hidden"), D = h("toPrimitive"), dd = {}.propertyIsEnumerable, _ = I("symbol-registry"), cd = I("symbols"), $ = I("op-symbols"), Wd = Object[M], Xd = typeof f == "function" && !!C.f, k = i.QObject, z = !k || !k[M] || !k[M].findChild, E = m && e(function() {
        return J(g({}, "a", {
          get: function() {
            return g(this, "a", { value: 7 }).a;
          }
        })).a != 7;
      }) ? function(Zd, bd, md) {
        var od = K(Wd, bd);
        od && delete Wd[bd], g(Zd, bd, md), od && Zd !== Wd && g(Wd, bd, od);
      } : g, j = function(Zd) {
        var bd = cd[Zd] = J(f[M]);
        return bd._k = Zd, bd;
      }, N = Xd && typeof f.iterator == "symbol" ? function(Zd) {
        return typeof Zd == "symbol";
      } : function(Zd) {
        return Zd instanceof f;
      }, Q = function(bd, md, od) {
        return bd === Wd && Q($, md, od), Z(bd), md = R(md, !0), Z(od), b(cd, md) ? (od.enumerable ? (b(bd, P) && bd[P][md] && (bd[P][md] = !1), od = J(od, { enumerable: S(0, !1) })) : (b(bd, P) || g(bd, P, S(1, {})), bd[P][md] = !0), E(bd, md, od)) : g(bd, md, od);
      }, u = function(bd, md) {
        Z(bd);
        for (var od = G(md = t(md)), ed = 0, nd = od.length, hd; nd > ed; )
          Q(bd, hd = od[ed++], md[hd]);
        return bd;
      }, x = function(bd, md) {
        return md === void 0 ? J(bd) : u(J(bd), md);
      }, T = function(bd) {
        var md = dd.call(this, bd = R(bd, !0));
        return this === Wd && b(cd, bd) && !b($, bd) ? !1 : md || !b(this, bd) || !b(cd, bd) || b(this, P) && this[P][bd] ? md : !0;
      }, U = function(bd, md) {
        if (bd = t(bd), md = R(md, !0), !(bd === Wd && b(cd, md) && !b($, md))) {
          var od = K(bd, md);
          return od && b(cd, md) && !(b(bd, P) && bd[P][md]) && (od.enumerable = !0), od;
        }
      }, w = function(bd) {
        for (var md = v(t(bd)), od = [], ed = 0, nd; md.length > ed; )
          !b(cd, nd = md[ed++]) && nd != P && nd != W && od.push(nd);
        return od;
      }, B = function(bd) {
        for (var md = bd === Wd, od = v(md ? $ : t(bd)), ed = [], nd = 0, hd; od.length > nd; )
          b(cd, hd = od[nd++]) && (!md || b(Wd, hd)) && ed.push(cd[hd]);
        return ed;
      };
      Xd || (f = function() {
        if (this instanceof f)
          throw TypeError("Symbol is not a constructor!");
        var bd = V(arguments.length > 0 ? arguments[0] : void 0), md = function(od) {
          this === Wd && md.call($, od), b(this, P) && b(this[P], bd) && (this[P][bd] = !1), E(this, bd, S(1, od));
        };
        return m && z && E(Wd, bd, { configurable: !0, set: md }), j(bd);
      }, n(f[M], "toString", function() {
        return this._k;
      }), L.f = U, F.f = Q, d(182).f = H.f = w, d(169).f = T, C.f = B, m && !d(89) && n(Wd, "propertyIsEnumerable", T, !0), Y.f = function(Zd) {
        return j(h(Zd));
      }), o(o.G + o.W + o.F * !Xd, { Symbol: f });
      for (var A = (
        // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
        "hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(",")
      ), ld = 0; A.length > ld; )
        h(A[ld++]);
      for (var id = r(h.store), sd = 0; id.length > sd; )
        p(id[sd++]);
      o(o.S + o.F * !Xd, "Symbol", {
        // 19.4.2.1 Symbol.for(key)
        for: function(Zd) {
          return b(_, Zd += "") ? _[Zd] : _[Zd] = f(Zd);
        },
        // 19.4.2.5 Symbol.keyFor(sym)
        keyFor: function(bd) {
          if (!N(bd))
            throw TypeError(bd + " is not a symbol!");
          for (var md in _)
            if (_[md] === bd)
              return md;
        },
        useSetter: function() {
          z = !0;
        },
        useSimple: function() {
          z = !1;
        }
      }), o(o.S + o.F * !Xd, "Object", {
        // 19.1.2.2 Object.create(O [, Properties])
        create: x,
        // 19.1.2.4 Object.defineProperty(O, P, Attributes)
        defineProperty: Q,
        // 19.1.2.3 Object.defineProperties(O, Properties)
        defineProperties: u,
        // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
        getOwnPropertyDescriptor: U,
        // 19.1.2.7 Object.getOwnPropertyNames(O)
        getOwnPropertyNames: w,
        // 19.1.2.8 Object.getOwnPropertySymbols(O)
        getOwnPropertySymbols: B
      });
      var td = e(function() {
        C.f(1);
      });
      o(o.S + o.F * td, "Object", {
        getOwnPropertySymbols: function(bd) {
          return C.f(c(bd));
        }
      }), O && o(o.S + o.F * (!Xd || e(function() {
        var Zd = f();
        return q([Zd]) != "[null]" || q({ a: Zd }) != "{}" || q(Object(Zd)) != "{}";
      })), "JSON", {
        stringify: function(bd) {
          for (var md = [bd], od = 1, ed, nd; arguments.length > od; )
            md.push(arguments[od++]);
          if (nd = ed = md[1], !(!X(ed) && bd === void 0 || N(bd)))
            return y(ed) || (ed = function(hd, Sd) {
              if (typeof nd == "function" && (Sd = nd.call(this, hd, Sd)), !N(Sd))
                return Sd;
            }), md[1] = ed, q.apply(O, md);
        }
      }), f[M][D] || d(95)(f[M], D, f[M].valueOf), a(f, "Symbol"), a(Math, "Math", !0), a(i.JSON, "JSON", !0);
    },
    /* 178 */
    /***/
    function(s, l, d) {
      l.f = d(122);
    },
    /* 179 */
    /***/
    function(s, l, d) {
      var i = d(91), b = d(92), m = d(89), o = d(178), n = d(96).f;
      s.exports = function(W) {
        var e = b.Symbol || (b.Symbol = m ? {} : i.Symbol || {});
        W.charAt(0) != "_" && !(W in e) && n(e, W, { value: o.f(W) });
      };
    },
    /* 180 */
    /***/
    function(s, l, d) {
      var i = d(110), b = d(168), m = d(169);
      s.exports = function(o) {
        var n = i(o), W = b.f;
        if (W)
          for (var e = W(o), I = m.f, a = 0, V; e.length > a; )
            I.call(o, V = e[a++]) && n.push(V);
        return n;
      };
    },
    /* 181 */
    /***/
    function(s, l, d) {
      var i = d(84), b = d(182).f, m = {}.toString, o = typeof window == "object" && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [], n = function(W) {
        try {
          return b(W);
        } catch {
          return o.slice();
        }
      };
      s.exports.f = function(e) {
        return o && m.call(e) == "[object Window]" ? n(e) : b(i(e));
      };
    },
    /* 182 */
    /***/
    function(s, l, d) {
      var i = d(111), b = d(119).concat("length", "prototype");
      l.f = Object.getOwnPropertyNames || function(o) {
        return i(o, b);
      };
    },
    /* 183 */
    /***/
    function(s, l, d) {
      var i = d(169), b = d(104), m = d(84), o = d(103), n = d(105), W = d(99), e = Object.getOwnPropertyDescriptor;
      l.f = d(100) ? e : function(a, V) {
        if (a = m(a), V = o(V, !0), W)
          try {
            return e(a, V);
          } catch {
          }
        if (n(a, V))
          return b(!i.f.call(a, V), a[V]);
      };
    },
    /* 184 */
    /***/
    function(s, l, d) {
      d(179)("asyncIterator");
    },
    /* 185 */
    /***/
    function(s, l, d) {
      d(179)("observable");
    },
    /* 186 */
    /***/
    function(s, l, d) {
      Object.defineProperty(l, "__esModule", {
        value: !0
      }), l.createNowTime = i, l.formatDelay = b;
      function i() {
        var m = null;
        return Date.now ? m = Date.now : m = function() {
          return (/* @__PURE__ */ new Date()).getTime();
        }, m;
      }
      function b(m) {
        return typeof m == "number" ? m = { delay: m } : "entropy" in m && (m = { delay: m.entropy, isEntropy: !0 }), m;
      }
    },
    /* 187 */
    /***/
    function(s, l, d) {
      Object.defineProperty(l, "__esModule", {
        value: !0
      }), l.default = {
        // s - startFrame, e - endFrame
        default: function(b, m, o, n, W) {
          return typeof b == "number" && typeof m == "number" ? b + (o - n) / (W - n) * (m - b) : o - n > W - o ? m : b;
        }
      };
    },
    /* 188 */
    /***/
    function(s, l, d) {
      Object.defineProperty(l, "__esModule", {
        value: !0
      }), l.parseEasing = l.Easings = void 0;
      var i = d(76), b = e(i), m = d(133), o = e(m), n = d(141), W = e(n);
      function e(y) {
        return y && y.__esModule ? y : { default: y };
      }
      var I = d(189), a = new W.default();
      function V() {
        for (var y = arguments.length, Z = Array(y), X = 0; X < y; X++)
          Z[X] = arguments[X];
        var c = a.get(Z);
        return c || (c = I.apply(void 0, Z), a.set(Z, c), c);
      }
      function h(y) {
        var Z = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "end";
        return function(X, c) {
          for (var t = 1; t < c.length; t++) {
            var R = c[t].offset;
            if (X <= R) {
              var S = c[t - 1].offset, J = R, H = (X - S) / (J - S), L = 1 / y, C = H / L;
              return Z === "end" ? C = Math.floor(C) : C = Math.ceil(C), L * C * (J - S) + S;
            }
          }
          return 0;
        };
      }
      function Y(y) {
        var Z = /^cubic-bezier\((.*)\)/, X = y.match(Z);
        if (X) {
          var c = X[1].trim();
          return c = c.split(",").map(function(L) {
            return parseFloat(L.trim());
          }), V.apply(void 0, (0, o.default)(c));
        }
        if (Z = /^steps\((.*)\)/, X = y.match(Z), X) {
          var t = X[1].trim();
          t = t.split(",").map(function(L) {
            return L.trim();
          });
          var R = t, S = (0, b.default)(R, 2), J = S[0], H = S[1];
          return h(parseInt(J, 10), H);
        }
        return y;
      }
      var p = {
        linear: function(Z) {
          return Z;
        },
        ease: V(0.25, 0.1, 0.25, 1),
        "ease-in": V(0.42, 0, 1, 1),
        "ease-out": V(0, 0, 0.58, 1),
        "ease-in-out": V(0.42, 0, 0.58, 1),
        // 'step-start': function(p, frames){
        //   let ret = 0
        //   for(let i = 0; i < frames.length; i++){
        //     const {offset} = frames[i]
        //     ret = offset
        //     if(p < offset){
        //       break
        //     }
        //   }
        //   return ret
        // },
        // 'step-end': function(p, frames){
        //   let ret = 0
        //   for(let i = 0; i < frames.length; i++){
        //     const {offset} = frames[i]
        //     if(p < offset){
        //       break
        //     }
        //     ret = offset
        //   }
        //   return ret
        // }
        "step-start": h(1, "start"),
        "step-end": h(1, "end")
      };
      function G(y) {
        return typeof y == "string" ? p[y] ? y = p[y] : y = Y(y) : y.type === "cubic-bezier" ? y = V.apply(void 0, (0, o.default)(y.value)) : y.type === "steps" && (y = h(y.step, y.pos)), y;
      }
      l.Easings = p, l.parseEasing = G;
    },
    /* 189 */
    /***/
    function(s, l) {
      var d = 4, i = 1e-3, b = 1e-7, m = 10, o = 11, n = 1 / (o - 1), W = typeof Float32Array == "function";
      function e(y, Z) {
        return 1 - 3 * Z + 3 * y;
      }
      function I(y, Z) {
        return 3 * Z - 6 * y;
      }
      function a(y) {
        return 3 * y;
      }
      function V(y, Z, X) {
        return ((e(Z, X) * y + I(Z, X)) * y + a(Z)) * y;
      }
      function h(y, Z, X) {
        return 3 * e(Z, X) * y * y + 2 * I(Z, X) * y + a(Z);
      }
      function Y(y, Z, X, c, t) {
        var R, S, J = 0;
        do
          S = Z + (X - Z) / 2, R = V(S, c, t) - y, R > 0 ? X = S : Z = S;
        while (Math.abs(R) > b && ++J < m);
        return S;
      }
      function p(y, Z, X, c) {
        for (var t = 0; t < d; ++t) {
          var R = h(Z, X, c);
          if (R === 0)
            return Z;
          var S = V(Z, X, c) - y;
          Z -= S / R;
        }
        return Z;
      }
      function G(y) {
        return y;
      }
      s.exports = function(Z, X, c, t) {
        if (!(0 <= Z && Z <= 1 && 0 <= c && c <= 1))
          throw new Error("bezier x values must be in [0, 1] range");
        if (Z === X && c === t)
          return G;
        for (var R = W ? new Float32Array(o) : new Array(o), S = 0; S < o; ++S)
          R[S] = V(S * n, Z, c);
        function J(H) {
          for (var L = 0, C = 1, F = o - 1; C !== F && R[C] <= H; ++C)
            L += n;
          --C;
          var r = (H - R[C]) / (R[C + 1] - R[C]), K = L + r * n, g = h(K, Z, c);
          return g >= i ? p(H, K, Z, c) : g === 0 ? K : Y(H, L, L + n, Z, c);
        }
        return function(L) {
          return L === 0 ? 0 : L === 1 ? 1 : V(J(L), X, t);
        };
      };
    },
    /* 190 */
    /***/
    function(s, l, d) {
      Object.defineProperty(l, "__esModule", {
        value: !0
      });
      var i = d(191), b = X(i), m = d(204), o = X(m), n = d(164), W = X(n), e = d(170), I = X(e), a = d(171), V = X(a), h = d(175), Y = X(h), p = d(75), G = X(p), y = d(208), Z = d(188);
      function X(g) {
        return g && g.__esModule ? g : { default: g };
      }
      var c = (0, Y.default)("timing"), t = (0, Y.default)("keyframes"), R = (0, Y.default)("initState"), S = (0, Y.default)("readyDefer"), J = (0, Y.default)("finishedDefer"), H = (0, Y.default)("effects"), L = (0, Y.default)("activeReadyTimer"), C = (0, Y.default)("activeFinishTimer"), F = (0, Y.default)("removeDefer"), r = {
        delay: 0,
        endDelay: 0,
        fill: "auto",
        iterations: 1,
        playbackRate: 1,
        direction: "normal",
        easing: "linear",
        effect: null
      }, K = function() {
        function g(v, f, O) {
          var q = this;
          if ((0, I.default)(this, g), Array.isArray(v)) {
            var M = [v[0], v, f];
            v = M[0], f = M[1], O = M[2];
          }
          typeof O == "number" && (O = { duration: O }), this[c] = (0, W.default)({}, r, O), this[c].easing = (0, Z.parseEasing)(this[c].easing), this[t] = (0, y.calculateFramesOffset)(f);
          var P = this[t][this[t].length - 1];
          this[R] = {}, (0, o.default)(P).forEach(function(D) {
            Object.prototype.hasOwnProperty.call(v, D) && D !== "easing" && D !== "offset" && (q[R][D] = v[D]);
          }), this[t] = this[t].map(function(D) {
            return (0, W.default)({}, q[R], D);
          }), this[t][0].offset !== 0 && this[t].unshift((0, W.default)({}, this[R], { offset: 0 })), P.offset < 1 && this[t].push((0, W.default)({}, P, { offset: 1 })), this[H] = {}, this.timeline = null;
        }
        return (0, V.default)(g, [{
          key: "pause",
          value: function() {
            this.timeline.playbackRate = 0;
          }
        }, {
          key: L,
          value: function() {
            var f = this;
            this[S] && !this[S].timerID && (this.timeline.currentTime < 0 ? this[S].timerID = this.timeline.setTimeout(function() {
              f[S].resolve(), delete f[S];
            }, { delay: -this.timeline.currentTime, heading: !1 }) : this[S].timerID = this.timeline.setTimeout(function() {
              f[S].resolve(), delete f[S];
            }, { delay: 0, isEntropy: !0 }));
          }
        }, {
          key: C,
          value: function() {
            var f = this, O = this[c], q = O.duration, M = O.iterations, P = O.endDelay, D = Math.ceil(q * M + P - this.timeline.currentTime) + 1;
            this[J] && !this[J].timerID && (this[J].timerID = this.timeline.setTimeout(function() {
              f[J].resolve(), f[F](S), f[F](J);
            }, { delay: D, heading: !1 }), this[J].reverseTimerID = this.timeline.setTimeout(function() {
              f[J].resolve(), f[F](S), f[F](J), f.timeline = null;
            }, { delay: -this[c].delay - 1, heading: !1 }));
          }
        }, {
          key: "play",
          value: function() {
            if (this.playState === "finished" && this.cancel(), this.playState === "idle") {
              if (this.playbackRate <= 0)
                return;
              var f = this[c], O = f.delay, q = f.playbackRate, M = f.timeline;
              this.timeline = new G.default({
                originTime: O,
                playbackRate: q
              }, M), this[L](), this[C]();
            } else
              this.playState === "paused" && (this.timeline.playbackRate = this.playbackRate, this[L]());
          }
        }, {
          key: F,
          value: function(f) {
            var O = this[f], q = this.timeline;
            O && q && (q.clearTimeout(O.timerID), O.reverseTimerID && q.clearTimeout(O.reverseTimerID)), delete this[f];
          }
        }, {
          key: "cancel",
          value: function() {
            this[F](S), this[F](J), this.timeline = null;
          }
        }, {
          key: "finish",
          value: function() {
            this.timeline && (this.timeline.currentTime = 1 / 0 / this.playbackRate), this[F](S), this[F](J);
          }
        }, {
          key: "applyEffects",
          value: function(f) {
            return (0, W.default)(this[H], f);
          }
        }, {
          key: "playbackRate",
          get: function() {
            return this[c].playbackRate;
          },
          set: function(f) {
            this.timeline && (this.timeline.playbackRate = f), this[c].playbackRate = f;
          }
        }, {
          key: "playState",
          get: function() {
            var f = this.timeline, O = this[c], q = O.iterations, M = O.duration, P = O.endDelay, D = "running";
            if (f == null)
              D = "idle";
            else if (f.paused)
              D = "paused";
            else if (f.currentTime < 0)
              D = "pending";
            else {
              var dd = f.currentTime - q * M;
              dd > 0 && dd < P ? D = "pending" : dd >= P && (D = "finished");
            }
            return D;
          }
        }, {
          key: "progress",
          get: function() {
            if (!this.timeline)
              return 0;
            var f = this[c], O = f.duration, q = f.iterations, M = this.timeline, P = this.playState, D = void 0;
            if (P === "idle")
              D = 0;
            else if (P === "paused" && M.currentTime < 0)
              D = 0;
            else if (P === "pending")
              if (M.currentTime < 0)
                D = 0;
              else {
                var dd = M.seekLocalTime(q * O);
                D = (0, y.periodicity)(dd, O)[1] / O;
              }
            else
              (P === "running" || P === "paused") && (D = (0, y.periodicity)(M.currentTime, O)[1] / O);
            return P === "finished" && (D = (0, y.periodicity)(q, 1)[1]), D;
          }
        }, {
          key: "frame",
          get: function() {
            var f = this.playState, O = this[R], q = this[c].fill;
            if (f === "idle")
              return O;
            var M = this.timeline.currentTime, P = this[t].slice(0), D = (0, y.getProgress)(this.timeline, this[c], this.progress), dd = D.p, _ = D.inverted, cd = O;
            return M < 0 && f === "pending" ? (q === "backwards" || q === "both") && (cd = _ ? P[P.length - 1] : P[0]) : (f !== "pending" && f !== "finished" || q === "forwards" || q === "both") && (cd = (0, y.getCurrentFrame)(this[c], P, this[H], dd)), cd;
          }
        }, {
          key: "timing",
          get: function() {
            return this[c];
          }
        }, {
          key: "effects",
          get: function() {
            return this[H];
          }
        }, {
          key: "baseTimeline",
          set: function(f) {
            this[c].timeline = f;
          },
          get: function() {
            return this[c].timeline;
          }
        }, {
          key: "ready",
          get: function() {
            return this[S] ? this[S].promise : this.timeline && this.timeline.currentTime >= 0 && this.playState !== "paused" ? b.default.resolve() : (this[S] = (0, y.defer)(), this.timeline && this[L](), this[S] ? this[S].promise : b.default.resolve());
          }
        }, {
          key: "finished",
          get: function() {
            return this.playState === "finished" ? b.default.resolve() : (this[J] || (this[J] = (0, y.defer)(), this.timeline && this[C]()), this[J].promise);
          }
        }]), g;
      }();
      l.default = K;
    },
    /* 191 */
    /***/
    function(s, l, d) {
      s.exports = { default: d(192), __esModule: !0 };
    },
    /* 192 */
    /***/
    function(s, l, d) {
      d(143), d(125), d(79), d(193), d(202), d(203), s.exports = d(92).Promise;
    },
    /* 193 */
    /***/
    function(s, l, d) {
      var i = d(89), b = d(91), m = d(93), o = d(128), n = d(90), W = d(98), e = d(94), I = d(147), a = d(148), V = d(194), h = d(195).set, Y = d(197)(), p = d(198), G = d(199), y = d(200), Z = d(201), X = "Promise", c = b.TypeError, t = b.process, R = t && t.versions, S = R && R.v8 || "", J = b[X], H = o(t) == "process", L = function() {
      }, C, F, r, K, g = F = p.f, v = !!function() {
        try {
          var _ = J.resolve(1), cd = (_.constructor = {})[d(122)("species")] = function($) {
            $(L, L);
          };
          return (H || typeof PromiseRejectionEvent == "function") && _.then(L) instanceof cd && S.indexOf("6.6") !== 0 && y.indexOf("Chrome/66") === -1;
        } catch {
        }
      }(), f = function(_) {
        var cd;
        return W(_) && typeof (cd = _.then) == "function" ? cd : !1;
      }, O = function(_, cd) {
        if (!_._n) {
          _._n = !0;
          var $ = _._c;
          Y(function() {
            for (var Wd = _._v, Xd = _._s == 1, k = 0, z = function(E) {
              var j = Xd ? E.ok : E.fail, N = E.resolve, Q = E.reject, u = E.domain, x, T, U;
              try {
                j ? (Xd || (_._h == 2 && P(_), _._h = 1), j === !0 ? x = Wd : (u && u.enter(), x = j(Wd), u && (u.exit(), U = !0)), x === E.promise ? Q(c("Promise-chain cycle")) : (T = f(x)) ? T.call(x, N, Q) : N(x)) : Q(Wd);
              } catch (w) {
                u && !U && u.exit(), Q(w);
              }
            }; $.length > k; )
              z($[k++]);
            _._c = [], _._n = !1, cd && !_._h && q(_);
          });
        }
      }, q = function(_) {
        h.call(b, function() {
          var cd = _._v, $ = M(_), Wd, Xd, k;
          if ($ && (Wd = G(function() {
            H ? t.emit("unhandledRejection", cd, _) : (Xd = b.onunhandledrejection) ? Xd({ promise: _, reason: cd }) : (k = b.console) && k.error && k.error("Unhandled promise rejection", cd);
          }), _._h = H || M(_) ? 2 : 1), _._a = void 0, $ && Wd.e)
            throw Wd.v;
        });
      }, M = function(_) {
        return _._h !== 1 && (_._a || _._c).length === 0;
      }, P = function(_) {
        h.call(b, function() {
          var cd;
          H ? t.emit("rejectionHandled", _) : (cd = b.onrejectionhandled) && cd({ promise: _, reason: _._v });
        });
      }, D = function(_) {
        var cd = this;
        cd._d || (cd._d = !0, cd = cd._w || cd, cd._v = _, cd._s = 2, cd._a || (cd._a = cd._c.slice()), O(cd, !0));
      }, dd = function(_) {
        var cd = this, $;
        if (!cd._d) {
          cd._d = !0, cd = cd._w || cd;
          try {
            if (cd === _)
              throw c("Promise can't be resolved itself");
            ($ = f(_)) ? Y(function() {
              var Wd = { _w: cd, _d: !1 };
              try {
                $.call(_, m(dd, Wd, 1), m(D, Wd, 1));
              } catch (Xd) {
                D.call(Wd, Xd);
              }
            }) : (cd._v = _, cd._s = 1, O(cd, !1));
          } catch (Wd) {
            D.call({ _w: cd, _d: !1 }, Wd);
          }
        }
      };
      v || (J = function(cd) {
        I(this, J, X, "_h"), e(cd), C.call(this);
        try {
          cd(m(dd, this, 1), m(D, this, 1));
        } catch ($) {
          D.call(this, $);
        }
      }, C = function(cd) {
        this._c = [], this._a = void 0, this._s = 0, this._d = !1, this._v = void 0, this._h = 0, this._n = !1;
      }, C.prototype = d(146)(J.prototype, {
        // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
        then: function(cd, $) {
          var Wd = g(V(this, J));
          return Wd.ok = typeof cd == "function" ? cd : !0, Wd.fail = typeof $ == "function" && $, Wd.domain = H ? t.domain : void 0, this._c.push(Wd), this._a && this._a.push(Wd), this._s && O(this, !1), Wd.promise;
        },
        // 25.4.5.1 Promise.prototype.catch(onRejected)
        catch: function(_) {
          return this.then(void 0, _);
        }
      }), r = function() {
        var _ = new C();
        this.promise = _, this.resolve = m(dd, _, 1), this.reject = m(D, _, 1);
      }, p.f = g = function(_) {
        return _ === J || _ === K ? new r(_) : F(_);
      }), n(n.G + n.W + n.F * !v, { Promise: J }), d(121)(J, X), d(149)(X), K = d(92)[X], n(n.S + n.F * !v, X, {
        // 25.4.4.5 Promise.reject(r)
        reject: function(cd) {
          var $ = g(this), Wd = $.reject;
          return Wd(cd), $.promise;
        }
      }), n(n.S + n.F * (i || !v), X, {
        // 25.4.4.6 Promise.resolve(x)
        resolve: function(cd) {
          return Z(i && this === K ? J : this, cd);
        }
      }), n(n.S + n.F * !(v && d(140)(function(_) {
        J.all(_).catch(L);
      })), X, {
        // 25.4.4.1 Promise.all(iterable)
        all: function(cd) {
          var $ = this, Wd = g($), Xd = Wd.resolve, k = Wd.reject, z = G(function() {
            var E = [], j = 0, N = 1;
            a(cd, !1, function(Q) {
              var u = j++, x = !1;
              E.push(void 0), N++, $.resolve(Q).then(function(T) {
                x || (x = !0, E[u] = T, --N || Xd(E));
              }, k);
            }), --N || Xd(E);
          });
          return z.e && k(z.v), Wd.promise;
        },
        // 25.4.4.4 Promise.race(iterable)
        race: function(cd) {
          var $ = this, Wd = g($), Xd = Wd.reject, k = G(function() {
            a(cd, !1, function(z) {
              $.resolve(z).then(Wd.resolve, Xd);
            });
          });
          return k.e && Xd(k.v), Wd.promise;
        }
      });
    },
    /* 194 */
    /***/
    function(s, l, d) {
      var i = d(97), b = d(94), m = d(122)("species");
      s.exports = function(o, n) {
        var W = i(o).constructor, e;
        return W === void 0 || (e = i(W)[m]) == null ? n : b(e);
      };
    },
    /* 195 */
    /***/
    function(s, l, d) {
      var i = d(93), b = d(196), m = d(120), o = d(102), n = d(91), W = n.process, e = n.setImmediate, I = n.clearImmediate, a = n.MessageChannel, V = n.Dispatch, h = 0, Y = {}, p = "onreadystatechange", G, y, Z, X = function() {
        var t = +this;
        if (Y.hasOwnProperty(t)) {
          var R = Y[t];
          delete Y[t], R();
        }
      }, c = function(t) {
        X.call(t.data);
      };
      (!e || !I) && (e = function(R) {
        for (var S = [], J = 1; arguments.length > J; )
          S.push(arguments[J++]);
        return Y[++h] = function() {
          b(typeof R == "function" ? R : Function(R), S);
        }, G(h), h;
      }, I = function(R) {
        delete Y[R];
      }, d(86)(W) == "process" ? G = function(t) {
        W.nextTick(i(X, t, 1));
      } : V && V.now ? G = function(t) {
        V.now(i(X, t, 1));
      } : a ? (y = new a(), Z = y.port2, y.port1.onmessage = c, G = i(Z.postMessage, Z, 1)) : n.addEventListener && typeof postMessage == "function" && !n.importScripts ? (G = function(t) {
        n.postMessage(t + "", "*");
      }, n.addEventListener("message", c, !1)) : p in o("script") ? G = function(t) {
        m.appendChild(o("script"))[p] = function() {
          m.removeChild(this), X.call(t);
        };
      } : G = function(t) {
        setTimeout(i(X, t, 1), 0);
      }), s.exports = {
        set: e,
        clear: I
      };
    },
    /* 196 */
    /***/
    function(s, l) {
      s.exports = function(d, i, b) {
        var m = b === void 0;
        switch (i.length) {
          case 0:
            return m ? d() : d.call(b);
          case 1:
            return m ? d(i[0]) : d.call(b, i[0]);
          case 2:
            return m ? d(i[0], i[1]) : d.call(b, i[0], i[1]);
          case 3:
            return m ? d(i[0], i[1], i[2]) : d.call(b, i[0], i[1], i[2]);
          case 4:
            return m ? d(i[0], i[1], i[2], i[3]) : d.call(b, i[0], i[1], i[2], i[3]);
        }
        return d.apply(b, i);
      };
    },
    /* 197 */
    /***/
    function(s, l, d) {
      var i = d(91), b = d(195).set, m = i.MutationObserver || i.WebKitMutationObserver, o = i.process, n = i.Promise, W = d(86)(o) == "process";
      s.exports = function() {
        var e, I, a, V = function() {
          var G, y;
          for (W && (G = o.domain) && G.exit(); e; ) {
            y = e.fn, e = e.next;
            try {
              y();
            } catch (Z) {
              throw e ? a() : I = void 0, Z;
            }
          }
          I = void 0, G && G.enter();
        };
        if (W)
          a = function() {
            o.nextTick(V);
          };
        else if (m && !(i.navigator && i.navigator.standalone)) {
          var h = !0, Y = document.createTextNode("");
          new m(V).observe(Y, { characterData: !0 }), a = function() {
            Y.data = h = !h;
          };
        } else if (n && n.resolve) {
          var p = n.resolve(void 0);
          a = function() {
            p.then(V);
          };
        } else
          a = function() {
            b.call(i, V);
          };
        return function(G) {
          var y = { fn: G, next: void 0 };
          I && (I.next = y), e || (e = y, a()), I = y;
        };
      };
    },
    /* 198 */
    /***/
    function(s, l, d) {
      var i = d(94);
      function b(m) {
        var o, n;
        this.promise = new m(function(W, e) {
          if (o !== void 0 || n !== void 0)
            throw TypeError("Bad Promise constructor");
          o = W, n = e;
        }), this.resolve = i(o), this.reject = i(n);
      }
      s.exports.f = function(m) {
        return new b(m);
      };
    },
    /* 199 */
    /***/
    function(s, l) {
      s.exports = function(d) {
        try {
          return { e: !1, v: d() };
        } catch (i) {
          return { e: !0, v: i };
        }
      };
    },
    /* 200 */
    /***/
    function(s, l, d) {
      var i = d(91), b = i.navigator;
      s.exports = b && b.userAgent || "";
    },
    /* 201 */
    /***/
    function(s, l, d) {
      var i = d(97), b = d(98), m = d(198);
      s.exports = function(o, n) {
        if (i(o), b(n) && n.constructor === o)
          return n;
        var W = m.f(o), e = W.resolve;
        return e(n), W.promise;
      };
    },
    /* 202 */
    /***/
    function(s, l, d) {
      var i = d(90), b = d(92), m = d(91), o = d(194), n = d(201);
      i(i.P + i.R, "Promise", { finally: function(W) {
        var e = o(this, b.Promise || m.Promise), I = typeof W == "function";
        return this.then(
          I ? function(a) {
            return n(e, W()).then(function() {
              return a;
            });
          } : W,
          I ? function(a) {
            return n(e, W()).then(function() {
              throw a;
            });
          } : W
        );
      } });
    },
    /* 203 */
    /***/
    function(s, l, d) {
      var i = d(90), b = d(198), m = d(199);
      i(i.S, "Promise", { try: function(o) {
        var n = b.f(this), W = m(o);
        return (W.e ? n.reject : n.resolve)(W.v), n.promise;
      } });
    },
    /* 204 */
    /***/
    function(s, l, d) {
      s.exports = { default: d(205), __esModule: !0 };
    },
    /* 205 */
    /***/
    function(s, l, d) {
      d(206), s.exports = d(92).Object.keys;
    },
    /* 206 */
    /***/
    function(s, l, d) {
      var i = d(124), b = d(110);
      d(207)("keys", function() {
        return function(o) {
          return b(i(o));
        };
      });
    },
    /* 207 */
    /***/
    function(s, l, d) {
      var i = d(90), b = d(92), m = d(101);
      s.exports = function(o, n) {
        var W = (b.Object || {})[o] || Object[o], e = {};
        e[o] = n(W), i(i.S + i.F * m(function() {
          W(1);
        }), "Object", e);
      };
    },
    /* 208 */
    /***/
    function(s, l, d) {
      Object.defineProperty(l, "__esModule", {
        value: !0
      });
      var i = d(76), b = Y(i), m = d(209), o = Y(m), n = d(164), W = Y(n), e = d(191), I = Y(e);
      l.defer = p, l.periodicity = G, l.calculateFramesOffset = y, l.getProgress = Z, l.getCurrentFrame = c;
      var a = d(188), V = d(187), h = Y(V);
      function Y(t) {
        return t && t.__esModule ? t : { default: t };
      }
      function p() {
        var t = {};
        return t.promise = new I.default(function(R, S) {
          t.resolve = R, t.reject = S;
        }), t;
      }
      function G(t, R) {
        var S = Math.floor(t / R), J = t - S * R;
        return J === 0 && S > 0 && (J = R, S--), [S, J];
      }
      function y(t) {
        t = t.slice(0);
        var R = t[0], S = t[t.length - 1];
        S.offset = S.offset || 1, R.offset = R.offset || 0;
        for (var J = 0, H = -1, L = 0; L < t.length; L++) {
          var C = t[L];
          if (C.offset != null) {
            var F = L - H;
            if (F > 1)
              for (var r = (C.offset - J) / F, K = 0; K < F - 1; K++)
                t[H + K + 1].offset = J + r * (K + 1);
            J = C.offset, H = L;
          }
          if (C.easing != null && (C.easing = (0, a.parseEasing)(C.easing)), L > 0) {
            var g = t[L].easing != null;
            t[L] = (0, W.default)({}, t[L - 1], t[L]), g || delete t[L].easing;
          }
        }
        return t;
      }
      function Z(t, R, S) {
        var J = t.currentTime, H = R.direction, L = R.duration, C = !1;
        if (H === "reverse")
          S = 1 - S, C = !0;
        else if (H === "alternate" || H === "alternate-reverse") {
          var F = Math.floor(J / L);
          S === 1 && F--, F % 2 ^ H === "alternate-reverse" && (S = 1 - S, C = !0);
        }
        return { p: S, inverted: C };
      }
      function X(t, R, S, J) {
        var H = {};
        return (0, o.default)(R).forEach(function(L) {
          var C = (0, b.default)(L, 2), F = C[0], r = C[1];
          if (F !== "offset" && F !== "easing") {
            var K = S[F] || S.default, g = K(t[F], r, J, t.offset, R.offset);
            g != null && (H[F] = g);
          }
        }), H;
      }
      function c(t, R, S, J) {
        var H = t.easing, L = t.effect;
        L || (S = (0, W.default)({}, h.default, S));
        var C = {};
        J = H(J, R);
        for (var F = 1; F < R.length; F++) {
          var r = R[F], K = r.offset;
          if (K >= J || F === R.length - 1) {
            var g = R[F - 1], v = g.offset, f = g.easing, O = J;
            if (f) {
              var q = K - v;
              O = f((J - v) / q) * q + v;
            }
            L ? C = L(g, r, O, v, K) : C = X(g, r, S, O);
            break;
          }
        }
        return C;
      }
    },
    /* 209 */
    /***/
    function(s, l, d) {
      s.exports = { default: d(210), __esModule: !0 };
    },
    /* 210 */
    /***/
    function(s, l, d) {
      d(211), s.exports = d(92).Object.entries;
    },
    /* 211 */
    /***/
    function(s, l, d) {
      var i = d(90), b = d(212)(!0);
      i(i.S, "Object", {
        entries: function(o) {
          return b(o);
        }
      });
    },
    /* 212 */
    /***/
    function(s, l, d) {
      var i = d(100), b = d(110), m = d(84), o = d(169).f;
      s.exports = function(n) {
        return function(W) {
          for (var e = m(W), I = b(e), a = I.length, V = 0, h = [], Y; a > V; )
            Y = I[V++], (!i || o.call(e, Y)) && h.push(n ? [Y, e[Y]] : e[Y]);
          return h;
        };
      };
    },
    /* 213 */
    /***/
    function(s, l, d) {
      d.r(l), d(1).glMatrix.setMatrixArrayType(Array);
      const i = /* @__PURE__ */ new Map();
      function b(o, n = {}, W = []) {
        o = o.toLowerCase();
        const e = i.get(o);
        if (!e)
          throw new TypeError(`Invalid node: ${o}`);
        const I = new e(n);
        return W.forEach((a) => {
          I.appendChild(a);
        }), I;
      }
      const m = {
        registerNode(o, n, W = 100) {
          if (n = n.toLowerCase(), i.has(n))
            throw new TypeError(`Cannot registerNode, ${n} has been taken.`);
          i.set(n, o), Object.defineProperties(o.prototype, {
            nodeType: {
              value: W
            },
            tagName: {
              value: n.toUpperCase()
            },
            nodeName: {
              value: n
            },
            ownerDocument: {
              value: m
            },
            namespaceURI: {
              value: `http://spritejs.com/${n}`
            }
          });
        },
        createElement: b,
        createElementNS(o, n) {
          return b(n);
        },
        isSpriteNode(o) {
          return i.has(o.toLowerCase());
        }
      };
      l.default = m;
    },
    /* 214 */
    /***/
    function(s, l, d) {
      d.r(l), d.d(l, "default", function() {
        return n;
      }), d(1).glMatrix.setMatrixArrayType(Array);
      const i = Symbol("type"), b = Symbol("bubbles"), m = Symbol("originalEvent"), o = Symbol("detail");
      class n {
        constructor(e, {
          bubbles: I = null
        } = {}) {
          if (typeof e == "string" ? (this[i] = e, this[b] = !!I) : (this[i] = e.type, this[m] = e, this[b] = I != null ? !!I : !!e.bubbles, e.detail && (this[o] = e.detail)), !this[i])
            throw new TypeError("Invalid event type.");
          this.cancelBubble = !1;
        }
        setOriginalEvent(e) {
          this[m] = e;
        }
        get originalEvent() {
          return this[m];
        }
        get type() {
          return this[i];
        }
        get bubbles() {
          return this[b];
        }
        get detail() {
          return this[o];
        }
        stopPropagation() {
          this.cancelBubble = !0;
        }
      }
    },
    /* 215 */
    /***/
    function(s, l, d) {
      d.r(l), d.d(l, "parseFilterString", function() {
        return b;
      }), d.d(l, "applyFilters", function() {
        return m;
      });
      var i = d(72);
      d(1).glMatrix.setMatrixArrayType(Array);
      function b(o) {
        if (o = o.trim(), !o || o === "none")
          return null;
        const n = /^(?:(url|blur|brightness|contrast|drop-shadow|grayscale|hue-rotate|invert|opacity|saturate|sepia)\(([^()]*(?:\(.*\))*[^()]*)\))+$/i, W = o.match(/(?:(url|blur|brightness|contrast|drop-shadow|grayscale|hue-rotate|invert|opacity|saturate|sepia)\(([^()]*(?:\(.*\))*[^()]*)\))+?/ig), e = [];
        return W && W.forEach((I) => {
          const a = I.match(n);
          if (!a)
            throw new TypeError("Invalid fitler string.");
          let [, V, h] = a;
          V = V.toLowerCase(), h = h.trim().match(/([^( )]+|([^( )]+\(.*\)))(?=\s|$)/g).map((Y, p) => {
            let G;
            return V === "url" || V === "drop-shadow" && p === 3 ? G = Y : G = Object(i.toNumber)(Y), /%$/.test(Y) && (G /= 100), G;
          }), e.push({
            type: V,
            args: h
          });
        }), e;
      }
      function m(o, n) {
        o.clearFilter(), n && n.forEach(({
          type: W,
          args: e
        }) => {
          let I = W;
          I === "drop-shadow" ? I = "dropShadow" : I === "hue-rotate" && (I = "hueRotate"), o[I](...e);
        });
      }
    },
    /* 216 */
    /***/
    function(s, l, d) {
      d.r(l), d.d(l, "default", function() {
        return i;
      }), d(1).glMatrix.setMatrixArrayType(Array);
      function i(b, m) {
        if (!m)
          return;
        const o = b.getListeners("beforerender"), n = b.getListeners("afterrender");
        o.length && !m.beforeRender ? m.beforeRender = (W) => {
          b.dispatchEvent({
            type: "beforerender",
            detail: {
              context: W
            }
          });
        } : o.length || (m.beforeRender = null), n.length && !m.afterRender ? m.afterRender = (W) => {
          b.dispatchEvent({
            type: "afterrender",
            detail: {
              context: W
            }
          });
        } : n.length || (m.afterRender = null);
      }
    },
    /* 217 */
    /***/
    function(s, l, d) {
      d.r(l), d.d(l, "default", function() {
        return e;
      });
      var i = d(12), b = d(218), m = d(70), o = d(213);
      d(1).glMatrix.setMatrixArrayType(Array);
      const n = Symbol("amount"), W = Symbol("meshCloud");
      class e extends m.default {
        constructor(a, V = 1) {
          super(), this.meshNode = a, a.connect(this), this[n] = V, this[W] = null;
        }
        get meshCloud() {
          const a = this.meshNode, V = this[n];
          return !this[W] && a.mesh && (this[W] = new i.MeshCloud(a.mesh, V)), this[W];
        }
        /* override */
        get isVisible() {
          return !!this.meshNode && this.meshNode.isVisible;
        }
        get amount() {
          return this[n];
        }
        set amount(a) {
          this[n] = a, this[W] && (this[W].amount = a);
        }
        brightness(a, V) {
          this.meshCloud && (this.meshCloud.brightness(a, V), this.forceUpdate());
        }
        contrast(a, V) {
          this.meshCloud && (this.meshCloud.contrast(a, V), this.forceUpdate());
        }
        delete(a) {
          this.meshCloud && (this.meshCloud.delete(a), this[n]--, this.forceUpdate());
        }
        /* override */
        draw(a = []) {
          if (super.draw(a), this.meshCloud) {
            if (this.program) {
              this.meshCloud.setProgram(this.program);
              const V = this.shaderAttrs;
              V && Object.entries(V).forEach(([Y, p]) => {
                this.meshCloud.mesh.setAttribute(Y, p);
              });
              const h = this.uniforms;
              if (this.uniforms) {
                const Y = {};
                Object.entries(h).forEach(([p, G]) => {
                  typeof G == "function" && (G = G(this, p)), Y[p] = G;
                }), this.meshCloud.mesh.setUniforms(Y);
              }
            }
            this.meshNode.textureImage && Object(b.drawTexture)(this.meshNode, this.meshNode.mesh), a.push(this.meshCloud);
          }
          return a;
        }
        getTransform(a) {
          if (this.meshCloud)
            return this.meshCloud.getTransform(a);
        }
        grayscale(a, V) {
          this.meshCloud && (this.meshCloud.grayscale(a, V), this.forceUpdate());
        }
        hueRotate(a, V) {
          this.meshCloud && (this.meshCloud.hueRotate(a, V), this.forceUpdate());
        }
        invert(a, V) {
          this.meshCloud && (this.meshCloud.invert(a, V), this.forceUpdate());
        }
        /* override */
        isPointCollision(a, V) {
          if (!this.meshCloud)
            return !1;
          const h = this.attributes.pointerEvents;
          if (h === "none" || h !== "all" && !this.isVisible)
            return !1;
          let Y = "both";
          h === "visibleFill" && (Y = "fill"), h === "visibleStroke" && (Y = "stroke");
          for (let p = 0; p < this[n]; p++)
            if (!this.meshCloud.isPointCollision(p, [a, V], Y))
              return !1;
          return !0;
        }
        setOpacity(a, V) {
          this.meshCloud && (this.meshCloud.opacity(a, V), this.forceUpdate());
        }
        rotate(a, V, [h, Y] = [0, 0]) {
          const p = Math.PI * V / 180;
          if (this.meshCloud) {
            const {
              x: G,
              y
            } = this.meshNode.attributes;
            this.meshCloud.rotate(a, p, [h + G, Y + y]), this.forceUpdate();
          }
        }
        saturate(a, V) {
          this.meshCloud && (this.meshCloud.saturate(a, V), this.forceUpdate());
        }
        scale(a, [V, h = V], [Y, p] = [0, 0]) {
          if (this.meshCloud) {
            const {
              x: G,
              y
            } = this.meshNode.attributes, Z = 1e-5;
            Math.abs(V) < Z && (V = 1 / V > 0 ? Z : -Z), Math.abs(h) < Z && (h = 1 / h > 0 ? Z : -Z), this.meshCloud.scale(a, [V, h], [Y + G, p + y]), this.forceUpdate();
          }
        }
        setColorTransform(a, V) {
          this.meshCloud && (this.meshCloud.setColorTransform(a, V), this.forceUpdate());
        }
        setFillColor(a, V) {
          this.meshCloud && (Array.isArray(V) && (V = [...V], V[0] /= 255, V[1] /= 255, V[2] /= 255), this.meshCloud.setFillColor(a, V), this.forceUpdate());
        }
        sepia(a, V) {
          this.meshCloud && (this.meshCloud.sepia(a, V), this.forceUpdate());
        }
        /* override */
        setResolution({
          width: a,
          height: V
        }) {
          super.setResolution({
            width: a,
            height: V
          }), this.meshNode.setResolution({
            width: a,
            height: V
          });
        }
        setStrokeColor(a, V) {
          this.meshCloud && (Array.isArray(V) && (V = [...V], V[0] /= 255, V[1] /= 255, V[2] /= 255), this.meshCloud.setStrokeColor(a, V), this.forceUpdate());
        }
        setTransform(a, V) {
          this.meshCloud && (this.meshCloud.setTransform(a, V), this.forceUpdate());
        }
        skew(a, [V, h = V], [Y, p] = [0, 0]) {
          if (this.meshCloud) {
            const {
              x: G,
              y
            } = this.meshNode.attributes;
            this.meshCloud.skew(a, [V, h], [Y + G, p + y]), this.forceUpdate();
          }
        }
        transform(a, V) {
          this.meshCloud && (this.meshCloud.transform(a, V), this.forceUpdate());
        }
        transformColor(a, V) {
          this.meshCloud && (this.meshCloud.transformColor(a, V), this.forceUpdate());
        }
        translate(a, [V, h]) {
          this.meshCloud && (this.meshCloud.translate(a, [V, h]), this.forceUpdate());
        }
        updateMesh() {
          this[W] && (this[W].mesh = this.meshNode.mesh, this.forceUpdate());
        }
      }
      o.default.registerNode(e, "cloud");
    },
    /* 218 */
    /***/
    function(s, l, d) {
      d.r(l), d.d(l, "loadTexture", function() {
        return o;
      }), d.d(l, "applyTexture", function() {
        return n;
      }), d.d(l, "createTexture", function() {
        return e;
      }), d.d(l, "deleteTexture", function() {
        return I;
      }), d.d(l, "drawTexture", function() {
        return V;
      }), d.d(l, "loadFrames", function() {
        return h;
      });
      var i = d(12), b = d(72);
      d(1).glMatrix.setMatrixArrayType(Array);
      const m = {};
      function o(Y, p) {
        if (m[Y])
          return m[Y];
        const G = i.ENV.loadImage(Y, {
          alias: p,
          useImageBitmap: !1
        });
        return G ?? Y;
      }
      async function n(Y, p, G) {
        let y = p;
        if (typeof p == "string" && (y = o(p)), y && typeof y.then == "function" && (y = await y), p === Y.attributes.texture) {
          y && y.image && (y.sourceRect && (Y.attributes.sourceRect = y.sourceRect), Y.textureImageRotated = !!y.rotated, y = y.image);
          const {
            width: Z,
            height: X,
            textureRect: c
          } = Y.attributes, t = Y.textureImage;
          Y.textureImage = y, G && t !== y && !c && (Z == null || X == null) && Y.updateContours(), Y.forceUpdate();
        }
        return y;
      }
      const W = Symbol("textureMap");
      function e(Y, p) {
        if (p[W] = p[W] || /* @__PURE__ */ new Map(), p[W].has(Y))
          return p[W].get(Y);
        const G = p.createTexture(Y);
        return !/^blob:/.test(Y.src) && typeof Y.getContext != "function" && p[W].set(Y, G), G;
      }
      function I(Y, p) {
        if (p[W] && p[W].has(Y)) {
          const G = p[W].get(Y);
          return p.deleteTexture(G), p[W].delete(Y), !0;
        }
        return !1;
      }
      const a = Symbol("textureContext");
      function V(Y, p) {
        const G = Y.textureImage instanceof String ? String(Y.textureImage) : Y.textureImage, y = Y.textureImageRotated, Z = p.texture, X = Y.renderer;
        if (G) {
          const c = Y.originalContentRect;
          let t = Y.attributes.textureRect;
          const R = Y.attributes.textureRepeat, S = Y.attributes.sourceRect;
          if (!Z || Y[a] && Y[a] !== X || Z.image !== G || Z.options.repeat !== R || !Object(b.compareValue)(Z.options.rect, t) || !Object(b.compareValue)(Z.options.srcRect, S)) {
            const J = e(G, X);
            t ? (t[0] += c[0], t[1] += c[1]) : t = c;
            let H = null;
            Z && !X[W].has(Z.image) && (!Z.options || !Z.options.hidden) && (H = p.uniforms.u_texSampler), p.setTexture(J, {
              rect: t,
              repeat: R,
              srcRect: S,
              rotated: y
            }), H && H.delete && H.delete(), Y[a] = X;
          }
        } else if (Z) {
          let c = null;
          !X[W].has(Z.image) && (!Z.options || !Z.options.hidden) && (c = p.uniforms.u_texSampler), p.setTexture(null), c && c.delete && c.delete();
        }
      }
      async function h(Y, p) {
        typeof p == "string" && (p = await (await fetch(p, {
          method: "GET",
          mode: "cors",
          cache: "default"
        })).json());
        const G = await o(Y), y = p.frames;
        return Object.entries(y).forEach(([Z, X]) => {
          const {
            x: c,
            y: t,
            w: R,
            h: S
          } = X.frame;
          let J = [c, t, R, S];
          const H = X.rotated;
          H && (J = [J[0], J[1], J[3], J[2]]), m[Z] = {
            image: G,
            sourceRect: J,
            rotated: H
          };
        }), G;
      }
    },
    /* 219 */
    /***/
    function(s, l, d) {
      d.r(l), d.d(l, "default", function() {
        return h;
      });
      var i = d(1), b = d(12), m = d(70), o = d(220), n = d(221), W = d(222), e = d(213), I = d(223);
      d(1).glMatrix.setMatrixArrayType(Array);
      function a(Y, p, G) {
        return p in Y ? Object.defineProperty(Y, p, { value: G, enumerable: !0, configurable: !0, writable: !0 }) : Y[p] = G, Y;
      }
      const V = Symbol("mesh");
      class h extends m.default {
        constructor(p = {}) {
          super(p);
        }
        get borderSize() {
          const {
            paddingTop: p,
            paddingRight: G,
            paddingBottom: y,
            paddingLeft: Z,
            borderWidth: X
          } = this.attributes, [c, t] = this.contentSize;
          return [Z + c + G + X, p + t + y + X];
        }
        // content + padding
        get clientSize() {
          const {
            paddingTop: p,
            paddingRight: G,
            paddingBottom: y,
            paddingLeft: Z
          } = this.attributes, [X, c] = this.contentSize;
          return [Z + X + G, p + c + y];
        }
        get contentSize() {
          let {
            width: p,
            height: G,
            boxSizing: y,
            paddingTop: Z,
            paddingRight: X,
            paddingBottom: c,
            paddingLeft: t
          } = this.attributes;
          if (p = p || 0, G = G || 0, y === "border-box") {
            const R = 2 * this.attributes.borderWidth;
            p -= R + X + t, G -= R + Z + c, p = Math.max(0, p), G = Math.max(0, G);
          }
          return [p, G];
        }
        get hasBorder() {
          return this.attributes.borderWidth > 0;
        }
        /* override */
        get isVisible() {
          const [p, G] = this.borderSize;
          return p > 0 && G > 0;
        }
        get mesh() {
          if (this.attributes.display === "none")
            return null;
          const p = this.clientBox;
          if (p) {
            let G = this[V];
            if (G)
              G.box !== p && (G.contours = p.contours, G.box = p);
            else {
              G = new b.Mesh2D(p), G.box = p;
              const Z = this.attributes.bgcolor;
              if (Object(n.setFillColor)(G, {
                color: Z
              }), this.hasBorder) {
                const {
                  borderColor: c,
                  borderWidth: t,
                  borderDash: R,
                  borderDashOffset: S
                } = this.attributes;
                Object(n.setStrokeColor)(G, {
                  color: c,
                  lineWidth: t,
                  lineDash: R,
                  lineDashOffset: S
                });
              }
              this[V] = G;
              const X = this.attributes.clipPath;
              X && this[V].setClipPath(X);
            }
            const y = this.opacity;
            return G.getOpacity() !== y && G.setOpacity(y), G.setTransform(...this.renderMatrix), G;
          }
          return null;
        }
        // content + padding + border
        get offsetSize() {
          const {
            paddingTop: p,
            paddingRight: G,
            paddingBottom: y,
            paddingLeft: Z,
            borderWidth: X
          } = this.attributes, [c, t] = this.contentSize, R = 2 * X;
          return [Z + c + G + R, p + t + y + R];
        }
        get originalClientRect() {
          if (this.mesh) {
            const p = this.mesh.boundingBox;
            return [p[0][0], p[0][1], p[1][0] - p[0][0], p[1][1] - p[0][1]];
          }
          return [0, 0, 0, 0];
        }
        get originalContentRect() {
          const [p, G, y, Z] = this.originalClientRect, X = this.attributes.padding;
          return [p + X[0], G + X[1], y - X[0] - X[2], Z - X[1] - X[3]];
        }
        getBoundingClientRect() {
          let p = this.renderMatrix;
          this.layer && this.layer.layerTransformInvert && (p = i.mat2d.multiply(Array.of(0, 0, 0, 0, 0, 0), this.layer.transformMatrix, p));
          let G = null;
          if (this.mesh) {
            G = [...this.mesh.boundingBox];
            const y = this.attributes.borderWidth;
            y && (G[0] = [G[0][0] - y, G[0][1] - y], G[1] = [G[1][0] + y, G[1][1] + y]);
          }
          return Object(I.default)(G, p);
        }
        // transformPoint(x, y) {
        //   const m = mat2d.invert(this.renderMatrix);
        //   const newX = x * m[0] + y * m[2] + m[4];
        //   const newY = x * m[1] + y * m[3] + m[5];
        //   return [newX, newY];
        // }
        /* override */
        onPropertyChange(p, G, y) {
          if (super.onPropertyChange(p, G, y), (p === "anchorX" || p === "anchorY" || p === "boxSizing" || p === "width" || p === "height" || p === "borderWidth" || p === "paddingLeft" || p === "paddingRight" || p === "paddingTop" || p === "paddingBottom" || /^border(TopLeft|TopRight|BottomRight|BottomLeft)Radius$/.test(p)) && this.updateContours(), this[V] && p === "clipPath" && this[V].setClipPath(G), this[V] && p === "bgcolor" && Object(n.setFillColor)(this[V], {
            color: G
          }), this[V] && (p === "borderColor" || p === "borderWidth" || p === "borderDash" || p === "borderDashOffset")) {
            const {
              borderColor: Z,
              borderWidth: X,
              borderDash: c,
              borderDashOffset: t
            } = this.attributes;
            Object(n.setStrokeColor)(this[V], {
              color: Z,
              lineWidth: X,
              lineDash: X ? c : 0,
              lineDashOffset: t
            });
          }
        }
        /* override */
        updateContours() {
          const {
            anchorX: p,
            anchorY: G,
            borderWidth: y,
            borderRadius: Z
          } = this.attributes, [X, c] = this.borderSize, t = this.offsetSize, R = 0.5 * y, S = -p * t[0] + R, J = -G * t[1] + R;
          this.clientBox = new b.Figure2D(), Object(W.createRadiusBox)(this.clientBox, [S, J, X, c], Z);
        }
      }
      a(h, "Attr", o.default), e.default.registerNode(h, "block");
    },
    /* 220 */
    /***/
    function(s, l, d) {
      d.r(l), d.d(l, "default", function() {
        return I;
      });
      var i = d(71), b = d(72), m = d(221);
      d(1).glMatrix.setMatrixArrayType(Array);
      const o = Symbol.for("spritejs_setAttribute"), n = Symbol.for("spritejs_getAttribute"), W = Symbol.for("spritejs_setAttributeDefault"), e = Symbol.for("spritejs_declareAlias");
      class I extends i.default {
        constructor(V) {
          super(V), this[W]({
            anchorX: 0,
            anchorY: 0,
            /* anchor */
            width: void 0,
            height: void 0,
            /* size */
            borderWidth: 0,
            borderColor: "rgba(0,0,0,1)",
            /* border */
            borderDash: void 0,
            borderDashOffset: 0,
            borderTopLeftRadius: [0, 0],
            borderTopRightRadius: [0, 0],
            borderBottomRightRadius: [0, 0],
            borderBottomLeftRadius: [0, 0],
            /* borderRadius */
            bgcolor: "rgba(0,0,0,0)",
            paddingTop: 0,
            paddingRight: 0,
            paddingBottom: 0,
            paddingLeft: 0,
            /* padding */
            boxSizing: "content-box",
            clipPath: void 0
          }), this[e]("anchor", "size", "border", "borderRadius", "padding");
        }
        get anchorX() {
          return this[n]("anchorX");
        }
        set anchorX(V) {
          this[o]("anchorX", Object(b.toNumber)(V));
        }
        get anchorY() {
          return this[n]("anchorY");
        }
        set anchorY(V) {
          this[o]("anchorY", Object(b.toNumber)(V));
        }
        get anchor() {
          return [this.anchorX, this.anchorY];
        }
        set anchor(V) {
          V = Object(b.toArray)(V), Array.isArray(V) || (V = [V, V]), this.anchorX = V[0], this.anchorY = V[1];
        }
        get width() {
          return this[n]("width");
        }
        set width(V) {
          this[o]("width", Object(b.toNumber)(V));
        }
        get height() {
          return this[n]("height");
        }
        set height(V) {
          this[o]("height", Object(b.toNumber)(V));
        }
        get size() {
          return [this.width, this.height];
        }
        set size(V) {
          V = Object(b.toArray)(V), Array.isArray(V) || (V = [V, V]), this.width = V[0], this.height = V[1];
        }
        get borderWidth() {
          return this[n]("borderWidth");
        }
        set borderWidth(V) {
          this[o]("borderWidth", Object(b.toNumber)(V));
        }
        get borderColor() {
          return this[n]("borderColor");
        }
        set borderColor(V) {
          this[o]("borderColor", Object(m.parseColor)(V));
        }
        get border() {
          return [this.borderWidth, this.borderColor];
        }
        set border(V) {
          V = Object(b.toArray)(V), Array.isArray(V) || (V = [V]), this.borderWidth = V[0], V[1] != null && (this.borderColor = V[1]);
        }
        get borderDash() {
          return this[n]("borderDash");
        }
        set borderDash(V) {
          V = Object(b.toArray)(V, !0), V != null && !Array.isArray(V) && (V = [V]), this[o]("borderDash", V ? V.map(b.toNumber) : null);
        }
        get borderDashOffset() {
          return this[n]("borderDashOffset");
        }
        set borderDashOffset(V) {
          this[o]("borderDashOffset", Object(b.toNumber)(V));
        }
        get borderTopLeftRadius() {
          return this[n]("borderTopLeftRadius");
        }
        set borderTopLeftRadius(V) {
          V = Object(b.toArray)(V, !0), Array.isArray(V) || (V = [V, V]), this[o]("borderTopLeftRadius", V.map(b.toNumber));
        }
        get borderTopRightRadius() {
          return this[n]("borderTopRightRadius");
        }
        set borderTopRightRadius(V) {
          V = Object(b.toArray)(V, !0), Array.isArray(V) || (V = [V, V]), this[o]("borderTopRightRadius", V.map(b.toNumber));
        }
        get borderBottomRightRadius() {
          return this[n]("borderBottomRightRadius");
        }
        set borderBottomRightRadius(V) {
          V = Object(b.toArray)(V, !0), Array.isArray(V) || (V = [V, V]), this[o]("borderBottomRightRadius", V.map(b.toNumber));
        }
        get borderBottomLeftRadius() {
          return this[n]("borderBottomLeftRadius");
        }
        set borderBottomLeftRadius(V) {
          V = Object(b.toArray)(V, !0), Array.isArray(V) || (V = [V, V]), this[o]("borderBottomLeftRadius", V.map(b.toNumber));
        }
        get borderRadius() {
          return [...this.borderTopLeftRadius, ...this.borderTopRightRadius, ...this.borderBottomRightRadius, ...this.borderBottomLeftRadius];
        }
        set borderRadius(V) {
          if (V = Object(b.toArray)(V), !Array.isArray(V))
            V = Array(8).fill(V);
          else if (V.length === 2)
            V = [V[0], V[1], V[0], V[1], V[0], V[1], V[0], V[1]];
          else if (V.length === 4)
            V = [V[0], V[1], V[2], V[3], V[0], V[1], V[2], V[3]];
          else if (V.length === 6)
            V = [V[0], V[1], V[2], V[3], V[4], V[5], V[2], V[3]];
          else if (V.length !== 8)
            throw new TypeError("Invalid borderRadius value.");
          this.borderTopLeftRadius = [V[0], V[1]], this.borderTopRightRadius = [V[2], V[3]], this.borderBottomRightRadius = [V[4], V[5]], this.borderBottomLeftRadius = [V[6], V[7]];
        }
        get bgcolor() {
          return this[n]("bgcolor");
        }
        set bgcolor(V) {
          this[o]("bgcolor", Object(m.parseColor)(V));
        }
        get paddingTop() {
          return this[n]("paddingTop");
        }
        set paddingTop(V) {
          this[o]("paddingTop", Object(b.toNumber)(V));
        }
        get paddingRight() {
          return this[n]("paddingRight");
        }
        set paddingRight(V) {
          this[o]("paddingRight", Object(b.toNumber)(V));
        }
        get paddingBottom() {
          return this[n]("paddingBottom");
        }
        set paddingBottom(V) {
          this[o]("paddingBottom", Object(b.toNumber)(V));
        }
        get paddingLeft() {
          return this[n]("paddingLeft");
        }
        set paddingLeft(V) {
          this[o]("paddingLeft", Object(b.toNumber)(V));
        }
        get padding() {
          return [this.paddingTop, this.paddingRight, this.paddingBottom, this.paddingLeft];
        }
        set padding(V) {
          V = Object(b.toArray)(V), Array.isArray(V) ? V.length === 2 ? V = [V[0], V[1], V[0], V[1]] : V.length === 3 && (V = [V[0], V[1], V[2], V[1]]) : V = [V, V, V, V], this.paddingTop = V[0], this.paddingRight = V[1], this.paddingBottom = V[2], this.paddingLeft = V[3];
        }
        get clipPath() {
          return this[n]("clipPath");
        }
        set clipPath(V) {
          this[o]("clipPath", V);
        }
        get boxSizing() {
          return this[n]("boxSizing");
        }
        set boxSizing(V) {
          if (V != null && V !== "border-box" && V !== "content-box")
            throw new TypeError("Invalid boxSizing type.");
          this[o]("boxSizing", V);
        }
      }
    },
    /* 221 */
    /***/
    function(s, l, d) {
      d.r(l), d.d(l, "Gradient", function() {
        return m;
      }), d.d(l, "isTransparent", function() {
        return o;
      }), d.d(l, "parseColor", function() {
        return n;
      }), d.d(l, "setFillColor", function() {
        return e;
      }), d.d(l, "setStrokeColor", function() {
        return I;
      }), d.d(l, "Color", function() {
        return a;
      });
      var i = d(32), b = /* @__PURE__ */ d.n(i);
      d(1).glMatrix.setMatrixArrayType(Array);
      class m {
        constructor({
          vector: h,
          colors: Y
        }) {
          if (!Array.isArray(h) || h.length !== 4 && h.length !== 6 && h.length !== 3)
            throw new TypeError("Invalid gradient");
          this.vector = h, this.colors = Y.map(({
            offset: p,
            color: G
          }) => ({
            offset: p,
            color: n(G)
          }));
        }
        toString() {
          return JSON.stringify({
            vector: this.vector,
            colors: this.colors
          });
        }
      }
      function o(V) {
        return V instanceof m ? !1 : V == null ? !0 : b()(V)[3] === 0;
      }
      function n(V) {
        if (V == null || (V || (V = "transparent"), V instanceof m))
          return V;
        const h = b()(V);
        if (!h || !h.length)
          throw new TypeError("Invalid color value.");
        return `rgba(${h.join()})`;
      }
      function W(V, h, Y) {
        const p = V.boundingBox[0];
        if (Y.vector) {
          let {
            vector: G,
            colors: y
          } = Y;
          G.length === 4 ? (G = [G[0] + p[0], G[1] + p[1], G[2] + p[0], G[3] + p[1]], V.setLinearGradient({
            vector: G,
            colors: y,
            type: h
          })) : G.length === 3 ? (G = [G[0] + p[0], G[1] + p[1], G[2]], V.setCircularGradient({
            vector: G,
            colors: y,
            type: h
          })) : (G = [G[0] + p[0], G[1] + p[1], G[2], G[3] + p[0], G[4] + p[1], G[5]], V.setRadialGradient({
            vector: G,
            colors: y,
            type: h
          }));
        } else
          V.gradient && V.gradient[h] && (delete V.gradient[h], delete V.uniforms.u_radialGradientVector);
      }
      function e(V, {
        color: h,
        rule: Y = "nonzero"
      }) {
        return W(V, "fill", h), h.vector || V.setFill({
          color: h,
          rule: Y
        }), V;
      }
      function I(V, {
        color: h,
        lineWidth: Y,
        lineCap: p,
        lineJoin: G,
        lineDash: y,
        lineDashOffset: Z,
        miterLimit: X,
        roundSegments: c
      }) {
        W(V, "stroke", h), h.vector && (h = [0, 0, 0, 1]), V.setStroke({
          color: h,
          thickness: Y,
          cap: p,
          join: G,
          miterLimit: X,
          lineDash: y,
          lineDashOffset: Z,
          roundSegments: c
        });
      }
      class a extends Array {
        constructor(h = 0, Y = 0, p = 0, G = 0) {
          return Array.isArray(h) && ([h, Y, p, G] = h), typeof h == "string" && ([h, Y, p, G] = b()(h), h /= 255, Y /= 255, p /= 255), super(h, Y, p, G), this;
        }
        get r() {
          return Math.round(this[0] * 255);
        }
        set r(h) {
          this[0] = h / 255;
        }
        get g() {
          return Math.round(this[1] * 255);
        }
        set g(h) {
          this[1] = h / 255;
        }
        get b() {
          return Math.round(this[2] * 255);
        }
        set b(h) {
          this[2] = h / 255;
        }
        get a() {
          return this[3];
        }
        set a(h) {
          this[3] = h;
        }
        get hex() {
          const h = `0${this.r.toString(16)}`.slice(-2), Y = `0${this.g.toString(16)}`.slice(-2), p = `0${this.b.toString(16)}`.slice(-2);
          let G;
          return this.a < 1 && (G = Math.round(this[3] * 255), G = `0${G.toString(16)}`.slice(-2)), `#${h}${Y}${p}${G || ""}`;
        }
        get rgba() {
          return `rgba(${this.r},${this.g},${this.b},${this.a})`;
        }
        fromColor(h) {
          return typeof h == "string" && (h = b()(h), h[0] /= 255, h[1] /= 255, h[2] /= 255), this[0] = h[0], this[1] = h[1], this[2] = h[2], this[3] = h[3], this;
        }
      }
    },
    /* 222 */
    /***/
    function(s, l, d) {
      d.r(l), d.d(l, "createRadiusBox", function() {
        return b;
      }), d(1).glMatrix.setMatrixArrayType(Array);
      function i(m, o, n, W, e, I = "leftTop") {
        const a = 0.5522848, V = W / 2 * a, h = e / 2 * a, Y = o + W, p = n + e, G = o + W / 2, y = n + e / 2;
        I === "leftTop" ? (m.moveTo(o, y), m.bezierCurveTo(o, y - h, G - V, n, G, n)) : I === "rightTop" ? m.bezierCurveTo(G + V, n, Y, y - h, Y, y) : I === "rightBottom" ? m.bezierCurveTo(Y, y + h, G + V, p, G, p) : I === "leftBottom" && m.bezierCurveTo(G - V, p, o, y + h, o, y);
      }
      function b(m, [o, n, W, e], I) {
        if (!I || Array.isArray(I) && I.every((a) => a === 0))
          m.beginPath(), m.rect(o, n, W, e);
        else {
          typeof I == "number" && (I = Array(8).fill(I));
          const [a, V, h, Y, p, G, y, Z] = I.map((X, c) => c % 2 ? Math.min(X, e / 2) : Math.min(X, W / 2));
          m.beginPath(), m.moveTo(o, n + V), i(m, o, n, a * 2, V * 2, "leftTop"), m.lineTo(o + W - h, n), i(m, o + W - h * 2, n, h * 2, Y * 2, "rightTop"), m.lineTo(o + W, n + e - G), i(m, o + W - p * 2, n + e - G * 2, p * 2, G * 2, "rightBottom"), m.lineTo(o + y, n + e), i(m, o, n + e - Z * 2, y * 2, Z * 2, "leftBottom"), m.closePath();
        }
        return m;
      }
    },
    /* 223 */
    /***/
    function(s, l, d) {
      d.r(l), d(1).glMatrix.setMatrixArrayType(Array), l.default = function(i, b) {
        if (!i)
          return {
            x: 0,
            y: 0,
            width: 0,
            height: 0,
            left: 0,
            top: 0,
            right: 0,
            bottom: 0
          };
        const [[m, o], [n, W]] = i, e = m * b[0] + o * b[2] + b[4], I = m * b[1] + o * b[3] + b[5], a = n * b[0] + o * b[2] + b[4], V = n * b[1] + o * b[3] + b[5], h = n * b[0] + W * b[2] + b[4], Y = n * b[1] + W * b[3] + b[5], p = m * b[0] + W * b[2] + b[4], G = m * b[1] + W * b[3] + b[5], y = Math.min(e, a, h, p), Z = Math.min(I, V, Y, G), X = Math.max(e, a, h, p), c = Math.max(I, V, Y, G);
        return {
          x: y,
          y: Z,
          width: X - y,
          height: c - Z,
          left: y,
          top: Z,
          right: X,
          bottom: c
        };
      };
    },
    /* 224 */
    /***/
    function(s, l, d) {
      d.r(l), d.d(l, "default", function() {
        return e;
      });
      var i = d(218), b = d(219), m = d(225), o = d(213);
      d(1).glMatrix.setMatrixArrayType(Array);
      function n(I, a, V) {
        return a in I ? Object.defineProperty(I, a, { value: V, enumerable: !0, configurable: !0, writable: !0 }) : I[a] = V, I;
      }
      const W = Symbol("textureTask");
      class e extends b.default {
        constructor(a = {}) {
          typeof a == "string" && (a = {
            texture: a
          }), super(a);
        }
        /* override */
        get contentSize() {
          let [a, V] = super.contentSize;
          const {
            width: h,
            height: Y
          } = this.attributes;
          if (h == null || Y == null) {
            const p = this.textureImage, G = this.attributes.textureRect, y = this.attributes.sourceRect;
            if (G)
              h == null && (a = G[0] + G[2]), Y == null && (V = G[1] + G[3]);
            else if (y) {
              const Z = this.layer ? this.layer.displayRatio : 1;
              h == null && (a = y[2] / Z), Y == null && (V = y[3] / Z);
            } else if (p) {
              const Z = this.layer ? this.layer.displayRatio : 1;
              h == null && (a = p.width / Z), Y == null && (V = p.height / Z);
            }
          }
          return [a, V];
        }
        get textureImageReady() {
          return this[W] || Promise.resolve();
        }
        /* override */
        draw(a = []) {
          super.draw(a);
          const V = this.mesh;
          return V && Object(i.drawTexture)(this, V), a;
        }
        /* override */
        onPropertyChange(a, V, h) {
          if (super.onPropertyChange(a, V, h), a === "texture" && (this[W] = Object(i.applyTexture)(this, V, !0)), a === "textureRect") {
            const {
              width: Y,
              height: p
            } = this.attributes;
            (Y == null || p == null) && this.updateContours();
          }
        }
      }
      n(e, "Attr", m.default), o.default.registerNode(e, "sprite");
    },
    /* 225 */
    /***/
    function(s, l, d) {
      d.r(l), d.d(l, "default", function() {
        return n;
      });
      var i = d(220);
      d(1).glMatrix.setMatrixArrayType(Array);
      const b = Symbol.for("spritejs_setAttributeDefault"), m = Symbol.for("spritejs_setAttribute"), o = Symbol.for("spritejs_getAttribute");
      class n extends i.default {
        constructor(e) {
          super(e), this[b]({
            texture: void 0,
            textureRect: void 0,
            textureRepeat: !1,
            sourceRect: void 0
          });
        }
        get texture() {
          return this[o]("texture");
        }
        set texture(e) {
          this[m]("texture", e);
        }
        get textureRect() {
          return this[o]("textureRect");
        }
        set textureRect(e) {
          this[m]("textureRect", e);
        }
        get sourceRect() {
          return this[o]("sourceRect");
        }
        set sourceRect(e) {
          this[m]("sourceRect", e);
        }
        get textureRepeat() {
          return this[o]("textureRepeat");
        }
        set textureRepeat(e) {
          this[m]("textureRepeat", !!e);
        }
      }
    },
    /* 226 */
    /***/
    function(s, l, d) {
      d.r(l), d.d(l, "default", function() {
        return Y;
      });
      var i = d(12), b = d(227), m = /* @__PURE__ */ d.n(b), o = d(70), n = d(228), W = d(221), e = d(218), I = d(213), a = d(223);
      d(1).glMatrix.setMatrixArrayType(Array);
      function V(p, G, y) {
        return G in p ? Object.defineProperty(p, G, { value: y, enumerable: !0, configurable: !0, writable: !0 }) : p[G] = y, p;
      }
      const h = Symbol("mesh");
      class Y extends o.default {
        constructor(G = {}) {
          typeof G == "string" && (G = {
            d: G
          }), super(G), this.effects = {
            d(y, Z, X, c, t) {
              const R = (X - c) / (t - c);
              if (R <= 0)
                return y;
              if (R >= 1)
                return Z;
              const S = m.a._preprocessing(m.a.path2shapes(y), m.a.path2shapes(Z)), J = m.a._lerp(...S, R)[0];
              return J.reduce((L, C) => `${L}${C.slice(2).join(" ")} `, `M${J[0][0]} ${J[0][1]}C`).trim();
            }
          };
        }
        /* override */
        get isVisible() {
          return !!this.d;
        }
        get mesh() {
          if (this.attributes.display === "none")
            return null;
          const G = this.path;
          if (G) {
            let y = this[h];
            if (y)
              y.path !== G && (y.contours = G.contours, y.path = G);
            else {
              y = new i.Mesh2D(this.path), y.path = G;
              const X = this.attributes.fillColor, c = this.attributes.fillRule;
              X && Object(W.setFillColor)(y, {
                color: X,
                rule: c
              });
              const t = this.attributes.lineWidth, R = this.attributes.strokeColor;
              if (R && t > 0) {
                const {
                  lineCap: J,
                  lineJoin: H,
                  miterLimit: L,
                  lineDash: C,
                  lineDashOffset: F,
                  roundSegments: r
                } = this.attributes;
                Object(W.setStrokeColor)(y, {
                  color: R,
                  lineWidth: t,
                  lineCap: J,
                  lineJoin: H,
                  miterLimit: L,
                  lineDash: C,
                  lineDashOffset: F,
                  roundSegments: r
                });
              }
              this[h] = y;
              const S = this.attributes.clipPath;
              S && this[h].setClipPath(S);
            }
            const Z = this.opacity;
            return y.getOpacity() !== Z && y.setOpacity(Z), y.setTransform(...this.renderMatrix), y;
          }
          return null;
        }
        get originalContentRect() {
          if (this.path) {
            const G = this.path.boundingBox;
            return [G[0][0], G[0][1], G[1][0] - G[0][0], G[1][1] - G[0][1]];
          }
          return [0, 0, 0, 0];
        }
        get originalClientRect() {
          if (this.mesh) {
            const G = this.mesh.boundingBox;
            return [G[0][0], G[0][1], G[1][0] - G[0][0], G[1][1] - G[0][1]];
          }
          return [0, 0, 0, 0];
        }
        get originalClientCenter() {
          return this.mesh ? this.mesh.boundingCenter : [0, 0];
        }
        set d(G) {
          this.attributes.d = G;
        }
        get d() {
          return this.attributes.d;
        }
        /* override */
        draw(G = []) {
          super.draw(G);
          const y = this.mesh;
          return y && Object(e.drawTexture)(this, y), G;
        }
        getBoundingClientRect() {
          let G = null;
          return this.mesh && (G = this.mesh.boundingBox), Object(a.default)(G, this.renderMatrix);
        }
        getPathLength() {
          return this.mesh ? this.mesh.getTotalLength() : 0;
        }
        getPointAtLength(G) {
          if (this.mesh) {
            const y = this.mesh.getPointAtLength(G);
            if (y)
              return [y.x, y.y];
          }
          return [0, 0];
        }
        /* override */
        onPropertyChange(G, y, Z) {
          if (super.onPropertyChange(G, y, Z), (G === "d" || G === "normalize") && this.updateContours(), this[h] && (G === "fillColor" || G === "fillRule")) {
            const {
              fillColor: X,
              fillRule: c
            } = this.attributes;
            Object(W.setFillColor)(this[h], {
              color: X,
              rule: c
            });
          }
          if (this[h] && (G === "strokeColor" || G === "lineWidth" || G === "lineCap" || G === "lineJoin" || G === "lineDash" || G === "lineDashOffset" || G === "roundSegments")) {
            const {
              strokeColor: X,
              lineWidth: c
            } = this.attributes;
            if (X && c > 0) {
              const {
                lineCap: t,
                lineJoin: R,
                lineDash: S,
                lineDashOffset: J,
                miterLimit: H,
                roundSegments: L
              } = this.attributes;
              Object(W.setStrokeColor)(this[h], {
                color: X,
                lineCap: t,
                lineJoin: R,
                lineWidth: c,
                lineDash: S,
                lineDashOffset: J,
                miterLimit: H,
                roundSegments: L
              });
            }
          }
          this[h] && G === "clipPath" && this[h].setClipPath(y), G === "texture" && Object(e.applyTexture)(this, y);
        }
        /* override */
        updateContours() {
          this.path = new i.Figure2D(), this.path.addPath(this.attributes.d), this.attributes.normalize && this.path.normalize(...this.path.boundingCenter);
        }
      }
      V(Y, "Attr", n.default), I.default.registerNode(Y, "path");
    },
    /* 227 */
    /***/
    function(s, l, d) {
      (function(i, b) {
        s.exports = b();
      })(this, function() {
        var i = /* @__PURE__ */ function() {
          function C(F, r) {
            var K = [], g = !0, v = !1, f = void 0;
            try {
              for (var O = F[Symbol.iterator](), q; !(g = (q = O.next()).done) && (K.push(q.value), !(r && K.length === r)); g = !0)
                ;
            } catch (M) {
              v = !0, f = M;
            } finally {
              try {
                !g && O.return && O.return();
              } finally {
                if (v)
                  throw f;
              }
            }
            return K;
          }
          return function(F, r) {
            if (Array.isArray(F))
              return F;
            if (Symbol.iterator in Object(F))
              return C(F, r);
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          };
        }(), b = Math.PI * 2, m = function(F, r, K, g, v, f, O) {
          var q = F.x, M = F.y;
          q *= r, M *= K;
          var P = g * q - v * M, D = v * q + g * M;
          return {
            x: P + f,
            y: D + O
          };
        }, o = function(F, r) {
          var K = 1.3333333333333333 * Math.tan(r / 4), g = Math.cos(F), v = Math.sin(F), f = Math.cos(F + r), O = Math.sin(F + r);
          return [{
            x: g - v * K,
            y: v + g * K
          }, {
            x: f + O * K,
            y: O - f * K
          }, {
            x: f,
            y: O
          }];
        }, n = function(F, r, K, g) {
          var v = F * g - r * K < 0 ? -1 : 1, f = Math.sqrt(F * F + r * r), O = Math.sqrt(F * F + r * r), q = F * K + r * g, M = q / (f * O);
          return M > 1 && (M = 1), M < -1 && (M = -1), v * Math.acos(M);
        }, W = function(F, r, K, g, v, f, O, q, M, P, D, dd) {
          var _ = Math.pow(v, 2), cd = Math.pow(f, 2), $ = Math.pow(D, 2), Wd = Math.pow(dd, 2), Xd = _ * cd - _ * Wd - cd * $;
          Xd < 0 && (Xd = 0), Xd /= _ * Wd + cd * $, Xd = Math.sqrt(Xd) * (O === q ? -1 : 1);
          var k = Xd * v / f * dd, z = Xd * -f / v * D, E = P * k - M * z + (F + K) / 2, j = M * k + P * z + (r + g) / 2, N = (D - k) / v, Q = (dd - z) / f, u = (-D - k) / v, x = (-dd - z) / f, T = n(1, 0, N, Q), U = n(N, Q, u, x);
          return q === 0 && U > 0 && (U -= b), q === 1 && U < 0 && (U += b), [E, j, T, U];
        }, e = function(F) {
          var r = F.px, K = F.py, g = F.cx, v = F.cy, f = F.rx, O = F.ry, q = F.xAxisRotation, M = q === void 0 ? 0 : q, P = F.largeArcFlag, D = P === void 0 ? 0 : P, dd = F.sweepFlag, _ = dd === void 0 ? 0 : dd, cd = [];
          if (f === 0 || O === 0)
            return [];
          var $ = Math.sin(M * b / 360), Wd = Math.cos(M * b / 360), Xd = Wd * (r - g) / 2 + $ * (K - v) / 2, k = -$ * (r - g) / 2 + Wd * (K - v) / 2;
          if (Xd === 0 && k === 0)
            return [];
          f = Math.abs(f), O = Math.abs(O);
          var z = Math.pow(Xd, 2) / Math.pow(f, 2) + Math.pow(k, 2) / Math.pow(O, 2);
          z > 1 && (f *= Math.sqrt(z), O *= Math.sqrt(z));
          var E = W(r, K, g, v, f, O, D, _, $, Wd, Xd, k), j = i(E, 4), N = j[0], Q = j[1], u = j[2], x = j[3], T = Math.max(Math.ceil(Math.abs(x) / (b / 4)), 1);
          x /= T;
          for (var U = 0; U < T; U++)
            cd.push(o(u, x)), u += x;
          return cd.map(function(w) {
            var B = m(w[0], f, O, Wd, $, N, Q), A = B.x, ld = B.y, id = m(w[1], f, O, Wd, $, N, Q), sd = id.x, td = id.y, Zd = m(w[2], f, O, Wd, $, N, Q), bd = Zd.x, md = Zd.y;
            return { x1: A, y1: ld, x2: sd, y2: td, x: bd, y: md };
          });
        }, I = {
          a: 7,
          c: 6,
          h: 1,
          l: 2,
          m: 2,
          q: 4,
          s: 4,
          t: 2,
          v: 1,
          z: 0
          /**
           * segment pattern
           * @type {RegExp}
           */
        }, a = /([astvzqmhlc])([^astvzqmhlc]*)/ig;
        function V(C) {
          var F = [];
          return C.replace(a, function(r, K, g) {
            var v = K.toLowerCase();
            for (g = Y(g), v == "m" && g.length > 2 && (F.push([K].concat(g.splice(0, 2))), v = "l", K = K == "m" ? "l" : "L"); ; ) {
              if (g.length == I[v])
                return g.unshift(K), F.push(g);
              if (g.length < I[v])
                throw new Error("malformed path data");
              F.push([K].concat(g.splice(0, I[v])));
            }
          }), F;
        }
        var h = /-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/ig;
        function Y(C) {
          var F = C.match(h);
          return F ? F.map(Number) : [];
        }
        function p(C) {
          var F = C[0][0], r = C[0][1], K = F, g = r;
          return C.forEach(function(v) {
            var f = v[0], O = v[2], q = v[4], M = v[6], P = v[1], D = v[3], dd = v[5], _ = v[7];
            F = Math.min(F, f, O, q, M), r = Math.min(r, P, D, dd, _), K = Math.max(K, f, O, q, M), g = Math.max(g, P, D, dd, _);
          }), [F, r, K, g];
        }
        function G(C, F) {
          return Math.sqrt(Math.pow(C[0] - F[0], 2) + Math.pow(C[1] - F[1], 2)) + Math.sqrt(Math.pow(C[2] - F[2], 2) + Math.pow(C[3] - F[3], 2));
        }
        function y(C, F) {
          var r = C[0], K = C[2], g = C[4], v = C[6], f = C[1], O = C[3], q = C[5], M = C[7], P = F[0], D = F[2], dd = F[4], _ = F[6], cd = F[1], $ = F[3], Wd = F[5], Xd = F[7];
          return Math.sqrt(Math.pow(P - r, 2) + Math.pow(cd - f, 2)) + Math.sqrt(Math.pow(D - K, 2) + Math.pow($ - O, 2)) + Math.sqrt(Math.pow(dd - g, 2) + Math.pow(Wd - q, 2)) + Math.sqrt(Math.pow(_ - v, 2) + Math.pow(Xd - M, 2));
        }
        function Z(C, F) {
          var r = c(C.length), K = [];
          r.forEach(function(v) {
            var f = 0, O = 0;
            v.forEach(function(q) {
              f += y(C[q], F[O++]);
            }), K.push({ index: v, distance: f });
          }), K.sort(function(v, f) {
            return v.distance - f.distance;
          });
          var g = [];
          return K[0].index.forEach(function(v) {
            g.push(C[v]);
          }), g;
        }
        function X(C, F) {
          var r = t(C.length), K = [];
          r.forEach(function(v) {
            var f = 0;
            v.forEach(function(O) {
              f += G(p(C[O]), p(F[O]));
            }), K.push({ index: v, distance: f });
          }), K.sort(function(v, f) {
            return v.distance - f.distance;
          });
          var g = [];
          return K[0].index.forEach(function(v) {
            g.push(C[v]);
          }), g;
        }
        function c(C) {
          for (var F = [], r = 0; r < C; r++) {
            for (var K = [], g = 0; g < C; g++) {
              var v = g + r;
              v > C - 1 && (v -= C), K[v] = g;
            }
            F.push(K);
          }
          return F;
        }
        function t(C) {
          for (var F = [], r = 0; r < C; r++)
            F.push(r);
          return R(F);
        }
        function R(C) {
          var F = [], r = [];
          function K(g) {
            var v, f;
            for (v = 0; v < g.length; v++)
              f = g.splice(v, 1)[0], r.push(f), g.length == 0 && F.push(r.slice()), K(g), g.splice(v, 0, f), r.pop();
            return F;
          }
          return K(C);
        }
        var S = {};
        S.parser = V, S.lerpCurve = function(C, F, r) {
          return S.lerpPoints(C[0], C[1], F[0], F[1], r).concat(S.lerpPoints(C[2], C[3], F[2], F[3], r)).concat(S.lerpPoints(C[4], C[5], F[4], F[5], r)).concat(S.lerpPoints(C[6], C[7], F[6], F[7], r));
        }, S.lerpPoints = function(C, F, r, K, g) {
          return [C + (r - C) * g, F + (K - F) * g];
        }, S.q2b = function(C, F, r, K, g, v) {
          return [C, F, (C + 2 * r) / 3, (F + 2 * K) / 3, (g + 2 * r) / 3, (v + 2 * K) / 3, g, v];
        }, S.path2shapes = function(C) {
          for (var F = S.parser(C), r = 0, K = 0, g = 0, v = F.length, f = [], O = null, q = void 0, M = void 0, P = void 0, D = void 0, dd = void 0, _ = void 0, cd = void 0; g < v; g++) {
            var $ = F[g], Wd = $[0], Xd = F[g - 1];
            switch (Wd) {
              case "m":
                dd = f.length, f[dd] = [], O = f[dd], r = r + $[1], K = K + $[2];
                break;
              case "M":
                dd = f.length, f[dd] = [], O = f[dd], r = $[1], K = $[2];
                break;
              case "l":
                O.push([r, K, r, K, r, K, r + $[1], K + $[2]]), r += $[1], K += $[2];
                break;
              case "L":
                O.push([r, K, $[1], $[2], $[1], $[2], $[1], $[2]]), r = $[1], K = $[2];
                break;
              case "h":
                O.push([r, K, r, K, r, K, r + $[1], K]), r += $[1];
                break;
              case "H":
                O.push([r, K, $[1], K, $[1], K, $[1], K]), r = $[1];
                break;
              case "v":
                O.push([r, K, r, K, r, K, r, K + $[1]]), K += $[1];
                break;
              case "V":
                O.push([r, K, r, $[1], r, $[1], r, $[1]]), K = $[1];
                break;
              case "C":
                O.push([r, K, $[1], $[2], $[3], $[4], $[5], $[6]]), r = $[5], K = $[6];
                break;
              case "S":
                Xd[0] === "C" || Xd[0] === "c" ? O.push([r, K, r + Xd[5] - Xd[3], K + Xd[6] - Xd[4], $[1], $[2], $[3], $[4]]) : (Xd[0] === "S" || Xd[0] === "s") && O.push([r, K, r + Xd[3] - Xd[1], K + Xd[4] - Xd[2], $[1], $[2], $[3], $[4]]), r = $[3], K = $[4];
                break;
              case "c":
                O.push([r, K, r + $[1], K + $[2], r + $[3], K + $[4], r + $[5], K + $[6]]), r = r + $[5], K = K + $[6];
                break;
              case "s":
                Xd[0] === "C" || Xd[0] === "c" ? O.push([r, K, r + Xd[5] - Xd[3], K + Xd[6] - Xd[4], r + $[1], K + $[2], r + $[3], K + $[4]]) : (Xd[0] === "S" || Xd[0] === "s") && O.push([r, K, r + Xd[3] - Xd[1], K + Xd[4] - Xd[2], r + $[1], K + $[2], r + $[3], K + $[4]]), r = r + $[3], K = K + $[4];
                break;
              case "a":
                _ = e({
                  rx: $[1],
                  ry: $[2],
                  px: r,
                  py: K,
                  xAxisRotation: $[3],
                  largeArcFlag: $[4],
                  sweepFlag: $[5],
                  cx: r + $[6],
                  cy: K + $[7]
                }), cd = _[_.length - 1], _.forEach(function(k, z) {
                  z === 0 ? O.push([r, K, k.x1, k.y1, k.x2, k.y2, k.x, k.y]) : O.push([_[z - 1].x, _[z - 1].y, k.x1, k.y1, k.x2, k.y2, k.x, k.y]);
                }), r = cd.x, K = cd.y;
                break;
              case "A":
                _ = e({
                  rx: $[1],
                  ry: $[2],
                  px: r,
                  py: K,
                  xAxisRotation: $[3],
                  largeArcFlag: $[4],
                  sweepFlag: $[5],
                  cx: $[6],
                  cy: $[7]
                }), cd = _[_.length - 1], _.forEach(function(k, z) {
                  z === 0 ? O.push([r, K, k.x1, k.y1, k.x2, k.y2, k.x, k.y]) : O.push([_[z - 1].x, _[z - 1].y, k.x1, k.y1, k.x2, k.y2, k.x, k.y]);
                }), r = cd.x, K = cd.y;
                break;
              case "Q":
                O.push(S.q2b(r, K, $[1], $[2], $[3], $[4])), r = $[3], K = $[4];
                break;
              case "q":
                O.push(S.q2b(r, K, r + $[1], K + $[2], $[3] + r, $[4] + K)), r += $[3], K += $[4];
                break;
              case "T":
                Xd[0] === "Q" || Xd[0] === "q" ? (P = r + Xd[3] - Xd[1], D = K + Xd[4] - Xd[2], O.push(S.q2b(r, K, P, D, $[1], $[2]))) : (Xd[0] === "T" || Xd[0] === "t") && (O.push(S.q2b(r, K, r + r - P, K + K - D, $[1], $[2])), P = r + r - P, D = K + K - D), r = $[1], K = $[2];
                break;
              case "t":
                Xd[0] === "Q" || Xd[0] === "q" ? (P = r + Xd[3] - Xd[1], D = K + Xd[4] - Xd[2], O.push(S.q2b(r, K, P, D, r + $[1], K + $[2]))) : (Xd[0] === "T" || Xd[0] === "t") && (O.push(S.q2b(r, K, r + r - P, K + K - D, r + $[1], K + $[2])), P = r + r - P, D = K + K - D), r += $[1], K += $[2];
                break;
              case "Z":
                q = O[0][0], M = O[0][1], O.push([r, K, q, M, q, M, q, M]);
                break;
              case "z":
                q = O[0][0], M = O[0][1], O.push([r, K, q, M, q, M, q, M]);
                break;
            }
          }
          return f;
        }, S._upCurves = function(C, F) {
          for (var r = 0, K = 0, g = C.length; r < F; r++)
            C.push(C[K].slice(0)), K++, K > g - 1 && (K -= g);
        };
        function J(C, F, r, K, g, v, f, O, q) {
          return {
            left: H(C, F, r, K, g, v, f, O, q),
            right: H(f, O, g, v, r, K, C, F, 1 - q, !0)
          };
        }
        function H(C, F, r, K, g, v, f, O, q, M) {
          var P = (r - C) * q + C, D = (K - F) * q + F, dd = (g - r) * q + r, _ = (v - K) * q + K, cd = (f - g) * q + g, $ = (O - v) * q + v, Wd = (dd - P) * q + P, Xd = (_ - D) * q + D, k = (cd - dd) * q + dd, z = ($ - _) * q + _, E = (k - Wd) * q + Wd, j = (z - Xd) * q + Xd;
          return M ? [E, j, Wd, Xd, P, D, C, F] : [C, F, P, D, Wd, Xd, E, j];
        }
        S._splitCurves = function(C, F) {
          for (var r = 0, K = 0; r < F; r++) {
            var g = C[K], v = J(g[0], g[1], g[2], g[3], g[4], g[5], g[6], g[7], 0.5);
            C.splice(K, 1), C.splice(K, 0, v.left, v.right), K += 2, K >= C.length - 1 && (K = 0);
          }
        };
        function L(C, F) {
          for (var r = function(v) {
            var f = C[C.length - 1], O = [];
            f.forEach(function(q) {
              O.push(q.slice(0));
            }), C.push(O);
          }, K = 0; K < F; K++)
            r();
        }
        return S.lerp = function(C, F, r) {
          return S._lerp(S.path2shapes(C), S.path2shapes(F), r);
        }, S.MIM_CURVES_COUNT = 100, S._preprocessing = function(C, F) {
          var r = C.length, K = F.length, g = JSON.parse(JSON.stringify(C)), v = JSON.parse(JSON.stringify(F));
          return r > K ? L(v, r - K) : r < K && L(g, K - r), g = X(g, v), g.forEach(function(f, O) {
            var q = f.length, M = v[O].length;
            q > M ? q < S.MIM_CURVES_COUNT ? (S._splitCurves(f, S.MIM_CURVES_COUNT - q), S._splitCurves(v[O], S.MIM_CURVES_COUNT - M)) : S._splitCurves(v[O], q - M) : q < M && (M < S.MIM_CURVES_COUNT ? (S._splitCurves(f, S.MIM_CURVES_COUNT - q), S._splitCurves(v[O], S.MIM_CURVES_COUNT - M)) : S._splitCurves(f, M - q));
          }), g.forEach(function(f, O) {
            g[O] = Z(f, v[O]);
          }), [g, v];
        }, S._lerp = function(C, F, r) {
          var K = [];
          return C.forEach(function(g, v) {
            var f = [];
            g.forEach(function(O, q) {
              f.push(S.lerpCurve(O, F[v][q], r));
            }), K.push(f);
          }), K;
        }, S.animate = function(C) {
          var F = S.path2shapes(C.from), r = S.path2shapes(C.to), K = S._preprocessing(F, r), g = /* @__PURE__ */ new Date(), v = C.end || function() {
          }, f = C.progress || function() {
          }, O = C.begin || function() {
          }, q = C.easing || function(_) {
            return _;
          }, M = null, P = null, D = C.time;
          O(F);
          var dd = function _() {
            var cd = /* @__PURE__ */ new Date() - g;
            if (cd >= D) {
              P = r, f(P, 1), v(P), cancelAnimationFrame(M);
              return;
            }
            var $ = q(cd / D);
            P = S._lerp(K[0], K[1], $), f(P, $), M = requestAnimationFrame(_);
          };
          dd();
        }, S;
      });
    },
    /* 228 */
    /***/
    function(s, l, d) {
      d.r(l), d.d(l, "default", function() {
        return e;
      });
      var i = d(71), b = d(221), m = d(72);
      d(1).glMatrix.setMatrixArrayType(Array);
      const o = Symbol.for("spritejs_setAttributeDefault"), n = Symbol.for("spritejs_setAttribute"), W = Symbol.for("spritejs_getAttribute");
      class e extends i.default {
        constructor(a) {
          super(a), this[o]({
            d: "",
            normalize: !1,
            fillColor: void 0,
            fillRule: "nonzero",
            strokeColor: void 0,
            lineWidth: 1,
            lineJoin: "miter",
            // 'miter' or 'bevel' or 'round'
            lineCap: "butt",
            // 'butt' or 'square' or 'round'
            roundSegments: 20,
            // default roundSegment if lineJoin or lineCap is round
            lineDash: void 0,
            lineDashOffset: 0,
            miterLimit: 10,
            texture: void 0,
            textureRect: void 0,
            textureRepeat: !1,
            sourceRect: void 0,
            clipPath: void 0
          });
        }
        get d() {
          return this[W]("d");
        }
        set d(a) {
          this[n]("d", a);
        }
        get normalize() {
          return this[W]("normalize");
        }
        set normalize(a) {
          this[n]("normalize", !!a);
        }
        get fillColor() {
          return this[W]("fillColor");
        }
        set fillColor(a) {
          this[n]("fillColor", Object(b.parseColor)(a));
        }
        get fillRule() {
          return this[W]("fillRule");
        }
        set fillRule(a) {
          if (a != null && a !== "nonzero" && a !== "evenodd")
            throw new TypeError("Invalid fill rule.");
          this[n]("fillRule", a);
        }
        get strokeColor() {
          return this[W]("strokeColor");
        }
        set strokeColor(a) {
          this[n]("strokeColor", Object(b.parseColor)(a));
        }
        get lineWidth() {
          return this[W]("lineWidth");
        }
        set lineWidth(a) {
          this[n]("lineWidth", Object(m.toNumber)(a));
        }
        get lineJoin() {
          return this[W]("lineJoin");
        }
        set lineJoin(a) {
          if (a != null && a !== "miter" && a !== "bevel" && a !== "round")
            throw new TypeError("Invalid lineJoin type.");
          this[n]("lineJoin", a);
        }
        get lineCap() {
          return this[W]("lineCap");
        }
        set lineCap(a) {
          if (a != null && a !== "butt" && a !== "square" && a !== "round")
            throw new TypeError("Invalid lineCap type.");
          this[n]("lineCap", a);
        }
        get lineDash() {
          return this[W]("lineDash");
        }
        set lineDash(a) {
          a = Object(m.toArray)(a, !0), a != null && !Array.isArray(a) && (a = [a]), this[n]("lineDash", a ? a.map(m.toNumber) : null);
        }
        get lineDashOffset() {
          return this[W]("lineDashOffset");
        }
        set lineDashOffset(a) {
          this[n]("lineDashOffset", Object(m.toNumber)(a));
        }
        get miterLimit() {
          return this[W]("miterLimit");
        }
        set miterLimit(a) {
          this[n]("miterLimit", Object(m.toNumber)(a));
        }
        get roundSegments() {
          return this[W]("roundSegments");
        }
        set roundSegments(a) {
          this[n]("roundSegments", a);
        }
        get texture() {
          return this[W]("texture");
        }
        set texture(a) {
          this[n]("texture", a);
        }
        get textureRect() {
          return this[W]("textureRect");
        }
        set textureRect(a) {
          this[n]("textureRect", a);
        }
        get sourceRect() {
          return this[W]("sourceRect");
        }
        set sourceRect(a) {
          this[n]("sourceRect", a);
        }
        get textureRepeat() {
          return this[W]("textureRepeat");
        }
        set textureRepeat(a) {
          this[n]("textureRepeat", !!a);
        }
        get clipPath() {
          return this[W]("clipPath");
        }
        set clipPath(a) {
          this[n]("clipPath", a);
        }
      }
    },
    /* 229 */
    /***/
    function(s, l, d) {
      d.r(l), d.d(l, "default", function() {
        return n;
      });
      var i = d(226), b = d(213), m = d(230);
      d(1).glMatrix.setMatrixArrayType(Array);
      function o(W, e, I) {
        return e in W ? Object.defineProperty(W, e, { value: I, enumerable: !0, configurable: !0, writable: !0 }) : W[e] = I, W;
      }
      class n extends i.default {
        /* override */
        get isVisible() {
          const {
            width: e,
            height: I
          } = this.attributes;
          return e > 0 && I > 0 && super.isVisible;
        }
      }
      o(n, "Attr", m.default), b.default.registerNode(n, "rect");
    },
    /* 230 */
    /***/
    function(s, l, d) {
      d.r(l), d.d(l, "default", function() {
        return I;
      });
      var i = d(228), b = d(72);
      d(1).glMatrix.setMatrixArrayType(Array);
      const m = Symbol.for("spritejs_setAttributeDefault"), o = Symbol.for("spritejs_setAttribute"), n = Symbol.for("spritejs_getAttribute"), W = Symbol.for("spritejs_declareAlias");
      function e(a) {
        const {
          width: V,
          height: h
        } = a;
        return `M0 0L${V} 0L${V} ${h}L0 ${h}Z`;
      }
      class I extends i.default {
        constructor(V) {
          super(V), this[m]({
            width: 0,
            height: 0
            /* size */
          }), this[W]("size");
        }
        // readonly
        get d() {
          return this[n]("d");
        }
        set d(V) {
        }
        // eslint-disable-line no-empty-function
        get width() {
          return this[n]("width");
        }
        set width(V) {
          if (V = Object(b.toNumber)(V), this[o]("width", V)) {
            const h = e(this);
            this[o]("d", h);
          }
        }
        get height() {
          return this[n]("height");
        }
        set height(V) {
          if (V = Object(b.toNumber)(V), this[o]("height", V)) {
            const h = e(this);
            this[o]("d", h);
          }
        }
        get size() {
          return [this.width, this.height];
        }
        set size(V) {
          V = Object(b.toArray)(V), Array.isArray(V) || (V = [V, V]), this.width = V[0], this.height = V[1];
        }
      }
    },
    /* 231 */
    /***/
    function(s, l, d) {
      d.r(l), d.d(l, "default", function() {
        return n;
      });
      var i = d(232), b = d(213), m = d(235);
      d(1).glMatrix.setMatrixArrayType(Array);
      function o(W, e, I) {
        return e in W ? Object.defineProperty(W, e, { value: I, enumerable: !0, configurable: !0, writable: !0 }) : W[e] = I, W;
      }
      class n extends i.default {
        get isVisible() {
          const {
            sides: e
          } = this.attributes;
          return e[0] > 0 && e[1] > 0 && super.isVisible;
        }
      }
      o(n, "Attr", m.default), b.default.registerNode(n, "triangle");
    },
    /* 232 */
    /***/
    function(s, l, d) {
      d.r(l), d.d(l, "default", function() {
        return n;
      });
      var i = d(226), b = d(213), m = d(233);
      d(1).glMatrix.setMatrixArrayType(Array);
      function o(W, e, I) {
        return e in W ? Object.defineProperty(W, e, { value: I, enumerable: !0, configurable: !0, writable: !0 }) : W[e] = I, W;
      }
      class n extends i.default {
        /* override */
        get isVisible() {
          const {
            points: e
          } = this.attributes;
          return e.length > 0 && super.isVisible;
        }
      }
      o(n, "Attr", m.default), b.default.registerNode(n, "polyline");
    },
    /* 233 */
    /***/
    function(s, l, d) {
      d.r(l), d.d(l, "default", function() {
        return a;
      });
      var i = d(228), b = d(72), m = d(234);
      d(1).glMatrix.setMatrixArrayType(Array);
      const o = Symbol.for("spritejs_setAttributeDefault"), n = Symbol.for("spritejs_setAttribute"), W = Symbol.for("spritejs_getAttribute"), e = Symbol.for("spritejs_declareAlias");
      function I(V) {
        const {
          points: h,
          smooth: Y,
          smoothRange: p,
          close: G
        } = V, y = [];
        for (let X = 0; X < h.length; X += 2)
          y.push([h[X], h[X + 1]]);
        let Z = "";
        return Y ? Z = Object(m.makeSmoothCurveLine)(y, p) : y.length && (Z = `M${y.map((X) => X.join(" ")).join("L")}`), Z && G && (Z += "Z"), Z;
      }
      class a extends i.default {
        constructor(h) {
          super(h), this[o]({
            points: [],
            smooth: !1,
            smoothRange: [0],
            closeType: "none"
            // none | normal
            /* close */
          }), this[e]("close");
        }
        // readonly
        get d() {
          return this[W]("d");
        }
        set d(h) {
        }
        // eslint-disable-line no-empty-function
        get close() {
          return this.closeType !== "none";
        }
        set close(h) {
          h = h ? "normal" : "none", this.closeType = h;
        }
        get closeType() {
          return this[W]("closeType");
        }
        set closeType(h) {
          if (h != null && h !== "none" && h !== "normal")
            throw new TypeError("Invalid closeType type.");
          if (this[n]("closeType", h)) {
            const Y = I(this);
            this[n]("d", Y);
          }
        }
        get smooth() {
          return this[W]("smooth");
        }
        set smooth(h) {
          if (this[n]("smooth", h)) {
            const Y = I(this);
            this[n]("d", Y);
          }
        }
        get smoothRange() {
          return this[W]("smoothRange");
        }
        set smoothRange(h) {
          if (h && !Array.isArray(h) && (h = [h]), this[n]("smoothRange", h) && this.smooth) {
            const Y = I(this);
            this[n]("d", Y);
          }
        }
        get points() {
          return this[W]("points");
        }
        set points(h) {
          if (h = Object(b.toArray)(h), Array.isArray(h) && (h = h.reduce((Y, p) => Array.isArray(p) ? [...Y, ...p.map((G) => Object(b.toNumber)(G))] : [...Y, Object(b.toNumber)(p)], [])), this[n]("points", h)) {
            const Y = I(this);
            this[n]("d", Y);
          }
        }
      }
    },
    /* 234 */
    /***/
    function(s, l, d) {
      d.r(l), d.d(l, "makeSmoothCurveLine", function() {
        return i;
      }), d(1).glMatrix.setMatrixArrayType(Array);
      function i(b, m = [0]) {
        function o(e, I = 0.168, a = 0.168) {
          let V, h, Y, p;
          if ((b[e].x === b[e + 1].x || b[e].y === b[e + 1].y) && (I = 0, a = 0), e < 1 ? (V = b[0].x + (b[1].x - b[0].x) * I, h = b[0].y + (b[1].y - b[0].y) * I) : (V = b[e].x + (b[e + 1].x - b[e - 1].x) * I, h = b[e].y + (b[e + 1].y - b[e - 1].y) * I), e > b.length - 3) {
            const G = b.length - 1;
            Y = b[G].x - (b[G].x - b[G - 1].x) * a, p = b[G].y - (b[G].y - b[G - 1].y) * a;
          } else
            Y = b[e + 1].x - (b[e + 2].x - b[e].x) * a, p = b[e + 1].y - (b[e + 2].y - b[e].y) * a;
          return [{
            x: V,
            y: h
          }, {
            x: Y,
            y: p
          }];
        }
        b = b.map(([e, I]) => ({
          x: e,
          y: I
        }));
        let n = "", W = 0;
        return b.forEach((e, I) => {
          if (I === 0)
            n += `M${e.x} ${e.y}`;
          else {
            for (; I > m[W]; )
              W++;
            if (W % 2) {
              const [a, V] = o(I - 1);
              n += `C${[a.x, a.y, V.x, V.y, e.x, e.y].join(" ")}`;
            } else
              n += `L${e.x} ${e.y}`;
          }
        }), n;
      }
    },
    /* 235 */
    /***/
    function(s, l, d) {
      d.r(l), d.d(l, "default", function() {
        return e;
      });
      var i = d(233), b = d(72);
      d(1).glMatrix.setMatrixArrayType(Array);
      const m = Symbol.for("spritejs_setAttributeDefault"), o = Symbol.for("spritejs_setAttribute"), n = Symbol.for("spritejs_getAttribute");
      function W(I) {
        const [a, V] = I.sides;
        let h = I.angle % 360;
        return h < 0 && (h += 360), h = Math.PI * h / 180, [0, 0, a, 0, V * Math.cos(h), V * Math.sin(h)];
      }
      class e extends i.default {
        constructor(a) {
          super(a), this[m]({
            sides: [0, 0],
            angle: 60,
            closeType: "normal"
          });
        }
        // readonly
        get points() {
          return super.points;
        }
        set points(a) {
        }
        // eslint-disable-line no-empty-function
        get sides() {
          return this[n]("sides");
        }
        set sides(a) {
          if (a = Object(b.toArray)(a, !0), a != null && !Array.isArray(a) && (a = [a, a]), this[o]("sides", a)) {
            const V = W(this);
            super.points = V;
          }
        }
        get angle() {
          return this[n]("angle");
        }
        set angle(a) {
          if (a = Object(b.toNumber)(a), this[o]("angle", a)) {
            const V = W(this);
            super.points = V;
          }
        }
      }
    },
    /* 236 */
    /***/
    function(s, l, d) {
      d.r(l), d.d(l, "default", function() {
        return n;
      });
      var i = d(232), b = d(213), m = d(237);
      d(1).glMatrix.setMatrixArrayType(Array);
      function o(W, e, I) {
        return e in W ? Object.defineProperty(W, e, { value: I, enumerable: !0, configurable: !0, writable: !0 }) : W[e] = I, W;
      }
      class n extends i.default {
        /* override */
        get isVisible() {
          const {
            sides: e
          } = this.attributes;
          return e[0] > 0 && e[1] > 0 && super.isVisible;
        }
      }
      o(n, "Attr", m.default), b.default.registerNode(n, "parallel");
    },
    /* 237 */
    /***/
    function(s, l, d) {
      d.r(l), d.d(l, "default", function() {
        return e;
      });
      var i = d(233), b = d(72);
      d(1).glMatrix.setMatrixArrayType(Array);
      const m = Symbol.for("spritejs_setAttributeDefault"), o = Symbol.for("spritejs_setAttribute"), n = Symbol.for("spritejs_getAttribute");
      function W(I) {
        const [a, V] = I.sides;
        let h = I.angle % 360;
        h < 0 && (h += 360), h = Math.PI * h / 180;
        const Y = V * Math.cos(h), p = V * Math.sin(h);
        return [0, 0, a, 0, Y + a, p, Y, p];
      }
      class e extends i.default {
        constructor(a) {
          super(a), this[m]({
            sides: [0, 0],
            angle: 90,
            closeType: "normal"
          });
        }
        // readonly
        get points() {
          return super.points;
        }
        set points(a) {
        }
        // eslint-disable-line no-empty-function
        get sides() {
          return this[n]("sides");
        }
        set sides(a) {
          if (a = Object(b.toArray)(a, !0), a != null && !Array.isArray(a) && (a = [a, a]), this[o]("sides", a)) {
            const V = W(this);
            super.points = V;
          }
        }
        get angle() {
          return this[n]("angle");
        }
        set angle(a) {
          if (a = Object(b.toNumber)(a), this[o]("angle", a)) {
            const V = W(this);
            super.points = V;
          }
        }
      }
    },
    /* 238 */
    /***/
    function(s, l, d) {
      d.r(l), d.d(l, "default", function() {
        return n;
      });
      var i = d(232), b = d(213), m = d(239);
      d(1).glMatrix.setMatrixArrayType(Array);
      function o(W, e, I) {
        return e in W ? Object.defineProperty(W, e, { value: I, enumerable: !0, configurable: !0, writable: !0 }) : W[e] = I, W;
      }
      class n extends i.default {
      }
      o(n, "Attr", m.default), b.default.registerNode(n, "regular");
    },
    /* 239 */
    /***/
    function(s, l, d) {
      d.r(l), d.d(l, "default", function() {
        return e;
      });
      var i = d(233), b = d(72);
      d(1).glMatrix.setMatrixArrayType(Array);
      const m = Symbol.for("spritejs_setAttributeDefault"), o = Symbol.for("spritejs_setAttribute"), n = Symbol.for("spritejs_getAttribute");
      function W(I) {
        const {
          edges: a,
          radius: V,
          offsetAngle: h
        } = I, Y = Math.PI * h / 180 - 0.5 * Math.PI;
        if (a < 3 || V <= 0)
          return [];
        const p = [];
        for (let G = 0; G < a; G++) {
          const y = G * 2 * Math.PI / a + Y, Z = V * Math.cos(y), X = V * Math.sin(y);
          p.push(Z, X);
        }
        return p;
      }
      class e extends i.default {
        constructor(a) {
          super(a), this[m]({
            edges: 3,
            radius: 0,
            offsetAngle: 0,
            closeType: "normal"
          });
        }
        // readonly
        get points() {
          return super.points;
        }
        set points(a) {
        }
        // eslint-disable-line no-empty-function
        get edges() {
          return this[n]("edges");
        }
        set edges(a) {
          if (a = Object(b.toNumber)(a), this[o]("edges", a)) {
            const V = W(this);
            super.points = V;
          }
        }
        get radius() {
          return this[n]("radius");
        }
        set radius(a) {
          if (a = Object(b.toNumber)(a), this[o]("radius", a)) {
            const V = W(this);
            super.points = V;
          }
        }
        get offsetAngle() {
          return this[n]("offsetAngle");
        }
        set offsetAngle(a) {
          if (a = Object(b.toNumber)(a), this[o]("offsetAngle", a)) {
            const V = W(this);
            super.points = V;
          }
        }
      }
    },
    /* 240 */
    /***/
    function(s, l, d) {
      d.r(l), d.d(l, "default", function() {
        return n;
      });
      var i = d(232), b = d(213), m = d(241);
      d(1).glMatrix.setMatrixArrayType(Array);
      function o(W, e, I) {
        return e in W ? Object.defineProperty(W, e, { value: I, enumerable: !0, configurable: !0, writable: !0 }) : W[e] = I, W;
      }
      class n extends i.default {
      }
      o(n, "Attr", m.default), b.default.registerNode(n, "star");
    },
    /* 241 */
    /***/
    function(s, l, d) {
      d.r(l), d.d(l, "default", function() {
        return e;
      });
      var i = d(233), b = d(72);
      d(1).glMatrix.setMatrixArrayType(Array);
      const m = Symbol.for("spritejs_setAttributeDefault"), o = Symbol.for("spritejs_setAttribute"), n = Symbol.for("spritejs_getAttribute");
      function W(I) {
        const {
          angles: a,
          innerRadius: V,
          outerRadius: h,
          offsetAngle: Y
        } = I, p = Math.PI * Y / 180 - 0.5 * Math.PI;
        if (a < 3 || V <= 0 || h <= 0)
          return [];
        const G = [];
        for (let y = 0; y < a * 2; y++) {
          const Z = y * Math.PI / a + p, X = y % 2 ? V : h, c = X * Math.cos(Z), t = X * Math.sin(Z);
          G.push(c, t);
        }
        return G;
      }
      class e extends i.default {
        constructor(a) {
          super(a), this[m]({
            angles: 5,
            innerRadius: 0,
            outerRadius: 0,
            /* radius */
            offsetAngle: 0,
            closeType: "normal"
          });
        }
        // readonly
        get points() {
          return super.points;
        }
        set points(a) {
        }
        // eslint-disable-line no-empty-function
        get angles() {
          return this[n]("angles");
        }
        set angles(a) {
          if (a = Object(b.toNumber)(a), this[o]("angles", a)) {
            const V = W(this);
            super.points = V;
          }
        }
        get innerRadius() {
          return this[n]("innerRadius");
        }
        set innerRadius(a) {
          if (a = Object(b.toNumber)(a), this[o]("innerRadius", a)) {
            const V = W(this);
            super.points = V;
          }
        }
        get outerRadius() {
          return this[n]("outerRadius");
        }
        set outerRadius(a) {
          if (a = Object(b.toNumber)(a), this[o]("outerRadius", a)) {
            const V = W(this);
            super.points = V;
          }
        }
        get radius() {
          return [this.innerRadius, this.outerRadius];
        }
        set radius(a) {
          a = Object(b.toArray)(a, !0), Array.isArray(a) || (a = [a, a]), this.innerRadius = a[0], this.outerRadius = a[1];
        }
        get offsetAngle() {
          return this[n]("offsetAngle");
        }
        set offsetAngle(a) {
          if (a = Object(b.toNumber)(a), this[o]("offsetAngle", a)) {
            const V = W(this);
            super.points = V;
          }
        }
      }
    },
    /* 242 */
    /***/
    function(s, l, d) {
      d.r(l), d.d(l, "default", function() {
        return n;
      });
      var i = d(226), b = d(213), m = d(243);
      d(1).glMatrix.setMatrixArrayType(Array);
      function o(W, e, I) {
        return e in W ? Object.defineProperty(W, e, { value: I, enumerable: !0, configurable: !0, writable: !0 }) : W[e] = I, W;
      }
      class n extends i.default {
        /* override */
        get isVisible() {
          const {
            radiusX: e,
            radiusY: I,
            startAngle: a,
            endAngle: V
          } = this.attributes;
          return e > 0 && I > 0 && a !== V && super.isVisible;
        }
      }
      o(n, "Attr", m.default), b.default.registerNode(n, "ellipse");
    },
    /* 243 */
    /***/
    function(s, l, d) {
      d.r(l), d.d(l, "default", function() {
        return a;
      });
      var i = d(12), b = d(228), m = d(72);
      d(1).glMatrix.setMatrixArrayType(Array);
      const o = Symbol.for("spritejs_setAttributeDefault"), n = Symbol.for("spritejs_setAttribute"), W = Symbol.for("spritejs_getAttribute"), e = Symbol.for("spritejs_declareAlias");
      function I(V) {
        const {
          radiusX: h,
          radiusY: Y,
          startAngle: p,
          endAngle: G,
          direction: y,
          closeType: Z
        } = V, X = y === "anitclockwise", c = new i.Figure2D();
        return Z === "sector" && c.moveTo(0, 0), c.ellipse(0, 0, h, Y, 0, Math.PI * p / 180, Math.PI * G / 180, X), Z !== "none" && c.closePath(), c.path.reduce((S, J) => S + J.join(" "), "");
      }
      class a extends b.default {
        constructor(h) {
          super(h), this[o]({
            radiusX: 0,
            radiusY: 0,
            /* radius */
            startAngle: 0,
            endAngle: 360,
            /* angle */
            direction: "clockwise",
            // clockwise | anticlockwise
            closeType: "none"
            // none | sector | normal
          }), this[e]("radius", "angle");
        }
        // readonly
        get d() {
          return this[W]("d");
        }
        set d(h) {
        }
        // eslint-disable-line no-empty-function
        get radiusX() {
          return this[W]("radiusX");
        }
        set radiusX(h) {
          if (h = Object(m.toNumber)(h), this[n]("radiusX", h)) {
            const Y = I(this);
            this[n]("d", Y);
          }
        }
        get radiusY() {
          return this[W]("radiusY");
        }
        set radiusY(h) {
          if (h = Object(m.toNumber)(h), this[n]("radiusY", h)) {
            const Y = I(this);
            this[n]("d", Y);
          }
        }
        get radius() {
          return [this.radiusX, this.radiusY];
        }
        set radius(h) {
          h = Object(m.toArray)(h, !0), Array.isArray(h) || (h = [h, h]), this.radiusX = h[0], this.radiusY = h[1];
        }
        get angle() {
          return [this.startAngle, this.endAngle];
        }
        set angle(h) {
          h = Object(m.toArray)(h), Array.isArray(h) || (h = [h, h]), this.startAngle = h[0], this.endAngle = h[1];
        }
        get direction() {
          return this[W]("direction");
        }
        set direction(h) {
          if (h != null && h !== "clockwise" && h !== "anticlockwise")
            throw new TypeError("Invalid direction type.");
          this[n]("direction", h);
        }
        get startAngle() {
          return this[W]("startAngle");
        }
        set startAngle(h) {
          if (h = Object(m.toNumber)(h), this[n]("startAngle", h)) {
            const Y = I(this);
            this[n]("d", Y);
          }
        }
        get endAngle() {
          return this[W]("endAngle");
        }
        set endAngle(h) {
          if (h = Object(m.toNumber)(h), this[n]("endAngle", h)) {
            const Y = I(this);
            this[n]("d", Y);
          }
        }
        get closeType() {
          return this[W]("closeType");
        }
        set closeType(h) {
          if (h != null && h !== "none" && h !== "sector" && h !== "normal")
            throw new TypeError("Invalid closeType type.");
          if (this[n]("closeType", h)) {
            const Y = I(this);
            this[n]("d", Y);
          }
        }
      }
    },
    /* 244 */
    /***/
    function(s, l, d) {
      d.r(l), d.d(l, "default", function() {
        return n;
      });
      var i = d(242), b = d(213), m = d(245);
      d(1).glMatrix.setMatrixArrayType(Array);
      function o(W, e, I) {
        return e in W ? Object.defineProperty(W, e, { value: I, enumerable: !0, configurable: !0, writable: !0 }) : W[e] = I, W;
      }
      class n extends i.default {
      }
      o(n, "Attr", m.default), b.default.registerNode(n, "arc");
    },
    /* 245 */
    /***/
    function(s, l, d) {
      d.r(l), d.d(l, "default", function() {
        return m;
      });
      var i = d(243), b = d(72);
      d(1).glMatrix.setMatrixArrayType(Array);
      class m extends i.default {
        get radius() {
          return super.radiusX;
        }
        set radius(n) {
          n = Object(b.toNumber)(n), super.radiusX = n, super.radiusY = n;
        }
      }
    },
    /* 246 */
    /***/
    function(s, l, d) {
      d.r(l), d.d(l, "default", function() {
        return n;
      });
      var i = d(226), b = d(213), m = d(247);
      d(1).glMatrix.setMatrixArrayType(Array);
      function o(W, e, I) {
        return e in W ? Object.defineProperty(W, e, { value: I, enumerable: !0, configurable: !0, writable: !0 }) : W[e] = I, W;
      }
      class n extends i.default {
        /* override */
        get isVisible() {
          const {
            innerRadius: e,
            outerRadius: I,
            startAngle: a,
            endAngle: V
          } = this.attributes;
          return (e > 0 || I > 0) && a !== V && super.isVisible;
        }
      }
      o(n, "Attr", m.default), b.default.registerNode(n, "ring");
    },
    /* 247 */
    /***/
    function(s, l, d) {
      d.r(l), d.d(l, "default", function() {
        return a;
      });
      var i = d(12), b = d(228), m = d(72);
      d(1).glMatrix.setMatrixArrayType(Array);
      const o = Symbol.for("spritejs_setAttributeDefault"), n = Symbol.for("spritejs_setAttribute"), W = Symbol.for("spritejs_getAttribute"), e = Symbol.for("spritejs_declareAlias");
      function I(V) {
        let {
          innerRadius: h,
          outerRadius: Y,
          startAngle: p,
          endAngle: G
        } = V;
        const y = new i.Figure2D();
        if (p = Math.PI * p / 180, G = Math.PI * G / 180, h > Y && ([h, Y] = [Y, h]), h <= 0 && y.moveTo(0, 0), y.arc(0, 0, Y, p, G, !1), h > 0) {
          const c = Math.PI * 2;
          G < p && (G = p + c + (G - p) % c), G - p >= c && (G = p + c - 1e-6), y.arc(0, 0, h, G, p, !0);
        }
        return y.closePath(), y.path.reduce((c, t) => c + t.join(" "), "");
      }
      class a extends b.default {
        constructor(h) {
          super(h), this[o]({
            innerRadius: 0,
            outerRadius: 0,
            /* radius */
            startAngle: 0,
            endAngle: 360
            /* angle */
          }), this[e]("radius", "angle");
        }
        // readonly
        get d() {
          return this[W]("d");
        }
        set d(h) {
        }
        // eslint-disable-line no-empty-function
        get innerRadius() {
          return this[W]("innerRadius");
        }
        set innerRadius(h) {
          if (h = Object(m.toNumber)(h), this[n]("innerRadius", h)) {
            const Y = I(this);
            this[n]("d", Y);
          }
        }
        get outerRadius() {
          return this[W]("outerRadius");
        }
        set outerRadius(h) {
          if (h = Object(m.toNumber)(h), this[n]("outerRadius", h)) {
            const Y = I(this);
            this[n]("d", Y);
          }
        }
        get radius() {
          return [this.innerRadius, this.outerRadius];
        }
        set radius(h) {
          h = Object(m.toArray)(h, !0), Array.isArray(h) || (h = [h, h]), this.innerRadius = h[0], this.outerRadius = h[1];
        }
        get startAngle() {
          return this[W]("startAngle");
        }
        set startAngle(h) {
          if (h = Object(m.toNumber)(h), this[n]("startAngle", h)) {
            const Y = I(this);
            this[n]("d", Y);
          }
        }
        get endAngle() {
          return this[W]("endAngle");
        }
        set endAngle(h) {
          if (h = Object(m.toNumber)(h), this[n]("endAngle", h)) {
            const Y = I(this);
            this[n]("d", Y);
          }
        }
        get angle() {
          return [this.startAngle, this.endAngle];
        }
        set angle(h) {
          h = Object(m.toArray)(h), Array.isArray(h) || (h = [h, h]), this.startAngle = h[0], this.endAngle = h[1];
        }
      }
    },
    /* 248 */
    /***/
    function(s, l, d) {
      d.r(l), d.d(l, "default", function() {
        return Y;
      });
      var i = d(12), b = d(218), m = d(219), o = d(249), n = d(213);
      d(1).glMatrix.setMatrixArrayType(Array);
      function W(p, G, y) {
        return G in p ? Object.defineProperty(p, G, { value: y, enumerable: !0, configurable: !0, writable: !0 }) : p[G] = y, p;
      }
      const e = Symbol("textImage"), I = Symbol("textImageTask"), a = Symbol("textureContext"), V = Symbol("updateTextureRect"), h = Symbol("textCanvas");
      class Y extends m.default {
        constructor(G = {}) {
          typeof G == "string" && (G = {
            text: G
          }), super(G);
        }
        /* override */
        get contentSize() {
          let [G, y] = super.contentSize;
          const {
            width: Z,
            height: X
          } = this.attributes;
          if (Z == null || X == null) {
            const c = this[e];
            c && (Z == null && (G = c.rect[2]), X == null && (y = c.rect[3]));
          }
          return [G, y];
        }
        get text() {
          return this.attributes.text;
        }
        set text(G) {
          this.attributes.text = G;
        }
        get textContent() {
          return this.attributes.text;
        }
        set textContent(G) {
          this.attributes.text = G;
        }
        get textImage() {
          return this[e] || {};
        }
        get textImageReady() {
          return this[I] || Promise.resolve();
        }
        /* override */
        draw(G) {
          super.draw(G);
          const y = this.mesh;
          if (y) {
            const Z = this[e];
            if (Z) {
              let X = y.texture;
              if (!X || this[a] && this[a] !== this.renderer || Z.needsUpdate ? (Z.needsUpdate = !1, Object(b.deleteTexture)(Z.image, this.renderer), X = Object(b.createTexture)(Z.image, this.renderer), this[V] = !0) : X = y.uniforms.u_texSampler, this[V]) {
                const [c, t] = Z.rect.slice(2), [R, S] = this.contentSize, J = this.attributes.textAlign, H = this.attributes.verticalAlign;
                let L = 0;
                J === "center" ? L = (R - c) / 2 : (J === "right" || J === "end") && (L = R - c);
                const C = this.attributes.fontSize, F = this.attributes.lineHeight;
                let r = 0;
                H === "top" ? r = (C - F) / 2 : H === "bottom" && (r = (F - C) / 2);
                const {
                  paddingLeft: K,
                  paddingTop: g
                } = this.attributes, {
                  borderWidth: v
                } = this.attributes;
                L += K + v, r += g + v;
                const {
                  anchorX: f,
                  anchorY: O
                } = this.attributes;
                L -= this.offsetSize[0] * f, r -= this.offsetSize[1] * O, y.setTexture(X, {
                  rect: [L, r, c, t]
                }), this[V] = !1, this[a] = this.renderer;
              }
            }
          }
          return G;
        }
        /* override */
        onPropertyChange(G, y, Z) {
          G === "text" || G === "fontSize" || G === "fontFamily" || G === "fontStyle" || G === "fontVariant" || G === "fontWeight" || G === "fontStretch" || G === "lineHeight" || G === "strokeColor" || G === "fillColor" || G === "strokeWidth" ? this.updateText() : ((G === "textAlign" || G === "verticalAlign") && (this[V] = !0), super.onPropertyChange(G, y, Z));
        }
        /* override */
        updateContours() {
          super.updateContours(), this[V] = !0;
        }
        updateText() {
          this[I] || (this[I] = Promise.resolve().then(() => {
            this[I] = null;
            const {
              text: G,
              font: y,
              fillColor: Z,
              strokeColor: X,
              strokeWidth: c
            } = this.attributes, t = this.layer ? this.layer.displayRatio : 1;
            return this[h] = this[h] || i.ENV.createCanvas(1, 1), this[e] = i.ENV.createText(G, {
              font: y,
              fillColor: Z,
              strokeColor: X,
              strokeWidth: c,
              parseFont: i.parseFont,
              ratio: t,
              textCanvas: this[h]
            }), this[e].needsUpdate = !0, this.updateContours(), this.forceUpdate(), this[e];
          }));
        }
      }
      W(Y, "Attr", o.default), n.default.registerNode(Y, "label");
    },
    /* 249 */
    /***/
    function(s, l, d) {
      d.r(l), d.d(l, "default", function() {
        return a;
      });
      var i = d(12), b = d(72), m = d(221), o = d(220);
      d(1).glMatrix.setMatrixArrayType(Array);
      const n = Symbol.for("spritejs_setAttributeDefault"), W = Symbol.for("spritejs_setAttribute"), e = Symbol.for("spritejs_getAttribute"), I = Symbol.for("spritejs_declareAlias");
      class a extends o.default {
        constructor(h) {
          super(h), this[n]({
            text: "",
            fontSize: 16,
            fontFamily: "Helvetica,Arial,sans-serif",
            fontStyle: "normal",
            fontVariant: "normal",
            fontWeight: "normal",
            fontStretch: "normal",
            lineHeight: "",
            /* font */
            textAlign: "left",
            strokeColor: void 0,
            strokeWidth: 1,
            fillColor: void 0,
            verticalAlign: "middle"
          }), this[I]("font");
        }
        get text() {
          return this[e]("text") || " ";
        }
        set text(h) {
          this[W]("text", h);
        }
        get fontSize() {
          return this[e]("fontSize");
        }
        set fontSize(h) {
          this[W]("fontSize", Object(b.toNumber)(h));
        }
        get fontFamily() {
          return this[e]("fontFamily");
        }
        set fontFamily(h) {
          this[W]("fontFamily", h);
        }
        get fontStyle() {
          return this[e]("fontStyle");
        }
        set fontStyle(h) {
          this[W]("fontStyle", h);
        }
        get fontVariant() {
          return this[e]("fontVariant");
        }
        set fontVariant(h) {
          this[W]("fontVariant", h);
        }
        get fontWeight() {
          return this[e]("fontWeight");
        }
        set fontWeight(h) {
          this[W]("fontWeight", h);
        }
        get fontStretch() {
          return this[e]("fontStretch");
        }
        set fontStretch(h) {
          this[W]("fontStretch", h);
        }
        get lineHeight() {
          return this[e]("lineHeight") || this.fontSize;
        }
        set lineHeight(h) {
          this[W]("lineHeight", Object(b.toNumber)(h));
        }
        get textAlign() {
          return this[e]("textAlign");
        }
        set textAlign(h) {
          this[W]("textAlign", h);
        }
        get strokeColor() {
          return this[e]("strokeColor");
        }
        set strokeColor(h) {
          this[W]("strokeColor", Object(m.parseColor)(h));
        }
        get strokeWidth() {
          return this[e]("strokeWidth");
        }
        set strokeWidth(h) {
          this[W]("strokeWidth", Object(b.toNumber)(h));
        }
        get verticalAlign() {
          return this[e]("verticalAlign");
        }
        set verticalAlign(h) {
          this[W]("verticalAlign", h);
        }
        get fillColor() {
          return this[e]("fillColor");
        }
        set fillColor(h) {
          this[W]("fillColor", Object(m.parseColor)(h));
        }
        get font() {
          const {
            fontStyle: h,
            fontVariant: Y,
            fontWeight: p,
            fontStretch: G,
            fontSize: y,
            lineHeight: Z,
            fontFamily: X
          } = this;
          return `${h} ${Y} ${p} ${G} ${y}px/${Z}px ${X}`;
        }
        set font(h) {
          if (h == null)
            this.fontStyle = null, this.fontVariant = null, this.fontWeight = null, this.fontStretch = null, this.fontSize = null, this.lineHeight = null, this.fontFamily = null;
          else {
            const Y = Object(i.parseFont)(h);
            this.fontStyle = Y.style, this.fontVariant = Y.variant, this.fontWeight = Y.weight, this.fontStretch = Y.stretch, this.fontSize = Object(b.toNumber)(`${Y.size}${Y.unit}`), Y.lineHeight && (this.lineHeight = Y.pxLineHeight), this.fontFamily = Y.family;
          }
        }
      }
    },
    /* 250 */
    /***/
    function(s, l, d) {
      d.r(l), d.d(l, "default", function() {
        return h;
      });
      var i = d(12), b = d(219), m = d(251), o = d(213), n = d(252);
      d(1).glMatrix.setMatrixArrayType(Array);
      function W(Y, p, G) {
        return p in Y ? Object.defineProperty(Y, p, { value: G, enumerable: !0, configurable: !0, writable: !0 }) : Y[p] = G, Y;
      }
      const e = Symbol("zOrder"), I = Symbol("ordered"), a = Symbol("children"), V = Symbol("sealed");
      class h extends b.default {
        constructor(p = {}) {
          super(p), this[a] = [], this[I] = null, this[e] = 0;
        }
        get childNodes() {
          return this[a];
        }
        get children() {
          return this[a];
        }
        get orderedChildren() {
          return this[I] || (this[I] = [...this[a]], this[I].sort((p, G) => p.zIndex - G.zIndex || p.zOrder - G.zOrder)), this[I];
        }
        append(...p) {
          return p.map((G) => this.appendChild(G));
        }
        appendChild(p) {
          return p.remove(), this[a].push(p), p.connect(this, this[e]++), this[I] && (this[I].length && p.zIndex < this[I][this[I].length - 1].zIndex ? this.reorder() : this[I].push(p)), p;
        }
        /* override */
        // get isVisible() {
        //   return this.attributes.opacity > 0 && this[_children].length > 0;
        // }
        /* override */
        cloneNode(p = !1) {
          const G = super.cloneNode();
          return p && this[a].forEach((y) => {
            const Z = y.cloneNode(p);
            G.appendChild(Z);
          }), G;
        }
        /* override */
        dispatchPointerEvent(p) {
          const G = this.orderedChildren;
          for (let y = G.length - 1; y >= 0; y--)
            if (G[y].dispatchPointerEvent(p))
              return !0;
          return super.dispatchPointerEvent(p);
        }
        /* override */
        draw(p = []) {
          if (this.__cacheRenderMatrix = this.renderMatrix, super.draw(p), !this[V] && this.attributes.display !== "none") {
            const G = this.orderedChildren;
            for (let y = 0; y < G.length; y++)
              G[y].draw(p);
          }
          return this.__cacheRenderMatrix = null, p;
        }
        getElementById(p) {
          return Object(n.querySelector)(`#${p}`, this);
        }
        getElementsByClassName(p) {
          return Object(n.querySelectorAll)(`.${p}`, this);
        }
        getElementsByName(p) {
          return Object(n.querySelectorAll)(`[name="${p}"]`, this);
        }
        getElementsByTagName(p) {
          return Object(n.querySelectorAll)(p, this);
        }
        insertBefore(p, G) {
          if (G == null)
            return this.appendChild(p);
          p.remove();
          const y = this[a].indexOf(G);
          if (y < 0)
            throw new Error("Invalid reference node.");
          const Z = G.zOrder;
          for (let X = y; X < this[a].length; X++) {
            const c = this[a][X].zOrder, t = this[a][X];
            delete t.zOrder, Object.defineProperty(t, "zOrder", {
              value: c + 1,
              writable: !1,
              configurable: !0
            });
          }
          if (this[a].splice(y, 0, p), p.connect(this, Z), this[I])
            if (p.zIndex !== G.zIndex)
              this.reorder();
            else {
              const X = this[I].indexOf(G);
              this[I].splice(X, 0, p);
            }
          return p;
        }
        querySelector(p) {
          return Object(n.querySelector)(p, this);
        }
        querySelectorAll(p) {
          return Object(n.querySelectorAll)(p, this);
        }
        replaceChild(p, G) {
          p.remove();
          const y = this[a].indexOf(G);
          if (y < 0)
            throw new Error("Invalid reference node.");
          if (this[a][y] = p, p.connect(this, G.zOrder), this[I])
            if (p.zIndex !== G.zIndex)
              this.reorder();
            else {
              const Z = this[I].indexOf(G);
              this[I][Z] = p;
            }
          return G.disconnect(this), p;
        }
        removeAllChildren() {
          const p = this[a];
          for (let G = p.length - 1; G >= 0; G--)
            p[G].remove();
        }
        removeChild(p) {
          const G = this[a].indexOf(p);
          if (G >= 0) {
            if (this[a].splice(G, 1), this[I]) {
              const y = this[I].indexOf(p);
              this[I].splice(y, 1);
            }
            return p.disconnect(this), p;
          }
          return null;
        }
        reorder() {
          this[I] = null;
        }
        seal() {
          function p(X, c) {
            const t = [];
            for (let R = 0; R < X.length; R++) {
              const S = [...X[R]];
              for (let J = 1; J < S.length; J += 2) {
                const H = S[J], L = S[J + 1];
                S[J] = H * c[0] + L * c[2] + c[4], S[J + 1] = H * c[1] + L * c[3] + c[5];
              }
              t.push(S);
            }
            return t;
          }
          const G = this.orderedChildren, y = new i.Figure2D(), Z = this.localMatrix;
          for (let X = 0; X < G.length; X++) {
            let c = G[X];
            if (c instanceof h && (c = c.seal()), c.clientBox) {
              let t = c.clientBox.contours.path;
              t = p(t, c.localMatrix), y.addPath(t);
            }
            if (c.path) {
              let t = c.path.contours.path;
              t = p(t, c.localMatrix), y.addPath(t);
            }
          }
          return this[V] = !0, this.clientBox = y, {
            clientBox: y,
            localMatrix: Z
          };
        }
        /* override */
        setResolution({
          width: p,
          height: G
        }) {
          super.setResolution({
            width: p,
            height: G
          }), this[a].forEach((y) => {
            y.setResolution({
              width: p,
              height: G
            });
          });
        }
        /* override */
        updateContours() {
          this[V] || super.updateContours();
        }
      }
      W(h, "Attr", m.default), o.default.registerNode(h, "group");
    },
    /* 251 */
    /***/
    function(s, l, d) {
      d.r(l), d.d(l, "default", function() {
        return b;
      });
      var i = d(220);
      d(1).glMatrix.setMatrixArrayType(Array);
      class b extends i.default {
        // constructor(subject) {
        //   super(subject);
        //   this[setDefault]({
        //     pointerEvents: 'all',
        //   });
        // }
      }
    },
    /* 252 */
    /***/
    function(s, l, d) {
      d.r(l), d.d(l, "querySelectorAll", function() {
        return V;
      }), d.d(l, "querySelector", function() {
        return h;
      }), d.d(l, "isMatched", function() {
        return Y;
      }), d.d(l, "compile", function() {
        return p;
      });
      var i = d(221), b = d(213);
      d(1).glMatrix.setMatrixArrayType(Array);
      const m = d(253);
      function o(G) {
        return G.nodeType === 1 || b.default.isSpriteNode(G.nodeName);
      }
      function n(G) {
        return Array.from(G.childNodes || []);
      }
      function W(G) {
        return b.default.isSpriteNode(G.nodeName) ? G.parent || G.canvas || G.container : G.parentElement;
      }
      function e(G) {
        let y = G.length, Z, X, c;
        for (; --y > -1; ) {
          for (Z = X = G[y], G[y] = null, c = !0; X; ) {
            if (G.indexOf(X) > -1) {
              c = !1, G.splice(y, 1);
              break;
            }
            X = W(X);
          }
          c && (G[y] = Z);
        }
        return G;
      }
      const I = {
        isTag: o,
        existsOne(G, y) {
          return y.some((Z) => o(Z) ? G(Z) || I.existsOne(G, n(Z)) : !1);
        },
        getSiblings(G) {
          const y = W(G);
          return y && n(y);
        },
        getChildren: n,
        getParent: W,
        getAttributeValue(G, y) {
          if (G.nodeType === 1 && y === "class" || y === "id")
            return G[y];
          if (this.hasAttrib(G, y)) {
            let Z = G.attributes[y];
            return Array.isArray(Z) && (Z = `[${Z.join()}]`), String(Z);
          }
        },
        hasAttrib(G, y) {
          return G.attributes[y] != null;
        },
        removeSubsets: e,
        getName(G) {
          return G.tagName ? G.tagName.toLowerCase() : null;
        },
        findOne: function G(y, Z) {
          let X = null;
          for (let c = 0, t = Z.length; c < t && !X; c++)
            if (y(Z[c]))
              X = Z[c];
            else {
              const R = n(Z[c]);
              R && R.length > 0 && (X = G(y, R));
            }
          return X;
        },
        findAll: function G(y, Z) {
          let X = [];
          for (let c = 0, t = Z.length; c < t; c++) {
            if (!o(Z[c]))
              continue;
            y(Z[c]) && X.push(Z[c]);
            const R = n(Z[c]);
            R && (X = X.concat(G(y, R)));
          }
          return X;
        },
        getText: function G(y) {
          return Array.isArray(y) ? y.map(G).join("") : o(y) ? G(n(y)) : y.nodeType === 3 ? y.nodeValue : b.default.isSpriteNode(y.nodeName) ? y.text : "";
        }
      };
      function a(G) {
        if (typeof G != "string")
          return G;
        let y = G.match(/\[(bgcolor|fillColor|strokeColor|color)\s*=\s*['"]?\w+['"]?\]/g);
        return y && (y = y.map((Z) => {
          const X = Z.slice(1, -1).split("="), c = Object(i.parseColor)(X[1].replace(/['"]/g, ""));
          return [Z, `[${X[0]}="${c}"]`];
        }), y.forEach(([Z, X]) => {
          G = G.replace(Z, X);
        })), y = G.match(/\[\w+\s*=\s*['"]\[.+?\]['"]\]/g), y && (y = y.map((Z) => {
          const X = Z.slice(1, -1).split("="), c = X[1].slice(2, -2).split(/,/g).map((t) => t.trim());
          return [Z, `[${X[0]}="[${c}]"]`];
        }), y.forEach(([Z, X]) => {
          G = G.replace(Z, X);
        })), G;
      }
      function V(G, y) {
        return m.selectAll(a(G), y, {
          adapter: I
        });
      }
      function h(G, y) {
        return m.selectOne(a(G), y, {
          adapter: I
        });
      }
      function Y(G, y) {
        return m.is(G, a(y), {
          adapter: I
        });
      }
      function p(G) {
        return m.compile(a(G), {
          adapter: I
        });
      }
    },
    /* 253 */
    /***/
    function(s, l, d) {
      s.exports = p;
      var i = d(254), b = d(273).falseFunc, m = d(274);
      function o(G) {
        return function(Z, X, c) {
          return X = X || {}, X.adapter = X.adapter || i, G(Z, X, c);
        };
      }
      var n = o(m), W = o(m.compileUnsafe);
      function e(G) {
        return function(Z, X, c) {
          return c = c || {}, c.adapter = c.adapter || i, typeof Z != "function" && (Z = W(Z, c, X)), Z.shouldTestNextSiblings && (X = a(c && c.context || X, c.adapter)), Array.isArray(X) ? X = c.adapter.removeSubsets(X) : X = c.adapter.getChildren(X), G(Z, X, c);
        };
      }
      function I(G, y) {
        var Z = y.getSiblings(G);
        if (!Array.isArray(Z))
          return [];
        for (Z = Z.slice(0); Z.shift() !== G; )
          ;
        return Z;
      }
      function a(G, y) {
        Array.isArray(G) || (G = [G]);
        for (var Z = G.slice(0), X = 0, c = G.length; X < c; X++) {
          var t = I(Z[X], y);
          Z.push.apply(Z, t);
        }
        return Z;
      }
      var V = e(function(y, Z, X) {
        return y === b || !Z || Z.length === 0 ? [] : X.adapter.findAll(y, Z);
      }), h = e(function(y, Z, X) {
        return y === b || !Z || Z.length === 0 ? null : X.adapter.findOne(y, Z);
      });
      function Y(G, y, Z) {
        return Z = Z || {}, Z.adapter = Z.adapter || i, (typeof y == "function" ? y : n(y, Z))(G);
      }
      function p(G, y, Z) {
        return V(G, y, Z);
      }
      p.compile = n, p.filters = m.Pseudos.filters, p.pseudos = m.Pseudos.pseudos, p.selectAll = V, p.selectOne = h, p.is = Y, p.parse = n, p.iterate = V, p._compileUnsafe = W, p._compileToken = m.compileToken;
    },
    /* 254 */
    /***/
    function(s, l, d) {
      var i = s.exports;
      [
        d(255),
        d(268),
        d(269),
        d(270),
        d(271),
        d(272)
      ].forEach(function(b) {
        Object.keys(b).forEach(function(m) {
          i[m] = b[m].bind(i);
        });
      });
    },
    /* 255 */
    /***/
    function(s, l, d) {
      var i = d(256), b = d(257), m = i.isTag;
      s.exports = {
        getInnerHTML: o,
        getOuterHTML: b,
        getText: n
      };
      function o(W, e) {
        return W.children ? W.children.map(function(I) {
          return b(I, e);
        }).join("") : "";
      }
      function n(W) {
        return Array.isArray(W) ? W.map(n).join("") : m(W) ? W.name === "br" ? `
` : n(W.children) : W.type === i.CDATA ? n(W.children) : W.type === i.Text ? W.data : "";
      }
    },
    /* 256 */
    /***/
    function(s, l) {
      s.exports = {
        Text: "text",
        //Text
        Directive: "directive",
        //<? ... ?>
        Comment: "comment",
        //<!-- ... -->
        Script: "script",
        //<script> tags
        Style: "style",
        //<style> tags
        Tag: "tag",
        //Any tag
        CDATA: "cdata",
        //<![CDATA[ ... ]]>
        Doctype: "doctype",
        isTag: function(d) {
          return d.type === "tag" || d.type === "script" || d.type === "style";
        }
      };
    },
    /* 257 */
    /***/
    function(s, l, d) {
      var i = d(258), b = d(259), m = d(267);
      m.elementNames.__proto__ = null, m.attributeNames.__proto__ = null;
      var o = {
        __proto__: null,
        style: !0,
        script: !0,
        xmp: !0,
        iframe: !0,
        noembed: !0,
        noframes: !0,
        plaintext: !0,
        noscript: !0
      };
      function n(G, y) {
        if (G) {
          var Z = "", X;
          for (var c in G)
            X = G[c], Z && (Z += " "), y.xmlMode === "foreign" && (c = m.attributeNames[c] || c), Z += c, (X !== null && X !== "" || y.xmlMode) && (Z += '="' + (y.decodeEntities ? b.encodeXML(X) : X.replace(/\"/g, "&quot;")) + '"');
          return Z;
        }
      }
      var W = {
        __proto__: null,
        area: !0,
        base: !0,
        basefont: !0,
        br: !0,
        col: !0,
        command: !0,
        embed: !0,
        frame: !0,
        hr: !0,
        img: !0,
        input: !0,
        isindex: !0,
        keygen: !0,
        link: !0,
        meta: !0,
        param: !0,
        source: !0,
        track: !0,
        wbr: !0
      }, e = s.exports = function(G, y) {
        !Array.isArray(G) && !G.cheerio && (G = [G]), y = y || {};
        for (var Z = "", X = 0; X < G.length; X++) {
          var c = G[X];
          c.type === "root" ? Z += e(c.children, y) : i.isTag(c) ? Z += a(c, y) : c.type === i.Directive ? Z += V(c) : c.type === i.Comment ? Z += p(c) : c.type === i.CDATA ? Z += Y(c) : Z += h(c, y);
        }
        return Z;
      }, I = [
        "mi",
        "mo",
        "mn",
        "ms",
        "mtext",
        "annotation-xml",
        "foreignObject",
        "desc",
        "title"
      ];
      function a(G, y) {
        y.xmlMode === "foreign" && (G.name = m.elementNames[G.name] || G.name, G.parent && I.indexOf(G.parent.name) >= 0 && (y = Object.assign({}, y, { xmlMode: !1 }))), !y.xmlMode && ["svg", "math"].indexOf(G.name) >= 0 && (y = Object.assign({}, y, { xmlMode: "foreign" }));
        var Z = "<" + G.name, X = n(G.attribs, y);
        return X && (Z += " " + X), y.xmlMode && (!G.children || G.children.length === 0) ? Z += "/>" : (Z += ">", G.children && (Z += e(G.children, y)), (!W[G.name] || y.xmlMode) && (Z += "</" + G.name + ">")), Z;
      }
      function V(G) {
        return "<" + G.data + ">";
      }
      function h(G, y) {
        var Z = G.data || "";
        return y.decodeEntities && !(G.parent && G.parent.name in o) && (Z = b.encodeXML(Z)), Z;
      }
      function Y(G) {
        return "<![CDATA[" + G.children[0].data + "]]>";
      }
      function p(G) {
        return "<!--" + G.data + "-->";
      }
    },
    /* 258 */
    /***/
    function(s, l, d) {
      Object.defineProperty(l, "__esModule", { value: !0 });
      function i(b) {
        return b.type === "tag" || b.type === "script" || b.type === "style";
      }
      l.isTag = i, l.Text = "text", l.Directive = "directive", l.Comment = "comment", l.Script = "script", l.Style = "style", l.Tag = "tag", l.CDATA = "cdata", l.Doctype = "doctype";
    },
    /* 259 */
    /***/
    function(s, l, d) {
      Object.defineProperty(l, "__esModule", { value: !0 }), l.encode = l.decodeStrict = l.decode = void 0;
      var i = d(260), b = d(266);
      function m(I, a) {
        return (!a || a <= 0 ? i.decodeXML : i.decodeHTML)(I);
      }
      l.decode = m;
      function o(I, a) {
        return (!a || a <= 0 ? i.decodeXML : i.decodeHTMLStrict)(I);
      }
      l.decodeStrict = o;
      function n(I, a) {
        return (!a || a <= 0 ? b.encodeXML : b.encodeHTML)(I);
      }
      l.encode = n;
      var W = d(266);
      Object.defineProperty(l, "encodeXML", { enumerable: !0, get: function() {
        return W.encodeXML;
      } }), Object.defineProperty(l, "encodeHTML", { enumerable: !0, get: function() {
        return W.encodeHTML;
      } }), Object.defineProperty(l, "escape", { enumerable: !0, get: function() {
        return W.escape;
      } }), Object.defineProperty(l, "encodeHTML4", { enumerable: !0, get: function() {
        return W.encodeHTML;
      } }), Object.defineProperty(l, "encodeHTML5", { enumerable: !0, get: function() {
        return W.encodeHTML;
      } });
      var e = d(260);
      Object.defineProperty(l, "decodeXML", { enumerable: !0, get: function() {
        return e.decodeXML;
      } }), Object.defineProperty(l, "decodeHTML", { enumerable: !0, get: function() {
        return e.decodeHTML;
      } }), Object.defineProperty(l, "decodeHTMLStrict", { enumerable: !0, get: function() {
        return e.decodeHTMLStrict;
      } }), Object.defineProperty(l, "decodeHTML4", { enumerable: !0, get: function() {
        return e.decodeHTML;
      } }), Object.defineProperty(l, "decodeHTML5", { enumerable: !0, get: function() {
        return e.decodeHTML;
      } }), Object.defineProperty(l, "decodeHTML4Strict", { enumerable: !0, get: function() {
        return e.decodeHTMLStrict;
      } }), Object.defineProperty(l, "decodeHTML5Strict", { enumerable: !0, get: function() {
        return e.decodeHTMLStrict;
      } }), Object.defineProperty(l, "decodeXMLStrict", { enumerable: !0, get: function() {
        return e.decodeXML;
      } });
    },
    /* 260 */
    /***/
    function(s, l, d) {
      var i = this && this.__importDefault || function(a) {
        return a && a.__esModule ? a : { default: a };
      };
      Object.defineProperty(l, "__esModule", { value: !0 }), l.decodeHTML = l.decodeHTMLStrict = l.decodeXML = void 0;
      var b = i(d(261)), m = i(d(262)), o = i(d(263)), n = i(d(264));
      l.decodeXML = W(o.default), l.decodeHTMLStrict = W(b.default);
      function W(a) {
        var V = Object.keys(a).join("|"), h = I(a);
        V += "|#[xX][\\da-fA-F]+|#\\d+";
        var Y = new RegExp("&(?:" + V + ");", "g");
        return function(p) {
          return String(p).replace(Y, h);
        };
      }
      var e = function(a, V) {
        return a < V ? 1 : -1;
      };
      l.decodeHTML = function() {
        for (var a = Object.keys(m.default).sort(e), V = Object.keys(b.default).sort(e), h = 0, Y = 0; h < V.length; h++)
          a[Y] === V[h] ? (V[h] += ";?", Y++) : V[h] += ";";
        var p = new RegExp("&(?:" + V.join("|") + "|#[xX][\\da-fA-F]+;?|#\\d+;?)", "g"), G = I(b.default);
        function y(Z) {
          return Z.substr(-1) !== ";" && (Z += ";"), G(Z);
        }
        return function(Z) {
          return String(Z).replace(p, y);
        };
      }();
      function I(a) {
        return function(h) {
          if (h.charAt(1) === "#") {
            var Y = h.charAt(2);
            return Y === "X" || Y === "x" ? n.default(parseInt(h.substr(3), 16)) : n.default(parseInt(h.substr(2), 10));
          }
          return a[h.slice(1, -1)];
        };
      }
    },
    /* 261 */
    /***/
    function(s) {
      s.exports = JSON.parse('{"Aacute":"Á","aacute":"á","Abreve":"Ă","abreve":"ă","ac":"∾","acd":"∿","acE":"∾̳","Acirc":"Â","acirc":"â","acute":"´","Acy":"А","acy":"а","AElig":"Æ","aelig":"æ","af":"⁡","Afr":"𝔄","afr":"𝔞","Agrave":"À","agrave":"à","alefsym":"ℵ","aleph":"ℵ","Alpha":"Α","alpha":"α","Amacr":"Ā","amacr":"ā","amalg":"⨿","amp":"&","AMP":"&","andand":"⩕","And":"⩓","and":"∧","andd":"⩜","andslope":"⩘","andv":"⩚","ang":"∠","ange":"⦤","angle":"∠","angmsdaa":"⦨","angmsdab":"⦩","angmsdac":"⦪","angmsdad":"⦫","angmsdae":"⦬","angmsdaf":"⦭","angmsdag":"⦮","angmsdah":"⦯","angmsd":"∡","angrt":"∟","angrtvb":"⊾","angrtvbd":"⦝","angsph":"∢","angst":"Å","angzarr":"⍼","Aogon":"Ą","aogon":"ą","Aopf":"𝔸","aopf":"𝕒","apacir":"⩯","ap":"≈","apE":"⩰","ape":"≊","apid":"≋","apos":"\'","ApplyFunction":"⁡","approx":"≈","approxeq":"≊","Aring":"Å","aring":"å","Ascr":"𝒜","ascr":"𝒶","Assign":"≔","ast":"*","asymp":"≈","asympeq":"≍","Atilde":"Ã","atilde":"ã","Auml":"Ä","auml":"ä","awconint":"∳","awint":"⨑","backcong":"≌","backepsilon":"϶","backprime":"‵","backsim":"∽","backsimeq":"⋍","Backslash":"∖","Barv":"⫧","barvee":"⊽","barwed":"⌅","Barwed":"⌆","barwedge":"⌅","bbrk":"⎵","bbrktbrk":"⎶","bcong":"≌","Bcy":"Б","bcy":"б","bdquo":"„","becaus":"∵","because":"∵","Because":"∵","bemptyv":"⦰","bepsi":"϶","bernou":"ℬ","Bernoullis":"ℬ","Beta":"Β","beta":"β","beth":"ℶ","between":"≬","Bfr":"𝔅","bfr":"𝔟","bigcap":"⋂","bigcirc":"◯","bigcup":"⋃","bigodot":"⨀","bigoplus":"⨁","bigotimes":"⨂","bigsqcup":"⨆","bigstar":"★","bigtriangledown":"▽","bigtriangleup":"△","biguplus":"⨄","bigvee":"⋁","bigwedge":"⋀","bkarow":"⤍","blacklozenge":"⧫","blacksquare":"▪","blacktriangle":"▴","blacktriangledown":"▾","blacktriangleleft":"◂","blacktriangleright":"▸","blank":"␣","blk12":"▒","blk14":"░","blk34":"▓","block":"█","bne":"=⃥","bnequiv":"≡⃥","bNot":"⫭","bnot":"⌐","Bopf":"𝔹","bopf":"𝕓","bot":"⊥","bottom":"⊥","bowtie":"⋈","boxbox":"⧉","boxdl":"┐","boxdL":"╕","boxDl":"╖","boxDL":"╗","boxdr":"┌","boxdR":"╒","boxDr":"╓","boxDR":"╔","boxh":"─","boxH":"═","boxhd":"┬","boxHd":"╤","boxhD":"╥","boxHD":"╦","boxhu":"┴","boxHu":"╧","boxhU":"╨","boxHU":"╩","boxminus":"⊟","boxplus":"⊞","boxtimes":"⊠","boxul":"┘","boxuL":"╛","boxUl":"╜","boxUL":"╝","boxur":"└","boxuR":"╘","boxUr":"╙","boxUR":"╚","boxv":"│","boxV":"║","boxvh":"┼","boxvH":"╪","boxVh":"╫","boxVH":"╬","boxvl":"┤","boxvL":"╡","boxVl":"╢","boxVL":"╣","boxvr":"├","boxvR":"╞","boxVr":"╟","boxVR":"╠","bprime":"‵","breve":"˘","Breve":"˘","brvbar":"¦","bscr":"𝒷","Bscr":"ℬ","bsemi":"⁏","bsim":"∽","bsime":"⋍","bsolb":"⧅","bsol":"\\\\","bsolhsub":"⟈","bull":"•","bullet":"•","bump":"≎","bumpE":"⪮","bumpe":"≏","Bumpeq":"≎","bumpeq":"≏","Cacute":"Ć","cacute":"ć","capand":"⩄","capbrcup":"⩉","capcap":"⩋","cap":"∩","Cap":"⋒","capcup":"⩇","capdot":"⩀","CapitalDifferentialD":"ⅅ","caps":"∩︀","caret":"⁁","caron":"ˇ","Cayleys":"ℭ","ccaps":"⩍","Ccaron":"Č","ccaron":"č","Ccedil":"Ç","ccedil":"ç","Ccirc":"Ĉ","ccirc":"ĉ","Cconint":"∰","ccups":"⩌","ccupssm":"⩐","Cdot":"Ċ","cdot":"ċ","cedil":"¸","Cedilla":"¸","cemptyv":"⦲","cent":"¢","centerdot":"·","CenterDot":"·","cfr":"𝔠","Cfr":"ℭ","CHcy":"Ч","chcy":"ч","check":"✓","checkmark":"✓","Chi":"Χ","chi":"χ","circ":"ˆ","circeq":"≗","circlearrowleft":"↺","circlearrowright":"↻","circledast":"⊛","circledcirc":"⊚","circleddash":"⊝","CircleDot":"⊙","circledR":"®","circledS":"Ⓢ","CircleMinus":"⊖","CirclePlus":"⊕","CircleTimes":"⊗","cir":"○","cirE":"⧃","cire":"≗","cirfnint":"⨐","cirmid":"⫯","cirscir":"⧂","ClockwiseContourIntegral":"∲","CloseCurlyDoubleQuote":"”","CloseCurlyQuote":"’","clubs":"♣","clubsuit":"♣","colon":":","Colon":"∷","Colone":"⩴","colone":"≔","coloneq":"≔","comma":",","commat":"@","comp":"∁","compfn":"∘","complement":"∁","complexes":"ℂ","cong":"≅","congdot":"⩭","Congruent":"≡","conint":"∮","Conint":"∯","ContourIntegral":"∮","copf":"𝕔","Copf":"ℂ","coprod":"∐","Coproduct":"∐","copy":"©","COPY":"©","copysr":"℗","CounterClockwiseContourIntegral":"∳","crarr":"↵","cross":"✗","Cross":"⨯","Cscr":"𝒞","cscr":"𝒸","csub":"⫏","csube":"⫑","csup":"⫐","csupe":"⫒","ctdot":"⋯","cudarrl":"⤸","cudarrr":"⤵","cuepr":"⋞","cuesc":"⋟","cularr":"↶","cularrp":"⤽","cupbrcap":"⩈","cupcap":"⩆","CupCap":"≍","cup":"∪","Cup":"⋓","cupcup":"⩊","cupdot":"⊍","cupor":"⩅","cups":"∪︀","curarr":"↷","curarrm":"⤼","curlyeqprec":"⋞","curlyeqsucc":"⋟","curlyvee":"⋎","curlywedge":"⋏","curren":"¤","curvearrowleft":"↶","curvearrowright":"↷","cuvee":"⋎","cuwed":"⋏","cwconint":"∲","cwint":"∱","cylcty":"⌭","dagger":"†","Dagger":"‡","daleth":"ℸ","darr":"↓","Darr":"↡","dArr":"⇓","dash":"‐","Dashv":"⫤","dashv":"⊣","dbkarow":"⤏","dblac":"˝","Dcaron":"Ď","dcaron":"ď","Dcy":"Д","dcy":"д","ddagger":"‡","ddarr":"⇊","DD":"ⅅ","dd":"ⅆ","DDotrahd":"⤑","ddotseq":"⩷","deg":"°","Del":"∇","Delta":"Δ","delta":"δ","demptyv":"⦱","dfisht":"⥿","Dfr":"𝔇","dfr":"𝔡","dHar":"⥥","dharl":"⇃","dharr":"⇂","DiacriticalAcute":"´","DiacriticalDot":"˙","DiacriticalDoubleAcute":"˝","DiacriticalGrave":"`","DiacriticalTilde":"˜","diam":"⋄","diamond":"⋄","Diamond":"⋄","diamondsuit":"♦","diams":"♦","die":"¨","DifferentialD":"ⅆ","digamma":"ϝ","disin":"⋲","div":"÷","divide":"÷","divideontimes":"⋇","divonx":"⋇","DJcy":"Ђ","djcy":"ђ","dlcorn":"⌞","dlcrop":"⌍","dollar":"$","Dopf":"𝔻","dopf":"𝕕","Dot":"¨","dot":"˙","DotDot":"⃜","doteq":"≐","doteqdot":"≑","DotEqual":"≐","dotminus":"∸","dotplus":"∔","dotsquare":"⊡","doublebarwedge":"⌆","DoubleContourIntegral":"∯","DoubleDot":"¨","DoubleDownArrow":"⇓","DoubleLeftArrow":"⇐","DoubleLeftRightArrow":"⇔","DoubleLeftTee":"⫤","DoubleLongLeftArrow":"⟸","DoubleLongLeftRightArrow":"⟺","DoubleLongRightArrow":"⟹","DoubleRightArrow":"⇒","DoubleRightTee":"⊨","DoubleUpArrow":"⇑","DoubleUpDownArrow":"⇕","DoubleVerticalBar":"∥","DownArrowBar":"⤓","downarrow":"↓","DownArrow":"↓","Downarrow":"⇓","DownArrowUpArrow":"⇵","DownBreve":"̑","downdownarrows":"⇊","downharpoonleft":"⇃","downharpoonright":"⇂","DownLeftRightVector":"⥐","DownLeftTeeVector":"⥞","DownLeftVectorBar":"⥖","DownLeftVector":"↽","DownRightTeeVector":"⥟","DownRightVectorBar":"⥗","DownRightVector":"⇁","DownTeeArrow":"↧","DownTee":"⊤","drbkarow":"⤐","drcorn":"⌟","drcrop":"⌌","Dscr":"𝒟","dscr":"𝒹","DScy":"Ѕ","dscy":"ѕ","dsol":"⧶","Dstrok":"Đ","dstrok":"đ","dtdot":"⋱","dtri":"▿","dtrif":"▾","duarr":"⇵","duhar":"⥯","dwangle":"⦦","DZcy":"Џ","dzcy":"џ","dzigrarr":"⟿","Eacute":"É","eacute":"é","easter":"⩮","Ecaron":"Ě","ecaron":"ě","Ecirc":"Ê","ecirc":"ê","ecir":"≖","ecolon":"≕","Ecy":"Э","ecy":"э","eDDot":"⩷","Edot":"Ė","edot":"ė","eDot":"≑","ee":"ⅇ","efDot":"≒","Efr":"𝔈","efr":"𝔢","eg":"⪚","Egrave":"È","egrave":"è","egs":"⪖","egsdot":"⪘","el":"⪙","Element":"∈","elinters":"⏧","ell":"ℓ","els":"⪕","elsdot":"⪗","Emacr":"Ē","emacr":"ē","empty":"∅","emptyset":"∅","EmptySmallSquare":"◻","emptyv":"∅","EmptyVerySmallSquare":"▫","emsp13":" ","emsp14":" ","emsp":" ","ENG":"Ŋ","eng":"ŋ","ensp":" ","Eogon":"Ę","eogon":"ę","Eopf":"𝔼","eopf":"𝕖","epar":"⋕","eparsl":"⧣","eplus":"⩱","epsi":"ε","Epsilon":"Ε","epsilon":"ε","epsiv":"ϵ","eqcirc":"≖","eqcolon":"≕","eqsim":"≂","eqslantgtr":"⪖","eqslantless":"⪕","Equal":"⩵","equals":"=","EqualTilde":"≂","equest":"≟","Equilibrium":"⇌","equiv":"≡","equivDD":"⩸","eqvparsl":"⧥","erarr":"⥱","erDot":"≓","escr":"ℯ","Escr":"ℰ","esdot":"≐","Esim":"⩳","esim":"≂","Eta":"Η","eta":"η","ETH":"Ð","eth":"ð","Euml":"Ë","euml":"ë","euro":"€","excl":"!","exist":"∃","Exists":"∃","expectation":"ℰ","exponentiale":"ⅇ","ExponentialE":"ⅇ","fallingdotseq":"≒","Fcy":"Ф","fcy":"ф","female":"♀","ffilig":"ﬃ","fflig":"ﬀ","ffllig":"ﬄ","Ffr":"𝔉","ffr":"𝔣","filig":"ﬁ","FilledSmallSquare":"◼","FilledVerySmallSquare":"▪","fjlig":"fj","flat":"♭","fllig":"ﬂ","fltns":"▱","fnof":"ƒ","Fopf":"𝔽","fopf":"𝕗","forall":"∀","ForAll":"∀","fork":"⋔","forkv":"⫙","Fouriertrf":"ℱ","fpartint":"⨍","frac12":"½","frac13":"⅓","frac14":"¼","frac15":"⅕","frac16":"⅙","frac18":"⅛","frac23":"⅔","frac25":"⅖","frac34":"¾","frac35":"⅗","frac38":"⅜","frac45":"⅘","frac56":"⅚","frac58":"⅝","frac78":"⅞","frasl":"⁄","frown":"⌢","fscr":"𝒻","Fscr":"ℱ","gacute":"ǵ","Gamma":"Γ","gamma":"γ","Gammad":"Ϝ","gammad":"ϝ","gap":"⪆","Gbreve":"Ğ","gbreve":"ğ","Gcedil":"Ģ","Gcirc":"Ĝ","gcirc":"ĝ","Gcy":"Г","gcy":"г","Gdot":"Ġ","gdot":"ġ","ge":"≥","gE":"≧","gEl":"⪌","gel":"⋛","geq":"≥","geqq":"≧","geqslant":"⩾","gescc":"⪩","ges":"⩾","gesdot":"⪀","gesdoto":"⪂","gesdotol":"⪄","gesl":"⋛︀","gesles":"⪔","Gfr":"𝔊","gfr":"𝔤","gg":"≫","Gg":"⋙","ggg":"⋙","gimel":"ℷ","GJcy":"Ѓ","gjcy":"ѓ","gla":"⪥","gl":"≷","glE":"⪒","glj":"⪤","gnap":"⪊","gnapprox":"⪊","gne":"⪈","gnE":"≩","gneq":"⪈","gneqq":"≩","gnsim":"⋧","Gopf":"𝔾","gopf":"𝕘","grave":"`","GreaterEqual":"≥","GreaterEqualLess":"⋛","GreaterFullEqual":"≧","GreaterGreater":"⪢","GreaterLess":"≷","GreaterSlantEqual":"⩾","GreaterTilde":"≳","Gscr":"𝒢","gscr":"ℊ","gsim":"≳","gsime":"⪎","gsiml":"⪐","gtcc":"⪧","gtcir":"⩺","gt":">","GT":">","Gt":"≫","gtdot":"⋗","gtlPar":"⦕","gtquest":"⩼","gtrapprox":"⪆","gtrarr":"⥸","gtrdot":"⋗","gtreqless":"⋛","gtreqqless":"⪌","gtrless":"≷","gtrsim":"≳","gvertneqq":"≩︀","gvnE":"≩︀","Hacek":"ˇ","hairsp":" ","half":"½","hamilt":"ℋ","HARDcy":"Ъ","hardcy":"ъ","harrcir":"⥈","harr":"↔","hArr":"⇔","harrw":"↭","Hat":"^","hbar":"ℏ","Hcirc":"Ĥ","hcirc":"ĥ","hearts":"♥","heartsuit":"♥","hellip":"…","hercon":"⊹","hfr":"𝔥","Hfr":"ℌ","HilbertSpace":"ℋ","hksearow":"⤥","hkswarow":"⤦","hoarr":"⇿","homtht":"∻","hookleftarrow":"↩","hookrightarrow":"↪","hopf":"𝕙","Hopf":"ℍ","horbar":"―","HorizontalLine":"─","hscr":"𝒽","Hscr":"ℋ","hslash":"ℏ","Hstrok":"Ħ","hstrok":"ħ","HumpDownHump":"≎","HumpEqual":"≏","hybull":"⁃","hyphen":"‐","Iacute":"Í","iacute":"í","ic":"⁣","Icirc":"Î","icirc":"î","Icy":"И","icy":"и","Idot":"İ","IEcy":"Е","iecy":"е","iexcl":"¡","iff":"⇔","ifr":"𝔦","Ifr":"ℑ","Igrave":"Ì","igrave":"ì","ii":"ⅈ","iiiint":"⨌","iiint":"∭","iinfin":"⧜","iiota":"℩","IJlig":"Ĳ","ijlig":"ĳ","Imacr":"Ī","imacr":"ī","image":"ℑ","ImaginaryI":"ⅈ","imagline":"ℐ","imagpart":"ℑ","imath":"ı","Im":"ℑ","imof":"⊷","imped":"Ƶ","Implies":"⇒","incare":"℅","in":"∈","infin":"∞","infintie":"⧝","inodot":"ı","intcal":"⊺","int":"∫","Int":"∬","integers":"ℤ","Integral":"∫","intercal":"⊺","Intersection":"⋂","intlarhk":"⨗","intprod":"⨼","InvisibleComma":"⁣","InvisibleTimes":"⁢","IOcy":"Ё","iocy":"ё","Iogon":"Į","iogon":"į","Iopf":"𝕀","iopf":"𝕚","Iota":"Ι","iota":"ι","iprod":"⨼","iquest":"¿","iscr":"𝒾","Iscr":"ℐ","isin":"∈","isindot":"⋵","isinE":"⋹","isins":"⋴","isinsv":"⋳","isinv":"∈","it":"⁢","Itilde":"Ĩ","itilde":"ĩ","Iukcy":"І","iukcy":"і","Iuml":"Ï","iuml":"ï","Jcirc":"Ĵ","jcirc":"ĵ","Jcy":"Й","jcy":"й","Jfr":"𝔍","jfr":"𝔧","jmath":"ȷ","Jopf":"𝕁","jopf":"𝕛","Jscr":"𝒥","jscr":"𝒿","Jsercy":"Ј","jsercy":"ј","Jukcy":"Є","jukcy":"є","Kappa":"Κ","kappa":"κ","kappav":"ϰ","Kcedil":"Ķ","kcedil":"ķ","Kcy":"К","kcy":"к","Kfr":"𝔎","kfr":"𝔨","kgreen":"ĸ","KHcy":"Х","khcy":"х","KJcy":"Ќ","kjcy":"ќ","Kopf":"𝕂","kopf":"𝕜","Kscr":"𝒦","kscr":"𝓀","lAarr":"⇚","Lacute":"Ĺ","lacute":"ĺ","laemptyv":"⦴","lagran":"ℒ","Lambda":"Λ","lambda":"λ","lang":"⟨","Lang":"⟪","langd":"⦑","langle":"⟨","lap":"⪅","Laplacetrf":"ℒ","laquo":"«","larrb":"⇤","larrbfs":"⤟","larr":"←","Larr":"↞","lArr":"⇐","larrfs":"⤝","larrhk":"↩","larrlp":"↫","larrpl":"⤹","larrsim":"⥳","larrtl":"↢","latail":"⤙","lAtail":"⤛","lat":"⪫","late":"⪭","lates":"⪭︀","lbarr":"⤌","lBarr":"⤎","lbbrk":"❲","lbrace":"{","lbrack":"[","lbrke":"⦋","lbrksld":"⦏","lbrkslu":"⦍","Lcaron":"Ľ","lcaron":"ľ","Lcedil":"Ļ","lcedil":"ļ","lceil":"⌈","lcub":"{","Lcy":"Л","lcy":"л","ldca":"⤶","ldquo":"“","ldquor":"„","ldrdhar":"⥧","ldrushar":"⥋","ldsh":"↲","le":"≤","lE":"≦","LeftAngleBracket":"⟨","LeftArrowBar":"⇤","leftarrow":"←","LeftArrow":"←","Leftarrow":"⇐","LeftArrowRightArrow":"⇆","leftarrowtail":"↢","LeftCeiling":"⌈","LeftDoubleBracket":"⟦","LeftDownTeeVector":"⥡","LeftDownVectorBar":"⥙","LeftDownVector":"⇃","LeftFloor":"⌊","leftharpoondown":"↽","leftharpoonup":"↼","leftleftarrows":"⇇","leftrightarrow":"↔","LeftRightArrow":"↔","Leftrightarrow":"⇔","leftrightarrows":"⇆","leftrightharpoons":"⇋","leftrightsquigarrow":"↭","LeftRightVector":"⥎","LeftTeeArrow":"↤","LeftTee":"⊣","LeftTeeVector":"⥚","leftthreetimes":"⋋","LeftTriangleBar":"⧏","LeftTriangle":"⊲","LeftTriangleEqual":"⊴","LeftUpDownVector":"⥑","LeftUpTeeVector":"⥠","LeftUpVectorBar":"⥘","LeftUpVector":"↿","LeftVectorBar":"⥒","LeftVector":"↼","lEg":"⪋","leg":"⋚","leq":"≤","leqq":"≦","leqslant":"⩽","lescc":"⪨","les":"⩽","lesdot":"⩿","lesdoto":"⪁","lesdotor":"⪃","lesg":"⋚︀","lesges":"⪓","lessapprox":"⪅","lessdot":"⋖","lesseqgtr":"⋚","lesseqqgtr":"⪋","LessEqualGreater":"⋚","LessFullEqual":"≦","LessGreater":"≶","lessgtr":"≶","LessLess":"⪡","lesssim":"≲","LessSlantEqual":"⩽","LessTilde":"≲","lfisht":"⥼","lfloor":"⌊","Lfr":"𝔏","lfr":"𝔩","lg":"≶","lgE":"⪑","lHar":"⥢","lhard":"↽","lharu":"↼","lharul":"⥪","lhblk":"▄","LJcy":"Љ","ljcy":"љ","llarr":"⇇","ll":"≪","Ll":"⋘","llcorner":"⌞","Lleftarrow":"⇚","llhard":"⥫","lltri":"◺","Lmidot":"Ŀ","lmidot":"ŀ","lmoustache":"⎰","lmoust":"⎰","lnap":"⪉","lnapprox":"⪉","lne":"⪇","lnE":"≨","lneq":"⪇","lneqq":"≨","lnsim":"⋦","loang":"⟬","loarr":"⇽","lobrk":"⟦","longleftarrow":"⟵","LongLeftArrow":"⟵","Longleftarrow":"⟸","longleftrightarrow":"⟷","LongLeftRightArrow":"⟷","Longleftrightarrow":"⟺","longmapsto":"⟼","longrightarrow":"⟶","LongRightArrow":"⟶","Longrightarrow":"⟹","looparrowleft":"↫","looparrowright":"↬","lopar":"⦅","Lopf":"𝕃","lopf":"𝕝","loplus":"⨭","lotimes":"⨴","lowast":"∗","lowbar":"_","LowerLeftArrow":"↙","LowerRightArrow":"↘","loz":"◊","lozenge":"◊","lozf":"⧫","lpar":"(","lparlt":"⦓","lrarr":"⇆","lrcorner":"⌟","lrhar":"⇋","lrhard":"⥭","lrm":"‎","lrtri":"⊿","lsaquo":"‹","lscr":"𝓁","Lscr":"ℒ","lsh":"↰","Lsh":"↰","lsim":"≲","lsime":"⪍","lsimg":"⪏","lsqb":"[","lsquo":"‘","lsquor":"‚","Lstrok":"Ł","lstrok":"ł","ltcc":"⪦","ltcir":"⩹","lt":"<","LT":"<","Lt":"≪","ltdot":"⋖","lthree":"⋋","ltimes":"⋉","ltlarr":"⥶","ltquest":"⩻","ltri":"◃","ltrie":"⊴","ltrif":"◂","ltrPar":"⦖","lurdshar":"⥊","luruhar":"⥦","lvertneqq":"≨︀","lvnE":"≨︀","macr":"¯","male":"♂","malt":"✠","maltese":"✠","Map":"⤅","map":"↦","mapsto":"↦","mapstodown":"↧","mapstoleft":"↤","mapstoup":"↥","marker":"▮","mcomma":"⨩","Mcy":"М","mcy":"м","mdash":"—","mDDot":"∺","measuredangle":"∡","MediumSpace":" ","Mellintrf":"ℳ","Mfr":"𝔐","mfr":"𝔪","mho":"℧","micro":"µ","midast":"*","midcir":"⫰","mid":"∣","middot":"·","minusb":"⊟","minus":"−","minusd":"∸","minusdu":"⨪","MinusPlus":"∓","mlcp":"⫛","mldr":"…","mnplus":"∓","models":"⊧","Mopf":"𝕄","mopf":"𝕞","mp":"∓","mscr":"𝓂","Mscr":"ℳ","mstpos":"∾","Mu":"Μ","mu":"μ","multimap":"⊸","mumap":"⊸","nabla":"∇","Nacute":"Ń","nacute":"ń","nang":"∠⃒","nap":"≉","napE":"⩰̸","napid":"≋̸","napos":"ŉ","napprox":"≉","natural":"♮","naturals":"ℕ","natur":"♮","nbsp":" ","nbump":"≎̸","nbumpe":"≏̸","ncap":"⩃","Ncaron":"Ň","ncaron":"ň","Ncedil":"Ņ","ncedil":"ņ","ncong":"≇","ncongdot":"⩭̸","ncup":"⩂","Ncy":"Н","ncy":"н","ndash":"–","nearhk":"⤤","nearr":"↗","neArr":"⇗","nearrow":"↗","ne":"≠","nedot":"≐̸","NegativeMediumSpace":"​","NegativeThickSpace":"​","NegativeThinSpace":"​","NegativeVeryThinSpace":"​","nequiv":"≢","nesear":"⤨","nesim":"≂̸","NestedGreaterGreater":"≫","NestedLessLess":"≪","NewLine":"\\n","nexist":"∄","nexists":"∄","Nfr":"𝔑","nfr":"𝔫","ngE":"≧̸","nge":"≱","ngeq":"≱","ngeqq":"≧̸","ngeqslant":"⩾̸","nges":"⩾̸","nGg":"⋙̸","ngsim":"≵","nGt":"≫⃒","ngt":"≯","ngtr":"≯","nGtv":"≫̸","nharr":"↮","nhArr":"⇎","nhpar":"⫲","ni":"∋","nis":"⋼","nisd":"⋺","niv":"∋","NJcy":"Њ","njcy":"њ","nlarr":"↚","nlArr":"⇍","nldr":"‥","nlE":"≦̸","nle":"≰","nleftarrow":"↚","nLeftarrow":"⇍","nleftrightarrow":"↮","nLeftrightarrow":"⇎","nleq":"≰","nleqq":"≦̸","nleqslant":"⩽̸","nles":"⩽̸","nless":"≮","nLl":"⋘̸","nlsim":"≴","nLt":"≪⃒","nlt":"≮","nltri":"⋪","nltrie":"⋬","nLtv":"≪̸","nmid":"∤","NoBreak":"⁠","NonBreakingSpace":" ","nopf":"𝕟","Nopf":"ℕ","Not":"⫬","not":"¬","NotCongruent":"≢","NotCupCap":"≭","NotDoubleVerticalBar":"∦","NotElement":"∉","NotEqual":"≠","NotEqualTilde":"≂̸","NotExists":"∄","NotGreater":"≯","NotGreaterEqual":"≱","NotGreaterFullEqual":"≧̸","NotGreaterGreater":"≫̸","NotGreaterLess":"≹","NotGreaterSlantEqual":"⩾̸","NotGreaterTilde":"≵","NotHumpDownHump":"≎̸","NotHumpEqual":"≏̸","notin":"∉","notindot":"⋵̸","notinE":"⋹̸","notinva":"∉","notinvb":"⋷","notinvc":"⋶","NotLeftTriangleBar":"⧏̸","NotLeftTriangle":"⋪","NotLeftTriangleEqual":"⋬","NotLess":"≮","NotLessEqual":"≰","NotLessGreater":"≸","NotLessLess":"≪̸","NotLessSlantEqual":"⩽̸","NotLessTilde":"≴","NotNestedGreaterGreater":"⪢̸","NotNestedLessLess":"⪡̸","notni":"∌","notniva":"∌","notnivb":"⋾","notnivc":"⋽","NotPrecedes":"⊀","NotPrecedesEqual":"⪯̸","NotPrecedesSlantEqual":"⋠","NotReverseElement":"∌","NotRightTriangleBar":"⧐̸","NotRightTriangle":"⋫","NotRightTriangleEqual":"⋭","NotSquareSubset":"⊏̸","NotSquareSubsetEqual":"⋢","NotSquareSuperset":"⊐̸","NotSquareSupersetEqual":"⋣","NotSubset":"⊂⃒","NotSubsetEqual":"⊈","NotSucceeds":"⊁","NotSucceedsEqual":"⪰̸","NotSucceedsSlantEqual":"⋡","NotSucceedsTilde":"≿̸","NotSuperset":"⊃⃒","NotSupersetEqual":"⊉","NotTilde":"≁","NotTildeEqual":"≄","NotTildeFullEqual":"≇","NotTildeTilde":"≉","NotVerticalBar":"∤","nparallel":"∦","npar":"∦","nparsl":"⫽⃥","npart":"∂̸","npolint":"⨔","npr":"⊀","nprcue":"⋠","nprec":"⊀","npreceq":"⪯̸","npre":"⪯̸","nrarrc":"⤳̸","nrarr":"↛","nrArr":"⇏","nrarrw":"↝̸","nrightarrow":"↛","nRightarrow":"⇏","nrtri":"⋫","nrtrie":"⋭","nsc":"⊁","nsccue":"⋡","nsce":"⪰̸","Nscr":"𝒩","nscr":"𝓃","nshortmid":"∤","nshortparallel":"∦","nsim":"≁","nsime":"≄","nsimeq":"≄","nsmid":"∤","nspar":"∦","nsqsube":"⋢","nsqsupe":"⋣","nsub":"⊄","nsubE":"⫅̸","nsube":"⊈","nsubset":"⊂⃒","nsubseteq":"⊈","nsubseteqq":"⫅̸","nsucc":"⊁","nsucceq":"⪰̸","nsup":"⊅","nsupE":"⫆̸","nsupe":"⊉","nsupset":"⊃⃒","nsupseteq":"⊉","nsupseteqq":"⫆̸","ntgl":"≹","Ntilde":"Ñ","ntilde":"ñ","ntlg":"≸","ntriangleleft":"⋪","ntrianglelefteq":"⋬","ntriangleright":"⋫","ntrianglerighteq":"⋭","Nu":"Ν","nu":"ν","num":"#","numero":"№","numsp":" ","nvap":"≍⃒","nvdash":"⊬","nvDash":"⊭","nVdash":"⊮","nVDash":"⊯","nvge":"≥⃒","nvgt":">⃒","nvHarr":"⤄","nvinfin":"⧞","nvlArr":"⤂","nvle":"≤⃒","nvlt":"<⃒","nvltrie":"⊴⃒","nvrArr":"⤃","nvrtrie":"⊵⃒","nvsim":"∼⃒","nwarhk":"⤣","nwarr":"↖","nwArr":"⇖","nwarrow":"↖","nwnear":"⤧","Oacute":"Ó","oacute":"ó","oast":"⊛","Ocirc":"Ô","ocirc":"ô","ocir":"⊚","Ocy":"О","ocy":"о","odash":"⊝","Odblac":"Ő","odblac":"ő","odiv":"⨸","odot":"⊙","odsold":"⦼","OElig":"Œ","oelig":"œ","ofcir":"⦿","Ofr":"𝔒","ofr":"𝔬","ogon":"˛","Ograve":"Ò","ograve":"ò","ogt":"⧁","ohbar":"⦵","ohm":"Ω","oint":"∮","olarr":"↺","olcir":"⦾","olcross":"⦻","oline":"‾","olt":"⧀","Omacr":"Ō","omacr":"ō","Omega":"Ω","omega":"ω","Omicron":"Ο","omicron":"ο","omid":"⦶","ominus":"⊖","Oopf":"𝕆","oopf":"𝕠","opar":"⦷","OpenCurlyDoubleQuote":"“","OpenCurlyQuote":"‘","operp":"⦹","oplus":"⊕","orarr":"↻","Or":"⩔","or":"∨","ord":"⩝","order":"ℴ","orderof":"ℴ","ordf":"ª","ordm":"º","origof":"⊶","oror":"⩖","orslope":"⩗","orv":"⩛","oS":"Ⓢ","Oscr":"𝒪","oscr":"ℴ","Oslash":"Ø","oslash":"ø","osol":"⊘","Otilde":"Õ","otilde":"õ","otimesas":"⨶","Otimes":"⨷","otimes":"⊗","Ouml":"Ö","ouml":"ö","ovbar":"⌽","OverBar":"‾","OverBrace":"⏞","OverBracket":"⎴","OverParenthesis":"⏜","para":"¶","parallel":"∥","par":"∥","parsim":"⫳","parsl":"⫽","part":"∂","PartialD":"∂","Pcy":"П","pcy":"п","percnt":"%","period":".","permil":"‰","perp":"⊥","pertenk":"‱","Pfr":"𝔓","pfr":"𝔭","Phi":"Φ","phi":"φ","phiv":"ϕ","phmmat":"ℳ","phone":"☎","Pi":"Π","pi":"π","pitchfork":"⋔","piv":"ϖ","planck":"ℏ","planckh":"ℎ","plankv":"ℏ","plusacir":"⨣","plusb":"⊞","pluscir":"⨢","plus":"+","plusdo":"∔","plusdu":"⨥","pluse":"⩲","PlusMinus":"±","plusmn":"±","plussim":"⨦","plustwo":"⨧","pm":"±","Poincareplane":"ℌ","pointint":"⨕","popf":"𝕡","Popf":"ℙ","pound":"£","prap":"⪷","Pr":"⪻","pr":"≺","prcue":"≼","precapprox":"⪷","prec":"≺","preccurlyeq":"≼","Precedes":"≺","PrecedesEqual":"⪯","PrecedesSlantEqual":"≼","PrecedesTilde":"≾","preceq":"⪯","precnapprox":"⪹","precneqq":"⪵","precnsim":"⋨","pre":"⪯","prE":"⪳","precsim":"≾","prime":"′","Prime":"″","primes":"ℙ","prnap":"⪹","prnE":"⪵","prnsim":"⋨","prod":"∏","Product":"∏","profalar":"⌮","profline":"⌒","profsurf":"⌓","prop":"∝","Proportional":"∝","Proportion":"∷","propto":"∝","prsim":"≾","prurel":"⊰","Pscr":"𝒫","pscr":"𝓅","Psi":"Ψ","psi":"ψ","puncsp":" ","Qfr":"𝔔","qfr":"𝔮","qint":"⨌","qopf":"𝕢","Qopf":"ℚ","qprime":"⁗","Qscr":"𝒬","qscr":"𝓆","quaternions":"ℍ","quatint":"⨖","quest":"?","questeq":"≟","quot":"\\"","QUOT":"\\"","rAarr":"⇛","race":"∽̱","Racute":"Ŕ","racute":"ŕ","radic":"√","raemptyv":"⦳","rang":"⟩","Rang":"⟫","rangd":"⦒","range":"⦥","rangle":"⟩","raquo":"»","rarrap":"⥵","rarrb":"⇥","rarrbfs":"⤠","rarrc":"⤳","rarr":"→","Rarr":"↠","rArr":"⇒","rarrfs":"⤞","rarrhk":"↪","rarrlp":"↬","rarrpl":"⥅","rarrsim":"⥴","Rarrtl":"⤖","rarrtl":"↣","rarrw":"↝","ratail":"⤚","rAtail":"⤜","ratio":"∶","rationals":"ℚ","rbarr":"⤍","rBarr":"⤏","RBarr":"⤐","rbbrk":"❳","rbrace":"}","rbrack":"]","rbrke":"⦌","rbrksld":"⦎","rbrkslu":"⦐","Rcaron":"Ř","rcaron":"ř","Rcedil":"Ŗ","rcedil":"ŗ","rceil":"⌉","rcub":"}","Rcy":"Р","rcy":"р","rdca":"⤷","rdldhar":"⥩","rdquo":"”","rdquor":"”","rdsh":"↳","real":"ℜ","realine":"ℛ","realpart":"ℜ","reals":"ℝ","Re":"ℜ","rect":"▭","reg":"®","REG":"®","ReverseElement":"∋","ReverseEquilibrium":"⇋","ReverseUpEquilibrium":"⥯","rfisht":"⥽","rfloor":"⌋","rfr":"𝔯","Rfr":"ℜ","rHar":"⥤","rhard":"⇁","rharu":"⇀","rharul":"⥬","Rho":"Ρ","rho":"ρ","rhov":"ϱ","RightAngleBracket":"⟩","RightArrowBar":"⇥","rightarrow":"→","RightArrow":"→","Rightarrow":"⇒","RightArrowLeftArrow":"⇄","rightarrowtail":"↣","RightCeiling":"⌉","RightDoubleBracket":"⟧","RightDownTeeVector":"⥝","RightDownVectorBar":"⥕","RightDownVector":"⇂","RightFloor":"⌋","rightharpoondown":"⇁","rightharpoonup":"⇀","rightleftarrows":"⇄","rightleftharpoons":"⇌","rightrightarrows":"⇉","rightsquigarrow":"↝","RightTeeArrow":"↦","RightTee":"⊢","RightTeeVector":"⥛","rightthreetimes":"⋌","RightTriangleBar":"⧐","RightTriangle":"⊳","RightTriangleEqual":"⊵","RightUpDownVector":"⥏","RightUpTeeVector":"⥜","RightUpVectorBar":"⥔","RightUpVector":"↾","RightVectorBar":"⥓","RightVector":"⇀","ring":"˚","risingdotseq":"≓","rlarr":"⇄","rlhar":"⇌","rlm":"‏","rmoustache":"⎱","rmoust":"⎱","rnmid":"⫮","roang":"⟭","roarr":"⇾","robrk":"⟧","ropar":"⦆","ropf":"𝕣","Ropf":"ℝ","roplus":"⨮","rotimes":"⨵","RoundImplies":"⥰","rpar":")","rpargt":"⦔","rppolint":"⨒","rrarr":"⇉","Rrightarrow":"⇛","rsaquo":"›","rscr":"𝓇","Rscr":"ℛ","rsh":"↱","Rsh":"↱","rsqb":"]","rsquo":"’","rsquor":"’","rthree":"⋌","rtimes":"⋊","rtri":"▹","rtrie":"⊵","rtrif":"▸","rtriltri":"⧎","RuleDelayed":"⧴","ruluhar":"⥨","rx":"℞","Sacute":"Ś","sacute":"ś","sbquo":"‚","scap":"⪸","Scaron":"Š","scaron":"š","Sc":"⪼","sc":"≻","sccue":"≽","sce":"⪰","scE":"⪴","Scedil":"Ş","scedil":"ş","Scirc":"Ŝ","scirc":"ŝ","scnap":"⪺","scnE":"⪶","scnsim":"⋩","scpolint":"⨓","scsim":"≿","Scy":"С","scy":"с","sdotb":"⊡","sdot":"⋅","sdote":"⩦","searhk":"⤥","searr":"↘","seArr":"⇘","searrow":"↘","sect":"§","semi":";","seswar":"⤩","setminus":"∖","setmn":"∖","sext":"✶","Sfr":"𝔖","sfr":"𝔰","sfrown":"⌢","sharp":"♯","SHCHcy":"Щ","shchcy":"щ","SHcy":"Ш","shcy":"ш","ShortDownArrow":"↓","ShortLeftArrow":"←","shortmid":"∣","shortparallel":"∥","ShortRightArrow":"→","ShortUpArrow":"↑","shy":"­","Sigma":"Σ","sigma":"σ","sigmaf":"ς","sigmav":"ς","sim":"∼","simdot":"⩪","sime":"≃","simeq":"≃","simg":"⪞","simgE":"⪠","siml":"⪝","simlE":"⪟","simne":"≆","simplus":"⨤","simrarr":"⥲","slarr":"←","SmallCircle":"∘","smallsetminus":"∖","smashp":"⨳","smeparsl":"⧤","smid":"∣","smile":"⌣","smt":"⪪","smte":"⪬","smtes":"⪬︀","SOFTcy":"Ь","softcy":"ь","solbar":"⌿","solb":"⧄","sol":"/","Sopf":"𝕊","sopf":"𝕤","spades":"♠","spadesuit":"♠","spar":"∥","sqcap":"⊓","sqcaps":"⊓︀","sqcup":"⊔","sqcups":"⊔︀","Sqrt":"√","sqsub":"⊏","sqsube":"⊑","sqsubset":"⊏","sqsubseteq":"⊑","sqsup":"⊐","sqsupe":"⊒","sqsupset":"⊐","sqsupseteq":"⊒","square":"□","Square":"□","SquareIntersection":"⊓","SquareSubset":"⊏","SquareSubsetEqual":"⊑","SquareSuperset":"⊐","SquareSupersetEqual":"⊒","SquareUnion":"⊔","squarf":"▪","squ":"□","squf":"▪","srarr":"→","Sscr":"𝒮","sscr":"𝓈","ssetmn":"∖","ssmile":"⌣","sstarf":"⋆","Star":"⋆","star":"☆","starf":"★","straightepsilon":"ϵ","straightphi":"ϕ","strns":"¯","sub":"⊂","Sub":"⋐","subdot":"⪽","subE":"⫅","sube":"⊆","subedot":"⫃","submult":"⫁","subnE":"⫋","subne":"⊊","subplus":"⪿","subrarr":"⥹","subset":"⊂","Subset":"⋐","subseteq":"⊆","subseteqq":"⫅","SubsetEqual":"⊆","subsetneq":"⊊","subsetneqq":"⫋","subsim":"⫇","subsub":"⫕","subsup":"⫓","succapprox":"⪸","succ":"≻","succcurlyeq":"≽","Succeeds":"≻","SucceedsEqual":"⪰","SucceedsSlantEqual":"≽","SucceedsTilde":"≿","succeq":"⪰","succnapprox":"⪺","succneqq":"⪶","succnsim":"⋩","succsim":"≿","SuchThat":"∋","sum":"∑","Sum":"∑","sung":"♪","sup1":"¹","sup2":"²","sup3":"³","sup":"⊃","Sup":"⋑","supdot":"⪾","supdsub":"⫘","supE":"⫆","supe":"⊇","supedot":"⫄","Superset":"⊃","SupersetEqual":"⊇","suphsol":"⟉","suphsub":"⫗","suplarr":"⥻","supmult":"⫂","supnE":"⫌","supne":"⊋","supplus":"⫀","supset":"⊃","Supset":"⋑","supseteq":"⊇","supseteqq":"⫆","supsetneq":"⊋","supsetneqq":"⫌","supsim":"⫈","supsub":"⫔","supsup":"⫖","swarhk":"⤦","swarr":"↙","swArr":"⇙","swarrow":"↙","swnwar":"⤪","szlig":"ß","Tab":"\\t","target":"⌖","Tau":"Τ","tau":"τ","tbrk":"⎴","Tcaron":"Ť","tcaron":"ť","Tcedil":"Ţ","tcedil":"ţ","Tcy":"Т","tcy":"т","tdot":"⃛","telrec":"⌕","Tfr":"𝔗","tfr":"𝔱","there4":"∴","therefore":"∴","Therefore":"∴","Theta":"Θ","theta":"θ","thetasym":"ϑ","thetav":"ϑ","thickapprox":"≈","thicksim":"∼","ThickSpace":"  ","ThinSpace":" ","thinsp":" ","thkap":"≈","thksim":"∼","THORN":"Þ","thorn":"þ","tilde":"˜","Tilde":"∼","TildeEqual":"≃","TildeFullEqual":"≅","TildeTilde":"≈","timesbar":"⨱","timesb":"⊠","times":"×","timesd":"⨰","tint":"∭","toea":"⤨","topbot":"⌶","topcir":"⫱","top":"⊤","Topf":"𝕋","topf":"𝕥","topfork":"⫚","tosa":"⤩","tprime":"‴","trade":"™","TRADE":"™","triangle":"▵","triangledown":"▿","triangleleft":"◃","trianglelefteq":"⊴","triangleq":"≜","triangleright":"▹","trianglerighteq":"⊵","tridot":"◬","trie":"≜","triminus":"⨺","TripleDot":"⃛","triplus":"⨹","trisb":"⧍","tritime":"⨻","trpezium":"⏢","Tscr":"𝒯","tscr":"𝓉","TScy":"Ц","tscy":"ц","TSHcy":"Ћ","tshcy":"ћ","Tstrok":"Ŧ","tstrok":"ŧ","twixt":"≬","twoheadleftarrow":"↞","twoheadrightarrow":"↠","Uacute":"Ú","uacute":"ú","uarr":"↑","Uarr":"↟","uArr":"⇑","Uarrocir":"⥉","Ubrcy":"Ў","ubrcy":"ў","Ubreve":"Ŭ","ubreve":"ŭ","Ucirc":"Û","ucirc":"û","Ucy":"У","ucy":"у","udarr":"⇅","Udblac":"Ű","udblac":"ű","udhar":"⥮","ufisht":"⥾","Ufr":"𝔘","ufr":"𝔲","Ugrave":"Ù","ugrave":"ù","uHar":"⥣","uharl":"↿","uharr":"↾","uhblk":"▀","ulcorn":"⌜","ulcorner":"⌜","ulcrop":"⌏","ultri":"◸","Umacr":"Ū","umacr":"ū","uml":"¨","UnderBar":"_","UnderBrace":"⏟","UnderBracket":"⎵","UnderParenthesis":"⏝","Union":"⋃","UnionPlus":"⊎","Uogon":"Ų","uogon":"ų","Uopf":"𝕌","uopf":"𝕦","UpArrowBar":"⤒","uparrow":"↑","UpArrow":"↑","Uparrow":"⇑","UpArrowDownArrow":"⇅","updownarrow":"↕","UpDownArrow":"↕","Updownarrow":"⇕","UpEquilibrium":"⥮","upharpoonleft":"↿","upharpoonright":"↾","uplus":"⊎","UpperLeftArrow":"↖","UpperRightArrow":"↗","upsi":"υ","Upsi":"ϒ","upsih":"ϒ","Upsilon":"Υ","upsilon":"υ","UpTeeArrow":"↥","UpTee":"⊥","upuparrows":"⇈","urcorn":"⌝","urcorner":"⌝","urcrop":"⌎","Uring":"Ů","uring":"ů","urtri":"◹","Uscr":"𝒰","uscr":"𝓊","utdot":"⋰","Utilde":"Ũ","utilde":"ũ","utri":"▵","utrif":"▴","uuarr":"⇈","Uuml":"Ü","uuml":"ü","uwangle":"⦧","vangrt":"⦜","varepsilon":"ϵ","varkappa":"ϰ","varnothing":"∅","varphi":"ϕ","varpi":"ϖ","varpropto":"∝","varr":"↕","vArr":"⇕","varrho":"ϱ","varsigma":"ς","varsubsetneq":"⊊︀","varsubsetneqq":"⫋︀","varsupsetneq":"⊋︀","varsupsetneqq":"⫌︀","vartheta":"ϑ","vartriangleleft":"⊲","vartriangleright":"⊳","vBar":"⫨","Vbar":"⫫","vBarv":"⫩","Vcy":"В","vcy":"в","vdash":"⊢","vDash":"⊨","Vdash":"⊩","VDash":"⊫","Vdashl":"⫦","veebar":"⊻","vee":"∨","Vee":"⋁","veeeq":"≚","vellip":"⋮","verbar":"|","Verbar":"‖","vert":"|","Vert":"‖","VerticalBar":"∣","VerticalLine":"|","VerticalSeparator":"❘","VerticalTilde":"≀","VeryThinSpace":" ","Vfr":"𝔙","vfr":"𝔳","vltri":"⊲","vnsub":"⊂⃒","vnsup":"⊃⃒","Vopf":"𝕍","vopf":"𝕧","vprop":"∝","vrtri":"⊳","Vscr":"𝒱","vscr":"𝓋","vsubnE":"⫋︀","vsubne":"⊊︀","vsupnE":"⫌︀","vsupne":"⊋︀","Vvdash":"⊪","vzigzag":"⦚","Wcirc":"Ŵ","wcirc":"ŵ","wedbar":"⩟","wedge":"∧","Wedge":"⋀","wedgeq":"≙","weierp":"℘","Wfr":"𝔚","wfr":"𝔴","Wopf":"𝕎","wopf":"𝕨","wp":"℘","wr":"≀","wreath":"≀","Wscr":"𝒲","wscr":"𝓌","xcap":"⋂","xcirc":"◯","xcup":"⋃","xdtri":"▽","Xfr":"𝔛","xfr":"𝔵","xharr":"⟷","xhArr":"⟺","Xi":"Ξ","xi":"ξ","xlarr":"⟵","xlArr":"⟸","xmap":"⟼","xnis":"⋻","xodot":"⨀","Xopf":"𝕏","xopf":"𝕩","xoplus":"⨁","xotime":"⨂","xrarr":"⟶","xrArr":"⟹","Xscr":"𝒳","xscr":"𝓍","xsqcup":"⨆","xuplus":"⨄","xutri":"△","xvee":"⋁","xwedge":"⋀","Yacute":"Ý","yacute":"ý","YAcy":"Я","yacy":"я","Ycirc":"Ŷ","ycirc":"ŷ","Ycy":"Ы","ycy":"ы","yen":"¥","Yfr":"𝔜","yfr":"𝔶","YIcy":"Ї","yicy":"ї","Yopf":"𝕐","yopf":"𝕪","Yscr":"𝒴","yscr":"𝓎","YUcy":"Ю","yucy":"ю","yuml":"ÿ","Yuml":"Ÿ","Zacute":"Ź","zacute":"ź","Zcaron":"Ž","zcaron":"ž","Zcy":"З","zcy":"з","Zdot":"Ż","zdot":"ż","zeetrf":"ℨ","ZeroWidthSpace":"​","Zeta":"Ζ","zeta":"ζ","zfr":"𝔷","Zfr":"ℨ","ZHcy":"Ж","zhcy":"ж","zigrarr":"⇝","zopf":"𝕫","Zopf":"ℤ","Zscr":"𝒵","zscr":"𝓏","zwj":"‍","zwnj":"‌"}');
    },
    /* 262 */
    /***/
    function(s) {
      s.exports = JSON.parse('{"Aacute":"Á","aacute":"á","Acirc":"Â","acirc":"â","acute":"´","AElig":"Æ","aelig":"æ","Agrave":"À","agrave":"à","amp":"&","AMP":"&","Aring":"Å","aring":"å","Atilde":"Ã","atilde":"ã","Auml":"Ä","auml":"ä","brvbar":"¦","Ccedil":"Ç","ccedil":"ç","cedil":"¸","cent":"¢","copy":"©","COPY":"©","curren":"¤","deg":"°","divide":"÷","Eacute":"É","eacute":"é","Ecirc":"Ê","ecirc":"ê","Egrave":"È","egrave":"è","ETH":"Ð","eth":"ð","Euml":"Ë","euml":"ë","frac12":"½","frac14":"¼","frac34":"¾","gt":">","GT":">","Iacute":"Í","iacute":"í","Icirc":"Î","icirc":"î","iexcl":"¡","Igrave":"Ì","igrave":"ì","iquest":"¿","Iuml":"Ï","iuml":"ï","laquo":"«","lt":"<","LT":"<","macr":"¯","micro":"µ","middot":"·","nbsp":" ","not":"¬","Ntilde":"Ñ","ntilde":"ñ","Oacute":"Ó","oacute":"ó","Ocirc":"Ô","ocirc":"ô","Ograve":"Ò","ograve":"ò","ordf":"ª","ordm":"º","Oslash":"Ø","oslash":"ø","Otilde":"Õ","otilde":"õ","Ouml":"Ö","ouml":"ö","para":"¶","plusmn":"±","pound":"£","quot":"\\"","QUOT":"\\"","raquo":"»","reg":"®","REG":"®","sect":"§","shy":"­","sup1":"¹","sup2":"²","sup3":"³","szlig":"ß","THORN":"Þ","thorn":"þ","times":"×","Uacute":"Ú","uacute":"ú","Ucirc":"Û","ucirc":"û","Ugrave":"Ù","ugrave":"ù","uml":"¨","Uuml":"Ü","uuml":"ü","Yacute":"Ý","yacute":"ý","yen":"¥","yuml":"ÿ"}');
    },
    /* 263 */
    /***/
    function(s) {
      s.exports = JSON.parse(`{"amp":"&","apos":"'","gt":">","lt":"<","quot":"\\""}`);
    },
    /* 264 */
    /***/
    function(s, l, d) {
      var i = this && this.__importDefault || function(o) {
        return o && o.__esModule ? o : { default: o };
      };
      Object.defineProperty(l, "__esModule", { value: !0 });
      var b = i(d(265));
      function m(o) {
        if (o >= 55296 && o <= 57343 || o > 1114111)
          return "�";
        o in b.default && (o = b.default[o]);
        var n = "";
        return o > 65535 && (o -= 65536, n += String.fromCharCode(o >>> 10 & 1023 | 55296), o = 56320 | o & 1023), n += String.fromCharCode(o), n;
      }
      l.default = m;
    },
    /* 265 */
    /***/
    function(s) {
      s.exports = JSON.parse('{"0":65533,"128":8364,"130":8218,"131":402,"132":8222,"133":8230,"134":8224,"135":8225,"136":710,"137":8240,"138":352,"139":8249,"140":338,"142":381,"145":8216,"146":8217,"147":8220,"148":8221,"149":8226,"150":8211,"151":8212,"152":732,"153":8482,"154":353,"155":8250,"156":339,"158":382,"159":376}');
    },
    /* 266 */
    /***/
    function(s, l, d) {
      var i = this && this.__importDefault || function(y) {
        return y && y.__esModule ? y : { default: y };
      };
      Object.defineProperty(l, "__esModule", { value: !0 }), l.escape = l.encodeHTML = l.encodeXML = void 0;
      var b = i(d(263)), m = I(b.default), o = a(m);
      l.encodeXML = Y(m, o);
      var n = i(d(261)), W = I(n.default), e = a(W);
      l.encodeHTML = Y(W, e);
      function I(y) {
        return Object.keys(y).sort().reduce(function(Z, X) {
          return Z[y[X]] = "&" + X + ";", Z;
        }, {});
      }
      function a(y) {
        for (var Z = [], X = [], c = 0, t = Object.keys(y); c < t.length; c++) {
          var R = t[c];
          R.length === 1 ? Z.push("\\" + R) : X.push(R);
        }
        Z.sort();
        for (var S = 0; S < Z.length - 1; S++) {
          for (var J = S; J < Z.length - 1 && Z[J].charCodeAt(1) + 1 === Z[J + 1].charCodeAt(1); )
            J += 1;
          var H = 1 + J - S;
          H < 3 || Z.splice(S, H, Z[S] + "-" + Z[J]);
        }
        return X.unshift("[" + Z.join("") + "]"), new RegExp(X.join("|"), "g");
      }
      var V = /(?:[\x80-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/g;
      function h(y) {
        return "&#x" + y.codePointAt(0).toString(16).toUpperCase() + ";";
      }
      function Y(y, Z) {
        return function(X) {
          return X.replace(Z, function(c) {
            return y[c];
          }).replace(V, h);
        };
      }
      var p = a(m);
      function G(y) {
        return y.replace(p, h).replace(V, h);
      }
      l.escape = G;
    },
    /* 267 */
    /***/
    function(s) {
      s.exports = JSON.parse('{"elementNames":{"altglyph":"altGlyph","altglyphdef":"altGlyphDef","altglyphitem":"altGlyphItem","animatecolor":"animateColor","animatemotion":"animateMotion","animatetransform":"animateTransform","clippath":"clipPath","feblend":"feBlend","fecolormatrix":"feColorMatrix","fecomponenttransfer":"feComponentTransfer","fecomposite":"feComposite","feconvolvematrix":"feConvolveMatrix","fediffuselighting":"feDiffuseLighting","fedisplacementmap":"feDisplacementMap","fedistantlight":"feDistantLight","fedropshadow":"feDropShadow","feflood":"feFlood","fefunca":"feFuncA","fefuncb":"feFuncB","fefuncg":"feFuncG","fefuncr":"feFuncR","fegaussianblur":"feGaussianBlur","feimage":"feImage","femerge":"feMerge","femergenode":"feMergeNode","femorphology":"feMorphology","feoffset":"feOffset","fepointlight":"fePointLight","fespecularlighting":"feSpecularLighting","fespotlight":"feSpotLight","fetile":"feTile","feturbulence":"feTurbulence","foreignobject":"foreignObject","glyphref":"glyphRef","lineargradient":"linearGradient","radialgradient":"radialGradient","textpath":"textPath"},"attributeNames":{"definitionurl":"definitionURL","attributename":"attributeName","attributetype":"attributeType","basefrequency":"baseFrequency","baseprofile":"baseProfile","calcmode":"calcMode","clippathunits":"clipPathUnits","diffuseconstant":"diffuseConstant","edgemode":"edgeMode","filterunits":"filterUnits","glyphref":"glyphRef","gradienttransform":"gradientTransform","gradientunits":"gradientUnits","kernelmatrix":"kernelMatrix","kernelunitlength":"kernelUnitLength","keypoints":"keyPoints","keysplines":"keySplines","keytimes":"keyTimes","lengthadjust":"lengthAdjust","limitingconeangle":"limitingConeAngle","markerheight":"markerHeight","markerunits":"markerUnits","markerwidth":"markerWidth","maskcontentunits":"maskContentUnits","maskunits":"maskUnits","numoctaves":"numOctaves","pathlength":"pathLength","patterncontentunits":"patternContentUnits","patterntransform":"patternTransform","patternunits":"patternUnits","pointsatx":"pointsAtX","pointsaty":"pointsAtY","pointsatz":"pointsAtZ","preservealpha":"preserveAlpha","preserveaspectratio":"preserveAspectRatio","primitiveunits":"primitiveUnits","refx":"refX","refy":"refY","repeatcount":"repeatCount","repeatdur":"repeatDur","requiredextensions":"requiredExtensions","requiredfeatures":"requiredFeatures","specularconstant":"specularConstant","specularexponent":"specularExponent","spreadmethod":"spreadMethod","startoffset":"startOffset","stddeviation":"stdDeviation","stitchtiles":"stitchTiles","surfacescale":"surfaceScale","systemlanguage":"systemLanguage","tablevalues":"tableValues","targetx":"targetX","targety":"targetY","textlength":"textLength","viewbox":"viewBox","viewtarget":"viewTarget","xchannelselector":"xChannelSelector","ychannelselector":"yChannelSelector","zoomandpan":"zoomAndPan"}}');
    },
    /* 268 */
    /***/
    function(s, l) {
      var d = l.getChildren = function(b) {
        return b.children;
      }, i = l.getParent = function(b) {
        return b.parent;
      };
      l.getSiblings = function(b) {
        var m = i(b);
        return m ? d(m) : [b];
      }, l.getAttributeValue = function(b, m) {
        return b.attribs && b.attribs[m];
      }, l.hasAttrib = function(b, m) {
        return !!b.attribs && hasOwnProperty.call(b.attribs, m);
      }, l.getName = function(b) {
        return b.name;
      };
    },
    /* 269 */
    /***/
    function(s, l) {
      l.removeElement = function(d) {
        if (d.prev && (d.prev.next = d.next), d.next && (d.next.prev = d.prev), d.parent) {
          var i = d.parent.children;
          i.splice(i.lastIndexOf(d), 1);
        }
      }, l.replaceElement = function(d, i) {
        var b = i.prev = d.prev;
        b && (b.next = i);
        var m = i.next = d.next;
        m && (m.prev = i);
        var o = i.parent = d.parent;
        if (o) {
          var n = o.children;
          n[n.lastIndexOf(d)] = i;
        }
      }, l.appendChild = function(d, i) {
        if (i.parent = d, d.children.push(i) !== 1) {
          var b = d.children[d.children.length - 2];
          b.next = i, i.prev = b, i.next = null;
        }
      }, l.append = function(d, i) {
        var b = d.parent, m = d.next;
        if (i.next = m, i.prev = d, d.next = i, i.parent = b, m) {
          if (m.prev = i, b) {
            var o = b.children;
            o.splice(o.lastIndexOf(m), 0, i);
          }
        } else
          b && b.children.push(i);
      }, l.prepend = function(d, i) {
        var b = d.parent;
        if (b) {
          var m = b.children;
          m.splice(m.lastIndexOf(d), 0, i);
        }
        d.prev && (d.prev.next = i), i.parent = b, i.prev = d.prev, i.next = d, d.prev = i;
      };
    },
    /* 270 */
    /***/
    function(s, l, d) {
      var i = d(256).isTag;
      s.exports = {
        filter: b,
        find: m,
        findOneChild: o,
        findOne: n,
        existsOne: W,
        findAll: e
      };
      function b(I, a, V, h) {
        return Array.isArray(a) || (a = [a]), (typeof h != "number" || !isFinite(h)) && (h = 1 / 0), m(I, a, V !== !1, h);
      }
      function m(I, a, V, h) {
        for (var Y = [], p, G = 0, y = a.length; G < y && !(I(a[G]) && (Y.push(a[G]), --h <= 0) || (p = a[G].children, V && p && p.length > 0 && (p = m(I, p, V, h), Y = Y.concat(p), h -= p.length, h <= 0))); G++)
          ;
        return Y;
      }
      function o(I, a) {
        for (var V = 0, h = a.length; V < h; V++)
          if (I(a[V]))
            return a[V];
        return null;
      }
      function n(I, a) {
        for (var V = null, h = 0, Y = a.length; h < Y && !V; h++)
          if (i(a[h]))
            I(a[h]) ? V = a[h] : a[h].children.length > 0 && (V = n(I, a[h].children));
          else
            continue;
        return V;
      }
      function W(I, a) {
        for (var V = 0, h = a.length; V < h; V++)
          if (i(a[V]) && (I(a[V]) || a[V].children.length > 0 && W(I, a[V].children)))
            return !0;
        return !1;
      }
      function e(I, a) {
        for (var V = [], h = a.slice(); h.length; ) {
          var Y = h.shift();
          i(Y) && (Y.children && Y.children.length > 0 && h.unshift.apply(h, Y.children), I(Y) && V.push(Y));
        }
        return V;
      }
    },
    /* 271 */
    /***/
    function(s, l, d) {
      var i = d(256), b = l.isTag = i.isTag;
      l.testElement = function(W, e) {
        for (var I in W)
          if (W.hasOwnProperty(I)) {
            if (I === "tag_name") {
              if (!b(e) || !W.tag_name(e.name))
                return !1;
            } else if (I === "tag_type") {
              if (!W.tag_type(e.type))
                return !1;
            } else if (I === "tag_contains") {
              if (b(e) || !W.tag_contains(e.data))
                return !1;
            } else if (!e.attribs || !W[I](e.attribs[I]))
              return !1;
          }
        return !0;
      };
      var m = {
        tag_name: function(W) {
          return typeof W == "function" ? function(e) {
            return b(e) && W(e.name);
          } : W === "*" ? b : function(e) {
            return b(e) && e.name === W;
          };
        },
        tag_type: function(W) {
          return typeof W == "function" ? function(e) {
            return W(e.type);
          } : function(e) {
            return e.type === W;
          };
        },
        tag_contains: function(W) {
          return typeof W == "function" ? function(e) {
            return !b(e) && W(e.data);
          } : function(e) {
            return !b(e) && e.data === W;
          };
        }
      };
      function o(W, e) {
        return typeof e == "function" ? function(I) {
          return I.attribs && e(I.attribs[W]);
        } : function(I) {
          return I.attribs && I.attribs[W] === e;
        };
      }
      function n(W, e) {
        return function(I) {
          return W(I) || e(I);
        };
      }
      l.getElements = function(W, e, I, a) {
        var V = Object.keys(W).map(function(h) {
          var Y = W[h];
          return h in m ? m[h](Y) : o(h, Y);
        });
        return V.length === 0 ? [] : this.filter(
          V.reduce(n),
          e,
          I,
          a
        );
      }, l.getElementById = function(W, e, I) {
        return Array.isArray(e) || (e = [e]), this.findOne(o("id", W), e, I !== !1);
      }, l.getElementsByTagName = function(W, e, I, a) {
        return this.filter(m.tag_name(W), e, I, a);
      }, l.getElementsByTagType = function(W, e, I, a) {
        return this.filter(m.tag_type(W), e, I, a);
      };
    },
    /* 272 */
    /***/
    function(s, l) {
      l.removeSubsets = function(b) {
        for (var m = b.length, o, n, W; --m > -1; ) {
          for (o = n = b[m], b[m] = null, W = !0; n; ) {
            if (b.indexOf(n) > -1) {
              W = !1, b.splice(m, 1);
              break;
            }
            n = n.parent;
          }
          W && (b[m] = o);
        }
        return b;
      };
      var d = {
        DISCONNECTED: 1,
        PRECEDING: 2,
        FOLLOWING: 4,
        CONTAINS: 8,
        CONTAINED_BY: 16
      }, i = l.compareDocumentPosition = function(b, m) {
        var o = [], n = [], W, e, I, a, V, h;
        if (b === m)
          return 0;
        for (W = b; W; )
          o.unshift(W), W = W.parent;
        for (W = m; W; )
          n.unshift(W), W = W.parent;
        for (h = 0; o[h] === n[h]; )
          h++;
        return h === 0 ? d.DISCONNECTED : (e = o[h - 1], I = e.children, a = o[h], V = n[h], I.indexOf(a) > I.indexOf(V) ? e === m ? d.FOLLOWING | d.CONTAINED_BY : d.FOLLOWING : e === b ? d.PRECEDING | d.CONTAINS : d.PRECEDING);
      };
      l.uniqueSort = function(b) {
        var m = b.length, o, n;
        for (b = b.slice(); --m > -1; )
          o = b[m], n = b.indexOf(o), n > -1 && n < m && b.splice(m, 1);
        return b.sort(function(W, e) {
          var I = i(W, e);
          return I & d.PRECEDING ? -1 : I & d.FOLLOWING ? 1 : 0;
        }), b;
      };
    },
    /* 273 */
    /***/
    function(s, l) {
      s.exports = {
        trueFunc: function() {
          return !0;
        },
        falseFunc: function() {
          return !1;
        }
      };
    },
    /* 274 */
    /***/
    function(s, l, d) {
      s.exports = V;
      var i = d(275).parse, b = d(273), m = d(278), o = d(279), n = d(280), W = d(282), e = b.trueFunc, I = b.falseFunc, a = W.filters;
      function V(L, C, F) {
        var r = Y(L, C, F);
        return h(r, C);
      }
      function h(L, C) {
        var F = C.adapter;
        return function(K) {
          return F.isTag(K) && L(K);
        };
      }
      function Y(L, C, F) {
        var r = i(L, C);
        return t(r, C, F);
      }
      function p(L) {
        return L.type === "pseudo" && (L.name === "scope" || Array.isArray(L.data) && L.data.some(function(C) {
          return C.some(p);
        }));
      }
      var G = { type: "descendant" }, y = { type: "_flexibleDescendant" }, Z = { type: "pseudo", name: "scope" }, X = {};
      function c(L, C, F) {
        var r = C.adapter, K = !!F && !!F.length && F.every(function(g) {
          return g === X || !!r.getParent(g);
        });
        L.forEach(function(g) {
          if (!(g.length > 0 && R(g[0]) && g[0].type !== "descendant"))
            if (K && !(Array.isArray(g) ? g.some(p) : p(g)))
              g.unshift(G);
            else
              return;
          g.unshift(Z);
        });
      }
      function t(L, C, F) {
        L = L.filter(function(v) {
          return v.length > 0;
        }), L.forEach(m);
        var r = Array.isArray(F);
        F = C && C.context || F, F && !r && (F = [F]), c(L, C, F);
        var K = !1, g = L.map(function(v) {
          if (v[0] && v[1] && v[0].name === "scope") {
            var f = v[1].type;
            r && f === "descendant" ? v[1] = y : (f === "adjacent" || f === "sibling") && (K = !0);
          }
          return S(v, C, F);
        }).reduce(J, I);
        return g.shouldTestNextSiblings = K, g;
      }
      function R(L) {
        return o[L.type] < 0;
      }
      function S(L, C, F) {
        return L.reduce(function(r, K) {
          if (r === I)
            return r;
          if (!(K.type in n))
            throw new Error("Rule type " + K.type + " is not supported by css-select");
          return n[K.type](r, K, C, F);
        }, C && C.rootFunc || e);
      }
      function J(L, C) {
        return C === I || L === e ? L : L === I || C === e ? C : function(r) {
          return L(r) || C(r);
        };
      }
      function H(L) {
        return L.some(R);
      }
      a.not = function(L, C, F, r) {
        var K = {
          xmlMode: !!(F && F.xmlMode),
          strict: !!(F && F.strict),
          adapter: F.adapter
        };
        if (K.strict && (C.length > 1 || C.some(H)))
          throw new Error("complex selectors in :not aren't allowed in strict mode");
        var g = t(C, K, r);
        return g === I ? L : g === e ? I : function(f) {
          return !g(f) && L(f);
        };
      }, a.has = function(L, C, F) {
        var r = F.adapter, K = {
          xmlMode: !!(F && F.xmlMode),
          strict: !!(F && F.strict),
          adapter: r
        }, g = C.some(H) ? [X] : null, v = t(C, K, g);
        return v === I ? I : v === e ? function(O) {
          return r.getChildren(O).some(r.isTag) && L(O);
        } : (v = h(v, F), g ? function(O) {
          return L(O) && (g[0] = O, r.existsOne(v, r.getChildren(O)));
        } : function(O) {
          return L(O) && r.existsOne(v, r.getChildren(O));
        });
      }, a.matches = function(L, C, F, r) {
        var K = {
          xmlMode: !!(F && F.xmlMode),
          strict: !!(F && F.strict),
          rootFunc: L,
          adapter: F.adapter
        };
        return t(C, K, r);
      }, V.compileToken = t, V.compileUnsafe = Y, V.Pseudos = W;
    },
    /* 275 */
    /***/
    function(s, l, d) {
      var i = this && this.__createBinding || (Object.create ? function(n, W, e, I) {
        I === void 0 && (I = e), Object.defineProperty(n, I, { enumerable: !0, get: function() {
          return W[e];
        } });
      } : function(n, W, e, I) {
        I === void 0 && (I = e), n[I] = W[e];
      }), b = this && this.__exportStar || function(n, W) {
        for (var e in n)
          e !== "default" && !W.hasOwnProperty(e) && i(W, n, e);
      };
      Object.defineProperty(l, "__esModule", { value: !0 }), b(d(276), l);
      var m = d(276);
      Object.defineProperty(l, "parse", { enumerable: !0, get: function() {
        return m.default;
      } });
      var o = d(277);
      Object.defineProperty(l, "stringify", { enumerable: !0, get: function() {
        return o.default;
      } });
    },
    /* 276 */
    /***/
    function(s, l, d) {
      Object.defineProperty(l, "__esModule", { value: !0 }), l.default = p;
      var i = /^[^\\]?(?:\\(?:[\da-f]{1,6}\s?|.)|[\w\-\u00b0-\uFFFF])+/, b = /\\([\da-f]{1,6}\s?|(\s)|.)/gi, m = /^\s*((?:\\.|[\w\u00b0-\uFFFF-])+)\s*(?:(\S?)=\s*(?:(['"])([^]*?)\3|(#?(?:\\.|[\w\u00b0-\uFFFF-])*)|)|)\s*(i)?\]/, o = {
        undefined: "exists",
        "": "equals",
        "~": "element",
        "^": "start",
        $: "end",
        "*": "any",
        "!": "not",
        "|": "hyphen"
      }, n = {
        ">": "child",
        "<": "parent",
        "~": "sibling",
        "+": "adjacent"
      }, W = {
        "#": ["id", "equals"],
        ".": ["class", "element"]
      }, e = /* @__PURE__ */ new Set(["has", "not", "matches"]), I = /* @__PURE__ */ new Set(["contains", "icontains"]), a = /* @__PURE__ */ new Set(['"', "'"]);
      function V(Z, X, c) {
        var t = parseInt(X, 16) - 65536;
        return t !== t || c ? X : t < 0 ? (
          // BMP codepoint
          String.fromCharCode(t + 65536)
        ) : (
          // Supplemental Plane codepoint (surrogate pair)
          String.fromCharCode(t >> 10 | 55296, t & 1023 | 56320)
        );
      }
      function h(Z) {
        return Z.replace(b, V);
      }
      function Y(Z) {
        return Z === " " || Z === `
` || Z === "	" || Z === "\f" || Z === "\r";
      }
      function p(Z, X) {
        var c = [];
        if (Z = G(c, "" + Z, X), Z !== "")
          throw new Error("Unmatched selector: " + Z);
        return c;
      }
      function G(Z, X, c) {
        var t = [], R = !1;
        function S() {
          var D = X.match(i);
          if (!D)
            throw new Error("Expected name, found " + X);
          var dd = D[0];
          return X = X.substr(dd.length), h(dd);
        }
        function J(D) {
          for (; Y(X.charAt(D)); )
            D++;
          X = X.substr(D);
        }
        function H(D) {
          for (var dd = 0; X.charAt(--D) === "\\"; )
            dd++;
          return (dd & 1) === 1;
        }
        for (J(0); X !== ""; ) {
          var L = X.charAt(0);
          if (Y(L))
            R = !0, J(1);
          else if (L in n)
            t.push({ type: n[L] }), R = !1, J(1);
          else if (L === ",") {
            if (t.length === 0)
              throw new Error("Empty sub-selector");
            Z.push(t), t = [], R = !1, J(1);
          } else if (R && (t.length > 0 && t.push({ type: "descendant" }), R = !1), L === "*")
            X = X.substr(1), t.push({ type: "universal" });
          else if (L in W) {
            var C = W[L], F = C[0], r = C[1];
            X = X.substr(1), t.push({
              type: "attribute",
              name: F,
              action: r,
              value: S(),
              ignoreCase: !1
            });
          } else if (L === "[") {
            X = X.substr(1);
            var K = X.match(m);
            if (!K)
              throw new Error("Malformed attribute selector: " + X);
            X = X.substr(K[0].length);
            var g = h(K[1]);
            (!c || ("lowerCaseAttributeNames" in c ? c.lowerCaseAttributeNames : !c.xmlMode)) && (g = g.toLowerCase()), t.push({
              type: "attribute",
              name: g,
              action: o[K[2]],
              value: h(K[4] || K[5] || ""),
              ignoreCase: !!K[6]
            });
          } else if (L === ":") {
            if (X.charAt(1) === ":") {
              X = X.substr(2), t.push({
                type: "pseudo-element",
                name: S().toLowerCase()
              });
              continue;
            }
            X = X.substr(1);
            var v = S().toLowerCase(), K = null;
            if (X.charAt(0) === "(")
              if (e.has(v)) {
                var f = X.charAt(1), O = a.has(f);
                if (X = X.substr(O ? 2 : 1), K = [], X = G(K, X, c), O) {
                  if (X.charAt(0) !== f)
                    throw new Error("Unmatched quotes in :" + v);
                  X = X.substr(1);
                }
                if (X.charAt(0) !== ")")
                  throw new Error("Missing closing parenthesis in :" + v + " (" + X + ")");
                X = X.substr(1);
              } else {
                for (var q = 1, M = 1; M > 0 && q < X.length; q++)
                  X.charAt(q) === "(" && !H(q) ? M++ : X.charAt(q) === ")" && !H(q) && M--;
                if (M)
                  throw new Error("Parenthesis not matched");
                if (K = X.substr(1, q - 2), X = X.substr(q), I.has(v)) {
                  var f = K.charAt(0);
                  f === K.slice(-1) && a.has(f) && (K = K.slice(1, -1)), K = h(K);
                }
              }
            t.push({ type: "pseudo", name: v, data: K });
          } else if (i.test(X)) {
            var P = S();
            (!c || ("lowerCaseTags" in c ? c.lowerCaseTags : !c.xmlMode)) && (P = P.toLowerCase()), t.push({ type: "tag", name: P });
          } else
            return t.length && t[t.length - 1].type === "descendant" && t.pop(), y(Z, t), X;
        }
        return y(Z, t), X;
      }
      function y(Z, X) {
        if (Z.length > 0 && X.length === 0)
          throw new Error("Empty sub-selector");
        Z.push(X);
      }
    },
    /* 277 */
    /***/
    function(s, l, d) {
      Object.defineProperty(l, "__esModule", { value: !0 });
      var i = {
        equals: "",
        element: "~",
        start: "^",
        end: "$",
        any: "*",
        not: "!",
        hyphen: "|"
      };
      function b(W) {
        return W.map(m).join(", ");
      }
      l.default = b;
      function m(W) {
        return W.map(o).join("");
      }
      function o(W) {
        switch (W.type) {
          case "child":
            return " > ";
          case "parent":
            return " < ";
          case "sibling":
            return " ~ ";
          case "adjacent":
            return " + ";
          case "descendant":
            return " ";
          case "universal":
            return "*";
          case "tag":
            return W.name;
          case "pseudo-element":
            return "::" + W.name;
          case "pseudo":
            return W.data === null ? ":" + W.name : typeof W.data == "string" ? ":" + W.name + "(" + W.data + ")" : ":" + W.name + "(" + b(W.data) + ")";
          case "attribute":
            return W.action === "exists" ? "[" + W.name + "]" : W.name === "id" && W.action === "equals" && !W.ignoreCase ? "#" + W.value : W.name === "class" && W.action === "element" && !W.ignoreCase ? "." + W.value : "[" + W.name + i[W.action] + "='" + W.value + "'" + (W.ignoreCase ? "i" : "") + "]";
          default:
            throw new Error("Unknown type");
        }
      }
      function n(W) {
        return W;
      }
    },
    /* 278 */
    /***/
    function(s, l, d) {
      s.exports = m;
      var i = d(279), b = {
        __proto__: null,
        exists: 10,
        equals: 8,
        not: 7,
        start: 6,
        end: 6,
        any: 5,
        hyphen: 4,
        element: 4
      };
      function m(n) {
        for (var W = n.map(o), e = 1; e < n.length; e++) {
          var I = W[e];
          if (!(I < 0))
            for (var a = e - 1; a >= 0 && I < W[a]; a--) {
              var V = n[a + 1];
              n[a + 1] = n[a], n[a] = V, W[a + 1] = W[a], W[a] = I;
            }
        }
      }
      function o(n) {
        var W = i[n.type];
        if (W === i.attribute)
          W = b[n.action], W === b.equals && n.name === "id" && (W = 9), n.ignoreCase && (W >>= 1);
        else if (W === i.pseudo)
          if (!n.data)
            W = 3;
          else if (n.name === "has" || n.name === "contains")
            W = 0;
          else if (n.name === "matches" || n.name === "not") {
            W = 0;
            for (var e = 0; e < n.data.length; e++)
              if (n.data[e].length === 1) {
                var I = o(n.data[e][0]);
                if (I === 0) {
                  W = 0;
                  break;
                }
                I > W && (W = I);
              }
            n.data.length > 1 && W > 0 && (W -= 1);
          } else
            W = 1;
        return W;
      }
    },
    /* 279 */
    /***/
    function(s) {
      s.exports = JSON.parse('{"universal":50,"tag":30,"attribute":1,"pseudo":0,"descendant":-1,"child":-1,"parent":-1,"sibling":-1,"adjacent":-1}');
    },
    /* 280 */
    /***/
    function(s, l, d) {
      var i = d(281), b = d(282);
      s.exports = {
        __proto__: null,
        attribute: i.compile,
        pseudo: b.compile,
        //tags
        tag: function(m, o, n) {
          var W = o.name, e = n.adapter;
          return function(a) {
            return e.getName(a) === W && m(a);
          };
        },
        //traversal
        descendant: function(m, o, n) {
          var W = typeof WeakSet < "u" ? /* @__PURE__ */ new WeakSet() : null, e = n.adapter;
          return function(a) {
            for (var V = !1; !V && (a = e.getParent(a)); )
              (!W || !W.has(a)) && (V = m(a), !V && W && W.add(a));
            return V;
          };
        },
        _flexibleDescendant: function(m, o, n) {
          var W = n.adapter;
          return function(I) {
            for (var a = m(I); !a && (I = W.getParent(I)); )
              a = m(I);
            return a;
          };
        },
        parent: function(m, o, n) {
          if (n && n.strict)
            throw new Error("Parent selector isn't part of CSS3");
          var W = n.adapter;
          return function(a) {
            return W.getChildren(a).some(e);
          };
          function e(I) {
            return W.isTag(I) && m(I);
          }
        },
        child: function(m, o, n) {
          var W = n.adapter;
          return function(I) {
            var a = W.getParent(I);
            return !!a && m(a);
          };
        },
        sibling: function(m, o, n) {
          var W = n.adapter;
          return function(I) {
            for (var a = W.getSiblings(I), V = 0; V < a.length; V++)
              if (W.isTag(a[V])) {
                if (a[V] === I)
                  break;
                if (m(a[V]))
                  return !0;
              }
            return !1;
          };
        },
        adjacent: function(m, o, n) {
          var W = n.adapter;
          return function(I) {
            for (var a = W.getSiblings(I), V, h = 0; h < a.length; h++)
              if (W.isTag(a[h])) {
                if (a[h] === I)
                  break;
                V = a[h];
              }
            return !!V && m(V);
          };
        },
        universal: function(m) {
          return m;
        }
      };
    },
    /* 281 */
    /***/
    function(s, l, d) {
      var i = d(273).falseFunc, b = /[-[\]{}()*+?.,\\^$|#\s]/g, m = {
        __proto__: null,
        equals: function(o, n, W) {
          var e = n.name, I = n.value, a = W.adapter;
          return n.ignoreCase ? (I = I.toLowerCase(), function(h) {
            var Y = a.getAttributeValue(h, e);
            return Y != null && Y.toLowerCase() === I && o(h);
          }) : function(h) {
            return a.getAttributeValue(h, e) === I && o(h);
          };
        },
        hyphen: function(o, n, W) {
          var e = n.name, I = n.value, a = I.length, V = W.adapter;
          return n.ignoreCase ? (I = I.toLowerCase(), function(Y) {
            var p = V.getAttributeValue(Y, e);
            return p != null && (p.length === a || p.charAt(a) === "-") && p.substr(0, a).toLowerCase() === I && o(Y);
          }) : function(Y) {
            var p = V.getAttributeValue(Y, e);
            return p != null && p.substr(0, a) === I && (p.length === a || p.charAt(a) === "-") && o(Y);
          };
        },
        element: function(o, n, W) {
          var e = n.name, I = n.value, a = W.adapter;
          if (/\s/.test(I))
            return i;
          I = I.replace(b, "\\$&");
          var V = "(?:^|\\s)" + I + "(?:$|\\s)", h = n.ignoreCase ? "i" : "", Y = new RegExp(V, h);
          return function(G) {
            var y = a.getAttributeValue(G, e);
            return y != null && Y.test(y) && o(G);
          };
        },
        exists: function(o, n, W) {
          var e = n.name, I = W.adapter;
          return function(V) {
            return I.hasAttrib(V, e) && o(V);
          };
        },
        start: function(o, n, W) {
          var e = n.name, I = n.value, a = I.length, V = W.adapter;
          return a === 0 ? i : n.ignoreCase ? (I = I.toLowerCase(), function(Y) {
            var p = V.getAttributeValue(Y, e);
            return p != null && p.substr(0, a).toLowerCase() === I && o(Y);
          }) : function(Y) {
            var p = V.getAttributeValue(Y, e);
            return p != null && p.substr(0, a) === I && o(Y);
          };
        },
        end: function(o, n, W) {
          var e = n.name, I = n.value, a = -I.length, V = W.adapter;
          return a === 0 ? i : n.ignoreCase ? (I = I.toLowerCase(), function(Y) {
            var p = V.getAttributeValue(Y, e);
            return p != null && p.substr(a).toLowerCase() === I && o(Y);
          }) : function(Y) {
            var p = V.getAttributeValue(Y, e);
            return p != null && p.substr(a) === I && o(Y);
          };
        },
        any: function(o, n, W) {
          var e = n.name, I = n.value, a = W.adapter;
          if (I === "")
            return i;
          if (n.ignoreCase) {
            var V = new RegExp(I.replace(b, "\\$&"), "i");
            return function(Y) {
              var p = a.getAttributeValue(Y, e);
              return p != null && V.test(p) && o(Y);
            };
          }
          return function(Y) {
            var p = a.getAttributeValue(Y, e);
            return p != null && p.indexOf(I) >= 0 && o(Y);
          };
        },
        not: function(o, n, W) {
          var e = n.name, I = n.value, a = W.adapter;
          return I === "" ? function(h) {
            return !!a.getAttributeValue(h, e) && o(h);
          } : n.ignoreCase ? (I = I.toLowerCase(), function(h) {
            var Y = a.getAttributeValue(h, e);
            return Y != null && Y.toLowerCase() !== I && o(h);
          }) : function(h) {
            return a.getAttributeValue(h, e) !== I && o(h);
          };
        }
      };
      s.exports = {
        compile: function(o, n, W) {
          if (W && W.strict && (n.ignoreCase || n.action === "not"))
            throw new Error("Unsupported attribute selector");
          return m[n.action](o, n, W);
        },
        rules: m
      };
    },
    /* 282 */
    /***/
    function(s, l, d) {
      var i = d(283), b = d(273), m = d(281), o = b.trueFunc, n = b.falseFunc, W = m.rules.equals;
      function e(y, Z) {
        var X = { name: y, value: Z };
        return function(t, R, S) {
          return W(t, X, S);
        };
      }
      function I(y, Z) {
        return function(X) {
          return !!Z.getParent(X) && y(X);
        };
      }
      var a = {
        contains: function(y, Z, X) {
          var c = X.adapter;
          return function(R) {
            return y(R) && c.getText(R).indexOf(Z) >= 0;
          };
        },
        icontains: function(y, Z, X) {
          var c = Z.toLowerCase(), t = X.adapter;
          return function(S) {
            return y(S) && t.getText(S).toLowerCase().indexOf(c) >= 0;
          };
        },
        //location specific methods
        "nth-child": function(y, Z, X) {
          var c = i(Z), t = X.adapter;
          return c === n ? c : c === o ? I(y, t) : function(S) {
            for (var J = t.getSiblings(S), H = 0, L = 0; H < J.length; H++)
              if (t.isTag(J[H])) {
                if (J[H] === S)
                  break;
                L++;
              }
            return c(L) && y(S);
          };
        },
        "nth-last-child": function(y, Z, X) {
          var c = i(Z), t = X.adapter;
          return c === n ? c : c === o ? I(y, t) : function(S) {
            for (var J = t.getSiblings(S), H = 0, L = J.length - 1; L >= 0; L--)
              if (t.isTag(J[L])) {
                if (J[L] === S)
                  break;
                H++;
              }
            return c(H) && y(S);
          };
        },
        "nth-of-type": function(y, Z, X) {
          var c = i(Z), t = X.adapter;
          return c === n ? c : c === o ? I(y, t) : function(S) {
            for (var J = t.getSiblings(S), H = 0, L = 0; L < J.length; L++)
              if (t.isTag(J[L])) {
                if (J[L] === S)
                  break;
                t.getName(J[L]) === t.getName(S) && H++;
              }
            return c(H) && y(S);
          };
        },
        "nth-last-of-type": function(y, Z, X) {
          var c = i(Z), t = X.adapter;
          return c === n ? c : c === o ? I(y, t) : function(S) {
            for (var J = t.getSiblings(S), H = 0, L = J.length - 1; L >= 0; L--)
              if (t.isTag(J[L])) {
                if (J[L] === S)
                  break;
                t.getName(J[L]) === t.getName(S) && H++;
              }
            return c(H) && y(S);
          };
        },
        //TODO determine the actual root element
        root: function(y, Z, X) {
          var c = X.adapter;
          return function(t) {
            return !c.getParent(t) && y(t);
          };
        },
        scope: function(y, Z, X, c) {
          var t = X.adapter;
          if (!c || c.length === 0)
            return a.root(y, Z, X);
          function R(S, J) {
            return typeof t.equals == "function" ? t.equals(S, J) : S === J;
          }
          return c.length === 1 ? function(S) {
            return R(c[0], S) && y(S);
          } : function(S) {
            return c.indexOf(S) >= 0 && y(S);
          };
        },
        //jQuery extensions (others follow as pseudos)
        checkbox: e("type", "checkbox"),
        file: e("type", "file"),
        password: e("type", "password"),
        radio: e("type", "radio"),
        reset: e("type", "reset"),
        image: e("type", "image"),
        submit: e("type", "submit"),
        //dynamic state pseudos. These depend on optional Adapter methods.
        hover: function(y, Z, X) {
          var c = X.adapter;
          return typeof c.isHovered == "function" ? function(R) {
            return y(R) && c.isHovered(R);
          } : n;
        },
        visited: function(y, Z, X) {
          var c = X.adapter;
          return typeof c.isVisited == "function" ? function(R) {
            return y(R) && c.isVisited(R);
          } : n;
        },
        active: function(y, Z, X) {
          var c = X.adapter;
          return typeof c.isActive == "function" ? function(R) {
            return y(R) && c.isActive(R);
          } : n;
        }
      };
      function V(y, Z) {
        for (var X = 0; y && X < y.length; X++)
          if (Z.isTag(y[X]))
            return y[X];
      }
      var h = {
        empty: function(y, Z) {
          return !Z.getChildren(y).some(function(X) {
            return Z.isTag(X) || X.type === "text";
          });
        },
        "first-child": function(y, Z) {
          return V(Z.getSiblings(y), Z) === y;
        },
        "last-child": function(y, Z) {
          for (var X = Z.getSiblings(y), c = X.length - 1; c >= 0; c--) {
            if (X[c] === y)
              return !0;
            if (Z.isTag(X[c]))
              break;
          }
          return !1;
        },
        "first-of-type": function(y, Z) {
          for (var X = Z.getSiblings(y), c = 0; c < X.length; c++)
            if (Z.isTag(X[c])) {
              if (X[c] === y)
                return !0;
              if (Z.getName(X[c]) === Z.getName(y))
                break;
            }
          return !1;
        },
        "last-of-type": function(y, Z) {
          for (var X = Z.getSiblings(y), c = X.length - 1; c >= 0; c--)
            if (Z.isTag(X[c])) {
              if (X[c] === y)
                return !0;
              if (Z.getName(X[c]) === Z.getName(y))
                break;
            }
          return !1;
        },
        "only-of-type": function(y, Z) {
          for (var X = Z.getSiblings(y), c = 0, t = X.length; c < t; c++)
            if (Z.isTag(X[c])) {
              if (X[c] === y)
                continue;
              if (Z.getName(X[c]) === Z.getName(y))
                return !1;
            }
          return !0;
        },
        "only-child": function(y, Z) {
          for (var X = Z.getSiblings(y), c = 0; c < X.length; c++)
            if (Z.isTag(X[c]) && X[c] !== y)
              return !1;
          return !0;
        },
        //:matches(a, area, link)[href]
        link: function(y, Z) {
          return Z.hasAttrib(y, "href");
        },
        //TODO: :any-link once the name is finalized (as an alias of :link)
        //forms
        //to consider: :target
        //:matches([selected], select:not([multiple]):not(> option[selected]) > option:first-of-type)
        selected: function(y, Z) {
          if (Z.hasAttrib(y, "selected"))
            return !0;
          if (Z.getName(y) !== "option")
            return !1;
          var X = Z.getParent(y);
          if (!X || Z.getName(X) !== "select" || Z.hasAttrib(X, "multiple"))
            return !1;
          for (var c = Z.getChildren(X), t = !1, R = 0; R < c.length; R++)
            if (Z.isTag(c[R]))
              if (c[R] === y)
                t = !0;
              else if (t) {
                if (Z.hasAttrib(c[R], "selected"))
                  return !1;
              } else
                return !1;
          return t;
        },
        //https://html.spec.whatwg.org/multipage/scripting.html#disabled-elements
        //:matches(
        //  :matches(button, input, select, textarea, menuitem, optgroup, option)[disabled],
        //  optgroup[disabled] > option),
        // fieldset[disabled] * //TODO not child of first <legend>
        //)
        disabled: function(y, Z) {
          return Z.hasAttrib(y, "disabled");
        },
        enabled: function(y, Z) {
          return !Z.hasAttrib(y, "disabled");
        },
        //:matches(:matches(:radio, :checkbox)[checked], :selected) (TODO menuitem)
        checked: function(y, Z) {
          return Z.hasAttrib(y, "checked") || h.selected(y, Z);
        },
        //:matches(input, select, textarea)[required]
        required: function(y, Z) {
          return Z.hasAttrib(y, "required");
        },
        //:matches(input, select, textarea):not([required])
        optional: function(y, Z) {
          return !Z.hasAttrib(y, "required");
        },
        //jQuery extensions
        //:not(:empty)
        parent: function(y, Z) {
          return !h.empty(y, Z);
        },
        //:matches(h1, h2, h3, h4, h5, h6)
        header: Y(["h1", "h2", "h3", "h4", "h5", "h6"]),
        //:matches(button, input[type=button])
        button: function(y, Z) {
          var X = Z.getName(y);
          return X === "button" || X === "input" && Z.getAttributeValue(y, "type") === "button";
        },
        //:matches(input, textarea, select, button)
        input: Y(["input", "textarea", "select", "button"]),
        //input:matches(:not([type!='']), [type='text' i])
        text: function(y, Z) {
          var X;
          return Z.getName(y) === "input" && (!(X = Z.getAttributeValue(y, "type")) || X.toLowerCase() === "text");
        }
      };
      function Y(y) {
        if (typeof Set < "u") {
          var Z = new Set(y);
          return function(X, c) {
            return Z.has(c.getName(X));
          };
        }
        return function(X, c) {
          return y.indexOf(c.getName(X)) >= 0;
        };
      }
      function p(y, Z, X) {
        if (X === null) {
          if (y.length > 2 && Z !== "scope")
            throw new Error("pseudo-selector :" + Z + " requires an argument");
        } else if (y.length === 2)
          throw new Error("pseudo-selector :" + Z + " doesn't have any arguments");
      }
      var G = /^(?:(?:nth|last|first|only)-(?:child|of-type)|root|empty|(?:en|dis)abled|checked|not)$/;
      s.exports = {
        compile: function(y, Z, X, c) {
          var t = Z.name, R = Z.data, S = X.adapter;
          if (X && X.strict && !G.test(t))
            throw new Error(":" + t + " isn't part of CSS3");
          if (typeof a[t] == "function")
            return a[t](y, R, X, c);
          if (typeof h[t] == "function") {
            var J = h[t];
            return p(J, t, R), J === n ? J : y === o ? function(L) {
              return J(L, S, R);
            } : function(L) {
              return J(L, S, R) && y(L);
            };
          } else
            throw new Error("unmatched pseudo-class :" + t);
        },
        filters: a,
        pseudos: h
      };
    },
    /* 283 */
    /***/
    function(s, l, d) {
      var i = d(284), b = d(285);
      s.exports = function(o) {
        return b(i(o));
      }, s.exports.parse = i, s.exports.compile = b;
    },
    /* 284 */
    /***/
    function(s, l) {
      s.exports = i;
      var d = /^([+\-]?\d*n)?\s*(?:([+\-]?)\s*(\d+))?$/;
      function i(b) {
        if (b = b.trim().toLowerCase(), b === "even")
          return [2, 0];
        if (b === "odd")
          return [2, 1];
        var m = b.match(d);
        if (!m)
          throw new SyntaxError("n-th rule couldn't be parsed ('" + b + "')");
        var o;
        return m[1] ? (o = parseInt(m[1], 10), isNaN(o) && (m[1].charAt(0) === "-" ? o = -1 : o = 1)) : o = 0, [
          o,
          m[3] ? parseInt((m[2] || "") + m[3], 10) : 0
        ];
      }
    },
    /* 285 */
    /***/
    function(s, l, d) {
      s.exports = o;
      var i = d(273), b = i.trueFunc, m = i.falseFunc;
      function o(n) {
        var W = n[0], e = n[1] - 1;
        if (e < 0 && W <= 0)
          return m;
        if (W === -1)
          return function(a) {
            return a <= e;
          };
        if (W === 0)
          return function(a) {
            return a === e;
          };
        if (W === 1)
          return e < 0 ? b : function(a) {
            return a >= e;
          };
        var I = e % W;
        return I < 0 && (I += W), W > 1 ? function(a) {
          return a >= e && a % W === I;
        } : (W *= -1, function(a) {
          return a <= e && a % W === I;
        });
      }
    },
    /* 286 */
    /***/
    function(s, l, d) {
      d.r(l), d.d(l, "default", function() {
        return R;
      });
      var i = d(12), b = d(74), m = d(1), o = d(68), n = d(250), W = d(213), e = d(218);
      d(1).glMatrix.setMatrixArrayType(Array);
      function I(S, J) {
        if (S == null)
          return {};
        var H = a(S, J), L, C;
        if (Object.getOwnPropertySymbols) {
          var F = Object.getOwnPropertySymbols(S);
          for (C = 0; C < F.length; C++)
            L = F[C], !(J.indexOf(L) >= 0) && Object.prototype.propertyIsEnumerable.call(S, L) && (H[L] = S[L]);
        }
        return H;
      }
      function a(S, J) {
        if (S == null)
          return {};
        var H = {}, L = Object.keys(S), C, F;
        for (F = 0; F < L.length; F++)
          C = L[F], !(J.indexOf(C) >= 0) && (H[C] = S[C]);
        return H;
      }
      const V = {
        antialias: !0,
        autoRender: !0,
        alpha: !0
        // for wx-miniprogram
      }, h = Symbol("autoRender"), Y = Symbol("renderer"), p = Symbol("timeline"), G = Symbol("prepareRender"), y = Symbol("tickRender"), Z = Symbol("pass"), X = Symbol("fbo"), c = Symbol("tickers"), t = Symbol("layerTransformInvert");
      class R extends n.default {
        constructor(J = {}) {
          if (super(), !J.canvas) {
            const {
              width: F,
              height: r
            } = this.getResolution(), K = i.ENV.createCanvas(F, r, {
              offscreen: !!J.offscreen,
              id: J.id,
              extra: J.extra
            });
            K.style && (K.style.position = "absolute"), K.dataset && (K.dataset.layerId = J.id), K.contextType && (J.contextType = K.contextType), J.canvas = K;
          }
          const H = J.canvas, L = Object.assign({}, V, J);
          this[h] = L.autoRender, delete J.autoRender;
          const C = L.Renderer || i.Renderer;
          this[Y] = new C(H, L), this.options = J, this.id = J.id, this[Z] = [], this.setResolution(H), this.canvas = H, this[p] = new b.Timeline(), this.__mouseCapturedTarget = null, this[t] = null;
        }
        get autoRender() {
          return this[h];
        }
        get displayRatio() {
          return this.parent && this.parent.options ? this.parent.options.displayRatio : 1;
        }
        get height() {
          const {
            height: J
          } = this.getResolution();
          return J / this.displayRatio;
        }
        get gl() {
          return this.renderer.glRenderer ? this.renderer.glRenderer.gl : null;
        }
        /* override */
        get layer() {
          return this;
        }
        get offscreen() {
          return !!this.options.offscreen || this.canvas._offscreen;
        }
        get pass() {
          return this[Z];
        }
        get prepareRender() {
          return this[G] ? this[G] : Promise.resolve();
        }
        /* override */
        get renderer() {
          return this[Y];
        }
        get renderOffset() {
          if (this.parent && this.parent.options) {
            const {
              left: J,
              top: H
            } = this.parent.options;
            return [J, H];
          }
          return [this.options.left | 0, this.options.top | 0];
        }
        get timeline() {
          return this[p];
        }
        get width() {
          const {
            width: J
          } = this.getResolution();
          return J / this.displayRatio;
        }
        get localMatrix() {
          const {
            x: J,
            y: H
          } = this.attributes;
          return [1, 0, 0, 1, J, H];
        }
        get layerTransformInvert() {
          if (this[t])
            return this[t];
          const J = this.transformMatrix;
          return J[0] === 1 && J[1] === 0 && J[2] === 0 && J[3] === 1 && J[4] === 0 && J[5] === 0 ? null : (this[t] = m.mat2d.invert(Array.of(0, 0, 0, 0, 0, 0), J), this[t]);
        }
        forceContextLoss() {
          const J = this.renderer.glRenderer;
          if (J) {
            const H = J.getExtension("WEBGL_lose_context");
            if (H)
              return H.loseContext(), !0;
          }
          return !1;
        }
        // isPointCollision(x, y) {
        //   return true;
        // }
        addPass({
          vertex: J,
          fragment: H,
          options: L,
          uniforms: C
        } = {}) {
          if (this.renderer.glRenderer) {
            const {
              width: F,
              height: r
            } = this.getResolution(), K = this.renderer.createPassProgram({
              vertex: J,
              fragment: H,
              options: L
            }), g = new i.Figure2D();
            g.rect(0, 0, F / this.displayRatio, r / this.displayRatio);
            const v = new i.Mesh2D(g);
            return v.setUniforms(C), v.setProgram(K), this[Z].push(v), this.forceUpdate(), v;
          }
          return null;
        }
        // delete unused texture to release memory.
        deleteTexture(J) {
          return Object(e.deleteTexture)(J, this.renderer);
        }
        /* override */
        dispatchPointerEvent(J) {
          const H = J.type;
          if (H === "mousedown" || H === "mouseup" || H === "mousemove") {
            const K = this.__mouseCapturedTarget;
            if (K) {
              if (K.layer === this)
                return K.dispatchEvent(J), !0;
              this.__mouseCapturedTarget = null;
            }
          }
          let L, C;
          const F = this.layerTransformInvert;
          if (F) {
            L = J.x, C = J.y;
            const K = F, g = K[0] * L + K[2] * C + K[4], v = K[1] * L + K[3] * C + K[5];
            delete J.x, delete J.y, delete J.layerX, delete J.layerY, Object.defineProperties(J, {
              layerX: {
                value: g,
                configurable: !0
              },
              layerY: {
                value: v,
                configurable: !0
              },
              x: {
                value: g,
                configurable: !0
              },
              y: {
                value: v,
                configurable: !0
              }
            });
          }
          const r = super.dispatchPointerEvent(J);
          return F && Object.defineProperties(J, {
            layerX: {
              value: L,
              configurable: !0
            },
            layerY: {
              value: C,
              configurable: !0
            },
            x: {
              value: L,
              configurable: !0
            },
            y: {
              value: C,
              configurable: !0
            }
          }), r;
        }
        /* override */
        forceUpdate() {
          if (!this[G])
            if (this.parent && this.parent.hasOffscreenCanvas) {
              this.parent.forceUpdate();
              let J = null;
              const H = new Promise((L) => {
                J = L;
              });
              H._resolve = J, this[G] = H;
            } else {
              let J = null, H = null;
              const L = new Promise((C) => {
                J = C, this[h] && (H = Object(o.requestAnimationFrame)(() => {
                  delete L._requestID, this.render();
                }));
              });
              L._resolve = J, L._requestID = H, this[G] = L;
            }
        }
        getFBO() {
          const J = this.renderer.glRenderer, {
            width: H,
            height: L
          } = this.getResolution();
          return J && (!this[X] || this[X].width !== H || this[X].height !== L) ? (this[X] = {
            width: H,
            height: L,
            target: J.createFBO(),
            buffer: J.createFBO(),
            swap() {
              [this.target, this.buffer] = [this.buffer, this.target];
            }
          }, this[X]) : this[X] ? this[X] : null;
        }
        updateGlobalTransform() {
          if (this.layerTransformInvert) {
            const J = this.renderer, H = J.__globalTransformMatrix || J.globalTransformMatrix;
            J.__globalTransformMatrix = H;
            const L = m.mat2d.fromValues(1, 0, 0, 1, 0, 0);
            J.setGlobalTransform(...m.mat2d.multiply(L, H, this.transformMatrix));
          }
        }
        /* override */
        onPropertyChange(J, H, L) {
          if (super.onPropertyChange(J, H, L), J === "zIndex" && (this.canvas.style.zIndex = H), J === "transform" || J === "translate" || J === "rotate" || J === "scale" || J === "skew") {
            const C = this[t];
            if (this[t] = null, this.updateGlobalTransform(), C && !this.layerTransformInvert) {
              const F = this.renderer, r = F.__globalTransformMatrix || F.globalTransformMatrix;
              F.setGlobalTransform(...r);
            }
          }
        }
        _prepareRenderFinished() {
          this[G] && (this[G]._requestID && Object(o.cancelAnimationFrame)(this[G]._requestID), this[G]._resolve(), delete this[G]);
        }
        render({
          clear: J = !0
        } = {}) {
          const H = this[Z].length ? this.getFBO() : null;
          H && this.renderer.glRenderer.bindFBO(H.target), J && this[Y].clear();
          const L = this.draw();
          if (L && L.length && (this.renderer.drawMeshes(L), this.canvas.draw && this.canvas.draw()), H) {
            const C = this.renderer.glRenderer, F = this[Z].length, {
              width: r,
              height: K
            } = this.getResolution(), g = [0, 0, r / this.displayRatio, K / this.displayRatio];
            this[Z].forEach((v, f) => {
              v.blend = !0, v.setTexture(H.target.texture, {
                rect: g
              }), f === F - 1 ? C.bindFBO(null) : (H.swap(), C.bindFBO(H.target)), this[Y].clear(), this.renderer.drawMeshes([v]);
            });
          }
          this._prepareRenderFinished();
        }
        /* override */
        setResolution({
          width: J,
          height: H
        }) {
          const L = this.renderer, C = L.__globalTransformMatrix || L.globalTransformMatrix, F = C[4], r = C[5], K = C[0], {
            width: g,
            height: v
          } = this.getResolution();
          (g !== J || v !== H) && (super.setResolution({
            width: J,
            height: H
          }), this.canvas && (this.canvas.width = J, this.canvas.height = H, L.updateResolution && L.updateResolution()), this.attributes.size = [J, H], this[Z].length && this[Z].forEach((M) => {
            const P = new i.Figure2D();
            P.rect(0, 0, J / this.displayRatio, H / this.displayRatio), M.contours = P.contours;
          }));
          const [f, O] = this.renderOffset, q = this.displayRatio;
          (F !== f || r !== O || K !== q) && (L.setGlobalTransform(q, 0, 0, q, f, O), L.__globalTransformMatrix = null, this[t] = null, this.updateGlobalTransform(), this.forceUpdate());
        }
        /**
         * tick(handler, {originTime = 0, playbackRate = 1.0, duration = Infinity})
         * @param {*} handler
         * @param {*} options
         */
        tick(J = null, H = {}) {
          let {
            duration: L = 1 / 0
          } = H, C = I(H, ["duration"]);
          const F = this.timeline.fork(C), r = this;
          this[c] = this[c] || [], this[c].push({
            handler: J,
            duration: L
          });
          const K = () => {
            let g = null, v = null;
            const f = () => {
              const O = this[c].map(({
                handler: q,
                duration: M
              }) => {
                const P = Math.min(1, F.currentTime / M);
                return {
                  value: q ? q(F.currentTime, P) : null,
                  p: P
                };
              });
              r[y] || (r[y] = Promise.resolve().then(() => {
                r[h] && r.render(), delete r[y];
                for (let q = O.length - 1; q >= 0; q--) {
                  const {
                    value: M,
                    p: P
                  } = O[q];
                  (M === !1 || P >= 1) && this[c].splice(q, 1);
                }
                this[c].length > 0 && K();
              }));
            };
            if (this[G] && this[G]._type !== "ticker" && (Object(o.cancelAnimationFrame)(this[G]._requestID), delete this[G]), !this[G]) {
              const O = new Promise((q) => {
                g = q, v = Object(o.requestAnimationFrame)(f);
              });
              O._resolve = g, O._requestID = v, O._type = "ticker", this[G] = O;
            }
          };
          K();
        }
        toGlobalPos(J, H) {
          if (this.layerTransformInvert) {
            const g = this.transformMatrix;
            J = g[0] * J + g[2] * H + g[4], H = g[1] * J + g[3] * H + g[5];
          }
          const {
            width: L,
            height: C
          } = this.getResolution(), F = this.renderOffset, r = [this.canvas.clientWidth, this.canvas.clientHeight];
          J = J * r[0] / L + F[0], H = H * r[1] / C + F[1];
          const K = this.displayRatio;
          return J *= K, H *= K, [J, H];
        }
        toLocalPos(J, H) {
          const {
            width: L,
            height: C
          } = this.getResolution(), F = this.renderOffset, r = [this.canvas.clientWidth, this.canvas.clientHeight];
          J = J * L / r[0] - F[0], H = H * C / r[1] - F[1];
          const K = this.displayRatio;
          J /= K, H /= K;
          const g = this.layerTransformInvert;
          return g && (J = g[0] * J + g[2] * H + g[4], H = g[1] * J + g[3] * H + g[5]), [J, H];
        }
      }
      W.default.registerNode(R, "layer");
    },
    /* 287 */
    /***/
    function(s, l, d) {
      d.r(l), d.d(l, "default", function() {
        return G;
      });
      var i = d(224), b = d(288), m = d(213), o = d(252), n = d(72);
      d(1).glMatrix.setMatrixArrayType(Array);
      function W(y, Z) {
        if (y == null)
          return {};
        var X = e(y, Z), c, t;
        if (Object.getOwnPropertySymbols) {
          var R = Object.getOwnPropertySymbols(y);
          for (t = 0; t < R.length; t++)
            c = R[t], !(Z.indexOf(c) >= 0) && Object.prototype.propertyIsEnumerable.call(y, c) && (X[c] = y[c]);
        }
        return X;
      }
      function e(y, Z) {
        if (y == null)
          return {};
        var X = {}, c = Object.keys(y), t, R;
        for (R = 0; R < c.length; R++)
          t = c[R], !(Z.indexOf(t) >= 0) && (X[t] = y[t]);
        return X;
      }
      function I(y, Z, X) {
        return Z in y ? Object.defineProperty(y, Z, { value: X, enumerable: !0, configurable: !0, writable: !0 }) : y[Z] = X, y;
      }
      const a = "http://www.w3.org/2000/svg", V = Symbol.for("spritejs_setAttribute"), h = Symbol("root"), Y = Symbol("task");
      function p(y, Z = !0) {
        const X = y[h];
        if (X && X.children[0]) {
          const c = y.svg, t = y.layer ? y.layer.displayRatio : 1;
          if (!c.hasAttribute("data-original-width")) {
            let J = c.getAttribute("width");
            J = J ? Object(n.sizeToPixel)(J) : 300;
            let H = c.getAttribute("height");
            H = H ? Object(n.sizeToPixel)(H) : 150, c.hasAttribute("viewBox") || c.setAttribute("viewBox", `0 0 ${Math.round(J)} ${Math.round(H)}`), c.setAttribute("data-original-width", J), c.setAttribute("data-original-height", H);
          }
          let R = y.attributes.width || Number(c.getAttribute("data-original-width")), S = y.attributes.height || Number(c.getAttribute("data-original-height"));
          if (R *= t, S *= t, Z && y.attributes.flexible) {
            const J = y.attributes.scale[0];
            if (R *= J, S *= J, c.setAttribute("width", R), c.setAttribute("height", S), R && S && y.textureImage) {
              const H = y.textureImage.width, L = y.textureImage.height, C = y.clientSize;
              y.attributes.textureRect = [0, 0, Math.round(C[0] * H / R), Math.round(C[1] * L / S)];
            }
          } else
            y[Y] || (c.setAttribute("width", R), c.setAttribute("height", S), y[Y] = Promise.resolve().then(() => {
              delete y[Y];
              const J = X.innerHTML, H = new Blob([J], {
                type: "image/svg+xml"
              }), L = URL.createObjectURL(H), C = new Image();
              C.onload = function() {
                C.width && C.height ? (y.attributes[V]("texture", C), y.attributes.flexible && (y.attributes.textureRect = null)) : y.attributes[V]("texture", null);
              }, C.src = L;
            }));
        }
      }
      class G extends i.default {
        constructor(Z = {}) {
          typeof Z == "string" && (Z = {
            svgText: Z
          });
          let {
            svgText: X
          } = Z, c = W(Z, ["svgText"]);
          if (super(c), this[h] = document.createElement("div"), X) {
            this[h].innerHTML = X;
            const t = this[h].children[0];
            t ? t.setAttribute("xmlns", a) : (fetch(X).then((R) => R.text()).then((R) => {
              this[h].innerHTML = R, (!this.observer || this.attributes.flexible) && p(this);
            }), X = null);
          }
          if (!X) {
            const t = document.createElementNS(a, "svg");
            t.setAttribute("xmlns", a), this[h].appendChild(t);
          }
          if (typeof MutationObserver == "function") {
            const t = new MutationObserver((R) => {
              p(this, !1);
            });
            t.observe(this[h], {
              attributes: !0,
              subtree: !0,
              characterData: !0,
              childList: !0
            }), this.observer = t;
          }
        }
        get children() {
          return [this.svg];
        }
        get childNodes() {
          return [this.svg];
        }
        get svg() {
          return this[h] ? this[h].children[0] : null;
        }
        /* override */
        setResolution({
          width: Z,
          height: X
        }) {
          super.setResolution({
            width: Z,
            height: X
          }), p(this);
        }
        /* override */
        dispatchPointerEvent(Z) {
          const X = super.dispatchPointerEvent(Z);
          if (X && this.attributes.passEvents && typeof MouseEvent == "function") {
            const {
              x: c,
              y: t
            } = Z;
            let [R, S] = this.getOffsetPosition(c, t);
            const J = Z.originalEvent, H = this.attributes.anchor, L = this.clientSize;
            R = (R + H[0] * L[0]) / 2, S = (S + H[1] * L[1]) / 2;
            const C = Z.type;
            if (C === J.type) {
              let F = null;
              if (J instanceof MouseEvent)
                F = new MouseEvent(C, {
                  screenX: R,
                  screenY: S,
                  clientX: R,
                  clientY: S,
                  bubbles: J.bubbles,
                  button: J.button,
                  buttons: J.buttons,
                  cancelBubble: J.cancelBubble,
                  cancelable: J.cancelable,
                  currentTarget: J.currentTarget,
                  fromElement: J.fromElement,
                  relatedTarget: J.relatedTarget,
                  returnValue: J.returnValue,
                  srcElement: J.srcElement,
                  target: J.target,
                  toElement: J.toElement,
                  // view: originalEvent.view,
                  which: J.witch
                });
              else if (J instanceof TouchEvent) {
                let r = null;
                const K = J.changedTouches || [J];
                for (let g = 0; g < K.length; g++) {
                  const v = K[g];
                  if (Z.identifier === v.identifier) {
                    r = v;
                    break;
                  }
                }
                if (r) {
                  const g = new Touch({
                    identifier: r.identifier,
                    target: r.target,
                    clientX: R,
                    clientY: S,
                    screenX: R,
                    screenY: S,
                    pageX: R,
                    pageY: S,
                    radiusX: r.radiusX,
                    radiusY: r.radiusY,
                    rotationAngle: r.rotationAngle,
                    force: r.force
                  });
                  F = new TouchEvent(C, {
                    cancelable: J.cancelable,
                    bubbles: J.bubbles,
                    composed: J.composed,
                    touches: [g],
                    targetTouches: [g],
                    changedTouches: [g]
                  });
                }
              } else
                F = J;
              F && this.svg.dispatchEvent(F);
            }
          }
          return X;
        }
        getElementById(Z) {
          return Object(o.querySelector)(`#${Z}`, this);
        }
        getElementsByClassName(Z) {
          return Object(o.querySelectorAll)(`.${Z}`, this);
        }
        getElementsByName(Z) {
          return Object(o.querySelectorAll)(`[name="${Z}"]`, this);
        }
        getElementsByTagName(Z) {
          return Object(o.querySelectorAll)(Z, this);
        }
        querySelector(Z) {
          return Object(o.querySelector)(Z, this);
        }
        querySelectorAll(Z) {
          return Object(o.querySelectorAll)(Z, this);
        }
        /* override */
        onPropertyChange(Z, X, c) {
          super.onPropertyChange(Z, X, c), Z === "flexible" && p(this), this.attributes.flexible && (Z === "width" || Z === "height" || Z === "scale" || Z === "transform") && p(this);
        }
      }
      I(G, "Attr", b.default), m.default.registerNode(G, "spritesvg");
    },
    /* 288 */
    /***/
    function(s, l, d) {
      d.r(l), d.d(l, "default", function() {
        return n;
      });
      var i = d(225);
      d(1).glMatrix.setMatrixArrayType(Array);
      const b = Symbol.for("spritejs_getAttribute"), m = Symbol.for("spritejs_setAttribute"), o = Symbol.for("spritejs_setAttributeDefault");
      class n extends i.default {
        constructor(e) {
          super(e), this[o]({
            passEvents: !1,
            flexible: !1
          });
        }
        // readonly
        get texture() {
          return this[b]("texture");
        }
        set texture(e) {
        }
        // eslint-disable-line no-empty-function
        get passEvents() {
          return this[b]("passEvents");
        }
        set passEvents(e) {
          return this[m]("passEvents", e);
        }
        get flexible() {
          return this[b]("flexible");
        }
        set flexible(e) {
          return this[m]("flexible", e);
        }
      }
    },
    /* 289 */
    /***/
    function(s, l, d) {
      d.r(l);
      var i = d(12);
      d(1).glMatrix.setMatrixArrayType(Array);
      function b(e, I) {
        var a = Object.keys(e);
        if (Object.getOwnPropertySymbols) {
          var V = Object.getOwnPropertySymbols(e);
          I && (V = V.filter(function(h) {
            return Object.getOwnPropertyDescriptor(e, h).enumerable;
          })), a.push.apply(a, V);
        }
        return a;
      }
      function m(e) {
        for (var I = 1; I < arguments.length; I++) {
          var a = arguments[I] != null ? arguments[I] : {};
          I % 2 ? b(Object(a), !0).forEach(function(V) {
            o(e, V, a[V]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(a)) : b(Object(a)).forEach(function(V) {
            Object.defineProperty(e, V, Object.getOwnPropertyDescriptor(a, V));
          });
        }
        return e;
      }
      function o(e, I, a) {
        return I in e ? Object.defineProperty(e, I, { value: a, enumerable: !0, configurable: !0, writable: !0 }) : e[I] = a, e;
      }
      const n = Symbol("inited");
      let W = null;
      typeof Worker == "function" && (W = class extends Worker {
        constructor(e) {
          if (e.worker === !0 && (e.worker = `./${e.id}.worker.js`), super(e.worker), this.options = e, !e.canvas) {
            const {
              width: I,
              height: a
            } = this.getResolution(), V = i.ENV.createCanvas(I, a, {
              offscreen: !1
            });
            V.style && (V.style.position = "absolute"), V.dataset && (V.dataset.layerId = e.id), e.canvas = V;
          }
          this.canvas = e.canvas;
        }
        get id() {
          return this.options.id;
        }
        setResolution({
          width: e,
          height: I
        }) {
          if (this[n])
            this.postMessage({
              type: "resolution_change",
              width: e,
              height: I
            });
          else {
            this.canvas.width = e, this.canvas.height = I;
            const a = this.options, V = a.canvas.transferControlToOffscreen(), h = m({}, a);
            delete h.container, h.canvas = V, this.postMessage({
              type: "create",
              options: h
            }, [V]), this[n] = !0;
          }
        }
        getResolution() {
          if (this.canvas) {
            const {
              width: e,
              height: I
            } = this.canvas;
            return {
              width: e,
              height: I
            };
          }
          return {
            width: 300,
            height: 150
          };
        }
        remove() {
          return this.parent && this.parent.removeChild ? (this.parent.removeChild(this), !0) : !1;
        }
        connect(e, I) {
          Object.defineProperty(this, "parent", {
            value: e,
            writable: !1,
            configurable: !0
          }), Object.defineProperty(this, "zOrder", {
            value: I,
            writable: !1,
            configurable: !0
          });
        }
        disconnect() {
          delete this.parent, delete this.zOrder;
        }
        dispatchPointerEvent(e) {
          this.postMessage({
            type: "event",
            event: {
              cancelBubble: e.cancelBubble,
              bubbles: e.bubbles,
              detail: e.detail,
              identifier: e.identifier,
              layerX: e.layerX,
              layerY: e.layerY,
              originalX: e.originalX,
              originalY: e.originalY,
              type: e.type,
              x: e.x,
              y: e.y
            }
          });
        }
      }), l.default = W;
    },
    /* 290 */
    /***/
    function(s, l, d) {
      d.r(l), (function(i) {
        d.d(l, "default", function() {
          return R;
        });
        var b = d(12), m = d(68), o = d(70), n = d(286), W = d(289), e = d(250), I = d(291), a = d(214), V = d(218), h = d(213);
        d(1).glMatrix.setMatrixArrayType(Array);
        const Y = Symbol("enteredTargets");
        function p(S) {
          return S.id = S.id || `_layer${Math.random().toString(36).slice(2, 12)}`, S.dataset || (S.dataset = {}), S.dataset.layerId = S.id, S.connect = (J, H) => {
            S.parent = J, Object.defineProperty(S, "zOrder", {
              value: H,
              writable: !1,
              configurable: !0
            });
          }, S.disconnect = (J) => {
            delete S.zOrder;
          }, S.canvas = S, S.getResolution = () => ({
            width: 0,
            height: 0
          }), S.setResolution = () => !1, S.options = {
            handleEvent: !1
          }, S;
        }
        function G(S, J) {
          const H = S.children;
          let L = null;
          for (let C = 0; C < H.length; C++) {
            const F = H[C];
            if ((J === F || L != null) && (L = F), L && L !== J && !L.offscreen)
              return L.canvas;
          }
          return null;
        }
        function y(S, J) {
          const [H, L] = S.renderOffset, {
            width: C,
            height: F
          } = S.getResolution(), r = S.displayRatio;
          S.renderer.drawImage(J.canvas, -H / r, -L / r, C / r, F / r);
        }
        const Z = {};
        function X(S) {
          const J = ["mousedown", "mouseup", "mousemove", "mousewheel", "wheel", "touchstart", "touchend", "touchmove", "touchcancel", "click", "dblclick", "longpress", "tap", "contextmenu"], H = S.container;
          H.addEventListener("mouseleave", (L) => {
            const C = S[Y];
            if (C.size) {
              const F = new a.default("mouseleave");
              F.setOriginalEvent(L), [...C].forEach((r) => {
                r.dispatchEvent(F);
              }), S[Y].clear();
            }
          }, {
            passive: !0
          }), J.forEach((L) => {
            H.addEventListener(L, (C) => {
              const {
                left: F,
                top: r,
                displayRatio: K
              } = S.options, g = S.orderedChildren;
              Object(I.default)(C, {
                offsetLeft: F,
                offsetTop: r,
                displayRatio: K
              }).forEach((f) => {
                const O = f.identifier;
                if (f.type === "touchmove" || f.type === "touchend") {
                  const M = Z[O];
                  M && M.dispatchEvent(f), f.type === "touchend" && delete Z[O];
                } else {
                  for (let M = g.length - 1; M >= 0; M--) {
                    const P = g[M];
                    if (P.options.handleEvent !== !1) {
                      if (P.dispatchPointerEvent(f) && f.target !== P)
                        break;
                      f.cancelBubble = !1;
                    }
                  }
                  if (f.target === g[0])
                    for (let M = g.length - 1; M >= 0; M--) {
                      const P = g[M];
                      if (P.options.handleEvent !== !1) {
                        f.target = P;
                        break;
                      }
                    }
                }
                const q = f.target;
                if (f.type === "touchstart" && (Z[O] = f.target), f.type === "mousemove") {
                  const M = S[Y];
                  let P;
                  if (q) {
                    const _ = q.ancestors || [];
                    P = /* @__PURE__ */ new Set([q, ..._]);
                  } else
                    P = /* @__PURE__ */ new Set();
                  const D = Object.entries(C);
                  if (!M.has(q) && q) {
                    const _ = new a.default("mouseenter");
                    _.setOriginalEvent(C), D.forEach(([$, Wd]) => {
                      _[$] = Wd;
                    }), M.add(q), q.dispatchEvent(_);
                    const cd = q.ancestors;
                    cd && cd.forEach(($) => {
                      $ instanceof o.default && !M.has($) && (M.add($), $.dispatchEvent(_));
                    });
                  }
                  const dd = new a.default("mouseleave");
                  dd.setOriginalEvent(C), D.forEach(([_, cd]) => {
                    dd[_] = cd;
                  }), [...M].forEach((_) => {
                    P.has(_) || (M.delete(_), _.dispatchEvent(dd));
                  });
                }
              });
            }, {
              passive: L !== "contextmenu"
            });
          });
        }
        function c(S, J) {
          if (J && J.style) {
            let {
              width: H,
              height: L,
              mode: C,
              container: F
            } = S;
            const {
              clientWidth: r,
              clientHeight: K
            } = F;
            H = H || r, L = L || K, C === "static" ? (J.style.width = `${H}px`, J.style.height = `${L}px`) : (J.style.top = "0", J.style.left = "0", J.style.width = `${r}px`, J.style.height = `${K}px`, J.style.transform = "", J.style.webkitTransform = "");
          }
        }
        const t = Symbol("offscreenLayerCount");
        class R extends e.default {
          /**
            width
            height
            mode: 'static', 'scale', 'stickyWidth', 'stickyHeight', 'stickyTop', 'stickyBottom', 'stickyLeft', 'stickyRight'
           */
          constructor(J = {}) {
            if (super(), !J.container)
              if (typeof b.ENV.Container == "function")
                J.container = new b.ENV.Container(J.width || 300, J.height || 150);
              else
                throw new Error("No container specified.");
            if (this.container = J.container, this.container.style && (this.container.style.overflow || (this.container.style.overflow = "hidden"), this.container.style.position || (this.container.style.position = "relative")), this.options = J, J.displayRatio = J.displayRatio || 1, J.mode = J.mode || "scale", J.left = 0, J.top = 0, J.autoResize = J.autoResize !== !1, J.autoResize) {
              let H;
              if (typeof globalThis < "u" ? H = globalThis : H = typeof window < "u" ? window : i, H.addEventListener) {
                const L = this;
                H.addEventListener("resize", function C() {
                  typeof document < "u" && document.contains(L.container) ? L.resize() : H.removeEventListener("resize", C);
                });
              }
            }
            this[Y] = /* @__PURE__ */ new Set(), this.setResolution(J), X(this), this[t] = 0;
          }
          get hasOffscreenCanvas() {
            return this[t] > 0;
          }
          set displayRatio(J) {
            this.options.displayRatio !== J && (this.options.displayRatio = J, this.resize());
          }
          get displayRatio() {
            return this.options.displayRatio;
          }
          set height(J) {
            this.options.height !== J && (this.options.height = J, this.resize());
          }
          get height() {
            return this.options.height;
          }
          set mode(J) {
            this.options.mode !== J && (this.options.mode = J, this.resize());
          }
          get mode() {
            return this.options.mode;
          }
          set width(J) {
            this.options.width !== J && (this.options.width = J, this.resize());
          }
          get width() {
            return this.options.width;
          }
          /* override */
          appendChild(J) {
            !(J instanceof n.default) && !(J instanceof W.default) && p(J);
            const H = super.appendChild(J), L = J.canvas;
            return J.offscreen ? this[t]++ : this.container.appendChild(L), c(this.options, L), J.setResolution(this.getResolution()), H;
          }
          /* override */
          forceUpdate() {
            this.hasOffscreenCanvas && !this._requestID && (this._requestID = Object(m.requestAnimationFrame)(() => {
              delete this._requestID, this.render();
            }));
          }
          /* override */
          insertBefore(J, H) {
            !(J instanceof n.default) && !(J instanceof W.default) && p(J);
            const L = super.insertBefore(J, H), C = J.canvas;
            if (!J.offscreen) {
              const F = G(this, J);
              this.container.insertBefore(C, F);
            }
            return c(this.options, C), J.setResolution(this.getResolution()), L;
          }
          layer(J = "default", H = {}) {
            H = Object.assign({}, this.options, H), H.id = J;
            const L = this.orderedChildren;
            for (let r = 0; r < L.length; r++)
              if (L[r].id === J)
                return L[r];
            const C = H.worker;
            let F;
            return C ? F = new W.default(H) : F = new n.default(H), this.appendChild(F), F;
          }
          async preload(...J) {
            const H = [], L = [], C = [];
            for (let F = 0; F < J.length; F++) {
              const r = J[F];
              let K;
              if (typeof r == "string")
                K = Object(V.loadTexture)(r);
              else if (Array.isArray(r))
                K = Object(V.loadFrames)(...r);
              else {
                const {
                  id: g,
                  src: v
                } = r;
                K = Object(V.loadTexture)(v, g);
              }
              K instanceof Promise || (K = Promise.resolve(K)), L.push(K.then((g) => {
                H.push(g), C[F] = g;
                const v = new a.default({
                  type: "preload",
                  detail: {
                    current: g,
                    loaded: H,
                    resources: J
                  }
                });
                this.dispatchEvent(v);
              }));
            }
            return await Promise.all(L), C;
          }
          /* override */
          removeChild(J) {
            const H = super.removeChild(J);
            if (H) {
              J._prepareRenderFinished && J._prepareRenderFinished();
              const L = J.canvas;
              L && L.remove && L.remove(), J.offscreen && this[t]--;
            }
            return H;
          }
          // for offscreen mode rendering
          render() {
            const J = this.orderedChildren;
            let H = null;
            const L = [];
            for (let C = 0; C < J.length; C++) {
              const F = J[C], r = L.length > 0;
              if (F instanceof n.default && !F.offscreen)
                if (!F.autoRender)
                  r && (console.warn("Some offscreen canvas will not be rendered."), L.length = 0);
                else if (H = F, r) {
                  F.renderer.clear();
                  for (let K = 0; K < L.length; K++) {
                    const g = L[K];
                    g.render(), y(F, g);
                  }
                  L.length = 0, F.render({
                    clear: !1
                  });
                } else
                  F.prepareRender && F.render();
              else
                F.offscreen ? H ? (F.prepareRender && F.render(), y(H, F)) : L.push(F) : F instanceof W.default && r && (console.warn("Some offscreen canvas will not be rendered."), L.length = 0);
            }
          }
          /* override */
          replaceChild(J, H) {
            const L = super.replaceChild(J, H);
            H.canvas.remove && H.canvas.remove(), H.offscreen && this[t]--;
            const C = J.canvas;
            if (!J.offscreen) {
              const F = G(this, J);
              this.container.insertBefore(C, F);
            }
            return c(this.options, C), J.setResolution(this.getResolution()), L;
          }
          resize() {
            const J = this.options;
            this.children.forEach((H) => {
              c(J, H.canvas);
            }), this.setResolution(J), this.dispatchEvent({
              type: "resize"
            });
          }
          /* override */
          setResolution({
            width: J,
            height: H
          } = {}) {
            const L = this.container, {
              clientWidth: C,
              clientHeight: F
            } = L;
            (J == null || H == null) && (J = J ?? C, H = H ?? F);
            const {
              mode: r,
              displayRatio: K
            } = this.options;
            if (J *= K, H *= K, this.options.left = 0, this.options.top = 0, r === "stickyHeight" || r === "stickyLeft" || r === "stickyRight") {
              const g = J;
              J = C * H / F, r === "stickyHeight" && (this.options.left = 0.5 * (J - g)), r === "stickyRight" && (this.options.left = J - g);
            } else if (r === "stickyWidth" || r === "stickyTop" || r === "stickyBottom") {
              const g = H;
              H = F * J / C, r === "stickyWidth" && (this.options.top = 0.5 * (H - g)), r === "stickyBottom" && (this.options.top = H - g);
            }
            super.setResolution({
              width: J,
              height: H
            });
          }
          snapshot({
            offscreen: J = !1,
            layers: H
          } = {}) {
            const L = J ? "snapshotOffScreenCanvas" : "snapshotCanvas", {
              width: C,
              height: F
            } = this.getResolution();
            this[L] = this[L] || b.ENV.createCanvas(C, F, {
              offscreen: J
            });
            const r = this[L].getContext("2d");
            H = H || this.orderedChildren, this[L].width = C, this[L].height = F;
            for (let K = 0; K < H.length; K++) {
              const g = H[K];
              if (!g.options.ignoreSnapshot) {
                g.render && g.render();
                const v = g.canvas;
                v && v !== g && r.drawImage(v, 0, 0, C, F);
              }
            }
            return this[L];
          }
        }
        typeof document < "u" && (R.prototype.layer3d = function(S, J = {}) {
          const H = J.url || "https://unpkg.com/sprite-extend-3d/dist/sprite-extend-3d.min.js";
          return new Promise((L, C) => {
            const F = document.createElement("script");
            F.async = !1, F.src = H, F.onload = () => {
              try {
                L(this.layer3d(S, J));
              } catch (r) {
                C(r);
              }
            }, document.documentElement.appendChild(F);
          });
        }), h.default.registerNode(R, "scene");
      }).call(this, d(22));
    },
    /* 291 */
    /***/
    function(s, l, d) {
      d.r(l), d.d(l, "default", function() {
        return b;
      });
      var i = d(214);
      d(1).glMatrix.setMatrixArrayType(Array);
      function b(m, {
        offsetTop: o = 0,
        offsetLeft: n = 0,
        displayRatio: W = 1
      } = {}) {
        let e, I;
        const a = [], {
          left: V,
          top: h,
          width: Y,
          height: p
        } = m.target.getBoundingClientRect(), G = m.target.width, y = m.target.height, Z = m.changedTouches || [m];
        for (let c = 0; c < Z.length; c++) {
          const t = Z[c], R = t.identifier, {
            clientX: S,
            clientY: J
          } = t;
          S != null && J != null && a.push({
            x: Math.round((S | 0) - V),
            y: Math.round((J | 0) - h),
            identifier: R
          });
        }
        a.length <= 0 && a.push({
          x: e,
          y: I
        });
        const X = [];
        return a.forEach((c) => {
          c.x != null && c.y != null && (e = (c.x * G / Y - n) / W, I = (c.y * y / p - o) / W);
          const t = new i.default(m);
          Object.defineProperties(t, {
            layerX: {
              value: e,
              configurable: !0
            },
            layerY: {
              value: I,
              configurable: !0
            },
            originalX: {
              value: c.x
            },
            originalY: {
              value: c.y
            },
            x: {
              value: e,
              configurable: !0
            },
            y: {
              value: I,
              configurable: !0
            },
            identifier: {
              value: c.identifier
            }
          }), X.push(t);
        }), X;
      }
    }
    /******/
  ])
);
Hd.version;
Hd.Arc;
Hd.Block;
Hd.Cloud;
Hd.Color;
Hd.Ellipse;
Hd.Gradient;
Hd.Group;
Hd.Label;
Hd.Layer;
Hd.LayerWorker;
Hd.Node;
Hd.Parallel;
Hd.Path;
Hd.Polyline;
Hd.Rect;
Hd.Regular;
Hd.Ring;
Hd.Scene;
Hd.Sprite;
Hd.SpriteSvg;
Hd.Star;
Hd.Triangle;
Hd.helpers;
Hd.createElement;
Hd.isSpriteNode;
Hd.registerNode;
Hd.requestAnimationFrame;
Hd.cancelAnimationFrame;
Hd.ENV;
function Ga(s, l) {
  if (s && l) {
    const d = Math.min(s.originX, l.originX), i = Math.min(s.originY, l.originY), b = Math.max(s.originX + s.width, l.originX + l.width), m = Math.max(s.originY + s.height, l.originY + l.height), o = b - d, n = m - i;
    return { originX: d, originY: i, width: o, height: n };
  }
  return l || s;
}
const Fl = (s, l) => new Promise(function(d) {
  window.requestIdleCallback ? requestIdleCallback(() => {
    d(1);
  }, { timeout: l }) : setTimeout(() => {
    d(2);
  }, l);
}).then(function() {
  s();
}, () => {
  s();
}), Ti = (s) => {
  const l = s.webkitBackingStorePixelRatio || s.mozBackingStorePixelRatio || s.msBackingStorePixelRatio || s.oBackingStorePixelRatio || s.backingStorePixelRatio || 1;
  return Math.max(1, (window.devicePixelRatio || 1) / l);
};
class ol extends Mb {
  constructor(l, d) {
    super(l), Object.defineProperty(this, "namespace", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "serviceStorage", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "storage", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "stateDisposer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "asyncClockState", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), ol.syncInterval = (d || ol.syncInterval) * 0.5, this.namespace = ol.namespace, this.serviceStorage = this.getNamespaceData(), this.storage = qd(this.serviceStorage);
  }
  getViewIdBySecenPath(l) {
    const d = this.getNamespaceData();
    for (const [i, b] of Object.entries(d))
      for (const m of Object.keys(b))
        if (m === l)
          return i;
  }
  getScenePathData(l) {
    const d = this.getNamespaceData();
    for (const i of Object.values(d))
      for (const b of Object.keys(i))
        if (b === l)
          return qd(i[b]);
  }
  getStorageData(l, d) {
    const i = this.getNamespaceData();
    return i[l] && qd(i[l][d]) || void 0;
  }
  hasSelector(l, d) {
    const i = this.storage && this.storage[l] && this.storage[l][d];
    return !!(i && Object.keys(i).find((b) => this.isOwn(b) && this.getLocalId(b) === Ld));
  }
  addStorageStateListener(l) {
    this.stateDisposer = zb(async () => {
      const d = this.getNamespaceData(), i = this.diffFun(this.serviceStorage, d);
      this.serviceStorage = d;
      for (const [b, m] of Object.entries(i))
        if (m && m.newValue === void 0) {
          const { viewId: o, scenePath: n } = m;
          o && n && this.storage[o] && delete this.storage[o][n][b];
        } else if (m && m.newValue) {
          const { viewId: o, scenePath: n } = m;
          this.storage[o] || (this.storage[o] = {}), this.storage[o][n] || (this.storage[o][n] = {}), this.storage[o][n][b] = qd(m.newValue);
        }
      Object.keys(i).length > 0 && l(i);
    });
  }
  removeStorageStateListener() {
    this.stateDisposer && this.stateDisposer();
  }
  diffFun(l, d) {
    const i = $d(l), b = $d(d), m = {};
    for (const o of i) {
      if (_d(l[o], d[o]))
        continue;
      const n = this.diffFunByscenePath(l[o] || {}, d[o] || {}, o);
      Object.assign(m, n);
    }
    for (const o of b)
      if (!i.includes(o)) {
        const n = this.diffFunByscenePath(l[o] || {}, d[o] || {}, o);
        Object.assign(m, n);
      }
    return m;
  }
  diffFunByscenePath(l, d, i) {
    const b = $d(l), m = $d(d), o = {};
    for (const n of b) {
      if (_d(l[n], d[n]))
        continue;
      const W = this.diffFunByKeys(l[n] || {}, d[n] || {}, n, i);
      Object.assign(o, W);
    }
    for (const n of m)
      if (!b.includes(n)) {
        const W = this.diffFunByKeys(l[n] || {}, d[n] || {}, n, i);
        Object.assign(o, W);
      }
    return o;
  }
  diffFunByKeys(l, d, i, b) {
    const m = $d(l), o = $d(d), n = {};
    for (const W of m) {
      if (o.includes(W)) {
        if (_d(l[W], d[W]))
          continue;
        n[W] = {
          oldValue: l[W],
          newValue: d[W],
          viewId: b,
          scenePath: i
        };
        continue;
      }
      n[W] = {
        oldValue: l[W],
        newValue: void 0,
        viewId: b,
        scenePath: i
      };
    }
    for (const W of o)
      m.includes(W) || (n[W] = {
        oldValue: void 0,
        newValue: d[W],
        viewId: b,
        scenePath: i
      });
    return n;
  }
  transformKey(l) {
    return this.uid + pl + l;
  }
  isOwn(l) {
    return l.split(pl)[0] === this.uid;
  }
  dispatch(l) {
    const { type: d, workId: i, ops: b, index: m, opt: o, toolsType: n, removeIds: W, updateNodeOpt: e, op: I, selectIds: a, isSync: V, scenePath: h, viewId: Y } = l;
    if (Y)
      switch (d) {
        case yd.Clear:
          const p = {};
          h && this.storage[Y] && this.storage[Y][h] ? (delete this.storage[Y][h], this.setState(p, { isSync: V, viewId: Y, scenePath: h })) : this.storage[Y] && (delete this.storage[Y], this.setState(p, { isSync: V, viewId: Y, scenePath: "" }));
          break;
        case yd.CreateWork:
          if (h && i && n && o) {
            const c = this.isLocalId(i.toString()) ? this.transformKey(i) : i;
            this.updateValue(c.toString(), {
              type: yd.CreateWork,
              workId: i,
              toolsType: n,
              opt: o
            }, { isSync: V, viewId: Y, scenePath: h });
          }
          break;
        case yd.DrawWork:
          if (h && i && typeof m == "number" && (I != null && I.length)) {
            const c = this.isLocalId(i.toString()) ? this.transformKey(i) : i, t = this.storage[Y][h][c], R = ((t == null ? void 0 : t.op) || []).slice(0, m).concat(I);
            t && R && this.updateValue(c.toString(), {
              ...t,
              type: yd.DrawWork,
              op: R,
              index: m
            }, { isSync: V, viewId: Y, scenePath: h });
          }
          break;
        case yd.FullWork:
          if (h && i) {
            const c = this.isLocalId(i.toString()) ? this.transformKey(i) : i, t = this.storage[Y][h][c], R = e || (t == null ? void 0 : t.updateNodeOpt), S = n || (t == null ? void 0 : t.toolsType), J = o || (t == null ? void 0 : t.opt), H = b || (t == null ? void 0 : t.ops);
            S && J && this.updateValue(c.toString(), {
              type: yd.FullWork,
              updateNodeOpt: R,
              workId: c,
              toolsType: S,
              opt: J,
              ops: H
            }, { isSync: V, viewId: Y, scenePath: h });
          }
          break;
        case yd.RemoveNode:
          if (h && (W != null && W.length)) {
            const c = W.map((t) => this.isLocalId(t + "") ? this.transformKey(t) : t);
            this.storage[Y] && this.storage[Y][h] && Object.keys(this.storage[Y][h]).map((t) => {
              c != null && c.includes(t) && this.updateValue(t, void 0, { isSync: V, viewId: Y, scenePath: h });
            });
          }
          break;
        case yd.UpdateNode:
          if (h && i && (e || b || o)) {
            const c = this.isLocalId(i.toString()) ? this.transformKey(i) : i, t = this.storage[Y][h][c];
            t && (t.updateNodeOpt = e, (b || I) && (t.ops = b, t.op = I), o && (t.opt = o), t.type = yd.FullWork, this.updateValue(c.toString(), t, { isSync: V, viewId: Y, scenePath: h }));
          }
          break;
        case yd.Select:
          if (!h)
            return;
          let G;
          a != null && a.length && (G = a.map((c) => this.isLocalId(c + "") ? this.transformKey(c) : c));
          const y = this.transformKey(Ld), Z = this.storage[Y][h][y], X = o || (Z == null ? void 0 : Z.opt);
          G && this.checkOtherSelector(y, G, { isSync: V, viewId: Y, scenePath: h }), this.updateValue(y, G && {
            type: yd.Select,
            toolsType: Gd.Selector,
            opt: X,
            selectIds: G
          }, { isSync: V, viewId: Y, scenePath: h });
          break;
      }
  }
  checkOtherSelector(l, d, i) {
    const { viewId: b, scenePath: m } = i;
    for (const o of Object.keys(this.storage[b][m]))
      if (o !== l && this.getLocalId(o) === Ld) {
        const n = this.storage[b][m][o];
        if (n && n.selectIds) {
          const W = n.selectIds.filter((e) => !d.includes(e));
          W.length > 0 && (n.selectIds = W), this.updateValue(o, W.length && n || void 0, i);
        }
      }
  }
  setState(l, d) {
    const { viewId: i, scenePath: b } = d, m = $d(l);
    for (let o = 0; o < m.length; o++) {
      const n = m[o], W = l[n];
      typeof W < "u" ? (this.storage[i] || (this.storage[i] = {}), this.storage[i][b] || (this.storage[i][b] = {}), this.storage[i][b][n] = W) : delete this.storage[i][b][n];
    }
    this.runSyncService(d);
  }
  updateValue(l, d, i) {
    const { viewId: b, scenePath: m } = i;
    d === void 0 ? delete this.storage[b][m][l] : (this.storage[b] || (this.storage[b] = {}), this.storage[b][m] || (this.storage[b][m] = {}), this.storage[b][m][l] = d), this.runSyncService(i);
  }
  runSyncService(l) {
    this.asyncClockState || (this.asyncClockState = !0, setTimeout(() => {
      l.isSync ? (this.asyncClockState = !1, this.syncSerivice(l.isAfterUpdate)) : Fl(() => {
        this.asyncClockState = !1, this.syncSerivice(l.isAfterUpdate);
      }, ol.syncInterval);
    }, l != null && l.isSync ? 0 : ol.syncInterval));
  }
  syncSerivice(l = !1) {
    const d = $d(this.serviceStorage), i = $d(this.storage), b = /* @__PURE__ */ new Map();
    for (const m of d) {
      if (!i.includes(m)) {
        b.set(m, void 0);
        continue;
      }
      _d(this.serviceStorage[m], this.storage[m]) || this.syncViewData(m, l);
    }
    for (const m of i)
      d.includes(m) || b.set(m, this.storage[m]);
    if (b.size > 5)
      this.syncStorageView(this.storage, l);
    else
      for (const [m, o] of b.entries())
        this.syncUpdataView(m, o, l);
  }
  syncViewData(l, d = !1) {
    const i = $d(this.serviceStorage[l]), b = $d(this.storage[l]), m = /* @__PURE__ */ new Map();
    for (const o of i) {
      if (!b.includes(o)) {
        m.set(o, void 0);
        continue;
      }
      _d(this.serviceStorage[l][o], this.storage[l][o]) || this.syncScenePathData(l, o, d);
    }
    for (const o of b)
      i.includes(o) || m.set(o, this.storage[l][o]);
    if (m.size > 5)
      this.syncStorageScenePath(l, this.storage[l], d);
    else
      for (const [o, n] of m.entries())
        this.syncUpdataScenePath(l, o, n, d);
  }
  syncScenePathData(l, d, i = !1) {
    const b = $d(this.serviceStorage[l][d]), m = $d(this.storage[l][d]), o = /* @__PURE__ */ new Map();
    for (const n of b) {
      if (!m.includes(n)) {
        o.set(n, void 0);
        continue;
      }
      _d(this.serviceStorage[l][d][n], this.storage[l][d][n]) || o.set(n, this.storage[l][d][n]);
    }
    for (const n of m)
      b.includes(n) || o.set(n, this.storage[l][d][n]);
    if (o.size > 5)
      this.syncStorageKey(l, d, this.storage[l][d], i);
    else
      for (const [n, W] of o.entries())
        this.syncUpdataKey(l, d, n, W, i);
  }
  syncUpdataView(l, d, i = !1) {
    var m;
    Object.keys(this.serviceStorage).length ? (i || (d === void 0 ? delete this.serviceStorage[l] : this.serviceStorage[l] = qd(d)), (m = this.plugin) == null || m.updateAttributes([this.namespace, l], d)) : this.syncStorageView(this.storage, i);
  }
  syncStorageView(l, d = !1) {
    var i;
    d || l && (this.serviceStorage = qd(l)), (i = this.plugin) == null || i.updateAttributes([this.namespace], l);
  }
  syncUpdataScenePath(l, d, i, b = !1) {
    var o;
    Object.keys(this.serviceStorage[l]).length ? (b || (i === void 0 ? delete this.serviceStorage[l][d] : this.serviceStorage[l][d] = i), (o = this.plugin) == null || o.updateAttributes([this.namespace, l, d], i)) : this.syncStorageScenePath(l, this.storage[l], b);
  }
  syncStorageScenePath(l, d, i = !1) {
    var b;
    i || d && (this.serviceStorage[l] = d), (b = this.plugin) == null || b.updateAttributes([this.namespace, l], d);
  }
  syncUpdataKey(l, d, i, b, m = !1) {
    var n;
    Object.keys(this.serviceStorage[l][d]).length ? (m || (b === void 0 ? delete this.serviceStorage[l][d][i] : this.serviceStorage[l][d][i] = b), (n = this.plugin) == null || n.updateAttributes([this.namespace, l, d, i], b)) : this.syncStorageKey(l, d, this.storage, m);
  }
  syncStorageKey(l, d, i, b = !1) {
    var m;
    b || (this.serviceStorage[l][d] = i), (m = this.plugin) == null || m.updateAttributes([this.namespace, l, d], i);
  }
  keyTransformWorkId(l) {
    const d = l.split(pl);
    return d.length === 2 ? d[1] : l;
  }
  destroy() {
    this.removeStorageStateListener(), this.serviceStorage = {}, this.storage = {};
  }
}
Object.defineProperty(ol, "namespace", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "PluginState"
});
Object.defineProperty(ol, "syncInterval", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 500
});
class ua {
  constructor() {
    Object.defineProperty(this, "roomMembers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "onChangeHooks", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: /* @__PURE__ */ new Set()
    });
  }
  setRoomMembers(l) {
    this.executChangeUidHook(this.roomMembers, l), this.roomMembers = l;
  }
  executChangeUidHook(l, d) {
    const i = {
      online: d.map((b) => {
        var m;
        return ((m = b.payload) == null ? void 0 : m.uid) || b.session;
      }),
      offline: l.map((b) => {
        var m;
        return ((m = b.payload) == null ? void 0 : m.uid) || b.session;
      })
    };
    this.onChangeHooks.forEach((b) => b(i));
  }
  getRoomMember(l) {
    return this.roomMembers.find((d) => {
      var i;
      return ((i = d.payload) == null ? void 0 : i.uid) === l;
    });
  }
  isOnLine(l) {
    return !this.getRoomMember(l);
  }
  onUidChangeHook(l) {
    this.onChangeHooks.add(l);
  }
  destroy() {
    this.onChangeHooks.clear();
  }
}
var Kl;
(function(s) {
  s[s.Text = 1] = "Text", s[s.Shape = 2] = "Shape";
})(Kl || (Kl = {}));
class fd {
  createProxy(l) {
    const d = new Proxy(l, {
      get(i, b, m) {
        const o = fd.interceptors.hasOwnProperty(b) ? fd.interceptors : i;
        return Reflect.get(o, b, m);
      }
    });
    return fd.proxyToRaw.set(d, l), d;
  }
}
Object.defineProperty(fd, "proxyToRaw", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /* @__PURE__ */ new WeakMap()
});
Object.defineProperty(fd, "interceptors", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: {
    entries(...s) {
      return fd.proxyToRaw.get(this).entries(...s);
    },
    forEach(...s) {
      return fd.proxyToRaw.get(this).forEach(...s);
    },
    size() {
      return fd.proxyToRaw.get(this).size;
    },
    get(s) {
      return fd.proxyToRaw.get(this).get(s);
    },
    set(s, l) {
      return fd.proxyToRaw.get(this).set(s, l);
    },
    delete(s, l) {
      return fd.proxyToRaw.get(this).delete(s);
    },
    clear() {
      return fd.proxyToRaw.get(this).clear();
    }
  }
});
class Va {
  // private activeIdCache?:string;
  constructor(l) {
    Object.defineProperty(this, "internalMsgEmitter", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "control", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "collector", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "editors", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "activeId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "proxyMap", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
    const { control: d, internalMsgEmitter: i } = l;
    this.control = d, this.internalMsgEmitter = i;
    const b = /* @__PURE__ */ new Map();
    this.proxyMap = new fd();
    const m = this, o = fd.interceptors.set;
    fd.interceptors.set = function(W, e) {
      return m.interceptors.set(W, e), o.call(this, W, e);
    };
    const n = fd.interceptors.delete;
    fd.interceptors.delete = function(W, e) {
      return m.interceptors.delete(W, e), n.call(this, W);
    }, this.editors = this.proxyMap.createProxy(b), this.collector = d.collector;
  }
  filterEditor(l) {
    const d = /* @__PURE__ */ new Map();
    return this.editors.forEach((i, b) => {
      i.viewId === l && d.set(b, i);
    }), d;
  }
  get interceptors() {
    return {
      set: (l, d) => {
        var W, e, I, a, V;
        const b = this.collector.isLocalId(l) ? this.collector.transformKey(l) : l, { viewId: m, scenePath: o } = d, n = this.collector.storage[m] && this.collector.storage[m][o] && this.collector.storage[m][o][b] || void 0;
        n ? n.toolsType === Gd.Text && (d.canWorker && ((a = this.control.worker) == null || a.taskBatchData.add({
          workId: l,
          msgType: yd.UpdateNode,
          dataType: d.dataType || Fd.Local,
          toolsType: Gd.Text,
          opt: d.opt,
          viewId: m,
          scenePath: o
        }), (V = this.control.worker) == null || V.runAnimation()), d.canSync && Fl(() => {
          var h;
          (h = this.collector) == null || h.dispatch({
            type: yd.UpdateNode,
            workId: l,
            toolsType: Gd.Text,
            opt: d.opt,
            viewId: m,
            scenePath: o
          });
        }, this.control.worker.maxLastSyncTime)) : d.type === Kl.Text && (d.canSync && ((W = this.collector) == null || W.dispatch({
          type: d.opt.text && yd.FullWork || yd.CreateWork,
          workId: l,
          toolsType: Gd.Text,
          opt: d.opt,
          isSync: !0,
          viewId: m,
          scenePath: o
        })), d.canWorker && ((e = this.control.worker) == null || e.taskBatchData.add({
          workId: l,
          msgType: d.opt.text && yd.FullWork || yd.CreateWork,
          dataType: d.dataType || Fd.Local,
          toolsType: Gd.Text,
          opt: d == null ? void 0 : d.opt,
          viewId: m,
          scenePath: o
        }), (I = this.control.worker) == null || I.runAnimation()));
      },
      delete: (l) => {
        var I, a;
        const i = this.collector.isLocalId(l) ? this.collector.transformKey(l) : l, b = this.editors.get(l), { viewId: m, scenePath: o, canSync: n, canWorker: W } = b, e = this.collector.storage[m][o][i];
        e && e.toolsType === Gd.Text && (W && ((I = this.control.worker) == null || I.taskBatchData.add({
          workId: l,
          toolsType: Gd.Text,
          msgType: yd.RemoveNode,
          dataType: Fd.Local,
          viewId: m,
          scenePath: o
        }), (a = this.control.worker) == null || a.runAnimation()), n && Fl(() => {
          var V;
          (V = this.collector) == null || V.dispatch({
            type: yd.RemoveNode,
            removeIds: [l],
            toolsType: Gd.Text,
            viewId: m,
            scenePath: o
          });
        }, this.control.worker.maxLastSyncTime));
      },
      clear() {
      }
    };
  }
  computeTextActive(l, d) {
    var m, o, n, W;
    const i = (m = this.control.viewContainerManager) == null ? void 0 : m.transformToScenePoint(l, d), b = (o = this.control.viewContainerManager) == null ? void 0 : o.getCurScenePath(d);
    d && b && ((n = this.control.worker) == null || n.taskBatchData.add({
      msgType: yd.GetTextActive,
      dataType: Fd.Local,
      op: i,
      viewId: d,
      scenePath: b
    }), (W = this.control.worker) == null || W.runAnimation());
  }
  checkEmptyTextBlur() {
    if (this.activeId) {
      const l = this.editors.get(this.activeId);
      (l == null ? void 0 : l.opt.text) && (l == null ? void 0 : l.opt.text.replace(/\s*,/g, "")) ? this.unActive() : this.delete(this.activeId, !0, !0);
    }
  }
  onCameraChange(l, d) {
    var i, b;
    for (const [m, o] of this.editors.entries())
      if (o.viewId === d) {
        const { boxPoint: n, boxSize: W } = o.opt, e = n && ((i = this.control.viewContainerManager) == null ? void 0 : i.transformToOriginPoint(n, o.viewId)), I = (b = this.control.viewContainerManager) == null ? void 0 : b.getCurScenePath(d);
        if (I && d) {
          const a = {
            x: e && e[0] || 0,
            y: e && e[1] || 0,
            w: W && W[0] || 0,
            h: W && W[1] || 0,
            opt: o.opt,
            scale: l.scale,
            type: Kl.Text,
            viewId: d,
            scenePath: I,
            canWorker: !1,
            canSync: !1
          };
          this.editors.set(m, a), this.control.viewContainerManager.setActiveTextEditor(d, this.activeId);
        }
      }
  }
  onServiceDerive(l) {
    var h, Y;
    const { workId: d, opt: i, msgType: b, viewId: m, scenePath: o } = l;
    if (!d || !m || !o)
      return;
    const n = d.toString();
    if (b === yd.RemoveNode) {
      this.delete(n, !1, !0);
      return;
    }
    const { boxPoint: W, boxSize: e } = i, I = W && ((h = this.control.viewContainerManager) == null ? void 0 : h.transformToOriginPoint(W, m)), a = this.control.viewContainerManager.getView(m), V = {
      x: I && I[0] || 0,
      y: I && I[1] || 0,
      w: e && e[0] || 0,
      h: e && e[1] || 0,
      opt: i,
      type: Kl.Text,
      canWorker: !0,
      canSync: !1,
      dataType: Fd.Service,
      scale: ((Y = a == null ? void 0 : a.cameraOpt) == null ? void 0 : Y.scale) || 1,
      viewId: m,
      scenePath: o
    };
    this.editors.set(n, V), this.control.viewContainerManager.setActiveTextEditor(m, this.activeId);
  }
  updateForLocalEditor(l, d) {
    this.editors.set(l, d);
  }
  // private effectUpdate(activeId?:string): void {
  //     if (activeId) {
  //         if (activeId !== this.activeId) {
  //             this.checkEmptyTextBlur();
  //         }
  //         this.active(activeId);
  //         return;
  //     }
  //     this.checkEmptyTextBlur();
  // }
  active(l) {
    const d = this.editors.get(l);
    d && d.viewId && (d.isActive = !0, d.opt.workState = ud.Start, this.activeId = l, this.control.viewContainerManager.setActiveTextEditor(d.viewId, this.activeId));
  }
  unActive() {
    const l = this.activeId && this.editors.get(this.activeId);
    l && l.viewId && (l.opt.workState = ud.Done, this.activeId = void 0, this.control.viewContainerManager.setActiveTextEditor(l.viewId, this.activeId));
  }
  createTextForMasterController(l) {
    const { workId: d, isActive: i, ...b } = l;
    i && (this.checkEmptyTextBlur(), this.activeId = d), b.dataType = Fd.Local, b.canWorker = !0, b.canSync = !0, this.editors.set(d, b), this.control.viewContainerManager.setActiveTextEditor(b.viewId, this.activeId);
  }
  updateTextForMasterController(l) {
    const { workId: d, isDel: i, ...b } = l;
    if (i)
      this.activeId === d && (this.activeId = void 0), this.editors.delete(d);
    else {
      const m = this.editors.get(d) || {};
      b.dataType = Fd.Local, b.canWorker = !0, b.canSync = !0, this.editors.set(d, { ...m, ...b });
    }
    this.control.viewContainerManager.setActiveTextEditor(b.viewId, this.activeId);
  }
  updateTextForWorker(l) {
    const { workId: d, isDel: i, isActive: b, ...m } = l;
    if (i)
      this.activeId === d && (this.activeId = void 0), this.editors.delete(d);
    else if (b)
      this.editors.get(d) && (m.dataType = void 0, m.canWorker = !1, m.canSync = !1, this.active(d));
    else {
      const o = this.editors.get(d) || {};
      m.dataType = void 0, m.canWorker = !1, m.canSync = !0, this.editors.set(d, { ...o, ...m });
    }
    this.control.viewContainerManager.setActiveTextEditor(m.viewId, this.activeId);
  }
  get(l) {
    return this.editors.get(l);
  }
  delete(l, d, i) {
    const b = this.editors.get(l);
    if (b) {
      const m = b.viewId;
      b.canSync = d, b.canWorker = i, this.editors.delete(l), this.activeId === l && (this.activeId = void 0), this.control.viewContainerManager.setActiveTextEditor(m, this.activeId);
    }
  }
  clear(l, d) {
    this.editors.forEach((i, b) => {
      i.viewId === l && (d && (i.canSync = !1), i.canWorker = !1, this.editors.delete(b));
    }), this.activeId = void 0, this.control.viewContainerManager.setActiveTextEditor(l, this.activeId);
  }
  destory() {
    this.editors.clear(), this.activeId = void 0;
  }
}
class al extends Mb {
  constructor(l, d) {
    super(l), Object.defineProperty(this, "serviceStorage", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "storage", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "stateDisposer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "asyncClockTimer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "namespace", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.namespace = al.namespace, al.syncInterval = (d || al.syncInterval) * 0.5, this.serviceStorage = this.getNamespaceData(), this.storage = qd(this.serviceStorage);
  }
  addStorageStateListener(l) {
    this.stateDisposer = zb(async () => {
      const d = this.getNamespaceData(), i = this.getDiffMap(this.serviceStorage, d);
      this.serviceStorage = d, i.size && l(i);
    });
  }
  getDiffMap(l, d) {
    const i = /* @__PURE__ */ new Map();
    for (const [b, m] of Object.entries(d))
      b !== this.uid && (m && _d(l[b], m) || m && i.set(b, m));
    return i;
  }
  removeStorageStateListener() {
    this.stateDisposer && this.stateDisposer();
  }
  transformKey(l) {
    return this.uid + pl + l;
  }
  isOwn(l) {
    return l === this.uid;
  }
  dispatch(l) {
    const { type: d, op: i, isSync: b, viewId: m } = l;
    switch (d) {
      case Yl.Cursor:
        i && this.pushValue(this.uid, {
          type: Yl.Cursor,
          op: i,
          viewId: m
        }, { isSync: b });
        break;
    }
  }
  pushValue(l, d, i) {
    var b;
    this.storage[l] || (this.storage[l] = []), (b = this.storage[l]) == null || b.push(d), this.runSyncService(i);
  }
  clearValue(l) {
    var i;
    this.storage[l] = void 0, Object.keys(this.serviceStorage).length && ((i = this.plugin) == null || i.updateAttributes([this.namespace, l], void 0));
  }
  runSyncService(l) {
    this.asyncClockTimer || (this.asyncClockTimer = setTimeout(() => {
      l != null && l.isSync ? (this.asyncClockTimer = void 0, this.syncSerivice()) : Fl(() => {
        this.asyncClockTimer = void 0, this.syncSerivice();
      }, al.syncInterval);
    }, l != null && l.isSync ? 0 : al.syncInterval));
  }
  syncSerivice() {
    var d;
    Object.keys(this.serviceStorage).length ? Object.keys(this.storage).forEach((i) => {
      var b;
      (b = this.plugin) == null || b.updateAttributes([this.namespace, i], this.storage[i]);
    }) : (d = this.plugin) == null || d.updateAttributes(this.namespace, this.storage), this.storage = {};
  }
  destroy() {
    this.removeStorageStateListener(), this.storage = {}, this.serviceStorage = {};
  }
}
Object.defineProperty(al, "syncInterval", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 500
});
Object.defineProperty(al, "namespace", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "PluginEvent"
});
var xb;
(function(s) {
  s[s.Event = 0] = "Event", s[s.Storage = 1] = "Storage";
})(xb || (xb = {}));
class ha {
  // private worker?: MasterController;
  constructor(l) {
    var b, m;
    Object.defineProperty(this, "internalMsgEmitter", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "control", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "eventCollector", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "roomMember", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "animationId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "removeTimerId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "animationPointWorkers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: /* @__PURE__ */ new Map()
    }), Object.defineProperty(this, "animationDrawWorkers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: /* @__PURE__ */ new Map()
    });
    const { control: d, internalMsgEmitter: i } = l;
    this.internalMsgEmitter = i, this.control = d, this.roomMember = d.roomMember, this.eventCollector = new al(d.plugin, (m = (b = this.control.pluginOptions) == null ? void 0 : b.syncOpt) == null ? void 0 : m.interval), this.eventCollector.addStorageStateListener((o) => {
      o.forEach((n, W) => {
        if (this.eventCollector.uid !== W) {
          const e = [];
          n == null || n.forEach((I) => {
            if (I && I.type === Yl.Cursor && I.op && I.viewId) {
              const a = [];
              for (let V = 0; V < I.op.length; V += 2) {
                const h = I.op[V], Y = I.op[V + 1];
                if (il(h) && il(Y)) {
                  const p = this.control.viewContainerManager.transformToOriginPoint([h, Y], I.viewId);
                  a.push(...p, I.viewId);
                } else
                  a.push(h, Y, I.viewId);
              }
              e.push(...a);
            }
          }), e.length && (this.activePointWorkShape(W, e), this.runAnimation(), this.removeTimerId && (clearTimeout(this.removeTimerId), this.removeTimerId = void 0));
        }
      });
    });
  }
  activePointWorkShape(l, d) {
    var o;
    if (!this.roomMember.getRoomMember(l))
      return;
    const b = this.animationDrawWorkers.get(l), m = this.animationPointWorkers.get(l);
    if (!m && d) {
      const n = {
        animationIndex: 0,
        animationWorkData: d,
        freeze: (b == null ? void 0 : b.workState) === ud.Start || (b == null ? void 0 : b.workState) === ud.Doing
      };
      (o = this.animationPointWorkers) == null || o.set(l, n);
      return;
    }
    m && d && (m.animationWorkData = d, m.animationIndex = 0, m.freeze = (b == null ? void 0 : b.workState) === ud.Start || (b == null ? void 0 : b.workState) === ud.Doing);
  }
  activeDrawWorkShape(l, d, i, b) {
    var W, e;
    if (!this.roomMember.getRoomMember(l))
      return;
    if (i === ud.Start) {
      const I = this.animationPointWorkers.get(l);
      if (I)
        I.animationWorkData = [], I.animationIndex = 0, I.freeze = !0;
      else {
        const a = {
          animationIndex: 0,
          animationWorkData: [],
          freeze: !0
        };
        (W = this.animationDrawWorkers) == null || W.set(l, a);
      }
    } else if (i === ud.Done) {
      const I = this.animationPointWorkers.get(l);
      I && (I.freeze = !1);
    }
    const o = this.animationDrawWorkers.get(l), n = [];
    if (d)
      for (let I = 0; I < d.length; I += 2)
        n.push(d[I], d[I + 1], b);
    if (!o && n.length) {
      const I = {
        animationIndex: 0,
        animationWorkData: n,
        workState: i
      };
      (e = this.animationDrawWorkers) == null || e.set(l, I);
      return;
    }
    o && n.length && (o.animationWorkData = n, o.animationIndex = 0, o.workState = i);
  }
  animationCursor() {
    this.animationId = void 0;
    const l = /* @__PURE__ */ new Map();
    this.animationPointWorkers.forEach((d, i) => {
      if (d.freeze)
        return;
      const m = d.animationIndex, o = this.roomMember.getRoomMember(i);
      if (o) {
        d.animationWorkData.length - 1 > m && (d.animationIndex = m + 3);
        const n = d.animationWorkData[m], W = d.animationWorkData[m + 1], e = d.animationWorkData[m + 2];
        l.set(i, {
          x: n,
          y: W,
          roomMember: il(n) && il(W) && o || void 0,
          viewId: e
        }), d.animationWorkData.length - 1 <= d.animationIndex && this.animationPointWorkers.delete(i);
      }
    }), this.animationDrawWorkers.forEach((d, i) => {
      const b = d.animationIndex, m = this.roomMember.getRoomMember(i);
      if (m) {
        d.animationWorkData.length - 1 > b && (d.animationIndex = b + 3);
        const o = d.animationWorkData[b], n = d.animationWorkData[b + 1], W = d.animationWorkData[b + 2];
        l.set(i, {
          x: o,
          y: n,
          roomMember: il(o) && il(n) && m || void 0,
          viewId: W
        }), d.animationWorkData.length - 1 <= d.animationIndex && this.animationDrawWorkers.delete(i);
      }
    }), this.control.viewContainerManager.setActiveCursor([...l.values()]), (this.animationPointWorkers.size || this.animationDrawWorkers.size) && this.runAnimation();
  }
  runAnimation() {
    this.animationId || (this.animationId = requestAnimationFrame(this.animationCursor.bind(this)));
  }
  // injectWorker(worker: MasterController){
  //     this.worker = worker;
  // }
  sendEvent(l, d) {
    this.eventCollector.dispatch({
      type: Yl.Cursor,
      op: il(l[0]) && il(l[1]) && this.control.viewContainerManager.transformToScenePoint(l, d) || [void 0, void 0],
      viewId: d
    });
  }
  collectServiceCursor(l) {
    const { op: d, uid: i, workState: b, viewId: m } = l;
    if (i && d && b && m) {
      this.removeTimerId && (clearTimeout(this.removeTimerId), this.removeTimerId = void 0);
      const o = il(d[0]) && il(d[1]) && this.control.viewContainerManager.transformToOriginPoint(d, m) || d;
      this.activeDrawWorkShape(i, o, b, m), this.runAnimation(), b === ud.Done && !this.removeTimerId && (this.removeTimerId = setTimeout(() => {
        this.removeTimerId = void 0, this.activeDrawWorkShape(i, [void 0, void 0], ud.Done, m), this.runAnimation();
      }, 3e3));
    }
  }
  unable() {
    this.eventCollector.dispatch({
      type: Yl.Cursor,
      op: [void 0, void 0],
      viewId: this.control.viewContainerManager.focuedViewId
    });
  }
  destroy() {
    this.eventCollector.destroy();
  }
}
const aZ = "KGZ1bmN0aW9uKCl7InVzZSBzdHJpY3QiO3ZhciBtcj10eXBlb2YgZ2xvYmFsVGhpczwidSI/Z2xvYmFsVGhpczp0eXBlb2Ygd2luZG93PCJ1Ij93aW5kb3c6dHlwZW9mIGdsb2JhbDwidSI/Z2xvYmFsOnR5cGVvZiBzZWxmPCJ1Ij9zZWxmOnt9O2Z1bmN0aW9uIFZuKGcpe3JldHVybiBnJiZnLl9fZXNNb2R1bGUmJk9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChnLCJkZWZhdWx0Iik/Zy5kZWZhdWx0Omd9ZnVuY3Rpb24gQ2YoKXt0aGlzLl9fZGF0YV9fPVtdLHRoaXMuc2l6ZT0wfXZhciBSZj1DZjtmdW5jdGlvbiBJZihnLGUpe3JldHVybiBnPT09ZXx8ZyE9PWcmJmUhPT1lfXZhciBMbz1JZixMZj1MbztmdW5jdGlvbiBEZihnLGUpe2Zvcih2YXIgdD1nLmxlbmd0aDt0LS07KWlmKExmKGdbdF1bMF0sZSkpcmV0dXJuIHQ7cmV0dXJuLTF9dmFyIFhuPURmLHdmPVhuLE5mPUFycmF5LnByb3RvdHlwZSxCZj1OZi5zcGxpY2U7ZnVuY3Rpb24gV2YoZyl7dmFyIGU9dGhpcy5fX2RhdGFfXyx0PXdmKGUsZyk7aWYodDwwKXJldHVybiExO3ZhciBuPWUubGVuZ3RoLTE7cmV0dXJuIHQ9PW4/ZS5wb3AoKTpCZi5jYWxsKGUsdCwxKSwtLXRoaXMuc2l6ZSwhMH12YXIgRmY9V2YsamY9WG47ZnVuY3Rpb24gVWYoZyl7dmFyIGU9dGhpcy5fX2RhdGFfXyx0PWpmKGUsZyk7cmV0dXJuIHQ8MD92b2lkIDA6ZVt0XVsxXX12YXIgemY9VWYsJGY9WG47ZnVuY3Rpb24gR2YoZyl7cmV0dXJuICRmKHRoaXMuX19kYXRhX18sZyk+LTF9dmFyIEtmPUdmLEhmPVhuO2Z1bmN0aW9uIFlmKGcsZSl7dmFyIHQ9dGhpcy5fX2RhdGFfXyxuPUhmKHQsZyk7cmV0dXJuIG48MD8oKyt0aGlzLnNpemUsdC5wdXNoKFtnLGVdKSk6dFtuXVsxXT1lLHRoaXN9dmFyIFZmPVlmLFhmPVJmLFpmPUZmLEpmPXpmLFFmPUtmLGtmPVZmO2Z1bmN0aW9uIGVuKGcpe3ZhciBlPS0xLHQ9Zz09bnVsbD8wOmcubGVuZ3RoO2Zvcih0aGlzLmNsZWFyKCk7KytlPHQ7KXt2YXIgbj1nW2VdO3RoaXMuc2V0KG5bMF0sblsxXSl9fWVuLnByb3RvdHlwZS5jbGVhcj1YZixlbi5wcm90b3R5cGUuZGVsZXRlPVpmLGVuLnByb3RvdHlwZS5nZXQ9SmYsZW4ucHJvdG90eXBlLmhhcz1RZixlbi5wcm90b3R5cGUuc2V0PWtmO3ZhciBabj1lbixxZj1abjtmdW5jdGlvbiBfZigpe3RoaXMuX19kYXRhX189bmV3IHFmLHRoaXMuc2l6ZT0wfXZhciB0Yz1fZjtmdW5jdGlvbiBlYyhnKXt2YXIgZT10aGlzLl9fZGF0YV9fLHQ9ZS5kZWxldGUoZyk7cmV0dXJuIHRoaXMuc2l6ZT1lLnNpemUsdH12YXIgcmM9ZWM7ZnVuY3Rpb24gbmMoZyl7cmV0dXJuIHRoaXMuX19kYXRhX18uZ2V0KGcpfXZhciBpYz1uYztmdW5jdGlvbiBzYyhnKXtyZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXMoZyl9dmFyIG9jPXNjLGFjPXR5cGVvZiBtcj09Im9iamVjdCImJm1yJiZtci5PYmplY3Q9PT1PYmplY3QmJm1yLERvPWFjLGxjPURvLHVjPXR5cGVvZiBzZWxmPT0ib2JqZWN0IiYmc2VsZiYmc2VsZi5PYmplY3Q9PT1PYmplY3QmJnNlbGYsZmM9bGN8fHVjfHxGdW5jdGlvbigicmV0dXJuIHRoaXMiKSgpLGFyPWZjLGNjPWFyLGhjPWNjLlN5bWJvbCxraT1oYyx3bz1raSxObz1PYmplY3QucHJvdG90eXBlLGRjPU5vLmhhc093blByb3BlcnR5LGdjPU5vLnRvU3RyaW5nLENuPXdvP3dvLnRvU3RyaW5nVGFnOnZvaWQgMDtmdW5jdGlvbiB2YyhnKXt2YXIgZT1kYy5jYWxsKGcsQ24pLHQ9Z1tDbl07dHJ5e2dbQ25dPXZvaWQgMDt2YXIgbj0hMH1jYXRjaHt9dmFyIGk9Z2MuY2FsbChnKTtyZXR1cm4gbiYmKGU/Z1tDbl09dDpkZWxldGUgZ1tDbl0pLGl9dmFyIHBjPXZjLG1jPU9iamVjdC5wcm90b3R5cGUseWM9bWMudG9TdHJpbmc7ZnVuY3Rpb24geGMoZyl7cmV0dXJuIHljLmNhbGwoZyl9dmFyIE9jPXhjLEJvPWtpLEVjPXBjLE1jPU9jLFNjPSJbb2JqZWN0IE51bGxdIixUYz0iW29iamVjdCBVbmRlZmluZWRdIixXbz1Cbz9Cby50b1N0cmluZ1RhZzp2b2lkIDA7ZnVuY3Rpb24gUGMoZyl7cmV0dXJuIGc9PW51bGw/Zz09PXZvaWQgMD9UYzpTYzpXbyYmV28gaW4gT2JqZWN0KGcpP0VjKGcpOk1jKGcpfXZhciBybj1QYztmdW5jdGlvbiBiYyhnKXt2YXIgZT10eXBlb2YgZztyZXR1cm4gZyE9bnVsbCYmKGU9PSJvYmplY3QifHxlPT0iZnVuY3Rpb24iKX12YXIgQ3I9YmMsQWM9cm4sQ2M9Q3IsUmM9IltvYmplY3QgQXN5bmNGdW5jdGlvbl0iLEljPSJbb2JqZWN0IEZ1bmN0aW9uXSIsTGM9IltvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dIixEYz0iW29iamVjdCBQcm94eV0iO2Z1bmN0aW9uIHdjKGcpe2lmKCFDYyhnKSlyZXR1cm4hMTt2YXIgZT1BYyhnKTtyZXR1cm4gZT09SWN8fGU9PUxjfHxlPT1SY3x8ZT09RGN9dmFyIEZvPXdjLE5jPWFyLEJjPU5jWyJfX2NvcmUtanNfc2hhcmVkX18iXSxXYz1CYyxxaT1XYyxqbz1mdW5jdGlvbigpe3ZhciBnPS9bXi5dKyQvLmV4ZWMocWkmJnFpLmtleXMmJnFpLmtleXMuSUVfUFJPVE98fCIiKTtyZXR1cm4gZz8iU3ltYm9sKHNyYylfMS4iK2c6IiJ9KCk7ZnVuY3Rpb24gRmMoZyl7cmV0dXJuISFqbyYmam8gaW4gZ312YXIgamM9RmMsVWM9RnVuY3Rpb24ucHJvdG90eXBlLHpjPVVjLnRvU3RyaW5nO2Z1bmN0aW9uICRjKGcpe2lmKGchPW51bGwpe3RyeXtyZXR1cm4gemMuY2FsbChnKX1jYXRjaHt9dHJ5e3JldHVybiBnKyIifWNhdGNoe319cmV0dXJuIiJ9dmFyIFVvPSRjLEdjPUZvLEtjPWpjLEhjPUNyLFljPVVvLFZjPS9bXFxeJC4qKz8oKVtcXXt9fF0vZyxYYz0vXlxbb2JqZWN0IC4rP0NvbnN0cnVjdG9yXF0kLyxaYz1GdW5jdGlvbi5wcm90b3R5cGUsSmM9T2JqZWN0LnByb3RvdHlwZSxRYz1aYy50b1N0cmluZyxrYz1KYy5oYXNPd25Qcm9wZXJ0eSxxYz1SZWdFeHAoIl4iK1FjLmNhbGwoa2MpLnJlcGxhY2UoVmMsIlxcJCYiKS5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcKCl8IGZvciAuKz8oPz1cXFxdKS9nLCIkMS4qPyIpKyIkIik7ZnVuY3Rpb24gX2MoZyl7aWYoIUhjKGcpfHxLYyhnKSlyZXR1cm4hMTt2YXIgZT1HYyhnKT9xYzpYYztyZXR1cm4gZS50ZXN0KFljKGcpKX12YXIgdGg9X2M7ZnVuY3Rpb24gZWgoZyxlKXtyZXR1cm4gZz09bnVsbD92b2lkIDA6Z1tlXX12YXIgcmg9ZWgsbmg9dGgsaWg9cmg7ZnVuY3Rpb24gc2goZyxlKXt2YXIgdD1paChnLGUpO3JldHVybiBuaCh0KT90OnZvaWQgMH12YXIgJHI9c2gsb2g9JHIsYWg9YXIsbGg9b2goYWgsIk1hcCIpLF9pPWxoLHVoPSRyLGZoPXVoKE9iamVjdCwiY3JlYXRlIiksSm49Zmgsem89Sm47ZnVuY3Rpb24gY2goKXt0aGlzLl9fZGF0YV9fPXpvP3pvKG51bGwpOnt9LHRoaXMuc2l6ZT0wfXZhciBoaD1jaDtmdW5jdGlvbiBkaChnKXt2YXIgZT10aGlzLmhhcyhnKSYmZGVsZXRlIHRoaXMuX19kYXRhX19bZ107cmV0dXJuIHRoaXMuc2l6ZS09ZT8xOjAsZX12YXIgZ2g9ZGgsdmg9Sm4scGg9Il9fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18iLG1oPU9iamVjdC5wcm90b3R5cGUseWg9bWguaGFzT3duUHJvcGVydHk7ZnVuY3Rpb24geGgoZyl7dmFyIGU9dGhpcy5fX2RhdGFfXztpZih2aCl7dmFyIHQ9ZVtnXTtyZXR1cm4gdD09PXBoP3ZvaWQgMDp0fXJldHVybiB5aC5jYWxsKGUsZyk/ZVtnXTp2b2lkIDB9dmFyIE9oPXhoLEVoPUpuLE1oPU9iamVjdC5wcm90b3R5cGUsU2g9TWguaGFzT3duUHJvcGVydHk7ZnVuY3Rpb24gVGgoZyl7dmFyIGU9dGhpcy5fX2RhdGFfXztyZXR1cm4gRWg/ZVtnXSE9PXZvaWQgMDpTaC5jYWxsKGUsZyl9dmFyIFBoPVRoLGJoPUpuLEFoPSJfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fIjtmdW5jdGlvbiBDaChnLGUpe3ZhciB0PXRoaXMuX19kYXRhX187cmV0dXJuIHRoaXMuc2l6ZSs9dGhpcy5oYXMoZyk/MDoxLHRbZ109YmgmJmU9PT12b2lkIDA/QWg6ZSx0aGlzfXZhciBSaD1DaCxJaD1oaCxMaD1naCxEaD1PaCx3aD1QaCxOaD1SaDtmdW5jdGlvbiBubihnKXt2YXIgZT0tMSx0PWc9PW51bGw/MDpnLmxlbmd0aDtmb3IodGhpcy5jbGVhcigpOysrZTx0Oyl7dmFyIG49Z1tlXTt0aGlzLnNldChuWzBdLG5bMV0pfX1ubi5wcm90b3R5cGUuY2xlYXI9SWgsbm4ucHJvdG90eXBlLmRlbGV0ZT1MaCxubi5wcm90b3R5cGUuZ2V0PURoLG5uLnByb3RvdHlwZS5oYXM9d2gsbm4ucHJvdG90eXBlLnNldD1OaDt2YXIgQmg9bm4sJG89QmgsV2g9Wm4sRmg9X2k7ZnVuY3Rpb24gamgoKXt0aGlzLnNpemU9MCx0aGlzLl9fZGF0YV9fPXtoYXNoOm5ldyAkbyxtYXA6bmV3KEZofHxXaCksc3RyaW5nOm5ldyAkb319dmFyIFVoPWpoO2Z1bmN0aW9uIHpoKGcpe3ZhciBlPXR5cGVvZiBnO3JldHVybiBlPT0ic3RyaW5nInx8ZT09Im51bWJlciJ8fGU9PSJzeW1ib2wifHxlPT0iYm9vbGVhbiI/ZyE9PSJfX3Byb3RvX18iOmc9PT1udWxsfXZhciAkaD16aCxHaD0kaDtmdW5jdGlvbiBLaChnLGUpe3ZhciB0PWcuX19kYXRhX187cmV0dXJuIEdoKGUpP3RbdHlwZW9mIGU9PSJzdHJpbmciPyJzdHJpbmciOiJoYXNoIl06dC5tYXB9dmFyIFFuPUtoLEhoPVFuO2Z1bmN0aW9uIFloKGcpe3ZhciBlPUhoKHRoaXMsZykuZGVsZXRlKGcpO3JldHVybiB0aGlzLnNpemUtPWU/MTowLGV9dmFyIFZoPVloLFhoPVFuO2Z1bmN0aW9uIFpoKGcpe3JldHVybiBYaCh0aGlzLGcpLmdldChnKX12YXIgSmg9WmgsUWg9UW47ZnVuY3Rpb24ga2goZyl7cmV0dXJuIFFoKHRoaXMsZykuaGFzKGcpfXZhciBxaD1raCxfaD1RbjtmdW5jdGlvbiB0ZChnLGUpe3ZhciB0PV9oKHRoaXMsZyksbj10LnNpemU7cmV0dXJuIHQuc2V0KGcsZSksdGhpcy5zaXplKz10LnNpemU9PW4/MDoxLHRoaXN9dmFyIGVkPXRkLHJkPVVoLG5kPVZoLGlkPUpoLHNkPXFoLG9kPWVkO2Z1bmN0aW9uIHNuKGcpe3ZhciBlPS0xLHQ9Zz09bnVsbD8wOmcubGVuZ3RoO2Zvcih0aGlzLmNsZWFyKCk7KytlPHQ7KXt2YXIgbj1nW2VdO3RoaXMuc2V0KG5bMF0sblsxXSl9fXNuLnByb3RvdHlwZS5jbGVhcj1yZCxzbi5wcm90b3R5cGUuZGVsZXRlPW5kLHNuLnByb3RvdHlwZS5nZXQ9aWQsc24ucHJvdG90eXBlLmhhcz1zZCxzbi5wcm90b3R5cGUuc2V0PW9kO3ZhciBhZD1zbixsZD1abix1ZD1faSxmZD1hZCxjZD0yMDA7ZnVuY3Rpb24gaGQoZyxlKXt2YXIgdD10aGlzLl9fZGF0YV9fO2lmKHQgaW5zdGFuY2VvZiBsZCl7dmFyIG49dC5fX2RhdGFfXztpZighdWR8fG4ubGVuZ3RoPGNkLTEpcmV0dXJuIG4ucHVzaChbZyxlXSksdGhpcy5zaXplPSsrdC5zaXplLHRoaXM7dD10aGlzLl9fZGF0YV9fPW5ldyBmZChuKX1yZXR1cm4gdC5zZXQoZyxlKSx0aGlzLnNpemU9dC5zaXplLHRoaXN9dmFyIGRkPWhkLGdkPVpuLHZkPXRjLHBkPXJjLG1kPWljLHlkPW9jLHhkPWRkO2Z1bmN0aW9uIG9uKGcpe3ZhciBlPXRoaXMuX19kYXRhX189bmV3IGdkKGcpO3RoaXMuc2l6ZT1lLnNpemV9b24ucHJvdG90eXBlLmNsZWFyPXZkLG9uLnByb3RvdHlwZS5kZWxldGU9cGQsb24ucHJvdG90eXBlLmdldD1tZCxvbi5wcm90b3R5cGUuaGFzPXlkLG9uLnByb3RvdHlwZS5zZXQ9eGQ7dmFyIE9kPW9uO2Z1bmN0aW9uIEVkKGcsZSl7Zm9yKHZhciB0PS0xLG49Zz09bnVsbD8wOmcubGVuZ3RoOysrdDxuJiZlKGdbdF0sdCxnKSE9PSExOyk7cmV0dXJuIGd9dmFyIE1kPUVkLFNkPSRyLFRkPWZ1bmN0aW9uKCl7dHJ5e3ZhciBnPVNkKE9iamVjdCwiZGVmaW5lUHJvcGVydHkiKTtyZXR1cm4gZyh7fSwiIix7fSksZ31jYXRjaHt9fSgpLFBkPVRkLEdvPVBkO2Z1bmN0aW9uIGJkKGcsZSx0KXtlPT0iX19wcm90b19fIiYmR28/R28oZyxlLHtjb25maWd1cmFibGU6ITAsZW51bWVyYWJsZTohMCx2YWx1ZTp0LHdyaXRhYmxlOiEwfSk6Z1tlXT10fXZhciBLbz1iZCxBZD1LbyxDZD1MbyxSZD1PYmplY3QucHJvdG90eXBlLElkPVJkLmhhc093blByb3BlcnR5O2Z1bmN0aW9uIExkKGcsZSx0KXt2YXIgbj1nW2VdOyghKElkLmNhbGwoZyxlKSYmQ2Qobix0KSl8fHQ9PT12b2lkIDAmJiEoZSBpbiBnKSkmJkFkKGcsZSx0KX12YXIgSG89TGQsRGQ9SG8sd2Q9S287ZnVuY3Rpb24gTmQoZyxlLHQsbil7dmFyIGk9IXQ7dHx8KHQ9e30pO2Zvcih2YXIgZj0tMSxoPWUubGVuZ3RoOysrZjxoOyl7dmFyIHU9ZVtmXSxhPW4/bih0W3VdLGdbdV0sdSx0LGcpOnZvaWQgMDthPT09dm9pZCAwJiYoYT1nW3VdKSxpP3dkKHQsdSxhKTpEZCh0LHUsYSl9cmV0dXJuIHR9dmFyIGtuPU5kO2Z1bmN0aW9uIEJkKGcsZSl7Zm9yKHZhciB0PS0xLG49QXJyYXkoZyk7Kyt0PGc7KW5bdF09ZSh0KTtyZXR1cm4gbn12YXIgV2Q9QmQ7ZnVuY3Rpb24gRmQoZyl7cmV0dXJuIGchPW51bGwmJnR5cGVvZiBnPT0ib2JqZWN0In12YXIgR3I9RmQsamQ9cm4sVWQ9R3IsemQ9IltvYmplY3QgQXJndW1lbnRzXSI7ZnVuY3Rpb24gJGQoZyl7cmV0dXJuIFVkKGcpJiZqZChnKT09emR9dmFyIEdkPSRkLFlvPUdkLEtkPUdyLFZvPU9iamVjdC5wcm90b3R5cGUsSGQ9Vm8uaGFzT3duUHJvcGVydHksWWQ9Vm8ucHJvcGVydHlJc0VudW1lcmFibGUsVmQ9WW8oZnVuY3Rpb24oKXtyZXR1cm4gYXJndW1lbnRzfSgpKT9ZbzpmdW5jdGlvbihnKXtyZXR1cm4gS2QoZykmJkhkLmNhbGwoZywiY2FsbGVlIikmJiFZZC5jYWxsKGcsImNhbGxlZSIpfSxYZD1WZCxaZD1BcnJheS5pc0FycmF5LHRzPVpkLHFuPXtleHBvcnRzOnt9fTtmdW5jdGlvbiBKZCgpe3JldHVybiExfXZhciBRZD1KZDtxbi5leHBvcnRzLGZ1bmN0aW9uKGcsZSl7dmFyIHQ9YXIsbj1RZCxpPWUmJiFlLm5vZGVUeXBlJiZlLGY9aSYmITAmJmcmJiFnLm5vZGVUeXBlJiZnLGg9ZiYmZi5leHBvcnRzPT09aSx1PWg/dC5CdWZmZXI6dm9pZCAwLGE9dT91LmlzQnVmZmVyOnZvaWQgMCxkPWF8fG47Zy5leHBvcnRzPWR9KHFuLHFuLmV4cG9ydHMpO3ZhciBYbz1xbi5leHBvcnRzLGtkPTkwMDcxOTkyNTQ3NDA5OTEscWQ9L14oPzowfFsxLTldXGQqKSQvO2Z1bmN0aW9uIF9kKGcsZSl7dmFyIHQ9dHlwZW9mIGc7cmV0dXJuIGU9ZT8/a2QsISFlJiYodD09Im51bWJlciJ8fHQhPSJzeW1ib2wiJiZxZC50ZXN0KGcpKSYmZz4tMSYmZyUxPT0wJiZnPGV9dmFyIHRnPV9kLGVnPTkwMDcxOTkyNTQ3NDA5OTE7ZnVuY3Rpb24gcmcoZyl7cmV0dXJuIHR5cGVvZiBnPT0ibnVtYmVyIiYmZz4tMSYmZyUxPT0wJiZnPD1lZ312YXIgWm89cmcsbmc9cm4saWc9Wm8sc2c9R3Isb2c9IltvYmplY3QgQXJndW1lbnRzXSIsYWc9IltvYmplY3QgQXJyYXldIixsZz0iW29iamVjdCBCb29sZWFuXSIsdWc9IltvYmplY3QgRGF0ZV0iLGZnPSJbb2JqZWN0IEVycm9yXSIsY2c9IltvYmplY3QgRnVuY3Rpb25dIixoZz0iW29iamVjdCBNYXBdIixkZz0iW29iamVjdCBOdW1iZXJdIixnZz0iW29iamVjdCBPYmplY3RdIix2Zz0iW29iamVjdCBSZWdFeHBdIixwZz0iW29iamVjdCBTZXRdIixtZz0iW29iamVjdCBTdHJpbmddIix5Zz0iW29iamVjdCBXZWFrTWFwXSIseGc9IltvYmplY3QgQXJyYXlCdWZmZXJdIixPZz0iW29iamVjdCBEYXRhVmlld10iLEVnPSJbb2JqZWN0IEZsb2F0MzJBcnJheV0iLE1nPSJbb2JqZWN0IEZsb2F0NjRBcnJheV0iLFNnPSJbb2JqZWN0IEludDhBcnJheV0iLFRnPSJbb2JqZWN0IEludDE2QXJyYXldIixQZz0iW29iamVjdCBJbnQzMkFycmF5XSIsYmc9IltvYmplY3QgVWludDhBcnJheV0iLEFnPSJbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XSIsQ2c9IltvYmplY3QgVWludDE2QXJyYXldIixSZz0iW29iamVjdCBVaW50MzJBcnJheV0iLHZlPXt9O3ZlW0VnXT12ZVtNZ109dmVbU2ddPXZlW1RnXT12ZVtQZ109dmVbYmddPXZlW0FnXT12ZVtDZ109dmVbUmddPSEwLHZlW29nXT12ZVthZ109dmVbeGddPXZlW2xnXT12ZVtPZ109dmVbdWddPXZlW2ZnXT12ZVtjZ109dmVbaGddPXZlW2RnXT12ZVtnZ109dmVbdmddPXZlW3BnXT12ZVttZ109dmVbeWddPSExO2Z1bmN0aW9uIElnKGcpe3JldHVybiBzZyhnKSYmaWcoZy5sZW5ndGgpJiYhIXZlW25nKGcpXX12YXIgTGc9SWc7ZnVuY3Rpb24gRGcoZyl7cmV0dXJuIGZ1bmN0aW9uKGUpe3JldHVybiBnKGUpfX12YXIgZXM9RGcsX249e2V4cG9ydHM6e319O19uLmV4cG9ydHMsZnVuY3Rpb24oZyxlKXt2YXIgdD1EbyxuPWUmJiFlLm5vZGVUeXBlJiZlLGk9biYmITAmJmcmJiFnLm5vZGVUeXBlJiZnLGY9aSYmaS5leHBvcnRzPT09bixoPWYmJnQucHJvY2Vzcyx1PWZ1bmN0aW9uKCl7dHJ5e3ZhciBhPWkmJmkucmVxdWlyZSYmaS5yZXF1aXJlKCJ1dGlsIikudHlwZXM7cmV0dXJuIGF8fGgmJmguYmluZGluZyYmaC5iaW5kaW5nKCJ1dGlsIil9Y2F0Y2h7fX0oKTtnLmV4cG9ydHM9dX0oX24sX24uZXhwb3J0cyk7dmFyIHJzPV9uLmV4cG9ydHMsd2c9TGcsTmc9ZXMsSm89cnMsUW89Sm8mJkpvLmlzVHlwZWRBcnJheSxCZz1Rbz9OZyhRbyk6d2csV2c9QmcsRmc9V2Qsamc9WGQsVWc9dHMsemc9WG8sJGc9dGcsR2c9V2csS2c9T2JqZWN0LnByb3RvdHlwZSxIZz1LZy5oYXNPd25Qcm9wZXJ0eTtmdW5jdGlvbiBZZyhnLGUpe3ZhciB0PVVnKGcpLG49IXQmJmpnKGcpLGk9IXQmJiFuJiZ6ZyhnKSxmPSF0JiYhbiYmIWkmJkdnKGcpLGg9dHx8bnx8aXx8Zix1PWg/RmcoZy5sZW5ndGgsU3RyaW5nKTpbXSxhPXUubGVuZ3RoO2Zvcih2YXIgZCBpbiBnKShlfHxIZy5jYWxsKGcsZCkpJiYhKGgmJihkPT0ibGVuZ3RoInx8aSYmKGQ9PSJvZmZzZXQifHxkPT0icGFyZW50Iil8fGYmJihkPT0iYnVmZmVyInx8ZD09ImJ5dGVMZW5ndGgifHxkPT0iYnl0ZU9mZnNldCIpfHwkZyhkLGEpKSkmJnUucHVzaChkKTtyZXR1cm4gdX12YXIga289WWcsVmc9T2JqZWN0LnByb3RvdHlwZTtmdW5jdGlvbiBYZyhnKXt2YXIgZT1nJiZnLmNvbnN0cnVjdG9yLHQ9dHlwZW9mIGU9PSJmdW5jdGlvbiImJmUucHJvdG90eXBlfHxWZztyZXR1cm4gZz09PXR9dmFyIG5zPVhnO2Z1bmN0aW9uIFpnKGcsZSl7cmV0dXJuIGZ1bmN0aW9uKHQpe3JldHVybiBnKGUodCkpfX12YXIgcW89WmcsSmc9cW8sUWc9SmcoT2JqZWN0LmtleXMsT2JqZWN0KSxrZz1RZyxxZz1ucyxfZz1rZyx0MD1PYmplY3QucHJvdG90eXBlLGUwPXQwLmhhc093blByb3BlcnR5O2Z1bmN0aW9uIHIwKGcpe2lmKCFxZyhnKSlyZXR1cm4gX2coZyk7dmFyIGU9W107Zm9yKHZhciB0IGluIE9iamVjdChnKSllMC5jYWxsKGcsdCkmJnQhPSJjb25zdHJ1Y3RvciImJmUucHVzaCh0KTtyZXR1cm4gZX12YXIgbjA9cjAsaTA9Rm8sczA9Wm87ZnVuY3Rpb24gbzAoZyl7cmV0dXJuIGchPW51bGwmJnMwKGcubGVuZ3RoKSYmIWkwKGcpfXZhciBfbz1vMCxhMD1rbyxsMD1uMCx1MD1fbztmdW5jdGlvbiBmMChnKXtyZXR1cm4gdTAoZyk/YTAoZyk6bDAoZyl9dmFyIGlzPWYwLGMwPWtuLGgwPWlzO2Z1bmN0aW9uIGQwKGcsZSl7cmV0dXJuIGcmJmMwKGUsaDAoZSksZyl9dmFyIGcwPWQwO2Z1bmN0aW9uIHYwKGcpe3ZhciBlPVtdO2lmKGchPW51bGwpZm9yKHZhciB0IGluIE9iamVjdChnKSllLnB1c2godCk7cmV0dXJuIGV9dmFyIHAwPXYwLG0wPUNyLHkwPW5zLHgwPXAwLE8wPU9iamVjdC5wcm90b3R5cGUsRTA9TzAuaGFzT3duUHJvcGVydHk7ZnVuY3Rpb24gTTAoZyl7aWYoIW0wKGcpKXJldHVybiB4MChnKTt2YXIgZT15MChnKSx0PVtdO2Zvcih2YXIgbiBpbiBnKW49PSJjb25zdHJ1Y3RvciImJihlfHwhRTAuY2FsbChnLG4pKXx8dC5wdXNoKG4pO3JldHVybiB0fXZhciBTMD1NMCxUMD1rbyxQMD1TMCxiMD1fbztmdW5jdGlvbiBBMChnKXtyZXR1cm4gYjAoZyk/VDAoZywhMCk6UDAoZyl9dmFyIHNzPUEwLEMwPWtuLFIwPXNzO2Z1bmN0aW9uIEkwKGcsZSl7cmV0dXJuIGcmJkMwKGUsUjAoZSksZyl9dmFyIEwwPUkwLHRpPXtleHBvcnRzOnt9fTt0aS5leHBvcnRzLGZ1bmN0aW9uKGcsZSl7dmFyIHQ9YXIsbj1lJiYhZS5ub2RlVHlwZSYmZSxpPW4mJiEwJiZnJiYhZy5ub2RlVHlwZSYmZyxmPWkmJmkuZXhwb3J0cz09PW4saD1mP3QuQnVmZmVyOnZvaWQgMCx1PWg/aC5hbGxvY1Vuc2FmZTp2b2lkIDA7ZnVuY3Rpb24gYShkLEUpe2lmKEUpcmV0dXJuIGQuc2xpY2UoKTt2YXIgcD1kLmxlbmd0aCxPPXU/dShwKTpuZXcgZC5jb25zdHJ1Y3RvcihwKTtyZXR1cm4gZC5jb3B5KE8pLE99Zy5leHBvcnRzPWF9KHRpLHRpLmV4cG9ydHMpO3ZhciBEMD10aS5leHBvcnRzO2Z1bmN0aW9uIHcwKGcsZSl7dmFyIHQ9LTEsbj1nLmxlbmd0aDtmb3IoZXx8KGU9QXJyYXkobikpOysrdDxuOyllW3RdPWdbdF07cmV0dXJuIGV9dmFyIE4wPXcwO2Z1bmN0aW9uIEIwKGcsZSl7Zm9yKHZhciB0PS0xLG49Zz09bnVsbD8wOmcubGVuZ3RoLGk9MCxmPVtdOysrdDxuOyl7dmFyIGg9Z1t0XTtlKGgsdCxnKSYmKGZbaSsrXT1oKX1yZXR1cm4gZn12YXIgVzA9QjA7ZnVuY3Rpb24gRjAoKXtyZXR1cm5bXX12YXIgdGE9RjAsajA9VzAsVTA9dGEsejA9T2JqZWN0LnByb3RvdHlwZSwkMD16MC5wcm9wZXJ0eUlzRW51bWVyYWJsZSxlYT1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzLEcwPWVhP2Z1bmN0aW9uKGcpe3JldHVybiBnPT1udWxsP1tdOihnPU9iamVjdChnKSxqMChlYShnKSxmdW5jdGlvbihlKXtyZXR1cm4gJDAuY2FsbChnLGUpfSkpfTpVMCxvcz1HMCxLMD1rbixIMD1vcztmdW5jdGlvbiBZMChnLGUpe3JldHVybiBLMChnLEgwKGcpLGUpfXZhciBWMD1ZMDtmdW5jdGlvbiBYMChnLGUpe2Zvcih2YXIgdD0tMSxuPWUubGVuZ3RoLGk9Zy5sZW5ndGg7Kyt0PG47KWdbaSt0XT1lW3RdO3JldHVybiBnfXZhciByYT1YMCxaMD1xbyxKMD1aMChPYmplY3QuZ2V0UHJvdG90eXBlT2YsT2JqZWN0KSxuYT1KMCxRMD1yYSxrMD1uYSxxMD1vcyxfMD10YSx0dj1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzLGV2PXR2P2Z1bmN0aW9uKGcpe2Zvcih2YXIgZT1bXTtnOylRMChlLHEwKGcpKSxnPWswKGcpO3JldHVybiBlfTpfMCxpYT1ldixydj1rbixudj1pYTtmdW5jdGlvbiBpdihnLGUpe3JldHVybiBydihnLG52KGcpLGUpfXZhciBzdj1pdixvdj1yYSxhdj10cztmdW5jdGlvbiBsdihnLGUsdCl7dmFyIG49ZShnKTtyZXR1cm4gYXYoZyk/bjpvdihuLHQoZykpfXZhciBzYT1sdix1dj1zYSxmdj1vcyxjdj1pcztmdW5jdGlvbiBodihnKXtyZXR1cm4gdXYoZyxjdixmdil9dmFyIGR2PWh2LGd2PXNhLHZ2PWlhLHB2PXNzO2Z1bmN0aW9uIG12KGcpe3JldHVybiBndihnLHB2LHZ2KX12YXIgeXY9bXYseHY9JHIsT3Y9YXIsRXY9eHYoT3YsIkRhdGFWaWV3IiksTXY9RXYsU3Y9JHIsVHY9YXIsUHY9U3YoVHYsIlByb21pc2UiKSxidj1QdixBdj0kcixDdj1hcixSdj1BdihDdiwiU2V0IiksSXY9UnYsTHY9JHIsRHY9YXIsd3Y9THYoRHYsIldlYWtNYXAiKSxOdj13dixhcz1Ndixscz1faSx1cz1idixmcz1Jdixjcz1OdixvYT1ybixhbj1VbyxhYT0iW29iamVjdCBNYXBdIixCdj0iW29iamVjdCBPYmplY3RdIixsYT0iW29iamVjdCBQcm9taXNlXSIsdWE9IltvYmplY3QgU2V0XSIsZmE9IltvYmplY3QgV2Vha01hcF0iLGNhPSJbb2JqZWN0IERhdGFWaWV3XSIsV3Y9YW4oYXMpLEZ2PWFuKGxzKSxqdj1hbih1cyksVXY9YW4oZnMpLHp2PWFuKGNzKSxLcj1vYTsoYXMmJktyKG5ldyBhcyhuZXcgQXJyYXlCdWZmZXIoMSkpKSE9Y2F8fGxzJiZLcihuZXcgbHMpIT1hYXx8dXMmJktyKHVzLnJlc29sdmUoKSkhPWxhfHxmcyYmS3IobmV3IGZzKSE9dWF8fGNzJiZLcihuZXcgY3MpIT1mYSkmJihLcj1mdW5jdGlvbihnKXt2YXIgZT1vYShnKSx0PWU9PUJ2P2cuY29uc3RydWN0b3I6dm9pZCAwLG49dD9hbih0KToiIjtpZihuKXN3aXRjaChuKXtjYXNlIFd2OnJldHVybiBjYTtjYXNlIEZ2OnJldHVybiBhYTtjYXNlIGp2OnJldHVybiBsYTtjYXNlIFV2OnJldHVybiB1YTtjYXNlIHp2OnJldHVybiBmYX1yZXR1cm4gZX0pO3ZhciBocz1Lciwkdj1PYmplY3QucHJvdG90eXBlLEd2PSR2Lmhhc093blByb3BlcnR5O2Z1bmN0aW9uIEt2KGcpe3ZhciBlPWcubGVuZ3RoLHQ9bmV3IGcuY29uc3RydWN0b3IoZSk7cmV0dXJuIGUmJnR5cGVvZiBnWzBdPT0ic3RyaW5nIiYmR3YuY2FsbChnLCJpbmRleCIpJiYodC5pbmRleD1nLmluZGV4LHQuaW5wdXQ9Zy5pbnB1dCksdH12YXIgSHY9S3YsWXY9YXIsVnY9WXYuVWludDhBcnJheSxYdj1WdixoYT1YdjtmdW5jdGlvbiBadihnKXt2YXIgZT1uZXcgZy5jb25zdHJ1Y3RvcihnLmJ5dGVMZW5ndGgpO3JldHVybiBuZXcgaGEoZSkuc2V0KG5ldyBoYShnKSksZX12YXIgZHM9WnYsSnY9ZHM7ZnVuY3Rpb24gUXYoZyxlKXt2YXIgdD1lP0p2KGcuYnVmZmVyKTpnLmJ1ZmZlcjtyZXR1cm4gbmV3IGcuY29uc3RydWN0b3IodCxnLmJ5dGVPZmZzZXQsZy5ieXRlTGVuZ3RoKX12YXIga3Y9UXYscXY9L1x3KiQvO2Z1bmN0aW9uIF92KGcpe3ZhciBlPW5ldyBnLmNvbnN0cnVjdG9yKGcuc291cmNlLHF2LmV4ZWMoZykpO3JldHVybiBlLmxhc3RJbmRleD1nLmxhc3RJbmRleCxlfXZhciB0cD1fdixkYT1raSxnYT1kYT9kYS5wcm90b3R5cGU6dm9pZCAwLHZhPWdhP2dhLnZhbHVlT2Y6dm9pZCAwO2Z1bmN0aW9uIGVwKGcpe3JldHVybiB2YT9PYmplY3QodmEuY2FsbChnKSk6e319dmFyIHJwPWVwLG5wPWRzO2Z1bmN0aW9uIGlwKGcsZSl7dmFyIHQ9ZT9ucChnLmJ1ZmZlcik6Zy5idWZmZXI7cmV0dXJuIG5ldyBnLmNvbnN0cnVjdG9yKHQsZy5ieXRlT2Zmc2V0LGcubGVuZ3RoKX12YXIgc3A9aXAsb3A9ZHMsYXA9a3YsbHA9dHAsdXA9cnAsZnA9c3AsY3A9IltvYmplY3QgQm9vbGVhbl0iLGhwPSJbb2JqZWN0IERhdGVdIixkcD0iW29iamVjdCBNYXBdIixncD0iW29iamVjdCBOdW1iZXJdIix2cD0iW29iamVjdCBSZWdFeHBdIixwcD0iW29iamVjdCBTZXRdIixtcD0iW29iamVjdCBTdHJpbmddIix5cD0iW29iamVjdCBTeW1ib2xdIix4cD0iW29iamVjdCBBcnJheUJ1ZmZlcl0iLE9wPSJbb2JqZWN0IERhdGFWaWV3XSIsRXA9IltvYmplY3QgRmxvYXQzMkFycmF5XSIsTXA9IltvYmplY3QgRmxvYXQ2NEFycmF5XSIsU3A9IltvYmplY3QgSW50OEFycmF5XSIsVHA9IltvYmplY3QgSW50MTZBcnJheV0iLFBwPSJbb2JqZWN0IEludDMyQXJyYXldIixicD0iW29iamVjdCBVaW50OEFycmF5XSIsQXA9IltvYmplY3QgVWludDhDbGFtcGVkQXJyYXldIixDcD0iW29iamVjdCBVaW50MTZBcnJheV0iLFJwPSJbb2JqZWN0IFVpbnQzMkFycmF5XSI7ZnVuY3Rpb24gSXAoZyxlLHQpe3ZhciBuPWcuY29uc3RydWN0b3I7c3dpdGNoKGUpe2Nhc2UgeHA6cmV0dXJuIG9wKGcpO2Nhc2UgY3A6Y2FzZSBocDpyZXR1cm4gbmV3IG4oK2cpO2Nhc2UgT3A6cmV0dXJuIGFwKGcsdCk7Y2FzZSBFcDpjYXNlIE1wOmNhc2UgU3A6Y2FzZSBUcDpjYXNlIFBwOmNhc2UgYnA6Y2FzZSBBcDpjYXNlIENwOmNhc2UgUnA6cmV0dXJuIGZwKGcsdCk7Y2FzZSBkcDpyZXR1cm4gbmV3IG47Y2FzZSBncDpjYXNlIG1wOnJldHVybiBuZXcgbihnKTtjYXNlIHZwOnJldHVybiBscChnKTtjYXNlIHBwOnJldHVybiBuZXcgbjtjYXNlIHlwOnJldHVybiB1cChnKX19dmFyIExwPUlwLERwPUNyLHBhPU9iamVjdC5jcmVhdGUsd3A9ZnVuY3Rpb24oKXtmdW5jdGlvbiBnKCl7fXJldHVybiBmdW5jdGlvbihlKXtpZighRHAoZSkpcmV0dXJue307aWYocGEpcmV0dXJuIHBhKGUpO2cucHJvdG90eXBlPWU7dmFyIHQ9bmV3IGc7cmV0dXJuIGcucHJvdG90eXBlPXZvaWQgMCx0fX0oKSxOcD13cCxCcD1OcCxXcD1uYSxGcD1ucztmdW5jdGlvbiBqcChnKXtyZXR1cm4gdHlwZW9mIGcuY29uc3RydWN0b3I9PSJmdW5jdGlvbiImJiFGcChnKT9CcChXcChnKSk6e319dmFyIFVwPWpwLHpwPWhzLCRwPUdyLEdwPSJbb2JqZWN0IE1hcF0iO2Z1bmN0aW9uIEtwKGcpe3JldHVybiAkcChnKSYmenAoZyk9PUdwfXZhciBIcD1LcCxZcD1IcCxWcD1lcyxtYT1ycyx5YT1tYSYmbWEuaXNNYXAsWHA9eWE/VnAoeWEpOllwLFpwPVhwLEpwPWhzLFFwPUdyLGtwPSJbb2JqZWN0IFNldF0iO2Z1bmN0aW9uIHFwKGcpe3JldHVybiBRcChnKSYmSnAoZyk9PWtwfXZhciBfcD1xcCx0MT1fcCxlMT1lcyx4YT1ycyxPYT14YSYmeGEuaXNTZXQscjE9T2E/ZTEoT2EpOnQxLG4xPXIxLGkxPU9kLHMxPU1kLG8xPUhvLGExPWcwLGwxPUwwLHUxPUQwLGYxPU4wLGMxPVYwLGgxPXN2LGQxPWR2LGcxPXl2LHYxPWhzLHAxPUh2LG0xPUxwLHkxPVVwLHgxPXRzLE8xPVhvLEUxPVpwLE0xPUNyLFMxPW4xLFQxPWlzLFAxPXNzLGIxPTEsQTE9MixDMT00LEVhPSJbb2JqZWN0IEFyZ3VtZW50c10iLFIxPSJbb2JqZWN0IEFycmF5XSIsSTE9IltvYmplY3QgQm9vbGVhbl0iLEwxPSJbb2JqZWN0IERhdGVdIixEMT0iW29iamVjdCBFcnJvcl0iLE1hPSJbb2JqZWN0IEZ1bmN0aW9uXSIsdzE9IltvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dIixOMT0iW29iamVjdCBNYXBdIixCMT0iW29iamVjdCBOdW1iZXJdIixTYT0iW29iamVjdCBPYmplY3RdIixXMT0iW29iamVjdCBSZWdFeHBdIixGMT0iW29iamVjdCBTZXRdIixqMT0iW29iamVjdCBTdHJpbmddIixVMT0iW29iamVjdCBTeW1ib2xdIix6MT0iW29iamVjdCBXZWFrTWFwXSIsJDE9IltvYmplY3QgQXJyYXlCdWZmZXJdIixHMT0iW29iamVjdCBEYXRhVmlld10iLEsxPSJbb2JqZWN0IEZsb2F0MzJBcnJheV0iLEgxPSJbb2JqZWN0IEZsb2F0NjRBcnJheV0iLFkxPSJbb2JqZWN0IEludDhBcnJheV0iLFYxPSJbb2JqZWN0IEludDE2QXJyYXldIixYMT0iW29iamVjdCBJbnQzMkFycmF5XSIsWjE9IltvYmplY3QgVWludDhBcnJheV0iLEoxPSJbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XSIsUTE9IltvYmplY3QgVWludDE2QXJyYXldIixrMT0iW29iamVjdCBVaW50MzJBcnJheV0iLGRlPXt9O2RlW0VhXT1kZVtSMV09ZGVbJDFdPWRlW0cxXT1kZVtJMV09ZGVbTDFdPWRlW0sxXT1kZVtIMV09ZGVbWTFdPWRlW1YxXT1kZVtYMV09ZGVbTjFdPWRlW0IxXT1kZVtTYV09ZGVbVzFdPWRlW0YxXT1kZVtqMV09ZGVbVTFdPWRlW1oxXT1kZVtKMV09ZGVbUTFdPWRlW2sxXT0hMCxkZVtEMV09ZGVbTWFdPWRlW3oxXT0hMTtmdW5jdGlvbiBlaShnLGUsdCxuLGksZil7dmFyIGgsdT1lJmIxLGE9ZSZBMSxkPWUmQzE7aWYodCYmKGg9aT90KGcsbixpLGYpOnQoZykpLGghPT12b2lkIDApcmV0dXJuIGg7aWYoIU0xKGcpKXJldHVybiBnO3ZhciBFPXgxKGcpO2lmKEUpe2lmKGg9cDEoZyksIXUpcmV0dXJuIGYxKGcsaCl9ZWxzZXt2YXIgcD12MShnKSxPPXA9PU1hfHxwPT13MTtpZihPMShnKSlyZXR1cm4gdTEoZyx1KTtpZihwPT1TYXx8cD09RWF8fE8mJiFpKXtpZihoPWF8fE8/e306eTEoZyksIXUpcmV0dXJuIGE/aDEoZyxsMShoLGcpKTpjMShnLGExKGgsZykpfWVsc2V7aWYoIWRlW3BdKXJldHVybiBpP2c6e307aD1tMShnLHAsdSl9fWZ8fChmPW5ldyBpMSk7dmFyIG09Zi5nZXQoZyk7aWYobSlyZXR1cm4gbTtmLnNldChnLGgpLFMxKGcpP2cuZm9yRWFjaChmdW5jdGlvbih5KXtoLmFkZChlaSh5LGUsdCx5LGcsZikpfSk6RTEoZykmJmcuZm9yRWFjaChmdW5jdGlvbih5LFMpe2guc2V0KFMsZWkoeSxlLHQsUyxnLGYpKX0pO3ZhciBiPWQ/YT9nMTpkMTphP1AxOlQxLE09RT92b2lkIDA6YihnKTtyZXR1cm4gczEoTXx8ZyxmdW5jdGlvbih5LFMpe00mJihTPXkseT1nW1NdKSxvMShoLFMsZWkoeSxlLHQsUyxnLGYpKX0pLGh9dmFyIHExPWVpLF8xPXExLHRtPTEsZW09NDtmdW5jdGlvbiBybShnKXtyZXR1cm4gXzEoZyx0bXxlbSl9dmFyIG5tPXJtLGRyPVZuKG5tKSxUYTsoZnVuY3Rpb24oZyl7Z1tnLnBlZGRpbmc9MF09InBlZGRpbmciLGdbZy5tb3VudGVkPTFdPSJtb3VudGVkIixnW2cudXBkYXRlPTJdPSJ1cGRhdGUiLGdbZy51bm1vdW50ZWQ9M109InVubW91bnRlZCJ9KShUYXx8KFRhPXt9KSk7dmFyIFJlOyhmdW5jdGlvbihnKXtnW2cuTm9ybWFsPTBdPSJOb3JtYWwiLGdbZy5TdHJva2U9MV09IlN0cm9rZSIsZ1tnLkRvdHRlZD0yXT0iRG90dGVkIixnW2cuTG9uZ0RvdHRlZD0zXT0iTG9uZ0RvdHRlZCJ9KShSZXx8KFJlPXt9KSk7dmFyIFBhOyhmdW5jdGlvbihnKXtnLlRyaWFuZ2xlPSJ0cmlhbmdsZSIsZy5SaG9tYnVzPSJyaG9tYnVzIixnLlBlbnRhZ3JhbT0icGVudGFncmFtIixnLlNwZWVjaEJhbGxvb249InNwZWVjaEJhbGxvb24iLGcuU3Rhcj0ic3RhciIsZy5Qb2x5Z29uPSJwb2x5Z29uIn0pKFBhfHwoUGE9e30pKTt2YXIgb2U7KGZ1bmN0aW9uKGcpe2cuTm9uZT0iTm9uZSIsZy5TaG93RmxvYXRCYXI9IlNob3dGbG9hdEJhciIsZy5aSW5kZXhGbG9hdEJhcj0iWkluZGV4RmxvYXRCYXIiLGcuRGVsZXRlTm9kZT0iRGVsZXRlTm9kZSIsZy5Db3B5Tm9kZT0iQ29weU5vZGUiLGcuWkluZGV4QWN0aXZlPSJaSW5kZXhBY3RpdmUiLGcuWkluZGV4Tm9kZT0iWkluZGV4Tm9kZSIsZy5Sb3RhdGVOb2RlPSJSb3RhdGVOb2RlIixnLlNldENvbG9yTm9kZT0iU2V0Q29sb3JOb2RlIixnLlRyYW5zbGF0ZU5vZGU9IlRyYW5zbGF0ZU5vZGUiLGcuU2NhbGVOb2RlPSJTY2FsZU5vZGUiLGcuT3JpZ2luYWxFdmVudD0iT3JpZ2luYWxFdmVudCIsZy5DcmVhdGVTY2VuZT0iQ3JlYXRlU2NlbmUiLGcuQWN0aXZlQ3Vyc29yPSJBY3RpdmVDdXJzb3IiLGcuTW92ZUN1cnNvcj0iTW92ZUN1cnNvciIsZy5Db21tYW5kRWRpdG9yPSJDb21tYW5kRWRpdG9yIixnLlNldEVkaXRvckRhdGE9IlNldEVkaXRvckRhdGEifSkob2V8fChvZT17fSkpO3ZhciBiYTsoZnVuY3Rpb24oZyl7Zy5EaXNwbGF5U3RhdGU9IkRpc3BsYXlTdGF0ZSIsZy5GbG9hdEJhcj0iRmxvYXRCYXIiLGcuQ2FudmFzU2VsZWN0b3I9IkNhbnZhc1NlbGVjdG9yIixnLk1haW5FbmdpbmU9Ik1haW5FbmdpbmUiLGcuRGlzcGxheUNvbnRhaW5lcj0iRGlzcGxheUNvbnRhaW5lciIsZy5DdXJzb3I9IkN1cnNvciIsZy5UZXh0RWRpdG9yPSJUZXh0RWRpdG9yIixnLkJpbmRNYWluVmlldz0iQmluZE1haW5WaWV3IixnLk1vdW50TWFpblZpZXc9Ik1vdW50TWFpblZpZXciLGcuTW91bnRBcHBWaWV3PSJNb3VudEFwcFZpZXcifSkoYmF8fChiYT17fSkpO3ZhciBBYTsoZnVuY3Rpb24oZyl7Z1tnLk1haW5WaWV3PTBdPSJNYWluVmlldyIsZ1tnLlBsdWdpbj0xXT0iUGx1Z2luIixnW2cuQm90aD0yXT0iQm90aCJ9KShBYXx8KEFhPXt9KSk7dmFyIEx0OyhmdW5jdGlvbihnKXtnW2cuUGVuY2lsPTFdPSJQZW5jaWwiLGdbZy5FcmFzZXI9Ml09IkVyYXNlciIsZ1tnLlNlbGVjdG9yPTNdPSJTZWxlY3RvciIsZ1tnLkNsaWNrZXI9NF09IkNsaWNrZXIiLGdbZy5BcnJvdz01XT0iQXJyb3ciLGdbZy5IYW5kPTZdPSJIYW5kIixnW2cuTGFzZXJQZW49N109Ikxhc2VyUGVuIixnW2cuVGV4dD04XT0iVGV4dCIsZ1tnLlN0cmFpZ2h0PTldPSJTdHJhaWdodCIsZ1tnLlJlY3RhbmdsZT0xMF09IlJlY3RhbmdsZSIsZ1tnLkVsbGlwc2U9MTFdPSJFbGxpcHNlIixnW2cuU3Rhcj0xMl09IlN0YXIiLGdbZy5UcmlhbmdsZT0xM109IlRyaWFuZ2xlIixnW2cuUmhvbWJ1cz0xNF09IlJob21idXMiLGdbZy5Qb2x5Z29uPTE1XT0iUG9seWdvbiIsZ1tnLlNwZWVjaEJhbGxvb249MTZdPSJTcGVlY2hCYWxsb29uIn0pKEx0fHwoTHQ9e30pKTt2YXIgenQ7KGZ1bmN0aW9uKGcpe2dbZy5Mb2NhbD0xXT0iTG9jYWwiLGdbZy5TZXJ2aWNlPTJdPSJTZXJ2aWNlIixnW2cuV29ya2VyPTNdPSJXb3JrZXIifSkoenR8fCh6dD17fSkpO3ZhciBjZTsoZnVuY3Rpb24oZyl7Z1tnLlBlbmRpbmc9MF09IlBlbmRpbmciLGdbZy5TdGFydD0xXT0iU3RhcnQiLGdbZy5Eb2luZz0yXT0iRG9pbmciLGdbZy5Eb25lPTNdPSJEb25lIixnW2cuRnJlZXplPTRdPSJGcmVlemUiLGdbZy5VbndyaXRhYmxlPTVdPSJVbndyaXRhYmxlIn0pKGNlfHwoY2U9e30pKTt2YXIgVHQ7KGZ1bmN0aW9uKGcpe2dbZy5Jbml0PTBdPSJJbml0IixnW2cuVXBkYXRlQ2FtZXJhPTFdPSJVcGRhdGVDYW1lcmEiLGdbZy5VcGRhdGVUb29scz0yXT0iVXBkYXRlVG9vbHMiLGdbZy5DcmVhdGVXb3JrPTNdPSJDcmVhdGVXb3JrIixnW2cuRHJhd1dvcms9NF09IkRyYXdXb3JrIixnW2cuRnVsbFdvcms9NV09IkZ1bGxXb3JrIixnW2cuVXBkYXRlTm9kZT02XT0iVXBkYXRlTm9kZSIsZ1tnLlJlbW92ZU5vZGU9N109IlJlbW92ZU5vZGUiLGdbZy5DbGVhcj04XT0iQ2xlYXIiLGdbZy5TZWxlY3Q9OV09IlNlbGVjdCIsZ1tnLkRlc3Ryb3k9MTBdPSJEZXN0cm95IixnW2cuTm9uZT0xMV09Ik5vbmUiLGdbZy5TbmFwc2hvdD0xMl09IlNuYXBzaG90IixnW2cuQm91bmRpbmdCb3g9MTNdPSJCb3VuZGluZ0JveCIsZ1tnLkN1cnNvcj0xNF09IkN1cnNvciIsZ1tnLlRleHRVcGRhdGU9MTVdPSJUZXh0VXBkYXRlIixnW2cuR2V0VGV4dEFjdGl2ZT0xNl09IkdldFRleHRBY3RpdmUiLGdbZy5UYXNrc1F1ZXVlPTE3XT0iVGFza3NRdWV1ZSJ9KShUdHx8KFR0PXt9KSk7dmFyIENhOyhmdW5jdGlvbihnKXtnLldlYmdsMj0id2ViZ2wyIixnLldlYmdsPSJ3ZWJnbCIsZy5DYW52YXMyZD0iMmQifSkoQ2F8fChDYT17fSkpO3ZhciBCdDsoZnVuY3Rpb24oZyl7Z1tnLkZsb2F0PTFdPSJGbG9hdCIsZ1tnLkJnPTJdPSJCZyIsZ1tnLlNlbGVjdG9yPTNdPSJTZWxlY3RvciIsZ1tnLk5vbmU9NF09Ik5vbmUifSkoQnR8fChCdD17fSkpO3ZhciBSYTsoZnVuY3Rpb24oZyl7Z1tnLkN1cnNvcj0xXT0iQ3Vyc29yIixnW2cuVGV4dENyZWF0ZT0yXT0iVGV4dENyZWF0ZSJ9KShSYXx8KFJhPXt9KSk7dmFyIElhOyhmdW5jdGlvbihnKXtnW2cuVG9wPTFdPSJUb3AiLGdbZy5Cb3R0b209Ml09IkJvdHRvbSJ9KShJYXx8KElhPXt9KSk7dmFyICRlOyhmdW5jdGlvbihnKXtnW2cubm9uZT0xXT0ibm9uZSIsZ1tnLmFsbD0yXT0iYWxsIixnW2cuYm90aD0zXT0iYm90aCJ9KSgkZXx8KCRlPXt9KSk7Y2xhc3MgUnJ7Y29uc3RydWN0b3IoKXtPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywibG9jYWxXb3JrIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInNlcnZpY2VXb3JrIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSl9cmVnaXN0ZXJGb3JXb3JrZXIoZSx0KXtyZXR1cm4gdGhpcy5sb2NhbFdvcms9ZSx0aGlzLnNlcnZpY2VXb3JrPXQsdGhpc319Y29uc3QgaW09e2xpbmVhcjpnPT5nLGVhc2VJblF1YWQ6Zz0+ZypnLGVhc2VPdXRRdWFkOmc9PmcqKDItZyksZWFzZUluT3V0UXVhZDpnPT5nPC41PzIqZypnOi0xKyg0LTIqZykqZyxlYXNlSW5DdWJpYzpnPT5nKmcqZyxlYXNlT3V0Q3ViaWM6Zz0+LS1nKmcqZysxLGVhc2VJbk91dEN1YmljOmc9Pmc8LjU/NCpnKmcqZzooZy0xKSooMipnLTIpKigyKmctMikrMSxlYXNlSW5RdWFydDpnPT5nKmcqZypnLGVhc2VPdXRRdWFydDpnPT4xLSAtLWcqZypnKmcsZWFzZUluT3V0UXVhcnQ6Zz0+ZzwuNT84KmcqZypnKmc6MS04Ki0tZypnKmcqZyxlYXNlSW5RdWludDpnPT5nKmcqZypnKmcsZWFzZU91dFF1aW50Omc9PjErLS1nKmcqZypnKmcsZWFzZUluT3V0UXVpbnQ6Zz0+ZzwuNT8xNipnKmcqZypnKmc6MSsxNiotLWcqZypnKmcqZyxlYXNlSW5TaW5lOmc9PjEtTWF0aC5jb3MoZypNYXRoLlBJLzIpLGVhc2VPdXRTaW5lOmc9Pk1hdGguc2luKGcqTWF0aC5QSS8yKSxlYXNlSW5PdXRTaW5lOmc9Pi0oTWF0aC5jb3MoTWF0aC5QSSpnKS0xKS8yLGVhc2VJbkV4cG86Zz0+Zzw9MD8wOk1hdGgucG93KDIsMTAqZy0xMCksZWFzZU91dEV4cG86Zz0+Zz49MT8xOjEtTWF0aC5wb3coMiwtMTAqZyksZWFzZUluT3V0RXhwbzpnPT5nPD0wPzA6Zz49MT8xOmc8LjU/TWF0aC5wb3coMiwyMCpnLTEwKS8yOigyLU1hdGgucG93KDIsLTIwKmcrMTApKS8yfTtjbGFzcyBFdHtjb25zdHJ1Y3RvcihlPTAsdD0wLG49MSl7T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIngiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTplfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInkiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp0fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInoiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpufSl9Z2V0IFhZKCl7cmV0dXJuW3RoaXMueCx0aGlzLnldfXNldHooZSl7cmV0dXJuIHRoaXMuej1lLHRoaXN9c2V0WFkoZT10aGlzLngsdD10aGlzLnkpe3JldHVybiB0aGlzLng9ZSx0aGlzLnk9dCx0aGlzfXNldChlPXRoaXMueCx0PXRoaXMueSxuPXRoaXMueil7cmV0dXJuIHRoaXMueD1lLHRoaXMueT10LHRoaXMuej1uLHRoaXN9c2V0VG8oe3g6ZT0wLHk6dD0wLHo6bj0xfSl7cmV0dXJuIHRoaXMueD1lLHRoaXMueT10LHRoaXMuej1uLHRoaXN9cm90KGUpe2lmKGU9PT0wKXJldHVybiB0aGlzO2NvbnN0e3g6dCx5Om59PXRoaXMsaT1NYXRoLnNpbihlKSxmPU1hdGguY29zKGUpO3JldHVybiB0aGlzLng9dCpmLW4qaSx0aGlzLnk9dCppK24qZix0aGlzfXJvdFdpdGgoZSx0KXtpZih0PT09MClyZXR1cm4gdGhpcztjb25zdCBuPXRoaXMueC1lLngsaT10aGlzLnktZS55LGY9TWF0aC5zaW4odCksaD1NYXRoLmNvcyh0KTtyZXR1cm4gdGhpcy54PWUueCsobipoLWkqZiksdGhpcy55PWUueSsobipmK2kqaCksdGhpc31jbG9uZSgpe2NvbnN0e3g6ZSx5OnQsejpufT10aGlzO3JldHVybiBuZXcgRXQoZSx0LG4pfXN1YihlKXtyZXR1cm4gdGhpcy54LT1lLngsdGhpcy55LT1lLnksdGhpc31zdWJYWShlLHQpe3JldHVybiB0aGlzLngtPWUsdGhpcy55LT10LHRoaXN9c3ViU2NhbGFyKGUpe3JldHVybiB0aGlzLngtPWUsdGhpcy55LT1lLHRoaXN9YWRkKGUpe3JldHVybiB0aGlzLngrPWUueCx0aGlzLnkrPWUueSx0aGlzfWFkZFhZKGUsdCl7cmV0dXJuIHRoaXMueCs9ZSx0aGlzLnkrPXQsdGhpc31hZGRTY2FsYXIoZSl7cmV0dXJuIHRoaXMueCs9ZSx0aGlzLnkrPWUsdGhpc31jbGFtcChlLHQpe3JldHVybiB0aGlzLng9TWF0aC5tYXgodGhpcy54LGUpLHRoaXMueT1NYXRoLm1heCh0aGlzLnksZSksdCE9PXZvaWQgMCYmKHRoaXMueD1NYXRoLm1pbih0aGlzLngsdCksdGhpcy55PU1hdGgubWluKHRoaXMueSx0KSksdGhpc31kaXYoZSl7cmV0dXJuIHRoaXMueC89ZSx0aGlzLnkvPWUsdGhpc31kaXZWKGUpe3JldHVybiB0aGlzLngvPWUueCx0aGlzLnkvPWUueSx0aGlzfW11bChlKXtyZXR1cm4gdGhpcy54Kj1lLHRoaXMueSo9ZSx0aGlzfW11bFYoZSl7cmV0dXJuIHRoaXMueCo9ZS54LHRoaXMueSo9ZS55LHRoaXN9YWJzKCl7cmV0dXJuIHRoaXMueD1NYXRoLmFicyh0aGlzLngpLHRoaXMueT1NYXRoLmFicyh0aGlzLnkpLHRoaXN9bnVkZ2UoZSx0KXtjb25zdCBuPUV0LlRhbihlLHRoaXMpO3JldHVybiB0aGlzLmFkZChuLm11bCh0KSl9bmVnKCl7cmV0dXJuIHRoaXMueCo9LTEsdGhpcy55Kj0tMSx0aGlzfWNyb3NzKGUpe3JldHVybiB0aGlzLng9dGhpcy55KmUuei10aGlzLnoqZS55LHRoaXMueT10aGlzLnoqZS54LXRoaXMueCplLnosdGhpc31kcHIoZSl7cmV0dXJuIEV0LkRwcih0aGlzLGUpfWNwcihlKXtyZXR1cm4gRXQuQ3ByKHRoaXMsZSl9bGVuMigpe3JldHVybiBFdC5MZW4yKHRoaXMpfWxlbigpe3JldHVybiBFdC5MZW4odGhpcyl9cHJ5KGUpe3JldHVybiBFdC5QcnkodGhpcyxlKX1wZXIoKXtjb25zdHt4OmUseTp0fT10aGlzO3JldHVybiB0aGlzLng9dCx0aGlzLnk9LWUsdGhpc311bmkoKXtyZXR1cm4gRXQuVW5pKHRoaXMpfXRhbihlKXtyZXR1cm4gRXQuVGFuKHRoaXMsZSl9ZGlzdChlKXtyZXR1cm4gRXQuRGlzdCh0aGlzLGUpfWRpc3RhbmNlVG9MaW5lU2VnbWVudChlLHQpe3JldHVybiBFdC5EaXN0YW5jZVRvTGluZVNlZ21lbnQoZSx0LHRoaXMpfXNsb3BlKGUpe3JldHVybiBFdC5TbG9wZSh0aGlzLGUpfXNuYXBUb0dyaWQoZSl7cmV0dXJuIHRoaXMueD1NYXRoLnJvdW5kKHRoaXMueC9lKSplLHRoaXMueT1NYXRoLnJvdW5kKHRoaXMueS9lKSplLHRoaXN9YW5nbGUoZSl7cmV0dXJuIEV0LkFuZ2xlKHRoaXMsZSl9dG9BbmdsZSgpe3JldHVybiBFdC5Ub0FuZ2xlKHRoaXMpfWxycChlLHQpe3JldHVybiB0aGlzLng9dGhpcy54KyhlLngtdGhpcy54KSp0LHRoaXMueT10aGlzLnkrKGUueS10aGlzLnkpKnQsdGhpc31lcXVhbHMoZSx0KXtyZXR1cm4gRXQuRXF1YWxzKHRoaXMsZSx0KX1lcXVhbHNYWShlLHQpe3JldHVybiBFdC5FcXVhbHNYWSh0aGlzLGUsdCl9bm9ybSgpe2NvbnN0IGU9dGhpcy5sZW4oKTtyZXR1cm4gdGhpcy54PWU9PT0wPzA6dGhpcy54L2UsdGhpcy55PWU9PT0wPzA6dGhpcy55L2UsdGhpc310b0ZpeGVkKCl7cmV0dXJuIEV0LlRvRml4ZWQodGhpcyl9dG9TdHJpbmcoKXtyZXR1cm4gRXQuVG9TdHJpbmcoRXQuVG9GaXhlZCh0aGlzKSl9dG9Kc29uKCl7cmV0dXJuIEV0LlRvSnNvbih0aGlzKX10b0FycmF5KCl7cmV0dXJuIEV0LlRvQXJyYXkodGhpcyl9c3RhdGljIEFkZChlLHQpe3JldHVybiBuZXcgRXQoZS54K3QueCxlLnkrdC55KX1zdGF0aWMgQWRkWFkoZSx0LG4pe3JldHVybiBuZXcgRXQoZS54K3QsZS55K24pfXN0YXRpYyBTdWIoZSx0KXtyZXR1cm4gbmV3IEV0KGUueC10LngsZS55LXQueSl9c3RhdGljIFN1YlhZKGUsdCxuKXtyZXR1cm4gbmV3IEV0KGUueC10LGUueS1uKX1zdGF0aWMgQWRkU2NhbGFyKGUsdCl7cmV0dXJuIG5ldyBFdChlLngrdCxlLnkrdCl9c3RhdGljIFN1YlNjYWxhcihlLHQpe3JldHVybiBuZXcgRXQoZS54LXQsZS55LXQpfXN0YXRpYyBEaXYoZSx0KXtyZXR1cm4gbmV3IEV0KGUueC90LGUueS90KX1zdGF0aWMgTXVsKGUsdCl7cmV0dXJuIG5ldyBFdChlLngqdCxlLnkqdCl9c3RhdGljIERpdlYoZSx0KXtyZXR1cm4gbmV3IEV0KGUueC90LngsZS55L3QueSl9c3RhdGljIE11bFYoZSx0KXtyZXR1cm4gbmV3IEV0KGUueCp0LngsZS55KnQueSl9c3RhdGljIE5lZyhlKXtyZXR1cm4gbmV3IEV0KC1lLngsLWUueSl9c3RhdGljIFBlcihlKXtyZXR1cm4gbmV3IEV0KGUueSwtZS54KX1zdGF0aWMgRGlzdDIoZSx0KXtyZXR1cm4gRXQuU3ViKGUsdCkubGVuMigpfXN0YXRpYyBBYnMoZSl7cmV0dXJuIG5ldyBFdChNYXRoLmFicyhlLngpLE1hdGguYWJzKGUueSkpfXN0YXRpYyBEaXN0KGUsdCl7cmV0dXJuIE1hdGguaHlwb3QoZS55LXQueSxlLngtdC54KX1zdGF0aWMgRHByKGUsdCl7cmV0dXJuIGUueCp0LngrZS55KnQueX1zdGF0aWMgQ3Jvc3MoZSx0KXtyZXR1cm4gbmV3IEV0KGUueSp0LnotZS56KnQueSxlLnoqdC54LWUueCp0LnopfXN0YXRpYyBDcHIoZSx0KXtyZXR1cm4gZS54KnQueS10LngqZS55fXN0YXRpYyBMZW4yKGUpe3JldHVybiBlLngqZS54K2UueSplLnl9c3RhdGljIExlbihlKXtyZXR1cm4gTWF0aC5oeXBvdChlLngsZS55KX1zdGF0aWMgUHJ5KGUsdCl7cmV0dXJuIEV0LkRwcihlLHQpL0V0Lkxlbih0KX1zdGF0aWMgVW5pKGUpe3JldHVybiBFdC5EaXYoZSxFdC5MZW4oZSkpfXN0YXRpYyBUYW4oZSx0KXtyZXR1cm4gRXQuVW5pKEV0LlN1YihlLHQpKX1zdGF0aWMgTWluKGUsdCl7cmV0dXJuIG5ldyBFdChNYXRoLm1pbihlLngsdC54KSxNYXRoLm1pbihlLnksdC55KSl9c3RhdGljIE1heChlLHQpe3JldHVybiBuZXcgRXQoTWF0aC5tYXgoZS54LHQueCksTWF0aC5tYXgoZS55LHQueSkpfXN0YXRpYyBGcm9tKGUpe3JldHVybiBuZXcgRXQoKS5hZGQoZSl9c3RhdGljIEZyb21BcnJheShlKXtyZXR1cm4gbmV3IEV0KGVbMF0sZVsxXSl9c3RhdGljIFJvdChlLHQ9MCl7Y29uc3Qgbj1NYXRoLnNpbih0KSxpPU1hdGguY29zKHQpO3JldHVybiBuZXcgRXQoZS54KmktZS55Km4sZS54Km4rZS55KmkpfXN0YXRpYyBSb3RXaXRoKGUsdCxuKXtjb25zdCBpPWUueC10LngsZj1lLnktdC55LGg9TWF0aC5zaW4obiksdT1NYXRoLmNvcyhuKTtyZXR1cm4gbmV3IEV0KHQueCsoaSp1LWYqaCksdC55KyhpKmgrZip1KSl9c3RhdGljIE5lYXJlc3RQb2ludE9uTGluZVRocm91Z2hQb2ludChlLHQsbil7cmV0dXJuIEV0Lk11bCh0LEV0LlN1YihuLGUpLnByeSh0KSkuYWRkKGUpfXN0YXRpYyBOZWFyZXN0UG9pbnRPbkxpbmVTZWdtZW50KGUsdCxuLGk9ITApe2NvbnN0IGY9RXQuVGFuKHQsZSksaD1FdC5BZGQoZSxFdC5NdWwoZixFdC5TdWIobixlKS5wcnkoZikpKTtpZihpKXtpZihoLng8TWF0aC5taW4oZS54LHQueCkpcmV0dXJuIEV0LkNhc3QoZS54PHQueD9lOnQpO2lmKGgueD5NYXRoLm1heChlLngsdC54KSlyZXR1cm4gRXQuQ2FzdChlLng+dC54P2U6dCk7aWYoaC55PE1hdGgubWluKGUueSx0LnkpKXJldHVybiBFdC5DYXN0KGUueTx0Lnk/ZTp0KTtpZihoLnk+TWF0aC5tYXgoZS55LHQueSkpcmV0dXJuIEV0LkNhc3QoZS55PnQueT9lOnQpfXJldHVybiBofXN0YXRpYyBEaXN0YW5jZVRvTGluZVRocm91Z2hQb2ludChlLHQsbil7cmV0dXJuIEV0LkRpc3QobixFdC5OZWFyZXN0UG9pbnRPbkxpbmVUaHJvdWdoUG9pbnQoZSx0LG4pKX1zdGF0aWMgRGlzdGFuY2VUb0xpbmVTZWdtZW50KGUsdCxuLGk9ITApe3JldHVybiBFdC5EaXN0KG4sRXQuTmVhcmVzdFBvaW50T25MaW5lU2VnbWVudChlLHQsbixpKSl9c3RhdGljIFNuYXAoZSx0PTEpe3JldHVybiBuZXcgRXQoTWF0aC5yb3VuZChlLngvdCkqdCxNYXRoLnJvdW5kKGUueS90KSp0KX1zdGF0aWMgQ2FzdChlKXtyZXR1cm4gZSBpbnN0YW5jZW9mIEV0P2U6RXQuRnJvbShlKX1zdGF0aWMgU2xvcGUoZSx0KXtyZXR1cm4gZS54PT09dC55P05hTjooZS55LXQueSkvKGUueC10LngpfXN0YXRpYyBBbmdsZShlLHQpe3JldHVybiBNYXRoLmF0YW4yKHQueS1lLnksdC54LWUueCl9c3RhdGljIExycChlLHQsbil7cmV0dXJuIEV0LlN1Yih0LGUpLm11bChuKS5hZGQoZSl9c3RhdGljIE1lZChlLHQpe3JldHVybiBuZXcgRXQoKGUueCt0LngpLzIsKGUueSt0LnkpLzIpfXN0YXRpYyBFcXVhbHMoZSx0LG49MWUtNCl7cmV0dXJuIE1hdGguYWJzKGUueC10LngpPG4mJk1hdGguYWJzKGUueS10LnkpPG59c3RhdGljIEVxdWFsc1hZKGUsdCxuKXtyZXR1cm4gZS54PT09dCYmZS55PT09bn1zdGF0aWMgRXF1YWxzWFlaKGUsdCxuPTFlLTQpe3JldHVybiBFdC5FcXVhbHMoZSx0LG4pJiZNYXRoLmFicygoZS56fHwwKS0odC56fHwwKSk8bn1zdGF0aWMgQ2xvY2t3aXNlKGUsdCxuKXtyZXR1cm4obi54LWUueCkqKHQueS1lLnkpLSh0LngtZS54KSoobi55LWUueSk8MH1zdGF0aWMgUmVzY2FsZShlLHQpe2NvbnN0IG49RXQuTGVuKGUpO3JldHVybiBuZXcgRXQodCplLngvbix0KmUueS9uKX1zdGF0aWMgU2NhbGVXaXRoT3JpZ2luKGUsdCxuKXtyZXR1cm4gRXQuU3ViKGUsbikubXVsKHQpLmFkZChuKX1zdGF0aWMgU2NhbGVXT3JpZ2luKGUsdCxuKXtyZXR1cm4gRXQuU3ViKGUsbikubXVsVih0KS5hZGQobil9c3RhdGljIFRvRml4ZWQoZSx0PTIpe3JldHVybiBuZXcgRXQoK2UueC50b0ZpeGVkKHQpLCtlLnkudG9GaXhlZCh0KSwrZS56LnRvRml4ZWQodCkpfXN0YXRpYyBOdWRnZShlLHQsbil7cmV0dXJuIEV0LkFkZChlLEV0LlRhbih0LGUpLm11bChuKSl9c3RhdGljIFRvU3RyaW5nKGUpe3JldHVybmAke2UueH0sICR7ZS55fWB9c3RhdGljIFRvQW5nbGUoZSl7bGV0IHQ9TWF0aC5hdGFuMihlLnksZS54KTtyZXR1cm4gdDwwJiYodCs9TWF0aC5QSSoyKSx0fXN0YXRpYyBGcm9tQW5nbGUoZSx0PTEpe3JldHVybiBuZXcgRXQoTWF0aC5jb3MoZSkqdCxNYXRoLnNpbihlKSp0KX1zdGF0aWMgVG9BcnJheShlKXtyZXR1cm5bZS54LGUueSxlLnpdfXN0YXRpYyBUb0pzb24oZSl7Y29uc3R7eDp0LHk6bix6Oml9PWU7cmV0dXJue3g6dCx5Om4sejppfX1zdGF0aWMgQXZlcmFnZShlKXtjb25zdCB0PWUubGVuZ3RoLG49bmV3IEV0KDAsMCk7Zm9yKGxldCBpPTA7aTx0O2krKyluLmFkZChlW2ldKTtyZXR1cm4gbi5kaXYodCl9c3RhdGljIENsYW1wKGUsdCxuKXtyZXR1cm4gbj09PXZvaWQgMD9uZXcgRXQoTWF0aC5taW4oTWF0aC5tYXgoZS54LHQpKSxNYXRoLm1pbihNYXRoLm1heChlLnksdCkpKTpuZXcgRXQoTWF0aC5taW4oTWF0aC5tYXgoZS54LHQpLG4pLE1hdGgubWluKE1hdGgubWF4KGUueSx0KSxuKSl9c3RhdGljIFBvaW50c0JldHdlZW4oZSx0LG49Nil7Y29uc3QgaT1bXTtmb3IobGV0IGY9MDtmPG47ZisrKXtjb25zdCBoPWltLmVhc2VJblF1YWQoZi8obi0xKSksdT1FdC5McnAoZSx0LGgpO3Uuej1NYXRoLm1pbigxLC41K01hdGguYWJzKC41LXNtKGgpKSouNjUpLGkucHVzaCh1KX1yZXR1cm4gaX1zdGF0aWMgU25hcFRvR3JpZChlLHQ9OCl7cmV0dXJuIG5ldyBFdChNYXRoLnJvdW5kKGUueC90KSp0LE1hdGgucm91bmQoZS55L3QpKnQpfX1jb25zdCBzbT1nPT5nPC41PzIqZypnOi0xKyg0LTIqZykqZztjbGFzcyBGdCBleHRlbmRzIEV0e2NvbnN0cnVjdG9yKGU9MCx0PTAsbj0wLGk9e3g6MCx5OjB9LGY9MCxoPTApe3N1cGVyKGUsdCxuKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywieCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOmV9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywieSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnR9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywieiIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOm59KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidiIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOml9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOmZ9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiYSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOmh9KX1nZXQgdGltZXN0YW1wKCl7cmV0dXJuIHRoaXMudH1nZXQgcHJlc3N1cmUoKXtyZXR1cm4gdGhpcy56fWdldCBhbmdsZU51bSgpe3JldHVybiB0aGlzLmF9Z2V0IFhZKCl7cmV0dXJuW3RoaXMueCx0aGlzLnldfXNldEEoZSl7dGhpcy5hPWV9c2V0VChlKXt0aGlzLnQ9ZX1zZXR2KGUpe3JldHVybiB0aGlzLnY9e3g6ZS54LHk6ZS55fSx0aGlzfXNldChlPXRoaXMueCx0PXRoaXMueSxuPXRoaXMueixpPXRoaXMudixmPXRoaXMudCxoPXRoaXMuYSl7cmV0dXJuIHRoaXMueD1lLHRoaXMueT10LHRoaXMuej1uLHRoaXMudj1pLHRoaXMudD1mLHRoaXMuYT1oLHRoaXN9Y2xvbmUoKXtjb25zdHt4OmUseTp0LHo6bix2OmksdDpmLGE6aH09dGhpcyx1PXt4OmkueCx5OmkueX07cmV0dXJuIG5ldyBGdChlLHQsbix1LGYsaCl9ZGlzdGFuY2UoZSl7cmV0dXJuIEZ0LkdldERpc3RhbmNlKHRoaXMsZSl9aXNOZWFyKGUsdCl7cmV0dXJuIEZ0LklzTmVhcih0aGlzLGUsdCl9Z2V0QW5nbGVCeVBvaW50cyhlLHQpe3JldHVybiBGdC5HZXRBbmdsZUJ5UG9pbnRzKGUsdGhpcyx0KX1zdGF0aWMgU3ViKGUsdCl7cmV0dXJuIG5ldyBGdChlLngtdC54LGUueS10LnkpfXN0YXRpYyBBZGQoZSx0KXtyZXR1cm4gbmV3IEZ0KGUueCt0LngsZS55K3QueSl9c3RhdGljIEdldERpc3RhbmNlKGUsdCl7cmV0dXJuIEZ0LkxlbihlLmNsb25lKCkuc3ViKHQpKX1zdGF0aWMgR2V0QW5nbGVCeVBvaW50cyhlLHQsbil7Y29uc3QgaT10LngtZS54LGY9bi54LXQueCxoPXQueS1lLnksdT1uLnktdC55O2xldCBhPTA7Y29uc3QgZD1NYXRoLnNxcnQoaSppK2gqaCksRT1NYXRoLnNxcnQoZipmK3UqdSk7aWYoZCYmRSl7Y29uc3QgcD1pKmYraCp1O2E9TWF0aC5hY29zKHAvKGQqRSkpLGE9YS9NYXRoLlBJKjE4MDtsZXQgTz1pKnUtaCpmO089Tz4wPzE6LTEsYT0xODArTyphfXJldHVybiBhfXN0YXRpYyBJc05lYXIoZSx0LG4pe3JldHVybiBGdC5MZW4oZS5jbG9uZSgpLnN1Yih0KSk8bn1zdGF0aWMgUm90V2l0aChlLHQsbixpPTIpe2NvbnN0IGY9ZS54LXQueCxoPWUueS10LnksdT1NYXRoLnNpbihuKSxhPU1hdGguY29zKG4pLGQ9TWF0aC5wb3coMTAsaSksRT1NYXRoLmZsb29yKCh0LngrKGYqYS1oKnUpKSpkKS9kLHA9TWF0aC5mbG9vcigodC55KyhmKnUraCphKSkqZCkvZDtyZXR1cm4gbmV3IEZ0KEUscCl9c3RhdGljIEdldERvdFN0cm9rZShlLHQsbj0xNil7Y29uc3QgaT1uZXcgRXQoMSwxKSxmPU1hdGguUEkrLjAwMSxoPUZ0LkFkZChlLEZ0LlN1YihlLGkpLnVuaSgpLnBlcigpLm11bCgtdCkpLHU9W107Zm9yKGxldCBhPTEvbixkPWE7ZDw9MTtkKz1hKXUucHVzaChGdC5Sb3RXaXRoKGgsZSxmKjIqZCkpO3JldHVybiB1fXN0YXRpYyBHZXRTZW1pY2lyY2xlU3Ryb2tlKGUsdCxuPS0xLGk9OCl7Y29uc3QgZj1uKihNYXRoLlBJKy4wMDEpLGg9W107Zm9yKGxldCB1PTEvaSxhPXU7YTw9MTthKz11KWgucHVzaChGdC5Sb3RXaXRoKHQsZSxmKmEpKTtyZXR1cm4gaH19ZnVuY3Rpb24gb20oZyxlKXtyZXR1cm57eDpnLngtZSx5OmcueS1lLHc6Zy53K2UqMixoOmcuaCtlKjJ9fWZ1bmN0aW9uICR0KGcsZSl7aWYoZyYmZSl7Y29uc3QgdD1NYXRoLm1pbihnLngsZS54KSxuPU1hdGgubWluKGcueSxlLnkpLGk9TWF0aC5tYXgoZy54K2cudyxlLngrZS53KSxmPU1hdGgubWF4KGcueStnLmgsZS55K2UuaCksaD1pLXQsdT1mLW47cmV0dXJue3g6dCx5Om4sdzpoLGg6dX19cmV0dXJuIGV8fGd9ZnVuY3Rpb24geGUoZyxlPTApe2NvbnN0IHQ9e3g6MCx5OjAsdzowLGg6MH07bGV0IG49MS8wLGk9MS8wLGY9LTEvMCxoPS0xLzA7cmV0dXJuIGcuZm9yRWFjaCh1PT57Y29uc3RbYSxkXT11LlhZO249TWF0aC5taW4obixhLWUpLGk9TWF0aC5taW4oaSxkLWUpLGY9TWF0aC5tYXgoZixhK2UpLGg9TWF0aC5tYXgoaCxkK2UpfSksdC54PW4sdC55PWksdC53PWYtbix0Lmg9aC1pLHR9ZnVuY3Rpb24gUm4oZyxlKXtyZXR1cm4hKGcueCtnLnc8ZS54fHxnLng+ZS54K2Uud3x8Zy55K2cuaDxlLnl8fGcueT5lLnkrZS5oKX1mdW5jdGlvbiBhbShnLGUpe3JldHVybiBnLmxlbmd0aD09PWUubGVuZ3RoJiZnLnNvcnQoKS50b1N0cmluZygpPT09ZS5zb3J0KCkudG9TdHJpbmcoKX1mdW5jdGlvbiBsbihnLGU9MTApe3JldHVybnt4Ok1hdGguZmxvb3IoZy54LWUpLHk6TWF0aC5mbG9vcihnLnktZSksdzpNYXRoLmZsb29yKGcudytlKjIpLGg6TWF0aC5mbG9vcihnLmgrZSoyKX19ZnVuY3Rpb24gTGEoZyxlKXtyZXR1cm57eDpnLngrZVswXSx5OmcueStlWzFdLHc6Zy53LGg6Zy5ofX1mdW5jdGlvbiBsbShnLGUpe2NvbnN0IHQ9bmV3IEV0KGcueCxnLnkpLG49bmV3IEV0KGcueCtnLncsZy55KSxpPW5ldyBFdChnLngrZy53LGcueStnLmgpLGY9bmV3IEV0KGcueCxnLnkrZy5oKSxoPW5ldyBFdChnLngrZy53LzIsZy55K2cuaC8yKSx1PU1hdGguUEkqZS8xODAsYT1FdC5Sb3RXaXRoKHQsaCx1KSxkPUV0LlJvdFdpdGgobixoLHUpLEU9RXQuUm90V2l0aChpLGgsdSkscD1FdC5Sb3RXaXRoKGYsaCx1KTtyZXR1cm4geGUoW2EsZCxFLHBdKX1mdW5jdGlvbiB1bShnLGUpe2NvbnN0IHQ9bmV3IEV0KGcueCxnLnkpLG49bmV3IEV0KGcueCtnLncsZy55KSxpPW5ldyBFdChnLngrZy53LGcueStnLmgpLGY9bmV3IEV0KGcueCxnLnkrZy5oKSxoPW5ldyBFdChnLngrZy53LzIsZy55K2cuaC8yKSx1PW5ldyBFdChlWzBdLGVbMV0pLGE9RXQuU2NhbGVXT3JpZ2luKHQsdSxoKSxkPUV0LlNjYWxlV09yaWdpbihuLHUsaCksRT1FdC5TY2FsZVdPcmlnaW4oaSx1LGgpLHA9RXQuU2NhbGVXT3JpZ2luKGYsdSxoKTtyZXR1cm4geGUoW2EsZCxFLHBdKX1mdW5jdGlvbiBmbShnLGUsdCl7Y29uc3Qgbj1uZXcgRXQoZVswXSxlWzFdKTtmb3IobGV0IGk9MDtpPGcubGVuZ3RoO2krPTMpe2NvbnN0IGY9bmV3IEV0KGdbaV0sZ1tpKzFdKSxoPU1hdGguUEkqdC8xODAsdT1FdC5Sb3RXaXRoKGYsbixoKTtnW2ldPXUueCxnW2krMV09dS55fX1mdW5jdGlvbiBjbShnLGUsdCl7Y29uc3Qgbj1uZXcgRXQoZVswXSxlWzFdKTtmb3IobGV0IGk9MDtpPGcubGVuZ3RoO2krPTMpe2NvbnN0IGY9bmV3IEV0KGdbaV0sZ1tpKzFdKSxoPW5ldyBFdCh0WzBdLHRbMV0pO2lmKGk8Zy5sZW5ndGgtMyl7Y29uc3QgYT1uZXcgRXQoZ1tpKzNdLGdbaSs0XSksZD1FdC5UYW4oYSxmKS5wZXIoKS5tdWwoZ1tpKzJdKS5tdWxWKGgpLmxlbigpO2dbaSsyXT1kfWVsc2UgaWYoaT09PWcubGVuZ3RoLTMpe2NvbnN0IGE9bmV3IEV0KGdbaS0zXSxnW2ktMl0pLGQ9RXQuVGFuKGYsYSkucGVyKCkubXVsKGdbaSsyXSkubXVsVihoKS5sZW4oKTtnW2krMl09ZH1jb25zdCB1PUV0LlNjYWxlV09yaWdpbihmLGgsbik7Z1tpXT11LngsZ1tpKzFdPXUueX19ZnVuY3Rpb24gaG0oZyxlKXtyZXR1cm4gZ1swXT49ZS54JiZnWzBdPD1lLngrZS53JiZnWzFdPj1lLnkmJmdbMV08PWUueStlLmh9ZnVuY3Rpb24gRGEoZyxlKXtjb25zdCB0PWc8PWU/MTpnL2Usbj1lPD1nPzE6ZS9nO3JldHVyblt0LG5dfWNvbnN0IHJpPWc9PntpZihnLnRhZ05hbWU9PT0iR1JPVVAiKXtjb25zdCBlPU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZykuZmluZCh0PT50LnRvU3RyaW5nKCk9PT0iU3ltYm9sKHNlYWxlZCkiKTtpZihlJiZnW2VdKXJldHVybiEwfXJldHVybiExfSx3YT1nPT5nIT09THQuVGV4dDtmdW5jdGlvbiB1bihnKXtyZXR1cm5gJHtuaShnLngpfSwke25pKGcueSl9IGB9ZnVuY3Rpb24gZm4oZyxlKXtyZXR1cm5gJHtuaSgoZy54K2UueCkvMil9LCR7bmkoKGcueStlLnkpLzIpfSBgfWZ1bmN0aW9uIG5pKGcpe3JldHVybitnLnRvRml4ZWQoNCl9dmFyIGRtPXJuLGdtPUdyLHZtPSJbb2JqZWN0IE51bWJlcl0iO2Z1bmN0aW9uIHBtKGcpe3JldHVybiB0eXBlb2YgZz09Im51bWJlciJ8fGdtKGcpJiZkbShnKT09dm19dmFyIG1tPXBtLE5hPVZuKG1tKSxpaT17ZXhwb3J0czp7fX07LyoqCiAqIEBsaWNlbnNlCiAqIExvZGFzaCA8aHR0cHM6Ly9sb2Rhc2guY29tLz4KICogQ29weXJpZ2h0IE9wZW5KUyBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnMgPGh0dHBzOi8vb3BlbmpzZi5vcmcvPgogKiBSZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+CiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+CiAqIENvcHlyaWdodCBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9ycwogKi9paS5leHBvcnRzLGZ1bmN0aW9uKGcsZSl7KGZ1bmN0aW9uKCl7dmFyIHQsbj0iNC4xNy4yMSIsaT0yMDAsZj0iVW5zdXBwb3J0ZWQgY29yZS1qcyB1c2UuIFRyeSBodHRwczovL25wbXMuaW8vc2VhcmNoP3E9cG9ueWZpbGwuIixoPSJFeHBlY3RlZCBhIGZ1bmN0aW9uIix1PSJJbnZhbGlkIGB2YXJpYWJsZWAgb3B0aW9uIHBhc3NlZCBpbnRvIGBfLnRlbXBsYXRlYCIsYT0iX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyIsZD01MDAsRT0iX19sb2Rhc2hfcGxhY2Vob2xkZXJfXyIscD0xLE89MixtPTQsYj0xLE09Mix5PTEsUz0yLHM9NCxjPTgsbD0xNix2PTMyLFQ9NjQsUj0xMjgsTD0yNTYsTj01MTIsQT0zMCx3PSIuLi4iLEI9ODAwLEQ9MTYsST0xLGo9MixWPTMsSj0xLzAsXz05MDA3MTk5MjU0NzQwOTkxLHN0PTE3OTc2OTMxMzQ4NjIzMTU3ZTI5MixHPU5hTixZPTQyOTQ5NjcyOTUscnQ9WS0xLG90PVk+Pj4xLGF0PVtbImFyeSIsUl0sWyJiaW5kIix5XSxbImJpbmRLZXkiLFNdLFsiY3VycnkiLGNdLFsiY3VycnlSaWdodCIsbF0sWyJmbGlwIixOXSxbInBhcnRpYWwiLHZdLFsicGFydGlhbFJpZ2h0IixUXSxbInJlYXJnIixMXV0saHQ9IltvYmplY3QgQXJndW1lbnRzXSIsaXQ9IltvYmplY3QgQXJyYXldIixNdD0iW29iamVjdCBBc3luY0Z1bmN0aW9uXSIsT3Q9IltvYmplY3QgQm9vbGVhbl0iLFU9IltvYmplY3QgRGF0ZV0iLCQ9IltvYmplY3QgRE9NRXhjZXB0aW9uXSIsUT0iW29iamVjdCBFcnJvcl0iLHR0PSJbb2JqZWN0IEZ1bmN0aW9uXSIsRj0iW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0iLEg9IltvYmplY3QgTWFwXSIseD0iW29iamVjdCBOdW1iZXJdIixQPSJbb2JqZWN0IE51bGxdIixXPSJbb2JqZWN0IE9iamVjdF0iLEs9IltvYmplY3QgUHJvbWlzZV0iLFo9IltvYmplY3QgUHJveHldIixrPSJbb2JqZWN0IFJlZ0V4cF0iLG50PSJbb2JqZWN0IFNldF0iLHV0PSJbb2JqZWN0IFN0cmluZ10iLGN0PSJbb2JqZWN0IFN5bWJvbF0iLHB0PSJbb2JqZWN0IFVuZGVmaW5lZF0iLHh0PSJbb2JqZWN0IFdlYWtNYXBdIixndD0iW29iamVjdCBXZWFrU2V0XSIsZHQ9IltvYmplY3QgQXJyYXlCdWZmZXJdIixtdD0iW29iamVjdCBEYXRhVmlld10iLGJ0PSJbb2JqZWN0IEZsb2F0MzJBcnJheV0iLEN0PSJbb2JqZWN0IEZsb2F0NjRBcnJheV0iLFN0PSJbb2JqZWN0IEludDhBcnJheV0iLE50PSJbb2JqZWN0IEludDE2QXJyYXldIixKdD0iW29iamVjdCBJbnQzMkFycmF5XSIsR3Q9IltvYmplY3QgVWludDhBcnJheV0iLEt0PSJbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XSIsWXQ9IltvYmplY3QgVWludDE2QXJyYXldIixWdD0iW29iamVjdCBVaW50MzJBcnJheV0iLFNlPS9cYl9fcCBcKz0gJyc7L2csT2U9L1xiKF9fcCBcKz0pICcnIFwrL2csRWU9LyhfX2VcKC4qP1wpfFxiX190XCkpIFwrXG4nJzsvZyxtZT0vJig/OmFtcHxsdHxndHxxdW90fCMzOSk7L2csVGU9L1smPD4iJ10vZyxiZT1SZWdFeHAobWUuc291cmNlKSxJZT1SZWdFeHAoVGUuc291cmNlKSxzZT0vPCUtKFtcc1xTXSs/KSU+L2csVmU9LzwlKFtcc1xTXSs/KSU+L2csTHI9LzwlPShbXHNcU10rPyklPi9nLFlyPS9cLnxcWyg/OlteW1xdXSp8KFsiJ10pKD86KD8hXDEpW15cXF18XFwuKSo/XDEpXF0vLGFpPS9eXHcqJC8sbGk9L1teLltcXV0rfFxbKD86KC0/XGQrKD86XC5cZCspPyl8KFsiJ10pKCg/Oig/IVwyKVteXFxdfFxcLikqPylcMilcXXwoPz0oPzpcLnxcW1xdKSg/OlwufFxbXF18JCkpL2cseXM9L1tcXF4kLiorPygpW1xde318XS9nLFN5PVJlZ0V4cCh5cy5zb3VyY2UpLHhzPS9eXHMrLyxUeT0vXHMvLFB5PS9ceyg/OlxuXC9cKiBcW3dyYXBwZWQgd2l0aCAuK1xdIFwqXC8pP1xuPy8sYnk9L1x7XG5cL1wqIFxbd3JhcHBlZCB3aXRoICguKylcXSBcKi8sQXk9Lyw/ICYgLyxDeT0vW15ceDAwLVx4MmZceDNhLVx4NDBceDViLVx4NjBceDdiLVx4N2ZdKy9nLFJ5PS9bKCk9LHt9XFtcXVwvXHNdLyxJeT0vXFwoXFwpPy9nLEx5PS9cJFx7KFteXFx9XSooPzpcXC5bXlxcfV0qKSopXH0vZyxlbD0vXHcqJC8sRHk9L15bLStdMHhbMC05YS1mXSskL2ksd3k9L14wYlswMV0rJC9pLE55PS9eXFtvYmplY3QgLis/Q29uc3RydWN0b3JcXSQvLEJ5PS9eMG9bMC03XSskL2ksV3k9L14oPzowfFsxLTldXGQqKSQvLEZ5PS9bXHhjMC1ceGQ2XHhkOC1ceGY2XHhmOC1ceGZmXHUwMTAwLVx1MDE3Zl0vZyx1aT0vKCReKS8sank9L1snXG5cclx1MjAyOFx1MjAyOVxcXS9nLGZpPSJcXHVkODAwLVxcdWRmZmYiLFV5PSJcXHUwMzAwLVxcdTAzNmYiLHp5PSJcXHVmZTIwLVxcdWZlMmYiLCR5PSJcXHUyMGQwLVxcdTIwZmYiLHJsPVV5K3p5KyR5LG5sPSJcXHUyNzAwLVxcdTI3YmYiLGlsPSJhLXpcXHhkZi1cXHhmNlxceGY4LVxceGZmIixHeT0iXFx4YWNcXHhiMVxceGQ3XFx4ZjciLEt5PSJcXHgwMC1cXHgyZlxceDNhLVxceDQwXFx4NWItXFx4NjBcXHg3Yi1cXHhiZiIsSHk9IlxcdTIwMDAtXFx1MjA2ZiIsWXk9IiBcXHRcXHgwYlxcZlxceGEwXFx1ZmVmZlxcblxcclxcdTIwMjhcXHUyMDI5XFx1MTY4MFxcdTE4MGVcXHUyMDAwXFx1MjAwMVxcdTIwMDJcXHUyMDAzXFx1MjAwNFxcdTIwMDVcXHUyMDA2XFx1MjAwN1xcdTIwMDhcXHUyMDA5XFx1MjAwYVxcdTIwMmZcXHUyMDVmXFx1MzAwMCIsc2w9IkEtWlxceGMwLVxceGQ2XFx4ZDgtXFx4ZGUiLG9sPSJcXHVmZTBlXFx1ZmUwZiIsYWw9R3krS3krSHkrWXksT3M9Ilsn4oCZXSIsVnk9IlsiK2ZpKyJdIixsbD0iWyIrYWwrIl0iLGNpPSJbIitybCsiXSIsdWw9IlxcZCsiLFh5PSJbIitubCsiXSIsZmw9IlsiK2lsKyJdIixjbD0iW14iK2ZpK2FsK3VsK25sK2lsK3NsKyJdIixFcz0iXFx1ZDgzY1tcXHVkZmZiLVxcdWRmZmZdIixaeT0iKD86IitjaSsifCIrRXMrIikiLGhsPSJbXiIrZmkrIl0iLE1zPSIoPzpcXHVkODNjW1xcdWRkZTYtXFx1ZGRmZl0pezJ9IixTcz0iW1xcdWQ4MDAtXFx1ZGJmZl1bXFx1ZGMwMC1cXHVkZmZmXSIsZ249IlsiK3NsKyJdIixkbD0iXFx1MjAwZCIsZ2w9Iig/OiIrZmwrInwiK2NsKyIpIixKeT0iKD86IitnbisifCIrY2wrIikiLHZsPSIoPzoiK09zKyIoPzpkfGxsfG18cmV8c3x0fHZlKSk/IixwbD0iKD86IitPcysiKD86RHxMTHxNfFJFfFN8VHxWRSkpPyIsbWw9WnkrIj8iLHlsPSJbIitvbCsiXT8iLFF5PSIoPzoiK2RsKyIoPzoiK1tobCxNcyxTc10uam9pbigifCIpKyIpIit5bCttbCsiKSoiLGt5PSJcXGQqKD86MXN0fDJuZHwzcmR8KD8hWzEyM10pXFxkdGgpKD89XFxifFtBLVpfXSkiLHF5PSJcXGQqKD86MVNUfDJORHwzUkR8KD8hWzEyM10pXFxkVEgpKD89XFxifFthLXpfXSkiLHhsPXlsK21sK1F5LF95PSIoPzoiK1tYeSxNcyxTc10uam9pbigifCIpKyIpIit4bCx0Mj0iKD86IitbaGwrY2krIj8iLGNpLE1zLFNzLFZ5XS5qb2luKCJ8IikrIikiLGUyPVJlZ0V4cChPcywiZyIpLHIyPVJlZ0V4cChjaSwiZyIpLFRzPVJlZ0V4cChFcysiKD89IitFcysiKXwiK3QyK3hsLCJnIiksbjI9UmVnRXhwKFtnbisiPyIrZmwrIisiK3ZsKyIoPz0iK1tsbCxnbiwiJCJdLmpvaW4oInwiKSsiKSIsSnkrIisiK3BsKyIoPz0iK1tsbCxnbitnbCwiJCJdLmpvaW4oInwiKSsiKSIsZ24rIj8iK2dsKyIrIit2bCxnbisiKyIrcGwscXksa3ksdWwsX3ldLmpvaW4oInwiKSwiZyIpLGkyPVJlZ0V4cCgiWyIrZGwrZmkrcmwrb2wrIl0iKSxzMj0vW2Etel1bQS1aXXxbQS1aXXsyfVthLXpdfFswLTldW2EtekEtWl18W2EtekEtWl1bMC05XXxbXmEtekEtWjAtOSBdLyxvMj1bIkFycmF5IiwiQnVmZmVyIiwiRGF0YVZpZXciLCJEYXRlIiwiRXJyb3IiLCJGbG9hdDMyQXJyYXkiLCJGbG9hdDY0QXJyYXkiLCJGdW5jdGlvbiIsIkludDhBcnJheSIsIkludDE2QXJyYXkiLCJJbnQzMkFycmF5IiwiTWFwIiwiTWF0aCIsIk9iamVjdCIsIlByb21pc2UiLCJSZWdFeHAiLCJTZXQiLCJTdHJpbmciLCJTeW1ib2wiLCJUeXBlRXJyb3IiLCJVaW50OEFycmF5IiwiVWludDhDbGFtcGVkQXJyYXkiLCJVaW50MTZBcnJheSIsIlVpbnQzMkFycmF5IiwiV2Vha01hcCIsIl8iLCJjbGVhclRpbWVvdXQiLCJpc0Zpbml0ZSIsInBhcnNlSW50Iiwic2V0VGltZW91dCJdLGEyPS0xLHBlPXt9O3BlW2J0XT1wZVtDdF09cGVbU3RdPXBlW050XT1wZVtKdF09cGVbR3RdPXBlW0t0XT1wZVtZdF09cGVbVnRdPSEwLHBlW2h0XT1wZVtpdF09cGVbZHRdPXBlW090XT1wZVttdF09cGVbVV09cGVbUV09cGVbdHRdPXBlW0hdPXBlW3hdPXBlW1ddPXBlW2tdPXBlW250XT1wZVt1dF09cGVbeHRdPSExO3ZhciBnZT17fTtnZVtodF09Z2VbaXRdPWdlW2R0XT1nZVttdF09Z2VbT3RdPWdlW1VdPWdlW2J0XT1nZVtDdF09Z2VbU3RdPWdlW050XT1nZVtKdF09Z2VbSF09Z2VbeF09Z2VbV109Z2Vba109Z2VbbnRdPWdlW3V0XT1nZVtjdF09Z2VbR3RdPWdlW0t0XT1nZVtZdF09Z2VbVnRdPSEwLGdlW1FdPWdlW3R0XT1nZVt4dF09ITE7dmFyIGwyPXvDgDoiQSIsw4E6IkEiLMOCOiJBIizDgzoiQSIsw4Q6IkEiLMOFOiJBIizDoDoiYSIsw6E6ImEiLMOiOiJhIizDozoiYSIsw6Q6ImEiLMOlOiJhIizDhzoiQyIsw6c6ImMiLMOQOiJEIizDsDoiZCIsw4g6IkUiLMOJOiJFIizDijoiRSIsw4s6IkUiLMOoOiJlIizDqToiZSIsw6o6ImUiLMOrOiJlIizDjDoiSSIsw406IkkiLMOOOiJJIizDjzoiSSIsw6w6ImkiLMOtOiJpIizDrjoiaSIsw686ImkiLMOROiJOIizDsToibiIsw5I6Ik8iLMOTOiJPIizDlDoiTyIsw5U6Ik8iLMOWOiJPIizDmDoiTyIsw7I6Im8iLMOzOiJvIizDtDoibyIsw7U6Im8iLMO2OiJvIizDuDoibyIsw5k6IlUiLMOaOiJVIizDmzoiVSIsw5w6IlUiLMO5OiJ1IizDujoidSIsw7s6InUiLMO8OiJ1IizDnToiWSIsw706InkiLMO/OiJ5IizDhjoiQWUiLMOmOiJhZSIsw546IlRoIizDvjoidGgiLMOfOiJzcyIsxIA6IkEiLMSCOiJBIizEhDoiQSIsxIE6ImEiLMSDOiJhIizEhToiYSIsxIY6IkMiLMSIOiJDIizEijoiQyIsxIw6IkMiLMSHOiJjIizEiToiYyIsxIs6ImMiLMSNOiJjIizEjjoiRCIsxJA6IkQiLMSPOiJkIizEkToiZCIsxJI6IkUiLMSUOiJFIizEljoiRSIsxJg6IkUiLMSaOiJFIizEkzoiZSIsxJU6ImUiLMSXOiJlIizEmToiZSIsxJs6ImUiLMScOiJHIizEnjoiRyIsxKA6IkciLMSiOiJHIizEnToiZyIsxJ86ImciLMShOiJnIizEozoiZyIsxKQ6IkgiLMSmOiJIIizEpToiaCIsxKc6ImgiLMSoOiJJIizEqjoiSSIsxKw6IkkiLMSuOiJJIizEsDoiSSIsxKk6ImkiLMSrOiJpIizErToiaSIsxK86ImkiLMSxOiJpIizEtDoiSiIsxLU6ImoiLMS2OiJLIizEtzoiayIsxLg6ImsiLMS5OiJMIizEuzoiTCIsxL06IkwiLMS/OiJMIizFgToiTCIsxLo6ImwiLMS8OiJsIizEvjoibCIsxYA6ImwiLMWCOiJsIizFgzoiTiIsxYU6Ik4iLMWHOiJOIizFijoiTiIsxYQ6Im4iLMWGOiJuIizFiDoibiIsxYs6Im4iLMWMOiJPIizFjjoiTyIsxZA6Ik8iLMWNOiJvIizFjzoibyIsxZE6Im8iLMWUOiJSIizFljoiUiIsxZg6IlIiLMWVOiJyIizFlzoiciIsxZk6InIiLMWaOiJTIizFnDoiUyIsxZ46IlMiLMWgOiJTIizFmzoicyIsxZ06InMiLMWfOiJzIizFoToicyIsxaI6IlQiLMWkOiJUIizFpjoiVCIsxaM6InQiLMWlOiJ0IizFpzoidCIsxag6IlUiLMWqOiJVIizFrDoiVSIsxa46IlUiLMWwOiJVIizFsjoiVSIsxak6InUiLMWrOiJ1IizFrToidSIsxa86InUiLMWxOiJ1IizFszoidSIsxbQ6IlciLMW1OiJ3IizFtjoiWSIsxbc6InkiLMW4OiJZIizFuToiWiIsxbs6IloiLMW9OiJaIizFujoieiIsxbw6InoiLMW+OiJ6IizEsjoiSUoiLMSzOiJpaiIsxZI6Ik9lIizFkzoib2UiLMWJOiInbiIsxb86InMifSx1Mj17IiYiOiImYW1wOyIsIjwiOiImbHQ7IiwiPiI6IiZndDsiLCciJzoiJnF1b3Q7IiwiJyI6IiYjMzk7In0sZjI9eyImYW1wOyI6IiYiLCImbHQ7IjoiPCIsIiZndDsiOiI+IiwiJnF1b3Q7IjonIicsIiYjMzk7IjoiJyJ9LGMyPXsiXFwiOiJcXCIsIiciOiInIiwiXG4iOiJuIiwiXHIiOiJyIiwiXHUyMDI4IjoidTIwMjgiLCJcdTIwMjkiOiJ1MjAyOSJ9LGgyPXBhcnNlRmxvYXQsZDI9cGFyc2VJbnQsT2w9dHlwZW9mIG1yPT0ib2JqZWN0IiYmbXImJm1yLk9iamVjdD09PU9iamVjdCYmbXIsZzI9dHlwZW9mIHNlbGY9PSJvYmplY3QiJiZzZWxmJiZzZWxmLk9iamVjdD09PU9iamVjdCYmc2VsZixOZT1PbHx8ZzJ8fEZ1bmN0aW9uKCJyZXR1cm4gdGhpcyIpKCksUHM9ZSYmIWUubm9kZVR5cGUmJmUsVnI9UHMmJiEwJiZnJiYhZy5ub2RlVHlwZSYmZyxFbD1WciYmVnIuZXhwb3J0cz09PVBzLGJzPUVsJiZPbC5wcm9jZXNzLF9lPWZ1bmN0aW9uKCl7dHJ5e3ZhciB2dD1WciYmVnIucmVxdWlyZSYmVnIucmVxdWlyZSgidXRpbCIpLnR5cGVzO3JldHVybiB2dHx8YnMmJmJzLmJpbmRpbmcmJmJzLmJpbmRpbmcoInV0aWwiKX1jYXRjaHt9fSgpLE1sPV9lJiZfZS5pc0FycmF5QnVmZmVyLFNsPV9lJiZfZS5pc0RhdGUsVGw9X2UmJl9lLmlzTWFwLFBsPV9lJiZfZS5pc1JlZ0V4cCxibD1fZSYmX2UuaXNTZXQsQWw9X2UmJl9lLmlzVHlwZWRBcnJheTtmdW5jdGlvbiBYZSh2dCxBdCxQdCl7c3dpdGNoKFB0Lmxlbmd0aCl7Y2FzZSAwOnJldHVybiB2dC5jYWxsKEF0KTtjYXNlIDE6cmV0dXJuIHZ0LmNhbGwoQXQsUHRbMF0pO2Nhc2UgMjpyZXR1cm4gdnQuY2FsbChBdCxQdFswXSxQdFsxXSk7Y2FzZSAzOnJldHVybiB2dC5jYWxsKEF0LFB0WzBdLFB0WzFdLFB0WzJdKX1yZXR1cm4gdnQuYXBwbHkoQXQsUHQpfWZ1bmN0aW9uIHYyKHZ0LEF0LFB0LGp0KXtmb3IodmFyIFF0PS0xLGFlPXZ0PT1udWxsPzA6dnQubGVuZ3RoOysrUXQ8YWU7KXt2YXIgTGU9dnRbUXRdO0F0KGp0LExlLFB0KExlKSx2dCl9cmV0dXJuIGp0fWZ1bmN0aW9uIHRyKHZ0LEF0KXtmb3IodmFyIFB0PS0xLGp0PXZ0PT1udWxsPzA6dnQubGVuZ3RoOysrUHQ8anQmJkF0KHZ0W1B0XSxQdCx2dCkhPT0hMTspO3JldHVybiB2dH1mdW5jdGlvbiBwMih2dCxBdCl7Zm9yKHZhciBQdD12dD09bnVsbD8wOnZ0Lmxlbmd0aDtQdC0tJiZBdCh2dFtQdF0sUHQsdnQpIT09ITE7KTtyZXR1cm4gdnR9ZnVuY3Rpb24gQ2wodnQsQXQpe2Zvcih2YXIgUHQ9LTEsanQ9dnQ9PW51bGw/MDp2dC5sZW5ndGg7KytQdDxqdDspaWYoIUF0KHZ0W1B0XSxQdCx2dCkpcmV0dXJuITE7cmV0dXJuITB9ZnVuY3Rpb24gRHIodnQsQXQpe2Zvcih2YXIgUHQ9LTEsanQ9dnQ9PW51bGw/MDp2dC5sZW5ndGgsUXQ9MCxhZT1bXTsrK1B0PGp0Oyl7dmFyIExlPXZ0W1B0XTtBdChMZSxQdCx2dCkmJihhZVtRdCsrXT1MZSl9cmV0dXJuIGFlfWZ1bmN0aW9uIGhpKHZ0LEF0KXt2YXIgUHQ9dnQ9PW51bGw/MDp2dC5sZW5ndGg7cmV0dXJuISFQdCYmdm4odnQsQXQsMCk+LTF9ZnVuY3Rpb24gQXModnQsQXQsUHQpe2Zvcih2YXIganQ9LTEsUXQ9dnQ9PW51bGw/MDp2dC5sZW5ndGg7KytqdDxRdDspaWYoUHQoQXQsdnRbanRdKSlyZXR1cm4hMDtyZXR1cm4hMX1mdW5jdGlvbiB5ZSh2dCxBdCl7Zm9yKHZhciBQdD0tMSxqdD12dD09bnVsbD8wOnZ0Lmxlbmd0aCxRdD1BcnJheShqdCk7KytQdDxqdDspUXRbUHRdPUF0KHZ0W1B0XSxQdCx2dCk7cmV0dXJuIFF0fWZ1bmN0aW9uIHdyKHZ0LEF0KXtmb3IodmFyIFB0PS0xLGp0PUF0Lmxlbmd0aCxRdD12dC5sZW5ndGg7KytQdDxqdDspdnRbUXQrUHRdPUF0W1B0XTtyZXR1cm4gdnR9ZnVuY3Rpb24gQ3ModnQsQXQsUHQsanQpe3ZhciBRdD0tMSxhZT12dD09bnVsbD8wOnZ0Lmxlbmd0aDtmb3IoanQmJmFlJiYoUHQ9dnRbKytRdF0pOysrUXQ8YWU7KVB0PUF0KFB0LHZ0W1F0XSxRdCx2dCk7cmV0dXJuIFB0fWZ1bmN0aW9uIG0yKHZ0LEF0LFB0LGp0KXt2YXIgUXQ9dnQ9PW51bGw/MDp2dC5sZW5ndGg7Zm9yKGp0JiZRdCYmKFB0PXZ0Wy0tUXRdKTtRdC0tOylQdD1BdChQdCx2dFtRdF0sUXQsdnQpO3JldHVybiBQdH1mdW5jdGlvbiBScyh2dCxBdCl7Zm9yKHZhciBQdD0tMSxqdD12dD09bnVsbD8wOnZ0Lmxlbmd0aDsrK1B0PGp0OylpZihBdCh2dFtQdF0sUHQsdnQpKXJldHVybiEwO3JldHVybiExfXZhciB5Mj1JcygibGVuZ3RoIik7ZnVuY3Rpb24geDIodnQpe3JldHVybiB2dC5zcGxpdCgiIil9ZnVuY3Rpb24gTzIodnQpe3JldHVybiB2dC5tYXRjaChDeSl8fFtdfWZ1bmN0aW9uIFJsKHZ0LEF0LFB0KXt2YXIganQ7cmV0dXJuIFB0KHZ0LGZ1bmN0aW9uKFF0LGFlLExlKXtpZihBdChRdCxhZSxMZSkpcmV0dXJuIGp0PWFlLCExfSksanR9ZnVuY3Rpb24gZGkodnQsQXQsUHQsanQpe2Zvcih2YXIgUXQ9dnQubGVuZ3RoLGFlPVB0KyhqdD8xOi0xKTtqdD9hZS0tOisrYWU8UXQ7KWlmKEF0KHZ0W2FlXSxhZSx2dCkpcmV0dXJuIGFlO3JldHVybi0xfWZ1bmN0aW9uIHZuKHZ0LEF0LFB0KXtyZXR1cm4gQXQ9PT1BdD9EMih2dCxBdCxQdCk6ZGkodnQsSWwsUHQpfWZ1bmN0aW9uIEUyKHZ0LEF0LFB0LGp0KXtmb3IodmFyIFF0PVB0LTEsYWU9dnQubGVuZ3RoOysrUXQ8YWU7KWlmKGp0KHZ0W1F0XSxBdCkpcmV0dXJuIFF0O3JldHVybi0xfWZ1bmN0aW9uIElsKHZ0KXtyZXR1cm4gdnQhPT12dH1mdW5jdGlvbiBMbCh2dCxBdCl7dmFyIFB0PXZ0PT1udWxsPzA6dnQubGVuZ3RoO3JldHVybiBQdD9Ecyh2dCxBdCkvUHQ6R31mdW5jdGlvbiBJcyh2dCl7cmV0dXJuIGZ1bmN0aW9uKEF0KXtyZXR1cm4gQXQ9PW51bGw/dDpBdFt2dF19fWZ1bmN0aW9uIExzKHZ0KXtyZXR1cm4gZnVuY3Rpb24oQXQpe3JldHVybiB2dD09bnVsbD90OnZ0W0F0XX19ZnVuY3Rpb24gRGwodnQsQXQsUHQsanQsUXQpe3JldHVybiBRdCh2dCxmdW5jdGlvbihhZSxMZSxoZSl7UHQ9anQ/KGp0PSExLGFlKTpBdChQdCxhZSxMZSxoZSl9KSxQdH1mdW5jdGlvbiBNMih2dCxBdCl7dmFyIFB0PXZ0Lmxlbmd0aDtmb3IodnQuc29ydChBdCk7UHQtLTspdnRbUHRdPXZ0W1B0XS52YWx1ZTtyZXR1cm4gdnR9ZnVuY3Rpb24gRHModnQsQXQpe2Zvcih2YXIgUHQsanQ9LTEsUXQ9dnQubGVuZ3RoOysranQ8UXQ7KXt2YXIgYWU9QXQodnRbanRdKTthZSE9PXQmJihQdD1QdD09PXQ/YWU6UHQrYWUpfXJldHVybiBQdH1mdW5jdGlvbiB3cyh2dCxBdCl7Zm9yKHZhciBQdD0tMSxqdD1BcnJheSh2dCk7KytQdDx2dDspanRbUHRdPUF0KFB0KTtyZXR1cm4ganR9ZnVuY3Rpb24gUzIodnQsQXQpe3JldHVybiB5ZShBdCxmdW5jdGlvbihQdCl7cmV0dXJuW1B0LHZ0W1B0XV19KX1mdW5jdGlvbiB3bCh2dCl7cmV0dXJuIHZ0JiZ2dC5zbGljZSgwLEZsKHZ0KSsxKS5yZXBsYWNlKHhzLCIiKX1mdW5jdGlvbiBaZSh2dCl7cmV0dXJuIGZ1bmN0aW9uKEF0KXtyZXR1cm4gdnQoQXQpfX1mdW5jdGlvbiBOcyh2dCxBdCl7cmV0dXJuIHllKEF0LGZ1bmN0aW9uKFB0KXtyZXR1cm4gdnRbUHRdfSl9ZnVuY3Rpb24gTG4odnQsQXQpe3JldHVybiB2dC5oYXMoQXQpfWZ1bmN0aW9uIE5sKHZ0LEF0KXtmb3IodmFyIFB0PS0xLGp0PXZ0Lmxlbmd0aDsrK1B0PGp0JiZ2bihBdCx2dFtQdF0sMCk+LTE7KTtyZXR1cm4gUHR9ZnVuY3Rpb24gQmwodnQsQXQpe2Zvcih2YXIgUHQ9dnQubGVuZ3RoO1B0LS0mJnZuKEF0LHZ0W1B0XSwwKT4tMTspO3JldHVybiBQdH1mdW5jdGlvbiBUMih2dCxBdCl7Zm9yKHZhciBQdD12dC5sZW5ndGgsanQ9MDtQdC0tOyl2dFtQdF09PT1BdCYmKytqdDtyZXR1cm4ganR9dmFyIFAyPUxzKGwyKSxiMj1Mcyh1Mik7ZnVuY3Rpb24gQTIodnQpe3JldHVybiJcXCIrYzJbdnRdfWZ1bmN0aW9uIEMyKHZ0LEF0KXtyZXR1cm4gdnQ9PW51bGw/dDp2dFtBdF19ZnVuY3Rpb24gcG4odnQpe3JldHVybiBpMi50ZXN0KHZ0KX1mdW5jdGlvbiBSMih2dCl7cmV0dXJuIHMyLnRlc3QodnQpfWZ1bmN0aW9uIEkyKHZ0KXtmb3IodmFyIEF0LFB0PVtdOyEoQXQ9dnQubmV4dCgpKS5kb25lOylQdC5wdXNoKEF0LnZhbHVlKTtyZXR1cm4gUHR9ZnVuY3Rpb24gQnModnQpe3ZhciBBdD0tMSxQdD1BcnJheSh2dC5zaXplKTtyZXR1cm4gdnQuZm9yRWFjaChmdW5jdGlvbihqdCxRdCl7UHRbKytBdF09W1F0LGp0XX0pLFB0fWZ1bmN0aW9uIFdsKHZ0LEF0KXtyZXR1cm4gZnVuY3Rpb24oUHQpe3JldHVybiB2dChBdChQdCkpfX1mdW5jdGlvbiBOcih2dCxBdCl7Zm9yKHZhciBQdD0tMSxqdD12dC5sZW5ndGgsUXQ9MCxhZT1bXTsrK1B0PGp0Oyl7dmFyIExlPXZ0W1B0XTsoTGU9PT1BdHx8TGU9PT1FKSYmKHZ0W1B0XT1FLGFlW1F0KytdPVB0KX1yZXR1cm4gYWV9ZnVuY3Rpb24gZ2kodnQpe3ZhciBBdD0tMSxQdD1BcnJheSh2dC5zaXplKTtyZXR1cm4gdnQuZm9yRWFjaChmdW5jdGlvbihqdCl7UHRbKytBdF09anR9KSxQdH1mdW5jdGlvbiBMMih2dCl7dmFyIEF0PS0xLFB0PUFycmF5KHZ0LnNpemUpO3JldHVybiB2dC5mb3JFYWNoKGZ1bmN0aW9uKGp0KXtQdFsrK0F0XT1banQsanRdfSksUHR9ZnVuY3Rpb24gRDIodnQsQXQsUHQpe2Zvcih2YXIganQ9UHQtMSxRdD12dC5sZW5ndGg7KytqdDxRdDspaWYodnRbanRdPT09QXQpcmV0dXJuIGp0O3JldHVybi0xfWZ1bmN0aW9uIHcyKHZ0LEF0LFB0KXtmb3IodmFyIGp0PVB0KzE7anQtLTspaWYodnRbanRdPT09QXQpcmV0dXJuIGp0O3JldHVybiBqdH1mdW5jdGlvbiBtbih2dCl7cmV0dXJuIHBuKHZ0KT9CMih2dCk6eTIodnQpfWZ1bmN0aW9uIHVyKHZ0KXtyZXR1cm4gcG4odnQpP1cyKHZ0KTp4Mih2dCl9ZnVuY3Rpb24gRmwodnQpe2Zvcih2YXIgQXQ9dnQubGVuZ3RoO0F0LS0mJlR5LnRlc3QodnQuY2hhckF0KEF0KSk7KTtyZXR1cm4gQXR9dmFyIE4yPUxzKGYyKTtmdW5jdGlvbiBCMih2dCl7Zm9yKHZhciBBdD1Ucy5sYXN0SW5kZXg9MDtUcy50ZXN0KHZ0KTspKytBdDtyZXR1cm4gQXR9ZnVuY3Rpb24gVzIodnQpe3JldHVybiB2dC5tYXRjaChUcyl8fFtdfWZ1bmN0aW9uIEYyKHZ0KXtyZXR1cm4gdnQubWF0Y2gobjIpfHxbXX12YXIgajI9ZnVuY3Rpb24gdnQoQXQpe0F0PUF0PT1udWxsP05lOnluLmRlZmF1bHRzKE5lLk9iamVjdCgpLEF0LHluLnBpY2soTmUsbzIpKTt2YXIgUHQ9QXQuQXJyYXksanQ9QXQuRGF0ZSxRdD1BdC5FcnJvcixhZT1BdC5GdW5jdGlvbixMZT1BdC5NYXRoLGhlPUF0Lk9iamVjdCxXcz1BdC5SZWdFeHAsVTI9QXQuU3RyaW5nLGVyPUF0LlR5cGVFcnJvcix2aT1QdC5wcm90b3R5cGUsejI9YWUucHJvdG90eXBlLHhuPWhlLnByb3RvdHlwZSxwaT1BdFsiX19jb3JlLWpzX3NoYXJlZF9fIl0sbWk9ejIudG9TdHJpbmcsZmU9eG4uaGFzT3duUHJvcGVydHksJDI9MCxqbD1mdW5jdGlvbigpe3ZhciByPS9bXi5dKyQvLmV4ZWMocGkmJnBpLmtleXMmJnBpLmtleXMuSUVfUFJPVE98fCIiKTtyZXR1cm4gcj8iU3ltYm9sKHNyYylfMS4iK3I6IiJ9KCkseWk9eG4udG9TdHJpbmcsRzI9bWkuY2FsbChoZSksSzI9TmUuXyxIMj1XcygiXiIrbWkuY2FsbChmZSkucmVwbGFjZSh5cywiXFwkJiIpLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFwoKXwgZm9yIC4rPyg/PVxcXF0pL2csIiQxLio/IikrIiQiKSx4aT1FbD9BdC5CdWZmZXI6dCxCcj1BdC5TeW1ib2wsT2k9QXQuVWludDhBcnJheSxVbD14aT94aS5hbGxvY1Vuc2FmZTp0LEVpPVdsKGhlLmdldFByb3RvdHlwZU9mLGhlKSx6bD1oZS5jcmVhdGUsJGw9eG4ucHJvcGVydHlJc0VudW1lcmFibGUsTWk9dmkuc3BsaWNlLEdsPUJyP0JyLmlzQ29uY2F0U3ByZWFkYWJsZTp0LERuPUJyP0JyLml0ZXJhdG9yOnQsWHI9QnI/QnIudG9TdHJpbmdUYWc6dCxTaT1mdW5jdGlvbigpe3RyeXt2YXIgcj1xcihoZSwiZGVmaW5lUHJvcGVydHkiKTtyZXR1cm4gcih7fSwiIix7fSkscn1jYXRjaHt9fSgpLFkyPUF0LmNsZWFyVGltZW91dCE9PU5lLmNsZWFyVGltZW91dCYmQXQuY2xlYXJUaW1lb3V0LFYyPWp0JiZqdC5ub3chPT1OZS5EYXRlLm5vdyYmanQubm93LFgyPUF0LnNldFRpbWVvdXQhPT1OZS5zZXRUaW1lb3V0JiZBdC5zZXRUaW1lb3V0LFRpPUxlLmNlaWwsUGk9TGUuZmxvb3IsRnM9aGUuZ2V0T3duUHJvcGVydHlTeW1ib2xzLFoyPXhpP3hpLmlzQnVmZmVyOnQsS2w9QXQuaXNGaW5pdGUsSjI9dmkuam9pbixRMj1XbChoZS5rZXlzLGhlKSxEZT1MZS5tYXgsV2U9TGUubWluLGsyPWp0Lm5vdyxxMj1BdC5wYXJzZUludCxIbD1MZS5yYW5kb20sXzI9dmkucmV2ZXJzZSxqcz1xcihBdCwiRGF0YVZpZXciKSx3bj1xcihBdCwiTWFwIiksVXM9cXIoQXQsIlByb21pc2UiKSxPbj1xcihBdCwiU2V0IiksTm49cXIoQXQsIldlYWtNYXAiKSxCbj1xcihoZSwiY3JlYXRlIiksYmk9Tm4mJm5ldyBObixFbj17fSx0eD1fcihqcyksZXg9X3Iod24pLHJ4PV9yKFVzKSxueD1fcihPbiksaXg9X3IoTm4pLEFpPUJyP0JyLnByb3RvdHlwZTp0LFduPUFpP0FpLnZhbHVlT2Y6dCxZbD1BaT9BaS50b1N0cmluZzp0O2Z1bmN0aW9uIHEocil7aWYoUGUocikmJiFrdChyKSYmIShyIGluc3RhbmNlb2YgcmUpKXtpZihyIGluc3RhbmNlb2YgcnIpcmV0dXJuIHI7aWYoZmUuY2FsbChyLCJfX3dyYXBwZWRfXyIpKXJldHVybiBWdShyKX1yZXR1cm4gbmV3IHJyKHIpfXZhciBNbj1mdW5jdGlvbigpe2Z1bmN0aW9uIHIoKXt9cmV0dXJuIGZ1bmN0aW9uKG8pe2lmKCFNZShvKSlyZXR1cm57fTtpZih6bClyZXR1cm4gemwobyk7ci5wcm90b3R5cGU9bzt2YXIgQz1uZXcgcjtyZXR1cm4gci5wcm90b3R5cGU9dCxDfX0oKTtmdW5jdGlvbiBDaSgpe31mdW5jdGlvbiBycihyLG8pe3RoaXMuX193cmFwcGVkX189cix0aGlzLl9fYWN0aW9uc19fPVtdLHRoaXMuX19jaGFpbl9fPSEhbyx0aGlzLl9faW5kZXhfXz0wLHRoaXMuX192YWx1ZXNfXz10fXEudGVtcGxhdGVTZXR0aW5ncz17ZXNjYXBlOnNlLGV2YWx1YXRlOlZlLGludGVycG9sYXRlOkxyLHZhcmlhYmxlOiIiLGltcG9ydHM6e186cX19LHEucHJvdG90eXBlPUNpLnByb3RvdHlwZSxxLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1xLHJyLnByb3RvdHlwZT1NbihDaS5wcm90b3R5cGUpLHJyLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1ycjtmdW5jdGlvbiByZShyKXt0aGlzLl9fd3JhcHBlZF9fPXIsdGhpcy5fX2FjdGlvbnNfXz1bXSx0aGlzLl9fZGlyX189MSx0aGlzLl9fZmlsdGVyZWRfXz0hMSx0aGlzLl9faXRlcmF0ZWVzX189W10sdGhpcy5fX3Rha2VDb3VudF9fPVksdGhpcy5fX3ZpZXdzX189W119ZnVuY3Rpb24gc3goKXt2YXIgcj1uZXcgcmUodGhpcy5fX3dyYXBwZWRfXyk7cmV0dXJuIHIuX19hY3Rpb25zX189R2UodGhpcy5fX2FjdGlvbnNfXyksci5fX2Rpcl9fPXRoaXMuX19kaXJfXyxyLl9fZmlsdGVyZWRfXz10aGlzLl9fZmlsdGVyZWRfXyxyLl9faXRlcmF0ZWVzX189R2UodGhpcy5fX2l0ZXJhdGVlc19fKSxyLl9fdGFrZUNvdW50X189dGhpcy5fX3Rha2VDb3VudF9fLHIuX192aWV3c19fPUdlKHRoaXMuX192aWV3c19fKSxyfWZ1bmN0aW9uIG94KCl7aWYodGhpcy5fX2ZpbHRlcmVkX18pe3ZhciByPW5ldyByZSh0aGlzKTtyLl9fZGlyX189LTEsci5fX2ZpbHRlcmVkX189ITB9ZWxzZSByPXRoaXMuY2xvbmUoKSxyLl9fZGlyX18qPS0xO3JldHVybiByfWZ1bmN0aW9uIGF4KCl7dmFyIHI9dGhpcy5fX3dyYXBwZWRfXy52YWx1ZSgpLG89dGhpcy5fX2Rpcl9fLEM9a3Qociksej1vPDAsWD1DP3IubGVuZ3RoOjAsZXQ9eE8oMCxYLHRoaXMuX192aWV3c19fKSxsdD1ldC5zdGFydCxmdD1ldC5lbmQseXQ9ZnQtbHQsUnQ9ej9mdDpsdC0xLEl0PXRoaXMuX19pdGVyYXRlZXNfXyx3dD1JdC5sZW5ndGgsV3Q9MCxVdD1XZSh5dCx0aGlzLl9fdGFrZUNvdW50X18pO2lmKCFDfHwheiYmWD09eXQmJlV0PT15dClyZXR1cm4gdnUocix0aGlzLl9fYWN0aW9uc19fKTt2YXIgWHQ9W107dDpmb3IoO3l0LS0mJld0PFV0Oyl7UnQrPW87Zm9yKHZhciBfdD0tMSxadD1yW1J0XTsrK190PHd0Oyl7dmFyIGVlPUl0W190XSxuZT1lZS5pdGVyYXRlZSxrZT1lZS50eXBlLHplPW5lKFp0KTtpZihrZT09ailadD16ZTtlbHNlIGlmKCF6ZSl7aWYoa2U9PUkpY29udGludWUgdDticmVhayB0fX1YdFtXdCsrXT1adH1yZXR1cm4gWHR9cmUucHJvdG90eXBlPU1uKENpLnByb3RvdHlwZSkscmUucHJvdG90eXBlLmNvbnN0cnVjdG9yPXJlO2Z1bmN0aW9uIFpyKHIpe3ZhciBvPS0xLEM9cj09bnVsbD8wOnIubGVuZ3RoO2Zvcih0aGlzLmNsZWFyKCk7KytvPEM7KXt2YXIgej1yW29dO3RoaXMuc2V0KHpbMF0selsxXSl9fWZ1bmN0aW9uIGx4KCl7dGhpcy5fX2RhdGFfXz1Cbj9CbihudWxsKTp7fSx0aGlzLnNpemU9MH1mdW5jdGlvbiB1eChyKXt2YXIgbz10aGlzLmhhcyhyKSYmZGVsZXRlIHRoaXMuX19kYXRhX19bcl07cmV0dXJuIHRoaXMuc2l6ZS09bz8xOjAsb31mdW5jdGlvbiBmeChyKXt2YXIgbz10aGlzLl9fZGF0YV9fO2lmKEJuKXt2YXIgQz1vW3JdO3JldHVybiBDPT09YT90OkN9cmV0dXJuIGZlLmNhbGwobyxyKT9vW3JdOnR9ZnVuY3Rpb24gY3gocil7dmFyIG89dGhpcy5fX2RhdGFfXztyZXR1cm4gQm4/b1tyXSE9PXQ6ZmUuY2FsbChvLHIpfWZ1bmN0aW9uIGh4KHIsbyl7dmFyIEM9dGhpcy5fX2RhdGFfXztyZXR1cm4gdGhpcy5zaXplKz10aGlzLmhhcyhyKT8wOjEsQ1tyXT1CbiYmbz09PXQ/YTpvLHRoaXN9WnIucHJvdG90eXBlLmNsZWFyPWx4LFpyLnByb3RvdHlwZS5kZWxldGU9dXgsWnIucHJvdG90eXBlLmdldD1meCxaci5wcm90b3R5cGUuaGFzPWN4LFpyLnByb3RvdHlwZS5zZXQ9aHg7ZnVuY3Rpb24geHIocil7dmFyIG89LTEsQz1yPT1udWxsPzA6ci5sZW5ndGg7Zm9yKHRoaXMuY2xlYXIoKTsrK288Qzspe3ZhciB6PXJbb107dGhpcy5zZXQoelswXSx6WzFdKX19ZnVuY3Rpb24gZHgoKXt0aGlzLl9fZGF0YV9fPVtdLHRoaXMuc2l6ZT0wfWZ1bmN0aW9uIGd4KHIpe3ZhciBvPXRoaXMuX19kYXRhX18sQz1SaShvLHIpO2lmKEM8MClyZXR1cm4hMTt2YXIgej1vLmxlbmd0aC0xO3JldHVybiBDPT16P28ucG9wKCk6TWkuY2FsbChvLEMsMSksLS10aGlzLnNpemUsITB9ZnVuY3Rpb24gdngocil7dmFyIG89dGhpcy5fX2RhdGFfXyxDPVJpKG8scik7cmV0dXJuIEM8MD90Om9bQ11bMV19ZnVuY3Rpb24gcHgocil7cmV0dXJuIFJpKHRoaXMuX19kYXRhX18scik+LTF9ZnVuY3Rpb24gbXgocixvKXt2YXIgQz10aGlzLl9fZGF0YV9fLHo9UmkoQyxyKTtyZXR1cm4gejwwPygrK3RoaXMuc2l6ZSxDLnB1c2goW3Isb10pKTpDW3pdWzFdPW8sdGhpc314ci5wcm90b3R5cGUuY2xlYXI9ZHgseHIucHJvdG90eXBlLmRlbGV0ZT1neCx4ci5wcm90b3R5cGUuZ2V0PXZ4LHhyLnByb3RvdHlwZS5oYXM9cHgseHIucHJvdG90eXBlLnNldD1teDtmdW5jdGlvbiBPcihyKXt2YXIgbz0tMSxDPXI9PW51bGw/MDpyLmxlbmd0aDtmb3IodGhpcy5jbGVhcigpOysrbzxDOyl7dmFyIHo9cltvXTt0aGlzLnNldCh6WzBdLHpbMV0pfX1mdW5jdGlvbiB5eCgpe3RoaXMuc2l6ZT0wLHRoaXMuX19kYXRhX189e2hhc2g6bmV3IFpyLG1hcDpuZXcod258fHhyKSxzdHJpbmc6bmV3IFpyfX1mdW5jdGlvbiB4eChyKXt2YXIgbz0kaSh0aGlzLHIpLmRlbGV0ZShyKTtyZXR1cm4gdGhpcy5zaXplLT1vPzE6MCxvfWZ1bmN0aW9uIE94KHIpe3JldHVybiAkaSh0aGlzLHIpLmdldChyKX1mdW5jdGlvbiBFeChyKXtyZXR1cm4gJGkodGhpcyxyKS5oYXMocil9ZnVuY3Rpb24gTXgocixvKXt2YXIgQz0kaSh0aGlzLHIpLHo9Qy5zaXplO3JldHVybiBDLnNldChyLG8pLHRoaXMuc2l6ZSs9Qy5zaXplPT16PzA6MSx0aGlzfU9yLnByb3RvdHlwZS5jbGVhcj15eCxPci5wcm90b3R5cGUuZGVsZXRlPXh4LE9yLnByb3RvdHlwZS5nZXQ9T3gsT3IucHJvdG90eXBlLmhhcz1FeCxPci5wcm90b3R5cGUuc2V0PU14O2Z1bmN0aW9uIEpyKHIpe3ZhciBvPS0xLEM9cj09bnVsbD8wOnIubGVuZ3RoO2Zvcih0aGlzLl9fZGF0YV9fPW5ldyBPcjsrK288QzspdGhpcy5hZGQocltvXSl9ZnVuY3Rpb24gU3gocil7cmV0dXJuIHRoaXMuX19kYXRhX18uc2V0KHIsYSksdGhpc31mdW5jdGlvbiBUeChyKXtyZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXMocil9SnIucHJvdG90eXBlLmFkZD1Kci5wcm90b3R5cGUucHVzaD1TeCxKci5wcm90b3R5cGUuaGFzPVR4O2Z1bmN0aW9uIGZyKHIpe3ZhciBvPXRoaXMuX19kYXRhX189bmV3IHhyKHIpO3RoaXMuc2l6ZT1vLnNpemV9ZnVuY3Rpb24gUHgoKXt0aGlzLl9fZGF0YV9fPW5ldyB4cix0aGlzLnNpemU9MH1mdW5jdGlvbiBieChyKXt2YXIgbz10aGlzLl9fZGF0YV9fLEM9by5kZWxldGUocik7cmV0dXJuIHRoaXMuc2l6ZT1vLnNpemUsQ31mdW5jdGlvbiBBeChyKXtyZXR1cm4gdGhpcy5fX2RhdGFfXy5nZXQocil9ZnVuY3Rpb24gQ3gocil7cmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKHIpfWZ1bmN0aW9uIFJ4KHIsbyl7dmFyIEM9dGhpcy5fX2RhdGFfXztpZihDIGluc3RhbmNlb2YgeHIpe3ZhciB6PUMuX19kYXRhX187aWYoIXdufHx6Lmxlbmd0aDxpLTEpcmV0dXJuIHoucHVzaChbcixvXSksdGhpcy5zaXplPSsrQy5zaXplLHRoaXM7Qz10aGlzLl9fZGF0YV9fPW5ldyBPcih6KX1yZXR1cm4gQy5zZXQocixvKSx0aGlzLnNpemU9Qy5zaXplLHRoaXN9ZnIucHJvdG90eXBlLmNsZWFyPVB4LGZyLnByb3RvdHlwZS5kZWxldGU9YngsZnIucHJvdG90eXBlLmdldD1BeCxmci5wcm90b3R5cGUuaGFzPUN4LGZyLnByb3RvdHlwZS5zZXQ9Ung7ZnVuY3Rpb24gVmwocixvKXt2YXIgQz1rdChyKSx6PSFDJiZ0bihyKSxYPSFDJiYheiYmenIociksZXQ9IUMmJiF6JiYhWCYmYm4ociksbHQ9Q3x8enx8WHx8ZXQsZnQ9bHQ/d3Moci5sZW5ndGgsVTIpOltdLHl0PWZ0Lmxlbmd0aDtmb3IodmFyIFJ0IGluIHIpKG98fGZlLmNhbGwocixSdCkpJiYhKGx0JiYoUnQ9PSJsZW5ndGgifHxYJiYoUnQ9PSJvZmZzZXQifHxSdD09InBhcmVudCIpfHxldCYmKFJ0PT0iYnVmZmVyInx8UnQ9PSJieXRlTGVuZ3RoInx8UnQ9PSJieXRlT2Zmc2V0Iil8fFRyKFJ0LHl0KSkpJiZmdC5wdXNoKFJ0KTtyZXR1cm4gZnR9ZnVuY3Rpb24gWGwocil7dmFyIG89ci5sZW5ndGg7cmV0dXJuIG8/cltRcygwLG8tMSldOnR9ZnVuY3Rpb24gSXgocixvKXtyZXR1cm4gR2koR2UociksUXIobywwLHIubGVuZ3RoKSl9ZnVuY3Rpb24gTHgocil7cmV0dXJuIEdpKEdlKHIpKX1mdW5jdGlvbiB6cyhyLG8sQyl7KEMhPT10JiYhY3IocltvXSxDKXx8Qz09PXQmJiEobyBpbiByKSkmJkVyKHIsbyxDKX1mdW5jdGlvbiBGbihyLG8sQyl7dmFyIHo9cltvXTsoIShmZS5jYWxsKHIsbykmJmNyKHosQykpfHxDPT09dCYmIShvIGluIHIpKSYmRXIocixvLEMpfWZ1bmN0aW9uIFJpKHIsbyl7Zm9yKHZhciBDPXIubGVuZ3RoO0MtLTspaWYoY3IocltDXVswXSxvKSlyZXR1cm4gQztyZXR1cm4tMX1mdW5jdGlvbiBEeChyLG8sQyx6KXtyZXR1cm4gV3IocixmdW5jdGlvbihYLGV0LGx0KXtvKHosWCxDKFgpLGx0KX0pLHp9ZnVuY3Rpb24gWmwocixvKXtyZXR1cm4gciYmdnIobyx3ZShvKSxyKX1mdW5jdGlvbiB3eChyLG8pe3JldHVybiByJiZ2cihvLEhlKG8pLHIpfWZ1bmN0aW9uIEVyKHIsbyxDKXtvPT0iX19wcm90b19fIiYmU2k/U2kocixvLHtjb25maWd1cmFibGU6ITAsZW51bWVyYWJsZTohMCx2YWx1ZTpDLHdyaXRhYmxlOiEwfSk6cltvXT1DfWZ1bmN0aW9uICRzKHIsbyl7Zm9yKHZhciBDPS0xLHo9by5sZW5ndGgsWD1QdCh6KSxldD1yPT1udWxsOysrQzx6OylYW0NdPWV0P3Q6TW8ocixvW0NdKTtyZXR1cm4gWH1mdW5jdGlvbiBRcihyLG8sQyl7cmV0dXJuIHI9PT1yJiYoQyE9PXQmJihyPXI8PUM/cjpDKSxvIT09dCYmKHI9cj49bz9yOm8pKSxyfWZ1bmN0aW9uIG5yKHIsbyxDLHosWCxldCl7dmFyIGx0LGZ0PW8mcCx5dD1vJk8sUnQ9byZtO2lmKEMmJihsdD1YP0Mocix6LFgsZXQpOkMocikpLGx0IT09dClyZXR1cm4gbHQ7aWYoIU1lKHIpKXJldHVybiByO3ZhciBJdD1rdChyKTtpZihJdCl7aWYobHQ9RU8ociksIWZ0KXJldHVybiBHZShyLGx0KX1lbHNle3ZhciB3dD1GZShyKSxXdD13dD09dHR8fHd0PT1GO2lmKHpyKHIpKXJldHVybiB5dShyLGZ0KTtpZih3dD09V3x8d3Q9PWh0fHxXdCYmIVgpe2lmKGx0PXl0fHxXdD97fTpGdShyKSwhZnQpcmV0dXJuIHl0P2ZPKHIsd3gobHQscikpOnVPKHIsWmwobHQscikpfWVsc2V7aWYoIWdlW3d0XSlyZXR1cm4gWD9yOnt9O2x0PU1PKHIsd3QsZnQpfX1ldHx8KGV0PW5ldyBmcik7dmFyIFV0PWV0LmdldChyKTtpZihVdClyZXR1cm4gVXQ7ZXQuc2V0KHIsbHQpLGRmKHIpP3IuZm9yRWFjaChmdW5jdGlvbihadCl7bHQuYWRkKG5yKFp0LG8sQyxadCxyLGV0KSl9KTpjZihyKSYmci5mb3JFYWNoKGZ1bmN0aW9uKFp0LGVlKXtsdC5zZXQoZWUsbnIoWnQsbyxDLGVlLHIsZXQpKX0pO3ZhciBYdD1SdD95dD9hbzpvbzp5dD9IZTp3ZSxfdD1JdD90Olh0KHIpO3JldHVybiB0cihfdHx8cixmdW5jdGlvbihadCxlZSl7X3QmJihlZT1adCxadD1yW2VlXSksRm4obHQsZWUsbnIoWnQsbyxDLGVlLHIsZXQpKX0pLGx0fWZ1bmN0aW9uIE54KHIpe3ZhciBvPXdlKHIpO3JldHVybiBmdW5jdGlvbihDKXtyZXR1cm4gSmwoQyxyLG8pfX1mdW5jdGlvbiBKbChyLG8sQyl7dmFyIHo9Qy5sZW5ndGg7aWYocj09bnVsbClyZXR1cm4hejtmb3Iocj1oZShyKTt6LS07KXt2YXIgWD1DW3pdLGV0PW9bWF0sbHQ9cltYXTtpZihsdD09PXQmJiEoWCBpbiByKXx8IWV0KGx0KSlyZXR1cm4hMX1yZXR1cm4hMH1mdW5jdGlvbiBRbChyLG8sQyl7aWYodHlwZW9mIHIhPSJmdW5jdGlvbiIpdGhyb3cgbmV3IGVyKGgpO3JldHVybiBIbihmdW5jdGlvbigpe3IuYXBwbHkodCxDKX0sbyl9ZnVuY3Rpb24gam4ocixvLEMseil7dmFyIFg9LTEsZXQ9aGksbHQ9ITAsZnQ9ci5sZW5ndGgseXQ9W10sUnQ9by5sZW5ndGg7aWYoIWZ0KXJldHVybiB5dDtDJiYobz15ZShvLFplKEMpKSksej8oZXQ9QXMsbHQ9ITEpOm8ubGVuZ3RoPj1pJiYoZXQ9TG4sbHQ9ITEsbz1uZXcgSnIobykpO3Q6Zm9yKDsrK1g8ZnQ7KXt2YXIgSXQ9cltYXSx3dD1DPT1udWxsP0l0OkMoSXQpO2lmKEl0PXp8fEl0IT09MD9JdDowLGx0JiZ3dD09PXd0KXtmb3IodmFyIFd0PVJ0O1d0LS07KWlmKG9bV3RdPT09d3QpY29udGludWUgdDt5dC5wdXNoKEl0KX1lbHNlIGV0KG8sd3Qseil8fHl0LnB1c2goSXQpfXJldHVybiB5dH12YXIgV3I9U3UoZ3IpLGtsPVN1KEtzLCEwKTtmdW5jdGlvbiBCeChyLG8pe3ZhciBDPSEwO3JldHVybiBXcihyLGZ1bmN0aW9uKHosWCxldCl7cmV0dXJuIEM9ISFvKHosWCxldCksQ30pLEN9ZnVuY3Rpb24gSWkocixvLEMpe2Zvcih2YXIgej0tMSxYPXIubGVuZ3RoOysrejxYOyl7dmFyIGV0PXJbel0sbHQ9byhldCk7aWYobHQhPW51bGwmJihmdD09PXQ/bHQ9PT1sdCYmIVFlKGx0KTpDKGx0LGZ0KSkpdmFyIGZ0PWx0LHl0PWV0fXJldHVybiB5dH1mdW5jdGlvbiBXeChyLG8sQyx6KXt2YXIgWD1yLmxlbmd0aDtmb3IoQz1xdChDKSxDPDAmJihDPS1DPlg/MDpYK0MpLHo9ej09PXR8fHo+WD9YOnF0KHopLHo8MCYmKHorPVgpLHo9Qz56PzA6dmYoeik7Qzx6OylyW0MrK109bztyZXR1cm4gcn1mdW5jdGlvbiBxbChyLG8pe3ZhciBDPVtdO3JldHVybiBXcihyLGZ1bmN0aW9uKHosWCxldCl7byh6LFgsZXQpJiZDLnB1c2goeil9KSxDfWZ1bmN0aW9uIEJlKHIsbyxDLHosWCl7dmFyIGV0PS0xLGx0PXIubGVuZ3RoO2ZvcihDfHwoQz1UTyksWHx8KFg9W10pOysrZXQ8bHQ7KXt2YXIgZnQ9cltldF07bz4wJiZDKGZ0KT9vPjE/QmUoZnQsby0xLEMseixYKTp3cihYLGZ0KTp6fHwoWFtYLmxlbmd0aF09ZnQpfXJldHVybiBYfXZhciBHcz1UdSgpLF9sPVR1KCEwKTtmdW5jdGlvbiBncihyLG8pe3JldHVybiByJiZHcyhyLG8sd2UpfWZ1bmN0aW9uIEtzKHIsbyl7cmV0dXJuIHImJl9sKHIsbyx3ZSl9ZnVuY3Rpb24gTGkocixvKXtyZXR1cm4gRHIobyxmdW5jdGlvbihDKXtyZXR1cm4gUHIocltDXSl9KX1mdW5jdGlvbiBrcihyLG8pe289anIobyxyKTtmb3IodmFyIEM9MCx6PW8ubGVuZ3RoO3IhPW51bGwmJkM8ejspcj1yW3ByKG9bQysrXSldO3JldHVybiBDJiZDPT16P3I6dH1mdW5jdGlvbiB0dShyLG8sQyl7dmFyIHo9byhyKTtyZXR1cm4ga3Qocik/ejp3cih6LEMocikpfWZ1bmN0aW9uIGplKHIpe3JldHVybiByPT1udWxsP3I9PT10P3B0OlA6WHImJlhyIGluIGhlKHIpP3lPKHIpOkxPKHIpfWZ1bmN0aW9uIEhzKHIsbyl7cmV0dXJuIHI+b31mdW5jdGlvbiBGeChyLG8pe3JldHVybiByIT1udWxsJiZmZS5jYWxsKHIsbyl9ZnVuY3Rpb24gangocixvKXtyZXR1cm4gciE9bnVsbCYmbyBpbiBoZShyKX1mdW5jdGlvbiBVeChyLG8sQyl7cmV0dXJuIHI+PVdlKG8sQykmJnI8RGUobyxDKX1mdW5jdGlvbiBZcyhyLG8sQyl7Zm9yKHZhciB6PUM/QXM6aGksWD1yWzBdLmxlbmd0aCxldD1yLmxlbmd0aCxsdD1ldCxmdD1QdChldCkseXQ9MS8wLFJ0PVtdO2x0LS07KXt2YXIgSXQ9cltsdF07bHQmJm8mJihJdD15ZShJdCxaZShvKSkpLHl0PVdlKEl0Lmxlbmd0aCx5dCksZnRbbHRdPSFDJiYob3x8WD49MTIwJiZJdC5sZW5ndGg+PTEyMCk/bmV3IEpyKGx0JiZJdCk6dH1JdD1yWzBdO3ZhciB3dD0tMSxXdD1mdFswXTt0OmZvcig7Kyt3dDxYJiZSdC5sZW5ndGg8eXQ7KXt2YXIgVXQ9SXRbd3RdLFh0PW8/byhVdCk6VXQ7aWYoVXQ9Q3x8VXQhPT0wP1V0OjAsIShXdD9MbihXdCxYdCk6eihSdCxYdCxDKSkpe2ZvcihsdD1ldDstLWx0Oyl7dmFyIF90PWZ0W2x0XTtpZighKF90P0xuKF90LFh0KTp6KHJbbHRdLFh0LEMpKSljb250aW51ZSB0fVd0JiZXdC5wdXNoKFh0KSxSdC5wdXNoKFV0KX19cmV0dXJuIFJ0fWZ1bmN0aW9uIHp4KHIsbyxDLHope3JldHVybiBncihyLGZ1bmN0aW9uKFgsZXQsbHQpe28oeixDKFgpLGV0LGx0KX0pLHp9ZnVuY3Rpb24gVW4ocixvLEMpe289anIobyxyKSxyPSR1KHIsbyk7dmFyIHo9cj09bnVsbD9yOnJbcHIoc3IobykpXTtyZXR1cm4gej09bnVsbD90OlhlKHoscixDKX1mdW5jdGlvbiBldShyKXtyZXR1cm4gUGUocikmJmplKHIpPT1odH1mdW5jdGlvbiAkeChyKXtyZXR1cm4gUGUocikmJmplKHIpPT1kdH1mdW5jdGlvbiBHeChyKXtyZXR1cm4gUGUocikmJmplKHIpPT1VfWZ1bmN0aW9uIHpuKHIsbyxDLHosWCl7cmV0dXJuIHI9PT1vPyEwOnI9PW51bGx8fG89PW51bGx8fCFQZShyKSYmIVBlKG8pP3IhPT1yJiZvIT09bzpLeChyLG8sQyx6LHpuLFgpfWZ1bmN0aW9uIEt4KHIsbyxDLHosWCxldCl7dmFyIGx0PWt0KHIpLGZ0PWt0KG8pLHl0PWx0P2l0OkZlKHIpLFJ0PWZ0P2l0OkZlKG8pO3l0PXl0PT1odD9XOnl0LFJ0PVJ0PT1odD9XOlJ0O3ZhciBJdD15dD09Vyx3dD1SdD09VyxXdD15dD09UnQ7aWYoV3QmJnpyKHIpKXtpZighenIobykpcmV0dXJuITE7bHQ9ITAsSXQ9ITF9aWYoV3QmJiFJdClyZXR1cm4gZXR8fChldD1uZXcgZnIpLGx0fHxibihyKT9OdShyLG8sQyx6LFgsZXQpOnBPKHIsbyx5dCxDLHosWCxldCk7aWYoIShDJmIpKXt2YXIgVXQ9SXQmJmZlLmNhbGwociwiX193cmFwcGVkX18iKSxYdD13dCYmZmUuY2FsbChvLCJfX3dyYXBwZWRfXyIpO2lmKFV0fHxYdCl7dmFyIF90PVV0P3IudmFsdWUoKTpyLFp0PVh0P28udmFsdWUoKTpvO3JldHVybiBldHx8KGV0PW5ldyBmciksWChfdCxadCxDLHosZXQpfX1yZXR1cm4gV3Q/KGV0fHwoZXQ9bmV3IGZyKSxtTyhyLG8sQyx6LFgsZXQpKTohMX1mdW5jdGlvbiBIeChyKXtyZXR1cm4gUGUocikmJkZlKHIpPT1IfWZ1bmN0aW9uIFZzKHIsbyxDLHope3ZhciBYPUMubGVuZ3RoLGV0PVgsbHQ9IXo7aWYocj09bnVsbClyZXR1cm4hZXQ7Zm9yKHI9aGUocik7WC0tOyl7dmFyIGZ0PUNbWF07aWYobHQmJmZ0WzJdP2Z0WzFdIT09cltmdFswXV06IShmdFswXWluIHIpKXJldHVybiExfWZvcig7KytYPGV0Oyl7ZnQ9Q1tYXTt2YXIgeXQ9ZnRbMF0sUnQ9clt5dF0sSXQ9ZnRbMV07aWYobHQmJmZ0WzJdKXtpZihSdD09PXQmJiEoeXQgaW4gcikpcmV0dXJuITF9ZWxzZXt2YXIgd3Q9bmV3IGZyO2lmKHopdmFyIFd0PXooUnQsSXQseXQscixvLHd0KTtpZighKFd0PT09dD96bihJdCxSdCxifE0seix3dCk6V3QpKXJldHVybiExfX1yZXR1cm4hMH1mdW5jdGlvbiBydShyKXtpZighTWUocil8fGJPKHIpKXJldHVybiExO3ZhciBvPVByKHIpP0gyOk55O3JldHVybiBvLnRlc3QoX3IocikpfWZ1bmN0aW9uIFl4KHIpe3JldHVybiBQZShyKSYmamUocik9PWt9ZnVuY3Rpb24gVngocil7cmV0dXJuIFBlKHIpJiZGZShyKT09bnR9ZnVuY3Rpb24gWHgocil7cmV0dXJuIFBlKHIpJiZaaShyLmxlbmd0aCkmJiEhcGVbamUocildfWZ1bmN0aW9uIG51KHIpe3JldHVybiB0eXBlb2Ygcj09ImZ1bmN0aW9uIj9yOnI9PW51bGw/WWU6dHlwZW9mIHI9PSJvYmplY3QiP2t0KHIpP291KHJbMF0sclsxXSk6c3Uocik6YmYocil9ZnVuY3Rpb24gWHMocil7aWYoIUtuKHIpKXJldHVybiBRMihyKTt2YXIgbz1bXTtmb3IodmFyIEMgaW4gaGUocikpZmUuY2FsbChyLEMpJiZDIT0iY29uc3RydWN0b3IiJiZvLnB1c2goQyk7cmV0dXJuIG99ZnVuY3Rpb24gWngocil7aWYoIU1lKHIpKXJldHVybiBJTyhyKTt2YXIgbz1LbihyKSxDPVtdO2Zvcih2YXIgeiBpbiByKXo9PSJjb25zdHJ1Y3RvciImJihvfHwhZmUuY2FsbChyLHopKXx8Qy5wdXNoKHopO3JldHVybiBDfWZ1bmN0aW9uIFpzKHIsbyl7cmV0dXJuIHI8b31mdW5jdGlvbiBpdShyLG8pe3ZhciBDPS0xLHo9S2Uocik/UHQoci5sZW5ndGgpOltdO3JldHVybiBXcihyLGZ1bmN0aW9uKFgsZXQsbHQpe3pbKytDXT1vKFgsZXQsbHQpfSksen1mdW5jdGlvbiBzdShyKXt2YXIgbz11byhyKTtyZXR1cm4gby5sZW5ndGg9PTEmJm9bMF1bMl0/VXUob1swXVswXSxvWzBdWzFdKTpmdW5jdGlvbihDKXtyZXR1cm4gQz09PXJ8fFZzKEMscixvKX19ZnVuY3Rpb24gb3UocixvKXtyZXR1cm4gY28ocikmJmp1KG8pP1V1KHByKHIpLG8pOmZ1bmN0aW9uKEMpe3ZhciB6PU1vKEMscik7cmV0dXJuIHo9PT10JiZ6PT09bz9TbyhDLHIpOnpuKG8seixifE0pfX1mdW5jdGlvbiBEaShyLG8sQyx6LFgpe3IhPT1vJiZHcyhvLGZ1bmN0aW9uKGV0LGx0KXtpZihYfHwoWD1uZXcgZnIpLE1lKGV0KSlKeChyLG8sbHQsQyxEaSx6LFgpO2Vsc2V7dmFyIGZ0PXo/eihnbyhyLGx0KSxldCxsdCsiIixyLG8sWCk6dDtmdD09PXQmJihmdD1ldCksenMocixsdCxmdCl9fSxIZSl9ZnVuY3Rpb24gSngocixvLEMseixYLGV0LGx0KXt2YXIgZnQ9Z28ocixDKSx5dD1nbyhvLEMpLFJ0PWx0LmdldCh5dCk7aWYoUnQpe3pzKHIsQyxSdCk7cmV0dXJufXZhciBJdD1ldD9ldChmdCx5dCxDKyIiLHIsbyxsdCk6dCx3dD1JdD09PXQ7aWYod3Qpe3ZhciBXdD1rdCh5dCksVXQ9IVd0JiZ6cih5dCksWHQ9IVd0JiYhVXQmJmJuKHl0KTtJdD15dCxXdHx8VXR8fFh0P2t0KGZ0KT9JdD1mdDpBZShmdCk/SXQ9R2UoZnQpOlV0Pyh3dD0hMSxJdD15dSh5dCwhMCkpOlh0Pyh3dD0hMSxJdD14dSh5dCwhMCkpOkl0PVtdOlluKHl0KXx8dG4oeXQpPyhJdD1mdCx0bihmdCk/SXQ9cGYoZnQpOighTWUoZnQpfHxQcihmdCkpJiYoSXQ9RnUoeXQpKSk6d3Q9ITF9d3QmJihsdC5zZXQoeXQsSXQpLFgoSXQseXQseixldCxsdCksbHQuZGVsZXRlKHl0KSksenMocixDLEl0KX1mdW5jdGlvbiBhdShyLG8pe3ZhciBDPXIubGVuZ3RoO2lmKEMpcmV0dXJuIG8rPW88MD9DOjAsVHIobyxDKT9yW29dOnR9ZnVuY3Rpb24gbHUocixvLEMpe28ubGVuZ3RoP289eWUobyxmdW5jdGlvbihldCl7cmV0dXJuIGt0KGV0KT9mdW5jdGlvbihsdCl7cmV0dXJuIGtyKGx0LGV0Lmxlbmd0aD09PTE/ZXRbMF06ZXQpfTpldH0pOm89W1llXTt2YXIgej0tMTtvPXllKG8sWmUoSHQoKSkpO3ZhciBYPWl1KHIsZnVuY3Rpb24oZXQsbHQsZnQpe3ZhciB5dD15ZShvLGZ1bmN0aW9uKFJ0KXtyZXR1cm4gUnQoZXQpfSk7cmV0dXJue2NyaXRlcmlhOnl0LGluZGV4Oisreix2YWx1ZTpldH19KTtyZXR1cm4gTTIoWCxmdW5jdGlvbihldCxsdCl7cmV0dXJuIGxPKGV0LGx0LEMpfSl9ZnVuY3Rpb24gUXgocixvKXtyZXR1cm4gdXUocixvLGZ1bmN0aW9uKEMseil7cmV0dXJuIFNvKHIseil9KX1mdW5jdGlvbiB1dShyLG8sQyl7Zm9yKHZhciB6PS0xLFg9by5sZW5ndGgsZXQ9e307Kyt6PFg7KXt2YXIgbHQ9b1t6XSxmdD1rcihyLGx0KTtDKGZ0LGx0KSYmJG4oZXQsanIobHQsciksZnQpfXJldHVybiBldH1mdW5jdGlvbiBreChyKXtyZXR1cm4gZnVuY3Rpb24obyl7cmV0dXJuIGtyKG8scil9fWZ1bmN0aW9uIEpzKHIsbyxDLHope3ZhciBYPXo/RTI6dm4sZXQ9LTEsbHQ9by5sZW5ndGgsZnQ9cjtmb3Iocj09PW8mJihvPUdlKG8pKSxDJiYoZnQ9eWUocixaZShDKSkpOysrZXQ8bHQ7KWZvcih2YXIgeXQ9MCxSdD1vW2V0XSxJdD1DP0MoUnQpOlJ0Oyh5dD1YKGZ0LEl0LHl0LHopKT4tMTspZnQhPT1yJiZNaS5jYWxsKGZ0LHl0LDEpLE1pLmNhbGwocix5dCwxKTtyZXR1cm4gcn1mdW5jdGlvbiBmdShyLG8pe2Zvcih2YXIgQz1yP28ubGVuZ3RoOjAsej1DLTE7Qy0tOyl7dmFyIFg9b1tDXTtpZihDPT16fHxYIT09ZXQpe3ZhciBldD1YO1RyKFgpP01pLmNhbGwocixYLDEpOl9zKHIsWCl9fXJldHVybiByfWZ1bmN0aW9uIFFzKHIsbyl7cmV0dXJuIHIrUGkoSGwoKSooby1yKzEpKX1mdW5jdGlvbiBxeChyLG8sQyx6KXtmb3IodmFyIFg9LTEsZXQ9RGUoVGkoKG8tcikvKEN8fDEpKSwwKSxsdD1QdChldCk7ZXQtLTspbHRbej9ldDorK1hdPXIscis9QztyZXR1cm4gbHR9ZnVuY3Rpb24ga3MocixvKXt2YXIgQz0iIjtpZighcnx8bzwxfHxvPl8pcmV0dXJuIEM7ZG8gbyUyJiYoQys9ciksbz1QaShvLzIpLG8mJihyKz1yKTt3aGlsZShvKTtyZXR1cm4gQ31mdW5jdGlvbiB0ZShyLG8pe3JldHVybiB2byh6dShyLG8sWWUpLHIrIiIpfWZ1bmN0aW9uIF94KHIpe3JldHVybiBYbChBbihyKSl9ZnVuY3Rpb24gdE8ocixvKXt2YXIgQz1BbihyKTtyZXR1cm4gR2koQyxRcihvLDAsQy5sZW5ndGgpKX1mdW5jdGlvbiAkbihyLG8sQyx6KXtpZighTWUocikpcmV0dXJuIHI7bz1qcihvLHIpO2Zvcih2YXIgWD0tMSxldD1vLmxlbmd0aCxsdD1ldC0xLGZ0PXI7ZnQhPW51bGwmJisrWDxldDspe3ZhciB5dD1wcihvW1hdKSxSdD1DO2lmKHl0PT09Il9fcHJvdG9fXyJ8fHl0PT09ImNvbnN0cnVjdG9yInx8eXQ9PT0icHJvdG90eXBlIilyZXR1cm4gcjtpZihYIT1sdCl7dmFyIEl0PWZ0W3l0XTtSdD16P3ooSXQseXQsZnQpOnQsUnQ9PT10JiYoUnQ9TWUoSXQpP0l0OlRyKG9bWCsxXSk/W106e30pfUZuKGZ0LHl0LFJ0KSxmdD1mdFt5dF19cmV0dXJuIHJ9dmFyIGN1PWJpP2Z1bmN0aW9uKHIsbyl7cmV0dXJuIGJpLnNldChyLG8pLHJ9OlllLGVPPVNpP2Z1bmN0aW9uKHIsbyl7cmV0dXJuIFNpKHIsInRvU3RyaW5nIix7Y29uZmlndXJhYmxlOiEwLGVudW1lcmFibGU6ITEsdmFsdWU6UG8obyksd3JpdGFibGU6ITB9KX06WWU7ZnVuY3Rpb24gck8ocil7cmV0dXJuIEdpKEFuKHIpKX1mdW5jdGlvbiBpcihyLG8sQyl7dmFyIHo9LTEsWD1yLmxlbmd0aDtvPDAmJihvPS1vPlg/MDpYK28pLEM9Qz5YP1g6QyxDPDAmJihDKz1YKSxYPW8+Qz8wOkMtbz4+PjAsbz4+Pj0wO2Zvcih2YXIgZXQ9UHQoWCk7Kyt6PFg7KWV0W3pdPXJbeitvXTtyZXR1cm4gZXR9ZnVuY3Rpb24gbk8ocixvKXt2YXIgQztyZXR1cm4gV3IocixmdW5jdGlvbih6LFgsZXQpe3JldHVybiBDPW8oeixYLGV0KSwhQ30pLCEhQ31mdW5jdGlvbiB3aShyLG8sQyl7dmFyIHo9MCxYPXI9PW51bGw/ejpyLmxlbmd0aDtpZih0eXBlb2Ygbz09Im51bWJlciImJm89PT1vJiZYPD1vdCl7Zm9yKDt6PFg7KXt2YXIgZXQ9eitYPj4+MSxsdD1yW2V0XTtsdCE9PW51bGwmJiFRZShsdCkmJihDP2x0PD1vOmx0PG8pP3o9ZXQrMTpYPWV0fXJldHVybiBYfXJldHVybiBxcyhyLG8sWWUsQyl9ZnVuY3Rpb24gcXMocixvLEMseil7dmFyIFg9MCxldD1yPT1udWxsPzA6ci5sZW5ndGg7aWYoZXQ9PT0wKXJldHVybiAwO289QyhvKTtmb3IodmFyIGx0PW8hPT1vLGZ0PW89PT1udWxsLHl0PVFlKG8pLFJ0PW89PT10O1g8ZXQ7KXt2YXIgSXQ9UGkoKFgrZXQpLzIpLHd0PUMocltJdF0pLFd0PXd0IT09dCxVdD13dD09PW51bGwsWHQ9d3Q9PT13dCxfdD1RZSh3dCk7aWYobHQpdmFyIFp0PXp8fFh0O2Vsc2UgUnQ/WnQ9WHQmJih6fHxXdCk6ZnQ/WnQ9WHQmJld0JiYoenx8IVV0KTp5dD9adD1YdCYmV3QmJiFVdCYmKHp8fCFfdCk6VXR8fF90P1p0PSExOlp0PXo/d3Q8PW86d3Q8bztadD9YPUl0KzE6ZXQ9SXR9cmV0dXJuIFdlKGV0LHJ0KX1mdW5jdGlvbiBodShyLG8pe2Zvcih2YXIgQz0tMSx6PXIubGVuZ3RoLFg9MCxldD1bXTsrK0M8ejspe3ZhciBsdD1yW0NdLGZ0PW8/byhsdCk6bHQ7aWYoIUN8fCFjcihmdCx5dCkpe3ZhciB5dD1mdDtldFtYKytdPWx0PT09MD8wOmx0fX1yZXR1cm4gZXR9ZnVuY3Rpb24gZHUocil7cmV0dXJuIHR5cGVvZiByPT0ibnVtYmVyIj9yOlFlKHIpP0c6K3J9ZnVuY3Rpb24gSmUocil7aWYodHlwZW9mIHI9PSJzdHJpbmciKXJldHVybiByO2lmKGt0KHIpKXJldHVybiB5ZShyLEplKSsiIjtpZihRZShyKSlyZXR1cm4gWWw/WWwuY2FsbChyKToiIjt2YXIgbz1yKyIiO3JldHVybiBvPT0iMCImJjEvcj09LUo/Ii0wIjpvfWZ1bmN0aW9uIEZyKHIsbyxDKXt2YXIgej0tMSxYPWhpLGV0PXIubGVuZ3RoLGx0PSEwLGZ0PVtdLHl0PWZ0O2lmKEMpbHQ9ITEsWD1BcztlbHNlIGlmKGV0Pj1pKXt2YXIgUnQ9bz9udWxsOmdPKHIpO2lmKFJ0KXJldHVybiBnaShSdCk7bHQ9ITEsWD1Mbix5dD1uZXcgSnJ9ZWxzZSB5dD1vP1tdOmZ0O3Q6Zm9yKDsrK3o8ZXQ7KXt2YXIgSXQ9clt6XSx3dD1vP28oSXQpOkl0O2lmKEl0PUN8fEl0IT09MD9JdDowLGx0JiZ3dD09PXd0KXtmb3IodmFyIFd0PXl0Lmxlbmd0aDtXdC0tOylpZih5dFtXdF09PT13dCljb250aW51ZSB0O28mJnl0LnB1c2god3QpLGZ0LnB1c2goSXQpfWVsc2UgWCh5dCx3dCxDKXx8KHl0IT09ZnQmJnl0LnB1c2god3QpLGZ0LnB1c2goSXQpKX1yZXR1cm4gZnR9ZnVuY3Rpb24gX3MocixvKXtyZXR1cm4gbz1qcihvLHIpLHI9JHUocixvKSxyPT1udWxsfHxkZWxldGUgcltwcihzcihvKSldfWZ1bmN0aW9uIGd1KHIsbyxDLHope3JldHVybiAkbihyLG8sQyhrcihyLG8pKSx6KX1mdW5jdGlvbiBOaShyLG8sQyx6KXtmb3IodmFyIFg9ci5sZW5ndGgsZXQ9ej9YOi0xOyh6P2V0LS06KytldDxYKSYmbyhyW2V0XSxldCxyKTspO3JldHVybiBDP2lyKHIsej8wOmV0LHo/ZXQrMTpYKTppcihyLHo/ZXQrMTowLHo/WDpldCl9ZnVuY3Rpb24gdnUocixvKXt2YXIgQz1yO3JldHVybiBDIGluc3RhbmNlb2YgcmUmJihDPUMudmFsdWUoKSksQ3MobyxmdW5jdGlvbih6LFgpe3JldHVybiBYLmZ1bmMuYXBwbHkoWC50aGlzQXJnLHdyKFt6XSxYLmFyZ3MpKX0sQyl9ZnVuY3Rpb24gdG8ocixvLEMpe3ZhciB6PXIubGVuZ3RoO2lmKHo8MilyZXR1cm4gej9GcihyWzBdKTpbXTtmb3IodmFyIFg9LTEsZXQ9UHQoeik7KytYPHo7KWZvcih2YXIgbHQ9cltYXSxmdD0tMTsrK2Z0PHo7KWZ0IT1YJiYoZXRbWF09am4oZXRbWF18fGx0LHJbZnRdLG8sQykpO3JldHVybiBGcihCZShldCwxKSxvLEMpfWZ1bmN0aW9uIHB1KHIsbyxDKXtmb3IodmFyIHo9LTEsWD1yLmxlbmd0aCxldD1vLmxlbmd0aCxsdD17fTsrK3o8WDspe3ZhciBmdD16PGV0P29bel06dDtDKGx0LHJbel0sZnQpfXJldHVybiBsdH1mdW5jdGlvbiBlbyhyKXtyZXR1cm4gQWUocik/cjpbXX1mdW5jdGlvbiBybyhyKXtyZXR1cm4gdHlwZW9mIHI9PSJmdW5jdGlvbiI/cjpZZX1mdW5jdGlvbiBqcihyLG8pe3JldHVybiBrdChyKT9yOmNvKHIsbyk/W3JdOll1KHVlKHIpKX12YXIgaU89dGU7ZnVuY3Rpb24gVXIocixvLEMpe3ZhciB6PXIubGVuZ3RoO3JldHVybiBDPUM9PT10P3o6QywhbyYmQz49ej9yOmlyKHIsbyxDKX12YXIgbXU9WTJ8fGZ1bmN0aW9uKHIpe3JldHVybiBOZS5jbGVhclRpbWVvdXQocil9O2Z1bmN0aW9uIHl1KHIsbyl7aWYobylyZXR1cm4gci5zbGljZSgpO3ZhciBDPXIubGVuZ3RoLHo9VWw/VWwoQyk6bmV3IHIuY29uc3RydWN0b3IoQyk7cmV0dXJuIHIuY29weSh6KSx6fWZ1bmN0aW9uIG5vKHIpe3ZhciBvPW5ldyByLmNvbnN0cnVjdG9yKHIuYnl0ZUxlbmd0aCk7cmV0dXJuIG5ldyBPaShvKS5zZXQobmV3IE9pKHIpKSxvfWZ1bmN0aW9uIHNPKHIsbyl7dmFyIEM9bz9ubyhyLmJ1ZmZlcik6ci5idWZmZXI7cmV0dXJuIG5ldyByLmNvbnN0cnVjdG9yKEMsci5ieXRlT2Zmc2V0LHIuYnl0ZUxlbmd0aCl9ZnVuY3Rpb24gb08ocil7dmFyIG89bmV3IHIuY29uc3RydWN0b3Ioci5zb3VyY2UsZWwuZXhlYyhyKSk7cmV0dXJuIG8ubGFzdEluZGV4PXIubGFzdEluZGV4LG99ZnVuY3Rpb24gYU8ocil7cmV0dXJuIFduP2hlKFduLmNhbGwocikpOnt9fWZ1bmN0aW9uIHh1KHIsbyl7dmFyIEM9bz9ubyhyLmJ1ZmZlcik6ci5idWZmZXI7cmV0dXJuIG5ldyByLmNvbnN0cnVjdG9yKEMsci5ieXRlT2Zmc2V0LHIubGVuZ3RoKX1mdW5jdGlvbiBPdShyLG8pe2lmKHIhPT1vKXt2YXIgQz1yIT09dCx6PXI9PT1udWxsLFg9cj09PXIsZXQ9UWUociksbHQ9byE9PXQsZnQ9bz09PW51bGwseXQ9bz09PW8sUnQ9UWUobyk7aWYoIWZ0JiYhUnQmJiFldCYmcj5vfHxldCYmbHQmJnl0JiYhZnQmJiFSdHx8eiYmbHQmJnl0fHwhQyYmeXR8fCFYKXJldHVybiAxO2lmKCF6JiYhZXQmJiFSdCYmcjxvfHxSdCYmQyYmWCYmIXomJiFldHx8ZnQmJkMmJlh8fCFsdCYmWHx8IXl0KXJldHVybi0xfXJldHVybiAwfWZ1bmN0aW9uIGxPKHIsbyxDKXtmb3IodmFyIHo9LTEsWD1yLmNyaXRlcmlhLGV0PW8uY3JpdGVyaWEsbHQ9WC5sZW5ndGgsZnQ9Qy5sZW5ndGg7Kyt6PGx0Oyl7dmFyIHl0PU91KFhbel0sZXRbel0pO2lmKHl0KXtpZih6Pj1mdClyZXR1cm4geXQ7dmFyIFJ0PUNbel07cmV0dXJuIHl0KihSdD09ImRlc2MiPy0xOjEpfX1yZXR1cm4gci5pbmRleC1vLmluZGV4fWZ1bmN0aW9uIEV1KHIsbyxDLHope2Zvcih2YXIgWD0tMSxldD1yLmxlbmd0aCxsdD1DLmxlbmd0aCxmdD0tMSx5dD1vLmxlbmd0aCxSdD1EZShldC1sdCwwKSxJdD1QdCh5dCtSdCksd3Q9IXo7KytmdDx5dDspSXRbZnRdPW9bZnRdO2Zvcig7KytYPGx0Oykod3R8fFg8ZXQpJiYoSXRbQ1tYXV09cltYXSk7Zm9yKDtSdC0tOylJdFtmdCsrXT1yW1grK107cmV0dXJuIEl0fWZ1bmN0aW9uIE11KHIsbyxDLHope2Zvcih2YXIgWD0tMSxldD1yLmxlbmd0aCxsdD0tMSxmdD1DLmxlbmd0aCx5dD0tMSxSdD1vLmxlbmd0aCxJdD1EZShldC1mdCwwKSx3dD1QdChJdCtSdCksV3Q9IXo7KytYPEl0Oyl3dFtYXT1yW1hdO2Zvcih2YXIgVXQ9WDsrK3l0PFJ0Oyl3dFtVdCt5dF09b1t5dF07Zm9yKDsrK2x0PGZ0OykoV3R8fFg8ZXQpJiYod3RbVXQrQ1tsdF1dPXJbWCsrXSk7cmV0dXJuIHd0fWZ1bmN0aW9uIEdlKHIsbyl7dmFyIEM9LTEsej1yLmxlbmd0aDtmb3Iob3x8KG89UHQoeikpOysrQzx6OylvW0NdPXJbQ107cmV0dXJuIG99ZnVuY3Rpb24gdnIocixvLEMseil7dmFyIFg9IUM7Q3x8KEM9e30pO2Zvcih2YXIgZXQ9LTEsbHQ9by5sZW5ndGg7KytldDxsdDspe3ZhciBmdD1vW2V0XSx5dD16P3ooQ1tmdF0scltmdF0sZnQsQyxyKTp0O3l0PT09dCYmKHl0PXJbZnRdKSxYP0VyKEMsZnQseXQpOkZuKEMsZnQseXQpfXJldHVybiBDfWZ1bmN0aW9uIHVPKHIsbyl7cmV0dXJuIHZyKHIsZm8ociksbyl9ZnVuY3Rpb24gZk8ocixvKXtyZXR1cm4gdnIocixCdShyKSxvKX1mdW5jdGlvbiBCaShyLG8pe3JldHVybiBmdW5jdGlvbihDLHope3ZhciBYPWt0KEMpP3YyOkR4LGV0PW8/bygpOnt9O3JldHVybiBYKEMscixIdCh6LDIpLGV0KX19ZnVuY3Rpb24gU24ocil7cmV0dXJuIHRlKGZ1bmN0aW9uKG8sQyl7dmFyIHo9LTEsWD1DLmxlbmd0aCxldD1YPjE/Q1tYLTFdOnQsbHQ9WD4yP0NbMl06dDtmb3IoZXQ9ci5sZW5ndGg+MyYmdHlwZW9mIGV0PT0iZnVuY3Rpb24iPyhYLS0sZXQpOnQsbHQmJlVlKENbMF0sQ1sxXSxsdCkmJihldD1YPDM/dDpldCxYPTEpLG89aGUobyk7Kyt6PFg7KXt2YXIgZnQ9Q1t6XTtmdCYmcihvLGZ0LHosZXQpfXJldHVybiBvfSl9ZnVuY3Rpb24gU3UocixvKXtyZXR1cm4gZnVuY3Rpb24oQyx6KXtpZihDPT1udWxsKXJldHVybiBDO2lmKCFLZShDKSlyZXR1cm4gcihDLHopO2Zvcih2YXIgWD1DLmxlbmd0aCxldD1vP1g6LTEsbHQ9aGUoQyk7KG8/ZXQtLTorK2V0PFgpJiZ6KGx0W2V0XSxldCxsdCkhPT0hMTspO3JldHVybiBDfX1mdW5jdGlvbiBUdShyKXtyZXR1cm4gZnVuY3Rpb24obyxDLHope2Zvcih2YXIgWD0tMSxldD1oZShvKSxsdD16KG8pLGZ0PWx0Lmxlbmd0aDtmdC0tOyl7dmFyIHl0PWx0W3I/ZnQ6KytYXTtpZihDKGV0W3l0XSx5dCxldCk9PT0hMSlicmVha31yZXR1cm4gb319ZnVuY3Rpb24gY08ocixvLEMpe3ZhciB6PW8meSxYPUduKHIpO2Z1bmN0aW9uIGV0KCl7dmFyIGx0PXRoaXMmJnRoaXMhPT1OZSYmdGhpcyBpbnN0YW5jZW9mIGV0P1g6cjtyZXR1cm4gbHQuYXBwbHkoej9DOnRoaXMsYXJndW1lbnRzKX1yZXR1cm4gZXR9ZnVuY3Rpb24gUHUocil7cmV0dXJuIGZ1bmN0aW9uKG8pe289dWUobyk7dmFyIEM9cG4obyk/dXIobyk6dCx6PUM/Q1swXTpvLmNoYXJBdCgwKSxYPUM/VXIoQywxKS5qb2luKCIiKTpvLnNsaWNlKDEpO3JldHVybiB6W3JdKCkrWH19ZnVuY3Rpb24gVG4ocil7cmV0dXJuIGZ1bmN0aW9uKG8pe3JldHVybiBDcyhUZihTZihvKS5yZXBsYWNlKGUyLCIiKSksciwiIil9fWZ1bmN0aW9uIEduKHIpe3JldHVybiBmdW5jdGlvbigpe3ZhciBvPWFyZ3VtZW50cztzd2l0Y2goby5sZW5ndGgpe2Nhc2UgMDpyZXR1cm4gbmV3IHI7Y2FzZSAxOnJldHVybiBuZXcgcihvWzBdKTtjYXNlIDI6cmV0dXJuIG5ldyByKG9bMF0sb1sxXSk7Y2FzZSAzOnJldHVybiBuZXcgcihvWzBdLG9bMV0sb1syXSk7Y2FzZSA0OnJldHVybiBuZXcgcihvWzBdLG9bMV0sb1syXSxvWzNdKTtjYXNlIDU6cmV0dXJuIG5ldyByKG9bMF0sb1sxXSxvWzJdLG9bM10sb1s0XSk7Y2FzZSA2OnJldHVybiBuZXcgcihvWzBdLG9bMV0sb1syXSxvWzNdLG9bNF0sb1s1XSk7Y2FzZSA3OnJldHVybiBuZXcgcihvWzBdLG9bMV0sb1syXSxvWzNdLG9bNF0sb1s1XSxvWzZdKX12YXIgQz1NbihyLnByb3RvdHlwZSksej1yLmFwcGx5KEMsbyk7cmV0dXJuIE1lKHopP3o6Q319ZnVuY3Rpb24gaE8ocixvLEMpe3ZhciB6PUduKHIpO2Z1bmN0aW9uIFgoKXtmb3IodmFyIGV0PWFyZ3VtZW50cy5sZW5ndGgsbHQ9UHQoZXQpLGZ0PWV0LHl0PVBuKFgpO2Z0LS07KWx0W2Z0XT1hcmd1bWVudHNbZnRdO3ZhciBSdD1ldDwzJiZsdFswXSE9PXl0JiZsdFtldC0xXSE9PXl0P1tdOk5yKGx0LHl0KTtpZihldC09UnQubGVuZ3RoLGV0PEMpcmV0dXJuIEl1KHIsbyxXaSxYLnBsYWNlaG9sZGVyLHQsbHQsUnQsdCx0LEMtZXQpO3ZhciBJdD10aGlzJiZ0aGlzIT09TmUmJnRoaXMgaW5zdGFuY2VvZiBYP3o6cjtyZXR1cm4gWGUoSXQsdGhpcyxsdCl9cmV0dXJuIFh9ZnVuY3Rpb24gYnUocil7cmV0dXJuIGZ1bmN0aW9uKG8sQyx6KXt2YXIgWD1oZShvKTtpZighS2Uobykpe3ZhciBldD1IdChDLDMpO289d2UobyksQz1mdW5jdGlvbihmdCl7cmV0dXJuIGV0KFhbZnRdLGZ0LFgpfX12YXIgbHQ9cihvLEMseik7cmV0dXJuIGx0Pi0xP1hbZXQ/b1tsdF06bHRdOnR9fWZ1bmN0aW9uIEF1KHIpe3JldHVybiBTcihmdW5jdGlvbihvKXt2YXIgQz1vLmxlbmd0aCx6PUMsWD1yci5wcm90b3R5cGUudGhydTtmb3IociYmby5yZXZlcnNlKCk7ei0tOyl7dmFyIGV0PW9bel07aWYodHlwZW9mIGV0IT0iZnVuY3Rpb24iKXRocm93IG5ldyBlcihoKTtpZihYJiYhbHQmJnppKGV0KT09IndyYXBwZXIiKXZhciBsdD1uZXcgcnIoW10sITApfWZvcih6PWx0P3o6QzsrK3o8Qzspe2V0PW9bel07dmFyIGZ0PXppKGV0KSx5dD1mdD09IndyYXBwZXIiP2xvKGV0KTp0O3l0JiZobyh5dFswXSkmJnl0WzFdPT0oUnxjfHZ8TCkmJiF5dFs0XS5sZW5ndGgmJnl0WzldPT0xP2x0PWx0W3ppKHl0WzBdKV0uYXBwbHkobHQseXRbM10pOmx0PWV0Lmxlbmd0aD09MSYmaG8oZXQpP2x0W2Z0XSgpOmx0LnRocnUoZXQpfXJldHVybiBmdW5jdGlvbigpe3ZhciBSdD1hcmd1bWVudHMsSXQ9UnRbMF07aWYobHQmJlJ0Lmxlbmd0aD09MSYma3QoSXQpKXJldHVybiBsdC5wbGFudChJdCkudmFsdWUoKTtmb3IodmFyIHd0PTAsV3Q9Qz9vW3d0XS5hcHBseSh0aGlzLFJ0KTpJdDsrK3d0PEM7KVd0PW9bd3RdLmNhbGwodGhpcyxXdCk7cmV0dXJuIFd0fX0pfWZ1bmN0aW9uIFdpKHIsbyxDLHosWCxldCxsdCxmdCx5dCxSdCl7dmFyIEl0PW8mUix3dD1vJnksV3Q9byZTLFV0PW8mKGN8bCksWHQ9byZOLF90PVd0P3Q6R24ocik7ZnVuY3Rpb24gWnQoKXtmb3IodmFyIGVlPWFyZ3VtZW50cy5sZW5ndGgsbmU9UHQoZWUpLGtlPWVlO2tlLS07KW5lW2tlXT1hcmd1bWVudHNba2VdO2lmKFV0KXZhciB6ZT1QbihadCkscWU9VDIobmUsemUpO2lmKHomJihuZT1FdShuZSx6LFgsVXQpKSxldCYmKG5lPU11KG5lLGV0LGx0LFV0KSksZWUtPXFlLFV0JiZlZTxSdCl7dmFyIENlPU5yKG5lLHplKTtyZXR1cm4gSXUocixvLFdpLFp0LnBsYWNlaG9sZGVyLEMsbmUsQ2UsZnQseXQsUnQtZWUpfXZhciBocj13dD9DOnRoaXMsQXI9V3Q/aHJbcl06cjtyZXR1cm4gZWU9bmUubGVuZ3RoLGZ0P25lPURPKG5lLGZ0KTpYdCYmZWU+MSYmbmUucmV2ZXJzZSgpLEl0JiZ5dDxlZSYmKG5lLmxlbmd0aD15dCksdGhpcyYmdGhpcyE9PU5lJiZ0aGlzIGluc3RhbmNlb2YgWnQmJihBcj1fdHx8R24oQXIpKSxBci5hcHBseShocixuZSl9cmV0dXJuIFp0fWZ1bmN0aW9uIEN1KHIsbyl7cmV0dXJuIGZ1bmN0aW9uKEMseil7cmV0dXJuIHp4KEMscixvKHopLHt9KX19ZnVuY3Rpb24gRmkocixvKXtyZXR1cm4gZnVuY3Rpb24oQyx6KXt2YXIgWDtpZihDPT09dCYmej09PXQpcmV0dXJuIG87aWYoQyE9PXQmJihYPUMpLHohPT10KXtpZihYPT09dClyZXR1cm4gejt0eXBlb2YgQz09InN0cmluZyJ8fHR5cGVvZiB6PT0ic3RyaW5nIj8oQz1KZShDKSx6PUplKHopKTooQz1kdShDKSx6PWR1KHopKSxYPXIoQyx6KX1yZXR1cm4gWH19ZnVuY3Rpb24gaW8ocil7cmV0dXJuIFNyKGZ1bmN0aW9uKG8pe3JldHVybiBvPXllKG8sWmUoSHQoKSkpLHRlKGZ1bmN0aW9uKEMpe3ZhciB6PXRoaXM7cmV0dXJuIHIobyxmdW5jdGlvbihYKXtyZXR1cm4gWGUoWCx6LEMpfSl9KX0pfWZ1bmN0aW9uIGppKHIsbyl7bz1vPT09dD8iICI6SmUobyk7dmFyIEM9by5sZW5ndGg7aWYoQzwyKXJldHVybiBDP2tzKG8scik6bzt2YXIgej1rcyhvLFRpKHIvbW4obykpKTtyZXR1cm4gcG4obyk/VXIodXIoeiksMCxyKS5qb2luKCIiKTp6LnNsaWNlKDAscil9ZnVuY3Rpb24gZE8ocixvLEMseil7dmFyIFg9byZ5LGV0PUduKHIpO2Z1bmN0aW9uIGx0KCl7Zm9yKHZhciBmdD0tMSx5dD1hcmd1bWVudHMubGVuZ3RoLFJ0PS0xLEl0PXoubGVuZ3RoLHd0PVB0KEl0K3l0KSxXdD10aGlzJiZ0aGlzIT09TmUmJnRoaXMgaW5zdGFuY2VvZiBsdD9ldDpyOysrUnQ8SXQ7KXd0W1J0XT16W1J0XTtmb3IoO3l0LS07KXd0W1J0KytdPWFyZ3VtZW50c1srK2Z0XTtyZXR1cm4gWGUoV3QsWD9DOnRoaXMsd3QpfXJldHVybiBsdH1mdW5jdGlvbiBSdShyKXtyZXR1cm4gZnVuY3Rpb24obyxDLHope3JldHVybiB6JiZ0eXBlb2YgeiE9Im51bWJlciImJlVlKG8sQyx6KSYmKEM9ej10KSxvPWJyKG8pLEM9PT10PyhDPW8sbz0wKTpDPWJyKEMpLHo9ej09PXQ/bzxDPzE6LTE6YnIoeikscXgobyxDLHoscil9fWZ1bmN0aW9uIFVpKHIpe3JldHVybiBmdW5jdGlvbihvLEMpe3JldHVybiB0eXBlb2Ygbz09InN0cmluZyImJnR5cGVvZiBDPT0ic3RyaW5nInx8KG89b3IobyksQz1vcihDKSkscihvLEMpfX1mdW5jdGlvbiBJdShyLG8sQyx6LFgsZXQsbHQsZnQseXQsUnQpe3ZhciBJdD1vJmMsd3Q9SXQ/bHQ6dCxXdD1JdD90Omx0LFV0PUl0P2V0OnQsWHQ9SXQ/dDpldDtvfD1JdD92OlQsbyY9fihJdD9UOnYpLG8mc3x8KG8mPX4oeXxTKSk7dmFyIF90PVtyLG8sWCxVdCx3dCxYdCxXdCxmdCx5dCxSdF0sWnQ9Qy5hcHBseSh0LF90KTtyZXR1cm4gaG8ocikmJkd1KFp0LF90KSxadC5wbGFjZWhvbGRlcj16LEt1KFp0LHIsbyl9ZnVuY3Rpb24gc28ocil7dmFyIG89TGVbcl07cmV0dXJuIGZ1bmN0aW9uKEMseil7aWYoQz1vcihDKSx6PXo9PW51bGw/MDpXZShxdCh6KSwyOTIpLHomJktsKEMpKXt2YXIgWD0odWUoQykrImUiKS5zcGxpdCgiZSIpLGV0PW8oWFswXSsiZSIrKCtYWzFdK3opKTtyZXR1cm4gWD0odWUoZXQpKyJlIikuc3BsaXQoImUiKSwrKFhbMF0rImUiKygrWFsxXS16KSl9cmV0dXJuIG8oQyl9fXZhciBnTz1PbiYmMS9naShuZXcgT24oWywtMF0pKVsxXT09Sj9mdW5jdGlvbihyKXtyZXR1cm4gbmV3IE9uKHIpfTpDbztmdW5jdGlvbiBMdShyKXtyZXR1cm4gZnVuY3Rpb24obyl7dmFyIEM9RmUobyk7cmV0dXJuIEM9PUg/QnMobyk6Qz09bnQ/TDIobyk6UzIobyxyKG8pKX19ZnVuY3Rpb24gTXIocixvLEMseixYLGV0LGx0LGZ0KXt2YXIgeXQ9byZTO2lmKCF5dCYmdHlwZW9mIHIhPSJmdW5jdGlvbiIpdGhyb3cgbmV3IGVyKGgpO3ZhciBSdD16P3oubGVuZ3RoOjA7aWYoUnR8fChvJj1+KHZ8VCksej1YPXQpLGx0PWx0PT09dD9sdDpEZShxdChsdCksMCksZnQ9ZnQ9PT10P2Z0OnF0KGZ0KSxSdC09WD9YLmxlbmd0aDowLG8mVCl7dmFyIEl0PXosd3Q9WDt6PVg9dH12YXIgV3Q9eXQ/dDpsbyhyKSxVdD1bcixvLEMseixYLEl0LHd0LGV0LGx0LGZ0XTtpZihXdCYmUk8oVXQsV3QpLHI9VXRbMF0sbz1VdFsxXSxDPVV0WzJdLHo9VXRbM10sWD1VdFs0XSxmdD1VdFs5XT1VdFs5XT09PXQ/eXQ/MDpyLmxlbmd0aDpEZShVdFs5XS1SdCwwKSwhZnQmJm8mKGN8bCkmJihvJj1+KGN8bCkpLCFvfHxvPT15KXZhciBYdD1jTyhyLG8sQyk7ZWxzZSBvPT1jfHxvPT1sP1h0PWhPKHIsbyxmdCk6KG89PXZ8fG89PSh5fHYpKSYmIVgubGVuZ3RoP1h0PWRPKHIsbyxDLHopOlh0PVdpLmFwcGx5KHQsVXQpO3ZhciBfdD1XdD9jdTpHdTtyZXR1cm4gS3UoX3QoWHQsVXQpLHIsbyl9ZnVuY3Rpb24gRHUocixvLEMseil7cmV0dXJuIHI9PT10fHxjcihyLHhuW0NdKSYmIWZlLmNhbGwoeixDKT9vOnJ9ZnVuY3Rpb24gd3UocixvLEMseixYLGV0KXtyZXR1cm4gTWUocikmJk1lKG8pJiYoZXQuc2V0KG8sciksRGkocixvLHQsd3UsZXQpLGV0LmRlbGV0ZShvKSkscn1mdW5jdGlvbiB2TyhyKXtyZXR1cm4gWW4ocik/dDpyfWZ1bmN0aW9uIE51KHIsbyxDLHosWCxldCl7dmFyIGx0PUMmYixmdD1yLmxlbmd0aCx5dD1vLmxlbmd0aDtpZihmdCE9eXQmJiEobHQmJnl0PmZ0KSlyZXR1cm4hMTt2YXIgUnQ9ZXQuZ2V0KHIpLEl0PWV0LmdldChvKTtpZihSdCYmSXQpcmV0dXJuIFJ0PT1vJiZJdD09cjt2YXIgd3Q9LTEsV3Q9ITAsVXQ9QyZNP25ldyBKcjp0O2ZvcihldC5zZXQocixvKSxldC5zZXQobyxyKTsrK3d0PGZ0Oyl7dmFyIFh0PXJbd3RdLF90PW9bd3RdO2lmKHopdmFyIFp0PWx0P3ooX3QsWHQsd3QsbyxyLGV0KTp6KFh0LF90LHd0LHIsbyxldCk7aWYoWnQhPT10KXtpZihadCljb250aW51ZTtXdD0hMTticmVha31pZihVdCl7aWYoIVJzKG8sZnVuY3Rpb24oZWUsbmUpe2lmKCFMbihVdCxuZSkmJihYdD09PWVlfHxYKFh0LGVlLEMseixldCkpKXJldHVybiBVdC5wdXNoKG5lKX0pKXtXdD0hMTticmVha319ZWxzZSBpZighKFh0PT09X3R8fFgoWHQsX3QsQyx6LGV0KSkpe1d0PSExO2JyZWFrfX1yZXR1cm4gZXQuZGVsZXRlKHIpLGV0LmRlbGV0ZShvKSxXdH1mdW5jdGlvbiBwTyhyLG8sQyx6LFgsZXQsbHQpe3N3aXRjaChDKXtjYXNlIG10OmlmKHIuYnl0ZUxlbmd0aCE9by5ieXRlTGVuZ3RofHxyLmJ5dGVPZmZzZXQhPW8uYnl0ZU9mZnNldClyZXR1cm4hMTtyPXIuYnVmZmVyLG89by5idWZmZXI7Y2FzZSBkdDpyZXR1cm4hKHIuYnl0ZUxlbmd0aCE9by5ieXRlTGVuZ3RofHwhZXQobmV3IE9pKHIpLG5ldyBPaShvKSkpO2Nhc2UgT3Q6Y2FzZSBVOmNhc2UgeDpyZXR1cm4gY3IoK3IsK28pO2Nhc2UgUTpyZXR1cm4gci5uYW1lPT1vLm5hbWUmJnIubWVzc2FnZT09by5tZXNzYWdlO2Nhc2UgazpjYXNlIHV0OnJldHVybiByPT1vKyIiO2Nhc2UgSDp2YXIgZnQ9QnM7Y2FzZSBudDp2YXIgeXQ9eiZiO2lmKGZ0fHwoZnQ9Z2kpLHIuc2l6ZSE9by5zaXplJiYheXQpcmV0dXJuITE7dmFyIFJ0PWx0LmdldChyKTtpZihSdClyZXR1cm4gUnQ9PW87enw9TSxsdC5zZXQocixvKTt2YXIgSXQ9TnUoZnQociksZnQobykseixYLGV0LGx0KTtyZXR1cm4gbHQuZGVsZXRlKHIpLEl0O2Nhc2UgY3Q6aWYoV24pcmV0dXJuIFduLmNhbGwocik9PVduLmNhbGwobyl9cmV0dXJuITF9ZnVuY3Rpb24gbU8ocixvLEMseixYLGV0KXt2YXIgbHQ9QyZiLGZ0PW9vKHIpLHl0PWZ0Lmxlbmd0aCxSdD1vbyhvKSxJdD1SdC5sZW5ndGg7aWYoeXQhPUl0JiYhbHQpcmV0dXJuITE7Zm9yKHZhciB3dD15dDt3dC0tOyl7dmFyIFd0PWZ0W3d0XTtpZighKGx0P1d0IGluIG86ZmUuY2FsbChvLFd0KSkpcmV0dXJuITF9dmFyIFV0PWV0LmdldChyKSxYdD1ldC5nZXQobyk7aWYoVXQmJlh0KXJldHVybiBVdD09byYmWHQ9PXI7dmFyIF90PSEwO2V0LnNldChyLG8pLGV0LnNldChvLHIpO2Zvcih2YXIgWnQ9bHQ7Kyt3dDx5dDspe1d0PWZ0W3d0XTt2YXIgZWU9cltXdF0sbmU9b1tXdF07aWYoeil2YXIga2U9bHQ/eihuZSxlZSxXdCxvLHIsZXQpOnooZWUsbmUsV3QscixvLGV0KTtpZighKGtlPT09dD9lZT09PW5lfHxYKGVlLG5lLEMseixldCk6a2UpKXtfdD0hMTticmVha31adHx8KFp0PVd0PT0iY29uc3RydWN0b3IiKX1pZihfdCYmIVp0KXt2YXIgemU9ci5jb25zdHJ1Y3RvcixxZT1vLmNvbnN0cnVjdG9yO3plIT1xZSYmImNvbnN0cnVjdG9yImluIHImJiJjb25zdHJ1Y3RvciJpbiBvJiYhKHR5cGVvZiB6ZT09ImZ1bmN0aW9uIiYmemUgaW5zdGFuY2VvZiB6ZSYmdHlwZW9mIHFlPT0iZnVuY3Rpb24iJiZxZSBpbnN0YW5jZW9mIHFlKSYmKF90PSExKX1yZXR1cm4gZXQuZGVsZXRlKHIpLGV0LmRlbGV0ZShvKSxfdH1mdW5jdGlvbiBTcihyKXtyZXR1cm4gdm8oenUocix0LEp1KSxyKyIiKX1mdW5jdGlvbiBvbyhyKXtyZXR1cm4gdHUocix3ZSxmbyl9ZnVuY3Rpb24gYW8ocil7cmV0dXJuIHR1KHIsSGUsQnUpfXZhciBsbz1iaT9mdW5jdGlvbihyKXtyZXR1cm4gYmkuZ2V0KHIpfTpDbztmdW5jdGlvbiB6aShyKXtmb3IodmFyIG89ci5uYW1lKyIiLEM9RW5bb10sej1mZS5jYWxsKEVuLG8pP0MubGVuZ3RoOjA7ei0tOyl7dmFyIFg9Q1t6XSxldD1YLmZ1bmM7aWYoZXQ9PW51bGx8fGV0PT1yKXJldHVybiBYLm5hbWV9cmV0dXJuIG99ZnVuY3Rpb24gUG4ocil7dmFyIG89ZmUuY2FsbChxLCJwbGFjZWhvbGRlciIpP3E6cjtyZXR1cm4gby5wbGFjZWhvbGRlcn1mdW5jdGlvbiBIdCgpe3ZhciByPXEuaXRlcmF0ZWV8fGJvO3JldHVybiByPXI9PT1ibz9udTpyLGFyZ3VtZW50cy5sZW5ndGg/cihhcmd1bWVudHNbMF0sYXJndW1lbnRzWzFdKTpyfWZ1bmN0aW9uICRpKHIsbyl7dmFyIEM9ci5fX2RhdGFfXztyZXR1cm4gUE8obyk/Q1t0eXBlb2Ygbz09InN0cmluZyI/InN0cmluZyI6Imhhc2giXTpDLm1hcH1mdW5jdGlvbiB1byhyKXtmb3IodmFyIG89d2UociksQz1vLmxlbmd0aDtDLS07KXt2YXIgej1vW0NdLFg9clt6XTtvW0NdPVt6LFgsanUoWCldfXJldHVybiBvfWZ1bmN0aW9uIHFyKHIsbyl7dmFyIEM9QzIocixvKTtyZXR1cm4gcnUoQyk/Qzp0fWZ1bmN0aW9uIHlPKHIpe3ZhciBvPWZlLmNhbGwocixYciksQz1yW1hyXTt0cnl7cltYcl09dDt2YXIgej0hMH1jYXRjaHt9dmFyIFg9eWkuY2FsbChyKTtyZXR1cm4geiYmKG8/cltYcl09QzpkZWxldGUgcltYcl0pLFh9dmFyIGZvPUZzP2Z1bmN0aW9uKHIpe3JldHVybiByPT1udWxsP1tdOihyPWhlKHIpLERyKEZzKHIpLGZ1bmN0aW9uKG8pe3JldHVybiAkbC5jYWxsKHIsbyl9KSl9OlJvLEJ1PUZzP2Z1bmN0aW9uKHIpe2Zvcih2YXIgbz1bXTtyOyl3cihvLGZvKHIpKSxyPUVpKHIpO3JldHVybiBvfTpSbyxGZT1qZTsoanMmJkZlKG5ldyBqcyhuZXcgQXJyYXlCdWZmZXIoMSkpKSE9bXR8fHduJiZGZShuZXcgd24pIT1IfHxVcyYmRmUoVXMucmVzb2x2ZSgpKSE9S3x8T24mJkZlKG5ldyBPbikhPW50fHxObiYmRmUobmV3IE5uKSE9eHQpJiYoRmU9ZnVuY3Rpb24ocil7dmFyIG89amUociksQz1vPT1XP3IuY29uc3RydWN0b3I6dCx6PUM/X3IoQyk6IiI7aWYoeilzd2l0Y2goeil7Y2FzZSB0eDpyZXR1cm4gbXQ7Y2FzZSBleDpyZXR1cm4gSDtjYXNlIHJ4OnJldHVybiBLO2Nhc2Ugbng6cmV0dXJuIG50O2Nhc2UgaXg6cmV0dXJuIHh0fXJldHVybiBvfSk7ZnVuY3Rpb24geE8ocixvLEMpe2Zvcih2YXIgej0tMSxYPUMubGVuZ3RoOysrejxYOyl7dmFyIGV0PUNbel0sbHQ9ZXQuc2l6ZTtzd2l0Y2goZXQudHlwZSl7Y2FzZSJkcm9wIjpyKz1sdDticmVhaztjYXNlImRyb3BSaWdodCI6by09bHQ7YnJlYWs7Y2FzZSJ0YWtlIjpvPVdlKG8scitsdCk7YnJlYWs7Y2FzZSJ0YWtlUmlnaHQiOnI9RGUocixvLWx0KTticmVha319cmV0dXJue3N0YXJ0OnIsZW5kOm99fWZ1bmN0aW9uIE9PKHIpe3ZhciBvPXIubWF0Y2goYnkpO3JldHVybiBvP29bMV0uc3BsaXQoQXkpOltdfWZ1bmN0aW9uIFd1KHIsbyxDKXtvPWpyKG8scik7Zm9yKHZhciB6PS0xLFg9by5sZW5ndGgsZXQ9ITE7Kyt6PFg7KXt2YXIgbHQ9cHIob1t6XSk7aWYoIShldD1yIT1udWxsJiZDKHIsbHQpKSlicmVhaztyPXJbbHRdfXJldHVybiBldHx8Kyt6IT1YP2V0OihYPXI9PW51bGw/MDpyLmxlbmd0aCwhIVgmJlppKFgpJiZUcihsdCxYKSYmKGt0KHIpfHx0bihyKSkpfWZ1bmN0aW9uIEVPKHIpe3ZhciBvPXIubGVuZ3RoLEM9bmV3IHIuY29uc3RydWN0b3Iobyk7cmV0dXJuIG8mJnR5cGVvZiByWzBdPT0ic3RyaW5nIiYmZmUuY2FsbChyLCJpbmRleCIpJiYoQy5pbmRleD1yLmluZGV4LEMuaW5wdXQ9ci5pbnB1dCksQ31mdW5jdGlvbiBGdShyKXtyZXR1cm4gdHlwZW9mIHIuY29uc3RydWN0b3I9PSJmdW5jdGlvbiImJiFLbihyKT9NbihFaShyKSk6e319ZnVuY3Rpb24gTU8ocixvLEMpe3ZhciB6PXIuY29uc3RydWN0b3I7c3dpdGNoKG8pe2Nhc2UgZHQ6cmV0dXJuIG5vKHIpO2Nhc2UgT3Q6Y2FzZSBVOnJldHVybiBuZXcgeigrcik7Y2FzZSBtdDpyZXR1cm4gc08ocixDKTtjYXNlIGJ0OmNhc2UgQ3Q6Y2FzZSBTdDpjYXNlIE50OmNhc2UgSnQ6Y2FzZSBHdDpjYXNlIEt0OmNhc2UgWXQ6Y2FzZSBWdDpyZXR1cm4geHUocixDKTtjYXNlIEg6cmV0dXJuIG5ldyB6O2Nhc2UgeDpjYXNlIHV0OnJldHVybiBuZXcgeihyKTtjYXNlIGs6cmV0dXJuIG9PKHIpO2Nhc2UgbnQ6cmV0dXJuIG5ldyB6O2Nhc2UgY3Q6cmV0dXJuIGFPKHIpfX1mdW5jdGlvbiBTTyhyLG8pe3ZhciBDPW8ubGVuZ3RoO2lmKCFDKXJldHVybiByO3ZhciB6PUMtMTtyZXR1cm4gb1t6XT0oQz4xPyImICI6IiIpK29bel0sbz1vLmpvaW4oQz4yPyIsICI6IiAiKSxyLnJlcGxhY2UoUHksYHsKLyogW3dyYXBwZWQgd2l0aCBgK28rYF0gKi8KYCl9ZnVuY3Rpb24gVE8ocil7cmV0dXJuIGt0KHIpfHx0bihyKXx8ISEoR2wmJnImJnJbR2xdKX1mdW5jdGlvbiBUcihyLG8pe3ZhciBDPXR5cGVvZiByO3JldHVybiBvPW8/P18sISFvJiYoQz09Im51bWJlciJ8fEMhPSJzeW1ib2wiJiZXeS50ZXN0KHIpKSYmcj4tMSYmciUxPT0wJiZyPG99ZnVuY3Rpb24gVWUocixvLEMpe2lmKCFNZShDKSlyZXR1cm4hMTt2YXIgej10eXBlb2YgbztyZXR1cm4oej09Im51bWJlciI/S2UoQykmJlRyKG8sQy5sZW5ndGgpOno9PSJzdHJpbmciJiZvIGluIEMpP2NyKENbb10scik6ITF9ZnVuY3Rpb24gY28ocixvKXtpZihrdChyKSlyZXR1cm4hMTt2YXIgQz10eXBlb2YgcjtyZXR1cm4gQz09Im51bWJlciJ8fEM9PSJzeW1ib2wifHxDPT0iYm9vbGVhbiJ8fHI9PW51bGx8fFFlKHIpPyEwOmFpLnRlc3Qocil8fCFZci50ZXN0KHIpfHxvIT1udWxsJiZyIGluIGhlKG8pfWZ1bmN0aW9uIFBPKHIpe3ZhciBvPXR5cGVvZiByO3JldHVybiBvPT0ic3RyaW5nInx8bz09Im51bWJlciJ8fG89PSJzeW1ib2wifHxvPT0iYm9vbGVhbiI/ciE9PSJfX3Byb3RvX18iOnI9PT1udWxsfWZ1bmN0aW9uIGhvKHIpe3ZhciBvPXppKHIpLEM9cVtvXTtpZih0eXBlb2YgQyE9ImZ1bmN0aW9uInx8IShvIGluIHJlLnByb3RvdHlwZSkpcmV0dXJuITE7aWYocj09PUMpcmV0dXJuITA7dmFyIHo9bG8oQyk7cmV0dXJuISF6JiZyPT09elswXX1mdW5jdGlvbiBiTyhyKXtyZXR1cm4hIWpsJiZqbCBpbiByfXZhciBBTz1waT9QcjpJbztmdW5jdGlvbiBLbihyKXt2YXIgbz1yJiZyLmNvbnN0cnVjdG9yLEM9dHlwZW9mIG89PSJmdW5jdGlvbiImJm8ucHJvdG90eXBlfHx4bjtyZXR1cm4gcj09PUN9ZnVuY3Rpb24ganUocil7cmV0dXJuIHI9PT1yJiYhTWUocil9ZnVuY3Rpb24gVXUocixvKXtyZXR1cm4gZnVuY3Rpb24oQyl7cmV0dXJuIEM9PW51bGw/ITE6Q1tyXT09PW8mJihvIT09dHx8ciBpbiBoZShDKSl9fWZ1bmN0aW9uIENPKHIpe3ZhciBvPVZpKHIsZnVuY3Rpb24oeil7cmV0dXJuIEMuc2l6ZT09PWQmJkMuY2xlYXIoKSx6fSksQz1vLmNhY2hlO3JldHVybiBvfWZ1bmN0aW9uIFJPKHIsbyl7dmFyIEM9clsxXSx6PW9bMV0sWD1DfHosZXQ9WDwoeXxTfFIpLGx0PXo9PVImJkM9PWN8fHo9PVImJkM9PUwmJnJbN10ubGVuZ3RoPD1vWzhdfHx6PT0oUnxMKSYmb1s3XS5sZW5ndGg8PW9bOF0mJkM9PWM7aWYoIShldHx8bHQpKXJldHVybiByO3omeSYmKHJbMl09b1syXSxYfD1DJnk/MDpzKTt2YXIgZnQ9b1szXTtpZihmdCl7dmFyIHl0PXJbM107clszXT15dD9FdSh5dCxmdCxvWzRdKTpmdCxyWzRdPXl0P05yKHJbM10sRSk6b1s0XX1yZXR1cm4gZnQ9b1s1XSxmdCYmKHl0PXJbNV0scls1XT15dD9NdSh5dCxmdCxvWzZdKTpmdCxyWzZdPXl0P05yKHJbNV0sRSk6b1s2XSksZnQ9b1s3XSxmdCYmKHJbN109ZnQpLHomUiYmKHJbOF09cls4XT09bnVsbD9vWzhdOldlKHJbOF0sb1s4XSkpLHJbOV09PW51bGwmJihyWzldPW9bOV0pLHJbMF09b1swXSxyWzFdPVgscn1mdW5jdGlvbiBJTyhyKXt2YXIgbz1bXTtpZihyIT1udWxsKWZvcih2YXIgQyBpbiBoZShyKSlvLnB1c2goQyk7cmV0dXJuIG99ZnVuY3Rpb24gTE8ocil7cmV0dXJuIHlpLmNhbGwocil9ZnVuY3Rpb24genUocixvLEMpe3JldHVybiBvPURlKG89PT10P3IubGVuZ3RoLTE6bywwKSxmdW5jdGlvbigpe2Zvcih2YXIgej1hcmd1bWVudHMsWD0tMSxldD1EZSh6Lmxlbmd0aC1vLDApLGx0PVB0KGV0KTsrK1g8ZXQ7KWx0W1hdPXpbbytYXTtYPS0xO2Zvcih2YXIgZnQ9UHQobysxKTsrK1g8bzspZnRbWF09eltYXTtyZXR1cm4gZnRbb109QyhsdCksWGUocix0aGlzLGZ0KX19ZnVuY3Rpb24gJHUocixvKXtyZXR1cm4gby5sZW5ndGg8Mj9yOmtyKHIsaXIobywwLC0xKSl9ZnVuY3Rpb24gRE8ocixvKXtmb3IodmFyIEM9ci5sZW5ndGgsej1XZShvLmxlbmd0aCxDKSxYPUdlKHIpO3otLTspe3ZhciBldD1vW3pdO3Jbel09VHIoZXQsQyk/WFtldF06dH1yZXR1cm4gcn1mdW5jdGlvbiBnbyhyLG8pe2lmKCEobz09PSJjb25zdHJ1Y3RvciImJnR5cGVvZiByW29dPT0iZnVuY3Rpb24iKSYmbyE9Il9fcHJvdG9fXyIpcmV0dXJuIHJbb119dmFyIEd1PUh1KGN1KSxIbj1YMnx8ZnVuY3Rpb24ocixvKXtyZXR1cm4gTmUuc2V0VGltZW91dChyLG8pfSx2bz1IdShlTyk7ZnVuY3Rpb24gS3UocixvLEMpe3ZhciB6PW8rIiI7cmV0dXJuIHZvKHIsU08oeix3TyhPTyh6KSxDKSkpfWZ1bmN0aW9uIEh1KHIpe3ZhciBvPTAsQz0wO3JldHVybiBmdW5jdGlvbigpe3ZhciB6PWsyKCksWD1ELSh6LUMpO2lmKEM9eixYPjApe2lmKCsrbz49QilyZXR1cm4gYXJndW1lbnRzWzBdfWVsc2Ugbz0wO3JldHVybiByLmFwcGx5KHQsYXJndW1lbnRzKX19ZnVuY3Rpb24gR2kocixvKXt2YXIgQz0tMSx6PXIubGVuZ3RoLFg9ei0xO2ZvcihvPW89PT10P3o6bzsrK0M8bzspe3ZhciBldD1RcyhDLFgpLGx0PXJbZXRdO3JbZXRdPXJbQ10scltDXT1sdH1yZXR1cm4gci5sZW5ndGg9byxyfXZhciBZdT1DTyhmdW5jdGlvbihyKXt2YXIgbz1bXTtyZXR1cm4gci5jaGFyQ29kZUF0KDApPT09NDYmJm8ucHVzaCgiIiksci5yZXBsYWNlKGxpLGZ1bmN0aW9uKEMseixYLGV0KXtvLnB1c2goWD9ldC5yZXBsYWNlKEl5LCIkMSIpOnp8fEMpfSksb30pO2Z1bmN0aW9uIHByKHIpe2lmKHR5cGVvZiByPT0ic3RyaW5nInx8UWUocikpcmV0dXJuIHI7dmFyIG89cisiIjtyZXR1cm4gbz09IjAiJiYxL3I9PS1KPyItMCI6b31mdW5jdGlvbiBfcihyKXtpZihyIT1udWxsKXt0cnl7cmV0dXJuIG1pLmNhbGwocil9Y2F0Y2h7fXRyeXtyZXR1cm4gcisiIn1jYXRjaHt9fXJldHVybiIifWZ1bmN0aW9uIHdPKHIsbyl7cmV0dXJuIHRyKGF0LGZ1bmN0aW9uKEMpe3ZhciB6PSJfLiIrQ1swXTtvJkNbMV0mJiFoaShyLHopJiZyLnB1c2goeil9KSxyLnNvcnQoKX1mdW5jdGlvbiBWdShyKXtpZihyIGluc3RhbmNlb2YgcmUpcmV0dXJuIHIuY2xvbmUoKTt2YXIgbz1uZXcgcnIoci5fX3dyYXBwZWRfXyxyLl9fY2hhaW5fXyk7cmV0dXJuIG8uX19hY3Rpb25zX189R2Uoci5fX2FjdGlvbnNfXyksby5fX2luZGV4X189ci5fX2luZGV4X18sby5fX3ZhbHVlc19fPXIuX192YWx1ZXNfXyxvfWZ1bmN0aW9uIE5PKHIsbyxDKXsoQz9VZShyLG8sQyk6bz09PXQpP289MTpvPURlKHF0KG8pLDApO3ZhciB6PXI9PW51bGw/MDpyLmxlbmd0aDtpZighenx8bzwxKXJldHVybltdO2Zvcih2YXIgWD0wLGV0PTAsbHQ9UHQoVGkoei9vKSk7WDx6OylsdFtldCsrXT1pcihyLFgsWCs9byk7cmV0dXJuIGx0fWZ1bmN0aW9uIEJPKHIpe2Zvcih2YXIgbz0tMSxDPXI9PW51bGw/MDpyLmxlbmd0aCx6PTAsWD1bXTsrK288Qzspe3ZhciBldD1yW29dO2V0JiYoWFt6KytdPWV0KX1yZXR1cm4gWH1mdW5jdGlvbiBXTygpe3ZhciByPWFyZ3VtZW50cy5sZW5ndGg7aWYoIXIpcmV0dXJuW107Zm9yKHZhciBvPVB0KHItMSksQz1hcmd1bWVudHNbMF0sej1yO3otLTspb1t6LTFdPWFyZ3VtZW50c1t6XTtyZXR1cm4gd3Ioa3QoQyk/R2UoQyk6W0NdLEJlKG8sMSkpfXZhciBGTz10ZShmdW5jdGlvbihyLG8pe3JldHVybiBBZShyKT9qbihyLEJlKG8sMSxBZSwhMCkpOltdfSksak89dGUoZnVuY3Rpb24ocixvKXt2YXIgQz1zcihvKTtyZXR1cm4gQWUoQykmJihDPXQpLEFlKHIpP2puKHIsQmUobywxLEFlLCEwKSxIdChDLDIpKTpbXX0pLFVPPXRlKGZ1bmN0aW9uKHIsbyl7dmFyIEM9c3Iobyk7cmV0dXJuIEFlKEMpJiYoQz10KSxBZShyKT9qbihyLEJlKG8sMSxBZSwhMCksdCxDKTpbXX0pO2Z1bmN0aW9uIHpPKHIsbyxDKXt2YXIgej1yPT1udWxsPzA6ci5sZW5ndGg7cmV0dXJuIHo/KG89Q3x8bz09PXQ/MTpxdChvKSxpcihyLG88MD8wOm8seikpOltdfWZ1bmN0aW9uICRPKHIsbyxDKXt2YXIgej1yPT1udWxsPzA6ci5sZW5ndGg7cmV0dXJuIHo/KG89Q3x8bz09PXQ/MTpxdChvKSxvPXotbyxpcihyLDAsbzwwPzA6bykpOltdfWZ1bmN0aW9uIEdPKHIsbyl7cmV0dXJuIHImJnIubGVuZ3RoP05pKHIsSHQobywzKSwhMCwhMCk6W119ZnVuY3Rpb24gS08ocixvKXtyZXR1cm4gciYmci5sZW5ndGg/TmkocixIdChvLDMpLCEwKTpbXX1mdW5jdGlvbiBITyhyLG8sQyx6KXt2YXIgWD1yPT1udWxsPzA6ci5sZW5ndGg7cmV0dXJuIFg/KEMmJnR5cGVvZiBDIT0ibnVtYmVyIiYmVWUocixvLEMpJiYoQz0wLHo9WCksV3gocixvLEMseikpOltdfWZ1bmN0aW9uIFh1KHIsbyxDKXt2YXIgej1yPT1udWxsPzA6ci5sZW5ndGg7aWYoIXopcmV0dXJuLTE7dmFyIFg9Qz09bnVsbD8wOnF0KEMpO3JldHVybiBYPDAmJihYPURlKHorWCwwKSksZGkocixIdChvLDMpLFgpfWZ1bmN0aW9uIFp1KHIsbyxDKXt2YXIgej1yPT1udWxsPzA6ci5sZW5ndGg7aWYoIXopcmV0dXJuLTE7dmFyIFg9ei0xO3JldHVybiBDIT09dCYmKFg9cXQoQyksWD1DPDA/RGUoeitYLDApOldlKFgsei0xKSksZGkocixIdChvLDMpLFgsITApfWZ1bmN0aW9uIEp1KHIpe3ZhciBvPXI9PW51bGw/MDpyLmxlbmd0aDtyZXR1cm4gbz9CZShyLDEpOltdfWZ1bmN0aW9uIFlPKHIpe3ZhciBvPXI9PW51bGw/MDpyLmxlbmd0aDtyZXR1cm4gbz9CZShyLEopOltdfWZ1bmN0aW9uIFZPKHIsbyl7dmFyIEM9cj09bnVsbD8wOnIubGVuZ3RoO3JldHVybiBDPyhvPW89PT10PzE6cXQobyksQmUocixvKSk6W119ZnVuY3Rpb24gWE8ocil7Zm9yKHZhciBvPS0xLEM9cj09bnVsbD8wOnIubGVuZ3RoLHo9e307KytvPEM7KXt2YXIgWD1yW29dO3pbWFswXV09WFsxXX1yZXR1cm4gen1mdW5jdGlvbiBRdShyKXtyZXR1cm4gciYmci5sZW5ndGg/clswXTp0fWZ1bmN0aW9uIFpPKHIsbyxDKXt2YXIgej1yPT1udWxsPzA6ci5sZW5ndGg7aWYoIXopcmV0dXJuLTE7dmFyIFg9Qz09bnVsbD8wOnF0KEMpO3JldHVybiBYPDAmJihYPURlKHorWCwwKSksdm4ocixvLFgpfWZ1bmN0aW9uIEpPKHIpe3ZhciBvPXI9PW51bGw/MDpyLmxlbmd0aDtyZXR1cm4gbz9pcihyLDAsLTEpOltdfXZhciBRTz10ZShmdW5jdGlvbihyKXt2YXIgbz15ZShyLGVvKTtyZXR1cm4gby5sZW5ndGgmJm9bMF09PT1yWzBdP1lzKG8pOltdfSksa089dGUoZnVuY3Rpb24ocil7dmFyIG89c3IociksQz15ZShyLGVvKTtyZXR1cm4gbz09PXNyKEMpP289dDpDLnBvcCgpLEMubGVuZ3RoJiZDWzBdPT09clswXT9ZcyhDLEh0KG8sMikpOltdfSkscU89dGUoZnVuY3Rpb24ocil7dmFyIG89c3IociksQz15ZShyLGVvKTtyZXR1cm4gbz10eXBlb2Ygbz09ImZ1bmN0aW9uIj9vOnQsbyYmQy5wb3AoKSxDLmxlbmd0aCYmQ1swXT09PXJbMF0/WXMoQyx0LG8pOltdfSk7ZnVuY3Rpb24gX08ocixvKXtyZXR1cm4gcj09bnVsbD8iIjpKMi5jYWxsKHIsbyl9ZnVuY3Rpb24gc3Iocil7dmFyIG89cj09bnVsbD8wOnIubGVuZ3RoO3JldHVybiBvP3Jbby0xXTp0fWZ1bmN0aW9uIHRFKHIsbyxDKXt2YXIgej1yPT1udWxsPzA6ci5sZW5ndGg7aWYoIXopcmV0dXJuLTE7dmFyIFg9ejtyZXR1cm4gQyE9PXQmJihYPXF0KEMpLFg9WDwwP0RlKHorWCwwKTpXZShYLHotMSkpLG89PT1vP3cyKHIsbyxYKTpkaShyLElsLFgsITApfWZ1bmN0aW9uIGVFKHIsbyl7cmV0dXJuIHImJnIubGVuZ3RoP2F1KHIscXQobykpOnR9dmFyIHJFPXRlKGt1KTtmdW5jdGlvbiBrdShyLG8pe3JldHVybiByJiZyLmxlbmd0aCYmbyYmby5sZW5ndGg/SnMocixvKTpyfWZ1bmN0aW9uIG5FKHIsbyxDKXtyZXR1cm4gciYmci5sZW5ndGgmJm8mJm8ubGVuZ3RoP0pzKHIsbyxIdChDLDIpKTpyfWZ1bmN0aW9uIGlFKHIsbyxDKXtyZXR1cm4gciYmci5sZW5ndGgmJm8mJm8ubGVuZ3RoP0pzKHIsbyx0LEMpOnJ9dmFyIHNFPVNyKGZ1bmN0aW9uKHIsbyl7dmFyIEM9cj09bnVsbD8wOnIubGVuZ3RoLHo9JHMocixvKTtyZXR1cm4gZnUocix5ZShvLGZ1bmN0aW9uKFgpe3JldHVybiBUcihYLEMpPytYOlh9KS5zb3J0KE91KSksen0pO2Z1bmN0aW9uIG9FKHIsbyl7dmFyIEM9W107aWYoIShyJiZyLmxlbmd0aCkpcmV0dXJuIEM7dmFyIHo9LTEsWD1bXSxldD1yLmxlbmd0aDtmb3Iobz1IdChvLDMpOysrejxldDspe3ZhciBsdD1yW3pdO28obHQseixyKSYmKEMucHVzaChsdCksWC5wdXNoKHopKX1yZXR1cm4gZnUocixYKSxDfWZ1bmN0aW9uIHBvKHIpe3JldHVybiByPT1udWxsP3I6XzIuY2FsbChyKX1mdW5jdGlvbiBhRShyLG8sQyl7dmFyIHo9cj09bnVsbD8wOnIubGVuZ3RoO3JldHVybiB6PyhDJiZ0eXBlb2YgQyE9Im51bWJlciImJlVlKHIsbyxDKT8obz0wLEM9eik6KG89bz09bnVsbD8wOnF0KG8pLEM9Qz09PXQ/ejpxdChDKSksaXIocixvLEMpKTpbXX1mdW5jdGlvbiBsRShyLG8pe3JldHVybiB3aShyLG8pfWZ1bmN0aW9uIHVFKHIsbyxDKXtyZXR1cm4gcXMocixvLEh0KEMsMikpfWZ1bmN0aW9uIGZFKHIsbyl7dmFyIEM9cj09bnVsbD8wOnIubGVuZ3RoO2lmKEMpe3ZhciB6PXdpKHIsbyk7aWYoejxDJiZjcihyW3pdLG8pKXJldHVybiB6fXJldHVybi0xfWZ1bmN0aW9uIGNFKHIsbyl7cmV0dXJuIHdpKHIsbywhMCl9ZnVuY3Rpb24gaEUocixvLEMpe3JldHVybiBxcyhyLG8sSHQoQywyKSwhMCl9ZnVuY3Rpb24gZEUocixvKXt2YXIgQz1yPT1udWxsPzA6ci5sZW5ndGg7aWYoQyl7dmFyIHo9d2kocixvLCEwKS0xO2lmKGNyKHJbel0sbykpcmV0dXJuIHp9cmV0dXJuLTF9ZnVuY3Rpb24gZ0Uocil7cmV0dXJuIHImJnIubGVuZ3RoP2h1KHIpOltdfWZ1bmN0aW9uIHZFKHIsbyl7cmV0dXJuIHImJnIubGVuZ3RoP2h1KHIsSHQobywyKSk6W119ZnVuY3Rpb24gcEUocil7dmFyIG89cj09bnVsbD8wOnIubGVuZ3RoO3JldHVybiBvP2lyKHIsMSxvKTpbXX1mdW5jdGlvbiBtRShyLG8sQyl7cmV0dXJuIHImJnIubGVuZ3RoPyhvPUN8fG89PT10PzE6cXQobyksaXIociwwLG88MD8wOm8pKTpbXX1mdW5jdGlvbiB5RShyLG8sQyl7dmFyIHo9cj09bnVsbD8wOnIubGVuZ3RoO3JldHVybiB6PyhvPUN8fG89PT10PzE6cXQobyksbz16LW8saXIocixvPDA/MDpvLHopKTpbXX1mdW5jdGlvbiB4RShyLG8pe3JldHVybiByJiZyLmxlbmd0aD9OaShyLEh0KG8sMyksITEsITApOltdfWZ1bmN0aW9uIE9FKHIsbyl7cmV0dXJuIHImJnIubGVuZ3RoP05pKHIsSHQobywzKSk6W119dmFyIEVFPXRlKGZ1bmN0aW9uKHIpe3JldHVybiBGcihCZShyLDEsQWUsITApKX0pLE1FPXRlKGZ1bmN0aW9uKHIpe3ZhciBvPXNyKHIpO3JldHVybiBBZShvKSYmKG89dCksRnIoQmUociwxLEFlLCEwKSxIdChvLDIpKX0pLFNFPXRlKGZ1bmN0aW9uKHIpe3ZhciBvPXNyKHIpO3JldHVybiBvPXR5cGVvZiBvPT0iZnVuY3Rpb24iP286dCxGcihCZShyLDEsQWUsITApLHQsbyl9KTtmdW5jdGlvbiBURShyKXtyZXR1cm4gciYmci5sZW5ndGg/RnIocik6W119ZnVuY3Rpb24gUEUocixvKXtyZXR1cm4gciYmci5sZW5ndGg/RnIocixIdChvLDIpKTpbXX1mdW5jdGlvbiBiRShyLG8pe3JldHVybiBvPXR5cGVvZiBvPT0iZnVuY3Rpb24iP286dCxyJiZyLmxlbmd0aD9GcihyLHQsbyk6W119ZnVuY3Rpb24gbW8ocil7aWYoIShyJiZyLmxlbmd0aCkpcmV0dXJuW107dmFyIG89MDtyZXR1cm4gcj1EcihyLGZ1bmN0aW9uKEMpe2lmKEFlKEMpKXJldHVybiBvPURlKEMubGVuZ3RoLG8pLCEwfSksd3MobyxmdW5jdGlvbihDKXtyZXR1cm4geWUocixJcyhDKSl9KX1mdW5jdGlvbiBxdShyLG8pe2lmKCEociYmci5sZW5ndGgpKXJldHVybltdO3ZhciBDPW1vKHIpO3JldHVybiBvPT1udWxsP0M6eWUoQyxmdW5jdGlvbih6KXtyZXR1cm4gWGUobyx0LHopfSl9dmFyIEFFPXRlKGZ1bmN0aW9uKHIsbyl7cmV0dXJuIEFlKHIpP2puKHIsbyk6W119KSxDRT10ZShmdW5jdGlvbihyKXtyZXR1cm4gdG8oRHIocixBZSkpfSksUkU9dGUoZnVuY3Rpb24ocil7dmFyIG89c3Iocik7cmV0dXJuIEFlKG8pJiYobz10KSx0byhEcihyLEFlKSxIdChvLDIpKX0pLElFPXRlKGZ1bmN0aW9uKHIpe3ZhciBvPXNyKHIpO3JldHVybiBvPXR5cGVvZiBvPT0iZnVuY3Rpb24iP286dCx0byhEcihyLEFlKSx0LG8pfSksTEU9dGUobW8pO2Z1bmN0aW9uIERFKHIsbyl7cmV0dXJuIHB1KHJ8fFtdLG98fFtdLEZuKX1mdW5jdGlvbiB3RShyLG8pe3JldHVybiBwdShyfHxbXSxvfHxbXSwkbil9dmFyIE5FPXRlKGZ1bmN0aW9uKHIpe3ZhciBvPXIubGVuZ3RoLEM9bz4xP3Jbby0xXTp0O3JldHVybiBDPXR5cGVvZiBDPT0iZnVuY3Rpb24iPyhyLnBvcCgpLEMpOnQscXUocixDKX0pO2Z1bmN0aW9uIF91KHIpe3ZhciBvPXEocik7cmV0dXJuIG8uX19jaGFpbl9fPSEwLG99ZnVuY3Rpb24gQkUocixvKXtyZXR1cm4gbyhyKSxyfWZ1bmN0aW9uIEtpKHIsbyl7cmV0dXJuIG8ocil9dmFyIFdFPVNyKGZ1bmN0aW9uKHIpe3ZhciBvPXIubGVuZ3RoLEM9bz9yWzBdOjAsej10aGlzLl9fd3JhcHBlZF9fLFg9ZnVuY3Rpb24oZXQpe3JldHVybiAkcyhldCxyKX07cmV0dXJuIG8+MXx8dGhpcy5fX2FjdGlvbnNfXy5sZW5ndGh8fCEoeiBpbnN0YW5jZW9mIHJlKXx8IVRyKEMpP3RoaXMudGhydShYKTooej16LnNsaWNlKEMsK0MrKG8/MTowKSksei5fX2FjdGlvbnNfXy5wdXNoKHtmdW5jOktpLGFyZ3M6W1hdLHRoaXNBcmc6dH0pLG5ldyBycih6LHRoaXMuX19jaGFpbl9fKS50aHJ1KGZ1bmN0aW9uKGV0KXtyZXR1cm4gbyYmIWV0Lmxlbmd0aCYmZXQucHVzaCh0KSxldH0pKX0pO2Z1bmN0aW9uIEZFKCl7cmV0dXJuIF91KHRoaXMpfWZ1bmN0aW9uIGpFKCl7cmV0dXJuIG5ldyBycih0aGlzLnZhbHVlKCksdGhpcy5fX2NoYWluX18pfWZ1bmN0aW9uIFVFKCl7dGhpcy5fX3ZhbHVlc19fPT09dCYmKHRoaXMuX192YWx1ZXNfXz1nZih0aGlzLnZhbHVlKCkpKTt2YXIgcj10aGlzLl9faW5kZXhfXz49dGhpcy5fX3ZhbHVlc19fLmxlbmd0aCxvPXI/dDp0aGlzLl9fdmFsdWVzX19bdGhpcy5fX2luZGV4X18rK107cmV0dXJue2RvbmU6cix2YWx1ZTpvfX1mdW5jdGlvbiB6RSgpe3JldHVybiB0aGlzfWZ1bmN0aW9uICRFKHIpe2Zvcih2YXIgbyxDPXRoaXM7QyBpbnN0YW5jZW9mIENpOyl7dmFyIHo9VnUoQyk7ei5fX2luZGV4X189MCx6Ll9fdmFsdWVzX189dCxvP1guX193cmFwcGVkX189ejpvPXo7dmFyIFg9ejtDPUMuX193cmFwcGVkX199cmV0dXJuIFguX193cmFwcGVkX189cixvfWZ1bmN0aW9uIEdFKCl7dmFyIHI9dGhpcy5fX3dyYXBwZWRfXztpZihyIGluc3RhbmNlb2YgcmUpe3ZhciBvPXI7cmV0dXJuIHRoaXMuX19hY3Rpb25zX18ubGVuZ3RoJiYobz1uZXcgcmUodGhpcykpLG89by5yZXZlcnNlKCksby5fX2FjdGlvbnNfXy5wdXNoKHtmdW5jOktpLGFyZ3M6W3BvXSx0aGlzQXJnOnR9KSxuZXcgcnIobyx0aGlzLl9fY2hhaW5fXyl9cmV0dXJuIHRoaXMudGhydShwbyl9ZnVuY3Rpb24gS0UoKXtyZXR1cm4gdnUodGhpcy5fX3dyYXBwZWRfXyx0aGlzLl9fYWN0aW9uc19fKX12YXIgSEU9QmkoZnVuY3Rpb24ocixvLEMpe2ZlLmNhbGwocixDKT8rK3JbQ106RXIocixDLDEpfSk7ZnVuY3Rpb24gWUUocixvLEMpe3ZhciB6PWt0KHIpP0NsOkJ4O3JldHVybiBDJiZVZShyLG8sQykmJihvPXQpLHoocixIdChvLDMpKX1mdW5jdGlvbiBWRShyLG8pe3ZhciBDPWt0KHIpP0RyOnFsO3JldHVybiBDKHIsSHQobywzKSl9dmFyIFhFPWJ1KFh1KSxaRT1idShadSk7ZnVuY3Rpb24gSkUocixvKXtyZXR1cm4gQmUoSGkocixvKSwxKX1mdW5jdGlvbiBRRShyLG8pe3JldHVybiBCZShIaShyLG8pLEopfWZ1bmN0aW9uIGtFKHIsbyxDKXtyZXR1cm4gQz1DPT09dD8xOnF0KEMpLEJlKEhpKHIsbyksQyl9ZnVuY3Rpb24gdGYocixvKXt2YXIgQz1rdChyKT90cjpXcjtyZXR1cm4gQyhyLEh0KG8sMykpfWZ1bmN0aW9uIGVmKHIsbyl7dmFyIEM9a3Qocik/cDI6a2w7cmV0dXJuIEMocixIdChvLDMpKX12YXIgcUU9QmkoZnVuY3Rpb24ocixvLEMpe2ZlLmNhbGwocixDKT9yW0NdLnB1c2gobyk6RXIocixDLFtvXSl9KTtmdW5jdGlvbiBfRShyLG8sQyx6KXtyPUtlKHIpP3I6QW4ociksQz1DJiYhej9xdChDKTowO3ZhciBYPXIubGVuZ3RoO3JldHVybiBDPDAmJihDPURlKFgrQywwKSksSmkocik/Qzw9WCYmci5pbmRleE9mKG8sQyk+LTE6ISFYJiZ2bihyLG8sQyk+LTF9dmFyIHRNPXRlKGZ1bmN0aW9uKHIsbyxDKXt2YXIgej0tMSxYPXR5cGVvZiBvPT0iZnVuY3Rpb24iLGV0PUtlKHIpP1B0KHIubGVuZ3RoKTpbXTtyZXR1cm4gV3IocixmdW5jdGlvbihsdCl7ZXRbKyt6XT1YP1hlKG8sbHQsQyk6VW4obHQsbyxDKX0pLGV0fSksZU09QmkoZnVuY3Rpb24ocixvLEMpe0VyKHIsQyxvKX0pO2Z1bmN0aW9uIEhpKHIsbyl7dmFyIEM9a3Qocik/eWU6aXU7cmV0dXJuIEMocixIdChvLDMpKX1mdW5jdGlvbiByTShyLG8sQyx6KXtyZXR1cm4gcj09bnVsbD9bXTooa3Qobyl8fChvPW89PW51bGw/W106W29dKSxDPXo/dDpDLGt0KEMpfHwoQz1DPT1udWxsP1tdOltDXSksbHUocixvLEMpKX12YXIgbk09QmkoZnVuY3Rpb24ocixvLEMpe3JbQz8wOjFdLnB1c2gobyl9LGZ1bmN0aW9uKCl7cmV0dXJuW1tdLFtdXX0pO2Z1bmN0aW9uIGlNKHIsbyxDKXt2YXIgej1rdChyKT9DczpEbCxYPWFyZ3VtZW50cy5sZW5ndGg8MztyZXR1cm4geihyLEh0KG8sNCksQyxYLFdyKX1mdW5jdGlvbiBzTShyLG8sQyl7dmFyIHo9a3Qocik/bTI6RGwsWD1hcmd1bWVudHMubGVuZ3RoPDM7cmV0dXJuIHoocixIdChvLDQpLEMsWCxrbCl9ZnVuY3Rpb24gb00ocixvKXt2YXIgQz1rdChyKT9EcjpxbDtyZXR1cm4gQyhyLFhpKEh0KG8sMykpKX1mdW5jdGlvbiBhTShyKXt2YXIgbz1rdChyKT9YbDpfeDtyZXR1cm4gbyhyKX1mdW5jdGlvbiBsTShyLG8sQyl7KEM/VWUocixvLEMpOm89PT10KT9vPTE6bz1xdChvKTt2YXIgej1rdChyKT9JeDp0TztyZXR1cm4geihyLG8pfWZ1bmN0aW9uIHVNKHIpe3ZhciBvPWt0KHIpP0x4OnJPO3JldHVybiBvKHIpfWZ1bmN0aW9uIGZNKHIpe2lmKHI9PW51bGwpcmV0dXJuIDA7aWYoS2UocikpcmV0dXJuIEppKHIpP21uKHIpOnIubGVuZ3RoO3ZhciBvPUZlKHIpO3JldHVybiBvPT1IfHxvPT1udD9yLnNpemU6WHMocikubGVuZ3RofWZ1bmN0aW9uIGNNKHIsbyxDKXt2YXIgej1rdChyKT9SczpuTztyZXR1cm4gQyYmVWUocixvLEMpJiYobz10KSx6KHIsSHQobywzKSl9dmFyIGhNPXRlKGZ1bmN0aW9uKHIsbyl7aWYocj09bnVsbClyZXR1cm5bXTt2YXIgQz1vLmxlbmd0aDtyZXR1cm4gQz4xJiZVZShyLG9bMF0sb1sxXSk/bz1bXTpDPjImJlVlKG9bMF0sb1sxXSxvWzJdKSYmKG89W29bMF1dKSxsdShyLEJlKG8sMSksW10pfSksWWk9VjJ8fGZ1bmN0aW9uKCl7cmV0dXJuIE5lLkRhdGUubm93KCl9O2Z1bmN0aW9uIGRNKHIsbyl7aWYodHlwZW9mIG8hPSJmdW5jdGlvbiIpdGhyb3cgbmV3IGVyKGgpO3JldHVybiByPXF0KHIpLGZ1bmN0aW9uKCl7aWYoLS1yPDEpcmV0dXJuIG8uYXBwbHkodGhpcyxhcmd1bWVudHMpfX1mdW5jdGlvbiByZihyLG8sQyl7cmV0dXJuIG89Qz90Om8sbz1yJiZvPT1udWxsP3IubGVuZ3RoOm8sTXIocixSLHQsdCx0LHQsbyl9ZnVuY3Rpb24gbmYocixvKXt2YXIgQztpZih0eXBlb2YgbyE9ImZ1bmN0aW9uIil0aHJvdyBuZXcgZXIoaCk7cmV0dXJuIHI9cXQociksZnVuY3Rpb24oKXtyZXR1cm4tLXI+MCYmKEM9by5hcHBseSh0aGlzLGFyZ3VtZW50cykpLHI8PTEmJihvPXQpLEN9fXZhciB5bz10ZShmdW5jdGlvbihyLG8sQyl7dmFyIHo9eTtpZihDLmxlbmd0aCl7dmFyIFg9TnIoQyxQbih5bykpO3p8PXZ9cmV0dXJuIE1yKHIseixvLEMsWCl9KSxzZj10ZShmdW5jdGlvbihyLG8sQyl7dmFyIHo9eXxTO2lmKEMubGVuZ3RoKXt2YXIgWD1OcihDLFBuKHNmKSk7enw9dn1yZXR1cm4gTXIobyx6LHIsQyxYKX0pO2Z1bmN0aW9uIG9mKHIsbyxDKXtvPUM/dDpvO3ZhciB6PU1yKHIsYyx0LHQsdCx0LHQsbyk7cmV0dXJuIHoucGxhY2Vob2xkZXI9b2YucGxhY2Vob2xkZXIsen1mdW5jdGlvbiBhZihyLG8sQyl7bz1DP3Q6bzt2YXIgej1NcihyLGwsdCx0LHQsdCx0LG8pO3JldHVybiB6LnBsYWNlaG9sZGVyPWFmLnBsYWNlaG9sZGVyLHp9ZnVuY3Rpb24gbGYocixvLEMpe3ZhciB6LFgsZXQsbHQsZnQseXQsUnQ9MCxJdD0hMSx3dD0hMSxXdD0hMDtpZih0eXBlb2YgciE9ImZ1bmN0aW9uIil0aHJvdyBuZXcgZXIoaCk7bz1vcihvKXx8MCxNZShDKSYmKEl0PSEhQy5sZWFkaW5nLHd0PSJtYXhXYWl0ImluIEMsZXQ9d3Q/RGUob3IoQy5tYXhXYWl0KXx8MCxvKTpldCxXdD0idHJhaWxpbmciaW4gQz8hIUMudHJhaWxpbmc6V3QpO2Z1bmN0aW9uIFV0KENlKXt2YXIgaHI9eixBcj1YO3JldHVybiB6PVg9dCxSdD1DZSxsdD1yLmFwcGx5KEFyLGhyKSxsdH1mdW5jdGlvbiBYdChDZSl7cmV0dXJuIFJ0PUNlLGZ0PUhuKGVlLG8pLEl0P1V0KENlKTpsdH1mdW5jdGlvbiBfdChDZSl7dmFyIGhyPUNlLXl0LEFyPUNlLVJ0LEFmPW8taHI7cmV0dXJuIHd0P1dlKEFmLGV0LUFyKTpBZn1mdW5jdGlvbiBadChDZSl7dmFyIGhyPUNlLXl0LEFyPUNlLVJ0O3JldHVybiB5dD09PXR8fGhyPj1vfHxocjwwfHx3dCYmQXI+PWV0fWZ1bmN0aW9uIGVlKCl7dmFyIENlPVlpKCk7aWYoWnQoQ2UpKXJldHVybiBuZShDZSk7ZnQ9SG4oZWUsX3QoQ2UpKX1mdW5jdGlvbiBuZShDZSl7cmV0dXJuIGZ0PXQsV3QmJno/VXQoQ2UpOih6PVg9dCxsdCl9ZnVuY3Rpb24ga2UoKXtmdCE9PXQmJm11KGZ0KSxSdD0wLHo9eXQ9WD1mdD10fWZ1bmN0aW9uIHplKCl7cmV0dXJuIGZ0PT09dD9sdDpuZShZaSgpKX1mdW5jdGlvbiBxZSgpe3ZhciBDZT1ZaSgpLGhyPVp0KENlKTtpZih6PWFyZ3VtZW50cyxYPXRoaXMseXQ9Q2UsaHIpe2lmKGZ0PT09dClyZXR1cm4gWHQoeXQpO2lmKHd0KXJldHVybiBtdShmdCksZnQ9SG4oZWUsbyksVXQoeXQpfXJldHVybiBmdD09PXQmJihmdD1IbihlZSxvKSksbHR9cmV0dXJuIHFlLmNhbmNlbD1rZSxxZS5mbHVzaD16ZSxxZX12YXIgZ009dGUoZnVuY3Rpb24ocixvKXtyZXR1cm4gUWwociwxLG8pfSksdk09dGUoZnVuY3Rpb24ocixvLEMpe3JldHVybiBRbChyLG9yKG8pfHwwLEMpfSk7ZnVuY3Rpb24gcE0ocil7cmV0dXJuIE1yKHIsTil9ZnVuY3Rpb24gVmkocixvKXtpZih0eXBlb2YgciE9ImZ1bmN0aW9uInx8byE9bnVsbCYmdHlwZW9mIG8hPSJmdW5jdGlvbiIpdGhyb3cgbmV3IGVyKGgpO3ZhciBDPWZ1bmN0aW9uKCl7dmFyIHo9YXJndW1lbnRzLFg9bz9vLmFwcGx5KHRoaXMseik6elswXSxldD1DLmNhY2hlO2lmKGV0LmhhcyhYKSlyZXR1cm4gZXQuZ2V0KFgpO3ZhciBsdD1yLmFwcGx5KHRoaXMseik7cmV0dXJuIEMuY2FjaGU9ZXQuc2V0KFgsbHQpfHxldCxsdH07cmV0dXJuIEMuY2FjaGU9bmV3KFZpLkNhY2hlfHxPciksQ31WaS5DYWNoZT1PcjtmdW5jdGlvbiBYaShyKXtpZih0eXBlb2YgciE9ImZ1bmN0aW9uIil0aHJvdyBuZXcgZXIoaCk7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIG89YXJndW1lbnRzO3N3aXRjaChvLmxlbmd0aCl7Y2FzZSAwOnJldHVybiFyLmNhbGwodGhpcyk7Y2FzZSAxOnJldHVybiFyLmNhbGwodGhpcyxvWzBdKTtjYXNlIDI6cmV0dXJuIXIuY2FsbCh0aGlzLG9bMF0sb1sxXSk7Y2FzZSAzOnJldHVybiFyLmNhbGwodGhpcyxvWzBdLG9bMV0sb1syXSl9cmV0dXJuIXIuYXBwbHkodGhpcyxvKX19ZnVuY3Rpb24gbU0ocil7cmV0dXJuIG5mKDIscil9dmFyIHlNPWlPKGZ1bmN0aW9uKHIsbyl7bz1vLmxlbmd0aD09MSYma3Qob1swXSk/eWUob1swXSxaZShIdCgpKSk6eWUoQmUobywxKSxaZShIdCgpKSk7dmFyIEM9by5sZW5ndGg7cmV0dXJuIHRlKGZ1bmN0aW9uKHope2Zvcih2YXIgWD0tMSxldD1XZSh6Lmxlbmd0aCxDKTsrK1g8ZXQ7KXpbWF09b1tYXS5jYWxsKHRoaXMseltYXSk7cmV0dXJuIFhlKHIsdGhpcyx6KX0pfSkseG89dGUoZnVuY3Rpb24ocixvKXt2YXIgQz1OcihvLFBuKHhvKSk7cmV0dXJuIE1yKHIsdix0LG8sQyl9KSx1Zj10ZShmdW5jdGlvbihyLG8pe3ZhciBDPU5yKG8sUG4odWYpKTtyZXR1cm4gTXIocixULHQsbyxDKX0pLHhNPVNyKGZ1bmN0aW9uKHIsbyl7cmV0dXJuIE1yKHIsTCx0LHQsdCxvKX0pO2Z1bmN0aW9uIE9NKHIsbyl7aWYodHlwZW9mIHIhPSJmdW5jdGlvbiIpdGhyb3cgbmV3IGVyKGgpO3JldHVybiBvPW89PT10P286cXQobyksdGUocixvKX1mdW5jdGlvbiBFTShyLG8pe2lmKHR5cGVvZiByIT0iZnVuY3Rpb24iKXRocm93IG5ldyBlcihoKTtyZXR1cm4gbz1vPT1udWxsPzA6RGUocXQobyksMCksdGUoZnVuY3Rpb24oQyl7dmFyIHo9Q1tvXSxYPVVyKEMsMCxvKTtyZXR1cm4geiYmd3IoWCx6KSxYZShyLHRoaXMsWCl9KX1mdW5jdGlvbiBNTShyLG8sQyl7dmFyIHo9ITAsWD0hMDtpZih0eXBlb2YgciE9ImZ1bmN0aW9uIil0aHJvdyBuZXcgZXIoaCk7cmV0dXJuIE1lKEMpJiYoej0ibGVhZGluZyJpbiBDPyEhQy5sZWFkaW5nOnosWD0idHJhaWxpbmciaW4gQz8hIUMudHJhaWxpbmc6WCksbGYocixvLHtsZWFkaW5nOnosbWF4V2FpdDpvLHRyYWlsaW5nOlh9KX1mdW5jdGlvbiBTTShyKXtyZXR1cm4gcmYociwxKX1mdW5jdGlvbiBUTShyLG8pe3JldHVybiB4byhybyhvKSxyKX1mdW5jdGlvbiBQTSgpe2lmKCFhcmd1bWVudHMubGVuZ3RoKXJldHVybltdO3ZhciByPWFyZ3VtZW50c1swXTtyZXR1cm4ga3Qocik/cjpbcl19ZnVuY3Rpb24gYk0ocil7cmV0dXJuIG5yKHIsbSl9ZnVuY3Rpb24gQU0ocixvKXtyZXR1cm4gbz10eXBlb2Ygbz09ImZ1bmN0aW9uIj9vOnQsbnIocixtLG8pfWZ1bmN0aW9uIENNKHIpe3JldHVybiBucihyLHB8bSl9ZnVuY3Rpb24gUk0ocixvKXtyZXR1cm4gbz10eXBlb2Ygbz09ImZ1bmN0aW9uIj9vOnQsbnIocixwfG0sbyl9ZnVuY3Rpb24gSU0ocixvKXtyZXR1cm4gbz09bnVsbHx8SmwocixvLHdlKG8pKX1mdW5jdGlvbiBjcihyLG8pe3JldHVybiByPT09b3x8ciE9PXImJm8hPT1vfXZhciBMTT1VaShIcyksRE09VWkoZnVuY3Rpb24ocixvKXtyZXR1cm4gcj49b30pLHRuPWV1KGZ1bmN0aW9uKCl7cmV0dXJuIGFyZ3VtZW50c30oKSk/ZXU6ZnVuY3Rpb24ocil7cmV0dXJuIFBlKHIpJiZmZS5jYWxsKHIsImNhbGxlZSIpJiYhJGwuY2FsbChyLCJjYWxsZWUiKX0sa3Q9UHQuaXNBcnJheSx3TT1NbD9aZShNbCk6JHg7ZnVuY3Rpb24gS2Uocil7cmV0dXJuIHIhPW51bGwmJlppKHIubGVuZ3RoKSYmIVByKHIpfWZ1bmN0aW9uIEFlKHIpe3JldHVybiBQZShyKSYmS2Uocil9ZnVuY3Rpb24gTk0ocil7cmV0dXJuIHI9PT0hMHx8cj09PSExfHxQZShyKSYmamUocik9PU90fXZhciB6cj1aMnx8SW8sQk09U2w/WmUoU2wpOkd4O2Z1bmN0aW9uIFdNKHIpe3JldHVybiBQZShyKSYmci5ub2RlVHlwZT09PTEmJiFZbihyKX1mdW5jdGlvbiBGTShyKXtpZihyPT1udWxsKXJldHVybiEwO2lmKEtlKHIpJiYoa3Qocil8fHR5cGVvZiByPT0ic3RyaW5nInx8dHlwZW9mIHIuc3BsaWNlPT0iZnVuY3Rpb24ifHx6cihyKXx8Ym4ocil8fHRuKHIpKSlyZXR1cm4hci5sZW5ndGg7dmFyIG89RmUocik7aWYobz09SHx8bz09bnQpcmV0dXJuIXIuc2l6ZTtpZihLbihyKSlyZXR1cm4hWHMocikubGVuZ3RoO2Zvcih2YXIgQyBpbiByKWlmKGZlLmNhbGwocixDKSlyZXR1cm4hMTtyZXR1cm4hMH1mdW5jdGlvbiBqTShyLG8pe3JldHVybiB6bihyLG8pfWZ1bmN0aW9uIFVNKHIsbyxDKXtDPXR5cGVvZiBDPT0iZnVuY3Rpb24iP0M6dDt2YXIgej1DP0MocixvKTp0O3JldHVybiB6PT09dD96bihyLG8sdCxDKTohIXp9ZnVuY3Rpb24gT28ocil7aWYoIVBlKHIpKXJldHVybiExO3ZhciBvPWplKHIpO3JldHVybiBvPT1RfHxvPT0kfHx0eXBlb2Ygci5tZXNzYWdlPT0ic3RyaW5nIiYmdHlwZW9mIHIubmFtZT09InN0cmluZyImJiFZbihyKX1mdW5jdGlvbiB6TShyKXtyZXR1cm4gdHlwZW9mIHI9PSJudW1iZXIiJiZLbChyKX1mdW5jdGlvbiBQcihyKXtpZighTWUocikpcmV0dXJuITE7dmFyIG89amUocik7cmV0dXJuIG89PXR0fHxvPT1GfHxvPT1NdHx8bz09Wn1mdW5jdGlvbiBmZihyKXtyZXR1cm4gdHlwZW9mIHI9PSJudW1iZXIiJiZyPT1xdChyKX1mdW5jdGlvbiBaaShyKXtyZXR1cm4gdHlwZW9mIHI9PSJudW1iZXIiJiZyPi0xJiZyJTE9PTAmJnI8PV99ZnVuY3Rpb24gTWUocil7dmFyIG89dHlwZW9mIHI7cmV0dXJuIHIhPW51bGwmJihvPT0ib2JqZWN0Inx8bz09ImZ1bmN0aW9uIil9ZnVuY3Rpb24gUGUocil7cmV0dXJuIHIhPW51bGwmJnR5cGVvZiByPT0ib2JqZWN0In12YXIgY2Y9VGw/WmUoVGwpOkh4O2Z1bmN0aW9uICRNKHIsbyl7cmV0dXJuIHI9PT1vfHxWcyhyLG8sdW8obykpfWZ1bmN0aW9uIEdNKHIsbyxDKXtyZXR1cm4gQz10eXBlb2YgQz09ImZ1bmN0aW9uIj9DOnQsVnMocixvLHVvKG8pLEMpfWZ1bmN0aW9uIEtNKHIpe3JldHVybiBoZihyKSYmciE9K3J9ZnVuY3Rpb24gSE0ocil7aWYoQU8ocikpdGhyb3cgbmV3IFF0KGYpO3JldHVybiBydShyKX1mdW5jdGlvbiBZTShyKXtyZXR1cm4gcj09PW51bGx9ZnVuY3Rpb24gVk0ocil7cmV0dXJuIHI9PW51bGx9ZnVuY3Rpb24gaGYocil7cmV0dXJuIHR5cGVvZiByPT0ibnVtYmVyInx8UGUocikmJmplKHIpPT14fWZ1bmN0aW9uIFluKHIpe2lmKCFQZShyKXx8amUocikhPVcpcmV0dXJuITE7dmFyIG89RWkocik7aWYobz09PW51bGwpcmV0dXJuITA7dmFyIEM9ZmUuY2FsbChvLCJjb25zdHJ1Y3RvciIpJiZvLmNvbnN0cnVjdG9yO3JldHVybiB0eXBlb2YgQz09ImZ1bmN0aW9uIiYmQyBpbnN0YW5jZW9mIEMmJm1pLmNhbGwoQyk9PUcyfXZhciBFbz1QbD9aZShQbCk6WXg7ZnVuY3Rpb24gWE0ocil7cmV0dXJuIGZmKHIpJiZyPj0tXyYmcjw9X312YXIgZGY9Ymw/WmUoYmwpOlZ4O2Z1bmN0aW9uIEppKHIpe3JldHVybiB0eXBlb2Ygcj09InN0cmluZyJ8fCFrdChyKSYmUGUocikmJmplKHIpPT11dH1mdW5jdGlvbiBRZShyKXtyZXR1cm4gdHlwZW9mIHI9PSJzeW1ib2wifHxQZShyKSYmamUocik9PWN0fXZhciBibj1BbD9aZShBbCk6WHg7ZnVuY3Rpb24gWk0ocil7cmV0dXJuIHI9PT10fWZ1bmN0aW9uIEpNKHIpe3JldHVybiBQZShyKSYmRmUocik9PXh0fWZ1bmN0aW9uIFFNKHIpe3JldHVybiBQZShyKSYmamUocik9PWd0fXZhciBrTT1VaShacykscU09VWkoZnVuY3Rpb24ocixvKXtyZXR1cm4gcjw9b30pO2Z1bmN0aW9uIGdmKHIpe2lmKCFyKXJldHVybltdO2lmKEtlKHIpKXJldHVybiBKaShyKT91cihyKTpHZShyKTtpZihEbiYmcltEbl0pcmV0dXJuIEkyKHJbRG5dKCkpO3ZhciBvPUZlKHIpLEM9bz09SD9CczpvPT1udD9naTpBbjtyZXR1cm4gQyhyKX1mdW5jdGlvbiBicihyKXtpZighcilyZXR1cm4gcj09PTA/cjowO2lmKHI9b3Iocikscj09PUp8fHI9PT0tSil7dmFyIG89cjwwPy0xOjE7cmV0dXJuIG8qc3R9cmV0dXJuIHI9PT1yP3I6MH1mdW5jdGlvbiBxdChyKXt2YXIgbz1icihyKSxDPW8lMTtyZXR1cm4gbz09PW8/Qz9vLUM6bzowfWZ1bmN0aW9uIHZmKHIpe3JldHVybiByP1FyKHF0KHIpLDAsWSk6MH1mdW5jdGlvbiBvcihyKXtpZih0eXBlb2Ygcj09Im51bWJlciIpcmV0dXJuIHI7aWYoUWUocikpcmV0dXJuIEc7aWYoTWUocikpe3ZhciBvPXR5cGVvZiByLnZhbHVlT2Y9PSJmdW5jdGlvbiI/ci52YWx1ZU9mKCk6cjtyPU1lKG8pP28rIiI6b31pZih0eXBlb2YgciE9InN0cmluZyIpcmV0dXJuIHI9PT0wP3I6K3I7cj13bChyKTt2YXIgQz13eS50ZXN0KHIpO3JldHVybiBDfHxCeS50ZXN0KHIpP2QyKHIuc2xpY2UoMiksQz8yOjgpOkR5LnRlc3Qocik/Rzorcn1mdW5jdGlvbiBwZihyKXtyZXR1cm4gdnIocixIZShyKSl9ZnVuY3Rpb24gX00ocil7cmV0dXJuIHI/UXIocXQociksLV8sXyk6cj09PTA/cjowfWZ1bmN0aW9uIHVlKHIpe3JldHVybiByPT1udWxsPyIiOkplKHIpfXZhciB0Uz1TbihmdW5jdGlvbihyLG8pe2lmKEtuKG8pfHxLZShvKSl7dnIobyx3ZShvKSxyKTtyZXR1cm59Zm9yKHZhciBDIGluIG8pZmUuY2FsbChvLEMpJiZGbihyLEMsb1tDXSl9KSxtZj1TbihmdW5jdGlvbihyLG8pe3ZyKG8sSGUobykscil9KSxRaT1TbihmdW5jdGlvbihyLG8sQyx6KXt2cihvLEhlKG8pLHIseil9KSxlUz1TbihmdW5jdGlvbihyLG8sQyx6KXt2cihvLHdlKG8pLHIseil9KSxyUz1Tcigkcyk7ZnVuY3Rpb24gblMocixvKXt2YXIgQz1NbihyKTtyZXR1cm4gbz09bnVsbD9DOlpsKEMsbyl9dmFyIGlTPXRlKGZ1bmN0aW9uKHIsbyl7cj1oZShyKTt2YXIgQz0tMSx6PW8ubGVuZ3RoLFg9ej4yP29bMl06dDtmb3IoWCYmVWUob1swXSxvWzFdLFgpJiYoej0xKTsrK0M8ejspZm9yKHZhciBldD1vW0NdLGx0PUhlKGV0KSxmdD0tMSx5dD1sdC5sZW5ndGg7KytmdDx5dDspe3ZhciBSdD1sdFtmdF0sSXQ9cltSdF07KEl0PT09dHx8Y3IoSXQseG5bUnRdKSYmIWZlLmNhbGwocixSdCkpJiYocltSdF09ZXRbUnRdKX1yZXR1cm4gcn0pLHNTPXRlKGZ1bmN0aW9uKHIpe3JldHVybiByLnB1c2godCx3dSksWGUoeWYsdCxyKX0pO2Z1bmN0aW9uIG9TKHIsbyl7cmV0dXJuIFJsKHIsSHQobywzKSxncil9ZnVuY3Rpb24gYVMocixvKXtyZXR1cm4gUmwocixIdChvLDMpLEtzKX1mdW5jdGlvbiBsUyhyLG8pe3JldHVybiByPT1udWxsP3I6R3MocixIdChvLDMpLEhlKX1mdW5jdGlvbiB1UyhyLG8pe3JldHVybiByPT1udWxsP3I6X2wocixIdChvLDMpLEhlKX1mdW5jdGlvbiBmUyhyLG8pe3JldHVybiByJiZncihyLEh0KG8sMykpfWZ1bmN0aW9uIGNTKHIsbyl7cmV0dXJuIHImJktzKHIsSHQobywzKSl9ZnVuY3Rpb24gaFMocil7cmV0dXJuIHI9PW51bGw/W106TGkocix3ZShyKSl9ZnVuY3Rpb24gZFMocil7cmV0dXJuIHI9PW51bGw/W106TGkocixIZShyKSl9ZnVuY3Rpb24gTW8ocixvLEMpe3ZhciB6PXI9PW51bGw/dDprcihyLG8pO3JldHVybiB6PT09dD9DOnp9ZnVuY3Rpb24gZ1MocixvKXtyZXR1cm4gciE9bnVsbCYmV3UocixvLEZ4KX1mdW5jdGlvbiBTbyhyLG8pe3JldHVybiByIT1udWxsJiZXdShyLG8sangpfXZhciB2Uz1DdShmdW5jdGlvbihyLG8sQyl7byE9bnVsbCYmdHlwZW9mIG8udG9TdHJpbmchPSJmdW5jdGlvbiImJihvPXlpLmNhbGwobykpLHJbb109Q30sUG8oWWUpKSxwUz1DdShmdW5jdGlvbihyLG8sQyl7byE9bnVsbCYmdHlwZW9mIG8udG9TdHJpbmchPSJmdW5jdGlvbiImJihvPXlpLmNhbGwobykpLGZlLmNhbGwocixvKT9yW29dLnB1c2goQyk6cltvXT1bQ119LEh0KSxtUz10ZShVbik7ZnVuY3Rpb24gd2Uocil7cmV0dXJuIEtlKHIpP1ZsKHIpOlhzKHIpfWZ1bmN0aW9uIEhlKHIpe3JldHVybiBLZShyKT9WbChyLCEwKTpaeChyKX1mdW5jdGlvbiB5UyhyLG8pe3ZhciBDPXt9O3JldHVybiBvPUh0KG8sMyksZ3IocixmdW5jdGlvbih6LFgsZXQpe0VyKEMsbyh6LFgsZXQpLHopfSksQ31mdW5jdGlvbiB4UyhyLG8pe3ZhciBDPXt9O3JldHVybiBvPUh0KG8sMyksZ3IocixmdW5jdGlvbih6LFgsZXQpe0VyKEMsWCxvKHosWCxldCkpfSksQ312YXIgT1M9U24oZnVuY3Rpb24ocixvLEMpe0RpKHIsbyxDKX0pLHlmPVNuKGZ1bmN0aW9uKHIsbyxDLHope0RpKHIsbyxDLHopfSksRVM9U3IoZnVuY3Rpb24ocixvKXt2YXIgQz17fTtpZihyPT1udWxsKXJldHVybiBDO3ZhciB6PSExO289eWUobyxmdW5jdGlvbihldCl7cmV0dXJuIGV0PWpyKGV0LHIpLHp8fCh6PWV0Lmxlbmd0aD4xKSxldH0pLHZyKHIsYW8ociksQykseiYmKEM9bnIoQyxwfE98bSx2TykpO2Zvcih2YXIgWD1vLmxlbmd0aDtYLS07KV9zKEMsb1tYXSk7cmV0dXJuIEN9KTtmdW5jdGlvbiBNUyhyLG8pe3JldHVybiB4ZihyLFhpKEh0KG8pKSl9dmFyIFNTPVNyKGZ1bmN0aW9uKHIsbyl7cmV0dXJuIHI9PW51bGw/e306UXgocixvKX0pO2Z1bmN0aW9uIHhmKHIsbyl7aWYocj09bnVsbClyZXR1cm57fTt2YXIgQz15ZShhbyhyKSxmdW5jdGlvbih6KXtyZXR1cm5bel19KTtyZXR1cm4gbz1IdChvKSx1dShyLEMsZnVuY3Rpb24oeixYKXtyZXR1cm4gbyh6LFhbMF0pfSl9ZnVuY3Rpb24gVFMocixvLEMpe289anIobyxyKTt2YXIgej0tMSxYPW8ubGVuZ3RoO2ZvcihYfHwoWD0xLHI9dCk7Kyt6PFg7KXt2YXIgZXQ9cj09bnVsbD90OnJbcHIob1t6XSldO2V0PT09dCYmKHo9WCxldD1DKSxyPVByKGV0KT9ldC5jYWxsKHIpOmV0fXJldHVybiByfWZ1bmN0aW9uIFBTKHIsbyxDKXtyZXR1cm4gcj09bnVsbD9yOiRuKHIsbyxDKX1mdW5jdGlvbiBiUyhyLG8sQyx6KXtyZXR1cm4gej10eXBlb2Ygej09ImZ1bmN0aW9uIj96OnQscj09bnVsbD9yOiRuKHIsbyxDLHopfXZhciBPZj1MdSh3ZSksRWY9THUoSGUpO2Z1bmN0aW9uIEFTKHIsbyxDKXt2YXIgej1rdChyKSxYPXp8fHpyKHIpfHxibihyKTtpZihvPUh0KG8sNCksQz09bnVsbCl7dmFyIGV0PXImJnIuY29uc3RydWN0b3I7WD9DPXo/bmV3IGV0OltdOk1lKHIpP0M9UHIoZXQpP01uKEVpKHIpKTp7fTpDPXt9fXJldHVybihYP3RyOmdyKShyLGZ1bmN0aW9uKGx0LGZ0LHl0KXtyZXR1cm4gbyhDLGx0LGZ0LHl0KX0pLEN9ZnVuY3Rpb24gQ1MocixvKXtyZXR1cm4gcj09bnVsbD8hMDpfcyhyLG8pfWZ1bmN0aW9uIFJTKHIsbyxDKXtyZXR1cm4gcj09bnVsbD9yOmd1KHIsbyxybyhDKSl9ZnVuY3Rpb24gSVMocixvLEMseil7cmV0dXJuIHo9dHlwZW9mIHo9PSJmdW5jdGlvbiI/ejp0LHI9PW51bGw/cjpndShyLG8scm8oQykseil9ZnVuY3Rpb24gQW4ocil7cmV0dXJuIHI9PW51bGw/W106TnMocix3ZShyKSl9ZnVuY3Rpb24gTFMocil7cmV0dXJuIHI9PW51bGw/W106TnMocixIZShyKSl9ZnVuY3Rpb24gRFMocixvLEMpe3JldHVybiBDPT09dCYmKEM9byxvPXQpLEMhPT10JiYoQz1vcihDKSxDPUM9PT1DP0M6MCksbyE9PXQmJihvPW9yKG8pLG89bz09PW8/bzowKSxRcihvcihyKSxvLEMpfWZ1bmN0aW9uIHdTKHIsbyxDKXtyZXR1cm4gbz1icihvKSxDPT09dD8oQz1vLG89MCk6Qz1icihDKSxyPW9yKHIpLFV4KHIsbyxDKX1mdW5jdGlvbiBOUyhyLG8sQyl7aWYoQyYmdHlwZW9mIEMhPSJib29sZWFuIiYmVWUocixvLEMpJiYobz1DPXQpLEM9PT10JiYodHlwZW9mIG89PSJib29sZWFuIj8oQz1vLG89dCk6dHlwZW9mIHI9PSJib29sZWFuIiYmKEM9cixyPXQpKSxyPT09dCYmbz09PXQ/KHI9MCxvPTEpOihyPWJyKHIpLG89PT10PyhvPXIscj0wKTpvPWJyKG8pKSxyPm8pe3ZhciB6PXI7cj1vLG89en1pZihDfHxyJTF8fG8lMSl7dmFyIFg9SGwoKTtyZXR1cm4gV2UocitYKihvLXIraDIoIjFlLSIrKChYKyIiKS5sZW5ndGgtMSkpKSxvKX1yZXR1cm4gUXMocixvKX12YXIgQlM9VG4oZnVuY3Rpb24ocixvLEMpe3JldHVybiBvPW8udG9Mb3dlckNhc2UoKSxyKyhDP01mKG8pOm8pfSk7ZnVuY3Rpb24gTWYocil7cmV0dXJuIFRvKHVlKHIpLnRvTG93ZXJDYXNlKCkpfWZ1bmN0aW9uIFNmKHIpe3JldHVybiByPXVlKHIpLHImJnIucmVwbGFjZShGeSxQMikucmVwbGFjZShyMiwiIil9ZnVuY3Rpb24gV1MocixvLEMpe3I9dWUociksbz1KZShvKTt2YXIgej1yLmxlbmd0aDtDPUM9PT10P3o6UXIocXQoQyksMCx6KTt2YXIgWD1DO3JldHVybiBDLT1vLmxlbmd0aCxDPj0wJiZyLnNsaWNlKEMsWCk9PW99ZnVuY3Rpb24gRlMocil7cmV0dXJuIHI9dWUociksciYmSWUudGVzdChyKT9yLnJlcGxhY2UoVGUsYjIpOnJ9ZnVuY3Rpb24galMocil7cmV0dXJuIHI9dWUociksciYmU3kudGVzdChyKT9yLnJlcGxhY2UoeXMsIlxcJCYiKTpyfXZhciBVUz1UbihmdW5jdGlvbihyLG8sQyl7cmV0dXJuIHIrKEM/Ii0iOiIiKStvLnRvTG93ZXJDYXNlKCl9KSx6Uz1UbihmdW5jdGlvbihyLG8sQyl7cmV0dXJuIHIrKEM/IiAiOiIiKStvLnRvTG93ZXJDYXNlKCl9KSwkUz1QdSgidG9Mb3dlckNhc2UiKTtmdW5jdGlvbiBHUyhyLG8sQyl7cj11ZShyKSxvPXF0KG8pO3ZhciB6PW8/bW4ocik6MDtpZighb3x8ej49bylyZXR1cm4gcjt2YXIgWD0oby16KS8yO3JldHVybiBqaShQaShYKSxDKStyK2ppKFRpKFgpLEMpfWZ1bmN0aW9uIEtTKHIsbyxDKXtyPXVlKHIpLG89cXQobyk7dmFyIHo9bz9tbihyKTowO3JldHVybiBvJiZ6PG8/citqaShvLXosQyk6cn1mdW5jdGlvbiBIUyhyLG8sQyl7cj11ZShyKSxvPXF0KG8pO3ZhciB6PW8/bW4ocik6MDtyZXR1cm4gbyYmejxvP2ppKG8teixDKStyOnJ9ZnVuY3Rpb24gWVMocixvLEMpe3JldHVybiBDfHxvPT1udWxsP289MDpvJiYobz0rbykscTIodWUocikucmVwbGFjZSh4cywiIiksb3x8MCl9ZnVuY3Rpb24gVlMocixvLEMpe3JldHVybihDP1VlKHIsbyxDKTpvPT09dCk/bz0xOm89cXQobyksa3ModWUociksbyl9ZnVuY3Rpb24gWFMoKXt2YXIgcj1hcmd1bWVudHMsbz11ZShyWzBdKTtyZXR1cm4gci5sZW5ndGg8Mz9vOm8ucmVwbGFjZShyWzFdLHJbMl0pfXZhciBaUz1UbihmdW5jdGlvbihyLG8sQyl7cmV0dXJuIHIrKEM/Il8iOiIiKStvLnRvTG93ZXJDYXNlKCl9KTtmdW5jdGlvbiBKUyhyLG8sQyl7cmV0dXJuIEMmJnR5cGVvZiBDIT0ibnVtYmVyIiYmVWUocixvLEMpJiYobz1DPXQpLEM9Qz09PXQ/WTpDPj4+MCxDPyhyPXVlKHIpLHImJih0eXBlb2Ygbz09InN0cmluZyJ8fG8hPW51bGwmJiFFbyhvKSkmJihvPUplKG8pLCFvJiZwbihyKSk/VXIodXIociksMCxDKTpyLnNwbGl0KG8sQykpOltdfXZhciBRUz1UbihmdW5jdGlvbihyLG8sQyl7cmV0dXJuIHIrKEM/IiAiOiIiKStUbyhvKX0pO2Z1bmN0aW9uIGtTKHIsbyxDKXtyZXR1cm4gcj11ZShyKSxDPUM9PW51bGw/MDpRcihxdChDKSwwLHIubGVuZ3RoKSxvPUplKG8pLHIuc2xpY2UoQyxDK28ubGVuZ3RoKT09b31mdW5jdGlvbiBxUyhyLG8sQyl7dmFyIHo9cS50ZW1wbGF0ZVNldHRpbmdzO0MmJlVlKHIsbyxDKSYmKG89dCkscj11ZShyKSxvPVFpKHt9LG8seixEdSk7dmFyIFg9UWkoe30sby5pbXBvcnRzLHouaW1wb3J0cyxEdSksZXQ9d2UoWCksbHQ9TnMoWCxldCksZnQseXQsUnQ9MCxJdD1vLmludGVycG9sYXRlfHx1aSx3dD0iX19wICs9ICciLFd0PVdzKChvLmVzY2FwZXx8dWkpLnNvdXJjZSsifCIrSXQuc291cmNlKyJ8IisoSXQ9PT1Mcj9MeTp1aSkuc291cmNlKyJ8Iisoby5ldmFsdWF0ZXx8dWkpLnNvdXJjZSsifCQiLCJnIiksVXQ9Ii8vIyBzb3VyY2VVUkw9IisoZmUuY2FsbChvLCJzb3VyY2VVUkwiKT8oby5zb3VyY2VVUkwrIiIpLnJlcGxhY2UoL1xzL2csIiAiKToibG9kYXNoLnRlbXBsYXRlU291cmNlc1siKyArK2EyKyJdIikrYApgO3IucmVwbGFjZShXdCxmdW5jdGlvbihadCxlZSxuZSxrZSx6ZSxxZSl7cmV0dXJuIG5lfHwobmU9a2UpLHd0Kz1yLnNsaWNlKFJ0LHFlKS5yZXBsYWNlKGp5LEEyKSxlZSYmKGZ0PSEwLHd0Kz1gJyArCl9fZShgK2VlK2ApICsKJ2ApLHplJiYoeXQ9ITAsd3QrPWAnOwpgK3plK2A7Cl9fcCArPSAnYCksbmUmJih3dCs9YCcgKwooKF9fdCA9IChgK25lK2ApKSA9PSBudWxsID8gJycgOiBfX3QpICsKJ2ApLFJ0PXFlK1p0Lmxlbmd0aCxadH0pLHd0Kz1gJzsKYDt2YXIgWHQ9ZmUuY2FsbChvLCJ2YXJpYWJsZSIpJiZvLnZhcmlhYmxlO2lmKCFYdCl3dD1gd2l0aCAob2JqKSB7CmArd3QrYAp9CmA7ZWxzZSBpZihSeS50ZXN0KFh0KSl0aHJvdyBuZXcgUXQodSk7d3Q9KHl0P3d0LnJlcGxhY2UoU2UsIiIpOnd0KS5yZXBsYWNlKE9lLCIkMSIpLnJlcGxhY2UoRWUsIiQxOyIpLHd0PSJmdW5jdGlvbigiKyhYdHx8Im9iaiIpK2ApIHsKYCsoWHQ/IiI6YG9iaiB8fCAob2JqID0ge30pOwpgKSsidmFyIF9fdCwgX19wID0gJyciKyhmdD8iLCBfX2UgPSBfLmVzY2FwZSI6IiIpKyh5dD9gLCBfX2ogPSBBcnJheS5wcm90b3R5cGUuam9pbjsKZnVuY3Rpb24gcHJpbnQoKSB7IF9fcCArPSBfX2ouY2FsbChhcmd1bWVudHMsICcnKSB9CmA6YDsKYCkrd3QrYHJldHVybiBfX3AKfWA7dmFyIF90PVBmKGZ1bmN0aW9uKCl7cmV0dXJuIGFlKGV0LFV0KyJyZXR1cm4gIit3dCkuYXBwbHkodCxsdCl9KTtpZihfdC5zb3VyY2U9d3QsT28oX3QpKXRocm93IF90O3JldHVybiBfdH1mdW5jdGlvbiBfUyhyKXtyZXR1cm4gdWUocikudG9Mb3dlckNhc2UoKX1mdW5jdGlvbiB0VChyKXtyZXR1cm4gdWUocikudG9VcHBlckNhc2UoKX1mdW5jdGlvbiBlVChyLG8sQyl7aWYocj11ZShyKSxyJiYoQ3x8bz09PXQpKXJldHVybiB3bChyKTtpZighcnx8IShvPUplKG8pKSlyZXR1cm4gcjt2YXIgej11cihyKSxYPXVyKG8pLGV0PU5sKHosWCksbHQ9QmwoeixYKSsxO3JldHVybiBVcih6LGV0LGx0KS5qb2luKCIiKX1mdW5jdGlvbiByVChyLG8sQyl7aWYocj11ZShyKSxyJiYoQ3x8bz09PXQpKXJldHVybiByLnNsaWNlKDAsRmwocikrMSk7aWYoIXJ8fCEobz1KZShvKSkpcmV0dXJuIHI7dmFyIHo9dXIociksWD1CbCh6LHVyKG8pKSsxO3JldHVybiBVcih6LDAsWCkuam9pbigiIil9ZnVuY3Rpb24gblQocixvLEMpe2lmKHI9dWUociksciYmKEN8fG89PT10KSlyZXR1cm4gci5yZXBsYWNlKHhzLCIiKTtpZighcnx8IShvPUplKG8pKSlyZXR1cm4gcjt2YXIgej11cihyKSxYPU5sKHosdXIobykpO3JldHVybiBVcih6LFgpLmpvaW4oIiIpfWZ1bmN0aW9uIGlUKHIsbyl7dmFyIEM9QSx6PXc7aWYoTWUobykpe3ZhciBYPSJzZXBhcmF0b3IiaW4gbz9vLnNlcGFyYXRvcjpYO0M9Imxlbmd0aCJpbiBvP3F0KG8ubGVuZ3RoKTpDLHo9Im9taXNzaW9uImluIG8/SmUoby5vbWlzc2lvbik6en1yPXVlKHIpO3ZhciBldD1yLmxlbmd0aDtpZihwbihyKSl7dmFyIGx0PXVyKHIpO2V0PWx0Lmxlbmd0aH1pZihDPj1ldClyZXR1cm4gcjt2YXIgZnQ9Qy1tbih6KTtpZihmdDwxKXJldHVybiB6O3ZhciB5dD1sdD9VcihsdCwwLGZ0KS5qb2luKCIiKTpyLnNsaWNlKDAsZnQpO2lmKFg9PT10KXJldHVybiB5dCt6O2lmKGx0JiYoZnQrPXl0Lmxlbmd0aC1mdCksRW8oWCkpe2lmKHIuc2xpY2UoZnQpLnNlYXJjaChYKSl7dmFyIFJ0LEl0PXl0O2ZvcihYLmdsb2JhbHx8KFg9V3MoWC5zb3VyY2UsdWUoZWwuZXhlYyhYKSkrImciKSksWC5sYXN0SW5kZXg9MDtSdD1YLmV4ZWMoSXQpOyl2YXIgd3Q9UnQuaW5kZXg7eXQ9eXQuc2xpY2UoMCx3dD09PXQ/ZnQ6d3QpfX1lbHNlIGlmKHIuaW5kZXhPZihKZShYKSxmdCkhPWZ0KXt2YXIgV3Q9eXQubGFzdEluZGV4T2YoWCk7V3Q+LTEmJih5dD15dC5zbGljZSgwLFd0KSl9cmV0dXJuIHl0K3p9ZnVuY3Rpb24gc1Qocil7cmV0dXJuIHI9dWUociksciYmYmUudGVzdChyKT9yLnJlcGxhY2UobWUsTjIpOnJ9dmFyIG9UPVRuKGZ1bmN0aW9uKHIsbyxDKXtyZXR1cm4gcisoQz8iICI6IiIpK28udG9VcHBlckNhc2UoKX0pLFRvPVB1KCJ0b1VwcGVyQ2FzZSIpO2Z1bmN0aW9uIFRmKHIsbyxDKXtyZXR1cm4gcj11ZShyKSxvPUM/dDpvLG89PT10P1IyKHIpP0YyKHIpOk8yKHIpOnIubWF0Y2gobyl8fFtdfXZhciBQZj10ZShmdW5jdGlvbihyLG8pe3RyeXtyZXR1cm4gWGUocix0LG8pfWNhdGNoKEMpe3JldHVybiBPbyhDKT9DOm5ldyBRdChDKX19KSxhVD1TcihmdW5jdGlvbihyLG8pe3JldHVybiB0cihvLGZ1bmN0aW9uKEMpe0M9cHIoQyksRXIocixDLHlvKHJbQ10scikpfSkscn0pO2Z1bmN0aW9uIGxUKHIpe3ZhciBvPXI9PW51bGw/MDpyLmxlbmd0aCxDPUh0KCk7cmV0dXJuIHI9bz95ZShyLGZ1bmN0aW9uKHope2lmKHR5cGVvZiB6WzFdIT0iZnVuY3Rpb24iKXRocm93IG5ldyBlcihoKTtyZXR1cm5bQyh6WzBdKSx6WzFdXX0pOltdLHRlKGZ1bmN0aW9uKHope2Zvcih2YXIgWD0tMTsrK1g8bzspe3ZhciBldD1yW1hdO2lmKFhlKGV0WzBdLHRoaXMseikpcmV0dXJuIFhlKGV0WzFdLHRoaXMseil9fSl9ZnVuY3Rpb24gdVQocil7cmV0dXJuIE54KG5yKHIscCkpfWZ1bmN0aW9uIFBvKHIpe3JldHVybiBmdW5jdGlvbigpe3JldHVybiByfX1mdW5jdGlvbiBmVChyLG8pe3JldHVybiByPT1udWxsfHxyIT09cj9vOnJ9dmFyIGNUPUF1KCksaFQ9QXUoITApO2Z1bmN0aW9uIFllKHIpe3JldHVybiByfWZ1bmN0aW9uIGJvKHIpe3JldHVybiBudSh0eXBlb2Ygcj09ImZ1bmN0aW9uIj9yOm5yKHIscCkpfWZ1bmN0aW9uIGRUKHIpe3JldHVybiBzdShucihyLHApKX1mdW5jdGlvbiBnVChyLG8pe3JldHVybiBvdShyLG5yKG8scCkpfXZhciB2VD10ZShmdW5jdGlvbihyLG8pe3JldHVybiBmdW5jdGlvbihDKXtyZXR1cm4gVW4oQyxyLG8pfX0pLHBUPXRlKGZ1bmN0aW9uKHIsbyl7cmV0dXJuIGZ1bmN0aW9uKEMpe3JldHVybiBVbihyLEMsbyl9fSk7ZnVuY3Rpb24gQW8ocixvLEMpe3ZhciB6PXdlKG8pLFg9TGkobyx6KTtDPT1udWxsJiYhKE1lKG8pJiYoWC5sZW5ndGh8fCF6Lmxlbmd0aCkpJiYoQz1vLG89cixyPXRoaXMsWD1MaShvLHdlKG8pKSk7dmFyIGV0PSEoTWUoQykmJiJjaGFpbiJpbiBDKXx8ISFDLmNoYWluLGx0PVByKHIpO3JldHVybiB0cihYLGZ1bmN0aW9uKGZ0KXt2YXIgeXQ9b1tmdF07cltmdF09eXQsbHQmJihyLnByb3RvdHlwZVtmdF09ZnVuY3Rpb24oKXt2YXIgUnQ9dGhpcy5fX2NoYWluX187aWYoZXR8fFJ0KXt2YXIgSXQ9cih0aGlzLl9fd3JhcHBlZF9fKSx3dD1JdC5fX2FjdGlvbnNfXz1HZSh0aGlzLl9fYWN0aW9uc19fKTtyZXR1cm4gd3QucHVzaCh7ZnVuYzp5dCxhcmdzOmFyZ3VtZW50cyx0aGlzQXJnOnJ9KSxJdC5fX2NoYWluX189UnQsSXR9cmV0dXJuIHl0LmFwcGx5KHIsd3IoW3RoaXMudmFsdWUoKV0sYXJndW1lbnRzKSl9KX0pLHJ9ZnVuY3Rpb24gbVQoKXtyZXR1cm4gTmUuXz09PXRoaXMmJihOZS5fPUsyKSx0aGlzfWZ1bmN0aW9uIENvKCl7fWZ1bmN0aW9uIHlUKHIpe3JldHVybiByPXF0KHIpLHRlKGZ1bmN0aW9uKG8pe3JldHVybiBhdShvLHIpfSl9dmFyIHhUPWlvKHllKSxPVD1pbyhDbCksRVQ9aW8oUnMpO2Z1bmN0aW9uIGJmKHIpe3JldHVybiBjbyhyKT9JcyhwcihyKSk6a3gocil9ZnVuY3Rpb24gTVQocil7cmV0dXJuIGZ1bmN0aW9uKG8pe3JldHVybiByPT1udWxsP3Q6a3IocixvKX19dmFyIFNUPVJ1KCksVFQ9UnUoITApO2Z1bmN0aW9uIFJvKCl7cmV0dXJuW119ZnVuY3Rpb24gSW8oKXtyZXR1cm4hMX1mdW5jdGlvbiBQVCgpe3JldHVybnt9fWZ1bmN0aW9uIGJUKCl7cmV0dXJuIiJ9ZnVuY3Rpb24gQVQoKXtyZXR1cm4hMH1mdW5jdGlvbiBDVChyLG8pe2lmKHI9cXQocikscjwxfHxyPl8pcmV0dXJuW107dmFyIEM9WSx6PVdlKHIsWSk7bz1IdChvKSxyLT1ZO2Zvcih2YXIgWD13cyh6LG8pOysrQzxyOylvKEMpO3JldHVybiBYfWZ1bmN0aW9uIFJUKHIpe3JldHVybiBrdChyKT95ZShyLHByKTpRZShyKT9bcl06R2UoWXUodWUocikpKX1mdW5jdGlvbiBJVChyKXt2YXIgbz0rKyQyO3JldHVybiB1ZShyKStvfXZhciBMVD1GaShmdW5jdGlvbihyLG8pe3JldHVybiByK299LDApLERUPXNvKCJjZWlsIiksd1Q9RmkoZnVuY3Rpb24ocixvKXtyZXR1cm4gci9vfSwxKSxOVD1zbygiZmxvb3IiKTtmdW5jdGlvbiBCVChyKXtyZXR1cm4gciYmci5sZW5ndGg/SWkocixZZSxIcyk6dH1mdW5jdGlvbiBXVChyLG8pe3JldHVybiByJiZyLmxlbmd0aD9JaShyLEh0KG8sMiksSHMpOnR9ZnVuY3Rpb24gRlQocil7cmV0dXJuIExsKHIsWWUpfWZ1bmN0aW9uIGpUKHIsbyl7cmV0dXJuIExsKHIsSHQobywyKSl9ZnVuY3Rpb24gVVQocil7cmV0dXJuIHImJnIubGVuZ3RoP0lpKHIsWWUsWnMpOnR9ZnVuY3Rpb24gelQocixvKXtyZXR1cm4gciYmci5sZW5ndGg/SWkocixIdChvLDIpLFpzKTp0fXZhciAkVD1GaShmdW5jdGlvbihyLG8pe3JldHVybiByKm99LDEpLEdUPXNvKCJyb3VuZCIpLEtUPUZpKGZ1bmN0aW9uKHIsbyl7cmV0dXJuIHItb30sMCk7ZnVuY3Rpb24gSFQocil7cmV0dXJuIHImJnIubGVuZ3RoP0RzKHIsWWUpOjB9ZnVuY3Rpb24gWVQocixvKXtyZXR1cm4gciYmci5sZW5ndGg/RHMocixIdChvLDIpKTowfXJldHVybiBxLmFmdGVyPWRNLHEuYXJ5PXJmLHEuYXNzaWduPXRTLHEuYXNzaWduSW49bWYscS5hc3NpZ25JbldpdGg9UWkscS5hc3NpZ25XaXRoPWVTLHEuYXQ9clMscS5iZWZvcmU9bmYscS5iaW5kPXlvLHEuYmluZEFsbD1hVCxxLmJpbmRLZXk9c2YscS5jYXN0QXJyYXk9UE0scS5jaGFpbj1fdSxxLmNodW5rPU5PLHEuY29tcGFjdD1CTyxxLmNvbmNhdD1XTyxxLmNvbmQ9bFQscS5jb25mb3Jtcz11VCxxLmNvbnN0YW50PVBvLHEuY291bnRCeT1IRSxxLmNyZWF0ZT1uUyxxLmN1cnJ5PW9mLHEuY3VycnlSaWdodD1hZixxLmRlYm91bmNlPWxmLHEuZGVmYXVsdHM9aVMscS5kZWZhdWx0c0RlZXA9c1MscS5kZWZlcj1nTSxxLmRlbGF5PXZNLHEuZGlmZmVyZW5jZT1GTyxxLmRpZmZlcmVuY2VCeT1qTyxxLmRpZmZlcmVuY2VXaXRoPVVPLHEuZHJvcD16TyxxLmRyb3BSaWdodD0kTyxxLmRyb3BSaWdodFdoaWxlPUdPLHEuZHJvcFdoaWxlPUtPLHEuZmlsbD1ITyxxLmZpbHRlcj1WRSxxLmZsYXRNYXA9SkUscS5mbGF0TWFwRGVlcD1RRSxxLmZsYXRNYXBEZXB0aD1rRSxxLmZsYXR0ZW49SnUscS5mbGF0dGVuRGVlcD1ZTyxxLmZsYXR0ZW5EZXB0aD1WTyxxLmZsaXA9cE0scS5mbG93PWNULHEuZmxvd1JpZ2h0PWhULHEuZnJvbVBhaXJzPVhPLHEuZnVuY3Rpb25zPWhTLHEuZnVuY3Rpb25zSW49ZFMscS5ncm91cEJ5PXFFLHEuaW5pdGlhbD1KTyxxLmludGVyc2VjdGlvbj1RTyxxLmludGVyc2VjdGlvbkJ5PWtPLHEuaW50ZXJzZWN0aW9uV2l0aD1xTyxxLmludmVydD12UyxxLmludmVydEJ5PXBTLHEuaW52b2tlTWFwPXRNLHEuaXRlcmF0ZWU9Ym8scS5rZXlCeT1lTSxxLmtleXM9d2UscS5rZXlzSW49SGUscS5tYXA9SGkscS5tYXBLZXlzPXlTLHEubWFwVmFsdWVzPXhTLHEubWF0Y2hlcz1kVCxxLm1hdGNoZXNQcm9wZXJ0eT1nVCxxLm1lbW9pemU9VmkscS5tZXJnZT1PUyxxLm1lcmdlV2l0aD15ZixxLm1ldGhvZD12VCxxLm1ldGhvZE9mPXBULHEubWl4aW49QW8scS5uZWdhdGU9WGkscS5udGhBcmc9eVQscS5vbWl0PUVTLHEub21pdEJ5PU1TLHEub25jZT1tTSxxLm9yZGVyQnk9ck0scS5vdmVyPXhULHEub3ZlckFyZ3M9eU0scS5vdmVyRXZlcnk9T1QscS5vdmVyU29tZT1FVCxxLnBhcnRpYWw9eG8scS5wYXJ0aWFsUmlnaHQ9dWYscS5wYXJ0aXRpb249bk0scS5waWNrPVNTLHEucGlja0J5PXhmLHEucHJvcGVydHk9YmYscS5wcm9wZXJ0eU9mPU1ULHEucHVsbD1yRSxxLnB1bGxBbGw9a3UscS5wdWxsQWxsQnk9bkUscS5wdWxsQWxsV2l0aD1pRSxxLnB1bGxBdD1zRSxxLnJhbmdlPVNULHEucmFuZ2VSaWdodD1UVCxxLnJlYXJnPXhNLHEucmVqZWN0PW9NLHEucmVtb3ZlPW9FLHEucmVzdD1PTSxxLnJldmVyc2U9cG8scS5zYW1wbGVTaXplPWxNLHEuc2V0PVBTLHEuc2V0V2l0aD1iUyxxLnNodWZmbGU9dU0scS5zbGljZT1hRSxxLnNvcnRCeT1oTSxxLnNvcnRlZFVuaXE9Z0UscS5zb3J0ZWRVbmlxQnk9dkUscS5zcGxpdD1KUyxxLnNwcmVhZD1FTSxxLnRhaWw9cEUscS50YWtlPW1FLHEudGFrZVJpZ2h0PXlFLHEudGFrZVJpZ2h0V2hpbGU9eEUscS50YWtlV2hpbGU9T0UscS50YXA9QkUscS50aHJvdHRsZT1NTSxxLnRocnU9S2kscS50b0FycmF5PWdmLHEudG9QYWlycz1PZixxLnRvUGFpcnNJbj1FZixxLnRvUGF0aD1SVCxxLnRvUGxhaW5PYmplY3Q9cGYscS50cmFuc2Zvcm09QVMscS51bmFyeT1TTSxxLnVuaW9uPUVFLHEudW5pb25CeT1NRSxxLnVuaW9uV2l0aD1TRSxxLnVuaXE9VEUscS51bmlxQnk9UEUscS51bmlxV2l0aD1iRSxxLnVuc2V0PUNTLHEudW56aXA9bW8scS51bnppcFdpdGg9cXUscS51cGRhdGU9UlMscS51cGRhdGVXaXRoPUlTLHEudmFsdWVzPUFuLHEudmFsdWVzSW49TFMscS53aXRob3V0PUFFLHEud29yZHM9VGYscS53cmFwPVRNLHEueG9yPUNFLHEueG9yQnk9UkUscS54b3JXaXRoPUlFLHEuemlwPUxFLHEuemlwT2JqZWN0PURFLHEuemlwT2JqZWN0RGVlcD13RSxxLnppcFdpdGg9TkUscS5lbnRyaWVzPU9mLHEuZW50cmllc0luPUVmLHEuZXh0ZW5kPW1mLHEuZXh0ZW5kV2l0aD1RaSxBbyhxLHEpLHEuYWRkPUxULHEuYXR0ZW1wdD1QZixxLmNhbWVsQ2FzZT1CUyxxLmNhcGl0YWxpemU9TWYscS5jZWlsPURULHEuY2xhbXA9RFMscS5jbG9uZT1iTSxxLmNsb25lRGVlcD1DTSxxLmNsb25lRGVlcFdpdGg9Uk0scS5jbG9uZVdpdGg9QU0scS5jb25mb3Jtc1RvPUlNLHEuZGVidXJyPVNmLHEuZGVmYXVsdFRvPWZULHEuZGl2aWRlPXdULHEuZW5kc1dpdGg9V1MscS5lcT1jcixxLmVzY2FwZT1GUyxxLmVzY2FwZVJlZ0V4cD1qUyxxLmV2ZXJ5PVlFLHEuZmluZD1YRSxxLmZpbmRJbmRleD1YdSxxLmZpbmRLZXk9b1MscS5maW5kTGFzdD1aRSxxLmZpbmRMYXN0SW5kZXg9WnUscS5maW5kTGFzdEtleT1hUyxxLmZsb29yPU5ULHEuZm9yRWFjaD10ZixxLmZvckVhY2hSaWdodD1lZixxLmZvckluPWxTLHEuZm9ySW5SaWdodD11UyxxLmZvck93bj1mUyxxLmZvck93blJpZ2h0PWNTLHEuZ2V0PU1vLHEuZ3Q9TE0scS5ndGU9RE0scS5oYXM9Z1MscS5oYXNJbj1TbyxxLmhlYWQ9UXUscS5pZGVudGl0eT1ZZSxxLmluY2x1ZGVzPV9FLHEuaW5kZXhPZj1aTyxxLmluUmFuZ2U9d1MscS5pbnZva2U9bVMscS5pc0FyZ3VtZW50cz10bixxLmlzQXJyYXk9a3QscS5pc0FycmF5QnVmZmVyPXdNLHEuaXNBcnJheUxpa2U9S2UscS5pc0FycmF5TGlrZU9iamVjdD1BZSxxLmlzQm9vbGVhbj1OTSxxLmlzQnVmZmVyPXpyLHEuaXNEYXRlPUJNLHEuaXNFbGVtZW50PVdNLHEuaXNFbXB0eT1GTSxxLmlzRXF1YWw9ak0scS5pc0VxdWFsV2l0aD1VTSxxLmlzRXJyb3I9T28scS5pc0Zpbml0ZT16TSxxLmlzRnVuY3Rpb249UHIscS5pc0ludGVnZXI9ZmYscS5pc0xlbmd0aD1aaSxxLmlzTWFwPWNmLHEuaXNNYXRjaD0kTSxxLmlzTWF0Y2hXaXRoPUdNLHEuaXNOYU49S00scS5pc05hdGl2ZT1ITSxxLmlzTmlsPVZNLHEuaXNOdWxsPVlNLHEuaXNOdW1iZXI9aGYscS5pc09iamVjdD1NZSxxLmlzT2JqZWN0TGlrZT1QZSxxLmlzUGxhaW5PYmplY3Q9WW4scS5pc1JlZ0V4cD1FbyxxLmlzU2FmZUludGVnZXI9WE0scS5pc1NldD1kZixxLmlzU3RyaW5nPUppLHEuaXNTeW1ib2w9UWUscS5pc1R5cGVkQXJyYXk9Ym4scS5pc1VuZGVmaW5lZD1aTSxxLmlzV2Vha01hcD1KTSxxLmlzV2Vha1NldD1RTSxxLmpvaW49X08scS5rZWJhYkNhc2U9VVMscS5sYXN0PXNyLHEubGFzdEluZGV4T2Y9dEUscS5sb3dlckNhc2U9elMscS5sb3dlckZpcnN0PSRTLHEubHQ9a00scS5sdGU9cU0scS5tYXg9QlQscS5tYXhCeT1XVCxxLm1lYW49RlQscS5tZWFuQnk9alQscS5taW49VVQscS5taW5CeT16VCxxLnN0dWJBcnJheT1SbyxxLnN0dWJGYWxzZT1JbyxxLnN0dWJPYmplY3Q9UFQscS5zdHViU3RyaW5nPWJULHEuc3R1YlRydWU9QVQscS5tdWx0aXBseT0kVCxxLm50aD1lRSxxLm5vQ29uZmxpY3Q9bVQscS5ub29wPUNvLHEubm93PVlpLHEucGFkPUdTLHEucGFkRW5kPUtTLHEucGFkU3RhcnQ9SFMscS5wYXJzZUludD1ZUyxxLnJhbmRvbT1OUyxxLnJlZHVjZT1pTSxxLnJlZHVjZVJpZ2h0PXNNLHEucmVwZWF0PVZTLHEucmVwbGFjZT1YUyxxLnJlc3VsdD1UUyxxLnJvdW5kPUdULHEucnVuSW5Db250ZXh0PXZ0LHEuc2FtcGxlPWFNLHEuc2l6ZT1mTSxxLnNuYWtlQ2FzZT1aUyxxLnNvbWU9Y00scS5zb3J0ZWRJbmRleD1sRSxxLnNvcnRlZEluZGV4Qnk9dUUscS5zb3J0ZWRJbmRleE9mPWZFLHEuc29ydGVkTGFzdEluZGV4PWNFLHEuc29ydGVkTGFzdEluZGV4Qnk9aEUscS5zb3J0ZWRMYXN0SW5kZXhPZj1kRSxxLnN0YXJ0Q2FzZT1RUyxxLnN0YXJ0c1dpdGg9a1MscS5zdWJ0cmFjdD1LVCxxLnN1bT1IVCxxLnN1bUJ5PVlULHEudGVtcGxhdGU9cVMscS50aW1lcz1DVCxxLnRvRmluaXRlPWJyLHEudG9JbnRlZ2VyPXF0LHEudG9MZW5ndGg9dmYscS50b0xvd2VyPV9TLHEudG9OdW1iZXI9b3IscS50b1NhZmVJbnRlZ2VyPV9NLHEudG9TdHJpbmc9dWUscS50b1VwcGVyPXRULHEudHJpbT1lVCxxLnRyaW1FbmQ9clQscS50cmltU3RhcnQ9blQscS50cnVuY2F0ZT1pVCxxLnVuZXNjYXBlPXNULHEudW5pcXVlSWQ9SVQscS51cHBlckNhc2U9b1QscS51cHBlckZpcnN0PVRvLHEuZWFjaD10ZixxLmVhY2hSaWdodD1lZixxLmZpcnN0PVF1LEFvKHEsZnVuY3Rpb24oKXt2YXIgcj17fTtyZXR1cm4gZ3IocSxmdW5jdGlvbihvLEMpe2ZlLmNhbGwocS5wcm90b3R5cGUsQyl8fChyW0NdPW8pfSkscn0oKSx7Y2hhaW46ITF9KSxxLlZFUlNJT049bix0cihbImJpbmQiLCJiaW5kS2V5IiwiY3VycnkiLCJjdXJyeVJpZ2h0IiwicGFydGlhbCIsInBhcnRpYWxSaWdodCJdLGZ1bmN0aW9uKHIpe3Fbcl0ucGxhY2Vob2xkZXI9cX0pLHRyKFsiZHJvcCIsInRha2UiXSxmdW5jdGlvbihyLG8pe3JlLnByb3RvdHlwZVtyXT1mdW5jdGlvbihDKXtDPUM9PT10PzE6RGUocXQoQyksMCk7dmFyIHo9dGhpcy5fX2ZpbHRlcmVkX18mJiFvP25ldyByZSh0aGlzKTp0aGlzLmNsb25lKCk7cmV0dXJuIHouX19maWx0ZXJlZF9fP3ouX190YWtlQ291bnRfXz1XZShDLHouX190YWtlQ291bnRfXyk6ei5fX3ZpZXdzX18ucHVzaCh7c2l6ZTpXZShDLFkpLHR5cGU6cisoei5fX2Rpcl9fPDA/IlJpZ2h0IjoiIil9KSx6fSxyZS5wcm90b3R5cGVbcisiUmlnaHQiXT1mdW5jdGlvbihDKXtyZXR1cm4gdGhpcy5yZXZlcnNlKClbcl0oQykucmV2ZXJzZSgpfX0pLHRyKFsiZmlsdGVyIiwibWFwIiwidGFrZVdoaWxlIl0sZnVuY3Rpb24ocixvKXt2YXIgQz1vKzEsej1DPT1JfHxDPT1WO3JlLnByb3RvdHlwZVtyXT1mdW5jdGlvbihYKXt2YXIgZXQ9dGhpcy5jbG9uZSgpO3JldHVybiBldC5fX2l0ZXJhdGVlc19fLnB1c2goe2l0ZXJhdGVlOkh0KFgsMyksdHlwZTpDfSksZXQuX19maWx0ZXJlZF9fPWV0Ll9fZmlsdGVyZWRfX3x8eixldH19KSx0cihbImhlYWQiLCJsYXN0Il0sZnVuY3Rpb24ocixvKXt2YXIgQz0idGFrZSIrKG8/IlJpZ2h0IjoiIik7cmUucHJvdG90eXBlW3JdPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXNbQ10oMSkudmFsdWUoKVswXX19KSx0cihbImluaXRpYWwiLCJ0YWlsIl0sZnVuY3Rpb24ocixvKXt2YXIgQz0iZHJvcCIrKG8/IiI6IlJpZ2h0Iik7cmUucHJvdG90eXBlW3JdPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX19maWx0ZXJlZF9fP25ldyByZSh0aGlzKTp0aGlzW0NdKDEpfX0pLHJlLnByb3RvdHlwZS5jb21wYWN0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZmlsdGVyKFllKX0scmUucHJvdG90eXBlLmZpbmQ9ZnVuY3Rpb24ocil7cmV0dXJuIHRoaXMuZmlsdGVyKHIpLmhlYWQoKX0scmUucHJvdG90eXBlLmZpbmRMYXN0PWZ1bmN0aW9uKHIpe3JldHVybiB0aGlzLnJldmVyc2UoKS5maW5kKHIpfSxyZS5wcm90b3R5cGUuaW52b2tlTWFwPXRlKGZ1bmN0aW9uKHIsbyl7cmV0dXJuIHR5cGVvZiByPT0iZnVuY3Rpb24iP25ldyByZSh0aGlzKTp0aGlzLm1hcChmdW5jdGlvbihDKXtyZXR1cm4gVW4oQyxyLG8pfSl9KSxyZS5wcm90b3R5cGUucmVqZWN0PWZ1bmN0aW9uKHIpe3JldHVybiB0aGlzLmZpbHRlcihYaShIdChyKSkpfSxyZS5wcm90b3R5cGUuc2xpY2U9ZnVuY3Rpb24ocixvKXtyPXF0KHIpO3ZhciBDPXRoaXM7cmV0dXJuIEMuX19maWx0ZXJlZF9fJiYocj4wfHxvPDApP25ldyByZShDKToocjwwP0M9Qy50YWtlUmlnaHQoLXIpOnImJihDPUMuZHJvcChyKSksbyE9PXQmJihvPXF0KG8pLEM9bzwwP0MuZHJvcFJpZ2h0KC1vKTpDLnRha2Uoby1yKSksQyl9LHJlLnByb3RvdHlwZS50YWtlUmlnaHRXaGlsZT1mdW5jdGlvbihyKXtyZXR1cm4gdGhpcy5yZXZlcnNlKCkudGFrZVdoaWxlKHIpLnJldmVyc2UoKX0scmUucHJvdG90eXBlLnRvQXJyYXk9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50YWtlKFkpfSxncihyZS5wcm90b3R5cGUsZnVuY3Rpb24ocixvKXt2YXIgQz0vXig/OmZpbHRlcnxmaW5kfG1hcHxyZWplY3QpfFdoaWxlJC8udGVzdChvKSx6PS9eKD86aGVhZHxsYXN0KSQvLnRlc3QobyksWD1xW3o/InRha2UiKyhvPT0ibGFzdCI/IlJpZ2h0IjoiIik6b10sZXQ9enx8L15maW5kLy50ZXN0KG8pO1gmJihxLnByb3RvdHlwZVtvXT1mdW5jdGlvbigpe3ZhciBsdD10aGlzLl9fd3JhcHBlZF9fLGZ0PXo/WzFdOmFyZ3VtZW50cyx5dD1sdCBpbnN0YW5jZW9mIHJlLFJ0PWZ0WzBdLEl0PXl0fHxrdChsdCksd3Q9ZnVuY3Rpb24oZWUpe3ZhciBuZT1YLmFwcGx5KHEsd3IoW2VlXSxmdCkpO3JldHVybiB6JiZXdD9uZVswXTpuZX07SXQmJkMmJnR5cGVvZiBSdD09ImZ1bmN0aW9uIiYmUnQubGVuZ3RoIT0xJiYoeXQ9SXQ9ITEpO3ZhciBXdD10aGlzLl9fY2hhaW5fXyxVdD0hIXRoaXMuX19hY3Rpb25zX18ubGVuZ3RoLFh0PWV0JiYhV3QsX3Q9eXQmJiFVdDtpZighZXQmJkl0KXtsdD1fdD9sdDpuZXcgcmUodGhpcyk7dmFyIFp0PXIuYXBwbHkobHQsZnQpO3JldHVybiBadC5fX2FjdGlvbnNfXy5wdXNoKHtmdW5jOktpLGFyZ3M6W3d0XSx0aGlzQXJnOnR9KSxuZXcgcnIoWnQsV3QpfXJldHVybiBYdCYmX3Q/ci5hcHBseSh0aGlzLGZ0KTooWnQ9dGhpcy50aHJ1KHd0KSxYdD96P1p0LnZhbHVlKClbMF06WnQudmFsdWUoKTpadCl9KX0pLHRyKFsicG9wIiwicHVzaCIsInNoaWZ0Iiwic29ydCIsInNwbGljZSIsInVuc2hpZnQiXSxmdW5jdGlvbihyKXt2YXIgbz12aVtyXSxDPS9eKD86cHVzaHxzb3J0fHVuc2hpZnQpJC8udGVzdChyKT8idGFwIjoidGhydSIsej0vXig/OnBvcHxzaGlmdCkkLy50ZXN0KHIpO3EucHJvdG90eXBlW3JdPWZ1bmN0aW9uKCl7dmFyIFg9YXJndW1lbnRzO2lmKHomJiF0aGlzLl9fY2hhaW5fXyl7dmFyIGV0PXRoaXMudmFsdWUoKTtyZXR1cm4gby5hcHBseShrdChldCk/ZXQ6W10sWCl9cmV0dXJuIHRoaXNbQ10oZnVuY3Rpb24obHQpe3JldHVybiBvLmFwcGx5KGt0KGx0KT9sdDpbXSxYKX0pfX0pLGdyKHJlLnByb3RvdHlwZSxmdW5jdGlvbihyLG8pe3ZhciBDPXFbb107aWYoQyl7dmFyIHo9Qy5uYW1lKyIiO2ZlLmNhbGwoRW4seil8fChFblt6XT1bXSksRW5bel0ucHVzaCh7bmFtZTpvLGZ1bmM6Q30pfX0pLEVuW1dpKHQsUykubmFtZV09W3tuYW1lOiJ3cmFwcGVyIixmdW5jOnR9XSxyZS5wcm90b3R5cGUuY2xvbmU9c3gscmUucHJvdG90eXBlLnJldmVyc2U9b3gscmUucHJvdG90eXBlLnZhbHVlPWF4LHEucHJvdG90eXBlLmF0PVdFLHEucHJvdG90eXBlLmNoYWluPUZFLHEucHJvdG90eXBlLmNvbW1pdD1qRSxxLnByb3RvdHlwZS5uZXh0PVVFLHEucHJvdG90eXBlLnBsYW50PSRFLHEucHJvdG90eXBlLnJldmVyc2U9R0UscS5wcm90b3R5cGUudG9KU09OPXEucHJvdG90eXBlLnZhbHVlT2Y9cS5wcm90b3R5cGUudmFsdWU9S0UscS5wcm90b3R5cGUuZmlyc3Q9cS5wcm90b3R5cGUuaGVhZCxEbiYmKHEucHJvdG90eXBlW0RuXT16RSkscX0seW49ajIoKTtWcj8oKFZyLmV4cG9ydHM9eW4pLl89eW4sUHMuXz15bik6TmUuXz15bn0pLmNhbGwobXIpfShpaSxpaS5leHBvcnRzKTt2YXIgQmE9aWkuZXhwb3J0cztjbGFzcyBEdHtjb25zdHJ1Y3RvcihlKXtPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywic3luY1VuaXRUaW1lIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6MWUzfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInZOb2RlcyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJkcmF3TGF5ZXIiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiZnVsbExheWVyIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIndvcmtJZCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pO2NvbnN0e3ZOb2Rlczp0LGZ1bGxMYXllcjpuLGRyYXdMYXllcjppfT1lO3RoaXMudk5vZGVzPXQsdGhpcy5mdWxsTGF5ZXI9bix0aGlzLmRyYXdMYXllcj1pfXNldFdvcmtJZChlKXt0aGlzLndvcmtJZD1lfWdldFdvcmtJZCgpe3JldHVybiB0aGlzLndvcmtJZH1nZXRXb3JrT3B0aW9ucygpe3JldHVybiB0aGlzLndvcmtPcHRpb25zfXNldFdvcmtPcHRpb25zKGUpe3RoaXMud29ya09wdGlvbnM9ZSx0aGlzLnN5bmNVbml0VGltZT1lLnN5bmNVbml0VGltZXx8dGhpcy5zeW5jVW5pdFRpbWV9dXBkYXRhT3B0U2VydmljZShlKXt2YXIgaTtsZXQgdDtjb25zdCBuPShpPXRoaXMud29ya0lkKT09bnVsbD92b2lkIDA6aS50b1N0cmluZygpO2lmKG4mJmUpe2NvbnN0IGY9dGhpcy5mdWxsTGF5ZXIuZ2V0RWxlbWVudHNCeU5hbWUobil8fHRoaXMuZHJhd0xheWVyJiZ0aGlzLmRyYXdMYXllci5nZXRFbGVtZW50c0J5TmFtZShuKXx8W107aWYoZi5sZW5ndGghPT0xKXJldHVybjtjb25zdCBoPWZbMF0se3Bvczp1LHpJbmRleDphLHNjYWxlOmQsYW5nbGU6RSx0cmFuc2xhdGU6cH09ZSxPPXt9O3R5cGVvZiBhPT0ibnVtYmVyIiYmKE8uekluZGV4PWEpLHUmJihPLnBvcz1bdVswXSx1WzFdXSksZCYmKE8uc2NhbGU9ZCksRSYmKE8ucm90YXRlPUUpLHAmJihPLnRyYW5zbGF0ZT1wKSxoLmF0dHIoTyk7Y29uc3QgbT1oPT1udWxsP3ZvaWQgMDpoLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO3JldHVybiBtJiYodD0kdCh0LHt4Ok1hdGguZmxvb3IobS54LUR0LlNhZmVCb3JkZXJQYWRkaW5nKSx5Ok1hdGguZmxvb3IobS55LUR0LlNhZmVCb3JkZXJQYWRkaW5nKSx3Ok1hdGguZmxvb3IobS53aWR0aCtEdC5TYWZlQm9yZGVyUGFkZGluZyoyKSxoOk1hdGguZmxvb3IobS5oZWlnaHQrRHQuU2FmZUJvcmRlclBhZGRpbmcqMil9KSksdGhpcy52Tm9kZXMuc2V0SW5mbyhuLHtyZWN0OnQsY2VudGVyUG9zOnV9KSx0fX1zdGF0aWMgdXBkYXRlTm9kZU9wdChlKXtjb25zdHtub2RlOnQsb3B0Om4sdk5vZGVzOmksd2lsbFNlcmlhbGl6ZURhdGE6Zix0YXJnZXROb2RlOmh9PWUse3pJbmRleDp1LHRyYW5zbGF0ZTphLGFuZ2xlOmQsYm94OkUsYm94U2NhbGU6cCxib3hUcmFuc2xhdGU6T309bjtsZXQgbTtjb25zdCBiPWgmJkJhLmNsb25lRGVlcChoKXx8aS5nZXQodC5uYW1lKTtpZighYilyZXR1cm47dSYmKHQuc2V0QXR0cmlidXRlKCJ6SW5kZXgiLHUpLGIub3B0LnpJbmRleD11KTtjb25zdCBNPXQucGFyZW50O2lmKE0pe2lmKEUmJk8mJnApe2NvbnN0e3JlY3Q6eX09YixTPVtdO2ZvcihsZXQgQT0wO0E8Yi5vcC5sZW5ndGg7QSs9MylTLnB1c2gobmV3IEZ0KGIub3BbQV0sYi5vcFtBKzFdLGIub3BbQSsyXSkpO2NvbnN0IHM9eGUoUyksYz1bcy53Kk0ud29ybGRTY2FsaW5nWzBdLHMuaCpNLndvcmxkU2NhbGluZ1swXV0sbD1beS53LWNbMF0seS5oLWNbMV1dLHY9Wyh5LncqcFswXS1sWzBdKS9jWzBdLCh5LmgqcFsxXS1sWzFdKS9jWzFdXSxUPVtPWzBdL00ud29ybGRTY2FsaW5nWzBdLE9bMV0vTS53b3JsZFNjYWxpbmdbMV1dLFI9Yi5vcC5tYXAoKEEsdyk9Pntjb25zdCBCPXclMztyZXR1cm4gQj09PTA/QStUWzBdOkI9PT0xP0ErVFsxXTpBfSksTD1bYi5jZW50ZXJQb3NbMF0rVFswXSxiLmNlbnRlclBvc1sxXStUWzFdXTtjbShSLEwsdik7Y29uc3QgTj1bXTtmb3IobGV0IEE9MDtBPFIubGVuZ3RoO0ErPTMpTi5wdXNoKG5ldyBGdChSW0FdLFJbQSsxXSxSW0ErMl0pKTtiLm9wPVIsYi5jZW50ZXJQb3M9TH1lbHNlIGlmKGEpe2NvbnN0IHk9W2FbMF0vTS53b3JsZFNjYWxpbmdbMF0sYVsxXS9NLndvcmxkU2NhbGluZ1sxXV07dC5zZXRBdHRyaWJ1dGUoInRyYW5zbGF0ZSIseSksYi5vcHQudHJhbnNsYXRlPXksaCYmKG09TGEoYi5yZWN0LGEpLGIucmVjdD1tKX1lbHNlIE5hKGQpJiYodC5zZXRBdHRyaWJ1dGUoInJvdGF0ZSIsZCksYi5vcHQucm90YXRlPWQsaCYmKG09bG0oYi5yZWN0LGQpLGIucmVjdD1tKSk7aWYoZil7aWYoYSl7Y29uc3QgeT1bYVswXS9NLndvcmxkU2NhbGluZ1swXSxhWzFdL00ud29ybGRTY2FsaW5nWzFdXSxTPWIub3AubWFwKChzLGMpPT57Y29uc3QgbD1jJTM7cmV0dXJuIGw9PT0wP3MreVswXTpsPT09MT9zK3lbMV06c30pO2Iub3A9UyxiLmNlbnRlclBvcz1bYi5jZW50ZXJQb3NbMF0reVswXSxiLmNlbnRlclBvc1sxXSt5WzFdXSxiIT1udWxsJiZiLm9wdCYmKGIub3B0LnRyYW5zbGF0ZT12b2lkIDApfWVsc2UgaWYoTmEoZCkpe2NvbnN0IHk9Yi5vcDtmbSh5LGIuY2VudGVyUG9zLGQpLGIub3A9eSxiIT1udWxsJiZiLm9wdCYmKGIub3B0LnJvdGF0ZT12b2lkIDApfX1iJiZpLnNldEluZm8odC5uYW1lLGIpfX1zdGF0aWMgZ2V0Q2VudGVyUG9zKGUsdCl7Y29uc3R7d29ybGRQb3NpdGlvbjpuLHdvcmxkU2NhbGluZzppfT10O3JldHVyblsoZS54K2Uudy8yLW5bMF0pL2lbMF0sKGUueStlLmgvMi1uWzFdKS9pWzFdXX1zdGF0aWMgZ2V0UmVjdEZyb21MYXllcihlLHQpe2NvbnN0IG49ZS5nZXRFbGVtZW50c0J5TmFtZSh0KVswXTtpZihuKXtjb25zdCBpPW4uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7cmV0dXJue3g6TWF0aC5mbG9vcihpLngtRHQuU2FmZUJvcmRlclBhZGRpbmcpLHk6TWF0aC5mbG9vcihpLnktRHQuU2FmZUJvcmRlclBhZGRpbmcpLHc6TWF0aC5mbG9vcihpLndpZHRoK0R0LlNhZmVCb3JkZXJQYWRkaW5nKjIpLGg6TWF0aC5mbG9vcihpLmhlaWdodCtEdC5TYWZlQm9yZGVyUGFkZGluZyoyKX19fX1PYmplY3QuZGVmaW5lUHJvcGVydHkoRHQsIlNhZmVCb3JkZXJQYWRkaW5nIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6MTB9KTt2YXIgbGU9ZnVuY3Rpb24oZyl7dmFyIGU9e307ZnVuY3Rpb24gdChuKXtpZihlW25dKXJldHVybiBlW25dLmV4cG9ydHM7dmFyIGk9ZVtuXT17aTpuLGw6ITEsZXhwb3J0czp7fX07cmV0dXJuIGdbbl0uY2FsbChpLmV4cG9ydHMsaSxpLmV4cG9ydHMsdCksaS5sPSEwLGkuZXhwb3J0c31yZXR1cm4gdC5tPWcsdC5jPWUsdC5kPWZ1bmN0aW9uKG4saSxmKXt0Lm8obixpKXx8T2JqZWN0LmRlZmluZVByb3BlcnR5KG4saSx7ZW51bWVyYWJsZTohMCxnZXQ6Zn0pfSx0LnI9ZnVuY3Rpb24obil7dHlwZW9mIFN5bWJvbDwidSImJlN5bWJvbC50b1N0cmluZ1RhZyYmT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sU3ltYm9sLnRvU3RyaW5nVGFnLHt2YWx1ZToiTW9kdWxlIn0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KX0sdC50PWZ1bmN0aW9uKG4saSl7aWYoaSYxJiYobj10KG4pKSxpJjh8fGkmNCYmdHlwZW9mIG49PSJvYmplY3QiJiZuJiZuLl9fZXNNb2R1bGUpcmV0dXJuIG47dmFyIGY9T2JqZWN0LmNyZWF0ZShudWxsKTtpZih0LnIoZiksT2JqZWN0LmRlZmluZVByb3BlcnR5KGYsImRlZmF1bHQiLHtlbnVtZXJhYmxlOiEwLHZhbHVlOm59KSxpJjImJnR5cGVvZiBuIT0ic3RyaW5nIilmb3IodmFyIGggaW4gbil0LmQoZixoLChmdW5jdGlvbih1KXtyZXR1cm4gblt1XX0pLmJpbmQobnVsbCxoKSk7cmV0dXJuIGZ9LHQubj1mdW5jdGlvbihuKXt2YXIgaT1uJiZuLl9fZXNNb2R1bGU/ZnVuY3Rpb24oKXtyZXR1cm4gbi5kZWZhdWx0fTpmdW5jdGlvbigpe3JldHVybiBufTtyZXR1cm4gdC5kKGksImEiLGkpLGl9LHQubz1mdW5jdGlvbihuLGkpe3JldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobixpKX0sdC5wPSIvanMvIix0KHQucz0wKX0oW2Z1bmN0aW9uKGcsZSx0KXt0LnIoZSksdC5kKGUsInZlcnNpb24iLGZ1bmN0aW9uKCl7cmV0dXJuIEp9KSx0LmQoZSwiaGVscGVycyIsZnVuY3Rpb24oKXtyZXR1cm4gan0pLHQuZChlLCJjcmVhdGVFbGVtZW50IixmdW5jdGlvbigpe3JldHVybiBCfSksdC5kKGUsImlzU3ByaXRlTm9kZSIsZnVuY3Rpb24oKXtyZXR1cm4gRH0pLHQuZChlLCJyZWdpc3Rlck5vZGUiLGZ1bmN0aW9uKCl7cmV0dXJuIEl9KTt2YXIgbj10KDEyKTt0LmQoZSwiRU5WIixmdW5jdGlvbigpe3JldHVybiBuLkVOVn0pO3ZhciBpPXQoNjgpO3QuZChlLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLGZ1bmN0aW9uKCl7cmV0dXJuIGkucmVxdWVzdEFuaW1hdGlvbkZyYW1lfSksdC5kKGUsImNhbmNlbEFuaW1hdGlvbkZyYW1lIixmdW5jdGlvbigpe3JldHVybiBpLmNhbmNlbEFuaW1hdGlvbkZyYW1lfSk7dmFyIGY9dCg3MCk7dC5kKGUsIk5vZGUiLGZ1bmN0aW9uKCl7cmV0dXJuIGYuZGVmYXVsdH0pO3ZhciBoPXQoMjE3KTt0LmQoZSwiQ2xvdWQiLGZ1bmN0aW9uKCl7cmV0dXJuIGguZGVmYXVsdH0pO3ZhciB1PXQoMjE5KTt0LmQoZSwiQmxvY2siLGZ1bmN0aW9uKCl7cmV0dXJuIHUuZGVmYXVsdH0pO3ZhciBhPXQoMjI0KTt0LmQoZSwiU3ByaXRlIixmdW5jdGlvbigpe3JldHVybiBhLmRlZmF1bHR9KTt2YXIgZD10KDIyNik7dC5kKGUsIlBhdGgiLGZ1bmN0aW9uKCl7cmV0dXJuIGQuZGVmYXVsdH0pO3ZhciBFPXQoMjI5KTt0LmQoZSwiUmVjdCIsZnVuY3Rpb24oKXtyZXR1cm4gRS5kZWZhdWx0fSk7dmFyIHA9dCgyMzEpO3QuZChlLCJUcmlhbmdsZSIsZnVuY3Rpb24oKXtyZXR1cm4gcC5kZWZhdWx0fSk7dmFyIE89dCgyMzYpO3QuZChlLCJQYXJhbGxlbCIsZnVuY3Rpb24oKXtyZXR1cm4gTy5kZWZhdWx0fSk7dmFyIG09dCgyMzgpO3QuZChlLCJSZWd1bGFyIixmdW5jdGlvbigpe3JldHVybiBtLmRlZmF1bHR9KTt2YXIgYj10KDI0MCk7dC5kKGUsIlN0YXIiLGZ1bmN0aW9uKCl7cmV0dXJuIGIuZGVmYXVsdH0pO3ZhciBNPXQoMjQyKTt0LmQoZSwiRWxsaXBzZSIsZnVuY3Rpb24oKXtyZXR1cm4gTS5kZWZhdWx0fSk7dmFyIHk9dCgyNDQpO3QuZChlLCJBcmMiLGZ1bmN0aW9uKCl7cmV0dXJuIHkuZGVmYXVsdH0pO3ZhciBTPXQoMjQ2KTt0LmQoZSwiUmluZyIsZnVuY3Rpb24oKXtyZXR1cm4gUy5kZWZhdWx0fSk7dmFyIHM9dCgyMzIpO3QuZChlLCJQb2x5bGluZSIsZnVuY3Rpb24oKXtyZXR1cm4gcy5kZWZhdWx0fSk7dmFyIGM9dCgyNDgpO3QuZChlLCJMYWJlbCIsZnVuY3Rpb24oKXtyZXR1cm4gYy5kZWZhdWx0fSk7dmFyIGw9dCgyNTApO3QuZChlLCJHcm91cCIsZnVuY3Rpb24oKXtyZXR1cm4gbC5kZWZhdWx0fSk7dmFyIHY9dCgyODYpO3QuZChlLCJMYXllciIsZnVuY3Rpb24oKXtyZXR1cm4gdi5kZWZhdWx0fSk7dmFyIFQ9dCgyODcpO3QuZChlLCJTcHJpdGVTdmciLGZ1bmN0aW9uKCl7cmV0dXJuIFQuZGVmYXVsdH0pO3ZhciBSPXQoMjg5KTt0LmQoZSwiTGF5ZXJXb3JrZXIiLGZ1bmN0aW9uKCl7cmV0dXJuIFIuZGVmYXVsdH0pO3ZhciBMPXQoMjkwKTt0LmQoZSwiU2NlbmUiLGZ1bmN0aW9uKCl7cmV0dXJuIEwuZGVmYXVsdH0pO3ZhciBOPXQoMjEzKSxBPXQoMjIxKTt0LmQoZSwiQ29sb3IiLGZ1bmN0aW9uKCl7cmV0dXJuIEEuQ29sb3J9KSx0LmQoZSwiR3JhZGllbnQiLGZ1bmN0aW9uKCl7cmV0dXJuIEEuR3JhZGllbnR9KTt2YXIgdz10KDcyKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3QgQj1OLmRlZmF1bHQuY3JlYXRlRWxlbWVudCxEPU4uZGVmYXVsdC5pc1Nwcml0ZU5vZGUsST1OLmRlZmF1bHQucmVnaXN0ZXJOb2RlLGo9e3BhcnNlQ29sb3I6QS5wYXJzZUNvbG9yLHNpemVUb1BpeGVsOncuc2l6ZVRvUGl4ZWwsdG9BcnJheTp3LnRvQXJyYXksdG9TdHJpbmc6dy50b1N0cmluZyx0b051bWJlcjp3LnRvTnVtYmVyfTtsZXQgVjtWPSIzLjguMyI7Y29uc3QgSj1WfSxmdW5jdGlvbihnLGUsdCl7dC5yKGUpO3ZhciBuPXQoMik7dC5kKGUsImdsTWF0cml4IixmdW5jdGlvbigpe3JldHVybiBufSk7dmFyIGk9dCgzKTt0LmQoZSwibWF0MiIsZnVuY3Rpb24oKXtyZXR1cm4gaX0pO3ZhciBmPXQoNCk7dC5kKGUsIm1hdDJkIixmdW5jdGlvbigpe3JldHVybiBmfSk7dmFyIGg9dCg1KTt0LmQoZSwibWF0MyIsZnVuY3Rpb24oKXtyZXR1cm4gaH0pO3ZhciB1PXQoNik7dC5kKGUsIm1hdDQiLGZ1bmN0aW9uKCl7cmV0dXJuIHV9KTt2YXIgYT10KDcpO3QuZChlLCJxdWF0IixmdW5jdGlvbigpe3JldHVybiBhfSk7dmFyIGQ9dCgxMCk7dC5kKGUsInF1YXQyIixmdW5jdGlvbigpe3JldHVybiBkfSk7dmFyIEU9dCgxMSk7dC5kKGUsInZlYzIiLGZ1bmN0aW9uKCl7cmV0dXJuIEV9KTt2YXIgcD10KDgpO3QuZChlLCJ2ZWMzIixmdW5jdGlvbigpe3JldHVybiBwfSk7dmFyIE89dCg5KTt0LmQoZSwidmVjNCIsZnVuY3Rpb24oKXtyZXR1cm4gT30pfSxmdW5jdGlvbihnLGUsdCl7dC5yKGUpLHQuZChlLCJFUFNJTE9OIixmdW5jdGlvbigpe3JldHVybiBufSksdC5kKGUsIkFSUkFZX1RZUEUiLGZ1bmN0aW9uKCl7cmV0dXJuIGl9KSx0LmQoZSwiUkFORE9NIixmdW5jdGlvbigpe3JldHVybiBmfSksdC5kKGUsInNldE1hdHJpeEFycmF5VHlwZSIsZnVuY3Rpb24oKXtyZXR1cm4gaH0pLHQuZChlLCJ0b1JhZGlhbiIsZnVuY3Rpb24oKXtyZXR1cm4gYX0pLHQuZChlLCJlcXVhbHMiLGZ1bmN0aW9uKCl7cmV0dXJuIGR9KTt2YXIgbj0xZS02LGk9dHlwZW9mIEZsb2F0MzJBcnJheTwidSI/RmxvYXQzMkFycmF5OkFycmF5LGY9TWF0aC5yYW5kb207ZnVuY3Rpb24gaChFKXtpPUV9dmFyIHU9TWF0aC5QSS8xODA7ZnVuY3Rpb24gYShFKXtyZXR1cm4gRSp1fWZ1bmN0aW9uIGQoRSxwKXtyZXR1cm4gTWF0aC5hYnMoRS1wKTw9bipNYXRoLm1heCgxLE1hdGguYWJzKEUpLE1hdGguYWJzKHApKX1NYXRoLmh5cG90fHwoTWF0aC5oeXBvdD1mdW5jdGlvbigpe2Zvcih2YXIgRT0wLHA9YXJndW1lbnRzLmxlbmd0aDtwLS07KUUrPWFyZ3VtZW50c1twXSphcmd1bWVudHNbcF07cmV0dXJuIE1hdGguc3FydChFKX0pfSxmdW5jdGlvbihnLGUsdCl7dC5yKGUpLHQuZChlLCJjcmVhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIGl9KSx0LmQoZSwiY2xvbmUiLGZ1bmN0aW9uKCl7cmV0dXJuIGZ9KSx0LmQoZSwiY29weSIsZnVuY3Rpb24oKXtyZXR1cm4gaH0pLHQuZChlLCJpZGVudGl0eSIsZnVuY3Rpb24oKXtyZXR1cm4gdX0pLHQuZChlLCJmcm9tVmFsdWVzIixmdW5jdGlvbigpe3JldHVybiBhfSksdC5kKGUsInNldCIsZnVuY3Rpb24oKXtyZXR1cm4gZH0pLHQuZChlLCJ0cmFuc3Bvc2UiLGZ1bmN0aW9uKCl7cmV0dXJuIEV9KSx0LmQoZSwiaW52ZXJ0IixmdW5jdGlvbigpe3JldHVybiBwfSksdC5kKGUsImFkam9pbnQiLGZ1bmN0aW9uKCl7cmV0dXJuIE99KSx0LmQoZSwiZGV0ZXJtaW5hbnQiLGZ1bmN0aW9uKCl7cmV0dXJuIG19KSx0LmQoZSwibXVsdGlwbHkiLGZ1bmN0aW9uKCl7cmV0dXJuIGJ9KSx0LmQoZSwicm90YXRlIixmdW5jdGlvbigpe3JldHVybiBNfSksdC5kKGUsInNjYWxlIixmdW5jdGlvbigpe3JldHVybiB5fSksdC5kKGUsImZyb21Sb3RhdGlvbiIsZnVuY3Rpb24oKXtyZXR1cm4gU30pLHQuZChlLCJmcm9tU2NhbGluZyIsZnVuY3Rpb24oKXtyZXR1cm4gc30pLHQuZChlLCJzdHIiLGZ1bmN0aW9uKCl7cmV0dXJuIGN9KSx0LmQoZSwiZnJvYiIsZnVuY3Rpb24oKXtyZXR1cm4gbH0pLHQuZChlLCJMRFUiLGZ1bmN0aW9uKCl7cmV0dXJuIHZ9KSx0LmQoZSwiYWRkIixmdW5jdGlvbigpe3JldHVybiBUfSksdC5kKGUsInN1YnRyYWN0IixmdW5jdGlvbigpe3JldHVybiBSfSksdC5kKGUsImV4YWN0RXF1YWxzIixmdW5jdGlvbigpe3JldHVybiBMfSksdC5kKGUsImVxdWFscyIsZnVuY3Rpb24oKXtyZXR1cm4gTn0pLHQuZChlLCJtdWx0aXBseVNjYWxhciIsZnVuY3Rpb24oKXtyZXR1cm4gQX0pLHQuZChlLCJtdWx0aXBseVNjYWxhckFuZEFkZCIsZnVuY3Rpb24oKXtyZXR1cm4gd30pLHQuZChlLCJtdWwiLGZ1bmN0aW9uKCl7cmV0dXJuIEJ9KSx0LmQoZSwic3ViIixmdW5jdGlvbigpe3JldHVybiBEfSk7dmFyIG49dCgyKTtmdW5jdGlvbiBpKCl7dmFyIEk9bmV3IG4uQVJSQVlfVFlQRSg0KTtyZXR1cm4gbi5BUlJBWV9UWVBFIT1GbG9hdDMyQXJyYXkmJihJWzFdPTAsSVsyXT0wKSxJWzBdPTEsSVszXT0xLEl9ZnVuY3Rpb24gZihJKXt2YXIgaj1uZXcgbi5BUlJBWV9UWVBFKDQpO3JldHVybiBqWzBdPUlbMF0salsxXT1JWzFdLGpbMl09SVsyXSxqWzNdPUlbM10san1mdW5jdGlvbiBoKEksail7cmV0dXJuIElbMF09alswXSxJWzFdPWpbMV0sSVsyXT1qWzJdLElbM109alszXSxJfWZ1bmN0aW9uIHUoSSl7cmV0dXJuIElbMF09MSxJWzFdPTAsSVsyXT0wLElbM109MSxJfWZ1bmN0aW9uIGEoSSxqLFYsSil7dmFyIF89bmV3IG4uQVJSQVlfVFlQRSg0KTtyZXR1cm4gX1swXT1JLF9bMV09aixfWzJdPVYsX1szXT1KLF99ZnVuY3Rpb24gZChJLGosVixKLF8pe3JldHVybiBJWzBdPWosSVsxXT1WLElbMl09SixJWzNdPV8sSX1mdW5jdGlvbiBFKEksail7aWYoST09PWope3ZhciBWPWpbMV07SVsxXT1qWzJdLElbMl09Vn1lbHNlIElbMF09alswXSxJWzFdPWpbMl0sSVsyXT1qWzFdLElbM109alszXTtyZXR1cm4gSX1mdW5jdGlvbiBwKEksail7dmFyIFY9alswXSxKPWpbMV0sXz1qWzJdLHN0PWpbM10sRz1WKnN0LV8qSjtyZXR1cm4gRz8oRz0xL0csSVswXT1zdCpHLElbMV09LUoqRyxJWzJdPS1fKkcsSVszXT1WKkcsSSk6bnVsbH1mdW5jdGlvbiBPKEksail7dmFyIFY9alswXTtyZXR1cm4gSVswXT1qWzNdLElbMV09LWpbMV0sSVsyXT0talsyXSxJWzNdPVYsSX1mdW5jdGlvbiBtKEkpe3JldHVybiBJWzBdKklbM10tSVsyXSpJWzFdfWZ1bmN0aW9uIGIoSSxqLFYpe3ZhciBKPWpbMF0sXz1qWzFdLHN0PWpbMl0sRz1qWzNdLFk9VlswXSxydD1WWzFdLG90PVZbMl0sYXQ9VlszXTtyZXR1cm4gSVswXT1KKlkrc3QqcnQsSVsxXT1fKlkrRypydCxJWzJdPUoqb3Qrc3QqYXQsSVszXT1fKm90K0cqYXQsSX1mdW5jdGlvbiBNKEksaixWKXt2YXIgSj1qWzBdLF89alsxXSxzdD1qWzJdLEc9alszXSxZPU1hdGguc2luKFYpLHJ0PU1hdGguY29zKFYpO3JldHVybiBJWzBdPUoqcnQrc3QqWSxJWzFdPV8qcnQrRypZLElbMl09SiotWStzdCpydCxJWzNdPV8qLVkrRypydCxJfWZ1bmN0aW9uIHkoSSxqLFYpe3ZhciBKPWpbMF0sXz1qWzFdLHN0PWpbMl0sRz1qWzNdLFk9VlswXSxydD1WWzFdO3JldHVybiBJWzBdPUoqWSxJWzFdPV8qWSxJWzJdPXN0KnJ0LElbM109RypydCxJfWZ1bmN0aW9uIFMoSSxqKXt2YXIgVj1NYXRoLnNpbihqKSxKPU1hdGguY29zKGopO3JldHVybiBJWzBdPUosSVsxXT1WLElbMl09LVYsSVszXT1KLEl9ZnVuY3Rpb24gcyhJLGope3JldHVybiBJWzBdPWpbMF0sSVsxXT0wLElbMl09MCxJWzNdPWpbMV0sSX1mdW5jdGlvbiBjKEkpe3JldHVybiJtYXQyKCIrSVswXSsiLCAiK0lbMV0rIiwgIitJWzJdKyIsICIrSVszXSsiKSJ9ZnVuY3Rpb24gbChJKXtyZXR1cm4gTWF0aC5oeXBvdChJWzBdLElbMV0sSVsyXSxJWzNdKX1mdW5jdGlvbiB2KEksaixWLEope3JldHVybiBJWzJdPUpbMl0vSlswXSxWWzBdPUpbMF0sVlsxXT1KWzFdLFZbM109SlszXS1JWzJdKlZbMV0sW0ksaixWXX1mdW5jdGlvbiBUKEksaixWKXtyZXR1cm4gSVswXT1qWzBdK1ZbMF0sSVsxXT1qWzFdK1ZbMV0sSVsyXT1qWzJdK1ZbMl0sSVszXT1qWzNdK1ZbM10sSX1mdW5jdGlvbiBSKEksaixWKXtyZXR1cm4gSVswXT1qWzBdLVZbMF0sSVsxXT1qWzFdLVZbMV0sSVsyXT1qWzJdLVZbMl0sSVszXT1qWzNdLVZbM10sSX1mdW5jdGlvbiBMKEksail7cmV0dXJuIElbMF09PT1qWzBdJiZJWzFdPT09alsxXSYmSVsyXT09PWpbMl0mJklbM109PT1qWzNdfWZ1bmN0aW9uIE4oSSxqKXt2YXIgVj1JWzBdLEo9SVsxXSxfPUlbMl0sc3Q9SVszXSxHPWpbMF0sWT1qWzFdLHJ0PWpbMl0sb3Q9alszXTtyZXR1cm4gTWF0aC5hYnMoVi1HKTw9bi5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoViksTWF0aC5hYnMoRykpJiZNYXRoLmFicyhKLVkpPD1uLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhKKSxNYXRoLmFicyhZKSkmJk1hdGguYWJzKF8tcnQpPD1uLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhfKSxNYXRoLmFicyhydCkpJiZNYXRoLmFicyhzdC1vdCk8PW4uRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKHN0KSxNYXRoLmFicyhvdCkpfWZ1bmN0aW9uIEEoSSxqLFYpe3JldHVybiBJWzBdPWpbMF0qVixJWzFdPWpbMV0qVixJWzJdPWpbMl0qVixJWzNdPWpbM10qVixJfWZ1bmN0aW9uIHcoSSxqLFYsSil7cmV0dXJuIElbMF09alswXStWWzBdKkosSVsxXT1qWzFdK1ZbMV0qSixJWzJdPWpbMl0rVlsyXSpKLElbM109alszXStWWzNdKkosSX12YXIgQj1iLEQ9Un0sZnVuY3Rpb24oZyxlLHQpe3QucihlKSx0LmQoZSwiY3JlYXRlIixmdW5jdGlvbigpe3JldHVybiBpfSksdC5kKGUsImNsb25lIixmdW5jdGlvbigpe3JldHVybiBmfSksdC5kKGUsImNvcHkiLGZ1bmN0aW9uKCl7cmV0dXJuIGh9KSx0LmQoZSwiaWRlbnRpdHkiLGZ1bmN0aW9uKCl7cmV0dXJuIHV9KSx0LmQoZSwiZnJvbVZhbHVlcyIsZnVuY3Rpb24oKXtyZXR1cm4gYX0pLHQuZChlLCJzZXQiLGZ1bmN0aW9uKCl7cmV0dXJuIGR9KSx0LmQoZSwiaW52ZXJ0IixmdW5jdGlvbigpe3JldHVybiBFfSksdC5kKGUsImRldGVybWluYW50IixmdW5jdGlvbigpe3JldHVybiBwfSksdC5kKGUsIm11bHRpcGx5IixmdW5jdGlvbigpe3JldHVybiBPfSksdC5kKGUsInJvdGF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gbX0pLHQuZChlLCJzY2FsZSIsZnVuY3Rpb24oKXtyZXR1cm4gYn0pLHQuZChlLCJ0cmFuc2xhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIE19KSx0LmQoZSwiZnJvbVJvdGF0aW9uIixmdW5jdGlvbigpe3JldHVybiB5fSksdC5kKGUsImZyb21TY2FsaW5nIixmdW5jdGlvbigpe3JldHVybiBTfSksdC5kKGUsImZyb21UcmFuc2xhdGlvbiIsZnVuY3Rpb24oKXtyZXR1cm4gc30pLHQuZChlLCJzdHIiLGZ1bmN0aW9uKCl7cmV0dXJuIGN9KSx0LmQoZSwiZnJvYiIsZnVuY3Rpb24oKXtyZXR1cm4gbH0pLHQuZChlLCJhZGQiLGZ1bmN0aW9uKCl7cmV0dXJuIHZ9KSx0LmQoZSwic3VidHJhY3QiLGZ1bmN0aW9uKCl7cmV0dXJuIFR9KSx0LmQoZSwibXVsdGlwbHlTY2FsYXIiLGZ1bmN0aW9uKCl7cmV0dXJuIFJ9KSx0LmQoZSwibXVsdGlwbHlTY2FsYXJBbmRBZGQiLGZ1bmN0aW9uKCl7cmV0dXJuIEx9KSx0LmQoZSwiZXhhY3RFcXVhbHMiLGZ1bmN0aW9uKCl7cmV0dXJuIE59KSx0LmQoZSwiZXF1YWxzIixmdW5jdGlvbigpe3JldHVybiBBfSksdC5kKGUsIm11bCIsZnVuY3Rpb24oKXtyZXR1cm4gd30pLHQuZChlLCJzdWIiLGZ1bmN0aW9uKCl7cmV0dXJuIEJ9KTt2YXIgbj10KDIpO2Z1bmN0aW9uIGkoKXt2YXIgRD1uZXcgbi5BUlJBWV9UWVBFKDYpO3JldHVybiBuLkFSUkFZX1RZUEUhPUZsb2F0MzJBcnJheSYmKERbMV09MCxEWzJdPTAsRFs0XT0wLERbNV09MCksRFswXT0xLERbM109MSxEfWZ1bmN0aW9uIGYoRCl7dmFyIEk9bmV3IG4uQVJSQVlfVFlQRSg2KTtyZXR1cm4gSVswXT1EWzBdLElbMV09RFsxXSxJWzJdPURbMl0sSVszXT1EWzNdLElbNF09RFs0XSxJWzVdPURbNV0sSX1mdW5jdGlvbiBoKEQsSSl7cmV0dXJuIERbMF09SVswXSxEWzFdPUlbMV0sRFsyXT1JWzJdLERbM109SVszXSxEWzRdPUlbNF0sRFs1XT1JWzVdLER9ZnVuY3Rpb24gdShEKXtyZXR1cm4gRFswXT0xLERbMV09MCxEWzJdPTAsRFszXT0xLERbNF09MCxEWzVdPTAsRH1mdW5jdGlvbiBhKEQsSSxqLFYsSixfKXt2YXIgc3Q9bmV3IG4uQVJSQVlfVFlQRSg2KTtyZXR1cm4gc3RbMF09RCxzdFsxXT1JLHN0WzJdPWosc3RbM109VixzdFs0XT1KLHN0WzVdPV8sc3R9ZnVuY3Rpb24gZChELEksaixWLEosXyxzdCl7cmV0dXJuIERbMF09SSxEWzFdPWosRFsyXT1WLERbM109SixEWzRdPV8sRFs1XT1zdCxEfWZ1bmN0aW9uIEUoRCxJKXt2YXIgaj1JWzBdLFY9SVsxXSxKPUlbMl0sXz1JWzNdLHN0PUlbNF0sRz1JWzVdLFk9aipfLVYqSjtyZXR1cm4gWT8oWT0xL1ksRFswXT1fKlksRFsxXT0tVipZLERbMl09LUoqWSxEWzNdPWoqWSxEWzRdPShKKkctXypzdCkqWSxEWzVdPShWKnN0LWoqRykqWSxEKTpudWxsfWZ1bmN0aW9uIHAoRCl7cmV0dXJuIERbMF0qRFszXS1EWzFdKkRbMl19ZnVuY3Rpb24gTyhELEksail7dmFyIFY9SVswXSxKPUlbMV0sXz1JWzJdLHN0PUlbM10sRz1JWzRdLFk9SVs1XSxydD1qWzBdLG90PWpbMV0sYXQ9alsyXSxodD1qWzNdLGl0PWpbNF0sTXQ9als1XTtyZXR1cm4gRFswXT1WKnJ0K18qb3QsRFsxXT1KKnJ0K3N0Km90LERbMl09ViphdCtfKmh0LERbM109SiphdCtzdCpodCxEWzRdPVYqaXQrXypNdCtHLERbNV09SippdCtzdCpNdCtZLER9ZnVuY3Rpb24gbShELEksail7dmFyIFY9SVswXSxKPUlbMV0sXz1JWzJdLHN0PUlbM10sRz1JWzRdLFk9SVs1XSxydD1NYXRoLnNpbihqKSxvdD1NYXRoLmNvcyhqKTtyZXR1cm4gRFswXT1WKm90K18qcnQsRFsxXT1KKm90K3N0KnJ0LERbMl09ViotcnQrXypvdCxEWzNdPUoqLXJ0K3N0Km90LERbNF09RyxEWzVdPVksRH1mdW5jdGlvbiBiKEQsSSxqKXt2YXIgVj1JWzBdLEo9SVsxXSxfPUlbMl0sc3Q9SVszXSxHPUlbNF0sWT1JWzVdLHJ0PWpbMF0sb3Q9alsxXTtyZXR1cm4gRFswXT1WKnJ0LERbMV09SipydCxEWzJdPV8qb3QsRFszXT1zdCpvdCxEWzRdPUcsRFs1XT1ZLER9ZnVuY3Rpb24gTShELEksail7dmFyIFY9SVswXSxKPUlbMV0sXz1JWzJdLHN0PUlbM10sRz1JWzRdLFk9SVs1XSxydD1qWzBdLG90PWpbMV07cmV0dXJuIERbMF09VixEWzFdPUosRFsyXT1fLERbM109c3QsRFs0XT1WKnJ0K18qb3QrRyxEWzVdPUoqcnQrc3Qqb3QrWSxEfWZ1bmN0aW9uIHkoRCxJKXt2YXIgaj1NYXRoLnNpbihJKSxWPU1hdGguY29zKEkpO3JldHVybiBEWzBdPVYsRFsxXT1qLERbMl09LWosRFszXT1WLERbNF09MCxEWzVdPTAsRH1mdW5jdGlvbiBTKEQsSSl7cmV0dXJuIERbMF09SVswXSxEWzFdPTAsRFsyXT0wLERbM109SVsxXSxEWzRdPTAsRFs1XT0wLER9ZnVuY3Rpb24gcyhELEkpe3JldHVybiBEWzBdPTEsRFsxXT0wLERbMl09MCxEWzNdPTEsRFs0XT1JWzBdLERbNV09SVsxXSxEfWZ1bmN0aW9uIGMoRCl7cmV0dXJuIm1hdDJkKCIrRFswXSsiLCAiK0RbMV0rIiwgIitEWzJdKyIsICIrRFszXSsiLCAiK0RbNF0rIiwgIitEWzVdKyIpIn1mdW5jdGlvbiBsKEQpe3JldHVybiBNYXRoLmh5cG90KERbMF0sRFsxXSxEWzJdLERbM10sRFs0XSxEWzVdLDEpfWZ1bmN0aW9uIHYoRCxJLGope3JldHVybiBEWzBdPUlbMF0ralswXSxEWzFdPUlbMV0ralsxXSxEWzJdPUlbMl0ralsyXSxEWzNdPUlbM10ralszXSxEWzRdPUlbNF0rals0XSxEWzVdPUlbNV0rals1XSxEfWZ1bmN0aW9uIFQoRCxJLGope3JldHVybiBEWzBdPUlbMF0talswXSxEWzFdPUlbMV0talsxXSxEWzJdPUlbMl0talsyXSxEWzNdPUlbM10talszXSxEWzRdPUlbNF0tals0XSxEWzVdPUlbNV0tals1XSxEfWZ1bmN0aW9uIFIoRCxJLGope3JldHVybiBEWzBdPUlbMF0qaixEWzFdPUlbMV0qaixEWzJdPUlbMl0qaixEWzNdPUlbM10qaixEWzRdPUlbNF0qaixEWzVdPUlbNV0qaixEfWZ1bmN0aW9uIEwoRCxJLGosVil7cmV0dXJuIERbMF09SVswXStqWzBdKlYsRFsxXT1JWzFdK2pbMV0qVixEWzJdPUlbMl0ralsyXSpWLERbM109SVszXStqWzNdKlYsRFs0XT1JWzRdK2pbNF0qVixEWzVdPUlbNV0rals1XSpWLER9ZnVuY3Rpb24gTihELEkpe3JldHVybiBEWzBdPT09SVswXSYmRFsxXT09PUlbMV0mJkRbMl09PT1JWzJdJiZEWzNdPT09SVszXSYmRFs0XT09PUlbNF0mJkRbNV09PT1JWzVdfWZ1bmN0aW9uIEEoRCxJKXt2YXIgaj1EWzBdLFY9RFsxXSxKPURbMl0sXz1EWzNdLHN0PURbNF0sRz1EWzVdLFk9SVswXSxydD1JWzFdLG90PUlbMl0sYXQ9SVszXSxodD1JWzRdLGl0PUlbNV07cmV0dXJuIE1hdGguYWJzKGotWSk8PW4uRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKGopLE1hdGguYWJzKFkpKSYmTWF0aC5hYnMoVi1ydCk8PW4uRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKFYpLE1hdGguYWJzKHJ0KSkmJk1hdGguYWJzKEotb3QpPD1uLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhKKSxNYXRoLmFicyhvdCkpJiZNYXRoLmFicyhfLWF0KTw9bi5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoXyksTWF0aC5hYnMoYXQpKSYmTWF0aC5hYnMoc3QtaHQpPD1uLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhzdCksTWF0aC5hYnMoaHQpKSYmTWF0aC5hYnMoRy1pdCk8PW4uRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKEcpLE1hdGguYWJzKGl0KSl9dmFyIHc9TyxCPVR9LGZ1bmN0aW9uKGcsZSx0KXt0LnIoZSksdC5kKGUsImNyZWF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gaX0pLHQuZChlLCJmcm9tTWF0NCIsZnVuY3Rpb24oKXtyZXR1cm4gZn0pLHQuZChlLCJjbG9uZSIsZnVuY3Rpb24oKXtyZXR1cm4gaH0pLHQuZChlLCJjb3B5IixmdW5jdGlvbigpe3JldHVybiB1fSksdC5kKGUsImZyb21WYWx1ZXMiLGZ1bmN0aW9uKCl7cmV0dXJuIGF9KSx0LmQoZSwic2V0IixmdW5jdGlvbigpe3JldHVybiBkfSksdC5kKGUsImlkZW50aXR5IixmdW5jdGlvbigpe3JldHVybiBFfSksdC5kKGUsInRyYW5zcG9zZSIsZnVuY3Rpb24oKXtyZXR1cm4gcH0pLHQuZChlLCJpbnZlcnQiLGZ1bmN0aW9uKCl7cmV0dXJuIE99KSx0LmQoZSwiYWRqb2ludCIsZnVuY3Rpb24oKXtyZXR1cm4gbX0pLHQuZChlLCJkZXRlcm1pbmFudCIsZnVuY3Rpb24oKXtyZXR1cm4gYn0pLHQuZChlLCJtdWx0aXBseSIsZnVuY3Rpb24oKXtyZXR1cm4gTX0pLHQuZChlLCJ0cmFuc2xhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIHl9KSx0LmQoZSwicm90YXRlIixmdW5jdGlvbigpe3JldHVybiBTfSksdC5kKGUsInNjYWxlIixmdW5jdGlvbigpe3JldHVybiBzfSksdC5kKGUsImZyb21UcmFuc2xhdGlvbiIsZnVuY3Rpb24oKXtyZXR1cm4gY30pLHQuZChlLCJmcm9tUm90YXRpb24iLGZ1bmN0aW9uKCl7cmV0dXJuIGx9KSx0LmQoZSwiZnJvbVNjYWxpbmciLGZ1bmN0aW9uKCl7cmV0dXJuIHZ9KSx0LmQoZSwiZnJvbU1hdDJkIixmdW5jdGlvbigpe3JldHVybiBUfSksdC5kKGUsImZyb21RdWF0IixmdW5jdGlvbigpe3JldHVybiBSfSksdC5kKGUsIm5vcm1hbEZyb21NYXQ0IixmdW5jdGlvbigpe3JldHVybiBMfSksdC5kKGUsInByb2plY3Rpb24iLGZ1bmN0aW9uKCl7cmV0dXJuIE59KSx0LmQoZSwic3RyIixmdW5jdGlvbigpe3JldHVybiBBfSksdC5kKGUsImZyb2IiLGZ1bmN0aW9uKCl7cmV0dXJuIHd9KSx0LmQoZSwiYWRkIixmdW5jdGlvbigpe3JldHVybiBCfSksdC5kKGUsInN1YnRyYWN0IixmdW5jdGlvbigpe3JldHVybiBEfSksdC5kKGUsIm11bHRpcGx5U2NhbGFyIixmdW5jdGlvbigpe3JldHVybiBJfSksdC5kKGUsIm11bHRpcGx5U2NhbGFyQW5kQWRkIixmdW5jdGlvbigpe3JldHVybiBqfSksdC5kKGUsImV4YWN0RXF1YWxzIixmdW5jdGlvbigpe3JldHVybiBWfSksdC5kKGUsImVxdWFscyIsZnVuY3Rpb24oKXtyZXR1cm4gSn0pLHQuZChlLCJtdWwiLGZ1bmN0aW9uKCl7cmV0dXJuIF99KSx0LmQoZSwic3ViIixmdW5jdGlvbigpe3JldHVybiBzdH0pO3ZhciBuPXQoMik7ZnVuY3Rpb24gaSgpe3ZhciBHPW5ldyBuLkFSUkFZX1RZUEUoOSk7cmV0dXJuIG4uQVJSQVlfVFlQRSE9RmxvYXQzMkFycmF5JiYoR1sxXT0wLEdbMl09MCxHWzNdPTAsR1s1XT0wLEdbNl09MCxHWzddPTApLEdbMF09MSxHWzRdPTEsR1s4XT0xLEd9ZnVuY3Rpb24gZihHLFkpe3JldHVybiBHWzBdPVlbMF0sR1sxXT1ZWzFdLEdbMl09WVsyXSxHWzNdPVlbNF0sR1s0XT1ZWzVdLEdbNV09WVs2XSxHWzZdPVlbOF0sR1s3XT1ZWzldLEdbOF09WVsxMF0sR31mdW5jdGlvbiBoKEcpe3ZhciBZPW5ldyBuLkFSUkFZX1RZUEUoOSk7cmV0dXJuIFlbMF09R1swXSxZWzFdPUdbMV0sWVsyXT1HWzJdLFlbM109R1szXSxZWzRdPUdbNF0sWVs1XT1HWzVdLFlbNl09R1s2XSxZWzddPUdbN10sWVs4XT1HWzhdLFl9ZnVuY3Rpb24gdShHLFkpe3JldHVybiBHWzBdPVlbMF0sR1sxXT1ZWzFdLEdbMl09WVsyXSxHWzNdPVlbM10sR1s0XT1ZWzRdLEdbNV09WVs1XSxHWzZdPVlbNl0sR1s3XT1ZWzddLEdbOF09WVs4XSxHfWZ1bmN0aW9uIGEoRyxZLHJ0LG90LGF0LGh0LGl0LE10LE90KXt2YXIgVT1uZXcgbi5BUlJBWV9UWVBFKDkpO3JldHVybiBVWzBdPUcsVVsxXT1ZLFVbMl09cnQsVVszXT1vdCxVWzRdPWF0LFVbNV09aHQsVVs2XT1pdCxVWzddPU10LFVbOF09T3QsVX1mdW5jdGlvbiBkKEcsWSxydCxvdCxhdCxodCxpdCxNdCxPdCxVKXtyZXR1cm4gR1swXT1ZLEdbMV09cnQsR1syXT1vdCxHWzNdPWF0LEdbNF09aHQsR1s1XT1pdCxHWzZdPU10LEdbN109T3QsR1s4XT1VLEd9ZnVuY3Rpb24gRShHKXtyZXR1cm4gR1swXT0xLEdbMV09MCxHWzJdPTAsR1szXT0wLEdbNF09MSxHWzVdPTAsR1s2XT0wLEdbN109MCxHWzhdPTEsR31mdW5jdGlvbiBwKEcsWSl7aWYoRz09PVkpe3ZhciBydD1ZWzFdLG90PVlbMl0sYXQ9WVs1XTtHWzFdPVlbM10sR1syXT1ZWzZdLEdbM109cnQsR1s1XT1ZWzddLEdbNl09b3QsR1s3XT1hdH1lbHNlIEdbMF09WVswXSxHWzFdPVlbM10sR1syXT1ZWzZdLEdbM109WVsxXSxHWzRdPVlbNF0sR1s1XT1ZWzddLEdbNl09WVsyXSxHWzddPVlbNV0sR1s4XT1ZWzhdO3JldHVybiBHfWZ1bmN0aW9uIE8oRyxZKXt2YXIgcnQ9WVswXSxvdD1ZWzFdLGF0PVlbMl0saHQ9WVszXSxpdD1ZWzRdLE10PVlbNV0sT3Q9WVs2XSxVPVlbN10sJD1ZWzhdLFE9JCppdC1NdCpVLHR0PS0kKmh0K010Kk90LEY9VSpodC1pdCpPdCxIPXJ0KlErb3QqdHQrYXQqRjtyZXR1cm4gSD8oSD0xL0gsR1swXT1RKkgsR1sxXT0oLSQqb3QrYXQqVSkqSCxHWzJdPShNdCpvdC1hdCppdCkqSCxHWzNdPXR0KkgsR1s0XT0oJCpydC1hdCpPdCkqSCxHWzVdPSgtTXQqcnQrYXQqaHQpKkgsR1s2XT1GKkgsR1s3XT0oLVUqcnQrb3QqT3QpKkgsR1s4XT0oaXQqcnQtb3QqaHQpKkgsRyk6bnVsbH1mdW5jdGlvbiBtKEcsWSl7dmFyIHJ0PVlbMF0sb3Q9WVsxXSxhdD1ZWzJdLGh0PVlbM10saXQ9WVs0XSxNdD1ZWzVdLE90PVlbNl0sVT1ZWzddLCQ9WVs4XTtyZXR1cm4gR1swXT1pdCokLU10KlUsR1sxXT1hdCpVLW90KiQsR1syXT1vdCpNdC1hdCppdCxHWzNdPU10Kk90LWh0KiQsR1s0XT1ydCokLWF0Kk90LEdbNV09YXQqaHQtcnQqTXQsR1s2XT1odCpVLWl0Kk90LEdbN109b3QqT3QtcnQqVSxHWzhdPXJ0Kml0LW90Kmh0LEd9ZnVuY3Rpb24gYihHKXt2YXIgWT1HWzBdLHJ0PUdbMV0sb3Q9R1syXSxhdD1HWzNdLGh0PUdbNF0saXQ9R1s1XSxNdD1HWzZdLE90PUdbN10sVT1HWzhdO3JldHVybiBZKihVKmh0LWl0Kk90KStydCooLVUqYXQraXQqTXQpK290KihPdCphdC1odCpNdCl9ZnVuY3Rpb24gTShHLFkscnQpe3ZhciBvdD1ZWzBdLGF0PVlbMV0saHQ9WVsyXSxpdD1ZWzNdLE10PVlbNF0sT3Q9WVs1XSxVPVlbNl0sJD1ZWzddLFE9WVs4XSx0dD1ydFswXSxGPXJ0WzFdLEg9cnRbMl0seD1ydFszXSxQPXJ0WzRdLFc9cnRbNV0sSz1ydFs2XSxaPXJ0WzddLGs9cnRbOF07cmV0dXJuIEdbMF09dHQqb3QrRippdCtIKlUsR1sxXT10dCphdCtGKk10K0gqJCxHWzJdPXR0Kmh0K0YqT3QrSCpRLEdbM109eCpvdCtQKml0K1cqVSxHWzRdPXgqYXQrUCpNdCtXKiQsR1s1XT14Kmh0K1AqT3QrVypRLEdbNl09SypvdCtaKml0K2sqVSxHWzddPUsqYXQrWipNdCtrKiQsR1s4XT1LKmh0K1oqT3QraypRLEd9ZnVuY3Rpb24geShHLFkscnQpe3ZhciBvdD1ZWzBdLGF0PVlbMV0saHQ9WVsyXSxpdD1ZWzNdLE10PVlbNF0sT3Q9WVs1XSxVPVlbNl0sJD1ZWzddLFE9WVs4XSx0dD1ydFswXSxGPXJ0WzFdO3JldHVybiBHWzBdPW90LEdbMV09YXQsR1syXT1odCxHWzNdPWl0LEdbNF09TXQsR1s1XT1PdCxHWzZdPXR0Km90K0YqaXQrVSxHWzddPXR0KmF0K0YqTXQrJCxHWzhdPXR0Kmh0K0YqT3QrUSxHfWZ1bmN0aW9uIFMoRyxZLHJ0KXt2YXIgb3Q9WVswXSxhdD1ZWzFdLGh0PVlbMl0saXQ9WVszXSxNdD1ZWzRdLE90PVlbNV0sVT1ZWzZdLCQ9WVs3XSxRPVlbOF0sdHQ9TWF0aC5zaW4ocnQpLEY9TWF0aC5jb3MocnQpO3JldHVybiBHWzBdPUYqb3QrdHQqaXQsR1sxXT1GKmF0K3R0Kk10LEdbMl09RipodCt0dCpPdCxHWzNdPUYqaXQtdHQqb3QsR1s0XT1GKk10LXR0KmF0LEdbNV09RipPdC10dCpodCxHWzZdPVUsR1s3XT0kLEdbOF09USxHfWZ1bmN0aW9uIHMoRyxZLHJ0KXt2YXIgb3Q9cnRbMF0sYXQ9cnRbMV07cmV0dXJuIEdbMF09b3QqWVswXSxHWzFdPW90KllbMV0sR1syXT1vdCpZWzJdLEdbM109YXQqWVszXSxHWzRdPWF0KllbNF0sR1s1XT1hdCpZWzVdLEdbNl09WVs2XSxHWzddPVlbN10sR1s4XT1ZWzhdLEd9ZnVuY3Rpb24gYyhHLFkpe3JldHVybiBHWzBdPTEsR1sxXT0wLEdbMl09MCxHWzNdPTAsR1s0XT0xLEdbNV09MCxHWzZdPVlbMF0sR1s3XT1ZWzFdLEdbOF09MSxHfWZ1bmN0aW9uIGwoRyxZKXt2YXIgcnQ9TWF0aC5zaW4oWSksb3Q9TWF0aC5jb3MoWSk7cmV0dXJuIEdbMF09b3QsR1sxXT1ydCxHWzJdPTAsR1szXT0tcnQsR1s0XT1vdCxHWzVdPTAsR1s2XT0wLEdbN109MCxHWzhdPTEsR31mdW5jdGlvbiB2KEcsWSl7cmV0dXJuIEdbMF09WVswXSxHWzFdPTAsR1syXT0wLEdbM109MCxHWzRdPVlbMV0sR1s1XT0wLEdbNl09MCxHWzddPTAsR1s4XT0xLEd9ZnVuY3Rpb24gVChHLFkpe3JldHVybiBHWzBdPVlbMF0sR1sxXT1ZWzFdLEdbMl09MCxHWzNdPVlbMl0sR1s0XT1ZWzNdLEdbNV09MCxHWzZdPVlbNF0sR1s3XT1ZWzVdLEdbOF09MSxHfWZ1bmN0aW9uIFIoRyxZKXt2YXIgcnQ9WVswXSxvdD1ZWzFdLGF0PVlbMl0saHQ9WVszXSxpdD1ydCtydCxNdD1vdCtvdCxPdD1hdCthdCxVPXJ0Kml0LCQ9b3QqaXQsUT1vdCpNdCx0dD1hdCppdCxGPWF0Kk10LEg9YXQqT3QseD1odCppdCxQPWh0Kk10LFc9aHQqT3Q7cmV0dXJuIEdbMF09MS1RLUgsR1szXT0kLVcsR1s2XT10dCtQLEdbMV09JCtXLEdbNF09MS1VLUgsR1s3XT1GLXgsR1syXT10dC1QLEdbNV09Rit4LEdbOF09MS1VLVEsR31mdW5jdGlvbiBMKEcsWSl7dmFyIHJ0PVlbMF0sb3Q9WVsxXSxhdD1ZWzJdLGh0PVlbM10saXQ9WVs0XSxNdD1ZWzVdLE90PVlbNl0sVT1ZWzddLCQ9WVs4XSxRPVlbOV0sdHQ9WVsxMF0sRj1ZWzExXSxIPVlbMTJdLHg9WVsxM10sUD1ZWzE0XSxXPVlbMTVdLEs9cnQqTXQtb3QqaXQsWj1ydCpPdC1hdCppdCxrPXJ0KlUtaHQqaXQsbnQ9b3QqT3QtYXQqTXQsdXQ9b3QqVS1odCpNdCxjdD1hdCpVLWh0Kk90LHB0PSQqeC1RKkgseHQ9JCpQLXR0KkgsZ3Q9JCpXLUYqSCxkdD1RKlAtdHQqeCxtdD1RKlctRip4LGJ0PXR0KlctRipQLEN0PUsqYnQtWiptdCtrKmR0K250Kmd0LXV0Knh0K2N0KnB0O3JldHVybiBDdD8oQ3Q9MS9DdCxHWzBdPShNdCpidC1PdCptdCtVKmR0KSpDdCxHWzFdPShPdCpndC1pdCpidC1VKnh0KSpDdCxHWzJdPShpdCptdC1NdCpndCtVKnB0KSpDdCxHWzNdPShhdCptdC1vdCpidC1odCpkdCkqQ3QsR1s0XT0ocnQqYnQtYXQqZ3QraHQqeHQpKkN0LEdbNV09KG90Kmd0LXJ0Km10LWh0KnB0KSpDdCxHWzZdPSh4KmN0LVAqdXQrVypudCkqQ3QsR1s3XT0oUCprLUgqY3QtVypaKSpDdCxHWzhdPShIKnV0LXgqaytXKkspKkN0LEcpOm51bGx9ZnVuY3Rpb24gTihHLFkscnQpe3JldHVybiBHWzBdPTIvWSxHWzFdPTAsR1syXT0wLEdbM109MCxHWzRdPS0yL3J0LEdbNV09MCxHWzZdPS0xLEdbN109MSxHWzhdPTEsR31mdW5jdGlvbiBBKEcpe3JldHVybiJtYXQzKCIrR1swXSsiLCAiK0dbMV0rIiwgIitHWzJdKyIsICIrR1szXSsiLCAiK0dbNF0rIiwgIitHWzVdKyIsICIrR1s2XSsiLCAiK0dbN10rIiwgIitHWzhdKyIpIn1mdW5jdGlvbiB3KEcpe3JldHVybiBNYXRoLmh5cG90KEdbMF0sR1sxXSxHWzJdLEdbM10sR1s0XSxHWzVdLEdbNl0sR1s3XSxHWzhdKX1mdW5jdGlvbiBCKEcsWSxydCl7cmV0dXJuIEdbMF09WVswXStydFswXSxHWzFdPVlbMV0rcnRbMV0sR1syXT1ZWzJdK3J0WzJdLEdbM109WVszXStydFszXSxHWzRdPVlbNF0rcnRbNF0sR1s1XT1ZWzVdK3J0WzVdLEdbNl09WVs2XStydFs2XSxHWzddPVlbN10rcnRbN10sR1s4XT1ZWzhdK3J0WzhdLEd9ZnVuY3Rpb24gRChHLFkscnQpe3JldHVybiBHWzBdPVlbMF0tcnRbMF0sR1sxXT1ZWzFdLXJ0WzFdLEdbMl09WVsyXS1ydFsyXSxHWzNdPVlbM10tcnRbM10sR1s0XT1ZWzRdLXJ0WzRdLEdbNV09WVs1XS1ydFs1XSxHWzZdPVlbNl0tcnRbNl0sR1s3XT1ZWzddLXJ0WzddLEdbOF09WVs4XS1ydFs4XSxHfWZ1bmN0aW9uIEkoRyxZLHJ0KXtyZXR1cm4gR1swXT1ZWzBdKnJ0LEdbMV09WVsxXSpydCxHWzJdPVlbMl0qcnQsR1szXT1ZWzNdKnJ0LEdbNF09WVs0XSpydCxHWzVdPVlbNV0qcnQsR1s2XT1ZWzZdKnJ0LEdbN109WVs3XSpydCxHWzhdPVlbOF0qcnQsR31mdW5jdGlvbiBqKEcsWSxydCxvdCl7cmV0dXJuIEdbMF09WVswXStydFswXSpvdCxHWzFdPVlbMV0rcnRbMV0qb3QsR1syXT1ZWzJdK3J0WzJdKm90LEdbM109WVszXStydFszXSpvdCxHWzRdPVlbNF0rcnRbNF0qb3QsR1s1XT1ZWzVdK3J0WzVdKm90LEdbNl09WVs2XStydFs2XSpvdCxHWzddPVlbN10rcnRbN10qb3QsR1s4XT1ZWzhdK3J0WzhdKm90LEd9ZnVuY3Rpb24gVihHLFkpe3JldHVybiBHWzBdPT09WVswXSYmR1sxXT09PVlbMV0mJkdbMl09PT1ZWzJdJiZHWzNdPT09WVszXSYmR1s0XT09PVlbNF0mJkdbNV09PT1ZWzVdJiZHWzZdPT09WVs2XSYmR1s3XT09PVlbN10mJkdbOF09PT1ZWzhdfWZ1bmN0aW9uIEooRyxZKXt2YXIgcnQ9R1swXSxvdD1HWzFdLGF0PUdbMl0saHQ9R1szXSxpdD1HWzRdLE10PUdbNV0sT3Q9R1s2XSxVPUdbN10sJD1HWzhdLFE9WVswXSx0dD1ZWzFdLEY9WVsyXSxIPVlbM10seD1ZWzRdLFA9WVs1XSxXPVlbNl0sSz1ZWzddLFo9WVs4XTtyZXR1cm4gTWF0aC5hYnMocnQtUSk8PW4uRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKHJ0KSxNYXRoLmFicyhRKSkmJk1hdGguYWJzKG90LXR0KTw9bi5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMob3QpLE1hdGguYWJzKHR0KSkmJk1hdGguYWJzKGF0LUYpPD1uLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhhdCksTWF0aC5hYnMoRikpJiZNYXRoLmFicyhodC1IKTw9bi5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoaHQpLE1hdGguYWJzKEgpKSYmTWF0aC5hYnMoaXQteCk8PW4uRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKGl0KSxNYXRoLmFicyh4KSkmJk1hdGguYWJzKE10LVApPD1uLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhNdCksTWF0aC5hYnMoUCkpJiZNYXRoLmFicyhPdC1XKTw9bi5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoT3QpLE1hdGguYWJzKFcpKSYmTWF0aC5hYnMoVS1LKTw9bi5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoVSksTWF0aC5hYnMoSykpJiZNYXRoLmFicygkLVopPD1uLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicygkKSxNYXRoLmFicyhaKSl9dmFyIF89TSxzdD1EfSxmdW5jdGlvbihnLGUsdCl7dC5yKGUpLHQuZChlLCJjcmVhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIGl9KSx0LmQoZSwiY2xvbmUiLGZ1bmN0aW9uKCl7cmV0dXJuIGZ9KSx0LmQoZSwiY29weSIsZnVuY3Rpb24oKXtyZXR1cm4gaH0pLHQuZChlLCJmcm9tVmFsdWVzIixmdW5jdGlvbigpe3JldHVybiB1fSksdC5kKGUsInNldCIsZnVuY3Rpb24oKXtyZXR1cm4gYX0pLHQuZChlLCJpZGVudGl0eSIsZnVuY3Rpb24oKXtyZXR1cm4gZH0pLHQuZChlLCJ0cmFuc3Bvc2UiLGZ1bmN0aW9uKCl7cmV0dXJuIEV9KSx0LmQoZSwiaW52ZXJ0IixmdW5jdGlvbigpe3JldHVybiBwfSksdC5kKGUsImFkam9pbnQiLGZ1bmN0aW9uKCl7cmV0dXJuIE99KSx0LmQoZSwiZGV0ZXJtaW5hbnQiLGZ1bmN0aW9uKCl7cmV0dXJuIG19KSx0LmQoZSwibXVsdGlwbHkiLGZ1bmN0aW9uKCl7cmV0dXJuIGJ9KSx0LmQoZSwidHJhbnNsYXRlIixmdW5jdGlvbigpe3JldHVybiBNfSksdC5kKGUsInNjYWxlIixmdW5jdGlvbigpe3JldHVybiB5fSksdC5kKGUsInJvdGF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gU30pLHQuZChlLCJyb3RhdGVYIixmdW5jdGlvbigpe3JldHVybiBzfSksdC5kKGUsInJvdGF0ZVkiLGZ1bmN0aW9uKCl7cmV0dXJuIGN9KSx0LmQoZSwicm90YXRlWiIsZnVuY3Rpb24oKXtyZXR1cm4gbH0pLHQuZChlLCJmcm9tVHJhbnNsYXRpb24iLGZ1bmN0aW9uKCl7cmV0dXJuIHZ9KSx0LmQoZSwiZnJvbVNjYWxpbmciLGZ1bmN0aW9uKCl7cmV0dXJuIFR9KSx0LmQoZSwiZnJvbVJvdGF0aW9uIixmdW5jdGlvbigpe3JldHVybiBSfSksdC5kKGUsImZyb21YUm90YXRpb24iLGZ1bmN0aW9uKCl7cmV0dXJuIEx9KSx0LmQoZSwiZnJvbVlSb3RhdGlvbiIsZnVuY3Rpb24oKXtyZXR1cm4gTn0pLHQuZChlLCJmcm9tWlJvdGF0aW9uIixmdW5jdGlvbigpe3JldHVybiBBfSksdC5kKGUsImZyb21Sb3RhdGlvblRyYW5zbGF0aW9uIixmdW5jdGlvbigpe3JldHVybiB3fSksdC5kKGUsImZyb21RdWF0MiIsZnVuY3Rpb24oKXtyZXR1cm4gQn0pLHQuZChlLCJnZXRUcmFuc2xhdGlvbiIsZnVuY3Rpb24oKXtyZXR1cm4gRH0pLHQuZChlLCJnZXRTY2FsaW5nIixmdW5jdGlvbigpe3JldHVybiBJfSksdC5kKGUsImdldFJvdGF0aW9uIixmdW5jdGlvbigpe3JldHVybiBqfSksdC5kKGUsImZyb21Sb3RhdGlvblRyYW5zbGF0aW9uU2NhbGUiLGZ1bmN0aW9uKCl7cmV0dXJuIFZ9KSx0LmQoZSwiZnJvbVJvdGF0aW9uVHJhbnNsYXRpb25TY2FsZU9yaWdpbiIsZnVuY3Rpb24oKXtyZXR1cm4gSn0pLHQuZChlLCJmcm9tUXVhdCIsZnVuY3Rpb24oKXtyZXR1cm4gX30pLHQuZChlLCJmcnVzdHVtIixmdW5jdGlvbigpe3JldHVybiBzdH0pLHQuZChlLCJwZXJzcGVjdGl2ZSIsZnVuY3Rpb24oKXtyZXR1cm4gR30pLHQuZChlLCJwZXJzcGVjdGl2ZUZyb21GaWVsZE9mVmlldyIsZnVuY3Rpb24oKXtyZXR1cm4gWX0pLHQuZChlLCJvcnRobyIsZnVuY3Rpb24oKXtyZXR1cm4gcnR9KSx0LmQoZSwibG9va0F0IixmdW5jdGlvbigpe3JldHVybiBvdH0pLHQuZChlLCJ0YXJnZXRUbyIsZnVuY3Rpb24oKXtyZXR1cm4gYXR9KSx0LmQoZSwic3RyIixmdW5jdGlvbigpe3JldHVybiBodH0pLHQuZChlLCJmcm9iIixmdW5jdGlvbigpe3JldHVybiBpdH0pLHQuZChlLCJhZGQiLGZ1bmN0aW9uKCl7cmV0dXJuIE10fSksdC5kKGUsInN1YnRyYWN0IixmdW5jdGlvbigpe3JldHVybiBPdH0pLHQuZChlLCJtdWx0aXBseVNjYWxhciIsZnVuY3Rpb24oKXtyZXR1cm4gVX0pLHQuZChlLCJtdWx0aXBseVNjYWxhckFuZEFkZCIsZnVuY3Rpb24oKXtyZXR1cm4gJH0pLHQuZChlLCJleGFjdEVxdWFscyIsZnVuY3Rpb24oKXtyZXR1cm4gUX0pLHQuZChlLCJlcXVhbHMiLGZ1bmN0aW9uKCl7cmV0dXJuIHR0fSksdC5kKGUsIm11bCIsZnVuY3Rpb24oKXtyZXR1cm4gRn0pLHQuZChlLCJzdWIiLGZ1bmN0aW9uKCl7cmV0dXJuIEh9KTt2YXIgbj10KDIpO2Z1bmN0aW9uIGkoKXt2YXIgeD1uZXcgbi5BUlJBWV9UWVBFKDE2KTtyZXR1cm4gbi5BUlJBWV9UWVBFIT1GbG9hdDMyQXJyYXkmJih4WzFdPTAseFsyXT0wLHhbM109MCx4WzRdPTAseFs2XT0wLHhbN109MCx4WzhdPTAseFs5XT0wLHhbMTFdPTAseFsxMl09MCx4WzEzXT0wLHhbMTRdPTApLHhbMF09MSx4WzVdPTEseFsxMF09MSx4WzE1XT0xLHh9ZnVuY3Rpb24gZih4KXt2YXIgUD1uZXcgbi5BUlJBWV9UWVBFKDE2KTtyZXR1cm4gUFswXT14WzBdLFBbMV09eFsxXSxQWzJdPXhbMl0sUFszXT14WzNdLFBbNF09eFs0XSxQWzVdPXhbNV0sUFs2XT14WzZdLFBbN109eFs3XSxQWzhdPXhbOF0sUFs5XT14WzldLFBbMTBdPXhbMTBdLFBbMTFdPXhbMTFdLFBbMTJdPXhbMTJdLFBbMTNdPXhbMTNdLFBbMTRdPXhbMTRdLFBbMTVdPXhbMTVdLFB9ZnVuY3Rpb24gaCh4LFApe3JldHVybiB4WzBdPVBbMF0seFsxXT1QWzFdLHhbMl09UFsyXSx4WzNdPVBbM10seFs0XT1QWzRdLHhbNV09UFs1XSx4WzZdPVBbNl0seFs3XT1QWzddLHhbOF09UFs4XSx4WzldPVBbOV0seFsxMF09UFsxMF0seFsxMV09UFsxMV0seFsxMl09UFsxMl0seFsxM109UFsxM10seFsxNF09UFsxNF0seFsxNV09UFsxNV0seH1mdW5jdGlvbiB1KHgsUCxXLEssWixrLG50LHV0LGN0LHB0LHh0LGd0LGR0LG10LGJ0LEN0KXt2YXIgU3Q9bmV3IG4uQVJSQVlfVFlQRSgxNik7cmV0dXJuIFN0WzBdPXgsU3RbMV09UCxTdFsyXT1XLFN0WzNdPUssU3RbNF09WixTdFs1XT1rLFN0WzZdPW50LFN0WzddPXV0LFN0WzhdPWN0LFN0WzldPXB0LFN0WzEwXT14dCxTdFsxMV09Z3QsU3RbMTJdPWR0LFN0WzEzXT1tdCxTdFsxNF09YnQsU3RbMTVdPUN0LFN0fWZ1bmN0aW9uIGEoeCxQLFcsSyxaLGssbnQsdXQsY3QscHQseHQsZ3QsZHQsbXQsYnQsQ3QsU3Qpe3JldHVybiB4WzBdPVAseFsxXT1XLHhbMl09Syx4WzNdPVoseFs0XT1rLHhbNV09bnQseFs2XT11dCx4WzddPWN0LHhbOF09cHQseFs5XT14dCx4WzEwXT1ndCx4WzExXT1kdCx4WzEyXT1tdCx4WzEzXT1idCx4WzE0XT1DdCx4WzE1XT1TdCx4fWZ1bmN0aW9uIGQoeCl7cmV0dXJuIHhbMF09MSx4WzFdPTAseFsyXT0wLHhbM109MCx4WzRdPTAseFs1XT0xLHhbNl09MCx4WzddPTAseFs4XT0wLHhbOV09MCx4WzEwXT0xLHhbMTFdPTAseFsxMl09MCx4WzEzXT0wLHhbMTRdPTAseFsxNV09MSx4fWZ1bmN0aW9uIEUoeCxQKXtpZih4PT09UCl7dmFyIFc9UFsxXSxLPVBbMl0sWj1QWzNdLGs9UFs2XSxudD1QWzddLHV0PVBbMTFdO3hbMV09UFs0XSx4WzJdPVBbOF0seFszXT1QWzEyXSx4WzRdPVcseFs2XT1QWzldLHhbN109UFsxM10seFs4XT1LLHhbOV09ayx4WzExXT1QWzE0XSx4WzEyXT1aLHhbMTNdPW50LHhbMTRdPXV0fWVsc2UgeFswXT1QWzBdLHhbMV09UFs0XSx4WzJdPVBbOF0seFszXT1QWzEyXSx4WzRdPVBbMV0seFs1XT1QWzVdLHhbNl09UFs5XSx4WzddPVBbMTNdLHhbOF09UFsyXSx4WzldPVBbNl0seFsxMF09UFsxMF0seFsxMV09UFsxNF0seFsxMl09UFszXSx4WzEzXT1QWzddLHhbMTRdPVBbMTFdLHhbMTVdPVBbMTVdO3JldHVybiB4fWZ1bmN0aW9uIHAoeCxQKXt2YXIgVz1QWzBdLEs9UFsxXSxaPVBbMl0saz1QWzNdLG50PVBbNF0sdXQ9UFs1XSxjdD1QWzZdLHB0PVBbN10seHQ9UFs4XSxndD1QWzldLGR0PVBbMTBdLG10PVBbMTFdLGJ0PVBbMTJdLEN0PVBbMTNdLFN0PVBbMTRdLE50PVBbMTVdLEp0PVcqdXQtSypudCxHdD1XKmN0LVoqbnQsS3Q9VypwdC1rKm50LFl0PUsqY3QtWip1dCxWdD1LKnB0LWsqdXQsU2U9WipwdC1rKmN0LE9lPXh0KkN0LWd0KmJ0LEVlPXh0KlN0LWR0KmJ0LG1lPXh0Kk50LW10KmJ0LFRlPWd0KlN0LWR0KkN0LGJlPWd0Kk50LW10KkN0LEllPWR0Kk50LW10KlN0LHNlPUp0KkllLUd0KmJlK0t0KlRlK1l0Km1lLVZ0KkVlK1NlKk9lO3JldHVybiBzZT8oc2U9MS9zZSx4WzBdPSh1dCpJZS1jdCpiZStwdCpUZSkqc2UseFsxXT0oWipiZS1LKkllLWsqVGUpKnNlLHhbMl09KEN0KlNlLVN0KlZ0K050Kll0KSpzZSx4WzNdPShkdCpWdC1ndCpTZS1tdCpZdCkqc2UseFs0XT0oY3QqbWUtbnQqSWUtcHQqRWUpKnNlLHhbNV09KFcqSWUtWiptZStrKkVlKSpzZSx4WzZdPShTdCpLdC1idCpTZS1OdCpHdCkqc2UseFs3XT0oeHQqU2UtZHQqS3QrbXQqR3QpKnNlLHhbOF09KG50KmJlLXV0Km1lK3B0Kk9lKSpzZSx4WzldPShLKm1lLVcqYmUtaypPZSkqc2UseFsxMF09KGJ0KlZ0LUN0Kkt0K050Kkp0KSpzZSx4WzExXT0oZ3QqS3QteHQqVnQtbXQqSnQpKnNlLHhbMTJdPSh1dCpFZS1udCpUZS1jdCpPZSkqc2UseFsxM109KFcqVGUtSypFZStaKk9lKSpzZSx4WzE0XT0oQ3QqR3QtYnQqWXQtU3QqSnQpKnNlLHhbMTVdPSh4dCpZdC1ndCpHdCtkdCpKdCkqc2UseCk6bnVsbH1mdW5jdGlvbiBPKHgsUCl7dmFyIFc9UFswXSxLPVBbMV0sWj1QWzJdLGs9UFszXSxudD1QWzRdLHV0PVBbNV0sY3Q9UFs2XSxwdD1QWzddLHh0PVBbOF0sZ3Q9UFs5XSxkdD1QWzEwXSxtdD1QWzExXSxidD1QWzEyXSxDdD1QWzEzXSxTdD1QWzE0XSxOdD1QWzE1XTtyZXR1cm4geFswXT11dCooZHQqTnQtbXQqU3QpLWd0KihjdCpOdC1wdCpTdCkrQ3QqKGN0Km10LXB0KmR0KSx4WzFdPS0oSyooZHQqTnQtbXQqU3QpLWd0KihaKk50LWsqU3QpK0N0KihaKm10LWsqZHQpKSx4WzJdPUsqKGN0Kk50LXB0KlN0KS11dCooWipOdC1rKlN0KStDdCooWipwdC1rKmN0KSx4WzNdPS0oSyooY3QqbXQtcHQqZHQpLXV0KihaKm10LWsqZHQpK2d0KihaKnB0LWsqY3QpKSx4WzRdPS0obnQqKGR0Kk50LW10KlN0KS14dCooY3QqTnQtcHQqU3QpK2J0KihjdCptdC1wdCpkdCkpLHhbNV09VyooZHQqTnQtbXQqU3QpLXh0KihaKk50LWsqU3QpK2J0KihaKm10LWsqZHQpLHhbNl09LShXKihjdCpOdC1wdCpTdCktbnQqKFoqTnQtaypTdCkrYnQqKFoqcHQtaypjdCkpLHhbN109VyooY3QqbXQtcHQqZHQpLW50KihaKm10LWsqZHQpK3h0KihaKnB0LWsqY3QpLHhbOF09bnQqKGd0Kk50LW10KkN0KS14dCoodXQqTnQtcHQqQ3QpK2J0Kih1dCptdC1wdCpndCkseFs5XT0tKFcqKGd0Kk50LW10KkN0KS14dCooSypOdC1rKkN0KStidCooSyptdC1rKmd0KSkseFsxMF09VyoodXQqTnQtcHQqQ3QpLW50KihLKk50LWsqQ3QpK2J0KihLKnB0LWsqdXQpLHhbMTFdPS0oVyoodXQqbXQtcHQqZ3QpLW50KihLKm10LWsqZ3QpK3h0KihLKnB0LWsqdXQpKSx4WzEyXT0tKG50KihndCpTdC1kdCpDdCkteHQqKHV0KlN0LWN0KkN0KStidCoodXQqZHQtY3QqZ3QpKSx4WzEzXT1XKihndCpTdC1kdCpDdCkteHQqKEsqU3QtWipDdCkrYnQqKEsqZHQtWipndCkseFsxNF09LShXKih1dCpTdC1jdCpDdCktbnQqKEsqU3QtWipDdCkrYnQqKEsqY3QtWip1dCkpLHhbMTVdPVcqKHV0KmR0LWN0Kmd0KS1udCooSypkdC1aKmd0KSt4dCooSypjdC1aKnV0KSx4fWZ1bmN0aW9uIG0oeCl7dmFyIFA9eFswXSxXPXhbMV0sSz14WzJdLFo9eFszXSxrPXhbNF0sbnQ9eFs1XSx1dD14WzZdLGN0PXhbN10scHQ9eFs4XSx4dD14WzldLGd0PXhbMTBdLGR0PXhbMTFdLG10PXhbMTJdLGJ0PXhbMTNdLEN0PXhbMTRdLFN0PXhbMTVdLE50PVAqbnQtVyprLEp0PVAqdXQtSyprLEd0PVAqY3QtWiprLEt0PVcqdXQtSypudCxZdD1XKmN0LVoqbnQsVnQ9SypjdC1aKnV0LFNlPXB0KmJ0LXh0Km10LE9lPXB0KkN0LWd0Km10LEVlPXB0KlN0LWR0Km10LG1lPXh0KkN0LWd0KmJ0LFRlPXh0KlN0LWR0KmJ0LGJlPWd0KlN0LWR0KkN0O3JldHVybiBOdCpiZS1KdCpUZStHdCptZStLdCpFZS1ZdCpPZStWdCpTZX1mdW5jdGlvbiBiKHgsUCxXKXt2YXIgSz1QWzBdLFo9UFsxXSxrPVBbMl0sbnQ9UFszXSx1dD1QWzRdLGN0PVBbNV0scHQ9UFs2XSx4dD1QWzddLGd0PVBbOF0sZHQ9UFs5XSxtdD1QWzEwXSxidD1QWzExXSxDdD1QWzEyXSxTdD1QWzEzXSxOdD1QWzE0XSxKdD1QWzE1XSxHdD1XWzBdLEt0PVdbMV0sWXQ9V1syXSxWdD1XWzNdO3JldHVybiB4WzBdPUd0KksrS3QqdXQrWXQqZ3QrVnQqQ3QseFsxXT1HdCpaK0t0KmN0K1l0KmR0K1Z0KlN0LHhbMl09R3QqaytLdCpwdCtZdCptdCtWdCpOdCx4WzNdPUd0Km50K0t0Knh0K1l0KmJ0K1Z0Kkp0LEd0PVdbNF0sS3Q9V1s1XSxZdD1XWzZdLFZ0PVdbN10seFs0XT1HdCpLK0t0KnV0K1l0Kmd0K1Z0KkN0LHhbNV09R3QqWitLdCpjdCtZdCpkdCtWdCpTdCx4WzZdPUd0KmsrS3QqcHQrWXQqbXQrVnQqTnQseFs3XT1HdCpudCtLdCp4dCtZdCpidCtWdCpKdCxHdD1XWzhdLEt0PVdbOV0sWXQ9V1sxMF0sVnQ9V1sxMV0seFs4XT1HdCpLK0t0KnV0K1l0Kmd0K1Z0KkN0LHhbOV09R3QqWitLdCpjdCtZdCpkdCtWdCpTdCx4WzEwXT1HdCprK0t0KnB0K1l0Km10K1Z0Kk50LHhbMTFdPUd0Km50K0t0Knh0K1l0KmJ0K1Z0Kkp0LEd0PVdbMTJdLEt0PVdbMTNdLFl0PVdbMTRdLFZ0PVdbMTVdLHhbMTJdPUd0KksrS3QqdXQrWXQqZ3QrVnQqQ3QseFsxM109R3QqWitLdCpjdCtZdCpkdCtWdCpTdCx4WzE0XT1HdCprK0t0KnB0K1l0Km10K1Z0Kk50LHhbMTVdPUd0Km50K0t0Knh0K1l0KmJ0K1Z0Kkp0LHh9ZnVuY3Rpb24gTSh4LFAsVyl7dmFyIEs9V1swXSxaPVdbMV0saz1XWzJdLG50LHV0LGN0LHB0LHh0LGd0LGR0LG10LGJ0LEN0LFN0LE50O3JldHVybiBQPT09eD8oeFsxMl09UFswXSpLK1BbNF0qWitQWzhdKmsrUFsxMl0seFsxM109UFsxXSpLK1BbNV0qWitQWzldKmsrUFsxM10seFsxNF09UFsyXSpLK1BbNl0qWitQWzEwXSprK1BbMTRdLHhbMTVdPVBbM10qSytQWzddKlorUFsxMV0qaytQWzE1XSk6KG50PVBbMF0sdXQ9UFsxXSxjdD1QWzJdLHB0PVBbM10seHQ9UFs0XSxndD1QWzVdLGR0PVBbNl0sbXQ9UFs3XSxidD1QWzhdLEN0PVBbOV0sU3Q9UFsxMF0sTnQ9UFsxMV0seFswXT1udCx4WzFdPXV0LHhbMl09Y3QseFszXT1wdCx4WzRdPXh0LHhbNV09Z3QseFs2XT1kdCx4WzddPW10LHhbOF09YnQseFs5XT1DdCx4WzEwXT1TdCx4WzExXT1OdCx4WzEyXT1udCpLK3h0KlorYnQqaytQWzEyXSx4WzEzXT11dCpLK2d0KlorQ3QqaytQWzEzXSx4WzE0XT1jdCpLK2R0KlorU3QqaytQWzE0XSx4WzE1XT1wdCpLK210KlorTnQqaytQWzE1XSkseH1mdW5jdGlvbiB5KHgsUCxXKXt2YXIgSz1XWzBdLFo9V1sxXSxrPVdbMl07cmV0dXJuIHhbMF09UFswXSpLLHhbMV09UFsxXSpLLHhbMl09UFsyXSpLLHhbM109UFszXSpLLHhbNF09UFs0XSpaLHhbNV09UFs1XSpaLHhbNl09UFs2XSpaLHhbN109UFs3XSpaLHhbOF09UFs4XSprLHhbOV09UFs5XSprLHhbMTBdPVBbMTBdKmsseFsxMV09UFsxMV0qayx4WzEyXT1QWzEyXSx4WzEzXT1QWzEzXSx4WzE0XT1QWzE0XSx4WzE1XT1QWzE1XSx4fWZ1bmN0aW9uIFMoeCxQLFcsSyl7dmFyIFo9S1swXSxrPUtbMV0sbnQ9S1syXSx1dD1NYXRoLmh5cG90KFosayxudCksY3QscHQseHQsZ3QsZHQsbXQsYnQsQ3QsU3QsTnQsSnQsR3QsS3QsWXQsVnQsU2UsT2UsRWUsbWUsVGUsYmUsSWUsc2UsVmU7cmV0dXJuIHV0PG4uRVBTSUxPTj9udWxsOih1dD0xL3V0LFoqPXV0LGsqPXV0LG50Kj11dCxjdD1NYXRoLnNpbihXKSxwdD1NYXRoLmNvcyhXKSx4dD0xLXB0LGd0PVBbMF0sZHQ9UFsxXSxtdD1QWzJdLGJ0PVBbM10sQ3Q9UFs0XSxTdD1QWzVdLE50PVBbNl0sSnQ9UFs3XSxHdD1QWzhdLEt0PVBbOV0sWXQ9UFsxMF0sVnQ9UFsxMV0sU2U9WipaKnh0K3B0LE9lPWsqWip4dCtudCpjdCxFZT1udCpaKnh0LWsqY3QsbWU9WiprKnh0LW50KmN0LFRlPWsqayp4dCtwdCxiZT1udCprKnh0K1oqY3QsSWU9WipudCp4dCtrKmN0LHNlPWsqbnQqeHQtWipjdCxWZT1udCpudCp4dCtwdCx4WzBdPWd0KlNlK0N0Kk9lK0d0KkVlLHhbMV09ZHQqU2UrU3QqT2UrS3QqRWUseFsyXT1tdCpTZStOdCpPZStZdCpFZSx4WzNdPWJ0KlNlK0p0Kk9lK1Z0KkVlLHhbNF09Z3QqbWUrQ3QqVGUrR3QqYmUseFs1XT1kdCptZStTdCpUZStLdCpiZSx4WzZdPW10Km1lK050KlRlK1l0KmJlLHhbN109YnQqbWUrSnQqVGUrVnQqYmUseFs4XT1ndCpJZStDdCpzZStHdCpWZSx4WzldPWR0KkllK1N0KnNlK0t0KlZlLHhbMTBdPW10KkllK050KnNlK1l0KlZlLHhbMTFdPWJ0KkllK0p0KnNlK1Z0KlZlLFAhPT14JiYoeFsxMl09UFsxMl0seFsxM109UFsxM10seFsxNF09UFsxNF0seFsxNV09UFsxNV0pLHgpfWZ1bmN0aW9uIHMoeCxQLFcpe3ZhciBLPU1hdGguc2luKFcpLFo9TWF0aC5jb3MoVyksaz1QWzRdLG50PVBbNV0sdXQ9UFs2XSxjdD1QWzddLHB0PVBbOF0seHQ9UFs5XSxndD1QWzEwXSxkdD1QWzExXTtyZXR1cm4gUCE9PXgmJih4WzBdPVBbMF0seFsxXT1QWzFdLHhbMl09UFsyXSx4WzNdPVBbM10seFsxMl09UFsxMl0seFsxM109UFsxM10seFsxNF09UFsxNF0seFsxNV09UFsxNV0pLHhbNF09aypaK3B0KksseFs1XT1udCpaK3h0KksseFs2XT11dCpaK2d0KksseFs3XT1jdCpaK2R0KksseFs4XT1wdCpaLWsqSyx4WzldPXh0KlotbnQqSyx4WzEwXT1ndCpaLXV0KksseFsxMV09ZHQqWi1jdCpLLHh9ZnVuY3Rpb24gYyh4LFAsVyl7dmFyIEs9TWF0aC5zaW4oVyksWj1NYXRoLmNvcyhXKSxrPVBbMF0sbnQ9UFsxXSx1dD1QWzJdLGN0PVBbM10scHQ9UFs4XSx4dD1QWzldLGd0PVBbMTBdLGR0PVBbMTFdO3JldHVybiBQIT09eCYmKHhbNF09UFs0XSx4WzVdPVBbNV0seFs2XT1QWzZdLHhbN109UFs3XSx4WzEyXT1QWzEyXSx4WzEzXT1QWzEzXSx4WzE0XT1QWzE0XSx4WzE1XT1QWzE1XSkseFswXT1rKlotcHQqSyx4WzFdPW50KloteHQqSyx4WzJdPXV0KlotZ3QqSyx4WzNdPWN0KlotZHQqSyx4WzhdPWsqSytwdCpaLHhbOV09bnQqSyt4dCpaLHhbMTBdPXV0KksrZ3QqWix4WzExXT1jdCpLK2R0KloseH1mdW5jdGlvbiBsKHgsUCxXKXt2YXIgSz1NYXRoLnNpbihXKSxaPU1hdGguY29zKFcpLGs9UFswXSxudD1QWzFdLHV0PVBbMl0sY3Q9UFszXSxwdD1QWzRdLHh0PVBbNV0sZ3Q9UFs2XSxkdD1QWzddO3JldHVybiBQIT09eCYmKHhbOF09UFs4XSx4WzldPVBbOV0seFsxMF09UFsxMF0seFsxMV09UFsxMV0seFsxMl09UFsxMl0seFsxM109UFsxM10seFsxNF09UFsxNF0seFsxNV09UFsxNV0pLHhbMF09aypaK3B0KksseFsxXT1udCpaK3h0KksseFsyXT11dCpaK2d0KksseFszXT1jdCpaK2R0KksseFs0XT1wdCpaLWsqSyx4WzVdPXh0KlotbnQqSyx4WzZdPWd0KlotdXQqSyx4WzddPWR0KlotY3QqSyx4fWZ1bmN0aW9uIHYoeCxQKXtyZXR1cm4geFswXT0xLHhbMV09MCx4WzJdPTAseFszXT0wLHhbNF09MCx4WzVdPTEseFs2XT0wLHhbN109MCx4WzhdPTAseFs5XT0wLHhbMTBdPTEseFsxMV09MCx4WzEyXT1QWzBdLHhbMTNdPVBbMV0seFsxNF09UFsyXSx4WzE1XT0xLHh9ZnVuY3Rpb24gVCh4LFApe3JldHVybiB4WzBdPVBbMF0seFsxXT0wLHhbMl09MCx4WzNdPTAseFs0XT0wLHhbNV09UFsxXSx4WzZdPTAseFs3XT0wLHhbOF09MCx4WzldPTAseFsxMF09UFsyXSx4WzExXT0wLHhbMTJdPTAseFsxM109MCx4WzE0XT0wLHhbMTVdPTEseH1mdW5jdGlvbiBSKHgsUCxXKXt2YXIgSz1XWzBdLFo9V1sxXSxrPVdbMl0sbnQ9TWF0aC5oeXBvdChLLFosayksdXQsY3QscHQ7cmV0dXJuIG50PG4uRVBTSUxPTj9udWxsOihudD0xL250LEsqPW50LFoqPW50LGsqPW50LHV0PU1hdGguc2luKFApLGN0PU1hdGguY29zKFApLHB0PTEtY3QseFswXT1LKksqcHQrY3QseFsxXT1aKksqcHQrayp1dCx4WzJdPWsqSypwdC1aKnV0LHhbM109MCx4WzRdPUsqWipwdC1rKnV0LHhbNV09WipaKnB0K2N0LHhbNl09aypaKnB0K0sqdXQseFs3XT0wLHhbOF09SyprKnB0K1oqdXQseFs5XT1aKmsqcHQtSyp1dCx4WzEwXT1rKmsqcHQrY3QseFsxMV09MCx4WzEyXT0wLHhbMTNdPTAseFsxNF09MCx4WzE1XT0xLHgpfWZ1bmN0aW9uIEwoeCxQKXt2YXIgVz1NYXRoLnNpbihQKSxLPU1hdGguY29zKFApO3JldHVybiB4WzBdPTEseFsxXT0wLHhbMl09MCx4WzNdPTAseFs0XT0wLHhbNV09Syx4WzZdPVcseFs3XT0wLHhbOF09MCx4WzldPS1XLHhbMTBdPUsseFsxMV09MCx4WzEyXT0wLHhbMTNdPTAseFsxNF09MCx4WzE1XT0xLHh9ZnVuY3Rpb24gTih4LFApe3ZhciBXPU1hdGguc2luKFApLEs9TWF0aC5jb3MoUCk7cmV0dXJuIHhbMF09Syx4WzFdPTAseFsyXT0tVyx4WzNdPTAseFs0XT0wLHhbNV09MSx4WzZdPTAseFs3XT0wLHhbOF09Vyx4WzldPTAseFsxMF09Syx4WzExXT0wLHhbMTJdPTAseFsxM109MCx4WzE0XT0wLHhbMTVdPTEseH1mdW5jdGlvbiBBKHgsUCl7dmFyIFc9TWF0aC5zaW4oUCksSz1NYXRoLmNvcyhQKTtyZXR1cm4geFswXT1LLHhbMV09Vyx4WzJdPTAseFszXT0wLHhbNF09LVcseFs1XT1LLHhbNl09MCx4WzddPTAseFs4XT0wLHhbOV09MCx4WzEwXT0xLHhbMTFdPTAseFsxMl09MCx4WzEzXT0wLHhbMTRdPTAseFsxNV09MSx4fWZ1bmN0aW9uIHcoeCxQLFcpe3ZhciBLPVBbMF0sWj1QWzFdLGs9UFsyXSxudD1QWzNdLHV0PUsrSyxjdD1aK1oscHQ9aytrLHh0PUsqdXQsZ3Q9SypjdCxkdD1LKnB0LG10PVoqY3QsYnQ9WipwdCxDdD1rKnB0LFN0PW50KnV0LE50PW50KmN0LEp0PW50KnB0O3JldHVybiB4WzBdPTEtKG10K0N0KSx4WzFdPWd0K0p0LHhbMl09ZHQtTnQseFszXT0wLHhbNF09Z3QtSnQseFs1XT0xLSh4dCtDdCkseFs2XT1idCtTdCx4WzddPTAseFs4XT1kdCtOdCx4WzldPWJ0LVN0LHhbMTBdPTEtKHh0K210KSx4WzExXT0wLHhbMTJdPVdbMF0seFsxM109V1sxXSx4WzE0XT1XWzJdLHhbMTVdPTEseH1mdW5jdGlvbiBCKHgsUCl7dmFyIFc9bmV3IG4uQVJSQVlfVFlQRSgzKSxLPS1QWzBdLFo9LVBbMV0saz0tUFsyXSxudD1QWzNdLHV0PVBbNF0sY3Q9UFs1XSxwdD1QWzZdLHh0PVBbN10sZ3Q9SypLK1oqWitrKmsrbnQqbnQ7cmV0dXJuIGd0PjA/KFdbMF09KHV0Km50K3h0KksrY3Qqay1wdCpaKSoyL2d0LFdbMV09KGN0Km50K3h0KlorcHQqSy11dCprKSoyL2d0LFdbMl09KHB0Km50K3h0KmsrdXQqWi1jdCpLKSoyL2d0KTooV1swXT0odXQqbnQreHQqSytjdCprLXB0KlopKjIsV1sxXT0oY3QqbnQreHQqWitwdCpLLXV0KmspKjIsV1syXT0ocHQqbnQreHQqayt1dCpaLWN0KkspKjIpLHcoeCxQLFcpLHh9ZnVuY3Rpb24gRCh4LFApe3JldHVybiB4WzBdPVBbMTJdLHhbMV09UFsxM10seFsyXT1QWzE0XSx4fWZ1bmN0aW9uIEkoeCxQKXt2YXIgVz1QWzBdLEs9UFsxXSxaPVBbMl0saz1QWzRdLG50PVBbNV0sdXQ9UFs2XSxjdD1QWzhdLHB0PVBbOV0seHQ9UFsxMF07cmV0dXJuIHhbMF09TWF0aC5oeXBvdChXLEssWikseFsxXT1NYXRoLmh5cG90KGssbnQsdXQpLHhbMl09TWF0aC5oeXBvdChjdCxwdCx4dCkseH1mdW5jdGlvbiBqKHgsUCl7dmFyIFc9bmV3IG4uQVJSQVlfVFlQRSgzKTtJKFcsUCk7dmFyIEs9MS9XWzBdLFo9MS9XWzFdLGs9MS9XWzJdLG50PVBbMF0qSyx1dD1QWzFdKlosY3Q9UFsyXSprLHB0PVBbNF0qSyx4dD1QWzVdKlosZ3Q9UFs2XSprLGR0PVBbOF0qSyxtdD1QWzldKlosYnQ9UFsxMF0qayxDdD1udCt4dCtidCxTdD0wO3JldHVybiBDdD4wPyhTdD1NYXRoLnNxcnQoQ3QrMSkqMix4WzNdPS4yNSpTdCx4WzBdPShndC1tdCkvU3QseFsxXT0oZHQtY3QpL1N0LHhbMl09KHV0LXB0KS9TdCk6bnQ+eHQmJm50PmJ0PyhTdD1NYXRoLnNxcnQoMStudC14dC1idCkqMix4WzNdPShndC1tdCkvU3QseFswXT0uMjUqU3QseFsxXT0odXQrcHQpL1N0LHhbMl09KGR0K2N0KS9TdCk6eHQ+YnQ/KFN0PU1hdGguc3FydCgxK3h0LW50LWJ0KSoyLHhbM109KGR0LWN0KS9TdCx4WzBdPSh1dCtwdCkvU3QseFsxXT0uMjUqU3QseFsyXT0oZ3QrbXQpL1N0KTooU3Q9TWF0aC5zcXJ0KDErYnQtbnQteHQpKjIseFszXT0odXQtcHQpL1N0LHhbMF09KGR0K2N0KS9TdCx4WzFdPShndCttdCkvU3QseFsyXT0uMjUqU3QpLHh9ZnVuY3Rpb24gVih4LFAsVyxLKXt2YXIgWj1QWzBdLGs9UFsxXSxudD1QWzJdLHV0PVBbM10sY3Q9WitaLHB0PWsrayx4dD1udCtudCxndD1aKmN0LGR0PVoqcHQsbXQ9Wip4dCxidD1rKnB0LEN0PWsqeHQsU3Q9bnQqeHQsTnQ9dXQqY3QsSnQ9dXQqcHQsR3Q9dXQqeHQsS3Q9S1swXSxZdD1LWzFdLFZ0PUtbMl07cmV0dXJuIHhbMF09KDEtKGJ0K1N0KSkqS3QseFsxXT0oZHQrR3QpKkt0LHhbMl09KG10LUp0KSpLdCx4WzNdPTAseFs0XT0oZHQtR3QpKll0LHhbNV09KDEtKGd0K1N0KSkqWXQseFs2XT0oQ3QrTnQpKll0LHhbN109MCx4WzhdPShtdCtKdCkqVnQseFs5XT0oQ3QtTnQpKlZ0LHhbMTBdPSgxLShndCtidCkpKlZ0LHhbMTFdPTAseFsxMl09V1swXSx4WzEzXT1XWzFdLHhbMTRdPVdbMl0seFsxNV09MSx4fWZ1bmN0aW9uIEooeCxQLFcsSyxaKXt2YXIgaz1QWzBdLG50PVBbMV0sdXQ9UFsyXSxjdD1QWzNdLHB0PWsrayx4dD1udCtudCxndD11dCt1dCxkdD1rKnB0LG10PWsqeHQsYnQ9aypndCxDdD1udCp4dCxTdD1udCpndCxOdD11dCpndCxKdD1jdCpwdCxHdD1jdCp4dCxLdD1jdCpndCxZdD1LWzBdLFZ0PUtbMV0sU2U9S1syXSxPZT1aWzBdLEVlPVpbMV0sbWU9WlsyXSxUZT0oMS0oQ3QrTnQpKSpZdCxiZT0obXQrS3QpKll0LEllPShidC1HdCkqWXQsc2U9KG10LUt0KSpWdCxWZT0oMS0oZHQrTnQpKSpWdCxMcj0oU3QrSnQpKlZ0LFlyPShidCtHdCkqU2UsYWk9KFN0LUp0KSpTZSxsaT0oMS0oZHQrQ3QpKSpTZTtyZXR1cm4geFswXT1UZSx4WzFdPWJlLHhbMl09SWUseFszXT0wLHhbNF09c2UseFs1XT1WZSx4WzZdPUxyLHhbN109MCx4WzhdPVlyLHhbOV09YWkseFsxMF09bGkseFsxMV09MCx4WzEyXT1XWzBdK09lLShUZSpPZStzZSpFZStZciptZSkseFsxM109V1sxXStFZS0oYmUqT2UrVmUqRWUrYWkqbWUpLHhbMTRdPVdbMl0rbWUtKEllKk9lK0xyKkVlK2xpKm1lKSx4WzE1XT0xLHh9ZnVuY3Rpb24gXyh4LFApe3ZhciBXPVBbMF0sSz1QWzFdLFo9UFsyXSxrPVBbM10sbnQ9VytXLHV0PUsrSyxjdD1aK1oscHQ9VypudCx4dD1LKm50LGd0PUsqdXQsZHQ9WipudCxtdD1aKnV0LGJ0PVoqY3QsQ3Q9aypudCxTdD1rKnV0LE50PWsqY3Q7cmV0dXJuIHhbMF09MS1ndC1idCx4WzFdPXh0K050LHhbMl09ZHQtU3QseFszXT0wLHhbNF09eHQtTnQseFs1XT0xLXB0LWJ0LHhbNl09bXQrQ3QseFs3XT0wLHhbOF09ZHQrU3QseFs5XT1tdC1DdCx4WzEwXT0xLXB0LWd0LHhbMTFdPTAseFsxMl09MCx4WzEzXT0wLHhbMTRdPTAseFsxNV09MSx4fWZ1bmN0aW9uIHN0KHgsUCxXLEssWixrLG50KXt2YXIgdXQ9MS8oVy1QKSxjdD0xLyhaLUspLHB0PTEvKGstbnQpO3JldHVybiB4WzBdPWsqMip1dCx4WzFdPTAseFsyXT0wLHhbM109MCx4WzRdPTAseFs1XT1rKjIqY3QseFs2XT0wLHhbN109MCx4WzhdPShXK1ApKnV0LHhbOV09KForSykqY3QseFsxMF09KG50K2spKnB0LHhbMTFdPS0xLHhbMTJdPTAseFsxM109MCx4WzE0XT1udCprKjIqcHQseFsxNV09MCx4fWZ1bmN0aW9uIEcoeCxQLFcsSyxaKXt2YXIgaz0xL01hdGgudGFuKFAvMiksbnQ7cmV0dXJuIHhbMF09ay9XLHhbMV09MCx4WzJdPTAseFszXT0wLHhbNF09MCx4WzVdPWsseFs2XT0wLHhbN109MCx4WzhdPTAseFs5XT0wLHhbMTFdPS0xLHhbMTJdPTAseFsxM109MCx4WzE1XT0wLFohPW51bGwmJlohPT0xLzA/KG50PTEvKEstWikseFsxMF09KForSykqbnQseFsxNF09MipaKksqbnQpOih4WzEwXT0tMSx4WzE0XT0tMipLKSx4fWZ1bmN0aW9uIFkoeCxQLFcsSyl7dmFyIFo9TWF0aC50YW4oUC51cERlZ3JlZXMqTWF0aC5QSS8xODApLGs9TWF0aC50YW4oUC5kb3duRGVncmVlcypNYXRoLlBJLzE4MCksbnQ9TWF0aC50YW4oUC5sZWZ0RGVncmVlcypNYXRoLlBJLzE4MCksdXQ9TWF0aC50YW4oUC5yaWdodERlZ3JlZXMqTWF0aC5QSS8xODApLGN0PTIvKG50K3V0KSxwdD0yLyhaK2spO3JldHVybiB4WzBdPWN0LHhbMV09MCx4WzJdPTAseFszXT0wLHhbNF09MCx4WzVdPXB0LHhbNl09MCx4WzddPTAseFs4XT0tKChudC11dCkqY3QqLjUpLHhbOV09KFotaykqcHQqLjUseFsxMF09Sy8oVy1LKSx4WzExXT0tMSx4WzEyXT0wLHhbMTNdPTAseFsxNF09SypXLyhXLUspLHhbMTVdPTAseH1mdW5jdGlvbiBydCh4LFAsVyxLLFosayxudCl7dmFyIHV0PTEvKFAtVyksY3Q9MS8oSy1aKSxwdD0xLyhrLW50KTtyZXR1cm4geFswXT0tMip1dCx4WzFdPTAseFsyXT0wLHhbM109MCx4WzRdPTAseFs1XT0tMipjdCx4WzZdPTAseFs3XT0wLHhbOF09MCx4WzldPTAseFsxMF09MipwdCx4WzExXT0wLHhbMTJdPShQK1cpKnV0LHhbMTNdPShaK0spKmN0LHhbMTRdPShudCtrKSpwdCx4WzE1XT0xLHh9ZnVuY3Rpb24gb3QoeCxQLFcsSyl7dmFyIFosayxudCx1dCxjdCxwdCx4dCxndCxkdCxtdCxidD1QWzBdLEN0PVBbMV0sU3Q9UFsyXSxOdD1LWzBdLEp0PUtbMV0sR3Q9S1syXSxLdD1XWzBdLFl0PVdbMV0sVnQ9V1syXTtyZXR1cm4gTWF0aC5hYnMoYnQtS3QpPG4uRVBTSUxPTiYmTWF0aC5hYnMoQ3QtWXQpPG4uRVBTSUxPTiYmTWF0aC5hYnMoU3QtVnQpPG4uRVBTSUxPTj9kKHgpOih4dD1idC1LdCxndD1DdC1ZdCxkdD1TdC1WdCxtdD0xL01hdGguaHlwb3QoeHQsZ3QsZHQpLHh0Kj1tdCxndCo9bXQsZHQqPW10LFo9SnQqZHQtR3QqZ3Qsaz1HdCp4dC1OdCpkdCxudD1OdCpndC1KdCp4dCxtdD1NYXRoLmh5cG90KFosayxudCksbXQ/KG10PTEvbXQsWio9bXQsayo9bXQsbnQqPW10KTooWj0wLGs9MCxudD0wKSx1dD1ndCpudC1kdCprLGN0PWR0KloteHQqbnQscHQ9eHQqay1ndCpaLG10PU1hdGguaHlwb3QodXQsY3QscHQpLG10PyhtdD0xL210LHV0Kj1tdCxjdCo9bXQscHQqPW10KToodXQ9MCxjdD0wLHB0PTApLHhbMF09Wix4WzFdPXV0LHhbMl09eHQseFszXT0wLHhbNF09ayx4WzVdPWN0LHhbNl09Z3QseFs3XT0wLHhbOF09bnQseFs5XT1wdCx4WzEwXT1kdCx4WzExXT0wLHhbMTJdPS0oWipidCtrKkN0K250KlN0KSx4WzEzXT0tKHV0KmJ0K2N0KkN0K3B0KlN0KSx4WzE0XT0tKHh0KmJ0K2d0KkN0K2R0KlN0KSx4WzE1XT0xLHgpfWZ1bmN0aW9uIGF0KHgsUCxXLEspe3ZhciBaPVBbMF0saz1QWzFdLG50PVBbMl0sdXQ9S1swXSxjdD1LWzFdLHB0PUtbMl0seHQ9Wi1XWzBdLGd0PWstV1sxXSxkdD1udC1XWzJdLG10PXh0Knh0K2d0Kmd0K2R0KmR0O210PjAmJihtdD0xL01hdGguc3FydChtdCkseHQqPW10LGd0Kj1tdCxkdCo9bXQpO3ZhciBidD1jdCpkdC1wdCpndCxDdD1wdCp4dC11dCpkdCxTdD11dCpndC1jdCp4dDtyZXR1cm4gbXQ9YnQqYnQrQ3QqQ3QrU3QqU3QsbXQ+MCYmKG10PTEvTWF0aC5zcXJ0KG10KSxidCo9bXQsQ3QqPW10LFN0Kj1tdCkseFswXT1idCx4WzFdPUN0LHhbMl09U3QseFszXT0wLHhbNF09Z3QqU3QtZHQqQ3QseFs1XT1kdCpidC14dCpTdCx4WzZdPXh0KkN0LWd0KmJ0LHhbN109MCx4WzhdPXh0LHhbOV09Z3QseFsxMF09ZHQseFsxMV09MCx4WzEyXT1aLHhbMTNdPWsseFsxNF09bnQseFsxNV09MSx4fWZ1bmN0aW9uIGh0KHgpe3JldHVybiJtYXQ0KCIreFswXSsiLCAiK3hbMV0rIiwgIit4WzJdKyIsICIreFszXSsiLCAiK3hbNF0rIiwgIit4WzVdKyIsICIreFs2XSsiLCAiK3hbN10rIiwgIit4WzhdKyIsICIreFs5XSsiLCAiK3hbMTBdKyIsICIreFsxMV0rIiwgIit4WzEyXSsiLCAiK3hbMTNdKyIsICIreFsxNF0rIiwgIit4WzE1XSsiKSJ9ZnVuY3Rpb24gaXQoeCl7cmV0dXJuIE1hdGguaHlwb3QoeFswXSx4WzFdLHhbMl0seFszXSx4WzRdLHhbNV0seFs2XSx4WzddLHhbOF0seFs5XSx4WzEwXSx4WzExXSx4WzEyXSx4WzEzXSx4WzE0XSx4WzE1XSl9ZnVuY3Rpb24gTXQoeCxQLFcpe3JldHVybiB4WzBdPVBbMF0rV1swXSx4WzFdPVBbMV0rV1sxXSx4WzJdPVBbMl0rV1syXSx4WzNdPVBbM10rV1szXSx4WzRdPVBbNF0rV1s0XSx4WzVdPVBbNV0rV1s1XSx4WzZdPVBbNl0rV1s2XSx4WzddPVBbN10rV1s3XSx4WzhdPVBbOF0rV1s4XSx4WzldPVBbOV0rV1s5XSx4WzEwXT1QWzEwXStXWzEwXSx4WzExXT1QWzExXStXWzExXSx4WzEyXT1QWzEyXStXWzEyXSx4WzEzXT1QWzEzXStXWzEzXSx4WzE0XT1QWzE0XStXWzE0XSx4WzE1XT1QWzE1XStXWzE1XSx4fWZ1bmN0aW9uIE90KHgsUCxXKXtyZXR1cm4geFswXT1QWzBdLVdbMF0seFsxXT1QWzFdLVdbMV0seFsyXT1QWzJdLVdbMl0seFszXT1QWzNdLVdbM10seFs0XT1QWzRdLVdbNF0seFs1XT1QWzVdLVdbNV0seFs2XT1QWzZdLVdbNl0seFs3XT1QWzddLVdbN10seFs4XT1QWzhdLVdbOF0seFs5XT1QWzldLVdbOV0seFsxMF09UFsxMF0tV1sxMF0seFsxMV09UFsxMV0tV1sxMV0seFsxMl09UFsxMl0tV1sxMl0seFsxM109UFsxM10tV1sxM10seFsxNF09UFsxNF0tV1sxNF0seFsxNV09UFsxNV0tV1sxNV0seH1mdW5jdGlvbiBVKHgsUCxXKXtyZXR1cm4geFswXT1QWzBdKlcseFsxXT1QWzFdKlcseFsyXT1QWzJdKlcseFszXT1QWzNdKlcseFs0XT1QWzRdKlcseFs1XT1QWzVdKlcseFs2XT1QWzZdKlcseFs3XT1QWzddKlcseFs4XT1QWzhdKlcseFs5XT1QWzldKlcseFsxMF09UFsxMF0qVyx4WzExXT1QWzExXSpXLHhbMTJdPVBbMTJdKlcseFsxM109UFsxM10qVyx4WzE0XT1QWzE0XSpXLHhbMTVdPVBbMTVdKlcseH1mdW5jdGlvbiAkKHgsUCxXLEspe3JldHVybiB4WzBdPVBbMF0rV1swXSpLLHhbMV09UFsxXStXWzFdKksseFsyXT1QWzJdK1dbMl0qSyx4WzNdPVBbM10rV1szXSpLLHhbNF09UFs0XStXWzRdKksseFs1XT1QWzVdK1dbNV0qSyx4WzZdPVBbNl0rV1s2XSpLLHhbN109UFs3XStXWzddKksseFs4XT1QWzhdK1dbOF0qSyx4WzldPVBbOV0rV1s5XSpLLHhbMTBdPVBbMTBdK1dbMTBdKksseFsxMV09UFsxMV0rV1sxMV0qSyx4WzEyXT1QWzEyXStXWzEyXSpLLHhbMTNdPVBbMTNdK1dbMTNdKksseFsxNF09UFsxNF0rV1sxNF0qSyx4WzE1XT1QWzE1XStXWzE1XSpLLHh9ZnVuY3Rpb24gUSh4LFApe3JldHVybiB4WzBdPT09UFswXSYmeFsxXT09PVBbMV0mJnhbMl09PT1QWzJdJiZ4WzNdPT09UFszXSYmeFs0XT09PVBbNF0mJnhbNV09PT1QWzVdJiZ4WzZdPT09UFs2XSYmeFs3XT09PVBbN10mJnhbOF09PT1QWzhdJiZ4WzldPT09UFs5XSYmeFsxMF09PT1QWzEwXSYmeFsxMV09PT1QWzExXSYmeFsxMl09PT1QWzEyXSYmeFsxM109PT1QWzEzXSYmeFsxNF09PT1QWzE0XSYmeFsxNV09PT1QWzE1XX1mdW5jdGlvbiB0dCh4LFApe3ZhciBXPXhbMF0sSz14WzFdLFo9eFsyXSxrPXhbM10sbnQ9eFs0XSx1dD14WzVdLGN0PXhbNl0scHQ9eFs3XSx4dD14WzhdLGd0PXhbOV0sZHQ9eFsxMF0sbXQ9eFsxMV0sYnQ9eFsxMl0sQ3Q9eFsxM10sU3Q9eFsxNF0sTnQ9eFsxNV0sSnQ9UFswXSxHdD1QWzFdLEt0PVBbMl0sWXQ9UFszXSxWdD1QWzRdLFNlPVBbNV0sT2U9UFs2XSxFZT1QWzddLG1lPVBbOF0sVGU9UFs5XSxiZT1QWzEwXSxJZT1QWzExXSxzZT1QWzEyXSxWZT1QWzEzXSxMcj1QWzE0XSxZcj1QWzE1XTtyZXR1cm4gTWF0aC5hYnMoVy1KdCk8PW4uRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKFcpLE1hdGguYWJzKEp0KSkmJk1hdGguYWJzKEstR3QpPD1uLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhLKSxNYXRoLmFicyhHdCkpJiZNYXRoLmFicyhaLUt0KTw9bi5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoWiksTWF0aC5hYnMoS3QpKSYmTWF0aC5hYnMoay1ZdCk8PW4uRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKGspLE1hdGguYWJzKFl0KSkmJk1hdGguYWJzKG50LVZ0KTw9bi5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMobnQpLE1hdGguYWJzKFZ0KSkmJk1hdGguYWJzKHV0LVNlKTw9bi5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnModXQpLE1hdGguYWJzKFNlKSkmJk1hdGguYWJzKGN0LU9lKTw9bi5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoY3QpLE1hdGguYWJzKE9lKSkmJk1hdGguYWJzKHB0LUVlKTw9bi5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMocHQpLE1hdGguYWJzKEVlKSkmJk1hdGguYWJzKHh0LW1lKTw9bi5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoeHQpLE1hdGguYWJzKG1lKSkmJk1hdGguYWJzKGd0LVRlKTw9bi5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoZ3QpLE1hdGguYWJzKFRlKSkmJk1hdGguYWJzKGR0LWJlKTw9bi5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoZHQpLE1hdGguYWJzKGJlKSkmJk1hdGguYWJzKG10LUllKTw9bi5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMobXQpLE1hdGguYWJzKEllKSkmJk1hdGguYWJzKGJ0LXNlKTw9bi5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoYnQpLE1hdGguYWJzKHNlKSkmJk1hdGguYWJzKEN0LVZlKTw9bi5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoQ3QpLE1hdGguYWJzKFZlKSkmJk1hdGguYWJzKFN0LUxyKTw9bi5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoU3QpLE1hdGguYWJzKExyKSkmJk1hdGguYWJzKE50LVlyKTw9bi5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoTnQpLE1hdGguYWJzKFlyKSl9dmFyIEY9YixIPU90fSxmdW5jdGlvbihnLGUsdCl7dC5yKGUpLHQuZChlLCJjcmVhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIHV9KSx0LmQoZSwiaWRlbnRpdHkiLGZ1bmN0aW9uKCl7cmV0dXJuIGF9KSx0LmQoZSwic2V0QXhpc0FuZ2xlIixmdW5jdGlvbigpe3JldHVybiBkfSksdC5kKGUsImdldEF4aXNBbmdsZSIsZnVuY3Rpb24oKXtyZXR1cm4gRX0pLHQuZChlLCJnZXRBbmdsZSIsZnVuY3Rpb24oKXtyZXR1cm4gcH0pLHQuZChlLCJtdWx0aXBseSIsZnVuY3Rpb24oKXtyZXR1cm4gT30pLHQuZChlLCJyb3RhdGVYIixmdW5jdGlvbigpe3JldHVybiBtfSksdC5kKGUsInJvdGF0ZVkiLGZ1bmN0aW9uKCl7cmV0dXJuIGJ9KSx0LmQoZSwicm90YXRlWiIsZnVuY3Rpb24oKXtyZXR1cm4gTX0pLHQuZChlLCJjYWxjdWxhdGVXIixmdW5jdGlvbigpe3JldHVybiB5fSksdC5kKGUsImV4cCIsZnVuY3Rpb24oKXtyZXR1cm4gU30pLHQuZChlLCJsbiIsZnVuY3Rpb24oKXtyZXR1cm4gc30pLHQuZChlLCJwb3ciLGZ1bmN0aW9uKCl7cmV0dXJuIGN9KSx0LmQoZSwic2xlcnAiLGZ1bmN0aW9uKCl7cmV0dXJuIGx9KSx0LmQoZSwicmFuZG9tIixmdW5jdGlvbigpe3JldHVybiB2fSksdC5kKGUsImludmVydCIsZnVuY3Rpb24oKXtyZXR1cm4gVH0pLHQuZChlLCJjb25qdWdhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIFJ9KSx0LmQoZSwiZnJvbU1hdDMiLGZ1bmN0aW9uKCl7cmV0dXJuIEx9KSx0LmQoZSwiZnJvbUV1bGVyIixmdW5jdGlvbigpe3JldHVybiBOfSksdC5kKGUsInN0ciIsZnVuY3Rpb24oKXtyZXR1cm4gQX0pLHQuZChlLCJjbG9uZSIsZnVuY3Rpb24oKXtyZXR1cm4gd30pLHQuZChlLCJmcm9tVmFsdWVzIixmdW5jdGlvbigpe3JldHVybiBCfSksdC5kKGUsImNvcHkiLGZ1bmN0aW9uKCl7cmV0dXJuIER9KSx0LmQoZSwic2V0IixmdW5jdGlvbigpe3JldHVybiBJfSksdC5kKGUsImFkZCIsZnVuY3Rpb24oKXtyZXR1cm4gan0pLHQuZChlLCJtdWwiLGZ1bmN0aW9uKCl7cmV0dXJuIFZ9KSx0LmQoZSwic2NhbGUiLGZ1bmN0aW9uKCl7cmV0dXJuIEp9KSx0LmQoZSwiZG90IixmdW5jdGlvbigpe3JldHVybiBffSksdC5kKGUsImxlcnAiLGZ1bmN0aW9uKCl7cmV0dXJuIHN0fSksdC5kKGUsImxlbmd0aCIsZnVuY3Rpb24oKXtyZXR1cm4gR30pLHQuZChlLCJsZW4iLGZ1bmN0aW9uKCl7cmV0dXJuIFl9KSx0LmQoZSwic3F1YXJlZExlbmd0aCIsZnVuY3Rpb24oKXtyZXR1cm4gcnR9KSx0LmQoZSwic3FyTGVuIixmdW5jdGlvbigpe3JldHVybiBvdH0pLHQuZChlLCJub3JtYWxpemUiLGZ1bmN0aW9uKCl7cmV0dXJuIGF0fSksdC5kKGUsImV4YWN0RXF1YWxzIixmdW5jdGlvbigpe3JldHVybiBodH0pLHQuZChlLCJlcXVhbHMiLGZ1bmN0aW9uKCl7cmV0dXJuIGl0fSksdC5kKGUsInJvdGF0aW9uVG8iLGZ1bmN0aW9uKCl7cmV0dXJuIE10fSksdC5kKGUsInNxbGVycCIsZnVuY3Rpb24oKXtyZXR1cm4gT3R9KSx0LmQoZSwic2V0QXhlcyIsZnVuY3Rpb24oKXtyZXR1cm4gVX0pO3ZhciBuPXQoMiksaT10KDUpLGY9dCg4KSxoPXQoOSk7ZnVuY3Rpb24gdSgpe3ZhciAkPW5ldyBuLkFSUkFZX1RZUEUoNCk7cmV0dXJuIG4uQVJSQVlfVFlQRSE9RmxvYXQzMkFycmF5JiYoJFswXT0wLCRbMV09MCwkWzJdPTApLCRbM109MSwkfWZ1bmN0aW9uIGEoJCl7cmV0dXJuICRbMF09MCwkWzFdPTAsJFsyXT0wLCRbM109MSwkfWZ1bmN0aW9uIGQoJCxRLHR0KXt0dD10dCouNTt2YXIgRj1NYXRoLnNpbih0dCk7cmV0dXJuICRbMF09RipRWzBdLCRbMV09RipRWzFdLCRbMl09RipRWzJdLCRbM109TWF0aC5jb3ModHQpLCR9ZnVuY3Rpb24gRSgkLFEpe3ZhciB0dD1NYXRoLmFjb3MoUVszXSkqMixGPU1hdGguc2luKHR0LzIpO3JldHVybiBGPm4uRVBTSUxPTj8oJFswXT1RWzBdL0YsJFsxXT1RWzFdL0YsJFsyXT1RWzJdL0YpOigkWzBdPTEsJFsxXT0wLCRbMl09MCksdHR9ZnVuY3Rpb24gcCgkLFEpe3ZhciB0dD1fKCQsUSk7cmV0dXJuIE1hdGguYWNvcygyKnR0KnR0LTEpfWZ1bmN0aW9uIE8oJCxRLHR0KXt2YXIgRj1RWzBdLEg9UVsxXSx4PVFbMl0sUD1RWzNdLFc9dHRbMF0sSz10dFsxXSxaPXR0WzJdLGs9dHRbM107cmV0dXJuICRbMF09RiprK1AqVytIKloteCpLLCRbMV09SCprK1AqSyt4KlctRipaLCRbMl09eCprK1AqWitGKkstSCpXLCRbM109UCprLUYqVy1IKksteCpaLCR9ZnVuY3Rpb24gbSgkLFEsdHQpe3R0Kj0uNTt2YXIgRj1RWzBdLEg9UVsxXSx4PVFbMl0sUD1RWzNdLFc9TWF0aC5zaW4odHQpLEs9TWF0aC5jb3ModHQpO3JldHVybiAkWzBdPUYqSytQKlcsJFsxXT1IKksreCpXLCRbMl09eCpLLUgqVywkWzNdPVAqSy1GKlcsJH1mdW5jdGlvbiBiKCQsUSx0dCl7dHQqPS41O3ZhciBGPVFbMF0sSD1RWzFdLHg9UVsyXSxQPVFbM10sVz1NYXRoLnNpbih0dCksSz1NYXRoLmNvcyh0dCk7cmV0dXJuICRbMF09RipLLXgqVywkWzFdPUgqSytQKlcsJFsyXT14KksrRipXLCRbM109UCpLLUgqVywkfWZ1bmN0aW9uIE0oJCxRLHR0KXt0dCo9LjU7dmFyIEY9UVswXSxIPVFbMV0seD1RWzJdLFA9UVszXSxXPU1hdGguc2luKHR0KSxLPU1hdGguY29zKHR0KTtyZXR1cm4gJFswXT1GKksrSCpXLCRbMV09SCpLLUYqVywkWzJdPXgqSytQKlcsJFszXT1QKksteCpXLCR9ZnVuY3Rpb24geSgkLFEpe3ZhciB0dD1RWzBdLEY9UVsxXSxIPVFbMl07cmV0dXJuICRbMF09dHQsJFsxXT1GLCRbMl09SCwkWzNdPU1hdGguc3FydChNYXRoLmFicygxLXR0KnR0LUYqRi1IKkgpKSwkfWZ1bmN0aW9uIFMoJCxRKXt2YXIgdHQ9UVswXSxGPVFbMV0sSD1RWzJdLHg9UVszXSxQPU1hdGguc3FydCh0dCp0dCtGKkYrSCpIKSxXPU1hdGguZXhwKHgpLEs9UD4wP1cqTWF0aC5zaW4oUCkvUDowO3JldHVybiAkWzBdPXR0KkssJFsxXT1GKkssJFsyXT1IKkssJFszXT1XKk1hdGguY29zKFApLCR9ZnVuY3Rpb24gcygkLFEpe3ZhciB0dD1RWzBdLEY9UVsxXSxIPVFbMl0seD1RWzNdLFA9TWF0aC5zcXJ0KHR0KnR0K0YqRitIKkgpLFc9UD4wP01hdGguYXRhbjIoUCx4KS9QOjA7cmV0dXJuICRbMF09dHQqVywkWzFdPUYqVywkWzJdPUgqVywkWzNdPS41Kk1hdGgubG9nKHR0KnR0K0YqRitIKkgreCp4KSwkfWZ1bmN0aW9uIGMoJCxRLHR0KXtyZXR1cm4gcygkLFEpLEooJCwkLHR0KSxTKCQsJCksJH1mdW5jdGlvbiBsKCQsUSx0dCxGKXt2YXIgSD1RWzBdLHg9UVsxXSxQPVFbMl0sVz1RWzNdLEs9dHRbMF0sWj10dFsxXSxrPXR0WzJdLG50PXR0WzNdLHV0LGN0LHB0LHh0LGd0O3JldHVybiBjdD1IKksreCpaK1AqaytXKm50LGN0PDAmJihjdD0tY3QsSz0tSyxaPS1aLGs9LWssbnQ9LW50KSwxLWN0Pm4uRVBTSUxPTj8odXQ9TWF0aC5hY29zKGN0KSxwdD1NYXRoLnNpbih1dCkseHQ9TWF0aC5zaW4oKDEtRikqdXQpL3B0LGd0PU1hdGguc2luKEYqdXQpL3B0KTooeHQ9MS1GLGd0PUYpLCRbMF09eHQqSCtndCpLLCRbMV09eHQqeCtndCpaLCRbMl09eHQqUCtndCprLCRbM109eHQqVytndCpudCwkfWZ1bmN0aW9uIHYoJCl7dmFyIFE9bi5SQU5ET00oKSx0dD1uLlJBTkRPTSgpLEY9bi5SQU5ET00oKSxIPU1hdGguc3FydCgxLVEpLHg9TWF0aC5zcXJ0KFEpO3JldHVybiAkWzBdPUgqTWF0aC5zaW4oMipNYXRoLlBJKnR0KSwkWzFdPUgqTWF0aC5jb3MoMipNYXRoLlBJKnR0KSwkWzJdPXgqTWF0aC5zaW4oMipNYXRoLlBJKkYpLCRbM109eCpNYXRoLmNvcygyKk1hdGguUEkqRiksJH1mdW5jdGlvbiBUKCQsUSl7dmFyIHR0PVFbMF0sRj1RWzFdLEg9UVsyXSx4PVFbM10sUD10dCp0dCtGKkYrSCpIK3gqeCxXPVA/MS9QOjA7cmV0dXJuICRbMF09LXR0KlcsJFsxXT0tRipXLCRbMl09LUgqVywkWzNdPXgqVywkfWZ1bmN0aW9uIFIoJCxRKXtyZXR1cm4gJFswXT0tUVswXSwkWzFdPS1RWzFdLCRbMl09LVFbMl0sJFszXT1RWzNdLCR9ZnVuY3Rpb24gTCgkLFEpe3ZhciB0dD1RWzBdK1FbNF0rUVs4XSxGO2lmKHR0PjApRj1NYXRoLnNxcnQodHQrMSksJFszXT0uNSpGLEY9LjUvRiwkWzBdPShRWzVdLVFbN10pKkYsJFsxXT0oUVs2XS1RWzJdKSpGLCRbMl09KFFbMV0tUVszXSkqRjtlbHNle3ZhciBIPTA7UVs0XT5RWzBdJiYoSD0xKSxRWzhdPlFbSCozK0hdJiYoSD0yKTt2YXIgeD0oSCsxKSUzLFA9KEgrMiklMztGPU1hdGguc3FydChRW0gqMytIXS1RW3gqMyt4XS1RW1AqMytQXSsxKSwkW0hdPS41KkYsRj0uNS9GLCRbM109KFFbeCozK1BdLVFbUCozK3hdKSpGLCRbeF09KFFbeCozK0hdK1FbSCozK3hdKSpGLCRbUF09KFFbUCozK0hdK1FbSCozK1BdKSpGfXJldHVybiAkfWZ1bmN0aW9uIE4oJCxRLHR0LEYpe3ZhciBIPS41Kk1hdGguUEkvMTgwO1EqPUgsdHQqPUgsRio9SDt2YXIgeD1NYXRoLnNpbihRKSxQPU1hdGguY29zKFEpLFc9TWF0aC5zaW4odHQpLEs9TWF0aC5jb3ModHQpLFo9TWF0aC5zaW4oRiksaz1NYXRoLmNvcyhGKTtyZXR1cm4gJFswXT14Kksqay1QKlcqWiwkWzFdPVAqVyprK3gqSypaLCRbMl09UCpLKloteCpXKmssJFszXT1QKksqayt4KlcqWiwkfWZ1bmN0aW9uIEEoJCl7cmV0dXJuInF1YXQoIiskWzBdKyIsICIrJFsxXSsiLCAiKyRbMl0rIiwgIiskWzNdKyIpIn12YXIgdz1oLmNsb25lLEI9aC5mcm9tVmFsdWVzLEQ9aC5jb3B5LEk9aC5zZXQsaj1oLmFkZCxWPU8sSj1oLnNjYWxlLF89aC5kb3Qsc3Q9aC5sZXJwLEc9aC5sZW5ndGgsWT1HLHJ0PWguc3F1YXJlZExlbmd0aCxvdD1ydCxhdD1oLm5vcm1hbGl6ZSxodD1oLmV4YWN0RXF1YWxzLGl0PWguZXF1YWxzLE10PWZ1bmN0aW9uKCl7dmFyICQ9Zi5jcmVhdGUoKSxRPWYuZnJvbVZhbHVlcygxLDAsMCksdHQ9Zi5mcm9tVmFsdWVzKDAsMSwwKTtyZXR1cm4gZnVuY3Rpb24oRixILHgpe3ZhciBQPWYuZG90KEgseCk7cmV0dXJuIFA8LS45OTk5OTk/KGYuY3Jvc3MoJCxRLEgpLGYubGVuKCQpPDFlLTYmJmYuY3Jvc3MoJCx0dCxIKSxmLm5vcm1hbGl6ZSgkLCQpLGQoRiwkLE1hdGguUEkpLEYpOlA+Ljk5OTk5OT8oRlswXT0wLEZbMV09MCxGWzJdPTAsRlszXT0xLEYpOihmLmNyb3NzKCQsSCx4KSxGWzBdPSRbMF0sRlsxXT0kWzFdLEZbMl09JFsyXSxGWzNdPTErUCxhdChGLEYpKX19KCksT3Q9ZnVuY3Rpb24oKXt2YXIgJD11KCksUT11KCk7cmV0dXJuIGZ1bmN0aW9uKHR0LEYsSCx4LFAsVyl7cmV0dXJuIGwoJCxGLFAsVyksbChRLEgseCxXKSxsKHR0LCQsUSwyKlcqKDEtVykpLHR0fX0oKSxVPWZ1bmN0aW9uKCl7dmFyICQ9aS5jcmVhdGUoKTtyZXR1cm4gZnVuY3Rpb24oUSx0dCxGLEgpe3JldHVybiAkWzBdPUZbMF0sJFszXT1GWzFdLCRbNl09RlsyXSwkWzFdPUhbMF0sJFs0XT1IWzFdLCRbN109SFsyXSwkWzJdPS10dFswXSwkWzVdPS10dFsxXSwkWzhdPS10dFsyXSxhdChRLEwoUSwkKSl9fSgpfSxmdW5jdGlvbihnLGUsdCl7dC5yKGUpLHQuZChlLCJjcmVhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIGl9KSx0LmQoZSwiY2xvbmUiLGZ1bmN0aW9uKCl7cmV0dXJuIGZ9KSx0LmQoZSwibGVuZ3RoIixmdW5jdGlvbigpe3JldHVybiBofSksdC5kKGUsImZyb21WYWx1ZXMiLGZ1bmN0aW9uKCl7cmV0dXJuIHV9KSx0LmQoZSwiY29weSIsZnVuY3Rpb24oKXtyZXR1cm4gYX0pLHQuZChlLCJzZXQiLGZ1bmN0aW9uKCl7cmV0dXJuIGR9KSx0LmQoZSwiYWRkIixmdW5jdGlvbigpe3JldHVybiBFfSksdC5kKGUsInN1YnRyYWN0IixmdW5jdGlvbigpe3JldHVybiBwfSksdC5kKGUsIm11bHRpcGx5IixmdW5jdGlvbigpe3JldHVybiBPfSksdC5kKGUsImRpdmlkZSIsZnVuY3Rpb24oKXtyZXR1cm4gbX0pLHQuZChlLCJjZWlsIixmdW5jdGlvbigpe3JldHVybiBifSksdC5kKGUsImZsb29yIixmdW5jdGlvbigpe3JldHVybiBNfSksdC5kKGUsIm1pbiIsZnVuY3Rpb24oKXtyZXR1cm4geX0pLHQuZChlLCJtYXgiLGZ1bmN0aW9uKCl7cmV0dXJuIFN9KSx0LmQoZSwicm91bmQiLGZ1bmN0aW9uKCl7cmV0dXJuIHN9KSx0LmQoZSwic2NhbGUiLGZ1bmN0aW9uKCl7cmV0dXJuIGN9KSx0LmQoZSwic2NhbGVBbmRBZGQiLGZ1bmN0aW9uKCl7cmV0dXJuIGx9KSx0LmQoZSwiZGlzdGFuY2UiLGZ1bmN0aW9uKCl7cmV0dXJuIHZ9KSx0LmQoZSwic3F1YXJlZERpc3RhbmNlIixmdW5jdGlvbigpe3JldHVybiBUfSksdC5kKGUsInNxdWFyZWRMZW5ndGgiLGZ1bmN0aW9uKCl7cmV0dXJuIFJ9KSx0LmQoZSwibmVnYXRlIixmdW5jdGlvbigpe3JldHVybiBMfSksdC5kKGUsImludmVyc2UiLGZ1bmN0aW9uKCl7cmV0dXJuIE59KSx0LmQoZSwibm9ybWFsaXplIixmdW5jdGlvbigpe3JldHVybiBBfSksdC5kKGUsImRvdCIsZnVuY3Rpb24oKXtyZXR1cm4gd30pLHQuZChlLCJjcm9zcyIsZnVuY3Rpb24oKXtyZXR1cm4gQn0pLHQuZChlLCJsZXJwIixmdW5jdGlvbigpe3JldHVybiBEfSksdC5kKGUsImhlcm1pdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIEl9KSx0LmQoZSwiYmV6aWVyIixmdW5jdGlvbigpe3JldHVybiBqfSksdC5kKGUsInJhbmRvbSIsZnVuY3Rpb24oKXtyZXR1cm4gVn0pLHQuZChlLCJ0cmFuc2Zvcm1NYXQ0IixmdW5jdGlvbigpe3JldHVybiBKfSksdC5kKGUsInRyYW5zZm9ybU1hdDMiLGZ1bmN0aW9uKCl7cmV0dXJuIF99KSx0LmQoZSwidHJhbnNmb3JtUXVhdCIsZnVuY3Rpb24oKXtyZXR1cm4gc3R9KSx0LmQoZSwicm90YXRlWCIsZnVuY3Rpb24oKXtyZXR1cm4gR30pLHQuZChlLCJyb3RhdGVZIixmdW5jdGlvbigpe3JldHVybiBZfSksdC5kKGUsInJvdGF0ZVoiLGZ1bmN0aW9uKCl7cmV0dXJuIHJ0fSksdC5kKGUsImFuZ2xlIixmdW5jdGlvbigpe3JldHVybiBvdH0pLHQuZChlLCJ6ZXJvIixmdW5jdGlvbigpe3JldHVybiBhdH0pLHQuZChlLCJzdHIiLGZ1bmN0aW9uKCl7cmV0dXJuIGh0fSksdC5kKGUsImV4YWN0RXF1YWxzIixmdW5jdGlvbigpe3JldHVybiBpdH0pLHQuZChlLCJlcXVhbHMiLGZ1bmN0aW9uKCl7cmV0dXJuIE10fSksdC5kKGUsInN1YiIsZnVuY3Rpb24oKXtyZXR1cm4gT3R9KSx0LmQoZSwibXVsIixmdW5jdGlvbigpe3JldHVybiBVfSksdC5kKGUsImRpdiIsZnVuY3Rpb24oKXtyZXR1cm4gJH0pLHQuZChlLCJkaXN0IixmdW5jdGlvbigpe3JldHVybiBRfSksdC5kKGUsInNxckRpc3QiLGZ1bmN0aW9uKCl7cmV0dXJuIHR0fSksdC5kKGUsImxlbiIsZnVuY3Rpb24oKXtyZXR1cm4gRn0pLHQuZChlLCJzcXJMZW4iLGZ1bmN0aW9uKCl7cmV0dXJuIEh9KSx0LmQoZSwiZm9yRWFjaCIsZnVuY3Rpb24oKXtyZXR1cm4geH0pO3ZhciBuPXQoMik7ZnVuY3Rpb24gaSgpe3ZhciBQPW5ldyBuLkFSUkFZX1RZUEUoMyk7cmV0dXJuIG4uQVJSQVlfVFlQRSE9RmxvYXQzMkFycmF5JiYoUFswXT0wLFBbMV09MCxQWzJdPTApLFB9ZnVuY3Rpb24gZihQKXt2YXIgVz1uZXcgbi5BUlJBWV9UWVBFKDMpO3JldHVybiBXWzBdPVBbMF0sV1sxXT1QWzFdLFdbMl09UFsyXSxXfWZ1bmN0aW9uIGgoUCl7dmFyIFc9UFswXSxLPVBbMV0sWj1QWzJdO3JldHVybiBNYXRoLmh5cG90KFcsSyxaKX1mdW5jdGlvbiB1KFAsVyxLKXt2YXIgWj1uZXcgbi5BUlJBWV9UWVBFKDMpO3JldHVybiBaWzBdPVAsWlsxXT1XLFpbMl09SyxafWZ1bmN0aW9uIGEoUCxXKXtyZXR1cm4gUFswXT1XWzBdLFBbMV09V1sxXSxQWzJdPVdbMl0sUH1mdW5jdGlvbiBkKFAsVyxLLFope3JldHVybiBQWzBdPVcsUFsxXT1LLFBbMl09WixQfWZ1bmN0aW9uIEUoUCxXLEspe3JldHVybiBQWzBdPVdbMF0rS1swXSxQWzFdPVdbMV0rS1sxXSxQWzJdPVdbMl0rS1syXSxQfWZ1bmN0aW9uIHAoUCxXLEspe3JldHVybiBQWzBdPVdbMF0tS1swXSxQWzFdPVdbMV0tS1sxXSxQWzJdPVdbMl0tS1syXSxQfWZ1bmN0aW9uIE8oUCxXLEspe3JldHVybiBQWzBdPVdbMF0qS1swXSxQWzFdPVdbMV0qS1sxXSxQWzJdPVdbMl0qS1syXSxQfWZ1bmN0aW9uIG0oUCxXLEspe3JldHVybiBQWzBdPVdbMF0vS1swXSxQWzFdPVdbMV0vS1sxXSxQWzJdPVdbMl0vS1syXSxQfWZ1bmN0aW9uIGIoUCxXKXtyZXR1cm4gUFswXT1NYXRoLmNlaWwoV1swXSksUFsxXT1NYXRoLmNlaWwoV1sxXSksUFsyXT1NYXRoLmNlaWwoV1syXSksUH1mdW5jdGlvbiBNKFAsVyl7cmV0dXJuIFBbMF09TWF0aC5mbG9vcihXWzBdKSxQWzFdPU1hdGguZmxvb3IoV1sxXSksUFsyXT1NYXRoLmZsb29yKFdbMl0pLFB9ZnVuY3Rpb24geShQLFcsSyl7cmV0dXJuIFBbMF09TWF0aC5taW4oV1swXSxLWzBdKSxQWzFdPU1hdGgubWluKFdbMV0sS1sxXSksUFsyXT1NYXRoLm1pbihXWzJdLEtbMl0pLFB9ZnVuY3Rpb24gUyhQLFcsSyl7cmV0dXJuIFBbMF09TWF0aC5tYXgoV1swXSxLWzBdKSxQWzFdPU1hdGgubWF4KFdbMV0sS1sxXSksUFsyXT1NYXRoLm1heChXWzJdLEtbMl0pLFB9ZnVuY3Rpb24gcyhQLFcpe3JldHVybiBQWzBdPU1hdGgucm91bmQoV1swXSksUFsxXT1NYXRoLnJvdW5kKFdbMV0pLFBbMl09TWF0aC5yb3VuZChXWzJdKSxQfWZ1bmN0aW9uIGMoUCxXLEspe3JldHVybiBQWzBdPVdbMF0qSyxQWzFdPVdbMV0qSyxQWzJdPVdbMl0qSyxQfWZ1bmN0aW9uIGwoUCxXLEssWil7cmV0dXJuIFBbMF09V1swXStLWzBdKlosUFsxXT1XWzFdK0tbMV0qWixQWzJdPVdbMl0rS1syXSpaLFB9ZnVuY3Rpb24gdihQLFcpe3ZhciBLPVdbMF0tUFswXSxaPVdbMV0tUFsxXSxrPVdbMl0tUFsyXTtyZXR1cm4gTWF0aC5oeXBvdChLLFosayl9ZnVuY3Rpb24gVChQLFcpe3ZhciBLPVdbMF0tUFswXSxaPVdbMV0tUFsxXSxrPVdbMl0tUFsyXTtyZXR1cm4gSypLK1oqWitrKmt9ZnVuY3Rpb24gUihQKXt2YXIgVz1QWzBdLEs9UFsxXSxaPVBbMl07cmV0dXJuIFcqVytLKksrWipafWZ1bmN0aW9uIEwoUCxXKXtyZXR1cm4gUFswXT0tV1swXSxQWzFdPS1XWzFdLFBbMl09LVdbMl0sUH1mdW5jdGlvbiBOKFAsVyl7cmV0dXJuIFBbMF09MS9XWzBdLFBbMV09MS9XWzFdLFBbMl09MS9XWzJdLFB9ZnVuY3Rpb24gQShQLFcpe3ZhciBLPVdbMF0sWj1XWzFdLGs9V1syXSxudD1LKksrWipaK2sqaztyZXR1cm4gbnQ+MCYmKG50PTEvTWF0aC5zcXJ0KG50KSksUFswXT1XWzBdKm50LFBbMV09V1sxXSpudCxQWzJdPVdbMl0qbnQsUH1mdW5jdGlvbiB3KFAsVyl7cmV0dXJuIFBbMF0qV1swXStQWzFdKldbMV0rUFsyXSpXWzJdfWZ1bmN0aW9uIEIoUCxXLEspe3ZhciBaPVdbMF0saz1XWzFdLG50PVdbMl0sdXQ9S1swXSxjdD1LWzFdLHB0PUtbMl07cmV0dXJuIFBbMF09aypwdC1udCpjdCxQWzFdPW50KnV0LVoqcHQsUFsyXT1aKmN0LWsqdXQsUH1mdW5jdGlvbiBEKFAsVyxLLFope3ZhciBrPVdbMF0sbnQ9V1sxXSx1dD1XWzJdO3JldHVybiBQWzBdPWsrWiooS1swXS1rKSxQWzFdPW50K1oqKEtbMV0tbnQpLFBbMl09dXQrWiooS1syXS11dCksUH1mdW5jdGlvbiBJKFAsVyxLLFosayxudCl7dmFyIHV0PW50Km50LGN0PXV0KigyKm50LTMpKzEscHQ9dXQqKG50LTIpK250LHh0PXV0KihudC0xKSxndD11dCooMy0yKm50KTtyZXR1cm4gUFswXT1XWzBdKmN0K0tbMF0qcHQrWlswXSp4dCtrWzBdKmd0LFBbMV09V1sxXSpjdCtLWzFdKnB0K1pbMV0qeHQra1sxXSpndCxQWzJdPVdbMl0qY3QrS1syXSpwdCtaWzJdKnh0K2tbMl0qZ3QsUH1mdW5jdGlvbiBqKFAsVyxLLFosayxudCl7dmFyIHV0PTEtbnQsY3Q9dXQqdXQscHQ9bnQqbnQseHQ9Y3QqdXQsZ3Q9MypudCpjdCxkdD0zKnB0KnV0LG10PXB0Km50O3JldHVybiBQWzBdPVdbMF0qeHQrS1swXSpndCtaWzBdKmR0K2tbMF0qbXQsUFsxXT1XWzFdKnh0K0tbMV0qZ3QrWlsxXSpkdCtrWzFdKm10LFBbMl09V1syXSp4dCtLWzJdKmd0K1pbMl0qZHQra1syXSptdCxQfWZ1bmN0aW9uIFYoUCxXKXtXPVd8fDE7dmFyIEs9bi5SQU5ET00oKSoyKk1hdGguUEksWj1uLlJBTkRPTSgpKjItMSxrPU1hdGguc3FydCgxLVoqWikqVztyZXR1cm4gUFswXT1NYXRoLmNvcyhLKSprLFBbMV09TWF0aC5zaW4oSykqayxQWzJdPVoqVyxQfWZ1bmN0aW9uIEooUCxXLEspe3ZhciBaPVdbMF0saz1XWzFdLG50PVdbMl0sdXQ9S1szXSpaK0tbN10qaytLWzExXSpudCtLWzE1XTtyZXR1cm4gdXQ9dXR8fDEsUFswXT0oS1swXSpaK0tbNF0qaytLWzhdKm50K0tbMTJdKS91dCxQWzFdPShLWzFdKlorS1s1XSprK0tbOV0qbnQrS1sxM10pL3V0LFBbMl09KEtbMl0qWitLWzZdKmsrS1sxMF0qbnQrS1sxNF0pL3V0LFB9ZnVuY3Rpb24gXyhQLFcsSyl7dmFyIFo9V1swXSxrPVdbMV0sbnQ9V1syXTtyZXR1cm4gUFswXT1aKktbMF0raypLWzNdK250KktbNl0sUFsxXT1aKktbMV0raypLWzRdK250KktbN10sUFsyXT1aKktbMl0raypLWzVdK250KktbOF0sUH1mdW5jdGlvbiBzdChQLFcsSyl7dmFyIFo9S1swXSxrPUtbMV0sbnQ9S1syXSx1dD1LWzNdLGN0PVdbMF0scHQ9V1sxXSx4dD1XWzJdLGd0PWsqeHQtbnQqcHQsZHQ9bnQqY3QtWip4dCxtdD1aKnB0LWsqY3QsYnQ9ayptdC1udCpkdCxDdD1udCpndC1aKm10LFN0PVoqZHQtaypndCxOdD11dCoyO3JldHVybiBndCo9TnQsZHQqPU50LG10Kj1OdCxidCo9MixDdCo9MixTdCo9MixQWzBdPWN0K2d0K2J0LFBbMV09cHQrZHQrQ3QsUFsyXT14dCttdCtTdCxQfWZ1bmN0aW9uIEcoUCxXLEssWil7dmFyIGs9W10sbnQ9W107cmV0dXJuIGtbMF09V1swXS1LWzBdLGtbMV09V1sxXS1LWzFdLGtbMl09V1syXS1LWzJdLG50WzBdPWtbMF0sbnRbMV09a1sxXSpNYXRoLmNvcyhaKS1rWzJdKk1hdGguc2luKFopLG50WzJdPWtbMV0qTWF0aC5zaW4oWikra1syXSpNYXRoLmNvcyhaKSxQWzBdPW50WzBdK0tbMF0sUFsxXT1udFsxXStLWzFdLFBbMl09bnRbMl0rS1syXSxQfWZ1bmN0aW9uIFkoUCxXLEssWil7dmFyIGs9W10sbnQ9W107cmV0dXJuIGtbMF09V1swXS1LWzBdLGtbMV09V1sxXS1LWzFdLGtbMl09V1syXS1LWzJdLG50WzBdPWtbMl0qTWF0aC5zaW4oWikra1swXSpNYXRoLmNvcyhaKSxudFsxXT1rWzFdLG50WzJdPWtbMl0qTWF0aC5jb3MoWikta1swXSpNYXRoLnNpbihaKSxQWzBdPW50WzBdK0tbMF0sUFsxXT1udFsxXStLWzFdLFBbMl09bnRbMl0rS1syXSxQfWZ1bmN0aW9uIHJ0KFAsVyxLLFope3ZhciBrPVtdLG50PVtdO3JldHVybiBrWzBdPVdbMF0tS1swXSxrWzFdPVdbMV0tS1sxXSxrWzJdPVdbMl0tS1syXSxudFswXT1rWzBdKk1hdGguY29zKFopLWtbMV0qTWF0aC5zaW4oWiksbnRbMV09a1swXSpNYXRoLnNpbihaKStrWzFdKk1hdGguY29zKFopLG50WzJdPWtbMl0sUFswXT1udFswXStLWzBdLFBbMV09bnRbMV0rS1sxXSxQWzJdPW50WzJdK0tbMl0sUH1mdW5jdGlvbiBvdChQLFcpe3ZhciBLPVBbMF0sWj1QWzFdLGs9UFsyXSxudD1XWzBdLHV0PVdbMV0sY3Q9V1syXSxwdD1NYXRoLnNxcnQoSypLK1oqWitrKmspLHh0PU1hdGguc3FydChudCpudCt1dCp1dCtjdCpjdCksZ3Q9cHQqeHQsZHQ9Z3QmJncoUCxXKS9ndDtyZXR1cm4gTWF0aC5hY29zKE1hdGgubWluKE1hdGgubWF4KGR0LC0xKSwxKSl9ZnVuY3Rpb24gYXQoUCl7cmV0dXJuIFBbMF09MCxQWzFdPTAsUFsyXT0wLFB9ZnVuY3Rpb24gaHQoUCl7cmV0dXJuInZlYzMoIitQWzBdKyIsICIrUFsxXSsiLCAiK1BbMl0rIikifWZ1bmN0aW9uIGl0KFAsVyl7cmV0dXJuIFBbMF09PT1XWzBdJiZQWzFdPT09V1sxXSYmUFsyXT09PVdbMl19ZnVuY3Rpb24gTXQoUCxXKXt2YXIgSz1QWzBdLFo9UFsxXSxrPVBbMl0sbnQ9V1swXSx1dD1XWzFdLGN0PVdbMl07cmV0dXJuIE1hdGguYWJzKEstbnQpPD1uLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhLKSxNYXRoLmFicyhudCkpJiZNYXRoLmFicyhaLXV0KTw9bi5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoWiksTWF0aC5hYnModXQpKSYmTWF0aC5hYnMoay1jdCk8PW4uRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKGspLE1hdGguYWJzKGN0KSl9dmFyIE90PXAsVT1PLCQ9bSxRPXYsdHQ9VCxGPWgsSD1SLHg9ZnVuY3Rpb24oKXt2YXIgUD1pKCk7cmV0dXJuIGZ1bmN0aW9uKFcsSyxaLGssbnQsdXQpe3ZhciBjdCxwdDtmb3IoS3x8KEs9MyksWnx8KFo9MCksaz9wdD1NYXRoLm1pbihrKksrWixXLmxlbmd0aCk6cHQ9Vy5sZW5ndGgsY3Q9WjtjdDxwdDtjdCs9SylQWzBdPVdbY3RdLFBbMV09V1tjdCsxXSxQWzJdPVdbY3QrMl0sbnQoUCxQLHV0KSxXW2N0XT1QWzBdLFdbY3QrMV09UFsxXSxXW2N0KzJdPVBbMl07cmV0dXJuIFd9fSgpfSxmdW5jdGlvbihnLGUsdCl7dC5yKGUpLHQuZChlLCJjcmVhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIGl9KSx0LmQoZSwiY2xvbmUiLGZ1bmN0aW9uKCl7cmV0dXJuIGZ9KSx0LmQoZSwiZnJvbVZhbHVlcyIsZnVuY3Rpb24oKXtyZXR1cm4gaH0pLHQuZChlLCJjb3B5IixmdW5jdGlvbigpe3JldHVybiB1fSksdC5kKGUsInNldCIsZnVuY3Rpb24oKXtyZXR1cm4gYX0pLHQuZChlLCJhZGQiLGZ1bmN0aW9uKCl7cmV0dXJuIGR9KSx0LmQoZSwic3VidHJhY3QiLGZ1bmN0aW9uKCl7cmV0dXJuIEV9KSx0LmQoZSwibXVsdGlwbHkiLGZ1bmN0aW9uKCl7cmV0dXJuIHB9KSx0LmQoZSwiZGl2aWRlIixmdW5jdGlvbigpe3JldHVybiBPfSksdC5kKGUsImNlaWwiLGZ1bmN0aW9uKCl7cmV0dXJuIG19KSx0LmQoZSwiZmxvb3IiLGZ1bmN0aW9uKCl7cmV0dXJuIGJ9KSx0LmQoZSwibWluIixmdW5jdGlvbigpe3JldHVybiBNfSksdC5kKGUsIm1heCIsZnVuY3Rpb24oKXtyZXR1cm4geX0pLHQuZChlLCJyb3VuZCIsZnVuY3Rpb24oKXtyZXR1cm4gU30pLHQuZChlLCJzY2FsZSIsZnVuY3Rpb24oKXtyZXR1cm4gc30pLHQuZChlLCJzY2FsZUFuZEFkZCIsZnVuY3Rpb24oKXtyZXR1cm4gY30pLHQuZChlLCJkaXN0YW5jZSIsZnVuY3Rpb24oKXtyZXR1cm4gbH0pLHQuZChlLCJzcXVhcmVkRGlzdGFuY2UiLGZ1bmN0aW9uKCl7cmV0dXJuIHZ9KSx0LmQoZSwibGVuZ3RoIixmdW5jdGlvbigpe3JldHVybiBUfSksdC5kKGUsInNxdWFyZWRMZW5ndGgiLGZ1bmN0aW9uKCl7cmV0dXJuIFJ9KSx0LmQoZSwibmVnYXRlIixmdW5jdGlvbigpe3JldHVybiBMfSksdC5kKGUsImludmVyc2UiLGZ1bmN0aW9uKCl7cmV0dXJuIE59KSx0LmQoZSwibm9ybWFsaXplIixmdW5jdGlvbigpe3JldHVybiBBfSksdC5kKGUsImRvdCIsZnVuY3Rpb24oKXtyZXR1cm4gd30pLHQuZChlLCJjcm9zcyIsZnVuY3Rpb24oKXtyZXR1cm4gQn0pLHQuZChlLCJsZXJwIixmdW5jdGlvbigpe3JldHVybiBEfSksdC5kKGUsInJhbmRvbSIsZnVuY3Rpb24oKXtyZXR1cm4gSX0pLHQuZChlLCJ0cmFuc2Zvcm1NYXQ0IixmdW5jdGlvbigpe3JldHVybiBqfSksdC5kKGUsInRyYW5zZm9ybVF1YXQiLGZ1bmN0aW9uKCl7cmV0dXJuIFZ9KSx0LmQoZSwiemVybyIsZnVuY3Rpb24oKXtyZXR1cm4gSn0pLHQuZChlLCJzdHIiLGZ1bmN0aW9uKCl7cmV0dXJuIF99KSx0LmQoZSwiZXhhY3RFcXVhbHMiLGZ1bmN0aW9uKCl7cmV0dXJuIHN0fSksdC5kKGUsImVxdWFscyIsZnVuY3Rpb24oKXtyZXR1cm4gR30pLHQuZChlLCJzdWIiLGZ1bmN0aW9uKCl7cmV0dXJuIFl9KSx0LmQoZSwibXVsIixmdW5jdGlvbigpe3JldHVybiBydH0pLHQuZChlLCJkaXYiLGZ1bmN0aW9uKCl7cmV0dXJuIG90fSksdC5kKGUsImRpc3QiLGZ1bmN0aW9uKCl7cmV0dXJuIGF0fSksdC5kKGUsInNxckRpc3QiLGZ1bmN0aW9uKCl7cmV0dXJuIGh0fSksdC5kKGUsImxlbiIsZnVuY3Rpb24oKXtyZXR1cm4gaXR9KSx0LmQoZSwic3FyTGVuIixmdW5jdGlvbigpe3JldHVybiBNdH0pLHQuZChlLCJmb3JFYWNoIixmdW5jdGlvbigpe3JldHVybiBPdH0pO3ZhciBuPXQoMik7ZnVuY3Rpb24gaSgpe3ZhciBVPW5ldyBuLkFSUkFZX1RZUEUoNCk7cmV0dXJuIG4uQVJSQVlfVFlQRSE9RmxvYXQzMkFycmF5JiYoVVswXT0wLFVbMV09MCxVWzJdPTAsVVszXT0wKSxVfWZ1bmN0aW9uIGYoVSl7dmFyICQ9bmV3IG4uQVJSQVlfVFlQRSg0KTtyZXR1cm4gJFswXT1VWzBdLCRbMV09VVsxXSwkWzJdPVVbMl0sJFszXT1VWzNdLCR9ZnVuY3Rpb24gaChVLCQsUSx0dCl7dmFyIEY9bmV3IG4uQVJSQVlfVFlQRSg0KTtyZXR1cm4gRlswXT1VLEZbMV09JCxGWzJdPVEsRlszXT10dCxGfWZ1bmN0aW9uIHUoVSwkKXtyZXR1cm4gVVswXT0kWzBdLFVbMV09JFsxXSxVWzJdPSRbMl0sVVszXT0kWzNdLFV9ZnVuY3Rpb24gYShVLCQsUSx0dCxGKXtyZXR1cm4gVVswXT0kLFVbMV09USxVWzJdPXR0LFVbM109RixVfWZ1bmN0aW9uIGQoVSwkLFEpe3JldHVybiBVWzBdPSRbMF0rUVswXSxVWzFdPSRbMV0rUVsxXSxVWzJdPSRbMl0rUVsyXSxVWzNdPSRbM10rUVszXSxVfWZ1bmN0aW9uIEUoVSwkLFEpe3JldHVybiBVWzBdPSRbMF0tUVswXSxVWzFdPSRbMV0tUVsxXSxVWzJdPSRbMl0tUVsyXSxVWzNdPSRbM10tUVszXSxVfWZ1bmN0aW9uIHAoVSwkLFEpe3JldHVybiBVWzBdPSRbMF0qUVswXSxVWzFdPSRbMV0qUVsxXSxVWzJdPSRbMl0qUVsyXSxVWzNdPSRbM10qUVszXSxVfWZ1bmN0aW9uIE8oVSwkLFEpe3JldHVybiBVWzBdPSRbMF0vUVswXSxVWzFdPSRbMV0vUVsxXSxVWzJdPSRbMl0vUVsyXSxVWzNdPSRbM10vUVszXSxVfWZ1bmN0aW9uIG0oVSwkKXtyZXR1cm4gVVswXT1NYXRoLmNlaWwoJFswXSksVVsxXT1NYXRoLmNlaWwoJFsxXSksVVsyXT1NYXRoLmNlaWwoJFsyXSksVVszXT1NYXRoLmNlaWwoJFszXSksVX1mdW5jdGlvbiBiKFUsJCl7cmV0dXJuIFVbMF09TWF0aC5mbG9vcigkWzBdKSxVWzFdPU1hdGguZmxvb3IoJFsxXSksVVsyXT1NYXRoLmZsb29yKCRbMl0pLFVbM109TWF0aC5mbG9vcigkWzNdKSxVfWZ1bmN0aW9uIE0oVSwkLFEpe3JldHVybiBVWzBdPU1hdGgubWluKCRbMF0sUVswXSksVVsxXT1NYXRoLm1pbigkWzFdLFFbMV0pLFVbMl09TWF0aC5taW4oJFsyXSxRWzJdKSxVWzNdPU1hdGgubWluKCRbM10sUVszXSksVX1mdW5jdGlvbiB5KFUsJCxRKXtyZXR1cm4gVVswXT1NYXRoLm1heCgkWzBdLFFbMF0pLFVbMV09TWF0aC5tYXgoJFsxXSxRWzFdKSxVWzJdPU1hdGgubWF4KCRbMl0sUVsyXSksVVszXT1NYXRoLm1heCgkWzNdLFFbM10pLFV9ZnVuY3Rpb24gUyhVLCQpe3JldHVybiBVWzBdPU1hdGgucm91bmQoJFswXSksVVsxXT1NYXRoLnJvdW5kKCRbMV0pLFVbMl09TWF0aC5yb3VuZCgkWzJdKSxVWzNdPU1hdGgucm91bmQoJFszXSksVX1mdW5jdGlvbiBzKFUsJCxRKXtyZXR1cm4gVVswXT0kWzBdKlEsVVsxXT0kWzFdKlEsVVsyXT0kWzJdKlEsVVszXT0kWzNdKlEsVX1mdW5jdGlvbiBjKFUsJCxRLHR0KXtyZXR1cm4gVVswXT0kWzBdK1FbMF0qdHQsVVsxXT0kWzFdK1FbMV0qdHQsVVsyXT0kWzJdK1FbMl0qdHQsVVszXT0kWzNdK1FbM10qdHQsVX1mdW5jdGlvbiBsKFUsJCl7dmFyIFE9JFswXS1VWzBdLHR0PSRbMV0tVVsxXSxGPSRbMl0tVVsyXSxIPSRbM10tVVszXTtyZXR1cm4gTWF0aC5oeXBvdChRLHR0LEYsSCl9ZnVuY3Rpb24gdihVLCQpe3ZhciBRPSRbMF0tVVswXSx0dD0kWzFdLVVbMV0sRj0kWzJdLVVbMl0sSD0kWzNdLVVbM107cmV0dXJuIFEqUSt0dCp0dCtGKkYrSCpIfWZ1bmN0aW9uIFQoVSl7dmFyICQ9VVswXSxRPVVbMV0sdHQ9VVsyXSxGPVVbM107cmV0dXJuIE1hdGguaHlwb3QoJCxRLHR0LEYpfWZ1bmN0aW9uIFIoVSl7dmFyICQ9VVswXSxRPVVbMV0sdHQ9VVsyXSxGPVVbM107cmV0dXJuICQqJCtRKlErdHQqdHQrRipGfWZ1bmN0aW9uIEwoVSwkKXtyZXR1cm4gVVswXT0tJFswXSxVWzFdPS0kWzFdLFVbMl09LSRbMl0sVVszXT0tJFszXSxVfWZ1bmN0aW9uIE4oVSwkKXtyZXR1cm4gVVswXT0xLyRbMF0sVVsxXT0xLyRbMV0sVVsyXT0xLyRbMl0sVVszXT0xLyRbM10sVX1mdW5jdGlvbiBBKFUsJCl7dmFyIFE9JFswXSx0dD0kWzFdLEY9JFsyXSxIPSRbM10seD1RKlErdHQqdHQrRipGK0gqSDtyZXR1cm4geD4wJiYoeD0xL01hdGguc3FydCh4KSksVVswXT1RKngsVVsxXT10dCp4LFVbMl09Rip4LFVbM109SCp4LFV9ZnVuY3Rpb24gdyhVLCQpe3JldHVybiBVWzBdKiRbMF0rVVsxXSokWzFdK1VbMl0qJFsyXStVWzNdKiRbM119ZnVuY3Rpb24gQihVLCQsUSx0dCl7dmFyIEY9UVswXSp0dFsxXS1RWzFdKnR0WzBdLEg9UVswXSp0dFsyXS1RWzJdKnR0WzBdLHg9UVswXSp0dFszXS1RWzNdKnR0WzBdLFA9UVsxXSp0dFsyXS1RWzJdKnR0WzFdLFc9UVsxXSp0dFszXS1RWzNdKnR0WzFdLEs9UVsyXSp0dFszXS1RWzNdKnR0WzJdLFo9JFswXSxrPSRbMV0sbnQ9JFsyXSx1dD0kWzNdO3JldHVybiBVWzBdPWsqSy1udCpXK3V0KlAsVVsxXT0tKFoqSykrbnQqeC11dCpILFVbMl09WipXLWsqeCt1dCpGLFVbM109LShaKlApK2sqSC1udCpGLFV9ZnVuY3Rpb24gRChVLCQsUSx0dCl7dmFyIEY9JFswXSxIPSRbMV0seD0kWzJdLFA9JFszXTtyZXR1cm4gVVswXT1GK3R0KihRWzBdLUYpLFVbMV09SCt0dCooUVsxXS1IKSxVWzJdPXgrdHQqKFFbMl0teCksVVszXT1QK3R0KihRWzNdLVApLFV9ZnVuY3Rpb24gSShVLCQpeyQ9JHx8MTt2YXIgUSx0dCxGLEgseCxQO2RvIFE9bi5SQU5ET00oKSoyLTEsdHQ9bi5SQU5ET00oKSoyLTEseD1RKlErdHQqdHQ7d2hpbGUoeD49MSk7ZG8gRj1uLlJBTkRPTSgpKjItMSxIPW4uUkFORE9NKCkqMi0xLFA9RipGK0gqSDt3aGlsZShQPj0xKTt2YXIgVz1NYXRoLnNxcnQoKDEteCkvUCk7cmV0dXJuIFVbMF09JCpRLFVbMV09JCp0dCxVWzJdPSQqRipXLFVbM109JCpIKlcsVX1mdW5jdGlvbiBqKFUsJCxRKXt2YXIgdHQ9JFswXSxGPSRbMV0sSD0kWzJdLHg9JFszXTtyZXR1cm4gVVswXT1RWzBdKnR0K1FbNF0qRitRWzhdKkgrUVsxMl0qeCxVWzFdPVFbMV0qdHQrUVs1XSpGK1FbOV0qSCtRWzEzXSp4LFVbMl09UVsyXSp0dCtRWzZdKkYrUVsxMF0qSCtRWzE0XSp4LFVbM109UVszXSp0dCtRWzddKkYrUVsxMV0qSCtRWzE1XSp4LFV9ZnVuY3Rpb24gVihVLCQsUSl7dmFyIHR0PSRbMF0sRj0kWzFdLEg9JFsyXSx4PVFbMF0sUD1RWzFdLFc9UVsyXSxLPVFbM10sWj1LKnR0K1AqSC1XKkYsaz1LKkYrVyp0dC14KkgsbnQ9SypIK3gqRi1QKnR0LHV0PS14KnR0LVAqRi1XKkg7cmV0dXJuIFVbMF09WipLK3V0Ki14K2sqLVctbnQqLVAsVVsxXT1rKksrdXQqLVArbnQqLXgtWiotVyxVWzJdPW50KksrdXQqLVcrWiotUC1rKi14LFVbM109JFszXSxVfWZ1bmN0aW9uIEooVSl7cmV0dXJuIFVbMF09MCxVWzFdPTAsVVsyXT0wLFVbM109MCxVfWZ1bmN0aW9uIF8oVSl7cmV0dXJuInZlYzQoIitVWzBdKyIsICIrVVsxXSsiLCAiK1VbMl0rIiwgIitVWzNdKyIpIn1mdW5jdGlvbiBzdChVLCQpe3JldHVybiBVWzBdPT09JFswXSYmVVsxXT09PSRbMV0mJlVbMl09PT0kWzJdJiZVWzNdPT09JFszXX1mdW5jdGlvbiBHKFUsJCl7dmFyIFE9VVswXSx0dD1VWzFdLEY9VVsyXSxIPVVbM10seD0kWzBdLFA9JFsxXSxXPSRbMl0sSz0kWzNdO3JldHVybiBNYXRoLmFicyhRLXgpPD1uLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhRKSxNYXRoLmFicyh4KSkmJk1hdGguYWJzKHR0LVApPD1uLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyh0dCksTWF0aC5hYnMoUCkpJiZNYXRoLmFicyhGLVcpPD1uLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhGKSxNYXRoLmFicyhXKSkmJk1hdGguYWJzKEgtSyk8PW4uRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKEgpLE1hdGguYWJzKEspKX12YXIgWT1FLHJ0PXAsb3Q9TyxhdD1sLGh0PXYsaXQ9VCxNdD1SLE90PWZ1bmN0aW9uKCl7dmFyIFU9aSgpO3JldHVybiBmdW5jdGlvbigkLFEsdHQsRixILHgpe3ZhciBQLFc7Zm9yKFF8fChRPTQpLHR0fHwodHQ9MCksRj9XPU1hdGgubWluKEYqUSt0dCwkLmxlbmd0aCk6Vz0kLmxlbmd0aCxQPXR0O1A8VztQKz1RKVVbMF09JFtQXSxVWzFdPSRbUCsxXSxVWzJdPSRbUCsyXSxVWzNdPSRbUCszXSxIKFUsVSx4KSwkW1BdPVVbMF0sJFtQKzFdPVVbMV0sJFtQKzJdPVVbMl0sJFtQKzNdPVVbM107cmV0dXJuICR9fSgpfSxmdW5jdGlvbihnLGUsdCl7dC5yKGUpLHQuZChlLCJjcmVhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIGh9KSx0LmQoZSwiY2xvbmUiLGZ1bmN0aW9uKCl7cmV0dXJuIHV9KSx0LmQoZSwiZnJvbVZhbHVlcyIsZnVuY3Rpb24oKXtyZXR1cm4gYX0pLHQuZChlLCJmcm9tUm90YXRpb25UcmFuc2xhdGlvblZhbHVlcyIsZnVuY3Rpb24oKXtyZXR1cm4gZH0pLHQuZChlLCJmcm9tUm90YXRpb25UcmFuc2xhdGlvbiIsZnVuY3Rpb24oKXtyZXR1cm4gRX0pLHQuZChlLCJmcm9tVHJhbnNsYXRpb24iLGZ1bmN0aW9uKCl7cmV0dXJuIHB9KSx0LmQoZSwiZnJvbVJvdGF0aW9uIixmdW5jdGlvbigpe3JldHVybiBPfSksdC5kKGUsImZyb21NYXQ0IixmdW5jdGlvbigpe3JldHVybiBtfSksdC5kKGUsImNvcHkiLGZ1bmN0aW9uKCl7cmV0dXJuIGJ9KSx0LmQoZSwiaWRlbnRpdHkiLGZ1bmN0aW9uKCl7cmV0dXJuIE19KSx0LmQoZSwic2V0IixmdW5jdGlvbigpe3JldHVybiB5fSksdC5kKGUsImdldFJlYWwiLGZ1bmN0aW9uKCl7cmV0dXJuIFN9KSx0LmQoZSwiZ2V0RHVhbCIsZnVuY3Rpb24oKXtyZXR1cm4gc30pLHQuZChlLCJzZXRSZWFsIixmdW5jdGlvbigpe3JldHVybiBjfSksdC5kKGUsInNldER1YWwiLGZ1bmN0aW9uKCl7cmV0dXJuIGx9KSx0LmQoZSwiZ2V0VHJhbnNsYXRpb24iLGZ1bmN0aW9uKCl7cmV0dXJuIHZ9KSx0LmQoZSwidHJhbnNsYXRlIixmdW5jdGlvbigpe3JldHVybiBUfSksdC5kKGUsInJvdGF0ZVgiLGZ1bmN0aW9uKCl7cmV0dXJuIFJ9KSx0LmQoZSwicm90YXRlWSIsZnVuY3Rpb24oKXtyZXR1cm4gTH0pLHQuZChlLCJyb3RhdGVaIixmdW5jdGlvbigpe3JldHVybiBOfSksdC5kKGUsInJvdGF0ZUJ5UXVhdEFwcGVuZCIsZnVuY3Rpb24oKXtyZXR1cm4gQX0pLHQuZChlLCJyb3RhdGVCeVF1YXRQcmVwZW5kIixmdW5jdGlvbigpe3JldHVybiB3fSksdC5kKGUsInJvdGF0ZUFyb3VuZEF4aXMiLGZ1bmN0aW9uKCl7cmV0dXJuIEJ9KSx0LmQoZSwiYWRkIixmdW5jdGlvbigpe3JldHVybiBEfSksdC5kKGUsIm11bHRpcGx5IixmdW5jdGlvbigpe3JldHVybiBJfSksdC5kKGUsIm11bCIsZnVuY3Rpb24oKXtyZXR1cm4gan0pLHQuZChlLCJzY2FsZSIsZnVuY3Rpb24oKXtyZXR1cm4gVn0pLHQuZChlLCJkb3QiLGZ1bmN0aW9uKCl7cmV0dXJuIEp9KSx0LmQoZSwibGVycCIsZnVuY3Rpb24oKXtyZXR1cm4gX30pLHQuZChlLCJpbnZlcnQiLGZ1bmN0aW9uKCl7cmV0dXJuIHN0fSksdC5kKGUsImNvbmp1Z2F0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gR30pLHQuZChlLCJsZW5ndGgiLGZ1bmN0aW9uKCl7cmV0dXJuIFl9KSx0LmQoZSwibGVuIixmdW5jdGlvbigpe3JldHVybiBydH0pLHQuZChlLCJzcXVhcmVkTGVuZ3RoIixmdW5jdGlvbigpe3JldHVybiBvdH0pLHQuZChlLCJzcXJMZW4iLGZ1bmN0aW9uKCl7cmV0dXJuIGF0fSksdC5kKGUsIm5vcm1hbGl6ZSIsZnVuY3Rpb24oKXtyZXR1cm4gaHR9KSx0LmQoZSwic3RyIixmdW5jdGlvbigpe3JldHVybiBpdH0pLHQuZChlLCJleGFjdEVxdWFscyIsZnVuY3Rpb24oKXtyZXR1cm4gTXR9KSx0LmQoZSwiZXF1YWxzIixmdW5jdGlvbigpe3JldHVybiBPdH0pO3ZhciBuPXQoMiksaT10KDcpLGY9dCg2KTtmdW5jdGlvbiBoKCl7dmFyIFU9bmV3IG4uQVJSQVlfVFlQRSg4KTtyZXR1cm4gbi5BUlJBWV9UWVBFIT1GbG9hdDMyQXJyYXkmJihVWzBdPTAsVVsxXT0wLFVbMl09MCxVWzRdPTAsVVs1XT0wLFVbNl09MCxVWzddPTApLFVbM109MSxVfWZ1bmN0aW9uIHUoVSl7dmFyICQ9bmV3IG4uQVJSQVlfVFlQRSg4KTtyZXR1cm4gJFswXT1VWzBdLCRbMV09VVsxXSwkWzJdPVVbMl0sJFszXT1VWzNdLCRbNF09VVs0XSwkWzVdPVVbNV0sJFs2XT1VWzZdLCRbN109VVs3XSwkfWZ1bmN0aW9uIGEoVSwkLFEsdHQsRixILHgsUCl7dmFyIFc9bmV3IG4uQVJSQVlfVFlQRSg4KTtyZXR1cm4gV1swXT1VLFdbMV09JCxXWzJdPVEsV1szXT10dCxXWzRdPUYsV1s1XT1ILFdbNl09eCxXWzddPVAsV31mdW5jdGlvbiBkKFUsJCxRLHR0LEYsSCx4KXt2YXIgUD1uZXcgbi5BUlJBWV9UWVBFKDgpO1BbMF09VSxQWzFdPSQsUFsyXT1RLFBbM109dHQ7dmFyIFc9RiouNSxLPUgqLjUsWj14Ki41O3JldHVybiBQWzRdPVcqdHQrSypRLVoqJCxQWzVdPUsqdHQrWipVLVcqUSxQWzZdPVoqdHQrVyokLUsqVSxQWzddPS1XKlUtSyokLVoqUSxQfWZ1bmN0aW9uIEUoVSwkLFEpe3ZhciB0dD1RWzBdKi41LEY9UVsxXSouNSxIPVFbMl0qLjUseD0kWzBdLFA9JFsxXSxXPSRbMl0sSz0kWzNdO3JldHVybiBVWzBdPXgsVVsxXT1QLFVbMl09VyxVWzNdPUssVVs0XT10dCpLK0YqVy1IKlAsVVs1XT1GKksrSCp4LXR0KlcsVVs2XT1IKksrdHQqUC1GKngsVVs3XT0tdHQqeC1GKlAtSCpXLFV9ZnVuY3Rpb24gcChVLCQpe3JldHVybiBVWzBdPTAsVVsxXT0wLFVbMl09MCxVWzNdPTEsVVs0XT0kWzBdKi41LFVbNV09JFsxXSouNSxVWzZdPSRbMl0qLjUsVVs3XT0wLFV9ZnVuY3Rpb24gTyhVLCQpe3JldHVybiBVWzBdPSRbMF0sVVsxXT0kWzFdLFVbMl09JFsyXSxVWzNdPSRbM10sVVs0XT0wLFVbNV09MCxVWzZdPTAsVVs3XT0wLFV9ZnVuY3Rpb24gbShVLCQpe3ZhciBRPWkuY3JlYXRlKCk7Zi5nZXRSb3RhdGlvbihRLCQpO3ZhciB0dD1uZXcgbi5BUlJBWV9UWVBFKDMpO3JldHVybiBmLmdldFRyYW5zbGF0aW9uKHR0LCQpLEUoVSxRLHR0KSxVfWZ1bmN0aW9uIGIoVSwkKXtyZXR1cm4gVVswXT0kWzBdLFVbMV09JFsxXSxVWzJdPSRbMl0sVVszXT0kWzNdLFVbNF09JFs0XSxVWzVdPSRbNV0sVVs2XT0kWzZdLFVbN109JFs3XSxVfWZ1bmN0aW9uIE0oVSl7cmV0dXJuIFVbMF09MCxVWzFdPTAsVVsyXT0wLFVbM109MSxVWzRdPTAsVVs1XT0wLFVbNl09MCxVWzddPTAsVX1mdW5jdGlvbiB5KFUsJCxRLHR0LEYsSCx4LFAsVyl7cmV0dXJuIFVbMF09JCxVWzFdPVEsVVsyXT10dCxVWzNdPUYsVVs0XT1ILFVbNV09eCxVWzZdPVAsVVs3XT1XLFV9dmFyIFM9aS5jb3B5O2Z1bmN0aW9uIHMoVSwkKXtyZXR1cm4gVVswXT0kWzRdLFVbMV09JFs1XSxVWzJdPSRbNl0sVVszXT0kWzddLFV9dmFyIGM9aS5jb3B5O2Z1bmN0aW9uIGwoVSwkKXtyZXR1cm4gVVs0XT0kWzBdLFVbNV09JFsxXSxVWzZdPSRbMl0sVVs3XT0kWzNdLFV9ZnVuY3Rpb24gdihVLCQpe3ZhciBRPSRbNF0sdHQ9JFs1XSxGPSRbNl0sSD0kWzddLHg9LSRbMF0sUD0tJFsxXSxXPS0kWzJdLEs9JFszXTtyZXR1cm4gVVswXT0oUSpLK0gqeCt0dCpXLUYqUCkqMixVWzFdPSh0dCpLK0gqUCtGKngtUSpXKSoyLFVbMl09KEYqSytIKlcrUSpQLXR0KngpKjIsVX1mdW5jdGlvbiBUKFUsJCxRKXt2YXIgdHQ9JFswXSxGPSRbMV0sSD0kWzJdLHg9JFszXSxQPVFbMF0qLjUsVz1RWzFdKi41LEs9UVsyXSouNSxaPSRbNF0saz0kWzVdLG50PSRbNl0sdXQ9JFs3XTtyZXR1cm4gVVswXT10dCxVWzFdPUYsVVsyXT1ILFVbM109eCxVWzRdPXgqUCtGKkstSCpXK1osVVs1XT14KlcrSCpQLXR0KksrayxVWzZdPXgqSyt0dCpXLUYqUCtudCxVWzddPS10dCpQLUYqVy1IKksrdXQsVX1mdW5jdGlvbiBSKFUsJCxRKXt2YXIgdHQ9LSRbMF0sRj0tJFsxXSxIPS0kWzJdLHg9JFszXSxQPSRbNF0sVz0kWzVdLEs9JFs2XSxaPSRbN10saz1QKngrWip0dCtXKkgtSypGLG50PVcqeCtaKkYrSyp0dC1QKkgsdXQ9Syp4K1oqSCtQKkYtVyp0dCxjdD1aKngtUCp0dC1XKkYtSypIO3JldHVybiBpLnJvdGF0ZVgoVSwkLFEpLHR0PVVbMF0sRj1VWzFdLEg9VVsyXSx4PVVbM10sVVs0XT1rKngrY3QqdHQrbnQqSC11dCpGLFVbNV09bnQqeCtjdCpGK3V0KnR0LWsqSCxVWzZdPXV0KngrY3QqSCtrKkYtbnQqdHQsVVs3XT1jdCp4LWsqdHQtbnQqRi11dCpILFV9ZnVuY3Rpb24gTChVLCQsUSl7dmFyIHR0PS0kWzBdLEY9LSRbMV0sSD0tJFsyXSx4PSRbM10sUD0kWzRdLFc9JFs1XSxLPSRbNl0sWj0kWzddLGs9UCp4K1oqdHQrVypILUsqRixudD1XKngrWipGK0sqdHQtUCpILHV0PUsqeCtaKkgrUCpGLVcqdHQsY3Q9Wip4LVAqdHQtVypGLUsqSDtyZXR1cm4gaS5yb3RhdGVZKFUsJCxRKSx0dD1VWzBdLEY9VVsxXSxIPVVbMl0seD1VWzNdLFVbNF09ayp4K2N0KnR0K250KkgtdXQqRixVWzVdPW50KngrY3QqRit1dCp0dC1rKkgsVVs2XT11dCp4K2N0KkgraypGLW50KnR0LFVbN109Y3QqeC1rKnR0LW50KkYtdXQqSCxVfWZ1bmN0aW9uIE4oVSwkLFEpe3ZhciB0dD0tJFswXSxGPS0kWzFdLEg9LSRbMl0seD0kWzNdLFA9JFs0XSxXPSRbNV0sSz0kWzZdLFo9JFs3XSxrPVAqeCtaKnR0K1cqSC1LKkYsbnQ9Vyp4K1oqRitLKnR0LVAqSCx1dD1LKngrWipIK1AqRi1XKnR0LGN0PVoqeC1QKnR0LVcqRi1LKkg7cmV0dXJuIGkucm90YXRlWihVLCQsUSksdHQ9VVswXSxGPVVbMV0sSD1VWzJdLHg9VVszXSxVWzRdPWsqeCtjdCp0dCtudCpILXV0KkYsVVs1XT1udCp4K2N0KkYrdXQqdHQtaypILFVbNl09dXQqeCtjdCpIK2sqRi1udCp0dCxVWzddPWN0Kngtayp0dC1udCpGLXV0KkgsVX1mdW5jdGlvbiBBKFUsJCxRKXt2YXIgdHQ9UVswXSxGPVFbMV0sSD1RWzJdLHg9UVszXSxQPSRbMF0sVz0kWzFdLEs9JFsyXSxaPSRbM107cmV0dXJuIFVbMF09UCp4K1oqdHQrVypILUsqRixVWzFdPVcqeCtaKkYrSyp0dC1QKkgsVVsyXT1LKngrWipIK1AqRi1XKnR0LFVbM109Wip4LVAqdHQtVypGLUsqSCxQPSRbNF0sVz0kWzVdLEs9JFs2XSxaPSRbN10sVVs0XT1QKngrWip0dCtXKkgtSypGLFVbNV09Vyp4K1oqRitLKnR0LVAqSCxVWzZdPUsqeCtaKkgrUCpGLVcqdHQsVVs3XT1aKngtUCp0dC1XKkYtSypILFV9ZnVuY3Rpb24gdyhVLCQsUSl7dmFyIHR0PSRbMF0sRj0kWzFdLEg9JFsyXSx4PSRbM10sUD1RWzBdLFc9UVsxXSxLPVFbMl0sWj1RWzNdO3JldHVybiBVWzBdPXR0KloreCpQK0YqSy1IKlcsVVsxXT1GKloreCpXK0gqUC10dCpLLFVbMl09SCpaK3gqSyt0dCpXLUYqUCxVWzNdPXgqWi10dCpQLUYqVy1IKkssUD1RWzRdLFc9UVs1XSxLPVFbNl0sWj1RWzddLFVbNF09dHQqWit4KlArRipLLUgqVyxVWzVdPUYqWit4KlcrSCpQLXR0KkssVVs2XT1IKloreCpLK3R0KlctRipQLFVbN109eCpaLXR0KlAtRipXLUgqSyxVfWZ1bmN0aW9uIEIoVSwkLFEsdHQpe2lmKE1hdGguYWJzKHR0KTxuLkVQU0lMT04pcmV0dXJuIGIoVSwkKTt2YXIgRj1NYXRoLmh5cG90KFFbMF0sUVsxXSxRWzJdKTt0dD10dCouNTt2YXIgSD1NYXRoLnNpbih0dCkseD1IKlFbMF0vRixQPUgqUVsxXS9GLFc9SCpRWzJdL0YsSz1NYXRoLmNvcyh0dCksWj0kWzBdLGs9JFsxXSxudD0kWzJdLHV0PSRbM107VVswXT1aKksrdXQqeCtrKlctbnQqUCxVWzFdPWsqSyt1dCpQK250KngtWipXLFVbMl09bnQqSyt1dCpXK1oqUC1rKngsVVszXT11dCpLLVoqeC1rKlAtbnQqVzt2YXIgY3Q9JFs0XSxwdD0kWzVdLHh0PSRbNl0sZ3Q9JFs3XTtyZXR1cm4gVVs0XT1jdCpLK2d0KngrcHQqVy14dCpQLFVbNV09cHQqSytndCpQK3h0KngtY3QqVyxVWzZdPXh0KksrZ3QqVytjdCpQLXB0KngsVVs3XT1ndCpLLWN0KngtcHQqUC14dCpXLFV9ZnVuY3Rpb24gRChVLCQsUSl7cmV0dXJuIFVbMF09JFswXStRWzBdLFVbMV09JFsxXStRWzFdLFVbMl09JFsyXStRWzJdLFVbM109JFszXStRWzNdLFVbNF09JFs0XStRWzRdLFVbNV09JFs1XStRWzVdLFVbNl09JFs2XStRWzZdLFVbN109JFs3XStRWzddLFV9ZnVuY3Rpb24gSShVLCQsUSl7dmFyIHR0PSRbMF0sRj0kWzFdLEg9JFsyXSx4PSRbM10sUD1RWzRdLFc9UVs1XSxLPVFbNl0sWj1RWzddLGs9JFs0XSxudD0kWzVdLHV0PSRbNl0sY3Q9JFs3XSxwdD1RWzBdLHh0PVFbMV0sZ3Q9UVsyXSxkdD1RWzNdO3JldHVybiBVWzBdPXR0KmR0K3gqcHQrRipndC1IKnh0LFVbMV09RipkdCt4Knh0K0gqcHQtdHQqZ3QsVVsyXT1IKmR0K3gqZ3QrdHQqeHQtRipwdCxVWzNdPXgqZHQtdHQqcHQtRip4dC1IKmd0LFVbNF09dHQqWit4KlArRipLLUgqVytrKmR0K2N0KnB0K250Kmd0LXV0Knh0LFVbNV09RipaK3gqVytIKlAtdHQqSytudCpkdCtjdCp4dCt1dCpwdC1rKmd0LFVbNl09SCpaK3gqSyt0dCpXLUYqUCt1dCpkdCtjdCpndCtrKnh0LW50KnB0LFVbN109eCpaLXR0KlAtRipXLUgqSytjdCpkdC1rKnB0LW50Knh0LXV0Kmd0LFV9dmFyIGo9STtmdW5jdGlvbiBWKFUsJCxRKXtyZXR1cm4gVVswXT0kWzBdKlEsVVsxXT0kWzFdKlEsVVsyXT0kWzJdKlEsVVszXT0kWzNdKlEsVVs0XT0kWzRdKlEsVVs1XT0kWzVdKlEsVVs2XT0kWzZdKlEsVVs3XT0kWzddKlEsVX12YXIgSj1pLmRvdDtmdW5jdGlvbiBfKFUsJCxRLHR0KXt2YXIgRj0xLXR0O3JldHVybiBKKCQsUSk8MCYmKHR0PS10dCksVVswXT0kWzBdKkYrUVswXSp0dCxVWzFdPSRbMV0qRitRWzFdKnR0LFVbMl09JFsyXSpGK1FbMl0qdHQsVVszXT0kWzNdKkYrUVszXSp0dCxVWzRdPSRbNF0qRitRWzRdKnR0LFVbNV09JFs1XSpGK1FbNV0qdHQsVVs2XT0kWzZdKkYrUVs2XSp0dCxVWzddPSRbN10qRitRWzddKnR0LFV9ZnVuY3Rpb24gc3QoVSwkKXt2YXIgUT1vdCgkKTtyZXR1cm4gVVswXT0tJFswXS9RLFVbMV09LSRbMV0vUSxVWzJdPS0kWzJdL1EsVVszXT0kWzNdL1EsVVs0XT0tJFs0XS9RLFVbNV09LSRbNV0vUSxVWzZdPS0kWzZdL1EsVVs3XT0kWzddL1EsVX1mdW5jdGlvbiBHKFUsJCl7cmV0dXJuIFVbMF09LSRbMF0sVVsxXT0tJFsxXSxVWzJdPS0kWzJdLFVbM109JFszXSxVWzRdPS0kWzRdLFVbNV09LSRbNV0sVVs2XT0tJFs2XSxVWzddPSRbN10sVX12YXIgWT1pLmxlbmd0aCxydD1ZLG90PWkuc3F1YXJlZExlbmd0aCxhdD1vdDtmdW5jdGlvbiBodChVLCQpe3ZhciBRPW90KCQpO2lmKFE+MCl7UT1NYXRoLnNxcnQoUSk7dmFyIHR0PSRbMF0vUSxGPSRbMV0vUSxIPSRbMl0vUSx4PSRbM10vUSxQPSRbNF0sVz0kWzVdLEs9JFs2XSxaPSRbN10saz10dCpQK0YqVytIKksreCpaO1VbMF09dHQsVVsxXT1GLFVbMl09SCxVWzNdPXgsVVs0XT0oUC10dCprKS9RLFVbNV09KFctRiprKS9RLFVbNl09KEstSCprKS9RLFVbN109KFoteCprKS9RfXJldHVybiBVfWZ1bmN0aW9uIGl0KFUpe3JldHVybiJxdWF0MigiK1VbMF0rIiwgIitVWzFdKyIsICIrVVsyXSsiLCAiK1VbM10rIiwgIitVWzRdKyIsICIrVVs1XSsiLCAiK1VbNl0rIiwgIitVWzddKyIpIn1mdW5jdGlvbiBNdChVLCQpe3JldHVybiBVWzBdPT09JFswXSYmVVsxXT09PSRbMV0mJlVbMl09PT0kWzJdJiZVWzNdPT09JFszXSYmVVs0XT09PSRbNF0mJlVbNV09PT0kWzVdJiZVWzZdPT09JFs2XSYmVVs3XT09PSRbN119ZnVuY3Rpb24gT3QoVSwkKXt2YXIgUT1VWzBdLHR0PVVbMV0sRj1VWzJdLEg9VVszXSx4PVVbNF0sUD1VWzVdLFc9VVs2XSxLPVVbN10sWj0kWzBdLGs9JFsxXSxudD0kWzJdLHV0PSRbM10sY3Q9JFs0XSxwdD0kWzVdLHh0PSRbNl0sZ3Q9JFs3XTtyZXR1cm4gTWF0aC5hYnMoUS1aKTw9bi5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoUSksTWF0aC5hYnMoWikpJiZNYXRoLmFicyh0dC1rKTw9bi5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnModHQpLE1hdGguYWJzKGspKSYmTWF0aC5hYnMoRi1udCk8PW4uRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKEYpLE1hdGguYWJzKG50KSkmJk1hdGguYWJzKEgtdXQpPD1uLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhIKSxNYXRoLmFicyh1dCkpJiZNYXRoLmFicyh4LWN0KTw9bi5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoeCksTWF0aC5hYnMoY3QpKSYmTWF0aC5hYnMoUC1wdCk8PW4uRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKFApLE1hdGguYWJzKHB0KSkmJk1hdGguYWJzKFcteHQpPD1uLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhXKSxNYXRoLmFicyh4dCkpJiZNYXRoLmFicyhLLWd0KTw9bi5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoSyksTWF0aC5hYnMoZ3QpKX19LGZ1bmN0aW9uKGcsZSx0KXt0LnIoZSksdC5kKGUsImNyZWF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gaX0pLHQuZChlLCJjbG9uZSIsZnVuY3Rpb24oKXtyZXR1cm4gZn0pLHQuZChlLCJmcm9tVmFsdWVzIixmdW5jdGlvbigpe3JldHVybiBofSksdC5kKGUsImNvcHkiLGZ1bmN0aW9uKCl7cmV0dXJuIHV9KSx0LmQoZSwic2V0IixmdW5jdGlvbigpe3JldHVybiBhfSksdC5kKGUsImFkZCIsZnVuY3Rpb24oKXtyZXR1cm4gZH0pLHQuZChlLCJzdWJ0cmFjdCIsZnVuY3Rpb24oKXtyZXR1cm4gRX0pLHQuZChlLCJtdWx0aXBseSIsZnVuY3Rpb24oKXtyZXR1cm4gcH0pLHQuZChlLCJkaXZpZGUiLGZ1bmN0aW9uKCl7cmV0dXJuIE99KSx0LmQoZSwiY2VpbCIsZnVuY3Rpb24oKXtyZXR1cm4gbX0pLHQuZChlLCJmbG9vciIsZnVuY3Rpb24oKXtyZXR1cm4gYn0pLHQuZChlLCJtaW4iLGZ1bmN0aW9uKCl7cmV0dXJuIE19KSx0LmQoZSwibWF4IixmdW5jdGlvbigpe3JldHVybiB5fSksdC5kKGUsInJvdW5kIixmdW5jdGlvbigpe3JldHVybiBTfSksdC5kKGUsInNjYWxlIixmdW5jdGlvbigpe3JldHVybiBzfSksdC5kKGUsInNjYWxlQW5kQWRkIixmdW5jdGlvbigpe3JldHVybiBjfSksdC5kKGUsImRpc3RhbmNlIixmdW5jdGlvbigpe3JldHVybiBsfSksdC5kKGUsInNxdWFyZWREaXN0YW5jZSIsZnVuY3Rpb24oKXtyZXR1cm4gdn0pLHQuZChlLCJsZW5ndGgiLGZ1bmN0aW9uKCl7cmV0dXJuIFR9KSx0LmQoZSwic3F1YXJlZExlbmd0aCIsZnVuY3Rpb24oKXtyZXR1cm4gUn0pLHQuZChlLCJuZWdhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIEx9KSx0LmQoZSwiaW52ZXJzZSIsZnVuY3Rpb24oKXtyZXR1cm4gTn0pLHQuZChlLCJub3JtYWxpemUiLGZ1bmN0aW9uKCl7cmV0dXJuIEF9KSx0LmQoZSwiZG90IixmdW5jdGlvbigpe3JldHVybiB3fSksdC5kKGUsImNyb3NzIixmdW5jdGlvbigpe3JldHVybiBCfSksdC5kKGUsImxlcnAiLGZ1bmN0aW9uKCl7cmV0dXJuIER9KSx0LmQoZSwicmFuZG9tIixmdW5jdGlvbigpe3JldHVybiBJfSksdC5kKGUsInRyYW5zZm9ybU1hdDIiLGZ1bmN0aW9uKCl7cmV0dXJuIGp9KSx0LmQoZSwidHJhbnNmb3JtTWF0MmQiLGZ1bmN0aW9uKCl7cmV0dXJuIFZ9KSx0LmQoZSwidHJhbnNmb3JtTWF0MyIsZnVuY3Rpb24oKXtyZXR1cm4gSn0pLHQuZChlLCJ0cmFuc2Zvcm1NYXQ0IixmdW5jdGlvbigpe3JldHVybiBffSksdC5kKGUsInJvdGF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gc3R9KSx0LmQoZSwiYW5nbGUiLGZ1bmN0aW9uKCl7cmV0dXJuIEd9KSx0LmQoZSwiemVybyIsZnVuY3Rpb24oKXtyZXR1cm4gWX0pLHQuZChlLCJzdHIiLGZ1bmN0aW9uKCl7cmV0dXJuIHJ0fSksdC5kKGUsImV4YWN0RXF1YWxzIixmdW5jdGlvbigpe3JldHVybiBvdH0pLHQuZChlLCJlcXVhbHMiLGZ1bmN0aW9uKCl7cmV0dXJuIGF0fSksdC5kKGUsImxlbiIsZnVuY3Rpb24oKXtyZXR1cm4gaHR9KSx0LmQoZSwic3ViIixmdW5jdGlvbigpe3JldHVybiBpdH0pLHQuZChlLCJtdWwiLGZ1bmN0aW9uKCl7cmV0dXJuIE10fSksdC5kKGUsImRpdiIsZnVuY3Rpb24oKXtyZXR1cm4gT3R9KSx0LmQoZSwiZGlzdCIsZnVuY3Rpb24oKXtyZXR1cm4gVX0pLHQuZChlLCJzcXJEaXN0IixmdW5jdGlvbigpe3JldHVybiAkfSksdC5kKGUsInNxckxlbiIsZnVuY3Rpb24oKXtyZXR1cm4gUX0pLHQuZChlLCJmb3JFYWNoIixmdW5jdGlvbigpe3JldHVybiB0dH0pO3ZhciBuPXQoMik7ZnVuY3Rpb24gaSgpe3ZhciBGPW5ldyBuLkFSUkFZX1RZUEUoMik7cmV0dXJuIG4uQVJSQVlfVFlQRSE9RmxvYXQzMkFycmF5JiYoRlswXT0wLEZbMV09MCksRn1mdW5jdGlvbiBmKEYpe3ZhciBIPW5ldyBuLkFSUkFZX1RZUEUoMik7cmV0dXJuIEhbMF09RlswXSxIWzFdPUZbMV0sSH1mdW5jdGlvbiBoKEYsSCl7dmFyIHg9bmV3IG4uQVJSQVlfVFlQRSgyKTtyZXR1cm4geFswXT1GLHhbMV09SCx4fWZ1bmN0aW9uIHUoRixIKXtyZXR1cm4gRlswXT1IWzBdLEZbMV09SFsxXSxGfWZ1bmN0aW9uIGEoRixILHgpe3JldHVybiBGWzBdPUgsRlsxXT14LEZ9ZnVuY3Rpb24gZChGLEgseCl7cmV0dXJuIEZbMF09SFswXSt4WzBdLEZbMV09SFsxXSt4WzFdLEZ9ZnVuY3Rpb24gRShGLEgseCl7cmV0dXJuIEZbMF09SFswXS14WzBdLEZbMV09SFsxXS14WzFdLEZ9ZnVuY3Rpb24gcChGLEgseCl7cmV0dXJuIEZbMF09SFswXSp4WzBdLEZbMV09SFsxXSp4WzFdLEZ9ZnVuY3Rpb24gTyhGLEgseCl7cmV0dXJuIEZbMF09SFswXS94WzBdLEZbMV09SFsxXS94WzFdLEZ9ZnVuY3Rpb24gbShGLEgpe3JldHVybiBGWzBdPU1hdGguY2VpbChIWzBdKSxGWzFdPU1hdGguY2VpbChIWzFdKSxGfWZ1bmN0aW9uIGIoRixIKXtyZXR1cm4gRlswXT1NYXRoLmZsb29yKEhbMF0pLEZbMV09TWF0aC5mbG9vcihIWzFdKSxGfWZ1bmN0aW9uIE0oRixILHgpe3JldHVybiBGWzBdPU1hdGgubWluKEhbMF0seFswXSksRlsxXT1NYXRoLm1pbihIWzFdLHhbMV0pLEZ9ZnVuY3Rpb24geShGLEgseCl7cmV0dXJuIEZbMF09TWF0aC5tYXgoSFswXSx4WzBdKSxGWzFdPU1hdGgubWF4KEhbMV0seFsxXSksRn1mdW5jdGlvbiBTKEYsSCl7cmV0dXJuIEZbMF09TWF0aC5yb3VuZChIWzBdKSxGWzFdPU1hdGgucm91bmQoSFsxXSksRn1mdW5jdGlvbiBzKEYsSCx4KXtyZXR1cm4gRlswXT1IWzBdKngsRlsxXT1IWzFdKngsRn1mdW5jdGlvbiBjKEYsSCx4LFApe3JldHVybiBGWzBdPUhbMF0reFswXSpQLEZbMV09SFsxXSt4WzFdKlAsRn1mdW5jdGlvbiBsKEYsSCl7dmFyIHg9SFswXS1GWzBdLFA9SFsxXS1GWzFdO3JldHVybiBNYXRoLmh5cG90KHgsUCl9ZnVuY3Rpb24gdihGLEgpe3ZhciB4PUhbMF0tRlswXSxQPUhbMV0tRlsxXTtyZXR1cm4geCp4K1AqUH1mdW5jdGlvbiBUKEYpe3ZhciBIPUZbMF0seD1GWzFdO3JldHVybiBNYXRoLmh5cG90KEgseCl9ZnVuY3Rpb24gUihGKXt2YXIgSD1GWzBdLHg9RlsxXTtyZXR1cm4gSCpIK3gqeH1mdW5jdGlvbiBMKEYsSCl7cmV0dXJuIEZbMF09LUhbMF0sRlsxXT0tSFsxXSxGfWZ1bmN0aW9uIE4oRixIKXtyZXR1cm4gRlswXT0xL0hbMF0sRlsxXT0xL0hbMV0sRn1mdW5jdGlvbiBBKEYsSCl7dmFyIHg9SFswXSxQPUhbMV0sVz14KngrUCpQO3JldHVybiBXPjAmJihXPTEvTWF0aC5zcXJ0KFcpKSxGWzBdPUhbMF0qVyxGWzFdPUhbMV0qVyxGfWZ1bmN0aW9uIHcoRixIKXtyZXR1cm4gRlswXSpIWzBdK0ZbMV0qSFsxXX1mdW5jdGlvbiBCKEYsSCx4KXt2YXIgUD1IWzBdKnhbMV0tSFsxXSp4WzBdO3JldHVybiBGWzBdPUZbMV09MCxGWzJdPVAsRn1mdW5jdGlvbiBEKEYsSCx4LFApe3ZhciBXPUhbMF0sSz1IWzFdO3JldHVybiBGWzBdPVcrUCooeFswXS1XKSxGWzFdPUsrUCooeFsxXS1LKSxGfWZ1bmN0aW9uIEkoRixIKXtIPUh8fDE7dmFyIHg9bi5SQU5ET00oKSoyKk1hdGguUEk7cmV0dXJuIEZbMF09TWF0aC5jb3MoeCkqSCxGWzFdPU1hdGguc2luKHgpKkgsRn1mdW5jdGlvbiBqKEYsSCx4KXt2YXIgUD1IWzBdLFc9SFsxXTtyZXR1cm4gRlswXT14WzBdKlAreFsyXSpXLEZbMV09eFsxXSpQK3hbM10qVyxGfWZ1bmN0aW9uIFYoRixILHgpe3ZhciBQPUhbMF0sVz1IWzFdO3JldHVybiBGWzBdPXhbMF0qUCt4WzJdKlcreFs0XSxGWzFdPXhbMV0qUCt4WzNdKlcreFs1XSxGfWZ1bmN0aW9uIEooRixILHgpe3ZhciBQPUhbMF0sVz1IWzFdO3JldHVybiBGWzBdPXhbMF0qUCt4WzNdKlcreFs2XSxGWzFdPXhbMV0qUCt4WzRdKlcreFs3XSxGfWZ1bmN0aW9uIF8oRixILHgpe3ZhciBQPUhbMF0sVz1IWzFdO3JldHVybiBGWzBdPXhbMF0qUCt4WzRdKlcreFsxMl0sRlsxXT14WzFdKlAreFs1XSpXK3hbMTNdLEZ9ZnVuY3Rpb24gc3QoRixILHgsUCl7dmFyIFc9SFswXS14WzBdLEs9SFsxXS14WzFdLFo9TWF0aC5zaW4oUCksaz1NYXRoLmNvcyhQKTtyZXR1cm4gRlswXT1XKmstSypaK3hbMF0sRlsxXT1XKlorSyprK3hbMV0sRn1mdW5jdGlvbiBHKEYsSCl7dmFyIHg9RlswXSxQPUZbMV0sVz1IWzBdLEs9SFsxXSxaPU1hdGguc3FydCh4KngrUCpQKSpNYXRoLnNxcnQoVypXK0sqSyksaz1aJiYoeCpXK1AqSykvWjtyZXR1cm4gTWF0aC5hY29zKE1hdGgubWluKE1hdGgubWF4KGssLTEpLDEpKX1mdW5jdGlvbiBZKEYpe3JldHVybiBGWzBdPTAsRlsxXT0wLEZ9ZnVuY3Rpb24gcnQoRil7cmV0dXJuInZlYzIoIitGWzBdKyIsICIrRlsxXSsiKSJ9ZnVuY3Rpb24gb3QoRixIKXtyZXR1cm4gRlswXT09PUhbMF0mJkZbMV09PT1IWzFdfWZ1bmN0aW9uIGF0KEYsSCl7dmFyIHg9RlswXSxQPUZbMV0sVz1IWzBdLEs9SFsxXTtyZXR1cm4gTWF0aC5hYnMoeC1XKTw9bi5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoeCksTWF0aC5hYnMoVykpJiZNYXRoLmFicyhQLUspPD1uLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhQKSxNYXRoLmFicyhLKSl9dmFyIGh0PVQsaXQ9RSxNdD1wLE90PU8sVT1sLCQ9dixRPVIsdHQ9ZnVuY3Rpb24oKXt2YXIgRj1pKCk7cmV0dXJuIGZ1bmN0aW9uKEgseCxQLFcsSyxaKXt2YXIgayxudDtmb3IoeHx8KHg9MiksUHx8KFA9MCksVz9udD1NYXRoLm1pbihXKngrUCxILmxlbmd0aCk6bnQ9SC5sZW5ndGgsaz1QO2s8bnQ7ays9eClGWzBdPUhba10sRlsxXT1IW2srMV0sSyhGLEYsWiksSFtrXT1GWzBdLEhbaysxXT1GWzFdO3JldHVybiBIfX0oKX0sZnVuY3Rpb24oZyxlLHQpe3QucihlKTt2YXIgbj10KDEzKTt0LmQoZSwiUmVuZGVyZXIiLGZ1bmN0aW9uKCl7cmV0dXJuIG4uZGVmYXVsdH0pO3ZhciBpPXQoNDApO3QuZChlLCJGaWd1cmUyRCIsZnVuY3Rpb24oKXtyZXR1cm4gaS5kZWZhdWx0fSk7dmFyIGY9dCg1Nik7dC5kKGUsIk1lc2gyRCIsZnVuY3Rpb24oKXtyZXR1cm4gZi5kZWZhdWx0fSk7dmFyIGg9dCgyOSk7dC5kKGUsIk1lc2hDbG91ZCIsZnVuY3Rpb24oKXtyZXR1cm4gaC5kZWZhdWx0fSk7dmFyIHU9dCgyMyk7dC5kKGUsInBhcnNlRm9udCIsZnVuY3Rpb24oKXtyZXR1cm4gdS5kZWZhdWx0fSk7dmFyIGE9dCgzMSk7dC5kKGUsInBhcnNlQ29sb3IiLGZ1bmN0aW9uKCl7cmV0dXJuIGEuZGVmYXVsdH0pO3ZhciBkPXQoMjEpO3QuZChlLCJFTlYiLGZ1bmN0aW9uKCl7cmV0dXJuIGQuZGVmYXVsdH0pLHQoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KX0sZnVuY3Rpb24oZyxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gTn0pO3ZhciBuPXQoMTQpLGk9dCgxKSxmPXQoMjApLGg9dCgyNyksdT10KDI1KSxhPXQoNDApLGQ9dCg1NiksRT10KDI5KSxwPXQoNTkpLE89dCgyMSksbT10KDYzKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3QgYj17YXV0b1VwZGF0ZTohMSxwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6ITEsYnVmZmVyU2l6ZToxNTAwfSxNPWBhdHRyaWJ1dGUgdmVjMyBhX3ZlcnRleFBvc2l0aW9uOwphdHRyaWJ1dGUgdmVjMyBhX3ZlcnRleFRleHR1cmVDb29yZDsKdmFyeWluZyB2ZWMzIHZUZXh0dXJlQ29vcmQ7CnVuaWZvcm0gbWF0MyB2aWV3TWF0cml4Owp1bmlmb3JtIG1hdDMgcHJvamVjdGlvbk1hdHJpeDsKCnZvaWQgbWFpbigpIHsKICBnbF9Qb2ludFNpemUgPSAxLjA7CiAgdmVjMyBwb3MgPSBwcm9qZWN0aW9uTWF0cml4ICogdmlld01hdHJpeCAqIHZlYzMoYV92ZXJ0ZXhQb3NpdGlvbi54eSwgMS4wKTsKICBnbF9Qb3NpdGlvbiA9IHZlYzQocG9zLnh5LCAxLjAsIDEuMCk7ICAgIAogIHZUZXh0dXJlQ29vcmQgPSBhX3ZlcnRleFRleHR1cmVDb29yZDsgICAgICAgICAgICAgIAp9CmAseT1gcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7CnZhcnlpbmcgdmVjMyB2VGV4dHVyZUNvb3JkOwp1bmlmb3JtIHNhbXBsZXIyRCB1X3RleFNhbXBsZXI7CnZvaWQgbWFpbigpIHsKICBnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQodV90ZXhTYW1wbGVyLCB2VGV4dHVyZUNvb3JkLnh5KTsKfQpgLFM9U3ltYm9sKCJnbFJlbmRlcmVyIikscz1TeW1ib2woImNhbnZhc1JlbmRlcmVyIiksYz1TeW1ib2woIm9wdGlvbnMiKSxsPVN5bWJvbCgiZ2xvYmFsVHJhbnNmb3JtIiksdj1TeW1ib2woImFwcGx5R2xvYmFsVHJhbnNmb3JtIiksVD1TeW1ib2woImNhbnZhcyIpO2Z1bmN0aW9uIFIoQSl7Y29uc3Qgdz1BLmdsLEI9QS5mYm87QiYmdy5iaW5kRnJhbWVidWZmZXIody5GUkFNRUJVRkZFUixCKSxBLl9kcmF3KCksQiYmdy5iaW5kRnJhbWVidWZmZXIody5GUkFNRUJVRkZFUixudWxsKX1mdW5jdGlvbiBMKEEsdyxCLEQpe2NvbnN0IEk9QS5jcmVhdGVUZXh0dXJlKHcuY2FudmFzKSxqPVtbWzAsMF0sW0IsMF0sW0IsRF0sWzAsRF0sWzAsMF1dXTtqLmNsb3NlZD0hMDtjb25zdCBWPW5ldyBkLmRlZmF1bHQoe2NvbnRvdXJzOmp9KTtWLnNldFRleHR1cmUoSSksQS5zZXRNZXNoRGF0YShbVi5tZXNoRGF0YV0pLFIoQSksSS5kZWxldGUoKSx3LmNsZWFyUmVjdCgwLDAsQixEKSxkZWxldGUgdy5fZmlsdGVyfWNsYXNzIE57Y29uc3RydWN0b3IodyxCPXt9KXtsZXQgRD1CLmNvbnRleHRUeXBlO2lmKER8fCh0eXBlb2YgV2ViR0wyUmVuZGVyaW5nQ29udGV4dD09ImZ1bmN0aW9uIj9EPSJ3ZWJnbDIiOnR5cGVvZiBXZWJHTFJlbmRlcmluZ0NvbnRleHQ9PSJmdW5jdGlvbiI/RD0id2ViZ2wiOkQ9IjJkIiksIXcuZ2V0Q29udGV4dCl7Y29uc3QgST13O3c9e2dldENvbnRleHQoKXtyZXR1cm4gSX0sd2lkdGg6Qi53aWR0aCxoZWlnaHQ6Qi5oZWlnaHR9LEkuY2FudmFzPXcsRD0iMmQifWlmKHRoaXNbVF09dyxEIT09IndlYmdsIiYmRCE9PSJ3ZWJnbDIiJiZEIT09IjJkIil0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gY29udGV4dCB0eXBlICR7RH1gKTtpZihCLmNvbnRleHRUeXBlPUQsdGhpc1tjXT1PYmplY3QuYXNzaWduKHt9LGIsQiksRD09PSJ3ZWJnbCJ8fEQ9PT0id2ViZ2wyIil7RD09PSJ3ZWJnbDIiJiYodGhpc1tjXS53ZWJnbDI9ITApO2NvbnN0IEk9bmV3IG4uZGVmYXVsdCh3LHRoaXNbY10pO0Q9PT0id2ViZ2wyIiYmIUkuaXNXZWJHTDImJihCLmNvbnRleHRUeXBlPSJ3ZWJnbCIpLE9iamVjdChtLmNyZWF0ZVNoYWRlcnMpKEkpLE9iamVjdChtLmFwcGx5U2hhZGVyKShJKSxPYmplY3QobS5jcmVhdGVDbG91ZFNoYWRlcnMpKEkpO2NvbnN0IGo9SS5nbDtqLmNsZWFyQ29sb3IoMCwwLDAsMCksai5ibGVuZEZ1bmNTZXBhcmF0ZShqLlNSQ19BTFBIQSxqLk9ORV9NSU5VU19TUkNfQUxQSEEsai5PTkUsai5PTkVfTUlOVVNfU1JDX0FMUEhBKSx0aGlzW1NdPUl9ZWxzZSB0aGlzW3NdPW5ldyBmLmRlZmF1bHQodyx0aGlzW2NdKTt0aGlzW2xdPVsxLDAsMCwwLDEsMCwwLDAsMV0sdGhpcy51cGRhdGVSZXNvbHV0aW9uKCl9Z2V0IGNhbnZhcygpe3JldHVybiB0aGlzW1RdfWdldCBjYW52YXNSZW5kZXJlcigpe3JldHVybiB0aGlzW3NdfWdldCBnbFJlbmRlcmVyKCl7cmV0dXJuIHRoaXNbU119Z2V0IGlzV2ViR0wyKCl7cmV0dXJuIHRoaXNbU10mJnRoaXNbU10uaXNXZWJHTDJ9Z2V0IG9wdGlvbnMoKXtyZXR1cm4gdGhpc1tjXX1nZXQgZ2xvYmFsVHJhbnNmb3JtTWF0cml4KCl7Y29uc3Qgdz10aGlzW2xdO3JldHVyblt3WzBdLHdbMV0sd1szXSx3WzRdLHdbNl0sd1s3XV19Z2V0IHZpZXdNYXRyaXgoKXtyZXR1cm4gdGhpc1tsXX1bdl0oKXtjb25zdCB3PXRoaXNbU118fHRoaXNbc107aWYodGhpc1tTXSl7Y29uc3R7d2lkdGg6QixoZWlnaHQ6RH09dGhpcy5jYW52YXM7dy51bmlmb3Jtcy52aWV3TWF0cml4PXRoaXMudmlld01hdHJpeCx3LnVuaWZvcm1zLnByb2plY3Rpb25NYXRyaXg9dGhpcy5wcm9qZWN0aW9uTWF0cml4LHcudW5pZm9ybXMudV9yZXNvbHV0aW9uPVtCLERdfX11cGRhdGVSZXNvbHV0aW9uKCl7Y29uc3R7d2lkdGg6dyxoZWlnaHQ6Qn09dGhpcy5jYW52YXMsRD1bMSwwLDAsMCwxLDAsLXcvMiwtQi8yLDFdLEk9WzIvdywwLDAsMCwtMi9CLDAsMCwwLDFdLGo9aS5tYXQzLm11bHRpcGx5KEFycmF5Lm9mKDAsMCwwLDAsMCwwLDAsMCwwKSxJLEQpO3RoaXMucHJvamVjdGlvbk1hdHJpeD1qLHRoaXNbU10mJnRoaXNbU10uZ2wudmlld3BvcnQoMCwwLHcsQil9Y3JlYXRlVGV4dHVyZSh3LEIpe3JldHVybih0aGlzW1NdfHx0aGlzW3NdKS5jcmVhdGVUZXh0dXJlKHcsQil9bG9hZFRleHR1cmUodyx7dXNlSW1hZ2VCaXRtYXA6Qj0hMX09e30pe3JldHVybih0aGlzW1NdfHx0aGlzW3NdKS5sb2FkVGV4dHVyZSh3LHt1c2VJbWFnZUJpdG1hcDpCfSl9Y3JlYXRlVGV4dCh3LHtmb250OkI9IjE2cHggYXJpYWwiLGZpbGxDb2xvcjpEPW51bGwsc3Ryb2tlQ29sb3I6ST1udWxsLHN0cm9rZVdpZHRoOmo9MX09e30pe2lmKHRoaXNbU10pe2NvbnN0IFY9Ty5kZWZhdWx0LmNyZWF0ZVRleHQodyx7Zm9udDpCLGZpbGxDb2xvcjpELHN0cm9rZUNvbG9yOkksc3Ryb2tlV2lkdGg6an0pO3JldHVybntpbWFnZTp0aGlzLmNyZWF0ZVRleHR1cmUoVi5pbWFnZSkscmVjdDpWLnJlY3R9fXJldHVybntfaW1nOntmb250OkIsZmlsbENvbG9yOkQsc3Ryb2tlQ29sb3I6SSxzdHJva2VXaWR0aDpqLHRleHQ6d319fWNyZWF0ZVByb2dyYW0oe3ZlcnRleDp3LGZyYWdtZW50OkIsb3B0aW9uczpEfT17fSl7aWYodGhpc1tTXSl7Y29uc3QgST10aGlzW1NdLmNvbXBpbGVTeW5jKEIsdyk7cmV0dXJuIEkuX2F0dHJpYk9wdHM9RCxJfXRocm93IG5ldyBFcnJvcigiQ29udGV4dCAyRCBjYW5ub3QgY3JlYXRlIHdlYmdsIHByb2dyYW0uIil9Y3JlYXRlUGFzc1Byb2dyYW0oe3ZlcnRleDp3PU0sZnJhZ21lbnQ6Qj15LG9wdGlvbnM6RH09e30pe3JldHVybiB0aGlzLmNyZWF0ZVByb2dyYW0oe3ZlcnRleDp3LGZyYWdtZW50OkIsb3B0aW9uczpEfSl9dXNlUHJvZ3JhbSh3LEI9e30pe2lmKHRoaXNbU10pe2NvbnN0IEQ9T2JqZWN0LmFzc2lnbih7fSx3Ll9hdHRyaWJPcHRzLEIpO3JldHVybiB0aGlzW1NdLnVzZVByb2dyYW0odyxEKX10aHJvdyBuZXcgRXJyb3IoIkNvbnRleHQgMkQgY2Fubm90IHVzZSB3ZWJnbCBwcm9ncmFtLiIpfWRlbGV0ZVRleHR1cmUodyl7cmV0dXJuKHRoaXNbU118fHRoaXNbc10pLmRlbGV0ZVRleHR1cmUodyl9Y2xlYXIoLi4udyl7aWYodGhpc1tTXSl7Y29uc3QgQj10aGlzW1NdLmdsO0IuY2xlYXIoQi5DT0xPUl9CVUZGRVJfQklUKX1lbHNlIHRoaXNbc10uY2xlYXIoLi4udyl9ZHJhd01lc2hDbG91ZCh3LHtjbGVhcjpCPSExLHByb2dyYW06RD1udWxsfT17fSl7Y29uc3QgST10aGlzW1NdfHx0aGlzW3NdLGo9RHx8dy5wcm9ncmFtO2lmKHRoaXNbU10pe2NvbnN0IFY9SS5nbDtpZihCJiZWLmNsZWFyKFYuQ09MT1JfQlVGRkVSX0JJVCksailJLnByb2dyYW0hPT1qJiZ0aGlzLnVzZVByb2dyYW0oaix7YV9jb2xvcjp7dHlwZToiVU5TSUdORURfQllURSIsbm9ybWFsaXplOiEwfSxhX2ZpbGxDbG91ZENvbG9yOnt0eXBlOiJVTlNJR05FRF9CWVRFIixub3JtYWxpemU6ITB9LGFfc3Ryb2tlQ2xvdWRDb2xvcjp7dHlwZToiVU5TSUdORURfQllURSIsbm9ybWFsaXplOiEwfSxhX2ZyYW1lSW5kZXg6e3R5cGU6IlVOU0lHTkVEX0JZVEUiLG5vcm1hbGl6ZTohMX19KTtlbHNle2NvbnN0IEo9dy5tZXNoLm1lc2hEYXRhLF89ISFKLnVuaWZvcm1zLnVfdGV4U2FtcGxlcixzdD0hIUoudW5pZm9ybXMudV9maWx0ZXJGbGFnLEc9ISFKLnVuaWZvcm1zLnVfcmFkaWFsR3JhZGllbnRWZWN0b3IsWT13Lmhhc0Nsb3VkQ29sb3IscnQ9dy5oYXNDbG91ZEZpbHRlcixvdD0hIUoudW5pZm9ybXMudV9jbGlwU2FtcGxlcjtPYmplY3QobS5hcHBseUNsb3VkU2hhZGVyKShJLHtoYXNUZXh0dXJlOl8saGFzRmlsdGVyOnN0LGhhc0dyYWRpZW50OkcsaGFzQ2xvdWRDb2xvcjpZLGhhc0Nsb3VkRmlsdGVyOnJ0LGhhc0NsaXBQYXRoOm90fSl9dGhpc1t2XSgpLEkuc2V0TWVzaERhdGEoW3cubWVzaERhdGFdKSx3LmJlZm9yZVJlbmRlciYmdy5iZWZvcmVSZW5kZXIoVix3KSxSKEkpLHcuYWZ0ZXJSZW5kZXImJncuYWZ0ZXJSZW5kZXIoVix3KX1lbHNlIEkuc2V0VHJhbnNmb3JtKHRoaXMuZ2xvYmFsVHJhbnNmb3JtTWF0cml4KSxJLmRyYXdNZXNoQ2xvdWQodyx7Y2xlYXI6Qixob29rOiExfSl9ZHJhd01lc2hlcyh3LHtjbGVhcjpCPSExLHByb2dyYW06RD1udWxsfT17fSl7Y29uc3QgST10aGlzW1NdfHx0aGlzW3NdO2lmKHRoaXNbU10pe2NvbnN0IGo9SS5mYm8sVj1PYmplY3QoaC5kZWZhdWx0KSh0aGlzLHcsRD09bnVsbCksSj1JLmdsO0ImJkouY2xlYXIoSi5DT0xPUl9CVUZGRVJfQklUKTtjb25zdCBfPSFPYmplY3QocC5pc1VuaXRUcmFuc2Zvcm0pKHRoaXMuZ2xvYmFsVHJhbnNmb3JtTWF0cml4KTt0aGlzLl9kcmF3Q2FsbHM9MDtmb3IoY29uc3Qgc3Qgb2YgVil7dGhpcy5fZHJhd0NhbGxzKys7Y29uc3QgRz1EfHxzdC5wcm9ncmFtO2lmKHN0IGluc3RhbmNlb2YgRS5kZWZhdWx0KXRoaXMuZHJhd01lc2hDbG91ZChzdCx7Y2xlYXI6Qixwcm9ncmFtOkd9KTtlbHNle2NvbnN0e3dpZHRoOlksaGVpZ2h0OnJ0fT10aGlzLmNhbnZhcztpZihzdC5iZWZvcmVSZW5kZXImJnN0LmJlZm9yZVJlbmRlcihKLHN0KSxzdC5wYXNzLmxlbmd0aCYmKCghdGhpcy5mYm98fHRoaXMuZmJvLndpZHRoIT09WXx8dGhpcy5mYm8uaGVpZ2h0IT09cnQpJiYodGhpcy5mYm89e3dpZHRoOlksaGVpZ2h0OnJ0LHRhcmdldDpJLmNyZWF0ZUZCTygpLGJ1ZmZlcjpJLmNyZWF0ZUZCTygpLHN3YXAoKXtbdGhpcy50YXJnZXQsdGhpcy5idWZmZXJdPVt0aGlzLmJ1ZmZlcix0aGlzLnRhcmdldF19fSksSS5iaW5kRkJPKHRoaXMuZmJvLnRhcmdldCkpLCFHJiZzdC5maWx0ZXJDYW52YXMpe09iamVjdChtLmFwcGx5U2hhZGVyKShJLHtoYXNUZXh0dXJlOiEwfSk7bGV0IG90PXRoaXMuZmlsdGVyQ29udGV4dDtvdHx8KG90PU8uZGVmYXVsdC5jcmVhdGVDYW52YXMoWSxydCkuZ2V0Q29udGV4dCgiMmQiKSx0aGlzLmZpbHRlckNvbnRleHQ9b3QpO2NvbnN0IGF0PXdbc3QucGFja0luZGV4XSxodD1hdC5maWx0ZXIsaXQ9d1tzdC5wYWNrSW5kZXgrMV0sTXQ9d1tzdC5wYWNrSW5kZXgtMV07KCFNdHx8IU10LmZpbHRlckNhbnZhc3x8TXQuZmlsdGVyIT09aHQpJiYoIWl0fHwhaXQuZmlsdGVyQ2FudmFzfHxpdC5maWx0ZXIhPT1odCk/KF8/KG90LnNhdmUoKSxPYmplY3QodS5kcmF3TWVzaDJEKShhdCxvdCwhMSksb3QucmVzdG9yZSgpLE9iamVjdCh1LmFwcGx5RmlsdGVyKShvdCxodCkpOk9iamVjdCh1LmRyYXdNZXNoMkQpKGF0LG90LCEwKSx0aGlzW3ZdKCksTChJLG90LFkscnQpKTooXyYmb3Quc2F2ZSgpLE9iamVjdCh1LmRyYXdNZXNoMkQpKGF0LG90LCExKSxfJiZvdC5yZXN0b3JlKCksKCFpdHx8IWl0LmZpbHRlckNhbnZhc3x8YXQuZmlsdGVyIT09aXQuZmlsdGVyKSYmKE9iamVjdCh1LmFwcGx5RmlsdGVyKShvdCxodCksdGhpc1t2XSgpLEwoSSxvdCxZLHJ0KSkpfWVsc2V7aWYoRylJLnByb2dyYW0hPT1HJiZ0aGlzLnVzZVByb2dyYW0oRyx7YV9jb2xvcjp7dHlwZToiVU5TSUdORURfQllURSIsbm9ybWFsaXplOiEwfX0pO2Vsc2V7Y29uc3Qgb3Q9ISFzdC51bmlmb3Jtcy51X3RleFNhbXBsZXIsYXQ9ISFzdC51bmlmb3Jtcy51X2ZpbHRlckZsYWcsaHQ9ISFzdC51bmlmb3Jtcy51X3JhZGlhbEdyYWRpZW50VmVjdG9yLGl0PSEhc3QudW5pZm9ybXMudV9jbGlwU2FtcGxlcjtPYmplY3QobS5hcHBseVNoYWRlcikoSSx7aGFzVGV4dHVyZTpvdCxoYXNGaWx0ZXI6YXQsaGFzR3JhZGllbnQ6aHQsaGFzQ2xpcFBhdGg6aXR9KX1zdC5maWx0ZXJDYW52YXMmJmNvbnNvbGUud2FybigiVXNlciBwcm9ncmFtIGlnbm9yZWQgc29tZSBmaWx0ZXIgZWZmZWN0cy4iKSx0aGlzW3ZdKCksSS5zZXRNZXNoRGF0YShbc3RdKSxSKEkpfWlmKHN0LnBhc3MubGVuZ3RoKXtjb25zdCBvdD1zdC5wYXNzLmxlbmd0aDtzdC5wYXNzLmZvckVhY2goKGF0LGh0KT0+e2F0LmJsZW5kPXN0LmVuYWJsZUJsZW5kLGF0LnNldFRleHR1cmUoSS5mYm8udGV4dHVyZSksaHQ9PT1vdC0xP0kuYmluZEZCTyhqKToodGhpcy5mYm8uc3dhcCgpLEkuYmluZEZCTyh0aGlzLmZiby50YXJnZXQpKSxhdC5wcm9ncmFtP0kudXNlUHJvZ3JhbShhdC5wcm9ncmFtKToodGhpcy5kZWZhdWx0UGFzc1Byb2dyYW09dGhpcy5kZWZhdWx0UGFzc1Byb2dyYW18fHRoaXMuY3JlYXRlUGFzc1Byb2dyYW0oKSxJLnVzZVByb2dyYW0odGhpcy5kZWZhdWx0UGFzc1Byb2dyYW0pKSxJLnNldE1lc2hEYXRhKFthdC5tZXNoRGF0YV0pLEouY2xlYXIoSi5DT0xPUl9CVUZGRVJfQklUKSxSKEkpfSl9c3QuYWZ0ZXJSZW5kZXImJnN0LmFmdGVyUmVuZGVyKEosc3QpfX19ZWxzZSBJLnNldFRyYW5zZm9ybSh0aGlzLmdsb2JhbFRyYW5zZm9ybU1hdHJpeCksSS5kcmF3TWVzaGVzKHcse2NsZWFyOkJ9KX1kcmF3SW1hZ2UodywuLi5CKXtjb25zdCBEPUIubGVuZ3RoO2lmKEQ8Mil0aHJvdyBuZXcgVHlwZUVycm9yKGBGYWlsZWQgdG8gZXhlY3V0ZSAnZHJhd0ltYWdlJyBvbiAnUmVuZGVyZXInOiAzIGFyZ3VtZW50cyByZXF1aXJlZCwgYnV0IG9ubHkgJHtCLmxlbmd0aCsxfSBwcmVzZW50LmApO2lmKEQhPT0yJiZEIT09NCYmRCE9PTgpdGhyb3cgbmV3IFR5cGVFcnJvcihgRmFpbGVkIHRvIGV4ZWN1dGUgJ2RyYXdJbWFnZScgb24gJ1JlbmRlcmVyJzogVmFsaWQgYXJpdGllcyBhcmU6IFszLCA1LCA5XSwgYnV0ICR7Qi5sZW5ndGgrMX0gYXJndW1lbnRzIHByb3ZpZGVkLmApO2xldCBJPW51bGwsaj1udWxsO0Q9PT0yP0k9W0JbMF0sQlsxXSx3LndpZHRoLHcuaGVpZ2h0XTpEPT09ND9JPUI6RD09PTgmJihqPUIuc2xpY2UoMCw0KSxJPUIuc2xpY2UoNCkpO2NvbnN0IFY9dGhpcy5jcmVhdGVUZXh0dXJlKHcpLHt3aWR0aDpKLGhlaWdodDpffT10aGlzLmNhbnZhcyxzdD1uZXcgYS5kZWZhdWx0O3N0LnJlY3QoSVswXSxJWzFdLEosXyk7Y29uc3QgRz1uZXcgZC5kZWZhdWx0KHN0LHt3aWR0aDpKLGhlaWdodDpffSk7Ry5zZXRUZXh0dXJlKFYse3JlY3Q6SSxzcmNSZWN0Omp9KSx0aGlzLmRyYXdNZXNoZXMoW0ddKSx0aGlzLmRlbGV0ZVRleHR1cmUoVil9c2V0R2xvYmFsVHJhbnNmb3JtKC4uLncpe3JldHVybiB0aGlzW2xdPVt3WzBdLHdbMV0sMCx3WzJdLHdbM10sMCx3WzRdLHdbNV0sMV0sdGhpc31nbG9iYWxUcmFuc2Zvcm0oLi4udyl7Y29uc3QgQj10aGlzW2xdO3JldHVybiB0aGlzW2xdPWkubWF0My5tdWx0aXBseShBcnJheS5vZigwLDAsMCwwLDAsMCwwLDAsMCksQix3KSx0aGlzfWdsb2JhbFRyYW5zbGF0ZSh3LEIpe2xldCBEPWkubWF0My5jcmVhdGUoKTtyZXR1cm4gRD1pLm1hdDMudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwLDAsMCwwKSxELFt3LEJdKSx0aGlzLmdsb2JhbFRyYW5zZm9ybSguLi5EKX1nbG9iYWxSb3RhdGUodyxbQixEXT1bMCwwXSl7bGV0IEk9aS5tYXQzLmNyZWF0ZSgpO3JldHVybiBJPWkubWF0My50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDAsMCwwLDApLEksW0IsRF0pLEk9aS5tYXQzLnJvdGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCwwLDAsMCksSSx3KSxJPWkubWF0My50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDAsMCwwLDApLEksWy1CLC1EXSksdGhpcy5nbG9iYWxUcmFuc2Zvcm0oLi4uSSl9Z2xvYmFsU2NhbGUodyxCPXcsW0QsSV09WzAsMF0pe2xldCBqPWkubWF0My5jcmVhdGUoKTtyZXR1cm4gaj1pLm1hdDMudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwLDAsMCwwKSxqLFtELEldKSxqPWkubWF0My5zY2FsZShBcnJheS5vZigwLDAsMCwwLDAsMCwwLDAsMCksaixbdyxCXSksaj1pLm1hdDMudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwLDAsMCwwKSxqLFstRCwtSV0pLHRoaXMuZ2xvYmFsVHJhbnNmb3JtKC4uLmopfWdsb2JhbFNrZXcodyxCPXcsW0QsSV09WzAsMF0pe2xldCBqPWkubWF0My5jcmVhdGUoKTtyZXR1cm4gaj1pLm1hdDMudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwLDAsMCwwKSxqLFtELEldKSxqPWkubWF0My5tdWx0aXBseShBcnJheS5vZigwLDAsMCwwLDAsMCwwLDAsMCksaixpLm1hdDMuZnJvbVZhbHVlcygxLE1hdGgudGFuKEIpLE1hdGgudGFuKHcpLDEsMCwwKSksaj1pLm1hdDMudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwLDAsMCwwKSxqLFstRCwtSV0pLHRoaXMuZ2xvYmFsVHJhbnNmb3JtKC4uLmopfXRyYW5zZm9ybVBvaW50KHcsQixEKXtsZXQgST10aGlzLmdsb2JhbFRyYW5zZm9ybU1hdHJpeDtEJiYoST1pLm1hdDMubXVsdGlwbHkoQXJyYXkub2YoMCwwLDAsMCwwLDAsMCwwLDApLEksRCkpO2NvbnN0IGo9dypJWzBdK0IqSVsyXStJWzRdLFY9dypJWzFdK0IqSVszXStJWzVdO3JldHVybltqLFZdfX19LGZ1bmN0aW9uKGcsZSx0KXt0LnIoZSk7dmFyIG49dCgxNSk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpLGUuZGVmYXVsdD1uLmRlZmF1bHR9LGZ1bmN0aW9uKGcsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIG19KTt2YXIgbj10KDE2KSxpPXQoMTcpLGY9dCgxOCksaD10KDE5KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gdShiLE0seSl7cmV0dXJuIE0gaW4gYj9PYmplY3QuZGVmaW5lUHJvcGVydHkoYixNLHt2YWx1ZTp5LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6YltNXT15LGJ9Y29uc3QgYT17fTtmdW5jdGlvbiBkKGIsTT0zKXtjb25zdCB5PVtdLFM9Yi5sZW5ndGg7Zm9yKGxldCBzPTA7czxTO3MrKylzJU08MiYmeS5wdXNoKC41KihiW3NdKzEpKTtyZXR1cm4geX1mdW5jdGlvbiBFKGIsTSl7Y29uc3QgeT1NLl9idWZmZXJzO09iamVjdC52YWx1ZXMoeSkuZm9yRWFjaChTPT57Yi5kZWxldGVCdWZmZXIoUyl9KSxNLl9idWZmZXJzPXt9fWZ1bmN0aW9uIHAoYixNLHkpe3JldHVybiBiLmFjdGl2ZVRleHR1cmUoYi5URVhUVVJFMCt5KSxBcnJheS5pc0FycmF5KE0uX2ltZyk/Yi5iaW5kVGV4dHVyZShiLlRFWFRVUkVfQ1VCRV9NQVAsTSk6Yi5iaW5kVGV4dHVyZShiLlRFWFRVUkVfMkQsTSksTX1jb25zdCBPPXtpbnQ6IjFpIixpdmVjMjoiMmkiLGl2ZWMzOiIzaSIsaXZlYzQ6IjRpIixmbG9hdDoiMWYiLHZlYzI6IjJmIix2ZWMzOiIzZiIsdmVjNDoiNGYiLG1hdDI6Ik1hdHJpeDJmdiIsbWF0MzoiTWF0cml4M2Z2IixtYXQ0OiJNYXRyaXg0ZnYiLHNhbXBsZXIxRDoic2FtcGxlcjFEIixzYW1wbGVyMkQ6InNhbXBsZXIyRCIsc2FtcGxlcjNEOiJzYW1wbGVyM0QiLHNhbXBsZXJDdWJlOiJzYW1wbGVyQ3ViZSIsc2FtcGxlcjFEU2hhZG93OiJzYW1wbGVyMURTaGFkb3ciLHNhbXBsZXIyRFNoYWRvdzoic2FtcGxlcjJEU2hhZG93IixzYW1wbGVyMkRSZWN0OiJzYW1wbGVyMkRSZWN0IixzYW1wbGVyMkRSZWN0U2hhZG93OiJzYW1wbGVyMkRSZWN0U2hhZG93In07Y2xhc3MgbXtzdGF0aWMgYWRkTGlicyhNPXt9KXtPYmplY3QuYXNzaWduKGEsTSl9c3RhdGljIEZMT0FUKE0seSl7cmV0dXJuIE9iamVjdChuLnBvaW50c1RvQnVmZmVyKShNLEZsb2F0MzJBcnJheSx5KX1zdGF0aWMgVU5TSUdORURfQllURShNLHkpe3JldHVybiBPYmplY3Qobi5wb2ludHNUb0J1ZmZlcikoTSxVaW50OEFycmF5LHkpfXN0YXRpYyBVTlNJR05FRF9TSE9SVChNLHkpe3JldHVybiBPYmplY3Qobi5wb2ludHNUb0J1ZmZlcikoTSxVaW50MTZBcnJheSx5KX1zdGF0aWMgQllURShNLHkpe3JldHVybiBPYmplY3Qobi5wb2ludHNUb0J1ZmZlcikoTSxJbnQ4QXJyYXkseSl9c3RhdGljIFNIT1JUKE0seSl7cmV0dXJuIE9iamVjdChuLnBvaW50c1RvQnVmZmVyKShNLEludDE2QXJyYXkseSl9Y29uc3RydWN0b3IoTSx5PXt9KXt0aGlzLm9wdGlvbnM9T2JqZWN0LmFzc2lnbih7fSxtLmRlZmF1bHRPcHRpb25zLHkpLHRoaXMuY2FudmFzPU07bGV0IFM7dGhpcy5vcHRpb25zLndlYmdsMiYmKFM9TS5nZXRDb250ZXh0KCJ3ZWJnbDIiLHRoaXMub3B0aW9ucykpLFM9PW51bGwmJihTPU9iamVjdChuLnNldHVwV2ViR0wpKE0sdGhpcy5vcHRpb25zKSx0aGlzLmFpYV9leHQ9Uy5nZXRFeHRlbnNpb24oIkFOR0xFX2luc3RhbmNlZF9hcnJheXMiKSksdGhpcy5nbD1TLFMudmlld3BvcnQoMCwwLE0ud2lkdGgsTS5oZWlnaHQpLFMuY2xlYXJDb2xvcigwLDAsMCwwKSxTLmJsZW5kRnVuY1NlcGFyYXRlKFMuU1JDX0FMUEhBLFMuT05FX01JTlVTX1NSQ19BTFBIQSxTLk9ORSxTLk9ORV9NSU5VU19TUkNfQUxQSEEpLHRoaXMucHJvZ3JhbXM9W10sdGhpcy5fZXZlbnRzPXt9fWdldCBwcm9ncmFtKCl7Y29uc3QgTT10aGlzLmdsO3JldHVybiBNLmdldFBhcmFtZXRlcihNLkNVUlJFTlRfUFJPR1JBTSl9X2RlY2xhcmVVbmlmb3JtKE0seSxTPSIxZiIpe2NvbnN0IHM9dGhpcy5nbCxjPXMuZ2V0VW5pZm9ybUxvY2F0aW9uKE0seSk7bGV0IGw7Y29uc3Qgdj10aGlzO2lmKC9ec2FtcGxlci8udGVzdChTKSl7Y29uc3QgVD1NLl9zYW1wbGVyTWFwLFI9TS5fYmluZFRleHR1cmVzO09iamVjdC5kZWZpbmVQcm9wZXJ0eShNLnVuaWZvcm1zLHkse2dldCgpe3JldHVybiBsfSxzZXQoTCl7bD1MO2NvbnN0IE49VFt5XSE9bnVsbD9UW3ldOlIubGVuZ3RoO1JbTl09TCxwKHMsTCxOKSxUW3ldfHwoVFt5XT1OLHMudW5pZm9ybTFpKGMsTikpLHYub3B0aW9ucy5hdXRvVXBkYXRlJiZ2LnVwZGF0ZSgpfSxjb25maWd1cmFibGU6ITEsZW51bWVyYWJsZTohMH0pfWVsc2V7Y29uc3QgVD1TLmluZGV4T2YoIk1hdHJpeCIpPT09MCxSPSFUJiYvdiQvLnRlc3QoUyksTD1zW2B1bmlmb3JtJHtTfWBdLmJpbmQocyk7T2JqZWN0LmRlZmluZVByb3BlcnR5KE0udW5pZm9ybXMseSx7Z2V0KCl7cmV0dXJuIGx9LHNldChOKXtsPU4sdHlwZW9mIE49PSJudW1iZXIiJiYoTj1bTl0pLFQ/TChjLCExLE4pOlI/TChjLE4pOkwoYywuLi5OKSx2Lm9wdGlvbnMuYXV0b1VwZGF0ZSYmdi51cGRhdGUoKX0sY29uZmlndXJhYmxlOiExLGVudW1lcmFibGU6ITB9KX19X2RyYXcoKXtjb25zdCBNPXRoaXMucHJvZ3JhbTtNLm1lc2hEYXRhLmZvckVhY2goKHksUyk9Pntjb25zdHtwb3NpdGlvbnM6cyxjZWxsczpjLGluc3RhbmNlQ291bnQ6bCxjZWxsc0NvdW50OnYsYXR0cmlidXRlczpULHVuaWZvcm1zOlIsdGV4dHVyZUNvb3JkOkwsZW5hYmxlQmxlbmQ6Tn09eSxBPXRoaXMuZ2w7bGV0IHc9eS5tb2RlIT1udWxsP3kubW9kZTpBLlRSSUFOR0xFUzt0eXBlb2Ygdz09InN0cmluZyImJih3PUFbd10pLE4/QS5lbmFibGUoQS5CTEVORCk6QS5kaXNhYmxlKEEuQkxFTkQpLEEuYmluZEJ1ZmZlcihBLkFSUkFZX0JVRkZFUixNLl9idWZmZXJzLnZlcnRpY2VzQnVmZmVyKSxBLmJ1ZmZlckRhdGEoQS5BUlJBWV9CVUZGRVIscyxBLlNUQVRJQ19EUkFXKSxjJiYoQS5iaW5kQnVmZmVyKEEuRUxFTUVOVF9BUlJBWV9CVUZGRVIsTS5fYnVmZmVycy5jZWxsc0J1ZmZlciksQS5idWZmZXJEYXRhKEEuRUxFTUVOVF9BUlJBWV9CVUZGRVIsYyxBLlNUQVRJQ19EUkFXKSk7Y29uc3QgQj1bXTtUJiZPYmplY3QudmFsdWVzKFQpLmZvckVhY2goKHtuYW1lOkksZGF0YTpqLGRpdmlzb3I6Vn0pPT57aWYoQS5iaW5kQnVmZmVyKEEuQVJSQVlfQlVGRkVSLE0uX2J1ZmZlcnNbSV0pLEEuYnVmZmVyRGF0YShBLkFSUkFZX0JVRkZFUixqLEEuU1RBVElDX0RSQVcpLFYhPW51bGwpe2NvbnN0IEo9QS5nZXRBdHRyaWJMb2NhdGlvbihNLEkpO0o+PTAmJihBLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KEopLEIucHVzaChKKSxBLnZlcnRleEF0dHJpYkRpdmlzb3I/QS52ZXJ0ZXhBdHRyaWJEaXZpc29yKEosVik6dGhpcy5haWFfZXh0JiZ0aGlzLmFpYV9leHQudmVydGV4QXR0cmliRGl2aXNvckFOR0xFKEosVikpfX0pLFImJk9iamVjdC5lbnRyaWVzKFIpLmZvckVhY2goKFtJLGpdKT0+e3RoaXMudW5pZm9ybXNbSV09an0pO2xldCBEO2lmKCFjKXtjb25zdCBJPU0uX2RpbWVuc2lvbjtEPXMubGVuZ3RoL0l9aWYoTS5fZW5hYmxlVGV4dHVyZXMmJk0uX2J1ZmZlcnMudGV4Q29vcmRCdWZmZXIpe2NvbnN0IEk9THx8ZChzLE0uX2RpbWVuc2lvbik7QS5iaW5kQnVmZmVyKEEuQVJSQVlfQlVGRkVSLE0uX2J1ZmZlcnMudGV4Q29vcmRCdWZmZXIpLEEuYnVmZmVyRGF0YShBLkFSUkFZX0JVRkZFUixtLkZMT0FUKEkpLEEuU1RBVElDX0RSQVcpfWwhPW51bGw/KGM/QS5kcmF3RWxlbWVudHNJbnN0YW5jZWQ/QS5kcmF3RWxlbWVudHNJbnN0YW5jZWQodyx2LEEuVU5TSUdORURfU0hPUlQsMCxsKTp0aGlzLmFpYV9leHQmJnRoaXMuYWlhX2V4dC5kcmF3RWxlbWVudHNJbnN0YW5jZWRBTkdMRSh3LHYsQS5VTlNJR05FRF9TSE9SVCwwLGwpOkEuZHJhd0FycmF5c0luc3RhbmNlZD9BLmRyYXdBcnJheXNJbnN0YW5jZWQodywwLEQsbCk6dGhpcy5haWFfZXh0LmRyYXdBcnJheXNJbnN0YW5jZWRBTkdMRSh3LDAsRCxsKSxCLmZvckVhY2goST0+e0EudmVydGV4QXR0cmliRGl2aXNvcj9BLnZlcnRleEF0dHJpYkRpdmlzb3IoSSxudWxsKTp0aGlzLmFpYV9leHQmJnRoaXMuYWlhX2V4dC52ZXJ0ZXhBdHRyaWJEaXZpc29yQU5HTEUoSSxudWxsKX0pKTpjP0EuZHJhd0VsZW1lbnRzKHcsdixBLlVOU0lHTkVEX1NIT1JULDApOkEuZHJhd0FycmF5cyh3LDAsRCl9KX1nZXQgaXNXZWJHTDIoKXtyZXR1cm4gdHlwZW9mIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQ8InUiJiZ0aGlzLmdsIGluc3RhbmNlb2YgV2ViR0wyUmVuZGVyaW5nQ29udGV4dH1nZXQgZW5hYmxlVGV4dHVyZXMoKXtyZXR1cm4gdGhpcy5wcm9ncmFtJiZ0aGlzLnByb2dyYW0uX2VuYWJsZVRleHR1cmVzfWdldCB1bmlmb3Jtcygpe2NvbnN0IE09dGhpcy5wcm9ncmFtO2lmKCFNfHwhTS51bmlmb3Jtcyl0aHJvdyBFcnJvcigiTm8gYXZhbGlhYmxlIHByb2dyYW0uIik7cmV0dXJuIE0udW5pZm9ybXN9ZGVsZXRlUHJvZ3JhbShNKXtjb25zdCB5PXRoaXMuZ2w7dGhpcy5wcm9ncmFtPT09TSYmKHRoaXMuc3RhcnRSZW5kZXI9ITEsdGhpcy5fcmVuZGVyRnJhbWVJRCYmKGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuX3JlbmRlckZyYW1lSUQpLGRlbGV0ZSB0aGlzLl9yZW5kZXJGcmFtZUlEKSx5LnVzZVByb2dyYW0obnVsbCkpO2NvbnN0IFM9dGhpcy5wcm9ncmFtcy5pbmRleE9mKE0pO1M+PTAmJnRoaXMucHJvZ3JhbXMuc3BsaWNlKFMsMSksRSh5LE0pLHkuZGVsZXRlUHJvZ3JhbShNKX1zZXRNZXNoRGF0YShNKXtBcnJheS5pc0FycmF5KE0pfHwoTT1bTV0pO2NvbnN0IHk9dGhpcy5wcm9ncmFtO3kubWVzaERhdGE9TS5tYXAoKHttb2RlOlMscG9zaXRpb25zOnMsaW5zdGFuY2VDb3VudDpjLGNlbGxzOmwsY2VsbHNDb3VudDp2LGF0dHJpYnV0ZXM6VCx1bmlmb3JtczpSLHRleHR1cmVDb29yZDpMLGVuYWJsZUJsZW5kOk59KT0+e2NvbnN0IEE9e3Bvc2l0aW9uczptLkZMT0FUKHMpLHVuaWZvcm1zOlIsZW5hYmxlQmxlbmQ6ISFOLHRleHR1cmVDb29yZDptLkZMT0FUKEwpfTtpZihsJiYoQS5jZWxscz1tLlVTSE9SVChsKSxBLmNlbGxzQ291bnQ9dnx8QS5jZWxscy5sZW5ndGgpLFMhPW51bGwmJihBLm1vZGU9UyksYyE9bnVsbCl7aWYoIXRoaXMuaXNXZWJHTDImJiF0aGlzLmFpYV9leHQpdGhyb3cgbmV3IEVycm9yKCJDYW5ub3QgdXNlIGluc3RhbmNlQ291bnQgaW4gdGhpcyByZW5kZXJpbmcgY29udGV4dCwgdXNlIHdlYmdsMiBjb250ZXh0IGluc3RlYWQuIik7QS5pbnN0YW5jZUNvdW50PWN9aWYoVCl7Y29uc3Qgdz17fTtPYmplY3QuZW50cmllcyhUKS5mb3JFYWNoKChbQixEXSk9PntpZigheS5fYXR0cmlidXRlW0JdKXkuX2F0dHJpYnV0ZVtCXT0iaWdub3JlZCI7ZWxzZSBpZih5Ll9hdHRyaWJ1dGVbQl0hPT0iaWdub3JlZCIpe2NvbnN0e25hbWU6SSx0eXBlOmp9PXkuX2F0dHJpYnV0ZVtCXTtsZXQgVj1ELmRhdGF8fEQ7aWYoQXJyYXkuaXNBcnJheShWKSYmKFY9bVtqXShWKSksd1tCXT17bmFtZTpJLGRhdGE6Vn0sRC5kaXZpc29yIT1udWxsKXtpZighdGhpcy5pc1dlYkdMMiYmIXRoaXMuYWlhX2V4dCl0aHJvdyBuZXcgRXJyb3IoIkNhbm5vdCB1c2UgZGl2aXNvciBpbiB0aGlzIHJlbmRlcmluZyBjb250ZXh0LCB1c2Ugd2ViZ2wyIGNvbnRleHQgaW5zdGVhZC4iKTt3W0JdLmRpdmlzb3I9RC5kaXZpc29yfX19KSxBLmF0dHJpYnV0ZXM9d31yZXR1cm4gQX0pLHRoaXMub3B0aW9ucy5hdXRvVXBkYXRlJiZ0aGlzLnVwZGF0ZSgpfWNyZWF0ZVByb2dyYW0oTSx5KXtjb25zdCBTPS9eXHMqdW5pZm9ybVxzK3NhbXBsZXIvbWcudGVzdChNKTtNPT1udWxsJiYoTT1mLmRlZmF1bHQpLHk9PW51bGwmJih5PVM/aC5kZWZhdWx0OmkuZGVmYXVsdCk7Y29uc3Qgcz10aGlzLmdsLGM9T2JqZWN0KG4uY3JlYXRlUHJvZ3JhbSkocyx5LE0pO2Muc2hhZGVyVGV4dD17dmVydGV4U2hhZGVyOnksZnJhZ21lbnRTaGFkZXI6TX0sYy5fYnVmZmVycz17fSxjLl9hdHRyaWJ1dGU9e30sYy51bmlmb3Jtcz17fSxjLl9zYW1wbGVyTWFwPXt9LGMuX2JpbmRUZXh0dXJlcz1bXTtjb25zdCBsPW5ldyBSZWdFeHAoYCg/OmF0dHJpYnV0ZXxpbikgdmVjKFxcZCkgJHt0aGlzLm9wdGlvbnMudmVydGV4UG9zaXRpb259YCwiaW0iKTtsZXQgdj15Lm1hdGNoKGwpO3YmJihjLl9kaW1lbnNpb249TnVtYmVyKHZbMV0pKTtjb25zdCBUPW5ldyBSZWdFeHAoYCg/OmF0dHJpYnV0ZXxpbikgdmVjKFxcZCkgJHt0aGlzLm9wdGlvbnMudmVydGV4VGV4dHVyZUNvb3JkfWAsImltIik7dj15Lm1hdGNoKFQpLHYmJihjLl90ZXhDb29yZFNpemU9TnVtYmVyKHZbMV0pKTtjb25zdCBSPS9eXHMqKD86YXR0cmlidXRlfGluKSAoXHcrPykoXGQqKSAoXHcrKS9naW07aWYodj15Lm1hdGNoKFIpLHYpZm9yKGxldCBBPTA7QTx2Lmxlbmd0aDtBKyspe2NvbnN0IHc9L15ccyooPzphdHRyaWJ1dGV8aW4pIChcdys/KShcZCopIChcdyspL2ltLEI9dltBXS5tYXRjaCh3KTtpZihCJiZCWzNdIT09dGhpcy5vcHRpb25zLnZlcnRleFBvc2l0aW9uJiZCWzNdIT09dGhpcy5vcHRpb25zLnZlcnRleFRleHR1cmVDb29yZCl7bGV0WyxELEksal09QjtEPT09Im1hdCImJihJKio9MiksYy5fYnVmZmVyc1tqXT1zLmNyZWF0ZUJ1ZmZlcigpLGMuX2F0dHJpYnV0ZVtqXT17bmFtZTpqLHR5cGU6RCxzaXplOk51bWJlcihJKXx8MX19fWNvbnN0IEw9L15ccyp1bmlmb3JtXHMrKFx3KylccysoXHcrKShcW1xkK1xdKT8vbWc7dj15Lm1hdGNoKEwpfHxbXSx2PXYuY29uY2F0KE0ubWF0Y2goTCl8fFtdKSx2LmZvckVhY2goQT0+e2NvbnN0IHc9QS5tYXRjaCgvXlxzKnVuaWZvcm1ccysoXHcrKVxzKyhcdyspKFxbXGQrXF0pPy8pO2xldFtCLEQsSV09dy5zbGljZSgxKTtCPU9bQl0sST0hIUksQi5pbmRleE9mKCJNYXRyaXgiKSE9PTAmJkkmJihCKz0idiIpLHRoaXMuX2RlY2xhcmVVbmlmb3JtKGMsRCxCKX0pLGMuX2J1ZmZlcnMudmVydGljZXNCdWZmZXI9cy5jcmVhdGVCdWZmZXIoKSxjLl9idWZmZXJzLmNlbGxzQnVmZmVyPXMuY3JlYXRlQnVmZmVyKCk7Y29uc3QgTj1zLmdldEF0dHJpYkxvY2F0aW9uKGMsdGhpcy5vcHRpb25zLnZlcnRleFRleHR1cmVDb29yZCk7cmV0dXJuIGMuX2VuYWJsZVRleHR1cmVzPU4+PTAsYy5fZW5hYmxlVGV4dHVyZXMmJihjLl9idWZmZXJzLnRleENvb3JkQnVmZmVyPXMuY3JlYXRlQnVmZmVyKCkpLHRoaXMucHJvZ3JhbXMucHVzaChjKSxjfXVzZVByb2dyYW0oTSx5PXt9KXt0aGlzLnN0YXJ0UmVuZGVyPSExLHRoaXMuX3JlbmRlckZyYW1lSUQmJihjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLl9yZW5kZXJGcmFtZUlEKSxkZWxldGUgdGhpcy5fcmVuZGVyRnJhbWVJRCk7Y29uc3QgUz10aGlzLmdsO1MudXNlUHJvZ3JhbShNKTtjb25zdCBzPU0uX2RpbWVuc2lvbjtTLmJpbmRCdWZmZXIoUy5BUlJBWV9CVUZGRVIsTS5fYnVmZmVycy52ZXJ0aWNlc0J1ZmZlcik7Y29uc3QgYz1TLmdldEF0dHJpYkxvY2F0aW9uKE0sdGhpcy5vcHRpb25zLnZlcnRleFBvc2l0aW9uKTtpZihTLnZlcnRleEF0dHJpYlBvaW50ZXIoYyxzLFMuRkxPQVQsITEsMCwwKSxTLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGMpLE0uX2VuYWJsZVRleHR1cmVzKXtTLmJpbmRCdWZmZXIoUy5BUlJBWV9CVUZGRVIsTS5fYnVmZmVycy50ZXhDb29yZEJ1ZmZlcik7Y29uc3QgbD1TLmdldEF0dHJpYkxvY2F0aW9uKE0sdGhpcy5vcHRpb25zLnZlcnRleFRleHR1cmVDb29yZCk7Uy52ZXJ0ZXhBdHRyaWJQb2ludGVyKGwsTS5fdGV4Q29vcmRTaXplfHwyLFMuRkxPQVQsITEsMCwwKSxTLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGwpfWlmKE9iamVjdC5lbnRyaWVzKE0uX2F0dHJpYnV0ZSkuZm9yRWFjaCgoW2wsdl0pPT57aWYodiE9PSJpZ25vcmVkIil7Y29uc3QgVD12LnNpemUsUj15W2xdfHx7fSxMPSEhUi5ub3JtYWxpemU7bGV0IE49Ui50eXBlfHwiRkxPQVQiO2NvbnN0IEE9Ui5rZXl8fGw7Tj09PSJVQllURSImJihOPSJVTlNJR05FRF9CWVRFIiksTj09PSJVU0hPUlQiJiYoTj0iVU5TSUdORURfU0hPUlQiKSx2LnR5cGU9TixBJiZBIT09bCYmKE0uX2F0dHJpYnV0ZVtBXT12KSxTLmJpbmRCdWZmZXIoUy5BUlJBWV9CVUZGRVIsTS5fYnVmZmVyc1tsXSk7Y29uc3Qgdz1TLmdldEF0dHJpYkxvY2F0aW9uKE0sbCk7dz49MCYmKFMudmVydGV4QXR0cmliUG9pbnRlcih3LFQsU1tOXSxMLDAsMCksUy5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSh3KSl9fSksIU0ubWVzaERhdGEpe2NvbnN0IGw9W1stMSwtMSwwLDFdLnNsaWNlKDAscyksWzEsLTEsMCwxXS5zbGljZSgwLHMpLFsxLDEsMCwxXS5zbGljZSgwLHMpLFstMSwxLDAsMV0uc2xpY2UoMCxzKV0sdj1bWzAsMSwzXSxbMywxLDJdXTt0aGlzLnNldE1lc2hEYXRhKHtwb3NpdGlvbnM6bCxjZWxsczp2fSl9cmV0dXJuIE19Y29tcGlsZVN5bmMoTSx5KXtNPU18fGYuZGVmYXVsdDtjb25zdCBTPXt9O2Z1bmN0aW9uIHMoVCl7VD1ULnJlcGxhY2UoL15ccyovbWcsIiIpO2NvbnN0IFI9W10sTD1ULm1hdGNoKC9eI3ByYWdtYVxzK2luY2x1ZGVccysuKi9tZyk7aWYoTCl7Zm9yKGxldCBOPTA7TjxMLmxlbmd0aDtOKyspe2NvbnN0IHc9TFtOXS5tYXRjaCgvKD86PHwiKSguKikoPzo+fCIpLyk7aWYodyl7Y29uc3QgQj13WzBdLmluZGV4T2YoIjwiKT09PTA/ImxpYiI6ImxpbmsiO2xldCBEPXdbMV07aWYoRD09PSJncmFwaCImJihEPSJncmFwaGljcyIpLFNbRF0pUi5wdXNoKGAvKiBpbmNsdWRlZCAke0R9ICovYCk7ZWxzZSBpZihTW0RdPSEwLEI9PT0ibGliIil7Y29uc3QgST1zKGFbRF0pO1IucHVzaChJKX1lbHNlIGlmKEI9PT0ibGluayIpdGhyb3cgbmV3IEVycm9yKCJDYW5ub3QgbG9hZCBleHRlcm5hbCBsaW5rcyBzeW5jaHJvbm91c2x5LiBVc2UgY29tcGlsZSBpbnN0ZWFkIG9mIGNvbXBpbGVTeW5jLiIpfX1SLmZvckVhY2goTj0+e1Q9VC5yZXBsYWNlKC9eI3ByYWdtYVxzK2luY2x1ZGVccysuKi9tLE4pfSl9cmV0dXJuIFR9Y29uc3QgYz1zKE0pLGw9eT9zKHkpOm51bGw7cmV0dXJuIHRoaXMuY3JlYXRlUHJvZ3JhbShjLGwpfWFzeW5jIGNvbXBpbGUoTSx5KXtNPU18fGYuZGVmYXVsdDtjb25zdCBTPXt9O2FzeW5jIGZ1bmN0aW9uIHMoVCl7VD1ULnJlcGxhY2UoL15ccyovbWcsIiIpO2NvbnN0IFI9W10sTD1ULm1hdGNoKC9eI3ByYWdtYVxzK2luY2x1ZGVccysuKi9tZyk7aWYoTCl7Zm9yKGxldCBOPTA7TjxMLmxlbmd0aDtOKyspe2NvbnN0IHc9TFtOXS5tYXRjaCgvKD86PHwiKSguKikoPzo+fCIpLyk7aWYodyl7Y29uc3QgQj13WzBdLmluZGV4T2YoIjwiKT09PTA/ImxpYiI6ImxpbmsiO2xldCBEPXdbMV07aWYoRD09PSJncmFwaCImJihEPSJncmFwaGljcyIpLFNbRF0pUi5wdXNoKGAvKiBpbmNsdWRlZCAke0R9ICovYCk7ZWxzZSBpZihTW0RdPSEwLEI9PT0ibGliIil7Y29uc3QgST1hd2FpdCBzKGFbRF0pO1IucHVzaChJKX1lbHNlIGlmKEI9PT0ibGluayIpe2xldCBJPWF3YWl0IG0uZmV0Y2hTaGFkZXIoRCk7ST1hd2FpdCBzKEkpLFIucHVzaChJKX19fVIuZm9yRWFjaChOPT57VD1ULnJlcGxhY2UoL14jcHJhZ21hXHMraW5jbHVkZVxzKy4qL20sTil9KX1yZXR1cm4gVH1jb25zdCBjPWF3YWl0IHMoTSksbD15P2F3YWl0IHMoeSk6bnVsbDtyZXR1cm4gdGhpcy5jcmVhdGVQcm9ncmFtKGMsbCl9YXN5bmMgbG9hZChNLHk9bnVsbCl7cmV0dXJuIE09YXdhaXQgbS5mZXRjaFNoYWRlcihNKSx5JiYoeT1hd2FpdCBtLmZldGNoU2hhZGVyKHkpKSx0aGlzLmNvbXBpbGUoTSx5KX1jcmVhdGVUZXh0dXJlKE09bnVsbCx7d3JhcFM6eT10aGlzLmdsLkNMQU1QX1RPX0VER0Usd3JhcFQ6Uz10aGlzLmdsLkNMQU1QX1RPX0VER0UsbWluRmlsdGVyOnM9dGhpcy5nbC5MSU5FQVIsbWFnRmlsdGVyOmM9dGhpcy5nbC5MSU5FQVJ9PXt9KXtjb25zdCBsPXRoaXMuZ2wsdj1BcnJheS5pc0FycmF5KE0pP2wuVEVYVFVSRV9DVUJFX01BUDpsLlRFWFRVUkVfMkQ7dGhpcy5fbWF4X3RleHR1cmVfaW1hZ2VfdW5pdHM9dGhpcy5fbWF4X3RleHR1cmVfaW1hZ2VfdW5pdHN8fGwuZ2V0UGFyYW1ldGVyKGwuTUFYX0NPTUJJTkVEX1RFWFRVUkVfSU1BR0VfVU5JVFMpLGwuYWN0aXZlVGV4dHVyZShsLlRFWFRVUkUwK3RoaXMuX21heF90ZXh0dXJlX2ltYWdlX3VuaXRzLTEpO2NvbnN0IFQ9bC5jcmVhdGVUZXh0dXJlKCk7bC5iaW5kVGV4dHVyZSh2LFQpLGwucGl4ZWxTdG9yZWkobC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCEwKTtjb25zdHt3aWR0aDpSLGhlaWdodDpMfT10aGlzLmNhbnZhcztpZihNKWlmKHY9PT1sLlRFWFRVUkVfQ1VCRV9NQVApZm9yKGxldCBOPTA7Tjw2O04rKylsLnRleEltYWdlMkQobC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1grTiwwLGwuUkdCQSxsLlJHQkEsbC5VTlNJR05FRF9CWVRFLE1bTl0pO2Vsc2UgbC50ZXhJbWFnZTJEKHYsMCxsLlJHQkEsbC5SR0JBLGwuVU5TSUdORURfQllURSxNKTtlbHNlIGlmKHY9PT1sLlRFWFRVUkVfQ1VCRV9NQVApZm9yKGxldCBOPTA7Tjw2O04rKyl0aGlzLmdsLnRleEltYWdlMkQodGhpcy5nbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1grTiwwLGwuUkdCQSxSLEwsMCxsLlJHQkEsbC5VTlNJR05FRF9CWVRFLG51bGwpO2Vsc2UgbC50ZXhJbWFnZTJEKHYsMCxsLlJHQkEsUixMLDAsbC5SR0JBLGwuVU5TSUdORURfQllURSxudWxsKTtyZXR1cm4gbC50ZXhQYXJhbWV0ZXJpKHYsbC5URVhUVVJFX01JTl9GSUxURVIscyksbC50ZXhQYXJhbWV0ZXJpKHYsbC5URVhUVVJFX01BR19GSUxURVIsYyksbC50ZXhQYXJhbWV0ZXJpKHYsbC5URVhUVVJFX1dSQVBfUyx5KSxsLnRleFBhcmFtZXRlcmkodixsLlRFWFRVUkVfV1JBUF9ULFMpLHY9PT1sLlRFWFRVUkVfQ1VCRV9NQVAmJihNLndpZHRoPU1bMF0ud2lkdGgsTS5oZWlnaHQ9TVswXS5oZWlnaHQpLGwuYmluZFRleHR1cmUodixudWxsKSxULl9pbWc9TXx8e3dpZHRoOlIsaGVpZ2h0Okx9LFQuZGVsZXRlPSgpPT57dGhpcy5kZWxldGVUZXh0dXJlKFQpfSxUfWRlbGV0ZVRleHR1cmUoTSl7Y29uc3QgeT1NLl9pbWc7dGhpcy5nbC5kZWxldGVUZXh0dXJlKE0pLHR5cGVvZiB5LmNsb3NlPT0iZnVuY3Rpb24iJiZ5LmNsb3NlKCl9YXN5bmMgbG9hZFRleHR1cmUoTSx7dXNlSW1hZ2VCaXRtYXA6eT0hMH09e30pe2NvbnN0IFM9YXdhaXQgbS5sb2FkSW1hZ2UoTSx7dXNlSW1hZ2VCaXRtYXA6eX0pO3JldHVybiB0aGlzLmNyZWF0ZVRleHR1cmUoUyl9Y3JlYXRlRkJPKHtjb2xvcjpNPTEsYmxlbmQ6eT0hMSxkZXB0aDpTPXRoaXMub3B0aW9ucy5kZXB0aCE9PSExLHN0ZW5jaWw6cz0hIXRoaXMub3B0aW9ucy5zdGVuY2lsfT17fSl7Y29uc3QgYz10aGlzLmdsLGw9Yy5jcmVhdGVGcmFtZWJ1ZmZlcigpO2MuYmluZEZyYW1lYnVmZmVyKGMuRlJBTUVCVUZGRVIsbCk7Y29uc3Qgdj1bXTtmb3IobGV0IEw9MDtMPE07TCsrKXtjb25zdCBOPXRoaXMuY3JlYXRlVGV4dHVyZSgpO2MuZnJhbWVidWZmZXJUZXh0dXJlMkQoYy5GUkFNRUJVRkZFUixjLkNPTE9SX0FUVEFDSE1FTlQwK0wsYy5URVhUVVJFXzJELE4sMCksdi5wdXNoKE4pfWwudGV4dHVyZXM9dixsLnRleHR1cmU9dlswXSxsLmJsZW5kPXk7Y29uc3R7d2lkdGg6VCxoZWlnaHQ6Un09dGhpcy5jYW52YXM7cmV0dXJuIFMmJiFzJiYobC5kZXB0aEJ1ZmZlcj1jLmNyZWF0ZVJlbmRlcmJ1ZmZlcigpLGMuYmluZFJlbmRlcmJ1ZmZlcihjLlJFTkRFUkJVRkZFUixsLmRlcHRoQnVmZmVyKSxjLnJlbmRlcmJ1ZmZlclN0b3JhZ2UoYy5SRU5ERVJCVUZGRVIsYy5ERVBUSF9DT01QT05FTlQxNixULFIpLGMuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoYy5GUkFNRUJVRkZFUixjLkRFUFRIX0FUVEFDSE1FTlQsYy5SRU5ERVJCVUZGRVIsbC5kZXB0aEJ1ZmZlcikpLHMmJiFTJiYobC5zdGVuY2lsQnVmZmVyPWMuY3JlYXRlUmVuZGVyYnVmZmVyKCksYy5iaW5kUmVuZGVyYnVmZmVyKGMuUkVOREVSQlVGRkVSLGwuc3RlbmNpbEJ1ZmZlciksYy5yZW5kZXJidWZmZXJTdG9yYWdlKGMuUkVOREVSQlVGRkVSLGMuU1RFTkNJTF9JTkRFWDgsVCxSKSxjLmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKGMuRlJBTUVCVUZGRVIsYy5TVEVOQ0lMX0FUVEFDSE1FTlQsYy5SRU5ERVJCVUZGRVIsbC5zdGVuY2lsQnVmZmVyKSksUyYmcyYmKGwuZGVwdGhTdGVuY2lsQnVmZmVyPWMuY3JlYXRlUmVuZGVyYnVmZmVyKCksYy5iaW5kUmVuZGVyYnVmZmVyKGMuUkVOREVSQlVGRkVSLGwuZGVwdGhTdGVuY2lsQnVmZmVyKSxjLnJlbmRlcmJ1ZmZlclN0b3JhZ2UoYy5SRU5ERVJCVUZGRVIsYy5ERVBUSF9TVEVOQ0lMLFQsUiksYy5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlcihjLkZSQU1FQlVGRkVSLGMuREVQVEhfU1RFTkNJTF9BVFRBQ0hNRU5ULGMuUkVOREVSQlVGRkVSLGwuZGVwdGhTdGVuY2lsQnVmZmVyKSksYy5iaW5kRnJhbWVidWZmZXIoYy5GUkFNRUJVRkZFUixudWxsKSxsfWJpbmRGQk8oTT1udWxsKXt0aGlzLmZibz1NfXJlbmRlcih7Y2xlYXJCdWZmZXI6TT0hMH09e30pe3RoaXMuc3RhcnRSZW5kZXI9ITA7Y29uc3QgeT10aGlzLmdsO2xldCBTPXRoaXMucHJvZ3JhbTtTfHwoUz10aGlzLmNyZWF0ZVByb2dyYW0oKSx0aGlzLnVzZVByb2dyYW0oUykpLHRoaXMuZmJvJiZ5LmJpbmRGcmFtZWJ1ZmZlcih5LkZSQU1FQlVGRkVSLHRoaXMuZmJvKTtjb25zdCBzPXRoaXMub3B0aW9ucy5kZXB0aDtzJiZ5LmVuYWJsZSh5LkRFUFRIX1RFU1QpLHRoaXMuZ2wuY2xlYXIodGhpcy5nbC5DT0xPUl9CVUZGRVJfQklUfChzP3RoaXMuZ2wuREVQVEhfQlVGRkVSX0JJVDowKXwodGhpcy5vcHRpb25zLnN0ZW5jaWw/dGhpcy5nbC5TVEVOQ0lMX0JVRkZFUl9CSVQ6MCkpO2NvbnN0IGM9dGhpcy5fcmVuZGVyRnJhbWVJRDt0aGlzLl9kcmF3KCksdGhpcy5mYm8mJnkuYmluZEZyYW1lYnVmZmVyKHkuRlJBTUVCVUZGRVIsbnVsbCksdGhpcy5fcmVuZGVyRnJhbWVJRD09PWMmJih0aGlzLl9yZW5kZXJGcmFtZUlEPW51bGwpfXVwZGF0ZSgpe3RoaXMuc3RhcnRSZW5kZXImJnRoaXMuX3JlbmRlckZyYW1lSUQ9PW51bGwmJih0aGlzLl9yZW5kZXJGcmFtZUlEPXJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLnJlbmRlci5iaW5kKHRoaXMpKSl9fXUobSwiZGVmYXVsdE9wdGlvbnMiLHtwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6ITAsYXV0b1VwZGF0ZTohMCx2ZXJ0ZXhQb3NpdGlvbjoiYV92ZXJ0ZXhQb3NpdGlvbiIsdmVydGV4VGV4dHVyZUNvb3JkOiJhX3ZlcnRleFRleHR1cmVDb29yZCIsd2ViZ2wyOiExfSksdShtLCJVQllURSIsbS5VTlNJR05FRF9CWVRFKSx1KG0sIlVTSE9SVCIsbS5VTlNJR05FRF9TSE9SVCksdShtLCJmZXRjaFNoYWRlciIsbi5mZXRjaFNoYWRlciksdShtLCJsb2FkSW1hZ2UiLG4ubG9hZEltYWdlKX0sZnVuY3Rpb24oZyxlLHQpe3QucihlKSx0LmQoZSwic2V0dXBXZWJHTCIsZnVuY3Rpb24oKXtyZXR1cm4gaX0pLHQuZChlLCJjcmVhdGVQcm9ncmFtIixmdW5jdGlvbigpe3JldHVybiBmfSksdC5kKGUsInBvaW50c1RvQnVmZmVyIixmdW5jdGlvbigpe3JldHVybiBofSksdC5kKGUsImxvYWRJbWFnZSIsZnVuY3Rpb24oKXtyZXR1cm4gYX0pLHQuZChlLCJmZXRjaFNoYWRlciIsZnVuY3Rpb24oKXtyZXR1cm4gRX0pLHQoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBuKHAsTyl7Y29uc3QgbT1bIndlYmdsIiwiZXhwZXJpbWVudGFsLXdlYmdsIiwid2Via2l0LTNkIiwibW96LXdlYmdsIl07bGV0IGI9bnVsbDtmb3IobGV0IE09MDtNPG0ubGVuZ3RoOysrTSl7dHJ5e2I9cC5nZXRDb250ZXh0KG1bTV0sTyl9Y2F0Y2h7fWlmKGIpYnJlYWt9cmV0dXJuIGJ9ZnVuY3Rpb24gaShwLE8pe2NvbnN0IG09bihwLE8pO2lmKCFtKXRocm93IG5ldyBFcnJvcigiU29ycnksIHlvdXIgYnJvd3NlciBkb2Vzbid0IHN1cHBvcnQgV2ViR0wuIik7cmV0dXJuIG19ZnVuY3Rpb24gZihwLE8sbSl7Y29uc3QgYj1wLmNyZWF0ZVNoYWRlcihwLlZFUlRFWF9TSEFERVIpO2lmKHAuc2hhZGVyU291cmNlKGIsTykscC5jb21waWxlU2hhZGVyKGIpLCFwLmdldFNoYWRlclBhcmFtZXRlcihiLHAuQ09NUElMRV9TVEFUVVMpKXtjb25zdCBTPWBWZXJ0ZXggc2hhZGVyIGZhaWxlZCB0byBjb21waWxlLiAgVGhlIGVycm9yIGxvZyBpczoke3AuZ2V0U2hhZGVySW5mb0xvZyhiKX1gO3Rocm93IG5ldyBFcnJvcihTKX1jb25zdCBNPXAuY3JlYXRlU2hhZGVyKHAuRlJBR01FTlRfU0hBREVSKTtpZihwLnNoYWRlclNvdXJjZShNLG0pLHAuY29tcGlsZVNoYWRlcihNKSwhcC5nZXRTaGFkZXJQYXJhbWV0ZXIoTSxwLkNPTVBJTEVfU1RBVFVTKSl7Y29uc3QgUz1gRnJhZ21lbnQgc2hhZGVyIGZhaWxlZCB0byBjb21waWxlLiAgVGhlIGVycm9yIGxvZyBpczoke3AuZ2V0U2hhZGVySW5mb0xvZyhNKX1gO3Rocm93IG5ldyBFcnJvcihTKX1jb25zdCB5PXAuY3JlYXRlUHJvZ3JhbSgpO2lmKHAuYXR0YWNoU2hhZGVyKHksYikscC5hdHRhY2hTaGFkZXIoeSxNKSxwLmxpbmtQcm9ncmFtKHkpLCFwLmdldFByb2dyYW1QYXJhbWV0ZXIoeSxwLkxJTktfU1RBVFVTKSl7Y29uc3QgUz1gU2hhZGVyIHByb2dyYW0gZmFpbGVkIHRvIGxpbmsuICBUaGUgZXJyb3IgbG9nIGlzOiR7cC5nZXRQcm9ncmFtSW5mb0xvZyh5KX1gO3Rocm93IG5ldyBFcnJvcihTKX1yZXR1cm4gcC5kZWxldGVTaGFkZXIoYikscC5kZWxldGVTaGFkZXIoTSkseX1mdW5jdGlvbiBoKHAsTz1GbG9hdDMyQXJyYXksbT1udWxsKXtpZihtJiYhKG0gaW5zdGFuY2VvZiBPKSl0aHJvdyBuZXcgVHlwZUVycm9yKCJXcm9uZyBidWZmZXIgdHlwZS4iKTtpZihwPT1udWxsfHxwIGluc3RhbmNlb2YgTylyZXR1cm4gcDtpZihwWzBdPT1udWxsfHxwWzBdLmxlbmd0aD09bnVsbClyZXR1cm4gbT8obS5zZXQocCwwKSxtKTpuZXcgTyhwKTtjb25zdCBiPXBbMF0ubGVuZ3RoLE09cC5sZW5ndGg7bXx8KG09bmV3IE8oYipNKSk7bGV0IHk9MDtmb3IobGV0IFM9MDtTPE07UysrKWZvcihsZXQgcz0wO3M8YjtzKyspbVt5KytdPXBbU11bc107cmV0dXJuIG19Y29uc3QgdT17fTtmdW5jdGlvbiBhKHAse3VzZUltYWdlQml0bWFwOk89ITAsYWxpYXM6bT1udWxsfT17fSl7aWYoIXVbcF0pe2lmKHR5cGVvZiBJbWFnZT09ImZ1bmN0aW9uIil7Y29uc3QgYj1uZXcgSW1hZ2U7dHlwZW9mIHA9PSJzdHJpbmciJiYhKHR5cGVvZiBsb2NhdGlvbj09Im9iamVjdCImJi9eZmlsZTovLnRlc3QobG9jYXRpb24uaHJlZikpJiYhL15kYXRhOi8udGVzdChwKSYmKGIuY3Jvc3NPcmlnaW49ImFub255bW91cyIpLHVbcF09bmV3IFByb21pc2UoTT0+e2Iub25sb2FkPWZ1bmN0aW9uKCl7TyYmdHlwZW9mIGNyZWF0ZUltYWdlQml0bWFwPT0iZnVuY3Rpb24iP2NyZWF0ZUltYWdlQml0bWFwKGIse2ltYWdlT3JpZW50YXRpb246ImZsaXBZIn0pLnRoZW4oeT0+e3VbcF09eSxtJiYodVttXT15KSxNKHkpfSk6KHVbcF09YixtJiYodVttXT1iKSxNKGIpKX0sYi5zcmM9cH0pLG0mJih1W21dPXVbcF0pfWVsc2UgaWYodHlwZW9mIGZldGNoPT0iZnVuY3Rpb24iKXJldHVybiBmZXRjaChwLHttZXRob2Q6IkdFVCIsbW9kZToiY29ycyIsY2FjaGU6ImRlZmF1bHQifSkudGhlbihiPT5iLmJsb2IoKSkudGhlbihiPT5jcmVhdGVJbWFnZUJpdG1hcChiLHtpbWFnZU9yaWVudGF0aW9uOiJmbGlwWSJ9KS50aGVuKE09Pih1W3BdPU0sbSYmKHVbbV09TSksTSkpKX1yZXR1cm4gdVtwXX1jb25zdCBkPXt9O2FzeW5jIGZ1bmN0aW9uIEUocCl7aWYoZFtwXSlyZXR1cm4gZFtwXTtjb25zdCBPPWF3YWl0IGZldGNoKHApO2lmKE8uc3RhdHVzPj0yMDAmJk8uc3RhdHVzPDMwMCl7Y29uc3QgbT1hd2FpdCBPLnRleHQoKTtyZXR1cm4gZFtwXT1tLG19dGhyb3cgbmV3IEVycm9yKCJTaGFkZXIgbG9hZGVkIGVycm9yLiIpfX0sZnVuY3Rpb24oZyxlLHQpe3QucihlKSxlLmRlZmF1bHQ9YGF0dHJpYnV0ZSB2ZWMzIGFfdmVydGV4UG9zaXRpb247Cgp2b2lkIG1haW4oKSB7CiAgZ2xfUG9pbnRTaXplID0gMS4wOwogIGdsX1Bvc2l0aW9uID0gdmVjNChhX3ZlcnRleFBvc2l0aW9uLCAxKTsKfWB9LGZ1bmN0aW9uKGcsZSx0KXt0LnIoZSksZS5kZWZhdWx0PWAjaWZkZWYgR0xfRVMKcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7CiNlbmRpZgoKdm9pZCBtYWluKCkgewogIGdsX0ZyYWdDb2xvciA9IHZlYzQoMC4wLCAwLjAsIDAuMCwgMC4xKTsKfWB9LGZ1bmN0aW9uKGcsZSx0KXt0LnIoZSksZS5kZWZhdWx0PWBhdHRyaWJ1dGUgdmVjNCBhX3ZlcnRleFBvc2l0aW9uOwphdHRyaWJ1dGUgdmVjMiBhX3ZlcnRleFRleHR1cmVDb29yZDsKdmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7Cgp2b2lkIG1haW4oKSB7CiAgZ2xfUG9pbnRTaXplID0gMS4wOwogIGdsX1Bvc2l0aW9uID0gYV92ZXJ0ZXhQb3NpdGlvbjsKICB2VGV4dHVyZUNvb3JkID0gYV92ZXJ0ZXhUZXh0dXJlQ29vcmQ7Cn1gfSxmdW5jdGlvbihnLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBofSk7dmFyIG49dCgyMSksaT10KDI1KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3QgZj1TeW1ib2woInRyYW5zZm9ybSIpO2NsYXNzIGh7Y29uc3RydWN0b3IoYSxkKXt0aGlzLmNvbnRleHQ9YS5nZXRDb250ZXh0KCIyZCIpLHRoaXMub3B0aW9ucz1kLHRoaXNbZl09WzEsMCwwLDEsMCwwXX1jcmVhdGVUZXh0dXJlKGEpe3JldHVybntfaW1nOmF9fWFzeW5jIGxvYWRUZXh0dXJlKGEpe2NvbnN0IGQ9YXdhaXQgbi5kZWZhdWx0LmxvYWRJbWFnZShhLHt1c2VJbWFnZUJpdG1hcDohMX0pO3JldHVybiB0aGlzLmNyZWF0ZVRleHR1cmUoZCl9ZGVsZXRlVGV4dHVyZShhKXtyZXR1cm4gYX1jbGVhcihhLGQsRSxwKXtjb25zdCBPPXRoaXMuY29udGV4dDthPWF8fDAsZD1kfHwwLEU9RXx8Ty5jYW52YXMud2lkdGgtYSxwPXB8fE8uY2FudmFzLmhlaWdodC1kLE8uY2xlYXJSZWN0KGEsZCxFLHApfWRyYXdNZXNoQ2xvdWQoYSx7Y2xlYXI6ZD0hMX09e30pe2NvbnN0IEU9W107Zm9yKGxldCBwPTA7cDxhLmFtb3VudDtwKyspe2NvbnN0IE89YS5nZXRUcmFuc2Zvcm0ocCk7bGV0IG09YS5nZXRUZXh0dXJlRnJhbWUocCk7bSYmKG09bS5faW1nKTtjb25zdCBiPWEuZ2V0RmlsdGVyKHApLHtmaWxsOk0sc3Ryb2tlOnl9PWEuZ2V0Q2xvdWRSR0JBKHApO0UucHVzaCh7bWVzaDphLm1lc2gsX2Nsb3VkT3B0aW9uczpbTSx5LG0sTyxiXX0pfWEuYmVmb3JlUmVuZGVyJiZhLmJlZm9yZVJlbmRlcih0aGlzLmNvbnRleHQsYSksdGhpcy5kcmF3TWVzaGVzKEUse2NsZWFyOmQsaG9vazohMX0pLGEuYWZ0ZXJSZW5kZXImJmEuYWZ0ZXJSZW5kZXIodGhpcy5jb250ZXh0LGEpfWRyYXdNZXNoZXMoYSx7Y2xlYXI6ZD0hMSxob29rOkU9ITB9PXt9KXtjb25zdCBwPXRoaXMuY29udGV4dDtkJiZwLmNsZWFyUmVjdCgwLDAscC5jYW52YXMud2lkdGgscC5jYW52YXMuaGVpZ2h0KTtsZXQgTz1udWxsO2NvbnN0e3dpZHRoOm0saGVpZ2h0OmJ9PXAuY2FudmFzLE09YS5sZW5ndGg7YS5mb3JFYWNoKCh5LFMpPT57bGV0IHMsYyxsLHYsVDtFJiZ5LmJlZm9yZVJlbmRlciYmeS5iZWZvcmVSZW5kZXIocCx5KSx5Ll9jbG91ZE9wdGlvbnMmJihbcyxjLGwsdixUXT15Ll9jbG91ZE9wdGlvbnMseT15Lm1lc2gpO2xldCBSPXkuZmlsdGVyO2lmKFQmJihSPVI/YCR7Un0gJHtUfWA6VCksUiYmIXRoaXMuZmlsdGVyQnVmZmVyJiZ0aGlzLmZpbHRlckJ1ZmZlciE9PSExKXtjb25zdCBMPW4uZGVmYXVsdC5jcmVhdGVDYW52YXMobSxiKTtMP3RoaXMuZmlsdGVyQnVmZmVyPUwuZ2V0Q29udGV4dCgiMmQiKTp0aGlzLmZpbHRlckJ1ZmZlcj0hMX1PJiZPIT09UiYmKE9iamVjdChpLmFwcGx5RmlsdGVyKSh0aGlzLmZpbHRlckJ1ZmZlcixPKSxwLmRyYXdJbWFnZSh0aGlzLmZpbHRlckJ1ZmZlci5jYW52YXMsMCwwLG0sYiksdGhpcy5maWx0ZXJCdWZmZXIuY2xlYXJSZWN0KDAsMCxtLGIpLE89bnVsbCksUiYmdGhpcy5maWx0ZXJCdWZmZXI/KHRoaXMuZmlsdGVyQnVmZmVyLnNhdmUoKSx0aGlzLmZpbHRlckJ1ZmZlci50cmFuc2Zvcm0oLi4udGhpc1tmXSksT2JqZWN0KGkuZHJhd01lc2gyRCkoeSx0aGlzLmZpbHRlckJ1ZmZlciwhMSxzLGMsbCx2KSx0aGlzLmZpbHRlckJ1ZmZlci5yZXN0b3JlKCksUz09PU0tMT8oT2JqZWN0KGkuYXBwbHlGaWx0ZXIpKHRoaXMuZmlsdGVyQnVmZmVyLFIpLHAuZHJhd0ltYWdlKHRoaXMuZmlsdGVyQnVmZmVyLmNhbnZhcywwLDAsbSxiKSx0aGlzLmZpbHRlckJ1ZmZlci5jbGVhclJlY3QoMCwwLG0sYikpOk89Uik6KHAuc2F2ZSgpLHAudHJhbnNmb3JtKC4uLnRoaXNbZl0pLE9iamVjdChpLmRyYXdNZXNoMkQpKHkscCwhMSxzLGMsbCx2KSxwLnJlc3RvcmUoKSksRSYmeS5hZnRlclJlbmRlciYmeS5hZnRlclJlbmRlcihwLHkpfSl9c2V0VHJhbnNmb3JtKGEpe3RoaXNbZl09YX19fSxmdW5jdGlvbihnLGUsdCl7dC5yKGUpLChmdW5jdGlvbihuKXt2YXIgaT10KDE0KSxmPXQoMjMpLGg9dCgyNCk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IHU9e307ZnVuY3Rpb24gYShtLGIpe2NvbnN0e3N0eWxlOk0sdmFyaWFudDp5LHdlaWdodDpTLHN0cmV0Y2g6cyxzaXplOmMscHhMaW5lSGVpZ2h0OmwsZmFtaWx5OnZ9PW07cmV0dXJuIHM9PT0ibm9ybWFsIj9gJHtNfSAke3l9ICR7U30gJHtjKmJ9cHgvJHtsKmJ9cHggJHt2fWA6YCR7TX0gJHt5fSAke1N9ICR7c30gJHtjKmJ9cHgvJHtsKmJ9cHggJHt2fWB9ZnVuY3Rpb24gZChtLHtmb250OmIsZmlsbENvbG9yOk0sc3Ryb2tlQ29sb3I6eSxzdHJva2VXaWR0aDpTLHJhdGlvOnM9MSx0ZXh0Q2FudmFzOmMsY2FjaGFibGU6bD0hMX0pe2xldCB2O2lmKGwpe3Y9W20sYixTdHJpbmcoTSksU3RyaW5nKHkpLFN0cmluZyhTKV0uam9pbigiIyMjIik7Y29uc3QgVj11W3ZdO2lmKFYpcmV0dXJuIFZ9Y3x8KGM9cCgxLDEpKTtjb25zdCBUPWMuZ2V0Q29udGV4dCgiMmQiKTtULnNhdmUoKSxULmZvbnQ9YjtsZXR7d2lkdGg6Un09VC5tZWFzdXJlVGV4dChtKTtULnJlc3RvcmUoKTtjb25zdCBMPU9iamVjdChmLmRlZmF1bHQpKGIpLE49TWF0aC5tYXgoTC5weExpbmVIZWlnaHQsTC5weEhlaWdodCoxLjEzKTsvaXRhbGljfG9ibGlxdWUvLnRlc3QoYikmJihSKz1OKk1hdGgudGFuKDE1Kk1hdGguUEkvMTgwKSksIU0mJiF5JiYoTT0iIzAwMCIpO2NvbnN0IEE9VC5jYW52YXMsdz1NYXRoLmNlaWwoUiksQj1NYXRoLmNlaWwoTik7QS53aWR0aD1NYXRoLnJvdW5kKHcqcyksQS5oZWlnaHQ9TWF0aC5yb3VuZChCKnMpLFQuc2F2ZSgpLFQuZm9udD1hKEwscyksVC50ZXh0QWxpZ249ImNlbnRlciIsVC50ZXh0QmFzZWxpbmU9Im1pZGRsZSI7Y29uc3QgRD1BLmhlaWdodCouNStMLnB4SGVpZ2h0Ki4wNSpzLEk9QS53aWR0aCouNTtpZihNKXtpZihBcnJheS5pc0FycmF5KE0pKU09T2JqZWN0KGguZGVmYXVsdCkoTSk7ZWxzZSBpZihNLnZlY3Rvcil7bGV0IFY7Y29uc3R7dmVjdG9yOkosY29sb3JzOl99PU07Si5sZW5ndGg9PT02P1Y9VC5jcmVhdGVSYWRpYWxHcmFkaWVudCguLi5KKTpWPVQuY3JlYXRlTGluZWFyR3JhZGllbnQoLi4uSiksXy5mb3JFYWNoKCh7b2Zmc2V0OnN0LGNvbG9yOkd9KT0+e1YuYWRkQ29sb3JTdG9wKHN0LEcpfSksTT1WfVQuZmlsbFN0eWxlPU0sVC5maWxsVGV4dChtLEksRCl9aWYoeSl7aWYoVC5saW5lV2lkdGg9UypzLEFycmF5LmlzQXJyYXkoeSkpeT1PYmplY3QoaC5kZWZhdWx0KSh5KTtlbHNlIGlmKHkudmVjdG9yKXtsZXQgVjtjb25zdHt2ZWN0b3I6Sixjb2xvcnM6X309eTtKLmxlbmd0aD09PTY/Vj1ULmNyZWF0ZVJhZGlhbEdyYWRpZW50KC4uLkopOlY9VC5jcmVhdGVMaW5lYXJHcmFkaWVudCguLi5KKSxfLmZvckVhY2goKHtvZmZzZXQ6c3QsY29sb3I6R30pPT57Vi5hZGRDb2xvclN0b3Aoc3QsRyl9KSx5PVZ9VC5zdHJva2VTdHlsZT15LFQuc3Ryb2tlVGV4dChtLEksRCl9VC5yZXN0b3JlKCk7Y29uc3Qgaj17aW1hZ2U6YyxyZWN0OlswLDAsdyxCXX07cmV0dXJuIGwmJih1W3ZdPWopLGp9bGV0IEU9ITE7aWYodHlwZW9mIG5hdmlnYXRvcj09Im9iamVjdCImJnR5cGVvZiBuYXZpZ2F0b3IudXNlckFnZW50PT0ic3RyaW5nIil7Y29uc3QgbT1uYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2Nocm9tZVwvKFxkKykvKTttJiYoRT1OdW1iZXIobVsxXSk8NzApfWZ1bmN0aW9uIHAobSxiLE09e30pe2NvbnN0IHk9TS5vZmZzY3JlZW58fCFFJiZNLm9mZnNjcmVlbiE9PSExO2xldCBTO3JldHVybiB0eXBlb2YgbjwidSImJnR5cGVvZiBuLmNyZWF0ZUNhbnZhcz09ImZ1bmN0aW9uIj9TPW4uY3JlYXRlQ2FudmFzKG0sYixNKTp5JiZ0eXBlb2YgT2Zmc2NyZWVuQ2FudmFzPT0iZnVuY3Rpb24iP1M9bmV3IE9mZnNjcmVlbkNhbnZhcyhtLGIpOihTPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImNhbnZhcyIpLFMud2lkdGg9bSxTLmhlaWdodD1iKSxTfWNvbnN0IE89e2NyZWF0ZUNhbnZhczpwLGNyZWF0ZVRleHQ6ZCxsb2FkSW1hZ2U6aS5kZWZhdWx0LmxvYWRJbWFnZX07ZS5kZWZhdWx0PU99KS5jYWxsKHRoaXMsdCgyMikpfSxmdW5jdGlvbihnLGUpe3ZhciB0O3Q9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc30oKTt0cnl7dD10fHxuZXcgRnVuY3Rpb24oInJldHVybiB0aGlzIikoKX1jYXRjaHt0eXBlb2Ygd2luZG93PT0ib2JqZWN0IiYmKHQ9d2luZG93KX1nLmV4cG9ydHM9dH0sZnVuY3Rpb24oZyxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gTX0pLHQoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBuKHksUyl7aWYodHlwZW9mIHk9PSJzdHJpbmciKXtjb25zdCBsPXkudHJpbSgpLm1hdGNoKC9eKFtcZC5dKykocHh8cHR8cGN8aW58Y218bW18ZW18ZXh8cmVtfHF8dnd8dmh8dm1heHx2bWlufCUpJC8pO2w/eT17c2l6ZTpwYXJzZUZsb2F0KGxbMV0pLHVuaXQ6bFsyXX06eT17c2l6ZTpwYXJzZUludCh5LDEwKSx1bml0OiJweCJ9fWxldHtzaXplOnMsdW5pdDpjfT15O2lmKGM9PT0icHQiKXMvPS43NTtlbHNlIGlmKGM9PT0icGMiKXMqPTE2O2Vsc2UgaWYoYz09PSJpbiIpcyo9OTY7ZWxzZSBpZihjPT09ImNtIilzKj05Ni8yLjU0O2Vsc2UgaWYoYz09PSJtbSIpcyo9OTYvMjUuNDtlbHNlIGlmKGM9PT0iZW0ifHxjPT09InJlbSJ8fGM9PT0iZXgiKXtpZighUyYmdHlwZW9mIGdldENvbXB1dGVkU3R5bGU9PSJmdW5jdGlvbiImJnR5cGVvZiBkb2N1bWVudDwidSIpe2NvbnN0IGw9Z2V0Q29tcHV0ZWRTdHlsZShkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpLmZvbnRTaXplO1M9bihsLDE2KX1zKj1TLGM9PT0iZXgiJiYocy89Mil9ZWxzZSBpZihjPT09InEiKXMqPTk2LzI1LjQvNDtlbHNlIGlmKGM9PT0idncifHxjPT09InZoIil7aWYodHlwZW9mIGRvY3VtZW50PCJ1Iil7Y29uc3QgbD1jPT09InZ3Ij9kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGg6ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodDtzKj1sLzEwMH19ZWxzZSBpZigoYz09PSJ2bWF4Inx8Yz09PSJ2bWluIikmJnR5cGVvZiBkb2N1bWVudDwidSIpe2NvbnN0IGw9ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoLHY9ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodDtjPT09InZtYXgiP3MqPU1hdGgubWF4KGwsdikvMTAwOnMqPU1hdGgubWluKGwsdikvMTAwfXJldHVybiBzfWNvbnN0IGk9ImJvbGR8Ym9sZGVyfGxpZ2h0ZXJ8WzEtOV0wMCIsZj0iaXRhbGljfG9ibGlxdWUiLGg9InNtYWxsLWNhcHMiLHU9InVsdHJhLWNvbmRlbnNlZHxleHRyYS1jb25kZW5zZWR8Y29uZGVuc2VkfHNlbWktY29uZGVuc2VkfHNlbWktZXhwYW5kZWR8ZXhwYW5kZWR8ZXh0cmEtZXhwYW5kZWR8dWx0cmEtZXhwYW5kZWQiLGE9InB4fHB0fHBjfGlufGNtfG1tfGVtfGV4fHJlbXxxfHZ3fHZofHZtYXh8dm1pbnwlIixkPWAnKFteJ10rKSd8IihbXiJdKykifChbXFx3LV18W+S4gC3pvqVdKStgLEU9bmV3IFJlZ0V4cChgKCR7aX0pICtgLCJpIikscD1uZXcgUmVnRXhwKGAoJHtmfSkgK2AsImkiKSxPPW5ldyBSZWdFeHAoYCgke2h9KSArYCwiaSIpLG09bmV3IFJlZ0V4cChgKCR7dX0pICtgLCJpIiksYj1uZXcgUmVnRXhwKCIoW1xcZFxcLl0rKSgiK2ErIikoPzpcXC8oW1xcZFxcLl0rKSgiK2ErIikpPyAqKCg/OiIrZCsiKSggKiwgKig/OiIrZCsiKSkqKSIpO2Z1bmN0aW9uIE0oeSxTKXtjb25zdCBzPWIuZXhlYyh5KTtpZighcylyZXR1cm47Y29uc3QgYz1wYXJzZUZsb2F0KHNbM10pLGw9e3dlaWdodDoibm9ybWFsIixzdHlsZToibm9ybWFsIixzdHJldGNoOiJub3JtYWwiLHZhcmlhbnQ6Im5vcm1hbCIsc2l6ZTpwYXJzZUZsb2F0KHNbMV0pLHVuaXQ6c1syXSxsaW5lSGVpZ2h0Ok51bWJlci5pc0Zpbml0ZShjKT9jOnZvaWQgMCxsaW5lSGVpZ2h0VW5pdDpzWzRdLGZhbWlseTpzWzVdLnJlcGxhY2UoLyAqLCAqL2csIiwiKX0sdj15LnN1YnN0cmluZygwLHMuaW5kZXgpLFQ9RS5leGVjKHYpLFI9cC5leGVjKHYpLEw9Ty5leGVjKHYpLE49bS5leGVjKHYpO3JldHVybiBUJiYobC53ZWlnaHQ9VFsxXSksUiYmKGwuc3R5bGU9UlsxXSksTCYmKGwudmFyaWFudD1MWzFdKSxOJiYobC5zdHJldGNoPU5bMV0pLGwucHhIZWlnaHQ9bih7c2l6ZTpsLnNpemUsdW5pdDpsLnVuaXR9LFMpLGwucHhMaW5lSGVpZ2h0PW4oe3NpemU6bC5saW5lSGVpZ2h0fHxsLnNpemUsdW5pdDpsLmxpbmVIZWlnaHRVbml0fHxsLnVuaXR9LFMpLGx9fSxmdW5jdGlvbihnLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBufSksdCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIG4oaSl7cmV0dXJuYHJnYmEoJHtpLm1hcCgoZixoKT0+aDwzP01hdGgucm91bmQoZioyNTUpOmYpLmpvaW4oKX0pYH19LGZ1bmN0aW9uKGcsZSx0KXt0LnIoZSksdC5kKGUsImFwcGx5RmlsdGVyIixmdW5jdGlvbigpe3JldHVybiB1fSksdC5kKGUsImRyYXdNZXNoMkQiLGZ1bmN0aW9uKCl7cmV0dXJuIGR9KTt2YXIgbj10KDEpLGk9dCgyNCksZj10KDIzKSxoPXQoMjYpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiB1KEUscCl7Y29uc3QgTz1FLmNhbnZhcztFLnNhdmUoKSxFLmZpbHRlcj1wLEUuZHJhd0ltYWdlKE8sMCwwLE8ud2lkdGgsTy5oZWlnaHQpLEUucmVzdG9yZSgpfWZ1bmN0aW9uIGEoRSxwKXtjb25zdCBPPS9yZ2JhXCgoXGQrKSwoXGQrKSwoXGQrKSwoXGQrKVwpLztFPUUubWF0Y2goTykuc2xpY2UoMSw1KS5tYXAoTnVtYmVyKSxwPXAubWF0Y2goTykuc2xpY2UoMSw1KS5tYXAoTnVtYmVyKTtjb25zdCBtPVtdLGI9cFszXTtmb3IobGV0IE09MDtNPDQ7TSsrKW1bTV09T2JqZWN0KGgubWl4KShFW01dLHBbTV0sYik7cmV0dXJuYHJnYmEoJHttLmpvaW4oKX0pYH1mdW5jdGlvbiBkKEUscCxPPSEwLG09bnVsbCxiPW51bGwsTT1udWxsLHk9bnVsbCl7cC5zYXZlKCk7bGV0IFM9ITEscz0hMTtpZihwLmdsb2JhbEFscGhhPUUuZ2V0T3BhY2l0eSgpLEUuX3VwZGF0ZU1hdHJpeCYmRS50cmFuc2Zvcm1TY2FsZS9FLmNvbnRvdXJzLnNjYWxlPjEuNSYmRS5hY2N1cmF0ZShFLnRyYW5zZm9ybVNjYWxlKSxFLmxpbmVXaWR0aCl7bGV0IHY9RS5ncmFkaWVudCYmRS5ncmFkaWVudC5zdHJva2U7aWYodil7Y29uc3R7dmVjdG9yOlQsY29sb3JzOlJ9PXY7aWYoVC5sZW5ndGg9PT02KXY9cC5jcmVhdGVSYWRpYWxHcmFkaWVudCguLi5UKTtlbHNlIGlmKFQubGVuZ3RoPT09NCl2PXAuY3JlYXRlTGluZWFyR3JhZGllbnQoLi4uVCk7ZWxzZSBpZihULmxlbmd0aD09PTMpdj1wLmNyZWF0ZUNpcmN1bGFyR3JhZGllbnQoLi4uVCk7ZWxzZSB0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIHZlY3RvciBkaW1lbnNpb24uIik7Ui5mb3JFYWNoKCh7b2Zmc2V0OkwsY29sb3I6Tn0pPT57bGV0IEE9T2JqZWN0KGkuZGVmYXVsdCkoTik7YiYmKEE9YShBLGIpKSx2LmFkZENvbG9yU3RvcChMLEEpfSkscC5zdHJva2VTdHlsZT12LFM9ITB9ZWxzZSBFLnN0cm9rZVN0eWxlJiYoYj9wLnN0cm9rZVN0eWxlPWEoRS5zdHJva2VTdHlsZSxiKTpwLnN0cm9rZVN0eWxlPUUuc3Ryb2tlU3R5bGUsUz0hMCl9UyYmKHAubGluZVdpZHRoPUUubGluZVdpZHRoLHAubGluZUpvaW49RS5saW5lSm9pbixwLmxpbmVDYXA9RS5saW5lQ2FwLHAubWl0ZXJMaW1pdD1FLm1pdGVyTGltaXQsRS5saW5lRGFzaCYmKHAuc2V0TGluZURhc2goRS5saW5lRGFzaCksRS5saW5lRGFzaE9mZnNldCYmKHAubGluZURhc2hPZmZzZXQ9RS5saW5lRGFzaE9mZnNldCkpKTtsZXQgYz1FLmdyYWRpZW50JiZFLmdyYWRpZW50LmZpbGw7aWYoYyl7Y29uc3R7dmVjdG9yOnYsY29sb3JzOlR9PWM7aWYodi5sZW5ndGg9PT02KWM9cC5jcmVhdGVSYWRpYWxHcmFkaWVudCguLi52KTtlbHNlIGlmKHYubGVuZ3RoPT09NCljPXAuY3JlYXRlTGluZWFyR3JhZGllbnQoLi4udik7ZWxzZSBpZih2Lmxlbmd0aD09PTMpYz1wLmNyZWF0ZUNpcmN1bGFyR3JhZGllbnQoLi4udik7ZWxzZSB0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIHZlY3RvciBkaW1lbnNpb24uIik7VC5mb3JFYWNoKCh7b2Zmc2V0OlIsY29sb3I6TH0pPT57bGV0IE49T2JqZWN0KGkuZGVmYXVsdCkoTCk7YiYmKE49YShOLGIpKSxjLmFkZENvbG9yU3RvcChSLE4pfSkscC5maWxsU3R5bGU9YyxzPSEwfWVsc2UgRS5maWxsU3R5bGUmJihtP3AuZmlsbFN0eWxlPWEoRS5maWxsU3R5bGUsbSk6cC5maWxsU3R5bGU9RS5maWxsU3R5bGUscz0hMCk7aWYoeSYmcC50cmFuc2Zvcm0oLi4ueSkscC50cmFuc2Zvcm0oLi4uRS50cmFuc2Zvcm1NYXRyaXgpLEUuY2xpcFBhdGgpe2NvbnN0IHY9RS5jbGlwUGF0aCxUPW5ldyBQYXRoMkQodik7cC5jbGlwKFQpfWNvbnN0IGw9RS5jb250b3Vycy5sZW5ndGg7aWYoRS5jb250b3Vycy5mb3JFYWNoKCh2LFQpPT57Y29uc3QgUj12Lmxlbmd0aCxMPVI+MSYmbi52ZWMyLmVxdWFscyh2WzBdLHZbUi0xXSksTj1UPT09bC0xJiZFLnRleHR1cmU7aWYodiYmUj4wKXtpZihzfHxTfHxOKXtwLmJlZ2luUGF0aCgpLHAubW92ZVRvKC4uLnZbMF0pO2ZvcihsZXQgQT0xO0E8UjtBKyspQT09PVItMSYmTD9wLmNsb3NlUGF0aCgpOnAubGluZVRvKC4uLnZbQV0pfWlmKHMmJnAuZmlsbChFLmZpbGxSdWxlKSxOKXtwLnNhdmUoKSxwLmNsaXAoKTtsZXR7aW1hZ2U6QSxvcHRpb25zOnd9PUUudGV4dHVyZTtpZihNJiYoQT1NKSx3LnJlcGVhdCYmY29uc29sZS53YXJuKCJDb250ZXh0IDJEIG5vdCBzdXBwb3J0ZWQgaW1hZ2UgcmVwZWF0IHlldC4iKSxBLmZvbnQpe3cuc2NhbGUmJmNvbnNvbGUud2FybigiQ29udGV4dCAyRCBub3Qgc3VwcG9ydGVkIHRleHQgc2NhbGUgeWV0LiIpLHcuc3JjUmVjdCYmY29uc29sZS53YXJuKCJDb250ZXh0IDJEIG5vdCBzdXBwb3J0ZWQgdGV4dCBzcmNSZWN0IHlldC4iKTtsZXR7Zm9udDpCLGZpbGxDb2xvcjpELHN0cm9rZUNvbG9yOkksc3Ryb2tlV2lkdGg6aix0ZXh0OlZ9PUE7IUQmJiFJJiYoRD0iIzAwMCIpLEFycmF5LmlzQXJyYXkoRCkmJihEPU9iamVjdChpLmRlZmF1bHQpKEQpKSxBcnJheS5pc0FycmF5KEkpJiYoST1PYmplY3QoaS5kZWZhdWx0KShJKSkscC5mb250PUI7Y29uc3R7d2lkdGg6Sn09cC5tZWFzdXJlVGV4dChWKSxfPU9iamVjdChmLmRlZmF1bHQpKEIpLHN0PU1hdGgubWF4KF8ucHhMaW5lSGVpZ2h0LF8ucHhIZWlnaHQqMS4xMyk7cC50ZXh0QWxpZ249ImNlbnRlciIscC50ZXh0QmFzZWxpbmU9Im1pZGRsZSI7Y29uc3QgRz13LnJlY3QsWT1HWzBdK3N0Ki41K18ucHhIZWlnaHQqLjA2LHJ0PUdbMV0rSiouNTtHWzJdIT1udWxsJiZwLnNjYWxlKEdbMl0vSixHWzNdL3N0KSxEJiYocC5maWxsU3R5bGU9RCxwLmZpbGxUZXh0KFYscnQsWSkpLEkmJihwLmxpbmVXaWR0aD1qLHAuc3Ryb2tlU3R5bGU9SSxwLnN0cm9rZVRleHQoVixydCxZKSl9ZWxzZXtsZXQgQj13LnJlY3Q7Y29uc3QgRD13LnNyY1JlY3Q7dy5zY2FsZSYmKEI9WzAsMCxwLmNhbnZhcy53aWR0aCxwLmNhbnZhcy5oZWlnaHRdKSx3LnJvdGF0ZWQmJkImJihCPVstQlsxXSxCWzBdLEJbM10sQlsyXV0pLEQmJihCPUJ8fFswLDAsRFsyXSxEWzNdXSksdy5yb3RhdGVkJiYocC50cmFuc2xhdGUoMCxCP0JbMl06QS53aWR0aCkscC5yb3RhdGUoLS41Kk1hdGguUEkpKSxEP3AuZHJhd0ltYWdlKEEsLi4uRCwuLi5CKTpCP3AuZHJhd0ltYWdlKEEsLi4uQik6cC5kcmF3SW1hZ2UoQSwwLDApfXAucmVzdG9yZSgpfVMmJnAuc3Ryb2tlKCl9fSkscC5yZXN0b3JlKCksTyl7Y29uc3Qgdj1FLmZpbHRlcjt2JiZ1KHAsdil9fX0sZnVuY3Rpb24oZyxlLHQpe3QucihlKSx0LmQoZSwiY2xhbXAiLGZ1bmN0aW9uKCl7cmV0dXJuIG59KSx0LmQoZSwibWl4IixmdW5jdGlvbigpe3JldHVybiBpfSksdC5kKGUsInRyYW5zZm9ybVBvaW50IixmdW5jdGlvbigpe3JldHVybiBmfSksdCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIG4oaCx1LGEpe3JldHVybiB1PmEmJihbdSxhXT1bYSx1XSksaDx1P3U6aD5hP2E6aH1mdW5jdGlvbiBpKGgsdSxhKXtyZXR1cm4gaCooMS1hKSt1KmF9ZnVuY3Rpb24gZihoLHUpe2NvbnN0W2EsZF09aDtyZXR1cm5bYSp1WzBdK2QqdVsyXSt1WzRdLGEqdVsxXStkKnVbM10rdVs1XV19fSxmdW5jdGlvbihnLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBhfSk7dmFyIG49dCgyOCksaT10KDI5KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gZihkLEUscCl7Y29uc3QgTz1kLnVuaWZvcm1zfHx7fSxtPUUudW5pZm9ybXN8fHt9O2lmKE8udV90ZXhTYW1wbGVyJiZtLnVfdGV4U2FtcGxlciYmTy51X3RleFNhbXBsZXIhPT1tLnVfdGV4U2FtcGxlcilyZXR1cm4hMTtjb25zdCBiPU9iamVjdC5rZXlzKE8pLE09T2JqZWN0LmtleXMobSkseT1iLmluZGV4T2YoInVfdGV4U2FtcGxlciIpLFM9TS5pbmRleE9mKCJ1X3RleFNhbXBsZXIiKTtpZih5Pj0wJiZiLnNwbGljZSh5LDEpLFM+PTAmJk0uc3BsaWNlKFMsMSksYi5sZW5ndGghPT1NLmxlbmd0aClyZXR1cm4hMTtjb25zdCBzPWIuZXZlcnkoYz0+e2NvbnN0IGw9T1tjXSx2PW1bY107aWYobD09PXYpcmV0dXJuITA7aWYobC5sZW5ndGgmJnYubGVuZ3RoJiZsLmxlbmd0aD09PXYubGVuZ3RoKXtmb3IobGV0IFQ9MDtUPGwubGVuZ3RoO1QrKylpZihsW1RdIT09dltUXSlyZXR1cm4hMTtyZXR1cm4hMH1yZXR1cm4hMX0pO2lmKHMpe2lmKE8udV90ZXhTYW1wbGVyJiYhbS51X3RleFNhbXBsZXIpRS5zZXRUZXh0dXJlKE8udV90ZXhTYW1wbGVyLHtoaWRkZW46ITB9KTtlbHNlIGlmKCFPLnVfdGV4U2FtcGxlciYmbS51X3RleFNhbXBsZXIpZm9yKGxldCBjPTA7YzxwLmxlbmd0aDtjKyspcFtjXS5zZXRUZXh0dXJlKG0udV90ZXhTYW1wbGVyLHtoaWRkZW46ITB9KX1yZXR1cm4gc31jb25zdCBoPXt9O2Z1bmN0aW9uIHUoZCxFKXtpZihkLmxlbmd0aCl7Y29uc3QgcD1PYmplY3Qobi5kZWZhdWx0KShkLGgpO3JldHVybiBwLmVuYWJsZUJsZW5kPUUsZFswXS5maWx0ZXJDYW52YXMmJihwLmZpbHRlckNhbnZhcz0hMCkscC5wYWNrSW5kZXg9ZFswXS5wYWNrSW5kZXgscC5wYWNrTGVuZ3RoPWQubGVuZ3RoLHAuYmVmb3JlUmVuZGVyPWRbMF0uYmVmb3JlUmVuZGVyLHAucGFzcz1kWzBdLnBhc3MscC5hZnRlclJlbmRlcj1kW2QubGVuZ3RoLTFdLmFmdGVyUmVuZGVyLGQubGVuZ3RoPTAscH19ZnVuY3Rpb24qYShkLEUscD0hMSl7Y29uc3QgTz1bXSxtPWQub3B0aW9ucy5idWZmZXJTaXplO2xldCBiPTAsTT0hMTtmb3IobGV0IHk9MDt5PEUubGVuZ3RoO3krKyl7Y29uc3QgUz1FW3ldO2lmKFMgaW5zdGFuY2VvZiBpLmRlZmF1bHQpTy5sZW5ndGgmJih5aWVsZCB1KE8sTSkpLGI9MCxNPSExLHlpZWxkIFM7ZWxzZXtjb25zdCBzPVMubWVzaERhdGE7aWYocy5jbGlwUGF0aCYmIXMudW5pZm9ybXMudV9jbGlwU2FtcGxlcil7Y29uc3QgbD1kLmNyZWF0ZVRleHR1cmUocy5jbGlwUGF0aCk7cy51bmlmb3Jtcy51X2NsaXBTYW1wbGVyPWx9bGV0IGM9MDtpZigoIXB8fCFTLmNhbklnbm9yZSgpKSYmcyYmcy5wb3NpdGlvbnMubGVuZ3RoKXtTLnBhY2tJbmRleD15O2NvbnN0IGw9Uy5maWx0ZXJDYW52YXM7aWYoYz1zLnBvc2l0aW9ucy5sZW5ndGgsbHx8YitjPm0pTy5sZW5ndGgmJih5aWVsZCB1KE8sTSkpLGI9MCxNPSExO2Vsc2UgaWYoYil7Y29uc3Qgdj1PW08ubGVuZ3RoLTFdO3YmJih2LmZpbHRlckNhbnZhc3x8di5hZnRlclJlbmRlcnx8Uy5iZWZvcmVSZW5kZXJ8fHYucGFzcy5sZW5ndGh8fFMucGFzcy5sZW5ndGh8fHYucHJvZ3JhbSE9PVMucHJvZ3JhbXx8IWYodixTLE8pKSYmKHlpZWxkIHUoTyxNKSxiPTAsTT0hMSl9Ty5wdXNoKFMpLE09TXx8Uy5lbmFibGVCbGVuZCxiKz1jfXk9PT1FLmxlbmd0aC0xJiZPLmxlbmd0aCYmKHlpZWxkIHUoTyxNKSl9fX19LGZ1bmN0aW9uKGcsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIGZ9KSx0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3Qgbj17VU5TSUdORURfQllURTpVaW50OEFycmF5LFVOU0lHTkVEX1NIT1JUOlVpbnQxNkFycmF5LEJZVEU6SW50OEFycmF5LFNIT1JUOkludDE2QXJyYXksRkxPQVQ6RmxvYXQzMkFycmF5fTtmdW5jdGlvbiBpKGgsdSl7bGV0IGE9MCxkPTAsRT0wLHA9MCxPPTAsbT0wLGI9MDtjb25zdCBNPWhbMF0ucHJvZ3JhbTtmb3IobGV0IHk9MDt5PGgubGVuZ3RoO3krKyl7Y29uc3QgUz1oW3ldLm1lc2hEYXRhO2lmKFMpe2IrPVMucG9zaXRpb25zLmxlbmd0aDtjb25zdCBzPVMucG9zaXRpb25zWzBdLmxlbmd0aDthKz1TLnBvc2l0aW9ucy5sZW5ndGgqcyxkKz1TLmNlbGxzLmxlbmd0aCozLG0rPVMuYXR0cmlidXRlcy5hX2NvbG9yLmxlbmd0aCo0O2NvbnN0IGM9Uy50ZXh0dXJlQ29vcmQ7YyYmKEUrPWMubGVuZ3RoKmNbMF0ubGVuZ3RoKTtjb25zdCBsPVMuYXR0cmlidXRlcy5hX3NvdXJjZVJlY3Q7bCYmKHArPWwubGVuZ3RoKjQpO2NvbnN0IHY9Uy5hdHRyaWJ1dGVzLmFfY2xpcFVWO3YmJihPKz12Lmxlbmd0aCoyKX19aWYoKCF1LnBvc2l0aW9uc3x8dS5wb3NpdGlvbnMubGVuZ3RoPGEpJiYodS5wb3NpdGlvbnM9bmV3IEZsb2F0MzJBcnJheShhKSksKCF1LmNlbGxzfHx1LmNlbGxzLmxlbmd0aDxkKSYmKHUuY2VsbHM9bmV3IFVpbnQxNkFycmF5KGQpKSxFJiYoIXUudGV4dHVyZUNvb3JkfHx1LnRleHR1cmVDb29yZC5sZW5ndGg8RSkmJih1LnRleHR1cmVDb29yZD1uZXcgRmxvYXQzMkFycmF5KEUpKSwoIXUuYV9jb2xvcnx8dS5hX2NvbG9yLmxlbmd0aDxtKSYmKHUuYV9jb2xvcj1uZXcgVWludDhBcnJheShtKSkscCYmKCF1LmFfc291cmNlUmVjdHx8dS5hX3NvdXJjZVJlY3QubGVuZ3RoPHApJiYodS5hX3NvdXJjZVJlY3Q9bmV3IEZsb2F0MzJBcnJheShwKSksTyYmKCF1LmFfY2xpcFVWfHx1LmFfY2xpcFVWLmxlbmd0aDxPKSYmKHUuYV9jbGlwVVY9bmV3IEZsb2F0MzJBcnJheShPKSksTSl7Y29uc3QgeT1PYmplY3QuZW50cmllcyhNLl9hdHRyaWJ1dGUpLFM9TS5fYXR0cmliT3B0c3x8e307Zm9yKGxldCBzPTA7czx5Lmxlbmd0aDtzKyspe2NvbnN0W2MsbF09eVtzXTtpZihjIT09ImFfY29sb3IiJiZjIT09ImFfc291cmNlUmVjdCImJmwhPT0iaWdub3JlZCIpe2NvbnN0IHY9U1tjXT9TW2NdLnR5cGU6IkZMT0FUIixUPW5bdl0sUj1sLnNpemUqYjsoIXVbY118fHVbY10ubGVuZ3RoPFIpJiYodVtjXT1uZXcgVChSKSl9fX1yZXR1cm4gdX1mdW5jdGlvbiBmKGgsdSl7bGV0IGE9W10sZD1bXSxFPVtdLHA9W10sTz1bXSxtPVtdLGI9MCxNPTA7Y29uc3QgeT1oWzBdP2hbMF0udW5pZm9ybXN8fHt9Ont9LFM9aFswXT9oWzBdLnByb2dyYW06bnVsbDt1JiYoaShoLHUpLGQ9dS5jZWxscyxhPXUucG9zaXRpb25zLEU9dS50ZXh0dXJlQ29vcmQscD11LmFfY29sb3IsTz11LmFfc291cmNlUmVjdCxtPXUuYV9jbGlwVVYpO2xldCBzPSExLGM9ITE7Y29uc3QgbD17fTtmb3IobGV0IFQ9MDtUPGgubGVuZ3RoO1QrKyl7bGV0IFI9aFtUXTtpZihSKXtpZihSLm1lc2hEYXRhJiYoUj1SLm1lc2hEYXRhKSx1KXtjb25zdCBOPVIucG9zaXRpb25zO2ZvcihsZXQgQT0wO0E8Ti5sZW5ndGg7QSsrKXtjb25zdCB3PU5bQV0sQj0zKihiK0EpO2ZvcihsZXQgRD0wO0Q8dy5sZW5ndGg7RCsrKWFbQitEXT13W0RdfX1lbHNlIGEucHVzaCguLi5SLnBvc2l0aW9ucyk7Y29uc3QgTD1SLmNlbGxzO2ZvcihsZXQgTj0wO048TC5sZW5ndGg7TisrKXtjb25zdCBBPUxbTl07aWYodSl7Y29uc3Qgdz0zKihNK04pO2Rbd109QVswXStiLGRbdysxXT1BWzFdK2IsZFt3KzJdPUFbMl0rYn1lbHNlIGQucHVzaChbQVswXStiLEFbMV0rYixBWzJdK2JdKX1pZih1KXtjb25zdCBOPVIuYXR0cmlidXRlcy5hX2NvbG9yO2ZvcihsZXQgQT0wO0E8Ti5sZW5ndGg7QSsrKXtjb25zdCB3PU5bQV0sQj00KihiK0EpO3BbQl09d1swXSxwW0IrMV09d1sxXSxwW0IrMl09d1syXSxwW0IrM109d1szXX19ZWxzZSBwLnB1c2goLi4uUi5hdHRyaWJ1dGVzLmFfY29sb3IpO2lmKFIuYXR0cmlidXRlcy5hX3NvdXJjZVJlY3QpaWYocz0hMCx1KXtjb25zdCBOPVIuYXR0cmlidXRlcy5hX3NvdXJjZVJlY3Q7Zm9yKGxldCBBPTA7QTxOLmxlbmd0aDtBKyspe2NvbnN0IHc9TltBXSxCPTQqKGIrQSk7T1tCXT13WzBdLE9bQisxXT13WzFdLE9bQisyXT13WzJdLE9bQiszXT13WzNdfX1lbHNlIE8ucHVzaCguLi5SLmF0dHJpYnV0ZXMuYV9zb3VyY2VSZWN0KTtpZihSLmF0dHJpYnV0ZXMuYV9jbGlwVVYpaWYoYz0hMCx1KXtjb25zdCBOPVIuYXR0cmlidXRlcy5hX2NsaXBVVjtmb3IobGV0IEE9MDtBPE4ubGVuZ3RoO0ErKyl7Y29uc3Qgdz1OW0FdLEI9MiooYitBKTttW0JdPXdbMF0sbVtCKzFdPXdbMV19fWVsc2UgbS5wdXNoKC4uLlIuYXR0cmlidXRlcy5hX2NsaXBVVik7aWYoUi50ZXh0dXJlQ29vcmQpaWYodSl7Y29uc3QgTj1SLnRleHR1cmVDb29yZDtmb3IobGV0IEE9MDtBPE4ubGVuZ3RoO0ErKyl7Y29uc3Qgdz1OW0FdLEI9MyooYitBKTtmb3IobGV0IEQ9MDtEPHcubGVuZ3RoO0QrKylFW0IrRF09d1tEXX19ZWxzZSBFLnB1c2goLi4uUi50ZXh0dXJlQ29vcmQpO2lmKFMpe2NvbnN0IE49T2JqZWN0LmVudHJpZXMoUy5fYXR0cmlidXRlKTtmb3IobGV0IEE9MDtBPE4ubGVuZ3RoO0ErKyl7Y29uc3RbdyxCXT1OW0FdO2lmKHchPT0iYV9jb2xvciImJnchPT0iYV9zb3VyY2VSZWN0IiYmQiE9PSJpZ25vcmVkIilpZihsW3ddPVtdLHUpe2xbd109dVt3XTtjb25zdCBEPVIuYXR0cmlidXRlc1t3XSxJPURbMF0ubGVuZ3RoO2ZvcihsZXQgaj0wO2o8RC5sZW5ndGg7aisrKXtjb25zdCBWPURbal0sSj1JKihiK2opO2ZvcihsZXQgXz0wO188Vi5sZW5ndGg7XysrKWxbd11bSitfXT1WW19dfX1lbHNlIGxbd10ucHVzaCguLi5SLmF0dHJpYnV0ZXNbd10pfX1iKz1SLnBvc2l0aW9ucy5sZW5ndGgsTSs9Ui5jZWxscy5sZW5ndGh9fWwuYV9jb2xvcj1wLHMmJk8mJk8ubGVuZ3RoPjAmJihsLmFfc291cmNlUmVjdD1PKTtjb25zdCB2PXtwb3NpdGlvbnM6YSxjZWxsczpkLGF0dHJpYnV0ZXM6bCx1bmlmb3Jtczp5LGNlbGxzQ291bnQ6TSozLHByb2dyYW06U307cmV0dXJuIEUmJkUubGVuZ3RoJiYodi50ZXh0dXJlQ29vcmQ9RSksYyYmbS5sZW5ndGg+MCYmKGwuYV9jbGlwVVY9bSksdn19LGZ1bmN0aW9uKGcsZSx0KXt0LnIoZSk7dmFyIG49dCgxKSxpPXQoMzApLGY9dCgyNiksaD10KDMxKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gdShsLHYpe3ZhciBUPU9iamVjdC5rZXlzKGwpO2lmKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpe3ZhciBSPU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMobCk7diYmKFI9Ui5maWx0ZXIoZnVuY3Rpb24oTCl7cmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobCxMKS5lbnVtZXJhYmxlfSkpLFQucHVzaC5hcHBseShULFIpfXJldHVybiBUfWZ1bmN0aW9uIGEobCl7Zm9yKHZhciB2PTE7djxhcmd1bWVudHMubGVuZ3RoO3YrKyl7dmFyIFQ9YXJndW1lbnRzW3ZdIT1udWxsP2FyZ3VtZW50c1t2XTp7fTt2JTI/dShPYmplY3QoVCksITApLmZvckVhY2goZnVuY3Rpb24oUil7ZChsLFIsVFtSXSl9KTpPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycz9PYmplY3QuZGVmaW5lUHJvcGVydGllcyhsLE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKFQpKTp1KE9iamVjdChUKSkuZm9yRWFjaChmdW5jdGlvbihSKXtPYmplY3QuZGVmaW5lUHJvcGVydHkobCxSLE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoVCxSKSl9KX1yZXR1cm4gbH1mdW5jdGlvbiBkKGwsdixUKXtyZXR1cm4gdiBpbiBsP09iamVjdC5kZWZpbmVQcm9wZXJ0eShsLHYse3ZhbHVlOlQsZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTpsW3ZdPVQsbH1jb25zdCBFPVN5bWJvbCgibWVzaCIpLHA9U3ltYm9sKCJjb3VudCIpLE89U3ltYm9sKCJibGVuZCIpLG09U3ltYm9sKCJmaWx0ZXIiKSxiPVN5bWJvbCgidGV4dHVyZXMiKSxNPVN5bWJvbCgidGV4dHVyZU9wdGlvbnMiKSx5PVN5bWJvbCgiY2xvdWRDb2xvciIpLFM9U3ltYm9sKCJjbG91ZEZpbHRlciIpLHM9U3ltYm9sKCJidWZmZXIiKTtmdW5jdGlvbiBjKGwsdj1udWxsKXtjb25zdCBUPW5ldyBGbG9hdDMyQXJyYXkoMypsKSxSPW5ldyBGbG9hdDMyQXJyYXkoMypsKSxMPW5ldyBGbG9hdDMyQXJyYXkoNCpsKSxOPW5ldyBGbG9hdDMyQXJyYXkoNCpsKSxBPW5ldyBGbG9hdDMyQXJyYXkoNCpsKSx3PW5ldyBGbG9hdDMyQXJyYXkoNCpsKSxCPW5ldyBGbG9hdDMyQXJyYXkoNCpsKSxEPW5ldyBVaW50OEFycmF5KGwpLEk9bmV3IFVpbnQ4QXJyYXkoNCpsKSxqPW5ldyBVaW50OEFycmF5KDQqbCk7cmV0dXJuIHYmJihULnNldCh2LnRyYW5zZm9ybTAsMCksUi5zZXQodi50cmFuc2Zvcm0xLDApLEwuc2V0KHYuY29sb3IwLDApLE4uc2V0KHYuY29sb3IxLDApLEEuc2V0KHYuY29sb3IyLDApLHcuc2V0KHYuY29sb3IzLDApLEIuc2V0KHYuY29sb3I0LDApLEQuc2V0KHYuZnJhbWVJbmRleCwwKSxJLnNldCh2LmZpbGxDb2xvciwwKSxqLnNldCh2LnN0cm9rZUNvbG9yLDApKSx7YnVmZmVyU2l6ZTpsLHRyYW5zZm9ybTA6VCx0cmFuc2Zvcm0xOlIsY29sb3IwOkwsY29sb3IxOk4sY29sb3IyOkEsY29sb3IzOncsY29sb3I0OkIsZnJhbWVJbmRleDpELGZpbGxDb2xvcjpJLHN0cm9rZUNvbG9yOmp9fWUuZGVmYXVsdD1jbGFzc3tjb25zdHJ1Y3RvcihsLHY9MSx7YnVmZmVyOlQ9MWUzfT17fSl7VD1NYXRoLm1heChULHYpLHRoaXNbcF09dix0aGlzW0VdPWwsdGhpc1tzXT1jKFQpLHRoaXNbYl09W10sdGhpc1ttXT1bXSx0aGlzW3ldPSExLHRoaXNbU109ITEsdGhpc1tPXT0hMSx0aGlzLmluaXRCdWZmZXIoKX1pbml0QnVmZmVyKGw9MCl7Y29uc3Qgdj10aGlzW3BdO2ZvcihsZXQgVD1sO1Q8djtUKyspdGhpc1tzXS50cmFuc2Zvcm0wLnNldChbMSwwLDBdLFQqMyksdGhpc1tzXS50cmFuc2Zvcm0xLnNldChbMCwxLDBdLFQqMyksdGhpc1tzXS5mcmFtZUluZGV4LnNldChbLTFdLFQpLHRoaXNbc10uZmlsbENvbG9yLnNldChbMCwwLDAsMF0sVCo0KSx0aGlzW3NdLnN0cm9rZUNvbG9yLnNldChbMCwwLDAsMF0sVCo0KSx0aGlzLnNldENvbG9yVHJhbnNmb3JtKFQsbnVsbCl9Z2V0IGJ1ZmZlclNpemUoKXtyZXR1cm4gdGhpc1tzXS5idWZmZXJTaXplfWdldCBtZXNoKCl7cmV0dXJuIHRoaXNbRV19c2V0IG1lc2gobCl7dGhpc1tFXT1sLHRoaXNbYl0mJnRoaXMuc2V0VGV4dHVyZUZyYW1lcyh0aGlzW2JdLHRoaXNbTV0pfWdldCBoYXNDbG91ZENvbG9yKCl7cmV0dXJuIHRoaXNbeV19Z2V0IGhhc0Nsb3VkRmlsdGVyKCl7cmV0dXJuIHRoaXNbU119X2dldEZpbHRlcihsKXtyZXR1cm4gdGhpc1ttXVtsXT10aGlzW21dW2xdfHxbXSx0aGlzW21dW2xdfWdldEZpbHRlcihsKXtyZXR1cm4gdGhpcy5fZ2V0RmlsdGVyKGwpLmpvaW4oIiAiKX1nZXQgZW5hYmxlQmxlbmQoKXtyZXR1cm4gdGhpc1tFXS5lbmFibGVCbGVuZHx8dGhpc1tPXX1jYW5JZ25vcmUoKXtyZXR1cm4gdGhpc1tFXS5jYW5JZ25vcmUoKX1kZWxldGUobCl7aWYobD49dGhpc1twXXx8bDwwKXRocm93IG5ldyBFcnJvcigiT3V0IG9mIHJhbmdlLiIpO2NvbnN0e3RyYW5zZm9ybTA6dix0cmFuc2Zvcm0xOlQsY29sb3IwOlIsY29sb3IxOkwsY29sb3IyOk4sY29sb3IzOkEsY29sb3I0OncsZnJhbWVJbmRleDpCLGZpbGxDb2xvcjpELHN0cm9rZUNvbG9yOkl9PXRoaXNbc107di5zZXQodi5zdWJhcnJheSgzKihsKzEpKSwzKmwpLFQuc2V0KFQuc3ViYXJyYXkoMyoobCsxKSksMypsKSxSLnNldChSLnN1YmFycmF5KDQqKGwrMSkpLDQqbCksTC5zZXQoTC5zdWJhcnJheSg0KihsKzEpKSw0KmwpLE4uc2V0KE4uc3ViYXJyYXkoNCoobCsxKSksNCpsKSxBLnNldChBLnN1YmFycmF5KDQqKGwrMSkpLDQqbCksdy5zZXQody5zdWJhcnJheSg0KihsKzEpKSw0KmwpLEIuc2V0KEIuc3ViYXJyYXkobCsxKSxsKSxELnNldChELnN1YmFycmF5KDQqKGwrMSkpLDQqbCksSS5zZXQoSS5zdWJhcnJheSg0KihsKzEpKSw0KmwpO2Zvcihjb25zdCBqIGluIHRoaXNbbV0paj09PWw/ZGVsZXRlIHRoaXNbbV1bal06aj5sJiYodGhpc1ttXVtqLTFdPXRoaXNbbV1bal0sZGVsZXRlIHRoaXNbbV1bal0pO3RoaXNbcF0tLX1zZXRDb2xvclRyYW5zZm9ybShsLHYpe2lmKGw+PXRoaXNbcF18fGw8MCl0aHJvdyBuZXcgRXJyb3IoIk91dCBvZiByYW5nZS4iKTtsKj00O2NvbnN0e2NvbG9yMDpULGNvbG9yMTpSLGNvbG9yMjpMLGNvbG9yMzpOLGNvbG9yNDpBfT10aGlzW3NdO3JldHVybiB2IT1udWxsPyhULnNldChbdlswXSx2WzVdLHZbMTBdLHZbMTVdXSxsKSxSLnNldChbdlsxXSx2WzZdLHZbMTFdLHZbMTZdXSxsKSxMLnNldChbdlsyXSx2WzddLHZbMTJdLHZbMTddXSxsKSxOLnNldChbdlszXSx2WzhdLHZbMTNdLHZbMThdXSxsKSxBLnNldChbdls0XSx2WzldLHZbMTRdLHZbMTldXSxsKSx0aGlzW09dPXRoaXNbT118fHZbMThdPDEsdGhpc1tTXT0hMCk6KFQuc2V0KFsxLDAsMCwwXSxsKSxSLnNldChbMCwxLDAsMF0sbCksTC5zZXQoWzAsMCwxLDBdLGwpLE4uc2V0KFswLDAsMCwxXSxsKSxBLnNldChbMCwwLDAsMF0sbCkpLHRoaXN9Z2V0Q29sb3JUcmFuc2Zvcm0obCl7aWYobD49dGhpc1twXXx8bDwwKXRocm93IG5ldyBFcnJvcigiT3V0IG9mIHJhbmdlLiIpO2wqPTQ7Y29uc3R7Y29sb3IwOnYsY29sb3IxOlQsY29sb3IyOlIsY29sb3IzOkwsY29sb3I0Ok59PXRoaXNbc107cmV0dXJuW3ZbbF0sVFtsXSxSW2xdLExbbF0sTltsXSx2W2wrMV0sVFtsKzFdLFJbbCsxXSxMW2wrMV0sTltsKzFdLHZbbCsyXSxUW2wrMl0sUltsKzJdLExbbCsyXSxOW2wrMl0sdltsKzNdLFRbbCszXSxSW2wrM10sTFtsKzNdLE5bbCszXV19dHJhbnNmb3JtQ29sb3IobCx2KXtsZXQgVD10aGlzLmdldENvbG9yVHJhbnNmb3JtKGwpO3JldHVybiBUPU9iamVjdChpLm11bHRpcGx5KShULHYpLHRoaXMuc2V0Q29sb3JUcmFuc2Zvcm0obCxUKSx0aGlzfXNldEZpbGxDb2xvcihsLHYpe2lmKGw+PXRoaXNbcF18fGw8MCl0aHJvdyBuZXcgRXJyb3IoIk91dCBvZiByYW5nZS4iKTt0eXBlb2Ygdj09InN0cmluZyImJih2PU9iamVjdChoLmRlZmF1bHQpKHYpKSx2WzNdPjAmJih0aGlzW3ldPSEwKSx0aGlzW3NdLmZpbGxDb2xvci5zZXQodi5tYXAoVD0+TWF0aC5yb3VuZCgyNTUqVCkpLDQqbCl9c2V0U3Ryb2tlQ29sb3IobCx2KXtpZihsPj10aGlzW3BdfHxsPDApdGhyb3cgbmV3IEVycm9yKCJPdXQgb2YgcmFuZ2UuIik7dHlwZW9mIHY9PSJzdHJpbmciJiYodj1PYmplY3QoaC5kZWZhdWx0KSh2KSksdlszXT4wJiYodGhpc1t5XT0hMCksdGhpc1tzXS5zdHJva2VDb2xvci5zZXQodi5tYXAoVD0+TWF0aC5yb3VuZCgyNTUqVCkpLDQqbCl9Z2V0Q2xvdWRSR0JBKGwpe2lmKGw+PXRoaXNbcF18fGw8MCl0aHJvdyBuZXcgRXJyb3IoIk91dCBvZiByYW5nZS4iKTtsKj00O2NvbnN0e2ZpbGxDb2xvcjp2LHN0cm9rZUNvbG9yOlR9PXRoaXNbc10sUj1bdltsXSx2W2wrMV0sdltsKzJdLHZbbCszXV0sTD1bVFtsXSxUW2wrMV0sVFtsKzJdLFRbbCszXV07cmV0dXJuIFJbM10vPTI1NSxMWzNdLz0yNTUse2ZpbGw6YHJnYmEoJHtSLmpvaW4oKX0pYCxzdHJva2U6YHJnYmEoJHtMLmpvaW4oKX0pYH19Z3JheXNjYWxlKGwsdil7dGhpcy50cmFuc2Zvcm1Db2xvcihsLE9iamVjdChpLmdyYXlzY2FsZSkodikpLHRoaXMuX2dldEZpbHRlcihsKS5wdXNoKGBncmF5c2NhbGUoJHsxMDAqdn0lKWApfWJyaWdodG5lc3MobCx2KXt0aGlzLnRyYW5zZm9ybUNvbG9yKGwsT2JqZWN0KGkuYnJpZ2h0bmVzcykodikpLHRoaXMuX2dldEZpbHRlcihsKS5wdXNoKGBicmlnaHRuZXNzKCR7MTAwKnZ9JSlgKX1zYXR1cmF0ZShsLHYpe3RoaXMudHJhbnNmb3JtQ29sb3IobCxPYmplY3QoaS5zYXR1cmF0ZSkodikpLHRoaXMuX2dldEZpbHRlcihsKS5wdXNoKGBzYXR1cmF0ZSgkezEwMCp2fSUpYCl9Y29udHJhc3QobCx2KXt0aGlzLnRyYW5zZm9ybUNvbG9yKGwsT2JqZWN0KGkuY29udHJhc3QpKHYpKSx0aGlzLl9nZXRGaWx0ZXIobCkucHVzaChgY29udHJhc3QoJHsxMDAqdn0lKWApfWludmVydChsLHYpe3RoaXMudHJhbnNmb3JtQ29sb3IobCxPYmplY3QoaS5pbnZlcnQpKHYpKSx0aGlzLl9nZXRGaWx0ZXIobCkucHVzaChgaW52ZXJ0KCR7MTAwKnZ9JSlgKX1zZXBpYShsLHYpe3RoaXMudHJhbnNmb3JtQ29sb3IobCxPYmplY3QoaS5zZXBpYSkodikpLHRoaXMuX2dldEZpbHRlcihsKS5wdXNoKGBzZXBpYSgkezEwMCp2fSUpYCl9b3BhY2l0eShsLHYpe3RoaXMudHJhbnNmb3JtQ29sb3IobCxPYmplY3QoaS5vcGFjaXR5KSh2KSksdGhpcy5fZ2V0RmlsdGVyKGwpLnB1c2goYG9wYWNpdHkoJHsxMDAqdn0lKWApfWh1ZVJvdGF0ZShsLHYpe3RoaXMudHJhbnNmb3JtQ29sb3IobCxPYmplY3QoaS5odWVSb3RhdGUpKHYpKSx0aGlzLl9nZXRGaWx0ZXIobCkucHVzaChgaHVlLXJvdGF0ZSgke3Z9ZGVnKWApfXNldFRyYW5zZm9ybShsLHYpe2lmKGw+PXRoaXNbcF18fGw8MCl0aHJvdyBuZXcgRXJyb3IoIk91dCBvZiByYW5nZS4iKTtsKj0zLHY9PW51bGwmJih2PVsxLDAsMCwxLDAsMF0pO2NvbnN0e3RyYW5zZm9ybTA6VCx0cmFuc2Zvcm0xOlJ9PXRoaXNbc107cmV0dXJuIFQuc2V0KFt2WzBdLHZbMl0sdls0XV0sbCksUi5zZXQoW3ZbMV0sdlszXSx2WzVdXSxsKSx0aGlzfWdldFRyYW5zZm9ybShsKXtpZihsPj10aGlzW3BdfHxsPDApdGhyb3cgbmV3IEVycm9yKCJPdXQgb2YgcmFuZ2UuIik7bCo9Mztjb25zdHt0cmFuc2Zvcm0wOnYsdHJhbnNmb3JtMTpUfT10aGlzW3NdO3JldHVyblt2W2xdLFRbbF0sdltsKzFdLFRbbCsxXSx2W2wrMl0sVFtsKzJdXX1nZXRUZXh0dXJlRnJhbWUobCl7cmV0dXJuIHRoaXNbYl1bdGhpc1tzXS5mcmFtZUluZGV4W2xdXX1zZXRUZXh0dXJlRnJhbWVzKGw9W10sdj17fSl7aWYobC5sZW5ndGg+MTIpdGhyb3cgbmV3IEVycm9yKCJNYXggZnJhbWVzIGV4Y2VlZC4gQWxsb3cgMTIgZnJhbWVzLiIpO2wubGVuZ3RoJiZ0aGlzW0VdLnNldFRleHR1cmUobFswXSx2KSx0aGlzW2JdPWwsdGhpc1tNXT12fXNldEZyYW1lSW5kZXgobCx2KXtpZihsPj10aGlzW3BdfHxsPDApdGhyb3cgbmV3IEVycm9yKCJPdXQgb2YgcmFuZ2UuIik7Y29uc3QgVD10aGlzW2JdLmxlbmd0aDtpZihUPD0wKXRocm93IG5ldyBFcnJvcigiTm8gZnJhbWVzIik7dGhpc1tzXS5mcmFtZUluZGV4W2xdPXYlVH1nZXQgYW1vdW50KCl7cmV0dXJuIHRoaXNbcF19c2V0IGFtb3VudChsKXtjb25zdCB2PXRoaXNbcF07bCE9PXYmJihsPnRoaXNbc10uYnVmZmVyU2l6ZSYmKHRoaXNbc109YyhNYXRoLm1heChsLHRoaXNbc10uYnVmZmVyU2l6ZSsxZTMpLHRoaXNbc10pKSx0aGlzW3BdPWwsbD52JiZ0aGlzLmluaXRCdWZmZXIodikpfWdldCBtZXNoRGF0YSgpe2NvbnN0e2F0dHJpYnV0ZXM6bCxjZWxsczp2LHBvc2l0aW9uczpULHRleHR1cmVDb29yZDpSLHVuaWZvcm1zOkx9PXRoaXNbRV0ubWVzaERhdGEsTj10aGlzW2JdLEE9e2F0dHJpYnV0ZXM6YSh7fSxsKSxjZWxsczp2LHBvc2l0aW9uczpULHRleHR1cmVDb29yZDpSLHVuaWZvcm1zOmEoe30sTCksaW5zdGFuY2VDb3VudDp0aGlzW3BdLGVuYWJsZUJsZW5kOnRoaXMuZW5hYmxlQmxlbmR9O04ubGVuZ3RoJiZOLmZvckVhY2goKFkscnQpPT57QS51bmlmb3Jtc1tgdV90ZXhGcmFtZSR7cnR9YF09WX0pO2NvbnN0e3RyYW5zZm9ybTA6dyx0cmFuc2Zvcm0xOkIsY29sb3IwOkQsY29sb3IxOkksY29sb3IyOmosY29sb3IzOlYsY29sb3I0OkosZmlsbENvbG9yOl8sc3Ryb2tlQ29sb3I6c3QsZnJhbWVJbmRleDpHfT10aGlzW3NdO3JldHVybiB0aGlzW0VdLnVuaWZvcm1zLnVfdGV4U2FtcGxlciYmKEEuYXR0cmlidXRlcy5hX2ZyYW1lSW5kZXg9e2RhdGE6RyxkaXZpc29yOjF9KSxBLmF0dHJpYnV0ZXMuYV90cmFuc2Zvcm0wPXtkYXRhOncsZGl2aXNvcjoxfSxBLmF0dHJpYnV0ZXMuYV90cmFuc2Zvcm0xPXtkYXRhOkIsZGl2aXNvcjoxfSxBLmF0dHJpYnV0ZXMuYV9jb2xvckNsb3VkMD17ZGF0YTpELGRpdmlzb3I6MX0sQS5hdHRyaWJ1dGVzLmFfY29sb3JDbG91ZDE9e2RhdGE6SSxkaXZpc29yOjF9LEEuYXR0cmlidXRlcy5hX2NvbG9yQ2xvdWQyPXtkYXRhOmosZGl2aXNvcjoxfSxBLmF0dHJpYnV0ZXMuYV9jb2xvckNsb3VkMz17ZGF0YTpWLGRpdmlzb3I6MX0sQS5hdHRyaWJ1dGVzLmFfY29sb3JDbG91ZDQ9e2RhdGE6SixkaXZpc29yOjF9LHRoaXMuaGFzQ2xvdWRDb2xvciYmKEEuYXR0cmlidXRlcy5hX2ZpbGxDbG91ZENvbG9yPXtkYXRhOl8sZGl2aXNvcjoxfSxBLmF0dHJpYnV0ZXMuYV9zdHJva2VDbG91ZENvbG9yPXtkYXRhOnN0LGRpdmlzb3I6MX0pLEF9c2V0UHJvZ3JhbShsKXt0aGlzW0VdLnNldFByb2dyYW0obCl9Z2V0IHByb2dyYW0oKXtyZXR1cm4gdGhpc1tFXS5wcm9ncmFtfXRyYW5zZm9ybShsLHYpe2NvbnN0IFQ9dGhpcy5nZXRUcmFuc2Zvcm0obCk7cmV0dXJuIHY9bi5tYXQyZC5tdWx0aXBseShBcnJheS5vZigwLDAsMCwwLDAsMCksVCx2KSx0aGlzLnNldFRyYW5zZm9ybShsLHYpLHRoaXN9dHJhbnNsYXRlKGwsW3YsVF0pe2xldCBSPW4ubWF0MmQuY3JlYXRlKCk7cmV0dXJuIFI9bi5tYXQyZC50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDApLFIsW3YsVF0pLHRoaXMudHJhbnNmb3JtKGwsUil9cm90YXRlKGwsdixbVCxSXT1bMCwwXSl7bGV0IEw9bi5tYXQyZC5jcmVhdGUoKTtyZXR1cm4gTD1uLm1hdDJkLnRyYW5zbGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCksTCxbVCxSXSksTD1uLm1hdDJkLnJvdGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCksTCx2KSxMPW4ubWF0MmQudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxMLFstVCwtUl0pLHRoaXMudHJhbnNmb3JtKGwsTCl9c2NhbGUobCxbdixUPXZdLFtSLExdPVswLDBdKXtsZXQgTj1uLm1hdDJkLmNyZWF0ZSgpO3JldHVybiBOPW4ubWF0MmQudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxOLFtSLExdKSxOPW4ubWF0MmQuc2NhbGUoQXJyYXkub2YoMCwwLDAsMCwwLDApLE4sW3YsVF0pLE49bi5tYXQyZC50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDApLE4sWy1SLC1MXSksdGhpcy50cmFuc2Zvcm0obCxOKX1za2V3KGwsW3YsVD12XSxbUixMXT1bMCwwXSl7bGV0IE49bi5tYXQyZC5jcmVhdGUoKTtyZXR1cm4gTj1uLm1hdDJkLnRyYW5zbGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCksTixbUixMXSksTj1uLm1hdDJkLm11bHRpcGx5KEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxOLG4ubWF0MmQuZnJvbVZhbHVlcygxLE1hdGgudGFuKFQpLE1hdGgudGFuKHYpLDEsMCwwKSksTj1uLm1hdDJkLnRyYW5zbGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCksTixbLVIsLUxdKSx0aGlzLnRyYW5zZm9ybShsLE4pfWlzUG9pbnRDb2xsaXNpb24obCxbdixUXSxSPSJib3RoIil7Y29uc3QgTD10aGlzLmdldFRyYW5zZm9ybShsKSxOPU9iamVjdChmLnRyYW5zZm9ybVBvaW50KShbdixUXSxuLm1hdDJkLmludmVydChBcnJheS5vZigwLDAsMCwwLDAsMCksTCkpO3JldHVybiB0aGlzW0VdLmlzUG9pbnRDb2xsaXNpb24oLi4uTixSKX1pc1BvaW50SW5GaWxsKGwsW3YsVF0pe3JldHVybiB0aGlzLmlzUG9pbnRDb2xsaXNpb24obCxbdixUXSwiZmlsbCIpfWlzUG9pbnRJblN0cm9rZShsLFt2LFRdKXtyZXR1cm4gdGhpcy5pc1BvaW50Q29sbGlzaW9uKGwsW3YsVF0sInN0cm9rZSIpfX19LGZ1bmN0aW9uKGcsZSx0KXt0LnIoZSksdC5kKGUsIm11bHRpcGx5IixmdW5jdGlvbigpe3JldHVybiBpfSksdC5kKGUsImdyYXlzY2FsZSIsZnVuY3Rpb24oKXtyZXR1cm4gZn0pLHQuZChlLCJicmlnaHRuZXNzIixmdW5jdGlvbigpe3JldHVybiBofSksdC5kKGUsInNhdHVyYXRlIixmdW5jdGlvbigpe3JldHVybiB1fSksdC5kKGUsImNvbnRyYXN0IixmdW5jdGlvbigpe3JldHVybiBhfSksdC5kKGUsImludmVydCIsZnVuY3Rpb24oKXtyZXR1cm4gZH0pLHQuZChlLCJzZXBpYSIsZnVuY3Rpb24oKXtyZXR1cm4gRX0pLHQuZChlLCJvcGFjaXR5IixmdW5jdGlvbigpe3JldHVybiBwfSksdC5kKGUsImh1ZVJvdGF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gT30pO3ZhciBuPXQoMjYpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBpKG0sYil7Y29uc3QgTT1bXSx5PW1bMF0sUz1tWzFdLHM9bVsyXSxjPW1bM10sbD1tWzRdLHY9bVs1XSxUPW1bNl0sUj1tWzddLEw9bVs4XSxOPW1bOV0sQT1tWzEwXSx3PW1bMTFdLEI9bVsxMl0sRD1tWzEzXSxJPW1bMTRdLGo9bVsxNV0sVj1tWzE2XSxKPW1bMTddLF89bVsxOF0sc3Q9bVsxOV07bGV0IEc9YlswXSxZPWJbMV0scnQ9YlsyXSxvdD1iWzNdLGF0PWJbNF07cmV0dXJuIE1bMF09Ryp5K1kqditydCpBK290KmosTVsxXT1HKlMrWSpUK3J0Kncrb3QqVixNWzJdPUcqcytZKlIrcnQqQitvdCpKLE1bM109RypjK1kqTCtydCpEK290Kl8sTVs0XT1HKmwrWSpOK3J0Kkkrb3Qqc3QrYXQsRz1iWzVdLFk9Yls2XSxydD1iWzddLG90PWJbOF0sYXQ9Yls5XSxNWzVdPUcqeStZKnYrcnQqQStvdCpqLE1bNl09RypTK1kqVCtydCp3K290KlYsTVs3XT1HKnMrWSpSK3J0KkIrb3QqSixNWzhdPUcqYytZKkwrcnQqRCtvdCpfLE1bOV09RypsK1kqTitydCpJK290KnN0K2F0LEc9YlsxMF0sWT1iWzExXSxydD1iWzEyXSxvdD1iWzEzXSxhdD1iWzE0XSxNWzEwXT1HKnkrWSp2K3J0KkErb3QqaixNWzExXT1HKlMrWSpUK3J0Kncrb3QqVixNWzEyXT1HKnMrWSpSK3J0KkIrb3QqSixNWzEzXT1HKmMrWSpMK3J0KkQrb3QqXyxNWzE0XT1HKmwrWSpOK3J0Kkkrb3Qqc3QrYXQsRz1iWzE1XSxZPWJbMTZdLHJ0PWJbMTddLG90PWJbMThdLGF0PWJbMTldLE1bMTVdPUcqeStZKnYrcnQqQStvdCpqLE1bMTZdPUcqUytZKlQrcnQqdytvdCpWLE1bMTddPUcqcytZKlIrcnQqQitvdCpKLE1bMThdPUcqYytZKkwrcnQqRCtvdCpfLE1bMTldPUcqbCtZKk4rcnQqSStvdCpzdCthdCxNfWZ1bmN0aW9uIGYobSl7bT1PYmplY3Qobi5jbGFtcCkoMCwxLG0pO2NvbnN0IGI9LjIxMjYqbSxNPS43MTUyKm0seT0uMDcyMiptO3JldHVybltiKzEtbSxNLHksMCwwLGIsTSsxLW0seSwwLDAsYixNLHkrMS1tLDAsMCwwLDAsMCwxLDBdfWZ1bmN0aW9uIGgobSl7cmV0dXJuW20sMCwwLDAsMCwwLG0sMCwwLDAsMCwwLG0sMCwwLDAsMCwwLDEsMF19ZnVuY3Rpb24gdShtKXtjb25zdCBiPS4yMTI2KigxLW0pLE09LjcxNTIqKDEtbSkseT0uMDcyMiooMS1tKTtyZXR1cm5bYittLE0seSwwLDAsYixNK20seSwwLDAsYixNLHkrbSwwLDAsMCwwLDAsMSwwXX1mdW5jdGlvbiBhKG0pe2NvbnN0IGI9LjUqKDEtbSk7cmV0dXJuW20sMCwwLDAsYiwwLG0sMCwwLGIsMCwwLG0sMCxiLDAsMCwwLDEsMF19ZnVuY3Rpb24gZChtKXtjb25zdCBiPTEtMiptO3JldHVybltiLDAsMCwwLG0sMCxiLDAsMCxtLDAsMCxiLDAsbSwwLDAsMCwxLDBdfWZ1bmN0aW9uIEUobSl7cmV0dXJuWzEtLjYwNyptLC43NjkqbSwuMTg5Km0sMCwwLC4zNDkqbSwxLS4zMTQqbSwuMTY4Km0sMCwwLC4yNzIqbSwuNTM0Km0sMS0uODY5Km0sMCwwLDAsMCwwLDEsMF19ZnVuY3Rpb24gcChtKXtyZXR1cm5bMSwwLDAsMCwwLDAsMSwwLDAsMCwwLDAsMSwwLDAsMCwwLDAsbSwwXX1mdW5jdGlvbiBPKG0pe2NvbnN0IGI9bS8xODAqTWF0aC5QSSxNPU1hdGguY29zKGIpLHk9TWF0aC5zaW4oYiksUz0uMjEyNixzPS43MTUyLGM9LjA3MjI7cmV0dXJuW1MrTSooMS1TKSt5Ki1TLHMrTSotcyt5Ki1zLGMrTSotYyt5KigxLWMpLDAsMCxTK00qLVMreSouMTQzLHMrTSooMS1zKSt5Ki4xNCxjK00qLWMreSotLjI4MywwLDAsUytNKi1TK3kqLSgxLVMpLHMrTSotcyt5KnMsYytNKigxLWMpK3kqYywwLDAsMCwwLDAsMSwwXX19LGZ1bmN0aW9uKGcsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIGZ9KTt2YXIgbj10KDMyKSxpPXQubihuKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gZihoKXtjb25zdCB1PWkoKShoKTtpZighdXx8IXUubGVuZ3RoKXRocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgY29sb3IgdmFsdWUuIik7cmV0dXJuW3VbMF0vMjU1LHVbMV0vMjU1LHVbMl0vMjU1LHVbM11dfX0sZnVuY3Rpb24oZyxlLHQpe3ZhciBuPXQoMzMpLGk9dCgzNyksZj10KDM5KTtnLmV4cG9ydHM9ZnVuY3Rpb24odSl7dmFyIGEsZD1uKHUpO3JldHVybiBkLnNwYWNlPyhhPUFycmF5KDMpLGFbMF09ZihkLnZhbHVlc1swXSwwLDI1NSksYVsxXT1mKGQudmFsdWVzWzFdLDAsMjU1KSxhWzJdPWYoZC52YWx1ZXNbMl0sMCwyNTUpLGQuc3BhY2VbMF09PT0iaCImJihhPWkucmdiKGEpKSxhLnB1c2goZihkLmFscGhhLDAsMSkpLGEpOltdfX0sZnVuY3Rpb24oZyxlLHQpeyhmdW5jdGlvbihuKXt2YXIgaT10KDM0KSxmPXQoMzUpLGg9dCgzNik7Zy5leHBvcnRzPWE7dmFyIHU9e3JlZDowLG9yYW5nZTo2MCx5ZWxsb3c6MTIwLGdyZWVuOjE4MCxibHVlOjI0MCxwdXJwbGU6MzAwfTtmdW5jdGlvbiBhKGQpe3ZhciBFLHA9W10sTz0xLG07aWYodHlwZW9mIGQ9PSJzdHJpbmciKWlmKGlbZF0pcD1pW2RdLnNsaWNlKCksbT0icmdiIjtlbHNlIGlmKGQ9PT0idHJhbnNwYXJlbnQiKU89MCxtPSJyZ2IiLHA9WzAsMCwwXTtlbHNlIGlmKC9eI1tBLUZhLWYwLTldKyQvLnRlc3QoZCkpe3ZhciBiPWQuc2xpY2UoMSksTT1iLmxlbmd0aCx5PU08PTQ7Tz0xLHk/KHA9W3BhcnNlSW50KGJbMF0rYlswXSwxNikscGFyc2VJbnQoYlsxXStiWzFdLDE2KSxwYXJzZUludChiWzJdK2JbMl0sMTYpXSxNPT09NCYmKE89cGFyc2VJbnQoYlszXStiWzNdLDE2KS8yNTUpKToocD1bcGFyc2VJbnQoYlswXStiWzFdLDE2KSxwYXJzZUludChiWzJdK2JbM10sMTYpLHBhcnNlSW50KGJbNF0rYls1XSwxNildLE09PT04JiYoTz1wYXJzZUludChiWzZdK2JbN10sMTYpLzI1NSkpLHBbMF18fChwWzBdPTApLHBbMV18fChwWzFdPTApLHBbMl18fChwWzJdPTApLG09InJnYiJ9ZWxzZSBpZihFPS9eKCg/OnJnYnxoc1tsdmJdfGh3YnxjbXlrP3x4eVt6eV18Z3JheXxsYWJ8bGNodT92P3xbbHlddXZ8bG1zKWE/KVxzKlwoKFteXCldKilcKS8uZXhlYyhkKSl7dmFyIFM9RVsxXSxzPVM9PT0icmdiIixiPVMucmVwbGFjZSgvYSQvLCIiKTttPWI7dmFyIE09Yj09PSJjbXlrIj80OmI9PT0iZ3JheSI/MTozO3A9RVsyXS50cmltKCkuc3BsaXQoL1xzKixccyovKS5tYXAoZnVuY3Rpb24oVCxSKXtpZigvJSQvLnRlc3QoVCkpcmV0dXJuIFI9PT1NP3BhcnNlRmxvYXQoVCkvMTAwOmI9PT0icmdiIj9wYXJzZUZsb2F0KFQpKjI1NS8xMDA6cGFyc2VGbG9hdChUKTtpZihiW1JdPT09ImgiKXtpZigvZGVnJC8udGVzdChUKSlyZXR1cm4gcGFyc2VGbG9hdChUKTtpZih1W1RdIT09dm9pZCAwKXJldHVybiB1W1RdfXJldHVybiBwYXJzZUZsb2F0KFQpfSksUz09PWImJnAucHVzaCgxKSxPPXN8fHBbTV09PT12b2lkIDA/MTpwW01dLHA9cC5zbGljZSgwLE0pfWVsc2UgZC5sZW5ndGg+MTAmJi9bMC05XSg/OlxzfFwvKS8udGVzdChkKSYmKHA9ZC5tYXRjaCgvKFswLTldKykvZykubWFwKGZ1bmN0aW9uKGwpe3JldHVybiBwYXJzZUZsb2F0KGwpfSksbT1kLm1hdGNoKC8oW2Etel0pL2lnKS5qb2luKCIiKS50b0xvd2VyQ2FzZSgpKTtlbHNlIGlmKCFpc05hTihkKSltPSJyZ2IiLHA9W2Q+Pj4xNiwoZCY2NTI4MCk+Pj44LGQmMjU1XTtlbHNlIGlmKGYoZCkpe3ZhciBjPWgoZC5yLGQucmVkLGQuUixudWxsKTtjIT09bnVsbD8obT0icmdiIixwPVtjLGgoZC5nLGQuZ3JlZW4sZC5HKSxoKGQuYixkLmJsdWUsZC5CKV0pOihtPSJoc2wiLHA9W2goZC5oLGQuaHVlLGQuSCksaChkLnMsZC5zYXR1cmF0aW9uLGQuUyksaChkLmwsZC5saWdodG5lc3MsZC5MLGQuYixkLmJyaWdodG5lc3MpXSksTz1oKGQuYSxkLmFscGhhLGQub3BhY2l0eSwxKSxkLm9wYWNpdHkhPW51bGwmJihPLz0xMDApfWVsc2UoQXJyYXkuaXNBcnJheShkKXx8bi5BcnJheUJ1ZmZlciYmQXJyYXlCdWZmZXIuaXNWaWV3JiZBcnJheUJ1ZmZlci5pc1ZpZXcoZCkpJiYocD1bZFswXSxkWzFdLGRbMl1dLG09InJnYiIsTz1kLmxlbmd0aD09PTQ/ZFszXToxKTtyZXR1cm57c3BhY2U6bSx2YWx1ZXM6cCxhbHBoYTpPfX19KS5jYWxsKHRoaXMsdCgyMikpfSxmdW5jdGlvbihnLGUsdCl7Zy5leHBvcnRzPXthbGljZWJsdWU6WzI0MCwyNDgsMjU1XSxhbnRpcXVld2hpdGU6WzI1MCwyMzUsMjE1XSxhcXVhOlswLDI1NSwyNTVdLGFxdWFtYXJpbmU6WzEyNywyNTUsMjEyXSxhenVyZTpbMjQwLDI1NSwyNTVdLGJlaWdlOlsyNDUsMjQ1LDIyMF0sYmlzcXVlOlsyNTUsMjI4LDE5Nl0sYmxhY2s6WzAsMCwwXSxibGFuY2hlZGFsbW9uZDpbMjU1LDIzNSwyMDVdLGJsdWU6WzAsMCwyNTVdLGJsdWV2aW9sZXQ6WzEzOCw0MywyMjZdLGJyb3duOlsxNjUsNDIsNDJdLGJ1cmx5d29vZDpbMjIyLDE4NCwxMzVdLGNhZGV0Ymx1ZTpbOTUsMTU4LDE2MF0sY2hhcnRyZXVzZTpbMTI3LDI1NSwwXSxjaG9jb2xhdGU6WzIxMCwxMDUsMzBdLGNvcmFsOlsyNTUsMTI3LDgwXSxjb3JuZmxvd2VyYmx1ZTpbMTAwLDE0OSwyMzddLGNvcm5zaWxrOlsyNTUsMjQ4LDIyMF0sY3JpbXNvbjpbMjIwLDIwLDYwXSxjeWFuOlswLDI1NSwyNTVdLGRhcmtibHVlOlswLDAsMTM5XSxkYXJrY3lhbjpbMCwxMzksMTM5XSxkYXJrZ29sZGVucm9kOlsxODQsMTM0LDExXSxkYXJrZ3JheTpbMTY5LDE2OSwxNjldLGRhcmtncmVlbjpbMCwxMDAsMF0sZGFya2dyZXk6WzE2OSwxNjksMTY5XSxkYXJra2hha2k6WzE4OSwxODMsMTA3XSxkYXJrbWFnZW50YTpbMTM5LDAsMTM5XSxkYXJrb2xpdmVncmVlbjpbODUsMTA3LDQ3XSxkYXJrb3JhbmdlOlsyNTUsMTQwLDBdLGRhcmtvcmNoaWQ6WzE1Myw1MCwyMDRdLGRhcmtyZWQ6WzEzOSwwLDBdLGRhcmtzYWxtb246WzIzMywxNTAsMTIyXSxkYXJrc2VhZ3JlZW46WzE0MywxODgsMTQzXSxkYXJrc2xhdGVibHVlOls3Miw2MSwxMzldLGRhcmtzbGF0ZWdyYXk6WzQ3LDc5LDc5XSxkYXJrc2xhdGVncmV5Ols0Nyw3OSw3OV0sZGFya3R1cnF1b2lzZTpbMCwyMDYsMjA5XSxkYXJrdmlvbGV0OlsxNDgsMCwyMTFdLGRlZXBwaW5rOlsyNTUsMjAsMTQ3XSxkZWVwc2t5Ymx1ZTpbMCwxOTEsMjU1XSxkaW1ncmF5OlsxMDUsMTA1LDEwNV0sZGltZ3JleTpbMTA1LDEwNSwxMDVdLGRvZGdlcmJsdWU6WzMwLDE0NCwyNTVdLGZpcmVicmljazpbMTc4LDM0LDM0XSxmbG9yYWx3aGl0ZTpbMjU1LDI1MCwyNDBdLGZvcmVzdGdyZWVuOlszNCwxMzksMzRdLGZ1Y2hzaWE6WzI1NSwwLDI1NV0sZ2FpbnNib3JvOlsyMjAsMjIwLDIyMF0sZ2hvc3R3aGl0ZTpbMjQ4LDI0OCwyNTVdLGdvbGQ6WzI1NSwyMTUsMF0sZ29sZGVucm9kOlsyMTgsMTY1LDMyXSxncmF5OlsxMjgsMTI4LDEyOF0sZ3JlZW46WzAsMTI4LDBdLGdyZWVueWVsbG93OlsxNzMsMjU1LDQ3XSxncmV5OlsxMjgsMTI4LDEyOF0saG9uZXlkZXc6WzI0MCwyNTUsMjQwXSxob3RwaW5rOlsyNTUsMTA1LDE4MF0saW5kaWFucmVkOlsyMDUsOTIsOTJdLGluZGlnbzpbNzUsMCwxMzBdLGl2b3J5OlsyNTUsMjU1LDI0MF0sa2hha2k6WzI0MCwyMzAsMTQwXSxsYXZlbmRlcjpbMjMwLDIzMCwyNTBdLGxhdmVuZGVyYmx1c2g6WzI1NSwyNDAsMjQ1XSxsYXduZ3JlZW46WzEyNCwyNTIsMF0sbGVtb25jaGlmZm9uOlsyNTUsMjUwLDIwNV0sbGlnaHRibHVlOlsxNzMsMjE2LDIzMF0sbGlnaHRjb3JhbDpbMjQwLDEyOCwxMjhdLGxpZ2h0Y3lhbjpbMjI0LDI1NSwyNTVdLGxpZ2h0Z29sZGVucm9keWVsbG93OlsyNTAsMjUwLDIxMF0sbGlnaHRncmF5OlsyMTEsMjExLDIxMV0sbGlnaHRncmVlbjpbMTQ0LDIzOCwxNDRdLGxpZ2h0Z3JleTpbMjExLDIxMSwyMTFdLGxpZ2h0cGluazpbMjU1LDE4MiwxOTNdLGxpZ2h0c2FsbW9uOlsyNTUsMTYwLDEyMl0sbGlnaHRzZWFncmVlbjpbMzIsMTc4LDE3MF0sbGlnaHRza3libHVlOlsxMzUsMjA2LDI1MF0sbGlnaHRzbGF0ZWdyYXk6WzExOSwxMzYsMTUzXSxsaWdodHNsYXRlZ3JleTpbMTE5LDEzNiwxNTNdLGxpZ2h0c3RlZWxibHVlOlsxNzYsMTk2LDIyMl0sbGlnaHR5ZWxsb3c6WzI1NSwyNTUsMjI0XSxsaW1lOlswLDI1NSwwXSxsaW1lZ3JlZW46WzUwLDIwNSw1MF0sbGluZW46WzI1MCwyNDAsMjMwXSxtYWdlbnRhOlsyNTUsMCwyNTVdLG1hcm9vbjpbMTI4LDAsMF0sbWVkaXVtYXF1YW1hcmluZTpbMTAyLDIwNSwxNzBdLG1lZGl1bWJsdWU6WzAsMCwyMDVdLG1lZGl1bW9yY2hpZDpbMTg2LDg1LDIxMV0sbWVkaXVtcHVycGxlOlsxNDcsMTEyLDIxOV0sbWVkaXVtc2VhZ3JlZW46WzYwLDE3OSwxMTNdLG1lZGl1bXNsYXRlYmx1ZTpbMTIzLDEwNCwyMzhdLG1lZGl1bXNwcmluZ2dyZWVuOlswLDI1MCwxNTRdLG1lZGl1bXR1cnF1b2lzZTpbNzIsMjA5LDIwNF0sbWVkaXVtdmlvbGV0cmVkOlsxOTksMjEsMTMzXSxtaWRuaWdodGJsdWU6WzI1LDI1LDExMl0sbWludGNyZWFtOlsyNDUsMjU1LDI1MF0sbWlzdHlyb3NlOlsyNTUsMjI4LDIyNV0sbW9jY2FzaW46WzI1NSwyMjgsMTgxXSxuYXZham93aGl0ZTpbMjU1LDIyMiwxNzNdLG5hdnk6WzAsMCwxMjhdLG9sZGxhY2U6WzI1MywyNDUsMjMwXSxvbGl2ZTpbMTI4LDEyOCwwXSxvbGl2ZWRyYWI6WzEwNywxNDIsMzVdLG9yYW5nZTpbMjU1LDE2NSwwXSxvcmFuZ2VyZWQ6WzI1NSw2OSwwXSxvcmNoaWQ6WzIxOCwxMTIsMjE0XSxwYWxlZ29sZGVucm9kOlsyMzgsMjMyLDE3MF0scGFsZWdyZWVuOlsxNTIsMjUxLDE1Ml0scGFsZXR1cnF1b2lzZTpbMTc1LDIzOCwyMzhdLHBhbGV2aW9sZXRyZWQ6WzIxOSwxMTIsMTQ3XSxwYXBheWF3aGlwOlsyNTUsMjM5LDIxM10scGVhY2hwdWZmOlsyNTUsMjE4LDE4NV0scGVydTpbMjA1LDEzMyw2M10scGluazpbMjU1LDE5MiwyMDNdLHBsdW06WzIyMSwxNjAsMjIxXSxwb3dkZXJibHVlOlsxNzYsMjI0LDIzMF0scHVycGxlOlsxMjgsMCwxMjhdLHJlYmVjY2FwdXJwbGU6WzEwMiw1MSwxNTNdLHJlZDpbMjU1LDAsMF0scm9zeWJyb3duOlsxODgsMTQzLDE0M10scm95YWxibHVlOls2NSwxMDUsMjI1XSxzYWRkbGVicm93bjpbMTM5LDY5LDE5XSxzYWxtb246WzI1MCwxMjgsMTE0XSxzYW5keWJyb3duOlsyNDQsMTY0LDk2XSxzZWFncmVlbjpbNDYsMTM5LDg3XSxzZWFzaGVsbDpbMjU1LDI0NSwyMzhdLHNpZW5uYTpbMTYwLDgyLDQ1XSxzaWx2ZXI6WzE5MiwxOTIsMTkyXSxza3libHVlOlsxMzUsMjA2LDIzNV0sc2xhdGVibHVlOlsxMDYsOTAsMjA1XSxzbGF0ZWdyYXk6WzExMiwxMjgsMTQ0XSxzbGF0ZWdyZXk6WzExMiwxMjgsMTQ0XSxzbm93OlsyNTUsMjUwLDI1MF0sc3ByaW5nZ3JlZW46WzAsMjU1LDEyN10sc3RlZWxibHVlOls3MCwxMzAsMTgwXSx0YW46WzIxMCwxODAsMTQwXSx0ZWFsOlswLDEyOCwxMjhdLHRoaXN0bGU6WzIxNiwxOTEsMjE2XSx0b21hdG86WzI1NSw5OSw3MV0sdHVycXVvaXNlOls2NCwyMjQsMjA4XSx2aW9sZXQ6WzIzOCwxMzAsMjM4XSx3aGVhdDpbMjQ1LDIyMiwxNzldLHdoaXRlOlsyNTUsMjU1LDI1NV0sd2hpdGVzbW9rZTpbMjQ1LDI0NSwyNDVdLHllbGxvdzpbMjU1LDI1NSwwXSx5ZWxsb3dncmVlbjpbMTU0LDIwNSw1MF19fSxmdW5jdGlvbihnLGUsdCl7dmFyIG49T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztnLmV4cG9ydHM9ZnVuY3Rpb24oaSl7dmFyIGY7cmV0dXJuIG4uY2FsbChpKT09PSJbb2JqZWN0IE9iamVjdF0iJiYoZj1PYmplY3QuZ2V0UHJvdG90eXBlT2YoaSksZj09PW51bGx8fGY9PT1PYmplY3QuZ2V0UHJvdG90eXBlT2Yoe30pKX19LGZ1bmN0aW9uKGcsZSl7Zy5leHBvcnRzPWZ1bmN0aW9uKCl7Zm9yKHZhciB0PTA7dDxhcmd1bWVudHMubGVuZ3RoO3QrKylpZihhcmd1bWVudHNbdF0hPT12b2lkIDApcmV0dXJuIGFyZ3VtZW50c1t0XX19LGZ1bmN0aW9uKGcsZSx0KXt2YXIgbj10KDM4KTtnLmV4cG9ydHM9e25hbWU6ImhzbCIsbWluOlswLDAsMF0sbWF4OlszNjAsMTAwLDEwMF0sY2hhbm5lbDpbImh1ZSIsInNhdHVyYXRpb24iLCJsaWdodG5lc3MiXSxhbGlhczpbIkhTTCJdLHJnYjpmdW5jdGlvbihpKXt2YXIgZj1pWzBdLzM2MCxoPWlbMV0vMTAwLHU9aVsyXS8xMDAsYSxkLEUscCxPO2lmKGg9PT0wKXJldHVybiBPPXUqMjU1LFtPLE8sT107dTwuNT9kPXUqKDEraCk6ZD11K2gtdSpoLGE9Mip1LWQscD1bMCwwLDBdO2Zvcih2YXIgbT0wO208MzttKyspRT1mKzEvMyotKG0tMSksRTwwP0UrKzpFPjEmJkUtLSw2KkU8MT9PPWErKGQtYSkqNipFOjIqRTwxP089ZDozKkU8Mj9PPWErKGQtYSkqKDIvMy1FKSo2Ok89YSxwW21dPU8qMjU1O3JldHVybiBwfX0sbi5oc2w9ZnVuY3Rpb24oaSl7dmFyIGY9aVswXS8yNTUsaD1pWzFdLzI1NSx1PWlbMl0vMjU1LGE9TWF0aC5taW4oZixoLHUpLGQ9TWF0aC5tYXgoZixoLHUpLEU9ZC1hLHAsTyxtO3JldHVybiBkPT09YT9wPTA6Zj09PWQ/cD0oaC11KS9FOmg9PT1kP3A9MisodS1mKS9FOnU9PT1kJiYocD00KyhmLWgpL0UpLHA9TWF0aC5taW4ocCo2MCwzNjApLHA8MCYmKHArPTM2MCksbT0oYStkKS8yLGQ9PT1hP089MDptPD0uNT9PPUUvKGQrYSk6Tz1FLygyLWQtYSksW3AsTyoxMDAsbSoxMDBdfX0sZnVuY3Rpb24oZyxlLHQpe2cuZXhwb3J0cz17bmFtZToicmdiIixtaW46WzAsMCwwXSxtYXg6WzI1NSwyNTUsMjU1XSxjaGFubmVsOlsicmVkIiwiZ3JlZW4iLCJibHVlIl0sYWxpYXM6WyJSR0IiXX19LGZ1bmN0aW9uKGcsZSl7Zy5leHBvcnRzPXQ7ZnVuY3Rpb24gdChuLGksZil7cmV0dXJuIGk8Zj9uPGk/aTpuPmY/ZjpuOm48Zj9mOm4+aT9pOm59fSxmdW5jdGlvbihnLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBjfSk7dmFyIG49dCg0MSksaT10Lm4obiksZj10KDQyKSxoPXQubihmKSx1PXQoNDMpLGE9dC5uKHUpLGQ9dCg0NCksRT10KDQ2KSxwPXQubihFKSxPPXQoNTMpLG09dCg1NSk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IGI9U3ltYm9sKCJjb250b3VycyIpLE09U3ltYm9sKCJwYXRoIikseT1TeW1ib2woInNpbXBsaWZ5IiksUz1TeW1ib2woInNjYWxlIikscz0yKk1hdGguUEk7Y2xhc3MgY3tjb25zdHJ1Y3Rvcih2PXt9KXt0eXBlb2Ygdj09InN0cmluZyImJih2PXtwYXRoOnZ9KSx2LnBhdGg/dGhpc1tNXT1pKCkodi5wYXRoKTp0aGlzW01dPVtdLHRoaXNbYl09bnVsbCx0aGlzW3ldPXYuc2ltcGxpZnkhPW51bGw/di5zaW1wbGlmeTowLHRoaXNbU109di5zY2FsZSE9bnVsbD92LnNjYWxlOjJ9Z2V0IGNvbnRvdXJzKCl7bGV0IHY9bnVsbDtpZighdGhpc1tiXSYmdGhpc1tNXSl7Y29uc3QgVD1PYmplY3QoZC5kZWZhdWx0KShhKCkodGhpc1tNXSkpO3RoaXNbYl09cCgpKFQsdGhpc1tTXSx0aGlzW3ldKSx0aGlzW2JdLnBhdGg9VCx0aGlzW2JdLnNpbXBsaWZ5PXRoaXNbeV0sdGhpc1tiXS5zY2FsZT10aGlzW1NdfXJldHVybiB0aGlzW2JdJiYodj10aGlzW2JdLm1hcChUPT5bLi4uVF0pLHYucGF0aD10aGlzW2JdLnBhdGgsdi5zaW1wbGlmeT10aGlzW2JdLnNpbXBsaWZ5LHYuc2NhbGU9dGhpc1tiXS5zY2FsZSksdn1nZXQgcGF0aCgpe3JldHVybiB0aGlzW01dfWdldCBzaW1wbGlmeSgpe3JldHVybiB0aGlzW3ldfWdldCBib3VuZGluZ0JveCgpe2NvbnN0IHY9dGhpcy5jb250b3VycztpZih2JiZ2Lmxlbmd0aCl7Y29uc3QgVD12LnJlZHVjZSgoUixMKT0+Wy4uLlIsLi4uTF0pO3JldHVybiBoKCkoVCl9cmV0dXJuW1swLDBdLFswLDBdXX1nZXQgYm91bmRpbmdDZW50ZXIoKXtjb25zdCB2PXRoaXMuYm91bmRpbmdCb3g7cmV0dXJuIHY/Wy41Kih2WzBdWzBdK3ZbMV1bMF0pLC41Kih2WzBdWzFdK3ZbMV1bMV0pXTpbMCwwXX1ub3JtYWxpemUodj0wLFQ9MCl7Y29uc3QgUj1PYmplY3QoZC5kZWZhdWx0KShhKCkodGhpc1tNXSkpLm1hcCgoW0wsLi4uTl0pPT57Y29uc3QgQT1bTF07Zm9yKGxldCB3PTA7dzxOLmxlbmd0aDt3Kz0yKXtjb25zdCBCPU5bd10tdixEPU5bdysxXS1UO0EucHVzaChCLEQpfXJldHVybiBBfSk7cmV0dXJuIHRoaXMuYmVnaW5QYXRoKCksdGhpc1tNXS5wdXNoKC4uLlIpLHRoaXN9Z2V0UG9pbnRBdExlbmd0aCh2KXtyZXR1cm4gdGhpcy5jb250b3Vycz9PYmplY3QoTy5nZXRQb2ludEF0TGVuZ3RoKSh0aGlzW2JdLHYpOm51bGx9Z2V0VG90YWxMZW5ndGgoKXtyZXR1cm4gdGhpcy5jb250b3Vycz9PYmplY3QoTy5nZXRUb3RhbExlbmd0aCkodGhpc1tiXSk6MH1hZGRQYXRoKHYpe3RoaXNbYl09bnVsbCx0eXBlb2Ygdj09InN0cmluZyImJih2PWkoKSh2KSksdGhpc1tNXS5wdXNoKC4uLnYpfWJlZ2luUGF0aCgpe3RoaXNbTV09W10sdGhpc1tiXT1udWxsfWNsZWFyKCl7dGhpcy5iZWdpblBhdGgoKX1lbGxpcHNlKHYsVCxSLEwsTixBLHcsQj0wKXtpZihBKz1OLHcrPU4sUjw9MHx8TDw9MHx8dz09PUEpcmV0dXJuO3c8QSYmKHc9QStzKyh3LUEpJXMpLHctQT5zJiYodz1BK3MpO2NvbnN0IEQ9dy1BO0Q+PXMmJih3LT0uMDAxKTtsZXQgST10aGlzW01dLmxlbmd0aD4wJiZEPHM/IkwiOiJNIjtjb25zdCBqPU9iamVjdChtLmdldFBvaW50KSh2LFQsUixMLEEpLFY9T2JqZWN0KG0uZ2V0UG9pbnQpKHYsVCxSLEwsdyksSj0rIUI7bGV0IF89RD5NYXRoLlBJPzE6MDtCJiYoXz0xLV8pLEkrPWouam9pbigiICIpLEkrPWBBJHtSfSAke0x9IDAgJHtffSAke0p9ICR7Vi5qb2luKCIgIil9YCxEPj1zJiYoSSs9IloiKSx0aGlzLmFkZFBhdGgoSSl9YXJjKHYsVCxSLEwsTixBPTApe3JldHVybiB0aGlzLmVsbGlwc2UodixULFIsUiwwLEwsTixBKX1hcmNUbyh2LFQsUixMLE4sQSx3KXt0aGlzW2JdPW51bGwsdGhpc1tNXS5wdXNoKFsiQSIsdixULFIsTCxOLEEsd10pfW1vdmVUbyh2LFQpe3RoaXNbYl09bnVsbCx0aGlzW01dLnB1c2goWyJNIix2LFRdKX1saW5lVG8odixUKXt0aGlzW2JdPW51bGwsdGhpc1tNXS5wdXNoKFsiTCIsdixUXSl9YmV6aWVyQ3VydmVUbyh2LFQsUixMLE4sQSl7dGhpc1tiXT1udWxsLHRoaXNbTV0ucHVzaChbIkMiLHYsVCxSLEwsTixBXSl9cXVhZHJhdGljQ3VydmVUbyh2LFQsUixMKXt0aGlzW2JdPW51bGwsdGhpc1tNXS5wdXNoKFsiUSIsdixULFIsTF0pfXJlY3QodixULFIsTCl7Y29uc3QgTj1gTSR7dn0gJHtUfUwke3YrUn0gJHtUfUwke3YrUn0gJHtUK0x9TCR7dn0gJHtUK0x9WmA7dGhpcy5hZGRQYXRoKE4pfWNsb3NlUGF0aCgpe3RoaXNbYl09bnVsbDtsZXQgdj1bXTtjb25zdCBUPXRoaXNbTV0ubGVuZ3RoO1Q+MCYmKHY9dGhpc1tNXVtULTFdKSx2WzBdIT09IloiJiZ2WzBdIT09InoiJiZ0aGlzW01dLnB1c2goWyJaIl0pfX19LGZ1bmN0aW9uKGcsZSl7Zy5leHBvcnRzPWk7dmFyIHQ9e2E6NyxjOjYsaDoxLGw6MixtOjIscTo0LHM6NCx0OjIsdjoxLHo6MH0sbj0vKFthc3R2enFtaGxjXSkoW15hc3R2enFtaGxjXSopL2lnO2Z1bmN0aW9uIGkodSl7dmFyIGE9W107cmV0dXJuIHUucmVwbGFjZShuLGZ1bmN0aW9uKGQsRSxwKXt2YXIgTz1FLnRvTG93ZXJDYXNlKCk7Zm9yKHA9aChwKSxPPT0ibSImJnAubGVuZ3RoPjImJihhLnB1c2goW0VdLmNvbmNhdChwLnNwbGljZSgwLDIpKSksTz0ibCIsRT1FPT0ibSI/ImwiOiJMIik7Oyl7aWYocC5sZW5ndGg9PXRbT10pcmV0dXJuIHAudW5zaGlmdChFKSxhLnB1c2gocCk7aWYocC5sZW5ndGg8dFtPXSl0aHJvdyBuZXcgRXJyb3IoIm1hbGZvcm1lZCBwYXRoIGRhdGEiKTthLnB1c2goW0VdLmNvbmNhdChwLnNwbGljZSgwLHRbT10pKSl9fSksYX12YXIgZj0vLT9bMC05XSpcLj9bMC05XSsoPzplWy0rXT9cZCspPy9pZztmdW5jdGlvbiBoKHUpe3ZhciBhPXUubWF0Y2goZik7cmV0dXJuIGE/YS5tYXAoTnVtYmVyKTpbXX19LGZ1bmN0aW9uKGcsZSx0KXtnLmV4cG9ydHM9bjtmdW5jdGlvbiBuKGkpe3ZhciBmPWkubGVuZ3RoO2lmKGY9PT0wKXJldHVybltbXSxbXV07Zm9yKHZhciBoPWlbMF0ubGVuZ3RoLHU9aVswXS5zbGljZSgpLGE9aVswXS5zbGljZSgpLGQ9MTtkPGY7KytkKWZvcih2YXIgRT1pW2RdLHA9MDtwPGg7KytwKXt2YXIgTz1FW3BdO3VbcF09TWF0aC5taW4odVtwXSxPKSxhW3BdPU1hdGgubWF4KGFbcF0sTyl9cmV0dXJuW3UsYV19fSxmdW5jdGlvbihnLGUpe2cuZXhwb3J0cz10O2Z1bmN0aW9uIHQobil7dmFyIGk9MCxmPTAsaD0wLHU9MDtyZXR1cm4gbi5tYXAoZnVuY3Rpb24oYSl7YT1hLnNsaWNlKCk7dmFyIGQ9YVswXSxFPWQudG9VcHBlckNhc2UoKTtpZihkIT1FKXN3aXRjaChhWzBdPUUsZCl7Y2FzZSJhIjphWzZdKz1oLGFbN10rPXU7YnJlYWs7Y2FzZSJ2IjphWzFdKz11O2JyZWFrO2Nhc2UiaCI6YVsxXSs9aDticmVhaztkZWZhdWx0OmZvcih2YXIgcD0xO3A8YS5sZW5ndGg7KWFbcCsrXSs9aCxhW3ArK10rPXV9c3dpdGNoKEUpe2Nhc2UiWiI6aD1pLHU9ZjticmVhaztjYXNlIkgiOmg9YVsxXTticmVhaztjYXNlIlYiOnU9YVsxXTticmVhaztjYXNlIk0iOmg9aT1hWzFdLHU9Zj1hWzJdO2JyZWFrO2RlZmF1bHQ6aD1hW2EubGVuZ3RoLTJdLHU9YVthLmxlbmd0aC0xXX1yZXR1cm4gYX0pfX0sZnVuY3Rpb24oZyxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gaX0pO3ZhciBuPXQoNDUpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBpKHUpe2Zvcih2YXIgYSxkPVtdLEU9MCxwPTAsTz0wLG09MCxiPW51bGwsTT1udWxsLHk9MCxTPTAscz0wLGM9dS5sZW5ndGg7czxjO3MrKyl7dmFyIGw9dVtzXSx2PWxbMF07c3dpdGNoKHYpe2Nhc2UiTSI6Tz1sWzFdLG09bFsyXTticmVhaztjYXNlIkEiOnZhciBUPU9iamVjdChuLmRlZmF1bHQpKHksUyxsWzZdLGxbN10sbFs0XSxsWzVdLGxbMV0sbFsyXSxsWzNdKTtpZighVC5sZW5ndGgpY29udGludWU7VD1ULm1hcCh3PT57Y29uc3RbQixELEksaixWLEosXyxzdF09dztyZXR1cm57eDE6SSx5MTpqLHgyOlYseTI6Six4Ol8seTpzdH19KTtmb3IodmFyIFI9MCxMO1I8VC5sZW5ndGg7UisrKUw9VFtSXSxsPVsiQyIsTC54MSxMLnkxLEwueDIsTC55MixMLngsTC55XSxSPFQubGVuZ3RoLTEmJmQucHVzaChsKTticmVhaztjYXNlIlMiOnZhciBOPXksQT1TOyhhPT0iQyJ8fGE9PSJTIikmJihOKz1OLUUsQSs9QS1wKSxsPVsiQyIsTixBLGxbMV0sbFsyXSxsWzNdLGxbNF1dO2JyZWFrO2Nhc2UiVCI6YT09IlEifHxhPT0iVCI/KGI9eSoyLWIsTT1TKjItTSk6KGI9eSxNPVMpLGw9aCh5LFMsYixNLGxbMV0sbFsyXSk7YnJlYWs7Y2FzZSJRIjpiPWxbMV0sTT1sWzJdLGw9aCh5LFMsbFsxXSxsWzJdLGxbM10sbFs0XSk7YnJlYWs7Y2FzZSJMIjpsPWYoeSxTLGxbMV0sbFsyXSk7YnJlYWs7Y2FzZSJIIjpsPWYoeSxTLGxbMV0sUyk7YnJlYWs7Y2FzZSJWIjpsPWYoeSxTLHksbFsxXSk7YnJlYWs7Y2FzZSJaIjpsPWYoeSxTLE8sbSk7YnJlYWt9YT12LHk9bFtsLmxlbmd0aC0yXSxTPWxbbC5sZW5ndGgtMV0sbC5sZW5ndGg+ND8oRT1sW2wubGVuZ3RoLTRdLHA9bFtsLmxlbmd0aC0zXSk6KEU9eSxwPVMpLGQucHVzaChsKX1yZXR1cm4gZH1mdW5jdGlvbiBmKHUsYSxkLEUpe3JldHVyblsiQyIsdSxhLGQsRSxkLEVdfWZ1bmN0aW9uIGgodSxhLGQsRSxwLE8pe3JldHVyblsiQyIsdS8zKzIvMypkLGEvMysyLzMqRSxwLzMrMi8zKmQsTy8zKzIvMypFLHAsT119fSxmdW5jdGlvbihnLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiB1fSksdCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IG49TWF0aC5QSSoyO2Z1bmN0aW9uIGkoYSxkLEUscCl7Y29uc3QgTz1hKnAtZCpFPDA/LTE6MTtsZXQgbT1hKkUrZCpwO3JldHVybiBtPjEmJihtPTEpLG08LTEmJihtPS0xKSxPKk1hdGguYWNvcyhtKX1mdW5jdGlvbiBmKGEsZCxFLHAsTyxtLGIsTSx5LFMpe2NvbnN0IHM9UyooYS1FKS8yK3kqKGQtcCkvMixjPS15KihhLUUpLzIrUyooZC1wKS8yLGw9YipiLHY9TSpNLFQ9cypzLFI9YypjO2xldCBMPWwqdi1sKlItdipUO0w8MCYmKEw9MCksTC89bCpSK3YqVCxMPU1hdGguc3FydChMKSooTz09PW0/LTE6MSk7Y29uc3QgTj1MKmIvTSpjLEE9TCotTS9iKnMsdz1TKk4teSpBKyhhK0UpLzIsQj15Kk4rUypBKyhkK3ApLzIsRD0ocy1OKS9iLEk9KGMtQSkvTSxqPSgtcy1OKS9iLFY9KC1jLUEpL00sSj1pKDEsMCxELEkpO2xldCBfPWkoRCxJLGosVik7cmV0dXJuIG09PT0wJiZfPjAmJihfLT1uKSxtPT09MSYmXzwwJiYoXys9biksW3csQixKLF9dfWZ1bmN0aW9uIGgoYSxkKXtjb25zdCBFPTEuMzMzMzMzMzMzMzMzMzMzMypNYXRoLnRhbihkLzQpLHA9TWF0aC5jb3MoYSksTz1NYXRoLnNpbihhKSxtPU1hdGguY29zKGErZCksYj1NYXRoLnNpbihhK2QpO3JldHVybltwLE8scC1PKkUsTytwKkUsbStiKkUsYi1tKkUsbSxiXX1mdW5jdGlvbiB1KGEsZCxFLHAsTyxtLGIsTSx5KXtjb25zdCBTPU1hdGguc2luKHkqbi8zNjApLHM9TWF0aC5jb3MoeSpuLzM2MCksYz1zKihhLUUpLzIrUyooZC1wKS8yLGw9LVMqKGEtRSkvMitzKihkLXApLzI7aWYoYz09PTAmJmw9PT0wKXJldHVybltdO2lmKGI9PT0wfHxNPT09MClyZXR1cm5bXTtiPU1hdGguYWJzKGIpLE09TWF0aC5hYnMoTSk7Y29uc3Qgdj1jKmMvKGIqYikrbCpsLyhNKk0pO3Y+MSYmKGIqPU1hdGguc3FydCh2KSxNKj1NYXRoLnNxcnQodikpO2NvbnN0IFQ9ZihhLGQsRSxwLE8sbSxiLE0sUyxzKSxSPVtdO2xldCBMPVRbMl0sTj1UWzNdO2NvbnN0IEE9TWF0aC5tYXgoTWF0aC5jZWlsKE1hdGguYWJzKE4pLyhuLzQpKSwxKTtOLz1BO2ZvcihsZXQgdz0wO3c8QTt3KyspUi5wdXNoKGgoTCxOKSksTCs9TjtyZXR1cm4gUi5tYXAodz0+e2ZvcihsZXQgQj0wO0I8dy5sZW5ndGg7Qis9Mil7bGV0IEQ9d1tCKzBdLEk9d1tCKzFdO0QqPWIsSSo9TTtjb25zdCBqPXMqRC1TKkksVj1TKkQrcypJO3dbQiswXT1qK1RbMF0sd1tCKzFdPVYrVFsxXX1yZXR1cm4gd30pfX0sZnVuY3Rpb24oZyxlLHQpe3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTt2YXIgbj10KDQ3KSx7Y29weTppfT10KDQ5KSxmPXQoNTApO2Z1bmN0aW9uIGgocCxPLG0pe3JldHVybiBwWzBdPU8scFsxXT1tLHB9dmFyIHU9WzAsMF0sYT1bMCwwXSxkPVswLDBdO2Z1bmN0aW9uIEUocCxPLG0sYil7bihtLGgodSxiWzFdLGJbMl0pLGgoYSxiWzNdLGJbNF0pLGgoZCxiWzVdLGJbNl0pLE8scCl9Zy5leHBvcnRzPWZ1bmN0aW9uKE8sbSxiKXt2YXIgTT1bXSx5PVtdLFM9WzAsMF07cmV0dXJuIE8uZm9yRWFjaChmdW5jdGlvbihzLGMsbCl7aWYoc1swXT09PSJNIilpKFMscy5zbGljZSgxKSkseS5sZW5ndGg+MCYmKE0ucHVzaCh5KSx5PVtdKTtlbHNlIGlmKHNbMF09PT0iQyIpRSh5LG0sUyxzKSxoKFMsc1s1XSxzWzZdKTtlbHNlIHRocm93IG5ldyBFcnJvcigiaWxsZWdhbCB0eXBlIGluIFNWRzogIitzWzBdKX0pLHkubGVuZ3RoPjAmJk0ucHVzaCh5KSxNLm1hcChmdW5jdGlvbihzKXtyZXR1cm4gZihzLGJ8fDApfSl9fSxmdW5jdGlvbihnLGUsdCl7Zy5leHBvcnRzPXQoNDgpKCl9LGZ1bmN0aW9uKGcsZSl7ZnVuY3Rpb24gdChpKXtyZXR1cm5baVswXSxpWzFdXX1mdW5jdGlvbiBuKGksZil7cmV0dXJuW2ksZl19Zy5leHBvcnRzPWZ1bmN0aW9uKGYpe2Y9Znx8e307dmFyIGg9dHlwZW9mIGYucmVjdXJzaW9uPT0ibnVtYmVyIj9mLnJlY3Vyc2lvbjo4LHU9dHlwZW9mIGYuZXBzaWxvbj09Im51bWJlciI/Zi5lcHNpbG9uOjExOTIwOTI5ZS0xNCxhPXR5cGVvZiBmLnBhdGhFcHNpbG9uPT0ibnVtYmVyIj9mLnBhdGhFcHNpbG9uOjEsZD10eXBlb2YgZi5hbmdsZUVwc2lsb249PSJudW1iZXIiP2YuYW5nbGVFcHNpbG9uOi4wMSxFPWYuYW5nbGVUb2xlcmFuY2V8fDAscD1mLmN1c3BMaW1pdHx8MDtyZXR1cm4gZnVuY3Rpb24oTSx5LFMscyxjLGwpe2x8fChsPVtdKSxjPXR5cGVvZiBjPT0ibnVtYmVyIj9jOjE7dmFyIHY9YS9jO3JldHVybiB2Kj12LE8oTSx5LFMscyxsLHYpLGx9O2Z1bmN0aW9uIE8oYixNLHksUyxzLGMpe3MucHVzaCh0KGIpKTt2YXIgbD1iWzBdLHY9YlsxXSxUPU1bMF0sUj1NWzFdLEw9eVswXSxOPXlbMV0sQT1TWzBdLHc9U1sxXTttKGwsdixULFIsTCxOLEEsdyxzLGMsMCkscy5wdXNoKHQoUykpfWZ1bmN0aW9uIG0oYixNLHksUyxzLGMsbCx2LFQsUixMKXtpZighKEw+aCkpe3ZhciBOPU1hdGguUEksQT0oYit5KS8yLHc9KE0rUykvMixCPSh5K3MpLzIsRD0oUytjKS8yLEk9KHMrbCkvMixqPShjK3YpLzIsVj0oQStCKS8yLEo9KHcrRCkvMixfPShCK0kpLzIsc3Q9KEQraikvMixHPShWK18pLzIsWT0oSitzdCkvMjtpZihMPjApe3ZhciBydD1sLWIsb3Q9di1NLGF0PU1hdGguYWJzKCh5LWwpKm90LShTLXYpKnJ0KSxodD1NYXRoLmFicygocy1sKSpvdC0oYy12KSpydCksaXQsTXQ7aWYoYXQ+dSYmaHQ+dSl7aWYoKGF0K2h0KSooYXQraHQpPD1SKihydCpydCtvdCpvdCkpe2lmKEU8ZCl7VC5wdXNoKG4oRyxZKSk7cmV0dXJufXZhciBPdD1NYXRoLmF0YW4yKGMtUyxzLXkpO2lmKGl0PU1hdGguYWJzKE90LU1hdGguYXRhbjIoUy1NLHktYikpLE10PU1hdGguYWJzKE1hdGguYXRhbjIodi1jLGwtcyktT3QpLGl0Pj1OJiYoaXQ9MipOLWl0KSxNdD49TiYmKE10PTIqTi1NdCksaXQrTXQ8RSl7VC5wdXNoKG4oRyxZKSk7cmV0dXJufWlmKHAhPT0wKXtpZihpdD5wKXtULnB1c2gobih5LFMpKTtyZXR1cm59aWYoTXQ+cCl7VC5wdXNoKG4ocyxjKSk7cmV0dXJufX19fWVsc2UgaWYoYXQ+dSl7aWYoYXQqYXQ8PVIqKHJ0KnJ0K290Km90KSl7aWYoRTxkKXtULnB1c2gobihHLFkpKTtyZXR1cm59aWYoaXQ9TWF0aC5hYnMoTWF0aC5hdGFuMihjLVMscy15KS1NYXRoLmF0YW4yKFMtTSx5LWIpKSxpdD49TiYmKGl0PTIqTi1pdCksaXQ8RSl7VC5wdXNoKG4oeSxTKSksVC5wdXNoKG4ocyxjKSk7cmV0dXJufWlmKHAhPT0wJiZpdD5wKXtULnB1c2gobih5LFMpKTtyZXR1cm59fX1lbHNlIGlmKGh0PnUpe2lmKGh0Kmh0PD1SKihydCpydCtvdCpvdCkpe2lmKEU8ZCl7VC5wdXNoKG4oRyxZKSk7cmV0dXJufWlmKGl0PU1hdGguYWJzKE1hdGguYXRhbjIodi1jLGwtcyktTWF0aC5hdGFuMihjLVMscy15KSksaXQ+PU4mJihpdD0yKk4taXQpLGl0PEUpe1QucHVzaChuKHksUykpLFQucHVzaChuKHMsYykpO3JldHVybn1pZihwIT09MCYmaXQ+cCl7VC5wdXNoKG4ocyxjKSk7cmV0dXJufX19ZWxzZSBpZihydD1HLShiK2wpLzIsb3Q9WS0oTSt2KS8yLHJ0KnJ0K290Km90PD1SKXtULnB1c2gobihHLFkpKTtyZXR1cm59fW0oYixNLEEsdyxWLEosRyxZLFQsUixMKzEpLG0oRyxZLF8sc3QsSSxqLGwsdixULFIsTCsxKX19fX0sZnVuY3Rpb24oZyxlLHQpe3QucihlKSx0LmQoZSwiY3JlYXRlIixmdW5jdGlvbigpe3JldHVybiBmfSksdC5kKGUsImNsb25lIixmdW5jdGlvbigpe3JldHVybiBpfSksdC5kKGUsImNvcHkiLGZ1bmN0aW9uKCl7cmV0dXJuIGh9KSx0LmQoZSwic2NhbGVBbmRBZGQiLGZ1bmN0aW9uKCl7cmV0dXJuIHV9KSx0LmQoZSwiZG90IixmdW5jdGlvbigpe3JldHVybiBhfSksdC5kKGUsInJvdGF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gZH0pLHQuZChlLCJjcm9zcyIsZnVuY3Rpb24oKXtyZXR1cm4gRX0pLHQuZChlLCJzdWIiLGZ1bmN0aW9uKCl7cmV0dXJuIHB9KSx0LmQoZSwiYWRkIixmdW5jdGlvbigpe3JldHVybiBPfSksdC5kKGUsImNvbXB1dGVNaXRlciIsZnVuY3Rpb24oKXtyZXR1cm4geX0pLHQuZChlLCJub3JtYWwiLGZ1bmN0aW9uKCl7cmV0dXJuIFN9KSx0LmQoZSwiZGlyZWN0aW9uIixmdW5jdGlvbigpe3JldHVybiBzfSk7dmFyIG49dCgxKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gaShjKXtyZXR1cm5bY1swXSxjWzFdXX1mdW5jdGlvbiBmKCl7cmV0dXJuWzAsMF19Y29uc3QgaD1uLnZlYzIuY29weSx1PW4udmVjMi5zY2FsZUFuZEFkZCxhPW4udmVjMi5kb3QsZD1uLnZlYzIucm90YXRlLEU9bi52ZWMyLmNyb3NzLHA9bi52ZWMyLnN1YixPPW4udmVjMi5hZGQsbT1uLnZlYzIubm9ybWFsaXplLGI9bi52ZWMyLnNldCxNPWYoKTtmdW5jdGlvbiB5KGMsbCx2LFQsUil7TyhjLHYsVCksbShjLGMpLGIobCwtY1sxXSxjWzBdKSxiKE0sLXZbMV0sdlswXSk7Y29uc3QgTD1SL2EobCxNKTtyZXR1cm4gTWF0aC5hYnMoTCl9ZnVuY3Rpb24gUyhjLGwpe3JldHVybiBiKGMsLWxbMV0sbFswXSksY31mdW5jdGlvbiBzKGMsbCx2KXtyZXR1cm4gcChjLGwsdiksbShjLGMpLGN9fSxmdW5jdGlvbihnLGUsdCl7dmFyIG49dCg1MSksaT10KDUyKTtnLmV4cG9ydHM9ZnVuY3Rpb24oaCx1KXtyZXR1cm4gaD1uKGgsdSksaD1pKGgsdSksaH0sZy5leHBvcnRzLnJhZGlhbERpc3RhbmNlPW4sZy5leHBvcnRzLmRvdWdsYXNQZXVja2VyPWl9LGZ1bmN0aW9uKGcsZSl7ZnVuY3Rpb24gdChuLGkpe3ZhciBmPW5bMF0taVswXSxoPW5bMV0taVsxXTtyZXR1cm4gZipmK2gqaH1nLmV4cG9ydHM9ZnVuY3Rpb24oaSxmKXtpZihpLmxlbmd0aDw9MSlyZXR1cm4gaTtmPXR5cGVvZiBmPT0ibnVtYmVyIj9mOjE7Zm9yKHZhciBoPWYqZix1PWlbMF0sYT1bdV0sZCxFPTEscD1pLmxlbmd0aDtFPHA7RSsrKWQ9aVtFXSx0KGQsdSk+aCYmKGEucHVzaChkKSx1PWQpO3JldHVybiB1IT09ZCYmYS5wdXNoKGQpLGF9fSxmdW5jdGlvbihnLGUpe2Z1bmN0aW9uIHQoaSxmLGgpe3ZhciB1PWZbMF0sYT1mWzFdLGQ9aFswXS11LEU9aFsxXS1hO2lmKGQhPT0wfHxFIT09MCl7dmFyIHA9KChpWzBdLXUpKmQrKGlbMV0tYSkqRSkvKGQqZCtFKkUpO3A+MT8odT1oWzBdLGE9aFsxXSk6cD4wJiYodSs9ZCpwLGErPUUqcCl9cmV0dXJuIGQ9aVswXS11LEU9aVsxXS1hLGQqZCtFKkV9ZnVuY3Rpb24gbihpLGYsaCx1LGEpe2Zvcih2YXIgZD11LEUscD1mKzE7cDxoO3ArKyl7dmFyIE89dChpW3BdLGlbZl0saVtoXSk7Tz5kJiYoRT1wLGQ9Tyl9ZD51JiYoRS1mPjEmJm4oaSxmLEUsdSxhKSxhLnB1c2goaVtFXSksaC1FPjEmJm4oaSxFLGgsdSxhKSl9Zy5leHBvcnRzPWZ1bmN0aW9uKGYsaCl7aWYoZi5sZW5ndGg8PTEpcmV0dXJuIGY7aD10eXBlb2YgaD09Im51bWJlciI/aDoxO3ZhciB1PWgqaCxhPWYubGVuZ3RoLTEsZD1bZlswXV07cmV0dXJuIG4oZiwwLGEsdSxkKSxkLnB1c2goZlthXSksZH19LGZ1bmN0aW9uKGcsZSx0KXt0LnIoZSksdC5kKGUsImdldFRvdGFsTGVuZ3RoIixmdW5jdGlvbigpe3JldHVybiBpfSksdC5kKGUsImdldFBvaW50QXRMZW5ndGgiLGZ1bmN0aW9uKCl7cmV0dXJuIGh9KSx0LmQoZSwiZ2V0RGFzaENvbnRvdXJzIixmdW5jdGlvbigpe3JldHVybiB1fSk7dmFyIG49dCg1NCk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIGkoYSl7aWYoYS50b3RhbExlbmd0aCE9bnVsbClyZXR1cm4gYS50b3RhbExlbmd0aDtsZXQgZD0wO3JldHVybiBhLmZvckVhY2goRT0+e2xldCBwPUVbMF07Zm9yKGxldCBPPTE7TzxFLmxlbmd0aDtPKyspe2NvbnN0IG09RVtPXTtkKz1PYmplY3Qobi5kaXN0YW5jZSkocCxtKSxwPW19fSksYS50b3RhbExlbmd0aD1kLGR9ZnVuY3Rpb24gZihhLGQsRT0hMCl7aWYoZD1OdW1iZXIoZCksIU51bWJlci5pc0Zpbml0ZShkKSl0aHJvdyBuZXcgVHlwZUVycm9yKCJGYWlsZWQgdG8gZXhlY3V0ZSAnZ2V0UG9pbnRBdExlbmd0aCcgb24gZmlndXJlOiBUaGUgcHJvdmlkZWQgZmxvYXQgdmFsdWUgaXMgbm9uLWZpbml0ZS4iKTtpZihkPD0wKXRocm93IG5ldyBUeXBlRXJyb3IoIkxlbmd0aCBtdXN0ID4gMCIpO2NvbnN0IHA9aShhKTtpZihkPj1wKXtjb25zdCBtPWFbYS5sZW5ndGgtMV0sYj1tW20ubGVuZ3RoLTJdLE09bVttLmxlbmd0aC0xXSx5PU1hdGguYXRhbjIoTVsxXS1iWzFdLE1bMF0tYlswXSk7cmV0dXJue2N1cnJlbnQ6YS5tYXAoUz0+Wy4uLlNdKSxwb2ludDp7eDpNWzBdLHk6TVsxXSxhbmdsZTp5fX19Y29uc3QgTz1bXTtmb3IobGV0IG09MDttPGEubGVuZ3RoO20rKyl7T1ttXT1bXTtjb25zdCBiPWFbbV07bGV0IE09YlswXTtmb3IobGV0IHk9MTt5PGIubGVuZ3RoO3krKyl7Y29uc3QgUz1iW3ldLHM9T2JqZWN0KG4uZGlzdGFuY2UpKE0sUyk7aWYoZDxzKXtjb25zdCBjPWQvcyxsPU1hdGguYXRhbjIoU1sxXS1NWzFdLFNbMF0tTVswXSksdj17eDpNWzBdKigxLWMpK1NbMF0qYyx5Ok1bMV0qKDEtYykrU1sxXSpjLGFuZ2xlOmx9O2lmKE9bbV0ucHVzaChNKSxkPjAmJk9bbV0ucHVzaChbdi54LHYueV0pLCFFKXJldHVybntjdXJyZW50Ok8scG9pbnQ6dn07Y29uc3QgVD1bXSxSPW07Zm9yKDttPGEubGVuZ3RoO20rKyl7Zm9yKFRbbS1SXT1bXSxtPT09UiYmVFswXS5wdXNoKFt2Lngsdi55XSk7eTxiLmxlbmd0aDt5KyspVFttLVJdLnB1c2goYlt5XSk7eT0wfXJldHVybntjdXJyZW50Ok8scG9pbnQ6dixyZXN0OlR9fWQtPXMsT1ttXS5wdXNoKE0pLE09U319fWZ1bmN0aW9uIGgoYSxkKXtpZihkPU51bWJlcihkKSwhTnVtYmVyLmlzRmluaXRlKGQpKXRocm93IG5ldyBUeXBlRXJyb3IoIkZhaWxlZCB0byBleGVjdXRlICdnZXRQb2ludEF0TGVuZ3RoJyBvbiBmaWd1cmU6IFRoZSBwcm92aWRlZCBmbG9hdCB2YWx1ZSBpcyBub24tZmluaXRlLiIpO2lmKGEubGVuZ3RoPD0wKXJldHVybnt4OjAseTowLGFuZ2xlOjB9O2lmKGQ8PTApe2NvbnN0IEU9YVswXVswXSxwPWFbMF1bMV0sTz1NYXRoLmF0YW4yKHBbMV0tRVsxXSxwWzBdLUVbMF0pO3JldHVybnt4OkVbMF0seTpFWzFdLGFuZ2xlOk99fXJldHVybiBmKGEsZCwhMSkucG9pbnR9ZnVuY3Rpb24gdShhLGQsRSl7bGV0IHA9MCxPPWRbMF0sbT1hO2NvbnN0IGI9W10sTT1kLmxlbmd0aDtpZihFPjApe2RvIEUtPWRbcCVNXSxwKys7d2hpbGUoRT4wKTtFPDAmJihPPS1FLHAtLSl9ZWxzZSBpZihFPDApe3A9LTE7ZG8gRSs9ZFtwJU0rTS0xXSxwLS07d2hpbGUoRTwwKTtFPj0wJiYocCsrLE89ZFtwJU0rTS0xXS1FKX1kb3tjb25zdCB5PWYobSxPKTttPXkucmVzdCwrK3AlMiYmYi5wdXNoKC4uLnkuY3VycmVudCk7bGV0IFM9cCVNO1M8MCYmKFMrPU0pLE89ZFtTXX13aGlsZShtKTtyZXR1cm4gYn19LGZ1bmN0aW9uKGcsZSx0KXt0LnIoZSksdC5kKGUsIm5vcm1hbGl6ZSIsZnVuY3Rpb24oKXtyZXR1cm4gbn0pLHQuZChlLCJkaXN0YW5jZSIsZnVuY3Rpb24oKXtyZXR1cm4gaX0pLHQoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBuKFtmLGgsdV0sYSxkLEUpe3JldHVybiBmPWYqMi9hLTEsaD0xLWgqMi9kLE51bWJlci5pc0Zpbml0ZShFKT8odT11KjIvRS0xLFtmLGgsdV0pOltmLGhdfWZ1bmN0aW9uIGkoW2YsaCx1PTBdLFthLGQsRT0wXSl7cmV0dXJuIE1hdGguaHlwb3QoYS1mLGQtaCxFLXUpfX0sZnVuY3Rpb24oZyxlLHQpe3QucihlKSx0LmQoZSwiZ2V0UG9pbnQiLGZ1bmN0aW9uKCl7cmV0dXJuIGl9KSx0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3Qgbj1NYXRoLlBJKjI7ZnVuY3Rpb24gaShmLGgsdSxhLGQpe2QlPW4sZDwwJiYoZCs9bik7Y29uc3QgRT1NYXRoLnRhbihkKTtpZihNYXRoLmFicyhFKTwxZTUpe2NvbnN0IHA9aC1FKmYsTz0xL3UqKjIrRSoqMi9hKioyO2xldCBtPS0xOyhkPD1NYXRoLlBJLzJ8fGQ+MypNYXRoLlBJLzIpJiYobT0xKTtjb25zdCBiPW0qTWF0aC5zcXJ0KDEvTykrZixNPUUqYitwO3JldHVybltiLE1dfXJldHVybiBkPE1hdGguUEk/W2YsaCthXTpbZixoLWFdfX0sZnVuY3Rpb24oZyxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gUX0pO3ZhciBuPXQoMSksaT10KDQyKSxmPXQubihpKSxoPXQoNTcpLHU9dCgyOCksYT10KDI0KSxkPXQoMzApLEU9dCg1OSkscD10KDUzKSxPPXQoNjApLG09dC5uKE8pLGI9dCg0NiksTT10Lm4oYikseT10KDMxKSxTPXQoNDApLHM9dCgyMSk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIGModHQsRil7aWYodHQ9PW51bGwpcmV0dXJue307dmFyIEg9bCh0dCxGKSx4LFA7aWYoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyl7dmFyIFc9T2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyh0dCk7Zm9yKFA9MDtQPFcubGVuZ3RoO1ArKyl4PVdbUF0sIShGLmluZGV4T2YoeCk+PTApJiZPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodHQseCkmJihIW3hdPXR0W3hdKX1yZXR1cm4gSH1mdW5jdGlvbiBsKHR0LEYpe2lmKHR0PT1udWxsKXJldHVybnt9O3ZhciBIPXt9LHg9T2JqZWN0LmtleXModHQpLFAsVztmb3IoVz0wO1c8eC5sZW5ndGg7VysrKVA9eFtXXSwhKEYuaW5kZXhPZihQKT49MCkmJihIW1BdPXR0W1BdKTtyZXR1cm4gSH1jb25zdCB2PVN5bWJvbCgibWVzaCIpLFQ9U3ltYm9sKCJjb250b3VycyIpLFI9U3ltYm9sKCJzdHJva2UiKSxMPVN5bWJvbCgiZmlsbCIpLE49U3ltYm9sKCJzdHJva2VDb2xvciIpLEE9U3ltYm9sKCJmaWxsQ29sb3IiKSx3PVN5bWJvbCgidHJhbnNmb3JtIiksQj1TeW1ib2woImludmVydFRyYW5zZm9ybSIpLEQ9U3ltYm9sKCJ1bmlmb3JtcyIpLEk9U3ltYm9sKCJ0ZXhPcHRpb25zIiksaj1TeW1ib2woImJsZW5kIiksVj1TeW1ib2woImFwcGx5VGV4dHVyZSIpLEo9U3ltYm9sKCJhcHBseVRyYW5zZm9ybSIpLF89U3ltYm9sKCJhcHBseUdyYWRpZW50VHJhbnNmb3JtIiksc3Q9U3ltYm9sKCJhcHBseVByb2dyYW0iKSxHPVN5bWJvbCgiZ3JhZGllbnQiKSxZPVN5bWJvbCgiZmlsdGVyIikscnQ9U3ltYm9sKCJvcGFjaXR5Iiksb3Q9U3ltYm9sKCJwcm9ncmFtIiksYXQ9U3ltYm9sKCJhdHRyaWJ1dGVzIiksaHQ9U3ltYm9sKCJwYXNzIiksaXQ9U3ltYm9sKCJjbGlwQ29udGV4dCIpLE10PVN5bWJvbCgiYXBwbHlDbGlwUGF0aCIpO2Z1bmN0aW9uIE90KHR0LEYpe2NvbnN0W0gseF09W3R0WzFdWzBdLXR0WzBdWzBdLHR0WzFdWzFdLXR0WzBdWzFdXSxQPVtdO2ZvcihsZXQgVz0wO1c8Ri5sZW5ndGg7VysrKXtjb25zdCBLPUZbV10sWj1bKEtbMF0tdHRbMF1bMF0pL0gsMS0oS1sxXS10dFswXVsxXSkveF07UC5wdXNoKFopfXJldHVybiBQfWZ1bmN0aW9uIFUoW3R0LEZdLFtILHgsUCxXXSx7c2NhbGU6S30pe3JldHVybiBLfHwodHQvPVAsRj0xLUYvVyx0dC09SCxGKz14KSxbdHQsRiwwXX1mdW5jdGlvbiAkKHR0LEYsSCl7Y29uc3QgeD1NKCkodHQsRixIKTtyZXR1cm4geC5wYXRoPXR0LHguc2ltcGxpZnk9SCx4LnNjYWxlPUYseH1jbGFzcyBRe2NvbnN0cnVjdG9yKEYpe3RoaXNbUl09bnVsbCx0aGlzW0xdPW51bGwsdGhpc1t3XT1bMSwwLDAsMSwwLDBdLHRoaXNbcnRdPTEsdGhpc1tEXT17fSx0aGlzW1ldPVtdLHRoaXNbal09bnVsbCx0aGlzW0ldPXt9LHRoaXMuY29udG91cnM9Ri5jb250b3Vycyx0aGlzW290XT1udWxsLHRoaXNbYXRdPXt9LHRoaXNbaHRdPVtdfWdldCBjb250b3Vycygpe3JldHVybiB0aGlzW1RdfXNldCBjb250b3VycyhGKXt0aGlzW3ZdPW51bGwsdGhpc1tUXT1GO2NvbnN0IEg9Ri5zY2FsZTt0aGlzLnRyYW5zZm9ybVNjYWxlL0g+MS41JiZ0aGlzLmFjY3VyYXRlKHRoaXMudHJhbnNmb3JtU2NhbGUpfXNldFByb2dyYW0oRil7dGhpc1tvdF09Rix0aGlzW3ZdJiZ0aGlzW3N0XShGKX1nZXQgcHJvZ3JhbSgpe3JldHVybiB0aGlzW290XX1zZXRBdHRyaWJ1dGUoRixIKXtIPT1udWxsP2RlbGV0ZSB0aGlzW2F0XVtGXTp0aGlzW2F0XVtGXT1IfWdldE9wYWNpdHkoKXtyZXR1cm4gdGhpc1tydF19c2V0T3BhY2l0eShGKXtpZihGPDB8fEY+MSl0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIG9wYWNpdHkgdmFsdWUuIik7dGhpc1t2XSYmdGhpc1t2XS5wb3NpdGlvbnMuZm9yRWFjaChIPT57SFsyXT0xL0hbMl0+MD9GOi1GfSksdGhpc1tydF09Rn1zZXRDbGlwUGF0aChGKXt0aGlzLmNsaXBQYXRoPUYsdGhpc1tEXS51X2NsaXBTYW1wbGVyJiZ0aGlzW0RdLnVfY2xpcFNhbXBsZXIuZGVsZXRlKCksdGhpcy5zZXRVbmlmb3Jtcyh7dV9jbGlwU2FtcGxlcjpudWxsfSksdGhpc1t2XSYmZGVsZXRlIHRoaXNbdl0uYXR0cmlidXRlcy5hX2NsaXBVVixGJiZ0aGlzW3ZdJiZ0aGlzW010XSgpfVtNdF0oKXtpZih0aGlzLmNsaXBQYXRoKXt0aGlzW2l0XXx8KHRoaXNbaXRdPXMuZGVmYXVsdC5jcmVhdGVDYW52YXMoMSwxKSk7Y29uc3RbW0YsSF0sW3gsUF1dPXRoaXMuYm91bmRpbmdCb3g7eCYmUCYmKHRoaXNbaXRdLndpZHRoPXgtRix0aGlzW2l0XS5oZWlnaHQ9UC1IKTtjb25zdCBXPXRoaXNbaXRdLmdldENvbnRleHQoIjJkIiksSz1uZXcgUGF0aDJEKHRoaXMuY2xpcFBhdGgpO1cuY2xlYXJSZWN0KDAsMCx0aGlzW2l0XS53aWR0aCx0aGlzW2l0XS5oZWlnaHQpLFcuc2F2ZSgpLFcudHJhbnNsYXRlKC1GLC1IKSxXLmZpbGxTdHlsZT0id2hpdGUiLFcuZmlsbChLKSxXLnJlc3RvcmUoKSx0aGlzW3ZdLmNsaXBQYXRoPXRoaXNbaXRdO2NvbnN0IFo9T3QodGhpcy5ib3VuZGluZ0JveCx0aGlzW3ZdLnBvc2l0aW9uMCk7dGhpc1t2XS5hdHRyaWJ1dGVzLmFfY2xpcFVWPVp9fWdldFBvaW50QXRMZW5ndGgoRil7cmV0dXJuIE9iamVjdChwLmdldFBvaW50QXRMZW5ndGgpKHRoaXNbVF0sRil9Z2V0VG90YWxMZW5ndGgoKXtyZXR1cm4gT2JqZWN0KHAuZ2V0VG90YWxMZW5ndGgpKHRoaXNbVF0pfWdldCBibGVuZCgpe3JldHVybiB0aGlzW2pdPT1udWxsPyJhdXRvIjp0aGlzW2pdfXNldCBibGVuZChGKXt0aGlzW2pdPUYsdGhpc1t2XSYmKHRoaXNbdl0uZW5hYmxlQmxlbmQ9dGhpcy5lbmFibGVCbGVuZCl9Z2V0IGJvdW5kaW5nQm94KCl7aWYodGhpc1t2XSYmdGhpc1t2XS5ib3VuZGluZ0JveClyZXR1cm4gdGhpc1t2XS5ib3VuZGluZ0JveDtjb25zdCBGPXRoaXMubWVzaERhdGE7aWYoRil7Y29uc3QgSD1GLnBvc2l0aW9uMDtpZihILmxlbmd0aClGLmJvdW5kaW5nQm94PWYoKShIKTtlbHNlIHJldHVybltbMCwwXSxbMCwwXV07cmV0dXJuIEYuYm91bmRpbmdCb3h9cmV0dXJuW1swLDBdLFswLDBdXX1nZXQgYm91bmRpbmdDZW50ZXIoKXtjb25zdCBGPXRoaXMuYm91bmRpbmdCb3g7cmV0dXJuIEY/Wy41KihGWzBdWzBdK0ZbMV1bMF0pLC41KihGWzBdWzFdK0ZbMV1bMV0pXTpbMCwwXX1nZXQgZmlsbFJ1bGUoKXtyZXR1cm4gdGhpc1tMXT90aGlzW0xdLnJ1bGU6Im5vbnplcm8ifWdldCBsaW5lV2lkdGgoKXtyZXR1cm4gdGhpc1tSXT90aGlzW1JdLmxpbmVXaWR0aDowfWdldCBsaW5lQ2FwKCl7cmV0dXJuIHRoaXNbUl0/dGhpc1tSXS5saW5lQ2FwOiIifWdldCBsaW5lSm9pbigpe3JldHVybiB0aGlzW1JdP3RoaXNbUl0ubGluZUpvaW46IiJ9Z2V0IG1pdGVyTGltaXQoKXtyZXR1cm4gdGhpc1tSXT90aGlzW1JdLm1pdGVyTGltaXQ6MH1nZXQgc3Ryb2tlU3R5bGUoKXtyZXR1cm4gdGhpc1tOXSYmdGhpc1tOXVszXSE9PTA/T2JqZWN0KGEuZGVmYXVsdCkodGhpc1tOXSk6IiJ9Z2V0IGxpbmVEYXNoKCl7cmV0dXJuIHRoaXNbUl0/dGhpc1tSXS5saW5lRGFzaDpudWxsfWdldCBsaW5lRGFzaE9mZnNldCgpe3JldHVybiB0aGlzW1JdP3RoaXNbUl0ubGluZURhc2hPZmZzZXQ6MH1nZXQgZmlsbFN0eWxlKCl7cmV0dXJuIHRoaXNbQV0mJnRoaXNbQV1bM10hPT0wP09iamVjdChhLmRlZmF1bHQpKHRoaXNbQV0pOiIifWdldCBncmFkaWVudCgpe3JldHVybiB0aGlzW0ddfWdldCB0ZXh0dXJlKCl7cmV0dXJuIHRoaXNbRF0udV90ZXhTYW1wbGVyP3tpbWFnZTp0aGlzW0RdLnVfdGV4U2FtcGxlci5faW1nLG9wdGlvbnM6dGhpc1tJXX06bnVsbH1nZXQgZW5hYmxlQmxlbmQoKXtyZXR1cm4gdGhpc1tqXT09PSEwfHx0aGlzW2pdPT09ITE/dGhpc1tqXTp0aGlzW3J0XTwxfHx0aGlzW05dIT1udWxsJiZ0aGlzW05dWzNdPDF8fHRoaXNbQV0hPW51bGwmJnRoaXNbQV1bM108MXx8dGhpc1tEXS51X2NvbG9yTWF0cml4IT1udWxsJiZ0aGlzW0RdLnVfY29sb3JNYXRyaXhbMThdPDF8fHRoaXNbRF0udV9yYWRpYWxHcmFkaWVudFZlY3RvciE9bnVsbHx8dGhpcy5iZWZvcmVSZW5kZXJ8fHRoaXMuYWZ0ZXJSZW5kZXJ9Z2V0IGZpbHRlckNhbnZhcygpe3JldHVybi9ibHVyfGRyb3Atc2hhZG93fHVybC8udGVzdCh0aGlzLmZpbHRlcil9Z2V0IGZpbHRlcigpe3JldHVybiB0aGlzW1ldLmpvaW4oIiAiKX1nZXQgdHJhbnNmb3JtTWF0cml4KCl7cmV0dXJuIHRoaXNbd119Z2V0IGludmVydE1hdHJpeCgpe2lmKCF0aGlzW0JdKXtjb25zdCBGPW4ubWF0MmQuaW52ZXJ0KEFycmF5Lm9mKDAsMCwwLDAsMCwwKSx0aGlzW3ddKTt0aGlzW0JdPUZ9cmV0dXJuIHRoaXNbQl19Z2V0IHRyYW5zZm9ybVNjYWxlKCl7Y29uc3QgRj10aGlzW3ddO3JldHVybiBNYXRoLm1heChNYXRoLmh5cG90KEZbMF0sRlsxXSksTWF0aC5oeXBvdChGWzJdLEZbM10pKX1nZXQgdW5pZm9ybXMoKXtyZXR1cm4gdGhpc1tEXX1nZXQgcGFzcygpe3JldHVybiB0aGlzW2h0XX1bc3RdKEYpe2NvbnN0IEg9dGhpc1thdF0seD10aGlzW3ZdLnBvc2l0aW9uMCxQPU9iamVjdC5lbnRyaWVzKEYuX2F0dHJpYnV0ZSk7Zm9yKGxldCBXPTA7VzxQLmxlbmd0aDtXKyspe2NvbnN0W0ssWl09UFtXXTtpZihLIT09ImFfY29sb3IiJiZLIT09ImFfc291cmNlUmVjdCImJlohPT0iaWdub3JlZCIpe2NvbnN0IGs9SFtLXTtpZihLPT09InV2IiYmIWspe2NvbnN0IG50PXRoaXNbdl0uYm91bmRpbmdCb3h8fGYoKSh4KTt0aGlzW3ZdLmF0dHJpYnV0ZXNbS109T3QobnQseCl9ZWxzZXt0aGlzW3ZdLmF0dHJpYnV0ZXNbS109W107Zm9yKGxldCBudD0wO250PHgubGVuZ3RoO250Kyspe2NvbnN0IHV0PXhbbnRdO3RoaXNbdl0uYXR0cmlidXRlc1tLXS5wdXNoKGs/ayh1dCxXLHgpOkFycmF5KFouc2l6ZSkuZmlsbCgwKSl9fX19fWdldCBtZXNoRGF0YSgpe2lmKHRoaXMuX3VwZGF0ZU1hdHJpeCYmdGhpcy50cmFuc2Zvcm1TY2FsZS90aGlzLmNvbnRvdXJzLnNjYWxlPjEuNSYmdGhpcy5hY2N1cmF0ZSh0aGlzLnRyYW5zZm9ybVNjYWxlKSwhdGhpc1t2XSl7IXRoaXNbTF0mJiF0aGlzW1JdJiZ0aGlzLnNldEZpbGwoKTtjb25zdCBGPXRoaXNbVF0sSD17fTtpZihGJiZGLmxlbmd0aCl7aWYodGhpc1tMXSl0cnl7Y29uc3QgVz1tKCkoRix0aGlzW0xdKTtXLnBvc2l0aW9ucz1XLnBvc2l0aW9ucy5tYXAoSz0+KEsucHVzaCh0aGlzW3J0XSksSykpLFcuYXR0cmlidXRlcz17YV9jb2xvcjpBcnJheS5mcm9tKHtsZW5ndGg6Vy5wb3NpdGlvbnMubGVuZ3RofSkubWFwKCgpPT50aGlzW0FdLm1hcChLPT5NYXRoLnJvdW5kKDI1NSpLKSkpfSxILmZpbGw9V31jYXRjaHt9aWYodGhpc1tSXSl7Y29uc3QgVz10aGlzW1JdLmxpbmVEYXNoO2xldCBLPUY7aWYoVyl7Y29uc3Qgaz10aGlzW1JdLmxpbmVEYXNoT2Zmc2V0O0s9T2JqZWN0KHAuZ2V0RGFzaENvbnRvdXJzKShGLFcsayl9Y29uc3QgWj1LLm1hcCgoayxudCk9Pntjb25zdCB1dD1rLmxlbmd0aD4xJiZuLnZlYzIuZXF1YWxzKGtbMF0sa1trLmxlbmd0aC0xXSksY3Q9dGhpc1tSXS5idWlsZChrLHV0KTtyZXR1cm4gbSgpKFtjdF0pfSk7Wi5mb3JFYWNoKGs9PntrLnBvc2l0aW9ucz1rLnBvc2l0aW9ucy5tYXAobnQ9PihudC5wdXNoKC10aGlzW3J0XSksbnQpKSxrLmF0dHJpYnV0ZXM9e2FfY29sb3I6QXJyYXkuZnJvbSh7bGVuZ3RoOmsucG9zaXRpb25zLmxlbmd0aH0pLm1hcCgoKT0+dGhpc1tOXS5tYXAobnQ9Pk1hdGgucm91bmQoMjU1Km50KSkpfX0pLEguc3Ryb2tlPU9iamVjdCh1LmRlZmF1bHQpKFopfX1jb25zdCB4PU9iamVjdCh1LmRlZmF1bHQpKFtILmZpbGwsSC5zdHJva2VdKTt4LmZpbGxQb2ludENvdW50PUguZmlsbD9ILmZpbGwucG9zaXRpb25zLmxlbmd0aDowLHguZW5hYmxlQmxlbmQ9dGhpcy5lbmFibGVCbGVuZCx4LnBvc2l0aW9uMD14LnBvc2l0aW9ucy5tYXAoKFtXLEssWl0pPT5bVyxLLFpdKSx4LnVuaWZvcm1zPXRoaXNbRF0sdGhpc1t2XT14LHRoaXNbRF0udV90ZXhTYW1wbGVyJiZ0aGlzW1ZdKHgsdGhpc1tJXSk7Y29uc3QgUD10aGlzW3ddO09iamVjdChFLmlzVW5pdFRyYW5zZm9ybSkoUCl8fCh0aGlzW0pdKHgsUCksdGhpc1tEXS51X3JhZGlhbEdyYWRpZW50VmVjdG9yJiZ0aGlzW19dKCkpLHRoaXMuY2xpcFBhdGgmJnRoaXNbTXRdKCksdGhpc1tvdF0mJnRoaXNbc3RdKHRoaXNbb3RdKX1yZXR1cm4gdGhpcy5fdXBkYXRlTWF0cml4JiYodGhpc1t2XS5tYXRyaXg9dGhpc1t3XSx0aGlzW0pdKHRoaXNbdl0sdGhpc1t3XSksdGhpc1tEXS51X3JhZGlhbEdyYWRpZW50VmVjdG9yJiZ0aGlzW19dKCkpLHRoaXNbdl19W0pdKEYsSCl7Y29uc3R7cG9zaXRpb25zOngscG9zaXRpb24wOlB9PUY7Zm9yKGxldCBXPTA7Vzx4Lmxlbmd0aDtXKyspe2NvbnN0W0ssWl09UFtXXSxrPXhbV107a1swXT1LKkhbMF0rWipIWzJdK0hbNF0sa1sxXT1LKkhbMV0rWipIWzNdK0hbNV19dGhpcy5fdXBkYXRlTWF0cml4PSExfVtfXSgpe2NvbnN0IEY9dGhpc1t3XSxIPVsuLi50aGlzLl9yYWRpYWxHcmFkaWVudFZlY3Rvcl07aWYoSCl7Y29uc3RbeCxQLCxXLEtdPUg7SFswXT14KkZbMF0rUCpGWzJdK0ZbNF0sSFsxXT14KkZbMV0rUCpGWzNdK0ZbNV0sSFszXT1XKkZbMF0rSypGWzJdK0ZbNF0sSFs0XT1XKkZbMV0rSypGWzNdK0ZbNV0sdGhpc1tEXS51X3JhZGlhbEdyYWRpZW50VmVjdG9yPUh9fVtWXShGLEgpe2Z1bmN0aW9uIHgobnQsdXQpe3JldHVybiBudD09bnVsbCYmdXQ9PW51bGw/ITA6bnQ9PW51bGx8fHV0PT1udWxsPyExOm50WzBdPT09dXRbMF0mJm50WzFdPT09dXRbMV0mJm50WzJdPT09dXRbMl0mJm50WzNdPT09dXRbM119Y29uc3QgUD10aGlzW0RdLnVfdGV4U2FtcGxlcjtpZighUClyZXR1cm47Y29uc3R7d2lkdGg6VyxoZWlnaHQ6S309UC5faW1nLFo9SC5zcmNSZWN0O2xldCBrPUgucmVjdHx8WzAsMF07aWYoSC5yb3RhdGVkJiYoaz1bLWtbMV0sa1swXSxrWzNdLGtbMl1dKSxrWzJdPT1udWxsJiYoa1syXT1aP1pbMl06Vyksa1szXT09bnVsbCYmKGtbM109Wj9aWzNdOkspLEguaGlkZGVuKUYudGV4dHVyZUNvb3JkPUYucG9zaXRpb25zLm1hcCgoKT0+Wy0xLC0xLC0xXSk7ZWxzZSBpZighRi50ZXh0dXJlQ29vcmR8fCF4KHRoaXNbSV0ucmVjdCxILnJlY3QpfHx0aGlzW0ldLmhpZGRlbiE9PUguaGlkZGVufHx0aGlzW0ldLnJvdGF0ZWQhPT1ILnJvdGF0ZWQpe2xldCBudD1udWxsO0gucm90YXRlZCYmKG50PW4ubWF0MmQucm90YXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxuLm1hdDJkLmZyb21WYWx1ZXMoMSwwLDAsMSwwLDApLC41Kk1hdGguUEkpLG50PW4ubWF0MmQudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxudCxbMCwta1syXV0pKSxGLnRleHR1cmVDb29yZD1GLnBvc2l0aW9uMC5tYXAoKFt1dCxjdCxwdF0pPT57aWYoMS9wdD4wKXtpZihILnJvdGF0ZWQpe2NvbnN0IGd0PXV0Km50WzBdK2N0Km50WzJdK250WzRdLGR0PXV0Km50WzFdK2N0Km50WzNdK250WzVdO1t1dCxjdF09W2d0LGR0XX1jb25zdCB4dD1VKFt1dCxjdF0sW2tbMF0va1syXSxrWzFdL2tbM10sa1syXSxrWzNdXSxIKTtyZXR1cm4gSC5yZXBlYXQmJih4dFsyXT0xKSx4dH1yZXR1cm5bLTEsLTEsLTFdfSl9aWYoWil7Y29uc3QgbnQ9W1pbMF0vVyxaWzFdL0ssWlsyXS9XLFpbM10vS107Ri5hdHRyaWJ1dGVzLmFfc291cmNlUmVjdD1GLnBvc2l0aW9ucy5tYXAoKCk9PlsuLi5udF0pfWVsc2UgRi5hdHRyaWJ1dGVzLmFfc291cmNlUmVjdD1GLnBvc2l0aW9ucy5tYXAoKCk9PlswLDAsMCwwXSl9YWNjdXJhdGUoRil7aWYoIXRoaXMuY29udG91cnMpcmV0dXJuO2lmKHRoaXMuY29udG91cnMucGF0aCl7Y29uc3QgeD10aGlzLmNvbnRvdXJzLnNpbXBsaWZ5LFA9JCh0aGlzLmNvbnRvdXJzLnBhdGgsMipGLHgpO3RoaXNbdl09bnVsbCx0aGlzW1RdPVB9fWNhbklnbm9yZSgpe2NvbnN0IEY9dGhpc1tSXT09bnVsbHx8dGhpc1tSXS5saW5lV2lkdGg9PT0wfHx0aGlzW05dWzNdPT09MCxIPXRoaXNbTF09PW51bGx8fHRoaXNbQV1bM109PT0wLHg9dGhpc1tEXS51X3JhZGlhbEdyYWRpZW50VmVjdG9yPT1udWxsLFA9dGhpc1tEXS51X3RleFNhbXBsZXI9PW51bGw7cmV0dXJuIHRoaXNbcnRdPT09MHx8dGhpc1tvdF09PW51bGwmJkYmJkgmJngmJlAmJiF0aGlzLmJlZm9yZVJlbmRlciYmIXRoaXMuYWZ0ZXJSZW5kZXJ9c2V0U3Ryb2tlKHt0aGlja25lc3M6Rj0xLGNhcDpIPSJidXR0Iixqb2luOng9Im1pdGVyIixtaXRlckxpbWl0OlA9MTAsY29sb3I6Vz1bMCwwLDAsMF0sbGluZURhc2g6Sz1udWxsLGxpbmVEYXNoT2Zmc2V0Olo9MCxyb3VuZFNlZ21lbnRzOms9MjB9PXt9KXtyZXR1cm4gdGhpc1t2XT1udWxsLHRoaXNbUl09bmV3IGguZGVmYXVsdCh7bGluZVdpZHRoOkYsbGluZUNhcDpILGxpbmVKb2luOngsbWl0ZXJMaW1pdDpQLHJvdW5kU2VnbWVudHM6a30pLHR5cGVvZiBXPT0ic3RyaW5nIiYmKFc9T2JqZWN0KHkuZGVmYXVsdCkoVykpLHRoaXNbTl09Vyx0aGlzW1JdLmxpbmVEYXNoPUssdGhpc1tSXS5saW5lRGFzaE9mZnNldD1aLHRoaXN9c2V0RmlsbCh7cnVsZTpGPXRoaXMuZmlsbFJ1bGUsY29sb3I6SD1bMCwwLDAsMF19PXt9KXtyZXR1cm4gdGhpc1t2XT1udWxsLHRoaXNbTF09e3J1bGU6Rn0sdHlwZW9mIEg9PSJzdHJpbmciJiYoSD1PYmplY3QoeS5kZWZhdWx0KShIKSksdGhpc1tBXT1ILHRoaXN9c2V0VGV4dHVyZShGLEg9e30pe2lmKEYmJkYuaW1hZ2Upe2NvbnN0e2ltYWdlOngscmVjdDpQfT1GO2lmKEY9eCxILnJlY3QpZm9yKGxldCBXPTA7VzxILnJlY3QubGVuZ3RoO1crKylQW1ddPUgucmVjdFtXXTtILnJlY3Q9UH1yZXR1cm4gdGhpc1tMXXx8dGhpcy5zZXRGaWxsKCksdGhpcy5zZXRVbmlmb3Jtcyh7dV90ZXhTYW1wbGVyOkZ9KSx0aGlzW3ZdJiZ0aGlzW1ZdKHRoaXNbdl0sSCksdGhpc1tJXT1ILHRoaXN9c2V0Q2lyY3VsYXJHcmFkaWVudCh7dmVjdG9yOkYsY29sb3JzOkgsdHlwZTp4PSJmaWxsIn09e30pe2lmKEYubGVuZ3RoIT09Myl0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIGxpbmVhckdyYWRpZW50LiIpO3RoaXMuc2V0R3JhZGllbnQoe3ZlY3RvcjpGLGNvbG9yczpILHR5cGU6eH0pfXNldExpbmVhckdyYWRpZW50KHt2ZWN0b3I6Rixjb2xvcnM6SCx0eXBlOng9ImZpbGwifT17fSl7aWYoRi5sZW5ndGghPT00KXRocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgbGluZWFyR3JhZGllbnQuIik7dGhpcy5zZXRHcmFkaWVudCh7dmVjdG9yOkYsY29sb3JzOkgsdHlwZTp4fSl9c2V0UmFkaWFsR3JhZGllbnQoe3ZlY3RvcjpGLGNvbG9yczpILHR5cGU6eD0iZmlsbCJ9PXt9KXtpZihGLmxlbmd0aCE9PTYpdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCByYWRpYWxHcmFkaWVudC4iKTt0aGlzLnNldEdyYWRpZW50KHt2ZWN0b3I6Rixjb2xvcnM6SCx0eXBlOnh9KX1zZXRHcmFkaWVudCh7dmVjdG9yOkYsY29sb3JzOkgsdHlwZTp4PSJmaWxsIn09e30pe0g9SC5tYXAoKHtvZmZzZXQ6Syxjb2xvcjpafSk9Pih0eXBlb2YgWj09InN0cmluZyImJihaPU9iamVjdCh5LmRlZmF1bHQpKFopKSx7b2Zmc2V0OkssY29sb3I6Wn0pKSx0aGlzW0ddPXRoaXNbR118fHt9LHRoaXNbR11beF09e3ZlY3RvcjpGLGNvbG9yczpIfSxILnNvcnQoKEssWik9Pksub2Zmc2V0LVoub2Zmc2V0KTtjb25zdCBQPVtdO0guZm9yRWFjaCgoe29mZnNldDpLLGNvbG9yOlp9KT0+e1AucHVzaChLLC4uLlopfSk7bGV0IFc7aWYoRi5sZW5ndGg9PT00P1c9W0ZbMF0sRlsxXSwwLEZbMl0sRlszXSwwXTpXPVsuLi5GXSxQLmxlbmd0aDw0MCYmUC5wdXNoKC0xKSxQLmxlbmd0aD40MCl0aHJvdyBuZXcgRXJyb3IoIlRvbyBtYW55IGNvbG9ycywgc2hvdWxkIGJlIGxlc3MgdGhhbiA4IGNvbG9ycyIpO3JldHVybiB0aGlzLl9yYWRpYWxHcmFkaWVudFZlY3Rvcj1XLHRoaXNbRF0udV9jb2xvclN0ZXBzPVAseD09PSJmaWxsIj90aGlzW0RdLnVfZ3JhZGllbnRUeXBlPTE6dGhpc1tEXS51X2dyYWRpZW50VHlwZT0wLHRoaXNbX10oKSx0aGlzfXNldFVuaWZvcm1zKEY9e30pe3JldHVybiBPYmplY3QuYXNzaWduKHRoaXNbRF0sRiksdGhpc31zZXRUcmFuc2Zvcm0oLi4uRil7Y29uc3QgSD10aGlzW3ddO3JldHVybiBuLm1hdDJkLmVxdWFscyhGLEgpfHwodGhpc1t3XT1GLGRlbGV0ZSB0aGlzW0JdLHRoaXMuX3VwZGF0ZU1hdHJpeD0hMCksdGhpc310cmFuc2Zvcm0oLi4uRil7Y29uc3QgSD10aGlzW3ddO3JldHVybiB0aGlzW3ddPW4ubWF0MmQubXVsdGlwbHkoQXJyYXkub2YoMCwwLDAsMCwwLDApLEgsRiksZGVsZXRlIHRoaXNbQl0sdGhpcy5fdXBkYXRlTWF0cml4PSEwLHRoaXN9dHJhbnNsYXRlKEYsSCl7bGV0IHg9bi5tYXQyZC5jcmVhdGUoKTtyZXR1cm4geD1uLm1hdDJkLnRyYW5zbGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCkseCxbRixIXSksdGhpcy50cmFuc2Zvcm0oLi4ueCl9cm90YXRlKEYsW0gseF09WzAsMF0pe2xldCBQPW4ubWF0MmQuY3JlYXRlKCk7cmV0dXJuIFA9bi5tYXQyZC50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDApLFAsW0gseF0pLFA9bi5tYXQyZC5yb3RhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDApLFAsRiksUD1uLm1hdDJkLnRyYW5zbGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCksUCxbLUgsLXhdKSx0aGlzLnRyYW5zZm9ybSguLi5QKX1zY2FsZShGLEg9RixbeCxQXT1bMCwwXSl7bGV0IFc9bi5tYXQyZC5jcmVhdGUoKTtyZXR1cm4gVz1uLm1hdDJkLnRyYW5zbGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCksVyxbeCxQXSksVz1uLm1hdDJkLnNjYWxlKEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxXLFtGLEhdKSxXPW4ubWF0MmQudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxXLFsteCwtUF0pLHRoaXMudHJhbnNmb3JtKC4uLlcpfXNrZXcoRixIPUYsW3gsUF09WzAsMF0pe2xldCBXPW4ubWF0MmQuY3JlYXRlKCk7cmV0dXJuIFc9bi5tYXQyZC50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDApLFcsW3gsUF0pLFc9bi5tYXQyZC5tdWx0aXBseShBcnJheS5vZigwLDAsMCwwLDAsMCksVyxuLm1hdDJkLmZyb21WYWx1ZXMoMSxNYXRoLnRhbihIKSxNYXRoLnRhbihGKSwxLDAsMCkpLFc9bi5tYXQyZC50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDApLFcsWy14LC1QXSksdGhpcy50cmFuc2Zvcm0oLi4uVyl9Y2xlYXJGaWx0ZXIoKXtyZXR1cm4gdGhpcy5zZXRDb2xvclRyYW5zZm9ybShudWxsKSx0aGlzW1ldLmxlbmd0aD0wLHRoaXN9c2V0Q29sb3JUcmFuc2Zvcm0oLi4uRil7cmV0dXJuIEZbMF09PT1udWxsP3RoaXMuc2V0VW5pZm9ybXMoe3VfZmlsdGVyRmxhZzowLHVfY29sb3JNYXRyaXg6MH0pOnRoaXMuc2V0VW5pZm9ybXMoe3VfZmlsdGVyRmxhZzoxLHVfY29sb3JNYXRyaXg6Rn0pLHRoaXN9dHJhbnNmb3JtQ29sb3IoLi4uRil7bGV0IEg9dGhpcy51bmlmb3Jtcy51X2NvbG9yTWF0cml4O3JldHVybiBIP0g9T2JqZWN0KGQubXVsdGlwbHkpKEgsRik6SD1GLHRoaXMuc2V0Q29sb3JUcmFuc2Zvcm0oLi4uSCksdGhpc31ibHVyKEYpe3JldHVybiB0aGlzW1ldLnB1c2goYGJsdXIoJHtGfXB4KWApLHRoaXN9YnJpZ2h0bmVzcyhGPTEpe3JldHVybiB0aGlzW1ldLnB1c2goYGJyaWdodG5lc3MoJHsxMDAqRn0lKWApLHRoaXMudHJhbnNmb3JtQ29sb3IoLi4uT2JqZWN0KGQuYnJpZ2h0bmVzcykoRikpfWNvbnRyYXN0KEY9MSl7cmV0dXJuIHRoaXNbWV0ucHVzaChgY29udHJhc3QoJHsxMDAqRn0lKWApLHRoaXMudHJhbnNmb3JtQ29sb3IoLi4uT2JqZWN0KGQuY29udHJhc3QpKEYpKX1kcm9wU2hhZG93KEYsSCx4PTAsUD1bMCwwLDAsMV0pe3JldHVybiBBcnJheS5pc0FycmF5KFApJiYoUD1PYmplY3QoYS5kZWZhdWx0KShQKSksdGhpc1tZXS5wdXNoKGBkcm9wLXNoYWRvdygke0Z9cHggJHtIfXB4ICR7eH1weCAke1B9KWApLHRoaXN9Z3JheXNjYWxlKEY9MSl7cmV0dXJuIHRoaXNbWV0ucHVzaChgZ3JheXNjYWxlKCR7MTAwKkZ9JSlgKSx0aGlzLnRyYW5zZm9ybUNvbG9yKC4uLk9iamVjdChkLmdyYXlzY2FsZSkoRikpfWh1ZVJvdGF0ZShGPTApe3JldHVybiB0aGlzW1ldLnB1c2goYGh1ZS1yb3RhdGUoJHtGfWRlZylgKSx0aGlzLnRyYW5zZm9ybUNvbG9yKC4uLk9iamVjdChkLmh1ZVJvdGF0ZSkoRikpfWludmVydChGPTEpe3JldHVybiB0aGlzW1ldLnB1c2goYGludmVydCgkezEwMCpGfSUpYCksdGhpcy50cmFuc2Zvcm1Db2xvciguLi5PYmplY3QoZC5pbnZlcnQpKEYpKX1vcGFjaXR5KEY9MSl7cmV0dXJuIHRoaXNbWV0ucHVzaChgb3BhY2l0eSgkezEwMCpGfSUpYCksdGhpcy50cmFuc2Zvcm1Db2xvciguLi5PYmplY3QoZC5vcGFjaXR5KShGKSl9c2F0dXJhdGUoRj0xKXtyZXR1cm4gdGhpc1tZXS5wdXNoKGBzYXR1cmF0ZSgkezEwMCpGfSUpYCksdGhpcy50cmFuc2Zvcm1Db2xvciguLi5PYmplY3QoZC5zYXR1cmF0ZSkoRikpfXNlcGlhKEY9MSl7cmV0dXJuIHRoaXNbWV0ucHVzaChgc2VwaWEoJHsxMDAqRn0lKWApLHRoaXMudHJhbnNmb3JtQ29sb3IoLi4uT2JqZWN0KGQuc2VwaWEpKEYpKX11cmwoRil7cmV0dXJuIHRoaXNbWV0ucHVzaChgdXJsKCR7Rn0pYCksdGhpc31pc1BvaW50Q29sbGlzaW9uKEYsSCx4PSJib3RoIil7Y29uc3QgUD10aGlzLm1lc2hEYXRhLHtwb3NpdGlvbnM6VyxjZWxsczpLfT1QLFo9dGhpcy5pbnZlcnRNYXRyaXgsaz1aWzBdKkYrWlsyXSpIK1pbNF0sbnQ9WlsxXSpGK1pbM10qSCtaWzVdLHV0PXRoaXMuYm91bmRpbmdCb3g7aWYoazx1dFswXVswXXx8az51dFsxXVswXXx8bnQ8dXRbMF1bMV18fG50PnV0WzFdWzFdKXJldHVybiExO2Z1bmN0aW9uIGN0KFtwdCx4dF0sW2d0LGR0XSxbbXQsYnRdKXtjb25zdCBDdD1tdC1ndCxTdD1idC1kdCxOdD0oKHB0LWd0KSpDdCsoeHQtZHQpKlN0KS8oQ3QqKjIrU3QqKjIpO3JldHVybiBOdD49MCYmTnQ8PTF9Zm9yKGxldCBwdD0wO3B0PEsubGVuZ3RoO3B0Kyspe2NvbnN0IHh0PUtbcHRdO2lmKHg9PT0iZmlsbCImJnh0WzBdPj1QLmZpbGxQb2ludENvdW50KWJyZWFrO2lmKHg9PT0ic3Ryb2tlIiYmeHRbMF08UC5maWxsUG9pbnRDb3VudCljb250aW51ZTtjb25zdFtbZ3QsZHRdLFttdCxidF0sW0N0LFN0XV09eHQubWFwKEt0PT5XW0t0XSksTnQ9TWF0aC5zaWduKChGLWd0KSooYnQtZHQpLShtdC1ndCkqKEgtZHQpKTtpZihOdD09PTAmJmN0KFtGLEhdLFtndCxkdF0sW210LGJ0XSkpcmV0dXJuITA7Y29uc3QgSnQ9TWF0aC5zaWduKChGLW10KSooU3QtYnQpLShDdC1tdCkqKEgtYnQpKTtpZihKdD09PTAmJmN0KFtGLEhdLFttdCxidF0sW0N0LFN0XSkpcmV0dXJuITA7Y29uc3QgR3Q9TWF0aC5zaWduKChGLUN0KSooZHQtU3QpLShndC1DdCkqKEgtU3QpKTtpZihHdD09PTAmJmN0KFtGLEhdLFtDdCxTdF0sW2d0LGR0XSl8fE50PT09MSYmSnQ9PT0xJiZHdD09PTF8fE50PT09LTEmJkp0PT09LTEmJkd0PT09LTEpcmV0dXJuITB9cmV0dXJuITF9aXNQb2ludEluRmlsbChGLEgpe3JldHVybiB0aGlzLmlzUG9pbnRDb2xsaXNpb24oRixILCJmaWxsIil9aXNQb2ludEluU3Ryb2tlKEYsSCl7cmV0dXJuIHRoaXMuaXNQb2ludENvbGxpc2lvbihGLEgsInN0cm9rZSIpfWFkZFBhc3MoRixIPXt9KXtsZXR7d2lkdGg6eCxoZWlnaHQ6UH09SCxXPWMoSCxbIndpZHRoIiwiaGVpZ2h0Il0pO2NvbnN0IEs9bmV3IFMuZGVmYXVsdDtLLnJlY3QoMCwwLHgsUCk7Y29uc3QgWj1uZXcgUShLLHt3aWR0aDp4LGhlaWdodDpQfSk7Wi5zZXRVbmlmb3JtcyhXKSxaLnNldFByb2dyYW0oRiksdGhpc1todF0ucHVzaChaKX19fSxmdW5jdGlvbihnLGUsdCl7dC5yKGUpO3ZhciBuPXQoNTgpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KSxlLmRlZmF1bHQ9bi5TdHJva2V9LGZ1bmN0aW9uKGcsZSx0KXt0LnIoZSksdC5kKGUsIlN0cm9rZSIsZnVuY3Rpb24oKXtyZXR1cm4gRX0pO3ZhciBuPXQoNDkpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCBpPU9iamVjdChuLmNyZWF0ZSkoKSxmPU9iamVjdChuLmNyZWF0ZSkoKSxoPU9iamVjdChuLmNyZWF0ZSkoKSx1PU9iamVjdChuLmNyZWF0ZSkoKSxhPU9iamVjdChuLmNyZWF0ZSkoKSxkPTFlMjA7Y2xhc3MgRXtjb25zdHJ1Y3Rvcih7bGluZVdpZHRoOk09MSxsaW5lSm9pbjp5PSJtaXRlciIsbWl0ZXJMaW1pdDpTPTEwLGxpbmVDYXA6cz0iYnV0dCIscm91bmRTZWdtZW50czpjPTIwfT17fSl7dGhpcy5saW5lV2lkdGg9TSx0aGlzLmxpbmVKb2luPXksdGhpcy5taXRlckxpbWl0PVMsdGhpcy5saW5lQ2FwPXMsdGhpcy5yb3VuZFNlZ21lbnRzPWMsdGhpcy5fbm9ybWFsPW51bGx9YnVpbGQoTSx5PSExKXtsZXQgUz1NLmxlbmd0aDtpZihNPVsuLi5NXSxTPDIpcmV0dXJuIE07eSYmKChNWzBdWzBdIT09TVtTLTFdWzBdfHxNWzBdWzFdIT09TVtTLTFdWzFdKSYmTS5wdXNoKFsuLi5NWzBdXSksTS5wdXNoKFsuLi5NWzFdXSkpLFM9TS5sZW5ndGgsdGhpcy5fbm9ybWFsPW51bGw7Y29uc3Qgcz17bGVmdDpbXSxyaWdodDpbXX0sYz10aGlzLmxpbmVXaWR0aC8yLGw9dGhpcy5saW5lQ2FwO2lmKCF5JiZsPT09InNxdWFyZSIpe09iamVjdChuLmRpcmVjdGlvbikoZixNWzBdLE1bMV0pLE9iamVjdChuLnNjYWxlQW5kQWRkKShNWzBdLE1bMF0sZixjKTtjb25zdCBUPU0ubGVuZ3RoLTE7T2JqZWN0KG4uZGlyZWN0aW9uKShmLE1bVF0sTVtULTFdKSxPYmplY3Qobi5zY2FsZUFuZEFkZCkoTVtUXSxNW1RdLGYsYyl9Zm9yKGxldCBUPTE7VDxTO1QrKyl7Y29uc3QgUj1NW1QtMV0sTD1NW1RdLE49TVtUKzFdO3RoaXMuX3NlZyhzLFIsTCxOLGMseSl9cmV0dXJuIXkmJmw9PT0icm91bmQiJiZtKHMsdGhpcy5yb3VuZFNlZ21lbnRzKSxbLi4ucy5sZWZ0LC4uLnMucmlnaHQucmV2ZXJzZSgpXX1fc2VnKE0seSxTLHMsYyxsKXtjb25zdCB2PXRoaXMubGluZUpvaW49PT0iYmV2ZWwiLFQ9dGhpcy5saW5lSm9pbj09PSJyb3VuZCI7aWYoT2JqZWN0KG4uZGlyZWN0aW9uKShmLFMseSksdGhpcy5fbm9ybWFsfHwodGhpcy5fbm9ybWFsPU9iamVjdChuLmNyZWF0ZSkoKSxPYmplY3Qobi5ub3JtYWwpKHRoaXMuX25vcm1hbCxmKSksTS5sZWZ0Lmxlbmd0aHx8TyhNLHksdGhpcy5fbm9ybWFsLGMpLCFzKU9iamVjdChuLm5vcm1hbCkodGhpcy5fbm9ybWFsLGYpLGw/TyhNLHksdGhpcy5fbm9ybWFsLGMpOk8oTSxTLHRoaXMuX25vcm1hbCxjKTtlbHNle09iamVjdChuLmRpcmVjdGlvbikoaCxzLFMpO2xldCBSPU9iamVjdChuLmNvbXB1dGVNaXRlcikodSxhLGYsaCxjKTtSPU1hdGgubWluKFIsZCk7Y29uc3QgTD1PYmplY3Qobi5kb3QpKHUsdGhpcy5fbm9ybWFsKTwwPy0xOjE7bGV0IE49dnx8VDtpZighTiYmdGhpcy5saW5lSm9pbj09PSJtaXRlciImJlIvYz50aGlzLm1pdGVyTGltaXQmJihOPSEwKSxOKXtPYmplY3Qobi5zY2FsZUFuZEFkZCkoaSxTLHRoaXMuX25vcm1hbCwtYypMKSxwKE0saSxMKTtsZXQgQT0xLzA7eSYmKEE9TWF0aC5taW4oQSxNYXRoLmh5cG90KFNbMF0teVswXSxTWzFdLXlbMV0pKSkscyYmKEE9TWF0aC5taW4oQSxNYXRoLmh5cG90KHNbMF0tU1swXSxzWzFdLVNbMV0pKSk7Y29uc3Qgdz1NYXRoLm1heChjLE1hdGgubWluKFIsQSkpO2lmKE9iamVjdChuLnNjYWxlQW5kQWRkKShpLFMsYSx3KkwpLHAoTSxpLC1MKSxzKWlmKE9iamVjdChuLm5vcm1hbCkoaSxoKSxPYmplY3Qobi5jb3B5KSh0aGlzLl9ub3JtYWwsaSksT2JqZWN0KG4uc2NhbGVBbmRBZGQpKGksUyxpLC1jKkwpLFQpe2NvbnN0IEI9T2JqZWN0KG4uY2xvbmUpKGkpLEQ9TD4wP00ubGVmdFtNLmxlZnQubGVuZ3RoLTFdOk0ucmlnaHRbTS5yaWdodC5sZW5ndGgtMV0sST1PYmplY3Qobi5jbG9uZSkoUyksaj1PYmplY3Qobi5zdWIpKE9iamVjdChuLmNyZWF0ZSkoKSxELEkpLFY9T2JqZWN0KG4uc3ViKShPYmplY3Qobi5jcmVhdGUpKCksQixJKSxKPU1hdGguUEkvdGhpcy5yb3VuZFNlZ21lbnRzO2ZvcihsZXQgXz0wO188dGhpcy5yb3VuZFNlZ21lbnRzJiYoT2JqZWN0KG4ucm90YXRlKShqLGosWzAsMF0sTCpKKSxNYXRoLnNpZ24oT2JqZWN0KG4uY3Jvc3MpKGksaixWKVsyXSk9PT1MKTtfKyspT2JqZWN0KG4uYWRkKShpLGosSSkscChNLGksTCk7cChNLEIsTCl9ZWxzZSBwKE0saSxMKX1lbHNlIE8oTSxTLGEsUiksT2JqZWN0KG4uY29weSkodGhpcy5fbm9ybWFsLGEpfX19ZnVuY3Rpb24gcChiLE0seSl7eT4wP2IubGVmdC5wdXNoKE9iamVjdChuLmNsb25lKShNKSk6Yi5yaWdodC5wdXNoKE9iamVjdChuLmNsb25lKShNKSl9ZnVuY3Rpb24gTyhiLE0seSxTLHM9LTEpe09iamVjdChuLnNjYWxlQW5kQWRkKShpLE0seSwtUykscChiLGksLXMpLE9iamVjdChuLnNjYWxlQW5kQWRkKShpLE0seSxTKSxwKGIsaSxzKX1mdW5jdGlvbiBtKHtsZWZ0OmIscmlnaHQ6TX0seSl7Y29uc3QgUz1PYmplY3Qobi5jcmVhdGUpKCkscz1PYmplY3Qobi5jcmVhdGUpKCk7bGV0IGM9YlswXSxsPU1bMF0sdj1bLjUqKGNbMF0rbFswXSksLjUqKGNbMV0rbFsxXSldO09iamVjdChuLnN1YikocyxjLHYpO2ZvcihsZXQgVD0xO1Q8PXk7VCsrKXtjb25zdCBSPS0xKk1hdGguUEkqVC95O09iamVjdChuLnJvdGF0ZSkoUyxzLFswLDBdLFIpLE9iamVjdChuLmFkZCkoaSx2LFMpLGIudW5zaGlmdChPYmplY3Qobi5jbG9uZSkoaSkpfWM9TVtNLmxlbmd0aC0xXSxsPWJbYi5sZW5ndGgtMV0sdj1bLjUqKGNbMF0rbFswXSksLjUqKGNbMV0rbFsxXSldLE9iamVjdChuLnN1YikocyxjLHYpO2ZvcihsZXQgVD0xO1Q8PXk7VCsrKXtjb25zdCBSPS0xKk1hdGguUEkqVC95O09iamVjdChuLnJvdGF0ZSkoUyxzLFswLDBdLFIpLE9iamVjdChuLmFkZCkoaSx2LFMpLE0ucHVzaChPYmplY3Qobi5jbG9uZSkoaSkpfX19LGZ1bmN0aW9uKGcsZSx0KXt0LnIoZSksdC5kKGUsImlzVW5pdFRyYW5zZm9ybSIsZnVuY3Rpb24oKXtyZXR1cm4gbn0pLHQoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBuKGkpe3JldHVybiBpWzBdPT09MSYmaVsxXT09PTAmJmlbMl09PT0wJiZpWzNdPT09MSYmaVs0XT09PTAmJmlbNV09PT0wfX0sZnVuY3Rpb24oZyxlLHQpe3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTt2YXIgbj10KDYxKSxpPXQoNjIpO2cuZXhwb3J0cz1mdW5jdGlvbihmLGgpe2lmKGg9aHx8e30sZj1mLmZpbHRlcihmdW5jdGlvbih5KXtyZXR1cm4geS5sZW5ndGg+Mn0pLGYubGVuZ3RoPT09MClyZXR1cm57cG9zaXRpb25zOltdLGNlbGxzOltdfTt0eXBlb2YgaC52ZXJ0ZXhTaXplIT0ibnVtYmVyIiYmKGgudmVydGV4U2l6ZT1mWzBdWzBdLmxlbmd0aCksZj1mLm1hcChmdW5jdGlvbih5KXtyZXR1cm4geS5yZWR1Y2UoZnVuY3Rpb24oUyxzKXtyZXR1cm4gUy5jb25jYXQocyl9KX0pO2NvbnN0IHU9aC5ydWxlPT09ImV2ZW5vZGQiP24uV0lORElOR19PREQ6bi5XSU5ESU5HX05PTlpFUk87Zm9yKHZhciBhPW4udGVzc2VsYXRlKGkoe2NvbnRvdXJzOmYsd2luZGluZ1J1bGU6dSxlbGVtZW50VHlwZTpuLlBPTFlHT05TLHBvbHlTaXplOjMsdmVydGV4U2l6ZToyfSxoKSksZD1bXSxFPTA7RTxhLnZlcnRpY2VzLmxlbmd0aDtFKz1oLnZlcnRleFNpemUpe3ZhciBwPWEudmVydGljZXMuc2xpY2UoRSxFK2gudmVydGV4U2l6ZSk7ZC5wdXNoKHApfXZhciBPPVtdO2ZvcihFPTA7RTxhLmVsZW1lbnRzLmxlbmd0aDtFKz0zKXt2YXIgbT1hLmVsZW1lbnRzW0VdLGI9YS5lbGVtZW50c1tFKzFdLE09YS5lbGVtZW50c1tFKzJdO08ucHVzaChbbSxiLE1dKX1yZXR1cm57cG9zaXRpb25zOmQsY2VsbHM6T319fSxmdW5jdGlvbihnLGUsdCl7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO3ZhciBuPXt9LGk9e307Zy5leHBvcnRzPW4sbi5XSU5ESU5HX09ERD0wLG4uV0lORElOR19OT05aRVJPPTEsbi5XSU5ESU5HX1BPU0lUSVZFPTIsbi5XSU5ESU5HX05FR0FUSVZFPTMsbi5XSU5ESU5HX0FCU19HRVFfVFdPPTQsbi5QT0xZR09OUz0wLG4uQ09OTkVDVEVEX1BPTFlHT05TPTEsbi5CT1VOREFSWV9DT05UT1VSUz0yLG4udGVzc2VsYXRlPWZ1bmN0aW9uKHMpe2Zvcih2YXIgYz1zLmRlYnVnfHwhMSxsPW5ldyBTLHY9MDt2PHMuY29udG91cnMubGVuZ3RoO3YrKylsLmFkZENvbnRvdXIocy52ZXJ0ZXhTaXplfHwyLHMuY29udG91cnNbdl0pO3JldHVybiBsLnRlc3NlbGF0ZShzLndpbmRpbmdSdWxlfHxuLldJTkRJTkdfT0RELHMuZWxlbWVudFR5cGV8fG4uUE9MWUdPTlMscy5wb2x5U2l6ZXx8MyxzLnZlcnRleFNpemV8fDIscy5ub3JtYWx8fFswLDAsMV0pLHt2ZXJ0aWNlczpsLnZlcnRpY2VzLHZlcnRleEluZGljZXM6bC52ZXJ0ZXhJbmRpY2VzLHZlcnRleENvdW50OmwudmVydGV4Q291bnQsZWxlbWVudHM6bC5lbGVtZW50cyxlbGVtZW50Q291bnQ6bC5lbGVtZW50Q291bnQsbWVzaDpjP2wubWVzaDp2b2lkIDB9fTt2YXIgZj1mdW5jdGlvbihzKXtpZighcyl0aHJvdyJBc3NlcnRpb24gRmFpbGVkISJ9O2Z1bmN0aW9uIGgoKXt0aGlzLm5leHQ9bnVsbCx0aGlzLnByZXY9bnVsbCx0aGlzLmFuRWRnZT1udWxsLHRoaXMuY29vcmRzPVswLDAsMF0sdGhpcy5zPTAsdGhpcy50PTAsdGhpcy5wcUhhbmRsZT0wLHRoaXMubj0wLHRoaXMuaWR4PTB9ZnVuY3Rpb24gdSgpe3RoaXMubmV4dD1udWxsLHRoaXMucHJldj1udWxsLHRoaXMuYW5FZGdlPW51bGwsdGhpcy50cmFpbD1udWxsLHRoaXMubj0wLHRoaXMubWFya2VkPSExLHRoaXMuaW5zaWRlPSExfWZ1bmN0aW9uIGEocyl7dGhpcy5uZXh0PW51bGwsdGhpcy5TeW09bnVsbCx0aGlzLk9uZXh0PW51bGwsdGhpcy5MbmV4dD1udWxsLHRoaXMuT3JnPW51bGwsdGhpcy5MZmFjZT1udWxsLHRoaXMuYWN0aXZlUmVnaW9uPW51bGwsdGhpcy53aW5kaW5nPTAsdGhpcy5zaWRlPXN9YS5wcm90b3R5cGU9e2dldCBSZmFjZSgpe3JldHVybiB0aGlzLlN5bS5MZmFjZX0sc2V0IFJmYWNlKHMpe3RoaXMuU3ltLkxmYWNlPXN9LGdldCBEc3QoKXtyZXR1cm4gdGhpcy5TeW0uT3JnfSxzZXQgRHN0KHMpe3RoaXMuU3ltLk9yZz1zfSxnZXQgT3ByZXYoKXtyZXR1cm4gdGhpcy5TeW0uTG5leHR9LHNldCBPcHJldihzKXt0aGlzLlN5bS5MbmV4dD1zfSxnZXQgTHByZXYoKXtyZXR1cm4gdGhpcy5PbmV4dC5TeW19LHNldCBMcHJldihzKXt0aGlzLk9uZXh0LlN5bT1zfSxnZXQgRHByZXYoKXtyZXR1cm4gdGhpcy5MbmV4dC5TeW19LHNldCBEcHJldihzKXt0aGlzLkxuZXh0LlN5bT1zfSxnZXQgUnByZXYoKXtyZXR1cm4gdGhpcy5TeW0uT25leHR9LHNldCBScHJldihzKXt0aGlzLlN5bS5PbmV4dD1zfSxnZXQgRG5leHQoKXtyZXR1cm4gdGhpcy5TeW0uT25leHQuU3ltfSxzZXQgRG5leHQocyl7dGhpcy5TeW0uT25leHQuU3ltPXN9LGdldCBSbmV4dCgpe3JldHVybiB0aGlzLlN5bS5MbmV4dC5TeW19LHNldCBSbmV4dChzKXt0aGlzLlN5bS5MbmV4dC5TeW09c319O2Z1bmN0aW9uIGQoKXt2YXIgcz1uZXcgaCxjPW5ldyB1LGw9bmV3IGEoMCksdj1uZXcgYSgxKTtzLm5leHQ9cy5wcmV2PXMscy5hbkVkZ2U9bnVsbCxjLm5leHQ9Yy5wcmV2PWMsYy5hbkVkZ2U9bnVsbCxjLnRyYWlsPW51bGwsYy5tYXJrZWQ9ITEsYy5pbnNpZGU9ITEsbC5uZXh0PWwsbC5TeW09dixsLk9uZXh0PW51bGwsbC5MbmV4dD1udWxsLGwuT3JnPW51bGwsbC5MZmFjZT1udWxsLGwud2luZGluZz0wLGwuYWN0aXZlUmVnaW9uPW51bGwsdi5uZXh0PXYsdi5TeW09bCx2Lk9uZXh0PW51bGwsdi5MbmV4dD1udWxsLHYuT3JnPW51bGwsdi5MZmFjZT1udWxsLHYud2luZGluZz0wLHYuYWN0aXZlUmVnaW9uPW51bGwsdGhpcy52SGVhZD1zLHRoaXMuZkhlYWQ9Yyx0aGlzLmVIZWFkPWwsdGhpcy5lSGVhZFN5bT12fWQucHJvdG90eXBlPXttYWtlRWRnZV86ZnVuY3Rpb24ocyl7dmFyIGM9bmV3IGEoMCksbD1uZXcgYSgxKTtzLlN5bS5zaWRlPHMuc2lkZSYmKHM9cy5TeW0pO3ZhciB2PXMuU3ltLm5leHQ7cmV0dXJuIGwubmV4dD12LHYuU3ltLm5leHQ9YyxjLm5leHQ9cyxzLlN5bS5uZXh0PWwsYy5TeW09bCxjLk9uZXh0PWMsYy5MbmV4dD1sLGMuT3JnPW51bGwsYy5MZmFjZT1udWxsLGMud2luZGluZz0wLGMuYWN0aXZlUmVnaW9uPW51bGwsbC5TeW09YyxsLk9uZXh0PWwsbC5MbmV4dD1jLGwuT3JnPW51bGwsbC5MZmFjZT1udWxsLGwud2luZGluZz0wLGwuYWN0aXZlUmVnaW9uPW51bGwsY30sc3BsaWNlXzpmdW5jdGlvbihzLGMpe3ZhciBsPXMuT25leHQsdj1jLk9uZXh0O2wuU3ltLkxuZXh0PWMsdi5TeW0uTG5leHQ9cyxzLk9uZXh0PXYsYy5PbmV4dD1sfSxtYWtlVmVydGV4XzpmdW5jdGlvbihzLGMsbCl7dmFyIHY9cztmKHYhPT1udWxsKTt2YXIgVD1sLnByZXY7di5wcmV2PVQsVC5uZXh0PXYsdi5uZXh0PWwsbC5wcmV2PXYsdi5hbkVkZ2U9Yzt2YXIgUj1jO2RvIFIuT3JnPXYsUj1SLk9uZXh0O3doaWxlKFIhPT1jKX0sbWFrZUZhY2VfOmZ1bmN0aW9uKHMsYyxsKXt2YXIgdj1zO2YodiE9PW51bGwpO3ZhciBUPWwucHJldjt2LnByZXY9VCxULm5leHQ9dix2Lm5leHQ9bCxsLnByZXY9dix2LmFuRWRnZT1jLHYudHJhaWw9bnVsbCx2Lm1hcmtlZD0hMSx2Lmluc2lkZT1sLmluc2lkZTt2YXIgUj1jO2RvIFIuTGZhY2U9dixSPVIuTG5leHQ7d2hpbGUoUiE9PWMpfSxraWxsRWRnZV86ZnVuY3Rpb24ocyl7cy5TeW0uc2lkZTxzLnNpZGUmJihzPXMuU3ltKTt2YXIgYz1zLm5leHQsbD1zLlN5bS5uZXh0O2MuU3ltLm5leHQ9bCxsLlN5bS5uZXh0PWN9LGtpbGxWZXJ0ZXhfOmZ1bmN0aW9uKHMsYyl7dmFyIGw9cy5hbkVkZ2Usdj1sO2RvIHYuT3JnPWMsdj12Lk9uZXh0O3doaWxlKHYhPT1sKTt2YXIgVD1zLnByZXYsUj1zLm5leHQ7Ui5wcmV2PVQsVC5uZXh0PVJ9LGtpbGxGYWNlXzpmdW5jdGlvbihzLGMpe3ZhciBsPXMuYW5FZGdlLHY9bDtkbyB2LkxmYWNlPWMsdj12LkxuZXh0O3doaWxlKHYhPT1sKTt2YXIgVD1zLnByZXYsUj1zLm5leHQ7Ui5wcmV2PVQsVC5uZXh0PVJ9LG1ha2VFZGdlOmZ1bmN0aW9uKCl7dmFyIHM9bmV3IGgsYz1uZXcgaCxsPW5ldyB1LHY9dGhpcy5tYWtlRWRnZV8odGhpcy5lSGVhZCk7cmV0dXJuIHRoaXMubWFrZVZlcnRleF8ocyx2LHRoaXMudkhlYWQpLHRoaXMubWFrZVZlcnRleF8oYyx2LlN5bSx0aGlzLnZIZWFkKSx0aGlzLm1ha2VGYWNlXyhsLHYsdGhpcy5mSGVhZCksdn0sc3BsaWNlOmZ1bmN0aW9uKHMsYyl7dmFyIGw9ITEsdj0hMTtpZihzIT09Yyl7aWYoYy5PcmchPT1zLk9yZyYmKHY9ITAsdGhpcy5raWxsVmVydGV4XyhjLk9yZyxzLk9yZykpLGMuTGZhY2UhPT1zLkxmYWNlJiYobD0hMCx0aGlzLmtpbGxGYWNlXyhjLkxmYWNlLHMuTGZhY2UpKSx0aGlzLnNwbGljZV8oYyxzKSwhdil7dmFyIFQ9bmV3IGg7dGhpcy5tYWtlVmVydGV4XyhULGMscy5PcmcpLHMuT3JnLmFuRWRnZT1zfWlmKCFsKXt2YXIgUj1uZXcgdTt0aGlzLm1ha2VGYWNlXyhSLGMscy5MZmFjZSkscy5MZmFjZS5hbkVkZ2U9c319fSxkZWxldGU6ZnVuY3Rpb24ocyl7dmFyIGM9cy5TeW0sbD0hMTtpZihzLkxmYWNlIT09cy5SZmFjZSYmKGw9ITAsdGhpcy5raWxsRmFjZV8ocy5MZmFjZSxzLlJmYWNlKSkscy5PbmV4dD09PXMpdGhpcy5raWxsVmVydGV4XyhzLk9yZyxudWxsKTtlbHNlIGlmKHMuUmZhY2UuYW5FZGdlPXMuT3ByZXYscy5PcmcuYW5FZGdlPXMuT25leHQsdGhpcy5zcGxpY2VfKHMscy5PcHJldiksIWwpe3ZhciB2PW5ldyB1O3RoaXMubWFrZUZhY2VfKHYscyxzLkxmYWNlKX1jLk9uZXh0PT09Yz8odGhpcy5raWxsVmVydGV4XyhjLk9yZyxudWxsKSx0aGlzLmtpbGxGYWNlXyhjLkxmYWNlLG51bGwpKToocy5MZmFjZS5hbkVkZ2U9Yy5PcHJldixjLk9yZy5hbkVkZ2U9Yy5PbmV4dCx0aGlzLnNwbGljZV8oYyxjLk9wcmV2KSksdGhpcy5raWxsRWRnZV8ocyl9LGFkZEVkZ2VWZXJ0ZXg6ZnVuY3Rpb24ocyl7dmFyIGM9dGhpcy5tYWtlRWRnZV8ocyksbD1jLlN5bTt0aGlzLnNwbGljZV8oYyxzLkxuZXh0KSxjLk9yZz1zLkRzdDt2YXIgdj1uZXcgaDtyZXR1cm4gdGhpcy5tYWtlVmVydGV4Xyh2LGwsYy5PcmcpLGMuTGZhY2U9bC5MZmFjZT1zLkxmYWNlLGN9LHNwbGl0RWRnZTpmdW5jdGlvbihzLGMpe3ZhciBsPXRoaXMuYWRkRWRnZVZlcnRleChzKSx2PWwuU3ltO3JldHVybiB0aGlzLnNwbGljZV8ocy5TeW0scy5TeW0uT3ByZXYpLHRoaXMuc3BsaWNlXyhzLlN5bSx2KSxzLkRzdD12Lk9yZyx2LkRzdC5hbkVkZ2U9di5TeW0sdi5SZmFjZT1zLlJmYWNlLHYud2luZGluZz1zLndpbmRpbmcsdi5TeW0ud2luZGluZz1zLlN5bS53aW5kaW5nLHZ9LGNvbm5lY3Q6ZnVuY3Rpb24ocyxjKXt2YXIgbD0hMSx2PXRoaXMubWFrZUVkZ2VfKHMpLFQ9di5TeW07aWYoYy5MZmFjZSE9PXMuTGZhY2UmJihsPSEwLHRoaXMua2lsbEZhY2VfKGMuTGZhY2Uscy5MZmFjZSkpLHRoaXMuc3BsaWNlXyh2LHMuTG5leHQpLHRoaXMuc3BsaWNlXyhULGMpLHYuT3JnPXMuRHN0LFQuT3JnPWMuT3JnLHYuTGZhY2U9VC5MZmFjZT1zLkxmYWNlLHMuTGZhY2UuYW5FZGdlPVQsIWwpe3ZhciBSPW5ldyB1O3RoaXMubWFrZUZhY2VfKFIsdixzLkxmYWNlKX1yZXR1cm4gdn0semFwRmFjZTpmdW5jdGlvbihzKXt2YXIgYz1zLmFuRWRnZSxsLHYsVCxSLEw7dj1jLkxuZXh0O2RvIGw9dix2PWwuTG5leHQsbC5MZmFjZT1udWxsLGwuUmZhY2U9PT1udWxsJiYobC5PbmV4dD09PWw/dGhpcy5raWxsVmVydGV4XyhsLk9yZyxudWxsKToobC5PcmcuYW5FZGdlPWwuT25leHQsdGhpcy5zcGxpY2VfKGwsbC5PcHJldikpLFQ9bC5TeW0sVC5PbmV4dD09PVQ/dGhpcy5raWxsVmVydGV4XyhULk9yZyxudWxsKTooVC5PcmcuYW5FZGdlPVQuT25leHQsdGhpcy5zcGxpY2VfKFQsVC5PcHJldikpLHRoaXMua2lsbEVkZ2VfKGwpKTt3aGlsZShsIT1jKTtSPXMucHJldixMPXMubmV4dCxMLnByZXY9UixSLm5leHQ9TH0sY291bnRGYWNlVmVydHNfOmZ1bmN0aW9uKHMpe3ZhciBjPXMuYW5FZGdlLGw9MDtkbyBsKyssYz1jLkxuZXh0O3doaWxlKGMhPT1zLmFuRWRnZSk7cmV0dXJuIGx9LG1lcmdlQ29udmV4RmFjZXM6ZnVuY3Rpb24ocyl7dmFyIGMsbCx2LFQsUixMLE47Zm9yKGM9dGhpcy5mSGVhZC5uZXh0O2MhPT10aGlzLmZIZWFkO2M9Yy5uZXh0KWlmKGMuaW5zaWRlKWZvcihsPWMuYW5FZGdlLFI9bC5Pcmc7dj1sLkxuZXh0LFQ9bC5TeW0sVCYmVC5MZmFjZSYmVC5MZmFjZS5pbnNpZGUmJihMPXRoaXMuY291bnRGYWNlVmVydHNfKGMpLE49dGhpcy5jb3VudEZhY2VWZXJ0c18oVC5MZmFjZSksTCtOLTI8PXMmJmkudmVydENDVyhsLkxwcmV2Lk9yZyxsLk9yZyxULkxuZXh0LkxuZXh0Lk9yZykmJmkudmVydENDVyhULkxwcmV2Lk9yZyxULk9yZyxsLkxuZXh0LkxuZXh0Lk9yZykmJih2PVQuTG5leHQsdGhpcy5kZWxldGUoVCksbD1udWxsLFQ9bnVsbCkpLCEobCYmbC5MbmV4dC5Pcmc9PT1SKTspbD12O3JldHVybiEwfSxjaGVjazpmdW5jdGlvbigpe3ZhciBzPXRoaXMuZkhlYWQsYz10aGlzLnZIZWFkLGw9dGhpcy5lSGVhZCx2LFQsUixMLE4sQTtmb3IoVD1zLFQ9czsodj1ULm5leHQpIT09cztUPXYpe2Yodi5wcmV2PT09VCksTj12LmFuRWRnZTtkbyBmKE4uU3ltIT09TiksZihOLlN5bS5TeW09PT1OKSxmKE4uTG5leHQuT25leHQuU3ltPT09TiksZihOLk9uZXh0LlN5bS5MbmV4dD09PU4pLGYoTi5MZmFjZT09PXYpLE49Ti5MbmV4dDt3aGlsZShOIT09di5hbkVkZ2UpfWZvcihmKHYucHJldj09PVQmJnYuYW5FZGdlPT09bnVsbCksTD1jLEw9YzsoUj1MLm5leHQpIT09YztMPVIpe2YoUi5wcmV2PT09TCksTj1SLmFuRWRnZTtkbyBmKE4uU3ltIT09TiksZihOLlN5bS5TeW09PT1OKSxmKE4uTG5leHQuT25leHQuU3ltPT09TiksZihOLk9uZXh0LlN5bS5MbmV4dD09PU4pLGYoTi5Pcmc9PT1SKSxOPU4uT25leHQ7d2hpbGUoTiE9PVIuYW5FZGdlKX1mb3IoZihSLnByZXY9PT1MJiZSLmFuRWRnZT09PW51bGwpLEE9bCxBPWw7KE49QS5uZXh0KSE9PWw7QT1OKWYoTi5TeW0ubmV4dD09PUEuU3ltKSxmKE4uU3ltIT09TiksZihOLlN5bS5TeW09PT1OKSxmKE4uT3JnIT09bnVsbCksZihOLkRzdCE9PW51bGwpLGYoTi5MbmV4dC5PbmV4dC5TeW09PT1OKSxmKE4uT25leHQuU3ltLkxuZXh0PT09Tik7ZihOLlN5bS5uZXh0PT09QS5TeW0mJk4uU3ltPT09dGhpcy5lSGVhZFN5bSYmTi5TeW0uU3ltPT09TiYmTi5Pcmc9PT1udWxsJiZOLkRzdD09PW51bGwmJk4uTGZhY2U9PT1udWxsJiZOLlJmYWNlPT09bnVsbCl9fSxpLnZlcnRFcT1mdW5jdGlvbihzLGMpe3JldHVybiBzLnM9PT1jLnMmJnMudD09PWMudH0saS52ZXJ0TGVxPWZ1bmN0aW9uKHMsYyl7cmV0dXJuIHMuczxjLnN8fHMucz09PWMucyYmcy50PD1jLnR9LGkudHJhbnNMZXE9ZnVuY3Rpb24ocyxjKXtyZXR1cm4gcy50PGMudHx8cy50PT09Yy50JiZzLnM8PWMuc30saS5lZGdlR29lc0xlZnQ9ZnVuY3Rpb24ocyl7cmV0dXJuIGkudmVydExlcShzLkRzdCxzLk9yZyl9LGkuZWRnZUdvZXNSaWdodD1mdW5jdGlvbihzKXtyZXR1cm4gaS52ZXJ0TGVxKHMuT3JnLHMuRHN0KX0saS52ZXJ0TDFkaXN0PWZ1bmN0aW9uKHMsYyl7cmV0dXJuIE1hdGguYWJzKHMucy1jLnMpK01hdGguYWJzKHMudC1jLnQpfSxpLmVkZ2VFdmFsPWZ1bmN0aW9uKHMsYyxsKXtmKGkudmVydExlcShzLGMpJiZpLnZlcnRMZXEoYyxsKSk7dmFyIHY9Yy5zLXMucyxUPWwucy1jLnM7cmV0dXJuIHYrVD4wP3Y8VD9jLnQtcy50KyhzLnQtbC50KSoodi8oditUKSk6Yy50LWwudCsobC50LXMudCkqKFQvKHYrVCkpOjB9LGkuZWRnZVNpZ249ZnVuY3Rpb24ocyxjLGwpe2YoaS52ZXJ0TGVxKHMsYykmJmkudmVydExlcShjLGwpKTt2YXIgdj1jLnMtcy5zLFQ9bC5zLWMucztyZXR1cm4gditUPjA/KGMudC1sLnQpKnYrKGMudC1zLnQpKlQ6MH0saS50cmFuc0V2YWw9ZnVuY3Rpb24ocyxjLGwpe2YoaS50cmFuc0xlcShzLGMpJiZpLnRyYW5zTGVxKGMsbCkpO3ZhciB2PWMudC1zLnQsVD1sLnQtYy50O3JldHVybiB2K1Q+MD92PFQ/Yy5zLXMucysocy5zLWwucykqKHYvKHYrVCkpOmMucy1sLnMrKGwucy1zLnMpKihULyh2K1QpKTowfSxpLnRyYW5zU2lnbj1mdW5jdGlvbihzLGMsbCl7ZihpLnRyYW5zTGVxKHMsYykmJmkudHJhbnNMZXEoYyxsKSk7dmFyIHY9Yy50LXMudCxUPWwudC1jLnQ7cmV0dXJuIHYrVD4wPyhjLnMtbC5zKSp2KyhjLnMtcy5zKSpUOjB9LGkudmVydENDVz1mdW5jdGlvbihzLGMsbCl7cmV0dXJuIHMucyooYy50LWwudCkrYy5zKihsLnQtcy50KStsLnMqKHMudC1jLnQpPj0wfSxpLmludGVycG9sYXRlPWZ1bmN0aW9uKHMsYyxsLHYpe3JldHVybiBzPXM8MD8wOnMsbD1sPDA/MDpsLHM8PWw/bD09PTA/KGMrdikvMjpjKyh2LWMpKihzLyhzK2wpKTp2KyhjLXYpKihsLyhzK2wpKX0saS5pbnRlcnNlY3Q9ZnVuY3Rpb24ocyxjLGwsdixUKXt2YXIgUixMLE47aS52ZXJ0TGVxKHMsYyl8fChOPXMscz1jLGM9TiksaS52ZXJ0TGVxKGwsdil8fChOPWwsbD12LHY9TiksaS52ZXJ0TGVxKHMsbCl8fChOPXMscz1sLGw9TixOPWMsYz12LHY9TiksaS52ZXJ0TGVxKGwsYyk/aS52ZXJ0TGVxKGMsdik/KFI9aS5lZGdlRXZhbChzLGwsYyksTD1pLmVkZ2VFdmFsKGwsYyx2KSxSK0w8MCYmKFI9LVIsTD0tTCksVC5zPWkuaW50ZXJwb2xhdGUoUixsLnMsTCxjLnMpKTooUj1pLmVkZ2VTaWduKHMsbCxjKSxMPS1pLmVkZ2VTaWduKHMsdixjKSxSK0w8MCYmKFI9LVIsTD0tTCksVC5zPWkuaW50ZXJwb2xhdGUoUixsLnMsTCx2LnMpKTpULnM9KGwucytjLnMpLzIsaS50cmFuc0xlcShzLGMpfHwoTj1zLHM9YyxjPU4pLGkudHJhbnNMZXEobCx2KXx8KE49bCxsPXYsdj1OKSxpLnRyYW5zTGVxKHMsbCl8fChOPXMscz1sLGw9TixOPWMsYz12LHY9TiksaS50cmFuc0xlcShsLGMpP2kudHJhbnNMZXEoYyx2KT8oUj1pLnRyYW5zRXZhbChzLGwsYyksTD1pLnRyYW5zRXZhbChsLGMsdiksUitMPDAmJihSPS1SLEw9LUwpLFQudD1pLmludGVycG9sYXRlKFIsbC50LEwsYy50KSk6KFI9aS50cmFuc1NpZ24ocyxsLGMpLEw9LWkudHJhbnNTaWduKHMsdixjKSxSK0w8MCYmKFI9LVIsTD0tTCksVC50PWkuaW50ZXJwb2xhdGUoUixsLnQsTCx2LnQpKTpULnQ9KGwudCtjLnQpLzJ9O2Z1bmN0aW9uIEUoKXt0aGlzLmtleT1udWxsLHRoaXMubmV4dD1udWxsLHRoaXMucHJldj1udWxsfWZ1bmN0aW9uIHAocyxjKXt0aGlzLmhlYWQ9bmV3IEUsdGhpcy5oZWFkLm5leHQ9dGhpcy5oZWFkLHRoaXMuaGVhZC5wcmV2PXRoaXMuaGVhZCx0aGlzLmZyYW1lPXMsdGhpcy5sZXE9Y31wLnByb3RvdHlwZT17bWluOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaGVhZC5uZXh0fSxtYXg6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5oZWFkLnByZXZ9LGluc2VydDpmdW5jdGlvbihzKXtyZXR1cm4gdGhpcy5pbnNlcnRCZWZvcmUodGhpcy5oZWFkLHMpfSxzZWFyY2g6ZnVuY3Rpb24ocyl7dmFyIGM9dGhpcy5oZWFkO2RvIGM9Yy5uZXh0O3doaWxlKGMua2V5IT09bnVsbCYmIXRoaXMubGVxKHRoaXMuZnJhbWUscyxjLmtleSkpO3JldHVybiBjfSxpbnNlcnRCZWZvcmU6ZnVuY3Rpb24ocyxjKXtkbyBzPXMucHJldjt3aGlsZShzLmtleSE9PW51bGwmJiF0aGlzLmxlcSh0aGlzLmZyYW1lLHMua2V5LGMpKTt2YXIgbD1uZXcgRTtyZXR1cm4gbC5rZXk9YyxsLm5leHQ9cy5uZXh0LHMubmV4dC5wcmV2PWwsbC5wcmV2PXMscy5uZXh0PWwsbH0sZGVsZXRlOmZ1bmN0aW9uKHMpe3MubmV4dC5wcmV2PXMucHJldixzLnByZXYubmV4dD1zLm5leHR9fTtmdW5jdGlvbiBPKCl7dGhpcy5oYW5kbGU9bnVsbH1mdW5jdGlvbiBtKCl7dGhpcy5rZXk9bnVsbCx0aGlzLm5vZGU9bnVsbH1mdW5jdGlvbiBiKHMsYyl7dGhpcy5zaXplPTAsdGhpcy5tYXg9cyx0aGlzLm5vZGVzPVtdLHRoaXMubm9kZXMubGVuZ3RoPXMrMTt2YXIgbDtmb3IobD0wO2w8dGhpcy5ub2Rlcy5sZW5ndGg7bCsrKXRoaXMubm9kZXNbbF09bmV3IE87Zm9yKHRoaXMuaGFuZGxlcz1bXSx0aGlzLmhhbmRsZXMubGVuZ3RoPXMrMSxsPTA7bDx0aGlzLmhhbmRsZXMubGVuZ3RoO2wrKyl0aGlzLmhhbmRsZXNbbF09bmV3IG07dGhpcy5pbml0aWFsaXplZD0hMSx0aGlzLmZyZWVMaXN0PTAsdGhpcy5sZXE9Yyx0aGlzLm5vZGVzWzFdLmhhbmRsZT0xLHRoaXMuaGFuZGxlc1sxXS5rZXk9bnVsbH1iLnByb3RvdHlwZT17ZmxvYXREb3duXzpmdW5jdGlvbihzKXt2YXIgYz10aGlzLm5vZGVzLGw9dGhpcy5oYW5kbGVzLHYsVCxSO2Zvcih2PWNbc10uaGFuZGxlOzspe2lmKFI9czw8MSxSPHRoaXMuc2l6ZSYmdGhpcy5sZXEobFtjW1IrMV0uaGFuZGxlXS5rZXksbFtjW1JdLmhhbmRsZV0ua2V5KSYmKytSLGYoUjw9dGhpcy5tYXgpLFQ9Y1tSXS5oYW5kbGUsUj50aGlzLnNpemV8fHRoaXMubGVxKGxbdl0ua2V5LGxbVF0ua2V5KSl7Y1tzXS5oYW5kbGU9dixsW3ZdLm5vZGU9czticmVha31jW3NdLmhhbmRsZT1ULGxbVF0ubm9kZT1zLHM9Un19LGZsb2F0VXBfOmZ1bmN0aW9uKHMpe3ZhciBjPXRoaXMubm9kZXMsbD10aGlzLmhhbmRsZXMsdixULFI7Zm9yKHY9Y1tzXS5oYW5kbGU7Oyl7aWYoUj1zPj4xLFQ9Y1tSXS5oYW5kbGUsUj09PTB8fHRoaXMubGVxKGxbVF0ua2V5LGxbdl0ua2V5KSl7Y1tzXS5oYW5kbGU9dixsW3ZdLm5vZGU9czticmVha31jW3NdLmhhbmRsZT1ULGxbVF0ubm9kZT1zLHM9Un19LGluaXQ6ZnVuY3Rpb24oKXtmb3IodmFyIHM9dGhpcy5zaXplO3M+PTE7LS1zKXRoaXMuZmxvYXREb3duXyhzKTt0aGlzLmluaXRpYWxpemVkPSEwfSxtaW46ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5oYW5kbGVzW3RoaXMubm9kZXNbMV0uaGFuZGxlXS5rZXl9LGluc2VydDpmdW5jdGlvbihzKXt2YXIgYyxsO2lmKGM9Kyt0aGlzLnNpemUsYyoyPnRoaXMubWF4KXt0aGlzLm1heCo9Mjt2YXIgdixUO2ZvcihUPXRoaXMubm9kZXMubGVuZ3RoLHRoaXMubm9kZXMubGVuZ3RoPXRoaXMubWF4KzEsdj1UO3Y8dGhpcy5ub2Rlcy5sZW5ndGg7disrKXRoaXMubm9kZXNbdl09bmV3IE87Zm9yKFQ9dGhpcy5oYW5kbGVzLmxlbmd0aCx0aGlzLmhhbmRsZXMubGVuZ3RoPXRoaXMubWF4KzEsdj1UO3Y8dGhpcy5oYW5kbGVzLmxlbmd0aDt2KyspdGhpcy5oYW5kbGVzW3ZdPW5ldyBtfXJldHVybiB0aGlzLmZyZWVMaXN0PT09MD9sPWM6KGw9dGhpcy5mcmVlTGlzdCx0aGlzLmZyZWVMaXN0PXRoaXMuaGFuZGxlc1tsXS5ub2RlKSx0aGlzLm5vZGVzW2NdLmhhbmRsZT1sLHRoaXMuaGFuZGxlc1tsXS5ub2RlPWMsdGhpcy5oYW5kbGVzW2xdLmtleT1zLHRoaXMuaW5pdGlhbGl6ZWQmJnRoaXMuZmxvYXRVcF8oYyksbH0sZXh0cmFjdE1pbjpmdW5jdGlvbigpe3ZhciBzPXRoaXMubm9kZXMsYz10aGlzLmhhbmRsZXMsbD1zWzFdLmhhbmRsZSx2PWNbbF0ua2V5O3JldHVybiB0aGlzLnNpemU+MCYmKHNbMV0uaGFuZGxlPXNbdGhpcy5zaXplXS5oYW5kbGUsY1tzWzFdLmhhbmRsZV0ubm9kZT0xLGNbbF0ua2V5PW51bGwsY1tsXS5ub2RlPXRoaXMuZnJlZUxpc3QsdGhpcy5mcmVlTGlzdD1sLC0tdGhpcy5zaXplLHRoaXMuc2l6ZT4wJiZ0aGlzLmZsb2F0RG93bl8oMSkpLHZ9LGRlbGV0ZTpmdW5jdGlvbihzKXt2YXIgYz10aGlzLm5vZGVzLGw9dGhpcy5oYW5kbGVzLHY7ZihzPj0xJiZzPD10aGlzLm1heCYmbFtzXS5rZXkhPT1udWxsKSx2PWxbc10ubm9kZSxjW3ZdLmhhbmRsZT1jW3RoaXMuc2l6ZV0uaGFuZGxlLGxbY1t2XS5oYW5kbGVdLm5vZGU9diwtLXRoaXMuc2l6ZSx2PD10aGlzLnNpemUmJih2PD0xfHx0aGlzLmxlcShsW2Nbdj4+MV0uaGFuZGxlXS5rZXksbFtjW3ZdLmhhbmRsZV0ua2V5KT90aGlzLmZsb2F0RG93bl8odik6dGhpcy5mbG9hdFVwXyh2KSksbFtzXS5rZXk9bnVsbCxsW3NdLm5vZGU9dGhpcy5mcmVlTGlzdCx0aGlzLmZyZWVMaXN0PXN9fTtmdW5jdGlvbiBNKCl7dGhpcy5lVXA9bnVsbCx0aGlzLm5vZGVVcD1udWxsLHRoaXMud2luZGluZ051bWJlcj0wLHRoaXMuaW5zaWRlPSExLHRoaXMuc2VudGluZWw9ITEsdGhpcy5kaXJ0eT0hMSx0aGlzLmZpeFVwcGVyRWRnZT0hMX12YXIgeT17fTt5LnJlZ2lvbkJlbG93PWZ1bmN0aW9uKHMpe3JldHVybiBzLm5vZGVVcC5wcmV2LmtleX0seS5yZWdpb25BYm92ZT1mdW5jdGlvbihzKXtyZXR1cm4gcy5ub2RlVXAubmV4dC5rZXl9LHkuZGVidWdFdmVudD1mdW5jdGlvbihzKXt9LHkuYWRkV2luZGluZz1mdW5jdGlvbihzLGMpe3Mud2luZGluZys9Yy53aW5kaW5nLHMuU3ltLndpbmRpbmcrPWMuU3ltLndpbmRpbmd9LHkuZWRnZUxlcT1mdW5jdGlvbihzLGMsbCl7dmFyIHY9cy5ldmVudCxMLE4sVD1jLmVVcCxSPWwuZVVwO2lmKFQuRHN0PT09dilyZXR1cm4gUi5Ec3Q9PT12P2kudmVydExlcShULk9yZyxSLk9yZyk/aS5lZGdlU2lnbihSLkRzdCxULk9yZyxSLk9yZyk8PTA6aS5lZGdlU2lnbihULkRzdCxSLk9yZyxULk9yZyk+PTA6aS5lZGdlU2lnbihSLkRzdCx2LFIuT3JnKTw9MDtpZihSLkRzdD09PXYpcmV0dXJuIGkuZWRnZVNpZ24oVC5Ec3QsdixULk9yZyk+PTA7dmFyIEw9aS5lZGdlRXZhbChULkRzdCx2LFQuT3JnKSxOPWkuZWRnZUV2YWwoUi5Ec3QsdixSLk9yZyk7cmV0dXJuIEw+PU59LHkuZGVsZXRlUmVnaW9uPWZ1bmN0aW9uKHMsYyl7Yy5maXhVcHBlckVkZ2UmJmYoYy5lVXAud2luZGluZz09PTApLGMuZVVwLmFjdGl2ZVJlZ2lvbj1udWxsLHMuZGljdC5kZWxldGUoYy5ub2RlVXApfSx5LmZpeFVwcGVyRWRnZT1mdW5jdGlvbihzLGMsbCl7ZihjLmZpeFVwcGVyRWRnZSkscy5tZXNoLmRlbGV0ZShjLmVVcCksYy5maXhVcHBlckVkZ2U9ITEsYy5lVXA9bCxsLmFjdGl2ZVJlZ2lvbj1jfSx5LnRvcExlZnRSZWdpb249ZnVuY3Rpb24ocyxjKXt2YXIgbD1jLmVVcC5PcmcsdjtkbyBjPXkucmVnaW9uQWJvdmUoYyk7d2hpbGUoYy5lVXAuT3JnPT09bCk7aWYoYy5maXhVcHBlckVkZ2Upe2lmKHY9cy5tZXNoLmNvbm5lY3QoeS5yZWdpb25CZWxvdyhjKS5lVXAuU3ltLGMuZVVwLkxuZXh0KSx2PT09bnVsbClyZXR1cm4gbnVsbDt5LmZpeFVwcGVyRWRnZShzLGMsdiksYz15LnJlZ2lvbkFib3ZlKGMpfXJldHVybiBjfSx5LnRvcFJpZ2h0UmVnaW9uPWZ1bmN0aW9uKHMpe3ZhciBjPXMuZVVwLkRzdDtkbyBzPXkucmVnaW9uQWJvdmUocyk7d2hpbGUocy5lVXAuRHN0PT09Yyk7cmV0dXJuIHN9LHkuYWRkUmVnaW9uQmVsb3c9ZnVuY3Rpb24ocyxjLGwpe3ZhciB2PW5ldyBNO3JldHVybiB2LmVVcD1sLHYubm9kZVVwPXMuZGljdC5pbnNlcnRCZWZvcmUoYy5ub2RlVXAsdiksdi5maXhVcHBlckVkZ2U9ITEsdi5zZW50aW5lbD0hMSx2LmRpcnR5PSExLGwuYWN0aXZlUmVnaW9uPXYsdn0seS5pc1dpbmRpbmdJbnNpZGU9ZnVuY3Rpb24ocyxjKXtzd2l0Y2gocy53aW5kaW5nUnVsZSl7Y2FzZSBuLldJTkRJTkdfT0REOnJldHVybihjJjEpIT09MDtjYXNlIG4uV0lORElOR19OT05aRVJPOnJldHVybiBjIT09MDtjYXNlIG4uV0lORElOR19QT1NJVElWRTpyZXR1cm4gYz4wO2Nhc2Ugbi5XSU5ESU5HX05FR0FUSVZFOnJldHVybiBjPDA7Y2FzZSBuLldJTkRJTkdfQUJTX0dFUV9UV086cmV0dXJuIGM+PTJ8fGM8PS0yfXJldHVybiBmKCExKSwhMX0seS5jb21wdXRlV2luZGluZz1mdW5jdGlvbihzLGMpe2Mud2luZGluZ051bWJlcj15LnJlZ2lvbkFib3ZlKGMpLndpbmRpbmdOdW1iZXIrYy5lVXAud2luZGluZyxjLmluc2lkZT15LmlzV2luZGluZ0luc2lkZShzLGMud2luZGluZ051bWJlcil9LHkuZmluaXNoUmVnaW9uPWZ1bmN0aW9uKHMsYyl7dmFyIGw9Yy5lVXAsdj1sLkxmYWNlO3YuaW5zaWRlPWMuaW5zaWRlLHYuYW5FZGdlPWwseS5kZWxldGVSZWdpb24ocyxjKX0seS5maW5pc2hMZWZ0UmVnaW9ucz1mdW5jdGlvbihzLGMsbCl7Zm9yKHZhciB2LEwsVD1udWxsLFI9YyxMPWMuZVVwO1IhPT1sOyl7aWYoUi5maXhVcHBlckVkZ2U9ITEsVD15LnJlZ2lvbkJlbG93KFIpLHY9VC5lVXAsdi5PcmchPUwuT3JnKXtpZighVC5maXhVcHBlckVkZ2Upe3kuZmluaXNoUmVnaW9uKHMsUik7YnJlYWt9dj1zLm1lc2guY29ubmVjdChMLkxwcmV2LHYuU3ltKSx5LmZpeFVwcGVyRWRnZShzLFQsdil9TC5PbmV4dCE9PXYmJihzLm1lc2guc3BsaWNlKHYuT3ByZXYsdikscy5tZXNoLnNwbGljZShMLHYpKSx5LmZpbmlzaFJlZ2lvbihzLFIpLEw9VC5lVXAsUj1UfXJldHVybiBMfSx5LmFkZFJpZ2h0RWRnZXM9ZnVuY3Rpb24ocyxjLGwsdixULFIpe3ZhciBMLE4sQSx3LEI9ITA7QT1sO2RvIGYoaS52ZXJ0TGVxKEEuT3JnLEEuRHN0KSkseS5hZGRSZWdpb25CZWxvdyhzLGMsQS5TeW0pLEE9QS5PbmV4dDt3aGlsZShBIT09dik7Zm9yKFQ9PT1udWxsJiYoVD15LnJlZ2lvbkJlbG93KGMpLmVVcC5ScHJldiksTj1jLHc9VDtMPXkucmVnaW9uQmVsb3coTiksQT1MLmVVcC5TeW0sQS5Pcmc9PT13Lk9yZzspQS5PbmV4dCE9PXcmJihzLm1lc2guc3BsaWNlKEEuT3ByZXYsQSkscy5tZXNoLnNwbGljZSh3Lk9wcmV2LEEpKSxMLndpbmRpbmdOdW1iZXI9Ti53aW5kaW5nTnVtYmVyLUEud2luZGluZyxMLmluc2lkZT15LmlzV2luZGluZ0luc2lkZShzLEwud2luZGluZ051bWJlciksTi5kaXJ0eT0hMCwhQiYmeS5jaGVja0ZvclJpZ2h0U3BsaWNlKHMsTikmJih5LmFkZFdpbmRpbmcoQSx3KSx5LmRlbGV0ZVJlZ2lvbihzLE4pLHMubWVzaC5kZWxldGUodykpLEI9ITEsTj1MLHc9QTtOLmRpcnR5PSEwLGYoTi53aW5kaW5nTnVtYmVyLUEud2luZGluZz09PUwud2luZGluZ051bWJlciksUiYmeS53YWxrRGlydHlSZWdpb25zKHMsTil9LHkuc3BsaWNlTWVyZ2VWZXJ0aWNlcz1mdW5jdGlvbihzLGMsbCl7cy5tZXNoLnNwbGljZShjLGwpfSx5LnZlcnRleFdlaWdodHM9ZnVuY3Rpb24ocyxjLGwpe3ZhciB2PWkudmVydEwxZGlzdChjLHMpLFQ9aS52ZXJ0TDFkaXN0KGwscyksUj0uNSpULyh2K1QpLEw9LjUqdi8oditUKTtzLmNvb3Jkc1swXSs9UipjLmNvb3Jkc1swXStMKmwuY29vcmRzWzBdLHMuY29vcmRzWzFdKz1SKmMuY29vcmRzWzFdK0wqbC5jb29yZHNbMV0scy5jb29yZHNbMl0rPVIqYy5jb29yZHNbMl0rTCpsLmNvb3Jkc1syXX0seS5nZXRJbnRlcnNlY3REYXRhPWZ1bmN0aW9uKHMsYyxsLHYsVCxSKXtjLmNvb3Jkc1swXT1jLmNvb3Jkc1sxXT1jLmNvb3Jkc1syXT0wLGMuaWR4PS0xLHkudmVydGV4V2VpZ2h0cyhjLGwsdikseS52ZXJ0ZXhXZWlnaHRzKGMsVCxSKX0seS5jaGVja0ZvclJpZ2h0U3BsaWNlPWZ1bmN0aW9uKHMsYyl7dmFyIGw9eS5yZWdpb25CZWxvdyhjKSx2PWMuZVVwLFQ9bC5lVXA7aWYoaS52ZXJ0TGVxKHYuT3JnLFQuT3JnKSl7aWYoaS5lZGdlU2lnbihULkRzdCx2Lk9yZyxULk9yZyk+MClyZXR1cm4hMTtpLnZlcnRFcSh2Lk9yZyxULk9yZyk/di5PcmchPT1ULk9yZyYmKHMucHEuZGVsZXRlKHYuT3JnLnBxSGFuZGxlKSx5LnNwbGljZU1lcmdlVmVydGljZXMocyxULk9wcmV2LHYpKToocy5tZXNoLnNwbGl0RWRnZShULlN5bSkscy5tZXNoLnNwbGljZSh2LFQuT3ByZXYpLGMuZGlydHk9bC5kaXJ0eT0hMCl9ZWxzZXtpZihpLmVkZ2VTaWduKHYuRHN0LFQuT3JnLHYuT3JnKTwwKXJldHVybiExO3kucmVnaW9uQWJvdmUoYykuZGlydHk9Yy5kaXJ0eT0hMCxzLm1lc2guc3BsaXRFZGdlKHYuU3ltKSxzLm1lc2guc3BsaWNlKFQuT3ByZXYsdil9cmV0dXJuITB9LHkuY2hlY2tGb3JMZWZ0U3BsaWNlPWZ1bmN0aW9uKHMsYyl7dmFyIGw9eS5yZWdpb25CZWxvdyhjKSx2PWMuZVVwLFQ9bC5lVXAsUjtpZihmKCFpLnZlcnRFcSh2LkRzdCxULkRzdCkpLGkudmVydExlcSh2LkRzdCxULkRzdCkpe2lmKGkuZWRnZVNpZ24odi5Ec3QsVC5Ec3Qsdi5PcmcpPDApcmV0dXJuITE7eS5yZWdpb25BYm92ZShjKS5kaXJ0eT1jLmRpcnR5PSEwLFI9cy5tZXNoLnNwbGl0RWRnZSh2KSxzLm1lc2guc3BsaWNlKFQuU3ltLFIpLFIuTGZhY2UuaW5zaWRlPWMuaW5zaWRlfWVsc2V7aWYoaS5lZGdlU2lnbihULkRzdCx2LkRzdCxULk9yZyk+MClyZXR1cm4hMTtjLmRpcnR5PWwuZGlydHk9ITAsUj1zLm1lc2guc3BsaXRFZGdlKFQpLHMubWVzaC5zcGxpY2Uodi5MbmV4dCxULlN5bSksUi5SZmFjZS5pbnNpZGU9Yy5pbnNpZGV9cmV0dXJuITB9LHkuY2hlY2tGb3JJbnRlcnNlY3Q9ZnVuY3Rpb24ocyxjKXt2YXIgbD15LnJlZ2lvbkJlbG93KGMpLHY9Yy5lVXAsVD1sLmVVcCxSPXYuT3JnLEw9VC5PcmcsTj12LkRzdCxBPVQuRHN0LHcsQixEPW5ldyBoLEksajtpZihmKCFpLnZlcnRFcShBLE4pKSxmKGkuZWRnZVNpZ24oTixzLmV2ZW50LFIpPD0wKSxmKGkuZWRnZVNpZ24oQSxzLmV2ZW50LEwpPj0wKSxmKFIhPT1zLmV2ZW50JiZMIT09cy5ldmVudCksZighYy5maXhVcHBlckVkZ2UmJiFsLmZpeFVwcGVyRWRnZSksUj09PUx8fCh3PU1hdGgubWluKFIudCxOLnQpLEI9TWF0aC5tYXgoTC50LEEudCksdz5CKSlyZXR1cm4hMTtpZihpLnZlcnRMZXEoUixMKSl7aWYoaS5lZGdlU2lnbihBLFIsTCk+MClyZXR1cm4hMX1lbHNlIGlmKGkuZWRnZVNpZ24oTixMLFIpPDApcmV0dXJuITE7cmV0dXJuIHkuZGVidWdFdmVudChzKSxpLmludGVyc2VjdChOLFIsQSxMLEQpLGYoTWF0aC5taW4oUi50LE4udCk8PUQudCksZihELnQ8PU1hdGgubWF4KEwudCxBLnQpKSxmKE1hdGgubWluKEEucyxOLnMpPD1ELnMpLGYoRC5zPD1NYXRoLm1heChMLnMsUi5zKSksaS52ZXJ0TGVxKEQscy5ldmVudCkmJihELnM9cy5ldmVudC5zLEQudD1zLmV2ZW50LnQpLEk9aS52ZXJ0TGVxKFIsTCk/UjpMLGkudmVydExlcShJLEQpJiYoRC5zPUkucyxELnQ9SS50KSxpLnZlcnRFcShELFIpfHxpLnZlcnRFcShELEwpPyh5LmNoZWNrRm9yUmlnaHRTcGxpY2UocyxjKSwhMSk6IWkudmVydEVxKE4scy5ldmVudCkmJmkuZWRnZVNpZ24oTixzLmV2ZW50LEQpPj0wfHwhaS52ZXJ0RXEoQSxzLmV2ZW50KSYmaS5lZGdlU2lnbihBLHMuZXZlbnQsRCk8PTA/QT09PXMuZXZlbnQ/KHMubWVzaC5zcGxpdEVkZ2Uodi5TeW0pLHMubWVzaC5zcGxpY2UoVC5TeW0sdiksYz15LnRvcExlZnRSZWdpb24ocyxjKSx2PXkucmVnaW9uQmVsb3coYykuZVVwLHkuZmluaXNoTGVmdFJlZ2lvbnMocyx5LnJlZ2lvbkJlbG93KGMpLGwpLHkuYWRkUmlnaHRFZGdlcyhzLGMsdi5PcHJldix2LHYsITApLCEwKTpOPT09cy5ldmVudD8ocy5tZXNoLnNwbGl0RWRnZShULlN5bSkscy5tZXNoLnNwbGljZSh2LkxuZXh0LFQuT3ByZXYpLGw9YyxjPXkudG9wUmlnaHRSZWdpb24oYyksaj15LnJlZ2lvbkJlbG93KGMpLmVVcC5ScHJldixsLmVVcD1ULk9wcmV2LFQ9eS5maW5pc2hMZWZ0UmVnaW9ucyhzLGwsbnVsbCkseS5hZGRSaWdodEVkZ2VzKHMsYyxULk9uZXh0LHYuUnByZXYsaiwhMCksITApOihpLmVkZ2VTaWduKE4scy5ldmVudCxEKT49MCYmKHkucmVnaW9uQWJvdmUoYykuZGlydHk9Yy5kaXJ0eT0hMCxzLm1lc2guc3BsaXRFZGdlKHYuU3ltKSx2Lk9yZy5zPXMuZXZlbnQucyx2Lk9yZy50PXMuZXZlbnQudCksaS5lZGdlU2lnbihBLHMuZXZlbnQsRCk8PTAmJihjLmRpcnR5PWwuZGlydHk9ITAscy5tZXNoLnNwbGl0RWRnZShULlN5bSksVC5Pcmcucz1zLmV2ZW50LnMsVC5PcmcudD1zLmV2ZW50LnQpLCExKToocy5tZXNoLnNwbGl0RWRnZSh2LlN5bSkscy5tZXNoLnNwbGl0RWRnZShULlN5bSkscy5tZXNoLnNwbGljZShULk9wcmV2LHYpLHYuT3JnLnM9RC5zLHYuT3JnLnQ9RC50LHYuT3JnLnBxSGFuZGxlPXMucHEuaW5zZXJ0KHYuT3JnKSx5LmdldEludGVyc2VjdERhdGEocyx2Lk9yZyxSLE4sTCxBKSx5LnJlZ2lvbkFib3ZlKGMpLmRpcnR5PWMuZGlydHk9bC5kaXJ0eT0hMCwhMSl9LHkud2Fsa0RpcnR5UmVnaW9ucz1mdW5jdGlvbihzLGMpe2Zvcih2YXIgbD15LnJlZ2lvbkJlbG93KGMpLHYsVDs7KXtmb3IoO2wuZGlydHk7KWM9bCxsPXkucmVnaW9uQmVsb3cobCk7aWYoIWMuZGlydHkmJihsPWMsYz15LnJlZ2lvbkFib3ZlKGMpLGM9PT1udWxsfHwhYy5kaXJ0eSkpcmV0dXJuO2lmKGMuZGlydHk9ITEsdj1jLmVVcCxUPWwuZVVwLHYuRHN0IT09VC5Ec3QmJnkuY2hlY2tGb3JMZWZ0U3BsaWNlKHMsYykmJihsLmZpeFVwcGVyRWRnZT8oeS5kZWxldGVSZWdpb24ocyxsKSxzLm1lc2guZGVsZXRlKFQpLGw9eS5yZWdpb25CZWxvdyhjKSxUPWwuZVVwKTpjLmZpeFVwcGVyRWRnZSYmKHkuZGVsZXRlUmVnaW9uKHMsYykscy5tZXNoLmRlbGV0ZSh2KSxjPXkucmVnaW9uQWJvdmUobCksdj1jLmVVcCkpLHYuT3JnIT09VC5PcmcpaWYodi5Ec3QhPT1ULkRzdCYmIWMuZml4VXBwZXJFZGdlJiYhbC5maXhVcHBlckVkZ2UmJih2LkRzdD09PXMuZXZlbnR8fFQuRHN0PT09cy5ldmVudCkpe2lmKHkuY2hlY2tGb3JJbnRlcnNlY3QocyxjKSlyZXR1cm59ZWxzZSB5LmNoZWNrRm9yUmlnaHRTcGxpY2UocyxjKTt2Lk9yZz09PVQuT3JnJiZ2LkRzdD09PVQuRHN0JiYoeS5hZGRXaW5kaW5nKFQsdikseS5kZWxldGVSZWdpb24ocyxjKSxzLm1lc2guZGVsZXRlKHYpLGM9eS5yZWdpb25BYm92ZShsKSl9fSx5LmNvbm5lY3RSaWdodFZlcnRleD1mdW5jdGlvbihzLGMsbCl7dmFyIHYsVD1sLk9uZXh0LFI9eS5yZWdpb25CZWxvdyhjKSxMPWMuZVVwLE49Ui5lVXAsQT0hMTtpZihMLkRzdCE9PU4uRHN0JiZ5LmNoZWNrRm9ySW50ZXJzZWN0KHMsYyksaS52ZXJ0RXEoTC5Pcmcscy5ldmVudCkmJihzLm1lc2guc3BsaWNlKFQuT3ByZXYsTCksYz15LnRvcExlZnRSZWdpb24ocyxjKSxUPXkucmVnaW9uQmVsb3coYykuZVVwLHkuZmluaXNoTGVmdFJlZ2lvbnMocyx5LnJlZ2lvbkJlbG93KGMpLFIpLEE9ITApLGkudmVydEVxKE4uT3JnLHMuZXZlbnQpJiYocy5tZXNoLnNwbGljZShsLE4uT3ByZXYpLGw9eS5maW5pc2hMZWZ0UmVnaW9ucyhzLFIsbnVsbCksQT0hMCksQSl7eS5hZGRSaWdodEVkZ2VzKHMsYyxsLk9uZXh0LFQsVCwhMCk7cmV0dXJufWkudmVydExlcShOLk9yZyxMLk9yZyk/dj1OLk9wcmV2OnY9TCx2PXMubWVzaC5jb25uZWN0KGwuTHByZXYsdikseS5hZGRSaWdodEVkZ2VzKHMsYyx2LHYuT25leHQsdi5PbmV4dCwhMSksdi5TeW0uYWN0aXZlUmVnaW9uLmZpeFVwcGVyRWRnZT0hMCx5LndhbGtEaXJ0eVJlZ2lvbnMocyxjKX0seS5jb25uZWN0TGVmdERlZ2VuZXJhdGU9ZnVuY3Rpb24ocyxjLGwpe3ZhciB2LFQsUixMLE47aWYodj1jLmVVcCxpLnZlcnRFcSh2Lk9yZyxsKSl7ZighMSkseS5zcGxpY2VNZXJnZVZlcnRpY2VzKHMsdixsLmFuRWRnZSk7cmV0dXJufWlmKCFpLnZlcnRFcSh2LkRzdCxsKSl7cy5tZXNoLnNwbGl0RWRnZSh2LlN5bSksYy5maXhVcHBlckVkZ2UmJihzLm1lc2guZGVsZXRlKHYuT25leHQpLGMuZml4VXBwZXJFZGdlPSExKSxzLm1lc2guc3BsaWNlKGwuYW5FZGdlLHYpLHkuc3dlZXBFdmVudChzLGwpO3JldHVybn1mKCExKSxjPXkudG9wUmlnaHRSZWdpb24oYyksTj15LnJlZ2lvbkJlbG93KGMpLFI9Ti5lVXAuU3ltLFQ9TD1SLk9uZXh0LE4uZml4VXBwZXJFZGdlJiYoZihUIT09UikseS5kZWxldGVSZWdpb24ocyxOKSxzLm1lc2guZGVsZXRlKFIpLFI9VC5PcHJldikscy5tZXNoLnNwbGljZShsLmFuRWRnZSxSKSxpLmVkZ2VHb2VzTGVmdChUKXx8KFQ9bnVsbCkseS5hZGRSaWdodEVkZ2VzKHMsYyxSLk9uZXh0LEwsVCwhMCl9LHkuY29ubmVjdExlZnRWZXJ0ZXg9ZnVuY3Rpb24ocyxjKXt2YXIgbCx2LFQsUixMLE4sQT1uZXcgTTtpZihBLmVVcD1jLmFuRWRnZS5TeW0sbD1zLmRpY3Quc2VhcmNoKEEpLmtleSx2PXkucmVnaW9uQmVsb3cobCksISF2KXtpZihSPWwuZVVwLEw9di5lVXAsaS5lZGdlU2lnbihSLkRzdCxjLFIuT3JnKT09PTApe3kuY29ubmVjdExlZnREZWdlbmVyYXRlKHMsbCxjKTtyZXR1cm59aWYoVD1pLnZlcnRMZXEoTC5Ec3QsUi5Ec3QpP2w6dixsLmluc2lkZXx8VC5maXhVcHBlckVkZ2Upe2lmKFQ9PT1sKU49cy5tZXNoLmNvbm5lY3QoYy5hbkVkZ2UuU3ltLFIuTG5leHQpO2Vsc2V7dmFyIHc9cy5tZXNoLmNvbm5lY3QoTC5EbmV4dCxjLmFuRWRnZSk7Tj13LlN5bX1ULmZpeFVwcGVyRWRnZT95LmZpeFVwcGVyRWRnZShzLFQsTik6eS5jb21wdXRlV2luZGluZyhzLHkuYWRkUmVnaW9uQmVsb3cocyxsLE4pKSx5LnN3ZWVwRXZlbnQocyxjKX1lbHNlIHkuYWRkUmlnaHRFZGdlcyhzLGwsYy5hbkVkZ2UsYy5hbkVkZ2UsbnVsbCwhMCl9fSx5LnN3ZWVwRXZlbnQ9ZnVuY3Rpb24ocyxjKXtzLmV2ZW50PWMseS5kZWJ1Z0V2ZW50KHMpO2Zvcih2YXIgbD1jLmFuRWRnZTtsLmFjdGl2ZVJlZ2lvbj09PW51bGw7KWlmKGw9bC5PbmV4dCxsPT09Yy5hbkVkZ2Upe3kuY29ubmVjdExlZnRWZXJ0ZXgocyxjKTtyZXR1cm59dmFyIHY9eS50b3BMZWZ0UmVnaW9uKHMsbC5hY3RpdmVSZWdpb24pO2YodiE9PW51bGwpO3ZhciBUPXkucmVnaW9uQmVsb3codiksUj1ULmVVcCxMPXkuZmluaXNoTGVmdFJlZ2lvbnMocyxULG51bGwpO0wuT25leHQ9PT1SP3kuY29ubmVjdFJpZ2h0VmVydGV4KHMsdixMKTp5LmFkZFJpZ2h0RWRnZXMocyx2LEwuT25leHQsUixSLCEwKX0seS5hZGRTZW50aW5lbD1mdW5jdGlvbihzLGMsbCx2KXt2YXIgVD1uZXcgTSxSPXMubWVzaC5tYWtlRWRnZSgpO1IuT3JnLnM9bCxSLk9yZy50PXYsUi5Ec3Qucz1jLFIuRHN0LnQ9dixzLmV2ZW50PVIuRHN0LFQuZVVwPVIsVC53aW5kaW5nTnVtYmVyPTAsVC5pbnNpZGU9ITEsVC5maXhVcHBlckVkZ2U9ITEsVC5zZW50aW5lbD0hMCxULmRpcnR5PSExLFQubm9kZVVwPXMuZGljdC5pbnNlcnQoVCl9LHkuaW5pdEVkZ2VEaWN0PWZ1bmN0aW9uKHMpe3MuZGljdD1uZXcgcChzLHkuZWRnZUxlcSk7dmFyIGM9cy5ibWF4WzBdLXMuYm1pblswXSxsPXMuYm1heFsxXS1zLmJtaW5bMV0sdj1zLmJtaW5bMF0tYyxUPXMuYm1heFswXStjLFI9cy5ibWluWzFdLWwsTD1zLmJtYXhbMV0rbDt5LmFkZFNlbnRpbmVsKHMsdixULFIpLHkuYWRkU2VudGluZWwocyx2LFQsTCl9LHkuZG9uZUVkZ2VEaWN0PWZ1bmN0aW9uKHMpe2Zvcih2YXIgYyxsPTA7KGM9cy5kaWN0Lm1pbigpLmtleSkhPT1udWxsOyljLnNlbnRpbmVsfHwoZihjLmZpeFVwcGVyRWRnZSksZigrK2w9PT0xKSksZihjLndpbmRpbmdOdW1iZXI9PT0wKSx5LmRlbGV0ZVJlZ2lvbihzLGMpfSx5LnJlbW92ZURlZ2VuZXJhdGVFZGdlcz1mdW5jdGlvbihzKXt2YXIgYyxsLHYsVD1zLm1lc2guZUhlYWQ7Zm9yKGM9VC5uZXh0O2MhPT1UO2M9bClsPWMubmV4dCx2PWMuTG5leHQsaS52ZXJ0RXEoYy5PcmcsYy5Ec3QpJiZjLkxuZXh0LkxuZXh0IT09YyYmKHkuc3BsaWNlTWVyZ2VWZXJ0aWNlcyhzLHYsYykscy5tZXNoLmRlbGV0ZShjKSxjPXYsdj1jLkxuZXh0KSx2LkxuZXh0PT09YyYmKHYhPT1jJiYoKHY9PT1sfHx2PT09bC5TeW0pJiYobD1sLm5leHQpLHMubWVzaC5kZWxldGUodikpLChjPT09bHx8Yz09PWwuU3ltKSYmKGw9bC5uZXh0KSxzLm1lc2guZGVsZXRlKGMpKX0seS5pbml0UHJpb3JpdHlRPWZ1bmN0aW9uKHMpe3ZhciBjLGwsdixUPTA7Zm9yKHY9cy5tZXNoLnZIZWFkLGw9di5uZXh0O2whPT12O2w9bC5uZXh0KVQrKztmb3IoVCs9OCxjPXMucHE9bmV3IGIoVCxpLnZlcnRMZXEpLHY9cy5tZXNoLnZIZWFkLGw9di5uZXh0O2whPT12O2w9bC5uZXh0KWwucHFIYW5kbGU9Yy5pbnNlcnQobCk7cmV0dXJuIGwhPT12PyExOihjLmluaXQoKSwhMCl9LHkuZG9uZVByaW9yaXR5UT1mdW5jdGlvbihzKXtzLnBxPW51bGx9LHkucmVtb3ZlRGVnZW5lcmF0ZUZhY2VzPWZ1bmN0aW9uKHMsYyl7dmFyIGwsdixUO2ZvcihsPWMuZkhlYWQubmV4dDtsIT09Yy5mSGVhZDtsPXYpdj1sLm5leHQsVD1sLmFuRWRnZSxmKFQuTG5leHQhPT1UKSxULkxuZXh0LkxuZXh0PT09VCYmKHkuYWRkV2luZGluZyhULk9uZXh0LFQpLHMubWVzaC5kZWxldGUoVCkpO3JldHVybiEwfSx5LmNvbXB1dGVJbnRlcmlvcj1mdW5jdGlvbihzKXt2YXIgYyxsO2lmKHkucmVtb3ZlRGVnZW5lcmF0ZUVkZ2VzKHMpLCF5LmluaXRQcmlvcml0eVEocykpcmV0dXJuITE7Zm9yKHkuaW5pdEVkZ2VEaWN0KHMpOyhjPXMucHEuZXh0cmFjdE1pbigpKSE9PW51bGw7KXtmb3IoO2w9cy5wcS5taW4oKSwhKGw9PT1udWxsfHwhaS52ZXJ0RXEobCxjKSk7KWw9cy5wcS5leHRyYWN0TWluKCkseS5zcGxpY2VNZXJnZVZlcnRpY2VzKHMsYy5hbkVkZ2UsbC5hbkVkZ2UpO3kuc3dlZXBFdmVudChzLGMpfXJldHVybiBzLmV2ZW50PXMuZGljdC5taW4oKS5rZXkuZVVwLk9yZyx5LmRlYnVnRXZlbnQocykseS5kb25lRWRnZURpY3QocykseS5kb25lUHJpb3JpdHlRKHMpLHkucmVtb3ZlRGVnZW5lcmF0ZUZhY2VzKHMscy5tZXNoKT8ocy5tZXNoLmNoZWNrKCksITApOiExfTtmdW5jdGlvbiBTKCl7dGhpcy5tZXNoPW51bGwsdGhpcy5ub3JtYWw9WzAsMCwwXSx0aGlzLnNVbml0PVswLDAsMF0sdGhpcy50VW5pdD1bMCwwLDBdLHRoaXMuYm1pbj1bMCwwXSx0aGlzLmJtYXg9WzAsMF0sdGhpcy53aW5kaW5nUnVsZT1uLldJTkRJTkdfT0RELHRoaXMuZGljdD1udWxsLHRoaXMucHE9bnVsbCx0aGlzLmV2ZW50PW51bGwsdGhpcy52ZXJ0ZXhJbmRleENvdW50ZXI9MCx0aGlzLnZlcnRpY2VzPVtdLHRoaXMudmVydGV4SW5kaWNlcz1bXSx0aGlzLnZlcnRleENvdW50PTAsdGhpcy5lbGVtZW50cz1bXSx0aGlzLmVsZW1lbnRDb3VudD0wfVMucHJvdG90eXBlPXtkb3RfOmZ1bmN0aW9uKHMsYyl7cmV0dXJuIHNbMF0qY1swXStzWzFdKmNbMV0rc1syXSpjWzJdfSxub3JtYWxpemVfOmZ1bmN0aW9uKHMpe3ZhciBjPXNbMF0qc1swXStzWzFdKnNbMV0rc1syXSpzWzJdO2YoYz4wKSxjPU1hdGguc3FydChjKSxzWzBdLz1jLHNbMV0vPWMsc1syXS89Y30sbG9uZ0F4aXNfOmZ1bmN0aW9uKHMpe3ZhciBjPTA7cmV0dXJuIE1hdGguYWJzKHNbMV0pPk1hdGguYWJzKHNbMF0pJiYoYz0xKSxNYXRoLmFicyhzWzJdKT5NYXRoLmFicyhzW2NdKSYmKGM9MiksY30sY29tcHV0ZU5vcm1hbF86ZnVuY3Rpb24ocyl7dmFyIGMsbCx2LFQsUixMLE49WzAsMCwwXSxBPVswLDAsMF0sdz1bMCwwLDBdLEI9WzAsMCwwXSxEPVswLDAsMF0sST1bbnVsbCxudWxsLG51bGxdLGo9W251bGwsbnVsbCxudWxsXSxWPXRoaXMubWVzaC52SGVhZCxKO2ZvcihjPVYubmV4dCxKPTA7SjwzOysrSilUPWMuY29vcmRzW0pdLEFbSl09VCxqW0pdPWMsTltKXT1ULElbSl09Yztmb3IoYz1WLm5leHQ7YyE9PVY7Yz1jLm5leHQpZm9yKEo9MDtKPDM7KytKKVQ9Yy5jb29yZHNbSl0sVDxBW0pdJiYoQVtKXT1ULGpbSl09YyksVD5OW0pdJiYoTltKXT1ULElbSl09Yyk7aWYoSj0wLE5bMV0tQVsxXT5OWzBdLUFbMF0mJihKPTEpLE5bMl0tQVsyXT5OW0pdLUFbSl0mJihKPTIpLEFbSl0+PU5bSl0pe3NbMF09MCxzWzFdPTAsc1syXT0xO3JldHVybn1mb3IoTD0wLGw9altKXSx2PUlbSl0sd1swXT1sLmNvb3Jkc1swXS12LmNvb3Jkc1swXSx3WzFdPWwuY29vcmRzWzFdLXYuY29vcmRzWzFdLHdbMl09bC5jb29yZHNbMl0tdi5jb29yZHNbMl0sYz1WLm5leHQ7YyE9PVY7Yz1jLm5leHQpQlswXT1jLmNvb3Jkc1swXS12LmNvb3Jkc1swXSxCWzFdPWMuY29vcmRzWzFdLXYuY29vcmRzWzFdLEJbMl09Yy5jb29yZHNbMl0tdi5jb29yZHNbMl0sRFswXT13WzFdKkJbMl0td1syXSpCWzFdLERbMV09d1syXSpCWzBdLXdbMF0qQlsyXSxEWzJdPXdbMF0qQlsxXS13WzFdKkJbMF0sUj1EWzBdKkRbMF0rRFsxXSpEWzFdK0RbMl0qRFsyXSxSPkwmJihMPVIsc1swXT1EWzBdLHNbMV09RFsxXSxzWzJdPURbMl0pO0w8PTAmJihzWzBdPXNbMV09c1syXT0wLHNbdGhpcy5sb25nQXhpc18odyldPTEpfSxjaGVja09yaWVudGF0aW9uXzpmdW5jdGlvbigpe3ZhciBzLGMsbD10aGlzLm1lc2guZkhlYWQsdixUPXRoaXMubWVzaC52SGVhZCxSO2ZvcihzPTAsYz1sLm5leHQ7YyE9PWw7Yz1jLm5leHQpaWYoUj1jLmFuRWRnZSwhKFIud2luZGluZzw9MCkpZG8gcys9KFIuT3JnLnMtUi5Ec3QucykqKFIuT3JnLnQrUi5Ec3QudCksUj1SLkxuZXh0O3doaWxlKFIhPT1jLmFuRWRnZSk7aWYoczwwKXtmb3Iodj1ULm5leHQ7diE9PVQ7dj12Lm5leHQpdi50PS12LnQ7dGhpcy50VW5pdFswXT0tdGhpcy50VW5pdFswXSx0aGlzLnRVbml0WzFdPS10aGlzLnRVbml0WzFdLHRoaXMudFVuaXRbMl09LXRoaXMudFVuaXRbMl19fSxwcm9qZWN0UG9seWdvbl86ZnVuY3Rpb24oKXt2YXIgcyxjPXRoaXMubWVzaC52SGVhZCxsPVswLDAsMF0sdixULFIsTCxOPSExO2ZvcihsWzBdPXRoaXMubm9ybWFsWzBdLGxbMV09dGhpcy5ub3JtYWxbMV0sbFsyXT10aGlzLm5vcm1hbFsyXSxsWzBdPT09MCYmbFsxXT09PTAmJmxbMl09PT0wJiYodGhpcy5jb21wdXRlTm9ybWFsXyhsKSxOPSEwKSx2PXRoaXMuc1VuaXQsVD10aGlzLnRVbml0LFI9dGhpcy5sb25nQXhpc18obCksdltSXT0wLHZbKFIrMSklM109MSx2WyhSKzIpJTNdPTAsVFtSXT0wLFRbKFIrMSklM109MCxUWyhSKzIpJTNdPWxbUl0+MD8xOi0xLHM9Yy5uZXh0O3MhPT1jO3M9cy5uZXh0KXMucz10aGlzLmRvdF8ocy5jb29yZHMsdikscy50PXRoaXMuZG90XyhzLmNvb3JkcyxUKTtmb3IoTiYmdGhpcy5jaGVja09yaWVudGF0aW9uXygpLEw9ITAscz1jLm5leHQ7cyE9PWM7cz1zLm5leHQpTD8odGhpcy5ibWluWzBdPXRoaXMuYm1heFswXT1zLnMsdGhpcy5ibWluWzFdPXRoaXMuYm1heFsxXT1zLnQsTD0hMSk6KHMuczx0aGlzLmJtaW5bMF0mJih0aGlzLmJtaW5bMF09cy5zKSxzLnM+dGhpcy5ibWF4WzBdJiYodGhpcy5ibWF4WzBdPXMucykscy50PHRoaXMuYm1pblsxXSYmKHRoaXMuYm1pblsxXT1zLnQpLHMudD50aGlzLmJtYXhbMV0mJih0aGlzLmJtYXhbMV09cy50KSl9LGFkZFdpbmRpbmdfOmZ1bmN0aW9uKHMsYyl7cy53aW5kaW5nKz1jLndpbmRpbmcscy5TeW0ud2luZGluZys9Yy5TeW0ud2luZGluZ30sdGVzc2VsbGF0ZU1vbm9SZWdpb25fOmZ1bmN0aW9uKHMsYyl7dmFyIGwsdjtmb3IobD1jLmFuRWRnZSxmKGwuTG5leHQhPT1sJiZsLkxuZXh0LkxuZXh0IT09bCk7aS52ZXJ0TGVxKGwuRHN0LGwuT3JnKTtsPWwuTHByZXYpO2Zvcig7aS52ZXJ0TGVxKGwuT3JnLGwuRHN0KTtsPWwuTG5leHQpO2Zvcih2PWwuTHByZXY7bC5MbmV4dCE9PXY7KWlmKGkudmVydExlcShsLkRzdCx2Lk9yZykpe2Zvcig7di5MbmV4dCE9PWwmJihpLmVkZ2VHb2VzTGVmdCh2LkxuZXh0KXx8aS5lZGdlU2lnbih2Lk9yZyx2LkRzdCx2LkxuZXh0LkRzdCk8PTApOyl7dmFyIFQ9cy5jb25uZWN0KHYuTG5leHQsdik7dj1ULlN5bX12PXYuTHByZXZ9ZWxzZXtmb3IoO3YuTG5leHQhPT1sJiYoaS5lZGdlR29lc1JpZ2h0KGwuTHByZXYpfHxpLmVkZ2VTaWduKGwuRHN0LGwuT3JnLGwuTHByZXYuT3JnKT49MCk7KXt2YXIgVD1zLmNvbm5lY3QobCxsLkxwcmV2KTtsPVQuU3ltfWw9bC5MbmV4dH1mb3IoZih2LkxuZXh0IT09bCk7di5MbmV4dC5MbmV4dCE9PWw7KXt2YXIgVD1zLmNvbm5lY3Qodi5MbmV4dCx2KTt2PVQuU3ltfXJldHVybiEwfSx0ZXNzZWxsYXRlSW50ZXJpb3JfOmZ1bmN0aW9uKHMpe3ZhciBjLGw7Zm9yKGM9cy5mSGVhZC5uZXh0O2MhPT1zLmZIZWFkO2M9bClpZihsPWMubmV4dCxjLmluc2lkZSYmIXRoaXMudGVzc2VsbGF0ZU1vbm9SZWdpb25fKHMsYykpcmV0dXJuITE7cmV0dXJuITB9LGRpc2NhcmRFeHRlcmlvcl86ZnVuY3Rpb24ocyl7dmFyIGMsbDtmb3IoYz1zLmZIZWFkLm5leHQ7YyE9PXMuZkhlYWQ7Yz1sKWw9Yy5uZXh0LGMuaW5zaWRlfHxzLnphcEZhY2UoYyl9LHNldFdpbmRpbmdOdW1iZXJfOmZ1bmN0aW9uKHMsYyxsKXt2YXIgdixUO2Zvcih2PXMuZUhlYWQubmV4dDt2IT09cy5lSGVhZDt2PVQpVD12Lm5leHQsdi5SZmFjZS5pbnNpZGUhPT12LkxmYWNlLmluc2lkZT92LndpbmRpbmc9di5MZmFjZS5pbnNpZGU/YzotYzpsP3MuZGVsZXRlKHYpOnYud2luZGluZz0wfSxnZXROZWlnaGJvdXJGYWNlXzpmdW5jdGlvbihzKXtyZXR1cm4hcy5SZmFjZXx8IXMuUmZhY2UuaW5zaWRlPy0xOnMuUmZhY2Uubn0sb3V0cHV0UG9seW1lc2hfOmZ1bmN0aW9uKHMsYyxsLHYpe3ZhciBULFIsTCxOPTAsQT0wLHcsQjtmb3IobD4zJiZzLm1lcmdlQ29udmV4RmFjZXMobCksVD1zLnZIZWFkLm5leHQ7VCE9PXMudkhlYWQ7VD1ULm5leHQpVC5uPS0xO2ZvcihSPXMuZkhlYWQubmV4dDtSIT09cy5mSGVhZDtSPVIubmV4dClpZihSLm49LTEsISFSLmluc2lkZSl7TD1SLmFuRWRnZSx3PTA7ZG8gVD1MLk9yZyxULm49PT0tMSYmKFQubj1BLEErKyksdysrLEw9TC5MbmV4dDt3aGlsZShMIT09Ui5hbkVkZ2UpO2Yodzw9bCksUi5uPU4sKytOfWZvcih0aGlzLmVsZW1lbnRDb3VudD1OLGM9PT1uLkNPTk5FQ1RFRF9QT0xZR09OUyYmKE4qPTIpLHRoaXMuZWxlbWVudHM9W10sdGhpcy5lbGVtZW50cy5sZW5ndGg9TipsLHRoaXMudmVydGV4Q291bnQ9QSx0aGlzLnZlcnRpY2VzPVtdLHRoaXMudmVydGljZXMubGVuZ3RoPUEqdix0aGlzLnZlcnRleEluZGljZXM9W10sdGhpcy52ZXJ0ZXhJbmRpY2VzLmxlbmd0aD1BLFQ9cy52SGVhZC5uZXh0O1QhPT1zLnZIZWFkO1Q9VC5uZXh0KWlmKFQubiE9PS0xKXt2YXIgRD1ULm4qdjt0aGlzLnZlcnRpY2VzW0QrMF09VC5jb29yZHNbMF0sdGhpcy52ZXJ0aWNlc1tEKzFdPVQuY29vcmRzWzFdLHY+MiYmKHRoaXMudmVydGljZXNbRCsyXT1ULmNvb3Jkc1syXSksdGhpcy52ZXJ0ZXhJbmRpY2VzW1Qubl09VC5pZHh9dmFyIEk9MDtmb3IoUj1zLmZIZWFkLm5leHQ7UiE9PXMuZkhlYWQ7Uj1SLm5leHQpaWYoUi5pbnNpZGUpe0w9Ui5hbkVkZ2Usdz0wO2RvIFQ9TC5PcmcsdGhpcy5lbGVtZW50c1tJKytdPVQubix3KyssTD1MLkxuZXh0O3doaWxlKEwhPT1SLmFuRWRnZSk7Zm9yKEI9dztCPGw7KytCKXRoaXMuZWxlbWVudHNbSSsrXT0tMTtpZihjPT09bi5DT05ORUNURURfUE9MWUdPTlMpe0w9Ui5hbkVkZ2U7ZG8gdGhpcy5lbGVtZW50c1tJKytdPXRoaXMuZ2V0TmVpZ2hib3VyRmFjZV8oTCksTD1MLkxuZXh0O3doaWxlKEwhPT1SLmFuRWRnZSk7Zm9yKEI9dztCPGw7KytCKXRoaXMuZWxlbWVudHNbSSsrXT0tMX19fSxvdXRwdXRDb250b3Vyc186ZnVuY3Rpb24ocyxjKXt2YXIgbCx2LFQsUj0wLEw9MDtmb3IodGhpcy52ZXJ0ZXhDb3VudD0wLHRoaXMuZWxlbWVudENvdW50PTAsbD1zLmZIZWFkLm5leHQ7bCE9PXMuZkhlYWQ7bD1sLm5leHQpaWYobC5pbnNpZGUpe1Q9dj1sLmFuRWRnZTtkbyB0aGlzLnZlcnRleENvdW50Kyssdj12LkxuZXh0O3doaWxlKHYhPT1UKTt0aGlzLmVsZW1lbnRDb3VudCsrfXRoaXMuZWxlbWVudHM9W10sdGhpcy5lbGVtZW50cy5sZW5ndGg9dGhpcy5lbGVtZW50Q291bnQqMix0aGlzLnZlcnRpY2VzPVtdLHRoaXMudmVydGljZXMubGVuZ3RoPXRoaXMudmVydGV4Q291bnQqYyx0aGlzLnZlcnRleEluZGljZXM9W10sdGhpcy52ZXJ0ZXhJbmRpY2VzLmxlbmd0aD10aGlzLnZlcnRleENvdW50O3ZhciBOPTAsQT0wLHc9MDtmb3IoUj0wLGw9cy5mSGVhZC5uZXh0O2whPT1zLmZIZWFkO2w9bC5uZXh0KWlmKGwuaW5zaWRlKXtMPTAsVD12PWwuYW5FZGdlO2RvIHRoaXMudmVydGljZXNbTisrXT12Lk9yZy5jb29yZHNbMF0sdGhpcy52ZXJ0aWNlc1tOKytdPXYuT3JnLmNvb3Jkc1sxXSxjPjImJih0aGlzLnZlcnRpY2VzW04rK109di5PcmcuY29vcmRzWzJdKSx0aGlzLnZlcnRleEluZGljZXNbQSsrXT12Lk9yZy5pZHgsTCsrLHY9di5MbmV4dDt3aGlsZSh2IT09VCk7dGhpcy5lbGVtZW50c1t3KytdPVIsdGhpcy5lbGVtZW50c1t3KytdPUwsUis9TH19LGFkZENvbnRvdXI6ZnVuY3Rpb24ocyxjKXt2YXIgbCx2O2Zvcih0aGlzLm1lc2g9PT1udWxsJiYodGhpcy5tZXNoPW5ldyBkKSxzPDImJihzPTIpLHM+MyYmKHM9MyksbD1udWxsLHY9MDt2PGMubGVuZ3RoO3YrPXMpbD09PW51bGw/KGw9dGhpcy5tZXNoLm1ha2VFZGdlKCksdGhpcy5tZXNoLnNwbGljZShsLGwuU3ltKSk6KHRoaXMubWVzaC5zcGxpdEVkZ2UobCksbD1sLkxuZXh0KSxsLk9yZy5jb29yZHNbMF09Y1t2KzBdLGwuT3JnLmNvb3Jkc1sxXT1jW3YrMV0scz4yP2wuT3JnLmNvb3Jkc1syXT1jW3YrMl06bC5PcmcuY29vcmRzWzJdPTAsbC5PcmcuaWR4PXRoaXMudmVydGV4SW5kZXhDb3VudGVyKyssbC53aW5kaW5nPTEsbC5TeW0ud2luZGluZz0tMX0sdGVzc2VsYXRlOmZ1bmN0aW9uKHMsYyxsLHYsVCl7aWYodGhpcy52ZXJ0aWNlcz1bXSx0aGlzLmVsZW1lbnRzPVtdLHRoaXMudmVydGV4SW5kaWNlcz1bXSx0aGlzLnZlcnRleEluZGV4Q291bnRlcj0wLFQmJih0aGlzLm5vcm1hbFswXT1UWzBdLHRoaXMubm9ybWFsWzFdPVRbMV0sdGhpcy5ub3JtYWxbMl09VFsyXSksdGhpcy53aW5kaW5nUnVsZT1zLHY8MiYmKHY9Miksdj4zJiYodj0zKSwhdGhpcy5tZXNoKXJldHVybiExO3RoaXMucHJvamVjdFBvbHlnb25fKCkseS5jb21wdXRlSW50ZXJpb3IodGhpcyk7dmFyIFI9dGhpcy5tZXNoO3JldHVybiBjPT09bi5CT1VOREFSWV9DT05UT1VSUz90aGlzLnNldFdpbmRpbmdOdW1iZXJfKFIsMSwhMCk6dGhpcy50ZXNzZWxsYXRlSW50ZXJpb3JfKFIpLFIuY2hlY2soKSxjPT09bi5CT1VOREFSWV9DT05UT1VSUz90aGlzLm91dHB1dENvbnRvdXJzXyhSLHYpOnRoaXMub3V0cHV0UG9seW1lc2hfKFIsYyxsLHYpLCEwfX19LGZ1bmN0aW9uKGcsZSl7Zy5leHBvcnRzPW47dmFyIHQ9T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtmdW5jdGlvbiBuKCl7Zm9yKHZhciBpPXt9LGY9MDtmPGFyZ3VtZW50cy5sZW5ndGg7ZisrKXt2YXIgaD1hcmd1bWVudHNbZl07Zm9yKHZhciB1IGluIGgpdC5jYWxsKGgsdSkmJihpW3VdPWhbdV0pfXJldHVybiBpfX0sZnVuY3Rpb24oZyxlLHQpe3QucihlKSx0LmQoZSwiY3JlYXRlU2hhZGVycyIsZnVuY3Rpb24oKXtyZXR1cm4gYX0pLHQuZChlLCJhcHBseVNoYWRlciIsZnVuY3Rpb24oKXtyZXR1cm4gZH0pLHQuZChlLCJjcmVhdGVDbG91ZFNoYWRlcnMiLGZ1bmN0aW9uKCl7cmV0dXJuIHB9KSx0LmQoZSwiYXBwbHlDbG91ZFNoYWRlciIsZnVuY3Rpb24oKXtyZXR1cm4gT30pO3ZhciBuPXQoNjQpLGk9dCg2NSksZj10KDY2KSxoPXQoNjcpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCB1PVN5bWJvbCgic2hhZGVycyIpO2Z1bmN0aW9uIGEobSl7bVt1XT1bXTtmb3IobGV0IGI9MDtiPDE2O2IrKyl7Y29uc3QgTT1bXSx5PSEhKGImMSksUz0hIShiJjIpLHM9ISEoYiY0KSxjPSEhKGImOCk7eSYmTS5wdXNoKCIjZGVmaW5lIFRFWFRVUkUgMSIpLFMmJk0ucHVzaCgiI2RlZmluZSBGSUxURVIgMSIpLHMmJk0ucHVzaCgiI2RlZmluZSBHUkFESUVOVCAxIiksYyYmTS5wdXNoKCIjZGVmaW5lIENMSVBQQVRIIDEiKTtjb25zdCBsPWAke00uam9pbihgCmApfQpgLHY9W107eSYmdi5wdXNoKCJ1bmlmb3JtIHNhbXBsZXIyRCB1X3RleFNhbXBsZXI7IiksYyYmdi5wdXNoKCJ1bmlmb3JtIHNhbXBsZXIyRCB1X2NsaXBTYW1wbGVyOyIpLG1bdV1bYl09W2wrdi5qb2luKGAKYCkraS5kZWZhdWx0LGwrbi5kZWZhdWx0XX19ZnVuY3Rpb24gZChtLHtoYXNUZXh0dXJlOmI9ITEsaGFzRmlsdGVyOk09ITEsaGFzR3JhZGllbnQ6eT0hMSxoYXNDbGlwUGF0aDpTPSExfT17fSl7Y29uc3Qgcz1ifE08PDF8eTw8MnxTPDwzO2xldCBjPW1bdV1bc107QXJyYXkuaXNBcnJheShjKSYmKGM9bS5jcmVhdGVQcm9ncmFtKC4uLmMpLG1bdV1bc109YyksbS5wcm9ncmFtIT09YyYmbS51c2VQcm9ncmFtKGMse2FfY29sb3I6e3R5cGU6IlVOU0lHTkVEX0JZVEUiLG5vcm1hbGl6ZTohMH19KX1jb25zdCBFPVtdO2Z1bmN0aW9uIHAobSl7Zm9yKGxldCBiPTA7Yjw2NDtiKyspe2NvbnN0IE09W10seT0hIShiJjEpLFM9ISEoYiYyKSxzPSEhKGImNCksYz0hIShiJjgpLGw9ISEoYiYxNiksdj0hIShiJjMyKTt5JiZNLnB1c2goIiNkZWZpbmUgVEVYVFVSRSAxIiksUyYmTS5wdXNoKCIjZGVmaW5lIEZJTFRFUiAxIikscyYmTS5wdXNoKCIjZGVmaW5lIEdSQURJRU5UIDEiKSxjJiZNLnB1c2goIiNkZWZpbmUgQ0xPVURDT0xPUiAxIiksbCYmTS5wdXNoKCIjZGVmaW5lIENMT1VERklMVEVSIDEiKSx2JiZNLnB1c2goIiNkZWZpbmUgQ0xJUFBBVEggMSIpO2NvbnN0IFQ9YCR7TS5qb2luKGAKYCl9CmAsUj1bXTtpZih5KXtSLnB1c2goInVuaWZvcm0gc2FtcGxlcjJEIHVfdGV4U2FtcGxlcjsiKTtmb3IobGV0IEw9MDtMPDEyO0wrKylSLnB1c2goYHVuaWZvcm0gc2FtcGxlcjJEIHVfdGV4RnJhbWUke0x9O2ApfXYmJlIucHVzaCgidW5pZm9ybSBzYW1wbGVyMkQgdV9jbGlwU2FtcGxlcjsiKSxFW2JdPVtUK1Iuam9pbihgCmApK2guZGVmYXVsdCxUK2YuZGVmYXVsdF19fWZ1bmN0aW9uIE8obSx7aGFzVGV4dHVyZTpiPSExLGhhc0ZpbHRlcjpNPSExLGhhc0dyYWRpZW50Onk9ITEsaGFzQ2xvdWRDb2xvcjpTPSExLGhhc0Nsb3VkRmlsdGVyOnM9ITEsaGFzQ2xpcFBhdGg6Yz0hMX09e30pe2NvbnN0IGw9YnxNPDwxfHk8PDJ8Uzw8M3xzPDw0fGM8PDU7bGV0IHY9RVtsXTtBcnJheS5pc0FycmF5KHYpJiYodj1tLmNyZWF0ZVByb2dyYW0oLi4udiksRVtsXT12KSxtLnByb2dyYW0hPT12JiZtLnVzZVByb2dyYW0odix7YV9jb2xvcjp7dHlwZToiVU5TSUdORURfQllURSIsbm9ybWFsaXplOiEwfSxhX2ZpbGxDbG91ZENvbG9yOnt0eXBlOiJVTlNJR05FRF9CWVRFIixub3JtYWxpemU6ITB9LGFfc3Ryb2tlQ2xvdWRDb2xvcjp7dHlwZToiVU5TSUdORURfQllURSIsbm9ybWFsaXplOiEwfSxhX2ZyYW1lSW5kZXg6e3R5cGU6IlVOU0lHTkVEX0JZVEUiLG5vcm1hbGl6ZTohMX19KX19LGZ1bmN0aW9uKGcsZSx0KXt0LnIoZSksZS5kZWZhdWx0PWBhdHRyaWJ1dGUgdmVjMyBhX3ZlcnRleFBvc2l0aW9uOwphdHRyaWJ1dGUgdmVjNCBhX2NvbG9yOwp2YXJ5aW5nIHZlYzQgdkNvbG9yOwp2YXJ5aW5nIGZsb2F0IGZsYWdCYWNrZ3JvdW5kOwp1bmlmb3JtIHZlYzIgdV9yZXNvbHV0aW9uOwp1bmlmb3JtIG1hdDMgdmlld01hdHJpeDsKdW5pZm9ybSBtYXQzIHByb2plY3Rpb25NYXRyaXg7CgojaWZkZWYgVEVYVFVSRQphdHRyaWJ1dGUgdmVjMyBhX3ZlcnRleFRleHR1cmVDb29yZDsKdmFyeWluZyB2ZWMzIHZUZXh0dXJlQ29vcmQ7CmF0dHJpYnV0ZSB2ZWM0IGFfc291cmNlUmVjdDsKdmFyeWluZyB2ZWM0IHZTb3VyY2VSZWN0OwojZW5kaWYKCiNpZmRlZiBDTElQUEFUSAphdHRyaWJ1dGUgdmVjMiBhX2NsaXBVVjsKdmFyeWluZyB2ZWMyIHZDbGlwVVY7CiNlbmRpZgoKI2lmZGVmIEdSQURJRU5UCnVuaWZvcm0gZmxvYXQgdV9yYWRpYWxHcmFkaWVudFZlY3Rvcls2XTsKdmFyeWluZyB2ZWMzIHZHcmFkaWVudFZlY3RvcjE7CnZhcnlpbmcgdmVjMyB2R3JhZGllbnRWZWN0b3IyOwojZW5kaWYKCnZvaWQgbWFpbigpIHsKICBnbF9Qb2ludFNpemUgPSAxLjA7CgogIHZlYzMgcG9zID0gcHJvamVjdGlvbk1hdHJpeCAqIHZpZXdNYXRyaXggKiB2ZWMzKGFfdmVydGV4UG9zaXRpb24ueHksIDEuMCk7CiAgZ2xfUG9zaXRpb24gPSB2ZWM0KHBvcy54eSwgMS4wLCAxLjApOwoKI2lmZGVmIEdSQURJRU5UCiAgdmVjMyB2ZzEgPSB2aWV3TWF0cml4ICogdmVjMyh1X3JhZGlhbEdyYWRpZW50VmVjdG9yWzBdLCB1X3JhZGlhbEdyYWRpZW50VmVjdG9yWzFdLCAxLjApOwogIHZlYzMgdmcyID0gdmlld01hdHJpeCAqIHZlYzModV9yYWRpYWxHcmFkaWVudFZlY3RvclszXSwgdV9yYWRpYWxHcmFkaWVudFZlY3Rvcls0XSwgMS4wKTsKICBmbG9hdCBoID0gdV9yZXNvbHV0aW9uLnk7CiAgdmcxLnkgPSBoIC0gdmcxLnk7CiAgdmcyLnkgPSBoIC0gdmcyLnk7CiAgdkdyYWRpZW50VmVjdG9yMSA9IHZlYzModmcxLnh5LCB1X3JhZGlhbEdyYWRpZW50VmVjdG9yWzJdKTsKICB2R3JhZGllbnRWZWN0b3IyID0gdmVjMyh2ZzIueHksIHVfcmFkaWFsR3JhZGllbnRWZWN0b3JbNV0pOwojZW5kaWYKICAKICBmbGFnQmFja2dyb3VuZCA9IGFfdmVydGV4UG9zaXRpb24uejsKICB2Q29sb3IgPSBhX2NvbG9yOwoKI2lmZGVmIFRFWFRVUkUKICB2VGV4dHVyZUNvb3JkID0gYV92ZXJ0ZXhUZXh0dXJlQ29vcmQ7CiAgdlNvdXJjZVJlY3QgPSBhX3NvdXJjZVJlY3Q7CiNlbmRpZgoKI2lmZGVmIENMSVBQQVRICiAgdkNsaXBVViA9IGFfY2xpcFVWOwojZW5kaWYKfWB9LGZ1bmN0aW9uKGcsZSx0KXt0LnIoZSksZS5kZWZhdWx0PWBwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDsKCnZhcnlpbmcgdmVjNCB2Q29sb3I7CnZhcnlpbmcgZmxvYXQgZmxhZ0JhY2tncm91bmQ7CgojaWZkZWYgVEVYVFVSRQp2YXJ5aW5nIHZlYzMgdlRleHR1cmVDb29yZDsKdmFyeWluZyB2ZWM0IHZTb3VyY2VSZWN0OwojZW5kaWYKCiNpZmRlZiBDTElQUEFUSAp2YXJ5aW5nIHZlYzIgdkNsaXBVVjsKI2VuZGlmCgojaWZkZWYgRklMVEVSCnVuaWZvcm0gaW50IHVfZmlsdGVyRmxhZzsKdW5pZm9ybSBmbG9hdCB1X2NvbG9yTWF0cml4WzIwXTsKI2VuZGlmCgojaWZkZWYgR1JBRElFTlQKdmFyeWluZyB2ZWMzIHZHcmFkaWVudFZlY3RvcjE7CnZhcnlpbmcgdmVjMyB2R3JhZGllbnRWZWN0b3IyOwp1bmlmb3JtIGZsb2F0IHVfY29sb3JTdGVwc1s0MF07CnVuaWZvcm0gaW50IHVfZ3JhZGllbnRUeXBlOwovLyB1bmlmb3JtIGZsb2F0IHVfcmFkaWFsR3JhZGllbnRWZWN0b3JbNl07Cgp2b2lkIGdyYWRpZW50KGlub3V0IHZlYzQgY29sb3IsIHZlYzMgZ3YxLCB2ZWMzIGd2MiwgZmxvYXQgY29sb3JTdGVwc1s0MF0pIHsKICBmbG9hdCB0OwogIC8vIGNlbnRlciBjaXJjbGUgcmFkaXVzCiAgZmxvYXQgY3IgPSBndjEuejsKICAvLyBmb2NhbCBjaXJjbGUgcmFkaXVzCiAgZmxvYXQgZnIgPSBndjIuejsKCiAgaWYoY3IgPiAwLjAgfHwgZnIgPiAwLjApIHsKICAgIC8vIHJhZGlhbCBncmFkaWVudAogICAgdmVjMiBjZW50ZXIgPSBndjEueHk7CiAgICB2ZWMyIGZvY2FsID0gZ3YyLnh5OwogICAgZmxvYXQgeCA9IGZvY2FsLnggLSBnbF9GcmFnQ29vcmQueDsKICAgIGZsb2F0IHkgPSBmb2NhbC55IC0gZ2xfRnJhZ0Nvb3JkLnk7CiAgICBmbG9hdCBkeCA9IGZvY2FsLnggLSBjZW50ZXIueDsKICAgIGZsb2F0IGR5ID0gZm9jYWwueSAtIGNlbnRlci55OwogICAgZmxvYXQgZHIgPSBjciAtIGZyOwogICAgZmxvYXQgYSA9IGR4ICogZHggKyBkeSAqIGR5IC0gZHIgKiBkcjsKICAgIGZsb2F0IGIgPSAtMi4wICogKHkgKiBkeSArIHggKiBkeCArIGZyICogZHIpOwogICAgZmxvYXQgYyA9IHggKiB4ICsgeSAqIHkgLSBmciAqIGZyOwogICAgdCA9IDEuMCAtIDAuNSAqICgxLjAgLyBhKSAqICgtYiArIHNxcnQoYiAqIGIgLSA0LjAgKiBhICogYykpOwogIH0gZWxzZSB7CiAgICAvLyBsaW5lYXIgZ3JhZGllbnQKICAgIHZlYzIgdjEgPSBnbF9GcmFnQ29vcmQueHkgLSBndjEueHk7CiAgICB2ZWMyIHYyID0gZ3YyLnh5IC0gZ3YxLnh5OwogICAgdCA9ICh2MS54ICogdjIueCArIHYxLnkgKiB2Mi55KSAvICh2Mi54ICogdjIueCArIHYyLnkgKiB2Mi55KTsKICB9CgogIHZlYzQgY29sb3JzWzhdOwogIGNvbG9yc1swXSA9IHZlYzQoY29sb3JTdGVwc1sxXSwgY29sb3JTdGVwc1syXSwgY29sb3JTdGVwc1szXSwgY29sb3JTdGVwc1s0XSk7CiAgY29sb3JzWzFdID0gdmVjNChjb2xvclN0ZXBzWzZdLCBjb2xvclN0ZXBzWzddLCBjb2xvclN0ZXBzWzhdLCBjb2xvclN0ZXBzWzldKTsKICBjb2xvcnNbMl0gPSB2ZWM0KGNvbG9yU3RlcHNbMTFdLCBjb2xvclN0ZXBzWzEyXSwgY29sb3JTdGVwc1sxM10sIGNvbG9yU3RlcHNbMTRdKTsKICBjb2xvcnNbM10gPSB2ZWM0KGNvbG9yU3RlcHNbMTZdLCBjb2xvclN0ZXBzWzE3XSwgY29sb3JTdGVwc1sxOF0sIGNvbG9yU3RlcHNbMTldKTsKICBjb2xvcnNbNF0gPSB2ZWM0KGNvbG9yU3RlcHNbMjFdLCBjb2xvclN0ZXBzWzIyXSwgY29sb3JTdGVwc1syM10sIGNvbG9yU3RlcHNbMjRdKTsKICBjb2xvcnNbNV0gPSB2ZWM0KGNvbG9yU3RlcHNbMjZdLCBjb2xvclN0ZXBzWzI3XSwgY29sb3JTdGVwc1syOF0sIGNvbG9yU3RlcHNbMjldKTsKICBjb2xvcnNbNl0gPSB2ZWM0KGNvbG9yU3RlcHNbMzFdLCBjb2xvclN0ZXBzWzMyXSwgY29sb3JTdGVwc1szM10sIGNvbG9yU3RlcHNbMzRdKTsKICBjb2xvcnNbN10gPSB2ZWM0KGNvbG9yU3RlcHNbMzZdLCBjb2xvclN0ZXBzWzM3XSwgY29sb3JTdGVwc1szOF0sIGNvbG9yU3RlcHNbMzldKTsKICAKICBmbG9hdCBzdGVwc1s4XTsKICBzdGVwc1swXSA9IGNvbG9yU3RlcHNbMF07CiAgc3RlcHNbMV0gPSBjb2xvclN0ZXBzWzVdOwogIHN0ZXBzWzJdID0gY29sb3JTdGVwc1sxMF07CiAgc3RlcHNbM10gPSBjb2xvclN0ZXBzWzE1XTsKICBzdGVwc1s0XSA9IGNvbG9yU3RlcHNbMjBdOwogIHN0ZXBzWzVdID0gY29sb3JTdGVwc1syNV07CiAgc3RlcHNbNl0gPSBjb2xvclN0ZXBzWzMwXTsKICBzdGVwc1s3XSA9IGNvbG9yU3RlcHNbMzVdOwoKICBjb2xvciA9IGNvbG9yc1swXTsKICBmb3IgKGludCBpID0gMTsgaSA8IDg7IGkrKykgewogICAgaWYgKHN0ZXBzW2ldIDwgMC4wIHx8IHN0ZXBzW2ldID4gMS4wKSB7CiAgICAgIGJyZWFrOwogICAgfQogICAgaWYoc3RlcHNbaV0gPT0gc3RlcHNbaSAtIDFdKSB7CiAgICAgIGNvbG9yID0gY29sb3JzW2ldOwogICAgfSBlbHNlIHsKICAgICAgY29sb3IgPSBtaXgoY29sb3IsIGNvbG9yc1tpXSwgY2xhbXAoKHQgLSBzdGVwc1tpIC0gMV0pIC8gKHN0ZXBzW2ldIC0gc3RlcHNbaSAtIDFdKSwgMC4wLCAxLjApKTsKICAgIH0KICAgIGlmIChzdGVwc1tpXSA+PSB0KSB7CiAgICAgIGJyZWFrOwogICAgfQogIH0KfQojZW5kaWYKCiNpZmRlZiBGSUxURVIKdm9pZCB0cmFuc2Zvcm1Db2xvcihpbm91dCB2ZWM0IGNvbG9yLCBpbiBmbG9hdCBjb2xvck1hdHJpeFsyMF0pIHsKICBmbG9hdCByID0gY29sb3IuciwgZyA9IGNvbG9yLmcsIGIgPSBjb2xvci5iLCBhID0gY29sb3IuYTsKICBjb2xvclswXSA9IGNvbG9yTWF0cml4WzBdICogciArIGNvbG9yTWF0cml4WzFdICogZyArIGNvbG9yTWF0cml4WzJdICogYiArIGNvbG9yTWF0cml4WzNdICogYSArIGNvbG9yTWF0cml4WzRdOwogIGNvbG9yWzFdID0gY29sb3JNYXRyaXhbNV0gKiByICsgY29sb3JNYXRyaXhbNl0gKiBnICsgY29sb3JNYXRyaXhbN10gKiBiICsgY29sb3JNYXRyaXhbOF0gKiBhICsgY29sb3JNYXRyaXhbOV07CiAgY29sb3JbMl0gPSBjb2xvck1hdHJpeFsxMF0gKiByICsgY29sb3JNYXRyaXhbMTFdICogZyArIGNvbG9yTWF0cml4WzEyXSAqIGIgKyBjb2xvck1hdHJpeFsxM10gKiBhICsgY29sb3JNYXRyaXhbMTRdOwogIGNvbG9yWzNdID0gY29sb3JNYXRyaXhbMTVdICogciArIGNvbG9yTWF0cml4WzE2XSAqIGcgKyBjb2xvck1hdHJpeFsxN10gKiBiICsgY29sb3JNYXRyaXhbMThdICogYSArIGNvbG9yTWF0cml4WzE5XTsKfQojZW5kaWYKCnZvaWQgbWFpbigpIHsKICB2ZWM0IGNvbG9yID0gdkNvbG9yOwogIGZsb2F0IG9wYWNpdHkgPSBhYnMoZmxhZ0JhY2tncm91bmQpOwoKI2lmZGVmIEdSQURJRU5UCiAgaWYodV9ncmFkaWVudFR5cGUgPiAwICYmIGZsYWdCYWNrZ3JvdW5kID4gMC4wIHx8IHVfZ3JhZGllbnRUeXBlID09IDAgJiYgZmxhZ0JhY2tncm91bmQgPD0gMC4wKSB7CiAgICBncmFkaWVudChjb2xvciwgdkdyYWRpZW50VmVjdG9yMSwgdkdyYWRpZW50VmVjdG9yMiwgdV9jb2xvclN0ZXBzKTsKICB9CiNlbmRpZgoKICBpZihvcGFjaXR5IDwgMS4wKSB7CiAgICBjb2xvci5hICo9IG9wYWNpdHk7CiAgfQoKI2lmZGVmIFRFWFRVUkUKICBpZihmbGFnQmFja2dyb3VuZCA+IDAuMCkgewogICAgdmVjMyB0ZXhDb29yZCA9IHZUZXh0dXJlQ29vcmQ7CgogICAgaWYodGV4Q29vcmQueiA9PSAxLjApIHsKICAgICAgdGV4Q29vcmQgPSBmcmFjdCh0ZXhDb29yZCk7CiAgICB9CgogICAgaWYodGV4Q29vcmQueCA8PSAxLjAgJiYgdGV4Q29vcmQueCA+PSAwLjAKICAgICAgJiYgdGV4Q29vcmQueSA8PSAxLjAgJiYgdGV4Q29vcmQueSA+PSAwLjApIHsKICAgICAgaWYodlNvdXJjZVJlY3QueiA+IDAuMCkgewogICAgICAgIHRleENvb3JkLnggPSB2U291cmNlUmVjdC54ICsgdGV4Q29vcmQueCAqIHZTb3VyY2VSZWN0Lno7CiAgICAgICAgdGV4Q29vcmQueSA9IDEuMCAtICh2U291cmNlUmVjdC55ICsgKDEuMCAtIHRleENvb3JkLnkpICogdlNvdXJjZVJlY3Qudyk7CiAgICAgIH0KICAgICAgdmVjNCB0ZXhDb2xvciA9IHRleHR1cmUyRCh1X3RleFNhbXBsZXIsIHRleENvb3JkLnh5KTsKICAgICAgZmxvYXQgYWxwaGEgPSB0ZXhDb2xvci5hOwogICAgICBpZihvcGFjaXR5IDwgMS4wKSB7CiAgICAgICAgdGV4Q29sb3IuYSAqPSBvcGFjaXR5OwogICAgICAgIGFscGhhICo9IG1peCgwLjQ2NSwgMS4wLCBvcGFjaXR5KTsKICAgICAgfQogICAgICAvLyBjb2xvciA9IG1peChjb2xvciwgdGV4Q29sb3IsIHRleENvbG9yLmEpOwogICAgICBjb2xvci5yZ2IgPSBtaXgoY29sb3IucmdiLCB0ZXhDb2xvci5yZ2IsIGFscGhhKTsKICAgICAgLy8gY29sb3IucmdiID0gbWl4KHRleENvbG9yLnJnYiwgY29sb3IucmdiLCBjb2xvci5hKTsKICAgICAgY29sb3IucmdiID0gbWl4KHRleENvbG9yLnJnYiwgY29sb3IucmdiLCBjbGFtcChjb2xvci5hIC8gbWF4KDAuMDAwMSwgdGV4Q29sb3IuYSksIDAuMCwgMS4wKSk7CiAgICAgIGNvbG9yLmEgPSB0ZXhDb2xvci5hICsgKDEuMCAtIHRleENvbG9yLmEpICogY29sb3IuYTsKICAgIH0KICB9CiNlbmRpZgoKI2lmZGVmIEZJTFRFUgogIGlmKHVfZmlsdGVyRmxhZyA+IDApIHsKICAgIHRyYW5zZm9ybUNvbG9yKGNvbG9yLCB1X2NvbG9yTWF0cml4KTsKICB9CiNlbmRpZgoKI2lmZGVmIENMSVBQQVRICiAgZmxvYXQgY2xpcCA9IHRleHR1cmUyRCh1X2NsaXBTYW1wbGVyLCB2Q2xpcFVWKS5yOwogIGNvbG9yICo9IGNsaXA7CiNlbmRpZgoKICBnbF9GcmFnQ29sb3IgPSBjb2xvcjsKfWB9LGZ1bmN0aW9uKGcsZSx0KXt0LnIoZSksZS5kZWZhdWx0PWBhdHRyaWJ1dGUgdmVjMyBhX3ZlcnRleFBvc2l0aW9uOwphdHRyaWJ1dGUgdmVjNCBhX2NvbG9yOwp2YXJ5aW5nIHZlYzQgdkNvbG9yOwp2YXJ5aW5nIGZsb2F0IGZsYWdCYWNrZ3JvdW5kOwphdHRyaWJ1dGUgdmVjMyBhX3RyYW5zZm9ybTA7CmF0dHJpYnV0ZSB2ZWMzIGFfdHJhbnNmb3JtMTsKdW5pZm9ybSB2ZWMyIHVfcmVzb2x1dGlvbjsKdW5pZm9ybSBtYXQzIHZpZXdNYXRyaXg7CnVuaWZvcm0gbWF0MyBwcm9qZWN0aW9uTWF0cml4OwoKI2lmZGVmIFRFWFRVUkUKYXR0cmlidXRlIHZlYzMgYV92ZXJ0ZXhUZXh0dXJlQ29vcmQ7CnZhcnlpbmcgdmVjMyB2VGV4dHVyZUNvb3JkOwphdHRyaWJ1dGUgZmxvYXQgYV9mcmFtZUluZGV4Owp2YXJ5aW5nIGZsb2F0IGZyYW1lSW5kZXg7CmF0dHJpYnV0ZSB2ZWM0IGFfc291cmNlUmVjdDsKdmFyeWluZyB2ZWM0IHZTb3VyY2VSZWN0OwojZW5kaWYKCiNpZmRlZiBDTElQUEFUSAphdHRyaWJ1dGUgdmVjMiBhX2NsaXBVVjsKdmFyeWluZyB2ZWMyIHZDbGlwVVY7CiNlbmRpZgoKI2lmZGVmIENMT1VERklMVEVSCmF0dHJpYnV0ZSB2ZWM0IGFfY29sb3JDbG91ZDA7CmF0dHJpYnV0ZSB2ZWM0IGFfY29sb3JDbG91ZDE7CmF0dHJpYnV0ZSB2ZWM0IGFfY29sb3JDbG91ZDI7CmF0dHJpYnV0ZSB2ZWM0IGFfY29sb3JDbG91ZDM7CmF0dHJpYnV0ZSB2ZWM0IGFfY29sb3JDbG91ZDQ7CnZhcnlpbmcgdmVjNCBjb2xvckNsb3VkMDsKdmFyeWluZyB2ZWM0IGNvbG9yQ2xvdWQxOwp2YXJ5aW5nIHZlYzQgY29sb3JDbG91ZDI7CnZhcnlpbmcgdmVjNCBjb2xvckNsb3VkMzsKdmFyeWluZyB2ZWM0IGNvbG9yQ2xvdWQ0OwojZW5kaWYKCiNpZmRlZiBDTE9VRENPTE9SCmF0dHJpYnV0ZSB2ZWM0IGFfZmlsbENsb3VkQ29sb3I7CmF0dHJpYnV0ZSB2ZWM0IGFfc3Ryb2tlQ2xvdWRDb2xvcjsKI2VuZGlmCgojaWZkZWYgR1JBRElFTlQKdW5pZm9ybSBmbG9hdCB1X3JhZGlhbEdyYWRpZW50VmVjdG9yWzZdOwp2YXJ5aW5nIHZlYzMgdkdyYWRpZW50VmVjdG9yMTsKdmFyeWluZyB2ZWMzIHZHcmFkaWVudFZlY3RvcjI7CiNlbmRpZgoKdm9pZCBtYWluKCkgewogIGdsX1BvaW50U2l6ZSA9IDEuMDsKCiAgbWF0MyBtb2RlbE1hdHJpeCA9IG1hdDMoCiAgICBhX3RyYW5zZm9ybTAueCwgYV90cmFuc2Zvcm0xLngsIDAsIAogICAgYV90cmFuc2Zvcm0wLnksIGFfdHJhbnNmb3JtMS55LCAwLAogICAgYV90cmFuc2Zvcm0wLnosIGFfdHJhbnNmb3JtMS56LCAxCiAgKTsKCiAgdmVjMyBwb3MgPSBwcm9qZWN0aW9uTWF0cml4ICogdmlld01hdHJpeCAqIG1vZGVsTWF0cml4ICogdmVjMyhhX3ZlcnRleFBvc2l0aW9uLnh5LCAxLjApOwogIGdsX1Bvc2l0aW9uID0gdmVjNChwb3MueHksIDEuMCwgMS4wKTsKCiNpZmRlZiBHUkFESUVOVAogIHZlYzMgdmcxID0gdmlld01hdHJpeCAqIHZlYzModV9yYWRpYWxHcmFkaWVudFZlY3RvclswXSwgdV9yYWRpYWxHcmFkaWVudFZlY3RvclsxXSwgMS4wKTsKICB2ZWMzIHZnMiA9IHZpZXdNYXRyaXggKiB2ZWMzKHVfcmFkaWFsR3JhZGllbnRWZWN0b3JbM10sIHVfcmFkaWFsR3JhZGllbnRWZWN0b3JbNF0sIDEuMCk7CiAgZmxvYXQgaCA9IHVfcmVzb2x1dGlvbi55OwogIHZnMS55ID0gaCAtIHZnMS55OwogIHZnMi55ID0gaCAtIHZnMi55OwogIHZHcmFkaWVudFZlY3RvcjEgPSB2ZWMzKHZnMS54eSwgdV9yYWRpYWxHcmFkaWVudFZlY3RvclsyXSk7CiAgdkdyYWRpZW50VmVjdG9yMiA9IHZlYzModmcyLnh5LCB1X3JhZGlhbEdyYWRpZW50VmVjdG9yWzVdKTsKI2VuZGlmCiAgCiAgZmxhZ0JhY2tncm91bmQgPSBhX3ZlcnRleFBvc2l0aW9uLno7CgojaWZkZWYgQ0xPVURDT0xPUgogIGlmKGZsYWdCYWNrZ3JvdW5kID4gMC4wKSB7CiAgICB2Q29sb3IgPSBtaXgoYV9jb2xvciwgYV9maWxsQ2xvdWRDb2xvciwgYV9maWxsQ2xvdWRDb2xvci5hKTsKICB9IGVsc2UgewogICAgdkNvbG9yID0gbWl4KGFfY29sb3IsIGFfc3Ryb2tlQ2xvdWRDb2xvciwgYV9zdHJva2VDbG91ZENvbG9yLmEpOwogIH0KI2Vsc2UKICB2Q29sb3IgPSBhX2NvbG9yOwojZW5kaWYKCiNpZmRlZiBURVhUVVJFCiAgdlRleHR1cmVDb29yZCA9IGFfdmVydGV4VGV4dHVyZUNvb3JkOwogIGZyYW1lSW5kZXggPSBhX2ZyYW1lSW5kZXg7CiAgdlNvdXJjZVJlY3QgPSBhX3NvdXJjZVJlY3Q7CiNlbmRpZgoKI2lmZGVmIENMSVBQQVRICiAgdkNsaXBVViA9IGFfY2xpcFVWOwojZW5kaWYKCiNpZmRlZiBDTE9VREZJTFRFUgogIGNvbG9yQ2xvdWQwID0gYV9jb2xvckNsb3VkMDsKICBjb2xvckNsb3VkMSA9IGFfY29sb3JDbG91ZDE7CiAgY29sb3JDbG91ZDIgPSBhX2NvbG9yQ2xvdWQyOwogIGNvbG9yQ2xvdWQzID0gYV9jb2xvckNsb3VkMzsKICBjb2xvckNsb3VkNCA9IGFfY29sb3JDbG91ZDQ7CiNlbmRpZgp9YH0sZnVuY3Rpb24oZyxlLHQpe3QucihlKSxlLmRlZmF1bHQ9YHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0OwoKdmFyeWluZyB2ZWM0IHZDb2xvcjsKdmFyeWluZyBmbG9hdCBmbGFnQmFja2dyb3VuZDsKCiNpZmRlZiBURVhUVVJFCnZhcnlpbmcgZmxvYXQgZnJhbWVJbmRleDsKdmFyeWluZyB2ZWMzIHZUZXh0dXJlQ29vcmQ7CnZhcnlpbmcgdmVjNCB2U291cmNlUmVjdDsKI2VuZGlmCgojaWZkZWYgQ0xJUFBBVEgKdmFyeWluZyB2ZWMyIHZDbGlwVVY7CiNlbmRpZgoKI2lmZGVmIEZJTFRFUgp1bmlmb3JtIGludCB1X2ZpbHRlckZsYWc7CnVuaWZvcm0gZmxvYXQgdV9jb2xvck1hdHJpeFsyMF07CiNlbmRpZgoKI2lmZGVmIENMT1VERklMVEVSCnZhcnlpbmcgdmVjNCBjb2xvckNsb3VkMDsKdmFyeWluZyB2ZWM0IGNvbG9yQ2xvdWQxOwp2YXJ5aW5nIHZlYzQgY29sb3JDbG91ZDI7CnZhcnlpbmcgdmVjNCBjb2xvckNsb3VkMzsKdmFyeWluZyB2ZWM0IGNvbG9yQ2xvdWQ0OwojZW5kaWYKCiNpZmRlZiBHUkFESUVOVAp2YXJ5aW5nIHZlYzMgdkdyYWRpZW50VmVjdG9yMTsKdmFyeWluZyB2ZWMzIHZHcmFkaWVudFZlY3RvcjI7CnVuaWZvcm0gZmxvYXQgdV9jb2xvclN0ZXBzWzQwXTsKdW5pZm9ybSBpbnQgdV9ncmFkaWVudFR5cGU7Cgp2b2lkIGdyYWRpZW50KGlub3V0IHZlYzQgY29sb3IsIHZlYzMgZ3YxLCB2ZWMzIGd2MiwgZmxvYXQgY29sb3JTdGVwc1s0MF0pIHsKICBmbG9hdCB0OwogIC8vIGNlbnRlciBjaXJjbGUgcmFkaXVzCiAgZmxvYXQgY3IgPSBndjEuejsKICAvLyBmb2NhbCBjaXJjbGUgcmFkaXVzCiAgZmxvYXQgZnIgPSBndjIuejsKCiAgaWYoY3IgPiAwLjAgfHwgZnIgPiAwLjApIHsKICAgIC8vIHJhZGlhbCBncmFkaWVudAogICAgdmVjMiBjZW50ZXIgPSBndjEueHk7CiAgICB2ZWMyIGZvY2FsID0gZ3YyLnh5OwogICAgZmxvYXQgeCA9IGZvY2FsLnggLSBnbF9GcmFnQ29vcmQueDsKICAgIGZsb2F0IHkgPSBmb2NhbC55IC0gZ2xfRnJhZ0Nvb3JkLnk7CiAgICBmbG9hdCBkeCA9IGZvY2FsLnggLSBjZW50ZXIueDsKICAgIGZsb2F0IGR5ID0gZm9jYWwueSAtIGNlbnRlci55OwogICAgZmxvYXQgZHIgPSBjciAtIGZyOwogICAgZmxvYXQgYSA9IGR4ICogZHggKyBkeSAqIGR5IC0gZHIgKiBkcjsKICAgIGZsb2F0IGIgPSAtMi4wICogKHkgKiBkeSArIHggKiBkeCArIGZyICogZHIpOwogICAgZmxvYXQgYyA9IHggKiB4ICsgeSAqIHkgLSBmciAqIGZyOwogICAgdCA9IDEuMCAtIDAuNSAqICgxLjAgLyBhKSAqICgtYiArIHNxcnQoYiAqIGIgLSA0LjAgKiBhICogYykpOwogIH0gZWxzZSB7CiAgICAvLyBsaW5lYXIgZ3JhZGllbnQKICAgIHZlYzIgdjEgPSBnbF9GcmFnQ29vcmQueHkgLSBndjEueHk7CiAgICB2ZWMyIHYyID0gZ3YyLnh5IC0gZ3YxLnh5OwogICAgdCA9ICh2MS54ICogdjIueCArIHYxLnkgKiB2Mi55KSAvICh2Mi54ICogdjIueCArIHYyLnkgKiB2Mi55KTsKICB9CgogIHZlYzQgY29sb3JzWzhdOwogIGNvbG9yc1swXSA9IHZlYzQoY29sb3JTdGVwc1sxXSwgY29sb3JTdGVwc1syXSwgY29sb3JTdGVwc1szXSwgY29sb3JTdGVwc1s0XSk7CiAgY29sb3JzWzFdID0gdmVjNChjb2xvclN0ZXBzWzZdLCBjb2xvclN0ZXBzWzddLCBjb2xvclN0ZXBzWzhdLCBjb2xvclN0ZXBzWzldKTsKICBjb2xvcnNbMl0gPSB2ZWM0KGNvbG9yU3RlcHNbMTFdLCBjb2xvclN0ZXBzWzEyXSwgY29sb3JTdGVwc1sxM10sIGNvbG9yU3RlcHNbMTRdKTsKICBjb2xvcnNbM10gPSB2ZWM0KGNvbG9yU3RlcHNbMTZdLCBjb2xvclN0ZXBzWzE3XSwgY29sb3JTdGVwc1sxOF0sIGNvbG9yU3RlcHNbMTldKTsKICBjb2xvcnNbNF0gPSB2ZWM0KGNvbG9yU3RlcHNbMjFdLCBjb2xvclN0ZXBzWzIyXSwgY29sb3JTdGVwc1syM10sIGNvbG9yU3RlcHNbMjRdKTsKICBjb2xvcnNbNV0gPSB2ZWM0KGNvbG9yU3RlcHNbMjZdLCBjb2xvclN0ZXBzWzI3XSwgY29sb3JTdGVwc1syOF0sIGNvbG9yU3RlcHNbMjldKTsKICBjb2xvcnNbNl0gPSB2ZWM0KGNvbG9yU3RlcHNbMzFdLCBjb2xvclN0ZXBzWzMyXSwgY29sb3JTdGVwc1szM10sIGNvbG9yU3RlcHNbMzRdKTsKICBjb2xvcnNbN10gPSB2ZWM0KGNvbG9yU3RlcHNbMzZdLCBjb2xvclN0ZXBzWzM3XSwgY29sb3JTdGVwc1szOF0sIGNvbG9yU3RlcHNbMzldKTsKICAKICBmbG9hdCBzdGVwc1s4XTsKICBzdGVwc1swXSA9IGNvbG9yU3RlcHNbMF07CiAgc3RlcHNbMV0gPSBjb2xvclN0ZXBzWzVdOwogIHN0ZXBzWzJdID0gY29sb3JTdGVwc1sxMF07CiAgc3RlcHNbM10gPSBjb2xvclN0ZXBzWzE1XTsKICBzdGVwc1s0XSA9IGNvbG9yU3RlcHNbMjBdOwogIHN0ZXBzWzVdID0gY29sb3JTdGVwc1syNV07CiAgc3RlcHNbNl0gPSBjb2xvclN0ZXBzWzMwXTsKICBzdGVwc1s3XSA9IGNvbG9yU3RlcHNbMzVdOwoKICBjb2xvciA9IGNvbG9yc1swXTsKICBmb3IgKGludCBpID0gMTsgaSA8IDg7IGkrKykgewogICAgaWYgKHN0ZXBzW2ldIDwgMC4wIHx8IHN0ZXBzW2ldID4gMS4wKSB7CiAgICAgIGJyZWFrOwogICAgfQogICAgaWYoc3RlcHNbaV0gPT0gc3RlcHNbaSAtIDFdKSB7CiAgICAgIGNvbG9yID0gY29sb3JzW2ldOwogICAgfSBlbHNlIHsKICAgICAgY29sb3IgPSBtaXgoY29sb3IsIGNvbG9yc1tpXSwgY2xhbXAoKHQgLSBzdGVwc1tpIC0gMV0pIC8gKHN0ZXBzW2ldIC0gc3RlcHNbaSAtIDFdKSwgMC4wLCAxLjApKTsKICAgIH0KICAgIGlmIChzdGVwc1tpXSA+PSB0KSB7CiAgICAgIGJyZWFrOwogICAgfQogIH0KfQojZW5kaWYKCnZvaWQgdHJhbnNmb3JtQ29sb3IoaW5vdXQgdmVjNCBjb2xvciwgaW4gZmxvYXQgY29sb3JNYXRyaXhbMjBdKSB7CiAgZmxvYXQgciA9IGNvbG9yLnIsIGcgPSBjb2xvci5nLCBiID0gY29sb3IuYiwgYSA9IGNvbG9yLmE7CiAgY29sb3JbMF0gPSBjb2xvck1hdHJpeFswXSAqIHIgKyBjb2xvck1hdHJpeFsxXSAqIGcgKyBjb2xvck1hdHJpeFsyXSAqIGIgKyBjb2xvck1hdHJpeFszXSAqIGEgKyBjb2xvck1hdHJpeFs0XTsKICBjb2xvclsxXSA9IGNvbG9yTWF0cml4WzVdICogciArIGNvbG9yTWF0cml4WzZdICogZyArIGNvbG9yTWF0cml4WzddICogYiArIGNvbG9yTWF0cml4WzhdICogYSArIGNvbG9yTWF0cml4WzldOwogIGNvbG9yWzJdID0gY29sb3JNYXRyaXhbMTBdICogciArIGNvbG9yTWF0cml4WzExXSAqIGcgKyBjb2xvck1hdHJpeFsxMl0gKiBiICsgY29sb3JNYXRyaXhbMTNdICogYSArIGNvbG9yTWF0cml4WzE0XTsKICBjb2xvclszXSA9IGNvbG9yTWF0cml4WzE1XSAqIHIgKyBjb2xvck1hdHJpeFsxNl0gKiBnICsgY29sb3JNYXRyaXhbMTddICogYiArIGNvbG9yTWF0cml4WzE4XSAqIGEgKyBjb2xvck1hdHJpeFsxOV07Cn0KCiNpZmRlZiBDTE9VREZJTFRFUgp2b2lkIGJ1aWxkQ2xvdWRDb2xvcihpbm91dCBmbG9hdCBjb2xvckNsb3VkTWF0cml4WzIwXSkgewogIGNvbG9yQ2xvdWRNYXRyaXhbMF0gPSBjb2xvckNsb3VkMFswXTsKICBjb2xvckNsb3VkTWF0cml4WzFdID0gY29sb3JDbG91ZDFbMF07CiAgY29sb3JDbG91ZE1hdHJpeFsyXSA9IGNvbG9yQ2xvdWQyWzBdOwogIGNvbG9yQ2xvdWRNYXRyaXhbM10gPSBjb2xvckNsb3VkM1swXTsKICBjb2xvckNsb3VkTWF0cml4WzRdID0gY29sb3JDbG91ZDRbMF07CgogIGNvbG9yQ2xvdWRNYXRyaXhbNV0gPSBjb2xvckNsb3VkMFsxXTsKICBjb2xvckNsb3VkTWF0cml4WzZdID0gY29sb3JDbG91ZDFbMV07CiAgY29sb3JDbG91ZE1hdHJpeFs3XSA9IGNvbG9yQ2xvdWQyWzFdOwogIGNvbG9yQ2xvdWRNYXRyaXhbOF0gPSBjb2xvckNsb3VkM1sxXTsKICBjb2xvckNsb3VkTWF0cml4WzldID0gY29sb3JDbG91ZDRbMV07CgogIGNvbG9yQ2xvdWRNYXRyaXhbMTBdID0gY29sb3JDbG91ZDBbMl07CiAgY29sb3JDbG91ZE1hdHJpeFsxMV0gPSBjb2xvckNsb3VkMVsyXTsKICBjb2xvckNsb3VkTWF0cml4WzEyXSA9IGNvbG9yQ2xvdWQyWzJdOwogIGNvbG9yQ2xvdWRNYXRyaXhbMTNdID0gY29sb3JDbG91ZDNbMl07CiAgY29sb3JDbG91ZE1hdHJpeFsxNF0gPSBjb2xvckNsb3VkNFsyXTsKCiAgY29sb3JDbG91ZE1hdHJpeFsxNV0gPSBjb2xvckNsb3VkMFszXTsKICBjb2xvckNsb3VkTWF0cml4WzE2XSA9IGNvbG9yQ2xvdWQxWzNdOwogIGNvbG9yQ2xvdWRNYXRyaXhbMTddID0gY29sb3JDbG91ZDJbM107CiAgY29sb3JDbG91ZE1hdHJpeFsxOF0gPSBjb2xvckNsb3VkM1szXTsKICBjb2xvckNsb3VkTWF0cml4WzE5XSA9IGNvbG9yQ2xvdWQ0WzNdOwp9CiNlbmRpZgoKdm9pZCBtYWluKCkgewogIHZlYzQgY29sb3IgPSB2Q29sb3I7CiAgZmxvYXQgb3BhY2l0eSA9IGFicyhmbGFnQmFja2dyb3VuZCk7CgojaWZkZWYgR1JBRElFTlQKICBpZih1X2dyYWRpZW50VHlwZSA+IDAgJiYgZmxhZ0JhY2tncm91bmQgPiAwLjAgfHwgdV9ncmFkaWVudFR5cGUgPT0gMCAmJiBmbGFnQmFja2dyb3VuZCA8PSAwLjApIHsKICAgIGdyYWRpZW50KGNvbG9yLCB2R3JhZGllbnRWZWN0b3IxLCB2R3JhZGllbnRWZWN0b3IyLCB1X2NvbG9yU3RlcHMpOwogIH0KI2VuZGlmCgogIGlmKG9wYWNpdHkgPCAxLjApIHsKICAgIGNvbG9yLmEgKj0gb3BhY2l0eTsKICB9CgojaWZkZWYgVEVYVFVSRQogIGlmKGZsYWdCYWNrZ3JvdW5kID4gMC4wKSB7CiAgICB2ZWMzIHRleENvb3JkID0gdlRleHR1cmVDb29yZDsKCiAgICBpZih0ZXhDb29yZC56ID09IDEuMCkgewogICAgICB0ZXhDb29yZCA9IGZyYWN0KHRleENvb3JkKTsKICAgIH0KCiAgICBpZih0ZXhDb29yZC54IDw9IDEuMCAmJiB0ZXhDb29yZC54ID49IDAuMAogICAgICAmJiB0ZXhDb29yZC55IDw9IDEuMCAmJiB0ZXhDb29yZC55ID49IDAuMCkgewogICAgICBpZih2U291cmNlUmVjdC56ID4gMC4wKSB7CiAgICAgICAgdGV4Q29vcmQueCA9IHZTb3VyY2VSZWN0LnggKyB0ZXhDb29yZC54ICogdlNvdXJjZVJlY3QuejsKICAgICAgICB0ZXhDb29yZC55ID0gMS4wIC0gKHZTb3VyY2VSZWN0LnkgKyAoMS4wIC0gdGV4Q29vcmQueSkgKiB2U291cmNlUmVjdC53KTsKICAgICAgfQogICAgICBpZihmcmFtZUluZGV4IDwgMC4wKSB7CiAgICAgICAgdmVjNCB0ZXhDb2xvciA9IHRleHR1cmUyRCh1X3RleFNhbXBsZXIsIHRleENvb3JkLnh5KTsKICAgICAgICBjb2xvciA9IG1peChjb2xvciwgdGV4Q29sb3IsIHRleENvbG9yLmEpOwogICAgICB9IGVsc2UgewogICAgICAgIGludCBpbmRleCA9IGludChmbG9vcihjbGFtcCgwLjAsIDExLjAsIGZyYW1lSW5kZXgpKSk7CiAgICAgICAgdmVjNCB0ZXhDb2xvcjsKICAgICAgICBpZihpbmRleCA9PSAwKSB0ZXhDb2xvciA9IHRleHR1cmUyRCh1X3RleEZyYW1lMCwgdGV4Q29vcmQueHkpOwogICAgICAgIGVsc2UgaWYoaW5kZXggPT0gMSkgdGV4Q29sb3IgPSB0ZXh0dXJlMkQodV90ZXhGcmFtZTEsIHRleENvb3JkLnh5KTsKICAgICAgICBlbHNlIGlmKGluZGV4ID09IDIpIHRleENvbG9yID0gdGV4dHVyZTJEKHVfdGV4RnJhbWUyLCB0ZXhDb29yZC54eSk7CiAgICAgICAgZWxzZSBpZihpbmRleCA9PSAzKSB0ZXhDb2xvciA9IHRleHR1cmUyRCh1X3RleEZyYW1lMywgdGV4Q29vcmQueHkpOwogICAgICAgIGVsc2UgaWYoaW5kZXggPT0gNCkgdGV4Q29sb3IgPSB0ZXh0dXJlMkQodV90ZXhGcmFtZTQsIHRleENvb3JkLnh5KTsKICAgICAgICBlbHNlIGlmKGluZGV4ID09IDUpIHRleENvbG9yID0gdGV4dHVyZTJEKHVfdGV4RnJhbWU1LCB0ZXhDb29yZC54eSk7CiAgICAgICAgZWxzZSBpZihpbmRleCA9PSA2KSB0ZXhDb2xvciA9IHRleHR1cmUyRCh1X3RleEZyYW1lNiwgdGV4Q29vcmQueHkpOwogICAgICAgIGVsc2UgaWYoaW5kZXggPT0gNykgdGV4Q29sb3IgPSB0ZXh0dXJlMkQodV90ZXhGcmFtZTcsIHRleENvb3JkLnh5KTsKICAgICAgICBlbHNlIGlmKGluZGV4ID09IDgpIHRleENvbG9yID0gdGV4dHVyZTJEKHVfdGV4RnJhbWU4LCB0ZXhDb29yZC54eSk7CiAgICAgICAgZWxzZSBpZihpbmRleCA9PSA5KSB0ZXhDb2xvciA9IHRleHR1cmUyRCh1X3RleEZyYW1lOSwgdGV4Q29vcmQueHkpOwogICAgICAgIGVsc2UgaWYoaW5kZXggPT0gMTApIHRleENvbG9yID0gdGV4dHVyZTJEKHVfdGV4RnJhbWUxMCwgdGV4Q29vcmQueHkpOwogICAgICAgIGVsc2UgdGV4Q29sb3IgPSB0ZXh0dXJlMkQodV90ZXhGcmFtZTExLCB0ZXhDb29yZC54eSk7CiAgICAgICAgZmxvYXQgYWxwaGEgPSB0ZXhDb2xvci5hOwogICAgICAgIGlmKG9wYWNpdHkgPCAxLjApIHsKICAgICAgICAgIHRleENvbG9yLmEgKj0gb3BhY2l0eTsKICAgICAgICAgIGFscGhhICo9IG1peCgwLjQ2NSwgMS4wLCBvcGFjaXR5KTsKICAgICAgICB9CiAgICAgICAgLy8gY29sb3IgPSBtaXgoY29sb3IsIHRleENvbG9yLCB0ZXhDb2xvci5hKTsKICAgICAgICBjb2xvci5yZ2IgPSBtaXgoY29sb3IucmdiLCB0ZXhDb2xvci5yZ2IsIGFscGhhKTsKICAgICAgICAvLyBjb2xvci5yZ2IgPSBtaXgodGV4Q29sb3IucmdiLCBjb2xvci5yZ2IsIGNvbG9yLmEpOwogICAgICAgIGNvbG9yLnJnYiA9IG1peCh0ZXhDb2xvci5yZ2IsIGNvbG9yLnJnYiwgY2xhbXAoY29sb3IuYSAvIG1heCgwLjAwMDEsIHRleENvbG9yLmEpLCAwLjAsIDEuMCkpOwogICAgICAgIGNvbG9yLmEgPSB0ZXhDb2xvci5hICsgKDEuMCAtIHRleENvbG9yLmEpICogY29sb3IuYTsKICAgICAgfQogICAgfQogIH0KI2VuZGlmCgojaWZkZWYgRklMVEVSCiAgaWYodV9maWx0ZXJGbGFnID4gMCkgewogICAgdHJhbnNmb3JtQ29sb3IoY29sb3IsIHVfY29sb3JNYXRyaXgpOwogIH0KI2VuZGlmCgojaWZkZWYgQ0xPVURGSUxURVIKICBmbG9hdCBjb2xvckNsb3VkTWF0cml4WzIwXTsKICBidWlsZENsb3VkQ29sb3IoY29sb3JDbG91ZE1hdHJpeCk7CiAgdHJhbnNmb3JtQ29sb3IoY29sb3IsIGNvbG9yQ2xvdWRNYXRyaXgpOwojZW5kaWYKCiNpZmRlZiBDTElQUEFUSAogIGZsb2F0IGNsaXAgPSB0ZXh0dXJlMkQodV9jbGlwU2FtcGxlciwgdkNsaXBVVikucjsKICBjb2xvciAqPSBjbGlwOwojZW5kaWYKCiAgZ2xfRnJhZ0NvbG9yID0gY29sb3I7Cn1gfSxmdW5jdGlvbihnLGUsdCl7dC5yKGUpLChmdW5jdGlvbihuLGkpe3QuZChlLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLGZ1bmN0aW9uKCl7cmV0dXJuIGh9KSx0LmQoZSwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLGZ1bmN0aW9uKCl7cmV0dXJuIHV9KSx0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gZigpe2lmKHR5cGVvZiBwZXJmb3JtYW5jZTwidSImJnBlcmZvcm1hbmNlLm5vdylyZXR1cm4gcGVyZm9ybWFuY2Uubm93KCk7aWYodHlwZW9mIG48InUiJiZuLmhydGltZSl7Y29uc3RbYSxkXT1uLmhydGltZSgpO3JldHVybiBhKjFlMytkKjFlLTZ9cmV0dXJuIERhdGUubm93P0RhdGUubm93KCk6bmV3IERhdGUoKS5nZXRUaW1lKCl9bGV0IGgsdTt0eXBlb2YgaTwidSImJnR5cGVvZiBpLnJlcXVlc3RBbmltYXRpb25GcmFtZT09ImZ1bmN0aW9uIj8oaD1pLnJlcXVlc3RBbmltYXRpb25GcmFtZSx1PWkuY2FuY2VsQW5pbWF0aW9uRnJhbWUpOihoPWZ1bmN0aW9uKGEpe3JldHVybiBzZXRUaW1lb3V0KCgpPT57YShmKCkpfSwxNil9LHU9ZnVuY3Rpb24oYSl7cmV0dXJuIGNsZWFyVGltZW91dChhKX0pfSkuY2FsbCh0aGlzLHQoNjkpLHQoMjIpKX0sZnVuY3Rpb24oZyxlKXt2YXIgdD1nLmV4cG9ydHM9e30sbixpO2Z1bmN0aW9uIGYoKXt0aHJvdyBuZXcgRXJyb3IoInNldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQiKX1mdW5jdGlvbiBoKCl7dGhyb3cgbmV3IEVycm9yKCJjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQiKX0oZnVuY3Rpb24oKXt0cnl7dHlwZW9mIHNldFRpbWVvdXQ9PSJmdW5jdGlvbiI/bj1zZXRUaW1lb3V0Om49Zn1jYXRjaHtuPWZ9dHJ5e3R5cGVvZiBjbGVhclRpbWVvdXQ9PSJmdW5jdGlvbiI/aT1jbGVhclRpbWVvdXQ6aT1ofWNhdGNoe2k9aH19KSgpO2Z1bmN0aW9uIHUoUyl7aWYobj09PXNldFRpbWVvdXQpcmV0dXJuIHNldFRpbWVvdXQoUywwKTtpZigobj09PWZ8fCFuKSYmc2V0VGltZW91dClyZXR1cm4gbj1zZXRUaW1lb3V0LHNldFRpbWVvdXQoUywwKTt0cnl7cmV0dXJuIG4oUywwKX1jYXRjaHt0cnl7cmV0dXJuIG4uY2FsbChudWxsLFMsMCl9Y2F0Y2h7cmV0dXJuIG4uY2FsbCh0aGlzLFMsMCl9fX1mdW5jdGlvbiBhKFMpe2lmKGk9PT1jbGVhclRpbWVvdXQpcmV0dXJuIGNsZWFyVGltZW91dChTKTtpZigoaT09PWh8fCFpKSYmY2xlYXJUaW1lb3V0KXJldHVybiBpPWNsZWFyVGltZW91dCxjbGVhclRpbWVvdXQoUyk7dHJ5e3JldHVybiBpKFMpfWNhdGNoe3RyeXtyZXR1cm4gaS5jYWxsKG51bGwsUyl9Y2F0Y2h7cmV0dXJuIGkuY2FsbCh0aGlzLFMpfX19dmFyIGQ9W10sRT0hMSxwLE89LTE7ZnVuY3Rpb24gbSgpeyFFfHwhcHx8KEU9ITEscC5sZW5ndGg/ZD1wLmNvbmNhdChkKTpPPS0xLGQubGVuZ3RoJiZiKCkpfWZ1bmN0aW9uIGIoKXtpZighRSl7dmFyIFM9dShtKTtFPSEwO2Zvcih2YXIgcz1kLmxlbmd0aDtzOyl7Zm9yKHA9ZCxkPVtdOysrTzxzOylwJiZwW09dLnJ1bigpO089LTEscz1kLmxlbmd0aH1wPW51bGwsRT0hMSxhKFMpfX10Lm5leHRUaWNrPWZ1bmN0aW9uKFMpe3ZhciBzPW5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoLTEpO2lmKGFyZ3VtZW50cy5sZW5ndGg+MSlmb3IodmFyIGM9MTtjPGFyZ3VtZW50cy5sZW5ndGg7YysrKXNbYy0xXT1hcmd1bWVudHNbY107ZC5wdXNoKG5ldyBNKFMscykpLGQubGVuZ3RoPT09MSYmIUUmJnUoYil9O2Z1bmN0aW9uIE0oUyxzKXt0aGlzLmZ1bj1TLHRoaXMuYXJyYXk9c31NLnByb3RvdHlwZS5ydW49ZnVuY3Rpb24oKXt0aGlzLmZ1bi5hcHBseShudWxsLHRoaXMuYXJyYXkpfSx0LnRpdGxlPSJicm93c2VyIix0LmJyb3dzZXI9ITAsdC5lbnY9e30sdC5hcmd2PVtdLHQudmVyc2lvbj0iIix0LnZlcnNpb25zPXt9O2Z1bmN0aW9uIHkoKXt9dC5vbj15LHQuYWRkTGlzdGVuZXI9eSx0Lm9uY2U9eSx0Lm9mZj15LHQucmVtb3ZlTGlzdGVuZXI9eSx0LnJlbW92ZUFsbExpc3RlbmVycz15LHQuZW1pdD15LHQucHJlcGVuZExpc3RlbmVyPXksdC5wcmVwZW5kT25jZUxpc3RlbmVyPXksdC5saXN0ZW5lcnM9ZnVuY3Rpb24oUyl7cmV0dXJuW119LHQuYmluZGluZz1mdW5jdGlvbihTKXt0aHJvdyBuZXcgRXJyb3IoInByb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkIil9LHQuY3dkPWZ1bmN0aW9uKCl7cmV0dXJuIi8ifSx0LmNoZGlyPWZ1bmN0aW9uKFMpe3Rocm93IG5ldyBFcnJvcigicHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkIil9LHQudW1hc2s9ZnVuY3Rpb24oKXtyZXR1cm4gMH19LGZ1bmN0aW9uKGcsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIEx9KTt2YXIgbj10KDEpLGk9dCg3MSksZj10KDczKSxoPXQoMjEzKSx1PXQoMjE0KSxhPXQoMjE1KSxkPXQoMjE2KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gRShOLEEpe3ZhciB3PU9iamVjdC5rZXlzKE4pO2lmKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpe3ZhciBCPU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoTik7QSYmKEI9Qi5maWx0ZXIoZnVuY3Rpb24oRCl7cmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTixEKS5lbnVtZXJhYmxlfSkpLHcucHVzaC5hcHBseSh3LEIpfXJldHVybiB3fWZ1bmN0aW9uIHAoTil7Zm9yKHZhciBBPTE7QTxhcmd1bWVudHMubGVuZ3RoO0ErKyl7dmFyIHc9YXJndW1lbnRzW0FdIT1udWxsP2FyZ3VtZW50c1tBXTp7fTtBJTI/RShPYmplY3QodyksITApLmZvckVhY2goZnVuY3Rpb24oQil7TyhOLEIsd1tCXSl9KTpPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycz9PYmplY3QuZGVmaW5lUHJvcGVydGllcyhOLE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHcpKTpFKE9iamVjdCh3KSkuZm9yRWFjaChmdW5jdGlvbihCKXtPYmplY3QuZGVmaW5lUHJvcGVydHkoTixCLE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodyxCKSl9KX1yZXR1cm4gTn1mdW5jdGlvbiBPKE4sQSx3KXtyZXR1cm4gQSBpbiBOP09iamVjdC5kZWZpbmVQcm9wZXJ0eShOLEEse3ZhbHVlOncsZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTpOW0FdPXcsTn1jb25zdCBtPVN5bWJvbC5mb3IoInNwcml0ZWpzX2NoYW5nZWRBdHRycyIpLGI9U3ltYm9sLmZvcigic3ByaXRlanNfYXR0cmlidXRlcyIpLE09U3ltYm9sKCJyZXNvbHV0aW9uIikseT1TeW1ib2woImFuaW1hdGlvbnMiKSxTPVN5bWJvbCgiZXZlbnRMaXN0ZW5lcnMiKSxzPVN5bWJvbCgiY2FwdHVyZUV2ZW50TGlzdGVuZXJzIiksYz1TeW1ib2woImZpbHRlcnMiKSxsPVN5bWJvbCgiZGlzcGxheSIpLHY9U3ltYm9sKCJwcm9ncmFtIiksVD1TeW1ib2woInNoYWRlckF0dHJzIiksUj1TeW1ib2woInVuaWZvcm1zIik7Y2xhc3MgTHtjb25zdHJ1Y3RvcihBPXt9KXt0aGlzLmF0dHJpYnV0ZXM9bmV3IHRoaXMuY29uc3RydWN0b3IuQXR0cih0aGlzKSx0aGlzW01dPXt3aWR0aDozMDAsaGVpZ2h0OjE1MH0sT2JqZWN0LmFzc2lnbih0aGlzLmF0dHJpYnV0ZXMsQSksdGhpc1t5XT1uZXcgU2V0LHRoaXNbU109e30sdGhpc1tzXT17fX1nZXQgYW5jZXN0b3JzKCl7bGV0IEE9dGhpcy5wYXJlbnQ7Y29uc3Qgdz1bXTtmb3IoO0E7KXcucHVzaChBKSxBPUEucGFyZW50O3JldHVybiB3fWdldCBhbmltYXRpb25zKCl7cmV0dXJuIHRoaXNbeV19Z2V0IGZpbHRlcnMoKXtyZXR1cm4gdGhpc1tjXXx8dGhpcy5wYXJlbnQmJnRoaXMucGFyZW50LmZpbHRlcnN9Z2V0IGlzVmlzaWJsZSgpe3JldHVybiExfWdldCBsYXllcigpe3JldHVybiB0aGlzLnBhcmVudD90aGlzLnBhcmVudC5sYXllcjpudWxsfWdldCBsb2NhbE1hdHJpeCgpe2NvbnN0IEE9dGhpcy50cmFuc2Zvcm1NYXRyaXgse3g6dyx5OkJ9PXRoaXMuYXR0cmlidXRlcztyZXR1cm4gQVs0XSs9dyxBWzVdKz1CLEF9Z2V0IG9wYWNpdHkoKXtsZXQgQT10aGlzLmF0dHJpYnV0ZXMub3BhY2l0eTtyZXR1cm4gdGhpcy5wYXJlbnQmJnRoaXMucGFyZW50Lm9wYWNpdHkhPW51bGwmJihBKj10aGlzLnBhcmVudC5vcGFjaXR5KSxBfWdldCBwYXJlbnROb2RlKCl7cmV0dXJuIHRoaXMucGFyZW50fWdldCBuZXh0U2libGluZygpe3JldHVybiB0aGlzLmdldE5vZGVOZWFyQnkoMSl9Z2V0IHByZXZpb3VzU2libGluZygpe3JldHVybiB0aGlzLmdldE5vZGVOZWFyQnkoLTEpfWdldCBwcm9ncmFtKCl7cmV0dXJuIHRoaXNbdl19Z2V0IHJlbmRlcmVyKCl7cmV0dXJuIHRoaXMucGFyZW50P3RoaXMucGFyZW50LnJlbmRlcmVyOm51bGx9Z2V0IHJlbmRlck1hdHJpeCgpe2lmKHRoaXMuX19jYWNoZVJlbmRlck1hdHJpeClyZXR1cm4gdGhpcy5fX2NhY2hlUmVuZGVyTWF0cml4O2xldCBBPXRoaXMubG9jYWxNYXRyaXg7Y29uc3Qgdz10aGlzLnBhcmVudDtpZih3KXtjb25zdCBCPXcuX19jYWNoZVJlbmRlck1hdHJpeHx8dy5yZW5kZXJNYXRyaXg7QiYmKEE9bi5tYXQyZC5tdWx0aXBseShBcnJheS5vZigwLDAsMCwwLDAsMCksQixBKSl9cmV0dXJuIEF9Z2V0IHdvcmxkU2NhbGluZygpe2NvbnN0IEE9dGhpcy5yZW5kZXJNYXRyaXg7cmV0dXJuW01hdGguaHlwb3QoQVswXSxBWzFdKSxNYXRoLmh5cG90KEFbMl0sQVszXSldfWdldCB3b3JsZFJvdGF0aW9uKCl7Y29uc3QgQT10aGlzLnJlbmRlck1hdHJpeDtyZXR1cm4gTWF0aC5hdGFuMihBWzFdLEFbM10pfWdldCB3b3JsZFBvc2l0aW9uKCl7Y29uc3QgQT10aGlzLnJlbmRlck1hdHJpeDtyZXR1cm5bQVs0XSxBWzVdXX1nZXQgdW5pZm9ybXMoKXtyZXR1cm4gdGhpc1tSXX1nZXQgY2xhc3NOYW1lKCl7cmV0dXJuIHRoaXMuYXR0cmlidXRlcy5jbGFzc05hbWV9c2V0IGNsYXNzTmFtZShBKXt0aGlzLmF0dHJpYnV0ZXMuY2xhc3NOYW1lPUF9Z2V0IGlkKCl7cmV0dXJuIHRoaXMuYXR0cmlidXRlcy5pZH1zZXQgaWQoQSl7dGhpcy5hdHRyaWJ1dGVzLmlkPUF9Z2V0IG5hbWUoKXtyZXR1cm4gdGhpcy5hdHRyaWJ1dGVzLm5hbWV9c2V0IG5hbWUoQSl7dGhpcy5hdHRyaWJ1dGVzLm5hbWU9QX1nZXQgekluZGV4KCl7cmV0dXJuIHRoaXMuYXR0cmlidXRlcy56SW5kZXh9c2V0IHpJbmRleChBKXt0aGlzLmF0dHJpYnV0ZXMuekluZGV4PUF9Z2V0IG1lc2goKXtyZXR1cm4gbnVsbH1nZXQgc2hhZGVyQXR0cnMoKXtyZXR1cm4gdGhpc1tUXXx8e319YWN0aXZhdGVBbmltYXRpb25zKCl7Y29uc3QgQT10aGlzLmxheWVyO2lmKEEpe2NvbnN0IHc9dGhpc1t5XTt3LmZvckVhY2goRD0+e0QuYmFzZVRpbWVsaW5lPUEudGltZWxpbmUsRC5wbGF5KCksRC5maW5pc2hlZC50aGVuKCgpPT57dy5kZWxldGUoRCl9KX0pO2NvbnN0IEI9dGhpcy5jaGlsZHJlbjtCJiZCLmZvckVhY2goRD0+e0QuYWN0aXZhdGVBbmltYXRpb25zJiZELmFjdGl2YXRlQW5pbWF0aW9ucygpfSl9fWFkZEV2ZW50TGlzdGVuZXIoQSx3LEI9e30pe0E9PT0ibW91c2V3aGVlbCImJihBPSJ3aGVlbCIpLHR5cGVvZiBCPT0iYm9vbGVhbiImJihCPXtjYXB0dXJlOkJ9KTtjb25zdHtjYXB0dXJlOkQsb25jZTpJfT1CLGo9RD9zOlM7cmV0dXJuIHRoaXNbal1bQV09dGhpc1tqXVtBXXx8W10sdGhpc1tqXVtBXS5wdXNoKHtsaXN0ZW5lcjp3LG9uY2U6SX0pLHRoaXN9YW5pbWF0ZShBLHcpe2NvbnN0IEI9bmV3IGYuZGVmYXVsdCh0aGlzLEEsdyk7cmV0dXJuIHRoaXMuZWZmZWN0cyYmQi5hcHBseUVmZmVjdHModGhpcy5lZmZlY3RzKSx0aGlzLmxheWVyJiYoQi5iYXNlVGltZWxpbmU9dGhpcy5sYXllci50aW1lbGluZSxCLnBsYXkoKSxCLmZpbmlzaGVkLnRoZW4oKCk9Pnt0aGlzW3ldLmRlbGV0ZShCKX0pKSx0aGlzW3ldLmFkZChCKSxCfWF0dHIoLi4uQSl7aWYoQS5sZW5ndGg9PT0wKXJldHVybiB0aGlzLmF0dHJpYnV0ZXNbYl07aWYoQS5sZW5ndGg+MSl7bGV0W3csQl09QTtyZXR1cm4gdHlwZW9mIEI9PSJmdW5jdGlvbiImJihCPUIodGhpcy5hdHRyKHcpKSksdGhpcy5zZXRBdHRyaWJ1dGUodyxCKSx0aGlzfXJldHVybiB0eXBlb2YgQVswXT09InN0cmluZyI/dGhpcy5nZXRBdHRyaWJ1dGUoQVswXSk6KE9iamVjdC5hc3NpZ24odGhpcy5hdHRyaWJ1dGVzLEFbMF0pLHRoaXMpfWNsb25lTm9kZSgpe2NvbnN0IEE9bmV3IHRoaXMuY29uc3RydWN0b3Isdz10aGlzLmF0dHJpYnV0ZXNbbV07cmV0dXJuIEEuYXR0cih3KSxBfWNvbm5lY3QoQSx3KXtPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywicGFyZW50Iix7dmFsdWU6QSx3cml0YWJsZTohMSxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiek9yZGVyIix7dmFsdWU6dyx3cml0YWJsZTohMSxjb25maWd1cmFibGU6ITB9KSxBLnRpbWVsaW5lJiZ0aGlzLmFjdGl2YXRlQW5pbWF0aW9ucygpLHRoaXMuc2V0UmVzb2x1dGlvbihBLmdldFJlc29sdXRpb24oKSksdGhpcy5mb3JjZVVwZGF0ZSgpLHRoaXMuZGlzcGF0Y2hFdmVudCh7dHlwZToiYXBwZW5kIixkZXRhaWw6e3BhcmVudDpBLHpPcmRlcjp3fX0pfWNvbnRhaW5zKEEpe2Zvcig7QSYmdGhpcyE9PUE7KUE9QS5wYXJlbnQ7cmV0dXJuISFBfWRlYWN0aXZhdGVBbmltYXRpb25zKCl7dGhpc1t5XS5mb3JFYWNoKHc9PncuY2FuY2VsKCkpO2NvbnN0IEE9dGhpcy5jaGlsZHJlbjtBJiZBLmZvckVhY2godz0+e3cuZGVhY3RpdmF0ZUFuaW1hdGlvbnMmJncuZGVhY3RpdmF0ZUFuaW1hdGlvbnMoKX0pfWRpc2Nvbm5lY3QoKXtjb25zdHtwYXJlbnQ6QSx6T3JkZXI6d309dGhpcztkZWxldGUgdGhpcy5wYXJlbnQsZGVsZXRlIHRoaXMuek9yZGVyLHRoaXMuZGVhY3RpdmF0ZUFuaW1hdGlvbnMoKSx0aGlzLmRpc3BhdGNoRXZlbnQoe3R5cGU6InJlbW92ZSIsZGV0YWlsOntwYXJlbnQ6QSx6T3JkZXI6d319KSxBJiZBLmZvcmNlVXBkYXRlKCl9ZGlzcGF0Y2hFdmVudChBKXtBIGluc3RhbmNlb2YgdS5kZWZhdWx0fHwoQT1uZXcgdS5kZWZhdWx0KEEpKSxBLnRhcmdldD10aGlzO2xldCB3PUEudHlwZTt3PT09Im1vdXNld2hlZWwiJiYodz0id2hlZWwiKTtjb25zdCBCPVt0aGlzXTtsZXQgRD10aGlzLnBhcmVudDtmb3IoO0EuYnViYmxlcyYmRDspQi5wdXNoKEQpLEQ9RC5wYXJlbnQ7Zm9yKGxldCBJPUIubGVuZ3RoLTE7ST49MDtJLS0pe2NvbnN0IGo9QltJXSxWPWpbc10mJmpbc11bd107aWYoViYmVi5sZW5ndGgmJihBLmN1cnJlbnRUYXJnZXQ9aixWLmZvckVhY2goKHtsaXN0ZW5lcjpKLG9uY2U6X30pPT57Si5jYWxsKHRoaXMsQSksXyYmQi5yZW1vdmVFdmVudExpc3RlbmVyKEopfSksZGVsZXRlIEEuY3VycmVudFRhcmdldCksIUEuYnViYmxlcyYmQS5jYW5jZWxCdWJibGUpYnJlYWt9aWYoIUEuY2FuY2VsQnViYmxlKWZvcihsZXQgST0wO0k8Qi5sZW5ndGg7SSsrKXtjb25zdCBqPUJbSV0sVj1qW1NdJiZqW1NdW3ddO2lmKFYmJlYubGVuZ3RoJiYoQS5jdXJyZW50VGFyZ2V0PWosVi5mb3JFYWNoKCh7bGlzdGVuZXI6SixvbmNlOl99KT0+e0ouY2FsbCh0aGlzLEEpLF8mJkIucmVtb3ZlRXZlbnRMaXN0ZW5lcihKKX0pLGRlbGV0ZSBBLmN1cnJlbnRUYXJnZXQpLCFBLmJ1YmJsZXN8fEEuY2FuY2VsQnViYmxlKWJyZWFrfX1kaXNwYXRjaFBvaW50ZXJFdmVudChBKXtjb25zdHtsYXllclg6dyxsYXllclk6Qn09QTtyZXR1cm4gdGhpcy5pc1BvaW50Q29sbGlzaW9uKHcsQik/KHRoaXMuZGlzcGF0Y2hFdmVudChBKSwhMCk6ITF9ZHJhdyhBPVtdKXtjb25zdCB3PXRoaXMubWVzaDtpZih3KXtpZihPYmplY3QoYS5hcHBseUZpbHRlcnMpKHcsdGhpcy5maWx0ZXJzKSxBLnB1c2godyksdGhpc1t2XSl7dy5zZXRQcm9ncmFtKHRoaXNbdl0pO2NvbnN0IEI9dGhpc1tUXTtCJiZPYmplY3QuZW50cmllcyhCKS5mb3JFYWNoKChbSSxqXSk9Pnt3LnNldEF0dHJpYnV0ZShJLGopfSk7Y29uc3QgRD10aGlzW1JdO2lmKHRoaXNbUl0pe2NvbnN0IEk9e307T2JqZWN0LmVudHJpZXMoRCkuZm9yRWFjaCgoW2osVl0pPT57dHlwZW9mIFY9PSJmdW5jdGlvbiImJihWPVYodGhpcyxqKSksSVtqXT1WfSksdy5zZXRVbmlmb3JtcyhJKX19T2JqZWN0KGQuZGVmYXVsdCkodGhpcyx3KX1yZXR1cm4gQX1mb3JjZVVwZGF0ZSgpe3RoaXMucGFyZW50JiZ0aGlzLnBhcmVudC5mb3JjZVVwZGF0ZSgpfWdldEF0dHJpYnV0ZShBKXtyZXR1cm4gdGhpcy5hdHRyaWJ1dGVzW0FdfWdldExpc3RlbmVycyhBLHtjYXB0dXJlOnc9ITF9PXt9KXtyZXR1cm5bLi4udGhpc1t3P3M6U11bQV18fFtdXX1nZXROb2RlTmVhckJ5KEE9MSl7aWYoIXRoaXMucGFyZW50KXJldHVybiBudWxsO2lmKEE9PT0wKXJldHVybiB0aGlzO2NvbnN0IHc9dGhpcy5wYXJlbnQuY2hpbGRyZW4sQj13LmluZGV4T2YodGhpcyk7cmV0dXJuIHdbQitBXX1nZXRXb3JsZFBvc2l0aW9uKEEsdyl7Y29uc3QgQj10aGlzLnJlbmRlck1hdHJpeCxEPUEqQlswXSt3KkJbMl0rQls0XSxJPUEqQlsxXSt3KkJbM10rQls1XTtyZXR1cm5bRCxJXX1nZXRPZmZzZXRQb3NpdGlvbihBLHcpe2NvbnN0IEI9bi5tYXQyZC5pbnZlcnQoQXJyYXkub2YoMCwwLDAsMCwwLDApLHRoaXMucmVuZGVyTWF0cml4KSxEPUEqQlswXSt3KkJbMl0rQls0XSxJPUEqQlsxXSt3KkJbM10rQls1XTtyZXR1cm5bRCxJXX1nZXRSZXNvbHV0aW9uKCl7cmV0dXJuIHAoe30sdGhpc1tNXSl9aXNQb2ludENvbGxpc2lvbihBLHcpe2lmKCF0aGlzLm1lc2gpcmV0dXJuITE7Y29uc3QgQj10aGlzLmF0dHJpYnV0ZXMucG9pbnRlckV2ZW50cztpZihCPT09Im5vbmUifHxCIT09ImFsbCImJiF0aGlzLmlzVmlzaWJsZSlyZXR1cm4hMTtsZXQgRD0iYm90aCI7cmV0dXJuIEI9PT0idmlzaWJsZUZpbGwiJiYoRD0iZmlsbCIpLEI9PT0idmlzaWJsZVN0cm9rZSImJihEPSJzdHJva2UiKSx0aGlzLm1lc2guaXNQb2ludENvbGxpc2lvbihBLHcsRCl9b25Qcm9wZXJ0eUNoYW5nZShBLHcsQil7QSE9PSJpZCImJkEhPT0ibmFtZSImJkEhPT0iY2xhc3NOYW1lIiYmQSE9PSJwb2ludGVyRXZlbnRzIiYmQSE9PSJwYXNzRXZlbnRzIiYmdGhpcy5mb3JjZVVwZGF0ZSgpLEE9PT0iZmlsdGVyIiYmKHRoaXNbY109T2JqZWN0KGEucGFyc2VGaWx0ZXJTdHJpbmcpKHcpKSxBPT09InpJbmRleCImJnRoaXMucGFyZW50JiZ0aGlzLnBhcmVudC5yZW9yZGVyKCl9c2V0QXR0cmlidXRlKEEsdyl7QT09PSJhdHRycyImJnRoaXMuYXR0cih3KSx0aGlzLmF0dHJpYnV0ZXNbQV09d31zZXRNb3VzZUNhcHR1cmUoKXt0aGlzLmxheWVyJiYodGhpcy5sYXllci5fX21vdXNlQ2FwdHVyZWRUYXJnZXQ9dGhpcyl9c2V0UHJvZ3JhbShBKXt0aGlzW3ZdPUEsdGhpcy5mb3JjZVVwZGF0ZSgpfXNldFNoYWRlckF0dHJpYnV0ZShBLHcpe3RoaXNbVF09dGhpc1tUXXx8e30sdGhpc1tUXVtBXT13LHRoaXMuZm9yY2VVcGRhdGUoKX1zZXRVbmlmb3JtcyhBKXt0aGlzW1JdPXRoaXNbUl18fHt9LE9iamVjdC5hc3NpZ24odGhpc1tSXSxBKSx0aGlzLmZvcmNlVXBkYXRlKCl9c2V0UmVzb2x1dGlvbih7d2lkdGg6QSxoZWlnaHQ6d30pe2NvbnN0e3dpZHRoOkIsaGVpZ2h0OkR9PXRoaXNbTV07KEIhPT1BfHxEIT09dykmJih0aGlzW01dPXt3aWR0aDpBLGhlaWdodDp3fSx0aGlzLmZvcmNlVXBkYXRlKCksdGhpcy5kaXNwYXRjaEV2ZW50KHt0eXBlOiJyZXNvbHV0aW9uY2hhbmdlIixkZXRhaWw6e3dpZHRoOkEsaGVpZ2h0Ond9fSkpfXNob3coKXt0aGlzLmF0dHJpYnV0ZXMuZGlzcGxheT09PSJub25lIiYmKHRoaXMuYXR0cmlidXRlcy5kaXNwbGF5PXRoaXNbbF18fCIiKX1oaWRlKCl7dGhpcy5hdHRyaWJ1dGVzLmRpc3BsYXkhPT0ibm9uZSImJih0aGlzW2xdPXRoaXMuYXR0cmlidXRlcy5kaXNwbGF5LHRoaXMuYXR0cmlidXRlcy5kaXNwbGF5PSJub25lIil9cmVsZWFzZU1vdXNlQ2FwdHVyZSgpe3RoaXMubGF5ZXImJnRoaXMubGF5ZXIuX19tb3VzZUNhcHR1cmVkVGFyZ2V0PT09dGhpcyYmKHRoaXMubGF5ZXIuX19tb3VzZUNhcHR1cmVkVGFyZ2V0PW51bGwpfXJlbW92ZSgpe3JldHVybiB0aGlzLnBhcmVudCYmdGhpcy5wYXJlbnQucmVtb3ZlQ2hpbGQ/KHRoaXMucGFyZW50LnJlbW92ZUNoaWxkKHRoaXMpLCEwKTohMX1yZW1vdmVBbGxMaXN0ZW5lcnMoQSx3PXt9KXt0eXBlb2Ygdz09ImJvb2xlYW4iJiYodz17Y2FwdHVyZTp3fSk7Y29uc3QgRD13LmNhcHR1cmU/czpTO3JldHVybiB0aGlzW0RdW0FdJiYodGhpc1tEXVtBXT1bXSksdGhpc31yZW1vdmVBdHRyaWJ1dGUoQSl7dGhpcy5zZXRBdHRyaWJ1dGUoQSxudWxsKX1yZW1vdmVFdmVudExpc3RlbmVyKEEsdyxCPXt9KXt0eXBlb2YgQj09ImJvb2xlYW4iJiYoQj17Y2FwdHVyZTpCfSk7Y29uc3QgST1CLmNhcHR1cmU/czpTO2lmKHRoaXNbSV1bQV0pe2NvbnN0IGo9dGhpc1tJXVtBXTtpZihqKWZvcihsZXQgVj0wO1Y8ai5sZW5ndGg7VisrKXtjb25zdHtsaXN0ZW5lcjpKfT1qW1ZdO2lmKEo9PT13KXt0aGlzW0ldW0FdLnNwbGljZShWLDEpO2JyZWFrfX19cmV0dXJuIHRoaXN9dHJhbnNpdGlvbihBLHc9ImxpbmVhciIpe2NvbnN0IEI9dGhpcyxEPVN5bWJvbCgiYW5pbWF0aW9uIik7dz13fHwibGluZWFyIjtsZXQgST0wO3JldHVybiB0eXBlb2YgQT09Im9iamVjdCImJihJPUEuZGVsYXl8fDAsQT1BLmR1cmF0aW9uKSx7W0RdOm51bGwsY2FuY2VsKGo9ITEpe2NvbnN0IFY9dGhpc1tEXTtWJiZWLmNhbmNlbChqKX0sZW5kKCl7Y29uc3Qgaj10aGlzW0RdO2omJihqLnBsYXlTdGF0ZT09PSJydW5uaW5nInx8ai5wbGF5U3RhdGU9PT0icGVuZGluZyIpJiZqLmZpbmlzaCgpfSxyZXZlcnNlKCl7Y29uc3Qgaj10aGlzW0RdO2lmKGopaWYoai5wbGF5U3RhdGU9PT0icnVubmluZyJ8fGoucGxheVN0YXRlPT09InBlbmRpbmciKWoucGxheWJhY2tSYXRlPS1qLnBsYXliYWNrUmF0ZTtlbHNle2NvbnN0IFY9ai50aW1pbmcuZGlyZWN0aW9uO2oudGltaW5nLmRpcmVjdGlvbj1WPT09InJldmVyc2UiPyJub3JtYWwiOiJyZXZlcnNlIixqLnBsYXkoKX1yZXR1cm4gai5maW5pc2hlZH0sYXR0cihqLFYpe3JldHVybiB0aGlzLmVuZCgpLHR5cGVvZiBqPT0ic3RyaW5nIiYmKGo9e1tqXTpWfSksT2JqZWN0LmVudHJpZXMoaikuZm9yRWFjaCgoW0osX10pPT57dHlwZW9mIF89PSJmdW5jdGlvbiImJihqW0pdPV8oQi5hdHRyKEopKSl9KSx0aGlzW0RdPUIuYW5pbWF0ZShbal0se2R1cmF0aW9uOkEqMWUzLGRlbGF5OkkqMWUzLGZpbGw6ImZvcndhcmRzIixlYXNpbmc6d30pLHRoaXNbRF0uZmluaXNoZWR9fX11cGRhdGVDb250b3Vycygpe319TyhMLCJBdHRyIixpLmRlZmF1bHQpLGguZGVmYXVsdC5yZWdpc3Rlck5vZGUoTCwibm9kZSIpfSxmdW5jdGlvbihnLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBMfSk7dmFyIG49dCgxKSxpPXQoMTIpLGY9dCg3Mik7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IGg9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlRGVmYXVsdCIpLHU9U3ltYm9sLmZvcigic3ByaXRlanNfZGVjbGFyZUFsaWFzIiksYT1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGUiKSxkPVN5bWJvbC5mb3IoInNwcml0ZWpzX2dldEF0dHJpYnV0ZSIpLEU9U3ltYm9sLmZvcigic3ByaXRlanNfYXR0cmlidXRlcyIpLHA9U3ltYm9sLmZvcigic3ByaXRlanNfY2hhbmdlZEF0dHJzIiksTz1TeW1ib2woInN1YmplY3QiKSxtPVN5bWJvbCgiYXR0ciIpLGI9U3ltYm9sKCJkZWZhdWx0IiksTT1TeW1ib2woImFsaWFzIik7ZnVuY3Rpb24geShOLFtBLHddKXtsZXQgQj1uLm1hdDJkLmZyb21WYWx1ZXMoMSwwLDAsMSwwLDApO3JldHVyblsuLi5OXS5mb3JFYWNoKChbRCxJXSk9PntpZigoQXx8dykmJihCPW4ubWF0MmQudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxCLFtBLHddKSksRD09PSJtYXRyaXgiKUI9bi5tYXQyZC5tdWx0aXBseShCLEIsSSk7ZWxzZSBpZihEPT09Im9mZnNldFRyYW5zbGF0ZSIpQls0XSs9SVswXSxCWzVdKz1JWzFdO2Vsc2UgaWYoRD09PSJvZmZzZXRSb3RhdGUiKUI9bi5tYXQyZC5yb3RhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDApLEIsSSk7ZWxzZSBpZihEPT09InNrZXciKXtjb25zdFtqLFZdPUk7Qj1uLm1hdDJkLm11bHRpcGx5KEIsQixuLm1hdDJkLmZyb21WYWx1ZXMoMSxNYXRoLnRhbihWKSxNYXRoLnRhbihqKSwxLDAsMCkpfWVsc2Ugbi5tYXQyZFtEXShCLEIsSSk7KEF8fHcpJiYoQj1uLm1hdDJkLnRyYW5zbGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCksQixbLUEsLXddKSl9KSxCfWNvbnN0IFM9U3ltYm9sKCJ0cmFuc2Zvcm1NYXRyaXgiKSxzPVN5bWJvbCgidHJhbnNmb3JtcyIpLGM9U3ltYm9sKCJjaGFuZ2VkQXR0cnMiKSxsPVN5bWJvbCgibGFzdENoYW5nZWRBdHRyIiksdj1TeW1ib2woIm9mZnNldEZpZ3VyZSIpO2Z1bmN0aW9uIFQoTixBLHcpe2NvbnN0IEI9TlttXVtBXTtpZihOW2FdKEEsdywhMSl8fE5bbF0hPT1BKXtjb25zdCBJPU5bc107SS5oYXMoQSkmJkkuZGVsZXRlKEEpLHcmJihBPT09InJvdGF0ZSImJih3PU1hdGguUEkqdy8xODApLEE9PT0ic2NhbGUiJiYodz13Lm1hcChqPT5NYXRoLmFicyhqKT4xZS01P2o6MS9qPjA/MWUtNTotMWUtNSkpLEkuc2V0KEEsdykpLE5bU109bnVsbCxOW09dLm9uUHJvcGVydHlDaGFuZ2UoQSx3LEIsTil9fWZ1bmN0aW9uIFIoTil7Y29uc3QgQT1OW3ZdLHc9Ti5vZmZzZXREaXN0YW5jZSpBLmdldFRvdGFsTGVuZ3RoKCksQj1BLmdldFBvaW50QXRMZW5ndGgodyk7aWYoQil7Y29uc3QgRD1OW3NdO2xldCBJPU4ub2Zmc2V0Um90YXRlO0k9PT0iYXV0byI/ST1CLmFuZ2xlOkk9PT0icmV2ZXJzZSI/ST1NYXRoLlBJK0IuYW5nbGU6ST1NYXRoLlBJKkkvMTgwLEQuc2V0KCJvZmZzZXRSb3RhdGUiLEkpLEQuc2V0KCJvZmZzZXRUcmFuc2xhdGUiLFtCLngsQi55XSksTltTXT1udWxsfX1jbGFzcyBMe3N0YXRpYyBzZXREZWZhdWx0KEEsLi4udyl7cmV0dXJuIEFbaF0oLi4udyl9c3RhdGljIGRlY2xhcmVBbGlhcyhBLC4uLncpe3JldHVybiBBW3VdKC4uLncpfXN0YXRpYyBzZXRBdHRyaWJ1dGUoQSwuLi53KXtyZXR1cm4gQVthXSguLi53KX1zdGF0aWMgZ2V0QXR0cmlidXRlKEEsLi4udyl7cmV0dXJuIEFbZF0oLi4udyl9c3RhdGljIGdldEF0dHJpYnV0ZXMoQSl7cmV0dXJuIEFbRV19c3RhdGljIGdldENoYW5nZWRBdHRyaWJ1dGVzKEEpe3JldHVybiBBW3BdfWNvbnN0cnVjdG9yKEEpe3RoaXNbT109QSx0aGlzW21dPXt9LHRoaXNbU109bi5tYXQyZC5mcm9tVmFsdWVzKDEsMCwwLDEsMCwwKSx0aGlzW3NdPW5ldyBNYXAsdGhpc1tiXT17fSx0aGlzW01dPVtdLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBLCJ0cmFuc2Zvcm1NYXRyaXgiLHtnZXQ6KCk9Pih0aGlzW1NdfHwodGhpc1tTXT15KHRoaXNbc10sdGhpcy50cmFuc2Zvcm1PcmlnaW4pKSxbLi4udGhpc1tTXV0pfSksdGhpc1toXSh7aWQ6IiIsbmFtZToiIixjbGFzc05hbWU6IiIseDowLHk6MCx0cmFuc2Zvcm1PcmlnaW46WzAsMF0sdHJhbnNmb3JtOiIiLHRyYW5zbGF0ZTpbMCwwXSxyb3RhdGU6MCxzY2FsZTpbMSwxXSxza2V3OlswLDBdLG9wYWNpdHk6MSx6SW5kZXg6MCxvZmZzZXRQYXRoOnZvaWQgMCxvZmZzZXREaXN0YW5jZTowLG9mZnNldFJvdGF0ZToiYXV0byIscG9pbnRlckV2ZW50czoidmlzaWJsZSIsZmlsdGVyOiJub25lIixkaXNwbGF5OiIifSksdGhpc1t1XSgiY2xhc3MiLCJwb3MiKSx0aGlzW2NdPW5ldyBTZXQsdGhpc1t2XT1uZXcgaS5GaWd1cmUyRCh7c2NhbGU6NSxzaW1wbGlmeTowfSl9Z2V0W3BdKCl7Y29uc3QgQT17fTtyZXR1cm5bLi4udGhpc1tjXV0uZm9yRWFjaCh3PT57QVt3XT10aGlzW21dW3ddfSksQX1nZXRbRV0oKXtjb25zdCBBPU9iamVjdC5hc3NpZ24oe30sdGhpc1ttXSk7Zm9yKGxldCB3PTA7dzx0aGlzW01dLmxlbmd0aDt3Kyspe2NvbnN0IEI9dGhpc1tNXVt3XTtBW0JdPXRoaXNbQl19cmV0dXJuIEF9W2hdKEEpe09iamVjdC5hc3NpZ24odGhpc1tiXSxBKSxPYmplY3QuYXNzaWduKHRoaXNbbV0sQSl9W3VdKC4uLkEpe3RoaXNbTV0ucHVzaCguLi5BKX1bYV0oQSx3LEI9ITApe2NvbnN0IEQ9dGhpc1ttXVtBXSxJPXRoaXNbT107cmV0dXJuIHc9PW51bGwmJih3PXRoaXNbYl1bQV0pLE9iamVjdChmLmNvbXBhcmVWYWx1ZSkoRCx3KT8hMToodGhpc1ttXVtBXT13LHRoaXNbY10uaGFzKEEpJiZ0aGlzW2NdLmRlbGV0ZShBKSx0aGlzW2NdLmFkZChBKSx0aGlzW2xdPUEsQiYmSS5vblByb3BlcnR5Q2hhbmdlKEEsdyxELHRoaXMpLCEwKX1bZF0oQSl7cmV0dXJuIHRoaXNbbV1bQV19c2V0IGlkKEEpe3RoaXNbYV0oImlkIixBKX1nZXQgaWQoKXtyZXR1cm4gdGhpc1tkXSgiaWQiKX1zZXQgbmFtZShBKXt0aGlzW2FdKCJuYW1lIixBKX1nZXQgbmFtZSgpe3JldHVybiB0aGlzW2RdKCJuYW1lIil9c2V0IGNsYXNzTmFtZShBKXt0aGlzW2FdKCJjbGFzc05hbWUiLEEpfWdldCBjbGFzc05hbWUoKXtyZXR1cm4gdGhpc1tkXSgiY2xhc3NOYW1lIil9c2V0IGNsYXNzKEEpe3RoaXMuY2xhc3NOYW1lPUF9Z2V0IGNsYXNzKCl7cmV0dXJuIHRoaXMuY2xhc3NOYW1lfWdldCB4KCl7cmV0dXJuIHRoaXNbZF0oIngiKX1zZXQgeChBKXt0aGlzW2FdKCJ4IixPYmplY3QoZi50b051bWJlcikoQSkpfWdldCB5KCl7cmV0dXJuIHRoaXNbZF0oInkiKX1zZXQgeShBKXt0aGlzW2FdKCJ5IixPYmplY3QoZi50b051bWJlcikoQSkpfWdldCBwb3MoKXtyZXR1cm5bdGhpcy54LHRoaXMueV19c2V0IHBvcyhBKXtBPU9iamVjdChmLnRvQXJyYXkpKEEpLEFycmF5LmlzQXJyYXkoQSl8fChBPVtBLEFdKSx0aGlzLng9QVswXSx0aGlzLnk9QVsxXX1nZXQgdHJhbnNmb3JtKCl7cmV0dXJuIHRoaXNbZF0oInRyYW5zZm9ybSIpfXNldCB0cmFuc2Zvcm0oQSl7bGV0IHc9bnVsbDtpZihBcnJheS5pc0FycmF5KEEpJiYodz1BLEE9YG1hdHJpeCgke0EubWFwKGYudG9OdW1iZXIpLmpvaW4oKX0pYCksdHlwZW9mIEE9PSJzdHJpbmciKUE9QS5yZXBsYWNlKC9ccyosXHMqL2csIiwiKTtlbHNlIGlmKEEhPW51bGwpdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCB0cmFuc2Zvcm0gdmFsdWUuIik7Y29uc3QgQj10aGlzW21dLnRyYW5zZm9ybTtpZih0aGlzW2FdKCJ0cmFuc2Zvcm0iLEEsITEpKXtjb25zdCBEPXRoaXNbc107aWYoRC5oYXMoIm1hdHJpeCIpJiZELmRlbGV0ZSgibWF0cml4IiksdylELnNldCgibWF0cml4Iix3KTtlbHNlIGlmKEEpe2NvbnN0IEk9QS5tYXRjaCgvKG1hdHJpeHx0cmFuc2xhdGV8cm90YXRlfHNjYWxlfHNrZXcpXChbXigpXStcKS9nKTtpZihJKXtsZXQgaj1uLm1hdDJkLmZyb21WYWx1ZXMoMSwwLDAsMSwwLDApO2ZvcihsZXQgVj0wO1Y8SS5sZW5ndGg7VisrKXtjb25zdCBfPUlbVl0ubWF0Y2goL14obWF0cml4fHRyYW5zbGF0ZXxyb3RhdGV8c2NhbGV8c2tldylcKChbXigpXSspXCkvKTtpZihfKXtsZXRbLHN0LEddPV87c3Q9PT0icm90YXRlIj9HPU1hdGguUEkqcGFyc2VGbG9hdChHKS8xODA6Rz1HLnRyaW0oKS5zcGxpdCgvW1xzLF0rLykubWFwKFk9Pk9iamVjdChmLnRvTnVtYmVyKShZKSksc3Q9PT0ibWF0cml4Ij9qPW4ubWF0MmQubXVsdGlwbHkoaixqLEcpOnN0PT09InNrZXciP2o9bi5tYXQyZC5tdWx0aXBseShqLGosbi5tYXQyZC5mcm9tVmFsdWVzKDEsTWF0aC50YW4oR1sxXSksTWF0aC50YW4oR1swXSksMSwwLDApKTpuLm1hdDJkW3N0XShqLGosRyksRC5zZXQoIm1hdHJpeCIsail9fX1lbHNlIHRocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgdHJhbnNmb3JtIHZhbHVlLiIpfXRoaXNbU109bnVsbCx0aGlzW09dLm9uUHJvcGVydHlDaGFuZ2UoInRyYW5zZm9ybSIsQSxCLHRoaXMpfX1nZXQgdHJhbnNmb3JtT3JpZ2luKCl7cmV0dXJuIHRoaXNbZF0oInRyYW5zZm9ybU9yaWdpbiIpfXNldCB0cmFuc2Zvcm1PcmlnaW4oQSl7QT1PYmplY3QoZi50b0FycmF5KShBLCEwKSxBIT1udWxsJiYhQXJyYXkuaXNBcnJheShBKSYmKEE9W0EsQV0pLHRoaXNbYV0oInRyYW5zZm9ybU9yaWdpbiIsQSkmJih0aGlzW1NdPW51bGwpfWdldCByb3RhdGUoKXtyZXR1cm4gdGhpc1tkXSgicm90YXRlIil9c2V0IHJvdGF0ZShBKXtUKHRoaXMsInJvdGF0ZSIsQSl9Z2V0IHRyYW5zbGF0ZSgpe3JldHVybiB0aGlzW2RdKCJ0cmFuc2xhdGUiKX1zZXQgdHJhbnNsYXRlKEEpe0E9T2JqZWN0KGYudG9BcnJheSkoQSwhMCksQSE9bnVsbCYmIUFycmF5LmlzQXJyYXkoQSkmJihBPVtBLEFdKSxUKHRoaXMsInRyYW5zbGF0ZSIsQSl9Z2V0IHNjYWxlKCl7cmV0dXJuIHRoaXNbZF0oInNjYWxlIil9c2V0IHNjYWxlKEEpe0E9T2JqZWN0KGYudG9BcnJheSkoQSwhMCksQSE9bnVsbCYmIUFycmF5LmlzQXJyYXkoQSkmJihBPVtBLEFdKSxUKHRoaXMsInNjYWxlIixBKX1nZXQgc2tldygpe3JldHVybiB0aGlzW2RdKCJza2V3Iil9c2V0IHNrZXcoQSl7QT1PYmplY3QoZi50b0FycmF5KShBLCEwKSxBIT1udWxsJiYhQXJyYXkuaXNBcnJheShBKSYmKEE9W0EsQV0pLFQodGhpcywic2tldyIsQSl9Z2V0IG9wYWNpdHkoKXtyZXR1cm4gdGhpc1tkXSgib3BhY2l0eSIpfXNldCBvcGFjaXR5KEEpe0EhPW51bGwmJihBPU51bWJlcihBKSksdGhpc1thXSgib3BhY2l0eSIsQSl9Z2V0IHpJbmRleCgpe3JldHVybiB0aGlzW2RdKCJ6SW5kZXgiKX1zZXQgekluZGV4KEEpe0EhPW51bGwmJihBPU51bWJlcihBKSksdGhpc1thXSgiekluZGV4IixBKX1nZXQgb2Zmc2V0UGF0aCgpe3JldHVybiB0aGlzW2RdKCJvZmZzZXRQYXRoIil9c2V0IG9mZnNldFBhdGgoQSl7dGhpc1thXSgib2Zmc2V0UGF0aCIsQSkmJih0aGlzW3ZdLmJlZ2luUGF0aCgpLEEhPW51bGwmJnRoaXNbdl0uYWRkUGF0aChBKSxSKHRoaXMpKX1nZXQgb2Zmc2V0RGlzdGFuY2UoKXtyZXR1cm4gdGhpc1tkXSgib2Zmc2V0RGlzdGFuY2UiKX1zZXQgb2Zmc2V0RGlzdGFuY2UoQSl7dGhpc1thXSgib2Zmc2V0RGlzdGFuY2UiLE9iamVjdChmLnRvTnVtYmVyKShBKSkmJlIodGhpcyl9Z2V0IG9mZnNldFJvdGF0ZSgpe3JldHVybiB0aGlzW2RdKCJvZmZzZXRSb3RhdGUiKX1zZXQgb2Zmc2V0Um90YXRlKEEpe3RoaXNbYV0oIm9mZnNldFJvdGF0ZSIsQSksUih0aGlzKX1nZXQgcG9pbnRlckV2ZW50cygpe3JldHVybiB0aGlzW2RdKCJwb2ludGVyRXZlbnRzIil9c2V0IHBvaW50ZXJFdmVudHMoQSl7aWYoQSE9bnVsbCYmQSE9PSJub25lIiYmQSE9PSJ2aXNpYmxlIiYmQSE9PSJ2aXNpYmxlRmlsbCImJkEhPT0idmlzaWJsZVN0cm9rZSImJkEhPT0iYWxsIil0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIHBvaW50ZXJFdmVudHMgdHlwZS4iKTt0aGlzW2FdKCJwb2ludGVyRXZlbnRzIixBKX1nZXQgZmlsdGVyKCl7cmV0dXJuIHRoaXNbZF0oImZpbHRlciIpfXNldCBmaWx0ZXIoQSl7dGhpc1thXSgiZmlsdGVyIixBKX1nZXQgZGlzcGxheSgpe3JldHVybiB0aGlzW2RdKCJkaXNwbGF5Iil9c2V0IGRpc3BsYXkoQSl7dGhpc1thXSgiZGlzcGxheSIsQSl9c2V0IG9mZnNldChBKXt9fX0sZnVuY3Rpb24oZyxlLHQpe3QucihlKSx0LmQoZSwic2l6ZVRvUGl4ZWwiLGZ1bmN0aW9uKCl7cmV0dXJuIG59KSx0LmQoZSwidG9TdHJpbmciLGZ1bmN0aW9uKCl7cmV0dXJuIGl9KSx0LmQoZSwidG9OdW1iZXIiLGZ1bmN0aW9uKCl7cmV0dXJuIGZ9KSx0LmQoZSwidG9BcnJheSIsZnVuY3Rpb24oKXtyZXR1cm4gaH0pLHQuZChlLCJjb21wYXJlVmFsdWUiLGZ1bmN0aW9uKCl7cmV0dXJuIHV9KSx0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gbihhLGQpe2NvbnN0IEU9YS50cmltKCkubWF0Y2goL14oW1xkLl0rKShweHxwdHxwY3xpbnxjbXxtbXxlbXxleHxyZW18cXx2d3x2aHx2bWF4fHZtaW4pJC8pO0U/YT17c2l6ZTpwYXJzZUZsb2F0KEVbMV0pLHVuaXQ6RVsyXX06YT17c2l6ZTpwYXJzZUZsb2F0KGEpLHVuaXQ6InB4In07bGV0e3NpemU6cCx1bml0Ok99PWE7aWYoTz09PSJwdCIpcC89Ljc1O2Vsc2UgaWYoTz09PSJwYyIpcCo9MTY7ZWxzZSBpZihPPT09ImluIilwKj05NjtlbHNlIGlmKE89PT0iY20iKXAqPTk2LzIuNTQ7ZWxzZSBpZihPPT09Im1tIilwKj05Ni8yNS40O2Vsc2UgaWYoTz09PSJlbSJ8fE89PT0icmVtInx8Tz09PSJleCIpe2lmKCFkJiZ0eXBlb2YgZ2V0Q29tcHV0ZWRTdHlsZT09ImZ1bmN0aW9uIiYmdHlwZW9mIGRvY3VtZW50PCJ1Iil7Y29uc3QgbT1nZXRDb21wdXRlZFN0eWxlKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkuZm9udFNpemU7bT9kPW4obSwxNik6ZD0xNn1wKj1kLE89PT0iZXgiJiYocC89Mil9ZWxzZSBpZihPPT09InEiKXAqPTk2LzI1LjQvNDtlbHNlIGlmKE89PT0idncifHxPPT09InZoIil7aWYodHlwZW9mIGRvY3VtZW50PCJ1Iil7Y29uc3QgbT1PPT09InZ3Ij93aW5kb3cuaW5uZXJXaWR0aHx8ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoOndpbmRvdy5pbm5lckhlaWdodHx8ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodDtwKj1tLzEwMH19ZWxzZSBpZigoTz09PSJ2bWF4Inx8Tz09PSJ2bWluIikmJnR5cGVvZiBkb2N1bWVudDwidSIpe2NvbnN0IG09d2luZG93LmlubmVyV2lkdGh8fGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCxiPXdpbmRvdy5pbm5lckhlaWdodHx8ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodDtPPT09InZtYXgiP3AqPU1hdGgubWF4KG0sYikvMTAwOnAqPU1hdGgubWluKG0sYikvMTAwfXJldHVybiBwfWZ1bmN0aW9uIGkoYSl7cmV0dXJuIGE9PW51bGw/YTpTdHJpbmcoYSl9ZnVuY3Rpb24gZihhKXtpZihhPT1udWxsKXJldHVybiBhO2lmKHR5cGVvZiBhPT0ic3RyaW5nIiYmKGE9bihhKSksIU51bWJlci5pc0Zpbml0ZShhKSl0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIHZhbHVlIik7cmV0dXJuIGF9ZnVuY3Rpb24gaChhLGQ9ITEpe3JldHVybiBhPT09IiI/bnVsbDoodHlwZW9mIGE9PSJzdHJpbmciJiYoYT1hLnNwbGl0KC9bXHMsXSsvZykpLEFycmF5LmlzQXJyYXkoYSkmJihkJiYoYT1hLm1hcChmKSksYS5sZW5ndGg9PT0xKT9hWzBdOmEpfWZ1bmN0aW9uIHUoYSxkKXtpZihBcnJheS5pc0FycmF5KGEpJiZBcnJheS5pc0FycmF5KGQpKXtpZihhLmxlbmd0aCE9PWQubGVuZ3RoKXJldHVybiExO2ZvcihsZXQgRT0wO0U8YS5sZW5ndGg7RSsrKWlmKGFbRV0hPT1kW0VdKXJldHVybiExO3JldHVybiEwfXJldHVybiBhPT1udWxsJiZkPT1udWxsfHxhPT09ZH19LGZ1bmN0aW9uKGcsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIE99KTt2YXIgbj10KDc0KSxpPXQoMzIpLGY9dC5uKGkpLGg9dCg2OCksdT10KDcyKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gYSgpe3JldHVybiBhPU9iamVjdC5hc3NpZ258fGZ1bmN0aW9uKG0pe2Zvcih2YXIgYj0xO2I8YXJndW1lbnRzLmxlbmd0aDtiKyspe3ZhciBNPWFyZ3VtZW50c1tiXTtmb3IodmFyIHkgaW4gTSlPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoTSx5KSYmKG1beV09TVt5XSl9cmV0dXJuIG19LGEuYXBwbHkodGhpcyxhcmd1bWVudHMpfWZ1bmN0aW9uIGQobSl7aWYodHlwZW9mIG09PSJzdHJpbmciKXtpZihtPW0udHJpbSgpLC9eWzAtOS5dKyUkLy50ZXN0KG0pKXJldHVybiBwYXJzZUZsb2F0KG0pLzEwMDtpZigvXihbXGQuXSspKHB4fHB0fHBjfGlufGNtfG1tfGVtfGV4fHJlbXxxfHZ3fHZofHZtYXh8dm1pbikkLy50ZXN0KG0pKXJldHVybiBPYmplY3QodS5zaXplVG9QaXhlbCkobSl9cmV0dXJuIG19ZnVuY3Rpb24gRShtLGIsTSx5LFMpe3JldHVybiB0eXBlb2YgbT09InN0cmluZyImJihtPWYoKShtKSksdHlwZW9mIGI9PSJzdHJpbmciJiYoYj1mKCkoYikpLG4uRWZmZWN0cy5kZWZhdWx0KG0sYixNLHksUyl9ZnVuY3Rpb24gcChtLGIsTSx5LFMpe3JldHVybiBuLkVmZmVjdHMuZGVmYXVsdChtLGIsTSx5LFMpfW4uRWZmZWN0cy5kZWZhdWx0PWZ1bmN0aW9uKG0sYixNLHksUyl7cmV0dXJuIEFycmF5LmlzQXJyYXkobSkmJkFycmF5LmlzQXJyYXkoYik/bS5tYXAoKHMsYyk9PnMrKE0teSkvKFMteSkqKGJbY10tcykpOnR5cGVvZiBtPT0ibnVtYmVyIiYmdHlwZW9mIGI9PSJudW1iZXIiP20rKE0teSkvKFMteSkqKGItbSk6TS15PlMtTT9iOm19LG4uRWZmZWN0cy5maWxsQ29sb3I9RSxuLkVmZmVjdHMuc3Ryb2tlQ29sb3I9RSxuLkVmZmVjdHMuYmdjb2xvcj1FLG4uRWZmZWN0cy5ib3JkZXJDb2xvcj1FLG4uRWZmZWN0cy50ZXh0PXA7Y2xhc3MgTyBleHRlbmRzIG4uQW5pbWF0b3J7Y29uc3RydWN0b3IoYixNLHkpe2NvbnN0IFM9Yi5hdHRyKCk7T2JqZWN0LmVudHJpZXMoUykuZm9yRWFjaCgoW3MsY10pPT57U1tzXT1uLkVmZmVjdHNbc10/YzpkKGMpfSksTT1NLm1hcChzPT57bGV0IGM9YSh7fSxzKTtjb25zdCBsPXt9O3JldHVybiBPYmplY3QuZW50cmllcyhjKS5mb3JFYWNoKChbdixUXSk9PntsW3ZdPW4uRWZmZWN0c1t2XT9UOmQoVCl9KSxsfSksc3VwZXIoUyxNLHkpLHRoaXMudGFyZ2V0PWIsdGhpcy5zZXR0ZXI9ZnVuY3Rpb24ocyxjKXtjLmF0dHIocyl9fWdldCBwbGF5U3RhdGUoKXtyZXR1cm4gdGhpcy50YXJnZXQucGFyZW50P3N1cGVyLnBsYXlTdGF0ZToiaWRsZSJ9Z2V0IGZpbmlzaGVkKCl7cmV0dXJuIHN1cGVyLmZpbmlzaGVkLnRoZW4oKCk9Pntjb25zdCBiPXRoaXM7cmV0dXJuIG5ldyBQcm9taXNlKE09PntmdW5jdGlvbiB5KCl7Yi5zZXR0ZXIoYi5mcmFtZSxiLnRhcmdldCk7Y29uc3QgUz1iLnBsYXlTdGF0ZTtTPT09ImZpbmlzaGVkInx8Uz09PSJpZGxlIj8oT2JqZWN0KGguY2FuY2VsQW5pbWF0aW9uRnJhbWUpKGIucmVxdWVzdElkKSxNKCkpOk9iamVjdChoLnJlcXVlc3RBbmltYXRpb25GcmFtZSkoeSl9eSgpfSl9KX1maW5pc2goKXtzdXBlci5maW5pc2goKSxPYmplY3QoaC5jYW5jZWxBbmltYXRpb25GcmFtZSkodGhpcy5yZXF1ZXN0SWQpLHRoaXMuc2V0dGVyKHRoaXMuZnJhbWUsdGhpcy50YXJnZXQpfXBsYXkoKXtpZighdGhpcy50YXJnZXQucGFyZW50fHx0aGlzLnBsYXlTdGF0ZT09PSJydW5uaW5nIilyZXR1cm47c3VwZXIucGxheSgpLHRoaXMuc2V0dGVyKHRoaXMuZnJhbWUsdGhpcy50YXJnZXQpO2NvbnN0IGI9dGhpczt0aGlzLnJlYWR5LnRoZW4oKCk9PntiLnNldHRlcihiLmZyYW1lLGIudGFyZ2V0KSxiLnJlcXVlc3RJZD1PYmplY3QoaC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpKGZ1bmN0aW9uIE0oKXtjb25zdCB5PWIudGFyZ2V0O2lmKHR5cGVvZiBkb2N1bWVudDwidSImJmRvY3VtZW50LmRvY3VtZW50RWxlbWVudCYmZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNvbnRhaW5zJiZ5LmxheWVyJiZ5LmxheWVyLmNhbnZhcyYmIWRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jb250YWlucyh5LmxheWVyLmNhbnZhcykpe2IuY2FuY2VsKCk7cmV0dXJufWNvbnN0IFM9Yi5wbGF5U3RhdGU7Yi5zZXR0ZXIoYi5mcmFtZSxiLnRhcmdldCksUyE9PSJpZGxlIiYmKFM9PT0icnVubmluZyI/Yi5yZXF1ZXN0SWQ9T2JqZWN0KGgucmVxdWVzdEFuaW1hdGlvbkZyYW1lKShNKTooUz09PSJwYXVzZWQifHxTPT09InBlbmRpbmciJiZiLnRpbWVsaW5lLmN1cnJlbnRUaW1lPDApJiZiLnJlYWR5LnRoZW4oKCk9PntiLnNldHRlcihiLmZyYW1lLGIudGFyZ2V0KSxiLnJlcXVlc3RJZD1PYmplY3QoaC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpKE0pfSkpfSl9KX1jYW5jZWwoYj0hMSl7T2JqZWN0KGguY2FuY2VsQW5pbWF0aW9uRnJhbWUpKHRoaXMucmVxdWVzdElkKSxiPyh0aGlzLnNldHRlcih0aGlzLmZyYW1lLHRoaXMudGFyZ2V0KSxzdXBlci5jYW5jZWwoKSk6KHN1cGVyLmNhbmNlbCgpLHRoaXMuc2V0dGVyKHRoaXMuZnJhbWUsdGhpcy50YXJnZXQpKX19fSxmdW5jdGlvbihnLGUsdCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLGUuVGltZWxpbmU9ZS5FZmZlY3RzPWUuRWFzaW5ncz1lLkFuaW1hdG9yPXZvaWQgMDt2YXIgbj10KDc1KSxpPUUobiksZj10KDE4NyksaD1FKGYpLHU9dCgxODgpLGE9dCgxOTApLGQ9RShhKTtmdW5jdGlvbiBFKHApe3JldHVybiBwJiZwLl9fZXNNb2R1bGU/cDp7ZGVmYXVsdDpwfX1lLkFuaW1hdG9yPWQuZGVmYXVsdCxlLkVhc2luZ3M9dS5FYXNpbmdzLGUuRWZmZWN0cz1oLmRlZmF1bHQsZS5UaW1lbGluZT1pLmRlZmF1bHR9LGZ1bmN0aW9uKGcsZSx0KXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSk7dmFyIG49dCg3NiksaT1zKG4pLGY9dCgxMzMpLGg9cyhmKSx1PXQoMTQxKSxhPXModSksZD10KDE2NCksRT1zKGQpLHA9dCgxNzApLE89cyhwKSxtPXQoMTcxKSxiPXMobSksTT10KDE3NSkseT1zKE0pLFM9dCgxODYpO2Z1bmN0aW9uIHMoQil7cmV0dXJuIEImJkIuX19lc01vZHVsZT9COntkZWZhdWx0OkJ9fXZhciBjPSgwLFMuY3JlYXRlTm93VGltZSkoKSxsPXtvcmlnaW5UaW1lOjAscGxheWJhY2tSYXRlOjF9LHY9KDAseS5kZWZhdWx0KSgidGltZU1hcmsiKSxUPSgwLHkuZGVmYXVsdCkoInBsYXliYWNrUmF0ZSIpLFI9KDAseS5kZWZhdWx0KSgidGltZXJzIiksTD0oMCx5LmRlZmF1bHQpKCJvcmlnaW5UaW1lIiksTj0oMCx5LmRlZmF1bHQpKCJzZXRUaW1lciIpLEE9KDAseS5kZWZhdWx0KSgicGFyZW50Iiksdz1mdW5jdGlvbigpe2Z1bmN0aW9uIEIoRCxJKXsoMCxPLmRlZmF1bHQpKHRoaXMsQiksRCBpbnN0YW5jZW9mIEImJihJPUQsRD17fSksRD0oMCxFLmRlZmF1bHQpKHt9LGwsRCksSSYmKHRoaXNbQV09SSk7dmFyIGo9RC5ub3d0aW1lfHxjO2lmKEkpT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImdsb2JhbFRpbWUiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gSS5jdXJyZW50VGltZX19KTtlbHNle3ZhciBWPWooKTtPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiZ2xvYmFsVGltZSIse2dldDpmdW5jdGlvbigpe3JldHVybiBqKCktVn19KX10aGlzW3ZdPVt7Z2xvYmFsVGltZTp0aGlzLmdsb2JhbFRpbWUsbG9jYWxUaW1lOi1ELm9yaWdpblRpbWUsZW50cm9weTotRC5vcmlnaW5UaW1lLHBsYXliYWNrUmF0ZTpELnBsYXliYWNrUmF0ZSxnbG9iYWxFbnRyb3B5OjB9XSx0aGlzW0FdJiYodGhpc1t2XVswXS5nbG9iYWxFbnRyb3B5PXRoaXNbQV0uZW50cm9weSksdGhpc1tMXT1ELm9yaWdpblRpbWUsdGhpc1tUXT1ELnBsYXliYWNrUmF0ZSx0aGlzW1JdPW5ldyBhLmRlZmF1bHR9cmV0dXJuKDAsYi5kZWZhdWx0KShCLFt7a2V5OiJtYXJrVGltZSIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgST1hcmd1bWVudHMubGVuZ3RoPjAmJmFyZ3VtZW50c1swXSE9PXZvaWQgMD9hcmd1bWVudHNbMF06e30saj1JLnRpbWUsVj1qPT09dm9pZCAwP3RoaXMuY3VycmVudFRpbWU6aixKPUkuZW50cm9weSxfPUo9PT12b2lkIDA/dGhpcy5lbnRyb3B5Okosc3Q9SS5wbGF5YmFja1JhdGUsRz1zdD09PXZvaWQgMD90aGlzLnBsYXliYWNrUmF0ZTpzdCxZPXtnbG9iYWxUaW1lOnRoaXMuZ2xvYmFsVGltZSxsb2NhbFRpbWU6VixlbnRyb3B5Ol8scGxheWJhY2tSYXRlOkcsZ2xvYmFsRW50cm9weTp0aGlzLmdsb2JhbEVudHJvcHl9O3RoaXNbdl0ucHVzaChZKX19LHtrZXk6ImZvcmsiLHZhbHVlOmZ1bmN0aW9uKEkpe3JldHVybiBuZXcgQihJLHRoaXMpfX0se2tleToic2Vla0dsb2JhbFRpbWUiLHZhbHVlOmZ1bmN0aW9uKEkpe3ZhciBqPXRoaXMuc2Vla1RpbWVNYXJrKEkpLFY9dGhpc1t2XVtqXSxKPVYuZW50cm9weSxfPVYucGxheWJhY2tSYXRlLHN0PVYuZ2xvYmFsVGltZTtyZXR1cm4gc3QrKEktSikvTWF0aC5hYnMoXyl9fSx7a2V5OiJzZWVrTG9jYWxUaW1lIix2YWx1ZTpmdW5jdGlvbihJKXt2YXIgaj10aGlzLnNlZWtUaW1lTWFyayhJKSxWPXRoaXNbdl1bal0sSj1WLmxvY2FsVGltZSxfPVYuZW50cm9weSxzdD1WLnBsYXliYWNrUmF0ZTtyZXR1cm4gc3Q+MD9KKyhJLV8pOkotKEktXyl9fSx7a2V5OiJzZWVrVGltZU1hcmsiLHZhbHVlOmZ1bmN0aW9uKEkpe3ZhciBqPXRoaXNbdl0sVj0wLEo9ai5sZW5ndGgtMTtpZihJPD1qW1ZdLmVudHJvcHkpcmV0dXJuIFY7aWYoST49altKXS5lbnRyb3B5KXJldHVybiBKO2Zvcih2YXIgXz1NYXRoLmZsb29yKChWK0opLzIpO18+ViYmXzxKOyl7aWYoST09PWpbX10uZW50cm9weSlyZXR1cm4gXztJPGpbX10uZW50cm9weT9KPV86ST5qW19dLmVudHJvcHkmJihWPV8pLF89TWF0aC5mbG9vcigoVitKKS8yKX1yZXR1cm4gVn19LHtrZXk6InVwZGF0ZVRpbWVycyIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgST10aGlzLGo9W10uY29uY2F0KCgwLGguZGVmYXVsdCkodGhpc1tSXSkpO2ouZm9yRWFjaChmdW5jdGlvbihWKXt2YXIgSj0oMCxpLmRlZmF1bHQpKFYsMiksXz1KWzBdLHN0PUpbMV07SVtOXShzdC5oYW5kbGVyLHN0LnRpbWUsXyl9KX19LHtrZXk6ImNsZWFyVGltZW91dCIsdmFsdWU6ZnVuY3Rpb24oRCl7ZnVuY3Rpb24gSShqKXtyZXR1cm4gRC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9cmV0dXJuIEkudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gRC50b1N0cmluZygpfSxJfShmdW5jdGlvbihEKXt2YXIgST10aGlzW1JdLmdldChEKTtJJiZJLnRpbWVySUQhPW51bGwmJih0aGlzW0FdP3RoaXNbQV0uY2xlYXJUaW1lb3V0KEkudGltZXJJRCk6Y2xlYXJUaW1lb3V0KEkudGltZXJJRCkpLHRoaXNbUl0uZGVsZXRlKEQpfSl9LHtrZXk6ImNsZWFySW50ZXJ2YWwiLHZhbHVlOmZ1bmN0aW9uKEkpe3JldHVybiB0aGlzLmNsZWFyVGltZW91dChJKX19LHtrZXk6ImNsZWFyIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBJPXRoaXMsaj10aGlzW1JdO1tdLmNvbmNhdCgoMCxoLmRlZmF1bHQpKGoua2V5cygpKSkuZm9yRWFjaChmdW5jdGlvbihWKXtJLmNsZWFyVGltZW91dChWKX0pfX0se2tleToic2V0VGltZW91dCIsdmFsdWU6ZnVuY3Rpb24oSSl7dmFyIGo9YXJndW1lbnRzLmxlbmd0aD4xJiZhcmd1bWVudHNbMV0hPT12b2lkIDA/YXJndW1lbnRzWzFdOntkZWxheTowfTtyZXR1cm4gdGhpc1tOXShJLGopfX0se2tleToic2V0SW50ZXJ2YWwiLHZhbHVlOmZ1bmN0aW9uKEkpe3ZhciBqPWFyZ3VtZW50cy5sZW5ndGg+MSYmYXJndW1lbnRzWzFdIT09dm9pZCAwP2FyZ3VtZW50c1sxXTp7ZGVsYXk6MH0sVj10aGlzLEo9dGhpc1tOXShmdW5jdGlvbiBfKCl7VltOXShfLGosSiksSSgpfSxqKTtyZXR1cm4gSn19LHtrZXk6Tix2YWx1ZTpmdW5jdGlvbihJLGope3ZhciBWPXRoaXMsSj1hcmd1bWVudHMubGVuZ3RoPjImJmFyZ3VtZW50c1syXSE9PXZvaWQgMD9hcmd1bWVudHNbMl06KDAseS5kZWZhdWx0KSgidGltZXJJRCIpO2o9KDAsUy5mb3JtYXREZWxheSkoaik7dmFyIF89dGhpc1tSXS5nZXQoSiksc3Q9dm9pZCAwLEc9bnVsbCxZPXZvaWQgMCxydD12b2lkIDA7Xz8odGhpcy5jbGVhclRpbWVvdXQoSiksai5pc0VudHJvcHk/c3Q9KGouZGVsYXktKHRoaXMuZW50cm9weS1fLnN0YXJ0RW50cm9weSkpL01hdGguYWJzKHRoaXMucGxheWJhY2tSYXRlKTpzdD0oai5kZWxheS0odGhpcy5jdXJyZW50VGltZS1fLnN0YXJ0VGltZSkpL3RoaXMucGxheWJhY2tSYXRlLFk9Xy5zdGFydFRpbWUscnQ9Xy5zdGFydEVudHJvcHkpOihzdD1qLmRlbGF5LyhqLmlzRW50cm9weT9NYXRoLmFicyh0aGlzLnBsYXliYWNrUmF0ZSk6dGhpcy5wbGF5YmFja1JhdGUpLFk9dGhpcy5jdXJyZW50VGltZSxydD10aGlzLmVudHJvcHkpO3ZhciBvdD10aGlzW0FdLGF0PW90P290LnNldFRpbWVvdXQuYmluZChvdCk6c2V0VGltZW91dCxodD1qLmhlYWRpbmc7cmV0dXJuIW90JiZodD09PSExJiZzdDwwJiYoc3Q9MS8wKSwoaXNGaW5pdGUoc3QpfHxvdCkmJihzdD1NYXRoLmNlaWwoc3QpLGF0IT09c2V0VGltZW91dCYmKHN0PXtkZWxheTpzdCxoZWFkaW5nOmh0fSksRz1hdChmdW5jdGlvbigpe1ZbUl0uZGVsZXRlKEopLEkoKX0sc3QpKSx0aGlzW1JdLnNldChKLHt0aW1lcklEOkcsaGFuZGxlcjpJLHRpbWU6aixzdGFydFRpbWU6WSxzdGFydEVudHJvcHk6cnR9KSxKfX0se2tleToicGFyZW50IixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc1tBXX19LHtrZXk6Imxhc3RUaW1lTWFyayIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXNbdl1bdGhpc1t2XS5sZW5ndGgtMV19fSx7a2V5OiJjdXJyZW50VGltZSIsZ2V0OmZ1bmN0aW9uKCl7dmFyIEk9dGhpcy5sYXN0VGltZU1hcmssaj1JLmxvY2FsVGltZSxWPUkuZ2xvYmFsVGltZTtyZXR1cm4gaisodGhpcy5nbG9iYWxUaW1lLVYpKnRoaXMucGxheWJhY2tSYXRlfSxzZXQ6ZnVuY3Rpb24oSSl7dmFyIGo9dGhpcyxWPXRoaXMuY3VycmVudFRpbWUsSj1JLF89dGhpc1tSXTt0aGlzLm1hcmtUaW1lKHt0aW1lOkl9KSxbXS5jb25jYXQoKDAsaC5kZWZhdWx0KShfKSkuZm9yRWFjaChmdW5jdGlvbihzdCl7dmFyIEc9KDAsaS5kZWZhdWx0KShzdCwyKSxZPUdbMF0scnQ9R1sxXTtpZihfLmhhcyhZKSl7dmFyIG90PXJ0LnRpbWUsYXQ9b3QuaXNFbnRyb3B5LGh0PW90LmRlbGF5LGl0PW90LmhlYWRpbmcsTXQ9cnQuaGFuZGxlcixPdD1ydC5zdGFydFRpbWU7aWYoYXQpaHQ9PT0wJiYoTXQoKSxqLmNsZWFyVGltZW91dChZKSk7ZWxzZXt2YXIgVT1PdCtodDsoaHQ9PT0wfHxpdCE9PSExJiYoSi1WKSpodDw9MHx8Vjw9VSYmVTw9Snx8Vj49VSYmVT49SikmJihNdCgpLGouY2xlYXJUaW1lb3V0KFkpKX19fSksdGhpcy51cGRhdGVUaW1lcnMoKX19LHtrZXk6ImVudHJvcHkiLGdldDpmdW5jdGlvbigpe3ZhciBJPXRoaXMubGFzdFRpbWVNYXJrLGo9SS5lbnRyb3B5LFY9SS5nbG9iYWxFbnRyb3B5O3JldHVybiBqK01hdGguYWJzKCh0aGlzLmdsb2JhbEVudHJvcHktVikqdGhpcy5wbGF5YmFja1JhdGUpfSxzZXQ6ZnVuY3Rpb24oSSl7aWYodGhpcy5lbnRyb3B5Pkkpe3ZhciBqPXRoaXMuc2Vla1RpbWVNYXJrKEkpO3RoaXNbdl0ubGVuZ3RoPWorMX10aGlzLm1hcmtUaW1lKHtlbnRyb3B5Okl9KSx0aGlzLnVwZGF0ZVRpbWVycygpfX0se2tleToiZ2xvYmFsRW50cm9weSIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXNbQV0/dGhpc1tBXS5lbnRyb3B5OnRoaXMuZ2xvYmFsVGltZX19LHtrZXk6InBsYXliYWNrUmF0ZSIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXNbVF19LHNldDpmdW5jdGlvbihJKXtJIT09dGhpcy5wbGF5YmFja1JhdGUmJih0aGlzLm1hcmtUaW1lKHtwbGF5YmFja1JhdGU6SX0pLHRoaXNbVF09SSx0aGlzLnVwZGF0ZVRpbWVycygpKX19LHtrZXk6InBhdXNlZCIsZ2V0OmZ1bmN0aW9uKCl7aWYodGhpcy5wbGF5YmFja1JhdGU9PT0wKXJldHVybiEwO2Zvcih2YXIgST10aGlzLnBhcmVudDtJOyl7aWYoSS5wbGF5YmFja1JhdGU9PT0wKXJldHVybiEwO0k9SS5wYXJlbnR9cmV0dXJuITF9fV0pLEJ9KCk7ZS5kZWZhdWx0PXd9LGZ1bmN0aW9uKGcsZSx0KXtlLl9fZXNNb2R1bGU9ITA7dmFyIG49dCg3NyksaT11KG4pLGY9dCgxMjkpLGg9dShmKTtmdW5jdGlvbiB1KGEpe3JldHVybiBhJiZhLl9fZXNNb2R1bGU/YTp7ZGVmYXVsdDphfX1lLmRlZmF1bHQ9ZnVuY3Rpb24oKXtmdW5jdGlvbiBhKGQsRSl7dmFyIHA9W10sTz0hMCxtPSExLGI9dm9pZCAwO3RyeXtmb3IodmFyIE09KDAsaC5kZWZhdWx0KShkKSx5OyEoTz0oeT1NLm5leHQoKSkuZG9uZSkmJihwLnB1c2goeS52YWx1ZSksIShFJiZwLmxlbmd0aD09PUUpKTtPPSEwKTt9Y2F0Y2goUyl7bT0hMCxiPVN9ZmluYWxseXt0cnl7IU8mJk0ucmV0dXJuJiZNLnJldHVybigpfWZpbmFsbHl7aWYobSl0aHJvdyBifX1yZXR1cm4gcH1yZXR1cm4gZnVuY3Rpb24oZCxFKXtpZihBcnJheS5pc0FycmF5KGQpKXJldHVybiBkO2lmKCgwLGkuZGVmYXVsdCkoT2JqZWN0KGQpKSlyZXR1cm4gYShkLEUpO3Rocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UiKX19KCl9LGZ1bmN0aW9uKGcsZSx0KXtnLmV4cG9ydHM9e2RlZmF1bHQ6dCg3OCksX19lc01vZHVsZTohMH19LGZ1bmN0aW9uKGcsZSx0KXt0KDc5KSx0KDEyNSksZy5leHBvcnRzPXQoMTI3KX0sZnVuY3Rpb24oZyxlLHQpe3QoODApO2Zvcih2YXIgbj10KDkxKSxpPXQoOTUpLGY9dCg4MyksaD10KDEyMikoInRvU3RyaW5nVGFnIiksdT0iQ1NTUnVsZUxpc3QsQ1NTU3R5bGVEZWNsYXJhdGlvbixDU1NWYWx1ZUxpc3QsQ2xpZW50UmVjdExpc3QsRE9NUmVjdExpc3QsRE9NU3RyaW5nTGlzdCxET01Ub2tlbkxpc3QsRGF0YVRyYW5zZmVySXRlbUxpc3QsRmlsZUxpc3QsSFRNTEFsbENvbGxlY3Rpb24sSFRNTENvbGxlY3Rpb24sSFRNTEZvcm1FbGVtZW50LEhUTUxTZWxlY3RFbGVtZW50LE1lZGlhTGlzdCxNaW1lVHlwZUFycmF5LE5hbWVkTm9kZU1hcCxOb2RlTGlzdCxQYWludFJlcXVlc3RMaXN0LFBsdWdpbixQbHVnaW5BcnJheSxTVkdMZW5ndGhMaXN0LFNWR051bWJlckxpc3QsU1ZHUGF0aFNlZ0xpc3QsU1ZHUG9pbnRMaXN0LFNWR1N0cmluZ0xpc3QsU1ZHVHJhbnNmb3JtTGlzdCxTb3VyY2VCdWZmZXJMaXN0LFN0eWxlU2hlZXRMaXN0LFRleHRUcmFja0N1ZUxpc3QsVGV4dFRyYWNrTGlzdCxUb3VjaExpc3QiLnNwbGl0KCIsIiksYT0wO2E8dS5sZW5ndGg7YSsrKXt2YXIgZD11W2FdLEU9bltkXSxwPUUmJkUucHJvdG90eXBlO3AmJiFwW2hdJiZpKHAsaCxkKSxmW2RdPWYuQXJyYXl9fSxmdW5jdGlvbihnLGUsdCl7dmFyIG49dCg4MSksaT10KDgyKSxmPXQoODMpLGg9dCg4NCk7Zy5leHBvcnRzPXQoODgpKEFycmF5LCJBcnJheSIsZnVuY3Rpb24odSxhKXt0aGlzLl90PWgodSksdGhpcy5faT0wLHRoaXMuX2s9YX0sZnVuY3Rpb24oKXt2YXIgdT10aGlzLl90LGE9dGhpcy5fayxkPXRoaXMuX2krKztyZXR1cm4hdXx8ZD49dS5sZW5ndGg/KHRoaXMuX3Q9dm9pZCAwLGkoMSkpOmE9PSJrZXlzIj9pKDAsZCk6YT09InZhbHVlcyI/aSgwLHVbZF0pOmkoMCxbZCx1W2RdXSl9LCJ2YWx1ZXMiKSxmLkFyZ3VtZW50cz1mLkFycmF5LG4oImtleXMiKSxuKCJ2YWx1ZXMiKSxuKCJlbnRyaWVzIil9LGZ1bmN0aW9uKGcsZSl7Zy5leHBvcnRzPWZ1bmN0aW9uKCl7fX0sZnVuY3Rpb24oZyxlKXtnLmV4cG9ydHM9ZnVuY3Rpb24odCxuKXtyZXR1cm57dmFsdWU6bixkb25lOiEhdH19fSxmdW5jdGlvbihnLGUpe2cuZXhwb3J0cz17fX0sZnVuY3Rpb24oZyxlLHQpe3ZhciBuPXQoODUpLGk9dCg4Nyk7Zy5leHBvcnRzPWZ1bmN0aW9uKGYpe3JldHVybiBuKGkoZikpfX0sZnVuY3Rpb24oZyxlLHQpe3ZhciBuPXQoODYpO2cuZXhwb3J0cz1PYmplY3QoInoiKS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgwKT9PYmplY3Q6ZnVuY3Rpb24oaSl7cmV0dXJuIG4oaSk9PSJTdHJpbmciP2kuc3BsaXQoIiIpOk9iamVjdChpKX19LGZ1bmN0aW9uKGcsZSl7dmFyIHQ9e30udG9TdHJpbmc7Zy5leHBvcnRzPWZ1bmN0aW9uKG4pe3JldHVybiB0LmNhbGwobikuc2xpY2UoOCwtMSl9fSxmdW5jdGlvbihnLGUpe2cuZXhwb3J0cz1mdW5jdGlvbih0KXtpZih0PT1udWxsKXRocm93IFR5cGVFcnJvcigiQ2FuJ3QgY2FsbCBtZXRob2Qgb24gICIrdCk7cmV0dXJuIHR9fSxmdW5jdGlvbihnLGUsdCl7dmFyIG49dCg4OSksaT10KDkwKSxmPXQoMTA2KSxoPXQoOTUpLHU9dCg4MyksYT10KDEwNyksZD10KDEyMSksRT10KDEyMykscD10KDEyMikoIml0ZXJhdG9yIiksTz0hKFtdLmtleXMmJiJuZXh0ImluW10ua2V5cygpKSxtPSJAQGl0ZXJhdG9yIixiPSJrZXlzIixNPSJ2YWx1ZXMiLHk9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc307Zy5leHBvcnRzPWZ1bmN0aW9uKFMscyxjLGwsdixULFIpe2EoYyxzLGwpO3ZhciBMPWZ1bmN0aW9uKEcpe2lmKCFPJiZHIGluIEIpcmV0dXJuIEJbR107c3dpdGNoKEcpe2Nhc2UgYjpyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gbmV3IGModGhpcyxHKX07Y2FzZSBNOnJldHVybiBmdW5jdGlvbigpe3JldHVybiBuZXcgYyh0aGlzLEcpfX1yZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gbmV3IGModGhpcyxHKX19LE49cysiIEl0ZXJhdG9yIixBPXY9PU0sdz0hMSxCPVMucHJvdG90eXBlLEQ9QltwXXx8QlttXXx8diYmQlt2XSxJPUR8fEwodiksaj12P0E/TCgiZW50cmllcyIpOkk6dm9pZCAwLFY9cz09IkFycmF5IiYmQi5lbnRyaWVzfHxELEosXyxzdDtpZihWJiYoc3Q9RShWLmNhbGwobmV3IFMpKSxzdCE9PU9iamVjdC5wcm90b3R5cGUmJnN0Lm5leHQmJihkKHN0LE4sITApLCFuJiZ0eXBlb2Ygc3RbcF0hPSJmdW5jdGlvbiImJmgoc3QscCx5KSkpLEEmJkQmJkQubmFtZSE9PU0mJih3PSEwLEk9ZnVuY3Rpb24oKXtyZXR1cm4gRC5jYWxsKHRoaXMpfSksKCFufHxSKSYmKE98fHd8fCFCW3BdKSYmaChCLHAsSSksdVtzXT1JLHVbTl09eSx2KWlmKEo9e3ZhbHVlczpBP0k6TChNKSxrZXlzOlQ/STpMKGIpLGVudHJpZXM6an0sUilmb3IoXyBpbiBKKV8gaW4gQnx8ZihCLF8sSltfXSk7ZWxzZSBpKGkuUCtpLkYqKE98fHcpLHMsSik7cmV0dXJuIEp9fSxmdW5jdGlvbihnLGUpe2cuZXhwb3J0cz0hMH0sZnVuY3Rpb24oZyxlLHQpe3ZhciBuPXQoOTEpLGk9dCg5MiksZj10KDkzKSxoPXQoOTUpLHU9dCgxMDUpLGE9InByb3RvdHlwZSIsZD1mdW5jdGlvbihFLHAsTyl7dmFyIG09RSZkLkYsYj1FJmQuRyxNPUUmZC5TLHk9RSZkLlAsUz1FJmQuQixzPUUmZC5XLGM9Yj9pOmlbcF18fChpW3BdPXt9KSxsPWNbYV0sdj1iP246TT9uW3BdOihuW3BdfHx7fSlbYV0sVCxSLEw7YiYmKE89cCk7Zm9yKFQgaW4gTylSPSFtJiZ2JiZ2W1RdIT09dm9pZCAwLCEoUiYmdShjLFQpKSYmKEw9Uj92W1RdOk9bVF0sY1tUXT1iJiZ0eXBlb2YgdltUXSE9ImZ1bmN0aW9uIj9PW1RdOlMmJlI/ZihMLG4pOnMmJnZbVF09PUw/ZnVuY3Rpb24oTil7dmFyIEE9ZnVuY3Rpb24odyxCLEQpe2lmKHRoaXMgaW5zdGFuY2VvZiBOKXtzd2l0Y2goYXJndW1lbnRzLmxlbmd0aCl7Y2FzZSAwOnJldHVybiBuZXcgTjtjYXNlIDE6cmV0dXJuIG5ldyBOKHcpO2Nhc2UgMjpyZXR1cm4gbmV3IE4odyxCKX1yZXR1cm4gbmV3IE4odyxCLEQpfXJldHVybiBOLmFwcGx5KHRoaXMsYXJndW1lbnRzKX07cmV0dXJuIEFbYV09TlthXSxBfShMKTp5JiZ0eXBlb2YgTD09ImZ1bmN0aW9uIj9mKEZ1bmN0aW9uLmNhbGwsTCk6TCx5JiYoKGMudmlydHVhbHx8KGMudmlydHVhbD17fSkpW1RdPUwsRSZkLlImJmwmJiFsW1RdJiZoKGwsVCxMKSkpfTtkLkY9MSxkLkc9MixkLlM9NCxkLlA9OCxkLkI9MTYsZC5XPTMyLGQuVT02NCxkLlI9MTI4LGcuZXhwb3J0cz1kfSxmdW5jdGlvbihnLGUpe3ZhciB0PWcuZXhwb3J0cz10eXBlb2Ygd2luZG93PCJ1IiYmd2luZG93Lk1hdGg9PU1hdGg/d2luZG93OnR5cGVvZiBzZWxmPCJ1IiYmc2VsZi5NYXRoPT1NYXRoP3NlbGY6RnVuY3Rpb24oInJldHVybiB0aGlzIikoKTt0eXBlb2YgX19nPT0ibnVtYmVyIiYmKF9fZz10KX0sZnVuY3Rpb24oZyxlKXt2YXIgdD1nLmV4cG9ydHM9e3ZlcnNpb246IjIuNi4xMSJ9O3R5cGVvZiBfX2U9PSJudW1iZXIiJiYoX19lPXQpfSxmdW5jdGlvbihnLGUsdCl7dmFyIG49dCg5NCk7Zy5leHBvcnRzPWZ1bmN0aW9uKGksZixoKXtpZihuKGkpLGY9PT12b2lkIDApcmV0dXJuIGk7c3dpdGNoKGgpe2Nhc2UgMTpyZXR1cm4gZnVuY3Rpb24odSl7cmV0dXJuIGkuY2FsbChmLHUpfTtjYXNlIDI6cmV0dXJuIGZ1bmN0aW9uKHUsYSl7cmV0dXJuIGkuY2FsbChmLHUsYSl9O2Nhc2UgMzpyZXR1cm4gZnVuY3Rpb24odSxhLGQpe3JldHVybiBpLmNhbGwoZix1LGEsZCl9fXJldHVybiBmdW5jdGlvbigpe3JldHVybiBpLmFwcGx5KGYsYXJndW1lbnRzKX19fSxmdW5jdGlvbihnLGUpe2cuZXhwb3J0cz1mdW5jdGlvbih0KXtpZih0eXBlb2YgdCE9ImZ1bmN0aW9uIil0aHJvdyBUeXBlRXJyb3IodCsiIGlzIG5vdCBhIGZ1bmN0aW9uISIpO3JldHVybiB0fX0sZnVuY3Rpb24oZyxlLHQpe3ZhciBuPXQoOTYpLGk9dCgxMDQpO2cuZXhwb3J0cz10KDEwMCk/ZnVuY3Rpb24oZixoLHUpe3JldHVybiBuLmYoZixoLGkoMSx1KSl9OmZ1bmN0aW9uKGYsaCx1KXtyZXR1cm4gZltoXT11LGZ9fSxmdW5jdGlvbihnLGUsdCl7dmFyIG49dCg5NyksaT10KDk5KSxmPXQoMTAzKSxoPU9iamVjdC5kZWZpbmVQcm9wZXJ0eTtlLmY9dCgxMDApP09iamVjdC5kZWZpbmVQcm9wZXJ0eTpmdW5jdGlvbihhLGQsRSl7aWYobihhKSxkPWYoZCwhMCksbihFKSxpKXRyeXtyZXR1cm4gaChhLGQsRSl9Y2F0Y2h7fWlmKCJnZXQiaW4gRXx8InNldCJpbiBFKXRocm93IFR5cGVFcnJvcigiQWNjZXNzb3JzIG5vdCBzdXBwb3J0ZWQhIik7cmV0dXJuInZhbHVlImluIEUmJihhW2RdPUUudmFsdWUpLGF9fSxmdW5jdGlvbihnLGUsdCl7dmFyIG49dCg5OCk7Zy5leHBvcnRzPWZ1bmN0aW9uKGkpe2lmKCFuKGkpKXRocm93IFR5cGVFcnJvcihpKyIgaXMgbm90IGFuIG9iamVjdCEiKTtyZXR1cm4gaX19LGZ1bmN0aW9uKGcsZSl7Zy5leHBvcnRzPWZ1bmN0aW9uKHQpe3JldHVybiB0eXBlb2YgdD09Im9iamVjdCI/dCE9PW51bGw6dHlwZW9mIHQ9PSJmdW5jdGlvbiJ9fSxmdW5jdGlvbihnLGUsdCl7Zy5leHBvcnRzPSF0KDEwMCkmJiF0KDEwMSkoZnVuY3Rpb24oKXtyZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHQoMTAyKSgiZGl2IiksImEiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gN319KS5hIT03fSl9LGZ1bmN0aW9uKGcsZSx0KXtnLmV4cG9ydHM9IXQoMTAxKShmdW5jdGlvbigpe3JldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sImEiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gN319KS5hIT03fSl9LGZ1bmN0aW9uKGcsZSl7Zy5leHBvcnRzPWZ1bmN0aW9uKHQpe3RyeXtyZXR1cm4hIXQoKX1jYXRjaHtyZXR1cm4hMH19fSxmdW5jdGlvbihnLGUsdCl7dmFyIG49dCg5OCksaT10KDkxKS5kb2N1bWVudCxmPW4oaSkmJm4oaS5jcmVhdGVFbGVtZW50KTtnLmV4cG9ydHM9ZnVuY3Rpb24oaCl7cmV0dXJuIGY/aS5jcmVhdGVFbGVtZW50KGgpOnt9fX0sZnVuY3Rpb24oZyxlLHQpe3ZhciBuPXQoOTgpO2cuZXhwb3J0cz1mdW5jdGlvbihpLGYpe2lmKCFuKGkpKXJldHVybiBpO3ZhciBoLHU7aWYoZiYmdHlwZW9mKGg9aS50b1N0cmluZyk9PSJmdW5jdGlvbiImJiFuKHU9aC5jYWxsKGkpKXx8dHlwZW9mKGg9aS52YWx1ZU9mKT09ImZ1bmN0aW9uIiYmIW4odT1oLmNhbGwoaSkpfHwhZiYmdHlwZW9mKGg9aS50b1N0cmluZyk9PSJmdW5jdGlvbiImJiFuKHU9aC5jYWxsKGkpKSlyZXR1cm4gdTt0aHJvdyBUeXBlRXJyb3IoIkNhbid0IGNvbnZlcnQgb2JqZWN0IHRvIHByaW1pdGl2ZSB2YWx1ZSIpfX0sZnVuY3Rpb24oZyxlKXtnLmV4cG9ydHM9ZnVuY3Rpb24odCxuKXtyZXR1cm57ZW51bWVyYWJsZTohKHQmMSksY29uZmlndXJhYmxlOiEodCYyKSx3cml0YWJsZTohKHQmNCksdmFsdWU6bn19fSxmdW5jdGlvbihnLGUpe3ZhciB0PXt9Lmhhc093blByb3BlcnR5O2cuZXhwb3J0cz1mdW5jdGlvbihuLGkpe3JldHVybiB0LmNhbGwobixpKX19LGZ1bmN0aW9uKGcsZSx0KXtnLmV4cG9ydHM9dCg5NSl9LGZ1bmN0aW9uKGcsZSx0KXt2YXIgbj10KDEwOCksaT10KDEwNCksZj10KDEyMSksaD17fTt0KDk1KShoLHQoMTIyKSgiaXRlcmF0b3IiKSxmdW5jdGlvbigpe3JldHVybiB0aGlzfSksZy5leHBvcnRzPWZ1bmN0aW9uKHUsYSxkKXt1LnByb3RvdHlwZT1uKGgse25leHQ6aSgxLGQpfSksZih1LGErIiBJdGVyYXRvciIpfX0sZnVuY3Rpb24oZyxlLHQpe3ZhciBuPXQoOTcpLGk9dCgxMDkpLGY9dCgxMTkpLGg9dCgxMTYpKCJJRV9QUk9UTyIpLHU9ZnVuY3Rpb24oKXt9LGE9InByb3RvdHlwZSIsZD1mdW5jdGlvbigpe3ZhciBFPXQoMTAyKSgiaWZyYW1lIikscD1mLmxlbmd0aCxPPSI8IixtPSI+IixiO2ZvcihFLnN0eWxlLmRpc3BsYXk9Im5vbmUiLHQoMTIwKS5hcHBlbmRDaGlsZChFKSxFLnNyYz0iamF2YXNjcmlwdDoiLGI9RS5jb250ZW50V2luZG93LmRvY3VtZW50LGIub3BlbigpLGIud3JpdGUoTysic2NyaXB0IittKyJkb2N1bWVudC5GPU9iamVjdCIrTysiL3NjcmlwdCIrbSksYi5jbG9zZSgpLGQ9Yi5GO3AtLTspZGVsZXRlIGRbYV1bZltwXV07cmV0dXJuIGQoKX07Zy5leHBvcnRzPU9iamVjdC5jcmVhdGV8fGZ1bmN0aW9uKHAsTyl7dmFyIG07cmV0dXJuIHAhPT1udWxsPyh1W2FdPW4ocCksbT1uZXcgdSx1W2FdPW51bGwsbVtoXT1wKTptPWQoKSxPPT09dm9pZCAwP206aShtLE8pfX0sZnVuY3Rpb24oZyxlLHQpe3ZhciBuPXQoOTYpLGk9dCg5NyksZj10KDExMCk7Zy5leHBvcnRzPXQoMTAwKT9PYmplY3QuZGVmaW5lUHJvcGVydGllczpmdW5jdGlvbih1LGEpe2kodSk7Zm9yKHZhciBkPWYoYSksRT1kLmxlbmd0aCxwPTAsTztFPnA7KW4uZih1LE89ZFtwKytdLGFbT10pO3JldHVybiB1fX0sZnVuY3Rpb24oZyxlLHQpe3ZhciBuPXQoMTExKSxpPXQoMTE5KTtnLmV4cG9ydHM9T2JqZWN0LmtleXN8fGZ1bmN0aW9uKGgpe3JldHVybiBuKGgsaSl9fSxmdW5jdGlvbihnLGUsdCl7dmFyIG49dCgxMDUpLGk9dCg4NCksZj10KDExMikoITEpLGg9dCgxMTYpKCJJRV9QUk9UTyIpO2cuZXhwb3J0cz1mdW5jdGlvbih1LGEpe3ZhciBkPWkodSksRT0wLHA9W10sTztmb3IoTyBpbiBkKU8hPWgmJm4oZCxPKSYmcC5wdXNoKE8pO2Zvcig7YS5sZW5ndGg+RTspbihkLE89YVtFKytdKSYmKH5mKHAsTyl8fHAucHVzaChPKSk7cmV0dXJuIHB9fSxmdW5jdGlvbihnLGUsdCl7dmFyIG49dCg4NCksaT10KDExMyksZj10KDExNSk7Zy5leHBvcnRzPWZ1bmN0aW9uKGgpe3JldHVybiBmdW5jdGlvbih1LGEsZCl7dmFyIEU9bih1KSxwPWkoRS5sZW5ndGgpLE89ZihkLHApLG07aWYoaCYmYSE9YSl7Zm9yKDtwPk87KWlmKG09RVtPKytdLG0hPW0pcmV0dXJuITB9ZWxzZSBmb3IoO3A+TztPKyspaWYoKGh8fE8gaW4gRSkmJkVbT109PT1hKXJldHVybiBofHxPfHwwO3JldHVybiFoJiYtMX19fSxmdW5jdGlvbihnLGUsdCl7dmFyIG49dCgxMTQpLGk9TWF0aC5taW47Zy5leHBvcnRzPWZ1bmN0aW9uKGYpe3JldHVybiBmPjA/aShuKGYpLDkwMDcxOTkyNTQ3NDA5OTEpOjB9fSxmdW5jdGlvbihnLGUpe3ZhciB0PU1hdGguY2VpbCxuPU1hdGguZmxvb3I7Zy5leHBvcnRzPWZ1bmN0aW9uKGkpe3JldHVybiBpc05hTihpPStpKT8wOihpPjA/bjp0KShpKX19LGZ1bmN0aW9uKGcsZSx0KXt2YXIgbj10KDExNCksaT1NYXRoLm1heCxmPU1hdGgubWluO2cuZXhwb3J0cz1mdW5jdGlvbihoLHUpe3JldHVybiBoPW4oaCksaDwwP2koaCt1LDApOmYoaCx1KX19LGZ1bmN0aW9uKGcsZSx0KXt2YXIgbj10KDExNykoImtleXMiKSxpPXQoMTE4KTtnLmV4cG9ydHM9ZnVuY3Rpb24oZil7cmV0dXJuIG5bZl18fChuW2ZdPWkoZikpfX0sZnVuY3Rpb24oZyxlLHQpe3ZhciBuPXQoOTIpLGk9dCg5MSksZj0iX19jb3JlLWpzX3NoYXJlZF9fIixoPWlbZl18fChpW2ZdPXt9KTsoZy5leHBvcnRzPWZ1bmN0aW9uKHUsYSl7cmV0dXJuIGhbdV18fChoW3VdPWEhPT12b2lkIDA/YTp7fSl9KSgidmVyc2lvbnMiLFtdKS5wdXNoKHt2ZXJzaW9uOm4udmVyc2lvbixtb2RlOnQoODkpPyJwdXJlIjoiZ2xvYmFsIixjb3B5cmlnaHQ6IsKpIDIwMTkgRGVuaXMgUHVzaGthcmV2ICh6bG9pcm9jay5ydSkifSl9LGZ1bmN0aW9uKGcsZSl7dmFyIHQ9MCxuPU1hdGgucmFuZG9tKCk7Zy5leHBvcnRzPWZ1bmN0aW9uKGkpe3JldHVybiJTeW1ib2woIi5jb25jYXQoaT09PXZvaWQgMD8iIjppLCIpXyIsKCsrdCtuKS50b1N0cmluZygzNikpfX0sZnVuY3Rpb24oZyxlKXtnLmV4cG9ydHM9ImNvbnN0cnVjdG9yLGhhc093blByb3BlcnR5LGlzUHJvdG90eXBlT2YscHJvcGVydHlJc0VudW1lcmFibGUsdG9Mb2NhbGVTdHJpbmcsdG9TdHJpbmcsdmFsdWVPZiIuc3BsaXQoIiwiKX0sZnVuY3Rpb24oZyxlLHQpe3ZhciBuPXQoOTEpLmRvY3VtZW50O2cuZXhwb3J0cz1uJiZuLmRvY3VtZW50RWxlbWVudH0sZnVuY3Rpb24oZyxlLHQpe3ZhciBuPXQoOTYpLmYsaT10KDEwNSksZj10KDEyMikoInRvU3RyaW5nVGFnIik7Zy5leHBvcnRzPWZ1bmN0aW9uKGgsdSxhKXtoJiYhaShoPWE/aDpoLnByb3RvdHlwZSxmKSYmbihoLGYse2NvbmZpZ3VyYWJsZTohMCx2YWx1ZTp1fSl9fSxmdW5jdGlvbihnLGUsdCl7dmFyIG49dCgxMTcpKCJ3a3MiKSxpPXQoMTE4KSxmPXQoOTEpLlN5bWJvbCxoPXR5cGVvZiBmPT0iZnVuY3Rpb24iLHU9Zy5leHBvcnRzPWZ1bmN0aW9uKGEpe3JldHVybiBuW2FdfHwoblthXT1oJiZmW2FdfHwoaD9mOmkpKCJTeW1ib2wuIithKSl9O3Uuc3RvcmU9bn0sZnVuY3Rpb24oZyxlLHQpe3ZhciBuPXQoMTA1KSxpPXQoMTI0KSxmPXQoMTE2KSgiSUVfUFJPVE8iKSxoPU9iamVjdC5wcm90b3R5cGU7Zy5leHBvcnRzPU9iamVjdC5nZXRQcm90b3R5cGVPZnx8ZnVuY3Rpb24odSl7cmV0dXJuIHU9aSh1KSxuKHUsZik/dVtmXTp0eXBlb2YgdS5jb25zdHJ1Y3Rvcj09ImZ1bmN0aW9uIiYmdSBpbnN0YW5jZW9mIHUuY29uc3RydWN0b3I/dS5jb25zdHJ1Y3Rvci5wcm90b3R5cGU6dSBpbnN0YW5jZW9mIE9iamVjdD9oOm51bGx9fSxmdW5jdGlvbihnLGUsdCl7dmFyIG49dCg4Nyk7Zy5leHBvcnRzPWZ1bmN0aW9uKGkpe3JldHVybiBPYmplY3QobihpKSl9fSxmdW5jdGlvbihnLGUsdCl7dmFyIG49dCgxMjYpKCEwKTt0KDg4KShTdHJpbmcsIlN0cmluZyIsZnVuY3Rpb24oaSl7dGhpcy5fdD1TdHJpbmcoaSksdGhpcy5faT0wfSxmdW5jdGlvbigpe3ZhciBpPXRoaXMuX3QsZj10aGlzLl9pLGg7cmV0dXJuIGY+PWkubGVuZ3RoP3t2YWx1ZTp2b2lkIDAsZG9uZTohMH06KGg9bihpLGYpLHRoaXMuX2krPWgubGVuZ3RoLHt2YWx1ZTpoLGRvbmU6ITF9KX0pfSxmdW5jdGlvbihnLGUsdCl7dmFyIG49dCgxMTQpLGk9dCg4Nyk7Zy5leHBvcnRzPWZ1bmN0aW9uKGYpe3JldHVybiBmdW5jdGlvbihoLHUpe3ZhciBhPVN0cmluZyhpKGgpKSxkPW4odSksRT1hLmxlbmd0aCxwLE87cmV0dXJuIGQ8MHx8ZD49RT9mPyIiOnZvaWQgMDoocD1hLmNoYXJDb2RlQXQoZCkscDw1NTI5Nnx8cD41NjMxOXx8ZCsxPT09RXx8KE89YS5jaGFyQ29kZUF0KGQrMSkpPDU2MzIwfHxPPjU3MzQzP2Y/YS5jaGFyQXQoZCk6cDpmP2Euc2xpY2UoZCxkKzIpOihwLTU1Mjk2PDwxMCkrKE8tNTYzMjApKzY1NTM2KX19fSxmdW5jdGlvbihnLGUsdCl7dmFyIG49dCgxMjgpLGk9dCgxMjIpKCJpdGVyYXRvciIpLGY9dCg4Myk7Zy5leHBvcnRzPXQoOTIpLmlzSXRlcmFibGU9ZnVuY3Rpb24oaCl7dmFyIHU9T2JqZWN0KGgpO3JldHVybiB1W2ldIT09dm9pZCAwfHwiQEBpdGVyYXRvciJpbiB1fHxmLmhhc093blByb3BlcnR5KG4odSkpfX0sZnVuY3Rpb24oZyxlLHQpe3ZhciBuPXQoODYpLGk9dCgxMjIpKCJ0b1N0cmluZ1RhZyIpLGY9bihmdW5jdGlvbigpe3JldHVybiBhcmd1bWVudHN9KCkpPT0iQXJndW1lbnRzIixoPWZ1bmN0aW9uKHUsYSl7dHJ5e3JldHVybiB1W2FdfWNhdGNoe319O2cuZXhwb3J0cz1mdW5jdGlvbih1KXt2YXIgYSxkLEU7cmV0dXJuIHU9PT12b2lkIDA/IlVuZGVmaW5lZCI6dT09PW51bGw/Ik51bGwiOnR5cGVvZihkPWgoYT1PYmplY3QodSksaSkpPT0ic3RyaW5nIj9kOmY/bihhKTooRT1uKGEpKT09Ik9iamVjdCImJnR5cGVvZiBhLmNhbGxlZT09ImZ1bmN0aW9uIj8iQXJndW1lbnRzIjpFfX0sZnVuY3Rpb24oZyxlLHQpe2cuZXhwb3J0cz17ZGVmYXVsdDp0KDEzMCksX19lc01vZHVsZTohMH19LGZ1bmN0aW9uKGcsZSx0KXt0KDc5KSx0KDEyNSksZy5leHBvcnRzPXQoMTMxKX0sZnVuY3Rpb24oZyxlLHQpe3ZhciBuPXQoOTcpLGk9dCgxMzIpO2cuZXhwb3J0cz10KDkyKS5nZXRJdGVyYXRvcj1mdW5jdGlvbihmKXt2YXIgaD1pKGYpO2lmKHR5cGVvZiBoIT0iZnVuY3Rpb24iKXRocm93IFR5cGVFcnJvcihmKyIgaXMgbm90IGl0ZXJhYmxlISIpO3JldHVybiBuKGguY2FsbChmKSl9fSxmdW5jdGlvbihnLGUsdCl7dmFyIG49dCgxMjgpLGk9dCgxMjIpKCJpdGVyYXRvciIpLGY9dCg4Myk7Zy5leHBvcnRzPXQoOTIpLmdldEl0ZXJhdG9yTWV0aG9kPWZ1bmN0aW9uKGgpe2lmKGghPW51bGwpcmV0dXJuIGhbaV18fGhbIkBAaXRlcmF0b3IiXXx8ZltuKGgpXX19LGZ1bmN0aW9uKGcsZSx0KXtlLl9fZXNNb2R1bGU9ITA7dmFyIG49dCgxMzQpLGk9ZihuKTtmdW5jdGlvbiBmKGgpe3JldHVybiBoJiZoLl9fZXNNb2R1bGU/aDp7ZGVmYXVsdDpofX1lLmRlZmF1bHQ9ZnVuY3Rpb24oaCl7aWYoQXJyYXkuaXNBcnJheShoKSl7Zm9yKHZhciB1PTAsYT1BcnJheShoLmxlbmd0aCk7dTxoLmxlbmd0aDt1KyspYVt1XT1oW3VdO3JldHVybiBhfWVsc2UgcmV0dXJuKDAsaS5kZWZhdWx0KShoKX19LGZ1bmN0aW9uKGcsZSx0KXtnLmV4cG9ydHM9e2RlZmF1bHQ6dCgxMzUpLF9fZXNNb2R1bGU6ITB9fSxmdW5jdGlvbihnLGUsdCl7dCgxMjUpLHQoMTM2KSxnLmV4cG9ydHM9dCg5MikuQXJyYXkuZnJvbX0sZnVuY3Rpb24oZyxlLHQpe3ZhciBuPXQoOTMpLGk9dCg5MCksZj10KDEyNCksaD10KDEzNyksdT10KDEzOCksYT10KDExMyksZD10KDEzOSksRT10KDEzMik7aShpLlMraS5GKiF0KDE0MCkoZnVuY3Rpb24ocCl7QXJyYXkuZnJvbShwKX0pLCJBcnJheSIse2Zyb206ZnVuY3Rpb24oTyl7dmFyIG09ZihPKSxiPXR5cGVvZiB0aGlzPT0iZnVuY3Rpb24iP3RoaXM6QXJyYXksTT1hcmd1bWVudHMubGVuZ3RoLHk9TT4xP2FyZ3VtZW50c1sxXTp2b2lkIDAsUz15IT09dm9pZCAwLHM9MCxjPUUobSksbCx2LFQsUjtpZihTJiYoeT1uKHksTT4yP2FyZ3VtZW50c1syXTp2b2lkIDAsMikpLGMhPW51bGwmJiEoYj09QXJyYXkmJnUoYykpKWZvcihSPWMuY2FsbChtKSx2PW5ldyBiOyEoVD1SLm5leHQoKSkuZG9uZTtzKyspZCh2LHMsUz9oKFIseSxbVC52YWx1ZSxzXSwhMCk6VC52YWx1ZSk7ZWxzZSBmb3IobD1hKG0ubGVuZ3RoKSx2PW5ldyBiKGwpO2w+cztzKyspZCh2LHMsUz95KG1bc10scyk6bVtzXSk7cmV0dXJuIHYubGVuZ3RoPXMsdn19KX0sZnVuY3Rpb24oZyxlLHQpe3ZhciBuPXQoOTcpO2cuZXhwb3J0cz1mdW5jdGlvbihpLGYsaCx1KXt0cnl7cmV0dXJuIHU/ZihuKGgpWzBdLGhbMV0pOmYoaCl9Y2F0Y2goZCl7dmFyIGE9aS5yZXR1cm47dGhyb3cgYSE9PXZvaWQgMCYmbihhLmNhbGwoaSkpLGR9fX0sZnVuY3Rpb24oZyxlLHQpe3ZhciBuPXQoODMpLGk9dCgxMjIpKCJpdGVyYXRvciIpLGY9QXJyYXkucHJvdG90eXBlO2cuZXhwb3J0cz1mdW5jdGlvbihoKXtyZXR1cm4gaCE9PXZvaWQgMCYmKG4uQXJyYXk9PT1ofHxmW2ldPT09aCl9fSxmdW5jdGlvbihnLGUsdCl7dmFyIG49dCg5NiksaT10KDEwNCk7Zy5leHBvcnRzPWZ1bmN0aW9uKGYsaCx1KXtoIGluIGY/bi5mKGYsaCxpKDAsdSkpOmZbaF09dX19LGZ1bmN0aW9uKGcsZSx0KXt2YXIgbj10KDEyMikoIml0ZXJhdG9yIiksaT0hMTt0cnl7dmFyIGY9WzddW25dKCk7Zi5yZXR1cm49ZnVuY3Rpb24oKXtpPSEwfSxBcnJheS5mcm9tKGYsZnVuY3Rpb24oKXt0aHJvdyAyfSl9Y2F0Y2h7fWcuZXhwb3J0cz1mdW5jdGlvbihoLHUpe2lmKCF1JiYhaSlyZXR1cm4hMTt2YXIgYT0hMTt0cnl7dmFyIGQ9WzddLEU9ZFtuXSgpO0UubmV4dD1mdW5jdGlvbigpe3JldHVybntkb25lOmE9ITB9fSxkW25dPWZ1bmN0aW9uKCl7cmV0dXJuIEV9LGgoZCl9Y2F0Y2h7fXJldHVybiBhfX0sZnVuY3Rpb24oZyxlLHQpe2cuZXhwb3J0cz17ZGVmYXVsdDp0KDE0MiksX19lc01vZHVsZTohMH19LGZ1bmN0aW9uKGcsZSx0KXt0KDE0MyksdCgxMjUpLHQoNzkpLHQoMTQ0KSx0KDE1NyksdCgxNjApLHQoMTYyKSxnLmV4cG9ydHM9dCg5MikuTWFwfSxmdW5jdGlvbihnLGUpe30sZnVuY3Rpb24oZyxlLHQpe3ZhciBuPXQoMTQ1KSxpPXQoMTUxKSxmPSJNYXAiO2cuZXhwb3J0cz10KDE1MikoZixmdW5jdGlvbihoKXtyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gaCh0aGlzLGFyZ3VtZW50cy5sZW5ndGg+MD9hcmd1bWVudHNbMF06dm9pZCAwKX19LHtnZXQ6ZnVuY3Rpb24odSl7dmFyIGE9bi5nZXRFbnRyeShpKHRoaXMsZiksdSk7cmV0dXJuIGEmJmEudn0sc2V0OmZ1bmN0aW9uKHUsYSl7cmV0dXJuIG4uZGVmKGkodGhpcyxmKSx1PT09MD8wOnUsYSl9fSxuLCEwKX0sZnVuY3Rpb24oZyxlLHQpe3ZhciBuPXQoOTYpLmYsaT10KDEwOCksZj10KDE0NiksaD10KDkzKSx1PXQoMTQ3KSxhPXQoMTQ4KSxkPXQoODgpLEU9dCg4MikscD10KDE0OSksTz10KDEwMCksbT10KDE1MCkuZmFzdEtleSxiPXQoMTUxKSxNPU8/Il9zIjoic2l6ZSIseT1mdW5jdGlvbihTLHMpe3ZhciBjPW0ocyksbDtpZihjIT09IkYiKXJldHVybiBTLl9pW2NdO2ZvcihsPVMuX2Y7bDtsPWwubilpZihsLms9PXMpcmV0dXJuIGx9O2cuZXhwb3J0cz17Z2V0Q29uc3RydWN0b3I6ZnVuY3Rpb24oUyxzLGMsbCl7dmFyIHY9UyhmdW5jdGlvbihULFIpe3UoVCx2LHMsIl9pIiksVC5fdD1zLFQuX2k9aShudWxsKSxULl9mPXZvaWQgMCxULl9sPXZvaWQgMCxUW01dPTAsUiE9bnVsbCYmYShSLGMsVFtsXSxUKX0pO3JldHVybiBmKHYucHJvdG90eXBlLHtjbGVhcjpmdW5jdGlvbigpe2Zvcih2YXIgUj1iKHRoaXMscyksTD1SLl9pLE49Ui5fZjtOO049Ti5uKU4ucj0hMCxOLnAmJihOLnA9Ti5wLm49dm9pZCAwKSxkZWxldGUgTFtOLmldO1IuX2Y9Ui5fbD12b2lkIDAsUltNXT0wfSxkZWxldGU6ZnVuY3Rpb24oVCl7dmFyIFI9Yih0aGlzLHMpLEw9eShSLFQpO2lmKEwpe3ZhciBOPUwubixBPUwucDtkZWxldGUgUi5faVtMLmldLEwucj0hMCxBJiYoQS5uPU4pLE4mJihOLnA9QSksUi5fZj09TCYmKFIuX2Y9TiksUi5fbD09TCYmKFIuX2w9QSksUltNXS0tfXJldHVybiEhTH0sZm9yRWFjaDpmdW5jdGlvbihSKXtiKHRoaXMscyk7Zm9yKHZhciBMPWgoUixhcmd1bWVudHMubGVuZ3RoPjE/YXJndW1lbnRzWzFdOnZvaWQgMCwzKSxOO049Tj9OLm46dGhpcy5fZjspZm9yKEwoTi52LE4uayx0aGlzKTtOJiZOLnI7KU49Ti5wfSxoYXM6ZnVuY3Rpb24oUil7cmV0dXJuISF5KGIodGhpcyxzKSxSKX19KSxPJiZuKHYucHJvdG90eXBlLCJzaXplIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGIodGhpcyxzKVtNXX19KSx2fSxkZWY6ZnVuY3Rpb24oUyxzLGMpe3ZhciBsPXkoUyxzKSx2LFQ7cmV0dXJuIGw/bC52PWM6KFMuX2w9bD17aTpUPW0ocywhMCksazpzLHY6YyxwOnY9Uy5fbCxuOnZvaWQgMCxyOiExfSxTLl9mfHwoUy5fZj1sKSx2JiYodi5uPWwpLFNbTV0rKyxUIT09IkYiJiYoUy5faVtUXT1sKSksU30sZ2V0RW50cnk6eSxzZXRTdHJvbmc6ZnVuY3Rpb24oUyxzLGMpe2QoUyxzLGZ1bmN0aW9uKGwsdil7dGhpcy5fdD1iKGwscyksdGhpcy5faz12LHRoaXMuX2w9dm9pZCAwfSxmdW5jdGlvbigpe2Zvcih2YXIgbD10aGlzLHY9bC5fayxUPWwuX2w7VCYmVC5yOylUPVQucDtyZXR1cm4hbC5fdHx8IShsLl9sPVQ9VD9ULm46bC5fdC5fZik/KGwuX3Q9dm9pZCAwLEUoMSkpOnY9PSJrZXlzIj9FKDAsVC5rKTp2PT0idmFsdWVzIj9FKDAsVC52KTpFKDAsW1QuayxULnZdKX0sYz8iZW50cmllcyI6InZhbHVlcyIsIWMsITApLHAocyl9fX0sZnVuY3Rpb24oZyxlLHQpe3ZhciBuPXQoOTUpO2cuZXhwb3J0cz1mdW5jdGlvbihpLGYsaCl7Zm9yKHZhciB1IGluIGYpaCYmaVt1XT9pW3VdPWZbdV06bihpLHUsZlt1XSk7cmV0dXJuIGl9fSxmdW5jdGlvbihnLGUpe2cuZXhwb3J0cz1mdW5jdGlvbih0LG4saSxmKXtpZighKHQgaW5zdGFuY2VvZiBuKXx8ZiE9PXZvaWQgMCYmZiBpbiB0KXRocm93IFR5cGVFcnJvcihpKyI6IGluY29ycmVjdCBpbnZvY2F0aW9uISIpO3JldHVybiB0fX0sZnVuY3Rpb24oZyxwLHQpe3ZhciBuPXQoOTMpLGk9dCgxMzcpLGY9dCgxMzgpLGg9dCg5NyksdT10KDExMyksYT10KDEzMiksZD17fSxFPXt9LHA9Zy5leHBvcnRzPWZ1bmN0aW9uKE8sbSxiLE0seSl7dmFyIFM9eT9mdW5jdGlvbigpe3JldHVybiBPfTphKE8pLHM9bihiLE0sbT8yOjEpLGM9MCxsLHYsVCxSO2lmKHR5cGVvZiBTIT0iZnVuY3Rpb24iKXRocm93IFR5cGVFcnJvcihPKyIgaXMgbm90IGl0ZXJhYmxlISIpO2lmKGYoUykpe2ZvcihsPXUoTy5sZW5ndGgpO2w+YztjKyspaWYoUj1tP3MoaCh2PU9bY10pWzBdLHZbMV0pOnMoT1tjXSksUj09PWR8fFI9PT1FKXJldHVybiBSfWVsc2UgZm9yKFQ9Uy5jYWxsKE8pOyEodj1ULm5leHQoKSkuZG9uZTspaWYoUj1pKFQscyx2LnZhbHVlLG0pLFI9PT1kfHxSPT09RSlyZXR1cm4gUn07cC5CUkVBSz1kLHAuUkVUVVJOPUV9LGZ1bmN0aW9uKGcsZSx0KXt2YXIgbj10KDkxKSxpPXQoOTIpLGY9dCg5NiksaD10KDEwMCksdT10KDEyMikoInNwZWNpZXMiKTtnLmV4cG9ydHM9ZnVuY3Rpb24oYSl7dmFyIGQ9dHlwZW9mIGlbYV09PSJmdW5jdGlvbiI/aVthXTpuW2FdO2gmJmQmJiFkW3VdJiZmLmYoZCx1LHtjb25maWd1cmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9fSl9fSxmdW5jdGlvbihnLGUsdCl7dmFyIG49dCgxMTgpKCJtZXRhIiksaT10KDk4KSxmPXQoMTA1KSxoPXQoOTYpLmYsdT0wLGE9T2JqZWN0LmlzRXh0ZW5zaWJsZXx8ZnVuY3Rpb24oKXtyZXR1cm4hMH0sZD0hdCgxMDEpKGZ1bmN0aW9uKCl7cmV0dXJuIGEoT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKHt9KSl9KSxFPWZ1bmN0aW9uKE0pe2goTSxuLHt2YWx1ZTp7aToiTyIrICsrdSx3Ont9fX0pfSxwPWZ1bmN0aW9uKE0seSl7aWYoIWkoTSkpcmV0dXJuIHR5cGVvZiBNPT0ic3ltYm9sIj9NOih0eXBlb2YgTT09InN0cmluZyI/IlMiOiJQIikrTTtpZighZihNLG4pKXtpZighYShNKSlyZXR1cm4iRiI7aWYoIXkpcmV0dXJuIkUiO0UoTSl9cmV0dXJuIE1bbl0uaX0sTz1mdW5jdGlvbihNLHkpe2lmKCFmKE0sbikpe2lmKCFhKE0pKXJldHVybiEwO2lmKCF5KXJldHVybiExO0UoTSl9cmV0dXJuIE1bbl0ud30sbT1mdW5jdGlvbihNKXtyZXR1cm4gZCYmYi5ORUVEJiZhKE0pJiYhZihNLG4pJiZFKE0pLE19LGI9Zy5leHBvcnRzPXtLRVk6bixORUVEOiExLGZhc3RLZXk6cCxnZXRXZWFrOk8sb25GcmVlemU6bX19LGZ1bmN0aW9uKGcsZSx0KXt2YXIgbj10KDk4KTtnLmV4cG9ydHM9ZnVuY3Rpb24oaSxmKXtpZighbihpKXx8aS5fdCE9PWYpdGhyb3cgVHlwZUVycm9yKCJJbmNvbXBhdGlibGUgcmVjZWl2ZXIsICIrZisiIHJlcXVpcmVkISIpO3JldHVybiBpfX0sZnVuY3Rpb24oZyxlLHQpe3ZhciBuPXQoOTEpLGk9dCg5MCksZj10KDE1MCksaD10KDEwMSksdT10KDk1KSxhPXQoMTQ2KSxkPXQoMTQ4KSxFPXQoMTQ3KSxwPXQoOTgpLE89dCgxMjEpLG09dCg5NikuZixiPXQoMTUzKSgwKSxNPXQoMTAwKTtnLmV4cG9ydHM9ZnVuY3Rpb24oeSxTLHMsYyxsLHYpe3ZhciBUPW5beV0sUj1ULEw9bD8ic2V0IjoiYWRkIixOPVImJlIucHJvdG90eXBlLEE9e307cmV0dXJuIU18fHR5cGVvZiBSIT0iZnVuY3Rpb24ifHwhKHZ8fE4uZm9yRWFjaCYmIWgoZnVuY3Rpb24oKXtuZXcgUigpLmVudHJpZXMoKS5uZXh0KCl9KSk/KFI9Yy5nZXRDb25zdHJ1Y3RvcihTLHksbCxMKSxhKFIucHJvdG90eXBlLHMpLGYuTkVFRD0hMCk6KFI9UyhmdW5jdGlvbih3LEIpe0UodyxSLHksIl9jIiksdy5fYz1uZXcgVCxCIT1udWxsJiZkKEIsbCx3W0xdLHcpfSksYigiYWRkLGNsZWFyLGRlbGV0ZSxmb3JFYWNoLGdldCxoYXMsc2V0LGtleXMsdmFsdWVzLGVudHJpZXMsdG9KU09OIi5zcGxpdCgiLCIpLGZ1bmN0aW9uKHcpe3ZhciBCPXc9PSJhZGQifHx3PT0ic2V0Ijt3IGluIE4mJiEodiYmdz09ImNsZWFyIikmJnUoUi5wcm90b3R5cGUsdyxmdW5jdGlvbihELEkpe2lmKEUodGhpcyxSLHcpLCFCJiZ2JiYhcChEKSlyZXR1cm4gdz09ImdldCI/dm9pZCAwOiExO3ZhciBqPXRoaXMuX2Nbd10oRD09PTA/MDpELEkpO3JldHVybiBCP3RoaXM6an0pfSksdnx8bShSLnByb3RvdHlwZSwic2l6ZSIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9jLnNpemV9fSkpLE8oUix5KSxBW3ldPVIsaShpLkcraS5XK2kuRixBKSx2fHxjLnNldFN0cm9uZyhSLHksbCksUn19LGZ1bmN0aW9uKGcsZSx0KXt2YXIgbj10KDkzKSxpPXQoODUpLGY9dCgxMjQpLGg9dCgxMTMpLHU9dCgxNTQpO2cuZXhwb3J0cz1mdW5jdGlvbihhLGQpe3ZhciBFPWE9PTEscD1hPT0yLE89YT09MyxtPWE9PTQsYj1hPT02LE09YT09NXx8Yix5PWR8fHU7cmV0dXJuIGZ1bmN0aW9uKFMscyxjKXtmb3IodmFyIGw9ZihTKSx2PWkobCksVD1uKHMsYywzKSxSPWgodi5sZW5ndGgpLEw9MCxOPUU/eShTLFIpOnA/eShTLDApOnZvaWQgMCxBLHc7Uj5MO0wrKylpZigoTXx8TCBpbiB2KSYmKEE9dltMXSx3PVQoQSxMLGwpLGEpKXtpZihFKU5bTF09dztlbHNlIGlmKHcpc3dpdGNoKGEpe2Nhc2UgMzpyZXR1cm4hMDtjYXNlIDU6cmV0dXJuIEE7Y2FzZSA2OnJldHVybiBMO2Nhc2UgMjpOLnB1c2goQSl9ZWxzZSBpZihtKXJldHVybiExfXJldHVybiBiPy0xOk98fG0/bTpOfX19LGZ1bmN0aW9uKGcsZSx0KXt2YXIgbj10KDE1NSk7Zy5leHBvcnRzPWZ1bmN0aW9uKGksZil7cmV0dXJuIG5ldyhuKGkpKShmKX19LGZ1bmN0aW9uKGcsZSx0KXt2YXIgbj10KDk4KSxpPXQoMTU2KSxmPXQoMTIyKSgic3BlY2llcyIpO2cuZXhwb3J0cz1mdW5jdGlvbihoKXt2YXIgdTtyZXR1cm4gaShoKSYmKHU9aC5jb25zdHJ1Y3Rvcix0eXBlb2YgdT09ImZ1bmN0aW9uIiYmKHU9PT1BcnJheXx8aSh1LnByb3RvdHlwZSkpJiYodT12b2lkIDApLG4odSkmJih1PXVbZl0sdT09PW51bGwmJih1PXZvaWQgMCkpKSx1PT09dm9pZCAwP0FycmF5OnV9fSxmdW5jdGlvbihnLGUsdCl7dmFyIG49dCg4Nik7Zy5leHBvcnRzPUFycmF5LmlzQXJyYXl8fGZ1bmN0aW9uKGYpe3JldHVybiBuKGYpPT0iQXJyYXkifX0sZnVuY3Rpb24oZyxlLHQpe3ZhciBuPXQoOTApO24obi5QK24uUiwiTWFwIix7dG9KU09OOnQoMTU4KSgiTWFwIil9KX0sZnVuY3Rpb24oZyxlLHQpe3ZhciBuPXQoMTI4KSxpPXQoMTU5KTtnLmV4cG9ydHM9ZnVuY3Rpb24oZil7cmV0dXJuIGZ1bmN0aW9uKCl7aWYobih0aGlzKSE9Zil0aHJvdyBUeXBlRXJyb3IoZisiI3RvSlNPTiBpc24ndCBnZW5lcmljIik7cmV0dXJuIGkodGhpcyl9fX0sZnVuY3Rpb24oZyxlLHQpe3ZhciBuPXQoMTQ4KTtnLmV4cG9ydHM9ZnVuY3Rpb24oaSxmKXt2YXIgaD1bXTtyZXR1cm4gbihpLCExLGgucHVzaCxoLGYpLGh9fSxmdW5jdGlvbihnLGUsdCl7dCgxNjEpKCJNYXAiKX0sZnVuY3Rpb24oZyxlLHQpe3ZhciBuPXQoOTApO2cuZXhwb3J0cz1mdW5jdGlvbihpKXtuKG4uUyxpLHtvZjpmdW5jdGlvbigpe2Zvcih2YXIgaD1hcmd1bWVudHMubGVuZ3RoLHU9bmV3IEFycmF5KGgpO2gtLTspdVtoXT1hcmd1bWVudHNbaF07cmV0dXJuIG5ldyB0aGlzKHUpfX0pfX0sZnVuY3Rpb24oZyxlLHQpe3QoMTYzKSgiTWFwIil9LGZ1bmN0aW9uKGcsZSx0KXt2YXIgbj10KDkwKSxpPXQoOTQpLGY9dCg5MyksaD10KDE0OCk7Zy5leHBvcnRzPWZ1bmN0aW9uKHUpe24obi5TLHUse2Zyb206ZnVuY3Rpb24oZCl7dmFyIEU9YXJndW1lbnRzWzFdLHAsTyxtLGI7cmV0dXJuIGkodGhpcykscD1FIT09dm9pZCAwLHAmJmkoRSksZD09bnVsbD9uZXcgdGhpczooTz1bXSxwPyhtPTAsYj1mKEUsYXJndW1lbnRzWzJdLDIpLGgoZCwhMSxmdW5jdGlvbihNKXtPLnB1c2goYihNLG0rKykpfSkpOmgoZCwhMSxPLnB1c2gsTyksbmV3IHRoaXMoTykpfX0pfX0sZnVuY3Rpb24oZyxlLHQpe2cuZXhwb3J0cz17ZGVmYXVsdDp0KDE2NSksX19lc01vZHVsZTohMH19LGZ1bmN0aW9uKGcsZSx0KXt0KDE2NiksZy5leHBvcnRzPXQoOTIpLk9iamVjdC5hc3NpZ259LGZ1bmN0aW9uKGcsZSx0KXt2YXIgbj10KDkwKTtuKG4uUytuLkYsIk9iamVjdCIse2Fzc2lnbjp0KDE2Nyl9KX0sZnVuY3Rpb24oZyxlLHQpe3ZhciBuPXQoMTAwKSxpPXQoMTEwKSxmPXQoMTY4KSxoPXQoMTY5KSx1PXQoMTI0KSxhPXQoODUpLGQ9T2JqZWN0LmFzc2lnbjtnLmV4cG9ydHM9IWR8fHQoMTAxKShmdW5jdGlvbigpe3ZhciBFPXt9LHA9e30sTz1TeW1ib2woKSxtPSJhYmNkZWZnaGlqa2xtbm9wcXJzdCI7cmV0dXJuIEVbT109NyxtLnNwbGl0KCIiKS5mb3JFYWNoKGZ1bmN0aW9uKGIpe3BbYl09Yn0pLGQoe30sRSlbT10hPTd8fE9iamVjdC5rZXlzKGQoe30scCkpLmpvaW4oIiIpIT1tfSk/ZnVuY3Rpb24ocCxPKXtmb3IodmFyIG09dShwKSxiPWFyZ3VtZW50cy5sZW5ndGgsTT0xLHk9Zi5mLFM9aC5mO2I+TTspZm9yKHZhciBzPWEoYXJndW1lbnRzW00rK10pLGM9eT9pKHMpLmNvbmNhdCh5KHMpKTppKHMpLGw9Yy5sZW5ndGgsdj0wLFQ7bD52OylUPWNbdisrXSwoIW58fFMuY2FsbChzLFQpKSYmKG1bVF09c1tUXSk7cmV0dXJuIG19OmR9LGZ1bmN0aW9uKGcsZSl7ZS5mPU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHN9LGZ1bmN0aW9uKGcsZSl7ZS5mPXt9LnByb3BlcnR5SXNFbnVtZXJhYmxlfSxmdW5jdGlvbihnLGUsdCl7ZS5fX2VzTW9kdWxlPSEwLGUuZGVmYXVsdD1mdW5jdGlvbihuLGkpe2lmKCEobiBpbnN0YW5jZW9mIGkpKXRocm93IG5ldyBUeXBlRXJyb3IoIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbiIpfX0sZnVuY3Rpb24oZyxlLHQpe2UuX19lc01vZHVsZT0hMDt2YXIgbj10KDE3MiksaT1mKG4pO2Z1bmN0aW9uIGYoaCl7cmV0dXJuIGgmJmguX19lc01vZHVsZT9oOntkZWZhdWx0Omh9fWUuZGVmYXVsdD1mdW5jdGlvbigpe2Z1bmN0aW9uIGgodSxhKXtmb3IodmFyIGQ9MDtkPGEubGVuZ3RoO2QrKyl7dmFyIEU9YVtkXTtFLmVudW1lcmFibGU9RS5lbnVtZXJhYmxlfHwhMSxFLmNvbmZpZ3VyYWJsZT0hMCwidmFsdWUiaW4gRSYmKEUud3JpdGFibGU9ITApLCgwLGkuZGVmYXVsdCkodSxFLmtleSxFKX19cmV0dXJuIGZ1bmN0aW9uKHUsYSxkKXtyZXR1cm4gYSYmaCh1LnByb3RvdHlwZSxhKSxkJiZoKHUsZCksdX19KCl9LGZ1bmN0aW9uKGcsZSx0KXtnLmV4cG9ydHM9e2RlZmF1bHQ6dCgxNzMpLF9fZXNNb2R1bGU6ITB9fSxmdW5jdGlvbihnLGUsdCl7dCgxNzQpO3ZhciBuPXQoOTIpLk9iamVjdDtnLmV4cG9ydHM9ZnVuY3Rpb24oZixoLHUpe3JldHVybiBuLmRlZmluZVByb3BlcnR5KGYsaCx1KX19LGZ1bmN0aW9uKGcsZSx0KXt2YXIgbj10KDkwKTtuKG4uUytuLkYqIXQoMTAwKSwiT2JqZWN0Iix7ZGVmaW5lUHJvcGVydHk6dCg5NikuZn0pfSxmdW5jdGlvbihnLGUsdCl7Zy5leHBvcnRzPXtkZWZhdWx0OnQoMTc2KSxfX2VzTW9kdWxlOiEwfX0sZnVuY3Rpb24oZyxlLHQpe3QoMTc3KSx0KDE0MyksdCgxODQpLHQoMTg1KSxnLmV4cG9ydHM9dCg5MikuU3ltYm9sfSxmdW5jdGlvbihnLGUsdCl7dmFyIG49dCg5MSksaT10KDEwNSksZj10KDEwMCksaD10KDkwKSx1PXQoMTA2KSxhPXQoMTUwKS5LRVksZD10KDEwMSksRT10KDExNykscD10KDEyMSksTz10KDExOCksbT10KDEyMiksYj10KDE3OCksTT10KDE3OSkseT10KDE4MCksUz10KDE1Nikscz10KDk3KSxjPXQoOTgpLGw9dCgxMjQpLHY9dCg4NCksVD10KDEwMyksUj10KDEwNCksTD10KDEwOCksTj10KDE4MSksQT10KDE4Myksdz10KDE2OCksQj10KDk2KSxEPXQoMTEwKSxJPUEuZixqPUIuZixWPU4uZixKPW4uU3ltYm9sLF89bi5KU09OLHN0PV8mJl8uc3RyaW5naWZ5LEc9InByb3RvdHlwZSIsWT1tKCJfaGlkZGVuIikscnQ9bSgidG9QcmltaXRpdmUiKSxvdD17fS5wcm9wZXJ0eUlzRW51bWVyYWJsZSxhdD1FKCJzeW1ib2wtcmVnaXN0cnkiKSxodD1FKCJzeW1ib2xzIiksaXQ9RSgib3Atc3ltYm9scyIpLE10PU9iamVjdFtHXSxPdD10eXBlb2YgSj09ImZ1bmN0aW9uIiYmISF3LmYsVT1uLlFPYmplY3QsJD0hVXx8IVVbR118fCFVW0ddLmZpbmRDaGlsZCxRPWYmJmQoZnVuY3Rpb24oKXtyZXR1cm4gTChqKHt9LCJhIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGoodGhpcywiYSIse3ZhbHVlOjd9KS5hfX0pKS5hIT03fSk/ZnVuY3Rpb24oZ3QsZHQsbXQpe3ZhciBidD1JKE10LGR0KTtidCYmZGVsZXRlIE10W2R0XSxqKGd0LGR0LG10KSxidCYmZ3QhPT1NdCYmaihNdCxkdCxidCl9OmosdHQ9ZnVuY3Rpb24oZ3Qpe3ZhciBkdD1odFtndF09TChKW0ddKTtyZXR1cm4gZHQuX2s9Z3QsZHR9LEY9T3QmJnR5cGVvZiBKLml0ZXJhdG9yPT0ic3ltYm9sIj9mdW5jdGlvbihndCl7cmV0dXJuIHR5cGVvZiBndD09InN5bWJvbCJ9OmZ1bmN0aW9uKGd0KXtyZXR1cm4gZ3QgaW5zdGFuY2VvZiBKfSxIPWZ1bmN0aW9uKGR0LG10LGJ0KXtyZXR1cm4gZHQ9PT1NdCYmSChpdCxtdCxidCkscyhkdCksbXQ9VChtdCwhMCkscyhidCksaShodCxtdCk/KGJ0LmVudW1lcmFibGU/KGkoZHQsWSkmJmR0W1ldW210XSYmKGR0W1ldW210XT0hMSksYnQ9TChidCx7ZW51bWVyYWJsZTpSKDAsITEpfSkpOihpKGR0LFkpfHxqKGR0LFksUigxLHt9KSksZHRbWV1bbXRdPSEwKSxRKGR0LG10LGJ0KSk6aihkdCxtdCxidCl9LHg9ZnVuY3Rpb24oZHQsbXQpe3MoZHQpO2Zvcih2YXIgYnQ9eShtdD12KG10KSksQ3Q9MCxTdD1idC5sZW5ndGgsTnQ7U3Q+Q3Q7KUgoZHQsTnQ9YnRbQ3QrK10sbXRbTnRdKTtyZXR1cm4gZHR9LFA9ZnVuY3Rpb24oZHQsbXQpe3JldHVybiBtdD09PXZvaWQgMD9MKGR0KTp4KEwoZHQpLG10KX0sVz1mdW5jdGlvbihkdCl7dmFyIG10PW90LmNhbGwodGhpcyxkdD1UKGR0LCEwKSk7cmV0dXJuIHRoaXM9PT1NdCYmaShodCxkdCkmJiFpKGl0LGR0KT8hMTptdHx8IWkodGhpcyxkdCl8fCFpKGh0LGR0KXx8aSh0aGlzLFkpJiZ0aGlzW1ldW2R0XT9tdDohMH0sSz1mdW5jdGlvbihkdCxtdCl7aWYoZHQ9dihkdCksbXQ9VChtdCwhMCksIShkdD09PU10JiZpKGh0LG10KSYmIWkoaXQsbXQpKSl7dmFyIGJ0PUkoZHQsbXQpO3JldHVybiBidCYmaShodCxtdCkmJiEoaShkdCxZKSYmZHRbWV1bbXRdKSYmKGJ0LmVudW1lcmFibGU9ITApLGJ0fX0sWj1mdW5jdGlvbihkdCl7Zm9yKHZhciBtdD1WKHYoZHQpKSxidD1bXSxDdD0wLFN0O210Lmxlbmd0aD5DdDspIWkoaHQsU3Q9bXRbQ3QrK10pJiZTdCE9WSYmU3QhPWEmJmJ0LnB1c2goU3QpO3JldHVybiBidH0saz1mdW5jdGlvbihkdCl7Zm9yKHZhciBtdD1kdD09PU10LGJ0PVYobXQ/aXQ6dihkdCkpLEN0PVtdLFN0PTAsTnQ7YnQubGVuZ3RoPlN0OylpKGh0LE50PWJ0W1N0KytdKSYmKCFtdHx8aShNdCxOdCkpJiZDdC5wdXNoKGh0W050XSk7cmV0dXJuIEN0fTtPdHx8KEo9ZnVuY3Rpb24oKXtpZih0aGlzIGluc3RhbmNlb2YgSil0aHJvdyBUeXBlRXJyb3IoIlN5bWJvbCBpcyBub3QgYSBjb25zdHJ1Y3RvciEiKTt2YXIgZHQ9Tyhhcmd1bWVudHMubGVuZ3RoPjA/YXJndW1lbnRzWzBdOnZvaWQgMCksbXQ9ZnVuY3Rpb24oYnQpe3RoaXM9PT1NdCYmbXQuY2FsbChpdCxidCksaSh0aGlzLFkpJiZpKHRoaXNbWV0sZHQpJiYodGhpc1tZXVtkdF09ITEpLFEodGhpcyxkdCxSKDEsYnQpKX07cmV0dXJuIGYmJiQmJlEoTXQsZHQse2NvbmZpZ3VyYWJsZTohMCxzZXQ6bXR9KSx0dChkdCl9LHUoSltHXSwidG9TdHJpbmciLGZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2t9KSxBLmY9SyxCLmY9SCx0KDE4MikuZj1OLmY9Wix0KDE2OSkuZj1XLHcuZj1rLGYmJiF0KDg5KSYmdShNdCwicHJvcGVydHlJc0VudW1lcmFibGUiLFcsITApLGIuZj1mdW5jdGlvbihndCl7cmV0dXJuIHR0KG0oZ3QpKX0pLGgoaC5HK2guVytoLkYqIU90LHtTeW1ib2w6Sn0pO2Zvcih2YXIgbnQ9Imhhc0luc3RhbmNlLGlzQ29uY2F0U3ByZWFkYWJsZSxpdGVyYXRvcixtYXRjaCxyZXBsYWNlLHNlYXJjaCxzcGVjaWVzLHNwbGl0LHRvUHJpbWl0aXZlLHRvU3RyaW5nVGFnLHVuc2NvcGFibGVzIi5zcGxpdCgiLCIpLHV0PTA7bnQubGVuZ3RoPnV0OyltKG50W3V0KytdKTtmb3IodmFyIGN0PUQobS5zdG9yZSkscHQ9MDtjdC5sZW5ndGg+cHQ7KU0oY3RbcHQrK10pO2goaC5TK2guRiohT3QsIlN5bWJvbCIse2ZvcjpmdW5jdGlvbihndCl7cmV0dXJuIGkoYXQsZ3QrPSIiKT9hdFtndF06YXRbZ3RdPUooZ3QpfSxrZXlGb3I6ZnVuY3Rpb24oZHQpe2lmKCFGKGR0KSl0aHJvdyBUeXBlRXJyb3IoZHQrIiBpcyBub3QgYSBzeW1ib2whIik7Zm9yKHZhciBtdCBpbiBhdClpZihhdFttdF09PT1kdClyZXR1cm4gbXR9LHVzZVNldHRlcjpmdW5jdGlvbigpeyQ9ITB9LHVzZVNpbXBsZTpmdW5jdGlvbigpeyQ9ITF9fSksaChoLlMraC5GKiFPdCwiT2JqZWN0Iix7Y3JlYXRlOlAsZGVmaW5lUHJvcGVydHk6SCxkZWZpbmVQcm9wZXJ0aWVzOngsZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOkssZ2V0T3duUHJvcGVydHlOYW1lczpaLGdldE93blByb3BlcnR5U3ltYm9sczprfSk7dmFyIHh0PWQoZnVuY3Rpb24oKXt3LmYoMSl9KTtoKGguUytoLkYqeHQsIk9iamVjdCIse2dldE93blByb3BlcnR5U3ltYm9sczpmdW5jdGlvbihkdCl7cmV0dXJuIHcuZihsKGR0KSl9fSksXyYmaChoLlMraC5GKighT3R8fGQoZnVuY3Rpb24oKXt2YXIgZ3Q9SigpO3JldHVybiBzdChbZ3RdKSE9IltudWxsXSJ8fHN0KHthOmd0fSkhPSJ7fSJ8fHN0KE9iamVjdChndCkpIT0ie30ifSkpLCJKU09OIix7c3RyaW5naWZ5OmZ1bmN0aW9uKGR0KXtmb3IodmFyIG10PVtkdF0sYnQ9MSxDdCxTdDthcmd1bWVudHMubGVuZ3RoPmJ0OyltdC5wdXNoKGFyZ3VtZW50c1tidCsrXSk7aWYoU3Q9Q3Q9bXRbMV0sISghYyhDdCkmJmR0PT09dm9pZCAwfHxGKGR0KSkpcmV0dXJuIFMoQ3QpfHwoQ3Q9ZnVuY3Rpb24oTnQsSnQpe2lmKHR5cGVvZiBTdD09ImZ1bmN0aW9uIiYmKEp0PVN0LmNhbGwodGhpcyxOdCxKdCkpLCFGKEp0KSlyZXR1cm4gSnR9KSxtdFsxXT1DdCxzdC5hcHBseShfLG10KX19KSxKW0ddW3J0XXx8dCg5NSkoSltHXSxydCxKW0ddLnZhbHVlT2YpLHAoSiwiU3ltYm9sIikscChNYXRoLCJNYXRoIiwhMCkscChuLkpTT04sIkpTT04iLCEwKX0sZnVuY3Rpb24oZyxlLHQpe2UuZj10KDEyMil9LGZ1bmN0aW9uKGcsZSx0KXt2YXIgbj10KDkxKSxpPXQoOTIpLGY9dCg4OSksaD10KDE3OCksdT10KDk2KS5mO2cuZXhwb3J0cz1mdW5jdGlvbihhKXt2YXIgZD1pLlN5bWJvbHx8KGkuU3ltYm9sPWY/e306bi5TeW1ib2x8fHt9KTthLmNoYXJBdCgwKSE9Il8iJiYhKGEgaW4gZCkmJnUoZCxhLHt2YWx1ZTpoLmYoYSl9KX19LGZ1bmN0aW9uKGcsZSx0KXt2YXIgbj10KDExMCksaT10KDE2OCksZj10KDE2OSk7Zy5leHBvcnRzPWZ1bmN0aW9uKGgpe3ZhciB1PW4oaCksYT1pLmY7aWYoYSlmb3IodmFyIGQ9YShoKSxFPWYuZixwPTAsTztkLmxlbmd0aD5wOylFLmNhbGwoaCxPPWRbcCsrXSkmJnUucHVzaChPKTtyZXR1cm4gdX19LGZ1bmN0aW9uKGcsZSx0KXt2YXIgbj10KDg0KSxpPXQoMTgyKS5mLGY9e30udG9TdHJpbmcsaD10eXBlb2Ygd2luZG93PT0ib2JqZWN0IiYmd2luZG93JiZPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcz9PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh3aW5kb3cpOltdLHU9ZnVuY3Rpb24oYSl7dHJ5e3JldHVybiBpKGEpfWNhdGNoe3JldHVybiBoLnNsaWNlKCl9fTtnLmV4cG9ydHMuZj1mdW5jdGlvbihkKXtyZXR1cm4gaCYmZi5jYWxsKGQpPT0iW29iamVjdCBXaW5kb3ddIj91KGQpOmkobihkKSl9fSxmdW5jdGlvbihnLGUsdCl7dmFyIG49dCgxMTEpLGk9dCgxMTkpLmNvbmNhdCgibGVuZ3RoIiwicHJvdG90eXBlIik7ZS5mPU9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzfHxmdW5jdGlvbihoKXtyZXR1cm4gbihoLGkpfX0sZnVuY3Rpb24oZyxlLHQpe3ZhciBuPXQoMTY5KSxpPXQoMTA0KSxmPXQoODQpLGg9dCgxMDMpLHU9dCgxMDUpLGE9dCg5OSksZD1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO2UuZj10KDEwMCk/ZDpmdW5jdGlvbihwLE8pe2lmKHA9ZihwKSxPPWgoTywhMCksYSl0cnl7cmV0dXJuIGQocCxPKX1jYXRjaHt9aWYodShwLE8pKXJldHVybiBpKCFuLmYuY2FsbChwLE8pLHBbT10pfX0sZnVuY3Rpb24oZyxlLHQpe3QoMTc5KSgiYXN5bmNJdGVyYXRvciIpfSxmdW5jdGlvbihnLGUsdCl7dCgxNzkpKCJvYnNlcnZhYmxlIil9LGZ1bmN0aW9uKGcsZSx0KXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksZS5jcmVhdGVOb3dUaW1lPW4sZS5mb3JtYXREZWxheT1pO2Z1bmN0aW9uIG4oKXt2YXIgZj1udWxsO3JldHVybiBEYXRlLm5vdz9mPURhdGUubm93OmY9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCl9LGZ9ZnVuY3Rpb24gaShmKXtyZXR1cm4gdHlwZW9mIGY9PSJudW1iZXIiP2Y9e2RlbGF5OmZ9OiJlbnRyb3B5ImluIGYmJihmPXtkZWxheTpmLmVudHJvcHksaXNFbnRyb3B5OiEwfSksZn19LGZ1bmN0aW9uKGcsZSx0KXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksZS5kZWZhdWx0PXtkZWZhdWx0OmZ1bmN0aW9uKGksZixoLHUsYSl7cmV0dXJuIHR5cGVvZiBpPT0ibnVtYmVyIiYmdHlwZW9mIGY9PSJudW1iZXIiP2krKGgtdSkvKGEtdSkqKGYtaSk6aC11PmEtaD9mOml9fX0sZnVuY3Rpb24oZyxlLHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxlLnBhcnNlRWFzaW5nPWUuRWFzaW5ncz12b2lkIDA7dmFyIG49dCg3NiksaT1kKG4pLGY9dCgxMzMpLGg9ZChmKSx1PXQoMTQxKSxhPWQodSk7ZnVuY3Rpb24gZChTKXtyZXR1cm4gUyYmUy5fX2VzTW9kdWxlP1M6e2RlZmF1bHQ6U319dmFyIEU9dCgxODkpLHA9bmV3IGEuZGVmYXVsdDtmdW5jdGlvbiBPKCl7Zm9yKHZhciBTPWFyZ3VtZW50cy5sZW5ndGgscz1BcnJheShTKSxjPTA7YzxTO2MrKylzW2NdPWFyZ3VtZW50c1tjXTt2YXIgbD1wLmdldChzKTtyZXR1cm4gbHx8KGw9RS5hcHBseSh2b2lkIDAscykscC5zZXQocyxsKSxsKX1mdW5jdGlvbiBtKFMpe3ZhciBzPWFyZ3VtZW50cy5sZW5ndGg+MSYmYXJndW1lbnRzWzFdIT09dm9pZCAwP2FyZ3VtZW50c1sxXToiZW5kIjtyZXR1cm4gZnVuY3Rpb24oYyxsKXtmb3IodmFyIHY9MTt2PGwubGVuZ3RoO3YrKyl7dmFyIFQ9bFt2XS5vZmZzZXQ7aWYoYzw9VCl7dmFyIFI9bFt2LTFdLm9mZnNldCxMPVQsTj0oYy1SKS8oTC1SKSxBPTEvUyx3PU4vQTtyZXR1cm4gcz09PSJlbmQiP3c9TWF0aC5mbG9vcih3KTp3PU1hdGguY2VpbCh3KSxBKncqKEwtUikrUn19cmV0dXJuIDB9fWZ1bmN0aW9uIGIoUyl7dmFyIHM9L15jdWJpYy1iZXppZXJcKCguKilcKS8sYz1TLm1hdGNoKHMpO2lmKGMpe3ZhciBsPWNbMV0udHJpbSgpO3JldHVybiBsPWwuc3BsaXQoIiwiKS5tYXAoZnVuY3Rpb24oQSl7cmV0dXJuIHBhcnNlRmxvYXQoQS50cmltKCkpfSksTy5hcHBseSh2b2lkIDAsKDAsaC5kZWZhdWx0KShsKSl9aWYocz0vXnN0ZXBzXCgoLiopXCkvLGM9Uy5tYXRjaChzKSxjKXt2YXIgdj1jWzFdLnRyaW0oKTt2PXYuc3BsaXQoIiwiKS5tYXAoZnVuY3Rpb24oQSl7cmV0dXJuIEEudHJpbSgpfSk7dmFyIFQ9dixSPSgwLGkuZGVmYXVsdCkoVCwyKSxMPVJbMF0sTj1SWzFdO3JldHVybiBtKHBhcnNlSW50KEwsMTApLE4pfXJldHVybiBTfXZhciBNPXtsaW5lYXI6ZnVuY3Rpb24ocyl7cmV0dXJuIHN9LGVhc2U6TyguMjUsLjEsLjI1LDEpLCJlYXNlLWluIjpPKC40MiwwLDEsMSksImVhc2Utb3V0IjpPKDAsMCwuNTgsMSksImVhc2UtaW4tb3V0IjpPKC40MiwwLC41OCwxKSwic3RlcC1zdGFydCI6bSgxLCJzdGFydCIpLCJzdGVwLWVuZCI6bSgxLCJlbmQiKX07ZnVuY3Rpb24geShTKXtyZXR1cm4gdHlwZW9mIFM9PSJzdHJpbmciP01bU10/Uz1NW1NdOlM9YihTKTpTLnR5cGU9PT0iY3ViaWMtYmV6aWVyIj9TPU8uYXBwbHkodm9pZCAwLCgwLGguZGVmYXVsdCkoUy52YWx1ZSkpOlMudHlwZT09PSJzdGVwcyImJihTPW0oUy5zdGVwLFMucG9zKSksU31lLkVhc2luZ3M9TSxlLnBhcnNlRWFzaW5nPXl9LGZ1bmN0aW9uKGcsZSl7dmFyIHQ9NCxuPS4wMDEsaT0xZS03LGY9MTAsaD0xMSx1PTEvKGgtMSksYT10eXBlb2YgRmxvYXQzMkFycmF5PT0iZnVuY3Rpb24iO2Z1bmN0aW9uIGQoUyxzKXtyZXR1cm4gMS0zKnMrMypTfWZ1bmN0aW9uIEUoUyxzKXtyZXR1cm4gMypzLTYqU31mdW5jdGlvbiBwKFMpe3JldHVybiAzKlN9ZnVuY3Rpb24gTyhTLHMsYyl7cmV0dXJuKChkKHMsYykqUytFKHMsYykpKlMrcChzKSkqU31mdW5jdGlvbiBtKFMscyxjKXtyZXR1cm4gMypkKHMsYykqUypTKzIqRShzLGMpKlMrcChzKX1mdW5jdGlvbiBiKFMscyxjLGwsdil7dmFyIFQsUixMPTA7ZG8gUj1zKyhjLXMpLzIsVD1PKFIsbCx2KS1TLFQ+MD9jPVI6cz1SO3doaWxlKE1hdGguYWJzKFQpPmkmJisrTDxmKTtyZXR1cm4gUn1mdW5jdGlvbiBNKFMscyxjLGwpe2Zvcih2YXIgdj0wO3Y8dDsrK3Ype3ZhciBUPW0ocyxjLGwpO2lmKFQ9PT0wKXJldHVybiBzO3ZhciBSPU8ocyxjLGwpLVM7cy09Ui9UfXJldHVybiBzfWZ1bmN0aW9uIHkoUyl7cmV0dXJuIFN9Zy5leHBvcnRzPWZ1bmN0aW9uKHMsYyxsLHYpe2lmKCEoMDw9cyYmczw9MSYmMDw9bCYmbDw9MSkpdGhyb3cgbmV3IEVycm9yKCJiZXppZXIgeCB2YWx1ZXMgbXVzdCBiZSBpbiBbMCwgMV0gcmFuZ2UiKTtpZihzPT09YyYmbD09PXYpcmV0dXJuIHk7Zm9yKHZhciBUPWE/bmV3IEZsb2F0MzJBcnJheShoKTpuZXcgQXJyYXkoaCksUj0wO1I8aDsrK1IpVFtSXT1PKFIqdSxzLGwpO2Z1bmN0aW9uIEwoTil7Zm9yKHZhciBBPTAsdz0xLEI9aC0xO3chPT1CJiZUW3ddPD1OOysrdylBKz11Oy0tdzt2YXIgRD0oTi1UW3ddKS8oVFt3KzFdLVRbd10pLEk9QStEKnUsaj1tKEkscyxsKTtyZXR1cm4gaj49bj9NKE4sSSxzLGwpOmo9PT0wP0k6YihOLEEsQSt1LHMsbCl9cmV0dXJuIGZ1bmN0aW9uKEEpe3JldHVybiBBPT09MD8wOkE9PT0xPzE6TyhMKEEpLGMsdil9fX0sZnVuY3Rpb24oZyxlLHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KTt2YXIgbj10KDE5MSksaT1jKG4pLGY9dCgyMDQpLGg9YyhmKSx1PXQoMTY0KSxhPWModSksZD10KDE3MCksRT1jKGQpLHA9dCgxNzEpLE89YyhwKSxtPXQoMTc1KSxiPWMobSksTT10KDc1KSx5PWMoTSksUz10KDIwOCkscz10KDE4OCk7ZnVuY3Rpb24gYyhqKXtyZXR1cm4gaiYmai5fX2VzTW9kdWxlP2o6e2RlZmF1bHQ6an19dmFyIGw9KDAsYi5kZWZhdWx0KSgidGltaW5nIiksdj0oMCxiLmRlZmF1bHQpKCJrZXlmcmFtZXMiKSxUPSgwLGIuZGVmYXVsdCkoImluaXRTdGF0ZSIpLFI9KDAsYi5kZWZhdWx0KSgicmVhZHlEZWZlciIpLEw9KDAsYi5kZWZhdWx0KSgiZmluaXNoZWREZWZlciIpLE49KDAsYi5kZWZhdWx0KSgiZWZmZWN0cyIpLEE9KDAsYi5kZWZhdWx0KSgiYWN0aXZlUmVhZHlUaW1lciIpLHc9KDAsYi5kZWZhdWx0KSgiYWN0aXZlRmluaXNoVGltZXIiKSxCPSgwLGIuZGVmYXVsdCkoInJlbW92ZURlZmVyIiksRD17ZGVsYXk6MCxlbmREZWxheTowLGZpbGw6ImF1dG8iLGl0ZXJhdGlvbnM6MSxwbGF5YmFja1JhdGU6MSxkaXJlY3Rpb246Im5vcm1hbCIsZWFzaW5nOiJsaW5lYXIiLGVmZmVjdDpudWxsfSxJPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gaihWLEosXyl7dmFyIHN0PXRoaXM7aWYoKDAsRS5kZWZhdWx0KSh0aGlzLGopLEFycmF5LmlzQXJyYXkoVikpe3ZhciBHPVtWWzBdLFYsSl07Vj1HWzBdLEo9R1sxXSxfPUdbMl19dHlwZW9mIF89PSJudW1iZXIiJiYoXz17ZHVyYXRpb246X30pLHRoaXNbbF09KDAsYS5kZWZhdWx0KSh7fSxELF8pLHRoaXNbbF0uZWFzaW5nPSgwLHMucGFyc2VFYXNpbmcpKHRoaXNbbF0uZWFzaW5nKSx0aGlzW3ZdPSgwLFMuY2FsY3VsYXRlRnJhbWVzT2Zmc2V0KShKKTt2YXIgWT10aGlzW3ZdW3RoaXNbdl0ubGVuZ3RoLTFdO3RoaXNbVF09e30sKDAsaC5kZWZhdWx0KShZKS5mb3JFYWNoKGZ1bmN0aW9uKHJ0KXtPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoVixydCkmJnJ0IT09ImVhc2luZyImJnJ0IT09Im9mZnNldCImJihzdFtUXVtydF09VltydF0pfSksdGhpc1t2XT10aGlzW3ZdLm1hcChmdW5jdGlvbihydCl7cmV0dXJuKDAsYS5kZWZhdWx0KSh7fSxzdFtUXSxydCl9KSx0aGlzW3ZdWzBdLm9mZnNldCE9PTAmJnRoaXNbdl0udW5zaGlmdCgoMCxhLmRlZmF1bHQpKHt9LHRoaXNbVF0se29mZnNldDowfSkpLFkub2Zmc2V0PDEmJnRoaXNbdl0ucHVzaCgoMCxhLmRlZmF1bHQpKHt9LFkse29mZnNldDoxfSkpLHRoaXNbTl09e30sdGhpcy50aW1lbGluZT1udWxsfXJldHVybigwLE8uZGVmYXVsdCkoaixbe2tleToicGF1c2UiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy50aW1lbGluZS5wbGF5YmFja1JhdGU9MH19LHtrZXk6QSx2YWx1ZTpmdW5jdGlvbigpe3ZhciBKPXRoaXM7dGhpc1tSXSYmIXRoaXNbUl0udGltZXJJRCYmKHRoaXMudGltZWxpbmUuY3VycmVudFRpbWU8MD90aGlzW1JdLnRpbWVySUQ9dGhpcy50aW1lbGluZS5zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7SltSXS5yZXNvbHZlKCksZGVsZXRlIEpbUl19LHtkZWxheTotdGhpcy50aW1lbGluZS5jdXJyZW50VGltZSxoZWFkaW5nOiExfSk6dGhpc1tSXS50aW1lcklEPXRoaXMudGltZWxpbmUuc2V0VGltZW91dChmdW5jdGlvbigpe0pbUl0ucmVzb2x2ZSgpLGRlbGV0ZSBKW1JdfSx7ZGVsYXk6MCxpc0VudHJvcHk6ITB9KSl9fSx7a2V5OncsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgSj10aGlzLF89dGhpc1tsXSxzdD1fLmR1cmF0aW9uLEc9Xy5pdGVyYXRpb25zLFk9Xy5lbmREZWxheSxydD1NYXRoLmNlaWwoc3QqRytZLXRoaXMudGltZWxpbmUuY3VycmVudFRpbWUpKzE7dGhpc1tMXSYmIXRoaXNbTF0udGltZXJJRCYmKHRoaXNbTF0udGltZXJJRD10aGlzLnRpbWVsaW5lLnNldFRpbWVvdXQoZnVuY3Rpb24oKXtKW0xdLnJlc29sdmUoKSxKW0JdKFIpLEpbQl0oTCl9LHtkZWxheTpydCxoZWFkaW5nOiExfSksdGhpc1tMXS5yZXZlcnNlVGltZXJJRD10aGlzLnRpbWVsaW5lLnNldFRpbWVvdXQoZnVuY3Rpb24oKXtKW0xdLnJlc29sdmUoKSxKW0JdKFIpLEpbQl0oTCksSi50aW1lbGluZT1udWxsfSx7ZGVsYXk6LXRoaXNbbF0uZGVsYXktMSxoZWFkaW5nOiExfSkpfX0se2tleToicGxheSIsdmFsdWU6ZnVuY3Rpb24oKXtpZih0aGlzLnBsYXlTdGF0ZT09PSJmaW5pc2hlZCImJnRoaXMuY2FuY2VsKCksdGhpcy5wbGF5U3RhdGU9PT0iaWRsZSIpe2lmKHRoaXMucGxheWJhY2tSYXRlPD0wKXJldHVybjt2YXIgSj10aGlzW2xdLF89Si5kZWxheSxzdD1KLnBsYXliYWNrUmF0ZSxHPUoudGltZWxpbmU7dGhpcy50aW1lbGluZT1uZXcgeS5kZWZhdWx0KHtvcmlnaW5UaW1lOl8scGxheWJhY2tSYXRlOnN0fSxHKSx0aGlzW0FdKCksdGhpc1t3XSgpfWVsc2UgdGhpcy5wbGF5U3RhdGU9PT0icGF1c2VkIiYmKHRoaXMudGltZWxpbmUucGxheWJhY2tSYXRlPXRoaXMucGxheWJhY2tSYXRlLHRoaXNbQV0oKSl9fSx7a2V5OkIsdmFsdWU6ZnVuY3Rpb24oSil7dmFyIF89dGhpc1tKXSxzdD10aGlzLnRpbWVsaW5lO18mJnN0JiYoc3QuY2xlYXJUaW1lb3V0KF8udGltZXJJRCksXy5yZXZlcnNlVGltZXJJRCYmc3QuY2xlYXJUaW1lb3V0KF8ucmV2ZXJzZVRpbWVySUQpKSxkZWxldGUgdGhpc1tKXX19LHtrZXk6ImNhbmNlbCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzW0JdKFIpLHRoaXNbQl0oTCksdGhpcy50aW1lbGluZT1udWxsfX0se2tleToiZmluaXNoIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMudGltZWxpbmUmJih0aGlzLnRpbWVsaW5lLmN1cnJlbnRUaW1lPTEvMC90aGlzLnBsYXliYWNrUmF0ZSksdGhpc1tCXShSKSx0aGlzW0JdKEwpfX0se2tleToiYXBwbHlFZmZlY3RzIix2YWx1ZTpmdW5jdGlvbihKKXtyZXR1cm4oMCxhLmRlZmF1bHQpKHRoaXNbTl0sSil9fSx7a2V5OiJwbGF5YmFja1JhdGUiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzW2xdLnBsYXliYWNrUmF0ZX0sc2V0OmZ1bmN0aW9uKEope3RoaXMudGltZWxpbmUmJih0aGlzLnRpbWVsaW5lLnBsYXliYWNrUmF0ZT1KKSx0aGlzW2xdLnBsYXliYWNrUmF0ZT1KfX0se2tleToicGxheVN0YXRlIixnZXQ6ZnVuY3Rpb24oKXt2YXIgSj10aGlzLnRpbWVsaW5lLF89dGhpc1tsXSxzdD1fLml0ZXJhdGlvbnMsRz1fLmR1cmF0aW9uLFk9Xy5lbmREZWxheSxydD0icnVubmluZyI7aWYoSj09bnVsbClydD0iaWRsZSI7ZWxzZSBpZihKLnBhdXNlZClydD0icGF1c2VkIjtlbHNlIGlmKEouY3VycmVudFRpbWU8MClydD0icGVuZGluZyI7ZWxzZXt2YXIgb3Q9Si5jdXJyZW50VGltZS1zdCpHO290PjAmJm90PFk/cnQ9InBlbmRpbmciOm90Pj1ZJiYocnQ9ImZpbmlzaGVkIil9cmV0dXJuIHJ0fX0se2tleToicHJvZ3Jlc3MiLGdldDpmdW5jdGlvbigpe2lmKCF0aGlzLnRpbWVsaW5lKXJldHVybiAwO3ZhciBKPXRoaXNbbF0sXz1KLmR1cmF0aW9uLHN0PUouaXRlcmF0aW9ucyxHPXRoaXMudGltZWxpbmUsWT10aGlzLnBsYXlTdGF0ZSxydD12b2lkIDA7aWYoWT09PSJpZGxlIilydD0wO2Vsc2UgaWYoWT09PSJwYXVzZWQiJiZHLmN1cnJlbnRUaW1lPDApcnQ9MDtlbHNlIGlmKFk9PT0icGVuZGluZyIpaWYoRy5jdXJyZW50VGltZTwwKXJ0PTA7ZWxzZXt2YXIgb3Q9Ry5zZWVrTG9jYWxUaW1lKHN0Kl8pO3J0PSgwLFMucGVyaW9kaWNpdHkpKG90LF8pWzFdL199ZWxzZShZPT09InJ1bm5pbmcifHxZPT09InBhdXNlZCIpJiYocnQ9KDAsUy5wZXJpb2RpY2l0eSkoRy5jdXJyZW50VGltZSxfKVsxXS9fKTtyZXR1cm4gWT09PSJmaW5pc2hlZCImJihydD0oMCxTLnBlcmlvZGljaXR5KShzdCwxKVsxXSkscnR9fSx7a2V5OiJmcmFtZSIsZ2V0OmZ1bmN0aW9uKCl7dmFyIEo9dGhpcy5wbGF5U3RhdGUsXz10aGlzW1RdLHN0PXRoaXNbbF0uZmlsbDtpZihKPT09ImlkbGUiKXJldHVybiBfO3ZhciBHPXRoaXMudGltZWxpbmUuY3VycmVudFRpbWUsWT10aGlzW3ZdLnNsaWNlKDApLHJ0PSgwLFMuZ2V0UHJvZ3Jlc3MpKHRoaXMudGltZWxpbmUsdGhpc1tsXSx0aGlzLnByb2dyZXNzKSxvdD1ydC5wLGF0PXJ0LmludmVydGVkLGh0PV87cmV0dXJuIEc8MCYmSj09PSJwZW5kaW5nIj8oc3Q9PT0iYmFja3dhcmRzInx8c3Q9PT0iYm90aCIpJiYoaHQ9YXQ/WVtZLmxlbmd0aC0xXTpZWzBdKTooSiE9PSJwZW5kaW5nIiYmSiE9PSJmaW5pc2hlZCJ8fHN0PT09ImZvcndhcmRzInx8c3Q9PT0iYm90aCIpJiYoaHQ9KDAsUy5nZXRDdXJyZW50RnJhbWUpKHRoaXNbbF0sWSx0aGlzW05dLG90KSksaHR9fSx7a2V5OiJ0aW1pbmciLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzW2xdfX0se2tleToiZWZmZWN0cyIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXNbTl19fSx7a2V5OiJiYXNlVGltZWxpbmUiLHNldDpmdW5jdGlvbihKKXt0aGlzW2xdLnRpbWVsaW5lPUp9LGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzW2xdLnRpbWVsaW5lfX0se2tleToicmVhZHkiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzW1JdP3RoaXNbUl0ucHJvbWlzZTp0aGlzLnRpbWVsaW5lJiZ0aGlzLnRpbWVsaW5lLmN1cnJlbnRUaW1lPj0wJiZ0aGlzLnBsYXlTdGF0ZSE9PSJwYXVzZWQiP2kuZGVmYXVsdC5yZXNvbHZlKCk6KHRoaXNbUl09KDAsUy5kZWZlcikoKSx0aGlzLnRpbWVsaW5lJiZ0aGlzW0FdKCksdGhpc1tSXT90aGlzW1JdLnByb21pc2U6aS5kZWZhdWx0LnJlc29sdmUoKSl9fSx7a2V5OiJmaW5pc2hlZCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucGxheVN0YXRlPT09ImZpbmlzaGVkIj9pLmRlZmF1bHQucmVzb2x2ZSgpOih0aGlzW0xdfHwodGhpc1tMXT0oMCxTLmRlZmVyKSgpLHRoaXMudGltZWxpbmUmJnRoaXNbd10oKSksdGhpc1tMXS5wcm9taXNlKX19XSksan0oKTtlLmRlZmF1bHQ9SX0sZnVuY3Rpb24oZyxlLHQpe2cuZXhwb3J0cz17ZGVmYXVsdDp0KDE5MiksX19lc01vZHVsZTohMH19LGZ1bmN0aW9uKGcsZSx0KXt0KDE0MyksdCgxMjUpLHQoNzkpLHQoMTkzKSx0KDIwMiksdCgyMDMpLGcuZXhwb3J0cz10KDkyKS5Qcm9taXNlfSxmdW5jdGlvbihnLGUsdCl7dmFyIG49dCg4OSksaT10KDkxKSxmPXQoOTMpLGg9dCgxMjgpLHU9dCg5MCksYT10KDk4KSxkPXQoOTQpLEU9dCgxNDcpLHA9dCgxNDgpLE89dCgxOTQpLG09dCgxOTUpLnNldCxiPXQoMTk3KSgpLE09dCgxOTgpLHk9dCgxOTkpLFM9dCgyMDApLHM9dCgyMDEpLGM9IlByb21pc2UiLGw9aS5UeXBlRXJyb3Isdj1pLnByb2Nlc3MsVD12JiZ2LnZlcnNpb25zLFI9VCYmVC52OHx8IiIsTD1pW2NdLE49aCh2KT09InByb2Nlc3MiLEE9ZnVuY3Rpb24oKXt9LHcsQixELEksaj1CPU0uZixWPSEhZnVuY3Rpb24oKXt0cnl7dmFyIGF0PUwucmVzb2x2ZSgxKSxodD0oYXQuY29uc3RydWN0b3I9e30pW3QoMTIyKSgic3BlY2llcyIpXT1mdW5jdGlvbihpdCl7aXQoQSxBKX07cmV0dXJuKE58fHR5cGVvZiBQcm9taXNlUmVqZWN0aW9uRXZlbnQ9PSJmdW5jdGlvbiIpJiZhdC50aGVuKEEpaW5zdGFuY2VvZiBodCYmUi5pbmRleE9mKCI2LjYiKSE9PTAmJlMuaW5kZXhPZigiQ2hyb21lLzY2Iik9PT0tMX1jYXRjaHt9fSgpLEo9ZnVuY3Rpb24oYXQpe3ZhciBodDtyZXR1cm4gYShhdCkmJnR5cGVvZihodD1hdC50aGVuKT09ImZ1bmN0aW9uIj9odDohMX0sXz1mdW5jdGlvbihhdCxodCl7aWYoIWF0Ll9uKXthdC5fbj0hMDt2YXIgaXQ9YXQuX2M7YihmdW5jdGlvbigpe2Zvcih2YXIgTXQ9YXQuX3YsT3Q9YXQuX3M9PTEsVT0wLCQ9ZnVuY3Rpb24oUSl7dmFyIHR0PU90P1Eub2s6US5mYWlsLEY9US5yZXNvbHZlLEg9US5yZWplY3QseD1RLmRvbWFpbixQLFcsSzt0cnl7dHQ/KE90fHwoYXQuX2g9PTImJlkoYXQpLGF0Ll9oPTEpLHR0PT09ITA/UD1NdDooeCYmeC5lbnRlcigpLFA9dHQoTXQpLHgmJih4LmV4aXQoKSxLPSEwKSksUD09PVEucHJvbWlzZT9IKGwoIlByb21pc2UtY2hhaW4gY3ljbGUiKSk6KFc9SihQKSk/Vy5jYWxsKFAsRixIKTpGKFApKTpIKE10KX1jYXRjaChaKXt4JiYhSyYmeC5leGl0KCksSChaKX19O2l0Lmxlbmd0aD5VOykkKGl0W1UrK10pO2F0Ll9jPVtdLGF0Ll9uPSExLGh0JiYhYXQuX2gmJnN0KGF0KX0pfX0sc3Q9ZnVuY3Rpb24oYXQpe20uY2FsbChpLGZ1bmN0aW9uKCl7dmFyIGh0PWF0Ll92LGl0PUcoYXQpLE10LE90LFU7aWYoaXQmJihNdD15KGZ1bmN0aW9uKCl7Tj92LmVtaXQoInVuaGFuZGxlZFJlamVjdGlvbiIsaHQsYXQpOihPdD1pLm9udW5oYW5kbGVkcmVqZWN0aW9uKT9PdCh7cHJvbWlzZTphdCxyZWFzb246aHR9KTooVT1pLmNvbnNvbGUpJiZVLmVycm9yJiZVLmVycm9yKCJVbmhhbmRsZWQgcHJvbWlzZSByZWplY3Rpb24iLGh0KX0pLGF0Ll9oPU58fEcoYXQpPzI6MSksYXQuX2E9dm9pZCAwLGl0JiZNdC5lKXRocm93IE10LnZ9KX0sRz1mdW5jdGlvbihhdCl7cmV0dXJuIGF0Ll9oIT09MSYmKGF0Ll9hfHxhdC5fYykubGVuZ3RoPT09MH0sWT1mdW5jdGlvbihhdCl7bS5jYWxsKGksZnVuY3Rpb24oKXt2YXIgaHQ7Tj92LmVtaXQoInJlamVjdGlvbkhhbmRsZWQiLGF0KTooaHQ9aS5vbnJlamVjdGlvbmhhbmRsZWQpJiZodCh7cHJvbWlzZTphdCxyZWFzb246YXQuX3Z9KX0pfSxydD1mdW5jdGlvbihhdCl7dmFyIGh0PXRoaXM7aHQuX2R8fChodC5fZD0hMCxodD1odC5fd3x8aHQsaHQuX3Y9YXQsaHQuX3M9MixodC5fYXx8KGh0Ll9hPWh0Ll9jLnNsaWNlKCkpLF8oaHQsITApKX0sb3Q9ZnVuY3Rpb24oYXQpe3ZhciBodD10aGlzLGl0O2lmKCFodC5fZCl7aHQuX2Q9ITAsaHQ9aHQuX3d8fGh0O3RyeXtpZihodD09PWF0KXRocm93IGwoIlByb21pc2UgY2FuJ3QgYmUgcmVzb2x2ZWQgaXRzZWxmIik7KGl0PUooYXQpKT9iKGZ1bmN0aW9uKCl7dmFyIE10PXtfdzpodCxfZDohMX07dHJ5e2l0LmNhbGwoYXQsZihvdCxNdCwxKSxmKHJ0LE10LDEpKX1jYXRjaChPdCl7cnQuY2FsbChNdCxPdCl9fSk6KGh0Ll92PWF0LGh0Ll9zPTEsXyhodCwhMSkpfWNhdGNoKE10KXtydC5jYWxsKHtfdzpodCxfZDohMX0sTXQpfX19O1Z8fChMPWZ1bmN0aW9uKGh0KXtFKHRoaXMsTCxjLCJfaCIpLGQoaHQpLHcuY2FsbCh0aGlzKTt0cnl7aHQoZihvdCx0aGlzLDEpLGYocnQsdGhpcywxKSl9Y2F0Y2goaXQpe3J0LmNhbGwodGhpcyxpdCl9fSx3PWZ1bmN0aW9uKGh0KXt0aGlzLl9jPVtdLHRoaXMuX2E9dm9pZCAwLHRoaXMuX3M9MCx0aGlzLl9kPSExLHRoaXMuX3Y9dm9pZCAwLHRoaXMuX2g9MCx0aGlzLl9uPSExfSx3LnByb3RvdHlwZT10KDE0NikoTC5wcm90b3R5cGUse3RoZW46ZnVuY3Rpb24oaHQsaXQpe3ZhciBNdD1qKE8odGhpcyxMKSk7cmV0dXJuIE10Lm9rPXR5cGVvZiBodD09ImZ1bmN0aW9uIj9odDohMCxNdC5mYWlsPXR5cGVvZiBpdD09ImZ1bmN0aW9uIiYmaXQsTXQuZG9tYWluPU4/di5kb21haW46dm9pZCAwLHRoaXMuX2MucHVzaChNdCksdGhpcy5fYSYmdGhpcy5fYS5wdXNoKE10KSx0aGlzLl9zJiZfKHRoaXMsITEpLE10LnByb21pc2V9LGNhdGNoOmZ1bmN0aW9uKGF0KXtyZXR1cm4gdGhpcy50aGVuKHZvaWQgMCxhdCl9fSksRD1mdW5jdGlvbigpe3ZhciBhdD1uZXcgdzt0aGlzLnByb21pc2U9YXQsdGhpcy5yZXNvbHZlPWYob3QsYXQsMSksdGhpcy5yZWplY3Q9ZihydCxhdCwxKX0sTS5mPWo9ZnVuY3Rpb24oYXQpe3JldHVybiBhdD09PUx8fGF0PT09ST9uZXcgRChhdCk6QihhdCl9KSx1KHUuRyt1LlcrdS5GKiFWLHtQcm9taXNlOkx9KSx0KDEyMSkoTCxjKSx0KDE0OSkoYyksST10KDkyKVtjXSx1KHUuUyt1LkYqIVYsYyx7cmVqZWN0OmZ1bmN0aW9uKGh0KXt2YXIgaXQ9aih0aGlzKSxNdD1pdC5yZWplY3Q7cmV0dXJuIE10KGh0KSxpdC5wcm9taXNlfX0pLHUodS5TK3UuRioobnx8IVYpLGMse3Jlc29sdmU6ZnVuY3Rpb24oaHQpe3JldHVybiBzKG4mJnRoaXM9PT1JP0w6dGhpcyxodCl9fSksdSh1LlMrdS5GKiEoViYmdCgxNDApKGZ1bmN0aW9uKGF0KXtMLmFsbChhdCkuY2F0Y2goQSl9KSksYyx7YWxsOmZ1bmN0aW9uKGh0KXt2YXIgaXQ9dGhpcyxNdD1qKGl0KSxPdD1NdC5yZXNvbHZlLFU9TXQucmVqZWN0LCQ9eShmdW5jdGlvbigpe3ZhciBRPVtdLHR0PTAsRj0xO3AoaHQsITEsZnVuY3Rpb24oSCl7dmFyIHg9dHQrKyxQPSExO1EucHVzaCh2b2lkIDApLEYrKyxpdC5yZXNvbHZlKEgpLnRoZW4oZnVuY3Rpb24oVyl7UHx8KFA9ITAsUVt4XT1XLC0tRnx8T3QoUSkpfSxVKX0pLC0tRnx8T3QoUSl9KTtyZXR1cm4gJC5lJiZVKCQudiksTXQucHJvbWlzZX0scmFjZTpmdW5jdGlvbihodCl7dmFyIGl0PXRoaXMsTXQ9aihpdCksT3Q9TXQucmVqZWN0LFU9eShmdW5jdGlvbigpe3AoaHQsITEsZnVuY3Rpb24oJCl7aXQucmVzb2x2ZSgkKS50aGVuKE10LnJlc29sdmUsT3QpfSl9KTtyZXR1cm4gVS5lJiZPdChVLnYpLE10LnByb21pc2V9fSl9LGZ1bmN0aW9uKGcsZSx0KXt2YXIgbj10KDk3KSxpPXQoOTQpLGY9dCgxMjIpKCJzcGVjaWVzIik7Zy5leHBvcnRzPWZ1bmN0aW9uKGgsdSl7dmFyIGE9bihoKS5jb25zdHJ1Y3RvcixkO3JldHVybiBhPT09dm9pZCAwfHwoZD1uKGEpW2ZdKT09bnVsbD91OmkoZCl9fSxmdW5jdGlvbihnLGUsdCl7dmFyIG49dCg5MyksaT10KDE5NiksZj10KDEyMCksaD10KDEwMiksdT10KDkxKSxhPXUucHJvY2VzcyxkPXUuc2V0SW1tZWRpYXRlLEU9dS5jbGVhckltbWVkaWF0ZSxwPXUuTWVzc2FnZUNoYW5uZWwsTz11LkRpc3BhdGNoLG09MCxiPXt9LE09Im9ucmVhZHlzdGF0ZWNoYW5nZSIseSxTLHMsYz1mdW5jdGlvbigpe3ZhciB2PSt0aGlzO2lmKGIuaGFzT3duUHJvcGVydHkodikpe3ZhciBUPWJbdl07ZGVsZXRlIGJbdl0sVCgpfX0sbD1mdW5jdGlvbih2KXtjLmNhbGwodi5kYXRhKX07KCFkfHwhRSkmJihkPWZ1bmN0aW9uKFQpe2Zvcih2YXIgUj1bXSxMPTE7YXJndW1lbnRzLmxlbmd0aD5MOylSLnB1c2goYXJndW1lbnRzW0wrK10pO3JldHVybiBiWysrbV09ZnVuY3Rpb24oKXtpKHR5cGVvZiBUPT0iZnVuY3Rpb24iP1Q6RnVuY3Rpb24oVCksUil9LHkobSksbX0sRT1mdW5jdGlvbihUKXtkZWxldGUgYltUXX0sdCg4NikoYSk9PSJwcm9jZXNzIj95PWZ1bmN0aW9uKHYpe2EubmV4dFRpY2sobihjLHYsMSkpfTpPJiZPLm5vdz95PWZ1bmN0aW9uKHYpe08ubm93KG4oYyx2LDEpKX06cD8oUz1uZXcgcCxzPVMucG9ydDIsUy5wb3J0MS5vbm1lc3NhZ2U9bCx5PW4ocy5wb3N0TWVzc2FnZSxzLDEpKTp1LmFkZEV2ZW50TGlzdGVuZXImJnR5cGVvZiBwb3N0TWVzc2FnZT09ImZ1bmN0aW9uIiYmIXUuaW1wb3J0U2NyaXB0cz8oeT1mdW5jdGlvbih2KXt1LnBvc3RNZXNzYWdlKHYrIiIsIioiKX0sdS5hZGRFdmVudExpc3RlbmVyKCJtZXNzYWdlIixsLCExKSk6TSBpbiBoKCJzY3JpcHQiKT95PWZ1bmN0aW9uKHYpe2YuYXBwZW5kQ2hpbGQoaCgic2NyaXB0IikpW01dPWZ1bmN0aW9uKCl7Zi5yZW1vdmVDaGlsZCh0aGlzKSxjLmNhbGwodil9fTp5PWZ1bmN0aW9uKHYpe3NldFRpbWVvdXQobihjLHYsMSksMCl9KSxnLmV4cG9ydHM9e3NldDpkLGNsZWFyOkV9fSxmdW5jdGlvbihnLGUpe2cuZXhwb3J0cz1mdW5jdGlvbih0LG4saSl7dmFyIGY9aT09PXZvaWQgMDtzd2l0Y2gobi5sZW5ndGgpe2Nhc2UgMDpyZXR1cm4gZj90KCk6dC5jYWxsKGkpO2Nhc2UgMTpyZXR1cm4gZj90KG5bMF0pOnQuY2FsbChpLG5bMF0pO2Nhc2UgMjpyZXR1cm4gZj90KG5bMF0sblsxXSk6dC5jYWxsKGksblswXSxuWzFdKTtjYXNlIDM6cmV0dXJuIGY/dChuWzBdLG5bMV0sblsyXSk6dC5jYWxsKGksblswXSxuWzFdLG5bMl0pO2Nhc2UgNDpyZXR1cm4gZj90KG5bMF0sblsxXSxuWzJdLG5bM10pOnQuY2FsbChpLG5bMF0sblsxXSxuWzJdLG5bM10pfXJldHVybiB0LmFwcGx5KGksbil9fSxmdW5jdGlvbihnLGUsdCl7dmFyIG49dCg5MSksaT10KDE5NSkuc2V0LGY9bi5NdXRhdGlvbk9ic2VydmVyfHxuLldlYktpdE11dGF0aW9uT2JzZXJ2ZXIsaD1uLnByb2Nlc3MsdT1uLlByb21pc2UsYT10KDg2KShoKT09InByb2Nlc3MiO2cuZXhwb3J0cz1mdW5jdGlvbigpe3ZhciBkLEUscCxPPWZ1bmN0aW9uKCl7dmFyIHksUztmb3IoYSYmKHk9aC5kb21haW4pJiZ5LmV4aXQoKTtkOyl7Uz1kLmZuLGQ9ZC5uZXh0O3RyeXtTKCl9Y2F0Y2gocyl7dGhyb3cgZD9wKCk6RT12b2lkIDAsc319RT12b2lkIDAseSYmeS5lbnRlcigpfTtpZihhKXA9ZnVuY3Rpb24oKXtoLm5leHRUaWNrKE8pfTtlbHNlIGlmKGYmJiEobi5uYXZpZ2F0b3ImJm4ubmF2aWdhdG9yLnN0YW5kYWxvbmUpKXt2YXIgbT0hMCxiPWRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCIiKTtuZXcgZihPKS5vYnNlcnZlKGIse2NoYXJhY3RlckRhdGE6ITB9KSxwPWZ1bmN0aW9uKCl7Yi5kYXRhPW09IW19fWVsc2UgaWYodSYmdS5yZXNvbHZlKXt2YXIgTT11LnJlc29sdmUodm9pZCAwKTtwPWZ1bmN0aW9uKCl7TS50aGVuKE8pfX1lbHNlIHA9ZnVuY3Rpb24oKXtpLmNhbGwobixPKX07cmV0dXJuIGZ1bmN0aW9uKHkpe3ZhciBTPXtmbjp5LG5leHQ6dm9pZCAwfTtFJiYoRS5uZXh0PVMpLGR8fChkPVMscCgpKSxFPVN9fX0sZnVuY3Rpb24oZyxlLHQpe3ZhciBuPXQoOTQpO2Z1bmN0aW9uIGkoZil7dmFyIGgsdTt0aGlzLnByb21pc2U9bmV3IGYoZnVuY3Rpb24oYSxkKXtpZihoIT09dm9pZCAwfHx1IT09dm9pZCAwKXRocm93IFR5cGVFcnJvcigiQmFkIFByb21pc2UgY29uc3RydWN0b3IiKTtoPWEsdT1kfSksdGhpcy5yZXNvbHZlPW4oaCksdGhpcy5yZWplY3Q9bih1KX1nLmV4cG9ydHMuZj1mdW5jdGlvbihmKXtyZXR1cm4gbmV3IGkoZil9fSxmdW5jdGlvbihnLGUpe2cuZXhwb3J0cz1mdW5jdGlvbih0KXt0cnl7cmV0dXJue2U6ITEsdjp0KCl9fWNhdGNoKG4pe3JldHVybntlOiEwLHY6bn19fX0sZnVuY3Rpb24oZyxlLHQpe3ZhciBuPXQoOTEpLGk9bi5uYXZpZ2F0b3I7Zy5leHBvcnRzPWkmJmkudXNlckFnZW50fHwiIn0sZnVuY3Rpb24oZyxlLHQpe3ZhciBuPXQoOTcpLGk9dCg5OCksZj10KDE5OCk7Zy5leHBvcnRzPWZ1bmN0aW9uKGgsdSl7aWYobihoKSxpKHUpJiZ1LmNvbnN0cnVjdG9yPT09aClyZXR1cm4gdTt2YXIgYT1mLmYoaCksZD1hLnJlc29sdmU7cmV0dXJuIGQodSksYS5wcm9taXNlfX0sZnVuY3Rpb24oZyxlLHQpe3ZhciBuPXQoOTApLGk9dCg5MiksZj10KDkxKSxoPXQoMTk0KSx1PXQoMjAxKTtuKG4uUCtuLlIsIlByb21pc2UiLHtmaW5hbGx5OmZ1bmN0aW9uKGEpe3ZhciBkPWgodGhpcyxpLlByb21pc2V8fGYuUHJvbWlzZSksRT10eXBlb2YgYT09ImZ1bmN0aW9uIjtyZXR1cm4gdGhpcy50aGVuKEU/ZnVuY3Rpb24ocCl7cmV0dXJuIHUoZCxhKCkpLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gcH0pfTphLEU/ZnVuY3Rpb24ocCl7cmV0dXJuIHUoZCxhKCkpLnRoZW4oZnVuY3Rpb24oKXt0aHJvdyBwfSl9OmEpfX0pfSxmdW5jdGlvbihnLGUsdCl7dmFyIG49dCg5MCksaT10KDE5OCksZj10KDE5OSk7bihuLlMsIlByb21pc2UiLHt0cnk6ZnVuY3Rpb24oaCl7dmFyIHU9aS5mKHRoaXMpLGE9ZihoKTtyZXR1cm4oYS5lP3UucmVqZWN0OnUucmVzb2x2ZSkoYS52KSx1LnByb21pc2V9fSl9LGZ1bmN0aW9uKGcsZSx0KXtnLmV4cG9ydHM9e2RlZmF1bHQ6dCgyMDUpLF9fZXNNb2R1bGU6ITB9fSxmdW5jdGlvbihnLGUsdCl7dCgyMDYpLGcuZXhwb3J0cz10KDkyKS5PYmplY3Qua2V5c30sZnVuY3Rpb24oZyxlLHQpe3ZhciBuPXQoMTI0KSxpPXQoMTEwKTt0KDIwNykoImtleXMiLGZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKGgpe3JldHVybiBpKG4oaCkpfX0pfSxmdW5jdGlvbihnLGUsdCl7dmFyIG49dCg5MCksaT10KDkyKSxmPXQoMTAxKTtnLmV4cG9ydHM9ZnVuY3Rpb24oaCx1KXt2YXIgYT0oaS5PYmplY3R8fHt9KVtoXXx8T2JqZWN0W2hdLGQ9e307ZFtoXT11KGEpLG4obi5TK24uRipmKGZ1bmN0aW9uKCl7YSgxKX0pLCJPYmplY3QiLGQpfX0sZnVuY3Rpb24oZyxlLHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KTt2YXIgbj10KDc2KSxpPWIobiksZj10KDIwOSksaD1iKGYpLHU9dCgxNjQpLGE9Yih1KSxkPXQoMTkxKSxFPWIoZCk7ZS5kZWZlcj1NLGUucGVyaW9kaWNpdHk9eSxlLmNhbGN1bGF0ZUZyYW1lc09mZnNldD1TLGUuZ2V0UHJvZ3Jlc3M9cyxlLmdldEN1cnJlbnRGcmFtZT1sO3ZhciBwPXQoMTg4KSxPPXQoMTg3KSxtPWIoTyk7ZnVuY3Rpb24gYih2KXtyZXR1cm4gdiYmdi5fX2VzTW9kdWxlP3Y6e2RlZmF1bHQ6dn19ZnVuY3Rpb24gTSgpe3ZhciB2PXt9O3JldHVybiB2LnByb21pc2U9bmV3IEUuZGVmYXVsdChmdW5jdGlvbihULFIpe3YucmVzb2x2ZT1ULHYucmVqZWN0PVJ9KSx2fWZ1bmN0aW9uIHkodixUKXt2YXIgUj1NYXRoLmZsb29yKHYvVCksTD12LVIqVDtyZXR1cm4gTD09PTAmJlI+MCYmKEw9VCxSLS0pLFtSLExdfWZ1bmN0aW9uIFModil7dj12LnNsaWNlKDApO3ZhciBUPXZbMF0sUj12W3YubGVuZ3RoLTFdO1Iub2Zmc2V0PVIub2Zmc2V0fHwxLFQub2Zmc2V0PVQub2Zmc2V0fHwwO2Zvcih2YXIgTD0wLE49LTEsQT0wO0E8di5sZW5ndGg7QSsrKXt2YXIgdz12W0FdO2lmKHcub2Zmc2V0IT1udWxsKXt2YXIgQj1BLU47aWYoQj4xKWZvcih2YXIgRD0ody5vZmZzZXQtTCkvQixJPTA7STxCLTE7SSsrKXZbTitJKzFdLm9mZnNldD1MK0QqKEkrMSk7TD13Lm9mZnNldCxOPUF9aWYody5lYXNpbmchPW51bGwmJih3LmVhc2luZz0oMCxwLnBhcnNlRWFzaW5nKSh3LmVhc2luZykpLEE+MCl7dmFyIGo9dltBXS5lYXNpbmchPW51bGw7dltBXT0oMCxhLmRlZmF1bHQpKHt9LHZbQS0xXSx2W0FdKSxqfHxkZWxldGUgdltBXS5lYXNpbmd9fXJldHVybiB2fWZ1bmN0aW9uIHModixULFIpe3ZhciBMPXYuY3VycmVudFRpbWUsTj1ULmRpcmVjdGlvbixBPVQuZHVyYXRpb24sdz0hMTtpZihOPT09InJldmVyc2UiKVI9MS1SLHc9ITA7ZWxzZSBpZihOPT09ImFsdGVybmF0ZSJ8fE49PT0iYWx0ZXJuYXRlLXJldmVyc2UiKXt2YXIgQj1NYXRoLmZsb29yKEwvQSk7Uj09PTEmJkItLSxCJTJeTj09PSJhbHRlcm5hdGUtcmV2ZXJzZSImJihSPTEtUix3PSEwKX1yZXR1cm57cDpSLGludmVydGVkOnd9fWZ1bmN0aW9uIGModixULFIsTCl7dmFyIE49e307cmV0dXJuKDAsaC5kZWZhdWx0KShUKS5mb3JFYWNoKGZ1bmN0aW9uKEEpe3ZhciB3PSgwLGkuZGVmYXVsdCkoQSwyKSxCPXdbMF0sRD13WzFdO2lmKEIhPT0ib2Zmc2V0IiYmQiE9PSJlYXNpbmciKXt2YXIgST1SW0JdfHxSLmRlZmF1bHQsaj1JKHZbQl0sRCxMLHYub2Zmc2V0LFQub2Zmc2V0KTtqIT1udWxsJiYoTltCXT1qKX19KSxOfWZ1bmN0aW9uIGwodixULFIsTCl7dmFyIE49di5lYXNpbmcsQT12LmVmZmVjdDtBfHwoUj0oMCxhLmRlZmF1bHQpKHt9LG0uZGVmYXVsdCxSKSk7dmFyIHc9e307TD1OKEwsVCk7Zm9yKHZhciBCPTE7QjxULmxlbmd0aDtCKyspe3ZhciBEPVRbQl0sST1ELm9mZnNldDtpZihJPj1MfHxCPT09VC5sZW5ndGgtMSl7dmFyIGo9VFtCLTFdLFY9ai5vZmZzZXQsSj1qLmVhc2luZyxfPUw7aWYoSil7dmFyIHN0PUktVjtfPUooKEwtVikvc3QpKnN0K1Z9QT93PUEoaixELF8sVixJKTp3PWMoaixELFIsXyk7YnJlYWt9fXJldHVybiB3fX0sZnVuY3Rpb24oZyxlLHQpe2cuZXhwb3J0cz17ZGVmYXVsdDp0KDIxMCksX19lc01vZHVsZTohMH19LGZ1bmN0aW9uKGcsZSx0KXt0KDIxMSksZy5leHBvcnRzPXQoOTIpLk9iamVjdC5lbnRyaWVzfSxmdW5jdGlvbihnLGUsdCl7dmFyIG49dCg5MCksaT10KDIxMikoITApO24obi5TLCJPYmplY3QiLHtlbnRyaWVzOmZ1bmN0aW9uKGgpe3JldHVybiBpKGgpfX0pfSxmdW5jdGlvbihnLGUsdCl7dmFyIG49dCgxMDApLGk9dCgxMTApLGY9dCg4NCksaD10KDE2OSkuZjtnLmV4cG9ydHM9ZnVuY3Rpb24odSl7cmV0dXJuIGZ1bmN0aW9uKGEpe2Zvcih2YXIgZD1mKGEpLEU9aShkKSxwPUUubGVuZ3RoLE89MCxtPVtdLGI7cD5POyliPUVbTysrXSwoIW58fGguY2FsbChkLGIpKSYmbS5wdXNoKHU/W2IsZFtiXV06ZFtiXSk7cmV0dXJuIG19fX0sZnVuY3Rpb24oZyxlLHQpe3QucihlKSx0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3Qgbj1uZXcgTWFwO2Z1bmN0aW9uIGkoaCx1PXt9LGE9W10pe2g9aC50b0xvd2VyQ2FzZSgpO2NvbnN0IGQ9bi5nZXQoaCk7aWYoIWQpdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBub2RlOiAke2h9YCk7Y29uc3QgRT1uZXcgZCh1KTtyZXR1cm4gYS5mb3JFYWNoKHA9PntFLmFwcGVuZENoaWxkKHApfSksRX1jb25zdCBmPXtyZWdpc3Rlck5vZGUoaCx1LGE9MTAwKXtpZih1PXUudG9Mb3dlckNhc2UoKSxuLmhhcyh1KSl0aHJvdyBuZXcgVHlwZUVycm9yKGBDYW5ub3QgcmVnaXN0ZXJOb2RlLCAke3V9IGhhcyBiZWVuIHRha2VuLmApO24uc2V0KHUsaCksT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoaC5wcm90b3R5cGUse25vZGVUeXBlOnt2YWx1ZTphfSx0YWdOYW1lOnt2YWx1ZTp1LnRvVXBwZXJDYXNlKCl9LG5vZGVOYW1lOnt2YWx1ZTp1fSxvd25lckRvY3VtZW50Ont2YWx1ZTpmfSxuYW1lc3BhY2VVUkk6e3ZhbHVlOmBodHRwOi8vc3ByaXRlanMuY29tLyR7dX1gfX0pfSxjcmVhdGVFbGVtZW50OmksY3JlYXRlRWxlbWVudE5TKGgsdSl7cmV0dXJuIGkodSl9LGlzU3ByaXRlTm9kZShoKXtyZXR1cm4gbi5oYXMoaC50b0xvd2VyQ2FzZSgpKX19O2UuZGVmYXVsdD1mfSxmdW5jdGlvbihnLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiB1fSksdCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IG49U3ltYm9sKCJ0eXBlIiksaT1TeW1ib2woImJ1YmJsZXMiKSxmPVN5bWJvbCgib3JpZ2luYWxFdmVudCIpLGg9U3ltYm9sKCJkZXRhaWwiKTtjbGFzcyB1e2NvbnN0cnVjdG9yKGQse2J1YmJsZXM6RT1udWxsfT17fSl7aWYodHlwZW9mIGQ9PSJzdHJpbmciPyh0aGlzW25dPWQsdGhpc1tpXT0hIUUpOih0aGlzW25dPWQudHlwZSx0aGlzW2ZdPWQsdGhpc1tpXT1FIT1udWxsPyEhRTohIWQuYnViYmxlcyxkLmRldGFpbCYmKHRoaXNbaF09ZC5kZXRhaWwpKSwhdGhpc1tuXSl0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIGV2ZW50IHR5cGUuIik7dGhpcy5jYW5jZWxCdWJibGU9ITF9c2V0T3JpZ2luYWxFdmVudChkKXt0aGlzW2ZdPWR9Z2V0IG9yaWdpbmFsRXZlbnQoKXtyZXR1cm4gdGhpc1tmXX1nZXQgdHlwZSgpe3JldHVybiB0aGlzW25dfWdldCBidWJibGVzKCl7cmV0dXJuIHRoaXNbaV19Z2V0IGRldGFpbCgpe3JldHVybiB0aGlzW2hdfXN0b3BQcm9wYWdhdGlvbigpe3RoaXMuY2FuY2VsQnViYmxlPSEwfX19LGZ1bmN0aW9uKGcsZSx0KXt0LnIoZSksdC5kKGUsInBhcnNlRmlsdGVyU3RyaW5nIixmdW5jdGlvbigpe3JldHVybiBpfSksdC5kKGUsImFwcGx5RmlsdGVycyIsZnVuY3Rpb24oKXtyZXR1cm4gZn0pO3ZhciBuPXQoNzIpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBpKGgpe2lmKGg9aC50cmltKCksIWh8fGg9PT0ibm9uZSIpcmV0dXJuIG51bGw7Y29uc3QgdT0vXig/Oih1cmx8Ymx1cnxicmlnaHRuZXNzfGNvbnRyYXN0fGRyb3Atc2hhZG93fGdyYXlzY2FsZXxodWUtcm90YXRlfGludmVydHxvcGFjaXR5fHNhdHVyYXRlfHNlcGlhKVwoKFteKCldKig/OlwoLipcKSkqW14oKV0qKVwpKSskL2ksYT1oLm1hdGNoKC8oPzoodXJsfGJsdXJ8YnJpZ2h0bmVzc3xjb250cmFzdHxkcm9wLXNoYWRvd3xncmF5c2NhbGV8aHVlLXJvdGF0ZXxpbnZlcnR8b3BhY2l0eXxzYXR1cmF0ZXxzZXBpYSlcKChbXigpXSooPzpcKC4qXCkpKlteKCldKilcKSkrPy9pZyksZD1bXTtyZXR1cm4gYSYmYS5mb3JFYWNoKEU9Pntjb25zdCBwPUUubWF0Y2godSk7aWYoIXApdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCBmaXRsZXIgc3RyaW5nLiIpO2xldFssTyxtXT1wO089Ty50b0xvd2VyQ2FzZSgpLG09bS50cmltKCkubWF0Y2goLyhbXiggKV0rfChbXiggKV0rXCguKlwpKSkoPz1cc3wkKS9nKS5tYXAoKGIsTSk9PntsZXQgeTtyZXR1cm4gTz09PSJ1cmwifHxPPT09ImRyb3Atc2hhZG93IiYmTT09PTM/eT1iOnk9T2JqZWN0KG4udG9OdW1iZXIpKGIpLC8lJC8udGVzdChiKSYmKHkvPTEwMCkseX0pLGQucHVzaCh7dHlwZTpPLGFyZ3M6bX0pfSksZH1mdW5jdGlvbiBmKGgsdSl7aC5jbGVhckZpbHRlcigpLHUmJnUuZm9yRWFjaCgoe3R5cGU6YSxhcmdzOmR9KT0+e2xldCBFPWE7RT09PSJkcm9wLXNoYWRvdyI/RT0iZHJvcFNoYWRvdyI6RT09PSJodWUtcm90YXRlIiYmKEU9Imh1ZVJvdGF0ZSIpLGhbRV0oLi4uZCl9KX19LGZ1bmN0aW9uKGcsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIG59KSx0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gbihpLGYpe2lmKCFmKXJldHVybjtjb25zdCBoPWkuZ2V0TGlzdGVuZXJzKCJiZWZvcmVyZW5kZXIiKSx1PWkuZ2V0TGlzdGVuZXJzKCJhZnRlcnJlbmRlciIpO2gubGVuZ3RoJiYhZi5iZWZvcmVSZW5kZXI/Zi5iZWZvcmVSZW5kZXI9YT0+e2kuZGlzcGF0Y2hFdmVudCh7dHlwZToiYmVmb3JlcmVuZGVyIixkZXRhaWw6e2NvbnRleHQ6YX19KX06aC5sZW5ndGh8fChmLmJlZm9yZVJlbmRlcj1udWxsKSx1Lmxlbmd0aCYmIWYuYWZ0ZXJSZW5kZXI/Zi5hZnRlclJlbmRlcj1hPT57aS5kaXNwYXRjaEV2ZW50KHt0eXBlOiJhZnRlcnJlbmRlciIsZGV0YWlsOntjb250ZXh0OmF9fSl9OnUubGVuZ3RofHwoZi5hZnRlclJlbmRlcj1udWxsKX19LGZ1bmN0aW9uKGcsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIGR9KTt2YXIgbj10KDEyKSxpPXQoMjE4KSxmPXQoNzApLGg9dCgyMTMpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCB1PVN5bWJvbCgiYW1vdW50IiksYT1TeW1ib2woIm1lc2hDbG91ZCIpO2NsYXNzIGQgZXh0ZW5kcyBmLmRlZmF1bHR7Y29uc3RydWN0b3IocCxPPTEpe3N1cGVyKCksdGhpcy5tZXNoTm9kZT1wLHAuY29ubmVjdCh0aGlzKSx0aGlzW3VdPU8sdGhpc1thXT1udWxsfWdldCBtZXNoQ2xvdWQoKXtjb25zdCBwPXRoaXMubWVzaE5vZGUsTz10aGlzW3VdO3JldHVybiF0aGlzW2FdJiZwLm1lc2gmJih0aGlzW2FdPW5ldyBuLk1lc2hDbG91ZChwLm1lc2gsTykpLHRoaXNbYV19Z2V0IGlzVmlzaWJsZSgpe3JldHVybiEhdGhpcy5tZXNoTm9kZSYmdGhpcy5tZXNoTm9kZS5pc1Zpc2libGV9Z2V0IGFtb3VudCgpe3JldHVybiB0aGlzW3VdfXNldCBhbW91bnQocCl7dGhpc1t1XT1wLHRoaXNbYV0mJih0aGlzW2FdLmFtb3VudD1wKX1icmlnaHRuZXNzKHAsTyl7dGhpcy5tZXNoQ2xvdWQmJih0aGlzLm1lc2hDbG91ZC5icmlnaHRuZXNzKHAsTyksdGhpcy5mb3JjZVVwZGF0ZSgpKX1jb250cmFzdChwLE8pe3RoaXMubWVzaENsb3VkJiYodGhpcy5tZXNoQ2xvdWQuY29udHJhc3QocCxPKSx0aGlzLmZvcmNlVXBkYXRlKCkpfWRlbGV0ZShwKXt0aGlzLm1lc2hDbG91ZCYmKHRoaXMubWVzaENsb3VkLmRlbGV0ZShwKSx0aGlzW3VdLS0sdGhpcy5mb3JjZVVwZGF0ZSgpKX1kcmF3KHA9W10pe2lmKHN1cGVyLmRyYXcocCksdGhpcy5tZXNoQ2xvdWQpe2lmKHRoaXMucHJvZ3JhbSl7dGhpcy5tZXNoQ2xvdWQuc2V0UHJvZ3JhbSh0aGlzLnByb2dyYW0pO2NvbnN0IE89dGhpcy5zaGFkZXJBdHRycztPJiZPYmplY3QuZW50cmllcyhPKS5mb3JFYWNoKChbYixNXSk9Pnt0aGlzLm1lc2hDbG91ZC5tZXNoLnNldEF0dHJpYnV0ZShiLE0pfSk7Y29uc3QgbT10aGlzLnVuaWZvcm1zO2lmKHRoaXMudW5pZm9ybXMpe2NvbnN0IGI9e307T2JqZWN0LmVudHJpZXMobSkuZm9yRWFjaCgoW00seV0pPT57dHlwZW9mIHk9PSJmdW5jdGlvbiImJih5PXkodGhpcyxNKSksYltNXT15fSksdGhpcy5tZXNoQ2xvdWQubWVzaC5zZXRVbmlmb3JtcyhiKX19dGhpcy5tZXNoTm9kZS50ZXh0dXJlSW1hZ2UmJk9iamVjdChpLmRyYXdUZXh0dXJlKSh0aGlzLm1lc2hOb2RlLHRoaXMubWVzaE5vZGUubWVzaCkscC5wdXNoKHRoaXMubWVzaENsb3VkKX1yZXR1cm4gcH1nZXRUcmFuc2Zvcm0ocCl7aWYodGhpcy5tZXNoQ2xvdWQpcmV0dXJuIHRoaXMubWVzaENsb3VkLmdldFRyYW5zZm9ybShwKX1ncmF5c2NhbGUocCxPKXt0aGlzLm1lc2hDbG91ZCYmKHRoaXMubWVzaENsb3VkLmdyYXlzY2FsZShwLE8pLHRoaXMuZm9yY2VVcGRhdGUoKSl9aHVlUm90YXRlKHAsTyl7dGhpcy5tZXNoQ2xvdWQmJih0aGlzLm1lc2hDbG91ZC5odWVSb3RhdGUocCxPKSx0aGlzLmZvcmNlVXBkYXRlKCkpfWludmVydChwLE8pe3RoaXMubWVzaENsb3VkJiYodGhpcy5tZXNoQ2xvdWQuaW52ZXJ0KHAsTyksdGhpcy5mb3JjZVVwZGF0ZSgpKX1pc1BvaW50Q29sbGlzaW9uKHAsTyl7aWYoIXRoaXMubWVzaENsb3VkKXJldHVybiExO2NvbnN0IG09dGhpcy5hdHRyaWJ1dGVzLnBvaW50ZXJFdmVudHM7aWYobT09PSJub25lInx8bSE9PSJhbGwiJiYhdGhpcy5pc1Zpc2libGUpcmV0dXJuITE7bGV0IGI9ImJvdGgiO209PT0idmlzaWJsZUZpbGwiJiYoYj0iZmlsbCIpLG09PT0idmlzaWJsZVN0cm9rZSImJihiPSJzdHJva2UiKTtmb3IobGV0IE09MDtNPHRoaXNbdV07TSsrKWlmKCF0aGlzLm1lc2hDbG91ZC5pc1BvaW50Q29sbGlzaW9uKE0sW3AsT10sYikpcmV0dXJuITE7cmV0dXJuITB9c2V0T3BhY2l0eShwLE8pe3RoaXMubWVzaENsb3VkJiYodGhpcy5tZXNoQ2xvdWQub3BhY2l0eShwLE8pLHRoaXMuZm9yY2VVcGRhdGUoKSl9cm90YXRlKHAsTyxbbSxiXT1bMCwwXSl7Y29uc3QgTT1NYXRoLlBJKk8vMTgwO2lmKHRoaXMubWVzaENsb3VkKXtjb25zdHt4OnkseTpTfT10aGlzLm1lc2hOb2RlLmF0dHJpYnV0ZXM7dGhpcy5tZXNoQ2xvdWQucm90YXRlKHAsTSxbbSt5LGIrU10pLHRoaXMuZm9yY2VVcGRhdGUoKX19c2F0dXJhdGUocCxPKXt0aGlzLm1lc2hDbG91ZCYmKHRoaXMubWVzaENsb3VkLnNhdHVyYXRlKHAsTyksdGhpcy5mb3JjZVVwZGF0ZSgpKX1zY2FsZShwLFtPLG09T10sW2IsTV09WzAsMF0pe2lmKHRoaXMubWVzaENsb3VkKXtjb25zdHt4OnkseTpTfT10aGlzLm1lc2hOb2RlLmF0dHJpYnV0ZXMscz0xZS01O01hdGguYWJzKE8pPHMmJihPPTEvTz4wP3M6LXMpLE1hdGguYWJzKG0pPHMmJihtPTEvbT4wP3M6LXMpLHRoaXMubWVzaENsb3VkLnNjYWxlKHAsW08sbV0sW2IreSxNK1NdKSx0aGlzLmZvcmNlVXBkYXRlKCl9fXNldENvbG9yVHJhbnNmb3JtKHAsTyl7dGhpcy5tZXNoQ2xvdWQmJih0aGlzLm1lc2hDbG91ZC5zZXRDb2xvclRyYW5zZm9ybShwLE8pLHRoaXMuZm9yY2VVcGRhdGUoKSl9c2V0RmlsbENvbG9yKHAsTyl7dGhpcy5tZXNoQ2xvdWQmJihBcnJheS5pc0FycmF5KE8pJiYoTz1bLi4uT10sT1swXS89MjU1LE9bMV0vPTI1NSxPWzJdLz0yNTUpLHRoaXMubWVzaENsb3VkLnNldEZpbGxDb2xvcihwLE8pLHRoaXMuZm9yY2VVcGRhdGUoKSl9c2VwaWEocCxPKXt0aGlzLm1lc2hDbG91ZCYmKHRoaXMubWVzaENsb3VkLnNlcGlhKHAsTyksdGhpcy5mb3JjZVVwZGF0ZSgpKX1zZXRSZXNvbHV0aW9uKHt3aWR0aDpwLGhlaWdodDpPfSl7c3VwZXIuc2V0UmVzb2x1dGlvbih7d2lkdGg6cCxoZWlnaHQ6T30pLHRoaXMubWVzaE5vZGUuc2V0UmVzb2x1dGlvbih7d2lkdGg6cCxoZWlnaHQ6T30pfXNldFN0cm9rZUNvbG9yKHAsTyl7dGhpcy5tZXNoQ2xvdWQmJihBcnJheS5pc0FycmF5KE8pJiYoTz1bLi4uT10sT1swXS89MjU1LE9bMV0vPTI1NSxPWzJdLz0yNTUpLHRoaXMubWVzaENsb3VkLnNldFN0cm9rZUNvbG9yKHAsTyksdGhpcy5mb3JjZVVwZGF0ZSgpKX1zZXRUcmFuc2Zvcm0ocCxPKXt0aGlzLm1lc2hDbG91ZCYmKHRoaXMubWVzaENsb3VkLnNldFRyYW5zZm9ybShwLE8pLHRoaXMuZm9yY2VVcGRhdGUoKSl9c2tldyhwLFtPLG09T10sW2IsTV09WzAsMF0pe2lmKHRoaXMubWVzaENsb3VkKXtjb25zdHt4OnkseTpTfT10aGlzLm1lc2hOb2RlLmF0dHJpYnV0ZXM7dGhpcy5tZXNoQ2xvdWQuc2tldyhwLFtPLG1dLFtiK3ksTStTXSksdGhpcy5mb3JjZVVwZGF0ZSgpfX10cmFuc2Zvcm0ocCxPKXt0aGlzLm1lc2hDbG91ZCYmKHRoaXMubWVzaENsb3VkLnRyYW5zZm9ybShwLE8pLHRoaXMuZm9yY2VVcGRhdGUoKSl9dHJhbnNmb3JtQ29sb3IocCxPKXt0aGlzLm1lc2hDbG91ZCYmKHRoaXMubWVzaENsb3VkLnRyYW5zZm9ybUNvbG9yKHAsTyksdGhpcy5mb3JjZVVwZGF0ZSgpKX10cmFuc2xhdGUocCxbTyxtXSl7dGhpcy5tZXNoQ2xvdWQmJih0aGlzLm1lc2hDbG91ZC50cmFuc2xhdGUocCxbTyxtXSksdGhpcy5mb3JjZVVwZGF0ZSgpKX11cGRhdGVNZXNoKCl7dGhpc1thXSYmKHRoaXNbYV0ubWVzaD10aGlzLm1lc2hOb2RlLm1lc2gsdGhpcy5mb3JjZVVwZGF0ZSgpKX19aC5kZWZhdWx0LnJlZ2lzdGVyTm9kZShkLCJjbG91ZCIpfSxmdW5jdGlvbihnLGUsdCl7dC5yKGUpLHQuZChlLCJsb2FkVGV4dHVyZSIsZnVuY3Rpb24oKXtyZXR1cm4gaH0pLHQuZChlLCJhcHBseVRleHR1cmUiLGZ1bmN0aW9uKCl7cmV0dXJuIHV9KSx0LmQoZSwiY3JlYXRlVGV4dHVyZSIsZnVuY3Rpb24oKXtyZXR1cm4gZH0pLHQuZChlLCJkZWxldGVUZXh0dXJlIixmdW5jdGlvbigpe3JldHVybiBFfSksdC5kKGUsImRyYXdUZXh0dXJlIixmdW5jdGlvbigpe3JldHVybiBPfSksdC5kKGUsImxvYWRGcmFtZXMiLGZ1bmN0aW9uKCl7cmV0dXJuIG19KTt2YXIgbj10KDEyKSxpPXQoNzIpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCBmPXt9O2Z1bmN0aW9uIGgoYixNKXtpZihmW2JdKXJldHVybiBmW2JdO2NvbnN0IHk9bi5FTlYubG9hZEltYWdlKGIse2FsaWFzOk0sdXNlSW1hZ2VCaXRtYXA6ITF9KTtyZXR1cm4geT8/Yn1hc3luYyBmdW5jdGlvbiB1KGIsTSx5KXtsZXQgUz1NO2lmKHR5cGVvZiBNPT0ic3RyaW5nIiYmKFM9aChNKSksUyYmdHlwZW9mIFMudGhlbj09ImZ1bmN0aW9uIiYmKFM9YXdhaXQgUyksTT09PWIuYXR0cmlidXRlcy50ZXh0dXJlKXtTJiZTLmltYWdlJiYoUy5zb3VyY2VSZWN0JiYoYi5hdHRyaWJ1dGVzLnNvdXJjZVJlY3Q9Uy5zb3VyY2VSZWN0KSxiLnRleHR1cmVJbWFnZVJvdGF0ZWQ9ISFTLnJvdGF0ZWQsUz1TLmltYWdlKTtjb25zdHt3aWR0aDpzLGhlaWdodDpjLHRleHR1cmVSZWN0Omx9PWIuYXR0cmlidXRlcyx2PWIudGV4dHVyZUltYWdlO2IudGV4dHVyZUltYWdlPVMseSYmdiE9PVMmJiFsJiYocz09bnVsbHx8Yz09bnVsbCkmJmIudXBkYXRlQ29udG91cnMoKSxiLmZvcmNlVXBkYXRlKCl9cmV0dXJuIFN9Y29uc3QgYT1TeW1ib2woInRleHR1cmVNYXAiKTtmdW5jdGlvbiBkKGIsTSl7aWYoTVthXT1NW2FdfHxuZXcgTWFwLE1bYV0uaGFzKGIpKXJldHVybiBNW2FdLmdldChiKTtjb25zdCB5PU0uY3JlYXRlVGV4dHVyZShiKTtyZXR1cm4hL15ibG9iOi8udGVzdChiLnNyYykmJnR5cGVvZiBiLmdldENvbnRleHQhPSJmdW5jdGlvbiImJk1bYV0uc2V0KGIseSkseX1mdW5jdGlvbiBFKGIsTSl7aWYoTVthXSYmTVthXS5oYXMoYikpe2NvbnN0IHk9TVthXS5nZXQoYik7cmV0dXJuIE0uZGVsZXRlVGV4dHVyZSh5KSxNW2FdLmRlbGV0ZShiKSwhMH1yZXR1cm4hMX1jb25zdCBwPVN5bWJvbCgidGV4dHVyZUNvbnRleHQiKTtmdW5jdGlvbiBPKGIsTSl7Y29uc3QgeT1iLnRleHR1cmVJbWFnZSBpbnN0YW5jZW9mIFN0cmluZz9TdHJpbmcoYi50ZXh0dXJlSW1hZ2UpOmIudGV4dHVyZUltYWdlLFM9Yi50ZXh0dXJlSW1hZ2VSb3RhdGVkLHM9TS50ZXh0dXJlLGM9Yi5yZW5kZXJlcjtpZih5KXtjb25zdCBsPWIub3JpZ2luYWxDb250ZW50UmVjdDtsZXQgdj1iLmF0dHJpYnV0ZXMudGV4dHVyZVJlY3Q7Y29uc3QgVD1iLmF0dHJpYnV0ZXMudGV4dHVyZVJlcGVhdCxSPWIuYXR0cmlidXRlcy5zb3VyY2VSZWN0O2lmKCFzfHxiW3BdJiZiW3BdIT09Y3x8cy5pbWFnZSE9PXl8fHMub3B0aW9ucy5yZXBlYXQhPT1UfHwhT2JqZWN0KGkuY29tcGFyZVZhbHVlKShzLm9wdGlvbnMucmVjdCx2KXx8IU9iamVjdChpLmNvbXBhcmVWYWx1ZSkocy5vcHRpb25zLnNyY1JlY3QsUikpe2NvbnN0IEw9ZCh5LGMpO3Y/KHZbMF0rPWxbMF0sdlsxXSs9bFsxXSk6dj1sO2xldCBOPW51bGw7cyYmIWNbYV0uaGFzKHMuaW1hZ2UpJiYoIXMub3B0aW9uc3x8IXMub3B0aW9ucy5oaWRkZW4pJiYoTj1NLnVuaWZvcm1zLnVfdGV4U2FtcGxlciksTS5zZXRUZXh0dXJlKEwse3JlY3Q6dixyZXBlYXQ6VCxzcmNSZWN0OlIscm90YXRlZDpTfSksTiYmTi5kZWxldGUmJk4uZGVsZXRlKCksYltwXT1jfX1lbHNlIGlmKHMpe2xldCBsPW51bGw7IWNbYV0uaGFzKHMuaW1hZ2UpJiYoIXMub3B0aW9uc3x8IXMub3B0aW9ucy5oaWRkZW4pJiYobD1NLnVuaWZvcm1zLnVfdGV4U2FtcGxlciksTS5zZXRUZXh0dXJlKG51bGwpLGwmJmwuZGVsZXRlJiZsLmRlbGV0ZSgpfX1hc3luYyBmdW5jdGlvbiBtKGIsTSl7dHlwZW9mIE09PSJzdHJpbmciJiYoTT1hd2FpdChhd2FpdCBmZXRjaChNLHttZXRob2Q6IkdFVCIsbW9kZToiY29ycyIsY2FjaGU6ImRlZmF1bHQifSkpLmpzb24oKSk7Y29uc3QgeT1hd2FpdCBoKGIpLFM9TS5mcmFtZXM7cmV0dXJuIE9iamVjdC5lbnRyaWVzKFMpLmZvckVhY2goKFtzLGNdKT0+e2NvbnN0e3g6bCx5OnYsdzpULGg6Un09Yy5mcmFtZTtsZXQgTD1bbCx2LFQsUl07Y29uc3QgTj1jLnJvdGF0ZWQ7TiYmKEw9W0xbMF0sTFsxXSxMWzNdLExbMl1dKSxmW3NdPXtpbWFnZTp5LHNvdXJjZVJlY3Q6TCxyb3RhdGVkOk59fSkseX19LGZ1bmN0aW9uKGcsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIG19KTt2YXIgbj10KDEpLGk9dCgxMiksZj10KDcwKSxoPXQoMjIwKSx1PXQoMjIxKSxhPXQoMjIyKSxkPXQoMjEzKSxFPXQoMjIzKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gcChiLE0seSl7cmV0dXJuIE0gaW4gYj9PYmplY3QuZGVmaW5lUHJvcGVydHkoYixNLHt2YWx1ZTp5LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6YltNXT15LGJ9Y29uc3QgTz1TeW1ib2woIm1lc2giKTtjbGFzcyBtIGV4dGVuZHMgZi5kZWZhdWx0e2NvbnN0cnVjdG9yKE09e30pe3N1cGVyKE0pfWdldCBib3JkZXJTaXplKCl7Y29uc3R7cGFkZGluZ1RvcDpNLHBhZGRpbmdSaWdodDp5LHBhZGRpbmdCb3R0b206UyxwYWRkaW5nTGVmdDpzLGJvcmRlcldpZHRoOmN9PXRoaXMuYXR0cmlidXRlcyxbbCx2XT10aGlzLmNvbnRlbnRTaXplO3JldHVybltzK2wreStjLE0rditTK2NdfWdldCBjbGllbnRTaXplKCl7Y29uc3R7cGFkZGluZ1RvcDpNLHBhZGRpbmdSaWdodDp5LHBhZGRpbmdCb3R0b206UyxwYWRkaW5nTGVmdDpzfT10aGlzLmF0dHJpYnV0ZXMsW2MsbF09dGhpcy5jb250ZW50U2l6ZTtyZXR1cm5bcytjK3ksTStsK1NdfWdldCBjb250ZW50U2l6ZSgpe2xldHt3aWR0aDpNLGhlaWdodDp5LGJveFNpemluZzpTLHBhZGRpbmdUb3A6cyxwYWRkaW5nUmlnaHQ6YyxwYWRkaW5nQm90dG9tOmwscGFkZGluZ0xlZnQ6dn09dGhpcy5hdHRyaWJ1dGVzO2lmKE09TXx8MCx5PXl8fDAsUz09PSJib3JkZXItYm94Iil7Y29uc3QgVD0yKnRoaXMuYXR0cmlidXRlcy5ib3JkZXJXaWR0aDtNLT1UK2Mrdix5LT1UK3MrbCxNPU1hdGgubWF4KDAsTSkseT1NYXRoLm1heCgwLHkpfXJldHVybltNLHldfWdldCBoYXNCb3JkZXIoKXtyZXR1cm4gdGhpcy5hdHRyaWJ1dGVzLmJvcmRlcldpZHRoPjB9Z2V0IGlzVmlzaWJsZSgpe2NvbnN0W00seV09dGhpcy5ib3JkZXJTaXplO3JldHVybiBNPjAmJnk+MH1nZXQgbWVzaCgpe2lmKHRoaXMuYXR0cmlidXRlcy5kaXNwbGF5PT09Im5vbmUiKXJldHVybiBudWxsO2NvbnN0IE09dGhpcy5jbGllbnRCb3g7aWYoTSl7bGV0IHk9dGhpc1tPXTtpZih5KXkuYm94IT09TSYmKHkuY29udG91cnM9TS5jb250b3Vycyx5LmJveD1NKTtlbHNle3k9bmV3IGkuTWVzaDJEKE0pLHkuYm94PU07Y29uc3Qgcz10aGlzLmF0dHJpYnV0ZXMuYmdjb2xvcjtpZihPYmplY3QodS5zZXRGaWxsQ29sb3IpKHkse2NvbG9yOnN9KSx0aGlzLmhhc0JvcmRlcil7Y29uc3R7Ym9yZGVyQ29sb3I6bCxib3JkZXJXaWR0aDp2LGJvcmRlckRhc2g6VCxib3JkZXJEYXNoT2Zmc2V0OlJ9PXRoaXMuYXR0cmlidXRlcztPYmplY3QodS5zZXRTdHJva2VDb2xvcikoeSx7Y29sb3I6bCxsaW5lV2lkdGg6dixsaW5lRGFzaDpULGxpbmVEYXNoT2Zmc2V0OlJ9KX10aGlzW09dPXk7Y29uc3QgYz10aGlzLmF0dHJpYnV0ZXMuY2xpcFBhdGg7YyYmdGhpc1tPXS5zZXRDbGlwUGF0aChjKX1jb25zdCBTPXRoaXMub3BhY2l0eTtyZXR1cm4geS5nZXRPcGFjaXR5KCkhPT1TJiZ5LnNldE9wYWNpdHkoUykseS5zZXRUcmFuc2Zvcm0oLi4udGhpcy5yZW5kZXJNYXRyaXgpLHl9cmV0dXJuIG51bGx9Z2V0IG9mZnNldFNpemUoKXtjb25zdHtwYWRkaW5nVG9wOk0scGFkZGluZ1JpZ2h0OnkscGFkZGluZ0JvdHRvbTpTLHBhZGRpbmdMZWZ0OnMsYm9yZGVyV2lkdGg6Y309dGhpcy5hdHRyaWJ1dGVzLFtsLHZdPXRoaXMuY29udGVudFNpemUsVD0yKmM7cmV0dXJuW3MrbCt5K1QsTSt2K1MrVF19Z2V0IG9yaWdpbmFsQ2xpZW50UmVjdCgpe2lmKHRoaXMubWVzaCl7Y29uc3QgTT10aGlzLm1lc2guYm91bmRpbmdCb3g7cmV0dXJuW01bMF1bMF0sTVswXVsxXSxNWzFdWzBdLU1bMF1bMF0sTVsxXVsxXS1NWzBdWzFdXX1yZXR1cm5bMCwwLDAsMF19Z2V0IG9yaWdpbmFsQ29udGVudFJlY3QoKXtjb25zdFtNLHksUyxzXT10aGlzLm9yaWdpbmFsQ2xpZW50UmVjdCxjPXRoaXMuYXR0cmlidXRlcy5wYWRkaW5nO3JldHVybltNK2NbMF0seStjWzFdLFMtY1swXS1jWzJdLHMtY1sxXS1jWzNdXX1nZXRCb3VuZGluZ0NsaWVudFJlY3QoKXtsZXQgTT10aGlzLnJlbmRlck1hdHJpeDt0aGlzLmxheWVyJiZ0aGlzLmxheWVyLmxheWVyVHJhbnNmb3JtSW52ZXJ0JiYoTT1uLm1hdDJkLm11bHRpcGx5KEFycmF5Lm9mKDAsMCwwLDAsMCwwKSx0aGlzLmxheWVyLnRyYW5zZm9ybU1hdHJpeCxNKSk7bGV0IHk9bnVsbDtpZih0aGlzLm1lc2gpe3k9Wy4uLnRoaXMubWVzaC5ib3VuZGluZ0JveF07Y29uc3QgUz10aGlzLmF0dHJpYnV0ZXMuYm9yZGVyV2lkdGg7UyYmKHlbMF09W3lbMF1bMF0tUyx5WzBdWzFdLVNdLHlbMV09W3lbMV1bMF0rUyx5WzFdWzFdK1NdKX1yZXR1cm4gT2JqZWN0KEUuZGVmYXVsdCkoeSxNKX1vblByb3BlcnR5Q2hhbmdlKE0seSxTKXtpZihzdXBlci5vblByb3BlcnR5Q2hhbmdlKE0seSxTKSwoTT09PSJhbmNob3JYInx8TT09PSJhbmNob3JZInx8TT09PSJib3hTaXppbmcifHxNPT09IndpZHRoInx8TT09PSJoZWlnaHQifHxNPT09ImJvcmRlcldpZHRoInx8TT09PSJwYWRkaW5nTGVmdCJ8fE09PT0icGFkZGluZ1JpZ2h0Inx8TT09PSJwYWRkaW5nVG9wInx8TT09PSJwYWRkaW5nQm90dG9tInx8L15ib3JkZXIoVG9wTGVmdHxUb3BSaWdodHxCb3R0b21SaWdodHxCb3R0b21MZWZ0KVJhZGl1cyQvLnRlc3QoTSkpJiZ0aGlzLnVwZGF0ZUNvbnRvdXJzKCksdGhpc1tPXSYmTT09PSJjbGlwUGF0aCImJnRoaXNbT10uc2V0Q2xpcFBhdGgoeSksdGhpc1tPXSYmTT09PSJiZ2NvbG9yIiYmT2JqZWN0KHUuc2V0RmlsbENvbG9yKSh0aGlzW09dLHtjb2xvcjp5fSksdGhpc1tPXSYmKE09PT0iYm9yZGVyQ29sb3IifHxNPT09ImJvcmRlcldpZHRoInx8TT09PSJib3JkZXJEYXNoInx8TT09PSJib3JkZXJEYXNoT2Zmc2V0Iikpe2NvbnN0e2JvcmRlckNvbG9yOnMsYm9yZGVyV2lkdGg6Yyxib3JkZXJEYXNoOmwsYm9yZGVyRGFzaE9mZnNldDp2fT10aGlzLmF0dHJpYnV0ZXM7T2JqZWN0KHUuc2V0U3Ryb2tlQ29sb3IpKHRoaXNbT10se2NvbG9yOnMsbGluZVdpZHRoOmMsbGluZURhc2g6Yz9sOjAsbGluZURhc2hPZmZzZXQ6dn0pfX11cGRhdGVDb250b3Vycygpe2NvbnN0e2FuY2hvclg6TSxhbmNob3JZOnksYm9yZGVyV2lkdGg6Uyxib3JkZXJSYWRpdXM6c309dGhpcy5hdHRyaWJ1dGVzLFtjLGxdPXRoaXMuYm9yZGVyU2l6ZSx2PXRoaXMub2Zmc2V0U2l6ZSxUPS41KlMsUj0tTSp2WzBdK1QsTD0teSp2WzFdK1Q7dGhpcy5jbGllbnRCb3g9bmV3IGkuRmlndXJlMkQsT2JqZWN0KGEuY3JlYXRlUmFkaXVzQm94KSh0aGlzLmNsaWVudEJveCxbUixMLGMsbF0scyl9fXAobSwiQXR0ciIsaC5kZWZhdWx0KSxkLmRlZmF1bHQucmVnaXN0ZXJOb2RlKG0sImJsb2NrIil9LGZ1bmN0aW9uKGcsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIEV9KTt2YXIgbj10KDcxKSxpPXQoNzIpLGY9dCgyMjEpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCBoPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZSIpLHU9U3ltYm9sLmZvcigic3ByaXRlanNfZ2V0QXR0cmlidXRlIiksYT1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGVEZWZhdWx0IiksZD1TeW1ib2wuZm9yKCJzcHJpdGVqc19kZWNsYXJlQWxpYXMiKTtjbGFzcyBFIGV4dGVuZHMgbi5kZWZhdWx0e2NvbnN0cnVjdG9yKE8pe3N1cGVyKE8pLHRoaXNbYV0oe2FuY2hvclg6MCxhbmNob3JZOjAsd2lkdGg6dm9pZCAwLGhlaWdodDp2b2lkIDAsYm9yZGVyV2lkdGg6MCxib3JkZXJDb2xvcjoicmdiYSgwLDAsMCwxKSIsYm9yZGVyRGFzaDp2b2lkIDAsYm9yZGVyRGFzaE9mZnNldDowLGJvcmRlclRvcExlZnRSYWRpdXM6WzAsMF0sYm9yZGVyVG9wUmlnaHRSYWRpdXM6WzAsMF0sYm9yZGVyQm90dG9tUmlnaHRSYWRpdXM6WzAsMF0sYm9yZGVyQm90dG9tTGVmdFJhZGl1czpbMCwwXSxiZ2NvbG9yOiJyZ2JhKDAsMCwwLDApIixwYWRkaW5nVG9wOjAscGFkZGluZ1JpZ2h0OjAscGFkZGluZ0JvdHRvbTowLHBhZGRpbmdMZWZ0OjAsYm94U2l6aW5nOiJjb250ZW50LWJveCIsY2xpcFBhdGg6dm9pZCAwfSksdGhpc1tkXSgiYW5jaG9yIiwic2l6ZSIsImJvcmRlciIsImJvcmRlclJhZGl1cyIsInBhZGRpbmciKX1nZXQgYW5jaG9yWCgpe3JldHVybiB0aGlzW3VdKCJhbmNob3JYIil9c2V0IGFuY2hvclgoTyl7dGhpc1toXSgiYW5jaG9yWCIsT2JqZWN0KGkudG9OdW1iZXIpKE8pKX1nZXQgYW5jaG9yWSgpe3JldHVybiB0aGlzW3VdKCJhbmNob3JZIil9c2V0IGFuY2hvclkoTyl7dGhpc1toXSgiYW5jaG9yWSIsT2JqZWN0KGkudG9OdW1iZXIpKE8pKX1nZXQgYW5jaG9yKCl7cmV0dXJuW3RoaXMuYW5jaG9yWCx0aGlzLmFuY2hvclldfXNldCBhbmNob3IoTyl7Tz1PYmplY3QoaS50b0FycmF5KShPKSxBcnJheS5pc0FycmF5KE8pfHwoTz1bTyxPXSksdGhpcy5hbmNob3JYPU9bMF0sdGhpcy5hbmNob3JZPU9bMV19Z2V0IHdpZHRoKCl7cmV0dXJuIHRoaXNbdV0oIndpZHRoIil9c2V0IHdpZHRoKE8pe3RoaXNbaF0oIndpZHRoIixPYmplY3QoaS50b051bWJlcikoTykpfWdldCBoZWlnaHQoKXtyZXR1cm4gdGhpc1t1XSgiaGVpZ2h0Iil9c2V0IGhlaWdodChPKXt0aGlzW2hdKCJoZWlnaHQiLE9iamVjdChpLnRvTnVtYmVyKShPKSl9Z2V0IHNpemUoKXtyZXR1cm5bdGhpcy53aWR0aCx0aGlzLmhlaWdodF19c2V0IHNpemUoTyl7Tz1PYmplY3QoaS50b0FycmF5KShPKSxBcnJheS5pc0FycmF5KE8pfHwoTz1bTyxPXSksdGhpcy53aWR0aD1PWzBdLHRoaXMuaGVpZ2h0PU9bMV19Z2V0IGJvcmRlcldpZHRoKCl7cmV0dXJuIHRoaXNbdV0oImJvcmRlcldpZHRoIil9c2V0IGJvcmRlcldpZHRoKE8pe3RoaXNbaF0oImJvcmRlcldpZHRoIixPYmplY3QoaS50b051bWJlcikoTykpfWdldCBib3JkZXJDb2xvcigpe3JldHVybiB0aGlzW3VdKCJib3JkZXJDb2xvciIpfXNldCBib3JkZXJDb2xvcihPKXt0aGlzW2hdKCJib3JkZXJDb2xvciIsT2JqZWN0KGYucGFyc2VDb2xvcikoTykpfWdldCBib3JkZXIoKXtyZXR1cm5bdGhpcy5ib3JkZXJXaWR0aCx0aGlzLmJvcmRlckNvbG9yXX1zZXQgYm9yZGVyKE8pe089T2JqZWN0KGkudG9BcnJheSkoTyksQXJyYXkuaXNBcnJheShPKXx8KE89W09dKSx0aGlzLmJvcmRlcldpZHRoPU9bMF0sT1sxXSE9bnVsbCYmKHRoaXMuYm9yZGVyQ29sb3I9T1sxXSl9Z2V0IGJvcmRlckRhc2goKXtyZXR1cm4gdGhpc1t1XSgiYm9yZGVyRGFzaCIpfXNldCBib3JkZXJEYXNoKE8pe089T2JqZWN0KGkudG9BcnJheSkoTywhMCksTyE9bnVsbCYmIUFycmF5LmlzQXJyYXkoTykmJihPPVtPXSksdGhpc1toXSgiYm9yZGVyRGFzaCIsTz9PLm1hcChpLnRvTnVtYmVyKTpudWxsKX1nZXQgYm9yZGVyRGFzaE9mZnNldCgpe3JldHVybiB0aGlzW3VdKCJib3JkZXJEYXNoT2Zmc2V0Iil9c2V0IGJvcmRlckRhc2hPZmZzZXQoTyl7dGhpc1toXSgiYm9yZGVyRGFzaE9mZnNldCIsT2JqZWN0KGkudG9OdW1iZXIpKE8pKX1nZXQgYm9yZGVyVG9wTGVmdFJhZGl1cygpe3JldHVybiB0aGlzW3VdKCJib3JkZXJUb3BMZWZ0UmFkaXVzIil9c2V0IGJvcmRlclRvcExlZnRSYWRpdXMoTyl7Tz1PYmplY3QoaS50b0FycmF5KShPLCEwKSxBcnJheS5pc0FycmF5KE8pfHwoTz1bTyxPXSksdGhpc1toXSgiYm9yZGVyVG9wTGVmdFJhZGl1cyIsTy5tYXAoaS50b051bWJlcikpfWdldCBib3JkZXJUb3BSaWdodFJhZGl1cygpe3JldHVybiB0aGlzW3VdKCJib3JkZXJUb3BSaWdodFJhZGl1cyIpfXNldCBib3JkZXJUb3BSaWdodFJhZGl1cyhPKXtPPU9iamVjdChpLnRvQXJyYXkpKE8sITApLEFycmF5LmlzQXJyYXkoTyl8fChPPVtPLE9dKSx0aGlzW2hdKCJib3JkZXJUb3BSaWdodFJhZGl1cyIsTy5tYXAoaS50b051bWJlcikpfWdldCBib3JkZXJCb3R0b21SaWdodFJhZGl1cygpe3JldHVybiB0aGlzW3VdKCJib3JkZXJCb3R0b21SaWdodFJhZGl1cyIpfXNldCBib3JkZXJCb3R0b21SaWdodFJhZGl1cyhPKXtPPU9iamVjdChpLnRvQXJyYXkpKE8sITApLEFycmF5LmlzQXJyYXkoTyl8fChPPVtPLE9dKSx0aGlzW2hdKCJib3JkZXJCb3R0b21SaWdodFJhZGl1cyIsTy5tYXAoaS50b051bWJlcikpfWdldCBib3JkZXJCb3R0b21MZWZ0UmFkaXVzKCl7cmV0dXJuIHRoaXNbdV0oImJvcmRlckJvdHRvbUxlZnRSYWRpdXMiKX1zZXQgYm9yZGVyQm90dG9tTGVmdFJhZGl1cyhPKXtPPU9iamVjdChpLnRvQXJyYXkpKE8sITApLEFycmF5LmlzQXJyYXkoTyl8fChPPVtPLE9dKSx0aGlzW2hdKCJib3JkZXJCb3R0b21MZWZ0UmFkaXVzIixPLm1hcChpLnRvTnVtYmVyKSl9Z2V0IGJvcmRlclJhZGl1cygpe3JldHVyblsuLi50aGlzLmJvcmRlclRvcExlZnRSYWRpdXMsLi4udGhpcy5ib3JkZXJUb3BSaWdodFJhZGl1cywuLi50aGlzLmJvcmRlckJvdHRvbVJpZ2h0UmFkaXVzLC4uLnRoaXMuYm9yZGVyQm90dG9tTGVmdFJhZGl1c119c2V0IGJvcmRlclJhZGl1cyhPKXtpZihPPU9iamVjdChpLnRvQXJyYXkpKE8pLCFBcnJheS5pc0FycmF5KE8pKU89QXJyYXkoOCkuZmlsbChPKTtlbHNlIGlmKE8ubGVuZ3RoPT09MilPPVtPWzBdLE9bMV0sT1swXSxPWzFdLE9bMF0sT1sxXSxPWzBdLE9bMV1dO2Vsc2UgaWYoTy5sZW5ndGg9PT00KU89W09bMF0sT1sxXSxPWzJdLE9bM10sT1swXSxPWzFdLE9bMl0sT1szXV07ZWxzZSBpZihPLmxlbmd0aD09PTYpTz1bT1swXSxPWzFdLE9bMl0sT1szXSxPWzRdLE9bNV0sT1syXSxPWzNdXTtlbHNlIGlmKE8ubGVuZ3RoIT09OCl0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIGJvcmRlclJhZGl1cyB2YWx1ZS4iKTt0aGlzLmJvcmRlclRvcExlZnRSYWRpdXM9W09bMF0sT1sxXV0sdGhpcy5ib3JkZXJUb3BSaWdodFJhZGl1cz1bT1syXSxPWzNdXSx0aGlzLmJvcmRlckJvdHRvbVJpZ2h0UmFkaXVzPVtPWzRdLE9bNV1dLHRoaXMuYm9yZGVyQm90dG9tTGVmdFJhZGl1cz1bT1s2XSxPWzddXX1nZXQgYmdjb2xvcigpe3JldHVybiB0aGlzW3VdKCJiZ2NvbG9yIil9c2V0IGJnY29sb3IoTyl7dGhpc1toXSgiYmdjb2xvciIsT2JqZWN0KGYucGFyc2VDb2xvcikoTykpfWdldCBwYWRkaW5nVG9wKCl7cmV0dXJuIHRoaXNbdV0oInBhZGRpbmdUb3AiKX1zZXQgcGFkZGluZ1RvcChPKXt0aGlzW2hdKCJwYWRkaW5nVG9wIixPYmplY3QoaS50b051bWJlcikoTykpfWdldCBwYWRkaW5nUmlnaHQoKXtyZXR1cm4gdGhpc1t1XSgicGFkZGluZ1JpZ2h0Iil9c2V0IHBhZGRpbmdSaWdodChPKXt0aGlzW2hdKCJwYWRkaW5nUmlnaHQiLE9iamVjdChpLnRvTnVtYmVyKShPKSl9Z2V0IHBhZGRpbmdCb3R0b20oKXtyZXR1cm4gdGhpc1t1XSgicGFkZGluZ0JvdHRvbSIpfXNldCBwYWRkaW5nQm90dG9tKE8pe3RoaXNbaF0oInBhZGRpbmdCb3R0b20iLE9iamVjdChpLnRvTnVtYmVyKShPKSl9Z2V0IHBhZGRpbmdMZWZ0KCl7cmV0dXJuIHRoaXNbdV0oInBhZGRpbmdMZWZ0Iil9c2V0IHBhZGRpbmdMZWZ0KE8pe3RoaXNbaF0oInBhZGRpbmdMZWZ0IixPYmplY3QoaS50b051bWJlcikoTykpfWdldCBwYWRkaW5nKCl7cmV0dXJuW3RoaXMucGFkZGluZ1RvcCx0aGlzLnBhZGRpbmdSaWdodCx0aGlzLnBhZGRpbmdCb3R0b20sdGhpcy5wYWRkaW5nTGVmdF19c2V0IHBhZGRpbmcoTyl7Tz1PYmplY3QoaS50b0FycmF5KShPKSxBcnJheS5pc0FycmF5KE8pP08ubGVuZ3RoPT09Mj9PPVtPWzBdLE9bMV0sT1swXSxPWzFdXTpPLmxlbmd0aD09PTMmJihPPVtPWzBdLE9bMV0sT1syXSxPWzFdXSk6Tz1bTyxPLE8sT10sdGhpcy5wYWRkaW5nVG9wPU9bMF0sdGhpcy5wYWRkaW5nUmlnaHQ9T1sxXSx0aGlzLnBhZGRpbmdCb3R0b209T1syXSx0aGlzLnBhZGRpbmdMZWZ0PU9bM119Z2V0IGNsaXBQYXRoKCl7cmV0dXJuIHRoaXNbdV0oImNsaXBQYXRoIil9c2V0IGNsaXBQYXRoKE8pe3RoaXNbaF0oImNsaXBQYXRoIixPKX1nZXQgYm94U2l6aW5nKCl7cmV0dXJuIHRoaXNbdV0oImJveFNpemluZyIpfXNldCBib3hTaXppbmcoTyl7aWYoTyE9bnVsbCYmTyE9PSJib3JkZXItYm94IiYmTyE9PSJjb250ZW50LWJveCIpdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCBib3hTaXppbmcgdHlwZS4iKTt0aGlzW2hdKCJib3hTaXppbmciLE8pfX19LGZ1bmN0aW9uKGcsZSx0KXt0LnIoZSksdC5kKGUsIkdyYWRpZW50IixmdW5jdGlvbigpe3JldHVybiBmfSksdC5kKGUsImlzVHJhbnNwYXJlbnQiLGZ1bmN0aW9uKCl7cmV0dXJuIGh9KSx0LmQoZSwicGFyc2VDb2xvciIsZnVuY3Rpb24oKXtyZXR1cm4gdX0pLHQuZChlLCJzZXRGaWxsQ29sb3IiLGZ1bmN0aW9uKCl7cmV0dXJuIGR9KSx0LmQoZSwic2V0U3Ryb2tlQ29sb3IiLGZ1bmN0aW9uKCl7cmV0dXJuIEV9KSx0LmQoZSwiQ29sb3IiLGZ1bmN0aW9uKCl7cmV0dXJuIHB9KTt2YXIgbj10KDMyKSxpPXQubihuKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y2xhc3MgZntjb25zdHJ1Y3Rvcih7dmVjdG9yOm0sY29sb3JzOmJ9KXtpZighQXJyYXkuaXNBcnJheShtKXx8bS5sZW5ndGghPT00JiZtLmxlbmd0aCE9PTYmJm0ubGVuZ3RoIT09Myl0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIGdyYWRpZW50Iik7dGhpcy52ZWN0b3I9bSx0aGlzLmNvbG9ycz1iLm1hcCgoe29mZnNldDpNLGNvbG9yOnl9KT0+KHtvZmZzZXQ6TSxjb2xvcjp1KHkpfSkpfXRvU3RyaW5nKCl7cmV0dXJuIEpTT04uc3RyaW5naWZ5KHt2ZWN0b3I6dGhpcy52ZWN0b3IsY29sb3JzOnRoaXMuY29sb3JzfSl9fWZ1bmN0aW9uIGgoTyl7cmV0dXJuIE8gaW5zdGFuY2VvZiBmPyExOk89PW51bGw/ITA6aSgpKE8pWzNdPT09MH1mdW5jdGlvbiB1KE8pe2lmKE89PW51bGx8fChPfHwoTz0idHJhbnNwYXJlbnQiKSxPIGluc3RhbmNlb2YgZikpcmV0dXJuIE87Y29uc3QgbT1pKCkoTyk7aWYoIW18fCFtLmxlbmd0aCl0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIGNvbG9yIHZhbHVlLiIpO3JldHVybmByZ2JhKCR7bS5qb2luKCl9KWB9ZnVuY3Rpb24gYShPLG0sYil7Y29uc3QgTT1PLmJvdW5kaW5nQm94WzBdO2lmKGIudmVjdG9yKXtsZXR7dmVjdG9yOnksY29sb3JzOlN9PWI7eS5sZW5ndGg9PT00Pyh5PVt5WzBdK01bMF0seVsxXStNWzFdLHlbMl0rTVswXSx5WzNdK01bMV1dLE8uc2V0TGluZWFyR3JhZGllbnQoe3ZlY3Rvcjp5LGNvbG9yczpTLHR5cGU6bX0pKTp5Lmxlbmd0aD09PTM/KHk9W3lbMF0rTVswXSx5WzFdK01bMV0seVsyXV0sTy5zZXRDaXJjdWxhckdyYWRpZW50KHt2ZWN0b3I6eSxjb2xvcnM6Uyx0eXBlOm19KSk6KHk9W3lbMF0rTVswXSx5WzFdK01bMV0seVsyXSx5WzNdK01bMF0seVs0XStNWzFdLHlbNV1dLE8uc2V0UmFkaWFsR3JhZGllbnQoe3ZlY3Rvcjp5LGNvbG9yczpTLHR5cGU6bX0pKX1lbHNlIE8uZ3JhZGllbnQmJk8uZ3JhZGllbnRbbV0mJihkZWxldGUgTy5ncmFkaWVudFttXSxkZWxldGUgTy51bmlmb3Jtcy51X3JhZGlhbEdyYWRpZW50VmVjdG9yKX1mdW5jdGlvbiBkKE8se2NvbG9yOm0scnVsZTpiPSJub256ZXJvIn0pe3JldHVybiBhKE8sImZpbGwiLG0pLG0udmVjdG9yfHxPLnNldEZpbGwoe2NvbG9yOm0scnVsZTpifSksT31mdW5jdGlvbiBFKE8se2NvbG9yOm0sbGluZVdpZHRoOmIsbGluZUNhcDpNLGxpbmVKb2luOnksbGluZURhc2g6UyxsaW5lRGFzaE9mZnNldDpzLG1pdGVyTGltaXQ6Yyxyb3VuZFNlZ21lbnRzOmx9KXthKE8sInN0cm9rZSIsbSksbS52ZWN0b3ImJihtPVswLDAsMCwxXSksTy5zZXRTdHJva2Uoe2NvbG9yOm0sdGhpY2tuZXNzOmIsY2FwOk0sam9pbjp5LG1pdGVyTGltaXQ6YyxsaW5lRGFzaDpTLGxpbmVEYXNoT2Zmc2V0OnMscm91bmRTZWdtZW50czpsfSl9Y2xhc3MgcCBleHRlbmRzIEFycmF5e2NvbnN0cnVjdG9yKG09MCxiPTAsTT0wLHk9MCl7cmV0dXJuIEFycmF5LmlzQXJyYXkobSkmJihbbSxiLE0seV09bSksdHlwZW9mIG09PSJzdHJpbmciJiYoW20sYixNLHldPWkoKShtKSxtLz0yNTUsYi89MjU1LE0vPTI1NSksc3VwZXIobSxiLE0seSksdGhpc31nZXQgcigpe3JldHVybiBNYXRoLnJvdW5kKHRoaXNbMF0qMjU1KX1zZXQgcihtKXt0aGlzWzBdPW0vMjU1fWdldCBnKCl7cmV0dXJuIE1hdGgucm91bmQodGhpc1sxXSoyNTUpfXNldCBnKG0pe3RoaXNbMV09bS8yNTV9Z2V0IGIoKXtyZXR1cm4gTWF0aC5yb3VuZCh0aGlzWzJdKjI1NSl9c2V0IGIobSl7dGhpc1syXT1tLzI1NX1nZXQgYSgpe3JldHVybiB0aGlzWzNdfXNldCBhKG0pe3RoaXNbM109bX1nZXQgaGV4KCl7Y29uc3QgbT1gMCR7dGhpcy5yLnRvU3RyaW5nKDE2KX1gLnNsaWNlKC0yKSxiPWAwJHt0aGlzLmcudG9TdHJpbmcoMTYpfWAuc2xpY2UoLTIpLE09YDAke3RoaXMuYi50b1N0cmluZygxNil9YC5zbGljZSgtMik7bGV0IHk7cmV0dXJuIHRoaXMuYTwxJiYoeT1NYXRoLnJvdW5kKHRoaXNbM10qMjU1KSx5PWAwJHt5LnRvU3RyaW5nKDE2KX1gLnNsaWNlKC0yKSksYCMke219JHtifSR7TX0ke3l8fCIifWB9Z2V0IHJnYmEoKXtyZXR1cm5gcmdiYSgke3RoaXMucn0sJHt0aGlzLmd9LCR7dGhpcy5ifSwke3RoaXMuYX0pYH1mcm9tQ29sb3IobSl7cmV0dXJuIHR5cGVvZiBtPT0ic3RyaW5nIiYmKG09aSgpKG0pLG1bMF0vPTI1NSxtWzFdLz0yNTUsbVsyXS89MjU1KSx0aGlzWzBdPW1bMF0sdGhpc1sxXT1tWzFdLHRoaXNbMl09bVsyXSx0aGlzWzNdPW1bM10sdGhpc319fSxmdW5jdGlvbihnLGUsdCl7dC5yKGUpLHQuZChlLCJjcmVhdGVSYWRpdXNCb3giLGZ1bmN0aW9uKCl7cmV0dXJuIGl9KSx0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gbihmLGgsdSxhLGQsRT0ibGVmdFRvcCIpe2NvbnN0IHA9LjU1MjI4NDgsTz1hLzIqcCxtPWQvMipwLGI9aCthLE09dStkLHk9aCthLzIsUz11K2QvMjtFPT09ImxlZnRUb3AiPyhmLm1vdmVUbyhoLFMpLGYuYmV6aWVyQ3VydmVUbyhoLFMtbSx5LU8sdSx5LHUpKTpFPT09InJpZ2h0VG9wIj9mLmJlemllckN1cnZlVG8oeStPLHUsYixTLW0sYixTKTpFPT09InJpZ2h0Qm90dG9tIj9mLmJlemllckN1cnZlVG8oYixTK20seStPLE0seSxNKTpFPT09ImxlZnRCb3R0b20iJiZmLmJlemllckN1cnZlVG8oeS1PLE0saCxTK20saCxTKX1mdW5jdGlvbiBpKGYsW2gsdSxhLGRdLEUpe2lmKCFFfHxBcnJheS5pc0FycmF5KEUpJiZFLmV2ZXJ5KHA9PnA9PT0wKSlmLmJlZ2luUGF0aCgpLGYucmVjdChoLHUsYSxkKTtlbHNle3R5cGVvZiBFPT0ibnVtYmVyIiYmKEU9QXJyYXkoOCkuZmlsbChFKSk7Y29uc3RbcCxPLG0sYixNLHksUyxzXT1FLm1hcCgoYyxsKT0+bCUyP01hdGgubWluKGMsZC8yKTpNYXRoLm1pbihjLGEvMikpO2YuYmVnaW5QYXRoKCksZi5tb3ZlVG8oaCx1K08pLG4oZixoLHUscCoyLE8qMiwibGVmdFRvcCIpLGYubGluZVRvKGgrYS1tLHUpLG4oZixoK2EtbSoyLHUsbSoyLGIqMiwicmlnaHRUb3AiKSxmLmxpbmVUbyhoK2EsdStkLXkpLG4oZixoK2EtTSoyLHUrZC15KjIsTSoyLHkqMiwicmlnaHRCb3R0b20iKSxmLmxpbmVUbyhoK1MsdStkKSxuKGYsaCx1K2QtcyoyLFMqMixzKjIsImxlZnRCb3R0b20iKSxmLmNsb3NlUGF0aCgpfXJldHVybiBmfX0sZnVuY3Rpb24oZyxlLHQpe3QucihlKSx0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSksZS5kZWZhdWx0PWZ1bmN0aW9uKG4saSl7aWYoIW4pcmV0dXJue3g6MCx5OjAsd2lkdGg6MCxoZWlnaHQ6MCxsZWZ0OjAsdG9wOjAscmlnaHQ6MCxib3R0b206MH07Y29uc3RbW2YsaF0sW3UsYV1dPW4sZD1mKmlbMF0raCppWzJdK2lbNF0sRT1mKmlbMV0raCppWzNdK2lbNV0scD11KmlbMF0raCppWzJdK2lbNF0sTz11KmlbMV0raCppWzNdK2lbNV0sbT11KmlbMF0rYSppWzJdK2lbNF0sYj11KmlbMV0rYSppWzNdK2lbNV0sTT1mKmlbMF0rYSppWzJdK2lbNF0seT1mKmlbMV0rYSppWzNdK2lbNV0sUz1NYXRoLm1pbihkLHAsbSxNKSxzPU1hdGgubWluKEUsTyxiLHkpLGM9TWF0aC5tYXgoZCxwLG0sTSksbD1NYXRoLm1heChFLE8sYix5KTtyZXR1cm57eDpTLHk6cyx3aWR0aDpjLVMsaGVpZ2h0OmwtcyxsZWZ0OlMsdG9wOnMscmlnaHQ6Yyxib3R0b206bH19fSxmdW5jdGlvbihnLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBkfSk7dmFyIG49dCgyMTgpLGk9dCgyMTkpLGY9dCgyMjUpLGg9dCgyMTMpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiB1KEUscCxPKXtyZXR1cm4gcCBpbiBFP09iamVjdC5kZWZpbmVQcm9wZXJ0eShFLHAse3ZhbHVlOk8sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTpFW3BdPU8sRX1jb25zdCBhPVN5bWJvbCgidGV4dHVyZVRhc2siKTtjbGFzcyBkIGV4dGVuZHMgaS5kZWZhdWx0e2NvbnN0cnVjdG9yKHA9e30pe3R5cGVvZiBwPT0ic3RyaW5nIiYmKHA9e3RleHR1cmU6cH0pLHN1cGVyKHApfWdldCBjb250ZW50U2l6ZSgpe2xldFtwLE9dPXN1cGVyLmNvbnRlbnRTaXplO2NvbnN0e3dpZHRoOm0saGVpZ2h0OmJ9PXRoaXMuYXR0cmlidXRlcztpZihtPT1udWxsfHxiPT1udWxsKXtjb25zdCBNPXRoaXMudGV4dHVyZUltYWdlLHk9dGhpcy5hdHRyaWJ1dGVzLnRleHR1cmVSZWN0LFM9dGhpcy5hdHRyaWJ1dGVzLnNvdXJjZVJlY3Q7aWYoeSltPT1udWxsJiYocD15WzBdK3lbMl0pLGI9PW51bGwmJihPPXlbMV0reVszXSk7ZWxzZSBpZihTKXtjb25zdCBzPXRoaXMubGF5ZXI/dGhpcy5sYXllci5kaXNwbGF5UmF0aW86MTttPT1udWxsJiYocD1TWzJdL3MpLGI9PW51bGwmJihPPVNbM10vcyl9ZWxzZSBpZihNKXtjb25zdCBzPXRoaXMubGF5ZXI/dGhpcy5sYXllci5kaXNwbGF5UmF0aW86MTttPT1udWxsJiYocD1NLndpZHRoL3MpLGI9PW51bGwmJihPPU0uaGVpZ2h0L3MpfX1yZXR1cm5bcCxPXX1nZXQgdGV4dHVyZUltYWdlUmVhZHkoKXtyZXR1cm4gdGhpc1thXXx8UHJvbWlzZS5yZXNvbHZlKCl9ZHJhdyhwPVtdKXtzdXBlci5kcmF3KHApO2NvbnN0IE89dGhpcy5tZXNoO3JldHVybiBPJiZPYmplY3Qobi5kcmF3VGV4dHVyZSkodGhpcyxPKSxwfW9uUHJvcGVydHlDaGFuZ2UocCxPLG0pe2lmKHN1cGVyLm9uUHJvcGVydHlDaGFuZ2UocCxPLG0pLHA9PT0idGV4dHVyZSImJih0aGlzW2FdPU9iamVjdChuLmFwcGx5VGV4dHVyZSkodGhpcyxPLCEwKSkscD09PSJ0ZXh0dXJlUmVjdCIpe2NvbnN0e3dpZHRoOmIsaGVpZ2h0Ok19PXRoaXMuYXR0cmlidXRlczsoYj09bnVsbHx8TT09bnVsbCkmJnRoaXMudXBkYXRlQ29udG91cnMoKX19fXUoZCwiQXR0ciIsZi5kZWZhdWx0KSxoLmRlZmF1bHQucmVnaXN0ZXJOb2RlKGQsInNwcml0ZSIpfSxmdW5jdGlvbihnLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiB1fSk7dmFyIG49dCgyMjApO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCBpPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZURlZmF1bHQiKSxmPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZSIpLGg9U3ltYm9sLmZvcigic3ByaXRlanNfZ2V0QXR0cmlidXRlIik7Y2xhc3MgdSBleHRlbmRzIG4uZGVmYXVsdHtjb25zdHJ1Y3RvcihkKXtzdXBlcihkKSx0aGlzW2ldKHt0ZXh0dXJlOnZvaWQgMCx0ZXh0dXJlUmVjdDp2b2lkIDAsdGV4dHVyZVJlcGVhdDohMSxzb3VyY2VSZWN0OnZvaWQgMH0pfWdldCB0ZXh0dXJlKCl7cmV0dXJuIHRoaXNbaF0oInRleHR1cmUiKX1zZXQgdGV4dHVyZShkKXt0aGlzW2ZdKCJ0ZXh0dXJlIixkKX1nZXQgdGV4dHVyZVJlY3QoKXtyZXR1cm4gdGhpc1toXSgidGV4dHVyZVJlY3QiKX1zZXQgdGV4dHVyZVJlY3QoZCl7dGhpc1tmXSgidGV4dHVyZVJlY3QiLGQpfWdldCBzb3VyY2VSZWN0KCl7cmV0dXJuIHRoaXNbaF0oInNvdXJjZVJlY3QiKX1zZXQgc291cmNlUmVjdChkKXt0aGlzW2ZdKCJzb3VyY2VSZWN0IixkKX1nZXQgdGV4dHVyZVJlcGVhdCgpe3JldHVybiB0aGlzW2hdKCJ0ZXh0dXJlUmVwZWF0Iil9c2V0IHRleHR1cmVSZXBlYXQoZCl7dGhpc1tmXSgidGV4dHVyZVJlcGVhdCIsISFkKX19fSxmdW5jdGlvbihnLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBifSk7dmFyIG49dCgxMiksaT10KDIyNyksZj10Lm4oaSksaD10KDcwKSx1PXQoMjI4KSxhPXQoMjIxKSxkPXQoMjE4KSxFPXQoMjEzKSxwPXQoMjIzKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gTyhNLHksUyl7cmV0dXJuIHkgaW4gTT9PYmplY3QuZGVmaW5lUHJvcGVydHkoTSx5LHt2YWx1ZTpTLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6TVt5XT1TLE19Y29uc3QgbT1TeW1ib2woIm1lc2giKTtjbGFzcyBiIGV4dGVuZHMgaC5kZWZhdWx0e2NvbnN0cnVjdG9yKHk9e30pe3R5cGVvZiB5PT0ic3RyaW5nIiYmKHk9e2Q6eX0pLHN1cGVyKHkpLHRoaXMuZWZmZWN0cz17ZChTLHMsYyxsLHYpe2NvbnN0IFQ9KGMtbCkvKHYtbCk7aWYoVDw9MClyZXR1cm4gUztpZihUPj0xKXJldHVybiBzO2NvbnN0IFI9Zi5hLl9wcmVwcm9jZXNzaW5nKGYuYS5wYXRoMnNoYXBlcyhTKSxmLmEucGF0aDJzaGFwZXMocykpLEw9Zi5hLl9sZXJwKC4uLlIsVClbMF07cmV0dXJuIEwucmVkdWNlKChBLHcpPT5gJHtBfSR7dy5zbGljZSgyKS5qb2luKCIgIil9IGAsYE0ke0xbMF1bMF19ICR7TFswXVsxXX1DYCkudHJpbSgpfX19Z2V0IGlzVmlzaWJsZSgpe3JldHVybiEhdGhpcy5kfWdldCBtZXNoKCl7aWYodGhpcy5hdHRyaWJ1dGVzLmRpc3BsYXk9PT0ibm9uZSIpcmV0dXJuIG51bGw7Y29uc3QgeT10aGlzLnBhdGg7aWYoeSl7bGV0IFM9dGhpc1ttXTtpZihTKVMucGF0aCE9PXkmJihTLmNvbnRvdXJzPXkuY29udG91cnMsUy5wYXRoPXkpO2Vsc2V7Uz1uZXcgbi5NZXNoMkQodGhpcy5wYXRoKSxTLnBhdGg9eTtjb25zdCBjPXRoaXMuYXR0cmlidXRlcy5maWxsQ29sb3IsbD10aGlzLmF0dHJpYnV0ZXMuZmlsbFJ1bGU7YyYmT2JqZWN0KGEuc2V0RmlsbENvbG9yKShTLHtjb2xvcjpjLHJ1bGU6bH0pO2NvbnN0IHY9dGhpcy5hdHRyaWJ1dGVzLmxpbmVXaWR0aCxUPXRoaXMuYXR0cmlidXRlcy5zdHJva2VDb2xvcjtpZihUJiZ2PjApe2NvbnN0e2xpbmVDYXA6TCxsaW5lSm9pbjpOLG1pdGVyTGltaXQ6QSxsaW5lRGFzaDp3LGxpbmVEYXNoT2Zmc2V0OkIscm91bmRTZWdtZW50czpEfT10aGlzLmF0dHJpYnV0ZXM7T2JqZWN0KGEuc2V0U3Ryb2tlQ29sb3IpKFMse2NvbG9yOlQsbGluZVdpZHRoOnYsbGluZUNhcDpMLGxpbmVKb2luOk4sbWl0ZXJMaW1pdDpBLGxpbmVEYXNoOncsbGluZURhc2hPZmZzZXQ6Qixyb3VuZFNlZ21lbnRzOkR9KX10aGlzW21dPVM7Y29uc3QgUj10aGlzLmF0dHJpYnV0ZXMuY2xpcFBhdGg7UiYmdGhpc1ttXS5zZXRDbGlwUGF0aChSKX1jb25zdCBzPXRoaXMub3BhY2l0eTtyZXR1cm4gUy5nZXRPcGFjaXR5KCkhPT1zJiZTLnNldE9wYWNpdHkocyksUy5zZXRUcmFuc2Zvcm0oLi4udGhpcy5yZW5kZXJNYXRyaXgpLFN9cmV0dXJuIG51bGx9Z2V0IG9yaWdpbmFsQ29udGVudFJlY3QoKXtpZih0aGlzLnBhdGgpe2NvbnN0IHk9dGhpcy5wYXRoLmJvdW5kaW5nQm94O3JldHVyblt5WzBdWzBdLHlbMF1bMV0seVsxXVswXS15WzBdWzBdLHlbMV1bMV0teVswXVsxXV19cmV0dXJuWzAsMCwwLDBdfWdldCBvcmlnaW5hbENsaWVudFJlY3QoKXtpZih0aGlzLm1lc2gpe2NvbnN0IHk9dGhpcy5tZXNoLmJvdW5kaW5nQm94O3JldHVyblt5WzBdWzBdLHlbMF1bMV0seVsxXVswXS15WzBdWzBdLHlbMV1bMV0teVswXVsxXV19cmV0dXJuWzAsMCwwLDBdfWdldCBvcmlnaW5hbENsaWVudENlbnRlcigpe3JldHVybiB0aGlzLm1lc2g/dGhpcy5tZXNoLmJvdW5kaW5nQ2VudGVyOlswLDBdfXNldCBkKHkpe3RoaXMuYXR0cmlidXRlcy5kPXl9Z2V0IGQoKXtyZXR1cm4gdGhpcy5hdHRyaWJ1dGVzLmR9ZHJhdyh5PVtdKXtzdXBlci5kcmF3KHkpO2NvbnN0IFM9dGhpcy5tZXNoO3JldHVybiBTJiZPYmplY3QoZC5kcmF3VGV4dHVyZSkodGhpcyxTKSx5fWdldEJvdW5kaW5nQ2xpZW50UmVjdCgpe2xldCB5PW51bGw7cmV0dXJuIHRoaXMubWVzaCYmKHk9dGhpcy5tZXNoLmJvdW5kaW5nQm94KSxPYmplY3QocC5kZWZhdWx0KSh5LHRoaXMucmVuZGVyTWF0cml4KX1nZXRQYXRoTGVuZ3RoKCl7cmV0dXJuIHRoaXMubWVzaD90aGlzLm1lc2guZ2V0VG90YWxMZW5ndGgoKTowfWdldFBvaW50QXRMZW5ndGgoeSl7aWYodGhpcy5tZXNoKXtjb25zdCBTPXRoaXMubWVzaC5nZXRQb2ludEF0TGVuZ3RoKHkpO2lmKFMpcmV0dXJuW1MueCxTLnldfXJldHVyblswLDBdfW9uUHJvcGVydHlDaGFuZ2UoeSxTLHMpe2lmKHN1cGVyLm9uUHJvcGVydHlDaGFuZ2UoeSxTLHMpLCh5PT09ImQifHx5PT09Im5vcm1hbGl6ZSIpJiZ0aGlzLnVwZGF0ZUNvbnRvdXJzKCksdGhpc1ttXSYmKHk9PT0iZmlsbENvbG9yInx8eT09PSJmaWxsUnVsZSIpKXtjb25zdHtmaWxsQ29sb3I6YyxmaWxsUnVsZTpsfT10aGlzLmF0dHJpYnV0ZXM7T2JqZWN0KGEuc2V0RmlsbENvbG9yKSh0aGlzW21dLHtjb2xvcjpjLHJ1bGU6bH0pfWlmKHRoaXNbbV0mJih5PT09InN0cm9rZUNvbG9yInx8eT09PSJsaW5lV2lkdGgifHx5PT09ImxpbmVDYXAifHx5PT09ImxpbmVKb2luInx8eT09PSJsaW5lRGFzaCJ8fHk9PT0ibGluZURhc2hPZmZzZXQifHx5PT09InJvdW5kU2VnbWVudHMiKSl7Y29uc3R7c3Ryb2tlQ29sb3I6YyxsaW5lV2lkdGg6bH09dGhpcy5hdHRyaWJ1dGVzO2lmKGMmJmw+MCl7Y29uc3R7bGluZUNhcDp2LGxpbmVKb2luOlQsbGluZURhc2g6UixsaW5lRGFzaE9mZnNldDpMLG1pdGVyTGltaXQ6Tixyb3VuZFNlZ21lbnRzOkF9PXRoaXMuYXR0cmlidXRlcztPYmplY3QoYS5zZXRTdHJva2VDb2xvcikodGhpc1ttXSx7Y29sb3I6YyxsaW5lQ2FwOnYsbGluZUpvaW46VCxsaW5lV2lkdGg6bCxsaW5lRGFzaDpSLGxpbmVEYXNoT2Zmc2V0OkwsbWl0ZXJMaW1pdDpOLHJvdW5kU2VnbWVudHM6QX0pfX10aGlzW21dJiZ5PT09ImNsaXBQYXRoIiYmdGhpc1ttXS5zZXRDbGlwUGF0aChTKSx5PT09InRleHR1cmUiJiZPYmplY3QoZC5hcHBseVRleHR1cmUpKHRoaXMsUyl9dXBkYXRlQ29udG91cnMoKXt0aGlzLnBhdGg9bmV3IG4uRmlndXJlMkQsdGhpcy5wYXRoLmFkZFBhdGgodGhpcy5hdHRyaWJ1dGVzLmQpLHRoaXMuYXR0cmlidXRlcy5ub3JtYWxpemUmJnRoaXMucGF0aC5ub3JtYWxpemUoLi4udGhpcy5wYXRoLmJvdW5kaW5nQ2VudGVyKX19TyhiLCJBdHRyIix1LmRlZmF1bHQpLEUuZGVmYXVsdC5yZWdpc3Rlck5vZGUoYiwicGF0aCIpfSxmdW5jdGlvbihnLGUsdCl7KGZ1bmN0aW9uKG4saSl7Zy5leHBvcnRzPWkoKX0pKHRoaXMsZnVuY3Rpb24oKXt2YXIgbj1mdW5jdGlvbigpe2Z1bmN0aW9uIHcoQixEKXt2YXIgST1bXSxqPSEwLFY9ITEsSj12b2lkIDA7dHJ5e2Zvcih2YXIgXz1CW1N5bWJvbC5pdGVyYXRvcl0oKSxzdDshKGo9KHN0PV8ubmV4dCgpKS5kb25lKSYmKEkucHVzaChzdC52YWx1ZSksIShEJiZJLmxlbmd0aD09PUQpKTtqPSEwKTt9Y2F0Y2goRyl7Vj0hMCxKPUd9ZmluYWxseXt0cnl7IWomJl8ucmV0dXJuJiZfLnJldHVybigpfWZpbmFsbHl7aWYoVil0aHJvdyBKfX1yZXR1cm4gSX1yZXR1cm4gZnVuY3Rpb24oQixEKXtpZihBcnJheS5pc0FycmF5KEIpKXJldHVybiBCO2lmKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoQikpcmV0dXJuIHcoQixEKTt0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlIil9fSgpLGk9TWF0aC5QSSoyLGY9ZnVuY3Rpb24oQixELEksaixWLEosXyl7dmFyIHN0PUIueCxHPUIueTtzdCo9RCxHKj1JO3ZhciBZPWoqc3QtVipHLHJ0PVYqc3QraipHO3JldHVybnt4OlkrSix5OnJ0K199fSxoPWZ1bmN0aW9uKEIsRCl7dmFyIEk9MS4zMzMzMzMzMzMzMzMzMzMzKk1hdGgudGFuKEQvNCksaj1NYXRoLmNvcyhCKSxWPU1hdGguc2luKEIpLEo9TWF0aC5jb3MoQitEKSxfPU1hdGguc2luKEIrRCk7cmV0dXJuW3t4OmotVipJLHk6VitqKkl9LHt4OkorXypJLHk6Xy1KKkl9LHt4OkoseTpffV19LHU9ZnVuY3Rpb24oQixELEksail7dmFyIFY9QipqLUQqSTwwPy0xOjEsSj1NYXRoLnNxcnQoQipCK0QqRCksXz1NYXRoLnNxcnQoQipCK0QqRCksc3Q9QipJK0QqaixHPXN0LyhKKl8pO3JldHVybiBHPjEmJihHPTEpLEc8LTEmJihHPS0xKSxWKk1hdGguYWNvcyhHKX0sYT1mdW5jdGlvbihCLEQsSSxqLFYsSixfLHN0LEcsWSxydCxvdCl7dmFyIGF0PU1hdGgucG93KFYsMiksaHQ9TWF0aC5wb3coSiwyKSxpdD1NYXRoLnBvdyhydCwyKSxNdD1NYXRoLnBvdyhvdCwyKSxPdD1hdCpodC1hdCpNdC1odCppdDtPdDwwJiYoT3Q9MCksT3QvPWF0Kk10K2h0Kml0LE90PU1hdGguc3FydChPdCkqKF89PT1zdD8tMToxKTt2YXIgVT1PdCpWL0oqb3QsJD1PdCotSi9WKnJ0LFE9WSpVLUcqJCsoQitJKS8yLHR0PUcqVStZKiQrKEQraikvMixGPShydC1VKS9WLEg9KG90LSQpL0oseD0oLXJ0LVUpL1YsUD0oLW90LSQpL0osVz11KDEsMCxGLEgpLEs9dShGLEgseCxQKTtyZXR1cm4gc3Q9PT0wJiZLPjAmJihLLT1pKSxzdD09PTEmJks8MCYmKEsrPWkpLFtRLHR0LFcsS119LGQ9ZnVuY3Rpb24oQil7dmFyIEQ9Qi5weCxJPUIucHksaj1CLmN4LFY9Qi5jeSxKPUIucngsXz1CLnJ5LHN0PUIueEF4aXNSb3RhdGlvbixHPXN0PT09dm9pZCAwPzA6c3QsWT1CLmxhcmdlQXJjRmxhZyxydD1ZPT09dm9pZCAwPzA6WSxvdD1CLnN3ZWVwRmxhZyxhdD1vdD09PXZvaWQgMD8wOm90LGh0PVtdO2lmKEo9PT0wfHxfPT09MClyZXR1cm5bXTt2YXIgaXQ9TWF0aC5zaW4oRyppLzM2MCksTXQ9TWF0aC5jb3MoRyppLzM2MCksT3Q9TXQqKEQtaikvMitpdCooSS1WKS8yLFU9LWl0KihELWopLzIrTXQqKEktVikvMjtpZihPdD09PTAmJlU9PT0wKXJldHVybltdO0o9TWF0aC5hYnMoSiksXz1NYXRoLmFicyhfKTt2YXIgJD1NYXRoLnBvdyhPdCwyKS9NYXRoLnBvdyhKLDIpK01hdGgucG93KFUsMikvTWF0aC5wb3coXywyKTskPjEmJihKKj1NYXRoLnNxcnQoJCksXyo9TWF0aC5zcXJ0KCQpKTt2YXIgUT1hKEQsSSxqLFYsSixfLHJ0LGF0LGl0LE10LE90LFUpLHR0PW4oUSw0KSxGPXR0WzBdLEg9dHRbMV0seD10dFsyXSxQPXR0WzNdLFc9TWF0aC5tYXgoTWF0aC5jZWlsKE1hdGguYWJzKFApLyhpLzQpKSwxKTtQLz1XO2Zvcih2YXIgSz0wO0s8VztLKyspaHQucHVzaChoKHgsUCkpLHgrPVA7cmV0dXJuIGh0Lm1hcChmdW5jdGlvbihaKXt2YXIgaz1mKFpbMF0sSixfLE10LGl0LEYsSCksbnQ9ay54LHV0PWsueSxjdD1mKFpbMV0sSixfLE10LGl0LEYsSCkscHQ9Y3QueCx4dD1jdC55LGd0PWYoWlsyXSxKLF8sTXQsaXQsRixIKSxkdD1ndC54LG10PWd0Lnk7cmV0dXJue3gxOm50LHkxOnV0LHgyOnB0LHkyOnh0LHg6ZHQseTptdH19KX0sRT17YTo3LGM6NixoOjEsbDoyLG06MixxOjQsczo0LHQ6Mix2OjEsejowfSxwPS8oW2FzdHZ6cW1obGNdKShbXmFzdHZ6cW1obGNdKikvaWc7ZnVuY3Rpb24gTyh3KXt2YXIgQj1bXTtyZXR1cm4gdy5yZXBsYWNlKHAsZnVuY3Rpb24oRCxJLGope3ZhciBWPUkudG9Mb3dlckNhc2UoKTtmb3Ioaj1iKGopLFY9PSJtIiYmai5sZW5ndGg+MiYmKEIucHVzaChbSV0uY29uY2F0KGouc3BsaWNlKDAsMikpKSxWPSJsIixJPUk9PSJtIj8ibCI6IkwiKTs7KXtpZihqLmxlbmd0aD09RVtWXSlyZXR1cm4gai51bnNoaWZ0KEkpLEIucHVzaChqKTtpZihqLmxlbmd0aDxFW1ZdKXRocm93IG5ldyBFcnJvcigibWFsZm9ybWVkIHBhdGggZGF0YSIpO0IucHVzaChbSV0uY29uY2F0KGouc3BsaWNlKDAsRVtWXSkpKX19KSxCfXZhciBtPS8tP1swLTldKlwuP1swLTldKyg/OmVbLStdP1xkKyk/L2lnO2Z1bmN0aW9uIGIodyl7dmFyIEI9dy5tYXRjaChtKTtyZXR1cm4gQj9CLm1hcChOdW1iZXIpOltdfWZ1bmN0aW9uIE0odyl7dmFyIEI9d1swXVswXSxEPXdbMF1bMV0sST1CLGo9RDtyZXR1cm4gdy5mb3JFYWNoKGZ1bmN0aW9uKFYpe3ZhciBKPVZbMF0sXz1WWzJdLHN0PVZbNF0sRz1WWzZdLFk9VlsxXSxydD1WWzNdLG90PVZbNV0sYXQ9Vls3XTtCPU1hdGgubWluKEIsSixfLHN0LEcpLEQ9TWF0aC5taW4oRCxZLHJ0LG90LGF0KSxJPU1hdGgubWF4KEksSixfLHN0LEcpLGo9TWF0aC5tYXgoaixZLHJ0LG90LGF0KX0pLFtCLEQsSSxqXX1mdW5jdGlvbiB5KHcsQil7cmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyh3WzBdLUJbMF0sMikrTWF0aC5wb3cod1sxXS1CWzFdLDIpKStNYXRoLnNxcnQoTWF0aC5wb3cod1syXS1CWzJdLDIpK01hdGgucG93KHdbM10tQlszXSwyKSl9ZnVuY3Rpb24gUyh3LEIpe3ZhciBEPXdbMF0sST13WzJdLGo9d1s0XSxWPXdbNl0sSj13WzFdLF89d1szXSxzdD13WzVdLEc9d1s3XSxZPUJbMF0scnQ9QlsyXSxvdD1CWzRdLGF0PUJbNl0saHQ9QlsxXSxpdD1CWzNdLE10PUJbNV0sT3Q9Qls3XTtyZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KFktRCwyKStNYXRoLnBvdyhodC1KLDIpKStNYXRoLnNxcnQoTWF0aC5wb3cocnQtSSwyKStNYXRoLnBvdyhpdC1fLDIpKStNYXRoLnNxcnQoTWF0aC5wb3cob3QtaiwyKStNYXRoLnBvdyhNdC1zdCwyKSkrTWF0aC5zcXJ0KE1hdGgucG93KGF0LVYsMikrTWF0aC5wb3coT3QtRywyKSl9ZnVuY3Rpb24gcyh3LEIpe3ZhciBEPWwody5sZW5ndGgpLEk9W107RC5mb3JFYWNoKGZ1bmN0aW9uKFYpe3ZhciBKPTAsXz0wO1YuZm9yRWFjaChmdW5jdGlvbihzdCl7Sis9Uyh3W3N0XSxCW18rK10pfSksSS5wdXNoKHtpbmRleDpWLGRpc3RhbmNlOkp9KX0pLEkuc29ydChmdW5jdGlvbihWLEope3JldHVybiBWLmRpc3RhbmNlLUouZGlzdGFuY2V9KTt2YXIgaj1bXTtyZXR1cm4gSVswXS5pbmRleC5mb3JFYWNoKGZ1bmN0aW9uKFYpe2oucHVzaCh3W1ZdKX0pLGp9ZnVuY3Rpb24gYyh3LEIpe3ZhciBEPXYody5sZW5ndGgpLEk9W107RC5mb3JFYWNoKGZ1bmN0aW9uKFYpe3ZhciBKPTA7Vi5mb3JFYWNoKGZ1bmN0aW9uKF8pe0orPXkoTSh3W19dKSxNKEJbX10pKX0pLEkucHVzaCh7aW5kZXg6VixkaXN0YW5jZTpKfSl9KSxJLnNvcnQoZnVuY3Rpb24oVixKKXtyZXR1cm4gVi5kaXN0YW5jZS1KLmRpc3RhbmNlfSk7dmFyIGo9W107cmV0dXJuIElbMF0uaW5kZXguZm9yRWFjaChmdW5jdGlvbihWKXtqLnB1c2god1tWXSl9KSxqfWZ1bmN0aW9uIGwodyl7Zm9yKHZhciBCPVtdLEQ9MDtEPHc7RCsrKXtmb3IodmFyIEk9W10saj0wO2o8dztqKyspe3ZhciBWPWorRDtWPnctMSYmKFYtPXcpLElbVl09an1CLnB1c2goSSl9cmV0dXJuIEJ9ZnVuY3Rpb24gdih3KXtmb3IodmFyIEI9W10sRD0wO0Q8dztEKyspQi5wdXNoKEQpO3JldHVybiBUKEIpfWZ1bmN0aW9uIFQodyl7dmFyIEI9W10sRD1bXTtmdW5jdGlvbiBJKGope3ZhciBWLEo7Zm9yKFY9MDtWPGoubGVuZ3RoO1YrKylKPWouc3BsaWNlKFYsMSlbMF0sRC5wdXNoKEopLGoubGVuZ3RoPT0wJiZCLnB1c2goRC5zbGljZSgpKSxJKGopLGouc3BsaWNlKFYsMCxKKSxELnBvcCgpO3JldHVybiBCfXJldHVybiBJKHcpfXZhciBSPXt9O1IucGFyc2VyPU8sUi5sZXJwQ3VydmU9ZnVuY3Rpb24odyxCLEQpe3JldHVybiBSLmxlcnBQb2ludHMod1swXSx3WzFdLEJbMF0sQlsxXSxEKS5jb25jYXQoUi5sZXJwUG9pbnRzKHdbMl0sd1szXSxCWzJdLEJbM10sRCkpLmNvbmNhdChSLmxlcnBQb2ludHMod1s0XSx3WzVdLEJbNF0sQls1XSxEKSkuY29uY2F0KFIubGVycFBvaW50cyh3WzZdLHdbN10sQls2XSxCWzddLEQpKX0sUi5sZXJwUG9pbnRzPWZ1bmN0aW9uKHcsQixELEksail7cmV0dXJuW3crKEQtdykqaixCKyhJLUIpKmpdfSxSLnEyYj1mdW5jdGlvbih3LEIsRCxJLGosVil7cmV0dXJuW3csQiwodysyKkQpLzMsKEIrMipJKS8zLChqKzIqRCkvMywoVisyKkkpLzMsaixWXX0sUi5wYXRoMnNoYXBlcz1mdW5jdGlvbih3KXtmb3IodmFyIEI9Ui5wYXJzZXIodyksRD0wLEk9MCxqPTAsVj1CLmxlbmd0aCxKPVtdLF89bnVsbCxzdD12b2lkIDAsRz12b2lkIDAsWT12b2lkIDAscnQ9dm9pZCAwLG90PXZvaWQgMCxhdD12b2lkIDAsaHQ9dm9pZCAwO2o8VjtqKyspe3ZhciBpdD1CW2pdLE10PWl0WzBdLE90PUJbai0xXTtzd2l0Y2goTXQpe2Nhc2UibSI6b3Q9Si5sZW5ndGgsSltvdF09W10sXz1KW290XSxEPUQraXRbMV0sST1JK2l0WzJdO2JyZWFrO2Nhc2UiTSI6b3Q9Si5sZW5ndGgsSltvdF09W10sXz1KW290XSxEPWl0WzFdLEk9aXRbMl07YnJlYWs7Y2FzZSJsIjpfLnB1c2goW0QsSSxELEksRCxJLEQraXRbMV0sSStpdFsyXV0pLEQrPWl0WzFdLEkrPWl0WzJdO2JyZWFrO2Nhc2UiTCI6Xy5wdXNoKFtELEksaXRbMV0saXRbMl0saXRbMV0saXRbMl0saXRbMV0saXRbMl1dKSxEPWl0WzFdLEk9aXRbMl07YnJlYWs7Y2FzZSJoIjpfLnB1c2goW0QsSSxELEksRCxJLEQraXRbMV0sSV0pLEQrPWl0WzFdO2JyZWFrO2Nhc2UiSCI6Xy5wdXNoKFtELEksaXRbMV0sSSxpdFsxXSxJLGl0WzFdLEldKSxEPWl0WzFdO2JyZWFrO2Nhc2UidiI6Xy5wdXNoKFtELEksRCxJLEQsSSxELEkraXRbMV1dKSxJKz1pdFsxXTticmVhaztjYXNlIlYiOl8ucHVzaChbRCxJLEQsaXRbMV0sRCxpdFsxXSxELGl0WzFdXSksST1pdFsxXTticmVhaztjYXNlIkMiOl8ucHVzaChbRCxJLGl0WzFdLGl0WzJdLGl0WzNdLGl0WzRdLGl0WzVdLGl0WzZdXSksRD1pdFs1XSxJPWl0WzZdO2JyZWFrO2Nhc2UiUyI6T3RbMF09PT0iQyJ8fE90WzBdPT09ImMiP18ucHVzaChbRCxJLEQrT3RbNV0tT3RbM10sSStPdFs2XS1PdFs0XSxpdFsxXSxpdFsyXSxpdFszXSxpdFs0XV0pOihPdFswXT09PSJTInx8T3RbMF09PT0icyIpJiZfLnB1c2goW0QsSSxEK090WzNdLU90WzFdLEkrT3RbNF0tT3RbMl0saXRbMV0saXRbMl0saXRbM10saXRbNF1dKSxEPWl0WzNdLEk9aXRbNF07YnJlYWs7Y2FzZSJjIjpfLnB1c2goW0QsSSxEK2l0WzFdLEkraXRbMl0sRCtpdFszXSxJK2l0WzRdLEQraXRbNV0sSStpdFs2XV0pLEQ9RCtpdFs1XSxJPUkraXRbNl07YnJlYWs7Y2FzZSJzIjpPdFswXT09PSJDInx8T3RbMF09PT0iYyI/Xy5wdXNoKFtELEksRCtPdFs1XS1PdFszXSxJK090WzZdLU90WzRdLEQraXRbMV0sSStpdFsyXSxEK2l0WzNdLEkraXRbNF1dKTooT3RbMF09PT0iUyJ8fE90WzBdPT09InMiKSYmXy5wdXNoKFtELEksRCtPdFszXS1PdFsxXSxJK090WzRdLU90WzJdLEQraXRbMV0sSStpdFsyXSxEK2l0WzNdLEkraXRbNF1dKSxEPUQraXRbM10sST1JK2l0WzRdO2JyZWFrO2Nhc2UiYSI6YXQ9ZCh7cng6aXRbMV0scnk6aXRbMl0scHg6RCxweTpJLHhBeGlzUm90YXRpb246aXRbM10sbGFyZ2VBcmNGbGFnOml0WzRdLHN3ZWVwRmxhZzppdFs1XSxjeDpEK2l0WzZdLGN5OkkraXRbN119KSxodD1hdFthdC5sZW5ndGgtMV0sYXQuZm9yRWFjaChmdW5jdGlvbihVLCQpeyQ9PT0wP18ucHVzaChbRCxJLFUueDEsVS55MSxVLngyLFUueTIsVS54LFUueV0pOl8ucHVzaChbYXRbJC0xXS54LGF0WyQtMV0ueSxVLngxLFUueTEsVS54MixVLnkyLFUueCxVLnldKX0pLEQ9aHQueCxJPWh0Lnk7YnJlYWs7Y2FzZSJBIjphdD1kKHtyeDppdFsxXSxyeTppdFsyXSxweDpELHB5OkkseEF4aXNSb3RhdGlvbjppdFszXSxsYXJnZUFyY0ZsYWc6aXRbNF0sc3dlZXBGbGFnOml0WzVdLGN4Oml0WzZdLGN5Oml0WzddfSksaHQ9YXRbYXQubGVuZ3RoLTFdLGF0LmZvckVhY2goZnVuY3Rpb24oVSwkKXskPT09MD9fLnB1c2goW0QsSSxVLngxLFUueTEsVS54MixVLnkyLFUueCxVLnldKTpfLnB1c2goW2F0WyQtMV0ueCxhdFskLTFdLnksVS54MSxVLnkxLFUueDIsVS55MixVLngsVS55XSl9KSxEPWh0LngsST1odC55O2JyZWFrO2Nhc2UiUSI6Xy5wdXNoKFIucTJiKEQsSSxpdFsxXSxpdFsyXSxpdFszXSxpdFs0XSkpLEQ9aXRbM10sST1pdFs0XTticmVhaztjYXNlInEiOl8ucHVzaChSLnEyYihELEksRCtpdFsxXSxJK2l0WzJdLGl0WzNdK0QsaXRbNF0rSSkpLEQrPWl0WzNdLEkrPWl0WzRdO2JyZWFrO2Nhc2UiVCI6T3RbMF09PT0iUSJ8fE90WzBdPT09InEiPyhZPUQrT3RbM10tT3RbMV0scnQ9SStPdFs0XS1PdFsyXSxfLnB1c2goUi5xMmIoRCxJLFkscnQsaXRbMV0saXRbMl0pKSk6KE90WzBdPT09IlQifHxPdFswXT09PSJ0IikmJihfLnB1c2goUi5xMmIoRCxJLEQrRC1ZLEkrSS1ydCxpdFsxXSxpdFsyXSkpLFk9RCtELVkscnQ9SStJLXJ0KSxEPWl0WzFdLEk9aXRbMl07YnJlYWs7Y2FzZSJ0IjpPdFswXT09PSJRInx8T3RbMF09PT0icSI/KFk9RCtPdFszXS1PdFsxXSxydD1JK090WzRdLU90WzJdLF8ucHVzaChSLnEyYihELEksWSxydCxEK2l0WzFdLEkraXRbMl0pKSk6KE90WzBdPT09IlQifHxPdFswXT09PSJ0IikmJihfLnB1c2goUi5xMmIoRCxJLEQrRC1ZLEkrSS1ydCxEK2l0WzFdLEkraXRbMl0pKSxZPUQrRC1ZLHJ0PUkrSS1ydCksRCs9aXRbMV0sSSs9aXRbMl07YnJlYWs7Y2FzZSJaIjpzdD1fWzBdWzBdLEc9X1swXVsxXSxfLnB1c2goW0QsSSxzdCxHLHN0LEcsc3QsR10pO2JyZWFrO2Nhc2UieiI6c3Q9X1swXVswXSxHPV9bMF1bMV0sXy5wdXNoKFtELEksc3QsRyxzdCxHLHN0LEddKTticmVha319cmV0dXJuIEp9LFIuX3VwQ3VydmVzPWZ1bmN0aW9uKHcsQil7Zm9yKHZhciBEPTAsST0wLGo9dy5sZW5ndGg7RDxCO0QrKyl3LnB1c2god1tJXS5zbGljZSgwKSksSSsrLEk+ai0xJiYoSS09ail9O2Z1bmN0aW9uIEwodyxCLEQsSSxqLFYsSixfLHN0KXtyZXR1cm57bGVmdDpOKHcsQixELEksaixWLEosXyxzdCkscmlnaHQ6TihKLF8saixWLEQsSSx3LEIsMS1zdCwhMCl9fWZ1bmN0aW9uIE4odyxCLEQsSSxqLFYsSixfLHN0LEcpe3ZhciBZPShELXcpKnN0K3cscnQ9KEktQikqc3QrQixvdD0oai1EKSpzdCtELGF0PShWLUkpKnN0K0ksaHQ9KEotaikqc3QraixpdD0oXy1WKSpzdCtWLE10PShvdC1ZKSpzdCtZLE90PShhdC1ydCkqc3QrcnQsVT0oaHQtb3QpKnN0K290LCQ9KGl0LWF0KSpzdCthdCxRPShVLU10KSpzdCtNdCx0dD0oJC1PdCkqc3QrT3Q7cmV0dXJuIEc/W1EsdHQsTXQsT3QsWSxydCx3LEJdOlt3LEIsWSxydCxNdCxPdCxRLHR0XX1SLl9zcGxpdEN1cnZlcz1mdW5jdGlvbih3LEIpe2Zvcih2YXIgRD0wLEk9MDtEPEI7RCsrKXt2YXIgaj13W0ldLFY9TChqWzBdLGpbMV0salsyXSxqWzNdLGpbNF0sals1XSxqWzZdLGpbN10sLjUpO3cuc3BsaWNlKEksMSksdy5zcGxpY2UoSSwwLFYubGVmdCxWLnJpZ2h0KSxJKz0yLEk+PXcubGVuZ3RoLTEmJihJPTApfX07ZnVuY3Rpb24gQSh3LEIpe2Zvcih2YXIgRD1mdW5jdGlvbihWKXt2YXIgSj13W3cubGVuZ3RoLTFdLF89W107Si5mb3JFYWNoKGZ1bmN0aW9uKHN0KXtfLnB1c2goc3Quc2xpY2UoMCkpfSksdy5wdXNoKF8pfSxJPTA7STxCO0krKylEKCl9cmV0dXJuIFIubGVycD1mdW5jdGlvbih3LEIsRCl7cmV0dXJuIFIuX2xlcnAoUi5wYXRoMnNoYXBlcyh3KSxSLnBhdGgyc2hhcGVzKEIpLEQpfSxSLk1JTV9DVVJWRVNfQ09VTlQ9MTAwLFIuX3ByZXByb2Nlc3Npbmc9ZnVuY3Rpb24odyxCKXt2YXIgRD13Lmxlbmd0aCxJPUIubGVuZ3RoLGo9SlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh3KSksVj1KU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KEIpKTtyZXR1cm4gRD5JP0EoVixELUkpOkQ8SSYmQShqLEktRCksaj1jKGosViksai5mb3JFYWNoKGZ1bmN0aW9uKEosXyl7dmFyIHN0PUoubGVuZ3RoLEc9VltfXS5sZW5ndGg7c3Q+Rz9zdDxSLk1JTV9DVVJWRVNfQ09VTlQ/KFIuX3NwbGl0Q3VydmVzKEosUi5NSU1fQ1VSVkVTX0NPVU5ULXN0KSxSLl9zcGxpdEN1cnZlcyhWW19dLFIuTUlNX0NVUlZFU19DT1VOVC1HKSk6Ui5fc3BsaXRDdXJ2ZXMoVltfXSxzdC1HKTpzdDxHJiYoRzxSLk1JTV9DVVJWRVNfQ09VTlQ/KFIuX3NwbGl0Q3VydmVzKEosUi5NSU1fQ1VSVkVTX0NPVU5ULXN0KSxSLl9zcGxpdEN1cnZlcyhWW19dLFIuTUlNX0NVUlZFU19DT1VOVC1HKSk6Ui5fc3BsaXRDdXJ2ZXMoSixHLXN0KSl9KSxqLmZvckVhY2goZnVuY3Rpb24oSixfKXtqW19dPXMoSixWW19dKX0pLFtqLFZdfSxSLl9sZXJwPWZ1bmN0aW9uKHcsQixEKXt2YXIgST1bXTtyZXR1cm4gdy5mb3JFYWNoKGZ1bmN0aW9uKGosVil7dmFyIEo9W107ai5mb3JFYWNoKGZ1bmN0aW9uKF8sc3Qpe0oucHVzaChSLmxlcnBDdXJ2ZShfLEJbVl1bc3RdLEQpKX0pLEkucHVzaChKKX0pLEl9LFIuYW5pbWF0ZT1mdW5jdGlvbih3KXt2YXIgQj1SLnBhdGgyc2hhcGVzKHcuZnJvbSksRD1SLnBhdGgyc2hhcGVzKHcudG8pLEk9Ui5fcHJlcHJvY2Vzc2luZyhCLEQpLGo9bmV3IERhdGUsVj13LmVuZHx8ZnVuY3Rpb24oKXt9LEo9dy5wcm9ncmVzc3x8ZnVuY3Rpb24oKXt9LF89dy5iZWdpbnx8ZnVuY3Rpb24oKXt9LHN0PXcuZWFzaW5nfHxmdW5jdGlvbihhdCl7cmV0dXJuIGF0fSxHPW51bGwsWT1udWxsLHJ0PXcudGltZTtfKEIpO3ZhciBvdD1mdW5jdGlvbiBhdCgpe3ZhciBodD1uZXcgRGF0ZS1qO2lmKGh0Pj1ydCl7WT1ELEooWSwxKSxWKFkpLGNhbmNlbEFuaW1hdGlvbkZyYW1lKEcpO3JldHVybn12YXIgaXQ9c3QoaHQvcnQpO1k9Ui5fbGVycChJWzBdLElbMV0saXQpLEooWSxpdCksRz1yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYXQpfTtvdCgpfSxSfSl9LGZ1bmN0aW9uKGcsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIGR9KTt2YXIgbj10KDcxKSxpPXQoMjIxKSxmPXQoNzIpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCBoPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZURlZmF1bHQiKSx1PVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZSIpLGE9U3ltYm9sLmZvcigic3ByaXRlanNfZ2V0QXR0cmlidXRlIik7Y2xhc3MgZCBleHRlbmRzIG4uZGVmYXVsdHtjb25zdHJ1Y3RvcihwKXtzdXBlcihwKSx0aGlzW2hdKHtkOiIiLG5vcm1hbGl6ZTohMSxmaWxsQ29sb3I6dm9pZCAwLGZpbGxSdWxlOiJub256ZXJvIixzdHJva2VDb2xvcjp2b2lkIDAsbGluZVdpZHRoOjEsbGluZUpvaW46Im1pdGVyIixsaW5lQ2FwOiJidXR0Iixyb3VuZFNlZ21lbnRzOjIwLGxpbmVEYXNoOnZvaWQgMCxsaW5lRGFzaE9mZnNldDowLG1pdGVyTGltaXQ6MTAsdGV4dHVyZTp2b2lkIDAsdGV4dHVyZVJlY3Q6dm9pZCAwLHRleHR1cmVSZXBlYXQ6ITEsc291cmNlUmVjdDp2b2lkIDAsY2xpcFBhdGg6dm9pZCAwfSl9Z2V0IGQoKXtyZXR1cm4gdGhpc1thXSgiZCIpfXNldCBkKHApe3RoaXNbdV0oImQiLHApfWdldCBub3JtYWxpemUoKXtyZXR1cm4gdGhpc1thXSgibm9ybWFsaXplIil9c2V0IG5vcm1hbGl6ZShwKXt0aGlzW3VdKCJub3JtYWxpemUiLCEhcCl9Z2V0IGZpbGxDb2xvcigpe3JldHVybiB0aGlzW2FdKCJmaWxsQ29sb3IiKX1zZXQgZmlsbENvbG9yKHApe3RoaXNbdV0oImZpbGxDb2xvciIsT2JqZWN0KGkucGFyc2VDb2xvcikocCkpfWdldCBmaWxsUnVsZSgpe3JldHVybiB0aGlzW2FdKCJmaWxsUnVsZSIpfXNldCBmaWxsUnVsZShwKXtpZihwIT1udWxsJiZwIT09Im5vbnplcm8iJiZwIT09ImV2ZW5vZGQiKXRocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgZmlsbCBydWxlLiIpO3RoaXNbdV0oImZpbGxSdWxlIixwKX1nZXQgc3Ryb2tlQ29sb3IoKXtyZXR1cm4gdGhpc1thXSgic3Ryb2tlQ29sb3IiKX1zZXQgc3Ryb2tlQ29sb3IocCl7dGhpc1t1XSgic3Ryb2tlQ29sb3IiLE9iamVjdChpLnBhcnNlQ29sb3IpKHApKX1nZXQgbGluZVdpZHRoKCl7cmV0dXJuIHRoaXNbYV0oImxpbmVXaWR0aCIpfXNldCBsaW5lV2lkdGgocCl7dGhpc1t1XSgibGluZVdpZHRoIixPYmplY3QoZi50b051bWJlcikocCkpfWdldCBsaW5lSm9pbigpe3JldHVybiB0aGlzW2FdKCJsaW5lSm9pbiIpfXNldCBsaW5lSm9pbihwKXtpZihwIT1udWxsJiZwIT09Im1pdGVyIiYmcCE9PSJiZXZlbCImJnAhPT0icm91bmQiKXRocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgbGluZUpvaW4gdHlwZS4iKTt0aGlzW3VdKCJsaW5lSm9pbiIscCl9Z2V0IGxpbmVDYXAoKXtyZXR1cm4gdGhpc1thXSgibGluZUNhcCIpfXNldCBsaW5lQ2FwKHApe2lmKHAhPW51bGwmJnAhPT0iYnV0dCImJnAhPT0ic3F1YXJlIiYmcCE9PSJyb3VuZCIpdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCBsaW5lQ2FwIHR5cGUuIik7dGhpc1t1XSgibGluZUNhcCIscCl9Z2V0IGxpbmVEYXNoKCl7cmV0dXJuIHRoaXNbYV0oImxpbmVEYXNoIil9c2V0IGxpbmVEYXNoKHApe3A9T2JqZWN0KGYudG9BcnJheSkocCwhMCkscCE9bnVsbCYmIUFycmF5LmlzQXJyYXkocCkmJihwPVtwXSksdGhpc1t1XSgibGluZURhc2giLHA/cC5tYXAoZi50b051bWJlcik6bnVsbCl9Z2V0IGxpbmVEYXNoT2Zmc2V0KCl7cmV0dXJuIHRoaXNbYV0oImxpbmVEYXNoT2Zmc2V0Iil9c2V0IGxpbmVEYXNoT2Zmc2V0KHApe3RoaXNbdV0oImxpbmVEYXNoT2Zmc2V0IixPYmplY3QoZi50b051bWJlcikocCkpfWdldCBtaXRlckxpbWl0KCl7cmV0dXJuIHRoaXNbYV0oIm1pdGVyTGltaXQiKX1zZXQgbWl0ZXJMaW1pdChwKXt0aGlzW3VdKCJtaXRlckxpbWl0IixPYmplY3QoZi50b051bWJlcikocCkpfWdldCByb3VuZFNlZ21lbnRzKCl7cmV0dXJuIHRoaXNbYV0oInJvdW5kU2VnbWVudHMiKX1zZXQgcm91bmRTZWdtZW50cyhwKXt0aGlzW3VdKCJyb3VuZFNlZ21lbnRzIixwKX1nZXQgdGV4dHVyZSgpe3JldHVybiB0aGlzW2FdKCJ0ZXh0dXJlIil9c2V0IHRleHR1cmUocCl7dGhpc1t1XSgidGV4dHVyZSIscCl9Z2V0IHRleHR1cmVSZWN0KCl7cmV0dXJuIHRoaXNbYV0oInRleHR1cmVSZWN0Iil9c2V0IHRleHR1cmVSZWN0KHApe3RoaXNbdV0oInRleHR1cmVSZWN0IixwKX1nZXQgc291cmNlUmVjdCgpe3JldHVybiB0aGlzW2FdKCJzb3VyY2VSZWN0Iil9c2V0IHNvdXJjZVJlY3QocCl7dGhpc1t1XSgic291cmNlUmVjdCIscCl9Z2V0IHRleHR1cmVSZXBlYXQoKXtyZXR1cm4gdGhpc1thXSgidGV4dHVyZVJlcGVhdCIpfXNldCB0ZXh0dXJlUmVwZWF0KHApe3RoaXNbdV0oInRleHR1cmVSZXBlYXQiLCEhcCl9Z2V0IGNsaXBQYXRoKCl7cmV0dXJuIHRoaXNbYV0oImNsaXBQYXRoIil9c2V0IGNsaXBQYXRoKHApe3RoaXNbdV0oImNsaXBQYXRoIixwKX19fSxmdW5jdGlvbihnLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiB1fSk7dmFyIG49dCgyMjYpLGk9dCgyMTMpLGY9dCgyMzApO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBoKGEsZCxFKXtyZXR1cm4gZCBpbiBhP09iamVjdC5kZWZpbmVQcm9wZXJ0eShhLGQse3ZhbHVlOkUsZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTphW2RdPUUsYX1jbGFzcyB1IGV4dGVuZHMgbi5kZWZhdWx0e2dldCBpc1Zpc2libGUoKXtjb25zdHt3aWR0aDpkLGhlaWdodDpFfT10aGlzLmF0dHJpYnV0ZXM7cmV0dXJuIGQ+MCYmRT4wJiZzdXBlci5pc1Zpc2libGV9fWgodSwiQXR0ciIsZi5kZWZhdWx0KSxpLmRlZmF1bHQucmVnaXN0ZXJOb2RlKHUsInJlY3QiKX0sZnVuY3Rpb24oZyxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gRX0pO3ZhciBuPXQoMjI4KSxpPXQoNzIpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCBmPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZURlZmF1bHQiKSxoPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZSIpLHU9U3ltYm9sLmZvcigic3ByaXRlanNfZ2V0QXR0cmlidXRlIiksYT1TeW1ib2wuZm9yKCJzcHJpdGVqc19kZWNsYXJlQWxpYXMiKTtmdW5jdGlvbiBkKHApe2NvbnN0e3dpZHRoOk8saGVpZ2h0Om19PXA7cmV0dXJuYE0wIDBMJHtPfSAwTCR7T30gJHttfUwwICR7bX1aYH1jbGFzcyBFIGV4dGVuZHMgbi5kZWZhdWx0e2NvbnN0cnVjdG9yKE8pe3N1cGVyKE8pLHRoaXNbZl0oe3dpZHRoOjAsaGVpZ2h0OjB9KSx0aGlzW2FdKCJzaXplIil9Z2V0IGQoKXtyZXR1cm4gdGhpc1t1XSgiZCIpfXNldCBkKE8pe31nZXQgd2lkdGgoKXtyZXR1cm4gdGhpc1t1XSgid2lkdGgiKX1zZXQgd2lkdGgoTyl7aWYoTz1PYmplY3QoaS50b051bWJlcikoTyksdGhpc1toXSgid2lkdGgiLE8pKXtjb25zdCBtPWQodGhpcyk7dGhpc1toXSgiZCIsbSl9fWdldCBoZWlnaHQoKXtyZXR1cm4gdGhpc1t1XSgiaGVpZ2h0Iil9c2V0IGhlaWdodChPKXtpZihPPU9iamVjdChpLnRvTnVtYmVyKShPKSx0aGlzW2hdKCJoZWlnaHQiLE8pKXtjb25zdCBtPWQodGhpcyk7dGhpc1toXSgiZCIsbSl9fWdldCBzaXplKCl7cmV0dXJuW3RoaXMud2lkdGgsdGhpcy5oZWlnaHRdfXNldCBzaXplKE8pe089T2JqZWN0KGkudG9BcnJheSkoTyksQXJyYXkuaXNBcnJheShPKXx8KE89W08sT10pLHRoaXMud2lkdGg9T1swXSx0aGlzLmhlaWdodD1PWzFdfX19LGZ1bmN0aW9uKGcsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIHV9KTt2YXIgbj10KDIzMiksaT10KDIxMyksZj10KDIzNSk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIGgoYSxkLEUpe3JldHVybiBkIGluIGE/T2JqZWN0LmRlZmluZVByb3BlcnR5KGEsZCx7dmFsdWU6RSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOmFbZF09RSxhfWNsYXNzIHUgZXh0ZW5kcyBuLmRlZmF1bHR7Z2V0IGlzVmlzaWJsZSgpe2NvbnN0e3NpZGVzOmR9PXRoaXMuYXR0cmlidXRlcztyZXR1cm4gZFswXT4wJiZkWzFdPjAmJnN1cGVyLmlzVmlzaWJsZX19aCh1LCJBdHRyIixmLmRlZmF1bHQpLGkuZGVmYXVsdC5yZWdpc3Rlck5vZGUodSwidHJpYW5nbGUiKX0sZnVuY3Rpb24oZyxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gdX0pO3ZhciBuPXQoMjI2KSxpPXQoMjEzKSxmPXQoMjMzKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gaChhLGQsRSl7cmV0dXJuIGQgaW4gYT9PYmplY3QuZGVmaW5lUHJvcGVydHkoYSxkLHt2YWx1ZTpFLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6YVtkXT1FLGF9Y2xhc3MgdSBleHRlbmRzIG4uZGVmYXVsdHtnZXQgaXNWaXNpYmxlKCl7Y29uc3R7cG9pbnRzOmR9PXRoaXMuYXR0cmlidXRlcztyZXR1cm4gZC5sZW5ndGg+MCYmc3VwZXIuaXNWaXNpYmxlfX1oKHUsIkF0dHIiLGYuZGVmYXVsdCksaS5kZWZhdWx0LnJlZ2lzdGVyTm9kZSh1LCJwb2x5bGluZSIpfSxmdW5jdGlvbihnLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBwfSk7dmFyIG49dCgyMjgpLGk9dCg3MiksZj10KDIzNCk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IGg9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlRGVmYXVsdCIpLHU9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlIiksYT1TeW1ib2wuZm9yKCJzcHJpdGVqc19nZXRBdHRyaWJ1dGUiKSxkPVN5bWJvbC5mb3IoInNwcml0ZWpzX2RlY2xhcmVBbGlhcyIpO2Z1bmN0aW9uIEUoTyl7Y29uc3R7cG9pbnRzOm0sc21vb3RoOmIsc21vb3RoUmFuZ2U6TSxjbG9zZTp5fT1PLFM9W107Zm9yKGxldCBjPTA7YzxtLmxlbmd0aDtjKz0yKVMucHVzaChbbVtjXSxtW2MrMV1dKTtsZXQgcz0iIjtyZXR1cm4gYj9zPU9iamVjdChmLm1ha2VTbW9vdGhDdXJ2ZUxpbmUpKFMsTSk6Uy5sZW5ndGgmJihzPWBNJHtTLm1hcChjPT5jLmpvaW4oIiAiKSkuam9pbigiTCIpfWApLHMmJnkmJihzKz0iWiIpLHN9Y2xhc3MgcCBleHRlbmRzIG4uZGVmYXVsdHtjb25zdHJ1Y3RvcihtKXtzdXBlcihtKSx0aGlzW2hdKHtwb2ludHM6W10sc21vb3RoOiExLHNtb290aFJhbmdlOlswXSxjbG9zZVR5cGU6Im5vbmUifSksdGhpc1tkXSgiY2xvc2UiKX1nZXQgZCgpe3JldHVybiB0aGlzW2FdKCJkIil9c2V0IGQobSl7fWdldCBjbG9zZSgpe3JldHVybiB0aGlzLmNsb3NlVHlwZSE9PSJub25lIn1zZXQgY2xvc2UobSl7bT1tPyJub3JtYWwiOiJub25lIix0aGlzLmNsb3NlVHlwZT1tfWdldCBjbG9zZVR5cGUoKXtyZXR1cm4gdGhpc1thXSgiY2xvc2VUeXBlIil9c2V0IGNsb3NlVHlwZShtKXtpZihtIT1udWxsJiZtIT09Im5vbmUiJiZtIT09Im5vcm1hbCIpdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCBjbG9zZVR5cGUgdHlwZS4iKTtpZih0aGlzW3VdKCJjbG9zZVR5cGUiLG0pKXtjb25zdCBiPUUodGhpcyk7dGhpc1t1XSgiZCIsYil9fWdldCBzbW9vdGgoKXtyZXR1cm4gdGhpc1thXSgic21vb3RoIil9c2V0IHNtb290aChtKXtpZih0aGlzW3VdKCJzbW9vdGgiLG0pKXtjb25zdCBiPUUodGhpcyk7dGhpc1t1XSgiZCIsYil9fWdldCBzbW9vdGhSYW5nZSgpe3JldHVybiB0aGlzW2FdKCJzbW9vdGhSYW5nZSIpfXNldCBzbW9vdGhSYW5nZShtKXtpZihtJiYhQXJyYXkuaXNBcnJheShtKSYmKG09W21dKSx0aGlzW3VdKCJzbW9vdGhSYW5nZSIsbSkmJnRoaXMuc21vb3RoKXtjb25zdCBiPUUodGhpcyk7dGhpc1t1XSgiZCIsYil9fWdldCBwb2ludHMoKXtyZXR1cm4gdGhpc1thXSgicG9pbnRzIil9c2V0IHBvaW50cyhtKXtpZihtPU9iamVjdChpLnRvQXJyYXkpKG0pLEFycmF5LmlzQXJyYXkobSkmJihtPW0ucmVkdWNlKChiLE0pPT5BcnJheS5pc0FycmF5KE0pP1suLi5iLC4uLk0ubWFwKHk9Pk9iamVjdChpLnRvTnVtYmVyKSh5KSldOlsuLi5iLE9iamVjdChpLnRvTnVtYmVyKShNKV0sW10pKSx0aGlzW3VdKCJwb2ludHMiLG0pKXtjb25zdCBiPUUodGhpcyk7dGhpc1t1XSgiZCIsYil9fX19LGZ1bmN0aW9uKGcsZSx0KXt0LnIoZSksdC5kKGUsIm1ha2VTbW9vdGhDdXJ2ZUxpbmUiLGZ1bmN0aW9uKCl7cmV0dXJuIG59KSx0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gbihpLGY9WzBdKXtmdW5jdGlvbiBoKGQsRT0uMTY4LHA9LjE2OCl7bGV0IE8sbSxiLE07aWYoKGlbZF0ueD09PWlbZCsxXS54fHxpW2RdLnk9PT1pW2QrMV0ueSkmJihFPTAscD0wKSxkPDE/KE89aVswXS54KyhpWzFdLngtaVswXS54KSpFLG09aVswXS55KyhpWzFdLnktaVswXS55KSpFKTooTz1pW2RdLngrKGlbZCsxXS54LWlbZC0xXS54KSpFLG09aVtkXS55KyhpW2QrMV0ueS1pW2QtMV0ueSkqRSksZD5pLmxlbmd0aC0zKXtjb25zdCB5PWkubGVuZ3RoLTE7Yj1pW3ldLngtKGlbeV0ueC1pW3ktMV0ueCkqcCxNPWlbeV0ueS0oaVt5XS55LWlbeS0xXS55KSpwfWVsc2UgYj1pW2QrMV0ueC0oaVtkKzJdLngtaVtkXS54KSpwLE09aVtkKzFdLnktKGlbZCsyXS55LWlbZF0ueSkqcDtyZXR1cm5be3g6Tyx5Om19LHt4OmIseTpNfV19aT1pLm1hcCgoW2QsRV0pPT4oe3g6ZCx5OkV9KSk7bGV0IHU9IiIsYT0wO3JldHVybiBpLmZvckVhY2goKGQsRSk9PntpZihFPT09MCl1Kz1gTSR7ZC54fSAke2QueX1gO2Vsc2V7Zm9yKDtFPmZbYV07KWErKztpZihhJTIpe2NvbnN0W3AsT109aChFLTEpO3UrPWBDJHtbcC54LHAueSxPLngsTy55LGQueCxkLnldLmpvaW4oIiAiKX1gfWVsc2UgdSs9YEwke2QueH0gJHtkLnl9YH19KSx1fX0sZnVuY3Rpb24oZyxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gZH0pO3ZhciBuPXQoMjMzKSxpPXQoNzIpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCBmPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZURlZmF1bHQiKSxoPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZSIpLHU9U3ltYm9sLmZvcigic3ByaXRlanNfZ2V0QXR0cmlidXRlIik7ZnVuY3Rpb24gYShFKXtjb25zdFtwLE9dPUUuc2lkZXM7bGV0IG09RS5hbmdsZSUzNjA7cmV0dXJuIG08MCYmKG0rPTM2MCksbT1NYXRoLlBJKm0vMTgwLFswLDAscCwwLE8qTWF0aC5jb3MobSksTypNYXRoLnNpbihtKV19Y2xhc3MgZCBleHRlbmRzIG4uZGVmYXVsdHtjb25zdHJ1Y3RvcihwKXtzdXBlcihwKSx0aGlzW2ZdKHtzaWRlczpbMCwwXSxhbmdsZTo2MCxjbG9zZVR5cGU6Im5vcm1hbCJ9KX1nZXQgcG9pbnRzKCl7cmV0dXJuIHN1cGVyLnBvaW50c31zZXQgcG9pbnRzKHApe31nZXQgc2lkZXMoKXtyZXR1cm4gdGhpc1t1XSgic2lkZXMiKX1zZXQgc2lkZXMocCl7aWYocD1PYmplY3QoaS50b0FycmF5KShwLCEwKSxwIT1udWxsJiYhQXJyYXkuaXNBcnJheShwKSYmKHA9W3AscF0pLHRoaXNbaF0oInNpZGVzIixwKSl7Y29uc3QgTz1hKHRoaXMpO3N1cGVyLnBvaW50cz1PfX1nZXQgYW5nbGUoKXtyZXR1cm4gdGhpc1t1XSgiYW5nbGUiKX1zZXQgYW5nbGUocCl7aWYocD1PYmplY3QoaS50b051bWJlcikocCksdGhpc1toXSgiYW5nbGUiLHApKXtjb25zdCBPPWEodGhpcyk7c3VwZXIucG9pbnRzPU99fX19LGZ1bmN0aW9uKGcsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIHV9KTt2YXIgbj10KDIzMiksaT10KDIxMyksZj10KDIzNyk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIGgoYSxkLEUpe3JldHVybiBkIGluIGE/T2JqZWN0LmRlZmluZVByb3BlcnR5KGEsZCx7dmFsdWU6RSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOmFbZF09RSxhfWNsYXNzIHUgZXh0ZW5kcyBuLmRlZmF1bHR7Z2V0IGlzVmlzaWJsZSgpe2NvbnN0e3NpZGVzOmR9PXRoaXMuYXR0cmlidXRlcztyZXR1cm4gZFswXT4wJiZkWzFdPjAmJnN1cGVyLmlzVmlzaWJsZX19aCh1LCJBdHRyIixmLmRlZmF1bHQpLGkuZGVmYXVsdC5yZWdpc3Rlck5vZGUodSwicGFyYWxsZWwiKX0sZnVuY3Rpb24oZyxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gZH0pO3ZhciBuPXQoMjMzKSxpPXQoNzIpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCBmPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZURlZmF1bHQiKSxoPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZSIpLHU9U3ltYm9sLmZvcigic3ByaXRlanNfZ2V0QXR0cmlidXRlIik7ZnVuY3Rpb24gYShFKXtjb25zdFtwLE9dPUUuc2lkZXM7bGV0IG09RS5hbmdsZSUzNjA7bTwwJiYobSs9MzYwKSxtPU1hdGguUEkqbS8xODA7Y29uc3QgYj1PKk1hdGguY29zKG0pLE09TypNYXRoLnNpbihtKTtyZXR1cm5bMCwwLHAsMCxiK3AsTSxiLE1dfWNsYXNzIGQgZXh0ZW5kcyBuLmRlZmF1bHR7Y29uc3RydWN0b3IocCl7c3VwZXIocCksdGhpc1tmXSh7c2lkZXM6WzAsMF0sYW5nbGU6OTAsY2xvc2VUeXBlOiJub3JtYWwifSl9Z2V0IHBvaW50cygpe3JldHVybiBzdXBlci5wb2ludHN9c2V0IHBvaW50cyhwKXt9Z2V0IHNpZGVzKCl7cmV0dXJuIHRoaXNbdV0oInNpZGVzIil9c2V0IHNpZGVzKHApe2lmKHA9T2JqZWN0KGkudG9BcnJheSkocCwhMCkscCE9bnVsbCYmIUFycmF5LmlzQXJyYXkocCkmJihwPVtwLHBdKSx0aGlzW2hdKCJzaWRlcyIscCkpe2NvbnN0IE89YSh0aGlzKTtzdXBlci5wb2ludHM9T319Z2V0IGFuZ2xlKCl7cmV0dXJuIHRoaXNbdV0oImFuZ2xlIil9c2V0IGFuZ2xlKHApe2lmKHA9T2JqZWN0KGkudG9OdW1iZXIpKHApLHRoaXNbaF0oImFuZ2xlIixwKSl7Y29uc3QgTz1hKHRoaXMpO3N1cGVyLnBvaW50cz1PfX19fSxmdW5jdGlvbihnLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiB1fSk7dmFyIG49dCgyMzIpLGk9dCgyMTMpLGY9dCgyMzkpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBoKGEsZCxFKXtyZXR1cm4gZCBpbiBhP09iamVjdC5kZWZpbmVQcm9wZXJ0eShhLGQse3ZhbHVlOkUsZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTphW2RdPUUsYX1jbGFzcyB1IGV4dGVuZHMgbi5kZWZhdWx0e31oKHUsIkF0dHIiLGYuZGVmYXVsdCksaS5kZWZhdWx0LnJlZ2lzdGVyTm9kZSh1LCJyZWd1bGFyIil9LGZ1bmN0aW9uKGcsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIGR9KTt2YXIgbj10KDIzMyksaT10KDcyKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3QgZj1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGVEZWZhdWx0IiksaD1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGUiKSx1PVN5bWJvbC5mb3IoInNwcml0ZWpzX2dldEF0dHJpYnV0ZSIpO2Z1bmN0aW9uIGEoRSl7Y29uc3R7ZWRnZXM6cCxyYWRpdXM6TyxvZmZzZXRBbmdsZTptfT1FLGI9TWF0aC5QSSptLzE4MC0uNSpNYXRoLlBJO2lmKHA8M3x8Tzw9MClyZXR1cm5bXTtjb25zdCBNPVtdO2ZvcihsZXQgeT0wO3k8cDt5Kyspe2NvbnN0IFM9eSoyKk1hdGguUEkvcCtiLHM9TypNYXRoLmNvcyhTKSxjPU8qTWF0aC5zaW4oUyk7TS5wdXNoKHMsYyl9cmV0dXJuIE19Y2xhc3MgZCBleHRlbmRzIG4uZGVmYXVsdHtjb25zdHJ1Y3RvcihwKXtzdXBlcihwKSx0aGlzW2ZdKHtlZGdlczozLHJhZGl1czowLG9mZnNldEFuZ2xlOjAsY2xvc2VUeXBlOiJub3JtYWwifSl9Z2V0IHBvaW50cygpe3JldHVybiBzdXBlci5wb2ludHN9c2V0IHBvaW50cyhwKXt9Z2V0IGVkZ2VzKCl7cmV0dXJuIHRoaXNbdV0oImVkZ2VzIil9c2V0IGVkZ2VzKHApe2lmKHA9T2JqZWN0KGkudG9OdW1iZXIpKHApLHRoaXNbaF0oImVkZ2VzIixwKSl7Y29uc3QgTz1hKHRoaXMpO3N1cGVyLnBvaW50cz1PfX1nZXQgcmFkaXVzKCl7cmV0dXJuIHRoaXNbdV0oInJhZGl1cyIpfXNldCByYWRpdXMocCl7aWYocD1PYmplY3QoaS50b051bWJlcikocCksdGhpc1toXSgicmFkaXVzIixwKSl7Y29uc3QgTz1hKHRoaXMpO3N1cGVyLnBvaW50cz1PfX1nZXQgb2Zmc2V0QW5nbGUoKXtyZXR1cm4gdGhpc1t1XSgib2Zmc2V0QW5nbGUiKX1zZXQgb2Zmc2V0QW5nbGUocCl7aWYocD1PYmplY3QoaS50b051bWJlcikocCksdGhpc1toXSgib2Zmc2V0QW5nbGUiLHApKXtjb25zdCBPPWEodGhpcyk7c3VwZXIucG9pbnRzPU99fX19LGZ1bmN0aW9uKGcsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIHV9KTt2YXIgbj10KDIzMiksaT10KDIxMyksZj10KDI0MSk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIGgoYSxkLEUpe3JldHVybiBkIGluIGE/T2JqZWN0LmRlZmluZVByb3BlcnR5KGEsZCx7dmFsdWU6RSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOmFbZF09RSxhfWNsYXNzIHUgZXh0ZW5kcyBuLmRlZmF1bHR7fWgodSwiQXR0ciIsZi5kZWZhdWx0KSxpLmRlZmF1bHQucmVnaXN0ZXJOb2RlKHUsInN0YXIiKX0sZnVuY3Rpb24oZyxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gZH0pO3ZhciBuPXQoMjMzKSxpPXQoNzIpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCBmPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZURlZmF1bHQiKSxoPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZSIpLHU9U3ltYm9sLmZvcigic3ByaXRlanNfZ2V0QXR0cmlidXRlIik7ZnVuY3Rpb24gYShFKXtjb25zdHthbmdsZXM6cCxpbm5lclJhZGl1czpPLG91dGVyUmFkaXVzOm0sb2Zmc2V0QW5nbGU6Yn09RSxNPU1hdGguUEkqYi8xODAtLjUqTWF0aC5QSTtpZihwPDN8fE88PTB8fG08PTApcmV0dXJuW107Y29uc3QgeT1bXTtmb3IobGV0IFM9MDtTPHAqMjtTKyspe2NvbnN0IHM9UypNYXRoLlBJL3ArTSxjPVMlMj9POm0sbD1jKk1hdGguY29zKHMpLHY9YypNYXRoLnNpbihzKTt5LnB1c2gobCx2KX1yZXR1cm4geX1jbGFzcyBkIGV4dGVuZHMgbi5kZWZhdWx0e2NvbnN0cnVjdG9yKHApe3N1cGVyKHApLHRoaXNbZl0oe2FuZ2xlczo1LGlubmVyUmFkaXVzOjAsb3V0ZXJSYWRpdXM6MCxvZmZzZXRBbmdsZTowLGNsb3NlVHlwZToibm9ybWFsIn0pfWdldCBwb2ludHMoKXtyZXR1cm4gc3VwZXIucG9pbnRzfXNldCBwb2ludHMocCl7fWdldCBhbmdsZXMoKXtyZXR1cm4gdGhpc1t1XSgiYW5nbGVzIil9c2V0IGFuZ2xlcyhwKXtpZihwPU9iamVjdChpLnRvTnVtYmVyKShwKSx0aGlzW2hdKCJhbmdsZXMiLHApKXtjb25zdCBPPWEodGhpcyk7c3VwZXIucG9pbnRzPU99fWdldCBpbm5lclJhZGl1cygpe3JldHVybiB0aGlzW3VdKCJpbm5lclJhZGl1cyIpfXNldCBpbm5lclJhZGl1cyhwKXtpZihwPU9iamVjdChpLnRvTnVtYmVyKShwKSx0aGlzW2hdKCJpbm5lclJhZGl1cyIscCkpe2NvbnN0IE89YSh0aGlzKTtzdXBlci5wb2ludHM9T319Z2V0IG91dGVyUmFkaXVzKCl7cmV0dXJuIHRoaXNbdV0oIm91dGVyUmFkaXVzIil9c2V0IG91dGVyUmFkaXVzKHApe2lmKHA9T2JqZWN0KGkudG9OdW1iZXIpKHApLHRoaXNbaF0oIm91dGVyUmFkaXVzIixwKSl7Y29uc3QgTz1hKHRoaXMpO3N1cGVyLnBvaW50cz1PfX1nZXQgcmFkaXVzKCl7cmV0dXJuW3RoaXMuaW5uZXJSYWRpdXMsdGhpcy5vdXRlclJhZGl1c119c2V0IHJhZGl1cyhwKXtwPU9iamVjdChpLnRvQXJyYXkpKHAsITApLEFycmF5LmlzQXJyYXkocCl8fChwPVtwLHBdKSx0aGlzLmlubmVyUmFkaXVzPXBbMF0sdGhpcy5vdXRlclJhZGl1cz1wWzFdfWdldCBvZmZzZXRBbmdsZSgpe3JldHVybiB0aGlzW3VdKCJvZmZzZXRBbmdsZSIpfXNldCBvZmZzZXRBbmdsZShwKXtpZihwPU9iamVjdChpLnRvTnVtYmVyKShwKSx0aGlzW2hdKCJvZmZzZXRBbmdsZSIscCkpe2NvbnN0IE89YSh0aGlzKTtzdXBlci5wb2ludHM9T319fX0sZnVuY3Rpb24oZyxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gdX0pO3ZhciBuPXQoMjI2KSxpPXQoMjEzKSxmPXQoMjQzKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gaChhLGQsRSl7cmV0dXJuIGQgaW4gYT9PYmplY3QuZGVmaW5lUHJvcGVydHkoYSxkLHt2YWx1ZTpFLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6YVtkXT1FLGF9Y2xhc3MgdSBleHRlbmRzIG4uZGVmYXVsdHtnZXQgaXNWaXNpYmxlKCl7Y29uc3R7cmFkaXVzWDpkLHJhZGl1c1k6RSxzdGFydEFuZ2xlOnAsZW5kQW5nbGU6T309dGhpcy5hdHRyaWJ1dGVzO3JldHVybiBkPjAmJkU+MCYmcCE9PU8mJnN1cGVyLmlzVmlzaWJsZX19aCh1LCJBdHRyIixmLmRlZmF1bHQpLGkuZGVmYXVsdC5yZWdpc3Rlck5vZGUodSwiZWxsaXBzZSIpfSxmdW5jdGlvbihnLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBwfSk7dmFyIG49dCgxMiksaT10KDIyOCksZj10KDcyKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3QgaD1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGVEZWZhdWx0IiksdT1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGUiKSxhPVN5bWJvbC5mb3IoInNwcml0ZWpzX2dldEF0dHJpYnV0ZSIpLGQ9U3ltYm9sLmZvcigic3ByaXRlanNfZGVjbGFyZUFsaWFzIik7ZnVuY3Rpb24gRShPKXtjb25zdHtyYWRpdXNYOm0scmFkaXVzWTpiLHN0YXJ0QW5nbGU6TSxlbmRBbmdsZTp5LGRpcmVjdGlvbjpTLGNsb3NlVHlwZTpzfT1PLGM9Uz09PSJhbml0Y2xvY2t3aXNlIixsPW5ldyBuLkZpZ3VyZTJEO3JldHVybiBzPT09InNlY3RvciImJmwubW92ZVRvKDAsMCksbC5lbGxpcHNlKDAsMCxtLGIsMCxNYXRoLlBJKk0vMTgwLE1hdGguUEkqeS8xODAsYykscyE9PSJub25lIiYmbC5jbG9zZVBhdGgoKSxsLnBhdGgucmVkdWNlKChSLEwpPT5SK0wuam9pbigiICIpLCIiKX1jbGFzcyBwIGV4dGVuZHMgaS5kZWZhdWx0e2NvbnN0cnVjdG9yKG0pe3N1cGVyKG0pLHRoaXNbaF0oe3JhZGl1c1g6MCxyYWRpdXNZOjAsc3RhcnRBbmdsZTowLGVuZEFuZ2xlOjM2MCxkaXJlY3Rpb246ImNsb2Nrd2lzZSIsY2xvc2VUeXBlOiJub25lIn0pLHRoaXNbZF0oInJhZGl1cyIsImFuZ2xlIil9Z2V0IGQoKXtyZXR1cm4gdGhpc1thXSgiZCIpfXNldCBkKG0pe31nZXQgcmFkaXVzWCgpe3JldHVybiB0aGlzW2FdKCJyYWRpdXNYIil9c2V0IHJhZGl1c1gobSl7aWYobT1PYmplY3QoZi50b051bWJlcikobSksdGhpc1t1XSgicmFkaXVzWCIsbSkpe2NvbnN0IGI9RSh0aGlzKTt0aGlzW3VdKCJkIixiKX19Z2V0IHJhZGl1c1koKXtyZXR1cm4gdGhpc1thXSgicmFkaXVzWSIpfXNldCByYWRpdXNZKG0pe2lmKG09T2JqZWN0KGYudG9OdW1iZXIpKG0pLHRoaXNbdV0oInJhZGl1c1kiLG0pKXtjb25zdCBiPUUodGhpcyk7dGhpc1t1XSgiZCIsYil9fWdldCByYWRpdXMoKXtyZXR1cm5bdGhpcy5yYWRpdXNYLHRoaXMucmFkaXVzWV19c2V0IHJhZGl1cyhtKXttPU9iamVjdChmLnRvQXJyYXkpKG0sITApLEFycmF5LmlzQXJyYXkobSl8fChtPVttLG1dKSx0aGlzLnJhZGl1c1g9bVswXSx0aGlzLnJhZGl1c1k9bVsxXX1nZXQgYW5nbGUoKXtyZXR1cm5bdGhpcy5zdGFydEFuZ2xlLHRoaXMuZW5kQW5nbGVdfXNldCBhbmdsZShtKXttPU9iamVjdChmLnRvQXJyYXkpKG0pLEFycmF5LmlzQXJyYXkobSl8fChtPVttLG1dKSx0aGlzLnN0YXJ0QW5nbGU9bVswXSx0aGlzLmVuZEFuZ2xlPW1bMV19Z2V0IGRpcmVjdGlvbigpe3JldHVybiB0aGlzW2FdKCJkaXJlY3Rpb24iKX1zZXQgZGlyZWN0aW9uKG0pe2lmKG0hPW51bGwmJm0hPT0iY2xvY2t3aXNlIiYmbSE9PSJhbnRpY2xvY2t3aXNlIil0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIGRpcmVjdGlvbiB0eXBlLiIpO3RoaXNbdV0oImRpcmVjdGlvbiIsbSl9Z2V0IHN0YXJ0QW5nbGUoKXtyZXR1cm4gdGhpc1thXSgic3RhcnRBbmdsZSIpfXNldCBzdGFydEFuZ2xlKG0pe2lmKG09T2JqZWN0KGYudG9OdW1iZXIpKG0pLHRoaXNbdV0oInN0YXJ0QW5nbGUiLG0pKXtjb25zdCBiPUUodGhpcyk7dGhpc1t1XSgiZCIsYil9fWdldCBlbmRBbmdsZSgpe3JldHVybiB0aGlzW2FdKCJlbmRBbmdsZSIpfXNldCBlbmRBbmdsZShtKXtpZihtPU9iamVjdChmLnRvTnVtYmVyKShtKSx0aGlzW3VdKCJlbmRBbmdsZSIsbSkpe2NvbnN0IGI9RSh0aGlzKTt0aGlzW3VdKCJkIixiKX19Z2V0IGNsb3NlVHlwZSgpe3JldHVybiB0aGlzW2FdKCJjbG9zZVR5cGUiKX1zZXQgY2xvc2VUeXBlKG0pe2lmKG0hPW51bGwmJm0hPT0ibm9uZSImJm0hPT0ic2VjdG9yIiYmbSE9PSJub3JtYWwiKXRocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgY2xvc2VUeXBlIHR5cGUuIik7aWYodGhpc1t1XSgiY2xvc2VUeXBlIixtKSl7Y29uc3QgYj1FKHRoaXMpO3RoaXNbdV0oImQiLGIpfX19fSxmdW5jdGlvbihnLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiB1fSk7dmFyIG49dCgyNDIpLGk9dCgyMTMpLGY9dCgyNDUpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBoKGEsZCxFKXtyZXR1cm4gZCBpbiBhP09iamVjdC5kZWZpbmVQcm9wZXJ0eShhLGQse3ZhbHVlOkUsZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTphW2RdPUUsYX1jbGFzcyB1IGV4dGVuZHMgbi5kZWZhdWx0e31oKHUsIkF0dHIiLGYuZGVmYXVsdCksaS5kZWZhdWx0LnJlZ2lzdGVyTm9kZSh1LCJhcmMiKX0sZnVuY3Rpb24oZyxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gZn0pO3ZhciBuPXQoMjQzKSxpPXQoNzIpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjbGFzcyBmIGV4dGVuZHMgbi5kZWZhdWx0e2dldCByYWRpdXMoKXtyZXR1cm4gc3VwZXIucmFkaXVzWH1zZXQgcmFkaXVzKHUpe3U9T2JqZWN0KGkudG9OdW1iZXIpKHUpLHN1cGVyLnJhZGl1c1g9dSxzdXBlci5yYWRpdXNZPXV9fX0sZnVuY3Rpb24oZyxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gdX0pO3ZhciBuPXQoMjI2KSxpPXQoMjEzKSxmPXQoMjQ3KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gaChhLGQsRSl7cmV0dXJuIGQgaW4gYT9PYmplY3QuZGVmaW5lUHJvcGVydHkoYSxkLHt2YWx1ZTpFLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6YVtkXT1FLGF9Y2xhc3MgdSBleHRlbmRzIG4uZGVmYXVsdHtnZXQgaXNWaXNpYmxlKCl7Y29uc3R7aW5uZXJSYWRpdXM6ZCxvdXRlclJhZGl1czpFLHN0YXJ0QW5nbGU6cCxlbmRBbmdsZTpPfT10aGlzLmF0dHJpYnV0ZXM7cmV0dXJuKGQ+MHx8RT4wKSYmcCE9PU8mJnN1cGVyLmlzVmlzaWJsZX19aCh1LCJBdHRyIixmLmRlZmF1bHQpLGkuZGVmYXVsdC5yZWdpc3Rlck5vZGUodSwicmluZyIpfSxmdW5jdGlvbihnLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBwfSk7dmFyIG49dCgxMiksaT10KDIyOCksZj10KDcyKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3QgaD1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGVEZWZhdWx0IiksdT1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGUiKSxhPVN5bWJvbC5mb3IoInNwcml0ZWpzX2dldEF0dHJpYnV0ZSIpLGQ9U3ltYm9sLmZvcigic3ByaXRlanNfZGVjbGFyZUFsaWFzIik7ZnVuY3Rpb24gRShPKXtsZXR7aW5uZXJSYWRpdXM6bSxvdXRlclJhZGl1czpiLHN0YXJ0QW5nbGU6TSxlbmRBbmdsZTp5fT1PO2NvbnN0IFM9bmV3IG4uRmlndXJlMkQ7aWYoTT1NYXRoLlBJKk0vMTgwLHk9TWF0aC5QSSp5LzE4MCxtPmImJihbbSxiXT1bYixtXSksbTw9MCYmUy5tb3ZlVG8oMCwwKSxTLmFyYygwLDAsYixNLHksITEpLG0+MCl7Y29uc3QgbD1NYXRoLlBJKjI7eTxNJiYoeT1NK2wrKHktTSklbCkseS1NPj1sJiYoeT1NK2wtMWUtNiksUy5hcmMoMCwwLG0seSxNLCEwKX1yZXR1cm4gUy5jbG9zZVBhdGgoKSxTLnBhdGgucmVkdWNlKChsLHYpPT5sK3Yuam9pbigiICIpLCIiKX1jbGFzcyBwIGV4dGVuZHMgaS5kZWZhdWx0e2NvbnN0cnVjdG9yKG0pe3N1cGVyKG0pLHRoaXNbaF0oe2lubmVyUmFkaXVzOjAsb3V0ZXJSYWRpdXM6MCxzdGFydEFuZ2xlOjAsZW5kQW5nbGU6MzYwfSksdGhpc1tkXSgicmFkaXVzIiwiYW5nbGUiKX1nZXQgZCgpe3JldHVybiB0aGlzW2FdKCJkIil9c2V0IGQobSl7fWdldCBpbm5lclJhZGl1cygpe3JldHVybiB0aGlzW2FdKCJpbm5lclJhZGl1cyIpfXNldCBpbm5lclJhZGl1cyhtKXtpZihtPU9iamVjdChmLnRvTnVtYmVyKShtKSx0aGlzW3VdKCJpbm5lclJhZGl1cyIsbSkpe2NvbnN0IGI9RSh0aGlzKTt0aGlzW3VdKCJkIixiKX19Z2V0IG91dGVyUmFkaXVzKCl7cmV0dXJuIHRoaXNbYV0oIm91dGVyUmFkaXVzIil9c2V0IG91dGVyUmFkaXVzKG0pe2lmKG09T2JqZWN0KGYudG9OdW1iZXIpKG0pLHRoaXNbdV0oIm91dGVyUmFkaXVzIixtKSl7Y29uc3QgYj1FKHRoaXMpO3RoaXNbdV0oImQiLGIpfX1nZXQgcmFkaXVzKCl7cmV0dXJuW3RoaXMuaW5uZXJSYWRpdXMsdGhpcy5vdXRlclJhZGl1c119c2V0IHJhZGl1cyhtKXttPU9iamVjdChmLnRvQXJyYXkpKG0sITApLEFycmF5LmlzQXJyYXkobSl8fChtPVttLG1dKSx0aGlzLmlubmVyUmFkaXVzPW1bMF0sdGhpcy5vdXRlclJhZGl1cz1tWzFdfWdldCBzdGFydEFuZ2xlKCl7cmV0dXJuIHRoaXNbYV0oInN0YXJ0QW5nbGUiKX1zZXQgc3RhcnRBbmdsZShtKXtpZihtPU9iamVjdChmLnRvTnVtYmVyKShtKSx0aGlzW3VdKCJzdGFydEFuZ2xlIixtKSl7Y29uc3QgYj1FKHRoaXMpO3RoaXNbdV0oImQiLGIpfX1nZXQgZW5kQW5nbGUoKXtyZXR1cm4gdGhpc1thXSgiZW5kQW5nbGUiKX1zZXQgZW5kQW5nbGUobSl7aWYobT1PYmplY3QoZi50b051bWJlcikobSksdGhpc1t1XSgiZW5kQW5nbGUiLG0pKXtjb25zdCBiPUUodGhpcyk7dGhpc1t1XSgiZCIsYil9fWdldCBhbmdsZSgpe3JldHVyblt0aGlzLnN0YXJ0QW5nbGUsdGhpcy5lbmRBbmdsZV19c2V0IGFuZ2xlKG0pe209T2JqZWN0KGYudG9BcnJheSkobSksQXJyYXkuaXNBcnJheShtKXx8KG09W20sbV0pLHRoaXMuc3RhcnRBbmdsZT1tWzBdLHRoaXMuZW5kQW5nbGU9bVsxXX19fSxmdW5jdGlvbihnLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBifSk7dmFyIG49dCgxMiksaT10KDIxOCksZj10KDIxOSksaD10KDI0OSksdT10KDIxMyk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIGEoTSx5LFMpe3JldHVybiB5IGluIE0/T2JqZWN0LmRlZmluZVByb3BlcnR5KE0seSx7dmFsdWU6UyxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOk1beV09UyxNfWNvbnN0IGQ9U3ltYm9sKCJ0ZXh0SW1hZ2UiKSxFPVN5bWJvbCgidGV4dEltYWdlVGFzayIpLHA9U3ltYm9sKCJ0ZXh0dXJlQ29udGV4dCIpLE89U3ltYm9sKCJ1cGRhdGVUZXh0dXJlUmVjdCIpLG09U3ltYm9sKCJ0ZXh0Q2FudmFzIik7Y2xhc3MgYiBleHRlbmRzIGYuZGVmYXVsdHtjb25zdHJ1Y3Rvcih5PXt9KXt0eXBlb2YgeT09InN0cmluZyImJih5PXt0ZXh0Onl9KSxzdXBlcih5KX1nZXQgY29udGVudFNpemUoKXtsZXRbeSxTXT1zdXBlci5jb250ZW50U2l6ZTtjb25zdHt3aWR0aDpzLGhlaWdodDpjfT10aGlzLmF0dHJpYnV0ZXM7aWYocz09bnVsbHx8Yz09bnVsbCl7Y29uc3QgbD10aGlzW2RdO2wmJihzPT1udWxsJiYoeT1sLnJlY3RbMl0pLGM9PW51bGwmJihTPWwucmVjdFszXSkpfXJldHVyblt5LFNdfWdldCB0ZXh0KCl7cmV0dXJuIHRoaXMuYXR0cmlidXRlcy50ZXh0fXNldCB0ZXh0KHkpe3RoaXMuYXR0cmlidXRlcy50ZXh0PXl9Z2V0IHRleHRDb250ZW50KCl7cmV0dXJuIHRoaXMuYXR0cmlidXRlcy50ZXh0fXNldCB0ZXh0Q29udGVudCh5KXt0aGlzLmF0dHJpYnV0ZXMudGV4dD15fWdldCB0ZXh0SW1hZ2UoKXtyZXR1cm4gdGhpc1tkXXx8e319Z2V0IHRleHRJbWFnZVJlYWR5KCl7cmV0dXJuIHRoaXNbRV18fFByb21pc2UucmVzb2x2ZSgpfWRyYXcoeSl7c3VwZXIuZHJhdyh5KTtjb25zdCBTPXRoaXMubWVzaDtpZihTKXtjb25zdCBzPXRoaXNbZF07aWYocyl7bGV0IGM9Uy50ZXh0dXJlO2lmKCFjfHx0aGlzW3BdJiZ0aGlzW3BdIT09dGhpcy5yZW5kZXJlcnx8cy5uZWVkc1VwZGF0ZT8ocy5uZWVkc1VwZGF0ZT0hMSxPYmplY3QoaS5kZWxldGVUZXh0dXJlKShzLmltYWdlLHRoaXMucmVuZGVyZXIpLGM9T2JqZWN0KGkuY3JlYXRlVGV4dHVyZSkocy5pbWFnZSx0aGlzLnJlbmRlcmVyKSx0aGlzW09dPSEwKTpjPVMudW5pZm9ybXMudV90ZXhTYW1wbGVyLHRoaXNbT10pe2NvbnN0W2wsdl09cy5yZWN0LnNsaWNlKDIpLFtULFJdPXRoaXMuY29udGVudFNpemUsTD10aGlzLmF0dHJpYnV0ZXMudGV4dEFsaWduLE49dGhpcy5hdHRyaWJ1dGVzLnZlcnRpY2FsQWxpZ247bGV0IEE9MDtMPT09ImNlbnRlciI/QT0oVC1sKS8yOihMPT09InJpZ2h0Inx8TD09PSJlbmQiKSYmKEE9VC1sKTtjb25zdCB3PXRoaXMuYXR0cmlidXRlcy5mb250U2l6ZSxCPXRoaXMuYXR0cmlidXRlcy5saW5lSGVpZ2h0O2xldCBEPTA7Tj09PSJ0b3AiP0Q9KHctQikvMjpOPT09ImJvdHRvbSImJihEPShCLXcpLzIpO2NvbnN0e3BhZGRpbmdMZWZ0OkkscGFkZGluZ1RvcDpqfT10aGlzLmF0dHJpYnV0ZXMse2JvcmRlcldpZHRoOlZ9PXRoaXMuYXR0cmlidXRlcztBKz1JK1YsRCs9aitWO2NvbnN0e2FuY2hvclg6SixhbmNob3JZOl99PXRoaXMuYXR0cmlidXRlcztBLT10aGlzLm9mZnNldFNpemVbMF0qSixELT10aGlzLm9mZnNldFNpemVbMV0qXyxTLnNldFRleHR1cmUoYyx7cmVjdDpbQSxELGwsdl19KSx0aGlzW09dPSExLHRoaXNbcF09dGhpcy5yZW5kZXJlcn19fXJldHVybiB5fW9uUHJvcGVydHlDaGFuZ2UoeSxTLHMpe3k9PT0idGV4dCJ8fHk9PT0iZm9udFNpemUifHx5PT09ImZvbnRGYW1pbHkifHx5PT09ImZvbnRTdHlsZSJ8fHk9PT0iZm9udFZhcmlhbnQifHx5PT09ImZvbnRXZWlnaHQifHx5PT09ImZvbnRTdHJldGNoInx8eT09PSJsaW5lSGVpZ2h0Inx8eT09PSJzdHJva2VDb2xvciJ8fHk9PT0iZmlsbENvbG9yInx8eT09PSJzdHJva2VXaWR0aCI/dGhpcy51cGRhdGVUZXh0KCk6KCh5PT09InRleHRBbGlnbiJ8fHk9PT0idmVydGljYWxBbGlnbiIpJiYodGhpc1tPXT0hMCksc3VwZXIub25Qcm9wZXJ0eUNoYW5nZSh5LFMscykpfXVwZGF0ZUNvbnRvdXJzKCl7c3VwZXIudXBkYXRlQ29udG91cnMoKSx0aGlzW09dPSEwfXVwZGF0ZVRleHQoKXt0aGlzW0VdfHwodGhpc1tFXT1Qcm9taXNlLnJlc29sdmUoKS50aGVuKCgpPT57dGhpc1tFXT1udWxsO2NvbnN0e3RleHQ6eSxmb250OlMsZmlsbENvbG9yOnMsc3Ryb2tlQ29sb3I6YyxzdHJva2VXaWR0aDpsfT10aGlzLmF0dHJpYnV0ZXMsdj10aGlzLmxheWVyP3RoaXMubGF5ZXIuZGlzcGxheVJhdGlvOjE7cmV0dXJuIHRoaXNbbV09dGhpc1ttXXx8bi5FTlYuY3JlYXRlQ2FudmFzKDEsMSksdGhpc1tkXT1uLkVOVi5jcmVhdGVUZXh0KHkse2ZvbnQ6UyxmaWxsQ29sb3I6cyxzdHJva2VDb2xvcjpjLHN0cm9rZVdpZHRoOmwscGFyc2VGb250Om4ucGFyc2VGb250LHJhdGlvOnYsdGV4dENhbnZhczp0aGlzW21dfSksdGhpc1tkXS5uZWVkc1VwZGF0ZT0hMCx0aGlzLnVwZGF0ZUNvbnRvdXJzKCksdGhpcy5mb3JjZVVwZGF0ZSgpLHRoaXNbZF19KSl9fWEoYiwiQXR0ciIsaC5kZWZhdWx0KSx1LmRlZmF1bHQucmVnaXN0ZXJOb2RlKGIsImxhYmVsIil9LGZ1bmN0aW9uKGcsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIHB9KTt2YXIgbj10KDEyKSxpPXQoNzIpLGY9dCgyMjEpLGg9dCgyMjApO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCB1PVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZURlZmF1bHQiKSxhPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZSIpLGQ9U3ltYm9sLmZvcigic3ByaXRlanNfZ2V0QXR0cmlidXRlIiksRT1TeW1ib2wuZm9yKCJzcHJpdGVqc19kZWNsYXJlQWxpYXMiKTtjbGFzcyBwIGV4dGVuZHMgaC5kZWZhdWx0e2NvbnN0cnVjdG9yKG0pe3N1cGVyKG0pLHRoaXNbdV0oe3RleHQ6IiIsZm9udFNpemU6MTYsZm9udEZhbWlseToiSGVsdmV0aWNhLEFyaWFsLHNhbnMtc2VyaWYiLGZvbnRTdHlsZToibm9ybWFsIixmb250VmFyaWFudDoibm9ybWFsIixmb250V2VpZ2h0OiJub3JtYWwiLGZvbnRTdHJldGNoOiJub3JtYWwiLGxpbmVIZWlnaHQ6IiIsdGV4dEFsaWduOiJsZWZ0IixzdHJva2VDb2xvcjp2b2lkIDAsc3Ryb2tlV2lkdGg6MSxmaWxsQ29sb3I6dm9pZCAwLHZlcnRpY2FsQWxpZ246Im1pZGRsZSJ9KSx0aGlzW0VdKCJmb250Iil9Z2V0IHRleHQoKXtyZXR1cm4gdGhpc1tkXSgidGV4dCIpfHwiICJ9c2V0IHRleHQobSl7dGhpc1thXSgidGV4dCIsbSl9Z2V0IGZvbnRTaXplKCl7cmV0dXJuIHRoaXNbZF0oImZvbnRTaXplIil9c2V0IGZvbnRTaXplKG0pe3RoaXNbYV0oImZvbnRTaXplIixPYmplY3QoaS50b051bWJlcikobSkpfWdldCBmb250RmFtaWx5KCl7cmV0dXJuIHRoaXNbZF0oImZvbnRGYW1pbHkiKX1zZXQgZm9udEZhbWlseShtKXt0aGlzW2FdKCJmb250RmFtaWx5IixtKX1nZXQgZm9udFN0eWxlKCl7cmV0dXJuIHRoaXNbZF0oImZvbnRTdHlsZSIpfXNldCBmb250U3R5bGUobSl7dGhpc1thXSgiZm9udFN0eWxlIixtKX1nZXQgZm9udFZhcmlhbnQoKXtyZXR1cm4gdGhpc1tkXSgiZm9udFZhcmlhbnQiKX1zZXQgZm9udFZhcmlhbnQobSl7dGhpc1thXSgiZm9udFZhcmlhbnQiLG0pfWdldCBmb250V2VpZ2h0KCl7cmV0dXJuIHRoaXNbZF0oImZvbnRXZWlnaHQiKX1zZXQgZm9udFdlaWdodChtKXt0aGlzW2FdKCJmb250V2VpZ2h0IixtKX1nZXQgZm9udFN0cmV0Y2goKXtyZXR1cm4gdGhpc1tkXSgiZm9udFN0cmV0Y2giKX1zZXQgZm9udFN0cmV0Y2gobSl7dGhpc1thXSgiZm9udFN0cmV0Y2giLG0pfWdldCBsaW5lSGVpZ2h0KCl7cmV0dXJuIHRoaXNbZF0oImxpbmVIZWlnaHQiKXx8dGhpcy5mb250U2l6ZX1zZXQgbGluZUhlaWdodChtKXt0aGlzW2FdKCJsaW5lSGVpZ2h0IixPYmplY3QoaS50b051bWJlcikobSkpfWdldCB0ZXh0QWxpZ24oKXtyZXR1cm4gdGhpc1tkXSgidGV4dEFsaWduIil9c2V0IHRleHRBbGlnbihtKXt0aGlzW2FdKCJ0ZXh0QWxpZ24iLG0pfWdldCBzdHJva2VDb2xvcigpe3JldHVybiB0aGlzW2RdKCJzdHJva2VDb2xvciIpfXNldCBzdHJva2VDb2xvcihtKXt0aGlzW2FdKCJzdHJva2VDb2xvciIsT2JqZWN0KGYucGFyc2VDb2xvcikobSkpfWdldCBzdHJva2VXaWR0aCgpe3JldHVybiB0aGlzW2RdKCJzdHJva2VXaWR0aCIpfXNldCBzdHJva2VXaWR0aChtKXt0aGlzW2FdKCJzdHJva2VXaWR0aCIsT2JqZWN0KGkudG9OdW1iZXIpKG0pKX1nZXQgdmVydGljYWxBbGlnbigpe3JldHVybiB0aGlzW2RdKCJ2ZXJ0aWNhbEFsaWduIil9c2V0IHZlcnRpY2FsQWxpZ24obSl7dGhpc1thXSgidmVydGljYWxBbGlnbiIsbSl9Z2V0IGZpbGxDb2xvcigpe3JldHVybiB0aGlzW2RdKCJmaWxsQ29sb3IiKX1zZXQgZmlsbENvbG9yKG0pe3RoaXNbYV0oImZpbGxDb2xvciIsT2JqZWN0KGYucGFyc2VDb2xvcikobSkpfWdldCBmb250KCl7Y29uc3R7Zm9udFN0eWxlOm0sZm9udFZhcmlhbnQ6Yixmb250V2VpZ2h0Ok0sZm9udFN0cmV0Y2g6eSxmb250U2l6ZTpTLGxpbmVIZWlnaHQ6cyxmb250RmFtaWx5OmN9PXRoaXM7cmV0dXJuYCR7bX0gJHtifSAke019ICR7eX0gJHtTfXB4LyR7c31weCAke2N9YH1zZXQgZm9udChtKXtpZihtPT1udWxsKXRoaXMuZm9udFN0eWxlPW51bGwsdGhpcy5mb250VmFyaWFudD1udWxsLHRoaXMuZm9udFdlaWdodD1udWxsLHRoaXMuZm9udFN0cmV0Y2g9bnVsbCx0aGlzLmZvbnRTaXplPW51bGwsdGhpcy5saW5lSGVpZ2h0PW51bGwsdGhpcy5mb250RmFtaWx5PW51bGw7ZWxzZXtjb25zdCBiPU9iamVjdChuLnBhcnNlRm9udCkobSk7dGhpcy5mb250U3R5bGU9Yi5zdHlsZSx0aGlzLmZvbnRWYXJpYW50PWIudmFyaWFudCx0aGlzLmZvbnRXZWlnaHQ9Yi53ZWlnaHQsdGhpcy5mb250U3RyZXRjaD1iLnN0cmV0Y2gsdGhpcy5mb250U2l6ZT1PYmplY3QoaS50b051bWJlcikoYCR7Yi5zaXplfSR7Yi51bml0fWApLGIubGluZUhlaWdodCYmKHRoaXMubGluZUhlaWdodD1iLnB4TGluZUhlaWdodCksdGhpcy5mb250RmFtaWx5PWIuZmFtaWx5fX19fSxmdW5jdGlvbihnLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBtfSk7dmFyIG49dCgxMiksaT10KDIxOSksZj10KDI1MSksaD10KDIxMyksdT10KDI1Mik7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIGEoYixNLHkpe3JldHVybiBNIGluIGI/T2JqZWN0LmRlZmluZVByb3BlcnR5KGIsTSx7dmFsdWU6eSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOmJbTV09eSxifWNvbnN0IGQ9U3ltYm9sKCJ6T3JkZXIiKSxFPVN5bWJvbCgib3JkZXJlZCIpLHA9U3ltYm9sKCJjaGlsZHJlbiIpLE89U3ltYm9sKCJzZWFsZWQiKTtjbGFzcyBtIGV4dGVuZHMgaS5kZWZhdWx0e2NvbnN0cnVjdG9yKE09e30pe3N1cGVyKE0pLHRoaXNbcF09W10sdGhpc1tFXT1udWxsLHRoaXNbZF09MH1nZXQgY2hpbGROb2Rlcygpe3JldHVybiB0aGlzW3BdfWdldCBjaGlsZHJlbigpe3JldHVybiB0aGlzW3BdfWdldCBvcmRlcmVkQ2hpbGRyZW4oKXtyZXR1cm4gdGhpc1tFXXx8KHRoaXNbRV09Wy4uLnRoaXNbcF1dLHRoaXNbRV0uc29ydCgoTSx5KT0+TS56SW5kZXgteS56SW5kZXh8fE0uek9yZGVyLXkuek9yZGVyKSksdGhpc1tFXX1hcHBlbmQoLi4uTSl7cmV0dXJuIE0ubWFwKHk9PnRoaXMuYXBwZW5kQ2hpbGQoeSkpfWFwcGVuZENoaWxkKE0pe3JldHVybiBNLnJlbW92ZSgpLHRoaXNbcF0ucHVzaChNKSxNLmNvbm5lY3QodGhpcyx0aGlzW2RdKyspLHRoaXNbRV0mJih0aGlzW0VdLmxlbmd0aCYmTS56SW5kZXg8dGhpc1tFXVt0aGlzW0VdLmxlbmd0aC0xXS56SW5kZXg/dGhpcy5yZW9yZGVyKCk6dGhpc1tFXS5wdXNoKE0pKSxNfWNsb25lTm9kZShNPSExKXtjb25zdCB5PXN1cGVyLmNsb25lTm9kZSgpO3JldHVybiBNJiZ0aGlzW3BdLmZvckVhY2goUz0+e2NvbnN0IHM9Uy5jbG9uZU5vZGUoTSk7eS5hcHBlbmRDaGlsZChzKX0pLHl9ZGlzcGF0Y2hQb2ludGVyRXZlbnQoTSl7Y29uc3QgeT10aGlzLm9yZGVyZWRDaGlsZHJlbjtmb3IobGV0IFM9eS5sZW5ndGgtMTtTPj0wO1MtLSlpZih5W1NdLmRpc3BhdGNoUG9pbnRlckV2ZW50KE0pKXJldHVybiEwO3JldHVybiBzdXBlci5kaXNwYXRjaFBvaW50ZXJFdmVudChNKX1kcmF3KE09W10pe2lmKHRoaXMuX19jYWNoZVJlbmRlck1hdHJpeD10aGlzLnJlbmRlck1hdHJpeCxzdXBlci5kcmF3KE0pLCF0aGlzW09dJiZ0aGlzLmF0dHJpYnV0ZXMuZGlzcGxheSE9PSJub25lIil7Y29uc3QgeT10aGlzLm9yZGVyZWRDaGlsZHJlbjtmb3IobGV0IFM9MDtTPHkubGVuZ3RoO1MrKyl5W1NdLmRyYXcoTSl9cmV0dXJuIHRoaXMuX19jYWNoZVJlbmRlck1hdHJpeD1udWxsLE19Z2V0RWxlbWVudEJ5SWQoTSl7cmV0dXJuIE9iamVjdCh1LnF1ZXJ5U2VsZWN0b3IpKGAjJHtNfWAsdGhpcyl9Z2V0RWxlbWVudHNCeUNsYXNzTmFtZShNKXtyZXR1cm4gT2JqZWN0KHUucXVlcnlTZWxlY3RvckFsbCkoYC4ke019YCx0aGlzKX1nZXRFbGVtZW50c0J5TmFtZShNKXtyZXR1cm4gT2JqZWN0KHUucXVlcnlTZWxlY3RvckFsbCkoYFtuYW1lPSIke019Il1gLHRoaXMpfWdldEVsZW1lbnRzQnlUYWdOYW1lKE0pe3JldHVybiBPYmplY3QodS5xdWVyeVNlbGVjdG9yQWxsKShNLHRoaXMpfWluc2VydEJlZm9yZShNLHkpe2lmKHk9PW51bGwpcmV0dXJuIHRoaXMuYXBwZW5kQ2hpbGQoTSk7TS5yZW1vdmUoKTtjb25zdCBTPXRoaXNbcF0uaW5kZXhPZih5KTtpZihTPDApdGhyb3cgbmV3IEVycm9yKCJJbnZhbGlkIHJlZmVyZW5jZSBub2RlLiIpO2NvbnN0IHM9eS56T3JkZXI7Zm9yKGxldCBjPVM7Yzx0aGlzW3BdLmxlbmd0aDtjKyspe2NvbnN0IGw9dGhpc1twXVtjXS56T3JkZXIsdj10aGlzW3BdW2NdO2RlbGV0ZSB2LnpPcmRlcixPYmplY3QuZGVmaW5lUHJvcGVydHkodiwiek9yZGVyIix7dmFsdWU6bCsxLHdyaXRhYmxlOiExLGNvbmZpZ3VyYWJsZTohMH0pfWlmKHRoaXNbcF0uc3BsaWNlKFMsMCxNKSxNLmNvbm5lY3QodGhpcyxzKSx0aGlzW0VdKWlmKE0uekluZGV4IT09eS56SW5kZXgpdGhpcy5yZW9yZGVyKCk7ZWxzZXtjb25zdCBjPXRoaXNbRV0uaW5kZXhPZih5KTt0aGlzW0VdLnNwbGljZShjLDAsTSl9cmV0dXJuIE19cXVlcnlTZWxlY3RvcihNKXtyZXR1cm4gT2JqZWN0KHUucXVlcnlTZWxlY3RvcikoTSx0aGlzKX1xdWVyeVNlbGVjdG9yQWxsKE0pe3JldHVybiBPYmplY3QodS5xdWVyeVNlbGVjdG9yQWxsKShNLHRoaXMpfXJlcGxhY2VDaGlsZChNLHkpe00ucmVtb3ZlKCk7Y29uc3QgUz10aGlzW3BdLmluZGV4T2YoeSk7aWYoUzwwKXRocm93IG5ldyBFcnJvcigiSW52YWxpZCByZWZlcmVuY2Ugbm9kZS4iKTtpZih0aGlzW3BdW1NdPU0sTS5jb25uZWN0KHRoaXMseS56T3JkZXIpLHRoaXNbRV0paWYoTS56SW5kZXghPT15LnpJbmRleCl0aGlzLnJlb3JkZXIoKTtlbHNle2NvbnN0IHM9dGhpc1tFXS5pbmRleE9mKHkpO3RoaXNbRV1bc109TX1yZXR1cm4geS5kaXNjb25uZWN0KHRoaXMpLE19cmVtb3ZlQWxsQ2hpbGRyZW4oKXtjb25zdCBNPXRoaXNbcF07Zm9yKGxldCB5PU0ubGVuZ3RoLTE7eT49MDt5LS0pTVt5XS5yZW1vdmUoKX1yZW1vdmVDaGlsZChNKXtjb25zdCB5PXRoaXNbcF0uaW5kZXhPZihNKTtpZih5Pj0wKXtpZih0aGlzW3BdLnNwbGljZSh5LDEpLHRoaXNbRV0pe2NvbnN0IFM9dGhpc1tFXS5pbmRleE9mKE0pO3RoaXNbRV0uc3BsaWNlKFMsMSl9cmV0dXJuIE0uZGlzY29ubmVjdCh0aGlzKSxNfXJldHVybiBudWxsfXJlb3JkZXIoKXt0aGlzW0VdPW51bGx9c2VhbCgpe2Z1bmN0aW9uIE0oYyxsKXtjb25zdCB2PVtdO2ZvcihsZXQgVD0wO1Q8Yy5sZW5ndGg7VCsrKXtjb25zdCBSPVsuLi5jW1RdXTtmb3IobGV0IEw9MTtMPFIubGVuZ3RoO0wrPTIpe2NvbnN0IE49UltMXSxBPVJbTCsxXTtSW0xdPU4qbFswXStBKmxbMl0rbFs0XSxSW0wrMV09TipsWzFdK0EqbFszXStsWzVdfXYucHVzaChSKX1yZXR1cm4gdn1jb25zdCB5PXRoaXMub3JkZXJlZENoaWxkcmVuLFM9bmV3IG4uRmlndXJlMkQscz10aGlzLmxvY2FsTWF0cml4O2ZvcihsZXQgYz0wO2M8eS5sZW5ndGg7YysrKXtsZXQgbD15W2NdO2lmKGwgaW5zdGFuY2VvZiBtJiYobD1sLnNlYWwoKSksbC5jbGllbnRCb3gpe2xldCB2PWwuY2xpZW50Qm94LmNvbnRvdXJzLnBhdGg7dj1NKHYsbC5sb2NhbE1hdHJpeCksUy5hZGRQYXRoKHYpfWlmKGwucGF0aCl7bGV0IHY9bC5wYXRoLmNvbnRvdXJzLnBhdGg7dj1NKHYsbC5sb2NhbE1hdHJpeCksUy5hZGRQYXRoKHYpfX1yZXR1cm4gdGhpc1tPXT0hMCx0aGlzLmNsaWVudEJveD1TLHtjbGllbnRCb3g6Uyxsb2NhbE1hdHJpeDpzfX1zZXRSZXNvbHV0aW9uKHt3aWR0aDpNLGhlaWdodDp5fSl7c3VwZXIuc2V0UmVzb2x1dGlvbih7d2lkdGg6TSxoZWlnaHQ6eX0pLHRoaXNbcF0uZm9yRWFjaChTPT57Uy5zZXRSZXNvbHV0aW9uKHt3aWR0aDpNLGhlaWdodDp5fSl9KX11cGRhdGVDb250b3Vycygpe3RoaXNbT118fHN1cGVyLnVwZGF0ZUNvbnRvdXJzKCl9fWEobSwiQXR0ciIsZi5kZWZhdWx0KSxoLmRlZmF1bHQucmVnaXN0ZXJOb2RlKG0sImdyb3VwIil9LGZ1bmN0aW9uKGcsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIGl9KTt2YXIgbj10KDIyMCk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NsYXNzIGkgZXh0ZW5kcyBuLmRlZmF1bHR7fX0sZnVuY3Rpb24oZyxlLHQpe3QucihlKSx0LmQoZSwicXVlcnlTZWxlY3RvckFsbCIsZnVuY3Rpb24oKXtyZXR1cm4gT30pLHQuZChlLCJxdWVyeVNlbGVjdG9yIixmdW5jdGlvbigpe3JldHVybiBtfSksdC5kKGUsImlzTWF0Y2hlZCIsZnVuY3Rpb24oKXtyZXR1cm4gYn0pLHQuZChlLCJjb21waWxlIixmdW5jdGlvbigpe3JldHVybiBNfSk7dmFyIG49dCgyMjEpLGk9dCgyMTMpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCBmPXQoMjUzKTtmdW5jdGlvbiBoKHkpe3JldHVybiB5Lm5vZGVUeXBlPT09MXx8aS5kZWZhdWx0LmlzU3ByaXRlTm9kZSh5Lm5vZGVOYW1lKX1mdW5jdGlvbiB1KHkpe3JldHVybiBBcnJheS5mcm9tKHkuY2hpbGROb2Rlc3x8W10pfWZ1bmN0aW9uIGEoeSl7cmV0dXJuIGkuZGVmYXVsdC5pc1Nwcml0ZU5vZGUoeS5ub2RlTmFtZSk/eS5wYXJlbnR8fHkuY2FudmFzfHx5LmNvbnRhaW5lcjp5LnBhcmVudEVsZW1lbnR9ZnVuY3Rpb24gZCh5KXtsZXQgUz15Lmxlbmd0aCxzLGMsbDtmb3IoOy0tUz4tMTspe2ZvcihzPWM9eVtTXSx5W1NdPW51bGwsbD0hMDtjOyl7aWYoeS5pbmRleE9mKGMpPi0xKXtsPSExLHkuc3BsaWNlKFMsMSk7YnJlYWt9Yz1hKGMpfWwmJih5W1NdPXMpfXJldHVybiB5fWNvbnN0IEU9e2lzVGFnOmgsZXhpc3RzT25lKHksUyl7cmV0dXJuIFMuc29tZShzPT5oKHMpP3kocyl8fEUuZXhpc3RzT25lKHksdShzKSk6ITEpfSxnZXRTaWJsaW5ncyh5KXtjb25zdCBTPWEoeSk7cmV0dXJuIFMmJnUoUyl9LGdldENoaWxkcmVuOnUsZ2V0UGFyZW50OmEsZ2V0QXR0cmlidXRlVmFsdWUoeSxTKXtpZih5Lm5vZGVUeXBlPT09MSYmUz09PSJjbGFzcyJ8fFM9PT0iaWQiKXJldHVybiB5W1NdO2lmKHRoaXMuaGFzQXR0cmliKHksUykpe2xldCBzPXkuYXR0cmlidXRlc1tTXTtyZXR1cm4gQXJyYXkuaXNBcnJheShzKSYmKHM9YFske3Muam9pbigpfV1gKSxTdHJpbmcocyl9fSxoYXNBdHRyaWIoeSxTKXtyZXR1cm4geS5hdHRyaWJ1dGVzW1NdIT1udWxsfSxyZW1vdmVTdWJzZXRzOmQsZ2V0TmFtZSh5KXtyZXR1cm4geS50YWdOYW1lP3kudGFnTmFtZS50b0xvd2VyQ2FzZSgpOm51bGx9LGZpbmRPbmU6ZnVuY3Rpb24geShTLHMpe2xldCBjPW51bGw7Zm9yKGxldCBsPTAsdj1zLmxlbmd0aDtsPHYmJiFjO2wrKylpZihTKHNbbF0pKWM9c1tsXTtlbHNle2NvbnN0IFQ9dShzW2xdKTtUJiZULmxlbmd0aD4wJiYoYz15KFMsVCkpfXJldHVybiBjfSxmaW5kQWxsOmZ1bmN0aW9uIHkoUyxzKXtsZXQgYz1bXTtmb3IobGV0IGw9MCx2PXMubGVuZ3RoO2w8djtsKyspe2lmKCFoKHNbbF0pKWNvbnRpbnVlO1Moc1tsXSkmJmMucHVzaChzW2xdKTtjb25zdCBUPXUoc1tsXSk7VCYmKGM9Yy5jb25jYXQoeShTLFQpKSl9cmV0dXJuIGN9LGdldFRleHQ6ZnVuY3Rpb24geShTKXtyZXR1cm4gQXJyYXkuaXNBcnJheShTKT9TLm1hcCh5KS5qb2luKCIiKTpoKFMpP3kodShTKSk6Uy5ub2RlVHlwZT09PTM/Uy5ub2RlVmFsdWU6aS5kZWZhdWx0LmlzU3ByaXRlTm9kZShTLm5vZGVOYW1lKT9TLnRleHQ6IiJ9fTtmdW5jdGlvbiBwKHkpe2lmKHR5cGVvZiB5IT0ic3RyaW5nIilyZXR1cm4geTtsZXQgUz15Lm1hdGNoKC9cWyhiZ2NvbG9yfGZpbGxDb2xvcnxzdHJva2VDb2xvcnxjb2xvcilccyo9XHMqWyciXT9cdytbJyJdP1xdL2cpO3JldHVybiBTJiYoUz1TLm1hcChzPT57Y29uc3QgYz1zLnNsaWNlKDEsLTEpLnNwbGl0KCI9IiksbD1PYmplY3Qobi5wYXJzZUNvbG9yKShjWzFdLnJlcGxhY2UoL1snIl0vZywiIikpO3JldHVybltzLGBbJHtjWzBdfT0iJHtsfSJdYF19KSxTLmZvckVhY2goKFtzLGNdKT0+e3k9eS5yZXBsYWNlKHMsYyl9KSksUz15Lm1hdGNoKC9cW1x3K1xzKj1ccypbJyJdXFsuKz9cXVsnIl1cXS9nKSxTJiYoUz1TLm1hcChzPT57Y29uc3QgYz1zLnNsaWNlKDEsLTEpLnNwbGl0KCI9IiksbD1jWzFdLnNsaWNlKDIsLTIpLnNwbGl0KC8sL2cpLm1hcCh2PT52LnRyaW0oKSk7cmV0dXJuW3MsYFske2NbMF19PSJbJHtsfV0iXWBdfSksUy5mb3JFYWNoKChbcyxjXSk9Pnt5PXkucmVwbGFjZShzLGMpfSkpLHl9ZnVuY3Rpb24gTyh5LFMpe3JldHVybiBmLnNlbGVjdEFsbChwKHkpLFMse2FkYXB0ZXI6RX0pfWZ1bmN0aW9uIG0oeSxTKXtyZXR1cm4gZi5zZWxlY3RPbmUocCh5KSxTLHthZGFwdGVyOkV9KX1mdW5jdGlvbiBiKHksUyl7cmV0dXJuIGYuaXMoeSxwKFMpLHthZGFwdGVyOkV9KX1mdW5jdGlvbiBNKHkpe3JldHVybiBmLmNvbXBpbGUocCh5KSx7YWRhcHRlcjpFfSl9fSxmdW5jdGlvbihnLGUsdCl7Zy5leHBvcnRzPU07dmFyIG49dCgyNTQpLGk9dCgyNzMpLmZhbHNlRnVuYyxmPXQoMjc0KTtmdW5jdGlvbiBoKHkpe3JldHVybiBmdW5jdGlvbihzLGMsbCl7cmV0dXJuIGM9Y3x8e30sYy5hZGFwdGVyPWMuYWRhcHRlcnx8bix5KHMsYyxsKX19dmFyIHU9aChmKSxhPWgoZi5jb21waWxlVW5zYWZlKTtmdW5jdGlvbiBkKHkpe3JldHVybiBmdW5jdGlvbihzLGMsbCl7cmV0dXJuIGw9bHx8e30sbC5hZGFwdGVyPWwuYWRhcHRlcnx8bix0eXBlb2YgcyE9ImZ1bmN0aW9uIiYmKHM9YShzLGwsYykpLHMuc2hvdWxkVGVzdE5leHRTaWJsaW5ncyYmKGM9cChsJiZsLmNvbnRleHR8fGMsbC5hZGFwdGVyKSksQXJyYXkuaXNBcnJheShjKT9jPWwuYWRhcHRlci5yZW1vdmVTdWJzZXRzKGMpOmM9bC5hZGFwdGVyLmdldENoaWxkcmVuKGMpLHkocyxjLGwpfX1mdW5jdGlvbiBFKHksUyl7dmFyIHM9Uy5nZXRTaWJsaW5ncyh5KTtpZighQXJyYXkuaXNBcnJheShzKSlyZXR1cm5bXTtmb3Iocz1zLnNsaWNlKDApO3Muc2hpZnQoKSE9PXk7KTtyZXR1cm4gc31mdW5jdGlvbiBwKHksUyl7QXJyYXkuaXNBcnJheSh5KXx8KHk9W3ldKTtmb3IodmFyIHM9eS5zbGljZSgwKSxjPTAsbD15Lmxlbmd0aDtjPGw7YysrKXt2YXIgdj1FKHNbY10sUyk7cy5wdXNoLmFwcGx5KHMsdil9cmV0dXJuIHN9dmFyIE89ZChmdW5jdGlvbihTLHMsYyl7cmV0dXJuIFM9PT1pfHwhc3x8cy5sZW5ndGg9PT0wP1tdOmMuYWRhcHRlci5maW5kQWxsKFMscyl9KSxtPWQoZnVuY3Rpb24oUyxzLGMpe3JldHVybiBTPT09aXx8IXN8fHMubGVuZ3RoPT09MD9udWxsOmMuYWRhcHRlci5maW5kT25lKFMscyl9KTtmdW5jdGlvbiBiKHksUyxzKXtyZXR1cm4gcz1zfHx7fSxzLmFkYXB0ZXI9cy5hZGFwdGVyfHxuLCh0eXBlb2YgUz09ImZ1bmN0aW9uIj9TOnUoUyxzKSkoeSl9ZnVuY3Rpb24gTSh5LFMscyl7cmV0dXJuIE8oeSxTLHMpfU0uY29tcGlsZT11LE0uZmlsdGVycz1mLlBzZXVkb3MuZmlsdGVycyxNLnBzZXVkb3M9Zi5Qc2V1ZG9zLnBzZXVkb3MsTS5zZWxlY3RBbGw9TyxNLnNlbGVjdE9uZT1tLE0uaXM9YixNLnBhcnNlPXUsTS5pdGVyYXRlPU8sTS5fY29tcGlsZVVuc2FmZT1hLE0uX2NvbXBpbGVUb2tlbj1mLmNvbXBpbGVUb2tlbn0sZnVuY3Rpb24oZyxlLHQpe3ZhciBuPWcuZXhwb3J0cztbdCgyNTUpLHQoMjY4KSx0KDI2OSksdCgyNzApLHQoMjcxKSx0KDI3MildLmZvckVhY2goZnVuY3Rpb24oaSl7T2JqZWN0LmtleXMoaSkuZm9yRWFjaChmdW5jdGlvbihmKXtuW2ZdPWlbZl0uYmluZChuKX0pfSl9LGZ1bmN0aW9uKGcsZSx0KXt2YXIgbj10KDI1NiksaT10KDI1NyksZj1uLmlzVGFnO2cuZXhwb3J0cz17Z2V0SW5uZXJIVE1MOmgsZ2V0T3V0ZXJIVE1MOmksZ2V0VGV4dDp1fTtmdW5jdGlvbiBoKGEsZCl7cmV0dXJuIGEuY2hpbGRyZW4/YS5jaGlsZHJlbi5tYXAoZnVuY3Rpb24oRSl7cmV0dXJuIGkoRSxkKX0pLmpvaW4oIiIpOiIifWZ1bmN0aW9uIHUoYSl7cmV0dXJuIEFycmF5LmlzQXJyYXkoYSk/YS5tYXAodSkuam9pbigiIik6ZihhKT9hLm5hbWU9PT0iYnIiP2AKYDp1KGEuY2hpbGRyZW4pOmEudHlwZT09PW4uQ0RBVEE/dShhLmNoaWxkcmVuKTphLnR5cGU9PT1uLlRleHQ/YS5kYXRhOiIifX0sZnVuY3Rpb24oZyxlKXtnLmV4cG9ydHM9e1RleHQ6InRleHQiLERpcmVjdGl2ZToiZGlyZWN0aXZlIixDb21tZW50OiJjb21tZW50IixTY3JpcHQ6InNjcmlwdCIsU3R5bGU6InN0eWxlIixUYWc6InRhZyIsQ0RBVEE6ImNkYXRhIixEb2N0eXBlOiJkb2N0eXBlIixpc1RhZzpmdW5jdGlvbih0KXtyZXR1cm4gdC50eXBlPT09InRhZyJ8fHQudHlwZT09PSJzY3JpcHQifHx0LnR5cGU9PT0ic3R5bGUifX19LGZ1bmN0aW9uKGcsZSx0KXt2YXIgbj10KDI1OCksaT10KDI1OSksZj10KDI2Nyk7Zi5lbGVtZW50TmFtZXMuX19wcm90b19fPW51bGwsZi5hdHRyaWJ1dGVOYW1lcy5fX3Byb3RvX189bnVsbDt2YXIgaD17X19wcm90b19fOm51bGwsc3R5bGU6ITAsc2NyaXB0OiEwLHhtcDohMCxpZnJhbWU6ITAsbm9lbWJlZDohMCxub2ZyYW1lczohMCxwbGFpbnRleHQ6ITAsbm9zY3JpcHQ6ITB9O2Z1bmN0aW9uIHUoeSxTKXtpZih5KXt2YXIgcz0iIixjO2Zvcih2YXIgbCBpbiB5KWM9eVtsXSxzJiYocys9IiAiKSxTLnhtbE1vZGU9PT0iZm9yZWlnbiImJihsPWYuYXR0cmlidXRlTmFtZXNbbF18fGwpLHMrPWwsKGMhPT1udWxsJiZjIT09IiJ8fFMueG1sTW9kZSkmJihzKz0nPSInKyhTLmRlY29kZUVudGl0aWVzP2kuZW5jb2RlWE1MKGMpOmMucmVwbGFjZSgvXCIvZywiJnF1b3Q7IikpKyciJyk7cmV0dXJuIHN9fXZhciBhPXtfX3Byb3RvX186bnVsbCxhcmVhOiEwLGJhc2U6ITAsYmFzZWZvbnQ6ITAsYnI6ITAsY29sOiEwLGNvbW1hbmQ6ITAsZW1iZWQ6ITAsZnJhbWU6ITAsaHI6ITAsaW1nOiEwLGlucHV0OiEwLGlzaW5kZXg6ITAsa2V5Z2VuOiEwLGxpbms6ITAsbWV0YTohMCxwYXJhbTohMCxzb3VyY2U6ITAsdHJhY2s6ITAsd2JyOiEwfSxkPWcuZXhwb3J0cz1mdW5jdGlvbih5LFMpeyFBcnJheS5pc0FycmF5KHkpJiYheS5jaGVlcmlvJiYoeT1beV0pLFM9U3x8e307Zm9yKHZhciBzPSIiLGM9MDtjPHkubGVuZ3RoO2MrKyl7dmFyIGw9eVtjXTtsLnR5cGU9PT0icm9vdCI/cys9ZChsLmNoaWxkcmVuLFMpOm4uaXNUYWcobCk/cys9cChsLFMpOmwudHlwZT09PW4uRGlyZWN0aXZlP3MrPU8obCk6bC50eXBlPT09bi5Db21tZW50P3MrPU0obCk6bC50eXBlPT09bi5DREFUQT9zKz1iKGwpOnMrPW0obCxTKX1yZXR1cm4gc30sRT1bIm1pIiwibW8iLCJtbiIsIm1zIiwibXRleHQiLCJhbm5vdGF0aW9uLXhtbCIsImZvcmVpZ25PYmplY3QiLCJkZXNjIiwidGl0bGUiXTtmdW5jdGlvbiBwKHksUyl7Uy54bWxNb2RlPT09ImZvcmVpZ24iJiYoeS5uYW1lPWYuZWxlbWVudE5hbWVzW3kubmFtZV18fHkubmFtZSx5LnBhcmVudCYmRS5pbmRleE9mKHkucGFyZW50Lm5hbWUpPj0wJiYoUz1PYmplY3QuYXNzaWduKHt9LFMse3htbE1vZGU6ITF9KSkpLCFTLnhtbE1vZGUmJlsic3ZnIiwibWF0aCJdLmluZGV4T2YoeS5uYW1lKT49MCYmKFM9T2JqZWN0LmFzc2lnbih7fSxTLHt4bWxNb2RlOiJmb3JlaWduIn0pKTt2YXIgcz0iPCIreS5uYW1lLGM9dSh5LmF0dHJpYnMsUyk7cmV0dXJuIGMmJihzKz0iICIrYyksUy54bWxNb2RlJiYoIXkuY2hpbGRyZW58fHkuY2hpbGRyZW4ubGVuZ3RoPT09MCk/cys9Ii8+Ijoocys9Ij4iLHkuY2hpbGRyZW4mJihzKz1kKHkuY2hpbGRyZW4sUykpLCghYVt5Lm5hbWVdfHxTLnhtbE1vZGUpJiYocys9IjwvIit5Lm5hbWUrIj4iKSksc31mdW5jdGlvbiBPKHkpe3JldHVybiI8Iit5LmRhdGErIj4ifWZ1bmN0aW9uIG0oeSxTKXt2YXIgcz15LmRhdGF8fCIiO3JldHVybiBTLmRlY29kZUVudGl0aWVzJiYhKHkucGFyZW50JiZ5LnBhcmVudC5uYW1lIGluIGgpJiYocz1pLmVuY29kZVhNTChzKSksc31mdW5jdGlvbiBiKHkpe3JldHVybiI8IVtDREFUQVsiK3kuY2hpbGRyZW5bMF0uZGF0YSsiXV0+In1mdW5jdGlvbiBNKHkpe3JldHVybiI8IS0tIit5LmRhdGErIi0tPiJ9fSxmdW5jdGlvbihnLGUsdCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pO2Z1bmN0aW9uIG4oaSl7cmV0dXJuIGkudHlwZT09PSJ0YWcifHxpLnR5cGU9PT0ic2NyaXB0Inx8aS50eXBlPT09InN0eWxlIn1lLmlzVGFnPW4sZS5UZXh0PSJ0ZXh0IixlLkRpcmVjdGl2ZT0iZGlyZWN0aXZlIixlLkNvbW1lbnQ9ImNvbW1lbnQiLGUuU2NyaXB0PSJzY3JpcHQiLGUuU3R5bGU9InN0eWxlIixlLlRhZz0idGFnIixlLkNEQVRBPSJjZGF0YSIsZS5Eb2N0eXBlPSJkb2N0eXBlIn0sZnVuY3Rpb24oZyxlLHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxlLmVuY29kZT1lLmRlY29kZVN0cmljdD1lLmRlY29kZT12b2lkIDA7dmFyIG49dCgyNjApLGk9dCgyNjYpO2Z1bmN0aW9uIGYoRSxwKXtyZXR1cm4oIXB8fHA8PTA/bi5kZWNvZGVYTUw6bi5kZWNvZGVIVE1MKShFKX1lLmRlY29kZT1mO2Z1bmN0aW9uIGgoRSxwKXtyZXR1cm4oIXB8fHA8PTA/bi5kZWNvZGVYTUw6bi5kZWNvZGVIVE1MU3RyaWN0KShFKX1lLmRlY29kZVN0cmljdD1oO2Z1bmN0aW9uIHUoRSxwKXtyZXR1cm4oIXB8fHA8PTA/aS5lbmNvZGVYTUw6aS5lbmNvZGVIVE1MKShFKX1lLmVuY29kZT11O3ZhciBhPXQoMjY2KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiZW5jb2RlWE1MIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gYS5lbmNvZGVYTUx9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsImVuY29kZUhUTUwiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBhLmVuY29kZUhUTUx9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsImVzY2FwZSIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGEuZXNjYXBlfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJlbmNvZGVIVE1MNCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGEuZW5jb2RlSFRNTH19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiZW5jb2RlSFRNTDUiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBhLmVuY29kZUhUTUx9fSk7dmFyIGQ9dCgyNjApO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJkZWNvZGVYTUwiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBkLmRlY29kZVhNTH19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiZGVjb2RlSFRNTCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGQuZGVjb2RlSFRNTH19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiZGVjb2RlSFRNTFN0cmljdCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGQuZGVjb2RlSFRNTFN0cmljdH19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiZGVjb2RlSFRNTDQiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBkLmRlY29kZUhUTUx9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsImRlY29kZUhUTUw1Iix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gZC5kZWNvZGVIVE1MfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJkZWNvZGVIVE1MNFN0cmljdCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGQuZGVjb2RlSFRNTFN0cmljdH19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiZGVjb2RlSFRNTDVTdHJpY3QiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBkLmRlY29kZUhUTUxTdHJpY3R9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsImRlY29kZVhNTFN0cmljdCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGQuZGVjb2RlWE1MfX0pfSxmdW5jdGlvbihnLGUsdCl7dmFyIG49dGhpcyYmdGhpcy5fX2ltcG9ydERlZmF1bHR8fGZ1bmN0aW9uKHApe3JldHVybiBwJiZwLl9fZXNNb2R1bGU/cDp7ZGVmYXVsdDpwfX07T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLGUuZGVjb2RlSFRNTD1lLmRlY29kZUhUTUxTdHJpY3Q9ZS5kZWNvZGVYTUw9dm9pZCAwO3ZhciBpPW4odCgyNjEpKSxmPW4odCgyNjIpKSxoPW4odCgyNjMpKSx1PW4odCgyNjQpKTtlLmRlY29kZVhNTD1hKGguZGVmYXVsdCksZS5kZWNvZGVIVE1MU3RyaWN0PWEoaS5kZWZhdWx0KTtmdW5jdGlvbiBhKHApe3ZhciBPPU9iamVjdC5rZXlzKHApLmpvaW4oInwiKSxtPUUocCk7Tys9InwjW3hYXVtcXGRhLWZBLUZdK3wjXFxkKyI7dmFyIGI9bmV3IFJlZ0V4cCgiJig/OiIrTysiKTsiLCJnIik7cmV0dXJuIGZ1bmN0aW9uKE0pe3JldHVybiBTdHJpbmcoTSkucmVwbGFjZShiLG0pfX12YXIgZD1mdW5jdGlvbihwLE8pe3JldHVybiBwPE8/MTotMX07ZS5kZWNvZGVIVE1MPWZ1bmN0aW9uKCl7Zm9yKHZhciBwPU9iamVjdC5rZXlzKGYuZGVmYXVsdCkuc29ydChkKSxPPU9iamVjdC5rZXlzKGkuZGVmYXVsdCkuc29ydChkKSxtPTAsYj0wO208Ty5sZW5ndGg7bSsrKXBbYl09PT1PW21dPyhPW21dKz0iOz8iLGIrKyk6T1ttXSs9IjsiO3ZhciBNPW5ldyBSZWdFeHAoIiYoPzoiK08uam9pbigifCIpKyJ8I1t4WF1bXFxkYS1mQS1GXSs7P3wjXFxkKzs/KSIsImciKSx5PUUoaS5kZWZhdWx0KTtmdW5jdGlvbiBTKHMpe3JldHVybiBzLnN1YnN0cigtMSkhPT0iOyImJihzKz0iOyIpLHkocyl9cmV0dXJuIGZ1bmN0aW9uKHMpe3JldHVybiBTdHJpbmcocykucmVwbGFjZShNLFMpfX0oKTtmdW5jdGlvbiBFKHApe3JldHVybiBmdW5jdGlvbihtKXtpZihtLmNoYXJBdCgxKT09PSIjIil7dmFyIGI9bS5jaGFyQXQoMik7cmV0dXJuIGI9PT0iWCJ8fGI9PT0ieCI/dS5kZWZhdWx0KHBhcnNlSW50KG0uc3Vic3RyKDMpLDE2KSk6dS5kZWZhdWx0KHBhcnNlSW50KG0uc3Vic3RyKDIpLDEwKSl9cmV0dXJuIHBbbS5zbGljZSgxLC0xKV19fX0sZnVuY3Rpb24oZyl7Zy5leHBvcnRzPUpTT04ucGFyc2UoJ3siQWFjdXRlIjoiw4EiLCJhYWN1dGUiOiLDoSIsIkFicmV2ZSI6IsSCIiwiYWJyZXZlIjoixIMiLCJhYyI6IuKIviIsImFjZCI6IuKIvyIsImFjRSI6IuKIvsyzIiwiQWNpcmMiOiLDgiIsImFjaXJjIjoiw6IiLCJhY3V0ZSI6IsK0IiwiQWN5Ijoi0JAiLCJhY3kiOiLQsCIsIkFFbGlnIjoiw4YiLCJhZWxpZyI6IsOmIiwiYWYiOiLigaEiLCJBZnIiOiLwnZSEIiwiYWZyIjoi8J2UniIsIkFncmF2ZSI6IsOAIiwiYWdyYXZlIjoiw6AiLCJhbGVmc3ltIjoi4oS1IiwiYWxlcGgiOiLihLUiLCJBbHBoYSI6Is6RIiwiYWxwaGEiOiLOsSIsIkFtYWNyIjoixIAiLCJhbWFjciI6IsSBIiwiYW1hbGciOiLiqL8iLCJhbXAiOiImIiwiQU1QIjoiJiIsImFuZGFuZCI6IuKplSIsIkFuZCI6IuKpkyIsImFuZCI6IuKIpyIsImFuZGQiOiLiqZwiLCJhbmRzbG9wZSI6IuKpmCIsImFuZHYiOiLiqZoiLCJhbmciOiLiiKAiLCJhbmdlIjoi4qakIiwiYW5nbGUiOiLiiKAiLCJhbmdtc2RhYSI6IuKmqCIsImFuZ21zZGFiIjoi4qapIiwiYW5nbXNkYWMiOiLipqoiLCJhbmdtc2RhZCI6IuKmqyIsImFuZ21zZGFlIjoi4qasIiwiYW5nbXNkYWYiOiLipq0iLCJhbmdtc2RhZyI6IuKmriIsImFuZ21zZGFoIjoi4qavIiwiYW5nbXNkIjoi4oihIiwiYW5ncnQiOiLiiJ8iLCJhbmdydHZiIjoi4oq+IiwiYW5ncnR2YmQiOiLipp0iLCJhbmdzcGgiOiLiiKIiLCJhbmdzdCI6IsOFIiwiYW5nemFyciI6IuKNvCIsIkFvZ29uIjoixIQiLCJhb2dvbiI6IsSFIiwiQW9wZiI6IvCdlLgiLCJhb3BmIjoi8J2VkiIsImFwYWNpciI6IuKpryIsImFwIjoi4omIIiwiYXBFIjoi4qmwIiwiYXBlIjoi4omKIiwiYXBpZCI6IuKJiyIsImFwb3MiOiJcJyIsIkFwcGx5RnVuY3Rpb24iOiLigaEiLCJhcHByb3giOiLiiYgiLCJhcHByb3hlcSI6IuKJiiIsIkFyaW5nIjoiw4UiLCJhcmluZyI6IsOlIiwiQXNjciI6IvCdkpwiLCJhc2NyIjoi8J2StiIsIkFzc2lnbiI6IuKJlCIsImFzdCI6IioiLCJhc3ltcCI6IuKJiCIsImFzeW1wZXEiOiLiiY0iLCJBdGlsZGUiOiLDgyIsImF0aWxkZSI6IsOjIiwiQXVtbCI6IsOEIiwiYXVtbCI6IsOkIiwiYXdjb25pbnQiOiLiiLMiLCJhd2ludCI6IuKokSIsImJhY2tjb25nIjoi4omMIiwiYmFja2Vwc2lsb24iOiLPtiIsImJhY2twcmltZSI6IuKAtSIsImJhY2tzaW0iOiLiiL0iLCJiYWNrc2ltZXEiOiLii40iLCJCYWNrc2xhc2giOiLiiJYiLCJCYXJ2Ijoi4qunIiwiYmFydmVlIjoi4oq9IiwiYmFyd2VkIjoi4oyFIiwiQmFyd2VkIjoi4oyGIiwiYmFyd2VkZ2UiOiLijIUiLCJiYnJrIjoi4o61IiwiYmJya3RicmsiOiLijrYiLCJiY29uZyI6IuKJjCIsIkJjeSI6ItCRIiwiYmN5Ijoi0LEiLCJiZHF1byI6IuKAniIsImJlY2F1cyI6IuKItSIsImJlY2F1c2UiOiLiiLUiLCJCZWNhdXNlIjoi4oi1IiwiYmVtcHR5diI6IuKmsCIsImJlcHNpIjoiz7YiLCJiZXJub3UiOiLihKwiLCJCZXJub3VsbGlzIjoi4oSsIiwiQmV0YSI6Is6SIiwiYmV0YSI6Is6yIiwiYmV0aCI6IuKEtiIsImJldHdlZW4iOiLiiawiLCJCZnIiOiLwnZSFIiwiYmZyIjoi8J2UnyIsImJpZ2NhcCI6IuKLgiIsImJpZ2NpcmMiOiLil68iLCJiaWdjdXAiOiLii4MiLCJiaWdvZG90Ijoi4qiAIiwiYmlnb3BsdXMiOiLiqIEiLCJiaWdvdGltZXMiOiLiqIIiLCJiaWdzcWN1cCI6IuKohiIsImJpZ3N0YXIiOiLimIUiLCJiaWd0cmlhbmdsZWRvd24iOiLilr0iLCJiaWd0cmlhbmdsZXVwIjoi4pazIiwiYmlndXBsdXMiOiLiqIQiLCJiaWd2ZWUiOiLii4EiLCJiaWd3ZWRnZSI6IuKLgCIsImJrYXJvdyI6IuKkjSIsImJsYWNrbG96ZW5nZSI6IuKnqyIsImJsYWNrc3F1YXJlIjoi4paqIiwiYmxhY2t0cmlhbmdsZSI6IuKWtCIsImJsYWNrdHJpYW5nbGVkb3duIjoi4pa+IiwiYmxhY2t0cmlhbmdsZWxlZnQiOiLil4IiLCJibGFja3RyaWFuZ2xlcmlnaHQiOiLilrgiLCJibGFuayI6IuKQoyIsImJsazEyIjoi4paSIiwiYmxrMTQiOiLilpEiLCJibGszNCI6IuKWkyIsImJsb2NrIjoi4paIIiwiYm5lIjoiPeKDpSIsImJuZXF1aXYiOiLiiaHig6UiLCJiTm90Ijoi4qutIiwiYm5vdCI6IuKMkCIsIkJvcGYiOiLwnZS5IiwiYm9wZiI6IvCdlZMiLCJib3QiOiLiiqUiLCJib3R0b20iOiLiiqUiLCJib3d0aWUiOiLii4giLCJib3hib3giOiLip4kiLCJib3hkbCI6IuKUkCIsImJveGRMIjoi4pWVIiwiYm94RGwiOiLilZYiLCJib3hETCI6IuKVlyIsImJveGRyIjoi4pSMIiwiYm94ZFIiOiLilZIiLCJib3hEciI6IuKVkyIsImJveERSIjoi4pWUIiwiYm94aCI6IuKUgCIsImJveEgiOiLilZAiLCJib3hoZCI6IuKUrCIsImJveEhkIjoi4pWkIiwiYm94aEQiOiLilaUiLCJib3hIRCI6IuKVpiIsImJveGh1Ijoi4pS0IiwiYm94SHUiOiLilaciLCJib3hoVSI6IuKVqCIsImJveEhVIjoi4pWpIiwiYm94bWludXMiOiLiip8iLCJib3hwbHVzIjoi4oqeIiwiYm94dGltZXMiOiLiiqAiLCJib3h1bCI6IuKUmCIsImJveHVMIjoi4pWbIiwiYm94VWwiOiLilZwiLCJib3hVTCI6IuKVnSIsImJveHVyIjoi4pSUIiwiYm94dVIiOiLilZgiLCJib3hVciI6IuKVmSIsImJveFVSIjoi4pWaIiwiYm94diI6IuKUgiIsImJveFYiOiLilZEiLCJib3h2aCI6IuKUvCIsImJveHZIIjoi4pWqIiwiYm94VmgiOiLilasiLCJib3hWSCI6IuKVrCIsImJveHZsIjoi4pSkIiwiYm94dkwiOiLilaEiLCJib3hWbCI6IuKVoiIsImJveFZMIjoi4pWjIiwiYm94dnIiOiLilJwiLCJib3h2UiI6IuKVniIsImJveFZyIjoi4pWfIiwiYm94VlIiOiLilaAiLCJicHJpbWUiOiLigLUiLCJicmV2ZSI6IsuYIiwiQnJldmUiOiLLmCIsImJydmJhciI6IsKmIiwiYnNjciI6IvCdkrciLCJCc2NyIjoi4oSsIiwiYnNlbWkiOiLigY8iLCJic2ltIjoi4oi9IiwiYnNpbWUiOiLii40iLCJic29sYiI6IuKnhSIsImJzb2wiOiJcXFxcIiwiYnNvbGhzdWIiOiLin4giLCJidWxsIjoi4oCiIiwiYnVsbGV0Ijoi4oCiIiwiYnVtcCI6IuKJjiIsImJ1bXBFIjoi4qquIiwiYnVtcGUiOiLiiY8iLCJCdW1wZXEiOiLiiY4iLCJidW1wZXEiOiLiiY8iLCJDYWN1dGUiOiLEhiIsImNhY3V0ZSI6IsSHIiwiY2FwYW5kIjoi4qmEIiwiY2FwYnJjdXAiOiLiqYkiLCJjYXBjYXAiOiLiqYsiLCJjYXAiOiLiiKkiLCJDYXAiOiLii5IiLCJjYXBjdXAiOiLiqYciLCJjYXBkb3QiOiLiqYAiLCJDYXBpdGFsRGlmZmVyZW50aWFsRCI6IuKFhSIsImNhcHMiOiLiiKnvuIAiLCJjYXJldCI6IuKBgSIsImNhcm9uIjoiy4ciLCJDYXlsZXlzIjoi4oStIiwiY2NhcHMiOiLiqY0iLCJDY2Fyb24iOiLEjCIsImNjYXJvbiI6IsSNIiwiQ2NlZGlsIjoiw4ciLCJjY2VkaWwiOiLDpyIsIkNjaXJjIjoixIgiLCJjY2lyYyI6IsSJIiwiQ2NvbmludCI6IuKIsCIsImNjdXBzIjoi4qmMIiwiY2N1cHNzbSI6IuKpkCIsIkNkb3QiOiLEiiIsImNkb3QiOiLEiyIsImNlZGlsIjoiwrgiLCJDZWRpbGxhIjoiwrgiLCJjZW1wdHl2Ijoi4qayIiwiY2VudCI6IsKiIiwiY2VudGVyZG90IjoiwrciLCJDZW50ZXJEb3QiOiLCtyIsImNmciI6IvCdlKAiLCJDZnIiOiLihK0iLCJDSGN5Ijoi0KciLCJjaGN5Ijoi0YciLCJjaGVjayI6IuKckyIsImNoZWNrbWFyayI6IuKckyIsIkNoaSI6Is6nIiwiY2hpIjoiz4ciLCJjaXJjIjoiy4YiLCJjaXJjZXEiOiLiiZciLCJjaXJjbGVhcnJvd2xlZnQiOiLihroiLCJjaXJjbGVhcnJvd3JpZ2h0Ijoi4oa7IiwiY2lyY2xlZGFzdCI6IuKKmyIsImNpcmNsZWRjaXJjIjoi4oqaIiwiY2lyY2xlZGRhc2giOiLiip0iLCJDaXJjbGVEb3QiOiLiipkiLCJjaXJjbGVkUiI6IsKuIiwiY2lyY2xlZFMiOiLik4giLCJDaXJjbGVNaW51cyI6IuKKliIsIkNpcmNsZVBsdXMiOiLiipUiLCJDaXJjbGVUaW1lcyI6IuKKlyIsImNpciI6IuKXiyIsImNpckUiOiLip4MiLCJjaXJlIjoi4omXIiwiY2lyZm5pbnQiOiLiqJAiLCJjaXJtaWQiOiLiq68iLCJjaXJzY2lyIjoi4qeCIiwiQ2xvY2t3aXNlQ29udG91ckludGVncmFsIjoi4oiyIiwiQ2xvc2VDdXJseURvdWJsZVF1b3RlIjoi4oCdIiwiQ2xvc2VDdXJseVF1b3RlIjoi4oCZIiwiY2x1YnMiOiLimaMiLCJjbHVic3VpdCI6IuKZoyIsImNvbG9uIjoiOiIsIkNvbG9uIjoi4oi3IiwiQ29sb25lIjoi4qm0IiwiY29sb25lIjoi4omUIiwiY29sb25lcSI6IuKJlCIsImNvbW1hIjoiLCIsImNvbW1hdCI6IkAiLCJjb21wIjoi4oiBIiwiY29tcGZuIjoi4oiYIiwiY29tcGxlbWVudCI6IuKIgSIsImNvbXBsZXhlcyI6IuKEgiIsImNvbmciOiLiiYUiLCJjb25nZG90Ijoi4qmtIiwiQ29uZ3J1ZW50Ijoi4omhIiwiY29uaW50Ijoi4oiuIiwiQ29uaW50Ijoi4oivIiwiQ29udG91ckludGVncmFsIjoi4oiuIiwiY29wZiI6IvCdlZQiLCJDb3BmIjoi4oSCIiwiY29wcm9kIjoi4oiQIiwiQ29wcm9kdWN0Ijoi4oiQIiwiY29weSI6IsKpIiwiQ09QWSI6IsKpIiwiY29weXNyIjoi4oSXIiwiQ291bnRlckNsb2Nrd2lzZUNvbnRvdXJJbnRlZ3JhbCI6IuKIsyIsImNyYXJyIjoi4oa1IiwiY3Jvc3MiOiLinJciLCJDcm9zcyI6IuKoryIsIkNzY3IiOiLwnZKeIiwiY3NjciI6IvCdkrgiLCJjc3ViIjoi4quPIiwiY3N1YmUiOiLiq5EiLCJjc3VwIjoi4quQIiwiY3N1cGUiOiLiq5IiLCJjdGRvdCI6IuKLryIsImN1ZGFycmwiOiLipLgiLCJjdWRhcnJyIjoi4qS1IiwiY3VlcHIiOiLii54iLCJjdWVzYyI6IuKLnyIsImN1bGFyciI6IuKGtiIsImN1bGFycnAiOiLipL0iLCJjdXBicmNhcCI6IuKpiCIsImN1cGNhcCI6IuKphiIsIkN1cENhcCI6IuKJjSIsImN1cCI6IuKIqiIsIkN1cCI6IuKLkyIsImN1cGN1cCI6IuKpiiIsImN1cGRvdCI6IuKKjSIsImN1cG9yIjoi4qmFIiwiY3VwcyI6IuKIqu+4gCIsImN1cmFyciI6IuKGtyIsImN1cmFycm0iOiLipLwiLCJjdXJseWVxcHJlYyI6IuKLniIsImN1cmx5ZXFzdWNjIjoi4oufIiwiY3VybHl2ZWUiOiLii44iLCJjdXJseXdlZGdlIjoi4ouPIiwiY3VycmVuIjoiwqQiLCJjdXJ2ZWFycm93bGVmdCI6IuKGtiIsImN1cnZlYXJyb3dyaWdodCI6IuKGtyIsImN1dmVlIjoi4ouOIiwiY3V3ZWQiOiLii48iLCJjd2NvbmludCI6IuKIsiIsImN3aW50Ijoi4oixIiwiY3lsY3R5Ijoi4oytIiwiZGFnZ2VyIjoi4oCgIiwiRGFnZ2VyIjoi4oChIiwiZGFsZXRoIjoi4oS4IiwiZGFyciI6IuKGkyIsIkRhcnIiOiLihqEiLCJkQXJyIjoi4oeTIiwiZGFzaCI6IuKAkCIsIkRhc2h2Ijoi4qukIiwiZGFzaHYiOiLiiqMiLCJkYmthcm93Ijoi4qSPIiwiZGJsYWMiOiLLnSIsIkRjYXJvbiI6IsSOIiwiZGNhcm9uIjoixI8iLCJEY3kiOiLQlCIsImRjeSI6ItC0IiwiZGRhZ2dlciI6IuKAoSIsImRkYXJyIjoi4oeKIiwiREQiOiLihYUiLCJkZCI6IuKFhiIsIkREb3RyYWhkIjoi4qSRIiwiZGRvdHNlcSI6IuKptyIsImRlZyI6IsKwIiwiRGVsIjoi4oiHIiwiRGVsdGEiOiLOlCIsImRlbHRhIjoizrQiLCJkZW1wdHl2Ijoi4qaxIiwiZGZpc2h0Ijoi4qW/IiwiRGZyIjoi8J2UhyIsImRmciI6IvCdlKEiLCJkSGFyIjoi4qWlIiwiZGhhcmwiOiLih4MiLCJkaGFyciI6IuKHgiIsIkRpYWNyaXRpY2FsQWN1dGUiOiLCtCIsIkRpYWNyaXRpY2FsRG90Ijoiy5kiLCJEaWFjcml0aWNhbERvdWJsZUFjdXRlIjoiy50iLCJEaWFjcml0aWNhbEdyYXZlIjoiYCIsIkRpYWNyaXRpY2FsVGlsZGUiOiLLnCIsImRpYW0iOiLii4QiLCJkaWFtb25kIjoi4ouEIiwiRGlhbW9uZCI6IuKLhCIsImRpYW1vbmRzdWl0Ijoi4pmmIiwiZGlhbXMiOiLimaYiLCJkaWUiOiLCqCIsIkRpZmZlcmVudGlhbEQiOiLihYYiLCJkaWdhbW1hIjoiz50iLCJkaXNpbiI6IuKLsiIsImRpdiI6IsO3IiwiZGl2aWRlIjoiw7ciLCJkaXZpZGVvbnRpbWVzIjoi4ouHIiwiZGl2b254Ijoi4ouHIiwiREpjeSI6ItCCIiwiZGpjeSI6ItGSIiwiZGxjb3JuIjoi4oyeIiwiZGxjcm9wIjoi4oyNIiwiZG9sbGFyIjoiJCIsIkRvcGYiOiLwnZS7IiwiZG9wZiI6IvCdlZUiLCJEb3QiOiLCqCIsImRvdCI6IsuZIiwiRG90RG90Ijoi4oOcIiwiZG90ZXEiOiLiiZAiLCJkb3RlcWRvdCI6IuKJkSIsIkRvdEVxdWFsIjoi4omQIiwiZG90bWludXMiOiLiiLgiLCJkb3RwbHVzIjoi4oiUIiwiZG90c3F1YXJlIjoi4oqhIiwiZG91YmxlYmFyd2VkZ2UiOiLijIYiLCJEb3VibGVDb250b3VySW50ZWdyYWwiOiLiiK8iLCJEb3VibGVEb3QiOiLCqCIsIkRvdWJsZURvd25BcnJvdyI6IuKHkyIsIkRvdWJsZUxlZnRBcnJvdyI6IuKHkCIsIkRvdWJsZUxlZnRSaWdodEFycm93Ijoi4oeUIiwiRG91YmxlTGVmdFRlZSI6IuKrpCIsIkRvdWJsZUxvbmdMZWZ0QXJyb3ciOiLin7giLCJEb3VibGVMb25nTGVmdFJpZ2h0QXJyb3ciOiLin7oiLCJEb3VibGVMb25nUmlnaHRBcnJvdyI6IuKfuSIsIkRvdWJsZVJpZ2h0QXJyb3ciOiLih5IiLCJEb3VibGVSaWdodFRlZSI6IuKKqCIsIkRvdWJsZVVwQXJyb3ciOiLih5EiLCJEb3VibGVVcERvd25BcnJvdyI6IuKHlSIsIkRvdWJsZVZlcnRpY2FsQmFyIjoi4oilIiwiRG93bkFycm93QmFyIjoi4qSTIiwiZG93bmFycm93Ijoi4oaTIiwiRG93bkFycm93Ijoi4oaTIiwiRG93bmFycm93Ijoi4oeTIiwiRG93bkFycm93VXBBcnJvdyI6IuKHtSIsIkRvd25CcmV2ZSI6IsyRIiwiZG93bmRvd25hcnJvd3MiOiLih4oiLCJkb3duaGFycG9vbmxlZnQiOiLih4MiLCJkb3duaGFycG9vbnJpZ2h0Ijoi4oeCIiwiRG93bkxlZnRSaWdodFZlY3RvciI6IuKlkCIsIkRvd25MZWZ0VGVlVmVjdG9yIjoi4qWeIiwiRG93bkxlZnRWZWN0b3JCYXIiOiLipZYiLCJEb3duTGVmdFZlY3RvciI6IuKGvSIsIkRvd25SaWdodFRlZVZlY3RvciI6IuKlnyIsIkRvd25SaWdodFZlY3RvckJhciI6IuKllyIsIkRvd25SaWdodFZlY3RvciI6IuKHgSIsIkRvd25UZWVBcnJvdyI6IuKGpyIsIkRvd25UZWUiOiLiiqQiLCJkcmJrYXJvdyI6IuKkkCIsImRyY29ybiI6IuKMnyIsImRyY3JvcCI6IuKMjCIsIkRzY3IiOiLwnZKfIiwiZHNjciI6IvCdkrkiLCJEU2N5Ijoi0IUiLCJkc2N5Ijoi0ZUiLCJkc29sIjoi4qe2IiwiRHN0cm9rIjoixJAiLCJkc3Ryb2siOiLEkSIsImR0ZG90Ijoi4ouxIiwiZHRyaSI6IuKWvyIsImR0cmlmIjoi4pa+IiwiZHVhcnIiOiLih7UiLCJkdWhhciI6IuKlryIsImR3YW5nbGUiOiLipqYiLCJEWmN5Ijoi0I8iLCJkemN5Ijoi0Z8iLCJkemlncmFyciI6IuKfvyIsIkVhY3V0ZSI6IsOJIiwiZWFjdXRlIjoiw6kiLCJlYXN0ZXIiOiLiqa4iLCJFY2Fyb24iOiLEmiIsImVjYXJvbiI6IsSbIiwiRWNpcmMiOiLDiiIsImVjaXJjIjoiw6oiLCJlY2lyIjoi4omWIiwiZWNvbG9uIjoi4omVIiwiRWN5Ijoi0K0iLCJlY3kiOiLRjSIsImVERG90Ijoi4qm3IiwiRWRvdCI6IsSWIiwiZWRvdCI6IsSXIiwiZURvdCI6IuKJkSIsImVlIjoi4oWHIiwiZWZEb3QiOiLiiZIiLCJFZnIiOiLwnZSIIiwiZWZyIjoi8J2UoiIsImVnIjoi4qqaIiwiRWdyYXZlIjoiw4giLCJlZ3JhdmUiOiLDqCIsImVncyI6IuKqliIsImVnc2RvdCI6IuKqmCIsImVsIjoi4qqZIiwiRWxlbWVudCI6IuKIiCIsImVsaW50ZXJzIjoi4o+nIiwiZWxsIjoi4oSTIiwiZWxzIjoi4qqVIiwiZWxzZG90Ijoi4qqXIiwiRW1hY3IiOiLEkiIsImVtYWNyIjoixJMiLCJlbXB0eSI6IuKIhSIsImVtcHR5c2V0Ijoi4oiFIiwiRW1wdHlTbWFsbFNxdWFyZSI6IuKXuyIsImVtcHR5diI6IuKIhSIsIkVtcHR5VmVyeVNtYWxsU3F1YXJlIjoi4parIiwiZW1zcDEzIjoi4oCEIiwiZW1zcDE0Ijoi4oCFIiwiZW1zcCI6IuKAgyIsIkVORyI6IsWKIiwiZW5nIjoixYsiLCJlbnNwIjoi4oCCIiwiRW9nb24iOiLEmCIsImVvZ29uIjoixJkiLCJFb3BmIjoi8J2UvCIsImVvcGYiOiLwnZWWIiwiZXBhciI6IuKLlSIsImVwYXJzbCI6IuKnoyIsImVwbHVzIjoi4qmxIiwiZXBzaSI6Is61IiwiRXBzaWxvbiI6Is6VIiwiZXBzaWxvbiI6Is61IiwiZXBzaXYiOiLPtSIsImVxY2lyYyI6IuKJliIsImVxY29sb24iOiLiiZUiLCJlcXNpbSI6IuKJgiIsImVxc2xhbnRndHIiOiLiqpYiLCJlcXNsYW50bGVzcyI6IuKqlSIsIkVxdWFsIjoi4qm1IiwiZXF1YWxzIjoiPSIsIkVxdWFsVGlsZGUiOiLiiYIiLCJlcXVlc3QiOiLiiZ8iLCJFcXVpbGlicml1bSI6IuKHjCIsImVxdWl2Ijoi4omhIiwiZXF1aXZERCI6IuKpuCIsImVxdnBhcnNsIjoi4qelIiwiZXJhcnIiOiLipbEiLCJlckRvdCI6IuKJkyIsImVzY3IiOiLihK8iLCJFc2NyIjoi4oSwIiwiZXNkb3QiOiLiiZAiLCJFc2ltIjoi4qmzIiwiZXNpbSI6IuKJgiIsIkV0YSI6Is6XIiwiZXRhIjoizrciLCJFVEgiOiLDkCIsImV0aCI6IsOwIiwiRXVtbCI6IsOLIiwiZXVtbCI6IsOrIiwiZXVybyI6IuKCrCIsImV4Y2wiOiIhIiwiZXhpc3QiOiLiiIMiLCJFeGlzdHMiOiLiiIMiLCJleHBlY3RhdGlvbiI6IuKEsCIsImV4cG9uZW50aWFsZSI6IuKFhyIsIkV4cG9uZW50aWFsRSI6IuKFhyIsImZhbGxpbmdkb3RzZXEiOiLiiZIiLCJGY3kiOiLQpCIsImZjeSI6ItGEIiwiZmVtYWxlIjoi4pmAIiwiZmZpbGlnIjoi76yDIiwiZmZsaWciOiLvrIAiLCJmZmxsaWciOiLvrIQiLCJGZnIiOiLwnZSJIiwiZmZyIjoi8J2UoyIsImZpbGlnIjoi76yBIiwiRmlsbGVkU21hbGxTcXVhcmUiOiLil7wiLCJGaWxsZWRWZXJ5U21hbGxTcXVhcmUiOiLilqoiLCJmamxpZyI6ImZqIiwiZmxhdCI6IuKZrSIsImZsbGlnIjoi76yCIiwiZmx0bnMiOiLilrEiLCJmbm9mIjoixpIiLCJGb3BmIjoi8J2UvSIsImZvcGYiOiLwnZWXIiwiZm9yYWxsIjoi4oiAIiwiRm9yQWxsIjoi4oiAIiwiZm9yayI6IuKLlCIsImZvcmt2Ijoi4quZIiwiRm91cmllcnRyZiI6IuKEsSIsImZwYXJ0aW50Ijoi4qiNIiwiZnJhYzEyIjoiwr0iLCJmcmFjMTMiOiLihZMiLCJmcmFjMTQiOiLCvCIsImZyYWMxNSI6IuKFlSIsImZyYWMxNiI6IuKFmSIsImZyYWMxOCI6IuKFmyIsImZyYWMyMyI6IuKFlCIsImZyYWMyNSI6IuKFliIsImZyYWMzNCI6IsK+IiwiZnJhYzM1Ijoi4oWXIiwiZnJhYzM4Ijoi4oWcIiwiZnJhYzQ1Ijoi4oWYIiwiZnJhYzU2Ijoi4oWaIiwiZnJhYzU4Ijoi4oWdIiwiZnJhYzc4Ijoi4oWeIiwiZnJhc2wiOiLigYQiLCJmcm93biI6IuKMoiIsImZzY3IiOiLwnZK7IiwiRnNjciI6IuKEsSIsImdhY3V0ZSI6Ise1IiwiR2FtbWEiOiLOkyIsImdhbW1hIjoizrMiLCJHYW1tYWQiOiLPnCIsImdhbW1hZCI6Is+dIiwiZ2FwIjoi4qqGIiwiR2JyZXZlIjoixJ4iLCJnYnJldmUiOiLEnyIsIkdjZWRpbCI6IsSiIiwiR2NpcmMiOiLEnCIsImdjaXJjIjoixJ0iLCJHY3kiOiLQkyIsImdjeSI6ItCzIiwiR2RvdCI6IsSgIiwiZ2RvdCI6IsShIiwiZ2UiOiLiiaUiLCJnRSI6IuKJpyIsImdFbCI6IuKqjCIsImdlbCI6IuKLmyIsImdlcSI6IuKJpSIsImdlcXEiOiLiiaciLCJnZXFzbGFudCI6IuKpviIsImdlc2NjIjoi4qqpIiwiZ2VzIjoi4qm+IiwiZ2VzZG90Ijoi4qqAIiwiZ2VzZG90byI6IuKqgiIsImdlc2RvdG9sIjoi4qqEIiwiZ2VzbCI6IuKLm++4gCIsImdlc2xlcyI6IuKqlCIsIkdmciI6IvCdlIoiLCJnZnIiOiLwnZSkIiwiZ2ciOiLiiasiLCJHZyI6IuKLmSIsImdnZyI6IuKLmSIsImdpbWVsIjoi4oS3IiwiR0pjeSI6ItCDIiwiZ2pjeSI6ItGTIiwiZ2xhIjoi4qqlIiwiZ2wiOiLiibciLCJnbEUiOiLiqpIiLCJnbGoiOiLiqqQiLCJnbmFwIjoi4qqKIiwiZ25hcHByb3giOiLiqooiLCJnbmUiOiLiqogiLCJnbkUiOiLiiakiLCJnbmVxIjoi4qqIIiwiZ25lcXEiOiLiiakiLCJnbnNpbSI6IuKLpyIsIkdvcGYiOiLwnZS+IiwiZ29wZiI6IvCdlZgiLCJncmF2ZSI6ImAiLCJHcmVhdGVyRXF1YWwiOiLiiaUiLCJHcmVhdGVyRXF1YWxMZXNzIjoi4oubIiwiR3JlYXRlckZ1bGxFcXVhbCI6IuKJpyIsIkdyZWF0ZXJHcmVhdGVyIjoi4qqiIiwiR3JlYXRlckxlc3MiOiLiibciLCJHcmVhdGVyU2xhbnRFcXVhbCI6IuKpviIsIkdyZWF0ZXJUaWxkZSI6IuKJsyIsIkdzY3IiOiLwnZKiIiwiZ3NjciI6IuKEiiIsImdzaW0iOiLiibMiLCJnc2ltZSI6IuKqjiIsImdzaW1sIjoi4qqQIiwiZ3RjYyI6IuKqpyIsImd0Y2lyIjoi4qm6IiwiZ3QiOiI+IiwiR1QiOiI+IiwiR3QiOiLiiasiLCJndGRvdCI6IuKLlyIsImd0bFBhciI6IuKmlSIsImd0cXVlc3QiOiLiqbwiLCJndHJhcHByb3giOiLiqoYiLCJndHJhcnIiOiLipbgiLCJndHJkb3QiOiLii5ciLCJndHJlcWxlc3MiOiLii5siLCJndHJlcXFsZXNzIjoi4qqMIiwiZ3RybGVzcyI6IuKJtyIsImd0cnNpbSI6IuKJsyIsImd2ZXJ0bmVxcSI6IuKJqe+4gCIsImd2bkUiOiLiianvuIAiLCJIYWNlayI6IsuHIiwiaGFpcnNwIjoi4oCKIiwiaGFsZiI6IsK9IiwiaGFtaWx0Ijoi4oSLIiwiSEFSRGN5Ijoi0KoiLCJoYXJkY3kiOiLRiiIsImhhcnJjaXIiOiLipYgiLCJoYXJyIjoi4oaUIiwiaEFyciI6IuKHlCIsImhhcnJ3Ijoi4oatIiwiSGF0IjoiXiIsImhiYXIiOiLihI8iLCJIY2lyYyI6IsSkIiwiaGNpcmMiOiLEpSIsImhlYXJ0cyI6IuKZpSIsImhlYXJ0c3VpdCI6IuKZpSIsImhlbGxpcCI6IuKApiIsImhlcmNvbiI6IuKKuSIsImhmciI6IvCdlKUiLCJIZnIiOiLihIwiLCJIaWxiZXJ0U3BhY2UiOiLihIsiLCJoa3NlYXJvdyI6IuKkpSIsImhrc3dhcm93Ijoi4qSmIiwiaG9hcnIiOiLih78iLCJob210aHQiOiLiiLsiLCJob29rbGVmdGFycm93Ijoi4oapIiwiaG9va3JpZ2h0YXJyb3ciOiLihqoiLCJob3BmIjoi8J2VmSIsIkhvcGYiOiLihI0iLCJob3JiYXIiOiLigJUiLCJIb3Jpem9udGFsTGluZSI6IuKUgCIsImhzY3IiOiLwnZK9IiwiSHNjciI6IuKEiyIsImhzbGFzaCI6IuKEjyIsIkhzdHJvayI6IsSmIiwiaHN0cm9rIjoixKciLCJIdW1wRG93bkh1bXAiOiLiiY4iLCJIdW1wRXF1YWwiOiLiiY8iLCJoeWJ1bGwiOiLigYMiLCJoeXBoZW4iOiLigJAiLCJJYWN1dGUiOiLDjSIsImlhY3V0ZSI6IsOtIiwiaWMiOiLigaMiLCJJY2lyYyI6IsOOIiwiaWNpcmMiOiLDriIsIkljeSI6ItCYIiwiaWN5Ijoi0LgiLCJJZG90IjoixLAiLCJJRWN5Ijoi0JUiLCJpZWN5Ijoi0LUiLCJpZXhjbCI6IsKhIiwiaWZmIjoi4oeUIiwiaWZyIjoi8J2UpiIsIklmciI6IuKEkSIsIklncmF2ZSI6IsOMIiwiaWdyYXZlIjoiw6wiLCJpaSI6IuKFiCIsImlpaWludCI6IuKojCIsImlpaW50Ijoi4oitIiwiaWluZmluIjoi4qecIiwiaWlvdGEiOiLihKkiLCJJSmxpZyI6IsSyIiwiaWpsaWciOiLEsyIsIkltYWNyIjoixKoiLCJpbWFjciI6IsSrIiwiaW1hZ2UiOiLihJEiLCJJbWFnaW5hcnlJIjoi4oWIIiwiaW1hZ2xpbmUiOiLihJAiLCJpbWFncGFydCI6IuKEkSIsImltYXRoIjoixLEiLCJJbSI6IuKEkSIsImltb2YiOiLiirciLCJpbXBlZCI6Isa1IiwiSW1wbGllcyI6IuKHkiIsImluY2FyZSI6IuKEhSIsImluIjoi4oiIIiwiaW5maW4iOiLiiJ4iLCJpbmZpbnRpZSI6IuKnnSIsImlub2RvdCI6IsSxIiwiaW50Y2FsIjoi4oq6IiwiaW50Ijoi4oirIiwiSW50Ijoi4oisIiwiaW50ZWdlcnMiOiLihKQiLCJJbnRlZ3JhbCI6IuKIqyIsImludGVyY2FsIjoi4oq6IiwiSW50ZXJzZWN0aW9uIjoi4ouCIiwiaW50bGFyaGsiOiLiqJciLCJpbnRwcm9kIjoi4qi8IiwiSW52aXNpYmxlQ29tbWEiOiLigaMiLCJJbnZpc2libGVUaW1lcyI6IuKBoiIsIklPY3kiOiLQgSIsImlvY3kiOiLRkSIsIklvZ29uIjoixK4iLCJpb2dvbiI6IsSvIiwiSW9wZiI6IvCdlYAiLCJpb3BmIjoi8J2VmiIsIklvdGEiOiLOmSIsImlvdGEiOiLOuSIsImlwcm9kIjoi4qi8IiwiaXF1ZXN0Ijoiwr8iLCJpc2NyIjoi8J2SviIsIklzY3IiOiLihJAiLCJpc2luIjoi4oiIIiwiaXNpbmRvdCI6IuKLtSIsImlzaW5FIjoi4ou5IiwiaXNpbnMiOiLii7QiLCJpc2luc3YiOiLii7MiLCJpc2ludiI6IuKIiCIsIml0Ijoi4oGiIiwiSXRpbGRlIjoixKgiLCJpdGlsZGUiOiLEqSIsIkl1a2N5Ijoi0IYiLCJpdWtjeSI6ItGWIiwiSXVtbCI6IsOPIiwiaXVtbCI6IsOvIiwiSmNpcmMiOiLEtCIsImpjaXJjIjoixLUiLCJKY3kiOiLQmSIsImpjeSI6ItC5IiwiSmZyIjoi8J2UjSIsImpmciI6IvCdlKciLCJqbWF0aCI6Isi3IiwiSm9wZiI6IvCdlYEiLCJqb3BmIjoi8J2VmyIsIkpzY3IiOiLwnZKlIiwianNjciI6IvCdkr8iLCJKc2VyY3kiOiLQiCIsImpzZXJjeSI6ItGYIiwiSnVrY3kiOiLQhCIsImp1a2N5Ijoi0ZQiLCJLYXBwYSI6Is6aIiwia2FwcGEiOiLOuiIsImthcHBhdiI6Is+wIiwiS2NlZGlsIjoixLYiLCJrY2VkaWwiOiLEtyIsIktjeSI6ItCaIiwia2N5Ijoi0LoiLCJLZnIiOiLwnZSOIiwia2ZyIjoi8J2UqCIsImtncmVlbiI6IsS4IiwiS0hjeSI6ItClIiwia2hjeSI6ItGFIiwiS0pjeSI6ItCMIiwia2pjeSI6ItGcIiwiS29wZiI6IvCdlYIiLCJrb3BmIjoi8J2VnCIsIktzY3IiOiLwnZKmIiwia3NjciI6IvCdk4AiLCJsQWFyciI6IuKHmiIsIkxhY3V0ZSI6IsS5IiwibGFjdXRlIjoixLoiLCJsYWVtcHR5diI6IuKmtCIsImxhZ3JhbiI6IuKEkiIsIkxhbWJkYSI6Is6bIiwibGFtYmRhIjoizrsiLCJsYW5nIjoi4p+oIiwiTGFuZyI6IuKfqiIsImxhbmdkIjoi4qaRIiwibGFuZ2xlIjoi4p+oIiwibGFwIjoi4qqFIiwiTGFwbGFjZXRyZiI6IuKEkiIsImxhcXVvIjoiwqsiLCJsYXJyYiI6IuKHpCIsImxhcnJiZnMiOiLipJ8iLCJsYXJyIjoi4oaQIiwiTGFyciI6IuKGniIsImxBcnIiOiLih5AiLCJsYXJyZnMiOiLipJ0iLCJsYXJyaGsiOiLihqkiLCJsYXJybHAiOiLihqsiLCJsYXJycGwiOiLipLkiLCJsYXJyc2ltIjoi4qWzIiwibGFycnRsIjoi4oaiIiwibGF0YWlsIjoi4qSZIiwibEF0YWlsIjoi4qSbIiwibGF0Ijoi4qqrIiwibGF0ZSI6IuKqrSIsImxhdGVzIjoi4qqt77iAIiwibGJhcnIiOiLipIwiLCJsQmFyciI6IuKkjiIsImxiYnJrIjoi4p2yIiwibGJyYWNlIjoieyIsImxicmFjayI6IlsiLCJsYnJrZSI6IuKmiyIsImxicmtzbGQiOiLipo8iLCJsYnJrc2x1Ijoi4qaNIiwiTGNhcm9uIjoixL0iLCJsY2Fyb24iOiLEviIsIkxjZWRpbCI6IsS7IiwibGNlZGlsIjoixLwiLCJsY2VpbCI6IuKMiCIsImxjdWIiOiJ7IiwiTGN5Ijoi0JsiLCJsY3kiOiLQuyIsImxkY2EiOiLipLYiLCJsZHF1byI6IuKAnCIsImxkcXVvciI6IuKAniIsImxkcmRoYXIiOiLipaciLCJsZHJ1c2hhciI6IuKliyIsImxkc2giOiLihrIiLCJsZSI6IuKJpCIsImxFIjoi4ommIiwiTGVmdEFuZ2xlQnJhY2tldCI6IuKfqCIsIkxlZnRBcnJvd0JhciI6IuKHpCIsImxlZnRhcnJvdyI6IuKGkCIsIkxlZnRBcnJvdyI6IuKGkCIsIkxlZnRhcnJvdyI6IuKHkCIsIkxlZnRBcnJvd1JpZ2h0QXJyb3ciOiLih4YiLCJsZWZ0YXJyb3d0YWlsIjoi4oaiIiwiTGVmdENlaWxpbmciOiLijIgiLCJMZWZ0RG91YmxlQnJhY2tldCI6IuKfpiIsIkxlZnREb3duVGVlVmVjdG9yIjoi4qWhIiwiTGVmdERvd25WZWN0b3JCYXIiOiLipZkiLCJMZWZ0RG93blZlY3RvciI6IuKHgyIsIkxlZnRGbG9vciI6IuKMiiIsImxlZnRoYXJwb29uZG93biI6IuKGvSIsImxlZnRoYXJwb29udXAiOiLihrwiLCJsZWZ0bGVmdGFycm93cyI6IuKHhyIsImxlZnRyaWdodGFycm93Ijoi4oaUIiwiTGVmdFJpZ2h0QXJyb3ciOiLihpQiLCJMZWZ0cmlnaHRhcnJvdyI6IuKHlCIsImxlZnRyaWdodGFycm93cyI6IuKHhiIsImxlZnRyaWdodGhhcnBvb25zIjoi4oeLIiwibGVmdHJpZ2h0c3F1aWdhcnJvdyI6IuKGrSIsIkxlZnRSaWdodFZlY3RvciI6IuKljiIsIkxlZnRUZWVBcnJvdyI6IuKGpCIsIkxlZnRUZWUiOiLiiqMiLCJMZWZ0VGVlVmVjdG9yIjoi4qWaIiwibGVmdHRocmVldGltZXMiOiLii4siLCJMZWZ0VHJpYW5nbGVCYXIiOiLip48iLCJMZWZ0VHJpYW5nbGUiOiLiirIiLCJMZWZ0VHJpYW5nbGVFcXVhbCI6IuKKtCIsIkxlZnRVcERvd25WZWN0b3IiOiLipZEiLCJMZWZ0VXBUZWVWZWN0b3IiOiLipaAiLCJMZWZ0VXBWZWN0b3JCYXIiOiLipZgiLCJMZWZ0VXBWZWN0b3IiOiLihr8iLCJMZWZ0VmVjdG9yQmFyIjoi4qWSIiwiTGVmdFZlY3RvciI6IuKGvCIsImxFZyI6IuKqiyIsImxlZyI6IuKLmiIsImxlcSI6IuKJpCIsImxlcXEiOiLiiaYiLCJsZXFzbGFudCI6IuKpvSIsImxlc2NjIjoi4qqoIiwibGVzIjoi4qm9IiwibGVzZG90Ijoi4qm/IiwibGVzZG90byI6IuKqgSIsImxlc2RvdG9yIjoi4qqDIiwibGVzZyI6IuKLmu+4gCIsImxlc2dlcyI6IuKqkyIsImxlc3NhcHByb3giOiLiqoUiLCJsZXNzZG90Ijoi4ouWIiwibGVzc2VxZ3RyIjoi4ouaIiwibGVzc2VxcWd0ciI6IuKqiyIsIkxlc3NFcXVhbEdyZWF0ZXIiOiLii5oiLCJMZXNzRnVsbEVxdWFsIjoi4ommIiwiTGVzc0dyZWF0ZXIiOiLiibYiLCJsZXNzZ3RyIjoi4om2IiwiTGVzc0xlc3MiOiLiqqEiLCJsZXNzc2ltIjoi4omyIiwiTGVzc1NsYW50RXF1YWwiOiLiqb0iLCJMZXNzVGlsZGUiOiLiibIiLCJsZmlzaHQiOiLipbwiLCJsZmxvb3IiOiLijIoiLCJMZnIiOiLwnZSPIiwibGZyIjoi8J2UqSIsImxnIjoi4om2IiwibGdFIjoi4qqRIiwibEhhciI6IuKloiIsImxoYXJkIjoi4oa9IiwibGhhcnUiOiLihrwiLCJsaGFydWwiOiLipaoiLCJsaGJsayI6IuKWhCIsIkxKY3kiOiLQiSIsImxqY3kiOiLRmSIsImxsYXJyIjoi4oeHIiwibGwiOiLiiaoiLCJMbCI6IuKLmCIsImxsY29ybmVyIjoi4oyeIiwiTGxlZnRhcnJvdyI6IuKHmiIsImxsaGFyZCI6IuKlqyIsImxsdHJpIjoi4pe6IiwiTG1pZG90IjoixL8iLCJsbWlkb3QiOiLFgCIsImxtb3VzdGFjaGUiOiLijrAiLCJsbW91c3QiOiLijrAiLCJsbmFwIjoi4qqJIiwibG5hcHByb3giOiLiqokiLCJsbmUiOiLiqociLCJsbkUiOiLiiagiLCJsbmVxIjoi4qqHIiwibG5lcXEiOiLiiagiLCJsbnNpbSI6IuKLpiIsImxvYW5nIjoi4p+sIiwibG9hcnIiOiLih70iLCJsb2JyayI6IuKfpiIsImxvbmdsZWZ0YXJyb3ciOiLin7UiLCJMb25nTGVmdEFycm93Ijoi4p+1IiwiTG9uZ2xlZnRhcnJvdyI6IuKfuCIsImxvbmdsZWZ0cmlnaHRhcnJvdyI6IuKftyIsIkxvbmdMZWZ0UmlnaHRBcnJvdyI6IuKftyIsIkxvbmdsZWZ0cmlnaHRhcnJvdyI6IuKfuiIsImxvbmdtYXBzdG8iOiLin7wiLCJsb25ncmlnaHRhcnJvdyI6IuKftiIsIkxvbmdSaWdodEFycm93Ijoi4p+2IiwiTG9uZ3JpZ2h0YXJyb3ciOiLin7kiLCJsb29wYXJyb3dsZWZ0Ijoi4oarIiwibG9vcGFycm93cmlnaHQiOiLihqwiLCJsb3BhciI6IuKmhSIsIkxvcGYiOiLwnZWDIiwibG9wZiI6IvCdlZ0iLCJsb3BsdXMiOiLiqK0iLCJsb3RpbWVzIjoi4qi0IiwibG93YXN0Ijoi4oiXIiwibG93YmFyIjoiXyIsIkxvd2VyTGVmdEFycm93Ijoi4oaZIiwiTG93ZXJSaWdodEFycm93Ijoi4oaYIiwibG96Ijoi4peKIiwibG96ZW5nZSI6IuKXiiIsImxvemYiOiLip6siLCJscGFyIjoiKCIsImxwYXJsdCI6IuKmkyIsImxyYXJyIjoi4oeGIiwibHJjb3JuZXIiOiLijJ8iLCJscmhhciI6IuKHiyIsImxyaGFyZCI6IuKlrSIsImxybSI6IuKAjiIsImxydHJpIjoi4oq/IiwibHNhcXVvIjoi4oC5IiwibHNjciI6IvCdk4EiLCJMc2NyIjoi4oSSIiwibHNoIjoi4oawIiwiTHNoIjoi4oawIiwibHNpbSI6IuKJsiIsImxzaW1lIjoi4qqNIiwibHNpbWciOiLiqo8iLCJsc3FiIjoiWyIsImxzcXVvIjoi4oCYIiwibHNxdW9yIjoi4oCaIiwiTHN0cm9rIjoixYEiLCJsc3Ryb2siOiLFgiIsImx0Y2MiOiLiqqYiLCJsdGNpciI6IuKpuSIsImx0IjoiPCIsIkxUIjoiPCIsIkx0Ijoi4omqIiwibHRkb3QiOiLii5YiLCJsdGhyZWUiOiLii4siLCJsdGltZXMiOiLii4kiLCJsdGxhcnIiOiLipbYiLCJsdHF1ZXN0Ijoi4qm7IiwibHRyaSI6IuKXgyIsImx0cmllIjoi4oq0IiwibHRyaWYiOiLil4IiLCJsdHJQYXIiOiLippYiLCJsdXJkc2hhciI6IuKliiIsImx1cnVoYXIiOiLipaYiLCJsdmVydG5lcXEiOiLiiajvuIAiLCJsdm5FIjoi4omo77iAIiwibWFjciI6IsKvIiwibWFsZSI6IuKZgiIsIm1hbHQiOiLinKAiLCJtYWx0ZXNlIjoi4pygIiwiTWFwIjoi4qSFIiwibWFwIjoi4oamIiwibWFwc3RvIjoi4oamIiwibWFwc3RvZG93biI6IuKGpyIsIm1hcHN0b2xlZnQiOiLihqQiLCJtYXBzdG91cCI6IuKGpSIsIm1hcmtlciI6IuKWriIsIm1jb21tYSI6IuKoqSIsIk1jeSI6ItCcIiwibWN5Ijoi0LwiLCJtZGFzaCI6IuKAlCIsIm1ERG90Ijoi4oi6IiwibWVhc3VyZWRhbmdsZSI6IuKIoSIsIk1lZGl1bVNwYWNlIjoi4oGfIiwiTWVsbGludHJmIjoi4oSzIiwiTWZyIjoi8J2UkCIsIm1mciI6IvCdlKoiLCJtaG8iOiLihKciLCJtaWNybyI6IsK1IiwibWlkYXN0IjoiKiIsIm1pZGNpciI6IuKrsCIsIm1pZCI6IuKIoyIsIm1pZGRvdCI6IsK3IiwibWludXNiIjoi4oqfIiwibWludXMiOiLiiJIiLCJtaW51c2QiOiLiiLgiLCJtaW51c2R1Ijoi4qiqIiwiTWludXNQbHVzIjoi4oiTIiwibWxjcCI6IuKrmyIsIm1sZHIiOiLigKYiLCJtbnBsdXMiOiLiiJMiLCJtb2RlbHMiOiLiiqciLCJNb3BmIjoi8J2VhCIsIm1vcGYiOiLwnZWeIiwibXAiOiLiiJMiLCJtc2NyIjoi8J2TgiIsIk1zY3IiOiLihLMiLCJtc3Rwb3MiOiLiiL4iLCJNdSI6Is6cIiwibXUiOiLOvCIsIm11bHRpbWFwIjoi4oq4IiwibXVtYXAiOiLiirgiLCJuYWJsYSI6IuKIhyIsIk5hY3V0ZSI6IsWDIiwibmFjdXRlIjoixYQiLCJuYW5nIjoi4oig4oOSIiwibmFwIjoi4omJIiwibmFwRSI6IuKpsMy4IiwibmFwaWQiOiLiiYvMuCIsIm5hcG9zIjoixYkiLCJuYXBwcm94Ijoi4omJIiwibmF0dXJhbCI6IuKZriIsIm5hdHVyYWxzIjoi4oSVIiwibmF0dXIiOiLima4iLCJuYnNwIjoiwqAiLCJuYnVtcCI6IuKJjsy4IiwibmJ1bXBlIjoi4omPzLgiLCJuY2FwIjoi4qmDIiwiTmNhcm9uIjoixYciLCJuY2Fyb24iOiLFiCIsIk5jZWRpbCI6IsWFIiwibmNlZGlsIjoixYYiLCJuY29uZyI6IuKJhyIsIm5jb25nZG90Ijoi4qmtzLgiLCJuY3VwIjoi4qmCIiwiTmN5Ijoi0J0iLCJuY3kiOiLQvSIsIm5kYXNoIjoi4oCTIiwibmVhcmhrIjoi4qSkIiwibmVhcnIiOiLihpciLCJuZUFyciI6IuKHlyIsIm5lYXJyb3ciOiLihpciLCJuZSI6IuKJoCIsIm5lZG90Ijoi4omQzLgiLCJOZWdhdGl2ZU1lZGl1bVNwYWNlIjoi4oCLIiwiTmVnYXRpdmVUaGlja1NwYWNlIjoi4oCLIiwiTmVnYXRpdmVUaGluU3BhY2UiOiLigIsiLCJOZWdhdGl2ZVZlcnlUaGluU3BhY2UiOiLigIsiLCJuZXF1aXYiOiLiiaIiLCJuZXNlYXIiOiLipKgiLCJuZXNpbSI6IuKJgsy4IiwiTmVzdGVkR3JlYXRlckdyZWF0ZXIiOiLiiasiLCJOZXN0ZWRMZXNzTGVzcyI6IuKJqiIsIk5ld0xpbmUiOiJcXG4iLCJuZXhpc3QiOiLiiIQiLCJuZXhpc3RzIjoi4oiEIiwiTmZyIjoi8J2UkSIsIm5mciI6IvCdlKsiLCJuZ0UiOiLiiafMuCIsIm5nZSI6IuKJsSIsIm5nZXEiOiLiibEiLCJuZ2VxcSI6IuKJp8y4IiwibmdlcXNsYW50Ijoi4qm+zLgiLCJuZ2VzIjoi4qm+zLgiLCJuR2ciOiLii5nMuCIsIm5nc2ltIjoi4om1Iiwibkd0Ijoi4omr4oOSIiwibmd0Ijoi4omvIiwibmd0ciI6IuKJryIsIm5HdHYiOiLiiavMuCIsIm5oYXJyIjoi4oauIiwibmhBcnIiOiLih44iLCJuaHBhciI6IuKrsiIsIm5pIjoi4oiLIiwibmlzIjoi4ou8IiwibmlzZCI6IuKLuiIsIm5pdiI6IuKIiyIsIk5KY3kiOiLQiiIsIm5qY3kiOiLRmiIsIm5sYXJyIjoi4oaaIiwibmxBcnIiOiLih40iLCJubGRyIjoi4oClIiwibmxFIjoi4ommzLgiLCJubGUiOiLiibAiLCJubGVmdGFycm93Ijoi4oaaIiwibkxlZnRhcnJvdyI6IuKHjSIsIm5sZWZ0cmlnaHRhcnJvdyI6IuKGriIsIm5MZWZ0cmlnaHRhcnJvdyI6IuKHjiIsIm5sZXEiOiLiibAiLCJubGVxcSI6IuKJpsy4IiwibmxlcXNsYW50Ijoi4qm9zLgiLCJubGVzIjoi4qm9zLgiLCJubGVzcyI6IuKJriIsIm5MbCI6IuKLmMy4IiwibmxzaW0iOiLiibQiLCJuTHQiOiLiiarig5IiLCJubHQiOiLiia4iLCJubHRyaSI6IuKLqiIsIm5sdHJpZSI6IuKLrCIsIm5MdHYiOiLiiarMuCIsIm5taWQiOiLiiKQiLCJOb0JyZWFrIjoi4oGgIiwiTm9uQnJlYWtpbmdTcGFjZSI6IsKgIiwibm9wZiI6IvCdlZ8iLCJOb3BmIjoi4oSVIiwiTm90Ijoi4qusIiwibm90IjoiwqwiLCJOb3RDb25ncnVlbnQiOiLiiaIiLCJOb3RDdXBDYXAiOiLiia0iLCJOb3REb3VibGVWZXJ0aWNhbEJhciI6IuKIpiIsIk5vdEVsZW1lbnQiOiLiiIkiLCJOb3RFcXVhbCI6IuKJoCIsIk5vdEVxdWFsVGlsZGUiOiLiiYLMuCIsIk5vdEV4aXN0cyI6IuKIhCIsIk5vdEdyZWF0ZXIiOiLiia8iLCJOb3RHcmVhdGVyRXF1YWwiOiLiibEiLCJOb3RHcmVhdGVyRnVsbEVxdWFsIjoi4omnzLgiLCJOb3RHcmVhdGVyR3JlYXRlciI6IuKJq8y4IiwiTm90R3JlYXRlckxlc3MiOiLiibkiLCJOb3RHcmVhdGVyU2xhbnRFcXVhbCI6IuKpvsy4IiwiTm90R3JlYXRlclRpbGRlIjoi4om1IiwiTm90SHVtcERvd25IdW1wIjoi4omOzLgiLCJOb3RIdW1wRXF1YWwiOiLiiY/MuCIsIm5vdGluIjoi4oiJIiwibm90aW5kb3QiOiLii7XMuCIsIm5vdGluRSI6IuKLucy4Iiwibm90aW52YSI6IuKIiSIsIm5vdGludmIiOiLii7ciLCJub3RpbnZjIjoi4ou2IiwiTm90TGVmdFRyaWFuZ2xlQmFyIjoi4qePzLgiLCJOb3RMZWZ0VHJpYW5nbGUiOiLii6oiLCJOb3RMZWZ0VHJpYW5nbGVFcXVhbCI6IuKLrCIsIk5vdExlc3MiOiLiia4iLCJOb3RMZXNzRXF1YWwiOiLiibAiLCJOb3RMZXNzR3JlYXRlciI6IuKJuCIsIk5vdExlc3NMZXNzIjoi4omqzLgiLCJOb3RMZXNzU2xhbnRFcXVhbCI6IuKpvcy4IiwiTm90TGVzc1RpbGRlIjoi4om0IiwiTm90TmVzdGVkR3JlYXRlckdyZWF0ZXIiOiLiqqLMuCIsIk5vdE5lc3RlZExlc3NMZXNzIjoi4qqhzLgiLCJub3RuaSI6IuKIjCIsIm5vdG5pdmEiOiLiiIwiLCJub3RuaXZiIjoi4ou+Iiwibm90bml2YyI6IuKLvSIsIk5vdFByZWNlZGVzIjoi4oqAIiwiTm90UHJlY2VkZXNFcXVhbCI6IuKqr8y4IiwiTm90UHJlY2VkZXNTbGFudEVxdWFsIjoi4ougIiwiTm90UmV2ZXJzZUVsZW1lbnQiOiLiiIwiLCJOb3RSaWdodFRyaWFuZ2xlQmFyIjoi4qeQzLgiLCJOb3RSaWdodFRyaWFuZ2xlIjoi4ourIiwiTm90UmlnaHRUcmlhbmdsZUVxdWFsIjoi4outIiwiTm90U3F1YXJlU3Vic2V0Ijoi4oqPzLgiLCJOb3RTcXVhcmVTdWJzZXRFcXVhbCI6IuKLoiIsIk5vdFNxdWFyZVN1cGVyc2V0Ijoi4oqQzLgiLCJOb3RTcXVhcmVTdXBlcnNldEVxdWFsIjoi4oujIiwiTm90U3Vic2V0Ijoi4oqC4oOSIiwiTm90U3Vic2V0RXF1YWwiOiLiiogiLCJOb3RTdWNjZWVkcyI6IuKKgSIsIk5vdFN1Y2NlZWRzRXF1YWwiOiLiqrDMuCIsIk5vdFN1Y2NlZWRzU2xhbnRFcXVhbCI6IuKLoSIsIk5vdFN1Y2NlZWRzVGlsZGUiOiLiib/MuCIsIk5vdFN1cGVyc2V0Ijoi4oqD4oOSIiwiTm90U3VwZXJzZXRFcXVhbCI6IuKKiSIsIk5vdFRpbGRlIjoi4omBIiwiTm90VGlsZGVFcXVhbCI6IuKJhCIsIk5vdFRpbGRlRnVsbEVxdWFsIjoi4omHIiwiTm90VGlsZGVUaWxkZSI6IuKJiSIsIk5vdFZlcnRpY2FsQmFyIjoi4oikIiwibnBhcmFsbGVsIjoi4oimIiwibnBhciI6IuKIpiIsIm5wYXJzbCI6IuKrveKDpSIsIm5wYXJ0Ijoi4oiCzLgiLCJucG9saW50Ijoi4qiUIiwibnByIjoi4oqAIiwibnByY3VlIjoi4ougIiwibnByZWMiOiLiioAiLCJucHJlY2VxIjoi4qqvzLgiLCJucHJlIjoi4qqvzLgiLCJucmFycmMiOiLipLPMuCIsIm5yYXJyIjoi4oabIiwibnJBcnIiOiLih48iLCJucmFycnciOiLihp3MuCIsIm5yaWdodGFycm93Ijoi4oabIiwiblJpZ2h0YXJyb3ciOiLih48iLCJucnRyaSI6IuKLqyIsIm5ydHJpZSI6IuKLrSIsIm5zYyI6IuKKgSIsIm5zY2N1ZSI6IuKLoSIsIm5zY2UiOiLiqrDMuCIsIk5zY3IiOiLwnZKpIiwibnNjciI6IvCdk4MiLCJuc2hvcnRtaWQiOiLiiKQiLCJuc2hvcnRwYXJhbGxlbCI6IuKIpiIsIm5zaW0iOiLiiYEiLCJuc2ltZSI6IuKJhCIsIm5zaW1lcSI6IuKJhCIsIm5zbWlkIjoi4oikIiwibnNwYXIiOiLiiKYiLCJuc3FzdWJlIjoi4ouiIiwibnNxc3VwZSI6IuKLoyIsIm5zdWIiOiLiioQiLCJuc3ViRSI6IuKrhcy4IiwibnN1YmUiOiLiiogiLCJuc3Vic2V0Ijoi4oqC4oOSIiwibnN1YnNldGVxIjoi4oqIIiwibnN1YnNldGVxcSI6IuKrhcy4IiwibnN1Y2MiOiLiioEiLCJuc3VjY2VxIjoi4qqwzLgiLCJuc3VwIjoi4oqFIiwibnN1cEUiOiLiq4bMuCIsIm5zdXBlIjoi4oqJIiwibnN1cHNldCI6IuKKg+KDkiIsIm5zdXBzZXRlcSI6IuKKiSIsIm5zdXBzZXRlcXEiOiLiq4bMuCIsIm50Z2wiOiLiibkiLCJOdGlsZGUiOiLDkSIsIm50aWxkZSI6IsOxIiwibnRsZyI6IuKJuCIsIm50cmlhbmdsZWxlZnQiOiLii6oiLCJudHJpYW5nbGVsZWZ0ZXEiOiLii6wiLCJudHJpYW5nbGVyaWdodCI6IuKLqyIsIm50cmlhbmdsZXJpZ2h0ZXEiOiLii60iLCJOdSI6Is6dIiwibnUiOiLOvSIsIm51bSI6IiMiLCJudW1lcm8iOiLihJYiLCJudW1zcCI6IuKAhyIsIm52YXAiOiLiiY3ig5IiLCJudmRhc2giOiLiiqwiLCJudkRhc2giOiLiiq0iLCJuVmRhc2giOiLiiq4iLCJuVkRhc2giOiLiiq8iLCJudmdlIjoi4oml4oOSIiwibnZndCI6Ij7ig5IiLCJudkhhcnIiOiLipIQiLCJudmluZmluIjoi4qeeIiwibnZsQXJyIjoi4qSCIiwibnZsZSI6IuKJpOKDkiIsIm52bHQiOiI84oOSIiwibnZsdHJpZSI6IuKKtOKDkiIsIm52ckFyciI6IuKkgyIsIm52cnRyaWUiOiLiirXig5IiLCJudnNpbSI6IuKIvOKDkiIsIm53YXJoayI6IuKkoyIsIm53YXJyIjoi4oaWIiwibndBcnIiOiLih5YiLCJud2Fycm93Ijoi4oaWIiwibnduZWFyIjoi4qSnIiwiT2FjdXRlIjoiw5MiLCJvYWN1dGUiOiLDsyIsIm9hc3QiOiLiipsiLCJPY2lyYyI6IsOUIiwib2NpcmMiOiLDtCIsIm9jaXIiOiLiipoiLCJPY3kiOiLQniIsIm9jeSI6ItC+Iiwib2Rhc2giOiLiip0iLCJPZGJsYWMiOiLFkCIsIm9kYmxhYyI6IsWRIiwib2RpdiI6IuKouCIsIm9kb3QiOiLiipkiLCJvZHNvbGQiOiLiprwiLCJPRWxpZyI6IsWSIiwib2VsaWciOiLFkyIsIm9mY2lyIjoi4qa/IiwiT2ZyIjoi8J2UkiIsIm9mciI6IvCdlKwiLCJvZ29uIjoiy5siLCJPZ3JhdmUiOiLDkiIsIm9ncmF2ZSI6IsOyIiwib2d0Ijoi4qeBIiwib2hiYXIiOiLiprUiLCJvaG0iOiLOqSIsIm9pbnQiOiLiiK4iLCJvbGFyciI6IuKGuiIsIm9sY2lyIjoi4qa+Iiwib2xjcm9zcyI6IuKmuyIsIm9saW5lIjoi4oC+Iiwib2x0Ijoi4qeAIiwiT21hY3IiOiLFjCIsIm9tYWNyIjoixY0iLCJPbWVnYSI6Is6pIiwib21lZ2EiOiLPiSIsIk9taWNyb24iOiLOnyIsIm9taWNyb24iOiLOvyIsIm9taWQiOiLiprYiLCJvbWludXMiOiLiipYiLCJPb3BmIjoi8J2VhiIsIm9vcGYiOiLwnZWgIiwib3BhciI6IuKmtyIsIk9wZW5DdXJseURvdWJsZVF1b3RlIjoi4oCcIiwiT3BlbkN1cmx5UXVvdGUiOiLigJgiLCJvcGVycCI6IuKmuSIsIm9wbHVzIjoi4oqVIiwib3JhcnIiOiLihrsiLCJPciI6IuKplCIsIm9yIjoi4oioIiwib3JkIjoi4qmdIiwib3JkZXIiOiLihLQiLCJvcmRlcm9mIjoi4oS0Iiwib3JkZiI6IsKqIiwib3JkbSI6IsK6Iiwib3JpZ29mIjoi4oq2Iiwib3JvciI6IuKpliIsIm9yc2xvcGUiOiLiqZciLCJvcnYiOiLiqZsiLCJvUyI6IuKTiCIsIk9zY3IiOiLwnZKqIiwib3NjciI6IuKEtCIsIk9zbGFzaCI6IsOYIiwib3NsYXNoIjoiw7giLCJvc29sIjoi4oqYIiwiT3RpbGRlIjoiw5UiLCJvdGlsZGUiOiLDtSIsIm90aW1lc2FzIjoi4qi2IiwiT3RpbWVzIjoi4qi3Iiwib3RpbWVzIjoi4oqXIiwiT3VtbCI6IsOWIiwib3VtbCI6IsO2Iiwib3ZiYXIiOiLijL0iLCJPdmVyQmFyIjoi4oC+IiwiT3ZlckJyYWNlIjoi4o+eIiwiT3ZlckJyYWNrZXQiOiLijrQiLCJPdmVyUGFyZW50aGVzaXMiOiLij5wiLCJwYXJhIjoiwrYiLCJwYXJhbGxlbCI6IuKIpSIsInBhciI6IuKIpSIsInBhcnNpbSI6IuKrsyIsInBhcnNsIjoi4qu9IiwicGFydCI6IuKIgiIsIlBhcnRpYWxEIjoi4oiCIiwiUGN5Ijoi0J8iLCJwY3kiOiLQvyIsInBlcmNudCI6IiUiLCJwZXJpb2QiOiIuIiwicGVybWlsIjoi4oCwIiwicGVycCI6IuKKpSIsInBlcnRlbmsiOiLigLEiLCJQZnIiOiLwnZSTIiwicGZyIjoi8J2UrSIsIlBoaSI6Is6mIiwicGhpIjoiz4YiLCJwaGl2Ijoiz5UiLCJwaG1tYXQiOiLihLMiLCJwaG9uZSI6IuKYjiIsIlBpIjoizqAiLCJwaSI6Is+AIiwicGl0Y2hmb3JrIjoi4ouUIiwicGl2Ijoiz5YiLCJwbGFuY2siOiLihI8iLCJwbGFuY2toIjoi4oSOIiwicGxhbmt2Ijoi4oSPIiwicGx1c2FjaXIiOiLiqKMiLCJwbHVzYiI6IuKKniIsInBsdXNjaXIiOiLiqKIiLCJwbHVzIjoiKyIsInBsdXNkbyI6IuKIlCIsInBsdXNkdSI6IuKopSIsInBsdXNlIjoi4qmyIiwiUGx1c01pbnVzIjoiwrEiLCJwbHVzbW4iOiLCsSIsInBsdXNzaW0iOiLiqKYiLCJwbHVzdHdvIjoi4qinIiwicG0iOiLCsSIsIlBvaW5jYXJlcGxhbmUiOiLihIwiLCJwb2ludGludCI6IuKolSIsInBvcGYiOiLwnZWhIiwiUG9wZiI6IuKEmSIsInBvdW5kIjoiwqMiLCJwcmFwIjoi4qq3IiwiUHIiOiLiqrsiLCJwciI6IuKJuiIsInByY3VlIjoi4om8IiwicHJlY2FwcHJveCI6IuKqtyIsInByZWMiOiLiiboiLCJwcmVjY3VybHllcSI6IuKJvCIsIlByZWNlZGVzIjoi4om6IiwiUHJlY2VkZXNFcXVhbCI6IuKqryIsIlByZWNlZGVzU2xhbnRFcXVhbCI6IuKJvCIsIlByZWNlZGVzVGlsZGUiOiLiib4iLCJwcmVjZXEiOiLiqq8iLCJwcmVjbmFwcHJveCI6IuKquSIsInByZWNuZXFxIjoi4qq1IiwicHJlY25zaW0iOiLii6giLCJwcmUiOiLiqq8iLCJwckUiOiLiqrMiLCJwcmVjc2ltIjoi4om+IiwicHJpbWUiOiLigLIiLCJQcmltZSI6IuKAsyIsInByaW1lcyI6IuKEmSIsInBybmFwIjoi4qq5IiwicHJuRSI6IuKqtSIsInBybnNpbSI6IuKLqCIsInByb2QiOiLiiI8iLCJQcm9kdWN0Ijoi4oiPIiwicHJvZmFsYXIiOiLijK4iLCJwcm9mbGluZSI6IuKMkiIsInByb2ZzdXJmIjoi4oyTIiwicHJvcCI6IuKInSIsIlByb3BvcnRpb25hbCI6IuKInSIsIlByb3BvcnRpb24iOiLiiLciLCJwcm9wdG8iOiLiiJ0iLCJwcnNpbSI6IuKJviIsInBydXJlbCI6IuKKsCIsIlBzY3IiOiLwnZKrIiwicHNjciI6IvCdk4UiLCJQc2kiOiLOqCIsInBzaSI6Is+IIiwicHVuY3NwIjoi4oCIIiwiUWZyIjoi8J2UlCIsInFmciI6IvCdlK4iLCJxaW50Ijoi4qiMIiwicW9wZiI6IvCdlaIiLCJRb3BmIjoi4oSaIiwicXByaW1lIjoi4oGXIiwiUXNjciI6IvCdkqwiLCJxc2NyIjoi8J2ThiIsInF1YXRlcm5pb25zIjoi4oSNIiwicXVhdGludCI6IuKoliIsInF1ZXN0IjoiPyIsInF1ZXN0ZXEiOiLiiZ8iLCJxdW90IjoiXFwiIiwiUVVPVCI6IlxcIiIsInJBYXJyIjoi4oebIiwicmFjZSI6IuKIvcyxIiwiUmFjdXRlIjoixZQiLCJyYWN1dGUiOiLFlSIsInJhZGljIjoi4oiaIiwicmFlbXB0eXYiOiLiprMiLCJyYW5nIjoi4p+pIiwiUmFuZyI6IuKfqyIsInJhbmdkIjoi4qaSIiwicmFuZ2UiOiLipqUiLCJyYW5nbGUiOiLin6kiLCJyYXF1byI6IsK7IiwicmFycmFwIjoi4qW1IiwicmFycmIiOiLih6UiLCJyYXJyYmZzIjoi4qSgIiwicmFycmMiOiLipLMiLCJyYXJyIjoi4oaSIiwiUmFyciI6IuKGoCIsInJBcnIiOiLih5IiLCJyYXJyZnMiOiLipJ4iLCJyYXJyaGsiOiLihqoiLCJyYXJybHAiOiLihqwiLCJyYXJycGwiOiLipYUiLCJyYXJyc2ltIjoi4qW0IiwiUmFycnRsIjoi4qSWIiwicmFycnRsIjoi4oajIiwicmFycnciOiLihp0iLCJyYXRhaWwiOiLipJoiLCJyQXRhaWwiOiLipJwiLCJyYXRpbyI6IuKItiIsInJhdGlvbmFscyI6IuKEmiIsInJiYXJyIjoi4qSNIiwickJhcnIiOiLipI8iLCJSQmFyciI6IuKkkCIsInJiYnJrIjoi4p2zIiwicmJyYWNlIjoifSIsInJicmFjayI6Il0iLCJyYnJrZSI6IuKmjCIsInJicmtzbGQiOiLipo4iLCJyYnJrc2x1Ijoi4qaQIiwiUmNhcm9uIjoixZgiLCJyY2Fyb24iOiLFmSIsIlJjZWRpbCI6IsWWIiwicmNlZGlsIjoixZciLCJyY2VpbCI6IuKMiSIsInJjdWIiOiJ9IiwiUmN5Ijoi0KAiLCJyY3kiOiLRgCIsInJkY2EiOiLipLciLCJyZGxkaGFyIjoi4qWpIiwicmRxdW8iOiLigJ0iLCJyZHF1b3IiOiLigJ0iLCJyZHNoIjoi4oazIiwicmVhbCI6IuKEnCIsInJlYWxpbmUiOiLihJsiLCJyZWFscGFydCI6IuKEnCIsInJlYWxzIjoi4oSdIiwiUmUiOiLihJwiLCJyZWN0Ijoi4patIiwicmVnIjoiwq4iLCJSRUciOiLCriIsIlJldmVyc2VFbGVtZW50Ijoi4oiLIiwiUmV2ZXJzZUVxdWlsaWJyaXVtIjoi4oeLIiwiUmV2ZXJzZVVwRXF1aWxpYnJpdW0iOiLipa8iLCJyZmlzaHQiOiLipb0iLCJyZmxvb3IiOiLijIsiLCJyZnIiOiLwnZSvIiwiUmZyIjoi4oScIiwickhhciI6IuKlpCIsInJoYXJkIjoi4oeBIiwicmhhcnUiOiLih4AiLCJyaGFydWwiOiLipawiLCJSaG8iOiLOoSIsInJobyI6Is+BIiwicmhvdiI6Is+xIiwiUmlnaHRBbmdsZUJyYWNrZXQiOiLin6kiLCJSaWdodEFycm93QmFyIjoi4oelIiwicmlnaHRhcnJvdyI6IuKGkiIsIlJpZ2h0QXJyb3ciOiLihpIiLCJSaWdodGFycm93Ijoi4oeSIiwiUmlnaHRBcnJvd0xlZnRBcnJvdyI6IuKHhCIsInJpZ2h0YXJyb3d0YWlsIjoi4oajIiwiUmlnaHRDZWlsaW5nIjoi4oyJIiwiUmlnaHREb3VibGVCcmFja2V0Ijoi4p+nIiwiUmlnaHREb3duVGVlVmVjdG9yIjoi4qWdIiwiUmlnaHREb3duVmVjdG9yQmFyIjoi4qWVIiwiUmlnaHREb3duVmVjdG9yIjoi4oeCIiwiUmlnaHRGbG9vciI6IuKMiyIsInJpZ2h0aGFycG9vbmRvd24iOiLih4EiLCJyaWdodGhhcnBvb251cCI6IuKHgCIsInJpZ2h0bGVmdGFycm93cyI6IuKHhCIsInJpZ2h0bGVmdGhhcnBvb25zIjoi4oeMIiwicmlnaHRyaWdodGFycm93cyI6IuKHiSIsInJpZ2h0c3F1aWdhcnJvdyI6IuKGnSIsIlJpZ2h0VGVlQXJyb3ciOiLihqYiLCJSaWdodFRlZSI6IuKKoiIsIlJpZ2h0VGVlVmVjdG9yIjoi4qWbIiwicmlnaHR0aHJlZXRpbWVzIjoi4ouMIiwiUmlnaHRUcmlhbmdsZUJhciI6IuKnkCIsIlJpZ2h0VHJpYW5nbGUiOiLiirMiLCJSaWdodFRyaWFuZ2xlRXF1YWwiOiLiirUiLCJSaWdodFVwRG93blZlY3RvciI6IuKljyIsIlJpZ2h0VXBUZWVWZWN0b3IiOiLipZwiLCJSaWdodFVwVmVjdG9yQmFyIjoi4qWUIiwiUmlnaHRVcFZlY3RvciI6IuKGviIsIlJpZ2h0VmVjdG9yQmFyIjoi4qWTIiwiUmlnaHRWZWN0b3IiOiLih4AiLCJyaW5nIjoiy5oiLCJyaXNpbmdkb3RzZXEiOiLiiZMiLCJybGFyciI6IuKHhCIsInJsaGFyIjoi4oeMIiwicmxtIjoi4oCPIiwicm1vdXN0YWNoZSI6IuKOsSIsInJtb3VzdCI6IuKOsSIsInJubWlkIjoi4quuIiwicm9hbmciOiLin60iLCJyb2FyciI6IuKHviIsInJvYnJrIjoi4p+nIiwicm9wYXIiOiLipoYiLCJyb3BmIjoi8J2VoyIsIlJvcGYiOiLihJ0iLCJyb3BsdXMiOiLiqK4iLCJyb3RpbWVzIjoi4qi1IiwiUm91bmRJbXBsaWVzIjoi4qWwIiwicnBhciI6IikiLCJycGFyZ3QiOiLippQiLCJycHBvbGludCI6IuKokiIsInJyYXJyIjoi4oeJIiwiUnJpZ2h0YXJyb3ciOiLih5siLCJyc2FxdW8iOiLigLoiLCJyc2NyIjoi8J2ThyIsIlJzY3IiOiLihJsiLCJyc2giOiLihrEiLCJSc2giOiLihrEiLCJyc3FiIjoiXSIsInJzcXVvIjoi4oCZIiwicnNxdW9yIjoi4oCZIiwicnRocmVlIjoi4ouMIiwicnRpbWVzIjoi4ouKIiwicnRyaSI6IuKWuSIsInJ0cmllIjoi4oq1IiwicnRyaWYiOiLilrgiLCJydHJpbHRyaSI6IuKnjiIsIlJ1bGVEZWxheWVkIjoi4qe0IiwicnVsdWhhciI6IuKlqCIsInJ4Ijoi4oSeIiwiU2FjdXRlIjoixZoiLCJzYWN1dGUiOiLFmyIsInNicXVvIjoi4oCaIiwic2NhcCI6IuKquCIsIlNjYXJvbiI6IsWgIiwic2Nhcm9uIjoixaEiLCJTYyI6IuKqvCIsInNjIjoi4om7Iiwic2NjdWUiOiLiib0iLCJzY2UiOiLiqrAiLCJzY0UiOiLiqrQiLCJTY2VkaWwiOiLFniIsInNjZWRpbCI6IsWfIiwiU2NpcmMiOiLFnCIsInNjaXJjIjoixZ0iLCJzY25hcCI6IuKquiIsInNjbkUiOiLiqrYiLCJzY25zaW0iOiLii6kiLCJzY3BvbGludCI6IuKokyIsInNjc2ltIjoi4om/IiwiU2N5Ijoi0KEiLCJzY3kiOiLRgSIsInNkb3RiIjoi4oqhIiwic2RvdCI6IuKLhSIsInNkb3RlIjoi4qmmIiwic2VhcmhrIjoi4qSlIiwic2VhcnIiOiLihpgiLCJzZUFyciI6IuKHmCIsInNlYXJyb3ciOiLihpgiLCJzZWN0IjoiwqciLCJzZW1pIjoiOyIsInNlc3dhciI6IuKkqSIsInNldG1pbnVzIjoi4oiWIiwic2V0bW4iOiLiiJYiLCJzZXh0Ijoi4py2IiwiU2ZyIjoi8J2UliIsInNmciI6IvCdlLAiLCJzZnJvd24iOiLijKIiLCJzaGFycCI6IuKZryIsIlNIQ0hjeSI6ItCpIiwic2hjaGN5Ijoi0YkiLCJTSGN5Ijoi0KgiLCJzaGN5Ijoi0YgiLCJTaG9ydERvd25BcnJvdyI6IuKGkyIsIlNob3J0TGVmdEFycm93Ijoi4oaQIiwic2hvcnRtaWQiOiLiiKMiLCJzaG9ydHBhcmFsbGVsIjoi4oilIiwiU2hvcnRSaWdodEFycm93Ijoi4oaSIiwiU2hvcnRVcEFycm93Ijoi4oaRIiwic2h5Ijoiwq0iLCJTaWdtYSI6Is6jIiwic2lnbWEiOiLPgyIsInNpZ21hZiI6Is+CIiwic2lnbWF2Ijoiz4IiLCJzaW0iOiLiiLwiLCJzaW1kb3QiOiLiqaoiLCJzaW1lIjoi4omDIiwic2ltZXEiOiLiiYMiLCJzaW1nIjoi4qqeIiwic2ltZ0UiOiLiqqAiLCJzaW1sIjoi4qqdIiwic2ltbEUiOiLiqp8iLCJzaW1uZSI6IuKJhiIsInNpbXBsdXMiOiLiqKQiLCJzaW1yYXJyIjoi4qWyIiwic2xhcnIiOiLihpAiLCJTbWFsbENpcmNsZSI6IuKImCIsInNtYWxsc2V0bWludXMiOiLiiJYiLCJzbWFzaHAiOiLiqLMiLCJzbWVwYXJzbCI6IuKnpCIsInNtaWQiOiLiiKMiLCJzbWlsZSI6IuKMoyIsInNtdCI6IuKqqiIsInNtdGUiOiLiqqwiLCJzbXRlcyI6IuKqrO+4gCIsIlNPRlRjeSI6ItCsIiwic29mdGN5Ijoi0YwiLCJzb2xiYXIiOiLijL8iLCJzb2xiIjoi4qeEIiwic29sIjoiLyIsIlNvcGYiOiLwnZWKIiwic29wZiI6IvCdlaQiLCJzcGFkZXMiOiLimaAiLCJzcGFkZXN1aXQiOiLimaAiLCJzcGFyIjoi4oilIiwic3FjYXAiOiLiipMiLCJzcWNhcHMiOiLiipPvuIAiLCJzcWN1cCI6IuKKlCIsInNxY3VwcyI6IuKKlO+4gCIsIlNxcnQiOiLiiJoiLCJzcXN1YiI6IuKKjyIsInNxc3ViZSI6IuKKkSIsInNxc3Vic2V0Ijoi4oqPIiwic3FzdWJzZXRlcSI6IuKKkSIsInNxc3VwIjoi4oqQIiwic3FzdXBlIjoi4oqSIiwic3FzdXBzZXQiOiLiipAiLCJzcXN1cHNldGVxIjoi4oqSIiwic3F1YXJlIjoi4pahIiwiU3F1YXJlIjoi4pahIiwiU3F1YXJlSW50ZXJzZWN0aW9uIjoi4oqTIiwiU3F1YXJlU3Vic2V0Ijoi4oqPIiwiU3F1YXJlU3Vic2V0RXF1YWwiOiLiipEiLCJTcXVhcmVTdXBlcnNldCI6IuKKkCIsIlNxdWFyZVN1cGVyc2V0RXF1YWwiOiLiipIiLCJTcXVhcmVVbmlvbiI6IuKKlCIsInNxdWFyZiI6IuKWqiIsInNxdSI6IuKWoSIsInNxdWYiOiLilqoiLCJzcmFyciI6IuKGkiIsIlNzY3IiOiLwnZKuIiwic3NjciI6IvCdk4giLCJzc2V0bW4iOiLiiJYiLCJzc21pbGUiOiLijKMiLCJzc3RhcmYiOiLii4YiLCJTdGFyIjoi4ouGIiwic3RhciI6IuKYhiIsInN0YXJmIjoi4piFIiwic3RyYWlnaHRlcHNpbG9uIjoiz7UiLCJzdHJhaWdodHBoaSI6Is+VIiwic3RybnMiOiLCryIsInN1YiI6IuKKgiIsIlN1YiI6IuKLkCIsInN1YmRvdCI6IuKqvSIsInN1YkUiOiLiq4UiLCJzdWJlIjoi4oqGIiwic3ViZWRvdCI6IuKrgyIsInN1Ym11bHQiOiLiq4EiLCJzdWJuRSI6IuKriyIsInN1Ym5lIjoi4oqKIiwic3VicGx1cyI6IuKqvyIsInN1YnJhcnIiOiLipbkiLCJzdWJzZXQiOiLiioIiLCJTdWJzZXQiOiLii5AiLCJzdWJzZXRlcSI6IuKKhiIsInN1YnNldGVxcSI6IuKrhSIsIlN1YnNldEVxdWFsIjoi4oqGIiwic3Vic2V0bmVxIjoi4oqKIiwic3Vic2V0bmVxcSI6IuKriyIsInN1YnNpbSI6IuKrhyIsInN1YnN1YiI6IuKrlSIsInN1YnN1cCI6IuKrkyIsInN1Y2NhcHByb3giOiLiqrgiLCJzdWNjIjoi4om7Iiwic3VjY2N1cmx5ZXEiOiLiib0iLCJTdWNjZWVkcyI6IuKJuyIsIlN1Y2NlZWRzRXF1YWwiOiLiqrAiLCJTdWNjZWVkc1NsYW50RXF1YWwiOiLiib0iLCJTdWNjZWVkc1RpbGRlIjoi4om/Iiwic3VjY2VxIjoi4qqwIiwic3VjY25hcHByb3giOiLiqroiLCJzdWNjbmVxcSI6IuKqtiIsInN1Y2Nuc2ltIjoi4oupIiwic3VjY3NpbSI6IuKJvyIsIlN1Y2hUaGF0Ijoi4oiLIiwic3VtIjoi4oiRIiwiU3VtIjoi4oiRIiwic3VuZyI6IuKZqiIsInN1cDEiOiLCuSIsInN1cDIiOiLCsiIsInN1cDMiOiLCsyIsInN1cCI6IuKKgyIsIlN1cCI6IuKLkSIsInN1cGRvdCI6IuKqviIsInN1cGRzdWIiOiLiq5giLCJzdXBFIjoi4quGIiwic3VwZSI6IuKKhyIsInN1cGVkb3QiOiLiq4QiLCJTdXBlcnNldCI6IuKKgyIsIlN1cGVyc2V0RXF1YWwiOiLiiociLCJzdXBoc29sIjoi4p+JIiwic3VwaHN1YiI6IuKrlyIsInN1cGxhcnIiOiLipbsiLCJzdXBtdWx0Ijoi4quCIiwic3VwbkUiOiLiq4wiLCJzdXBuZSI6IuKKiyIsInN1cHBsdXMiOiLiq4AiLCJzdXBzZXQiOiLiioMiLCJTdXBzZXQiOiLii5EiLCJzdXBzZXRlcSI6IuKKhyIsInN1cHNldGVxcSI6IuKrhiIsInN1cHNldG5lcSI6IuKKiyIsInN1cHNldG5lcXEiOiLiq4wiLCJzdXBzaW0iOiLiq4giLCJzdXBzdWIiOiLiq5QiLCJzdXBzdXAiOiLiq5YiLCJzd2FyaGsiOiLipKYiLCJzd2FyciI6IuKGmSIsInN3QXJyIjoi4oeZIiwic3dhcnJvdyI6IuKGmSIsInN3bndhciI6IuKkqiIsInN6bGlnIjoiw58iLCJUYWIiOiJcXHQiLCJ0YXJnZXQiOiLijJYiLCJUYXUiOiLOpCIsInRhdSI6Is+EIiwidGJyayI6IuKOtCIsIlRjYXJvbiI6IsWkIiwidGNhcm9uIjoixaUiLCJUY2VkaWwiOiLFoiIsInRjZWRpbCI6IsWjIiwiVGN5Ijoi0KIiLCJ0Y3kiOiLRgiIsInRkb3QiOiLig5siLCJ0ZWxyZWMiOiLijJUiLCJUZnIiOiLwnZSXIiwidGZyIjoi8J2UsSIsInRoZXJlNCI6IuKItCIsInRoZXJlZm9yZSI6IuKItCIsIlRoZXJlZm9yZSI6IuKItCIsIlRoZXRhIjoizpgiLCJ0aGV0YSI6Is64IiwidGhldGFzeW0iOiLPkSIsInRoZXRhdiI6Is+RIiwidGhpY2thcHByb3giOiLiiYgiLCJ0aGlja3NpbSI6IuKIvCIsIlRoaWNrU3BhY2UiOiLigZ/igIoiLCJUaGluU3BhY2UiOiLigIkiLCJ0aGluc3AiOiLigIkiLCJ0aGthcCI6IuKJiCIsInRoa3NpbSI6IuKIvCIsIlRIT1JOIjoiw54iLCJ0aG9ybiI6IsO+IiwidGlsZGUiOiLLnCIsIlRpbGRlIjoi4oi8IiwiVGlsZGVFcXVhbCI6IuKJgyIsIlRpbGRlRnVsbEVxdWFsIjoi4omFIiwiVGlsZGVUaWxkZSI6IuKJiCIsInRpbWVzYmFyIjoi4qixIiwidGltZXNiIjoi4oqgIiwidGltZXMiOiLDlyIsInRpbWVzZCI6IuKosCIsInRpbnQiOiLiiK0iLCJ0b2VhIjoi4qSoIiwidG9wYm90Ijoi4oy2IiwidG9wY2lyIjoi4quxIiwidG9wIjoi4oqkIiwiVG9wZiI6IvCdlYsiLCJ0b3BmIjoi8J2VpSIsInRvcGZvcmsiOiLiq5oiLCJ0b3NhIjoi4qSpIiwidHByaW1lIjoi4oC0IiwidHJhZGUiOiLihKIiLCJUUkFERSI6IuKEoiIsInRyaWFuZ2xlIjoi4pa1IiwidHJpYW5nbGVkb3duIjoi4pa/IiwidHJpYW5nbGVsZWZ0Ijoi4peDIiwidHJpYW5nbGVsZWZ0ZXEiOiLiirQiLCJ0cmlhbmdsZXEiOiLiiZwiLCJ0cmlhbmdsZXJpZ2h0Ijoi4pa5IiwidHJpYW5nbGVyaWdodGVxIjoi4oq1IiwidHJpZG90Ijoi4pesIiwidHJpZSI6IuKJnCIsInRyaW1pbnVzIjoi4qi6IiwiVHJpcGxlRG90Ijoi4oObIiwidHJpcGx1cyI6IuKouSIsInRyaXNiIjoi4qeNIiwidHJpdGltZSI6IuKouyIsInRycGV6aXVtIjoi4o+iIiwiVHNjciI6IvCdkq8iLCJ0c2NyIjoi8J2TiSIsIlRTY3kiOiLQpiIsInRzY3kiOiLRhiIsIlRTSGN5Ijoi0IsiLCJ0c2hjeSI6ItGbIiwiVHN0cm9rIjoixaYiLCJ0c3Ryb2siOiLFpyIsInR3aXh0Ijoi4omsIiwidHdvaGVhZGxlZnRhcnJvdyI6IuKGniIsInR3b2hlYWRyaWdodGFycm93Ijoi4oagIiwiVWFjdXRlIjoiw5oiLCJ1YWN1dGUiOiLDuiIsInVhcnIiOiLihpEiLCJVYXJyIjoi4oafIiwidUFyciI6IuKHkSIsIlVhcnJvY2lyIjoi4qWJIiwiVWJyY3kiOiLQjiIsInVicmN5Ijoi0Z4iLCJVYnJldmUiOiLFrCIsInVicmV2ZSI6IsWtIiwiVWNpcmMiOiLDmyIsInVjaXJjIjoiw7siLCJVY3kiOiLQoyIsInVjeSI6ItGDIiwidWRhcnIiOiLih4UiLCJVZGJsYWMiOiLFsCIsInVkYmxhYyI6IsWxIiwidWRoYXIiOiLipa4iLCJ1ZmlzaHQiOiLipb4iLCJVZnIiOiLwnZSYIiwidWZyIjoi8J2UsiIsIlVncmF2ZSI6IsOZIiwidWdyYXZlIjoiw7kiLCJ1SGFyIjoi4qWjIiwidWhhcmwiOiLihr8iLCJ1aGFyciI6IuKGviIsInVoYmxrIjoi4paAIiwidWxjb3JuIjoi4oycIiwidWxjb3JuZXIiOiLijJwiLCJ1bGNyb3AiOiLijI8iLCJ1bHRyaSI6IuKXuCIsIlVtYWNyIjoixaoiLCJ1bWFjciI6IsWrIiwidW1sIjoiwqgiLCJVbmRlckJhciI6Il8iLCJVbmRlckJyYWNlIjoi4o+fIiwiVW5kZXJCcmFja2V0Ijoi4o61IiwiVW5kZXJQYXJlbnRoZXNpcyI6IuKPnSIsIlVuaW9uIjoi4ouDIiwiVW5pb25QbHVzIjoi4oqOIiwiVW9nb24iOiLFsiIsInVvZ29uIjoixbMiLCJVb3BmIjoi8J2VjCIsInVvcGYiOiLwnZWmIiwiVXBBcnJvd0JhciI6IuKkkiIsInVwYXJyb3ciOiLihpEiLCJVcEFycm93Ijoi4oaRIiwiVXBhcnJvdyI6IuKHkSIsIlVwQXJyb3dEb3duQXJyb3ciOiLih4UiLCJ1cGRvd25hcnJvdyI6IuKGlSIsIlVwRG93bkFycm93Ijoi4oaVIiwiVXBkb3duYXJyb3ciOiLih5UiLCJVcEVxdWlsaWJyaXVtIjoi4qWuIiwidXBoYXJwb29ubGVmdCI6IuKGvyIsInVwaGFycG9vbnJpZ2h0Ijoi4oa+IiwidXBsdXMiOiLiio4iLCJVcHBlckxlZnRBcnJvdyI6IuKGliIsIlVwcGVyUmlnaHRBcnJvdyI6IuKGlyIsInVwc2kiOiLPhSIsIlVwc2kiOiLPkiIsInVwc2loIjoiz5IiLCJVcHNpbG9uIjoizqUiLCJ1cHNpbG9uIjoiz4UiLCJVcFRlZUFycm93Ijoi4oalIiwiVXBUZWUiOiLiiqUiLCJ1cHVwYXJyb3dzIjoi4oeIIiwidXJjb3JuIjoi4oydIiwidXJjb3JuZXIiOiLijJ0iLCJ1cmNyb3AiOiLijI4iLCJVcmluZyI6IsWuIiwidXJpbmciOiLFryIsInVydHJpIjoi4pe5IiwiVXNjciI6IvCdkrAiLCJ1c2NyIjoi8J2TiiIsInV0ZG90Ijoi4ouwIiwiVXRpbGRlIjoixagiLCJ1dGlsZGUiOiLFqSIsInV0cmkiOiLilrUiLCJ1dHJpZiI6IuKWtCIsInV1YXJyIjoi4oeIIiwiVXVtbCI6IsOcIiwidXVtbCI6IsO8IiwidXdhbmdsZSI6IuKmpyIsInZhbmdydCI6IuKmnCIsInZhcmVwc2lsb24iOiLPtSIsInZhcmthcHBhIjoiz7AiLCJ2YXJub3RoaW5nIjoi4oiFIiwidmFycGhpIjoiz5UiLCJ2YXJwaSI6Is+WIiwidmFycHJvcHRvIjoi4oidIiwidmFyciI6IuKGlSIsInZBcnIiOiLih5UiLCJ2YXJyaG8iOiLPsSIsInZhcnNpZ21hIjoiz4IiLCJ2YXJzdWJzZXRuZXEiOiLiiorvuIAiLCJ2YXJzdWJzZXRuZXFxIjoi4quL77iAIiwidmFyc3Vwc2V0bmVxIjoi4oqL77iAIiwidmFyc3Vwc2V0bmVxcSI6IuKrjO+4gCIsInZhcnRoZXRhIjoiz5EiLCJ2YXJ0cmlhbmdsZWxlZnQiOiLiirIiLCJ2YXJ0cmlhbmdsZXJpZ2h0Ijoi4oqzIiwidkJhciI6IuKrqCIsIlZiYXIiOiLiq6siLCJ2QmFydiI6IuKrqSIsIlZjeSI6ItCSIiwidmN5Ijoi0LIiLCJ2ZGFzaCI6IuKKoiIsInZEYXNoIjoi4oqoIiwiVmRhc2giOiLiiqkiLCJWRGFzaCI6IuKKqyIsIlZkYXNobCI6IuKrpiIsInZlZWJhciI6IuKKuyIsInZlZSI6IuKIqCIsIlZlZSI6IuKLgSIsInZlZWVxIjoi4omaIiwidmVsbGlwIjoi4ouuIiwidmVyYmFyIjoifCIsIlZlcmJhciI6IuKAliIsInZlcnQiOiJ8IiwiVmVydCI6IuKAliIsIlZlcnRpY2FsQmFyIjoi4oijIiwiVmVydGljYWxMaW5lIjoifCIsIlZlcnRpY2FsU2VwYXJhdG9yIjoi4p2YIiwiVmVydGljYWxUaWxkZSI6IuKJgCIsIlZlcnlUaGluU3BhY2UiOiLigIoiLCJWZnIiOiLwnZSZIiwidmZyIjoi8J2UsyIsInZsdHJpIjoi4oqyIiwidm5zdWIiOiLiioLig5IiLCJ2bnN1cCI6IuKKg+KDkiIsIlZvcGYiOiLwnZWNIiwidm9wZiI6IvCdlaciLCJ2cHJvcCI6IuKInSIsInZydHJpIjoi4oqzIiwiVnNjciI6IvCdkrEiLCJ2c2NyIjoi8J2TiyIsInZzdWJuRSI6IuKri++4gCIsInZzdWJuZSI6IuKKiu+4gCIsInZzdXBuRSI6IuKrjO+4gCIsInZzdXBuZSI6IuKKi++4gCIsIlZ2ZGFzaCI6IuKKqiIsInZ6aWd6YWciOiLippoiLCJXY2lyYyI6IsW0Iiwid2NpcmMiOiLFtSIsIndlZGJhciI6IuKpnyIsIndlZGdlIjoi4oinIiwiV2VkZ2UiOiLii4AiLCJ3ZWRnZXEiOiLiiZkiLCJ3ZWllcnAiOiLihJgiLCJXZnIiOiLwnZSaIiwid2ZyIjoi8J2UtCIsIldvcGYiOiLwnZWOIiwid29wZiI6IvCdlagiLCJ3cCI6IuKEmCIsIndyIjoi4omAIiwid3JlYXRoIjoi4omAIiwiV3NjciI6IvCdkrIiLCJ3c2NyIjoi8J2TjCIsInhjYXAiOiLii4IiLCJ4Y2lyYyI6IuKXryIsInhjdXAiOiLii4MiLCJ4ZHRyaSI6IuKWvSIsIlhmciI6IvCdlJsiLCJ4ZnIiOiLwnZS1IiwieGhhcnIiOiLin7ciLCJ4aEFyciI6IuKfuiIsIlhpIjoizp4iLCJ4aSI6Is6+IiwieGxhcnIiOiLin7UiLCJ4bEFyciI6IuKfuCIsInhtYXAiOiLin7wiLCJ4bmlzIjoi4ou7IiwieG9kb3QiOiLiqIAiLCJYb3BmIjoi8J2VjyIsInhvcGYiOiLwnZWpIiwieG9wbHVzIjoi4qiBIiwieG90aW1lIjoi4qiCIiwieHJhcnIiOiLin7YiLCJ4ckFyciI6IuKfuSIsIlhzY3IiOiLwnZKzIiwieHNjciI6IvCdk40iLCJ4c3FjdXAiOiLiqIYiLCJ4dXBsdXMiOiLiqIQiLCJ4dXRyaSI6IuKWsyIsInh2ZWUiOiLii4EiLCJ4d2VkZ2UiOiLii4AiLCJZYWN1dGUiOiLDnSIsInlhY3V0ZSI6IsO9IiwiWUFjeSI6ItCvIiwieWFjeSI6ItGPIiwiWWNpcmMiOiLFtiIsInljaXJjIjoixbciLCJZY3kiOiLQqyIsInljeSI6ItGLIiwieWVuIjoiwqUiLCJZZnIiOiLwnZScIiwieWZyIjoi8J2UtiIsIllJY3kiOiLQhyIsInlpY3kiOiLRlyIsIllvcGYiOiLwnZWQIiwieW9wZiI6IvCdlaoiLCJZc2NyIjoi8J2StCIsInlzY3IiOiLwnZOOIiwiWVVjeSI6ItCuIiwieXVjeSI6ItGOIiwieXVtbCI6IsO/IiwiWXVtbCI6IsW4IiwiWmFjdXRlIjoixbkiLCJ6YWN1dGUiOiLFuiIsIlpjYXJvbiI6IsW9IiwiemNhcm9uIjoixb4iLCJaY3kiOiLQlyIsInpjeSI6ItC3IiwiWmRvdCI6IsW7IiwiemRvdCI6IsW8IiwiemVldHJmIjoi4oSoIiwiWmVyb1dpZHRoU3BhY2UiOiLigIsiLCJaZXRhIjoizpYiLCJ6ZXRhIjoizrYiLCJ6ZnIiOiLwnZS3IiwiWmZyIjoi4oSoIiwiWkhjeSI6ItCWIiwiemhjeSI6ItC2IiwiemlncmFyciI6IuKHnSIsInpvcGYiOiLwnZWrIiwiWm9wZiI6IuKEpCIsIlpzY3IiOiLwnZK1IiwienNjciI6IvCdk48iLCJ6d2oiOiLigI0iLCJ6d25qIjoi4oCMIn0nKX0sZnVuY3Rpb24oZyl7Zy5leHBvcnRzPUpTT04ucGFyc2UoJ3siQWFjdXRlIjoiw4EiLCJhYWN1dGUiOiLDoSIsIkFjaXJjIjoiw4IiLCJhY2lyYyI6IsOiIiwiYWN1dGUiOiLCtCIsIkFFbGlnIjoiw4YiLCJhZWxpZyI6IsOmIiwiQWdyYXZlIjoiw4AiLCJhZ3JhdmUiOiLDoCIsImFtcCI6IiYiLCJBTVAiOiImIiwiQXJpbmciOiLDhSIsImFyaW5nIjoiw6UiLCJBdGlsZGUiOiLDgyIsImF0aWxkZSI6IsOjIiwiQXVtbCI6IsOEIiwiYXVtbCI6IsOkIiwiYnJ2YmFyIjoiwqYiLCJDY2VkaWwiOiLDhyIsImNjZWRpbCI6IsOnIiwiY2VkaWwiOiLCuCIsImNlbnQiOiLCoiIsImNvcHkiOiLCqSIsIkNPUFkiOiLCqSIsImN1cnJlbiI6IsKkIiwiZGVnIjoiwrAiLCJkaXZpZGUiOiLDtyIsIkVhY3V0ZSI6IsOJIiwiZWFjdXRlIjoiw6kiLCJFY2lyYyI6IsOKIiwiZWNpcmMiOiLDqiIsIkVncmF2ZSI6IsOIIiwiZWdyYXZlIjoiw6giLCJFVEgiOiLDkCIsImV0aCI6IsOwIiwiRXVtbCI6IsOLIiwiZXVtbCI6IsOrIiwiZnJhYzEyIjoiwr0iLCJmcmFjMTQiOiLCvCIsImZyYWMzNCI6IsK+IiwiZ3QiOiI+IiwiR1QiOiI+IiwiSWFjdXRlIjoiw40iLCJpYWN1dGUiOiLDrSIsIkljaXJjIjoiw44iLCJpY2lyYyI6IsOuIiwiaWV4Y2wiOiLCoSIsIklncmF2ZSI6IsOMIiwiaWdyYXZlIjoiw6wiLCJpcXVlc3QiOiLCvyIsIkl1bWwiOiLDjyIsIml1bWwiOiLDryIsImxhcXVvIjoiwqsiLCJsdCI6IjwiLCJMVCI6IjwiLCJtYWNyIjoiwq8iLCJtaWNybyI6IsK1IiwibWlkZG90IjoiwrciLCJuYnNwIjoiwqAiLCJub3QiOiLCrCIsIk50aWxkZSI6IsORIiwibnRpbGRlIjoiw7EiLCJPYWN1dGUiOiLDkyIsIm9hY3V0ZSI6IsOzIiwiT2NpcmMiOiLDlCIsIm9jaXJjIjoiw7QiLCJPZ3JhdmUiOiLDkiIsIm9ncmF2ZSI6IsOyIiwib3JkZiI6IsKqIiwib3JkbSI6IsK6IiwiT3NsYXNoIjoiw5giLCJvc2xhc2giOiLDuCIsIk90aWxkZSI6IsOVIiwib3RpbGRlIjoiw7UiLCJPdW1sIjoiw5YiLCJvdW1sIjoiw7YiLCJwYXJhIjoiwrYiLCJwbHVzbW4iOiLCsSIsInBvdW5kIjoiwqMiLCJxdW90IjoiXFwiIiwiUVVPVCI6IlxcIiIsInJhcXVvIjoiwrsiLCJyZWciOiLCriIsIlJFRyI6IsKuIiwic2VjdCI6IsKnIiwic2h5Ijoiwq0iLCJzdXAxIjoiwrkiLCJzdXAyIjoiwrIiLCJzdXAzIjoiwrMiLCJzemxpZyI6IsOfIiwiVEhPUk4iOiLDniIsInRob3JuIjoiw74iLCJ0aW1lcyI6IsOXIiwiVWFjdXRlIjoiw5oiLCJ1YWN1dGUiOiLDuiIsIlVjaXJjIjoiw5siLCJ1Y2lyYyI6IsO7IiwiVWdyYXZlIjoiw5kiLCJ1Z3JhdmUiOiLDuSIsInVtbCI6IsKoIiwiVXVtbCI6IsOcIiwidXVtbCI6IsO8IiwiWWFjdXRlIjoiw50iLCJ5YWN1dGUiOiLDvSIsInllbiI6IsKlIiwieXVtbCI6IsO/In0nKX0sZnVuY3Rpb24oZyl7Zy5leHBvcnRzPUpTT04ucGFyc2UoYHsiYW1wIjoiJiIsImFwb3MiOiInIiwiZ3QiOiI+IiwibHQiOiI8IiwicXVvdCI6IlxcIiJ9YCl9LGZ1bmN0aW9uKGcsZSx0KXt2YXIgbj10aGlzJiZ0aGlzLl9faW1wb3J0RGVmYXVsdHx8ZnVuY3Rpb24oaCl7cmV0dXJuIGgmJmguX19lc01vZHVsZT9oOntkZWZhdWx0Omh9fTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSk7dmFyIGk9bih0KDI2NSkpO2Z1bmN0aW9uIGYoaCl7aWYoaD49NTUyOTYmJmg8PTU3MzQzfHxoPjExMTQxMTEpcmV0dXJuIu+/vSI7aCBpbiBpLmRlZmF1bHQmJihoPWkuZGVmYXVsdFtoXSk7dmFyIHU9IiI7cmV0dXJuIGg+NjU1MzUmJihoLT02NTUzNix1Kz1TdHJpbmcuZnJvbUNoYXJDb2RlKGg+Pj4xMCYxMDIzfDU1Mjk2KSxoPTU2MzIwfGgmMTAyMyksdSs9U3RyaW5nLmZyb21DaGFyQ29kZShoKSx1fWUuZGVmYXVsdD1mfSxmdW5jdGlvbihnKXtnLmV4cG9ydHM9SlNPTi5wYXJzZSgneyIwIjo2NTUzMywiMTI4Ijo4MzY0LCIxMzAiOjgyMTgsIjEzMSI6NDAyLCIxMzIiOjgyMjIsIjEzMyI6ODIzMCwiMTM0Ijo4MjI0LCIxMzUiOjgyMjUsIjEzNiI6NzEwLCIxMzciOjgyNDAsIjEzOCI6MzUyLCIxMzkiOjgyNDksIjE0MCI6MzM4LCIxNDIiOjM4MSwiMTQ1Ijo4MjE2LCIxNDYiOjgyMTcsIjE0NyI6ODIyMCwiMTQ4Ijo4MjIxLCIxNDkiOjgyMjYsIjE1MCI6ODIxMSwiMTUxIjo4MjEyLCIxNTIiOjczMiwiMTUzIjo4NDgyLCIxNTQiOjM1MywiMTU1Ijo4MjUwLCIxNTYiOjMzOSwiMTU4IjozODIsIjE1OSI6Mzc2fScpfSxmdW5jdGlvbihnLGUsdCl7dmFyIG49dGhpcyYmdGhpcy5fX2ltcG9ydERlZmF1bHR8fGZ1bmN0aW9uKFMpe3JldHVybiBTJiZTLl9fZXNNb2R1bGU/Uzp7ZGVmYXVsdDpTfX07T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLGUuZXNjYXBlPWUuZW5jb2RlSFRNTD1lLmVuY29kZVhNTD12b2lkIDA7dmFyIGk9bih0KDI2MykpLGY9RShpLmRlZmF1bHQpLGg9cChmKTtlLmVuY29kZVhNTD1iKGYsaCk7dmFyIHU9bih0KDI2MSkpLGE9RSh1LmRlZmF1bHQpLGQ9cChhKTtlLmVuY29kZUhUTUw9YihhLGQpO2Z1bmN0aW9uIEUoUyl7cmV0dXJuIE9iamVjdC5rZXlzKFMpLnNvcnQoKS5yZWR1Y2UoZnVuY3Rpb24ocyxjKXtyZXR1cm4gc1tTW2NdXT0iJiIrYysiOyIsc30se30pfWZ1bmN0aW9uIHAoUyl7Zm9yKHZhciBzPVtdLGM9W10sbD0wLHY9T2JqZWN0LmtleXMoUyk7bDx2Lmxlbmd0aDtsKyspe3ZhciBUPXZbbF07VC5sZW5ndGg9PT0xP3MucHVzaCgiXFwiK1QpOmMucHVzaChUKX1zLnNvcnQoKTtmb3IodmFyIFI9MDtSPHMubGVuZ3RoLTE7UisrKXtmb3IodmFyIEw9UjtMPHMubGVuZ3RoLTEmJnNbTF0uY2hhckNvZGVBdCgxKSsxPT09c1tMKzFdLmNoYXJDb2RlQXQoMSk7KUwrPTE7dmFyIE49MStMLVI7TjwzfHxzLnNwbGljZShSLE4sc1tSXSsiLSIrc1tMXSl9cmV0dXJuIGMudW5zaGlmdCgiWyIrcy5qb2luKCIiKSsiXSIpLG5ldyBSZWdFeHAoYy5qb2luKCJ8IiksImciKX12YXIgTz0vKD86W1x4ODAtXHVEN0ZGXHVFMDAwLVx1RkZGRl18W1x1RDgwMC1cdURCRkZdW1x1REMwMC1cdURGRkZdfFtcdUQ4MDAtXHVEQkZGXSg/IVtcdURDMDAtXHVERkZGXSl8KD86W15cdUQ4MDAtXHVEQkZGXXxeKVtcdURDMDAtXHVERkZGXSkvZztmdW5jdGlvbiBtKFMpe3JldHVybiImI3giK1MuY29kZVBvaW50QXQoMCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkrIjsifWZ1bmN0aW9uIGIoUyxzKXtyZXR1cm4gZnVuY3Rpb24oYyl7cmV0dXJuIGMucmVwbGFjZShzLGZ1bmN0aW9uKGwpe3JldHVybiBTW2xdfSkucmVwbGFjZShPLG0pfX12YXIgTT1wKGYpO2Z1bmN0aW9uIHkoUyl7cmV0dXJuIFMucmVwbGFjZShNLG0pLnJlcGxhY2UoTyxtKX1lLmVzY2FwZT15fSxmdW5jdGlvbihnKXtnLmV4cG9ydHM9SlNPTi5wYXJzZSgneyJlbGVtZW50TmFtZXMiOnsiYWx0Z2x5cGgiOiJhbHRHbHlwaCIsImFsdGdseXBoZGVmIjoiYWx0R2x5cGhEZWYiLCJhbHRnbHlwaGl0ZW0iOiJhbHRHbHlwaEl0ZW0iLCJhbmltYXRlY29sb3IiOiJhbmltYXRlQ29sb3IiLCJhbmltYXRlbW90aW9uIjoiYW5pbWF0ZU1vdGlvbiIsImFuaW1hdGV0cmFuc2Zvcm0iOiJhbmltYXRlVHJhbnNmb3JtIiwiY2xpcHBhdGgiOiJjbGlwUGF0aCIsImZlYmxlbmQiOiJmZUJsZW5kIiwiZmVjb2xvcm1hdHJpeCI6ImZlQ29sb3JNYXRyaXgiLCJmZWNvbXBvbmVudHRyYW5zZmVyIjoiZmVDb21wb25lbnRUcmFuc2ZlciIsImZlY29tcG9zaXRlIjoiZmVDb21wb3NpdGUiLCJmZWNvbnZvbHZlbWF0cml4IjoiZmVDb252b2x2ZU1hdHJpeCIsImZlZGlmZnVzZWxpZ2h0aW5nIjoiZmVEaWZmdXNlTGlnaHRpbmciLCJmZWRpc3BsYWNlbWVudG1hcCI6ImZlRGlzcGxhY2VtZW50TWFwIiwiZmVkaXN0YW50bGlnaHQiOiJmZURpc3RhbnRMaWdodCIsImZlZHJvcHNoYWRvdyI6ImZlRHJvcFNoYWRvdyIsImZlZmxvb2QiOiJmZUZsb29kIiwiZmVmdW5jYSI6ImZlRnVuY0EiLCJmZWZ1bmNiIjoiZmVGdW5jQiIsImZlZnVuY2ciOiJmZUZ1bmNHIiwiZmVmdW5jciI6ImZlRnVuY1IiLCJmZWdhdXNzaWFuYmx1ciI6ImZlR2F1c3NpYW5CbHVyIiwiZmVpbWFnZSI6ImZlSW1hZ2UiLCJmZW1lcmdlIjoiZmVNZXJnZSIsImZlbWVyZ2Vub2RlIjoiZmVNZXJnZU5vZGUiLCJmZW1vcnBob2xvZ3kiOiJmZU1vcnBob2xvZ3kiLCJmZW9mZnNldCI6ImZlT2Zmc2V0IiwiZmVwb2ludGxpZ2h0IjoiZmVQb2ludExpZ2h0IiwiZmVzcGVjdWxhcmxpZ2h0aW5nIjoiZmVTcGVjdWxhckxpZ2h0aW5nIiwiZmVzcG90bGlnaHQiOiJmZVNwb3RMaWdodCIsImZldGlsZSI6ImZlVGlsZSIsImZldHVyYnVsZW5jZSI6ImZlVHVyYnVsZW5jZSIsImZvcmVpZ25vYmplY3QiOiJmb3JlaWduT2JqZWN0IiwiZ2x5cGhyZWYiOiJnbHlwaFJlZiIsImxpbmVhcmdyYWRpZW50IjoibGluZWFyR3JhZGllbnQiLCJyYWRpYWxncmFkaWVudCI6InJhZGlhbEdyYWRpZW50IiwidGV4dHBhdGgiOiJ0ZXh0UGF0aCJ9LCJhdHRyaWJ1dGVOYW1lcyI6eyJkZWZpbml0aW9udXJsIjoiZGVmaW5pdGlvblVSTCIsImF0dHJpYnV0ZW5hbWUiOiJhdHRyaWJ1dGVOYW1lIiwiYXR0cmlidXRldHlwZSI6ImF0dHJpYnV0ZVR5cGUiLCJiYXNlZnJlcXVlbmN5IjoiYmFzZUZyZXF1ZW5jeSIsImJhc2Vwcm9maWxlIjoiYmFzZVByb2ZpbGUiLCJjYWxjbW9kZSI6ImNhbGNNb2RlIiwiY2xpcHBhdGh1bml0cyI6ImNsaXBQYXRoVW5pdHMiLCJkaWZmdXNlY29uc3RhbnQiOiJkaWZmdXNlQ29uc3RhbnQiLCJlZGdlbW9kZSI6ImVkZ2VNb2RlIiwiZmlsdGVydW5pdHMiOiJmaWx0ZXJVbml0cyIsImdseXBocmVmIjoiZ2x5cGhSZWYiLCJncmFkaWVudHRyYW5zZm9ybSI6ImdyYWRpZW50VHJhbnNmb3JtIiwiZ3JhZGllbnR1bml0cyI6ImdyYWRpZW50VW5pdHMiLCJrZXJuZWxtYXRyaXgiOiJrZXJuZWxNYXRyaXgiLCJrZXJuZWx1bml0bGVuZ3RoIjoia2VybmVsVW5pdExlbmd0aCIsImtleXBvaW50cyI6ImtleVBvaW50cyIsImtleXNwbGluZXMiOiJrZXlTcGxpbmVzIiwia2V5dGltZXMiOiJrZXlUaW1lcyIsImxlbmd0aGFkanVzdCI6Imxlbmd0aEFkanVzdCIsImxpbWl0aW5nY29uZWFuZ2xlIjoibGltaXRpbmdDb25lQW5nbGUiLCJtYXJrZXJoZWlnaHQiOiJtYXJrZXJIZWlnaHQiLCJtYXJrZXJ1bml0cyI6Im1hcmtlclVuaXRzIiwibWFya2Vyd2lkdGgiOiJtYXJrZXJXaWR0aCIsIm1hc2tjb250ZW50dW5pdHMiOiJtYXNrQ29udGVudFVuaXRzIiwibWFza3VuaXRzIjoibWFza1VuaXRzIiwibnVtb2N0YXZlcyI6Im51bU9jdGF2ZXMiLCJwYXRobGVuZ3RoIjoicGF0aExlbmd0aCIsInBhdHRlcm5jb250ZW50dW5pdHMiOiJwYXR0ZXJuQ29udGVudFVuaXRzIiwicGF0dGVybnRyYW5zZm9ybSI6InBhdHRlcm5UcmFuc2Zvcm0iLCJwYXR0ZXJudW5pdHMiOiJwYXR0ZXJuVW5pdHMiLCJwb2ludHNhdHgiOiJwb2ludHNBdFgiLCJwb2ludHNhdHkiOiJwb2ludHNBdFkiLCJwb2ludHNhdHoiOiJwb2ludHNBdFoiLCJwcmVzZXJ2ZWFscGhhIjoicHJlc2VydmVBbHBoYSIsInByZXNlcnZlYXNwZWN0cmF0aW8iOiJwcmVzZXJ2ZUFzcGVjdFJhdGlvIiwicHJpbWl0aXZldW5pdHMiOiJwcmltaXRpdmVVbml0cyIsInJlZngiOiJyZWZYIiwicmVmeSI6InJlZlkiLCJyZXBlYXRjb3VudCI6InJlcGVhdENvdW50IiwicmVwZWF0ZHVyIjoicmVwZWF0RHVyIiwicmVxdWlyZWRleHRlbnNpb25zIjoicmVxdWlyZWRFeHRlbnNpb25zIiwicmVxdWlyZWRmZWF0dXJlcyI6InJlcXVpcmVkRmVhdHVyZXMiLCJzcGVjdWxhcmNvbnN0YW50Ijoic3BlY3VsYXJDb25zdGFudCIsInNwZWN1bGFyZXhwb25lbnQiOiJzcGVjdWxhckV4cG9uZW50Iiwic3ByZWFkbWV0aG9kIjoic3ByZWFkTWV0aG9kIiwic3RhcnRvZmZzZXQiOiJzdGFydE9mZnNldCIsInN0ZGRldmlhdGlvbiI6InN0ZERldmlhdGlvbiIsInN0aXRjaHRpbGVzIjoic3RpdGNoVGlsZXMiLCJzdXJmYWNlc2NhbGUiOiJzdXJmYWNlU2NhbGUiLCJzeXN0ZW1sYW5ndWFnZSI6InN5c3RlbUxhbmd1YWdlIiwidGFibGV2YWx1ZXMiOiJ0YWJsZVZhbHVlcyIsInRhcmdldHgiOiJ0YXJnZXRYIiwidGFyZ2V0eSI6InRhcmdldFkiLCJ0ZXh0bGVuZ3RoIjoidGV4dExlbmd0aCIsInZpZXdib3giOiJ2aWV3Qm94Iiwidmlld3RhcmdldCI6InZpZXdUYXJnZXQiLCJ4Y2hhbm5lbHNlbGVjdG9yIjoieENoYW5uZWxTZWxlY3RvciIsInljaGFubmVsc2VsZWN0b3IiOiJ5Q2hhbm5lbFNlbGVjdG9yIiwiem9vbWFuZHBhbiI6Inpvb21BbmRQYW4ifX0nKX0sZnVuY3Rpb24oZyxlKXt2YXIgdD1lLmdldENoaWxkcmVuPWZ1bmN0aW9uKGkpe3JldHVybiBpLmNoaWxkcmVufSxuPWUuZ2V0UGFyZW50PWZ1bmN0aW9uKGkpe3JldHVybiBpLnBhcmVudH07ZS5nZXRTaWJsaW5ncz1mdW5jdGlvbihpKXt2YXIgZj1uKGkpO3JldHVybiBmP3QoZik6W2ldfSxlLmdldEF0dHJpYnV0ZVZhbHVlPWZ1bmN0aW9uKGksZil7cmV0dXJuIGkuYXR0cmlicyYmaS5hdHRyaWJzW2ZdfSxlLmhhc0F0dHJpYj1mdW5jdGlvbihpLGYpe3JldHVybiEhaS5hdHRyaWJzJiZoYXNPd25Qcm9wZXJ0eS5jYWxsKGkuYXR0cmlicyxmKX0sZS5nZXROYW1lPWZ1bmN0aW9uKGkpe3JldHVybiBpLm5hbWV9fSxmdW5jdGlvbihnLGUpe2UucmVtb3ZlRWxlbWVudD1mdW5jdGlvbih0KXtpZih0LnByZXYmJih0LnByZXYubmV4dD10Lm5leHQpLHQubmV4dCYmKHQubmV4dC5wcmV2PXQucHJldiksdC5wYXJlbnQpe3ZhciBuPXQucGFyZW50LmNoaWxkcmVuO24uc3BsaWNlKG4ubGFzdEluZGV4T2YodCksMSl9fSxlLnJlcGxhY2VFbGVtZW50PWZ1bmN0aW9uKHQsbil7dmFyIGk9bi5wcmV2PXQucHJldjtpJiYoaS5uZXh0PW4pO3ZhciBmPW4ubmV4dD10Lm5leHQ7ZiYmKGYucHJldj1uKTt2YXIgaD1uLnBhcmVudD10LnBhcmVudDtpZihoKXt2YXIgdT1oLmNoaWxkcmVuO3VbdS5sYXN0SW5kZXhPZih0KV09bn19LGUuYXBwZW5kQ2hpbGQ9ZnVuY3Rpb24odCxuKXtpZihuLnBhcmVudD10LHQuY2hpbGRyZW4ucHVzaChuKSE9PTEpe3ZhciBpPXQuY2hpbGRyZW5bdC5jaGlsZHJlbi5sZW5ndGgtMl07aS5uZXh0PW4sbi5wcmV2PWksbi5uZXh0PW51bGx9fSxlLmFwcGVuZD1mdW5jdGlvbih0LG4pe3ZhciBpPXQucGFyZW50LGY9dC5uZXh0O2lmKG4ubmV4dD1mLG4ucHJldj10LHQubmV4dD1uLG4ucGFyZW50PWksZil7aWYoZi5wcmV2PW4saSl7dmFyIGg9aS5jaGlsZHJlbjtoLnNwbGljZShoLmxhc3RJbmRleE9mKGYpLDAsbil9fWVsc2UgaSYmaS5jaGlsZHJlbi5wdXNoKG4pfSxlLnByZXBlbmQ9ZnVuY3Rpb24odCxuKXt2YXIgaT10LnBhcmVudDtpZihpKXt2YXIgZj1pLmNoaWxkcmVuO2Yuc3BsaWNlKGYubGFzdEluZGV4T2YodCksMCxuKX10LnByZXYmJih0LnByZXYubmV4dD1uKSxuLnBhcmVudD1pLG4ucHJldj10LnByZXYsbi5uZXh0PXQsdC5wcmV2PW59fSxmdW5jdGlvbihnLGUsdCl7dmFyIG49dCgyNTYpLmlzVGFnO2cuZXhwb3J0cz17ZmlsdGVyOmksZmluZDpmLGZpbmRPbmVDaGlsZDpoLGZpbmRPbmU6dSxleGlzdHNPbmU6YSxmaW5kQWxsOmR9O2Z1bmN0aW9uIGkoRSxwLE8sbSl7cmV0dXJuIEFycmF5LmlzQXJyYXkocCl8fChwPVtwXSksKHR5cGVvZiBtIT0ibnVtYmVyInx8IWlzRmluaXRlKG0pKSYmKG09MS8wKSxmKEUscCxPIT09ITEsbSl9ZnVuY3Rpb24gZihFLHAsTyxtKXtmb3IodmFyIGI9W10sTSx5PTAsUz1wLmxlbmd0aDt5PFMmJiEoRShwW3ldKSYmKGIucHVzaChwW3ldKSwtLW08PTApfHwoTT1wW3ldLmNoaWxkcmVuLE8mJk0mJk0ubGVuZ3RoPjAmJihNPWYoRSxNLE8sbSksYj1iLmNvbmNhdChNKSxtLT1NLmxlbmd0aCxtPD0wKSkpO3krKyk7cmV0dXJuIGJ9ZnVuY3Rpb24gaChFLHApe2Zvcih2YXIgTz0wLG09cC5sZW5ndGg7TzxtO08rKylpZihFKHBbT10pKXJldHVybiBwW09dO3JldHVybiBudWxsfWZ1bmN0aW9uIHUoRSxwKXtmb3IodmFyIE89bnVsbCxtPTAsYj1wLmxlbmd0aDttPGImJiFPO20rKylpZihuKHBbbV0pKUUocFttXSk/Tz1wW21dOnBbbV0uY2hpbGRyZW4ubGVuZ3RoPjAmJihPPXUoRSxwW21dLmNoaWxkcmVuKSk7ZWxzZSBjb250aW51ZTtyZXR1cm4gT31mdW5jdGlvbiBhKEUscCl7Zm9yKHZhciBPPTAsbT1wLmxlbmd0aDtPPG07TysrKWlmKG4ocFtPXSkmJihFKHBbT10pfHxwW09dLmNoaWxkcmVuLmxlbmd0aD4wJiZhKEUscFtPXS5jaGlsZHJlbikpKXJldHVybiEwO3JldHVybiExfWZ1bmN0aW9uIGQoRSxwKXtmb3IodmFyIE89W10sbT1wLnNsaWNlKCk7bS5sZW5ndGg7KXt2YXIgYj1tLnNoaWZ0KCk7bihiKSYmKGIuY2hpbGRyZW4mJmIuY2hpbGRyZW4ubGVuZ3RoPjAmJm0udW5zaGlmdC5hcHBseShtLGIuY2hpbGRyZW4pLEUoYikmJk8ucHVzaChiKSl9cmV0dXJuIE99fSxmdW5jdGlvbihnLGUsdCl7dmFyIG49dCgyNTYpLGk9ZS5pc1RhZz1uLmlzVGFnO2UudGVzdEVsZW1lbnQ9ZnVuY3Rpb24oYSxkKXtmb3IodmFyIEUgaW4gYSlpZihhLmhhc093blByb3BlcnR5KEUpKXtpZihFPT09InRhZ19uYW1lIil7aWYoIWkoZCl8fCFhLnRhZ19uYW1lKGQubmFtZSkpcmV0dXJuITF9ZWxzZSBpZihFPT09InRhZ190eXBlIil7aWYoIWEudGFnX3R5cGUoZC50eXBlKSlyZXR1cm4hMX1lbHNlIGlmKEU9PT0idGFnX2NvbnRhaW5zIil7aWYoaShkKXx8IWEudGFnX2NvbnRhaW5zKGQuZGF0YSkpcmV0dXJuITF9ZWxzZSBpZighZC5hdHRyaWJzfHwhYVtFXShkLmF0dHJpYnNbRV0pKXJldHVybiExfXJldHVybiEwfTt2YXIgZj17dGFnX25hbWU6ZnVuY3Rpb24oYSl7cmV0dXJuIHR5cGVvZiBhPT0iZnVuY3Rpb24iP2Z1bmN0aW9uKGQpe3JldHVybiBpKGQpJiZhKGQubmFtZSl9OmE9PT0iKiI/aTpmdW5jdGlvbihkKXtyZXR1cm4gaShkKSYmZC5uYW1lPT09YX19LHRhZ190eXBlOmZ1bmN0aW9uKGEpe3JldHVybiB0eXBlb2YgYT09ImZ1bmN0aW9uIj9mdW5jdGlvbihkKXtyZXR1cm4gYShkLnR5cGUpfTpmdW5jdGlvbihkKXtyZXR1cm4gZC50eXBlPT09YX19LHRhZ19jb250YWluczpmdW5jdGlvbihhKXtyZXR1cm4gdHlwZW9mIGE9PSJmdW5jdGlvbiI/ZnVuY3Rpb24oZCl7cmV0dXJuIWkoZCkmJmEoZC5kYXRhKX06ZnVuY3Rpb24oZCl7cmV0dXJuIWkoZCkmJmQuZGF0YT09PWF9fX07ZnVuY3Rpb24gaChhLGQpe3JldHVybiB0eXBlb2YgZD09ImZ1bmN0aW9uIj9mdW5jdGlvbihFKXtyZXR1cm4gRS5hdHRyaWJzJiZkKEUuYXR0cmlic1thXSl9OmZ1bmN0aW9uKEUpe3JldHVybiBFLmF0dHJpYnMmJkUuYXR0cmlic1thXT09PWR9fWZ1bmN0aW9uIHUoYSxkKXtyZXR1cm4gZnVuY3Rpb24oRSl7cmV0dXJuIGEoRSl8fGQoRSl9fWUuZ2V0RWxlbWVudHM9ZnVuY3Rpb24oYSxkLEUscCl7dmFyIE89T2JqZWN0LmtleXMoYSkubWFwKGZ1bmN0aW9uKG0pe3ZhciBiPWFbbV07cmV0dXJuIG0gaW4gZj9mW21dKGIpOmgobSxiKX0pO3JldHVybiBPLmxlbmd0aD09PTA/W106dGhpcy5maWx0ZXIoTy5yZWR1Y2UodSksZCxFLHApfSxlLmdldEVsZW1lbnRCeUlkPWZ1bmN0aW9uKGEsZCxFKXtyZXR1cm4gQXJyYXkuaXNBcnJheShkKXx8KGQ9W2RdKSx0aGlzLmZpbmRPbmUoaCgiaWQiLGEpLGQsRSE9PSExKX0sZS5nZXRFbGVtZW50c0J5VGFnTmFtZT1mdW5jdGlvbihhLGQsRSxwKXtyZXR1cm4gdGhpcy5maWx0ZXIoZi50YWdfbmFtZShhKSxkLEUscCl9LGUuZ2V0RWxlbWVudHNCeVRhZ1R5cGU9ZnVuY3Rpb24oYSxkLEUscCl7cmV0dXJuIHRoaXMuZmlsdGVyKGYudGFnX3R5cGUoYSksZCxFLHApfX0sZnVuY3Rpb24oZyxlKXtlLnJlbW92ZVN1YnNldHM9ZnVuY3Rpb24oaSl7Zm9yKHZhciBmPWkubGVuZ3RoLGgsdSxhOy0tZj4tMTspe2ZvcihoPXU9aVtmXSxpW2ZdPW51bGwsYT0hMDt1Oyl7aWYoaS5pbmRleE9mKHUpPi0xKXthPSExLGkuc3BsaWNlKGYsMSk7YnJlYWt9dT11LnBhcmVudH1hJiYoaVtmXT1oKX1yZXR1cm4gaX07dmFyIHQ9e0RJU0NPTk5FQ1RFRDoxLFBSRUNFRElORzoyLEZPTExPV0lORzo0LENPTlRBSU5TOjgsQ09OVEFJTkVEX0JZOjE2fSxuPWUuY29tcGFyZURvY3VtZW50UG9zaXRpb249ZnVuY3Rpb24oaSxmKXt2YXIgaD1bXSx1PVtdLGEsZCxFLHAsTyxtO2lmKGk9PT1mKXJldHVybiAwO2ZvcihhPWk7YTspaC51bnNoaWZ0KGEpLGE9YS5wYXJlbnQ7Zm9yKGE9ZjthOyl1LnVuc2hpZnQoYSksYT1hLnBhcmVudDtmb3IobT0wO2hbbV09PT11W21dOyltKys7cmV0dXJuIG09PT0wP3QuRElTQ09OTkVDVEVEOihkPWhbbS0xXSxFPWQuY2hpbGRyZW4scD1oW21dLE89dVttXSxFLmluZGV4T2YocCk+RS5pbmRleE9mKE8pP2Q9PT1mP3QuRk9MTE9XSU5HfHQuQ09OVEFJTkVEX0JZOnQuRk9MTE9XSU5HOmQ9PT1pP3QuUFJFQ0VESU5HfHQuQ09OVEFJTlM6dC5QUkVDRURJTkcpfTtlLnVuaXF1ZVNvcnQ9ZnVuY3Rpb24oaSl7dmFyIGY9aS5sZW5ndGgsaCx1O2ZvcihpPWkuc2xpY2UoKTstLWY+LTE7KWg9aVtmXSx1PWkuaW5kZXhPZihoKSx1Pi0xJiZ1PGYmJmkuc3BsaWNlKGYsMSk7cmV0dXJuIGkuc29ydChmdW5jdGlvbihhLGQpe3ZhciBFPW4oYSxkKTtyZXR1cm4gRSZ0LlBSRUNFRElORz8tMTpFJnQuRk9MTE9XSU5HPzE6MH0pLGl9fSxmdW5jdGlvbihnLGUpe2cuZXhwb3J0cz17dHJ1ZUZ1bmM6ZnVuY3Rpb24oKXtyZXR1cm4hMH0sZmFsc2VGdW5jOmZ1bmN0aW9uKCl7cmV0dXJuITF9fX0sZnVuY3Rpb24oZyxlLHQpe2cuZXhwb3J0cz1PO3ZhciBuPXQoMjc1KS5wYXJzZSxpPXQoMjczKSxmPXQoMjc4KSxoPXQoMjc5KSx1PXQoMjgwKSxhPXQoMjgyKSxkPWkudHJ1ZUZ1bmMsRT1pLmZhbHNlRnVuYyxwPWEuZmlsdGVycztmdW5jdGlvbiBPKEEsdyxCKXt2YXIgRD1iKEEsdyxCKTtyZXR1cm4gbShELHcpfWZ1bmN0aW9uIG0oQSx3KXt2YXIgQj13LmFkYXB0ZXI7cmV0dXJuIGZ1bmN0aW9uKEkpe3JldHVybiBCLmlzVGFnKEkpJiZBKEkpfX1mdW5jdGlvbiBiKEEsdyxCKXt2YXIgRD1uKEEsdyk7cmV0dXJuIHYoRCx3LEIpfWZ1bmN0aW9uIE0oQSl7cmV0dXJuIEEudHlwZT09PSJwc2V1ZG8iJiYoQS5uYW1lPT09InNjb3BlInx8QXJyYXkuaXNBcnJheShBLmRhdGEpJiZBLmRhdGEuc29tZShmdW5jdGlvbih3KXtyZXR1cm4gdy5zb21lKE0pfSkpfXZhciB5PXt0eXBlOiJkZXNjZW5kYW50In0sUz17dHlwZToiX2ZsZXhpYmxlRGVzY2VuZGFudCJ9LHM9e3R5cGU6InBzZXVkbyIsbmFtZToic2NvcGUifSxjPXt9O2Z1bmN0aW9uIGwoQSx3LEIpe3ZhciBEPXcuYWRhcHRlcixJPSEhQiYmISFCLmxlbmd0aCYmQi5ldmVyeShmdW5jdGlvbihqKXtyZXR1cm4gaj09PWN8fCEhRC5nZXRQYXJlbnQoail9KTtBLmZvckVhY2goZnVuY3Rpb24oail7aWYoIShqLmxlbmd0aD4wJiZUKGpbMF0pJiZqWzBdLnR5cGUhPT0iZGVzY2VuZGFudCIpKWlmKEkmJiEoQXJyYXkuaXNBcnJheShqKT9qLnNvbWUoTSk6TShqKSkpai51bnNoaWZ0KHkpO2Vsc2UgcmV0dXJuO2oudW5zaGlmdChzKX0pfWZ1bmN0aW9uIHYoQSx3LEIpe0E9QS5maWx0ZXIoZnVuY3Rpb24oVil7cmV0dXJuIFYubGVuZ3RoPjB9KSxBLmZvckVhY2goZik7dmFyIEQ9QXJyYXkuaXNBcnJheShCKTtCPXcmJncuY29udGV4dHx8QixCJiYhRCYmKEI9W0JdKSxsKEEsdyxCKTt2YXIgST0hMSxqPUEubWFwKGZ1bmN0aW9uKFYpe2lmKFZbMF0mJlZbMV0mJlZbMF0ubmFtZT09PSJzY29wZSIpe3ZhciBKPVZbMV0udHlwZTtEJiZKPT09ImRlc2NlbmRhbnQiP1ZbMV09UzooSj09PSJhZGphY2VudCJ8fEo9PT0ic2libGluZyIpJiYoST0hMCl9cmV0dXJuIFIoVix3LEIpfSkucmVkdWNlKEwsRSk7cmV0dXJuIGouc2hvdWxkVGVzdE5leHRTaWJsaW5ncz1JLGp9ZnVuY3Rpb24gVChBKXtyZXR1cm4gaFtBLnR5cGVdPDB9ZnVuY3Rpb24gUihBLHcsQil7cmV0dXJuIEEucmVkdWNlKGZ1bmN0aW9uKEQsSSl7aWYoRD09PUUpcmV0dXJuIEQ7aWYoIShJLnR5cGUgaW4gdSkpdGhyb3cgbmV3IEVycm9yKCJSdWxlIHR5cGUgIitJLnR5cGUrIiBpcyBub3Qgc3VwcG9ydGVkIGJ5IGNzcy1zZWxlY3QiKTtyZXR1cm4gdVtJLnR5cGVdKEQsSSx3LEIpfSx3JiZ3LnJvb3RGdW5jfHxkKX1mdW5jdGlvbiBMKEEsdyl7cmV0dXJuIHc9PT1FfHxBPT09ZD9BOkE9PT1FfHx3PT09ZD93OmZ1bmN0aW9uKEQpe3JldHVybiBBKEQpfHx3KEQpfX1mdW5jdGlvbiBOKEEpe3JldHVybiBBLnNvbWUoVCl9cC5ub3Q9ZnVuY3Rpb24oQSx3LEIsRCl7dmFyIEk9e3htbE1vZGU6ISEoQiYmQi54bWxNb2RlKSxzdHJpY3Q6ISEoQiYmQi5zdHJpY3QpLGFkYXB0ZXI6Qi5hZGFwdGVyfTtpZihJLnN0cmljdCYmKHcubGVuZ3RoPjF8fHcuc29tZShOKSkpdGhyb3cgbmV3IEVycm9yKCJjb21wbGV4IHNlbGVjdG9ycyBpbiA6bm90IGFyZW4ndCBhbGxvd2VkIGluIHN0cmljdCBtb2RlIik7dmFyIGo9dih3LEksRCk7cmV0dXJuIGo9PT1FP0E6aj09PWQ/RTpmdW5jdGlvbihKKXtyZXR1cm4haihKKSYmQShKKX19LHAuaGFzPWZ1bmN0aW9uKEEsdyxCKXt2YXIgRD1CLmFkYXB0ZXIsST17eG1sTW9kZTohIShCJiZCLnhtbE1vZGUpLHN0cmljdDohIShCJiZCLnN0cmljdCksYWRhcHRlcjpEfSxqPXcuc29tZShOKT9bY106bnVsbCxWPXYodyxJLGopO3JldHVybiBWPT09RT9FOlY9PT1kP2Z1bmN0aW9uKF8pe3JldHVybiBELmdldENoaWxkcmVuKF8pLnNvbWUoRC5pc1RhZykmJkEoXyl9OihWPW0oVixCKSxqP2Z1bmN0aW9uKF8pe3JldHVybiBBKF8pJiYoalswXT1fLEQuZXhpc3RzT25lKFYsRC5nZXRDaGlsZHJlbihfKSkpfTpmdW5jdGlvbihfKXtyZXR1cm4gQShfKSYmRC5leGlzdHNPbmUoVixELmdldENoaWxkcmVuKF8pKX0pfSxwLm1hdGNoZXM9ZnVuY3Rpb24oQSx3LEIsRCl7dmFyIEk9e3htbE1vZGU6ISEoQiYmQi54bWxNb2RlKSxzdHJpY3Q6ISEoQiYmQi5zdHJpY3QpLHJvb3RGdW5jOkEsYWRhcHRlcjpCLmFkYXB0ZXJ9O3JldHVybiB2KHcsSSxEKX0sTy5jb21waWxlVG9rZW49dixPLmNvbXBpbGVVbnNhZmU9YixPLlBzZXVkb3M9YX0sZnVuY3Rpb24oZyxlLHQpe3ZhciBuPXRoaXMmJnRoaXMuX19jcmVhdGVCaW5kaW5nfHwoT2JqZWN0LmNyZWF0ZT9mdW5jdGlvbih1LGEsZCxFKXtFPT09dm9pZCAwJiYoRT1kKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodSxFLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBhW2RdfX0pfTpmdW5jdGlvbih1LGEsZCxFKXtFPT09dm9pZCAwJiYoRT1kKSx1W0VdPWFbZF19KSxpPXRoaXMmJnRoaXMuX19leHBvcnRTdGFyfHxmdW5jdGlvbih1LGEpe2Zvcih2YXIgZCBpbiB1KWQhPT0iZGVmYXVsdCImJiFhLmhhc093blByb3BlcnR5KGQpJiZuKGEsdSxkKX07T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLGkodCgyNzYpLGUpO3ZhciBmPXQoMjc2KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwicGFyc2UiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBmLmRlZmF1bHR9fSk7dmFyIGg9dCgyNzcpO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJzdHJpbmdpZnkiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBoLmRlZmF1bHR9fSl9LGZ1bmN0aW9uKGcsZSx0KXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksZS5kZWZhdWx0PU07dmFyIG49L15bXlxcXT8oPzpcXCg/OltcZGEtZl17MSw2fVxzP3wuKXxbXHdcLVx1MDBiMC1cdUZGRkZdKSsvLGk9L1xcKFtcZGEtZl17MSw2fVxzP3woXHMpfC4pL2dpLGY9L15ccyooKD86XFwufFtcd1x1MDBiMC1cdUZGRkYtXSkrKVxzKig/OihcUz8pPVxzKig/OihbJyJdKShbXl0qPylcM3woIz8oPzpcXC58W1x3XHUwMGIwLVx1RkZGRi1dKSopfCl8KVxzKihpKT9cXS8saD17dW5kZWZpbmVkOiJleGlzdHMiLCIiOiJlcXVhbHMiLCJ+IjoiZWxlbWVudCIsIl4iOiJzdGFydCIsJDoiZW5kIiwiKiI6ImFueSIsIiEiOiJub3QiLCJ8IjoiaHlwaGVuIn0sdT17Ij4iOiJjaGlsZCIsIjwiOiJwYXJlbnQiLCJ+Ijoic2libGluZyIsIisiOiJhZGphY2VudCJ9LGE9eyIjIjpbImlkIiwiZXF1YWxzIl0sIi4iOlsiY2xhc3MiLCJlbGVtZW50Il19LGQ9bmV3IFNldChbImhhcyIsIm5vdCIsIm1hdGNoZXMiXSksRT1uZXcgU2V0KFsiY29udGFpbnMiLCJpY29udGFpbnMiXSkscD1uZXcgU2V0KFsnIicsIiciXSk7ZnVuY3Rpb24gTyhzLGMsbCl7dmFyIHY9cGFyc2VJbnQoYywxNiktNjU1MzY7cmV0dXJuIHYhPT12fHxsP2M6djwwP1N0cmluZy5mcm9tQ2hhckNvZGUodis2NTUzNik6U3RyaW5nLmZyb21DaGFyQ29kZSh2Pj4xMHw1NTI5Nix2JjEwMjN8NTYzMjApfWZ1bmN0aW9uIG0ocyl7cmV0dXJuIHMucmVwbGFjZShpLE8pfWZ1bmN0aW9uIGIocyl7cmV0dXJuIHM9PT0iICJ8fHM9PT1gCmB8fHM9PT0iCSJ8fHM9PT0iXGYifHxzPT09IlxyIn1mdW5jdGlvbiBNKHMsYyl7dmFyIGw9W107aWYocz15KGwsIiIrcyxjKSxzIT09IiIpdGhyb3cgbmV3IEVycm9yKCJVbm1hdGNoZWQgc2VsZWN0b3I6ICIrcyk7cmV0dXJuIGx9ZnVuY3Rpb24geShzLGMsbCl7dmFyIHY9W10sVD0hMTtmdW5jdGlvbiBSKCl7dmFyIHJ0PWMubWF0Y2gobik7aWYoIXJ0KXRocm93IG5ldyBFcnJvcigiRXhwZWN0ZWQgbmFtZSwgZm91bmQgIitjKTt2YXIgb3Q9cnRbMF07cmV0dXJuIGM9Yy5zdWJzdHIob3QubGVuZ3RoKSxtKG90KX1mdW5jdGlvbiBMKHJ0KXtmb3IoO2IoYy5jaGFyQXQocnQpKTspcnQrKztjPWMuc3Vic3RyKHJ0KX1mdW5jdGlvbiBOKHJ0KXtmb3IodmFyIG90PTA7Yy5jaGFyQXQoLS1ydCk9PT0iXFwiOylvdCsrO3JldHVybihvdCYxKT09PTF9Zm9yKEwoMCk7YyE9PSIiOyl7dmFyIEE9Yy5jaGFyQXQoMCk7aWYoYihBKSlUPSEwLEwoMSk7ZWxzZSBpZihBIGluIHUpdi5wdXNoKHt0eXBlOnVbQV19KSxUPSExLEwoMSk7ZWxzZSBpZihBPT09IiwiKXtpZih2Lmxlbmd0aD09PTApdGhyb3cgbmV3IEVycm9yKCJFbXB0eSBzdWItc2VsZWN0b3IiKTtzLnB1c2godiksdj1bXSxUPSExLEwoMSl9ZWxzZSBpZihUJiYodi5sZW5ndGg+MCYmdi5wdXNoKHt0eXBlOiJkZXNjZW5kYW50In0pLFQ9ITEpLEE9PT0iKiIpYz1jLnN1YnN0cigxKSx2LnB1c2goe3R5cGU6InVuaXZlcnNhbCJ9KTtlbHNlIGlmKEEgaW4gYSl7dmFyIHc9YVtBXSxCPXdbMF0sRD13WzFdO2M9Yy5zdWJzdHIoMSksdi5wdXNoKHt0eXBlOiJhdHRyaWJ1dGUiLG5hbWU6QixhY3Rpb246RCx2YWx1ZTpSKCksaWdub3JlQ2FzZTohMX0pfWVsc2UgaWYoQT09PSJbIil7Yz1jLnN1YnN0cigxKTt2YXIgST1jLm1hdGNoKGYpO2lmKCFJKXRocm93IG5ldyBFcnJvcigiTWFsZm9ybWVkIGF0dHJpYnV0ZSBzZWxlY3RvcjogIitjKTtjPWMuc3Vic3RyKElbMF0ubGVuZ3RoKTt2YXIgaj1tKElbMV0pOyghbHx8KCJsb3dlckNhc2VBdHRyaWJ1dGVOYW1lcyJpbiBsP2wubG93ZXJDYXNlQXR0cmlidXRlTmFtZXM6IWwueG1sTW9kZSkpJiYoaj1qLnRvTG93ZXJDYXNlKCkpLHYucHVzaCh7dHlwZToiYXR0cmlidXRlIixuYW1lOmosYWN0aW9uOmhbSVsyXV0sdmFsdWU6bShJWzRdfHxJWzVdfHwiIiksaWdub3JlQ2FzZTohIUlbNl19KX1lbHNlIGlmKEE9PT0iOiIpe2lmKGMuY2hhckF0KDEpPT09IjoiKXtjPWMuc3Vic3RyKDIpLHYucHVzaCh7dHlwZToicHNldWRvLWVsZW1lbnQiLG5hbWU6UigpLnRvTG93ZXJDYXNlKCl9KTtjb250aW51ZX1jPWMuc3Vic3RyKDEpO3ZhciBWPVIoKS50b0xvd2VyQ2FzZSgpLEk9bnVsbDtpZihjLmNoYXJBdCgwKT09PSIoIilpZihkLmhhcyhWKSl7dmFyIEo9Yy5jaGFyQXQoMSksXz1wLmhhcyhKKTtpZihjPWMuc3Vic3RyKF8/MjoxKSxJPVtdLGM9eShJLGMsbCksXyl7aWYoYy5jaGFyQXQoMCkhPT1KKXRocm93IG5ldyBFcnJvcigiVW5tYXRjaGVkIHF1b3RlcyBpbiA6IitWKTtjPWMuc3Vic3RyKDEpfWlmKGMuY2hhckF0KDApIT09IikiKXRocm93IG5ldyBFcnJvcigiTWlzc2luZyBjbG9zaW5nIHBhcmVudGhlc2lzIGluIDoiK1YrIiAoIitjKyIpIik7Yz1jLnN1YnN0cigxKX1lbHNle2Zvcih2YXIgc3Q9MSxHPTE7Rz4wJiZzdDxjLmxlbmd0aDtzdCsrKWMuY2hhckF0KHN0KT09PSIoIiYmIU4oc3QpP0crKzpjLmNoYXJBdChzdCk9PT0iKSImJiFOKHN0KSYmRy0tO2lmKEcpdGhyb3cgbmV3IEVycm9yKCJQYXJlbnRoZXNpcyBub3QgbWF0Y2hlZCIpO2lmKEk9Yy5zdWJzdHIoMSxzdC0yKSxjPWMuc3Vic3RyKHN0KSxFLmhhcyhWKSl7dmFyIEo9SS5jaGFyQXQoMCk7Sj09PUkuc2xpY2UoLTEpJiZwLmhhcyhKKSYmKEk9SS5zbGljZSgxLC0xKSksST1tKEkpfX12LnB1c2goe3R5cGU6InBzZXVkbyIsbmFtZTpWLGRhdGE6SX0pfWVsc2UgaWYobi50ZXN0KGMpKXt2YXIgWT1SKCk7KCFsfHwoImxvd2VyQ2FzZVRhZ3MiaW4gbD9sLmxvd2VyQ2FzZVRhZ3M6IWwueG1sTW9kZSkpJiYoWT1ZLnRvTG93ZXJDYXNlKCkpLHYucHVzaCh7dHlwZToidGFnIixuYW1lOll9KX1lbHNlIHJldHVybiB2Lmxlbmd0aCYmdlt2Lmxlbmd0aC0xXS50eXBlPT09ImRlc2NlbmRhbnQiJiZ2LnBvcCgpLFMocyx2KSxjfXJldHVybiBTKHMsdiksY31mdW5jdGlvbiBTKHMsYyl7aWYocy5sZW5ndGg+MCYmYy5sZW5ndGg9PT0wKXRocm93IG5ldyBFcnJvcigiRW1wdHkgc3ViLXNlbGVjdG9yIik7cy5wdXNoKGMpfX0sZnVuY3Rpb24oZyxlLHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KTt2YXIgbj17ZXF1YWxzOiIiLGVsZW1lbnQ6In4iLHN0YXJ0OiJeIixlbmQ6IiQiLGFueToiKiIsbm90OiIhIixoeXBoZW46InwifTtmdW5jdGlvbiBpKGEpe3JldHVybiBhLm1hcChmKS5qb2luKCIsICIpfWUuZGVmYXVsdD1pO2Z1bmN0aW9uIGYoYSl7cmV0dXJuIGEubWFwKGgpLmpvaW4oIiIpfWZ1bmN0aW9uIGgoYSl7c3dpdGNoKGEudHlwZSl7Y2FzZSJjaGlsZCI6cmV0dXJuIiA+ICI7Y2FzZSJwYXJlbnQiOnJldHVybiIgPCAiO2Nhc2Uic2libGluZyI6cmV0dXJuIiB+ICI7Y2FzZSJhZGphY2VudCI6cmV0dXJuIiArICI7Y2FzZSJkZXNjZW5kYW50IjpyZXR1cm4iICI7Y2FzZSJ1bml2ZXJzYWwiOnJldHVybiIqIjtjYXNlInRhZyI6cmV0dXJuIGEubmFtZTtjYXNlInBzZXVkby1lbGVtZW50IjpyZXR1cm4iOjoiK2EubmFtZTtjYXNlInBzZXVkbyI6cmV0dXJuIGEuZGF0YT09PW51bGw/IjoiK2EubmFtZTp0eXBlb2YgYS5kYXRhPT0ic3RyaW5nIj8iOiIrYS5uYW1lKyIoIithLmRhdGErIikiOiI6IithLm5hbWUrIigiK2koYS5kYXRhKSsiKSI7Y2FzZSJhdHRyaWJ1dGUiOnJldHVybiBhLmFjdGlvbj09PSJleGlzdHMiPyJbIithLm5hbWUrIl0iOmEubmFtZT09PSJpZCImJmEuYWN0aW9uPT09ImVxdWFscyImJiFhLmlnbm9yZUNhc2U/IiMiK2EudmFsdWU6YS5uYW1lPT09ImNsYXNzIiYmYS5hY3Rpb249PT0iZWxlbWVudCImJiFhLmlnbm9yZUNhc2U/Ii4iK2EudmFsdWU6IlsiK2EubmFtZStuW2EuYWN0aW9uXSsiPSciK2EudmFsdWUrIiciKyhhLmlnbm9yZUNhc2U/ImkiOiIiKSsiXSI7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoIlVua25vd24gdHlwZSIpfX1mdW5jdGlvbiB1KGEpe3JldHVybiBhfX0sZnVuY3Rpb24oZyxlLHQpe2cuZXhwb3J0cz1mO3ZhciBuPXQoMjc5KSxpPXtfX3Byb3RvX186bnVsbCxleGlzdHM6MTAsZXF1YWxzOjgsbm90Ojcsc3RhcnQ6NixlbmQ6Nixhbnk6NSxoeXBoZW46NCxlbGVtZW50OjR9O2Z1bmN0aW9uIGYodSl7Zm9yKHZhciBhPXUubWFwKGgpLGQ9MTtkPHUubGVuZ3RoO2QrKyl7dmFyIEU9YVtkXTtpZighKEU8MCkpZm9yKHZhciBwPWQtMTtwPj0wJiZFPGFbcF07cC0tKXt2YXIgTz11W3ArMV07dVtwKzFdPXVbcF0sdVtwXT1PLGFbcCsxXT1hW3BdLGFbcF09RX19fWZ1bmN0aW9uIGgodSl7dmFyIGE9blt1LnR5cGVdO2lmKGE9PT1uLmF0dHJpYnV0ZSlhPWlbdS5hY3Rpb25dLGE9PT1pLmVxdWFscyYmdS5uYW1lPT09ImlkIiYmKGE9OSksdS5pZ25vcmVDYXNlJiYoYT4+PTEpO2Vsc2UgaWYoYT09PW4ucHNldWRvKWlmKCF1LmRhdGEpYT0zO2Vsc2UgaWYodS5uYW1lPT09ImhhcyJ8fHUubmFtZT09PSJjb250YWlucyIpYT0wO2Vsc2UgaWYodS5uYW1lPT09Im1hdGNoZXMifHx1Lm5hbWU9PT0ibm90Iil7YT0wO2Zvcih2YXIgZD0wO2Q8dS5kYXRhLmxlbmd0aDtkKyspaWYodS5kYXRhW2RdLmxlbmd0aD09PTEpe3ZhciBFPWgodS5kYXRhW2RdWzBdKTtpZihFPT09MCl7YT0wO2JyZWFrfUU+YSYmKGE9RSl9dS5kYXRhLmxlbmd0aD4xJiZhPjAmJihhLT0xKX1lbHNlIGE9MTtyZXR1cm4gYX19LGZ1bmN0aW9uKGcpe2cuZXhwb3J0cz1KU09OLnBhcnNlKCd7InVuaXZlcnNhbCI6NTAsInRhZyI6MzAsImF0dHJpYnV0ZSI6MSwicHNldWRvIjowLCJkZXNjZW5kYW50IjotMSwiY2hpbGQiOi0xLCJwYXJlbnQiOi0xLCJzaWJsaW5nIjotMSwiYWRqYWNlbnQiOi0xfScpfSxmdW5jdGlvbihnLGUsdCl7dmFyIG49dCgyODEpLGk9dCgyODIpO2cuZXhwb3J0cz17X19wcm90b19fOm51bGwsYXR0cmlidXRlOm4uY29tcGlsZSxwc2V1ZG86aS5jb21waWxlLHRhZzpmdW5jdGlvbihmLGgsdSl7dmFyIGE9aC5uYW1lLGQ9dS5hZGFwdGVyO3JldHVybiBmdW5jdGlvbihwKXtyZXR1cm4gZC5nZXROYW1lKHApPT09YSYmZihwKX19LGRlc2NlbmRhbnQ6ZnVuY3Rpb24oZixoLHUpe3ZhciBhPXR5cGVvZiBXZWFrU2V0PCJ1Ij9uZXcgV2Vha1NldDpudWxsLGQ9dS5hZGFwdGVyO3JldHVybiBmdW5jdGlvbihwKXtmb3IodmFyIE89ITE7IU8mJihwPWQuZ2V0UGFyZW50KHApKTspKCFhfHwhYS5oYXMocCkpJiYoTz1mKHApLCFPJiZhJiZhLmFkZChwKSk7cmV0dXJuIE99fSxfZmxleGlibGVEZXNjZW5kYW50OmZ1bmN0aW9uKGYsaCx1KXt2YXIgYT11LmFkYXB0ZXI7cmV0dXJuIGZ1bmN0aW9uKEUpe2Zvcih2YXIgcD1mKEUpOyFwJiYoRT1hLmdldFBhcmVudChFKSk7KXA9ZihFKTtyZXR1cm4gcH19LHBhcmVudDpmdW5jdGlvbihmLGgsdSl7aWYodSYmdS5zdHJpY3QpdGhyb3cgbmV3IEVycm9yKCJQYXJlbnQgc2VsZWN0b3IgaXNuJ3QgcGFydCBvZiBDU1MzIik7dmFyIGE9dS5hZGFwdGVyO3JldHVybiBmdW5jdGlvbihwKXtyZXR1cm4gYS5nZXRDaGlsZHJlbihwKS5zb21lKGQpfTtmdW5jdGlvbiBkKEUpe3JldHVybiBhLmlzVGFnKEUpJiZmKEUpfX0sY2hpbGQ6ZnVuY3Rpb24oZixoLHUpe3ZhciBhPXUuYWRhcHRlcjtyZXR1cm4gZnVuY3Rpb24oRSl7dmFyIHA9YS5nZXRQYXJlbnQoRSk7cmV0dXJuISFwJiZmKHApfX0sc2libGluZzpmdW5jdGlvbihmLGgsdSl7dmFyIGE9dS5hZGFwdGVyO3JldHVybiBmdW5jdGlvbihFKXtmb3IodmFyIHA9YS5nZXRTaWJsaW5ncyhFKSxPPTA7TzxwLmxlbmd0aDtPKyspaWYoYS5pc1RhZyhwW09dKSl7aWYocFtPXT09PUUpYnJlYWs7aWYoZihwW09dKSlyZXR1cm4hMH1yZXR1cm4hMX19LGFkamFjZW50OmZ1bmN0aW9uKGYsaCx1KXt2YXIgYT11LmFkYXB0ZXI7cmV0dXJuIGZ1bmN0aW9uKEUpe2Zvcih2YXIgcD1hLmdldFNpYmxpbmdzKEUpLE8sbT0wO208cC5sZW5ndGg7bSsrKWlmKGEuaXNUYWcocFttXSkpe2lmKHBbbV09PT1FKWJyZWFrO089cFttXX1yZXR1cm4hIU8mJmYoTyl9fSx1bml2ZXJzYWw6ZnVuY3Rpb24oZil7cmV0dXJuIGZ9fX0sZnVuY3Rpb24oZyxlLHQpe3ZhciBuPXQoMjczKS5mYWxzZUZ1bmMsaT0vWy1bXF17fSgpKis/LixcXF4kfCNcc10vZyxmPXtfX3Byb3RvX186bnVsbCxlcXVhbHM6ZnVuY3Rpb24oaCx1LGEpe3ZhciBkPXUubmFtZSxFPXUudmFsdWUscD1hLmFkYXB0ZXI7cmV0dXJuIHUuaWdub3JlQ2FzZT8oRT1FLnRvTG93ZXJDYXNlKCksZnVuY3Rpb24obSl7dmFyIGI9cC5nZXRBdHRyaWJ1dGVWYWx1ZShtLGQpO3JldHVybiBiIT1udWxsJiZiLnRvTG93ZXJDYXNlKCk9PT1FJiZoKG0pfSk6ZnVuY3Rpb24obSl7cmV0dXJuIHAuZ2V0QXR0cmlidXRlVmFsdWUobSxkKT09PUUmJmgobSl9fSxoeXBoZW46ZnVuY3Rpb24oaCx1LGEpe3ZhciBkPXUubmFtZSxFPXUudmFsdWUscD1FLmxlbmd0aCxPPWEuYWRhcHRlcjtyZXR1cm4gdS5pZ25vcmVDYXNlPyhFPUUudG9Mb3dlckNhc2UoKSxmdW5jdGlvbihiKXt2YXIgTT1PLmdldEF0dHJpYnV0ZVZhbHVlKGIsZCk7cmV0dXJuIE0hPW51bGwmJihNLmxlbmd0aD09PXB8fE0uY2hhckF0KHApPT09Ii0iKSYmTS5zdWJzdHIoMCxwKS50b0xvd2VyQ2FzZSgpPT09RSYmaChiKX0pOmZ1bmN0aW9uKGIpe3ZhciBNPU8uZ2V0QXR0cmlidXRlVmFsdWUoYixkKTtyZXR1cm4gTSE9bnVsbCYmTS5zdWJzdHIoMCxwKT09PUUmJihNLmxlbmd0aD09PXB8fE0uY2hhckF0KHApPT09Ii0iKSYmaChiKX19LGVsZW1lbnQ6ZnVuY3Rpb24oaCx1LGEpe3ZhciBkPXUubmFtZSxFPXUudmFsdWUscD1hLmFkYXB0ZXI7aWYoL1xzLy50ZXN0KEUpKXJldHVybiBuO0U9RS5yZXBsYWNlKGksIlxcJCYiKTt2YXIgTz0iKD86XnxcXHMpIitFKyIoPzokfFxccykiLG09dS5pZ25vcmVDYXNlPyJpIjoiIixiPW5ldyBSZWdFeHAoTyxtKTtyZXR1cm4gZnVuY3Rpb24oeSl7dmFyIFM9cC5nZXRBdHRyaWJ1dGVWYWx1ZSh5LGQpO3JldHVybiBTIT1udWxsJiZiLnRlc3QoUykmJmgoeSl9fSxleGlzdHM6ZnVuY3Rpb24oaCx1LGEpe3ZhciBkPXUubmFtZSxFPWEuYWRhcHRlcjtyZXR1cm4gZnVuY3Rpb24oTyl7cmV0dXJuIEUuaGFzQXR0cmliKE8sZCkmJmgoTyl9fSxzdGFydDpmdW5jdGlvbihoLHUsYSl7dmFyIGQ9dS5uYW1lLEU9dS52YWx1ZSxwPUUubGVuZ3RoLE89YS5hZGFwdGVyO3JldHVybiBwPT09MD9uOnUuaWdub3JlQ2FzZT8oRT1FLnRvTG93ZXJDYXNlKCksZnVuY3Rpb24oYil7dmFyIE09Ty5nZXRBdHRyaWJ1dGVWYWx1ZShiLGQpO3JldHVybiBNIT1udWxsJiZNLnN1YnN0cigwLHApLnRvTG93ZXJDYXNlKCk9PT1FJiZoKGIpfSk6ZnVuY3Rpb24oYil7dmFyIE09Ty5nZXRBdHRyaWJ1dGVWYWx1ZShiLGQpO3JldHVybiBNIT1udWxsJiZNLnN1YnN0cigwLHApPT09RSYmaChiKX19LGVuZDpmdW5jdGlvbihoLHUsYSl7dmFyIGQ9dS5uYW1lLEU9dS52YWx1ZSxwPS1FLmxlbmd0aCxPPWEuYWRhcHRlcjtyZXR1cm4gcD09PTA/bjp1Lmlnbm9yZUNhc2U/KEU9RS50b0xvd2VyQ2FzZSgpLGZ1bmN0aW9uKGIpe3ZhciBNPU8uZ2V0QXR0cmlidXRlVmFsdWUoYixkKTtyZXR1cm4gTSE9bnVsbCYmTS5zdWJzdHIocCkudG9Mb3dlckNhc2UoKT09PUUmJmgoYil9KTpmdW5jdGlvbihiKXt2YXIgTT1PLmdldEF0dHJpYnV0ZVZhbHVlKGIsZCk7cmV0dXJuIE0hPW51bGwmJk0uc3Vic3RyKHApPT09RSYmaChiKX19LGFueTpmdW5jdGlvbihoLHUsYSl7dmFyIGQ9dS5uYW1lLEU9dS52YWx1ZSxwPWEuYWRhcHRlcjtpZihFPT09IiIpcmV0dXJuIG47aWYodS5pZ25vcmVDYXNlKXt2YXIgTz1uZXcgUmVnRXhwKEUucmVwbGFjZShpLCJcXCQmIiksImkiKTtyZXR1cm4gZnVuY3Rpb24oYil7dmFyIE09cC5nZXRBdHRyaWJ1dGVWYWx1ZShiLGQpO3JldHVybiBNIT1udWxsJiZPLnRlc3QoTSkmJmgoYil9fXJldHVybiBmdW5jdGlvbihiKXt2YXIgTT1wLmdldEF0dHJpYnV0ZVZhbHVlKGIsZCk7cmV0dXJuIE0hPW51bGwmJk0uaW5kZXhPZihFKT49MCYmaChiKX19LG5vdDpmdW5jdGlvbihoLHUsYSl7dmFyIGQ9dS5uYW1lLEU9dS52YWx1ZSxwPWEuYWRhcHRlcjtyZXR1cm4gRT09PSIiP2Z1bmN0aW9uKG0pe3JldHVybiEhcC5nZXRBdHRyaWJ1dGVWYWx1ZShtLGQpJiZoKG0pfTp1Lmlnbm9yZUNhc2U/KEU9RS50b0xvd2VyQ2FzZSgpLGZ1bmN0aW9uKG0pe3ZhciBiPXAuZ2V0QXR0cmlidXRlVmFsdWUobSxkKTtyZXR1cm4gYiE9bnVsbCYmYi50b0xvd2VyQ2FzZSgpIT09RSYmaChtKX0pOmZ1bmN0aW9uKG0pe3JldHVybiBwLmdldEF0dHJpYnV0ZVZhbHVlKG0sZCkhPT1FJiZoKG0pfX19O2cuZXhwb3J0cz17Y29tcGlsZTpmdW5jdGlvbihoLHUsYSl7aWYoYSYmYS5zdHJpY3QmJih1Lmlnbm9yZUNhc2V8fHUuYWN0aW9uPT09Im5vdCIpKXRocm93IG5ldyBFcnJvcigiVW5zdXBwb3J0ZWQgYXR0cmlidXRlIHNlbGVjdG9yIik7cmV0dXJuIGZbdS5hY3Rpb25dKGgsdSxhKX0scnVsZXM6Zn19LGZ1bmN0aW9uKGcsZSx0KXt2YXIgbj10KDI4MyksaT10KDI3MyksZj10KDI4MSksaD1pLnRydWVGdW5jLHU9aS5mYWxzZUZ1bmMsYT1mLnJ1bGVzLmVxdWFscztmdW5jdGlvbiBkKFMscyl7dmFyIGM9e25hbWU6Uyx2YWx1ZTpzfTtyZXR1cm4gZnVuY3Rpb24odixULFIpe3JldHVybiBhKHYsYyxSKX19ZnVuY3Rpb24gRShTLHMpe3JldHVybiBmdW5jdGlvbihjKXtyZXR1cm4hIXMuZ2V0UGFyZW50KGMpJiZTKGMpfX12YXIgcD17Y29udGFpbnM6ZnVuY3Rpb24oUyxzLGMpe3ZhciBsPWMuYWRhcHRlcjtyZXR1cm4gZnVuY3Rpb24oVCl7cmV0dXJuIFMoVCkmJmwuZ2V0VGV4dChUKS5pbmRleE9mKHMpPj0wfX0saWNvbnRhaW5zOmZ1bmN0aW9uKFMscyxjKXt2YXIgbD1zLnRvTG93ZXJDYXNlKCksdj1jLmFkYXB0ZXI7cmV0dXJuIGZ1bmN0aW9uKFIpe3JldHVybiBTKFIpJiZ2LmdldFRleHQoUikudG9Mb3dlckNhc2UoKS5pbmRleE9mKGwpPj0wfX0sIm50aC1jaGlsZCI6ZnVuY3Rpb24oUyxzLGMpe3ZhciBsPW4ocyksdj1jLmFkYXB0ZXI7cmV0dXJuIGw9PT11P2w6bD09PWg/RShTLHYpOmZ1bmN0aW9uKFIpe2Zvcih2YXIgTD12LmdldFNpYmxpbmdzKFIpLE49MCxBPTA7TjxMLmxlbmd0aDtOKyspaWYodi5pc1RhZyhMW05dKSl7aWYoTFtOXT09PVIpYnJlYWs7QSsrfXJldHVybiBsKEEpJiZTKFIpfX0sIm50aC1sYXN0LWNoaWxkIjpmdW5jdGlvbihTLHMsYyl7dmFyIGw9bihzKSx2PWMuYWRhcHRlcjtyZXR1cm4gbD09PXU/bDpsPT09aD9FKFMsdik6ZnVuY3Rpb24oUil7Zm9yKHZhciBMPXYuZ2V0U2libGluZ3MoUiksTj0wLEE9TC5sZW5ndGgtMTtBPj0wO0EtLSlpZih2LmlzVGFnKExbQV0pKXtpZihMW0FdPT09UilicmVhaztOKyt9cmV0dXJuIGwoTikmJlMoUil9fSwibnRoLW9mLXR5cGUiOmZ1bmN0aW9uKFMscyxjKXt2YXIgbD1uKHMpLHY9Yy5hZGFwdGVyO3JldHVybiBsPT09dT9sOmw9PT1oP0UoUyx2KTpmdW5jdGlvbihSKXtmb3IodmFyIEw9di5nZXRTaWJsaW5ncyhSKSxOPTAsQT0wO0E8TC5sZW5ndGg7QSsrKWlmKHYuaXNUYWcoTFtBXSkpe2lmKExbQV09PT1SKWJyZWFrO3YuZ2V0TmFtZShMW0FdKT09PXYuZ2V0TmFtZShSKSYmTisrfXJldHVybiBsKE4pJiZTKFIpfX0sIm50aC1sYXN0LW9mLXR5cGUiOmZ1bmN0aW9uKFMscyxjKXt2YXIgbD1uKHMpLHY9Yy5hZGFwdGVyO3JldHVybiBsPT09dT9sOmw9PT1oP0UoUyx2KTpmdW5jdGlvbihSKXtmb3IodmFyIEw9di5nZXRTaWJsaW5ncyhSKSxOPTAsQT1MLmxlbmd0aC0xO0E+PTA7QS0tKWlmKHYuaXNUYWcoTFtBXSkpe2lmKExbQV09PT1SKWJyZWFrO3YuZ2V0TmFtZShMW0FdKT09PXYuZ2V0TmFtZShSKSYmTisrfXJldHVybiBsKE4pJiZTKFIpfX0scm9vdDpmdW5jdGlvbihTLHMsYyl7dmFyIGw9Yy5hZGFwdGVyO3JldHVybiBmdW5jdGlvbih2KXtyZXR1cm4hbC5nZXRQYXJlbnQodikmJlModil9fSxzY29wZTpmdW5jdGlvbihTLHMsYyxsKXt2YXIgdj1jLmFkYXB0ZXI7aWYoIWx8fGwubGVuZ3RoPT09MClyZXR1cm4gcC5yb290KFMscyxjKTtmdW5jdGlvbiBUKFIsTCl7cmV0dXJuIHR5cGVvZiB2LmVxdWFscz09ImZ1bmN0aW9uIj92LmVxdWFscyhSLEwpOlI9PT1MfXJldHVybiBsLmxlbmd0aD09PTE/ZnVuY3Rpb24oUil7cmV0dXJuIFQobFswXSxSKSYmUyhSKX06ZnVuY3Rpb24oUil7cmV0dXJuIGwuaW5kZXhPZihSKT49MCYmUyhSKX19LGNoZWNrYm94OmQoInR5cGUiLCJjaGVja2JveCIpLGZpbGU6ZCgidHlwZSIsImZpbGUiKSxwYXNzd29yZDpkKCJ0eXBlIiwicGFzc3dvcmQiKSxyYWRpbzpkKCJ0eXBlIiwicmFkaW8iKSxyZXNldDpkKCJ0eXBlIiwicmVzZXQiKSxpbWFnZTpkKCJ0eXBlIiwiaW1hZ2UiKSxzdWJtaXQ6ZCgidHlwZSIsInN1Ym1pdCIpLGhvdmVyOmZ1bmN0aW9uKFMscyxjKXt2YXIgbD1jLmFkYXB0ZXI7cmV0dXJuIHR5cGVvZiBsLmlzSG92ZXJlZD09ImZ1bmN0aW9uIj9mdW5jdGlvbihUKXtyZXR1cm4gUyhUKSYmbC5pc0hvdmVyZWQoVCl9OnV9LHZpc2l0ZWQ6ZnVuY3Rpb24oUyxzLGMpe3ZhciBsPWMuYWRhcHRlcjtyZXR1cm4gdHlwZW9mIGwuaXNWaXNpdGVkPT0iZnVuY3Rpb24iP2Z1bmN0aW9uKFQpe3JldHVybiBTKFQpJiZsLmlzVmlzaXRlZChUKX06dX0sYWN0aXZlOmZ1bmN0aW9uKFMscyxjKXt2YXIgbD1jLmFkYXB0ZXI7cmV0dXJuIHR5cGVvZiBsLmlzQWN0aXZlPT0iZnVuY3Rpb24iP2Z1bmN0aW9uKFQpe3JldHVybiBTKFQpJiZsLmlzQWN0aXZlKFQpfTp1fX07ZnVuY3Rpb24gTyhTLHMpe2Zvcih2YXIgYz0wO1MmJmM8Uy5sZW5ndGg7YysrKWlmKHMuaXNUYWcoU1tjXSkpcmV0dXJuIFNbY119dmFyIG09e2VtcHR5OmZ1bmN0aW9uKFMscyl7cmV0dXJuIXMuZ2V0Q2hpbGRyZW4oUykuc29tZShmdW5jdGlvbihjKXtyZXR1cm4gcy5pc1RhZyhjKXx8Yy50eXBlPT09InRleHQifSl9LCJmaXJzdC1jaGlsZCI6ZnVuY3Rpb24oUyxzKXtyZXR1cm4gTyhzLmdldFNpYmxpbmdzKFMpLHMpPT09U30sImxhc3QtY2hpbGQiOmZ1bmN0aW9uKFMscyl7Zm9yKHZhciBjPXMuZ2V0U2libGluZ3MoUyksbD1jLmxlbmd0aC0xO2w+PTA7bC0tKXtpZihjW2xdPT09UylyZXR1cm4hMDtpZihzLmlzVGFnKGNbbF0pKWJyZWFrfXJldHVybiExfSwiZmlyc3Qtb2YtdHlwZSI6ZnVuY3Rpb24oUyxzKXtmb3IodmFyIGM9cy5nZXRTaWJsaW5ncyhTKSxsPTA7bDxjLmxlbmd0aDtsKyspaWYocy5pc1RhZyhjW2xdKSl7aWYoY1tsXT09PVMpcmV0dXJuITA7aWYocy5nZXROYW1lKGNbbF0pPT09cy5nZXROYW1lKFMpKWJyZWFrfXJldHVybiExfSwibGFzdC1vZi10eXBlIjpmdW5jdGlvbihTLHMpe2Zvcih2YXIgYz1zLmdldFNpYmxpbmdzKFMpLGw9Yy5sZW5ndGgtMTtsPj0wO2wtLSlpZihzLmlzVGFnKGNbbF0pKXtpZihjW2xdPT09UylyZXR1cm4hMDtpZihzLmdldE5hbWUoY1tsXSk9PT1zLmdldE5hbWUoUykpYnJlYWt9cmV0dXJuITF9LCJvbmx5LW9mLXR5cGUiOmZ1bmN0aW9uKFMscyl7Zm9yKHZhciBjPXMuZ2V0U2libGluZ3MoUyksbD0wLHY9Yy5sZW5ndGg7bDx2O2wrKylpZihzLmlzVGFnKGNbbF0pKXtpZihjW2xdPT09Uyljb250aW51ZTtpZihzLmdldE5hbWUoY1tsXSk9PT1zLmdldE5hbWUoUykpcmV0dXJuITF9cmV0dXJuITB9LCJvbmx5LWNoaWxkIjpmdW5jdGlvbihTLHMpe2Zvcih2YXIgYz1zLmdldFNpYmxpbmdzKFMpLGw9MDtsPGMubGVuZ3RoO2wrKylpZihzLmlzVGFnKGNbbF0pJiZjW2xdIT09UylyZXR1cm4hMTtyZXR1cm4hMH0sbGluazpmdW5jdGlvbihTLHMpe3JldHVybiBzLmhhc0F0dHJpYihTLCJocmVmIil9LHNlbGVjdGVkOmZ1bmN0aW9uKFMscyl7aWYocy5oYXNBdHRyaWIoUywic2VsZWN0ZWQiKSlyZXR1cm4hMDtpZihzLmdldE5hbWUoUykhPT0ib3B0aW9uIilyZXR1cm4hMTt2YXIgYz1zLmdldFBhcmVudChTKTtpZighY3x8cy5nZXROYW1lKGMpIT09InNlbGVjdCJ8fHMuaGFzQXR0cmliKGMsIm11bHRpcGxlIikpcmV0dXJuITE7Zm9yKHZhciBsPXMuZ2V0Q2hpbGRyZW4oYyksdj0hMSxUPTA7VDxsLmxlbmd0aDtUKyspaWYocy5pc1RhZyhsW1RdKSlpZihsW1RdPT09Uyl2PSEwO2Vsc2UgaWYodil7aWYocy5oYXNBdHRyaWIobFtUXSwic2VsZWN0ZWQiKSlyZXR1cm4hMX1lbHNlIHJldHVybiExO3JldHVybiB2fSxkaXNhYmxlZDpmdW5jdGlvbihTLHMpe3JldHVybiBzLmhhc0F0dHJpYihTLCJkaXNhYmxlZCIpfSxlbmFibGVkOmZ1bmN0aW9uKFMscyl7cmV0dXJuIXMuaGFzQXR0cmliKFMsImRpc2FibGVkIil9LGNoZWNrZWQ6ZnVuY3Rpb24oUyxzKXtyZXR1cm4gcy5oYXNBdHRyaWIoUywiY2hlY2tlZCIpfHxtLnNlbGVjdGVkKFMscyl9LHJlcXVpcmVkOmZ1bmN0aW9uKFMscyl7cmV0dXJuIHMuaGFzQXR0cmliKFMsInJlcXVpcmVkIil9LG9wdGlvbmFsOmZ1bmN0aW9uKFMscyl7cmV0dXJuIXMuaGFzQXR0cmliKFMsInJlcXVpcmVkIil9LHBhcmVudDpmdW5jdGlvbihTLHMpe3JldHVybiFtLmVtcHR5KFMscyl9LGhlYWRlcjpiKFsiaDEiLCJoMiIsImgzIiwiaDQiLCJoNSIsImg2Il0pLGJ1dHRvbjpmdW5jdGlvbihTLHMpe3ZhciBjPXMuZ2V0TmFtZShTKTtyZXR1cm4gYz09PSJidXR0b24ifHxjPT09ImlucHV0IiYmcy5nZXRBdHRyaWJ1dGVWYWx1ZShTLCJ0eXBlIik9PT0iYnV0dG9uIn0saW5wdXQ6YihbImlucHV0IiwidGV4dGFyZWEiLCJzZWxlY3QiLCJidXR0b24iXSksdGV4dDpmdW5jdGlvbihTLHMpe3ZhciBjO3JldHVybiBzLmdldE5hbWUoUyk9PT0iaW5wdXQiJiYoIShjPXMuZ2V0QXR0cmlidXRlVmFsdWUoUywidHlwZSIpKXx8Yy50b0xvd2VyQ2FzZSgpPT09InRleHQiKX19O2Z1bmN0aW9uIGIoUyl7aWYodHlwZW9mIFNldDwidSIpe3ZhciBzPW5ldyBTZXQoUyk7cmV0dXJuIGZ1bmN0aW9uKGMsbCl7cmV0dXJuIHMuaGFzKGwuZ2V0TmFtZShjKSl9fXJldHVybiBmdW5jdGlvbihjLGwpe3JldHVybiBTLmluZGV4T2YobC5nZXROYW1lKGMpKT49MH19ZnVuY3Rpb24gTShTLHMsYyl7aWYoYz09PW51bGwpe2lmKFMubGVuZ3RoPjImJnMhPT0ic2NvcGUiKXRocm93IG5ldyBFcnJvcigicHNldWRvLXNlbGVjdG9yIDoiK3MrIiByZXF1aXJlcyBhbiBhcmd1bWVudCIpfWVsc2UgaWYoUy5sZW5ndGg9PT0yKXRocm93IG5ldyBFcnJvcigicHNldWRvLXNlbGVjdG9yIDoiK3MrIiBkb2Vzbid0IGhhdmUgYW55IGFyZ3VtZW50cyIpfXZhciB5PS9eKD86KD86bnRofGxhc3R8Zmlyc3R8b25seSktKD86Y2hpbGR8b2YtdHlwZSl8cm9vdHxlbXB0eXwoPzplbnxkaXMpYWJsZWR8Y2hlY2tlZHxub3QpJC87Zy5leHBvcnRzPXtjb21waWxlOmZ1bmN0aW9uKFMscyxjLGwpe3ZhciB2PXMubmFtZSxUPXMuZGF0YSxSPWMuYWRhcHRlcjtpZihjJiZjLnN0cmljdCYmIXkudGVzdCh2KSl0aHJvdyBuZXcgRXJyb3IoIjoiK3YrIiBpc24ndCBwYXJ0IG9mIENTUzMiKTtpZih0eXBlb2YgcFt2XT09ImZ1bmN0aW9uIilyZXR1cm4gcFt2XShTLFQsYyxsKTtpZih0eXBlb2YgbVt2XT09ImZ1bmN0aW9uIil7dmFyIEw9bVt2XTtyZXR1cm4gTShMLHYsVCksTD09PXU/TDpTPT09aD9mdW5jdGlvbihBKXtyZXR1cm4gTChBLFIsVCl9OmZ1bmN0aW9uKEEpe3JldHVybiBMKEEsUixUKSYmUyhBKX19ZWxzZSB0aHJvdyBuZXcgRXJyb3IoInVubWF0Y2hlZCBwc2V1ZG8tY2xhc3MgOiIrdil9LGZpbHRlcnM6cCxwc2V1ZG9zOm19fSxmdW5jdGlvbihnLGUsdCl7dmFyIG49dCgyODQpLGk9dCgyODUpO2cuZXhwb3J0cz1mdW5jdGlvbihoKXtyZXR1cm4gaShuKGgpKX0sZy5leHBvcnRzLnBhcnNlPW4sZy5leHBvcnRzLmNvbXBpbGU9aX0sZnVuY3Rpb24oZyxlKXtnLmV4cG9ydHM9bjt2YXIgdD0vXihbK1wtXT9cZCpuKT9ccyooPzooWytcLV0/KVxzKihcZCspKT8kLztmdW5jdGlvbiBuKGkpe2lmKGk9aS50cmltKCkudG9Mb3dlckNhc2UoKSxpPT09ImV2ZW4iKXJldHVyblsyLDBdO2lmKGk9PT0ib2RkIilyZXR1cm5bMiwxXTt2YXIgZj1pLm1hdGNoKHQpO2lmKCFmKXRocm93IG5ldyBTeW50YXhFcnJvcigibi10aCBydWxlIGNvdWxkbid0IGJlIHBhcnNlZCAoJyIraSsiJykiKTt2YXIgaDtyZXR1cm4gZlsxXT8oaD1wYXJzZUludChmWzFdLDEwKSxpc05hTihoKSYmKGZbMV0uY2hhckF0KDApPT09Ii0iP2g9LTE6aD0xKSk6aD0wLFtoLGZbM10/cGFyc2VJbnQoKGZbMl18fCIiKStmWzNdLDEwKTowXX19LGZ1bmN0aW9uKGcsZSx0KXtnLmV4cG9ydHM9aDt2YXIgbj10KDI3MyksaT1uLnRydWVGdW5jLGY9bi5mYWxzZUZ1bmM7ZnVuY3Rpb24gaCh1KXt2YXIgYT11WzBdLGQ9dVsxXS0xO2lmKGQ8MCYmYTw9MClyZXR1cm4gZjtpZihhPT09LTEpcmV0dXJuIGZ1bmN0aW9uKHApe3JldHVybiBwPD1kfTtpZihhPT09MClyZXR1cm4gZnVuY3Rpb24ocCl7cmV0dXJuIHA9PT1kfTtpZihhPT09MSlyZXR1cm4gZDwwP2k6ZnVuY3Rpb24ocCl7cmV0dXJuIHA+PWR9O3ZhciBFPWQlYTtyZXR1cm4gRTwwJiYoRSs9YSksYT4xP2Z1bmN0aW9uKHApe3JldHVybiBwPj1kJiZwJWE9PT1FfTooYSo9LTEsZnVuY3Rpb24ocCl7cmV0dXJuIHA8PWQmJnAlYT09PUV9KX19LGZ1bmN0aW9uKGcsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIFR9KTt2YXIgbj10KDEyKSxpPXQoNzQpLGY9dCgxKSxoPXQoNjgpLHU9dCgyNTApLGE9dCgyMTMpLGQ9dCgyMTgpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBFKFIsTCl7aWYoUj09bnVsbClyZXR1cm57fTt2YXIgTj1wKFIsTCksQSx3O2lmKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpe3ZhciBCPU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoUik7Zm9yKHc9MDt3PEIubGVuZ3RoO3crKylBPUJbd10sIShMLmluZGV4T2YoQSk+PTApJiZPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoUixBKSYmKE5bQV09UltBXSl9cmV0dXJuIE59ZnVuY3Rpb24gcChSLEwpe2lmKFI9PW51bGwpcmV0dXJue307dmFyIE49e30sQT1PYmplY3Qua2V5cyhSKSx3LEI7Zm9yKEI9MDtCPEEubGVuZ3RoO0IrKyl3PUFbQl0sIShMLmluZGV4T2Yodyk+PTApJiYoTlt3XT1SW3ddKTtyZXR1cm4gTn1jb25zdCBPPXthbnRpYWxpYXM6ITAsYXV0b1JlbmRlcjohMCxhbHBoYTohMH0sbT1TeW1ib2woImF1dG9SZW5kZXIiKSxiPVN5bWJvbCgicmVuZGVyZXIiKSxNPVN5bWJvbCgidGltZWxpbmUiKSx5PVN5bWJvbCgicHJlcGFyZVJlbmRlciIpLFM9U3ltYm9sKCJ0aWNrUmVuZGVyIikscz1TeW1ib2woInBhc3MiKSxjPVN5bWJvbCgiZmJvIiksbD1TeW1ib2woInRpY2tlcnMiKSx2PVN5bWJvbCgibGF5ZXJUcmFuc2Zvcm1JbnZlcnQiKTtjbGFzcyBUIGV4dGVuZHMgdS5kZWZhdWx0e2NvbnN0cnVjdG9yKEw9e30pe2lmKHN1cGVyKCksIUwuY2FudmFzKXtjb25zdHt3aWR0aDpCLGhlaWdodDpEfT10aGlzLmdldFJlc29sdXRpb24oKSxJPW4uRU5WLmNyZWF0ZUNhbnZhcyhCLEQse29mZnNjcmVlbjohIUwub2Zmc2NyZWVuLGlkOkwuaWQsZXh0cmE6TC5leHRyYX0pO0kuc3R5bGUmJihJLnN0eWxlLnBvc2l0aW9uPSJhYnNvbHV0ZSIpLEkuZGF0YXNldCYmKEkuZGF0YXNldC5sYXllcklkPUwuaWQpLEkuY29udGV4dFR5cGUmJihMLmNvbnRleHRUeXBlPUkuY29udGV4dFR5cGUpLEwuY2FudmFzPUl9Y29uc3QgTj1MLmNhbnZhcyxBPU9iamVjdC5hc3NpZ24oe30sTyxMKTt0aGlzW21dPUEuYXV0b1JlbmRlcixkZWxldGUgTC5hdXRvUmVuZGVyO2NvbnN0IHc9QS5SZW5kZXJlcnx8bi5SZW5kZXJlcjt0aGlzW2JdPW5ldyB3KE4sQSksdGhpcy5vcHRpb25zPUwsdGhpcy5pZD1MLmlkLHRoaXNbc109W10sdGhpcy5zZXRSZXNvbHV0aW9uKE4pLHRoaXMuY2FudmFzPU4sdGhpc1tNXT1uZXcgaS5UaW1lbGluZSx0aGlzLl9fbW91c2VDYXB0dXJlZFRhcmdldD1udWxsLHRoaXNbdl09bnVsbH1nZXQgYXV0b1JlbmRlcigpe3JldHVybiB0aGlzW21dfWdldCBkaXNwbGF5UmF0aW8oKXtyZXR1cm4gdGhpcy5wYXJlbnQmJnRoaXMucGFyZW50Lm9wdGlvbnM/dGhpcy5wYXJlbnQub3B0aW9ucy5kaXNwbGF5UmF0aW86MX1nZXQgaGVpZ2h0KCl7Y29uc3R7aGVpZ2h0Okx9PXRoaXMuZ2V0UmVzb2x1dGlvbigpO3JldHVybiBML3RoaXMuZGlzcGxheVJhdGlvfWdldCBnbCgpe3JldHVybiB0aGlzLnJlbmRlcmVyLmdsUmVuZGVyZXI/dGhpcy5yZW5kZXJlci5nbFJlbmRlcmVyLmdsOm51bGx9Z2V0IGxheWVyKCl7cmV0dXJuIHRoaXN9Z2V0IG9mZnNjcmVlbigpe3JldHVybiEhdGhpcy5vcHRpb25zLm9mZnNjcmVlbnx8dGhpcy5jYW52YXMuX29mZnNjcmVlbn1nZXQgcGFzcygpe3JldHVybiB0aGlzW3NdfWdldCBwcmVwYXJlUmVuZGVyKCl7cmV0dXJuIHRoaXNbeV0/dGhpc1t5XTpQcm9taXNlLnJlc29sdmUoKX1nZXQgcmVuZGVyZXIoKXtyZXR1cm4gdGhpc1tiXX1nZXQgcmVuZGVyT2Zmc2V0KCl7aWYodGhpcy5wYXJlbnQmJnRoaXMucGFyZW50Lm9wdGlvbnMpe2NvbnN0e2xlZnQ6TCx0b3A6Tn09dGhpcy5wYXJlbnQub3B0aW9ucztyZXR1cm5bTCxOXX1yZXR1cm5bdGhpcy5vcHRpb25zLmxlZnR8MCx0aGlzLm9wdGlvbnMudG9wfDBdfWdldCB0aW1lbGluZSgpe3JldHVybiB0aGlzW01dfWdldCB3aWR0aCgpe2NvbnN0e3dpZHRoOkx9PXRoaXMuZ2V0UmVzb2x1dGlvbigpO3JldHVybiBML3RoaXMuZGlzcGxheVJhdGlvfWdldCBsb2NhbE1hdHJpeCgpe2NvbnN0e3g6TCx5Ok59PXRoaXMuYXR0cmlidXRlcztyZXR1cm5bMSwwLDAsMSxMLE5dfWdldCBsYXllclRyYW5zZm9ybUludmVydCgpe2lmKHRoaXNbdl0pcmV0dXJuIHRoaXNbdl07Y29uc3QgTD10aGlzLnRyYW5zZm9ybU1hdHJpeDtyZXR1cm4gTFswXT09PTEmJkxbMV09PT0wJiZMWzJdPT09MCYmTFszXT09PTEmJkxbNF09PT0wJiZMWzVdPT09MD9udWxsOih0aGlzW3ZdPWYubWF0MmQuaW52ZXJ0KEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxMKSx0aGlzW3ZdKX1mb3JjZUNvbnRleHRMb3NzKCl7Y29uc3QgTD10aGlzLnJlbmRlcmVyLmdsUmVuZGVyZXI7aWYoTCl7Y29uc3QgTj1MLmdldEV4dGVuc2lvbigiV0VCR0xfbG9zZV9jb250ZXh0Iik7aWYoTilyZXR1cm4gTi5sb3NlQ29udGV4dCgpLCEwfXJldHVybiExfWFkZFBhc3Moe3ZlcnRleDpMLGZyYWdtZW50Ok4sb3B0aW9uczpBLHVuaWZvcm1zOnd9PXt9KXtpZih0aGlzLnJlbmRlcmVyLmdsUmVuZGVyZXIpe2NvbnN0e3dpZHRoOkIsaGVpZ2h0OkR9PXRoaXMuZ2V0UmVzb2x1dGlvbigpLEk9dGhpcy5yZW5kZXJlci5jcmVhdGVQYXNzUHJvZ3JhbSh7dmVydGV4OkwsZnJhZ21lbnQ6TixvcHRpb25zOkF9KSxqPW5ldyBuLkZpZ3VyZTJEO2oucmVjdCgwLDAsQi90aGlzLmRpc3BsYXlSYXRpbyxEL3RoaXMuZGlzcGxheVJhdGlvKTtjb25zdCBWPW5ldyBuLk1lc2gyRChqKTtyZXR1cm4gVi5zZXRVbmlmb3Jtcyh3KSxWLnNldFByb2dyYW0oSSksdGhpc1tzXS5wdXNoKFYpLHRoaXMuZm9yY2VVcGRhdGUoKSxWfXJldHVybiBudWxsfWRlbGV0ZVRleHR1cmUoTCl7cmV0dXJuIE9iamVjdChkLmRlbGV0ZVRleHR1cmUpKEwsdGhpcy5yZW5kZXJlcil9ZGlzcGF0Y2hQb2ludGVyRXZlbnQoTCl7Y29uc3QgTj1MLnR5cGU7aWYoTj09PSJtb3VzZWRvd24ifHxOPT09Im1vdXNldXAifHxOPT09Im1vdXNlbW92ZSIpe2NvbnN0IEk9dGhpcy5fX21vdXNlQ2FwdHVyZWRUYXJnZXQ7aWYoSSl7aWYoSS5sYXllcj09PXRoaXMpcmV0dXJuIEkuZGlzcGF0Y2hFdmVudChMKSwhMDt0aGlzLl9fbW91c2VDYXB0dXJlZFRhcmdldD1udWxsfX1sZXQgQSx3O2NvbnN0IEI9dGhpcy5sYXllclRyYW5zZm9ybUludmVydDtpZihCKXtBPUwueCx3PUwueTtjb25zdCBJPUIsaj1JWzBdKkErSVsyXSp3K0lbNF0sVj1JWzFdKkErSVszXSp3K0lbNV07ZGVsZXRlIEwueCxkZWxldGUgTC55LGRlbGV0ZSBMLmxheWVyWCxkZWxldGUgTC5sYXllclksT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoTCx7bGF5ZXJYOnt2YWx1ZTpqLGNvbmZpZ3VyYWJsZTohMH0sbGF5ZXJZOnt2YWx1ZTpWLGNvbmZpZ3VyYWJsZTohMH0seDp7dmFsdWU6aixjb25maWd1cmFibGU6ITB9LHk6e3ZhbHVlOlYsY29uZmlndXJhYmxlOiEwfX0pfWNvbnN0IEQ9c3VwZXIuZGlzcGF0Y2hQb2ludGVyRXZlbnQoTCk7cmV0dXJuIEImJk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEwse2xheWVyWDp7dmFsdWU6QSxjb25maWd1cmFibGU6ITB9LGxheWVyWTp7dmFsdWU6dyxjb25maWd1cmFibGU6ITB9LHg6e3ZhbHVlOkEsY29uZmlndXJhYmxlOiEwfSx5Ont2YWx1ZTp3LGNvbmZpZ3VyYWJsZTohMH19KSxEfWZvcmNlVXBkYXRlKCl7aWYoIXRoaXNbeV0paWYodGhpcy5wYXJlbnQmJnRoaXMucGFyZW50Lmhhc09mZnNjcmVlbkNhbnZhcyl7dGhpcy5wYXJlbnQuZm9yY2VVcGRhdGUoKTtsZXQgTD1udWxsO2NvbnN0IE49bmV3IFByb21pc2UoQT0+e0w9QX0pO04uX3Jlc29sdmU9TCx0aGlzW3ldPU59ZWxzZXtsZXQgTD1udWxsLE49bnVsbDtjb25zdCBBPW5ldyBQcm9taXNlKHc9PntMPXcsdGhpc1ttXSYmKE49T2JqZWN0KGgucmVxdWVzdEFuaW1hdGlvbkZyYW1lKSgoKT0+e2RlbGV0ZSBBLl9yZXF1ZXN0SUQsdGhpcy5yZW5kZXIoKX0pKX0pO0EuX3Jlc29sdmU9TCxBLl9yZXF1ZXN0SUQ9Tix0aGlzW3ldPUF9fWdldEZCTygpe2NvbnN0IEw9dGhpcy5yZW5kZXJlci5nbFJlbmRlcmVyLHt3aWR0aDpOLGhlaWdodDpBfT10aGlzLmdldFJlc29sdXRpb24oKTtyZXR1cm4gTCYmKCF0aGlzW2NdfHx0aGlzW2NdLndpZHRoIT09Tnx8dGhpc1tjXS5oZWlnaHQhPT1BKT8odGhpc1tjXT17d2lkdGg6TixoZWlnaHQ6QSx0YXJnZXQ6TC5jcmVhdGVGQk8oKSxidWZmZXI6TC5jcmVhdGVGQk8oKSxzd2FwKCl7W3RoaXMudGFyZ2V0LHRoaXMuYnVmZmVyXT1bdGhpcy5idWZmZXIsdGhpcy50YXJnZXRdfX0sdGhpc1tjXSk6dGhpc1tjXT90aGlzW2NdOm51bGx9dXBkYXRlR2xvYmFsVHJhbnNmb3JtKCl7aWYodGhpcy5sYXllclRyYW5zZm9ybUludmVydCl7Y29uc3QgTD10aGlzLnJlbmRlcmVyLE49TC5fX2dsb2JhbFRyYW5zZm9ybU1hdHJpeHx8TC5nbG9iYWxUcmFuc2Zvcm1NYXRyaXg7TC5fX2dsb2JhbFRyYW5zZm9ybU1hdHJpeD1OO2NvbnN0IEE9Zi5tYXQyZC5mcm9tVmFsdWVzKDEsMCwwLDEsMCwwKTtMLnNldEdsb2JhbFRyYW5zZm9ybSguLi5mLm1hdDJkLm11bHRpcGx5KEEsTix0aGlzLnRyYW5zZm9ybU1hdHJpeCkpfX1vblByb3BlcnR5Q2hhbmdlKEwsTixBKXtpZihzdXBlci5vblByb3BlcnR5Q2hhbmdlKEwsTixBKSxMPT09InpJbmRleCImJih0aGlzLmNhbnZhcy5zdHlsZS56SW5kZXg9TiksTD09PSJ0cmFuc2Zvcm0ifHxMPT09InRyYW5zbGF0ZSJ8fEw9PT0icm90YXRlInx8TD09PSJzY2FsZSJ8fEw9PT0ic2tldyIpe2NvbnN0IHc9dGhpc1t2XTtpZih0aGlzW3ZdPW51bGwsdGhpcy51cGRhdGVHbG9iYWxUcmFuc2Zvcm0oKSx3JiYhdGhpcy5sYXllclRyYW5zZm9ybUludmVydCl7Y29uc3QgQj10aGlzLnJlbmRlcmVyLEQ9Qi5fX2dsb2JhbFRyYW5zZm9ybU1hdHJpeHx8Qi5nbG9iYWxUcmFuc2Zvcm1NYXRyaXg7Qi5zZXRHbG9iYWxUcmFuc2Zvcm0oLi4uRCl9fX1fcHJlcGFyZVJlbmRlckZpbmlzaGVkKCl7dGhpc1t5XSYmKHRoaXNbeV0uX3JlcXVlc3RJRCYmT2JqZWN0KGguY2FuY2VsQW5pbWF0aW9uRnJhbWUpKHRoaXNbeV0uX3JlcXVlc3RJRCksdGhpc1t5XS5fcmVzb2x2ZSgpLGRlbGV0ZSB0aGlzW3ldKX1yZW5kZXIoe2NsZWFyOkw9ITB9PXt9KXtjb25zdCBOPXRoaXNbc10ubGVuZ3RoP3RoaXMuZ2V0RkJPKCk6bnVsbDtOJiZ0aGlzLnJlbmRlcmVyLmdsUmVuZGVyZXIuYmluZEZCTyhOLnRhcmdldCksTCYmdGhpc1tiXS5jbGVhcigpO2NvbnN0IEE9dGhpcy5kcmF3KCk7aWYoQSYmQS5sZW5ndGgmJih0aGlzLnJlbmRlcmVyLmRyYXdNZXNoZXMoQSksdGhpcy5jYW52YXMuZHJhdyYmdGhpcy5jYW52YXMuZHJhdygpKSxOKXtjb25zdCB3PXRoaXMucmVuZGVyZXIuZ2xSZW5kZXJlcixCPXRoaXNbc10ubGVuZ3RoLHt3aWR0aDpELGhlaWdodDpJfT10aGlzLmdldFJlc29sdXRpb24oKSxqPVswLDAsRC90aGlzLmRpc3BsYXlSYXRpbyxJL3RoaXMuZGlzcGxheVJhdGlvXTt0aGlzW3NdLmZvckVhY2goKFYsSik9PntWLmJsZW5kPSEwLFYuc2V0VGV4dHVyZShOLnRhcmdldC50ZXh0dXJlLHtyZWN0Omp9KSxKPT09Qi0xP3cuYmluZEZCTyhudWxsKTooTi5zd2FwKCksdy5iaW5kRkJPKE4udGFyZ2V0KSksdGhpc1tiXS5jbGVhcigpLHRoaXMucmVuZGVyZXIuZHJhd01lc2hlcyhbVl0pfSl9dGhpcy5fcHJlcGFyZVJlbmRlckZpbmlzaGVkKCl9c2V0UmVzb2x1dGlvbih7d2lkdGg6TCxoZWlnaHQ6Tn0pe2NvbnN0IEE9dGhpcy5yZW5kZXJlcix3PUEuX19nbG9iYWxUcmFuc2Zvcm1NYXRyaXh8fEEuZ2xvYmFsVHJhbnNmb3JtTWF0cml4LEI9d1s0XSxEPXdbNV0sST13WzBdLHt3aWR0aDpqLGhlaWdodDpWfT10aGlzLmdldFJlc29sdXRpb24oKTsoaiE9PUx8fFYhPT1OKSYmKHN1cGVyLnNldFJlc29sdXRpb24oe3dpZHRoOkwsaGVpZ2h0Ok59KSx0aGlzLmNhbnZhcyYmKHRoaXMuY2FudmFzLndpZHRoPUwsdGhpcy5jYW52YXMuaGVpZ2h0PU4sQS51cGRhdGVSZXNvbHV0aW9uJiZBLnVwZGF0ZVJlc29sdXRpb24oKSksdGhpcy5hdHRyaWJ1dGVzLnNpemU9W0wsTl0sdGhpc1tzXS5sZW5ndGgmJnRoaXNbc10uZm9yRWFjaChHPT57Y29uc3QgWT1uZXcgbi5GaWd1cmUyRDtZLnJlY3QoMCwwLEwvdGhpcy5kaXNwbGF5UmF0aW8sTi90aGlzLmRpc3BsYXlSYXRpbyksRy5jb250b3Vycz1ZLmNvbnRvdXJzfSkpO2NvbnN0W0osX109dGhpcy5yZW5kZXJPZmZzZXQsc3Q9dGhpcy5kaXNwbGF5UmF0aW87KEIhPT1KfHxEIT09X3x8SSE9PXN0KSYmKEEuc2V0R2xvYmFsVHJhbnNmb3JtKHN0LDAsMCxzdCxKLF8pLEEuX19nbG9iYWxUcmFuc2Zvcm1NYXRyaXg9bnVsbCx0aGlzW3ZdPW51bGwsdGhpcy51cGRhdGVHbG9iYWxUcmFuc2Zvcm0oKSx0aGlzLmZvcmNlVXBkYXRlKCkpfXRpY2soTD1udWxsLE49e30pe2xldHtkdXJhdGlvbjpBPTEvMH09Tix3PUUoTixbImR1cmF0aW9uIl0pO2NvbnN0IEI9dGhpcy50aW1lbGluZS5mb3JrKHcpLEQ9dGhpczt0aGlzW2xdPXRoaXNbbF18fFtdLHRoaXNbbF0ucHVzaCh7aGFuZGxlcjpMLGR1cmF0aW9uOkF9KTtjb25zdCBJPSgpPT57bGV0IGo9bnVsbCxWPW51bGw7Y29uc3QgSj0oKT0+e2NvbnN0IF89dGhpc1tsXS5tYXAoKHtoYW5kbGVyOnN0LGR1cmF0aW9uOkd9KT0+e2NvbnN0IFk9TWF0aC5taW4oMSxCLmN1cnJlbnRUaW1lL0cpO3JldHVybnt2YWx1ZTpzdD9zdChCLmN1cnJlbnRUaW1lLFkpOm51bGwscDpZfX0pO0RbU118fChEW1NdPVByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCk9PntEW21dJiZELnJlbmRlcigpLGRlbGV0ZSBEW1NdO2ZvcihsZXQgc3Q9Xy5sZW5ndGgtMTtzdD49MDtzdC0tKXtjb25zdHt2YWx1ZTpHLHA6WX09X1tzdF07KEc9PT0hMXx8WT49MSkmJnRoaXNbbF0uc3BsaWNlKHN0LDEpfXRoaXNbbF0ubGVuZ3RoPjAmJkkoKX0pKX07aWYodGhpc1t5XSYmdGhpc1t5XS5fdHlwZSE9PSJ0aWNrZXIiJiYoT2JqZWN0KGguY2FuY2VsQW5pbWF0aW9uRnJhbWUpKHRoaXNbeV0uX3JlcXVlc3RJRCksZGVsZXRlIHRoaXNbeV0pLCF0aGlzW3ldKXtjb25zdCBfPW5ldyBQcm9taXNlKHN0PT57aj1zdCxWPU9iamVjdChoLnJlcXVlc3RBbmltYXRpb25GcmFtZSkoSil9KTtfLl9yZXNvbHZlPWosXy5fcmVxdWVzdElEPVYsXy5fdHlwZT0idGlja2VyIix0aGlzW3ldPV99fTtJKCl9dG9HbG9iYWxQb3MoTCxOKXtpZih0aGlzLmxheWVyVHJhbnNmb3JtSW52ZXJ0KXtjb25zdCBqPXRoaXMudHJhbnNmb3JtTWF0cml4O0w9alswXSpMK2pbMl0qTitqWzRdLE49alsxXSpMK2pbM10qTitqWzVdfWNvbnN0e3dpZHRoOkEsaGVpZ2h0Ond9PXRoaXMuZ2V0UmVzb2x1dGlvbigpLEI9dGhpcy5yZW5kZXJPZmZzZXQsRD1bdGhpcy5jYW52YXMuY2xpZW50V2lkdGgsdGhpcy5jYW52YXMuY2xpZW50SGVpZ2h0XTtMPUwqRFswXS9BK0JbMF0sTj1OKkRbMV0vdytCWzFdO2NvbnN0IEk9dGhpcy5kaXNwbGF5UmF0aW87cmV0dXJuIEwqPUksTio9SSxbTCxOXX10b0xvY2FsUG9zKEwsTil7Y29uc3R7d2lkdGg6QSxoZWlnaHQ6d309dGhpcy5nZXRSZXNvbHV0aW9uKCksQj10aGlzLnJlbmRlck9mZnNldCxEPVt0aGlzLmNhbnZhcy5jbGllbnRXaWR0aCx0aGlzLmNhbnZhcy5jbGllbnRIZWlnaHRdO0w9TCpBL0RbMF0tQlswXSxOPU4qdy9EWzFdLUJbMV07Y29uc3QgST10aGlzLmRpc3BsYXlSYXRpbztMLz1JLE4vPUk7Y29uc3Qgaj10aGlzLmxheWVyVHJhbnNmb3JtSW52ZXJ0O3JldHVybiBqJiYoTD1qWzBdKkwralsyXSpOK2pbNF0sTj1qWzFdKkwralszXSpOK2pbNV0pLFtMLE5dfX1hLmRlZmF1bHQucmVnaXN0ZXJOb2RlKFQsImxheWVyIil9LGZ1bmN0aW9uKGcsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIHl9KTt2YXIgbj10KDIyNCksaT10KDI4OCksZj10KDIxMyksaD10KDI1MiksdT10KDcyKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gYShTLHMpe2lmKFM9PW51bGwpcmV0dXJue307dmFyIGM9ZChTLHMpLGwsdjtpZihPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKXt2YXIgVD1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKFMpO2Zvcih2PTA7djxULmxlbmd0aDt2KyspbD1UW3ZdLCEocy5pbmRleE9mKGwpPj0wKSYmT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKFMsbCkmJihjW2xdPVNbbF0pfXJldHVybiBjfWZ1bmN0aW9uIGQoUyxzKXtpZihTPT1udWxsKXJldHVybnt9O3ZhciBjPXt9LGw9T2JqZWN0LmtleXMoUyksdixUO2ZvcihUPTA7VDxsLmxlbmd0aDtUKyspdj1sW1RdLCEocy5pbmRleE9mKHYpPj0wKSYmKGNbdl09U1t2XSk7cmV0dXJuIGN9ZnVuY3Rpb24gRShTLHMsYyl7cmV0dXJuIHMgaW4gUz9PYmplY3QuZGVmaW5lUHJvcGVydHkoUyxzLHt2YWx1ZTpjLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6U1tzXT1jLFN9Y29uc3QgcD0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciLE89U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlIiksbT1TeW1ib2woInJvb3QiKSxiPVN5bWJvbCgidGFzayIpO2Z1bmN0aW9uIE0oUyxzPSEwKXtjb25zdCBjPVNbbV07aWYoYyYmYy5jaGlsZHJlblswXSl7Y29uc3QgbD1TLnN2Zyx2PVMubGF5ZXI/Uy5sYXllci5kaXNwbGF5UmF0aW86MTtpZighbC5oYXNBdHRyaWJ1dGUoImRhdGEtb3JpZ2luYWwtd2lkdGgiKSl7bGV0IEw9bC5nZXRBdHRyaWJ1dGUoIndpZHRoIik7TD1MP09iamVjdCh1LnNpemVUb1BpeGVsKShMKTozMDA7bGV0IE49bC5nZXRBdHRyaWJ1dGUoImhlaWdodCIpO049Tj9PYmplY3QodS5zaXplVG9QaXhlbCkoTik6MTUwLGwuaGFzQXR0cmlidXRlKCJ2aWV3Qm94Iil8fGwuc2V0QXR0cmlidXRlKCJ2aWV3Qm94IixgMCAwICR7TWF0aC5yb3VuZChMKX0gJHtNYXRoLnJvdW5kKE4pfWApLGwuc2V0QXR0cmlidXRlKCJkYXRhLW9yaWdpbmFsLXdpZHRoIixMKSxsLnNldEF0dHJpYnV0ZSgiZGF0YS1vcmlnaW5hbC1oZWlnaHQiLE4pfWxldCBUPVMuYXR0cmlidXRlcy53aWR0aHx8TnVtYmVyKGwuZ2V0QXR0cmlidXRlKCJkYXRhLW9yaWdpbmFsLXdpZHRoIikpLFI9Uy5hdHRyaWJ1dGVzLmhlaWdodHx8TnVtYmVyKGwuZ2V0QXR0cmlidXRlKCJkYXRhLW9yaWdpbmFsLWhlaWdodCIpKTtpZihUKj12LFIqPXYscyYmUy5hdHRyaWJ1dGVzLmZsZXhpYmxlKXtjb25zdCBMPVMuYXR0cmlidXRlcy5zY2FsZVswXTtpZihUKj1MLFIqPUwsbC5zZXRBdHRyaWJ1dGUoIndpZHRoIixUKSxsLnNldEF0dHJpYnV0ZSgiaGVpZ2h0IixSKSxUJiZSJiZTLnRleHR1cmVJbWFnZSl7Y29uc3QgTj1TLnRleHR1cmVJbWFnZS53aWR0aCxBPVMudGV4dHVyZUltYWdlLmhlaWdodCx3PVMuY2xpZW50U2l6ZTtTLmF0dHJpYnV0ZXMudGV4dHVyZVJlY3Q9WzAsMCxNYXRoLnJvdW5kKHdbMF0qTi9UKSxNYXRoLnJvdW5kKHdbMV0qQS9SKV19fWVsc2UgU1tiXXx8KGwuc2V0QXR0cmlidXRlKCJ3aWR0aCIsVCksbC5zZXRBdHRyaWJ1dGUoImhlaWdodCIsUiksU1tiXT1Qcm9taXNlLnJlc29sdmUoKS50aGVuKCgpPT57ZGVsZXRlIFNbYl07Y29uc3QgTD1jLmlubmVySFRNTCxOPW5ldyBCbG9iKFtMXSx7dHlwZToiaW1hZ2Uvc3ZnK3htbCJ9KSxBPVVSTC5jcmVhdGVPYmplY3RVUkwoTiksdz1uZXcgSW1hZ2U7dy5vbmxvYWQ9ZnVuY3Rpb24oKXt3LndpZHRoJiZ3LmhlaWdodD8oUy5hdHRyaWJ1dGVzW09dKCJ0ZXh0dXJlIix3KSxTLmF0dHJpYnV0ZXMuZmxleGlibGUmJihTLmF0dHJpYnV0ZXMudGV4dHVyZVJlY3Q9bnVsbCkpOlMuYXR0cmlidXRlc1tPXSgidGV4dHVyZSIsbnVsbCl9LHcuc3JjPUF9KSl9fWNsYXNzIHkgZXh0ZW5kcyBuLmRlZmF1bHR7Y29uc3RydWN0b3Iocz17fSl7dHlwZW9mIHM9PSJzdHJpbmciJiYocz17c3ZnVGV4dDpzfSk7bGV0e3N2Z1RleHQ6Y309cyxsPWEocyxbInN2Z1RleHQiXSk7aWYoc3VwZXIobCksdGhpc1ttXT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKSxjKXt0aGlzW21dLmlubmVySFRNTD1jO2NvbnN0IHY9dGhpc1ttXS5jaGlsZHJlblswXTt2P3Yuc2V0QXR0cmlidXRlKCJ4bWxucyIscCk6KGZldGNoKGMpLnRoZW4oVD0+VC50ZXh0KCkpLnRoZW4oVD0+e3RoaXNbbV0uaW5uZXJIVE1MPVQsKCF0aGlzLm9ic2VydmVyfHx0aGlzLmF0dHJpYnV0ZXMuZmxleGlibGUpJiZNKHRoaXMpfSksYz1udWxsKX1pZighYyl7Y29uc3Qgdj1kb2N1bWVudC5jcmVhdGVFbGVtZW50TlMocCwic3ZnIik7di5zZXRBdHRyaWJ1dGUoInhtbG5zIixwKSx0aGlzW21dLmFwcGVuZENoaWxkKHYpfWlmKHR5cGVvZiBNdXRhdGlvbk9ic2VydmVyPT0iZnVuY3Rpb24iKXtjb25zdCB2PW5ldyBNdXRhdGlvbk9ic2VydmVyKFQ9PntNKHRoaXMsITEpfSk7di5vYnNlcnZlKHRoaXNbbV0se2F0dHJpYnV0ZXM6ITAsc3VidHJlZTohMCxjaGFyYWN0ZXJEYXRhOiEwLGNoaWxkTGlzdDohMH0pLHRoaXMub2JzZXJ2ZXI9dn19Z2V0IGNoaWxkcmVuKCl7cmV0dXJuW3RoaXMuc3ZnXX1nZXQgY2hpbGROb2Rlcygpe3JldHVyblt0aGlzLnN2Z119Z2V0IHN2Zygpe3JldHVybiB0aGlzW21dP3RoaXNbbV0uY2hpbGRyZW5bMF06bnVsbH1zZXRSZXNvbHV0aW9uKHt3aWR0aDpzLGhlaWdodDpjfSl7c3VwZXIuc2V0UmVzb2x1dGlvbih7d2lkdGg6cyxoZWlnaHQ6Y30pLE0odGhpcyl9ZGlzcGF0Y2hQb2ludGVyRXZlbnQocyl7Y29uc3QgYz1zdXBlci5kaXNwYXRjaFBvaW50ZXJFdmVudChzKTtpZihjJiZ0aGlzLmF0dHJpYnV0ZXMucGFzc0V2ZW50cyYmdHlwZW9mIE1vdXNlRXZlbnQ9PSJmdW5jdGlvbiIpe2NvbnN0e3g6bCx5OnZ9PXM7bGV0W1QsUl09dGhpcy5nZXRPZmZzZXRQb3NpdGlvbihsLHYpO2NvbnN0IEw9cy5vcmlnaW5hbEV2ZW50LE49dGhpcy5hdHRyaWJ1dGVzLmFuY2hvcixBPXRoaXMuY2xpZW50U2l6ZTtUPShUK05bMF0qQVswXSkvMixSPShSK05bMV0qQVsxXSkvMjtjb25zdCB3PXMudHlwZTtpZih3PT09TC50eXBlKXtsZXQgQj1udWxsO2lmKEwgaW5zdGFuY2VvZiBNb3VzZUV2ZW50KUI9bmV3IE1vdXNlRXZlbnQodyx7c2NyZWVuWDpULHNjcmVlblk6UixjbGllbnRYOlQsY2xpZW50WTpSLGJ1YmJsZXM6TC5idWJibGVzLGJ1dHRvbjpMLmJ1dHRvbixidXR0b25zOkwuYnV0dG9ucyxjYW5jZWxCdWJibGU6TC5jYW5jZWxCdWJibGUsY2FuY2VsYWJsZTpMLmNhbmNlbGFibGUsY3VycmVudFRhcmdldDpMLmN1cnJlbnRUYXJnZXQsZnJvbUVsZW1lbnQ6TC5mcm9tRWxlbWVudCxyZWxhdGVkVGFyZ2V0OkwucmVsYXRlZFRhcmdldCxyZXR1cm5WYWx1ZTpMLnJldHVyblZhbHVlLHNyY0VsZW1lbnQ6TC5zcmNFbGVtZW50LHRhcmdldDpMLnRhcmdldCx0b0VsZW1lbnQ6TC50b0VsZW1lbnQsd2hpY2g6TC53aXRjaH0pO2Vsc2UgaWYoTCBpbnN0YW5jZW9mIFRvdWNoRXZlbnQpe2xldCBEPW51bGw7Y29uc3QgST1MLmNoYW5nZWRUb3VjaGVzfHxbTF07Zm9yKGxldCBqPTA7ajxJLmxlbmd0aDtqKyspe2NvbnN0IFY9SVtqXTtpZihzLmlkZW50aWZpZXI9PT1WLmlkZW50aWZpZXIpe0Q9VjticmVha319aWYoRCl7Y29uc3Qgaj1uZXcgVG91Y2goe2lkZW50aWZpZXI6RC5pZGVudGlmaWVyLHRhcmdldDpELnRhcmdldCxjbGllbnRYOlQsY2xpZW50WTpSLHNjcmVlblg6VCxzY3JlZW5ZOlIscGFnZVg6VCxwYWdlWTpSLHJhZGl1c1g6RC5yYWRpdXNYLHJhZGl1c1k6RC5yYWRpdXNZLHJvdGF0aW9uQW5nbGU6RC5yb3RhdGlvbkFuZ2xlLGZvcmNlOkQuZm9yY2V9KTtCPW5ldyBUb3VjaEV2ZW50KHcse2NhbmNlbGFibGU6TC5jYW5jZWxhYmxlLGJ1YmJsZXM6TC5idWJibGVzLGNvbXBvc2VkOkwuY29tcG9zZWQsdG91Y2hlczpbal0sdGFyZ2V0VG91Y2hlczpbal0sY2hhbmdlZFRvdWNoZXM6W2pdfSl9fWVsc2UgQj1MO0ImJnRoaXMuc3ZnLmRpc3BhdGNoRXZlbnQoQil9fXJldHVybiBjfWdldEVsZW1lbnRCeUlkKHMpe3JldHVybiBPYmplY3QoaC5xdWVyeVNlbGVjdG9yKShgIyR7c31gLHRoaXMpfWdldEVsZW1lbnRzQnlDbGFzc05hbWUocyl7cmV0dXJuIE9iamVjdChoLnF1ZXJ5U2VsZWN0b3JBbGwpKGAuJHtzfWAsdGhpcyl9Z2V0RWxlbWVudHNCeU5hbWUocyl7cmV0dXJuIE9iamVjdChoLnF1ZXJ5U2VsZWN0b3JBbGwpKGBbbmFtZT0iJHtzfSJdYCx0aGlzKX1nZXRFbGVtZW50c0J5VGFnTmFtZShzKXtyZXR1cm4gT2JqZWN0KGgucXVlcnlTZWxlY3RvckFsbCkocyx0aGlzKX1xdWVyeVNlbGVjdG9yKHMpe3JldHVybiBPYmplY3QoaC5xdWVyeVNlbGVjdG9yKShzLHRoaXMpfXF1ZXJ5U2VsZWN0b3JBbGwocyl7cmV0dXJuIE9iamVjdChoLnF1ZXJ5U2VsZWN0b3JBbGwpKHMsdGhpcyl9b25Qcm9wZXJ0eUNoYW5nZShzLGMsbCl7c3VwZXIub25Qcm9wZXJ0eUNoYW5nZShzLGMsbCkscz09PSJmbGV4aWJsZSImJk0odGhpcyksdGhpcy5hdHRyaWJ1dGVzLmZsZXhpYmxlJiYocz09PSJ3aWR0aCJ8fHM9PT0iaGVpZ2h0Inx8cz09PSJzY2FsZSJ8fHM9PT0idHJhbnNmb3JtIikmJk0odGhpcyl9fUUoeSwiQXR0ciIsaS5kZWZhdWx0KSxmLmRlZmF1bHQucmVnaXN0ZXJOb2RlKHksInNwcml0ZXN2ZyIpfSxmdW5jdGlvbihnLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiB1fSk7dmFyIG49dCgyMjUpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCBpPVN5bWJvbC5mb3IoInNwcml0ZWpzX2dldEF0dHJpYnV0ZSIpLGY9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlIiksaD1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGVEZWZhdWx0Iik7Y2xhc3MgdSBleHRlbmRzIG4uZGVmYXVsdHtjb25zdHJ1Y3RvcihkKXtzdXBlcihkKSx0aGlzW2hdKHtwYXNzRXZlbnRzOiExLGZsZXhpYmxlOiExfSl9Z2V0IHRleHR1cmUoKXtyZXR1cm4gdGhpc1tpXSgidGV4dHVyZSIpfXNldCB0ZXh0dXJlKGQpe31nZXQgcGFzc0V2ZW50cygpe3JldHVybiB0aGlzW2ldKCJwYXNzRXZlbnRzIil9c2V0IHBhc3NFdmVudHMoZCl7cmV0dXJuIHRoaXNbZl0oInBhc3NFdmVudHMiLGQpfWdldCBmbGV4aWJsZSgpe3JldHVybiB0aGlzW2ldKCJmbGV4aWJsZSIpfXNldCBmbGV4aWJsZShkKXtyZXR1cm4gdGhpc1tmXSgiZmxleGlibGUiLGQpfX19LGZ1bmN0aW9uKGcsZSx0KXt0LnIoZSk7dmFyIG49dCgxMik7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIGkoZCxFKXt2YXIgcD1PYmplY3Qua2V5cyhkKTtpZihPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKXt2YXIgTz1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGQpO0UmJihPPU8uZmlsdGVyKGZ1bmN0aW9uKG0pe3JldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGQsbSkuZW51bWVyYWJsZX0pKSxwLnB1c2guYXBwbHkocCxPKX1yZXR1cm4gcH1mdW5jdGlvbiBmKGQpe2Zvcih2YXIgRT0xO0U8YXJndW1lbnRzLmxlbmd0aDtFKyspe3ZhciBwPWFyZ3VtZW50c1tFXSE9bnVsbD9hcmd1bWVudHNbRV06e307RSUyP2koT2JqZWN0KHApLCEwKS5mb3JFYWNoKGZ1bmN0aW9uKE8pe2goZCxPLHBbT10pfSk6T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnM/T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZCxPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhwKSk6aShPYmplY3QocCkpLmZvckVhY2goZnVuY3Rpb24oTyl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGQsTyxPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHAsTykpfSl9cmV0dXJuIGR9ZnVuY3Rpb24gaChkLEUscCl7cmV0dXJuIEUgaW4gZD9PYmplY3QuZGVmaW5lUHJvcGVydHkoZCxFLHt2YWx1ZTpwLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6ZFtFXT1wLGR9Y29uc3QgdT1TeW1ib2woImluaXRlZCIpO2xldCBhPW51bGw7dHlwZW9mIFdvcmtlcj09ImZ1bmN0aW9uIiYmKGE9Y2xhc3MgZXh0ZW5kcyBXb3JrZXJ7Y29uc3RydWN0b3IoZCl7aWYoZC53b3JrZXI9PT0hMCYmKGQud29ya2VyPWAuLyR7ZC5pZH0ud29ya2VyLmpzYCksc3VwZXIoZC53b3JrZXIpLHRoaXMub3B0aW9ucz1kLCFkLmNhbnZhcyl7Y29uc3R7d2lkdGg6RSxoZWlnaHQ6cH09dGhpcy5nZXRSZXNvbHV0aW9uKCksTz1uLkVOVi5jcmVhdGVDYW52YXMoRSxwLHtvZmZzY3JlZW46ITF9KTtPLnN0eWxlJiYoTy5zdHlsZS5wb3NpdGlvbj0iYWJzb2x1dGUiKSxPLmRhdGFzZXQmJihPLmRhdGFzZXQubGF5ZXJJZD1kLmlkKSxkLmNhbnZhcz1PfXRoaXMuY2FudmFzPWQuY2FudmFzfWdldCBpZCgpe3JldHVybiB0aGlzLm9wdGlvbnMuaWR9c2V0UmVzb2x1dGlvbih7d2lkdGg6ZCxoZWlnaHQ6RX0pe2lmKHRoaXNbdV0pdGhpcy5wb3N0TWVzc2FnZSh7dHlwZToicmVzb2x1dGlvbl9jaGFuZ2UiLHdpZHRoOmQsaGVpZ2h0OkV9KTtlbHNle3RoaXMuY2FudmFzLndpZHRoPWQsdGhpcy5jYW52YXMuaGVpZ2h0PUU7Y29uc3QgcD10aGlzLm9wdGlvbnMsTz1wLmNhbnZhcy50cmFuc2ZlckNvbnRyb2xUb09mZnNjcmVlbigpLG09Zih7fSxwKTtkZWxldGUgbS5jb250YWluZXIsbS5jYW52YXM9Tyx0aGlzLnBvc3RNZXNzYWdlKHt0eXBlOiJjcmVhdGUiLG9wdGlvbnM6bX0sW09dKSx0aGlzW3VdPSEwfX1nZXRSZXNvbHV0aW9uKCl7aWYodGhpcy5jYW52YXMpe2NvbnN0e3dpZHRoOmQsaGVpZ2h0OkV9PXRoaXMuY2FudmFzO3JldHVybnt3aWR0aDpkLGhlaWdodDpFfX1yZXR1cm57d2lkdGg6MzAwLGhlaWdodDoxNTB9fXJlbW92ZSgpe3JldHVybiB0aGlzLnBhcmVudCYmdGhpcy5wYXJlbnQucmVtb3ZlQ2hpbGQ/KHRoaXMucGFyZW50LnJlbW92ZUNoaWxkKHRoaXMpLCEwKTohMX1jb25uZWN0KGQsRSl7T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInBhcmVudCIse3ZhbHVlOmQsd3JpdGFibGU6ITEsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInpPcmRlciIse3ZhbHVlOkUsd3JpdGFibGU6ITEsY29uZmlndXJhYmxlOiEwfSl9ZGlzY29ubmVjdCgpe2RlbGV0ZSB0aGlzLnBhcmVudCxkZWxldGUgdGhpcy56T3JkZXJ9ZGlzcGF0Y2hQb2ludGVyRXZlbnQoZCl7dGhpcy5wb3N0TWVzc2FnZSh7dHlwZToiZXZlbnQiLGV2ZW50OntjYW5jZWxCdWJibGU6ZC5jYW5jZWxCdWJibGUsYnViYmxlczpkLmJ1YmJsZXMsZGV0YWlsOmQuZGV0YWlsLGlkZW50aWZpZXI6ZC5pZGVudGlmaWVyLGxheWVyWDpkLmxheWVyWCxsYXllclk6ZC5sYXllclksb3JpZ2luYWxYOmQub3JpZ2luYWxYLG9yaWdpbmFsWTpkLm9yaWdpbmFsWSx0eXBlOmQudHlwZSx4OmQueCx5OmQueX19KX19KSxlLmRlZmF1bHQ9YX0sZnVuY3Rpb24oZyxlLHQpe3QucihlKSwoZnVuY3Rpb24obil7dC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIFR9KTt2YXIgaT10KDEyKSxmPXQoNjgpLGg9dCg3MCksdT10KDI4NiksYT10KDI4OSksZD10KDI1MCksRT10KDI5MSkscD10KDIxNCksTz10KDIxOCksbT10KDIxMyk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IGI9U3ltYm9sKCJlbnRlcmVkVGFyZ2V0cyIpO2Z1bmN0aW9uIE0oUil7cmV0dXJuIFIuaWQ9Ui5pZHx8YF9sYXllciR7TWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMiwxMil9YCxSLmRhdGFzZXR8fChSLmRhdGFzZXQ9e30pLFIuZGF0YXNldC5sYXllcklkPVIuaWQsUi5jb25uZWN0PShMLE4pPT57Ui5wYXJlbnQ9TCxPYmplY3QuZGVmaW5lUHJvcGVydHkoUiwiek9yZGVyIix7dmFsdWU6Tix3cml0YWJsZTohMSxjb25maWd1cmFibGU6ITB9KX0sUi5kaXNjb25uZWN0PUw9PntkZWxldGUgUi56T3JkZXJ9LFIuY2FudmFzPVIsUi5nZXRSZXNvbHV0aW9uPSgpPT4oe3dpZHRoOjAsaGVpZ2h0OjB9KSxSLnNldFJlc29sdXRpb249KCk9PiExLFIub3B0aW9ucz17aGFuZGxlRXZlbnQ6ITF9LFJ9ZnVuY3Rpb24geShSLEwpe2NvbnN0IE49Ui5jaGlsZHJlbjtsZXQgQT1udWxsO2ZvcihsZXQgdz0wO3c8Ti5sZW5ndGg7dysrKXtjb25zdCBCPU5bd107aWYoKEw9PT1CfHxBIT1udWxsKSYmKEE9QiksQSYmQSE9PUwmJiFBLm9mZnNjcmVlbilyZXR1cm4gQS5jYW52YXN9cmV0dXJuIG51bGx9ZnVuY3Rpb24gUyhSLEwpe2NvbnN0W04sQV09Ui5yZW5kZXJPZmZzZXQse3dpZHRoOncsaGVpZ2h0OkJ9PVIuZ2V0UmVzb2x1dGlvbigpLEQ9Ui5kaXNwbGF5UmF0aW87Ui5yZW5kZXJlci5kcmF3SW1hZ2UoTC5jYW52YXMsLU4vRCwtQS9ELHcvRCxCL0QpfWNvbnN0IHM9e307ZnVuY3Rpb24gYyhSKXtjb25zdCBMPVsibW91c2Vkb3duIiwibW91c2V1cCIsIm1vdXNlbW92ZSIsIm1vdXNld2hlZWwiLCJ3aGVlbCIsInRvdWNoc3RhcnQiLCJ0b3VjaGVuZCIsInRvdWNobW92ZSIsInRvdWNoY2FuY2VsIiwiY2xpY2siLCJkYmxjbGljayIsImxvbmdwcmVzcyIsInRhcCIsImNvbnRleHRtZW51Il0sTj1SLmNvbnRhaW5lcjtOLmFkZEV2ZW50TGlzdGVuZXIoIm1vdXNlbGVhdmUiLEE9Pntjb25zdCB3PVJbYl07aWYody5zaXplKXtjb25zdCBCPW5ldyBwLmRlZmF1bHQoIm1vdXNlbGVhdmUiKTtCLnNldE9yaWdpbmFsRXZlbnQoQSksWy4uLnddLmZvckVhY2goRD0+e0QuZGlzcGF0Y2hFdmVudChCKX0pLFJbYl0uY2xlYXIoKX19LHtwYXNzaXZlOiEwfSksTC5mb3JFYWNoKEE9PntOLmFkZEV2ZW50TGlzdGVuZXIoQSx3PT57Y29uc3R7bGVmdDpCLHRvcDpELGRpc3BsYXlSYXRpbzpJfT1SLm9wdGlvbnMsaj1SLm9yZGVyZWRDaGlsZHJlbjtPYmplY3QoRS5kZWZhdWx0KSh3LHtvZmZzZXRMZWZ0OkIsb2Zmc2V0VG9wOkQsZGlzcGxheVJhdGlvOkl9KS5mb3JFYWNoKEo9Pntjb25zdCBfPUouaWRlbnRpZmllcjtpZihKLnR5cGU9PT0idG91Y2htb3ZlInx8Si50eXBlPT09InRvdWNoZW5kIil7Y29uc3QgRz1zW19dO0cmJkcuZGlzcGF0Y2hFdmVudChKKSxKLnR5cGU9PT0idG91Y2hlbmQiJiZkZWxldGUgc1tfXX1lbHNle2ZvcihsZXQgRz1qLmxlbmd0aC0xO0c+PTA7Ry0tKXtjb25zdCBZPWpbR107aWYoWS5vcHRpb25zLmhhbmRsZUV2ZW50IT09ITEpe2lmKFkuZGlzcGF0Y2hQb2ludGVyRXZlbnQoSikmJkoudGFyZ2V0IT09WSlicmVhaztKLmNhbmNlbEJ1YmJsZT0hMX19aWYoSi50YXJnZXQ9PT1qWzBdKWZvcihsZXQgRz1qLmxlbmd0aC0xO0c+PTA7Ry0tKXtjb25zdCBZPWpbR107aWYoWS5vcHRpb25zLmhhbmRsZUV2ZW50IT09ITEpe0oudGFyZ2V0PVk7YnJlYWt9fX1jb25zdCBzdD1KLnRhcmdldDtpZihKLnR5cGU9PT0idG91Y2hzdGFydCImJihzW19dPUoudGFyZ2V0KSxKLnR5cGU9PT0ibW91c2Vtb3ZlIil7Y29uc3QgRz1SW2JdO2xldCBZO2lmKHN0KXtjb25zdCBhdD1zdC5hbmNlc3RvcnN8fFtdO1k9bmV3IFNldChbc3QsLi4uYXRdKX1lbHNlIFk9bmV3IFNldDtjb25zdCBydD1PYmplY3QuZW50cmllcyh3KTtpZighRy5oYXMoc3QpJiZzdCl7Y29uc3QgYXQ9bmV3IHAuZGVmYXVsdCgibW91c2VlbnRlciIpO2F0LnNldE9yaWdpbmFsRXZlbnQodykscnQuZm9yRWFjaCgoW2l0LE10XSk9PnthdFtpdF09TXR9KSxHLmFkZChzdCksc3QuZGlzcGF0Y2hFdmVudChhdCk7Y29uc3QgaHQ9c3QuYW5jZXN0b3JzO2h0JiZodC5mb3JFYWNoKGl0PT57aXQgaW5zdGFuY2VvZiBoLmRlZmF1bHQmJiFHLmhhcyhpdCkmJihHLmFkZChpdCksaXQuZGlzcGF0Y2hFdmVudChhdCkpfSl9Y29uc3Qgb3Q9bmV3IHAuZGVmYXVsdCgibW91c2VsZWF2ZSIpO290LnNldE9yaWdpbmFsRXZlbnQodykscnQuZm9yRWFjaCgoW2F0LGh0XSk9PntvdFthdF09aHR9KSxbLi4uR10uZm9yRWFjaChhdD0+e1kuaGFzKGF0KXx8KEcuZGVsZXRlKGF0KSxhdC5kaXNwYXRjaEV2ZW50KG90KSl9KX19KX0se3Bhc3NpdmU6QSE9PSJjb250ZXh0bWVudSJ9KX0pfWZ1bmN0aW9uIGwoUixMKXtpZihMJiZMLnN0eWxlKXtsZXR7d2lkdGg6TixoZWlnaHQ6QSxtb2RlOncsY29udGFpbmVyOkJ9PVI7Y29uc3R7Y2xpZW50V2lkdGg6RCxjbGllbnRIZWlnaHQ6SX09QjtOPU58fEQsQT1BfHxJLHc9PT0ic3RhdGljIj8oTC5zdHlsZS53aWR0aD1gJHtOfXB4YCxMLnN0eWxlLmhlaWdodD1gJHtBfXB4YCk6KEwuc3R5bGUudG9wPSIwIixMLnN0eWxlLmxlZnQ9IjAiLEwuc3R5bGUud2lkdGg9YCR7RH1weGAsTC5zdHlsZS5oZWlnaHQ9YCR7SX1weGAsTC5zdHlsZS50cmFuc2Zvcm09IiIsTC5zdHlsZS53ZWJraXRUcmFuc2Zvcm09IiIpfX1jb25zdCB2PVN5bWJvbCgib2Zmc2NyZWVuTGF5ZXJDb3VudCIpO2NsYXNzIFQgZXh0ZW5kcyBkLmRlZmF1bHR7Y29uc3RydWN0b3IoTD17fSl7aWYoc3VwZXIoKSwhTC5jb250YWluZXIpaWYodHlwZW9mIGkuRU5WLkNvbnRhaW5lcj09ImZ1bmN0aW9uIilMLmNvbnRhaW5lcj1uZXcgaS5FTlYuQ29udGFpbmVyKEwud2lkdGh8fDMwMCxMLmhlaWdodHx8MTUwKTtlbHNlIHRocm93IG5ldyBFcnJvcigiTm8gY29udGFpbmVyIHNwZWNpZmllZC4iKTtpZih0aGlzLmNvbnRhaW5lcj1MLmNvbnRhaW5lcix0aGlzLmNvbnRhaW5lci5zdHlsZSYmKHRoaXMuY29udGFpbmVyLnN0eWxlLm92ZXJmbG93fHwodGhpcy5jb250YWluZXIuc3R5bGUub3ZlcmZsb3c9ImhpZGRlbiIpLHRoaXMuY29udGFpbmVyLnN0eWxlLnBvc2l0aW9ufHwodGhpcy5jb250YWluZXIuc3R5bGUucG9zaXRpb249InJlbGF0aXZlIikpLHRoaXMub3B0aW9ucz1MLEwuZGlzcGxheVJhdGlvPUwuZGlzcGxheVJhdGlvfHwxLEwubW9kZT1MLm1vZGV8fCJzY2FsZSIsTC5sZWZ0PTAsTC50b3A9MCxMLmF1dG9SZXNpemU9TC5hdXRvUmVzaXplIT09ITEsTC5hdXRvUmVzaXplKXtsZXQgTjtpZih0eXBlb2YgZ2xvYmFsVGhpczwidSI/Tj1nbG9iYWxUaGlzOk49dHlwZW9mIHdpbmRvdzwidSI/d2luZG93Om4sTi5hZGRFdmVudExpc3RlbmVyKXtjb25zdCBBPXRoaXM7Ti5hZGRFdmVudExpc3RlbmVyKCJyZXNpemUiLGZ1bmN0aW9uIHcoKXt0eXBlb2YgZG9jdW1lbnQ8InUiJiZkb2N1bWVudC5jb250YWlucyhBLmNvbnRhaW5lcik/QS5yZXNpemUoKTpOLnJlbW92ZUV2ZW50TGlzdGVuZXIoInJlc2l6ZSIsdyl9KX19dGhpc1tiXT1uZXcgU2V0LHRoaXMuc2V0UmVzb2x1dGlvbihMKSxjKHRoaXMpLHRoaXNbdl09MH1nZXQgaGFzT2Zmc2NyZWVuQ2FudmFzKCl7cmV0dXJuIHRoaXNbdl0+MH1zZXQgZGlzcGxheVJhdGlvKEwpe3RoaXMub3B0aW9ucy5kaXNwbGF5UmF0aW8hPT1MJiYodGhpcy5vcHRpb25zLmRpc3BsYXlSYXRpbz1MLHRoaXMucmVzaXplKCkpfWdldCBkaXNwbGF5UmF0aW8oKXtyZXR1cm4gdGhpcy5vcHRpb25zLmRpc3BsYXlSYXRpb31zZXQgaGVpZ2h0KEwpe3RoaXMub3B0aW9ucy5oZWlnaHQhPT1MJiYodGhpcy5vcHRpb25zLmhlaWdodD1MLHRoaXMucmVzaXplKCkpfWdldCBoZWlnaHQoKXtyZXR1cm4gdGhpcy5vcHRpb25zLmhlaWdodH1zZXQgbW9kZShMKXt0aGlzLm9wdGlvbnMubW9kZSE9PUwmJih0aGlzLm9wdGlvbnMubW9kZT1MLHRoaXMucmVzaXplKCkpfWdldCBtb2RlKCl7cmV0dXJuIHRoaXMub3B0aW9ucy5tb2RlfXNldCB3aWR0aChMKXt0aGlzLm9wdGlvbnMud2lkdGghPT1MJiYodGhpcy5vcHRpb25zLndpZHRoPUwsdGhpcy5yZXNpemUoKSl9Z2V0IHdpZHRoKCl7cmV0dXJuIHRoaXMub3B0aW9ucy53aWR0aH1hcHBlbmRDaGlsZChMKXshKEwgaW5zdGFuY2VvZiB1LmRlZmF1bHQpJiYhKEwgaW5zdGFuY2VvZiBhLmRlZmF1bHQpJiZNKEwpO2NvbnN0IE49c3VwZXIuYXBwZW5kQ2hpbGQoTCksQT1MLmNhbnZhcztyZXR1cm4gTC5vZmZzY3JlZW4/dGhpc1t2XSsrOnRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKEEpLGwodGhpcy5vcHRpb25zLEEpLEwuc2V0UmVzb2x1dGlvbih0aGlzLmdldFJlc29sdXRpb24oKSksTn1mb3JjZVVwZGF0ZSgpe3RoaXMuaGFzT2Zmc2NyZWVuQ2FudmFzJiYhdGhpcy5fcmVxdWVzdElEJiYodGhpcy5fcmVxdWVzdElEPU9iamVjdChmLnJlcXVlc3RBbmltYXRpb25GcmFtZSkoKCk9PntkZWxldGUgdGhpcy5fcmVxdWVzdElELHRoaXMucmVuZGVyKCl9KSl9aW5zZXJ0QmVmb3JlKEwsTil7IShMIGluc3RhbmNlb2YgdS5kZWZhdWx0KSYmIShMIGluc3RhbmNlb2YgYS5kZWZhdWx0KSYmTShMKTtjb25zdCBBPXN1cGVyLmluc2VydEJlZm9yZShMLE4pLHc9TC5jYW52YXM7aWYoIUwub2Zmc2NyZWVuKXtjb25zdCBCPXkodGhpcyxMKTt0aGlzLmNvbnRhaW5lci5pbnNlcnRCZWZvcmUodyxCKX1yZXR1cm4gbCh0aGlzLm9wdGlvbnMsdyksTC5zZXRSZXNvbHV0aW9uKHRoaXMuZ2V0UmVzb2x1dGlvbigpKSxBfWxheWVyKEw9ImRlZmF1bHQiLE49e30pe049T2JqZWN0LmFzc2lnbih7fSx0aGlzLm9wdGlvbnMsTiksTi5pZD1MO2NvbnN0IEE9dGhpcy5vcmRlcmVkQ2hpbGRyZW47Zm9yKGxldCBEPTA7RDxBLmxlbmd0aDtEKyspaWYoQVtEXS5pZD09PUwpcmV0dXJuIEFbRF07Y29uc3Qgdz1OLndvcmtlcjtsZXQgQjtyZXR1cm4gdz9CPW5ldyBhLmRlZmF1bHQoTik6Qj1uZXcgdS5kZWZhdWx0KE4pLHRoaXMuYXBwZW5kQ2hpbGQoQiksQn1hc3luYyBwcmVsb2FkKC4uLkwpe2NvbnN0IE49W10sQT1bXSx3PVtdO2ZvcihsZXQgQj0wO0I8TC5sZW5ndGg7QisrKXtjb25zdCBEPUxbQl07bGV0IEk7aWYodHlwZW9mIEQ9PSJzdHJpbmciKUk9T2JqZWN0KE8ubG9hZFRleHR1cmUpKEQpO2Vsc2UgaWYoQXJyYXkuaXNBcnJheShEKSlJPU9iamVjdChPLmxvYWRGcmFtZXMpKC4uLkQpO2Vsc2V7Y29uc3R7aWQ6aixzcmM6Vn09RDtJPU9iamVjdChPLmxvYWRUZXh0dXJlKShWLGopfUkgaW5zdGFuY2VvZiBQcm9taXNlfHwoST1Qcm9taXNlLnJlc29sdmUoSSkpLEEucHVzaChJLnRoZW4oaj0+e04ucHVzaChqKSx3W0JdPWo7Y29uc3QgVj1uZXcgcC5kZWZhdWx0KHt0eXBlOiJwcmVsb2FkIixkZXRhaWw6e2N1cnJlbnQ6aixsb2FkZWQ6TixyZXNvdXJjZXM6TH19KTt0aGlzLmRpc3BhdGNoRXZlbnQoVil9KSl9cmV0dXJuIGF3YWl0IFByb21pc2UuYWxsKEEpLHd9cmVtb3ZlQ2hpbGQoTCl7Y29uc3QgTj1zdXBlci5yZW1vdmVDaGlsZChMKTtpZihOKXtMLl9wcmVwYXJlUmVuZGVyRmluaXNoZWQmJkwuX3ByZXBhcmVSZW5kZXJGaW5pc2hlZCgpO2NvbnN0IEE9TC5jYW52YXM7QSYmQS5yZW1vdmUmJkEucmVtb3ZlKCksTC5vZmZzY3JlZW4mJnRoaXNbdl0tLX1yZXR1cm4gTn1yZW5kZXIoKXtjb25zdCBMPXRoaXMub3JkZXJlZENoaWxkcmVuO2xldCBOPW51bGw7Y29uc3QgQT1bXTtmb3IobGV0IHc9MDt3PEwubGVuZ3RoO3crKyl7Y29uc3QgQj1MW3ddLEQ9QS5sZW5ndGg+MDtpZihCIGluc3RhbmNlb2YgdS5kZWZhdWx0JiYhQi5vZmZzY3JlZW4paWYoIUIuYXV0b1JlbmRlcilEJiYoY29uc29sZS53YXJuKCJTb21lIG9mZnNjcmVlbiBjYW52YXMgd2lsbCBub3QgYmUgcmVuZGVyZWQuIiksQS5sZW5ndGg9MCk7ZWxzZSBpZihOPUIsRCl7Qi5yZW5kZXJlci5jbGVhcigpO2ZvcihsZXQgST0wO0k8QS5sZW5ndGg7SSsrKXtjb25zdCBqPUFbSV07ai5yZW5kZXIoKSxTKEIsail9QS5sZW5ndGg9MCxCLnJlbmRlcih7Y2xlYXI6ITF9KX1lbHNlIEIucHJlcGFyZVJlbmRlciYmQi5yZW5kZXIoKTtlbHNlIEIub2Zmc2NyZWVuP04/KEIucHJlcGFyZVJlbmRlciYmQi5yZW5kZXIoKSxTKE4sQikpOkEucHVzaChCKTpCIGluc3RhbmNlb2YgYS5kZWZhdWx0JiZEJiYoY29uc29sZS53YXJuKCJTb21lIG9mZnNjcmVlbiBjYW52YXMgd2lsbCBub3QgYmUgcmVuZGVyZWQuIiksQS5sZW5ndGg9MCl9fXJlcGxhY2VDaGlsZChMLE4pe2NvbnN0IEE9c3VwZXIucmVwbGFjZUNoaWxkKEwsTik7Ti5jYW52YXMucmVtb3ZlJiZOLmNhbnZhcy5yZW1vdmUoKSxOLm9mZnNjcmVlbiYmdGhpc1t2XS0tO2NvbnN0IHc9TC5jYW52YXM7aWYoIUwub2Zmc2NyZWVuKXtjb25zdCBCPXkodGhpcyxMKTt0aGlzLmNvbnRhaW5lci5pbnNlcnRCZWZvcmUodyxCKX1yZXR1cm4gbCh0aGlzLm9wdGlvbnMsdyksTC5zZXRSZXNvbHV0aW9uKHRoaXMuZ2V0UmVzb2x1dGlvbigpKSxBfXJlc2l6ZSgpe2NvbnN0IEw9dGhpcy5vcHRpb25zO3RoaXMuY2hpbGRyZW4uZm9yRWFjaChOPT57bChMLE4uY2FudmFzKX0pLHRoaXMuc2V0UmVzb2x1dGlvbihMKSx0aGlzLmRpc3BhdGNoRXZlbnQoe3R5cGU6InJlc2l6ZSJ9KX1zZXRSZXNvbHV0aW9uKHt3aWR0aDpMLGhlaWdodDpOfT17fSl7Y29uc3QgQT10aGlzLmNvbnRhaW5lcix7Y2xpZW50V2lkdGg6dyxjbGllbnRIZWlnaHQ6Qn09QTsoTD09bnVsbHx8Tj09bnVsbCkmJihMPUw/P3csTj1OPz9CKTtjb25zdHttb2RlOkQsZGlzcGxheVJhdGlvOkl9PXRoaXMub3B0aW9ucztpZihMKj1JLE4qPUksdGhpcy5vcHRpb25zLmxlZnQ9MCx0aGlzLm9wdGlvbnMudG9wPTAsRD09PSJzdGlja3lIZWlnaHQifHxEPT09InN0aWNreUxlZnQifHxEPT09InN0aWNreVJpZ2h0Iil7Y29uc3Qgaj1MO0w9dypOL0IsRD09PSJzdGlja3lIZWlnaHQiJiYodGhpcy5vcHRpb25zLmxlZnQ9LjUqKEwtaikpLEQ9PT0ic3RpY2t5UmlnaHQiJiYodGhpcy5vcHRpb25zLmxlZnQ9TC1qKX1lbHNlIGlmKEQ9PT0ic3RpY2t5V2lkdGgifHxEPT09InN0aWNreVRvcCJ8fEQ9PT0ic3RpY2t5Qm90dG9tIil7Y29uc3Qgaj1OO049QipML3csRD09PSJzdGlja3lXaWR0aCImJih0aGlzLm9wdGlvbnMudG9wPS41KihOLWopKSxEPT09InN0aWNreUJvdHRvbSImJih0aGlzLm9wdGlvbnMudG9wPU4tail9c3VwZXIuc2V0UmVzb2x1dGlvbih7d2lkdGg6TCxoZWlnaHQ6Tn0pfXNuYXBzaG90KHtvZmZzY3JlZW46TD0hMSxsYXllcnM6Tn09e30pe2NvbnN0IEE9TD8ic25hcHNob3RPZmZTY3JlZW5DYW52YXMiOiJzbmFwc2hvdENhbnZhcyIse3dpZHRoOncsaGVpZ2h0OkJ9PXRoaXMuZ2V0UmVzb2x1dGlvbigpO3RoaXNbQV09dGhpc1tBXXx8aS5FTlYuY3JlYXRlQ2FudmFzKHcsQix7b2Zmc2NyZWVuOkx9KTtjb25zdCBEPXRoaXNbQV0uZ2V0Q29udGV4dCgiMmQiKTtOPU58fHRoaXMub3JkZXJlZENoaWxkcmVuLHRoaXNbQV0ud2lkdGg9dyx0aGlzW0FdLmhlaWdodD1CO2ZvcihsZXQgST0wO0k8Ti5sZW5ndGg7SSsrKXtjb25zdCBqPU5bSV07aWYoIWoub3B0aW9ucy5pZ25vcmVTbmFwc2hvdCl7ai5yZW5kZXImJmoucmVuZGVyKCk7Y29uc3QgVj1qLmNhbnZhcztWJiZWIT09aiYmRC5kcmF3SW1hZ2UoViwwLDAsdyxCKX19cmV0dXJuIHRoaXNbQV19fXR5cGVvZiBkb2N1bWVudDwidSImJihULnByb3RvdHlwZS5sYXllcjNkPWZ1bmN0aW9uKFIsTD17fSl7Y29uc3QgTj1MLnVybHx8Imh0dHBzOi8vdW5wa2cuY29tL3Nwcml0ZS1leHRlbmQtM2QvZGlzdC9zcHJpdGUtZXh0ZW5kLTNkLm1pbi5qcyI7cmV0dXJuIG5ldyBQcm9taXNlKChBLHcpPT57Y29uc3QgQj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJzY3JpcHQiKTtCLmFzeW5jPSExLEIuc3JjPU4sQi5vbmxvYWQ9KCk9Pnt0cnl7QSh0aGlzLmxheWVyM2QoUixMKSl9Y2F0Y2goRCl7dyhEKX19LGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZChCKX0pfSksbS5kZWZhdWx0LnJlZ2lzdGVyTm9kZShULCJzY2VuZSIpfSkuY2FsbCh0aGlzLHQoMjIpKX0sZnVuY3Rpb24oZyxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gaX0pO3ZhciBuPXQoMjE0KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gaShmLHtvZmZzZXRUb3A6aD0wLG9mZnNldExlZnQ6dT0wLGRpc3BsYXlSYXRpbzphPTF9PXt9KXtsZXQgZCxFO2NvbnN0IHA9W10se2xlZnQ6Tyx0b3A6bSx3aWR0aDpiLGhlaWdodDpNfT1mLnRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSx5PWYudGFyZ2V0LndpZHRoLFM9Zi50YXJnZXQuaGVpZ2h0LHM9Zi5jaGFuZ2VkVG91Y2hlc3x8W2ZdO2ZvcihsZXQgbD0wO2w8cy5sZW5ndGg7bCsrKXtjb25zdCB2PXNbbF0sVD12LmlkZW50aWZpZXIse2NsaWVudFg6UixjbGllbnRZOkx9PXY7UiE9bnVsbCYmTCE9bnVsbCYmcC5wdXNoKHt4Ok1hdGgucm91bmQoKFJ8MCktTykseTpNYXRoLnJvdW5kKChMfDApLW0pLGlkZW50aWZpZXI6VH0pfXAubGVuZ3RoPD0wJiZwLnB1c2goe3g6ZCx5OkV9KTtjb25zdCBjPVtdO3JldHVybiBwLmZvckVhY2gobD0+e2wueCE9bnVsbCYmbC55IT1udWxsJiYoZD0obC54KnkvYi11KS9hLEU9KGwueSpTL00taCkvYSk7Y29uc3Qgdj1uZXcgbi5kZWZhdWx0KGYpO09iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHYse2xheWVyWDp7dmFsdWU6ZCxjb25maWd1cmFibGU6ITB9LGxheWVyWTp7dmFsdWU6RSxjb25maWd1cmFibGU6ITB9LG9yaWdpbmFsWDp7dmFsdWU6bC54fSxvcmlnaW5hbFk6e3ZhbHVlOmwueX0seDp7dmFsdWU6ZCxjb25maWd1cmFibGU6ITB9LHk6e3ZhbHVlOkUsY29uZmlndXJhYmxlOiEwfSxpZGVudGlmaWVyOnt2YWx1ZTpsLmlkZW50aWZpZXJ9fSksYy5wdXNoKHYpfSksY319XSk7bGUudmVyc2lvbixsZS5BcmMsbGUuQmxvY2ssbGUuQ2xvdWQsbGUuQ29sb3I7Y29uc3QgV2E9bGUuRWxsaXBzZTtsZS5HcmFkaWVudDtjb25zdCBJcj1sZS5Hcm91cCx5bT1sZS5MYWJlbDtsZS5MYXllcixsZS5MYXllcldvcmtlcixsZS5Ob2RlLGxlLlBhcmFsbGVsO2NvbnN0IEhyPWxlLlBhdGgsY249bGUuUG9seWxpbmUsZ3M9bGUuUmVjdDtsZS5SZWd1bGFyLGxlLlJpbmc7Y29uc3QgeG09bGUuU2NlbmU7bGUuU3ByaXRlLGxlLlNwcml0ZVN2ZyxsZS5TdGFyLGxlLlRyaWFuZ2xlLGxlLmhlbHBlcnMsbGUuY3JlYXRlRWxlbWVudCxsZS5pc1Nwcml0ZU5vZGUsbGUucmVnaXN0ZXJOb2RlLGxlLnJlcXVlc3RBbmltYXRpb25GcmFtZSxsZS5jYW5jZWxBbmltYXRpb25GcmFtZSxsZS5FTlY7ZnVuY3Rpb24gaG4oZyxlPSEwKXtjb25zdCB0PWcubGVuZ3RoO2lmKHQ8MilyZXR1cm4iIjtsZXQgbj1nWzBdLGk9Z1sxXTtpZih0PT09MilyZXR1cm5gTSR7dW4obil9TCR7dW4oaSl9YDtsZXQgZj0iIjtmb3IobGV0IGg9Mix1PXQtMTtoPHU7aCsrKW49Z1toXSxpPWdbaCsxXSxmKz1mbihuLGkpO3JldHVybiBlP2BNJHtmbihnWzBdLGdbMV0pfVEke3VuKGdbMV0pfSR7Zm4oZ1sxXSxnWzJdKX1UJHtmfSR7Zm4oZ1t0LTFdLGdbMF0pfSR7Zm4oZ1swXSxnWzFdKX1aYDpgTSR7dW4oZ1swXSl9USR7dW4oZ1sxXSl9JHtmbihnWzFdLGdbMl0pfSR7Zy5sZW5ndGg+Mz8iVCI6IiJ9JHtmfUwke3VuKGdbdC0xXSl9YH12YXIgdnM9e2V4cG9ydHM6e319O3ZzLmV4cG9ydHMsZnVuY3Rpb24oZyl7dmFyIGU9ZnVuY3Rpb24oKXt2YXIgdD1TdHJpbmcuZnJvbUNoYXJDb2RlLG49IkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89IixpPSJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSstJCIsZj17fTtmdW5jdGlvbiBoKGEsZCl7aWYoIWZbYV0pe2ZbYV09e307Zm9yKHZhciBFPTA7RTxhLmxlbmd0aDtFKyspZlthXVthLmNoYXJBdChFKV09RX1yZXR1cm4gZlthXVtkXX12YXIgdT17Y29tcHJlc3NUb0Jhc2U2NDpmdW5jdGlvbihhKXtpZihhPT1udWxsKXJldHVybiIiO3ZhciBkPXUuX2NvbXByZXNzKGEsNixmdW5jdGlvbihFKXtyZXR1cm4gbi5jaGFyQXQoRSl9KTtzd2l0Y2goZC5sZW5ndGglNCl7ZGVmYXVsdDpjYXNlIDA6cmV0dXJuIGQ7Y2FzZSAxOnJldHVybiBkKyI9PT0iO2Nhc2UgMjpyZXR1cm4gZCsiPT0iO2Nhc2UgMzpyZXR1cm4gZCsiPSJ9fSxkZWNvbXByZXNzRnJvbUJhc2U2NDpmdW5jdGlvbihhKXtyZXR1cm4gYT09bnVsbD8iIjphPT0iIj9udWxsOnUuX2RlY29tcHJlc3MoYS5sZW5ndGgsMzIsZnVuY3Rpb24oZCl7cmV0dXJuIGgobixhLmNoYXJBdChkKSl9KX0sY29tcHJlc3NUb1VURjE2OmZ1bmN0aW9uKGEpe3JldHVybiBhPT1udWxsPyIiOnUuX2NvbXByZXNzKGEsMTUsZnVuY3Rpb24oZCl7cmV0dXJuIHQoZCszMil9KSsiICJ9LGRlY29tcHJlc3NGcm9tVVRGMTY6ZnVuY3Rpb24oYSl7cmV0dXJuIGE9PW51bGw/IiI6YT09IiI/bnVsbDp1Ll9kZWNvbXByZXNzKGEubGVuZ3RoLDE2Mzg0LGZ1bmN0aW9uKGQpe3JldHVybiBhLmNoYXJDb2RlQXQoZCktMzJ9KX0sY29tcHJlc3NUb1VpbnQ4QXJyYXk6ZnVuY3Rpb24oYSl7Zm9yKHZhciBkPXUuY29tcHJlc3MoYSksRT1uZXcgVWludDhBcnJheShkLmxlbmd0aCoyKSxwPTAsTz1kLmxlbmd0aDtwPE87cCsrKXt2YXIgbT1kLmNoYXJDb2RlQXQocCk7RVtwKjJdPW0+Pj44LEVbcCoyKzFdPW0lMjU2fXJldHVybiBFfSxkZWNvbXByZXNzRnJvbVVpbnQ4QXJyYXk6ZnVuY3Rpb24oYSl7aWYoYT09bnVsbClyZXR1cm4gdS5kZWNvbXByZXNzKGEpO2Zvcih2YXIgZD1uZXcgQXJyYXkoYS5sZW5ndGgvMiksRT0wLHA9ZC5sZW5ndGg7RTxwO0UrKylkW0VdPWFbRSoyXSoyNTYrYVtFKjIrMV07dmFyIE89W107cmV0dXJuIGQuZm9yRWFjaChmdW5jdGlvbihtKXtPLnB1c2godChtKSl9KSx1LmRlY29tcHJlc3MoTy5qb2luKCIiKSl9LGNvbXByZXNzVG9FbmNvZGVkVVJJQ29tcG9uZW50OmZ1bmN0aW9uKGEpe3JldHVybiBhPT1udWxsPyIiOnUuX2NvbXByZXNzKGEsNixmdW5jdGlvbihkKXtyZXR1cm4gaS5jaGFyQXQoZCl9KX0sZGVjb21wcmVzc0Zyb21FbmNvZGVkVVJJQ29tcG9uZW50OmZ1bmN0aW9uKGEpe3JldHVybiBhPT1udWxsPyIiOmE9PSIiP251bGw6KGE9YS5yZXBsYWNlKC8gL2csIisiKSx1Ll9kZWNvbXByZXNzKGEubGVuZ3RoLDMyLGZ1bmN0aW9uKGQpe3JldHVybiBoKGksYS5jaGFyQXQoZCkpfSkpfSxjb21wcmVzczpmdW5jdGlvbihhKXtyZXR1cm4gdS5fY29tcHJlc3MoYSwxNixmdW5jdGlvbihkKXtyZXR1cm4gdChkKX0pfSxfY29tcHJlc3M6ZnVuY3Rpb24oYSxkLEUpe2lmKGE9PW51bGwpcmV0dXJuIiI7dmFyIHAsTyxtPXt9LGI9e30sTT0iIix5PSIiLFM9IiIscz0yLGM9MyxsPTIsdj1bXSxUPTAsUj0wLEw7Zm9yKEw9MDtMPGEubGVuZ3RoO0wrPTEpaWYoTT1hLmNoYXJBdChMKSxPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobSxNKXx8KG1bTV09YysrLGJbTV09ITApLHk9UytNLE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtLHkpKVM9eTtlbHNle2lmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLFMpKXtpZihTLmNoYXJDb2RlQXQoMCk8MjU2KXtmb3IocD0wO3A8bDtwKyspVD1UPDwxLFI9PWQtMT8oUj0wLHYucHVzaChFKFQpKSxUPTApOlIrKztmb3IoTz1TLmNoYXJDb2RlQXQoMCkscD0wO3A8ODtwKyspVD1UPDwxfE8mMSxSPT1kLTE/KFI9MCx2LnB1c2goRShUKSksVD0wKTpSKyssTz1PPj4xfWVsc2V7Zm9yKE89MSxwPTA7cDxsO3ArKylUPVQ8PDF8TyxSPT1kLTE/KFI9MCx2LnB1c2goRShUKSksVD0wKTpSKyssTz0wO2ZvcihPPVMuY2hhckNvZGVBdCgwKSxwPTA7cDwxNjtwKyspVD1UPDwxfE8mMSxSPT1kLTE/KFI9MCx2LnB1c2goRShUKSksVD0wKTpSKyssTz1PPj4xfXMtLSxzPT0wJiYocz1NYXRoLnBvdygyLGwpLGwrKyksZGVsZXRlIGJbU119ZWxzZSBmb3IoTz1tW1NdLHA9MDtwPGw7cCsrKVQ9VDw8MXxPJjEsUj09ZC0xPyhSPTAsdi5wdXNoKEUoVCkpLFQ9MCk6UisrLE89Tz4+MTtzLS0scz09MCYmKHM9TWF0aC5wb3coMixsKSxsKyspLG1beV09YysrLFM9U3RyaW5nKE0pfWlmKFMhPT0iIil7aWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsUykpe2lmKFMuY2hhckNvZGVBdCgwKTwyNTYpe2ZvcihwPTA7cDxsO3ArKylUPVQ8PDEsUj09ZC0xPyhSPTAsdi5wdXNoKEUoVCkpLFQ9MCk6UisrO2ZvcihPPVMuY2hhckNvZGVBdCgwKSxwPTA7cDw4O3ArKylUPVQ8PDF8TyYxLFI9PWQtMT8oUj0wLHYucHVzaChFKFQpKSxUPTApOlIrKyxPPU8+PjF9ZWxzZXtmb3IoTz0xLHA9MDtwPGw7cCsrKVQ9VDw8MXxPLFI9PWQtMT8oUj0wLHYucHVzaChFKFQpKSxUPTApOlIrKyxPPTA7Zm9yKE89Uy5jaGFyQ29kZUF0KDApLHA9MDtwPDE2O3ArKylUPVQ8PDF8TyYxLFI9PWQtMT8oUj0wLHYucHVzaChFKFQpKSxUPTApOlIrKyxPPU8+PjF9cy0tLHM9PTAmJihzPU1hdGgucG93KDIsbCksbCsrKSxkZWxldGUgYltTXX1lbHNlIGZvcihPPW1bU10scD0wO3A8bDtwKyspVD1UPDwxfE8mMSxSPT1kLTE/KFI9MCx2LnB1c2goRShUKSksVD0wKTpSKyssTz1PPj4xO3MtLSxzPT0wJiYocz1NYXRoLnBvdygyLGwpLGwrKyl9Zm9yKE89MixwPTA7cDxsO3ArKylUPVQ8PDF8TyYxLFI9PWQtMT8oUj0wLHYucHVzaChFKFQpKSxUPTApOlIrKyxPPU8+PjE7Zm9yKDs7KWlmKFQ9VDw8MSxSPT1kLTEpe3YucHVzaChFKFQpKTticmVha31lbHNlIFIrKztyZXR1cm4gdi5qb2luKCIiKX0sZGVjb21wcmVzczpmdW5jdGlvbihhKXtyZXR1cm4gYT09bnVsbD8iIjphPT0iIj9udWxsOnUuX2RlY29tcHJlc3MoYS5sZW5ndGgsMzI3NjgsZnVuY3Rpb24oZCl7cmV0dXJuIGEuY2hhckNvZGVBdChkKX0pfSxfZGVjb21wcmVzczpmdW5jdGlvbihhLGQsRSl7dmFyIHA9W10sTz00LG09NCxiPTMsTT0iIix5PVtdLFMscyxjLGwsdixULFIsTD17dmFsOkUoMCkscG9zaXRpb246ZCxpbmRleDoxfTtmb3IoUz0wO1M8MztTKz0xKXBbU109Uztmb3IoYz0wLHY9TWF0aC5wb3coMiwyKSxUPTE7VCE9djspbD1MLnZhbCZMLnBvc2l0aW9uLEwucG9zaXRpb24+Pj0xLEwucG9zaXRpb249PTAmJihMLnBvc2l0aW9uPWQsTC52YWw9RShMLmluZGV4KyspKSxjfD0obD4wPzE6MCkqVCxUPDw9MTtzd2l0Y2goYyl7Y2FzZSAwOmZvcihjPTAsdj1NYXRoLnBvdygyLDgpLFQ9MTtUIT12OylsPUwudmFsJkwucG9zaXRpb24sTC5wb3NpdGlvbj4+PTEsTC5wb3NpdGlvbj09MCYmKEwucG9zaXRpb249ZCxMLnZhbD1FKEwuaW5kZXgrKykpLGN8PShsPjA/MTowKSpULFQ8PD0xO1I9dChjKTticmVhaztjYXNlIDE6Zm9yKGM9MCx2PU1hdGgucG93KDIsMTYpLFQ9MTtUIT12OylsPUwudmFsJkwucG9zaXRpb24sTC5wb3NpdGlvbj4+PTEsTC5wb3NpdGlvbj09MCYmKEwucG9zaXRpb249ZCxMLnZhbD1FKEwuaW5kZXgrKykpLGN8PShsPjA/MTowKSpULFQ8PD0xO1I9dChjKTticmVhaztjYXNlIDI6cmV0dXJuIiJ9Zm9yKHBbM109UixzPVIseS5wdXNoKFIpOzspe2lmKEwuaW5kZXg+YSlyZXR1cm4iIjtmb3IoYz0wLHY9TWF0aC5wb3coMixiKSxUPTE7VCE9djspbD1MLnZhbCZMLnBvc2l0aW9uLEwucG9zaXRpb24+Pj0xLEwucG9zaXRpb249PTAmJihMLnBvc2l0aW9uPWQsTC52YWw9RShMLmluZGV4KyspKSxjfD0obD4wPzE6MCkqVCxUPDw9MTtzd2l0Y2goUj1jKXtjYXNlIDA6Zm9yKGM9MCx2PU1hdGgucG93KDIsOCksVD0xO1QhPXY7KWw9TC52YWwmTC5wb3NpdGlvbixMLnBvc2l0aW9uPj49MSxMLnBvc2l0aW9uPT0wJiYoTC5wb3NpdGlvbj1kLEwudmFsPUUoTC5pbmRleCsrKSksY3w9KGw+MD8xOjApKlQsVDw8PTE7cFttKytdPXQoYyksUj1tLTEsTy0tO2JyZWFrO2Nhc2UgMTpmb3IoYz0wLHY9TWF0aC5wb3coMiwxNiksVD0xO1QhPXY7KWw9TC52YWwmTC5wb3NpdGlvbixMLnBvc2l0aW9uPj49MSxMLnBvc2l0aW9uPT0wJiYoTC5wb3NpdGlvbj1kLEwudmFsPUUoTC5pbmRleCsrKSksY3w9KGw+MD8xOjApKlQsVDw8PTE7cFttKytdPXQoYyksUj1tLTEsTy0tO2JyZWFrO2Nhc2UgMjpyZXR1cm4geS5qb2luKCIiKX1pZihPPT0wJiYoTz1NYXRoLnBvdygyLGIpLGIrKykscFtSXSlNPXBbUl07ZWxzZSBpZihSPT09bSlNPXMrcy5jaGFyQXQoMCk7ZWxzZSByZXR1cm4gbnVsbDt5LnB1c2goTSkscFttKytdPXMrTS5jaGFyQXQoMCksTy0tLHM9TSxPPT0wJiYoTz1NYXRoLnBvdygyLGIpLGIrKyl9fX07cmV0dXJuIHV9KCk7ZyE9bnVsbD9nLmV4cG9ydHM9ZTp0eXBlb2YgYW5ndWxhcjwidSImJmFuZ3VsYXIhPW51bGwmJmFuZ3VsYXIubW9kdWxlKCJMWlN0cmluZyIsW10pLmZhY3RvcnkoIkxaU3RyaW5nIixmdW5jdGlvbigpe3JldHVybiBlfSl9KHZzKTt2YXIgRmE9dnMuZXhwb3J0cztmdW5jdGlvbiBzaShnKXtyZXR1cm4gSlNPTi5wYXJzZShGYS5kZWNvbXByZXNzKGcpKX1mdW5jdGlvbiB5cihnKXtyZXR1cm4gRmEuY29tcHJlc3MoSlNPTi5zdHJpbmdpZnkoZykpfWNsYXNzIGphIGV4dGVuZHMgRHR7Y29uc3RydWN0b3IoZSl7c3VwZXIoZSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImNhblJvdGF0ZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInNjYWxlVHlwZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOiRlLmFsbH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ0b29sc1R5cGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpMdC5QZW5jaWx9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywic3luY1RpbWVzdGFtcCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzeW5jSW5kZXgiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTowfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInRtcFBvaW50cyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOltdfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIk1BWF9SRVBFQVIiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZToxMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ1bmlUaGlja25lc3MiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywid29ya09wdGlvbnMiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiY2VudGVyUG9zIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6WzAsMF19KSx0aGlzLndvcmtPcHRpb25zPWUudG9vbHNPcHQsdGhpcy51bmlUaGlja25lc3M9dGhpcy5NQVhfUkVQRUFSL3RoaXMud29ya09wdGlvbnMudGhpY2tuZXNzLzEwLHRoaXMuc3luY1RpbWVzdGFtcD0wfWNvbWJpbmVDb25zdW1lKCl7dmFyIGg7Y29uc3QgZT0oaD10aGlzLndvcmtJZCk9PW51bGw/dm9pZCAwOmgudG9TdHJpbmcoKSx0PXRoaXMudHJhbnNmb3JtRGF0YUFsbCghMCksbj17bmFtZTplfTtsZXQgaTtjb25zdCBmPXRoaXMuZHJhd0xheWVyfHx0aGlzLmZ1bGxMYXllcjtyZXR1cm4gdC5sZW5ndGgmJihpPXRoaXMuZHJhdyh7YXR0cnM6bix0YXNrczp0LHJlcGxhY2VJZDplLGxheWVyOmYsaXNDbGVhckFsbDohMH0pKSx7cmVjdDppLHR5cGU6VHQuRHJhd1dvcmssZGF0YVR5cGU6enQuTG9jYWx9fXNldFdvcmtPcHRpb25zKGUpe3N1cGVyLnNldFdvcmtPcHRpb25zKGUpLHRoaXMuc3luY1RpbWVzdGFtcD1EYXRlLm5vdygpfWNvbnN1bWUoZSl7dmFyIE07Y29uc3R7ZGF0YTp0LGlzRnVsbFdvcms6bixpc0NsZWFyQWxsOmksaXNTdWJXb3JrZXI6Zn09ZTtpZigoKE09dC5vcCk9PW51bGw/dm9pZCAwOk0ubGVuZ3RoKT09PTApcmV0dXJue3R5cGU6VHQuTm9uZX07Y29uc3R7d29ya0lkOmh9PXQse3Rhc2tzOnUsZWZmZWN0czphLGNvbnN1bWVJbmRleDpkfT10aGlzLnRyYW5zZm9ybURhdGEodCwhMSk7dGhpcy5zeW5jSW5kZXg9TWF0aC5taW4odGhpcy5zeW5jSW5kZXgsZCk7Y29uc3QgRT17bmFtZTpoPT1udWxsP3ZvaWQgMDpoLnRvU3RyaW5nKCl9O2xldCBwLE89ITE7Y29uc3QgbT10aGlzLnN5bmNJbmRleDtpZih0aGlzLnN5bmNUaW1lc3RhbXA9PT0wJiYodGhpcy5zeW5jVGltZXN0YW1wPURhdGUubm93KCkpLHUubGVuZ3RoJiYodVswXS50YXNrSWQtdGhpcy5zeW5jVGltZXN0YW1wPnRoaXMuc3luY1VuaXRUaW1lJiYoTz0hMCx0aGlzLnN5bmNUaW1lc3RhbXA9dVswXS50YXNrSWQsdGhpcy5zeW5jSW5kZXg9dGhpcy50bXBQb2ludHMubGVuZ3RoKSxmKSl7Y29uc3QgeT1uP3RoaXMuZnVsbExheWVyOnRoaXMuZHJhd0xheWVyfHx0aGlzLmZ1bGxMYXllcjtwPXRoaXMuZHJhdyh7YXR0cnM6RSx0YXNrczp1LGVmZmVjdHM6YSxsYXllcjp5LGlzQ2xlYXJBbGw6aX0pfWlmKGYpcmV0dXJuIGQ+MTAmJnRoaXMudG1wUG9pbnRzLnNwbGljZSgwLGQtMTApLHtyZWN0OnAsdHlwZTpUdC5EcmF3V29yayxkYXRhVHlwZTp6dC5Mb2NhbH07Y29uc3QgYj1bXTtyZXR1cm4gdGhpcy50bXBQb2ludHMuc2xpY2UobSkuZm9yRWFjaCh5PT57Yi5wdXNoKHkueCx5LnksdGhpcy5jb21wdXRSYWRpdXMoeS56LHRoaXMud29ya09wdGlvbnMudGhpY2tuZXNzKSl9KSx7cmVjdDpwLHR5cGU6VHQuRHJhd1dvcmssZGF0YVR5cGU6enQuTG9jYWwsd29ya0lkOk8/aDp2b2lkIDAsb3A6Tz9iOnZvaWQgMCxpbmRleDpPP20qMzp2b2lkIDB9fWNvbnN1bWVBbGwoZSl7dmFyIGQsRTtpZihlLmRhdGEpe2NvbnN0e29wOnAsd29ya1N0YXRlOk99PWUuZGF0YTtwIT1udWxsJiZwLmxlbmd0aCYmTz09PWNlLkRvbmUmJnRoaXMud29ya09wdGlvbnMuc3Ryb2tlVHlwZT09PVJlLlN0cm9rZSYmdGhpcy51cGRhdGVUZW1wUG9pbnRzV2l0aFByZXNzdXJlV2hlbkRvbmUocCl9Y29uc3QgdD0oZD10aGlzLndvcmtJZCk9PW51bGw/dm9pZCAwOmQudG9TdHJpbmcoKTtpZighdClyZXR1cm57dHlwZTpUdC5Ob25lfTtjb25zdCBuPXRoaXMudHJhbnNmb3JtRGF0YUFsbCghMCksaT17bmFtZTp0fTtsZXQgZjtjb25zdCBoPXRoaXMuZnVsbExheWVyO24ubGVuZ3RoJiYoZj10aGlzLmRyYXcoe2F0dHJzOmksdGFza3M6bixyZXBsYWNlSWQ6dCxsYXllcjpoLGlzQ2xlYXJBbGw6ITF9KSk7Y29uc3QgdT1bXTt0aGlzLnRtcFBvaW50cy5tYXAocD0+e3UucHVzaChwLngscC55LHRoaXMuY29tcHV0UmFkaXVzKHAueix0aGlzLndvcmtPcHRpb25zLnRoaWNrbmVzcykpfSksdGhpcy5zeW5jVGltZXN0YW1wPTAsZGVsZXRlIHRoaXMud29ya09wdGlvbnMuc3luY1VuaXRUaW1lO2NvbnN0IGE9eXIodSk7cmV0dXJuIHRoaXMudk5vZGVzLnNldEluZm8odCx7cmVjdDpmLG9wOnUsb3B0OnRoaXMud29ya09wdGlvbnMsdG9vbHNUeXBlOnRoaXMudG9vbHNUeXBlLHNjYWxlVHlwZTp0aGlzLnNjYWxlVHlwZSxjYW5Sb3RhdGU6dGhpcy5jYW5Sb3RhdGUsY2VudGVyUG9zOmYmJkR0LmdldENlbnRlclBvcyhmLGgpfSkse3JlY3Q6Zix0eXBlOlR0LkZ1bGxXb3JrLGRhdGFUeXBlOnp0LkxvY2FsLHdvcmtJZDp0LG9wczphLHVwZGF0ZU5vZGVPcHQ6e3Bvczp0aGlzLmNlbnRlclBvcyx1c2VBbmltYXRpb246ITB9LG9wdDp0aGlzLndvcmtPcHRpb25zLHVuZG9UaWNrZXJJZDooRT1lLmRhdGEpPT1udWxsP3ZvaWQgMDpFLnVuZG9UaWNrZXJJZH19Y2xlYXJUbXBQb2ludHMoKXt0aGlzLnRtcFBvaW50cy5sZW5ndGg9MCx0aGlzLnN5bmNUaW1lc3RhbXA9MCx0aGlzLnN5bmNJbmRleD0wfWNvbnN1bWVTZXJ2aWNlKGUpe3ZhciBFO2NvbnN0e29wOnQsaXNGdWxsV29yazpuLHJlcGxhY2VJZDppLGlzQ2xlYXJBbGw6Zn09ZTt0aGlzLnRtcFBvaW50cy5sZW5ndGg9MDtmb3IobGV0IHA9MDtwPHQubGVuZ3RoO3ArPTMpe2NvbnN0IE89bmV3IEZ0KHRbcF0sdFtwKzFdLHRbcCsyXSk7aWYodGhpcy50bXBQb2ludHMubGVuZ3RoPjApe2NvbnN0IG09dGhpcy50bXBQb2ludHNbdGhpcy50bXBQb2ludHMubGVuZ3RoLTFdLGI9RXQuU3ViKE8sbSkudW5pKCk7Ty5zZXR2KGIpfXRoaXMudG1wUG9pbnRzLnB1c2goTyl9Y29uc3QgaD10aGlzLnRyYW5zZm9ybURhdGFBbGwoITEpLHU9KEU9dGhpcy53b3JrSWQpPT1udWxsP3ZvaWQgMDpFLnRvU3RyaW5nKCksYT17bmFtZTp1fTtsZXQgZDtpZih1JiZoLmxlbmd0aCl7Y29uc3QgcD1uP3RoaXMuZnVsbExheWVyOnRoaXMuZHJhd0xheWVyfHx0aGlzLmZ1bGxMYXllcjtkPXRoaXMuZHJhdyh7YXR0cnM6YSx0YXNrczpoLHJlcGxhY2VJZDppLGxheWVyOnAsaXNDbGVhckFsbDpmfSksdGhpcy52Tm9kZXMuc2V0SW5mbyh1LHtyZWN0OmQsb3A6dCxvcHQ6dGhpcy53b3JrT3B0aW9ucyx0b29sc1R5cGU6dGhpcy50b29sc1R5cGUsc2NhbGVUeXBlOnRoaXMuc2NhbGVUeXBlLGNhblJvdGF0ZTp0aGlzLmNhblJvdGF0ZSxjZW50ZXJQb3M6ZCYmRHQuZ2V0Q2VudGVyUG9zKGQscCl9KX1yZXR1cm4gZH10cmFuc2Zvcm1EYXRhQWxsKGU9ITApe3JldHVybiB0aGlzLmdldFRhc2tQb2ludHModGhpcy50bXBQb2ludHMsZSYmdGhpcy53b3JrT3B0aW9ucy50aGlja25lc3N8fHZvaWQgMCl9ZHJhdyhlKXt2YXIgbDtjb25zdHthdHRyczp0LHRhc2tzOm4scmVwbGFjZUlkOmksZWZmZWN0czpmLGxheWVyOmgsaXNDbGVhckFsbDp1fT1lLHtzdHJva2VDb2xvcjphLHN0cm9rZVR5cGU6ZCx0aGlja25lc3M6RSx6SW5kZXg6cCxzY2FsZTpPLHJvdGF0ZTptLHRyYW5zbGF0ZTpifT10aGlzLndvcmtPcHRpb25zO3UmJmgucmVtb3ZlQWxsQ2hpbGRyZW4oKSxpJiYodGhpcy5mdWxsTGF5ZXIuZ2V0RWxlbWVudHNCeU5hbWUoaSsiIikubWFwKHY9PnYucmVtb3ZlKCkpLChsPXRoaXMuZHJhd0xheWVyKT09bnVsbHx8bC5nZXRFbGVtZW50c0J5TmFtZShpKyIiKS5tYXAodj0+di5yZW1vdmUoKSkpLGYhPW51bGwmJmYuc2l6ZSYmKGYuZm9yRWFjaCh2PT57dmFyIFQ7KFQ9aC5nZXRFbGVtZW50QnlJZCh2KyIiKSk9PW51bGx8fFQucmVtb3ZlKCl9KSxmLmNsZWFyKCkpO2xldCBNO2NvbnN0IHk9W10sUz1oLndvcmxkUG9zaXRpb24scz1oLndvcmxkU2NhbGluZztmb3IobGV0IHY9MDt2PG4ubGVuZ3RoO3YrKyl7Y29uc3R7cG9zOlQscG9pbnRzOlIsdGFza0lkOkx9PW5bdl07dC5pZD1MLnRvU3RyaW5nKCk7Y29uc3R7cHM6TixyZWN0OkF9PXRoaXMuY29tcHV0RHJhd1BvaW50cyhSKTtsZXQgdztjb25zdCBCPVIubGVuZ3RoPT09MTtkPT09UmUuU3Ryb2tlfHxCP3c9aG4oTiwhMCk6dz1obihOLCExKTtjb25zdCBEPXtwb3M6VCxkOncsZmlsbENvbG9yOmQ9PT1SZS5TdHJva2V8fEI/YTp2b2lkIDAsbGluZURhc2g6ZD09PVJlLkRvdHRlZCYmIUI/WzEsRSoyXTpkPT09UmUuTG9uZ0RvdHRlZCYmIUI/W0UsRSoyXTp2b2lkIDAsc3Ryb2tlQ29sb3I6YSxsaW5lQ2FwOmQ9PT1SZS5TdHJva2V8fEI/dm9pZCAwOiJyb3VuZCIsbGluZVdpZHRoOmQ9PT1SZS5TdHJva2V8fEI/MDpFfTtNPSR0KE0se3g6TWF0aC5mbG9vcigoQS54K1RbMF0pKnNbMF0rU1swXS1EdC5TYWZlQm9yZGVyUGFkZGluZykseTpNYXRoLmZsb29yKChBLnkrVFsxXSkqc1sxXStTWzFdLUR0LlNhZmVCb3JkZXJQYWRkaW5nKSx3Ok1hdGguZmxvb3IoQS53KnNbMF0rMipEdC5TYWZlQm9yZGVyUGFkZGluZyksaDpNYXRoLmZsb29yKEEuaCpzWzFdKzIqRHQuU2FmZUJvcmRlclBhZGRpbmcpfSkseS5wdXNoKEQpfU8mJih0LnNjYWxlPU8pLG0mJih0LnJvdGF0ZT1tKSxiJiYodC50cmFuc2xhdGU9Yik7Y29uc3QgYz1uZXcgSXI7aWYoTSl7dGhpcy5jZW50ZXJQb3M9RHQuZ2V0Q2VudGVyUG9zKE0saCksYy5hdHRyKHsuLi50LG5vcm1hbGl6ZTohMCxpZDp0Lm5hbWUsYW5jaG9yOlsuNSwuNV0sYmdjb2xvcjpkPT09UmUuU3Ryb2tlP2E6dm9pZCAwLHBvczp0aGlzLmNlbnRlclBvcyxzaXplOlsoTS53LTIqRHQuU2FmZUJvcmRlclBhZGRpbmcpL3NbMF0sKE0uaC0yKkR0LlNhZmVCb3JkZXJQYWRkaW5nKS9zWzFdXSx6SW5kZXg6cH0pO2NvbnN0IHY9eS5tYXAoVD0+KFQucG9zPVtULnBvc1swXS10aGlzLmNlbnRlclBvc1swXSxULnBvc1sxXS10aGlzLmNlbnRlclBvc1sxXV0sbmV3IEhyKFQpKSk7Yy5hcHBlbmQoLi4udiksZD09PVJlLlN0cm9rZSYmYy5zZWFsKCksaC5hcHBlbmQoYyl9aWYoT3x8bXx8Yil7Y29uc3Qgdj1jPT1udWxsP3ZvaWQgMDpjLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO2lmKHYpcmV0dXJue3g6TWF0aC5mbG9vcih2LngtRHQuU2FmZUJvcmRlclBhZGRpbmcpLHk6TWF0aC5mbG9vcih2LnktRHQuU2FmZUJvcmRlclBhZGRpbmcpLHc6TWF0aC5mbG9vcih2LndpZHRoK0R0LlNhZmVCb3JkZXJQYWRkaW5nKjIpLGg6TWF0aC5mbG9vcih2LmhlaWdodCtEdC5TYWZlQm9yZGVyUGFkZGluZyoyKX19cmV0dXJuIE19Y29tcHV0RHJhd1BvaW50cyhlKXtyZXR1cm4gdGhpcy53b3JrT3B0aW9ucy5zdHJva2VUeXBlPT09UmUuU3Ryb2tlfHxlLmxlbmd0aD09PTE/dGhpcy5jb21wdXRTdHJva2UoZSk6dGhpcy5jb21wdXROb21hbChlKX1jb21wdXROb21hbChlKXtsZXQgdD10aGlzLndvcmtPcHRpb25zLnRoaWNrbmVzcztjb25zdCBuPWUubWFwKGk9Pih0PU1hdGgubWF4KHQsaS5yYWRpdXMpLGkucG9pbnQpKTtyZXR1cm57cHM6bixyZWN0OnhlKG4sdCl9fWNvbXB1dFN0cm9rZShlKXtyZXR1cm4gZS5sZW5ndGg9PT0xP3RoaXMuY29tcHV0RG90U3Ryb2tlKGVbMF0pOnRoaXMuY29tcHV0TGluZVN0cm9rZShlKX1jb21wdXRMaW5lU3Ryb2tlKGUpe2NvbnN0IHQ9W10sbj1bXTtmb3IobGV0IGE9MDthPGUubGVuZ3RoO2ErKyl7Y29uc3R7cG9pbnQ6ZCxyYWRpdXM6RX09ZVthXTtsZXQgcD1kLnY7YT09PTAmJmUubGVuZ3RoPjEmJihwPWVbYSsxXS5wb2ludC52KTtjb25zdCBPPUV0LlBlcihwKS5tdWwoRSk7dC5wdXNoKEZ0LlN1YihkLE8pKSxuLnB1c2goRnQuQWRkKGQsTykpfWNvbnN0IGk9ZVtlLmxlbmd0aC0xXSxmPUZ0LkdldFNlbWljaXJjbGVTdHJva2UoaS5wb2ludCx0W3QubGVuZ3RoLTFdLC0xLDgpLGg9RnQuR2V0U2VtaWNpcmNsZVN0cm9rZShlWzBdLnBvaW50LG5bMF0sLTEsOCksdT10LmNvbmNhdChmLG4ucmV2ZXJzZSgpLGgpO3JldHVybntwczp1LHJlY3Q6eGUodSl9fWNvbXB1dERvdFN0cm9rZShlKXtjb25zdHtwb2ludDp0LHJhZGl1czpufT1lLGk9e3g6dC54LW4seTp0Lnktbix3Om4qMixoOm4qMn07cmV0dXJue3BzOkZ0LkdldERvdFN0cm9rZSh0LG4sOCkscmVjdDppfX10cmFuc2Zvcm1EYXRhKGUsdCl7Y29uc3R7b3A6bix3b3JrU3RhdGU6aX09ZTtsZXQgZj10aGlzLnRtcFBvaW50cy5sZW5ndGgtMSxoPVtdO2lmKG4hPW51bGwmJm4ubGVuZ3RoJiZpKXtjb25zdHtzdHJva2VUeXBlOnUsdGhpY2tuZXNzOmF9PXRoaXMud29ya09wdGlvbnMsZD1uZXcgU2V0O2Y9dT09PVJlLlN0cm9rZT90aGlzLnVwZGF0ZVRlbXBQb2ludHNXaXRoUHJlc3N1cmUobixhLGQpOnRoaXMudXBkYXRlVGVtcFBvaW50cyhuLGEsZCk7Y29uc3QgRT10P3RoaXMudG1wUG9pbnRzOnRoaXMudG1wUG9pbnRzLnNsaWNlKGYpO3JldHVybiBoPXRoaXMuZ2V0VGFza1BvaW50cyhFLGEpLHt0YXNrczpoLGVmZmVjdHM6ZCxjb25zdW1lSW5kZXg6Zn19cmV0dXJue3Rhc2tzOmgsY29uc3VtZUluZGV4OmZ9fWNvbXB1dFJhZGl1cyhlLHQpe3JldHVybiBlKi4wMyp0K3QqLjV9Z2V0TWluWihlLHQpe3JldHVybigodHx8TWF0aC5tYXgoMSxNYXRoLmZsb29yKGUqLjMpKSktZSouNSkqMTAwL2UvM31nZXRUYXNrUG9pbnRzKGUsdCl7dmFyIEU7Y29uc3Qgbj1bXTtpZihlLmxlbmd0aD09PTApcmV0dXJuW107bGV0IGk9MCxmPWVbMF0ueCxoPWVbMF0ueSx1PVtmLGhdLGE9W10sZD1lWzBdLnQ7Zm9yKDtpPGUubGVuZ3RoOyl7Y29uc3QgcD1lW2ldLE89cC54LWYsbT1wLnktaCxiPXAueixNPXQ/dGhpcy5jb21wdXRSYWRpdXMoYix0KTpiO2lmKGEucHVzaCh7cG9pbnQ6bmV3IEZ0KE8sbSxiLGVbaV0udikscmFkaXVzOk19KSxpPjAmJmk8ZS5sZW5ndGgtMSl7Y29uc3QgeT1lW2ldLmdldEFuZ2xlQnlQb2ludHMoZVtpLTFdLGVbaSsxXSk7aWYoeTw5MHx8eT4yNzApe2NvbnN0IFM9KEU9YS5wb3AoKSk9PW51bGw/dm9pZCAwOkUucG9pbnQuY2xvbmUoKTtTJiZuLnB1c2goe3Rhc2tJZDpkLHBvczp1LHBvaW50czpbLi4uYSx7cG9pbnQ6UyxyYWRpdXM6TX1dfSksZj1lW2ldLngsaD1lW2ldLnksdT1bZixoXTtjb25zdCBzPXAueC1mLGM9cC55LWg7YT1be3BvaW50Om5ldyBGdChzLGMsYikscmFkaXVzOk19XSxkPURhdGUubm93KCl9fWkrK31yZXR1cm4gbi5wdXNoKHt0YXNrSWQ6ZCxwb3M6dSxwb2ludHM6YX0pLG59dXBkYXRlVGVtcFBvaW50c1dpdGhQcmVzc3VyZShlLHQsbil7Y29uc3QgaT1EYXRlLm5vdygpLGY9dGhpcy50bXBQb2ludHMubGVuZ3RoO2xldCBoPWY7Zm9yKGxldCBhPTA7YTxlLmxlbmd0aDthKz0yKXtoPU1hdGgubWluKGgsZik7Y29uc3QgZD10aGlzLnRtcFBvaW50cy5sZW5ndGgsRT1uZXcgRnQoZVthXSxlW2ErMV0pO2lmKGQ9PT0wKXt0aGlzLnRtcFBvaW50cy5wdXNoKEUpO2NvbnRpbnVlfWNvbnN0IHA9ZC0xLE89dGhpcy50bXBQb2ludHNbcF0sbT1FdC5TdWIoRSxPKS51bmkoKTtpZihFLmlzTmVhcihPLHQpKXtpZihPLno8dGhpcy5NQVhfUkVQRUFSKXtpZihPLnNldHooTWF0aC5taW4oTy56KzEsdGhpcy5NQVhfUkVQRUFSKSksaD1NYXRoLm1pbihoLHApLGQ+MSl7bGV0IHk9ZC0xO2Zvcig7eT4wOyl7Y29uc3QgUz10aGlzLnRtcFBvaW50c1t5XS5kaXN0YW5jZSh0aGlzLnRtcFBvaW50c1t5LTFdKSxzPU1hdGgubWF4KHRoaXMudG1wUG9pbnRzW3ldLnotdGhpcy51bmlUaGlja25lc3MqUywwKTtpZih0aGlzLnRtcFBvaW50c1t5LTFdLno+PXMpYnJlYWs7dGhpcy50bXBQb2ludHNbeS0xXS5zZXR6KHMpLGg9TWF0aC5taW4oaCx5LTEpLHktLX19fWVsc2UgaD0xLzA7Y29udGludWV9RS5zZXR2KG0pO2NvbnN0IGI9RS5kaXN0YW5jZShPKSxNPU1hdGgubWF4KE8uei10aGlzLnVuaVRoaWNrbmVzcypiLDApO2Q+MSYmRXQuRXF1YWxzKG0sTy52LC4wMikmJihNPjB8fE8uejw9MCkmJihuJiZPLnQmJm4uYWRkKE8udCksdGhpcy50bXBQb2ludHMucG9wKCksaD1NYXRoLm1pbihwLGgpKSxFLnNldHooTSksdGhpcy50bXBQb2ludHMucHVzaChFKX1pZihoPT09MS8wKXJldHVybiB0aGlzLnRtcFBvaW50cy5sZW5ndGg7bGV0IHU9ZjtpZihoPT09Zil7dT1NYXRoLm1heCh1LTEsMCk7Y29uc3QgYT10aGlzLnRtcFBvaW50c1t1XS50O2EmJihuPT1udWxsfHxuLmFkZChhKSl9ZWxzZXtsZXQgYT1mLTE7Zm9yKHU9aDthPj0wOyl7Y29uc3QgZD10aGlzLnRtcFBvaW50c1thXS50O2lmKGQmJihuPT1udWxsfHxuLmFkZChkKSxhPD1oKSl7dT1hLGE9LTE7YnJlYWt9YS0tfX1yZXR1cm4gdGhpcy50bXBQb2ludHNbdV0uc2V0VChpKSx1fXVwZGF0ZVRlbXBQb2ludHMoZSx0LG4pe3ZhciBhO2NvbnN0IGk9RGF0ZS5ub3coKSxmPXRoaXMudG1wUG9pbnRzLmxlbmd0aDtsZXQgaD1mO2ZvcihsZXQgZD0wO2Q8ZS5sZW5ndGg7ZCs9Mil7Y29uc3QgRT10aGlzLnRtcFBvaW50cy5sZW5ndGgscD1uZXcgRnQoZVtkXSxlW2QrMV0pO2lmKEU9PT0wKXt0aGlzLnRtcFBvaW50cy5wdXNoKHApO2NvbnRpbnVlfWNvbnN0IE89RS0xLG09dGhpcy50bXBQb2ludHNbT10sYj1FdC5TdWIocCxtKS51bmkoKTtpZihFdC5FcXVhbHMoYixtLnYsLjAyKSl7biYmbS50JiZuLmFkZChtLnQpLHRoaXMudG1wUG9pbnRzLnBvcCgpLGg9TWF0aC5taW4oTyxoKTtjb250aW51ZX1pZihwLmlzTmVhcihtLHQvMikpe2g9TWF0aC5taW4oTyxoKTtjb250aW51ZX1wLnNldHYoYiksdGhpcy50bXBQb2ludHMucHVzaChwKX1sZXQgdT1mO2lmKGg9PT1mKXt1PU1hdGgubWF4KHUtMSwwKTtjb25zdCBkPXRoaXMudG1wUG9pbnRzW3VdLnQ7ZCYmKG49PW51bGx8fG4uYWRkKGQpKX1lbHNle2xldCBkPU1hdGgubWluKGYtMSxoKTtmb3IodT1oO2Q+PTA7KXtjb25zdCBFPShhPXRoaXMudG1wUG9pbnRzW2RdKT09bnVsbD92b2lkIDA6YS50O2lmKEUmJihuPT1udWxsfHxuLmFkZChFKSxkPD1oKSl7dT1kLGQ9LTE7YnJlYWt9ZC0tfX1yZXR1cm4gdGhpcy50bXBQb2ludHNbdV0uc2V0VChpKSx1fXVwZGF0ZVRlbXBQb2ludHNXaXRoUHJlc3N1cmVXaGVuRG9uZShlKXtjb25zdHt0aGlja25lc3M6dH09dGhpcy53b3JrT3B0aW9ucyxuPWUubGVuZ3RoLGk9dGhpcy5nZXRNaW5aKHQpO2ZvcihsZXQgZj0wO2Y8bjtmKz0yKXtjb25zdCBoPXRoaXMudG1wUG9pbnRzLmxlbmd0aCx1PW5ldyBGdChlW2ZdLGVbZisxXSk7aWYoaD09PTApe3RoaXMudG1wUG9pbnRzLnB1c2godSk7Y29udGludWV9Y29uc3QgYT1oLTEsZD10aGlzLnRtcFBvaW50c1thXSxFPUV0LlN1Yih1LGQpLnVuaSgpLHA9dS5kaXN0YW5jZShkKTtpZihoPjEmJmQuej09PWkpYnJlYWs7aWYodS5pc05lYXIoZCx0LzIpKXtpZihuPDMmJmQuejx0aGlzLk1BWF9SRVBFQVImJihkLnNldHooTWF0aC5taW4oZC56KzEsdGhpcy5NQVhfUkVQRUFSKSksaD4xKSl7bGV0IG09aC0xO2Zvcig7bT4wOyl7Y29uc3QgYj10aGlzLnRtcFBvaW50c1ttXS5kaXN0YW5jZSh0aGlzLnRtcFBvaW50c1ttLTFdKSxNPU1hdGgubWF4KHRoaXMudG1wUG9pbnRzW21dLnotdGhpcy51bmlUaGlja25lc3MqYiwtdC80KTtpZih0aGlzLnRtcFBvaW50c1ttLTFdLno+PU0pYnJlYWs7dGhpcy50bXBQb2ludHNbbS0xXS5zZXR6KE0pLG0tLX19Y29udGludWV9dS5zZXR2KEUpO2NvbnN0IE89TWF0aC5tYXgoZC56LXRoaXMudW5pVGhpY2tuZXNzKnAsaSk7aD4xJiZFdC5FcXVhbHMoRSxkLnYsLjAyKSYmZC56PD0wJiZ0aGlzLnRtcFBvaW50cy5wb3AoKSx1LnNldHooTyksdGhpcy50bXBQb2ludHMucHVzaCh1KX19c3RhdGljIHVwZGF0ZU5vZGVPcHQoZSl7dmFyIHU7Y29uc3R7bm9kZTp0LG9wdDpuLHZOb2RlczppfT1lLHtzdHJva2VDb2xvcjpmfT1uLGg9aS5nZXQodC5uYW1lKTtyZXR1cm4gZiYmKHQudGFnTmFtZT09PSJHUk9VUCI/cmkodCk/dC5zZXRBdHRyaWJ1dGUoImJnY29sb3IiLGYpOnQuY2hpbGRyZW4uZm9yRWFjaChhPT57YS5zZXRBdHRyaWJ1dGUoInN0cm9rZUNvbG9yIixmKSxhLmdldEF0dHJpYnV0ZSgiZmlsbENvbG9yIikmJmEuc2V0QXR0cmlidXRlKCJmaWxsQ29sb3IiLGYpfSk6KHQuc2V0QXR0cmlidXRlKCJzdHJva2VDb2xvciIsZiksdC5zZXRBdHRyaWJ1dGUoImZpbGxDb2xvciIsZikpLCh1PWg9PW51bGw/dm9pZCAwOmgub3B0KSE9bnVsbCYmdS5zdHJva2VDb2xvciYmKGgub3B0LnN0cm9rZUNvbG9yPWYpKSxoJiZpLnNldEluZm8odC5uYW1lLGgpLER0LnVwZGF0ZU5vZGVPcHQoZSl9c3RhdGljIGdldFJlY3RGcm9tTGF5ZXIoZSx0KXtjb25zdCBuPWUuZ2V0RWxlbWVudHNCeU5hbWUodClbMF07aWYobil7Y29uc3QgaT1uLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO3JldHVybnt4Ok1hdGguZmxvb3IoaS54LUR0LlNhZmVCb3JkZXJQYWRkaW5nKSx5Ok1hdGguZmxvb3IoaS55LUR0LlNhZmVCb3JkZXJQYWRkaW5nKSx3Ok1hdGguZmxvb3IoaS53aWR0aCtEdC5TYWZlQm9yZGVyUGFkZGluZyoyKSxoOk1hdGguZmxvb3IoaS5oZWlnaHQrRHQuU2FmZUJvcmRlclBhZGRpbmcqMil9fX19Y2xhc3MgVWEgZXh0ZW5kcyBEdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihlKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidG9vbHNUeXBlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6THQuTGFzZXJQZW59KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiY2FuUm90YXRlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6ITF9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywic2NhbGVUeXBlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6JGUubm9uZX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzeW5jVGltZXN0YW1wIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInN5bmNJbmRleCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOjB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidG1wUG9pbnRzIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6W119KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywid29ya09wdGlvbnMiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiY29uc3VtZUluZGV4Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6MH0pLHRoaXMud29ya09wdGlvbnM9ZS50b29sc09wdCx0aGlzLnN5bmNUaW1lc3RhbXA9MH1jb21iaW5lQ29uc3VtZSgpe31zZXRXb3JrT3B0aW9ucyhlKXtzdXBlci5zZXRXb3JrT3B0aW9ucyhlKSx0aGlzLnN5bmNUaW1lc3RhbXA9RGF0ZS5ub3coKX1jb25zdW1lKGUpe2NvbnN0e2RhdGE6dCxpc0Z1bGxXb3JrOm59PWUse3dvcmtJZDppLG9wOmZ9PXQ7aWYoKGY9PW51bGw/dm9pZCAwOmYubGVuZ3RoKT09PTApcmV0dXJue3R5cGU6VHQuTm9uZX07aWYodGhpcy51cGRhdGVUZW1wUG9pbnRzKGZ8fFtdKSx0aGlzLmNvbnN1bWVJbmRleD50aGlzLnRtcFBvaW50cy5sZW5ndGgtNClyZXR1cm57dHlwZTpUdC5Ob25lfTtjb25zdHtzdHJva2VDb2xvcjpoLHRoaWNrbmVzczp1LHN0cm9rZVR5cGU6YX09dGhpcy53b3JrT3B0aW9ucyxkPXhlKHRoaXMudG1wUG9pbnRzLHUpO2xldCBFPSExO2NvbnN0IHA9dGhpcy5zeW5jSW5kZXgsTz10aGlzLnRtcFBvaW50cy5zbGljZSh0aGlzLmNvbnN1bWVJbmRleCk7dGhpcy5jb25zdW1lSW5kZXg9dGhpcy50bXBQb2ludHMubGVuZ3RoLTEsdGhpcy5zeW5jVGltZXN0YW1wPT09MCYmKHRoaXMuc3luY1RpbWVzdGFtcD1EYXRlLm5vdygpKTtjb25zdCBtPXtuYW1lOmk9PW51bGw/dm9pZCAwOmkudG9TdHJpbmcoKSxvcGFjaXR5OjEsbGluZURhc2g6YT09PVJlLkRvdHRlZD9bMSx1KjJdOmE9PT1SZS5Mb25nRG90dGVkP1t1LHUqMl06dm9pZCAwLHN0cm9rZUNvbG9yOmgsbGluZUNhcDoicm91bmQiLGxpbmVXaWR0aDp1LGFuY2hvcjpbLjUsLjVdfSxiPXRoaXMuZ2V0VGFza1BvaW50cyhPKTtpZihiLmxlbmd0aCl7Y29uc3QgeT1EYXRlLm5vdygpO3ktdGhpcy5zeW5jVGltZXN0YW1wPnRoaXMuc3luY1VuaXRUaW1lJiYoRT0hMCx0aGlzLnN5bmNUaW1lc3RhbXA9eSx0aGlzLnN5bmNJbmRleD10aGlzLnRtcFBvaW50cy5sZW5ndGgpLCFuJiZ0aGlzLmRyYXcoe2F0dHJzOm0sdGFza3M6Yixpc0RvdDohMX0pfWNvbnN0IE09W107cmV0dXJuIHRoaXMudG1wUG9pbnRzLnNsaWNlKHApLmZvckVhY2goeT0+e00ucHVzaCh5LngseS55KX0pLHtyZWN0Ont4OmQueCp0aGlzLmZ1bGxMYXllci53b3JsZFNjYWxpbmdbMF0rdGhpcy5mdWxsTGF5ZXIud29ybGRQb3NpdGlvblswXSx5OmQueSp0aGlzLmZ1bGxMYXllci53b3JsZFNjYWxpbmdbMV0rdGhpcy5mdWxsTGF5ZXIud29ybGRQb3NpdGlvblsxXSx3OmQudyp0aGlzLmZ1bGxMYXllci53b3JsZFNjYWxpbmdbMF0saDpkLmgqdGhpcy5mdWxsTGF5ZXIud29ybGRTY2FsaW5nWzFdfSx0eXBlOlR0LkRyYXdXb3JrLGRhdGFUeXBlOnp0LkxvY2FsLHdvcmtJZDpFP2k6dm9pZCAwLG9wOkU/TTp2b2lkIDAsaW5kZXg6RT9wKjI6dm9pZCAwfX1jb25zdW1lQWxsKCl7dmFyIGk7Y29uc3QgZT0oaT10aGlzLndvcmtJZCk9PW51bGw/dm9pZCAwOmkudG9TdHJpbmcoKTtsZXQgdDtpZih0aGlzLnRtcFBvaW50cy5sZW5ndGgtMT50aGlzLmNvbnN1bWVJbmRleCl7bGV0IGY9dGhpcy50bXBQb2ludHMuc2xpY2UodGhpcy5jb25zdW1lSW5kZXgpO2NvbnN0IGg9Zi5sZW5ndGg9PT0xLHtzdHJva2VDb2xvcjp1LHRoaWNrbmVzczphLHN0cm9rZVR5cGU6ZH09dGhpcy53b3JrT3B0aW9ucztpZihoKXtjb25zdCBPPXRoaXMuY29tcHV0RG90U3Ryb2tlKHtwb2ludDpmWzBdLHJhZGl1czphLzJ9KTtmPU8ucHMsdD1PLnJlY3R9ZWxzZSB0PXhlKHRoaXMudG1wUG9pbnRzLGEpO2NvbnN0IEU9e25hbWU6ZT09bnVsbD92b2lkIDA6ZS50b1N0cmluZygpLGZpbGxDb2xvcjpoP3U6dm9pZCAwLG9wYWNpdHk6MSxsaW5lRGFzaDpkPT09UmUuRG90dGVkJiYhaD9bMSxhKjJdOmQ9PT1SZS5Mb25nRG90dGVkJiYhaD9bYSxhKjJdOnZvaWQgMCxzdHJva2VDb2xvcjp1LGxpbmVDYXA6aD92b2lkIDA6InJvdW5kIixsaW5lV2lkdGg6aD8wOmEsYW5jaG9yOlsuNSwuNV19LHA9dGhpcy5nZXRUYXNrUG9pbnRzKGYpO3AubGVuZ3RoJiZ0aGlzLmRyYXcoe2F0dHJzOkUsdGFza3M6cCxpc0RvdDpofSl9Y29uc3Qgbj1bXTtyZXR1cm4gdGhpcy50bXBQb2ludHMuc2xpY2UodGhpcy5zeW5jSW5kZXgpLmZvckVhY2goZj0+e24ucHVzaChmLngsZi55KX0pLHtyZWN0OnQmJnt4OnQueCp0aGlzLmZ1bGxMYXllci53b3JsZFNjYWxpbmdbMF0rdGhpcy5mdWxsTGF5ZXIud29ybGRQb3NpdGlvblswXSx5OnQueSp0aGlzLmZ1bGxMYXllci53b3JsZFNjYWxpbmdbMV0rdGhpcy5mdWxsTGF5ZXIud29ybGRQb3NpdGlvblsxXSx3OnQudyp0aGlzLmZ1bGxMYXllci53b3JsZFNjYWxpbmdbMF0saDp0LmgqdGhpcy5mdWxsTGF5ZXIud29ybGRTY2FsaW5nWzFdfSx0eXBlOlR0LkRyYXdXb3JrLGRhdGFUeXBlOnp0LkxvY2FsLHdvcmtJZDplLG9wOm4saW5kZXg6dGhpcy5zeW5jSW5kZXgqMn19Y2xlYXJUbXBQb2ludHMoKXt0aGlzLnRtcFBvaW50cy5sZW5ndGg9MCx0aGlzLnN5bmNUaW1lc3RhbXA9MCx0aGlzLnN5bmNJbmRleD0wfWNvbnN1bWVTZXJ2aWNlKGUpe3ZhciBPO2NvbnN0e29wOnR9PWUse3N0cm9rZUNvbG9yOm4sdGhpY2tuZXNzOmksc3Ryb2tlVHlwZTpmfT10aGlzLndvcmtPcHRpb25zO2lmKCF0Lmxlbmd0aCl7Y29uc3QgbT14ZSh0aGlzLnRtcFBvaW50cyxpKTtyZXR1cm57eDptLngqdGhpcy5mdWxsTGF5ZXIud29ybGRTY2FsaW5nWzBdK3RoaXMuZnVsbExheWVyLndvcmxkUG9zaXRpb25bMF0seTptLnkqdGhpcy5mdWxsTGF5ZXIud29ybGRTY2FsaW5nWzFdK3RoaXMuZnVsbExheWVyLndvcmxkUG9zaXRpb25bMV0sdzptLncqdGhpcy5mdWxsTGF5ZXIud29ybGRTY2FsaW5nWzBdLGg6bS5oKnRoaXMuZnVsbExheWVyLndvcmxkU2NhbGluZ1sxXX19Y29uc3QgaD1NYXRoLm1heCgwLHRoaXMudG1wUG9pbnRzLmxlbmd0aC0xKTt0aGlzLnVwZGF0ZVRlbXBQb2ludHModHx8W10pO2xldCB1LGE9dGhpcy50bXBQb2ludHMuc2xpY2UoaCk7Y29uc3QgZD1hLmxlbmd0aD09PTE7aWYoZCl7Y29uc3QgbT10aGlzLmNvbXB1dERvdFN0cm9rZSh7cG9pbnQ6YVswXSxyYWRpdXM6aS8yfSk7YT1tLnBzLHU9bS5yZWN0fWVsc2UgdT14ZSh0aGlzLnRtcFBvaW50cyxpKTtjb25zdCBFPXtuYW1lOihPPXRoaXMud29ya0lkKT09bnVsbD92b2lkIDA6Ty50b1N0cmluZygpLGZpbGxDb2xvcjpkP246dm9pZCAwLG9wYWNpdHk6MSxsaW5lRGFzaDpmPT09UmUuRG90dGVkJiYhZD9bMSxpKjJdOmY9PT1SZS5Mb25nRG90dGVkJiYhZD9baSxpKjJdOnZvaWQgMCxzdHJva2VDb2xvcjpuLGxpbmVDYXA6ZD92b2lkIDA6InJvdW5kIixsaW5lV2lkdGg6ZD8wOmksYW5jaG9yOlsuNSwuNV19LHA9dGhpcy5nZXRUYXNrUG9pbnRzKGEpO3JldHVybiBwLmxlbmd0aCYmdGhpcy5kcmF3KHthdHRyczpFLHRhc2tzOnAsaXNEb3Q6ZH0pLHt4OnUueCp0aGlzLmZ1bGxMYXllci53b3JsZFNjYWxpbmdbMF0rdGhpcy5mdWxsTGF5ZXIud29ybGRQb3NpdGlvblswXSx5OnUueSp0aGlzLmZ1bGxMYXllci53b3JsZFNjYWxpbmdbMV0rdGhpcy5mdWxsTGF5ZXIud29ybGRQb3NpdGlvblsxXSx3OnUudyp0aGlzLmZ1bGxMYXllci53b3JsZFNjYWxpbmdbMF0saDp1LmgqdGhpcy5mdWxsTGF5ZXIud29ybGRTY2FsaW5nWzFdfX1jb21wdXREb3RTdHJva2UoZSl7Y29uc3R7cG9pbnQ6dCxyYWRpdXM6bn09ZSxpPXt4OnQueC1uLHk6dC55LW4sdzpuKjIsaDpuKjJ9O3JldHVybntwczpGdC5HZXREb3RTdHJva2UodCxuLDgpLHJlY3Q6aX19dXBkYXRlVGVtcFBvaW50cyhlKXtjb25zdCB0PXRoaXMudG1wUG9pbnRzLmxlbmd0aDtmb3IobGV0IG49MDtuPGUubGVuZ3RoO24rPTIpe2lmKHQpe2NvbnN0IGk9dGhpcy50bXBQb2ludHMuc2xpY2UoLTEpWzBdO2kmJmkueD09PWVbbl0mJmkueT09PWVbbisxXSYmdGhpcy50bXBQb2ludHMucG9wKCl9dGhpcy50bXBQb2ludHMucHVzaChuZXcgRnQoZVtuXSxlW24rMV0pKX19YXN5bmMgZHJhdyhlKXtjb25zdHthdHRyczp0LHRhc2tzOm4saXNEb3Q6aX09ZSxmPXRoaXMuZnVsbExheWVyLHtkdXJhdGlvbjpofT10aGlzLndvcmtPcHRpb25zLHU9bmV3IEhyO2ZvcihsZXQgYT0wO2E8bi5sZW5ndGg7YSsrKXtjb25zdHtwb3M6ZCxwb2ludHM6RX09blthXTtsZXQgcDtpP3A9aG4oRSwhMCk6cD1obihFLCExKSx1LmF0dHIoey4uLnQscG9zOmQsZDpwfSk7Y29uc3R7dmVydGV4Ok8sZnJhZ21lbnQ6bX09dGhpcy53b3JrT3B0aW9ucztpZihPJiZtKXtjb25zdCBiPWYucmVuZGVyZXIuY3JlYXRlUHJvZ3JhbSh7dmVydGV4Ok8sZnJhZ21lbnQ6bX0pLHt3aWR0aDpNLGhlaWdodDp5fT1mLmdldFJlc29sdXRpb24oKTt1LnNldFVuaWZvcm1zKHt1X3RpbWU6MCx1X3Jlc29sdXRpb246W00seV19KSx1LnNldFByb2dyYW0oYil9Zi5hcHBlbmRDaGlsZCh1KSxhd2FpdCB1LnRyYW5zaXRpb24oaCkuYXR0cih7c2NhbGU6aT9bLjEsLjFdOlsxLDFdLGxpbmVXaWR0aDppPzA6MX0pLHUucmVtb3ZlKCl9fWdldFRhc2tQb2ludHMoZSl7dmFyIGE7Y29uc3QgdD1bXTtpZihlLmxlbmd0aD09PTApcmV0dXJuW107bGV0IG49MCxpPWVbMF0ueCxmPWVbMF0ueSxoPVtpLGZdLHU9W107Zm9yKDtuPGUubGVuZ3RoOyl7Y29uc3QgZD1lW25dLEU9ZC54LWkscD1kLnktZjtpZih1LnB1c2gobmV3IEZ0KEUscCkpLG4+MCYmbjxlLmxlbmd0aC0xKXtjb25zdCBPPWVbbl0uZ2V0QW5nbGVCeVBvaW50cyhlW24tMV0sZVtuKzFdKTtpZihPPDkwfHxPPjI3MCl7Y29uc3QgbT0oYT11LnBvcCgpKT09bnVsbD92b2lkIDA6YS5jbG9uZSgpO20mJnQucHVzaCh7cG9zOmgscG9pbnRzOlsuLi51LG1dfSksaT1lW25dLngsZj1lW25dLnksaD1baSxmXTtjb25zdCBiPWQueC1pLE09ZC55LWY7dT1bbmV3IEZ0KGIsTSldfX1uKyt9cmV0dXJuIHQucHVzaCh7cG9zOmgscG9pbnRzOnV9KSx0fXJlbW92ZUxvY2FsKCl7fXJlbW92ZVNlcnZpY2UoZSl7bGV0IHQ7Y29uc3Qgbj1bXTtyZXR1cm4gdGhpcy5mdWxsTGF5ZXIuZ2V0RWxlbWVudHNCeU5hbWUoZSkuZm9yRWFjaChpPT57aWYoaS5uYW1lPT09ZSl7Y29uc3QgZj1pLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO3Q9JHQodCx7eDpmLngseTpmLnksdzpmLndpZHRoLGg6Zi5oZWlnaHR9KSxuLnB1c2goaSl9fSksbi5sZW5ndGgmJm4uZm9yRWFjaChpPT5pLnJlbW92ZSgpKSx0fX12YXIgT209b2k7b2kucG9seWxpbmU9b2ksb2kucG9seWdvbj1FbTtmdW5jdGlvbiBvaShnLGUsdCl7dmFyIG49Zy5sZW5ndGgsaT1kbihnWzBdLGUpLGY9W10saCx1LGEsZCxFO2Zvcih0fHwodD1bXSksaD0xO2g8bjtoKyspe2Zvcih1PWdbaC0xXSxhPWdbaF0sZD1FPWRuKGEsZSk7OylpZihpfGQpe2lmKGkmZClicmVhaztpPyh1PXBzKHUsYSxpLGUpLGk9ZG4odSxlKSk6KGE9cHModSxhLGQsZSksZD1kbihhLGUpKX1lbHNle2YucHVzaCh1KSxkIT09RT8oZi5wdXNoKGEpLGg8bi0xJiYodC5wdXNoKGYpLGY9W10pKTpoPT09bi0xJiZmLnB1c2goYSk7YnJlYWt9aT1FfXJldHVybiBmLmxlbmd0aCYmdC5wdXNoKGYpLHR9ZnVuY3Rpb24gRW0oZyxlKXt2YXIgdCxuLGksZixoLHUsYTtmb3Iobj0xO248PTg7bio9Mil7Zm9yKHQ9W10saT1nW2cubGVuZ3RoLTFdLGY9IShkbihpLGUpJm4pLGg9MDtoPGcubGVuZ3RoO2grKyl1PWdbaF0sYT0hKGRuKHUsZSkmbiksYSE9PWYmJnQucHVzaChwcyhpLHUsbixlKSksYSYmdC5wdXNoKHUpLGk9dSxmPWE7aWYoZz10LCFnLmxlbmd0aClicmVha31yZXR1cm4gdH1mdW5jdGlvbiBwcyhnLGUsdCxuKXtyZXR1cm4gdCY4P1tnWzBdKyhlWzBdLWdbMF0pKihuWzNdLWdbMV0pLyhlWzFdLWdbMV0pLG5bM11dOnQmND9bZ1swXSsoZVswXS1nWzBdKSooblsxXS1nWzFdKS8oZVsxXS1nWzFdKSxuWzFdXTp0JjI/W25bMl0sZ1sxXSsoZVsxXS1nWzFdKSooblsyXS1nWzBdKS8oZVswXS1nWzBdKV06dCYxP1tuWzBdLGdbMV0rKGVbMV0tZ1sxXSkqKG5bMF0tZ1swXSkvKGVbMF0tZ1swXSldOm51bGx9ZnVuY3Rpb24gZG4oZyxlKXt2YXIgdD0wO3JldHVybiBnWzBdPGVbMF0/dHw9MTpnWzBdPmVbMl0mJih0fD0yKSxnWzFdPGVbMV0/dHw9NDpnWzFdPmVbM10mJih0fD04KSx0fXZhciBNbT1WbihPbSk7Y2xhc3MgbHIgZXh0ZW5kcyBEdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihlKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiY2FuUm90YXRlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6ITF9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywic2NhbGVUeXBlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6JGUubm9uZX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ0b29sc1R5cGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpMdC5FcmFzZXJ9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidG1wUG9pbnRzIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6W119KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywid29ya09wdGlvbnMiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywid29ybGRQb3NpdGlvbiIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ3b3JsZFNjYWxpbmciLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiZXJhc2VyUmVjdCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJlcmFzZXJQb2x5bGluZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLHRoaXMud29ya09wdGlvbnM9ZS50b29sc09wdCx0aGlzLndvcmxkUG9zaXRpb249dGhpcy5mdWxsTGF5ZXIud29ybGRQb3NpdGlvbix0aGlzLndvcmxkU2NhbGluZz10aGlzLmZ1bGxMYXllci53b3JsZFNjYWxpbmd9Y29tYmluZUNvbnN1bWUoKXt9Y29uc3VtZVNlcnZpY2UoKXt9c2V0V29ya09wdGlvbnMoZSl7c3VwZXIuc2V0V29ya09wdGlvbnMoZSl9Y3JlYXRlRXJhc2VyUmVjdChlKXtjb25zdCB0PWVbMF0qdGhpcy53b3JsZFNjYWxpbmdbMF0rdGhpcy53b3JsZFBvc2l0aW9uWzBdLG49ZVsxXSp0aGlzLndvcmxkU2NhbGluZ1sxXSt0aGlzLndvcmxkUG9zaXRpb25bMV0se3dpZHRoOmksaGVpZ2h0OmZ9PWxyLmVyYXNlclNpemVzW3RoaXMud29ya09wdGlvbnMudGhpY2tuZXNzXTt0aGlzLmVyYXNlclJlY3Q9e3g6dC1pKi41LHk6bi1mKi41LHc6aSxoOmZ9LHRoaXMuZXJhc2VyUG9seWxpbmU9W3RoaXMuZXJhc2VyUmVjdC54LHRoaXMuZXJhc2VyUmVjdC55LHRoaXMuZXJhc2VyUmVjdC54K3RoaXMuZXJhc2VyUmVjdC53LHRoaXMuZXJhc2VyUmVjdC55K3RoaXMuZXJhc2VyUmVjdC5oXX1jb21wdXRSZWN0Q2VudGVyUG9pbnRzKCl7Y29uc3QgZT10aGlzLnRtcFBvaW50cy5zbGljZSgtMik7aWYodGhpcy50bXBQb2ludHMubGVuZ3RoPT09NCl7Y29uc3QgdD1uZXcgRXQodGhpcy50bXBQb2ludHNbMF0sdGhpcy50bXBQb2ludHNbMV0pLG49bmV3IEV0KHRoaXMudG1wUG9pbnRzWzJdLHRoaXMudG1wUG9pbnRzWzNdKSxpPUV0LlN1YihuLHQpLnVuaSgpLGY9RXQuRGlzdCh0LG4pLHt3aWR0aDpoLGhlaWdodDp1fT1sci5lcmFzZXJTaXplc1t0aGlzLndvcmtPcHRpb25zLnRoaWNrbmVzc10sYT1NYXRoLm1pbihoLHUpLGQ9TWF0aC5yb3VuZChmL2EpO2lmKGQ+MSl7Y29uc3QgRT1bXTtmb3IobGV0IHA9MDtwPGQ7cCsrKXtjb25zdCBPPUV0Lk11bChpLHAqYSk7RS5wdXNoKHRoaXMudG1wUG9pbnRzWzBdK08ueCx0aGlzLnRtcFBvaW50c1sxXStPLnkpfXJldHVybiBFLmNvbmNhdChlKX19cmV0dXJuIGV9aXNOZWFyKGUsdCl7Y29uc3Qgbj1uZXcgRXQoZVswXSxlWzFdKSxpPW5ldyBFdCh0WzBdLHRbMV0pLHt3aWR0aDpmLGhlaWdodDpofT1sci5lcmFzZXJTaXplc1t0aGlzLndvcmtPcHRpb25zLnRoaWNrbmVzc107cmV0dXJuIEV0LkRpc3QobixpKTxNYXRoLmh5cG90KGYsaCkqLjV9Y3V0UG9seWxpbmUoZSx0KXtsZXQgbj1bdF0saT0wO2Zvcig7aTxlLmxlbmd0aDspe2NvbnN0IHU9ZVtpXTtpZih1Lmxlbmd0aDwyKWJyZWFrO249ZihuLHUpLGkrK31yZXR1cm4gbjtmdW5jdGlvbiBmKHUsYSl7Y29uc3QgZD11O2ZvcihsZXQgRT0wO0U8dS5sZW5ndGg7RSsrKXtjb25zdCBwPXVbRV0sTz1wLmZpbmRJbmRleCgobSxiKT0+YjxwLmxlbmd0aC0xP2goW20scFtiKzFdXSxbYVswXSxhWzFdXSk6ITEpO2lmKE8hPT0tMSYmTz4tMSl7Y29uc3QgbT1bXSxiPXAuc2xpY2UoMCxPKzEpO2lmKEV0LkVxdWFscyhwW09dLGFbMF0pfHxiLnB1c2goYVswXS5jbG9uZSgpLnNldHoocFtPXS56KSksYi5sZW5ndGg+MSYmbS5wdXNoKGIpLE8rYS5sZW5ndGgtMTxwLmxlbmd0aC0xKXtjb25zdCBNPU8rYS5sZW5ndGgtMSx5PXAuc2xpY2UoTSksUz1hW2EubGVuZ3RoLTFdO0V0LkVxdWFscyhwW01dLFMpfHx5LnVuc2hpZnQoUy5jbG9uZSgpLnNldHoocFtNXS56KSkseS5sZW5ndGg+MSYmbS5wdXNoKHkpfXJldHVybiBkLnNwbGljZShFLDEsLi4ubSksZH19cmV0dXJuIGR9ZnVuY3Rpb24gaCh1LGEpe2NvbnN0IGQ9RXQuU3ViKHVbMV0sdVswXSksRT1FdC5TdWIoYVsxXSxhWzBdKSxwPUV0LlN1YihhWzBdLHVbMF0pO3JldHVybiBNYXRoLmFicyhFdC5DcHIoZCxFKSk8LjEmJk1hdGguYWJzKEV0LkNwcihkLHApKTwuMX19aXNTYW1lUG9pbnQoZSx0KXtyZXR1cm4gZVswXT09PXRbMF0mJmVbMV09PT10WzFdfXRyYW5zbGF0ZUludGVyc2VjdChlKXtjb25zdCB0PVtdO2ZvcihsZXQgbj0wO248ZS5sZW5ndGg7bisrKXtjb25zdCBpPWVbbl0uZmlsdGVyKCh1LGEsZCk9PiEoYT4wJiZ0aGlzLmlzU2FtZVBvaW50KHUsZFthLTFdKSkpLGY9W107bGV0IGg9MDtmb3IoO2g8aS5sZW5ndGg7KXtjb25zdCB1PWlbaF0sYT1uZXcgRXQodVswXSx1WzFdKTtmLnB1c2goYSksaCsrfXQucHVzaChmKX1yZXR1cm4gdH1yZW1vdmUoZSl7Y29uc3R7Y3VyTm9kZU1hcDp0LHJlbW92ZUlkczpuLG5ld1dvcmtEYXRhczppfT1lLHtpc0xpbmU6Zn09dGhpcy53b3JrT3B0aW9ucztsZXQgaDtmb3IoY29uc3RbdSxhXW9mIHQuZW50cmllcygpKWlmKGEucmVjdCYmdGhpcy5lcmFzZXJSZWN0JiZ0aGlzLmVyYXNlclBvbHlsaW5lJiZSbih0aGlzLmVyYXNlclJlY3QsYS5yZWN0KSl7Y29uc3QgZD1hLm9wO2lmKCEoZCE9bnVsbCYmZC5sZW5ndGgpKWNvbnRpbnVlO2NvbnN0IEU9W10scD1bXTtmb3IobGV0IG09MDttPGQubGVuZ3RoO20rPTMpe2NvbnN0IGI9bmV3IEV0KGRbbV0qdGhpcy53b3JsZFNjYWxpbmdbMF0rdGhpcy53b3JsZFBvc2l0aW9uWzBdLGRbbSsxXSp0aGlzLndvcmxkU2NhbGluZ1sxXSt0aGlzLndvcmxkUG9zaXRpb25bMV0sZFttKzJdKTtwLnB1c2goYiksRS5wdXNoKG5ldyBGdChiLngsYi55KSl9Y29uc3QgTz14ZShFKTtpZihSbihPLHRoaXMuZXJhc2VyUmVjdCkpe2lmKHAubGVuZ3RoPjEpe2NvbnN0IG09TW0ucG9seWxpbmUocC5tYXAoYj0+Yi5YWSksdGhpcy5lcmFzZXJQb2x5bGluZSk7aWYobS5sZW5ndGgmJihuLmFkZChhLm5hbWUpLCFmJiZhLnRvb2xzVHlwZT09PUx0LlBlbmNpbCkpe2NvbnN0IGI9dGhpcy50cmFuc2xhdGVJbnRlcnNlY3QobSksTT10aGlzLmN1dFBvbHlsaW5lKGIscCk7Zm9yKGxldCB5PTA7eTxNLmxlbmd0aDt5Kyspe2NvbnN0IFM9YCR7dX1fc18ke3l9YCxzPVtdO01beV0uZm9yRWFjaChjPT57cy5wdXNoKChjLngtdGhpcy53b3JsZFBvc2l0aW9uWzBdKS90aGlzLndvcmxkU2NhbGluZ1swXSwoYy55LXRoaXMud29ybGRQb3NpdGlvblsxXSkvdGhpcy53b3JsZFNjYWxpbmdbMV0sYy56KX0pLGEub3B0JiZhLnRvb2xzVHlwZSYmdGhpcy52Tm9kZXMmJih0aGlzLnZOb2Rlcy5zZXRJbmZvKFMse3JlY3Q6T3x8YS5yZWN0LG9wOnMsb3B0OmEub3B0LGNhblJvdGF0ZTphLmNhblJvdGF0ZSxzY2FsZVR5cGU6YS5zY2FsZVR5cGUsdG9vbHNUeXBlOmEudG9vbHNUeXBlfSksaS5zZXQoUyx7d29ya0lkOlMsb3A6cyxvcHQ6YS5vcHQsdG9vbHNUeXBlOmEudG9vbHNUeXBlfSkpfX19ZWxzZSBuLmFkZChhLm5hbWUpO2g9JHQoaCxPKX19cmV0dXJuIG4uZm9yRWFjaCh1PT57dmFyIGE7cmV0dXJuKGE9dGhpcy52Tm9kZXMpPT1udWxsP3ZvaWQgMDphLmRlbGV0ZSh1KX0pLGgmJihoLngtPUR0LlNhZmVCb3JkZXJQYWRkaW5nLGgueS09RHQuU2FmZUJvcmRlclBhZGRpbmcsaC53Kz1EdC5TYWZlQm9yZGVyUGFkZGluZyoyLGguaCs9RHQuU2FmZUJvcmRlclBhZGRpbmcqMiksaH1jb25zdW1lKGUpe2NvbnN0e29wOnR9PWUuZGF0YTtpZighdHx8dC5sZW5ndGg9PT0wKXJldHVybnt0eXBlOlR0Lk5vbmV9O2NvbnN0IG49dGhpcy50bXBQb2ludHMubGVuZ3RoO2lmKG4+MSYmdGhpcy5pc05lYXIoW3RbMF0sdFsxXV0sW3RoaXMudG1wUG9pbnRzW24tMl0sdGhpcy50bXBQb2ludHNbbi0xXV0pKXJldHVybnt0eXBlOlR0Lk5vbmV9O249PT00JiYodGhpcy50bXBQb2ludHMuc2hpZnQoKSx0aGlzLnRtcFBvaW50cy5zaGlmdCgpKSx0aGlzLnRtcFBvaW50cy5wdXNoKHRbMF0sdFsxXSk7Y29uc3QgaT10aGlzLmNvbXB1dFJlY3RDZW50ZXJQb2ludHMoKTtsZXQgZjtjb25zdCBoPW5ldyBTZXQsdT1uZXcgTWFwO3RoaXMudk5vZGVzLmdldExhc3RUYXJnZXQoKTtmb3IobGV0IGE9MDthPGkubGVuZ3RoLTE7YSs9Mil7dGhpcy5jcmVhdGVFcmFzZXJSZWN0KGkuc2xpY2UoYSxhKzIpKTtjb25zdCBkPXRoaXMucmVtb3ZlKHtjdXJOb2RlTWFwOnRoaXMudk5vZGVzLmdldExhc3RUYXJnZXQoKSxyZW1vdmVJZHM6aCxuZXdXb3JrRGF0YXM6dX0pO2Y9JHQoZixkKX1pZih0aGlzLnZOb2Rlcy5kZWxldGVMYXN0VGFyZ2V0KCksZiYmaC5zaXplKXtmb3IoY29uc3QgYSBvZiB1LmtleXMoKSloLmhhcyhhKSYmdS5kZWxldGUoYSk7cmV0dXJue3R5cGU6VHQuUmVtb3ZlTm9kZSxkYXRhVHlwZTp6dC5Mb2NhbCxyZWN0OmYscmVtb3ZlSWRzOlsuLi5oXSxuZXdXb3JrRGF0YXM6dX19cmV0dXJue3R5cGU6VHQuTm9uZX19Y29uc3VtZUFsbChlKXtyZXR1cm4gdGhpcy5jb25zdW1lKGUpfWNsZWFyVG1wUG9pbnRzKCl7dGhpcy50bXBQb2ludHMubGVuZ3RoPTB9fU9iamVjdC5kZWZpbmVQcm9wZXJ0eShsciwiZXJhc2VyU2l6ZXMiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpPYmplY3QuZnJlZXplKFtPYmplY3QuZnJlZXplKHt3aWR0aDoxOCxoZWlnaHQ6MjZ9KSxPYmplY3QuZnJlZXplKHt3aWR0aDoyNixoZWlnaHQ6MzR9KSxPYmplY3QuZnJlZXplKHt3aWR0aDozNCxoZWlnaHQ6NTB9KV0pfSk7Y29uc3QgU209IisrIixUbT0ic2VsZWN0b3IiLFBtPSJhbGwiO2NsYXNzIGllIGV4dGVuZHMgRHR7Y29uc3RydWN0b3IoZSl7c3VwZXIoZSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInRvb2xzVHlwZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOkx0LlNlbGVjdG9yfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInRtcFBvaW50cyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOltdfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIndvcmtPcHRpb25zIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInNlbGVjdElkcyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzZWxlY3RvckNvbG9yIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInN0cm9rZUNvbG9yIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImZpbGxDb2xvciIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJvbGRTZWxlY3RSZWN0Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImNhblJvdGF0ZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOiExfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImNhblRleHRFZGl0Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6ITF9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywic2NhbGVUeXBlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6JGUuYWxsfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInRleHRPcHQiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSx0aGlzLndvcmtPcHRpb25zPWUudG9vbHNPcHR9Y29tcHV0U2VsZWN0b3IoKXtjb25zdCBlPXhlKHRoaXMudG1wUG9pbnRzKSx7cmVjdFJhbmdlOnQsbm9kZVJhbmdlOm59PXRoaXMudk5vZGVzLmdldFJlY3RJbnRlcnNlY3RSYW5nZShlKTtyZXR1cm57c2VsZWN0SWRzOlsuLi5uLmtleXMoKV0saW50ZXJzZWN0UmVjdDp0LHN1Yk5vZGVNYXA6bn19dXBkYXRlVGVtcFBvaW50cyhlKXtjb25zdCB0PXRoaXMudG1wUG9pbnRzLmxlbmd0aCxuPWUubGVuZ3RoO2lmKG4+MSl7Y29uc3QgaT1uZXcgRnQoZVtuLTJdKnRoaXMuZnVsbExheWVyLndvcmxkU2NhbGluZ1swXSt0aGlzLmZ1bGxMYXllci53b3JsZFBvc2l0aW9uWzBdLGVbbi0xXSp0aGlzLmZ1bGxMYXllci53b3JsZFNjYWxpbmdbMF0rdGhpcy5mdWxsTGF5ZXIud29ybGRQb3NpdGlvblsxXSk7dD09PTI/dGhpcy50bXBQb2ludHMuc3BsaWNlKDEsMSxpKTp0aGlzLnRtcFBvaW50cy5wdXNoKGkpfX1kcmF3U2VsZWN0b3IoZSl7Y29uc3R7ZHJhd1JlY3Q6dCxzdWJOb2RlTWFwOm4sc2VsZWN0b3JJZDppLGxheWVyOmZ9PWUsaD1uZXcgSXIoe3BvczpbdC54LHQueV0sYW5jaG9yOlswLDBdLHNpemU6W3Qudyx0LmhdLGlkOmksbmFtZTppZS5zZWxlY3RvcklkLHpJbmRleDoxZTN9KSx1PVtdLGE9bmV3IGdzKHtub3JtYWxpemU6ITAscG9zOlt0LncvMix0LmgvMl0sbGluZVdpZHRoOjEsc3Ryb2tlQ29sb3I6dGhpcy53b3JrT3B0aW9ucy5zdHJva2VDb2xvcix3aWR0aDp0LnctMixoZWlnaHQ6dC5oLTIsbmFtZTppZS5zZWxlY3RvckJvcmRlcklkfSk7dS5wdXNoKGEpLG4uZm9yRWFjaCgoZCxFKT0+e2NvbnN0IHA9W2QucmVjdC54K2QucmVjdC53LzItdC54LGQucmVjdC55K2QucmVjdC5oLzItdC55XSxPPW5ldyBncyh7bm9ybWFsaXplOiEwLHBvczpwLGxpbmVXaWR0aDoxLHN0cm9rZUNvbG9yOm4uc2l6ZT4xP3RoaXMud29ya09wdGlvbnMuc3Ryb2tlQ29sb3I6dm9pZCAwLHdpZHRoOmQucmVjdC53LGhlaWdodDpkLnJlY3QuaCxpZDpgc2VsZWN0b3ItJHtFfWAsbmFtZTpgc2VsZWN0b3ItJHtFfWB9KTt1LnB1c2goTyl9KSx1JiZoLmFwcGVuZCguLi51KSwoZj09bnVsbD92b2lkIDA6Zi5wYXJlbnQpLmFwcGVuZENoaWxkKGgpfWRyYXcoZSx0LG4pe3ZhciBoLHU7Y29uc3R7aW50ZXJzZWN0UmVjdDppLHN1Yk5vZGVNYXA6Zn09bjsodT0oaD10LnBhcmVudCk9PW51bGw/dm9pZCAwOmguZ2V0RWxlbWVudEJ5SWQoZSkpPT1udWxsfHx1LnJlbW92ZSgpLGkmJnRoaXMuZHJhd1NlbGVjdG9yKHtkcmF3UmVjdDppLHN1Yk5vZGVNYXA6ZixzZWxlY3RvcklkOmUsbGF5ZXI6dH0pfWdldFNlbGVjdGVvckluZm8oZSl7Zm9yKGNvbnN0IHQgb2YgZS52YWx1ZXMoKSl7Y29uc3R7b3B0Om4sY2FuUm90YXRlOmksc2NhbGVUeXBlOmYsdG9vbHNUeXBlOmh9PXQ7dGhpcy5zZWxlY3RvckNvbG9yPXRoaXMud29ya09wdGlvbnMuc3Ryb2tlQ29sb3IsdGhpcy5zdHJva2VDb2xvcj1uLnN0cm9rZUNvbG9yLG4uZmlsbENvbG9yJiYodGhpcy5maWxsQ29sb3I9bi5maWxsQ29sb3IpLG4udGV4dE9wdCYmKHRoaXMudGV4dE9wdD1uLnRleHRPcHQpLGg9PT1MdC5UZXh0JiYodGhpcy50ZXh0T3B0PW4pLGUuc2l6ZT09PTE/KHRoaXMudGV4dE9wdCYmKHRoaXMuY2FuVGV4dEVkaXQ9ITApLHRoaXMuY2FuUm90YXRlPWksdGhpcy5zY2FsZVR5cGU9Zik6Zj09PSRlLm5vbmUmJih0aGlzLnNjYWxlVHlwZT1mKX19Y29uc3VtZShlKXtjb25zdHtvcDp0LHdvcmtTdGF0ZTpufT1lLmRhdGE7bGV0IGk9dGhpcy5vbGRTZWxlY3RSZWN0O2lmKG49PT1jZS5TdGFydCYmKGk9dGhpcy5iYWNrVG9GdWxsTGF5ZXIoKSksISh0IT1udWxsJiZ0Lmxlbmd0aCl8fCF0aGlzLnZOb2Rlcy5jdXJOb2RlTWFwLnNpemUpcmV0dXJue3R5cGU6VHQuTm9uZX07dGhpcy51cGRhdGVUZW1wUG9pbnRzKHQpO2NvbnN0IGY9dGhpcy5jb21wdXRTZWxlY3RvcigpO2lmKHRoaXMuc2VsZWN0SWRzJiZhbSh0aGlzLnNlbGVjdElkcyxmLnNlbGVjdElkcykpcmV0dXJue3R5cGU6VHQuTm9uZX07dGhpcy5zZWxlY3RJZHM9Zi5zZWxlY3RJZHM7Y29uc3QgaD1mLmludGVyc2VjdFJlY3Q7cmV0dXJuIHRoaXMuZHJhdyhpZS5zZWxlY3RvcklkLHRoaXMuZHJhd0xheWVyfHx0aGlzLmZ1bGxMYXllcixmKSx0aGlzLmdldFNlbGVjdGVvckluZm8oZi5zdWJOb2RlTWFwKSx0aGlzLm9sZFNlbGVjdFJlY3Q9aCx7dHlwZTpUdC5TZWxlY3QsZGF0YVR5cGU6enQuTG9jYWwscmVjdDokdChoLGkpLHNlbGVjdElkczpmLnNlbGVjdElkcyxvcHQ6dGhpcy53b3JrT3B0aW9ucyxzZWxlY3RSZWN0Omgsc2VsZWN0b3JDb2xvcjp0aGlzLnNlbGVjdG9yQ29sb3Isc3Ryb2tlQ29sb3I6dGhpcy5zdHJva2VDb2xvcixmaWxsQ29sb3I6dGhpcy5maWxsQ29sb3IsdGV4dE9wdDp0aGlzLnRleHRPcHQsY2FuVGV4dEVkaXQ6dGhpcy5jYW5UZXh0RWRpdCxjYW5Sb3RhdGU6dGhpcy5jYW5Sb3RhdGUsc2NhbGVUeXBlOnRoaXMuc2NhbGVUeXBlLHdpbGxTeW5jU2VydmljZTohMH19Y29uc3VtZUFsbCgpe3ZhciBlO3JldHVybihlPXRoaXMuc2VsZWN0SWRzKSE9bnVsbCYmZS5sZW5ndGgmJnRoaXMuc2VhbFRvRHJhd0xheWVyKHRoaXMuc2VsZWN0SWRzKSx0aGlzLm9sZFNlbGVjdFJlY3Q/e3R5cGU6VHQuU2VsZWN0LGRhdGFUeXBlOnp0LkxvY2FsLHJlY3Q6dGhpcy5vbGRTZWxlY3RSZWN0LHNlbGVjdElkczp0aGlzLnNlbGVjdElkcyxvcHQ6dGhpcy53b3JrT3B0aW9ucyxzZWxlY3RSZWN0OnRoaXMub2xkU2VsZWN0UmVjdCxzdHJva2VDb2xvcjp0aGlzLnN0cm9rZUNvbG9yLGZpbGxDb2xvcjp0aGlzLmZpbGxDb2xvcix0ZXh0T3B0OnRoaXMudGV4dE9wdCxjYW5UZXh0RWRpdDp0aGlzLmNhblRleHRFZGl0LGNhblJvdGF0ZTp0aGlzLmNhblJvdGF0ZSxzY2FsZVR5cGU6dGhpcy5zY2FsZVR5cGUsd2lsbFN5bmNTZXJ2aWNlOiExfTp7dHlwZTpUdC5Ob25lfX1jb25zdW1lU2VydmljZSgpe31jbGVhclRtcFBvaW50cygpe3RoaXMudG1wUG9pbnRzLmxlbmd0aD0wfWNsZWFyU2VsZWN0RGF0YSgpe3RoaXMuc2VsZWN0SWRzPXZvaWQgMCx0aGlzLm9sZFNlbGVjdFJlY3Q9dm9pZCAwfWJhY2tUb0Z1bGxMYXllcihlKXt2YXIgZixoO2xldCB0O2NvbnN0IG49W10saT1bXTtmb3IoY29uc3QgdSBvZigoZj10aGlzLmRyYXdMYXllcik9PW51bGw/dm9pZCAwOmYuY2hpbGRyZW4pfHxbXSlpZighKGUhPW51bGwmJmUubGVuZ3RoJiYhZS5pbmNsdWRlcyh1LmlkKSkmJnUuaWQhPT1pZS5zZWxlY3RvcklkKXtjb25zdCBhPXUuY2xvbmVOb2RlKCEwKTtyaSh1KSYmYS5zZWFsKCksdGhpcy5mdWxsTGF5ZXIuZ2V0RWxlbWVudHNCeU5hbWUodS5uYW1lKS5sZW5ndGh8fG4ucHVzaChhKSxpLnB1c2godSk7Y29uc3QgZD0oaD10aGlzLnZOb2Rlcy5nZXQodS5uYW1lKSk9PW51bGw/dm9pZCAwOmgucmVjdDtkJiYodD0kdCh0LGQpKX1yZXR1cm4gaS5mb3JFYWNoKHU9PnUucmVtb3ZlKCkpLG4ubGVuZ3RoJiZ0aGlzLmZ1bGxMYXllci5hcHBlbmQoLi4ubiksdH1zZWFsVG9EcmF3TGF5ZXIoZSl7dmFyIGk7Y29uc3QgdD1bXSxuPVtdO2UuZm9yRWFjaChmPT57dGhpcy5mdWxsTGF5ZXIuZ2V0RWxlbWVudHNCeU5hbWUoZi50b1N0cmluZygpKS5mb3JFYWNoKGg9Pnt2YXIgYTtjb25zdCB1PWguY2xvbmVOb2RlKCEwKTtyaShoKSYmdS5zZWFsKCksKGE9dGhpcy5kcmF3TGF5ZXIpIT1udWxsJiZhLmdldEVsZW1lbnRzQnlOYW1lKGgubmFtZSkubGVuZ3RofHx0LnB1c2godSksbi5wdXNoKGgpfSl9KSxuLmZvckVhY2goZj0+Zi5yZW1vdmUoKSksdCYmKChpPXRoaXMuZHJhd0xheWVyKT09bnVsbHx8aS5hcHBlbmQoLi4udCkpfWdldFNlbGVjdG9yUmVjdChlLHQpe3ZhciBoO2xldCBuO2NvbnN0IGk9KGg9ZS5wYXJlbnQpPT1udWxsP3ZvaWQgMDpoLmdldEVsZW1lbnRCeUlkKHQpLGY9aT09bnVsbD92b2lkIDA6aS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtyZXR1cm4gZiYmKG49JHQobix7eDpNYXRoLmZsb29yKGYueCkseTpNYXRoLmZsb29yKGYueSksdzpNYXRoLnJvdW5kKGYud2lkdGgpLGg6TWF0aC5yb3VuZChmLmhlaWdodCl9KSksbn1pc0NhbkZpbGxDb2xvcihlKXtyZXR1cm4gZT09PUx0LkVsbGlwc2V8fGU9PT1MdC5UcmlhbmdsZXx8ZT09PUx0LlJlY3RhbmdsZXx8ZT09PUx0LlBvbHlnb258fGU9PT1MdC5TdGFyfHxlPT09THQuU3BlZWNoQmFsbG9vbn11cGRhdGVTZWxlY3RvcihlKXtjb25zdHt1cGRhdGVTZWxlY3Rvck9wdDp0LHNlbGVjdElkczpuLHZOb2RlczppLHdpbGxTZXJpYWxpemVEYXRhOmYsd29ya2VyOmh9PWUsdT10aGlzLmRyYXdMYXllcjtpZighdSlyZXR1cm47bGV0IGE7Y29uc3QgZD1uZXcgTWFwLHtib3g6RSx3b3JrU3RhdGU6cCxhbmdsZTpPLHRyYW5zbGF0ZTptfT10O2xldCBiPVswLDBdLE09WzEsMV0seT1bMCwwXSxTO2lmKEV8fG18fEJhLmlzTnVtYmVyKE8pKXtpZihwPT09Y2UuU3RhcnQpcmV0dXJuIGkuc2V0VGFyZ2V0KCkse3R5cGU6VHQuU2VsZWN0LGRhdGFUeXBlOnp0LkxvY2FsLHNlbGVjdFJlY3Q6dGhpcy5vbGRTZWxlY3RSZWN0LHJlY3Q6dGhpcy5vbGRTZWxlY3RSZWN0fTtpZihTPWkuZ2V0TGFzdFRhcmdldCgpLFMmJkUpe2xldCBjO249PW51bGx8fG4uZm9yRWFjaChsPT57Y29uc3Qgdj1TPT1udWxsP3ZvaWQgMDpTLmdldChsKTtjPSR0KGMsdj09bnVsbD92b2lkIDA6di5yZWN0KX0pLGMmJihNPVtFLncvYy53LEUuaC9jLmhdLGI9W0UueCtFLncvMi0oYy54K2Mudy8yKSxFLnkrRS5oLzItKGMueStjLmgvMildLHk9W2MueCtjLncvMixjLnkrYy5oLzJdKX19bj09bnVsbHx8bi5mb3JFYWNoKGM9Pntjb25zdCBsPWkuZ2V0KGMpO2lmKGwpe2NvbnN0e3Rvb2xzVHlwZTp2fT1sO2xldCBUPSh1PT1udWxsP3ZvaWQgMDp1LmdldEVsZW1lbnRzQnlOYW1lKGMpKVswXTtpZihUKXtjb25zdCBSPXsuLi50fTtsZXQgTDtpZih2KXtpZihTJiYoTD1TLmdldChjKSxMJiZFKSl7Ui5ib3hTY2FsZT1NO2NvbnN0IEE9W0wucmVjdC54K0wucmVjdC53LzIsTC5yZWN0LnkrTC5yZWN0LmgvMl0sdz1bQVswXS15WzBdLEFbMV0teVsxXV07Ui5ib3hUcmFuc2xhdGU9W3dbMF0qKE1bMF0tMSkrYlswXSx3WzFdKihNWzFdLTEpK2JbMV1dfWNvbnN0IE49WGEodik7aWYoTj09bnVsbHx8Ti51cGRhdGVOb2RlT3B0KHtub2RlOlQsb3B0OlIsdk5vZGVzOmksd2lsbFNlcmlhbGl6ZURhdGE6Zix0YXJnZXROb2RlOkx9KSxsJiZoJiYoZiYmKFIuYW5nbGV8fFIudHJhbnNsYXRlKXx8Ui5ib3gmJlIud29ya1N0YXRlIT09Y2UuU3RhcnQpKXtjb25zdCBBPWguY3JlYXRlV29ya1NoYXBlTm9kZSh7dG9vbHNUeXBlOnYsdG9vbHNPcHQ6bC5vcHR9KTtBPT1udWxsfHxBLnNldFdvcmtJZChjKTtjb25zdCB3PUE9PW51bGw/dm9pZCAwOkEuY29uc3VtZVNlcnZpY2Uoe29wOmwub3AsaXNGdWxsV29yazohMSxyZXBsYWNlSWQ6Yyxpc0NsZWFyQWxsOiExfSk7dyYmKGwucmVjdD13LGkuc2V0SW5mbyhjLGwpKSxUPSh1PT1udWxsP3ZvaWQgMDp1LmdldEVsZW1lbnRzQnlOYW1lKGMpKVswXX1sJiYoZC5zZXQoYyxsKSxhPSR0KGEsbC5yZWN0KSl9fX19LHRoaXMpLFMmJnA9PT1jZS5Eb25lJiZpLmRlbGV0ZUxhc3RUYXJnZXQoKSx0aGlzLmRyYXcoaWUuc2VsZWN0b3JJZCx1LHtzZWxlY3RJZHM6bnx8W10sc3ViTm9kZU1hcDpkLGludGVyc2VjdFJlY3Q6YX0pO2NvbnN0IHM9JHQodGhpcy5vbGRTZWxlY3RSZWN0LGEpO3JldHVybiB0aGlzLm9sZFNlbGVjdFJlY3Q9YSx7dHlwZTpUdC5TZWxlY3QsZGF0YVR5cGU6enQuTG9jYWwsc2VsZWN0UmVjdDphLHJlY3Q6c319Ymx1clNlbGVjdG9yKCl7Y29uc3QgZT10aGlzLmJhY2tUb0Z1bGxMYXllcigpO3JldHVybnt0eXBlOlR0LlNlbGVjdCxkYXRhVHlwZTp6dC5Mb2NhbCxyZWN0OmUsc2VsZWN0SWRzOltdLHdpbGxTeW5jU2VydmljZTohMH19Z2V0UmlnaHRTZXJ2aWNlSWQoZSl7cmV0dXJuIGUucmVwbGFjZSgiKysiLCItIil9c2VsZWN0U2VydmljZU5vZGUoZSx0KXtjb25zdHtzZWxlY3RJZHM6bn09dCxpPXRoaXMuZ2V0UmlnaHRTZXJ2aWNlSWQoZSksZj10aGlzLmdldFNlbGVjdG9yUmVjdCh0aGlzLmZ1bGxMYXllcixpKTtsZXQgaDtjb25zdCB1PW5ldyBNYXA7cmV0dXJuIG49PW51bGx8fG4uZm9yRWFjaChhPT57Y29uc3QgZD10aGlzLnZOb2Rlcy5nZXQoYSksRT10aGlzLmZ1bGxMYXllci5nZXRFbGVtZW50c0J5TmFtZShhKVswXTtkJiZFJiYoaD0kdChoLGQucmVjdCksdS5zZXQoYSxkKSl9KSx0aGlzLmRyYXcoaSx0aGlzLmZ1bGxMYXllcix7aW50ZXJzZWN0UmVjdDpoLHNlbGVjdElkczpufHxbXSxzdWJOb2RlTWFwOnV9KSwkdChoLGYpfXJlUmVuZGVyU2VsZWN0b3IoKXt2YXIgbjtsZXQgZTtjb25zdCB0PW5ldyBNYXA7cmV0dXJuKG49dGhpcy5zZWxlY3RJZHMpPT1udWxsfHxuLmZvckVhY2goaT0+e2NvbnN0IGY9dGhpcy52Tm9kZXMuZ2V0KGkpO2U9JHQoZSxmPT1udWxsP3ZvaWQgMDpmLnJlY3QpfSx0aGlzKSx0aGlzLmRyYXcoaWUuc2VsZWN0b3JJZCx0aGlzLmRyYXdMYXllcnx8dGhpcy5mdWxsTGF5ZXIse2ludGVyc2VjdFJlY3Q6ZSxzdWJOb2RlTWFwOnQsc2VsZWN0SWRzOnRoaXMuc2VsZWN0SWRzfHxbXX0pLHRoaXMuZ2V0U2VsZWN0ZW9ySW5mbyh0KSx0aGlzLm9sZFNlbGVjdFJlY3Q9ZSxlfXVwZGF0ZVNlbGVjdElkcyhlKXt2YXIgaCx1O2xldCB0O2NvbnN0IG49KGg9dGhpcy5zZWxlY3RJZHMpPT1udWxsP3ZvaWQgMDpoLmZpbHRlcihhPT4hZS5pbmNsdWRlcyhhKSksaT1lLmZpbHRlcihhPT57dmFyIGQ7cmV0dXJuISgoZD10aGlzLnNlbGVjdElkcykhPW51bGwmJmQuaW5jbHVkZXMoYSkpfSk7aWYobiE9bnVsbCYmbi5sZW5ndGgmJih0PXRoaXMuYmFja1RvRnVsbExheWVyKG4pKSxpLmxlbmd0aCl7dGhpcy5zZWFsVG9EcmF3TGF5ZXIoaSk7Zm9yKGNvbnN0IGEgb2YgaSl7Y29uc3QgZD0odT10aGlzLnZOb2Rlcy5nZXQoYSkpPT1udWxsP3ZvaWQgMDp1LnJlY3Q7ZCYmKHQ9JHQodCxkKSl9fXRoaXMuc2VsZWN0SWRzPWU7Y29uc3QgZj10aGlzLnJlUmVuZGVyU2VsZWN0b3IoKTtyZXR1cm57YmdSZWN0OnQsc2VsZWN0UmVjdDpmfX19T2JqZWN0LmRlZmluZVByb3BlcnR5KGllLCJzZWxlY3RvcklkIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6VG19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoaWUsInNlbGVjdG9yQm9yZGVySWQiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZToic2VsZWN0b3ItYm9yZGVyIn0pO2NsYXNzIHphIGV4dGVuZHMgRHR7Y29uc3RydWN0b3IoZSl7c3VwZXIoZSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImNhblJvdGF0ZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOiExfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInNjYWxlVHlwZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOiRlLmJvdGh9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidG9vbHNUeXBlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6THQuQXJyb3d9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidG1wUG9pbnRzIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6W119KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywid29ya09wdGlvbnMiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywib2xkUmVjdCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJhcnJvd1RpcFdpZHRoIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInN5bmNUaW1lc3RhbXAiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSx0aGlzLndvcmtPcHRpb25zPWUudG9vbHNPcHQsdGhpcy5hcnJvd1RpcFdpZHRoPXRoaXMud29ya09wdGlvbnMudGhpY2tuZXNzKjQsdGhpcy5zeW5jVGltZXN0YW1wPTAsdGhpcy5zeW5jVW5pdFRpbWU9NTB9Y29uc3VtZShlKXt2YXIgbTtjb25zdHtkYXRhOnQsaXNGdWxsV29yazpuLGlzU3ViV29ya2VyOml9PWUsZj0obT10PT1udWxsP3ZvaWQgMDp0LndvcmtJZCk9PW51bGw/dm9pZCAwOm0udG9TdHJpbmcoKTtpZighZilyZXR1cm57dHlwZTpUdC5Ob25lfTtjb25zdHtvcDpoLHdvcmtTdGF0ZTp1fT10LGE9aD09bnVsbD92b2lkIDA6aC5sZW5ndGg7aWYoIWF8fGE8MilyZXR1cm57dHlwZTpUdC5Ob25lfTtsZXQgZDtpZih1PT09Y2UuU3RhcnQ/KHRoaXMudG1wUG9pbnRzPVtuZXcgRnQoaFswXSxoWzFdKV0sZD0hMSk6ZD10aGlzLnVwZGF0ZVRlbXBQb2ludHMoaCksIWQpcmV0dXJue3R5cGU6VHQuTm9uZX07aWYoIWkpe2NvbnN0IGI9RGF0ZS5ub3coKTtyZXR1cm4gYi10aGlzLnN5bmNUaW1lc3RhbXA+dGhpcy5zeW5jVW5pdFRpbWU/KHRoaXMuc3luY1RpbWVzdGFtcD1iLHt0eXBlOlR0LkRyYXdXb3JrLGRhdGFUeXBlOnp0LkxvY2FsLHdvcmtJZDpmLG9wOnRoaXMudG1wUG9pbnRzLm1hcChNPT5bLi4uTS5YWSwwXSkuZmxhdCgxKSxpc1N5bmM6ITAsaW5kZXg6MH0pOnt0eXBlOlR0Lk5vbmV9fWNvbnN0IEU9bj90aGlzLmZ1bGxMYXllcjp0aGlzLmRyYXdMYXllcnx8dGhpcy5mdWxsTGF5ZXIscD10aGlzLmRyYXcoe3dvcmtJZDpmLGxheWVyOkV9KSxPPSR0KHAsdGhpcy5vbGRSZWN0KTtyZXR1cm4gdGhpcy5vbGRSZWN0PXAse3JlY3Q6Tyx0eXBlOlR0LkRyYXdXb3JrLGRhdGFUeXBlOnp0LkxvY2FsLHdvcmtJZDpmfX1jb25zdW1lQWxsKGUpe3ZhciBhO2NvbnN0e2RhdGE6dH09ZSxuPShhPXQ9PW51bGw/dm9pZCAwOnQud29ya0lkKT09bnVsbD92b2lkIDA6YS50b1N0cmluZygpO2lmKCFuKXJldHVybnt0eXBlOlR0Lk5vbmV9O2lmKHRoaXMudG1wUG9pbnRzLmxlbmd0aDwyKXJldHVybnt0eXBlOlR0LlJlbW92ZU5vZGUscmVtb3ZlSWRzOltuXX07Y29uc3QgaT10aGlzLmZ1bGxMYXllcixmPXRoaXMuZHJhdyh7d29ya0lkOm4sbGF5ZXI6aX0pO3RoaXMub2xkUmVjdD1mO2NvbnN0IGg9dGhpcy50bXBQb2ludHMubWFwKGQ9PlsuLi5kLlhZLDBdKS5mbGF0KDEpLHU9eXIoaCk7cmV0dXJuIHRoaXMudk5vZGVzLnNldEluZm8obix7cmVjdDpmLG9wOmgsb3B0OnRoaXMud29ya09wdGlvbnMsdG9vbHNUeXBlOnRoaXMudG9vbHNUeXBlLGNhblJvdGF0ZTp0aGlzLmNhblJvdGF0ZSxzY2FsZVR5cGU6dGhpcy5zY2FsZVR5cGUsY2VudGVyUG9zOkR0LmdldENlbnRlclBvcyhmLGkpfSkse3JlY3Q6Zix0eXBlOlR0LkZ1bGxXb3JrLGRhdGFUeXBlOnp0LkxvY2FsLHdvcmtJZDpuLG9wczp1LGlzU3luYzohMH19ZHJhdyhlKXt2YXIgUztjb25zdHt3b3JrSWQ6dCxsYXllcjpufT1lO3RoaXMuZnVsbExheWVyLmdldEVsZW1lbnRzQnlOYW1lKHQpLm1hcChzPT5zLnJlbW92ZSgpKSwoUz10aGlzLmRyYXdMYXllcik9PW51bGx8fFMuZ2V0RWxlbWVudHNCeU5hbWUodCkubWFwKHM9PnMucmVtb3ZlKCkpO2NvbnN0e3N0cm9rZUNvbG9yOmksdGhpY2tuZXNzOmYsekluZGV4Omgsc2NhbGU6dSxyb3RhdGU6YSx0cmFuc2xhdGU6ZH09dGhpcy53b3JrT3B0aW9ucyxFPW4ud29ybGRQb3NpdGlvbixwPW4ud29ybGRTY2FsaW5nLHtwb2ludHM6TyxyZWN0Om19PXRoaXMuY29tcHV0RHJhd1BvaW50cyhmKSxNPXtwb3M6W20ueCttLncvMixtLnkrbS5oLzJdLG5hbWU6dCxpZDp0LGNsb3NlOiEwLHBvaW50czpPLGZpbGxDb2xvcjppLHN0cm9rZUNvbG9yOmksbGluZVdpZHRoOjAsbm9ybWFsaXplOiEwLHpJbmRleDpofTt1JiYoTS5zY2FsZT11KSxhJiYoTS5yb3RhdGU9YSksZCYmKE0udHJhbnNsYXRlPWQpO2NvbnN0IHk9bmV3IGNuKE0pO2lmKG4uYXBwZW5kKHkpLHV8fGF8fGQpe2NvbnN0IHM9eS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtyZXR1cm57eDpNYXRoLmZsb29yKHMueC1EdC5TYWZlQm9yZGVyUGFkZGluZykseTpNYXRoLmZsb29yKHMueS1EdC5TYWZlQm9yZGVyUGFkZGluZyksdzpNYXRoLmZsb29yKHMud2lkdGgrRHQuU2FmZUJvcmRlclBhZGRpbmcqMiksaDpNYXRoLmZsb29yKHMuaGVpZ2h0K0R0LlNhZmVCb3JkZXJQYWRkaW5nKjIpfX1yZXR1cm57eDpNYXRoLmZsb29yKG0ueCpwWzBdK0VbMF0tRHQuU2FmZUJvcmRlclBhZGRpbmcpLHk6TWF0aC5mbG9vcihtLnkqcFsxXStFWzFdLUR0LlNhZmVCb3JkZXJQYWRkaW5nKSx3Ok1hdGguZmxvb3IobS53KnBbMF0rMipEdC5TYWZlQm9yZGVyUGFkZGluZyksaDpNYXRoLmZsb29yKG0uaCpwWzFdKzIqRHQuU2FmZUJvcmRlclBhZGRpbmcpfX1jb21wdXREcmF3UG9pbnRzKGUpe3JldHVybiB0aGlzLnRtcFBvaW50c1sxXS5kaXN0YW5jZSh0aGlzLnRtcFBvaW50c1swXSk+dGhpcy5hcnJvd1RpcFdpZHRoP3RoaXMuY29tcHV0RnVsbEFycm93UG9pbnRzKGUpOnRoaXMuY29tcHV0VHJpYW5nbGVQb2ludHMoKX1jb21wdXRGdWxsQXJyb3dQb2ludHMoZSl7Y29uc3QgdD1FdC5TdWIodGhpcy50bXBQb2ludHNbMV0sdGhpcy50bXBQb2ludHNbMF0pLnVuaSgpLG49RXQuUGVyKHQpLm11bChlLzIpLGk9RnQuU3ViKHRoaXMudG1wUG9pbnRzWzBdLG4pLGY9RnQuQWRkKHRoaXMudG1wUG9pbnRzWzBdLG4pLGg9RXQuTXVsKHQsdGhpcy5hcnJvd1RpcFdpZHRoKSx1PUV0LlN1Yih0aGlzLnRtcFBvaW50c1sxXSxoKSxhPUZ0LlN1Yih1LG4pLGQ9RnQuQWRkKHUsbiksRT1FdC5QZXIodCkubXVsKGUqMS41KSxwPUZ0LlN1Yih1LEUpLE89RnQuQWRkKHUsRSksbT1baSxhLHAsdGhpcy50bXBQb2ludHNbMV0sTyxkLGZdO3JldHVybntwb2ludHM6bS5tYXAoYj0+RnQuU3ViKGIsdGhpcy50bXBQb2ludHNbMF0pLlhZKS5mbGF0KDEpLHJlY3Q6eGUobSksaXNUcmlhbmdsZTohMSxwb3M6dGhpcy50bXBQb2ludHNbMF0uWFl9fWNvbXB1dFRyaWFuZ2xlUG9pbnRzKCl7Y29uc3QgZT1FdC5TdWIodGhpcy50bXBQb2ludHNbMV0sdGhpcy50bXBQb2ludHNbMF0pLnVuaSgpLHQ9dGhpcy50bXBQb2ludHNbMV0uZGlzdGFuY2UodGhpcy50bXBQb2ludHNbMF0pLG49RXQuUGVyKGUpLm11bChNYXRoLmZsb29yKHQqMy84KSksaT1GdC5TdWIodGhpcy50bXBQb2ludHNbMF0sbiksZj1GdC5BZGQodGhpcy50bXBQb2ludHNbMF0sbiksaD1baSx0aGlzLnRtcFBvaW50c1sxXSxmXTtyZXR1cm57cG9pbnRzOmgubWFwKHU9PkZ0LlN1Yih1LHRoaXMudG1wUG9pbnRzWzBdKS5YWSkuZmxhdCgxKSxyZWN0OnhlKGgpLGlzVHJpYW5nbGU6ITAscG9zOnRoaXMudG1wUG9pbnRzWzBdLlhZfX11cGRhdGVUZW1wUG9pbnRzKGUpe2NvbnN0IHQ9ZS5zbGljZSgtMiksbj1uZXcgRnQodFswXSx0WzFdKSxpPXRoaXMudG1wUG9pbnRzWzBdLHt0aGlja25lc3M6Zn09dGhpcy53b3JrT3B0aW9ucztpZihpLmlzTmVhcihuLGYpKXJldHVybiExO2lmKHRoaXMudG1wUG9pbnRzLmxlbmd0aD09PTIpe2lmKG4uaXNOZWFyKHRoaXMudG1wUG9pbnRzWzFdLDEpKXJldHVybiExO3RoaXMudG1wUG9pbnRzWzFdPW59ZWxzZSB0aGlzLnRtcFBvaW50cy5wdXNoKG4pO3JldHVybiEwfWNvbnN1bWVTZXJ2aWNlKGUpe3ZhciB1O2NvbnN0e29wOnQsaXNGdWxsV29yazpufT1lLGk9KHU9dGhpcy53b3JrSWQpPT1udWxsP3ZvaWQgMDp1LnRvU3RyaW5nKCk7aWYoIWkpcmV0dXJuO3RoaXMudG1wUG9pbnRzLmxlbmd0aD0wO2ZvcihsZXQgYT0wO2E8dC5sZW5ndGg7YSs9Myl0aGlzLnRtcFBvaW50cy5wdXNoKG5ldyBGdCh0W2FdLHRbYSsxXSx0W2ErMl0pKTtjb25zdCBmPW4/dGhpcy5mdWxsTGF5ZXI6dGhpcy5kcmF3TGF5ZXJ8fHRoaXMuZnVsbExheWVyLGg9dGhpcy5kcmF3KHt3b3JrSWQ6aSxsYXllcjpmfSk7cmV0dXJuIHRoaXMub2xkUmVjdD1oLHRoaXMudk5vZGVzLnNldEluZm8oaSx7cmVjdDpoLG9wOnQsb3B0OnRoaXMud29ya09wdGlvbnMsdG9vbHNUeXBlOnRoaXMudG9vbHNUeXBlLGNhblJvdGF0ZTp0aGlzLmNhblJvdGF0ZSxzY2FsZVR5cGU6dGhpcy5zY2FsZVR5cGUsY2VudGVyUG9zOkR0LmdldENlbnRlclBvcyhoLGYpfSksaH1jbGVhclRtcFBvaW50cygpe3RoaXMudG1wUG9pbnRzLmxlbmd0aD0wfXN0YXRpYyB1cGRhdGVOb2RlT3B0KGUpe3ZhciB1O2NvbnN0e25vZGU6dCxvcHQ6bix2Tm9kZXM6aX09ZSx7c3Ryb2tlQ29sb3I6Zn09bixoPWkuZ2V0KHQubmFtZSk7cmV0dXJuIGYmJih0LnNldEF0dHJpYnV0ZSgic3Ryb2tlQ29sb3IiLGYpLHQuc2V0QXR0cmlidXRlKCJmaWxsQ29sb3IiLGYpLCh1PWg9PW51bGw/dm9pZCAwOmgub3B0KSE9bnVsbCYmdS5zdHJva2VDb2xvciYmKGgub3B0LnN0cm9rZUNvbG9yPWYpLGgmJmkuc2V0SW5mbyh0Lm5hbWUsaCkpLER0LnVwZGF0ZU5vZGVPcHQoZSl9fWNsYXNzICRhIGV4dGVuZHMgRHR7Y29uc3RydWN0b3IoZSl7c3VwZXIoZSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImNhblJvdGF0ZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOiExfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInNjYWxlVHlwZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOiRlLmFsbH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ0b29sc1R5cGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpMdC5FbGxpcHNlfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInRtcFBvaW50cyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOltdfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIndvcmtPcHRpb25zIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIm9sZFJlY3QiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywic3luY1RpbWVzdGFtcCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLHRoaXMud29ya09wdGlvbnM9ZS50b29sc09wdCx0aGlzLnN5bmNUaW1lc3RhbXA9MCx0aGlzLnN5bmNVbml0VGltZT01MH1jb25zdW1lKGUpe3ZhciBtO2NvbnN0e2RhdGE6dCxpc0Z1bGxXb3JrOm4saXNTdWJXb3JrZXI6aX09ZSxmPShtPXQ9PW51bGw/dm9pZCAwOnQud29ya0lkKT09bnVsbD92b2lkIDA6bS50b1N0cmluZygpO2lmKCFmKXJldHVybnt0eXBlOlR0Lk5vbmV9O2NvbnN0e29wOmgsd29ya1N0YXRlOnV9PXQsYT1oPT1udWxsP3ZvaWQgMDpoLmxlbmd0aDtpZighYXx8YTwyKXJldHVybnt0eXBlOlR0Lk5vbmV9O2xldCBkO2lmKHU9PT1jZS5TdGFydD8odGhpcy50bXBQb2ludHM9W25ldyBGdChoWzBdLGhbMV0pXSxkPSExKTpkPXRoaXMudXBkYXRlVGVtcFBvaW50cyhoKSwhZClyZXR1cm57dHlwZTpUdC5Ob25lfTtpZighaSl7Y29uc3QgYj1EYXRlLm5vdygpO3JldHVybiBiLXRoaXMuc3luY1RpbWVzdGFtcD50aGlzLnN5bmNVbml0VGltZT8odGhpcy5zeW5jVGltZXN0YW1wPWIse3R5cGU6VHQuRHJhd1dvcmssZGF0YVR5cGU6enQuTG9jYWwsd29ya0lkOmYsb3A6dGhpcy50bXBQb2ludHMubWFwKE09PlsuLi5NLlhZLDBdKS5mbGF0KDEpLGlzU3luYzohMCxpbmRleDowfSk6e3R5cGU6VHQuTm9uZX19Y29uc3QgRT1uP3RoaXMuZnVsbExheWVyOnRoaXMuZHJhd0xheWVyfHx0aGlzLmZ1bGxMYXllcixwPXRoaXMuZHJhdyh7d29ya0lkOmYsbGF5ZXI6RSxpc0RyYXdpbmc6ITB9KSxPPSR0KHAsdGhpcy5vbGRSZWN0KTtyZXR1cm4gdGhpcy5vbGRSZWN0PXAse3JlY3Q6Tyx0eXBlOlR0LkRyYXdXb3JrLGRhdGFUeXBlOnp0LkxvY2FsLHdvcmtJZDpmfX1jb25zdW1lQWxsKGUpe3ZhciBhO2NvbnN0e2RhdGE6dH09ZSxuPShhPXQ9PW51bGw/dm9pZCAwOnQud29ya0lkKT09bnVsbD92b2lkIDA6YS50b1N0cmluZygpO2lmKCFuKXJldHVybnt0eXBlOlR0Lk5vbmV9O2lmKHRoaXMudG1wUG9pbnRzLmxlbmd0aDwyKXJldHVybnt0eXBlOlR0LlJlbW92ZU5vZGUscmVtb3ZlSWRzOltuXX07Y29uc3QgaT10aGlzLmZ1bGxMYXllcixmPXRoaXMuZHJhdyh7d29ya0lkOm4sbGF5ZXI6aSxpc0RyYXdpbmc6ITF9KTt0aGlzLm9sZFJlY3Q9Zjtjb25zdCBoPXRoaXMudG1wUG9pbnRzLm1hcChkPT5bLi4uZC5YWSwwXSkuZmxhdCgxKSx1PXlyKGgpO3JldHVybiB0aGlzLnZOb2Rlcy5zZXRJbmZvKG4se3JlY3Q6ZixvcDpoLG9wdDp0aGlzLndvcmtPcHRpb25zLHRvb2xzVHlwZTp0aGlzLnRvb2xzVHlwZSxjYW5Sb3RhdGU6dGhpcy5jYW5Sb3RhdGUsc2NhbGVUeXBlOnRoaXMuc2NhbGVUeXBlLGNlbnRlclBvczpmJiZEdC5nZXRDZW50ZXJQb3MoZixpKX0pLHtyZWN0OmYsdHlwZTpUdC5GdWxsV29yayxkYXRhVHlwZTp6dC5Mb2NhbCx3b3JrSWQ6bixvcHM6dSxpc1N5bmM6ITB9fWRyYXcoZSl7dmFyIGw7Y29uc3R7d29ya0lkOnQsbGF5ZXI6bixpc0RyYXdpbmc6aX09ZTt0aGlzLmZ1bGxMYXllci5nZXRFbGVtZW50c0J5TmFtZSh0KS5tYXAodj0+di5yZW1vdmUoKSksKGw9dGhpcy5kcmF3TGF5ZXIpPT1udWxsfHxsLmdldEVsZW1lbnRzQnlOYW1lKHQpLm1hcCh2PT52LnJlbW92ZSgpKTtjb25zdHtzdHJva2VDb2xvcjpmLGZpbGxDb2xvcjpoLHRoaWNrbmVzczp1LHpJbmRleDphLHNjYWxlOmQscm90YXRlOkUsdHJhbnNsYXRlOnB9PXRoaXMud29ya09wdGlvbnMsTz1uLndvcmxkUG9zaXRpb24sbT1uLndvcmxkU2NhbGluZyx7cmFkaXVzOmIscmVjdDpNLHBvczp5fT10aGlzLmNvbXB1dERyYXdQb2ludHModSksUz17cG9zOnksbmFtZTp0LGlkOnQscmFkaXVzOmIsbGluZVdpZHRoOnUsZmlsbENvbG9yOmghPT0idHJhbnNwYXJlbnQiJiZofHx2b2lkIDAsc3Ryb2tlQ29sb3I6Zixub3JtYWxpemU6ITAsekluZGV4OmF9LHM9e3g6TWF0aC5mbG9vcihNLngqbVswXStPWzBdLUR0LlNhZmVCb3JkZXJQYWRkaW5nKSx5Ok1hdGguZmxvb3IoTS55Km1bMV0rT1sxXS1EdC5TYWZlQm9yZGVyUGFkZGluZyksdzpNYXRoLmZsb29yKE0udyptWzBdKzIqRHQuU2FmZUJvcmRlclBhZGRpbmcpLGg6TWF0aC5mbG9vcihNLmgqbVsxXSsyKkR0LlNhZmVCb3JkZXJQYWRkaW5nKX07aWYoaSl7Y29uc3R7bmFtZTp2LGlkOlQsekluZGV4OlIsc3Ryb2tlQ29sb3I6TH09UyxOPUR0LmdldENlbnRlclBvcyhzLG4pLEE9bmV3IElyKHtuYW1lOnYsaWQ6VCx6SW5kZXg6Uixwb3M6TixhbmNob3I6Wy41LC41XSxzaXplOltzLncscy5oXX0pLHc9bmV3IFdhKHsuLi5TLHBvczpbMCwwXX0pLEI9bmV3IEhyKHtkOiJNLTQsMEg0TTAsLTRWNCIsbm9ybWFsaXplOiEwLHBvczpbMCwwXSxzdHJva2VDb2xvcjpMLGxpbmVXaWR0aDoxLHNjYWxlOlsxL21bMF0sMS9tWzFdXX0pO3JldHVybiBBLmFwcGVuZCh3LEIpLG4uYXBwZW5kKEEpLHN9ZCYmKFMuc2NhbGU9ZCksRSYmKFMucm90YXRlPUUpLHAmJihTLnRyYW5zbGF0ZT1wKTtjb25zdCBjPW5ldyBXYShTKTtpZihuLmFwcGVuZChjKSxFfHxkfHxwKXtjb25zdCB2PWMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7cmV0dXJue3g6TWF0aC5mbG9vcih2LngtRHQuU2FmZUJvcmRlclBhZGRpbmcpLHk6TWF0aC5mbG9vcih2LnktRHQuU2FmZUJvcmRlclBhZGRpbmcpLHc6TWF0aC5mbG9vcih2LndpZHRoK0R0LlNhZmVCb3JkZXJQYWRkaW5nKjIpLGg6TWF0aC5mbG9vcih2LmhlaWdodCtEdC5TYWZlQm9yZGVyUGFkZGluZyoyKX19cmV0dXJuIHN9Y29tcHV0RHJhd1BvaW50cyhlKXtjb25zdCB0PXhlKHRoaXMudG1wUG9pbnRzKSxuPXhlKHRoaXMudG1wUG9pbnRzLGUpLGk9W01hdGguZmxvb3IodC54K3Qudy8yKSxNYXRoLmZsb29yKHQueSt0LmgvMildO3JldHVybntyZWN0Om4scG9zOmkscmFkaXVzOltNYXRoLmZsb29yKHQudy8yKSxNYXRoLmZsb29yKHQuaC8yKV19fXVwZGF0ZVRlbXBQb2ludHMoZSl7Y29uc3QgdD1lLnNsaWNlKC0yKSxuPW5ldyBGdCh0WzBdLHRbMV0pLGk9dGhpcy50bXBQb2ludHNbMF0se3RoaWNrbmVzczpmfT10aGlzLndvcmtPcHRpb25zO2lmKGkuaXNOZWFyKG4sZikpcmV0dXJuITE7aWYodGhpcy50bXBQb2ludHMubGVuZ3RoPT09Mil7aWYobi5pc05lYXIodGhpcy50bXBQb2ludHNbMV0sMSkpcmV0dXJuITE7dGhpcy50bXBQb2ludHNbMV09bn1lbHNlIHRoaXMudG1wUG9pbnRzLnB1c2gobik7cmV0dXJuITB9Y29uc3VtZVNlcnZpY2UoZSl7dmFyIHU7Y29uc3R7b3A6dCxpc0Z1bGxXb3JrOm59PWUsaT0odT10aGlzLndvcmtJZCk9PW51bGw/dm9pZCAwOnUudG9TdHJpbmcoKTtpZighaSlyZXR1cm47dGhpcy50bXBQb2ludHMubGVuZ3RoPTA7Zm9yKGxldCBhPTA7YTx0Lmxlbmd0aDthKz0zKXRoaXMudG1wUG9pbnRzLnB1c2gobmV3IEZ0KHRbYV0sdFthKzFdLHRbYSsyXSkpO2NvbnN0IGY9bj90aGlzLmZ1bGxMYXllcjp0aGlzLmRyYXdMYXllcnx8dGhpcy5mdWxsTGF5ZXIsaD10aGlzLmRyYXcoe3dvcmtJZDppLGxheWVyOmYsaXNEcmF3aW5nOiExfSk7cmV0dXJuIHRoaXMub2xkUmVjdD1oLHRoaXMudk5vZGVzLnNldEluZm8oaSx7cmVjdDpoLG9wOnQsb3B0OnRoaXMud29ya09wdGlvbnMsdG9vbHNUeXBlOnRoaXMudG9vbHNUeXBlLGNhblJvdGF0ZTp0aGlzLmNhblJvdGF0ZSxzY2FsZVR5cGU6dGhpcy5zY2FsZVR5cGUsY2VudGVyUG9zOkR0LmdldENlbnRlclBvcyhoLGYpfSksaH1jbGVhclRtcFBvaW50cygpe3RoaXMudG1wUG9pbnRzLmxlbmd0aD0wfXN0YXRpYyB1cGRhdGVOb2RlT3B0KGUpe3ZhciBkLEU7Y29uc3R7bm9kZTp0LG9wdDpuLHZOb2RlczppfT1lLHtzdHJva2VDb2xvcjpmLGZpbGxDb2xvcjpofT1uLHU9aS5nZXQodC5uYW1lKTtsZXQgYT10O3JldHVybiB0LnRhZ05hbWU9PT0iR1JPVVAiJiYoYT10LmNoaWxkcmVuWzBdKSxmJiYoYS5zZXRBdHRyaWJ1dGUoInN0cm9rZUNvbG9yIixmKSwoZD11PT1udWxsP3ZvaWQgMDp1Lm9wdCkhPW51bGwmJmQuc3Ryb2tlQ29sb3ImJih1Lm9wdC5zdHJva2VDb2xvcj1mKSksaCYmKGg9PT0idHJhbnNwYXJlbnQiP2Euc2V0QXR0cmlidXRlKCJmaWxsQ29sb3IiLCJyZ2JhKDAsMCwwLDApIik6YS5zZXRBdHRyaWJ1dGUoImZpbGxDb2xvciIsaCksKEU9dT09bnVsbD92b2lkIDA6dS5vcHQpIT1udWxsJiZFLmZpbGxDb2xvciYmKHUub3B0LmZpbGxDb2xvcj1oKSksdSYmaS5zZXRJbmZvKHQubmFtZSx1KSxEdC51cGRhdGVOb2RlT3B0KGUpfX1jbGFzcyBHYSBleHRlbmRzIER0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJjYW5Sb3RhdGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzY2FsZVR5cGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTokZS5hbGx9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidG9vbHNUeXBlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6THQuUmVjdGFuZ2xlfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInRtcFBvaW50cyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOltdfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIndvcmtPcHRpb25zIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIm9sZFJlY3QiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywic3luY1RpbWVzdGFtcCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLHRoaXMud29ya09wdGlvbnM9ZS50b29sc09wdCx0aGlzLnN5bmNUaW1lc3RhbXA9MCx0aGlzLnN5bmNVbml0VGltZT01MH10cmFuc2Zvcm1EYXRhKCl7Y29uc3QgZT14ZSh0aGlzLnRtcFBvaW50cyk7cmV0dXJuW1tlLngsZS55LDBdLFtlLngrZS53LGUueSwwXSxbZS54K2UudyxlLnkrZS5oLDBdLFtlLngsZS55K2UuaCwwXV19Y29tcHV0RHJhd1BvaW50cyhlKXtjb25zdHt0aGlja25lc3M6dH09dGhpcy53b3JrT3B0aW9ucyxuPVtdO2Zvcihjb25zdCBoIG9mIGUpbi5wdXNoKG5ldyBFdCguLi5oKSk7Y29uc3QgaT14ZShuLHQpLGY9W2kueCtpLncvMixpLnkraS5oLzJdO3JldHVybntyZWN0OmkscG9zOmYscG9pbnRzOm4ubWFwKGg9PmguWFkpLmZsYXQoMSl9fWNvbnN1bWUoZSl7dmFyIGI7Y29uc3R7ZGF0YTp0LGlzRnVsbFdvcms6bixpc1N1YldvcmtlcjppfT1lLGY9KGI9dD09bnVsbD92b2lkIDA6dC53b3JrSWQpPT1udWxsP3ZvaWQgMDpiLnRvU3RyaW5nKCk7aWYoIWYpcmV0dXJue3R5cGU6VHQuTm9uZX07Y29uc3R7b3A6aCx3b3JrU3RhdGU6dX09dCxhPWg9PW51bGw/dm9pZCAwOmgubGVuZ3RoO2lmKCFhfHxhPDIpcmV0dXJue3R5cGU6VHQuTm9uZX07bGV0IGQ7aWYodT09PWNlLlN0YXJ0Pyh0aGlzLnRtcFBvaW50cz1bbmV3IEZ0KGhbMF0saFsxXSldLGQ9ITEpOmQ9dGhpcy51cGRhdGVUZW1wUG9pbnRzKGgpLCFkKXJldHVybnt0eXBlOlR0Lk5vbmV9O2NvbnN0IEU9dGhpcy50cmFuc2Zvcm1EYXRhKCk7aWYoIWkpe2NvbnN0IE09RGF0ZS5ub3coKTtyZXR1cm4gTS10aGlzLnN5bmNUaW1lc3RhbXA+dGhpcy5zeW5jVW5pdFRpbWU/KHRoaXMuc3luY1RpbWVzdGFtcD1NLHt0eXBlOlR0LkRyYXdXb3JrLGRhdGFUeXBlOnp0LkxvY2FsLHdvcmtJZDpmLG9wOkUuZmxhdCgxKSxpc1N5bmM6ITAsaW5kZXg6MH0pOnt0eXBlOlR0Lk5vbmV9fWNvbnN0IHA9bj90aGlzLmZ1bGxMYXllcjp0aGlzLmRyYXdMYXllcnx8dGhpcy5mdWxsTGF5ZXIsTz10aGlzLmRyYXcoe3BzOkUsd29ya0lkOmYsbGF5ZXI6cCxpc0RyYXdpbmc6ITB9KSxtPSR0KE8sdGhpcy5vbGRSZWN0KTtyZXR1cm4gdGhpcy5vbGRSZWN0PU8se3JlY3Q6bSx0eXBlOlR0LkRyYXdXb3JrLGRhdGFUeXBlOnp0LkxvY2FsLHdvcmtJZDpmfX1jb25zdW1lQWxsKGUpe3ZhciBkO2NvbnN0e2RhdGE6dH09ZSxuPShkPXQ9PW51bGw/dm9pZCAwOnQud29ya0lkKT09bnVsbD92b2lkIDA6ZC50b1N0cmluZygpO2lmKCFuKXJldHVybnt0eXBlOlR0Lk5vbmV9O2lmKHRoaXMudG1wUG9pbnRzLmxlbmd0aDwyKXJldHVybnt0eXBlOlR0LlJlbW92ZU5vZGUscmVtb3ZlSWRzOltuXX07Y29uc3QgaT10aGlzLnRyYW5zZm9ybURhdGEoKSxmPXRoaXMuZnVsbExheWVyLGg9dGhpcy5kcmF3KHtwczppLHdvcmtJZDpuLGxheWVyOmYsaXNEcmF3aW5nOiExfSk7dGhpcy5vbGRSZWN0PWg7Y29uc3QgdT1pLmZsYXQoMSksYT15cih1KTtyZXR1cm4gdGhpcy52Tm9kZXMuc2V0SW5mbyhuLHtyZWN0Omgsb3A6dSxvcHQ6dGhpcy53b3JrT3B0aW9ucyx0b29sc1R5cGU6dGhpcy50b29sc1R5cGUsc2NhbGVUeXBlOnRoaXMuc2NhbGVUeXBlLGNhblJvdGF0ZTp0aGlzLmNhblJvdGF0ZSxjZW50ZXJQb3M6aCYmRHQuZ2V0Q2VudGVyUG9zKGgsZil9KSx7cmVjdDpoLHR5cGU6VHQuRnVsbFdvcmssZGF0YVR5cGU6enQuTG9jYWwsd29ya0lkOm4sb3BzOmEsaXNTeW5jOiEwfX1kcmF3KGUpe3ZhciBMO2NvbnN0e3dvcmtJZDp0LGxheWVyOm4saXNEcmF3aW5nOmkscHM6ZixyZXBsYWNlSWQ6aH09ZTt0aGlzLmZ1bGxMYXllci5nZXRFbGVtZW50c0J5TmFtZShofHx0KS5tYXAoTj0+Ti5yZW1vdmUoKSksKEw9dGhpcy5kcmF3TGF5ZXIpPT1udWxsfHxMLmdldEVsZW1lbnRzQnlOYW1lKGh8fHQpLm1hcChOPT5OLnJlbW92ZSgpKTtjb25zdHtzdHJva2VDb2xvcjp1LGZpbGxDb2xvcjphLHRoaWNrbmVzczpkLHpJbmRleDpFLHNjYWxlOnAscm90YXRlOk8sdHJhbnNsYXRlOm0sdGV4dE9wdDpifT10aGlzLndvcmtPcHRpb25zLE09bi53b3JsZFBvc2l0aW9uLHk9bi53b3JsZFNjYWxpbmcse3BvaW50czpTLHJlY3Q6cyxwb3M6Y309dGhpcy5jb21wdXREcmF3UG9pbnRzKGYpLGw9e2Nsb3NlOiEwLG5vcm1hbGl6ZTohMCxwb2ludHM6UyxsaW5lV2lkdGg6ZCxmaWxsQ29sb3I6YSE9PSJ0cmFuc3BhcmVudCImJmF8fHZvaWQgMCxzdHJva2VDb2xvcjp1LGxpbmVKb2luOiJyb3VuZCJ9LHY9e3g6TWF0aC5mbG9vcihzLngqeVswXStNWzBdLUR0LlNhZmVCb3JkZXJQYWRkaW5nKSx5Ok1hdGguZmxvb3Iocy55KnlbMV0rTVsxXS1EdC5TYWZlQm9yZGVyUGFkZGluZyksdzpNYXRoLmZsb29yKHMudyp5WzBdKzIqRHQuU2FmZUJvcmRlclBhZGRpbmcpLGg6TWF0aC5mbG9vcihzLmgqeVswXSsyKkR0LlNhZmVCb3JkZXJQYWRkaW5nKX0sVD1uZXcgSXIoe25hbWU6dCxpZDp0LHpJbmRleDpFLHBvczpjLGFuY2hvcjpbLjUsLjVdLHNpemU6W3MudyxzLmhdLHNjYWxlOnAscm90YXRlOk8sdHJhbnNsYXRlOm19KSxSPW5ldyBjbih7Li4ubCxwb3M6WzAsMF19KTtpZihULmFwcGVuZENoaWxkKFIpLGkpe2NvbnN0IE49bmV3IEhyKHtkOiJNLTQsMEg0TTAsLTRWNCIsbm9ybWFsaXplOiEwLHBvczpbMCwwXSxzdHJva2VDb2xvcjp1LGxpbmVXaWR0aDoxLHNjYWxlOlsxL3lbMF0sMS95WzFdXX0pO1QuYXBwZW5kQ2hpbGQoTil9aWYobi5hcHBlbmQoVCkscHx8T3x8bSl7Y29uc3QgTj1ULmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO3JldHVybnt4Ok1hdGguZmxvb3IoTi54LUR0LlNhZmVCb3JkZXJQYWRkaW5nKSx5Ok1hdGguZmxvb3IoTi55LUR0LlNhZmVCb3JkZXJQYWRkaW5nKSx3Ok1hdGguZmxvb3IoTi53aWR0aCsyKkR0LlNhZmVCb3JkZXJQYWRkaW5nKSxoOk1hdGguZmxvb3IoTi5oZWlnaHQrMipEdC5TYWZlQm9yZGVyUGFkZGluZyl9fXJldHVybiB2fXVwZGF0ZVRlbXBQb2ludHMoZSl7Y29uc3QgdD1lLnNsaWNlKC0yKSxuPW5ldyBGdCh0WzBdLHRbMV0pLGk9dGhpcy50bXBQb2ludHNbMF0se3RoaWNrbmVzczpmfT10aGlzLndvcmtPcHRpb25zO2lmKGkuaXNOZWFyKG4sZikpcmV0dXJuITE7aWYodGhpcy50bXBQb2ludHMubGVuZ3RoPT09Mil7aWYobi5pc05lYXIodGhpcy50bXBQb2ludHNbMV0sMSkpcmV0dXJuITE7dGhpcy50bXBQb2ludHNbMV09bn1lbHNlIHRoaXMudG1wUG9pbnRzLnB1c2gobik7cmV0dXJuITB9Y29uc3VtZVNlcnZpY2UoZSl7dmFyIGQ7Y29uc3R7b3A6dCxpc0Z1bGxXb3JrOm4scmVwbGFjZUlkOml9PWUsZj0oZD10aGlzLndvcmtJZCk9PW51bGw/dm9pZCAwOmQudG9TdHJpbmcoKTtpZighZilyZXR1cm47Y29uc3QgaD1bXTtmb3IobGV0IEU9MDtFPHQubGVuZ3RoO0UrPTMpaC5wdXNoKFt0W0VdLHRbRSsxXSx0W0UrMl1dKTtjb25zdCB1PW4/dGhpcy5mdWxsTGF5ZXI6dGhpcy5kcmF3TGF5ZXJ8fHRoaXMuZnVsbExheWVyLGE9dGhpcy5kcmF3KHtwczpoLHdvcmtJZDpmLGxheWVyOnUsaXNEcmF3aW5nOiExLHJlcGxhY2VJZDppfSk7cmV0dXJuIHRoaXMub2xkUmVjdD1hLHRoaXMudk5vZGVzLnNldEluZm8oZix7cmVjdDphLG9wOnQsb3B0OnRoaXMud29ya09wdGlvbnMsdG9vbHNUeXBlOnRoaXMudG9vbHNUeXBlLHNjYWxlVHlwZTp0aGlzLnNjYWxlVHlwZSxjYW5Sb3RhdGU6dGhpcy5jYW5Sb3RhdGUsY2VudGVyUG9zOmEmJkR0LmdldENlbnRlclBvcyhhLHUpfSksYX1jbGVhclRtcFBvaW50cygpe3RoaXMudG1wUG9pbnRzLmxlbmd0aD0wfXN0YXRpYyB1cGRhdGVOb2RlT3B0KGUpe3ZhciBkLEU7Y29uc3R7bm9kZTp0LG9wdDpuLHZOb2RlczppfT1lLHtzdHJva2VDb2xvcjpmLGZpbGxDb2xvcjpofT1uLHU9aS5nZXQodC5uYW1lKTtsZXQgYT10O3JldHVybiB0LnRhZ05hbWU9PT0iR1JPVVAiJiYoYT10LmNoaWxkcmVuWzBdKSxmJiYoYS5zZXRBdHRyaWJ1dGUoInN0cm9rZUNvbG9yIixmKSwoZD11PT1udWxsP3ZvaWQgMDp1Lm9wdCkhPW51bGwmJmQuc3Ryb2tlQ29sb3ImJih1Lm9wdC5zdHJva2VDb2xvcj1mKSksaCYmKGg9PT0idHJhbnNwYXJlbnQiP2Euc2V0QXR0cmlidXRlKCJmaWxsQ29sb3IiLCJyZ2JhKDAsMCwwLDApIik6YS5zZXRBdHRyaWJ1dGUoImZpbGxDb2xvciIsaCksKEU9dT09bnVsbD92b2lkIDA6dS5vcHQpIT1udWxsJiZFLmZpbGxDb2xvciYmKHUub3B0LmZpbGxDb2xvcj1oKSksdSYmaS5zZXRJbmZvKHQubmFtZSx1KSxEdC51cGRhdGVOb2RlT3B0KGUpfX1jbGFzcyBLYSBleHRlbmRzIER0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJjYW5Sb3RhdGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTohMX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzY2FsZVR5cGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTokZS5hbGx9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidG9vbHNUeXBlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6THQuU3Rhcn0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ0bXBQb2ludHMiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpbXX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ3b3JrT3B0aW9ucyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJvbGRSZWN0Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInN5bmNUaW1lc3RhbXAiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSx0aGlzLndvcmtPcHRpb25zPWUudG9vbHNPcHQsdGhpcy5zeW5jVGltZXN0YW1wPTAsdGhpcy5zeW5jVW5pdFRpbWU9NTB9Y29uc3VtZShlKXt2YXIgbTtjb25zdHtkYXRhOnQsaXNGdWxsV29yazpuLGlzU3ViV29ya2VyOml9PWUsZj0obT10PT1udWxsP3ZvaWQgMDp0LndvcmtJZCk9PW51bGw/dm9pZCAwOm0udG9TdHJpbmcoKTtpZighZilyZXR1cm57dHlwZTpUdC5Ob25lfTtjb25zdHtvcDpoLHdvcmtTdGF0ZTp1fT10LGE9aD09bnVsbD92b2lkIDA6aC5sZW5ndGg7aWYoIWF8fGE8MilyZXR1cm57dHlwZTpUdC5Ob25lfTtsZXQgZDtpZih1PT09Y2UuU3RhcnQ/KHRoaXMudG1wUG9pbnRzPVtuZXcgRnQoaFswXSxoWzFdKV0sZD0hMSk6ZD10aGlzLnVwZGF0ZVRlbXBQb2ludHMoaCksIWQpcmV0dXJue3R5cGU6VHQuTm9uZX07aWYoIWkpe2NvbnN0IGI9RGF0ZS5ub3coKTtyZXR1cm4gYi10aGlzLnN5bmNUaW1lc3RhbXA+dGhpcy5zeW5jVW5pdFRpbWU/KHRoaXMuc3luY1RpbWVzdGFtcD1iLHt0eXBlOlR0LkRyYXdXb3JrLGRhdGFUeXBlOnp0LkxvY2FsLHdvcmtJZDpmLG9wOnRoaXMudG1wUG9pbnRzLm1hcChNPT5bLi4uTS5YWSwwXSkuZmxhdCgxKSxpc1N5bmM6ITAsaW5kZXg6MH0pOnt0eXBlOlR0Lk5vbmV9fWNvbnN0IEU9bj90aGlzLmZ1bGxMYXllcjp0aGlzLmRyYXdMYXllcnx8dGhpcy5mdWxsTGF5ZXIscD10aGlzLmRyYXcoe3dvcmtJZDpmLGxheWVyOkUsaXNEcmF3aW5nOiEwfSksTz0kdChwLHRoaXMub2xkUmVjdCk7cmV0dXJuIHRoaXMub2xkUmVjdD1wLHtyZWN0Ok8sdHlwZTpUdC5EcmF3V29yayxkYXRhVHlwZTp6dC5Mb2NhbCx3b3JrSWQ6Zn19Y29uc3VtZUFsbChlKXt2YXIgYTtjb25zdHtkYXRhOnR9PWUsbj0oYT10PT1udWxsP3ZvaWQgMDp0LndvcmtJZCk9PW51bGw/dm9pZCAwOmEudG9TdHJpbmcoKTtpZighbilyZXR1cm57dHlwZTpUdC5Ob25lfTtpZih0aGlzLnRtcFBvaW50cy5sZW5ndGg8MilyZXR1cm57dHlwZTpUdC5SZW1vdmVOb2RlLHJlbW92ZUlkczpbbl19O2NvbnN0IGk9dGhpcy5mdWxsTGF5ZXIsZj10aGlzLmRyYXcoe3dvcmtJZDpuLGxheWVyOmksaXNEcmF3aW5nOiExfSk7dGhpcy5vbGRSZWN0PWY7Y29uc3QgaD10aGlzLnRtcFBvaW50cy5tYXAoZD0+Wy4uLmQuWFksMF0pLmZsYXQoMSksdT15cihoKTtyZXR1cm4gdGhpcy52Tm9kZXMuc2V0SW5mbyhuLHtyZWN0OmYsb3A6aCxvcHQ6dGhpcy53b3JrT3B0aW9ucyx0b29sc1R5cGU6dGhpcy50b29sc1R5cGUsc2NhbGVUeXBlOnRoaXMuc2NhbGVUeXBlLGNhblJvdGF0ZTp0aGlzLmNhblJvdGF0ZSxjZW50ZXJQb3M6ZiYmRHQuZ2V0Q2VudGVyUG9zKGYsaSl9KSx7cmVjdDpmLHR5cGU6VHQuRnVsbFdvcmssZGF0YVR5cGU6enQuTG9jYWwsd29ya0lkOm4sb3BzOnUsaXNTeW5jOiEwfX1kcmF3KGUpe3ZhciBSO2NvbnN0e3dvcmtJZDp0LGxheWVyOm4saXNEcmF3aW5nOml9PWU7dGhpcy5mdWxsTGF5ZXIuZ2V0RWxlbWVudHNCeU5hbWUodCkubWFwKEw9PkwucmVtb3ZlKCkpLChSPXRoaXMuZHJhd0xheWVyKT09bnVsbHx8Ui5nZXRFbGVtZW50c0J5TmFtZSh0KS5tYXAoTD0+TC5yZW1vdmUoKSk7Y29uc3R7c3Ryb2tlQ29sb3I6ZixmaWxsQ29sb3I6aCx0aGlja25lc3M6dSx6SW5kZXg6YSx2ZXJ0aWNlczpkLGlubmVyVmVydGljZVN0ZXA6RSxpbm5lclJhdGlvOnAsc2NhbGU6Tyxyb3RhdGU6bSx0cmFuc2xhdGU6Yn09dGhpcy53b3JrT3B0aW9ucyxNPW4ud29ybGRQb3NpdGlvbix5PW4ud29ybGRTY2FsaW5nLHtyZWN0OlMscG9zOnMscG9pbnRzOmN9PXRoaXMuY29tcHV0RHJhd1BvaW50cyh1LGQsRSxwKSxsPXtwb3M6cyxjbG9zZTohMCxuYW1lOnQsaWQ6dCxwb2ludHM6YyxsaW5lV2lkdGg6dSxmaWxsQ29sb3I6aCE9PSJ0cmFuc3BhcmVudCImJmh8fHZvaWQgMCxzdHJva2VDb2xvcjpmLGNsYXNzTmFtZTpgJHtzWzBdfSwke3NbMV19YCxub3JtYWxpemU6ITAsekluZGV4OmEsbGluZUpvaW46InJvdW5kIn0sdj17eDpNYXRoLmZsb29yKFMueCp5WzBdK01bMF0tRHQuU2FmZUJvcmRlclBhZGRpbmcqeVswXSkseTpNYXRoLmZsb29yKFMueSp5WzFdK01bMV0tRHQuU2FmZUJvcmRlclBhZGRpbmcqeVsxXSksdzpNYXRoLmZsb29yKFMudyp5WzBdKzIqRHQuU2FmZUJvcmRlclBhZGRpbmcqeVswXSksaDpNYXRoLmZsb29yKFMuaCp5WzFdKzIqRHQuU2FmZUJvcmRlclBhZGRpbmcqeVsxXSl9O2lmKGkpe2NvbnN0e25hbWU6TCxpZDpOLHpJbmRleDpBLHN0cm9rZUNvbG9yOnd9PWwsQj1bKHYueCt2LncvMi1NWzBdKS95WzBdLCh2Lnkrdi5oLzItTVsxXSkveVsxXV0sRD1uZXcgSXIoe25hbWU6TCxpZDpOLHpJbmRleDpBLHBvczpCLGFuY2hvcjpbLjUsLjVdLHNpemU6W3Yudyx2LmhdfSksST1uZXcgY24oey4uLmwscG9zOlswLDBdfSksaj1uZXcgSHIoe2Q6Ik0tNCwwSDRNMCwtNFY0Iixub3JtYWxpemU6ITAscG9zOlswLDBdLHN0cm9rZUNvbG9yOncsbGluZVdpZHRoOjEsc2NhbGU6WzEveVswXSwxL3lbMV1dfSk7cmV0dXJuIEQuYXBwZW5kKEksaiksbi5hcHBlbmQoRCksdn1PJiYobC5zY2FsZT1PKSxtJiYobC5yb3RhdGU9bSksYiYmKGwudHJhbnNsYXRlPWIpO2NvbnN0IFQ9bmV3IGNuKGwpO2lmKG4uYXBwZW5kKFQpLE98fG18fGIpe2NvbnN0IEw9VC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtyZXR1cm57eDpNYXRoLmZsb29yKEwueC1EdC5TYWZlQm9yZGVyUGFkZGluZykseTpNYXRoLmZsb29yKEwueS1EdC5TYWZlQm9yZGVyUGFkZGluZyksdzpNYXRoLmZsb29yKEwud2lkdGgrRHQuU2FmZUJvcmRlclBhZGRpbmcqMiksaDpNYXRoLmZsb29yKEwuaGVpZ2h0K0R0LlNhZmVCb3JkZXJQYWRkaW5nKjIpfX1yZXR1cm4gdn1jb21wdXREcmF3UG9pbnRzKGUsdCxuLGkpe2NvbnN0IGY9eGUodGhpcy50bXBQb2ludHMpLGg9W01hdGguZmxvb3IoZi54K2Yudy8yKSxNYXRoLmZsb29yKGYueStmLmgvMildLHU9RGEoZi53LGYuaCksYT1NYXRoLmZsb29yKE1hdGgubWluKGYudyxmLmgpLzIpLGQ9aSphLEU9W10scD0yKk1hdGguUEkvdDtmb3IobGV0IG09MDttPHQ7bSsrKXtjb25zdCBiPW0qcC0uNSpNYXRoLlBJO2xldCBNLHk7bSVuPT09MT8oTT1kKnVbMF0qTWF0aC5jb3MoYikseT1kKnVbMV0qTWF0aC5zaW4oYikpOihNPWEqdVswXSpNYXRoLmNvcyhiKSx5PWEqdVsxXSpNYXRoLnNpbihiKSxFLnB1c2goTSx5KSksRS5wdXNoKE0seSl9cmV0dXJue3JlY3Q6eGUodGhpcy50bXBQb2ludHMsZSkscG9zOmgscG9pbnRzOkV9fXVwZGF0ZVRlbXBQb2ludHMoZSl7Y29uc3QgdD1lLnNsaWNlKC0yKSxuPW5ldyBGdCh0WzBdLHRbMV0pLGk9dGhpcy50bXBQb2ludHNbMF0se3RoaWNrbmVzczpmfT10aGlzLndvcmtPcHRpb25zO2lmKGkuaXNOZWFyKG4sZil8fEZ0LlN1YihpLG4pLlhZLmluY2x1ZGVzKDApKXJldHVybiExO2lmKHRoaXMudG1wUG9pbnRzLmxlbmd0aD09PTIpe2lmKG4uaXNOZWFyKHRoaXMudG1wUG9pbnRzWzFdLDEpKXJldHVybiExO3RoaXMudG1wUG9pbnRzWzFdPW59ZWxzZSB0aGlzLnRtcFBvaW50cy5wdXNoKG4pO3JldHVybiEwfWNvbnN1bWVTZXJ2aWNlKGUpe3ZhciB1O2NvbnN0e29wOnQsaXNGdWxsV29yazpufT1lLGk9KHU9dGhpcy53b3JrSWQpPT1udWxsP3ZvaWQgMDp1LnRvU3RyaW5nKCk7aWYoIWkpcmV0dXJuO3RoaXMudG1wUG9pbnRzLmxlbmd0aD0wO2ZvcihsZXQgYT0wO2E8dC5sZW5ndGg7YSs9Myl0aGlzLnRtcFBvaW50cy5wdXNoKG5ldyBGdCh0W2FdLHRbYSsxXSx0W2ErMl0pKTtjb25zdCBmPW4/dGhpcy5mdWxsTGF5ZXI6dGhpcy5kcmF3TGF5ZXJ8fHRoaXMuZnVsbExheWVyLGg9dGhpcy5kcmF3KHt3b3JrSWQ6aSxsYXllcjpmLGlzRHJhd2luZzohMX0pO3JldHVybiB0aGlzLm9sZFJlY3Q9aCx0aGlzLnZOb2Rlcy5zZXRJbmZvKGkse3JlY3Q6aCxvcDp0LG9wdDp0aGlzLndvcmtPcHRpb25zLHRvb2xzVHlwZTp0aGlzLnRvb2xzVHlwZSxzY2FsZVR5cGU6dGhpcy5zY2FsZVR5cGUsY2FuUm90YXRlOnRoaXMuY2FuUm90YXRlLGNlbnRlclBvczpoJiZEdC5nZXRDZW50ZXJQb3MoaCxmKX0pLGh9Y2xlYXJUbXBQb2ludHMoKXt0aGlzLnRtcFBvaW50cy5sZW5ndGg9MH1zdGF0aWMgdXBkYXRlTm9kZU9wdChlKXt2YXIgZCxFO2NvbnN0e25vZGU6dCxvcHQ6bix2Tm9kZXM6aX09ZSx7c3Ryb2tlQ29sb3I6ZixmaWxsQ29sb3I6aH09bix1PWkuZ2V0KHQubmFtZSk7bGV0IGE9dDtyZXR1cm4gdC50YWdOYW1lPT09IkdST1VQIiYmKGE9dC5jaGlsZHJlblswXSksZiYmKGEuc2V0QXR0cmlidXRlKCJzdHJva2VDb2xvciIsZiksKGQ9dT09bnVsbD92b2lkIDA6dS5vcHQpIT1udWxsJiZkLnN0cm9rZUNvbG9yJiYodS5vcHQuc3Ryb2tlQ29sb3I9ZikpLGgmJihoPT09InRyYW5zcGFyZW50Ij9hLnNldEF0dHJpYnV0ZSgiZmlsbENvbG9yIiwicmdiYSgwLDAsMCwwKSIpOmEuc2V0QXR0cmlidXRlKCJmaWxsQ29sb3IiLGgpLChFPXU9PW51bGw/dm9pZCAwOnUub3B0KSE9bnVsbCYmRS5maWxsQ29sb3ImJih1Lm9wdC5maWxsQ29sb3I9aCkpLHUmJmkuc2V0SW5mbyh0Lm5hbWUsdSksRHQudXBkYXRlTm9kZU9wdChlKX19Y2xhc3MgSGEgZXh0ZW5kcyBEdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihlKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiY2FuUm90YXRlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6ITF9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywic2NhbGVUeXBlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6JGUuYWxsfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInRvb2xzVHlwZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOkx0LlBvbHlnb259KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidG1wUG9pbnRzIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6W119KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywid29ya09wdGlvbnMiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywib2xkUmVjdCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzeW5jVGltZXN0YW1wIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksdGhpcy53b3JrT3B0aW9ucz1lLnRvb2xzT3B0LHRoaXMuc3luY1RpbWVzdGFtcD0wLHRoaXMuc3luY1VuaXRUaW1lPTUwfWNvbnN1bWUoZSl7dmFyIG07Y29uc3R7ZGF0YTp0LGlzRnVsbFdvcms6bixpc1N1YldvcmtlcjppfT1lLGY9KG09dD09bnVsbD92b2lkIDA6dC53b3JrSWQpPT1udWxsP3ZvaWQgMDptLnRvU3RyaW5nKCk7aWYoIWYpcmV0dXJue3R5cGU6VHQuTm9uZX07Y29uc3R7b3A6aCx3b3JrU3RhdGU6dX09dCxhPWg9PW51bGw/dm9pZCAwOmgubGVuZ3RoO2lmKCFhfHxhPDIpcmV0dXJue3R5cGU6VHQuTm9uZX07bGV0IGQ7aWYodT09PWNlLlN0YXJ0Pyh0aGlzLnRtcFBvaW50cz1bbmV3IEZ0KGhbMF0saFsxXSldLGQ9ITEpOmQ9dGhpcy51cGRhdGVUZW1wUG9pbnRzKGgpLCFkKXJldHVybnt0eXBlOlR0Lk5vbmV9O2lmKCFpKXtjb25zdCBiPURhdGUubm93KCk7cmV0dXJuIGItdGhpcy5zeW5jVGltZXN0YW1wPnRoaXMuc3luY1VuaXRUaW1lPyh0aGlzLnN5bmNUaW1lc3RhbXA9Yix7dHlwZTpUdC5EcmF3V29yayxkYXRhVHlwZTp6dC5Mb2NhbCx3b3JrSWQ6ZixvcDp0aGlzLnRtcFBvaW50cy5tYXAoTT0+Wy4uLk0uWFksMF0pLmZsYXQoMSksaXNTeW5jOiEwLGluZGV4OjB9KTp7dHlwZTpUdC5Ob25lfX1jb25zdCBFPW4/dGhpcy5mdWxsTGF5ZXI6dGhpcy5kcmF3TGF5ZXJ8fHRoaXMuZnVsbExheWVyLHA9dGhpcy5kcmF3KHt3b3JrSWQ6ZixsYXllcjpFLGlzRHJhd2luZzohMH0pLE89JHQocCx0aGlzLm9sZFJlY3QpO3JldHVybiB0aGlzLm9sZFJlY3Q9cCx7cmVjdDpPLHR5cGU6VHQuRHJhd1dvcmssZGF0YVR5cGU6enQuTG9jYWwsd29ya0lkOmZ9fWNvbnN1bWVBbGwoZSl7dmFyIGE7Y29uc3R7ZGF0YTp0fT1lLG49KGE9dD09bnVsbD92b2lkIDA6dC53b3JrSWQpPT1udWxsP3ZvaWQgMDphLnRvU3RyaW5nKCk7aWYoIW4pcmV0dXJue3R5cGU6VHQuTm9uZX07aWYodGhpcy50bXBQb2ludHMubGVuZ3RoPDIpcmV0dXJue3R5cGU6VHQuUmVtb3ZlTm9kZSxyZW1vdmVJZHM6W25dfTtjb25zdCBpPXRoaXMuZnVsbExheWVyLGY9dGhpcy5kcmF3KHt3b3JrSWQ6bixsYXllcjppLGlzRHJhd2luZzohMX0pO3RoaXMub2xkUmVjdD1mO2NvbnN0IGg9dGhpcy50bXBQb2ludHMubWFwKGQ9PlsuLi5kLlhZLDBdKS5mbGF0KDEpLHU9eXIoaCk7cmV0dXJuIHRoaXMudk5vZGVzLnNldEluZm8obix7cmVjdDpmLG9wOmgsb3B0OnRoaXMud29ya09wdGlvbnMsdG9vbHNUeXBlOnRoaXMudG9vbHNUeXBlLHNjYWxlVHlwZTp0aGlzLnNjYWxlVHlwZSxjYW5Sb3RhdGU6dGhpcy5jYW5Sb3RhdGUsY2VudGVyUG9zOmYmJkR0LmdldENlbnRlclBvcyhmLGkpfSkse3JlY3Q6Zix0eXBlOlR0LkZ1bGxXb3JrLGRhdGFUeXBlOnp0LkxvY2FsLHdvcmtJZDpuLG9wczp1LGlzU3luYzohMH19ZHJhdyhlKXt2YXIgdjtjb25zdHt3b3JrSWQ6dCxsYXllcjpuLGlzRHJhd2luZzppfT1lO3RoaXMuZnVsbExheWVyLmdldEVsZW1lbnRzQnlOYW1lKHQpLm1hcChUPT5ULnJlbW92ZSgpKSwodj10aGlzLmRyYXdMYXllcik9PW51bGx8fHYuZ2V0RWxlbWVudHNCeU5hbWUodCkubWFwKFQ9PlQucmVtb3ZlKCkpO2NvbnN0e3N0cm9rZUNvbG9yOmYsZmlsbENvbG9yOmgsdGhpY2tuZXNzOnUsekluZGV4OmEsdmVydGljZXM6ZCxzY2FsZTpFLHJvdGF0ZTpwLHRyYW5zbGF0ZTpPfT10aGlzLndvcmtPcHRpb25zLG09bi53b3JsZFBvc2l0aW9uLGI9bi53b3JsZFNjYWxpbmcse3JlY3Q6TSxwb3M6eSxwb2ludHM6U309dGhpcy5jb21wdXREcmF3UG9pbnRzKHUsZCkscz17cG9zOnksY2xvc2U6ITAsbmFtZTp0LGlkOnQscG9pbnRzOlMsbGluZVdpZHRoOnUsZmlsbENvbG9yOmghPT0idHJhbnNwYXJlbnQiJiZofHx2b2lkIDAsc3Ryb2tlQ29sb3I6Zixub3JtYWxpemU6ITAsekluZGV4OmEsbGluZUpvaW46InJvdW5kIn0sYz17eDpNYXRoLmZsb29yKE0ueCpiWzBdK21bMF0tRHQuU2FmZUJvcmRlclBhZGRpbmcqYlswXSkseTpNYXRoLmZsb29yKE0ueSpiWzFdK21bMV0tRHQuU2FmZUJvcmRlclBhZGRpbmcqYlsxXSksdzpNYXRoLmZsb29yKE0udypiWzBdKzIqRHQuU2FmZUJvcmRlclBhZGRpbmcqYlswXSksaDpNYXRoLmZsb29yKE0uaCpiWzFdKzIqRHQuU2FmZUJvcmRlclBhZGRpbmcqYlsxXSl9O2lmKGkpe2NvbnN0e25hbWU6VCxpZDpSLHpJbmRleDpMLHN0cm9rZUNvbG9yOk59PXMsQT1bKGMueCtjLncvMi1tWzBdKS9iWzBdLChjLnkrYy5oLzItbVsxXSkvYlsxXV0sdz1uZXcgSXIoe25hbWU6VCxpZDpSLHpJbmRleDpMLHBvczpBLGFuY2hvcjpbLjUsLjVdLHNpemU6W2MudyxjLmhdfSksQj1uZXcgY24oey4uLnMscG9zOlswLDBdfSksRD1uZXcgSHIoe2Q6Ik0tNCwwSDRNMCwtNFY0Iixub3JtYWxpemU6ITAscG9zOlswLDBdLHN0cm9rZUNvbG9yOk4sbGluZVdpZHRoOjEsc2NhbGU6WzEvYlswXSwxL2JbMV1dfSk7cmV0dXJuIHcuYXBwZW5kKEIsRCksbi5hcHBlbmQodyksY31FJiYocy5zY2FsZT1FKSxwJiYocy5yb3RhdGU9cCksTyYmKHMudHJhbnNsYXRlPU8pO2NvbnN0IGw9bmV3IGNuKHMpO2lmKG4uYXBwZW5kKGwpLEV8fHB8fE8pe2NvbnN0IFQ9bC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtyZXR1cm57eDpNYXRoLmZsb29yKFQueC1EdC5TYWZlQm9yZGVyUGFkZGluZykseTpNYXRoLmZsb29yKFQueS1EdC5TYWZlQm9yZGVyUGFkZGluZyksdzpNYXRoLmZsb29yKFQud2lkdGgrRHQuU2FmZUJvcmRlclBhZGRpbmcqMiksaDpNYXRoLmZsb29yKFQuaGVpZ2h0K0R0LlNhZmVCb3JkZXJQYWRkaW5nKjIpfX1yZXR1cm4gY31jb21wdXREcmF3UG9pbnRzKGUsdCl7Y29uc3Qgbj14ZSh0aGlzLnRtcFBvaW50cyksaT1bTWF0aC5mbG9vcihuLngrbi53LzIpLE1hdGguZmxvb3Iobi55K24uaC8yKV0sZj1EYShuLncsbi5oKSxoPU1hdGguZmxvb3IoTWF0aC5taW4obi53LG4uaCkvMiksdT1bXSxhPTIqTWF0aC5QSS90O2ZvcihsZXQgRT0wO0U8dDtFKyspe2NvbnN0IHA9RSphLS41Kk1hdGguUEksTz1oKmZbMF0qTWF0aC5jb3MocCksbT1oKmZbMV0qTWF0aC5zaW4ocCk7dS5wdXNoKE8sbSl9cmV0dXJue3JlY3Q6eGUodGhpcy50bXBQb2ludHMsZSkscG9zOmkscG9pbnRzOnV9fXVwZGF0ZVRlbXBQb2ludHMoZSl7Y29uc3QgdD1lLnNsaWNlKC0yKSxuPW5ldyBGdCh0WzBdLHRbMV0pLGk9dGhpcy50bXBQb2ludHNbMF0se3RoaWNrbmVzczpmfT10aGlzLndvcmtPcHRpb25zO2lmKGkuaXNOZWFyKG4sZil8fEZ0LlN1YihpLG4pLlhZLmluY2x1ZGVzKDApKXJldHVybiExO2lmKHRoaXMudG1wUG9pbnRzLmxlbmd0aD09PTIpe2lmKG4uaXNOZWFyKHRoaXMudG1wUG9pbnRzWzFdLDEpKXJldHVybiExO3RoaXMudG1wUG9pbnRzWzFdPW59ZWxzZSB0aGlzLnRtcFBvaW50cy5wdXNoKG4pO3JldHVybiEwfWNvbnN1bWVTZXJ2aWNlKGUpe3ZhciB1O2NvbnN0e29wOnQsaXNGdWxsV29yazpufT1lLGk9KHU9dGhpcy53b3JrSWQpPT1udWxsP3ZvaWQgMDp1LnRvU3RyaW5nKCk7aWYoIWkpcmV0dXJuO3RoaXMudG1wUG9pbnRzLmxlbmd0aD0wO2ZvcihsZXQgYT0wO2E8dC5sZW5ndGg7YSs9Myl0aGlzLnRtcFBvaW50cy5wdXNoKG5ldyBGdCh0W2FdLHRbYSsxXSx0W2ErMl0pKTtjb25zdCBmPW4/dGhpcy5mdWxsTGF5ZXI6dGhpcy5kcmF3TGF5ZXJ8fHRoaXMuZnVsbExheWVyLGg9dGhpcy5kcmF3KHt3b3JrSWQ6aSxsYXllcjpmLGlzRHJhd2luZzohMX0pO3JldHVybiB0aGlzLm9sZFJlY3Q9aCx0aGlzLnZOb2Rlcy5zZXRJbmZvKGkse3JlY3Q6aCxvcDp0LG9wdDp0aGlzLndvcmtPcHRpb25zLHRvb2xzVHlwZTp0aGlzLnRvb2xzVHlwZSxzY2FsZVR5cGU6dGhpcy5zY2FsZVR5cGUsY2FuUm90YXRlOnRoaXMuY2FuUm90YXRlLGNlbnRlclBvczpoJiZEdC5nZXRDZW50ZXJQb3MoaCxmKX0pLGh9Y2xlYXJUbXBQb2ludHMoKXt0aGlzLnRtcFBvaW50cy5sZW5ndGg9MH1zdGF0aWMgdXBkYXRlTm9kZU9wdChlKXt2YXIgZCxFO2NvbnN0e25vZGU6dCxvcHQ6bix2Tm9kZXM6aX09ZSx7c3Ryb2tlQ29sb3I6ZixmaWxsQ29sb3I6aH09bix1PWkuZ2V0KHQubmFtZSk7bGV0IGE9dDtyZXR1cm4gdC50YWdOYW1lPT09IkdST1VQIiYmKGE9dC5jaGlsZHJlblswXSksZiYmKGEuc2V0QXR0cmlidXRlKCJzdHJva2VDb2xvciIsZiksKGQ9dT09bnVsbD92b2lkIDA6dS5vcHQpIT1udWxsJiZkLnN0cm9rZUNvbG9yJiYodS5vcHQuc3Ryb2tlQ29sb3I9ZikpLGgmJihoPT09InRyYW5zcGFyZW50Ij9hLnNldEF0dHJpYnV0ZSgiZmlsbENvbG9yIiwicmdiYSgwLDAsMCwwKSIpOmEuc2V0QXR0cmlidXRlKCJmaWxsQ29sb3IiLGgpLChFPXU9PW51bGw/dm9pZCAwOnUub3B0KSE9bnVsbCYmRS5maWxsQ29sb3ImJih1Lm9wdC5maWxsQ29sb3I9aCkpLHUmJmkuc2V0SW5mbyh0Lm5hbWUsdSksRHQudXBkYXRlTm9kZU9wdChlKX19Y2xhc3MgWWEgZXh0ZW5kcyBEdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihlKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiY2FuUm90YXRlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6ITF9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywic2NhbGVUeXBlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6JGUuYWxsfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInRvb2xzVHlwZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOkx0LlN0cmFpZ2h0fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInRtcFBvaW50cyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOltdfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIndvcmtPcHRpb25zIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIm9sZFJlY3QiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywic3RyYWlnaHRUaXBXaWR0aCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzeW5jVGltZXN0YW1wIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksdGhpcy53b3JrT3B0aW9ucz1lLnRvb2xzT3B0LHRoaXMuc3RyYWlnaHRUaXBXaWR0aD10aGlzLndvcmtPcHRpb25zLnRoaWNrbmVzcy8yLHRoaXMuc3luY1RpbWVzdGFtcD0wLHRoaXMuc3luY1VuaXRUaW1lPTUwfWNvbnN1bWUoZSl7dmFyIG07Y29uc3R7ZGF0YTp0LGlzRnVsbFdvcms6bixpc1N1YldvcmtlcjppfT1lLGY9KG09dD09bnVsbD92b2lkIDA6dC53b3JrSWQpPT1udWxsP3ZvaWQgMDptLnRvU3RyaW5nKCk7aWYoIWYpcmV0dXJue3R5cGU6VHQuTm9uZX07Y29uc3R7b3A6aCx3b3JrU3RhdGU6dX09dCxhPWg9PW51bGw/dm9pZCAwOmgubGVuZ3RoO2lmKCFhfHxhPDIpcmV0dXJue3R5cGU6VHQuTm9uZX07bGV0IGQ7aWYodT09PWNlLlN0YXJ0Pyh0aGlzLnRtcFBvaW50cz1bbmV3IEZ0KGhbMF0saFsxXSldLGQ9ITEpOmQ9dGhpcy51cGRhdGVUZW1wUG9pbnRzKGgpLCFkKXJldHVybnt0eXBlOlR0Lk5vbmV9O2lmKCFpKXtjb25zdCBiPURhdGUubm93KCk7cmV0dXJuIGItdGhpcy5zeW5jVGltZXN0YW1wPnRoaXMuc3luY1VuaXRUaW1lPyh0aGlzLnN5bmNUaW1lc3RhbXA9Yix7dHlwZTpUdC5EcmF3V29yayxkYXRhVHlwZTp6dC5Mb2NhbCx3b3JrSWQ6ZixvcDp0aGlzLnRtcFBvaW50cy5tYXAoTT0+Wy4uLk0uWFksMF0pLmZsYXQoMSksaXNTeW5jOiEwLGluZGV4OjB9KTp7dHlwZTpUdC5Ob25lfX1jb25zdCBFPW4/dGhpcy5mdWxsTGF5ZXI6dGhpcy5kcmF3TGF5ZXJ8fHRoaXMuZnVsbExheWVyLHA9dGhpcy5kcmF3KHt3b3JrSWQ6ZixsYXllcjpFfSksTz0kdChwLHRoaXMub2xkUmVjdCk7cmV0dXJuIHRoaXMub2xkUmVjdD1wLHtyZWN0Ok8sdHlwZTpUdC5EcmF3V29yayxkYXRhVHlwZTp6dC5Mb2NhbCx3b3JrSWQ6Zn19Y29uc3VtZUFsbChlKXt2YXIgYTtjb25zdHtkYXRhOnR9PWUsbj0oYT10PT1udWxsP3ZvaWQgMDp0LndvcmtJZCk9PW51bGw/dm9pZCAwOmEudG9TdHJpbmcoKTtpZighbilyZXR1cm57dHlwZTpUdC5Ob25lfTtpZih0aGlzLnRtcFBvaW50cy5sZW5ndGg8MilyZXR1cm57dHlwZTpUdC5SZW1vdmVOb2RlLHJlbW92ZUlkczpbbl19O2NvbnN0IGk9dGhpcy5mdWxsTGF5ZXIsZj10aGlzLmRyYXcoe3dvcmtJZDpuLGxheWVyOml9KTt0aGlzLm9sZFJlY3Q9Zjtjb25zdCBoPXRoaXMudG1wUG9pbnRzLm1hcChkPT5bLi4uZC5YWSwwXSkuZmxhdCgxKSx1PXlyKGgpO3JldHVybiBlLnZOb2Rlcy5zZXRJbmZvKG4se3JlY3Q6ZixvcDpoLG9wdDp0aGlzLndvcmtPcHRpb25zLHRvb2xzVHlwZTp0aGlzLnRvb2xzVHlwZSxzY2FsZVR5cGU6dGhpcy5zY2FsZVR5cGUsY2FuUm90YXRlOnRoaXMuY2FuUm90YXRlLGNlbnRlclBvczpmJiZEdC5nZXRDZW50ZXJQb3MoZixpKX0pLHtyZWN0OmYsdHlwZTpUdC5GdWxsV29yayxkYXRhVHlwZTp6dC5Mb2NhbCx3b3JrSWQ6bixvcHM6dSxpc1N5bmM6ITB9fWRyYXcoZSl7dmFyIHM7Y29uc3R7d29ya0lkOnQsbGF5ZXI6bn09ZTt0aGlzLmZ1bGxMYXllci5nZXRFbGVtZW50c0J5TmFtZSh0KS5tYXAoYz0+Yy5yZW1vdmUoKSksKHM9dGhpcy5kcmF3TGF5ZXIpPT1udWxsfHxzLmdldEVsZW1lbnRzQnlOYW1lKHQpLm1hcChjPT5jLnJlbW92ZSgpKTtjb25zdHtzdHJva2VDb2xvcjppLHRoaWNrbmVzczpmLHpJbmRleDpoLHNjYWxlOnUscm90YXRlOmEsdHJhbnNsYXRlOmR9PXRoaXMud29ya09wdGlvbnMsRT1uLndvcmxkUG9zaXRpb24scD1uLndvcmxkU2NhbGluZyx7ZDpPLHJlY3Q6bX09dGhpcy5jb21wdXREcmF3UG9pbnRzKGYpLGI9W20ueCttLncvMixtLnkrbS5oLzJdLE09e3BvczpiLG5hbWU6dCxpZDp0LGQ6TyxmaWxsQ29sb3I6aSxzdHJva2VDb2xvcjppLGxpbmVXaWR0aDowLGNsYXNzTmFtZTpgJHtiWzBdfSwke2JbMV19YCxub3JtYWxpemU6ITAsekluZGV4Omh9O3UmJihNLnNjYWxlPXUpLGEmJihNLnJvdGF0ZT1hKSxkJiYoTS50cmFuc2xhdGU9ZCk7Y29uc3QgeT1uZXcgSHIoTSk7aWYobi5hcHBlbmQoeSksYXx8dXx8ZCl7Y29uc3QgYz15LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO3JldHVybnt4Ok1hdGguZmxvb3IoYy54LUR0LlNhZmVCb3JkZXJQYWRkaW5nKSx5Ok1hdGguZmxvb3IoYy55LUR0LlNhZmVCb3JkZXJQYWRkaW5nKSx3Ok1hdGguZmxvb3IoYy53aWR0aCtEdC5TYWZlQm9yZGVyUGFkZGluZyoyKSxoOk1hdGguZmxvb3IoYy5oZWlnaHQrRHQuU2FmZUJvcmRlclBhZGRpbmcqMil9fXJldHVybnt4Ok1hdGguZmxvb3IobS54KnBbMF0rRVswXS1EdC5TYWZlQm9yZGVyUGFkZGluZykseTpNYXRoLmZsb29yKG0ueSpwWzFdK0VbMV0tRHQuU2FmZUJvcmRlclBhZGRpbmcpLHc6TWF0aC5mbG9vcihtLncqcFswXSsyKkR0LlNhZmVCb3JkZXJQYWRkaW5nKSxoOk1hdGguZmxvb3IobS5oKnBbMV0rMipEdC5TYWZlQm9yZGVyUGFkZGluZyl9fWNvbXB1dERyYXdQb2ludHMoZSl7cmV0dXJuIHRoaXMudG1wUG9pbnRzWzFdLmRpc3RhbmNlKHRoaXMudG1wUG9pbnRzWzBdKT50aGlzLnN0cmFpZ2h0VGlwV2lkdGg/dGhpcy5jb21wdXRGdWxsUG9pbnRzKGUpOnRoaXMuY29tcHV0RG90UG9pbnRzKGUpfWNvbXB1dEZ1bGxQb2ludHMoZSl7Y29uc3QgdD1FdC5TdWIodGhpcy50bXBQb2ludHNbMV0sdGhpcy50bXBQb2ludHNbMF0pLnVuaSgpLG49RXQuUGVyKHQpLm11bChlLzIpLGk9RnQuU3ViKHRoaXMudG1wUG9pbnRzWzBdLG4pLGY9RnQuQWRkKHRoaXMudG1wUG9pbnRzWzBdLG4pLGg9RnQuU3ViKHRoaXMudG1wUG9pbnRzWzFdLG4pLHU9RnQuQWRkKHRoaXMudG1wUG9pbnRzWzFdLG4pLGE9RnQuR2V0U2VtaWNpcmNsZVN0cm9rZSh0aGlzLnRtcFBvaW50c1sxXSxoLC0xLDgpLGQ9RnQuR2V0U2VtaWNpcmNsZVN0cm9rZSh0aGlzLnRtcFBvaW50c1swXSxmLC0xLDgpLEU9W2ksaCwuLi5hLHUsZiwuLi5kXTtyZXR1cm57ZDpobihFLCEwKSxyZWN0OnhlKEUpLGlzRG90OiExLHBvczp0aGlzLnRtcFBvaW50c1swXS5YWX19Y29tcHV0RG90UG9pbnRzKGUpe2NvbnN0IHQ9RnQuR2V0RG90U3Ryb2tlKHRoaXMudG1wUG9pbnRzWzBdLGUvMiw4KTtyZXR1cm57ZDpobih0LCEwKSxyZWN0OnhlKHQpLGlzRG90OiEwLHBvczp0aGlzLnRtcFBvaW50c1swXS5YWX19dXBkYXRlVGVtcFBvaW50cyhlKXtjb25zdCB0PWUuc2xpY2UoLTIpLG49bmV3IEZ0KHRbMF0sdFsxXSksaT10aGlzLnRtcFBvaW50c1swXSx7dGhpY2tuZXNzOmZ9PXRoaXMud29ya09wdGlvbnM7aWYoaS5pc05lYXIobixmKSlyZXR1cm4hMTtpZih0aGlzLnRtcFBvaW50cy5sZW5ndGg9PT0yKXtpZihuLmlzTmVhcih0aGlzLnRtcFBvaW50c1sxXSwxKSlyZXR1cm4hMTt0aGlzLnRtcFBvaW50c1sxXT1ufWVsc2UgdGhpcy50bXBQb2ludHMucHVzaChuKTtyZXR1cm4hMH1jb25zdW1lU2VydmljZShlKXt2YXIgdTtjb25zdHtvcDp0LGlzRnVsbFdvcms6bn09ZSxpPSh1PXRoaXMud29ya0lkKT09bnVsbD92b2lkIDA6dS50b1N0cmluZygpO2lmKCFpKXJldHVybjt0aGlzLnRtcFBvaW50cy5sZW5ndGg9MDtmb3IobGV0IGE9MDthPHQubGVuZ3RoO2ErPTMpdGhpcy50bXBQb2ludHMucHVzaChuZXcgRnQodFthXSx0W2ErMV0sdFthKzJdKSk7Y29uc3QgZj1uP3RoaXMuZnVsbExheWVyOnRoaXMuZHJhd0xheWVyfHx0aGlzLmZ1bGxMYXllcixoPXRoaXMuZHJhdyh7d29ya0lkOmksbGF5ZXI6Zn0pO3JldHVybiB0aGlzLm9sZFJlY3Q9aCx0aGlzLnZOb2Rlcy5zZXRJbmZvKGkse3JlY3Q6aCxvcDp0LG9wdDp0aGlzLndvcmtPcHRpb25zLHRvb2xzVHlwZTp0aGlzLnRvb2xzVHlwZSxzY2FsZVR5cGU6dGhpcy5zY2FsZVR5cGUsY2FuUm90YXRlOnRoaXMuY2FuUm90YXRlLGNlbnRlclBvczpoJiZEdC5nZXRDZW50ZXJQb3MoaCxmKX0pLGh9Y2xlYXJUbXBQb2ludHMoKXt0aGlzLnRtcFBvaW50cy5sZW5ndGg9MH1zdGF0aWMgdXBkYXRlTm9kZU9wdChlKXt2YXIgdTtjb25zdHtub2RlOnQsb3B0Om4sdk5vZGVzOml9PWUse3N0cm9rZUNvbG9yOmZ9PW4saD1pLmdldCh0Lm5hbWUpO3JldHVybiBmJiYodC5zZXRBdHRyaWJ1dGUoInN0cm9rZUNvbG9yIixmKSx0LnNldEF0dHJpYnV0ZSgiZmlsbENvbG9yIixmKSwodT1oPT1udWxsP3ZvaWQgMDpoLm9wdCkhPW51bGwmJnUuc3Ryb2tlQ29sb3ImJihoLm9wdC5zdHJva2VDb2xvcj1mKSksaCYmaS5zZXRJbmZvKHQubmFtZSxoKSxEdC51cGRhdGVOb2RlT3B0KGUpfX1jbGFzcyBWYSBleHRlbmRzIER0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJjYW5Sb3RhdGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTohMX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzY2FsZVR5cGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTokZS5hbGx9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidG9vbHNUeXBlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6THQuVGV4dH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ0bXBQb2ludHMiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpbXX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ3b3JrT3B0aW9ucyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJvbGRSZWN0Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksdGhpcy53b3JrT3B0aW9ucz1lLnRvb2xzT3B0fWNvbnN1bWUoKXtyZXR1cm57dHlwZTpUdC5Ob25lfX1jb25zdW1lQWxsKCl7cmV0dXJue3R5cGU6VHQuTm9uZX19ZHJhdyhlKXt2YXIgTztjb25zdHt3b3JrSWQ6dCxsYXllcjpufT1lO3RoaXMuZnVsbExheWVyLmdldEVsZW1lbnRzQnlOYW1lKHQpLm1hcChtPT5tLnJlbW92ZSgpKSwoTz10aGlzLmRyYXdMYXllcik9PW51bGx8fE8uZ2V0RWxlbWVudHNCeU5hbWUodCkubWFwKG09Pm0ucmVtb3ZlKCkpO2NvbnN0e2JveFNpemU6aSxib3hQb2ludDpmLHN0cm9rZUNvbG9yOmh9PXRoaXMud29ya09wdGlvbnMsdT1uLndvcmxkUG9zaXRpb24sYT1uLndvcmxkU2NhbGluZztpZighZnx8IWkpcmV0dXJuO2NvbnN0IGQ9bmV3IElyKHtuYW1lOnQsaWQ6dCxwb3M6W2ZbMF0raVswXS8yLGZbMV0raVsxXS8yXSxhbmNob3I6Wy41LC41XSxzaXplOmksYmdjb2xvcjpoLG9wYWNpdHk6LjF9KSxFPXt4OmZbMF0seTpmWzFdLHc6aVswXSxoOmlbMV19LHA9bmV3IGdzKHtub3JtYWxpemU6ITAscG9zOlswLDBdLHNpemU6aSxsaW5lV2lkdGg6MH0pO3JldHVybiBkLmFwcGVuZENoaWxkKHApLG4uYXBwZW5kKGQpLHt4Ok1hdGguZmxvb3IoRS54KmFbMF0rdVswXSkseTpNYXRoLmZsb29yKEUueSphWzFdK3VbMV0pLHc6TWF0aC5mbG9vcihFLncqYVswXSksaDpNYXRoLmZsb29yKEUuaCphWzFdKX19Y29uc3VtZVNlcnZpY2UoZSl7dmFyIHUsYTtjb25zdCB0PSh1PXRoaXMud29ya0lkKT09bnVsbD92b2lkIDA6dS50b1N0cmluZygpO2lmKCF0KXJldHVybjtjb25zdHtpc0Z1bGxXb3JrOm4scmVwbGFjZUlkOml9PWU7dGhpcy5vbGRSZWN0PWkmJigoYT10aGlzLnZOb2Rlcy5nZXQoaSkpPT1udWxsP3ZvaWQgMDphLnJlY3QpfHx2b2lkIDA7Y29uc3QgZj1uP3RoaXMuZnVsbExheWVyOnRoaXMuZHJhd0xheWVyfHx0aGlzLmZ1bGxMYXllcixoPXRoaXMuZHJhdyh7d29ya0lkOnQsbGF5ZXI6Zn0pO3JldHVybiB0aGlzLnZOb2Rlcy5zZXRJbmZvKHQse3JlY3Q6aCxvcDpbXSxvcHQ6dGhpcy53b3JrT3B0aW9ucyx0b29sc1R5cGU6dGhpcy50b29sc1R5cGUsc2NhbGVUeXBlOnRoaXMuc2NhbGVUeXBlLGNhblJvdGF0ZTp0aGlzLmNhblJvdGF0ZSxjZW50ZXJQb3M6aCYmRHQuZ2V0Q2VudGVyUG9zKGgsZil9KSxofXVwZGF0YU9wdFNlcnZpY2UoZSl7aWYoIXRoaXMud29ya0lkKXJldHVybjtjb25zdCB0PXRoaXMud29ya0lkLnRvU3RyaW5nKCkse2ZvbnRDb2xvcjpuLGZvbnRCZ0NvbG9yOml9PWUsZj10aGlzLnZOb2Rlcy5nZXQodCk7aWYoIWYpcmV0dXJuO24mJihmLm9wdC5mb250Q29sb3I9biksaSYmKGYub3B0LmZvbnRCZ0NvbG9yPWkpLHRoaXMub2xkUmVjdD1mLnJlY3Q7Y29uc3QgaD10aGlzLmRyYXcoe3dvcmtJZDp0LGxheWVyOnRoaXMuZnVsbExheWVyfSk7cmV0dXJuIHRoaXMudk5vZGVzLnNldEluZm8odCx7cmVjdDpoLG9wOltdLG9wdDp0aGlzLndvcmtPcHRpb25zLHRvb2xzVHlwZTp0aGlzLnRvb2xzVHlwZSxzY2FsZVR5cGU6dGhpcy5zY2FsZVR5cGUsY2FuUm90YXRlOnRoaXMuY2FuUm90YXRlLGNlbnRlclBvczpoJiZEdC5nZXRDZW50ZXJQb3MoaCx0aGlzLmZ1bGxMYXllcil9KSxofWNsZWFyVG1wUG9pbnRzKCl7dGhpcy50bXBQb2ludHMubGVuZ3RoPTB9c3RhdGljIGNyZWF0ZUxhYmVscyhlLHQpe2NvbnN0IG49W10saT1lLnRleHQubGVuZ3RoO2ZvcihsZXQgZj0wO2Y8aTtmKyspe2NvbnN0IGg9ZS50ZXh0W2ZdLHU9e2FuY2hvcjpbLjUsLjVdLHRleHQ6aCxmb250U2l6ZTplLmZvbnRTaXplLGxpbmVIZWlnaHQ6ZS5mb250U2l6ZSxmb250RmFtaWx5OmUuZm9udEZhbWlseSxmb250U3R5bGU6ZS5mb250U3R5bGUsZmlsbENvbG9yOmUuZm9udENvbG9yLGJnY29sb3I6ZS5mb250QmdDb2xvcix0ZXh0QWxpZ246ZS50ZXh0QWxpZ24sZm9udFdlaWdodDplLmZvbnRXZWlnaHR9LGE9WzAsMF07aWYoZS52ZXJ0aWNhbEFsaWduPT09Im1pZGRsZSIpe2NvbnN0IEU9KGktMSkvMjthWzFdPShmLUUpKnUubGluZUhlaWdodH1lLnRleHRBbGlnbj09PSJsZWZ0IiYmKGFbMF09LXQudy8yLHUuYW5jaG9yPVswLC41XSksdS5wb3M9YTtjb25zdCBkPW5ldyB5bSh1KTtuLnB1c2goZCl9cmV0dXJuIG59c3RhdGljIHVwZGF0ZU5vZGVPcHQoZSl7Y29uc3R7bm9kZTp0LG9wdDpuLHZOb2RlczppLHRhcmdldE5vZGU6Zn09ZSx7Zm9udEJnQ29sb3I6aCxmb250Q29sb3I6dSx0cmFuc2xhdGU6YSxib3g6ZCxib3hTY2FsZTpFLGJveFRyYW5zbGF0ZTpwLHdvcmtTdGF0ZTpPfT1uLG09ZiYmZHIoZil8fGkuZ2V0KHQubmFtZSk7aWYoIW0pcmV0dXJuO2NvbnN0IGI9dC5wYXJlbnQ7aWYoIWIpcmV0dXJuO2NvbnN0IE09bS5vcHQ7aWYoTS53b3JrU3RhdGU9Tyx1JiZNLmZvbnRDb2xvciYmKE0uZm9udENvbG9yPXUpLGgmJk0uZm9udEJnQ29sb3ImJihNLmZvbnRCZ0NvbG9yPWgpLGQmJnAmJkUpe2NvbnN0e2JveFNpemU6eSxmb250U2l6ZTpTfT1NLHM9bS5yZWN0LGM9TGEodW0ocyxFKSxwKTtNLmJveFBvaW50PWMmJlsoYy54LWIud29ybGRQb3NpdGlvblswXSkvYi53b3JsZFNjYWxpbmdbMF0sKGMueS1iLndvcmxkUG9zaXRpb25bMV0pL2Iud29ybGRTY2FsaW5nWzFdXSxNLmJveFNpemU9eSYmW3lbMF0qRVswXSx5WzFdKkVbMV1dLE0uZm9udFNpemU9UyYmUypFWzBdfWVsc2UgYSYmTS5ib3hQb2ludCYmKE0uYm94UG9pbnQ9W00uYm94UG9pbnRbMF0rYVswXSxNLmJveFBvaW50WzFdK2FbMV1dLG0uY2VudGVyUG9zPVttLmNlbnRlclBvc1swXSthWzBdLG0uY2VudGVyUG9zWzFdK2FbMV1dLG0ucmVjdD17eDptLnJlY3QueCthWzBdLHk6bS5yZWN0LnkrYVsxXSx3Om0ucmVjdC53LGg6bS5yZWN0Lmh9KTtyZXR1cm4gbSYmaS5zZXRJbmZvKHQubmFtZSxtKSxtPT1udWxsP3ZvaWQgMDptLnJlY3R9c3RhdGljIGdldFJlY3RGcm9tTGF5ZXIoZSx0KXtjb25zdCBuPWUuZ2V0RWxlbWVudHNCeU5hbWUodClbMF07aWYobil7Y29uc3QgaT1uLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO3JldHVybnt4Ok1hdGguZmxvb3IoaS54KSx5Ok1hdGguZmxvb3IoaS55KSx3Ok1hdGguZmxvb3IoaS53aWR0aCksaDpNYXRoLmZsb29yKGkuaGVpZ2h0KX19fX1mdW5jdGlvbiBYYShnKXtzd2l0Y2goZyl7Y2FzZSBMdC5BcnJvdzpyZXR1cm4gemE7Y2FzZSBMdC5QZW5jaWw6cmV0dXJuIGphO2Nhc2UgTHQuU3RyYWlnaHQ6cmV0dXJuIFlhO2Nhc2UgTHQuRWxsaXBzZTpyZXR1cm4gJGE7Y2FzZSBMdC5Qb2x5Z29uOmNhc2UgTHQuVHJpYW5nbGU6cmV0dXJuIEhhO2Nhc2UgTHQuU3RhcjpjYXNlIEx0LlJob21idXM6cmV0dXJuIEthO2Nhc2UgTHQuUmVjdGFuZ2xlOnJldHVybiBHYTtjYXNlIEx0LlRleHQ6cmV0dXJuIFZhO2Nhc2UgTHQuTGFzZXJQZW46cmV0dXJuIFVhO2Nhc2UgTHQuRXJhc2VyOnJldHVybiBscjtjYXNlIEx0LlNlbGVjdG9yOnJldHVybiBpZX19ZnVuY3Rpb24gWmEoZyl7Y29uc3R7dG9vbHNUeXBlOmUsLi4udH09Zztzd2l0Y2goZSl7Y2FzZSBMdC5BcnJvdzpyZXR1cm4gbmV3IHphKHQpO2Nhc2UgTHQuUGVuY2lsOnJldHVybiBuZXcgamEodCk7Y2FzZSBMdC5TdHJhaWdodDpyZXR1cm4gbmV3IFlhKHQpO2Nhc2UgTHQuRWxsaXBzZTpyZXR1cm4gbmV3ICRhKHQpO2Nhc2UgTHQuUG9seWdvbjpjYXNlIEx0LlRyaWFuZ2xlOnJldHVybiBuZXcgSGEodCk7Y2FzZSBMdC5TdGFyOmNhc2UgTHQuUmhvbWJ1czpyZXR1cm4gbmV3IEthKHQpO2Nhc2UgTHQuUmVjdGFuZ2xlOnJldHVybiBuZXcgR2EodCk7Y2FzZSBMdC5UZXh0OnJldHVybiBuZXcgVmEodCk7Y2FzZSBMdC5MYXNlclBlbjpyZXR1cm4gbmV3IFVhKHQpO2Nhc2UgTHQuRXJhc2VyOnJldHVybiBuZXcgbHIodCk7Y2FzZSBMdC5TZWxlY3RvcjpyZXR1cm4gbmV3IGllKHQpO2RlZmF1bHQ6cmV0dXJufX1jbGFzcyBibSBleHRlbmRzIFJye2NvbnN0cnVjdG9yKCl7c3VwZXIoLi4uYXJndW1lbnRzKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiZW1pdEV2ZW50VHlwZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOm9lLlpJbmRleEFjdGl2ZX0pfWNvbnN1bWUoZSl7Y29uc3R7bXNnVHlwZTp0LGRhdGFUeXBlOm4sZW1pdEV2ZW50VHlwZTppfT1lO2lmKHQ9PT1UdC5VcGRhdGVOb2RlJiZuPT09enQuTG9jYWwmJmk9PT10aGlzLmVtaXRFdmVudFR5cGUpcmV0dXJuIHRoaXMuY29uc3VtZUZvckxvY2FsV29ya2VyKGUpLCEwfWNvbnN1bWVGb3JMb2NhbFdvcmtlcihlKXt2YXIgdSxhLGQsRSxwO2NvbnN0e3dvcmtJZDp0LGlzQWN0aXZlWkluZGV4Om4sd2lsbFJlZnJlc2hTZWxlY3RvcjppfT1lO2lmKHQhPT1pZS5zZWxlY3RvcklkKXJldHVybjtjb25zdCBmPSh1PXRoaXMubG9jYWxXb3JrKT09bnVsbD92b2lkIDA6dS53b3JrU2hhcGVzLmdldChpZS5zZWxlY3RvcklkKTtpZighZilyZXR1cm47Y29uc3QgaD1mLm9sZFNlbGVjdFJlY3Q7aWYobiYmaCYmdGhpcy5sb2NhbFdvcmspe2NvbnN0IE89bmV3IFNldDtpZih0aGlzLmxvY2FsV29yay52Tm9kZXMuY3VyTm9kZU1hcC5mb3JFYWNoKChtLGIpPT57Um4oaCxtLnJlY3QpJiZPLmFkZChiKX0pLE8uc2l6ZSl7Y29uc3QgbT1bXTtPLmZvckVhY2goYj0+e3ZhciBNOyhNPXRoaXMubG9jYWxXb3JrKT09bnVsbHx8TS5mdWxsTGF5ZXIuZ2V0RWxlbWVudHNCeU5hbWUoYikuZm9yRWFjaCh5PT57dmFyIHMsYztjb25zdCBTPXkuY2xvbmVOb2RlKCEwKTtyaSh5KSYmUy5zZWFsKCksKGM9KHM9dGhpcy5sb2NhbFdvcmspPT1udWxsP3ZvaWQgMDpzLmRyYXdMYXllcikhPW51bGwmJmMuZ2V0RWxlbWVudHNCeU5hbWUoYikubGVuZ3RofHxtLnB1c2goUyl9KX0pLG0ubGVuZ3RoJiYoKGE9dGhpcy5sb2NhbFdvcmsuZHJhd0xheWVyKT09bnVsbHx8YS5hcHBlbmQoLi4ubSkpfX1lbHNlKEU9KGQ9dGhpcy5sb2NhbFdvcmspPT1udWxsP3ZvaWQgMDpkLmRyYXdMYXllcik9PW51bGx8fEUuY2hpbGRyZW4uZmlsdGVyKE89Pnt2YXIgbTtyZXR1cm4hKChtPWYuc2VsZWN0SWRzKSE9bnVsbCYmbS5pbmNsdWRlcyhPLm5hbWUpKX0pLmZvckVhY2goTz0+Ty5yZW1vdmUoKSk7aSYmKChwPXRoaXMubG9jYWxXb3JrKT09bnVsbHx8cC5fcG9zdCh7cmVuZGVyOlt7cmVjdDpoLGRyYXdDYW52YXM6QnQuU2VsZWN0b3IsY2xlYXJDYW52YXM6QnQuU2VsZWN0b3IsaXNDbGVhcjohMCxpc0Z1bGxXb3JrOiExLHZpZXdJZDp0aGlzLmxvY2FsV29yay52aWV3SWR9XSxzcDpbe3R5cGU6VHQuU2VsZWN0LHNlbGVjdElkczpmLnNlbGVjdElkcyxvcHQ6Zi5nZXRXb3JrT3B0aW9ucygpLHNlbGVjdFJlY3Q6aCxzdHJva2VDb2xvcjpmLnN0cm9rZUNvbG9yLGZpbGxDb2xvcjpmLmZpbGxDb2xvcix3aWxsU3luY1NlcnZpY2U6ITEsaXNTeW5jOiEwfV19KSl9fWNsYXNzIEFtIGV4dGVuZHMgUnJ7Y29uc3RydWN0b3IoKXtzdXBlciguLi5hcmd1bWVudHMpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJlbWl0RXZlbnRUeXBlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6b2UuQ29weU5vZGV9KX1jb25zdW1lKGUpe2NvbnN0e21zZ1R5cGU6dCxkYXRhVHlwZTpuLGVtaXRFdmVudFR5cGU6aX09ZTtpZih0PT09VHQuRnVsbFdvcmsmJm49PT16dC5Mb2NhbCYmaT09PXRoaXMuZW1pdEV2ZW50VHlwZSlyZXR1cm4gdGhpcy5jb25zdW1lRm9yTG9jYWxXb3JrZXIoZSksITB9Y29uc3VtZUZvckxvY2FsV29ya2VyKGUpe3ZhciBuO2NvbnN0e3dvcmtJZDp0fT1lO3QmJigobj10aGlzLmxvY2FsV29yayk9PW51bGx8fG4uY29uc3VtZUZ1bGwoZSkpfX1jbGFzcyBDbSBleHRlbmRzIFJye2NvbnN0cnVjdG9yKCl7c3VwZXIoLi4uYXJndW1lbnRzKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiZW1pdEV2ZW50VHlwZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOm9lLlNldENvbG9yTm9kZX0pfWNvbnN1bWUoZSl7Y29uc3R7bXNnVHlwZTp0LGRhdGFUeXBlOm4sZW1pdEV2ZW50VHlwZTppLHVuZG9UaWNrZXJJZDpmfT1lO2lmKHQ9PT1UdC5VcGRhdGVOb2RlJiZuPT09enQuTG9jYWwmJmk9PT10aGlzLmVtaXRFdmVudFR5cGUpcmV0dXJuIHRoaXMuY29uc3VtZUZvckxvY2FsV29ya2VyKGUpLGYmJnNldFRpbWVvdXQoKCk9Pnt2YXIgaDsoaD10aGlzLmxvY2FsV29yayk9PW51bGx8fGguX3Bvc3Qoe3NwOlt7dHlwZTpUdC5Ob25lLHVuZG9UaWNrZXJJZDpmfV19KX0sMCksITB9Y29uc3VtZUZvckxvY2FsV29ya2VyKGUpe3ZhciBhO2NvbnN0e3dvcmtJZDp0LHVwZGF0ZU5vZGVPcHQ6bix3aWxsUmVmcmVzaFNlbGVjdG9yOmksd2lsbFN5bmNTZXJ2aWNlOmYsd2lsbFNlcmlhbGl6ZURhdGE6aCx0ZXh0VXBkYXRlRm9yV29rZXI6dX09ZTt0PT09aWUuc2VsZWN0b3JJZCYmbiYmKChhPXRoaXMubG9jYWxXb3JrKT09bnVsbHx8YS51cGRhdGVTZWxlY3Rvcih7dXBkYXRlU2VsZWN0b3JPcHQ6bix3aWxsUmVmcmVzaFNlbGVjdG9yOmksd2lsbFN5bmNTZXJ2aWNlOmYsd2lsbFNlcmlhbGl6ZURhdGE6aCx0ZXh0VXBkYXRlRm9yV29rZXI6dX0pKX19Y2xhc3MgUm0gZXh0ZW5kcyBScntjb25zdHJ1Y3Rvcigpe3N1cGVyKC4uLmFyZ3VtZW50cyksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImVtaXRFdmVudFR5cGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpvZS5aSW5kZXhOb2RlfSl9Y29uc3VtZShlKXtjb25zdHttc2dUeXBlOnQsZGF0YVR5cGU6bixlbWl0RXZlbnRUeXBlOml9PWU7aWYodD09PVR0LlVwZGF0ZU5vZGUmJm49PT16dC5Mb2NhbCYmaT09PXRoaXMuZW1pdEV2ZW50VHlwZSlyZXR1cm4gdGhpcy5jb25zdW1lRm9yTG9jYWxXb3JrZXIoZSksITB9Y29uc3VtZUZvckxvY2FsV29ya2VyKGUpe3ZhciB1O2NvbnN0e3dvcmtJZDp0LHVwZGF0ZU5vZGVPcHQ6bix3aWxsUmVmcmVzaFNlbGVjdG9yOmksd2lsbFN5bmNTZXJ2aWNlOmYsd2lsbFNlcmlhbGl6ZURhdGE6aH09ZTt0PT09aWUuc2VsZWN0b3JJZCYmbiYmKCh1PXRoaXMubG9jYWxXb3JrKT09bnVsbHx8dS51cGRhdGVTZWxlY3Rvcih7dXBkYXRlU2VsZWN0b3JPcHQ6bix3aWxsUmVmcmVzaFNlbGVjdG9yOmksd2lsbFN5bmNTZXJ2aWNlOmYsd2lsbFNlcmlhbGl6ZURhdGE6aH0pKX19Y2xhc3MgSW0gZXh0ZW5kcyBScntjb25zdHJ1Y3Rvcigpe3N1cGVyKC4uLmFyZ3VtZW50cyksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImVtaXRFdmVudFR5cGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpvZS5UcmFuc2xhdGVOb2RlfSl9Y29uc3VtZShlKXtjb25zdHttc2dUeXBlOnQsZGF0YVR5cGU6bixlbWl0RXZlbnRUeXBlOmksdW5kb1RpY2tlcklkOmZ9PWU7aWYodD09PVR0LlVwZGF0ZU5vZGUmJm49PT16dC5Mb2NhbCYmaT09PXRoaXMuZW1pdEV2ZW50VHlwZSlyZXR1cm4gdGhpcy5jb25zdW1lRm9yTG9jYWxXb3JrZXIoZSksZiYmc2V0VGltZW91dCgoKT0+e3ZhciBoOyhoPXRoaXMubG9jYWxXb3JrKT09bnVsbHx8aC5fcG9zdCh7c3A6W3t0eXBlOlR0Lk5vbmUsdW5kb1RpY2tlcklkOmZ9XX0pfSwwKSwhMH1jb25zdW1lRm9yTG9jYWxXb3JrZXIoZSl7dmFyIGQ7Y29uc3R7d29ya0lkOnQsdXBkYXRlTm9kZU9wdDpuLHdpbGxSZWZyZXNoU2VsZWN0b3I6aSx3aWxsU3luY1NlcnZpY2U6Zix3aWxsU2VyaWFsaXplRGF0YTpoLHRleHRVcGRhdGVGb3JXb2tlcjp1LGVtaXRFdmVudFR5cGU6YX09ZTt0PT09aWUuc2VsZWN0b3JJZCYmbiYmKChkPXRoaXMubG9jYWxXb3JrKT09bnVsbHx8ZC51cGRhdGVTZWxlY3Rvcih7dXBkYXRlU2VsZWN0b3JPcHQ6bix3aWxsUmVmcmVzaFNlbGVjdG9yOmksd2lsbFN5bmNTZXJ2aWNlOmYsd2lsbFNlcmlhbGl6ZURhdGE6aCxpc1N5bmM6ITAsdGV4dFVwZGF0ZUZvcldva2VyOnUsZW1pdEV2ZW50VHlwZTphfSkpfX1jbGFzcyBMbSBleHRlbmRzIFJye2NvbnN0cnVjdG9yKCl7c3VwZXIoLi4uYXJndW1lbnRzKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiZW1pdEV2ZW50VHlwZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOm9lLkRlbGV0ZU5vZGV9KX1jb25zdW1lKGUpe2NvbnN0e21zZ1R5cGU6dCxkYXRhVHlwZTpuLGVtaXRFdmVudFR5cGU6aX09ZTtpZih0PT09VHQuUmVtb3ZlTm9kZSl7aWYobj09PXp0LkxvY2FsJiZpPT09dGhpcy5lbWl0RXZlbnRUeXBlKXJldHVybiB0aGlzLmNvbnN1bWVGb3JMb2NhbFdvcmtlcihlKSwhMDtpZihuPT09enQuU2VydmljZSYmaT09PXRoaXMuZW1pdEV2ZW50VHlwZSlyZXR1cm4gdGhpcy5jb25zdW1lRm9yU2VydmljZVdvcmtlcihlKSwhMH19Y29uc3VtZUZvckxvY2FsV29ya2VyKGUpe2lmKCF0aGlzLmxvY2FsV29yaylyZXR1cm47Y29uc3R7cmVtb3ZlSWRzOnQsd2lsbFJlZnJlc2g6bix3aWxsU3luY1NlcnZpY2U6aSx2aWV3SWQ6Zn09ZTtpZighKHQhPW51bGwmJnQubGVuZ3RoKSlyZXR1cm47bGV0IGg7Y29uc3QgdT1bXSxhPVtdLGQ9W107Zm9yKGNvbnN0IEUgb2YgdCl7aWYoRT09PWllLnNlbGVjdG9ySWQpe2NvbnN0IE89dGhpcy5sb2NhbFdvcmsud29ya1NoYXBlcy5nZXQoaWUuc2VsZWN0b3JJZCksbT1PLnNlbGVjdElkcyYmWy4uLk8uc2VsZWN0SWRzXXx8W107Zm9yKGNvbnN0IE0gb2YgbSl7aWYodGhpcy5sb2NhbFdvcmsudk5vZGVzLmdldChNKSl7Y29uc3QgUz10aGlzLmNvbW1hbmREZWxldGVUZXh0KE0pO1MmJnUucHVzaChTKX1oPSR0KGgsdGhpcy5sb2NhbFdvcmsucmVtb3ZlTm9kZShNKSksZC5wdXNoKE0pfWNvbnN0IGI9Tz09bnVsbD92b2lkIDA6Ty51cGRhdGVTZWxlY3RJZHMoW10pO2g9JHQoaCxiLmJnUmVjdCksdGhpcy5sb2NhbFdvcmsuY2xlYXJXb3JrU2hhcGVOb2RlQ2FjaGUoaWUuc2VsZWN0b3JJZCksdGhpcy5sb2NhbFdvcmsud29ya1NoYXBlcy5kZWxldGUoaWUuc2VsZWN0b3JJZCksdS5wdXNoKHt0eXBlOlR0LlNlbGVjdCxzZWxlY3RJZHM6W10sd2lsbFN5bmNTZXJ2aWNlOml9KTtjb250aW51ZX1jb25zdCBwPXRoaXMuY29tbWFuZERlbGV0ZVRleHQoRSk7cCYmdS5wdXNoKHApLGg9JHQoaCx0aGlzLmxvY2FsV29yay5yZW1vdmVOb2RlKEUpKSxkLnB1c2goRSl9aSYmdS5wdXNoKHt0eXBlOlR0LlJlbW92ZU5vZGUscmVtb3ZlSWRzOmQsdW5kb1RpY2tlcklkOmUudW5kb1RpY2tlcklkfSksaCYmbiYmYS5wdXNoKHtyZWN0OmgsZHJhd0NhbnZhczpCdC5CZyxjbGVhckNhbnZhczpCdC5CZyxpc0NsZWFyOiEwLGlzRnVsbFdvcms6ITAsdmlld0lkOmZ9KSwoYS5sZW5ndGh8fHUubGVuZ3RoKSYmdGhpcy5sb2NhbFdvcmsuX3Bvc3Qoe3JlbmRlcjphLHNwOnV9KX1jb25zdW1lRm9yU2VydmljZVdvcmtlcihlKXt0aGlzLnNlcnZpY2VXb3JrJiZ0aGlzLnNlcnZpY2VXb3JrLnJlbW92ZVNlbGVjdFdvcmsoZSl9Y29tbWFuZERlbGV0ZVRleHQoZSl7dmFyIG47Y29uc3QgdD0obj10aGlzLmxvY2FsV29yayk9PW51bGw/dm9pZCAwOm4udk5vZGVzLmdldChlKTtpZih0JiZ0LnRvb2xzVHlwZT09PUx0LlRleHQpcmV0dXJue3R5cGU6VHQuVGV4dFVwZGF0ZSx0b29sc1R5cGU6THQuVGV4dCx3b3JrSWQ6ZX19fWNsYXNzIERtIGV4dGVuZHMgUnJ7Y29uc3RydWN0b3IoKXtzdXBlciguLi5hcmd1bWVudHMpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJlbWl0RXZlbnRUeXBlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6b2UuU2NhbGVOb2RlfSl9Y29uc3VtZShlKXtjb25zdHttc2dUeXBlOnQsZGF0YVR5cGU6bixlbWl0RXZlbnRUeXBlOmksdW5kb1RpY2tlcklkOmZ9PWU7aWYodD09PVR0LlVwZGF0ZU5vZGUmJm49PT16dC5Mb2NhbCYmaT09PXRoaXMuZW1pdEV2ZW50VHlwZSlyZXR1cm4gdGhpcy5jb25zdW1lRm9yTG9jYWxXb3JrZXIoZSksZiYmc2V0VGltZW91dCgoKT0+e3ZhciBoOyhoPXRoaXMubG9jYWxXb3JrKT09bnVsbHx8aC5fcG9zdCh7c3A6W3t0eXBlOlR0Lk5vbmUsdW5kb1RpY2tlcklkOmZ9XX0pfSwwKSwhMH1jb25zdW1lRm9yTG9jYWxXb3JrZXIoZSl7dmFyIGE7Y29uc3R7d29ya0lkOnQsdXBkYXRlTm9kZU9wdDpuLHdpbGxSZWZyZXNoU2VsZWN0b3I6aSx3aWxsU3luY1NlcnZpY2U6Zix3aWxsU2VyaWFsaXplRGF0YTpoLHRleHRVcGRhdGVGb3JXb2tlcjp1fT1lO3Q9PT1pZS5zZWxlY3RvcklkJiZuJiYoKGE9dGhpcy5sb2NhbFdvcmspPT1udWxsfHxhLnVwZGF0ZVNlbGVjdG9yKHt1cGRhdGVTZWxlY3Rvck9wdDpuLHdpbGxSZWZyZXNoU2VsZWN0b3I6aSx3aWxsU3luY1NlcnZpY2U6ZixlbWl0RXZlbnRUeXBlOnRoaXMuZW1pdEV2ZW50VHlwZSx3aWxsU2VyaWFsaXplRGF0YTpoLGlzU3luYzohMCx0ZXh0VXBkYXRlRm9yV29rZXI6dX0pKX19Y2xhc3Mgd20gZXh0ZW5kcyBScntjb25zdHJ1Y3Rvcigpe3N1cGVyKC4uLmFyZ3VtZW50cyksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImVtaXRFdmVudFR5cGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpvZS5Sb3RhdGVOb2RlfSl9Y29uc3VtZShlKXtjb25zdHttc2dUeXBlOnQsZGF0YVR5cGU6bixlbWl0RXZlbnRUeXBlOmksdW5kb1RpY2tlcklkOmZ9PWU7aWYodD09PVR0LlVwZGF0ZU5vZGUmJm49PT16dC5Mb2NhbCYmaT09PXRoaXMuZW1pdEV2ZW50VHlwZSlyZXR1cm4gdGhpcy5jb25zdW1lRm9yTG9jYWxXb3JrZXIoZSksZiYmc2V0VGltZW91dCgoKT0+e3ZhciBoOyhoPXRoaXMubG9jYWxXb3JrKT09bnVsbHx8aC5fcG9zdCh7c3A6W3t0eXBlOlR0Lk5vbmUsdW5kb1RpY2tlcklkOmZ9XX0pfSwwKSwhMH1jb25zdW1lRm9yTG9jYWxXb3JrZXIoZSl7dmFyIGE7Y29uc3R7d29ya0lkOnQsdXBkYXRlTm9kZU9wdDpuLHdpbGxSZWZyZXNoU2VsZWN0b3I6aSx3aWxsU3luY1NlcnZpY2U6Zix3aWxsU2VyaWFsaXplRGF0YTpoLGVtaXRFdmVudFR5cGU6dX09ZTt0PT09aWUuc2VsZWN0b3JJZCYmbiYmKChhPXRoaXMubG9jYWxXb3JrKT09bnVsbHx8YS51cGRhdGVTZWxlY3Rvcih7dXBkYXRlU2VsZWN0b3JPcHQ6bix3aWxsUmVmcmVzaFNlbGVjdG9yOmksd2lsbFN5bmNTZXJ2aWNlOmYsd2lsbFNlcmlhbGl6ZURhdGE6aCxlbWl0RXZlbnRUeXBlOnUsaXNTeW5jOiEwfSkpfX1jbGFzcyBObXtjb25zdHJ1Y3RvcihlKXtPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiYnVpbGRlcnMiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpuZXcgTWFwfSksdGhpcy5idWlsZGVycz1uZXcgTWFwKGUubWFwKHQ9Plt0LHRoaXMuYnVpbGQodCldKSl9YnVpbGQoZSl7c3dpdGNoKGUpe2Nhc2Ugb2UuVHJhbnNsYXRlTm9kZTpyZXR1cm4gbmV3IEltO2Nhc2Ugb2UuWkluZGV4Tm9kZTpyZXR1cm4gbmV3IFJtO2Nhc2Ugb2UuWkluZGV4QWN0aXZlOnJldHVybiBuZXcgYm07Y2FzZSBvZS5Db3B5Tm9kZTpyZXR1cm4gbmV3IEFtO2Nhc2Ugb2UuU2V0Q29sb3JOb2RlOnJldHVybiBuZXcgQ207Y2FzZSBvZS5EZWxldGVOb2RlOnJldHVybiBuZXcgTG07Y2FzZSBvZS5TY2FsZU5vZGU6cmV0dXJuIG5ldyBEbTtjYXNlIG9lLlJvdGF0ZU5vZGU6cmV0dXJuIG5ldyB3bX19cmVnaXN0ZXJGb3JXb3JrZXIoZSx0KXtyZXR1cm4gdGhpcy5idWlsZGVycy5mb3JFYWNoKG49PntuJiZuLnJlZ2lzdGVyRm9yV29ya2VyKGUsdCl9KSx0aGlzfWNvbnN1bWVGb3JXb3JrZXIoZSl7Zm9yKGNvbnN0IHQgb2YgdGhpcy5idWlsZGVycy52YWx1ZXMoKSlpZih0IT1udWxsJiZ0LmNvbnN1bWUoZSkpcmV0dXJuITA7cmV0dXJuITF9fWNsYXNzIEJte2NvbnN0cnVjdG9yKGUsdCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInZpZXdJZCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzY2VuZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzY2VuZVBhdGgiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiZHJhd0xheWVyIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImZ1bGxMYXllciIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJjdXJOb2RlTWFwIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6bmV3IE1hcH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ0YXJnZXROb2RlTWFwIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6W119KSx0aGlzLnZpZXdJZD1lLHRoaXMuc2NlbmU9dH1pbml0KGUsdCl7dGhpcy5mdWxsTGF5ZXI9ZSx0aGlzLmRyYXdMYXllcj10fWdldChlKXtyZXR1cm4gdGhpcy5jdXJOb2RlTWFwLmdldChlKX1oYXNSZW5kZXJOb2Rlcygpe2xldCBlPSExO2Zvcihjb25zdCB0IG9mIHRoaXMuY3VyTm9kZU1hcC52YWx1ZXMoKSl3YSh0LnRvb2xzVHlwZSkmJihlPSEwKTtyZXR1cm4gZX1oYXMoZSl7dGhpcy5jdXJOb2RlTWFwLmhhcyhlKX1zZXRJbmZvKGUsdCl7Y29uc3Qgbj10aGlzLmN1ck5vZGVNYXAuZ2V0KGUpfHx7bmFtZTplLHJlY3Q6dC5yZWN0fTt0LnJlY3QmJihuLnJlY3Q9ZHIodC5yZWN0KSksdC5vcCYmKG4ub3A9ZHIodC5vcCkpLHQuY2FuUm90YXRlJiYobi5jYW5Sb3RhdGU9dC5jYW5Sb3RhdGUpLHQuc2NhbGVUeXBlJiYobi5zY2FsZVR5cGU9dC5zY2FsZVR5cGUpLHQub3B0JiYobi5vcHQ9ZHIodC5vcHQpKSx0LnRvb2xzVHlwZSYmKG4udG9vbHNUeXBlPXQudG9vbHNUeXBlKSx0LmNlbnRlclBvcyYmKG4uY2VudGVyUG9zPWRyKHQuY2VudGVyUG9zKSksbi5yZWN0P3RoaXMuY3VyTm9kZU1hcC5zZXQoZSxuKTp0aGlzLmN1ck5vZGVNYXAuZGVsZXRlKGUpfWRlbGV0ZShlKXt0aGlzLmN1ck5vZGVNYXAuZGVsZXRlKGUpfWNsZWFyKCl7dGhpcy5jdXJOb2RlTWFwLmNsZWFyKCksdGhpcy50YXJnZXROb2RlTWFwLmxlbmd0aD0wfWdldFJlY3RJbnRlcnNlY3RSYW5nZShlKXtsZXQgdDtjb25zdCBuPW5ldyBNYXA7cmV0dXJuIHRoaXMuY3VyTm9kZU1hcC5mb3JFYWNoKChpLGYpPT57Um4oZSxpLnJlY3QpJiYodD0kdCh0LGkucmVjdCksbi5zZXQoZixpKSl9KSx7cmVjdFJhbmdlOnQsbm9kZVJhbmdlOm59fWdldE5vZGVSZWN0Rm9ybVNoYXBlKGUsdCl7Y29uc3Qgbj1YYSh0LnRvb2xzVHlwZSk7bGV0IGk9dGhpcy5mdWxsTGF5ZXImJihuPT1udWxsP3ZvaWQgMDpuLmdldFJlY3RGcm9tTGF5ZXIodGhpcy5mdWxsTGF5ZXIsZSkpO3JldHVybiFpJiZ0aGlzLmRyYXdMYXllciYmKGk9bj09bnVsbD92b2lkIDA6bi5nZXRSZWN0RnJvbUxheWVyKHRoaXMuZHJhd0xheWVyLGUpKSxpfXVwZGF0ZU5vZGVzUmVjdCgpe3RoaXMuY3VyTm9kZU1hcC5mb3JFYWNoKChlLHQpPT57Y29uc3Qgbj10aGlzLmdldE5vZGVSZWN0Rm9ybVNoYXBlKHQsZSk7bj8oZS5yZWN0PW4sdGhpcy5jdXJOb2RlTWFwLnNldCh0LGUpKTp0aGlzLmN1ck5vZGVNYXAuZGVsZXRlKHQpfSl9Y29tYmluZUludGVyc2VjdFJlY3QoZSl7bGV0IHQ9ZTtyZXR1cm4gdGhpcy5jdXJOb2RlTWFwLmZvckVhY2gobj0+e1JuKHQsbi5yZWN0KSYmKHQ9JHQodCxuLnJlY3QpKX0pLHR9c2V0VGFyZ2V0KCl7cmV0dXJuIHRoaXMudGFyZ2V0Tm9kZU1hcC5wdXNoKGRyKHRoaXMuY3VyTm9kZU1hcCkpLHRoaXMudGFyZ2V0Tm9kZU1hcC5sZW5ndGgtMX1nZXRMYXN0VGFyZ2V0KCl7cmV0dXJuIHRoaXMudGFyZ2V0Tm9kZU1hcFt0aGlzLnRhcmdldE5vZGVNYXAubGVuZ3RoLTFdfWRlbGV0ZUxhc3RUYXJnZXQoKXt0aGlzLnRhcmdldE5vZGVNYXAubGVuZ3RoPXRoaXMudGFyZ2V0Tm9kZU1hcC5sZW5ndGgtMX1nZXRUYXJnZXQoZSl7cmV0dXJuIHRoaXMudGFyZ2V0Tm9kZU1hcFtlXX1kZWxldGVUYXJnZXQoZSl7dGhpcy50YXJnZXROb2RlTWFwLmxlbmd0aD1lfX1jbGFzcyBKYXtjb25zdHJ1Y3RvcihlLHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ2aWV3SWQiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiZnVsbExheWVyIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInZOb2RlcyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJkcHIiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywib3B0Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImNhbWVyYU9wdCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzY2VuZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLHRoaXMudmlld0lkPWUsdGhpcy5vcHQ9dCx0aGlzLmRwcj10LmRwcix0aGlzLnNjZW5lPXRoaXMuY3JlYXRlU2NlbmUodC5vZmZzY3JlZW5DYW52YXNPcHQpLHRoaXMuZnVsbExheWVyPXRoaXMuY3JlYXRlTGF5ZXIoImZ1bGxMYXllciIsdGhpcy5zY2VuZSx7Li4udC5sYXllck9wdCxidWZmZXJTaXplOnRoaXMudmlld0lkPT09Im1haW5WaWV3Ij82ZTM6M2UzfSksdGhpcy52Tm9kZXM9bmV3IEJtKGUsdGhpcy5zY2VuZSl9b24oZSl7Y29uc3R7bXNnVHlwZTp0LHRvb2xzVHlwZTpuLG9wdDppLHdvcmtJZDpmLHdvcmtTdGF0ZTpoLGRhdGFUeXBlOnV9PWU7c3dpdGNoKHQpe2Nhc2UgVHQuRGVzdHJveTp0aGlzLmRlc3Ryb3koKTticmVhaztjYXNlIFR0LkNsZWFyOnRoaXMuY2xlYXJBbGwoKTticmVhaztjYXNlIFR0LlVwZGF0ZVRvb2xzOmlmKG4mJmkpe2NvbnN0IGE9e3Rvb2xzVHlwZTpuLHRvb2xzT3B0Oml9O3RoaXMubG9jYWxXb3JrLnNldFRvb2xzT3B0KGEpfWJyZWFrO2Nhc2UgVHQuQ3JlYXRlV29yazpmJiZpJiYoIXRoaXMubG9jYWxXb3JrLmdldFRtcFdvcmtTaGFwZU5vZGUoKSYmbiYmdGhpcy5zZXRUb29sc09wdCh7dG9vbHNUeXBlOm4sdG9vbHNPcHQ6aX0pLHRoaXMuc2V0V29ya09wdCh7d29ya0lkOmYsdG9vbHNPcHQ6aX0pKTticmVhaztjYXNlIFR0LkRyYXdXb3JrOmg9PT1jZS5Eb25lJiZ1PT09enQuTG9jYWw/dGhpcy5jb25zdW1lRHJhd0FsbCh1LGUpOnRoaXMuY29uc3VtZURyYXcodSxlKTticmVha319dXBkYXRlU2NlbmUoZSl7dGhpcy5zY2VuZS5hdHRyKHsuLi5lfSk7Y29uc3R7d2lkdGg6dCxoZWlnaHQ6bn09ZTt0aGlzLnNjZW5lLmNvbnRhaW5lci53aWR0aD10LHRoaXMuc2NlbmUuY29udGFpbmVyLmhlaWdodD1uLHRoaXMuc2NlbmUud2lkdGg9dCx0aGlzLnNjZW5lLmhlaWdodD1uLHRoaXMudXBkYXRlTGF5ZXIoe3dpZHRoOnQsaGVpZ2h0Om59KX11cGRhdGVMYXllcihlKXtjb25zdHt3aWR0aDp0LGhlaWdodDpufT1lO3RoaXMuZnVsbExheWVyJiYodGhpcy5mdWxsTGF5ZXIucGFyZW50LnNldEF0dHJpYnV0ZSgid2lkdGgiLHQpLHRoaXMuZnVsbExheWVyLnBhcmVudC5zZXRBdHRyaWJ1dGUoImhlaWdodCIsbiksdGhpcy5mdWxsTGF5ZXIuc2V0QXR0cmlidXRlKCJzaXplIixbdCxuXSksdGhpcy5mdWxsTGF5ZXIuc2V0QXR0cmlidXRlKCJwb3MiLFt0Ki41LG4qLjVdKSksdGhpcy5kcmF3TGF5ZXImJih0aGlzLmRyYXdMYXllci5wYXJlbnQuc2V0QXR0cmlidXRlKCJ3aWR0aCIsdCksdGhpcy5kcmF3TGF5ZXIucGFyZW50LnNldEF0dHJpYnV0ZSgiaGVpZ2h0IixuKSx0aGlzLmRyYXdMYXllci5zZXRBdHRyaWJ1dGUoInNpemUiLFt0LG5dKSx0aGlzLmRyYXdMYXllci5zZXRBdHRyaWJ1dGUoInBvcyIsW3QqLjUsbiouNV0pKSx0aGlzLnNuYXBzaG90RnVsbExheWVyJiYodGhpcy5zbmFwc2hvdEZ1bGxMYXllci5wYXJlbnQuc2V0QXR0cmlidXRlKCJ3aWR0aCIsdCksdGhpcy5zbmFwc2hvdEZ1bGxMYXllci5wYXJlbnQuc2V0QXR0cmlidXRlKCJoZWlnaHQiLG4pLHRoaXMuc25hcHNob3RGdWxsTGF5ZXIuc2V0QXR0cmlidXRlKCJzaXplIixbdCxuXSksdGhpcy5zbmFwc2hvdEZ1bGxMYXllci5zZXRBdHRyaWJ1dGUoInBvcyIsW3QqLjUsbiouNV0pKX1jcmVhdGVTY2VuZShlKXtjb25zdHt3aWR0aDp0LGhlaWdodDpufT1lLGk9bmV3IE9mZnNjcmVlbkNhbnZhcyh0LG4pO3JldHVybiBuZXcgeG0oe2NvbnRhaW5lcjppLGRpc3BsYXlSYXRpbzp0aGlzLmRwcixkZXB0aDohMSxkZXN5bmNocm9uaXplZDohMCwuLi5lfSl9Y3JlYXRlTGF5ZXIoZSx0LG4pe2NvbnN0e3dpZHRoOmksaGVpZ2h0OmZ9PW4saD1gb2Zmc2NyZWVuLSR7ZX1gLHU9dC5sYXllcihoLG4pLGE9bmV3IElyKHthbmNob3I6Wy41LC41XSxwb3M6W2kqLjUsZiouNV0sc2l6ZTpbaSxmXSxuYW1lOiJ2aWV3cG9ydCIsaWQ6ZX0pO3JldHVybiB1LmFwcGVuZChhKSxhfWNsZWFyQWxsKCl7dmFyIGU7dGhpcy5mdWxsTGF5ZXImJih0aGlzLmZ1bGxMYXllci5wYXJlbnQuY2hpbGRyZW4uZm9yRWFjaCh0PT57dC5uYW1lIT09InZpZXdwb3J0IiYmdC5yZW1vdmUoKX0pLHRoaXMuZnVsbExheWVyLnJlbW92ZUFsbENoaWxkcmVuKCkpLHRoaXMuZHJhd0xheWVyJiYodGhpcy5kcmF3TGF5ZXIucGFyZW50LmNoaWxkcmVuLmZvckVhY2godD0+e3QubmFtZSE9PSJ2aWV3cG9ydCImJnQucmVtb3ZlKCl9KSx0aGlzLmRyYXdMYXllci5yZW1vdmVBbGxDaGlsZHJlbigpKSx0aGlzLmxvY2FsV29yay5jbGVhckFsbFdvcmtTaGFwZXNDYWNoZSgpLChlPXRoaXMuc2VydmljZVdvcmspPT1udWxsfHxlLmNsZWFyQWxsV29ya1NoYXBlc0NhY2hlKCl9c2V0VG9vbHNPcHQoZSl7dGhpcy5sb2NhbFdvcmsuc2V0VG9vbHNPcHQoZSl9c2V0V29ya09wdChlKXtjb25zdHt3b3JrSWQ6dCx0b29sc09wdDpufT1lO3QmJm4mJnRoaXMubG9jYWxXb3JrLnNldFdvcmtPcHRpb25zKHQsbil9ZGVzdHJveSgpe3ZhciBlO3RoaXMudk5vZGVzLmNsZWFyKCksdGhpcy5zY2VuZS5yZW1vdmUoKSx0aGlzLmZ1bGxMYXllci5yZW1vdmUoKSx0aGlzLmxvY2FsV29yay5kZXN0cm95KCksKGU9dGhpcy5zZXJ2aWNlV29yayk9PW51bGx8fGUuZGVzdHJveSgpfX1jbGFzcyBRYXtjb25zdHJ1Y3RvcihlKXtPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidmlld0lkIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInZOb2RlcyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJmdWxsTGF5ZXIiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiZHJhd0xheWVyIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIl9wb3N0Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInRtcFdvcmtTaGFwZU5vZGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidG1wT3B0Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIndvcmtTaGFwZXMiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpuZXcgTWFwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIndvcmtTaGFwZVN0YXRlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6bmV3IE1hcH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJlZmZlY3RXb3JrSWQiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiZHJhd0NvdW50Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6MH0pLHRoaXMudmlld0lkPWUudmlld0lkLHRoaXMudk5vZGVzPWUudk5vZGVzLHRoaXMuZnVsbExheWVyPWUuZnVsbExheWVyLHRoaXMuZHJhd0xheWVyPWUuZHJhd0xheWVyLHRoaXMuX3Bvc3Q9ZS5wb3N0fWRlc3Ryb3koKXt0aGlzLndvcmtTaGFwZVN0YXRlLmNsZWFyKCksdGhpcy53b3JrU2hhcGVzLmNsZWFyKCl9Z2V0V29ya1NoYXBlKGUpe3JldHVybiB0aGlzLndvcmtTaGFwZXMuZ2V0KGUpfWdldFRtcFdvcmtTaGFwZU5vZGUoKXtyZXR1cm4gdGhpcy50bXBXb3JrU2hhcGVOb2RlfXNldFRtcFdvcmtJZChlKXtpZihlJiZ0aGlzLnRtcFdvcmtTaGFwZU5vZGUpe3RoaXMudG1wV29ya1NoYXBlTm9kZS5zZXRXb3JrSWQoZSksdGhpcy53b3JrU2hhcGVzLnNldChlLHRoaXMudG1wV29ya1NoYXBlTm9kZSksdGhpcy50bXBPcHQmJnRoaXMuc2V0VG9vbHNPcHQodGhpcy50bXBPcHQpO3JldHVybn19c2V0VG1wV29ya09wdGlvbnMoZSl7dmFyIHQ7KHQ9dGhpcy50bXBXb3JrU2hhcGVOb2RlKT09bnVsbHx8dC5zZXRXb3JrT3B0aW9ucyhlKX1zZXRXb3JrT3B0aW9ucyhlLHQpe3ZhciBpO3RoaXMud29ya1NoYXBlcy5nZXQoZSl8fHRoaXMuc2V0VG1wV29ya0lkKGUpLChpPXRoaXMud29ya1NoYXBlcy5nZXQoZSkpPT1udWxsfHxpLnNldFdvcmtPcHRpb25zKHQpfWNyZWF0ZVdvcmtTaGFwZU5vZGUoZSl7cmV0dXJuIFphKHsuLi5lLHZOb2Rlczp0aGlzLnZOb2RlcyxmdWxsTGF5ZXI6dGhpcy5mdWxsTGF5ZXIsZHJhd0xheWVyOnRoaXMuZHJhd0xheWVyfSl9c2V0VG9vbHNPcHQoZSl7dmFyIHQsbjsoKHQ9dGhpcy50bXBPcHQpPT1udWxsP3ZvaWQgMDp0LnRvb2xzVHlwZSkhPT1lLnRvb2xzVHlwZSYmKG49dGhpcy50bXBPcHQpIT1udWxsJiZuLnRvb2xzVHlwZSYmdGhpcy5jbGVhckFsbFdvcmtTaGFwZXNDYWNoZSgpLHRoaXMudG1wT3B0PWUsdGhpcy50bXBXb3JrU2hhcGVOb2RlPXRoaXMuY3JlYXRlV29ya1NoYXBlTm9kZShlKX1jbGVhcldvcmtTaGFwZU5vZGVDYWNoZShlKXt2YXIgdDsodD10aGlzLmdldFdvcmtTaGFwZShlKSk9PW51bGx8fHQuY2xlYXJUbXBQb2ludHMoKSx0aGlzLndvcmtTaGFwZXMuZGVsZXRlKGUpLHRoaXMud29ya1NoYXBlU3RhdGUuZGVsZXRlKGUpfWNsZWFyQWxsV29ya1NoYXBlc0NhY2hlKCl7dGhpcy53b3JrU2hhcGVzLmZvckVhY2goZT0+ZS5jbGVhclRtcFBvaW50cygpKSx0aGlzLndvcmtTaGFwZXMuY2xlYXIoKSx0aGlzLndvcmtTaGFwZVN0YXRlLmNsZWFyKCl9c2V0RnVsbFdvcmsoZSl7Y29uc3R7d29ya0lkOnQsb3B0Om4sdG9vbHNUeXBlOml9PWU7aWYodCYmbiYmaSl7Y29uc3QgZj10JiZ0aGlzLndvcmtTaGFwZXMuZ2V0KHQpfHx0aGlzLmNyZWF0ZVdvcmtTaGFwZU5vZGUoe3Rvb2xzT3B0Om4sdG9vbHNUeXBlOml9KTtyZXR1cm4gZj8oZi5zZXRXb3JrSWQodCksdGhpcy53b3JrU2hhcGVzLnNldCh0LGYpLGYpOnZvaWQgMH19fXZhciBXbT1hcixGbT1mdW5jdGlvbigpe3JldHVybiBXbS5EYXRlLm5vdygpfSxqbT1GbSxVbT0vXHMvO2Z1bmN0aW9uIHptKGcpe2Zvcih2YXIgZT1nLmxlbmd0aDtlLS0mJlVtLnRlc3QoZy5jaGFyQXQoZSkpOyk7cmV0dXJuIGV9dmFyICRtPXptLEdtPSRtLEttPS9eXHMrLztmdW5jdGlvbiBIbShnKXtyZXR1cm4gZyYmZy5zbGljZSgwLEdtKGcpKzEpLnJlcGxhY2UoS20sIiIpfXZhciBZbT1IbSxWbT1ybixYbT1HcixabT0iW29iamVjdCBTeW1ib2xdIjtmdW5jdGlvbiBKbShnKXtyZXR1cm4gdHlwZW9mIGc9PSJzeW1ib2wifHxYbShnKSYmVm0oZyk9PVptfXZhciBRbT1KbSxrbT1ZbSxrYT1DcixxbT1RbSxxYT1OYU4sX209L15bLStdMHhbMC05YS1mXSskL2ksdHk9L14wYlswMV0rJC9pLGV5PS9eMG9bMC03XSskL2kscnk9cGFyc2VJbnQ7ZnVuY3Rpb24gbnkoZyl7aWYodHlwZW9mIGc9PSJudW1iZXIiKXJldHVybiBnO2lmKHFtKGcpKXJldHVybiBxYTtpZihrYShnKSl7dmFyIGU9dHlwZW9mIGcudmFsdWVPZj09ImZ1bmN0aW9uIj9nLnZhbHVlT2YoKTpnO2c9a2EoZSk/ZSsiIjplfWlmKHR5cGVvZiBnIT0ic3RyaW5nIilyZXR1cm4gZz09PTA/ZzorZztnPWttKGcpO3ZhciB0PXR5LnRlc3QoZyk7cmV0dXJuIHR8fGV5LnRlc3QoZyk/cnkoZy5zbGljZSgyKSx0PzI6OCk6X20udGVzdChnKT9xYTorZ312YXIgaXk9bnksc3k9Q3IsbXM9am0sX2E9aXksb3k9IkV4cGVjdGVkIGEgZnVuY3Rpb24iLGF5PU1hdGgubWF4LGx5PU1hdGgubWluO2Z1bmN0aW9uIHV5KGcsZSx0KXt2YXIgbixpLGYsaCx1LGEsZD0wLEU9ITEscD0hMSxPPSEwO2lmKHR5cGVvZiBnIT0iZnVuY3Rpb24iKXRocm93IG5ldyBUeXBlRXJyb3Iob3kpO2U9X2EoZSl8fDAsc3kodCkmJihFPSEhdC5sZWFkaW5nLHA9Im1heFdhaXQiaW4gdCxmPXA/YXkoX2EodC5tYXhXYWl0KXx8MCxlKTpmLE89InRyYWlsaW5nImluIHQ/ISF0LnRyYWlsaW5nOk8pO2Z1bmN0aW9uIG0oVCl7dmFyIFI9bixMPWk7cmV0dXJuIG49aT12b2lkIDAsZD1ULGg9Zy5hcHBseShMLFIpLGh9ZnVuY3Rpb24gYihUKXtyZXR1cm4gZD1ULHU9c2V0VGltZW91dChTLGUpLEU/bShUKTpofWZ1bmN0aW9uIE0oVCl7dmFyIFI9VC1hLEw9VC1kLE49ZS1SO3JldHVybiBwP2x5KE4sZi1MKTpOfWZ1bmN0aW9uIHkoVCl7dmFyIFI9VC1hLEw9VC1kO3JldHVybiBhPT09dm9pZCAwfHxSPj1lfHxSPDB8fHAmJkw+PWZ9ZnVuY3Rpb24gUygpe3ZhciBUPW1zKCk7aWYoeShUKSlyZXR1cm4gcyhUKTt1PXNldFRpbWVvdXQoUyxNKFQpKX1mdW5jdGlvbiBzKFQpe3JldHVybiB1PXZvaWQgMCxPJiZuP20oVCk6KG49aT12b2lkIDAsaCl9ZnVuY3Rpb24gYygpe3UhPT12b2lkIDAmJmNsZWFyVGltZW91dCh1KSxkPTAsbj1hPWk9dT12b2lkIDB9ZnVuY3Rpb24gbCgpe3JldHVybiB1PT09dm9pZCAwP2g6cyhtcygpKX1mdW5jdGlvbiB2KCl7dmFyIFQ9bXMoKSxSPXkoVCk7aWYobj1hcmd1bWVudHMsaT10aGlzLGE9VCxSKXtpZih1PT09dm9pZCAwKXJldHVybiBiKGEpO2lmKHApcmV0dXJuIGNsZWFyVGltZW91dCh1KSx1PXNldFRpbWVvdXQoUyxlKSxtKGEpfXJldHVybiB1PT09dm9pZCAwJiYodT1zZXRUaW1lb3V0KFMsZSkpLGh9cmV0dXJuIHYuY2FuY2VsPWMsdi5mbHVzaD1sLHZ9dmFyIGZ5PXV5LGN5PWZ5LGh5PUNyLGR5PSJFeHBlY3RlZCBhIGZ1bmN0aW9uIjtmdW5jdGlvbiBneShnLGUsdCl7dmFyIG49ITAsaT0hMDtpZih0eXBlb2YgZyE9ImZ1bmN0aW9uIil0aHJvdyBuZXcgVHlwZUVycm9yKGR5KTtyZXR1cm4gaHkodCkmJihuPSJsZWFkaW5nImluIHQ/ISF0LmxlYWRpbmc6bixpPSJ0cmFpbGluZyJpbiB0PyEhdC50cmFpbGluZzppKSxjeShnLGUse2xlYWRpbmc6bixtYXhXYWl0OmUsdHJhaWxpbmc6aX0pfXZhciB2eT1neSx0bD1Wbih2eSk7Y2xhc3MgcHkgZXh0ZW5kcyBRYXtjb25zdHJ1Y3RvcihlKXtzdXBlcihlKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiY29tYmluZVVuaXRUaW1lIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6NjAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImNvbWJpbmVUaW1lcklkIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImVmZmVjdFNlbGVjdE5vZGVEYXRhIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6bmV3IFNldH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJiYXRjaEVyYXNlcldvcmtzIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6bmV3IFNldH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJiYXRjaEVyYXNlclJlbW92ZU5vZGVzIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6bmV3IFNldH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJiYXRjaEVmZmVjdFdvcmsiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp0bCh0PT57dGhpcy52Tm9kZXMuY3VyTm9kZU1hcC5zaXplJiYodGhpcy52Tm9kZXMudXBkYXRlTm9kZXNSZWN0KCksdGhpcy5yZVJlbmRlclNlbGVjdG9yKCkpLHQmJnQoKX0sMTAwLHtsZWFkaW5nOiExfSl9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiYmF0Y2hFcmFzZXJDb21iaW5lIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dGwoKCk9Pntjb25zdCB0PXRoaXMudXBkYXRlQmF0Y2hFcmFzZXJDb21iaW5lTm9kZSh0aGlzLmJhdGNoRXJhc2VyV29ya3MsdGhpcy5iYXRjaEVyYXNlclJlbW92ZU5vZGVzKTt0aGlzLmJhdGNoRXJhc2VyV29ya3MuY2xlYXIoKSx0aGlzLmJhdGNoRXJhc2VyUmVtb3ZlTm9kZXMuY2xlYXIoKSx0Lmxlbmd0aCYmdGhpcy5fcG9zdCh7cmVuZGVyOnR9KX0sMTAwLHtsZWFkaW5nOiExfSl9KX1jb25zdW1lRHJhdyhlLHQpe2NvbnN0e29wOm4sd29ya0lkOml9PWU7aWYobiE9bnVsbCYmbi5sZW5ndGgmJmkpe2NvbnN0IGY9dGhpcy53b3JrU2hhcGVzLmdldChpKTtpZighZilyZXR1cm47Y29uc3QgaD1mLnRvb2xzVHlwZTtpZihoPT09THQuTGFzZXJQZW4pcmV0dXJuO2NvbnN0IHU9Zi5jb25zdW1lKHtkYXRhOmUsaXNGdWxsV29yazohMH0pO3N3aXRjaChoKXtjYXNlIEx0LlNlbGVjdG9yOnUudHlwZT09PVR0LlNlbGVjdCYmKHUuc2VsZWN0SWRzJiZ0LnJ1blJldmVyc2VTZWxlY3RXb3JrKHUuc2VsZWN0SWRzKSx0aGlzLmRyYXdTZWxlY3Rvcih1LCEwKSk7YnJlYWs7Y2FzZSBMdC5FcmFzZXI6dSE9bnVsbCYmdS5yZWN0JiZ0aGlzLmRyYXdFcmFzZXIodSk7YnJlYWs7Y2FzZSBMdC5BcnJvdzpjYXNlIEx0LlN0cmFpZ2h0OmNhc2UgTHQuRWxsaXBzZTpjYXNlIEx0LlJlY3RhbmdsZTpjYXNlIEx0LlN0YXI6Y2FzZSBMdC5Qb2x5Z29uOmNhc2UgTHQuU3BlZWNoQmFsbG9vbjp1JiYodGhpcy5kcmF3Q291bnQrKyx0aGlzLmRyYXdQZW5jaWwodSkpO2JyZWFrO2Nhc2UgTHQuUGVuY2lsOnRoaXMuY29tYmluZVRpbWVySWR8fCh0aGlzLmNvbWJpbmVUaW1lcklkPXNldFRpbWVvdXQoKCk9Pnt0aGlzLmNvbWJpbmVUaW1lcklkPXZvaWQgMCx0aGlzLmRyYXdQZW5jaWxDb21iaW5lKGkpfSxNYXRoLmZsb29yKGYuZ2V0V29ya09wdGlvbnMoKS5zeW5jVW5pdFRpbWV8fHRoaXMuY29tYmluZVVuaXRUaW1lLzIpKSksdSYmKHRoaXMuZHJhd0NvdW50KyssdGhpcy5kcmF3UGVuY2lsKHUpKTticmVha319fWNvbnN1bWVEcmF3QWxsKGUsdCl7dmFyIGY7dGhpcy5jb21iaW5lVGltZXJJZCYmKGNsZWFyVGltZW91dCh0aGlzLmNvbWJpbmVUaW1lcklkKSx0aGlzLmNvbWJpbmVUaW1lcklkPXZvaWQgMCk7Y29uc3R7d29ya0lkOm4sdW5kb1RpY2tlcklkOml9PWU7aWYobil7aSYmc2V0VGltZW91dCgoKT0+e3RoaXMuX3Bvc3Qoe3NwOlt7dHlwZTpUdC5Ob25lLHVuZG9UaWNrZXJJZDppfV19KX0sMCk7Y29uc3QgaD10aGlzLndvcmtTaGFwZXMuZ2V0KG4pO2lmKCFoKXJldHVybjtjb25zdCB1PWgudG9vbHNUeXBlO2lmKHU9PT1MdC5MYXNlclBlbilyZXR1cm47Y29uc3QgYT1oLmNvbnN1bWVBbGwoe2RhdGE6ZX0pLGQ9dGhpcy53b3JrU2hhcGVTdGF0ZS5nZXQobik7c3dpdGNoKHUpe2Nhc2UgTHQuU2VsZWN0b3I6YS5zZWxlY3RJZHMmJnQucnVuUmV2ZXJzZVNlbGVjdFdvcmsoYS5zZWxlY3RJZHMpLHRoaXMuZHJhd1NlbGVjdG9yKGEsITEpLChmPWguc2VsZWN0SWRzKSE9bnVsbCYmZi5sZW5ndGg/aC5jbGVhclRtcFBvaW50cygpOnRoaXMuY2xlYXJXb3JrU2hhcGVOb2RlQ2FjaGUobik7YnJlYWs7Y2FzZSBMdC5FcmFzZXI6YSE9bnVsbCYmYS5yZWN0JiZ0aGlzLmRyYXdFcmFzZXIoYSksaC5jbGVhclRtcFBvaW50cygpO2JyZWFrO2Nhc2UgTHQuQXJyb3c6Y2FzZSBMdC5TdHJhaWdodDpjYXNlIEx0LkVsbGlwc2U6Y2FzZSBMdC5SZWN0YW5nbGU6Y2FzZSBMdC5TdGFyOmNhc2UgTHQuUG9seWdvbjpjYXNlIEx0LlNwZWVjaEJhbGxvb246dGhpcy5kcmF3UGVuY2lsRnVsbChhLGguZ2V0V29ya09wdGlvbnMoKSxkKSx0aGlzLmRyYXdDb3VudD0wLHRoaXMuY2xlYXJXb3JrU2hhcGVOb2RlQ2FjaGUobik7YnJlYWs7Y2FzZSBMdC5QZW5jaWw6YSE9bnVsbCYmYS5yZWN0JiYodGhpcy5kcmF3UGVuY2lsRnVsbChhLGguZ2V0V29ya09wdGlvbnMoKSxkKSx0aGlzLmRyYXdDb3VudD0wKSx0aGlzLmNsZWFyV29ya1NoYXBlTm9kZUNhY2hlKG4pO2JyZWFrfX19Y29uc3VtZUZ1bGwoZSl7dmFyIGYsaDtjb25zdCB0PXRoaXMuc2V0RnVsbFdvcmsoZSksbj1lLm9wcyYmc2koZS5vcHMpLGk9KGY9ZS53b3JrSWQpPT1udWxsP3ZvaWQgMDpmLnRvU3RyaW5nKCk7aWYoaSYmdCl7Y29uc3QgdT0oaD10aGlzLnZOb2Rlcy5nZXQoaSkpPT1udWxsP3ZvaWQgMDpoLnJlY3Q7bGV0IGE9dC5jb25zdW1lU2VydmljZSh7b3A6bixpc0Z1bGxXb3JrOiEwLHJlcGxhY2VJZDppfSk7Y29uc3QgZD0oZT09bnVsbD92b2lkIDA6ZS51cGRhdGVOb2RlT3B0KSYmdC51cGRhdGFPcHRTZXJ2aWNlKGUudXBkYXRlTm9kZU9wdCk7aWYoYT0kdChhLGQpLGEmJmUud2lsbFJlZnJlc2gpe2NvbnN0IEU9W107dSYmRS5wdXNoKHtyZWN0OmEsaXNDbGVhcjohMCxjbGVhckNhbnZhczpCdC5CZyxpc0Z1bGxXb3JrOiEwLHZpZXdJZDp0aGlzLnZpZXdJZH0pLEUucHVzaCh7cmVjdDphLGRyYXdDYW52YXM6QnQuQmcsaXNGdWxsV29yazohMCx2aWV3SWQ6dGhpcy52aWV3SWR9KTtjb25zdCBwPXtyZW5kZXI6RSxzcDplLndpbGxTeW5jU2VydmljZSYmW3tvcHQ6ZS5vcHQsdG9vbHNUeXBlOmUudG9vbHNUeXBlLHR5cGU6VHQuRnVsbFdvcmssd29ya0lkOmUud29ya0lkLG9wczplLm9wcyx1cGRhdGVOb2RlT3B0OmUudXBkYXRlTm9kZU9wdCx1bmRvVGlja2VySWQ6ZS51bmRvVGlja2VySWQsdmlld0lkOnRoaXMudmlld0lkfV18fHZvaWQgMH07dGhpcy5fcG9zdChwKX1lLndvcmtJZCYmdGhpcy53b3JrU2hhcGVzLmRlbGV0ZShlLndvcmtJZCl9fXJlbW92ZVdvcmsoZSl7Y29uc3R7d29ya0lkOnR9PWUsbj10PT1udWxsP3ZvaWQgMDp0LnRvU3RyaW5nKCk7aWYobil7Y29uc3QgaT10aGlzLnJlbW92ZU5vZGUobik7aSYmdGhpcy5fcG9zdCh7cmVuZGVyOlt7cmVjdDppLGlzQ2xlYXI6ITAsaXNGdWxsV29yazohMCxjbGVhckNhbnZhczpCdC5CZyxkcmF3Q2FudmFzOkJ0LkJnLHZpZXdJZDp0aGlzLnZpZXdJZH1dfSl9fXJlbW92ZU5vZGUoZSl7dmFyIGk7dGhpcy53b3JrU2hhcGVzLmhhcyhlKSYmdGhpcy5jbGVhcldvcmtTaGFwZU5vZGVDYWNoZShlKTtsZXQgdDtjb25zdCBuPXRoaXMudk5vZGVzLmdldChlKTtyZXR1cm4gbiYmKHRoaXMuZnVsbExheWVyLmdldEVsZW1lbnRzQnlOYW1lKGUpLmNvbmNhdCgoKGk9dGhpcy5kcmF3TGF5ZXIpPT1udWxsP3ZvaWQgMDppLmdldEVsZW1lbnRzQnlOYW1lKGUpKXx8W10pLmZvckVhY2goZj0+e2YucmVtb3ZlKCl9KSx0PSR0KHQsbi5yZWN0KSx0aGlzLnZOb2Rlcy5kZWxldGUoZSkpLHR9Y2hlY2tUZXh0QWN0aXZlKGUpe3ZhciBuO2NvbnN0e29wOnR9PWU7aWYodCE9bnVsbCYmdC5sZW5ndGgpe2xldCBpO2Zvcihjb25zdCBmIG9mIHRoaXMudk5vZGVzLmN1ck5vZGVNYXAudmFsdWVzKCkpe2NvbnN0e3JlY3Q6aCxuYW1lOnUsdG9vbHNUeXBlOmF9PWYsZD10WzBdKnRoaXMuZnVsbExheWVyLndvcmxkU2NhbGluZ1swXSt0aGlzLmZ1bGxMYXllci53b3JsZFBvc2l0aW9uWzBdLEU9dFsxXSp0aGlzLmZ1bGxMYXllci53b3JsZFNjYWxpbmdbMV0rdGhpcy5mdWxsTGF5ZXIud29ybGRQb3NpdGlvblsxXTtpZihhPT09THQuVGV4dCYmaG0oW2QsRV0saCkpe2k9dTticmVha319aWYoaSl7Y29uc3QgZj10aGlzLndvcmtTaGFwZXMuZ2V0KGllLnNlbGVjdG9ySWQpO2YmJigobj1mLnNlbGVjdElkcykhPW51bGwmJm4uaW5jbHVkZXMoaSkpJiZ0aGlzLmJsdXJTZWxlY3RvcigpLHRoaXMuX3Bvc3Qoe3NwOlt7dHlwZTpUdC5HZXRUZXh0QWN0aXZlLHRvb2xzVHlwZTpMdC5UZXh0LHdvcmtJZDppfV19KX19fWNvbGxvY3RFZmZlY3RTZWxlY3RXb3JrKGUpe2NvbnN0IHQ9dGhpcy53b3JrU2hhcGVzLmdldChpZS5zZWxlY3RvcklkKSx7d29ya0lkOm59PWU7aWYodCYmbiYmdC5zZWxlY3RJZHMmJnQuc2VsZWN0SWRzLmluY2x1ZGVzKG4udG9TdHJpbmcoKSkpe3RoaXMuZWZmZWN0U2VsZWN0Tm9kZURhdGEuYWRkKGUpLHNldFRpbWVvdXQoKCk9Pnt2YXIgaTt0aGlzLnJ1bkVmZmVjdFNlbGVjdFdvcmsoKSwoaT10aGlzLmVmZmVjdFNlbGVjdE5vZGVEYXRhKT09bnVsbHx8aS5jbGVhcigpfSwwKTtyZXR1cm59cmV0dXJuIGV9dXBkYXRlU2VsZWN0b3IoZSl7dmFyIHk7Y29uc3QgdD10aGlzLndvcmtTaGFwZXMuZ2V0KGllLnNlbGVjdG9ySWQpO2lmKCEoKHk9dD09bnVsbD92b2lkIDA6dC5zZWxlY3RJZHMpIT1udWxsJiZ5Lmxlbmd0aCkpcmV0dXJuO2NvbnN0e3VwZGF0ZVNlbGVjdG9yT3B0Om4sd2lsbFJlZnJlc2hTZWxlY3RvcjppLHdpbGxTeW5jU2VydmljZTpmLHdpbGxTZXJpYWxpemVEYXRhOmgsZW1pdEV2ZW50VHlwZTp1LGlzU3luYzphLHRleHRVcGRhdGVGb3JXb2tlcjpkfT1lLEU9bi53b3JrU3RhdGUscD10PT1udWxsP3ZvaWQgMDp0LnVwZGF0ZVNlbGVjdG9yKHt1cGRhdGVTZWxlY3Rvck9wdDpuLHNlbGVjdElkczp0LnNlbGVjdElkcyx2Tm9kZXM6dGhpcy52Tm9kZXMsd2lsbFNlcmlhbGl6ZURhdGE6aCx3b3JrZXI6dGhpc30pLE89cD09bnVsbD92b2lkIDA6cC5zZWxlY3RSZWN0LG09bmV3IE1hcDtpZih0LnNlbGVjdElkcy5mb3JFYWNoKFM9Pntjb25zdCBzPXRoaXMudk5vZGVzLmdldChTKTtpZihzKXtjb25zdHt0b29sc1R5cGU6YyxvcDpsLG9wdDp2fT1zO20uc2V0KFMse29wdDp2LHRvb2xzVHlwZTpjLG9wczoobD09bnVsbD92b2lkIDA6bC5sZW5ndGgpJiZ5cihsKXx8dm9pZCAwfSl9fSksdT09PW9lLlRyYW5zbGF0ZU5vZGUmJkU9PT1jZS5TdGFydClyZXR1cm47Y29uc3QgYj1bXSxNPVtdO2lmKGkpe2IucHVzaCh7aXNDbGVhckFsbDohMCxpc0Z1bGxXb3JrOiExLGNsZWFyQ2FudmFzOkJ0LlNlbGVjdG9yLHZpZXdJZDp0aGlzLnZpZXdJZH0pO2NvbnN0IFM9e3JlY3Q6Tyxpc0Z1bGxXb3JrOiExLGRyYXdDYW52YXM6QnQuU2VsZWN0b3Isdmlld0lkOnRoaXMudmlld0lkfTtuLnRyYW5zbGF0ZSYmdT09PW9lLlRyYW5zbGF0ZU5vZGUmJkU9PT1jZS5Eb2luZyYmKFMudHJhbnNsYXRlPW4udHJhbnNsYXRlKSxiLnB1c2goUyl9aWYoZil7aD8odT09PW9lLlJvdGF0ZU5vZGUmJkU9PT1jZS5Eb25lJiZNLnB1c2goe3R5cGU6VHQuU2VsZWN0LHNlbGVjdElkczp0LnNlbGVjdElkcyxzZWxlY3RSZWN0Ok8sd2lsbFN5bmNTZXJ2aWNlOiEwLGlzU3luYzphfSksdT09PW9lLlNjYWxlTm9kZSYmRT09PWNlLkRvbmUmJk0ucHVzaCh7dHlwZTpUdC5TZWxlY3Qsc2VsZWN0SWRzOnQuc2VsZWN0SWRzLHNlbGVjdFJlY3Q6Tyx3aWxsU3luY1NlcnZpY2U6ITEsaXNTeW5jOmF9KSk6dT09PW9lLlNjYWxlTm9kZSYmRT09PWNlLlN0YXJ0JiZNLnB1c2goe3R5cGU6VHQuU2VsZWN0LHNlbGVjdElkczp0LnNlbGVjdElkcyxzZWxlY3RSZWN0Ok8sY2FudmFzV2lkdGg6dGhpcy5mdWxsTGF5ZXIucGFyZW50LndpZHRoLGNhbnZhc0hlaWdodDp0aGlzLmZ1bGxMYXllci5wYXJlbnQuaGVpZ2h0LHdpbGxTeW5jU2VydmljZTohMX0pO2Zvcihjb25zdFtTLHNdb2YgbS5lbnRyaWVzKCkpZCYmcy50b29sc1R5cGU9PT1MdC5UZXh0P00ucHVzaCh7Li4ucyx3b3JrSWQ6Uyx0eXBlOlR0LlRleHRVcGRhdGV9KTpNLnB1c2goey4uLnMsd29ya0lkOlMsdHlwZTpUdC5VcGRhdGVOb2RlLHVwZGF0ZU5vZGVPcHQ6e3VzZUFuaW1hdGlvbjohMX0saXNTeW5jOmF9KX0oYi5sZW5ndGh8fE0ubGVuZ3RoKSYmdGhpcy5fcG9zdCh7cmVuZGVyOmIsc3A6TX0pfWJsdXJTZWxlY3RvcihlKXt2YXIgaTtjb25zdCB0PXRoaXMud29ya1NoYXBlcy5nZXQoaWUuc2VsZWN0b3JJZCksbj10PT1udWxsP3ZvaWQgMDp0LmJsdXJTZWxlY3RvcigpO2lmKHRoaXMuY2xlYXJXb3JrU2hhcGVOb2RlQ2FjaGUoaWUuc2VsZWN0b3JJZCksKChpPXRoaXMuZHJhd0xheWVyKT09bnVsbD92b2lkIDA6aS5wYXJlbnQpLmNoaWxkcmVuLmZvckVhY2goZj0+e2YubmFtZT09PWllLnNlbGVjdG9ySWQmJmYucmVtb3ZlKCl9KSxuKXtjb25zdCBmPVtuXTtlIT1udWxsJiZlLnVuZG9UaWNrZXJJZCYmZi5wdXNoKHt0eXBlOlR0LlNlbGVjdCxzZWxlY3RJZHM6W10sdW5kb1RpY2tlcklkOmUudW5kb1RpY2tlcklkfSksdGhpcy5fcG9zdCh7cmVuZGVyOihuPT1udWxsP3ZvaWQgMDpuLnJlY3QpJiZbe3JlY3Q6bi5yZWN0LGRyYXdDYW52YXM6QnQuQmcsaXNDbGVhcjohMCxjbGVhckNhbnZhczpCdC5CZyxpc0Z1bGxXb3JrOiEwLHZpZXdJZDp0aGlzLnZpZXdJZH1dLHNwOmZ9KX19cnVuRWZmZWN0V29yayhlKXt0aGlzLmJhdGNoRWZmZWN0V29yayhlKX1yZVJlbmRlclNlbGVjdG9yKCl7dmFyIHQ7Y29uc3QgZT10aGlzLndvcmtTaGFwZXMuZ2V0KGllLnNlbGVjdG9ySWQpO2lmKCh0PWU9PW51bGw/dm9pZCAwOmUuc2VsZWN0SWRzKSE9bnVsbCYmdC5sZW5ndGgmJnRoaXMuZHJhd0xheWVyKXtjb25zdCBuPWUucmVSZW5kZXJTZWxlY3RvcigpO24mJnRoaXMuX3Bvc3Qoe3JlbmRlcjpbe3JlY3Q6bixpc0NsZWFyOiEwLGlzRnVsbFdvcms6ITEsY2xlYXJDYW52YXM6QnQuU2VsZWN0b3IsZHJhd0NhbnZhczpCdC5TZWxlY3Rvcix2aWV3SWQ6dGhpcy52aWV3SWR9XSxzcDpbe3R5cGU6VHQuU2VsZWN0LHNlbGVjdElkczplLnNlbGVjdElkcyxzZWxlY3RSZWN0Om4sd2lsbFN5bmNTZXJ2aWNlOiExLHZpZXdJZDp0aGlzLnZpZXdJZH1dfSl9fXVwZGF0ZUZ1bGxTZWxlY3RXb3JrKGUpe3ZhciBpLGYsaCx1LGEsZCxFO2NvbnN0IHQ9dGhpcy53b3JrU2hhcGVzLmdldChpZS5zZWxlY3RvcklkKSx7c2VsZWN0SWRzOm59PWU7aWYoIShuIT1udWxsJiZuLmxlbmd0aCkpe3RoaXMuYmx1clNlbGVjdG9yKGUpO3JldHVybn1pZighdCl7dGhpcy5zZXRGdWxsV29yayhlKSx0aGlzLnVwZGF0ZUZ1bGxTZWxlY3RXb3JrKGUpO3JldHVybn1pZih0JiYobiE9bnVsbCYmbi5sZW5ndGgpKXtjb25zdHtiZ1JlY3Q6cCxzZWxlY3RSZWN0Ok99PXQudXBkYXRlU2VsZWN0SWRzKG4pLG09e3JlbmRlcjpbXSxzcDpbXX07cCYmKChpPW0ucmVuZGVyKT09bnVsbHx8aS5wdXNoKHtyZWN0OnAsaXNDbGVhcjohMCxpc0Z1bGxXb3JrOiEwLGNsZWFyQ2FudmFzOkJ0LkJnLGRyYXdDYW52YXM6QnQuQmcsdmlld0lkOnRoaXMudmlld0lkfSkpLChmPW0ucmVuZGVyKT09bnVsbHx8Zi5wdXNoKHtyZWN0OnB8fE8saXNDbGVhcjohMCxpc0Z1bGxXb3JrOiExLGNsZWFyQ2FudmFzOkJ0LlNlbGVjdG9yLGRyYXdDYW52YXM6QnQuU2VsZWN0b3Isdmlld0lkOnRoaXMudmlld0lkfSksKEU9bS5zcCk9PW51bGx8fEUucHVzaCh7Li4uZSxzZWxlY3RvckNvbG9yOihoPWUub3B0KT09bnVsbD92b2lkIDA6aC5zdHJva2VDb2xvcixzdHJva2VDb2xvcjoodT1lLm9wdCk9PW51bGw/dm9pZCAwOnUuc3Ryb2tlQ29sb3IsZmlsbENvbG9yOihhPWUub3B0KT09bnVsbD92b2lkIDA6YS5maWxsQ29sb3IsdGV4dE9wdDooZD1lLm9wdCk9PW51bGw/dm9pZCAwOmQudGV4dE9wdCxjYW5UZXh0RWRpdDp0LmNhblRleHRFZGl0LGNhblJvdGF0ZTp0LmNhblJvdGF0ZSxzY2FsZVR5cGU6dC5zY2FsZVR5cGUsdHlwZTpUdC5TZWxlY3Qsc2VsZWN0UmVjdDpwfHxPLHdpbGxTeW5jU2VydmljZTohMX0pLHRoaXMuX3Bvc3QobSl9fWRlc3Ryb3koKXtzdXBlci5kZXN0cm95KCksdGhpcy5lZmZlY3RTZWxlY3ROb2RlRGF0YS5jbGVhcigpLHRoaXMuYmF0Y2hFcmFzZXJXb3Jrcy5jbGVhcigpLHRoaXMuYmF0Y2hFcmFzZXJSZW1vdmVOb2Rlcy5jbGVhcigpfWRyYXdQZW5jaWxDb21iaW5lKGUpe3ZhciBuLGk7Y29uc3QgdD0obj10aGlzLndvcmtTaGFwZXMuZ2V0KGUpKT09bnVsbD92b2lkIDA6bi5jb21iaW5lQ29uc3VtZSgpO2lmKHQpe2NvbnN0IGY9e3JlbmRlcjpbXSxkcmF3Q291bnQ6dGhpcy5kcmF3Q291bnR9OyhpPWYucmVuZGVyKT09bnVsbHx8aS5wdXNoKHtyZWN0OnQ9PW51bGw/dm9pZCAwOnQucmVjdCxpc0NsZWFyOiEwLGRyYXdDYW52YXM6QnQuRmxvYXQsY2xlYXJDYW52YXM6QnQuRmxvYXQsaXNGdWxsV29yazohMSx2aWV3SWQ6dGhpcy52aWV3SWR9KSx0aGlzLl9wb3N0KGYpfX1kcmF3U2VsZWN0b3IoZSx0KXt2YXIgaSxmLGg7Y29uc3Qgbj17cmVuZGVyOltdLHNwOltlXX07KGk9ZS5zZWxlY3RJZHMpIT1udWxsJiZpLmxlbmd0aCYmIXQmJigoZj1uLnJlbmRlcik9PW51bGx8fGYucHVzaCh7cmVjdDplLnNlbGVjdFJlY3QsZHJhd0NhbnZhczpCdC5TZWxlY3Rvcixpc0NsZWFyOiEwLGNsZWFyQ2FudmFzOkJ0LlNlbGVjdG9yLGlzRnVsbFdvcms6ITEsdmlld0lkOnRoaXMudmlld0lkfSx7cmVjdDplLnJlY3QsaXNDbGVhcjohMCxjbGVhckNhbnZhczpCdC5GbG9hdCxpc0Z1bGxXb3JrOiExLHZpZXdJZDp0aGlzLnZpZXdJZH0se3JlY3Q6ZS5yZWN0LGRyYXdDYW52YXM6QnQuQmcsaXNDbGVhcjohMCxjbGVhckNhbnZhczpCdC5CZyxpc0Z1bGxXb3JrOiEwLHZpZXdJZDp0aGlzLnZpZXdJZH0pKSx0JiYoKGg9bi5yZW5kZXIpPT1udWxsfHxoLnB1c2goe3JlY3Q6ZS5yZWN0LGRyYXdDYW52YXM6QnQuRmxvYXQsaXNDbGVhcjohMCxjbGVhckNhbnZhczpCdC5GbG9hdCxpc0Z1bGxXb3JrOiExLHZpZXdJZDp0aGlzLnZpZXdJZH0se3JlY3Q6ZS5yZWN0LGRyYXdDYW52YXM6QnQuQmcsaXNDbGVhcjohMCxjbGVhckNhbnZhczpCdC5CZyxpc0Z1bGxXb3JrOiEwLHZpZXdJZDp0aGlzLnZpZXdJZH0pKSx0aGlzLl9wb3N0KG4pfWFzeW5jIGRyYXdFcmFzZXIoZSl7dmFyIG4saTtjb25zdCB0PVtdO2lmKChuPWUubmV3V29ya0RhdGFzKSE9bnVsbCYmbi5zaXplKXtmb3IoY29uc3QgZiBvZiBlLm5ld1dvcmtEYXRhcy52YWx1ZXMoKSl7Y29uc3QgaD1mLndvcmtJZC50b1N0cmluZygpO3RoaXMuYmF0Y2hFcmFzZXJXb3Jrcy5hZGQoaCksdC5wdXNoKHt0eXBlOlR0LkZ1bGxXb3JrLHdvcmtJZDpoLG9wczp5cihmLm9wKSxvcHQ6Zi5vcHQsdG9vbHNUeXBlOmYudG9vbHNUeXBlLHVwZGF0ZU5vZGVPcHQ6e3VzZUFuaW1hdGlvbjohMX19KX1kZWxldGUgZS5uZXdXb3JrRGF0YXN9KGk9ZS5yZW1vdmVJZHMpPT1udWxsfHxpLmZvckVhY2goZj0+e3RoaXMuYmF0Y2hFcmFzZXJSZW1vdmVOb2Rlcy5hZGQoZil9KSx0LnB1c2goZSksdGhpcy5fcG9zdCh7c3A6dH0pLHRoaXMuYmF0Y2hFcmFzZXJDb21iaW5lKCl9ZHJhd1BlbmNpbChlKXt0aGlzLl9wb3N0KHtkcmF3Q291bnQ6dGhpcy5kcmF3Q291bnQsc3A6KGU9PW51bGw/dm9pZCAwOmUub3ApJiZbZV19KX1kcmF3UGVuY2lsRnVsbChlLHQsbil7dmFyIGY7Y29uc3QgaT17ZHJhd0NvdW50OjEvMCxyZW5kZXI6W3tyZWN0OmUucmVjdCxkcmF3Q2FudmFzOkJ0LkJnLGlzQ2xlYXI6KG49PW51bGw/dm9pZCAwOm4ud2lsbENsZWFyKXx8KHQ9PW51bGw/dm9pZCAwOnQuaXNPcGFjaXR5KSxjbGVhckNhbnZhczpCdC5CZyxpc0Z1bGxXb3JrOiEwLHZpZXdJZDp0aGlzLnZpZXdJZH1dLHNwOltlXX07KGY9aS5yZW5kZXIpPT1udWxsfHxmLnB1c2goe2lzQ2xlYXJBbGw6ITAsY2xlYXJDYW52YXM6QnQuRmxvYXQsaXNGdWxsV29yazohMSx2aWV3SWQ6dGhpcy52aWV3SWR9KSx0aGlzLl9wb3N0KGkpfXVwZGF0ZUJhdGNoRXJhc2VyQ29tYmluZU5vZGUoZSx0KXtjb25zdCBuPVtdO2xldCBpO2Zvcihjb25zdCBmIG9mIHQua2V5cygpKXRoaXMuZnVsbExheWVyLmdldEVsZW1lbnRzQnlOYW1lKGYpLmZvckVhY2goaD0+e2NvbnN0IHU9aC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtpPSR0KGkse3g6dS54LWxyLlNhZmVCb3JkZXJQYWRkaW5nLHk6dS55LWxyLlNhZmVCb3JkZXJQYWRkaW5nLHc6dS53aWR0aCtsci5TYWZlQm9yZGVyUGFkZGluZyxoOnUuaGVpZ2h0K2xyLlNhZmVCb3JkZXJQYWRkaW5nfSksaC5yZW1vdmUoKX0pO3JldHVybiBlLmZvckVhY2goZj0+e2NvbnN0IGg9dGhpcy52Tm9kZXMuZ2V0KGYpO2lmKGgpaWYodGhpcy5mdWxsTGF5ZXIuZ2V0RWxlbWVudHNCeU5hbWUoZilbMF0paT0kdChpLGgucmVjdCk7ZWxzZXtjb25zdCBhPXRoaXMuc2V0RnVsbFdvcmsoey4uLmgsd29ya0lkOmZ9KSxkPWEmJmEuY29uc3VtZVNlcnZpY2Uoe29wOmgub3AsaXNGdWxsV29yazohMH0pO2QmJihoLnJlY3Q9ZCxpPSR0KGksZCkpfX0pLGkmJm4ucHVzaCh7cmVjdDppLGlzQ2xlYXI6ITAsaXNGdWxsV29yazohMCxjbGVhckNhbnZhczpCdC5CZyxkcmF3Q2FudmFzOkJ0LkJnLHZpZXdJZDp0aGlzLnZpZXdJZH0pLG59cnVuRWZmZWN0U2VsZWN0V29yaygpe3ZhciBlO2Zvcihjb25zdCB0IG9mIHRoaXMuZWZmZWN0U2VsZWN0Tm9kZURhdGEudmFsdWVzKCkpe2NvbnN0IG49dGhpcy5zZXRGdWxsV29yayh0KSxpPXQub3BzJiZzaSh0Lm9wcyk7biYmKG4uY29uc3VtZVNlcnZpY2Uoe29wOmksaXNGdWxsV29yazohMSxyZXBsYWNlSWQ6KGU9bi5nZXRXb3JrSWQoKSk9PW51bGw/dm9pZCAwOmUudG9TdHJpbmcoKX0pLHQhPW51bGwmJnQudXBkYXRlTm9kZU9wdCYmbi51cGRhdGFPcHRTZXJ2aWNlKHQudXBkYXRlTm9kZU9wdCksdC53b3JrSWQmJnRoaXMud29ya1NoYXBlcy5kZWxldGUodC53b3JrSWQpKX10aGlzLnJlUmVuZGVyU2VsZWN0b3IoKX19Y2xhc3MgbXl7Y29uc3RydWN0b3IoZSl7T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInZpZXdJZCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ2Tm9kZXMiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiZnVsbExheWVyIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImRyYXdMYXllciIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ3b3JrU2hhcGVzIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6bmV3IE1hcH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJhbmltYXRpb25JZCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzZWxlY3RvcldvcmtTaGFwZXMiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpuZXcgTWFwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIndpbGxSdW5FZmZlY3RTZWxlY3RvcklkcyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOm5ldyBTZXR9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywicnVuRWZmZWN0SWQiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywibm9BbmltYXRpb25SZWN0Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInBvc3QiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSx0aGlzLnZpZXdJZD1lLnZpZXdJZCx0aGlzLnZOb2Rlcz1lLnZOb2Rlcyx0aGlzLmZ1bGxMYXllcj1lLmZ1bGxMYXllcix0aGlzLmRyYXdMYXllcj1lLmRyYXdMYXllcix0aGlzLnBvc3Q9ZS5wb3N0fWRlc3Ryb3koKXt0aGlzLndvcmtTaGFwZXMuY2xlYXIoKSx0aGlzLnNlbGVjdG9yV29ya1NoYXBlcy5jbGVhcigpLHRoaXMud2lsbFJ1bkVmZmVjdFNlbGVjdG9ySWRzLmNsZWFyKCl9Y29uc3VtZURyYXcoZSl7dGhpcy5hY3RpdmVXb3JrU2hhcGUoZSksdGhpcy5ydW5BbmltYXRpb24oKX1jb25zdW1lRnVsbChlKXt0aGlzLmFjdGl2ZVdvcmtTaGFwZShlKSx0aGlzLnJ1bkFuaW1hdGlvbigpfWNsZWFyQWxsV29ya1NoYXBlc0NhY2hlKCl7dGhpcy53b3JrU2hhcGVzLmZvckVhY2goKGUsdCk9PntlLnRvb2xzVHlwZT09PUx0Lkxhc2VyUGVuP3NldFRpbWVvdXQoKCk9Pnt0aGlzLndvcmtTaGFwZXMuZGVsZXRlKHQpfSwyZTMpOnRoaXMud29ya1NoYXBlcy5kZWxldGUodCl9KX1ydW5TZWxlY3RXb3JrKGUpe3RoaXMuYWN0aXZlU2VsZWN0b3JTaGFwZShlKTtjb25zdHt3b3JrSWQ6dH09ZSxuPXQ9PW51bGw/dm9pZCAwOnQudG9TdHJpbmcoKTtuJiZ0aGlzLndpbGxSdW5FZmZlY3RTZWxlY3Rvcklkcy5hZGQobiksdGhpcy5ydW5FZmZlY3QoKX1zZXROb2RlS2V5KGUsdCxuKXtyZXR1cm4gZS50b29sc1R5cGU9dCxlLm5vZGU9WmEoe3Rvb2xzVHlwZTp0LHRvb2xzT3B0Om4sdk5vZGVzOnRoaXMudk5vZGVzLGZ1bGxMYXllcjp0aGlzLmZ1bGxMYXllcixkcmF3TGF5ZXI6dGhpcy5kcmF3TGF5ZXJ9KSxlfXJ1blJldmVyc2VTZWxlY3RXb3JrKGUpe2UuZm9yRWFjaCh0PT57dGhpcy5zZWxlY3RvcldvcmtTaGFwZXMuZm9yRWFjaCgobixpKT0+e3ZhciBmO2lmKChmPW4uc2VsZWN0SWRzKSE9bnVsbCYmZi5sZW5ndGgpe2NvbnN0IGg9bi5zZWxlY3RJZHMuaW5kZXhPZih0KTtoPi0xJiYobi5zZWxlY3RJZHMuc3BsaWNlKGgsMSksdGhpcy53aWxsUnVuRWZmZWN0U2VsZWN0b3JJZHMuYWRkKGkpKX19KX0pLHRoaXMud2lsbFJ1bkVmZmVjdFNlbGVjdG9ySWRzLnNpemUmJnRoaXMucnVuRWZmZWN0KCl9cmVtb3ZlV29yayhlKXtjb25zdHt3b3JrSWQ6dH09ZSxuPXQ9PW51bGw/dm9pZCAwOnQudG9TdHJpbmcoKTtpZihuKXtjb25zdCBpPXRoaXMud29ya1NoYXBlcy5nZXQobik7aWYoaSl7dGhpcy53b3JrU2hhcGVzLmRlbGV0ZShuKSx0aGlzLnJlbW92ZU5vZGUobixlLGk9PW51bGw/dm9pZCAwOmkudG90YWxSZWN0LCExKTtyZXR1cm59dGhpcy5yZW1vdmVOb2RlKG4sZSl9fXJlbW92ZVNlbGVjdFdvcmsoZSl7Y29uc3R7d29ya0lkOnR9PWUsbj10PT1udWxsP3ZvaWQgMDp0LnRvU3RyaW5nKCk7biYmKHRoaXMuYWN0aXZlU2VsZWN0b3JTaGFwZShlKSx0aGlzLndpbGxSdW5FZmZlY3RTZWxlY3Rvcklkcy5hZGQobikpLHRoaXMucnVuRWZmZWN0KCl9cmVtb3ZlTm9kZShlLHQsbixpPSEwKXt2YXIgZDtjb25zdCBmPXRoaXMuZnVsbExheWVyLmdldEVsZW1lbnRzQnlOYW1lKGUpLmNvbmNhdCh0aGlzLmRyYXdMYXllci5nZXRFbGVtZW50c0J5TmFtZShlKSk7ZS5pbmRleE9mKGllLnNlbGVjdG9ySWQpPi0xJiZ0aGlzLnJlbW92ZVNlbGVjdFdvcmsodCk7Y29uc3QgaD1bXTtsZXQgdT1uO2NvbnN0IGE9KGQ9dGhpcy52Tm9kZXMuZ2V0KGUpKT09bnVsbD92b2lkIDA6ZC5yZWN0O2EmJih1PSR0KGEsdSkpLGYuZm9yRWFjaChFPT57aC5wdXNoKEUpfSksaC5sZW5ndGgmJmguZm9yRWFjaChFPT5FLnJlbW92ZSgpKSx1JiYodGhpcy5wb3N0KHtyZW5kZXI6W3tyZWN0OmxuKHUpLGlzQ2xlYXI6ITAsaXNGdWxsV29yazppLGNsZWFyQ2FudmFzOmk/QnQuQmc6QnQuRmxvYXQsZHJhd0NhbnZhczppP0J0LkJnOkJ0LkZsb2F0LHZpZXdJZDp0aGlzLnZpZXdJZH1dfSksdGhpcy52Tm9kZXMuZGVsZXRlKGUpKX1hY3RpdmVXb3JrU2hhcGUoZSl7dmFyIE8sbSxiLE07Y29uc3R7d29ya0lkOnQsb3B0Om4sdG9vbHNUeXBlOmksdHlwZTpmLHVwZGF0ZU5vZGVPcHQ6aCxvcHM6dSxvcDphLHVzZUFuaW1hdGlvbjpkfT1lO2lmKCF0KXJldHVybjtjb25zdCBFPXQudG9TdHJpbmcoKTtpZighKChPPXRoaXMud29ya1NoYXBlcykhPW51bGwmJk8uaGFzKEUpKSl7bGV0IHk9e3Rvb2xzVHlwZTppLGFuaW1hdGlvbldvcmtEYXRhOmF8fFtdLGFuaW1hdGlvbkluZGV4OjAsdHlwZTpmLHVwZGF0ZU5vZGVPcHQ6aCxvcHM6dSx1c2VBbmltYXRpb246dHlwZW9mIGQ8InUiP2Q6dHlwZW9mKGg9PW51bGw/dm9pZCAwOmgudXNlQW5pbWF0aW9uKTwidSI/aD09bnVsbD92b2lkIDA6aC51c2VBbmltYXRpb246ITAsb2xkUmVjdDoobT10aGlzLnZOb2Rlcy5nZXQoRSkpPT1udWxsP3ZvaWQgMDptLnJlY3R9O2kmJm4mJih5PXRoaXMuc2V0Tm9kZUtleSh5LGksbikpLChiPXRoaXMud29ya1NoYXBlcyk9PW51bGx8fGIuc2V0KEUseSl9Y29uc3QgcD0oTT10aGlzLndvcmtTaGFwZXMpPT1udWxsP3ZvaWQgMDpNLmdldChFKTtmJiYocC50eXBlPWYpLHUmJihwLmFuaW1hdGlvbldvcmtEYXRhPXNpKHUpLHAub3BzPXUpLGgmJihwLnVwZGF0ZU5vZGVPcHQ9aCksYSYmKHAuYW5pbWF0aW9uV29ya0RhdGE9YSkscC5ub2RlJiZwLm5vZGUuZ2V0V29ya0lkKCkhPT1FJiZwLm5vZGUuc2V0V29ya0lkKEUpLHAudG9vbHNUeXBlIT09aSYmaSYmbiYmdGhpcy5zZXROb2RlS2V5KHAsaSxuKX1hbmltYXRpb25EcmF3KCl7dmFyIGEsZCxFLHAsTzt0aGlzLmFuaW1hdGlvbklkPXZvaWQgMDtsZXQgZT0hMTtjb25zdCB0PW5ldyBNYXAsbj1bXSxpPVtdLGY9W10saD1bXTt0aGlzLndvcmtTaGFwZXMuZm9yRWFjaCgobSxiKT0+e3ZhciBNLHksUyxzLGMsbCx2LFQsUixMLE4sQSx3LEIsRCxJLGosVixKLF8sc3QsRyxZO3N3aXRjaChtLnRvb2xzVHlwZSl7Y2FzZSBMdC5UZXh0OntpZihtLm5vZGUpe2NvbnN0IHJ0PW0ub2xkUmVjdCxvdD0oTT1tLm5vZGUpPT1udWxsP3ZvaWQgMDpNLmNvbnN1bWVTZXJ2aWNlKHtvcDptLmFuaW1hdGlvbldvcmtEYXRhfHxbXSxpc0Z1bGxXb3JrOiEwfSk7dGhpcy5zZWxlY3RvcldvcmtTaGFwZXMuZm9yRWFjaCgoYXQsaHQpPT57dmFyIGl0OyhpdD1hdC5zZWxlY3RJZHMpIT1udWxsJiZpdC5pbmNsdWRlcyhiKSYmKHRoaXMud2lsbFJ1bkVmZmVjdFNlbGVjdG9ySWRzLmFkZChodCksdGhpcy5ub0FuaW1hdGlvblJlY3Q9JHQodGhpcy5ub0FuaW1hdGlvblJlY3QscnQpLHRoaXMubm9BbmltYXRpb25SZWN0PSR0KHRoaXMubm9BbmltYXRpb25SZWN0LG90KSx0aGlzLnJ1bkVmZmVjdCgpKX0pLCh5PW0ubm9kZSk9PW51bGx8fHkuY2xlYXJUbXBQb2ludHMoKSx0aGlzLndvcmtTaGFwZXMuZGVsZXRlKGIpfWJyZWFrfWNhc2UgTHQuQXJyb3c6Y2FzZSBMdC5TdHJhaWdodDpjYXNlIEx0LlJlY3RhbmdsZTpjYXNlIEx0LkVsbGlwc2U6Y2FzZSBMdC5TdGFyOmNhc2UgTHQuUG9seWdvbjpjYXNlIEx0LlNwZWVjaEJhbGxvb246e2NvbnN0IHJ0PSEhbS5vcHM7aWYoKFM9bS5hbmltYXRpb25Xb3JrRGF0YSkhPW51bGwmJlMubGVuZ3RoKXtjb25zdCBvdD1tLm9sZFJlY3QsYXQ9bS5ub2RlLm9sZFJlY3Q7b3QmJmYucHVzaCh7cmVjdDpvdCxpc0NsZWFyOiEwLGNsZWFyQ2FudmFzOkJ0LkJnLHZpZXdJZDp0aGlzLnZpZXdJZH0pLGF0JiZoLnB1c2goe3JlY3Q6YXQsaXNDbGVhcjohMCxjbGVhckNhbnZhczpCdC5GbG9hdCx2aWV3SWQ6dGhpcy52aWV3SWR9KTtjb25zdCBodD0ocz1tLm5vZGUpPT1udWxsP3ZvaWQgMDpzLmNvbnN1bWVTZXJ2aWNlKHtvcDptLmFuaW1hdGlvbldvcmtEYXRhLGlzRnVsbFdvcms6cnR9KSxpdD17d29ya1N0YXRlOm90P20ub3BzP2NlLkRvbmU6Y2UuRG9pbmc6Y2UuU3RhcnQsb3A6bS5hbmltYXRpb25Xb3JrRGF0YS5maWx0ZXIoKE10LE90KT0+e2lmKE90JTMhPT0yKXJldHVybiEwfSkuc2xpY2UoLTIpfTt0LnNldChiLGl0KSxydD8odGhpcy5zZWxlY3RvcldvcmtTaGFwZXMuZm9yRWFjaCgoTXQsT3QpPT57dmFyIFU7KFU9TXQuc2VsZWN0SWRzKSE9bnVsbCYmVS5pbmNsdWRlcyhiKSYmKHRoaXMud2lsbFJ1bkVmZmVjdFNlbGVjdG9ySWRzLmFkZChPdCksdGhpcy5ub0FuaW1hdGlvblJlY3Q9JHQodGhpcy5ub0FuaW1hdGlvblJlY3Qsb3QpLHRoaXMubm9BbmltYXRpb25SZWN0PSR0KHRoaXMubm9BbmltYXRpb25SZWN0LGF0KSx0aGlzLm5vQW5pbWF0aW9uUmVjdD0kdCh0aGlzLm5vQW5pbWF0aW9uUmVjdCxodCksdGhpcy5ydW5FZmZlY3QoKSl9KSwoYz1tLm5vZGUpPT1udWxsfHxjLmNsZWFyVG1wUG9pbnRzKCksdGhpcy53b3JrU2hhcGVzLmRlbGV0ZShiKSxuLnB1c2goe3JlY3Q6aHQsZHJhd0NhbnZhczpCdC5CZyxpc0Z1bGxXb3JrOnJ0LHZpZXdJZDp0aGlzLnZpZXdJZH0pKTppLnB1c2goe3JlY3Q6aHQsZHJhd0NhbnZhczpCdC5GbG9hdCxpc0Z1bGxXb3JrOnJ0LHZpZXdJZDp0aGlzLnZpZXdJZH0pLG0uYW5pbWF0aW9uV29ya0RhdGEubGVuZ3RoPTB9YnJlYWt9Y2FzZSBMdC5QZW5jaWw6e2lmKCFtLnVzZUFuaW1hdGlvbiYmbS5vcHMpe2xldCBydD0obD1tLm5vZGUpPT1udWxsP3ZvaWQgMDpsLmNvbnN1bWVTZXJ2aWNlKHtvcDptLmFuaW1hdGlvbldvcmtEYXRhfHxbXSxpc0Z1bGxXb3JrOiEwLHJlcGxhY2VJZDpifSk7Y29uc3Qgb3Q9KHY9bS5ub2RlKT09bnVsbD92b2lkIDA6di51cGRhdGFPcHRTZXJ2aWNlKG0udXBkYXRlTm9kZU9wdCk7cnQ9JHQocnQsb3QpLGYucHVzaCh7cmVjdDokdChtLm9sZFJlY3QscnQpLGNsZWFyQ2FudmFzOkJ0LkJnLHZpZXdJZDp0aGlzLnZpZXdJZH0pLG4ucHVzaCh7cmVjdDokdChtLm9sZFJlY3QscnQpLGRyYXdDYW52YXM6QnQuQmcsdmlld0lkOnRoaXMudmlld0lkfSksdGhpcy5zZWxlY3RvcldvcmtTaGFwZXMuZm9yRWFjaCgoYXQsaHQpPT57dmFyIGl0OyhpdD1hdC5zZWxlY3RJZHMpIT1udWxsJiZpdC5pbmNsdWRlcyhiKSYmKHRoaXMud2lsbFJ1bkVmZmVjdFNlbGVjdG9ySWRzLmFkZChodCksdGhpcy5ub0FuaW1hdGlvblJlY3Q9JHQodGhpcy5ub0FuaW1hdGlvblJlY3QscnQpLHRoaXMucnVuRWZmZWN0KCkpfSksKFQ9bS5ub2RlKT09bnVsbHx8VC5jbGVhclRtcFBvaW50cygpLHRoaXMud29ya1NoYXBlcy5kZWxldGUoYil9ZWxzZSBpZihtLnVzZUFuaW1hdGlvbil7Y29uc3Qgb3Q9dGhpcy5jb21wdXROZXh0QW5pbWF0aW9uSW5kZXgobSwzKSxhdD1NYXRoLm1heCgwLChtLmFuaW1hdGlvbkluZGV4fHwwKS0zKSxodD0obS5hbmltYXRpb25Xb3JrRGF0YXx8W10pLnNsaWNlKGF0LG90KTtpZihtLmlzRGVsKW0uaXNEZWwmJigoRD1tLm5vZGUpPT1udWxsfHxELmNsZWFyVG1wUG9pbnRzKCksdGhpcy53b3JrU2hhcGVzLmRlbGV0ZShiKSk7ZWxzZXtpZigobS5hbmltYXRpb25JbmRleHx8MCk8b3Qpe2NvbnN0IGl0PShMPW0ubm9kZSk9PW51bGw/dm9pZCAwOkwuY29uc3VtZVNlcnZpY2Uoe29wOmh0LGlzRnVsbFdvcms6ITEscmVwbGFjZUlkOihSPW0ubm9kZS5nZXRXb3JrSWQoKSk9PW51bGw/dm9pZCAwOlIudG9TdHJpbmcoKX0pO2kucHVzaCh7cmVjdDppdCxkcmF3Q2FudmFzOkJ0LkZsb2F0LHZpZXdJZDp0aGlzLnZpZXdJZH0pLG0uYW5pbWF0aW9uSW5kZXg9b3R9ZWxzZSBpZihtLm9wcyl7Y29uc3QgaXQ9KEE9bS5ub2RlKT09bnVsbD92b2lkIDA6QS5jb25zdW1lU2VydmljZSh7b3A6bS5hbmltYXRpb25Xb3JrRGF0YXx8W10saXNGdWxsV29yazohMCxyZXBsYWNlSWQ6KE49bS5ub2RlLmdldFdvcmtJZCgpKT09bnVsbD92b2lkIDA6Ti50b1N0cmluZygpfSk7bS5pc0RlbD0hMCxoLnB1c2goe3JlY3Q6aXQsY2xlYXJDYW52YXM6QnQuRmxvYXQsdmlld0lkOnRoaXMudmlld0lkfSksKHc9bS5ub2RlKSE9bnVsbCYmdy5nZXRXb3JrT3B0aW9ucygpLmlzT3BhY2l0eSYmZi5wdXNoKHtyZWN0Oml0LGNsZWFyQ2FudmFzOkJ0LkJnLHZpZXdJZDp0aGlzLnZpZXdJZH0pLG4ucHVzaCh7cmVjdDppdCxkcmF3Q2FudmFzOkJ0LkJnLHZpZXdJZDp0aGlzLnZpZXdJZH0pLHRoaXMudk5vZGVzLnNldEluZm8oYix7b3A6bS5hbmltYXRpb25Xb3JrRGF0YSxvcHQ6KEI9bS5ub2RlKT09bnVsbD92b2lkIDA6Qi5nZXRXb3JrT3B0aW9ucygpLHRvb2xzVHlwZTptLnRvb2xzVHlwZSxyZWN0Oml0fSl9ZT0hMH1odC5sZW5ndGgmJnQuc2V0KGIse3dvcmtTdGF0ZTphdD09PTA/Y2UuU3RhcnQ6b3Q9PT0oKEk9bS5hbmltYXRpb25Xb3JrRGF0YSk9PW51bGw/dm9pZCAwOkkubGVuZ3RoKT9jZS5Eb25lOmNlLkRvaW5nLG9wOmh0LmZpbHRlcigoaXQsTXQpPT57aWYoTXQlMyE9PTIpcmV0dXJuITB9KS5zbGljZSgtMil9KTticmVha31icmVha31jYXNlIEx0Lkxhc2VyUGVuOntjb25zdCBvdD10aGlzLmNvbXB1dE5leHRBbmltYXRpb25JbmRleChtLDIpLGF0PU1hdGgubWF4KDAsKG0uYW5pbWF0aW9uSW5kZXh8fDApLTIpLGh0PShtLmFuaW1hdGlvbldvcmtEYXRhfHxbXSkuc2xpY2UoYXQsb3QpO2lmKG0uaXNEZWwpe2lmKG0uaXNEZWwpe2NvbnN0IGl0PShzdD1tLm5vZGUpPT1udWxsP3ZvaWQgMDpzdC5jb25zdW1lU2VydmljZSh7b3A6W10saXNGdWxsV29yazohMX0pO20udG90YWxSZWN0PSR0KG0udG90YWxSZWN0LGl0KSxoLnB1c2goe3JlY3Q6bS50b3RhbFJlY3QsY2xlYXJDYW52YXM6QnQuRmxvYXQsdmlld0lkOnRoaXMudmlld0lkfSksaS5wdXNoKHtyZWN0Om0udG90YWxSZWN0LGRyYXdDYW52YXM6QnQuRmxvYXQsdmlld0lkOnRoaXMudmlld0lkfSksKEc9bS5ub2RlKT09bnVsbHx8Ry5jbGVhclRtcFBvaW50cygpLHRoaXMud29ya1NoYXBlcy5kZWxldGUoYil9fWVsc2V7aWYoKG0uYW5pbWF0aW9uSW5kZXh8fDApPG90KXtjb25zdCBpdD0oVj1tLm5vZGUpPT1udWxsP3ZvaWQgMDpWLmNvbnN1bWVTZXJ2aWNlKHtvcDpodCxpc0Z1bGxXb3JrOiExLHJlcGxhY2VJZDooaj1tLm5vZGUuZ2V0V29ya0lkKCkpPT1udWxsP3ZvaWQgMDpqLnRvU3RyaW5nKCl9KTttLnRvdGFsUmVjdD0kdChtLnRvdGFsUmVjdCxpdCksbS50aW1lciYmKGNsZWFyVGltZW91dChtLnRpbWVyKSxtLnRpbWVyPXZvaWQgMCksbS5hbmltYXRpb25JbmRleD1vdH1lbHNle20udGltZXJ8fChtLnRpbWVyPXNldFRpbWVvdXQoKCk9PnttLnRpbWVyPXZvaWQgMCxtLmlzRGVsPSEwLHRoaXMucnVuQW5pbWF0aW9uKCl9LCgoSj1tLm5vZGUpPT1udWxsP3ZvaWQgMDpKLmdldFdvcmtPcHRpb25zKCkpLmR1cmF0aW9uKjFlMysxMDApKTtjb25zdCBpdD0oXz1tLm5vZGUpPT1udWxsP3ZvaWQgMDpfLmNvbnN1bWVTZXJ2aWNlKHtvcDpbXSxpc0Z1bGxXb3JrOiExfSk7bS50b3RhbFJlY3Q9JHQobS50b3RhbFJlY3QsaXQpfWgucHVzaCh7cmVjdDptLnRvdGFsUmVjdCxjbGVhckNhbnZhczpCdC5GbG9hdCx2aWV3SWQ6dGhpcy52aWV3SWR9KSxpLnB1c2goe3JlY3Q6bS50b3RhbFJlY3QsZHJhd0NhbnZhczpCdC5GbG9hdCx2aWV3SWQ6dGhpcy52aWV3SWR9KSxlPSEwfWh0Lmxlbmd0aCYmdC5zZXQoYix7d29ya1N0YXRlOmF0PT09MD9jZS5TdGFydDpvdD09PSgoWT1tLmFuaW1hdGlvbldvcmtEYXRhKT09bnVsbD92b2lkIDA6WS5sZW5ndGgpP2NlLkRvbmU6Y2UuRG9pbmcsb3A6aHQuc2xpY2UoLTIpfSk7YnJlYWt9fX0pLGUmJnRoaXMucnVuQW5pbWF0aW9uKCk7Y29uc3QgdT17cmVuZGVyOltdfTtpZihmLmxlbmd0aCl7Y29uc3QgbT1mLnJlZHVjZSgoYixNKT0+KE0ucmVjdCYmTS5jbGVhckNhbnZhcz09PUJ0LkJnJiYoYi5yZWN0PSR0KGIucmVjdCxNLnJlY3QpKSxiKSx7aXNDbGVhcjohMCxjbGVhckNhbnZhczpCdC5CZyx2aWV3SWQ6dGhpcy52aWV3SWR9KTttLnJlY3QmJihtLnJlY3Q9bS5yZWN0JiZsbihtLnJlY3QpLChhPXUucmVuZGVyKT09bnVsbHx8YS5wdXNoKG0pKX1pZihoLmxlbmd0aCl7Y29uc3QgbT1oLnJlZHVjZSgoYixNKT0+KE0ucmVjdCYmTS5jbGVhckNhbnZhcz09PUJ0LkZsb2F0JiYoYi5yZWN0PSR0KGIucmVjdCxNLnJlY3QpKSxiKSx7aXNDbGVhcjohMCxjbGVhckNhbnZhczpCdC5GbG9hdCx2aWV3SWQ6dGhpcy52aWV3SWR9KTttLnJlY3QmJihtLnJlY3Q9bS5yZWN0JiZsbihtLnJlY3QpLChkPXUucmVuZGVyKT09bnVsbHx8ZC5wdXNoKG0pKX1pZihuLmxlbmd0aCl7Y29uc3QgbT1uLnJlZHVjZSgoYixNKT0+KE0ucmVjdCYmTS5kcmF3Q2FudmFzPT09QnQuQmcmJihiLnJlY3Q9JHQoYi5yZWN0LE0ucmVjdCkpLGIpLHtpc0Z1bGxXb3JrOiEwLGRyYXdDYW52YXM6QnQuQmcsdmlld0lkOnRoaXMudmlld0lkfSk7bS5yZWN0JiYobS5yZWN0PW0ucmVjdCYmbG4obS5yZWN0KSwoRT11LnJlbmRlcik9PW51bGx8fEUucHVzaChtKSl9aWYoaS5sZW5ndGgpe2NvbnN0IG09aS5yZWR1Y2UoKGIsTSk9PihNLnJlY3QmJk0uZHJhd0NhbnZhcz09PUJ0LkZsb2F0JiYoYi5yZWN0PSR0KGIucmVjdCxNLnJlY3QpKSxiKSx7aXNGdWxsV29yazohMSxkcmF3Q2FudmFzOkJ0LkZsb2F0LHZpZXdJZDp0aGlzLnZpZXdJZH0pO20ucmVjdCYmKG0ucmVjdD1tLnJlY3QmJmxuKG0ucmVjdCksKHA9dS5yZW5kZXIpPT1udWxsfHxwLnB1c2gobSkpfXQuc2l6ZSYmKHUuc3A9W10sdC5mb3JFYWNoKChtLGIpPT57dmFyIE07KE09dS5zcCk9PW51bGx8fE0ucHVzaCh7dHlwZTpUdC5DdXJzb3IsdWlkOmIuc3BsaXQoU20pWzBdLG9wOm0ub3Asd29ya1N0YXRlOm0ud29ya1N0YXRlLHZpZXdJZDp0aGlzLnZpZXdJZH0pfSkpLChPPXUucmVuZGVyKSE9bnVsbCYmTy5sZW5ndGgmJnRoaXMucG9zdCh1KX1ydW5BbmltYXRpb24oKXt0aGlzLmFuaW1hdGlvbklkfHwodGhpcy5hbmltYXRpb25JZD1yZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5hbmltYXRpb25EcmF3LmJpbmQodGhpcykpKX1jb21wdXROZXh0QW5pbWF0aW9uSW5kZXgoZSx0KXt2YXIgaTtjb25zdCBuPU1hdGguZmxvb3IoKGUuYW5pbWF0aW9uV29ya0RhdGF8fFtdKS5zbGljZShlLmFuaW1hdGlvbkluZGV4KS5sZW5ndGgqMzIvdC8oKChpPWUubm9kZSk9PW51bGw/dm9pZCAwOmkuc3luY1VuaXRUaW1lKXx8MWUzKSkqdDtyZXR1cm4gTWF0aC5taW4oKGUuYW5pbWF0aW9uSW5kZXh8fDApKyhufHx0KSwoZS5hbmltYXRpb25Xb3JrRGF0YXx8W10pLmxlbmd0aCl9cnVuRWZmZWN0KCl7dGhpcy5ydW5FZmZlY3RJZHx8KHRoaXMucnVuRWZmZWN0SWQ9c2V0VGltZW91dCh0aGlzLmVmZmVjdFJ1blNlbGVjdG9yLmJpbmQodGhpcyksMCkpfWVmZmVjdFJ1blNlbGVjdG9yKCl7dGhpcy5ydW5FZmZlY3RJZD12b2lkIDA7bGV0IGU9dGhpcy5ub0FuaW1hdGlvblJlY3Q7dGhpcy53aWxsUnVuRWZmZWN0U2VsZWN0b3JJZHMuZm9yRWFjaCh0PT57dmFyIGYsaDtjb25zdCBuPXRoaXMuc2VsZWN0b3JXb3JrU2hhcGVzLmdldCh0KSxpPW4mJm4uc2VsZWN0SWRzJiYoKGY9bi5ub2RlKT09bnVsbD92b2lkIDA6Zi5zZWxlY3RTZXJ2aWNlTm9kZSh0LG4pKTtlPSR0KGUsaSksKGg9bj09bnVsbD92b2lkIDA6bi5zZWxlY3RJZHMpIT1udWxsJiZoLmxlbmd0aHx8dGhpcy5zZWxlY3RvcldvcmtTaGFwZXMuZGVsZXRlKHQpfSksZSYmdGhpcy5wb3N0KHtyZW5kZXI6W3tyZWN0OmxuKGUpLGRyYXdDYW52YXM6QnQuQmcsaXNDbGVhcjohMCxjbGVhckNhbnZhczpCdC5CZyxpc0Z1bGxXb3JrOiEwLHZpZXdJZDp0aGlzLnZpZXdJZH1dfSksdGhpcy53aWxsUnVuRWZmZWN0U2VsZWN0b3JJZHMuY2xlYXIoKSx0aGlzLm5vQW5pbWF0aW9uUmVjdD12b2lkIDB9YWN0aXZlU2VsZWN0b3JTaGFwZShlKXt2YXIgZCxFLHA7Y29uc3R7d29ya0lkOnQsb3B0Om4sdG9vbHNUeXBlOmksdHlwZTpmLHNlbGVjdElkczpofT1lO2lmKCF0KXJldHVybjtjb25zdCB1PXQudG9TdHJpbmcoKTtpZighKChkPXRoaXMuc2VsZWN0b3JXb3JrU2hhcGVzKSE9bnVsbCYmZC5oYXModSkpKXtsZXQgTz17dG9vbHNUeXBlOmksc2VsZWN0SWRzOmgsdHlwZTpmLG9wdDpufTtpJiZuJiYoTz10aGlzLnNldE5vZGVLZXkoTyxpLG4pKSwoRT10aGlzLnNlbGVjdG9yV29ya1NoYXBlcyk9PW51bGx8fEUuc2V0KHUsTyl9Y29uc3QgYT0ocD10aGlzLnNlbGVjdG9yV29ya1NoYXBlcyk9PW51bGw/dm9pZCAwOnAuZ2V0KHUpO2YmJihhLnR5cGU9ZiksYS5ub2RlJiZhLm5vZGUuZ2V0V29ya0lkKCkhPT11JiZhLm5vZGUuc2V0V29ya0lkKHUpLGEuc2VsZWN0SWRzPWh8fFtdfX1jbGFzcyB5eSBleHRlbmRzIFFhe2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJhbmltYXRpb25Xb3JrUmVjdHMiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpuZXcgTWFwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImNvbWJpbmVEcmF3VGltZXIiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiYW5pbWF0aW9uSWQiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiY2xvc2VBbmltYXRpb25UaW1lIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6MTEwMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJydW5MYXNlclBlblN0ZXAiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTowfSl9cnVuRnVsbFdvcmsoZSl7dmFyIGk7Y29uc3QgdD10aGlzLnNldEZ1bGxXb3JrKGUpLG49ZS5vcHMmJnNpKGUub3BzKTtpZih0KXtjb25zdCBmPXQuY29uc3VtZVNlcnZpY2Uoe29wOm4saXNGdWxsV29yazohMCxyZXBsYWNlSWQ6KGk9dC5nZXRXb3JrSWQoKSk9PW51bGw/dm9pZCAwOmkudG9TdHJpbmcoKX0pLGg9KGU9PW51bGw/dm9pZCAwOmUudXBkYXRlTm9kZU9wdCkmJnQudXBkYXRhT3B0U2VydmljZShlLnVwZGF0ZU5vZGVPcHQpO3JldHVybiBlLndvcmtJZCYmdGhpcy53b3JrU2hhcGVzLmRlbGV0ZShlLndvcmtJZCksaHx8Zn19cnVuU2VsZWN0V29yayhlKXt2YXIgbjtjb25zdCB0PXRoaXMuc2V0RnVsbFdvcmsoZSk7dCYmKChuPWUuc2VsZWN0SWRzKSE9bnVsbCYmbi5sZW5ndGgpJiZlLndvcmtJZCYmdC5zZWxlY3RTZXJ2aWNlTm9kZShlLndvcmtJZC50b1N0cmluZygpLHtzZWxlY3RJZHM6ZS5zZWxlY3RJZHN9KX1jb25zdW1lRHJhdyhlKXt2YXIgaTtjb25zdHtvcDp0LHdvcmtJZDpufT1lO2lmKHQhPW51bGwmJnQubGVuZ3RoJiZuKXtjb25zdCBmPXRoaXMud29ya1NoYXBlcy5nZXQobik7aWYoIWYpcmV0dXJuO2NvbnN0IGg9Zi50b29sc1R5cGUsdT1mLmNvbnN1bWUoe2RhdGE6ZSxpc0Z1bGxXb3JrOiExLGlzQ2xlYXJBbGw6ITAsaXNTdWJXb3JrZXI6ITB9KTtzd2l0Y2goaCl7Y2FzZSBMdC5MYXNlclBlbjp1IT1udWxsJiZ1LnJlY3QmJigoaT10aGlzLmFuaW1hdGlvbldvcmtSZWN0cyk9PW51bGx8fGkuc2V0KG4se3Jlczp1LGNhbkRlbDohMSxpc1JlY3Q6ITB9KSksdGhpcy5ydW5MYXNlclBlbkFuaW1hdGlvbigpO2JyZWFrO2Nhc2UgTHQuQXJyb3c6Y2FzZSBMdC5TdHJhaWdodDpjYXNlIEx0LkVsbGlwc2U6Y2FzZSBMdC5SZWN0YW5nbGU6Y2FzZSBMdC5TdGFyOmNhc2UgTHQuUG9seWdvbjpjYXNlIEx0LlNwZWVjaEJhbGxvb246dSYmKHRoaXMuZHJhd0NvdW50KyssdGhpcy5kcmF3QXJyb3codSkpO2JyZWFrO2Nhc2UgTHQuUGVuY2lsOnUmJih0aGlzLmRyYXdDb3VudCsrLHRoaXMuZHJhd1BlbmNpbCh1KSk7YnJlYWt9fX1jb25zdW1lRHJhd0FsbChlKXt2YXIgbixpO2NvbnN0e3dvcmtJZDp0fT1lO2lmKHQpe2NvbnN0IGY9dGhpcy53b3JrU2hhcGVzLmdldCh0KTtpZighZilyZXR1cm47c3dpdGNoKGYudG9vbHNUeXBlKXtjYXNlIEx0Lkxhc2VyUGVuOmlmKHRoaXMuYW5pbWF0aW9uSWQpe2NvbnN0IHU9Zi5jb25zdW1lQWxsKHtkYXRhOmV9KTt1IT1udWxsJiZ1Lm9wJiYodSE9bnVsbCYmdS5yZWN0JiYoKG49dGhpcy5hbmltYXRpb25Xb3JrUmVjdHMpPT1udWxsfHxuLnNldCh0LHtyZXM6dSxjYW5EZWw6ITEsaXNSZWN0OiEwfSksdGhpcy5ydW5MYXNlclBlbkFuaW1hdGlvbigpKSx0aGlzLl9wb3N0KHtzcDpbdV19KSk7Y29uc3QgYT0oaT1mLmdldFdvcmtPcHRpb25zKCkpPT1udWxsP3ZvaWQgMDppLmR1cmF0aW9uO3RoaXMuY2xvc2VBbmltYXRpb25UaW1lPWE/YSoxZTMrMTAwOnRoaXMuY2xvc2VBbmltYXRpb25UaW1lLHNldFRpbWVvdXQoKCk9Pnt2YXIgRTt0aGlzLmZ1bGxMYXllci5nZXRFbGVtZW50c0J5TmFtZSh0LnRvU3RyaW5nKCkpLm1hcChwPT5wLnJlbW92ZSgpKSx0aGlzLmNsZWFyV29ya1NoYXBlTm9kZUNhY2hlKHQpO2NvbnN0IGQ9KEU9dGhpcy5hbmltYXRpb25Xb3JrUmVjdHMpPT1udWxsP3ZvaWQgMDpFLmdldCh0KTtkJiYoZC5jYW5EZWw9ITApLHNldFRpbWVvdXQoKCk9Pnt0aGlzLl9wb3N0KHtzcDpbe3JlbW92ZUlkczpbdC50b1N0cmluZygpXSx0eXBlOlR0LlJlbW92ZU5vZGV9XX0pfSxmLmdldFdvcmtPcHRpb25zKCkuc3luY1VuaXRUaW1lfHx0aGlzLmNsb3NlQW5pbWF0aW9uVGltZSl9LHRoaXMuY2xvc2VBbmltYXRpb25UaW1lKX1icmVhaztjYXNlIEx0LkFycm93OmNhc2UgTHQuU3RyYWlnaHQ6Y2FzZSBMdC5FbGxpcHNlOmNhc2UgTHQuUGVuY2lsOmNhc2UgTHQuUmVjdGFuZ2xlOmNhc2UgTHQuU3RhcjpjYXNlIEx0LlBvbHlnb246Y2FzZSBMdC5TcGVlY2hCYWxsb29uOnRoaXMuZHJhd0NvdW50PTAsdGhpcy5mdWxsTGF5ZXIucmVtb3ZlQWxsQ2hpbGRyZW4oKSx0aGlzLmNsZWFyV29ya1NoYXBlTm9kZUNhY2hlKHQpO2JyZWFrfX19cnVuTGFzZXJQZW5BbmltYXRpb24oKXt0aGlzLmFuaW1hdGlvbklkfHwodGhpcy5hbmltYXRpb25JZD1yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCk9Pnt2YXIgbixpO2lmKHRoaXMuYW5pbWF0aW9uSWQ9dm9pZCAwLHRoaXMucnVuTGFzZXJQZW5TdGVwKyssdGhpcy5ydW5MYXNlclBlblN0ZXA+MSl7dGhpcy5ydW5MYXNlclBlblN0ZXA9MCx0aGlzLnJ1bkxhc2VyUGVuQW5pbWF0aW9uKCk7cmV0dXJufWxldCBlO2NvbnN0IHQ9W107KG49dGhpcy5hbmltYXRpb25Xb3JrUmVjdHMpPT1udWxsfHxuLmZvckVhY2goKGYsaCx1KT0+e2YuaXNSZWN0JiYoZT0kdChlLGYucmVzLnJlY3QpKSxmLnJlcy53b3JrSWQmJnQucHVzaChmLnJlcyksdGhpcy5mdWxsTGF5ZXIuZ2V0RWxlbWVudHNCeU5hbWUoaC50b1N0cmluZygpKS5sZW5ndGg/Zi5pc1JlY3Q9ITA6Zi5pc1JlY3Q9ITEsZi5jYW5EZWwmJnUuZGVsZXRlKGgpfSksKGk9dGhpcy5hbmltYXRpb25Xb3JrUmVjdHMpIT1udWxsJiZpLnNpemUmJnRoaXMucnVuTGFzZXJQZW5BbmltYXRpb24oKSxlJiZ0aGlzLl9wb3N0KHtyZW5kZXI6W3tyZWN0OmUsZHJhd0NhbnZhczpCdC5GbG9hdCxpc0NsZWFyOiEwLGNsZWFyQ2FudmFzOkJ0LkZsb2F0LGlzRnVsbFdvcms6ITEsdmlld0lkOnRoaXMudmlld0lkfV0sc3A6dH0pfSkpfWRyYXdQZW5jaWwoZSl7dGhpcy5fcG9zdCh7ZHJhd0NvdW50OnRoaXMuZHJhd0NvdW50LHJlbmRlcjpbe3JlY3Q6ZT09bnVsbD92b2lkIDA6ZS5yZWN0LGRyYXdDYW52YXM6QnQuRmxvYXQsaXNDbGVhcjohMSxpc0Z1bGxXb3JrOiExLHZpZXdJZDp0aGlzLnZpZXdJZH1dLHNwOihlPT1udWxsP3ZvaWQgMDplLm9wKSYmW2VdfSl9ZHJhd0Fycm93KGUpe3RoaXMuX3Bvc3Qoe2RyYXdDb3VudDp0aGlzLmRyYXdDb3VudCxyZW5kZXI6W3tyZWN0OmU9PW51bGw/dm9pZCAwOmUucmVjdCxkcmF3Q2FudmFzOkJ0LkZsb2F0LGlzQ2xlYXI6ITAsY2xlYXJDYW52YXM6QnQuRmxvYXQsaXNGdWxsV29yazohMSx2aWV3SWQ6dGhpcy52aWV3SWR9XX0pfX12YXIgSW47KGZ1bmN0aW9uKGcpe2cuRnVsbD0iZnVsbCIsZy5TdWI9InN1YiJ9KShJbnx8KEluPXt9KSk7Y2xhc3MgeHl7Y29uc3RydWN0b3IoZSx0KXtPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiX3NlbGYiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidHlwZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ3b3JrVGhyZWFkTWFwIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6bmV3IE1hcH0pLHRoaXMuX3NlbGY9ZSx0aGlzLnR5cGU9dCx0aGlzLnJlZ2lzdGVyKCl9aW5pdChlKXtjb25zdHt2aWV3SWQ6dCxkcHI6bixvZmZzY3JlZW5DYW52YXNPcHQ6aSxsYXllck9wdDpmfT1lO2lmKCFufHwhaXx8IWYpcmV0dXJuO2xldCBoO3RoaXMudHlwZT09PUluLkZ1bGwmJihoPW5ldyBPeSh0LHtkcHI6bixvZmZzY3JlZW5DYW52YXNPcHQ6aSxsYXllck9wdDpmfSx0aGlzLnBvc3QuYmluZCh0aGlzKSkpLHRoaXMudHlwZT09PUluLlN1YiYmKGg9bmV3IEV5KHQse2RwcjpuLG9mZnNjcmVlbkNhbnZhc09wdDppLGxheWVyT3B0OmZ9LHRoaXMucG9zdC5iaW5kKHRoaXMpKSksaCYmZS5jYW1lcmFPcHQmJmguc2V0Q2FtZXJhT3B0KGUuY2FtZXJhT3B0KSxoJiZ0aGlzLndvcmtUaHJlYWRNYXAuc2V0KHQsaCl9cmVnaXN0ZXIoKXtvbm1lc3NhZ2U9ZT0+e2NvbnN0IHQ9ZS5kYXRhO2lmKHQpZm9yKGNvbnN0IG4gb2YgdC52YWx1ZXMoKSl7Y29uc3R7bXNnVHlwZTppLHZpZXdJZDpmLHRhc2tzcXVldWU6aCxtYWluVGFza3NxdWV1ZUNvdW50OnV9PW47aWYoaT09PVR0LkluaXQpe3RoaXMuaW5pdChuKTtjb250aW51ZX1pZihpPT09VHQuVGFza3NRdWV1ZSYmKGghPW51bGwmJmguc2l6ZSkmJnUpe3RoaXMud29ya1RocmVhZE1hcC5mb3JFYWNoKChkLEUpPT57Y29uc3QgcD1oLmdldChFKTtwJiZkLm9uKHApLHRoaXMucG9zdCh7d29ya2VyVGFza3NxdWV1ZUNvdW50OnV9KX0pO2NvbnRpbnVlfWlmKGY9PT1QbSl7dGhpcy53b3JrVGhyZWFkTWFwLmZvckVhY2goZD0+e2Qub24obiksaT09PVR0LkRlc3Ryb3kmJnRoaXMud29ya1RocmVhZE1hcC5kZWxldGUoZil9KTtjb250aW51ZX1jb25zdCBhPXRoaXMud29ya1RocmVhZE1hcC5nZXQoZik7YSYmKGEub24obiksaT09PVR0LkRlc3Ryb3kmJnRoaXMud29ya1RocmVhZE1hcC5kZWxldGUoZikpfX19cG9zdChlLHQpe3Q/dGhpcy5fc2VsZi5wb3N0TWVzc2FnZShlLHQpOnRoaXMuX3NlbGYucG9zdE1lc3NhZ2UoZSl9fWNsYXNzIE95IGV4dGVuZHMgSmF7Y29uc3RydWN0b3IoZSx0LG4pe3N1cGVyKGUsdCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImRyYXdMYXllciIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzbmFwc2hvdEZ1bGxMYXllciIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJtZXRob2RCdWlsZGVyIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImxvY2FsV29yayIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzZXJ2aWNlV29yayIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJfcG9zdCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLHRoaXMuX3Bvc3Q9bix0aGlzLmRyYXdMYXllcj10aGlzLmNyZWF0ZUxheWVyKCJkcmF3TGF5ZXIiLHRoaXMuc2NlbmUsey4uLnQubGF5ZXJPcHQsYnVmZmVyU2l6ZToxZTN9KTtjb25zdCBpPXt2aWV3SWQ6dGhpcy52aWV3SWQsdk5vZGVzOnRoaXMudk5vZGVzLGZ1bGxMYXllcjp0aGlzLmZ1bGxMYXllcixkcmF3TGF5ZXI6dGhpcy5kcmF3TGF5ZXIscG9zdDp0aGlzLnBvc3QuYmluZCh0aGlzKX07dGhpcy5sb2NhbFdvcms9bmV3IHB5KGkpLHRoaXMuc2VydmljZVdvcms9bmV3IG15KGkpLHRoaXMubWV0aG9kQnVpbGRlcj1uZXcgTm0oW29lLkNvcHlOb2RlLG9lLlNldENvbG9yTm9kZSxvZS5EZWxldGVOb2RlLG9lLlJvdGF0ZU5vZGUsb2UuU2NhbGVOb2RlLG9lLlRyYW5zbGF0ZU5vZGUsb2UuWkluZGV4QWN0aXZlLG9lLlpJbmRleE5vZGVdKS5yZWdpc3RlckZvcldvcmtlcih0aGlzLmxvY2FsV29yayx0aGlzLnNlcnZpY2VXb3JrKSx0aGlzLnZOb2Rlcy5pbml0KHRoaXMuZnVsbExheWVyLHRoaXMuZHJhd0xheWVyKX1hc3luYyBwb3N0KGUsdCl7dmFyIHUsYTtjb25zdCBuPWUucmVuZGVyLGk9W107bGV0IGY9dDtpZihuIT1udWxsJiZuLmxlbmd0aCl7Zm9yKGNvbnN0IGQgb2Ygbil7aWYoZC5pc0NsZWFyQWxsJiYoZC5yZWN0PXRoaXMuZ2V0U2NlbmVSZWN0KCksZC5pc0NsZWFyPSEwLGRlbGV0ZSBkLmlzQ2xlYXJBbGwpLGQuaXNEcmF3QWxsJiYoZC5yZWN0PXRoaXMuZ2V0U2NlbmVSZWN0KCksZGVsZXRlIGQuaXNEcmF3QWxsKSxkLmRyYXdDYW52YXMpe2NvbnN0IEU9ZC5pc0Z1bGxXb3JrP3RoaXMuZnVsbExheWVyOnRoaXMuZHJhd0xheWVyOyhFPT1udWxsP3ZvaWQgMDpFLnBhcmVudCkucmVuZGVyKCl9aWYoZC5yZWN0KXtkLmNsZWFyQ2FudmFzPT09ZC5kcmF3Q2FudmFzJiZkLmRyYXdDYW52YXM9PT1CdC5CZyYmKGQucmVjdD10aGlzLmNoZWNrUmlnaHRSZWN0Qm91bmRpbmdCb3goZC5yZWN0KSk7Y29uc3QgRT1kLnJlY3Q7aWYoZC5yZWN0PXRoaXMuc2FmYXJpRml4UmVjdChkcihkLnJlY3QpKSxkLmRyYXdDYW52YXMsQnQuU2VsZWN0b3IsIWQucmVjdCljb250aW51ZTtpZihkLmRyYXdDYW52YXM9PT1CdC5TZWxlY3Rvcil7Y29uc3QgcD0odT1lLnNwKT09bnVsbD92b2lkIDA6dS5maW5kKE89Pk8udHlwZT09PVR0LlNlbGVjdCk7cCYmKHAucmVjdD1kLnJlY3QpLGQub2Zmc2V0PXt4OmQucmVjdC54LUUueCx5OmQucmVjdC55LUUueX19aWYoZC5kcmF3Q2FudmFzKXtjb25zdCBwPWF3YWl0IHRoaXMuZ2V0UmVjdEltYWdlQml0bWFwKGQucmVjdCwhIWQuaXNGdWxsV29yayk7ZC5pbWFnZUJpdG1hcD1wLGZ8fChmPVtdKSxmLnB1c2gocCl9aS5wdXNoKGQpfX1lLnJlbmRlcj1pfWNvbnN0IGg9KGE9ZS5zcCk9PW51bGw/dm9pZCAwOmEuZmlsdGVyKGQ9PmQudHlwZSE9PVR0Lk5vbmV8fE9iamVjdC5rZXlzKGQpLmZpbHRlcihFPT5FPT09InR5cGUiKS5sZW5ndGgpO2lmKGghPW51bGwmJmgubGVuZ3RoJiYoZS5zcD1oLm1hcChkPT4oey4uLmQsdmlld0lkOnRoaXMudmlld0lkfSkpKSwoZS5kcmF3Q291bnR8fGUud29ya2VyVGFza3NxdWV1ZUNvdW50fHxoIT1udWxsJiZoLmxlbmd0aHx8aSE9bnVsbCYmaS5sZW5ndGgpJiYodGhpcy5fcG9zdChlLGYpLGYhPW51bGwmJmYubGVuZ3RoKSlmb3IoY29uc3QgZCBvZiBmKWQgaW5zdGFuY2VvZiBJbWFnZUJpdG1hcCYmZC5jbG9zZSgpfW9uKGUpe2lmKHRoaXMubWV0aG9kQnVpbGRlci5jb25zdW1lRm9yV29ya2VyKGUpKXJldHVybjtjb25zdHttc2dUeXBlOnQsZGF0YVR5cGU6bix3b3JrSWQ6aX09ZTtzd2l0Y2godCl7Y2FzZSBUdC5VcGRhdGVDYW1lcmE6dGhpcy51cGRhdGVDYW1lcmEoZSk7YnJlYWs7Y2FzZSBUdC5TZWxlY3Q6bj09PXp0LlNlcnZpY2UmJihpPT09aWUuc2VsZWN0b3JJZD90aGlzLmxvY2FsV29yay51cGRhdGVGdWxsU2VsZWN0V29yayhlKTp0aGlzLnNlcnZpY2VXb3JrLnJ1blNlbGVjdFdvcmsoZSkpO2JyZWFrO2Nhc2UgVHQuVXBkYXRlTm9kZTpjYXNlIFR0LkZ1bGxXb3JrOnRoaXMuY29uc3VtZUZ1bGwobixlKTticmVhaztjYXNlIFR0LlJlbW92ZU5vZGU6dGhpcy5yZW1vdmVOb2RlKGUpO2JyZWFrO2Nhc2UgVHQuR2V0VGV4dEFjdGl2ZTp0aGlzLmNoZWNrVGV4dEFjdGl2ZShlKTticmVha31zdXBlci5vbihlKX1yZW1vdmVOb2RlKGUpe2NvbnN0e2RhdGFUeXBlOnQsd29ya0lkOm59PWU7bj09PWllLnNlbGVjdG9ySWQmJnRoaXMubG9jYWxXb3JrLmJsdXJTZWxlY3RvcihlKSx0PT09enQuU2VydmljZSYmdGhpcy5zZXJ2aWNlV29yay5yZW1vdmVXb3JrKGUpLHQ9PT16dC5Mb2NhbCYmdGhpcy5sb2NhbFdvcmsucmVtb3ZlV29yayhlKX1jaGVja1RleHRBY3RpdmUoZSl7Y29uc3R7ZGF0YVR5cGU6dH09ZTt0PT09enQuTG9jYWwmJnRoaXMubG9jYWxXb3JrLmNoZWNrVGV4dEFjdGl2ZShlKX1jbGVhckFsbCgpe3RoaXMudk5vZGVzLmNsZWFyKCksc3VwZXIuY2xlYXJBbGwoKSx0aGlzLnBvc3Qoe3JlbmRlcjpbe2lzQ2xlYXJBbGw6ITAsY2xlYXJDYW52YXM6QnQuQmcsaXNGdWxsV29yazohMCx2aWV3SWQ6dGhpcy52aWV3SWR9LHtpc0NsZWFyQWxsOiEwLGNsZWFyQ2FudmFzOkJ0LkZsb2F0LGlzRnVsbFdvcms6ITEsdmlld0lkOnRoaXMudmlld0lkfV0sc3A6W3t0eXBlOlR0LkNsZWFyfV19KX1zZXRDYW1lcmFPcHQoZSl7dGhpcy5jYW1lcmFPcHQ9ZTtjb25zdHtzY2FsZTp0LGNlbnRlclg6bixjZW50ZXJZOmksd2lkdGg6ZixoZWlnaHQ6aH09ZTsoZiE9PXRoaXMuc2NlbmUud2lkdGh8fGghPT10aGlzLnNjZW5lLmhlaWdodCkmJnRoaXMudXBkYXRlU2NlbmUoe3dpZHRoOmYsaGVpZ2h0Omh9KSx0aGlzLmZ1bGxMYXllciYmKHRoaXMuZnVsbExheWVyLnNldEF0dHJpYnV0ZSgic2NhbGUiLFt0LHRdKSx0aGlzLmZ1bGxMYXllci5zZXRBdHRyaWJ1dGUoInRyYW5zbGF0ZSIsWy1uLC1pXSkpLHRoaXMuZHJhd0xheWVyJiYodGhpcy5kcmF3TGF5ZXIuc2V0QXR0cmlidXRlKCJzY2FsZSIsW3QsdF0pLHRoaXMuZHJhd0xheWVyLnNldEF0dHJpYnV0ZSgidHJhbnNsYXRlIixbLW4sLWldKSl9Z2V0T2Zmc2NyZWVuKGUpe3JldHVybihlP3RoaXMuZnVsbExheWVyLnBhcmVudDp0aGlzLmRyYXdMYXllci5wYXJlbnQpLmNhbnZhc31jb25zdW1lRnVsbChlLHQpe2U9PT16dC5Mb2NhbCYmdGhpcy5sb2NhbFdvcmsuY29uc3VtZUZ1bGwodCk7Y29uc3Qgbj10aGlzLmxvY2FsV29yay5jb2xsb2N0RWZmZWN0U2VsZWN0V29yayh0KTtuJiZlPT09enQuU2VydmljZSYmdGhpcy5zZXJ2aWNlV29yay5jb25zdW1lRnVsbChuKX1jb25zdW1lRHJhdyhlLHQpe2U9PT16dC5Mb2NhbCYmdGhpcy5sb2NhbFdvcmsuY29uc3VtZURyYXcodCx0aGlzLnNlcnZpY2VXb3JrKSxlPT09enQuU2VydmljZSYmdGhpcy5zZXJ2aWNlV29yay5jb25zdW1lRHJhdyh0KX1jb25zdW1lRHJhd0FsbChlLHQpe2U9PT16dC5Mb2NhbCYmdGhpcy5sb2NhbFdvcmsuY29uc3VtZURyYXdBbGwodCx0aGlzLnNlcnZpY2VXb3JrKX11cGRhdGVDYW1lcmEoZSl7Y29uc3QgdD1bXSx7Y2FtZXJhT3B0Om59PWU7biYmKHRoaXMuc2V0Q2FtZXJhT3B0KG4pLHRoaXMubG9jYWxXb3JrLndvcmtTaGFwZXMuZm9yRWFjaCgoaSxmKT0+eyhpLnRvb2xzVHlwZT09PUx0LlBlbmNpbHx8aS50b29sc1R5cGU9PT1MdC5BcnJvd3x8aS50b29sc1R5cGU9PT1MdC5TdHJhaWdodHx8aS50b29sc1R5cGU9PT1MdC5FbGxpcHNlfHxpLnRvb2xzVHlwZT09PUx0LlJlY3RhbmdsZXx8aS50b29sc1R5cGU9PT1MdC5TdGFyfHxpLnRvb2xzVHlwZT09PUx0LlBvbHlnb258fGkudG9vbHNUeXBlPT09THQuU3BlZWNoQmFsbG9vbnx8aS50b29sc1R5cGU9PT1MdC5UZXh0KSYmdGhpcy5sb2NhbFdvcmsud29ya1NoYXBlU3RhdGUuc2V0KGYse3dpbGxDbGVhcjohMH0pfSksdGhpcy5sb2NhbFdvcmsucnVuRWZmZWN0V29yaygoKT0+e2lmKHRoaXMuc2VydmljZVdvcmsuc2VsZWN0b3JXb3JrU2hhcGVzLnNpemUpZm9yKGNvbnN0W2ksZl1vZiB0aGlzLnNlcnZpY2VXb3JrLnNlbGVjdG9yV29ya1NoYXBlcy5lbnRyaWVzKCkpdGhpcy5zZXJ2aWNlV29yay5ydW5TZWxlY3RXb3JrKHt3b3JrSWQ6aSxzZWxlY3RJZHM6Zi5zZWxlY3RJZHMsbXNnVHlwZTpUdC5TZWxlY3QsZGF0YVR5cGU6enQuU2VydmljZSx2aWV3SWQ6dGhpcy52aWV3SWR9KTtpZih0aGlzLnZOb2Rlcy5oYXNSZW5kZXJOb2RlcygpKXtsZXQgaTt0LnB1c2goe2lzQ2xlYXJBbGw6ITAsY2xlYXJDYW52YXM6QnQuQmcsaXNGdWxsV29yazohMCx2aWV3SWQ6dGhpcy52aWV3SWR9LHtpc0NsZWFyQWxsOiEwLGNsZWFyQ2FudmFzOkJ0LkZsb2F0LGlzRnVsbFdvcms6ITEsdmlld0lkOnRoaXMudmlld0lkfSk7Zm9yKGNvbnN0IGYgb2YgdGhpcy52Tm9kZXMuY3VyTm9kZU1hcC52YWx1ZXMoKSl3YShmLnRvb2xzVHlwZSkmJihpPSR0KGksZi5yZWN0KSk7aSYmdC5wdXNoKHtyZWN0Om9tKGksMTAwKSxkcmF3Q2FudmFzOkJ0LkJnLGlzQ2xlYXI6ITEsaXNGdWxsV29yazohMCx2aWV3SWQ6dGhpcy52aWV3SWR9KX10Lmxlbmd0aCYmdGhpcy5wb3N0KHtyZW5kZXI6dH0pfSkpfWdldFJlY3RJbWFnZUJpdG1hcChlLHQpe2NvbnN0IG49ZS54KnRoaXMuZHByLGk9ZS55KnRoaXMuZHByLGY9ZS53KnRoaXMuZHByLGg9ZS5oKnRoaXMuZHByO3JldHVybiBjcmVhdGVJbWFnZUJpdG1hcCh0aGlzLmdldE9mZnNjcmVlbih0KSxuLGksZixoKX1zYWZhcmlGaXhSZWN0KGUpe2lmKGUudytlLng8PTB8fGUuaCtlLnk8PTB8fGUudzw9MHx8ZS5oPD0wKXJldHVybjtjb25zdCB0PXt4OjAseTowLHc6dGhpcy5zY2VuZS53aWR0aCxoOnRoaXMuc2NlbmUuaGVpZ2h0fTtpZihlLng8MD9lLncrZS54PHRoaXMuc2NlbmUud2lkdGgmJih0Lnc9ZS53K2UueCk6ZS53K2UueD4wJiYodC54PWUueCx0Lnc9dGhpcy5zY2VuZS53aWR0aC1lLngpLGUueTwwP2UuaCtlLnk8dGhpcy5zY2VuZS5oZWlnaHQmJih0Lmg9ZS5oK2UueSk6ZS5oK2UueT4wJiYodC55PWUueSx0Lmg9dGhpcy5zY2VuZS5oZWlnaHQtZS55KSwhKHQudzw9MHx8dC5oPD0wKSlyZXR1cm4gdH1nZXRTY2VuZVJlY3QoKXtjb25zdHt3aWR0aDplLGhlaWdodDp0fT10aGlzLnNjZW5lO3JldHVybnt4OjAseTowLHc6ZSxoOnR9fWNoZWNrUmlnaHRSZWN0Qm91bmRpbmdCb3goZSl7cmV0dXJuIHRoaXMudk5vZGVzLmNvbWJpbmVJbnRlcnNlY3RSZWN0KGUpfX1jbGFzcyBFeSBleHRlbmRzIEphe2NvbnN0cnVjdG9yKGUsdCxuKXtzdXBlcihlLHQpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJfcG9zdCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJkcmF3TGF5ZXIiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywic25hcHNob3RGdWxsTGF5ZXIiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywic2VydmljZVdvcmsiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywibG9jYWxXb3JrIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksdGhpcy5fcG9zdD1uO2NvbnN0IGk9e3ZpZXdJZDp0aGlzLnZpZXdJZCx2Tm9kZXM6dGhpcy52Tm9kZXMsZnVsbExheWVyOnRoaXMuZnVsbExheWVyLGRyYXdMYXllcjp0aGlzLmRyYXdMYXllcixwb3N0OnRoaXMucG9zdC5iaW5kKHRoaXMpfTt0aGlzLmxvY2FsV29yaz1uZXcgeXkoaSksdGhpcy52Tm9kZXMuaW5pdCh0aGlzLmZ1bGxMYXllcix0aGlzLmRyYXdMYXllcil9YXN5bmMgcG9zdChlLHQpe3ZhciBoO2NvbnN0IG49ZS5yZW5kZXIsaT1bXTtsZXQgZj10O2lmKG4hPW51bGwmJm4ubGVuZ3RoKXtmb3IoY29uc3QgdSBvZiBuKWlmKHUuZHJhd0NhbnZhcyYmdGhpcy5mdWxsTGF5ZXIucGFyZW50LnJlbmRlcigpLHUucmVjdCl7aWYodS5yZWN0PXRoaXMuc2FmYXJpRml4UmVjdChkcih1LnJlY3QpKSwhdS5yZWN0KWNvbnRpbnVlO2lmKHUuZHJhd0NhbnZhcyl7Y29uc3QgYT1hd2FpdCB0aGlzLmdldFJlY3RJbWFnZUJpdG1hcCh1LnJlY3QsISF1LmlzRnVsbFdvcmspO3UuaW1hZ2VCaXRtYXA9YSxmfHwoZj1bXSksZi5wdXNoKGEpfWkucHVzaCh1KX1lLnJlbmRlcj1pfWlmKCgoaD1lLnNwKSE9bnVsbCYmaC5sZW5ndGh8fGUuZHJhd0NvdW50fHxpIT1udWxsJiZpLmxlbmd0aCkmJih0aGlzLl9wb3N0KGUsZiksZiE9bnVsbCYmZi5sZW5ndGgpKWZvcihjb25zdCB1IG9mIGYpdSBpbnN0YW5jZW9mIEltYWdlQml0bWFwJiZ1LmNsb3NlKCl9b24oZSl7Y29uc3R7bXNnVHlwZTp0fT1lO3N3aXRjaCh0KXtjYXNlIFR0LlVwZGF0ZUNhbWVyYTp0aGlzLnVwZGF0ZUNhbWVyYShlKTticmVhaztjYXNlIFR0LlNuYXBzaG90OnRoaXMuc25hcHNob3RGdWxsTGF5ZXI9dGhpcy5jcmVhdGVMYXllcigic25hcHNob3RGdWxsTGF5ZXIiLHRoaXMuc2NlbmUsey4uLnRoaXMub3B0LmxheWVyT3B0LGJ1ZmZlclNpemU6dGhpcy52aWV3SWQ9PT0ibWFpblZpZXciPzZlMzozZTN9KSx0aGlzLnNuYXBzaG90RnVsbExheWVyJiZ0aGlzLmdldFNuYXBzaG90KGUpLnRoZW4oKCk9Pnt0aGlzLnNuYXBzaG90RnVsbExheWVyPXZvaWQgMH0pO2JyZWFrO2Nhc2UgVHQuQm91bmRpbmdCb3g6dGhpcy5zbmFwc2hvdEZ1bGxMYXllcj10aGlzLmNyZWF0ZUxheWVyKCJzbmFwc2hvdEZ1bGxMYXllciIsdGhpcy5zY2VuZSx7Li4udGhpcy5vcHQubGF5ZXJPcHQsYnVmZmVyU2l6ZTp0aGlzLnZpZXdJZD09PSJtYWluVmlldyI/NmUzOjNlM30pLHRoaXMuc25hcHNob3RGdWxsTGF5ZXImJnRoaXMuZ2V0Qm91bmRpbmdSZWN0KGUpLnRoZW4oKCk9Pnt0aGlzLnNuYXBzaG90RnVsbExheWVyPXZvaWQgMH0pO2JyZWFrfXN1cGVyLm9uKGUpfWdldE9mZnNjcmVlbihlKXt2YXIgdDtyZXR1cm4odD0oZSYmdGhpcy5zbmFwc2hvdEZ1bGxMYXllcnx8dGhpcy5mdWxsTGF5ZXIpLnBhcmVudCk9PW51bGw/dm9pZCAwOnQuY2FudmFzfWNvbnN1bWVEcmF3KGUsdCl7ZT09PXp0LkxvY2FsJiZ0aGlzLmxvY2FsV29yay5jb25zdW1lRHJhdyh0KX1jb25zdW1lRHJhd0FsbChlLHQpe3RoaXMubG9jYWxXb3JrLmNvbnN1bWVEcmF3QWxsKHQpfWdldFJlY3RJbWFnZUJpdG1hcChlLHQ9ITEsbil7Y29uc3QgaT1lLngqdGhpcy5kcHIsZj1lLnkqdGhpcy5kcHIsaD1lLncqdGhpcy5kcHIsdT1lLmgqdGhpcy5kcHI7cmV0dXJuIGNyZWF0ZUltYWdlQml0bWFwKHRoaXMuZ2V0T2Zmc2NyZWVuKHQpLGksZixoLHUsbil9c2FmYXJpRml4UmVjdChlKXtpZihlLncrZS54PD0wfHxlLmgrZS55PD0wfHxlLnc8PTB8fGUuaDw9MClyZXR1cm47Y29uc3QgdD17eDowLHk6MCx3OnRoaXMuc2NlbmUud2lkdGgsaDp0aGlzLnNjZW5lLmhlaWdodH07aWYoZS54PDA/ZS53K2UueDx0aGlzLnNjZW5lLndpZHRoJiYodC53PWUudytlLngpOmUudytlLng+MCYmKHQueD1lLngsdC53PXRoaXMuc2NlbmUud2lkdGgtZS54KSxlLnk8MD9lLmgrZS55PHRoaXMuc2NlbmUuaGVpZ2h0JiYodC5oPWUuaCtlLnkpOmUuaCtlLnk+MCYmKHQueT1lLnksdC5oPXRoaXMuc2NlbmUuaGVpZ2h0LWUueSksISh0Lnc8PTB8fHQuaDw9MCkpcmV0dXJuIHR9dXBkYXRlQ2FtZXJhKGUpe2NvbnN0e2NhbWVyYU9wdDp0fT1lO3QmJnRoaXMuc2V0Q2FtZXJhT3B0KHQpfXNldENhbWVyYU9wdChlLHQpe3RoaXMuY2FtZXJhT3B0PWU7Y29uc3R7c2NhbGU6bixjZW50ZXJYOmksY2VudGVyWTpmLHdpZHRoOmgsaGVpZ2h0OnV9PWU7KGghPT10aGlzLnNjZW5lLndpZHRofHx1IT09dGhpcy5zY2VuZS5oZWlnaHQpJiZ0aGlzLnVwZGF0ZVNjZW5lKHt3aWR0aDpoLGhlaWdodDp1fSksdD8odC5zZXRBdHRyaWJ1dGUoInNjYWxlIixbbixuXSksdC5zZXRBdHRyaWJ1dGUoInRyYW5zbGF0ZSIsWy1pLC1mXSkpOih0aGlzLmZ1bGxMYXllci5zZXRBdHRyaWJ1dGUoInNjYWxlIixbbixuXSksdGhpcy5mdWxsTGF5ZXIuc2V0QXR0cmlidXRlKCJ0cmFuc2xhdGUiLFstaSwtZl0pKX1hc3luYyBnZXRTbmFwc2hvdChlKXtjb25zdHtzY2VuZVBhdGg6dCxzY2VuZXM6bixjYW1lcmFPcHQ6aSx3OmYsaH09ZTtpZih0JiZuJiZpJiZ0aGlzLnNuYXBzaG90RnVsbExheWVyKXtjb25zdCB1PWRyKHRoaXMuY2FtZXJhT3B0KTt0aGlzLnNldENhbWVyYU9wdChpLHRoaXMuc25hcHNob3RGdWxsTGF5ZXIpLHRoaXMubG9jYWxXb3JrLmZ1bGxMYXllcj10aGlzLnNuYXBzaG90RnVsbExheWVyLHRoaXMubG9jYWxXb3JrLmRyYXdMYXllcj10aGlzLmZ1bGxMYXllcjtsZXQgYTtmb3IoY29uc3RbcCxPXW9mIE9iamVjdC5lbnRyaWVzKG4pKWlmKE8hPW51bGwmJk8udHlwZSlzd2l0Y2goTz09bnVsbD92b2lkIDA6Ty50eXBlKXtjYXNlIFR0LlVwZGF0ZU5vZGU6Y2FzZSBUdC5GdWxsV29yazp7Y29uc3QgbT10aGlzLmxvY2FsV29yay5ydW5GdWxsV29yayh7Li4uTyx3b3JrSWQ6cCxtc2dUeXBlOlR0LkZ1bGxXb3JrLGRhdGFUeXBlOnp0LlNlcnZpY2Usdmlld0lkOnRoaXMudmlld0lkfSk7YT0kdChhLG0pO2JyZWFrfX10aGlzLmxvY2FsV29yay5mdWxsTGF5ZXI9dGhpcy5mdWxsTGF5ZXIsdGhpcy5sb2NhbFdvcmsuZHJhd0xheWVyPXZvaWQgMDtsZXQgZDtmJiZoJiYoZD17cmVzaXplV2lkdGg6ZixyZXNpemVIZWlnaHQ6aH0pLHRoaXMuc25hcHNob3RGdWxsTGF5ZXIucGFyZW50LnJlbmRlcigpO2NvbnN0IEU9YXdhaXQgdGhpcy5nZXRSZWN0SW1hZ2VCaXRtYXAoe3g6MCx5OjAsdzp0aGlzLnNjZW5lLndpZHRoLGg6dGhpcy5zY2VuZS5oZWlnaHR9LCEwLGQpO0UmJihhd2FpdCB0aGlzLnBvc3Qoe3NwOlt7dHlwZTpUdC5TbmFwc2hvdCxzY2VuZVBhdGg6dCxpbWFnZUJpdG1hcDpFfV19LFtFXSksRS5jbG9zZSgpLHRoaXMuc25hcHNob3RGdWxsTGF5ZXIucmVtb3ZlQWxsQ2hpbGRyZW4oKSx0aGlzLnNldENhbWVyYU9wdCh1LHRoaXMuZnVsbExheWVyKSl9fWFzeW5jIGdldEJvdW5kaW5nUmVjdChlKXtjb25zdHtzY2VuZVBhdGg6dCxzY2VuZXM6bixjYW1lcmFPcHQ6aX09ZTtpZih0JiZuJiZpJiZ0aGlzLnNuYXBzaG90RnVsbExheWVyKXtjb25zdCBmPWRyKHRoaXMuY2FtZXJhT3B0KTt0aGlzLnNldENhbWVyYU9wdChpLHRoaXMuc25hcHNob3RGdWxsTGF5ZXIpLHRoaXMubG9jYWxXb3JrLmZ1bGxMYXllcj10aGlzLnNuYXBzaG90RnVsbExheWVyLHRoaXMubG9jYWxXb3JrLmRyYXdMYXllcj10aGlzLmRyYXdMYXllcjtsZXQgaDtmb3IoY29uc3RbdSxhXW9mIE9iamVjdC5lbnRyaWVzKG4pKWlmKGEhPW51bGwmJmEudHlwZSlzd2l0Y2goYT09bnVsbD92b2lkIDA6YS50eXBlKXtjYXNlIFR0LlVwZGF0ZU5vZGU6Y2FzZSBUdC5GdWxsV29yazp7Y29uc3QgZD10aGlzLmxvY2FsV29yay5ydW5GdWxsV29yayh7Li4uYSx3b3JrSWQ6dSxtc2dUeXBlOlR0LkZ1bGxXb3JrLGRhdGFUeXBlOnp0LlNlcnZpY2Usdmlld0lkOnRoaXMudmlld0lkfSk7aD0kdChoLGQpO2JyZWFrfX1oJiZhd2FpdCB0aGlzLnBvc3Qoe3NwOlt7dHlwZTpUdC5Cb3VuZGluZ0JveCxzY2VuZVBhdGg6dCxyZWN0Omh9XX0pLHRoaXMubG9jYWxXb3JrLmZ1bGxMYXllcj10aGlzLmZ1bGxMYXllcix0aGlzLmxvY2FsV29yay5kcmF3TGF5ZXI9dm9pZCAwLHRoaXMuc25hcHNob3RGdWxsTGF5ZXIucmVtb3ZlQWxsQ2hpbGRyZW4oKSx0aGlzLnNldENhbWVyYU9wdChmLHRoaXMuZnVsbExheWVyKX19fWNvbnN0IE15PXNlbGY7bmV3IHh5KE15LEluLkZ1bGwpfSkoKTsK", Yb = typeof window < "u" && window.Blob && new Blob([atob(aZ)], { type: "text/javascript;charset=utf-8" });
function pa(s) {
  let l;
  try {
    if (l = Yb && (window.URL || window.webkitURL).createObjectURL(Yb), !l)
      throw "";
    const d = new Worker(l, {
      name: s == null ? void 0 : s.name
    });
    return d.addEventListener("error", () => {
      (window.URL || window.webkitURL).revokeObjectURL(l);
    }), d;
  } catch {
    return new Worker(
      "data:application/javascript;base64," + aZ,
      {
        name: s == null ? void 0 : s.name
      }
    );
  } finally {
    l && (window.URL || window.webkitURL).revokeObjectURL(l);
  }
}
const eZ = "KGZ1bmN0aW9uKCl7InVzZSBzdHJpY3QiO3ZhciBtcj10eXBlb2YgZ2xvYmFsVGhpczwidSI/Z2xvYmFsVGhpczp0eXBlb2Ygd2luZG93PCJ1Ij93aW5kb3c6dHlwZW9mIGdsb2JhbDwidSI/Z2xvYmFsOnR5cGVvZiBzZWxmPCJ1Ij9zZWxmOnt9O2Z1bmN0aW9uIFZuKGcpe3JldHVybiBnJiZnLl9fZXNNb2R1bGUmJk9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChnLCJkZWZhdWx0Iik/Zy5kZWZhdWx0Omd9ZnVuY3Rpb24gQ2YoKXt0aGlzLl9fZGF0YV9fPVtdLHRoaXMuc2l6ZT0wfXZhciBSZj1DZjtmdW5jdGlvbiBJZihnLGUpe3JldHVybiBnPT09ZXx8ZyE9PWcmJmUhPT1lfXZhciBMbz1JZixMZj1MbztmdW5jdGlvbiBEZihnLGUpe2Zvcih2YXIgdD1nLmxlbmd0aDt0LS07KWlmKExmKGdbdF1bMF0sZSkpcmV0dXJuIHQ7cmV0dXJuLTF9dmFyIFhuPURmLHdmPVhuLE5mPUFycmF5LnByb3RvdHlwZSxCZj1OZi5zcGxpY2U7ZnVuY3Rpb24gV2YoZyl7dmFyIGU9dGhpcy5fX2RhdGFfXyx0PXdmKGUsZyk7aWYodDwwKXJldHVybiExO3ZhciBuPWUubGVuZ3RoLTE7cmV0dXJuIHQ9PW4/ZS5wb3AoKTpCZi5jYWxsKGUsdCwxKSwtLXRoaXMuc2l6ZSwhMH12YXIgRmY9V2YsamY9WG47ZnVuY3Rpb24gVWYoZyl7dmFyIGU9dGhpcy5fX2RhdGFfXyx0PWpmKGUsZyk7cmV0dXJuIHQ8MD92b2lkIDA6ZVt0XVsxXX12YXIgemY9VWYsJGY9WG47ZnVuY3Rpb24gR2YoZyl7cmV0dXJuICRmKHRoaXMuX19kYXRhX18sZyk+LTF9dmFyIEtmPUdmLEhmPVhuO2Z1bmN0aW9uIFlmKGcsZSl7dmFyIHQ9dGhpcy5fX2RhdGFfXyxuPUhmKHQsZyk7cmV0dXJuIG48MD8oKyt0aGlzLnNpemUsdC5wdXNoKFtnLGVdKSk6dFtuXVsxXT1lLHRoaXN9dmFyIFZmPVlmLFhmPVJmLFpmPUZmLEpmPXpmLFFmPUtmLGtmPVZmO2Z1bmN0aW9uIGVuKGcpe3ZhciBlPS0xLHQ9Zz09bnVsbD8wOmcubGVuZ3RoO2Zvcih0aGlzLmNsZWFyKCk7KytlPHQ7KXt2YXIgbj1nW2VdO3RoaXMuc2V0KG5bMF0sblsxXSl9fWVuLnByb3RvdHlwZS5jbGVhcj1YZixlbi5wcm90b3R5cGUuZGVsZXRlPVpmLGVuLnByb3RvdHlwZS5nZXQ9SmYsZW4ucHJvdG90eXBlLmhhcz1RZixlbi5wcm90b3R5cGUuc2V0PWtmO3ZhciBabj1lbixxZj1abjtmdW5jdGlvbiBfZigpe3RoaXMuX19kYXRhX189bmV3IHFmLHRoaXMuc2l6ZT0wfXZhciB0Yz1fZjtmdW5jdGlvbiBlYyhnKXt2YXIgZT10aGlzLl9fZGF0YV9fLHQ9ZS5kZWxldGUoZyk7cmV0dXJuIHRoaXMuc2l6ZT1lLnNpemUsdH12YXIgcmM9ZWM7ZnVuY3Rpb24gbmMoZyl7cmV0dXJuIHRoaXMuX19kYXRhX18uZ2V0KGcpfXZhciBpYz1uYztmdW5jdGlvbiBzYyhnKXtyZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXMoZyl9dmFyIG9jPXNjLGFjPXR5cGVvZiBtcj09Im9iamVjdCImJm1yJiZtci5PYmplY3Q9PT1PYmplY3QmJm1yLERvPWFjLGxjPURvLHVjPXR5cGVvZiBzZWxmPT0ib2JqZWN0IiYmc2VsZiYmc2VsZi5PYmplY3Q9PT1PYmplY3QmJnNlbGYsZmM9bGN8fHVjfHxGdW5jdGlvbigicmV0dXJuIHRoaXMiKSgpLGFyPWZjLGNjPWFyLGhjPWNjLlN5bWJvbCxraT1oYyx3bz1raSxObz1PYmplY3QucHJvdG90eXBlLGRjPU5vLmhhc093blByb3BlcnR5LGdjPU5vLnRvU3RyaW5nLENuPXdvP3dvLnRvU3RyaW5nVGFnOnZvaWQgMDtmdW5jdGlvbiB2YyhnKXt2YXIgZT1kYy5jYWxsKGcsQ24pLHQ9Z1tDbl07dHJ5e2dbQ25dPXZvaWQgMDt2YXIgbj0hMH1jYXRjaHt9dmFyIGk9Z2MuY2FsbChnKTtyZXR1cm4gbiYmKGU/Z1tDbl09dDpkZWxldGUgZ1tDbl0pLGl9dmFyIHBjPXZjLG1jPU9iamVjdC5wcm90b3R5cGUseWM9bWMudG9TdHJpbmc7ZnVuY3Rpb24geGMoZyl7cmV0dXJuIHljLmNhbGwoZyl9dmFyIE9jPXhjLEJvPWtpLEVjPXBjLE1jPU9jLFNjPSJbb2JqZWN0IE51bGxdIixUYz0iW29iamVjdCBVbmRlZmluZWRdIixXbz1Cbz9Cby50b1N0cmluZ1RhZzp2b2lkIDA7ZnVuY3Rpb24gUGMoZyl7cmV0dXJuIGc9PW51bGw/Zz09PXZvaWQgMD9UYzpTYzpXbyYmV28gaW4gT2JqZWN0KGcpP0VjKGcpOk1jKGcpfXZhciBybj1QYztmdW5jdGlvbiBiYyhnKXt2YXIgZT10eXBlb2YgZztyZXR1cm4gZyE9bnVsbCYmKGU9PSJvYmplY3QifHxlPT0iZnVuY3Rpb24iKX12YXIgQ3I9YmMsQWM9cm4sQ2M9Q3IsUmM9IltvYmplY3QgQXN5bmNGdW5jdGlvbl0iLEljPSJbb2JqZWN0IEZ1bmN0aW9uXSIsTGM9IltvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dIixEYz0iW29iamVjdCBQcm94eV0iO2Z1bmN0aW9uIHdjKGcpe2lmKCFDYyhnKSlyZXR1cm4hMTt2YXIgZT1BYyhnKTtyZXR1cm4gZT09SWN8fGU9PUxjfHxlPT1SY3x8ZT09RGN9dmFyIEZvPXdjLE5jPWFyLEJjPU5jWyJfX2NvcmUtanNfc2hhcmVkX18iXSxXYz1CYyxxaT1XYyxqbz1mdW5jdGlvbigpe3ZhciBnPS9bXi5dKyQvLmV4ZWMocWkmJnFpLmtleXMmJnFpLmtleXMuSUVfUFJPVE98fCIiKTtyZXR1cm4gZz8iU3ltYm9sKHNyYylfMS4iK2c6IiJ9KCk7ZnVuY3Rpb24gRmMoZyl7cmV0dXJuISFqbyYmam8gaW4gZ312YXIgamM9RmMsVWM9RnVuY3Rpb24ucHJvdG90eXBlLHpjPVVjLnRvU3RyaW5nO2Z1bmN0aW9uICRjKGcpe2lmKGchPW51bGwpe3RyeXtyZXR1cm4gemMuY2FsbChnKX1jYXRjaHt9dHJ5e3JldHVybiBnKyIifWNhdGNoe319cmV0dXJuIiJ9dmFyIFVvPSRjLEdjPUZvLEtjPWpjLEhjPUNyLFljPVVvLFZjPS9bXFxeJC4qKz8oKVtcXXt9fF0vZyxYYz0vXlxbb2JqZWN0IC4rP0NvbnN0cnVjdG9yXF0kLyxaYz1GdW5jdGlvbi5wcm90b3R5cGUsSmM9T2JqZWN0LnByb3RvdHlwZSxRYz1aYy50b1N0cmluZyxrYz1KYy5oYXNPd25Qcm9wZXJ0eSxxYz1SZWdFeHAoIl4iK1FjLmNhbGwoa2MpLnJlcGxhY2UoVmMsIlxcJCYiKS5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcKCl8IGZvciAuKz8oPz1cXFxdKS9nLCIkMS4qPyIpKyIkIik7ZnVuY3Rpb24gX2MoZyl7aWYoIUhjKGcpfHxLYyhnKSlyZXR1cm4hMTt2YXIgZT1HYyhnKT9xYzpYYztyZXR1cm4gZS50ZXN0KFljKGcpKX12YXIgdGg9X2M7ZnVuY3Rpb24gZWgoZyxlKXtyZXR1cm4gZz09bnVsbD92b2lkIDA6Z1tlXX12YXIgcmg9ZWgsbmg9dGgsaWg9cmg7ZnVuY3Rpb24gc2goZyxlKXt2YXIgdD1paChnLGUpO3JldHVybiBuaCh0KT90OnZvaWQgMH12YXIgJHI9c2gsb2g9JHIsYWg9YXIsbGg9b2goYWgsIk1hcCIpLF9pPWxoLHVoPSRyLGZoPXVoKE9iamVjdCwiY3JlYXRlIiksSm49Zmgsem89Sm47ZnVuY3Rpb24gY2goKXt0aGlzLl9fZGF0YV9fPXpvP3pvKG51bGwpOnt9LHRoaXMuc2l6ZT0wfXZhciBoaD1jaDtmdW5jdGlvbiBkaChnKXt2YXIgZT10aGlzLmhhcyhnKSYmZGVsZXRlIHRoaXMuX19kYXRhX19bZ107cmV0dXJuIHRoaXMuc2l6ZS09ZT8xOjAsZX12YXIgZ2g9ZGgsdmg9Sm4scGg9Il9fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18iLG1oPU9iamVjdC5wcm90b3R5cGUseWg9bWguaGFzT3duUHJvcGVydHk7ZnVuY3Rpb24geGgoZyl7dmFyIGU9dGhpcy5fX2RhdGFfXztpZih2aCl7dmFyIHQ9ZVtnXTtyZXR1cm4gdD09PXBoP3ZvaWQgMDp0fXJldHVybiB5aC5jYWxsKGUsZyk/ZVtnXTp2b2lkIDB9dmFyIE9oPXhoLEVoPUpuLE1oPU9iamVjdC5wcm90b3R5cGUsU2g9TWguaGFzT3duUHJvcGVydHk7ZnVuY3Rpb24gVGgoZyl7dmFyIGU9dGhpcy5fX2RhdGFfXztyZXR1cm4gRWg/ZVtnXSE9PXZvaWQgMDpTaC5jYWxsKGUsZyl9dmFyIFBoPVRoLGJoPUpuLEFoPSJfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fIjtmdW5jdGlvbiBDaChnLGUpe3ZhciB0PXRoaXMuX19kYXRhX187cmV0dXJuIHRoaXMuc2l6ZSs9dGhpcy5oYXMoZyk/MDoxLHRbZ109YmgmJmU9PT12b2lkIDA/QWg6ZSx0aGlzfXZhciBSaD1DaCxJaD1oaCxMaD1naCxEaD1PaCx3aD1QaCxOaD1SaDtmdW5jdGlvbiBubihnKXt2YXIgZT0tMSx0PWc9PW51bGw/MDpnLmxlbmd0aDtmb3IodGhpcy5jbGVhcigpOysrZTx0Oyl7dmFyIG49Z1tlXTt0aGlzLnNldChuWzBdLG5bMV0pfX1ubi5wcm90b3R5cGUuY2xlYXI9SWgsbm4ucHJvdG90eXBlLmRlbGV0ZT1MaCxubi5wcm90b3R5cGUuZ2V0PURoLG5uLnByb3RvdHlwZS5oYXM9d2gsbm4ucHJvdG90eXBlLnNldD1OaDt2YXIgQmg9bm4sJG89QmgsV2g9Wm4sRmg9X2k7ZnVuY3Rpb24gamgoKXt0aGlzLnNpemU9MCx0aGlzLl9fZGF0YV9fPXtoYXNoOm5ldyAkbyxtYXA6bmV3KEZofHxXaCksc3RyaW5nOm5ldyAkb319dmFyIFVoPWpoO2Z1bmN0aW9uIHpoKGcpe3ZhciBlPXR5cGVvZiBnO3JldHVybiBlPT0ic3RyaW5nInx8ZT09Im51bWJlciJ8fGU9PSJzeW1ib2wifHxlPT0iYm9vbGVhbiI/ZyE9PSJfX3Byb3RvX18iOmc9PT1udWxsfXZhciAkaD16aCxHaD0kaDtmdW5jdGlvbiBLaChnLGUpe3ZhciB0PWcuX19kYXRhX187cmV0dXJuIEdoKGUpP3RbdHlwZW9mIGU9PSJzdHJpbmciPyJzdHJpbmciOiJoYXNoIl06dC5tYXB9dmFyIFFuPUtoLEhoPVFuO2Z1bmN0aW9uIFloKGcpe3ZhciBlPUhoKHRoaXMsZykuZGVsZXRlKGcpO3JldHVybiB0aGlzLnNpemUtPWU/MTowLGV9dmFyIFZoPVloLFhoPVFuO2Z1bmN0aW9uIFpoKGcpe3JldHVybiBYaCh0aGlzLGcpLmdldChnKX12YXIgSmg9WmgsUWg9UW47ZnVuY3Rpb24ga2goZyl7cmV0dXJuIFFoKHRoaXMsZykuaGFzKGcpfXZhciBxaD1raCxfaD1RbjtmdW5jdGlvbiB0ZChnLGUpe3ZhciB0PV9oKHRoaXMsZyksbj10LnNpemU7cmV0dXJuIHQuc2V0KGcsZSksdGhpcy5zaXplKz10LnNpemU9PW4/MDoxLHRoaXN9dmFyIGVkPXRkLHJkPVVoLG5kPVZoLGlkPUpoLHNkPXFoLG9kPWVkO2Z1bmN0aW9uIHNuKGcpe3ZhciBlPS0xLHQ9Zz09bnVsbD8wOmcubGVuZ3RoO2Zvcih0aGlzLmNsZWFyKCk7KytlPHQ7KXt2YXIgbj1nW2VdO3RoaXMuc2V0KG5bMF0sblsxXSl9fXNuLnByb3RvdHlwZS5jbGVhcj1yZCxzbi5wcm90b3R5cGUuZGVsZXRlPW5kLHNuLnByb3RvdHlwZS5nZXQ9aWQsc24ucHJvdG90eXBlLmhhcz1zZCxzbi5wcm90b3R5cGUuc2V0PW9kO3ZhciBhZD1zbixsZD1abix1ZD1faSxmZD1hZCxjZD0yMDA7ZnVuY3Rpb24gaGQoZyxlKXt2YXIgdD10aGlzLl9fZGF0YV9fO2lmKHQgaW5zdGFuY2VvZiBsZCl7dmFyIG49dC5fX2RhdGFfXztpZighdWR8fG4ubGVuZ3RoPGNkLTEpcmV0dXJuIG4ucHVzaChbZyxlXSksdGhpcy5zaXplPSsrdC5zaXplLHRoaXM7dD10aGlzLl9fZGF0YV9fPW5ldyBmZChuKX1yZXR1cm4gdC5zZXQoZyxlKSx0aGlzLnNpemU9dC5zaXplLHRoaXN9dmFyIGRkPWhkLGdkPVpuLHZkPXRjLHBkPXJjLG1kPWljLHlkPW9jLHhkPWRkO2Z1bmN0aW9uIG9uKGcpe3ZhciBlPXRoaXMuX19kYXRhX189bmV3IGdkKGcpO3RoaXMuc2l6ZT1lLnNpemV9b24ucHJvdG90eXBlLmNsZWFyPXZkLG9uLnByb3RvdHlwZS5kZWxldGU9cGQsb24ucHJvdG90eXBlLmdldD1tZCxvbi5wcm90b3R5cGUuaGFzPXlkLG9uLnByb3RvdHlwZS5zZXQ9eGQ7dmFyIE9kPW9uO2Z1bmN0aW9uIEVkKGcsZSl7Zm9yKHZhciB0PS0xLG49Zz09bnVsbD8wOmcubGVuZ3RoOysrdDxuJiZlKGdbdF0sdCxnKSE9PSExOyk7cmV0dXJuIGd9dmFyIE1kPUVkLFNkPSRyLFRkPWZ1bmN0aW9uKCl7dHJ5e3ZhciBnPVNkKE9iamVjdCwiZGVmaW5lUHJvcGVydHkiKTtyZXR1cm4gZyh7fSwiIix7fSksZ31jYXRjaHt9fSgpLFBkPVRkLEdvPVBkO2Z1bmN0aW9uIGJkKGcsZSx0KXtlPT0iX19wcm90b19fIiYmR28/R28oZyxlLHtjb25maWd1cmFibGU6ITAsZW51bWVyYWJsZTohMCx2YWx1ZTp0LHdyaXRhYmxlOiEwfSk6Z1tlXT10fXZhciBLbz1iZCxBZD1LbyxDZD1MbyxSZD1PYmplY3QucHJvdG90eXBlLElkPVJkLmhhc093blByb3BlcnR5O2Z1bmN0aW9uIExkKGcsZSx0KXt2YXIgbj1nW2VdOyghKElkLmNhbGwoZyxlKSYmQ2Qobix0KSl8fHQ9PT12b2lkIDAmJiEoZSBpbiBnKSkmJkFkKGcsZSx0KX12YXIgSG89TGQsRGQ9SG8sd2Q9S287ZnVuY3Rpb24gTmQoZyxlLHQsbil7dmFyIGk9IXQ7dHx8KHQ9e30pO2Zvcih2YXIgZj0tMSxoPWUubGVuZ3RoOysrZjxoOyl7dmFyIHU9ZVtmXSxhPW4/bih0W3VdLGdbdV0sdSx0LGcpOnZvaWQgMDthPT09dm9pZCAwJiYoYT1nW3VdKSxpP3dkKHQsdSxhKTpEZCh0LHUsYSl9cmV0dXJuIHR9dmFyIGtuPU5kO2Z1bmN0aW9uIEJkKGcsZSl7Zm9yKHZhciB0PS0xLG49QXJyYXkoZyk7Kyt0PGc7KW5bdF09ZSh0KTtyZXR1cm4gbn12YXIgV2Q9QmQ7ZnVuY3Rpb24gRmQoZyl7cmV0dXJuIGchPW51bGwmJnR5cGVvZiBnPT0ib2JqZWN0In12YXIgR3I9RmQsamQ9cm4sVWQ9R3IsemQ9IltvYmplY3QgQXJndW1lbnRzXSI7ZnVuY3Rpb24gJGQoZyl7cmV0dXJuIFVkKGcpJiZqZChnKT09emR9dmFyIEdkPSRkLFlvPUdkLEtkPUdyLFZvPU9iamVjdC5wcm90b3R5cGUsSGQ9Vm8uaGFzT3duUHJvcGVydHksWWQ9Vm8ucHJvcGVydHlJc0VudW1lcmFibGUsVmQ9WW8oZnVuY3Rpb24oKXtyZXR1cm4gYXJndW1lbnRzfSgpKT9ZbzpmdW5jdGlvbihnKXtyZXR1cm4gS2QoZykmJkhkLmNhbGwoZywiY2FsbGVlIikmJiFZZC5jYWxsKGcsImNhbGxlZSIpfSxYZD1WZCxaZD1BcnJheS5pc0FycmF5LHRzPVpkLHFuPXtleHBvcnRzOnt9fTtmdW5jdGlvbiBKZCgpe3JldHVybiExfXZhciBRZD1KZDtxbi5leHBvcnRzLGZ1bmN0aW9uKGcsZSl7dmFyIHQ9YXIsbj1RZCxpPWUmJiFlLm5vZGVUeXBlJiZlLGY9aSYmITAmJmcmJiFnLm5vZGVUeXBlJiZnLGg9ZiYmZi5leHBvcnRzPT09aSx1PWg/dC5CdWZmZXI6dm9pZCAwLGE9dT91LmlzQnVmZmVyOnZvaWQgMCxkPWF8fG47Zy5leHBvcnRzPWR9KHFuLHFuLmV4cG9ydHMpO3ZhciBYbz1xbi5leHBvcnRzLGtkPTkwMDcxOTkyNTQ3NDA5OTEscWQ9L14oPzowfFsxLTldXGQqKSQvO2Z1bmN0aW9uIF9kKGcsZSl7dmFyIHQ9dHlwZW9mIGc7cmV0dXJuIGU9ZT8/a2QsISFlJiYodD09Im51bWJlciJ8fHQhPSJzeW1ib2wiJiZxZC50ZXN0KGcpKSYmZz4tMSYmZyUxPT0wJiZnPGV9dmFyIHRnPV9kLGVnPTkwMDcxOTkyNTQ3NDA5OTE7ZnVuY3Rpb24gcmcoZyl7cmV0dXJuIHR5cGVvZiBnPT0ibnVtYmVyIiYmZz4tMSYmZyUxPT0wJiZnPD1lZ312YXIgWm89cmcsbmc9cm4saWc9Wm8sc2c9R3Isb2c9IltvYmplY3QgQXJndW1lbnRzXSIsYWc9IltvYmplY3QgQXJyYXldIixsZz0iW29iamVjdCBCb29sZWFuXSIsdWc9IltvYmplY3QgRGF0ZV0iLGZnPSJbb2JqZWN0IEVycm9yXSIsY2c9IltvYmplY3QgRnVuY3Rpb25dIixoZz0iW29iamVjdCBNYXBdIixkZz0iW29iamVjdCBOdW1iZXJdIixnZz0iW29iamVjdCBPYmplY3RdIix2Zz0iW29iamVjdCBSZWdFeHBdIixwZz0iW29iamVjdCBTZXRdIixtZz0iW29iamVjdCBTdHJpbmddIix5Zz0iW29iamVjdCBXZWFrTWFwXSIseGc9IltvYmplY3QgQXJyYXlCdWZmZXJdIixPZz0iW29iamVjdCBEYXRhVmlld10iLEVnPSJbb2JqZWN0IEZsb2F0MzJBcnJheV0iLE1nPSJbb2JqZWN0IEZsb2F0NjRBcnJheV0iLFNnPSJbb2JqZWN0IEludDhBcnJheV0iLFRnPSJbb2JqZWN0IEludDE2QXJyYXldIixQZz0iW29iamVjdCBJbnQzMkFycmF5XSIsYmc9IltvYmplY3QgVWludDhBcnJheV0iLEFnPSJbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XSIsQ2c9IltvYmplY3QgVWludDE2QXJyYXldIixSZz0iW29iamVjdCBVaW50MzJBcnJheV0iLHZlPXt9O3ZlW0VnXT12ZVtNZ109dmVbU2ddPXZlW1RnXT12ZVtQZ109dmVbYmddPXZlW0FnXT12ZVtDZ109dmVbUmddPSEwLHZlW29nXT12ZVthZ109dmVbeGddPXZlW2xnXT12ZVtPZ109dmVbdWddPXZlW2ZnXT12ZVtjZ109dmVbaGddPXZlW2RnXT12ZVtnZ109dmVbdmddPXZlW3BnXT12ZVttZ109dmVbeWddPSExO2Z1bmN0aW9uIElnKGcpe3JldHVybiBzZyhnKSYmaWcoZy5sZW5ndGgpJiYhIXZlW25nKGcpXX12YXIgTGc9SWc7ZnVuY3Rpb24gRGcoZyl7cmV0dXJuIGZ1bmN0aW9uKGUpe3JldHVybiBnKGUpfX12YXIgZXM9RGcsX249e2V4cG9ydHM6e319O19uLmV4cG9ydHMsZnVuY3Rpb24oZyxlKXt2YXIgdD1EbyxuPWUmJiFlLm5vZGVUeXBlJiZlLGk9biYmITAmJmcmJiFnLm5vZGVUeXBlJiZnLGY9aSYmaS5leHBvcnRzPT09bixoPWYmJnQucHJvY2Vzcyx1PWZ1bmN0aW9uKCl7dHJ5e3ZhciBhPWkmJmkucmVxdWlyZSYmaS5yZXF1aXJlKCJ1dGlsIikudHlwZXM7cmV0dXJuIGF8fGgmJmguYmluZGluZyYmaC5iaW5kaW5nKCJ1dGlsIil9Y2F0Y2h7fX0oKTtnLmV4cG9ydHM9dX0oX24sX24uZXhwb3J0cyk7dmFyIHJzPV9uLmV4cG9ydHMsd2c9TGcsTmc9ZXMsSm89cnMsUW89Sm8mJkpvLmlzVHlwZWRBcnJheSxCZz1Rbz9OZyhRbyk6d2csV2c9QmcsRmc9V2Qsamc9WGQsVWc9dHMsemc9WG8sJGc9dGcsR2c9V2csS2c9T2JqZWN0LnByb3RvdHlwZSxIZz1LZy5oYXNPd25Qcm9wZXJ0eTtmdW5jdGlvbiBZZyhnLGUpe3ZhciB0PVVnKGcpLG49IXQmJmpnKGcpLGk9IXQmJiFuJiZ6ZyhnKSxmPSF0JiYhbiYmIWkmJkdnKGcpLGg9dHx8bnx8aXx8Zix1PWg/RmcoZy5sZW5ndGgsU3RyaW5nKTpbXSxhPXUubGVuZ3RoO2Zvcih2YXIgZCBpbiBnKShlfHxIZy5jYWxsKGcsZCkpJiYhKGgmJihkPT0ibGVuZ3RoInx8aSYmKGQ9PSJvZmZzZXQifHxkPT0icGFyZW50Iil8fGYmJihkPT0iYnVmZmVyInx8ZD09ImJ5dGVMZW5ndGgifHxkPT0iYnl0ZU9mZnNldCIpfHwkZyhkLGEpKSkmJnUucHVzaChkKTtyZXR1cm4gdX12YXIga289WWcsVmc9T2JqZWN0LnByb3RvdHlwZTtmdW5jdGlvbiBYZyhnKXt2YXIgZT1nJiZnLmNvbnN0cnVjdG9yLHQ9dHlwZW9mIGU9PSJmdW5jdGlvbiImJmUucHJvdG90eXBlfHxWZztyZXR1cm4gZz09PXR9dmFyIG5zPVhnO2Z1bmN0aW9uIFpnKGcsZSl7cmV0dXJuIGZ1bmN0aW9uKHQpe3JldHVybiBnKGUodCkpfX12YXIgcW89WmcsSmc9cW8sUWc9SmcoT2JqZWN0LmtleXMsT2JqZWN0KSxrZz1RZyxxZz1ucyxfZz1rZyx0MD1PYmplY3QucHJvdG90eXBlLGUwPXQwLmhhc093blByb3BlcnR5O2Z1bmN0aW9uIHIwKGcpe2lmKCFxZyhnKSlyZXR1cm4gX2coZyk7dmFyIGU9W107Zm9yKHZhciB0IGluIE9iamVjdChnKSllMC5jYWxsKGcsdCkmJnQhPSJjb25zdHJ1Y3RvciImJmUucHVzaCh0KTtyZXR1cm4gZX12YXIgbjA9cjAsaTA9Rm8sczA9Wm87ZnVuY3Rpb24gbzAoZyl7cmV0dXJuIGchPW51bGwmJnMwKGcubGVuZ3RoKSYmIWkwKGcpfXZhciBfbz1vMCxhMD1rbyxsMD1uMCx1MD1fbztmdW5jdGlvbiBmMChnKXtyZXR1cm4gdTAoZyk/YTAoZyk6bDAoZyl9dmFyIGlzPWYwLGMwPWtuLGgwPWlzO2Z1bmN0aW9uIGQwKGcsZSl7cmV0dXJuIGcmJmMwKGUsaDAoZSksZyl9dmFyIGcwPWQwO2Z1bmN0aW9uIHYwKGcpe3ZhciBlPVtdO2lmKGchPW51bGwpZm9yKHZhciB0IGluIE9iamVjdChnKSllLnB1c2godCk7cmV0dXJuIGV9dmFyIHAwPXYwLG0wPUNyLHkwPW5zLHgwPXAwLE8wPU9iamVjdC5wcm90b3R5cGUsRTA9TzAuaGFzT3duUHJvcGVydHk7ZnVuY3Rpb24gTTAoZyl7aWYoIW0wKGcpKXJldHVybiB4MChnKTt2YXIgZT15MChnKSx0PVtdO2Zvcih2YXIgbiBpbiBnKW49PSJjb25zdHJ1Y3RvciImJihlfHwhRTAuY2FsbChnLG4pKXx8dC5wdXNoKG4pO3JldHVybiB0fXZhciBTMD1NMCxUMD1rbyxQMD1TMCxiMD1fbztmdW5jdGlvbiBBMChnKXtyZXR1cm4gYjAoZyk/VDAoZywhMCk6UDAoZyl9dmFyIHNzPUEwLEMwPWtuLFIwPXNzO2Z1bmN0aW9uIEkwKGcsZSl7cmV0dXJuIGcmJkMwKGUsUjAoZSksZyl9dmFyIEwwPUkwLHRpPXtleHBvcnRzOnt9fTt0aS5leHBvcnRzLGZ1bmN0aW9uKGcsZSl7dmFyIHQ9YXIsbj1lJiYhZS5ub2RlVHlwZSYmZSxpPW4mJiEwJiZnJiYhZy5ub2RlVHlwZSYmZyxmPWkmJmkuZXhwb3J0cz09PW4saD1mP3QuQnVmZmVyOnZvaWQgMCx1PWg/aC5hbGxvY1Vuc2FmZTp2b2lkIDA7ZnVuY3Rpb24gYShkLEUpe2lmKEUpcmV0dXJuIGQuc2xpY2UoKTt2YXIgcD1kLmxlbmd0aCxPPXU/dShwKTpuZXcgZC5jb25zdHJ1Y3RvcihwKTtyZXR1cm4gZC5jb3B5KE8pLE99Zy5leHBvcnRzPWF9KHRpLHRpLmV4cG9ydHMpO3ZhciBEMD10aS5leHBvcnRzO2Z1bmN0aW9uIHcwKGcsZSl7dmFyIHQ9LTEsbj1nLmxlbmd0aDtmb3IoZXx8KGU9QXJyYXkobikpOysrdDxuOyllW3RdPWdbdF07cmV0dXJuIGV9dmFyIE4wPXcwO2Z1bmN0aW9uIEIwKGcsZSl7Zm9yKHZhciB0PS0xLG49Zz09bnVsbD8wOmcubGVuZ3RoLGk9MCxmPVtdOysrdDxuOyl7dmFyIGg9Z1t0XTtlKGgsdCxnKSYmKGZbaSsrXT1oKX1yZXR1cm4gZn12YXIgVzA9QjA7ZnVuY3Rpb24gRjAoKXtyZXR1cm5bXX12YXIgdGE9RjAsajA9VzAsVTA9dGEsejA9T2JqZWN0LnByb3RvdHlwZSwkMD16MC5wcm9wZXJ0eUlzRW51bWVyYWJsZSxlYT1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzLEcwPWVhP2Z1bmN0aW9uKGcpe3JldHVybiBnPT1udWxsP1tdOihnPU9iamVjdChnKSxqMChlYShnKSxmdW5jdGlvbihlKXtyZXR1cm4gJDAuY2FsbChnLGUpfSkpfTpVMCxvcz1HMCxLMD1rbixIMD1vcztmdW5jdGlvbiBZMChnLGUpe3JldHVybiBLMChnLEgwKGcpLGUpfXZhciBWMD1ZMDtmdW5jdGlvbiBYMChnLGUpe2Zvcih2YXIgdD0tMSxuPWUubGVuZ3RoLGk9Zy5sZW5ndGg7Kyt0PG47KWdbaSt0XT1lW3RdO3JldHVybiBnfXZhciByYT1YMCxaMD1xbyxKMD1aMChPYmplY3QuZ2V0UHJvdG90eXBlT2YsT2JqZWN0KSxuYT1KMCxRMD1yYSxrMD1uYSxxMD1vcyxfMD10YSx0dj1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzLGV2PXR2P2Z1bmN0aW9uKGcpe2Zvcih2YXIgZT1bXTtnOylRMChlLHEwKGcpKSxnPWswKGcpO3JldHVybiBlfTpfMCxpYT1ldixydj1rbixudj1pYTtmdW5jdGlvbiBpdihnLGUpe3JldHVybiBydihnLG52KGcpLGUpfXZhciBzdj1pdixvdj1yYSxhdj10cztmdW5jdGlvbiBsdihnLGUsdCl7dmFyIG49ZShnKTtyZXR1cm4gYXYoZyk/bjpvdihuLHQoZykpfXZhciBzYT1sdix1dj1zYSxmdj1vcyxjdj1pcztmdW5jdGlvbiBodihnKXtyZXR1cm4gdXYoZyxjdixmdil9dmFyIGR2PWh2LGd2PXNhLHZ2PWlhLHB2PXNzO2Z1bmN0aW9uIG12KGcpe3JldHVybiBndihnLHB2LHZ2KX12YXIgeXY9bXYseHY9JHIsT3Y9YXIsRXY9eHYoT3YsIkRhdGFWaWV3IiksTXY9RXYsU3Y9JHIsVHY9YXIsUHY9U3YoVHYsIlByb21pc2UiKSxidj1QdixBdj0kcixDdj1hcixSdj1BdihDdiwiU2V0IiksSXY9UnYsTHY9JHIsRHY9YXIsd3Y9THYoRHYsIldlYWtNYXAiKSxOdj13dixhcz1Ndixscz1faSx1cz1idixmcz1Jdixjcz1OdixvYT1ybixhbj1VbyxhYT0iW29iamVjdCBNYXBdIixCdj0iW29iamVjdCBPYmplY3RdIixsYT0iW29iamVjdCBQcm9taXNlXSIsdWE9IltvYmplY3QgU2V0XSIsZmE9IltvYmplY3QgV2Vha01hcF0iLGNhPSJbb2JqZWN0IERhdGFWaWV3XSIsV3Y9YW4oYXMpLEZ2PWFuKGxzKSxqdj1hbih1cyksVXY9YW4oZnMpLHp2PWFuKGNzKSxLcj1vYTsoYXMmJktyKG5ldyBhcyhuZXcgQXJyYXlCdWZmZXIoMSkpKSE9Y2F8fGxzJiZLcihuZXcgbHMpIT1hYXx8dXMmJktyKHVzLnJlc29sdmUoKSkhPWxhfHxmcyYmS3IobmV3IGZzKSE9dWF8fGNzJiZLcihuZXcgY3MpIT1mYSkmJihLcj1mdW5jdGlvbihnKXt2YXIgZT1vYShnKSx0PWU9PUJ2P2cuY29uc3RydWN0b3I6dm9pZCAwLG49dD9hbih0KToiIjtpZihuKXN3aXRjaChuKXtjYXNlIFd2OnJldHVybiBjYTtjYXNlIEZ2OnJldHVybiBhYTtjYXNlIGp2OnJldHVybiBsYTtjYXNlIFV2OnJldHVybiB1YTtjYXNlIHp2OnJldHVybiBmYX1yZXR1cm4gZX0pO3ZhciBocz1Lciwkdj1PYmplY3QucHJvdG90eXBlLEd2PSR2Lmhhc093blByb3BlcnR5O2Z1bmN0aW9uIEt2KGcpe3ZhciBlPWcubGVuZ3RoLHQ9bmV3IGcuY29uc3RydWN0b3IoZSk7cmV0dXJuIGUmJnR5cGVvZiBnWzBdPT0ic3RyaW5nIiYmR3YuY2FsbChnLCJpbmRleCIpJiYodC5pbmRleD1nLmluZGV4LHQuaW5wdXQ9Zy5pbnB1dCksdH12YXIgSHY9S3YsWXY9YXIsVnY9WXYuVWludDhBcnJheSxYdj1WdixoYT1YdjtmdW5jdGlvbiBadihnKXt2YXIgZT1uZXcgZy5jb25zdHJ1Y3RvcihnLmJ5dGVMZW5ndGgpO3JldHVybiBuZXcgaGEoZSkuc2V0KG5ldyBoYShnKSksZX12YXIgZHM9WnYsSnY9ZHM7ZnVuY3Rpb24gUXYoZyxlKXt2YXIgdD1lP0p2KGcuYnVmZmVyKTpnLmJ1ZmZlcjtyZXR1cm4gbmV3IGcuY29uc3RydWN0b3IodCxnLmJ5dGVPZmZzZXQsZy5ieXRlTGVuZ3RoKX12YXIga3Y9UXYscXY9L1x3KiQvO2Z1bmN0aW9uIF92KGcpe3ZhciBlPW5ldyBnLmNvbnN0cnVjdG9yKGcuc291cmNlLHF2LmV4ZWMoZykpO3JldHVybiBlLmxhc3RJbmRleD1nLmxhc3RJbmRleCxlfXZhciB0cD1fdixkYT1raSxnYT1kYT9kYS5wcm90b3R5cGU6dm9pZCAwLHZhPWdhP2dhLnZhbHVlT2Y6dm9pZCAwO2Z1bmN0aW9uIGVwKGcpe3JldHVybiB2YT9PYmplY3QodmEuY2FsbChnKSk6e319dmFyIHJwPWVwLG5wPWRzO2Z1bmN0aW9uIGlwKGcsZSl7dmFyIHQ9ZT9ucChnLmJ1ZmZlcik6Zy5idWZmZXI7cmV0dXJuIG5ldyBnLmNvbnN0cnVjdG9yKHQsZy5ieXRlT2Zmc2V0LGcubGVuZ3RoKX12YXIgc3A9aXAsb3A9ZHMsYXA9a3YsbHA9dHAsdXA9cnAsZnA9c3AsY3A9IltvYmplY3QgQm9vbGVhbl0iLGhwPSJbb2JqZWN0IERhdGVdIixkcD0iW29iamVjdCBNYXBdIixncD0iW29iamVjdCBOdW1iZXJdIix2cD0iW29iamVjdCBSZWdFeHBdIixwcD0iW29iamVjdCBTZXRdIixtcD0iW29iamVjdCBTdHJpbmddIix5cD0iW29iamVjdCBTeW1ib2xdIix4cD0iW29iamVjdCBBcnJheUJ1ZmZlcl0iLE9wPSJbb2JqZWN0IERhdGFWaWV3XSIsRXA9IltvYmplY3QgRmxvYXQzMkFycmF5XSIsTXA9IltvYmplY3QgRmxvYXQ2NEFycmF5XSIsU3A9IltvYmplY3QgSW50OEFycmF5XSIsVHA9IltvYmplY3QgSW50MTZBcnJheV0iLFBwPSJbb2JqZWN0IEludDMyQXJyYXldIixicD0iW29iamVjdCBVaW50OEFycmF5XSIsQXA9IltvYmplY3QgVWludDhDbGFtcGVkQXJyYXldIixDcD0iW29iamVjdCBVaW50MTZBcnJheV0iLFJwPSJbb2JqZWN0IFVpbnQzMkFycmF5XSI7ZnVuY3Rpb24gSXAoZyxlLHQpe3ZhciBuPWcuY29uc3RydWN0b3I7c3dpdGNoKGUpe2Nhc2UgeHA6cmV0dXJuIG9wKGcpO2Nhc2UgY3A6Y2FzZSBocDpyZXR1cm4gbmV3IG4oK2cpO2Nhc2UgT3A6cmV0dXJuIGFwKGcsdCk7Y2FzZSBFcDpjYXNlIE1wOmNhc2UgU3A6Y2FzZSBUcDpjYXNlIFBwOmNhc2UgYnA6Y2FzZSBBcDpjYXNlIENwOmNhc2UgUnA6cmV0dXJuIGZwKGcsdCk7Y2FzZSBkcDpyZXR1cm4gbmV3IG47Y2FzZSBncDpjYXNlIG1wOnJldHVybiBuZXcgbihnKTtjYXNlIHZwOnJldHVybiBscChnKTtjYXNlIHBwOnJldHVybiBuZXcgbjtjYXNlIHlwOnJldHVybiB1cChnKX19dmFyIExwPUlwLERwPUNyLHBhPU9iamVjdC5jcmVhdGUsd3A9ZnVuY3Rpb24oKXtmdW5jdGlvbiBnKCl7fXJldHVybiBmdW5jdGlvbihlKXtpZighRHAoZSkpcmV0dXJue307aWYocGEpcmV0dXJuIHBhKGUpO2cucHJvdG90eXBlPWU7dmFyIHQ9bmV3IGc7cmV0dXJuIGcucHJvdG90eXBlPXZvaWQgMCx0fX0oKSxOcD13cCxCcD1OcCxXcD1uYSxGcD1ucztmdW5jdGlvbiBqcChnKXtyZXR1cm4gdHlwZW9mIGcuY29uc3RydWN0b3I9PSJmdW5jdGlvbiImJiFGcChnKT9CcChXcChnKSk6e319dmFyIFVwPWpwLHpwPWhzLCRwPUdyLEdwPSJbb2JqZWN0IE1hcF0iO2Z1bmN0aW9uIEtwKGcpe3JldHVybiAkcChnKSYmenAoZyk9PUdwfXZhciBIcD1LcCxZcD1IcCxWcD1lcyxtYT1ycyx5YT1tYSYmbWEuaXNNYXAsWHA9eWE/VnAoeWEpOllwLFpwPVhwLEpwPWhzLFFwPUdyLGtwPSJbb2JqZWN0IFNldF0iO2Z1bmN0aW9uIHFwKGcpe3JldHVybiBRcChnKSYmSnAoZyk9PWtwfXZhciBfcD1xcCx0MT1fcCxlMT1lcyx4YT1ycyxPYT14YSYmeGEuaXNTZXQscjE9T2E/ZTEoT2EpOnQxLG4xPXIxLGkxPU9kLHMxPU1kLG8xPUhvLGExPWcwLGwxPUwwLHUxPUQwLGYxPU4wLGMxPVYwLGgxPXN2LGQxPWR2LGcxPXl2LHYxPWhzLHAxPUh2LG0xPUxwLHkxPVVwLHgxPXRzLE8xPVhvLEUxPVpwLE0xPUNyLFMxPW4xLFQxPWlzLFAxPXNzLGIxPTEsQTE9MixDMT00LEVhPSJbb2JqZWN0IEFyZ3VtZW50c10iLFIxPSJbb2JqZWN0IEFycmF5XSIsSTE9IltvYmplY3QgQm9vbGVhbl0iLEwxPSJbb2JqZWN0IERhdGVdIixEMT0iW29iamVjdCBFcnJvcl0iLE1hPSJbb2JqZWN0IEZ1bmN0aW9uXSIsdzE9IltvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dIixOMT0iW29iamVjdCBNYXBdIixCMT0iW29iamVjdCBOdW1iZXJdIixTYT0iW29iamVjdCBPYmplY3RdIixXMT0iW29iamVjdCBSZWdFeHBdIixGMT0iW29iamVjdCBTZXRdIixqMT0iW29iamVjdCBTdHJpbmddIixVMT0iW29iamVjdCBTeW1ib2xdIix6MT0iW29iamVjdCBXZWFrTWFwXSIsJDE9IltvYmplY3QgQXJyYXlCdWZmZXJdIixHMT0iW29iamVjdCBEYXRhVmlld10iLEsxPSJbb2JqZWN0IEZsb2F0MzJBcnJheV0iLEgxPSJbb2JqZWN0IEZsb2F0NjRBcnJheV0iLFkxPSJbb2JqZWN0IEludDhBcnJheV0iLFYxPSJbb2JqZWN0IEludDE2QXJyYXldIixYMT0iW29iamVjdCBJbnQzMkFycmF5XSIsWjE9IltvYmplY3QgVWludDhBcnJheV0iLEoxPSJbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XSIsUTE9IltvYmplY3QgVWludDE2QXJyYXldIixrMT0iW29iamVjdCBVaW50MzJBcnJheV0iLGRlPXt9O2RlW0VhXT1kZVtSMV09ZGVbJDFdPWRlW0cxXT1kZVtJMV09ZGVbTDFdPWRlW0sxXT1kZVtIMV09ZGVbWTFdPWRlW1YxXT1kZVtYMV09ZGVbTjFdPWRlW0IxXT1kZVtTYV09ZGVbVzFdPWRlW0YxXT1kZVtqMV09ZGVbVTFdPWRlW1oxXT1kZVtKMV09ZGVbUTFdPWRlW2sxXT0hMCxkZVtEMV09ZGVbTWFdPWRlW3oxXT0hMTtmdW5jdGlvbiBlaShnLGUsdCxuLGksZil7dmFyIGgsdT1lJmIxLGE9ZSZBMSxkPWUmQzE7aWYodCYmKGg9aT90KGcsbixpLGYpOnQoZykpLGghPT12b2lkIDApcmV0dXJuIGg7aWYoIU0xKGcpKXJldHVybiBnO3ZhciBFPXgxKGcpO2lmKEUpe2lmKGg9cDEoZyksIXUpcmV0dXJuIGYxKGcsaCl9ZWxzZXt2YXIgcD12MShnKSxPPXA9PU1hfHxwPT13MTtpZihPMShnKSlyZXR1cm4gdTEoZyx1KTtpZihwPT1TYXx8cD09RWF8fE8mJiFpKXtpZihoPWF8fE8/e306eTEoZyksIXUpcmV0dXJuIGE/aDEoZyxsMShoLGcpKTpjMShnLGExKGgsZykpfWVsc2V7aWYoIWRlW3BdKXJldHVybiBpP2c6e307aD1tMShnLHAsdSl9fWZ8fChmPW5ldyBpMSk7dmFyIG09Zi5nZXQoZyk7aWYobSlyZXR1cm4gbTtmLnNldChnLGgpLFMxKGcpP2cuZm9yRWFjaChmdW5jdGlvbih5KXtoLmFkZChlaSh5LGUsdCx5LGcsZikpfSk6RTEoZykmJmcuZm9yRWFjaChmdW5jdGlvbih5LFMpe2guc2V0KFMsZWkoeSxlLHQsUyxnLGYpKX0pO3ZhciBiPWQ/YT9nMTpkMTphP1AxOlQxLE09RT92b2lkIDA6YihnKTtyZXR1cm4gczEoTXx8ZyxmdW5jdGlvbih5LFMpe00mJihTPXkseT1nW1NdKSxvMShoLFMsZWkoeSxlLHQsUyxnLGYpKX0pLGh9dmFyIHExPWVpLF8xPXExLHRtPTEsZW09NDtmdW5jdGlvbiBybShnKXtyZXR1cm4gXzEoZyx0bXxlbSl9dmFyIG5tPXJtLGRyPVZuKG5tKSxUYTsoZnVuY3Rpb24oZyl7Z1tnLnBlZGRpbmc9MF09InBlZGRpbmciLGdbZy5tb3VudGVkPTFdPSJtb3VudGVkIixnW2cudXBkYXRlPTJdPSJ1cGRhdGUiLGdbZy51bm1vdW50ZWQ9M109InVubW91bnRlZCJ9KShUYXx8KFRhPXt9KSk7dmFyIFJlOyhmdW5jdGlvbihnKXtnW2cuTm9ybWFsPTBdPSJOb3JtYWwiLGdbZy5TdHJva2U9MV09IlN0cm9rZSIsZ1tnLkRvdHRlZD0yXT0iRG90dGVkIixnW2cuTG9uZ0RvdHRlZD0zXT0iTG9uZ0RvdHRlZCJ9KShSZXx8KFJlPXt9KSk7dmFyIFBhOyhmdW5jdGlvbihnKXtnLlRyaWFuZ2xlPSJ0cmlhbmdsZSIsZy5SaG9tYnVzPSJyaG9tYnVzIixnLlBlbnRhZ3JhbT0icGVudGFncmFtIixnLlNwZWVjaEJhbGxvb249InNwZWVjaEJhbGxvb24iLGcuU3Rhcj0ic3RhciIsZy5Qb2x5Z29uPSJwb2x5Z29uIn0pKFBhfHwoUGE9e30pKTt2YXIgb2U7KGZ1bmN0aW9uKGcpe2cuTm9uZT0iTm9uZSIsZy5TaG93RmxvYXRCYXI9IlNob3dGbG9hdEJhciIsZy5aSW5kZXhGbG9hdEJhcj0iWkluZGV4RmxvYXRCYXIiLGcuRGVsZXRlTm9kZT0iRGVsZXRlTm9kZSIsZy5Db3B5Tm9kZT0iQ29weU5vZGUiLGcuWkluZGV4QWN0aXZlPSJaSW5kZXhBY3RpdmUiLGcuWkluZGV4Tm9kZT0iWkluZGV4Tm9kZSIsZy5Sb3RhdGVOb2RlPSJSb3RhdGVOb2RlIixnLlNldENvbG9yTm9kZT0iU2V0Q29sb3JOb2RlIixnLlRyYW5zbGF0ZU5vZGU9IlRyYW5zbGF0ZU5vZGUiLGcuU2NhbGVOb2RlPSJTY2FsZU5vZGUiLGcuT3JpZ2luYWxFdmVudD0iT3JpZ2luYWxFdmVudCIsZy5DcmVhdGVTY2VuZT0iQ3JlYXRlU2NlbmUiLGcuQWN0aXZlQ3Vyc29yPSJBY3RpdmVDdXJzb3IiLGcuTW92ZUN1cnNvcj0iTW92ZUN1cnNvciIsZy5Db21tYW5kRWRpdG9yPSJDb21tYW5kRWRpdG9yIixnLlNldEVkaXRvckRhdGE9IlNldEVkaXRvckRhdGEifSkob2V8fChvZT17fSkpO3ZhciBiYTsoZnVuY3Rpb24oZyl7Zy5EaXNwbGF5U3RhdGU9IkRpc3BsYXlTdGF0ZSIsZy5GbG9hdEJhcj0iRmxvYXRCYXIiLGcuQ2FudmFzU2VsZWN0b3I9IkNhbnZhc1NlbGVjdG9yIixnLk1haW5FbmdpbmU9Ik1haW5FbmdpbmUiLGcuRGlzcGxheUNvbnRhaW5lcj0iRGlzcGxheUNvbnRhaW5lciIsZy5DdXJzb3I9IkN1cnNvciIsZy5UZXh0RWRpdG9yPSJUZXh0RWRpdG9yIixnLkJpbmRNYWluVmlldz0iQmluZE1haW5WaWV3IixnLk1vdW50TWFpblZpZXc9Ik1vdW50TWFpblZpZXciLGcuTW91bnRBcHBWaWV3PSJNb3VudEFwcFZpZXcifSkoYmF8fChiYT17fSkpO3ZhciBBYTsoZnVuY3Rpb24oZyl7Z1tnLk1haW5WaWV3PTBdPSJNYWluVmlldyIsZ1tnLlBsdWdpbj0xXT0iUGx1Z2luIixnW2cuQm90aD0yXT0iQm90aCJ9KShBYXx8KEFhPXt9KSk7dmFyIEx0OyhmdW5jdGlvbihnKXtnW2cuUGVuY2lsPTFdPSJQZW5jaWwiLGdbZy5FcmFzZXI9Ml09IkVyYXNlciIsZ1tnLlNlbGVjdG9yPTNdPSJTZWxlY3RvciIsZ1tnLkNsaWNrZXI9NF09IkNsaWNrZXIiLGdbZy5BcnJvdz01XT0iQXJyb3ciLGdbZy5IYW5kPTZdPSJIYW5kIixnW2cuTGFzZXJQZW49N109Ikxhc2VyUGVuIixnW2cuVGV4dD04XT0iVGV4dCIsZ1tnLlN0cmFpZ2h0PTldPSJTdHJhaWdodCIsZ1tnLlJlY3RhbmdsZT0xMF09IlJlY3RhbmdsZSIsZ1tnLkVsbGlwc2U9MTFdPSJFbGxpcHNlIixnW2cuU3Rhcj0xMl09IlN0YXIiLGdbZy5UcmlhbmdsZT0xM109IlRyaWFuZ2xlIixnW2cuUmhvbWJ1cz0xNF09IlJob21idXMiLGdbZy5Qb2x5Z29uPTE1XT0iUG9seWdvbiIsZ1tnLlNwZWVjaEJhbGxvb249MTZdPSJTcGVlY2hCYWxsb29uIn0pKEx0fHwoTHQ9e30pKTt2YXIgenQ7KGZ1bmN0aW9uKGcpe2dbZy5Mb2NhbD0xXT0iTG9jYWwiLGdbZy5TZXJ2aWNlPTJdPSJTZXJ2aWNlIixnW2cuV29ya2VyPTNdPSJXb3JrZXIifSkoenR8fCh6dD17fSkpO3ZhciBjZTsoZnVuY3Rpb24oZyl7Z1tnLlBlbmRpbmc9MF09IlBlbmRpbmciLGdbZy5TdGFydD0xXT0iU3RhcnQiLGdbZy5Eb2luZz0yXT0iRG9pbmciLGdbZy5Eb25lPTNdPSJEb25lIixnW2cuRnJlZXplPTRdPSJGcmVlemUiLGdbZy5VbndyaXRhYmxlPTVdPSJVbndyaXRhYmxlIn0pKGNlfHwoY2U9e30pKTt2YXIgVHQ7KGZ1bmN0aW9uKGcpe2dbZy5Jbml0PTBdPSJJbml0IixnW2cuVXBkYXRlQ2FtZXJhPTFdPSJVcGRhdGVDYW1lcmEiLGdbZy5VcGRhdGVUb29scz0yXT0iVXBkYXRlVG9vbHMiLGdbZy5DcmVhdGVXb3JrPTNdPSJDcmVhdGVXb3JrIixnW2cuRHJhd1dvcms9NF09IkRyYXdXb3JrIixnW2cuRnVsbFdvcms9NV09IkZ1bGxXb3JrIixnW2cuVXBkYXRlTm9kZT02XT0iVXBkYXRlTm9kZSIsZ1tnLlJlbW92ZU5vZGU9N109IlJlbW92ZU5vZGUiLGdbZy5DbGVhcj04XT0iQ2xlYXIiLGdbZy5TZWxlY3Q9OV09IlNlbGVjdCIsZ1tnLkRlc3Ryb3k9MTBdPSJEZXN0cm95IixnW2cuTm9uZT0xMV09Ik5vbmUiLGdbZy5TbmFwc2hvdD0xMl09IlNuYXBzaG90IixnW2cuQm91bmRpbmdCb3g9MTNdPSJCb3VuZGluZ0JveCIsZ1tnLkN1cnNvcj0xNF09IkN1cnNvciIsZ1tnLlRleHRVcGRhdGU9MTVdPSJUZXh0VXBkYXRlIixnW2cuR2V0VGV4dEFjdGl2ZT0xNl09IkdldFRleHRBY3RpdmUiLGdbZy5UYXNrc1F1ZXVlPTE3XT0iVGFza3NRdWV1ZSJ9KShUdHx8KFR0PXt9KSk7dmFyIENhOyhmdW5jdGlvbihnKXtnLldlYmdsMj0id2ViZ2wyIixnLldlYmdsPSJ3ZWJnbCIsZy5DYW52YXMyZD0iMmQifSkoQ2F8fChDYT17fSkpO3ZhciBCdDsoZnVuY3Rpb24oZyl7Z1tnLkZsb2F0PTFdPSJGbG9hdCIsZ1tnLkJnPTJdPSJCZyIsZ1tnLlNlbGVjdG9yPTNdPSJTZWxlY3RvciIsZ1tnLk5vbmU9NF09Ik5vbmUifSkoQnR8fChCdD17fSkpO3ZhciBSYTsoZnVuY3Rpb24oZyl7Z1tnLkN1cnNvcj0xXT0iQ3Vyc29yIixnW2cuVGV4dENyZWF0ZT0yXT0iVGV4dENyZWF0ZSJ9KShSYXx8KFJhPXt9KSk7dmFyIElhOyhmdW5jdGlvbihnKXtnW2cuVG9wPTFdPSJUb3AiLGdbZy5Cb3R0b209Ml09IkJvdHRvbSJ9KShJYXx8KElhPXt9KSk7dmFyICRlOyhmdW5jdGlvbihnKXtnW2cubm9uZT0xXT0ibm9uZSIsZ1tnLmFsbD0yXT0iYWxsIixnW2cuYm90aD0zXT0iYm90aCJ9KSgkZXx8KCRlPXt9KSk7Y2xhc3MgUnJ7Y29uc3RydWN0b3IoKXtPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywibG9jYWxXb3JrIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInNlcnZpY2VXb3JrIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSl9cmVnaXN0ZXJGb3JXb3JrZXIoZSx0KXtyZXR1cm4gdGhpcy5sb2NhbFdvcms9ZSx0aGlzLnNlcnZpY2VXb3JrPXQsdGhpc319Y29uc3QgaW09e2xpbmVhcjpnPT5nLGVhc2VJblF1YWQ6Zz0+ZypnLGVhc2VPdXRRdWFkOmc9PmcqKDItZyksZWFzZUluT3V0UXVhZDpnPT5nPC41PzIqZypnOi0xKyg0LTIqZykqZyxlYXNlSW5DdWJpYzpnPT5nKmcqZyxlYXNlT3V0Q3ViaWM6Zz0+LS1nKmcqZysxLGVhc2VJbk91dEN1YmljOmc9Pmc8LjU/NCpnKmcqZzooZy0xKSooMipnLTIpKigyKmctMikrMSxlYXNlSW5RdWFydDpnPT5nKmcqZypnLGVhc2VPdXRRdWFydDpnPT4xLSAtLWcqZypnKmcsZWFzZUluT3V0UXVhcnQ6Zz0+ZzwuNT84KmcqZypnKmc6MS04Ki0tZypnKmcqZyxlYXNlSW5RdWludDpnPT5nKmcqZypnKmcsZWFzZU91dFF1aW50Omc9PjErLS1nKmcqZypnKmcsZWFzZUluT3V0UXVpbnQ6Zz0+ZzwuNT8xNipnKmcqZypnKmc6MSsxNiotLWcqZypnKmcqZyxlYXNlSW5TaW5lOmc9PjEtTWF0aC5jb3MoZypNYXRoLlBJLzIpLGVhc2VPdXRTaW5lOmc9Pk1hdGguc2luKGcqTWF0aC5QSS8yKSxlYXNlSW5PdXRTaW5lOmc9Pi0oTWF0aC5jb3MoTWF0aC5QSSpnKS0xKS8yLGVhc2VJbkV4cG86Zz0+Zzw9MD8wOk1hdGgucG93KDIsMTAqZy0xMCksZWFzZU91dEV4cG86Zz0+Zz49MT8xOjEtTWF0aC5wb3coMiwtMTAqZyksZWFzZUluT3V0RXhwbzpnPT5nPD0wPzA6Zz49MT8xOmc8LjU/TWF0aC5wb3coMiwyMCpnLTEwKS8yOigyLU1hdGgucG93KDIsLTIwKmcrMTApKS8yfTtjbGFzcyBFdHtjb25zdHJ1Y3RvcihlPTAsdD0wLG49MSl7T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIngiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTplfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInkiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp0fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInoiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpufSl9Z2V0IFhZKCl7cmV0dXJuW3RoaXMueCx0aGlzLnldfXNldHooZSl7cmV0dXJuIHRoaXMuej1lLHRoaXN9c2V0WFkoZT10aGlzLngsdD10aGlzLnkpe3JldHVybiB0aGlzLng9ZSx0aGlzLnk9dCx0aGlzfXNldChlPXRoaXMueCx0PXRoaXMueSxuPXRoaXMueil7cmV0dXJuIHRoaXMueD1lLHRoaXMueT10LHRoaXMuej1uLHRoaXN9c2V0VG8oe3g6ZT0wLHk6dD0wLHo6bj0xfSl7cmV0dXJuIHRoaXMueD1lLHRoaXMueT10LHRoaXMuej1uLHRoaXN9cm90KGUpe2lmKGU9PT0wKXJldHVybiB0aGlzO2NvbnN0e3g6dCx5Om59PXRoaXMsaT1NYXRoLnNpbihlKSxmPU1hdGguY29zKGUpO3JldHVybiB0aGlzLng9dCpmLW4qaSx0aGlzLnk9dCppK24qZix0aGlzfXJvdFdpdGgoZSx0KXtpZih0PT09MClyZXR1cm4gdGhpcztjb25zdCBuPXRoaXMueC1lLngsaT10aGlzLnktZS55LGY9TWF0aC5zaW4odCksaD1NYXRoLmNvcyh0KTtyZXR1cm4gdGhpcy54PWUueCsobipoLWkqZiksdGhpcy55PWUueSsobipmK2kqaCksdGhpc31jbG9uZSgpe2NvbnN0e3g6ZSx5OnQsejpufT10aGlzO3JldHVybiBuZXcgRXQoZSx0LG4pfXN1YihlKXtyZXR1cm4gdGhpcy54LT1lLngsdGhpcy55LT1lLnksdGhpc31zdWJYWShlLHQpe3JldHVybiB0aGlzLngtPWUsdGhpcy55LT10LHRoaXN9c3ViU2NhbGFyKGUpe3JldHVybiB0aGlzLngtPWUsdGhpcy55LT1lLHRoaXN9YWRkKGUpe3JldHVybiB0aGlzLngrPWUueCx0aGlzLnkrPWUueSx0aGlzfWFkZFhZKGUsdCl7cmV0dXJuIHRoaXMueCs9ZSx0aGlzLnkrPXQsdGhpc31hZGRTY2FsYXIoZSl7cmV0dXJuIHRoaXMueCs9ZSx0aGlzLnkrPWUsdGhpc31jbGFtcChlLHQpe3JldHVybiB0aGlzLng9TWF0aC5tYXgodGhpcy54LGUpLHRoaXMueT1NYXRoLm1heCh0aGlzLnksZSksdCE9PXZvaWQgMCYmKHRoaXMueD1NYXRoLm1pbih0aGlzLngsdCksdGhpcy55PU1hdGgubWluKHRoaXMueSx0KSksdGhpc31kaXYoZSl7cmV0dXJuIHRoaXMueC89ZSx0aGlzLnkvPWUsdGhpc31kaXZWKGUpe3JldHVybiB0aGlzLngvPWUueCx0aGlzLnkvPWUueSx0aGlzfW11bChlKXtyZXR1cm4gdGhpcy54Kj1lLHRoaXMueSo9ZSx0aGlzfW11bFYoZSl7cmV0dXJuIHRoaXMueCo9ZS54LHRoaXMueSo9ZS55LHRoaXN9YWJzKCl7cmV0dXJuIHRoaXMueD1NYXRoLmFicyh0aGlzLngpLHRoaXMueT1NYXRoLmFicyh0aGlzLnkpLHRoaXN9bnVkZ2UoZSx0KXtjb25zdCBuPUV0LlRhbihlLHRoaXMpO3JldHVybiB0aGlzLmFkZChuLm11bCh0KSl9bmVnKCl7cmV0dXJuIHRoaXMueCo9LTEsdGhpcy55Kj0tMSx0aGlzfWNyb3NzKGUpe3JldHVybiB0aGlzLng9dGhpcy55KmUuei10aGlzLnoqZS55LHRoaXMueT10aGlzLnoqZS54LXRoaXMueCplLnosdGhpc31kcHIoZSl7cmV0dXJuIEV0LkRwcih0aGlzLGUpfWNwcihlKXtyZXR1cm4gRXQuQ3ByKHRoaXMsZSl9bGVuMigpe3JldHVybiBFdC5MZW4yKHRoaXMpfWxlbigpe3JldHVybiBFdC5MZW4odGhpcyl9cHJ5KGUpe3JldHVybiBFdC5QcnkodGhpcyxlKX1wZXIoKXtjb25zdHt4OmUseTp0fT10aGlzO3JldHVybiB0aGlzLng9dCx0aGlzLnk9LWUsdGhpc311bmkoKXtyZXR1cm4gRXQuVW5pKHRoaXMpfXRhbihlKXtyZXR1cm4gRXQuVGFuKHRoaXMsZSl9ZGlzdChlKXtyZXR1cm4gRXQuRGlzdCh0aGlzLGUpfWRpc3RhbmNlVG9MaW5lU2VnbWVudChlLHQpe3JldHVybiBFdC5EaXN0YW5jZVRvTGluZVNlZ21lbnQoZSx0LHRoaXMpfXNsb3BlKGUpe3JldHVybiBFdC5TbG9wZSh0aGlzLGUpfXNuYXBUb0dyaWQoZSl7cmV0dXJuIHRoaXMueD1NYXRoLnJvdW5kKHRoaXMueC9lKSplLHRoaXMueT1NYXRoLnJvdW5kKHRoaXMueS9lKSplLHRoaXN9YW5nbGUoZSl7cmV0dXJuIEV0LkFuZ2xlKHRoaXMsZSl9dG9BbmdsZSgpe3JldHVybiBFdC5Ub0FuZ2xlKHRoaXMpfWxycChlLHQpe3JldHVybiB0aGlzLng9dGhpcy54KyhlLngtdGhpcy54KSp0LHRoaXMueT10aGlzLnkrKGUueS10aGlzLnkpKnQsdGhpc31lcXVhbHMoZSx0KXtyZXR1cm4gRXQuRXF1YWxzKHRoaXMsZSx0KX1lcXVhbHNYWShlLHQpe3JldHVybiBFdC5FcXVhbHNYWSh0aGlzLGUsdCl9bm9ybSgpe2NvbnN0IGU9dGhpcy5sZW4oKTtyZXR1cm4gdGhpcy54PWU9PT0wPzA6dGhpcy54L2UsdGhpcy55PWU9PT0wPzA6dGhpcy55L2UsdGhpc310b0ZpeGVkKCl7cmV0dXJuIEV0LlRvRml4ZWQodGhpcyl9dG9TdHJpbmcoKXtyZXR1cm4gRXQuVG9TdHJpbmcoRXQuVG9GaXhlZCh0aGlzKSl9dG9Kc29uKCl7cmV0dXJuIEV0LlRvSnNvbih0aGlzKX10b0FycmF5KCl7cmV0dXJuIEV0LlRvQXJyYXkodGhpcyl9c3RhdGljIEFkZChlLHQpe3JldHVybiBuZXcgRXQoZS54K3QueCxlLnkrdC55KX1zdGF0aWMgQWRkWFkoZSx0LG4pe3JldHVybiBuZXcgRXQoZS54K3QsZS55K24pfXN0YXRpYyBTdWIoZSx0KXtyZXR1cm4gbmV3IEV0KGUueC10LngsZS55LXQueSl9c3RhdGljIFN1YlhZKGUsdCxuKXtyZXR1cm4gbmV3IEV0KGUueC10LGUueS1uKX1zdGF0aWMgQWRkU2NhbGFyKGUsdCl7cmV0dXJuIG5ldyBFdChlLngrdCxlLnkrdCl9c3RhdGljIFN1YlNjYWxhcihlLHQpe3JldHVybiBuZXcgRXQoZS54LXQsZS55LXQpfXN0YXRpYyBEaXYoZSx0KXtyZXR1cm4gbmV3IEV0KGUueC90LGUueS90KX1zdGF0aWMgTXVsKGUsdCl7cmV0dXJuIG5ldyBFdChlLngqdCxlLnkqdCl9c3RhdGljIERpdlYoZSx0KXtyZXR1cm4gbmV3IEV0KGUueC90LngsZS55L3QueSl9c3RhdGljIE11bFYoZSx0KXtyZXR1cm4gbmV3IEV0KGUueCp0LngsZS55KnQueSl9c3RhdGljIE5lZyhlKXtyZXR1cm4gbmV3IEV0KC1lLngsLWUueSl9c3RhdGljIFBlcihlKXtyZXR1cm4gbmV3IEV0KGUueSwtZS54KX1zdGF0aWMgRGlzdDIoZSx0KXtyZXR1cm4gRXQuU3ViKGUsdCkubGVuMigpfXN0YXRpYyBBYnMoZSl7cmV0dXJuIG5ldyBFdChNYXRoLmFicyhlLngpLE1hdGguYWJzKGUueSkpfXN0YXRpYyBEaXN0KGUsdCl7cmV0dXJuIE1hdGguaHlwb3QoZS55LXQueSxlLngtdC54KX1zdGF0aWMgRHByKGUsdCl7cmV0dXJuIGUueCp0LngrZS55KnQueX1zdGF0aWMgQ3Jvc3MoZSx0KXtyZXR1cm4gbmV3IEV0KGUueSp0LnotZS56KnQueSxlLnoqdC54LWUueCp0LnopfXN0YXRpYyBDcHIoZSx0KXtyZXR1cm4gZS54KnQueS10LngqZS55fXN0YXRpYyBMZW4yKGUpe3JldHVybiBlLngqZS54K2UueSplLnl9c3RhdGljIExlbihlKXtyZXR1cm4gTWF0aC5oeXBvdChlLngsZS55KX1zdGF0aWMgUHJ5KGUsdCl7cmV0dXJuIEV0LkRwcihlLHQpL0V0Lkxlbih0KX1zdGF0aWMgVW5pKGUpe3JldHVybiBFdC5EaXYoZSxFdC5MZW4oZSkpfXN0YXRpYyBUYW4oZSx0KXtyZXR1cm4gRXQuVW5pKEV0LlN1YihlLHQpKX1zdGF0aWMgTWluKGUsdCl7cmV0dXJuIG5ldyBFdChNYXRoLm1pbihlLngsdC54KSxNYXRoLm1pbihlLnksdC55KSl9c3RhdGljIE1heChlLHQpe3JldHVybiBuZXcgRXQoTWF0aC5tYXgoZS54LHQueCksTWF0aC5tYXgoZS55LHQueSkpfXN0YXRpYyBGcm9tKGUpe3JldHVybiBuZXcgRXQoKS5hZGQoZSl9c3RhdGljIEZyb21BcnJheShlKXtyZXR1cm4gbmV3IEV0KGVbMF0sZVsxXSl9c3RhdGljIFJvdChlLHQ9MCl7Y29uc3Qgbj1NYXRoLnNpbih0KSxpPU1hdGguY29zKHQpO3JldHVybiBuZXcgRXQoZS54KmktZS55Km4sZS54Km4rZS55KmkpfXN0YXRpYyBSb3RXaXRoKGUsdCxuKXtjb25zdCBpPWUueC10LngsZj1lLnktdC55LGg9TWF0aC5zaW4obiksdT1NYXRoLmNvcyhuKTtyZXR1cm4gbmV3IEV0KHQueCsoaSp1LWYqaCksdC55KyhpKmgrZip1KSl9c3RhdGljIE5lYXJlc3RQb2ludE9uTGluZVRocm91Z2hQb2ludChlLHQsbil7cmV0dXJuIEV0Lk11bCh0LEV0LlN1YihuLGUpLnByeSh0KSkuYWRkKGUpfXN0YXRpYyBOZWFyZXN0UG9pbnRPbkxpbmVTZWdtZW50KGUsdCxuLGk9ITApe2NvbnN0IGY9RXQuVGFuKHQsZSksaD1FdC5BZGQoZSxFdC5NdWwoZixFdC5TdWIobixlKS5wcnkoZikpKTtpZihpKXtpZihoLng8TWF0aC5taW4oZS54LHQueCkpcmV0dXJuIEV0LkNhc3QoZS54PHQueD9lOnQpO2lmKGgueD5NYXRoLm1heChlLngsdC54KSlyZXR1cm4gRXQuQ2FzdChlLng+dC54P2U6dCk7aWYoaC55PE1hdGgubWluKGUueSx0LnkpKXJldHVybiBFdC5DYXN0KGUueTx0Lnk/ZTp0KTtpZihoLnk+TWF0aC5tYXgoZS55LHQueSkpcmV0dXJuIEV0LkNhc3QoZS55PnQueT9lOnQpfXJldHVybiBofXN0YXRpYyBEaXN0YW5jZVRvTGluZVRocm91Z2hQb2ludChlLHQsbil7cmV0dXJuIEV0LkRpc3QobixFdC5OZWFyZXN0UG9pbnRPbkxpbmVUaHJvdWdoUG9pbnQoZSx0LG4pKX1zdGF0aWMgRGlzdGFuY2VUb0xpbmVTZWdtZW50KGUsdCxuLGk9ITApe3JldHVybiBFdC5EaXN0KG4sRXQuTmVhcmVzdFBvaW50T25MaW5lU2VnbWVudChlLHQsbixpKSl9c3RhdGljIFNuYXAoZSx0PTEpe3JldHVybiBuZXcgRXQoTWF0aC5yb3VuZChlLngvdCkqdCxNYXRoLnJvdW5kKGUueS90KSp0KX1zdGF0aWMgQ2FzdChlKXtyZXR1cm4gZSBpbnN0YW5jZW9mIEV0P2U6RXQuRnJvbShlKX1zdGF0aWMgU2xvcGUoZSx0KXtyZXR1cm4gZS54PT09dC55P05hTjooZS55LXQueSkvKGUueC10LngpfXN0YXRpYyBBbmdsZShlLHQpe3JldHVybiBNYXRoLmF0YW4yKHQueS1lLnksdC54LWUueCl9c3RhdGljIExycChlLHQsbil7cmV0dXJuIEV0LlN1Yih0LGUpLm11bChuKS5hZGQoZSl9c3RhdGljIE1lZChlLHQpe3JldHVybiBuZXcgRXQoKGUueCt0LngpLzIsKGUueSt0LnkpLzIpfXN0YXRpYyBFcXVhbHMoZSx0LG49MWUtNCl7cmV0dXJuIE1hdGguYWJzKGUueC10LngpPG4mJk1hdGguYWJzKGUueS10LnkpPG59c3RhdGljIEVxdWFsc1hZKGUsdCxuKXtyZXR1cm4gZS54PT09dCYmZS55PT09bn1zdGF0aWMgRXF1YWxzWFlaKGUsdCxuPTFlLTQpe3JldHVybiBFdC5FcXVhbHMoZSx0LG4pJiZNYXRoLmFicygoZS56fHwwKS0odC56fHwwKSk8bn1zdGF0aWMgQ2xvY2t3aXNlKGUsdCxuKXtyZXR1cm4obi54LWUueCkqKHQueS1lLnkpLSh0LngtZS54KSoobi55LWUueSk8MH1zdGF0aWMgUmVzY2FsZShlLHQpe2NvbnN0IG49RXQuTGVuKGUpO3JldHVybiBuZXcgRXQodCplLngvbix0KmUueS9uKX1zdGF0aWMgU2NhbGVXaXRoT3JpZ2luKGUsdCxuKXtyZXR1cm4gRXQuU3ViKGUsbikubXVsKHQpLmFkZChuKX1zdGF0aWMgU2NhbGVXT3JpZ2luKGUsdCxuKXtyZXR1cm4gRXQuU3ViKGUsbikubXVsVih0KS5hZGQobil9c3RhdGljIFRvRml4ZWQoZSx0PTIpe3JldHVybiBuZXcgRXQoK2UueC50b0ZpeGVkKHQpLCtlLnkudG9GaXhlZCh0KSwrZS56LnRvRml4ZWQodCkpfXN0YXRpYyBOdWRnZShlLHQsbil7cmV0dXJuIEV0LkFkZChlLEV0LlRhbih0LGUpLm11bChuKSl9c3RhdGljIFRvU3RyaW5nKGUpe3JldHVybmAke2UueH0sICR7ZS55fWB9c3RhdGljIFRvQW5nbGUoZSl7bGV0IHQ9TWF0aC5hdGFuMihlLnksZS54KTtyZXR1cm4gdDwwJiYodCs9TWF0aC5QSSoyKSx0fXN0YXRpYyBGcm9tQW5nbGUoZSx0PTEpe3JldHVybiBuZXcgRXQoTWF0aC5jb3MoZSkqdCxNYXRoLnNpbihlKSp0KX1zdGF0aWMgVG9BcnJheShlKXtyZXR1cm5bZS54LGUueSxlLnpdfXN0YXRpYyBUb0pzb24oZSl7Y29uc3R7eDp0LHk6bix6Oml9PWU7cmV0dXJue3g6dCx5Om4sejppfX1zdGF0aWMgQXZlcmFnZShlKXtjb25zdCB0PWUubGVuZ3RoLG49bmV3IEV0KDAsMCk7Zm9yKGxldCBpPTA7aTx0O2krKyluLmFkZChlW2ldKTtyZXR1cm4gbi5kaXYodCl9c3RhdGljIENsYW1wKGUsdCxuKXtyZXR1cm4gbj09PXZvaWQgMD9uZXcgRXQoTWF0aC5taW4oTWF0aC5tYXgoZS54LHQpKSxNYXRoLm1pbihNYXRoLm1heChlLnksdCkpKTpuZXcgRXQoTWF0aC5taW4oTWF0aC5tYXgoZS54LHQpLG4pLE1hdGgubWluKE1hdGgubWF4KGUueSx0KSxuKSl9c3RhdGljIFBvaW50c0JldHdlZW4oZSx0LG49Nil7Y29uc3QgaT1bXTtmb3IobGV0IGY9MDtmPG47ZisrKXtjb25zdCBoPWltLmVhc2VJblF1YWQoZi8obi0xKSksdT1FdC5McnAoZSx0LGgpO3Uuej1NYXRoLm1pbigxLC41K01hdGguYWJzKC41LXNtKGgpKSouNjUpLGkucHVzaCh1KX1yZXR1cm4gaX1zdGF0aWMgU25hcFRvR3JpZChlLHQ9OCl7cmV0dXJuIG5ldyBFdChNYXRoLnJvdW5kKGUueC90KSp0LE1hdGgucm91bmQoZS55L3QpKnQpfX1jb25zdCBzbT1nPT5nPC41PzIqZypnOi0xKyg0LTIqZykqZztjbGFzcyBGdCBleHRlbmRzIEV0e2NvbnN0cnVjdG9yKGU9MCx0PTAsbj0wLGk9e3g6MCx5OjB9LGY9MCxoPTApe3N1cGVyKGUsdCxuKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywieCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOmV9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywieSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnR9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywieiIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOm59KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidiIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOml9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOmZ9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiYSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOmh9KX1nZXQgdGltZXN0YW1wKCl7cmV0dXJuIHRoaXMudH1nZXQgcHJlc3N1cmUoKXtyZXR1cm4gdGhpcy56fWdldCBhbmdsZU51bSgpe3JldHVybiB0aGlzLmF9Z2V0IFhZKCl7cmV0dXJuW3RoaXMueCx0aGlzLnldfXNldEEoZSl7dGhpcy5hPWV9c2V0VChlKXt0aGlzLnQ9ZX1zZXR2KGUpe3JldHVybiB0aGlzLnY9e3g6ZS54LHk6ZS55fSx0aGlzfXNldChlPXRoaXMueCx0PXRoaXMueSxuPXRoaXMueixpPXRoaXMudixmPXRoaXMudCxoPXRoaXMuYSl7cmV0dXJuIHRoaXMueD1lLHRoaXMueT10LHRoaXMuej1uLHRoaXMudj1pLHRoaXMudD1mLHRoaXMuYT1oLHRoaXN9Y2xvbmUoKXtjb25zdHt4OmUseTp0LHo6bix2OmksdDpmLGE6aH09dGhpcyx1PXt4OmkueCx5OmkueX07cmV0dXJuIG5ldyBGdChlLHQsbix1LGYsaCl9ZGlzdGFuY2UoZSl7cmV0dXJuIEZ0LkdldERpc3RhbmNlKHRoaXMsZSl9aXNOZWFyKGUsdCl7cmV0dXJuIEZ0LklzTmVhcih0aGlzLGUsdCl9Z2V0QW5nbGVCeVBvaW50cyhlLHQpe3JldHVybiBGdC5HZXRBbmdsZUJ5UG9pbnRzKGUsdGhpcyx0KX1zdGF0aWMgU3ViKGUsdCl7cmV0dXJuIG5ldyBGdChlLngtdC54LGUueS10LnkpfXN0YXRpYyBBZGQoZSx0KXtyZXR1cm4gbmV3IEZ0KGUueCt0LngsZS55K3QueSl9c3RhdGljIEdldERpc3RhbmNlKGUsdCl7cmV0dXJuIEZ0LkxlbihlLmNsb25lKCkuc3ViKHQpKX1zdGF0aWMgR2V0QW5nbGVCeVBvaW50cyhlLHQsbil7Y29uc3QgaT10LngtZS54LGY9bi54LXQueCxoPXQueS1lLnksdT1uLnktdC55O2xldCBhPTA7Y29uc3QgZD1NYXRoLnNxcnQoaSppK2gqaCksRT1NYXRoLnNxcnQoZipmK3UqdSk7aWYoZCYmRSl7Y29uc3QgcD1pKmYraCp1O2E9TWF0aC5hY29zKHAvKGQqRSkpLGE9YS9NYXRoLlBJKjE4MDtsZXQgTz1pKnUtaCpmO089Tz4wPzE6LTEsYT0xODArTyphfXJldHVybiBhfXN0YXRpYyBJc05lYXIoZSx0LG4pe3JldHVybiBGdC5MZW4oZS5jbG9uZSgpLnN1Yih0KSk8bn1zdGF0aWMgUm90V2l0aChlLHQsbixpPTIpe2NvbnN0IGY9ZS54LXQueCxoPWUueS10LnksdT1NYXRoLnNpbihuKSxhPU1hdGguY29zKG4pLGQ9TWF0aC5wb3coMTAsaSksRT1NYXRoLmZsb29yKCh0LngrKGYqYS1oKnUpKSpkKS9kLHA9TWF0aC5mbG9vcigodC55KyhmKnUraCphKSkqZCkvZDtyZXR1cm4gbmV3IEZ0KEUscCl9c3RhdGljIEdldERvdFN0cm9rZShlLHQsbj0xNil7Y29uc3QgaT1uZXcgRXQoMSwxKSxmPU1hdGguUEkrLjAwMSxoPUZ0LkFkZChlLEZ0LlN1YihlLGkpLnVuaSgpLnBlcigpLm11bCgtdCkpLHU9W107Zm9yKGxldCBhPTEvbixkPWE7ZDw9MTtkKz1hKXUucHVzaChGdC5Sb3RXaXRoKGgsZSxmKjIqZCkpO3JldHVybiB1fXN0YXRpYyBHZXRTZW1pY2lyY2xlU3Ryb2tlKGUsdCxuPS0xLGk9OCl7Y29uc3QgZj1uKihNYXRoLlBJKy4wMDEpLGg9W107Zm9yKGxldCB1PTEvaSxhPXU7YTw9MTthKz11KWgucHVzaChGdC5Sb3RXaXRoKHQsZSxmKmEpKTtyZXR1cm4gaH19ZnVuY3Rpb24gb20oZyxlKXtyZXR1cm57eDpnLngtZSx5OmcueS1lLHc6Zy53K2UqMixoOmcuaCtlKjJ9fWZ1bmN0aW9uICR0KGcsZSl7aWYoZyYmZSl7Y29uc3QgdD1NYXRoLm1pbihnLngsZS54KSxuPU1hdGgubWluKGcueSxlLnkpLGk9TWF0aC5tYXgoZy54K2cudyxlLngrZS53KSxmPU1hdGgubWF4KGcueStnLmgsZS55K2UuaCksaD1pLXQsdT1mLW47cmV0dXJue3g6dCx5Om4sdzpoLGg6dX19cmV0dXJuIGV8fGd9ZnVuY3Rpb24geGUoZyxlPTApe2NvbnN0IHQ9e3g6MCx5OjAsdzowLGg6MH07bGV0IG49MS8wLGk9MS8wLGY9LTEvMCxoPS0xLzA7cmV0dXJuIGcuZm9yRWFjaCh1PT57Y29uc3RbYSxkXT11LlhZO249TWF0aC5taW4obixhLWUpLGk9TWF0aC5taW4oaSxkLWUpLGY9TWF0aC5tYXgoZixhK2UpLGg9TWF0aC5tYXgoaCxkK2UpfSksdC54PW4sdC55PWksdC53PWYtbix0Lmg9aC1pLHR9ZnVuY3Rpb24gUm4oZyxlKXtyZXR1cm4hKGcueCtnLnc8ZS54fHxnLng+ZS54K2Uud3x8Zy55K2cuaDxlLnl8fGcueT5lLnkrZS5oKX1mdW5jdGlvbiBhbShnLGUpe3JldHVybiBnLmxlbmd0aD09PWUubGVuZ3RoJiZnLnNvcnQoKS50b1N0cmluZygpPT09ZS5zb3J0KCkudG9TdHJpbmcoKX1mdW5jdGlvbiBsbihnLGU9MTApe3JldHVybnt4Ok1hdGguZmxvb3IoZy54LWUpLHk6TWF0aC5mbG9vcihnLnktZSksdzpNYXRoLmZsb29yKGcudytlKjIpLGg6TWF0aC5mbG9vcihnLmgrZSoyKX19ZnVuY3Rpb24gTGEoZyxlKXtyZXR1cm57eDpnLngrZVswXSx5OmcueStlWzFdLHc6Zy53LGg6Zy5ofX1mdW5jdGlvbiBsbShnLGUpe2NvbnN0IHQ9bmV3IEV0KGcueCxnLnkpLG49bmV3IEV0KGcueCtnLncsZy55KSxpPW5ldyBFdChnLngrZy53LGcueStnLmgpLGY9bmV3IEV0KGcueCxnLnkrZy5oKSxoPW5ldyBFdChnLngrZy53LzIsZy55K2cuaC8yKSx1PU1hdGguUEkqZS8xODAsYT1FdC5Sb3RXaXRoKHQsaCx1KSxkPUV0LlJvdFdpdGgobixoLHUpLEU9RXQuUm90V2l0aChpLGgsdSkscD1FdC5Sb3RXaXRoKGYsaCx1KTtyZXR1cm4geGUoW2EsZCxFLHBdKX1mdW5jdGlvbiB1bShnLGUpe2NvbnN0IHQ9bmV3IEV0KGcueCxnLnkpLG49bmV3IEV0KGcueCtnLncsZy55KSxpPW5ldyBFdChnLngrZy53LGcueStnLmgpLGY9bmV3IEV0KGcueCxnLnkrZy5oKSxoPW5ldyBFdChnLngrZy53LzIsZy55K2cuaC8yKSx1PW5ldyBFdChlWzBdLGVbMV0pLGE9RXQuU2NhbGVXT3JpZ2luKHQsdSxoKSxkPUV0LlNjYWxlV09yaWdpbihuLHUsaCksRT1FdC5TY2FsZVdPcmlnaW4oaSx1LGgpLHA9RXQuU2NhbGVXT3JpZ2luKGYsdSxoKTtyZXR1cm4geGUoW2EsZCxFLHBdKX1mdW5jdGlvbiBmbShnLGUsdCl7Y29uc3Qgbj1uZXcgRXQoZVswXSxlWzFdKTtmb3IobGV0IGk9MDtpPGcubGVuZ3RoO2krPTMpe2NvbnN0IGY9bmV3IEV0KGdbaV0sZ1tpKzFdKSxoPU1hdGguUEkqdC8xODAsdT1FdC5Sb3RXaXRoKGYsbixoKTtnW2ldPXUueCxnW2krMV09dS55fX1mdW5jdGlvbiBjbShnLGUsdCl7Y29uc3Qgbj1uZXcgRXQoZVswXSxlWzFdKTtmb3IobGV0IGk9MDtpPGcubGVuZ3RoO2krPTMpe2NvbnN0IGY9bmV3IEV0KGdbaV0sZ1tpKzFdKSxoPW5ldyBFdCh0WzBdLHRbMV0pO2lmKGk8Zy5sZW5ndGgtMyl7Y29uc3QgYT1uZXcgRXQoZ1tpKzNdLGdbaSs0XSksZD1FdC5UYW4oYSxmKS5wZXIoKS5tdWwoZ1tpKzJdKS5tdWxWKGgpLmxlbigpO2dbaSsyXT1kfWVsc2UgaWYoaT09PWcubGVuZ3RoLTMpe2NvbnN0IGE9bmV3IEV0KGdbaS0zXSxnW2ktMl0pLGQ9RXQuVGFuKGYsYSkucGVyKCkubXVsKGdbaSsyXSkubXVsVihoKS5sZW4oKTtnW2krMl09ZH1jb25zdCB1PUV0LlNjYWxlV09yaWdpbihmLGgsbik7Z1tpXT11LngsZ1tpKzFdPXUueX19ZnVuY3Rpb24gaG0oZyxlKXtyZXR1cm4gZ1swXT49ZS54JiZnWzBdPD1lLngrZS53JiZnWzFdPj1lLnkmJmdbMV08PWUueStlLmh9ZnVuY3Rpb24gRGEoZyxlKXtjb25zdCB0PWc8PWU/MTpnL2Usbj1lPD1nPzE6ZS9nO3JldHVyblt0LG5dfWNvbnN0IHJpPWc9PntpZihnLnRhZ05hbWU9PT0iR1JPVVAiKXtjb25zdCBlPU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZykuZmluZCh0PT50LnRvU3RyaW5nKCk9PT0iU3ltYm9sKHNlYWxlZCkiKTtpZihlJiZnW2VdKXJldHVybiEwfXJldHVybiExfSx3YT1nPT5nIT09THQuVGV4dDtmdW5jdGlvbiB1bihnKXtyZXR1cm5gJHtuaShnLngpfSwke25pKGcueSl9IGB9ZnVuY3Rpb24gZm4oZyxlKXtyZXR1cm5gJHtuaSgoZy54K2UueCkvMil9LCR7bmkoKGcueStlLnkpLzIpfSBgfWZ1bmN0aW9uIG5pKGcpe3JldHVybitnLnRvRml4ZWQoNCl9dmFyIGRtPXJuLGdtPUdyLHZtPSJbb2JqZWN0IE51bWJlcl0iO2Z1bmN0aW9uIHBtKGcpe3JldHVybiB0eXBlb2YgZz09Im51bWJlciJ8fGdtKGcpJiZkbShnKT09dm19dmFyIG1tPXBtLE5hPVZuKG1tKSxpaT17ZXhwb3J0czp7fX07LyoqCiAqIEBsaWNlbnNlCiAqIExvZGFzaCA8aHR0cHM6Ly9sb2Rhc2guY29tLz4KICogQ29weXJpZ2h0IE9wZW5KUyBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnMgPGh0dHBzOi8vb3BlbmpzZi5vcmcvPgogKiBSZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+CiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+CiAqIENvcHlyaWdodCBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9ycwogKi9paS5leHBvcnRzLGZ1bmN0aW9uKGcsZSl7KGZ1bmN0aW9uKCl7dmFyIHQsbj0iNC4xNy4yMSIsaT0yMDAsZj0iVW5zdXBwb3J0ZWQgY29yZS1qcyB1c2UuIFRyeSBodHRwczovL25wbXMuaW8vc2VhcmNoP3E9cG9ueWZpbGwuIixoPSJFeHBlY3RlZCBhIGZ1bmN0aW9uIix1PSJJbnZhbGlkIGB2YXJpYWJsZWAgb3B0aW9uIHBhc3NlZCBpbnRvIGBfLnRlbXBsYXRlYCIsYT0iX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyIsZD01MDAsRT0iX19sb2Rhc2hfcGxhY2Vob2xkZXJfXyIscD0xLE89MixtPTQsYj0xLE09Mix5PTEsUz0yLHM9NCxjPTgsbD0xNix2PTMyLFQ9NjQsUj0xMjgsTD0yNTYsTj01MTIsQT0zMCx3PSIuLi4iLEI9ODAwLEQ9MTYsST0xLGo9MixWPTMsSj0xLzAsXz05MDA3MTk5MjU0NzQwOTkxLHN0PTE3OTc2OTMxMzQ4NjIzMTU3ZTI5MixHPU5hTixZPTQyOTQ5NjcyOTUscnQ9WS0xLG90PVk+Pj4xLGF0PVtbImFyeSIsUl0sWyJiaW5kIix5XSxbImJpbmRLZXkiLFNdLFsiY3VycnkiLGNdLFsiY3VycnlSaWdodCIsbF0sWyJmbGlwIixOXSxbInBhcnRpYWwiLHZdLFsicGFydGlhbFJpZ2h0IixUXSxbInJlYXJnIixMXV0saHQ9IltvYmplY3QgQXJndW1lbnRzXSIsaXQ9IltvYmplY3QgQXJyYXldIixNdD0iW29iamVjdCBBc3luY0Z1bmN0aW9uXSIsT3Q9IltvYmplY3QgQm9vbGVhbl0iLFU9IltvYmplY3QgRGF0ZV0iLCQ9IltvYmplY3QgRE9NRXhjZXB0aW9uXSIsUT0iW29iamVjdCBFcnJvcl0iLHR0PSJbb2JqZWN0IEZ1bmN0aW9uXSIsRj0iW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0iLEg9IltvYmplY3QgTWFwXSIseD0iW29iamVjdCBOdW1iZXJdIixQPSJbb2JqZWN0IE51bGxdIixXPSJbb2JqZWN0IE9iamVjdF0iLEs9IltvYmplY3QgUHJvbWlzZV0iLFo9IltvYmplY3QgUHJveHldIixrPSJbb2JqZWN0IFJlZ0V4cF0iLG50PSJbb2JqZWN0IFNldF0iLHV0PSJbb2JqZWN0IFN0cmluZ10iLGN0PSJbb2JqZWN0IFN5bWJvbF0iLHB0PSJbb2JqZWN0IFVuZGVmaW5lZF0iLHh0PSJbb2JqZWN0IFdlYWtNYXBdIixndD0iW29iamVjdCBXZWFrU2V0XSIsZHQ9IltvYmplY3QgQXJyYXlCdWZmZXJdIixtdD0iW29iamVjdCBEYXRhVmlld10iLGJ0PSJbb2JqZWN0IEZsb2F0MzJBcnJheV0iLEN0PSJbb2JqZWN0IEZsb2F0NjRBcnJheV0iLFN0PSJbb2JqZWN0IEludDhBcnJheV0iLE50PSJbb2JqZWN0IEludDE2QXJyYXldIixKdD0iW29iamVjdCBJbnQzMkFycmF5XSIsR3Q9IltvYmplY3QgVWludDhBcnJheV0iLEt0PSJbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XSIsWXQ9IltvYmplY3QgVWludDE2QXJyYXldIixWdD0iW29iamVjdCBVaW50MzJBcnJheV0iLFNlPS9cYl9fcCBcKz0gJyc7L2csT2U9L1xiKF9fcCBcKz0pICcnIFwrL2csRWU9LyhfX2VcKC4qP1wpfFxiX190XCkpIFwrXG4nJzsvZyxtZT0vJig/OmFtcHxsdHxndHxxdW90fCMzOSk7L2csVGU9L1smPD4iJ10vZyxiZT1SZWdFeHAobWUuc291cmNlKSxJZT1SZWdFeHAoVGUuc291cmNlKSxzZT0vPCUtKFtcc1xTXSs/KSU+L2csVmU9LzwlKFtcc1xTXSs/KSU+L2csTHI9LzwlPShbXHNcU10rPyklPi9nLFlyPS9cLnxcWyg/OlteW1xdXSp8KFsiJ10pKD86KD8hXDEpW15cXF18XFwuKSo/XDEpXF0vLGFpPS9eXHcqJC8sbGk9L1teLltcXV0rfFxbKD86KC0/XGQrKD86XC5cZCspPyl8KFsiJ10pKCg/Oig/IVwyKVteXFxdfFxcLikqPylcMilcXXwoPz0oPzpcLnxcW1xdKSg/OlwufFxbXF18JCkpL2cseXM9L1tcXF4kLiorPygpW1xde318XS9nLFN5PVJlZ0V4cCh5cy5zb3VyY2UpLHhzPS9eXHMrLyxUeT0vXHMvLFB5PS9ceyg/OlxuXC9cKiBcW3dyYXBwZWQgd2l0aCAuK1xdIFwqXC8pP1xuPy8sYnk9L1x7XG5cL1wqIFxbd3JhcHBlZCB3aXRoICguKylcXSBcKi8sQXk9Lyw/ICYgLyxDeT0vW15ceDAwLVx4MmZceDNhLVx4NDBceDViLVx4NjBceDdiLVx4N2ZdKy9nLFJ5PS9bKCk9LHt9XFtcXVwvXHNdLyxJeT0vXFwoXFwpPy9nLEx5PS9cJFx7KFteXFx9XSooPzpcXC5bXlxcfV0qKSopXH0vZyxlbD0vXHcqJC8sRHk9L15bLStdMHhbMC05YS1mXSskL2ksd3k9L14wYlswMV0rJC9pLE55PS9eXFtvYmplY3QgLis/Q29uc3RydWN0b3JcXSQvLEJ5PS9eMG9bMC03XSskL2ksV3k9L14oPzowfFsxLTldXGQqKSQvLEZ5PS9bXHhjMC1ceGQ2XHhkOC1ceGY2XHhmOC1ceGZmXHUwMTAwLVx1MDE3Zl0vZyx1aT0vKCReKS8sank9L1snXG5cclx1MjAyOFx1MjAyOVxcXS9nLGZpPSJcXHVkODAwLVxcdWRmZmYiLFV5PSJcXHUwMzAwLVxcdTAzNmYiLHp5PSJcXHVmZTIwLVxcdWZlMmYiLCR5PSJcXHUyMGQwLVxcdTIwZmYiLHJsPVV5K3p5KyR5LG5sPSJcXHUyNzAwLVxcdTI3YmYiLGlsPSJhLXpcXHhkZi1cXHhmNlxceGY4LVxceGZmIixHeT0iXFx4YWNcXHhiMVxceGQ3XFx4ZjciLEt5PSJcXHgwMC1cXHgyZlxceDNhLVxceDQwXFx4NWItXFx4NjBcXHg3Yi1cXHhiZiIsSHk9IlxcdTIwMDAtXFx1MjA2ZiIsWXk9IiBcXHRcXHgwYlxcZlxceGEwXFx1ZmVmZlxcblxcclxcdTIwMjhcXHUyMDI5XFx1MTY4MFxcdTE4MGVcXHUyMDAwXFx1MjAwMVxcdTIwMDJcXHUyMDAzXFx1MjAwNFxcdTIwMDVcXHUyMDA2XFx1MjAwN1xcdTIwMDhcXHUyMDA5XFx1MjAwYVxcdTIwMmZcXHUyMDVmXFx1MzAwMCIsc2w9IkEtWlxceGMwLVxceGQ2XFx4ZDgtXFx4ZGUiLG9sPSJcXHVmZTBlXFx1ZmUwZiIsYWw9R3krS3krSHkrWXksT3M9Ilsn4oCZXSIsVnk9IlsiK2ZpKyJdIixsbD0iWyIrYWwrIl0iLGNpPSJbIitybCsiXSIsdWw9IlxcZCsiLFh5PSJbIitubCsiXSIsZmw9IlsiK2lsKyJdIixjbD0iW14iK2ZpK2FsK3VsK25sK2lsK3NsKyJdIixFcz0iXFx1ZDgzY1tcXHVkZmZiLVxcdWRmZmZdIixaeT0iKD86IitjaSsifCIrRXMrIikiLGhsPSJbXiIrZmkrIl0iLE1zPSIoPzpcXHVkODNjW1xcdWRkZTYtXFx1ZGRmZl0pezJ9IixTcz0iW1xcdWQ4MDAtXFx1ZGJmZl1bXFx1ZGMwMC1cXHVkZmZmXSIsZ249IlsiK3NsKyJdIixkbD0iXFx1MjAwZCIsZ2w9Iig/OiIrZmwrInwiK2NsKyIpIixKeT0iKD86IitnbisifCIrY2wrIikiLHZsPSIoPzoiK09zKyIoPzpkfGxsfG18cmV8c3x0fHZlKSk/IixwbD0iKD86IitPcysiKD86RHxMTHxNfFJFfFN8VHxWRSkpPyIsbWw9WnkrIj8iLHlsPSJbIitvbCsiXT8iLFF5PSIoPzoiK2RsKyIoPzoiK1tobCxNcyxTc10uam9pbigifCIpKyIpIit5bCttbCsiKSoiLGt5PSJcXGQqKD86MXN0fDJuZHwzcmR8KD8hWzEyM10pXFxkdGgpKD89XFxifFtBLVpfXSkiLHF5PSJcXGQqKD86MVNUfDJORHwzUkR8KD8hWzEyM10pXFxkVEgpKD89XFxifFthLXpfXSkiLHhsPXlsK21sK1F5LF95PSIoPzoiK1tYeSxNcyxTc10uam9pbigifCIpKyIpIit4bCx0Mj0iKD86IitbaGwrY2krIj8iLGNpLE1zLFNzLFZ5XS5qb2luKCJ8IikrIikiLGUyPVJlZ0V4cChPcywiZyIpLHIyPVJlZ0V4cChjaSwiZyIpLFRzPVJlZ0V4cChFcysiKD89IitFcysiKXwiK3QyK3hsLCJnIiksbjI9UmVnRXhwKFtnbisiPyIrZmwrIisiK3ZsKyIoPz0iK1tsbCxnbiwiJCJdLmpvaW4oInwiKSsiKSIsSnkrIisiK3BsKyIoPz0iK1tsbCxnbitnbCwiJCJdLmpvaW4oInwiKSsiKSIsZ24rIj8iK2dsKyIrIit2bCxnbisiKyIrcGwscXksa3ksdWwsX3ldLmpvaW4oInwiKSwiZyIpLGkyPVJlZ0V4cCgiWyIrZGwrZmkrcmwrb2wrIl0iKSxzMj0vW2Etel1bQS1aXXxbQS1aXXsyfVthLXpdfFswLTldW2EtekEtWl18W2EtekEtWl1bMC05XXxbXmEtekEtWjAtOSBdLyxvMj1bIkFycmF5IiwiQnVmZmVyIiwiRGF0YVZpZXciLCJEYXRlIiwiRXJyb3IiLCJGbG9hdDMyQXJyYXkiLCJGbG9hdDY0QXJyYXkiLCJGdW5jdGlvbiIsIkludDhBcnJheSIsIkludDE2QXJyYXkiLCJJbnQzMkFycmF5IiwiTWFwIiwiTWF0aCIsIk9iamVjdCIsIlByb21pc2UiLCJSZWdFeHAiLCJTZXQiLCJTdHJpbmciLCJTeW1ib2wiLCJUeXBlRXJyb3IiLCJVaW50OEFycmF5IiwiVWludDhDbGFtcGVkQXJyYXkiLCJVaW50MTZBcnJheSIsIlVpbnQzMkFycmF5IiwiV2Vha01hcCIsIl8iLCJjbGVhclRpbWVvdXQiLCJpc0Zpbml0ZSIsInBhcnNlSW50Iiwic2V0VGltZW91dCJdLGEyPS0xLHBlPXt9O3BlW2J0XT1wZVtDdF09cGVbU3RdPXBlW050XT1wZVtKdF09cGVbR3RdPXBlW0t0XT1wZVtZdF09cGVbVnRdPSEwLHBlW2h0XT1wZVtpdF09cGVbZHRdPXBlW090XT1wZVttdF09cGVbVV09cGVbUV09cGVbdHRdPXBlW0hdPXBlW3hdPXBlW1ddPXBlW2tdPXBlW250XT1wZVt1dF09cGVbeHRdPSExO3ZhciBnZT17fTtnZVtodF09Z2VbaXRdPWdlW2R0XT1nZVttdF09Z2VbT3RdPWdlW1VdPWdlW2J0XT1nZVtDdF09Z2VbU3RdPWdlW050XT1nZVtKdF09Z2VbSF09Z2VbeF09Z2VbV109Z2Vba109Z2VbbnRdPWdlW3V0XT1nZVtjdF09Z2VbR3RdPWdlW0t0XT1nZVtZdF09Z2VbVnRdPSEwLGdlW1FdPWdlW3R0XT1nZVt4dF09ITE7dmFyIGwyPXvDgDoiQSIsw4E6IkEiLMOCOiJBIizDgzoiQSIsw4Q6IkEiLMOFOiJBIizDoDoiYSIsw6E6ImEiLMOiOiJhIizDozoiYSIsw6Q6ImEiLMOlOiJhIizDhzoiQyIsw6c6ImMiLMOQOiJEIizDsDoiZCIsw4g6IkUiLMOJOiJFIizDijoiRSIsw4s6IkUiLMOoOiJlIizDqToiZSIsw6o6ImUiLMOrOiJlIizDjDoiSSIsw406IkkiLMOOOiJJIizDjzoiSSIsw6w6ImkiLMOtOiJpIizDrjoiaSIsw686ImkiLMOROiJOIizDsToibiIsw5I6Ik8iLMOTOiJPIizDlDoiTyIsw5U6Ik8iLMOWOiJPIizDmDoiTyIsw7I6Im8iLMOzOiJvIizDtDoibyIsw7U6Im8iLMO2OiJvIizDuDoibyIsw5k6IlUiLMOaOiJVIizDmzoiVSIsw5w6IlUiLMO5OiJ1IizDujoidSIsw7s6InUiLMO8OiJ1IizDnToiWSIsw706InkiLMO/OiJ5IizDhjoiQWUiLMOmOiJhZSIsw546IlRoIizDvjoidGgiLMOfOiJzcyIsxIA6IkEiLMSCOiJBIizEhDoiQSIsxIE6ImEiLMSDOiJhIizEhToiYSIsxIY6IkMiLMSIOiJDIizEijoiQyIsxIw6IkMiLMSHOiJjIizEiToiYyIsxIs6ImMiLMSNOiJjIizEjjoiRCIsxJA6IkQiLMSPOiJkIizEkToiZCIsxJI6IkUiLMSUOiJFIizEljoiRSIsxJg6IkUiLMSaOiJFIizEkzoiZSIsxJU6ImUiLMSXOiJlIizEmToiZSIsxJs6ImUiLMScOiJHIizEnjoiRyIsxKA6IkciLMSiOiJHIizEnToiZyIsxJ86ImciLMShOiJnIizEozoiZyIsxKQ6IkgiLMSmOiJIIizEpToiaCIsxKc6ImgiLMSoOiJJIizEqjoiSSIsxKw6IkkiLMSuOiJJIizEsDoiSSIsxKk6ImkiLMSrOiJpIizErToiaSIsxK86ImkiLMSxOiJpIizEtDoiSiIsxLU6ImoiLMS2OiJLIizEtzoiayIsxLg6ImsiLMS5OiJMIizEuzoiTCIsxL06IkwiLMS/OiJMIizFgToiTCIsxLo6ImwiLMS8OiJsIizEvjoibCIsxYA6ImwiLMWCOiJsIizFgzoiTiIsxYU6Ik4iLMWHOiJOIizFijoiTiIsxYQ6Im4iLMWGOiJuIizFiDoibiIsxYs6Im4iLMWMOiJPIizFjjoiTyIsxZA6Ik8iLMWNOiJvIizFjzoibyIsxZE6Im8iLMWUOiJSIizFljoiUiIsxZg6IlIiLMWVOiJyIizFlzoiciIsxZk6InIiLMWaOiJTIizFnDoiUyIsxZ46IlMiLMWgOiJTIizFmzoicyIsxZ06InMiLMWfOiJzIizFoToicyIsxaI6IlQiLMWkOiJUIizFpjoiVCIsxaM6InQiLMWlOiJ0IizFpzoidCIsxag6IlUiLMWqOiJVIizFrDoiVSIsxa46IlUiLMWwOiJVIizFsjoiVSIsxak6InUiLMWrOiJ1IizFrToidSIsxa86InUiLMWxOiJ1IizFszoidSIsxbQ6IlciLMW1OiJ3IizFtjoiWSIsxbc6InkiLMW4OiJZIizFuToiWiIsxbs6IloiLMW9OiJaIizFujoieiIsxbw6InoiLMW+OiJ6IizEsjoiSUoiLMSzOiJpaiIsxZI6Ik9lIizFkzoib2UiLMWJOiInbiIsxb86InMifSx1Mj17IiYiOiImYW1wOyIsIjwiOiImbHQ7IiwiPiI6IiZndDsiLCciJzoiJnF1b3Q7IiwiJyI6IiYjMzk7In0sZjI9eyImYW1wOyI6IiYiLCImbHQ7IjoiPCIsIiZndDsiOiI+IiwiJnF1b3Q7IjonIicsIiYjMzk7IjoiJyJ9LGMyPXsiXFwiOiJcXCIsIiciOiInIiwiXG4iOiJuIiwiXHIiOiJyIiwiXHUyMDI4IjoidTIwMjgiLCJcdTIwMjkiOiJ1MjAyOSJ9LGgyPXBhcnNlRmxvYXQsZDI9cGFyc2VJbnQsT2w9dHlwZW9mIG1yPT0ib2JqZWN0IiYmbXImJm1yLk9iamVjdD09PU9iamVjdCYmbXIsZzI9dHlwZW9mIHNlbGY9PSJvYmplY3QiJiZzZWxmJiZzZWxmLk9iamVjdD09PU9iamVjdCYmc2VsZixOZT1PbHx8ZzJ8fEZ1bmN0aW9uKCJyZXR1cm4gdGhpcyIpKCksUHM9ZSYmIWUubm9kZVR5cGUmJmUsVnI9UHMmJiEwJiZnJiYhZy5ub2RlVHlwZSYmZyxFbD1WciYmVnIuZXhwb3J0cz09PVBzLGJzPUVsJiZPbC5wcm9jZXNzLF9lPWZ1bmN0aW9uKCl7dHJ5e3ZhciB2dD1WciYmVnIucmVxdWlyZSYmVnIucmVxdWlyZSgidXRpbCIpLnR5cGVzO3JldHVybiB2dHx8YnMmJmJzLmJpbmRpbmcmJmJzLmJpbmRpbmcoInV0aWwiKX1jYXRjaHt9fSgpLE1sPV9lJiZfZS5pc0FycmF5QnVmZmVyLFNsPV9lJiZfZS5pc0RhdGUsVGw9X2UmJl9lLmlzTWFwLFBsPV9lJiZfZS5pc1JlZ0V4cCxibD1fZSYmX2UuaXNTZXQsQWw9X2UmJl9lLmlzVHlwZWRBcnJheTtmdW5jdGlvbiBYZSh2dCxBdCxQdCl7c3dpdGNoKFB0Lmxlbmd0aCl7Y2FzZSAwOnJldHVybiB2dC5jYWxsKEF0KTtjYXNlIDE6cmV0dXJuIHZ0LmNhbGwoQXQsUHRbMF0pO2Nhc2UgMjpyZXR1cm4gdnQuY2FsbChBdCxQdFswXSxQdFsxXSk7Y2FzZSAzOnJldHVybiB2dC5jYWxsKEF0LFB0WzBdLFB0WzFdLFB0WzJdKX1yZXR1cm4gdnQuYXBwbHkoQXQsUHQpfWZ1bmN0aW9uIHYyKHZ0LEF0LFB0LGp0KXtmb3IodmFyIFF0PS0xLGFlPXZ0PT1udWxsPzA6dnQubGVuZ3RoOysrUXQ8YWU7KXt2YXIgTGU9dnRbUXRdO0F0KGp0LExlLFB0KExlKSx2dCl9cmV0dXJuIGp0fWZ1bmN0aW9uIHRyKHZ0LEF0KXtmb3IodmFyIFB0PS0xLGp0PXZ0PT1udWxsPzA6dnQubGVuZ3RoOysrUHQ8anQmJkF0KHZ0W1B0XSxQdCx2dCkhPT0hMTspO3JldHVybiB2dH1mdW5jdGlvbiBwMih2dCxBdCl7Zm9yKHZhciBQdD12dD09bnVsbD8wOnZ0Lmxlbmd0aDtQdC0tJiZBdCh2dFtQdF0sUHQsdnQpIT09ITE7KTtyZXR1cm4gdnR9ZnVuY3Rpb24gQ2wodnQsQXQpe2Zvcih2YXIgUHQ9LTEsanQ9dnQ9PW51bGw/MDp2dC5sZW5ndGg7KytQdDxqdDspaWYoIUF0KHZ0W1B0XSxQdCx2dCkpcmV0dXJuITE7cmV0dXJuITB9ZnVuY3Rpb24gRHIodnQsQXQpe2Zvcih2YXIgUHQ9LTEsanQ9dnQ9PW51bGw/MDp2dC5sZW5ndGgsUXQ9MCxhZT1bXTsrK1B0PGp0Oyl7dmFyIExlPXZ0W1B0XTtBdChMZSxQdCx2dCkmJihhZVtRdCsrXT1MZSl9cmV0dXJuIGFlfWZ1bmN0aW9uIGhpKHZ0LEF0KXt2YXIgUHQ9dnQ9PW51bGw/MDp2dC5sZW5ndGg7cmV0dXJuISFQdCYmdm4odnQsQXQsMCk+LTF9ZnVuY3Rpb24gQXModnQsQXQsUHQpe2Zvcih2YXIganQ9LTEsUXQ9dnQ9PW51bGw/MDp2dC5sZW5ndGg7KytqdDxRdDspaWYoUHQoQXQsdnRbanRdKSlyZXR1cm4hMDtyZXR1cm4hMX1mdW5jdGlvbiB5ZSh2dCxBdCl7Zm9yKHZhciBQdD0tMSxqdD12dD09bnVsbD8wOnZ0Lmxlbmd0aCxRdD1BcnJheShqdCk7KytQdDxqdDspUXRbUHRdPUF0KHZ0W1B0XSxQdCx2dCk7cmV0dXJuIFF0fWZ1bmN0aW9uIHdyKHZ0LEF0KXtmb3IodmFyIFB0PS0xLGp0PUF0Lmxlbmd0aCxRdD12dC5sZW5ndGg7KytQdDxqdDspdnRbUXQrUHRdPUF0W1B0XTtyZXR1cm4gdnR9ZnVuY3Rpb24gQ3ModnQsQXQsUHQsanQpe3ZhciBRdD0tMSxhZT12dD09bnVsbD8wOnZ0Lmxlbmd0aDtmb3IoanQmJmFlJiYoUHQ9dnRbKytRdF0pOysrUXQ8YWU7KVB0PUF0KFB0LHZ0W1F0XSxRdCx2dCk7cmV0dXJuIFB0fWZ1bmN0aW9uIG0yKHZ0LEF0LFB0LGp0KXt2YXIgUXQ9dnQ9PW51bGw/MDp2dC5sZW5ndGg7Zm9yKGp0JiZRdCYmKFB0PXZ0Wy0tUXRdKTtRdC0tOylQdD1BdChQdCx2dFtRdF0sUXQsdnQpO3JldHVybiBQdH1mdW5jdGlvbiBScyh2dCxBdCl7Zm9yKHZhciBQdD0tMSxqdD12dD09bnVsbD8wOnZ0Lmxlbmd0aDsrK1B0PGp0OylpZihBdCh2dFtQdF0sUHQsdnQpKXJldHVybiEwO3JldHVybiExfXZhciB5Mj1JcygibGVuZ3RoIik7ZnVuY3Rpb24geDIodnQpe3JldHVybiB2dC5zcGxpdCgiIil9ZnVuY3Rpb24gTzIodnQpe3JldHVybiB2dC5tYXRjaChDeSl8fFtdfWZ1bmN0aW9uIFJsKHZ0LEF0LFB0KXt2YXIganQ7cmV0dXJuIFB0KHZ0LGZ1bmN0aW9uKFF0LGFlLExlKXtpZihBdChRdCxhZSxMZSkpcmV0dXJuIGp0PWFlLCExfSksanR9ZnVuY3Rpb24gZGkodnQsQXQsUHQsanQpe2Zvcih2YXIgUXQ9dnQubGVuZ3RoLGFlPVB0KyhqdD8xOi0xKTtqdD9hZS0tOisrYWU8UXQ7KWlmKEF0KHZ0W2FlXSxhZSx2dCkpcmV0dXJuIGFlO3JldHVybi0xfWZ1bmN0aW9uIHZuKHZ0LEF0LFB0KXtyZXR1cm4gQXQ9PT1BdD9EMih2dCxBdCxQdCk6ZGkodnQsSWwsUHQpfWZ1bmN0aW9uIEUyKHZ0LEF0LFB0LGp0KXtmb3IodmFyIFF0PVB0LTEsYWU9dnQubGVuZ3RoOysrUXQ8YWU7KWlmKGp0KHZ0W1F0XSxBdCkpcmV0dXJuIFF0O3JldHVybi0xfWZ1bmN0aW9uIElsKHZ0KXtyZXR1cm4gdnQhPT12dH1mdW5jdGlvbiBMbCh2dCxBdCl7dmFyIFB0PXZ0PT1udWxsPzA6dnQubGVuZ3RoO3JldHVybiBQdD9Ecyh2dCxBdCkvUHQ6R31mdW5jdGlvbiBJcyh2dCl7cmV0dXJuIGZ1bmN0aW9uKEF0KXtyZXR1cm4gQXQ9PW51bGw/dDpBdFt2dF19fWZ1bmN0aW9uIExzKHZ0KXtyZXR1cm4gZnVuY3Rpb24oQXQpe3JldHVybiB2dD09bnVsbD90OnZ0W0F0XX19ZnVuY3Rpb24gRGwodnQsQXQsUHQsanQsUXQpe3JldHVybiBRdCh2dCxmdW5jdGlvbihhZSxMZSxoZSl7UHQ9anQ/KGp0PSExLGFlKTpBdChQdCxhZSxMZSxoZSl9KSxQdH1mdW5jdGlvbiBNMih2dCxBdCl7dmFyIFB0PXZ0Lmxlbmd0aDtmb3IodnQuc29ydChBdCk7UHQtLTspdnRbUHRdPXZ0W1B0XS52YWx1ZTtyZXR1cm4gdnR9ZnVuY3Rpb24gRHModnQsQXQpe2Zvcih2YXIgUHQsanQ9LTEsUXQ9dnQubGVuZ3RoOysranQ8UXQ7KXt2YXIgYWU9QXQodnRbanRdKTthZSE9PXQmJihQdD1QdD09PXQ/YWU6UHQrYWUpfXJldHVybiBQdH1mdW5jdGlvbiB3cyh2dCxBdCl7Zm9yKHZhciBQdD0tMSxqdD1BcnJheSh2dCk7KytQdDx2dDspanRbUHRdPUF0KFB0KTtyZXR1cm4ganR9ZnVuY3Rpb24gUzIodnQsQXQpe3JldHVybiB5ZShBdCxmdW5jdGlvbihQdCl7cmV0dXJuW1B0LHZ0W1B0XV19KX1mdW5jdGlvbiB3bCh2dCl7cmV0dXJuIHZ0JiZ2dC5zbGljZSgwLEZsKHZ0KSsxKS5yZXBsYWNlKHhzLCIiKX1mdW5jdGlvbiBaZSh2dCl7cmV0dXJuIGZ1bmN0aW9uKEF0KXtyZXR1cm4gdnQoQXQpfX1mdW5jdGlvbiBOcyh2dCxBdCl7cmV0dXJuIHllKEF0LGZ1bmN0aW9uKFB0KXtyZXR1cm4gdnRbUHRdfSl9ZnVuY3Rpb24gTG4odnQsQXQpe3JldHVybiB2dC5oYXMoQXQpfWZ1bmN0aW9uIE5sKHZ0LEF0KXtmb3IodmFyIFB0PS0xLGp0PXZ0Lmxlbmd0aDsrK1B0PGp0JiZ2bihBdCx2dFtQdF0sMCk+LTE7KTtyZXR1cm4gUHR9ZnVuY3Rpb24gQmwodnQsQXQpe2Zvcih2YXIgUHQ9dnQubGVuZ3RoO1B0LS0mJnZuKEF0LHZ0W1B0XSwwKT4tMTspO3JldHVybiBQdH1mdW5jdGlvbiBUMih2dCxBdCl7Zm9yKHZhciBQdD12dC5sZW5ndGgsanQ9MDtQdC0tOyl2dFtQdF09PT1BdCYmKytqdDtyZXR1cm4ganR9dmFyIFAyPUxzKGwyKSxiMj1Mcyh1Mik7ZnVuY3Rpb24gQTIodnQpe3JldHVybiJcXCIrYzJbdnRdfWZ1bmN0aW9uIEMyKHZ0LEF0KXtyZXR1cm4gdnQ9PW51bGw/dDp2dFtBdF19ZnVuY3Rpb24gcG4odnQpe3JldHVybiBpMi50ZXN0KHZ0KX1mdW5jdGlvbiBSMih2dCl7cmV0dXJuIHMyLnRlc3QodnQpfWZ1bmN0aW9uIEkyKHZ0KXtmb3IodmFyIEF0LFB0PVtdOyEoQXQ9dnQubmV4dCgpKS5kb25lOylQdC5wdXNoKEF0LnZhbHVlKTtyZXR1cm4gUHR9ZnVuY3Rpb24gQnModnQpe3ZhciBBdD0tMSxQdD1BcnJheSh2dC5zaXplKTtyZXR1cm4gdnQuZm9yRWFjaChmdW5jdGlvbihqdCxRdCl7UHRbKytBdF09W1F0LGp0XX0pLFB0fWZ1bmN0aW9uIFdsKHZ0LEF0KXtyZXR1cm4gZnVuY3Rpb24oUHQpe3JldHVybiB2dChBdChQdCkpfX1mdW5jdGlvbiBOcih2dCxBdCl7Zm9yKHZhciBQdD0tMSxqdD12dC5sZW5ndGgsUXQ9MCxhZT1bXTsrK1B0PGp0Oyl7dmFyIExlPXZ0W1B0XTsoTGU9PT1BdHx8TGU9PT1FKSYmKHZ0W1B0XT1FLGFlW1F0KytdPVB0KX1yZXR1cm4gYWV9ZnVuY3Rpb24gZ2kodnQpe3ZhciBBdD0tMSxQdD1BcnJheSh2dC5zaXplKTtyZXR1cm4gdnQuZm9yRWFjaChmdW5jdGlvbihqdCl7UHRbKytBdF09anR9KSxQdH1mdW5jdGlvbiBMMih2dCl7dmFyIEF0PS0xLFB0PUFycmF5KHZ0LnNpemUpO3JldHVybiB2dC5mb3JFYWNoKGZ1bmN0aW9uKGp0KXtQdFsrK0F0XT1banQsanRdfSksUHR9ZnVuY3Rpb24gRDIodnQsQXQsUHQpe2Zvcih2YXIganQ9UHQtMSxRdD12dC5sZW5ndGg7KytqdDxRdDspaWYodnRbanRdPT09QXQpcmV0dXJuIGp0O3JldHVybi0xfWZ1bmN0aW9uIHcyKHZ0LEF0LFB0KXtmb3IodmFyIGp0PVB0KzE7anQtLTspaWYodnRbanRdPT09QXQpcmV0dXJuIGp0O3JldHVybiBqdH1mdW5jdGlvbiBtbih2dCl7cmV0dXJuIHBuKHZ0KT9CMih2dCk6eTIodnQpfWZ1bmN0aW9uIHVyKHZ0KXtyZXR1cm4gcG4odnQpP1cyKHZ0KTp4Mih2dCl9ZnVuY3Rpb24gRmwodnQpe2Zvcih2YXIgQXQ9dnQubGVuZ3RoO0F0LS0mJlR5LnRlc3QodnQuY2hhckF0KEF0KSk7KTtyZXR1cm4gQXR9dmFyIE4yPUxzKGYyKTtmdW5jdGlvbiBCMih2dCl7Zm9yKHZhciBBdD1Ucy5sYXN0SW5kZXg9MDtUcy50ZXN0KHZ0KTspKytBdDtyZXR1cm4gQXR9ZnVuY3Rpb24gVzIodnQpe3JldHVybiB2dC5tYXRjaChUcyl8fFtdfWZ1bmN0aW9uIEYyKHZ0KXtyZXR1cm4gdnQubWF0Y2gobjIpfHxbXX12YXIgajI9ZnVuY3Rpb24gdnQoQXQpe0F0PUF0PT1udWxsP05lOnluLmRlZmF1bHRzKE5lLk9iamVjdCgpLEF0LHluLnBpY2soTmUsbzIpKTt2YXIgUHQ9QXQuQXJyYXksanQ9QXQuRGF0ZSxRdD1BdC5FcnJvcixhZT1BdC5GdW5jdGlvbixMZT1BdC5NYXRoLGhlPUF0Lk9iamVjdCxXcz1BdC5SZWdFeHAsVTI9QXQuU3RyaW5nLGVyPUF0LlR5cGVFcnJvcix2aT1QdC5wcm90b3R5cGUsejI9YWUucHJvdG90eXBlLHhuPWhlLnByb3RvdHlwZSxwaT1BdFsiX19jb3JlLWpzX3NoYXJlZF9fIl0sbWk9ejIudG9TdHJpbmcsZmU9eG4uaGFzT3duUHJvcGVydHksJDI9MCxqbD1mdW5jdGlvbigpe3ZhciByPS9bXi5dKyQvLmV4ZWMocGkmJnBpLmtleXMmJnBpLmtleXMuSUVfUFJPVE98fCIiKTtyZXR1cm4gcj8iU3ltYm9sKHNyYylfMS4iK3I6IiJ9KCkseWk9eG4udG9TdHJpbmcsRzI9bWkuY2FsbChoZSksSzI9TmUuXyxIMj1XcygiXiIrbWkuY2FsbChmZSkucmVwbGFjZSh5cywiXFwkJiIpLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFwoKXwgZm9yIC4rPyg/PVxcXF0pL2csIiQxLio/IikrIiQiKSx4aT1FbD9BdC5CdWZmZXI6dCxCcj1BdC5TeW1ib2wsT2k9QXQuVWludDhBcnJheSxVbD14aT94aS5hbGxvY1Vuc2FmZTp0LEVpPVdsKGhlLmdldFByb3RvdHlwZU9mLGhlKSx6bD1oZS5jcmVhdGUsJGw9eG4ucHJvcGVydHlJc0VudW1lcmFibGUsTWk9dmkuc3BsaWNlLEdsPUJyP0JyLmlzQ29uY2F0U3ByZWFkYWJsZTp0LERuPUJyP0JyLml0ZXJhdG9yOnQsWHI9QnI/QnIudG9TdHJpbmdUYWc6dCxTaT1mdW5jdGlvbigpe3RyeXt2YXIgcj1xcihoZSwiZGVmaW5lUHJvcGVydHkiKTtyZXR1cm4gcih7fSwiIix7fSkscn1jYXRjaHt9fSgpLFkyPUF0LmNsZWFyVGltZW91dCE9PU5lLmNsZWFyVGltZW91dCYmQXQuY2xlYXJUaW1lb3V0LFYyPWp0JiZqdC5ub3chPT1OZS5EYXRlLm5vdyYmanQubm93LFgyPUF0LnNldFRpbWVvdXQhPT1OZS5zZXRUaW1lb3V0JiZBdC5zZXRUaW1lb3V0LFRpPUxlLmNlaWwsUGk9TGUuZmxvb3IsRnM9aGUuZ2V0T3duUHJvcGVydHlTeW1ib2xzLFoyPXhpP3hpLmlzQnVmZmVyOnQsS2w9QXQuaXNGaW5pdGUsSjI9dmkuam9pbixRMj1XbChoZS5rZXlzLGhlKSxEZT1MZS5tYXgsV2U9TGUubWluLGsyPWp0Lm5vdyxxMj1BdC5wYXJzZUludCxIbD1MZS5yYW5kb20sXzI9dmkucmV2ZXJzZSxqcz1xcihBdCwiRGF0YVZpZXciKSx3bj1xcihBdCwiTWFwIiksVXM9cXIoQXQsIlByb21pc2UiKSxPbj1xcihBdCwiU2V0IiksTm49cXIoQXQsIldlYWtNYXAiKSxCbj1xcihoZSwiY3JlYXRlIiksYmk9Tm4mJm5ldyBObixFbj17fSx0eD1fcihqcyksZXg9X3Iod24pLHJ4PV9yKFVzKSxueD1fcihPbiksaXg9X3IoTm4pLEFpPUJyP0JyLnByb3RvdHlwZTp0LFduPUFpP0FpLnZhbHVlT2Y6dCxZbD1BaT9BaS50b1N0cmluZzp0O2Z1bmN0aW9uIHEocil7aWYoUGUocikmJiFrdChyKSYmIShyIGluc3RhbmNlb2YgcmUpKXtpZihyIGluc3RhbmNlb2YgcnIpcmV0dXJuIHI7aWYoZmUuY2FsbChyLCJfX3dyYXBwZWRfXyIpKXJldHVybiBWdShyKX1yZXR1cm4gbmV3IHJyKHIpfXZhciBNbj1mdW5jdGlvbigpe2Z1bmN0aW9uIHIoKXt9cmV0dXJuIGZ1bmN0aW9uKG8pe2lmKCFNZShvKSlyZXR1cm57fTtpZih6bClyZXR1cm4gemwobyk7ci5wcm90b3R5cGU9bzt2YXIgQz1uZXcgcjtyZXR1cm4gci5wcm90b3R5cGU9dCxDfX0oKTtmdW5jdGlvbiBDaSgpe31mdW5jdGlvbiBycihyLG8pe3RoaXMuX193cmFwcGVkX189cix0aGlzLl9fYWN0aW9uc19fPVtdLHRoaXMuX19jaGFpbl9fPSEhbyx0aGlzLl9faW5kZXhfXz0wLHRoaXMuX192YWx1ZXNfXz10fXEudGVtcGxhdGVTZXR0aW5ncz17ZXNjYXBlOnNlLGV2YWx1YXRlOlZlLGludGVycG9sYXRlOkxyLHZhcmlhYmxlOiIiLGltcG9ydHM6e186cX19LHEucHJvdG90eXBlPUNpLnByb3RvdHlwZSxxLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1xLHJyLnByb3RvdHlwZT1NbihDaS5wcm90b3R5cGUpLHJyLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1ycjtmdW5jdGlvbiByZShyKXt0aGlzLl9fd3JhcHBlZF9fPXIsdGhpcy5fX2FjdGlvbnNfXz1bXSx0aGlzLl9fZGlyX189MSx0aGlzLl9fZmlsdGVyZWRfXz0hMSx0aGlzLl9faXRlcmF0ZWVzX189W10sdGhpcy5fX3Rha2VDb3VudF9fPVksdGhpcy5fX3ZpZXdzX189W119ZnVuY3Rpb24gc3goKXt2YXIgcj1uZXcgcmUodGhpcy5fX3dyYXBwZWRfXyk7cmV0dXJuIHIuX19hY3Rpb25zX189R2UodGhpcy5fX2FjdGlvbnNfXyksci5fX2Rpcl9fPXRoaXMuX19kaXJfXyxyLl9fZmlsdGVyZWRfXz10aGlzLl9fZmlsdGVyZWRfXyxyLl9faXRlcmF0ZWVzX189R2UodGhpcy5fX2l0ZXJhdGVlc19fKSxyLl9fdGFrZUNvdW50X189dGhpcy5fX3Rha2VDb3VudF9fLHIuX192aWV3c19fPUdlKHRoaXMuX192aWV3c19fKSxyfWZ1bmN0aW9uIG94KCl7aWYodGhpcy5fX2ZpbHRlcmVkX18pe3ZhciByPW5ldyByZSh0aGlzKTtyLl9fZGlyX189LTEsci5fX2ZpbHRlcmVkX189ITB9ZWxzZSByPXRoaXMuY2xvbmUoKSxyLl9fZGlyX18qPS0xO3JldHVybiByfWZ1bmN0aW9uIGF4KCl7dmFyIHI9dGhpcy5fX3dyYXBwZWRfXy52YWx1ZSgpLG89dGhpcy5fX2Rpcl9fLEM9a3Qociksej1vPDAsWD1DP3IubGVuZ3RoOjAsZXQ9eE8oMCxYLHRoaXMuX192aWV3c19fKSxsdD1ldC5zdGFydCxmdD1ldC5lbmQseXQ9ZnQtbHQsUnQ9ej9mdDpsdC0xLEl0PXRoaXMuX19pdGVyYXRlZXNfXyx3dD1JdC5sZW5ndGgsV3Q9MCxVdD1XZSh5dCx0aGlzLl9fdGFrZUNvdW50X18pO2lmKCFDfHwheiYmWD09eXQmJlV0PT15dClyZXR1cm4gdnUocix0aGlzLl9fYWN0aW9uc19fKTt2YXIgWHQ9W107dDpmb3IoO3l0LS0mJld0PFV0Oyl7UnQrPW87Zm9yKHZhciBfdD0tMSxadD1yW1J0XTsrK190PHd0Oyl7dmFyIGVlPUl0W190XSxuZT1lZS5pdGVyYXRlZSxrZT1lZS50eXBlLHplPW5lKFp0KTtpZihrZT09ailadD16ZTtlbHNlIGlmKCF6ZSl7aWYoa2U9PUkpY29udGludWUgdDticmVhayB0fX1YdFtXdCsrXT1adH1yZXR1cm4gWHR9cmUucHJvdG90eXBlPU1uKENpLnByb3RvdHlwZSkscmUucHJvdG90eXBlLmNvbnN0cnVjdG9yPXJlO2Z1bmN0aW9uIFpyKHIpe3ZhciBvPS0xLEM9cj09bnVsbD8wOnIubGVuZ3RoO2Zvcih0aGlzLmNsZWFyKCk7KytvPEM7KXt2YXIgej1yW29dO3RoaXMuc2V0KHpbMF0selsxXSl9fWZ1bmN0aW9uIGx4KCl7dGhpcy5fX2RhdGFfXz1Cbj9CbihudWxsKTp7fSx0aGlzLnNpemU9MH1mdW5jdGlvbiB1eChyKXt2YXIgbz10aGlzLmhhcyhyKSYmZGVsZXRlIHRoaXMuX19kYXRhX19bcl07cmV0dXJuIHRoaXMuc2l6ZS09bz8xOjAsb31mdW5jdGlvbiBmeChyKXt2YXIgbz10aGlzLl9fZGF0YV9fO2lmKEJuKXt2YXIgQz1vW3JdO3JldHVybiBDPT09YT90OkN9cmV0dXJuIGZlLmNhbGwobyxyKT9vW3JdOnR9ZnVuY3Rpb24gY3gocil7dmFyIG89dGhpcy5fX2RhdGFfXztyZXR1cm4gQm4/b1tyXSE9PXQ6ZmUuY2FsbChvLHIpfWZ1bmN0aW9uIGh4KHIsbyl7dmFyIEM9dGhpcy5fX2RhdGFfXztyZXR1cm4gdGhpcy5zaXplKz10aGlzLmhhcyhyKT8wOjEsQ1tyXT1CbiYmbz09PXQ/YTpvLHRoaXN9WnIucHJvdG90eXBlLmNsZWFyPWx4LFpyLnByb3RvdHlwZS5kZWxldGU9dXgsWnIucHJvdG90eXBlLmdldD1meCxaci5wcm90b3R5cGUuaGFzPWN4LFpyLnByb3RvdHlwZS5zZXQ9aHg7ZnVuY3Rpb24geHIocil7dmFyIG89LTEsQz1yPT1udWxsPzA6ci5sZW5ndGg7Zm9yKHRoaXMuY2xlYXIoKTsrK288Qzspe3ZhciB6PXJbb107dGhpcy5zZXQoelswXSx6WzFdKX19ZnVuY3Rpb24gZHgoKXt0aGlzLl9fZGF0YV9fPVtdLHRoaXMuc2l6ZT0wfWZ1bmN0aW9uIGd4KHIpe3ZhciBvPXRoaXMuX19kYXRhX18sQz1SaShvLHIpO2lmKEM8MClyZXR1cm4hMTt2YXIgej1vLmxlbmd0aC0xO3JldHVybiBDPT16P28ucG9wKCk6TWkuY2FsbChvLEMsMSksLS10aGlzLnNpemUsITB9ZnVuY3Rpb24gdngocil7dmFyIG89dGhpcy5fX2RhdGFfXyxDPVJpKG8scik7cmV0dXJuIEM8MD90Om9bQ11bMV19ZnVuY3Rpb24gcHgocil7cmV0dXJuIFJpKHRoaXMuX19kYXRhX18scik+LTF9ZnVuY3Rpb24gbXgocixvKXt2YXIgQz10aGlzLl9fZGF0YV9fLHo9UmkoQyxyKTtyZXR1cm4gejwwPygrK3RoaXMuc2l6ZSxDLnB1c2goW3Isb10pKTpDW3pdWzFdPW8sdGhpc314ci5wcm90b3R5cGUuY2xlYXI9ZHgseHIucHJvdG90eXBlLmRlbGV0ZT1neCx4ci5wcm90b3R5cGUuZ2V0PXZ4LHhyLnByb3RvdHlwZS5oYXM9cHgseHIucHJvdG90eXBlLnNldD1teDtmdW5jdGlvbiBPcihyKXt2YXIgbz0tMSxDPXI9PW51bGw/MDpyLmxlbmd0aDtmb3IodGhpcy5jbGVhcigpOysrbzxDOyl7dmFyIHo9cltvXTt0aGlzLnNldCh6WzBdLHpbMV0pfX1mdW5jdGlvbiB5eCgpe3RoaXMuc2l6ZT0wLHRoaXMuX19kYXRhX189e2hhc2g6bmV3IFpyLG1hcDpuZXcod258fHhyKSxzdHJpbmc6bmV3IFpyfX1mdW5jdGlvbiB4eChyKXt2YXIgbz0kaSh0aGlzLHIpLmRlbGV0ZShyKTtyZXR1cm4gdGhpcy5zaXplLT1vPzE6MCxvfWZ1bmN0aW9uIE94KHIpe3JldHVybiAkaSh0aGlzLHIpLmdldChyKX1mdW5jdGlvbiBFeChyKXtyZXR1cm4gJGkodGhpcyxyKS5oYXMocil9ZnVuY3Rpb24gTXgocixvKXt2YXIgQz0kaSh0aGlzLHIpLHo9Qy5zaXplO3JldHVybiBDLnNldChyLG8pLHRoaXMuc2l6ZSs9Qy5zaXplPT16PzA6MSx0aGlzfU9yLnByb3RvdHlwZS5jbGVhcj15eCxPci5wcm90b3R5cGUuZGVsZXRlPXh4LE9yLnByb3RvdHlwZS5nZXQ9T3gsT3IucHJvdG90eXBlLmhhcz1FeCxPci5wcm90b3R5cGUuc2V0PU14O2Z1bmN0aW9uIEpyKHIpe3ZhciBvPS0xLEM9cj09bnVsbD8wOnIubGVuZ3RoO2Zvcih0aGlzLl9fZGF0YV9fPW5ldyBPcjsrK288QzspdGhpcy5hZGQocltvXSl9ZnVuY3Rpb24gU3gocil7cmV0dXJuIHRoaXMuX19kYXRhX18uc2V0KHIsYSksdGhpc31mdW5jdGlvbiBUeChyKXtyZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXMocil9SnIucHJvdG90eXBlLmFkZD1Kci5wcm90b3R5cGUucHVzaD1TeCxKci5wcm90b3R5cGUuaGFzPVR4O2Z1bmN0aW9uIGZyKHIpe3ZhciBvPXRoaXMuX19kYXRhX189bmV3IHhyKHIpO3RoaXMuc2l6ZT1vLnNpemV9ZnVuY3Rpb24gUHgoKXt0aGlzLl9fZGF0YV9fPW5ldyB4cix0aGlzLnNpemU9MH1mdW5jdGlvbiBieChyKXt2YXIgbz10aGlzLl9fZGF0YV9fLEM9by5kZWxldGUocik7cmV0dXJuIHRoaXMuc2l6ZT1vLnNpemUsQ31mdW5jdGlvbiBBeChyKXtyZXR1cm4gdGhpcy5fX2RhdGFfXy5nZXQocil9ZnVuY3Rpb24gQ3gocil7cmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKHIpfWZ1bmN0aW9uIFJ4KHIsbyl7dmFyIEM9dGhpcy5fX2RhdGFfXztpZihDIGluc3RhbmNlb2YgeHIpe3ZhciB6PUMuX19kYXRhX187aWYoIXdufHx6Lmxlbmd0aDxpLTEpcmV0dXJuIHoucHVzaChbcixvXSksdGhpcy5zaXplPSsrQy5zaXplLHRoaXM7Qz10aGlzLl9fZGF0YV9fPW5ldyBPcih6KX1yZXR1cm4gQy5zZXQocixvKSx0aGlzLnNpemU9Qy5zaXplLHRoaXN9ZnIucHJvdG90eXBlLmNsZWFyPVB4LGZyLnByb3RvdHlwZS5kZWxldGU9YngsZnIucHJvdG90eXBlLmdldD1BeCxmci5wcm90b3R5cGUuaGFzPUN4LGZyLnByb3RvdHlwZS5zZXQ9Ung7ZnVuY3Rpb24gVmwocixvKXt2YXIgQz1rdChyKSx6PSFDJiZ0bihyKSxYPSFDJiYheiYmenIociksZXQ9IUMmJiF6JiYhWCYmYm4ociksbHQ9Q3x8enx8WHx8ZXQsZnQ9bHQ/d3Moci5sZW5ndGgsVTIpOltdLHl0PWZ0Lmxlbmd0aDtmb3IodmFyIFJ0IGluIHIpKG98fGZlLmNhbGwocixSdCkpJiYhKGx0JiYoUnQ9PSJsZW5ndGgifHxYJiYoUnQ9PSJvZmZzZXQifHxSdD09InBhcmVudCIpfHxldCYmKFJ0PT0iYnVmZmVyInx8UnQ9PSJieXRlTGVuZ3RoInx8UnQ9PSJieXRlT2Zmc2V0Iil8fFRyKFJ0LHl0KSkpJiZmdC5wdXNoKFJ0KTtyZXR1cm4gZnR9ZnVuY3Rpb24gWGwocil7dmFyIG89ci5sZW5ndGg7cmV0dXJuIG8/cltRcygwLG8tMSldOnR9ZnVuY3Rpb24gSXgocixvKXtyZXR1cm4gR2koR2UociksUXIobywwLHIubGVuZ3RoKSl9ZnVuY3Rpb24gTHgocil7cmV0dXJuIEdpKEdlKHIpKX1mdW5jdGlvbiB6cyhyLG8sQyl7KEMhPT10JiYhY3IocltvXSxDKXx8Qz09PXQmJiEobyBpbiByKSkmJkVyKHIsbyxDKX1mdW5jdGlvbiBGbihyLG8sQyl7dmFyIHo9cltvXTsoIShmZS5jYWxsKHIsbykmJmNyKHosQykpfHxDPT09dCYmIShvIGluIHIpKSYmRXIocixvLEMpfWZ1bmN0aW9uIFJpKHIsbyl7Zm9yKHZhciBDPXIubGVuZ3RoO0MtLTspaWYoY3IocltDXVswXSxvKSlyZXR1cm4gQztyZXR1cm4tMX1mdW5jdGlvbiBEeChyLG8sQyx6KXtyZXR1cm4gV3IocixmdW5jdGlvbihYLGV0LGx0KXtvKHosWCxDKFgpLGx0KX0pLHp9ZnVuY3Rpb24gWmwocixvKXtyZXR1cm4gciYmdnIobyx3ZShvKSxyKX1mdW5jdGlvbiB3eChyLG8pe3JldHVybiByJiZ2cihvLEhlKG8pLHIpfWZ1bmN0aW9uIEVyKHIsbyxDKXtvPT0iX19wcm90b19fIiYmU2k/U2kocixvLHtjb25maWd1cmFibGU6ITAsZW51bWVyYWJsZTohMCx2YWx1ZTpDLHdyaXRhYmxlOiEwfSk6cltvXT1DfWZ1bmN0aW9uICRzKHIsbyl7Zm9yKHZhciBDPS0xLHo9by5sZW5ndGgsWD1QdCh6KSxldD1yPT1udWxsOysrQzx6OylYW0NdPWV0P3Q6TW8ocixvW0NdKTtyZXR1cm4gWH1mdW5jdGlvbiBRcihyLG8sQyl7cmV0dXJuIHI9PT1yJiYoQyE9PXQmJihyPXI8PUM/cjpDKSxvIT09dCYmKHI9cj49bz9yOm8pKSxyfWZ1bmN0aW9uIG5yKHIsbyxDLHosWCxldCl7dmFyIGx0LGZ0PW8mcCx5dD1vJk8sUnQ9byZtO2lmKEMmJihsdD1YP0Mocix6LFgsZXQpOkMocikpLGx0IT09dClyZXR1cm4gbHQ7aWYoIU1lKHIpKXJldHVybiByO3ZhciBJdD1rdChyKTtpZihJdCl7aWYobHQ9RU8ociksIWZ0KXJldHVybiBHZShyLGx0KX1lbHNle3ZhciB3dD1GZShyKSxXdD13dD09dHR8fHd0PT1GO2lmKHpyKHIpKXJldHVybiB5dShyLGZ0KTtpZih3dD09V3x8d3Q9PWh0fHxXdCYmIVgpe2lmKGx0PXl0fHxXdD97fTpGdShyKSwhZnQpcmV0dXJuIHl0P2ZPKHIsd3gobHQscikpOnVPKHIsWmwobHQscikpfWVsc2V7aWYoIWdlW3d0XSlyZXR1cm4gWD9yOnt9O2x0PU1PKHIsd3QsZnQpfX1ldHx8KGV0PW5ldyBmcik7dmFyIFV0PWV0LmdldChyKTtpZihVdClyZXR1cm4gVXQ7ZXQuc2V0KHIsbHQpLGRmKHIpP3IuZm9yRWFjaChmdW5jdGlvbihadCl7bHQuYWRkKG5yKFp0LG8sQyxadCxyLGV0KSl9KTpjZihyKSYmci5mb3JFYWNoKGZ1bmN0aW9uKFp0LGVlKXtsdC5zZXQoZWUsbnIoWnQsbyxDLGVlLHIsZXQpKX0pO3ZhciBYdD1SdD95dD9hbzpvbzp5dD9IZTp3ZSxfdD1JdD90Olh0KHIpO3JldHVybiB0cihfdHx8cixmdW5jdGlvbihadCxlZSl7X3QmJihlZT1adCxadD1yW2VlXSksRm4obHQsZWUsbnIoWnQsbyxDLGVlLHIsZXQpKX0pLGx0fWZ1bmN0aW9uIE54KHIpe3ZhciBvPXdlKHIpO3JldHVybiBmdW5jdGlvbihDKXtyZXR1cm4gSmwoQyxyLG8pfX1mdW5jdGlvbiBKbChyLG8sQyl7dmFyIHo9Qy5sZW5ndGg7aWYocj09bnVsbClyZXR1cm4hejtmb3Iocj1oZShyKTt6LS07KXt2YXIgWD1DW3pdLGV0PW9bWF0sbHQ9cltYXTtpZihsdD09PXQmJiEoWCBpbiByKXx8IWV0KGx0KSlyZXR1cm4hMX1yZXR1cm4hMH1mdW5jdGlvbiBRbChyLG8sQyl7aWYodHlwZW9mIHIhPSJmdW5jdGlvbiIpdGhyb3cgbmV3IGVyKGgpO3JldHVybiBIbihmdW5jdGlvbigpe3IuYXBwbHkodCxDKX0sbyl9ZnVuY3Rpb24gam4ocixvLEMseil7dmFyIFg9LTEsZXQ9aGksbHQ9ITAsZnQ9ci5sZW5ndGgseXQ9W10sUnQ9by5sZW5ndGg7aWYoIWZ0KXJldHVybiB5dDtDJiYobz15ZShvLFplKEMpKSksej8oZXQ9QXMsbHQ9ITEpOm8ubGVuZ3RoPj1pJiYoZXQ9TG4sbHQ9ITEsbz1uZXcgSnIobykpO3Q6Zm9yKDsrK1g8ZnQ7KXt2YXIgSXQ9cltYXSx3dD1DPT1udWxsP0l0OkMoSXQpO2lmKEl0PXp8fEl0IT09MD9JdDowLGx0JiZ3dD09PXd0KXtmb3IodmFyIFd0PVJ0O1d0LS07KWlmKG9bV3RdPT09d3QpY29udGludWUgdDt5dC5wdXNoKEl0KX1lbHNlIGV0KG8sd3Qseil8fHl0LnB1c2goSXQpfXJldHVybiB5dH12YXIgV3I9U3UoZ3IpLGtsPVN1KEtzLCEwKTtmdW5jdGlvbiBCeChyLG8pe3ZhciBDPSEwO3JldHVybiBXcihyLGZ1bmN0aW9uKHosWCxldCl7cmV0dXJuIEM9ISFvKHosWCxldCksQ30pLEN9ZnVuY3Rpb24gSWkocixvLEMpe2Zvcih2YXIgej0tMSxYPXIubGVuZ3RoOysrejxYOyl7dmFyIGV0PXJbel0sbHQ9byhldCk7aWYobHQhPW51bGwmJihmdD09PXQ/bHQ9PT1sdCYmIVFlKGx0KTpDKGx0LGZ0KSkpdmFyIGZ0PWx0LHl0PWV0fXJldHVybiB5dH1mdW5jdGlvbiBXeChyLG8sQyx6KXt2YXIgWD1yLmxlbmd0aDtmb3IoQz1xdChDKSxDPDAmJihDPS1DPlg/MDpYK0MpLHo9ej09PXR8fHo+WD9YOnF0KHopLHo8MCYmKHorPVgpLHo9Qz56PzA6dmYoeik7Qzx6OylyW0MrK109bztyZXR1cm4gcn1mdW5jdGlvbiBxbChyLG8pe3ZhciBDPVtdO3JldHVybiBXcihyLGZ1bmN0aW9uKHosWCxldCl7byh6LFgsZXQpJiZDLnB1c2goeil9KSxDfWZ1bmN0aW9uIEJlKHIsbyxDLHosWCl7dmFyIGV0PS0xLGx0PXIubGVuZ3RoO2ZvcihDfHwoQz1UTyksWHx8KFg9W10pOysrZXQ8bHQ7KXt2YXIgZnQ9cltldF07bz4wJiZDKGZ0KT9vPjE/QmUoZnQsby0xLEMseixYKTp3cihYLGZ0KTp6fHwoWFtYLmxlbmd0aF09ZnQpfXJldHVybiBYfXZhciBHcz1UdSgpLF9sPVR1KCEwKTtmdW5jdGlvbiBncihyLG8pe3JldHVybiByJiZHcyhyLG8sd2UpfWZ1bmN0aW9uIEtzKHIsbyl7cmV0dXJuIHImJl9sKHIsbyx3ZSl9ZnVuY3Rpb24gTGkocixvKXtyZXR1cm4gRHIobyxmdW5jdGlvbihDKXtyZXR1cm4gUHIocltDXSl9KX1mdW5jdGlvbiBrcihyLG8pe289anIobyxyKTtmb3IodmFyIEM9MCx6PW8ubGVuZ3RoO3IhPW51bGwmJkM8ejspcj1yW3ByKG9bQysrXSldO3JldHVybiBDJiZDPT16P3I6dH1mdW5jdGlvbiB0dShyLG8sQyl7dmFyIHo9byhyKTtyZXR1cm4ga3Qocik/ejp3cih6LEMocikpfWZ1bmN0aW9uIGplKHIpe3JldHVybiByPT1udWxsP3I9PT10P3B0OlA6WHImJlhyIGluIGhlKHIpP3lPKHIpOkxPKHIpfWZ1bmN0aW9uIEhzKHIsbyl7cmV0dXJuIHI+b31mdW5jdGlvbiBGeChyLG8pe3JldHVybiByIT1udWxsJiZmZS5jYWxsKHIsbyl9ZnVuY3Rpb24gangocixvKXtyZXR1cm4gciE9bnVsbCYmbyBpbiBoZShyKX1mdW5jdGlvbiBVeChyLG8sQyl7cmV0dXJuIHI+PVdlKG8sQykmJnI8RGUobyxDKX1mdW5jdGlvbiBZcyhyLG8sQyl7Zm9yKHZhciB6PUM/QXM6aGksWD1yWzBdLmxlbmd0aCxldD1yLmxlbmd0aCxsdD1ldCxmdD1QdChldCkseXQ9MS8wLFJ0PVtdO2x0LS07KXt2YXIgSXQ9cltsdF07bHQmJm8mJihJdD15ZShJdCxaZShvKSkpLHl0PVdlKEl0Lmxlbmd0aCx5dCksZnRbbHRdPSFDJiYob3x8WD49MTIwJiZJdC5sZW5ndGg+PTEyMCk/bmV3IEpyKGx0JiZJdCk6dH1JdD1yWzBdO3ZhciB3dD0tMSxXdD1mdFswXTt0OmZvcig7Kyt3dDxYJiZSdC5sZW5ndGg8eXQ7KXt2YXIgVXQ9SXRbd3RdLFh0PW8/byhVdCk6VXQ7aWYoVXQ9Q3x8VXQhPT0wP1V0OjAsIShXdD9MbihXdCxYdCk6eihSdCxYdCxDKSkpe2ZvcihsdD1ldDstLWx0Oyl7dmFyIF90PWZ0W2x0XTtpZighKF90P0xuKF90LFh0KTp6KHJbbHRdLFh0LEMpKSljb250aW51ZSB0fVd0JiZXdC5wdXNoKFh0KSxSdC5wdXNoKFV0KX19cmV0dXJuIFJ0fWZ1bmN0aW9uIHp4KHIsbyxDLHope3JldHVybiBncihyLGZ1bmN0aW9uKFgsZXQsbHQpe28oeixDKFgpLGV0LGx0KX0pLHp9ZnVuY3Rpb24gVW4ocixvLEMpe289anIobyxyKSxyPSR1KHIsbyk7dmFyIHo9cj09bnVsbD9yOnJbcHIoc3IobykpXTtyZXR1cm4gej09bnVsbD90OlhlKHoscixDKX1mdW5jdGlvbiBldShyKXtyZXR1cm4gUGUocikmJmplKHIpPT1odH1mdW5jdGlvbiAkeChyKXtyZXR1cm4gUGUocikmJmplKHIpPT1kdH1mdW5jdGlvbiBHeChyKXtyZXR1cm4gUGUocikmJmplKHIpPT1VfWZ1bmN0aW9uIHpuKHIsbyxDLHosWCl7cmV0dXJuIHI9PT1vPyEwOnI9PW51bGx8fG89PW51bGx8fCFQZShyKSYmIVBlKG8pP3IhPT1yJiZvIT09bzpLeChyLG8sQyx6LHpuLFgpfWZ1bmN0aW9uIEt4KHIsbyxDLHosWCxldCl7dmFyIGx0PWt0KHIpLGZ0PWt0KG8pLHl0PWx0P2l0OkZlKHIpLFJ0PWZ0P2l0OkZlKG8pO3l0PXl0PT1odD9XOnl0LFJ0PVJ0PT1odD9XOlJ0O3ZhciBJdD15dD09Vyx3dD1SdD09VyxXdD15dD09UnQ7aWYoV3QmJnpyKHIpKXtpZighenIobykpcmV0dXJuITE7bHQ9ITAsSXQ9ITF9aWYoV3QmJiFJdClyZXR1cm4gZXR8fChldD1uZXcgZnIpLGx0fHxibihyKT9OdShyLG8sQyx6LFgsZXQpOnBPKHIsbyx5dCxDLHosWCxldCk7aWYoIShDJmIpKXt2YXIgVXQ9SXQmJmZlLmNhbGwociwiX193cmFwcGVkX18iKSxYdD13dCYmZmUuY2FsbChvLCJfX3dyYXBwZWRfXyIpO2lmKFV0fHxYdCl7dmFyIF90PVV0P3IudmFsdWUoKTpyLFp0PVh0P28udmFsdWUoKTpvO3JldHVybiBldHx8KGV0PW5ldyBmciksWChfdCxadCxDLHosZXQpfX1yZXR1cm4gV3Q/KGV0fHwoZXQ9bmV3IGZyKSxtTyhyLG8sQyx6LFgsZXQpKTohMX1mdW5jdGlvbiBIeChyKXtyZXR1cm4gUGUocikmJkZlKHIpPT1IfWZ1bmN0aW9uIFZzKHIsbyxDLHope3ZhciBYPUMubGVuZ3RoLGV0PVgsbHQ9IXo7aWYocj09bnVsbClyZXR1cm4hZXQ7Zm9yKHI9aGUocik7WC0tOyl7dmFyIGZ0PUNbWF07aWYobHQmJmZ0WzJdP2Z0WzFdIT09cltmdFswXV06IShmdFswXWluIHIpKXJldHVybiExfWZvcig7KytYPGV0Oyl7ZnQ9Q1tYXTt2YXIgeXQ9ZnRbMF0sUnQ9clt5dF0sSXQ9ZnRbMV07aWYobHQmJmZ0WzJdKXtpZihSdD09PXQmJiEoeXQgaW4gcikpcmV0dXJuITF9ZWxzZXt2YXIgd3Q9bmV3IGZyO2lmKHopdmFyIFd0PXooUnQsSXQseXQscixvLHd0KTtpZighKFd0PT09dD96bihJdCxSdCxifE0seix3dCk6V3QpKXJldHVybiExfX1yZXR1cm4hMH1mdW5jdGlvbiBydShyKXtpZighTWUocil8fGJPKHIpKXJldHVybiExO3ZhciBvPVByKHIpP0gyOk55O3JldHVybiBvLnRlc3QoX3IocikpfWZ1bmN0aW9uIFl4KHIpe3JldHVybiBQZShyKSYmamUocik9PWt9ZnVuY3Rpb24gVngocil7cmV0dXJuIFBlKHIpJiZGZShyKT09bnR9ZnVuY3Rpb24gWHgocil7cmV0dXJuIFBlKHIpJiZaaShyLmxlbmd0aCkmJiEhcGVbamUocildfWZ1bmN0aW9uIG51KHIpe3JldHVybiB0eXBlb2Ygcj09ImZ1bmN0aW9uIj9yOnI9PW51bGw/WWU6dHlwZW9mIHI9PSJvYmplY3QiP2t0KHIpP291KHJbMF0sclsxXSk6c3Uocik6YmYocil9ZnVuY3Rpb24gWHMocil7aWYoIUtuKHIpKXJldHVybiBRMihyKTt2YXIgbz1bXTtmb3IodmFyIEMgaW4gaGUocikpZmUuY2FsbChyLEMpJiZDIT0iY29uc3RydWN0b3IiJiZvLnB1c2goQyk7cmV0dXJuIG99ZnVuY3Rpb24gWngocil7aWYoIU1lKHIpKXJldHVybiBJTyhyKTt2YXIgbz1LbihyKSxDPVtdO2Zvcih2YXIgeiBpbiByKXo9PSJjb25zdHJ1Y3RvciImJihvfHwhZmUuY2FsbChyLHopKXx8Qy5wdXNoKHopO3JldHVybiBDfWZ1bmN0aW9uIFpzKHIsbyl7cmV0dXJuIHI8b31mdW5jdGlvbiBpdShyLG8pe3ZhciBDPS0xLHo9S2Uocik/UHQoci5sZW5ndGgpOltdO3JldHVybiBXcihyLGZ1bmN0aW9uKFgsZXQsbHQpe3pbKytDXT1vKFgsZXQsbHQpfSksen1mdW5jdGlvbiBzdShyKXt2YXIgbz11byhyKTtyZXR1cm4gby5sZW5ndGg9PTEmJm9bMF1bMl0/VXUob1swXVswXSxvWzBdWzFdKTpmdW5jdGlvbihDKXtyZXR1cm4gQz09PXJ8fFZzKEMscixvKX19ZnVuY3Rpb24gb3UocixvKXtyZXR1cm4gY28ocikmJmp1KG8pP1V1KHByKHIpLG8pOmZ1bmN0aW9uKEMpe3ZhciB6PU1vKEMscik7cmV0dXJuIHo9PT10JiZ6PT09bz9TbyhDLHIpOnpuKG8seixifE0pfX1mdW5jdGlvbiBEaShyLG8sQyx6LFgpe3IhPT1vJiZHcyhvLGZ1bmN0aW9uKGV0LGx0KXtpZihYfHwoWD1uZXcgZnIpLE1lKGV0KSlKeChyLG8sbHQsQyxEaSx6LFgpO2Vsc2V7dmFyIGZ0PXo/eihnbyhyLGx0KSxldCxsdCsiIixyLG8sWCk6dDtmdD09PXQmJihmdD1ldCksenMocixsdCxmdCl9fSxIZSl9ZnVuY3Rpb24gSngocixvLEMseixYLGV0LGx0KXt2YXIgZnQ9Z28ocixDKSx5dD1nbyhvLEMpLFJ0PWx0LmdldCh5dCk7aWYoUnQpe3pzKHIsQyxSdCk7cmV0dXJufXZhciBJdD1ldD9ldChmdCx5dCxDKyIiLHIsbyxsdCk6dCx3dD1JdD09PXQ7aWYod3Qpe3ZhciBXdD1rdCh5dCksVXQ9IVd0JiZ6cih5dCksWHQ9IVd0JiYhVXQmJmJuKHl0KTtJdD15dCxXdHx8VXR8fFh0P2t0KGZ0KT9JdD1mdDpBZShmdCk/SXQ9R2UoZnQpOlV0Pyh3dD0hMSxJdD15dSh5dCwhMCkpOlh0Pyh3dD0hMSxJdD14dSh5dCwhMCkpOkl0PVtdOlluKHl0KXx8dG4oeXQpPyhJdD1mdCx0bihmdCk/SXQ9cGYoZnQpOighTWUoZnQpfHxQcihmdCkpJiYoSXQ9RnUoeXQpKSk6d3Q9ITF9d3QmJihsdC5zZXQoeXQsSXQpLFgoSXQseXQseixldCxsdCksbHQuZGVsZXRlKHl0KSksenMocixDLEl0KX1mdW5jdGlvbiBhdShyLG8pe3ZhciBDPXIubGVuZ3RoO2lmKEMpcmV0dXJuIG8rPW88MD9DOjAsVHIobyxDKT9yW29dOnR9ZnVuY3Rpb24gbHUocixvLEMpe28ubGVuZ3RoP289eWUobyxmdW5jdGlvbihldCl7cmV0dXJuIGt0KGV0KT9mdW5jdGlvbihsdCl7cmV0dXJuIGtyKGx0LGV0Lmxlbmd0aD09PTE/ZXRbMF06ZXQpfTpldH0pOm89W1llXTt2YXIgej0tMTtvPXllKG8sWmUoSHQoKSkpO3ZhciBYPWl1KHIsZnVuY3Rpb24oZXQsbHQsZnQpe3ZhciB5dD15ZShvLGZ1bmN0aW9uKFJ0KXtyZXR1cm4gUnQoZXQpfSk7cmV0dXJue2NyaXRlcmlhOnl0LGluZGV4Oisreix2YWx1ZTpldH19KTtyZXR1cm4gTTIoWCxmdW5jdGlvbihldCxsdCl7cmV0dXJuIGxPKGV0LGx0LEMpfSl9ZnVuY3Rpb24gUXgocixvKXtyZXR1cm4gdXUocixvLGZ1bmN0aW9uKEMseil7cmV0dXJuIFNvKHIseil9KX1mdW5jdGlvbiB1dShyLG8sQyl7Zm9yKHZhciB6PS0xLFg9by5sZW5ndGgsZXQ9e307Kyt6PFg7KXt2YXIgbHQ9b1t6XSxmdD1rcihyLGx0KTtDKGZ0LGx0KSYmJG4oZXQsanIobHQsciksZnQpfXJldHVybiBldH1mdW5jdGlvbiBreChyKXtyZXR1cm4gZnVuY3Rpb24obyl7cmV0dXJuIGtyKG8scil9fWZ1bmN0aW9uIEpzKHIsbyxDLHope3ZhciBYPXo/RTI6dm4sZXQ9LTEsbHQ9by5sZW5ndGgsZnQ9cjtmb3Iocj09PW8mJihvPUdlKG8pKSxDJiYoZnQ9eWUocixaZShDKSkpOysrZXQ8bHQ7KWZvcih2YXIgeXQ9MCxSdD1vW2V0XSxJdD1DP0MoUnQpOlJ0Oyh5dD1YKGZ0LEl0LHl0LHopKT4tMTspZnQhPT1yJiZNaS5jYWxsKGZ0LHl0LDEpLE1pLmNhbGwocix5dCwxKTtyZXR1cm4gcn1mdW5jdGlvbiBmdShyLG8pe2Zvcih2YXIgQz1yP28ubGVuZ3RoOjAsej1DLTE7Qy0tOyl7dmFyIFg9b1tDXTtpZihDPT16fHxYIT09ZXQpe3ZhciBldD1YO1RyKFgpP01pLmNhbGwocixYLDEpOl9zKHIsWCl9fXJldHVybiByfWZ1bmN0aW9uIFFzKHIsbyl7cmV0dXJuIHIrUGkoSGwoKSooby1yKzEpKX1mdW5jdGlvbiBxeChyLG8sQyx6KXtmb3IodmFyIFg9LTEsZXQ9RGUoVGkoKG8tcikvKEN8fDEpKSwwKSxsdD1QdChldCk7ZXQtLTspbHRbej9ldDorK1hdPXIscis9QztyZXR1cm4gbHR9ZnVuY3Rpb24ga3MocixvKXt2YXIgQz0iIjtpZighcnx8bzwxfHxvPl8pcmV0dXJuIEM7ZG8gbyUyJiYoQys9ciksbz1QaShvLzIpLG8mJihyKz1yKTt3aGlsZShvKTtyZXR1cm4gQ31mdW5jdGlvbiB0ZShyLG8pe3JldHVybiB2byh6dShyLG8sWWUpLHIrIiIpfWZ1bmN0aW9uIF94KHIpe3JldHVybiBYbChBbihyKSl9ZnVuY3Rpb24gdE8ocixvKXt2YXIgQz1BbihyKTtyZXR1cm4gR2koQyxRcihvLDAsQy5sZW5ndGgpKX1mdW5jdGlvbiAkbihyLG8sQyx6KXtpZighTWUocikpcmV0dXJuIHI7bz1qcihvLHIpO2Zvcih2YXIgWD0tMSxldD1vLmxlbmd0aCxsdD1ldC0xLGZ0PXI7ZnQhPW51bGwmJisrWDxldDspe3ZhciB5dD1wcihvW1hdKSxSdD1DO2lmKHl0PT09Il9fcHJvdG9fXyJ8fHl0PT09ImNvbnN0cnVjdG9yInx8eXQ9PT0icHJvdG90eXBlIilyZXR1cm4gcjtpZihYIT1sdCl7dmFyIEl0PWZ0W3l0XTtSdD16P3ooSXQseXQsZnQpOnQsUnQ9PT10JiYoUnQ9TWUoSXQpP0l0OlRyKG9bWCsxXSk/W106e30pfUZuKGZ0LHl0LFJ0KSxmdD1mdFt5dF19cmV0dXJuIHJ9dmFyIGN1PWJpP2Z1bmN0aW9uKHIsbyl7cmV0dXJuIGJpLnNldChyLG8pLHJ9OlllLGVPPVNpP2Z1bmN0aW9uKHIsbyl7cmV0dXJuIFNpKHIsInRvU3RyaW5nIix7Y29uZmlndXJhYmxlOiEwLGVudW1lcmFibGU6ITEsdmFsdWU6UG8obyksd3JpdGFibGU6ITB9KX06WWU7ZnVuY3Rpb24gck8ocil7cmV0dXJuIEdpKEFuKHIpKX1mdW5jdGlvbiBpcihyLG8sQyl7dmFyIHo9LTEsWD1yLmxlbmd0aDtvPDAmJihvPS1vPlg/MDpYK28pLEM9Qz5YP1g6QyxDPDAmJihDKz1YKSxYPW8+Qz8wOkMtbz4+PjAsbz4+Pj0wO2Zvcih2YXIgZXQ9UHQoWCk7Kyt6PFg7KWV0W3pdPXJbeitvXTtyZXR1cm4gZXR9ZnVuY3Rpb24gbk8ocixvKXt2YXIgQztyZXR1cm4gV3IocixmdW5jdGlvbih6LFgsZXQpe3JldHVybiBDPW8oeixYLGV0KSwhQ30pLCEhQ31mdW5jdGlvbiB3aShyLG8sQyl7dmFyIHo9MCxYPXI9PW51bGw/ejpyLmxlbmd0aDtpZih0eXBlb2Ygbz09Im51bWJlciImJm89PT1vJiZYPD1vdCl7Zm9yKDt6PFg7KXt2YXIgZXQ9eitYPj4+MSxsdD1yW2V0XTtsdCE9PW51bGwmJiFRZShsdCkmJihDP2x0PD1vOmx0PG8pP3o9ZXQrMTpYPWV0fXJldHVybiBYfXJldHVybiBxcyhyLG8sWWUsQyl9ZnVuY3Rpb24gcXMocixvLEMseil7dmFyIFg9MCxldD1yPT1udWxsPzA6ci5sZW5ndGg7aWYoZXQ9PT0wKXJldHVybiAwO289QyhvKTtmb3IodmFyIGx0PW8hPT1vLGZ0PW89PT1udWxsLHl0PVFlKG8pLFJ0PW89PT10O1g8ZXQ7KXt2YXIgSXQ9UGkoKFgrZXQpLzIpLHd0PUMocltJdF0pLFd0PXd0IT09dCxVdD13dD09PW51bGwsWHQ9d3Q9PT13dCxfdD1RZSh3dCk7aWYobHQpdmFyIFp0PXp8fFh0O2Vsc2UgUnQ/WnQ9WHQmJih6fHxXdCk6ZnQ/WnQ9WHQmJld0JiYoenx8IVV0KTp5dD9adD1YdCYmV3QmJiFVdCYmKHp8fCFfdCk6VXR8fF90P1p0PSExOlp0PXo/d3Q8PW86d3Q8bztadD9YPUl0KzE6ZXQ9SXR9cmV0dXJuIFdlKGV0LHJ0KX1mdW5jdGlvbiBodShyLG8pe2Zvcih2YXIgQz0tMSx6PXIubGVuZ3RoLFg9MCxldD1bXTsrK0M8ejspe3ZhciBsdD1yW0NdLGZ0PW8/byhsdCk6bHQ7aWYoIUN8fCFjcihmdCx5dCkpe3ZhciB5dD1mdDtldFtYKytdPWx0PT09MD8wOmx0fX1yZXR1cm4gZXR9ZnVuY3Rpb24gZHUocil7cmV0dXJuIHR5cGVvZiByPT0ibnVtYmVyIj9yOlFlKHIpP0c6K3J9ZnVuY3Rpb24gSmUocil7aWYodHlwZW9mIHI9PSJzdHJpbmciKXJldHVybiByO2lmKGt0KHIpKXJldHVybiB5ZShyLEplKSsiIjtpZihRZShyKSlyZXR1cm4gWWw/WWwuY2FsbChyKToiIjt2YXIgbz1yKyIiO3JldHVybiBvPT0iMCImJjEvcj09LUo/Ii0wIjpvfWZ1bmN0aW9uIEZyKHIsbyxDKXt2YXIgej0tMSxYPWhpLGV0PXIubGVuZ3RoLGx0PSEwLGZ0PVtdLHl0PWZ0O2lmKEMpbHQ9ITEsWD1BcztlbHNlIGlmKGV0Pj1pKXt2YXIgUnQ9bz9udWxsOmdPKHIpO2lmKFJ0KXJldHVybiBnaShSdCk7bHQ9ITEsWD1Mbix5dD1uZXcgSnJ9ZWxzZSB5dD1vP1tdOmZ0O3Q6Zm9yKDsrK3o8ZXQ7KXt2YXIgSXQ9clt6XSx3dD1vP28oSXQpOkl0O2lmKEl0PUN8fEl0IT09MD9JdDowLGx0JiZ3dD09PXd0KXtmb3IodmFyIFd0PXl0Lmxlbmd0aDtXdC0tOylpZih5dFtXdF09PT13dCljb250aW51ZSB0O28mJnl0LnB1c2god3QpLGZ0LnB1c2goSXQpfWVsc2UgWCh5dCx3dCxDKXx8KHl0IT09ZnQmJnl0LnB1c2god3QpLGZ0LnB1c2goSXQpKX1yZXR1cm4gZnR9ZnVuY3Rpb24gX3MocixvKXtyZXR1cm4gbz1qcihvLHIpLHI9JHUocixvKSxyPT1udWxsfHxkZWxldGUgcltwcihzcihvKSldfWZ1bmN0aW9uIGd1KHIsbyxDLHope3JldHVybiAkbihyLG8sQyhrcihyLG8pKSx6KX1mdW5jdGlvbiBOaShyLG8sQyx6KXtmb3IodmFyIFg9ci5sZW5ndGgsZXQ9ej9YOi0xOyh6P2V0LS06KytldDxYKSYmbyhyW2V0XSxldCxyKTspO3JldHVybiBDP2lyKHIsej8wOmV0LHo/ZXQrMTpYKTppcihyLHo/ZXQrMTowLHo/WDpldCl9ZnVuY3Rpb24gdnUocixvKXt2YXIgQz1yO3JldHVybiBDIGluc3RhbmNlb2YgcmUmJihDPUMudmFsdWUoKSksQ3MobyxmdW5jdGlvbih6LFgpe3JldHVybiBYLmZ1bmMuYXBwbHkoWC50aGlzQXJnLHdyKFt6XSxYLmFyZ3MpKX0sQyl9ZnVuY3Rpb24gdG8ocixvLEMpe3ZhciB6PXIubGVuZ3RoO2lmKHo8MilyZXR1cm4gej9GcihyWzBdKTpbXTtmb3IodmFyIFg9LTEsZXQ9UHQoeik7KytYPHo7KWZvcih2YXIgbHQ9cltYXSxmdD0tMTsrK2Z0PHo7KWZ0IT1YJiYoZXRbWF09am4oZXRbWF18fGx0LHJbZnRdLG8sQykpO3JldHVybiBGcihCZShldCwxKSxvLEMpfWZ1bmN0aW9uIHB1KHIsbyxDKXtmb3IodmFyIHo9LTEsWD1yLmxlbmd0aCxldD1vLmxlbmd0aCxsdD17fTsrK3o8WDspe3ZhciBmdD16PGV0P29bel06dDtDKGx0LHJbel0sZnQpfXJldHVybiBsdH1mdW5jdGlvbiBlbyhyKXtyZXR1cm4gQWUocik/cjpbXX1mdW5jdGlvbiBybyhyKXtyZXR1cm4gdHlwZW9mIHI9PSJmdW5jdGlvbiI/cjpZZX1mdW5jdGlvbiBqcihyLG8pe3JldHVybiBrdChyKT9yOmNvKHIsbyk/W3JdOll1KHVlKHIpKX12YXIgaU89dGU7ZnVuY3Rpb24gVXIocixvLEMpe3ZhciB6PXIubGVuZ3RoO3JldHVybiBDPUM9PT10P3o6QywhbyYmQz49ej9yOmlyKHIsbyxDKX12YXIgbXU9WTJ8fGZ1bmN0aW9uKHIpe3JldHVybiBOZS5jbGVhclRpbWVvdXQocil9O2Z1bmN0aW9uIHl1KHIsbyl7aWYobylyZXR1cm4gci5zbGljZSgpO3ZhciBDPXIubGVuZ3RoLHo9VWw/VWwoQyk6bmV3IHIuY29uc3RydWN0b3IoQyk7cmV0dXJuIHIuY29weSh6KSx6fWZ1bmN0aW9uIG5vKHIpe3ZhciBvPW5ldyByLmNvbnN0cnVjdG9yKHIuYnl0ZUxlbmd0aCk7cmV0dXJuIG5ldyBPaShvKS5zZXQobmV3IE9pKHIpKSxvfWZ1bmN0aW9uIHNPKHIsbyl7dmFyIEM9bz9ubyhyLmJ1ZmZlcik6ci5idWZmZXI7cmV0dXJuIG5ldyByLmNvbnN0cnVjdG9yKEMsci5ieXRlT2Zmc2V0LHIuYnl0ZUxlbmd0aCl9ZnVuY3Rpb24gb08ocil7dmFyIG89bmV3IHIuY29uc3RydWN0b3Ioci5zb3VyY2UsZWwuZXhlYyhyKSk7cmV0dXJuIG8ubGFzdEluZGV4PXIubGFzdEluZGV4LG99ZnVuY3Rpb24gYU8ocil7cmV0dXJuIFduP2hlKFduLmNhbGwocikpOnt9fWZ1bmN0aW9uIHh1KHIsbyl7dmFyIEM9bz9ubyhyLmJ1ZmZlcik6ci5idWZmZXI7cmV0dXJuIG5ldyByLmNvbnN0cnVjdG9yKEMsci5ieXRlT2Zmc2V0LHIubGVuZ3RoKX1mdW5jdGlvbiBPdShyLG8pe2lmKHIhPT1vKXt2YXIgQz1yIT09dCx6PXI9PT1udWxsLFg9cj09PXIsZXQ9UWUociksbHQ9byE9PXQsZnQ9bz09PW51bGwseXQ9bz09PW8sUnQ9UWUobyk7aWYoIWZ0JiYhUnQmJiFldCYmcj5vfHxldCYmbHQmJnl0JiYhZnQmJiFSdHx8eiYmbHQmJnl0fHwhQyYmeXR8fCFYKXJldHVybiAxO2lmKCF6JiYhZXQmJiFSdCYmcjxvfHxSdCYmQyYmWCYmIXomJiFldHx8ZnQmJkMmJlh8fCFsdCYmWHx8IXl0KXJldHVybi0xfXJldHVybiAwfWZ1bmN0aW9uIGxPKHIsbyxDKXtmb3IodmFyIHo9LTEsWD1yLmNyaXRlcmlhLGV0PW8uY3JpdGVyaWEsbHQ9WC5sZW5ndGgsZnQ9Qy5sZW5ndGg7Kyt6PGx0Oyl7dmFyIHl0PU91KFhbel0sZXRbel0pO2lmKHl0KXtpZih6Pj1mdClyZXR1cm4geXQ7dmFyIFJ0PUNbel07cmV0dXJuIHl0KihSdD09ImRlc2MiPy0xOjEpfX1yZXR1cm4gci5pbmRleC1vLmluZGV4fWZ1bmN0aW9uIEV1KHIsbyxDLHope2Zvcih2YXIgWD0tMSxldD1yLmxlbmd0aCxsdD1DLmxlbmd0aCxmdD0tMSx5dD1vLmxlbmd0aCxSdD1EZShldC1sdCwwKSxJdD1QdCh5dCtSdCksd3Q9IXo7KytmdDx5dDspSXRbZnRdPW9bZnRdO2Zvcig7KytYPGx0Oykod3R8fFg8ZXQpJiYoSXRbQ1tYXV09cltYXSk7Zm9yKDtSdC0tOylJdFtmdCsrXT1yW1grK107cmV0dXJuIEl0fWZ1bmN0aW9uIE11KHIsbyxDLHope2Zvcih2YXIgWD0tMSxldD1yLmxlbmd0aCxsdD0tMSxmdD1DLmxlbmd0aCx5dD0tMSxSdD1vLmxlbmd0aCxJdD1EZShldC1mdCwwKSx3dD1QdChJdCtSdCksV3Q9IXo7KytYPEl0Oyl3dFtYXT1yW1hdO2Zvcih2YXIgVXQ9WDsrK3l0PFJ0Oyl3dFtVdCt5dF09b1t5dF07Zm9yKDsrK2x0PGZ0OykoV3R8fFg8ZXQpJiYod3RbVXQrQ1tsdF1dPXJbWCsrXSk7cmV0dXJuIHd0fWZ1bmN0aW9uIEdlKHIsbyl7dmFyIEM9LTEsej1yLmxlbmd0aDtmb3Iob3x8KG89UHQoeikpOysrQzx6OylvW0NdPXJbQ107cmV0dXJuIG99ZnVuY3Rpb24gdnIocixvLEMseil7dmFyIFg9IUM7Q3x8KEM9e30pO2Zvcih2YXIgZXQ9LTEsbHQ9by5sZW5ndGg7KytldDxsdDspe3ZhciBmdD1vW2V0XSx5dD16P3ooQ1tmdF0scltmdF0sZnQsQyxyKTp0O3l0PT09dCYmKHl0PXJbZnRdKSxYP0VyKEMsZnQseXQpOkZuKEMsZnQseXQpfXJldHVybiBDfWZ1bmN0aW9uIHVPKHIsbyl7cmV0dXJuIHZyKHIsZm8ociksbyl9ZnVuY3Rpb24gZk8ocixvKXtyZXR1cm4gdnIocixCdShyKSxvKX1mdW5jdGlvbiBCaShyLG8pe3JldHVybiBmdW5jdGlvbihDLHope3ZhciBYPWt0KEMpP3YyOkR4LGV0PW8/bygpOnt9O3JldHVybiBYKEMscixIdCh6LDIpLGV0KX19ZnVuY3Rpb24gU24ocil7cmV0dXJuIHRlKGZ1bmN0aW9uKG8sQyl7dmFyIHo9LTEsWD1DLmxlbmd0aCxldD1YPjE/Q1tYLTFdOnQsbHQ9WD4yP0NbMl06dDtmb3IoZXQ9ci5sZW5ndGg+MyYmdHlwZW9mIGV0PT0iZnVuY3Rpb24iPyhYLS0sZXQpOnQsbHQmJlVlKENbMF0sQ1sxXSxsdCkmJihldD1YPDM/dDpldCxYPTEpLG89aGUobyk7Kyt6PFg7KXt2YXIgZnQ9Q1t6XTtmdCYmcihvLGZ0LHosZXQpfXJldHVybiBvfSl9ZnVuY3Rpb24gU3UocixvKXtyZXR1cm4gZnVuY3Rpb24oQyx6KXtpZihDPT1udWxsKXJldHVybiBDO2lmKCFLZShDKSlyZXR1cm4gcihDLHopO2Zvcih2YXIgWD1DLmxlbmd0aCxldD1vP1g6LTEsbHQ9aGUoQyk7KG8/ZXQtLTorK2V0PFgpJiZ6KGx0W2V0XSxldCxsdCkhPT0hMTspO3JldHVybiBDfX1mdW5jdGlvbiBUdShyKXtyZXR1cm4gZnVuY3Rpb24obyxDLHope2Zvcih2YXIgWD0tMSxldD1oZShvKSxsdD16KG8pLGZ0PWx0Lmxlbmd0aDtmdC0tOyl7dmFyIHl0PWx0W3I/ZnQ6KytYXTtpZihDKGV0W3l0XSx5dCxldCk9PT0hMSlicmVha31yZXR1cm4gb319ZnVuY3Rpb24gY08ocixvLEMpe3ZhciB6PW8meSxYPUduKHIpO2Z1bmN0aW9uIGV0KCl7dmFyIGx0PXRoaXMmJnRoaXMhPT1OZSYmdGhpcyBpbnN0YW5jZW9mIGV0P1g6cjtyZXR1cm4gbHQuYXBwbHkoej9DOnRoaXMsYXJndW1lbnRzKX1yZXR1cm4gZXR9ZnVuY3Rpb24gUHUocil7cmV0dXJuIGZ1bmN0aW9uKG8pe289dWUobyk7dmFyIEM9cG4obyk/dXIobyk6dCx6PUM/Q1swXTpvLmNoYXJBdCgwKSxYPUM/VXIoQywxKS5qb2luKCIiKTpvLnNsaWNlKDEpO3JldHVybiB6W3JdKCkrWH19ZnVuY3Rpb24gVG4ocil7cmV0dXJuIGZ1bmN0aW9uKG8pe3JldHVybiBDcyhUZihTZihvKS5yZXBsYWNlKGUyLCIiKSksciwiIil9fWZ1bmN0aW9uIEduKHIpe3JldHVybiBmdW5jdGlvbigpe3ZhciBvPWFyZ3VtZW50cztzd2l0Y2goby5sZW5ndGgpe2Nhc2UgMDpyZXR1cm4gbmV3IHI7Y2FzZSAxOnJldHVybiBuZXcgcihvWzBdKTtjYXNlIDI6cmV0dXJuIG5ldyByKG9bMF0sb1sxXSk7Y2FzZSAzOnJldHVybiBuZXcgcihvWzBdLG9bMV0sb1syXSk7Y2FzZSA0OnJldHVybiBuZXcgcihvWzBdLG9bMV0sb1syXSxvWzNdKTtjYXNlIDU6cmV0dXJuIG5ldyByKG9bMF0sb1sxXSxvWzJdLG9bM10sb1s0XSk7Y2FzZSA2OnJldHVybiBuZXcgcihvWzBdLG9bMV0sb1syXSxvWzNdLG9bNF0sb1s1XSk7Y2FzZSA3OnJldHVybiBuZXcgcihvWzBdLG9bMV0sb1syXSxvWzNdLG9bNF0sb1s1XSxvWzZdKX12YXIgQz1NbihyLnByb3RvdHlwZSksej1yLmFwcGx5KEMsbyk7cmV0dXJuIE1lKHopP3o6Q319ZnVuY3Rpb24gaE8ocixvLEMpe3ZhciB6PUduKHIpO2Z1bmN0aW9uIFgoKXtmb3IodmFyIGV0PWFyZ3VtZW50cy5sZW5ndGgsbHQ9UHQoZXQpLGZ0PWV0LHl0PVBuKFgpO2Z0LS07KWx0W2Z0XT1hcmd1bWVudHNbZnRdO3ZhciBSdD1ldDwzJiZsdFswXSE9PXl0JiZsdFtldC0xXSE9PXl0P1tdOk5yKGx0LHl0KTtpZihldC09UnQubGVuZ3RoLGV0PEMpcmV0dXJuIEl1KHIsbyxXaSxYLnBsYWNlaG9sZGVyLHQsbHQsUnQsdCx0LEMtZXQpO3ZhciBJdD10aGlzJiZ0aGlzIT09TmUmJnRoaXMgaW5zdGFuY2VvZiBYP3o6cjtyZXR1cm4gWGUoSXQsdGhpcyxsdCl9cmV0dXJuIFh9ZnVuY3Rpb24gYnUocil7cmV0dXJuIGZ1bmN0aW9uKG8sQyx6KXt2YXIgWD1oZShvKTtpZighS2Uobykpe3ZhciBldD1IdChDLDMpO289d2UobyksQz1mdW5jdGlvbihmdCl7cmV0dXJuIGV0KFhbZnRdLGZ0LFgpfX12YXIgbHQ9cihvLEMseik7cmV0dXJuIGx0Pi0xP1hbZXQ/b1tsdF06bHRdOnR9fWZ1bmN0aW9uIEF1KHIpe3JldHVybiBTcihmdW5jdGlvbihvKXt2YXIgQz1vLmxlbmd0aCx6PUMsWD1yci5wcm90b3R5cGUudGhydTtmb3IociYmby5yZXZlcnNlKCk7ei0tOyl7dmFyIGV0PW9bel07aWYodHlwZW9mIGV0IT0iZnVuY3Rpb24iKXRocm93IG5ldyBlcihoKTtpZihYJiYhbHQmJnppKGV0KT09IndyYXBwZXIiKXZhciBsdD1uZXcgcnIoW10sITApfWZvcih6PWx0P3o6QzsrK3o8Qzspe2V0PW9bel07dmFyIGZ0PXppKGV0KSx5dD1mdD09IndyYXBwZXIiP2xvKGV0KTp0O3l0JiZobyh5dFswXSkmJnl0WzFdPT0oUnxjfHZ8TCkmJiF5dFs0XS5sZW5ndGgmJnl0WzldPT0xP2x0PWx0W3ppKHl0WzBdKV0uYXBwbHkobHQseXRbM10pOmx0PWV0Lmxlbmd0aD09MSYmaG8oZXQpP2x0W2Z0XSgpOmx0LnRocnUoZXQpfXJldHVybiBmdW5jdGlvbigpe3ZhciBSdD1hcmd1bWVudHMsSXQ9UnRbMF07aWYobHQmJlJ0Lmxlbmd0aD09MSYma3QoSXQpKXJldHVybiBsdC5wbGFudChJdCkudmFsdWUoKTtmb3IodmFyIHd0PTAsV3Q9Qz9vW3d0XS5hcHBseSh0aGlzLFJ0KTpJdDsrK3d0PEM7KVd0PW9bd3RdLmNhbGwodGhpcyxXdCk7cmV0dXJuIFd0fX0pfWZ1bmN0aW9uIFdpKHIsbyxDLHosWCxldCxsdCxmdCx5dCxSdCl7dmFyIEl0PW8mUix3dD1vJnksV3Q9byZTLFV0PW8mKGN8bCksWHQ9byZOLF90PVd0P3Q6R24ocik7ZnVuY3Rpb24gWnQoKXtmb3IodmFyIGVlPWFyZ3VtZW50cy5sZW5ndGgsbmU9UHQoZWUpLGtlPWVlO2tlLS07KW5lW2tlXT1hcmd1bWVudHNba2VdO2lmKFV0KXZhciB6ZT1QbihadCkscWU9VDIobmUsemUpO2lmKHomJihuZT1FdShuZSx6LFgsVXQpKSxldCYmKG5lPU11KG5lLGV0LGx0LFV0KSksZWUtPXFlLFV0JiZlZTxSdCl7dmFyIENlPU5yKG5lLHplKTtyZXR1cm4gSXUocixvLFdpLFp0LnBsYWNlaG9sZGVyLEMsbmUsQ2UsZnQseXQsUnQtZWUpfXZhciBocj13dD9DOnRoaXMsQXI9V3Q/aHJbcl06cjtyZXR1cm4gZWU9bmUubGVuZ3RoLGZ0P25lPURPKG5lLGZ0KTpYdCYmZWU+MSYmbmUucmV2ZXJzZSgpLEl0JiZ5dDxlZSYmKG5lLmxlbmd0aD15dCksdGhpcyYmdGhpcyE9PU5lJiZ0aGlzIGluc3RhbmNlb2YgWnQmJihBcj1fdHx8R24oQXIpKSxBci5hcHBseShocixuZSl9cmV0dXJuIFp0fWZ1bmN0aW9uIEN1KHIsbyl7cmV0dXJuIGZ1bmN0aW9uKEMseil7cmV0dXJuIHp4KEMscixvKHopLHt9KX19ZnVuY3Rpb24gRmkocixvKXtyZXR1cm4gZnVuY3Rpb24oQyx6KXt2YXIgWDtpZihDPT09dCYmej09PXQpcmV0dXJuIG87aWYoQyE9PXQmJihYPUMpLHohPT10KXtpZihYPT09dClyZXR1cm4gejt0eXBlb2YgQz09InN0cmluZyJ8fHR5cGVvZiB6PT0ic3RyaW5nIj8oQz1KZShDKSx6PUplKHopKTooQz1kdShDKSx6PWR1KHopKSxYPXIoQyx6KX1yZXR1cm4gWH19ZnVuY3Rpb24gaW8ocil7cmV0dXJuIFNyKGZ1bmN0aW9uKG8pe3JldHVybiBvPXllKG8sWmUoSHQoKSkpLHRlKGZ1bmN0aW9uKEMpe3ZhciB6PXRoaXM7cmV0dXJuIHIobyxmdW5jdGlvbihYKXtyZXR1cm4gWGUoWCx6LEMpfSl9KX0pfWZ1bmN0aW9uIGppKHIsbyl7bz1vPT09dD8iICI6SmUobyk7dmFyIEM9by5sZW5ndGg7aWYoQzwyKXJldHVybiBDP2tzKG8scik6bzt2YXIgej1rcyhvLFRpKHIvbW4obykpKTtyZXR1cm4gcG4obyk/VXIodXIoeiksMCxyKS5qb2luKCIiKTp6LnNsaWNlKDAscil9ZnVuY3Rpb24gZE8ocixvLEMseil7dmFyIFg9byZ5LGV0PUduKHIpO2Z1bmN0aW9uIGx0KCl7Zm9yKHZhciBmdD0tMSx5dD1hcmd1bWVudHMubGVuZ3RoLFJ0PS0xLEl0PXoubGVuZ3RoLHd0PVB0KEl0K3l0KSxXdD10aGlzJiZ0aGlzIT09TmUmJnRoaXMgaW5zdGFuY2VvZiBsdD9ldDpyOysrUnQ8SXQ7KXd0W1J0XT16W1J0XTtmb3IoO3l0LS07KXd0W1J0KytdPWFyZ3VtZW50c1srK2Z0XTtyZXR1cm4gWGUoV3QsWD9DOnRoaXMsd3QpfXJldHVybiBsdH1mdW5jdGlvbiBSdShyKXtyZXR1cm4gZnVuY3Rpb24obyxDLHope3JldHVybiB6JiZ0eXBlb2YgeiE9Im51bWJlciImJlVlKG8sQyx6KSYmKEM9ej10KSxvPWJyKG8pLEM9PT10PyhDPW8sbz0wKTpDPWJyKEMpLHo9ej09PXQ/bzxDPzE6LTE6YnIoeikscXgobyxDLHoscil9fWZ1bmN0aW9uIFVpKHIpe3JldHVybiBmdW5jdGlvbihvLEMpe3JldHVybiB0eXBlb2Ygbz09InN0cmluZyImJnR5cGVvZiBDPT0ic3RyaW5nInx8KG89b3IobyksQz1vcihDKSkscihvLEMpfX1mdW5jdGlvbiBJdShyLG8sQyx6LFgsZXQsbHQsZnQseXQsUnQpe3ZhciBJdD1vJmMsd3Q9SXQ/bHQ6dCxXdD1JdD90Omx0LFV0PUl0P2V0OnQsWHQ9SXQ/dDpldDtvfD1JdD92OlQsbyY9fihJdD9UOnYpLG8mc3x8KG8mPX4oeXxTKSk7dmFyIF90PVtyLG8sWCxVdCx3dCxYdCxXdCxmdCx5dCxSdF0sWnQ9Qy5hcHBseSh0LF90KTtyZXR1cm4gaG8ocikmJkd1KFp0LF90KSxadC5wbGFjZWhvbGRlcj16LEt1KFp0LHIsbyl9ZnVuY3Rpb24gc28ocil7dmFyIG89TGVbcl07cmV0dXJuIGZ1bmN0aW9uKEMseil7aWYoQz1vcihDKSx6PXo9PW51bGw/MDpXZShxdCh6KSwyOTIpLHomJktsKEMpKXt2YXIgWD0odWUoQykrImUiKS5zcGxpdCgiZSIpLGV0PW8oWFswXSsiZSIrKCtYWzFdK3opKTtyZXR1cm4gWD0odWUoZXQpKyJlIikuc3BsaXQoImUiKSwrKFhbMF0rImUiKygrWFsxXS16KSl9cmV0dXJuIG8oQyl9fXZhciBnTz1PbiYmMS9naShuZXcgT24oWywtMF0pKVsxXT09Sj9mdW5jdGlvbihyKXtyZXR1cm4gbmV3IE9uKHIpfTpDbztmdW5jdGlvbiBMdShyKXtyZXR1cm4gZnVuY3Rpb24obyl7dmFyIEM9RmUobyk7cmV0dXJuIEM9PUg/QnMobyk6Qz09bnQ/TDIobyk6UzIobyxyKG8pKX19ZnVuY3Rpb24gTXIocixvLEMseixYLGV0LGx0LGZ0KXt2YXIgeXQ9byZTO2lmKCF5dCYmdHlwZW9mIHIhPSJmdW5jdGlvbiIpdGhyb3cgbmV3IGVyKGgpO3ZhciBSdD16P3oubGVuZ3RoOjA7aWYoUnR8fChvJj1+KHZ8VCksej1YPXQpLGx0PWx0PT09dD9sdDpEZShxdChsdCksMCksZnQ9ZnQ9PT10P2Z0OnF0KGZ0KSxSdC09WD9YLmxlbmd0aDowLG8mVCl7dmFyIEl0PXosd3Q9WDt6PVg9dH12YXIgV3Q9eXQ/dDpsbyhyKSxVdD1bcixvLEMseixYLEl0LHd0LGV0LGx0LGZ0XTtpZihXdCYmUk8oVXQsV3QpLHI9VXRbMF0sbz1VdFsxXSxDPVV0WzJdLHo9VXRbM10sWD1VdFs0XSxmdD1VdFs5XT1VdFs5XT09PXQ/eXQ/MDpyLmxlbmd0aDpEZShVdFs5XS1SdCwwKSwhZnQmJm8mKGN8bCkmJihvJj1+KGN8bCkpLCFvfHxvPT15KXZhciBYdD1jTyhyLG8sQyk7ZWxzZSBvPT1jfHxvPT1sP1h0PWhPKHIsbyxmdCk6KG89PXZ8fG89PSh5fHYpKSYmIVgubGVuZ3RoP1h0PWRPKHIsbyxDLHopOlh0PVdpLmFwcGx5KHQsVXQpO3ZhciBfdD1XdD9jdTpHdTtyZXR1cm4gS3UoX3QoWHQsVXQpLHIsbyl9ZnVuY3Rpb24gRHUocixvLEMseil7cmV0dXJuIHI9PT10fHxjcihyLHhuW0NdKSYmIWZlLmNhbGwoeixDKT9vOnJ9ZnVuY3Rpb24gd3UocixvLEMseixYLGV0KXtyZXR1cm4gTWUocikmJk1lKG8pJiYoZXQuc2V0KG8sciksRGkocixvLHQsd3UsZXQpLGV0LmRlbGV0ZShvKSkscn1mdW5jdGlvbiB2TyhyKXtyZXR1cm4gWW4ocik/dDpyfWZ1bmN0aW9uIE51KHIsbyxDLHosWCxldCl7dmFyIGx0PUMmYixmdD1yLmxlbmd0aCx5dD1vLmxlbmd0aDtpZihmdCE9eXQmJiEobHQmJnl0PmZ0KSlyZXR1cm4hMTt2YXIgUnQ9ZXQuZ2V0KHIpLEl0PWV0LmdldChvKTtpZihSdCYmSXQpcmV0dXJuIFJ0PT1vJiZJdD09cjt2YXIgd3Q9LTEsV3Q9ITAsVXQ9QyZNP25ldyBKcjp0O2ZvcihldC5zZXQocixvKSxldC5zZXQobyxyKTsrK3d0PGZ0Oyl7dmFyIFh0PXJbd3RdLF90PW9bd3RdO2lmKHopdmFyIFp0PWx0P3ooX3QsWHQsd3QsbyxyLGV0KTp6KFh0LF90LHd0LHIsbyxldCk7aWYoWnQhPT10KXtpZihadCljb250aW51ZTtXdD0hMTticmVha31pZihVdCl7aWYoIVJzKG8sZnVuY3Rpb24oZWUsbmUpe2lmKCFMbihVdCxuZSkmJihYdD09PWVlfHxYKFh0LGVlLEMseixldCkpKXJldHVybiBVdC5wdXNoKG5lKX0pKXtXdD0hMTticmVha319ZWxzZSBpZighKFh0PT09X3R8fFgoWHQsX3QsQyx6LGV0KSkpe1d0PSExO2JyZWFrfX1yZXR1cm4gZXQuZGVsZXRlKHIpLGV0LmRlbGV0ZShvKSxXdH1mdW5jdGlvbiBwTyhyLG8sQyx6LFgsZXQsbHQpe3N3aXRjaChDKXtjYXNlIG10OmlmKHIuYnl0ZUxlbmd0aCE9by5ieXRlTGVuZ3RofHxyLmJ5dGVPZmZzZXQhPW8uYnl0ZU9mZnNldClyZXR1cm4hMTtyPXIuYnVmZmVyLG89by5idWZmZXI7Y2FzZSBkdDpyZXR1cm4hKHIuYnl0ZUxlbmd0aCE9by5ieXRlTGVuZ3RofHwhZXQobmV3IE9pKHIpLG5ldyBPaShvKSkpO2Nhc2UgT3Q6Y2FzZSBVOmNhc2UgeDpyZXR1cm4gY3IoK3IsK28pO2Nhc2UgUTpyZXR1cm4gci5uYW1lPT1vLm5hbWUmJnIubWVzc2FnZT09by5tZXNzYWdlO2Nhc2UgazpjYXNlIHV0OnJldHVybiByPT1vKyIiO2Nhc2UgSDp2YXIgZnQ9QnM7Y2FzZSBudDp2YXIgeXQ9eiZiO2lmKGZ0fHwoZnQ9Z2kpLHIuc2l6ZSE9by5zaXplJiYheXQpcmV0dXJuITE7dmFyIFJ0PWx0LmdldChyKTtpZihSdClyZXR1cm4gUnQ9PW87enw9TSxsdC5zZXQocixvKTt2YXIgSXQ9TnUoZnQociksZnQobykseixYLGV0LGx0KTtyZXR1cm4gbHQuZGVsZXRlKHIpLEl0O2Nhc2UgY3Q6aWYoV24pcmV0dXJuIFduLmNhbGwocik9PVduLmNhbGwobyl9cmV0dXJuITF9ZnVuY3Rpb24gbU8ocixvLEMseixYLGV0KXt2YXIgbHQ9QyZiLGZ0PW9vKHIpLHl0PWZ0Lmxlbmd0aCxSdD1vbyhvKSxJdD1SdC5sZW5ndGg7aWYoeXQhPUl0JiYhbHQpcmV0dXJuITE7Zm9yKHZhciB3dD15dDt3dC0tOyl7dmFyIFd0PWZ0W3d0XTtpZighKGx0P1d0IGluIG86ZmUuY2FsbChvLFd0KSkpcmV0dXJuITF9dmFyIFV0PWV0LmdldChyKSxYdD1ldC5nZXQobyk7aWYoVXQmJlh0KXJldHVybiBVdD09byYmWHQ9PXI7dmFyIF90PSEwO2V0LnNldChyLG8pLGV0LnNldChvLHIpO2Zvcih2YXIgWnQ9bHQ7Kyt3dDx5dDspe1d0PWZ0W3d0XTt2YXIgZWU9cltXdF0sbmU9b1tXdF07aWYoeil2YXIga2U9bHQ/eihuZSxlZSxXdCxvLHIsZXQpOnooZWUsbmUsV3QscixvLGV0KTtpZighKGtlPT09dD9lZT09PW5lfHxYKGVlLG5lLEMseixldCk6a2UpKXtfdD0hMTticmVha31adHx8KFp0PVd0PT0iY29uc3RydWN0b3IiKX1pZihfdCYmIVp0KXt2YXIgemU9ci5jb25zdHJ1Y3RvcixxZT1vLmNvbnN0cnVjdG9yO3plIT1xZSYmImNvbnN0cnVjdG9yImluIHImJiJjb25zdHJ1Y3RvciJpbiBvJiYhKHR5cGVvZiB6ZT09ImZ1bmN0aW9uIiYmemUgaW5zdGFuY2VvZiB6ZSYmdHlwZW9mIHFlPT0iZnVuY3Rpb24iJiZxZSBpbnN0YW5jZW9mIHFlKSYmKF90PSExKX1yZXR1cm4gZXQuZGVsZXRlKHIpLGV0LmRlbGV0ZShvKSxfdH1mdW5jdGlvbiBTcihyKXtyZXR1cm4gdm8oenUocix0LEp1KSxyKyIiKX1mdW5jdGlvbiBvbyhyKXtyZXR1cm4gdHUocix3ZSxmbyl9ZnVuY3Rpb24gYW8ocil7cmV0dXJuIHR1KHIsSGUsQnUpfXZhciBsbz1iaT9mdW5jdGlvbihyKXtyZXR1cm4gYmkuZ2V0KHIpfTpDbztmdW5jdGlvbiB6aShyKXtmb3IodmFyIG89ci5uYW1lKyIiLEM9RW5bb10sej1mZS5jYWxsKEVuLG8pP0MubGVuZ3RoOjA7ei0tOyl7dmFyIFg9Q1t6XSxldD1YLmZ1bmM7aWYoZXQ9PW51bGx8fGV0PT1yKXJldHVybiBYLm5hbWV9cmV0dXJuIG99ZnVuY3Rpb24gUG4ocil7dmFyIG89ZmUuY2FsbChxLCJwbGFjZWhvbGRlciIpP3E6cjtyZXR1cm4gby5wbGFjZWhvbGRlcn1mdW5jdGlvbiBIdCgpe3ZhciByPXEuaXRlcmF0ZWV8fGJvO3JldHVybiByPXI9PT1ibz9udTpyLGFyZ3VtZW50cy5sZW5ndGg/cihhcmd1bWVudHNbMF0sYXJndW1lbnRzWzFdKTpyfWZ1bmN0aW9uICRpKHIsbyl7dmFyIEM9ci5fX2RhdGFfXztyZXR1cm4gUE8obyk/Q1t0eXBlb2Ygbz09InN0cmluZyI/InN0cmluZyI6Imhhc2giXTpDLm1hcH1mdW5jdGlvbiB1byhyKXtmb3IodmFyIG89d2UociksQz1vLmxlbmd0aDtDLS07KXt2YXIgej1vW0NdLFg9clt6XTtvW0NdPVt6LFgsanUoWCldfXJldHVybiBvfWZ1bmN0aW9uIHFyKHIsbyl7dmFyIEM9QzIocixvKTtyZXR1cm4gcnUoQyk/Qzp0fWZ1bmN0aW9uIHlPKHIpe3ZhciBvPWZlLmNhbGwocixYciksQz1yW1hyXTt0cnl7cltYcl09dDt2YXIgej0hMH1jYXRjaHt9dmFyIFg9eWkuY2FsbChyKTtyZXR1cm4geiYmKG8/cltYcl09QzpkZWxldGUgcltYcl0pLFh9dmFyIGZvPUZzP2Z1bmN0aW9uKHIpe3JldHVybiByPT1udWxsP1tdOihyPWhlKHIpLERyKEZzKHIpLGZ1bmN0aW9uKG8pe3JldHVybiAkbC5jYWxsKHIsbyl9KSl9OlJvLEJ1PUZzP2Z1bmN0aW9uKHIpe2Zvcih2YXIgbz1bXTtyOyl3cihvLGZvKHIpKSxyPUVpKHIpO3JldHVybiBvfTpSbyxGZT1qZTsoanMmJkZlKG5ldyBqcyhuZXcgQXJyYXlCdWZmZXIoMSkpKSE9bXR8fHduJiZGZShuZXcgd24pIT1IfHxVcyYmRmUoVXMucmVzb2x2ZSgpKSE9S3x8T24mJkZlKG5ldyBPbikhPW50fHxObiYmRmUobmV3IE5uKSE9eHQpJiYoRmU9ZnVuY3Rpb24ocil7dmFyIG89amUociksQz1vPT1XP3IuY29uc3RydWN0b3I6dCx6PUM/X3IoQyk6IiI7aWYoeilzd2l0Y2goeil7Y2FzZSB0eDpyZXR1cm4gbXQ7Y2FzZSBleDpyZXR1cm4gSDtjYXNlIHJ4OnJldHVybiBLO2Nhc2Ugbng6cmV0dXJuIG50O2Nhc2UgaXg6cmV0dXJuIHh0fXJldHVybiBvfSk7ZnVuY3Rpb24geE8ocixvLEMpe2Zvcih2YXIgej0tMSxYPUMubGVuZ3RoOysrejxYOyl7dmFyIGV0PUNbel0sbHQ9ZXQuc2l6ZTtzd2l0Y2goZXQudHlwZSl7Y2FzZSJkcm9wIjpyKz1sdDticmVhaztjYXNlImRyb3BSaWdodCI6by09bHQ7YnJlYWs7Y2FzZSJ0YWtlIjpvPVdlKG8scitsdCk7YnJlYWs7Y2FzZSJ0YWtlUmlnaHQiOnI9RGUocixvLWx0KTticmVha319cmV0dXJue3N0YXJ0OnIsZW5kOm99fWZ1bmN0aW9uIE9PKHIpe3ZhciBvPXIubWF0Y2goYnkpO3JldHVybiBvP29bMV0uc3BsaXQoQXkpOltdfWZ1bmN0aW9uIFd1KHIsbyxDKXtvPWpyKG8scik7Zm9yKHZhciB6PS0xLFg9by5sZW5ndGgsZXQ9ITE7Kyt6PFg7KXt2YXIgbHQ9cHIob1t6XSk7aWYoIShldD1yIT1udWxsJiZDKHIsbHQpKSlicmVhaztyPXJbbHRdfXJldHVybiBldHx8Kyt6IT1YP2V0OihYPXI9PW51bGw/MDpyLmxlbmd0aCwhIVgmJlppKFgpJiZUcihsdCxYKSYmKGt0KHIpfHx0bihyKSkpfWZ1bmN0aW9uIEVPKHIpe3ZhciBvPXIubGVuZ3RoLEM9bmV3IHIuY29uc3RydWN0b3Iobyk7cmV0dXJuIG8mJnR5cGVvZiByWzBdPT0ic3RyaW5nIiYmZmUuY2FsbChyLCJpbmRleCIpJiYoQy5pbmRleD1yLmluZGV4LEMuaW5wdXQ9ci5pbnB1dCksQ31mdW5jdGlvbiBGdShyKXtyZXR1cm4gdHlwZW9mIHIuY29uc3RydWN0b3I9PSJmdW5jdGlvbiImJiFLbihyKT9NbihFaShyKSk6e319ZnVuY3Rpb24gTU8ocixvLEMpe3ZhciB6PXIuY29uc3RydWN0b3I7c3dpdGNoKG8pe2Nhc2UgZHQ6cmV0dXJuIG5vKHIpO2Nhc2UgT3Q6Y2FzZSBVOnJldHVybiBuZXcgeigrcik7Y2FzZSBtdDpyZXR1cm4gc08ocixDKTtjYXNlIGJ0OmNhc2UgQ3Q6Y2FzZSBTdDpjYXNlIE50OmNhc2UgSnQ6Y2FzZSBHdDpjYXNlIEt0OmNhc2UgWXQ6Y2FzZSBWdDpyZXR1cm4geHUocixDKTtjYXNlIEg6cmV0dXJuIG5ldyB6O2Nhc2UgeDpjYXNlIHV0OnJldHVybiBuZXcgeihyKTtjYXNlIGs6cmV0dXJuIG9PKHIpO2Nhc2UgbnQ6cmV0dXJuIG5ldyB6O2Nhc2UgY3Q6cmV0dXJuIGFPKHIpfX1mdW5jdGlvbiBTTyhyLG8pe3ZhciBDPW8ubGVuZ3RoO2lmKCFDKXJldHVybiByO3ZhciB6PUMtMTtyZXR1cm4gb1t6XT0oQz4xPyImICI6IiIpK29bel0sbz1vLmpvaW4oQz4yPyIsICI6IiAiKSxyLnJlcGxhY2UoUHksYHsKLyogW3dyYXBwZWQgd2l0aCBgK28rYF0gKi8KYCl9ZnVuY3Rpb24gVE8ocil7cmV0dXJuIGt0KHIpfHx0bihyKXx8ISEoR2wmJnImJnJbR2xdKX1mdW5jdGlvbiBUcihyLG8pe3ZhciBDPXR5cGVvZiByO3JldHVybiBvPW8/P18sISFvJiYoQz09Im51bWJlciJ8fEMhPSJzeW1ib2wiJiZXeS50ZXN0KHIpKSYmcj4tMSYmciUxPT0wJiZyPG99ZnVuY3Rpb24gVWUocixvLEMpe2lmKCFNZShDKSlyZXR1cm4hMTt2YXIgej10eXBlb2YgbztyZXR1cm4oej09Im51bWJlciI/S2UoQykmJlRyKG8sQy5sZW5ndGgpOno9PSJzdHJpbmciJiZvIGluIEMpP2NyKENbb10scik6ITF9ZnVuY3Rpb24gY28ocixvKXtpZihrdChyKSlyZXR1cm4hMTt2YXIgQz10eXBlb2YgcjtyZXR1cm4gQz09Im51bWJlciJ8fEM9PSJzeW1ib2wifHxDPT0iYm9vbGVhbiJ8fHI9PW51bGx8fFFlKHIpPyEwOmFpLnRlc3Qocil8fCFZci50ZXN0KHIpfHxvIT1udWxsJiZyIGluIGhlKG8pfWZ1bmN0aW9uIFBPKHIpe3ZhciBvPXR5cGVvZiByO3JldHVybiBvPT0ic3RyaW5nInx8bz09Im51bWJlciJ8fG89PSJzeW1ib2wifHxvPT0iYm9vbGVhbiI/ciE9PSJfX3Byb3RvX18iOnI9PT1udWxsfWZ1bmN0aW9uIGhvKHIpe3ZhciBvPXppKHIpLEM9cVtvXTtpZih0eXBlb2YgQyE9ImZ1bmN0aW9uInx8IShvIGluIHJlLnByb3RvdHlwZSkpcmV0dXJuITE7aWYocj09PUMpcmV0dXJuITA7dmFyIHo9bG8oQyk7cmV0dXJuISF6JiZyPT09elswXX1mdW5jdGlvbiBiTyhyKXtyZXR1cm4hIWpsJiZqbCBpbiByfXZhciBBTz1waT9QcjpJbztmdW5jdGlvbiBLbihyKXt2YXIgbz1yJiZyLmNvbnN0cnVjdG9yLEM9dHlwZW9mIG89PSJmdW5jdGlvbiImJm8ucHJvdG90eXBlfHx4bjtyZXR1cm4gcj09PUN9ZnVuY3Rpb24ganUocil7cmV0dXJuIHI9PT1yJiYhTWUocil9ZnVuY3Rpb24gVXUocixvKXtyZXR1cm4gZnVuY3Rpb24oQyl7cmV0dXJuIEM9PW51bGw/ITE6Q1tyXT09PW8mJihvIT09dHx8ciBpbiBoZShDKSl9fWZ1bmN0aW9uIENPKHIpe3ZhciBvPVZpKHIsZnVuY3Rpb24oeil7cmV0dXJuIEMuc2l6ZT09PWQmJkMuY2xlYXIoKSx6fSksQz1vLmNhY2hlO3JldHVybiBvfWZ1bmN0aW9uIFJPKHIsbyl7dmFyIEM9clsxXSx6PW9bMV0sWD1DfHosZXQ9WDwoeXxTfFIpLGx0PXo9PVImJkM9PWN8fHo9PVImJkM9PUwmJnJbN10ubGVuZ3RoPD1vWzhdfHx6PT0oUnxMKSYmb1s3XS5sZW5ndGg8PW9bOF0mJkM9PWM7aWYoIShldHx8bHQpKXJldHVybiByO3omeSYmKHJbMl09b1syXSxYfD1DJnk/MDpzKTt2YXIgZnQ9b1szXTtpZihmdCl7dmFyIHl0PXJbM107clszXT15dD9FdSh5dCxmdCxvWzRdKTpmdCxyWzRdPXl0P05yKHJbM10sRSk6b1s0XX1yZXR1cm4gZnQ9b1s1XSxmdCYmKHl0PXJbNV0scls1XT15dD9NdSh5dCxmdCxvWzZdKTpmdCxyWzZdPXl0P05yKHJbNV0sRSk6b1s2XSksZnQ9b1s3XSxmdCYmKHJbN109ZnQpLHomUiYmKHJbOF09cls4XT09bnVsbD9vWzhdOldlKHJbOF0sb1s4XSkpLHJbOV09PW51bGwmJihyWzldPW9bOV0pLHJbMF09b1swXSxyWzFdPVgscn1mdW5jdGlvbiBJTyhyKXt2YXIgbz1bXTtpZihyIT1udWxsKWZvcih2YXIgQyBpbiBoZShyKSlvLnB1c2goQyk7cmV0dXJuIG99ZnVuY3Rpb24gTE8ocil7cmV0dXJuIHlpLmNhbGwocil9ZnVuY3Rpb24genUocixvLEMpe3JldHVybiBvPURlKG89PT10P3IubGVuZ3RoLTE6bywwKSxmdW5jdGlvbigpe2Zvcih2YXIgej1hcmd1bWVudHMsWD0tMSxldD1EZSh6Lmxlbmd0aC1vLDApLGx0PVB0KGV0KTsrK1g8ZXQ7KWx0W1hdPXpbbytYXTtYPS0xO2Zvcih2YXIgZnQ9UHQobysxKTsrK1g8bzspZnRbWF09eltYXTtyZXR1cm4gZnRbb109QyhsdCksWGUocix0aGlzLGZ0KX19ZnVuY3Rpb24gJHUocixvKXtyZXR1cm4gby5sZW5ndGg8Mj9yOmtyKHIsaXIobywwLC0xKSl9ZnVuY3Rpb24gRE8ocixvKXtmb3IodmFyIEM9ci5sZW5ndGgsej1XZShvLmxlbmd0aCxDKSxYPUdlKHIpO3otLTspe3ZhciBldD1vW3pdO3Jbel09VHIoZXQsQyk/WFtldF06dH1yZXR1cm4gcn1mdW5jdGlvbiBnbyhyLG8pe2lmKCEobz09PSJjb25zdHJ1Y3RvciImJnR5cGVvZiByW29dPT0iZnVuY3Rpb24iKSYmbyE9Il9fcHJvdG9fXyIpcmV0dXJuIHJbb119dmFyIEd1PUh1KGN1KSxIbj1YMnx8ZnVuY3Rpb24ocixvKXtyZXR1cm4gTmUuc2V0VGltZW91dChyLG8pfSx2bz1IdShlTyk7ZnVuY3Rpb24gS3UocixvLEMpe3ZhciB6PW8rIiI7cmV0dXJuIHZvKHIsU08oeix3TyhPTyh6KSxDKSkpfWZ1bmN0aW9uIEh1KHIpe3ZhciBvPTAsQz0wO3JldHVybiBmdW5jdGlvbigpe3ZhciB6PWsyKCksWD1ELSh6LUMpO2lmKEM9eixYPjApe2lmKCsrbz49QilyZXR1cm4gYXJndW1lbnRzWzBdfWVsc2Ugbz0wO3JldHVybiByLmFwcGx5KHQsYXJndW1lbnRzKX19ZnVuY3Rpb24gR2kocixvKXt2YXIgQz0tMSx6PXIubGVuZ3RoLFg9ei0xO2ZvcihvPW89PT10P3o6bzsrK0M8bzspe3ZhciBldD1RcyhDLFgpLGx0PXJbZXRdO3JbZXRdPXJbQ10scltDXT1sdH1yZXR1cm4gci5sZW5ndGg9byxyfXZhciBZdT1DTyhmdW5jdGlvbihyKXt2YXIgbz1bXTtyZXR1cm4gci5jaGFyQ29kZUF0KDApPT09NDYmJm8ucHVzaCgiIiksci5yZXBsYWNlKGxpLGZ1bmN0aW9uKEMseixYLGV0KXtvLnB1c2goWD9ldC5yZXBsYWNlKEl5LCIkMSIpOnp8fEMpfSksb30pO2Z1bmN0aW9uIHByKHIpe2lmKHR5cGVvZiByPT0ic3RyaW5nInx8UWUocikpcmV0dXJuIHI7dmFyIG89cisiIjtyZXR1cm4gbz09IjAiJiYxL3I9PS1KPyItMCI6b31mdW5jdGlvbiBfcihyKXtpZihyIT1udWxsKXt0cnl7cmV0dXJuIG1pLmNhbGwocil9Y2F0Y2h7fXRyeXtyZXR1cm4gcisiIn1jYXRjaHt9fXJldHVybiIifWZ1bmN0aW9uIHdPKHIsbyl7cmV0dXJuIHRyKGF0LGZ1bmN0aW9uKEMpe3ZhciB6PSJfLiIrQ1swXTtvJkNbMV0mJiFoaShyLHopJiZyLnB1c2goeil9KSxyLnNvcnQoKX1mdW5jdGlvbiBWdShyKXtpZihyIGluc3RhbmNlb2YgcmUpcmV0dXJuIHIuY2xvbmUoKTt2YXIgbz1uZXcgcnIoci5fX3dyYXBwZWRfXyxyLl9fY2hhaW5fXyk7cmV0dXJuIG8uX19hY3Rpb25zX189R2Uoci5fX2FjdGlvbnNfXyksby5fX2luZGV4X189ci5fX2luZGV4X18sby5fX3ZhbHVlc19fPXIuX192YWx1ZXNfXyxvfWZ1bmN0aW9uIE5PKHIsbyxDKXsoQz9VZShyLG8sQyk6bz09PXQpP289MTpvPURlKHF0KG8pLDApO3ZhciB6PXI9PW51bGw/MDpyLmxlbmd0aDtpZighenx8bzwxKXJldHVybltdO2Zvcih2YXIgWD0wLGV0PTAsbHQ9UHQoVGkoei9vKSk7WDx6OylsdFtldCsrXT1pcihyLFgsWCs9byk7cmV0dXJuIGx0fWZ1bmN0aW9uIEJPKHIpe2Zvcih2YXIgbz0tMSxDPXI9PW51bGw/MDpyLmxlbmd0aCx6PTAsWD1bXTsrK288Qzspe3ZhciBldD1yW29dO2V0JiYoWFt6KytdPWV0KX1yZXR1cm4gWH1mdW5jdGlvbiBXTygpe3ZhciByPWFyZ3VtZW50cy5sZW5ndGg7aWYoIXIpcmV0dXJuW107Zm9yKHZhciBvPVB0KHItMSksQz1hcmd1bWVudHNbMF0sej1yO3otLTspb1t6LTFdPWFyZ3VtZW50c1t6XTtyZXR1cm4gd3Ioa3QoQyk/R2UoQyk6W0NdLEJlKG8sMSkpfXZhciBGTz10ZShmdW5jdGlvbihyLG8pe3JldHVybiBBZShyKT9qbihyLEJlKG8sMSxBZSwhMCkpOltdfSksak89dGUoZnVuY3Rpb24ocixvKXt2YXIgQz1zcihvKTtyZXR1cm4gQWUoQykmJihDPXQpLEFlKHIpP2puKHIsQmUobywxLEFlLCEwKSxIdChDLDIpKTpbXX0pLFVPPXRlKGZ1bmN0aW9uKHIsbyl7dmFyIEM9c3Iobyk7cmV0dXJuIEFlKEMpJiYoQz10KSxBZShyKT9qbihyLEJlKG8sMSxBZSwhMCksdCxDKTpbXX0pO2Z1bmN0aW9uIHpPKHIsbyxDKXt2YXIgej1yPT1udWxsPzA6ci5sZW5ndGg7cmV0dXJuIHo/KG89Q3x8bz09PXQ/MTpxdChvKSxpcihyLG88MD8wOm8seikpOltdfWZ1bmN0aW9uICRPKHIsbyxDKXt2YXIgej1yPT1udWxsPzA6ci5sZW5ndGg7cmV0dXJuIHo/KG89Q3x8bz09PXQ/MTpxdChvKSxvPXotbyxpcihyLDAsbzwwPzA6bykpOltdfWZ1bmN0aW9uIEdPKHIsbyl7cmV0dXJuIHImJnIubGVuZ3RoP05pKHIsSHQobywzKSwhMCwhMCk6W119ZnVuY3Rpb24gS08ocixvKXtyZXR1cm4gciYmci5sZW5ndGg/TmkocixIdChvLDMpLCEwKTpbXX1mdW5jdGlvbiBITyhyLG8sQyx6KXt2YXIgWD1yPT1udWxsPzA6ci5sZW5ndGg7cmV0dXJuIFg/KEMmJnR5cGVvZiBDIT0ibnVtYmVyIiYmVWUocixvLEMpJiYoQz0wLHo9WCksV3gocixvLEMseikpOltdfWZ1bmN0aW9uIFh1KHIsbyxDKXt2YXIgej1yPT1udWxsPzA6ci5sZW5ndGg7aWYoIXopcmV0dXJuLTE7dmFyIFg9Qz09bnVsbD8wOnF0KEMpO3JldHVybiBYPDAmJihYPURlKHorWCwwKSksZGkocixIdChvLDMpLFgpfWZ1bmN0aW9uIFp1KHIsbyxDKXt2YXIgej1yPT1udWxsPzA6ci5sZW5ndGg7aWYoIXopcmV0dXJuLTE7dmFyIFg9ei0xO3JldHVybiBDIT09dCYmKFg9cXQoQyksWD1DPDA/RGUoeitYLDApOldlKFgsei0xKSksZGkocixIdChvLDMpLFgsITApfWZ1bmN0aW9uIEp1KHIpe3ZhciBvPXI9PW51bGw/MDpyLmxlbmd0aDtyZXR1cm4gbz9CZShyLDEpOltdfWZ1bmN0aW9uIFlPKHIpe3ZhciBvPXI9PW51bGw/MDpyLmxlbmd0aDtyZXR1cm4gbz9CZShyLEopOltdfWZ1bmN0aW9uIFZPKHIsbyl7dmFyIEM9cj09bnVsbD8wOnIubGVuZ3RoO3JldHVybiBDPyhvPW89PT10PzE6cXQobyksQmUocixvKSk6W119ZnVuY3Rpb24gWE8ocil7Zm9yKHZhciBvPS0xLEM9cj09bnVsbD8wOnIubGVuZ3RoLHo9e307KytvPEM7KXt2YXIgWD1yW29dO3pbWFswXV09WFsxXX1yZXR1cm4gen1mdW5jdGlvbiBRdShyKXtyZXR1cm4gciYmci5sZW5ndGg/clswXTp0fWZ1bmN0aW9uIFpPKHIsbyxDKXt2YXIgej1yPT1udWxsPzA6ci5sZW5ndGg7aWYoIXopcmV0dXJuLTE7dmFyIFg9Qz09bnVsbD8wOnF0KEMpO3JldHVybiBYPDAmJihYPURlKHorWCwwKSksdm4ocixvLFgpfWZ1bmN0aW9uIEpPKHIpe3ZhciBvPXI9PW51bGw/MDpyLmxlbmd0aDtyZXR1cm4gbz9pcihyLDAsLTEpOltdfXZhciBRTz10ZShmdW5jdGlvbihyKXt2YXIgbz15ZShyLGVvKTtyZXR1cm4gby5sZW5ndGgmJm9bMF09PT1yWzBdP1lzKG8pOltdfSksa089dGUoZnVuY3Rpb24ocil7dmFyIG89c3IociksQz15ZShyLGVvKTtyZXR1cm4gbz09PXNyKEMpP289dDpDLnBvcCgpLEMubGVuZ3RoJiZDWzBdPT09clswXT9ZcyhDLEh0KG8sMikpOltdfSkscU89dGUoZnVuY3Rpb24ocil7dmFyIG89c3IociksQz15ZShyLGVvKTtyZXR1cm4gbz10eXBlb2Ygbz09ImZ1bmN0aW9uIj9vOnQsbyYmQy5wb3AoKSxDLmxlbmd0aCYmQ1swXT09PXJbMF0/WXMoQyx0LG8pOltdfSk7ZnVuY3Rpb24gX08ocixvKXtyZXR1cm4gcj09bnVsbD8iIjpKMi5jYWxsKHIsbyl9ZnVuY3Rpb24gc3Iocil7dmFyIG89cj09bnVsbD8wOnIubGVuZ3RoO3JldHVybiBvP3Jbby0xXTp0fWZ1bmN0aW9uIHRFKHIsbyxDKXt2YXIgej1yPT1udWxsPzA6ci5sZW5ndGg7aWYoIXopcmV0dXJuLTE7dmFyIFg9ejtyZXR1cm4gQyE9PXQmJihYPXF0KEMpLFg9WDwwP0RlKHorWCwwKTpXZShYLHotMSkpLG89PT1vP3cyKHIsbyxYKTpkaShyLElsLFgsITApfWZ1bmN0aW9uIGVFKHIsbyl7cmV0dXJuIHImJnIubGVuZ3RoP2F1KHIscXQobykpOnR9dmFyIHJFPXRlKGt1KTtmdW5jdGlvbiBrdShyLG8pe3JldHVybiByJiZyLmxlbmd0aCYmbyYmby5sZW5ndGg/SnMocixvKTpyfWZ1bmN0aW9uIG5FKHIsbyxDKXtyZXR1cm4gciYmci5sZW5ndGgmJm8mJm8ubGVuZ3RoP0pzKHIsbyxIdChDLDIpKTpyfWZ1bmN0aW9uIGlFKHIsbyxDKXtyZXR1cm4gciYmci5sZW5ndGgmJm8mJm8ubGVuZ3RoP0pzKHIsbyx0LEMpOnJ9dmFyIHNFPVNyKGZ1bmN0aW9uKHIsbyl7dmFyIEM9cj09bnVsbD8wOnIubGVuZ3RoLHo9JHMocixvKTtyZXR1cm4gZnUocix5ZShvLGZ1bmN0aW9uKFgpe3JldHVybiBUcihYLEMpPytYOlh9KS5zb3J0KE91KSksen0pO2Z1bmN0aW9uIG9FKHIsbyl7dmFyIEM9W107aWYoIShyJiZyLmxlbmd0aCkpcmV0dXJuIEM7dmFyIHo9LTEsWD1bXSxldD1yLmxlbmd0aDtmb3Iobz1IdChvLDMpOysrejxldDspe3ZhciBsdD1yW3pdO28obHQseixyKSYmKEMucHVzaChsdCksWC5wdXNoKHopKX1yZXR1cm4gZnUocixYKSxDfWZ1bmN0aW9uIHBvKHIpe3JldHVybiByPT1udWxsP3I6XzIuY2FsbChyKX1mdW5jdGlvbiBhRShyLG8sQyl7dmFyIHo9cj09bnVsbD8wOnIubGVuZ3RoO3JldHVybiB6PyhDJiZ0eXBlb2YgQyE9Im51bWJlciImJlVlKHIsbyxDKT8obz0wLEM9eik6KG89bz09bnVsbD8wOnF0KG8pLEM9Qz09PXQ/ejpxdChDKSksaXIocixvLEMpKTpbXX1mdW5jdGlvbiBsRShyLG8pe3JldHVybiB3aShyLG8pfWZ1bmN0aW9uIHVFKHIsbyxDKXtyZXR1cm4gcXMocixvLEh0KEMsMikpfWZ1bmN0aW9uIGZFKHIsbyl7dmFyIEM9cj09bnVsbD8wOnIubGVuZ3RoO2lmKEMpe3ZhciB6PXdpKHIsbyk7aWYoejxDJiZjcihyW3pdLG8pKXJldHVybiB6fXJldHVybi0xfWZ1bmN0aW9uIGNFKHIsbyl7cmV0dXJuIHdpKHIsbywhMCl9ZnVuY3Rpb24gaEUocixvLEMpe3JldHVybiBxcyhyLG8sSHQoQywyKSwhMCl9ZnVuY3Rpb24gZEUocixvKXt2YXIgQz1yPT1udWxsPzA6ci5sZW5ndGg7aWYoQyl7dmFyIHo9d2kocixvLCEwKS0xO2lmKGNyKHJbel0sbykpcmV0dXJuIHp9cmV0dXJuLTF9ZnVuY3Rpb24gZ0Uocil7cmV0dXJuIHImJnIubGVuZ3RoP2h1KHIpOltdfWZ1bmN0aW9uIHZFKHIsbyl7cmV0dXJuIHImJnIubGVuZ3RoP2h1KHIsSHQobywyKSk6W119ZnVuY3Rpb24gcEUocil7dmFyIG89cj09bnVsbD8wOnIubGVuZ3RoO3JldHVybiBvP2lyKHIsMSxvKTpbXX1mdW5jdGlvbiBtRShyLG8sQyl7cmV0dXJuIHImJnIubGVuZ3RoPyhvPUN8fG89PT10PzE6cXQobyksaXIociwwLG88MD8wOm8pKTpbXX1mdW5jdGlvbiB5RShyLG8sQyl7dmFyIHo9cj09bnVsbD8wOnIubGVuZ3RoO3JldHVybiB6PyhvPUN8fG89PT10PzE6cXQobyksbz16LW8saXIocixvPDA/MDpvLHopKTpbXX1mdW5jdGlvbiB4RShyLG8pe3JldHVybiByJiZyLmxlbmd0aD9OaShyLEh0KG8sMyksITEsITApOltdfWZ1bmN0aW9uIE9FKHIsbyl7cmV0dXJuIHImJnIubGVuZ3RoP05pKHIsSHQobywzKSk6W119dmFyIEVFPXRlKGZ1bmN0aW9uKHIpe3JldHVybiBGcihCZShyLDEsQWUsITApKX0pLE1FPXRlKGZ1bmN0aW9uKHIpe3ZhciBvPXNyKHIpO3JldHVybiBBZShvKSYmKG89dCksRnIoQmUociwxLEFlLCEwKSxIdChvLDIpKX0pLFNFPXRlKGZ1bmN0aW9uKHIpe3ZhciBvPXNyKHIpO3JldHVybiBvPXR5cGVvZiBvPT0iZnVuY3Rpb24iP286dCxGcihCZShyLDEsQWUsITApLHQsbyl9KTtmdW5jdGlvbiBURShyKXtyZXR1cm4gciYmci5sZW5ndGg/RnIocik6W119ZnVuY3Rpb24gUEUocixvKXtyZXR1cm4gciYmci5sZW5ndGg/RnIocixIdChvLDIpKTpbXX1mdW5jdGlvbiBiRShyLG8pe3JldHVybiBvPXR5cGVvZiBvPT0iZnVuY3Rpb24iP286dCxyJiZyLmxlbmd0aD9GcihyLHQsbyk6W119ZnVuY3Rpb24gbW8ocil7aWYoIShyJiZyLmxlbmd0aCkpcmV0dXJuW107dmFyIG89MDtyZXR1cm4gcj1EcihyLGZ1bmN0aW9uKEMpe2lmKEFlKEMpKXJldHVybiBvPURlKEMubGVuZ3RoLG8pLCEwfSksd3MobyxmdW5jdGlvbihDKXtyZXR1cm4geWUocixJcyhDKSl9KX1mdW5jdGlvbiBxdShyLG8pe2lmKCEociYmci5sZW5ndGgpKXJldHVybltdO3ZhciBDPW1vKHIpO3JldHVybiBvPT1udWxsP0M6eWUoQyxmdW5jdGlvbih6KXtyZXR1cm4gWGUobyx0LHopfSl9dmFyIEFFPXRlKGZ1bmN0aW9uKHIsbyl7cmV0dXJuIEFlKHIpP2puKHIsbyk6W119KSxDRT10ZShmdW5jdGlvbihyKXtyZXR1cm4gdG8oRHIocixBZSkpfSksUkU9dGUoZnVuY3Rpb24ocil7dmFyIG89c3Iocik7cmV0dXJuIEFlKG8pJiYobz10KSx0byhEcihyLEFlKSxIdChvLDIpKX0pLElFPXRlKGZ1bmN0aW9uKHIpe3ZhciBvPXNyKHIpO3JldHVybiBvPXR5cGVvZiBvPT0iZnVuY3Rpb24iP286dCx0byhEcihyLEFlKSx0LG8pfSksTEU9dGUobW8pO2Z1bmN0aW9uIERFKHIsbyl7cmV0dXJuIHB1KHJ8fFtdLG98fFtdLEZuKX1mdW5jdGlvbiB3RShyLG8pe3JldHVybiBwdShyfHxbXSxvfHxbXSwkbil9dmFyIE5FPXRlKGZ1bmN0aW9uKHIpe3ZhciBvPXIubGVuZ3RoLEM9bz4xP3Jbby0xXTp0O3JldHVybiBDPXR5cGVvZiBDPT0iZnVuY3Rpb24iPyhyLnBvcCgpLEMpOnQscXUocixDKX0pO2Z1bmN0aW9uIF91KHIpe3ZhciBvPXEocik7cmV0dXJuIG8uX19jaGFpbl9fPSEwLG99ZnVuY3Rpb24gQkUocixvKXtyZXR1cm4gbyhyKSxyfWZ1bmN0aW9uIEtpKHIsbyl7cmV0dXJuIG8ocil9dmFyIFdFPVNyKGZ1bmN0aW9uKHIpe3ZhciBvPXIubGVuZ3RoLEM9bz9yWzBdOjAsej10aGlzLl9fd3JhcHBlZF9fLFg9ZnVuY3Rpb24oZXQpe3JldHVybiAkcyhldCxyKX07cmV0dXJuIG8+MXx8dGhpcy5fX2FjdGlvbnNfXy5sZW5ndGh8fCEoeiBpbnN0YW5jZW9mIHJlKXx8IVRyKEMpP3RoaXMudGhydShYKTooej16LnNsaWNlKEMsK0MrKG8/MTowKSksei5fX2FjdGlvbnNfXy5wdXNoKHtmdW5jOktpLGFyZ3M6W1hdLHRoaXNBcmc6dH0pLG5ldyBycih6LHRoaXMuX19jaGFpbl9fKS50aHJ1KGZ1bmN0aW9uKGV0KXtyZXR1cm4gbyYmIWV0Lmxlbmd0aCYmZXQucHVzaCh0KSxldH0pKX0pO2Z1bmN0aW9uIEZFKCl7cmV0dXJuIF91KHRoaXMpfWZ1bmN0aW9uIGpFKCl7cmV0dXJuIG5ldyBycih0aGlzLnZhbHVlKCksdGhpcy5fX2NoYWluX18pfWZ1bmN0aW9uIFVFKCl7dGhpcy5fX3ZhbHVlc19fPT09dCYmKHRoaXMuX192YWx1ZXNfXz1nZih0aGlzLnZhbHVlKCkpKTt2YXIgcj10aGlzLl9faW5kZXhfXz49dGhpcy5fX3ZhbHVlc19fLmxlbmd0aCxvPXI/dDp0aGlzLl9fdmFsdWVzX19bdGhpcy5fX2luZGV4X18rK107cmV0dXJue2RvbmU6cix2YWx1ZTpvfX1mdW5jdGlvbiB6RSgpe3JldHVybiB0aGlzfWZ1bmN0aW9uICRFKHIpe2Zvcih2YXIgbyxDPXRoaXM7QyBpbnN0YW5jZW9mIENpOyl7dmFyIHo9VnUoQyk7ei5fX2luZGV4X189MCx6Ll9fdmFsdWVzX189dCxvP1guX193cmFwcGVkX189ejpvPXo7dmFyIFg9ejtDPUMuX193cmFwcGVkX199cmV0dXJuIFguX193cmFwcGVkX189cixvfWZ1bmN0aW9uIEdFKCl7dmFyIHI9dGhpcy5fX3dyYXBwZWRfXztpZihyIGluc3RhbmNlb2YgcmUpe3ZhciBvPXI7cmV0dXJuIHRoaXMuX19hY3Rpb25zX18ubGVuZ3RoJiYobz1uZXcgcmUodGhpcykpLG89by5yZXZlcnNlKCksby5fX2FjdGlvbnNfXy5wdXNoKHtmdW5jOktpLGFyZ3M6W3BvXSx0aGlzQXJnOnR9KSxuZXcgcnIobyx0aGlzLl9fY2hhaW5fXyl9cmV0dXJuIHRoaXMudGhydShwbyl9ZnVuY3Rpb24gS0UoKXtyZXR1cm4gdnUodGhpcy5fX3dyYXBwZWRfXyx0aGlzLl9fYWN0aW9uc19fKX12YXIgSEU9QmkoZnVuY3Rpb24ocixvLEMpe2ZlLmNhbGwocixDKT8rK3JbQ106RXIocixDLDEpfSk7ZnVuY3Rpb24gWUUocixvLEMpe3ZhciB6PWt0KHIpP0NsOkJ4O3JldHVybiBDJiZVZShyLG8sQykmJihvPXQpLHoocixIdChvLDMpKX1mdW5jdGlvbiBWRShyLG8pe3ZhciBDPWt0KHIpP0RyOnFsO3JldHVybiBDKHIsSHQobywzKSl9dmFyIFhFPWJ1KFh1KSxaRT1idShadSk7ZnVuY3Rpb24gSkUocixvKXtyZXR1cm4gQmUoSGkocixvKSwxKX1mdW5jdGlvbiBRRShyLG8pe3JldHVybiBCZShIaShyLG8pLEopfWZ1bmN0aW9uIGtFKHIsbyxDKXtyZXR1cm4gQz1DPT09dD8xOnF0KEMpLEJlKEhpKHIsbyksQyl9ZnVuY3Rpb24gdGYocixvKXt2YXIgQz1rdChyKT90cjpXcjtyZXR1cm4gQyhyLEh0KG8sMykpfWZ1bmN0aW9uIGVmKHIsbyl7dmFyIEM9a3Qocik/cDI6a2w7cmV0dXJuIEMocixIdChvLDMpKX12YXIgcUU9QmkoZnVuY3Rpb24ocixvLEMpe2ZlLmNhbGwocixDKT9yW0NdLnB1c2gobyk6RXIocixDLFtvXSl9KTtmdW5jdGlvbiBfRShyLG8sQyx6KXtyPUtlKHIpP3I6QW4ociksQz1DJiYhej9xdChDKTowO3ZhciBYPXIubGVuZ3RoO3JldHVybiBDPDAmJihDPURlKFgrQywwKSksSmkocik/Qzw9WCYmci5pbmRleE9mKG8sQyk+LTE6ISFYJiZ2bihyLG8sQyk+LTF9dmFyIHRNPXRlKGZ1bmN0aW9uKHIsbyxDKXt2YXIgej0tMSxYPXR5cGVvZiBvPT0iZnVuY3Rpb24iLGV0PUtlKHIpP1B0KHIubGVuZ3RoKTpbXTtyZXR1cm4gV3IocixmdW5jdGlvbihsdCl7ZXRbKyt6XT1YP1hlKG8sbHQsQyk6VW4obHQsbyxDKX0pLGV0fSksZU09QmkoZnVuY3Rpb24ocixvLEMpe0VyKHIsQyxvKX0pO2Z1bmN0aW9uIEhpKHIsbyl7dmFyIEM9a3Qocik/eWU6aXU7cmV0dXJuIEMocixIdChvLDMpKX1mdW5jdGlvbiByTShyLG8sQyx6KXtyZXR1cm4gcj09bnVsbD9bXTooa3Qobyl8fChvPW89PW51bGw/W106W29dKSxDPXo/dDpDLGt0KEMpfHwoQz1DPT1udWxsP1tdOltDXSksbHUocixvLEMpKX12YXIgbk09QmkoZnVuY3Rpb24ocixvLEMpe3JbQz8wOjFdLnB1c2gobyl9LGZ1bmN0aW9uKCl7cmV0dXJuW1tdLFtdXX0pO2Z1bmN0aW9uIGlNKHIsbyxDKXt2YXIgej1rdChyKT9DczpEbCxYPWFyZ3VtZW50cy5sZW5ndGg8MztyZXR1cm4geihyLEh0KG8sNCksQyxYLFdyKX1mdW5jdGlvbiBzTShyLG8sQyl7dmFyIHo9a3Qocik/bTI6RGwsWD1hcmd1bWVudHMubGVuZ3RoPDM7cmV0dXJuIHoocixIdChvLDQpLEMsWCxrbCl9ZnVuY3Rpb24gb00ocixvKXt2YXIgQz1rdChyKT9EcjpxbDtyZXR1cm4gQyhyLFhpKEh0KG8sMykpKX1mdW5jdGlvbiBhTShyKXt2YXIgbz1rdChyKT9YbDpfeDtyZXR1cm4gbyhyKX1mdW5jdGlvbiBsTShyLG8sQyl7KEM/VWUocixvLEMpOm89PT10KT9vPTE6bz1xdChvKTt2YXIgej1rdChyKT9JeDp0TztyZXR1cm4geihyLG8pfWZ1bmN0aW9uIHVNKHIpe3ZhciBvPWt0KHIpP0x4OnJPO3JldHVybiBvKHIpfWZ1bmN0aW9uIGZNKHIpe2lmKHI9PW51bGwpcmV0dXJuIDA7aWYoS2UocikpcmV0dXJuIEppKHIpP21uKHIpOnIubGVuZ3RoO3ZhciBvPUZlKHIpO3JldHVybiBvPT1IfHxvPT1udD9yLnNpemU6WHMocikubGVuZ3RofWZ1bmN0aW9uIGNNKHIsbyxDKXt2YXIgej1rdChyKT9SczpuTztyZXR1cm4gQyYmVWUocixvLEMpJiYobz10KSx6KHIsSHQobywzKSl9dmFyIGhNPXRlKGZ1bmN0aW9uKHIsbyl7aWYocj09bnVsbClyZXR1cm5bXTt2YXIgQz1vLmxlbmd0aDtyZXR1cm4gQz4xJiZVZShyLG9bMF0sb1sxXSk/bz1bXTpDPjImJlVlKG9bMF0sb1sxXSxvWzJdKSYmKG89W29bMF1dKSxsdShyLEJlKG8sMSksW10pfSksWWk9VjJ8fGZ1bmN0aW9uKCl7cmV0dXJuIE5lLkRhdGUubm93KCl9O2Z1bmN0aW9uIGRNKHIsbyl7aWYodHlwZW9mIG8hPSJmdW5jdGlvbiIpdGhyb3cgbmV3IGVyKGgpO3JldHVybiByPXF0KHIpLGZ1bmN0aW9uKCl7aWYoLS1yPDEpcmV0dXJuIG8uYXBwbHkodGhpcyxhcmd1bWVudHMpfX1mdW5jdGlvbiByZihyLG8sQyl7cmV0dXJuIG89Qz90Om8sbz1yJiZvPT1udWxsP3IubGVuZ3RoOm8sTXIocixSLHQsdCx0LHQsbyl9ZnVuY3Rpb24gbmYocixvKXt2YXIgQztpZih0eXBlb2YgbyE9ImZ1bmN0aW9uIil0aHJvdyBuZXcgZXIoaCk7cmV0dXJuIHI9cXQociksZnVuY3Rpb24oKXtyZXR1cm4tLXI+MCYmKEM9by5hcHBseSh0aGlzLGFyZ3VtZW50cykpLHI8PTEmJihvPXQpLEN9fXZhciB5bz10ZShmdW5jdGlvbihyLG8sQyl7dmFyIHo9eTtpZihDLmxlbmd0aCl7dmFyIFg9TnIoQyxQbih5bykpO3p8PXZ9cmV0dXJuIE1yKHIseixvLEMsWCl9KSxzZj10ZShmdW5jdGlvbihyLG8sQyl7dmFyIHo9eXxTO2lmKEMubGVuZ3RoKXt2YXIgWD1OcihDLFBuKHNmKSk7enw9dn1yZXR1cm4gTXIobyx6LHIsQyxYKX0pO2Z1bmN0aW9uIG9mKHIsbyxDKXtvPUM/dDpvO3ZhciB6PU1yKHIsYyx0LHQsdCx0LHQsbyk7cmV0dXJuIHoucGxhY2Vob2xkZXI9b2YucGxhY2Vob2xkZXIsen1mdW5jdGlvbiBhZihyLG8sQyl7bz1DP3Q6bzt2YXIgej1NcihyLGwsdCx0LHQsdCx0LG8pO3JldHVybiB6LnBsYWNlaG9sZGVyPWFmLnBsYWNlaG9sZGVyLHp9ZnVuY3Rpb24gbGYocixvLEMpe3ZhciB6LFgsZXQsbHQsZnQseXQsUnQ9MCxJdD0hMSx3dD0hMSxXdD0hMDtpZih0eXBlb2YgciE9ImZ1bmN0aW9uIil0aHJvdyBuZXcgZXIoaCk7bz1vcihvKXx8MCxNZShDKSYmKEl0PSEhQy5sZWFkaW5nLHd0PSJtYXhXYWl0ImluIEMsZXQ9d3Q/RGUob3IoQy5tYXhXYWl0KXx8MCxvKTpldCxXdD0idHJhaWxpbmciaW4gQz8hIUMudHJhaWxpbmc6V3QpO2Z1bmN0aW9uIFV0KENlKXt2YXIgaHI9eixBcj1YO3JldHVybiB6PVg9dCxSdD1DZSxsdD1yLmFwcGx5KEFyLGhyKSxsdH1mdW5jdGlvbiBYdChDZSl7cmV0dXJuIFJ0PUNlLGZ0PUhuKGVlLG8pLEl0P1V0KENlKTpsdH1mdW5jdGlvbiBfdChDZSl7dmFyIGhyPUNlLXl0LEFyPUNlLVJ0LEFmPW8taHI7cmV0dXJuIHd0P1dlKEFmLGV0LUFyKTpBZn1mdW5jdGlvbiBadChDZSl7dmFyIGhyPUNlLXl0LEFyPUNlLVJ0O3JldHVybiB5dD09PXR8fGhyPj1vfHxocjwwfHx3dCYmQXI+PWV0fWZ1bmN0aW9uIGVlKCl7dmFyIENlPVlpKCk7aWYoWnQoQ2UpKXJldHVybiBuZShDZSk7ZnQ9SG4oZWUsX3QoQ2UpKX1mdW5jdGlvbiBuZShDZSl7cmV0dXJuIGZ0PXQsV3QmJno/VXQoQ2UpOih6PVg9dCxsdCl9ZnVuY3Rpb24ga2UoKXtmdCE9PXQmJm11KGZ0KSxSdD0wLHo9eXQ9WD1mdD10fWZ1bmN0aW9uIHplKCl7cmV0dXJuIGZ0PT09dD9sdDpuZShZaSgpKX1mdW5jdGlvbiBxZSgpe3ZhciBDZT1ZaSgpLGhyPVp0KENlKTtpZih6PWFyZ3VtZW50cyxYPXRoaXMseXQ9Q2UsaHIpe2lmKGZ0PT09dClyZXR1cm4gWHQoeXQpO2lmKHd0KXJldHVybiBtdShmdCksZnQ9SG4oZWUsbyksVXQoeXQpfXJldHVybiBmdD09PXQmJihmdD1IbihlZSxvKSksbHR9cmV0dXJuIHFlLmNhbmNlbD1rZSxxZS5mbHVzaD16ZSxxZX12YXIgZ009dGUoZnVuY3Rpb24ocixvKXtyZXR1cm4gUWwociwxLG8pfSksdk09dGUoZnVuY3Rpb24ocixvLEMpe3JldHVybiBRbChyLG9yKG8pfHwwLEMpfSk7ZnVuY3Rpb24gcE0ocil7cmV0dXJuIE1yKHIsTil9ZnVuY3Rpb24gVmkocixvKXtpZih0eXBlb2YgciE9ImZ1bmN0aW9uInx8byE9bnVsbCYmdHlwZW9mIG8hPSJmdW5jdGlvbiIpdGhyb3cgbmV3IGVyKGgpO3ZhciBDPWZ1bmN0aW9uKCl7dmFyIHo9YXJndW1lbnRzLFg9bz9vLmFwcGx5KHRoaXMseik6elswXSxldD1DLmNhY2hlO2lmKGV0LmhhcyhYKSlyZXR1cm4gZXQuZ2V0KFgpO3ZhciBsdD1yLmFwcGx5KHRoaXMseik7cmV0dXJuIEMuY2FjaGU9ZXQuc2V0KFgsbHQpfHxldCxsdH07cmV0dXJuIEMuY2FjaGU9bmV3KFZpLkNhY2hlfHxPciksQ31WaS5DYWNoZT1PcjtmdW5jdGlvbiBYaShyKXtpZih0eXBlb2YgciE9ImZ1bmN0aW9uIil0aHJvdyBuZXcgZXIoaCk7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIG89YXJndW1lbnRzO3N3aXRjaChvLmxlbmd0aCl7Y2FzZSAwOnJldHVybiFyLmNhbGwodGhpcyk7Y2FzZSAxOnJldHVybiFyLmNhbGwodGhpcyxvWzBdKTtjYXNlIDI6cmV0dXJuIXIuY2FsbCh0aGlzLG9bMF0sb1sxXSk7Y2FzZSAzOnJldHVybiFyLmNhbGwodGhpcyxvWzBdLG9bMV0sb1syXSl9cmV0dXJuIXIuYXBwbHkodGhpcyxvKX19ZnVuY3Rpb24gbU0ocil7cmV0dXJuIG5mKDIscil9dmFyIHlNPWlPKGZ1bmN0aW9uKHIsbyl7bz1vLmxlbmd0aD09MSYma3Qob1swXSk/eWUob1swXSxaZShIdCgpKSk6eWUoQmUobywxKSxaZShIdCgpKSk7dmFyIEM9by5sZW5ndGg7cmV0dXJuIHRlKGZ1bmN0aW9uKHope2Zvcih2YXIgWD0tMSxldD1XZSh6Lmxlbmd0aCxDKTsrK1g8ZXQ7KXpbWF09b1tYXS5jYWxsKHRoaXMseltYXSk7cmV0dXJuIFhlKHIsdGhpcyx6KX0pfSkseG89dGUoZnVuY3Rpb24ocixvKXt2YXIgQz1OcihvLFBuKHhvKSk7cmV0dXJuIE1yKHIsdix0LG8sQyl9KSx1Zj10ZShmdW5jdGlvbihyLG8pe3ZhciBDPU5yKG8sUG4odWYpKTtyZXR1cm4gTXIocixULHQsbyxDKX0pLHhNPVNyKGZ1bmN0aW9uKHIsbyl7cmV0dXJuIE1yKHIsTCx0LHQsdCxvKX0pO2Z1bmN0aW9uIE9NKHIsbyl7aWYodHlwZW9mIHIhPSJmdW5jdGlvbiIpdGhyb3cgbmV3IGVyKGgpO3JldHVybiBvPW89PT10P286cXQobyksdGUocixvKX1mdW5jdGlvbiBFTShyLG8pe2lmKHR5cGVvZiByIT0iZnVuY3Rpb24iKXRocm93IG5ldyBlcihoKTtyZXR1cm4gbz1vPT1udWxsPzA6RGUocXQobyksMCksdGUoZnVuY3Rpb24oQyl7dmFyIHo9Q1tvXSxYPVVyKEMsMCxvKTtyZXR1cm4geiYmd3IoWCx6KSxYZShyLHRoaXMsWCl9KX1mdW5jdGlvbiBNTShyLG8sQyl7dmFyIHo9ITAsWD0hMDtpZih0eXBlb2YgciE9ImZ1bmN0aW9uIil0aHJvdyBuZXcgZXIoaCk7cmV0dXJuIE1lKEMpJiYoej0ibGVhZGluZyJpbiBDPyEhQy5sZWFkaW5nOnosWD0idHJhaWxpbmciaW4gQz8hIUMudHJhaWxpbmc6WCksbGYocixvLHtsZWFkaW5nOnosbWF4V2FpdDpvLHRyYWlsaW5nOlh9KX1mdW5jdGlvbiBTTShyKXtyZXR1cm4gcmYociwxKX1mdW5jdGlvbiBUTShyLG8pe3JldHVybiB4byhybyhvKSxyKX1mdW5jdGlvbiBQTSgpe2lmKCFhcmd1bWVudHMubGVuZ3RoKXJldHVybltdO3ZhciByPWFyZ3VtZW50c1swXTtyZXR1cm4ga3Qocik/cjpbcl19ZnVuY3Rpb24gYk0ocil7cmV0dXJuIG5yKHIsbSl9ZnVuY3Rpb24gQU0ocixvKXtyZXR1cm4gbz10eXBlb2Ygbz09ImZ1bmN0aW9uIj9vOnQsbnIocixtLG8pfWZ1bmN0aW9uIENNKHIpe3JldHVybiBucihyLHB8bSl9ZnVuY3Rpb24gUk0ocixvKXtyZXR1cm4gbz10eXBlb2Ygbz09ImZ1bmN0aW9uIj9vOnQsbnIocixwfG0sbyl9ZnVuY3Rpb24gSU0ocixvKXtyZXR1cm4gbz09bnVsbHx8SmwocixvLHdlKG8pKX1mdW5jdGlvbiBjcihyLG8pe3JldHVybiByPT09b3x8ciE9PXImJm8hPT1vfXZhciBMTT1VaShIcyksRE09VWkoZnVuY3Rpb24ocixvKXtyZXR1cm4gcj49b30pLHRuPWV1KGZ1bmN0aW9uKCl7cmV0dXJuIGFyZ3VtZW50c30oKSk/ZXU6ZnVuY3Rpb24ocil7cmV0dXJuIFBlKHIpJiZmZS5jYWxsKHIsImNhbGxlZSIpJiYhJGwuY2FsbChyLCJjYWxsZWUiKX0sa3Q9UHQuaXNBcnJheSx3TT1NbD9aZShNbCk6JHg7ZnVuY3Rpb24gS2Uocil7cmV0dXJuIHIhPW51bGwmJlppKHIubGVuZ3RoKSYmIVByKHIpfWZ1bmN0aW9uIEFlKHIpe3JldHVybiBQZShyKSYmS2Uocil9ZnVuY3Rpb24gTk0ocil7cmV0dXJuIHI9PT0hMHx8cj09PSExfHxQZShyKSYmamUocik9PU90fXZhciB6cj1aMnx8SW8sQk09U2w/WmUoU2wpOkd4O2Z1bmN0aW9uIFdNKHIpe3JldHVybiBQZShyKSYmci5ub2RlVHlwZT09PTEmJiFZbihyKX1mdW5jdGlvbiBGTShyKXtpZihyPT1udWxsKXJldHVybiEwO2lmKEtlKHIpJiYoa3Qocil8fHR5cGVvZiByPT0ic3RyaW5nInx8dHlwZW9mIHIuc3BsaWNlPT0iZnVuY3Rpb24ifHx6cihyKXx8Ym4ocil8fHRuKHIpKSlyZXR1cm4hci5sZW5ndGg7dmFyIG89RmUocik7aWYobz09SHx8bz09bnQpcmV0dXJuIXIuc2l6ZTtpZihLbihyKSlyZXR1cm4hWHMocikubGVuZ3RoO2Zvcih2YXIgQyBpbiByKWlmKGZlLmNhbGwocixDKSlyZXR1cm4hMTtyZXR1cm4hMH1mdW5jdGlvbiBqTShyLG8pe3JldHVybiB6bihyLG8pfWZ1bmN0aW9uIFVNKHIsbyxDKXtDPXR5cGVvZiBDPT0iZnVuY3Rpb24iP0M6dDt2YXIgej1DP0MocixvKTp0O3JldHVybiB6PT09dD96bihyLG8sdCxDKTohIXp9ZnVuY3Rpb24gT28ocil7aWYoIVBlKHIpKXJldHVybiExO3ZhciBvPWplKHIpO3JldHVybiBvPT1RfHxvPT0kfHx0eXBlb2Ygci5tZXNzYWdlPT0ic3RyaW5nIiYmdHlwZW9mIHIubmFtZT09InN0cmluZyImJiFZbihyKX1mdW5jdGlvbiB6TShyKXtyZXR1cm4gdHlwZW9mIHI9PSJudW1iZXIiJiZLbChyKX1mdW5jdGlvbiBQcihyKXtpZighTWUocikpcmV0dXJuITE7dmFyIG89amUocik7cmV0dXJuIG89PXR0fHxvPT1GfHxvPT1NdHx8bz09Wn1mdW5jdGlvbiBmZihyKXtyZXR1cm4gdHlwZW9mIHI9PSJudW1iZXIiJiZyPT1xdChyKX1mdW5jdGlvbiBaaShyKXtyZXR1cm4gdHlwZW9mIHI9PSJudW1iZXIiJiZyPi0xJiZyJTE9PTAmJnI8PV99ZnVuY3Rpb24gTWUocil7dmFyIG89dHlwZW9mIHI7cmV0dXJuIHIhPW51bGwmJihvPT0ib2JqZWN0Inx8bz09ImZ1bmN0aW9uIil9ZnVuY3Rpb24gUGUocil7cmV0dXJuIHIhPW51bGwmJnR5cGVvZiByPT0ib2JqZWN0In12YXIgY2Y9VGw/WmUoVGwpOkh4O2Z1bmN0aW9uICRNKHIsbyl7cmV0dXJuIHI9PT1vfHxWcyhyLG8sdW8obykpfWZ1bmN0aW9uIEdNKHIsbyxDKXtyZXR1cm4gQz10eXBlb2YgQz09ImZ1bmN0aW9uIj9DOnQsVnMocixvLHVvKG8pLEMpfWZ1bmN0aW9uIEtNKHIpe3JldHVybiBoZihyKSYmciE9K3J9ZnVuY3Rpb24gSE0ocil7aWYoQU8ocikpdGhyb3cgbmV3IFF0KGYpO3JldHVybiBydShyKX1mdW5jdGlvbiBZTShyKXtyZXR1cm4gcj09PW51bGx9ZnVuY3Rpb24gVk0ocil7cmV0dXJuIHI9PW51bGx9ZnVuY3Rpb24gaGYocil7cmV0dXJuIHR5cGVvZiByPT0ibnVtYmVyInx8UGUocikmJmplKHIpPT14fWZ1bmN0aW9uIFluKHIpe2lmKCFQZShyKXx8amUocikhPVcpcmV0dXJuITE7dmFyIG89RWkocik7aWYobz09PW51bGwpcmV0dXJuITA7dmFyIEM9ZmUuY2FsbChvLCJjb25zdHJ1Y3RvciIpJiZvLmNvbnN0cnVjdG9yO3JldHVybiB0eXBlb2YgQz09ImZ1bmN0aW9uIiYmQyBpbnN0YW5jZW9mIEMmJm1pLmNhbGwoQyk9PUcyfXZhciBFbz1QbD9aZShQbCk6WXg7ZnVuY3Rpb24gWE0ocil7cmV0dXJuIGZmKHIpJiZyPj0tXyYmcjw9X312YXIgZGY9Ymw/WmUoYmwpOlZ4O2Z1bmN0aW9uIEppKHIpe3JldHVybiB0eXBlb2Ygcj09InN0cmluZyJ8fCFrdChyKSYmUGUocikmJmplKHIpPT11dH1mdW5jdGlvbiBRZShyKXtyZXR1cm4gdHlwZW9mIHI9PSJzeW1ib2wifHxQZShyKSYmamUocik9PWN0fXZhciBibj1BbD9aZShBbCk6WHg7ZnVuY3Rpb24gWk0ocil7cmV0dXJuIHI9PT10fWZ1bmN0aW9uIEpNKHIpe3JldHVybiBQZShyKSYmRmUocik9PXh0fWZ1bmN0aW9uIFFNKHIpe3JldHVybiBQZShyKSYmamUocik9PWd0fXZhciBrTT1VaShacykscU09VWkoZnVuY3Rpb24ocixvKXtyZXR1cm4gcjw9b30pO2Z1bmN0aW9uIGdmKHIpe2lmKCFyKXJldHVybltdO2lmKEtlKHIpKXJldHVybiBKaShyKT91cihyKTpHZShyKTtpZihEbiYmcltEbl0pcmV0dXJuIEkyKHJbRG5dKCkpO3ZhciBvPUZlKHIpLEM9bz09SD9CczpvPT1udD9naTpBbjtyZXR1cm4gQyhyKX1mdW5jdGlvbiBicihyKXtpZighcilyZXR1cm4gcj09PTA/cjowO2lmKHI9b3Iocikscj09PUp8fHI9PT0tSil7dmFyIG89cjwwPy0xOjE7cmV0dXJuIG8qc3R9cmV0dXJuIHI9PT1yP3I6MH1mdW5jdGlvbiBxdChyKXt2YXIgbz1icihyKSxDPW8lMTtyZXR1cm4gbz09PW8/Qz9vLUM6bzowfWZ1bmN0aW9uIHZmKHIpe3JldHVybiByP1FyKHF0KHIpLDAsWSk6MH1mdW5jdGlvbiBvcihyKXtpZih0eXBlb2Ygcj09Im51bWJlciIpcmV0dXJuIHI7aWYoUWUocikpcmV0dXJuIEc7aWYoTWUocikpe3ZhciBvPXR5cGVvZiByLnZhbHVlT2Y9PSJmdW5jdGlvbiI/ci52YWx1ZU9mKCk6cjtyPU1lKG8pP28rIiI6b31pZih0eXBlb2YgciE9InN0cmluZyIpcmV0dXJuIHI9PT0wP3I6K3I7cj13bChyKTt2YXIgQz13eS50ZXN0KHIpO3JldHVybiBDfHxCeS50ZXN0KHIpP2QyKHIuc2xpY2UoMiksQz8yOjgpOkR5LnRlc3Qocik/Rzorcn1mdW5jdGlvbiBwZihyKXtyZXR1cm4gdnIocixIZShyKSl9ZnVuY3Rpb24gX00ocil7cmV0dXJuIHI/UXIocXQociksLV8sXyk6cj09PTA/cjowfWZ1bmN0aW9uIHVlKHIpe3JldHVybiByPT1udWxsPyIiOkplKHIpfXZhciB0Uz1TbihmdW5jdGlvbihyLG8pe2lmKEtuKG8pfHxLZShvKSl7dnIobyx3ZShvKSxyKTtyZXR1cm59Zm9yKHZhciBDIGluIG8pZmUuY2FsbChvLEMpJiZGbihyLEMsb1tDXSl9KSxtZj1TbihmdW5jdGlvbihyLG8pe3ZyKG8sSGUobykscil9KSxRaT1TbihmdW5jdGlvbihyLG8sQyx6KXt2cihvLEhlKG8pLHIseil9KSxlUz1TbihmdW5jdGlvbihyLG8sQyx6KXt2cihvLHdlKG8pLHIseil9KSxyUz1Tcigkcyk7ZnVuY3Rpb24gblMocixvKXt2YXIgQz1NbihyKTtyZXR1cm4gbz09bnVsbD9DOlpsKEMsbyl9dmFyIGlTPXRlKGZ1bmN0aW9uKHIsbyl7cj1oZShyKTt2YXIgQz0tMSx6PW8ubGVuZ3RoLFg9ej4yP29bMl06dDtmb3IoWCYmVWUob1swXSxvWzFdLFgpJiYoej0xKTsrK0M8ejspZm9yKHZhciBldD1vW0NdLGx0PUhlKGV0KSxmdD0tMSx5dD1sdC5sZW5ndGg7KytmdDx5dDspe3ZhciBSdD1sdFtmdF0sSXQ9cltSdF07KEl0PT09dHx8Y3IoSXQseG5bUnRdKSYmIWZlLmNhbGwocixSdCkpJiYocltSdF09ZXRbUnRdKX1yZXR1cm4gcn0pLHNTPXRlKGZ1bmN0aW9uKHIpe3JldHVybiByLnB1c2godCx3dSksWGUoeWYsdCxyKX0pO2Z1bmN0aW9uIG9TKHIsbyl7cmV0dXJuIFJsKHIsSHQobywzKSxncil9ZnVuY3Rpb24gYVMocixvKXtyZXR1cm4gUmwocixIdChvLDMpLEtzKX1mdW5jdGlvbiBsUyhyLG8pe3JldHVybiByPT1udWxsP3I6R3MocixIdChvLDMpLEhlKX1mdW5jdGlvbiB1UyhyLG8pe3JldHVybiByPT1udWxsP3I6X2wocixIdChvLDMpLEhlKX1mdW5jdGlvbiBmUyhyLG8pe3JldHVybiByJiZncihyLEh0KG8sMykpfWZ1bmN0aW9uIGNTKHIsbyl7cmV0dXJuIHImJktzKHIsSHQobywzKSl9ZnVuY3Rpb24gaFMocil7cmV0dXJuIHI9PW51bGw/W106TGkocix3ZShyKSl9ZnVuY3Rpb24gZFMocil7cmV0dXJuIHI9PW51bGw/W106TGkocixIZShyKSl9ZnVuY3Rpb24gTW8ocixvLEMpe3ZhciB6PXI9PW51bGw/dDprcihyLG8pO3JldHVybiB6PT09dD9DOnp9ZnVuY3Rpb24gZ1MocixvKXtyZXR1cm4gciE9bnVsbCYmV3UocixvLEZ4KX1mdW5jdGlvbiBTbyhyLG8pe3JldHVybiByIT1udWxsJiZXdShyLG8sangpfXZhciB2Uz1DdShmdW5jdGlvbihyLG8sQyl7byE9bnVsbCYmdHlwZW9mIG8udG9TdHJpbmchPSJmdW5jdGlvbiImJihvPXlpLmNhbGwobykpLHJbb109Q30sUG8oWWUpKSxwUz1DdShmdW5jdGlvbihyLG8sQyl7byE9bnVsbCYmdHlwZW9mIG8udG9TdHJpbmchPSJmdW5jdGlvbiImJihvPXlpLmNhbGwobykpLGZlLmNhbGwocixvKT9yW29dLnB1c2goQyk6cltvXT1bQ119LEh0KSxtUz10ZShVbik7ZnVuY3Rpb24gd2Uocil7cmV0dXJuIEtlKHIpP1ZsKHIpOlhzKHIpfWZ1bmN0aW9uIEhlKHIpe3JldHVybiBLZShyKT9WbChyLCEwKTpaeChyKX1mdW5jdGlvbiB5UyhyLG8pe3ZhciBDPXt9O3JldHVybiBvPUh0KG8sMyksZ3IocixmdW5jdGlvbih6LFgsZXQpe0VyKEMsbyh6LFgsZXQpLHopfSksQ31mdW5jdGlvbiB4UyhyLG8pe3ZhciBDPXt9O3JldHVybiBvPUh0KG8sMyksZ3IocixmdW5jdGlvbih6LFgsZXQpe0VyKEMsWCxvKHosWCxldCkpfSksQ312YXIgT1M9U24oZnVuY3Rpb24ocixvLEMpe0RpKHIsbyxDKX0pLHlmPVNuKGZ1bmN0aW9uKHIsbyxDLHope0RpKHIsbyxDLHopfSksRVM9U3IoZnVuY3Rpb24ocixvKXt2YXIgQz17fTtpZihyPT1udWxsKXJldHVybiBDO3ZhciB6PSExO289eWUobyxmdW5jdGlvbihldCl7cmV0dXJuIGV0PWpyKGV0LHIpLHp8fCh6PWV0Lmxlbmd0aD4xKSxldH0pLHZyKHIsYW8ociksQykseiYmKEM9bnIoQyxwfE98bSx2TykpO2Zvcih2YXIgWD1vLmxlbmd0aDtYLS07KV9zKEMsb1tYXSk7cmV0dXJuIEN9KTtmdW5jdGlvbiBNUyhyLG8pe3JldHVybiB4ZihyLFhpKEh0KG8pKSl9dmFyIFNTPVNyKGZ1bmN0aW9uKHIsbyl7cmV0dXJuIHI9PW51bGw/e306UXgocixvKX0pO2Z1bmN0aW9uIHhmKHIsbyl7aWYocj09bnVsbClyZXR1cm57fTt2YXIgQz15ZShhbyhyKSxmdW5jdGlvbih6KXtyZXR1cm5bel19KTtyZXR1cm4gbz1IdChvKSx1dShyLEMsZnVuY3Rpb24oeixYKXtyZXR1cm4gbyh6LFhbMF0pfSl9ZnVuY3Rpb24gVFMocixvLEMpe289anIobyxyKTt2YXIgej0tMSxYPW8ubGVuZ3RoO2ZvcihYfHwoWD0xLHI9dCk7Kyt6PFg7KXt2YXIgZXQ9cj09bnVsbD90OnJbcHIob1t6XSldO2V0PT09dCYmKHo9WCxldD1DKSxyPVByKGV0KT9ldC5jYWxsKHIpOmV0fXJldHVybiByfWZ1bmN0aW9uIFBTKHIsbyxDKXtyZXR1cm4gcj09bnVsbD9yOiRuKHIsbyxDKX1mdW5jdGlvbiBiUyhyLG8sQyx6KXtyZXR1cm4gej10eXBlb2Ygej09ImZ1bmN0aW9uIj96OnQscj09bnVsbD9yOiRuKHIsbyxDLHopfXZhciBPZj1MdSh3ZSksRWY9THUoSGUpO2Z1bmN0aW9uIEFTKHIsbyxDKXt2YXIgej1rdChyKSxYPXp8fHpyKHIpfHxibihyKTtpZihvPUh0KG8sNCksQz09bnVsbCl7dmFyIGV0PXImJnIuY29uc3RydWN0b3I7WD9DPXo/bmV3IGV0OltdOk1lKHIpP0M9UHIoZXQpP01uKEVpKHIpKTp7fTpDPXt9fXJldHVybihYP3RyOmdyKShyLGZ1bmN0aW9uKGx0LGZ0LHl0KXtyZXR1cm4gbyhDLGx0LGZ0LHl0KX0pLEN9ZnVuY3Rpb24gQ1MocixvKXtyZXR1cm4gcj09bnVsbD8hMDpfcyhyLG8pfWZ1bmN0aW9uIFJTKHIsbyxDKXtyZXR1cm4gcj09bnVsbD9yOmd1KHIsbyxybyhDKSl9ZnVuY3Rpb24gSVMocixvLEMseil7cmV0dXJuIHo9dHlwZW9mIHo9PSJmdW5jdGlvbiI/ejp0LHI9PW51bGw/cjpndShyLG8scm8oQykseil9ZnVuY3Rpb24gQW4ocil7cmV0dXJuIHI9PW51bGw/W106TnMocix3ZShyKSl9ZnVuY3Rpb24gTFMocil7cmV0dXJuIHI9PW51bGw/W106TnMocixIZShyKSl9ZnVuY3Rpb24gRFMocixvLEMpe3JldHVybiBDPT09dCYmKEM9byxvPXQpLEMhPT10JiYoQz1vcihDKSxDPUM9PT1DP0M6MCksbyE9PXQmJihvPW9yKG8pLG89bz09PW8/bzowKSxRcihvcihyKSxvLEMpfWZ1bmN0aW9uIHdTKHIsbyxDKXtyZXR1cm4gbz1icihvKSxDPT09dD8oQz1vLG89MCk6Qz1icihDKSxyPW9yKHIpLFV4KHIsbyxDKX1mdW5jdGlvbiBOUyhyLG8sQyl7aWYoQyYmdHlwZW9mIEMhPSJib29sZWFuIiYmVWUocixvLEMpJiYobz1DPXQpLEM9PT10JiYodHlwZW9mIG89PSJib29sZWFuIj8oQz1vLG89dCk6dHlwZW9mIHI9PSJib29sZWFuIiYmKEM9cixyPXQpKSxyPT09dCYmbz09PXQ/KHI9MCxvPTEpOihyPWJyKHIpLG89PT10PyhvPXIscj0wKTpvPWJyKG8pKSxyPm8pe3ZhciB6PXI7cj1vLG89en1pZihDfHxyJTF8fG8lMSl7dmFyIFg9SGwoKTtyZXR1cm4gV2UocitYKihvLXIraDIoIjFlLSIrKChYKyIiKS5sZW5ndGgtMSkpKSxvKX1yZXR1cm4gUXMocixvKX12YXIgQlM9VG4oZnVuY3Rpb24ocixvLEMpe3JldHVybiBvPW8udG9Mb3dlckNhc2UoKSxyKyhDP01mKG8pOm8pfSk7ZnVuY3Rpb24gTWYocil7cmV0dXJuIFRvKHVlKHIpLnRvTG93ZXJDYXNlKCkpfWZ1bmN0aW9uIFNmKHIpe3JldHVybiByPXVlKHIpLHImJnIucmVwbGFjZShGeSxQMikucmVwbGFjZShyMiwiIil9ZnVuY3Rpb24gV1MocixvLEMpe3I9dWUociksbz1KZShvKTt2YXIgej1yLmxlbmd0aDtDPUM9PT10P3o6UXIocXQoQyksMCx6KTt2YXIgWD1DO3JldHVybiBDLT1vLmxlbmd0aCxDPj0wJiZyLnNsaWNlKEMsWCk9PW99ZnVuY3Rpb24gRlMocil7cmV0dXJuIHI9dWUociksciYmSWUudGVzdChyKT9yLnJlcGxhY2UoVGUsYjIpOnJ9ZnVuY3Rpb24galMocil7cmV0dXJuIHI9dWUociksciYmU3kudGVzdChyKT9yLnJlcGxhY2UoeXMsIlxcJCYiKTpyfXZhciBVUz1UbihmdW5jdGlvbihyLG8sQyl7cmV0dXJuIHIrKEM/Ii0iOiIiKStvLnRvTG93ZXJDYXNlKCl9KSx6Uz1UbihmdW5jdGlvbihyLG8sQyl7cmV0dXJuIHIrKEM/IiAiOiIiKStvLnRvTG93ZXJDYXNlKCl9KSwkUz1QdSgidG9Mb3dlckNhc2UiKTtmdW5jdGlvbiBHUyhyLG8sQyl7cj11ZShyKSxvPXF0KG8pO3ZhciB6PW8/bW4ocik6MDtpZighb3x8ej49bylyZXR1cm4gcjt2YXIgWD0oby16KS8yO3JldHVybiBqaShQaShYKSxDKStyK2ppKFRpKFgpLEMpfWZ1bmN0aW9uIEtTKHIsbyxDKXtyPXVlKHIpLG89cXQobyk7dmFyIHo9bz9tbihyKTowO3JldHVybiBvJiZ6PG8/citqaShvLXosQyk6cn1mdW5jdGlvbiBIUyhyLG8sQyl7cj11ZShyKSxvPXF0KG8pO3ZhciB6PW8/bW4ocik6MDtyZXR1cm4gbyYmejxvP2ppKG8teixDKStyOnJ9ZnVuY3Rpb24gWVMocixvLEMpe3JldHVybiBDfHxvPT1udWxsP289MDpvJiYobz0rbykscTIodWUocikucmVwbGFjZSh4cywiIiksb3x8MCl9ZnVuY3Rpb24gVlMocixvLEMpe3JldHVybihDP1VlKHIsbyxDKTpvPT09dCk/bz0xOm89cXQobyksa3ModWUociksbyl9ZnVuY3Rpb24gWFMoKXt2YXIgcj1hcmd1bWVudHMsbz11ZShyWzBdKTtyZXR1cm4gci5sZW5ndGg8Mz9vOm8ucmVwbGFjZShyWzFdLHJbMl0pfXZhciBaUz1UbihmdW5jdGlvbihyLG8sQyl7cmV0dXJuIHIrKEM/Il8iOiIiKStvLnRvTG93ZXJDYXNlKCl9KTtmdW5jdGlvbiBKUyhyLG8sQyl7cmV0dXJuIEMmJnR5cGVvZiBDIT0ibnVtYmVyIiYmVWUocixvLEMpJiYobz1DPXQpLEM9Qz09PXQ/WTpDPj4+MCxDPyhyPXVlKHIpLHImJih0eXBlb2Ygbz09InN0cmluZyJ8fG8hPW51bGwmJiFFbyhvKSkmJihvPUplKG8pLCFvJiZwbihyKSk/VXIodXIociksMCxDKTpyLnNwbGl0KG8sQykpOltdfXZhciBRUz1UbihmdW5jdGlvbihyLG8sQyl7cmV0dXJuIHIrKEM/IiAiOiIiKStUbyhvKX0pO2Z1bmN0aW9uIGtTKHIsbyxDKXtyZXR1cm4gcj11ZShyKSxDPUM9PW51bGw/MDpRcihxdChDKSwwLHIubGVuZ3RoKSxvPUplKG8pLHIuc2xpY2UoQyxDK28ubGVuZ3RoKT09b31mdW5jdGlvbiBxUyhyLG8sQyl7dmFyIHo9cS50ZW1wbGF0ZVNldHRpbmdzO0MmJlVlKHIsbyxDKSYmKG89dCkscj11ZShyKSxvPVFpKHt9LG8seixEdSk7dmFyIFg9UWkoe30sby5pbXBvcnRzLHouaW1wb3J0cyxEdSksZXQ9d2UoWCksbHQ9TnMoWCxldCksZnQseXQsUnQ9MCxJdD1vLmludGVycG9sYXRlfHx1aSx3dD0iX19wICs9ICciLFd0PVdzKChvLmVzY2FwZXx8dWkpLnNvdXJjZSsifCIrSXQuc291cmNlKyJ8IisoSXQ9PT1Mcj9MeTp1aSkuc291cmNlKyJ8Iisoby5ldmFsdWF0ZXx8dWkpLnNvdXJjZSsifCQiLCJnIiksVXQ9Ii8vIyBzb3VyY2VVUkw9IisoZmUuY2FsbChvLCJzb3VyY2VVUkwiKT8oby5zb3VyY2VVUkwrIiIpLnJlcGxhY2UoL1xzL2csIiAiKToibG9kYXNoLnRlbXBsYXRlU291cmNlc1siKyArK2EyKyJdIikrYApgO3IucmVwbGFjZShXdCxmdW5jdGlvbihadCxlZSxuZSxrZSx6ZSxxZSl7cmV0dXJuIG5lfHwobmU9a2UpLHd0Kz1yLnNsaWNlKFJ0LHFlKS5yZXBsYWNlKGp5LEEyKSxlZSYmKGZ0PSEwLHd0Kz1gJyArCl9fZShgK2VlK2ApICsKJ2ApLHplJiYoeXQ9ITAsd3QrPWAnOwpgK3plK2A7Cl9fcCArPSAnYCksbmUmJih3dCs9YCcgKwooKF9fdCA9IChgK25lK2ApKSA9PSBudWxsID8gJycgOiBfX3QpICsKJ2ApLFJ0PXFlK1p0Lmxlbmd0aCxadH0pLHd0Kz1gJzsKYDt2YXIgWHQ9ZmUuY2FsbChvLCJ2YXJpYWJsZSIpJiZvLnZhcmlhYmxlO2lmKCFYdCl3dD1gd2l0aCAob2JqKSB7CmArd3QrYAp9CmA7ZWxzZSBpZihSeS50ZXN0KFh0KSl0aHJvdyBuZXcgUXQodSk7d3Q9KHl0P3d0LnJlcGxhY2UoU2UsIiIpOnd0KS5yZXBsYWNlKE9lLCIkMSIpLnJlcGxhY2UoRWUsIiQxOyIpLHd0PSJmdW5jdGlvbigiKyhYdHx8Im9iaiIpK2ApIHsKYCsoWHQ/IiI6YG9iaiB8fCAob2JqID0ge30pOwpgKSsidmFyIF9fdCwgX19wID0gJyciKyhmdD8iLCBfX2UgPSBfLmVzY2FwZSI6IiIpKyh5dD9gLCBfX2ogPSBBcnJheS5wcm90b3R5cGUuam9pbjsKZnVuY3Rpb24gcHJpbnQoKSB7IF9fcCArPSBfX2ouY2FsbChhcmd1bWVudHMsICcnKSB9CmA6YDsKYCkrd3QrYHJldHVybiBfX3AKfWA7dmFyIF90PVBmKGZ1bmN0aW9uKCl7cmV0dXJuIGFlKGV0LFV0KyJyZXR1cm4gIit3dCkuYXBwbHkodCxsdCl9KTtpZihfdC5zb3VyY2U9d3QsT28oX3QpKXRocm93IF90O3JldHVybiBfdH1mdW5jdGlvbiBfUyhyKXtyZXR1cm4gdWUocikudG9Mb3dlckNhc2UoKX1mdW5jdGlvbiB0VChyKXtyZXR1cm4gdWUocikudG9VcHBlckNhc2UoKX1mdW5jdGlvbiBlVChyLG8sQyl7aWYocj11ZShyKSxyJiYoQ3x8bz09PXQpKXJldHVybiB3bChyKTtpZighcnx8IShvPUplKG8pKSlyZXR1cm4gcjt2YXIgej11cihyKSxYPXVyKG8pLGV0PU5sKHosWCksbHQ9QmwoeixYKSsxO3JldHVybiBVcih6LGV0LGx0KS5qb2luKCIiKX1mdW5jdGlvbiByVChyLG8sQyl7aWYocj11ZShyKSxyJiYoQ3x8bz09PXQpKXJldHVybiByLnNsaWNlKDAsRmwocikrMSk7aWYoIXJ8fCEobz1KZShvKSkpcmV0dXJuIHI7dmFyIHo9dXIociksWD1CbCh6LHVyKG8pKSsxO3JldHVybiBVcih6LDAsWCkuam9pbigiIil9ZnVuY3Rpb24gblQocixvLEMpe2lmKHI9dWUociksciYmKEN8fG89PT10KSlyZXR1cm4gci5yZXBsYWNlKHhzLCIiKTtpZighcnx8IShvPUplKG8pKSlyZXR1cm4gcjt2YXIgej11cihyKSxYPU5sKHosdXIobykpO3JldHVybiBVcih6LFgpLmpvaW4oIiIpfWZ1bmN0aW9uIGlUKHIsbyl7dmFyIEM9QSx6PXc7aWYoTWUobykpe3ZhciBYPSJzZXBhcmF0b3IiaW4gbz9vLnNlcGFyYXRvcjpYO0M9Imxlbmd0aCJpbiBvP3F0KG8ubGVuZ3RoKTpDLHo9Im9taXNzaW9uImluIG8/SmUoby5vbWlzc2lvbik6en1yPXVlKHIpO3ZhciBldD1yLmxlbmd0aDtpZihwbihyKSl7dmFyIGx0PXVyKHIpO2V0PWx0Lmxlbmd0aH1pZihDPj1ldClyZXR1cm4gcjt2YXIgZnQ9Qy1tbih6KTtpZihmdDwxKXJldHVybiB6O3ZhciB5dD1sdD9VcihsdCwwLGZ0KS5qb2luKCIiKTpyLnNsaWNlKDAsZnQpO2lmKFg9PT10KXJldHVybiB5dCt6O2lmKGx0JiYoZnQrPXl0Lmxlbmd0aC1mdCksRW8oWCkpe2lmKHIuc2xpY2UoZnQpLnNlYXJjaChYKSl7dmFyIFJ0LEl0PXl0O2ZvcihYLmdsb2JhbHx8KFg9V3MoWC5zb3VyY2UsdWUoZWwuZXhlYyhYKSkrImciKSksWC5sYXN0SW5kZXg9MDtSdD1YLmV4ZWMoSXQpOyl2YXIgd3Q9UnQuaW5kZXg7eXQ9eXQuc2xpY2UoMCx3dD09PXQ/ZnQ6d3QpfX1lbHNlIGlmKHIuaW5kZXhPZihKZShYKSxmdCkhPWZ0KXt2YXIgV3Q9eXQubGFzdEluZGV4T2YoWCk7V3Q+LTEmJih5dD15dC5zbGljZSgwLFd0KSl9cmV0dXJuIHl0K3p9ZnVuY3Rpb24gc1Qocil7cmV0dXJuIHI9dWUociksciYmYmUudGVzdChyKT9yLnJlcGxhY2UobWUsTjIpOnJ9dmFyIG9UPVRuKGZ1bmN0aW9uKHIsbyxDKXtyZXR1cm4gcisoQz8iICI6IiIpK28udG9VcHBlckNhc2UoKX0pLFRvPVB1KCJ0b1VwcGVyQ2FzZSIpO2Z1bmN0aW9uIFRmKHIsbyxDKXtyZXR1cm4gcj11ZShyKSxvPUM/dDpvLG89PT10P1IyKHIpP0YyKHIpOk8yKHIpOnIubWF0Y2gobyl8fFtdfXZhciBQZj10ZShmdW5jdGlvbihyLG8pe3RyeXtyZXR1cm4gWGUocix0LG8pfWNhdGNoKEMpe3JldHVybiBPbyhDKT9DOm5ldyBRdChDKX19KSxhVD1TcihmdW5jdGlvbihyLG8pe3JldHVybiB0cihvLGZ1bmN0aW9uKEMpe0M9cHIoQyksRXIocixDLHlvKHJbQ10scikpfSkscn0pO2Z1bmN0aW9uIGxUKHIpe3ZhciBvPXI9PW51bGw/MDpyLmxlbmd0aCxDPUh0KCk7cmV0dXJuIHI9bz95ZShyLGZ1bmN0aW9uKHope2lmKHR5cGVvZiB6WzFdIT0iZnVuY3Rpb24iKXRocm93IG5ldyBlcihoKTtyZXR1cm5bQyh6WzBdKSx6WzFdXX0pOltdLHRlKGZ1bmN0aW9uKHope2Zvcih2YXIgWD0tMTsrK1g8bzspe3ZhciBldD1yW1hdO2lmKFhlKGV0WzBdLHRoaXMseikpcmV0dXJuIFhlKGV0WzFdLHRoaXMseil9fSl9ZnVuY3Rpb24gdVQocil7cmV0dXJuIE54KG5yKHIscCkpfWZ1bmN0aW9uIFBvKHIpe3JldHVybiBmdW5jdGlvbigpe3JldHVybiByfX1mdW5jdGlvbiBmVChyLG8pe3JldHVybiByPT1udWxsfHxyIT09cj9vOnJ9dmFyIGNUPUF1KCksaFQ9QXUoITApO2Z1bmN0aW9uIFllKHIpe3JldHVybiByfWZ1bmN0aW9uIGJvKHIpe3JldHVybiBudSh0eXBlb2Ygcj09ImZ1bmN0aW9uIj9yOm5yKHIscCkpfWZ1bmN0aW9uIGRUKHIpe3JldHVybiBzdShucihyLHApKX1mdW5jdGlvbiBnVChyLG8pe3JldHVybiBvdShyLG5yKG8scCkpfXZhciB2VD10ZShmdW5jdGlvbihyLG8pe3JldHVybiBmdW5jdGlvbihDKXtyZXR1cm4gVW4oQyxyLG8pfX0pLHBUPXRlKGZ1bmN0aW9uKHIsbyl7cmV0dXJuIGZ1bmN0aW9uKEMpe3JldHVybiBVbihyLEMsbyl9fSk7ZnVuY3Rpb24gQW8ocixvLEMpe3ZhciB6PXdlKG8pLFg9TGkobyx6KTtDPT1udWxsJiYhKE1lKG8pJiYoWC5sZW5ndGh8fCF6Lmxlbmd0aCkpJiYoQz1vLG89cixyPXRoaXMsWD1MaShvLHdlKG8pKSk7dmFyIGV0PSEoTWUoQykmJiJjaGFpbiJpbiBDKXx8ISFDLmNoYWluLGx0PVByKHIpO3JldHVybiB0cihYLGZ1bmN0aW9uKGZ0KXt2YXIgeXQ9b1tmdF07cltmdF09eXQsbHQmJihyLnByb3RvdHlwZVtmdF09ZnVuY3Rpb24oKXt2YXIgUnQ9dGhpcy5fX2NoYWluX187aWYoZXR8fFJ0KXt2YXIgSXQ9cih0aGlzLl9fd3JhcHBlZF9fKSx3dD1JdC5fX2FjdGlvbnNfXz1HZSh0aGlzLl9fYWN0aW9uc19fKTtyZXR1cm4gd3QucHVzaCh7ZnVuYzp5dCxhcmdzOmFyZ3VtZW50cyx0aGlzQXJnOnJ9KSxJdC5fX2NoYWluX189UnQsSXR9cmV0dXJuIHl0LmFwcGx5KHIsd3IoW3RoaXMudmFsdWUoKV0sYXJndW1lbnRzKSl9KX0pLHJ9ZnVuY3Rpb24gbVQoKXtyZXR1cm4gTmUuXz09PXRoaXMmJihOZS5fPUsyKSx0aGlzfWZ1bmN0aW9uIENvKCl7fWZ1bmN0aW9uIHlUKHIpe3JldHVybiByPXF0KHIpLHRlKGZ1bmN0aW9uKG8pe3JldHVybiBhdShvLHIpfSl9dmFyIHhUPWlvKHllKSxPVD1pbyhDbCksRVQ9aW8oUnMpO2Z1bmN0aW9uIGJmKHIpe3JldHVybiBjbyhyKT9JcyhwcihyKSk6a3gocil9ZnVuY3Rpb24gTVQocil7cmV0dXJuIGZ1bmN0aW9uKG8pe3JldHVybiByPT1udWxsP3Q6a3IocixvKX19dmFyIFNUPVJ1KCksVFQ9UnUoITApO2Z1bmN0aW9uIFJvKCl7cmV0dXJuW119ZnVuY3Rpb24gSW8oKXtyZXR1cm4hMX1mdW5jdGlvbiBQVCgpe3JldHVybnt9fWZ1bmN0aW9uIGJUKCl7cmV0dXJuIiJ9ZnVuY3Rpb24gQVQoKXtyZXR1cm4hMH1mdW5jdGlvbiBDVChyLG8pe2lmKHI9cXQocikscjwxfHxyPl8pcmV0dXJuW107dmFyIEM9WSx6PVdlKHIsWSk7bz1IdChvKSxyLT1ZO2Zvcih2YXIgWD13cyh6LG8pOysrQzxyOylvKEMpO3JldHVybiBYfWZ1bmN0aW9uIFJUKHIpe3JldHVybiBrdChyKT95ZShyLHByKTpRZShyKT9bcl06R2UoWXUodWUocikpKX1mdW5jdGlvbiBJVChyKXt2YXIgbz0rKyQyO3JldHVybiB1ZShyKStvfXZhciBMVD1GaShmdW5jdGlvbihyLG8pe3JldHVybiByK299LDApLERUPXNvKCJjZWlsIiksd1Q9RmkoZnVuY3Rpb24ocixvKXtyZXR1cm4gci9vfSwxKSxOVD1zbygiZmxvb3IiKTtmdW5jdGlvbiBCVChyKXtyZXR1cm4gciYmci5sZW5ndGg/SWkocixZZSxIcyk6dH1mdW5jdGlvbiBXVChyLG8pe3JldHVybiByJiZyLmxlbmd0aD9JaShyLEh0KG8sMiksSHMpOnR9ZnVuY3Rpb24gRlQocil7cmV0dXJuIExsKHIsWWUpfWZ1bmN0aW9uIGpUKHIsbyl7cmV0dXJuIExsKHIsSHQobywyKSl9ZnVuY3Rpb24gVVQocil7cmV0dXJuIHImJnIubGVuZ3RoP0lpKHIsWWUsWnMpOnR9ZnVuY3Rpb24gelQocixvKXtyZXR1cm4gciYmci5sZW5ndGg/SWkocixIdChvLDIpLFpzKTp0fXZhciAkVD1GaShmdW5jdGlvbihyLG8pe3JldHVybiByKm99LDEpLEdUPXNvKCJyb3VuZCIpLEtUPUZpKGZ1bmN0aW9uKHIsbyl7cmV0dXJuIHItb30sMCk7ZnVuY3Rpb24gSFQocil7cmV0dXJuIHImJnIubGVuZ3RoP0RzKHIsWWUpOjB9ZnVuY3Rpb24gWVQocixvKXtyZXR1cm4gciYmci5sZW5ndGg/RHMocixIdChvLDIpKTowfXJldHVybiBxLmFmdGVyPWRNLHEuYXJ5PXJmLHEuYXNzaWduPXRTLHEuYXNzaWduSW49bWYscS5hc3NpZ25JbldpdGg9UWkscS5hc3NpZ25XaXRoPWVTLHEuYXQ9clMscS5iZWZvcmU9bmYscS5iaW5kPXlvLHEuYmluZEFsbD1hVCxxLmJpbmRLZXk9c2YscS5jYXN0QXJyYXk9UE0scS5jaGFpbj1fdSxxLmNodW5rPU5PLHEuY29tcGFjdD1CTyxxLmNvbmNhdD1XTyxxLmNvbmQ9bFQscS5jb25mb3Jtcz11VCxxLmNvbnN0YW50PVBvLHEuY291bnRCeT1IRSxxLmNyZWF0ZT1uUyxxLmN1cnJ5PW9mLHEuY3VycnlSaWdodD1hZixxLmRlYm91bmNlPWxmLHEuZGVmYXVsdHM9aVMscS5kZWZhdWx0c0RlZXA9c1MscS5kZWZlcj1nTSxxLmRlbGF5PXZNLHEuZGlmZmVyZW5jZT1GTyxxLmRpZmZlcmVuY2VCeT1qTyxxLmRpZmZlcmVuY2VXaXRoPVVPLHEuZHJvcD16TyxxLmRyb3BSaWdodD0kTyxxLmRyb3BSaWdodFdoaWxlPUdPLHEuZHJvcFdoaWxlPUtPLHEuZmlsbD1ITyxxLmZpbHRlcj1WRSxxLmZsYXRNYXA9SkUscS5mbGF0TWFwRGVlcD1RRSxxLmZsYXRNYXBEZXB0aD1rRSxxLmZsYXR0ZW49SnUscS5mbGF0dGVuRGVlcD1ZTyxxLmZsYXR0ZW5EZXB0aD1WTyxxLmZsaXA9cE0scS5mbG93PWNULHEuZmxvd1JpZ2h0PWhULHEuZnJvbVBhaXJzPVhPLHEuZnVuY3Rpb25zPWhTLHEuZnVuY3Rpb25zSW49ZFMscS5ncm91cEJ5PXFFLHEuaW5pdGlhbD1KTyxxLmludGVyc2VjdGlvbj1RTyxxLmludGVyc2VjdGlvbkJ5PWtPLHEuaW50ZXJzZWN0aW9uV2l0aD1xTyxxLmludmVydD12UyxxLmludmVydEJ5PXBTLHEuaW52b2tlTWFwPXRNLHEuaXRlcmF0ZWU9Ym8scS5rZXlCeT1lTSxxLmtleXM9d2UscS5rZXlzSW49SGUscS5tYXA9SGkscS5tYXBLZXlzPXlTLHEubWFwVmFsdWVzPXhTLHEubWF0Y2hlcz1kVCxxLm1hdGNoZXNQcm9wZXJ0eT1nVCxxLm1lbW9pemU9VmkscS5tZXJnZT1PUyxxLm1lcmdlV2l0aD15ZixxLm1ldGhvZD12VCxxLm1ldGhvZE9mPXBULHEubWl4aW49QW8scS5uZWdhdGU9WGkscS5udGhBcmc9eVQscS5vbWl0PUVTLHEub21pdEJ5PU1TLHEub25jZT1tTSxxLm9yZGVyQnk9ck0scS5vdmVyPXhULHEub3ZlckFyZ3M9eU0scS5vdmVyRXZlcnk9T1QscS5vdmVyU29tZT1FVCxxLnBhcnRpYWw9eG8scS5wYXJ0aWFsUmlnaHQ9dWYscS5wYXJ0aXRpb249bk0scS5waWNrPVNTLHEucGlja0J5PXhmLHEucHJvcGVydHk9YmYscS5wcm9wZXJ0eU9mPU1ULHEucHVsbD1yRSxxLnB1bGxBbGw9a3UscS5wdWxsQWxsQnk9bkUscS5wdWxsQWxsV2l0aD1pRSxxLnB1bGxBdD1zRSxxLnJhbmdlPVNULHEucmFuZ2VSaWdodD1UVCxxLnJlYXJnPXhNLHEucmVqZWN0PW9NLHEucmVtb3ZlPW9FLHEucmVzdD1PTSxxLnJldmVyc2U9cG8scS5zYW1wbGVTaXplPWxNLHEuc2V0PVBTLHEuc2V0V2l0aD1iUyxxLnNodWZmbGU9dU0scS5zbGljZT1hRSxxLnNvcnRCeT1oTSxxLnNvcnRlZFVuaXE9Z0UscS5zb3J0ZWRVbmlxQnk9dkUscS5zcGxpdD1KUyxxLnNwcmVhZD1FTSxxLnRhaWw9cEUscS50YWtlPW1FLHEudGFrZVJpZ2h0PXlFLHEudGFrZVJpZ2h0V2hpbGU9eEUscS50YWtlV2hpbGU9T0UscS50YXA9QkUscS50aHJvdHRsZT1NTSxxLnRocnU9S2kscS50b0FycmF5PWdmLHEudG9QYWlycz1PZixxLnRvUGFpcnNJbj1FZixxLnRvUGF0aD1SVCxxLnRvUGxhaW5PYmplY3Q9cGYscS50cmFuc2Zvcm09QVMscS51bmFyeT1TTSxxLnVuaW9uPUVFLHEudW5pb25CeT1NRSxxLnVuaW9uV2l0aD1TRSxxLnVuaXE9VEUscS51bmlxQnk9UEUscS51bmlxV2l0aD1iRSxxLnVuc2V0PUNTLHEudW56aXA9bW8scS51bnppcFdpdGg9cXUscS51cGRhdGU9UlMscS51cGRhdGVXaXRoPUlTLHEudmFsdWVzPUFuLHEudmFsdWVzSW49TFMscS53aXRob3V0PUFFLHEud29yZHM9VGYscS53cmFwPVRNLHEueG9yPUNFLHEueG9yQnk9UkUscS54b3JXaXRoPUlFLHEuemlwPUxFLHEuemlwT2JqZWN0PURFLHEuemlwT2JqZWN0RGVlcD13RSxxLnppcFdpdGg9TkUscS5lbnRyaWVzPU9mLHEuZW50cmllc0luPUVmLHEuZXh0ZW5kPW1mLHEuZXh0ZW5kV2l0aD1RaSxBbyhxLHEpLHEuYWRkPUxULHEuYXR0ZW1wdD1QZixxLmNhbWVsQ2FzZT1CUyxxLmNhcGl0YWxpemU9TWYscS5jZWlsPURULHEuY2xhbXA9RFMscS5jbG9uZT1iTSxxLmNsb25lRGVlcD1DTSxxLmNsb25lRGVlcFdpdGg9Uk0scS5jbG9uZVdpdGg9QU0scS5jb25mb3Jtc1RvPUlNLHEuZGVidXJyPVNmLHEuZGVmYXVsdFRvPWZULHEuZGl2aWRlPXdULHEuZW5kc1dpdGg9V1MscS5lcT1jcixxLmVzY2FwZT1GUyxxLmVzY2FwZVJlZ0V4cD1qUyxxLmV2ZXJ5PVlFLHEuZmluZD1YRSxxLmZpbmRJbmRleD1YdSxxLmZpbmRLZXk9b1MscS5maW5kTGFzdD1aRSxxLmZpbmRMYXN0SW5kZXg9WnUscS5maW5kTGFzdEtleT1hUyxxLmZsb29yPU5ULHEuZm9yRWFjaD10ZixxLmZvckVhY2hSaWdodD1lZixxLmZvckluPWxTLHEuZm9ySW5SaWdodD11UyxxLmZvck93bj1mUyxxLmZvck93blJpZ2h0PWNTLHEuZ2V0PU1vLHEuZ3Q9TE0scS5ndGU9RE0scS5oYXM9Z1MscS5oYXNJbj1TbyxxLmhlYWQ9UXUscS5pZGVudGl0eT1ZZSxxLmluY2x1ZGVzPV9FLHEuaW5kZXhPZj1aTyxxLmluUmFuZ2U9d1MscS5pbnZva2U9bVMscS5pc0FyZ3VtZW50cz10bixxLmlzQXJyYXk9a3QscS5pc0FycmF5QnVmZmVyPXdNLHEuaXNBcnJheUxpa2U9S2UscS5pc0FycmF5TGlrZU9iamVjdD1BZSxxLmlzQm9vbGVhbj1OTSxxLmlzQnVmZmVyPXpyLHEuaXNEYXRlPUJNLHEuaXNFbGVtZW50PVdNLHEuaXNFbXB0eT1GTSxxLmlzRXF1YWw9ak0scS5pc0VxdWFsV2l0aD1VTSxxLmlzRXJyb3I9T28scS5pc0Zpbml0ZT16TSxxLmlzRnVuY3Rpb249UHIscS5pc0ludGVnZXI9ZmYscS5pc0xlbmd0aD1aaSxxLmlzTWFwPWNmLHEuaXNNYXRjaD0kTSxxLmlzTWF0Y2hXaXRoPUdNLHEuaXNOYU49S00scS5pc05hdGl2ZT1ITSxxLmlzTmlsPVZNLHEuaXNOdWxsPVlNLHEuaXNOdW1iZXI9aGYscS5pc09iamVjdD1NZSxxLmlzT2JqZWN0TGlrZT1QZSxxLmlzUGxhaW5PYmplY3Q9WW4scS5pc1JlZ0V4cD1FbyxxLmlzU2FmZUludGVnZXI9WE0scS5pc1NldD1kZixxLmlzU3RyaW5nPUppLHEuaXNTeW1ib2w9UWUscS5pc1R5cGVkQXJyYXk9Ym4scS5pc1VuZGVmaW5lZD1aTSxxLmlzV2Vha01hcD1KTSxxLmlzV2Vha1NldD1RTSxxLmpvaW49X08scS5rZWJhYkNhc2U9VVMscS5sYXN0PXNyLHEubGFzdEluZGV4T2Y9dEUscS5sb3dlckNhc2U9elMscS5sb3dlckZpcnN0PSRTLHEubHQ9a00scS5sdGU9cU0scS5tYXg9QlQscS5tYXhCeT1XVCxxLm1lYW49RlQscS5tZWFuQnk9alQscS5taW49VVQscS5taW5CeT16VCxxLnN0dWJBcnJheT1SbyxxLnN0dWJGYWxzZT1JbyxxLnN0dWJPYmplY3Q9UFQscS5zdHViU3RyaW5nPWJULHEuc3R1YlRydWU9QVQscS5tdWx0aXBseT0kVCxxLm50aD1lRSxxLm5vQ29uZmxpY3Q9bVQscS5ub29wPUNvLHEubm93PVlpLHEucGFkPUdTLHEucGFkRW5kPUtTLHEucGFkU3RhcnQ9SFMscS5wYXJzZUludD1ZUyxxLnJhbmRvbT1OUyxxLnJlZHVjZT1pTSxxLnJlZHVjZVJpZ2h0PXNNLHEucmVwZWF0PVZTLHEucmVwbGFjZT1YUyxxLnJlc3VsdD1UUyxxLnJvdW5kPUdULHEucnVuSW5Db250ZXh0PXZ0LHEuc2FtcGxlPWFNLHEuc2l6ZT1mTSxxLnNuYWtlQ2FzZT1aUyxxLnNvbWU9Y00scS5zb3J0ZWRJbmRleD1sRSxxLnNvcnRlZEluZGV4Qnk9dUUscS5zb3J0ZWRJbmRleE9mPWZFLHEuc29ydGVkTGFzdEluZGV4PWNFLHEuc29ydGVkTGFzdEluZGV4Qnk9aEUscS5zb3J0ZWRMYXN0SW5kZXhPZj1kRSxxLnN0YXJ0Q2FzZT1RUyxxLnN0YXJ0c1dpdGg9a1MscS5zdWJ0cmFjdD1LVCxxLnN1bT1IVCxxLnN1bUJ5PVlULHEudGVtcGxhdGU9cVMscS50aW1lcz1DVCxxLnRvRmluaXRlPWJyLHEudG9JbnRlZ2VyPXF0LHEudG9MZW5ndGg9dmYscS50b0xvd2VyPV9TLHEudG9OdW1iZXI9b3IscS50b1NhZmVJbnRlZ2VyPV9NLHEudG9TdHJpbmc9dWUscS50b1VwcGVyPXRULHEudHJpbT1lVCxxLnRyaW1FbmQ9clQscS50cmltU3RhcnQ9blQscS50cnVuY2F0ZT1pVCxxLnVuZXNjYXBlPXNULHEudW5pcXVlSWQ9SVQscS51cHBlckNhc2U9b1QscS51cHBlckZpcnN0PVRvLHEuZWFjaD10ZixxLmVhY2hSaWdodD1lZixxLmZpcnN0PVF1LEFvKHEsZnVuY3Rpb24oKXt2YXIgcj17fTtyZXR1cm4gZ3IocSxmdW5jdGlvbihvLEMpe2ZlLmNhbGwocS5wcm90b3R5cGUsQyl8fChyW0NdPW8pfSkscn0oKSx7Y2hhaW46ITF9KSxxLlZFUlNJT049bix0cihbImJpbmQiLCJiaW5kS2V5IiwiY3VycnkiLCJjdXJyeVJpZ2h0IiwicGFydGlhbCIsInBhcnRpYWxSaWdodCJdLGZ1bmN0aW9uKHIpe3Fbcl0ucGxhY2Vob2xkZXI9cX0pLHRyKFsiZHJvcCIsInRha2UiXSxmdW5jdGlvbihyLG8pe3JlLnByb3RvdHlwZVtyXT1mdW5jdGlvbihDKXtDPUM9PT10PzE6RGUocXQoQyksMCk7dmFyIHo9dGhpcy5fX2ZpbHRlcmVkX18mJiFvP25ldyByZSh0aGlzKTp0aGlzLmNsb25lKCk7cmV0dXJuIHouX19maWx0ZXJlZF9fP3ouX190YWtlQ291bnRfXz1XZShDLHouX190YWtlQ291bnRfXyk6ei5fX3ZpZXdzX18ucHVzaCh7c2l6ZTpXZShDLFkpLHR5cGU6cisoei5fX2Rpcl9fPDA/IlJpZ2h0IjoiIil9KSx6fSxyZS5wcm90b3R5cGVbcisiUmlnaHQiXT1mdW5jdGlvbihDKXtyZXR1cm4gdGhpcy5yZXZlcnNlKClbcl0oQykucmV2ZXJzZSgpfX0pLHRyKFsiZmlsdGVyIiwibWFwIiwidGFrZVdoaWxlIl0sZnVuY3Rpb24ocixvKXt2YXIgQz1vKzEsej1DPT1JfHxDPT1WO3JlLnByb3RvdHlwZVtyXT1mdW5jdGlvbihYKXt2YXIgZXQ9dGhpcy5jbG9uZSgpO3JldHVybiBldC5fX2l0ZXJhdGVlc19fLnB1c2goe2l0ZXJhdGVlOkh0KFgsMyksdHlwZTpDfSksZXQuX19maWx0ZXJlZF9fPWV0Ll9fZmlsdGVyZWRfX3x8eixldH19KSx0cihbImhlYWQiLCJsYXN0Il0sZnVuY3Rpb24ocixvKXt2YXIgQz0idGFrZSIrKG8/IlJpZ2h0IjoiIik7cmUucHJvdG90eXBlW3JdPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXNbQ10oMSkudmFsdWUoKVswXX19KSx0cihbImluaXRpYWwiLCJ0YWlsIl0sZnVuY3Rpb24ocixvKXt2YXIgQz0iZHJvcCIrKG8/IiI6IlJpZ2h0Iik7cmUucHJvdG90eXBlW3JdPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX19maWx0ZXJlZF9fP25ldyByZSh0aGlzKTp0aGlzW0NdKDEpfX0pLHJlLnByb3RvdHlwZS5jb21wYWN0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZmlsdGVyKFllKX0scmUucHJvdG90eXBlLmZpbmQ9ZnVuY3Rpb24ocil7cmV0dXJuIHRoaXMuZmlsdGVyKHIpLmhlYWQoKX0scmUucHJvdG90eXBlLmZpbmRMYXN0PWZ1bmN0aW9uKHIpe3JldHVybiB0aGlzLnJldmVyc2UoKS5maW5kKHIpfSxyZS5wcm90b3R5cGUuaW52b2tlTWFwPXRlKGZ1bmN0aW9uKHIsbyl7cmV0dXJuIHR5cGVvZiByPT0iZnVuY3Rpb24iP25ldyByZSh0aGlzKTp0aGlzLm1hcChmdW5jdGlvbihDKXtyZXR1cm4gVW4oQyxyLG8pfSl9KSxyZS5wcm90b3R5cGUucmVqZWN0PWZ1bmN0aW9uKHIpe3JldHVybiB0aGlzLmZpbHRlcihYaShIdChyKSkpfSxyZS5wcm90b3R5cGUuc2xpY2U9ZnVuY3Rpb24ocixvKXtyPXF0KHIpO3ZhciBDPXRoaXM7cmV0dXJuIEMuX19maWx0ZXJlZF9fJiYocj4wfHxvPDApP25ldyByZShDKToocjwwP0M9Qy50YWtlUmlnaHQoLXIpOnImJihDPUMuZHJvcChyKSksbyE9PXQmJihvPXF0KG8pLEM9bzwwP0MuZHJvcFJpZ2h0KC1vKTpDLnRha2Uoby1yKSksQyl9LHJlLnByb3RvdHlwZS50YWtlUmlnaHRXaGlsZT1mdW5jdGlvbihyKXtyZXR1cm4gdGhpcy5yZXZlcnNlKCkudGFrZVdoaWxlKHIpLnJldmVyc2UoKX0scmUucHJvdG90eXBlLnRvQXJyYXk9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50YWtlKFkpfSxncihyZS5wcm90b3R5cGUsZnVuY3Rpb24ocixvKXt2YXIgQz0vXig/OmZpbHRlcnxmaW5kfG1hcHxyZWplY3QpfFdoaWxlJC8udGVzdChvKSx6PS9eKD86aGVhZHxsYXN0KSQvLnRlc3QobyksWD1xW3o/InRha2UiKyhvPT0ibGFzdCI/IlJpZ2h0IjoiIik6b10sZXQ9enx8L15maW5kLy50ZXN0KG8pO1gmJihxLnByb3RvdHlwZVtvXT1mdW5jdGlvbigpe3ZhciBsdD10aGlzLl9fd3JhcHBlZF9fLGZ0PXo/WzFdOmFyZ3VtZW50cyx5dD1sdCBpbnN0YW5jZW9mIHJlLFJ0PWZ0WzBdLEl0PXl0fHxrdChsdCksd3Q9ZnVuY3Rpb24oZWUpe3ZhciBuZT1YLmFwcGx5KHEsd3IoW2VlXSxmdCkpO3JldHVybiB6JiZXdD9uZVswXTpuZX07SXQmJkMmJnR5cGVvZiBSdD09ImZ1bmN0aW9uIiYmUnQubGVuZ3RoIT0xJiYoeXQ9SXQ9ITEpO3ZhciBXdD10aGlzLl9fY2hhaW5fXyxVdD0hIXRoaXMuX19hY3Rpb25zX18ubGVuZ3RoLFh0PWV0JiYhV3QsX3Q9eXQmJiFVdDtpZighZXQmJkl0KXtsdD1fdD9sdDpuZXcgcmUodGhpcyk7dmFyIFp0PXIuYXBwbHkobHQsZnQpO3JldHVybiBadC5fX2FjdGlvbnNfXy5wdXNoKHtmdW5jOktpLGFyZ3M6W3d0XSx0aGlzQXJnOnR9KSxuZXcgcnIoWnQsV3QpfXJldHVybiBYdCYmX3Q/ci5hcHBseSh0aGlzLGZ0KTooWnQ9dGhpcy50aHJ1KHd0KSxYdD96P1p0LnZhbHVlKClbMF06WnQudmFsdWUoKTpadCl9KX0pLHRyKFsicG9wIiwicHVzaCIsInNoaWZ0Iiwic29ydCIsInNwbGljZSIsInVuc2hpZnQiXSxmdW5jdGlvbihyKXt2YXIgbz12aVtyXSxDPS9eKD86cHVzaHxzb3J0fHVuc2hpZnQpJC8udGVzdChyKT8idGFwIjoidGhydSIsej0vXig/OnBvcHxzaGlmdCkkLy50ZXN0KHIpO3EucHJvdG90eXBlW3JdPWZ1bmN0aW9uKCl7dmFyIFg9YXJndW1lbnRzO2lmKHomJiF0aGlzLl9fY2hhaW5fXyl7dmFyIGV0PXRoaXMudmFsdWUoKTtyZXR1cm4gby5hcHBseShrdChldCk/ZXQ6W10sWCl9cmV0dXJuIHRoaXNbQ10oZnVuY3Rpb24obHQpe3JldHVybiBvLmFwcGx5KGt0KGx0KT9sdDpbXSxYKX0pfX0pLGdyKHJlLnByb3RvdHlwZSxmdW5jdGlvbihyLG8pe3ZhciBDPXFbb107aWYoQyl7dmFyIHo9Qy5uYW1lKyIiO2ZlLmNhbGwoRW4seil8fChFblt6XT1bXSksRW5bel0ucHVzaCh7bmFtZTpvLGZ1bmM6Q30pfX0pLEVuW1dpKHQsUykubmFtZV09W3tuYW1lOiJ3cmFwcGVyIixmdW5jOnR9XSxyZS5wcm90b3R5cGUuY2xvbmU9c3gscmUucHJvdG90eXBlLnJldmVyc2U9b3gscmUucHJvdG90eXBlLnZhbHVlPWF4LHEucHJvdG90eXBlLmF0PVdFLHEucHJvdG90eXBlLmNoYWluPUZFLHEucHJvdG90eXBlLmNvbW1pdD1qRSxxLnByb3RvdHlwZS5uZXh0PVVFLHEucHJvdG90eXBlLnBsYW50PSRFLHEucHJvdG90eXBlLnJldmVyc2U9R0UscS5wcm90b3R5cGUudG9KU09OPXEucHJvdG90eXBlLnZhbHVlT2Y9cS5wcm90b3R5cGUudmFsdWU9S0UscS5wcm90b3R5cGUuZmlyc3Q9cS5wcm90b3R5cGUuaGVhZCxEbiYmKHEucHJvdG90eXBlW0RuXT16RSkscX0seW49ajIoKTtWcj8oKFZyLmV4cG9ydHM9eW4pLl89eW4sUHMuXz15bik6TmUuXz15bn0pLmNhbGwobXIpfShpaSxpaS5leHBvcnRzKTt2YXIgQmE9aWkuZXhwb3J0cztjbGFzcyBEdHtjb25zdHJ1Y3RvcihlKXtPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywic3luY1VuaXRUaW1lIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6MWUzfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInZOb2RlcyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJkcmF3TGF5ZXIiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiZnVsbExheWVyIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIndvcmtJZCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pO2NvbnN0e3ZOb2Rlczp0LGZ1bGxMYXllcjpuLGRyYXdMYXllcjppfT1lO3RoaXMudk5vZGVzPXQsdGhpcy5mdWxsTGF5ZXI9bix0aGlzLmRyYXdMYXllcj1pfXNldFdvcmtJZChlKXt0aGlzLndvcmtJZD1lfWdldFdvcmtJZCgpe3JldHVybiB0aGlzLndvcmtJZH1nZXRXb3JrT3B0aW9ucygpe3JldHVybiB0aGlzLndvcmtPcHRpb25zfXNldFdvcmtPcHRpb25zKGUpe3RoaXMud29ya09wdGlvbnM9ZSx0aGlzLnN5bmNVbml0VGltZT1lLnN5bmNVbml0VGltZXx8dGhpcy5zeW5jVW5pdFRpbWV9dXBkYXRhT3B0U2VydmljZShlKXt2YXIgaTtsZXQgdDtjb25zdCBuPShpPXRoaXMud29ya0lkKT09bnVsbD92b2lkIDA6aS50b1N0cmluZygpO2lmKG4mJmUpe2NvbnN0IGY9dGhpcy5mdWxsTGF5ZXIuZ2V0RWxlbWVudHNCeU5hbWUobil8fHRoaXMuZHJhd0xheWVyJiZ0aGlzLmRyYXdMYXllci5nZXRFbGVtZW50c0J5TmFtZShuKXx8W107aWYoZi5sZW5ndGghPT0xKXJldHVybjtjb25zdCBoPWZbMF0se3Bvczp1LHpJbmRleDphLHNjYWxlOmQsYW5nbGU6RSx0cmFuc2xhdGU6cH09ZSxPPXt9O3R5cGVvZiBhPT0ibnVtYmVyIiYmKE8uekluZGV4PWEpLHUmJihPLnBvcz1bdVswXSx1WzFdXSksZCYmKE8uc2NhbGU9ZCksRSYmKE8ucm90YXRlPUUpLHAmJihPLnRyYW5zbGF0ZT1wKSxoLmF0dHIoTyk7Y29uc3QgbT1oPT1udWxsP3ZvaWQgMDpoLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO3JldHVybiBtJiYodD0kdCh0LHt4Ok1hdGguZmxvb3IobS54LUR0LlNhZmVCb3JkZXJQYWRkaW5nKSx5Ok1hdGguZmxvb3IobS55LUR0LlNhZmVCb3JkZXJQYWRkaW5nKSx3Ok1hdGguZmxvb3IobS53aWR0aCtEdC5TYWZlQm9yZGVyUGFkZGluZyoyKSxoOk1hdGguZmxvb3IobS5oZWlnaHQrRHQuU2FmZUJvcmRlclBhZGRpbmcqMil9KSksdGhpcy52Tm9kZXMuc2V0SW5mbyhuLHtyZWN0OnQsY2VudGVyUG9zOnV9KSx0fX1zdGF0aWMgdXBkYXRlTm9kZU9wdChlKXtjb25zdHtub2RlOnQsb3B0Om4sdk5vZGVzOmksd2lsbFNlcmlhbGl6ZURhdGE6Zix0YXJnZXROb2RlOmh9PWUse3pJbmRleDp1LHRyYW5zbGF0ZTphLGFuZ2xlOmQsYm94OkUsYm94U2NhbGU6cCxib3hUcmFuc2xhdGU6T309bjtsZXQgbTtjb25zdCBiPWgmJkJhLmNsb25lRGVlcChoKXx8aS5nZXQodC5uYW1lKTtpZighYilyZXR1cm47dSYmKHQuc2V0QXR0cmlidXRlKCJ6SW5kZXgiLHUpLGIub3B0LnpJbmRleD11KTtjb25zdCBNPXQucGFyZW50O2lmKE0pe2lmKEUmJk8mJnApe2NvbnN0e3JlY3Q6eX09YixTPVtdO2ZvcihsZXQgQT0wO0E8Yi5vcC5sZW5ndGg7QSs9MylTLnB1c2gobmV3IEZ0KGIub3BbQV0sYi5vcFtBKzFdLGIub3BbQSsyXSkpO2NvbnN0IHM9eGUoUyksYz1bcy53Kk0ud29ybGRTY2FsaW5nWzBdLHMuaCpNLndvcmxkU2NhbGluZ1swXV0sbD1beS53LWNbMF0seS5oLWNbMV1dLHY9Wyh5LncqcFswXS1sWzBdKS9jWzBdLCh5LmgqcFsxXS1sWzFdKS9jWzFdXSxUPVtPWzBdL00ud29ybGRTY2FsaW5nWzBdLE9bMV0vTS53b3JsZFNjYWxpbmdbMV1dLFI9Yi5vcC5tYXAoKEEsdyk9Pntjb25zdCBCPXclMztyZXR1cm4gQj09PTA/QStUWzBdOkI9PT0xP0ErVFsxXTpBfSksTD1bYi5jZW50ZXJQb3NbMF0rVFswXSxiLmNlbnRlclBvc1sxXStUWzFdXTtjbShSLEwsdik7Y29uc3QgTj1bXTtmb3IobGV0IEE9MDtBPFIubGVuZ3RoO0ErPTMpTi5wdXNoKG5ldyBGdChSW0FdLFJbQSsxXSxSW0ErMl0pKTtiLm9wPVIsYi5jZW50ZXJQb3M9TH1lbHNlIGlmKGEpe2NvbnN0IHk9W2FbMF0vTS53b3JsZFNjYWxpbmdbMF0sYVsxXS9NLndvcmxkU2NhbGluZ1sxXV07dC5zZXRBdHRyaWJ1dGUoInRyYW5zbGF0ZSIseSksYi5vcHQudHJhbnNsYXRlPXksaCYmKG09TGEoYi5yZWN0LGEpLGIucmVjdD1tKX1lbHNlIE5hKGQpJiYodC5zZXRBdHRyaWJ1dGUoInJvdGF0ZSIsZCksYi5vcHQucm90YXRlPWQsaCYmKG09bG0oYi5yZWN0LGQpLGIucmVjdD1tKSk7aWYoZil7aWYoYSl7Y29uc3QgeT1bYVswXS9NLndvcmxkU2NhbGluZ1swXSxhWzFdL00ud29ybGRTY2FsaW5nWzFdXSxTPWIub3AubWFwKChzLGMpPT57Y29uc3QgbD1jJTM7cmV0dXJuIGw9PT0wP3MreVswXTpsPT09MT9zK3lbMV06c30pO2Iub3A9UyxiLmNlbnRlclBvcz1bYi5jZW50ZXJQb3NbMF0reVswXSxiLmNlbnRlclBvc1sxXSt5WzFdXSxiIT1udWxsJiZiLm9wdCYmKGIub3B0LnRyYW5zbGF0ZT12b2lkIDApfWVsc2UgaWYoTmEoZCkpe2NvbnN0IHk9Yi5vcDtmbSh5LGIuY2VudGVyUG9zLGQpLGIub3A9eSxiIT1udWxsJiZiLm9wdCYmKGIub3B0LnJvdGF0ZT12b2lkIDApfX1iJiZpLnNldEluZm8odC5uYW1lLGIpfX1zdGF0aWMgZ2V0Q2VudGVyUG9zKGUsdCl7Y29uc3R7d29ybGRQb3NpdGlvbjpuLHdvcmxkU2NhbGluZzppfT10O3JldHVyblsoZS54K2Uudy8yLW5bMF0pL2lbMF0sKGUueStlLmgvMi1uWzFdKS9pWzFdXX1zdGF0aWMgZ2V0UmVjdEZyb21MYXllcihlLHQpe2NvbnN0IG49ZS5nZXRFbGVtZW50c0J5TmFtZSh0KVswXTtpZihuKXtjb25zdCBpPW4uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7cmV0dXJue3g6TWF0aC5mbG9vcihpLngtRHQuU2FmZUJvcmRlclBhZGRpbmcpLHk6TWF0aC5mbG9vcihpLnktRHQuU2FmZUJvcmRlclBhZGRpbmcpLHc6TWF0aC5mbG9vcihpLndpZHRoK0R0LlNhZmVCb3JkZXJQYWRkaW5nKjIpLGg6TWF0aC5mbG9vcihpLmhlaWdodCtEdC5TYWZlQm9yZGVyUGFkZGluZyoyKX19fX1PYmplY3QuZGVmaW5lUHJvcGVydHkoRHQsIlNhZmVCb3JkZXJQYWRkaW5nIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6MTB9KTt2YXIgbGU9ZnVuY3Rpb24oZyl7dmFyIGU9e307ZnVuY3Rpb24gdChuKXtpZihlW25dKXJldHVybiBlW25dLmV4cG9ydHM7dmFyIGk9ZVtuXT17aTpuLGw6ITEsZXhwb3J0czp7fX07cmV0dXJuIGdbbl0uY2FsbChpLmV4cG9ydHMsaSxpLmV4cG9ydHMsdCksaS5sPSEwLGkuZXhwb3J0c31yZXR1cm4gdC5tPWcsdC5jPWUsdC5kPWZ1bmN0aW9uKG4saSxmKXt0Lm8obixpKXx8T2JqZWN0LmRlZmluZVByb3BlcnR5KG4saSx7ZW51bWVyYWJsZTohMCxnZXQ6Zn0pfSx0LnI9ZnVuY3Rpb24obil7dHlwZW9mIFN5bWJvbDwidSImJlN5bWJvbC50b1N0cmluZ1RhZyYmT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sU3ltYm9sLnRvU3RyaW5nVGFnLHt2YWx1ZToiTW9kdWxlIn0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KX0sdC50PWZ1bmN0aW9uKG4saSl7aWYoaSYxJiYobj10KG4pKSxpJjh8fGkmNCYmdHlwZW9mIG49PSJvYmplY3QiJiZuJiZuLl9fZXNNb2R1bGUpcmV0dXJuIG47dmFyIGY9T2JqZWN0LmNyZWF0ZShudWxsKTtpZih0LnIoZiksT2JqZWN0LmRlZmluZVByb3BlcnR5KGYsImRlZmF1bHQiLHtlbnVtZXJhYmxlOiEwLHZhbHVlOm59KSxpJjImJnR5cGVvZiBuIT0ic3RyaW5nIilmb3IodmFyIGggaW4gbil0LmQoZixoLChmdW5jdGlvbih1KXtyZXR1cm4gblt1XX0pLmJpbmQobnVsbCxoKSk7cmV0dXJuIGZ9LHQubj1mdW5jdGlvbihuKXt2YXIgaT1uJiZuLl9fZXNNb2R1bGU/ZnVuY3Rpb24oKXtyZXR1cm4gbi5kZWZhdWx0fTpmdW5jdGlvbigpe3JldHVybiBufTtyZXR1cm4gdC5kKGksImEiLGkpLGl9LHQubz1mdW5jdGlvbihuLGkpe3JldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobixpKX0sdC5wPSIvanMvIix0KHQucz0wKX0oW2Z1bmN0aW9uKGcsZSx0KXt0LnIoZSksdC5kKGUsInZlcnNpb24iLGZ1bmN0aW9uKCl7cmV0dXJuIEp9KSx0LmQoZSwiaGVscGVycyIsZnVuY3Rpb24oKXtyZXR1cm4gan0pLHQuZChlLCJjcmVhdGVFbGVtZW50IixmdW5jdGlvbigpe3JldHVybiBCfSksdC5kKGUsImlzU3ByaXRlTm9kZSIsZnVuY3Rpb24oKXtyZXR1cm4gRH0pLHQuZChlLCJyZWdpc3Rlck5vZGUiLGZ1bmN0aW9uKCl7cmV0dXJuIEl9KTt2YXIgbj10KDEyKTt0LmQoZSwiRU5WIixmdW5jdGlvbigpe3JldHVybiBuLkVOVn0pO3ZhciBpPXQoNjgpO3QuZChlLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLGZ1bmN0aW9uKCl7cmV0dXJuIGkucmVxdWVzdEFuaW1hdGlvbkZyYW1lfSksdC5kKGUsImNhbmNlbEFuaW1hdGlvbkZyYW1lIixmdW5jdGlvbigpe3JldHVybiBpLmNhbmNlbEFuaW1hdGlvbkZyYW1lfSk7dmFyIGY9dCg3MCk7dC5kKGUsIk5vZGUiLGZ1bmN0aW9uKCl7cmV0dXJuIGYuZGVmYXVsdH0pO3ZhciBoPXQoMjE3KTt0LmQoZSwiQ2xvdWQiLGZ1bmN0aW9uKCl7cmV0dXJuIGguZGVmYXVsdH0pO3ZhciB1PXQoMjE5KTt0LmQoZSwiQmxvY2siLGZ1bmN0aW9uKCl7cmV0dXJuIHUuZGVmYXVsdH0pO3ZhciBhPXQoMjI0KTt0LmQoZSwiU3ByaXRlIixmdW5jdGlvbigpe3JldHVybiBhLmRlZmF1bHR9KTt2YXIgZD10KDIyNik7dC5kKGUsIlBhdGgiLGZ1bmN0aW9uKCl7cmV0dXJuIGQuZGVmYXVsdH0pO3ZhciBFPXQoMjI5KTt0LmQoZSwiUmVjdCIsZnVuY3Rpb24oKXtyZXR1cm4gRS5kZWZhdWx0fSk7dmFyIHA9dCgyMzEpO3QuZChlLCJUcmlhbmdsZSIsZnVuY3Rpb24oKXtyZXR1cm4gcC5kZWZhdWx0fSk7dmFyIE89dCgyMzYpO3QuZChlLCJQYXJhbGxlbCIsZnVuY3Rpb24oKXtyZXR1cm4gTy5kZWZhdWx0fSk7dmFyIG09dCgyMzgpO3QuZChlLCJSZWd1bGFyIixmdW5jdGlvbigpe3JldHVybiBtLmRlZmF1bHR9KTt2YXIgYj10KDI0MCk7dC5kKGUsIlN0YXIiLGZ1bmN0aW9uKCl7cmV0dXJuIGIuZGVmYXVsdH0pO3ZhciBNPXQoMjQyKTt0LmQoZSwiRWxsaXBzZSIsZnVuY3Rpb24oKXtyZXR1cm4gTS5kZWZhdWx0fSk7dmFyIHk9dCgyNDQpO3QuZChlLCJBcmMiLGZ1bmN0aW9uKCl7cmV0dXJuIHkuZGVmYXVsdH0pO3ZhciBTPXQoMjQ2KTt0LmQoZSwiUmluZyIsZnVuY3Rpb24oKXtyZXR1cm4gUy5kZWZhdWx0fSk7dmFyIHM9dCgyMzIpO3QuZChlLCJQb2x5bGluZSIsZnVuY3Rpb24oKXtyZXR1cm4gcy5kZWZhdWx0fSk7dmFyIGM9dCgyNDgpO3QuZChlLCJMYWJlbCIsZnVuY3Rpb24oKXtyZXR1cm4gYy5kZWZhdWx0fSk7dmFyIGw9dCgyNTApO3QuZChlLCJHcm91cCIsZnVuY3Rpb24oKXtyZXR1cm4gbC5kZWZhdWx0fSk7dmFyIHY9dCgyODYpO3QuZChlLCJMYXllciIsZnVuY3Rpb24oKXtyZXR1cm4gdi5kZWZhdWx0fSk7dmFyIFQ9dCgyODcpO3QuZChlLCJTcHJpdGVTdmciLGZ1bmN0aW9uKCl7cmV0dXJuIFQuZGVmYXVsdH0pO3ZhciBSPXQoMjg5KTt0LmQoZSwiTGF5ZXJXb3JrZXIiLGZ1bmN0aW9uKCl7cmV0dXJuIFIuZGVmYXVsdH0pO3ZhciBMPXQoMjkwKTt0LmQoZSwiU2NlbmUiLGZ1bmN0aW9uKCl7cmV0dXJuIEwuZGVmYXVsdH0pO3ZhciBOPXQoMjEzKSxBPXQoMjIxKTt0LmQoZSwiQ29sb3IiLGZ1bmN0aW9uKCl7cmV0dXJuIEEuQ29sb3J9KSx0LmQoZSwiR3JhZGllbnQiLGZ1bmN0aW9uKCl7cmV0dXJuIEEuR3JhZGllbnR9KTt2YXIgdz10KDcyKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3QgQj1OLmRlZmF1bHQuY3JlYXRlRWxlbWVudCxEPU4uZGVmYXVsdC5pc1Nwcml0ZU5vZGUsST1OLmRlZmF1bHQucmVnaXN0ZXJOb2RlLGo9e3BhcnNlQ29sb3I6QS5wYXJzZUNvbG9yLHNpemVUb1BpeGVsOncuc2l6ZVRvUGl4ZWwsdG9BcnJheTp3LnRvQXJyYXksdG9TdHJpbmc6dy50b1N0cmluZyx0b051bWJlcjp3LnRvTnVtYmVyfTtsZXQgVjtWPSIzLjguMyI7Y29uc3QgSj1WfSxmdW5jdGlvbihnLGUsdCl7dC5yKGUpO3ZhciBuPXQoMik7dC5kKGUsImdsTWF0cml4IixmdW5jdGlvbigpe3JldHVybiBufSk7dmFyIGk9dCgzKTt0LmQoZSwibWF0MiIsZnVuY3Rpb24oKXtyZXR1cm4gaX0pO3ZhciBmPXQoNCk7dC5kKGUsIm1hdDJkIixmdW5jdGlvbigpe3JldHVybiBmfSk7dmFyIGg9dCg1KTt0LmQoZSwibWF0MyIsZnVuY3Rpb24oKXtyZXR1cm4gaH0pO3ZhciB1PXQoNik7dC5kKGUsIm1hdDQiLGZ1bmN0aW9uKCl7cmV0dXJuIHV9KTt2YXIgYT10KDcpO3QuZChlLCJxdWF0IixmdW5jdGlvbigpe3JldHVybiBhfSk7dmFyIGQ9dCgxMCk7dC5kKGUsInF1YXQyIixmdW5jdGlvbigpe3JldHVybiBkfSk7dmFyIEU9dCgxMSk7dC5kKGUsInZlYzIiLGZ1bmN0aW9uKCl7cmV0dXJuIEV9KTt2YXIgcD10KDgpO3QuZChlLCJ2ZWMzIixmdW5jdGlvbigpe3JldHVybiBwfSk7dmFyIE89dCg5KTt0LmQoZSwidmVjNCIsZnVuY3Rpb24oKXtyZXR1cm4gT30pfSxmdW5jdGlvbihnLGUsdCl7dC5yKGUpLHQuZChlLCJFUFNJTE9OIixmdW5jdGlvbigpe3JldHVybiBufSksdC5kKGUsIkFSUkFZX1RZUEUiLGZ1bmN0aW9uKCl7cmV0dXJuIGl9KSx0LmQoZSwiUkFORE9NIixmdW5jdGlvbigpe3JldHVybiBmfSksdC5kKGUsInNldE1hdHJpeEFycmF5VHlwZSIsZnVuY3Rpb24oKXtyZXR1cm4gaH0pLHQuZChlLCJ0b1JhZGlhbiIsZnVuY3Rpb24oKXtyZXR1cm4gYX0pLHQuZChlLCJlcXVhbHMiLGZ1bmN0aW9uKCl7cmV0dXJuIGR9KTt2YXIgbj0xZS02LGk9dHlwZW9mIEZsb2F0MzJBcnJheTwidSI/RmxvYXQzMkFycmF5OkFycmF5LGY9TWF0aC5yYW5kb207ZnVuY3Rpb24gaChFKXtpPUV9dmFyIHU9TWF0aC5QSS8xODA7ZnVuY3Rpb24gYShFKXtyZXR1cm4gRSp1fWZ1bmN0aW9uIGQoRSxwKXtyZXR1cm4gTWF0aC5hYnMoRS1wKTw9bipNYXRoLm1heCgxLE1hdGguYWJzKEUpLE1hdGguYWJzKHApKX1NYXRoLmh5cG90fHwoTWF0aC5oeXBvdD1mdW5jdGlvbigpe2Zvcih2YXIgRT0wLHA9YXJndW1lbnRzLmxlbmd0aDtwLS07KUUrPWFyZ3VtZW50c1twXSphcmd1bWVudHNbcF07cmV0dXJuIE1hdGguc3FydChFKX0pfSxmdW5jdGlvbihnLGUsdCl7dC5yKGUpLHQuZChlLCJjcmVhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIGl9KSx0LmQoZSwiY2xvbmUiLGZ1bmN0aW9uKCl7cmV0dXJuIGZ9KSx0LmQoZSwiY29weSIsZnVuY3Rpb24oKXtyZXR1cm4gaH0pLHQuZChlLCJpZGVudGl0eSIsZnVuY3Rpb24oKXtyZXR1cm4gdX0pLHQuZChlLCJmcm9tVmFsdWVzIixmdW5jdGlvbigpe3JldHVybiBhfSksdC5kKGUsInNldCIsZnVuY3Rpb24oKXtyZXR1cm4gZH0pLHQuZChlLCJ0cmFuc3Bvc2UiLGZ1bmN0aW9uKCl7cmV0dXJuIEV9KSx0LmQoZSwiaW52ZXJ0IixmdW5jdGlvbigpe3JldHVybiBwfSksdC5kKGUsImFkam9pbnQiLGZ1bmN0aW9uKCl7cmV0dXJuIE99KSx0LmQoZSwiZGV0ZXJtaW5hbnQiLGZ1bmN0aW9uKCl7cmV0dXJuIG19KSx0LmQoZSwibXVsdGlwbHkiLGZ1bmN0aW9uKCl7cmV0dXJuIGJ9KSx0LmQoZSwicm90YXRlIixmdW5jdGlvbigpe3JldHVybiBNfSksdC5kKGUsInNjYWxlIixmdW5jdGlvbigpe3JldHVybiB5fSksdC5kKGUsImZyb21Sb3RhdGlvbiIsZnVuY3Rpb24oKXtyZXR1cm4gU30pLHQuZChlLCJmcm9tU2NhbGluZyIsZnVuY3Rpb24oKXtyZXR1cm4gc30pLHQuZChlLCJzdHIiLGZ1bmN0aW9uKCl7cmV0dXJuIGN9KSx0LmQoZSwiZnJvYiIsZnVuY3Rpb24oKXtyZXR1cm4gbH0pLHQuZChlLCJMRFUiLGZ1bmN0aW9uKCl7cmV0dXJuIHZ9KSx0LmQoZSwiYWRkIixmdW5jdGlvbigpe3JldHVybiBUfSksdC5kKGUsInN1YnRyYWN0IixmdW5jdGlvbigpe3JldHVybiBSfSksdC5kKGUsImV4YWN0RXF1YWxzIixmdW5jdGlvbigpe3JldHVybiBMfSksdC5kKGUsImVxdWFscyIsZnVuY3Rpb24oKXtyZXR1cm4gTn0pLHQuZChlLCJtdWx0aXBseVNjYWxhciIsZnVuY3Rpb24oKXtyZXR1cm4gQX0pLHQuZChlLCJtdWx0aXBseVNjYWxhckFuZEFkZCIsZnVuY3Rpb24oKXtyZXR1cm4gd30pLHQuZChlLCJtdWwiLGZ1bmN0aW9uKCl7cmV0dXJuIEJ9KSx0LmQoZSwic3ViIixmdW5jdGlvbigpe3JldHVybiBEfSk7dmFyIG49dCgyKTtmdW5jdGlvbiBpKCl7dmFyIEk9bmV3IG4uQVJSQVlfVFlQRSg0KTtyZXR1cm4gbi5BUlJBWV9UWVBFIT1GbG9hdDMyQXJyYXkmJihJWzFdPTAsSVsyXT0wKSxJWzBdPTEsSVszXT0xLEl9ZnVuY3Rpb24gZihJKXt2YXIgaj1uZXcgbi5BUlJBWV9UWVBFKDQpO3JldHVybiBqWzBdPUlbMF0salsxXT1JWzFdLGpbMl09SVsyXSxqWzNdPUlbM10san1mdW5jdGlvbiBoKEksail7cmV0dXJuIElbMF09alswXSxJWzFdPWpbMV0sSVsyXT1qWzJdLElbM109alszXSxJfWZ1bmN0aW9uIHUoSSl7cmV0dXJuIElbMF09MSxJWzFdPTAsSVsyXT0wLElbM109MSxJfWZ1bmN0aW9uIGEoSSxqLFYsSil7dmFyIF89bmV3IG4uQVJSQVlfVFlQRSg0KTtyZXR1cm4gX1swXT1JLF9bMV09aixfWzJdPVYsX1szXT1KLF99ZnVuY3Rpb24gZChJLGosVixKLF8pe3JldHVybiBJWzBdPWosSVsxXT1WLElbMl09SixJWzNdPV8sSX1mdW5jdGlvbiBFKEksail7aWYoST09PWope3ZhciBWPWpbMV07SVsxXT1qWzJdLElbMl09Vn1lbHNlIElbMF09alswXSxJWzFdPWpbMl0sSVsyXT1qWzFdLElbM109alszXTtyZXR1cm4gSX1mdW5jdGlvbiBwKEksail7dmFyIFY9alswXSxKPWpbMV0sXz1qWzJdLHN0PWpbM10sRz1WKnN0LV8qSjtyZXR1cm4gRz8oRz0xL0csSVswXT1zdCpHLElbMV09LUoqRyxJWzJdPS1fKkcsSVszXT1WKkcsSSk6bnVsbH1mdW5jdGlvbiBPKEksail7dmFyIFY9alswXTtyZXR1cm4gSVswXT1qWzNdLElbMV09LWpbMV0sSVsyXT0talsyXSxJWzNdPVYsSX1mdW5jdGlvbiBtKEkpe3JldHVybiBJWzBdKklbM10tSVsyXSpJWzFdfWZ1bmN0aW9uIGIoSSxqLFYpe3ZhciBKPWpbMF0sXz1qWzFdLHN0PWpbMl0sRz1qWzNdLFk9VlswXSxydD1WWzFdLG90PVZbMl0sYXQ9VlszXTtyZXR1cm4gSVswXT1KKlkrc3QqcnQsSVsxXT1fKlkrRypydCxJWzJdPUoqb3Qrc3QqYXQsSVszXT1fKm90K0cqYXQsSX1mdW5jdGlvbiBNKEksaixWKXt2YXIgSj1qWzBdLF89alsxXSxzdD1qWzJdLEc9alszXSxZPU1hdGguc2luKFYpLHJ0PU1hdGguY29zKFYpO3JldHVybiBJWzBdPUoqcnQrc3QqWSxJWzFdPV8qcnQrRypZLElbMl09SiotWStzdCpydCxJWzNdPV8qLVkrRypydCxJfWZ1bmN0aW9uIHkoSSxqLFYpe3ZhciBKPWpbMF0sXz1qWzFdLHN0PWpbMl0sRz1qWzNdLFk9VlswXSxydD1WWzFdO3JldHVybiBJWzBdPUoqWSxJWzFdPV8qWSxJWzJdPXN0KnJ0LElbM109RypydCxJfWZ1bmN0aW9uIFMoSSxqKXt2YXIgVj1NYXRoLnNpbihqKSxKPU1hdGguY29zKGopO3JldHVybiBJWzBdPUosSVsxXT1WLElbMl09LVYsSVszXT1KLEl9ZnVuY3Rpb24gcyhJLGope3JldHVybiBJWzBdPWpbMF0sSVsxXT0wLElbMl09MCxJWzNdPWpbMV0sSX1mdW5jdGlvbiBjKEkpe3JldHVybiJtYXQyKCIrSVswXSsiLCAiK0lbMV0rIiwgIitJWzJdKyIsICIrSVszXSsiKSJ9ZnVuY3Rpb24gbChJKXtyZXR1cm4gTWF0aC5oeXBvdChJWzBdLElbMV0sSVsyXSxJWzNdKX1mdW5jdGlvbiB2KEksaixWLEope3JldHVybiBJWzJdPUpbMl0vSlswXSxWWzBdPUpbMF0sVlsxXT1KWzFdLFZbM109SlszXS1JWzJdKlZbMV0sW0ksaixWXX1mdW5jdGlvbiBUKEksaixWKXtyZXR1cm4gSVswXT1qWzBdK1ZbMF0sSVsxXT1qWzFdK1ZbMV0sSVsyXT1qWzJdK1ZbMl0sSVszXT1qWzNdK1ZbM10sSX1mdW5jdGlvbiBSKEksaixWKXtyZXR1cm4gSVswXT1qWzBdLVZbMF0sSVsxXT1qWzFdLVZbMV0sSVsyXT1qWzJdLVZbMl0sSVszXT1qWzNdLVZbM10sSX1mdW5jdGlvbiBMKEksail7cmV0dXJuIElbMF09PT1qWzBdJiZJWzFdPT09alsxXSYmSVsyXT09PWpbMl0mJklbM109PT1qWzNdfWZ1bmN0aW9uIE4oSSxqKXt2YXIgVj1JWzBdLEo9SVsxXSxfPUlbMl0sc3Q9SVszXSxHPWpbMF0sWT1qWzFdLHJ0PWpbMl0sb3Q9alszXTtyZXR1cm4gTWF0aC5hYnMoVi1HKTw9bi5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoViksTWF0aC5hYnMoRykpJiZNYXRoLmFicyhKLVkpPD1uLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhKKSxNYXRoLmFicyhZKSkmJk1hdGguYWJzKF8tcnQpPD1uLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhfKSxNYXRoLmFicyhydCkpJiZNYXRoLmFicyhzdC1vdCk8PW4uRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKHN0KSxNYXRoLmFicyhvdCkpfWZ1bmN0aW9uIEEoSSxqLFYpe3JldHVybiBJWzBdPWpbMF0qVixJWzFdPWpbMV0qVixJWzJdPWpbMl0qVixJWzNdPWpbM10qVixJfWZ1bmN0aW9uIHcoSSxqLFYsSil7cmV0dXJuIElbMF09alswXStWWzBdKkosSVsxXT1qWzFdK1ZbMV0qSixJWzJdPWpbMl0rVlsyXSpKLElbM109alszXStWWzNdKkosSX12YXIgQj1iLEQ9Un0sZnVuY3Rpb24oZyxlLHQpe3QucihlKSx0LmQoZSwiY3JlYXRlIixmdW5jdGlvbigpe3JldHVybiBpfSksdC5kKGUsImNsb25lIixmdW5jdGlvbigpe3JldHVybiBmfSksdC5kKGUsImNvcHkiLGZ1bmN0aW9uKCl7cmV0dXJuIGh9KSx0LmQoZSwiaWRlbnRpdHkiLGZ1bmN0aW9uKCl7cmV0dXJuIHV9KSx0LmQoZSwiZnJvbVZhbHVlcyIsZnVuY3Rpb24oKXtyZXR1cm4gYX0pLHQuZChlLCJzZXQiLGZ1bmN0aW9uKCl7cmV0dXJuIGR9KSx0LmQoZSwiaW52ZXJ0IixmdW5jdGlvbigpe3JldHVybiBFfSksdC5kKGUsImRldGVybWluYW50IixmdW5jdGlvbigpe3JldHVybiBwfSksdC5kKGUsIm11bHRpcGx5IixmdW5jdGlvbigpe3JldHVybiBPfSksdC5kKGUsInJvdGF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gbX0pLHQuZChlLCJzY2FsZSIsZnVuY3Rpb24oKXtyZXR1cm4gYn0pLHQuZChlLCJ0cmFuc2xhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIE19KSx0LmQoZSwiZnJvbVJvdGF0aW9uIixmdW5jdGlvbigpe3JldHVybiB5fSksdC5kKGUsImZyb21TY2FsaW5nIixmdW5jdGlvbigpe3JldHVybiBTfSksdC5kKGUsImZyb21UcmFuc2xhdGlvbiIsZnVuY3Rpb24oKXtyZXR1cm4gc30pLHQuZChlLCJzdHIiLGZ1bmN0aW9uKCl7cmV0dXJuIGN9KSx0LmQoZSwiZnJvYiIsZnVuY3Rpb24oKXtyZXR1cm4gbH0pLHQuZChlLCJhZGQiLGZ1bmN0aW9uKCl7cmV0dXJuIHZ9KSx0LmQoZSwic3VidHJhY3QiLGZ1bmN0aW9uKCl7cmV0dXJuIFR9KSx0LmQoZSwibXVsdGlwbHlTY2FsYXIiLGZ1bmN0aW9uKCl7cmV0dXJuIFJ9KSx0LmQoZSwibXVsdGlwbHlTY2FsYXJBbmRBZGQiLGZ1bmN0aW9uKCl7cmV0dXJuIEx9KSx0LmQoZSwiZXhhY3RFcXVhbHMiLGZ1bmN0aW9uKCl7cmV0dXJuIE59KSx0LmQoZSwiZXF1YWxzIixmdW5jdGlvbigpe3JldHVybiBBfSksdC5kKGUsIm11bCIsZnVuY3Rpb24oKXtyZXR1cm4gd30pLHQuZChlLCJzdWIiLGZ1bmN0aW9uKCl7cmV0dXJuIEJ9KTt2YXIgbj10KDIpO2Z1bmN0aW9uIGkoKXt2YXIgRD1uZXcgbi5BUlJBWV9UWVBFKDYpO3JldHVybiBuLkFSUkFZX1RZUEUhPUZsb2F0MzJBcnJheSYmKERbMV09MCxEWzJdPTAsRFs0XT0wLERbNV09MCksRFswXT0xLERbM109MSxEfWZ1bmN0aW9uIGYoRCl7dmFyIEk9bmV3IG4uQVJSQVlfVFlQRSg2KTtyZXR1cm4gSVswXT1EWzBdLElbMV09RFsxXSxJWzJdPURbMl0sSVszXT1EWzNdLElbNF09RFs0XSxJWzVdPURbNV0sSX1mdW5jdGlvbiBoKEQsSSl7cmV0dXJuIERbMF09SVswXSxEWzFdPUlbMV0sRFsyXT1JWzJdLERbM109SVszXSxEWzRdPUlbNF0sRFs1XT1JWzVdLER9ZnVuY3Rpb24gdShEKXtyZXR1cm4gRFswXT0xLERbMV09MCxEWzJdPTAsRFszXT0xLERbNF09MCxEWzVdPTAsRH1mdW5jdGlvbiBhKEQsSSxqLFYsSixfKXt2YXIgc3Q9bmV3IG4uQVJSQVlfVFlQRSg2KTtyZXR1cm4gc3RbMF09RCxzdFsxXT1JLHN0WzJdPWosc3RbM109VixzdFs0XT1KLHN0WzVdPV8sc3R9ZnVuY3Rpb24gZChELEksaixWLEosXyxzdCl7cmV0dXJuIERbMF09SSxEWzFdPWosRFsyXT1WLERbM109SixEWzRdPV8sRFs1XT1zdCxEfWZ1bmN0aW9uIEUoRCxJKXt2YXIgaj1JWzBdLFY9SVsxXSxKPUlbMl0sXz1JWzNdLHN0PUlbNF0sRz1JWzVdLFk9aipfLVYqSjtyZXR1cm4gWT8oWT0xL1ksRFswXT1fKlksRFsxXT0tVipZLERbMl09LUoqWSxEWzNdPWoqWSxEWzRdPShKKkctXypzdCkqWSxEWzVdPShWKnN0LWoqRykqWSxEKTpudWxsfWZ1bmN0aW9uIHAoRCl7cmV0dXJuIERbMF0qRFszXS1EWzFdKkRbMl19ZnVuY3Rpb24gTyhELEksail7dmFyIFY9SVswXSxKPUlbMV0sXz1JWzJdLHN0PUlbM10sRz1JWzRdLFk9SVs1XSxydD1qWzBdLG90PWpbMV0sYXQ9alsyXSxodD1qWzNdLGl0PWpbNF0sTXQ9als1XTtyZXR1cm4gRFswXT1WKnJ0K18qb3QsRFsxXT1KKnJ0K3N0Km90LERbMl09ViphdCtfKmh0LERbM109SiphdCtzdCpodCxEWzRdPVYqaXQrXypNdCtHLERbNV09SippdCtzdCpNdCtZLER9ZnVuY3Rpb24gbShELEksail7dmFyIFY9SVswXSxKPUlbMV0sXz1JWzJdLHN0PUlbM10sRz1JWzRdLFk9SVs1XSxydD1NYXRoLnNpbihqKSxvdD1NYXRoLmNvcyhqKTtyZXR1cm4gRFswXT1WKm90K18qcnQsRFsxXT1KKm90K3N0KnJ0LERbMl09ViotcnQrXypvdCxEWzNdPUoqLXJ0K3N0Km90LERbNF09RyxEWzVdPVksRH1mdW5jdGlvbiBiKEQsSSxqKXt2YXIgVj1JWzBdLEo9SVsxXSxfPUlbMl0sc3Q9SVszXSxHPUlbNF0sWT1JWzVdLHJ0PWpbMF0sb3Q9alsxXTtyZXR1cm4gRFswXT1WKnJ0LERbMV09SipydCxEWzJdPV8qb3QsRFszXT1zdCpvdCxEWzRdPUcsRFs1XT1ZLER9ZnVuY3Rpb24gTShELEksail7dmFyIFY9SVswXSxKPUlbMV0sXz1JWzJdLHN0PUlbM10sRz1JWzRdLFk9SVs1XSxydD1qWzBdLG90PWpbMV07cmV0dXJuIERbMF09VixEWzFdPUosRFsyXT1fLERbM109c3QsRFs0XT1WKnJ0K18qb3QrRyxEWzVdPUoqcnQrc3Qqb3QrWSxEfWZ1bmN0aW9uIHkoRCxJKXt2YXIgaj1NYXRoLnNpbihJKSxWPU1hdGguY29zKEkpO3JldHVybiBEWzBdPVYsRFsxXT1qLERbMl09LWosRFszXT1WLERbNF09MCxEWzVdPTAsRH1mdW5jdGlvbiBTKEQsSSl7cmV0dXJuIERbMF09SVswXSxEWzFdPTAsRFsyXT0wLERbM109SVsxXSxEWzRdPTAsRFs1XT0wLER9ZnVuY3Rpb24gcyhELEkpe3JldHVybiBEWzBdPTEsRFsxXT0wLERbMl09MCxEWzNdPTEsRFs0XT1JWzBdLERbNV09SVsxXSxEfWZ1bmN0aW9uIGMoRCl7cmV0dXJuIm1hdDJkKCIrRFswXSsiLCAiK0RbMV0rIiwgIitEWzJdKyIsICIrRFszXSsiLCAiK0RbNF0rIiwgIitEWzVdKyIpIn1mdW5jdGlvbiBsKEQpe3JldHVybiBNYXRoLmh5cG90KERbMF0sRFsxXSxEWzJdLERbM10sRFs0XSxEWzVdLDEpfWZ1bmN0aW9uIHYoRCxJLGope3JldHVybiBEWzBdPUlbMF0ralswXSxEWzFdPUlbMV0ralsxXSxEWzJdPUlbMl0ralsyXSxEWzNdPUlbM10ralszXSxEWzRdPUlbNF0rals0XSxEWzVdPUlbNV0rals1XSxEfWZ1bmN0aW9uIFQoRCxJLGope3JldHVybiBEWzBdPUlbMF0talswXSxEWzFdPUlbMV0talsxXSxEWzJdPUlbMl0talsyXSxEWzNdPUlbM10talszXSxEWzRdPUlbNF0tals0XSxEWzVdPUlbNV0tals1XSxEfWZ1bmN0aW9uIFIoRCxJLGope3JldHVybiBEWzBdPUlbMF0qaixEWzFdPUlbMV0qaixEWzJdPUlbMl0qaixEWzNdPUlbM10qaixEWzRdPUlbNF0qaixEWzVdPUlbNV0qaixEfWZ1bmN0aW9uIEwoRCxJLGosVil7cmV0dXJuIERbMF09SVswXStqWzBdKlYsRFsxXT1JWzFdK2pbMV0qVixEWzJdPUlbMl0ralsyXSpWLERbM109SVszXStqWzNdKlYsRFs0XT1JWzRdK2pbNF0qVixEWzVdPUlbNV0rals1XSpWLER9ZnVuY3Rpb24gTihELEkpe3JldHVybiBEWzBdPT09SVswXSYmRFsxXT09PUlbMV0mJkRbMl09PT1JWzJdJiZEWzNdPT09SVszXSYmRFs0XT09PUlbNF0mJkRbNV09PT1JWzVdfWZ1bmN0aW9uIEEoRCxJKXt2YXIgaj1EWzBdLFY9RFsxXSxKPURbMl0sXz1EWzNdLHN0PURbNF0sRz1EWzVdLFk9SVswXSxydD1JWzFdLG90PUlbMl0sYXQ9SVszXSxodD1JWzRdLGl0PUlbNV07cmV0dXJuIE1hdGguYWJzKGotWSk8PW4uRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKGopLE1hdGguYWJzKFkpKSYmTWF0aC5hYnMoVi1ydCk8PW4uRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKFYpLE1hdGguYWJzKHJ0KSkmJk1hdGguYWJzKEotb3QpPD1uLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhKKSxNYXRoLmFicyhvdCkpJiZNYXRoLmFicyhfLWF0KTw9bi5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoXyksTWF0aC5hYnMoYXQpKSYmTWF0aC5hYnMoc3QtaHQpPD1uLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhzdCksTWF0aC5hYnMoaHQpKSYmTWF0aC5hYnMoRy1pdCk8PW4uRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKEcpLE1hdGguYWJzKGl0KSl9dmFyIHc9TyxCPVR9LGZ1bmN0aW9uKGcsZSx0KXt0LnIoZSksdC5kKGUsImNyZWF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gaX0pLHQuZChlLCJmcm9tTWF0NCIsZnVuY3Rpb24oKXtyZXR1cm4gZn0pLHQuZChlLCJjbG9uZSIsZnVuY3Rpb24oKXtyZXR1cm4gaH0pLHQuZChlLCJjb3B5IixmdW5jdGlvbigpe3JldHVybiB1fSksdC5kKGUsImZyb21WYWx1ZXMiLGZ1bmN0aW9uKCl7cmV0dXJuIGF9KSx0LmQoZSwic2V0IixmdW5jdGlvbigpe3JldHVybiBkfSksdC5kKGUsImlkZW50aXR5IixmdW5jdGlvbigpe3JldHVybiBFfSksdC5kKGUsInRyYW5zcG9zZSIsZnVuY3Rpb24oKXtyZXR1cm4gcH0pLHQuZChlLCJpbnZlcnQiLGZ1bmN0aW9uKCl7cmV0dXJuIE99KSx0LmQoZSwiYWRqb2ludCIsZnVuY3Rpb24oKXtyZXR1cm4gbX0pLHQuZChlLCJkZXRlcm1pbmFudCIsZnVuY3Rpb24oKXtyZXR1cm4gYn0pLHQuZChlLCJtdWx0aXBseSIsZnVuY3Rpb24oKXtyZXR1cm4gTX0pLHQuZChlLCJ0cmFuc2xhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIHl9KSx0LmQoZSwicm90YXRlIixmdW5jdGlvbigpe3JldHVybiBTfSksdC5kKGUsInNjYWxlIixmdW5jdGlvbigpe3JldHVybiBzfSksdC5kKGUsImZyb21UcmFuc2xhdGlvbiIsZnVuY3Rpb24oKXtyZXR1cm4gY30pLHQuZChlLCJmcm9tUm90YXRpb24iLGZ1bmN0aW9uKCl7cmV0dXJuIGx9KSx0LmQoZSwiZnJvbVNjYWxpbmciLGZ1bmN0aW9uKCl7cmV0dXJuIHZ9KSx0LmQoZSwiZnJvbU1hdDJkIixmdW5jdGlvbigpe3JldHVybiBUfSksdC5kKGUsImZyb21RdWF0IixmdW5jdGlvbigpe3JldHVybiBSfSksdC5kKGUsIm5vcm1hbEZyb21NYXQ0IixmdW5jdGlvbigpe3JldHVybiBMfSksdC5kKGUsInByb2plY3Rpb24iLGZ1bmN0aW9uKCl7cmV0dXJuIE59KSx0LmQoZSwic3RyIixmdW5jdGlvbigpe3JldHVybiBBfSksdC5kKGUsImZyb2IiLGZ1bmN0aW9uKCl7cmV0dXJuIHd9KSx0LmQoZSwiYWRkIixmdW5jdGlvbigpe3JldHVybiBCfSksdC5kKGUsInN1YnRyYWN0IixmdW5jdGlvbigpe3JldHVybiBEfSksdC5kKGUsIm11bHRpcGx5U2NhbGFyIixmdW5jdGlvbigpe3JldHVybiBJfSksdC5kKGUsIm11bHRpcGx5U2NhbGFyQW5kQWRkIixmdW5jdGlvbigpe3JldHVybiBqfSksdC5kKGUsImV4YWN0RXF1YWxzIixmdW5jdGlvbigpe3JldHVybiBWfSksdC5kKGUsImVxdWFscyIsZnVuY3Rpb24oKXtyZXR1cm4gSn0pLHQuZChlLCJtdWwiLGZ1bmN0aW9uKCl7cmV0dXJuIF99KSx0LmQoZSwic3ViIixmdW5jdGlvbigpe3JldHVybiBzdH0pO3ZhciBuPXQoMik7ZnVuY3Rpb24gaSgpe3ZhciBHPW5ldyBuLkFSUkFZX1RZUEUoOSk7cmV0dXJuIG4uQVJSQVlfVFlQRSE9RmxvYXQzMkFycmF5JiYoR1sxXT0wLEdbMl09MCxHWzNdPTAsR1s1XT0wLEdbNl09MCxHWzddPTApLEdbMF09MSxHWzRdPTEsR1s4XT0xLEd9ZnVuY3Rpb24gZihHLFkpe3JldHVybiBHWzBdPVlbMF0sR1sxXT1ZWzFdLEdbMl09WVsyXSxHWzNdPVlbNF0sR1s0XT1ZWzVdLEdbNV09WVs2XSxHWzZdPVlbOF0sR1s3XT1ZWzldLEdbOF09WVsxMF0sR31mdW5jdGlvbiBoKEcpe3ZhciBZPW5ldyBuLkFSUkFZX1RZUEUoOSk7cmV0dXJuIFlbMF09R1swXSxZWzFdPUdbMV0sWVsyXT1HWzJdLFlbM109R1szXSxZWzRdPUdbNF0sWVs1XT1HWzVdLFlbNl09R1s2XSxZWzddPUdbN10sWVs4XT1HWzhdLFl9ZnVuY3Rpb24gdShHLFkpe3JldHVybiBHWzBdPVlbMF0sR1sxXT1ZWzFdLEdbMl09WVsyXSxHWzNdPVlbM10sR1s0XT1ZWzRdLEdbNV09WVs1XSxHWzZdPVlbNl0sR1s3XT1ZWzddLEdbOF09WVs4XSxHfWZ1bmN0aW9uIGEoRyxZLHJ0LG90LGF0LGh0LGl0LE10LE90KXt2YXIgVT1uZXcgbi5BUlJBWV9UWVBFKDkpO3JldHVybiBVWzBdPUcsVVsxXT1ZLFVbMl09cnQsVVszXT1vdCxVWzRdPWF0LFVbNV09aHQsVVs2XT1pdCxVWzddPU10LFVbOF09T3QsVX1mdW5jdGlvbiBkKEcsWSxydCxvdCxhdCxodCxpdCxNdCxPdCxVKXtyZXR1cm4gR1swXT1ZLEdbMV09cnQsR1syXT1vdCxHWzNdPWF0LEdbNF09aHQsR1s1XT1pdCxHWzZdPU10LEdbN109T3QsR1s4XT1VLEd9ZnVuY3Rpb24gRShHKXtyZXR1cm4gR1swXT0xLEdbMV09MCxHWzJdPTAsR1szXT0wLEdbNF09MSxHWzVdPTAsR1s2XT0wLEdbN109MCxHWzhdPTEsR31mdW5jdGlvbiBwKEcsWSl7aWYoRz09PVkpe3ZhciBydD1ZWzFdLG90PVlbMl0sYXQ9WVs1XTtHWzFdPVlbM10sR1syXT1ZWzZdLEdbM109cnQsR1s1XT1ZWzddLEdbNl09b3QsR1s3XT1hdH1lbHNlIEdbMF09WVswXSxHWzFdPVlbM10sR1syXT1ZWzZdLEdbM109WVsxXSxHWzRdPVlbNF0sR1s1XT1ZWzddLEdbNl09WVsyXSxHWzddPVlbNV0sR1s4XT1ZWzhdO3JldHVybiBHfWZ1bmN0aW9uIE8oRyxZKXt2YXIgcnQ9WVswXSxvdD1ZWzFdLGF0PVlbMl0saHQ9WVszXSxpdD1ZWzRdLE10PVlbNV0sT3Q9WVs2XSxVPVlbN10sJD1ZWzhdLFE9JCppdC1NdCpVLHR0PS0kKmh0K010Kk90LEY9VSpodC1pdCpPdCxIPXJ0KlErb3QqdHQrYXQqRjtyZXR1cm4gSD8oSD0xL0gsR1swXT1RKkgsR1sxXT0oLSQqb3QrYXQqVSkqSCxHWzJdPShNdCpvdC1hdCppdCkqSCxHWzNdPXR0KkgsR1s0XT0oJCpydC1hdCpPdCkqSCxHWzVdPSgtTXQqcnQrYXQqaHQpKkgsR1s2XT1GKkgsR1s3XT0oLVUqcnQrb3QqT3QpKkgsR1s4XT0oaXQqcnQtb3QqaHQpKkgsRyk6bnVsbH1mdW5jdGlvbiBtKEcsWSl7dmFyIHJ0PVlbMF0sb3Q9WVsxXSxhdD1ZWzJdLGh0PVlbM10saXQ9WVs0XSxNdD1ZWzVdLE90PVlbNl0sVT1ZWzddLCQ9WVs4XTtyZXR1cm4gR1swXT1pdCokLU10KlUsR1sxXT1hdCpVLW90KiQsR1syXT1vdCpNdC1hdCppdCxHWzNdPU10Kk90LWh0KiQsR1s0XT1ydCokLWF0Kk90LEdbNV09YXQqaHQtcnQqTXQsR1s2XT1odCpVLWl0Kk90LEdbN109b3QqT3QtcnQqVSxHWzhdPXJ0Kml0LW90Kmh0LEd9ZnVuY3Rpb24gYihHKXt2YXIgWT1HWzBdLHJ0PUdbMV0sb3Q9R1syXSxhdD1HWzNdLGh0PUdbNF0saXQ9R1s1XSxNdD1HWzZdLE90PUdbN10sVT1HWzhdO3JldHVybiBZKihVKmh0LWl0Kk90KStydCooLVUqYXQraXQqTXQpK290KihPdCphdC1odCpNdCl9ZnVuY3Rpb24gTShHLFkscnQpe3ZhciBvdD1ZWzBdLGF0PVlbMV0saHQ9WVsyXSxpdD1ZWzNdLE10PVlbNF0sT3Q9WVs1XSxVPVlbNl0sJD1ZWzddLFE9WVs4XSx0dD1ydFswXSxGPXJ0WzFdLEg9cnRbMl0seD1ydFszXSxQPXJ0WzRdLFc9cnRbNV0sSz1ydFs2XSxaPXJ0WzddLGs9cnRbOF07cmV0dXJuIEdbMF09dHQqb3QrRippdCtIKlUsR1sxXT10dCphdCtGKk10K0gqJCxHWzJdPXR0Kmh0K0YqT3QrSCpRLEdbM109eCpvdCtQKml0K1cqVSxHWzRdPXgqYXQrUCpNdCtXKiQsR1s1XT14Kmh0K1AqT3QrVypRLEdbNl09SypvdCtaKml0K2sqVSxHWzddPUsqYXQrWipNdCtrKiQsR1s4XT1LKmh0K1oqT3QraypRLEd9ZnVuY3Rpb24geShHLFkscnQpe3ZhciBvdD1ZWzBdLGF0PVlbMV0saHQ9WVsyXSxpdD1ZWzNdLE10PVlbNF0sT3Q9WVs1XSxVPVlbNl0sJD1ZWzddLFE9WVs4XSx0dD1ydFswXSxGPXJ0WzFdO3JldHVybiBHWzBdPW90LEdbMV09YXQsR1syXT1odCxHWzNdPWl0LEdbNF09TXQsR1s1XT1PdCxHWzZdPXR0Km90K0YqaXQrVSxHWzddPXR0KmF0K0YqTXQrJCxHWzhdPXR0Kmh0K0YqT3QrUSxHfWZ1bmN0aW9uIFMoRyxZLHJ0KXt2YXIgb3Q9WVswXSxhdD1ZWzFdLGh0PVlbMl0saXQ9WVszXSxNdD1ZWzRdLE90PVlbNV0sVT1ZWzZdLCQ9WVs3XSxRPVlbOF0sdHQ9TWF0aC5zaW4ocnQpLEY9TWF0aC5jb3MocnQpO3JldHVybiBHWzBdPUYqb3QrdHQqaXQsR1sxXT1GKmF0K3R0Kk10LEdbMl09RipodCt0dCpPdCxHWzNdPUYqaXQtdHQqb3QsR1s0XT1GKk10LXR0KmF0LEdbNV09RipPdC10dCpodCxHWzZdPVUsR1s3XT0kLEdbOF09USxHfWZ1bmN0aW9uIHMoRyxZLHJ0KXt2YXIgb3Q9cnRbMF0sYXQ9cnRbMV07cmV0dXJuIEdbMF09b3QqWVswXSxHWzFdPW90KllbMV0sR1syXT1vdCpZWzJdLEdbM109YXQqWVszXSxHWzRdPWF0KllbNF0sR1s1XT1hdCpZWzVdLEdbNl09WVs2XSxHWzddPVlbN10sR1s4XT1ZWzhdLEd9ZnVuY3Rpb24gYyhHLFkpe3JldHVybiBHWzBdPTEsR1sxXT0wLEdbMl09MCxHWzNdPTAsR1s0XT0xLEdbNV09MCxHWzZdPVlbMF0sR1s3XT1ZWzFdLEdbOF09MSxHfWZ1bmN0aW9uIGwoRyxZKXt2YXIgcnQ9TWF0aC5zaW4oWSksb3Q9TWF0aC5jb3MoWSk7cmV0dXJuIEdbMF09b3QsR1sxXT1ydCxHWzJdPTAsR1szXT0tcnQsR1s0XT1vdCxHWzVdPTAsR1s2XT0wLEdbN109MCxHWzhdPTEsR31mdW5jdGlvbiB2KEcsWSl7cmV0dXJuIEdbMF09WVswXSxHWzFdPTAsR1syXT0wLEdbM109MCxHWzRdPVlbMV0sR1s1XT0wLEdbNl09MCxHWzddPTAsR1s4XT0xLEd9ZnVuY3Rpb24gVChHLFkpe3JldHVybiBHWzBdPVlbMF0sR1sxXT1ZWzFdLEdbMl09MCxHWzNdPVlbMl0sR1s0XT1ZWzNdLEdbNV09MCxHWzZdPVlbNF0sR1s3XT1ZWzVdLEdbOF09MSxHfWZ1bmN0aW9uIFIoRyxZKXt2YXIgcnQ9WVswXSxvdD1ZWzFdLGF0PVlbMl0saHQ9WVszXSxpdD1ydCtydCxNdD1vdCtvdCxPdD1hdCthdCxVPXJ0Kml0LCQ9b3QqaXQsUT1vdCpNdCx0dD1hdCppdCxGPWF0Kk10LEg9YXQqT3QseD1odCppdCxQPWh0Kk10LFc9aHQqT3Q7cmV0dXJuIEdbMF09MS1RLUgsR1szXT0kLVcsR1s2XT10dCtQLEdbMV09JCtXLEdbNF09MS1VLUgsR1s3XT1GLXgsR1syXT10dC1QLEdbNV09Rit4LEdbOF09MS1VLVEsR31mdW5jdGlvbiBMKEcsWSl7dmFyIHJ0PVlbMF0sb3Q9WVsxXSxhdD1ZWzJdLGh0PVlbM10saXQ9WVs0XSxNdD1ZWzVdLE90PVlbNl0sVT1ZWzddLCQ9WVs4XSxRPVlbOV0sdHQ9WVsxMF0sRj1ZWzExXSxIPVlbMTJdLHg9WVsxM10sUD1ZWzE0XSxXPVlbMTVdLEs9cnQqTXQtb3QqaXQsWj1ydCpPdC1hdCppdCxrPXJ0KlUtaHQqaXQsbnQ9b3QqT3QtYXQqTXQsdXQ9b3QqVS1odCpNdCxjdD1hdCpVLWh0Kk90LHB0PSQqeC1RKkgseHQ9JCpQLXR0KkgsZ3Q9JCpXLUYqSCxkdD1RKlAtdHQqeCxtdD1RKlctRip4LGJ0PXR0KlctRipQLEN0PUsqYnQtWiptdCtrKmR0K250Kmd0LXV0Knh0K2N0KnB0O3JldHVybiBDdD8oQ3Q9MS9DdCxHWzBdPShNdCpidC1PdCptdCtVKmR0KSpDdCxHWzFdPShPdCpndC1pdCpidC1VKnh0KSpDdCxHWzJdPShpdCptdC1NdCpndCtVKnB0KSpDdCxHWzNdPShhdCptdC1vdCpidC1odCpkdCkqQ3QsR1s0XT0ocnQqYnQtYXQqZ3QraHQqeHQpKkN0LEdbNV09KG90Kmd0LXJ0Km10LWh0KnB0KSpDdCxHWzZdPSh4KmN0LVAqdXQrVypudCkqQ3QsR1s3XT0oUCprLUgqY3QtVypaKSpDdCxHWzhdPShIKnV0LXgqaytXKkspKkN0LEcpOm51bGx9ZnVuY3Rpb24gTihHLFkscnQpe3JldHVybiBHWzBdPTIvWSxHWzFdPTAsR1syXT0wLEdbM109MCxHWzRdPS0yL3J0LEdbNV09MCxHWzZdPS0xLEdbN109MSxHWzhdPTEsR31mdW5jdGlvbiBBKEcpe3JldHVybiJtYXQzKCIrR1swXSsiLCAiK0dbMV0rIiwgIitHWzJdKyIsICIrR1szXSsiLCAiK0dbNF0rIiwgIitHWzVdKyIsICIrR1s2XSsiLCAiK0dbN10rIiwgIitHWzhdKyIpIn1mdW5jdGlvbiB3KEcpe3JldHVybiBNYXRoLmh5cG90KEdbMF0sR1sxXSxHWzJdLEdbM10sR1s0XSxHWzVdLEdbNl0sR1s3XSxHWzhdKX1mdW5jdGlvbiBCKEcsWSxydCl7cmV0dXJuIEdbMF09WVswXStydFswXSxHWzFdPVlbMV0rcnRbMV0sR1syXT1ZWzJdK3J0WzJdLEdbM109WVszXStydFszXSxHWzRdPVlbNF0rcnRbNF0sR1s1XT1ZWzVdK3J0WzVdLEdbNl09WVs2XStydFs2XSxHWzddPVlbN10rcnRbN10sR1s4XT1ZWzhdK3J0WzhdLEd9ZnVuY3Rpb24gRChHLFkscnQpe3JldHVybiBHWzBdPVlbMF0tcnRbMF0sR1sxXT1ZWzFdLXJ0WzFdLEdbMl09WVsyXS1ydFsyXSxHWzNdPVlbM10tcnRbM10sR1s0XT1ZWzRdLXJ0WzRdLEdbNV09WVs1XS1ydFs1XSxHWzZdPVlbNl0tcnRbNl0sR1s3XT1ZWzddLXJ0WzddLEdbOF09WVs4XS1ydFs4XSxHfWZ1bmN0aW9uIEkoRyxZLHJ0KXtyZXR1cm4gR1swXT1ZWzBdKnJ0LEdbMV09WVsxXSpydCxHWzJdPVlbMl0qcnQsR1szXT1ZWzNdKnJ0LEdbNF09WVs0XSpydCxHWzVdPVlbNV0qcnQsR1s2XT1ZWzZdKnJ0LEdbN109WVs3XSpydCxHWzhdPVlbOF0qcnQsR31mdW5jdGlvbiBqKEcsWSxydCxvdCl7cmV0dXJuIEdbMF09WVswXStydFswXSpvdCxHWzFdPVlbMV0rcnRbMV0qb3QsR1syXT1ZWzJdK3J0WzJdKm90LEdbM109WVszXStydFszXSpvdCxHWzRdPVlbNF0rcnRbNF0qb3QsR1s1XT1ZWzVdK3J0WzVdKm90LEdbNl09WVs2XStydFs2XSpvdCxHWzddPVlbN10rcnRbN10qb3QsR1s4XT1ZWzhdK3J0WzhdKm90LEd9ZnVuY3Rpb24gVihHLFkpe3JldHVybiBHWzBdPT09WVswXSYmR1sxXT09PVlbMV0mJkdbMl09PT1ZWzJdJiZHWzNdPT09WVszXSYmR1s0XT09PVlbNF0mJkdbNV09PT1ZWzVdJiZHWzZdPT09WVs2XSYmR1s3XT09PVlbN10mJkdbOF09PT1ZWzhdfWZ1bmN0aW9uIEooRyxZKXt2YXIgcnQ9R1swXSxvdD1HWzFdLGF0PUdbMl0saHQ9R1szXSxpdD1HWzRdLE10PUdbNV0sT3Q9R1s2XSxVPUdbN10sJD1HWzhdLFE9WVswXSx0dD1ZWzFdLEY9WVsyXSxIPVlbM10seD1ZWzRdLFA9WVs1XSxXPVlbNl0sSz1ZWzddLFo9WVs4XTtyZXR1cm4gTWF0aC5hYnMocnQtUSk8PW4uRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKHJ0KSxNYXRoLmFicyhRKSkmJk1hdGguYWJzKG90LXR0KTw9bi5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMob3QpLE1hdGguYWJzKHR0KSkmJk1hdGguYWJzKGF0LUYpPD1uLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhhdCksTWF0aC5hYnMoRikpJiZNYXRoLmFicyhodC1IKTw9bi5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoaHQpLE1hdGguYWJzKEgpKSYmTWF0aC5hYnMoaXQteCk8PW4uRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKGl0KSxNYXRoLmFicyh4KSkmJk1hdGguYWJzKE10LVApPD1uLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhNdCksTWF0aC5hYnMoUCkpJiZNYXRoLmFicyhPdC1XKTw9bi5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoT3QpLE1hdGguYWJzKFcpKSYmTWF0aC5hYnMoVS1LKTw9bi5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoVSksTWF0aC5hYnMoSykpJiZNYXRoLmFicygkLVopPD1uLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicygkKSxNYXRoLmFicyhaKSl9dmFyIF89TSxzdD1EfSxmdW5jdGlvbihnLGUsdCl7dC5yKGUpLHQuZChlLCJjcmVhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIGl9KSx0LmQoZSwiY2xvbmUiLGZ1bmN0aW9uKCl7cmV0dXJuIGZ9KSx0LmQoZSwiY29weSIsZnVuY3Rpb24oKXtyZXR1cm4gaH0pLHQuZChlLCJmcm9tVmFsdWVzIixmdW5jdGlvbigpe3JldHVybiB1fSksdC5kKGUsInNldCIsZnVuY3Rpb24oKXtyZXR1cm4gYX0pLHQuZChlLCJpZGVudGl0eSIsZnVuY3Rpb24oKXtyZXR1cm4gZH0pLHQuZChlLCJ0cmFuc3Bvc2UiLGZ1bmN0aW9uKCl7cmV0dXJuIEV9KSx0LmQoZSwiaW52ZXJ0IixmdW5jdGlvbigpe3JldHVybiBwfSksdC5kKGUsImFkam9pbnQiLGZ1bmN0aW9uKCl7cmV0dXJuIE99KSx0LmQoZSwiZGV0ZXJtaW5hbnQiLGZ1bmN0aW9uKCl7cmV0dXJuIG19KSx0LmQoZSwibXVsdGlwbHkiLGZ1bmN0aW9uKCl7cmV0dXJuIGJ9KSx0LmQoZSwidHJhbnNsYXRlIixmdW5jdGlvbigpe3JldHVybiBNfSksdC5kKGUsInNjYWxlIixmdW5jdGlvbigpe3JldHVybiB5fSksdC5kKGUsInJvdGF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gU30pLHQuZChlLCJyb3RhdGVYIixmdW5jdGlvbigpe3JldHVybiBzfSksdC5kKGUsInJvdGF0ZVkiLGZ1bmN0aW9uKCl7cmV0dXJuIGN9KSx0LmQoZSwicm90YXRlWiIsZnVuY3Rpb24oKXtyZXR1cm4gbH0pLHQuZChlLCJmcm9tVHJhbnNsYXRpb24iLGZ1bmN0aW9uKCl7cmV0dXJuIHZ9KSx0LmQoZSwiZnJvbVNjYWxpbmciLGZ1bmN0aW9uKCl7cmV0dXJuIFR9KSx0LmQoZSwiZnJvbVJvdGF0aW9uIixmdW5jdGlvbigpe3JldHVybiBSfSksdC5kKGUsImZyb21YUm90YXRpb24iLGZ1bmN0aW9uKCl7cmV0dXJuIEx9KSx0LmQoZSwiZnJvbVlSb3RhdGlvbiIsZnVuY3Rpb24oKXtyZXR1cm4gTn0pLHQuZChlLCJmcm9tWlJvdGF0aW9uIixmdW5jdGlvbigpe3JldHVybiBBfSksdC5kKGUsImZyb21Sb3RhdGlvblRyYW5zbGF0aW9uIixmdW5jdGlvbigpe3JldHVybiB3fSksdC5kKGUsImZyb21RdWF0MiIsZnVuY3Rpb24oKXtyZXR1cm4gQn0pLHQuZChlLCJnZXRUcmFuc2xhdGlvbiIsZnVuY3Rpb24oKXtyZXR1cm4gRH0pLHQuZChlLCJnZXRTY2FsaW5nIixmdW5jdGlvbigpe3JldHVybiBJfSksdC5kKGUsImdldFJvdGF0aW9uIixmdW5jdGlvbigpe3JldHVybiBqfSksdC5kKGUsImZyb21Sb3RhdGlvblRyYW5zbGF0aW9uU2NhbGUiLGZ1bmN0aW9uKCl7cmV0dXJuIFZ9KSx0LmQoZSwiZnJvbVJvdGF0aW9uVHJhbnNsYXRpb25TY2FsZU9yaWdpbiIsZnVuY3Rpb24oKXtyZXR1cm4gSn0pLHQuZChlLCJmcm9tUXVhdCIsZnVuY3Rpb24oKXtyZXR1cm4gX30pLHQuZChlLCJmcnVzdHVtIixmdW5jdGlvbigpe3JldHVybiBzdH0pLHQuZChlLCJwZXJzcGVjdGl2ZSIsZnVuY3Rpb24oKXtyZXR1cm4gR30pLHQuZChlLCJwZXJzcGVjdGl2ZUZyb21GaWVsZE9mVmlldyIsZnVuY3Rpb24oKXtyZXR1cm4gWX0pLHQuZChlLCJvcnRobyIsZnVuY3Rpb24oKXtyZXR1cm4gcnR9KSx0LmQoZSwibG9va0F0IixmdW5jdGlvbigpe3JldHVybiBvdH0pLHQuZChlLCJ0YXJnZXRUbyIsZnVuY3Rpb24oKXtyZXR1cm4gYXR9KSx0LmQoZSwic3RyIixmdW5jdGlvbigpe3JldHVybiBodH0pLHQuZChlLCJmcm9iIixmdW5jdGlvbigpe3JldHVybiBpdH0pLHQuZChlLCJhZGQiLGZ1bmN0aW9uKCl7cmV0dXJuIE10fSksdC5kKGUsInN1YnRyYWN0IixmdW5jdGlvbigpe3JldHVybiBPdH0pLHQuZChlLCJtdWx0aXBseVNjYWxhciIsZnVuY3Rpb24oKXtyZXR1cm4gVX0pLHQuZChlLCJtdWx0aXBseVNjYWxhckFuZEFkZCIsZnVuY3Rpb24oKXtyZXR1cm4gJH0pLHQuZChlLCJleGFjdEVxdWFscyIsZnVuY3Rpb24oKXtyZXR1cm4gUX0pLHQuZChlLCJlcXVhbHMiLGZ1bmN0aW9uKCl7cmV0dXJuIHR0fSksdC5kKGUsIm11bCIsZnVuY3Rpb24oKXtyZXR1cm4gRn0pLHQuZChlLCJzdWIiLGZ1bmN0aW9uKCl7cmV0dXJuIEh9KTt2YXIgbj10KDIpO2Z1bmN0aW9uIGkoKXt2YXIgeD1uZXcgbi5BUlJBWV9UWVBFKDE2KTtyZXR1cm4gbi5BUlJBWV9UWVBFIT1GbG9hdDMyQXJyYXkmJih4WzFdPTAseFsyXT0wLHhbM109MCx4WzRdPTAseFs2XT0wLHhbN109MCx4WzhdPTAseFs5XT0wLHhbMTFdPTAseFsxMl09MCx4WzEzXT0wLHhbMTRdPTApLHhbMF09MSx4WzVdPTEseFsxMF09MSx4WzE1XT0xLHh9ZnVuY3Rpb24gZih4KXt2YXIgUD1uZXcgbi5BUlJBWV9UWVBFKDE2KTtyZXR1cm4gUFswXT14WzBdLFBbMV09eFsxXSxQWzJdPXhbMl0sUFszXT14WzNdLFBbNF09eFs0XSxQWzVdPXhbNV0sUFs2XT14WzZdLFBbN109eFs3XSxQWzhdPXhbOF0sUFs5XT14WzldLFBbMTBdPXhbMTBdLFBbMTFdPXhbMTFdLFBbMTJdPXhbMTJdLFBbMTNdPXhbMTNdLFBbMTRdPXhbMTRdLFBbMTVdPXhbMTVdLFB9ZnVuY3Rpb24gaCh4LFApe3JldHVybiB4WzBdPVBbMF0seFsxXT1QWzFdLHhbMl09UFsyXSx4WzNdPVBbM10seFs0XT1QWzRdLHhbNV09UFs1XSx4WzZdPVBbNl0seFs3XT1QWzddLHhbOF09UFs4XSx4WzldPVBbOV0seFsxMF09UFsxMF0seFsxMV09UFsxMV0seFsxMl09UFsxMl0seFsxM109UFsxM10seFsxNF09UFsxNF0seFsxNV09UFsxNV0seH1mdW5jdGlvbiB1KHgsUCxXLEssWixrLG50LHV0LGN0LHB0LHh0LGd0LGR0LG10LGJ0LEN0KXt2YXIgU3Q9bmV3IG4uQVJSQVlfVFlQRSgxNik7cmV0dXJuIFN0WzBdPXgsU3RbMV09UCxTdFsyXT1XLFN0WzNdPUssU3RbNF09WixTdFs1XT1rLFN0WzZdPW50LFN0WzddPXV0LFN0WzhdPWN0LFN0WzldPXB0LFN0WzEwXT14dCxTdFsxMV09Z3QsU3RbMTJdPWR0LFN0WzEzXT1tdCxTdFsxNF09YnQsU3RbMTVdPUN0LFN0fWZ1bmN0aW9uIGEoeCxQLFcsSyxaLGssbnQsdXQsY3QscHQseHQsZ3QsZHQsbXQsYnQsQ3QsU3Qpe3JldHVybiB4WzBdPVAseFsxXT1XLHhbMl09Syx4WzNdPVoseFs0XT1rLHhbNV09bnQseFs2XT11dCx4WzddPWN0LHhbOF09cHQseFs5XT14dCx4WzEwXT1ndCx4WzExXT1kdCx4WzEyXT1tdCx4WzEzXT1idCx4WzE0XT1DdCx4WzE1XT1TdCx4fWZ1bmN0aW9uIGQoeCl7cmV0dXJuIHhbMF09MSx4WzFdPTAseFsyXT0wLHhbM109MCx4WzRdPTAseFs1XT0xLHhbNl09MCx4WzddPTAseFs4XT0wLHhbOV09MCx4WzEwXT0xLHhbMTFdPTAseFsxMl09MCx4WzEzXT0wLHhbMTRdPTAseFsxNV09MSx4fWZ1bmN0aW9uIEUoeCxQKXtpZih4PT09UCl7dmFyIFc9UFsxXSxLPVBbMl0sWj1QWzNdLGs9UFs2XSxudD1QWzddLHV0PVBbMTFdO3hbMV09UFs0XSx4WzJdPVBbOF0seFszXT1QWzEyXSx4WzRdPVcseFs2XT1QWzldLHhbN109UFsxM10seFs4XT1LLHhbOV09ayx4WzExXT1QWzE0XSx4WzEyXT1aLHhbMTNdPW50LHhbMTRdPXV0fWVsc2UgeFswXT1QWzBdLHhbMV09UFs0XSx4WzJdPVBbOF0seFszXT1QWzEyXSx4WzRdPVBbMV0seFs1XT1QWzVdLHhbNl09UFs5XSx4WzddPVBbMTNdLHhbOF09UFsyXSx4WzldPVBbNl0seFsxMF09UFsxMF0seFsxMV09UFsxNF0seFsxMl09UFszXSx4WzEzXT1QWzddLHhbMTRdPVBbMTFdLHhbMTVdPVBbMTVdO3JldHVybiB4fWZ1bmN0aW9uIHAoeCxQKXt2YXIgVz1QWzBdLEs9UFsxXSxaPVBbMl0saz1QWzNdLG50PVBbNF0sdXQ9UFs1XSxjdD1QWzZdLHB0PVBbN10seHQ9UFs4XSxndD1QWzldLGR0PVBbMTBdLG10PVBbMTFdLGJ0PVBbMTJdLEN0PVBbMTNdLFN0PVBbMTRdLE50PVBbMTVdLEp0PVcqdXQtSypudCxHdD1XKmN0LVoqbnQsS3Q9VypwdC1rKm50LFl0PUsqY3QtWip1dCxWdD1LKnB0LWsqdXQsU2U9WipwdC1rKmN0LE9lPXh0KkN0LWd0KmJ0LEVlPXh0KlN0LWR0KmJ0LG1lPXh0Kk50LW10KmJ0LFRlPWd0KlN0LWR0KkN0LGJlPWd0Kk50LW10KkN0LEllPWR0Kk50LW10KlN0LHNlPUp0KkllLUd0KmJlK0t0KlRlK1l0Km1lLVZ0KkVlK1NlKk9lO3JldHVybiBzZT8oc2U9MS9zZSx4WzBdPSh1dCpJZS1jdCpiZStwdCpUZSkqc2UseFsxXT0oWipiZS1LKkllLWsqVGUpKnNlLHhbMl09KEN0KlNlLVN0KlZ0K050Kll0KSpzZSx4WzNdPShkdCpWdC1ndCpTZS1tdCpZdCkqc2UseFs0XT0oY3QqbWUtbnQqSWUtcHQqRWUpKnNlLHhbNV09KFcqSWUtWiptZStrKkVlKSpzZSx4WzZdPShTdCpLdC1idCpTZS1OdCpHdCkqc2UseFs3XT0oeHQqU2UtZHQqS3QrbXQqR3QpKnNlLHhbOF09KG50KmJlLXV0Km1lK3B0Kk9lKSpzZSx4WzldPShLKm1lLVcqYmUtaypPZSkqc2UseFsxMF09KGJ0KlZ0LUN0Kkt0K050Kkp0KSpzZSx4WzExXT0oZ3QqS3QteHQqVnQtbXQqSnQpKnNlLHhbMTJdPSh1dCpFZS1udCpUZS1jdCpPZSkqc2UseFsxM109KFcqVGUtSypFZStaKk9lKSpzZSx4WzE0XT0oQ3QqR3QtYnQqWXQtU3QqSnQpKnNlLHhbMTVdPSh4dCpZdC1ndCpHdCtkdCpKdCkqc2UseCk6bnVsbH1mdW5jdGlvbiBPKHgsUCl7dmFyIFc9UFswXSxLPVBbMV0sWj1QWzJdLGs9UFszXSxudD1QWzRdLHV0PVBbNV0sY3Q9UFs2XSxwdD1QWzddLHh0PVBbOF0sZ3Q9UFs5XSxkdD1QWzEwXSxtdD1QWzExXSxidD1QWzEyXSxDdD1QWzEzXSxTdD1QWzE0XSxOdD1QWzE1XTtyZXR1cm4geFswXT11dCooZHQqTnQtbXQqU3QpLWd0KihjdCpOdC1wdCpTdCkrQ3QqKGN0Km10LXB0KmR0KSx4WzFdPS0oSyooZHQqTnQtbXQqU3QpLWd0KihaKk50LWsqU3QpK0N0KihaKm10LWsqZHQpKSx4WzJdPUsqKGN0Kk50LXB0KlN0KS11dCooWipOdC1rKlN0KStDdCooWipwdC1rKmN0KSx4WzNdPS0oSyooY3QqbXQtcHQqZHQpLXV0KihaKm10LWsqZHQpK2d0KihaKnB0LWsqY3QpKSx4WzRdPS0obnQqKGR0Kk50LW10KlN0KS14dCooY3QqTnQtcHQqU3QpK2J0KihjdCptdC1wdCpkdCkpLHhbNV09VyooZHQqTnQtbXQqU3QpLXh0KihaKk50LWsqU3QpK2J0KihaKm10LWsqZHQpLHhbNl09LShXKihjdCpOdC1wdCpTdCktbnQqKFoqTnQtaypTdCkrYnQqKFoqcHQtaypjdCkpLHhbN109VyooY3QqbXQtcHQqZHQpLW50KihaKm10LWsqZHQpK3h0KihaKnB0LWsqY3QpLHhbOF09bnQqKGd0Kk50LW10KkN0KS14dCoodXQqTnQtcHQqQ3QpK2J0Kih1dCptdC1wdCpndCkseFs5XT0tKFcqKGd0Kk50LW10KkN0KS14dCooSypOdC1rKkN0KStidCooSyptdC1rKmd0KSkseFsxMF09VyoodXQqTnQtcHQqQ3QpLW50KihLKk50LWsqQ3QpK2J0KihLKnB0LWsqdXQpLHhbMTFdPS0oVyoodXQqbXQtcHQqZ3QpLW50KihLKm10LWsqZ3QpK3h0KihLKnB0LWsqdXQpKSx4WzEyXT0tKG50KihndCpTdC1kdCpDdCkteHQqKHV0KlN0LWN0KkN0KStidCoodXQqZHQtY3QqZ3QpKSx4WzEzXT1XKihndCpTdC1kdCpDdCkteHQqKEsqU3QtWipDdCkrYnQqKEsqZHQtWipndCkseFsxNF09LShXKih1dCpTdC1jdCpDdCktbnQqKEsqU3QtWipDdCkrYnQqKEsqY3QtWip1dCkpLHhbMTVdPVcqKHV0KmR0LWN0Kmd0KS1udCooSypkdC1aKmd0KSt4dCooSypjdC1aKnV0KSx4fWZ1bmN0aW9uIG0oeCl7dmFyIFA9eFswXSxXPXhbMV0sSz14WzJdLFo9eFszXSxrPXhbNF0sbnQ9eFs1XSx1dD14WzZdLGN0PXhbN10scHQ9eFs4XSx4dD14WzldLGd0PXhbMTBdLGR0PXhbMTFdLG10PXhbMTJdLGJ0PXhbMTNdLEN0PXhbMTRdLFN0PXhbMTVdLE50PVAqbnQtVyprLEp0PVAqdXQtSyprLEd0PVAqY3QtWiprLEt0PVcqdXQtSypudCxZdD1XKmN0LVoqbnQsVnQ9SypjdC1aKnV0LFNlPXB0KmJ0LXh0Km10LE9lPXB0KkN0LWd0Km10LEVlPXB0KlN0LWR0Km10LG1lPXh0KkN0LWd0KmJ0LFRlPXh0KlN0LWR0KmJ0LGJlPWd0KlN0LWR0KkN0O3JldHVybiBOdCpiZS1KdCpUZStHdCptZStLdCpFZS1ZdCpPZStWdCpTZX1mdW5jdGlvbiBiKHgsUCxXKXt2YXIgSz1QWzBdLFo9UFsxXSxrPVBbMl0sbnQ9UFszXSx1dD1QWzRdLGN0PVBbNV0scHQ9UFs2XSx4dD1QWzddLGd0PVBbOF0sZHQ9UFs5XSxtdD1QWzEwXSxidD1QWzExXSxDdD1QWzEyXSxTdD1QWzEzXSxOdD1QWzE0XSxKdD1QWzE1XSxHdD1XWzBdLEt0PVdbMV0sWXQ9V1syXSxWdD1XWzNdO3JldHVybiB4WzBdPUd0KksrS3QqdXQrWXQqZ3QrVnQqQ3QseFsxXT1HdCpaK0t0KmN0K1l0KmR0K1Z0KlN0LHhbMl09R3QqaytLdCpwdCtZdCptdCtWdCpOdCx4WzNdPUd0Km50K0t0Knh0K1l0KmJ0K1Z0Kkp0LEd0PVdbNF0sS3Q9V1s1XSxZdD1XWzZdLFZ0PVdbN10seFs0XT1HdCpLK0t0KnV0K1l0Kmd0K1Z0KkN0LHhbNV09R3QqWitLdCpjdCtZdCpkdCtWdCpTdCx4WzZdPUd0KmsrS3QqcHQrWXQqbXQrVnQqTnQseFs3XT1HdCpudCtLdCp4dCtZdCpidCtWdCpKdCxHdD1XWzhdLEt0PVdbOV0sWXQ9V1sxMF0sVnQ9V1sxMV0seFs4XT1HdCpLK0t0KnV0K1l0Kmd0K1Z0KkN0LHhbOV09R3QqWitLdCpjdCtZdCpkdCtWdCpTdCx4WzEwXT1HdCprK0t0KnB0K1l0Km10K1Z0Kk50LHhbMTFdPUd0Km50K0t0Knh0K1l0KmJ0K1Z0Kkp0LEd0PVdbMTJdLEt0PVdbMTNdLFl0PVdbMTRdLFZ0PVdbMTVdLHhbMTJdPUd0KksrS3QqdXQrWXQqZ3QrVnQqQ3QseFsxM109R3QqWitLdCpjdCtZdCpkdCtWdCpTdCx4WzE0XT1HdCprK0t0KnB0K1l0Km10K1Z0Kk50LHhbMTVdPUd0Km50K0t0Knh0K1l0KmJ0K1Z0Kkp0LHh9ZnVuY3Rpb24gTSh4LFAsVyl7dmFyIEs9V1swXSxaPVdbMV0saz1XWzJdLG50LHV0LGN0LHB0LHh0LGd0LGR0LG10LGJ0LEN0LFN0LE50O3JldHVybiBQPT09eD8oeFsxMl09UFswXSpLK1BbNF0qWitQWzhdKmsrUFsxMl0seFsxM109UFsxXSpLK1BbNV0qWitQWzldKmsrUFsxM10seFsxNF09UFsyXSpLK1BbNl0qWitQWzEwXSprK1BbMTRdLHhbMTVdPVBbM10qSytQWzddKlorUFsxMV0qaytQWzE1XSk6KG50PVBbMF0sdXQ9UFsxXSxjdD1QWzJdLHB0PVBbM10seHQ9UFs0XSxndD1QWzVdLGR0PVBbNl0sbXQ9UFs3XSxidD1QWzhdLEN0PVBbOV0sU3Q9UFsxMF0sTnQ9UFsxMV0seFswXT1udCx4WzFdPXV0LHhbMl09Y3QseFszXT1wdCx4WzRdPXh0LHhbNV09Z3QseFs2XT1kdCx4WzddPW10LHhbOF09YnQseFs5XT1DdCx4WzEwXT1TdCx4WzExXT1OdCx4WzEyXT1udCpLK3h0KlorYnQqaytQWzEyXSx4WzEzXT11dCpLK2d0KlorQ3QqaytQWzEzXSx4WzE0XT1jdCpLK2R0KlorU3QqaytQWzE0XSx4WzE1XT1wdCpLK210KlorTnQqaytQWzE1XSkseH1mdW5jdGlvbiB5KHgsUCxXKXt2YXIgSz1XWzBdLFo9V1sxXSxrPVdbMl07cmV0dXJuIHhbMF09UFswXSpLLHhbMV09UFsxXSpLLHhbMl09UFsyXSpLLHhbM109UFszXSpLLHhbNF09UFs0XSpaLHhbNV09UFs1XSpaLHhbNl09UFs2XSpaLHhbN109UFs3XSpaLHhbOF09UFs4XSprLHhbOV09UFs5XSprLHhbMTBdPVBbMTBdKmsseFsxMV09UFsxMV0qayx4WzEyXT1QWzEyXSx4WzEzXT1QWzEzXSx4WzE0XT1QWzE0XSx4WzE1XT1QWzE1XSx4fWZ1bmN0aW9uIFMoeCxQLFcsSyl7dmFyIFo9S1swXSxrPUtbMV0sbnQ9S1syXSx1dD1NYXRoLmh5cG90KFosayxudCksY3QscHQseHQsZ3QsZHQsbXQsYnQsQ3QsU3QsTnQsSnQsR3QsS3QsWXQsVnQsU2UsT2UsRWUsbWUsVGUsYmUsSWUsc2UsVmU7cmV0dXJuIHV0PG4uRVBTSUxPTj9udWxsOih1dD0xL3V0LFoqPXV0LGsqPXV0LG50Kj11dCxjdD1NYXRoLnNpbihXKSxwdD1NYXRoLmNvcyhXKSx4dD0xLXB0LGd0PVBbMF0sZHQ9UFsxXSxtdD1QWzJdLGJ0PVBbM10sQ3Q9UFs0XSxTdD1QWzVdLE50PVBbNl0sSnQ9UFs3XSxHdD1QWzhdLEt0PVBbOV0sWXQ9UFsxMF0sVnQ9UFsxMV0sU2U9WipaKnh0K3B0LE9lPWsqWip4dCtudCpjdCxFZT1udCpaKnh0LWsqY3QsbWU9WiprKnh0LW50KmN0LFRlPWsqayp4dCtwdCxiZT1udCprKnh0K1oqY3QsSWU9WipudCp4dCtrKmN0LHNlPWsqbnQqeHQtWipjdCxWZT1udCpudCp4dCtwdCx4WzBdPWd0KlNlK0N0Kk9lK0d0KkVlLHhbMV09ZHQqU2UrU3QqT2UrS3QqRWUseFsyXT1tdCpTZStOdCpPZStZdCpFZSx4WzNdPWJ0KlNlK0p0Kk9lK1Z0KkVlLHhbNF09Z3QqbWUrQ3QqVGUrR3QqYmUseFs1XT1kdCptZStTdCpUZStLdCpiZSx4WzZdPW10Km1lK050KlRlK1l0KmJlLHhbN109YnQqbWUrSnQqVGUrVnQqYmUseFs4XT1ndCpJZStDdCpzZStHdCpWZSx4WzldPWR0KkllK1N0KnNlK0t0KlZlLHhbMTBdPW10KkllK050KnNlK1l0KlZlLHhbMTFdPWJ0KkllK0p0KnNlK1Z0KlZlLFAhPT14JiYoeFsxMl09UFsxMl0seFsxM109UFsxM10seFsxNF09UFsxNF0seFsxNV09UFsxNV0pLHgpfWZ1bmN0aW9uIHMoeCxQLFcpe3ZhciBLPU1hdGguc2luKFcpLFo9TWF0aC5jb3MoVyksaz1QWzRdLG50PVBbNV0sdXQ9UFs2XSxjdD1QWzddLHB0PVBbOF0seHQ9UFs5XSxndD1QWzEwXSxkdD1QWzExXTtyZXR1cm4gUCE9PXgmJih4WzBdPVBbMF0seFsxXT1QWzFdLHhbMl09UFsyXSx4WzNdPVBbM10seFsxMl09UFsxMl0seFsxM109UFsxM10seFsxNF09UFsxNF0seFsxNV09UFsxNV0pLHhbNF09aypaK3B0KksseFs1XT1udCpaK3h0KksseFs2XT11dCpaK2d0KksseFs3XT1jdCpaK2R0KksseFs4XT1wdCpaLWsqSyx4WzldPXh0KlotbnQqSyx4WzEwXT1ndCpaLXV0KksseFsxMV09ZHQqWi1jdCpLLHh9ZnVuY3Rpb24gYyh4LFAsVyl7dmFyIEs9TWF0aC5zaW4oVyksWj1NYXRoLmNvcyhXKSxrPVBbMF0sbnQ9UFsxXSx1dD1QWzJdLGN0PVBbM10scHQ9UFs4XSx4dD1QWzldLGd0PVBbMTBdLGR0PVBbMTFdO3JldHVybiBQIT09eCYmKHhbNF09UFs0XSx4WzVdPVBbNV0seFs2XT1QWzZdLHhbN109UFs3XSx4WzEyXT1QWzEyXSx4WzEzXT1QWzEzXSx4WzE0XT1QWzE0XSx4WzE1XT1QWzE1XSkseFswXT1rKlotcHQqSyx4WzFdPW50KloteHQqSyx4WzJdPXV0KlotZ3QqSyx4WzNdPWN0KlotZHQqSyx4WzhdPWsqSytwdCpaLHhbOV09bnQqSyt4dCpaLHhbMTBdPXV0KksrZ3QqWix4WzExXT1jdCpLK2R0KloseH1mdW5jdGlvbiBsKHgsUCxXKXt2YXIgSz1NYXRoLnNpbihXKSxaPU1hdGguY29zKFcpLGs9UFswXSxudD1QWzFdLHV0PVBbMl0sY3Q9UFszXSxwdD1QWzRdLHh0PVBbNV0sZ3Q9UFs2XSxkdD1QWzddO3JldHVybiBQIT09eCYmKHhbOF09UFs4XSx4WzldPVBbOV0seFsxMF09UFsxMF0seFsxMV09UFsxMV0seFsxMl09UFsxMl0seFsxM109UFsxM10seFsxNF09UFsxNF0seFsxNV09UFsxNV0pLHhbMF09aypaK3B0KksseFsxXT1udCpaK3h0KksseFsyXT11dCpaK2d0KksseFszXT1jdCpaK2R0KksseFs0XT1wdCpaLWsqSyx4WzVdPXh0KlotbnQqSyx4WzZdPWd0KlotdXQqSyx4WzddPWR0KlotY3QqSyx4fWZ1bmN0aW9uIHYoeCxQKXtyZXR1cm4geFswXT0xLHhbMV09MCx4WzJdPTAseFszXT0wLHhbNF09MCx4WzVdPTEseFs2XT0wLHhbN109MCx4WzhdPTAseFs5XT0wLHhbMTBdPTEseFsxMV09MCx4WzEyXT1QWzBdLHhbMTNdPVBbMV0seFsxNF09UFsyXSx4WzE1XT0xLHh9ZnVuY3Rpb24gVCh4LFApe3JldHVybiB4WzBdPVBbMF0seFsxXT0wLHhbMl09MCx4WzNdPTAseFs0XT0wLHhbNV09UFsxXSx4WzZdPTAseFs3XT0wLHhbOF09MCx4WzldPTAseFsxMF09UFsyXSx4WzExXT0wLHhbMTJdPTAseFsxM109MCx4WzE0XT0wLHhbMTVdPTEseH1mdW5jdGlvbiBSKHgsUCxXKXt2YXIgSz1XWzBdLFo9V1sxXSxrPVdbMl0sbnQ9TWF0aC5oeXBvdChLLFosayksdXQsY3QscHQ7cmV0dXJuIG50PG4uRVBTSUxPTj9udWxsOihudD0xL250LEsqPW50LFoqPW50LGsqPW50LHV0PU1hdGguc2luKFApLGN0PU1hdGguY29zKFApLHB0PTEtY3QseFswXT1LKksqcHQrY3QseFsxXT1aKksqcHQrayp1dCx4WzJdPWsqSypwdC1aKnV0LHhbM109MCx4WzRdPUsqWipwdC1rKnV0LHhbNV09WipaKnB0K2N0LHhbNl09aypaKnB0K0sqdXQseFs3XT0wLHhbOF09SyprKnB0K1oqdXQseFs5XT1aKmsqcHQtSyp1dCx4WzEwXT1rKmsqcHQrY3QseFsxMV09MCx4WzEyXT0wLHhbMTNdPTAseFsxNF09MCx4WzE1XT0xLHgpfWZ1bmN0aW9uIEwoeCxQKXt2YXIgVz1NYXRoLnNpbihQKSxLPU1hdGguY29zKFApO3JldHVybiB4WzBdPTEseFsxXT0wLHhbMl09MCx4WzNdPTAseFs0XT0wLHhbNV09Syx4WzZdPVcseFs3XT0wLHhbOF09MCx4WzldPS1XLHhbMTBdPUsseFsxMV09MCx4WzEyXT0wLHhbMTNdPTAseFsxNF09MCx4WzE1XT0xLHh9ZnVuY3Rpb24gTih4LFApe3ZhciBXPU1hdGguc2luKFApLEs9TWF0aC5jb3MoUCk7cmV0dXJuIHhbMF09Syx4WzFdPTAseFsyXT0tVyx4WzNdPTAseFs0XT0wLHhbNV09MSx4WzZdPTAseFs3XT0wLHhbOF09Vyx4WzldPTAseFsxMF09Syx4WzExXT0wLHhbMTJdPTAseFsxM109MCx4WzE0XT0wLHhbMTVdPTEseH1mdW5jdGlvbiBBKHgsUCl7dmFyIFc9TWF0aC5zaW4oUCksSz1NYXRoLmNvcyhQKTtyZXR1cm4geFswXT1LLHhbMV09Vyx4WzJdPTAseFszXT0wLHhbNF09LVcseFs1XT1LLHhbNl09MCx4WzddPTAseFs4XT0wLHhbOV09MCx4WzEwXT0xLHhbMTFdPTAseFsxMl09MCx4WzEzXT0wLHhbMTRdPTAseFsxNV09MSx4fWZ1bmN0aW9uIHcoeCxQLFcpe3ZhciBLPVBbMF0sWj1QWzFdLGs9UFsyXSxudD1QWzNdLHV0PUsrSyxjdD1aK1oscHQ9aytrLHh0PUsqdXQsZ3Q9SypjdCxkdD1LKnB0LG10PVoqY3QsYnQ9WipwdCxDdD1rKnB0LFN0PW50KnV0LE50PW50KmN0LEp0PW50KnB0O3JldHVybiB4WzBdPTEtKG10K0N0KSx4WzFdPWd0K0p0LHhbMl09ZHQtTnQseFszXT0wLHhbNF09Z3QtSnQseFs1XT0xLSh4dCtDdCkseFs2XT1idCtTdCx4WzddPTAseFs4XT1kdCtOdCx4WzldPWJ0LVN0LHhbMTBdPTEtKHh0K210KSx4WzExXT0wLHhbMTJdPVdbMF0seFsxM109V1sxXSx4WzE0XT1XWzJdLHhbMTVdPTEseH1mdW5jdGlvbiBCKHgsUCl7dmFyIFc9bmV3IG4uQVJSQVlfVFlQRSgzKSxLPS1QWzBdLFo9LVBbMV0saz0tUFsyXSxudD1QWzNdLHV0PVBbNF0sY3Q9UFs1XSxwdD1QWzZdLHh0PVBbN10sZ3Q9SypLK1oqWitrKmsrbnQqbnQ7cmV0dXJuIGd0PjA/KFdbMF09KHV0Km50K3h0KksrY3Qqay1wdCpaKSoyL2d0LFdbMV09KGN0Km50K3h0KlorcHQqSy11dCprKSoyL2d0LFdbMl09KHB0Km50K3h0KmsrdXQqWi1jdCpLKSoyL2d0KTooV1swXT0odXQqbnQreHQqSytjdCprLXB0KlopKjIsV1sxXT0oY3QqbnQreHQqWitwdCpLLXV0KmspKjIsV1syXT0ocHQqbnQreHQqayt1dCpaLWN0KkspKjIpLHcoeCxQLFcpLHh9ZnVuY3Rpb24gRCh4LFApe3JldHVybiB4WzBdPVBbMTJdLHhbMV09UFsxM10seFsyXT1QWzE0XSx4fWZ1bmN0aW9uIEkoeCxQKXt2YXIgVz1QWzBdLEs9UFsxXSxaPVBbMl0saz1QWzRdLG50PVBbNV0sdXQ9UFs2XSxjdD1QWzhdLHB0PVBbOV0seHQ9UFsxMF07cmV0dXJuIHhbMF09TWF0aC5oeXBvdChXLEssWikseFsxXT1NYXRoLmh5cG90KGssbnQsdXQpLHhbMl09TWF0aC5oeXBvdChjdCxwdCx4dCkseH1mdW5jdGlvbiBqKHgsUCl7dmFyIFc9bmV3IG4uQVJSQVlfVFlQRSgzKTtJKFcsUCk7dmFyIEs9MS9XWzBdLFo9MS9XWzFdLGs9MS9XWzJdLG50PVBbMF0qSyx1dD1QWzFdKlosY3Q9UFsyXSprLHB0PVBbNF0qSyx4dD1QWzVdKlosZ3Q9UFs2XSprLGR0PVBbOF0qSyxtdD1QWzldKlosYnQ9UFsxMF0qayxDdD1udCt4dCtidCxTdD0wO3JldHVybiBDdD4wPyhTdD1NYXRoLnNxcnQoQ3QrMSkqMix4WzNdPS4yNSpTdCx4WzBdPShndC1tdCkvU3QseFsxXT0oZHQtY3QpL1N0LHhbMl09KHV0LXB0KS9TdCk6bnQ+eHQmJm50PmJ0PyhTdD1NYXRoLnNxcnQoMStudC14dC1idCkqMix4WzNdPShndC1tdCkvU3QseFswXT0uMjUqU3QseFsxXT0odXQrcHQpL1N0LHhbMl09KGR0K2N0KS9TdCk6eHQ+YnQ/KFN0PU1hdGguc3FydCgxK3h0LW50LWJ0KSoyLHhbM109KGR0LWN0KS9TdCx4WzBdPSh1dCtwdCkvU3QseFsxXT0uMjUqU3QseFsyXT0oZ3QrbXQpL1N0KTooU3Q9TWF0aC5zcXJ0KDErYnQtbnQteHQpKjIseFszXT0odXQtcHQpL1N0LHhbMF09KGR0K2N0KS9TdCx4WzFdPShndCttdCkvU3QseFsyXT0uMjUqU3QpLHh9ZnVuY3Rpb24gVih4LFAsVyxLKXt2YXIgWj1QWzBdLGs9UFsxXSxudD1QWzJdLHV0PVBbM10sY3Q9WitaLHB0PWsrayx4dD1udCtudCxndD1aKmN0LGR0PVoqcHQsbXQ9Wip4dCxidD1rKnB0LEN0PWsqeHQsU3Q9bnQqeHQsTnQ9dXQqY3QsSnQ9dXQqcHQsR3Q9dXQqeHQsS3Q9S1swXSxZdD1LWzFdLFZ0PUtbMl07cmV0dXJuIHhbMF09KDEtKGJ0K1N0KSkqS3QseFsxXT0oZHQrR3QpKkt0LHhbMl09KG10LUp0KSpLdCx4WzNdPTAseFs0XT0oZHQtR3QpKll0LHhbNV09KDEtKGd0K1N0KSkqWXQseFs2XT0oQ3QrTnQpKll0LHhbN109MCx4WzhdPShtdCtKdCkqVnQseFs5XT0oQ3QtTnQpKlZ0LHhbMTBdPSgxLShndCtidCkpKlZ0LHhbMTFdPTAseFsxMl09V1swXSx4WzEzXT1XWzFdLHhbMTRdPVdbMl0seFsxNV09MSx4fWZ1bmN0aW9uIEooeCxQLFcsSyxaKXt2YXIgaz1QWzBdLG50PVBbMV0sdXQ9UFsyXSxjdD1QWzNdLHB0PWsrayx4dD1udCtudCxndD11dCt1dCxkdD1rKnB0LG10PWsqeHQsYnQ9aypndCxDdD1udCp4dCxTdD1udCpndCxOdD11dCpndCxKdD1jdCpwdCxHdD1jdCp4dCxLdD1jdCpndCxZdD1LWzBdLFZ0PUtbMV0sU2U9S1syXSxPZT1aWzBdLEVlPVpbMV0sbWU9WlsyXSxUZT0oMS0oQ3QrTnQpKSpZdCxiZT0obXQrS3QpKll0LEllPShidC1HdCkqWXQsc2U9KG10LUt0KSpWdCxWZT0oMS0oZHQrTnQpKSpWdCxMcj0oU3QrSnQpKlZ0LFlyPShidCtHdCkqU2UsYWk9KFN0LUp0KSpTZSxsaT0oMS0oZHQrQ3QpKSpTZTtyZXR1cm4geFswXT1UZSx4WzFdPWJlLHhbMl09SWUseFszXT0wLHhbNF09c2UseFs1XT1WZSx4WzZdPUxyLHhbN109MCx4WzhdPVlyLHhbOV09YWkseFsxMF09bGkseFsxMV09MCx4WzEyXT1XWzBdK09lLShUZSpPZStzZSpFZStZciptZSkseFsxM109V1sxXStFZS0oYmUqT2UrVmUqRWUrYWkqbWUpLHhbMTRdPVdbMl0rbWUtKEllKk9lK0xyKkVlK2xpKm1lKSx4WzE1XT0xLHh9ZnVuY3Rpb24gXyh4LFApe3ZhciBXPVBbMF0sSz1QWzFdLFo9UFsyXSxrPVBbM10sbnQ9VytXLHV0PUsrSyxjdD1aK1oscHQ9VypudCx4dD1LKm50LGd0PUsqdXQsZHQ9WipudCxtdD1aKnV0LGJ0PVoqY3QsQ3Q9aypudCxTdD1rKnV0LE50PWsqY3Q7cmV0dXJuIHhbMF09MS1ndC1idCx4WzFdPXh0K050LHhbMl09ZHQtU3QseFszXT0wLHhbNF09eHQtTnQseFs1XT0xLXB0LWJ0LHhbNl09bXQrQ3QseFs3XT0wLHhbOF09ZHQrU3QseFs5XT1tdC1DdCx4WzEwXT0xLXB0LWd0LHhbMTFdPTAseFsxMl09MCx4WzEzXT0wLHhbMTRdPTAseFsxNV09MSx4fWZ1bmN0aW9uIHN0KHgsUCxXLEssWixrLG50KXt2YXIgdXQ9MS8oVy1QKSxjdD0xLyhaLUspLHB0PTEvKGstbnQpO3JldHVybiB4WzBdPWsqMip1dCx4WzFdPTAseFsyXT0wLHhbM109MCx4WzRdPTAseFs1XT1rKjIqY3QseFs2XT0wLHhbN109MCx4WzhdPShXK1ApKnV0LHhbOV09KForSykqY3QseFsxMF09KG50K2spKnB0LHhbMTFdPS0xLHhbMTJdPTAseFsxM109MCx4WzE0XT1udCprKjIqcHQseFsxNV09MCx4fWZ1bmN0aW9uIEcoeCxQLFcsSyxaKXt2YXIgaz0xL01hdGgudGFuKFAvMiksbnQ7cmV0dXJuIHhbMF09ay9XLHhbMV09MCx4WzJdPTAseFszXT0wLHhbNF09MCx4WzVdPWsseFs2XT0wLHhbN109MCx4WzhdPTAseFs5XT0wLHhbMTFdPS0xLHhbMTJdPTAseFsxM109MCx4WzE1XT0wLFohPW51bGwmJlohPT0xLzA/KG50PTEvKEstWikseFsxMF09KForSykqbnQseFsxNF09MipaKksqbnQpOih4WzEwXT0tMSx4WzE0XT0tMipLKSx4fWZ1bmN0aW9uIFkoeCxQLFcsSyl7dmFyIFo9TWF0aC50YW4oUC51cERlZ3JlZXMqTWF0aC5QSS8xODApLGs9TWF0aC50YW4oUC5kb3duRGVncmVlcypNYXRoLlBJLzE4MCksbnQ9TWF0aC50YW4oUC5sZWZ0RGVncmVlcypNYXRoLlBJLzE4MCksdXQ9TWF0aC50YW4oUC5yaWdodERlZ3JlZXMqTWF0aC5QSS8xODApLGN0PTIvKG50K3V0KSxwdD0yLyhaK2spO3JldHVybiB4WzBdPWN0LHhbMV09MCx4WzJdPTAseFszXT0wLHhbNF09MCx4WzVdPXB0LHhbNl09MCx4WzddPTAseFs4XT0tKChudC11dCkqY3QqLjUpLHhbOV09KFotaykqcHQqLjUseFsxMF09Sy8oVy1LKSx4WzExXT0tMSx4WzEyXT0wLHhbMTNdPTAseFsxNF09SypXLyhXLUspLHhbMTVdPTAseH1mdW5jdGlvbiBydCh4LFAsVyxLLFosayxudCl7dmFyIHV0PTEvKFAtVyksY3Q9MS8oSy1aKSxwdD0xLyhrLW50KTtyZXR1cm4geFswXT0tMip1dCx4WzFdPTAseFsyXT0wLHhbM109MCx4WzRdPTAseFs1XT0tMipjdCx4WzZdPTAseFs3XT0wLHhbOF09MCx4WzldPTAseFsxMF09MipwdCx4WzExXT0wLHhbMTJdPShQK1cpKnV0LHhbMTNdPShaK0spKmN0LHhbMTRdPShudCtrKSpwdCx4WzE1XT0xLHh9ZnVuY3Rpb24gb3QoeCxQLFcsSyl7dmFyIFosayxudCx1dCxjdCxwdCx4dCxndCxkdCxtdCxidD1QWzBdLEN0PVBbMV0sU3Q9UFsyXSxOdD1LWzBdLEp0PUtbMV0sR3Q9S1syXSxLdD1XWzBdLFl0PVdbMV0sVnQ9V1syXTtyZXR1cm4gTWF0aC5hYnMoYnQtS3QpPG4uRVBTSUxPTiYmTWF0aC5hYnMoQ3QtWXQpPG4uRVBTSUxPTiYmTWF0aC5hYnMoU3QtVnQpPG4uRVBTSUxPTj9kKHgpOih4dD1idC1LdCxndD1DdC1ZdCxkdD1TdC1WdCxtdD0xL01hdGguaHlwb3QoeHQsZ3QsZHQpLHh0Kj1tdCxndCo9bXQsZHQqPW10LFo9SnQqZHQtR3QqZ3Qsaz1HdCp4dC1OdCpkdCxudD1OdCpndC1KdCp4dCxtdD1NYXRoLmh5cG90KFosayxudCksbXQ/KG10PTEvbXQsWio9bXQsayo9bXQsbnQqPW10KTooWj0wLGs9MCxudD0wKSx1dD1ndCpudC1kdCprLGN0PWR0KloteHQqbnQscHQ9eHQqay1ndCpaLG10PU1hdGguaHlwb3QodXQsY3QscHQpLG10PyhtdD0xL210LHV0Kj1tdCxjdCo9bXQscHQqPW10KToodXQ9MCxjdD0wLHB0PTApLHhbMF09Wix4WzFdPXV0LHhbMl09eHQseFszXT0wLHhbNF09ayx4WzVdPWN0LHhbNl09Z3QseFs3XT0wLHhbOF09bnQseFs5XT1wdCx4WzEwXT1kdCx4WzExXT0wLHhbMTJdPS0oWipidCtrKkN0K250KlN0KSx4WzEzXT0tKHV0KmJ0K2N0KkN0K3B0KlN0KSx4WzE0XT0tKHh0KmJ0K2d0KkN0K2R0KlN0KSx4WzE1XT0xLHgpfWZ1bmN0aW9uIGF0KHgsUCxXLEspe3ZhciBaPVBbMF0saz1QWzFdLG50PVBbMl0sdXQ9S1swXSxjdD1LWzFdLHB0PUtbMl0seHQ9Wi1XWzBdLGd0PWstV1sxXSxkdD1udC1XWzJdLG10PXh0Knh0K2d0Kmd0K2R0KmR0O210PjAmJihtdD0xL01hdGguc3FydChtdCkseHQqPW10LGd0Kj1tdCxkdCo9bXQpO3ZhciBidD1jdCpkdC1wdCpndCxDdD1wdCp4dC11dCpkdCxTdD11dCpndC1jdCp4dDtyZXR1cm4gbXQ9YnQqYnQrQ3QqQ3QrU3QqU3QsbXQ+MCYmKG10PTEvTWF0aC5zcXJ0KG10KSxidCo9bXQsQ3QqPW10LFN0Kj1tdCkseFswXT1idCx4WzFdPUN0LHhbMl09U3QseFszXT0wLHhbNF09Z3QqU3QtZHQqQ3QseFs1XT1kdCpidC14dCpTdCx4WzZdPXh0KkN0LWd0KmJ0LHhbN109MCx4WzhdPXh0LHhbOV09Z3QseFsxMF09ZHQseFsxMV09MCx4WzEyXT1aLHhbMTNdPWsseFsxNF09bnQseFsxNV09MSx4fWZ1bmN0aW9uIGh0KHgpe3JldHVybiJtYXQ0KCIreFswXSsiLCAiK3hbMV0rIiwgIit4WzJdKyIsICIreFszXSsiLCAiK3hbNF0rIiwgIit4WzVdKyIsICIreFs2XSsiLCAiK3hbN10rIiwgIit4WzhdKyIsICIreFs5XSsiLCAiK3hbMTBdKyIsICIreFsxMV0rIiwgIit4WzEyXSsiLCAiK3hbMTNdKyIsICIreFsxNF0rIiwgIit4WzE1XSsiKSJ9ZnVuY3Rpb24gaXQoeCl7cmV0dXJuIE1hdGguaHlwb3QoeFswXSx4WzFdLHhbMl0seFszXSx4WzRdLHhbNV0seFs2XSx4WzddLHhbOF0seFs5XSx4WzEwXSx4WzExXSx4WzEyXSx4WzEzXSx4WzE0XSx4WzE1XSl9ZnVuY3Rpb24gTXQoeCxQLFcpe3JldHVybiB4WzBdPVBbMF0rV1swXSx4WzFdPVBbMV0rV1sxXSx4WzJdPVBbMl0rV1syXSx4WzNdPVBbM10rV1szXSx4WzRdPVBbNF0rV1s0XSx4WzVdPVBbNV0rV1s1XSx4WzZdPVBbNl0rV1s2XSx4WzddPVBbN10rV1s3XSx4WzhdPVBbOF0rV1s4XSx4WzldPVBbOV0rV1s5XSx4WzEwXT1QWzEwXStXWzEwXSx4WzExXT1QWzExXStXWzExXSx4WzEyXT1QWzEyXStXWzEyXSx4WzEzXT1QWzEzXStXWzEzXSx4WzE0XT1QWzE0XStXWzE0XSx4WzE1XT1QWzE1XStXWzE1XSx4fWZ1bmN0aW9uIE90KHgsUCxXKXtyZXR1cm4geFswXT1QWzBdLVdbMF0seFsxXT1QWzFdLVdbMV0seFsyXT1QWzJdLVdbMl0seFszXT1QWzNdLVdbM10seFs0XT1QWzRdLVdbNF0seFs1XT1QWzVdLVdbNV0seFs2XT1QWzZdLVdbNl0seFs3XT1QWzddLVdbN10seFs4XT1QWzhdLVdbOF0seFs5XT1QWzldLVdbOV0seFsxMF09UFsxMF0tV1sxMF0seFsxMV09UFsxMV0tV1sxMV0seFsxMl09UFsxMl0tV1sxMl0seFsxM109UFsxM10tV1sxM10seFsxNF09UFsxNF0tV1sxNF0seFsxNV09UFsxNV0tV1sxNV0seH1mdW5jdGlvbiBVKHgsUCxXKXtyZXR1cm4geFswXT1QWzBdKlcseFsxXT1QWzFdKlcseFsyXT1QWzJdKlcseFszXT1QWzNdKlcseFs0XT1QWzRdKlcseFs1XT1QWzVdKlcseFs2XT1QWzZdKlcseFs3XT1QWzddKlcseFs4XT1QWzhdKlcseFs5XT1QWzldKlcseFsxMF09UFsxMF0qVyx4WzExXT1QWzExXSpXLHhbMTJdPVBbMTJdKlcseFsxM109UFsxM10qVyx4WzE0XT1QWzE0XSpXLHhbMTVdPVBbMTVdKlcseH1mdW5jdGlvbiAkKHgsUCxXLEspe3JldHVybiB4WzBdPVBbMF0rV1swXSpLLHhbMV09UFsxXStXWzFdKksseFsyXT1QWzJdK1dbMl0qSyx4WzNdPVBbM10rV1szXSpLLHhbNF09UFs0XStXWzRdKksseFs1XT1QWzVdK1dbNV0qSyx4WzZdPVBbNl0rV1s2XSpLLHhbN109UFs3XStXWzddKksseFs4XT1QWzhdK1dbOF0qSyx4WzldPVBbOV0rV1s5XSpLLHhbMTBdPVBbMTBdK1dbMTBdKksseFsxMV09UFsxMV0rV1sxMV0qSyx4WzEyXT1QWzEyXStXWzEyXSpLLHhbMTNdPVBbMTNdK1dbMTNdKksseFsxNF09UFsxNF0rV1sxNF0qSyx4WzE1XT1QWzE1XStXWzE1XSpLLHh9ZnVuY3Rpb24gUSh4LFApe3JldHVybiB4WzBdPT09UFswXSYmeFsxXT09PVBbMV0mJnhbMl09PT1QWzJdJiZ4WzNdPT09UFszXSYmeFs0XT09PVBbNF0mJnhbNV09PT1QWzVdJiZ4WzZdPT09UFs2XSYmeFs3XT09PVBbN10mJnhbOF09PT1QWzhdJiZ4WzldPT09UFs5XSYmeFsxMF09PT1QWzEwXSYmeFsxMV09PT1QWzExXSYmeFsxMl09PT1QWzEyXSYmeFsxM109PT1QWzEzXSYmeFsxNF09PT1QWzE0XSYmeFsxNV09PT1QWzE1XX1mdW5jdGlvbiB0dCh4LFApe3ZhciBXPXhbMF0sSz14WzFdLFo9eFsyXSxrPXhbM10sbnQ9eFs0XSx1dD14WzVdLGN0PXhbNl0scHQ9eFs3XSx4dD14WzhdLGd0PXhbOV0sZHQ9eFsxMF0sbXQ9eFsxMV0sYnQ9eFsxMl0sQ3Q9eFsxM10sU3Q9eFsxNF0sTnQ9eFsxNV0sSnQ9UFswXSxHdD1QWzFdLEt0PVBbMl0sWXQ9UFszXSxWdD1QWzRdLFNlPVBbNV0sT2U9UFs2XSxFZT1QWzddLG1lPVBbOF0sVGU9UFs5XSxiZT1QWzEwXSxJZT1QWzExXSxzZT1QWzEyXSxWZT1QWzEzXSxMcj1QWzE0XSxZcj1QWzE1XTtyZXR1cm4gTWF0aC5hYnMoVy1KdCk8PW4uRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKFcpLE1hdGguYWJzKEp0KSkmJk1hdGguYWJzKEstR3QpPD1uLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhLKSxNYXRoLmFicyhHdCkpJiZNYXRoLmFicyhaLUt0KTw9bi5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoWiksTWF0aC5hYnMoS3QpKSYmTWF0aC5hYnMoay1ZdCk8PW4uRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKGspLE1hdGguYWJzKFl0KSkmJk1hdGguYWJzKG50LVZ0KTw9bi5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMobnQpLE1hdGguYWJzKFZ0KSkmJk1hdGguYWJzKHV0LVNlKTw9bi5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnModXQpLE1hdGguYWJzKFNlKSkmJk1hdGguYWJzKGN0LU9lKTw9bi5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoY3QpLE1hdGguYWJzKE9lKSkmJk1hdGguYWJzKHB0LUVlKTw9bi5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMocHQpLE1hdGguYWJzKEVlKSkmJk1hdGguYWJzKHh0LW1lKTw9bi5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoeHQpLE1hdGguYWJzKG1lKSkmJk1hdGguYWJzKGd0LVRlKTw9bi5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoZ3QpLE1hdGguYWJzKFRlKSkmJk1hdGguYWJzKGR0LWJlKTw9bi5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoZHQpLE1hdGguYWJzKGJlKSkmJk1hdGguYWJzKG10LUllKTw9bi5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMobXQpLE1hdGguYWJzKEllKSkmJk1hdGguYWJzKGJ0LXNlKTw9bi5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoYnQpLE1hdGguYWJzKHNlKSkmJk1hdGguYWJzKEN0LVZlKTw9bi5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoQ3QpLE1hdGguYWJzKFZlKSkmJk1hdGguYWJzKFN0LUxyKTw9bi5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoU3QpLE1hdGguYWJzKExyKSkmJk1hdGguYWJzKE50LVlyKTw9bi5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoTnQpLE1hdGguYWJzKFlyKSl9dmFyIEY9YixIPU90fSxmdW5jdGlvbihnLGUsdCl7dC5yKGUpLHQuZChlLCJjcmVhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIHV9KSx0LmQoZSwiaWRlbnRpdHkiLGZ1bmN0aW9uKCl7cmV0dXJuIGF9KSx0LmQoZSwic2V0QXhpc0FuZ2xlIixmdW5jdGlvbigpe3JldHVybiBkfSksdC5kKGUsImdldEF4aXNBbmdsZSIsZnVuY3Rpb24oKXtyZXR1cm4gRX0pLHQuZChlLCJnZXRBbmdsZSIsZnVuY3Rpb24oKXtyZXR1cm4gcH0pLHQuZChlLCJtdWx0aXBseSIsZnVuY3Rpb24oKXtyZXR1cm4gT30pLHQuZChlLCJyb3RhdGVYIixmdW5jdGlvbigpe3JldHVybiBtfSksdC5kKGUsInJvdGF0ZVkiLGZ1bmN0aW9uKCl7cmV0dXJuIGJ9KSx0LmQoZSwicm90YXRlWiIsZnVuY3Rpb24oKXtyZXR1cm4gTX0pLHQuZChlLCJjYWxjdWxhdGVXIixmdW5jdGlvbigpe3JldHVybiB5fSksdC5kKGUsImV4cCIsZnVuY3Rpb24oKXtyZXR1cm4gU30pLHQuZChlLCJsbiIsZnVuY3Rpb24oKXtyZXR1cm4gc30pLHQuZChlLCJwb3ciLGZ1bmN0aW9uKCl7cmV0dXJuIGN9KSx0LmQoZSwic2xlcnAiLGZ1bmN0aW9uKCl7cmV0dXJuIGx9KSx0LmQoZSwicmFuZG9tIixmdW5jdGlvbigpe3JldHVybiB2fSksdC5kKGUsImludmVydCIsZnVuY3Rpb24oKXtyZXR1cm4gVH0pLHQuZChlLCJjb25qdWdhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIFJ9KSx0LmQoZSwiZnJvbU1hdDMiLGZ1bmN0aW9uKCl7cmV0dXJuIEx9KSx0LmQoZSwiZnJvbUV1bGVyIixmdW5jdGlvbigpe3JldHVybiBOfSksdC5kKGUsInN0ciIsZnVuY3Rpb24oKXtyZXR1cm4gQX0pLHQuZChlLCJjbG9uZSIsZnVuY3Rpb24oKXtyZXR1cm4gd30pLHQuZChlLCJmcm9tVmFsdWVzIixmdW5jdGlvbigpe3JldHVybiBCfSksdC5kKGUsImNvcHkiLGZ1bmN0aW9uKCl7cmV0dXJuIER9KSx0LmQoZSwic2V0IixmdW5jdGlvbigpe3JldHVybiBJfSksdC5kKGUsImFkZCIsZnVuY3Rpb24oKXtyZXR1cm4gan0pLHQuZChlLCJtdWwiLGZ1bmN0aW9uKCl7cmV0dXJuIFZ9KSx0LmQoZSwic2NhbGUiLGZ1bmN0aW9uKCl7cmV0dXJuIEp9KSx0LmQoZSwiZG90IixmdW5jdGlvbigpe3JldHVybiBffSksdC5kKGUsImxlcnAiLGZ1bmN0aW9uKCl7cmV0dXJuIHN0fSksdC5kKGUsImxlbmd0aCIsZnVuY3Rpb24oKXtyZXR1cm4gR30pLHQuZChlLCJsZW4iLGZ1bmN0aW9uKCl7cmV0dXJuIFl9KSx0LmQoZSwic3F1YXJlZExlbmd0aCIsZnVuY3Rpb24oKXtyZXR1cm4gcnR9KSx0LmQoZSwic3FyTGVuIixmdW5jdGlvbigpe3JldHVybiBvdH0pLHQuZChlLCJub3JtYWxpemUiLGZ1bmN0aW9uKCl7cmV0dXJuIGF0fSksdC5kKGUsImV4YWN0RXF1YWxzIixmdW5jdGlvbigpe3JldHVybiBodH0pLHQuZChlLCJlcXVhbHMiLGZ1bmN0aW9uKCl7cmV0dXJuIGl0fSksdC5kKGUsInJvdGF0aW9uVG8iLGZ1bmN0aW9uKCl7cmV0dXJuIE10fSksdC5kKGUsInNxbGVycCIsZnVuY3Rpb24oKXtyZXR1cm4gT3R9KSx0LmQoZSwic2V0QXhlcyIsZnVuY3Rpb24oKXtyZXR1cm4gVX0pO3ZhciBuPXQoMiksaT10KDUpLGY9dCg4KSxoPXQoOSk7ZnVuY3Rpb24gdSgpe3ZhciAkPW5ldyBuLkFSUkFZX1RZUEUoNCk7cmV0dXJuIG4uQVJSQVlfVFlQRSE9RmxvYXQzMkFycmF5JiYoJFswXT0wLCRbMV09MCwkWzJdPTApLCRbM109MSwkfWZ1bmN0aW9uIGEoJCl7cmV0dXJuICRbMF09MCwkWzFdPTAsJFsyXT0wLCRbM109MSwkfWZ1bmN0aW9uIGQoJCxRLHR0KXt0dD10dCouNTt2YXIgRj1NYXRoLnNpbih0dCk7cmV0dXJuICRbMF09RipRWzBdLCRbMV09RipRWzFdLCRbMl09RipRWzJdLCRbM109TWF0aC5jb3ModHQpLCR9ZnVuY3Rpb24gRSgkLFEpe3ZhciB0dD1NYXRoLmFjb3MoUVszXSkqMixGPU1hdGguc2luKHR0LzIpO3JldHVybiBGPm4uRVBTSUxPTj8oJFswXT1RWzBdL0YsJFsxXT1RWzFdL0YsJFsyXT1RWzJdL0YpOigkWzBdPTEsJFsxXT0wLCRbMl09MCksdHR9ZnVuY3Rpb24gcCgkLFEpe3ZhciB0dD1fKCQsUSk7cmV0dXJuIE1hdGguYWNvcygyKnR0KnR0LTEpfWZ1bmN0aW9uIE8oJCxRLHR0KXt2YXIgRj1RWzBdLEg9UVsxXSx4PVFbMl0sUD1RWzNdLFc9dHRbMF0sSz10dFsxXSxaPXR0WzJdLGs9dHRbM107cmV0dXJuICRbMF09RiprK1AqVytIKloteCpLLCRbMV09SCprK1AqSyt4KlctRipaLCRbMl09eCprK1AqWitGKkstSCpXLCRbM109UCprLUYqVy1IKksteCpaLCR9ZnVuY3Rpb24gbSgkLFEsdHQpe3R0Kj0uNTt2YXIgRj1RWzBdLEg9UVsxXSx4PVFbMl0sUD1RWzNdLFc9TWF0aC5zaW4odHQpLEs9TWF0aC5jb3ModHQpO3JldHVybiAkWzBdPUYqSytQKlcsJFsxXT1IKksreCpXLCRbMl09eCpLLUgqVywkWzNdPVAqSy1GKlcsJH1mdW5jdGlvbiBiKCQsUSx0dCl7dHQqPS41O3ZhciBGPVFbMF0sSD1RWzFdLHg9UVsyXSxQPVFbM10sVz1NYXRoLnNpbih0dCksSz1NYXRoLmNvcyh0dCk7cmV0dXJuICRbMF09RipLLXgqVywkWzFdPUgqSytQKlcsJFsyXT14KksrRipXLCRbM109UCpLLUgqVywkfWZ1bmN0aW9uIE0oJCxRLHR0KXt0dCo9LjU7dmFyIEY9UVswXSxIPVFbMV0seD1RWzJdLFA9UVszXSxXPU1hdGguc2luKHR0KSxLPU1hdGguY29zKHR0KTtyZXR1cm4gJFswXT1GKksrSCpXLCRbMV09SCpLLUYqVywkWzJdPXgqSytQKlcsJFszXT1QKksteCpXLCR9ZnVuY3Rpb24geSgkLFEpe3ZhciB0dD1RWzBdLEY9UVsxXSxIPVFbMl07cmV0dXJuICRbMF09dHQsJFsxXT1GLCRbMl09SCwkWzNdPU1hdGguc3FydChNYXRoLmFicygxLXR0KnR0LUYqRi1IKkgpKSwkfWZ1bmN0aW9uIFMoJCxRKXt2YXIgdHQ9UVswXSxGPVFbMV0sSD1RWzJdLHg9UVszXSxQPU1hdGguc3FydCh0dCp0dCtGKkYrSCpIKSxXPU1hdGguZXhwKHgpLEs9UD4wP1cqTWF0aC5zaW4oUCkvUDowO3JldHVybiAkWzBdPXR0KkssJFsxXT1GKkssJFsyXT1IKkssJFszXT1XKk1hdGguY29zKFApLCR9ZnVuY3Rpb24gcygkLFEpe3ZhciB0dD1RWzBdLEY9UVsxXSxIPVFbMl0seD1RWzNdLFA9TWF0aC5zcXJ0KHR0KnR0K0YqRitIKkgpLFc9UD4wP01hdGguYXRhbjIoUCx4KS9QOjA7cmV0dXJuICRbMF09dHQqVywkWzFdPUYqVywkWzJdPUgqVywkWzNdPS41Kk1hdGgubG9nKHR0KnR0K0YqRitIKkgreCp4KSwkfWZ1bmN0aW9uIGMoJCxRLHR0KXtyZXR1cm4gcygkLFEpLEooJCwkLHR0KSxTKCQsJCksJH1mdW5jdGlvbiBsKCQsUSx0dCxGKXt2YXIgSD1RWzBdLHg9UVsxXSxQPVFbMl0sVz1RWzNdLEs9dHRbMF0sWj10dFsxXSxrPXR0WzJdLG50PXR0WzNdLHV0LGN0LHB0LHh0LGd0O3JldHVybiBjdD1IKksreCpaK1AqaytXKm50LGN0PDAmJihjdD0tY3QsSz0tSyxaPS1aLGs9LWssbnQ9LW50KSwxLWN0Pm4uRVBTSUxPTj8odXQ9TWF0aC5hY29zKGN0KSxwdD1NYXRoLnNpbih1dCkseHQ9TWF0aC5zaW4oKDEtRikqdXQpL3B0LGd0PU1hdGguc2luKEYqdXQpL3B0KTooeHQ9MS1GLGd0PUYpLCRbMF09eHQqSCtndCpLLCRbMV09eHQqeCtndCpaLCRbMl09eHQqUCtndCprLCRbM109eHQqVytndCpudCwkfWZ1bmN0aW9uIHYoJCl7dmFyIFE9bi5SQU5ET00oKSx0dD1uLlJBTkRPTSgpLEY9bi5SQU5ET00oKSxIPU1hdGguc3FydCgxLVEpLHg9TWF0aC5zcXJ0KFEpO3JldHVybiAkWzBdPUgqTWF0aC5zaW4oMipNYXRoLlBJKnR0KSwkWzFdPUgqTWF0aC5jb3MoMipNYXRoLlBJKnR0KSwkWzJdPXgqTWF0aC5zaW4oMipNYXRoLlBJKkYpLCRbM109eCpNYXRoLmNvcygyKk1hdGguUEkqRiksJH1mdW5jdGlvbiBUKCQsUSl7dmFyIHR0PVFbMF0sRj1RWzFdLEg9UVsyXSx4PVFbM10sUD10dCp0dCtGKkYrSCpIK3gqeCxXPVA/MS9QOjA7cmV0dXJuICRbMF09LXR0KlcsJFsxXT0tRipXLCRbMl09LUgqVywkWzNdPXgqVywkfWZ1bmN0aW9uIFIoJCxRKXtyZXR1cm4gJFswXT0tUVswXSwkWzFdPS1RWzFdLCRbMl09LVFbMl0sJFszXT1RWzNdLCR9ZnVuY3Rpb24gTCgkLFEpe3ZhciB0dD1RWzBdK1FbNF0rUVs4XSxGO2lmKHR0PjApRj1NYXRoLnNxcnQodHQrMSksJFszXT0uNSpGLEY9LjUvRiwkWzBdPShRWzVdLVFbN10pKkYsJFsxXT0oUVs2XS1RWzJdKSpGLCRbMl09KFFbMV0tUVszXSkqRjtlbHNle3ZhciBIPTA7UVs0XT5RWzBdJiYoSD0xKSxRWzhdPlFbSCozK0hdJiYoSD0yKTt2YXIgeD0oSCsxKSUzLFA9KEgrMiklMztGPU1hdGguc3FydChRW0gqMytIXS1RW3gqMyt4XS1RW1AqMytQXSsxKSwkW0hdPS41KkYsRj0uNS9GLCRbM109KFFbeCozK1BdLVFbUCozK3hdKSpGLCRbeF09KFFbeCozK0hdK1FbSCozK3hdKSpGLCRbUF09KFFbUCozK0hdK1FbSCozK1BdKSpGfXJldHVybiAkfWZ1bmN0aW9uIE4oJCxRLHR0LEYpe3ZhciBIPS41Kk1hdGguUEkvMTgwO1EqPUgsdHQqPUgsRio9SDt2YXIgeD1NYXRoLnNpbihRKSxQPU1hdGguY29zKFEpLFc9TWF0aC5zaW4odHQpLEs9TWF0aC5jb3ModHQpLFo9TWF0aC5zaW4oRiksaz1NYXRoLmNvcyhGKTtyZXR1cm4gJFswXT14Kksqay1QKlcqWiwkWzFdPVAqVyprK3gqSypaLCRbMl09UCpLKloteCpXKmssJFszXT1QKksqayt4KlcqWiwkfWZ1bmN0aW9uIEEoJCl7cmV0dXJuInF1YXQoIiskWzBdKyIsICIrJFsxXSsiLCAiKyRbMl0rIiwgIiskWzNdKyIpIn12YXIgdz1oLmNsb25lLEI9aC5mcm9tVmFsdWVzLEQ9aC5jb3B5LEk9aC5zZXQsaj1oLmFkZCxWPU8sSj1oLnNjYWxlLF89aC5kb3Qsc3Q9aC5sZXJwLEc9aC5sZW5ndGgsWT1HLHJ0PWguc3F1YXJlZExlbmd0aCxvdD1ydCxhdD1oLm5vcm1hbGl6ZSxodD1oLmV4YWN0RXF1YWxzLGl0PWguZXF1YWxzLE10PWZ1bmN0aW9uKCl7dmFyICQ9Zi5jcmVhdGUoKSxRPWYuZnJvbVZhbHVlcygxLDAsMCksdHQ9Zi5mcm9tVmFsdWVzKDAsMSwwKTtyZXR1cm4gZnVuY3Rpb24oRixILHgpe3ZhciBQPWYuZG90KEgseCk7cmV0dXJuIFA8LS45OTk5OTk/KGYuY3Jvc3MoJCxRLEgpLGYubGVuKCQpPDFlLTYmJmYuY3Jvc3MoJCx0dCxIKSxmLm5vcm1hbGl6ZSgkLCQpLGQoRiwkLE1hdGguUEkpLEYpOlA+Ljk5OTk5OT8oRlswXT0wLEZbMV09MCxGWzJdPTAsRlszXT0xLEYpOihmLmNyb3NzKCQsSCx4KSxGWzBdPSRbMF0sRlsxXT0kWzFdLEZbMl09JFsyXSxGWzNdPTErUCxhdChGLEYpKX19KCksT3Q9ZnVuY3Rpb24oKXt2YXIgJD11KCksUT11KCk7cmV0dXJuIGZ1bmN0aW9uKHR0LEYsSCx4LFAsVyl7cmV0dXJuIGwoJCxGLFAsVyksbChRLEgseCxXKSxsKHR0LCQsUSwyKlcqKDEtVykpLHR0fX0oKSxVPWZ1bmN0aW9uKCl7dmFyICQ9aS5jcmVhdGUoKTtyZXR1cm4gZnVuY3Rpb24oUSx0dCxGLEgpe3JldHVybiAkWzBdPUZbMF0sJFszXT1GWzFdLCRbNl09RlsyXSwkWzFdPUhbMF0sJFs0XT1IWzFdLCRbN109SFsyXSwkWzJdPS10dFswXSwkWzVdPS10dFsxXSwkWzhdPS10dFsyXSxhdChRLEwoUSwkKSl9fSgpfSxmdW5jdGlvbihnLGUsdCl7dC5yKGUpLHQuZChlLCJjcmVhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIGl9KSx0LmQoZSwiY2xvbmUiLGZ1bmN0aW9uKCl7cmV0dXJuIGZ9KSx0LmQoZSwibGVuZ3RoIixmdW5jdGlvbigpe3JldHVybiBofSksdC5kKGUsImZyb21WYWx1ZXMiLGZ1bmN0aW9uKCl7cmV0dXJuIHV9KSx0LmQoZSwiY29weSIsZnVuY3Rpb24oKXtyZXR1cm4gYX0pLHQuZChlLCJzZXQiLGZ1bmN0aW9uKCl7cmV0dXJuIGR9KSx0LmQoZSwiYWRkIixmdW5jdGlvbigpe3JldHVybiBFfSksdC5kKGUsInN1YnRyYWN0IixmdW5jdGlvbigpe3JldHVybiBwfSksdC5kKGUsIm11bHRpcGx5IixmdW5jdGlvbigpe3JldHVybiBPfSksdC5kKGUsImRpdmlkZSIsZnVuY3Rpb24oKXtyZXR1cm4gbX0pLHQuZChlLCJjZWlsIixmdW5jdGlvbigpe3JldHVybiBifSksdC5kKGUsImZsb29yIixmdW5jdGlvbigpe3JldHVybiBNfSksdC5kKGUsIm1pbiIsZnVuY3Rpb24oKXtyZXR1cm4geX0pLHQuZChlLCJtYXgiLGZ1bmN0aW9uKCl7cmV0dXJuIFN9KSx0LmQoZSwicm91bmQiLGZ1bmN0aW9uKCl7cmV0dXJuIHN9KSx0LmQoZSwic2NhbGUiLGZ1bmN0aW9uKCl7cmV0dXJuIGN9KSx0LmQoZSwic2NhbGVBbmRBZGQiLGZ1bmN0aW9uKCl7cmV0dXJuIGx9KSx0LmQoZSwiZGlzdGFuY2UiLGZ1bmN0aW9uKCl7cmV0dXJuIHZ9KSx0LmQoZSwic3F1YXJlZERpc3RhbmNlIixmdW5jdGlvbigpe3JldHVybiBUfSksdC5kKGUsInNxdWFyZWRMZW5ndGgiLGZ1bmN0aW9uKCl7cmV0dXJuIFJ9KSx0LmQoZSwibmVnYXRlIixmdW5jdGlvbigpe3JldHVybiBMfSksdC5kKGUsImludmVyc2UiLGZ1bmN0aW9uKCl7cmV0dXJuIE59KSx0LmQoZSwibm9ybWFsaXplIixmdW5jdGlvbigpe3JldHVybiBBfSksdC5kKGUsImRvdCIsZnVuY3Rpb24oKXtyZXR1cm4gd30pLHQuZChlLCJjcm9zcyIsZnVuY3Rpb24oKXtyZXR1cm4gQn0pLHQuZChlLCJsZXJwIixmdW5jdGlvbigpe3JldHVybiBEfSksdC5kKGUsImhlcm1pdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIEl9KSx0LmQoZSwiYmV6aWVyIixmdW5jdGlvbigpe3JldHVybiBqfSksdC5kKGUsInJhbmRvbSIsZnVuY3Rpb24oKXtyZXR1cm4gVn0pLHQuZChlLCJ0cmFuc2Zvcm1NYXQ0IixmdW5jdGlvbigpe3JldHVybiBKfSksdC5kKGUsInRyYW5zZm9ybU1hdDMiLGZ1bmN0aW9uKCl7cmV0dXJuIF99KSx0LmQoZSwidHJhbnNmb3JtUXVhdCIsZnVuY3Rpb24oKXtyZXR1cm4gc3R9KSx0LmQoZSwicm90YXRlWCIsZnVuY3Rpb24oKXtyZXR1cm4gR30pLHQuZChlLCJyb3RhdGVZIixmdW5jdGlvbigpe3JldHVybiBZfSksdC5kKGUsInJvdGF0ZVoiLGZ1bmN0aW9uKCl7cmV0dXJuIHJ0fSksdC5kKGUsImFuZ2xlIixmdW5jdGlvbigpe3JldHVybiBvdH0pLHQuZChlLCJ6ZXJvIixmdW5jdGlvbigpe3JldHVybiBhdH0pLHQuZChlLCJzdHIiLGZ1bmN0aW9uKCl7cmV0dXJuIGh0fSksdC5kKGUsImV4YWN0RXF1YWxzIixmdW5jdGlvbigpe3JldHVybiBpdH0pLHQuZChlLCJlcXVhbHMiLGZ1bmN0aW9uKCl7cmV0dXJuIE10fSksdC5kKGUsInN1YiIsZnVuY3Rpb24oKXtyZXR1cm4gT3R9KSx0LmQoZSwibXVsIixmdW5jdGlvbigpe3JldHVybiBVfSksdC5kKGUsImRpdiIsZnVuY3Rpb24oKXtyZXR1cm4gJH0pLHQuZChlLCJkaXN0IixmdW5jdGlvbigpe3JldHVybiBRfSksdC5kKGUsInNxckRpc3QiLGZ1bmN0aW9uKCl7cmV0dXJuIHR0fSksdC5kKGUsImxlbiIsZnVuY3Rpb24oKXtyZXR1cm4gRn0pLHQuZChlLCJzcXJMZW4iLGZ1bmN0aW9uKCl7cmV0dXJuIEh9KSx0LmQoZSwiZm9yRWFjaCIsZnVuY3Rpb24oKXtyZXR1cm4geH0pO3ZhciBuPXQoMik7ZnVuY3Rpb24gaSgpe3ZhciBQPW5ldyBuLkFSUkFZX1RZUEUoMyk7cmV0dXJuIG4uQVJSQVlfVFlQRSE9RmxvYXQzMkFycmF5JiYoUFswXT0wLFBbMV09MCxQWzJdPTApLFB9ZnVuY3Rpb24gZihQKXt2YXIgVz1uZXcgbi5BUlJBWV9UWVBFKDMpO3JldHVybiBXWzBdPVBbMF0sV1sxXT1QWzFdLFdbMl09UFsyXSxXfWZ1bmN0aW9uIGgoUCl7dmFyIFc9UFswXSxLPVBbMV0sWj1QWzJdO3JldHVybiBNYXRoLmh5cG90KFcsSyxaKX1mdW5jdGlvbiB1KFAsVyxLKXt2YXIgWj1uZXcgbi5BUlJBWV9UWVBFKDMpO3JldHVybiBaWzBdPVAsWlsxXT1XLFpbMl09SyxafWZ1bmN0aW9uIGEoUCxXKXtyZXR1cm4gUFswXT1XWzBdLFBbMV09V1sxXSxQWzJdPVdbMl0sUH1mdW5jdGlvbiBkKFAsVyxLLFope3JldHVybiBQWzBdPVcsUFsxXT1LLFBbMl09WixQfWZ1bmN0aW9uIEUoUCxXLEspe3JldHVybiBQWzBdPVdbMF0rS1swXSxQWzFdPVdbMV0rS1sxXSxQWzJdPVdbMl0rS1syXSxQfWZ1bmN0aW9uIHAoUCxXLEspe3JldHVybiBQWzBdPVdbMF0tS1swXSxQWzFdPVdbMV0tS1sxXSxQWzJdPVdbMl0tS1syXSxQfWZ1bmN0aW9uIE8oUCxXLEspe3JldHVybiBQWzBdPVdbMF0qS1swXSxQWzFdPVdbMV0qS1sxXSxQWzJdPVdbMl0qS1syXSxQfWZ1bmN0aW9uIG0oUCxXLEspe3JldHVybiBQWzBdPVdbMF0vS1swXSxQWzFdPVdbMV0vS1sxXSxQWzJdPVdbMl0vS1syXSxQfWZ1bmN0aW9uIGIoUCxXKXtyZXR1cm4gUFswXT1NYXRoLmNlaWwoV1swXSksUFsxXT1NYXRoLmNlaWwoV1sxXSksUFsyXT1NYXRoLmNlaWwoV1syXSksUH1mdW5jdGlvbiBNKFAsVyl7cmV0dXJuIFBbMF09TWF0aC5mbG9vcihXWzBdKSxQWzFdPU1hdGguZmxvb3IoV1sxXSksUFsyXT1NYXRoLmZsb29yKFdbMl0pLFB9ZnVuY3Rpb24geShQLFcsSyl7cmV0dXJuIFBbMF09TWF0aC5taW4oV1swXSxLWzBdKSxQWzFdPU1hdGgubWluKFdbMV0sS1sxXSksUFsyXT1NYXRoLm1pbihXWzJdLEtbMl0pLFB9ZnVuY3Rpb24gUyhQLFcsSyl7cmV0dXJuIFBbMF09TWF0aC5tYXgoV1swXSxLWzBdKSxQWzFdPU1hdGgubWF4KFdbMV0sS1sxXSksUFsyXT1NYXRoLm1heChXWzJdLEtbMl0pLFB9ZnVuY3Rpb24gcyhQLFcpe3JldHVybiBQWzBdPU1hdGgucm91bmQoV1swXSksUFsxXT1NYXRoLnJvdW5kKFdbMV0pLFBbMl09TWF0aC5yb3VuZChXWzJdKSxQfWZ1bmN0aW9uIGMoUCxXLEspe3JldHVybiBQWzBdPVdbMF0qSyxQWzFdPVdbMV0qSyxQWzJdPVdbMl0qSyxQfWZ1bmN0aW9uIGwoUCxXLEssWil7cmV0dXJuIFBbMF09V1swXStLWzBdKlosUFsxXT1XWzFdK0tbMV0qWixQWzJdPVdbMl0rS1syXSpaLFB9ZnVuY3Rpb24gdihQLFcpe3ZhciBLPVdbMF0tUFswXSxaPVdbMV0tUFsxXSxrPVdbMl0tUFsyXTtyZXR1cm4gTWF0aC5oeXBvdChLLFosayl9ZnVuY3Rpb24gVChQLFcpe3ZhciBLPVdbMF0tUFswXSxaPVdbMV0tUFsxXSxrPVdbMl0tUFsyXTtyZXR1cm4gSypLK1oqWitrKmt9ZnVuY3Rpb24gUihQKXt2YXIgVz1QWzBdLEs9UFsxXSxaPVBbMl07cmV0dXJuIFcqVytLKksrWipafWZ1bmN0aW9uIEwoUCxXKXtyZXR1cm4gUFswXT0tV1swXSxQWzFdPS1XWzFdLFBbMl09LVdbMl0sUH1mdW5jdGlvbiBOKFAsVyl7cmV0dXJuIFBbMF09MS9XWzBdLFBbMV09MS9XWzFdLFBbMl09MS9XWzJdLFB9ZnVuY3Rpb24gQShQLFcpe3ZhciBLPVdbMF0sWj1XWzFdLGs9V1syXSxudD1LKksrWipaK2sqaztyZXR1cm4gbnQ+MCYmKG50PTEvTWF0aC5zcXJ0KG50KSksUFswXT1XWzBdKm50LFBbMV09V1sxXSpudCxQWzJdPVdbMl0qbnQsUH1mdW5jdGlvbiB3KFAsVyl7cmV0dXJuIFBbMF0qV1swXStQWzFdKldbMV0rUFsyXSpXWzJdfWZ1bmN0aW9uIEIoUCxXLEspe3ZhciBaPVdbMF0saz1XWzFdLG50PVdbMl0sdXQ9S1swXSxjdD1LWzFdLHB0PUtbMl07cmV0dXJuIFBbMF09aypwdC1udCpjdCxQWzFdPW50KnV0LVoqcHQsUFsyXT1aKmN0LWsqdXQsUH1mdW5jdGlvbiBEKFAsVyxLLFope3ZhciBrPVdbMF0sbnQ9V1sxXSx1dD1XWzJdO3JldHVybiBQWzBdPWsrWiooS1swXS1rKSxQWzFdPW50K1oqKEtbMV0tbnQpLFBbMl09dXQrWiooS1syXS11dCksUH1mdW5jdGlvbiBJKFAsVyxLLFosayxudCl7dmFyIHV0PW50Km50LGN0PXV0KigyKm50LTMpKzEscHQ9dXQqKG50LTIpK250LHh0PXV0KihudC0xKSxndD11dCooMy0yKm50KTtyZXR1cm4gUFswXT1XWzBdKmN0K0tbMF0qcHQrWlswXSp4dCtrWzBdKmd0LFBbMV09V1sxXSpjdCtLWzFdKnB0K1pbMV0qeHQra1sxXSpndCxQWzJdPVdbMl0qY3QrS1syXSpwdCtaWzJdKnh0K2tbMl0qZ3QsUH1mdW5jdGlvbiBqKFAsVyxLLFosayxudCl7dmFyIHV0PTEtbnQsY3Q9dXQqdXQscHQ9bnQqbnQseHQ9Y3QqdXQsZ3Q9MypudCpjdCxkdD0zKnB0KnV0LG10PXB0Km50O3JldHVybiBQWzBdPVdbMF0qeHQrS1swXSpndCtaWzBdKmR0K2tbMF0qbXQsUFsxXT1XWzFdKnh0K0tbMV0qZ3QrWlsxXSpkdCtrWzFdKm10LFBbMl09V1syXSp4dCtLWzJdKmd0K1pbMl0qZHQra1syXSptdCxQfWZ1bmN0aW9uIFYoUCxXKXtXPVd8fDE7dmFyIEs9bi5SQU5ET00oKSoyKk1hdGguUEksWj1uLlJBTkRPTSgpKjItMSxrPU1hdGguc3FydCgxLVoqWikqVztyZXR1cm4gUFswXT1NYXRoLmNvcyhLKSprLFBbMV09TWF0aC5zaW4oSykqayxQWzJdPVoqVyxQfWZ1bmN0aW9uIEooUCxXLEspe3ZhciBaPVdbMF0saz1XWzFdLG50PVdbMl0sdXQ9S1szXSpaK0tbN10qaytLWzExXSpudCtLWzE1XTtyZXR1cm4gdXQ9dXR8fDEsUFswXT0oS1swXSpaK0tbNF0qaytLWzhdKm50K0tbMTJdKS91dCxQWzFdPShLWzFdKlorS1s1XSprK0tbOV0qbnQrS1sxM10pL3V0LFBbMl09KEtbMl0qWitLWzZdKmsrS1sxMF0qbnQrS1sxNF0pL3V0LFB9ZnVuY3Rpb24gXyhQLFcsSyl7dmFyIFo9V1swXSxrPVdbMV0sbnQ9V1syXTtyZXR1cm4gUFswXT1aKktbMF0raypLWzNdK250KktbNl0sUFsxXT1aKktbMV0raypLWzRdK250KktbN10sUFsyXT1aKktbMl0raypLWzVdK250KktbOF0sUH1mdW5jdGlvbiBzdChQLFcsSyl7dmFyIFo9S1swXSxrPUtbMV0sbnQ9S1syXSx1dD1LWzNdLGN0PVdbMF0scHQ9V1sxXSx4dD1XWzJdLGd0PWsqeHQtbnQqcHQsZHQ9bnQqY3QtWip4dCxtdD1aKnB0LWsqY3QsYnQ9ayptdC1udCpkdCxDdD1udCpndC1aKm10LFN0PVoqZHQtaypndCxOdD11dCoyO3JldHVybiBndCo9TnQsZHQqPU50LG10Kj1OdCxidCo9MixDdCo9MixTdCo9MixQWzBdPWN0K2d0K2J0LFBbMV09cHQrZHQrQ3QsUFsyXT14dCttdCtTdCxQfWZ1bmN0aW9uIEcoUCxXLEssWil7dmFyIGs9W10sbnQ9W107cmV0dXJuIGtbMF09V1swXS1LWzBdLGtbMV09V1sxXS1LWzFdLGtbMl09V1syXS1LWzJdLG50WzBdPWtbMF0sbnRbMV09a1sxXSpNYXRoLmNvcyhaKS1rWzJdKk1hdGguc2luKFopLG50WzJdPWtbMV0qTWF0aC5zaW4oWikra1syXSpNYXRoLmNvcyhaKSxQWzBdPW50WzBdK0tbMF0sUFsxXT1udFsxXStLWzFdLFBbMl09bnRbMl0rS1syXSxQfWZ1bmN0aW9uIFkoUCxXLEssWil7dmFyIGs9W10sbnQ9W107cmV0dXJuIGtbMF09V1swXS1LWzBdLGtbMV09V1sxXS1LWzFdLGtbMl09V1syXS1LWzJdLG50WzBdPWtbMl0qTWF0aC5zaW4oWikra1swXSpNYXRoLmNvcyhaKSxudFsxXT1rWzFdLG50WzJdPWtbMl0qTWF0aC5jb3MoWikta1swXSpNYXRoLnNpbihaKSxQWzBdPW50WzBdK0tbMF0sUFsxXT1udFsxXStLWzFdLFBbMl09bnRbMl0rS1syXSxQfWZ1bmN0aW9uIHJ0KFAsVyxLLFope3ZhciBrPVtdLG50PVtdO3JldHVybiBrWzBdPVdbMF0tS1swXSxrWzFdPVdbMV0tS1sxXSxrWzJdPVdbMl0tS1syXSxudFswXT1rWzBdKk1hdGguY29zKFopLWtbMV0qTWF0aC5zaW4oWiksbnRbMV09a1swXSpNYXRoLnNpbihaKStrWzFdKk1hdGguY29zKFopLG50WzJdPWtbMl0sUFswXT1udFswXStLWzBdLFBbMV09bnRbMV0rS1sxXSxQWzJdPW50WzJdK0tbMl0sUH1mdW5jdGlvbiBvdChQLFcpe3ZhciBLPVBbMF0sWj1QWzFdLGs9UFsyXSxudD1XWzBdLHV0PVdbMV0sY3Q9V1syXSxwdD1NYXRoLnNxcnQoSypLK1oqWitrKmspLHh0PU1hdGguc3FydChudCpudCt1dCp1dCtjdCpjdCksZ3Q9cHQqeHQsZHQ9Z3QmJncoUCxXKS9ndDtyZXR1cm4gTWF0aC5hY29zKE1hdGgubWluKE1hdGgubWF4KGR0LC0xKSwxKSl9ZnVuY3Rpb24gYXQoUCl7cmV0dXJuIFBbMF09MCxQWzFdPTAsUFsyXT0wLFB9ZnVuY3Rpb24gaHQoUCl7cmV0dXJuInZlYzMoIitQWzBdKyIsICIrUFsxXSsiLCAiK1BbMl0rIikifWZ1bmN0aW9uIGl0KFAsVyl7cmV0dXJuIFBbMF09PT1XWzBdJiZQWzFdPT09V1sxXSYmUFsyXT09PVdbMl19ZnVuY3Rpb24gTXQoUCxXKXt2YXIgSz1QWzBdLFo9UFsxXSxrPVBbMl0sbnQ9V1swXSx1dD1XWzFdLGN0PVdbMl07cmV0dXJuIE1hdGguYWJzKEstbnQpPD1uLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhLKSxNYXRoLmFicyhudCkpJiZNYXRoLmFicyhaLXV0KTw9bi5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoWiksTWF0aC5hYnModXQpKSYmTWF0aC5hYnMoay1jdCk8PW4uRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKGspLE1hdGguYWJzKGN0KSl9dmFyIE90PXAsVT1PLCQ9bSxRPXYsdHQ9VCxGPWgsSD1SLHg9ZnVuY3Rpb24oKXt2YXIgUD1pKCk7cmV0dXJuIGZ1bmN0aW9uKFcsSyxaLGssbnQsdXQpe3ZhciBjdCxwdDtmb3IoS3x8KEs9MyksWnx8KFo9MCksaz9wdD1NYXRoLm1pbihrKksrWixXLmxlbmd0aCk6cHQ9Vy5sZW5ndGgsY3Q9WjtjdDxwdDtjdCs9SylQWzBdPVdbY3RdLFBbMV09V1tjdCsxXSxQWzJdPVdbY3QrMl0sbnQoUCxQLHV0KSxXW2N0XT1QWzBdLFdbY3QrMV09UFsxXSxXW2N0KzJdPVBbMl07cmV0dXJuIFd9fSgpfSxmdW5jdGlvbihnLGUsdCl7dC5yKGUpLHQuZChlLCJjcmVhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIGl9KSx0LmQoZSwiY2xvbmUiLGZ1bmN0aW9uKCl7cmV0dXJuIGZ9KSx0LmQoZSwiZnJvbVZhbHVlcyIsZnVuY3Rpb24oKXtyZXR1cm4gaH0pLHQuZChlLCJjb3B5IixmdW5jdGlvbigpe3JldHVybiB1fSksdC5kKGUsInNldCIsZnVuY3Rpb24oKXtyZXR1cm4gYX0pLHQuZChlLCJhZGQiLGZ1bmN0aW9uKCl7cmV0dXJuIGR9KSx0LmQoZSwic3VidHJhY3QiLGZ1bmN0aW9uKCl7cmV0dXJuIEV9KSx0LmQoZSwibXVsdGlwbHkiLGZ1bmN0aW9uKCl7cmV0dXJuIHB9KSx0LmQoZSwiZGl2aWRlIixmdW5jdGlvbigpe3JldHVybiBPfSksdC5kKGUsImNlaWwiLGZ1bmN0aW9uKCl7cmV0dXJuIG19KSx0LmQoZSwiZmxvb3IiLGZ1bmN0aW9uKCl7cmV0dXJuIGJ9KSx0LmQoZSwibWluIixmdW5jdGlvbigpe3JldHVybiBNfSksdC5kKGUsIm1heCIsZnVuY3Rpb24oKXtyZXR1cm4geX0pLHQuZChlLCJyb3VuZCIsZnVuY3Rpb24oKXtyZXR1cm4gU30pLHQuZChlLCJzY2FsZSIsZnVuY3Rpb24oKXtyZXR1cm4gc30pLHQuZChlLCJzY2FsZUFuZEFkZCIsZnVuY3Rpb24oKXtyZXR1cm4gY30pLHQuZChlLCJkaXN0YW5jZSIsZnVuY3Rpb24oKXtyZXR1cm4gbH0pLHQuZChlLCJzcXVhcmVkRGlzdGFuY2UiLGZ1bmN0aW9uKCl7cmV0dXJuIHZ9KSx0LmQoZSwibGVuZ3RoIixmdW5jdGlvbigpe3JldHVybiBUfSksdC5kKGUsInNxdWFyZWRMZW5ndGgiLGZ1bmN0aW9uKCl7cmV0dXJuIFJ9KSx0LmQoZSwibmVnYXRlIixmdW5jdGlvbigpe3JldHVybiBMfSksdC5kKGUsImludmVyc2UiLGZ1bmN0aW9uKCl7cmV0dXJuIE59KSx0LmQoZSwibm9ybWFsaXplIixmdW5jdGlvbigpe3JldHVybiBBfSksdC5kKGUsImRvdCIsZnVuY3Rpb24oKXtyZXR1cm4gd30pLHQuZChlLCJjcm9zcyIsZnVuY3Rpb24oKXtyZXR1cm4gQn0pLHQuZChlLCJsZXJwIixmdW5jdGlvbigpe3JldHVybiBEfSksdC5kKGUsInJhbmRvbSIsZnVuY3Rpb24oKXtyZXR1cm4gSX0pLHQuZChlLCJ0cmFuc2Zvcm1NYXQ0IixmdW5jdGlvbigpe3JldHVybiBqfSksdC5kKGUsInRyYW5zZm9ybVF1YXQiLGZ1bmN0aW9uKCl7cmV0dXJuIFZ9KSx0LmQoZSwiemVybyIsZnVuY3Rpb24oKXtyZXR1cm4gSn0pLHQuZChlLCJzdHIiLGZ1bmN0aW9uKCl7cmV0dXJuIF99KSx0LmQoZSwiZXhhY3RFcXVhbHMiLGZ1bmN0aW9uKCl7cmV0dXJuIHN0fSksdC5kKGUsImVxdWFscyIsZnVuY3Rpb24oKXtyZXR1cm4gR30pLHQuZChlLCJzdWIiLGZ1bmN0aW9uKCl7cmV0dXJuIFl9KSx0LmQoZSwibXVsIixmdW5jdGlvbigpe3JldHVybiBydH0pLHQuZChlLCJkaXYiLGZ1bmN0aW9uKCl7cmV0dXJuIG90fSksdC5kKGUsImRpc3QiLGZ1bmN0aW9uKCl7cmV0dXJuIGF0fSksdC5kKGUsInNxckRpc3QiLGZ1bmN0aW9uKCl7cmV0dXJuIGh0fSksdC5kKGUsImxlbiIsZnVuY3Rpb24oKXtyZXR1cm4gaXR9KSx0LmQoZSwic3FyTGVuIixmdW5jdGlvbigpe3JldHVybiBNdH0pLHQuZChlLCJmb3JFYWNoIixmdW5jdGlvbigpe3JldHVybiBPdH0pO3ZhciBuPXQoMik7ZnVuY3Rpb24gaSgpe3ZhciBVPW5ldyBuLkFSUkFZX1RZUEUoNCk7cmV0dXJuIG4uQVJSQVlfVFlQRSE9RmxvYXQzMkFycmF5JiYoVVswXT0wLFVbMV09MCxVWzJdPTAsVVszXT0wKSxVfWZ1bmN0aW9uIGYoVSl7dmFyICQ9bmV3IG4uQVJSQVlfVFlQRSg0KTtyZXR1cm4gJFswXT1VWzBdLCRbMV09VVsxXSwkWzJdPVVbMl0sJFszXT1VWzNdLCR9ZnVuY3Rpb24gaChVLCQsUSx0dCl7dmFyIEY9bmV3IG4uQVJSQVlfVFlQRSg0KTtyZXR1cm4gRlswXT1VLEZbMV09JCxGWzJdPVEsRlszXT10dCxGfWZ1bmN0aW9uIHUoVSwkKXtyZXR1cm4gVVswXT0kWzBdLFVbMV09JFsxXSxVWzJdPSRbMl0sVVszXT0kWzNdLFV9ZnVuY3Rpb24gYShVLCQsUSx0dCxGKXtyZXR1cm4gVVswXT0kLFVbMV09USxVWzJdPXR0LFVbM109RixVfWZ1bmN0aW9uIGQoVSwkLFEpe3JldHVybiBVWzBdPSRbMF0rUVswXSxVWzFdPSRbMV0rUVsxXSxVWzJdPSRbMl0rUVsyXSxVWzNdPSRbM10rUVszXSxVfWZ1bmN0aW9uIEUoVSwkLFEpe3JldHVybiBVWzBdPSRbMF0tUVswXSxVWzFdPSRbMV0tUVsxXSxVWzJdPSRbMl0tUVsyXSxVWzNdPSRbM10tUVszXSxVfWZ1bmN0aW9uIHAoVSwkLFEpe3JldHVybiBVWzBdPSRbMF0qUVswXSxVWzFdPSRbMV0qUVsxXSxVWzJdPSRbMl0qUVsyXSxVWzNdPSRbM10qUVszXSxVfWZ1bmN0aW9uIE8oVSwkLFEpe3JldHVybiBVWzBdPSRbMF0vUVswXSxVWzFdPSRbMV0vUVsxXSxVWzJdPSRbMl0vUVsyXSxVWzNdPSRbM10vUVszXSxVfWZ1bmN0aW9uIG0oVSwkKXtyZXR1cm4gVVswXT1NYXRoLmNlaWwoJFswXSksVVsxXT1NYXRoLmNlaWwoJFsxXSksVVsyXT1NYXRoLmNlaWwoJFsyXSksVVszXT1NYXRoLmNlaWwoJFszXSksVX1mdW5jdGlvbiBiKFUsJCl7cmV0dXJuIFVbMF09TWF0aC5mbG9vcigkWzBdKSxVWzFdPU1hdGguZmxvb3IoJFsxXSksVVsyXT1NYXRoLmZsb29yKCRbMl0pLFVbM109TWF0aC5mbG9vcigkWzNdKSxVfWZ1bmN0aW9uIE0oVSwkLFEpe3JldHVybiBVWzBdPU1hdGgubWluKCRbMF0sUVswXSksVVsxXT1NYXRoLm1pbigkWzFdLFFbMV0pLFVbMl09TWF0aC5taW4oJFsyXSxRWzJdKSxVWzNdPU1hdGgubWluKCRbM10sUVszXSksVX1mdW5jdGlvbiB5KFUsJCxRKXtyZXR1cm4gVVswXT1NYXRoLm1heCgkWzBdLFFbMF0pLFVbMV09TWF0aC5tYXgoJFsxXSxRWzFdKSxVWzJdPU1hdGgubWF4KCRbMl0sUVsyXSksVVszXT1NYXRoLm1heCgkWzNdLFFbM10pLFV9ZnVuY3Rpb24gUyhVLCQpe3JldHVybiBVWzBdPU1hdGgucm91bmQoJFswXSksVVsxXT1NYXRoLnJvdW5kKCRbMV0pLFVbMl09TWF0aC5yb3VuZCgkWzJdKSxVWzNdPU1hdGgucm91bmQoJFszXSksVX1mdW5jdGlvbiBzKFUsJCxRKXtyZXR1cm4gVVswXT0kWzBdKlEsVVsxXT0kWzFdKlEsVVsyXT0kWzJdKlEsVVszXT0kWzNdKlEsVX1mdW5jdGlvbiBjKFUsJCxRLHR0KXtyZXR1cm4gVVswXT0kWzBdK1FbMF0qdHQsVVsxXT0kWzFdK1FbMV0qdHQsVVsyXT0kWzJdK1FbMl0qdHQsVVszXT0kWzNdK1FbM10qdHQsVX1mdW5jdGlvbiBsKFUsJCl7dmFyIFE9JFswXS1VWzBdLHR0PSRbMV0tVVsxXSxGPSRbMl0tVVsyXSxIPSRbM10tVVszXTtyZXR1cm4gTWF0aC5oeXBvdChRLHR0LEYsSCl9ZnVuY3Rpb24gdihVLCQpe3ZhciBRPSRbMF0tVVswXSx0dD0kWzFdLVVbMV0sRj0kWzJdLVVbMl0sSD0kWzNdLVVbM107cmV0dXJuIFEqUSt0dCp0dCtGKkYrSCpIfWZ1bmN0aW9uIFQoVSl7dmFyICQ9VVswXSxRPVVbMV0sdHQ9VVsyXSxGPVVbM107cmV0dXJuIE1hdGguaHlwb3QoJCxRLHR0LEYpfWZ1bmN0aW9uIFIoVSl7dmFyICQ9VVswXSxRPVVbMV0sdHQ9VVsyXSxGPVVbM107cmV0dXJuICQqJCtRKlErdHQqdHQrRipGfWZ1bmN0aW9uIEwoVSwkKXtyZXR1cm4gVVswXT0tJFswXSxVWzFdPS0kWzFdLFVbMl09LSRbMl0sVVszXT0tJFszXSxVfWZ1bmN0aW9uIE4oVSwkKXtyZXR1cm4gVVswXT0xLyRbMF0sVVsxXT0xLyRbMV0sVVsyXT0xLyRbMl0sVVszXT0xLyRbM10sVX1mdW5jdGlvbiBBKFUsJCl7dmFyIFE9JFswXSx0dD0kWzFdLEY9JFsyXSxIPSRbM10seD1RKlErdHQqdHQrRipGK0gqSDtyZXR1cm4geD4wJiYoeD0xL01hdGguc3FydCh4KSksVVswXT1RKngsVVsxXT10dCp4LFVbMl09Rip4LFVbM109SCp4LFV9ZnVuY3Rpb24gdyhVLCQpe3JldHVybiBVWzBdKiRbMF0rVVsxXSokWzFdK1VbMl0qJFsyXStVWzNdKiRbM119ZnVuY3Rpb24gQihVLCQsUSx0dCl7dmFyIEY9UVswXSp0dFsxXS1RWzFdKnR0WzBdLEg9UVswXSp0dFsyXS1RWzJdKnR0WzBdLHg9UVswXSp0dFszXS1RWzNdKnR0WzBdLFA9UVsxXSp0dFsyXS1RWzJdKnR0WzFdLFc9UVsxXSp0dFszXS1RWzNdKnR0WzFdLEs9UVsyXSp0dFszXS1RWzNdKnR0WzJdLFo9JFswXSxrPSRbMV0sbnQ9JFsyXSx1dD0kWzNdO3JldHVybiBVWzBdPWsqSy1udCpXK3V0KlAsVVsxXT0tKFoqSykrbnQqeC11dCpILFVbMl09WipXLWsqeCt1dCpGLFVbM109LShaKlApK2sqSC1udCpGLFV9ZnVuY3Rpb24gRChVLCQsUSx0dCl7dmFyIEY9JFswXSxIPSRbMV0seD0kWzJdLFA9JFszXTtyZXR1cm4gVVswXT1GK3R0KihRWzBdLUYpLFVbMV09SCt0dCooUVsxXS1IKSxVWzJdPXgrdHQqKFFbMl0teCksVVszXT1QK3R0KihRWzNdLVApLFV9ZnVuY3Rpb24gSShVLCQpeyQ9JHx8MTt2YXIgUSx0dCxGLEgseCxQO2RvIFE9bi5SQU5ET00oKSoyLTEsdHQ9bi5SQU5ET00oKSoyLTEseD1RKlErdHQqdHQ7d2hpbGUoeD49MSk7ZG8gRj1uLlJBTkRPTSgpKjItMSxIPW4uUkFORE9NKCkqMi0xLFA9RipGK0gqSDt3aGlsZShQPj0xKTt2YXIgVz1NYXRoLnNxcnQoKDEteCkvUCk7cmV0dXJuIFVbMF09JCpRLFVbMV09JCp0dCxVWzJdPSQqRipXLFVbM109JCpIKlcsVX1mdW5jdGlvbiBqKFUsJCxRKXt2YXIgdHQ9JFswXSxGPSRbMV0sSD0kWzJdLHg9JFszXTtyZXR1cm4gVVswXT1RWzBdKnR0K1FbNF0qRitRWzhdKkgrUVsxMl0qeCxVWzFdPVFbMV0qdHQrUVs1XSpGK1FbOV0qSCtRWzEzXSp4LFVbMl09UVsyXSp0dCtRWzZdKkYrUVsxMF0qSCtRWzE0XSp4LFVbM109UVszXSp0dCtRWzddKkYrUVsxMV0qSCtRWzE1XSp4LFV9ZnVuY3Rpb24gVihVLCQsUSl7dmFyIHR0PSRbMF0sRj0kWzFdLEg9JFsyXSx4PVFbMF0sUD1RWzFdLFc9UVsyXSxLPVFbM10sWj1LKnR0K1AqSC1XKkYsaz1LKkYrVyp0dC14KkgsbnQ9SypIK3gqRi1QKnR0LHV0PS14KnR0LVAqRi1XKkg7cmV0dXJuIFVbMF09WipLK3V0Ki14K2sqLVctbnQqLVAsVVsxXT1rKksrdXQqLVArbnQqLXgtWiotVyxVWzJdPW50KksrdXQqLVcrWiotUC1rKi14LFVbM109JFszXSxVfWZ1bmN0aW9uIEooVSl7cmV0dXJuIFVbMF09MCxVWzFdPTAsVVsyXT0wLFVbM109MCxVfWZ1bmN0aW9uIF8oVSl7cmV0dXJuInZlYzQoIitVWzBdKyIsICIrVVsxXSsiLCAiK1VbMl0rIiwgIitVWzNdKyIpIn1mdW5jdGlvbiBzdChVLCQpe3JldHVybiBVWzBdPT09JFswXSYmVVsxXT09PSRbMV0mJlVbMl09PT0kWzJdJiZVWzNdPT09JFszXX1mdW5jdGlvbiBHKFUsJCl7dmFyIFE9VVswXSx0dD1VWzFdLEY9VVsyXSxIPVVbM10seD0kWzBdLFA9JFsxXSxXPSRbMl0sSz0kWzNdO3JldHVybiBNYXRoLmFicyhRLXgpPD1uLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhRKSxNYXRoLmFicyh4KSkmJk1hdGguYWJzKHR0LVApPD1uLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyh0dCksTWF0aC5hYnMoUCkpJiZNYXRoLmFicyhGLVcpPD1uLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhGKSxNYXRoLmFicyhXKSkmJk1hdGguYWJzKEgtSyk8PW4uRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKEgpLE1hdGguYWJzKEspKX12YXIgWT1FLHJ0PXAsb3Q9TyxhdD1sLGh0PXYsaXQ9VCxNdD1SLE90PWZ1bmN0aW9uKCl7dmFyIFU9aSgpO3JldHVybiBmdW5jdGlvbigkLFEsdHQsRixILHgpe3ZhciBQLFc7Zm9yKFF8fChRPTQpLHR0fHwodHQ9MCksRj9XPU1hdGgubWluKEYqUSt0dCwkLmxlbmd0aCk6Vz0kLmxlbmd0aCxQPXR0O1A8VztQKz1RKVVbMF09JFtQXSxVWzFdPSRbUCsxXSxVWzJdPSRbUCsyXSxVWzNdPSRbUCszXSxIKFUsVSx4KSwkW1BdPVVbMF0sJFtQKzFdPVVbMV0sJFtQKzJdPVVbMl0sJFtQKzNdPVVbM107cmV0dXJuICR9fSgpfSxmdW5jdGlvbihnLGUsdCl7dC5yKGUpLHQuZChlLCJjcmVhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIGh9KSx0LmQoZSwiY2xvbmUiLGZ1bmN0aW9uKCl7cmV0dXJuIHV9KSx0LmQoZSwiZnJvbVZhbHVlcyIsZnVuY3Rpb24oKXtyZXR1cm4gYX0pLHQuZChlLCJmcm9tUm90YXRpb25UcmFuc2xhdGlvblZhbHVlcyIsZnVuY3Rpb24oKXtyZXR1cm4gZH0pLHQuZChlLCJmcm9tUm90YXRpb25UcmFuc2xhdGlvbiIsZnVuY3Rpb24oKXtyZXR1cm4gRX0pLHQuZChlLCJmcm9tVHJhbnNsYXRpb24iLGZ1bmN0aW9uKCl7cmV0dXJuIHB9KSx0LmQoZSwiZnJvbVJvdGF0aW9uIixmdW5jdGlvbigpe3JldHVybiBPfSksdC5kKGUsImZyb21NYXQ0IixmdW5jdGlvbigpe3JldHVybiBtfSksdC5kKGUsImNvcHkiLGZ1bmN0aW9uKCl7cmV0dXJuIGJ9KSx0LmQoZSwiaWRlbnRpdHkiLGZ1bmN0aW9uKCl7cmV0dXJuIE19KSx0LmQoZSwic2V0IixmdW5jdGlvbigpe3JldHVybiB5fSksdC5kKGUsImdldFJlYWwiLGZ1bmN0aW9uKCl7cmV0dXJuIFN9KSx0LmQoZSwiZ2V0RHVhbCIsZnVuY3Rpb24oKXtyZXR1cm4gc30pLHQuZChlLCJzZXRSZWFsIixmdW5jdGlvbigpe3JldHVybiBjfSksdC5kKGUsInNldER1YWwiLGZ1bmN0aW9uKCl7cmV0dXJuIGx9KSx0LmQoZSwiZ2V0VHJhbnNsYXRpb24iLGZ1bmN0aW9uKCl7cmV0dXJuIHZ9KSx0LmQoZSwidHJhbnNsYXRlIixmdW5jdGlvbigpe3JldHVybiBUfSksdC5kKGUsInJvdGF0ZVgiLGZ1bmN0aW9uKCl7cmV0dXJuIFJ9KSx0LmQoZSwicm90YXRlWSIsZnVuY3Rpb24oKXtyZXR1cm4gTH0pLHQuZChlLCJyb3RhdGVaIixmdW5jdGlvbigpe3JldHVybiBOfSksdC5kKGUsInJvdGF0ZUJ5UXVhdEFwcGVuZCIsZnVuY3Rpb24oKXtyZXR1cm4gQX0pLHQuZChlLCJyb3RhdGVCeVF1YXRQcmVwZW5kIixmdW5jdGlvbigpe3JldHVybiB3fSksdC5kKGUsInJvdGF0ZUFyb3VuZEF4aXMiLGZ1bmN0aW9uKCl7cmV0dXJuIEJ9KSx0LmQoZSwiYWRkIixmdW5jdGlvbigpe3JldHVybiBEfSksdC5kKGUsIm11bHRpcGx5IixmdW5jdGlvbigpe3JldHVybiBJfSksdC5kKGUsIm11bCIsZnVuY3Rpb24oKXtyZXR1cm4gan0pLHQuZChlLCJzY2FsZSIsZnVuY3Rpb24oKXtyZXR1cm4gVn0pLHQuZChlLCJkb3QiLGZ1bmN0aW9uKCl7cmV0dXJuIEp9KSx0LmQoZSwibGVycCIsZnVuY3Rpb24oKXtyZXR1cm4gX30pLHQuZChlLCJpbnZlcnQiLGZ1bmN0aW9uKCl7cmV0dXJuIHN0fSksdC5kKGUsImNvbmp1Z2F0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gR30pLHQuZChlLCJsZW5ndGgiLGZ1bmN0aW9uKCl7cmV0dXJuIFl9KSx0LmQoZSwibGVuIixmdW5jdGlvbigpe3JldHVybiBydH0pLHQuZChlLCJzcXVhcmVkTGVuZ3RoIixmdW5jdGlvbigpe3JldHVybiBvdH0pLHQuZChlLCJzcXJMZW4iLGZ1bmN0aW9uKCl7cmV0dXJuIGF0fSksdC5kKGUsIm5vcm1hbGl6ZSIsZnVuY3Rpb24oKXtyZXR1cm4gaHR9KSx0LmQoZSwic3RyIixmdW5jdGlvbigpe3JldHVybiBpdH0pLHQuZChlLCJleGFjdEVxdWFscyIsZnVuY3Rpb24oKXtyZXR1cm4gTXR9KSx0LmQoZSwiZXF1YWxzIixmdW5jdGlvbigpe3JldHVybiBPdH0pO3ZhciBuPXQoMiksaT10KDcpLGY9dCg2KTtmdW5jdGlvbiBoKCl7dmFyIFU9bmV3IG4uQVJSQVlfVFlQRSg4KTtyZXR1cm4gbi5BUlJBWV9UWVBFIT1GbG9hdDMyQXJyYXkmJihVWzBdPTAsVVsxXT0wLFVbMl09MCxVWzRdPTAsVVs1XT0wLFVbNl09MCxVWzddPTApLFVbM109MSxVfWZ1bmN0aW9uIHUoVSl7dmFyICQ9bmV3IG4uQVJSQVlfVFlQRSg4KTtyZXR1cm4gJFswXT1VWzBdLCRbMV09VVsxXSwkWzJdPVVbMl0sJFszXT1VWzNdLCRbNF09VVs0XSwkWzVdPVVbNV0sJFs2XT1VWzZdLCRbN109VVs3XSwkfWZ1bmN0aW9uIGEoVSwkLFEsdHQsRixILHgsUCl7dmFyIFc9bmV3IG4uQVJSQVlfVFlQRSg4KTtyZXR1cm4gV1swXT1VLFdbMV09JCxXWzJdPVEsV1szXT10dCxXWzRdPUYsV1s1XT1ILFdbNl09eCxXWzddPVAsV31mdW5jdGlvbiBkKFUsJCxRLHR0LEYsSCx4KXt2YXIgUD1uZXcgbi5BUlJBWV9UWVBFKDgpO1BbMF09VSxQWzFdPSQsUFsyXT1RLFBbM109dHQ7dmFyIFc9RiouNSxLPUgqLjUsWj14Ki41O3JldHVybiBQWzRdPVcqdHQrSypRLVoqJCxQWzVdPUsqdHQrWipVLVcqUSxQWzZdPVoqdHQrVyokLUsqVSxQWzddPS1XKlUtSyokLVoqUSxQfWZ1bmN0aW9uIEUoVSwkLFEpe3ZhciB0dD1RWzBdKi41LEY9UVsxXSouNSxIPVFbMl0qLjUseD0kWzBdLFA9JFsxXSxXPSRbMl0sSz0kWzNdO3JldHVybiBVWzBdPXgsVVsxXT1QLFVbMl09VyxVWzNdPUssVVs0XT10dCpLK0YqVy1IKlAsVVs1XT1GKksrSCp4LXR0KlcsVVs2XT1IKksrdHQqUC1GKngsVVs3XT0tdHQqeC1GKlAtSCpXLFV9ZnVuY3Rpb24gcChVLCQpe3JldHVybiBVWzBdPTAsVVsxXT0wLFVbMl09MCxVWzNdPTEsVVs0XT0kWzBdKi41LFVbNV09JFsxXSouNSxVWzZdPSRbMl0qLjUsVVs3XT0wLFV9ZnVuY3Rpb24gTyhVLCQpe3JldHVybiBVWzBdPSRbMF0sVVsxXT0kWzFdLFVbMl09JFsyXSxVWzNdPSRbM10sVVs0XT0wLFVbNV09MCxVWzZdPTAsVVs3XT0wLFV9ZnVuY3Rpb24gbShVLCQpe3ZhciBRPWkuY3JlYXRlKCk7Zi5nZXRSb3RhdGlvbihRLCQpO3ZhciB0dD1uZXcgbi5BUlJBWV9UWVBFKDMpO3JldHVybiBmLmdldFRyYW5zbGF0aW9uKHR0LCQpLEUoVSxRLHR0KSxVfWZ1bmN0aW9uIGIoVSwkKXtyZXR1cm4gVVswXT0kWzBdLFVbMV09JFsxXSxVWzJdPSRbMl0sVVszXT0kWzNdLFVbNF09JFs0XSxVWzVdPSRbNV0sVVs2XT0kWzZdLFVbN109JFs3XSxVfWZ1bmN0aW9uIE0oVSl7cmV0dXJuIFVbMF09MCxVWzFdPTAsVVsyXT0wLFVbM109MSxVWzRdPTAsVVs1XT0wLFVbNl09MCxVWzddPTAsVX1mdW5jdGlvbiB5KFUsJCxRLHR0LEYsSCx4LFAsVyl7cmV0dXJuIFVbMF09JCxVWzFdPVEsVVsyXT10dCxVWzNdPUYsVVs0XT1ILFVbNV09eCxVWzZdPVAsVVs3XT1XLFV9dmFyIFM9aS5jb3B5O2Z1bmN0aW9uIHMoVSwkKXtyZXR1cm4gVVswXT0kWzRdLFVbMV09JFs1XSxVWzJdPSRbNl0sVVszXT0kWzddLFV9dmFyIGM9aS5jb3B5O2Z1bmN0aW9uIGwoVSwkKXtyZXR1cm4gVVs0XT0kWzBdLFVbNV09JFsxXSxVWzZdPSRbMl0sVVs3XT0kWzNdLFV9ZnVuY3Rpb24gdihVLCQpe3ZhciBRPSRbNF0sdHQ9JFs1XSxGPSRbNl0sSD0kWzddLHg9LSRbMF0sUD0tJFsxXSxXPS0kWzJdLEs9JFszXTtyZXR1cm4gVVswXT0oUSpLK0gqeCt0dCpXLUYqUCkqMixVWzFdPSh0dCpLK0gqUCtGKngtUSpXKSoyLFVbMl09KEYqSytIKlcrUSpQLXR0KngpKjIsVX1mdW5jdGlvbiBUKFUsJCxRKXt2YXIgdHQ9JFswXSxGPSRbMV0sSD0kWzJdLHg9JFszXSxQPVFbMF0qLjUsVz1RWzFdKi41LEs9UVsyXSouNSxaPSRbNF0saz0kWzVdLG50PSRbNl0sdXQ9JFs3XTtyZXR1cm4gVVswXT10dCxVWzFdPUYsVVsyXT1ILFVbM109eCxVWzRdPXgqUCtGKkstSCpXK1osVVs1XT14KlcrSCpQLXR0KksrayxVWzZdPXgqSyt0dCpXLUYqUCtudCxVWzddPS10dCpQLUYqVy1IKksrdXQsVX1mdW5jdGlvbiBSKFUsJCxRKXt2YXIgdHQ9LSRbMF0sRj0tJFsxXSxIPS0kWzJdLHg9JFszXSxQPSRbNF0sVz0kWzVdLEs9JFs2XSxaPSRbN10saz1QKngrWip0dCtXKkgtSypGLG50PVcqeCtaKkYrSyp0dC1QKkgsdXQ9Syp4K1oqSCtQKkYtVyp0dCxjdD1aKngtUCp0dC1XKkYtSypIO3JldHVybiBpLnJvdGF0ZVgoVSwkLFEpLHR0PVVbMF0sRj1VWzFdLEg9VVsyXSx4PVVbM10sVVs0XT1rKngrY3QqdHQrbnQqSC11dCpGLFVbNV09bnQqeCtjdCpGK3V0KnR0LWsqSCxVWzZdPXV0KngrY3QqSCtrKkYtbnQqdHQsVVs3XT1jdCp4LWsqdHQtbnQqRi11dCpILFV9ZnVuY3Rpb24gTChVLCQsUSl7dmFyIHR0PS0kWzBdLEY9LSRbMV0sSD0tJFsyXSx4PSRbM10sUD0kWzRdLFc9JFs1XSxLPSRbNl0sWj0kWzddLGs9UCp4K1oqdHQrVypILUsqRixudD1XKngrWipGK0sqdHQtUCpILHV0PUsqeCtaKkgrUCpGLVcqdHQsY3Q9Wip4LVAqdHQtVypGLUsqSDtyZXR1cm4gaS5yb3RhdGVZKFUsJCxRKSx0dD1VWzBdLEY9VVsxXSxIPVVbMl0seD1VWzNdLFVbNF09ayp4K2N0KnR0K250KkgtdXQqRixVWzVdPW50KngrY3QqRit1dCp0dC1rKkgsVVs2XT11dCp4K2N0KkgraypGLW50KnR0LFVbN109Y3QqeC1rKnR0LW50KkYtdXQqSCxVfWZ1bmN0aW9uIE4oVSwkLFEpe3ZhciB0dD0tJFswXSxGPS0kWzFdLEg9LSRbMl0seD0kWzNdLFA9JFs0XSxXPSRbNV0sSz0kWzZdLFo9JFs3XSxrPVAqeCtaKnR0K1cqSC1LKkYsbnQ9Vyp4K1oqRitLKnR0LVAqSCx1dD1LKngrWipIK1AqRi1XKnR0LGN0PVoqeC1QKnR0LVcqRi1LKkg7cmV0dXJuIGkucm90YXRlWihVLCQsUSksdHQ9VVswXSxGPVVbMV0sSD1VWzJdLHg9VVszXSxVWzRdPWsqeCtjdCp0dCtudCpILXV0KkYsVVs1XT1udCp4K2N0KkYrdXQqdHQtaypILFVbNl09dXQqeCtjdCpIK2sqRi1udCp0dCxVWzddPWN0Kngtayp0dC1udCpGLXV0KkgsVX1mdW5jdGlvbiBBKFUsJCxRKXt2YXIgdHQ9UVswXSxGPVFbMV0sSD1RWzJdLHg9UVszXSxQPSRbMF0sVz0kWzFdLEs9JFsyXSxaPSRbM107cmV0dXJuIFVbMF09UCp4K1oqdHQrVypILUsqRixVWzFdPVcqeCtaKkYrSyp0dC1QKkgsVVsyXT1LKngrWipIK1AqRi1XKnR0LFVbM109Wip4LVAqdHQtVypGLUsqSCxQPSRbNF0sVz0kWzVdLEs9JFs2XSxaPSRbN10sVVs0XT1QKngrWip0dCtXKkgtSypGLFVbNV09Vyp4K1oqRitLKnR0LVAqSCxVWzZdPUsqeCtaKkgrUCpGLVcqdHQsVVs3XT1aKngtUCp0dC1XKkYtSypILFV9ZnVuY3Rpb24gdyhVLCQsUSl7dmFyIHR0PSRbMF0sRj0kWzFdLEg9JFsyXSx4PSRbM10sUD1RWzBdLFc9UVsxXSxLPVFbMl0sWj1RWzNdO3JldHVybiBVWzBdPXR0KloreCpQK0YqSy1IKlcsVVsxXT1GKloreCpXK0gqUC10dCpLLFVbMl09SCpaK3gqSyt0dCpXLUYqUCxVWzNdPXgqWi10dCpQLUYqVy1IKkssUD1RWzRdLFc9UVs1XSxLPVFbNl0sWj1RWzddLFVbNF09dHQqWit4KlArRipLLUgqVyxVWzVdPUYqWit4KlcrSCpQLXR0KkssVVs2XT1IKloreCpLK3R0KlctRipQLFVbN109eCpaLXR0KlAtRipXLUgqSyxVfWZ1bmN0aW9uIEIoVSwkLFEsdHQpe2lmKE1hdGguYWJzKHR0KTxuLkVQU0lMT04pcmV0dXJuIGIoVSwkKTt2YXIgRj1NYXRoLmh5cG90KFFbMF0sUVsxXSxRWzJdKTt0dD10dCouNTt2YXIgSD1NYXRoLnNpbih0dCkseD1IKlFbMF0vRixQPUgqUVsxXS9GLFc9SCpRWzJdL0YsSz1NYXRoLmNvcyh0dCksWj0kWzBdLGs9JFsxXSxudD0kWzJdLHV0PSRbM107VVswXT1aKksrdXQqeCtrKlctbnQqUCxVWzFdPWsqSyt1dCpQK250KngtWipXLFVbMl09bnQqSyt1dCpXK1oqUC1rKngsVVszXT11dCpLLVoqeC1rKlAtbnQqVzt2YXIgY3Q9JFs0XSxwdD0kWzVdLHh0PSRbNl0sZ3Q9JFs3XTtyZXR1cm4gVVs0XT1jdCpLK2d0KngrcHQqVy14dCpQLFVbNV09cHQqSytndCpQK3h0KngtY3QqVyxVWzZdPXh0KksrZ3QqVytjdCpQLXB0KngsVVs3XT1ndCpLLWN0KngtcHQqUC14dCpXLFV9ZnVuY3Rpb24gRChVLCQsUSl7cmV0dXJuIFVbMF09JFswXStRWzBdLFVbMV09JFsxXStRWzFdLFVbMl09JFsyXStRWzJdLFVbM109JFszXStRWzNdLFVbNF09JFs0XStRWzRdLFVbNV09JFs1XStRWzVdLFVbNl09JFs2XStRWzZdLFVbN109JFs3XStRWzddLFV9ZnVuY3Rpb24gSShVLCQsUSl7dmFyIHR0PSRbMF0sRj0kWzFdLEg9JFsyXSx4PSRbM10sUD1RWzRdLFc9UVs1XSxLPVFbNl0sWj1RWzddLGs9JFs0XSxudD0kWzVdLHV0PSRbNl0sY3Q9JFs3XSxwdD1RWzBdLHh0PVFbMV0sZ3Q9UVsyXSxkdD1RWzNdO3JldHVybiBVWzBdPXR0KmR0K3gqcHQrRipndC1IKnh0LFVbMV09RipkdCt4Knh0K0gqcHQtdHQqZ3QsVVsyXT1IKmR0K3gqZ3QrdHQqeHQtRipwdCxVWzNdPXgqZHQtdHQqcHQtRip4dC1IKmd0LFVbNF09dHQqWit4KlArRipLLUgqVytrKmR0K2N0KnB0K250Kmd0LXV0Knh0LFVbNV09RipaK3gqVytIKlAtdHQqSytudCpkdCtjdCp4dCt1dCpwdC1rKmd0LFVbNl09SCpaK3gqSyt0dCpXLUYqUCt1dCpkdCtjdCpndCtrKnh0LW50KnB0LFVbN109eCpaLXR0KlAtRipXLUgqSytjdCpkdC1rKnB0LW50Knh0LXV0Kmd0LFV9dmFyIGo9STtmdW5jdGlvbiBWKFUsJCxRKXtyZXR1cm4gVVswXT0kWzBdKlEsVVsxXT0kWzFdKlEsVVsyXT0kWzJdKlEsVVszXT0kWzNdKlEsVVs0XT0kWzRdKlEsVVs1XT0kWzVdKlEsVVs2XT0kWzZdKlEsVVs3XT0kWzddKlEsVX12YXIgSj1pLmRvdDtmdW5jdGlvbiBfKFUsJCxRLHR0KXt2YXIgRj0xLXR0O3JldHVybiBKKCQsUSk8MCYmKHR0PS10dCksVVswXT0kWzBdKkYrUVswXSp0dCxVWzFdPSRbMV0qRitRWzFdKnR0LFVbMl09JFsyXSpGK1FbMl0qdHQsVVszXT0kWzNdKkYrUVszXSp0dCxVWzRdPSRbNF0qRitRWzRdKnR0LFVbNV09JFs1XSpGK1FbNV0qdHQsVVs2XT0kWzZdKkYrUVs2XSp0dCxVWzddPSRbN10qRitRWzddKnR0LFV9ZnVuY3Rpb24gc3QoVSwkKXt2YXIgUT1vdCgkKTtyZXR1cm4gVVswXT0tJFswXS9RLFVbMV09LSRbMV0vUSxVWzJdPS0kWzJdL1EsVVszXT0kWzNdL1EsVVs0XT0tJFs0XS9RLFVbNV09LSRbNV0vUSxVWzZdPS0kWzZdL1EsVVs3XT0kWzddL1EsVX1mdW5jdGlvbiBHKFUsJCl7cmV0dXJuIFVbMF09LSRbMF0sVVsxXT0tJFsxXSxVWzJdPS0kWzJdLFVbM109JFszXSxVWzRdPS0kWzRdLFVbNV09LSRbNV0sVVs2XT0tJFs2XSxVWzddPSRbN10sVX12YXIgWT1pLmxlbmd0aCxydD1ZLG90PWkuc3F1YXJlZExlbmd0aCxhdD1vdDtmdW5jdGlvbiBodChVLCQpe3ZhciBRPW90KCQpO2lmKFE+MCl7UT1NYXRoLnNxcnQoUSk7dmFyIHR0PSRbMF0vUSxGPSRbMV0vUSxIPSRbMl0vUSx4PSRbM10vUSxQPSRbNF0sVz0kWzVdLEs9JFs2XSxaPSRbN10saz10dCpQK0YqVytIKksreCpaO1VbMF09dHQsVVsxXT1GLFVbMl09SCxVWzNdPXgsVVs0XT0oUC10dCprKS9RLFVbNV09KFctRiprKS9RLFVbNl09KEstSCprKS9RLFVbN109KFoteCprKS9RfXJldHVybiBVfWZ1bmN0aW9uIGl0KFUpe3JldHVybiJxdWF0MigiK1VbMF0rIiwgIitVWzFdKyIsICIrVVsyXSsiLCAiK1VbM10rIiwgIitVWzRdKyIsICIrVVs1XSsiLCAiK1VbNl0rIiwgIitVWzddKyIpIn1mdW5jdGlvbiBNdChVLCQpe3JldHVybiBVWzBdPT09JFswXSYmVVsxXT09PSRbMV0mJlVbMl09PT0kWzJdJiZVWzNdPT09JFszXSYmVVs0XT09PSRbNF0mJlVbNV09PT0kWzVdJiZVWzZdPT09JFs2XSYmVVs3XT09PSRbN119ZnVuY3Rpb24gT3QoVSwkKXt2YXIgUT1VWzBdLHR0PVVbMV0sRj1VWzJdLEg9VVszXSx4PVVbNF0sUD1VWzVdLFc9VVs2XSxLPVVbN10sWj0kWzBdLGs9JFsxXSxudD0kWzJdLHV0PSRbM10sY3Q9JFs0XSxwdD0kWzVdLHh0PSRbNl0sZ3Q9JFs3XTtyZXR1cm4gTWF0aC5hYnMoUS1aKTw9bi5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoUSksTWF0aC5hYnMoWikpJiZNYXRoLmFicyh0dC1rKTw9bi5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnModHQpLE1hdGguYWJzKGspKSYmTWF0aC5hYnMoRi1udCk8PW4uRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKEYpLE1hdGguYWJzKG50KSkmJk1hdGguYWJzKEgtdXQpPD1uLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhIKSxNYXRoLmFicyh1dCkpJiZNYXRoLmFicyh4LWN0KTw9bi5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoeCksTWF0aC5hYnMoY3QpKSYmTWF0aC5hYnMoUC1wdCk8PW4uRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKFApLE1hdGguYWJzKHB0KSkmJk1hdGguYWJzKFcteHQpPD1uLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhXKSxNYXRoLmFicyh4dCkpJiZNYXRoLmFicyhLLWd0KTw9bi5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoSyksTWF0aC5hYnMoZ3QpKX19LGZ1bmN0aW9uKGcsZSx0KXt0LnIoZSksdC5kKGUsImNyZWF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gaX0pLHQuZChlLCJjbG9uZSIsZnVuY3Rpb24oKXtyZXR1cm4gZn0pLHQuZChlLCJmcm9tVmFsdWVzIixmdW5jdGlvbigpe3JldHVybiBofSksdC5kKGUsImNvcHkiLGZ1bmN0aW9uKCl7cmV0dXJuIHV9KSx0LmQoZSwic2V0IixmdW5jdGlvbigpe3JldHVybiBhfSksdC5kKGUsImFkZCIsZnVuY3Rpb24oKXtyZXR1cm4gZH0pLHQuZChlLCJzdWJ0cmFjdCIsZnVuY3Rpb24oKXtyZXR1cm4gRX0pLHQuZChlLCJtdWx0aXBseSIsZnVuY3Rpb24oKXtyZXR1cm4gcH0pLHQuZChlLCJkaXZpZGUiLGZ1bmN0aW9uKCl7cmV0dXJuIE99KSx0LmQoZSwiY2VpbCIsZnVuY3Rpb24oKXtyZXR1cm4gbX0pLHQuZChlLCJmbG9vciIsZnVuY3Rpb24oKXtyZXR1cm4gYn0pLHQuZChlLCJtaW4iLGZ1bmN0aW9uKCl7cmV0dXJuIE19KSx0LmQoZSwibWF4IixmdW5jdGlvbigpe3JldHVybiB5fSksdC5kKGUsInJvdW5kIixmdW5jdGlvbigpe3JldHVybiBTfSksdC5kKGUsInNjYWxlIixmdW5jdGlvbigpe3JldHVybiBzfSksdC5kKGUsInNjYWxlQW5kQWRkIixmdW5jdGlvbigpe3JldHVybiBjfSksdC5kKGUsImRpc3RhbmNlIixmdW5jdGlvbigpe3JldHVybiBsfSksdC5kKGUsInNxdWFyZWREaXN0YW5jZSIsZnVuY3Rpb24oKXtyZXR1cm4gdn0pLHQuZChlLCJsZW5ndGgiLGZ1bmN0aW9uKCl7cmV0dXJuIFR9KSx0LmQoZSwic3F1YXJlZExlbmd0aCIsZnVuY3Rpb24oKXtyZXR1cm4gUn0pLHQuZChlLCJuZWdhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIEx9KSx0LmQoZSwiaW52ZXJzZSIsZnVuY3Rpb24oKXtyZXR1cm4gTn0pLHQuZChlLCJub3JtYWxpemUiLGZ1bmN0aW9uKCl7cmV0dXJuIEF9KSx0LmQoZSwiZG90IixmdW5jdGlvbigpe3JldHVybiB3fSksdC5kKGUsImNyb3NzIixmdW5jdGlvbigpe3JldHVybiBCfSksdC5kKGUsImxlcnAiLGZ1bmN0aW9uKCl7cmV0dXJuIER9KSx0LmQoZSwicmFuZG9tIixmdW5jdGlvbigpe3JldHVybiBJfSksdC5kKGUsInRyYW5zZm9ybU1hdDIiLGZ1bmN0aW9uKCl7cmV0dXJuIGp9KSx0LmQoZSwidHJhbnNmb3JtTWF0MmQiLGZ1bmN0aW9uKCl7cmV0dXJuIFZ9KSx0LmQoZSwidHJhbnNmb3JtTWF0MyIsZnVuY3Rpb24oKXtyZXR1cm4gSn0pLHQuZChlLCJ0cmFuc2Zvcm1NYXQ0IixmdW5jdGlvbigpe3JldHVybiBffSksdC5kKGUsInJvdGF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gc3R9KSx0LmQoZSwiYW5nbGUiLGZ1bmN0aW9uKCl7cmV0dXJuIEd9KSx0LmQoZSwiemVybyIsZnVuY3Rpb24oKXtyZXR1cm4gWX0pLHQuZChlLCJzdHIiLGZ1bmN0aW9uKCl7cmV0dXJuIHJ0fSksdC5kKGUsImV4YWN0RXF1YWxzIixmdW5jdGlvbigpe3JldHVybiBvdH0pLHQuZChlLCJlcXVhbHMiLGZ1bmN0aW9uKCl7cmV0dXJuIGF0fSksdC5kKGUsImxlbiIsZnVuY3Rpb24oKXtyZXR1cm4gaHR9KSx0LmQoZSwic3ViIixmdW5jdGlvbigpe3JldHVybiBpdH0pLHQuZChlLCJtdWwiLGZ1bmN0aW9uKCl7cmV0dXJuIE10fSksdC5kKGUsImRpdiIsZnVuY3Rpb24oKXtyZXR1cm4gT3R9KSx0LmQoZSwiZGlzdCIsZnVuY3Rpb24oKXtyZXR1cm4gVX0pLHQuZChlLCJzcXJEaXN0IixmdW5jdGlvbigpe3JldHVybiAkfSksdC5kKGUsInNxckxlbiIsZnVuY3Rpb24oKXtyZXR1cm4gUX0pLHQuZChlLCJmb3JFYWNoIixmdW5jdGlvbigpe3JldHVybiB0dH0pO3ZhciBuPXQoMik7ZnVuY3Rpb24gaSgpe3ZhciBGPW5ldyBuLkFSUkFZX1RZUEUoMik7cmV0dXJuIG4uQVJSQVlfVFlQRSE9RmxvYXQzMkFycmF5JiYoRlswXT0wLEZbMV09MCksRn1mdW5jdGlvbiBmKEYpe3ZhciBIPW5ldyBuLkFSUkFZX1RZUEUoMik7cmV0dXJuIEhbMF09RlswXSxIWzFdPUZbMV0sSH1mdW5jdGlvbiBoKEYsSCl7dmFyIHg9bmV3IG4uQVJSQVlfVFlQRSgyKTtyZXR1cm4geFswXT1GLHhbMV09SCx4fWZ1bmN0aW9uIHUoRixIKXtyZXR1cm4gRlswXT1IWzBdLEZbMV09SFsxXSxGfWZ1bmN0aW9uIGEoRixILHgpe3JldHVybiBGWzBdPUgsRlsxXT14LEZ9ZnVuY3Rpb24gZChGLEgseCl7cmV0dXJuIEZbMF09SFswXSt4WzBdLEZbMV09SFsxXSt4WzFdLEZ9ZnVuY3Rpb24gRShGLEgseCl7cmV0dXJuIEZbMF09SFswXS14WzBdLEZbMV09SFsxXS14WzFdLEZ9ZnVuY3Rpb24gcChGLEgseCl7cmV0dXJuIEZbMF09SFswXSp4WzBdLEZbMV09SFsxXSp4WzFdLEZ9ZnVuY3Rpb24gTyhGLEgseCl7cmV0dXJuIEZbMF09SFswXS94WzBdLEZbMV09SFsxXS94WzFdLEZ9ZnVuY3Rpb24gbShGLEgpe3JldHVybiBGWzBdPU1hdGguY2VpbChIWzBdKSxGWzFdPU1hdGguY2VpbChIWzFdKSxGfWZ1bmN0aW9uIGIoRixIKXtyZXR1cm4gRlswXT1NYXRoLmZsb29yKEhbMF0pLEZbMV09TWF0aC5mbG9vcihIWzFdKSxGfWZ1bmN0aW9uIE0oRixILHgpe3JldHVybiBGWzBdPU1hdGgubWluKEhbMF0seFswXSksRlsxXT1NYXRoLm1pbihIWzFdLHhbMV0pLEZ9ZnVuY3Rpb24geShGLEgseCl7cmV0dXJuIEZbMF09TWF0aC5tYXgoSFswXSx4WzBdKSxGWzFdPU1hdGgubWF4KEhbMV0seFsxXSksRn1mdW5jdGlvbiBTKEYsSCl7cmV0dXJuIEZbMF09TWF0aC5yb3VuZChIWzBdKSxGWzFdPU1hdGgucm91bmQoSFsxXSksRn1mdW5jdGlvbiBzKEYsSCx4KXtyZXR1cm4gRlswXT1IWzBdKngsRlsxXT1IWzFdKngsRn1mdW5jdGlvbiBjKEYsSCx4LFApe3JldHVybiBGWzBdPUhbMF0reFswXSpQLEZbMV09SFsxXSt4WzFdKlAsRn1mdW5jdGlvbiBsKEYsSCl7dmFyIHg9SFswXS1GWzBdLFA9SFsxXS1GWzFdO3JldHVybiBNYXRoLmh5cG90KHgsUCl9ZnVuY3Rpb24gdihGLEgpe3ZhciB4PUhbMF0tRlswXSxQPUhbMV0tRlsxXTtyZXR1cm4geCp4K1AqUH1mdW5jdGlvbiBUKEYpe3ZhciBIPUZbMF0seD1GWzFdO3JldHVybiBNYXRoLmh5cG90KEgseCl9ZnVuY3Rpb24gUihGKXt2YXIgSD1GWzBdLHg9RlsxXTtyZXR1cm4gSCpIK3gqeH1mdW5jdGlvbiBMKEYsSCl7cmV0dXJuIEZbMF09LUhbMF0sRlsxXT0tSFsxXSxGfWZ1bmN0aW9uIE4oRixIKXtyZXR1cm4gRlswXT0xL0hbMF0sRlsxXT0xL0hbMV0sRn1mdW5jdGlvbiBBKEYsSCl7dmFyIHg9SFswXSxQPUhbMV0sVz14KngrUCpQO3JldHVybiBXPjAmJihXPTEvTWF0aC5zcXJ0KFcpKSxGWzBdPUhbMF0qVyxGWzFdPUhbMV0qVyxGfWZ1bmN0aW9uIHcoRixIKXtyZXR1cm4gRlswXSpIWzBdK0ZbMV0qSFsxXX1mdW5jdGlvbiBCKEYsSCx4KXt2YXIgUD1IWzBdKnhbMV0tSFsxXSp4WzBdO3JldHVybiBGWzBdPUZbMV09MCxGWzJdPVAsRn1mdW5jdGlvbiBEKEYsSCx4LFApe3ZhciBXPUhbMF0sSz1IWzFdO3JldHVybiBGWzBdPVcrUCooeFswXS1XKSxGWzFdPUsrUCooeFsxXS1LKSxGfWZ1bmN0aW9uIEkoRixIKXtIPUh8fDE7dmFyIHg9bi5SQU5ET00oKSoyKk1hdGguUEk7cmV0dXJuIEZbMF09TWF0aC5jb3MoeCkqSCxGWzFdPU1hdGguc2luKHgpKkgsRn1mdW5jdGlvbiBqKEYsSCx4KXt2YXIgUD1IWzBdLFc9SFsxXTtyZXR1cm4gRlswXT14WzBdKlAreFsyXSpXLEZbMV09eFsxXSpQK3hbM10qVyxGfWZ1bmN0aW9uIFYoRixILHgpe3ZhciBQPUhbMF0sVz1IWzFdO3JldHVybiBGWzBdPXhbMF0qUCt4WzJdKlcreFs0XSxGWzFdPXhbMV0qUCt4WzNdKlcreFs1XSxGfWZ1bmN0aW9uIEooRixILHgpe3ZhciBQPUhbMF0sVz1IWzFdO3JldHVybiBGWzBdPXhbMF0qUCt4WzNdKlcreFs2XSxGWzFdPXhbMV0qUCt4WzRdKlcreFs3XSxGfWZ1bmN0aW9uIF8oRixILHgpe3ZhciBQPUhbMF0sVz1IWzFdO3JldHVybiBGWzBdPXhbMF0qUCt4WzRdKlcreFsxMl0sRlsxXT14WzFdKlAreFs1XSpXK3hbMTNdLEZ9ZnVuY3Rpb24gc3QoRixILHgsUCl7dmFyIFc9SFswXS14WzBdLEs9SFsxXS14WzFdLFo9TWF0aC5zaW4oUCksaz1NYXRoLmNvcyhQKTtyZXR1cm4gRlswXT1XKmstSypaK3hbMF0sRlsxXT1XKlorSyprK3hbMV0sRn1mdW5jdGlvbiBHKEYsSCl7dmFyIHg9RlswXSxQPUZbMV0sVz1IWzBdLEs9SFsxXSxaPU1hdGguc3FydCh4KngrUCpQKSpNYXRoLnNxcnQoVypXK0sqSyksaz1aJiYoeCpXK1AqSykvWjtyZXR1cm4gTWF0aC5hY29zKE1hdGgubWluKE1hdGgubWF4KGssLTEpLDEpKX1mdW5jdGlvbiBZKEYpe3JldHVybiBGWzBdPTAsRlsxXT0wLEZ9ZnVuY3Rpb24gcnQoRil7cmV0dXJuInZlYzIoIitGWzBdKyIsICIrRlsxXSsiKSJ9ZnVuY3Rpb24gb3QoRixIKXtyZXR1cm4gRlswXT09PUhbMF0mJkZbMV09PT1IWzFdfWZ1bmN0aW9uIGF0KEYsSCl7dmFyIHg9RlswXSxQPUZbMV0sVz1IWzBdLEs9SFsxXTtyZXR1cm4gTWF0aC5hYnMoeC1XKTw9bi5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoeCksTWF0aC5hYnMoVykpJiZNYXRoLmFicyhQLUspPD1uLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhQKSxNYXRoLmFicyhLKSl9dmFyIGh0PVQsaXQ9RSxNdD1wLE90PU8sVT1sLCQ9dixRPVIsdHQ9ZnVuY3Rpb24oKXt2YXIgRj1pKCk7cmV0dXJuIGZ1bmN0aW9uKEgseCxQLFcsSyxaKXt2YXIgayxudDtmb3IoeHx8KHg9MiksUHx8KFA9MCksVz9udD1NYXRoLm1pbihXKngrUCxILmxlbmd0aCk6bnQ9SC5sZW5ndGgsaz1QO2s8bnQ7ays9eClGWzBdPUhba10sRlsxXT1IW2srMV0sSyhGLEYsWiksSFtrXT1GWzBdLEhbaysxXT1GWzFdO3JldHVybiBIfX0oKX0sZnVuY3Rpb24oZyxlLHQpe3QucihlKTt2YXIgbj10KDEzKTt0LmQoZSwiUmVuZGVyZXIiLGZ1bmN0aW9uKCl7cmV0dXJuIG4uZGVmYXVsdH0pO3ZhciBpPXQoNDApO3QuZChlLCJGaWd1cmUyRCIsZnVuY3Rpb24oKXtyZXR1cm4gaS5kZWZhdWx0fSk7dmFyIGY9dCg1Nik7dC5kKGUsIk1lc2gyRCIsZnVuY3Rpb24oKXtyZXR1cm4gZi5kZWZhdWx0fSk7dmFyIGg9dCgyOSk7dC5kKGUsIk1lc2hDbG91ZCIsZnVuY3Rpb24oKXtyZXR1cm4gaC5kZWZhdWx0fSk7dmFyIHU9dCgyMyk7dC5kKGUsInBhcnNlRm9udCIsZnVuY3Rpb24oKXtyZXR1cm4gdS5kZWZhdWx0fSk7dmFyIGE9dCgzMSk7dC5kKGUsInBhcnNlQ29sb3IiLGZ1bmN0aW9uKCl7cmV0dXJuIGEuZGVmYXVsdH0pO3ZhciBkPXQoMjEpO3QuZChlLCJFTlYiLGZ1bmN0aW9uKCl7cmV0dXJuIGQuZGVmYXVsdH0pLHQoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KX0sZnVuY3Rpb24oZyxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gTn0pO3ZhciBuPXQoMTQpLGk9dCgxKSxmPXQoMjApLGg9dCgyNyksdT10KDI1KSxhPXQoNDApLGQ9dCg1NiksRT10KDI5KSxwPXQoNTkpLE89dCgyMSksbT10KDYzKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3QgYj17YXV0b1VwZGF0ZTohMSxwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6ITEsYnVmZmVyU2l6ZToxNTAwfSxNPWBhdHRyaWJ1dGUgdmVjMyBhX3ZlcnRleFBvc2l0aW9uOwphdHRyaWJ1dGUgdmVjMyBhX3ZlcnRleFRleHR1cmVDb29yZDsKdmFyeWluZyB2ZWMzIHZUZXh0dXJlQ29vcmQ7CnVuaWZvcm0gbWF0MyB2aWV3TWF0cml4Owp1bmlmb3JtIG1hdDMgcHJvamVjdGlvbk1hdHJpeDsKCnZvaWQgbWFpbigpIHsKICBnbF9Qb2ludFNpemUgPSAxLjA7CiAgdmVjMyBwb3MgPSBwcm9qZWN0aW9uTWF0cml4ICogdmlld01hdHJpeCAqIHZlYzMoYV92ZXJ0ZXhQb3NpdGlvbi54eSwgMS4wKTsKICBnbF9Qb3NpdGlvbiA9IHZlYzQocG9zLnh5LCAxLjAsIDEuMCk7ICAgIAogIHZUZXh0dXJlQ29vcmQgPSBhX3ZlcnRleFRleHR1cmVDb29yZDsgICAgICAgICAgICAgIAp9CmAseT1gcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7CnZhcnlpbmcgdmVjMyB2VGV4dHVyZUNvb3JkOwp1bmlmb3JtIHNhbXBsZXIyRCB1X3RleFNhbXBsZXI7CnZvaWQgbWFpbigpIHsKICBnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQodV90ZXhTYW1wbGVyLCB2VGV4dHVyZUNvb3JkLnh5KTsKfQpgLFM9U3ltYm9sKCJnbFJlbmRlcmVyIikscz1TeW1ib2woImNhbnZhc1JlbmRlcmVyIiksYz1TeW1ib2woIm9wdGlvbnMiKSxsPVN5bWJvbCgiZ2xvYmFsVHJhbnNmb3JtIiksdj1TeW1ib2woImFwcGx5R2xvYmFsVHJhbnNmb3JtIiksVD1TeW1ib2woImNhbnZhcyIpO2Z1bmN0aW9uIFIoQSl7Y29uc3Qgdz1BLmdsLEI9QS5mYm87QiYmdy5iaW5kRnJhbWVidWZmZXIody5GUkFNRUJVRkZFUixCKSxBLl9kcmF3KCksQiYmdy5iaW5kRnJhbWVidWZmZXIody5GUkFNRUJVRkZFUixudWxsKX1mdW5jdGlvbiBMKEEsdyxCLEQpe2NvbnN0IEk9QS5jcmVhdGVUZXh0dXJlKHcuY2FudmFzKSxqPVtbWzAsMF0sW0IsMF0sW0IsRF0sWzAsRF0sWzAsMF1dXTtqLmNsb3NlZD0hMDtjb25zdCBWPW5ldyBkLmRlZmF1bHQoe2NvbnRvdXJzOmp9KTtWLnNldFRleHR1cmUoSSksQS5zZXRNZXNoRGF0YShbVi5tZXNoRGF0YV0pLFIoQSksSS5kZWxldGUoKSx3LmNsZWFyUmVjdCgwLDAsQixEKSxkZWxldGUgdy5fZmlsdGVyfWNsYXNzIE57Y29uc3RydWN0b3IodyxCPXt9KXtsZXQgRD1CLmNvbnRleHRUeXBlO2lmKER8fCh0eXBlb2YgV2ViR0wyUmVuZGVyaW5nQ29udGV4dD09ImZ1bmN0aW9uIj9EPSJ3ZWJnbDIiOnR5cGVvZiBXZWJHTFJlbmRlcmluZ0NvbnRleHQ9PSJmdW5jdGlvbiI/RD0id2ViZ2wiOkQ9IjJkIiksIXcuZ2V0Q29udGV4dCl7Y29uc3QgST13O3c9e2dldENvbnRleHQoKXtyZXR1cm4gSX0sd2lkdGg6Qi53aWR0aCxoZWlnaHQ6Qi5oZWlnaHR9LEkuY2FudmFzPXcsRD0iMmQifWlmKHRoaXNbVF09dyxEIT09IndlYmdsIiYmRCE9PSJ3ZWJnbDIiJiZEIT09IjJkIil0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gY29udGV4dCB0eXBlICR7RH1gKTtpZihCLmNvbnRleHRUeXBlPUQsdGhpc1tjXT1PYmplY3QuYXNzaWduKHt9LGIsQiksRD09PSJ3ZWJnbCJ8fEQ9PT0id2ViZ2wyIil7RD09PSJ3ZWJnbDIiJiYodGhpc1tjXS53ZWJnbDI9ITApO2NvbnN0IEk9bmV3IG4uZGVmYXVsdCh3LHRoaXNbY10pO0Q9PT0id2ViZ2wyIiYmIUkuaXNXZWJHTDImJihCLmNvbnRleHRUeXBlPSJ3ZWJnbCIpLE9iamVjdChtLmNyZWF0ZVNoYWRlcnMpKEkpLE9iamVjdChtLmFwcGx5U2hhZGVyKShJKSxPYmplY3QobS5jcmVhdGVDbG91ZFNoYWRlcnMpKEkpO2NvbnN0IGo9SS5nbDtqLmNsZWFyQ29sb3IoMCwwLDAsMCksai5ibGVuZEZ1bmNTZXBhcmF0ZShqLlNSQ19BTFBIQSxqLk9ORV9NSU5VU19TUkNfQUxQSEEsai5PTkUsai5PTkVfTUlOVVNfU1JDX0FMUEhBKSx0aGlzW1NdPUl9ZWxzZSB0aGlzW3NdPW5ldyBmLmRlZmF1bHQodyx0aGlzW2NdKTt0aGlzW2xdPVsxLDAsMCwwLDEsMCwwLDAsMV0sdGhpcy51cGRhdGVSZXNvbHV0aW9uKCl9Z2V0IGNhbnZhcygpe3JldHVybiB0aGlzW1RdfWdldCBjYW52YXNSZW5kZXJlcigpe3JldHVybiB0aGlzW3NdfWdldCBnbFJlbmRlcmVyKCl7cmV0dXJuIHRoaXNbU119Z2V0IGlzV2ViR0wyKCl7cmV0dXJuIHRoaXNbU10mJnRoaXNbU10uaXNXZWJHTDJ9Z2V0IG9wdGlvbnMoKXtyZXR1cm4gdGhpc1tjXX1nZXQgZ2xvYmFsVHJhbnNmb3JtTWF0cml4KCl7Y29uc3Qgdz10aGlzW2xdO3JldHVyblt3WzBdLHdbMV0sd1szXSx3WzRdLHdbNl0sd1s3XV19Z2V0IHZpZXdNYXRyaXgoKXtyZXR1cm4gdGhpc1tsXX1bdl0oKXtjb25zdCB3PXRoaXNbU118fHRoaXNbc107aWYodGhpc1tTXSl7Y29uc3R7d2lkdGg6QixoZWlnaHQ6RH09dGhpcy5jYW52YXM7dy51bmlmb3Jtcy52aWV3TWF0cml4PXRoaXMudmlld01hdHJpeCx3LnVuaWZvcm1zLnByb2plY3Rpb25NYXRyaXg9dGhpcy5wcm9qZWN0aW9uTWF0cml4LHcudW5pZm9ybXMudV9yZXNvbHV0aW9uPVtCLERdfX11cGRhdGVSZXNvbHV0aW9uKCl7Y29uc3R7d2lkdGg6dyxoZWlnaHQ6Qn09dGhpcy5jYW52YXMsRD1bMSwwLDAsMCwxLDAsLXcvMiwtQi8yLDFdLEk9WzIvdywwLDAsMCwtMi9CLDAsMCwwLDFdLGo9aS5tYXQzLm11bHRpcGx5KEFycmF5Lm9mKDAsMCwwLDAsMCwwLDAsMCwwKSxJLEQpO3RoaXMucHJvamVjdGlvbk1hdHJpeD1qLHRoaXNbU10mJnRoaXNbU10uZ2wudmlld3BvcnQoMCwwLHcsQil9Y3JlYXRlVGV4dHVyZSh3LEIpe3JldHVybih0aGlzW1NdfHx0aGlzW3NdKS5jcmVhdGVUZXh0dXJlKHcsQil9bG9hZFRleHR1cmUodyx7dXNlSW1hZ2VCaXRtYXA6Qj0hMX09e30pe3JldHVybih0aGlzW1NdfHx0aGlzW3NdKS5sb2FkVGV4dHVyZSh3LHt1c2VJbWFnZUJpdG1hcDpCfSl9Y3JlYXRlVGV4dCh3LHtmb250OkI9IjE2cHggYXJpYWwiLGZpbGxDb2xvcjpEPW51bGwsc3Ryb2tlQ29sb3I6ST1udWxsLHN0cm9rZVdpZHRoOmo9MX09e30pe2lmKHRoaXNbU10pe2NvbnN0IFY9Ty5kZWZhdWx0LmNyZWF0ZVRleHQodyx7Zm9udDpCLGZpbGxDb2xvcjpELHN0cm9rZUNvbG9yOkksc3Ryb2tlV2lkdGg6an0pO3JldHVybntpbWFnZTp0aGlzLmNyZWF0ZVRleHR1cmUoVi5pbWFnZSkscmVjdDpWLnJlY3R9fXJldHVybntfaW1nOntmb250OkIsZmlsbENvbG9yOkQsc3Ryb2tlQ29sb3I6SSxzdHJva2VXaWR0aDpqLHRleHQ6d319fWNyZWF0ZVByb2dyYW0oe3ZlcnRleDp3LGZyYWdtZW50OkIsb3B0aW9uczpEfT17fSl7aWYodGhpc1tTXSl7Y29uc3QgST10aGlzW1NdLmNvbXBpbGVTeW5jKEIsdyk7cmV0dXJuIEkuX2F0dHJpYk9wdHM9RCxJfXRocm93IG5ldyBFcnJvcigiQ29udGV4dCAyRCBjYW5ub3QgY3JlYXRlIHdlYmdsIHByb2dyYW0uIil9Y3JlYXRlUGFzc1Byb2dyYW0oe3ZlcnRleDp3PU0sZnJhZ21lbnQ6Qj15LG9wdGlvbnM6RH09e30pe3JldHVybiB0aGlzLmNyZWF0ZVByb2dyYW0oe3ZlcnRleDp3LGZyYWdtZW50OkIsb3B0aW9uczpEfSl9dXNlUHJvZ3JhbSh3LEI9e30pe2lmKHRoaXNbU10pe2NvbnN0IEQ9T2JqZWN0LmFzc2lnbih7fSx3Ll9hdHRyaWJPcHRzLEIpO3JldHVybiB0aGlzW1NdLnVzZVByb2dyYW0odyxEKX10aHJvdyBuZXcgRXJyb3IoIkNvbnRleHQgMkQgY2Fubm90IHVzZSB3ZWJnbCBwcm9ncmFtLiIpfWRlbGV0ZVRleHR1cmUodyl7cmV0dXJuKHRoaXNbU118fHRoaXNbc10pLmRlbGV0ZVRleHR1cmUodyl9Y2xlYXIoLi4udyl7aWYodGhpc1tTXSl7Y29uc3QgQj10aGlzW1NdLmdsO0IuY2xlYXIoQi5DT0xPUl9CVUZGRVJfQklUKX1lbHNlIHRoaXNbc10uY2xlYXIoLi4udyl9ZHJhd01lc2hDbG91ZCh3LHtjbGVhcjpCPSExLHByb2dyYW06RD1udWxsfT17fSl7Y29uc3QgST10aGlzW1NdfHx0aGlzW3NdLGo9RHx8dy5wcm9ncmFtO2lmKHRoaXNbU10pe2NvbnN0IFY9SS5nbDtpZihCJiZWLmNsZWFyKFYuQ09MT1JfQlVGRkVSX0JJVCksailJLnByb2dyYW0hPT1qJiZ0aGlzLnVzZVByb2dyYW0oaix7YV9jb2xvcjp7dHlwZToiVU5TSUdORURfQllURSIsbm9ybWFsaXplOiEwfSxhX2ZpbGxDbG91ZENvbG9yOnt0eXBlOiJVTlNJR05FRF9CWVRFIixub3JtYWxpemU6ITB9LGFfc3Ryb2tlQ2xvdWRDb2xvcjp7dHlwZToiVU5TSUdORURfQllURSIsbm9ybWFsaXplOiEwfSxhX2ZyYW1lSW5kZXg6e3R5cGU6IlVOU0lHTkVEX0JZVEUiLG5vcm1hbGl6ZTohMX19KTtlbHNle2NvbnN0IEo9dy5tZXNoLm1lc2hEYXRhLF89ISFKLnVuaWZvcm1zLnVfdGV4U2FtcGxlcixzdD0hIUoudW5pZm9ybXMudV9maWx0ZXJGbGFnLEc9ISFKLnVuaWZvcm1zLnVfcmFkaWFsR3JhZGllbnRWZWN0b3IsWT13Lmhhc0Nsb3VkQ29sb3IscnQ9dy5oYXNDbG91ZEZpbHRlcixvdD0hIUoudW5pZm9ybXMudV9jbGlwU2FtcGxlcjtPYmplY3QobS5hcHBseUNsb3VkU2hhZGVyKShJLHtoYXNUZXh0dXJlOl8saGFzRmlsdGVyOnN0LGhhc0dyYWRpZW50OkcsaGFzQ2xvdWRDb2xvcjpZLGhhc0Nsb3VkRmlsdGVyOnJ0LGhhc0NsaXBQYXRoOm90fSl9dGhpc1t2XSgpLEkuc2V0TWVzaERhdGEoW3cubWVzaERhdGFdKSx3LmJlZm9yZVJlbmRlciYmdy5iZWZvcmVSZW5kZXIoVix3KSxSKEkpLHcuYWZ0ZXJSZW5kZXImJncuYWZ0ZXJSZW5kZXIoVix3KX1lbHNlIEkuc2V0VHJhbnNmb3JtKHRoaXMuZ2xvYmFsVHJhbnNmb3JtTWF0cml4KSxJLmRyYXdNZXNoQ2xvdWQodyx7Y2xlYXI6Qixob29rOiExfSl9ZHJhd01lc2hlcyh3LHtjbGVhcjpCPSExLHByb2dyYW06RD1udWxsfT17fSl7Y29uc3QgST10aGlzW1NdfHx0aGlzW3NdO2lmKHRoaXNbU10pe2NvbnN0IGo9SS5mYm8sVj1PYmplY3QoaC5kZWZhdWx0KSh0aGlzLHcsRD09bnVsbCksSj1JLmdsO0ImJkouY2xlYXIoSi5DT0xPUl9CVUZGRVJfQklUKTtjb25zdCBfPSFPYmplY3QocC5pc1VuaXRUcmFuc2Zvcm0pKHRoaXMuZ2xvYmFsVHJhbnNmb3JtTWF0cml4KTt0aGlzLl9kcmF3Q2FsbHM9MDtmb3IoY29uc3Qgc3Qgb2YgVil7dGhpcy5fZHJhd0NhbGxzKys7Y29uc3QgRz1EfHxzdC5wcm9ncmFtO2lmKHN0IGluc3RhbmNlb2YgRS5kZWZhdWx0KXRoaXMuZHJhd01lc2hDbG91ZChzdCx7Y2xlYXI6Qixwcm9ncmFtOkd9KTtlbHNle2NvbnN0e3dpZHRoOlksaGVpZ2h0OnJ0fT10aGlzLmNhbnZhcztpZihzdC5iZWZvcmVSZW5kZXImJnN0LmJlZm9yZVJlbmRlcihKLHN0KSxzdC5wYXNzLmxlbmd0aCYmKCghdGhpcy5mYm98fHRoaXMuZmJvLndpZHRoIT09WXx8dGhpcy5mYm8uaGVpZ2h0IT09cnQpJiYodGhpcy5mYm89e3dpZHRoOlksaGVpZ2h0OnJ0LHRhcmdldDpJLmNyZWF0ZUZCTygpLGJ1ZmZlcjpJLmNyZWF0ZUZCTygpLHN3YXAoKXtbdGhpcy50YXJnZXQsdGhpcy5idWZmZXJdPVt0aGlzLmJ1ZmZlcix0aGlzLnRhcmdldF19fSksSS5iaW5kRkJPKHRoaXMuZmJvLnRhcmdldCkpLCFHJiZzdC5maWx0ZXJDYW52YXMpe09iamVjdChtLmFwcGx5U2hhZGVyKShJLHtoYXNUZXh0dXJlOiEwfSk7bGV0IG90PXRoaXMuZmlsdGVyQ29udGV4dDtvdHx8KG90PU8uZGVmYXVsdC5jcmVhdGVDYW52YXMoWSxydCkuZ2V0Q29udGV4dCgiMmQiKSx0aGlzLmZpbHRlckNvbnRleHQ9b3QpO2NvbnN0IGF0PXdbc3QucGFja0luZGV4XSxodD1hdC5maWx0ZXIsaXQ9d1tzdC5wYWNrSW5kZXgrMV0sTXQ9d1tzdC5wYWNrSW5kZXgtMV07KCFNdHx8IU10LmZpbHRlckNhbnZhc3x8TXQuZmlsdGVyIT09aHQpJiYoIWl0fHwhaXQuZmlsdGVyQ2FudmFzfHxpdC5maWx0ZXIhPT1odCk/KF8/KG90LnNhdmUoKSxPYmplY3QodS5kcmF3TWVzaDJEKShhdCxvdCwhMSksb3QucmVzdG9yZSgpLE9iamVjdCh1LmFwcGx5RmlsdGVyKShvdCxodCkpOk9iamVjdCh1LmRyYXdNZXNoMkQpKGF0LG90LCEwKSx0aGlzW3ZdKCksTChJLG90LFkscnQpKTooXyYmb3Quc2F2ZSgpLE9iamVjdCh1LmRyYXdNZXNoMkQpKGF0LG90LCExKSxfJiZvdC5yZXN0b3JlKCksKCFpdHx8IWl0LmZpbHRlckNhbnZhc3x8YXQuZmlsdGVyIT09aXQuZmlsdGVyKSYmKE9iamVjdCh1LmFwcGx5RmlsdGVyKShvdCxodCksdGhpc1t2XSgpLEwoSSxvdCxZLHJ0KSkpfWVsc2V7aWYoRylJLnByb2dyYW0hPT1HJiZ0aGlzLnVzZVByb2dyYW0oRyx7YV9jb2xvcjp7dHlwZToiVU5TSUdORURfQllURSIsbm9ybWFsaXplOiEwfX0pO2Vsc2V7Y29uc3Qgb3Q9ISFzdC51bmlmb3Jtcy51X3RleFNhbXBsZXIsYXQ9ISFzdC51bmlmb3Jtcy51X2ZpbHRlckZsYWcsaHQ9ISFzdC51bmlmb3Jtcy51X3JhZGlhbEdyYWRpZW50VmVjdG9yLGl0PSEhc3QudW5pZm9ybXMudV9jbGlwU2FtcGxlcjtPYmplY3QobS5hcHBseVNoYWRlcikoSSx7aGFzVGV4dHVyZTpvdCxoYXNGaWx0ZXI6YXQsaGFzR3JhZGllbnQ6aHQsaGFzQ2xpcFBhdGg6aXR9KX1zdC5maWx0ZXJDYW52YXMmJmNvbnNvbGUud2FybigiVXNlciBwcm9ncmFtIGlnbm9yZWQgc29tZSBmaWx0ZXIgZWZmZWN0cy4iKSx0aGlzW3ZdKCksSS5zZXRNZXNoRGF0YShbc3RdKSxSKEkpfWlmKHN0LnBhc3MubGVuZ3RoKXtjb25zdCBvdD1zdC5wYXNzLmxlbmd0aDtzdC5wYXNzLmZvckVhY2goKGF0LGh0KT0+e2F0LmJsZW5kPXN0LmVuYWJsZUJsZW5kLGF0LnNldFRleHR1cmUoSS5mYm8udGV4dHVyZSksaHQ9PT1vdC0xP0kuYmluZEZCTyhqKToodGhpcy5mYm8uc3dhcCgpLEkuYmluZEZCTyh0aGlzLmZiby50YXJnZXQpKSxhdC5wcm9ncmFtP0kudXNlUHJvZ3JhbShhdC5wcm9ncmFtKToodGhpcy5kZWZhdWx0UGFzc1Byb2dyYW09dGhpcy5kZWZhdWx0UGFzc1Byb2dyYW18fHRoaXMuY3JlYXRlUGFzc1Byb2dyYW0oKSxJLnVzZVByb2dyYW0odGhpcy5kZWZhdWx0UGFzc1Byb2dyYW0pKSxJLnNldE1lc2hEYXRhKFthdC5tZXNoRGF0YV0pLEouY2xlYXIoSi5DT0xPUl9CVUZGRVJfQklUKSxSKEkpfSl9c3QuYWZ0ZXJSZW5kZXImJnN0LmFmdGVyUmVuZGVyKEosc3QpfX19ZWxzZSBJLnNldFRyYW5zZm9ybSh0aGlzLmdsb2JhbFRyYW5zZm9ybU1hdHJpeCksSS5kcmF3TWVzaGVzKHcse2NsZWFyOkJ9KX1kcmF3SW1hZ2UodywuLi5CKXtjb25zdCBEPUIubGVuZ3RoO2lmKEQ8Mil0aHJvdyBuZXcgVHlwZUVycm9yKGBGYWlsZWQgdG8gZXhlY3V0ZSAnZHJhd0ltYWdlJyBvbiAnUmVuZGVyZXInOiAzIGFyZ3VtZW50cyByZXF1aXJlZCwgYnV0IG9ubHkgJHtCLmxlbmd0aCsxfSBwcmVzZW50LmApO2lmKEQhPT0yJiZEIT09NCYmRCE9PTgpdGhyb3cgbmV3IFR5cGVFcnJvcihgRmFpbGVkIHRvIGV4ZWN1dGUgJ2RyYXdJbWFnZScgb24gJ1JlbmRlcmVyJzogVmFsaWQgYXJpdGllcyBhcmU6IFszLCA1LCA5XSwgYnV0ICR7Qi5sZW5ndGgrMX0gYXJndW1lbnRzIHByb3ZpZGVkLmApO2xldCBJPW51bGwsaj1udWxsO0Q9PT0yP0k9W0JbMF0sQlsxXSx3LndpZHRoLHcuaGVpZ2h0XTpEPT09ND9JPUI6RD09PTgmJihqPUIuc2xpY2UoMCw0KSxJPUIuc2xpY2UoNCkpO2NvbnN0IFY9dGhpcy5jcmVhdGVUZXh0dXJlKHcpLHt3aWR0aDpKLGhlaWdodDpffT10aGlzLmNhbnZhcyxzdD1uZXcgYS5kZWZhdWx0O3N0LnJlY3QoSVswXSxJWzFdLEosXyk7Y29uc3QgRz1uZXcgZC5kZWZhdWx0KHN0LHt3aWR0aDpKLGhlaWdodDpffSk7Ry5zZXRUZXh0dXJlKFYse3JlY3Q6SSxzcmNSZWN0Omp9KSx0aGlzLmRyYXdNZXNoZXMoW0ddKSx0aGlzLmRlbGV0ZVRleHR1cmUoVil9c2V0R2xvYmFsVHJhbnNmb3JtKC4uLncpe3JldHVybiB0aGlzW2xdPVt3WzBdLHdbMV0sMCx3WzJdLHdbM10sMCx3WzRdLHdbNV0sMV0sdGhpc31nbG9iYWxUcmFuc2Zvcm0oLi4udyl7Y29uc3QgQj10aGlzW2xdO3JldHVybiB0aGlzW2xdPWkubWF0My5tdWx0aXBseShBcnJheS5vZigwLDAsMCwwLDAsMCwwLDAsMCksQix3KSx0aGlzfWdsb2JhbFRyYW5zbGF0ZSh3LEIpe2xldCBEPWkubWF0My5jcmVhdGUoKTtyZXR1cm4gRD1pLm1hdDMudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwLDAsMCwwKSxELFt3LEJdKSx0aGlzLmdsb2JhbFRyYW5zZm9ybSguLi5EKX1nbG9iYWxSb3RhdGUodyxbQixEXT1bMCwwXSl7bGV0IEk9aS5tYXQzLmNyZWF0ZSgpO3JldHVybiBJPWkubWF0My50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDAsMCwwLDApLEksW0IsRF0pLEk9aS5tYXQzLnJvdGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCwwLDAsMCksSSx3KSxJPWkubWF0My50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDAsMCwwLDApLEksWy1CLC1EXSksdGhpcy5nbG9iYWxUcmFuc2Zvcm0oLi4uSSl9Z2xvYmFsU2NhbGUodyxCPXcsW0QsSV09WzAsMF0pe2xldCBqPWkubWF0My5jcmVhdGUoKTtyZXR1cm4gaj1pLm1hdDMudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwLDAsMCwwKSxqLFtELEldKSxqPWkubWF0My5zY2FsZShBcnJheS5vZigwLDAsMCwwLDAsMCwwLDAsMCksaixbdyxCXSksaj1pLm1hdDMudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwLDAsMCwwKSxqLFstRCwtSV0pLHRoaXMuZ2xvYmFsVHJhbnNmb3JtKC4uLmopfWdsb2JhbFNrZXcodyxCPXcsW0QsSV09WzAsMF0pe2xldCBqPWkubWF0My5jcmVhdGUoKTtyZXR1cm4gaj1pLm1hdDMudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwLDAsMCwwKSxqLFtELEldKSxqPWkubWF0My5tdWx0aXBseShBcnJheS5vZigwLDAsMCwwLDAsMCwwLDAsMCksaixpLm1hdDMuZnJvbVZhbHVlcygxLE1hdGgudGFuKEIpLE1hdGgudGFuKHcpLDEsMCwwKSksaj1pLm1hdDMudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwLDAsMCwwKSxqLFstRCwtSV0pLHRoaXMuZ2xvYmFsVHJhbnNmb3JtKC4uLmopfXRyYW5zZm9ybVBvaW50KHcsQixEKXtsZXQgST10aGlzLmdsb2JhbFRyYW5zZm9ybU1hdHJpeDtEJiYoST1pLm1hdDMubXVsdGlwbHkoQXJyYXkub2YoMCwwLDAsMCwwLDAsMCwwLDApLEksRCkpO2NvbnN0IGo9dypJWzBdK0IqSVsyXStJWzRdLFY9dypJWzFdK0IqSVszXStJWzVdO3JldHVybltqLFZdfX19LGZ1bmN0aW9uKGcsZSx0KXt0LnIoZSk7dmFyIG49dCgxNSk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpLGUuZGVmYXVsdD1uLmRlZmF1bHR9LGZ1bmN0aW9uKGcsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIG19KTt2YXIgbj10KDE2KSxpPXQoMTcpLGY9dCgxOCksaD10KDE5KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gdShiLE0seSl7cmV0dXJuIE0gaW4gYj9PYmplY3QuZGVmaW5lUHJvcGVydHkoYixNLHt2YWx1ZTp5LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6YltNXT15LGJ9Y29uc3QgYT17fTtmdW5jdGlvbiBkKGIsTT0zKXtjb25zdCB5PVtdLFM9Yi5sZW5ndGg7Zm9yKGxldCBzPTA7czxTO3MrKylzJU08MiYmeS5wdXNoKC41KihiW3NdKzEpKTtyZXR1cm4geX1mdW5jdGlvbiBFKGIsTSl7Y29uc3QgeT1NLl9idWZmZXJzO09iamVjdC52YWx1ZXMoeSkuZm9yRWFjaChTPT57Yi5kZWxldGVCdWZmZXIoUyl9KSxNLl9idWZmZXJzPXt9fWZ1bmN0aW9uIHAoYixNLHkpe3JldHVybiBiLmFjdGl2ZVRleHR1cmUoYi5URVhUVVJFMCt5KSxBcnJheS5pc0FycmF5KE0uX2ltZyk/Yi5iaW5kVGV4dHVyZShiLlRFWFRVUkVfQ1VCRV9NQVAsTSk6Yi5iaW5kVGV4dHVyZShiLlRFWFRVUkVfMkQsTSksTX1jb25zdCBPPXtpbnQ6IjFpIixpdmVjMjoiMmkiLGl2ZWMzOiIzaSIsaXZlYzQ6IjRpIixmbG9hdDoiMWYiLHZlYzI6IjJmIix2ZWMzOiIzZiIsdmVjNDoiNGYiLG1hdDI6Ik1hdHJpeDJmdiIsbWF0MzoiTWF0cml4M2Z2IixtYXQ0OiJNYXRyaXg0ZnYiLHNhbXBsZXIxRDoic2FtcGxlcjFEIixzYW1wbGVyMkQ6InNhbXBsZXIyRCIsc2FtcGxlcjNEOiJzYW1wbGVyM0QiLHNhbXBsZXJDdWJlOiJzYW1wbGVyQ3ViZSIsc2FtcGxlcjFEU2hhZG93OiJzYW1wbGVyMURTaGFkb3ciLHNhbXBsZXIyRFNoYWRvdzoic2FtcGxlcjJEU2hhZG93IixzYW1wbGVyMkRSZWN0OiJzYW1wbGVyMkRSZWN0IixzYW1wbGVyMkRSZWN0U2hhZG93OiJzYW1wbGVyMkRSZWN0U2hhZG93In07Y2xhc3MgbXtzdGF0aWMgYWRkTGlicyhNPXt9KXtPYmplY3QuYXNzaWduKGEsTSl9c3RhdGljIEZMT0FUKE0seSl7cmV0dXJuIE9iamVjdChuLnBvaW50c1RvQnVmZmVyKShNLEZsb2F0MzJBcnJheSx5KX1zdGF0aWMgVU5TSUdORURfQllURShNLHkpe3JldHVybiBPYmplY3Qobi5wb2ludHNUb0J1ZmZlcikoTSxVaW50OEFycmF5LHkpfXN0YXRpYyBVTlNJR05FRF9TSE9SVChNLHkpe3JldHVybiBPYmplY3Qobi5wb2ludHNUb0J1ZmZlcikoTSxVaW50MTZBcnJheSx5KX1zdGF0aWMgQllURShNLHkpe3JldHVybiBPYmplY3Qobi5wb2ludHNUb0J1ZmZlcikoTSxJbnQ4QXJyYXkseSl9c3RhdGljIFNIT1JUKE0seSl7cmV0dXJuIE9iamVjdChuLnBvaW50c1RvQnVmZmVyKShNLEludDE2QXJyYXkseSl9Y29uc3RydWN0b3IoTSx5PXt9KXt0aGlzLm9wdGlvbnM9T2JqZWN0LmFzc2lnbih7fSxtLmRlZmF1bHRPcHRpb25zLHkpLHRoaXMuY2FudmFzPU07bGV0IFM7dGhpcy5vcHRpb25zLndlYmdsMiYmKFM9TS5nZXRDb250ZXh0KCJ3ZWJnbDIiLHRoaXMub3B0aW9ucykpLFM9PW51bGwmJihTPU9iamVjdChuLnNldHVwV2ViR0wpKE0sdGhpcy5vcHRpb25zKSx0aGlzLmFpYV9leHQ9Uy5nZXRFeHRlbnNpb24oIkFOR0xFX2luc3RhbmNlZF9hcnJheXMiKSksdGhpcy5nbD1TLFMudmlld3BvcnQoMCwwLE0ud2lkdGgsTS5oZWlnaHQpLFMuY2xlYXJDb2xvcigwLDAsMCwwKSxTLmJsZW5kRnVuY1NlcGFyYXRlKFMuU1JDX0FMUEhBLFMuT05FX01JTlVTX1NSQ19BTFBIQSxTLk9ORSxTLk9ORV9NSU5VU19TUkNfQUxQSEEpLHRoaXMucHJvZ3JhbXM9W10sdGhpcy5fZXZlbnRzPXt9fWdldCBwcm9ncmFtKCl7Y29uc3QgTT10aGlzLmdsO3JldHVybiBNLmdldFBhcmFtZXRlcihNLkNVUlJFTlRfUFJPR1JBTSl9X2RlY2xhcmVVbmlmb3JtKE0seSxTPSIxZiIpe2NvbnN0IHM9dGhpcy5nbCxjPXMuZ2V0VW5pZm9ybUxvY2F0aW9uKE0seSk7bGV0IGw7Y29uc3Qgdj10aGlzO2lmKC9ec2FtcGxlci8udGVzdChTKSl7Y29uc3QgVD1NLl9zYW1wbGVyTWFwLFI9TS5fYmluZFRleHR1cmVzO09iamVjdC5kZWZpbmVQcm9wZXJ0eShNLnVuaWZvcm1zLHkse2dldCgpe3JldHVybiBsfSxzZXQoTCl7bD1MO2NvbnN0IE49VFt5XSE9bnVsbD9UW3ldOlIubGVuZ3RoO1JbTl09TCxwKHMsTCxOKSxUW3ldfHwoVFt5XT1OLHMudW5pZm9ybTFpKGMsTikpLHYub3B0aW9ucy5hdXRvVXBkYXRlJiZ2LnVwZGF0ZSgpfSxjb25maWd1cmFibGU6ITEsZW51bWVyYWJsZTohMH0pfWVsc2V7Y29uc3QgVD1TLmluZGV4T2YoIk1hdHJpeCIpPT09MCxSPSFUJiYvdiQvLnRlc3QoUyksTD1zW2B1bmlmb3JtJHtTfWBdLmJpbmQocyk7T2JqZWN0LmRlZmluZVByb3BlcnR5KE0udW5pZm9ybXMseSx7Z2V0KCl7cmV0dXJuIGx9LHNldChOKXtsPU4sdHlwZW9mIE49PSJudW1iZXIiJiYoTj1bTl0pLFQ/TChjLCExLE4pOlI/TChjLE4pOkwoYywuLi5OKSx2Lm9wdGlvbnMuYXV0b1VwZGF0ZSYmdi51cGRhdGUoKX0sY29uZmlndXJhYmxlOiExLGVudW1lcmFibGU6ITB9KX19X2RyYXcoKXtjb25zdCBNPXRoaXMucHJvZ3JhbTtNLm1lc2hEYXRhLmZvckVhY2goKHksUyk9Pntjb25zdHtwb3NpdGlvbnM6cyxjZWxsczpjLGluc3RhbmNlQ291bnQ6bCxjZWxsc0NvdW50OnYsYXR0cmlidXRlczpULHVuaWZvcm1zOlIsdGV4dHVyZUNvb3JkOkwsZW5hYmxlQmxlbmQ6Tn09eSxBPXRoaXMuZ2w7bGV0IHc9eS5tb2RlIT1udWxsP3kubW9kZTpBLlRSSUFOR0xFUzt0eXBlb2Ygdz09InN0cmluZyImJih3PUFbd10pLE4/QS5lbmFibGUoQS5CTEVORCk6QS5kaXNhYmxlKEEuQkxFTkQpLEEuYmluZEJ1ZmZlcihBLkFSUkFZX0JVRkZFUixNLl9idWZmZXJzLnZlcnRpY2VzQnVmZmVyKSxBLmJ1ZmZlckRhdGEoQS5BUlJBWV9CVUZGRVIscyxBLlNUQVRJQ19EUkFXKSxjJiYoQS5iaW5kQnVmZmVyKEEuRUxFTUVOVF9BUlJBWV9CVUZGRVIsTS5fYnVmZmVycy5jZWxsc0J1ZmZlciksQS5idWZmZXJEYXRhKEEuRUxFTUVOVF9BUlJBWV9CVUZGRVIsYyxBLlNUQVRJQ19EUkFXKSk7Y29uc3QgQj1bXTtUJiZPYmplY3QudmFsdWVzKFQpLmZvckVhY2goKHtuYW1lOkksZGF0YTpqLGRpdmlzb3I6Vn0pPT57aWYoQS5iaW5kQnVmZmVyKEEuQVJSQVlfQlVGRkVSLE0uX2J1ZmZlcnNbSV0pLEEuYnVmZmVyRGF0YShBLkFSUkFZX0JVRkZFUixqLEEuU1RBVElDX0RSQVcpLFYhPW51bGwpe2NvbnN0IEo9QS5nZXRBdHRyaWJMb2NhdGlvbihNLEkpO0o+PTAmJihBLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KEopLEIucHVzaChKKSxBLnZlcnRleEF0dHJpYkRpdmlzb3I/QS52ZXJ0ZXhBdHRyaWJEaXZpc29yKEosVik6dGhpcy5haWFfZXh0JiZ0aGlzLmFpYV9leHQudmVydGV4QXR0cmliRGl2aXNvckFOR0xFKEosVikpfX0pLFImJk9iamVjdC5lbnRyaWVzKFIpLmZvckVhY2goKFtJLGpdKT0+e3RoaXMudW5pZm9ybXNbSV09an0pO2xldCBEO2lmKCFjKXtjb25zdCBJPU0uX2RpbWVuc2lvbjtEPXMubGVuZ3RoL0l9aWYoTS5fZW5hYmxlVGV4dHVyZXMmJk0uX2J1ZmZlcnMudGV4Q29vcmRCdWZmZXIpe2NvbnN0IEk9THx8ZChzLE0uX2RpbWVuc2lvbik7QS5iaW5kQnVmZmVyKEEuQVJSQVlfQlVGRkVSLE0uX2J1ZmZlcnMudGV4Q29vcmRCdWZmZXIpLEEuYnVmZmVyRGF0YShBLkFSUkFZX0JVRkZFUixtLkZMT0FUKEkpLEEuU1RBVElDX0RSQVcpfWwhPW51bGw/KGM/QS5kcmF3RWxlbWVudHNJbnN0YW5jZWQ/QS5kcmF3RWxlbWVudHNJbnN0YW5jZWQodyx2LEEuVU5TSUdORURfU0hPUlQsMCxsKTp0aGlzLmFpYV9leHQmJnRoaXMuYWlhX2V4dC5kcmF3RWxlbWVudHNJbnN0YW5jZWRBTkdMRSh3LHYsQS5VTlNJR05FRF9TSE9SVCwwLGwpOkEuZHJhd0FycmF5c0luc3RhbmNlZD9BLmRyYXdBcnJheXNJbnN0YW5jZWQodywwLEQsbCk6dGhpcy5haWFfZXh0LmRyYXdBcnJheXNJbnN0YW5jZWRBTkdMRSh3LDAsRCxsKSxCLmZvckVhY2goST0+e0EudmVydGV4QXR0cmliRGl2aXNvcj9BLnZlcnRleEF0dHJpYkRpdmlzb3IoSSxudWxsKTp0aGlzLmFpYV9leHQmJnRoaXMuYWlhX2V4dC52ZXJ0ZXhBdHRyaWJEaXZpc29yQU5HTEUoSSxudWxsKX0pKTpjP0EuZHJhd0VsZW1lbnRzKHcsdixBLlVOU0lHTkVEX1NIT1JULDApOkEuZHJhd0FycmF5cyh3LDAsRCl9KX1nZXQgaXNXZWJHTDIoKXtyZXR1cm4gdHlwZW9mIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQ8InUiJiZ0aGlzLmdsIGluc3RhbmNlb2YgV2ViR0wyUmVuZGVyaW5nQ29udGV4dH1nZXQgZW5hYmxlVGV4dHVyZXMoKXtyZXR1cm4gdGhpcy5wcm9ncmFtJiZ0aGlzLnByb2dyYW0uX2VuYWJsZVRleHR1cmVzfWdldCB1bmlmb3Jtcygpe2NvbnN0IE09dGhpcy5wcm9ncmFtO2lmKCFNfHwhTS51bmlmb3Jtcyl0aHJvdyBFcnJvcigiTm8gYXZhbGlhYmxlIHByb2dyYW0uIik7cmV0dXJuIE0udW5pZm9ybXN9ZGVsZXRlUHJvZ3JhbShNKXtjb25zdCB5PXRoaXMuZ2w7dGhpcy5wcm9ncmFtPT09TSYmKHRoaXMuc3RhcnRSZW5kZXI9ITEsdGhpcy5fcmVuZGVyRnJhbWVJRCYmKGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuX3JlbmRlckZyYW1lSUQpLGRlbGV0ZSB0aGlzLl9yZW5kZXJGcmFtZUlEKSx5LnVzZVByb2dyYW0obnVsbCkpO2NvbnN0IFM9dGhpcy5wcm9ncmFtcy5pbmRleE9mKE0pO1M+PTAmJnRoaXMucHJvZ3JhbXMuc3BsaWNlKFMsMSksRSh5LE0pLHkuZGVsZXRlUHJvZ3JhbShNKX1zZXRNZXNoRGF0YShNKXtBcnJheS5pc0FycmF5KE0pfHwoTT1bTV0pO2NvbnN0IHk9dGhpcy5wcm9ncmFtO3kubWVzaERhdGE9TS5tYXAoKHttb2RlOlMscG9zaXRpb25zOnMsaW5zdGFuY2VDb3VudDpjLGNlbGxzOmwsY2VsbHNDb3VudDp2LGF0dHJpYnV0ZXM6VCx1bmlmb3JtczpSLHRleHR1cmVDb29yZDpMLGVuYWJsZUJsZW5kOk59KT0+e2NvbnN0IEE9e3Bvc2l0aW9uczptLkZMT0FUKHMpLHVuaWZvcm1zOlIsZW5hYmxlQmxlbmQ6ISFOLHRleHR1cmVDb29yZDptLkZMT0FUKEwpfTtpZihsJiYoQS5jZWxscz1tLlVTSE9SVChsKSxBLmNlbGxzQ291bnQ9dnx8QS5jZWxscy5sZW5ndGgpLFMhPW51bGwmJihBLm1vZGU9UyksYyE9bnVsbCl7aWYoIXRoaXMuaXNXZWJHTDImJiF0aGlzLmFpYV9leHQpdGhyb3cgbmV3IEVycm9yKCJDYW5ub3QgdXNlIGluc3RhbmNlQ291bnQgaW4gdGhpcyByZW5kZXJpbmcgY29udGV4dCwgdXNlIHdlYmdsMiBjb250ZXh0IGluc3RlYWQuIik7QS5pbnN0YW5jZUNvdW50PWN9aWYoVCl7Y29uc3Qgdz17fTtPYmplY3QuZW50cmllcyhUKS5mb3JFYWNoKChbQixEXSk9PntpZigheS5fYXR0cmlidXRlW0JdKXkuX2F0dHJpYnV0ZVtCXT0iaWdub3JlZCI7ZWxzZSBpZih5Ll9hdHRyaWJ1dGVbQl0hPT0iaWdub3JlZCIpe2NvbnN0e25hbWU6SSx0eXBlOmp9PXkuX2F0dHJpYnV0ZVtCXTtsZXQgVj1ELmRhdGF8fEQ7aWYoQXJyYXkuaXNBcnJheShWKSYmKFY9bVtqXShWKSksd1tCXT17bmFtZTpJLGRhdGE6Vn0sRC5kaXZpc29yIT1udWxsKXtpZighdGhpcy5pc1dlYkdMMiYmIXRoaXMuYWlhX2V4dCl0aHJvdyBuZXcgRXJyb3IoIkNhbm5vdCB1c2UgZGl2aXNvciBpbiB0aGlzIHJlbmRlcmluZyBjb250ZXh0LCB1c2Ugd2ViZ2wyIGNvbnRleHQgaW5zdGVhZC4iKTt3W0JdLmRpdmlzb3I9RC5kaXZpc29yfX19KSxBLmF0dHJpYnV0ZXM9d31yZXR1cm4gQX0pLHRoaXMub3B0aW9ucy5hdXRvVXBkYXRlJiZ0aGlzLnVwZGF0ZSgpfWNyZWF0ZVByb2dyYW0oTSx5KXtjb25zdCBTPS9eXHMqdW5pZm9ybVxzK3NhbXBsZXIvbWcudGVzdChNKTtNPT1udWxsJiYoTT1mLmRlZmF1bHQpLHk9PW51bGwmJih5PVM/aC5kZWZhdWx0OmkuZGVmYXVsdCk7Y29uc3Qgcz10aGlzLmdsLGM9T2JqZWN0KG4uY3JlYXRlUHJvZ3JhbSkocyx5LE0pO2Muc2hhZGVyVGV4dD17dmVydGV4U2hhZGVyOnksZnJhZ21lbnRTaGFkZXI6TX0sYy5fYnVmZmVycz17fSxjLl9hdHRyaWJ1dGU9e30sYy51bmlmb3Jtcz17fSxjLl9zYW1wbGVyTWFwPXt9LGMuX2JpbmRUZXh0dXJlcz1bXTtjb25zdCBsPW5ldyBSZWdFeHAoYCg/OmF0dHJpYnV0ZXxpbikgdmVjKFxcZCkgJHt0aGlzLm9wdGlvbnMudmVydGV4UG9zaXRpb259YCwiaW0iKTtsZXQgdj15Lm1hdGNoKGwpO3YmJihjLl9kaW1lbnNpb249TnVtYmVyKHZbMV0pKTtjb25zdCBUPW5ldyBSZWdFeHAoYCg/OmF0dHJpYnV0ZXxpbikgdmVjKFxcZCkgJHt0aGlzLm9wdGlvbnMudmVydGV4VGV4dHVyZUNvb3JkfWAsImltIik7dj15Lm1hdGNoKFQpLHYmJihjLl90ZXhDb29yZFNpemU9TnVtYmVyKHZbMV0pKTtjb25zdCBSPS9eXHMqKD86YXR0cmlidXRlfGluKSAoXHcrPykoXGQqKSAoXHcrKS9naW07aWYodj15Lm1hdGNoKFIpLHYpZm9yKGxldCBBPTA7QTx2Lmxlbmd0aDtBKyspe2NvbnN0IHc9L15ccyooPzphdHRyaWJ1dGV8aW4pIChcdys/KShcZCopIChcdyspL2ltLEI9dltBXS5tYXRjaCh3KTtpZihCJiZCWzNdIT09dGhpcy5vcHRpb25zLnZlcnRleFBvc2l0aW9uJiZCWzNdIT09dGhpcy5vcHRpb25zLnZlcnRleFRleHR1cmVDb29yZCl7bGV0WyxELEksal09QjtEPT09Im1hdCImJihJKio9MiksYy5fYnVmZmVyc1tqXT1zLmNyZWF0ZUJ1ZmZlcigpLGMuX2F0dHJpYnV0ZVtqXT17bmFtZTpqLHR5cGU6RCxzaXplOk51bWJlcihJKXx8MX19fWNvbnN0IEw9L15ccyp1bmlmb3JtXHMrKFx3KylccysoXHcrKShcW1xkK1xdKT8vbWc7dj15Lm1hdGNoKEwpfHxbXSx2PXYuY29uY2F0KE0ubWF0Y2goTCl8fFtdKSx2LmZvckVhY2goQT0+e2NvbnN0IHc9QS5tYXRjaCgvXlxzKnVuaWZvcm1ccysoXHcrKVxzKyhcdyspKFxbXGQrXF0pPy8pO2xldFtCLEQsSV09dy5zbGljZSgxKTtCPU9bQl0sST0hIUksQi5pbmRleE9mKCJNYXRyaXgiKSE9PTAmJkkmJihCKz0idiIpLHRoaXMuX2RlY2xhcmVVbmlmb3JtKGMsRCxCKX0pLGMuX2J1ZmZlcnMudmVydGljZXNCdWZmZXI9cy5jcmVhdGVCdWZmZXIoKSxjLl9idWZmZXJzLmNlbGxzQnVmZmVyPXMuY3JlYXRlQnVmZmVyKCk7Y29uc3QgTj1zLmdldEF0dHJpYkxvY2F0aW9uKGMsdGhpcy5vcHRpb25zLnZlcnRleFRleHR1cmVDb29yZCk7cmV0dXJuIGMuX2VuYWJsZVRleHR1cmVzPU4+PTAsYy5fZW5hYmxlVGV4dHVyZXMmJihjLl9idWZmZXJzLnRleENvb3JkQnVmZmVyPXMuY3JlYXRlQnVmZmVyKCkpLHRoaXMucHJvZ3JhbXMucHVzaChjKSxjfXVzZVByb2dyYW0oTSx5PXt9KXt0aGlzLnN0YXJ0UmVuZGVyPSExLHRoaXMuX3JlbmRlckZyYW1lSUQmJihjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLl9yZW5kZXJGcmFtZUlEKSxkZWxldGUgdGhpcy5fcmVuZGVyRnJhbWVJRCk7Y29uc3QgUz10aGlzLmdsO1MudXNlUHJvZ3JhbShNKTtjb25zdCBzPU0uX2RpbWVuc2lvbjtTLmJpbmRCdWZmZXIoUy5BUlJBWV9CVUZGRVIsTS5fYnVmZmVycy52ZXJ0aWNlc0J1ZmZlcik7Y29uc3QgYz1TLmdldEF0dHJpYkxvY2F0aW9uKE0sdGhpcy5vcHRpb25zLnZlcnRleFBvc2l0aW9uKTtpZihTLnZlcnRleEF0dHJpYlBvaW50ZXIoYyxzLFMuRkxPQVQsITEsMCwwKSxTLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGMpLE0uX2VuYWJsZVRleHR1cmVzKXtTLmJpbmRCdWZmZXIoUy5BUlJBWV9CVUZGRVIsTS5fYnVmZmVycy50ZXhDb29yZEJ1ZmZlcik7Y29uc3QgbD1TLmdldEF0dHJpYkxvY2F0aW9uKE0sdGhpcy5vcHRpb25zLnZlcnRleFRleHR1cmVDb29yZCk7Uy52ZXJ0ZXhBdHRyaWJQb2ludGVyKGwsTS5fdGV4Q29vcmRTaXplfHwyLFMuRkxPQVQsITEsMCwwKSxTLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGwpfWlmKE9iamVjdC5lbnRyaWVzKE0uX2F0dHJpYnV0ZSkuZm9yRWFjaCgoW2wsdl0pPT57aWYodiE9PSJpZ25vcmVkIil7Y29uc3QgVD12LnNpemUsUj15W2xdfHx7fSxMPSEhUi5ub3JtYWxpemU7bGV0IE49Ui50eXBlfHwiRkxPQVQiO2NvbnN0IEE9Ui5rZXl8fGw7Tj09PSJVQllURSImJihOPSJVTlNJR05FRF9CWVRFIiksTj09PSJVU0hPUlQiJiYoTj0iVU5TSUdORURfU0hPUlQiKSx2LnR5cGU9TixBJiZBIT09bCYmKE0uX2F0dHJpYnV0ZVtBXT12KSxTLmJpbmRCdWZmZXIoUy5BUlJBWV9CVUZGRVIsTS5fYnVmZmVyc1tsXSk7Y29uc3Qgdz1TLmdldEF0dHJpYkxvY2F0aW9uKE0sbCk7dz49MCYmKFMudmVydGV4QXR0cmliUG9pbnRlcih3LFQsU1tOXSxMLDAsMCksUy5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSh3KSl9fSksIU0ubWVzaERhdGEpe2NvbnN0IGw9W1stMSwtMSwwLDFdLnNsaWNlKDAscyksWzEsLTEsMCwxXS5zbGljZSgwLHMpLFsxLDEsMCwxXS5zbGljZSgwLHMpLFstMSwxLDAsMV0uc2xpY2UoMCxzKV0sdj1bWzAsMSwzXSxbMywxLDJdXTt0aGlzLnNldE1lc2hEYXRhKHtwb3NpdGlvbnM6bCxjZWxsczp2fSl9cmV0dXJuIE19Y29tcGlsZVN5bmMoTSx5KXtNPU18fGYuZGVmYXVsdDtjb25zdCBTPXt9O2Z1bmN0aW9uIHMoVCl7VD1ULnJlcGxhY2UoL15ccyovbWcsIiIpO2NvbnN0IFI9W10sTD1ULm1hdGNoKC9eI3ByYWdtYVxzK2luY2x1ZGVccysuKi9tZyk7aWYoTCl7Zm9yKGxldCBOPTA7TjxMLmxlbmd0aDtOKyspe2NvbnN0IHc9TFtOXS5tYXRjaCgvKD86PHwiKSguKikoPzo+fCIpLyk7aWYodyl7Y29uc3QgQj13WzBdLmluZGV4T2YoIjwiKT09PTA/ImxpYiI6ImxpbmsiO2xldCBEPXdbMV07aWYoRD09PSJncmFwaCImJihEPSJncmFwaGljcyIpLFNbRF0pUi5wdXNoKGAvKiBpbmNsdWRlZCAke0R9ICovYCk7ZWxzZSBpZihTW0RdPSEwLEI9PT0ibGliIil7Y29uc3QgST1zKGFbRF0pO1IucHVzaChJKX1lbHNlIGlmKEI9PT0ibGluayIpdGhyb3cgbmV3IEVycm9yKCJDYW5ub3QgbG9hZCBleHRlcm5hbCBsaW5rcyBzeW5jaHJvbm91c2x5LiBVc2UgY29tcGlsZSBpbnN0ZWFkIG9mIGNvbXBpbGVTeW5jLiIpfX1SLmZvckVhY2goTj0+e1Q9VC5yZXBsYWNlKC9eI3ByYWdtYVxzK2luY2x1ZGVccysuKi9tLE4pfSl9cmV0dXJuIFR9Y29uc3QgYz1zKE0pLGw9eT9zKHkpOm51bGw7cmV0dXJuIHRoaXMuY3JlYXRlUHJvZ3JhbShjLGwpfWFzeW5jIGNvbXBpbGUoTSx5KXtNPU18fGYuZGVmYXVsdDtjb25zdCBTPXt9O2FzeW5jIGZ1bmN0aW9uIHMoVCl7VD1ULnJlcGxhY2UoL15ccyovbWcsIiIpO2NvbnN0IFI9W10sTD1ULm1hdGNoKC9eI3ByYWdtYVxzK2luY2x1ZGVccysuKi9tZyk7aWYoTCl7Zm9yKGxldCBOPTA7TjxMLmxlbmd0aDtOKyspe2NvbnN0IHc9TFtOXS5tYXRjaCgvKD86PHwiKSguKikoPzo+fCIpLyk7aWYodyl7Y29uc3QgQj13WzBdLmluZGV4T2YoIjwiKT09PTA/ImxpYiI6ImxpbmsiO2xldCBEPXdbMV07aWYoRD09PSJncmFwaCImJihEPSJncmFwaGljcyIpLFNbRF0pUi5wdXNoKGAvKiBpbmNsdWRlZCAke0R9ICovYCk7ZWxzZSBpZihTW0RdPSEwLEI9PT0ibGliIil7Y29uc3QgST1hd2FpdCBzKGFbRF0pO1IucHVzaChJKX1lbHNlIGlmKEI9PT0ibGluayIpe2xldCBJPWF3YWl0IG0uZmV0Y2hTaGFkZXIoRCk7ST1hd2FpdCBzKEkpLFIucHVzaChJKX19fVIuZm9yRWFjaChOPT57VD1ULnJlcGxhY2UoL14jcHJhZ21hXHMraW5jbHVkZVxzKy4qL20sTil9KX1yZXR1cm4gVH1jb25zdCBjPWF3YWl0IHMoTSksbD15P2F3YWl0IHMoeSk6bnVsbDtyZXR1cm4gdGhpcy5jcmVhdGVQcm9ncmFtKGMsbCl9YXN5bmMgbG9hZChNLHk9bnVsbCl7cmV0dXJuIE09YXdhaXQgbS5mZXRjaFNoYWRlcihNKSx5JiYoeT1hd2FpdCBtLmZldGNoU2hhZGVyKHkpKSx0aGlzLmNvbXBpbGUoTSx5KX1jcmVhdGVUZXh0dXJlKE09bnVsbCx7d3JhcFM6eT10aGlzLmdsLkNMQU1QX1RPX0VER0Usd3JhcFQ6Uz10aGlzLmdsLkNMQU1QX1RPX0VER0UsbWluRmlsdGVyOnM9dGhpcy5nbC5MSU5FQVIsbWFnRmlsdGVyOmM9dGhpcy5nbC5MSU5FQVJ9PXt9KXtjb25zdCBsPXRoaXMuZ2wsdj1BcnJheS5pc0FycmF5KE0pP2wuVEVYVFVSRV9DVUJFX01BUDpsLlRFWFRVUkVfMkQ7dGhpcy5fbWF4X3RleHR1cmVfaW1hZ2VfdW5pdHM9dGhpcy5fbWF4X3RleHR1cmVfaW1hZ2VfdW5pdHN8fGwuZ2V0UGFyYW1ldGVyKGwuTUFYX0NPTUJJTkVEX1RFWFRVUkVfSU1BR0VfVU5JVFMpLGwuYWN0aXZlVGV4dHVyZShsLlRFWFRVUkUwK3RoaXMuX21heF90ZXh0dXJlX2ltYWdlX3VuaXRzLTEpO2NvbnN0IFQ9bC5jcmVhdGVUZXh0dXJlKCk7bC5iaW5kVGV4dHVyZSh2LFQpLGwucGl4ZWxTdG9yZWkobC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCEwKTtjb25zdHt3aWR0aDpSLGhlaWdodDpMfT10aGlzLmNhbnZhcztpZihNKWlmKHY9PT1sLlRFWFRVUkVfQ1VCRV9NQVApZm9yKGxldCBOPTA7Tjw2O04rKylsLnRleEltYWdlMkQobC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1grTiwwLGwuUkdCQSxsLlJHQkEsbC5VTlNJR05FRF9CWVRFLE1bTl0pO2Vsc2UgbC50ZXhJbWFnZTJEKHYsMCxsLlJHQkEsbC5SR0JBLGwuVU5TSUdORURfQllURSxNKTtlbHNlIGlmKHY9PT1sLlRFWFRVUkVfQ1VCRV9NQVApZm9yKGxldCBOPTA7Tjw2O04rKyl0aGlzLmdsLnRleEltYWdlMkQodGhpcy5nbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1grTiwwLGwuUkdCQSxSLEwsMCxsLlJHQkEsbC5VTlNJR05FRF9CWVRFLG51bGwpO2Vsc2UgbC50ZXhJbWFnZTJEKHYsMCxsLlJHQkEsUixMLDAsbC5SR0JBLGwuVU5TSUdORURfQllURSxudWxsKTtyZXR1cm4gbC50ZXhQYXJhbWV0ZXJpKHYsbC5URVhUVVJFX01JTl9GSUxURVIscyksbC50ZXhQYXJhbWV0ZXJpKHYsbC5URVhUVVJFX01BR19GSUxURVIsYyksbC50ZXhQYXJhbWV0ZXJpKHYsbC5URVhUVVJFX1dSQVBfUyx5KSxsLnRleFBhcmFtZXRlcmkodixsLlRFWFRVUkVfV1JBUF9ULFMpLHY9PT1sLlRFWFRVUkVfQ1VCRV9NQVAmJihNLndpZHRoPU1bMF0ud2lkdGgsTS5oZWlnaHQ9TVswXS5oZWlnaHQpLGwuYmluZFRleHR1cmUodixudWxsKSxULl9pbWc9TXx8e3dpZHRoOlIsaGVpZ2h0Okx9LFQuZGVsZXRlPSgpPT57dGhpcy5kZWxldGVUZXh0dXJlKFQpfSxUfWRlbGV0ZVRleHR1cmUoTSl7Y29uc3QgeT1NLl9pbWc7dGhpcy5nbC5kZWxldGVUZXh0dXJlKE0pLHR5cGVvZiB5LmNsb3NlPT0iZnVuY3Rpb24iJiZ5LmNsb3NlKCl9YXN5bmMgbG9hZFRleHR1cmUoTSx7dXNlSW1hZ2VCaXRtYXA6eT0hMH09e30pe2NvbnN0IFM9YXdhaXQgbS5sb2FkSW1hZ2UoTSx7dXNlSW1hZ2VCaXRtYXA6eX0pO3JldHVybiB0aGlzLmNyZWF0ZVRleHR1cmUoUyl9Y3JlYXRlRkJPKHtjb2xvcjpNPTEsYmxlbmQ6eT0hMSxkZXB0aDpTPXRoaXMub3B0aW9ucy5kZXB0aCE9PSExLHN0ZW5jaWw6cz0hIXRoaXMub3B0aW9ucy5zdGVuY2lsfT17fSl7Y29uc3QgYz10aGlzLmdsLGw9Yy5jcmVhdGVGcmFtZWJ1ZmZlcigpO2MuYmluZEZyYW1lYnVmZmVyKGMuRlJBTUVCVUZGRVIsbCk7Y29uc3Qgdj1bXTtmb3IobGV0IEw9MDtMPE07TCsrKXtjb25zdCBOPXRoaXMuY3JlYXRlVGV4dHVyZSgpO2MuZnJhbWVidWZmZXJUZXh0dXJlMkQoYy5GUkFNRUJVRkZFUixjLkNPTE9SX0FUVEFDSE1FTlQwK0wsYy5URVhUVVJFXzJELE4sMCksdi5wdXNoKE4pfWwudGV4dHVyZXM9dixsLnRleHR1cmU9dlswXSxsLmJsZW5kPXk7Y29uc3R7d2lkdGg6VCxoZWlnaHQ6Un09dGhpcy5jYW52YXM7cmV0dXJuIFMmJiFzJiYobC5kZXB0aEJ1ZmZlcj1jLmNyZWF0ZVJlbmRlcmJ1ZmZlcigpLGMuYmluZFJlbmRlcmJ1ZmZlcihjLlJFTkRFUkJVRkZFUixsLmRlcHRoQnVmZmVyKSxjLnJlbmRlcmJ1ZmZlclN0b3JhZ2UoYy5SRU5ERVJCVUZGRVIsYy5ERVBUSF9DT01QT05FTlQxNixULFIpLGMuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoYy5GUkFNRUJVRkZFUixjLkRFUFRIX0FUVEFDSE1FTlQsYy5SRU5ERVJCVUZGRVIsbC5kZXB0aEJ1ZmZlcikpLHMmJiFTJiYobC5zdGVuY2lsQnVmZmVyPWMuY3JlYXRlUmVuZGVyYnVmZmVyKCksYy5iaW5kUmVuZGVyYnVmZmVyKGMuUkVOREVSQlVGRkVSLGwuc3RlbmNpbEJ1ZmZlciksYy5yZW5kZXJidWZmZXJTdG9yYWdlKGMuUkVOREVSQlVGRkVSLGMuU1RFTkNJTF9JTkRFWDgsVCxSKSxjLmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKGMuRlJBTUVCVUZGRVIsYy5TVEVOQ0lMX0FUVEFDSE1FTlQsYy5SRU5ERVJCVUZGRVIsbC5zdGVuY2lsQnVmZmVyKSksUyYmcyYmKGwuZGVwdGhTdGVuY2lsQnVmZmVyPWMuY3JlYXRlUmVuZGVyYnVmZmVyKCksYy5iaW5kUmVuZGVyYnVmZmVyKGMuUkVOREVSQlVGRkVSLGwuZGVwdGhTdGVuY2lsQnVmZmVyKSxjLnJlbmRlcmJ1ZmZlclN0b3JhZ2UoYy5SRU5ERVJCVUZGRVIsYy5ERVBUSF9TVEVOQ0lMLFQsUiksYy5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlcihjLkZSQU1FQlVGRkVSLGMuREVQVEhfU1RFTkNJTF9BVFRBQ0hNRU5ULGMuUkVOREVSQlVGRkVSLGwuZGVwdGhTdGVuY2lsQnVmZmVyKSksYy5iaW5kRnJhbWVidWZmZXIoYy5GUkFNRUJVRkZFUixudWxsKSxsfWJpbmRGQk8oTT1udWxsKXt0aGlzLmZibz1NfXJlbmRlcih7Y2xlYXJCdWZmZXI6TT0hMH09e30pe3RoaXMuc3RhcnRSZW5kZXI9ITA7Y29uc3QgeT10aGlzLmdsO2xldCBTPXRoaXMucHJvZ3JhbTtTfHwoUz10aGlzLmNyZWF0ZVByb2dyYW0oKSx0aGlzLnVzZVByb2dyYW0oUykpLHRoaXMuZmJvJiZ5LmJpbmRGcmFtZWJ1ZmZlcih5LkZSQU1FQlVGRkVSLHRoaXMuZmJvKTtjb25zdCBzPXRoaXMub3B0aW9ucy5kZXB0aDtzJiZ5LmVuYWJsZSh5LkRFUFRIX1RFU1QpLHRoaXMuZ2wuY2xlYXIodGhpcy5nbC5DT0xPUl9CVUZGRVJfQklUfChzP3RoaXMuZ2wuREVQVEhfQlVGRkVSX0JJVDowKXwodGhpcy5vcHRpb25zLnN0ZW5jaWw/dGhpcy5nbC5TVEVOQ0lMX0JVRkZFUl9CSVQ6MCkpO2NvbnN0IGM9dGhpcy5fcmVuZGVyRnJhbWVJRDt0aGlzLl9kcmF3KCksdGhpcy5mYm8mJnkuYmluZEZyYW1lYnVmZmVyKHkuRlJBTUVCVUZGRVIsbnVsbCksdGhpcy5fcmVuZGVyRnJhbWVJRD09PWMmJih0aGlzLl9yZW5kZXJGcmFtZUlEPW51bGwpfXVwZGF0ZSgpe3RoaXMuc3RhcnRSZW5kZXImJnRoaXMuX3JlbmRlckZyYW1lSUQ9PW51bGwmJih0aGlzLl9yZW5kZXJGcmFtZUlEPXJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLnJlbmRlci5iaW5kKHRoaXMpKSl9fXUobSwiZGVmYXVsdE9wdGlvbnMiLHtwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6ITAsYXV0b1VwZGF0ZTohMCx2ZXJ0ZXhQb3NpdGlvbjoiYV92ZXJ0ZXhQb3NpdGlvbiIsdmVydGV4VGV4dHVyZUNvb3JkOiJhX3ZlcnRleFRleHR1cmVDb29yZCIsd2ViZ2wyOiExfSksdShtLCJVQllURSIsbS5VTlNJR05FRF9CWVRFKSx1KG0sIlVTSE9SVCIsbS5VTlNJR05FRF9TSE9SVCksdShtLCJmZXRjaFNoYWRlciIsbi5mZXRjaFNoYWRlciksdShtLCJsb2FkSW1hZ2UiLG4ubG9hZEltYWdlKX0sZnVuY3Rpb24oZyxlLHQpe3QucihlKSx0LmQoZSwic2V0dXBXZWJHTCIsZnVuY3Rpb24oKXtyZXR1cm4gaX0pLHQuZChlLCJjcmVhdGVQcm9ncmFtIixmdW5jdGlvbigpe3JldHVybiBmfSksdC5kKGUsInBvaW50c1RvQnVmZmVyIixmdW5jdGlvbigpe3JldHVybiBofSksdC5kKGUsImxvYWRJbWFnZSIsZnVuY3Rpb24oKXtyZXR1cm4gYX0pLHQuZChlLCJmZXRjaFNoYWRlciIsZnVuY3Rpb24oKXtyZXR1cm4gRX0pLHQoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBuKHAsTyl7Y29uc3QgbT1bIndlYmdsIiwiZXhwZXJpbWVudGFsLXdlYmdsIiwid2Via2l0LTNkIiwibW96LXdlYmdsIl07bGV0IGI9bnVsbDtmb3IobGV0IE09MDtNPG0ubGVuZ3RoOysrTSl7dHJ5e2I9cC5nZXRDb250ZXh0KG1bTV0sTyl9Y2F0Y2h7fWlmKGIpYnJlYWt9cmV0dXJuIGJ9ZnVuY3Rpb24gaShwLE8pe2NvbnN0IG09bihwLE8pO2lmKCFtKXRocm93IG5ldyBFcnJvcigiU29ycnksIHlvdXIgYnJvd3NlciBkb2Vzbid0IHN1cHBvcnQgV2ViR0wuIik7cmV0dXJuIG19ZnVuY3Rpb24gZihwLE8sbSl7Y29uc3QgYj1wLmNyZWF0ZVNoYWRlcihwLlZFUlRFWF9TSEFERVIpO2lmKHAuc2hhZGVyU291cmNlKGIsTykscC5jb21waWxlU2hhZGVyKGIpLCFwLmdldFNoYWRlclBhcmFtZXRlcihiLHAuQ09NUElMRV9TVEFUVVMpKXtjb25zdCBTPWBWZXJ0ZXggc2hhZGVyIGZhaWxlZCB0byBjb21waWxlLiAgVGhlIGVycm9yIGxvZyBpczoke3AuZ2V0U2hhZGVySW5mb0xvZyhiKX1gO3Rocm93IG5ldyBFcnJvcihTKX1jb25zdCBNPXAuY3JlYXRlU2hhZGVyKHAuRlJBR01FTlRfU0hBREVSKTtpZihwLnNoYWRlclNvdXJjZShNLG0pLHAuY29tcGlsZVNoYWRlcihNKSwhcC5nZXRTaGFkZXJQYXJhbWV0ZXIoTSxwLkNPTVBJTEVfU1RBVFVTKSl7Y29uc3QgUz1gRnJhZ21lbnQgc2hhZGVyIGZhaWxlZCB0byBjb21waWxlLiAgVGhlIGVycm9yIGxvZyBpczoke3AuZ2V0U2hhZGVySW5mb0xvZyhNKX1gO3Rocm93IG5ldyBFcnJvcihTKX1jb25zdCB5PXAuY3JlYXRlUHJvZ3JhbSgpO2lmKHAuYXR0YWNoU2hhZGVyKHksYikscC5hdHRhY2hTaGFkZXIoeSxNKSxwLmxpbmtQcm9ncmFtKHkpLCFwLmdldFByb2dyYW1QYXJhbWV0ZXIoeSxwLkxJTktfU1RBVFVTKSl7Y29uc3QgUz1gU2hhZGVyIHByb2dyYW0gZmFpbGVkIHRvIGxpbmsuICBUaGUgZXJyb3IgbG9nIGlzOiR7cC5nZXRQcm9ncmFtSW5mb0xvZyh5KX1gO3Rocm93IG5ldyBFcnJvcihTKX1yZXR1cm4gcC5kZWxldGVTaGFkZXIoYikscC5kZWxldGVTaGFkZXIoTSkseX1mdW5jdGlvbiBoKHAsTz1GbG9hdDMyQXJyYXksbT1udWxsKXtpZihtJiYhKG0gaW5zdGFuY2VvZiBPKSl0aHJvdyBuZXcgVHlwZUVycm9yKCJXcm9uZyBidWZmZXIgdHlwZS4iKTtpZihwPT1udWxsfHxwIGluc3RhbmNlb2YgTylyZXR1cm4gcDtpZihwWzBdPT1udWxsfHxwWzBdLmxlbmd0aD09bnVsbClyZXR1cm4gbT8obS5zZXQocCwwKSxtKTpuZXcgTyhwKTtjb25zdCBiPXBbMF0ubGVuZ3RoLE09cC5sZW5ndGg7bXx8KG09bmV3IE8oYipNKSk7bGV0IHk9MDtmb3IobGV0IFM9MDtTPE07UysrKWZvcihsZXQgcz0wO3M8YjtzKyspbVt5KytdPXBbU11bc107cmV0dXJuIG19Y29uc3QgdT17fTtmdW5jdGlvbiBhKHAse3VzZUltYWdlQml0bWFwOk89ITAsYWxpYXM6bT1udWxsfT17fSl7aWYoIXVbcF0pe2lmKHR5cGVvZiBJbWFnZT09ImZ1bmN0aW9uIil7Y29uc3QgYj1uZXcgSW1hZ2U7dHlwZW9mIHA9PSJzdHJpbmciJiYhKHR5cGVvZiBsb2NhdGlvbj09Im9iamVjdCImJi9eZmlsZTovLnRlc3QobG9jYXRpb24uaHJlZikpJiYhL15kYXRhOi8udGVzdChwKSYmKGIuY3Jvc3NPcmlnaW49ImFub255bW91cyIpLHVbcF09bmV3IFByb21pc2UoTT0+e2Iub25sb2FkPWZ1bmN0aW9uKCl7TyYmdHlwZW9mIGNyZWF0ZUltYWdlQml0bWFwPT0iZnVuY3Rpb24iP2NyZWF0ZUltYWdlQml0bWFwKGIse2ltYWdlT3JpZW50YXRpb246ImZsaXBZIn0pLnRoZW4oeT0+e3VbcF09eSxtJiYodVttXT15KSxNKHkpfSk6KHVbcF09YixtJiYodVttXT1iKSxNKGIpKX0sYi5zcmM9cH0pLG0mJih1W21dPXVbcF0pfWVsc2UgaWYodHlwZW9mIGZldGNoPT0iZnVuY3Rpb24iKXJldHVybiBmZXRjaChwLHttZXRob2Q6IkdFVCIsbW9kZToiY29ycyIsY2FjaGU6ImRlZmF1bHQifSkudGhlbihiPT5iLmJsb2IoKSkudGhlbihiPT5jcmVhdGVJbWFnZUJpdG1hcChiLHtpbWFnZU9yaWVudGF0aW9uOiJmbGlwWSJ9KS50aGVuKE09Pih1W3BdPU0sbSYmKHVbbV09TSksTSkpKX1yZXR1cm4gdVtwXX1jb25zdCBkPXt9O2FzeW5jIGZ1bmN0aW9uIEUocCl7aWYoZFtwXSlyZXR1cm4gZFtwXTtjb25zdCBPPWF3YWl0IGZldGNoKHApO2lmKE8uc3RhdHVzPj0yMDAmJk8uc3RhdHVzPDMwMCl7Y29uc3QgbT1hd2FpdCBPLnRleHQoKTtyZXR1cm4gZFtwXT1tLG19dGhyb3cgbmV3IEVycm9yKCJTaGFkZXIgbG9hZGVkIGVycm9yLiIpfX0sZnVuY3Rpb24oZyxlLHQpe3QucihlKSxlLmRlZmF1bHQ9YGF0dHJpYnV0ZSB2ZWMzIGFfdmVydGV4UG9zaXRpb247Cgp2b2lkIG1haW4oKSB7CiAgZ2xfUG9pbnRTaXplID0gMS4wOwogIGdsX1Bvc2l0aW9uID0gdmVjNChhX3ZlcnRleFBvc2l0aW9uLCAxKTsKfWB9LGZ1bmN0aW9uKGcsZSx0KXt0LnIoZSksZS5kZWZhdWx0PWAjaWZkZWYgR0xfRVMKcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7CiNlbmRpZgoKdm9pZCBtYWluKCkgewogIGdsX0ZyYWdDb2xvciA9IHZlYzQoMC4wLCAwLjAsIDAuMCwgMC4xKTsKfWB9LGZ1bmN0aW9uKGcsZSx0KXt0LnIoZSksZS5kZWZhdWx0PWBhdHRyaWJ1dGUgdmVjNCBhX3ZlcnRleFBvc2l0aW9uOwphdHRyaWJ1dGUgdmVjMiBhX3ZlcnRleFRleHR1cmVDb29yZDsKdmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7Cgp2b2lkIG1haW4oKSB7CiAgZ2xfUG9pbnRTaXplID0gMS4wOwogIGdsX1Bvc2l0aW9uID0gYV92ZXJ0ZXhQb3NpdGlvbjsKICB2VGV4dHVyZUNvb3JkID0gYV92ZXJ0ZXhUZXh0dXJlQ29vcmQ7Cn1gfSxmdW5jdGlvbihnLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBofSk7dmFyIG49dCgyMSksaT10KDI1KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3QgZj1TeW1ib2woInRyYW5zZm9ybSIpO2NsYXNzIGh7Y29uc3RydWN0b3IoYSxkKXt0aGlzLmNvbnRleHQ9YS5nZXRDb250ZXh0KCIyZCIpLHRoaXMub3B0aW9ucz1kLHRoaXNbZl09WzEsMCwwLDEsMCwwXX1jcmVhdGVUZXh0dXJlKGEpe3JldHVybntfaW1nOmF9fWFzeW5jIGxvYWRUZXh0dXJlKGEpe2NvbnN0IGQ9YXdhaXQgbi5kZWZhdWx0LmxvYWRJbWFnZShhLHt1c2VJbWFnZUJpdG1hcDohMX0pO3JldHVybiB0aGlzLmNyZWF0ZVRleHR1cmUoZCl9ZGVsZXRlVGV4dHVyZShhKXtyZXR1cm4gYX1jbGVhcihhLGQsRSxwKXtjb25zdCBPPXRoaXMuY29udGV4dDthPWF8fDAsZD1kfHwwLEU9RXx8Ty5jYW52YXMud2lkdGgtYSxwPXB8fE8uY2FudmFzLmhlaWdodC1kLE8uY2xlYXJSZWN0KGEsZCxFLHApfWRyYXdNZXNoQ2xvdWQoYSx7Y2xlYXI6ZD0hMX09e30pe2NvbnN0IEU9W107Zm9yKGxldCBwPTA7cDxhLmFtb3VudDtwKyspe2NvbnN0IE89YS5nZXRUcmFuc2Zvcm0ocCk7bGV0IG09YS5nZXRUZXh0dXJlRnJhbWUocCk7bSYmKG09bS5faW1nKTtjb25zdCBiPWEuZ2V0RmlsdGVyKHApLHtmaWxsOk0sc3Ryb2tlOnl9PWEuZ2V0Q2xvdWRSR0JBKHApO0UucHVzaCh7bWVzaDphLm1lc2gsX2Nsb3VkT3B0aW9uczpbTSx5LG0sTyxiXX0pfWEuYmVmb3JlUmVuZGVyJiZhLmJlZm9yZVJlbmRlcih0aGlzLmNvbnRleHQsYSksdGhpcy5kcmF3TWVzaGVzKEUse2NsZWFyOmQsaG9vazohMX0pLGEuYWZ0ZXJSZW5kZXImJmEuYWZ0ZXJSZW5kZXIodGhpcy5jb250ZXh0LGEpfWRyYXdNZXNoZXMoYSx7Y2xlYXI6ZD0hMSxob29rOkU9ITB9PXt9KXtjb25zdCBwPXRoaXMuY29udGV4dDtkJiZwLmNsZWFyUmVjdCgwLDAscC5jYW52YXMud2lkdGgscC5jYW52YXMuaGVpZ2h0KTtsZXQgTz1udWxsO2NvbnN0e3dpZHRoOm0saGVpZ2h0OmJ9PXAuY2FudmFzLE09YS5sZW5ndGg7YS5mb3JFYWNoKCh5LFMpPT57bGV0IHMsYyxsLHYsVDtFJiZ5LmJlZm9yZVJlbmRlciYmeS5iZWZvcmVSZW5kZXIocCx5KSx5Ll9jbG91ZE9wdGlvbnMmJihbcyxjLGwsdixUXT15Ll9jbG91ZE9wdGlvbnMseT15Lm1lc2gpO2xldCBSPXkuZmlsdGVyO2lmKFQmJihSPVI/YCR7Un0gJHtUfWA6VCksUiYmIXRoaXMuZmlsdGVyQnVmZmVyJiZ0aGlzLmZpbHRlckJ1ZmZlciE9PSExKXtjb25zdCBMPW4uZGVmYXVsdC5jcmVhdGVDYW52YXMobSxiKTtMP3RoaXMuZmlsdGVyQnVmZmVyPUwuZ2V0Q29udGV4dCgiMmQiKTp0aGlzLmZpbHRlckJ1ZmZlcj0hMX1PJiZPIT09UiYmKE9iamVjdChpLmFwcGx5RmlsdGVyKSh0aGlzLmZpbHRlckJ1ZmZlcixPKSxwLmRyYXdJbWFnZSh0aGlzLmZpbHRlckJ1ZmZlci5jYW52YXMsMCwwLG0sYiksdGhpcy5maWx0ZXJCdWZmZXIuY2xlYXJSZWN0KDAsMCxtLGIpLE89bnVsbCksUiYmdGhpcy5maWx0ZXJCdWZmZXI/KHRoaXMuZmlsdGVyQnVmZmVyLnNhdmUoKSx0aGlzLmZpbHRlckJ1ZmZlci50cmFuc2Zvcm0oLi4udGhpc1tmXSksT2JqZWN0KGkuZHJhd01lc2gyRCkoeSx0aGlzLmZpbHRlckJ1ZmZlciwhMSxzLGMsbCx2KSx0aGlzLmZpbHRlckJ1ZmZlci5yZXN0b3JlKCksUz09PU0tMT8oT2JqZWN0KGkuYXBwbHlGaWx0ZXIpKHRoaXMuZmlsdGVyQnVmZmVyLFIpLHAuZHJhd0ltYWdlKHRoaXMuZmlsdGVyQnVmZmVyLmNhbnZhcywwLDAsbSxiKSx0aGlzLmZpbHRlckJ1ZmZlci5jbGVhclJlY3QoMCwwLG0sYikpOk89Uik6KHAuc2F2ZSgpLHAudHJhbnNmb3JtKC4uLnRoaXNbZl0pLE9iamVjdChpLmRyYXdNZXNoMkQpKHkscCwhMSxzLGMsbCx2KSxwLnJlc3RvcmUoKSksRSYmeS5hZnRlclJlbmRlciYmeS5hZnRlclJlbmRlcihwLHkpfSl9c2V0VHJhbnNmb3JtKGEpe3RoaXNbZl09YX19fSxmdW5jdGlvbihnLGUsdCl7dC5yKGUpLChmdW5jdGlvbihuKXt2YXIgaT10KDE0KSxmPXQoMjMpLGg9dCgyNCk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IHU9e307ZnVuY3Rpb24gYShtLGIpe2NvbnN0e3N0eWxlOk0sdmFyaWFudDp5LHdlaWdodDpTLHN0cmV0Y2g6cyxzaXplOmMscHhMaW5lSGVpZ2h0OmwsZmFtaWx5OnZ9PW07cmV0dXJuIHM9PT0ibm9ybWFsIj9gJHtNfSAke3l9ICR7U30gJHtjKmJ9cHgvJHtsKmJ9cHggJHt2fWA6YCR7TX0gJHt5fSAke1N9ICR7c30gJHtjKmJ9cHgvJHtsKmJ9cHggJHt2fWB9ZnVuY3Rpb24gZChtLHtmb250OmIsZmlsbENvbG9yOk0sc3Ryb2tlQ29sb3I6eSxzdHJva2VXaWR0aDpTLHJhdGlvOnM9MSx0ZXh0Q2FudmFzOmMsY2FjaGFibGU6bD0hMX0pe2xldCB2O2lmKGwpe3Y9W20sYixTdHJpbmcoTSksU3RyaW5nKHkpLFN0cmluZyhTKV0uam9pbigiIyMjIik7Y29uc3QgVj11W3ZdO2lmKFYpcmV0dXJuIFZ9Y3x8KGM9cCgxLDEpKTtjb25zdCBUPWMuZ2V0Q29udGV4dCgiMmQiKTtULnNhdmUoKSxULmZvbnQ9YjtsZXR7d2lkdGg6Un09VC5tZWFzdXJlVGV4dChtKTtULnJlc3RvcmUoKTtjb25zdCBMPU9iamVjdChmLmRlZmF1bHQpKGIpLE49TWF0aC5tYXgoTC5weExpbmVIZWlnaHQsTC5weEhlaWdodCoxLjEzKTsvaXRhbGljfG9ibGlxdWUvLnRlc3QoYikmJihSKz1OKk1hdGgudGFuKDE1Kk1hdGguUEkvMTgwKSksIU0mJiF5JiYoTT0iIzAwMCIpO2NvbnN0IEE9VC5jYW52YXMsdz1NYXRoLmNlaWwoUiksQj1NYXRoLmNlaWwoTik7QS53aWR0aD1NYXRoLnJvdW5kKHcqcyksQS5oZWlnaHQ9TWF0aC5yb3VuZChCKnMpLFQuc2F2ZSgpLFQuZm9udD1hKEwscyksVC50ZXh0QWxpZ249ImNlbnRlciIsVC50ZXh0QmFzZWxpbmU9Im1pZGRsZSI7Y29uc3QgRD1BLmhlaWdodCouNStMLnB4SGVpZ2h0Ki4wNSpzLEk9QS53aWR0aCouNTtpZihNKXtpZihBcnJheS5pc0FycmF5KE0pKU09T2JqZWN0KGguZGVmYXVsdCkoTSk7ZWxzZSBpZihNLnZlY3Rvcil7bGV0IFY7Y29uc3R7dmVjdG9yOkosY29sb3JzOl99PU07Si5sZW5ndGg9PT02P1Y9VC5jcmVhdGVSYWRpYWxHcmFkaWVudCguLi5KKTpWPVQuY3JlYXRlTGluZWFyR3JhZGllbnQoLi4uSiksXy5mb3JFYWNoKCh7b2Zmc2V0OnN0LGNvbG9yOkd9KT0+e1YuYWRkQ29sb3JTdG9wKHN0LEcpfSksTT1WfVQuZmlsbFN0eWxlPU0sVC5maWxsVGV4dChtLEksRCl9aWYoeSl7aWYoVC5saW5lV2lkdGg9UypzLEFycmF5LmlzQXJyYXkoeSkpeT1PYmplY3QoaC5kZWZhdWx0KSh5KTtlbHNlIGlmKHkudmVjdG9yKXtsZXQgVjtjb25zdHt2ZWN0b3I6Sixjb2xvcnM6X309eTtKLmxlbmd0aD09PTY/Vj1ULmNyZWF0ZVJhZGlhbEdyYWRpZW50KC4uLkopOlY9VC5jcmVhdGVMaW5lYXJHcmFkaWVudCguLi5KKSxfLmZvckVhY2goKHtvZmZzZXQ6c3QsY29sb3I6R30pPT57Vi5hZGRDb2xvclN0b3Aoc3QsRyl9KSx5PVZ9VC5zdHJva2VTdHlsZT15LFQuc3Ryb2tlVGV4dChtLEksRCl9VC5yZXN0b3JlKCk7Y29uc3Qgaj17aW1hZ2U6YyxyZWN0OlswLDAsdyxCXX07cmV0dXJuIGwmJih1W3ZdPWopLGp9bGV0IEU9ITE7aWYodHlwZW9mIG5hdmlnYXRvcj09Im9iamVjdCImJnR5cGVvZiBuYXZpZ2F0b3IudXNlckFnZW50PT0ic3RyaW5nIil7Y29uc3QgbT1uYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2Nocm9tZVwvKFxkKykvKTttJiYoRT1OdW1iZXIobVsxXSk8NzApfWZ1bmN0aW9uIHAobSxiLE09e30pe2NvbnN0IHk9TS5vZmZzY3JlZW58fCFFJiZNLm9mZnNjcmVlbiE9PSExO2xldCBTO3JldHVybiB0eXBlb2YgbjwidSImJnR5cGVvZiBuLmNyZWF0ZUNhbnZhcz09ImZ1bmN0aW9uIj9TPW4uY3JlYXRlQ2FudmFzKG0sYixNKTp5JiZ0eXBlb2YgT2Zmc2NyZWVuQ2FudmFzPT0iZnVuY3Rpb24iP1M9bmV3IE9mZnNjcmVlbkNhbnZhcyhtLGIpOihTPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImNhbnZhcyIpLFMud2lkdGg9bSxTLmhlaWdodD1iKSxTfWNvbnN0IE89e2NyZWF0ZUNhbnZhczpwLGNyZWF0ZVRleHQ6ZCxsb2FkSW1hZ2U6aS5kZWZhdWx0LmxvYWRJbWFnZX07ZS5kZWZhdWx0PU99KS5jYWxsKHRoaXMsdCgyMikpfSxmdW5jdGlvbihnLGUpe3ZhciB0O3Q9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc30oKTt0cnl7dD10fHxuZXcgRnVuY3Rpb24oInJldHVybiB0aGlzIikoKX1jYXRjaHt0eXBlb2Ygd2luZG93PT0ib2JqZWN0IiYmKHQ9d2luZG93KX1nLmV4cG9ydHM9dH0sZnVuY3Rpb24oZyxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gTX0pLHQoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBuKHksUyl7aWYodHlwZW9mIHk9PSJzdHJpbmciKXtjb25zdCBsPXkudHJpbSgpLm1hdGNoKC9eKFtcZC5dKykocHh8cHR8cGN8aW58Y218bW18ZW18ZXh8cmVtfHF8dnd8dmh8dm1heHx2bWlufCUpJC8pO2w/eT17c2l6ZTpwYXJzZUZsb2F0KGxbMV0pLHVuaXQ6bFsyXX06eT17c2l6ZTpwYXJzZUludCh5LDEwKSx1bml0OiJweCJ9fWxldHtzaXplOnMsdW5pdDpjfT15O2lmKGM9PT0icHQiKXMvPS43NTtlbHNlIGlmKGM9PT0icGMiKXMqPTE2O2Vsc2UgaWYoYz09PSJpbiIpcyo9OTY7ZWxzZSBpZihjPT09ImNtIilzKj05Ni8yLjU0O2Vsc2UgaWYoYz09PSJtbSIpcyo9OTYvMjUuNDtlbHNlIGlmKGM9PT0iZW0ifHxjPT09InJlbSJ8fGM9PT0iZXgiKXtpZighUyYmdHlwZW9mIGdldENvbXB1dGVkU3R5bGU9PSJmdW5jdGlvbiImJnR5cGVvZiBkb2N1bWVudDwidSIpe2NvbnN0IGw9Z2V0Q29tcHV0ZWRTdHlsZShkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpLmZvbnRTaXplO1M9bihsLDE2KX1zKj1TLGM9PT0iZXgiJiYocy89Mil9ZWxzZSBpZihjPT09InEiKXMqPTk2LzI1LjQvNDtlbHNlIGlmKGM9PT0idncifHxjPT09InZoIil7aWYodHlwZW9mIGRvY3VtZW50PCJ1Iil7Y29uc3QgbD1jPT09InZ3Ij9kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGg6ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodDtzKj1sLzEwMH19ZWxzZSBpZigoYz09PSJ2bWF4Inx8Yz09PSJ2bWluIikmJnR5cGVvZiBkb2N1bWVudDwidSIpe2NvbnN0IGw9ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoLHY9ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodDtjPT09InZtYXgiP3MqPU1hdGgubWF4KGwsdikvMTAwOnMqPU1hdGgubWluKGwsdikvMTAwfXJldHVybiBzfWNvbnN0IGk9ImJvbGR8Ym9sZGVyfGxpZ2h0ZXJ8WzEtOV0wMCIsZj0iaXRhbGljfG9ibGlxdWUiLGg9InNtYWxsLWNhcHMiLHU9InVsdHJhLWNvbmRlbnNlZHxleHRyYS1jb25kZW5zZWR8Y29uZGVuc2VkfHNlbWktY29uZGVuc2VkfHNlbWktZXhwYW5kZWR8ZXhwYW5kZWR8ZXh0cmEtZXhwYW5kZWR8dWx0cmEtZXhwYW5kZWQiLGE9InB4fHB0fHBjfGlufGNtfG1tfGVtfGV4fHJlbXxxfHZ3fHZofHZtYXh8dm1pbnwlIixkPWAnKFteJ10rKSd8IihbXiJdKykifChbXFx3LV18W+S4gC3pvqVdKStgLEU9bmV3IFJlZ0V4cChgKCR7aX0pICtgLCJpIikscD1uZXcgUmVnRXhwKGAoJHtmfSkgK2AsImkiKSxPPW5ldyBSZWdFeHAoYCgke2h9KSArYCwiaSIpLG09bmV3IFJlZ0V4cChgKCR7dX0pICtgLCJpIiksYj1uZXcgUmVnRXhwKCIoW1xcZFxcLl0rKSgiK2ErIikoPzpcXC8oW1xcZFxcLl0rKSgiK2ErIikpPyAqKCg/OiIrZCsiKSggKiwgKig/OiIrZCsiKSkqKSIpO2Z1bmN0aW9uIE0oeSxTKXtjb25zdCBzPWIuZXhlYyh5KTtpZighcylyZXR1cm47Y29uc3QgYz1wYXJzZUZsb2F0KHNbM10pLGw9e3dlaWdodDoibm9ybWFsIixzdHlsZToibm9ybWFsIixzdHJldGNoOiJub3JtYWwiLHZhcmlhbnQ6Im5vcm1hbCIsc2l6ZTpwYXJzZUZsb2F0KHNbMV0pLHVuaXQ6c1syXSxsaW5lSGVpZ2h0Ok51bWJlci5pc0Zpbml0ZShjKT9jOnZvaWQgMCxsaW5lSGVpZ2h0VW5pdDpzWzRdLGZhbWlseTpzWzVdLnJlcGxhY2UoLyAqLCAqL2csIiwiKX0sdj15LnN1YnN0cmluZygwLHMuaW5kZXgpLFQ9RS5leGVjKHYpLFI9cC5leGVjKHYpLEw9Ty5leGVjKHYpLE49bS5leGVjKHYpO3JldHVybiBUJiYobC53ZWlnaHQ9VFsxXSksUiYmKGwuc3R5bGU9UlsxXSksTCYmKGwudmFyaWFudD1MWzFdKSxOJiYobC5zdHJldGNoPU5bMV0pLGwucHhIZWlnaHQ9bih7c2l6ZTpsLnNpemUsdW5pdDpsLnVuaXR9LFMpLGwucHhMaW5lSGVpZ2h0PW4oe3NpemU6bC5saW5lSGVpZ2h0fHxsLnNpemUsdW5pdDpsLmxpbmVIZWlnaHRVbml0fHxsLnVuaXR9LFMpLGx9fSxmdW5jdGlvbihnLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBufSksdCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIG4oaSl7cmV0dXJuYHJnYmEoJHtpLm1hcCgoZixoKT0+aDwzP01hdGgucm91bmQoZioyNTUpOmYpLmpvaW4oKX0pYH19LGZ1bmN0aW9uKGcsZSx0KXt0LnIoZSksdC5kKGUsImFwcGx5RmlsdGVyIixmdW5jdGlvbigpe3JldHVybiB1fSksdC5kKGUsImRyYXdNZXNoMkQiLGZ1bmN0aW9uKCl7cmV0dXJuIGR9KTt2YXIgbj10KDEpLGk9dCgyNCksZj10KDIzKSxoPXQoMjYpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiB1KEUscCl7Y29uc3QgTz1FLmNhbnZhcztFLnNhdmUoKSxFLmZpbHRlcj1wLEUuZHJhd0ltYWdlKE8sMCwwLE8ud2lkdGgsTy5oZWlnaHQpLEUucmVzdG9yZSgpfWZ1bmN0aW9uIGEoRSxwKXtjb25zdCBPPS9yZ2JhXCgoXGQrKSwoXGQrKSwoXGQrKSwoXGQrKVwpLztFPUUubWF0Y2goTykuc2xpY2UoMSw1KS5tYXAoTnVtYmVyKSxwPXAubWF0Y2goTykuc2xpY2UoMSw1KS5tYXAoTnVtYmVyKTtjb25zdCBtPVtdLGI9cFszXTtmb3IobGV0IE09MDtNPDQ7TSsrKW1bTV09T2JqZWN0KGgubWl4KShFW01dLHBbTV0sYik7cmV0dXJuYHJnYmEoJHttLmpvaW4oKX0pYH1mdW5jdGlvbiBkKEUscCxPPSEwLG09bnVsbCxiPW51bGwsTT1udWxsLHk9bnVsbCl7cC5zYXZlKCk7bGV0IFM9ITEscz0hMTtpZihwLmdsb2JhbEFscGhhPUUuZ2V0T3BhY2l0eSgpLEUuX3VwZGF0ZU1hdHJpeCYmRS50cmFuc2Zvcm1TY2FsZS9FLmNvbnRvdXJzLnNjYWxlPjEuNSYmRS5hY2N1cmF0ZShFLnRyYW5zZm9ybVNjYWxlKSxFLmxpbmVXaWR0aCl7bGV0IHY9RS5ncmFkaWVudCYmRS5ncmFkaWVudC5zdHJva2U7aWYodil7Y29uc3R7dmVjdG9yOlQsY29sb3JzOlJ9PXY7aWYoVC5sZW5ndGg9PT02KXY9cC5jcmVhdGVSYWRpYWxHcmFkaWVudCguLi5UKTtlbHNlIGlmKFQubGVuZ3RoPT09NCl2PXAuY3JlYXRlTGluZWFyR3JhZGllbnQoLi4uVCk7ZWxzZSBpZihULmxlbmd0aD09PTMpdj1wLmNyZWF0ZUNpcmN1bGFyR3JhZGllbnQoLi4uVCk7ZWxzZSB0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIHZlY3RvciBkaW1lbnNpb24uIik7Ui5mb3JFYWNoKCh7b2Zmc2V0OkwsY29sb3I6Tn0pPT57bGV0IEE9T2JqZWN0KGkuZGVmYXVsdCkoTik7YiYmKEE9YShBLGIpKSx2LmFkZENvbG9yU3RvcChMLEEpfSkscC5zdHJva2VTdHlsZT12LFM9ITB9ZWxzZSBFLnN0cm9rZVN0eWxlJiYoYj9wLnN0cm9rZVN0eWxlPWEoRS5zdHJva2VTdHlsZSxiKTpwLnN0cm9rZVN0eWxlPUUuc3Ryb2tlU3R5bGUsUz0hMCl9UyYmKHAubGluZVdpZHRoPUUubGluZVdpZHRoLHAubGluZUpvaW49RS5saW5lSm9pbixwLmxpbmVDYXA9RS5saW5lQ2FwLHAubWl0ZXJMaW1pdD1FLm1pdGVyTGltaXQsRS5saW5lRGFzaCYmKHAuc2V0TGluZURhc2goRS5saW5lRGFzaCksRS5saW5lRGFzaE9mZnNldCYmKHAubGluZURhc2hPZmZzZXQ9RS5saW5lRGFzaE9mZnNldCkpKTtsZXQgYz1FLmdyYWRpZW50JiZFLmdyYWRpZW50LmZpbGw7aWYoYyl7Y29uc3R7dmVjdG9yOnYsY29sb3JzOlR9PWM7aWYodi5sZW5ndGg9PT02KWM9cC5jcmVhdGVSYWRpYWxHcmFkaWVudCguLi52KTtlbHNlIGlmKHYubGVuZ3RoPT09NCljPXAuY3JlYXRlTGluZWFyR3JhZGllbnQoLi4udik7ZWxzZSBpZih2Lmxlbmd0aD09PTMpYz1wLmNyZWF0ZUNpcmN1bGFyR3JhZGllbnQoLi4udik7ZWxzZSB0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIHZlY3RvciBkaW1lbnNpb24uIik7VC5mb3JFYWNoKCh7b2Zmc2V0OlIsY29sb3I6TH0pPT57bGV0IE49T2JqZWN0KGkuZGVmYXVsdCkoTCk7YiYmKE49YShOLGIpKSxjLmFkZENvbG9yU3RvcChSLE4pfSkscC5maWxsU3R5bGU9YyxzPSEwfWVsc2UgRS5maWxsU3R5bGUmJihtP3AuZmlsbFN0eWxlPWEoRS5maWxsU3R5bGUsbSk6cC5maWxsU3R5bGU9RS5maWxsU3R5bGUscz0hMCk7aWYoeSYmcC50cmFuc2Zvcm0oLi4ueSkscC50cmFuc2Zvcm0oLi4uRS50cmFuc2Zvcm1NYXRyaXgpLEUuY2xpcFBhdGgpe2NvbnN0IHY9RS5jbGlwUGF0aCxUPW5ldyBQYXRoMkQodik7cC5jbGlwKFQpfWNvbnN0IGw9RS5jb250b3Vycy5sZW5ndGg7aWYoRS5jb250b3Vycy5mb3JFYWNoKCh2LFQpPT57Y29uc3QgUj12Lmxlbmd0aCxMPVI+MSYmbi52ZWMyLmVxdWFscyh2WzBdLHZbUi0xXSksTj1UPT09bC0xJiZFLnRleHR1cmU7aWYodiYmUj4wKXtpZihzfHxTfHxOKXtwLmJlZ2luUGF0aCgpLHAubW92ZVRvKC4uLnZbMF0pO2ZvcihsZXQgQT0xO0E8UjtBKyspQT09PVItMSYmTD9wLmNsb3NlUGF0aCgpOnAubGluZVRvKC4uLnZbQV0pfWlmKHMmJnAuZmlsbChFLmZpbGxSdWxlKSxOKXtwLnNhdmUoKSxwLmNsaXAoKTtsZXR7aW1hZ2U6QSxvcHRpb25zOnd9PUUudGV4dHVyZTtpZihNJiYoQT1NKSx3LnJlcGVhdCYmY29uc29sZS53YXJuKCJDb250ZXh0IDJEIG5vdCBzdXBwb3J0ZWQgaW1hZ2UgcmVwZWF0IHlldC4iKSxBLmZvbnQpe3cuc2NhbGUmJmNvbnNvbGUud2FybigiQ29udGV4dCAyRCBub3Qgc3VwcG9ydGVkIHRleHQgc2NhbGUgeWV0LiIpLHcuc3JjUmVjdCYmY29uc29sZS53YXJuKCJDb250ZXh0IDJEIG5vdCBzdXBwb3J0ZWQgdGV4dCBzcmNSZWN0IHlldC4iKTtsZXR7Zm9udDpCLGZpbGxDb2xvcjpELHN0cm9rZUNvbG9yOkksc3Ryb2tlV2lkdGg6aix0ZXh0OlZ9PUE7IUQmJiFJJiYoRD0iIzAwMCIpLEFycmF5LmlzQXJyYXkoRCkmJihEPU9iamVjdChpLmRlZmF1bHQpKEQpKSxBcnJheS5pc0FycmF5KEkpJiYoST1PYmplY3QoaS5kZWZhdWx0KShJKSkscC5mb250PUI7Y29uc3R7d2lkdGg6Sn09cC5tZWFzdXJlVGV4dChWKSxfPU9iamVjdChmLmRlZmF1bHQpKEIpLHN0PU1hdGgubWF4KF8ucHhMaW5lSGVpZ2h0LF8ucHhIZWlnaHQqMS4xMyk7cC50ZXh0QWxpZ249ImNlbnRlciIscC50ZXh0QmFzZWxpbmU9Im1pZGRsZSI7Y29uc3QgRz13LnJlY3QsWT1HWzBdK3N0Ki41K18ucHhIZWlnaHQqLjA2LHJ0PUdbMV0rSiouNTtHWzJdIT1udWxsJiZwLnNjYWxlKEdbMl0vSixHWzNdL3N0KSxEJiYocC5maWxsU3R5bGU9RCxwLmZpbGxUZXh0KFYscnQsWSkpLEkmJihwLmxpbmVXaWR0aD1qLHAuc3Ryb2tlU3R5bGU9SSxwLnN0cm9rZVRleHQoVixydCxZKSl9ZWxzZXtsZXQgQj13LnJlY3Q7Y29uc3QgRD13LnNyY1JlY3Q7dy5zY2FsZSYmKEI9WzAsMCxwLmNhbnZhcy53aWR0aCxwLmNhbnZhcy5oZWlnaHRdKSx3LnJvdGF0ZWQmJkImJihCPVstQlsxXSxCWzBdLEJbM10sQlsyXV0pLEQmJihCPUJ8fFswLDAsRFsyXSxEWzNdXSksdy5yb3RhdGVkJiYocC50cmFuc2xhdGUoMCxCP0JbMl06QS53aWR0aCkscC5yb3RhdGUoLS41Kk1hdGguUEkpKSxEP3AuZHJhd0ltYWdlKEEsLi4uRCwuLi5CKTpCP3AuZHJhd0ltYWdlKEEsLi4uQik6cC5kcmF3SW1hZ2UoQSwwLDApfXAucmVzdG9yZSgpfVMmJnAuc3Ryb2tlKCl9fSkscC5yZXN0b3JlKCksTyl7Y29uc3Qgdj1FLmZpbHRlcjt2JiZ1KHAsdil9fX0sZnVuY3Rpb24oZyxlLHQpe3QucihlKSx0LmQoZSwiY2xhbXAiLGZ1bmN0aW9uKCl7cmV0dXJuIG59KSx0LmQoZSwibWl4IixmdW5jdGlvbigpe3JldHVybiBpfSksdC5kKGUsInRyYW5zZm9ybVBvaW50IixmdW5jdGlvbigpe3JldHVybiBmfSksdCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIG4oaCx1LGEpe3JldHVybiB1PmEmJihbdSxhXT1bYSx1XSksaDx1P3U6aD5hP2E6aH1mdW5jdGlvbiBpKGgsdSxhKXtyZXR1cm4gaCooMS1hKSt1KmF9ZnVuY3Rpb24gZihoLHUpe2NvbnN0W2EsZF09aDtyZXR1cm5bYSp1WzBdK2QqdVsyXSt1WzRdLGEqdVsxXStkKnVbM10rdVs1XV19fSxmdW5jdGlvbihnLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBhfSk7dmFyIG49dCgyOCksaT10KDI5KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gZihkLEUscCl7Y29uc3QgTz1kLnVuaWZvcm1zfHx7fSxtPUUudW5pZm9ybXN8fHt9O2lmKE8udV90ZXhTYW1wbGVyJiZtLnVfdGV4U2FtcGxlciYmTy51X3RleFNhbXBsZXIhPT1tLnVfdGV4U2FtcGxlcilyZXR1cm4hMTtjb25zdCBiPU9iamVjdC5rZXlzKE8pLE09T2JqZWN0LmtleXMobSkseT1iLmluZGV4T2YoInVfdGV4U2FtcGxlciIpLFM9TS5pbmRleE9mKCJ1X3RleFNhbXBsZXIiKTtpZih5Pj0wJiZiLnNwbGljZSh5LDEpLFM+PTAmJk0uc3BsaWNlKFMsMSksYi5sZW5ndGghPT1NLmxlbmd0aClyZXR1cm4hMTtjb25zdCBzPWIuZXZlcnkoYz0+e2NvbnN0IGw9T1tjXSx2PW1bY107aWYobD09PXYpcmV0dXJuITA7aWYobC5sZW5ndGgmJnYubGVuZ3RoJiZsLmxlbmd0aD09PXYubGVuZ3RoKXtmb3IobGV0IFQ9MDtUPGwubGVuZ3RoO1QrKylpZihsW1RdIT09dltUXSlyZXR1cm4hMTtyZXR1cm4hMH1yZXR1cm4hMX0pO2lmKHMpe2lmKE8udV90ZXhTYW1wbGVyJiYhbS51X3RleFNhbXBsZXIpRS5zZXRUZXh0dXJlKE8udV90ZXhTYW1wbGVyLHtoaWRkZW46ITB9KTtlbHNlIGlmKCFPLnVfdGV4U2FtcGxlciYmbS51X3RleFNhbXBsZXIpZm9yKGxldCBjPTA7YzxwLmxlbmd0aDtjKyspcFtjXS5zZXRUZXh0dXJlKG0udV90ZXhTYW1wbGVyLHtoaWRkZW46ITB9KX1yZXR1cm4gc31jb25zdCBoPXt9O2Z1bmN0aW9uIHUoZCxFKXtpZihkLmxlbmd0aCl7Y29uc3QgcD1PYmplY3Qobi5kZWZhdWx0KShkLGgpO3JldHVybiBwLmVuYWJsZUJsZW5kPUUsZFswXS5maWx0ZXJDYW52YXMmJihwLmZpbHRlckNhbnZhcz0hMCkscC5wYWNrSW5kZXg9ZFswXS5wYWNrSW5kZXgscC5wYWNrTGVuZ3RoPWQubGVuZ3RoLHAuYmVmb3JlUmVuZGVyPWRbMF0uYmVmb3JlUmVuZGVyLHAucGFzcz1kWzBdLnBhc3MscC5hZnRlclJlbmRlcj1kW2QubGVuZ3RoLTFdLmFmdGVyUmVuZGVyLGQubGVuZ3RoPTAscH19ZnVuY3Rpb24qYShkLEUscD0hMSl7Y29uc3QgTz1bXSxtPWQub3B0aW9ucy5idWZmZXJTaXplO2xldCBiPTAsTT0hMTtmb3IobGV0IHk9MDt5PEUubGVuZ3RoO3krKyl7Y29uc3QgUz1FW3ldO2lmKFMgaW5zdGFuY2VvZiBpLmRlZmF1bHQpTy5sZW5ndGgmJih5aWVsZCB1KE8sTSkpLGI9MCxNPSExLHlpZWxkIFM7ZWxzZXtjb25zdCBzPVMubWVzaERhdGE7aWYocy5jbGlwUGF0aCYmIXMudW5pZm9ybXMudV9jbGlwU2FtcGxlcil7Y29uc3QgbD1kLmNyZWF0ZVRleHR1cmUocy5jbGlwUGF0aCk7cy51bmlmb3Jtcy51X2NsaXBTYW1wbGVyPWx9bGV0IGM9MDtpZigoIXB8fCFTLmNhbklnbm9yZSgpKSYmcyYmcy5wb3NpdGlvbnMubGVuZ3RoKXtTLnBhY2tJbmRleD15O2NvbnN0IGw9Uy5maWx0ZXJDYW52YXM7aWYoYz1zLnBvc2l0aW9ucy5sZW5ndGgsbHx8YitjPm0pTy5sZW5ndGgmJih5aWVsZCB1KE8sTSkpLGI9MCxNPSExO2Vsc2UgaWYoYil7Y29uc3Qgdj1PW08ubGVuZ3RoLTFdO3YmJih2LmZpbHRlckNhbnZhc3x8di5hZnRlclJlbmRlcnx8Uy5iZWZvcmVSZW5kZXJ8fHYucGFzcy5sZW5ndGh8fFMucGFzcy5sZW5ndGh8fHYucHJvZ3JhbSE9PVMucHJvZ3JhbXx8IWYodixTLE8pKSYmKHlpZWxkIHUoTyxNKSxiPTAsTT0hMSl9Ty5wdXNoKFMpLE09TXx8Uy5lbmFibGVCbGVuZCxiKz1jfXk9PT1FLmxlbmd0aC0xJiZPLmxlbmd0aCYmKHlpZWxkIHUoTyxNKSl9fX19LGZ1bmN0aW9uKGcsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIGZ9KSx0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3Qgbj17VU5TSUdORURfQllURTpVaW50OEFycmF5LFVOU0lHTkVEX1NIT1JUOlVpbnQxNkFycmF5LEJZVEU6SW50OEFycmF5LFNIT1JUOkludDE2QXJyYXksRkxPQVQ6RmxvYXQzMkFycmF5fTtmdW5jdGlvbiBpKGgsdSl7bGV0IGE9MCxkPTAsRT0wLHA9MCxPPTAsbT0wLGI9MDtjb25zdCBNPWhbMF0ucHJvZ3JhbTtmb3IobGV0IHk9MDt5PGgubGVuZ3RoO3krKyl7Y29uc3QgUz1oW3ldLm1lc2hEYXRhO2lmKFMpe2IrPVMucG9zaXRpb25zLmxlbmd0aDtjb25zdCBzPVMucG9zaXRpb25zWzBdLmxlbmd0aDthKz1TLnBvc2l0aW9ucy5sZW5ndGgqcyxkKz1TLmNlbGxzLmxlbmd0aCozLG0rPVMuYXR0cmlidXRlcy5hX2NvbG9yLmxlbmd0aCo0O2NvbnN0IGM9Uy50ZXh0dXJlQ29vcmQ7YyYmKEUrPWMubGVuZ3RoKmNbMF0ubGVuZ3RoKTtjb25zdCBsPVMuYXR0cmlidXRlcy5hX3NvdXJjZVJlY3Q7bCYmKHArPWwubGVuZ3RoKjQpO2NvbnN0IHY9Uy5hdHRyaWJ1dGVzLmFfY2xpcFVWO3YmJihPKz12Lmxlbmd0aCoyKX19aWYoKCF1LnBvc2l0aW9uc3x8dS5wb3NpdGlvbnMubGVuZ3RoPGEpJiYodS5wb3NpdGlvbnM9bmV3IEZsb2F0MzJBcnJheShhKSksKCF1LmNlbGxzfHx1LmNlbGxzLmxlbmd0aDxkKSYmKHUuY2VsbHM9bmV3IFVpbnQxNkFycmF5KGQpKSxFJiYoIXUudGV4dHVyZUNvb3JkfHx1LnRleHR1cmVDb29yZC5sZW5ndGg8RSkmJih1LnRleHR1cmVDb29yZD1uZXcgRmxvYXQzMkFycmF5KEUpKSwoIXUuYV9jb2xvcnx8dS5hX2NvbG9yLmxlbmd0aDxtKSYmKHUuYV9jb2xvcj1uZXcgVWludDhBcnJheShtKSkscCYmKCF1LmFfc291cmNlUmVjdHx8dS5hX3NvdXJjZVJlY3QubGVuZ3RoPHApJiYodS5hX3NvdXJjZVJlY3Q9bmV3IEZsb2F0MzJBcnJheShwKSksTyYmKCF1LmFfY2xpcFVWfHx1LmFfY2xpcFVWLmxlbmd0aDxPKSYmKHUuYV9jbGlwVVY9bmV3IEZsb2F0MzJBcnJheShPKSksTSl7Y29uc3QgeT1PYmplY3QuZW50cmllcyhNLl9hdHRyaWJ1dGUpLFM9TS5fYXR0cmliT3B0c3x8e307Zm9yKGxldCBzPTA7czx5Lmxlbmd0aDtzKyspe2NvbnN0W2MsbF09eVtzXTtpZihjIT09ImFfY29sb3IiJiZjIT09ImFfc291cmNlUmVjdCImJmwhPT0iaWdub3JlZCIpe2NvbnN0IHY9U1tjXT9TW2NdLnR5cGU6IkZMT0FUIixUPW5bdl0sUj1sLnNpemUqYjsoIXVbY118fHVbY10ubGVuZ3RoPFIpJiYodVtjXT1uZXcgVChSKSl9fX1yZXR1cm4gdX1mdW5jdGlvbiBmKGgsdSl7bGV0IGE9W10sZD1bXSxFPVtdLHA9W10sTz1bXSxtPVtdLGI9MCxNPTA7Y29uc3QgeT1oWzBdP2hbMF0udW5pZm9ybXN8fHt9Ont9LFM9aFswXT9oWzBdLnByb2dyYW06bnVsbDt1JiYoaShoLHUpLGQ9dS5jZWxscyxhPXUucG9zaXRpb25zLEU9dS50ZXh0dXJlQ29vcmQscD11LmFfY29sb3IsTz11LmFfc291cmNlUmVjdCxtPXUuYV9jbGlwVVYpO2xldCBzPSExLGM9ITE7Y29uc3QgbD17fTtmb3IobGV0IFQ9MDtUPGgubGVuZ3RoO1QrKyl7bGV0IFI9aFtUXTtpZihSKXtpZihSLm1lc2hEYXRhJiYoUj1SLm1lc2hEYXRhKSx1KXtjb25zdCBOPVIucG9zaXRpb25zO2ZvcihsZXQgQT0wO0E8Ti5sZW5ndGg7QSsrKXtjb25zdCB3PU5bQV0sQj0zKihiK0EpO2ZvcihsZXQgRD0wO0Q8dy5sZW5ndGg7RCsrKWFbQitEXT13W0RdfX1lbHNlIGEucHVzaCguLi5SLnBvc2l0aW9ucyk7Y29uc3QgTD1SLmNlbGxzO2ZvcihsZXQgTj0wO048TC5sZW5ndGg7TisrKXtjb25zdCBBPUxbTl07aWYodSl7Y29uc3Qgdz0zKihNK04pO2Rbd109QVswXStiLGRbdysxXT1BWzFdK2IsZFt3KzJdPUFbMl0rYn1lbHNlIGQucHVzaChbQVswXStiLEFbMV0rYixBWzJdK2JdKX1pZih1KXtjb25zdCBOPVIuYXR0cmlidXRlcy5hX2NvbG9yO2ZvcihsZXQgQT0wO0E8Ti5sZW5ndGg7QSsrKXtjb25zdCB3PU5bQV0sQj00KihiK0EpO3BbQl09d1swXSxwW0IrMV09d1sxXSxwW0IrMl09d1syXSxwW0IrM109d1szXX19ZWxzZSBwLnB1c2goLi4uUi5hdHRyaWJ1dGVzLmFfY29sb3IpO2lmKFIuYXR0cmlidXRlcy5hX3NvdXJjZVJlY3QpaWYocz0hMCx1KXtjb25zdCBOPVIuYXR0cmlidXRlcy5hX3NvdXJjZVJlY3Q7Zm9yKGxldCBBPTA7QTxOLmxlbmd0aDtBKyspe2NvbnN0IHc9TltBXSxCPTQqKGIrQSk7T1tCXT13WzBdLE9bQisxXT13WzFdLE9bQisyXT13WzJdLE9bQiszXT13WzNdfX1lbHNlIE8ucHVzaCguLi5SLmF0dHJpYnV0ZXMuYV9zb3VyY2VSZWN0KTtpZihSLmF0dHJpYnV0ZXMuYV9jbGlwVVYpaWYoYz0hMCx1KXtjb25zdCBOPVIuYXR0cmlidXRlcy5hX2NsaXBVVjtmb3IobGV0IEE9MDtBPE4ubGVuZ3RoO0ErKyl7Y29uc3Qgdz1OW0FdLEI9MiooYitBKTttW0JdPXdbMF0sbVtCKzFdPXdbMV19fWVsc2UgbS5wdXNoKC4uLlIuYXR0cmlidXRlcy5hX2NsaXBVVik7aWYoUi50ZXh0dXJlQ29vcmQpaWYodSl7Y29uc3QgTj1SLnRleHR1cmVDb29yZDtmb3IobGV0IEE9MDtBPE4ubGVuZ3RoO0ErKyl7Y29uc3Qgdz1OW0FdLEI9MyooYitBKTtmb3IobGV0IEQ9MDtEPHcubGVuZ3RoO0QrKylFW0IrRF09d1tEXX19ZWxzZSBFLnB1c2goLi4uUi50ZXh0dXJlQ29vcmQpO2lmKFMpe2NvbnN0IE49T2JqZWN0LmVudHJpZXMoUy5fYXR0cmlidXRlKTtmb3IobGV0IEE9MDtBPE4ubGVuZ3RoO0ErKyl7Y29uc3RbdyxCXT1OW0FdO2lmKHchPT0iYV9jb2xvciImJnchPT0iYV9zb3VyY2VSZWN0IiYmQiE9PSJpZ25vcmVkIilpZihsW3ddPVtdLHUpe2xbd109dVt3XTtjb25zdCBEPVIuYXR0cmlidXRlc1t3XSxJPURbMF0ubGVuZ3RoO2ZvcihsZXQgaj0wO2o8RC5sZW5ndGg7aisrKXtjb25zdCBWPURbal0sSj1JKihiK2opO2ZvcihsZXQgXz0wO188Vi5sZW5ndGg7XysrKWxbd11bSitfXT1WW19dfX1lbHNlIGxbd10ucHVzaCguLi5SLmF0dHJpYnV0ZXNbd10pfX1iKz1SLnBvc2l0aW9ucy5sZW5ndGgsTSs9Ui5jZWxscy5sZW5ndGh9fWwuYV9jb2xvcj1wLHMmJk8mJk8ubGVuZ3RoPjAmJihsLmFfc291cmNlUmVjdD1PKTtjb25zdCB2PXtwb3NpdGlvbnM6YSxjZWxsczpkLGF0dHJpYnV0ZXM6bCx1bmlmb3Jtczp5LGNlbGxzQ291bnQ6TSozLHByb2dyYW06U307cmV0dXJuIEUmJkUubGVuZ3RoJiYodi50ZXh0dXJlQ29vcmQ9RSksYyYmbS5sZW5ndGg+MCYmKGwuYV9jbGlwVVY9bSksdn19LGZ1bmN0aW9uKGcsZSx0KXt0LnIoZSk7dmFyIG49dCgxKSxpPXQoMzApLGY9dCgyNiksaD10KDMxKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gdShsLHYpe3ZhciBUPU9iamVjdC5rZXlzKGwpO2lmKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpe3ZhciBSPU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMobCk7diYmKFI9Ui5maWx0ZXIoZnVuY3Rpb24oTCl7cmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobCxMKS5lbnVtZXJhYmxlfSkpLFQucHVzaC5hcHBseShULFIpfXJldHVybiBUfWZ1bmN0aW9uIGEobCl7Zm9yKHZhciB2PTE7djxhcmd1bWVudHMubGVuZ3RoO3YrKyl7dmFyIFQ9YXJndW1lbnRzW3ZdIT1udWxsP2FyZ3VtZW50c1t2XTp7fTt2JTI/dShPYmplY3QoVCksITApLmZvckVhY2goZnVuY3Rpb24oUil7ZChsLFIsVFtSXSl9KTpPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycz9PYmplY3QuZGVmaW5lUHJvcGVydGllcyhsLE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKFQpKTp1KE9iamVjdChUKSkuZm9yRWFjaChmdW5jdGlvbihSKXtPYmplY3QuZGVmaW5lUHJvcGVydHkobCxSLE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoVCxSKSl9KX1yZXR1cm4gbH1mdW5jdGlvbiBkKGwsdixUKXtyZXR1cm4gdiBpbiBsP09iamVjdC5kZWZpbmVQcm9wZXJ0eShsLHYse3ZhbHVlOlQsZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTpsW3ZdPVQsbH1jb25zdCBFPVN5bWJvbCgibWVzaCIpLHA9U3ltYm9sKCJjb3VudCIpLE89U3ltYm9sKCJibGVuZCIpLG09U3ltYm9sKCJmaWx0ZXIiKSxiPVN5bWJvbCgidGV4dHVyZXMiKSxNPVN5bWJvbCgidGV4dHVyZU9wdGlvbnMiKSx5PVN5bWJvbCgiY2xvdWRDb2xvciIpLFM9U3ltYm9sKCJjbG91ZEZpbHRlciIpLHM9U3ltYm9sKCJidWZmZXIiKTtmdW5jdGlvbiBjKGwsdj1udWxsKXtjb25zdCBUPW5ldyBGbG9hdDMyQXJyYXkoMypsKSxSPW5ldyBGbG9hdDMyQXJyYXkoMypsKSxMPW5ldyBGbG9hdDMyQXJyYXkoNCpsKSxOPW5ldyBGbG9hdDMyQXJyYXkoNCpsKSxBPW5ldyBGbG9hdDMyQXJyYXkoNCpsKSx3PW5ldyBGbG9hdDMyQXJyYXkoNCpsKSxCPW5ldyBGbG9hdDMyQXJyYXkoNCpsKSxEPW5ldyBVaW50OEFycmF5KGwpLEk9bmV3IFVpbnQ4QXJyYXkoNCpsKSxqPW5ldyBVaW50OEFycmF5KDQqbCk7cmV0dXJuIHYmJihULnNldCh2LnRyYW5zZm9ybTAsMCksUi5zZXQodi50cmFuc2Zvcm0xLDApLEwuc2V0KHYuY29sb3IwLDApLE4uc2V0KHYuY29sb3IxLDApLEEuc2V0KHYuY29sb3IyLDApLHcuc2V0KHYuY29sb3IzLDApLEIuc2V0KHYuY29sb3I0LDApLEQuc2V0KHYuZnJhbWVJbmRleCwwKSxJLnNldCh2LmZpbGxDb2xvciwwKSxqLnNldCh2LnN0cm9rZUNvbG9yLDApKSx7YnVmZmVyU2l6ZTpsLHRyYW5zZm9ybTA6VCx0cmFuc2Zvcm0xOlIsY29sb3IwOkwsY29sb3IxOk4sY29sb3IyOkEsY29sb3IzOncsY29sb3I0OkIsZnJhbWVJbmRleDpELGZpbGxDb2xvcjpJLHN0cm9rZUNvbG9yOmp9fWUuZGVmYXVsdD1jbGFzc3tjb25zdHJ1Y3RvcihsLHY9MSx7YnVmZmVyOlQ9MWUzfT17fSl7VD1NYXRoLm1heChULHYpLHRoaXNbcF09dix0aGlzW0VdPWwsdGhpc1tzXT1jKFQpLHRoaXNbYl09W10sdGhpc1ttXT1bXSx0aGlzW3ldPSExLHRoaXNbU109ITEsdGhpc1tPXT0hMSx0aGlzLmluaXRCdWZmZXIoKX1pbml0QnVmZmVyKGw9MCl7Y29uc3Qgdj10aGlzW3BdO2ZvcihsZXQgVD1sO1Q8djtUKyspdGhpc1tzXS50cmFuc2Zvcm0wLnNldChbMSwwLDBdLFQqMyksdGhpc1tzXS50cmFuc2Zvcm0xLnNldChbMCwxLDBdLFQqMyksdGhpc1tzXS5mcmFtZUluZGV4LnNldChbLTFdLFQpLHRoaXNbc10uZmlsbENvbG9yLnNldChbMCwwLDAsMF0sVCo0KSx0aGlzW3NdLnN0cm9rZUNvbG9yLnNldChbMCwwLDAsMF0sVCo0KSx0aGlzLnNldENvbG9yVHJhbnNmb3JtKFQsbnVsbCl9Z2V0IGJ1ZmZlclNpemUoKXtyZXR1cm4gdGhpc1tzXS5idWZmZXJTaXplfWdldCBtZXNoKCl7cmV0dXJuIHRoaXNbRV19c2V0IG1lc2gobCl7dGhpc1tFXT1sLHRoaXNbYl0mJnRoaXMuc2V0VGV4dHVyZUZyYW1lcyh0aGlzW2JdLHRoaXNbTV0pfWdldCBoYXNDbG91ZENvbG9yKCl7cmV0dXJuIHRoaXNbeV19Z2V0IGhhc0Nsb3VkRmlsdGVyKCl7cmV0dXJuIHRoaXNbU119X2dldEZpbHRlcihsKXtyZXR1cm4gdGhpc1ttXVtsXT10aGlzW21dW2xdfHxbXSx0aGlzW21dW2xdfWdldEZpbHRlcihsKXtyZXR1cm4gdGhpcy5fZ2V0RmlsdGVyKGwpLmpvaW4oIiAiKX1nZXQgZW5hYmxlQmxlbmQoKXtyZXR1cm4gdGhpc1tFXS5lbmFibGVCbGVuZHx8dGhpc1tPXX1jYW5JZ25vcmUoKXtyZXR1cm4gdGhpc1tFXS5jYW5JZ25vcmUoKX1kZWxldGUobCl7aWYobD49dGhpc1twXXx8bDwwKXRocm93IG5ldyBFcnJvcigiT3V0IG9mIHJhbmdlLiIpO2NvbnN0e3RyYW5zZm9ybTA6dix0cmFuc2Zvcm0xOlQsY29sb3IwOlIsY29sb3IxOkwsY29sb3IyOk4sY29sb3IzOkEsY29sb3I0OncsZnJhbWVJbmRleDpCLGZpbGxDb2xvcjpELHN0cm9rZUNvbG9yOkl9PXRoaXNbc107di5zZXQodi5zdWJhcnJheSgzKihsKzEpKSwzKmwpLFQuc2V0KFQuc3ViYXJyYXkoMyoobCsxKSksMypsKSxSLnNldChSLnN1YmFycmF5KDQqKGwrMSkpLDQqbCksTC5zZXQoTC5zdWJhcnJheSg0KihsKzEpKSw0KmwpLE4uc2V0KE4uc3ViYXJyYXkoNCoobCsxKSksNCpsKSxBLnNldChBLnN1YmFycmF5KDQqKGwrMSkpLDQqbCksdy5zZXQody5zdWJhcnJheSg0KihsKzEpKSw0KmwpLEIuc2V0KEIuc3ViYXJyYXkobCsxKSxsKSxELnNldChELnN1YmFycmF5KDQqKGwrMSkpLDQqbCksSS5zZXQoSS5zdWJhcnJheSg0KihsKzEpKSw0KmwpO2Zvcihjb25zdCBqIGluIHRoaXNbbV0paj09PWw/ZGVsZXRlIHRoaXNbbV1bal06aj5sJiYodGhpc1ttXVtqLTFdPXRoaXNbbV1bal0sZGVsZXRlIHRoaXNbbV1bal0pO3RoaXNbcF0tLX1zZXRDb2xvclRyYW5zZm9ybShsLHYpe2lmKGw+PXRoaXNbcF18fGw8MCl0aHJvdyBuZXcgRXJyb3IoIk91dCBvZiByYW5nZS4iKTtsKj00O2NvbnN0e2NvbG9yMDpULGNvbG9yMTpSLGNvbG9yMjpMLGNvbG9yMzpOLGNvbG9yNDpBfT10aGlzW3NdO3JldHVybiB2IT1udWxsPyhULnNldChbdlswXSx2WzVdLHZbMTBdLHZbMTVdXSxsKSxSLnNldChbdlsxXSx2WzZdLHZbMTFdLHZbMTZdXSxsKSxMLnNldChbdlsyXSx2WzddLHZbMTJdLHZbMTddXSxsKSxOLnNldChbdlszXSx2WzhdLHZbMTNdLHZbMThdXSxsKSxBLnNldChbdls0XSx2WzldLHZbMTRdLHZbMTldXSxsKSx0aGlzW09dPXRoaXNbT118fHZbMThdPDEsdGhpc1tTXT0hMCk6KFQuc2V0KFsxLDAsMCwwXSxsKSxSLnNldChbMCwxLDAsMF0sbCksTC5zZXQoWzAsMCwxLDBdLGwpLE4uc2V0KFswLDAsMCwxXSxsKSxBLnNldChbMCwwLDAsMF0sbCkpLHRoaXN9Z2V0Q29sb3JUcmFuc2Zvcm0obCl7aWYobD49dGhpc1twXXx8bDwwKXRocm93IG5ldyBFcnJvcigiT3V0IG9mIHJhbmdlLiIpO2wqPTQ7Y29uc3R7Y29sb3IwOnYsY29sb3IxOlQsY29sb3IyOlIsY29sb3IzOkwsY29sb3I0Ok59PXRoaXNbc107cmV0dXJuW3ZbbF0sVFtsXSxSW2xdLExbbF0sTltsXSx2W2wrMV0sVFtsKzFdLFJbbCsxXSxMW2wrMV0sTltsKzFdLHZbbCsyXSxUW2wrMl0sUltsKzJdLExbbCsyXSxOW2wrMl0sdltsKzNdLFRbbCszXSxSW2wrM10sTFtsKzNdLE5bbCszXV19dHJhbnNmb3JtQ29sb3IobCx2KXtsZXQgVD10aGlzLmdldENvbG9yVHJhbnNmb3JtKGwpO3JldHVybiBUPU9iamVjdChpLm11bHRpcGx5KShULHYpLHRoaXMuc2V0Q29sb3JUcmFuc2Zvcm0obCxUKSx0aGlzfXNldEZpbGxDb2xvcihsLHYpe2lmKGw+PXRoaXNbcF18fGw8MCl0aHJvdyBuZXcgRXJyb3IoIk91dCBvZiByYW5nZS4iKTt0eXBlb2Ygdj09InN0cmluZyImJih2PU9iamVjdChoLmRlZmF1bHQpKHYpKSx2WzNdPjAmJih0aGlzW3ldPSEwKSx0aGlzW3NdLmZpbGxDb2xvci5zZXQodi5tYXAoVD0+TWF0aC5yb3VuZCgyNTUqVCkpLDQqbCl9c2V0U3Ryb2tlQ29sb3IobCx2KXtpZihsPj10aGlzW3BdfHxsPDApdGhyb3cgbmV3IEVycm9yKCJPdXQgb2YgcmFuZ2UuIik7dHlwZW9mIHY9PSJzdHJpbmciJiYodj1PYmplY3QoaC5kZWZhdWx0KSh2KSksdlszXT4wJiYodGhpc1t5XT0hMCksdGhpc1tzXS5zdHJva2VDb2xvci5zZXQodi5tYXAoVD0+TWF0aC5yb3VuZCgyNTUqVCkpLDQqbCl9Z2V0Q2xvdWRSR0JBKGwpe2lmKGw+PXRoaXNbcF18fGw8MCl0aHJvdyBuZXcgRXJyb3IoIk91dCBvZiByYW5nZS4iKTtsKj00O2NvbnN0e2ZpbGxDb2xvcjp2LHN0cm9rZUNvbG9yOlR9PXRoaXNbc10sUj1bdltsXSx2W2wrMV0sdltsKzJdLHZbbCszXV0sTD1bVFtsXSxUW2wrMV0sVFtsKzJdLFRbbCszXV07cmV0dXJuIFJbM10vPTI1NSxMWzNdLz0yNTUse2ZpbGw6YHJnYmEoJHtSLmpvaW4oKX0pYCxzdHJva2U6YHJnYmEoJHtMLmpvaW4oKX0pYH19Z3JheXNjYWxlKGwsdil7dGhpcy50cmFuc2Zvcm1Db2xvcihsLE9iamVjdChpLmdyYXlzY2FsZSkodikpLHRoaXMuX2dldEZpbHRlcihsKS5wdXNoKGBncmF5c2NhbGUoJHsxMDAqdn0lKWApfWJyaWdodG5lc3MobCx2KXt0aGlzLnRyYW5zZm9ybUNvbG9yKGwsT2JqZWN0KGkuYnJpZ2h0bmVzcykodikpLHRoaXMuX2dldEZpbHRlcihsKS5wdXNoKGBicmlnaHRuZXNzKCR7MTAwKnZ9JSlgKX1zYXR1cmF0ZShsLHYpe3RoaXMudHJhbnNmb3JtQ29sb3IobCxPYmplY3QoaS5zYXR1cmF0ZSkodikpLHRoaXMuX2dldEZpbHRlcihsKS5wdXNoKGBzYXR1cmF0ZSgkezEwMCp2fSUpYCl9Y29udHJhc3QobCx2KXt0aGlzLnRyYW5zZm9ybUNvbG9yKGwsT2JqZWN0KGkuY29udHJhc3QpKHYpKSx0aGlzLl9nZXRGaWx0ZXIobCkucHVzaChgY29udHJhc3QoJHsxMDAqdn0lKWApfWludmVydChsLHYpe3RoaXMudHJhbnNmb3JtQ29sb3IobCxPYmplY3QoaS5pbnZlcnQpKHYpKSx0aGlzLl9nZXRGaWx0ZXIobCkucHVzaChgaW52ZXJ0KCR7MTAwKnZ9JSlgKX1zZXBpYShsLHYpe3RoaXMudHJhbnNmb3JtQ29sb3IobCxPYmplY3QoaS5zZXBpYSkodikpLHRoaXMuX2dldEZpbHRlcihsKS5wdXNoKGBzZXBpYSgkezEwMCp2fSUpYCl9b3BhY2l0eShsLHYpe3RoaXMudHJhbnNmb3JtQ29sb3IobCxPYmplY3QoaS5vcGFjaXR5KSh2KSksdGhpcy5fZ2V0RmlsdGVyKGwpLnB1c2goYG9wYWNpdHkoJHsxMDAqdn0lKWApfWh1ZVJvdGF0ZShsLHYpe3RoaXMudHJhbnNmb3JtQ29sb3IobCxPYmplY3QoaS5odWVSb3RhdGUpKHYpKSx0aGlzLl9nZXRGaWx0ZXIobCkucHVzaChgaHVlLXJvdGF0ZSgke3Z9ZGVnKWApfXNldFRyYW5zZm9ybShsLHYpe2lmKGw+PXRoaXNbcF18fGw8MCl0aHJvdyBuZXcgRXJyb3IoIk91dCBvZiByYW5nZS4iKTtsKj0zLHY9PW51bGwmJih2PVsxLDAsMCwxLDAsMF0pO2NvbnN0e3RyYW5zZm9ybTA6VCx0cmFuc2Zvcm0xOlJ9PXRoaXNbc107cmV0dXJuIFQuc2V0KFt2WzBdLHZbMl0sdls0XV0sbCksUi5zZXQoW3ZbMV0sdlszXSx2WzVdXSxsKSx0aGlzfWdldFRyYW5zZm9ybShsKXtpZihsPj10aGlzW3BdfHxsPDApdGhyb3cgbmV3IEVycm9yKCJPdXQgb2YgcmFuZ2UuIik7bCo9Mztjb25zdHt0cmFuc2Zvcm0wOnYsdHJhbnNmb3JtMTpUfT10aGlzW3NdO3JldHVyblt2W2xdLFRbbF0sdltsKzFdLFRbbCsxXSx2W2wrMl0sVFtsKzJdXX1nZXRUZXh0dXJlRnJhbWUobCl7cmV0dXJuIHRoaXNbYl1bdGhpc1tzXS5mcmFtZUluZGV4W2xdXX1zZXRUZXh0dXJlRnJhbWVzKGw9W10sdj17fSl7aWYobC5sZW5ndGg+MTIpdGhyb3cgbmV3IEVycm9yKCJNYXggZnJhbWVzIGV4Y2VlZC4gQWxsb3cgMTIgZnJhbWVzLiIpO2wubGVuZ3RoJiZ0aGlzW0VdLnNldFRleHR1cmUobFswXSx2KSx0aGlzW2JdPWwsdGhpc1tNXT12fXNldEZyYW1lSW5kZXgobCx2KXtpZihsPj10aGlzW3BdfHxsPDApdGhyb3cgbmV3IEVycm9yKCJPdXQgb2YgcmFuZ2UuIik7Y29uc3QgVD10aGlzW2JdLmxlbmd0aDtpZihUPD0wKXRocm93IG5ldyBFcnJvcigiTm8gZnJhbWVzIik7dGhpc1tzXS5mcmFtZUluZGV4W2xdPXYlVH1nZXQgYW1vdW50KCl7cmV0dXJuIHRoaXNbcF19c2V0IGFtb3VudChsKXtjb25zdCB2PXRoaXNbcF07bCE9PXYmJihsPnRoaXNbc10uYnVmZmVyU2l6ZSYmKHRoaXNbc109YyhNYXRoLm1heChsLHRoaXNbc10uYnVmZmVyU2l6ZSsxZTMpLHRoaXNbc10pKSx0aGlzW3BdPWwsbD52JiZ0aGlzLmluaXRCdWZmZXIodikpfWdldCBtZXNoRGF0YSgpe2NvbnN0e2F0dHJpYnV0ZXM6bCxjZWxsczp2LHBvc2l0aW9uczpULHRleHR1cmVDb29yZDpSLHVuaWZvcm1zOkx9PXRoaXNbRV0ubWVzaERhdGEsTj10aGlzW2JdLEE9e2F0dHJpYnV0ZXM6YSh7fSxsKSxjZWxsczp2LHBvc2l0aW9uczpULHRleHR1cmVDb29yZDpSLHVuaWZvcm1zOmEoe30sTCksaW5zdGFuY2VDb3VudDp0aGlzW3BdLGVuYWJsZUJsZW5kOnRoaXMuZW5hYmxlQmxlbmR9O04ubGVuZ3RoJiZOLmZvckVhY2goKFkscnQpPT57QS51bmlmb3Jtc1tgdV90ZXhGcmFtZSR7cnR9YF09WX0pO2NvbnN0e3RyYW5zZm9ybTA6dyx0cmFuc2Zvcm0xOkIsY29sb3IwOkQsY29sb3IxOkksY29sb3IyOmosY29sb3IzOlYsY29sb3I0OkosZmlsbENvbG9yOl8sc3Ryb2tlQ29sb3I6c3QsZnJhbWVJbmRleDpHfT10aGlzW3NdO3JldHVybiB0aGlzW0VdLnVuaWZvcm1zLnVfdGV4U2FtcGxlciYmKEEuYXR0cmlidXRlcy5hX2ZyYW1lSW5kZXg9e2RhdGE6RyxkaXZpc29yOjF9KSxBLmF0dHJpYnV0ZXMuYV90cmFuc2Zvcm0wPXtkYXRhOncsZGl2aXNvcjoxfSxBLmF0dHJpYnV0ZXMuYV90cmFuc2Zvcm0xPXtkYXRhOkIsZGl2aXNvcjoxfSxBLmF0dHJpYnV0ZXMuYV9jb2xvckNsb3VkMD17ZGF0YTpELGRpdmlzb3I6MX0sQS5hdHRyaWJ1dGVzLmFfY29sb3JDbG91ZDE9e2RhdGE6SSxkaXZpc29yOjF9LEEuYXR0cmlidXRlcy5hX2NvbG9yQ2xvdWQyPXtkYXRhOmosZGl2aXNvcjoxfSxBLmF0dHJpYnV0ZXMuYV9jb2xvckNsb3VkMz17ZGF0YTpWLGRpdmlzb3I6MX0sQS5hdHRyaWJ1dGVzLmFfY29sb3JDbG91ZDQ9e2RhdGE6SixkaXZpc29yOjF9LHRoaXMuaGFzQ2xvdWRDb2xvciYmKEEuYXR0cmlidXRlcy5hX2ZpbGxDbG91ZENvbG9yPXtkYXRhOl8sZGl2aXNvcjoxfSxBLmF0dHJpYnV0ZXMuYV9zdHJva2VDbG91ZENvbG9yPXtkYXRhOnN0LGRpdmlzb3I6MX0pLEF9c2V0UHJvZ3JhbShsKXt0aGlzW0VdLnNldFByb2dyYW0obCl9Z2V0IHByb2dyYW0oKXtyZXR1cm4gdGhpc1tFXS5wcm9ncmFtfXRyYW5zZm9ybShsLHYpe2NvbnN0IFQ9dGhpcy5nZXRUcmFuc2Zvcm0obCk7cmV0dXJuIHY9bi5tYXQyZC5tdWx0aXBseShBcnJheS5vZigwLDAsMCwwLDAsMCksVCx2KSx0aGlzLnNldFRyYW5zZm9ybShsLHYpLHRoaXN9dHJhbnNsYXRlKGwsW3YsVF0pe2xldCBSPW4ubWF0MmQuY3JlYXRlKCk7cmV0dXJuIFI9bi5tYXQyZC50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDApLFIsW3YsVF0pLHRoaXMudHJhbnNmb3JtKGwsUil9cm90YXRlKGwsdixbVCxSXT1bMCwwXSl7bGV0IEw9bi5tYXQyZC5jcmVhdGUoKTtyZXR1cm4gTD1uLm1hdDJkLnRyYW5zbGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCksTCxbVCxSXSksTD1uLm1hdDJkLnJvdGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCksTCx2KSxMPW4ubWF0MmQudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxMLFstVCwtUl0pLHRoaXMudHJhbnNmb3JtKGwsTCl9c2NhbGUobCxbdixUPXZdLFtSLExdPVswLDBdKXtsZXQgTj1uLm1hdDJkLmNyZWF0ZSgpO3JldHVybiBOPW4ubWF0MmQudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxOLFtSLExdKSxOPW4ubWF0MmQuc2NhbGUoQXJyYXkub2YoMCwwLDAsMCwwLDApLE4sW3YsVF0pLE49bi5tYXQyZC50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDApLE4sWy1SLC1MXSksdGhpcy50cmFuc2Zvcm0obCxOKX1za2V3KGwsW3YsVD12XSxbUixMXT1bMCwwXSl7bGV0IE49bi5tYXQyZC5jcmVhdGUoKTtyZXR1cm4gTj1uLm1hdDJkLnRyYW5zbGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCksTixbUixMXSksTj1uLm1hdDJkLm11bHRpcGx5KEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxOLG4ubWF0MmQuZnJvbVZhbHVlcygxLE1hdGgudGFuKFQpLE1hdGgudGFuKHYpLDEsMCwwKSksTj1uLm1hdDJkLnRyYW5zbGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCksTixbLVIsLUxdKSx0aGlzLnRyYW5zZm9ybShsLE4pfWlzUG9pbnRDb2xsaXNpb24obCxbdixUXSxSPSJib3RoIil7Y29uc3QgTD10aGlzLmdldFRyYW5zZm9ybShsKSxOPU9iamVjdChmLnRyYW5zZm9ybVBvaW50KShbdixUXSxuLm1hdDJkLmludmVydChBcnJheS5vZigwLDAsMCwwLDAsMCksTCkpO3JldHVybiB0aGlzW0VdLmlzUG9pbnRDb2xsaXNpb24oLi4uTixSKX1pc1BvaW50SW5GaWxsKGwsW3YsVF0pe3JldHVybiB0aGlzLmlzUG9pbnRDb2xsaXNpb24obCxbdixUXSwiZmlsbCIpfWlzUG9pbnRJblN0cm9rZShsLFt2LFRdKXtyZXR1cm4gdGhpcy5pc1BvaW50Q29sbGlzaW9uKGwsW3YsVF0sInN0cm9rZSIpfX19LGZ1bmN0aW9uKGcsZSx0KXt0LnIoZSksdC5kKGUsIm11bHRpcGx5IixmdW5jdGlvbigpe3JldHVybiBpfSksdC5kKGUsImdyYXlzY2FsZSIsZnVuY3Rpb24oKXtyZXR1cm4gZn0pLHQuZChlLCJicmlnaHRuZXNzIixmdW5jdGlvbigpe3JldHVybiBofSksdC5kKGUsInNhdHVyYXRlIixmdW5jdGlvbigpe3JldHVybiB1fSksdC5kKGUsImNvbnRyYXN0IixmdW5jdGlvbigpe3JldHVybiBhfSksdC5kKGUsImludmVydCIsZnVuY3Rpb24oKXtyZXR1cm4gZH0pLHQuZChlLCJzZXBpYSIsZnVuY3Rpb24oKXtyZXR1cm4gRX0pLHQuZChlLCJvcGFjaXR5IixmdW5jdGlvbigpe3JldHVybiBwfSksdC5kKGUsImh1ZVJvdGF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gT30pO3ZhciBuPXQoMjYpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBpKG0sYil7Y29uc3QgTT1bXSx5PW1bMF0sUz1tWzFdLHM9bVsyXSxjPW1bM10sbD1tWzRdLHY9bVs1XSxUPW1bNl0sUj1tWzddLEw9bVs4XSxOPW1bOV0sQT1tWzEwXSx3PW1bMTFdLEI9bVsxMl0sRD1tWzEzXSxJPW1bMTRdLGo9bVsxNV0sVj1tWzE2XSxKPW1bMTddLF89bVsxOF0sc3Q9bVsxOV07bGV0IEc9YlswXSxZPWJbMV0scnQ9YlsyXSxvdD1iWzNdLGF0PWJbNF07cmV0dXJuIE1bMF09Ryp5K1kqditydCpBK290KmosTVsxXT1HKlMrWSpUK3J0Kncrb3QqVixNWzJdPUcqcytZKlIrcnQqQitvdCpKLE1bM109RypjK1kqTCtydCpEK290Kl8sTVs0XT1HKmwrWSpOK3J0Kkkrb3Qqc3QrYXQsRz1iWzVdLFk9Yls2XSxydD1iWzddLG90PWJbOF0sYXQ9Yls5XSxNWzVdPUcqeStZKnYrcnQqQStvdCpqLE1bNl09RypTK1kqVCtydCp3K290KlYsTVs3XT1HKnMrWSpSK3J0KkIrb3QqSixNWzhdPUcqYytZKkwrcnQqRCtvdCpfLE1bOV09RypsK1kqTitydCpJK290KnN0K2F0LEc9YlsxMF0sWT1iWzExXSxydD1iWzEyXSxvdD1iWzEzXSxhdD1iWzE0XSxNWzEwXT1HKnkrWSp2K3J0KkErb3QqaixNWzExXT1HKlMrWSpUK3J0Kncrb3QqVixNWzEyXT1HKnMrWSpSK3J0KkIrb3QqSixNWzEzXT1HKmMrWSpMK3J0KkQrb3QqXyxNWzE0XT1HKmwrWSpOK3J0Kkkrb3Qqc3QrYXQsRz1iWzE1XSxZPWJbMTZdLHJ0PWJbMTddLG90PWJbMThdLGF0PWJbMTldLE1bMTVdPUcqeStZKnYrcnQqQStvdCpqLE1bMTZdPUcqUytZKlQrcnQqdytvdCpWLE1bMTddPUcqcytZKlIrcnQqQitvdCpKLE1bMThdPUcqYytZKkwrcnQqRCtvdCpfLE1bMTldPUcqbCtZKk4rcnQqSStvdCpzdCthdCxNfWZ1bmN0aW9uIGYobSl7bT1PYmplY3Qobi5jbGFtcCkoMCwxLG0pO2NvbnN0IGI9LjIxMjYqbSxNPS43MTUyKm0seT0uMDcyMiptO3JldHVybltiKzEtbSxNLHksMCwwLGIsTSsxLW0seSwwLDAsYixNLHkrMS1tLDAsMCwwLDAsMCwxLDBdfWZ1bmN0aW9uIGgobSl7cmV0dXJuW20sMCwwLDAsMCwwLG0sMCwwLDAsMCwwLG0sMCwwLDAsMCwwLDEsMF19ZnVuY3Rpb24gdShtKXtjb25zdCBiPS4yMTI2KigxLW0pLE09LjcxNTIqKDEtbSkseT0uMDcyMiooMS1tKTtyZXR1cm5bYittLE0seSwwLDAsYixNK20seSwwLDAsYixNLHkrbSwwLDAsMCwwLDAsMSwwXX1mdW5jdGlvbiBhKG0pe2NvbnN0IGI9LjUqKDEtbSk7cmV0dXJuW20sMCwwLDAsYiwwLG0sMCwwLGIsMCwwLG0sMCxiLDAsMCwwLDEsMF19ZnVuY3Rpb24gZChtKXtjb25zdCBiPTEtMiptO3JldHVybltiLDAsMCwwLG0sMCxiLDAsMCxtLDAsMCxiLDAsbSwwLDAsMCwxLDBdfWZ1bmN0aW9uIEUobSl7cmV0dXJuWzEtLjYwNyptLC43NjkqbSwuMTg5Km0sMCwwLC4zNDkqbSwxLS4zMTQqbSwuMTY4Km0sMCwwLC4yNzIqbSwuNTM0Km0sMS0uODY5Km0sMCwwLDAsMCwwLDEsMF19ZnVuY3Rpb24gcChtKXtyZXR1cm5bMSwwLDAsMCwwLDAsMSwwLDAsMCwwLDAsMSwwLDAsMCwwLDAsbSwwXX1mdW5jdGlvbiBPKG0pe2NvbnN0IGI9bS8xODAqTWF0aC5QSSxNPU1hdGguY29zKGIpLHk9TWF0aC5zaW4oYiksUz0uMjEyNixzPS43MTUyLGM9LjA3MjI7cmV0dXJuW1MrTSooMS1TKSt5Ki1TLHMrTSotcyt5Ki1zLGMrTSotYyt5KigxLWMpLDAsMCxTK00qLVMreSouMTQzLHMrTSooMS1zKSt5Ki4xNCxjK00qLWMreSotLjI4MywwLDAsUytNKi1TK3kqLSgxLVMpLHMrTSotcyt5KnMsYytNKigxLWMpK3kqYywwLDAsMCwwLDAsMSwwXX19LGZ1bmN0aW9uKGcsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIGZ9KTt2YXIgbj10KDMyKSxpPXQubihuKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gZihoKXtjb25zdCB1PWkoKShoKTtpZighdXx8IXUubGVuZ3RoKXRocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgY29sb3IgdmFsdWUuIik7cmV0dXJuW3VbMF0vMjU1LHVbMV0vMjU1LHVbMl0vMjU1LHVbM11dfX0sZnVuY3Rpb24oZyxlLHQpe3ZhciBuPXQoMzMpLGk9dCgzNyksZj10KDM5KTtnLmV4cG9ydHM9ZnVuY3Rpb24odSl7dmFyIGEsZD1uKHUpO3JldHVybiBkLnNwYWNlPyhhPUFycmF5KDMpLGFbMF09ZihkLnZhbHVlc1swXSwwLDI1NSksYVsxXT1mKGQudmFsdWVzWzFdLDAsMjU1KSxhWzJdPWYoZC52YWx1ZXNbMl0sMCwyNTUpLGQuc3BhY2VbMF09PT0iaCImJihhPWkucmdiKGEpKSxhLnB1c2goZihkLmFscGhhLDAsMSkpLGEpOltdfX0sZnVuY3Rpb24oZyxlLHQpeyhmdW5jdGlvbihuKXt2YXIgaT10KDM0KSxmPXQoMzUpLGg9dCgzNik7Zy5leHBvcnRzPWE7dmFyIHU9e3JlZDowLG9yYW5nZTo2MCx5ZWxsb3c6MTIwLGdyZWVuOjE4MCxibHVlOjI0MCxwdXJwbGU6MzAwfTtmdW5jdGlvbiBhKGQpe3ZhciBFLHA9W10sTz0xLG07aWYodHlwZW9mIGQ9PSJzdHJpbmciKWlmKGlbZF0pcD1pW2RdLnNsaWNlKCksbT0icmdiIjtlbHNlIGlmKGQ9PT0idHJhbnNwYXJlbnQiKU89MCxtPSJyZ2IiLHA9WzAsMCwwXTtlbHNlIGlmKC9eI1tBLUZhLWYwLTldKyQvLnRlc3QoZCkpe3ZhciBiPWQuc2xpY2UoMSksTT1iLmxlbmd0aCx5PU08PTQ7Tz0xLHk/KHA9W3BhcnNlSW50KGJbMF0rYlswXSwxNikscGFyc2VJbnQoYlsxXStiWzFdLDE2KSxwYXJzZUludChiWzJdK2JbMl0sMTYpXSxNPT09NCYmKE89cGFyc2VJbnQoYlszXStiWzNdLDE2KS8yNTUpKToocD1bcGFyc2VJbnQoYlswXStiWzFdLDE2KSxwYXJzZUludChiWzJdK2JbM10sMTYpLHBhcnNlSW50KGJbNF0rYls1XSwxNildLE09PT04JiYoTz1wYXJzZUludChiWzZdK2JbN10sMTYpLzI1NSkpLHBbMF18fChwWzBdPTApLHBbMV18fChwWzFdPTApLHBbMl18fChwWzJdPTApLG09InJnYiJ9ZWxzZSBpZihFPS9eKCg/OnJnYnxoc1tsdmJdfGh3YnxjbXlrP3x4eVt6eV18Z3JheXxsYWJ8bGNodT92P3xbbHlddXZ8bG1zKWE/KVxzKlwoKFteXCldKilcKS8uZXhlYyhkKSl7dmFyIFM9RVsxXSxzPVM9PT0icmdiIixiPVMucmVwbGFjZSgvYSQvLCIiKTttPWI7dmFyIE09Yj09PSJjbXlrIj80OmI9PT0iZ3JheSI/MTozO3A9RVsyXS50cmltKCkuc3BsaXQoL1xzKixccyovKS5tYXAoZnVuY3Rpb24oVCxSKXtpZigvJSQvLnRlc3QoVCkpcmV0dXJuIFI9PT1NP3BhcnNlRmxvYXQoVCkvMTAwOmI9PT0icmdiIj9wYXJzZUZsb2F0KFQpKjI1NS8xMDA6cGFyc2VGbG9hdChUKTtpZihiW1JdPT09ImgiKXtpZigvZGVnJC8udGVzdChUKSlyZXR1cm4gcGFyc2VGbG9hdChUKTtpZih1W1RdIT09dm9pZCAwKXJldHVybiB1W1RdfXJldHVybiBwYXJzZUZsb2F0KFQpfSksUz09PWImJnAucHVzaCgxKSxPPXN8fHBbTV09PT12b2lkIDA/MTpwW01dLHA9cC5zbGljZSgwLE0pfWVsc2UgZC5sZW5ndGg+MTAmJi9bMC05XSg/OlxzfFwvKS8udGVzdChkKSYmKHA9ZC5tYXRjaCgvKFswLTldKykvZykubWFwKGZ1bmN0aW9uKGwpe3JldHVybiBwYXJzZUZsb2F0KGwpfSksbT1kLm1hdGNoKC8oW2Etel0pL2lnKS5qb2luKCIiKS50b0xvd2VyQ2FzZSgpKTtlbHNlIGlmKCFpc05hTihkKSltPSJyZ2IiLHA9W2Q+Pj4xNiwoZCY2NTI4MCk+Pj44LGQmMjU1XTtlbHNlIGlmKGYoZCkpe3ZhciBjPWgoZC5yLGQucmVkLGQuUixudWxsKTtjIT09bnVsbD8obT0icmdiIixwPVtjLGgoZC5nLGQuZ3JlZW4sZC5HKSxoKGQuYixkLmJsdWUsZC5CKV0pOihtPSJoc2wiLHA9W2goZC5oLGQuaHVlLGQuSCksaChkLnMsZC5zYXR1cmF0aW9uLGQuUyksaChkLmwsZC5saWdodG5lc3MsZC5MLGQuYixkLmJyaWdodG5lc3MpXSksTz1oKGQuYSxkLmFscGhhLGQub3BhY2l0eSwxKSxkLm9wYWNpdHkhPW51bGwmJihPLz0xMDApfWVsc2UoQXJyYXkuaXNBcnJheShkKXx8bi5BcnJheUJ1ZmZlciYmQXJyYXlCdWZmZXIuaXNWaWV3JiZBcnJheUJ1ZmZlci5pc1ZpZXcoZCkpJiYocD1bZFswXSxkWzFdLGRbMl1dLG09InJnYiIsTz1kLmxlbmd0aD09PTQ/ZFszXToxKTtyZXR1cm57c3BhY2U6bSx2YWx1ZXM6cCxhbHBoYTpPfX19KS5jYWxsKHRoaXMsdCgyMikpfSxmdW5jdGlvbihnLGUsdCl7Zy5leHBvcnRzPXthbGljZWJsdWU6WzI0MCwyNDgsMjU1XSxhbnRpcXVld2hpdGU6WzI1MCwyMzUsMjE1XSxhcXVhOlswLDI1NSwyNTVdLGFxdWFtYXJpbmU6WzEyNywyNTUsMjEyXSxhenVyZTpbMjQwLDI1NSwyNTVdLGJlaWdlOlsyNDUsMjQ1LDIyMF0sYmlzcXVlOlsyNTUsMjI4LDE5Nl0sYmxhY2s6WzAsMCwwXSxibGFuY2hlZGFsbW9uZDpbMjU1LDIzNSwyMDVdLGJsdWU6WzAsMCwyNTVdLGJsdWV2aW9sZXQ6WzEzOCw0MywyMjZdLGJyb3duOlsxNjUsNDIsNDJdLGJ1cmx5d29vZDpbMjIyLDE4NCwxMzVdLGNhZGV0Ymx1ZTpbOTUsMTU4LDE2MF0sY2hhcnRyZXVzZTpbMTI3LDI1NSwwXSxjaG9jb2xhdGU6WzIxMCwxMDUsMzBdLGNvcmFsOlsyNTUsMTI3LDgwXSxjb3JuZmxvd2VyYmx1ZTpbMTAwLDE0OSwyMzddLGNvcm5zaWxrOlsyNTUsMjQ4LDIyMF0sY3JpbXNvbjpbMjIwLDIwLDYwXSxjeWFuOlswLDI1NSwyNTVdLGRhcmtibHVlOlswLDAsMTM5XSxkYXJrY3lhbjpbMCwxMzksMTM5XSxkYXJrZ29sZGVucm9kOlsxODQsMTM0LDExXSxkYXJrZ3JheTpbMTY5LDE2OSwxNjldLGRhcmtncmVlbjpbMCwxMDAsMF0sZGFya2dyZXk6WzE2OSwxNjksMTY5XSxkYXJra2hha2k6WzE4OSwxODMsMTA3XSxkYXJrbWFnZW50YTpbMTM5LDAsMTM5XSxkYXJrb2xpdmVncmVlbjpbODUsMTA3LDQ3XSxkYXJrb3JhbmdlOlsyNTUsMTQwLDBdLGRhcmtvcmNoaWQ6WzE1Myw1MCwyMDRdLGRhcmtyZWQ6WzEzOSwwLDBdLGRhcmtzYWxtb246WzIzMywxNTAsMTIyXSxkYXJrc2VhZ3JlZW46WzE0MywxODgsMTQzXSxkYXJrc2xhdGVibHVlOls3Miw2MSwxMzldLGRhcmtzbGF0ZWdyYXk6WzQ3LDc5LDc5XSxkYXJrc2xhdGVncmV5Ols0Nyw3OSw3OV0sZGFya3R1cnF1b2lzZTpbMCwyMDYsMjA5XSxkYXJrdmlvbGV0OlsxNDgsMCwyMTFdLGRlZXBwaW5rOlsyNTUsMjAsMTQ3XSxkZWVwc2t5Ymx1ZTpbMCwxOTEsMjU1XSxkaW1ncmF5OlsxMDUsMTA1LDEwNV0sZGltZ3JleTpbMTA1LDEwNSwxMDVdLGRvZGdlcmJsdWU6WzMwLDE0NCwyNTVdLGZpcmVicmljazpbMTc4LDM0LDM0XSxmbG9yYWx3aGl0ZTpbMjU1LDI1MCwyNDBdLGZvcmVzdGdyZWVuOlszNCwxMzksMzRdLGZ1Y2hzaWE6WzI1NSwwLDI1NV0sZ2FpbnNib3JvOlsyMjAsMjIwLDIyMF0sZ2hvc3R3aGl0ZTpbMjQ4LDI0OCwyNTVdLGdvbGQ6WzI1NSwyMTUsMF0sZ29sZGVucm9kOlsyMTgsMTY1LDMyXSxncmF5OlsxMjgsMTI4LDEyOF0sZ3JlZW46WzAsMTI4LDBdLGdyZWVueWVsbG93OlsxNzMsMjU1LDQ3XSxncmV5OlsxMjgsMTI4LDEyOF0saG9uZXlkZXc6WzI0MCwyNTUsMjQwXSxob3RwaW5rOlsyNTUsMTA1LDE4MF0saW5kaWFucmVkOlsyMDUsOTIsOTJdLGluZGlnbzpbNzUsMCwxMzBdLGl2b3J5OlsyNTUsMjU1LDI0MF0sa2hha2k6WzI0MCwyMzAsMTQwXSxsYXZlbmRlcjpbMjMwLDIzMCwyNTBdLGxhdmVuZGVyYmx1c2g6WzI1NSwyNDAsMjQ1XSxsYXduZ3JlZW46WzEyNCwyNTIsMF0sbGVtb25jaGlmZm9uOlsyNTUsMjUwLDIwNV0sbGlnaHRibHVlOlsxNzMsMjE2LDIzMF0sbGlnaHRjb3JhbDpbMjQwLDEyOCwxMjhdLGxpZ2h0Y3lhbjpbMjI0LDI1NSwyNTVdLGxpZ2h0Z29sZGVucm9keWVsbG93OlsyNTAsMjUwLDIxMF0sbGlnaHRncmF5OlsyMTEsMjExLDIxMV0sbGlnaHRncmVlbjpbMTQ0LDIzOCwxNDRdLGxpZ2h0Z3JleTpbMjExLDIxMSwyMTFdLGxpZ2h0cGluazpbMjU1LDE4MiwxOTNdLGxpZ2h0c2FsbW9uOlsyNTUsMTYwLDEyMl0sbGlnaHRzZWFncmVlbjpbMzIsMTc4LDE3MF0sbGlnaHRza3libHVlOlsxMzUsMjA2LDI1MF0sbGlnaHRzbGF0ZWdyYXk6WzExOSwxMzYsMTUzXSxsaWdodHNsYXRlZ3JleTpbMTE5LDEzNiwxNTNdLGxpZ2h0c3RlZWxibHVlOlsxNzYsMTk2LDIyMl0sbGlnaHR5ZWxsb3c6WzI1NSwyNTUsMjI0XSxsaW1lOlswLDI1NSwwXSxsaW1lZ3JlZW46WzUwLDIwNSw1MF0sbGluZW46WzI1MCwyNDAsMjMwXSxtYWdlbnRhOlsyNTUsMCwyNTVdLG1hcm9vbjpbMTI4LDAsMF0sbWVkaXVtYXF1YW1hcmluZTpbMTAyLDIwNSwxNzBdLG1lZGl1bWJsdWU6WzAsMCwyMDVdLG1lZGl1bW9yY2hpZDpbMTg2LDg1LDIxMV0sbWVkaXVtcHVycGxlOlsxNDcsMTEyLDIxOV0sbWVkaXVtc2VhZ3JlZW46WzYwLDE3OSwxMTNdLG1lZGl1bXNsYXRlYmx1ZTpbMTIzLDEwNCwyMzhdLG1lZGl1bXNwcmluZ2dyZWVuOlswLDI1MCwxNTRdLG1lZGl1bXR1cnF1b2lzZTpbNzIsMjA5LDIwNF0sbWVkaXVtdmlvbGV0cmVkOlsxOTksMjEsMTMzXSxtaWRuaWdodGJsdWU6WzI1LDI1LDExMl0sbWludGNyZWFtOlsyNDUsMjU1LDI1MF0sbWlzdHlyb3NlOlsyNTUsMjI4LDIyNV0sbW9jY2FzaW46WzI1NSwyMjgsMTgxXSxuYXZham93aGl0ZTpbMjU1LDIyMiwxNzNdLG5hdnk6WzAsMCwxMjhdLG9sZGxhY2U6WzI1MywyNDUsMjMwXSxvbGl2ZTpbMTI4LDEyOCwwXSxvbGl2ZWRyYWI6WzEwNywxNDIsMzVdLG9yYW5nZTpbMjU1LDE2NSwwXSxvcmFuZ2VyZWQ6WzI1NSw2OSwwXSxvcmNoaWQ6WzIxOCwxMTIsMjE0XSxwYWxlZ29sZGVucm9kOlsyMzgsMjMyLDE3MF0scGFsZWdyZWVuOlsxNTIsMjUxLDE1Ml0scGFsZXR1cnF1b2lzZTpbMTc1LDIzOCwyMzhdLHBhbGV2aW9sZXRyZWQ6WzIxOSwxMTIsMTQ3XSxwYXBheWF3aGlwOlsyNTUsMjM5LDIxM10scGVhY2hwdWZmOlsyNTUsMjE4LDE4NV0scGVydTpbMjA1LDEzMyw2M10scGluazpbMjU1LDE5MiwyMDNdLHBsdW06WzIyMSwxNjAsMjIxXSxwb3dkZXJibHVlOlsxNzYsMjI0LDIzMF0scHVycGxlOlsxMjgsMCwxMjhdLHJlYmVjY2FwdXJwbGU6WzEwMiw1MSwxNTNdLHJlZDpbMjU1LDAsMF0scm9zeWJyb3duOlsxODgsMTQzLDE0M10scm95YWxibHVlOls2NSwxMDUsMjI1XSxzYWRkbGVicm93bjpbMTM5LDY5LDE5XSxzYWxtb246WzI1MCwxMjgsMTE0XSxzYW5keWJyb3duOlsyNDQsMTY0LDk2XSxzZWFncmVlbjpbNDYsMTM5LDg3XSxzZWFzaGVsbDpbMjU1LDI0NSwyMzhdLHNpZW5uYTpbMTYwLDgyLDQ1XSxzaWx2ZXI6WzE5MiwxOTIsMTkyXSxza3libHVlOlsxMzUsMjA2LDIzNV0sc2xhdGVibHVlOlsxMDYsOTAsMjA1XSxzbGF0ZWdyYXk6WzExMiwxMjgsMTQ0XSxzbGF0ZWdyZXk6WzExMiwxMjgsMTQ0XSxzbm93OlsyNTUsMjUwLDI1MF0sc3ByaW5nZ3JlZW46WzAsMjU1LDEyN10sc3RlZWxibHVlOls3MCwxMzAsMTgwXSx0YW46WzIxMCwxODAsMTQwXSx0ZWFsOlswLDEyOCwxMjhdLHRoaXN0bGU6WzIxNiwxOTEsMjE2XSx0b21hdG86WzI1NSw5OSw3MV0sdHVycXVvaXNlOls2NCwyMjQsMjA4XSx2aW9sZXQ6WzIzOCwxMzAsMjM4XSx3aGVhdDpbMjQ1LDIyMiwxNzldLHdoaXRlOlsyNTUsMjU1LDI1NV0sd2hpdGVzbW9rZTpbMjQ1LDI0NSwyNDVdLHllbGxvdzpbMjU1LDI1NSwwXSx5ZWxsb3dncmVlbjpbMTU0LDIwNSw1MF19fSxmdW5jdGlvbihnLGUsdCl7dmFyIG49T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztnLmV4cG9ydHM9ZnVuY3Rpb24oaSl7dmFyIGY7cmV0dXJuIG4uY2FsbChpKT09PSJbb2JqZWN0IE9iamVjdF0iJiYoZj1PYmplY3QuZ2V0UHJvdG90eXBlT2YoaSksZj09PW51bGx8fGY9PT1PYmplY3QuZ2V0UHJvdG90eXBlT2Yoe30pKX19LGZ1bmN0aW9uKGcsZSl7Zy5leHBvcnRzPWZ1bmN0aW9uKCl7Zm9yKHZhciB0PTA7dDxhcmd1bWVudHMubGVuZ3RoO3QrKylpZihhcmd1bWVudHNbdF0hPT12b2lkIDApcmV0dXJuIGFyZ3VtZW50c1t0XX19LGZ1bmN0aW9uKGcsZSx0KXt2YXIgbj10KDM4KTtnLmV4cG9ydHM9e25hbWU6ImhzbCIsbWluOlswLDAsMF0sbWF4OlszNjAsMTAwLDEwMF0sY2hhbm5lbDpbImh1ZSIsInNhdHVyYXRpb24iLCJsaWdodG5lc3MiXSxhbGlhczpbIkhTTCJdLHJnYjpmdW5jdGlvbihpKXt2YXIgZj1pWzBdLzM2MCxoPWlbMV0vMTAwLHU9aVsyXS8xMDAsYSxkLEUscCxPO2lmKGg9PT0wKXJldHVybiBPPXUqMjU1LFtPLE8sT107dTwuNT9kPXUqKDEraCk6ZD11K2gtdSpoLGE9Mip1LWQscD1bMCwwLDBdO2Zvcih2YXIgbT0wO208MzttKyspRT1mKzEvMyotKG0tMSksRTwwP0UrKzpFPjEmJkUtLSw2KkU8MT9PPWErKGQtYSkqNipFOjIqRTwxP089ZDozKkU8Mj9PPWErKGQtYSkqKDIvMy1FKSo2Ok89YSxwW21dPU8qMjU1O3JldHVybiBwfX0sbi5oc2w9ZnVuY3Rpb24oaSl7dmFyIGY9aVswXS8yNTUsaD1pWzFdLzI1NSx1PWlbMl0vMjU1LGE9TWF0aC5taW4oZixoLHUpLGQ9TWF0aC5tYXgoZixoLHUpLEU9ZC1hLHAsTyxtO3JldHVybiBkPT09YT9wPTA6Zj09PWQ/cD0oaC11KS9FOmg9PT1kP3A9MisodS1mKS9FOnU9PT1kJiYocD00KyhmLWgpL0UpLHA9TWF0aC5taW4ocCo2MCwzNjApLHA8MCYmKHArPTM2MCksbT0oYStkKS8yLGQ9PT1hP089MDptPD0uNT9PPUUvKGQrYSk6Tz1FLygyLWQtYSksW3AsTyoxMDAsbSoxMDBdfX0sZnVuY3Rpb24oZyxlLHQpe2cuZXhwb3J0cz17bmFtZToicmdiIixtaW46WzAsMCwwXSxtYXg6WzI1NSwyNTUsMjU1XSxjaGFubmVsOlsicmVkIiwiZ3JlZW4iLCJibHVlIl0sYWxpYXM6WyJSR0IiXX19LGZ1bmN0aW9uKGcsZSl7Zy5leHBvcnRzPXQ7ZnVuY3Rpb24gdChuLGksZil7cmV0dXJuIGk8Zj9uPGk/aTpuPmY/ZjpuOm48Zj9mOm4+aT9pOm59fSxmdW5jdGlvbihnLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBjfSk7dmFyIG49dCg0MSksaT10Lm4obiksZj10KDQyKSxoPXQubihmKSx1PXQoNDMpLGE9dC5uKHUpLGQ9dCg0NCksRT10KDQ2KSxwPXQubihFKSxPPXQoNTMpLG09dCg1NSk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IGI9U3ltYm9sKCJjb250b3VycyIpLE09U3ltYm9sKCJwYXRoIikseT1TeW1ib2woInNpbXBsaWZ5IiksUz1TeW1ib2woInNjYWxlIikscz0yKk1hdGguUEk7Y2xhc3MgY3tjb25zdHJ1Y3Rvcih2PXt9KXt0eXBlb2Ygdj09InN0cmluZyImJih2PXtwYXRoOnZ9KSx2LnBhdGg/dGhpc1tNXT1pKCkodi5wYXRoKTp0aGlzW01dPVtdLHRoaXNbYl09bnVsbCx0aGlzW3ldPXYuc2ltcGxpZnkhPW51bGw/di5zaW1wbGlmeTowLHRoaXNbU109di5zY2FsZSE9bnVsbD92LnNjYWxlOjJ9Z2V0IGNvbnRvdXJzKCl7bGV0IHY9bnVsbDtpZighdGhpc1tiXSYmdGhpc1tNXSl7Y29uc3QgVD1PYmplY3QoZC5kZWZhdWx0KShhKCkodGhpc1tNXSkpO3RoaXNbYl09cCgpKFQsdGhpc1tTXSx0aGlzW3ldKSx0aGlzW2JdLnBhdGg9VCx0aGlzW2JdLnNpbXBsaWZ5PXRoaXNbeV0sdGhpc1tiXS5zY2FsZT10aGlzW1NdfXJldHVybiB0aGlzW2JdJiYodj10aGlzW2JdLm1hcChUPT5bLi4uVF0pLHYucGF0aD10aGlzW2JdLnBhdGgsdi5zaW1wbGlmeT10aGlzW2JdLnNpbXBsaWZ5LHYuc2NhbGU9dGhpc1tiXS5zY2FsZSksdn1nZXQgcGF0aCgpe3JldHVybiB0aGlzW01dfWdldCBzaW1wbGlmeSgpe3JldHVybiB0aGlzW3ldfWdldCBib3VuZGluZ0JveCgpe2NvbnN0IHY9dGhpcy5jb250b3VycztpZih2JiZ2Lmxlbmd0aCl7Y29uc3QgVD12LnJlZHVjZSgoUixMKT0+Wy4uLlIsLi4uTF0pO3JldHVybiBoKCkoVCl9cmV0dXJuW1swLDBdLFswLDBdXX1nZXQgYm91bmRpbmdDZW50ZXIoKXtjb25zdCB2PXRoaXMuYm91bmRpbmdCb3g7cmV0dXJuIHY/Wy41Kih2WzBdWzBdK3ZbMV1bMF0pLC41Kih2WzBdWzFdK3ZbMV1bMV0pXTpbMCwwXX1ub3JtYWxpemUodj0wLFQ9MCl7Y29uc3QgUj1PYmplY3QoZC5kZWZhdWx0KShhKCkodGhpc1tNXSkpLm1hcCgoW0wsLi4uTl0pPT57Y29uc3QgQT1bTF07Zm9yKGxldCB3PTA7dzxOLmxlbmd0aDt3Kz0yKXtjb25zdCBCPU5bd10tdixEPU5bdysxXS1UO0EucHVzaChCLEQpfXJldHVybiBBfSk7cmV0dXJuIHRoaXMuYmVnaW5QYXRoKCksdGhpc1tNXS5wdXNoKC4uLlIpLHRoaXN9Z2V0UG9pbnRBdExlbmd0aCh2KXtyZXR1cm4gdGhpcy5jb250b3Vycz9PYmplY3QoTy5nZXRQb2ludEF0TGVuZ3RoKSh0aGlzW2JdLHYpOm51bGx9Z2V0VG90YWxMZW5ndGgoKXtyZXR1cm4gdGhpcy5jb250b3Vycz9PYmplY3QoTy5nZXRUb3RhbExlbmd0aCkodGhpc1tiXSk6MH1hZGRQYXRoKHYpe3RoaXNbYl09bnVsbCx0eXBlb2Ygdj09InN0cmluZyImJih2PWkoKSh2KSksdGhpc1tNXS5wdXNoKC4uLnYpfWJlZ2luUGF0aCgpe3RoaXNbTV09W10sdGhpc1tiXT1udWxsfWNsZWFyKCl7dGhpcy5iZWdpblBhdGgoKX1lbGxpcHNlKHYsVCxSLEwsTixBLHcsQj0wKXtpZihBKz1OLHcrPU4sUjw9MHx8TDw9MHx8dz09PUEpcmV0dXJuO3c8QSYmKHc9QStzKyh3LUEpJXMpLHctQT5zJiYodz1BK3MpO2NvbnN0IEQ9dy1BO0Q+PXMmJih3LT0uMDAxKTtsZXQgST10aGlzW01dLmxlbmd0aD4wJiZEPHM/IkwiOiJNIjtjb25zdCBqPU9iamVjdChtLmdldFBvaW50KSh2LFQsUixMLEEpLFY9T2JqZWN0KG0uZ2V0UG9pbnQpKHYsVCxSLEwsdyksSj0rIUI7bGV0IF89RD5NYXRoLlBJPzE6MDtCJiYoXz0xLV8pLEkrPWouam9pbigiICIpLEkrPWBBJHtSfSAke0x9IDAgJHtffSAke0p9ICR7Vi5qb2luKCIgIil9YCxEPj1zJiYoSSs9IloiKSx0aGlzLmFkZFBhdGgoSSl9YXJjKHYsVCxSLEwsTixBPTApe3JldHVybiB0aGlzLmVsbGlwc2UodixULFIsUiwwLEwsTixBKX1hcmNUbyh2LFQsUixMLE4sQSx3KXt0aGlzW2JdPW51bGwsdGhpc1tNXS5wdXNoKFsiQSIsdixULFIsTCxOLEEsd10pfW1vdmVUbyh2LFQpe3RoaXNbYl09bnVsbCx0aGlzW01dLnB1c2goWyJNIix2LFRdKX1saW5lVG8odixUKXt0aGlzW2JdPW51bGwsdGhpc1tNXS5wdXNoKFsiTCIsdixUXSl9YmV6aWVyQ3VydmVUbyh2LFQsUixMLE4sQSl7dGhpc1tiXT1udWxsLHRoaXNbTV0ucHVzaChbIkMiLHYsVCxSLEwsTixBXSl9cXVhZHJhdGljQ3VydmVUbyh2LFQsUixMKXt0aGlzW2JdPW51bGwsdGhpc1tNXS5wdXNoKFsiUSIsdixULFIsTF0pfXJlY3QodixULFIsTCl7Y29uc3QgTj1gTSR7dn0gJHtUfUwke3YrUn0gJHtUfUwke3YrUn0gJHtUK0x9TCR7dn0gJHtUK0x9WmA7dGhpcy5hZGRQYXRoKE4pfWNsb3NlUGF0aCgpe3RoaXNbYl09bnVsbDtsZXQgdj1bXTtjb25zdCBUPXRoaXNbTV0ubGVuZ3RoO1Q+MCYmKHY9dGhpc1tNXVtULTFdKSx2WzBdIT09IloiJiZ2WzBdIT09InoiJiZ0aGlzW01dLnB1c2goWyJaIl0pfX19LGZ1bmN0aW9uKGcsZSl7Zy5leHBvcnRzPWk7dmFyIHQ9e2E6NyxjOjYsaDoxLGw6MixtOjIscTo0LHM6NCx0OjIsdjoxLHo6MH0sbj0vKFthc3R2enFtaGxjXSkoW15hc3R2enFtaGxjXSopL2lnO2Z1bmN0aW9uIGkodSl7dmFyIGE9W107cmV0dXJuIHUucmVwbGFjZShuLGZ1bmN0aW9uKGQsRSxwKXt2YXIgTz1FLnRvTG93ZXJDYXNlKCk7Zm9yKHA9aChwKSxPPT0ibSImJnAubGVuZ3RoPjImJihhLnB1c2goW0VdLmNvbmNhdChwLnNwbGljZSgwLDIpKSksTz0ibCIsRT1FPT0ibSI/ImwiOiJMIik7Oyl7aWYocC5sZW5ndGg9PXRbT10pcmV0dXJuIHAudW5zaGlmdChFKSxhLnB1c2gocCk7aWYocC5sZW5ndGg8dFtPXSl0aHJvdyBuZXcgRXJyb3IoIm1hbGZvcm1lZCBwYXRoIGRhdGEiKTthLnB1c2goW0VdLmNvbmNhdChwLnNwbGljZSgwLHRbT10pKSl9fSksYX12YXIgZj0vLT9bMC05XSpcLj9bMC05XSsoPzplWy0rXT9cZCspPy9pZztmdW5jdGlvbiBoKHUpe3ZhciBhPXUubWF0Y2goZik7cmV0dXJuIGE/YS5tYXAoTnVtYmVyKTpbXX19LGZ1bmN0aW9uKGcsZSx0KXtnLmV4cG9ydHM9bjtmdW5jdGlvbiBuKGkpe3ZhciBmPWkubGVuZ3RoO2lmKGY9PT0wKXJldHVybltbXSxbXV07Zm9yKHZhciBoPWlbMF0ubGVuZ3RoLHU9aVswXS5zbGljZSgpLGE9aVswXS5zbGljZSgpLGQ9MTtkPGY7KytkKWZvcih2YXIgRT1pW2RdLHA9MDtwPGg7KytwKXt2YXIgTz1FW3BdO3VbcF09TWF0aC5taW4odVtwXSxPKSxhW3BdPU1hdGgubWF4KGFbcF0sTyl9cmV0dXJuW3UsYV19fSxmdW5jdGlvbihnLGUpe2cuZXhwb3J0cz10O2Z1bmN0aW9uIHQobil7dmFyIGk9MCxmPTAsaD0wLHU9MDtyZXR1cm4gbi5tYXAoZnVuY3Rpb24oYSl7YT1hLnNsaWNlKCk7dmFyIGQ9YVswXSxFPWQudG9VcHBlckNhc2UoKTtpZihkIT1FKXN3aXRjaChhWzBdPUUsZCl7Y2FzZSJhIjphWzZdKz1oLGFbN10rPXU7YnJlYWs7Y2FzZSJ2IjphWzFdKz11O2JyZWFrO2Nhc2UiaCI6YVsxXSs9aDticmVhaztkZWZhdWx0OmZvcih2YXIgcD0xO3A8YS5sZW5ndGg7KWFbcCsrXSs9aCxhW3ArK10rPXV9c3dpdGNoKEUpe2Nhc2UiWiI6aD1pLHU9ZjticmVhaztjYXNlIkgiOmg9YVsxXTticmVhaztjYXNlIlYiOnU9YVsxXTticmVhaztjYXNlIk0iOmg9aT1hWzFdLHU9Zj1hWzJdO2JyZWFrO2RlZmF1bHQ6aD1hW2EubGVuZ3RoLTJdLHU9YVthLmxlbmd0aC0xXX1yZXR1cm4gYX0pfX0sZnVuY3Rpb24oZyxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gaX0pO3ZhciBuPXQoNDUpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBpKHUpe2Zvcih2YXIgYSxkPVtdLEU9MCxwPTAsTz0wLG09MCxiPW51bGwsTT1udWxsLHk9MCxTPTAscz0wLGM9dS5sZW5ndGg7czxjO3MrKyl7dmFyIGw9dVtzXSx2PWxbMF07c3dpdGNoKHYpe2Nhc2UiTSI6Tz1sWzFdLG09bFsyXTticmVhaztjYXNlIkEiOnZhciBUPU9iamVjdChuLmRlZmF1bHQpKHksUyxsWzZdLGxbN10sbFs0XSxsWzVdLGxbMV0sbFsyXSxsWzNdKTtpZighVC5sZW5ndGgpY29udGludWU7VD1ULm1hcCh3PT57Y29uc3RbQixELEksaixWLEosXyxzdF09dztyZXR1cm57eDE6SSx5MTpqLHgyOlYseTI6Six4Ol8seTpzdH19KTtmb3IodmFyIFI9MCxMO1I8VC5sZW5ndGg7UisrKUw9VFtSXSxsPVsiQyIsTC54MSxMLnkxLEwueDIsTC55MixMLngsTC55XSxSPFQubGVuZ3RoLTEmJmQucHVzaChsKTticmVhaztjYXNlIlMiOnZhciBOPXksQT1TOyhhPT0iQyJ8fGE9PSJTIikmJihOKz1OLUUsQSs9QS1wKSxsPVsiQyIsTixBLGxbMV0sbFsyXSxsWzNdLGxbNF1dO2JyZWFrO2Nhc2UiVCI6YT09IlEifHxhPT0iVCI/KGI9eSoyLWIsTT1TKjItTSk6KGI9eSxNPVMpLGw9aCh5LFMsYixNLGxbMV0sbFsyXSk7YnJlYWs7Y2FzZSJRIjpiPWxbMV0sTT1sWzJdLGw9aCh5LFMsbFsxXSxsWzJdLGxbM10sbFs0XSk7YnJlYWs7Y2FzZSJMIjpsPWYoeSxTLGxbMV0sbFsyXSk7YnJlYWs7Y2FzZSJIIjpsPWYoeSxTLGxbMV0sUyk7YnJlYWs7Y2FzZSJWIjpsPWYoeSxTLHksbFsxXSk7YnJlYWs7Y2FzZSJaIjpsPWYoeSxTLE8sbSk7YnJlYWt9YT12LHk9bFtsLmxlbmd0aC0yXSxTPWxbbC5sZW5ndGgtMV0sbC5sZW5ndGg+ND8oRT1sW2wubGVuZ3RoLTRdLHA9bFtsLmxlbmd0aC0zXSk6KEU9eSxwPVMpLGQucHVzaChsKX1yZXR1cm4gZH1mdW5jdGlvbiBmKHUsYSxkLEUpe3JldHVyblsiQyIsdSxhLGQsRSxkLEVdfWZ1bmN0aW9uIGgodSxhLGQsRSxwLE8pe3JldHVyblsiQyIsdS8zKzIvMypkLGEvMysyLzMqRSxwLzMrMi8zKmQsTy8zKzIvMypFLHAsT119fSxmdW5jdGlvbihnLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiB1fSksdCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IG49TWF0aC5QSSoyO2Z1bmN0aW9uIGkoYSxkLEUscCl7Y29uc3QgTz1hKnAtZCpFPDA/LTE6MTtsZXQgbT1hKkUrZCpwO3JldHVybiBtPjEmJihtPTEpLG08LTEmJihtPS0xKSxPKk1hdGguYWNvcyhtKX1mdW5jdGlvbiBmKGEsZCxFLHAsTyxtLGIsTSx5LFMpe2NvbnN0IHM9UyooYS1FKS8yK3kqKGQtcCkvMixjPS15KihhLUUpLzIrUyooZC1wKS8yLGw9YipiLHY9TSpNLFQ9cypzLFI9YypjO2xldCBMPWwqdi1sKlItdipUO0w8MCYmKEw9MCksTC89bCpSK3YqVCxMPU1hdGguc3FydChMKSooTz09PW0/LTE6MSk7Y29uc3QgTj1MKmIvTSpjLEE9TCotTS9iKnMsdz1TKk4teSpBKyhhK0UpLzIsQj15Kk4rUypBKyhkK3ApLzIsRD0ocy1OKS9iLEk9KGMtQSkvTSxqPSgtcy1OKS9iLFY9KC1jLUEpL00sSj1pKDEsMCxELEkpO2xldCBfPWkoRCxJLGosVik7cmV0dXJuIG09PT0wJiZfPjAmJihfLT1uKSxtPT09MSYmXzwwJiYoXys9biksW3csQixKLF9dfWZ1bmN0aW9uIGgoYSxkKXtjb25zdCBFPTEuMzMzMzMzMzMzMzMzMzMzMypNYXRoLnRhbihkLzQpLHA9TWF0aC5jb3MoYSksTz1NYXRoLnNpbihhKSxtPU1hdGguY29zKGErZCksYj1NYXRoLnNpbihhK2QpO3JldHVybltwLE8scC1PKkUsTytwKkUsbStiKkUsYi1tKkUsbSxiXX1mdW5jdGlvbiB1KGEsZCxFLHAsTyxtLGIsTSx5KXtjb25zdCBTPU1hdGguc2luKHkqbi8zNjApLHM9TWF0aC5jb3MoeSpuLzM2MCksYz1zKihhLUUpLzIrUyooZC1wKS8yLGw9LVMqKGEtRSkvMitzKihkLXApLzI7aWYoYz09PTAmJmw9PT0wKXJldHVybltdO2lmKGI9PT0wfHxNPT09MClyZXR1cm5bXTtiPU1hdGguYWJzKGIpLE09TWF0aC5hYnMoTSk7Y29uc3Qgdj1jKmMvKGIqYikrbCpsLyhNKk0pO3Y+MSYmKGIqPU1hdGguc3FydCh2KSxNKj1NYXRoLnNxcnQodikpO2NvbnN0IFQ9ZihhLGQsRSxwLE8sbSxiLE0sUyxzKSxSPVtdO2xldCBMPVRbMl0sTj1UWzNdO2NvbnN0IEE9TWF0aC5tYXgoTWF0aC5jZWlsKE1hdGguYWJzKE4pLyhuLzQpKSwxKTtOLz1BO2ZvcihsZXQgdz0wO3c8QTt3KyspUi5wdXNoKGgoTCxOKSksTCs9TjtyZXR1cm4gUi5tYXAodz0+e2ZvcihsZXQgQj0wO0I8dy5sZW5ndGg7Qis9Mil7bGV0IEQ9d1tCKzBdLEk9d1tCKzFdO0QqPWIsSSo9TTtjb25zdCBqPXMqRC1TKkksVj1TKkQrcypJO3dbQiswXT1qK1RbMF0sd1tCKzFdPVYrVFsxXX1yZXR1cm4gd30pfX0sZnVuY3Rpb24oZyxlLHQpe3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTt2YXIgbj10KDQ3KSx7Y29weTppfT10KDQ5KSxmPXQoNTApO2Z1bmN0aW9uIGgocCxPLG0pe3JldHVybiBwWzBdPU8scFsxXT1tLHB9dmFyIHU9WzAsMF0sYT1bMCwwXSxkPVswLDBdO2Z1bmN0aW9uIEUocCxPLG0sYil7bihtLGgodSxiWzFdLGJbMl0pLGgoYSxiWzNdLGJbNF0pLGgoZCxiWzVdLGJbNl0pLE8scCl9Zy5leHBvcnRzPWZ1bmN0aW9uKE8sbSxiKXt2YXIgTT1bXSx5PVtdLFM9WzAsMF07cmV0dXJuIE8uZm9yRWFjaChmdW5jdGlvbihzLGMsbCl7aWYoc1swXT09PSJNIilpKFMscy5zbGljZSgxKSkseS5sZW5ndGg+MCYmKE0ucHVzaCh5KSx5PVtdKTtlbHNlIGlmKHNbMF09PT0iQyIpRSh5LG0sUyxzKSxoKFMsc1s1XSxzWzZdKTtlbHNlIHRocm93IG5ldyBFcnJvcigiaWxsZWdhbCB0eXBlIGluIFNWRzogIitzWzBdKX0pLHkubGVuZ3RoPjAmJk0ucHVzaCh5KSxNLm1hcChmdW5jdGlvbihzKXtyZXR1cm4gZihzLGJ8fDApfSl9fSxmdW5jdGlvbihnLGUsdCl7Zy5leHBvcnRzPXQoNDgpKCl9LGZ1bmN0aW9uKGcsZSl7ZnVuY3Rpb24gdChpKXtyZXR1cm5baVswXSxpWzFdXX1mdW5jdGlvbiBuKGksZil7cmV0dXJuW2ksZl19Zy5leHBvcnRzPWZ1bmN0aW9uKGYpe2Y9Znx8e307dmFyIGg9dHlwZW9mIGYucmVjdXJzaW9uPT0ibnVtYmVyIj9mLnJlY3Vyc2lvbjo4LHU9dHlwZW9mIGYuZXBzaWxvbj09Im51bWJlciI/Zi5lcHNpbG9uOjExOTIwOTI5ZS0xNCxhPXR5cGVvZiBmLnBhdGhFcHNpbG9uPT0ibnVtYmVyIj9mLnBhdGhFcHNpbG9uOjEsZD10eXBlb2YgZi5hbmdsZUVwc2lsb249PSJudW1iZXIiP2YuYW5nbGVFcHNpbG9uOi4wMSxFPWYuYW5nbGVUb2xlcmFuY2V8fDAscD1mLmN1c3BMaW1pdHx8MDtyZXR1cm4gZnVuY3Rpb24oTSx5LFMscyxjLGwpe2x8fChsPVtdKSxjPXR5cGVvZiBjPT0ibnVtYmVyIj9jOjE7dmFyIHY9YS9jO3JldHVybiB2Kj12LE8oTSx5LFMscyxsLHYpLGx9O2Z1bmN0aW9uIE8oYixNLHksUyxzLGMpe3MucHVzaCh0KGIpKTt2YXIgbD1iWzBdLHY9YlsxXSxUPU1bMF0sUj1NWzFdLEw9eVswXSxOPXlbMV0sQT1TWzBdLHc9U1sxXTttKGwsdixULFIsTCxOLEEsdyxzLGMsMCkscy5wdXNoKHQoUykpfWZ1bmN0aW9uIG0oYixNLHksUyxzLGMsbCx2LFQsUixMKXtpZighKEw+aCkpe3ZhciBOPU1hdGguUEksQT0oYit5KS8yLHc9KE0rUykvMixCPSh5K3MpLzIsRD0oUytjKS8yLEk9KHMrbCkvMixqPShjK3YpLzIsVj0oQStCKS8yLEo9KHcrRCkvMixfPShCK0kpLzIsc3Q9KEQraikvMixHPShWK18pLzIsWT0oSitzdCkvMjtpZihMPjApe3ZhciBydD1sLWIsb3Q9di1NLGF0PU1hdGguYWJzKCh5LWwpKm90LShTLXYpKnJ0KSxodD1NYXRoLmFicygocy1sKSpvdC0oYy12KSpydCksaXQsTXQ7aWYoYXQ+dSYmaHQ+dSl7aWYoKGF0K2h0KSooYXQraHQpPD1SKihydCpydCtvdCpvdCkpe2lmKEU8ZCl7VC5wdXNoKG4oRyxZKSk7cmV0dXJufXZhciBPdD1NYXRoLmF0YW4yKGMtUyxzLXkpO2lmKGl0PU1hdGguYWJzKE90LU1hdGguYXRhbjIoUy1NLHktYikpLE10PU1hdGguYWJzKE1hdGguYXRhbjIodi1jLGwtcyktT3QpLGl0Pj1OJiYoaXQ9MipOLWl0KSxNdD49TiYmKE10PTIqTi1NdCksaXQrTXQ8RSl7VC5wdXNoKG4oRyxZKSk7cmV0dXJufWlmKHAhPT0wKXtpZihpdD5wKXtULnB1c2gobih5LFMpKTtyZXR1cm59aWYoTXQ+cCl7VC5wdXNoKG4ocyxjKSk7cmV0dXJufX19fWVsc2UgaWYoYXQ+dSl7aWYoYXQqYXQ8PVIqKHJ0KnJ0K290Km90KSl7aWYoRTxkKXtULnB1c2gobihHLFkpKTtyZXR1cm59aWYoaXQ9TWF0aC5hYnMoTWF0aC5hdGFuMihjLVMscy15KS1NYXRoLmF0YW4yKFMtTSx5LWIpKSxpdD49TiYmKGl0PTIqTi1pdCksaXQ8RSl7VC5wdXNoKG4oeSxTKSksVC5wdXNoKG4ocyxjKSk7cmV0dXJufWlmKHAhPT0wJiZpdD5wKXtULnB1c2gobih5LFMpKTtyZXR1cm59fX1lbHNlIGlmKGh0PnUpe2lmKGh0Kmh0PD1SKihydCpydCtvdCpvdCkpe2lmKEU8ZCl7VC5wdXNoKG4oRyxZKSk7cmV0dXJufWlmKGl0PU1hdGguYWJzKE1hdGguYXRhbjIodi1jLGwtcyktTWF0aC5hdGFuMihjLVMscy15KSksaXQ+PU4mJihpdD0yKk4taXQpLGl0PEUpe1QucHVzaChuKHksUykpLFQucHVzaChuKHMsYykpO3JldHVybn1pZihwIT09MCYmaXQ+cCl7VC5wdXNoKG4ocyxjKSk7cmV0dXJufX19ZWxzZSBpZihydD1HLShiK2wpLzIsb3Q9WS0oTSt2KS8yLHJ0KnJ0K290Km90PD1SKXtULnB1c2gobihHLFkpKTtyZXR1cm59fW0oYixNLEEsdyxWLEosRyxZLFQsUixMKzEpLG0oRyxZLF8sc3QsSSxqLGwsdixULFIsTCsxKX19fX0sZnVuY3Rpb24oZyxlLHQpe3QucihlKSx0LmQoZSwiY3JlYXRlIixmdW5jdGlvbigpe3JldHVybiBmfSksdC5kKGUsImNsb25lIixmdW5jdGlvbigpe3JldHVybiBpfSksdC5kKGUsImNvcHkiLGZ1bmN0aW9uKCl7cmV0dXJuIGh9KSx0LmQoZSwic2NhbGVBbmRBZGQiLGZ1bmN0aW9uKCl7cmV0dXJuIHV9KSx0LmQoZSwiZG90IixmdW5jdGlvbigpe3JldHVybiBhfSksdC5kKGUsInJvdGF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gZH0pLHQuZChlLCJjcm9zcyIsZnVuY3Rpb24oKXtyZXR1cm4gRX0pLHQuZChlLCJzdWIiLGZ1bmN0aW9uKCl7cmV0dXJuIHB9KSx0LmQoZSwiYWRkIixmdW5jdGlvbigpe3JldHVybiBPfSksdC5kKGUsImNvbXB1dGVNaXRlciIsZnVuY3Rpb24oKXtyZXR1cm4geX0pLHQuZChlLCJub3JtYWwiLGZ1bmN0aW9uKCl7cmV0dXJuIFN9KSx0LmQoZSwiZGlyZWN0aW9uIixmdW5jdGlvbigpe3JldHVybiBzfSk7dmFyIG49dCgxKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gaShjKXtyZXR1cm5bY1swXSxjWzFdXX1mdW5jdGlvbiBmKCl7cmV0dXJuWzAsMF19Y29uc3QgaD1uLnZlYzIuY29weSx1PW4udmVjMi5zY2FsZUFuZEFkZCxhPW4udmVjMi5kb3QsZD1uLnZlYzIucm90YXRlLEU9bi52ZWMyLmNyb3NzLHA9bi52ZWMyLnN1YixPPW4udmVjMi5hZGQsbT1uLnZlYzIubm9ybWFsaXplLGI9bi52ZWMyLnNldCxNPWYoKTtmdW5jdGlvbiB5KGMsbCx2LFQsUil7TyhjLHYsVCksbShjLGMpLGIobCwtY1sxXSxjWzBdKSxiKE0sLXZbMV0sdlswXSk7Y29uc3QgTD1SL2EobCxNKTtyZXR1cm4gTWF0aC5hYnMoTCl9ZnVuY3Rpb24gUyhjLGwpe3JldHVybiBiKGMsLWxbMV0sbFswXSksY31mdW5jdGlvbiBzKGMsbCx2KXtyZXR1cm4gcChjLGwsdiksbShjLGMpLGN9fSxmdW5jdGlvbihnLGUsdCl7dmFyIG49dCg1MSksaT10KDUyKTtnLmV4cG9ydHM9ZnVuY3Rpb24oaCx1KXtyZXR1cm4gaD1uKGgsdSksaD1pKGgsdSksaH0sZy5leHBvcnRzLnJhZGlhbERpc3RhbmNlPW4sZy5leHBvcnRzLmRvdWdsYXNQZXVja2VyPWl9LGZ1bmN0aW9uKGcsZSl7ZnVuY3Rpb24gdChuLGkpe3ZhciBmPW5bMF0taVswXSxoPW5bMV0taVsxXTtyZXR1cm4gZipmK2gqaH1nLmV4cG9ydHM9ZnVuY3Rpb24oaSxmKXtpZihpLmxlbmd0aDw9MSlyZXR1cm4gaTtmPXR5cGVvZiBmPT0ibnVtYmVyIj9mOjE7Zm9yKHZhciBoPWYqZix1PWlbMF0sYT1bdV0sZCxFPTEscD1pLmxlbmd0aDtFPHA7RSsrKWQ9aVtFXSx0KGQsdSk+aCYmKGEucHVzaChkKSx1PWQpO3JldHVybiB1IT09ZCYmYS5wdXNoKGQpLGF9fSxmdW5jdGlvbihnLGUpe2Z1bmN0aW9uIHQoaSxmLGgpe3ZhciB1PWZbMF0sYT1mWzFdLGQ9aFswXS11LEU9aFsxXS1hO2lmKGQhPT0wfHxFIT09MCl7dmFyIHA9KChpWzBdLXUpKmQrKGlbMV0tYSkqRSkvKGQqZCtFKkUpO3A+MT8odT1oWzBdLGE9aFsxXSk6cD4wJiYodSs9ZCpwLGErPUUqcCl9cmV0dXJuIGQ9aVswXS11LEU9aVsxXS1hLGQqZCtFKkV9ZnVuY3Rpb24gbihpLGYsaCx1LGEpe2Zvcih2YXIgZD11LEUscD1mKzE7cDxoO3ArKyl7dmFyIE89dChpW3BdLGlbZl0saVtoXSk7Tz5kJiYoRT1wLGQ9Tyl9ZD51JiYoRS1mPjEmJm4oaSxmLEUsdSxhKSxhLnB1c2goaVtFXSksaC1FPjEmJm4oaSxFLGgsdSxhKSl9Zy5leHBvcnRzPWZ1bmN0aW9uKGYsaCl7aWYoZi5sZW5ndGg8PTEpcmV0dXJuIGY7aD10eXBlb2YgaD09Im51bWJlciI/aDoxO3ZhciB1PWgqaCxhPWYubGVuZ3RoLTEsZD1bZlswXV07cmV0dXJuIG4oZiwwLGEsdSxkKSxkLnB1c2goZlthXSksZH19LGZ1bmN0aW9uKGcsZSx0KXt0LnIoZSksdC5kKGUsImdldFRvdGFsTGVuZ3RoIixmdW5jdGlvbigpe3JldHVybiBpfSksdC5kKGUsImdldFBvaW50QXRMZW5ndGgiLGZ1bmN0aW9uKCl7cmV0dXJuIGh9KSx0LmQoZSwiZ2V0RGFzaENvbnRvdXJzIixmdW5jdGlvbigpe3JldHVybiB1fSk7dmFyIG49dCg1NCk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIGkoYSl7aWYoYS50b3RhbExlbmd0aCE9bnVsbClyZXR1cm4gYS50b3RhbExlbmd0aDtsZXQgZD0wO3JldHVybiBhLmZvckVhY2goRT0+e2xldCBwPUVbMF07Zm9yKGxldCBPPTE7TzxFLmxlbmd0aDtPKyspe2NvbnN0IG09RVtPXTtkKz1PYmplY3Qobi5kaXN0YW5jZSkocCxtKSxwPW19fSksYS50b3RhbExlbmd0aD1kLGR9ZnVuY3Rpb24gZihhLGQsRT0hMCl7aWYoZD1OdW1iZXIoZCksIU51bWJlci5pc0Zpbml0ZShkKSl0aHJvdyBuZXcgVHlwZUVycm9yKCJGYWlsZWQgdG8gZXhlY3V0ZSAnZ2V0UG9pbnRBdExlbmd0aCcgb24gZmlndXJlOiBUaGUgcHJvdmlkZWQgZmxvYXQgdmFsdWUgaXMgbm9uLWZpbml0ZS4iKTtpZihkPD0wKXRocm93IG5ldyBUeXBlRXJyb3IoIkxlbmd0aCBtdXN0ID4gMCIpO2NvbnN0IHA9aShhKTtpZihkPj1wKXtjb25zdCBtPWFbYS5sZW5ndGgtMV0sYj1tW20ubGVuZ3RoLTJdLE09bVttLmxlbmd0aC0xXSx5PU1hdGguYXRhbjIoTVsxXS1iWzFdLE1bMF0tYlswXSk7cmV0dXJue2N1cnJlbnQ6YS5tYXAoUz0+Wy4uLlNdKSxwb2ludDp7eDpNWzBdLHk6TVsxXSxhbmdsZTp5fX19Y29uc3QgTz1bXTtmb3IobGV0IG09MDttPGEubGVuZ3RoO20rKyl7T1ttXT1bXTtjb25zdCBiPWFbbV07bGV0IE09YlswXTtmb3IobGV0IHk9MTt5PGIubGVuZ3RoO3krKyl7Y29uc3QgUz1iW3ldLHM9T2JqZWN0KG4uZGlzdGFuY2UpKE0sUyk7aWYoZDxzKXtjb25zdCBjPWQvcyxsPU1hdGguYXRhbjIoU1sxXS1NWzFdLFNbMF0tTVswXSksdj17eDpNWzBdKigxLWMpK1NbMF0qYyx5Ok1bMV0qKDEtYykrU1sxXSpjLGFuZ2xlOmx9O2lmKE9bbV0ucHVzaChNKSxkPjAmJk9bbV0ucHVzaChbdi54LHYueV0pLCFFKXJldHVybntjdXJyZW50Ok8scG9pbnQ6dn07Y29uc3QgVD1bXSxSPW07Zm9yKDttPGEubGVuZ3RoO20rKyl7Zm9yKFRbbS1SXT1bXSxtPT09UiYmVFswXS5wdXNoKFt2Lngsdi55XSk7eTxiLmxlbmd0aDt5KyspVFttLVJdLnB1c2goYlt5XSk7eT0wfXJldHVybntjdXJyZW50Ok8scG9pbnQ6dixyZXN0OlR9fWQtPXMsT1ttXS5wdXNoKE0pLE09U319fWZ1bmN0aW9uIGgoYSxkKXtpZihkPU51bWJlcihkKSwhTnVtYmVyLmlzRmluaXRlKGQpKXRocm93IG5ldyBUeXBlRXJyb3IoIkZhaWxlZCB0byBleGVjdXRlICdnZXRQb2ludEF0TGVuZ3RoJyBvbiBmaWd1cmU6IFRoZSBwcm92aWRlZCBmbG9hdCB2YWx1ZSBpcyBub24tZmluaXRlLiIpO2lmKGEubGVuZ3RoPD0wKXJldHVybnt4OjAseTowLGFuZ2xlOjB9O2lmKGQ8PTApe2NvbnN0IEU9YVswXVswXSxwPWFbMF1bMV0sTz1NYXRoLmF0YW4yKHBbMV0tRVsxXSxwWzBdLUVbMF0pO3JldHVybnt4OkVbMF0seTpFWzFdLGFuZ2xlOk99fXJldHVybiBmKGEsZCwhMSkucG9pbnR9ZnVuY3Rpb24gdShhLGQsRSl7bGV0IHA9MCxPPWRbMF0sbT1hO2NvbnN0IGI9W10sTT1kLmxlbmd0aDtpZihFPjApe2RvIEUtPWRbcCVNXSxwKys7d2hpbGUoRT4wKTtFPDAmJihPPS1FLHAtLSl9ZWxzZSBpZihFPDApe3A9LTE7ZG8gRSs9ZFtwJU0rTS0xXSxwLS07d2hpbGUoRTwwKTtFPj0wJiYocCsrLE89ZFtwJU0rTS0xXS1FKX1kb3tjb25zdCB5PWYobSxPKTttPXkucmVzdCwrK3AlMiYmYi5wdXNoKC4uLnkuY3VycmVudCk7bGV0IFM9cCVNO1M8MCYmKFMrPU0pLE89ZFtTXX13aGlsZShtKTtyZXR1cm4gYn19LGZ1bmN0aW9uKGcsZSx0KXt0LnIoZSksdC5kKGUsIm5vcm1hbGl6ZSIsZnVuY3Rpb24oKXtyZXR1cm4gbn0pLHQuZChlLCJkaXN0YW5jZSIsZnVuY3Rpb24oKXtyZXR1cm4gaX0pLHQoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBuKFtmLGgsdV0sYSxkLEUpe3JldHVybiBmPWYqMi9hLTEsaD0xLWgqMi9kLE51bWJlci5pc0Zpbml0ZShFKT8odT11KjIvRS0xLFtmLGgsdV0pOltmLGhdfWZ1bmN0aW9uIGkoW2YsaCx1PTBdLFthLGQsRT0wXSl7cmV0dXJuIE1hdGguaHlwb3QoYS1mLGQtaCxFLXUpfX0sZnVuY3Rpb24oZyxlLHQpe3QucihlKSx0LmQoZSwiZ2V0UG9pbnQiLGZ1bmN0aW9uKCl7cmV0dXJuIGl9KSx0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3Qgbj1NYXRoLlBJKjI7ZnVuY3Rpb24gaShmLGgsdSxhLGQpe2QlPW4sZDwwJiYoZCs9bik7Y29uc3QgRT1NYXRoLnRhbihkKTtpZihNYXRoLmFicyhFKTwxZTUpe2NvbnN0IHA9aC1FKmYsTz0xL3UqKjIrRSoqMi9hKioyO2xldCBtPS0xOyhkPD1NYXRoLlBJLzJ8fGQ+MypNYXRoLlBJLzIpJiYobT0xKTtjb25zdCBiPW0qTWF0aC5zcXJ0KDEvTykrZixNPUUqYitwO3JldHVybltiLE1dfXJldHVybiBkPE1hdGguUEk/W2YsaCthXTpbZixoLWFdfX0sZnVuY3Rpb24oZyxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gUX0pO3ZhciBuPXQoMSksaT10KDQyKSxmPXQubihpKSxoPXQoNTcpLHU9dCgyOCksYT10KDI0KSxkPXQoMzApLEU9dCg1OSkscD10KDUzKSxPPXQoNjApLG09dC5uKE8pLGI9dCg0NiksTT10Lm4oYikseT10KDMxKSxTPXQoNDApLHM9dCgyMSk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIGModHQsRil7aWYodHQ9PW51bGwpcmV0dXJue307dmFyIEg9bCh0dCxGKSx4LFA7aWYoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyl7dmFyIFc9T2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyh0dCk7Zm9yKFA9MDtQPFcubGVuZ3RoO1ArKyl4PVdbUF0sIShGLmluZGV4T2YoeCk+PTApJiZPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodHQseCkmJihIW3hdPXR0W3hdKX1yZXR1cm4gSH1mdW5jdGlvbiBsKHR0LEYpe2lmKHR0PT1udWxsKXJldHVybnt9O3ZhciBIPXt9LHg9T2JqZWN0LmtleXModHQpLFAsVztmb3IoVz0wO1c8eC5sZW5ndGg7VysrKVA9eFtXXSwhKEYuaW5kZXhPZihQKT49MCkmJihIW1BdPXR0W1BdKTtyZXR1cm4gSH1jb25zdCB2PVN5bWJvbCgibWVzaCIpLFQ9U3ltYm9sKCJjb250b3VycyIpLFI9U3ltYm9sKCJzdHJva2UiKSxMPVN5bWJvbCgiZmlsbCIpLE49U3ltYm9sKCJzdHJva2VDb2xvciIpLEE9U3ltYm9sKCJmaWxsQ29sb3IiKSx3PVN5bWJvbCgidHJhbnNmb3JtIiksQj1TeW1ib2woImludmVydFRyYW5zZm9ybSIpLEQ9U3ltYm9sKCJ1bmlmb3JtcyIpLEk9U3ltYm9sKCJ0ZXhPcHRpb25zIiksaj1TeW1ib2woImJsZW5kIiksVj1TeW1ib2woImFwcGx5VGV4dHVyZSIpLEo9U3ltYm9sKCJhcHBseVRyYW5zZm9ybSIpLF89U3ltYm9sKCJhcHBseUdyYWRpZW50VHJhbnNmb3JtIiksc3Q9U3ltYm9sKCJhcHBseVByb2dyYW0iKSxHPVN5bWJvbCgiZ3JhZGllbnQiKSxZPVN5bWJvbCgiZmlsdGVyIikscnQ9U3ltYm9sKCJvcGFjaXR5Iiksb3Q9U3ltYm9sKCJwcm9ncmFtIiksYXQ9U3ltYm9sKCJhdHRyaWJ1dGVzIiksaHQ9U3ltYm9sKCJwYXNzIiksaXQ9U3ltYm9sKCJjbGlwQ29udGV4dCIpLE10PVN5bWJvbCgiYXBwbHlDbGlwUGF0aCIpO2Z1bmN0aW9uIE90KHR0LEYpe2NvbnN0W0gseF09W3R0WzFdWzBdLXR0WzBdWzBdLHR0WzFdWzFdLXR0WzBdWzFdXSxQPVtdO2ZvcihsZXQgVz0wO1c8Ri5sZW5ndGg7VysrKXtjb25zdCBLPUZbV10sWj1bKEtbMF0tdHRbMF1bMF0pL0gsMS0oS1sxXS10dFswXVsxXSkveF07UC5wdXNoKFopfXJldHVybiBQfWZ1bmN0aW9uIFUoW3R0LEZdLFtILHgsUCxXXSx7c2NhbGU6S30pe3JldHVybiBLfHwodHQvPVAsRj0xLUYvVyx0dC09SCxGKz14KSxbdHQsRiwwXX1mdW5jdGlvbiAkKHR0LEYsSCl7Y29uc3QgeD1NKCkodHQsRixIKTtyZXR1cm4geC5wYXRoPXR0LHguc2ltcGxpZnk9SCx4LnNjYWxlPUYseH1jbGFzcyBRe2NvbnN0cnVjdG9yKEYpe3RoaXNbUl09bnVsbCx0aGlzW0xdPW51bGwsdGhpc1t3XT1bMSwwLDAsMSwwLDBdLHRoaXNbcnRdPTEsdGhpc1tEXT17fSx0aGlzW1ldPVtdLHRoaXNbal09bnVsbCx0aGlzW0ldPXt9LHRoaXMuY29udG91cnM9Ri5jb250b3Vycyx0aGlzW290XT1udWxsLHRoaXNbYXRdPXt9LHRoaXNbaHRdPVtdfWdldCBjb250b3Vycygpe3JldHVybiB0aGlzW1RdfXNldCBjb250b3VycyhGKXt0aGlzW3ZdPW51bGwsdGhpc1tUXT1GO2NvbnN0IEg9Ri5zY2FsZTt0aGlzLnRyYW5zZm9ybVNjYWxlL0g+MS41JiZ0aGlzLmFjY3VyYXRlKHRoaXMudHJhbnNmb3JtU2NhbGUpfXNldFByb2dyYW0oRil7dGhpc1tvdF09Rix0aGlzW3ZdJiZ0aGlzW3N0XShGKX1nZXQgcHJvZ3JhbSgpe3JldHVybiB0aGlzW290XX1zZXRBdHRyaWJ1dGUoRixIKXtIPT1udWxsP2RlbGV0ZSB0aGlzW2F0XVtGXTp0aGlzW2F0XVtGXT1IfWdldE9wYWNpdHkoKXtyZXR1cm4gdGhpc1tydF19c2V0T3BhY2l0eShGKXtpZihGPDB8fEY+MSl0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIG9wYWNpdHkgdmFsdWUuIik7dGhpc1t2XSYmdGhpc1t2XS5wb3NpdGlvbnMuZm9yRWFjaChIPT57SFsyXT0xL0hbMl0+MD9GOi1GfSksdGhpc1tydF09Rn1zZXRDbGlwUGF0aChGKXt0aGlzLmNsaXBQYXRoPUYsdGhpc1tEXS51X2NsaXBTYW1wbGVyJiZ0aGlzW0RdLnVfY2xpcFNhbXBsZXIuZGVsZXRlKCksdGhpcy5zZXRVbmlmb3Jtcyh7dV9jbGlwU2FtcGxlcjpudWxsfSksdGhpc1t2XSYmZGVsZXRlIHRoaXNbdl0uYXR0cmlidXRlcy5hX2NsaXBVVixGJiZ0aGlzW3ZdJiZ0aGlzW010XSgpfVtNdF0oKXtpZih0aGlzLmNsaXBQYXRoKXt0aGlzW2l0XXx8KHRoaXNbaXRdPXMuZGVmYXVsdC5jcmVhdGVDYW52YXMoMSwxKSk7Y29uc3RbW0YsSF0sW3gsUF1dPXRoaXMuYm91bmRpbmdCb3g7eCYmUCYmKHRoaXNbaXRdLndpZHRoPXgtRix0aGlzW2l0XS5oZWlnaHQ9UC1IKTtjb25zdCBXPXRoaXNbaXRdLmdldENvbnRleHQoIjJkIiksSz1uZXcgUGF0aDJEKHRoaXMuY2xpcFBhdGgpO1cuY2xlYXJSZWN0KDAsMCx0aGlzW2l0XS53aWR0aCx0aGlzW2l0XS5oZWlnaHQpLFcuc2F2ZSgpLFcudHJhbnNsYXRlKC1GLC1IKSxXLmZpbGxTdHlsZT0id2hpdGUiLFcuZmlsbChLKSxXLnJlc3RvcmUoKSx0aGlzW3ZdLmNsaXBQYXRoPXRoaXNbaXRdO2NvbnN0IFo9T3QodGhpcy5ib3VuZGluZ0JveCx0aGlzW3ZdLnBvc2l0aW9uMCk7dGhpc1t2XS5hdHRyaWJ1dGVzLmFfY2xpcFVWPVp9fWdldFBvaW50QXRMZW5ndGgoRil7cmV0dXJuIE9iamVjdChwLmdldFBvaW50QXRMZW5ndGgpKHRoaXNbVF0sRil9Z2V0VG90YWxMZW5ndGgoKXtyZXR1cm4gT2JqZWN0KHAuZ2V0VG90YWxMZW5ndGgpKHRoaXNbVF0pfWdldCBibGVuZCgpe3JldHVybiB0aGlzW2pdPT1udWxsPyJhdXRvIjp0aGlzW2pdfXNldCBibGVuZChGKXt0aGlzW2pdPUYsdGhpc1t2XSYmKHRoaXNbdl0uZW5hYmxlQmxlbmQ9dGhpcy5lbmFibGVCbGVuZCl9Z2V0IGJvdW5kaW5nQm94KCl7aWYodGhpc1t2XSYmdGhpc1t2XS5ib3VuZGluZ0JveClyZXR1cm4gdGhpc1t2XS5ib3VuZGluZ0JveDtjb25zdCBGPXRoaXMubWVzaERhdGE7aWYoRil7Y29uc3QgSD1GLnBvc2l0aW9uMDtpZihILmxlbmd0aClGLmJvdW5kaW5nQm94PWYoKShIKTtlbHNlIHJldHVybltbMCwwXSxbMCwwXV07cmV0dXJuIEYuYm91bmRpbmdCb3h9cmV0dXJuW1swLDBdLFswLDBdXX1nZXQgYm91bmRpbmdDZW50ZXIoKXtjb25zdCBGPXRoaXMuYm91bmRpbmdCb3g7cmV0dXJuIEY/Wy41KihGWzBdWzBdK0ZbMV1bMF0pLC41KihGWzBdWzFdK0ZbMV1bMV0pXTpbMCwwXX1nZXQgZmlsbFJ1bGUoKXtyZXR1cm4gdGhpc1tMXT90aGlzW0xdLnJ1bGU6Im5vbnplcm8ifWdldCBsaW5lV2lkdGgoKXtyZXR1cm4gdGhpc1tSXT90aGlzW1JdLmxpbmVXaWR0aDowfWdldCBsaW5lQ2FwKCl7cmV0dXJuIHRoaXNbUl0/dGhpc1tSXS5saW5lQ2FwOiIifWdldCBsaW5lSm9pbigpe3JldHVybiB0aGlzW1JdP3RoaXNbUl0ubGluZUpvaW46IiJ9Z2V0IG1pdGVyTGltaXQoKXtyZXR1cm4gdGhpc1tSXT90aGlzW1JdLm1pdGVyTGltaXQ6MH1nZXQgc3Ryb2tlU3R5bGUoKXtyZXR1cm4gdGhpc1tOXSYmdGhpc1tOXVszXSE9PTA/T2JqZWN0KGEuZGVmYXVsdCkodGhpc1tOXSk6IiJ9Z2V0IGxpbmVEYXNoKCl7cmV0dXJuIHRoaXNbUl0/dGhpc1tSXS5saW5lRGFzaDpudWxsfWdldCBsaW5lRGFzaE9mZnNldCgpe3JldHVybiB0aGlzW1JdP3RoaXNbUl0ubGluZURhc2hPZmZzZXQ6MH1nZXQgZmlsbFN0eWxlKCl7cmV0dXJuIHRoaXNbQV0mJnRoaXNbQV1bM10hPT0wP09iamVjdChhLmRlZmF1bHQpKHRoaXNbQV0pOiIifWdldCBncmFkaWVudCgpe3JldHVybiB0aGlzW0ddfWdldCB0ZXh0dXJlKCl7cmV0dXJuIHRoaXNbRF0udV90ZXhTYW1wbGVyP3tpbWFnZTp0aGlzW0RdLnVfdGV4U2FtcGxlci5faW1nLG9wdGlvbnM6dGhpc1tJXX06bnVsbH1nZXQgZW5hYmxlQmxlbmQoKXtyZXR1cm4gdGhpc1tqXT09PSEwfHx0aGlzW2pdPT09ITE/dGhpc1tqXTp0aGlzW3J0XTwxfHx0aGlzW05dIT1udWxsJiZ0aGlzW05dWzNdPDF8fHRoaXNbQV0hPW51bGwmJnRoaXNbQV1bM108MXx8dGhpc1tEXS51X2NvbG9yTWF0cml4IT1udWxsJiZ0aGlzW0RdLnVfY29sb3JNYXRyaXhbMThdPDF8fHRoaXNbRF0udV9yYWRpYWxHcmFkaWVudFZlY3RvciE9bnVsbHx8dGhpcy5iZWZvcmVSZW5kZXJ8fHRoaXMuYWZ0ZXJSZW5kZXJ9Z2V0IGZpbHRlckNhbnZhcygpe3JldHVybi9ibHVyfGRyb3Atc2hhZG93fHVybC8udGVzdCh0aGlzLmZpbHRlcil9Z2V0IGZpbHRlcigpe3JldHVybiB0aGlzW1ldLmpvaW4oIiAiKX1nZXQgdHJhbnNmb3JtTWF0cml4KCl7cmV0dXJuIHRoaXNbd119Z2V0IGludmVydE1hdHJpeCgpe2lmKCF0aGlzW0JdKXtjb25zdCBGPW4ubWF0MmQuaW52ZXJ0KEFycmF5Lm9mKDAsMCwwLDAsMCwwKSx0aGlzW3ddKTt0aGlzW0JdPUZ9cmV0dXJuIHRoaXNbQl19Z2V0IHRyYW5zZm9ybVNjYWxlKCl7Y29uc3QgRj10aGlzW3ddO3JldHVybiBNYXRoLm1heChNYXRoLmh5cG90KEZbMF0sRlsxXSksTWF0aC5oeXBvdChGWzJdLEZbM10pKX1nZXQgdW5pZm9ybXMoKXtyZXR1cm4gdGhpc1tEXX1nZXQgcGFzcygpe3JldHVybiB0aGlzW2h0XX1bc3RdKEYpe2NvbnN0IEg9dGhpc1thdF0seD10aGlzW3ZdLnBvc2l0aW9uMCxQPU9iamVjdC5lbnRyaWVzKEYuX2F0dHJpYnV0ZSk7Zm9yKGxldCBXPTA7VzxQLmxlbmd0aDtXKyspe2NvbnN0W0ssWl09UFtXXTtpZihLIT09ImFfY29sb3IiJiZLIT09ImFfc291cmNlUmVjdCImJlohPT0iaWdub3JlZCIpe2NvbnN0IGs9SFtLXTtpZihLPT09InV2IiYmIWspe2NvbnN0IG50PXRoaXNbdl0uYm91bmRpbmdCb3h8fGYoKSh4KTt0aGlzW3ZdLmF0dHJpYnV0ZXNbS109T3QobnQseCl9ZWxzZXt0aGlzW3ZdLmF0dHJpYnV0ZXNbS109W107Zm9yKGxldCBudD0wO250PHgubGVuZ3RoO250Kyspe2NvbnN0IHV0PXhbbnRdO3RoaXNbdl0uYXR0cmlidXRlc1tLXS5wdXNoKGs/ayh1dCxXLHgpOkFycmF5KFouc2l6ZSkuZmlsbCgwKSl9fX19fWdldCBtZXNoRGF0YSgpe2lmKHRoaXMuX3VwZGF0ZU1hdHJpeCYmdGhpcy50cmFuc2Zvcm1TY2FsZS90aGlzLmNvbnRvdXJzLnNjYWxlPjEuNSYmdGhpcy5hY2N1cmF0ZSh0aGlzLnRyYW5zZm9ybVNjYWxlKSwhdGhpc1t2XSl7IXRoaXNbTF0mJiF0aGlzW1JdJiZ0aGlzLnNldEZpbGwoKTtjb25zdCBGPXRoaXNbVF0sSD17fTtpZihGJiZGLmxlbmd0aCl7aWYodGhpc1tMXSl0cnl7Y29uc3QgVz1tKCkoRix0aGlzW0xdKTtXLnBvc2l0aW9ucz1XLnBvc2l0aW9ucy5tYXAoSz0+KEsucHVzaCh0aGlzW3J0XSksSykpLFcuYXR0cmlidXRlcz17YV9jb2xvcjpBcnJheS5mcm9tKHtsZW5ndGg6Vy5wb3NpdGlvbnMubGVuZ3RofSkubWFwKCgpPT50aGlzW0FdLm1hcChLPT5NYXRoLnJvdW5kKDI1NSpLKSkpfSxILmZpbGw9V31jYXRjaHt9aWYodGhpc1tSXSl7Y29uc3QgVz10aGlzW1JdLmxpbmVEYXNoO2xldCBLPUY7aWYoVyl7Y29uc3Qgaz10aGlzW1JdLmxpbmVEYXNoT2Zmc2V0O0s9T2JqZWN0KHAuZ2V0RGFzaENvbnRvdXJzKShGLFcsayl9Y29uc3QgWj1LLm1hcCgoayxudCk9Pntjb25zdCB1dD1rLmxlbmd0aD4xJiZuLnZlYzIuZXF1YWxzKGtbMF0sa1trLmxlbmd0aC0xXSksY3Q9dGhpc1tSXS5idWlsZChrLHV0KTtyZXR1cm4gbSgpKFtjdF0pfSk7Wi5mb3JFYWNoKGs9PntrLnBvc2l0aW9ucz1rLnBvc2l0aW9ucy5tYXAobnQ9PihudC5wdXNoKC10aGlzW3J0XSksbnQpKSxrLmF0dHJpYnV0ZXM9e2FfY29sb3I6QXJyYXkuZnJvbSh7bGVuZ3RoOmsucG9zaXRpb25zLmxlbmd0aH0pLm1hcCgoKT0+dGhpc1tOXS5tYXAobnQ9Pk1hdGgucm91bmQoMjU1Km50KSkpfX0pLEguc3Ryb2tlPU9iamVjdCh1LmRlZmF1bHQpKFopfX1jb25zdCB4PU9iamVjdCh1LmRlZmF1bHQpKFtILmZpbGwsSC5zdHJva2VdKTt4LmZpbGxQb2ludENvdW50PUguZmlsbD9ILmZpbGwucG9zaXRpb25zLmxlbmd0aDowLHguZW5hYmxlQmxlbmQ9dGhpcy5lbmFibGVCbGVuZCx4LnBvc2l0aW9uMD14LnBvc2l0aW9ucy5tYXAoKFtXLEssWl0pPT5bVyxLLFpdKSx4LnVuaWZvcm1zPXRoaXNbRF0sdGhpc1t2XT14LHRoaXNbRF0udV90ZXhTYW1wbGVyJiZ0aGlzW1ZdKHgsdGhpc1tJXSk7Y29uc3QgUD10aGlzW3ddO09iamVjdChFLmlzVW5pdFRyYW5zZm9ybSkoUCl8fCh0aGlzW0pdKHgsUCksdGhpc1tEXS51X3JhZGlhbEdyYWRpZW50VmVjdG9yJiZ0aGlzW19dKCkpLHRoaXMuY2xpcFBhdGgmJnRoaXNbTXRdKCksdGhpc1tvdF0mJnRoaXNbc3RdKHRoaXNbb3RdKX1yZXR1cm4gdGhpcy5fdXBkYXRlTWF0cml4JiYodGhpc1t2XS5tYXRyaXg9dGhpc1t3XSx0aGlzW0pdKHRoaXNbdl0sdGhpc1t3XSksdGhpc1tEXS51X3JhZGlhbEdyYWRpZW50VmVjdG9yJiZ0aGlzW19dKCkpLHRoaXNbdl19W0pdKEYsSCl7Y29uc3R7cG9zaXRpb25zOngscG9zaXRpb24wOlB9PUY7Zm9yKGxldCBXPTA7Vzx4Lmxlbmd0aDtXKyspe2NvbnN0W0ssWl09UFtXXSxrPXhbV107a1swXT1LKkhbMF0rWipIWzJdK0hbNF0sa1sxXT1LKkhbMV0rWipIWzNdK0hbNV19dGhpcy5fdXBkYXRlTWF0cml4PSExfVtfXSgpe2NvbnN0IEY9dGhpc1t3XSxIPVsuLi50aGlzLl9yYWRpYWxHcmFkaWVudFZlY3Rvcl07aWYoSCl7Y29uc3RbeCxQLCxXLEtdPUg7SFswXT14KkZbMF0rUCpGWzJdK0ZbNF0sSFsxXT14KkZbMV0rUCpGWzNdK0ZbNV0sSFszXT1XKkZbMF0rSypGWzJdK0ZbNF0sSFs0XT1XKkZbMV0rSypGWzNdK0ZbNV0sdGhpc1tEXS51X3JhZGlhbEdyYWRpZW50VmVjdG9yPUh9fVtWXShGLEgpe2Z1bmN0aW9uIHgobnQsdXQpe3JldHVybiBudD09bnVsbCYmdXQ9PW51bGw/ITA6bnQ9PW51bGx8fHV0PT1udWxsPyExOm50WzBdPT09dXRbMF0mJm50WzFdPT09dXRbMV0mJm50WzJdPT09dXRbMl0mJm50WzNdPT09dXRbM119Y29uc3QgUD10aGlzW0RdLnVfdGV4U2FtcGxlcjtpZighUClyZXR1cm47Y29uc3R7d2lkdGg6VyxoZWlnaHQ6S309UC5faW1nLFo9SC5zcmNSZWN0O2xldCBrPUgucmVjdHx8WzAsMF07aWYoSC5yb3RhdGVkJiYoaz1bLWtbMV0sa1swXSxrWzNdLGtbMl1dKSxrWzJdPT1udWxsJiYoa1syXT1aP1pbMl06Vyksa1szXT09bnVsbCYmKGtbM109Wj9aWzNdOkspLEguaGlkZGVuKUYudGV4dHVyZUNvb3JkPUYucG9zaXRpb25zLm1hcCgoKT0+Wy0xLC0xLC0xXSk7ZWxzZSBpZighRi50ZXh0dXJlQ29vcmR8fCF4KHRoaXNbSV0ucmVjdCxILnJlY3QpfHx0aGlzW0ldLmhpZGRlbiE9PUguaGlkZGVufHx0aGlzW0ldLnJvdGF0ZWQhPT1ILnJvdGF0ZWQpe2xldCBudD1udWxsO0gucm90YXRlZCYmKG50PW4ubWF0MmQucm90YXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxuLm1hdDJkLmZyb21WYWx1ZXMoMSwwLDAsMSwwLDApLC41Kk1hdGguUEkpLG50PW4ubWF0MmQudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxudCxbMCwta1syXV0pKSxGLnRleHR1cmVDb29yZD1GLnBvc2l0aW9uMC5tYXAoKFt1dCxjdCxwdF0pPT57aWYoMS9wdD4wKXtpZihILnJvdGF0ZWQpe2NvbnN0IGd0PXV0Km50WzBdK2N0Km50WzJdK250WzRdLGR0PXV0Km50WzFdK2N0Km50WzNdK250WzVdO1t1dCxjdF09W2d0LGR0XX1jb25zdCB4dD1VKFt1dCxjdF0sW2tbMF0va1syXSxrWzFdL2tbM10sa1syXSxrWzNdXSxIKTtyZXR1cm4gSC5yZXBlYXQmJih4dFsyXT0xKSx4dH1yZXR1cm5bLTEsLTEsLTFdfSl9aWYoWil7Y29uc3QgbnQ9W1pbMF0vVyxaWzFdL0ssWlsyXS9XLFpbM10vS107Ri5hdHRyaWJ1dGVzLmFfc291cmNlUmVjdD1GLnBvc2l0aW9ucy5tYXAoKCk9PlsuLi5udF0pfWVsc2UgRi5hdHRyaWJ1dGVzLmFfc291cmNlUmVjdD1GLnBvc2l0aW9ucy5tYXAoKCk9PlswLDAsMCwwXSl9YWNjdXJhdGUoRil7aWYoIXRoaXMuY29udG91cnMpcmV0dXJuO2lmKHRoaXMuY29udG91cnMucGF0aCl7Y29uc3QgeD10aGlzLmNvbnRvdXJzLnNpbXBsaWZ5LFA9JCh0aGlzLmNvbnRvdXJzLnBhdGgsMipGLHgpO3RoaXNbdl09bnVsbCx0aGlzW1RdPVB9fWNhbklnbm9yZSgpe2NvbnN0IEY9dGhpc1tSXT09bnVsbHx8dGhpc1tSXS5saW5lV2lkdGg9PT0wfHx0aGlzW05dWzNdPT09MCxIPXRoaXNbTF09PW51bGx8fHRoaXNbQV1bM109PT0wLHg9dGhpc1tEXS51X3JhZGlhbEdyYWRpZW50VmVjdG9yPT1udWxsLFA9dGhpc1tEXS51X3RleFNhbXBsZXI9PW51bGw7cmV0dXJuIHRoaXNbcnRdPT09MHx8dGhpc1tvdF09PW51bGwmJkYmJkgmJngmJlAmJiF0aGlzLmJlZm9yZVJlbmRlciYmIXRoaXMuYWZ0ZXJSZW5kZXJ9c2V0U3Ryb2tlKHt0aGlja25lc3M6Rj0xLGNhcDpIPSJidXR0Iixqb2luOng9Im1pdGVyIixtaXRlckxpbWl0OlA9MTAsY29sb3I6Vz1bMCwwLDAsMF0sbGluZURhc2g6Sz1udWxsLGxpbmVEYXNoT2Zmc2V0Olo9MCxyb3VuZFNlZ21lbnRzOms9MjB9PXt9KXtyZXR1cm4gdGhpc1t2XT1udWxsLHRoaXNbUl09bmV3IGguZGVmYXVsdCh7bGluZVdpZHRoOkYsbGluZUNhcDpILGxpbmVKb2luOngsbWl0ZXJMaW1pdDpQLHJvdW5kU2VnbWVudHM6a30pLHR5cGVvZiBXPT0ic3RyaW5nIiYmKFc9T2JqZWN0KHkuZGVmYXVsdCkoVykpLHRoaXNbTl09Vyx0aGlzW1JdLmxpbmVEYXNoPUssdGhpc1tSXS5saW5lRGFzaE9mZnNldD1aLHRoaXN9c2V0RmlsbCh7cnVsZTpGPXRoaXMuZmlsbFJ1bGUsY29sb3I6SD1bMCwwLDAsMF19PXt9KXtyZXR1cm4gdGhpc1t2XT1udWxsLHRoaXNbTF09e3J1bGU6Rn0sdHlwZW9mIEg9PSJzdHJpbmciJiYoSD1PYmplY3QoeS5kZWZhdWx0KShIKSksdGhpc1tBXT1ILHRoaXN9c2V0VGV4dHVyZShGLEg9e30pe2lmKEYmJkYuaW1hZ2Upe2NvbnN0e2ltYWdlOngscmVjdDpQfT1GO2lmKEY9eCxILnJlY3QpZm9yKGxldCBXPTA7VzxILnJlY3QubGVuZ3RoO1crKylQW1ddPUgucmVjdFtXXTtILnJlY3Q9UH1yZXR1cm4gdGhpc1tMXXx8dGhpcy5zZXRGaWxsKCksdGhpcy5zZXRVbmlmb3Jtcyh7dV90ZXhTYW1wbGVyOkZ9KSx0aGlzW3ZdJiZ0aGlzW1ZdKHRoaXNbdl0sSCksdGhpc1tJXT1ILHRoaXN9c2V0Q2lyY3VsYXJHcmFkaWVudCh7dmVjdG9yOkYsY29sb3JzOkgsdHlwZTp4PSJmaWxsIn09e30pe2lmKEYubGVuZ3RoIT09Myl0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIGxpbmVhckdyYWRpZW50LiIpO3RoaXMuc2V0R3JhZGllbnQoe3ZlY3RvcjpGLGNvbG9yczpILHR5cGU6eH0pfXNldExpbmVhckdyYWRpZW50KHt2ZWN0b3I6Rixjb2xvcnM6SCx0eXBlOng9ImZpbGwifT17fSl7aWYoRi5sZW5ndGghPT00KXRocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgbGluZWFyR3JhZGllbnQuIik7dGhpcy5zZXRHcmFkaWVudCh7dmVjdG9yOkYsY29sb3JzOkgsdHlwZTp4fSl9c2V0UmFkaWFsR3JhZGllbnQoe3ZlY3RvcjpGLGNvbG9yczpILHR5cGU6eD0iZmlsbCJ9PXt9KXtpZihGLmxlbmd0aCE9PTYpdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCByYWRpYWxHcmFkaWVudC4iKTt0aGlzLnNldEdyYWRpZW50KHt2ZWN0b3I6Rixjb2xvcnM6SCx0eXBlOnh9KX1zZXRHcmFkaWVudCh7dmVjdG9yOkYsY29sb3JzOkgsdHlwZTp4PSJmaWxsIn09e30pe0g9SC5tYXAoKHtvZmZzZXQ6Syxjb2xvcjpafSk9Pih0eXBlb2YgWj09InN0cmluZyImJihaPU9iamVjdCh5LmRlZmF1bHQpKFopKSx7b2Zmc2V0OkssY29sb3I6Wn0pKSx0aGlzW0ddPXRoaXNbR118fHt9LHRoaXNbR11beF09e3ZlY3RvcjpGLGNvbG9yczpIfSxILnNvcnQoKEssWik9Pksub2Zmc2V0LVoub2Zmc2V0KTtjb25zdCBQPVtdO0guZm9yRWFjaCgoe29mZnNldDpLLGNvbG9yOlp9KT0+e1AucHVzaChLLC4uLlopfSk7bGV0IFc7aWYoRi5sZW5ndGg9PT00P1c9W0ZbMF0sRlsxXSwwLEZbMl0sRlszXSwwXTpXPVsuLi5GXSxQLmxlbmd0aDw0MCYmUC5wdXNoKC0xKSxQLmxlbmd0aD40MCl0aHJvdyBuZXcgRXJyb3IoIlRvbyBtYW55IGNvbG9ycywgc2hvdWxkIGJlIGxlc3MgdGhhbiA4IGNvbG9ycyIpO3JldHVybiB0aGlzLl9yYWRpYWxHcmFkaWVudFZlY3Rvcj1XLHRoaXNbRF0udV9jb2xvclN0ZXBzPVAseD09PSJmaWxsIj90aGlzW0RdLnVfZ3JhZGllbnRUeXBlPTE6dGhpc1tEXS51X2dyYWRpZW50VHlwZT0wLHRoaXNbX10oKSx0aGlzfXNldFVuaWZvcm1zKEY9e30pe3JldHVybiBPYmplY3QuYXNzaWduKHRoaXNbRF0sRiksdGhpc31zZXRUcmFuc2Zvcm0oLi4uRil7Y29uc3QgSD10aGlzW3ddO3JldHVybiBuLm1hdDJkLmVxdWFscyhGLEgpfHwodGhpc1t3XT1GLGRlbGV0ZSB0aGlzW0JdLHRoaXMuX3VwZGF0ZU1hdHJpeD0hMCksdGhpc310cmFuc2Zvcm0oLi4uRil7Y29uc3QgSD10aGlzW3ddO3JldHVybiB0aGlzW3ddPW4ubWF0MmQubXVsdGlwbHkoQXJyYXkub2YoMCwwLDAsMCwwLDApLEgsRiksZGVsZXRlIHRoaXNbQl0sdGhpcy5fdXBkYXRlTWF0cml4PSEwLHRoaXN9dHJhbnNsYXRlKEYsSCl7bGV0IHg9bi5tYXQyZC5jcmVhdGUoKTtyZXR1cm4geD1uLm1hdDJkLnRyYW5zbGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCkseCxbRixIXSksdGhpcy50cmFuc2Zvcm0oLi4ueCl9cm90YXRlKEYsW0gseF09WzAsMF0pe2xldCBQPW4ubWF0MmQuY3JlYXRlKCk7cmV0dXJuIFA9bi5tYXQyZC50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDApLFAsW0gseF0pLFA9bi5tYXQyZC5yb3RhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDApLFAsRiksUD1uLm1hdDJkLnRyYW5zbGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCksUCxbLUgsLXhdKSx0aGlzLnRyYW5zZm9ybSguLi5QKX1zY2FsZShGLEg9RixbeCxQXT1bMCwwXSl7bGV0IFc9bi5tYXQyZC5jcmVhdGUoKTtyZXR1cm4gVz1uLm1hdDJkLnRyYW5zbGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCksVyxbeCxQXSksVz1uLm1hdDJkLnNjYWxlKEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxXLFtGLEhdKSxXPW4ubWF0MmQudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxXLFsteCwtUF0pLHRoaXMudHJhbnNmb3JtKC4uLlcpfXNrZXcoRixIPUYsW3gsUF09WzAsMF0pe2xldCBXPW4ubWF0MmQuY3JlYXRlKCk7cmV0dXJuIFc9bi5tYXQyZC50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDApLFcsW3gsUF0pLFc9bi5tYXQyZC5tdWx0aXBseShBcnJheS5vZigwLDAsMCwwLDAsMCksVyxuLm1hdDJkLmZyb21WYWx1ZXMoMSxNYXRoLnRhbihIKSxNYXRoLnRhbihGKSwxLDAsMCkpLFc9bi5tYXQyZC50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDApLFcsWy14LC1QXSksdGhpcy50cmFuc2Zvcm0oLi4uVyl9Y2xlYXJGaWx0ZXIoKXtyZXR1cm4gdGhpcy5zZXRDb2xvclRyYW5zZm9ybShudWxsKSx0aGlzW1ldLmxlbmd0aD0wLHRoaXN9c2V0Q29sb3JUcmFuc2Zvcm0oLi4uRil7cmV0dXJuIEZbMF09PT1udWxsP3RoaXMuc2V0VW5pZm9ybXMoe3VfZmlsdGVyRmxhZzowLHVfY29sb3JNYXRyaXg6MH0pOnRoaXMuc2V0VW5pZm9ybXMoe3VfZmlsdGVyRmxhZzoxLHVfY29sb3JNYXRyaXg6Rn0pLHRoaXN9dHJhbnNmb3JtQ29sb3IoLi4uRil7bGV0IEg9dGhpcy51bmlmb3Jtcy51X2NvbG9yTWF0cml4O3JldHVybiBIP0g9T2JqZWN0KGQubXVsdGlwbHkpKEgsRik6SD1GLHRoaXMuc2V0Q29sb3JUcmFuc2Zvcm0oLi4uSCksdGhpc31ibHVyKEYpe3JldHVybiB0aGlzW1ldLnB1c2goYGJsdXIoJHtGfXB4KWApLHRoaXN9YnJpZ2h0bmVzcyhGPTEpe3JldHVybiB0aGlzW1ldLnB1c2goYGJyaWdodG5lc3MoJHsxMDAqRn0lKWApLHRoaXMudHJhbnNmb3JtQ29sb3IoLi4uT2JqZWN0KGQuYnJpZ2h0bmVzcykoRikpfWNvbnRyYXN0KEY9MSl7cmV0dXJuIHRoaXNbWV0ucHVzaChgY29udHJhc3QoJHsxMDAqRn0lKWApLHRoaXMudHJhbnNmb3JtQ29sb3IoLi4uT2JqZWN0KGQuY29udHJhc3QpKEYpKX1kcm9wU2hhZG93KEYsSCx4PTAsUD1bMCwwLDAsMV0pe3JldHVybiBBcnJheS5pc0FycmF5KFApJiYoUD1PYmplY3QoYS5kZWZhdWx0KShQKSksdGhpc1tZXS5wdXNoKGBkcm9wLXNoYWRvdygke0Z9cHggJHtIfXB4ICR7eH1weCAke1B9KWApLHRoaXN9Z3JheXNjYWxlKEY9MSl7cmV0dXJuIHRoaXNbWV0ucHVzaChgZ3JheXNjYWxlKCR7MTAwKkZ9JSlgKSx0aGlzLnRyYW5zZm9ybUNvbG9yKC4uLk9iamVjdChkLmdyYXlzY2FsZSkoRikpfWh1ZVJvdGF0ZShGPTApe3JldHVybiB0aGlzW1ldLnB1c2goYGh1ZS1yb3RhdGUoJHtGfWRlZylgKSx0aGlzLnRyYW5zZm9ybUNvbG9yKC4uLk9iamVjdChkLmh1ZVJvdGF0ZSkoRikpfWludmVydChGPTEpe3JldHVybiB0aGlzW1ldLnB1c2goYGludmVydCgkezEwMCpGfSUpYCksdGhpcy50cmFuc2Zvcm1Db2xvciguLi5PYmplY3QoZC5pbnZlcnQpKEYpKX1vcGFjaXR5KEY9MSl7cmV0dXJuIHRoaXNbWV0ucHVzaChgb3BhY2l0eSgkezEwMCpGfSUpYCksdGhpcy50cmFuc2Zvcm1Db2xvciguLi5PYmplY3QoZC5vcGFjaXR5KShGKSl9c2F0dXJhdGUoRj0xKXtyZXR1cm4gdGhpc1tZXS5wdXNoKGBzYXR1cmF0ZSgkezEwMCpGfSUpYCksdGhpcy50cmFuc2Zvcm1Db2xvciguLi5PYmplY3QoZC5zYXR1cmF0ZSkoRikpfXNlcGlhKEY9MSl7cmV0dXJuIHRoaXNbWV0ucHVzaChgc2VwaWEoJHsxMDAqRn0lKWApLHRoaXMudHJhbnNmb3JtQ29sb3IoLi4uT2JqZWN0KGQuc2VwaWEpKEYpKX11cmwoRil7cmV0dXJuIHRoaXNbWV0ucHVzaChgdXJsKCR7Rn0pYCksdGhpc31pc1BvaW50Q29sbGlzaW9uKEYsSCx4PSJib3RoIil7Y29uc3QgUD10aGlzLm1lc2hEYXRhLHtwb3NpdGlvbnM6VyxjZWxsczpLfT1QLFo9dGhpcy5pbnZlcnRNYXRyaXgsaz1aWzBdKkYrWlsyXSpIK1pbNF0sbnQ9WlsxXSpGK1pbM10qSCtaWzVdLHV0PXRoaXMuYm91bmRpbmdCb3g7aWYoazx1dFswXVswXXx8az51dFsxXVswXXx8bnQ8dXRbMF1bMV18fG50PnV0WzFdWzFdKXJldHVybiExO2Z1bmN0aW9uIGN0KFtwdCx4dF0sW2d0LGR0XSxbbXQsYnRdKXtjb25zdCBDdD1tdC1ndCxTdD1idC1kdCxOdD0oKHB0LWd0KSpDdCsoeHQtZHQpKlN0KS8oQ3QqKjIrU3QqKjIpO3JldHVybiBOdD49MCYmTnQ8PTF9Zm9yKGxldCBwdD0wO3B0PEsubGVuZ3RoO3B0Kyspe2NvbnN0IHh0PUtbcHRdO2lmKHg9PT0iZmlsbCImJnh0WzBdPj1QLmZpbGxQb2ludENvdW50KWJyZWFrO2lmKHg9PT0ic3Ryb2tlIiYmeHRbMF08UC5maWxsUG9pbnRDb3VudCljb250aW51ZTtjb25zdFtbZ3QsZHRdLFttdCxidF0sW0N0LFN0XV09eHQubWFwKEt0PT5XW0t0XSksTnQ9TWF0aC5zaWduKChGLWd0KSooYnQtZHQpLShtdC1ndCkqKEgtZHQpKTtpZihOdD09PTAmJmN0KFtGLEhdLFtndCxkdF0sW210LGJ0XSkpcmV0dXJuITA7Y29uc3QgSnQ9TWF0aC5zaWduKChGLW10KSooU3QtYnQpLShDdC1tdCkqKEgtYnQpKTtpZihKdD09PTAmJmN0KFtGLEhdLFttdCxidF0sW0N0LFN0XSkpcmV0dXJuITA7Y29uc3QgR3Q9TWF0aC5zaWduKChGLUN0KSooZHQtU3QpLShndC1DdCkqKEgtU3QpKTtpZihHdD09PTAmJmN0KFtGLEhdLFtDdCxTdF0sW2d0LGR0XSl8fE50PT09MSYmSnQ9PT0xJiZHdD09PTF8fE50PT09LTEmJkp0PT09LTEmJkd0PT09LTEpcmV0dXJuITB9cmV0dXJuITF9aXNQb2ludEluRmlsbChGLEgpe3JldHVybiB0aGlzLmlzUG9pbnRDb2xsaXNpb24oRixILCJmaWxsIil9aXNQb2ludEluU3Ryb2tlKEYsSCl7cmV0dXJuIHRoaXMuaXNQb2ludENvbGxpc2lvbihGLEgsInN0cm9rZSIpfWFkZFBhc3MoRixIPXt9KXtsZXR7d2lkdGg6eCxoZWlnaHQ6UH09SCxXPWMoSCxbIndpZHRoIiwiaGVpZ2h0Il0pO2NvbnN0IEs9bmV3IFMuZGVmYXVsdDtLLnJlY3QoMCwwLHgsUCk7Y29uc3QgWj1uZXcgUShLLHt3aWR0aDp4LGhlaWdodDpQfSk7Wi5zZXRVbmlmb3JtcyhXKSxaLnNldFByb2dyYW0oRiksdGhpc1todF0ucHVzaChaKX19fSxmdW5jdGlvbihnLGUsdCl7dC5yKGUpO3ZhciBuPXQoNTgpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KSxlLmRlZmF1bHQ9bi5TdHJva2V9LGZ1bmN0aW9uKGcsZSx0KXt0LnIoZSksdC5kKGUsIlN0cm9rZSIsZnVuY3Rpb24oKXtyZXR1cm4gRX0pO3ZhciBuPXQoNDkpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCBpPU9iamVjdChuLmNyZWF0ZSkoKSxmPU9iamVjdChuLmNyZWF0ZSkoKSxoPU9iamVjdChuLmNyZWF0ZSkoKSx1PU9iamVjdChuLmNyZWF0ZSkoKSxhPU9iamVjdChuLmNyZWF0ZSkoKSxkPTFlMjA7Y2xhc3MgRXtjb25zdHJ1Y3Rvcih7bGluZVdpZHRoOk09MSxsaW5lSm9pbjp5PSJtaXRlciIsbWl0ZXJMaW1pdDpTPTEwLGxpbmVDYXA6cz0iYnV0dCIscm91bmRTZWdtZW50czpjPTIwfT17fSl7dGhpcy5saW5lV2lkdGg9TSx0aGlzLmxpbmVKb2luPXksdGhpcy5taXRlckxpbWl0PVMsdGhpcy5saW5lQ2FwPXMsdGhpcy5yb3VuZFNlZ21lbnRzPWMsdGhpcy5fbm9ybWFsPW51bGx9YnVpbGQoTSx5PSExKXtsZXQgUz1NLmxlbmd0aDtpZihNPVsuLi5NXSxTPDIpcmV0dXJuIE07eSYmKChNWzBdWzBdIT09TVtTLTFdWzBdfHxNWzBdWzFdIT09TVtTLTFdWzFdKSYmTS5wdXNoKFsuLi5NWzBdXSksTS5wdXNoKFsuLi5NWzFdXSkpLFM9TS5sZW5ndGgsdGhpcy5fbm9ybWFsPW51bGw7Y29uc3Qgcz17bGVmdDpbXSxyaWdodDpbXX0sYz10aGlzLmxpbmVXaWR0aC8yLGw9dGhpcy5saW5lQ2FwO2lmKCF5JiZsPT09InNxdWFyZSIpe09iamVjdChuLmRpcmVjdGlvbikoZixNWzBdLE1bMV0pLE9iamVjdChuLnNjYWxlQW5kQWRkKShNWzBdLE1bMF0sZixjKTtjb25zdCBUPU0ubGVuZ3RoLTE7T2JqZWN0KG4uZGlyZWN0aW9uKShmLE1bVF0sTVtULTFdKSxPYmplY3Qobi5zY2FsZUFuZEFkZCkoTVtUXSxNW1RdLGYsYyl9Zm9yKGxldCBUPTE7VDxTO1QrKyl7Y29uc3QgUj1NW1QtMV0sTD1NW1RdLE49TVtUKzFdO3RoaXMuX3NlZyhzLFIsTCxOLGMseSl9cmV0dXJuIXkmJmw9PT0icm91bmQiJiZtKHMsdGhpcy5yb3VuZFNlZ21lbnRzKSxbLi4ucy5sZWZ0LC4uLnMucmlnaHQucmV2ZXJzZSgpXX1fc2VnKE0seSxTLHMsYyxsKXtjb25zdCB2PXRoaXMubGluZUpvaW49PT0iYmV2ZWwiLFQ9dGhpcy5saW5lSm9pbj09PSJyb3VuZCI7aWYoT2JqZWN0KG4uZGlyZWN0aW9uKShmLFMseSksdGhpcy5fbm9ybWFsfHwodGhpcy5fbm9ybWFsPU9iamVjdChuLmNyZWF0ZSkoKSxPYmplY3Qobi5ub3JtYWwpKHRoaXMuX25vcm1hbCxmKSksTS5sZWZ0Lmxlbmd0aHx8TyhNLHksdGhpcy5fbm9ybWFsLGMpLCFzKU9iamVjdChuLm5vcm1hbCkodGhpcy5fbm9ybWFsLGYpLGw/TyhNLHksdGhpcy5fbm9ybWFsLGMpOk8oTSxTLHRoaXMuX25vcm1hbCxjKTtlbHNle09iamVjdChuLmRpcmVjdGlvbikoaCxzLFMpO2xldCBSPU9iamVjdChuLmNvbXB1dGVNaXRlcikodSxhLGYsaCxjKTtSPU1hdGgubWluKFIsZCk7Y29uc3QgTD1PYmplY3Qobi5kb3QpKHUsdGhpcy5fbm9ybWFsKTwwPy0xOjE7bGV0IE49dnx8VDtpZighTiYmdGhpcy5saW5lSm9pbj09PSJtaXRlciImJlIvYz50aGlzLm1pdGVyTGltaXQmJihOPSEwKSxOKXtPYmplY3Qobi5zY2FsZUFuZEFkZCkoaSxTLHRoaXMuX25vcm1hbCwtYypMKSxwKE0saSxMKTtsZXQgQT0xLzA7eSYmKEE9TWF0aC5taW4oQSxNYXRoLmh5cG90KFNbMF0teVswXSxTWzFdLXlbMV0pKSkscyYmKEE9TWF0aC5taW4oQSxNYXRoLmh5cG90KHNbMF0tU1swXSxzWzFdLVNbMV0pKSk7Y29uc3Qgdz1NYXRoLm1heChjLE1hdGgubWluKFIsQSkpO2lmKE9iamVjdChuLnNjYWxlQW5kQWRkKShpLFMsYSx3KkwpLHAoTSxpLC1MKSxzKWlmKE9iamVjdChuLm5vcm1hbCkoaSxoKSxPYmplY3Qobi5jb3B5KSh0aGlzLl9ub3JtYWwsaSksT2JqZWN0KG4uc2NhbGVBbmRBZGQpKGksUyxpLC1jKkwpLFQpe2NvbnN0IEI9T2JqZWN0KG4uY2xvbmUpKGkpLEQ9TD4wP00ubGVmdFtNLmxlZnQubGVuZ3RoLTFdOk0ucmlnaHRbTS5yaWdodC5sZW5ndGgtMV0sST1PYmplY3Qobi5jbG9uZSkoUyksaj1PYmplY3Qobi5zdWIpKE9iamVjdChuLmNyZWF0ZSkoKSxELEkpLFY9T2JqZWN0KG4uc3ViKShPYmplY3Qobi5jcmVhdGUpKCksQixJKSxKPU1hdGguUEkvdGhpcy5yb3VuZFNlZ21lbnRzO2ZvcihsZXQgXz0wO188dGhpcy5yb3VuZFNlZ21lbnRzJiYoT2JqZWN0KG4ucm90YXRlKShqLGosWzAsMF0sTCpKKSxNYXRoLnNpZ24oT2JqZWN0KG4uY3Jvc3MpKGksaixWKVsyXSk9PT1MKTtfKyspT2JqZWN0KG4uYWRkKShpLGosSSkscChNLGksTCk7cChNLEIsTCl9ZWxzZSBwKE0saSxMKX1lbHNlIE8oTSxTLGEsUiksT2JqZWN0KG4uY29weSkodGhpcy5fbm9ybWFsLGEpfX19ZnVuY3Rpb24gcChiLE0seSl7eT4wP2IubGVmdC5wdXNoKE9iamVjdChuLmNsb25lKShNKSk6Yi5yaWdodC5wdXNoKE9iamVjdChuLmNsb25lKShNKSl9ZnVuY3Rpb24gTyhiLE0seSxTLHM9LTEpe09iamVjdChuLnNjYWxlQW5kQWRkKShpLE0seSwtUykscChiLGksLXMpLE9iamVjdChuLnNjYWxlQW5kQWRkKShpLE0seSxTKSxwKGIsaSxzKX1mdW5jdGlvbiBtKHtsZWZ0OmIscmlnaHQ6TX0seSl7Y29uc3QgUz1PYmplY3Qobi5jcmVhdGUpKCkscz1PYmplY3Qobi5jcmVhdGUpKCk7bGV0IGM9YlswXSxsPU1bMF0sdj1bLjUqKGNbMF0rbFswXSksLjUqKGNbMV0rbFsxXSldO09iamVjdChuLnN1YikocyxjLHYpO2ZvcihsZXQgVD0xO1Q8PXk7VCsrKXtjb25zdCBSPS0xKk1hdGguUEkqVC95O09iamVjdChuLnJvdGF0ZSkoUyxzLFswLDBdLFIpLE9iamVjdChuLmFkZCkoaSx2LFMpLGIudW5zaGlmdChPYmplY3Qobi5jbG9uZSkoaSkpfWM9TVtNLmxlbmd0aC0xXSxsPWJbYi5sZW5ndGgtMV0sdj1bLjUqKGNbMF0rbFswXSksLjUqKGNbMV0rbFsxXSldLE9iamVjdChuLnN1YikocyxjLHYpO2ZvcihsZXQgVD0xO1Q8PXk7VCsrKXtjb25zdCBSPS0xKk1hdGguUEkqVC95O09iamVjdChuLnJvdGF0ZSkoUyxzLFswLDBdLFIpLE9iamVjdChuLmFkZCkoaSx2LFMpLE0ucHVzaChPYmplY3Qobi5jbG9uZSkoaSkpfX19LGZ1bmN0aW9uKGcsZSx0KXt0LnIoZSksdC5kKGUsImlzVW5pdFRyYW5zZm9ybSIsZnVuY3Rpb24oKXtyZXR1cm4gbn0pLHQoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBuKGkpe3JldHVybiBpWzBdPT09MSYmaVsxXT09PTAmJmlbMl09PT0wJiZpWzNdPT09MSYmaVs0XT09PTAmJmlbNV09PT0wfX0sZnVuY3Rpb24oZyxlLHQpe3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTt2YXIgbj10KDYxKSxpPXQoNjIpO2cuZXhwb3J0cz1mdW5jdGlvbihmLGgpe2lmKGg9aHx8e30sZj1mLmZpbHRlcihmdW5jdGlvbih5KXtyZXR1cm4geS5sZW5ndGg+Mn0pLGYubGVuZ3RoPT09MClyZXR1cm57cG9zaXRpb25zOltdLGNlbGxzOltdfTt0eXBlb2YgaC52ZXJ0ZXhTaXplIT0ibnVtYmVyIiYmKGgudmVydGV4U2l6ZT1mWzBdWzBdLmxlbmd0aCksZj1mLm1hcChmdW5jdGlvbih5KXtyZXR1cm4geS5yZWR1Y2UoZnVuY3Rpb24oUyxzKXtyZXR1cm4gUy5jb25jYXQocyl9KX0pO2NvbnN0IHU9aC5ydWxlPT09ImV2ZW5vZGQiP24uV0lORElOR19PREQ6bi5XSU5ESU5HX05PTlpFUk87Zm9yKHZhciBhPW4udGVzc2VsYXRlKGkoe2NvbnRvdXJzOmYsd2luZGluZ1J1bGU6dSxlbGVtZW50VHlwZTpuLlBPTFlHT05TLHBvbHlTaXplOjMsdmVydGV4U2l6ZToyfSxoKSksZD1bXSxFPTA7RTxhLnZlcnRpY2VzLmxlbmd0aDtFKz1oLnZlcnRleFNpemUpe3ZhciBwPWEudmVydGljZXMuc2xpY2UoRSxFK2gudmVydGV4U2l6ZSk7ZC5wdXNoKHApfXZhciBPPVtdO2ZvcihFPTA7RTxhLmVsZW1lbnRzLmxlbmd0aDtFKz0zKXt2YXIgbT1hLmVsZW1lbnRzW0VdLGI9YS5lbGVtZW50c1tFKzFdLE09YS5lbGVtZW50c1tFKzJdO08ucHVzaChbbSxiLE1dKX1yZXR1cm57cG9zaXRpb25zOmQsY2VsbHM6T319fSxmdW5jdGlvbihnLGUsdCl7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO3ZhciBuPXt9LGk9e307Zy5leHBvcnRzPW4sbi5XSU5ESU5HX09ERD0wLG4uV0lORElOR19OT05aRVJPPTEsbi5XSU5ESU5HX1BPU0lUSVZFPTIsbi5XSU5ESU5HX05FR0FUSVZFPTMsbi5XSU5ESU5HX0FCU19HRVFfVFdPPTQsbi5QT0xZR09OUz0wLG4uQ09OTkVDVEVEX1BPTFlHT05TPTEsbi5CT1VOREFSWV9DT05UT1VSUz0yLG4udGVzc2VsYXRlPWZ1bmN0aW9uKHMpe2Zvcih2YXIgYz1zLmRlYnVnfHwhMSxsPW5ldyBTLHY9MDt2PHMuY29udG91cnMubGVuZ3RoO3YrKylsLmFkZENvbnRvdXIocy52ZXJ0ZXhTaXplfHwyLHMuY29udG91cnNbdl0pO3JldHVybiBsLnRlc3NlbGF0ZShzLndpbmRpbmdSdWxlfHxuLldJTkRJTkdfT0RELHMuZWxlbWVudFR5cGV8fG4uUE9MWUdPTlMscy5wb2x5U2l6ZXx8MyxzLnZlcnRleFNpemV8fDIscy5ub3JtYWx8fFswLDAsMV0pLHt2ZXJ0aWNlczpsLnZlcnRpY2VzLHZlcnRleEluZGljZXM6bC52ZXJ0ZXhJbmRpY2VzLHZlcnRleENvdW50OmwudmVydGV4Q291bnQsZWxlbWVudHM6bC5lbGVtZW50cyxlbGVtZW50Q291bnQ6bC5lbGVtZW50Q291bnQsbWVzaDpjP2wubWVzaDp2b2lkIDB9fTt2YXIgZj1mdW5jdGlvbihzKXtpZighcyl0aHJvdyJBc3NlcnRpb24gRmFpbGVkISJ9O2Z1bmN0aW9uIGgoKXt0aGlzLm5leHQ9bnVsbCx0aGlzLnByZXY9bnVsbCx0aGlzLmFuRWRnZT1udWxsLHRoaXMuY29vcmRzPVswLDAsMF0sdGhpcy5zPTAsdGhpcy50PTAsdGhpcy5wcUhhbmRsZT0wLHRoaXMubj0wLHRoaXMuaWR4PTB9ZnVuY3Rpb24gdSgpe3RoaXMubmV4dD1udWxsLHRoaXMucHJldj1udWxsLHRoaXMuYW5FZGdlPW51bGwsdGhpcy50cmFpbD1udWxsLHRoaXMubj0wLHRoaXMubWFya2VkPSExLHRoaXMuaW5zaWRlPSExfWZ1bmN0aW9uIGEocyl7dGhpcy5uZXh0PW51bGwsdGhpcy5TeW09bnVsbCx0aGlzLk9uZXh0PW51bGwsdGhpcy5MbmV4dD1udWxsLHRoaXMuT3JnPW51bGwsdGhpcy5MZmFjZT1udWxsLHRoaXMuYWN0aXZlUmVnaW9uPW51bGwsdGhpcy53aW5kaW5nPTAsdGhpcy5zaWRlPXN9YS5wcm90b3R5cGU9e2dldCBSZmFjZSgpe3JldHVybiB0aGlzLlN5bS5MZmFjZX0sc2V0IFJmYWNlKHMpe3RoaXMuU3ltLkxmYWNlPXN9LGdldCBEc3QoKXtyZXR1cm4gdGhpcy5TeW0uT3JnfSxzZXQgRHN0KHMpe3RoaXMuU3ltLk9yZz1zfSxnZXQgT3ByZXYoKXtyZXR1cm4gdGhpcy5TeW0uTG5leHR9LHNldCBPcHJldihzKXt0aGlzLlN5bS5MbmV4dD1zfSxnZXQgTHByZXYoKXtyZXR1cm4gdGhpcy5PbmV4dC5TeW19LHNldCBMcHJldihzKXt0aGlzLk9uZXh0LlN5bT1zfSxnZXQgRHByZXYoKXtyZXR1cm4gdGhpcy5MbmV4dC5TeW19LHNldCBEcHJldihzKXt0aGlzLkxuZXh0LlN5bT1zfSxnZXQgUnByZXYoKXtyZXR1cm4gdGhpcy5TeW0uT25leHR9LHNldCBScHJldihzKXt0aGlzLlN5bS5PbmV4dD1zfSxnZXQgRG5leHQoKXtyZXR1cm4gdGhpcy5TeW0uT25leHQuU3ltfSxzZXQgRG5leHQocyl7dGhpcy5TeW0uT25leHQuU3ltPXN9LGdldCBSbmV4dCgpe3JldHVybiB0aGlzLlN5bS5MbmV4dC5TeW19LHNldCBSbmV4dChzKXt0aGlzLlN5bS5MbmV4dC5TeW09c319O2Z1bmN0aW9uIGQoKXt2YXIgcz1uZXcgaCxjPW5ldyB1LGw9bmV3IGEoMCksdj1uZXcgYSgxKTtzLm5leHQ9cy5wcmV2PXMscy5hbkVkZ2U9bnVsbCxjLm5leHQ9Yy5wcmV2PWMsYy5hbkVkZ2U9bnVsbCxjLnRyYWlsPW51bGwsYy5tYXJrZWQ9ITEsYy5pbnNpZGU9ITEsbC5uZXh0PWwsbC5TeW09dixsLk9uZXh0PW51bGwsbC5MbmV4dD1udWxsLGwuT3JnPW51bGwsbC5MZmFjZT1udWxsLGwud2luZGluZz0wLGwuYWN0aXZlUmVnaW9uPW51bGwsdi5uZXh0PXYsdi5TeW09bCx2Lk9uZXh0PW51bGwsdi5MbmV4dD1udWxsLHYuT3JnPW51bGwsdi5MZmFjZT1udWxsLHYud2luZGluZz0wLHYuYWN0aXZlUmVnaW9uPW51bGwsdGhpcy52SGVhZD1zLHRoaXMuZkhlYWQ9Yyx0aGlzLmVIZWFkPWwsdGhpcy5lSGVhZFN5bT12fWQucHJvdG90eXBlPXttYWtlRWRnZV86ZnVuY3Rpb24ocyl7dmFyIGM9bmV3IGEoMCksbD1uZXcgYSgxKTtzLlN5bS5zaWRlPHMuc2lkZSYmKHM9cy5TeW0pO3ZhciB2PXMuU3ltLm5leHQ7cmV0dXJuIGwubmV4dD12LHYuU3ltLm5leHQ9YyxjLm5leHQ9cyxzLlN5bS5uZXh0PWwsYy5TeW09bCxjLk9uZXh0PWMsYy5MbmV4dD1sLGMuT3JnPW51bGwsYy5MZmFjZT1udWxsLGMud2luZGluZz0wLGMuYWN0aXZlUmVnaW9uPW51bGwsbC5TeW09YyxsLk9uZXh0PWwsbC5MbmV4dD1jLGwuT3JnPW51bGwsbC5MZmFjZT1udWxsLGwud2luZGluZz0wLGwuYWN0aXZlUmVnaW9uPW51bGwsY30sc3BsaWNlXzpmdW5jdGlvbihzLGMpe3ZhciBsPXMuT25leHQsdj1jLk9uZXh0O2wuU3ltLkxuZXh0PWMsdi5TeW0uTG5leHQ9cyxzLk9uZXh0PXYsYy5PbmV4dD1sfSxtYWtlVmVydGV4XzpmdW5jdGlvbihzLGMsbCl7dmFyIHY9cztmKHYhPT1udWxsKTt2YXIgVD1sLnByZXY7di5wcmV2PVQsVC5uZXh0PXYsdi5uZXh0PWwsbC5wcmV2PXYsdi5hbkVkZ2U9Yzt2YXIgUj1jO2RvIFIuT3JnPXYsUj1SLk9uZXh0O3doaWxlKFIhPT1jKX0sbWFrZUZhY2VfOmZ1bmN0aW9uKHMsYyxsKXt2YXIgdj1zO2YodiE9PW51bGwpO3ZhciBUPWwucHJldjt2LnByZXY9VCxULm5leHQ9dix2Lm5leHQ9bCxsLnByZXY9dix2LmFuRWRnZT1jLHYudHJhaWw9bnVsbCx2Lm1hcmtlZD0hMSx2Lmluc2lkZT1sLmluc2lkZTt2YXIgUj1jO2RvIFIuTGZhY2U9dixSPVIuTG5leHQ7d2hpbGUoUiE9PWMpfSxraWxsRWRnZV86ZnVuY3Rpb24ocyl7cy5TeW0uc2lkZTxzLnNpZGUmJihzPXMuU3ltKTt2YXIgYz1zLm5leHQsbD1zLlN5bS5uZXh0O2MuU3ltLm5leHQ9bCxsLlN5bS5uZXh0PWN9LGtpbGxWZXJ0ZXhfOmZ1bmN0aW9uKHMsYyl7dmFyIGw9cy5hbkVkZ2Usdj1sO2RvIHYuT3JnPWMsdj12Lk9uZXh0O3doaWxlKHYhPT1sKTt2YXIgVD1zLnByZXYsUj1zLm5leHQ7Ui5wcmV2PVQsVC5uZXh0PVJ9LGtpbGxGYWNlXzpmdW5jdGlvbihzLGMpe3ZhciBsPXMuYW5FZGdlLHY9bDtkbyB2LkxmYWNlPWMsdj12LkxuZXh0O3doaWxlKHYhPT1sKTt2YXIgVD1zLnByZXYsUj1zLm5leHQ7Ui5wcmV2PVQsVC5uZXh0PVJ9LG1ha2VFZGdlOmZ1bmN0aW9uKCl7dmFyIHM9bmV3IGgsYz1uZXcgaCxsPW5ldyB1LHY9dGhpcy5tYWtlRWRnZV8odGhpcy5lSGVhZCk7cmV0dXJuIHRoaXMubWFrZVZlcnRleF8ocyx2LHRoaXMudkhlYWQpLHRoaXMubWFrZVZlcnRleF8oYyx2LlN5bSx0aGlzLnZIZWFkKSx0aGlzLm1ha2VGYWNlXyhsLHYsdGhpcy5mSGVhZCksdn0sc3BsaWNlOmZ1bmN0aW9uKHMsYyl7dmFyIGw9ITEsdj0hMTtpZihzIT09Yyl7aWYoYy5PcmchPT1zLk9yZyYmKHY9ITAsdGhpcy5raWxsVmVydGV4XyhjLk9yZyxzLk9yZykpLGMuTGZhY2UhPT1zLkxmYWNlJiYobD0hMCx0aGlzLmtpbGxGYWNlXyhjLkxmYWNlLHMuTGZhY2UpKSx0aGlzLnNwbGljZV8oYyxzKSwhdil7dmFyIFQ9bmV3IGg7dGhpcy5tYWtlVmVydGV4XyhULGMscy5PcmcpLHMuT3JnLmFuRWRnZT1zfWlmKCFsKXt2YXIgUj1uZXcgdTt0aGlzLm1ha2VGYWNlXyhSLGMscy5MZmFjZSkscy5MZmFjZS5hbkVkZ2U9c319fSxkZWxldGU6ZnVuY3Rpb24ocyl7dmFyIGM9cy5TeW0sbD0hMTtpZihzLkxmYWNlIT09cy5SZmFjZSYmKGw9ITAsdGhpcy5raWxsRmFjZV8ocy5MZmFjZSxzLlJmYWNlKSkscy5PbmV4dD09PXMpdGhpcy5raWxsVmVydGV4XyhzLk9yZyxudWxsKTtlbHNlIGlmKHMuUmZhY2UuYW5FZGdlPXMuT3ByZXYscy5PcmcuYW5FZGdlPXMuT25leHQsdGhpcy5zcGxpY2VfKHMscy5PcHJldiksIWwpe3ZhciB2PW5ldyB1O3RoaXMubWFrZUZhY2VfKHYscyxzLkxmYWNlKX1jLk9uZXh0PT09Yz8odGhpcy5raWxsVmVydGV4XyhjLk9yZyxudWxsKSx0aGlzLmtpbGxGYWNlXyhjLkxmYWNlLG51bGwpKToocy5MZmFjZS5hbkVkZ2U9Yy5PcHJldixjLk9yZy5hbkVkZ2U9Yy5PbmV4dCx0aGlzLnNwbGljZV8oYyxjLk9wcmV2KSksdGhpcy5raWxsRWRnZV8ocyl9LGFkZEVkZ2VWZXJ0ZXg6ZnVuY3Rpb24ocyl7dmFyIGM9dGhpcy5tYWtlRWRnZV8ocyksbD1jLlN5bTt0aGlzLnNwbGljZV8oYyxzLkxuZXh0KSxjLk9yZz1zLkRzdDt2YXIgdj1uZXcgaDtyZXR1cm4gdGhpcy5tYWtlVmVydGV4Xyh2LGwsYy5PcmcpLGMuTGZhY2U9bC5MZmFjZT1zLkxmYWNlLGN9LHNwbGl0RWRnZTpmdW5jdGlvbihzLGMpe3ZhciBsPXRoaXMuYWRkRWRnZVZlcnRleChzKSx2PWwuU3ltO3JldHVybiB0aGlzLnNwbGljZV8ocy5TeW0scy5TeW0uT3ByZXYpLHRoaXMuc3BsaWNlXyhzLlN5bSx2KSxzLkRzdD12Lk9yZyx2LkRzdC5hbkVkZ2U9di5TeW0sdi5SZmFjZT1zLlJmYWNlLHYud2luZGluZz1zLndpbmRpbmcsdi5TeW0ud2luZGluZz1zLlN5bS53aW5kaW5nLHZ9LGNvbm5lY3Q6ZnVuY3Rpb24ocyxjKXt2YXIgbD0hMSx2PXRoaXMubWFrZUVkZ2VfKHMpLFQ9di5TeW07aWYoYy5MZmFjZSE9PXMuTGZhY2UmJihsPSEwLHRoaXMua2lsbEZhY2VfKGMuTGZhY2Uscy5MZmFjZSkpLHRoaXMuc3BsaWNlXyh2LHMuTG5leHQpLHRoaXMuc3BsaWNlXyhULGMpLHYuT3JnPXMuRHN0LFQuT3JnPWMuT3JnLHYuTGZhY2U9VC5MZmFjZT1zLkxmYWNlLHMuTGZhY2UuYW5FZGdlPVQsIWwpe3ZhciBSPW5ldyB1O3RoaXMubWFrZUZhY2VfKFIsdixzLkxmYWNlKX1yZXR1cm4gdn0semFwRmFjZTpmdW5jdGlvbihzKXt2YXIgYz1zLmFuRWRnZSxsLHYsVCxSLEw7dj1jLkxuZXh0O2RvIGw9dix2PWwuTG5leHQsbC5MZmFjZT1udWxsLGwuUmZhY2U9PT1udWxsJiYobC5PbmV4dD09PWw/dGhpcy5raWxsVmVydGV4XyhsLk9yZyxudWxsKToobC5PcmcuYW5FZGdlPWwuT25leHQsdGhpcy5zcGxpY2VfKGwsbC5PcHJldikpLFQ9bC5TeW0sVC5PbmV4dD09PVQ/dGhpcy5raWxsVmVydGV4XyhULk9yZyxudWxsKTooVC5PcmcuYW5FZGdlPVQuT25leHQsdGhpcy5zcGxpY2VfKFQsVC5PcHJldikpLHRoaXMua2lsbEVkZ2VfKGwpKTt3aGlsZShsIT1jKTtSPXMucHJldixMPXMubmV4dCxMLnByZXY9UixSLm5leHQ9TH0sY291bnRGYWNlVmVydHNfOmZ1bmN0aW9uKHMpe3ZhciBjPXMuYW5FZGdlLGw9MDtkbyBsKyssYz1jLkxuZXh0O3doaWxlKGMhPT1zLmFuRWRnZSk7cmV0dXJuIGx9LG1lcmdlQ29udmV4RmFjZXM6ZnVuY3Rpb24ocyl7dmFyIGMsbCx2LFQsUixMLE47Zm9yKGM9dGhpcy5mSGVhZC5uZXh0O2MhPT10aGlzLmZIZWFkO2M9Yy5uZXh0KWlmKGMuaW5zaWRlKWZvcihsPWMuYW5FZGdlLFI9bC5Pcmc7dj1sLkxuZXh0LFQ9bC5TeW0sVCYmVC5MZmFjZSYmVC5MZmFjZS5pbnNpZGUmJihMPXRoaXMuY291bnRGYWNlVmVydHNfKGMpLE49dGhpcy5jb3VudEZhY2VWZXJ0c18oVC5MZmFjZSksTCtOLTI8PXMmJmkudmVydENDVyhsLkxwcmV2Lk9yZyxsLk9yZyxULkxuZXh0LkxuZXh0Lk9yZykmJmkudmVydENDVyhULkxwcmV2Lk9yZyxULk9yZyxsLkxuZXh0LkxuZXh0Lk9yZykmJih2PVQuTG5leHQsdGhpcy5kZWxldGUoVCksbD1udWxsLFQ9bnVsbCkpLCEobCYmbC5MbmV4dC5Pcmc9PT1SKTspbD12O3JldHVybiEwfSxjaGVjazpmdW5jdGlvbigpe3ZhciBzPXRoaXMuZkhlYWQsYz10aGlzLnZIZWFkLGw9dGhpcy5lSGVhZCx2LFQsUixMLE4sQTtmb3IoVD1zLFQ9czsodj1ULm5leHQpIT09cztUPXYpe2Yodi5wcmV2PT09VCksTj12LmFuRWRnZTtkbyBmKE4uU3ltIT09TiksZihOLlN5bS5TeW09PT1OKSxmKE4uTG5leHQuT25leHQuU3ltPT09TiksZihOLk9uZXh0LlN5bS5MbmV4dD09PU4pLGYoTi5MZmFjZT09PXYpLE49Ti5MbmV4dDt3aGlsZShOIT09di5hbkVkZ2UpfWZvcihmKHYucHJldj09PVQmJnYuYW5FZGdlPT09bnVsbCksTD1jLEw9YzsoUj1MLm5leHQpIT09YztMPVIpe2YoUi5wcmV2PT09TCksTj1SLmFuRWRnZTtkbyBmKE4uU3ltIT09TiksZihOLlN5bS5TeW09PT1OKSxmKE4uTG5leHQuT25leHQuU3ltPT09TiksZihOLk9uZXh0LlN5bS5MbmV4dD09PU4pLGYoTi5Pcmc9PT1SKSxOPU4uT25leHQ7d2hpbGUoTiE9PVIuYW5FZGdlKX1mb3IoZihSLnByZXY9PT1MJiZSLmFuRWRnZT09PW51bGwpLEE9bCxBPWw7KE49QS5uZXh0KSE9PWw7QT1OKWYoTi5TeW0ubmV4dD09PUEuU3ltKSxmKE4uU3ltIT09TiksZihOLlN5bS5TeW09PT1OKSxmKE4uT3JnIT09bnVsbCksZihOLkRzdCE9PW51bGwpLGYoTi5MbmV4dC5PbmV4dC5TeW09PT1OKSxmKE4uT25leHQuU3ltLkxuZXh0PT09Tik7ZihOLlN5bS5uZXh0PT09QS5TeW0mJk4uU3ltPT09dGhpcy5lSGVhZFN5bSYmTi5TeW0uU3ltPT09TiYmTi5Pcmc9PT1udWxsJiZOLkRzdD09PW51bGwmJk4uTGZhY2U9PT1udWxsJiZOLlJmYWNlPT09bnVsbCl9fSxpLnZlcnRFcT1mdW5jdGlvbihzLGMpe3JldHVybiBzLnM9PT1jLnMmJnMudD09PWMudH0saS52ZXJ0TGVxPWZ1bmN0aW9uKHMsYyl7cmV0dXJuIHMuczxjLnN8fHMucz09PWMucyYmcy50PD1jLnR9LGkudHJhbnNMZXE9ZnVuY3Rpb24ocyxjKXtyZXR1cm4gcy50PGMudHx8cy50PT09Yy50JiZzLnM8PWMuc30saS5lZGdlR29lc0xlZnQ9ZnVuY3Rpb24ocyl7cmV0dXJuIGkudmVydExlcShzLkRzdCxzLk9yZyl9LGkuZWRnZUdvZXNSaWdodD1mdW5jdGlvbihzKXtyZXR1cm4gaS52ZXJ0TGVxKHMuT3JnLHMuRHN0KX0saS52ZXJ0TDFkaXN0PWZ1bmN0aW9uKHMsYyl7cmV0dXJuIE1hdGguYWJzKHMucy1jLnMpK01hdGguYWJzKHMudC1jLnQpfSxpLmVkZ2VFdmFsPWZ1bmN0aW9uKHMsYyxsKXtmKGkudmVydExlcShzLGMpJiZpLnZlcnRMZXEoYyxsKSk7dmFyIHY9Yy5zLXMucyxUPWwucy1jLnM7cmV0dXJuIHYrVD4wP3Y8VD9jLnQtcy50KyhzLnQtbC50KSoodi8oditUKSk6Yy50LWwudCsobC50LXMudCkqKFQvKHYrVCkpOjB9LGkuZWRnZVNpZ249ZnVuY3Rpb24ocyxjLGwpe2YoaS52ZXJ0TGVxKHMsYykmJmkudmVydExlcShjLGwpKTt2YXIgdj1jLnMtcy5zLFQ9bC5zLWMucztyZXR1cm4gditUPjA/KGMudC1sLnQpKnYrKGMudC1zLnQpKlQ6MH0saS50cmFuc0V2YWw9ZnVuY3Rpb24ocyxjLGwpe2YoaS50cmFuc0xlcShzLGMpJiZpLnRyYW5zTGVxKGMsbCkpO3ZhciB2PWMudC1zLnQsVD1sLnQtYy50O3JldHVybiB2K1Q+MD92PFQ/Yy5zLXMucysocy5zLWwucykqKHYvKHYrVCkpOmMucy1sLnMrKGwucy1zLnMpKihULyh2K1QpKTowfSxpLnRyYW5zU2lnbj1mdW5jdGlvbihzLGMsbCl7ZihpLnRyYW5zTGVxKHMsYykmJmkudHJhbnNMZXEoYyxsKSk7dmFyIHY9Yy50LXMudCxUPWwudC1jLnQ7cmV0dXJuIHYrVD4wPyhjLnMtbC5zKSp2KyhjLnMtcy5zKSpUOjB9LGkudmVydENDVz1mdW5jdGlvbihzLGMsbCl7cmV0dXJuIHMucyooYy50LWwudCkrYy5zKihsLnQtcy50KStsLnMqKHMudC1jLnQpPj0wfSxpLmludGVycG9sYXRlPWZ1bmN0aW9uKHMsYyxsLHYpe3JldHVybiBzPXM8MD8wOnMsbD1sPDA/MDpsLHM8PWw/bD09PTA/KGMrdikvMjpjKyh2LWMpKihzLyhzK2wpKTp2KyhjLXYpKihsLyhzK2wpKX0saS5pbnRlcnNlY3Q9ZnVuY3Rpb24ocyxjLGwsdixUKXt2YXIgUixMLE47aS52ZXJ0TGVxKHMsYyl8fChOPXMscz1jLGM9TiksaS52ZXJ0TGVxKGwsdil8fChOPWwsbD12LHY9TiksaS52ZXJ0TGVxKHMsbCl8fChOPXMscz1sLGw9TixOPWMsYz12LHY9TiksaS52ZXJ0TGVxKGwsYyk/aS52ZXJ0TGVxKGMsdik/KFI9aS5lZGdlRXZhbChzLGwsYyksTD1pLmVkZ2VFdmFsKGwsYyx2KSxSK0w8MCYmKFI9LVIsTD0tTCksVC5zPWkuaW50ZXJwb2xhdGUoUixsLnMsTCxjLnMpKTooUj1pLmVkZ2VTaWduKHMsbCxjKSxMPS1pLmVkZ2VTaWduKHMsdixjKSxSK0w8MCYmKFI9LVIsTD0tTCksVC5zPWkuaW50ZXJwb2xhdGUoUixsLnMsTCx2LnMpKTpULnM9KGwucytjLnMpLzIsaS50cmFuc0xlcShzLGMpfHwoTj1zLHM9YyxjPU4pLGkudHJhbnNMZXEobCx2KXx8KE49bCxsPXYsdj1OKSxpLnRyYW5zTGVxKHMsbCl8fChOPXMscz1sLGw9TixOPWMsYz12LHY9TiksaS50cmFuc0xlcShsLGMpP2kudHJhbnNMZXEoYyx2KT8oUj1pLnRyYW5zRXZhbChzLGwsYyksTD1pLnRyYW5zRXZhbChsLGMsdiksUitMPDAmJihSPS1SLEw9LUwpLFQudD1pLmludGVycG9sYXRlKFIsbC50LEwsYy50KSk6KFI9aS50cmFuc1NpZ24ocyxsLGMpLEw9LWkudHJhbnNTaWduKHMsdixjKSxSK0w8MCYmKFI9LVIsTD0tTCksVC50PWkuaW50ZXJwb2xhdGUoUixsLnQsTCx2LnQpKTpULnQ9KGwudCtjLnQpLzJ9O2Z1bmN0aW9uIEUoKXt0aGlzLmtleT1udWxsLHRoaXMubmV4dD1udWxsLHRoaXMucHJldj1udWxsfWZ1bmN0aW9uIHAocyxjKXt0aGlzLmhlYWQ9bmV3IEUsdGhpcy5oZWFkLm5leHQ9dGhpcy5oZWFkLHRoaXMuaGVhZC5wcmV2PXRoaXMuaGVhZCx0aGlzLmZyYW1lPXMsdGhpcy5sZXE9Y31wLnByb3RvdHlwZT17bWluOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaGVhZC5uZXh0fSxtYXg6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5oZWFkLnByZXZ9LGluc2VydDpmdW5jdGlvbihzKXtyZXR1cm4gdGhpcy5pbnNlcnRCZWZvcmUodGhpcy5oZWFkLHMpfSxzZWFyY2g6ZnVuY3Rpb24ocyl7dmFyIGM9dGhpcy5oZWFkO2RvIGM9Yy5uZXh0O3doaWxlKGMua2V5IT09bnVsbCYmIXRoaXMubGVxKHRoaXMuZnJhbWUscyxjLmtleSkpO3JldHVybiBjfSxpbnNlcnRCZWZvcmU6ZnVuY3Rpb24ocyxjKXtkbyBzPXMucHJldjt3aGlsZShzLmtleSE9PW51bGwmJiF0aGlzLmxlcSh0aGlzLmZyYW1lLHMua2V5LGMpKTt2YXIgbD1uZXcgRTtyZXR1cm4gbC5rZXk9YyxsLm5leHQ9cy5uZXh0LHMubmV4dC5wcmV2PWwsbC5wcmV2PXMscy5uZXh0PWwsbH0sZGVsZXRlOmZ1bmN0aW9uKHMpe3MubmV4dC5wcmV2PXMucHJldixzLnByZXYubmV4dD1zLm5leHR9fTtmdW5jdGlvbiBPKCl7dGhpcy5oYW5kbGU9bnVsbH1mdW5jdGlvbiBtKCl7dGhpcy5rZXk9bnVsbCx0aGlzLm5vZGU9bnVsbH1mdW5jdGlvbiBiKHMsYyl7dGhpcy5zaXplPTAsdGhpcy5tYXg9cyx0aGlzLm5vZGVzPVtdLHRoaXMubm9kZXMubGVuZ3RoPXMrMTt2YXIgbDtmb3IobD0wO2w8dGhpcy5ub2Rlcy5sZW5ndGg7bCsrKXRoaXMubm9kZXNbbF09bmV3IE87Zm9yKHRoaXMuaGFuZGxlcz1bXSx0aGlzLmhhbmRsZXMubGVuZ3RoPXMrMSxsPTA7bDx0aGlzLmhhbmRsZXMubGVuZ3RoO2wrKyl0aGlzLmhhbmRsZXNbbF09bmV3IG07dGhpcy5pbml0aWFsaXplZD0hMSx0aGlzLmZyZWVMaXN0PTAsdGhpcy5sZXE9Yyx0aGlzLm5vZGVzWzFdLmhhbmRsZT0xLHRoaXMuaGFuZGxlc1sxXS5rZXk9bnVsbH1iLnByb3RvdHlwZT17ZmxvYXREb3duXzpmdW5jdGlvbihzKXt2YXIgYz10aGlzLm5vZGVzLGw9dGhpcy5oYW5kbGVzLHYsVCxSO2Zvcih2PWNbc10uaGFuZGxlOzspe2lmKFI9czw8MSxSPHRoaXMuc2l6ZSYmdGhpcy5sZXEobFtjW1IrMV0uaGFuZGxlXS5rZXksbFtjW1JdLmhhbmRsZV0ua2V5KSYmKytSLGYoUjw9dGhpcy5tYXgpLFQ9Y1tSXS5oYW5kbGUsUj50aGlzLnNpemV8fHRoaXMubGVxKGxbdl0ua2V5LGxbVF0ua2V5KSl7Y1tzXS5oYW5kbGU9dixsW3ZdLm5vZGU9czticmVha31jW3NdLmhhbmRsZT1ULGxbVF0ubm9kZT1zLHM9Un19LGZsb2F0VXBfOmZ1bmN0aW9uKHMpe3ZhciBjPXRoaXMubm9kZXMsbD10aGlzLmhhbmRsZXMsdixULFI7Zm9yKHY9Y1tzXS5oYW5kbGU7Oyl7aWYoUj1zPj4xLFQ9Y1tSXS5oYW5kbGUsUj09PTB8fHRoaXMubGVxKGxbVF0ua2V5LGxbdl0ua2V5KSl7Y1tzXS5oYW5kbGU9dixsW3ZdLm5vZGU9czticmVha31jW3NdLmhhbmRsZT1ULGxbVF0ubm9kZT1zLHM9Un19LGluaXQ6ZnVuY3Rpb24oKXtmb3IodmFyIHM9dGhpcy5zaXplO3M+PTE7LS1zKXRoaXMuZmxvYXREb3duXyhzKTt0aGlzLmluaXRpYWxpemVkPSEwfSxtaW46ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5oYW5kbGVzW3RoaXMubm9kZXNbMV0uaGFuZGxlXS5rZXl9LGluc2VydDpmdW5jdGlvbihzKXt2YXIgYyxsO2lmKGM9Kyt0aGlzLnNpemUsYyoyPnRoaXMubWF4KXt0aGlzLm1heCo9Mjt2YXIgdixUO2ZvcihUPXRoaXMubm9kZXMubGVuZ3RoLHRoaXMubm9kZXMubGVuZ3RoPXRoaXMubWF4KzEsdj1UO3Y8dGhpcy5ub2Rlcy5sZW5ndGg7disrKXRoaXMubm9kZXNbdl09bmV3IE87Zm9yKFQ9dGhpcy5oYW5kbGVzLmxlbmd0aCx0aGlzLmhhbmRsZXMubGVuZ3RoPXRoaXMubWF4KzEsdj1UO3Y8dGhpcy5oYW5kbGVzLmxlbmd0aDt2KyspdGhpcy5oYW5kbGVzW3ZdPW5ldyBtfXJldHVybiB0aGlzLmZyZWVMaXN0PT09MD9sPWM6KGw9dGhpcy5mcmVlTGlzdCx0aGlzLmZyZWVMaXN0PXRoaXMuaGFuZGxlc1tsXS5ub2RlKSx0aGlzLm5vZGVzW2NdLmhhbmRsZT1sLHRoaXMuaGFuZGxlc1tsXS5ub2RlPWMsdGhpcy5oYW5kbGVzW2xdLmtleT1zLHRoaXMuaW5pdGlhbGl6ZWQmJnRoaXMuZmxvYXRVcF8oYyksbH0sZXh0cmFjdE1pbjpmdW5jdGlvbigpe3ZhciBzPXRoaXMubm9kZXMsYz10aGlzLmhhbmRsZXMsbD1zWzFdLmhhbmRsZSx2PWNbbF0ua2V5O3JldHVybiB0aGlzLnNpemU+MCYmKHNbMV0uaGFuZGxlPXNbdGhpcy5zaXplXS5oYW5kbGUsY1tzWzFdLmhhbmRsZV0ubm9kZT0xLGNbbF0ua2V5PW51bGwsY1tsXS5ub2RlPXRoaXMuZnJlZUxpc3QsdGhpcy5mcmVlTGlzdD1sLC0tdGhpcy5zaXplLHRoaXMuc2l6ZT4wJiZ0aGlzLmZsb2F0RG93bl8oMSkpLHZ9LGRlbGV0ZTpmdW5jdGlvbihzKXt2YXIgYz10aGlzLm5vZGVzLGw9dGhpcy5oYW5kbGVzLHY7ZihzPj0xJiZzPD10aGlzLm1heCYmbFtzXS5rZXkhPT1udWxsKSx2PWxbc10ubm9kZSxjW3ZdLmhhbmRsZT1jW3RoaXMuc2l6ZV0uaGFuZGxlLGxbY1t2XS5oYW5kbGVdLm5vZGU9diwtLXRoaXMuc2l6ZSx2PD10aGlzLnNpemUmJih2PD0xfHx0aGlzLmxlcShsW2Nbdj4+MV0uaGFuZGxlXS5rZXksbFtjW3ZdLmhhbmRsZV0ua2V5KT90aGlzLmZsb2F0RG93bl8odik6dGhpcy5mbG9hdFVwXyh2KSksbFtzXS5rZXk9bnVsbCxsW3NdLm5vZGU9dGhpcy5mcmVlTGlzdCx0aGlzLmZyZWVMaXN0PXN9fTtmdW5jdGlvbiBNKCl7dGhpcy5lVXA9bnVsbCx0aGlzLm5vZGVVcD1udWxsLHRoaXMud2luZGluZ051bWJlcj0wLHRoaXMuaW5zaWRlPSExLHRoaXMuc2VudGluZWw9ITEsdGhpcy5kaXJ0eT0hMSx0aGlzLmZpeFVwcGVyRWRnZT0hMX12YXIgeT17fTt5LnJlZ2lvbkJlbG93PWZ1bmN0aW9uKHMpe3JldHVybiBzLm5vZGVVcC5wcmV2LmtleX0seS5yZWdpb25BYm92ZT1mdW5jdGlvbihzKXtyZXR1cm4gcy5ub2RlVXAubmV4dC5rZXl9LHkuZGVidWdFdmVudD1mdW5jdGlvbihzKXt9LHkuYWRkV2luZGluZz1mdW5jdGlvbihzLGMpe3Mud2luZGluZys9Yy53aW5kaW5nLHMuU3ltLndpbmRpbmcrPWMuU3ltLndpbmRpbmd9LHkuZWRnZUxlcT1mdW5jdGlvbihzLGMsbCl7dmFyIHY9cy5ldmVudCxMLE4sVD1jLmVVcCxSPWwuZVVwO2lmKFQuRHN0PT09dilyZXR1cm4gUi5Ec3Q9PT12P2kudmVydExlcShULk9yZyxSLk9yZyk/aS5lZGdlU2lnbihSLkRzdCxULk9yZyxSLk9yZyk8PTA6aS5lZGdlU2lnbihULkRzdCxSLk9yZyxULk9yZyk+PTA6aS5lZGdlU2lnbihSLkRzdCx2LFIuT3JnKTw9MDtpZihSLkRzdD09PXYpcmV0dXJuIGkuZWRnZVNpZ24oVC5Ec3QsdixULk9yZyk+PTA7dmFyIEw9aS5lZGdlRXZhbChULkRzdCx2LFQuT3JnKSxOPWkuZWRnZUV2YWwoUi5Ec3QsdixSLk9yZyk7cmV0dXJuIEw+PU59LHkuZGVsZXRlUmVnaW9uPWZ1bmN0aW9uKHMsYyl7Yy5maXhVcHBlckVkZ2UmJmYoYy5lVXAud2luZGluZz09PTApLGMuZVVwLmFjdGl2ZVJlZ2lvbj1udWxsLHMuZGljdC5kZWxldGUoYy5ub2RlVXApfSx5LmZpeFVwcGVyRWRnZT1mdW5jdGlvbihzLGMsbCl7ZihjLmZpeFVwcGVyRWRnZSkscy5tZXNoLmRlbGV0ZShjLmVVcCksYy5maXhVcHBlckVkZ2U9ITEsYy5lVXA9bCxsLmFjdGl2ZVJlZ2lvbj1jfSx5LnRvcExlZnRSZWdpb249ZnVuY3Rpb24ocyxjKXt2YXIgbD1jLmVVcC5PcmcsdjtkbyBjPXkucmVnaW9uQWJvdmUoYyk7d2hpbGUoYy5lVXAuT3JnPT09bCk7aWYoYy5maXhVcHBlckVkZ2Upe2lmKHY9cy5tZXNoLmNvbm5lY3QoeS5yZWdpb25CZWxvdyhjKS5lVXAuU3ltLGMuZVVwLkxuZXh0KSx2PT09bnVsbClyZXR1cm4gbnVsbDt5LmZpeFVwcGVyRWRnZShzLGMsdiksYz15LnJlZ2lvbkFib3ZlKGMpfXJldHVybiBjfSx5LnRvcFJpZ2h0UmVnaW9uPWZ1bmN0aW9uKHMpe3ZhciBjPXMuZVVwLkRzdDtkbyBzPXkucmVnaW9uQWJvdmUocyk7d2hpbGUocy5lVXAuRHN0PT09Yyk7cmV0dXJuIHN9LHkuYWRkUmVnaW9uQmVsb3c9ZnVuY3Rpb24ocyxjLGwpe3ZhciB2PW5ldyBNO3JldHVybiB2LmVVcD1sLHYubm9kZVVwPXMuZGljdC5pbnNlcnRCZWZvcmUoYy5ub2RlVXAsdiksdi5maXhVcHBlckVkZ2U9ITEsdi5zZW50aW5lbD0hMSx2LmRpcnR5PSExLGwuYWN0aXZlUmVnaW9uPXYsdn0seS5pc1dpbmRpbmdJbnNpZGU9ZnVuY3Rpb24ocyxjKXtzd2l0Y2gocy53aW5kaW5nUnVsZSl7Y2FzZSBuLldJTkRJTkdfT0REOnJldHVybihjJjEpIT09MDtjYXNlIG4uV0lORElOR19OT05aRVJPOnJldHVybiBjIT09MDtjYXNlIG4uV0lORElOR19QT1NJVElWRTpyZXR1cm4gYz4wO2Nhc2Ugbi5XSU5ESU5HX05FR0FUSVZFOnJldHVybiBjPDA7Y2FzZSBuLldJTkRJTkdfQUJTX0dFUV9UV086cmV0dXJuIGM+PTJ8fGM8PS0yfXJldHVybiBmKCExKSwhMX0seS5jb21wdXRlV2luZGluZz1mdW5jdGlvbihzLGMpe2Mud2luZGluZ051bWJlcj15LnJlZ2lvbkFib3ZlKGMpLndpbmRpbmdOdW1iZXIrYy5lVXAud2luZGluZyxjLmluc2lkZT15LmlzV2luZGluZ0luc2lkZShzLGMud2luZGluZ051bWJlcil9LHkuZmluaXNoUmVnaW9uPWZ1bmN0aW9uKHMsYyl7dmFyIGw9Yy5lVXAsdj1sLkxmYWNlO3YuaW5zaWRlPWMuaW5zaWRlLHYuYW5FZGdlPWwseS5kZWxldGVSZWdpb24ocyxjKX0seS5maW5pc2hMZWZ0UmVnaW9ucz1mdW5jdGlvbihzLGMsbCl7Zm9yKHZhciB2LEwsVD1udWxsLFI9YyxMPWMuZVVwO1IhPT1sOyl7aWYoUi5maXhVcHBlckVkZ2U9ITEsVD15LnJlZ2lvbkJlbG93KFIpLHY9VC5lVXAsdi5PcmchPUwuT3JnKXtpZighVC5maXhVcHBlckVkZ2Upe3kuZmluaXNoUmVnaW9uKHMsUik7YnJlYWt9dj1zLm1lc2guY29ubmVjdChMLkxwcmV2LHYuU3ltKSx5LmZpeFVwcGVyRWRnZShzLFQsdil9TC5PbmV4dCE9PXYmJihzLm1lc2guc3BsaWNlKHYuT3ByZXYsdikscy5tZXNoLnNwbGljZShMLHYpKSx5LmZpbmlzaFJlZ2lvbihzLFIpLEw9VC5lVXAsUj1UfXJldHVybiBMfSx5LmFkZFJpZ2h0RWRnZXM9ZnVuY3Rpb24ocyxjLGwsdixULFIpe3ZhciBMLE4sQSx3LEI9ITA7QT1sO2RvIGYoaS52ZXJ0TGVxKEEuT3JnLEEuRHN0KSkseS5hZGRSZWdpb25CZWxvdyhzLGMsQS5TeW0pLEE9QS5PbmV4dDt3aGlsZShBIT09dik7Zm9yKFQ9PT1udWxsJiYoVD15LnJlZ2lvbkJlbG93KGMpLmVVcC5ScHJldiksTj1jLHc9VDtMPXkucmVnaW9uQmVsb3coTiksQT1MLmVVcC5TeW0sQS5Pcmc9PT13Lk9yZzspQS5PbmV4dCE9PXcmJihzLm1lc2guc3BsaWNlKEEuT3ByZXYsQSkscy5tZXNoLnNwbGljZSh3Lk9wcmV2LEEpKSxMLndpbmRpbmdOdW1iZXI9Ti53aW5kaW5nTnVtYmVyLUEud2luZGluZyxMLmluc2lkZT15LmlzV2luZGluZ0luc2lkZShzLEwud2luZGluZ051bWJlciksTi5kaXJ0eT0hMCwhQiYmeS5jaGVja0ZvclJpZ2h0U3BsaWNlKHMsTikmJih5LmFkZFdpbmRpbmcoQSx3KSx5LmRlbGV0ZVJlZ2lvbihzLE4pLHMubWVzaC5kZWxldGUodykpLEI9ITEsTj1MLHc9QTtOLmRpcnR5PSEwLGYoTi53aW5kaW5nTnVtYmVyLUEud2luZGluZz09PUwud2luZGluZ051bWJlciksUiYmeS53YWxrRGlydHlSZWdpb25zKHMsTil9LHkuc3BsaWNlTWVyZ2VWZXJ0aWNlcz1mdW5jdGlvbihzLGMsbCl7cy5tZXNoLnNwbGljZShjLGwpfSx5LnZlcnRleFdlaWdodHM9ZnVuY3Rpb24ocyxjLGwpe3ZhciB2PWkudmVydEwxZGlzdChjLHMpLFQ9aS52ZXJ0TDFkaXN0KGwscyksUj0uNSpULyh2K1QpLEw9LjUqdi8oditUKTtzLmNvb3Jkc1swXSs9UipjLmNvb3Jkc1swXStMKmwuY29vcmRzWzBdLHMuY29vcmRzWzFdKz1SKmMuY29vcmRzWzFdK0wqbC5jb29yZHNbMV0scy5jb29yZHNbMl0rPVIqYy5jb29yZHNbMl0rTCpsLmNvb3Jkc1syXX0seS5nZXRJbnRlcnNlY3REYXRhPWZ1bmN0aW9uKHMsYyxsLHYsVCxSKXtjLmNvb3Jkc1swXT1jLmNvb3Jkc1sxXT1jLmNvb3Jkc1syXT0wLGMuaWR4PS0xLHkudmVydGV4V2VpZ2h0cyhjLGwsdikseS52ZXJ0ZXhXZWlnaHRzKGMsVCxSKX0seS5jaGVja0ZvclJpZ2h0U3BsaWNlPWZ1bmN0aW9uKHMsYyl7dmFyIGw9eS5yZWdpb25CZWxvdyhjKSx2PWMuZVVwLFQ9bC5lVXA7aWYoaS52ZXJ0TGVxKHYuT3JnLFQuT3JnKSl7aWYoaS5lZGdlU2lnbihULkRzdCx2Lk9yZyxULk9yZyk+MClyZXR1cm4hMTtpLnZlcnRFcSh2Lk9yZyxULk9yZyk/di5PcmchPT1ULk9yZyYmKHMucHEuZGVsZXRlKHYuT3JnLnBxSGFuZGxlKSx5LnNwbGljZU1lcmdlVmVydGljZXMocyxULk9wcmV2LHYpKToocy5tZXNoLnNwbGl0RWRnZShULlN5bSkscy5tZXNoLnNwbGljZSh2LFQuT3ByZXYpLGMuZGlydHk9bC5kaXJ0eT0hMCl9ZWxzZXtpZihpLmVkZ2VTaWduKHYuRHN0LFQuT3JnLHYuT3JnKTwwKXJldHVybiExO3kucmVnaW9uQWJvdmUoYykuZGlydHk9Yy5kaXJ0eT0hMCxzLm1lc2guc3BsaXRFZGdlKHYuU3ltKSxzLm1lc2guc3BsaWNlKFQuT3ByZXYsdil9cmV0dXJuITB9LHkuY2hlY2tGb3JMZWZ0U3BsaWNlPWZ1bmN0aW9uKHMsYyl7dmFyIGw9eS5yZWdpb25CZWxvdyhjKSx2PWMuZVVwLFQ9bC5lVXAsUjtpZihmKCFpLnZlcnRFcSh2LkRzdCxULkRzdCkpLGkudmVydExlcSh2LkRzdCxULkRzdCkpe2lmKGkuZWRnZVNpZ24odi5Ec3QsVC5Ec3Qsdi5PcmcpPDApcmV0dXJuITE7eS5yZWdpb25BYm92ZShjKS5kaXJ0eT1jLmRpcnR5PSEwLFI9cy5tZXNoLnNwbGl0RWRnZSh2KSxzLm1lc2guc3BsaWNlKFQuU3ltLFIpLFIuTGZhY2UuaW5zaWRlPWMuaW5zaWRlfWVsc2V7aWYoaS5lZGdlU2lnbihULkRzdCx2LkRzdCxULk9yZyk+MClyZXR1cm4hMTtjLmRpcnR5PWwuZGlydHk9ITAsUj1zLm1lc2guc3BsaXRFZGdlKFQpLHMubWVzaC5zcGxpY2Uodi5MbmV4dCxULlN5bSksUi5SZmFjZS5pbnNpZGU9Yy5pbnNpZGV9cmV0dXJuITB9LHkuY2hlY2tGb3JJbnRlcnNlY3Q9ZnVuY3Rpb24ocyxjKXt2YXIgbD15LnJlZ2lvbkJlbG93KGMpLHY9Yy5lVXAsVD1sLmVVcCxSPXYuT3JnLEw9VC5PcmcsTj12LkRzdCxBPVQuRHN0LHcsQixEPW5ldyBoLEksajtpZihmKCFpLnZlcnRFcShBLE4pKSxmKGkuZWRnZVNpZ24oTixzLmV2ZW50LFIpPD0wKSxmKGkuZWRnZVNpZ24oQSxzLmV2ZW50LEwpPj0wKSxmKFIhPT1zLmV2ZW50JiZMIT09cy5ldmVudCksZighYy5maXhVcHBlckVkZ2UmJiFsLmZpeFVwcGVyRWRnZSksUj09PUx8fCh3PU1hdGgubWluKFIudCxOLnQpLEI9TWF0aC5tYXgoTC50LEEudCksdz5CKSlyZXR1cm4hMTtpZihpLnZlcnRMZXEoUixMKSl7aWYoaS5lZGdlU2lnbihBLFIsTCk+MClyZXR1cm4hMX1lbHNlIGlmKGkuZWRnZVNpZ24oTixMLFIpPDApcmV0dXJuITE7cmV0dXJuIHkuZGVidWdFdmVudChzKSxpLmludGVyc2VjdChOLFIsQSxMLEQpLGYoTWF0aC5taW4oUi50LE4udCk8PUQudCksZihELnQ8PU1hdGgubWF4KEwudCxBLnQpKSxmKE1hdGgubWluKEEucyxOLnMpPD1ELnMpLGYoRC5zPD1NYXRoLm1heChMLnMsUi5zKSksaS52ZXJ0TGVxKEQscy5ldmVudCkmJihELnM9cy5ldmVudC5zLEQudD1zLmV2ZW50LnQpLEk9aS52ZXJ0TGVxKFIsTCk/UjpMLGkudmVydExlcShJLEQpJiYoRC5zPUkucyxELnQ9SS50KSxpLnZlcnRFcShELFIpfHxpLnZlcnRFcShELEwpPyh5LmNoZWNrRm9yUmlnaHRTcGxpY2UocyxjKSwhMSk6IWkudmVydEVxKE4scy5ldmVudCkmJmkuZWRnZVNpZ24oTixzLmV2ZW50LEQpPj0wfHwhaS52ZXJ0RXEoQSxzLmV2ZW50KSYmaS5lZGdlU2lnbihBLHMuZXZlbnQsRCk8PTA/QT09PXMuZXZlbnQ/KHMubWVzaC5zcGxpdEVkZ2Uodi5TeW0pLHMubWVzaC5zcGxpY2UoVC5TeW0sdiksYz15LnRvcExlZnRSZWdpb24ocyxjKSx2PXkucmVnaW9uQmVsb3coYykuZVVwLHkuZmluaXNoTGVmdFJlZ2lvbnMocyx5LnJlZ2lvbkJlbG93KGMpLGwpLHkuYWRkUmlnaHRFZGdlcyhzLGMsdi5PcHJldix2LHYsITApLCEwKTpOPT09cy5ldmVudD8ocy5tZXNoLnNwbGl0RWRnZShULlN5bSkscy5tZXNoLnNwbGljZSh2LkxuZXh0LFQuT3ByZXYpLGw9YyxjPXkudG9wUmlnaHRSZWdpb24oYyksaj15LnJlZ2lvbkJlbG93KGMpLmVVcC5ScHJldixsLmVVcD1ULk9wcmV2LFQ9eS5maW5pc2hMZWZ0UmVnaW9ucyhzLGwsbnVsbCkseS5hZGRSaWdodEVkZ2VzKHMsYyxULk9uZXh0LHYuUnByZXYsaiwhMCksITApOihpLmVkZ2VTaWduKE4scy5ldmVudCxEKT49MCYmKHkucmVnaW9uQWJvdmUoYykuZGlydHk9Yy5kaXJ0eT0hMCxzLm1lc2guc3BsaXRFZGdlKHYuU3ltKSx2Lk9yZy5zPXMuZXZlbnQucyx2Lk9yZy50PXMuZXZlbnQudCksaS5lZGdlU2lnbihBLHMuZXZlbnQsRCk8PTAmJihjLmRpcnR5PWwuZGlydHk9ITAscy5tZXNoLnNwbGl0RWRnZShULlN5bSksVC5Pcmcucz1zLmV2ZW50LnMsVC5PcmcudD1zLmV2ZW50LnQpLCExKToocy5tZXNoLnNwbGl0RWRnZSh2LlN5bSkscy5tZXNoLnNwbGl0RWRnZShULlN5bSkscy5tZXNoLnNwbGljZShULk9wcmV2LHYpLHYuT3JnLnM9RC5zLHYuT3JnLnQ9RC50LHYuT3JnLnBxSGFuZGxlPXMucHEuaW5zZXJ0KHYuT3JnKSx5LmdldEludGVyc2VjdERhdGEocyx2Lk9yZyxSLE4sTCxBKSx5LnJlZ2lvbkFib3ZlKGMpLmRpcnR5PWMuZGlydHk9bC5kaXJ0eT0hMCwhMSl9LHkud2Fsa0RpcnR5UmVnaW9ucz1mdW5jdGlvbihzLGMpe2Zvcih2YXIgbD15LnJlZ2lvbkJlbG93KGMpLHYsVDs7KXtmb3IoO2wuZGlydHk7KWM9bCxsPXkucmVnaW9uQmVsb3cobCk7aWYoIWMuZGlydHkmJihsPWMsYz15LnJlZ2lvbkFib3ZlKGMpLGM9PT1udWxsfHwhYy5kaXJ0eSkpcmV0dXJuO2lmKGMuZGlydHk9ITEsdj1jLmVVcCxUPWwuZVVwLHYuRHN0IT09VC5Ec3QmJnkuY2hlY2tGb3JMZWZ0U3BsaWNlKHMsYykmJihsLmZpeFVwcGVyRWRnZT8oeS5kZWxldGVSZWdpb24ocyxsKSxzLm1lc2guZGVsZXRlKFQpLGw9eS5yZWdpb25CZWxvdyhjKSxUPWwuZVVwKTpjLmZpeFVwcGVyRWRnZSYmKHkuZGVsZXRlUmVnaW9uKHMsYykscy5tZXNoLmRlbGV0ZSh2KSxjPXkucmVnaW9uQWJvdmUobCksdj1jLmVVcCkpLHYuT3JnIT09VC5PcmcpaWYodi5Ec3QhPT1ULkRzdCYmIWMuZml4VXBwZXJFZGdlJiYhbC5maXhVcHBlckVkZ2UmJih2LkRzdD09PXMuZXZlbnR8fFQuRHN0PT09cy5ldmVudCkpe2lmKHkuY2hlY2tGb3JJbnRlcnNlY3QocyxjKSlyZXR1cm59ZWxzZSB5LmNoZWNrRm9yUmlnaHRTcGxpY2UocyxjKTt2Lk9yZz09PVQuT3JnJiZ2LkRzdD09PVQuRHN0JiYoeS5hZGRXaW5kaW5nKFQsdikseS5kZWxldGVSZWdpb24ocyxjKSxzLm1lc2guZGVsZXRlKHYpLGM9eS5yZWdpb25BYm92ZShsKSl9fSx5LmNvbm5lY3RSaWdodFZlcnRleD1mdW5jdGlvbihzLGMsbCl7dmFyIHYsVD1sLk9uZXh0LFI9eS5yZWdpb25CZWxvdyhjKSxMPWMuZVVwLE49Ui5lVXAsQT0hMTtpZihMLkRzdCE9PU4uRHN0JiZ5LmNoZWNrRm9ySW50ZXJzZWN0KHMsYyksaS52ZXJ0RXEoTC5Pcmcscy5ldmVudCkmJihzLm1lc2guc3BsaWNlKFQuT3ByZXYsTCksYz15LnRvcExlZnRSZWdpb24ocyxjKSxUPXkucmVnaW9uQmVsb3coYykuZVVwLHkuZmluaXNoTGVmdFJlZ2lvbnMocyx5LnJlZ2lvbkJlbG93KGMpLFIpLEE9ITApLGkudmVydEVxKE4uT3JnLHMuZXZlbnQpJiYocy5tZXNoLnNwbGljZShsLE4uT3ByZXYpLGw9eS5maW5pc2hMZWZ0UmVnaW9ucyhzLFIsbnVsbCksQT0hMCksQSl7eS5hZGRSaWdodEVkZ2VzKHMsYyxsLk9uZXh0LFQsVCwhMCk7cmV0dXJufWkudmVydExlcShOLk9yZyxMLk9yZyk/dj1OLk9wcmV2OnY9TCx2PXMubWVzaC5jb25uZWN0KGwuTHByZXYsdikseS5hZGRSaWdodEVkZ2VzKHMsYyx2LHYuT25leHQsdi5PbmV4dCwhMSksdi5TeW0uYWN0aXZlUmVnaW9uLmZpeFVwcGVyRWRnZT0hMCx5LndhbGtEaXJ0eVJlZ2lvbnMocyxjKX0seS5jb25uZWN0TGVmdERlZ2VuZXJhdGU9ZnVuY3Rpb24ocyxjLGwpe3ZhciB2LFQsUixMLE47aWYodj1jLmVVcCxpLnZlcnRFcSh2Lk9yZyxsKSl7ZighMSkseS5zcGxpY2VNZXJnZVZlcnRpY2VzKHMsdixsLmFuRWRnZSk7cmV0dXJufWlmKCFpLnZlcnRFcSh2LkRzdCxsKSl7cy5tZXNoLnNwbGl0RWRnZSh2LlN5bSksYy5maXhVcHBlckVkZ2UmJihzLm1lc2guZGVsZXRlKHYuT25leHQpLGMuZml4VXBwZXJFZGdlPSExKSxzLm1lc2guc3BsaWNlKGwuYW5FZGdlLHYpLHkuc3dlZXBFdmVudChzLGwpO3JldHVybn1mKCExKSxjPXkudG9wUmlnaHRSZWdpb24oYyksTj15LnJlZ2lvbkJlbG93KGMpLFI9Ti5lVXAuU3ltLFQ9TD1SLk9uZXh0LE4uZml4VXBwZXJFZGdlJiYoZihUIT09UikseS5kZWxldGVSZWdpb24ocyxOKSxzLm1lc2guZGVsZXRlKFIpLFI9VC5PcHJldikscy5tZXNoLnNwbGljZShsLmFuRWRnZSxSKSxpLmVkZ2VHb2VzTGVmdChUKXx8KFQ9bnVsbCkseS5hZGRSaWdodEVkZ2VzKHMsYyxSLk9uZXh0LEwsVCwhMCl9LHkuY29ubmVjdExlZnRWZXJ0ZXg9ZnVuY3Rpb24ocyxjKXt2YXIgbCx2LFQsUixMLE4sQT1uZXcgTTtpZihBLmVVcD1jLmFuRWRnZS5TeW0sbD1zLmRpY3Quc2VhcmNoKEEpLmtleSx2PXkucmVnaW9uQmVsb3cobCksISF2KXtpZihSPWwuZVVwLEw9di5lVXAsaS5lZGdlU2lnbihSLkRzdCxjLFIuT3JnKT09PTApe3kuY29ubmVjdExlZnREZWdlbmVyYXRlKHMsbCxjKTtyZXR1cm59aWYoVD1pLnZlcnRMZXEoTC5Ec3QsUi5Ec3QpP2w6dixsLmluc2lkZXx8VC5maXhVcHBlckVkZ2Upe2lmKFQ9PT1sKU49cy5tZXNoLmNvbm5lY3QoYy5hbkVkZ2UuU3ltLFIuTG5leHQpO2Vsc2V7dmFyIHc9cy5tZXNoLmNvbm5lY3QoTC5EbmV4dCxjLmFuRWRnZSk7Tj13LlN5bX1ULmZpeFVwcGVyRWRnZT95LmZpeFVwcGVyRWRnZShzLFQsTik6eS5jb21wdXRlV2luZGluZyhzLHkuYWRkUmVnaW9uQmVsb3cocyxsLE4pKSx5LnN3ZWVwRXZlbnQocyxjKX1lbHNlIHkuYWRkUmlnaHRFZGdlcyhzLGwsYy5hbkVkZ2UsYy5hbkVkZ2UsbnVsbCwhMCl9fSx5LnN3ZWVwRXZlbnQ9ZnVuY3Rpb24ocyxjKXtzLmV2ZW50PWMseS5kZWJ1Z0V2ZW50KHMpO2Zvcih2YXIgbD1jLmFuRWRnZTtsLmFjdGl2ZVJlZ2lvbj09PW51bGw7KWlmKGw9bC5PbmV4dCxsPT09Yy5hbkVkZ2Upe3kuY29ubmVjdExlZnRWZXJ0ZXgocyxjKTtyZXR1cm59dmFyIHY9eS50b3BMZWZ0UmVnaW9uKHMsbC5hY3RpdmVSZWdpb24pO2YodiE9PW51bGwpO3ZhciBUPXkucmVnaW9uQmVsb3codiksUj1ULmVVcCxMPXkuZmluaXNoTGVmdFJlZ2lvbnMocyxULG51bGwpO0wuT25leHQ9PT1SP3kuY29ubmVjdFJpZ2h0VmVydGV4KHMsdixMKTp5LmFkZFJpZ2h0RWRnZXMocyx2LEwuT25leHQsUixSLCEwKX0seS5hZGRTZW50aW5lbD1mdW5jdGlvbihzLGMsbCx2KXt2YXIgVD1uZXcgTSxSPXMubWVzaC5tYWtlRWRnZSgpO1IuT3JnLnM9bCxSLk9yZy50PXYsUi5Ec3Qucz1jLFIuRHN0LnQ9dixzLmV2ZW50PVIuRHN0LFQuZVVwPVIsVC53aW5kaW5nTnVtYmVyPTAsVC5pbnNpZGU9ITEsVC5maXhVcHBlckVkZ2U9ITEsVC5zZW50aW5lbD0hMCxULmRpcnR5PSExLFQubm9kZVVwPXMuZGljdC5pbnNlcnQoVCl9LHkuaW5pdEVkZ2VEaWN0PWZ1bmN0aW9uKHMpe3MuZGljdD1uZXcgcChzLHkuZWRnZUxlcSk7dmFyIGM9cy5ibWF4WzBdLXMuYm1pblswXSxsPXMuYm1heFsxXS1zLmJtaW5bMV0sdj1zLmJtaW5bMF0tYyxUPXMuYm1heFswXStjLFI9cy5ibWluWzFdLWwsTD1zLmJtYXhbMV0rbDt5LmFkZFNlbnRpbmVsKHMsdixULFIpLHkuYWRkU2VudGluZWwocyx2LFQsTCl9LHkuZG9uZUVkZ2VEaWN0PWZ1bmN0aW9uKHMpe2Zvcih2YXIgYyxsPTA7KGM9cy5kaWN0Lm1pbigpLmtleSkhPT1udWxsOyljLnNlbnRpbmVsfHwoZihjLmZpeFVwcGVyRWRnZSksZigrK2w9PT0xKSksZihjLndpbmRpbmdOdW1iZXI9PT0wKSx5LmRlbGV0ZVJlZ2lvbihzLGMpfSx5LnJlbW92ZURlZ2VuZXJhdGVFZGdlcz1mdW5jdGlvbihzKXt2YXIgYyxsLHYsVD1zLm1lc2guZUhlYWQ7Zm9yKGM9VC5uZXh0O2MhPT1UO2M9bClsPWMubmV4dCx2PWMuTG5leHQsaS52ZXJ0RXEoYy5PcmcsYy5Ec3QpJiZjLkxuZXh0LkxuZXh0IT09YyYmKHkuc3BsaWNlTWVyZ2VWZXJ0aWNlcyhzLHYsYykscy5tZXNoLmRlbGV0ZShjKSxjPXYsdj1jLkxuZXh0KSx2LkxuZXh0PT09YyYmKHYhPT1jJiYoKHY9PT1sfHx2PT09bC5TeW0pJiYobD1sLm5leHQpLHMubWVzaC5kZWxldGUodikpLChjPT09bHx8Yz09PWwuU3ltKSYmKGw9bC5uZXh0KSxzLm1lc2guZGVsZXRlKGMpKX0seS5pbml0UHJpb3JpdHlRPWZ1bmN0aW9uKHMpe3ZhciBjLGwsdixUPTA7Zm9yKHY9cy5tZXNoLnZIZWFkLGw9di5uZXh0O2whPT12O2w9bC5uZXh0KVQrKztmb3IoVCs9OCxjPXMucHE9bmV3IGIoVCxpLnZlcnRMZXEpLHY9cy5tZXNoLnZIZWFkLGw9di5uZXh0O2whPT12O2w9bC5uZXh0KWwucHFIYW5kbGU9Yy5pbnNlcnQobCk7cmV0dXJuIGwhPT12PyExOihjLmluaXQoKSwhMCl9LHkuZG9uZVByaW9yaXR5UT1mdW5jdGlvbihzKXtzLnBxPW51bGx9LHkucmVtb3ZlRGVnZW5lcmF0ZUZhY2VzPWZ1bmN0aW9uKHMsYyl7dmFyIGwsdixUO2ZvcihsPWMuZkhlYWQubmV4dDtsIT09Yy5mSGVhZDtsPXYpdj1sLm5leHQsVD1sLmFuRWRnZSxmKFQuTG5leHQhPT1UKSxULkxuZXh0LkxuZXh0PT09VCYmKHkuYWRkV2luZGluZyhULk9uZXh0LFQpLHMubWVzaC5kZWxldGUoVCkpO3JldHVybiEwfSx5LmNvbXB1dGVJbnRlcmlvcj1mdW5jdGlvbihzKXt2YXIgYyxsO2lmKHkucmVtb3ZlRGVnZW5lcmF0ZUVkZ2VzKHMpLCF5LmluaXRQcmlvcml0eVEocykpcmV0dXJuITE7Zm9yKHkuaW5pdEVkZ2VEaWN0KHMpOyhjPXMucHEuZXh0cmFjdE1pbigpKSE9PW51bGw7KXtmb3IoO2w9cy5wcS5taW4oKSwhKGw9PT1udWxsfHwhaS52ZXJ0RXEobCxjKSk7KWw9cy5wcS5leHRyYWN0TWluKCkseS5zcGxpY2VNZXJnZVZlcnRpY2VzKHMsYy5hbkVkZ2UsbC5hbkVkZ2UpO3kuc3dlZXBFdmVudChzLGMpfXJldHVybiBzLmV2ZW50PXMuZGljdC5taW4oKS5rZXkuZVVwLk9yZyx5LmRlYnVnRXZlbnQocykseS5kb25lRWRnZURpY3QocykseS5kb25lUHJpb3JpdHlRKHMpLHkucmVtb3ZlRGVnZW5lcmF0ZUZhY2VzKHMscy5tZXNoKT8ocy5tZXNoLmNoZWNrKCksITApOiExfTtmdW5jdGlvbiBTKCl7dGhpcy5tZXNoPW51bGwsdGhpcy5ub3JtYWw9WzAsMCwwXSx0aGlzLnNVbml0PVswLDAsMF0sdGhpcy50VW5pdD1bMCwwLDBdLHRoaXMuYm1pbj1bMCwwXSx0aGlzLmJtYXg9WzAsMF0sdGhpcy53aW5kaW5nUnVsZT1uLldJTkRJTkdfT0RELHRoaXMuZGljdD1udWxsLHRoaXMucHE9bnVsbCx0aGlzLmV2ZW50PW51bGwsdGhpcy52ZXJ0ZXhJbmRleENvdW50ZXI9MCx0aGlzLnZlcnRpY2VzPVtdLHRoaXMudmVydGV4SW5kaWNlcz1bXSx0aGlzLnZlcnRleENvdW50PTAsdGhpcy5lbGVtZW50cz1bXSx0aGlzLmVsZW1lbnRDb3VudD0wfVMucHJvdG90eXBlPXtkb3RfOmZ1bmN0aW9uKHMsYyl7cmV0dXJuIHNbMF0qY1swXStzWzFdKmNbMV0rc1syXSpjWzJdfSxub3JtYWxpemVfOmZ1bmN0aW9uKHMpe3ZhciBjPXNbMF0qc1swXStzWzFdKnNbMV0rc1syXSpzWzJdO2YoYz4wKSxjPU1hdGguc3FydChjKSxzWzBdLz1jLHNbMV0vPWMsc1syXS89Y30sbG9uZ0F4aXNfOmZ1bmN0aW9uKHMpe3ZhciBjPTA7cmV0dXJuIE1hdGguYWJzKHNbMV0pPk1hdGguYWJzKHNbMF0pJiYoYz0xKSxNYXRoLmFicyhzWzJdKT5NYXRoLmFicyhzW2NdKSYmKGM9MiksY30sY29tcHV0ZU5vcm1hbF86ZnVuY3Rpb24ocyl7dmFyIGMsbCx2LFQsUixMLE49WzAsMCwwXSxBPVswLDAsMF0sdz1bMCwwLDBdLEI9WzAsMCwwXSxEPVswLDAsMF0sST1bbnVsbCxudWxsLG51bGxdLGo9W251bGwsbnVsbCxudWxsXSxWPXRoaXMubWVzaC52SGVhZCxKO2ZvcihjPVYubmV4dCxKPTA7SjwzOysrSilUPWMuY29vcmRzW0pdLEFbSl09VCxqW0pdPWMsTltKXT1ULElbSl09Yztmb3IoYz1WLm5leHQ7YyE9PVY7Yz1jLm5leHQpZm9yKEo9MDtKPDM7KytKKVQ9Yy5jb29yZHNbSl0sVDxBW0pdJiYoQVtKXT1ULGpbSl09YyksVD5OW0pdJiYoTltKXT1ULElbSl09Yyk7aWYoSj0wLE5bMV0tQVsxXT5OWzBdLUFbMF0mJihKPTEpLE5bMl0tQVsyXT5OW0pdLUFbSl0mJihKPTIpLEFbSl0+PU5bSl0pe3NbMF09MCxzWzFdPTAsc1syXT0xO3JldHVybn1mb3IoTD0wLGw9altKXSx2PUlbSl0sd1swXT1sLmNvb3Jkc1swXS12LmNvb3Jkc1swXSx3WzFdPWwuY29vcmRzWzFdLXYuY29vcmRzWzFdLHdbMl09bC5jb29yZHNbMl0tdi5jb29yZHNbMl0sYz1WLm5leHQ7YyE9PVY7Yz1jLm5leHQpQlswXT1jLmNvb3Jkc1swXS12LmNvb3Jkc1swXSxCWzFdPWMuY29vcmRzWzFdLXYuY29vcmRzWzFdLEJbMl09Yy5jb29yZHNbMl0tdi5jb29yZHNbMl0sRFswXT13WzFdKkJbMl0td1syXSpCWzFdLERbMV09d1syXSpCWzBdLXdbMF0qQlsyXSxEWzJdPXdbMF0qQlsxXS13WzFdKkJbMF0sUj1EWzBdKkRbMF0rRFsxXSpEWzFdK0RbMl0qRFsyXSxSPkwmJihMPVIsc1swXT1EWzBdLHNbMV09RFsxXSxzWzJdPURbMl0pO0w8PTAmJihzWzBdPXNbMV09c1syXT0wLHNbdGhpcy5sb25nQXhpc18odyldPTEpfSxjaGVja09yaWVudGF0aW9uXzpmdW5jdGlvbigpe3ZhciBzLGMsbD10aGlzLm1lc2guZkhlYWQsdixUPXRoaXMubWVzaC52SGVhZCxSO2ZvcihzPTAsYz1sLm5leHQ7YyE9PWw7Yz1jLm5leHQpaWYoUj1jLmFuRWRnZSwhKFIud2luZGluZzw9MCkpZG8gcys9KFIuT3JnLnMtUi5Ec3QucykqKFIuT3JnLnQrUi5Ec3QudCksUj1SLkxuZXh0O3doaWxlKFIhPT1jLmFuRWRnZSk7aWYoczwwKXtmb3Iodj1ULm5leHQ7diE9PVQ7dj12Lm5leHQpdi50PS12LnQ7dGhpcy50VW5pdFswXT0tdGhpcy50VW5pdFswXSx0aGlzLnRVbml0WzFdPS10aGlzLnRVbml0WzFdLHRoaXMudFVuaXRbMl09LXRoaXMudFVuaXRbMl19fSxwcm9qZWN0UG9seWdvbl86ZnVuY3Rpb24oKXt2YXIgcyxjPXRoaXMubWVzaC52SGVhZCxsPVswLDAsMF0sdixULFIsTCxOPSExO2ZvcihsWzBdPXRoaXMubm9ybWFsWzBdLGxbMV09dGhpcy5ub3JtYWxbMV0sbFsyXT10aGlzLm5vcm1hbFsyXSxsWzBdPT09MCYmbFsxXT09PTAmJmxbMl09PT0wJiYodGhpcy5jb21wdXRlTm9ybWFsXyhsKSxOPSEwKSx2PXRoaXMuc1VuaXQsVD10aGlzLnRVbml0LFI9dGhpcy5sb25nQXhpc18obCksdltSXT0wLHZbKFIrMSklM109MSx2WyhSKzIpJTNdPTAsVFtSXT0wLFRbKFIrMSklM109MCxUWyhSKzIpJTNdPWxbUl0+MD8xOi0xLHM9Yy5uZXh0O3MhPT1jO3M9cy5uZXh0KXMucz10aGlzLmRvdF8ocy5jb29yZHMsdikscy50PXRoaXMuZG90XyhzLmNvb3JkcyxUKTtmb3IoTiYmdGhpcy5jaGVja09yaWVudGF0aW9uXygpLEw9ITAscz1jLm5leHQ7cyE9PWM7cz1zLm5leHQpTD8odGhpcy5ibWluWzBdPXRoaXMuYm1heFswXT1zLnMsdGhpcy5ibWluWzFdPXRoaXMuYm1heFsxXT1zLnQsTD0hMSk6KHMuczx0aGlzLmJtaW5bMF0mJih0aGlzLmJtaW5bMF09cy5zKSxzLnM+dGhpcy5ibWF4WzBdJiYodGhpcy5ibWF4WzBdPXMucykscy50PHRoaXMuYm1pblsxXSYmKHRoaXMuYm1pblsxXT1zLnQpLHMudD50aGlzLmJtYXhbMV0mJih0aGlzLmJtYXhbMV09cy50KSl9LGFkZFdpbmRpbmdfOmZ1bmN0aW9uKHMsYyl7cy53aW5kaW5nKz1jLndpbmRpbmcscy5TeW0ud2luZGluZys9Yy5TeW0ud2luZGluZ30sdGVzc2VsbGF0ZU1vbm9SZWdpb25fOmZ1bmN0aW9uKHMsYyl7dmFyIGwsdjtmb3IobD1jLmFuRWRnZSxmKGwuTG5leHQhPT1sJiZsLkxuZXh0LkxuZXh0IT09bCk7aS52ZXJ0TGVxKGwuRHN0LGwuT3JnKTtsPWwuTHByZXYpO2Zvcig7aS52ZXJ0TGVxKGwuT3JnLGwuRHN0KTtsPWwuTG5leHQpO2Zvcih2PWwuTHByZXY7bC5MbmV4dCE9PXY7KWlmKGkudmVydExlcShsLkRzdCx2Lk9yZykpe2Zvcig7di5MbmV4dCE9PWwmJihpLmVkZ2VHb2VzTGVmdCh2LkxuZXh0KXx8aS5lZGdlU2lnbih2Lk9yZyx2LkRzdCx2LkxuZXh0LkRzdCk8PTApOyl7dmFyIFQ9cy5jb25uZWN0KHYuTG5leHQsdik7dj1ULlN5bX12PXYuTHByZXZ9ZWxzZXtmb3IoO3YuTG5leHQhPT1sJiYoaS5lZGdlR29lc1JpZ2h0KGwuTHByZXYpfHxpLmVkZ2VTaWduKGwuRHN0LGwuT3JnLGwuTHByZXYuT3JnKT49MCk7KXt2YXIgVD1zLmNvbm5lY3QobCxsLkxwcmV2KTtsPVQuU3ltfWw9bC5MbmV4dH1mb3IoZih2LkxuZXh0IT09bCk7di5MbmV4dC5MbmV4dCE9PWw7KXt2YXIgVD1zLmNvbm5lY3Qodi5MbmV4dCx2KTt2PVQuU3ltfXJldHVybiEwfSx0ZXNzZWxsYXRlSW50ZXJpb3JfOmZ1bmN0aW9uKHMpe3ZhciBjLGw7Zm9yKGM9cy5mSGVhZC5uZXh0O2MhPT1zLmZIZWFkO2M9bClpZihsPWMubmV4dCxjLmluc2lkZSYmIXRoaXMudGVzc2VsbGF0ZU1vbm9SZWdpb25fKHMsYykpcmV0dXJuITE7cmV0dXJuITB9LGRpc2NhcmRFeHRlcmlvcl86ZnVuY3Rpb24ocyl7dmFyIGMsbDtmb3IoYz1zLmZIZWFkLm5leHQ7YyE9PXMuZkhlYWQ7Yz1sKWw9Yy5uZXh0LGMuaW5zaWRlfHxzLnphcEZhY2UoYyl9LHNldFdpbmRpbmdOdW1iZXJfOmZ1bmN0aW9uKHMsYyxsKXt2YXIgdixUO2Zvcih2PXMuZUhlYWQubmV4dDt2IT09cy5lSGVhZDt2PVQpVD12Lm5leHQsdi5SZmFjZS5pbnNpZGUhPT12LkxmYWNlLmluc2lkZT92LndpbmRpbmc9di5MZmFjZS5pbnNpZGU/YzotYzpsP3MuZGVsZXRlKHYpOnYud2luZGluZz0wfSxnZXROZWlnaGJvdXJGYWNlXzpmdW5jdGlvbihzKXtyZXR1cm4hcy5SZmFjZXx8IXMuUmZhY2UuaW5zaWRlPy0xOnMuUmZhY2Uubn0sb3V0cHV0UG9seW1lc2hfOmZ1bmN0aW9uKHMsYyxsLHYpe3ZhciBULFIsTCxOPTAsQT0wLHcsQjtmb3IobD4zJiZzLm1lcmdlQ29udmV4RmFjZXMobCksVD1zLnZIZWFkLm5leHQ7VCE9PXMudkhlYWQ7VD1ULm5leHQpVC5uPS0xO2ZvcihSPXMuZkhlYWQubmV4dDtSIT09cy5mSGVhZDtSPVIubmV4dClpZihSLm49LTEsISFSLmluc2lkZSl7TD1SLmFuRWRnZSx3PTA7ZG8gVD1MLk9yZyxULm49PT0tMSYmKFQubj1BLEErKyksdysrLEw9TC5MbmV4dDt3aGlsZShMIT09Ui5hbkVkZ2UpO2Yodzw9bCksUi5uPU4sKytOfWZvcih0aGlzLmVsZW1lbnRDb3VudD1OLGM9PT1uLkNPTk5FQ1RFRF9QT0xZR09OUyYmKE4qPTIpLHRoaXMuZWxlbWVudHM9W10sdGhpcy5lbGVtZW50cy5sZW5ndGg9TipsLHRoaXMudmVydGV4Q291bnQ9QSx0aGlzLnZlcnRpY2VzPVtdLHRoaXMudmVydGljZXMubGVuZ3RoPUEqdix0aGlzLnZlcnRleEluZGljZXM9W10sdGhpcy52ZXJ0ZXhJbmRpY2VzLmxlbmd0aD1BLFQ9cy52SGVhZC5uZXh0O1QhPT1zLnZIZWFkO1Q9VC5uZXh0KWlmKFQubiE9PS0xKXt2YXIgRD1ULm4qdjt0aGlzLnZlcnRpY2VzW0QrMF09VC5jb29yZHNbMF0sdGhpcy52ZXJ0aWNlc1tEKzFdPVQuY29vcmRzWzFdLHY+MiYmKHRoaXMudmVydGljZXNbRCsyXT1ULmNvb3Jkc1syXSksdGhpcy52ZXJ0ZXhJbmRpY2VzW1Qubl09VC5pZHh9dmFyIEk9MDtmb3IoUj1zLmZIZWFkLm5leHQ7UiE9PXMuZkhlYWQ7Uj1SLm5leHQpaWYoUi5pbnNpZGUpe0w9Ui5hbkVkZ2Usdz0wO2RvIFQ9TC5PcmcsdGhpcy5lbGVtZW50c1tJKytdPVQubix3KyssTD1MLkxuZXh0O3doaWxlKEwhPT1SLmFuRWRnZSk7Zm9yKEI9dztCPGw7KytCKXRoaXMuZWxlbWVudHNbSSsrXT0tMTtpZihjPT09bi5DT05ORUNURURfUE9MWUdPTlMpe0w9Ui5hbkVkZ2U7ZG8gdGhpcy5lbGVtZW50c1tJKytdPXRoaXMuZ2V0TmVpZ2hib3VyRmFjZV8oTCksTD1MLkxuZXh0O3doaWxlKEwhPT1SLmFuRWRnZSk7Zm9yKEI9dztCPGw7KytCKXRoaXMuZWxlbWVudHNbSSsrXT0tMX19fSxvdXRwdXRDb250b3Vyc186ZnVuY3Rpb24ocyxjKXt2YXIgbCx2LFQsUj0wLEw9MDtmb3IodGhpcy52ZXJ0ZXhDb3VudD0wLHRoaXMuZWxlbWVudENvdW50PTAsbD1zLmZIZWFkLm5leHQ7bCE9PXMuZkhlYWQ7bD1sLm5leHQpaWYobC5pbnNpZGUpe1Q9dj1sLmFuRWRnZTtkbyB0aGlzLnZlcnRleENvdW50Kyssdj12LkxuZXh0O3doaWxlKHYhPT1UKTt0aGlzLmVsZW1lbnRDb3VudCsrfXRoaXMuZWxlbWVudHM9W10sdGhpcy5lbGVtZW50cy5sZW5ndGg9dGhpcy5lbGVtZW50Q291bnQqMix0aGlzLnZlcnRpY2VzPVtdLHRoaXMudmVydGljZXMubGVuZ3RoPXRoaXMudmVydGV4Q291bnQqYyx0aGlzLnZlcnRleEluZGljZXM9W10sdGhpcy52ZXJ0ZXhJbmRpY2VzLmxlbmd0aD10aGlzLnZlcnRleENvdW50O3ZhciBOPTAsQT0wLHc9MDtmb3IoUj0wLGw9cy5mSGVhZC5uZXh0O2whPT1zLmZIZWFkO2w9bC5uZXh0KWlmKGwuaW5zaWRlKXtMPTAsVD12PWwuYW5FZGdlO2RvIHRoaXMudmVydGljZXNbTisrXT12Lk9yZy5jb29yZHNbMF0sdGhpcy52ZXJ0aWNlc1tOKytdPXYuT3JnLmNvb3Jkc1sxXSxjPjImJih0aGlzLnZlcnRpY2VzW04rK109di5PcmcuY29vcmRzWzJdKSx0aGlzLnZlcnRleEluZGljZXNbQSsrXT12Lk9yZy5pZHgsTCsrLHY9di5MbmV4dDt3aGlsZSh2IT09VCk7dGhpcy5lbGVtZW50c1t3KytdPVIsdGhpcy5lbGVtZW50c1t3KytdPUwsUis9TH19LGFkZENvbnRvdXI6ZnVuY3Rpb24ocyxjKXt2YXIgbCx2O2Zvcih0aGlzLm1lc2g9PT1udWxsJiYodGhpcy5tZXNoPW5ldyBkKSxzPDImJihzPTIpLHM+MyYmKHM9MyksbD1udWxsLHY9MDt2PGMubGVuZ3RoO3YrPXMpbD09PW51bGw/KGw9dGhpcy5tZXNoLm1ha2VFZGdlKCksdGhpcy5tZXNoLnNwbGljZShsLGwuU3ltKSk6KHRoaXMubWVzaC5zcGxpdEVkZ2UobCksbD1sLkxuZXh0KSxsLk9yZy5jb29yZHNbMF09Y1t2KzBdLGwuT3JnLmNvb3Jkc1sxXT1jW3YrMV0scz4yP2wuT3JnLmNvb3Jkc1syXT1jW3YrMl06bC5PcmcuY29vcmRzWzJdPTAsbC5PcmcuaWR4PXRoaXMudmVydGV4SW5kZXhDb3VudGVyKyssbC53aW5kaW5nPTEsbC5TeW0ud2luZGluZz0tMX0sdGVzc2VsYXRlOmZ1bmN0aW9uKHMsYyxsLHYsVCl7aWYodGhpcy52ZXJ0aWNlcz1bXSx0aGlzLmVsZW1lbnRzPVtdLHRoaXMudmVydGV4SW5kaWNlcz1bXSx0aGlzLnZlcnRleEluZGV4Q291bnRlcj0wLFQmJih0aGlzLm5vcm1hbFswXT1UWzBdLHRoaXMubm9ybWFsWzFdPVRbMV0sdGhpcy5ub3JtYWxbMl09VFsyXSksdGhpcy53aW5kaW5nUnVsZT1zLHY8MiYmKHY9Miksdj4zJiYodj0zKSwhdGhpcy5tZXNoKXJldHVybiExO3RoaXMucHJvamVjdFBvbHlnb25fKCkseS5jb21wdXRlSW50ZXJpb3IodGhpcyk7dmFyIFI9dGhpcy5tZXNoO3JldHVybiBjPT09bi5CT1VOREFSWV9DT05UT1VSUz90aGlzLnNldFdpbmRpbmdOdW1iZXJfKFIsMSwhMCk6dGhpcy50ZXNzZWxsYXRlSW50ZXJpb3JfKFIpLFIuY2hlY2soKSxjPT09bi5CT1VOREFSWV9DT05UT1VSUz90aGlzLm91dHB1dENvbnRvdXJzXyhSLHYpOnRoaXMub3V0cHV0UG9seW1lc2hfKFIsYyxsLHYpLCEwfX19LGZ1bmN0aW9uKGcsZSl7Zy5leHBvcnRzPW47dmFyIHQ9T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtmdW5jdGlvbiBuKCl7Zm9yKHZhciBpPXt9LGY9MDtmPGFyZ3VtZW50cy5sZW5ndGg7ZisrKXt2YXIgaD1hcmd1bWVudHNbZl07Zm9yKHZhciB1IGluIGgpdC5jYWxsKGgsdSkmJihpW3VdPWhbdV0pfXJldHVybiBpfX0sZnVuY3Rpb24oZyxlLHQpe3QucihlKSx0LmQoZSwiY3JlYXRlU2hhZGVycyIsZnVuY3Rpb24oKXtyZXR1cm4gYX0pLHQuZChlLCJhcHBseVNoYWRlciIsZnVuY3Rpb24oKXtyZXR1cm4gZH0pLHQuZChlLCJjcmVhdGVDbG91ZFNoYWRlcnMiLGZ1bmN0aW9uKCl7cmV0dXJuIHB9KSx0LmQoZSwiYXBwbHlDbG91ZFNoYWRlciIsZnVuY3Rpb24oKXtyZXR1cm4gT30pO3ZhciBuPXQoNjQpLGk9dCg2NSksZj10KDY2KSxoPXQoNjcpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCB1PVN5bWJvbCgic2hhZGVycyIpO2Z1bmN0aW9uIGEobSl7bVt1XT1bXTtmb3IobGV0IGI9MDtiPDE2O2IrKyl7Y29uc3QgTT1bXSx5PSEhKGImMSksUz0hIShiJjIpLHM9ISEoYiY0KSxjPSEhKGImOCk7eSYmTS5wdXNoKCIjZGVmaW5lIFRFWFRVUkUgMSIpLFMmJk0ucHVzaCgiI2RlZmluZSBGSUxURVIgMSIpLHMmJk0ucHVzaCgiI2RlZmluZSBHUkFESUVOVCAxIiksYyYmTS5wdXNoKCIjZGVmaW5lIENMSVBQQVRIIDEiKTtjb25zdCBsPWAke00uam9pbihgCmApfQpgLHY9W107eSYmdi5wdXNoKCJ1bmlmb3JtIHNhbXBsZXIyRCB1X3RleFNhbXBsZXI7IiksYyYmdi5wdXNoKCJ1bmlmb3JtIHNhbXBsZXIyRCB1X2NsaXBTYW1wbGVyOyIpLG1bdV1bYl09W2wrdi5qb2luKGAKYCkraS5kZWZhdWx0LGwrbi5kZWZhdWx0XX19ZnVuY3Rpb24gZChtLHtoYXNUZXh0dXJlOmI9ITEsaGFzRmlsdGVyOk09ITEsaGFzR3JhZGllbnQ6eT0hMSxoYXNDbGlwUGF0aDpTPSExfT17fSl7Y29uc3Qgcz1ifE08PDF8eTw8MnxTPDwzO2xldCBjPW1bdV1bc107QXJyYXkuaXNBcnJheShjKSYmKGM9bS5jcmVhdGVQcm9ncmFtKC4uLmMpLG1bdV1bc109YyksbS5wcm9ncmFtIT09YyYmbS51c2VQcm9ncmFtKGMse2FfY29sb3I6e3R5cGU6IlVOU0lHTkVEX0JZVEUiLG5vcm1hbGl6ZTohMH19KX1jb25zdCBFPVtdO2Z1bmN0aW9uIHAobSl7Zm9yKGxldCBiPTA7Yjw2NDtiKyspe2NvbnN0IE09W10seT0hIShiJjEpLFM9ISEoYiYyKSxzPSEhKGImNCksYz0hIShiJjgpLGw9ISEoYiYxNiksdj0hIShiJjMyKTt5JiZNLnB1c2goIiNkZWZpbmUgVEVYVFVSRSAxIiksUyYmTS5wdXNoKCIjZGVmaW5lIEZJTFRFUiAxIikscyYmTS5wdXNoKCIjZGVmaW5lIEdSQURJRU5UIDEiKSxjJiZNLnB1c2goIiNkZWZpbmUgQ0xPVURDT0xPUiAxIiksbCYmTS5wdXNoKCIjZGVmaW5lIENMT1VERklMVEVSIDEiKSx2JiZNLnB1c2goIiNkZWZpbmUgQ0xJUFBBVEggMSIpO2NvbnN0IFQ9YCR7TS5qb2luKGAKYCl9CmAsUj1bXTtpZih5KXtSLnB1c2goInVuaWZvcm0gc2FtcGxlcjJEIHVfdGV4U2FtcGxlcjsiKTtmb3IobGV0IEw9MDtMPDEyO0wrKylSLnB1c2goYHVuaWZvcm0gc2FtcGxlcjJEIHVfdGV4RnJhbWUke0x9O2ApfXYmJlIucHVzaCgidW5pZm9ybSBzYW1wbGVyMkQgdV9jbGlwU2FtcGxlcjsiKSxFW2JdPVtUK1Iuam9pbihgCmApK2guZGVmYXVsdCxUK2YuZGVmYXVsdF19fWZ1bmN0aW9uIE8obSx7aGFzVGV4dHVyZTpiPSExLGhhc0ZpbHRlcjpNPSExLGhhc0dyYWRpZW50Onk9ITEsaGFzQ2xvdWRDb2xvcjpTPSExLGhhc0Nsb3VkRmlsdGVyOnM9ITEsaGFzQ2xpcFBhdGg6Yz0hMX09e30pe2NvbnN0IGw9YnxNPDwxfHk8PDJ8Uzw8M3xzPDw0fGM8PDU7bGV0IHY9RVtsXTtBcnJheS5pc0FycmF5KHYpJiYodj1tLmNyZWF0ZVByb2dyYW0oLi4udiksRVtsXT12KSxtLnByb2dyYW0hPT12JiZtLnVzZVByb2dyYW0odix7YV9jb2xvcjp7dHlwZToiVU5TSUdORURfQllURSIsbm9ybWFsaXplOiEwfSxhX2ZpbGxDbG91ZENvbG9yOnt0eXBlOiJVTlNJR05FRF9CWVRFIixub3JtYWxpemU6ITB9LGFfc3Ryb2tlQ2xvdWRDb2xvcjp7dHlwZToiVU5TSUdORURfQllURSIsbm9ybWFsaXplOiEwfSxhX2ZyYW1lSW5kZXg6e3R5cGU6IlVOU0lHTkVEX0JZVEUiLG5vcm1hbGl6ZTohMX19KX19LGZ1bmN0aW9uKGcsZSx0KXt0LnIoZSksZS5kZWZhdWx0PWBhdHRyaWJ1dGUgdmVjMyBhX3ZlcnRleFBvc2l0aW9uOwphdHRyaWJ1dGUgdmVjNCBhX2NvbG9yOwp2YXJ5aW5nIHZlYzQgdkNvbG9yOwp2YXJ5aW5nIGZsb2F0IGZsYWdCYWNrZ3JvdW5kOwp1bmlmb3JtIHZlYzIgdV9yZXNvbHV0aW9uOwp1bmlmb3JtIG1hdDMgdmlld01hdHJpeDsKdW5pZm9ybSBtYXQzIHByb2plY3Rpb25NYXRyaXg7CgojaWZkZWYgVEVYVFVSRQphdHRyaWJ1dGUgdmVjMyBhX3ZlcnRleFRleHR1cmVDb29yZDsKdmFyeWluZyB2ZWMzIHZUZXh0dXJlQ29vcmQ7CmF0dHJpYnV0ZSB2ZWM0IGFfc291cmNlUmVjdDsKdmFyeWluZyB2ZWM0IHZTb3VyY2VSZWN0OwojZW5kaWYKCiNpZmRlZiBDTElQUEFUSAphdHRyaWJ1dGUgdmVjMiBhX2NsaXBVVjsKdmFyeWluZyB2ZWMyIHZDbGlwVVY7CiNlbmRpZgoKI2lmZGVmIEdSQURJRU5UCnVuaWZvcm0gZmxvYXQgdV9yYWRpYWxHcmFkaWVudFZlY3Rvcls2XTsKdmFyeWluZyB2ZWMzIHZHcmFkaWVudFZlY3RvcjE7CnZhcnlpbmcgdmVjMyB2R3JhZGllbnRWZWN0b3IyOwojZW5kaWYKCnZvaWQgbWFpbigpIHsKICBnbF9Qb2ludFNpemUgPSAxLjA7CgogIHZlYzMgcG9zID0gcHJvamVjdGlvbk1hdHJpeCAqIHZpZXdNYXRyaXggKiB2ZWMzKGFfdmVydGV4UG9zaXRpb24ueHksIDEuMCk7CiAgZ2xfUG9zaXRpb24gPSB2ZWM0KHBvcy54eSwgMS4wLCAxLjApOwoKI2lmZGVmIEdSQURJRU5UCiAgdmVjMyB2ZzEgPSB2aWV3TWF0cml4ICogdmVjMyh1X3JhZGlhbEdyYWRpZW50VmVjdG9yWzBdLCB1X3JhZGlhbEdyYWRpZW50VmVjdG9yWzFdLCAxLjApOwogIHZlYzMgdmcyID0gdmlld01hdHJpeCAqIHZlYzModV9yYWRpYWxHcmFkaWVudFZlY3RvclszXSwgdV9yYWRpYWxHcmFkaWVudFZlY3Rvcls0XSwgMS4wKTsKICBmbG9hdCBoID0gdV9yZXNvbHV0aW9uLnk7CiAgdmcxLnkgPSBoIC0gdmcxLnk7CiAgdmcyLnkgPSBoIC0gdmcyLnk7CiAgdkdyYWRpZW50VmVjdG9yMSA9IHZlYzModmcxLnh5LCB1X3JhZGlhbEdyYWRpZW50VmVjdG9yWzJdKTsKICB2R3JhZGllbnRWZWN0b3IyID0gdmVjMyh2ZzIueHksIHVfcmFkaWFsR3JhZGllbnRWZWN0b3JbNV0pOwojZW5kaWYKICAKICBmbGFnQmFja2dyb3VuZCA9IGFfdmVydGV4UG9zaXRpb24uejsKICB2Q29sb3IgPSBhX2NvbG9yOwoKI2lmZGVmIFRFWFRVUkUKICB2VGV4dHVyZUNvb3JkID0gYV92ZXJ0ZXhUZXh0dXJlQ29vcmQ7CiAgdlNvdXJjZVJlY3QgPSBhX3NvdXJjZVJlY3Q7CiNlbmRpZgoKI2lmZGVmIENMSVBQQVRICiAgdkNsaXBVViA9IGFfY2xpcFVWOwojZW5kaWYKfWB9LGZ1bmN0aW9uKGcsZSx0KXt0LnIoZSksZS5kZWZhdWx0PWBwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDsKCnZhcnlpbmcgdmVjNCB2Q29sb3I7CnZhcnlpbmcgZmxvYXQgZmxhZ0JhY2tncm91bmQ7CgojaWZkZWYgVEVYVFVSRQp2YXJ5aW5nIHZlYzMgdlRleHR1cmVDb29yZDsKdmFyeWluZyB2ZWM0IHZTb3VyY2VSZWN0OwojZW5kaWYKCiNpZmRlZiBDTElQUEFUSAp2YXJ5aW5nIHZlYzIgdkNsaXBVVjsKI2VuZGlmCgojaWZkZWYgRklMVEVSCnVuaWZvcm0gaW50IHVfZmlsdGVyRmxhZzsKdW5pZm9ybSBmbG9hdCB1X2NvbG9yTWF0cml4WzIwXTsKI2VuZGlmCgojaWZkZWYgR1JBRElFTlQKdmFyeWluZyB2ZWMzIHZHcmFkaWVudFZlY3RvcjE7CnZhcnlpbmcgdmVjMyB2R3JhZGllbnRWZWN0b3IyOwp1bmlmb3JtIGZsb2F0IHVfY29sb3JTdGVwc1s0MF07CnVuaWZvcm0gaW50IHVfZ3JhZGllbnRUeXBlOwovLyB1bmlmb3JtIGZsb2F0IHVfcmFkaWFsR3JhZGllbnRWZWN0b3JbNl07Cgp2b2lkIGdyYWRpZW50KGlub3V0IHZlYzQgY29sb3IsIHZlYzMgZ3YxLCB2ZWMzIGd2MiwgZmxvYXQgY29sb3JTdGVwc1s0MF0pIHsKICBmbG9hdCB0OwogIC8vIGNlbnRlciBjaXJjbGUgcmFkaXVzCiAgZmxvYXQgY3IgPSBndjEuejsKICAvLyBmb2NhbCBjaXJjbGUgcmFkaXVzCiAgZmxvYXQgZnIgPSBndjIuejsKCiAgaWYoY3IgPiAwLjAgfHwgZnIgPiAwLjApIHsKICAgIC8vIHJhZGlhbCBncmFkaWVudAogICAgdmVjMiBjZW50ZXIgPSBndjEueHk7CiAgICB2ZWMyIGZvY2FsID0gZ3YyLnh5OwogICAgZmxvYXQgeCA9IGZvY2FsLnggLSBnbF9GcmFnQ29vcmQueDsKICAgIGZsb2F0IHkgPSBmb2NhbC55IC0gZ2xfRnJhZ0Nvb3JkLnk7CiAgICBmbG9hdCBkeCA9IGZvY2FsLnggLSBjZW50ZXIueDsKICAgIGZsb2F0IGR5ID0gZm9jYWwueSAtIGNlbnRlci55OwogICAgZmxvYXQgZHIgPSBjciAtIGZyOwogICAgZmxvYXQgYSA9IGR4ICogZHggKyBkeSAqIGR5IC0gZHIgKiBkcjsKICAgIGZsb2F0IGIgPSAtMi4wICogKHkgKiBkeSArIHggKiBkeCArIGZyICogZHIpOwogICAgZmxvYXQgYyA9IHggKiB4ICsgeSAqIHkgLSBmciAqIGZyOwogICAgdCA9IDEuMCAtIDAuNSAqICgxLjAgLyBhKSAqICgtYiArIHNxcnQoYiAqIGIgLSA0LjAgKiBhICogYykpOwogIH0gZWxzZSB7CiAgICAvLyBsaW5lYXIgZ3JhZGllbnQKICAgIHZlYzIgdjEgPSBnbF9GcmFnQ29vcmQueHkgLSBndjEueHk7CiAgICB2ZWMyIHYyID0gZ3YyLnh5IC0gZ3YxLnh5OwogICAgdCA9ICh2MS54ICogdjIueCArIHYxLnkgKiB2Mi55KSAvICh2Mi54ICogdjIueCArIHYyLnkgKiB2Mi55KTsKICB9CgogIHZlYzQgY29sb3JzWzhdOwogIGNvbG9yc1swXSA9IHZlYzQoY29sb3JTdGVwc1sxXSwgY29sb3JTdGVwc1syXSwgY29sb3JTdGVwc1szXSwgY29sb3JTdGVwc1s0XSk7CiAgY29sb3JzWzFdID0gdmVjNChjb2xvclN0ZXBzWzZdLCBjb2xvclN0ZXBzWzddLCBjb2xvclN0ZXBzWzhdLCBjb2xvclN0ZXBzWzldKTsKICBjb2xvcnNbMl0gPSB2ZWM0KGNvbG9yU3RlcHNbMTFdLCBjb2xvclN0ZXBzWzEyXSwgY29sb3JTdGVwc1sxM10sIGNvbG9yU3RlcHNbMTRdKTsKICBjb2xvcnNbM10gPSB2ZWM0KGNvbG9yU3RlcHNbMTZdLCBjb2xvclN0ZXBzWzE3XSwgY29sb3JTdGVwc1sxOF0sIGNvbG9yU3RlcHNbMTldKTsKICBjb2xvcnNbNF0gPSB2ZWM0KGNvbG9yU3RlcHNbMjFdLCBjb2xvclN0ZXBzWzIyXSwgY29sb3JTdGVwc1syM10sIGNvbG9yU3RlcHNbMjRdKTsKICBjb2xvcnNbNV0gPSB2ZWM0KGNvbG9yU3RlcHNbMjZdLCBjb2xvclN0ZXBzWzI3XSwgY29sb3JTdGVwc1syOF0sIGNvbG9yU3RlcHNbMjldKTsKICBjb2xvcnNbNl0gPSB2ZWM0KGNvbG9yU3RlcHNbMzFdLCBjb2xvclN0ZXBzWzMyXSwgY29sb3JTdGVwc1szM10sIGNvbG9yU3RlcHNbMzRdKTsKICBjb2xvcnNbN10gPSB2ZWM0KGNvbG9yU3RlcHNbMzZdLCBjb2xvclN0ZXBzWzM3XSwgY29sb3JTdGVwc1szOF0sIGNvbG9yU3RlcHNbMzldKTsKICAKICBmbG9hdCBzdGVwc1s4XTsKICBzdGVwc1swXSA9IGNvbG9yU3RlcHNbMF07CiAgc3RlcHNbMV0gPSBjb2xvclN0ZXBzWzVdOwogIHN0ZXBzWzJdID0gY29sb3JTdGVwc1sxMF07CiAgc3RlcHNbM10gPSBjb2xvclN0ZXBzWzE1XTsKICBzdGVwc1s0XSA9IGNvbG9yU3RlcHNbMjBdOwogIHN0ZXBzWzVdID0gY29sb3JTdGVwc1syNV07CiAgc3RlcHNbNl0gPSBjb2xvclN0ZXBzWzMwXTsKICBzdGVwc1s3XSA9IGNvbG9yU3RlcHNbMzVdOwoKICBjb2xvciA9IGNvbG9yc1swXTsKICBmb3IgKGludCBpID0gMTsgaSA8IDg7IGkrKykgewogICAgaWYgKHN0ZXBzW2ldIDwgMC4wIHx8IHN0ZXBzW2ldID4gMS4wKSB7CiAgICAgIGJyZWFrOwogICAgfQogICAgaWYoc3RlcHNbaV0gPT0gc3RlcHNbaSAtIDFdKSB7CiAgICAgIGNvbG9yID0gY29sb3JzW2ldOwogICAgfSBlbHNlIHsKICAgICAgY29sb3IgPSBtaXgoY29sb3IsIGNvbG9yc1tpXSwgY2xhbXAoKHQgLSBzdGVwc1tpIC0gMV0pIC8gKHN0ZXBzW2ldIC0gc3RlcHNbaSAtIDFdKSwgMC4wLCAxLjApKTsKICAgIH0KICAgIGlmIChzdGVwc1tpXSA+PSB0KSB7CiAgICAgIGJyZWFrOwogICAgfQogIH0KfQojZW5kaWYKCiNpZmRlZiBGSUxURVIKdm9pZCB0cmFuc2Zvcm1Db2xvcihpbm91dCB2ZWM0IGNvbG9yLCBpbiBmbG9hdCBjb2xvck1hdHJpeFsyMF0pIHsKICBmbG9hdCByID0gY29sb3IuciwgZyA9IGNvbG9yLmcsIGIgPSBjb2xvci5iLCBhID0gY29sb3IuYTsKICBjb2xvclswXSA9IGNvbG9yTWF0cml4WzBdICogciArIGNvbG9yTWF0cml4WzFdICogZyArIGNvbG9yTWF0cml4WzJdICogYiArIGNvbG9yTWF0cml4WzNdICogYSArIGNvbG9yTWF0cml4WzRdOwogIGNvbG9yWzFdID0gY29sb3JNYXRyaXhbNV0gKiByICsgY29sb3JNYXRyaXhbNl0gKiBnICsgY29sb3JNYXRyaXhbN10gKiBiICsgY29sb3JNYXRyaXhbOF0gKiBhICsgY29sb3JNYXRyaXhbOV07CiAgY29sb3JbMl0gPSBjb2xvck1hdHJpeFsxMF0gKiByICsgY29sb3JNYXRyaXhbMTFdICogZyArIGNvbG9yTWF0cml4WzEyXSAqIGIgKyBjb2xvck1hdHJpeFsxM10gKiBhICsgY29sb3JNYXRyaXhbMTRdOwogIGNvbG9yWzNdID0gY29sb3JNYXRyaXhbMTVdICogciArIGNvbG9yTWF0cml4WzE2XSAqIGcgKyBjb2xvck1hdHJpeFsxN10gKiBiICsgY29sb3JNYXRyaXhbMThdICogYSArIGNvbG9yTWF0cml4WzE5XTsKfQojZW5kaWYKCnZvaWQgbWFpbigpIHsKICB2ZWM0IGNvbG9yID0gdkNvbG9yOwogIGZsb2F0IG9wYWNpdHkgPSBhYnMoZmxhZ0JhY2tncm91bmQpOwoKI2lmZGVmIEdSQURJRU5UCiAgaWYodV9ncmFkaWVudFR5cGUgPiAwICYmIGZsYWdCYWNrZ3JvdW5kID4gMC4wIHx8IHVfZ3JhZGllbnRUeXBlID09IDAgJiYgZmxhZ0JhY2tncm91bmQgPD0gMC4wKSB7CiAgICBncmFkaWVudChjb2xvciwgdkdyYWRpZW50VmVjdG9yMSwgdkdyYWRpZW50VmVjdG9yMiwgdV9jb2xvclN0ZXBzKTsKICB9CiNlbmRpZgoKICBpZihvcGFjaXR5IDwgMS4wKSB7CiAgICBjb2xvci5hICo9IG9wYWNpdHk7CiAgfQoKI2lmZGVmIFRFWFRVUkUKICBpZihmbGFnQmFja2dyb3VuZCA+IDAuMCkgewogICAgdmVjMyB0ZXhDb29yZCA9IHZUZXh0dXJlQ29vcmQ7CgogICAgaWYodGV4Q29vcmQueiA9PSAxLjApIHsKICAgICAgdGV4Q29vcmQgPSBmcmFjdCh0ZXhDb29yZCk7CiAgICB9CgogICAgaWYodGV4Q29vcmQueCA8PSAxLjAgJiYgdGV4Q29vcmQueCA+PSAwLjAKICAgICAgJiYgdGV4Q29vcmQueSA8PSAxLjAgJiYgdGV4Q29vcmQueSA+PSAwLjApIHsKICAgICAgaWYodlNvdXJjZVJlY3QueiA+IDAuMCkgewogICAgICAgIHRleENvb3JkLnggPSB2U291cmNlUmVjdC54ICsgdGV4Q29vcmQueCAqIHZTb3VyY2VSZWN0Lno7CiAgICAgICAgdGV4Q29vcmQueSA9IDEuMCAtICh2U291cmNlUmVjdC55ICsgKDEuMCAtIHRleENvb3JkLnkpICogdlNvdXJjZVJlY3Qudyk7CiAgICAgIH0KICAgICAgdmVjNCB0ZXhDb2xvciA9IHRleHR1cmUyRCh1X3RleFNhbXBsZXIsIHRleENvb3JkLnh5KTsKICAgICAgZmxvYXQgYWxwaGEgPSB0ZXhDb2xvci5hOwogICAgICBpZihvcGFjaXR5IDwgMS4wKSB7CiAgICAgICAgdGV4Q29sb3IuYSAqPSBvcGFjaXR5OwogICAgICAgIGFscGhhICo9IG1peCgwLjQ2NSwgMS4wLCBvcGFjaXR5KTsKICAgICAgfQogICAgICAvLyBjb2xvciA9IG1peChjb2xvciwgdGV4Q29sb3IsIHRleENvbG9yLmEpOwogICAgICBjb2xvci5yZ2IgPSBtaXgoY29sb3IucmdiLCB0ZXhDb2xvci5yZ2IsIGFscGhhKTsKICAgICAgLy8gY29sb3IucmdiID0gbWl4KHRleENvbG9yLnJnYiwgY29sb3IucmdiLCBjb2xvci5hKTsKICAgICAgY29sb3IucmdiID0gbWl4KHRleENvbG9yLnJnYiwgY29sb3IucmdiLCBjbGFtcChjb2xvci5hIC8gbWF4KDAuMDAwMSwgdGV4Q29sb3IuYSksIDAuMCwgMS4wKSk7CiAgICAgIGNvbG9yLmEgPSB0ZXhDb2xvci5hICsgKDEuMCAtIHRleENvbG9yLmEpICogY29sb3IuYTsKICAgIH0KICB9CiNlbmRpZgoKI2lmZGVmIEZJTFRFUgogIGlmKHVfZmlsdGVyRmxhZyA+IDApIHsKICAgIHRyYW5zZm9ybUNvbG9yKGNvbG9yLCB1X2NvbG9yTWF0cml4KTsKICB9CiNlbmRpZgoKI2lmZGVmIENMSVBQQVRICiAgZmxvYXQgY2xpcCA9IHRleHR1cmUyRCh1X2NsaXBTYW1wbGVyLCB2Q2xpcFVWKS5yOwogIGNvbG9yICo9IGNsaXA7CiNlbmRpZgoKICBnbF9GcmFnQ29sb3IgPSBjb2xvcjsKfWB9LGZ1bmN0aW9uKGcsZSx0KXt0LnIoZSksZS5kZWZhdWx0PWBhdHRyaWJ1dGUgdmVjMyBhX3ZlcnRleFBvc2l0aW9uOwphdHRyaWJ1dGUgdmVjNCBhX2NvbG9yOwp2YXJ5aW5nIHZlYzQgdkNvbG9yOwp2YXJ5aW5nIGZsb2F0IGZsYWdCYWNrZ3JvdW5kOwphdHRyaWJ1dGUgdmVjMyBhX3RyYW5zZm9ybTA7CmF0dHJpYnV0ZSB2ZWMzIGFfdHJhbnNmb3JtMTsKdW5pZm9ybSB2ZWMyIHVfcmVzb2x1dGlvbjsKdW5pZm9ybSBtYXQzIHZpZXdNYXRyaXg7CnVuaWZvcm0gbWF0MyBwcm9qZWN0aW9uTWF0cml4OwoKI2lmZGVmIFRFWFRVUkUKYXR0cmlidXRlIHZlYzMgYV92ZXJ0ZXhUZXh0dXJlQ29vcmQ7CnZhcnlpbmcgdmVjMyB2VGV4dHVyZUNvb3JkOwphdHRyaWJ1dGUgZmxvYXQgYV9mcmFtZUluZGV4Owp2YXJ5aW5nIGZsb2F0IGZyYW1lSW5kZXg7CmF0dHJpYnV0ZSB2ZWM0IGFfc291cmNlUmVjdDsKdmFyeWluZyB2ZWM0IHZTb3VyY2VSZWN0OwojZW5kaWYKCiNpZmRlZiBDTElQUEFUSAphdHRyaWJ1dGUgdmVjMiBhX2NsaXBVVjsKdmFyeWluZyB2ZWMyIHZDbGlwVVY7CiNlbmRpZgoKI2lmZGVmIENMT1VERklMVEVSCmF0dHJpYnV0ZSB2ZWM0IGFfY29sb3JDbG91ZDA7CmF0dHJpYnV0ZSB2ZWM0IGFfY29sb3JDbG91ZDE7CmF0dHJpYnV0ZSB2ZWM0IGFfY29sb3JDbG91ZDI7CmF0dHJpYnV0ZSB2ZWM0IGFfY29sb3JDbG91ZDM7CmF0dHJpYnV0ZSB2ZWM0IGFfY29sb3JDbG91ZDQ7CnZhcnlpbmcgdmVjNCBjb2xvckNsb3VkMDsKdmFyeWluZyB2ZWM0IGNvbG9yQ2xvdWQxOwp2YXJ5aW5nIHZlYzQgY29sb3JDbG91ZDI7CnZhcnlpbmcgdmVjNCBjb2xvckNsb3VkMzsKdmFyeWluZyB2ZWM0IGNvbG9yQ2xvdWQ0OwojZW5kaWYKCiNpZmRlZiBDTE9VRENPTE9SCmF0dHJpYnV0ZSB2ZWM0IGFfZmlsbENsb3VkQ29sb3I7CmF0dHJpYnV0ZSB2ZWM0IGFfc3Ryb2tlQ2xvdWRDb2xvcjsKI2VuZGlmCgojaWZkZWYgR1JBRElFTlQKdW5pZm9ybSBmbG9hdCB1X3JhZGlhbEdyYWRpZW50VmVjdG9yWzZdOwp2YXJ5aW5nIHZlYzMgdkdyYWRpZW50VmVjdG9yMTsKdmFyeWluZyB2ZWMzIHZHcmFkaWVudFZlY3RvcjI7CiNlbmRpZgoKdm9pZCBtYWluKCkgewogIGdsX1BvaW50U2l6ZSA9IDEuMDsKCiAgbWF0MyBtb2RlbE1hdHJpeCA9IG1hdDMoCiAgICBhX3RyYW5zZm9ybTAueCwgYV90cmFuc2Zvcm0xLngsIDAsIAogICAgYV90cmFuc2Zvcm0wLnksIGFfdHJhbnNmb3JtMS55LCAwLAogICAgYV90cmFuc2Zvcm0wLnosIGFfdHJhbnNmb3JtMS56LCAxCiAgKTsKCiAgdmVjMyBwb3MgPSBwcm9qZWN0aW9uTWF0cml4ICogdmlld01hdHJpeCAqIG1vZGVsTWF0cml4ICogdmVjMyhhX3ZlcnRleFBvc2l0aW9uLnh5LCAxLjApOwogIGdsX1Bvc2l0aW9uID0gdmVjNChwb3MueHksIDEuMCwgMS4wKTsKCiNpZmRlZiBHUkFESUVOVAogIHZlYzMgdmcxID0gdmlld01hdHJpeCAqIHZlYzModV9yYWRpYWxHcmFkaWVudFZlY3RvclswXSwgdV9yYWRpYWxHcmFkaWVudFZlY3RvclsxXSwgMS4wKTsKICB2ZWMzIHZnMiA9IHZpZXdNYXRyaXggKiB2ZWMzKHVfcmFkaWFsR3JhZGllbnRWZWN0b3JbM10sIHVfcmFkaWFsR3JhZGllbnRWZWN0b3JbNF0sIDEuMCk7CiAgZmxvYXQgaCA9IHVfcmVzb2x1dGlvbi55OwogIHZnMS55ID0gaCAtIHZnMS55OwogIHZnMi55ID0gaCAtIHZnMi55OwogIHZHcmFkaWVudFZlY3RvcjEgPSB2ZWMzKHZnMS54eSwgdV9yYWRpYWxHcmFkaWVudFZlY3RvclsyXSk7CiAgdkdyYWRpZW50VmVjdG9yMiA9IHZlYzModmcyLnh5LCB1X3JhZGlhbEdyYWRpZW50VmVjdG9yWzVdKTsKI2VuZGlmCiAgCiAgZmxhZ0JhY2tncm91bmQgPSBhX3ZlcnRleFBvc2l0aW9uLno7CgojaWZkZWYgQ0xPVURDT0xPUgogIGlmKGZsYWdCYWNrZ3JvdW5kID4gMC4wKSB7CiAgICB2Q29sb3IgPSBtaXgoYV9jb2xvciwgYV9maWxsQ2xvdWRDb2xvciwgYV9maWxsQ2xvdWRDb2xvci5hKTsKICB9IGVsc2UgewogICAgdkNvbG9yID0gbWl4KGFfY29sb3IsIGFfc3Ryb2tlQ2xvdWRDb2xvciwgYV9zdHJva2VDbG91ZENvbG9yLmEpOwogIH0KI2Vsc2UKICB2Q29sb3IgPSBhX2NvbG9yOwojZW5kaWYKCiNpZmRlZiBURVhUVVJFCiAgdlRleHR1cmVDb29yZCA9IGFfdmVydGV4VGV4dHVyZUNvb3JkOwogIGZyYW1lSW5kZXggPSBhX2ZyYW1lSW5kZXg7CiAgdlNvdXJjZVJlY3QgPSBhX3NvdXJjZVJlY3Q7CiNlbmRpZgoKI2lmZGVmIENMSVBQQVRICiAgdkNsaXBVViA9IGFfY2xpcFVWOwojZW5kaWYKCiNpZmRlZiBDTE9VREZJTFRFUgogIGNvbG9yQ2xvdWQwID0gYV9jb2xvckNsb3VkMDsKICBjb2xvckNsb3VkMSA9IGFfY29sb3JDbG91ZDE7CiAgY29sb3JDbG91ZDIgPSBhX2NvbG9yQ2xvdWQyOwogIGNvbG9yQ2xvdWQzID0gYV9jb2xvckNsb3VkMzsKICBjb2xvckNsb3VkNCA9IGFfY29sb3JDbG91ZDQ7CiNlbmRpZgp9YH0sZnVuY3Rpb24oZyxlLHQpe3QucihlKSxlLmRlZmF1bHQ9YHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0OwoKdmFyeWluZyB2ZWM0IHZDb2xvcjsKdmFyeWluZyBmbG9hdCBmbGFnQmFja2dyb3VuZDsKCiNpZmRlZiBURVhUVVJFCnZhcnlpbmcgZmxvYXQgZnJhbWVJbmRleDsKdmFyeWluZyB2ZWMzIHZUZXh0dXJlQ29vcmQ7CnZhcnlpbmcgdmVjNCB2U291cmNlUmVjdDsKI2VuZGlmCgojaWZkZWYgQ0xJUFBBVEgKdmFyeWluZyB2ZWMyIHZDbGlwVVY7CiNlbmRpZgoKI2lmZGVmIEZJTFRFUgp1bmlmb3JtIGludCB1X2ZpbHRlckZsYWc7CnVuaWZvcm0gZmxvYXQgdV9jb2xvck1hdHJpeFsyMF07CiNlbmRpZgoKI2lmZGVmIENMT1VERklMVEVSCnZhcnlpbmcgdmVjNCBjb2xvckNsb3VkMDsKdmFyeWluZyB2ZWM0IGNvbG9yQ2xvdWQxOwp2YXJ5aW5nIHZlYzQgY29sb3JDbG91ZDI7CnZhcnlpbmcgdmVjNCBjb2xvckNsb3VkMzsKdmFyeWluZyB2ZWM0IGNvbG9yQ2xvdWQ0OwojZW5kaWYKCiNpZmRlZiBHUkFESUVOVAp2YXJ5aW5nIHZlYzMgdkdyYWRpZW50VmVjdG9yMTsKdmFyeWluZyB2ZWMzIHZHcmFkaWVudFZlY3RvcjI7CnVuaWZvcm0gZmxvYXQgdV9jb2xvclN0ZXBzWzQwXTsKdW5pZm9ybSBpbnQgdV9ncmFkaWVudFR5cGU7Cgp2b2lkIGdyYWRpZW50KGlub3V0IHZlYzQgY29sb3IsIHZlYzMgZ3YxLCB2ZWMzIGd2MiwgZmxvYXQgY29sb3JTdGVwc1s0MF0pIHsKICBmbG9hdCB0OwogIC8vIGNlbnRlciBjaXJjbGUgcmFkaXVzCiAgZmxvYXQgY3IgPSBndjEuejsKICAvLyBmb2NhbCBjaXJjbGUgcmFkaXVzCiAgZmxvYXQgZnIgPSBndjIuejsKCiAgaWYoY3IgPiAwLjAgfHwgZnIgPiAwLjApIHsKICAgIC8vIHJhZGlhbCBncmFkaWVudAogICAgdmVjMiBjZW50ZXIgPSBndjEueHk7CiAgICB2ZWMyIGZvY2FsID0gZ3YyLnh5OwogICAgZmxvYXQgeCA9IGZvY2FsLnggLSBnbF9GcmFnQ29vcmQueDsKICAgIGZsb2F0IHkgPSBmb2NhbC55IC0gZ2xfRnJhZ0Nvb3JkLnk7CiAgICBmbG9hdCBkeCA9IGZvY2FsLnggLSBjZW50ZXIueDsKICAgIGZsb2F0IGR5ID0gZm9jYWwueSAtIGNlbnRlci55OwogICAgZmxvYXQgZHIgPSBjciAtIGZyOwogICAgZmxvYXQgYSA9IGR4ICogZHggKyBkeSAqIGR5IC0gZHIgKiBkcjsKICAgIGZsb2F0IGIgPSAtMi4wICogKHkgKiBkeSArIHggKiBkeCArIGZyICogZHIpOwogICAgZmxvYXQgYyA9IHggKiB4ICsgeSAqIHkgLSBmciAqIGZyOwogICAgdCA9IDEuMCAtIDAuNSAqICgxLjAgLyBhKSAqICgtYiArIHNxcnQoYiAqIGIgLSA0LjAgKiBhICogYykpOwogIH0gZWxzZSB7CiAgICAvLyBsaW5lYXIgZ3JhZGllbnQKICAgIHZlYzIgdjEgPSBnbF9GcmFnQ29vcmQueHkgLSBndjEueHk7CiAgICB2ZWMyIHYyID0gZ3YyLnh5IC0gZ3YxLnh5OwogICAgdCA9ICh2MS54ICogdjIueCArIHYxLnkgKiB2Mi55KSAvICh2Mi54ICogdjIueCArIHYyLnkgKiB2Mi55KTsKICB9CgogIHZlYzQgY29sb3JzWzhdOwogIGNvbG9yc1swXSA9IHZlYzQoY29sb3JTdGVwc1sxXSwgY29sb3JTdGVwc1syXSwgY29sb3JTdGVwc1szXSwgY29sb3JTdGVwc1s0XSk7CiAgY29sb3JzWzFdID0gdmVjNChjb2xvclN0ZXBzWzZdLCBjb2xvclN0ZXBzWzddLCBjb2xvclN0ZXBzWzhdLCBjb2xvclN0ZXBzWzldKTsKICBjb2xvcnNbMl0gPSB2ZWM0KGNvbG9yU3RlcHNbMTFdLCBjb2xvclN0ZXBzWzEyXSwgY29sb3JTdGVwc1sxM10sIGNvbG9yU3RlcHNbMTRdKTsKICBjb2xvcnNbM10gPSB2ZWM0KGNvbG9yU3RlcHNbMTZdLCBjb2xvclN0ZXBzWzE3XSwgY29sb3JTdGVwc1sxOF0sIGNvbG9yU3RlcHNbMTldKTsKICBjb2xvcnNbNF0gPSB2ZWM0KGNvbG9yU3RlcHNbMjFdLCBjb2xvclN0ZXBzWzIyXSwgY29sb3JTdGVwc1syM10sIGNvbG9yU3RlcHNbMjRdKTsKICBjb2xvcnNbNV0gPSB2ZWM0KGNvbG9yU3RlcHNbMjZdLCBjb2xvclN0ZXBzWzI3XSwgY29sb3JTdGVwc1syOF0sIGNvbG9yU3RlcHNbMjldKTsKICBjb2xvcnNbNl0gPSB2ZWM0KGNvbG9yU3RlcHNbMzFdLCBjb2xvclN0ZXBzWzMyXSwgY29sb3JTdGVwc1szM10sIGNvbG9yU3RlcHNbMzRdKTsKICBjb2xvcnNbN10gPSB2ZWM0KGNvbG9yU3RlcHNbMzZdLCBjb2xvclN0ZXBzWzM3XSwgY29sb3JTdGVwc1szOF0sIGNvbG9yU3RlcHNbMzldKTsKICAKICBmbG9hdCBzdGVwc1s4XTsKICBzdGVwc1swXSA9IGNvbG9yU3RlcHNbMF07CiAgc3RlcHNbMV0gPSBjb2xvclN0ZXBzWzVdOwogIHN0ZXBzWzJdID0gY29sb3JTdGVwc1sxMF07CiAgc3RlcHNbM10gPSBjb2xvclN0ZXBzWzE1XTsKICBzdGVwc1s0XSA9IGNvbG9yU3RlcHNbMjBdOwogIHN0ZXBzWzVdID0gY29sb3JTdGVwc1syNV07CiAgc3RlcHNbNl0gPSBjb2xvclN0ZXBzWzMwXTsKICBzdGVwc1s3XSA9IGNvbG9yU3RlcHNbMzVdOwoKICBjb2xvciA9IGNvbG9yc1swXTsKICBmb3IgKGludCBpID0gMTsgaSA8IDg7IGkrKykgewogICAgaWYgKHN0ZXBzW2ldIDwgMC4wIHx8IHN0ZXBzW2ldID4gMS4wKSB7CiAgICAgIGJyZWFrOwogICAgfQogICAgaWYoc3RlcHNbaV0gPT0gc3RlcHNbaSAtIDFdKSB7CiAgICAgIGNvbG9yID0gY29sb3JzW2ldOwogICAgfSBlbHNlIHsKICAgICAgY29sb3IgPSBtaXgoY29sb3IsIGNvbG9yc1tpXSwgY2xhbXAoKHQgLSBzdGVwc1tpIC0gMV0pIC8gKHN0ZXBzW2ldIC0gc3RlcHNbaSAtIDFdKSwgMC4wLCAxLjApKTsKICAgIH0KICAgIGlmIChzdGVwc1tpXSA+PSB0KSB7CiAgICAgIGJyZWFrOwogICAgfQogIH0KfQojZW5kaWYKCnZvaWQgdHJhbnNmb3JtQ29sb3IoaW5vdXQgdmVjNCBjb2xvciwgaW4gZmxvYXQgY29sb3JNYXRyaXhbMjBdKSB7CiAgZmxvYXQgciA9IGNvbG9yLnIsIGcgPSBjb2xvci5nLCBiID0gY29sb3IuYiwgYSA9IGNvbG9yLmE7CiAgY29sb3JbMF0gPSBjb2xvck1hdHJpeFswXSAqIHIgKyBjb2xvck1hdHJpeFsxXSAqIGcgKyBjb2xvck1hdHJpeFsyXSAqIGIgKyBjb2xvck1hdHJpeFszXSAqIGEgKyBjb2xvck1hdHJpeFs0XTsKICBjb2xvclsxXSA9IGNvbG9yTWF0cml4WzVdICogciArIGNvbG9yTWF0cml4WzZdICogZyArIGNvbG9yTWF0cml4WzddICogYiArIGNvbG9yTWF0cml4WzhdICogYSArIGNvbG9yTWF0cml4WzldOwogIGNvbG9yWzJdID0gY29sb3JNYXRyaXhbMTBdICogciArIGNvbG9yTWF0cml4WzExXSAqIGcgKyBjb2xvck1hdHJpeFsxMl0gKiBiICsgY29sb3JNYXRyaXhbMTNdICogYSArIGNvbG9yTWF0cml4WzE0XTsKICBjb2xvclszXSA9IGNvbG9yTWF0cml4WzE1XSAqIHIgKyBjb2xvck1hdHJpeFsxNl0gKiBnICsgY29sb3JNYXRyaXhbMTddICogYiArIGNvbG9yTWF0cml4WzE4XSAqIGEgKyBjb2xvck1hdHJpeFsxOV07Cn0KCiNpZmRlZiBDTE9VREZJTFRFUgp2b2lkIGJ1aWxkQ2xvdWRDb2xvcihpbm91dCBmbG9hdCBjb2xvckNsb3VkTWF0cml4WzIwXSkgewogIGNvbG9yQ2xvdWRNYXRyaXhbMF0gPSBjb2xvckNsb3VkMFswXTsKICBjb2xvckNsb3VkTWF0cml4WzFdID0gY29sb3JDbG91ZDFbMF07CiAgY29sb3JDbG91ZE1hdHJpeFsyXSA9IGNvbG9yQ2xvdWQyWzBdOwogIGNvbG9yQ2xvdWRNYXRyaXhbM10gPSBjb2xvckNsb3VkM1swXTsKICBjb2xvckNsb3VkTWF0cml4WzRdID0gY29sb3JDbG91ZDRbMF07CgogIGNvbG9yQ2xvdWRNYXRyaXhbNV0gPSBjb2xvckNsb3VkMFsxXTsKICBjb2xvckNsb3VkTWF0cml4WzZdID0gY29sb3JDbG91ZDFbMV07CiAgY29sb3JDbG91ZE1hdHJpeFs3XSA9IGNvbG9yQ2xvdWQyWzFdOwogIGNvbG9yQ2xvdWRNYXRyaXhbOF0gPSBjb2xvckNsb3VkM1sxXTsKICBjb2xvckNsb3VkTWF0cml4WzldID0gY29sb3JDbG91ZDRbMV07CgogIGNvbG9yQ2xvdWRNYXRyaXhbMTBdID0gY29sb3JDbG91ZDBbMl07CiAgY29sb3JDbG91ZE1hdHJpeFsxMV0gPSBjb2xvckNsb3VkMVsyXTsKICBjb2xvckNsb3VkTWF0cml4WzEyXSA9IGNvbG9yQ2xvdWQyWzJdOwogIGNvbG9yQ2xvdWRNYXRyaXhbMTNdID0gY29sb3JDbG91ZDNbMl07CiAgY29sb3JDbG91ZE1hdHJpeFsxNF0gPSBjb2xvckNsb3VkNFsyXTsKCiAgY29sb3JDbG91ZE1hdHJpeFsxNV0gPSBjb2xvckNsb3VkMFszXTsKICBjb2xvckNsb3VkTWF0cml4WzE2XSA9IGNvbG9yQ2xvdWQxWzNdOwogIGNvbG9yQ2xvdWRNYXRyaXhbMTddID0gY29sb3JDbG91ZDJbM107CiAgY29sb3JDbG91ZE1hdHJpeFsxOF0gPSBjb2xvckNsb3VkM1szXTsKICBjb2xvckNsb3VkTWF0cml4WzE5XSA9IGNvbG9yQ2xvdWQ0WzNdOwp9CiNlbmRpZgoKdm9pZCBtYWluKCkgewogIHZlYzQgY29sb3IgPSB2Q29sb3I7CiAgZmxvYXQgb3BhY2l0eSA9IGFicyhmbGFnQmFja2dyb3VuZCk7CgojaWZkZWYgR1JBRElFTlQKICBpZih1X2dyYWRpZW50VHlwZSA+IDAgJiYgZmxhZ0JhY2tncm91bmQgPiAwLjAgfHwgdV9ncmFkaWVudFR5cGUgPT0gMCAmJiBmbGFnQmFja2dyb3VuZCA8PSAwLjApIHsKICAgIGdyYWRpZW50KGNvbG9yLCB2R3JhZGllbnRWZWN0b3IxLCB2R3JhZGllbnRWZWN0b3IyLCB1X2NvbG9yU3RlcHMpOwogIH0KI2VuZGlmCgogIGlmKG9wYWNpdHkgPCAxLjApIHsKICAgIGNvbG9yLmEgKj0gb3BhY2l0eTsKICB9CgojaWZkZWYgVEVYVFVSRQogIGlmKGZsYWdCYWNrZ3JvdW5kID4gMC4wKSB7CiAgICB2ZWMzIHRleENvb3JkID0gdlRleHR1cmVDb29yZDsKCiAgICBpZih0ZXhDb29yZC56ID09IDEuMCkgewogICAgICB0ZXhDb29yZCA9IGZyYWN0KHRleENvb3JkKTsKICAgIH0KCiAgICBpZih0ZXhDb29yZC54IDw9IDEuMCAmJiB0ZXhDb29yZC54ID49IDAuMAogICAgICAmJiB0ZXhDb29yZC55IDw9IDEuMCAmJiB0ZXhDb29yZC55ID49IDAuMCkgewogICAgICBpZih2U291cmNlUmVjdC56ID4gMC4wKSB7CiAgICAgICAgdGV4Q29vcmQueCA9IHZTb3VyY2VSZWN0LnggKyB0ZXhDb29yZC54ICogdlNvdXJjZVJlY3QuejsKICAgICAgICB0ZXhDb29yZC55ID0gMS4wIC0gKHZTb3VyY2VSZWN0LnkgKyAoMS4wIC0gdGV4Q29vcmQueSkgKiB2U291cmNlUmVjdC53KTsKICAgICAgfQogICAgICBpZihmcmFtZUluZGV4IDwgMC4wKSB7CiAgICAgICAgdmVjNCB0ZXhDb2xvciA9IHRleHR1cmUyRCh1X3RleFNhbXBsZXIsIHRleENvb3JkLnh5KTsKICAgICAgICBjb2xvciA9IG1peChjb2xvciwgdGV4Q29sb3IsIHRleENvbG9yLmEpOwogICAgICB9IGVsc2UgewogICAgICAgIGludCBpbmRleCA9IGludChmbG9vcihjbGFtcCgwLjAsIDExLjAsIGZyYW1lSW5kZXgpKSk7CiAgICAgICAgdmVjNCB0ZXhDb2xvcjsKICAgICAgICBpZihpbmRleCA9PSAwKSB0ZXhDb2xvciA9IHRleHR1cmUyRCh1X3RleEZyYW1lMCwgdGV4Q29vcmQueHkpOwogICAgICAgIGVsc2UgaWYoaW5kZXggPT0gMSkgdGV4Q29sb3IgPSB0ZXh0dXJlMkQodV90ZXhGcmFtZTEsIHRleENvb3JkLnh5KTsKICAgICAgICBlbHNlIGlmKGluZGV4ID09IDIpIHRleENvbG9yID0gdGV4dHVyZTJEKHVfdGV4RnJhbWUyLCB0ZXhDb29yZC54eSk7CiAgICAgICAgZWxzZSBpZihpbmRleCA9PSAzKSB0ZXhDb2xvciA9IHRleHR1cmUyRCh1X3RleEZyYW1lMywgdGV4Q29vcmQueHkpOwogICAgICAgIGVsc2UgaWYoaW5kZXggPT0gNCkgdGV4Q29sb3IgPSB0ZXh0dXJlMkQodV90ZXhGcmFtZTQsIHRleENvb3JkLnh5KTsKICAgICAgICBlbHNlIGlmKGluZGV4ID09IDUpIHRleENvbG9yID0gdGV4dHVyZTJEKHVfdGV4RnJhbWU1LCB0ZXhDb29yZC54eSk7CiAgICAgICAgZWxzZSBpZihpbmRleCA9PSA2KSB0ZXhDb2xvciA9IHRleHR1cmUyRCh1X3RleEZyYW1lNiwgdGV4Q29vcmQueHkpOwogICAgICAgIGVsc2UgaWYoaW5kZXggPT0gNykgdGV4Q29sb3IgPSB0ZXh0dXJlMkQodV90ZXhGcmFtZTcsIHRleENvb3JkLnh5KTsKICAgICAgICBlbHNlIGlmKGluZGV4ID09IDgpIHRleENvbG9yID0gdGV4dHVyZTJEKHVfdGV4RnJhbWU4LCB0ZXhDb29yZC54eSk7CiAgICAgICAgZWxzZSBpZihpbmRleCA9PSA5KSB0ZXhDb2xvciA9IHRleHR1cmUyRCh1X3RleEZyYW1lOSwgdGV4Q29vcmQueHkpOwogICAgICAgIGVsc2UgaWYoaW5kZXggPT0gMTApIHRleENvbG9yID0gdGV4dHVyZTJEKHVfdGV4RnJhbWUxMCwgdGV4Q29vcmQueHkpOwogICAgICAgIGVsc2UgdGV4Q29sb3IgPSB0ZXh0dXJlMkQodV90ZXhGcmFtZTExLCB0ZXhDb29yZC54eSk7CiAgICAgICAgZmxvYXQgYWxwaGEgPSB0ZXhDb2xvci5hOwogICAgICAgIGlmKG9wYWNpdHkgPCAxLjApIHsKICAgICAgICAgIHRleENvbG9yLmEgKj0gb3BhY2l0eTsKICAgICAgICAgIGFscGhhICo9IG1peCgwLjQ2NSwgMS4wLCBvcGFjaXR5KTsKICAgICAgICB9CiAgICAgICAgLy8gY29sb3IgPSBtaXgoY29sb3IsIHRleENvbG9yLCB0ZXhDb2xvci5hKTsKICAgICAgICBjb2xvci5yZ2IgPSBtaXgoY29sb3IucmdiLCB0ZXhDb2xvci5yZ2IsIGFscGhhKTsKICAgICAgICAvLyBjb2xvci5yZ2IgPSBtaXgodGV4Q29sb3IucmdiLCBjb2xvci5yZ2IsIGNvbG9yLmEpOwogICAgICAgIGNvbG9yLnJnYiA9IG1peCh0ZXhDb2xvci5yZ2IsIGNvbG9yLnJnYiwgY2xhbXAoY29sb3IuYSAvIG1heCgwLjAwMDEsIHRleENvbG9yLmEpLCAwLjAsIDEuMCkpOwogICAgICAgIGNvbG9yLmEgPSB0ZXhDb2xvci5hICsgKDEuMCAtIHRleENvbG9yLmEpICogY29sb3IuYTsKICAgICAgfQogICAgfQogIH0KI2VuZGlmCgojaWZkZWYgRklMVEVSCiAgaWYodV9maWx0ZXJGbGFnID4gMCkgewogICAgdHJhbnNmb3JtQ29sb3IoY29sb3IsIHVfY29sb3JNYXRyaXgpOwogIH0KI2VuZGlmCgojaWZkZWYgQ0xPVURGSUxURVIKICBmbG9hdCBjb2xvckNsb3VkTWF0cml4WzIwXTsKICBidWlsZENsb3VkQ29sb3IoY29sb3JDbG91ZE1hdHJpeCk7CiAgdHJhbnNmb3JtQ29sb3IoY29sb3IsIGNvbG9yQ2xvdWRNYXRyaXgpOwojZW5kaWYKCiNpZmRlZiBDTElQUEFUSAogIGZsb2F0IGNsaXAgPSB0ZXh0dXJlMkQodV9jbGlwU2FtcGxlciwgdkNsaXBVVikucjsKICBjb2xvciAqPSBjbGlwOwojZW5kaWYKCiAgZ2xfRnJhZ0NvbG9yID0gY29sb3I7Cn1gfSxmdW5jdGlvbihnLGUsdCl7dC5yKGUpLChmdW5jdGlvbihuLGkpe3QuZChlLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLGZ1bmN0aW9uKCl7cmV0dXJuIGh9KSx0LmQoZSwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLGZ1bmN0aW9uKCl7cmV0dXJuIHV9KSx0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gZigpe2lmKHR5cGVvZiBwZXJmb3JtYW5jZTwidSImJnBlcmZvcm1hbmNlLm5vdylyZXR1cm4gcGVyZm9ybWFuY2Uubm93KCk7aWYodHlwZW9mIG48InUiJiZuLmhydGltZSl7Y29uc3RbYSxkXT1uLmhydGltZSgpO3JldHVybiBhKjFlMytkKjFlLTZ9cmV0dXJuIERhdGUubm93P0RhdGUubm93KCk6bmV3IERhdGUoKS5nZXRUaW1lKCl9bGV0IGgsdTt0eXBlb2YgaTwidSImJnR5cGVvZiBpLnJlcXVlc3RBbmltYXRpb25GcmFtZT09ImZ1bmN0aW9uIj8oaD1pLnJlcXVlc3RBbmltYXRpb25GcmFtZSx1PWkuY2FuY2VsQW5pbWF0aW9uRnJhbWUpOihoPWZ1bmN0aW9uKGEpe3JldHVybiBzZXRUaW1lb3V0KCgpPT57YShmKCkpfSwxNil9LHU9ZnVuY3Rpb24oYSl7cmV0dXJuIGNsZWFyVGltZW91dChhKX0pfSkuY2FsbCh0aGlzLHQoNjkpLHQoMjIpKX0sZnVuY3Rpb24oZyxlKXt2YXIgdD1nLmV4cG9ydHM9e30sbixpO2Z1bmN0aW9uIGYoKXt0aHJvdyBuZXcgRXJyb3IoInNldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQiKX1mdW5jdGlvbiBoKCl7dGhyb3cgbmV3IEVycm9yKCJjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQiKX0oZnVuY3Rpb24oKXt0cnl7dHlwZW9mIHNldFRpbWVvdXQ9PSJmdW5jdGlvbiI/bj1zZXRUaW1lb3V0Om49Zn1jYXRjaHtuPWZ9dHJ5e3R5cGVvZiBjbGVhclRpbWVvdXQ9PSJmdW5jdGlvbiI/aT1jbGVhclRpbWVvdXQ6aT1ofWNhdGNoe2k9aH19KSgpO2Z1bmN0aW9uIHUoUyl7aWYobj09PXNldFRpbWVvdXQpcmV0dXJuIHNldFRpbWVvdXQoUywwKTtpZigobj09PWZ8fCFuKSYmc2V0VGltZW91dClyZXR1cm4gbj1zZXRUaW1lb3V0LHNldFRpbWVvdXQoUywwKTt0cnl7cmV0dXJuIG4oUywwKX1jYXRjaHt0cnl7cmV0dXJuIG4uY2FsbChudWxsLFMsMCl9Y2F0Y2h7cmV0dXJuIG4uY2FsbCh0aGlzLFMsMCl9fX1mdW5jdGlvbiBhKFMpe2lmKGk9PT1jbGVhclRpbWVvdXQpcmV0dXJuIGNsZWFyVGltZW91dChTKTtpZigoaT09PWh8fCFpKSYmY2xlYXJUaW1lb3V0KXJldHVybiBpPWNsZWFyVGltZW91dCxjbGVhclRpbWVvdXQoUyk7dHJ5e3JldHVybiBpKFMpfWNhdGNoe3RyeXtyZXR1cm4gaS5jYWxsKG51bGwsUyl9Y2F0Y2h7cmV0dXJuIGkuY2FsbCh0aGlzLFMpfX19dmFyIGQ9W10sRT0hMSxwLE89LTE7ZnVuY3Rpb24gbSgpeyFFfHwhcHx8KEU9ITEscC5sZW5ndGg/ZD1wLmNvbmNhdChkKTpPPS0xLGQubGVuZ3RoJiZiKCkpfWZ1bmN0aW9uIGIoKXtpZighRSl7dmFyIFM9dShtKTtFPSEwO2Zvcih2YXIgcz1kLmxlbmd0aDtzOyl7Zm9yKHA9ZCxkPVtdOysrTzxzOylwJiZwW09dLnJ1bigpO089LTEscz1kLmxlbmd0aH1wPW51bGwsRT0hMSxhKFMpfX10Lm5leHRUaWNrPWZ1bmN0aW9uKFMpe3ZhciBzPW5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoLTEpO2lmKGFyZ3VtZW50cy5sZW5ndGg+MSlmb3IodmFyIGM9MTtjPGFyZ3VtZW50cy5sZW5ndGg7YysrKXNbYy0xXT1hcmd1bWVudHNbY107ZC5wdXNoKG5ldyBNKFMscykpLGQubGVuZ3RoPT09MSYmIUUmJnUoYil9O2Z1bmN0aW9uIE0oUyxzKXt0aGlzLmZ1bj1TLHRoaXMuYXJyYXk9c31NLnByb3RvdHlwZS5ydW49ZnVuY3Rpb24oKXt0aGlzLmZ1bi5hcHBseShudWxsLHRoaXMuYXJyYXkpfSx0LnRpdGxlPSJicm93c2VyIix0LmJyb3dzZXI9ITAsdC5lbnY9e30sdC5hcmd2PVtdLHQudmVyc2lvbj0iIix0LnZlcnNpb25zPXt9O2Z1bmN0aW9uIHkoKXt9dC5vbj15LHQuYWRkTGlzdGVuZXI9eSx0Lm9uY2U9eSx0Lm9mZj15LHQucmVtb3ZlTGlzdGVuZXI9eSx0LnJlbW92ZUFsbExpc3RlbmVycz15LHQuZW1pdD15LHQucHJlcGVuZExpc3RlbmVyPXksdC5wcmVwZW5kT25jZUxpc3RlbmVyPXksdC5saXN0ZW5lcnM9ZnVuY3Rpb24oUyl7cmV0dXJuW119LHQuYmluZGluZz1mdW5jdGlvbihTKXt0aHJvdyBuZXcgRXJyb3IoInByb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkIil9LHQuY3dkPWZ1bmN0aW9uKCl7cmV0dXJuIi8ifSx0LmNoZGlyPWZ1bmN0aW9uKFMpe3Rocm93IG5ldyBFcnJvcigicHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkIil9LHQudW1hc2s9ZnVuY3Rpb24oKXtyZXR1cm4gMH19LGZ1bmN0aW9uKGcsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIEx9KTt2YXIgbj10KDEpLGk9dCg3MSksZj10KDczKSxoPXQoMjEzKSx1PXQoMjE0KSxhPXQoMjE1KSxkPXQoMjE2KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gRShOLEEpe3ZhciB3PU9iamVjdC5rZXlzKE4pO2lmKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpe3ZhciBCPU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoTik7QSYmKEI9Qi5maWx0ZXIoZnVuY3Rpb24oRCl7cmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTixEKS5lbnVtZXJhYmxlfSkpLHcucHVzaC5hcHBseSh3LEIpfXJldHVybiB3fWZ1bmN0aW9uIHAoTil7Zm9yKHZhciBBPTE7QTxhcmd1bWVudHMubGVuZ3RoO0ErKyl7dmFyIHc9YXJndW1lbnRzW0FdIT1udWxsP2FyZ3VtZW50c1tBXTp7fTtBJTI/RShPYmplY3QodyksITApLmZvckVhY2goZnVuY3Rpb24oQil7TyhOLEIsd1tCXSl9KTpPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycz9PYmplY3QuZGVmaW5lUHJvcGVydGllcyhOLE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHcpKTpFKE9iamVjdCh3KSkuZm9yRWFjaChmdW5jdGlvbihCKXtPYmplY3QuZGVmaW5lUHJvcGVydHkoTixCLE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodyxCKSl9KX1yZXR1cm4gTn1mdW5jdGlvbiBPKE4sQSx3KXtyZXR1cm4gQSBpbiBOP09iamVjdC5kZWZpbmVQcm9wZXJ0eShOLEEse3ZhbHVlOncsZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTpOW0FdPXcsTn1jb25zdCBtPVN5bWJvbC5mb3IoInNwcml0ZWpzX2NoYW5nZWRBdHRycyIpLGI9U3ltYm9sLmZvcigic3ByaXRlanNfYXR0cmlidXRlcyIpLE09U3ltYm9sKCJyZXNvbHV0aW9uIikseT1TeW1ib2woImFuaW1hdGlvbnMiKSxTPVN5bWJvbCgiZXZlbnRMaXN0ZW5lcnMiKSxzPVN5bWJvbCgiY2FwdHVyZUV2ZW50TGlzdGVuZXJzIiksYz1TeW1ib2woImZpbHRlcnMiKSxsPVN5bWJvbCgiZGlzcGxheSIpLHY9U3ltYm9sKCJwcm9ncmFtIiksVD1TeW1ib2woInNoYWRlckF0dHJzIiksUj1TeW1ib2woInVuaWZvcm1zIik7Y2xhc3MgTHtjb25zdHJ1Y3RvcihBPXt9KXt0aGlzLmF0dHJpYnV0ZXM9bmV3IHRoaXMuY29uc3RydWN0b3IuQXR0cih0aGlzKSx0aGlzW01dPXt3aWR0aDozMDAsaGVpZ2h0OjE1MH0sT2JqZWN0LmFzc2lnbih0aGlzLmF0dHJpYnV0ZXMsQSksdGhpc1t5XT1uZXcgU2V0LHRoaXNbU109e30sdGhpc1tzXT17fX1nZXQgYW5jZXN0b3JzKCl7bGV0IEE9dGhpcy5wYXJlbnQ7Y29uc3Qgdz1bXTtmb3IoO0E7KXcucHVzaChBKSxBPUEucGFyZW50O3JldHVybiB3fWdldCBhbmltYXRpb25zKCl7cmV0dXJuIHRoaXNbeV19Z2V0IGZpbHRlcnMoKXtyZXR1cm4gdGhpc1tjXXx8dGhpcy5wYXJlbnQmJnRoaXMucGFyZW50LmZpbHRlcnN9Z2V0IGlzVmlzaWJsZSgpe3JldHVybiExfWdldCBsYXllcigpe3JldHVybiB0aGlzLnBhcmVudD90aGlzLnBhcmVudC5sYXllcjpudWxsfWdldCBsb2NhbE1hdHJpeCgpe2NvbnN0IEE9dGhpcy50cmFuc2Zvcm1NYXRyaXgse3g6dyx5OkJ9PXRoaXMuYXR0cmlidXRlcztyZXR1cm4gQVs0XSs9dyxBWzVdKz1CLEF9Z2V0IG9wYWNpdHkoKXtsZXQgQT10aGlzLmF0dHJpYnV0ZXMub3BhY2l0eTtyZXR1cm4gdGhpcy5wYXJlbnQmJnRoaXMucGFyZW50Lm9wYWNpdHkhPW51bGwmJihBKj10aGlzLnBhcmVudC5vcGFjaXR5KSxBfWdldCBwYXJlbnROb2RlKCl7cmV0dXJuIHRoaXMucGFyZW50fWdldCBuZXh0U2libGluZygpe3JldHVybiB0aGlzLmdldE5vZGVOZWFyQnkoMSl9Z2V0IHByZXZpb3VzU2libGluZygpe3JldHVybiB0aGlzLmdldE5vZGVOZWFyQnkoLTEpfWdldCBwcm9ncmFtKCl7cmV0dXJuIHRoaXNbdl19Z2V0IHJlbmRlcmVyKCl7cmV0dXJuIHRoaXMucGFyZW50P3RoaXMucGFyZW50LnJlbmRlcmVyOm51bGx9Z2V0IHJlbmRlck1hdHJpeCgpe2lmKHRoaXMuX19jYWNoZVJlbmRlck1hdHJpeClyZXR1cm4gdGhpcy5fX2NhY2hlUmVuZGVyTWF0cml4O2xldCBBPXRoaXMubG9jYWxNYXRyaXg7Y29uc3Qgdz10aGlzLnBhcmVudDtpZih3KXtjb25zdCBCPXcuX19jYWNoZVJlbmRlck1hdHJpeHx8dy5yZW5kZXJNYXRyaXg7QiYmKEE9bi5tYXQyZC5tdWx0aXBseShBcnJheS5vZigwLDAsMCwwLDAsMCksQixBKSl9cmV0dXJuIEF9Z2V0IHdvcmxkU2NhbGluZygpe2NvbnN0IEE9dGhpcy5yZW5kZXJNYXRyaXg7cmV0dXJuW01hdGguaHlwb3QoQVswXSxBWzFdKSxNYXRoLmh5cG90KEFbMl0sQVszXSldfWdldCB3b3JsZFJvdGF0aW9uKCl7Y29uc3QgQT10aGlzLnJlbmRlck1hdHJpeDtyZXR1cm4gTWF0aC5hdGFuMihBWzFdLEFbM10pfWdldCB3b3JsZFBvc2l0aW9uKCl7Y29uc3QgQT10aGlzLnJlbmRlck1hdHJpeDtyZXR1cm5bQVs0XSxBWzVdXX1nZXQgdW5pZm9ybXMoKXtyZXR1cm4gdGhpc1tSXX1nZXQgY2xhc3NOYW1lKCl7cmV0dXJuIHRoaXMuYXR0cmlidXRlcy5jbGFzc05hbWV9c2V0IGNsYXNzTmFtZShBKXt0aGlzLmF0dHJpYnV0ZXMuY2xhc3NOYW1lPUF9Z2V0IGlkKCl7cmV0dXJuIHRoaXMuYXR0cmlidXRlcy5pZH1zZXQgaWQoQSl7dGhpcy5hdHRyaWJ1dGVzLmlkPUF9Z2V0IG5hbWUoKXtyZXR1cm4gdGhpcy5hdHRyaWJ1dGVzLm5hbWV9c2V0IG5hbWUoQSl7dGhpcy5hdHRyaWJ1dGVzLm5hbWU9QX1nZXQgekluZGV4KCl7cmV0dXJuIHRoaXMuYXR0cmlidXRlcy56SW5kZXh9c2V0IHpJbmRleChBKXt0aGlzLmF0dHJpYnV0ZXMuekluZGV4PUF9Z2V0IG1lc2goKXtyZXR1cm4gbnVsbH1nZXQgc2hhZGVyQXR0cnMoKXtyZXR1cm4gdGhpc1tUXXx8e319YWN0aXZhdGVBbmltYXRpb25zKCl7Y29uc3QgQT10aGlzLmxheWVyO2lmKEEpe2NvbnN0IHc9dGhpc1t5XTt3LmZvckVhY2goRD0+e0QuYmFzZVRpbWVsaW5lPUEudGltZWxpbmUsRC5wbGF5KCksRC5maW5pc2hlZC50aGVuKCgpPT57dy5kZWxldGUoRCl9KX0pO2NvbnN0IEI9dGhpcy5jaGlsZHJlbjtCJiZCLmZvckVhY2goRD0+e0QuYWN0aXZhdGVBbmltYXRpb25zJiZELmFjdGl2YXRlQW5pbWF0aW9ucygpfSl9fWFkZEV2ZW50TGlzdGVuZXIoQSx3LEI9e30pe0E9PT0ibW91c2V3aGVlbCImJihBPSJ3aGVlbCIpLHR5cGVvZiBCPT0iYm9vbGVhbiImJihCPXtjYXB0dXJlOkJ9KTtjb25zdHtjYXB0dXJlOkQsb25jZTpJfT1CLGo9RD9zOlM7cmV0dXJuIHRoaXNbal1bQV09dGhpc1tqXVtBXXx8W10sdGhpc1tqXVtBXS5wdXNoKHtsaXN0ZW5lcjp3LG9uY2U6SX0pLHRoaXN9YW5pbWF0ZShBLHcpe2NvbnN0IEI9bmV3IGYuZGVmYXVsdCh0aGlzLEEsdyk7cmV0dXJuIHRoaXMuZWZmZWN0cyYmQi5hcHBseUVmZmVjdHModGhpcy5lZmZlY3RzKSx0aGlzLmxheWVyJiYoQi5iYXNlVGltZWxpbmU9dGhpcy5sYXllci50aW1lbGluZSxCLnBsYXkoKSxCLmZpbmlzaGVkLnRoZW4oKCk9Pnt0aGlzW3ldLmRlbGV0ZShCKX0pKSx0aGlzW3ldLmFkZChCKSxCfWF0dHIoLi4uQSl7aWYoQS5sZW5ndGg9PT0wKXJldHVybiB0aGlzLmF0dHJpYnV0ZXNbYl07aWYoQS5sZW5ndGg+MSl7bGV0W3csQl09QTtyZXR1cm4gdHlwZW9mIEI9PSJmdW5jdGlvbiImJihCPUIodGhpcy5hdHRyKHcpKSksdGhpcy5zZXRBdHRyaWJ1dGUodyxCKSx0aGlzfXJldHVybiB0eXBlb2YgQVswXT09InN0cmluZyI/dGhpcy5nZXRBdHRyaWJ1dGUoQVswXSk6KE9iamVjdC5hc3NpZ24odGhpcy5hdHRyaWJ1dGVzLEFbMF0pLHRoaXMpfWNsb25lTm9kZSgpe2NvbnN0IEE9bmV3IHRoaXMuY29uc3RydWN0b3Isdz10aGlzLmF0dHJpYnV0ZXNbbV07cmV0dXJuIEEuYXR0cih3KSxBfWNvbm5lY3QoQSx3KXtPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywicGFyZW50Iix7dmFsdWU6QSx3cml0YWJsZTohMSxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiek9yZGVyIix7dmFsdWU6dyx3cml0YWJsZTohMSxjb25maWd1cmFibGU6ITB9KSxBLnRpbWVsaW5lJiZ0aGlzLmFjdGl2YXRlQW5pbWF0aW9ucygpLHRoaXMuc2V0UmVzb2x1dGlvbihBLmdldFJlc29sdXRpb24oKSksdGhpcy5mb3JjZVVwZGF0ZSgpLHRoaXMuZGlzcGF0Y2hFdmVudCh7dHlwZToiYXBwZW5kIixkZXRhaWw6e3BhcmVudDpBLHpPcmRlcjp3fX0pfWNvbnRhaW5zKEEpe2Zvcig7QSYmdGhpcyE9PUE7KUE9QS5wYXJlbnQ7cmV0dXJuISFBfWRlYWN0aXZhdGVBbmltYXRpb25zKCl7dGhpc1t5XS5mb3JFYWNoKHc9PncuY2FuY2VsKCkpO2NvbnN0IEE9dGhpcy5jaGlsZHJlbjtBJiZBLmZvckVhY2godz0+e3cuZGVhY3RpdmF0ZUFuaW1hdGlvbnMmJncuZGVhY3RpdmF0ZUFuaW1hdGlvbnMoKX0pfWRpc2Nvbm5lY3QoKXtjb25zdHtwYXJlbnQ6QSx6T3JkZXI6d309dGhpcztkZWxldGUgdGhpcy5wYXJlbnQsZGVsZXRlIHRoaXMuek9yZGVyLHRoaXMuZGVhY3RpdmF0ZUFuaW1hdGlvbnMoKSx0aGlzLmRpc3BhdGNoRXZlbnQoe3R5cGU6InJlbW92ZSIsZGV0YWlsOntwYXJlbnQ6QSx6T3JkZXI6d319KSxBJiZBLmZvcmNlVXBkYXRlKCl9ZGlzcGF0Y2hFdmVudChBKXtBIGluc3RhbmNlb2YgdS5kZWZhdWx0fHwoQT1uZXcgdS5kZWZhdWx0KEEpKSxBLnRhcmdldD10aGlzO2xldCB3PUEudHlwZTt3PT09Im1vdXNld2hlZWwiJiYodz0id2hlZWwiKTtjb25zdCBCPVt0aGlzXTtsZXQgRD10aGlzLnBhcmVudDtmb3IoO0EuYnViYmxlcyYmRDspQi5wdXNoKEQpLEQ9RC5wYXJlbnQ7Zm9yKGxldCBJPUIubGVuZ3RoLTE7ST49MDtJLS0pe2NvbnN0IGo9QltJXSxWPWpbc10mJmpbc11bd107aWYoViYmVi5sZW5ndGgmJihBLmN1cnJlbnRUYXJnZXQ9aixWLmZvckVhY2goKHtsaXN0ZW5lcjpKLG9uY2U6X30pPT57Si5jYWxsKHRoaXMsQSksXyYmQi5yZW1vdmVFdmVudExpc3RlbmVyKEopfSksZGVsZXRlIEEuY3VycmVudFRhcmdldCksIUEuYnViYmxlcyYmQS5jYW5jZWxCdWJibGUpYnJlYWt9aWYoIUEuY2FuY2VsQnViYmxlKWZvcihsZXQgST0wO0k8Qi5sZW5ndGg7SSsrKXtjb25zdCBqPUJbSV0sVj1qW1NdJiZqW1NdW3ddO2lmKFYmJlYubGVuZ3RoJiYoQS5jdXJyZW50VGFyZ2V0PWosVi5mb3JFYWNoKCh7bGlzdGVuZXI6SixvbmNlOl99KT0+e0ouY2FsbCh0aGlzLEEpLF8mJkIucmVtb3ZlRXZlbnRMaXN0ZW5lcihKKX0pLGRlbGV0ZSBBLmN1cnJlbnRUYXJnZXQpLCFBLmJ1YmJsZXN8fEEuY2FuY2VsQnViYmxlKWJyZWFrfX1kaXNwYXRjaFBvaW50ZXJFdmVudChBKXtjb25zdHtsYXllclg6dyxsYXllclk6Qn09QTtyZXR1cm4gdGhpcy5pc1BvaW50Q29sbGlzaW9uKHcsQik/KHRoaXMuZGlzcGF0Y2hFdmVudChBKSwhMCk6ITF9ZHJhdyhBPVtdKXtjb25zdCB3PXRoaXMubWVzaDtpZih3KXtpZihPYmplY3QoYS5hcHBseUZpbHRlcnMpKHcsdGhpcy5maWx0ZXJzKSxBLnB1c2godyksdGhpc1t2XSl7dy5zZXRQcm9ncmFtKHRoaXNbdl0pO2NvbnN0IEI9dGhpc1tUXTtCJiZPYmplY3QuZW50cmllcyhCKS5mb3JFYWNoKChbSSxqXSk9Pnt3LnNldEF0dHJpYnV0ZShJLGopfSk7Y29uc3QgRD10aGlzW1JdO2lmKHRoaXNbUl0pe2NvbnN0IEk9e307T2JqZWN0LmVudHJpZXMoRCkuZm9yRWFjaCgoW2osVl0pPT57dHlwZW9mIFY9PSJmdW5jdGlvbiImJihWPVYodGhpcyxqKSksSVtqXT1WfSksdy5zZXRVbmlmb3JtcyhJKX19T2JqZWN0KGQuZGVmYXVsdCkodGhpcyx3KX1yZXR1cm4gQX1mb3JjZVVwZGF0ZSgpe3RoaXMucGFyZW50JiZ0aGlzLnBhcmVudC5mb3JjZVVwZGF0ZSgpfWdldEF0dHJpYnV0ZShBKXtyZXR1cm4gdGhpcy5hdHRyaWJ1dGVzW0FdfWdldExpc3RlbmVycyhBLHtjYXB0dXJlOnc9ITF9PXt9KXtyZXR1cm5bLi4udGhpc1t3P3M6U11bQV18fFtdXX1nZXROb2RlTmVhckJ5KEE9MSl7aWYoIXRoaXMucGFyZW50KXJldHVybiBudWxsO2lmKEE9PT0wKXJldHVybiB0aGlzO2NvbnN0IHc9dGhpcy5wYXJlbnQuY2hpbGRyZW4sQj13LmluZGV4T2YodGhpcyk7cmV0dXJuIHdbQitBXX1nZXRXb3JsZFBvc2l0aW9uKEEsdyl7Y29uc3QgQj10aGlzLnJlbmRlck1hdHJpeCxEPUEqQlswXSt3KkJbMl0rQls0XSxJPUEqQlsxXSt3KkJbM10rQls1XTtyZXR1cm5bRCxJXX1nZXRPZmZzZXRQb3NpdGlvbihBLHcpe2NvbnN0IEI9bi5tYXQyZC5pbnZlcnQoQXJyYXkub2YoMCwwLDAsMCwwLDApLHRoaXMucmVuZGVyTWF0cml4KSxEPUEqQlswXSt3KkJbMl0rQls0XSxJPUEqQlsxXSt3KkJbM10rQls1XTtyZXR1cm5bRCxJXX1nZXRSZXNvbHV0aW9uKCl7cmV0dXJuIHAoe30sdGhpc1tNXSl9aXNQb2ludENvbGxpc2lvbihBLHcpe2lmKCF0aGlzLm1lc2gpcmV0dXJuITE7Y29uc3QgQj10aGlzLmF0dHJpYnV0ZXMucG9pbnRlckV2ZW50cztpZihCPT09Im5vbmUifHxCIT09ImFsbCImJiF0aGlzLmlzVmlzaWJsZSlyZXR1cm4hMTtsZXQgRD0iYm90aCI7cmV0dXJuIEI9PT0idmlzaWJsZUZpbGwiJiYoRD0iZmlsbCIpLEI9PT0idmlzaWJsZVN0cm9rZSImJihEPSJzdHJva2UiKSx0aGlzLm1lc2guaXNQb2ludENvbGxpc2lvbihBLHcsRCl9b25Qcm9wZXJ0eUNoYW5nZShBLHcsQil7QSE9PSJpZCImJkEhPT0ibmFtZSImJkEhPT0iY2xhc3NOYW1lIiYmQSE9PSJwb2ludGVyRXZlbnRzIiYmQSE9PSJwYXNzRXZlbnRzIiYmdGhpcy5mb3JjZVVwZGF0ZSgpLEE9PT0iZmlsdGVyIiYmKHRoaXNbY109T2JqZWN0KGEucGFyc2VGaWx0ZXJTdHJpbmcpKHcpKSxBPT09InpJbmRleCImJnRoaXMucGFyZW50JiZ0aGlzLnBhcmVudC5yZW9yZGVyKCl9c2V0QXR0cmlidXRlKEEsdyl7QT09PSJhdHRycyImJnRoaXMuYXR0cih3KSx0aGlzLmF0dHJpYnV0ZXNbQV09d31zZXRNb3VzZUNhcHR1cmUoKXt0aGlzLmxheWVyJiYodGhpcy5sYXllci5fX21vdXNlQ2FwdHVyZWRUYXJnZXQ9dGhpcyl9c2V0UHJvZ3JhbShBKXt0aGlzW3ZdPUEsdGhpcy5mb3JjZVVwZGF0ZSgpfXNldFNoYWRlckF0dHJpYnV0ZShBLHcpe3RoaXNbVF09dGhpc1tUXXx8e30sdGhpc1tUXVtBXT13LHRoaXMuZm9yY2VVcGRhdGUoKX1zZXRVbmlmb3JtcyhBKXt0aGlzW1JdPXRoaXNbUl18fHt9LE9iamVjdC5hc3NpZ24odGhpc1tSXSxBKSx0aGlzLmZvcmNlVXBkYXRlKCl9c2V0UmVzb2x1dGlvbih7d2lkdGg6QSxoZWlnaHQ6d30pe2NvbnN0e3dpZHRoOkIsaGVpZ2h0OkR9PXRoaXNbTV07KEIhPT1BfHxEIT09dykmJih0aGlzW01dPXt3aWR0aDpBLGhlaWdodDp3fSx0aGlzLmZvcmNlVXBkYXRlKCksdGhpcy5kaXNwYXRjaEV2ZW50KHt0eXBlOiJyZXNvbHV0aW9uY2hhbmdlIixkZXRhaWw6e3dpZHRoOkEsaGVpZ2h0Ond9fSkpfXNob3coKXt0aGlzLmF0dHJpYnV0ZXMuZGlzcGxheT09PSJub25lIiYmKHRoaXMuYXR0cmlidXRlcy5kaXNwbGF5PXRoaXNbbF18fCIiKX1oaWRlKCl7dGhpcy5hdHRyaWJ1dGVzLmRpc3BsYXkhPT0ibm9uZSImJih0aGlzW2xdPXRoaXMuYXR0cmlidXRlcy5kaXNwbGF5LHRoaXMuYXR0cmlidXRlcy5kaXNwbGF5PSJub25lIil9cmVsZWFzZU1vdXNlQ2FwdHVyZSgpe3RoaXMubGF5ZXImJnRoaXMubGF5ZXIuX19tb3VzZUNhcHR1cmVkVGFyZ2V0PT09dGhpcyYmKHRoaXMubGF5ZXIuX19tb3VzZUNhcHR1cmVkVGFyZ2V0PW51bGwpfXJlbW92ZSgpe3JldHVybiB0aGlzLnBhcmVudCYmdGhpcy5wYXJlbnQucmVtb3ZlQ2hpbGQ/KHRoaXMucGFyZW50LnJlbW92ZUNoaWxkKHRoaXMpLCEwKTohMX1yZW1vdmVBbGxMaXN0ZW5lcnMoQSx3PXt9KXt0eXBlb2Ygdz09ImJvb2xlYW4iJiYodz17Y2FwdHVyZTp3fSk7Y29uc3QgRD13LmNhcHR1cmU/czpTO3JldHVybiB0aGlzW0RdW0FdJiYodGhpc1tEXVtBXT1bXSksdGhpc31yZW1vdmVBdHRyaWJ1dGUoQSl7dGhpcy5zZXRBdHRyaWJ1dGUoQSxudWxsKX1yZW1vdmVFdmVudExpc3RlbmVyKEEsdyxCPXt9KXt0eXBlb2YgQj09ImJvb2xlYW4iJiYoQj17Y2FwdHVyZTpCfSk7Y29uc3QgST1CLmNhcHR1cmU/czpTO2lmKHRoaXNbSV1bQV0pe2NvbnN0IGo9dGhpc1tJXVtBXTtpZihqKWZvcihsZXQgVj0wO1Y8ai5sZW5ndGg7VisrKXtjb25zdHtsaXN0ZW5lcjpKfT1qW1ZdO2lmKEo9PT13KXt0aGlzW0ldW0FdLnNwbGljZShWLDEpO2JyZWFrfX19cmV0dXJuIHRoaXN9dHJhbnNpdGlvbihBLHc9ImxpbmVhciIpe2NvbnN0IEI9dGhpcyxEPVN5bWJvbCgiYW5pbWF0aW9uIik7dz13fHwibGluZWFyIjtsZXQgST0wO3JldHVybiB0eXBlb2YgQT09Im9iamVjdCImJihJPUEuZGVsYXl8fDAsQT1BLmR1cmF0aW9uKSx7W0RdOm51bGwsY2FuY2VsKGo9ITEpe2NvbnN0IFY9dGhpc1tEXTtWJiZWLmNhbmNlbChqKX0sZW5kKCl7Y29uc3Qgaj10aGlzW0RdO2omJihqLnBsYXlTdGF0ZT09PSJydW5uaW5nInx8ai5wbGF5U3RhdGU9PT0icGVuZGluZyIpJiZqLmZpbmlzaCgpfSxyZXZlcnNlKCl7Y29uc3Qgaj10aGlzW0RdO2lmKGopaWYoai5wbGF5U3RhdGU9PT0icnVubmluZyJ8fGoucGxheVN0YXRlPT09InBlbmRpbmciKWoucGxheWJhY2tSYXRlPS1qLnBsYXliYWNrUmF0ZTtlbHNle2NvbnN0IFY9ai50aW1pbmcuZGlyZWN0aW9uO2oudGltaW5nLmRpcmVjdGlvbj1WPT09InJldmVyc2UiPyJub3JtYWwiOiJyZXZlcnNlIixqLnBsYXkoKX1yZXR1cm4gai5maW5pc2hlZH0sYXR0cihqLFYpe3JldHVybiB0aGlzLmVuZCgpLHR5cGVvZiBqPT0ic3RyaW5nIiYmKGo9e1tqXTpWfSksT2JqZWN0LmVudHJpZXMoaikuZm9yRWFjaCgoW0osX10pPT57dHlwZW9mIF89PSJmdW5jdGlvbiImJihqW0pdPV8oQi5hdHRyKEopKSl9KSx0aGlzW0RdPUIuYW5pbWF0ZShbal0se2R1cmF0aW9uOkEqMWUzLGRlbGF5OkkqMWUzLGZpbGw6ImZvcndhcmRzIixlYXNpbmc6d30pLHRoaXNbRF0uZmluaXNoZWR9fX11cGRhdGVDb250b3Vycygpe319TyhMLCJBdHRyIixpLmRlZmF1bHQpLGguZGVmYXVsdC5yZWdpc3Rlck5vZGUoTCwibm9kZSIpfSxmdW5jdGlvbihnLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBMfSk7dmFyIG49dCgxKSxpPXQoMTIpLGY9dCg3Mik7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IGg9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlRGVmYXVsdCIpLHU9U3ltYm9sLmZvcigic3ByaXRlanNfZGVjbGFyZUFsaWFzIiksYT1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGUiKSxkPVN5bWJvbC5mb3IoInNwcml0ZWpzX2dldEF0dHJpYnV0ZSIpLEU9U3ltYm9sLmZvcigic3ByaXRlanNfYXR0cmlidXRlcyIpLHA9U3ltYm9sLmZvcigic3ByaXRlanNfY2hhbmdlZEF0dHJzIiksTz1TeW1ib2woInN1YmplY3QiKSxtPVN5bWJvbCgiYXR0ciIpLGI9U3ltYm9sKCJkZWZhdWx0IiksTT1TeW1ib2woImFsaWFzIik7ZnVuY3Rpb24geShOLFtBLHddKXtsZXQgQj1uLm1hdDJkLmZyb21WYWx1ZXMoMSwwLDAsMSwwLDApO3JldHVyblsuLi5OXS5mb3JFYWNoKChbRCxJXSk9PntpZigoQXx8dykmJihCPW4ubWF0MmQudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxCLFtBLHddKSksRD09PSJtYXRyaXgiKUI9bi5tYXQyZC5tdWx0aXBseShCLEIsSSk7ZWxzZSBpZihEPT09Im9mZnNldFRyYW5zbGF0ZSIpQls0XSs9SVswXSxCWzVdKz1JWzFdO2Vsc2UgaWYoRD09PSJvZmZzZXRSb3RhdGUiKUI9bi5tYXQyZC5yb3RhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDApLEIsSSk7ZWxzZSBpZihEPT09InNrZXciKXtjb25zdFtqLFZdPUk7Qj1uLm1hdDJkLm11bHRpcGx5KEIsQixuLm1hdDJkLmZyb21WYWx1ZXMoMSxNYXRoLnRhbihWKSxNYXRoLnRhbihqKSwxLDAsMCkpfWVsc2Ugbi5tYXQyZFtEXShCLEIsSSk7KEF8fHcpJiYoQj1uLm1hdDJkLnRyYW5zbGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCksQixbLUEsLXddKSl9KSxCfWNvbnN0IFM9U3ltYm9sKCJ0cmFuc2Zvcm1NYXRyaXgiKSxzPVN5bWJvbCgidHJhbnNmb3JtcyIpLGM9U3ltYm9sKCJjaGFuZ2VkQXR0cnMiKSxsPVN5bWJvbCgibGFzdENoYW5nZWRBdHRyIiksdj1TeW1ib2woIm9mZnNldEZpZ3VyZSIpO2Z1bmN0aW9uIFQoTixBLHcpe2NvbnN0IEI9TlttXVtBXTtpZihOW2FdKEEsdywhMSl8fE5bbF0hPT1BKXtjb25zdCBJPU5bc107SS5oYXMoQSkmJkkuZGVsZXRlKEEpLHcmJihBPT09InJvdGF0ZSImJih3PU1hdGguUEkqdy8xODApLEE9PT0ic2NhbGUiJiYodz13Lm1hcChqPT5NYXRoLmFicyhqKT4xZS01P2o6MS9qPjA/MWUtNTotMWUtNSkpLEkuc2V0KEEsdykpLE5bU109bnVsbCxOW09dLm9uUHJvcGVydHlDaGFuZ2UoQSx3LEIsTil9fWZ1bmN0aW9uIFIoTil7Y29uc3QgQT1OW3ZdLHc9Ti5vZmZzZXREaXN0YW5jZSpBLmdldFRvdGFsTGVuZ3RoKCksQj1BLmdldFBvaW50QXRMZW5ndGgodyk7aWYoQil7Y29uc3QgRD1OW3NdO2xldCBJPU4ub2Zmc2V0Um90YXRlO0k9PT0iYXV0byI/ST1CLmFuZ2xlOkk9PT0icmV2ZXJzZSI/ST1NYXRoLlBJK0IuYW5nbGU6ST1NYXRoLlBJKkkvMTgwLEQuc2V0KCJvZmZzZXRSb3RhdGUiLEkpLEQuc2V0KCJvZmZzZXRUcmFuc2xhdGUiLFtCLngsQi55XSksTltTXT1udWxsfX1jbGFzcyBMe3N0YXRpYyBzZXREZWZhdWx0KEEsLi4udyl7cmV0dXJuIEFbaF0oLi4udyl9c3RhdGljIGRlY2xhcmVBbGlhcyhBLC4uLncpe3JldHVybiBBW3VdKC4uLncpfXN0YXRpYyBzZXRBdHRyaWJ1dGUoQSwuLi53KXtyZXR1cm4gQVthXSguLi53KX1zdGF0aWMgZ2V0QXR0cmlidXRlKEEsLi4udyl7cmV0dXJuIEFbZF0oLi4udyl9c3RhdGljIGdldEF0dHJpYnV0ZXMoQSl7cmV0dXJuIEFbRV19c3RhdGljIGdldENoYW5nZWRBdHRyaWJ1dGVzKEEpe3JldHVybiBBW3BdfWNvbnN0cnVjdG9yKEEpe3RoaXNbT109QSx0aGlzW21dPXt9LHRoaXNbU109bi5tYXQyZC5mcm9tVmFsdWVzKDEsMCwwLDEsMCwwKSx0aGlzW3NdPW5ldyBNYXAsdGhpc1tiXT17fSx0aGlzW01dPVtdLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBLCJ0cmFuc2Zvcm1NYXRyaXgiLHtnZXQ6KCk9Pih0aGlzW1NdfHwodGhpc1tTXT15KHRoaXNbc10sdGhpcy50cmFuc2Zvcm1PcmlnaW4pKSxbLi4udGhpc1tTXV0pfSksdGhpc1toXSh7aWQ6IiIsbmFtZToiIixjbGFzc05hbWU6IiIseDowLHk6MCx0cmFuc2Zvcm1PcmlnaW46WzAsMF0sdHJhbnNmb3JtOiIiLHRyYW5zbGF0ZTpbMCwwXSxyb3RhdGU6MCxzY2FsZTpbMSwxXSxza2V3OlswLDBdLG9wYWNpdHk6MSx6SW5kZXg6MCxvZmZzZXRQYXRoOnZvaWQgMCxvZmZzZXREaXN0YW5jZTowLG9mZnNldFJvdGF0ZToiYXV0byIscG9pbnRlckV2ZW50czoidmlzaWJsZSIsZmlsdGVyOiJub25lIixkaXNwbGF5OiIifSksdGhpc1t1XSgiY2xhc3MiLCJwb3MiKSx0aGlzW2NdPW5ldyBTZXQsdGhpc1t2XT1uZXcgaS5GaWd1cmUyRCh7c2NhbGU6NSxzaW1wbGlmeTowfSl9Z2V0W3BdKCl7Y29uc3QgQT17fTtyZXR1cm5bLi4udGhpc1tjXV0uZm9yRWFjaCh3PT57QVt3XT10aGlzW21dW3ddfSksQX1nZXRbRV0oKXtjb25zdCBBPU9iamVjdC5hc3NpZ24oe30sdGhpc1ttXSk7Zm9yKGxldCB3PTA7dzx0aGlzW01dLmxlbmd0aDt3Kyspe2NvbnN0IEI9dGhpc1tNXVt3XTtBW0JdPXRoaXNbQl19cmV0dXJuIEF9W2hdKEEpe09iamVjdC5hc3NpZ24odGhpc1tiXSxBKSxPYmplY3QuYXNzaWduKHRoaXNbbV0sQSl9W3VdKC4uLkEpe3RoaXNbTV0ucHVzaCguLi5BKX1bYV0oQSx3LEI9ITApe2NvbnN0IEQ9dGhpc1ttXVtBXSxJPXRoaXNbT107cmV0dXJuIHc9PW51bGwmJih3PXRoaXNbYl1bQV0pLE9iamVjdChmLmNvbXBhcmVWYWx1ZSkoRCx3KT8hMToodGhpc1ttXVtBXT13LHRoaXNbY10uaGFzKEEpJiZ0aGlzW2NdLmRlbGV0ZShBKSx0aGlzW2NdLmFkZChBKSx0aGlzW2xdPUEsQiYmSS5vblByb3BlcnR5Q2hhbmdlKEEsdyxELHRoaXMpLCEwKX1bZF0oQSl7cmV0dXJuIHRoaXNbbV1bQV19c2V0IGlkKEEpe3RoaXNbYV0oImlkIixBKX1nZXQgaWQoKXtyZXR1cm4gdGhpc1tkXSgiaWQiKX1zZXQgbmFtZShBKXt0aGlzW2FdKCJuYW1lIixBKX1nZXQgbmFtZSgpe3JldHVybiB0aGlzW2RdKCJuYW1lIil9c2V0IGNsYXNzTmFtZShBKXt0aGlzW2FdKCJjbGFzc05hbWUiLEEpfWdldCBjbGFzc05hbWUoKXtyZXR1cm4gdGhpc1tkXSgiY2xhc3NOYW1lIil9c2V0IGNsYXNzKEEpe3RoaXMuY2xhc3NOYW1lPUF9Z2V0IGNsYXNzKCl7cmV0dXJuIHRoaXMuY2xhc3NOYW1lfWdldCB4KCl7cmV0dXJuIHRoaXNbZF0oIngiKX1zZXQgeChBKXt0aGlzW2FdKCJ4IixPYmplY3QoZi50b051bWJlcikoQSkpfWdldCB5KCl7cmV0dXJuIHRoaXNbZF0oInkiKX1zZXQgeShBKXt0aGlzW2FdKCJ5IixPYmplY3QoZi50b051bWJlcikoQSkpfWdldCBwb3MoKXtyZXR1cm5bdGhpcy54LHRoaXMueV19c2V0IHBvcyhBKXtBPU9iamVjdChmLnRvQXJyYXkpKEEpLEFycmF5LmlzQXJyYXkoQSl8fChBPVtBLEFdKSx0aGlzLng9QVswXSx0aGlzLnk9QVsxXX1nZXQgdHJhbnNmb3JtKCl7cmV0dXJuIHRoaXNbZF0oInRyYW5zZm9ybSIpfXNldCB0cmFuc2Zvcm0oQSl7bGV0IHc9bnVsbDtpZihBcnJheS5pc0FycmF5KEEpJiYodz1BLEE9YG1hdHJpeCgke0EubWFwKGYudG9OdW1iZXIpLmpvaW4oKX0pYCksdHlwZW9mIEE9PSJzdHJpbmciKUE9QS5yZXBsYWNlKC9ccyosXHMqL2csIiwiKTtlbHNlIGlmKEEhPW51bGwpdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCB0cmFuc2Zvcm0gdmFsdWUuIik7Y29uc3QgQj10aGlzW21dLnRyYW5zZm9ybTtpZih0aGlzW2FdKCJ0cmFuc2Zvcm0iLEEsITEpKXtjb25zdCBEPXRoaXNbc107aWYoRC5oYXMoIm1hdHJpeCIpJiZELmRlbGV0ZSgibWF0cml4IiksdylELnNldCgibWF0cml4Iix3KTtlbHNlIGlmKEEpe2NvbnN0IEk9QS5tYXRjaCgvKG1hdHJpeHx0cmFuc2xhdGV8cm90YXRlfHNjYWxlfHNrZXcpXChbXigpXStcKS9nKTtpZihJKXtsZXQgaj1uLm1hdDJkLmZyb21WYWx1ZXMoMSwwLDAsMSwwLDApO2ZvcihsZXQgVj0wO1Y8SS5sZW5ndGg7VisrKXtjb25zdCBfPUlbVl0ubWF0Y2goL14obWF0cml4fHRyYW5zbGF0ZXxyb3RhdGV8c2NhbGV8c2tldylcKChbXigpXSspXCkvKTtpZihfKXtsZXRbLHN0LEddPV87c3Q9PT0icm90YXRlIj9HPU1hdGguUEkqcGFyc2VGbG9hdChHKS8xODA6Rz1HLnRyaW0oKS5zcGxpdCgvW1xzLF0rLykubWFwKFk9Pk9iamVjdChmLnRvTnVtYmVyKShZKSksc3Q9PT0ibWF0cml4Ij9qPW4ubWF0MmQubXVsdGlwbHkoaixqLEcpOnN0PT09InNrZXciP2o9bi5tYXQyZC5tdWx0aXBseShqLGosbi5tYXQyZC5mcm9tVmFsdWVzKDEsTWF0aC50YW4oR1sxXSksTWF0aC50YW4oR1swXSksMSwwLDApKTpuLm1hdDJkW3N0XShqLGosRyksRC5zZXQoIm1hdHJpeCIsail9fX1lbHNlIHRocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgdHJhbnNmb3JtIHZhbHVlLiIpfXRoaXNbU109bnVsbCx0aGlzW09dLm9uUHJvcGVydHlDaGFuZ2UoInRyYW5zZm9ybSIsQSxCLHRoaXMpfX1nZXQgdHJhbnNmb3JtT3JpZ2luKCl7cmV0dXJuIHRoaXNbZF0oInRyYW5zZm9ybU9yaWdpbiIpfXNldCB0cmFuc2Zvcm1PcmlnaW4oQSl7QT1PYmplY3QoZi50b0FycmF5KShBLCEwKSxBIT1udWxsJiYhQXJyYXkuaXNBcnJheShBKSYmKEE9W0EsQV0pLHRoaXNbYV0oInRyYW5zZm9ybU9yaWdpbiIsQSkmJih0aGlzW1NdPW51bGwpfWdldCByb3RhdGUoKXtyZXR1cm4gdGhpc1tkXSgicm90YXRlIil9c2V0IHJvdGF0ZShBKXtUKHRoaXMsInJvdGF0ZSIsQSl9Z2V0IHRyYW5zbGF0ZSgpe3JldHVybiB0aGlzW2RdKCJ0cmFuc2xhdGUiKX1zZXQgdHJhbnNsYXRlKEEpe0E9T2JqZWN0KGYudG9BcnJheSkoQSwhMCksQSE9bnVsbCYmIUFycmF5LmlzQXJyYXkoQSkmJihBPVtBLEFdKSxUKHRoaXMsInRyYW5zbGF0ZSIsQSl9Z2V0IHNjYWxlKCl7cmV0dXJuIHRoaXNbZF0oInNjYWxlIil9c2V0IHNjYWxlKEEpe0E9T2JqZWN0KGYudG9BcnJheSkoQSwhMCksQSE9bnVsbCYmIUFycmF5LmlzQXJyYXkoQSkmJihBPVtBLEFdKSxUKHRoaXMsInNjYWxlIixBKX1nZXQgc2tldygpe3JldHVybiB0aGlzW2RdKCJza2V3Iil9c2V0IHNrZXcoQSl7QT1PYmplY3QoZi50b0FycmF5KShBLCEwKSxBIT1udWxsJiYhQXJyYXkuaXNBcnJheShBKSYmKEE9W0EsQV0pLFQodGhpcywic2tldyIsQSl9Z2V0IG9wYWNpdHkoKXtyZXR1cm4gdGhpc1tkXSgib3BhY2l0eSIpfXNldCBvcGFjaXR5KEEpe0EhPW51bGwmJihBPU51bWJlcihBKSksdGhpc1thXSgib3BhY2l0eSIsQSl9Z2V0IHpJbmRleCgpe3JldHVybiB0aGlzW2RdKCJ6SW5kZXgiKX1zZXQgekluZGV4KEEpe0EhPW51bGwmJihBPU51bWJlcihBKSksdGhpc1thXSgiekluZGV4IixBKX1nZXQgb2Zmc2V0UGF0aCgpe3JldHVybiB0aGlzW2RdKCJvZmZzZXRQYXRoIil9c2V0IG9mZnNldFBhdGgoQSl7dGhpc1thXSgib2Zmc2V0UGF0aCIsQSkmJih0aGlzW3ZdLmJlZ2luUGF0aCgpLEEhPW51bGwmJnRoaXNbdl0uYWRkUGF0aChBKSxSKHRoaXMpKX1nZXQgb2Zmc2V0RGlzdGFuY2UoKXtyZXR1cm4gdGhpc1tkXSgib2Zmc2V0RGlzdGFuY2UiKX1zZXQgb2Zmc2V0RGlzdGFuY2UoQSl7dGhpc1thXSgib2Zmc2V0RGlzdGFuY2UiLE9iamVjdChmLnRvTnVtYmVyKShBKSkmJlIodGhpcyl9Z2V0IG9mZnNldFJvdGF0ZSgpe3JldHVybiB0aGlzW2RdKCJvZmZzZXRSb3RhdGUiKX1zZXQgb2Zmc2V0Um90YXRlKEEpe3RoaXNbYV0oIm9mZnNldFJvdGF0ZSIsQSksUih0aGlzKX1nZXQgcG9pbnRlckV2ZW50cygpe3JldHVybiB0aGlzW2RdKCJwb2ludGVyRXZlbnRzIil9c2V0IHBvaW50ZXJFdmVudHMoQSl7aWYoQSE9bnVsbCYmQSE9PSJub25lIiYmQSE9PSJ2aXNpYmxlIiYmQSE9PSJ2aXNpYmxlRmlsbCImJkEhPT0idmlzaWJsZVN0cm9rZSImJkEhPT0iYWxsIil0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIHBvaW50ZXJFdmVudHMgdHlwZS4iKTt0aGlzW2FdKCJwb2ludGVyRXZlbnRzIixBKX1nZXQgZmlsdGVyKCl7cmV0dXJuIHRoaXNbZF0oImZpbHRlciIpfXNldCBmaWx0ZXIoQSl7dGhpc1thXSgiZmlsdGVyIixBKX1nZXQgZGlzcGxheSgpe3JldHVybiB0aGlzW2RdKCJkaXNwbGF5Iil9c2V0IGRpc3BsYXkoQSl7dGhpc1thXSgiZGlzcGxheSIsQSl9c2V0IG9mZnNldChBKXt9fX0sZnVuY3Rpb24oZyxlLHQpe3QucihlKSx0LmQoZSwic2l6ZVRvUGl4ZWwiLGZ1bmN0aW9uKCl7cmV0dXJuIG59KSx0LmQoZSwidG9TdHJpbmciLGZ1bmN0aW9uKCl7cmV0dXJuIGl9KSx0LmQoZSwidG9OdW1iZXIiLGZ1bmN0aW9uKCl7cmV0dXJuIGZ9KSx0LmQoZSwidG9BcnJheSIsZnVuY3Rpb24oKXtyZXR1cm4gaH0pLHQuZChlLCJjb21wYXJlVmFsdWUiLGZ1bmN0aW9uKCl7cmV0dXJuIHV9KSx0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gbihhLGQpe2NvbnN0IEU9YS50cmltKCkubWF0Y2goL14oW1xkLl0rKShweHxwdHxwY3xpbnxjbXxtbXxlbXxleHxyZW18cXx2d3x2aHx2bWF4fHZtaW4pJC8pO0U/YT17c2l6ZTpwYXJzZUZsb2F0KEVbMV0pLHVuaXQ6RVsyXX06YT17c2l6ZTpwYXJzZUZsb2F0KGEpLHVuaXQ6InB4In07bGV0e3NpemU6cCx1bml0Ok99PWE7aWYoTz09PSJwdCIpcC89Ljc1O2Vsc2UgaWYoTz09PSJwYyIpcCo9MTY7ZWxzZSBpZihPPT09ImluIilwKj05NjtlbHNlIGlmKE89PT0iY20iKXAqPTk2LzIuNTQ7ZWxzZSBpZihPPT09Im1tIilwKj05Ni8yNS40O2Vsc2UgaWYoTz09PSJlbSJ8fE89PT0icmVtInx8Tz09PSJleCIpe2lmKCFkJiZ0eXBlb2YgZ2V0Q29tcHV0ZWRTdHlsZT09ImZ1bmN0aW9uIiYmdHlwZW9mIGRvY3VtZW50PCJ1Iil7Y29uc3QgbT1nZXRDb21wdXRlZFN0eWxlKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkuZm9udFNpemU7bT9kPW4obSwxNik6ZD0xNn1wKj1kLE89PT0iZXgiJiYocC89Mil9ZWxzZSBpZihPPT09InEiKXAqPTk2LzI1LjQvNDtlbHNlIGlmKE89PT0idncifHxPPT09InZoIil7aWYodHlwZW9mIGRvY3VtZW50PCJ1Iil7Y29uc3QgbT1PPT09InZ3Ij93aW5kb3cuaW5uZXJXaWR0aHx8ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoOndpbmRvdy5pbm5lckhlaWdodHx8ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodDtwKj1tLzEwMH19ZWxzZSBpZigoTz09PSJ2bWF4Inx8Tz09PSJ2bWluIikmJnR5cGVvZiBkb2N1bWVudDwidSIpe2NvbnN0IG09d2luZG93LmlubmVyV2lkdGh8fGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCxiPXdpbmRvdy5pbm5lckhlaWdodHx8ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodDtPPT09InZtYXgiP3AqPU1hdGgubWF4KG0sYikvMTAwOnAqPU1hdGgubWluKG0sYikvMTAwfXJldHVybiBwfWZ1bmN0aW9uIGkoYSl7cmV0dXJuIGE9PW51bGw/YTpTdHJpbmcoYSl9ZnVuY3Rpb24gZihhKXtpZihhPT1udWxsKXJldHVybiBhO2lmKHR5cGVvZiBhPT0ic3RyaW5nIiYmKGE9bihhKSksIU51bWJlci5pc0Zpbml0ZShhKSl0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIHZhbHVlIik7cmV0dXJuIGF9ZnVuY3Rpb24gaChhLGQ9ITEpe3JldHVybiBhPT09IiI/bnVsbDoodHlwZW9mIGE9PSJzdHJpbmciJiYoYT1hLnNwbGl0KC9bXHMsXSsvZykpLEFycmF5LmlzQXJyYXkoYSkmJihkJiYoYT1hLm1hcChmKSksYS5sZW5ndGg9PT0xKT9hWzBdOmEpfWZ1bmN0aW9uIHUoYSxkKXtpZihBcnJheS5pc0FycmF5KGEpJiZBcnJheS5pc0FycmF5KGQpKXtpZihhLmxlbmd0aCE9PWQubGVuZ3RoKXJldHVybiExO2ZvcihsZXQgRT0wO0U8YS5sZW5ndGg7RSsrKWlmKGFbRV0hPT1kW0VdKXJldHVybiExO3JldHVybiEwfXJldHVybiBhPT1udWxsJiZkPT1udWxsfHxhPT09ZH19LGZ1bmN0aW9uKGcsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIE99KTt2YXIgbj10KDc0KSxpPXQoMzIpLGY9dC5uKGkpLGg9dCg2OCksdT10KDcyKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gYSgpe3JldHVybiBhPU9iamVjdC5hc3NpZ258fGZ1bmN0aW9uKG0pe2Zvcih2YXIgYj0xO2I8YXJndW1lbnRzLmxlbmd0aDtiKyspe3ZhciBNPWFyZ3VtZW50c1tiXTtmb3IodmFyIHkgaW4gTSlPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoTSx5KSYmKG1beV09TVt5XSl9cmV0dXJuIG19LGEuYXBwbHkodGhpcyxhcmd1bWVudHMpfWZ1bmN0aW9uIGQobSl7aWYodHlwZW9mIG09PSJzdHJpbmciKXtpZihtPW0udHJpbSgpLC9eWzAtOS5dKyUkLy50ZXN0KG0pKXJldHVybiBwYXJzZUZsb2F0KG0pLzEwMDtpZigvXihbXGQuXSspKHB4fHB0fHBjfGlufGNtfG1tfGVtfGV4fHJlbXxxfHZ3fHZofHZtYXh8dm1pbikkLy50ZXN0KG0pKXJldHVybiBPYmplY3QodS5zaXplVG9QaXhlbCkobSl9cmV0dXJuIG19ZnVuY3Rpb24gRShtLGIsTSx5LFMpe3JldHVybiB0eXBlb2YgbT09InN0cmluZyImJihtPWYoKShtKSksdHlwZW9mIGI9PSJzdHJpbmciJiYoYj1mKCkoYikpLG4uRWZmZWN0cy5kZWZhdWx0KG0sYixNLHksUyl9ZnVuY3Rpb24gcChtLGIsTSx5LFMpe3JldHVybiBuLkVmZmVjdHMuZGVmYXVsdChtLGIsTSx5LFMpfW4uRWZmZWN0cy5kZWZhdWx0PWZ1bmN0aW9uKG0sYixNLHksUyl7cmV0dXJuIEFycmF5LmlzQXJyYXkobSkmJkFycmF5LmlzQXJyYXkoYik/bS5tYXAoKHMsYyk9PnMrKE0teSkvKFMteSkqKGJbY10tcykpOnR5cGVvZiBtPT0ibnVtYmVyIiYmdHlwZW9mIGI9PSJudW1iZXIiP20rKE0teSkvKFMteSkqKGItbSk6TS15PlMtTT9iOm19LG4uRWZmZWN0cy5maWxsQ29sb3I9RSxuLkVmZmVjdHMuc3Ryb2tlQ29sb3I9RSxuLkVmZmVjdHMuYmdjb2xvcj1FLG4uRWZmZWN0cy5ib3JkZXJDb2xvcj1FLG4uRWZmZWN0cy50ZXh0PXA7Y2xhc3MgTyBleHRlbmRzIG4uQW5pbWF0b3J7Y29uc3RydWN0b3IoYixNLHkpe2NvbnN0IFM9Yi5hdHRyKCk7T2JqZWN0LmVudHJpZXMoUykuZm9yRWFjaCgoW3MsY10pPT57U1tzXT1uLkVmZmVjdHNbc10/YzpkKGMpfSksTT1NLm1hcChzPT57bGV0IGM9YSh7fSxzKTtjb25zdCBsPXt9O3JldHVybiBPYmplY3QuZW50cmllcyhjKS5mb3JFYWNoKChbdixUXSk9PntsW3ZdPW4uRWZmZWN0c1t2XT9UOmQoVCl9KSxsfSksc3VwZXIoUyxNLHkpLHRoaXMudGFyZ2V0PWIsdGhpcy5zZXR0ZXI9ZnVuY3Rpb24ocyxjKXtjLmF0dHIocyl9fWdldCBwbGF5U3RhdGUoKXtyZXR1cm4gdGhpcy50YXJnZXQucGFyZW50P3N1cGVyLnBsYXlTdGF0ZToiaWRsZSJ9Z2V0IGZpbmlzaGVkKCl7cmV0dXJuIHN1cGVyLmZpbmlzaGVkLnRoZW4oKCk9Pntjb25zdCBiPXRoaXM7cmV0dXJuIG5ldyBQcm9taXNlKE09PntmdW5jdGlvbiB5KCl7Yi5zZXR0ZXIoYi5mcmFtZSxiLnRhcmdldCk7Y29uc3QgUz1iLnBsYXlTdGF0ZTtTPT09ImZpbmlzaGVkInx8Uz09PSJpZGxlIj8oT2JqZWN0KGguY2FuY2VsQW5pbWF0aW9uRnJhbWUpKGIucmVxdWVzdElkKSxNKCkpOk9iamVjdChoLnJlcXVlc3RBbmltYXRpb25GcmFtZSkoeSl9eSgpfSl9KX1maW5pc2goKXtzdXBlci5maW5pc2goKSxPYmplY3QoaC5jYW5jZWxBbmltYXRpb25GcmFtZSkodGhpcy5yZXF1ZXN0SWQpLHRoaXMuc2V0dGVyKHRoaXMuZnJhbWUsdGhpcy50YXJnZXQpfXBsYXkoKXtpZighdGhpcy50YXJnZXQucGFyZW50fHx0aGlzLnBsYXlTdGF0ZT09PSJydW5uaW5nIilyZXR1cm47c3VwZXIucGxheSgpLHRoaXMuc2V0dGVyKHRoaXMuZnJhbWUsdGhpcy50YXJnZXQpO2NvbnN0IGI9dGhpczt0aGlzLnJlYWR5LnRoZW4oKCk9PntiLnNldHRlcihiLmZyYW1lLGIudGFyZ2V0KSxiLnJlcXVlc3RJZD1PYmplY3QoaC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpKGZ1bmN0aW9uIE0oKXtjb25zdCB5PWIudGFyZ2V0O2lmKHR5cGVvZiBkb2N1bWVudDwidSImJmRvY3VtZW50LmRvY3VtZW50RWxlbWVudCYmZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNvbnRhaW5zJiZ5LmxheWVyJiZ5LmxheWVyLmNhbnZhcyYmIWRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jb250YWlucyh5LmxheWVyLmNhbnZhcykpe2IuY2FuY2VsKCk7cmV0dXJufWNvbnN0IFM9Yi5wbGF5U3RhdGU7Yi5zZXR0ZXIoYi5mcmFtZSxiLnRhcmdldCksUyE9PSJpZGxlIiYmKFM9PT0icnVubmluZyI/Yi5yZXF1ZXN0SWQ9T2JqZWN0KGgucmVxdWVzdEFuaW1hdGlvbkZyYW1lKShNKTooUz09PSJwYXVzZWQifHxTPT09InBlbmRpbmciJiZiLnRpbWVsaW5lLmN1cnJlbnRUaW1lPDApJiZiLnJlYWR5LnRoZW4oKCk9PntiLnNldHRlcihiLmZyYW1lLGIudGFyZ2V0KSxiLnJlcXVlc3RJZD1PYmplY3QoaC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpKE0pfSkpfSl9KX1jYW5jZWwoYj0hMSl7T2JqZWN0KGguY2FuY2VsQW5pbWF0aW9uRnJhbWUpKHRoaXMucmVxdWVzdElkKSxiPyh0aGlzLnNldHRlcih0aGlzLmZyYW1lLHRoaXMudGFyZ2V0KSxzdXBlci5jYW5jZWwoKSk6KHN1cGVyLmNhbmNlbCgpLHRoaXMuc2V0dGVyKHRoaXMuZnJhbWUsdGhpcy50YXJnZXQpKX19fSxmdW5jdGlvbihnLGUsdCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLGUuVGltZWxpbmU9ZS5FZmZlY3RzPWUuRWFzaW5ncz1lLkFuaW1hdG9yPXZvaWQgMDt2YXIgbj10KDc1KSxpPUUobiksZj10KDE4NyksaD1FKGYpLHU9dCgxODgpLGE9dCgxOTApLGQ9RShhKTtmdW5jdGlvbiBFKHApe3JldHVybiBwJiZwLl9fZXNNb2R1bGU/cDp7ZGVmYXVsdDpwfX1lLkFuaW1hdG9yPWQuZGVmYXVsdCxlLkVhc2luZ3M9dS5FYXNpbmdzLGUuRWZmZWN0cz1oLmRlZmF1bHQsZS5UaW1lbGluZT1pLmRlZmF1bHR9LGZ1bmN0aW9uKGcsZSx0KXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSk7dmFyIG49dCg3NiksaT1zKG4pLGY9dCgxMzMpLGg9cyhmKSx1PXQoMTQxKSxhPXModSksZD10KDE2NCksRT1zKGQpLHA9dCgxNzApLE89cyhwKSxtPXQoMTcxKSxiPXMobSksTT10KDE3NSkseT1zKE0pLFM9dCgxODYpO2Z1bmN0aW9uIHMoQil7cmV0dXJuIEImJkIuX19lc01vZHVsZT9COntkZWZhdWx0OkJ9fXZhciBjPSgwLFMuY3JlYXRlTm93VGltZSkoKSxsPXtvcmlnaW5UaW1lOjAscGxheWJhY2tSYXRlOjF9LHY9KDAseS5kZWZhdWx0KSgidGltZU1hcmsiKSxUPSgwLHkuZGVmYXVsdCkoInBsYXliYWNrUmF0ZSIpLFI9KDAseS5kZWZhdWx0KSgidGltZXJzIiksTD0oMCx5LmRlZmF1bHQpKCJvcmlnaW5UaW1lIiksTj0oMCx5LmRlZmF1bHQpKCJzZXRUaW1lciIpLEE9KDAseS5kZWZhdWx0KSgicGFyZW50Iiksdz1mdW5jdGlvbigpe2Z1bmN0aW9uIEIoRCxJKXsoMCxPLmRlZmF1bHQpKHRoaXMsQiksRCBpbnN0YW5jZW9mIEImJihJPUQsRD17fSksRD0oMCxFLmRlZmF1bHQpKHt9LGwsRCksSSYmKHRoaXNbQV09SSk7dmFyIGo9RC5ub3d0aW1lfHxjO2lmKEkpT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImdsb2JhbFRpbWUiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gSS5jdXJyZW50VGltZX19KTtlbHNle3ZhciBWPWooKTtPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiZ2xvYmFsVGltZSIse2dldDpmdW5jdGlvbigpe3JldHVybiBqKCktVn19KX10aGlzW3ZdPVt7Z2xvYmFsVGltZTp0aGlzLmdsb2JhbFRpbWUsbG9jYWxUaW1lOi1ELm9yaWdpblRpbWUsZW50cm9weTotRC5vcmlnaW5UaW1lLHBsYXliYWNrUmF0ZTpELnBsYXliYWNrUmF0ZSxnbG9iYWxFbnRyb3B5OjB9XSx0aGlzW0FdJiYodGhpc1t2XVswXS5nbG9iYWxFbnRyb3B5PXRoaXNbQV0uZW50cm9weSksdGhpc1tMXT1ELm9yaWdpblRpbWUsdGhpc1tUXT1ELnBsYXliYWNrUmF0ZSx0aGlzW1JdPW5ldyBhLmRlZmF1bHR9cmV0dXJuKDAsYi5kZWZhdWx0KShCLFt7a2V5OiJtYXJrVGltZSIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgST1hcmd1bWVudHMubGVuZ3RoPjAmJmFyZ3VtZW50c1swXSE9PXZvaWQgMD9hcmd1bWVudHNbMF06e30saj1JLnRpbWUsVj1qPT09dm9pZCAwP3RoaXMuY3VycmVudFRpbWU6aixKPUkuZW50cm9weSxfPUo9PT12b2lkIDA/dGhpcy5lbnRyb3B5Okosc3Q9SS5wbGF5YmFja1JhdGUsRz1zdD09PXZvaWQgMD90aGlzLnBsYXliYWNrUmF0ZTpzdCxZPXtnbG9iYWxUaW1lOnRoaXMuZ2xvYmFsVGltZSxsb2NhbFRpbWU6VixlbnRyb3B5Ol8scGxheWJhY2tSYXRlOkcsZ2xvYmFsRW50cm9weTp0aGlzLmdsb2JhbEVudHJvcHl9O3RoaXNbdl0ucHVzaChZKX19LHtrZXk6ImZvcmsiLHZhbHVlOmZ1bmN0aW9uKEkpe3JldHVybiBuZXcgQihJLHRoaXMpfX0se2tleToic2Vla0dsb2JhbFRpbWUiLHZhbHVlOmZ1bmN0aW9uKEkpe3ZhciBqPXRoaXMuc2Vla1RpbWVNYXJrKEkpLFY9dGhpc1t2XVtqXSxKPVYuZW50cm9weSxfPVYucGxheWJhY2tSYXRlLHN0PVYuZ2xvYmFsVGltZTtyZXR1cm4gc3QrKEktSikvTWF0aC5hYnMoXyl9fSx7a2V5OiJzZWVrTG9jYWxUaW1lIix2YWx1ZTpmdW5jdGlvbihJKXt2YXIgaj10aGlzLnNlZWtUaW1lTWFyayhJKSxWPXRoaXNbdl1bal0sSj1WLmxvY2FsVGltZSxfPVYuZW50cm9weSxzdD1WLnBsYXliYWNrUmF0ZTtyZXR1cm4gc3Q+MD9KKyhJLV8pOkotKEktXyl9fSx7a2V5OiJzZWVrVGltZU1hcmsiLHZhbHVlOmZ1bmN0aW9uKEkpe3ZhciBqPXRoaXNbdl0sVj0wLEo9ai5sZW5ndGgtMTtpZihJPD1qW1ZdLmVudHJvcHkpcmV0dXJuIFY7aWYoST49altKXS5lbnRyb3B5KXJldHVybiBKO2Zvcih2YXIgXz1NYXRoLmZsb29yKChWK0opLzIpO18+ViYmXzxKOyl7aWYoST09PWpbX10uZW50cm9weSlyZXR1cm4gXztJPGpbX10uZW50cm9weT9KPV86ST5qW19dLmVudHJvcHkmJihWPV8pLF89TWF0aC5mbG9vcigoVitKKS8yKX1yZXR1cm4gVn19LHtrZXk6InVwZGF0ZVRpbWVycyIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgST10aGlzLGo9W10uY29uY2F0KCgwLGguZGVmYXVsdCkodGhpc1tSXSkpO2ouZm9yRWFjaChmdW5jdGlvbihWKXt2YXIgSj0oMCxpLmRlZmF1bHQpKFYsMiksXz1KWzBdLHN0PUpbMV07SVtOXShzdC5oYW5kbGVyLHN0LnRpbWUsXyl9KX19LHtrZXk6ImNsZWFyVGltZW91dCIsdmFsdWU6ZnVuY3Rpb24oRCl7ZnVuY3Rpb24gSShqKXtyZXR1cm4gRC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9cmV0dXJuIEkudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gRC50b1N0cmluZygpfSxJfShmdW5jdGlvbihEKXt2YXIgST10aGlzW1JdLmdldChEKTtJJiZJLnRpbWVySUQhPW51bGwmJih0aGlzW0FdP3RoaXNbQV0uY2xlYXJUaW1lb3V0KEkudGltZXJJRCk6Y2xlYXJUaW1lb3V0KEkudGltZXJJRCkpLHRoaXNbUl0uZGVsZXRlKEQpfSl9LHtrZXk6ImNsZWFySW50ZXJ2YWwiLHZhbHVlOmZ1bmN0aW9uKEkpe3JldHVybiB0aGlzLmNsZWFyVGltZW91dChJKX19LHtrZXk6ImNsZWFyIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBJPXRoaXMsaj10aGlzW1JdO1tdLmNvbmNhdCgoMCxoLmRlZmF1bHQpKGoua2V5cygpKSkuZm9yRWFjaChmdW5jdGlvbihWKXtJLmNsZWFyVGltZW91dChWKX0pfX0se2tleToic2V0VGltZW91dCIsdmFsdWU6ZnVuY3Rpb24oSSl7dmFyIGo9YXJndW1lbnRzLmxlbmd0aD4xJiZhcmd1bWVudHNbMV0hPT12b2lkIDA/YXJndW1lbnRzWzFdOntkZWxheTowfTtyZXR1cm4gdGhpc1tOXShJLGopfX0se2tleToic2V0SW50ZXJ2YWwiLHZhbHVlOmZ1bmN0aW9uKEkpe3ZhciBqPWFyZ3VtZW50cy5sZW5ndGg+MSYmYXJndW1lbnRzWzFdIT09dm9pZCAwP2FyZ3VtZW50c1sxXTp7ZGVsYXk6MH0sVj10aGlzLEo9dGhpc1tOXShmdW5jdGlvbiBfKCl7VltOXShfLGosSiksSSgpfSxqKTtyZXR1cm4gSn19LHtrZXk6Tix2YWx1ZTpmdW5jdGlvbihJLGope3ZhciBWPXRoaXMsSj1hcmd1bWVudHMubGVuZ3RoPjImJmFyZ3VtZW50c1syXSE9PXZvaWQgMD9hcmd1bWVudHNbMl06KDAseS5kZWZhdWx0KSgidGltZXJJRCIpO2o9KDAsUy5mb3JtYXREZWxheSkoaik7dmFyIF89dGhpc1tSXS5nZXQoSiksc3Q9dm9pZCAwLEc9bnVsbCxZPXZvaWQgMCxydD12b2lkIDA7Xz8odGhpcy5jbGVhclRpbWVvdXQoSiksai5pc0VudHJvcHk/c3Q9KGouZGVsYXktKHRoaXMuZW50cm9weS1fLnN0YXJ0RW50cm9weSkpL01hdGguYWJzKHRoaXMucGxheWJhY2tSYXRlKTpzdD0oai5kZWxheS0odGhpcy5jdXJyZW50VGltZS1fLnN0YXJ0VGltZSkpL3RoaXMucGxheWJhY2tSYXRlLFk9Xy5zdGFydFRpbWUscnQ9Xy5zdGFydEVudHJvcHkpOihzdD1qLmRlbGF5LyhqLmlzRW50cm9weT9NYXRoLmFicyh0aGlzLnBsYXliYWNrUmF0ZSk6dGhpcy5wbGF5YmFja1JhdGUpLFk9dGhpcy5jdXJyZW50VGltZSxydD10aGlzLmVudHJvcHkpO3ZhciBvdD10aGlzW0FdLGF0PW90P290LnNldFRpbWVvdXQuYmluZChvdCk6c2V0VGltZW91dCxodD1qLmhlYWRpbmc7cmV0dXJuIW90JiZodD09PSExJiZzdDwwJiYoc3Q9MS8wKSwoaXNGaW5pdGUoc3QpfHxvdCkmJihzdD1NYXRoLmNlaWwoc3QpLGF0IT09c2V0VGltZW91dCYmKHN0PXtkZWxheTpzdCxoZWFkaW5nOmh0fSksRz1hdChmdW5jdGlvbigpe1ZbUl0uZGVsZXRlKEopLEkoKX0sc3QpKSx0aGlzW1JdLnNldChKLHt0aW1lcklEOkcsaGFuZGxlcjpJLHRpbWU6aixzdGFydFRpbWU6WSxzdGFydEVudHJvcHk6cnR9KSxKfX0se2tleToicGFyZW50IixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc1tBXX19LHtrZXk6Imxhc3RUaW1lTWFyayIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXNbdl1bdGhpc1t2XS5sZW5ndGgtMV19fSx7a2V5OiJjdXJyZW50VGltZSIsZ2V0OmZ1bmN0aW9uKCl7dmFyIEk9dGhpcy5sYXN0VGltZU1hcmssaj1JLmxvY2FsVGltZSxWPUkuZ2xvYmFsVGltZTtyZXR1cm4gaisodGhpcy5nbG9iYWxUaW1lLVYpKnRoaXMucGxheWJhY2tSYXRlfSxzZXQ6ZnVuY3Rpb24oSSl7dmFyIGo9dGhpcyxWPXRoaXMuY3VycmVudFRpbWUsSj1JLF89dGhpc1tSXTt0aGlzLm1hcmtUaW1lKHt0aW1lOkl9KSxbXS5jb25jYXQoKDAsaC5kZWZhdWx0KShfKSkuZm9yRWFjaChmdW5jdGlvbihzdCl7dmFyIEc9KDAsaS5kZWZhdWx0KShzdCwyKSxZPUdbMF0scnQ9R1sxXTtpZihfLmhhcyhZKSl7dmFyIG90PXJ0LnRpbWUsYXQ9b3QuaXNFbnRyb3B5LGh0PW90LmRlbGF5LGl0PW90LmhlYWRpbmcsTXQ9cnQuaGFuZGxlcixPdD1ydC5zdGFydFRpbWU7aWYoYXQpaHQ9PT0wJiYoTXQoKSxqLmNsZWFyVGltZW91dChZKSk7ZWxzZXt2YXIgVT1PdCtodDsoaHQ9PT0wfHxpdCE9PSExJiYoSi1WKSpodDw9MHx8Vjw9VSYmVTw9Snx8Vj49VSYmVT49SikmJihNdCgpLGouY2xlYXJUaW1lb3V0KFkpKX19fSksdGhpcy51cGRhdGVUaW1lcnMoKX19LHtrZXk6ImVudHJvcHkiLGdldDpmdW5jdGlvbigpe3ZhciBJPXRoaXMubGFzdFRpbWVNYXJrLGo9SS5lbnRyb3B5LFY9SS5nbG9iYWxFbnRyb3B5O3JldHVybiBqK01hdGguYWJzKCh0aGlzLmdsb2JhbEVudHJvcHktVikqdGhpcy5wbGF5YmFja1JhdGUpfSxzZXQ6ZnVuY3Rpb24oSSl7aWYodGhpcy5lbnRyb3B5Pkkpe3ZhciBqPXRoaXMuc2Vla1RpbWVNYXJrKEkpO3RoaXNbdl0ubGVuZ3RoPWorMX10aGlzLm1hcmtUaW1lKHtlbnRyb3B5Okl9KSx0aGlzLnVwZGF0ZVRpbWVycygpfX0se2tleToiZ2xvYmFsRW50cm9weSIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXNbQV0/dGhpc1tBXS5lbnRyb3B5OnRoaXMuZ2xvYmFsVGltZX19LHtrZXk6InBsYXliYWNrUmF0ZSIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXNbVF19LHNldDpmdW5jdGlvbihJKXtJIT09dGhpcy5wbGF5YmFja1JhdGUmJih0aGlzLm1hcmtUaW1lKHtwbGF5YmFja1JhdGU6SX0pLHRoaXNbVF09SSx0aGlzLnVwZGF0ZVRpbWVycygpKX19LHtrZXk6InBhdXNlZCIsZ2V0OmZ1bmN0aW9uKCl7aWYodGhpcy5wbGF5YmFja1JhdGU9PT0wKXJldHVybiEwO2Zvcih2YXIgST10aGlzLnBhcmVudDtJOyl7aWYoSS5wbGF5YmFja1JhdGU9PT0wKXJldHVybiEwO0k9SS5wYXJlbnR9cmV0dXJuITF9fV0pLEJ9KCk7ZS5kZWZhdWx0PXd9LGZ1bmN0aW9uKGcsZSx0KXtlLl9fZXNNb2R1bGU9ITA7dmFyIG49dCg3NyksaT11KG4pLGY9dCgxMjkpLGg9dShmKTtmdW5jdGlvbiB1KGEpe3JldHVybiBhJiZhLl9fZXNNb2R1bGU/YTp7ZGVmYXVsdDphfX1lLmRlZmF1bHQ9ZnVuY3Rpb24oKXtmdW5jdGlvbiBhKGQsRSl7dmFyIHA9W10sTz0hMCxtPSExLGI9dm9pZCAwO3RyeXtmb3IodmFyIE09KDAsaC5kZWZhdWx0KShkKSx5OyEoTz0oeT1NLm5leHQoKSkuZG9uZSkmJihwLnB1c2goeS52YWx1ZSksIShFJiZwLmxlbmd0aD09PUUpKTtPPSEwKTt9Y2F0Y2goUyl7bT0hMCxiPVN9ZmluYWxseXt0cnl7IU8mJk0ucmV0dXJuJiZNLnJldHVybigpfWZpbmFsbHl7aWYobSl0aHJvdyBifX1yZXR1cm4gcH1yZXR1cm4gZnVuY3Rpb24oZCxFKXtpZihBcnJheS5pc0FycmF5KGQpKXJldHVybiBkO2lmKCgwLGkuZGVmYXVsdCkoT2JqZWN0KGQpKSlyZXR1cm4gYShkLEUpO3Rocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UiKX19KCl9LGZ1bmN0aW9uKGcsZSx0KXtnLmV4cG9ydHM9e2RlZmF1bHQ6dCg3OCksX19lc01vZHVsZTohMH19LGZ1bmN0aW9uKGcsZSx0KXt0KDc5KSx0KDEyNSksZy5leHBvcnRzPXQoMTI3KX0sZnVuY3Rpb24oZyxlLHQpe3QoODApO2Zvcih2YXIgbj10KDkxKSxpPXQoOTUpLGY9dCg4MyksaD10KDEyMikoInRvU3RyaW5nVGFnIiksdT0iQ1NTUnVsZUxpc3QsQ1NTU3R5bGVEZWNsYXJhdGlvbixDU1NWYWx1ZUxpc3QsQ2xpZW50UmVjdExpc3QsRE9NUmVjdExpc3QsRE9NU3RyaW5nTGlzdCxET01Ub2tlbkxpc3QsRGF0YVRyYW5zZmVySXRlbUxpc3QsRmlsZUxpc3QsSFRNTEFsbENvbGxlY3Rpb24sSFRNTENvbGxlY3Rpb24sSFRNTEZvcm1FbGVtZW50LEhUTUxTZWxlY3RFbGVtZW50LE1lZGlhTGlzdCxNaW1lVHlwZUFycmF5LE5hbWVkTm9kZU1hcCxOb2RlTGlzdCxQYWludFJlcXVlc3RMaXN0LFBsdWdpbixQbHVnaW5BcnJheSxTVkdMZW5ndGhMaXN0LFNWR051bWJlckxpc3QsU1ZHUGF0aFNlZ0xpc3QsU1ZHUG9pbnRMaXN0LFNWR1N0cmluZ0xpc3QsU1ZHVHJhbnNmb3JtTGlzdCxTb3VyY2VCdWZmZXJMaXN0LFN0eWxlU2hlZXRMaXN0LFRleHRUcmFja0N1ZUxpc3QsVGV4dFRyYWNrTGlzdCxUb3VjaExpc3QiLnNwbGl0KCIsIiksYT0wO2E8dS5sZW5ndGg7YSsrKXt2YXIgZD11W2FdLEU9bltkXSxwPUUmJkUucHJvdG90eXBlO3AmJiFwW2hdJiZpKHAsaCxkKSxmW2RdPWYuQXJyYXl9fSxmdW5jdGlvbihnLGUsdCl7dmFyIG49dCg4MSksaT10KDgyKSxmPXQoODMpLGg9dCg4NCk7Zy5leHBvcnRzPXQoODgpKEFycmF5LCJBcnJheSIsZnVuY3Rpb24odSxhKXt0aGlzLl90PWgodSksdGhpcy5faT0wLHRoaXMuX2s9YX0sZnVuY3Rpb24oKXt2YXIgdT10aGlzLl90LGE9dGhpcy5fayxkPXRoaXMuX2krKztyZXR1cm4hdXx8ZD49dS5sZW5ndGg/KHRoaXMuX3Q9dm9pZCAwLGkoMSkpOmE9PSJrZXlzIj9pKDAsZCk6YT09InZhbHVlcyI/aSgwLHVbZF0pOmkoMCxbZCx1W2RdXSl9LCJ2YWx1ZXMiKSxmLkFyZ3VtZW50cz1mLkFycmF5LG4oImtleXMiKSxuKCJ2YWx1ZXMiKSxuKCJlbnRyaWVzIil9LGZ1bmN0aW9uKGcsZSl7Zy5leHBvcnRzPWZ1bmN0aW9uKCl7fX0sZnVuY3Rpb24oZyxlKXtnLmV4cG9ydHM9ZnVuY3Rpb24odCxuKXtyZXR1cm57dmFsdWU6bixkb25lOiEhdH19fSxmdW5jdGlvbihnLGUpe2cuZXhwb3J0cz17fX0sZnVuY3Rpb24oZyxlLHQpe3ZhciBuPXQoODUpLGk9dCg4Nyk7Zy5leHBvcnRzPWZ1bmN0aW9uKGYpe3JldHVybiBuKGkoZikpfX0sZnVuY3Rpb24oZyxlLHQpe3ZhciBuPXQoODYpO2cuZXhwb3J0cz1PYmplY3QoInoiKS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgwKT9PYmplY3Q6ZnVuY3Rpb24oaSl7cmV0dXJuIG4oaSk9PSJTdHJpbmciP2kuc3BsaXQoIiIpOk9iamVjdChpKX19LGZ1bmN0aW9uKGcsZSl7dmFyIHQ9e30udG9TdHJpbmc7Zy5leHBvcnRzPWZ1bmN0aW9uKG4pe3JldHVybiB0LmNhbGwobikuc2xpY2UoOCwtMSl9fSxmdW5jdGlvbihnLGUpe2cuZXhwb3J0cz1mdW5jdGlvbih0KXtpZih0PT1udWxsKXRocm93IFR5cGVFcnJvcigiQ2FuJ3QgY2FsbCBtZXRob2Qgb24gICIrdCk7cmV0dXJuIHR9fSxmdW5jdGlvbihnLGUsdCl7dmFyIG49dCg4OSksaT10KDkwKSxmPXQoMTA2KSxoPXQoOTUpLHU9dCg4MyksYT10KDEwNyksZD10KDEyMSksRT10KDEyMykscD10KDEyMikoIml0ZXJhdG9yIiksTz0hKFtdLmtleXMmJiJuZXh0ImluW10ua2V5cygpKSxtPSJAQGl0ZXJhdG9yIixiPSJrZXlzIixNPSJ2YWx1ZXMiLHk9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc307Zy5leHBvcnRzPWZ1bmN0aW9uKFMscyxjLGwsdixULFIpe2EoYyxzLGwpO3ZhciBMPWZ1bmN0aW9uKEcpe2lmKCFPJiZHIGluIEIpcmV0dXJuIEJbR107c3dpdGNoKEcpe2Nhc2UgYjpyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gbmV3IGModGhpcyxHKX07Y2FzZSBNOnJldHVybiBmdW5jdGlvbigpe3JldHVybiBuZXcgYyh0aGlzLEcpfX1yZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gbmV3IGModGhpcyxHKX19LE49cysiIEl0ZXJhdG9yIixBPXY9PU0sdz0hMSxCPVMucHJvdG90eXBlLEQ9QltwXXx8QlttXXx8diYmQlt2XSxJPUR8fEwodiksaj12P0E/TCgiZW50cmllcyIpOkk6dm9pZCAwLFY9cz09IkFycmF5IiYmQi5lbnRyaWVzfHxELEosXyxzdDtpZihWJiYoc3Q9RShWLmNhbGwobmV3IFMpKSxzdCE9PU9iamVjdC5wcm90b3R5cGUmJnN0Lm5leHQmJihkKHN0LE4sITApLCFuJiZ0eXBlb2Ygc3RbcF0hPSJmdW5jdGlvbiImJmgoc3QscCx5KSkpLEEmJkQmJkQubmFtZSE9PU0mJih3PSEwLEk9ZnVuY3Rpb24oKXtyZXR1cm4gRC5jYWxsKHRoaXMpfSksKCFufHxSKSYmKE98fHd8fCFCW3BdKSYmaChCLHAsSSksdVtzXT1JLHVbTl09eSx2KWlmKEo9e3ZhbHVlczpBP0k6TChNKSxrZXlzOlQ/STpMKGIpLGVudHJpZXM6an0sUilmb3IoXyBpbiBKKV8gaW4gQnx8ZihCLF8sSltfXSk7ZWxzZSBpKGkuUCtpLkYqKE98fHcpLHMsSik7cmV0dXJuIEp9fSxmdW5jdGlvbihnLGUpe2cuZXhwb3J0cz0hMH0sZnVuY3Rpb24oZyxlLHQpe3ZhciBuPXQoOTEpLGk9dCg5MiksZj10KDkzKSxoPXQoOTUpLHU9dCgxMDUpLGE9InByb3RvdHlwZSIsZD1mdW5jdGlvbihFLHAsTyl7dmFyIG09RSZkLkYsYj1FJmQuRyxNPUUmZC5TLHk9RSZkLlAsUz1FJmQuQixzPUUmZC5XLGM9Yj9pOmlbcF18fChpW3BdPXt9KSxsPWNbYV0sdj1iP246TT9uW3BdOihuW3BdfHx7fSlbYV0sVCxSLEw7YiYmKE89cCk7Zm9yKFQgaW4gTylSPSFtJiZ2JiZ2W1RdIT09dm9pZCAwLCEoUiYmdShjLFQpKSYmKEw9Uj92W1RdOk9bVF0sY1tUXT1iJiZ0eXBlb2YgdltUXSE9ImZ1bmN0aW9uIj9PW1RdOlMmJlI/ZihMLG4pOnMmJnZbVF09PUw/ZnVuY3Rpb24oTil7dmFyIEE9ZnVuY3Rpb24odyxCLEQpe2lmKHRoaXMgaW5zdGFuY2VvZiBOKXtzd2l0Y2goYXJndW1lbnRzLmxlbmd0aCl7Y2FzZSAwOnJldHVybiBuZXcgTjtjYXNlIDE6cmV0dXJuIG5ldyBOKHcpO2Nhc2UgMjpyZXR1cm4gbmV3IE4odyxCKX1yZXR1cm4gbmV3IE4odyxCLEQpfXJldHVybiBOLmFwcGx5KHRoaXMsYXJndW1lbnRzKX07cmV0dXJuIEFbYV09TlthXSxBfShMKTp5JiZ0eXBlb2YgTD09ImZ1bmN0aW9uIj9mKEZ1bmN0aW9uLmNhbGwsTCk6TCx5JiYoKGMudmlydHVhbHx8KGMudmlydHVhbD17fSkpW1RdPUwsRSZkLlImJmwmJiFsW1RdJiZoKGwsVCxMKSkpfTtkLkY9MSxkLkc9MixkLlM9NCxkLlA9OCxkLkI9MTYsZC5XPTMyLGQuVT02NCxkLlI9MTI4LGcuZXhwb3J0cz1kfSxmdW5jdGlvbihnLGUpe3ZhciB0PWcuZXhwb3J0cz10eXBlb2Ygd2luZG93PCJ1IiYmd2luZG93Lk1hdGg9PU1hdGg/d2luZG93OnR5cGVvZiBzZWxmPCJ1IiYmc2VsZi5NYXRoPT1NYXRoP3NlbGY6RnVuY3Rpb24oInJldHVybiB0aGlzIikoKTt0eXBlb2YgX19nPT0ibnVtYmVyIiYmKF9fZz10KX0sZnVuY3Rpb24oZyxlKXt2YXIgdD1nLmV4cG9ydHM9e3ZlcnNpb246IjIuNi4xMSJ9O3R5cGVvZiBfX2U9PSJudW1iZXIiJiYoX19lPXQpfSxmdW5jdGlvbihnLGUsdCl7dmFyIG49dCg5NCk7Zy5leHBvcnRzPWZ1bmN0aW9uKGksZixoKXtpZihuKGkpLGY9PT12b2lkIDApcmV0dXJuIGk7c3dpdGNoKGgpe2Nhc2UgMTpyZXR1cm4gZnVuY3Rpb24odSl7cmV0dXJuIGkuY2FsbChmLHUpfTtjYXNlIDI6cmV0dXJuIGZ1bmN0aW9uKHUsYSl7cmV0dXJuIGkuY2FsbChmLHUsYSl9O2Nhc2UgMzpyZXR1cm4gZnVuY3Rpb24odSxhLGQpe3JldHVybiBpLmNhbGwoZix1LGEsZCl9fXJldHVybiBmdW5jdGlvbigpe3JldHVybiBpLmFwcGx5KGYsYXJndW1lbnRzKX19fSxmdW5jdGlvbihnLGUpe2cuZXhwb3J0cz1mdW5jdGlvbih0KXtpZih0eXBlb2YgdCE9ImZ1bmN0aW9uIil0aHJvdyBUeXBlRXJyb3IodCsiIGlzIG5vdCBhIGZ1bmN0aW9uISIpO3JldHVybiB0fX0sZnVuY3Rpb24oZyxlLHQpe3ZhciBuPXQoOTYpLGk9dCgxMDQpO2cuZXhwb3J0cz10KDEwMCk/ZnVuY3Rpb24oZixoLHUpe3JldHVybiBuLmYoZixoLGkoMSx1KSl9OmZ1bmN0aW9uKGYsaCx1KXtyZXR1cm4gZltoXT11LGZ9fSxmdW5jdGlvbihnLGUsdCl7dmFyIG49dCg5NyksaT10KDk5KSxmPXQoMTAzKSxoPU9iamVjdC5kZWZpbmVQcm9wZXJ0eTtlLmY9dCgxMDApP09iamVjdC5kZWZpbmVQcm9wZXJ0eTpmdW5jdGlvbihhLGQsRSl7aWYobihhKSxkPWYoZCwhMCksbihFKSxpKXRyeXtyZXR1cm4gaChhLGQsRSl9Y2F0Y2h7fWlmKCJnZXQiaW4gRXx8InNldCJpbiBFKXRocm93IFR5cGVFcnJvcigiQWNjZXNzb3JzIG5vdCBzdXBwb3J0ZWQhIik7cmV0dXJuInZhbHVlImluIEUmJihhW2RdPUUudmFsdWUpLGF9fSxmdW5jdGlvbihnLGUsdCl7dmFyIG49dCg5OCk7Zy5leHBvcnRzPWZ1bmN0aW9uKGkpe2lmKCFuKGkpKXRocm93IFR5cGVFcnJvcihpKyIgaXMgbm90IGFuIG9iamVjdCEiKTtyZXR1cm4gaX19LGZ1bmN0aW9uKGcsZSl7Zy5leHBvcnRzPWZ1bmN0aW9uKHQpe3JldHVybiB0eXBlb2YgdD09Im9iamVjdCI/dCE9PW51bGw6dHlwZW9mIHQ9PSJmdW5jdGlvbiJ9fSxmdW5jdGlvbihnLGUsdCl7Zy5leHBvcnRzPSF0KDEwMCkmJiF0KDEwMSkoZnVuY3Rpb24oKXtyZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHQoMTAyKSgiZGl2IiksImEiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gN319KS5hIT03fSl9LGZ1bmN0aW9uKGcsZSx0KXtnLmV4cG9ydHM9IXQoMTAxKShmdW5jdGlvbigpe3JldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sImEiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gN319KS5hIT03fSl9LGZ1bmN0aW9uKGcsZSl7Zy5leHBvcnRzPWZ1bmN0aW9uKHQpe3RyeXtyZXR1cm4hIXQoKX1jYXRjaHtyZXR1cm4hMH19fSxmdW5jdGlvbihnLGUsdCl7dmFyIG49dCg5OCksaT10KDkxKS5kb2N1bWVudCxmPW4oaSkmJm4oaS5jcmVhdGVFbGVtZW50KTtnLmV4cG9ydHM9ZnVuY3Rpb24oaCl7cmV0dXJuIGY/aS5jcmVhdGVFbGVtZW50KGgpOnt9fX0sZnVuY3Rpb24oZyxlLHQpe3ZhciBuPXQoOTgpO2cuZXhwb3J0cz1mdW5jdGlvbihpLGYpe2lmKCFuKGkpKXJldHVybiBpO3ZhciBoLHU7aWYoZiYmdHlwZW9mKGg9aS50b1N0cmluZyk9PSJmdW5jdGlvbiImJiFuKHU9aC5jYWxsKGkpKXx8dHlwZW9mKGg9aS52YWx1ZU9mKT09ImZ1bmN0aW9uIiYmIW4odT1oLmNhbGwoaSkpfHwhZiYmdHlwZW9mKGg9aS50b1N0cmluZyk9PSJmdW5jdGlvbiImJiFuKHU9aC5jYWxsKGkpKSlyZXR1cm4gdTt0aHJvdyBUeXBlRXJyb3IoIkNhbid0IGNvbnZlcnQgb2JqZWN0IHRvIHByaW1pdGl2ZSB2YWx1ZSIpfX0sZnVuY3Rpb24oZyxlKXtnLmV4cG9ydHM9ZnVuY3Rpb24odCxuKXtyZXR1cm57ZW51bWVyYWJsZTohKHQmMSksY29uZmlndXJhYmxlOiEodCYyKSx3cml0YWJsZTohKHQmNCksdmFsdWU6bn19fSxmdW5jdGlvbihnLGUpe3ZhciB0PXt9Lmhhc093blByb3BlcnR5O2cuZXhwb3J0cz1mdW5jdGlvbihuLGkpe3JldHVybiB0LmNhbGwobixpKX19LGZ1bmN0aW9uKGcsZSx0KXtnLmV4cG9ydHM9dCg5NSl9LGZ1bmN0aW9uKGcsZSx0KXt2YXIgbj10KDEwOCksaT10KDEwNCksZj10KDEyMSksaD17fTt0KDk1KShoLHQoMTIyKSgiaXRlcmF0b3IiKSxmdW5jdGlvbigpe3JldHVybiB0aGlzfSksZy5leHBvcnRzPWZ1bmN0aW9uKHUsYSxkKXt1LnByb3RvdHlwZT1uKGgse25leHQ6aSgxLGQpfSksZih1LGErIiBJdGVyYXRvciIpfX0sZnVuY3Rpb24oZyxlLHQpe3ZhciBuPXQoOTcpLGk9dCgxMDkpLGY9dCgxMTkpLGg9dCgxMTYpKCJJRV9QUk9UTyIpLHU9ZnVuY3Rpb24oKXt9LGE9InByb3RvdHlwZSIsZD1mdW5jdGlvbigpe3ZhciBFPXQoMTAyKSgiaWZyYW1lIikscD1mLmxlbmd0aCxPPSI8IixtPSI+IixiO2ZvcihFLnN0eWxlLmRpc3BsYXk9Im5vbmUiLHQoMTIwKS5hcHBlbmRDaGlsZChFKSxFLnNyYz0iamF2YXNjcmlwdDoiLGI9RS5jb250ZW50V2luZG93LmRvY3VtZW50LGIub3BlbigpLGIud3JpdGUoTysic2NyaXB0IittKyJkb2N1bWVudC5GPU9iamVjdCIrTysiL3NjcmlwdCIrbSksYi5jbG9zZSgpLGQ9Yi5GO3AtLTspZGVsZXRlIGRbYV1bZltwXV07cmV0dXJuIGQoKX07Zy5leHBvcnRzPU9iamVjdC5jcmVhdGV8fGZ1bmN0aW9uKHAsTyl7dmFyIG07cmV0dXJuIHAhPT1udWxsPyh1W2FdPW4ocCksbT1uZXcgdSx1W2FdPW51bGwsbVtoXT1wKTptPWQoKSxPPT09dm9pZCAwP206aShtLE8pfX0sZnVuY3Rpb24oZyxlLHQpe3ZhciBuPXQoOTYpLGk9dCg5NyksZj10KDExMCk7Zy5leHBvcnRzPXQoMTAwKT9PYmplY3QuZGVmaW5lUHJvcGVydGllczpmdW5jdGlvbih1LGEpe2kodSk7Zm9yKHZhciBkPWYoYSksRT1kLmxlbmd0aCxwPTAsTztFPnA7KW4uZih1LE89ZFtwKytdLGFbT10pO3JldHVybiB1fX0sZnVuY3Rpb24oZyxlLHQpe3ZhciBuPXQoMTExKSxpPXQoMTE5KTtnLmV4cG9ydHM9T2JqZWN0LmtleXN8fGZ1bmN0aW9uKGgpe3JldHVybiBuKGgsaSl9fSxmdW5jdGlvbihnLGUsdCl7dmFyIG49dCgxMDUpLGk9dCg4NCksZj10KDExMikoITEpLGg9dCgxMTYpKCJJRV9QUk9UTyIpO2cuZXhwb3J0cz1mdW5jdGlvbih1LGEpe3ZhciBkPWkodSksRT0wLHA9W10sTztmb3IoTyBpbiBkKU8hPWgmJm4oZCxPKSYmcC5wdXNoKE8pO2Zvcig7YS5sZW5ndGg+RTspbihkLE89YVtFKytdKSYmKH5mKHAsTyl8fHAucHVzaChPKSk7cmV0dXJuIHB9fSxmdW5jdGlvbihnLGUsdCl7dmFyIG49dCg4NCksaT10KDExMyksZj10KDExNSk7Zy5leHBvcnRzPWZ1bmN0aW9uKGgpe3JldHVybiBmdW5jdGlvbih1LGEsZCl7dmFyIEU9bih1KSxwPWkoRS5sZW5ndGgpLE89ZihkLHApLG07aWYoaCYmYSE9YSl7Zm9yKDtwPk87KWlmKG09RVtPKytdLG0hPW0pcmV0dXJuITB9ZWxzZSBmb3IoO3A+TztPKyspaWYoKGh8fE8gaW4gRSkmJkVbT109PT1hKXJldHVybiBofHxPfHwwO3JldHVybiFoJiYtMX19fSxmdW5jdGlvbihnLGUsdCl7dmFyIG49dCgxMTQpLGk9TWF0aC5taW47Zy5leHBvcnRzPWZ1bmN0aW9uKGYpe3JldHVybiBmPjA/aShuKGYpLDkwMDcxOTkyNTQ3NDA5OTEpOjB9fSxmdW5jdGlvbihnLGUpe3ZhciB0PU1hdGguY2VpbCxuPU1hdGguZmxvb3I7Zy5leHBvcnRzPWZ1bmN0aW9uKGkpe3JldHVybiBpc05hTihpPStpKT8wOihpPjA/bjp0KShpKX19LGZ1bmN0aW9uKGcsZSx0KXt2YXIgbj10KDExNCksaT1NYXRoLm1heCxmPU1hdGgubWluO2cuZXhwb3J0cz1mdW5jdGlvbihoLHUpe3JldHVybiBoPW4oaCksaDwwP2koaCt1LDApOmYoaCx1KX19LGZ1bmN0aW9uKGcsZSx0KXt2YXIgbj10KDExNykoImtleXMiKSxpPXQoMTE4KTtnLmV4cG9ydHM9ZnVuY3Rpb24oZil7cmV0dXJuIG5bZl18fChuW2ZdPWkoZikpfX0sZnVuY3Rpb24oZyxlLHQpe3ZhciBuPXQoOTIpLGk9dCg5MSksZj0iX19jb3JlLWpzX3NoYXJlZF9fIixoPWlbZl18fChpW2ZdPXt9KTsoZy5leHBvcnRzPWZ1bmN0aW9uKHUsYSl7cmV0dXJuIGhbdV18fChoW3VdPWEhPT12b2lkIDA/YTp7fSl9KSgidmVyc2lvbnMiLFtdKS5wdXNoKHt2ZXJzaW9uOm4udmVyc2lvbixtb2RlOnQoODkpPyJwdXJlIjoiZ2xvYmFsIixjb3B5cmlnaHQ6IsKpIDIwMTkgRGVuaXMgUHVzaGthcmV2ICh6bG9pcm9jay5ydSkifSl9LGZ1bmN0aW9uKGcsZSl7dmFyIHQ9MCxuPU1hdGgucmFuZG9tKCk7Zy5leHBvcnRzPWZ1bmN0aW9uKGkpe3JldHVybiJTeW1ib2woIi5jb25jYXQoaT09PXZvaWQgMD8iIjppLCIpXyIsKCsrdCtuKS50b1N0cmluZygzNikpfX0sZnVuY3Rpb24oZyxlKXtnLmV4cG9ydHM9ImNvbnN0cnVjdG9yLGhhc093blByb3BlcnR5LGlzUHJvdG90eXBlT2YscHJvcGVydHlJc0VudW1lcmFibGUsdG9Mb2NhbGVTdHJpbmcsdG9TdHJpbmcsdmFsdWVPZiIuc3BsaXQoIiwiKX0sZnVuY3Rpb24oZyxlLHQpe3ZhciBuPXQoOTEpLmRvY3VtZW50O2cuZXhwb3J0cz1uJiZuLmRvY3VtZW50RWxlbWVudH0sZnVuY3Rpb24oZyxlLHQpe3ZhciBuPXQoOTYpLmYsaT10KDEwNSksZj10KDEyMikoInRvU3RyaW5nVGFnIik7Zy5leHBvcnRzPWZ1bmN0aW9uKGgsdSxhKXtoJiYhaShoPWE/aDpoLnByb3RvdHlwZSxmKSYmbihoLGYse2NvbmZpZ3VyYWJsZTohMCx2YWx1ZTp1fSl9fSxmdW5jdGlvbihnLGUsdCl7dmFyIG49dCgxMTcpKCJ3a3MiKSxpPXQoMTE4KSxmPXQoOTEpLlN5bWJvbCxoPXR5cGVvZiBmPT0iZnVuY3Rpb24iLHU9Zy5leHBvcnRzPWZ1bmN0aW9uKGEpe3JldHVybiBuW2FdfHwoblthXT1oJiZmW2FdfHwoaD9mOmkpKCJTeW1ib2wuIithKSl9O3Uuc3RvcmU9bn0sZnVuY3Rpb24oZyxlLHQpe3ZhciBuPXQoMTA1KSxpPXQoMTI0KSxmPXQoMTE2KSgiSUVfUFJPVE8iKSxoPU9iamVjdC5wcm90b3R5cGU7Zy5leHBvcnRzPU9iamVjdC5nZXRQcm90b3R5cGVPZnx8ZnVuY3Rpb24odSl7cmV0dXJuIHU9aSh1KSxuKHUsZik/dVtmXTp0eXBlb2YgdS5jb25zdHJ1Y3Rvcj09ImZ1bmN0aW9uIiYmdSBpbnN0YW5jZW9mIHUuY29uc3RydWN0b3I/dS5jb25zdHJ1Y3Rvci5wcm90b3R5cGU6dSBpbnN0YW5jZW9mIE9iamVjdD9oOm51bGx9fSxmdW5jdGlvbihnLGUsdCl7dmFyIG49dCg4Nyk7Zy5leHBvcnRzPWZ1bmN0aW9uKGkpe3JldHVybiBPYmplY3QobihpKSl9fSxmdW5jdGlvbihnLGUsdCl7dmFyIG49dCgxMjYpKCEwKTt0KDg4KShTdHJpbmcsIlN0cmluZyIsZnVuY3Rpb24oaSl7dGhpcy5fdD1TdHJpbmcoaSksdGhpcy5faT0wfSxmdW5jdGlvbigpe3ZhciBpPXRoaXMuX3QsZj10aGlzLl9pLGg7cmV0dXJuIGY+PWkubGVuZ3RoP3t2YWx1ZTp2b2lkIDAsZG9uZTohMH06KGg9bihpLGYpLHRoaXMuX2krPWgubGVuZ3RoLHt2YWx1ZTpoLGRvbmU6ITF9KX0pfSxmdW5jdGlvbihnLGUsdCl7dmFyIG49dCgxMTQpLGk9dCg4Nyk7Zy5leHBvcnRzPWZ1bmN0aW9uKGYpe3JldHVybiBmdW5jdGlvbihoLHUpe3ZhciBhPVN0cmluZyhpKGgpKSxkPW4odSksRT1hLmxlbmd0aCxwLE87cmV0dXJuIGQ8MHx8ZD49RT9mPyIiOnZvaWQgMDoocD1hLmNoYXJDb2RlQXQoZCkscDw1NTI5Nnx8cD41NjMxOXx8ZCsxPT09RXx8KE89YS5jaGFyQ29kZUF0KGQrMSkpPDU2MzIwfHxPPjU3MzQzP2Y/YS5jaGFyQXQoZCk6cDpmP2Euc2xpY2UoZCxkKzIpOihwLTU1Mjk2PDwxMCkrKE8tNTYzMjApKzY1NTM2KX19fSxmdW5jdGlvbihnLGUsdCl7dmFyIG49dCgxMjgpLGk9dCgxMjIpKCJpdGVyYXRvciIpLGY9dCg4Myk7Zy5leHBvcnRzPXQoOTIpLmlzSXRlcmFibGU9ZnVuY3Rpb24oaCl7dmFyIHU9T2JqZWN0KGgpO3JldHVybiB1W2ldIT09dm9pZCAwfHwiQEBpdGVyYXRvciJpbiB1fHxmLmhhc093blByb3BlcnR5KG4odSkpfX0sZnVuY3Rpb24oZyxlLHQpe3ZhciBuPXQoODYpLGk9dCgxMjIpKCJ0b1N0cmluZ1RhZyIpLGY9bihmdW5jdGlvbigpe3JldHVybiBhcmd1bWVudHN9KCkpPT0iQXJndW1lbnRzIixoPWZ1bmN0aW9uKHUsYSl7dHJ5e3JldHVybiB1W2FdfWNhdGNoe319O2cuZXhwb3J0cz1mdW5jdGlvbih1KXt2YXIgYSxkLEU7cmV0dXJuIHU9PT12b2lkIDA/IlVuZGVmaW5lZCI6dT09PW51bGw/Ik51bGwiOnR5cGVvZihkPWgoYT1PYmplY3QodSksaSkpPT0ic3RyaW5nIj9kOmY/bihhKTooRT1uKGEpKT09Ik9iamVjdCImJnR5cGVvZiBhLmNhbGxlZT09ImZ1bmN0aW9uIj8iQXJndW1lbnRzIjpFfX0sZnVuY3Rpb24oZyxlLHQpe2cuZXhwb3J0cz17ZGVmYXVsdDp0KDEzMCksX19lc01vZHVsZTohMH19LGZ1bmN0aW9uKGcsZSx0KXt0KDc5KSx0KDEyNSksZy5leHBvcnRzPXQoMTMxKX0sZnVuY3Rpb24oZyxlLHQpe3ZhciBuPXQoOTcpLGk9dCgxMzIpO2cuZXhwb3J0cz10KDkyKS5nZXRJdGVyYXRvcj1mdW5jdGlvbihmKXt2YXIgaD1pKGYpO2lmKHR5cGVvZiBoIT0iZnVuY3Rpb24iKXRocm93IFR5cGVFcnJvcihmKyIgaXMgbm90IGl0ZXJhYmxlISIpO3JldHVybiBuKGguY2FsbChmKSl9fSxmdW5jdGlvbihnLGUsdCl7dmFyIG49dCgxMjgpLGk9dCgxMjIpKCJpdGVyYXRvciIpLGY9dCg4Myk7Zy5leHBvcnRzPXQoOTIpLmdldEl0ZXJhdG9yTWV0aG9kPWZ1bmN0aW9uKGgpe2lmKGghPW51bGwpcmV0dXJuIGhbaV18fGhbIkBAaXRlcmF0b3IiXXx8ZltuKGgpXX19LGZ1bmN0aW9uKGcsZSx0KXtlLl9fZXNNb2R1bGU9ITA7dmFyIG49dCgxMzQpLGk9ZihuKTtmdW5jdGlvbiBmKGgpe3JldHVybiBoJiZoLl9fZXNNb2R1bGU/aDp7ZGVmYXVsdDpofX1lLmRlZmF1bHQ9ZnVuY3Rpb24oaCl7aWYoQXJyYXkuaXNBcnJheShoKSl7Zm9yKHZhciB1PTAsYT1BcnJheShoLmxlbmd0aCk7dTxoLmxlbmd0aDt1KyspYVt1XT1oW3VdO3JldHVybiBhfWVsc2UgcmV0dXJuKDAsaS5kZWZhdWx0KShoKX19LGZ1bmN0aW9uKGcsZSx0KXtnLmV4cG9ydHM9e2RlZmF1bHQ6dCgxMzUpLF9fZXNNb2R1bGU6ITB9fSxmdW5jdGlvbihnLGUsdCl7dCgxMjUpLHQoMTM2KSxnLmV4cG9ydHM9dCg5MikuQXJyYXkuZnJvbX0sZnVuY3Rpb24oZyxlLHQpe3ZhciBuPXQoOTMpLGk9dCg5MCksZj10KDEyNCksaD10KDEzNyksdT10KDEzOCksYT10KDExMyksZD10KDEzOSksRT10KDEzMik7aShpLlMraS5GKiF0KDE0MCkoZnVuY3Rpb24ocCl7QXJyYXkuZnJvbShwKX0pLCJBcnJheSIse2Zyb206ZnVuY3Rpb24oTyl7dmFyIG09ZihPKSxiPXR5cGVvZiB0aGlzPT0iZnVuY3Rpb24iP3RoaXM6QXJyYXksTT1hcmd1bWVudHMubGVuZ3RoLHk9TT4xP2FyZ3VtZW50c1sxXTp2b2lkIDAsUz15IT09dm9pZCAwLHM9MCxjPUUobSksbCx2LFQsUjtpZihTJiYoeT1uKHksTT4yP2FyZ3VtZW50c1syXTp2b2lkIDAsMikpLGMhPW51bGwmJiEoYj09QXJyYXkmJnUoYykpKWZvcihSPWMuY2FsbChtKSx2PW5ldyBiOyEoVD1SLm5leHQoKSkuZG9uZTtzKyspZCh2LHMsUz9oKFIseSxbVC52YWx1ZSxzXSwhMCk6VC52YWx1ZSk7ZWxzZSBmb3IobD1hKG0ubGVuZ3RoKSx2PW5ldyBiKGwpO2w+cztzKyspZCh2LHMsUz95KG1bc10scyk6bVtzXSk7cmV0dXJuIHYubGVuZ3RoPXMsdn19KX0sZnVuY3Rpb24oZyxlLHQpe3ZhciBuPXQoOTcpO2cuZXhwb3J0cz1mdW5jdGlvbihpLGYsaCx1KXt0cnl7cmV0dXJuIHU/ZihuKGgpWzBdLGhbMV0pOmYoaCl9Y2F0Y2goZCl7dmFyIGE9aS5yZXR1cm47dGhyb3cgYSE9PXZvaWQgMCYmbihhLmNhbGwoaSkpLGR9fX0sZnVuY3Rpb24oZyxlLHQpe3ZhciBuPXQoODMpLGk9dCgxMjIpKCJpdGVyYXRvciIpLGY9QXJyYXkucHJvdG90eXBlO2cuZXhwb3J0cz1mdW5jdGlvbihoKXtyZXR1cm4gaCE9PXZvaWQgMCYmKG4uQXJyYXk9PT1ofHxmW2ldPT09aCl9fSxmdW5jdGlvbihnLGUsdCl7dmFyIG49dCg5NiksaT10KDEwNCk7Zy5leHBvcnRzPWZ1bmN0aW9uKGYsaCx1KXtoIGluIGY/bi5mKGYsaCxpKDAsdSkpOmZbaF09dX19LGZ1bmN0aW9uKGcsZSx0KXt2YXIgbj10KDEyMikoIml0ZXJhdG9yIiksaT0hMTt0cnl7dmFyIGY9WzddW25dKCk7Zi5yZXR1cm49ZnVuY3Rpb24oKXtpPSEwfSxBcnJheS5mcm9tKGYsZnVuY3Rpb24oKXt0aHJvdyAyfSl9Y2F0Y2h7fWcuZXhwb3J0cz1mdW5jdGlvbihoLHUpe2lmKCF1JiYhaSlyZXR1cm4hMTt2YXIgYT0hMTt0cnl7dmFyIGQ9WzddLEU9ZFtuXSgpO0UubmV4dD1mdW5jdGlvbigpe3JldHVybntkb25lOmE9ITB9fSxkW25dPWZ1bmN0aW9uKCl7cmV0dXJuIEV9LGgoZCl9Y2F0Y2h7fXJldHVybiBhfX0sZnVuY3Rpb24oZyxlLHQpe2cuZXhwb3J0cz17ZGVmYXVsdDp0KDE0MiksX19lc01vZHVsZTohMH19LGZ1bmN0aW9uKGcsZSx0KXt0KDE0MyksdCgxMjUpLHQoNzkpLHQoMTQ0KSx0KDE1NyksdCgxNjApLHQoMTYyKSxnLmV4cG9ydHM9dCg5MikuTWFwfSxmdW5jdGlvbihnLGUpe30sZnVuY3Rpb24oZyxlLHQpe3ZhciBuPXQoMTQ1KSxpPXQoMTUxKSxmPSJNYXAiO2cuZXhwb3J0cz10KDE1MikoZixmdW5jdGlvbihoKXtyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gaCh0aGlzLGFyZ3VtZW50cy5sZW5ndGg+MD9hcmd1bWVudHNbMF06dm9pZCAwKX19LHtnZXQ6ZnVuY3Rpb24odSl7dmFyIGE9bi5nZXRFbnRyeShpKHRoaXMsZiksdSk7cmV0dXJuIGEmJmEudn0sc2V0OmZ1bmN0aW9uKHUsYSl7cmV0dXJuIG4uZGVmKGkodGhpcyxmKSx1PT09MD8wOnUsYSl9fSxuLCEwKX0sZnVuY3Rpb24oZyxlLHQpe3ZhciBuPXQoOTYpLmYsaT10KDEwOCksZj10KDE0NiksaD10KDkzKSx1PXQoMTQ3KSxhPXQoMTQ4KSxkPXQoODgpLEU9dCg4MikscD10KDE0OSksTz10KDEwMCksbT10KDE1MCkuZmFzdEtleSxiPXQoMTUxKSxNPU8/Il9zIjoic2l6ZSIseT1mdW5jdGlvbihTLHMpe3ZhciBjPW0ocyksbDtpZihjIT09IkYiKXJldHVybiBTLl9pW2NdO2ZvcihsPVMuX2Y7bDtsPWwubilpZihsLms9PXMpcmV0dXJuIGx9O2cuZXhwb3J0cz17Z2V0Q29uc3RydWN0b3I6ZnVuY3Rpb24oUyxzLGMsbCl7dmFyIHY9UyhmdW5jdGlvbihULFIpe3UoVCx2LHMsIl9pIiksVC5fdD1zLFQuX2k9aShudWxsKSxULl9mPXZvaWQgMCxULl9sPXZvaWQgMCxUW01dPTAsUiE9bnVsbCYmYShSLGMsVFtsXSxUKX0pO3JldHVybiBmKHYucHJvdG90eXBlLHtjbGVhcjpmdW5jdGlvbigpe2Zvcih2YXIgUj1iKHRoaXMscyksTD1SLl9pLE49Ui5fZjtOO049Ti5uKU4ucj0hMCxOLnAmJihOLnA9Ti5wLm49dm9pZCAwKSxkZWxldGUgTFtOLmldO1IuX2Y9Ui5fbD12b2lkIDAsUltNXT0wfSxkZWxldGU6ZnVuY3Rpb24oVCl7dmFyIFI9Yih0aGlzLHMpLEw9eShSLFQpO2lmKEwpe3ZhciBOPUwubixBPUwucDtkZWxldGUgUi5faVtMLmldLEwucj0hMCxBJiYoQS5uPU4pLE4mJihOLnA9QSksUi5fZj09TCYmKFIuX2Y9TiksUi5fbD09TCYmKFIuX2w9QSksUltNXS0tfXJldHVybiEhTH0sZm9yRWFjaDpmdW5jdGlvbihSKXtiKHRoaXMscyk7Zm9yKHZhciBMPWgoUixhcmd1bWVudHMubGVuZ3RoPjE/YXJndW1lbnRzWzFdOnZvaWQgMCwzKSxOO049Tj9OLm46dGhpcy5fZjspZm9yKEwoTi52LE4uayx0aGlzKTtOJiZOLnI7KU49Ti5wfSxoYXM6ZnVuY3Rpb24oUil7cmV0dXJuISF5KGIodGhpcyxzKSxSKX19KSxPJiZuKHYucHJvdG90eXBlLCJzaXplIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGIodGhpcyxzKVtNXX19KSx2fSxkZWY6ZnVuY3Rpb24oUyxzLGMpe3ZhciBsPXkoUyxzKSx2LFQ7cmV0dXJuIGw/bC52PWM6KFMuX2w9bD17aTpUPW0ocywhMCksazpzLHY6YyxwOnY9Uy5fbCxuOnZvaWQgMCxyOiExfSxTLl9mfHwoUy5fZj1sKSx2JiYodi5uPWwpLFNbTV0rKyxUIT09IkYiJiYoUy5faVtUXT1sKSksU30sZ2V0RW50cnk6eSxzZXRTdHJvbmc6ZnVuY3Rpb24oUyxzLGMpe2QoUyxzLGZ1bmN0aW9uKGwsdil7dGhpcy5fdD1iKGwscyksdGhpcy5faz12LHRoaXMuX2w9dm9pZCAwfSxmdW5jdGlvbigpe2Zvcih2YXIgbD10aGlzLHY9bC5fayxUPWwuX2w7VCYmVC5yOylUPVQucDtyZXR1cm4hbC5fdHx8IShsLl9sPVQ9VD9ULm46bC5fdC5fZik/KGwuX3Q9dm9pZCAwLEUoMSkpOnY9PSJrZXlzIj9FKDAsVC5rKTp2PT0idmFsdWVzIj9FKDAsVC52KTpFKDAsW1QuayxULnZdKX0sYz8iZW50cmllcyI6InZhbHVlcyIsIWMsITApLHAocyl9fX0sZnVuY3Rpb24oZyxlLHQpe3ZhciBuPXQoOTUpO2cuZXhwb3J0cz1mdW5jdGlvbihpLGYsaCl7Zm9yKHZhciB1IGluIGYpaCYmaVt1XT9pW3VdPWZbdV06bihpLHUsZlt1XSk7cmV0dXJuIGl9fSxmdW5jdGlvbihnLGUpe2cuZXhwb3J0cz1mdW5jdGlvbih0LG4saSxmKXtpZighKHQgaW5zdGFuY2VvZiBuKXx8ZiE9PXZvaWQgMCYmZiBpbiB0KXRocm93IFR5cGVFcnJvcihpKyI6IGluY29ycmVjdCBpbnZvY2F0aW9uISIpO3JldHVybiB0fX0sZnVuY3Rpb24oZyxwLHQpe3ZhciBuPXQoOTMpLGk9dCgxMzcpLGY9dCgxMzgpLGg9dCg5NyksdT10KDExMyksYT10KDEzMiksZD17fSxFPXt9LHA9Zy5leHBvcnRzPWZ1bmN0aW9uKE8sbSxiLE0seSl7dmFyIFM9eT9mdW5jdGlvbigpe3JldHVybiBPfTphKE8pLHM9bihiLE0sbT8yOjEpLGM9MCxsLHYsVCxSO2lmKHR5cGVvZiBTIT0iZnVuY3Rpb24iKXRocm93IFR5cGVFcnJvcihPKyIgaXMgbm90IGl0ZXJhYmxlISIpO2lmKGYoUykpe2ZvcihsPXUoTy5sZW5ndGgpO2w+YztjKyspaWYoUj1tP3MoaCh2PU9bY10pWzBdLHZbMV0pOnMoT1tjXSksUj09PWR8fFI9PT1FKXJldHVybiBSfWVsc2UgZm9yKFQ9Uy5jYWxsKE8pOyEodj1ULm5leHQoKSkuZG9uZTspaWYoUj1pKFQscyx2LnZhbHVlLG0pLFI9PT1kfHxSPT09RSlyZXR1cm4gUn07cC5CUkVBSz1kLHAuUkVUVVJOPUV9LGZ1bmN0aW9uKGcsZSx0KXt2YXIgbj10KDkxKSxpPXQoOTIpLGY9dCg5NiksaD10KDEwMCksdT10KDEyMikoInNwZWNpZXMiKTtnLmV4cG9ydHM9ZnVuY3Rpb24oYSl7dmFyIGQ9dHlwZW9mIGlbYV09PSJmdW5jdGlvbiI/aVthXTpuW2FdO2gmJmQmJiFkW3VdJiZmLmYoZCx1LHtjb25maWd1cmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9fSl9fSxmdW5jdGlvbihnLGUsdCl7dmFyIG49dCgxMTgpKCJtZXRhIiksaT10KDk4KSxmPXQoMTA1KSxoPXQoOTYpLmYsdT0wLGE9T2JqZWN0LmlzRXh0ZW5zaWJsZXx8ZnVuY3Rpb24oKXtyZXR1cm4hMH0sZD0hdCgxMDEpKGZ1bmN0aW9uKCl7cmV0dXJuIGEoT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKHt9KSl9KSxFPWZ1bmN0aW9uKE0pe2goTSxuLHt2YWx1ZTp7aToiTyIrICsrdSx3Ont9fX0pfSxwPWZ1bmN0aW9uKE0seSl7aWYoIWkoTSkpcmV0dXJuIHR5cGVvZiBNPT0ic3ltYm9sIj9NOih0eXBlb2YgTT09InN0cmluZyI/IlMiOiJQIikrTTtpZighZihNLG4pKXtpZighYShNKSlyZXR1cm4iRiI7aWYoIXkpcmV0dXJuIkUiO0UoTSl9cmV0dXJuIE1bbl0uaX0sTz1mdW5jdGlvbihNLHkpe2lmKCFmKE0sbikpe2lmKCFhKE0pKXJldHVybiEwO2lmKCF5KXJldHVybiExO0UoTSl9cmV0dXJuIE1bbl0ud30sbT1mdW5jdGlvbihNKXtyZXR1cm4gZCYmYi5ORUVEJiZhKE0pJiYhZihNLG4pJiZFKE0pLE19LGI9Zy5leHBvcnRzPXtLRVk6bixORUVEOiExLGZhc3RLZXk6cCxnZXRXZWFrOk8sb25GcmVlemU6bX19LGZ1bmN0aW9uKGcsZSx0KXt2YXIgbj10KDk4KTtnLmV4cG9ydHM9ZnVuY3Rpb24oaSxmKXtpZighbihpKXx8aS5fdCE9PWYpdGhyb3cgVHlwZUVycm9yKCJJbmNvbXBhdGlibGUgcmVjZWl2ZXIsICIrZisiIHJlcXVpcmVkISIpO3JldHVybiBpfX0sZnVuY3Rpb24oZyxlLHQpe3ZhciBuPXQoOTEpLGk9dCg5MCksZj10KDE1MCksaD10KDEwMSksdT10KDk1KSxhPXQoMTQ2KSxkPXQoMTQ4KSxFPXQoMTQ3KSxwPXQoOTgpLE89dCgxMjEpLG09dCg5NikuZixiPXQoMTUzKSgwKSxNPXQoMTAwKTtnLmV4cG9ydHM9ZnVuY3Rpb24oeSxTLHMsYyxsLHYpe3ZhciBUPW5beV0sUj1ULEw9bD8ic2V0IjoiYWRkIixOPVImJlIucHJvdG90eXBlLEE9e307cmV0dXJuIU18fHR5cGVvZiBSIT0iZnVuY3Rpb24ifHwhKHZ8fE4uZm9yRWFjaCYmIWgoZnVuY3Rpb24oKXtuZXcgUigpLmVudHJpZXMoKS5uZXh0KCl9KSk/KFI9Yy5nZXRDb25zdHJ1Y3RvcihTLHksbCxMKSxhKFIucHJvdG90eXBlLHMpLGYuTkVFRD0hMCk6KFI9UyhmdW5jdGlvbih3LEIpe0UodyxSLHksIl9jIiksdy5fYz1uZXcgVCxCIT1udWxsJiZkKEIsbCx3W0xdLHcpfSksYigiYWRkLGNsZWFyLGRlbGV0ZSxmb3JFYWNoLGdldCxoYXMsc2V0LGtleXMsdmFsdWVzLGVudHJpZXMsdG9KU09OIi5zcGxpdCgiLCIpLGZ1bmN0aW9uKHcpe3ZhciBCPXc9PSJhZGQifHx3PT0ic2V0Ijt3IGluIE4mJiEodiYmdz09ImNsZWFyIikmJnUoUi5wcm90b3R5cGUsdyxmdW5jdGlvbihELEkpe2lmKEUodGhpcyxSLHcpLCFCJiZ2JiYhcChEKSlyZXR1cm4gdz09ImdldCI/dm9pZCAwOiExO3ZhciBqPXRoaXMuX2Nbd10oRD09PTA/MDpELEkpO3JldHVybiBCP3RoaXM6an0pfSksdnx8bShSLnByb3RvdHlwZSwic2l6ZSIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9jLnNpemV9fSkpLE8oUix5KSxBW3ldPVIsaShpLkcraS5XK2kuRixBKSx2fHxjLnNldFN0cm9uZyhSLHksbCksUn19LGZ1bmN0aW9uKGcsZSx0KXt2YXIgbj10KDkzKSxpPXQoODUpLGY9dCgxMjQpLGg9dCgxMTMpLHU9dCgxNTQpO2cuZXhwb3J0cz1mdW5jdGlvbihhLGQpe3ZhciBFPWE9PTEscD1hPT0yLE89YT09MyxtPWE9PTQsYj1hPT02LE09YT09NXx8Yix5PWR8fHU7cmV0dXJuIGZ1bmN0aW9uKFMscyxjKXtmb3IodmFyIGw9ZihTKSx2PWkobCksVD1uKHMsYywzKSxSPWgodi5sZW5ndGgpLEw9MCxOPUU/eShTLFIpOnA/eShTLDApOnZvaWQgMCxBLHc7Uj5MO0wrKylpZigoTXx8TCBpbiB2KSYmKEE9dltMXSx3PVQoQSxMLGwpLGEpKXtpZihFKU5bTF09dztlbHNlIGlmKHcpc3dpdGNoKGEpe2Nhc2UgMzpyZXR1cm4hMDtjYXNlIDU6cmV0dXJuIEE7Y2FzZSA2OnJldHVybiBMO2Nhc2UgMjpOLnB1c2goQSl9ZWxzZSBpZihtKXJldHVybiExfXJldHVybiBiPy0xOk98fG0/bTpOfX19LGZ1bmN0aW9uKGcsZSx0KXt2YXIgbj10KDE1NSk7Zy5leHBvcnRzPWZ1bmN0aW9uKGksZil7cmV0dXJuIG5ldyhuKGkpKShmKX19LGZ1bmN0aW9uKGcsZSx0KXt2YXIgbj10KDk4KSxpPXQoMTU2KSxmPXQoMTIyKSgic3BlY2llcyIpO2cuZXhwb3J0cz1mdW5jdGlvbihoKXt2YXIgdTtyZXR1cm4gaShoKSYmKHU9aC5jb25zdHJ1Y3Rvcix0eXBlb2YgdT09ImZ1bmN0aW9uIiYmKHU9PT1BcnJheXx8aSh1LnByb3RvdHlwZSkpJiYodT12b2lkIDApLG4odSkmJih1PXVbZl0sdT09PW51bGwmJih1PXZvaWQgMCkpKSx1PT09dm9pZCAwP0FycmF5OnV9fSxmdW5jdGlvbihnLGUsdCl7dmFyIG49dCg4Nik7Zy5leHBvcnRzPUFycmF5LmlzQXJyYXl8fGZ1bmN0aW9uKGYpe3JldHVybiBuKGYpPT0iQXJyYXkifX0sZnVuY3Rpb24oZyxlLHQpe3ZhciBuPXQoOTApO24obi5QK24uUiwiTWFwIix7dG9KU09OOnQoMTU4KSgiTWFwIil9KX0sZnVuY3Rpb24oZyxlLHQpe3ZhciBuPXQoMTI4KSxpPXQoMTU5KTtnLmV4cG9ydHM9ZnVuY3Rpb24oZil7cmV0dXJuIGZ1bmN0aW9uKCl7aWYobih0aGlzKSE9Zil0aHJvdyBUeXBlRXJyb3IoZisiI3RvSlNPTiBpc24ndCBnZW5lcmljIik7cmV0dXJuIGkodGhpcyl9fX0sZnVuY3Rpb24oZyxlLHQpe3ZhciBuPXQoMTQ4KTtnLmV4cG9ydHM9ZnVuY3Rpb24oaSxmKXt2YXIgaD1bXTtyZXR1cm4gbihpLCExLGgucHVzaCxoLGYpLGh9fSxmdW5jdGlvbihnLGUsdCl7dCgxNjEpKCJNYXAiKX0sZnVuY3Rpb24oZyxlLHQpe3ZhciBuPXQoOTApO2cuZXhwb3J0cz1mdW5jdGlvbihpKXtuKG4uUyxpLHtvZjpmdW5jdGlvbigpe2Zvcih2YXIgaD1hcmd1bWVudHMubGVuZ3RoLHU9bmV3IEFycmF5KGgpO2gtLTspdVtoXT1hcmd1bWVudHNbaF07cmV0dXJuIG5ldyB0aGlzKHUpfX0pfX0sZnVuY3Rpb24oZyxlLHQpe3QoMTYzKSgiTWFwIil9LGZ1bmN0aW9uKGcsZSx0KXt2YXIgbj10KDkwKSxpPXQoOTQpLGY9dCg5MyksaD10KDE0OCk7Zy5leHBvcnRzPWZ1bmN0aW9uKHUpe24obi5TLHUse2Zyb206ZnVuY3Rpb24oZCl7dmFyIEU9YXJndW1lbnRzWzFdLHAsTyxtLGI7cmV0dXJuIGkodGhpcykscD1FIT09dm9pZCAwLHAmJmkoRSksZD09bnVsbD9uZXcgdGhpczooTz1bXSxwPyhtPTAsYj1mKEUsYXJndW1lbnRzWzJdLDIpLGgoZCwhMSxmdW5jdGlvbihNKXtPLnB1c2goYihNLG0rKykpfSkpOmgoZCwhMSxPLnB1c2gsTyksbmV3IHRoaXMoTykpfX0pfX0sZnVuY3Rpb24oZyxlLHQpe2cuZXhwb3J0cz17ZGVmYXVsdDp0KDE2NSksX19lc01vZHVsZTohMH19LGZ1bmN0aW9uKGcsZSx0KXt0KDE2NiksZy5leHBvcnRzPXQoOTIpLk9iamVjdC5hc3NpZ259LGZ1bmN0aW9uKGcsZSx0KXt2YXIgbj10KDkwKTtuKG4uUytuLkYsIk9iamVjdCIse2Fzc2lnbjp0KDE2Nyl9KX0sZnVuY3Rpb24oZyxlLHQpe3ZhciBuPXQoMTAwKSxpPXQoMTEwKSxmPXQoMTY4KSxoPXQoMTY5KSx1PXQoMTI0KSxhPXQoODUpLGQ9T2JqZWN0LmFzc2lnbjtnLmV4cG9ydHM9IWR8fHQoMTAxKShmdW5jdGlvbigpe3ZhciBFPXt9LHA9e30sTz1TeW1ib2woKSxtPSJhYmNkZWZnaGlqa2xtbm9wcXJzdCI7cmV0dXJuIEVbT109NyxtLnNwbGl0KCIiKS5mb3JFYWNoKGZ1bmN0aW9uKGIpe3BbYl09Yn0pLGQoe30sRSlbT10hPTd8fE9iamVjdC5rZXlzKGQoe30scCkpLmpvaW4oIiIpIT1tfSk/ZnVuY3Rpb24ocCxPKXtmb3IodmFyIG09dShwKSxiPWFyZ3VtZW50cy5sZW5ndGgsTT0xLHk9Zi5mLFM9aC5mO2I+TTspZm9yKHZhciBzPWEoYXJndW1lbnRzW00rK10pLGM9eT9pKHMpLmNvbmNhdCh5KHMpKTppKHMpLGw9Yy5sZW5ndGgsdj0wLFQ7bD52OylUPWNbdisrXSwoIW58fFMuY2FsbChzLFQpKSYmKG1bVF09c1tUXSk7cmV0dXJuIG19OmR9LGZ1bmN0aW9uKGcsZSl7ZS5mPU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHN9LGZ1bmN0aW9uKGcsZSl7ZS5mPXt9LnByb3BlcnR5SXNFbnVtZXJhYmxlfSxmdW5jdGlvbihnLGUsdCl7ZS5fX2VzTW9kdWxlPSEwLGUuZGVmYXVsdD1mdW5jdGlvbihuLGkpe2lmKCEobiBpbnN0YW5jZW9mIGkpKXRocm93IG5ldyBUeXBlRXJyb3IoIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbiIpfX0sZnVuY3Rpb24oZyxlLHQpe2UuX19lc01vZHVsZT0hMDt2YXIgbj10KDE3MiksaT1mKG4pO2Z1bmN0aW9uIGYoaCl7cmV0dXJuIGgmJmguX19lc01vZHVsZT9oOntkZWZhdWx0Omh9fWUuZGVmYXVsdD1mdW5jdGlvbigpe2Z1bmN0aW9uIGgodSxhKXtmb3IodmFyIGQ9MDtkPGEubGVuZ3RoO2QrKyl7dmFyIEU9YVtkXTtFLmVudW1lcmFibGU9RS5lbnVtZXJhYmxlfHwhMSxFLmNvbmZpZ3VyYWJsZT0hMCwidmFsdWUiaW4gRSYmKEUud3JpdGFibGU9ITApLCgwLGkuZGVmYXVsdCkodSxFLmtleSxFKX19cmV0dXJuIGZ1bmN0aW9uKHUsYSxkKXtyZXR1cm4gYSYmaCh1LnByb3RvdHlwZSxhKSxkJiZoKHUsZCksdX19KCl9LGZ1bmN0aW9uKGcsZSx0KXtnLmV4cG9ydHM9e2RlZmF1bHQ6dCgxNzMpLF9fZXNNb2R1bGU6ITB9fSxmdW5jdGlvbihnLGUsdCl7dCgxNzQpO3ZhciBuPXQoOTIpLk9iamVjdDtnLmV4cG9ydHM9ZnVuY3Rpb24oZixoLHUpe3JldHVybiBuLmRlZmluZVByb3BlcnR5KGYsaCx1KX19LGZ1bmN0aW9uKGcsZSx0KXt2YXIgbj10KDkwKTtuKG4uUytuLkYqIXQoMTAwKSwiT2JqZWN0Iix7ZGVmaW5lUHJvcGVydHk6dCg5NikuZn0pfSxmdW5jdGlvbihnLGUsdCl7Zy5leHBvcnRzPXtkZWZhdWx0OnQoMTc2KSxfX2VzTW9kdWxlOiEwfX0sZnVuY3Rpb24oZyxlLHQpe3QoMTc3KSx0KDE0MyksdCgxODQpLHQoMTg1KSxnLmV4cG9ydHM9dCg5MikuU3ltYm9sfSxmdW5jdGlvbihnLGUsdCl7dmFyIG49dCg5MSksaT10KDEwNSksZj10KDEwMCksaD10KDkwKSx1PXQoMTA2KSxhPXQoMTUwKS5LRVksZD10KDEwMSksRT10KDExNykscD10KDEyMSksTz10KDExOCksbT10KDEyMiksYj10KDE3OCksTT10KDE3OSkseT10KDE4MCksUz10KDE1Nikscz10KDk3KSxjPXQoOTgpLGw9dCgxMjQpLHY9dCg4NCksVD10KDEwMyksUj10KDEwNCksTD10KDEwOCksTj10KDE4MSksQT10KDE4Myksdz10KDE2OCksQj10KDk2KSxEPXQoMTEwKSxJPUEuZixqPUIuZixWPU4uZixKPW4uU3ltYm9sLF89bi5KU09OLHN0PV8mJl8uc3RyaW5naWZ5LEc9InByb3RvdHlwZSIsWT1tKCJfaGlkZGVuIikscnQ9bSgidG9QcmltaXRpdmUiKSxvdD17fS5wcm9wZXJ0eUlzRW51bWVyYWJsZSxhdD1FKCJzeW1ib2wtcmVnaXN0cnkiKSxodD1FKCJzeW1ib2xzIiksaXQ9RSgib3Atc3ltYm9scyIpLE10PU9iamVjdFtHXSxPdD10eXBlb2YgSj09ImZ1bmN0aW9uIiYmISF3LmYsVT1uLlFPYmplY3QsJD0hVXx8IVVbR118fCFVW0ddLmZpbmRDaGlsZCxRPWYmJmQoZnVuY3Rpb24oKXtyZXR1cm4gTChqKHt9LCJhIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGoodGhpcywiYSIse3ZhbHVlOjd9KS5hfX0pKS5hIT03fSk/ZnVuY3Rpb24oZ3QsZHQsbXQpe3ZhciBidD1JKE10LGR0KTtidCYmZGVsZXRlIE10W2R0XSxqKGd0LGR0LG10KSxidCYmZ3QhPT1NdCYmaihNdCxkdCxidCl9OmosdHQ9ZnVuY3Rpb24oZ3Qpe3ZhciBkdD1odFtndF09TChKW0ddKTtyZXR1cm4gZHQuX2s9Z3QsZHR9LEY9T3QmJnR5cGVvZiBKLml0ZXJhdG9yPT0ic3ltYm9sIj9mdW5jdGlvbihndCl7cmV0dXJuIHR5cGVvZiBndD09InN5bWJvbCJ9OmZ1bmN0aW9uKGd0KXtyZXR1cm4gZ3QgaW5zdGFuY2VvZiBKfSxIPWZ1bmN0aW9uKGR0LG10LGJ0KXtyZXR1cm4gZHQ9PT1NdCYmSChpdCxtdCxidCkscyhkdCksbXQ9VChtdCwhMCkscyhidCksaShodCxtdCk/KGJ0LmVudW1lcmFibGU/KGkoZHQsWSkmJmR0W1ldW210XSYmKGR0W1ldW210XT0hMSksYnQ9TChidCx7ZW51bWVyYWJsZTpSKDAsITEpfSkpOihpKGR0LFkpfHxqKGR0LFksUigxLHt9KSksZHRbWV1bbXRdPSEwKSxRKGR0LG10LGJ0KSk6aihkdCxtdCxidCl9LHg9ZnVuY3Rpb24oZHQsbXQpe3MoZHQpO2Zvcih2YXIgYnQ9eShtdD12KG10KSksQ3Q9MCxTdD1idC5sZW5ndGgsTnQ7U3Q+Q3Q7KUgoZHQsTnQ9YnRbQ3QrK10sbXRbTnRdKTtyZXR1cm4gZHR9LFA9ZnVuY3Rpb24oZHQsbXQpe3JldHVybiBtdD09PXZvaWQgMD9MKGR0KTp4KEwoZHQpLG10KX0sVz1mdW5jdGlvbihkdCl7dmFyIG10PW90LmNhbGwodGhpcyxkdD1UKGR0LCEwKSk7cmV0dXJuIHRoaXM9PT1NdCYmaShodCxkdCkmJiFpKGl0LGR0KT8hMTptdHx8IWkodGhpcyxkdCl8fCFpKGh0LGR0KXx8aSh0aGlzLFkpJiZ0aGlzW1ldW2R0XT9tdDohMH0sSz1mdW5jdGlvbihkdCxtdCl7aWYoZHQ9dihkdCksbXQ9VChtdCwhMCksIShkdD09PU10JiZpKGh0LG10KSYmIWkoaXQsbXQpKSl7dmFyIGJ0PUkoZHQsbXQpO3JldHVybiBidCYmaShodCxtdCkmJiEoaShkdCxZKSYmZHRbWV1bbXRdKSYmKGJ0LmVudW1lcmFibGU9ITApLGJ0fX0sWj1mdW5jdGlvbihkdCl7Zm9yKHZhciBtdD1WKHYoZHQpKSxidD1bXSxDdD0wLFN0O210Lmxlbmd0aD5DdDspIWkoaHQsU3Q9bXRbQ3QrK10pJiZTdCE9WSYmU3QhPWEmJmJ0LnB1c2goU3QpO3JldHVybiBidH0saz1mdW5jdGlvbihkdCl7Zm9yKHZhciBtdD1kdD09PU10LGJ0PVYobXQ/aXQ6dihkdCkpLEN0PVtdLFN0PTAsTnQ7YnQubGVuZ3RoPlN0OylpKGh0LE50PWJ0W1N0KytdKSYmKCFtdHx8aShNdCxOdCkpJiZDdC5wdXNoKGh0W050XSk7cmV0dXJuIEN0fTtPdHx8KEo9ZnVuY3Rpb24oKXtpZih0aGlzIGluc3RhbmNlb2YgSil0aHJvdyBUeXBlRXJyb3IoIlN5bWJvbCBpcyBub3QgYSBjb25zdHJ1Y3RvciEiKTt2YXIgZHQ9Tyhhcmd1bWVudHMubGVuZ3RoPjA/YXJndW1lbnRzWzBdOnZvaWQgMCksbXQ9ZnVuY3Rpb24oYnQpe3RoaXM9PT1NdCYmbXQuY2FsbChpdCxidCksaSh0aGlzLFkpJiZpKHRoaXNbWV0sZHQpJiYodGhpc1tZXVtkdF09ITEpLFEodGhpcyxkdCxSKDEsYnQpKX07cmV0dXJuIGYmJiQmJlEoTXQsZHQse2NvbmZpZ3VyYWJsZTohMCxzZXQ6bXR9KSx0dChkdCl9LHUoSltHXSwidG9TdHJpbmciLGZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2t9KSxBLmY9SyxCLmY9SCx0KDE4MikuZj1OLmY9Wix0KDE2OSkuZj1XLHcuZj1rLGYmJiF0KDg5KSYmdShNdCwicHJvcGVydHlJc0VudW1lcmFibGUiLFcsITApLGIuZj1mdW5jdGlvbihndCl7cmV0dXJuIHR0KG0oZ3QpKX0pLGgoaC5HK2guVytoLkYqIU90LHtTeW1ib2w6Sn0pO2Zvcih2YXIgbnQ9Imhhc0luc3RhbmNlLGlzQ29uY2F0U3ByZWFkYWJsZSxpdGVyYXRvcixtYXRjaCxyZXBsYWNlLHNlYXJjaCxzcGVjaWVzLHNwbGl0LHRvUHJpbWl0aXZlLHRvU3RyaW5nVGFnLHVuc2NvcGFibGVzIi5zcGxpdCgiLCIpLHV0PTA7bnQubGVuZ3RoPnV0OyltKG50W3V0KytdKTtmb3IodmFyIGN0PUQobS5zdG9yZSkscHQ9MDtjdC5sZW5ndGg+cHQ7KU0oY3RbcHQrK10pO2goaC5TK2guRiohT3QsIlN5bWJvbCIse2ZvcjpmdW5jdGlvbihndCl7cmV0dXJuIGkoYXQsZ3QrPSIiKT9hdFtndF06YXRbZ3RdPUooZ3QpfSxrZXlGb3I6ZnVuY3Rpb24oZHQpe2lmKCFGKGR0KSl0aHJvdyBUeXBlRXJyb3IoZHQrIiBpcyBub3QgYSBzeW1ib2whIik7Zm9yKHZhciBtdCBpbiBhdClpZihhdFttdF09PT1kdClyZXR1cm4gbXR9LHVzZVNldHRlcjpmdW5jdGlvbigpeyQ9ITB9LHVzZVNpbXBsZTpmdW5jdGlvbigpeyQ9ITF9fSksaChoLlMraC5GKiFPdCwiT2JqZWN0Iix7Y3JlYXRlOlAsZGVmaW5lUHJvcGVydHk6SCxkZWZpbmVQcm9wZXJ0aWVzOngsZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOkssZ2V0T3duUHJvcGVydHlOYW1lczpaLGdldE93blByb3BlcnR5U3ltYm9sczprfSk7dmFyIHh0PWQoZnVuY3Rpb24oKXt3LmYoMSl9KTtoKGguUytoLkYqeHQsIk9iamVjdCIse2dldE93blByb3BlcnR5U3ltYm9sczpmdW5jdGlvbihkdCl7cmV0dXJuIHcuZihsKGR0KSl9fSksXyYmaChoLlMraC5GKighT3R8fGQoZnVuY3Rpb24oKXt2YXIgZ3Q9SigpO3JldHVybiBzdChbZ3RdKSE9IltudWxsXSJ8fHN0KHthOmd0fSkhPSJ7fSJ8fHN0KE9iamVjdChndCkpIT0ie30ifSkpLCJKU09OIix7c3RyaW5naWZ5OmZ1bmN0aW9uKGR0KXtmb3IodmFyIG10PVtkdF0sYnQ9MSxDdCxTdDthcmd1bWVudHMubGVuZ3RoPmJ0OyltdC5wdXNoKGFyZ3VtZW50c1tidCsrXSk7aWYoU3Q9Q3Q9bXRbMV0sISghYyhDdCkmJmR0PT09dm9pZCAwfHxGKGR0KSkpcmV0dXJuIFMoQ3QpfHwoQ3Q9ZnVuY3Rpb24oTnQsSnQpe2lmKHR5cGVvZiBTdD09ImZ1bmN0aW9uIiYmKEp0PVN0LmNhbGwodGhpcyxOdCxKdCkpLCFGKEp0KSlyZXR1cm4gSnR9KSxtdFsxXT1DdCxzdC5hcHBseShfLG10KX19KSxKW0ddW3J0XXx8dCg5NSkoSltHXSxydCxKW0ddLnZhbHVlT2YpLHAoSiwiU3ltYm9sIikscChNYXRoLCJNYXRoIiwhMCkscChuLkpTT04sIkpTT04iLCEwKX0sZnVuY3Rpb24oZyxlLHQpe2UuZj10KDEyMil9LGZ1bmN0aW9uKGcsZSx0KXt2YXIgbj10KDkxKSxpPXQoOTIpLGY9dCg4OSksaD10KDE3OCksdT10KDk2KS5mO2cuZXhwb3J0cz1mdW5jdGlvbihhKXt2YXIgZD1pLlN5bWJvbHx8KGkuU3ltYm9sPWY/e306bi5TeW1ib2x8fHt9KTthLmNoYXJBdCgwKSE9Il8iJiYhKGEgaW4gZCkmJnUoZCxhLHt2YWx1ZTpoLmYoYSl9KX19LGZ1bmN0aW9uKGcsZSx0KXt2YXIgbj10KDExMCksaT10KDE2OCksZj10KDE2OSk7Zy5leHBvcnRzPWZ1bmN0aW9uKGgpe3ZhciB1PW4oaCksYT1pLmY7aWYoYSlmb3IodmFyIGQ9YShoKSxFPWYuZixwPTAsTztkLmxlbmd0aD5wOylFLmNhbGwoaCxPPWRbcCsrXSkmJnUucHVzaChPKTtyZXR1cm4gdX19LGZ1bmN0aW9uKGcsZSx0KXt2YXIgbj10KDg0KSxpPXQoMTgyKS5mLGY9e30udG9TdHJpbmcsaD10eXBlb2Ygd2luZG93PT0ib2JqZWN0IiYmd2luZG93JiZPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcz9PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh3aW5kb3cpOltdLHU9ZnVuY3Rpb24oYSl7dHJ5e3JldHVybiBpKGEpfWNhdGNoe3JldHVybiBoLnNsaWNlKCl9fTtnLmV4cG9ydHMuZj1mdW5jdGlvbihkKXtyZXR1cm4gaCYmZi5jYWxsKGQpPT0iW29iamVjdCBXaW5kb3ddIj91KGQpOmkobihkKSl9fSxmdW5jdGlvbihnLGUsdCl7dmFyIG49dCgxMTEpLGk9dCgxMTkpLmNvbmNhdCgibGVuZ3RoIiwicHJvdG90eXBlIik7ZS5mPU9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzfHxmdW5jdGlvbihoKXtyZXR1cm4gbihoLGkpfX0sZnVuY3Rpb24oZyxlLHQpe3ZhciBuPXQoMTY5KSxpPXQoMTA0KSxmPXQoODQpLGg9dCgxMDMpLHU9dCgxMDUpLGE9dCg5OSksZD1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO2UuZj10KDEwMCk/ZDpmdW5jdGlvbihwLE8pe2lmKHA9ZihwKSxPPWgoTywhMCksYSl0cnl7cmV0dXJuIGQocCxPKX1jYXRjaHt9aWYodShwLE8pKXJldHVybiBpKCFuLmYuY2FsbChwLE8pLHBbT10pfX0sZnVuY3Rpb24oZyxlLHQpe3QoMTc5KSgiYXN5bmNJdGVyYXRvciIpfSxmdW5jdGlvbihnLGUsdCl7dCgxNzkpKCJvYnNlcnZhYmxlIil9LGZ1bmN0aW9uKGcsZSx0KXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksZS5jcmVhdGVOb3dUaW1lPW4sZS5mb3JtYXREZWxheT1pO2Z1bmN0aW9uIG4oKXt2YXIgZj1udWxsO3JldHVybiBEYXRlLm5vdz9mPURhdGUubm93OmY9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCl9LGZ9ZnVuY3Rpb24gaShmKXtyZXR1cm4gdHlwZW9mIGY9PSJudW1iZXIiP2Y9e2RlbGF5OmZ9OiJlbnRyb3B5ImluIGYmJihmPXtkZWxheTpmLmVudHJvcHksaXNFbnRyb3B5OiEwfSksZn19LGZ1bmN0aW9uKGcsZSx0KXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksZS5kZWZhdWx0PXtkZWZhdWx0OmZ1bmN0aW9uKGksZixoLHUsYSl7cmV0dXJuIHR5cGVvZiBpPT0ibnVtYmVyIiYmdHlwZW9mIGY9PSJudW1iZXIiP2krKGgtdSkvKGEtdSkqKGYtaSk6aC11PmEtaD9mOml9fX0sZnVuY3Rpb24oZyxlLHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxlLnBhcnNlRWFzaW5nPWUuRWFzaW5ncz12b2lkIDA7dmFyIG49dCg3NiksaT1kKG4pLGY9dCgxMzMpLGg9ZChmKSx1PXQoMTQxKSxhPWQodSk7ZnVuY3Rpb24gZChTKXtyZXR1cm4gUyYmUy5fX2VzTW9kdWxlP1M6e2RlZmF1bHQ6U319dmFyIEU9dCgxODkpLHA9bmV3IGEuZGVmYXVsdDtmdW5jdGlvbiBPKCl7Zm9yKHZhciBTPWFyZ3VtZW50cy5sZW5ndGgscz1BcnJheShTKSxjPTA7YzxTO2MrKylzW2NdPWFyZ3VtZW50c1tjXTt2YXIgbD1wLmdldChzKTtyZXR1cm4gbHx8KGw9RS5hcHBseSh2b2lkIDAscykscC5zZXQocyxsKSxsKX1mdW5jdGlvbiBtKFMpe3ZhciBzPWFyZ3VtZW50cy5sZW5ndGg+MSYmYXJndW1lbnRzWzFdIT09dm9pZCAwP2FyZ3VtZW50c1sxXToiZW5kIjtyZXR1cm4gZnVuY3Rpb24oYyxsKXtmb3IodmFyIHY9MTt2PGwubGVuZ3RoO3YrKyl7dmFyIFQ9bFt2XS5vZmZzZXQ7aWYoYzw9VCl7dmFyIFI9bFt2LTFdLm9mZnNldCxMPVQsTj0oYy1SKS8oTC1SKSxBPTEvUyx3PU4vQTtyZXR1cm4gcz09PSJlbmQiP3c9TWF0aC5mbG9vcih3KTp3PU1hdGguY2VpbCh3KSxBKncqKEwtUikrUn19cmV0dXJuIDB9fWZ1bmN0aW9uIGIoUyl7dmFyIHM9L15jdWJpYy1iZXppZXJcKCguKilcKS8sYz1TLm1hdGNoKHMpO2lmKGMpe3ZhciBsPWNbMV0udHJpbSgpO3JldHVybiBsPWwuc3BsaXQoIiwiKS5tYXAoZnVuY3Rpb24oQSl7cmV0dXJuIHBhcnNlRmxvYXQoQS50cmltKCkpfSksTy5hcHBseSh2b2lkIDAsKDAsaC5kZWZhdWx0KShsKSl9aWYocz0vXnN0ZXBzXCgoLiopXCkvLGM9Uy5tYXRjaChzKSxjKXt2YXIgdj1jWzFdLnRyaW0oKTt2PXYuc3BsaXQoIiwiKS5tYXAoZnVuY3Rpb24oQSl7cmV0dXJuIEEudHJpbSgpfSk7dmFyIFQ9dixSPSgwLGkuZGVmYXVsdCkoVCwyKSxMPVJbMF0sTj1SWzFdO3JldHVybiBtKHBhcnNlSW50KEwsMTApLE4pfXJldHVybiBTfXZhciBNPXtsaW5lYXI6ZnVuY3Rpb24ocyl7cmV0dXJuIHN9LGVhc2U6TyguMjUsLjEsLjI1LDEpLCJlYXNlLWluIjpPKC40MiwwLDEsMSksImVhc2Utb3V0IjpPKDAsMCwuNTgsMSksImVhc2UtaW4tb3V0IjpPKC40MiwwLC41OCwxKSwic3RlcC1zdGFydCI6bSgxLCJzdGFydCIpLCJzdGVwLWVuZCI6bSgxLCJlbmQiKX07ZnVuY3Rpb24geShTKXtyZXR1cm4gdHlwZW9mIFM9PSJzdHJpbmciP01bU10/Uz1NW1NdOlM9YihTKTpTLnR5cGU9PT0iY3ViaWMtYmV6aWVyIj9TPU8uYXBwbHkodm9pZCAwLCgwLGguZGVmYXVsdCkoUy52YWx1ZSkpOlMudHlwZT09PSJzdGVwcyImJihTPW0oUy5zdGVwLFMucG9zKSksU31lLkVhc2luZ3M9TSxlLnBhcnNlRWFzaW5nPXl9LGZ1bmN0aW9uKGcsZSl7dmFyIHQ9NCxuPS4wMDEsaT0xZS03LGY9MTAsaD0xMSx1PTEvKGgtMSksYT10eXBlb2YgRmxvYXQzMkFycmF5PT0iZnVuY3Rpb24iO2Z1bmN0aW9uIGQoUyxzKXtyZXR1cm4gMS0zKnMrMypTfWZ1bmN0aW9uIEUoUyxzKXtyZXR1cm4gMypzLTYqU31mdW5jdGlvbiBwKFMpe3JldHVybiAzKlN9ZnVuY3Rpb24gTyhTLHMsYyl7cmV0dXJuKChkKHMsYykqUytFKHMsYykpKlMrcChzKSkqU31mdW5jdGlvbiBtKFMscyxjKXtyZXR1cm4gMypkKHMsYykqUypTKzIqRShzLGMpKlMrcChzKX1mdW5jdGlvbiBiKFMscyxjLGwsdil7dmFyIFQsUixMPTA7ZG8gUj1zKyhjLXMpLzIsVD1PKFIsbCx2KS1TLFQ+MD9jPVI6cz1SO3doaWxlKE1hdGguYWJzKFQpPmkmJisrTDxmKTtyZXR1cm4gUn1mdW5jdGlvbiBNKFMscyxjLGwpe2Zvcih2YXIgdj0wO3Y8dDsrK3Ype3ZhciBUPW0ocyxjLGwpO2lmKFQ9PT0wKXJldHVybiBzO3ZhciBSPU8ocyxjLGwpLVM7cy09Ui9UfXJldHVybiBzfWZ1bmN0aW9uIHkoUyl7cmV0dXJuIFN9Zy5leHBvcnRzPWZ1bmN0aW9uKHMsYyxsLHYpe2lmKCEoMDw9cyYmczw9MSYmMDw9bCYmbDw9MSkpdGhyb3cgbmV3IEVycm9yKCJiZXppZXIgeCB2YWx1ZXMgbXVzdCBiZSBpbiBbMCwgMV0gcmFuZ2UiKTtpZihzPT09YyYmbD09PXYpcmV0dXJuIHk7Zm9yKHZhciBUPWE/bmV3IEZsb2F0MzJBcnJheShoKTpuZXcgQXJyYXkoaCksUj0wO1I8aDsrK1IpVFtSXT1PKFIqdSxzLGwpO2Z1bmN0aW9uIEwoTil7Zm9yKHZhciBBPTAsdz0xLEI9aC0xO3chPT1CJiZUW3ddPD1OOysrdylBKz11Oy0tdzt2YXIgRD0oTi1UW3ddKS8oVFt3KzFdLVRbd10pLEk9QStEKnUsaj1tKEkscyxsKTtyZXR1cm4gaj49bj9NKE4sSSxzLGwpOmo9PT0wP0k6YihOLEEsQSt1LHMsbCl9cmV0dXJuIGZ1bmN0aW9uKEEpe3JldHVybiBBPT09MD8wOkE9PT0xPzE6TyhMKEEpLGMsdil9fX0sZnVuY3Rpb24oZyxlLHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KTt2YXIgbj10KDE5MSksaT1jKG4pLGY9dCgyMDQpLGg9YyhmKSx1PXQoMTY0KSxhPWModSksZD10KDE3MCksRT1jKGQpLHA9dCgxNzEpLE89YyhwKSxtPXQoMTc1KSxiPWMobSksTT10KDc1KSx5PWMoTSksUz10KDIwOCkscz10KDE4OCk7ZnVuY3Rpb24gYyhqKXtyZXR1cm4gaiYmai5fX2VzTW9kdWxlP2o6e2RlZmF1bHQ6an19dmFyIGw9KDAsYi5kZWZhdWx0KSgidGltaW5nIiksdj0oMCxiLmRlZmF1bHQpKCJrZXlmcmFtZXMiKSxUPSgwLGIuZGVmYXVsdCkoImluaXRTdGF0ZSIpLFI9KDAsYi5kZWZhdWx0KSgicmVhZHlEZWZlciIpLEw9KDAsYi5kZWZhdWx0KSgiZmluaXNoZWREZWZlciIpLE49KDAsYi5kZWZhdWx0KSgiZWZmZWN0cyIpLEE9KDAsYi5kZWZhdWx0KSgiYWN0aXZlUmVhZHlUaW1lciIpLHc9KDAsYi5kZWZhdWx0KSgiYWN0aXZlRmluaXNoVGltZXIiKSxCPSgwLGIuZGVmYXVsdCkoInJlbW92ZURlZmVyIiksRD17ZGVsYXk6MCxlbmREZWxheTowLGZpbGw6ImF1dG8iLGl0ZXJhdGlvbnM6MSxwbGF5YmFja1JhdGU6MSxkaXJlY3Rpb246Im5vcm1hbCIsZWFzaW5nOiJsaW5lYXIiLGVmZmVjdDpudWxsfSxJPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gaihWLEosXyl7dmFyIHN0PXRoaXM7aWYoKDAsRS5kZWZhdWx0KSh0aGlzLGopLEFycmF5LmlzQXJyYXkoVikpe3ZhciBHPVtWWzBdLFYsSl07Vj1HWzBdLEo9R1sxXSxfPUdbMl19dHlwZW9mIF89PSJudW1iZXIiJiYoXz17ZHVyYXRpb246X30pLHRoaXNbbF09KDAsYS5kZWZhdWx0KSh7fSxELF8pLHRoaXNbbF0uZWFzaW5nPSgwLHMucGFyc2VFYXNpbmcpKHRoaXNbbF0uZWFzaW5nKSx0aGlzW3ZdPSgwLFMuY2FsY3VsYXRlRnJhbWVzT2Zmc2V0KShKKTt2YXIgWT10aGlzW3ZdW3RoaXNbdl0ubGVuZ3RoLTFdO3RoaXNbVF09e30sKDAsaC5kZWZhdWx0KShZKS5mb3JFYWNoKGZ1bmN0aW9uKHJ0KXtPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoVixydCkmJnJ0IT09ImVhc2luZyImJnJ0IT09Im9mZnNldCImJihzdFtUXVtydF09VltydF0pfSksdGhpc1t2XT10aGlzW3ZdLm1hcChmdW5jdGlvbihydCl7cmV0dXJuKDAsYS5kZWZhdWx0KSh7fSxzdFtUXSxydCl9KSx0aGlzW3ZdWzBdLm9mZnNldCE9PTAmJnRoaXNbdl0udW5zaGlmdCgoMCxhLmRlZmF1bHQpKHt9LHRoaXNbVF0se29mZnNldDowfSkpLFkub2Zmc2V0PDEmJnRoaXNbdl0ucHVzaCgoMCxhLmRlZmF1bHQpKHt9LFkse29mZnNldDoxfSkpLHRoaXNbTl09e30sdGhpcy50aW1lbGluZT1udWxsfXJldHVybigwLE8uZGVmYXVsdCkoaixbe2tleToicGF1c2UiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy50aW1lbGluZS5wbGF5YmFja1JhdGU9MH19LHtrZXk6QSx2YWx1ZTpmdW5jdGlvbigpe3ZhciBKPXRoaXM7dGhpc1tSXSYmIXRoaXNbUl0udGltZXJJRCYmKHRoaXMudGltZWxpbmUuY3VycmVudFRpbWU8MD90aGlzW1JdLnRpbWVySUQ9dGhpcy50aW1lbGluZS5zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7SltSXS5yZXNvbHZlKCksZGVsZXRlIEpbUl19LHtkZWxheTotdGhpcy50aW1lbGluZS5jdXJyZW50VGltZSxoZWFkaW5nOiExfSk6dGhpc1tSXS50aW1lcklEPXRoaXMudGltZWxpbmUuc2V0VGltZW91dChmdW5jdGlvbigpe0pbUl0ucmVzb2x2ZSgpLGRlbGV0ZSBKW1JdfSx7ZGVsYXk6MCxpc0VudHJvcHk6ITB9KSl9fSx7a2V5OncsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgSj10aGlzLF89dGhpc1tsXSxzdD1fLmR1cmF0aW9uLEc9Xy5pdGVyYXRpb25zLFk9Xy5lbmREZWxheSxydD1NYXRoLmNlaWwoc3QqRytZLXRoaXMudGltZWxpbmUuY3VycmVudFRpbWUpKzE7dGhpc1tMXSYmIXRoaXNbTF0udGltZXJJRCYmKHRoaXNbTF0udGltZXJJRD10aGlzLnRpbWVsaW5lLnNldFRpbWVvdXQoZnVuY3Rpb24oKXtKW0xdLnJlc29sdmUoKSxKW0JdKFIpLEpbQl0oTCl9LHtkZWxheTpydCxoZWFkaW5nOiExfSksdGhpc1tMXS5yZXZlcnNlVGltZXJJRD10aGlzLnRpbWVsaW5lLnNldFRpbWVvdXQoZnVuY3Rpb24oKXtKW0xdLnJlc29sdmUoKSxKW0JdKFIpLEpbQl0oTCksSi50aW1lbGluZT1udWxsfSx7ZGVsYXk6LXRoaXNbbF0uZGVsYXktMSxoZWFkaW5nOiExfSkpfX0se2tleToicGxheSIsdmFsdWU6ZnVuY3Rpb24oKXtpZih0aGlzLnBsYXlTdGF0ZT09PSJmaW5pc2hlZCImJnRoaXMuY2FuY2VsKCksdGhpcy5wbGF5U3RhdGU9PT0iaWRsZSIpe2lmKHRoaXMucGxheWJhY2tSYXRlPD0wKXJldHVybjt2YXIgSj10aGlzW2xdLF89Si5kZWxheSxzdD1KLnBsYXliYWNrUmF0ZSxHPUoudGltZWxpbmU7dGhpcy50aW1lbGluZT1uZXcgeS5kZWZhdWx0KHtvcmlnaW5UaW1lOl8scGxheWJhY2tSYXRlOnN0fSxHKSx0aGlzW0FdKCksdGhpc1t3XSgpfWVsc2UgdGhpcy5wbGF5U3RhdGU9PT0icGF1c2VkIiYmKHRoaXMudGltZWxpbmUucGxheWJhY2tSYXRlPXRoaXMucGxheWJhY2tSYXRlLHRoaXNbQV0oKSl9fSx7a2V5OkIsdmFsdWU6ZnVuY3Rpb24oSil7dmFyIF89dGhpc1tKXSxzdD10aGlzLnRpbWVsaW5lO18mJnN0JiYoc3QuY2xlYXJUaW1lb3V0KF8udGltZXJJRCksXy5yZXZlcnNlVGltZXJJRCYmc3QuY2xlYXJUaW1lb3V0KF8ucmV2ZXJzZVRpbWVySUQpKSxkZWxldGUgdGhpc1tKXX19LHtrZXk6ImNhbmNlbCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzW0JdKFIpLHRoaXNbQl0oTCksdGhpcy50aW1lbGluZT1udWxsfX0se2tleToiZmluaXNoIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMudGltZWxpbmUmJih0aGlzLnRpbWVsaW5lLmN1cnJlbnRUaW1lPTEvMC90aGlzLnBsYXliYWNrUmF0ZSksdGhpc1tCXShSKSx0aGlzW0JdKEwpfX0se2tleToiYXBwbHlFZmZlY3RzIix2YWx1ZTpmdW5jdGlvbihKKXtyZXR1cm4oMCxhLmRlZmF1bHQpKHRoaXNbTl0sSil9fSx7a2V5OiJwbGF5YmFja1JhdGUiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzW2xdLnBsYXliYWNrUmF0ZX0sc2V0OmZ1bmN0aW9uKEope3RoaXMudGltZWxpbmUmJih0aGlzLnRpbWVsaW5lLnBsYXliYWNrUmF0ZT1KKSx0aGlzW2xdLnBsYXliYWNrUmF0ZT1KfX0se2tleToicGxheVN0YXRlIixnZXQ6ZnVuY3Rpb24oKXt2YXIgSj10aGlzLnRpbWVsaW5lLF89dGhpc1tsXSxzdD1fLml0ZXJhdGlvbnMsRz1fLmR1cmF0aW9uLFk9Xy5lbmREZWxheSxydD0icnVubmluZyI7aWYoSj09bnVsbClydD0iaWRsZSI7ZWxzZSBpZihKLnBhdXNlZClydD0icGF1c2VkIjtlbHNlIGlmKEouY3VycmVudFRpbWU8MClydD0icGVuZGluZyI7ZWxzZXt2YXIgb3Q9Si5jdXJyZW50VGltZS1zdCpHO290PjAmJm90PFk/cnQ9InBlbmRpbmciOm90Pj1ZJiYocnQ9ImZpbmlzaGVkIil9cmV0dXJuIHJ0fX0se2tleToicHJvZ3Jlc3MiLGdldDpmdW5jdGlvbigpe2lmKCF0aGlzLnRpbWVsaW5lKXJldHVybiAwO3ZhciBKPXRoaXNbbF0sXz1KLmR1cmF0aW9uLHN0PUouaXRlcmF0aW9ucyxHPXRoaXMudGltZWxpbmUsWT10aGlzLnBsYXlTdGF0ZSxydD12b2lkIDA7aWYoWT09PSJpZGxlIilydD0wO2Vsc2UgaWYoWT09PSJwYXVzZWQiJiZHLmN1cnJlbnRUaW1lPDApcnQ9MDtlbHNlIGlmKFk9PT0icGVuZGluZyIpaWYoRy5jdXJyZW50VGltZTwwKXJ0PTA7ZWxzZXt2YXIgb3Q9Ry5zZWVrTG9jYWxUaW1lKHN0Kl8pO3J0PSgwLFMucGVyaW9kaWNpdHkpKG90LF8pWzFdL199ZWxzZShZPT09InJ1bm5pbmcifHxZPT09InBhdXNlZCIpJiYocnQ9KDAsUy5wZXJpb2RpY2l0eSkoRy5jdXJyZW50VGltZSxfKVsxXS9fKTtyZXR1cm4gWT09PSJmaW5pc2hlZCImJihydD0oMCxTLnBlcmlvZGljaXR5KShzdCwxKVsxXSkscnR9fSx7a2V5OiJmcmFtZSIsZ2V0OmZ1bmN0aW9uKCl7dmFyIEo9dGhpcy5wbGF5U3RhdGUsXz10aGlzW1RdLHN0PXRoaXNbbF0uZmlsbDtpZihKPT09ImlkbGUiKXJldHVybiBfO3ZhciBHPXRoaXMudGltZWxpbmUuY3VycmVudFRpbWUsWT10aGlzW3ZdLnNsaWNlKDApLHJ0PSgwLFMuZ2V0UHJvZ3Jlc3MpKHRoaXMudGltZWxpbmUsdGhpc1tsXSx0aGlzLnByb2dyZXNzKSxvdD1ydC5wLGF0PXJ0LmludmVydGVkLGh0PV87cmV0dXJuIEc8MCYmSj09PSJwZW5kaW5nIj8oc3Q9PT0iYmFja3dhcmRzInx8c3Q9PT0iYm90aCIpJiYoaHQ9YXQ/WVtZLmxlbmd0aC0xXTpZWzBdKTooSiE9PSJwZW5kaW5nIiYmSiE9PSJmaW5pc2hlZCJ8fHN0PT09ImZvcndhcmRzInx8c3Q9PT0iYm90aCIpJiYoaHQ9KDAsUy5nZXRDdXJyZW50RnJhbWUpKHRoaXNbbF0sWSx0aGlzW05dLG90KSksaHR9fSx7a2V5OiJ0aW1pbmciLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzW2xdfX0se2tleToiZWZmZWN0cyIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXNbTl19fSx7a2V5OiJiYXNlVGltZWxpbmUiLHNldDpmdW5jdGlvbihKKXt0aGlzW2xdLnRpbWVsaW5lPUp9LGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzW2xdLnRpbWVsaW5lfX0se2tleToicmVhZHkiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzW1JdP3RoaXNbUl0ucHJvbWlzZTp0aGlzLnRpbWVsaW5lJiZ0aGlzLnRpbWVsaW5lLmN1cnJlbnRUaW1lPj0wJiZ0aGlzLnBsYXlTdGF0ZSE9PSJwYXVzZWQiP2kuZGVmYXVsdC5yZXNvbHZlKCk6KHRoaXNbUl09KDAsUy5kZWZlcikoKSx0aGlzLnRpbWVsaW5lJiZ0aGlzW0FdKCksdGhpc1tSXT90aGlzW1JdLnByb21pc2U6aS5kZWZhdWx0LnJlc29sdmUoKSl9fSx7a2V5OiJmaW5pc2hlZCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucGxheVN0YXRlPT09ImZpbmlzaGVkIj9pLmRlZmF1bHQucmVzb2x2ZSgpOih0aGlzW0xdfHwodGhpc1tMXT0oMCxTLmRlZmVyKSgpLHRoaXMudGltZWxpbmUmJnRoaXNbd10oKSksdGhpc1tMXS5wcm9taXNlKX19XSksan0oKTtlLmRlZmF1bHQ9SX0sZnVuY3Rpb24oZyxlLHQpe2cuZXhwb3J0cz17ZGVmYXVsdDp0KDE5MiksX19lc01vZHVsZTohMH19LGZ1bmN0aW9uKGcsZSx0KXt0KDE0MyksdCgxMjUpLHQoNzkpLHQoMTkzKSx0KDIwMiksdCgyMDMpLGcuZXhwb3J0cz10KDkyKS5Qcm9taXNlfSxmdW5jdGlvbihnLGUsdCl7dmFyIG49dCg4OSksaT10KDkxKSxmPXQoOTMpLGg9dCgxMjgpLHU9dCg5MCksYT10KDk4KSxkPXQoOTQpLEU9dCgxNDcpLHA9dCgxNDgpLE89dCgxOTQpLG09dCgxOTUpLnNldCxiPXQoMTk3KSgpLE09dCgxOTgpLHk9dCgxOTkpLFM9dCgyMDApLHM9dCgyMDEpLGM9IlByb21pc2UiLGw9aS5UeXBlRXJyb3Isdj1pLnByb2Nlc3MsVD12JiZ2LnZlcnNpb25zLFI9VCYmVC52OHx8IiIsTD1pW2NdLE49aCh2KT09InByb2Nlc3MiLEE9ZnVuY3Rpb24oKXt9LHcsQixELEksaj1CPU0uZixWPSEhZnVuY3Rpb24oKXt0cnl7dmFyIGF0PUwucmVzb2x2ZSgxKSxodD0oYXQuY29uc3RydWN0b3I9e30pW3QoMTIyKSgic3BlY2llcyIpXT1mdW5jdGlvbihpdCl7aXQoQSxBKX07cmV0dXJuKE58fHR5cGVvZiBQcm9taXNlUmVqZWN0aW9uRXZlbnQ9PSJmdW5jdGlvbiIpJiZhdC50aGVuKEEpaW5zdGFuY2VvZiBodCYmUi5pbmRleE9mKCI2LjYiKSE9PTAmJlMuaW5kZXhPZigiQ2hyb21lLzY2Iik9PT0tMX1jYXRjaHt9fSgpLEo9ZnVuY3Rpb24oYXQpe3ZhciBodDtyZXR1cm4gYShhdCkmJnR5cGVvZihodD1hdC50aGVuKT09ImZ1bmN0aW9uIj9odDohMX0sXz1mdW5jdGlvbihhdCxodCl7aWYoIWF0Ll9uKXthdC5fbj0hMDt2YXIgaXQ9YXQuX2M7YihmdW5jdGlvbigpe2Zvcih2YXIgTXQ9YXQuX3YsT3Q9YXQuX3M9PTEsVT0wLCQ9ZnVuY3Rpb24oUSl7dmFyIHR0PU90P1Eub2s6US5mYWlsLEY9US5yZXNvbHZlLEg9US5yZWplY3QseD1RLmRvbWFpbixQLFcsSzt0cnl7dHQ/KE90fHwoYXQuX2g9PTImJlkoYXQpLGF0Ll9oPTEpLHR0PT09ITA/UD1NdDooeCYmeC5lbnRlcigpLFA9dHQoTXQpLHgmJih4LmV4aXQoKSxLPSEwKSksUD09PVEucHJvbWlzZT9IKGwoIlByb21pc2UtY2hhaW4gY3ljbGUiKSk6KFc9SihQKSk/Vy5jYWxsKFAsRixIKTpGKFApKTpIKE10KX1jYXRjaChaKXt4JiYhSyYmeC5leGl0KCksSChaKX19O2l0Lmxlbmd0aD5VOykkKGl0W1UrK10pO2F0Ll9jPVtdLGF0Ll9uPSExLGh0JiYhYXQuX2gmJnN0KGF0KX0pfX0sc3Q9ZnVuY3Rpb24oYXQpe20uY2FsbChpLGZ1bmN0aW9uKCl7dmFyIGh0PWF0Ll92LGl0PUcoYXQpLE10LE90LFU7aWYoaXQmJihNdD15KGZ1bmN0aW9uKCl7Tj92LmVtaXQoInVuaGFuZGxlZFJlamVjdGlvbiIsaHQsYXQpOihPdD1pLm9udW5oYW5kbGVkcmVqZWN0aW9uKT9PdCh7cHJvbWlzZTphdCxyZWFzb246aHR9KTooVT1pLmNvbnNvbGUpJiZVLmVycm9yJiZVLmVycm9yKCJVbmhhbmRsZWQgcHJvbWlzZSByZWplY3Rpb24iLGh0KX0pLGF0Ll9oPU58fEcoYXQpPzI6MSksYXQuX2E9dm9pZCAwLGl0JiZNdC5lKXRocm93IE10LnZ9KX0sRz1mdW5jdGlvbihhdCl7cmV0dXJuIGF0Ll9oIT09MSYmKGF0Ll9hfHxhdC5fYykubGVuZ3RoPT09MH0sWT1mdW5jdGlvbihhdCl7bS5jYWxsKGksZnVuY3Rpb24oKXt2YXIgaHQ7Tj92LmVtaXQoInJlamVjdGlvbkhhbmRsZWQiLGF0KTooaHQ9aS5vbnJlamVjdGlvbmhhbmRsZWQpJiZodCh7cHJvbWlzZTphdCxyZWFzb246YXQuX3Z9KX0pfSxydD1mdW5jdGlvbihhdCl7dmFyIGh0PXRoaXM7aHQuX2R8fChodC5fZD0hMCxodD1odC5fd3x8aHQsaHQuX3Y9YXQsaHQuX3M9MixodC5fYXx8KGh0Ll9hPWh0Ll9jLnNsaWNlKCkpLF8oaHQsITApKX0sb3Q9ZnVuY3Rpb24oYXQpe3ZhciBodD10aGlzLGl0O2lmKCFodC5fZCl7aHQuX2Q9ITAsaHQ9aHQuX3d8fGh0O3RyeXtpZihodD09PWF0KXRocm93IGwoIlByb21pc2UgY2FuJ3QgYmUgcmVzb2x2ZWQgaXRzZWxmIik7KGl0PUooYXQpKT9iKGZ1bmN0aW9uKCl7dmFyIE10PXtfdzpodCxfZDohMX07dHJ5e2l0LmNhbGwoYXQsZihvdCxNdCwxKSxmKHJ0LE10LDEpKX1jYXRjaChPdCl7cnQuY2FsbChNdCxPdCl9fSk6KGh0Ll92PWF0LGh0Ll9zPTEsXyhodCwhMSkpfWNhdGNoKE10KXtydC5jYWxsKHtfdzpodCxfZDohMX0sTXQpfX19O1Z8fChMPWZ1bmN0aW9uKGh0KXtFKHRoaXMsTCxjLCJfaCIpLGQoaHQpLHcuY2FsbCh0aGlzKTt0cnl7aHQoZihvdCx0aGlzLDEpLGYocnQsdGhpcywxKSl9Y2F0Y2goaXQpe3J0LmNhbGwodGhpcyxpdCl9fSx3PWZ1bmN0aW9uKGh0KXt0aGlzLl9jPVtdLHRoaXMuX2E9dm9pZCAwLHRoaXMuX3M9MCx0aGlzLl9kPSExLHRoaXMuX3Y9dm9pZCAwLHRoaXMuX2g9MCx0aGlzLl9uPSExfSx3LnByb3RvdHlwZT10KDE0NikoTC5wcm90b3R5cGUse3RoZW46ZnVuY3Rpb24oaHQsaXQpe3ZhciBNdD1qKE8odGhpcyxMKSk7cmV0dXJuIE10Lm9rPXR5cGVvZiBodD09ImZ1bmN0aW9uIj9odDohMCxNdC5mYWlsPXR5cGVvZiBpdD09ImZ1bmN0aW9uIiYmaXQsTXQuZG9tYWluPU4/di5kb21haW46dm9pZCAwLHRoaXMuX2MucHVzaChNdCksdGhpcy5fYSYmdGhpcy5fYS5wdXNoKE10KSx0aGlzLl9zJiZfKHRoaXMsITEpLE10LnByb21pc2V9LGNhdGNoOmZ1bmN0aW9uKGF0KXtyZXR1cm4gdGhpcy50aGVuKHZvaWQgMCxhdCl9fSksRD1mdW5jdGlvbigpe3ZhciBhdD1uZXcgdzt0aGlzLnByb21pc2U9YXQsdGhpcy5yZXNvbHZlPWYob3QsYXQsMSksdGhpcy5yZWplY3Q9ZihydCxhdCwxKX0sTS5mPWo9ZnVuY3Rpb24oYXQpe3JldHVybiBhdD09PUx8fGF0PT09ST9uZXcgRChhdCk6QihhdCl9KSx1KHUuRyt1LlcrdS5GKiFWLHtQcm9taXNlOkx9KSx0KDEyMSkoTCxjKSx0KDE0OSkoYyksST10KDkyKVtjXSx1KHUuUyt1LkYqIVYsYyx7cmVqZWN0OmZ1bmN0aW9uKGh0KXt2YXIgaXQ9aih0aGlzKSxNdD1pdC5yZWplY3Q7cmV0dXJuIE10KGh0KSxpdC5wcm9taXNlfX0pLHUodS5TK3UuRioobnx8IVYpLGMse3Jlc29sdmU6ZnVuY3Rpb24oaHQpe3JldHVybiBzKG4mJnRoaXM9PT1JP0w6dGhpcyxodCl9fSksdSh1LlMrdS5GKiEoViYmdCgxNDApKGZ1bmN0aW9uKGF0KXtMLmFsbChhdCkuY2F0Y2goQSl9KSksYyx7YWxsOmZ1bmN0aW9uKGh0KXt2YXIgaXQ9dGhpcyxNdD1qKGl0KSxPdD1NdC5yZXNvbHZlLFU9TXQucmVqZWN0LCQ9eShmdW5jdGlvbigpe3ZhciBRPVtdLHR0PTAsRj0xO3AoaHQsITEsZnVuY3Rpb24oSCl7dmFyIHg9dHQrKyxQPSExO1EucHVzaCh2b2lkIDApLEYrKyxpdC5yZXNvbHZlKEgpLnRoZW4oZnVuY3Rpb24oVyl7UHx8KFA9ITAsUVt4XT1XLC0tRnx8T3QoUSkpfSxVKX0pLC0tRnx8T3QoUSl9KTtyZXR1cm4gJC5lJiZVKCQudiksTXQucHJvbWlzZX0scmFjZTpmdW5jdGlvbihodCl7dmFyIGl0PXRoaXMsTXQ9aihpdCksT3Q9TXQucmVqZWN0LFU9eShmdW5jdGlvbigpe3AoaHQsITEsZnVuY3Rpb24oJCl7aXQucmVzb2x2ZSgkKS50aGVuKE10LnJlc29sdmUsT3QpfSl9KTtyZXR1cm4gVS5lJiZPdChVLnYpLE10LnByb21pc2V9fSl9LGZ1bmN0aW9uKGcsZSx0KXt2YXIgbj10KDk3KSxpPXQoOTQpLGY9dCgxMjIpKCJzcGVjaWVzIik7Zy5leHBvcnRzPWZ1bmN0aW9uKGgsdSl7dmFyIGE9bihoKS5jb25zdHJ1Y3RvcixkO3JldHVybiBhPT09dm9pZCAwfHwoZD1uKGEpW2ZdKT09bnVsbD91OmkoZCl9fSxmdW5jdGlvbihnLGUsdCl7dmFyIG49dCg5MyksaT10KDE5NiksZj10KDEyMCksaD10KDEwMiksdT10KDkxKSxhPXUucHJvY2VzcyxkPXUuc2V0SW1tZWRpYXRlLEU9dS5jbGVhckltbWVkaWF0ZSxwPXUuTWVzc2FnZUNoYW5uZWwsTz11LkRpc3BhdGNoLG09MCxiPXt9LE09Im9ucmVhZHlzdGF0ZWNoYW5nZSIseSxTLHMsYz1mdW5jdGlvbigpe3ZhciB2PSt0aGlzO2lmKGIuaGFzT3duUHJvcGVydHkodikpe3ZhciBUPWJbdl07ZGVsZXRlIGJbdl0sVCgpfX0sbD1mdW5jdGlvbih2KXtjLmNhbGwodi5kYXRhKX07KCFkfHwhRSkmJihkPWZ1bmN0aW9uKFQpe2Zvcih2YXIgUj1bXSxMPTE7YXJndW1lbnRzLmxlbmd0aD5MOylSLnB1c2goYXJndW1lbnRzW0wrK10pO3JldHVybiBiWysrbV09ZnVuY3Rpb24oKXtpKHR5cGVvZiBUPT0iZnVuY3Rpb24iP1Q6RnVuY3Rpb24oVCksUil9LHkobSksbX0sRT1mdW5jdGlvbihUKXtkZWxldGUgYltUXX0sdCg4NikoYSk9PSJwcm9jZXNzIj95PWZ1bmN0aW9uKHYpe2EubmV4dFRpY2sobihjLHYsMSkpfTpPJiZPLm5vdz95PWZ1bmN0aW9uKHYpe08ubm93KG4oYyx2LDEpKX06cD8oUz1uZXcgcCxzPVMucG9ydDIsUy5wb3J0MS5vbm1lc3NhZ2U9bCx5PW4ocy5wb3N0TWVzc2FnZSxzLDEpKTp1LmFkZEV2ZW50TGlzdGVuZXImJnR5cGVvZiBwb3N0TWVzc2FnZT09ImZ1bmN0aW9uIiYmIXUuaW1wb3J0U2NyaXB0cz8oeT1mdW5jdGlvbih2KXt1LnBvc3RNZXNzYWdlKHYrIiIsIioiKX0sdS5hZGRFdmVudExpc3RlbmVyKCJtZXNzYWdlIixsLCExKSk6TSBpbiBoKCJzY3JpcHQiKT95PWZ1bmN0aW9uKHYpe2YuYXBwZW5kQ2hpbGQoaCgic2NyaXB0IikpW01dPWZ1bmN0aW9uKCl7Zi5yZW1vdmVDaGlsZCh0aGlzKSxjLmNhbGwodil9fTp5PWZ1bmN0aW9uKHYpe3NldFRpbWVvdXQobihjLHYsMSksMCl9KSxnLmV4cG9ydHM9e3NldDpkLGNsZWFyOkV9fSxmdW5jdGlvbihnLGUpe2cuZXhwb3J0cz1mdW5jdGlvbih0LG4saSl7dmFyIGY9aT09PXZvaWQgMDtzd2l0Y2gobi5sZW5ndGgpe2Nhc2UgMDpyZXR1cm4gZj90KCk6dC5jYWxsKGkpO2Nhc2UgMTpyZXR1cm4gZj90KG5bMF0pOnQuY2FsbChpLG5bMF0pO2Nhc2UgMjpyZXR1cm4gZj90KG5bMF0sblsxXSk6dC5jYWxsKGksblswXSxuWzFdKTtjYXNlIDM6cmV0dXJuIGY/dChuWzBdLG5bMV0sblsyXSk6dC5jYWxsKGksblswXSxuWzFdLG5bMl0pO2Nhc2UgNDpyZXR1cm4gZj90KG5bMF0sblsxXSxuWzJdLG5bM10pOnQuY2FsbChpLG5bMF0sblsxXSxuWzJdLG5bM10pfXJldHVybiB0LmFwcGx5KGksbil9fSxmdW5jdGlvbihnLGUsdCl7dmFyIG49dCg5MSksaT10KDE5NSkuc2V0LGY9bi5NdXRhdGlvbk9ic2VydmVyfHxuLldlYktpdE11dGF0aW9uT2JzZXJ2ZXIsaD1uLnByb2Nlc3MsdT1uLlByb21pc2UsYT10KDg2KShoKT09InByb2Nlc3MiO2cuZXhwb3J0cz1mdW5jdGlvbigpe3ZhciBkLEUscCxPPWZ1bmN0aW9uKCl7dmFyIHksUztmb3IoYSYmKHk9aC5kb21haW4pJiZ5LmV4aXQoKTtkOyl7Uz1kLmZuLGQ9ZC5uZXh0O3RyeXtTKCl9Y2F0Y2gocyl7dGhyb3cgZD9wKCk6RT12b2lkIDAsc319RT12b2lkIDAseSYmeS5lbnRlcigpfTtpZihhKXA9ZnVuY3Rpb24oKXtoLm5leHRUaWNrKE8pfTtlbHNlIGlmKGYmJiEobi5uYXZpZ2F0b3ImJm4ubmF2aWdhdG9yLnN0YW5kYWxvbmUpKXt2YXIgbT0hMCxiPWRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCIiKTtuZXcgZihPKS5vYnNlcnZlKGIse2NoYXJhY3RlckRhdGE6ITB9KSxwPWZ1bmN0aW9uKCl7Yi5kYXRhPW09IW19fWVsc2UgaWYodSYmdS5yZXNvbHZlKXt2YXIgTT11LnJlc29sdmUodm9pZCAwKTtwPWZ1bmN0aW9uKCl7TS50aGVuKE8pfX1lbHNlIHA9ZnVuY3Rpb24oKXtpLmNhbGwobixPKX07cmV0dXJuIGZ1bmN0aW9uKHkpe3ZhciBTPXtmbjp5LG5leHQ6dm9pZCAwfTtFJiYoRS5uZXh0PVMpLGR8fChkPVMscCgpKSxFPVN9fX0sZnVuY3Rpb24oZyxlLHQpe3ZhciBuPXQoOTQpO2Z1bmN0aW9uIGkoZil7dmFyIGgsdTt0aGlzLnByb21pc2U9bmV3IGYoZnVuY3Rpb24oYSxkKXtpZihoIT09dm9pZCAwfHx1IT09dm9pZCAwKXRocm93IFR5cGVFcnJvcigiQmFkIFByb21pc2UgY29uc3RydWN0b3IiKTtoPWEsdT1kfSksdGhpcy5yZXNvbHZlPW4oaCksdGhpcy5yZWplY3Q9bih1KX1nLmV4cG9ydHMuZj1mdW5jdGlvbihmKXtyZXR1cm4gbmV3IGkoZil9fSxmdW5jdGlvbihnLGUpe2cuZXhwb3J0cz1mdW5jdGlvbih0KXt0cnl7cmV0dXJue2U6ITEsdjp0KCl9fWNhdGNoKG4pe3JldHVybntlOiEwLHY6bn19fX0sZnVuY3Rpb24oZyxlLHQpe3ZhciBuPXQoOTEpLGk9bi5uYXZpZ2F0b3I7Zy5leHBvcnRzPWkmJmkudXNlckFnZW50fHwiIn0sZnVuY3Rpb24oZyxlLHQpe3ZhciBuPXQoOTcpLGk9dCg5OCksZj10KDE5OCk7Zy5leHBvcnRzPWZ1bmN0aW9uKGgsdSl7aWYobihoKSxpKHUpJiZ1LmNvbnN0cnVjdG9yPT09aClyZXR1cm4gdTt2YXIgYT1mLmYoaCksZD1hLnJlc29sdmU7cmV0dXJuIGQodSksYS5wcm9taXNlfX0sZnVuY3Rpb24oZyxlLHQpe3ZhciBuPXQoOTApLGk9dCg5MiksZj10KDkxKSxoPXQoMTk0KSx1PXQoMjAxKTtuKG4uUCtuLlIsIlByb21pc2UiLHtmaW5hbGx5OmZ1bmN0aW9uKGEpe3ZhciBkPWgodGhpcyxpLlByb21pc2V8fGYuUHJvbWlzZSksRT10eXBlb2YgYT09ImZ1bmN0aW9uIjtyZXR1cm4gdGhpcy50aGVuKEU/ZnVuY3Rpb24ocCl7cmV0dXJuIHUoZCxhKCkpLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gcH0pfTphLEU/ZnVuY3Rpb24ocCl7cmV0dXJuIHUoZCxhKCkpLnRoZW4oZnVuY3Rpb24oKXt0aHJvdyBwfSl9OmEpfX0pfSxmdW5jdGlvbihnLGUsdCl7dmFyIG49dCg5MCksaT10KDE5OCksZj10KDE5OSk7bihuLlMsIlByb21pc2UiLHt0cnk6ZnVuY3Rpb24oaCl7dmFyIHU9aS5mKHRoaXMpLGE9ZihoKTtyZXR1cm4oYS5lP3UucmVqZWN0OnUucmVzb2x2ZSkoYS52KSx1LnByb21pc2V9fSl9LGZ1bmN0aW9uKGcsZSx0KXtnLmV4cG9ydHM9e2RlZmF1bHQ6dCgyMDUpLF9fZXNNb2R1bGU6ITB9fSxmdW5jdGlvbihnLGUsdCl7dCgyMDYpLGcuZXhwb3J0cz10KDkyKS5PYmplY3Qua2V5c30sZnVuY3Rpb24oZyxlLHQpe3ZhciBuPXQoMTI0KSxpPXQoMTEwKTt0KDIwNykoImtleXMiLGZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKGgpe3JldHVybiBpKG4oaCkpfX0pfSxmdW5jdGlvbihnLGUsdCl7dmFyIG49dCg5MCksaT10KDkyKSxmPXQoMTAxKTtnLmV4cG9ydHM9ZnVuY3Rpb24oaCx1KXt2YXIgYT0oaS5PYmplY3R8fHt9KVtoXXx8T2JqZWN0W2hdLGQ9e307ZFtoXT11KGEpLG4obi5TK24uRipmKGZ1bmN0aW9uKCl7YSgxKX0pLCJPYmplY3QiLGQpfX0sZnVuY3Rpb24oZyxlLHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KTt2YXIgbj10KDc2KSxpPWIobiksZj10KDIwOSksaD1iKGYpLHU9dCgxNjQpLGE9Yih1KSxkPXQoMTkxKSxFPWIoZCk7ZS5kZWZlcj1NLGUucGVyaW9kaWNpdHk9eSxlLmNhbGN1bGF0ZUZyYW1lc09mZnNldD1TLGUuZ2V0UHJvZ3Jlc3M9cyxlLmdldEN1cnJlbnRGcmFtZT1sO3ZhciBwPXQoMTg4KSxPPXQoMTg3KSxtPWIoTyk7ZnVuY3Rpb24gYih2KXtyZXR1cm4gdiYmdi5fX2VzTW9kdWxlP3Y6e2RlZmF1bHQ6dn19ZnVuY3Rpb24gTSgpe3ZhciB2PXt9O3JldHVybiB2LnByb21pc2U9bmV3IEUuZGVmYXVsdChmdW5jdGlvbihULFIpe3YucmVzb2x2ZT1ULHYucmVqZWN0PVJ9KSx2fWZ1bmN0aW9uIHkodixUKXt2YXIgUj1NYXRoLmZsb29yKHYvVCksTD12LVIqVDtyZXR1cm4gTD09PTAmJlI+MCYmKEw9VCxSLS0pLFtSLExdfWZ1bmN0aW9uIFModil7dj12LnNsaWNlKDApO3ZhciBUPXZbMF0sUj12W3YubGVuZ3RoLTFdO1Iub2Zmc2V0PVIub2Zmc2V0fHwxLFQub2Zmc2V0PVQub2Zmc2V0fHwwO2Zvcih2YXIgTD0wLE49LTEsQT0wO0E8di5sZW5ndGg7QSsrKXt2YXIgdz12W0FdO2lmKHcub2Zmc2V0IT1udWxsKXt2YXIgQj1BLU47aWYoQj4xKWZvcih2YXIgRD0ody5vZmZzZXQtTCkvQixJPTA7STxCLTE7SSsrKXZbTitJKzFdLm9mZnNldD1MK0QqKEkrMSk7TD13Lm9mZnNldCxOPUF9aWYody5lYXNpbmchPW51bGwmJih3LmVhc2luZz0oMCxwLnBhcnNlRWFzaW5nKSh3LmVhc2luZykpLEE+MCl7dmFyIGo9dltBXS5lYXNpbmchPW51bGw7dltBXT0oMCxhLmRlZmF1bHQpKHt9LHZbQS0xXSx2W0FdKSxqfHxkZWxldGUgdltBXS5lYXNpbmd9fXJldHVybiB2fWZ1bmN0aW9uIHModixULFIpe3ZhciBMPXYuY3VycmVudFRpbWUsTj1ULmRpcmVjdGlvbixBPVQuZHVyYXRpb24sdz0hMTtpZihOPT09InJldmVyc2UiKVI9MS1SLHc9ITA7ZWxzZSBpZihOPT09ImFsdGVybmF0ZSJ8fE49PT0iYWx0ZXJuYXRlLXJldmVyc2UiKXt2YXIgQj1NYXRoLmZsb29yKEwvQSk7Uj09PTEmJkItLSxCJTJeTj09PSJhbHRlcm5hdGUtcmV2ZXJzZSImJihSPTEtUix3PSEwKX1yZXR1cm57cDpSLGludmVydGVkOnd9fWZ1bmN0aW9uIGModixULFIsTCl7dmFyIE49e307cmV0dXJuKDAsaC5kZWZhdWx0KShUKS5mb3JFYWNoKGZ1bmN0aW9uKEEpe3ZhciB3PSgwLGkuZGVmYXVsdCkoQSwyKSxCPXdbMF0sRD13WzFdO2lmKEIhPT0ib2Zmc2V0IiYmQiE9PSJlYXNpbmciKXt2YXIgST1SW0JdfHxSLmRlZmF1bHQsaj1JKHZbQl0sRCxMLHYub2Zmc2V0LFQub2Zmc2V0KTtqIT1udWxsJiYoTltCXT1qKX19KSxOfWZ1bmN0aW9uIGwodixULFIsTCl7dmFyIE49di5lYXNpbmcsQT12LmVmZmVjdDtBfHwoUj0oMCxhLmRlZmF1bHQpKHt9LG0uZGVmYXVsdCxSKSk7dmFyIHc9e307TD1OKEwsVCk7Zm9yKHZhciBCPTE7QjxULmxlbmd0aDtCKyspe3ZhciBEPVRbQl0sST1ELm9mZnNldDtpZihJPj1MfHxCPT09VC5sZW5ndGgtMSl7dmFyIGo9VFtCLTFdLFY9ai5vZmZzZXQsSj1qLmVhc2luZyxfPUw7aWYoSil7dmFyIHN0PUktVjtfPUooKEwtVikvc3QpKnN0K1Z9QT93PUEoaixELF8sVixJKTp3PWMoaixELFIsXyk7YnJlYWt9fXJldHVybiB3fX0sZnVuY3Rpb24oZyxlLHQpe2cuZXhwb3J0cz17ZGVmYXVsdDp0KDIxMCksX19lc01vZHVsZTohMH19LGZ1bmN0aW9uKGcsZSx0KXt0KDIxMSksZy5leHBvcnRzPXQoOTIpLk9iamVjdC5lbnRyaWVzfSxmdW5jdGlvbihnLGUsdCl7dmFyIG49dCg5MCksaT10KDIxMikoITApO24obi5TLCJPYmplY3QiLHtlbnRyaWVzOmZ1bmN0aW9uKGgpe3JldHVybiBpKGgpfX0pfSxmdW5jdGlvbihnLGUsdCl7dmFyIG49dCgxMDApLGk9dCgxMTApLGY9dCg4NCksaD10KDE2OSkuZjtnLmV4cG9ydHM9ZnVuY3Rpb24odSl7cmV0dXJuIGZ1bmN0aW9uKGEpe2Zvcih2YXIgZD1mKGEpLEU9aShkKSxwPUUubGVuZ3RoLE89MCxtPVtdLGI7cD5POyliPUVbTysrXSwoIW58fGguY2FsbChkLGIpKSYmbS5wdXNoKHU/W2IsZFtiXV06ZFtiXSk7cmV0dXJuIG19fX0sZnVuY3Rpb24oZyxlLHQpe3QucihlKSx0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3Qgbj1uZXcgTWFwO2Z1bmN0aW9uIGkoaCx1PXt9LGE9W10pe2g9aC50b0xvd2VyQ2FzZSgpO2NvbnN0IGQ9bi5nZXQoaCk7aWYoIWQpdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBub2RlOiAke2h9YCk7Y29uc3QgRT1uZXcgZCh1KTtyZXR1cm4gYS5mb3JFYWNoKHA9PntFLmFwcGVuZENoaWxkKHApfSksRX1jb25zdCBmPXtyZWdpc3Rlck5vZGUoaCx1LGE9MTAwKXtpZih1PXUudG9Mb3dlckNhc2UoKSxuLmhhcyh1KSl0aHJvdyBuZXcgVHlwZUVycm9yKGBDYW5ub3QgcmVnaXN0ZXJOb2RlLCAke3V9IGhhcyBiZWVuIHRha2VuLmApO24uc2V0KHUsaCksT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoaC5wcm90b3R5cGUse25vZGVUeXBlOnt2YWx1ZTphfSx0YWdOYW1lOnt2YWx1ZTp1LnRvVXBwZXJDYXNlKCl9LG5vZGVOYW1lOnt2YWx1ZTp1fSxvd25lckRvY3VtZW50Ont2YWx1ZTpmfSxuYW1lc3BhY2VVUkk6e3ZhbHVlOmBodHRwOi8vc3ByaXRlanMuY29tLyR7dX1gfX0pfSxjcmVhdGVFbGVtZW50OmksY3JlYXRlRWxlbWVudE5TKGgsdSl7cmV0dXJuIGkodSl9LGlzU3ByaXRlTm9kZShoKXtyZXR1cm4gbi5oYXMoaC50b0xvd2VyQ2FzZSgpKX19O2UuZGVmYXVsdD1mfSxmdW5jdGlvbihnLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiB1fSksdCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IG49U3ltYm9sKCJ0eXBlIiksaT1TeW1ib2woImJ1YmJsZXMiKSxmPVN5bWJvbCgib3JpZ2luYWxFdmVudCIpLGg9U3ltYm9sKCJkZXRhaWwiKTtjbGFzcyB1e2NvbnN0cnVjdG9yKGQse2J1YmJsZXM6RT1udWxsfT17fSl7aWYodHlwZW9mIGQ9PSJzdHJpbmciPyh0aGlzW25dPWQsdGhpc1tpXT0hIUUpOih0aGlzW25dPWQudHlwZSx0aGlzW2ZdPWQsdGhpc1tpXT1FIT1udWxsPyEhRTohIWQuYnViYmxlcyxkLmRldGFpbCYmKHRoaXNbaF09ZC5kZXRhaWwpKSwhdGhpc1tuXSl0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIGV2ZW50IHR5cGUuIik7dGhpcy5jYW5jZWxCdWJibGU9ITF9c2V0T3JpZ2luYWxFdmVudChkKXt0aGlzW2ZdPWR9Z2V0IG9yaWdpbmFsRXZlbnQoKXtyZXR1cm4gdGhpc1tmXX1nZXQgdHlwZSgpe3JldHVybiB0aGlzW25dfWdldCBidWJibGVzKCl7cmV0dXJuIHRoaXNbaV19Z2V0IGRldGFpbCgpe3JldHVybiB0aGlzW2hdfXN0b3BQcm9wYWdhdGlvbigpe3RoaXMuY2FuY2VsQnViYmxlPSEwfX19LGZ1bmN0aW9uKGcsZSx0KXt0LnIoZSksdC5kKGUsInBhcnNlRmlsdGVyU3RyaW5nIixmdW5jdGlvbigpe3JldHVybiBpfSksdC5kKGUsImFwcGx5RmlsdGVycyIsZnVuY3Rpb24oKXtyZXR1cm4gZn0pO3ZhciBuPXQoNzIpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBpKGgpe2lmKGg9aC50cmltKCksIWh8fGg9PT0ibm9uZSIpcmV0dXJuIG51bGw7Y29uc3QgdT0vXig/Oih1cmx8Ymx1cnxicmlnaHRuZXNzfGNvbnRyYXN0fGRyb3Atc2hhZG93fGdyYXlzY2FsZXxodWUtcm90YXRlfGludmVydHxvcGFjaXR5fHNhdHVyYXRlfHNlcGlhKVwoKFteKCldKig/OlwoLipcKSkqW14oKV0qKVwpKSskL2ksYT1oLm1hdGNoKC8oPzoodXJsfGJsdXJ8YnJpZ2h0bmVzc3xjb250cmFzdHxkcm9wLXNoYWRvd3xncmF5c2NhbGV8aHVlLXJvdGF0ZXxpbnZlcnR8b3BhY2l0eXxzYXR1cmF0ZXxzZXBpYSlcKChbXigpXSooPzpcKC4qXCkpKlteKCldKilcKSkrPy9pZyksZD1bXTtyZXR1cm4gYSYmYS5mb3JFYWNoKEU9Pntjb25zdCBwPUUubWF0Y2godSk7aWYoIXApdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCBmaXRsZXIgc3RyaW5nLiIpO2xldFssTyxtXT1wO089Ty50b0xvd2VyQ2FzZSgpLG09bS50cmltKCkubWF0Y2goLyhbXiggKV0rfChbXiggKV0rXCguKlwpKSkoPz1cc3wkKS9nKS5tYXAoKGIsTSk9PntsZXQgeTtyZXR1cm4gTz09PSJ1cmwifHxPPT09ImRyb3Atc2hhZG93IiYmTT09PTM/eT1iOnk9T2JqZWN0KG4udG9OdW1iZXIpKGIpLC8lJC8udGVzdChiKSYmKHkvPTEwMCkseX0pLGQucHVzaCh7dHlwZTpPLGFyZ3M6bX0pfSksZH1mdW5jdGlvbiBmKGgsdSl7aC5jbGVhckZpbHRlcigpLHUmJnUuZm9yRWFjaCgoe3R5cGU6YSxhcmdzOmR9KT0+e2xldCBFPWE7RT09PSJkcm9wLXNoYWRvdyI/RT0iZHJvcFNoYWRvdyI6RT09PSJodWUtcm90YXRlIiYmKEU9Imh1ZVJvdGF0ZSIpLGhbRV0oLi4uZCl9KX19LGZ1bmN0aW9uKGcsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIG59KSx0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gbihpLGYpe2lmKCFmKXJldHVybjtjb25zdCBoPWkuZ2V0TGlzdGVuZXJzKCJiZWZvcmVyZW5kZXIiKSx1PWkuZ2V0TGlzdGVuZXJzKCJhZnRlcnJlbmRlciIpO2gubGVuZ3RoJiYhZi5iZWZvcmVSZW5kZXI/Zi5iZWZvcmVSZW5kZXI9YT0+e2kuZGlzcGF0Y2hFdmVudCh7dHlwZToiYmVmb3JlcmVuZGVyIixkZXRhaWw6e2NvbnRleHQ6YX19KX06aC5sZW5ndGh8fChmLmJlZm9yZVJlbmRlcj1udWxsKSx1Lmxlbmd0aCYmIWYuYWZ0ZXJSZW5kZXI/Zi5hZnRlclJlbmRlcj1hPT57aS5kaXNwYXRjaEV2ZW50KHt0eXBlOiJhZnRlcnJlbmRlciIsZGV0YWlsOntjb250ZXh0OmF9fSl9OnUubGVuZ3RofHwoZi5hZnRlclJlbmRlcj1udWxsKX19LGZ1bmN0aW9uKGcsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIGR9KTt2YXIgbj10KDEyKSxpPXQoMjE4KSxmPXQoNzApLGg9dCgyMTMpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCB1PVN5bWJvbCgiYW1vdW50IiksYT1TeW1ib2woIm1lc2hDbG91ZCIpO2NsYXNzIGQgZXh0ZW5kcyBmLmRlZmF1bHR7Y29uc3RydWN0b3IocCxPPTEpe3N1cGVyKCksdGhpcy5tZXNoTm9kZT1wLHAuY29ubmVjdCh0aGlzKSx0aGlzW3VdPU8sdGhpc1thXT1udWxsfWdldCBtZXNoQ2xvdWQoKXtjb25zdCBwPXRoaXMubWVzaE5vZGUsTz10aGlzW3VdO3JldHVybiF0aGlzW2FdJiZwLm1lc2gmJih0aGlzW2FdPW5ldyBuLk1lc2hDbG91ZChwLm1lc2gsTykpLHRoaXNbYV19Z2V0IGlzVmlzaWJsZSgpe3JldHVybiEhdGhpcy5tZXNoTm9kZSYmdGhpcy5tZXNoTm9kZS5pc1Zpc2libGV9Z2V0IGFtb3VudCgpe3JldHVybiB0aGlzW3VdfXNldCBhbW91bnQocCl7dGhpc1t1XT1wLHRoaXNbYV0mJih0aGlzW2FdLmFtb3VudD1wKX1icmlnaHRuZXNzKHAsTyl7dGhpcy5tZXNoQ2xvdWQmJih0aGlzLm1lc2hDbG91ZC5icmlnaHRuZXNzKHAsTyksdGhpcy5mb3JjZVVwZGF0ZSgpKX1jb250cmFzdChwLE8pe3RoaXMubWVzaENsb3VkJiYodGhpcy5tZXNoQ2xvdWQuY29udHJhc3QocCxPKSx0aGlzLmZvcmNlVXBkYXRlKCkpfWRlbGV0ZShwKXt0aGlzLm1lc2hDbG91ZCYmKHRoaXMubWVzaENsb3VkLmRlbGV0ZShwKSx0aGlzW3VdLS0sdGhpcy5mb3JjZVVwZGF0ZSgpKX1kcmF3KHA9W10pe2lmKHN1cGVyLmRyYXcocCksdGhpcy5tZXNoQ2xvdWQpe2lmKHRoaXMucHJvZ3JhbSl7dGhpcy5tZXNoQ2xvdWQuc2V0UHJvZ3JhbSh0aGlzLnByb2dyYW0pO2NvbnN0IE89dGhpcy5zaGFkZXJBdHRycztPJiZPYmplY3QuZW50cmllcyhPKS5mb3JFYWNoKChbYixNXSk9Pnt0aGlzLm1lc2hDbG91ZC5tZXNoLnNldEF0dHJpYnV0ZShiLE0pfSk7Y29uc3QgbT10aGlzLnVuaWZvcm1zO2lmKHRoaXMudW5pZm9ybXMpe2NvbnN0IGI9e307T2JqZWN0LmVudHJpZXMobSkuZm9yRWFjaCgoW00seV0pPT57dHlwZW9mIHk9PSJmdW5jdGlvbiImJih5PXkodGhpcyxNKSksYltNXT15fSksdGhpcy5tZXNoQ2xvdWQubWVzaC5zZXRVbmlmb3JtcyhiKX19dGhpcy5tZXNoTm9kZS50ZXh0dXJlSW1hZ2UmJk9iamVjdChpLmRyYXdUZXh0dXJlKSh0aGlzLm1lc2hOb2RlLHRoaXMubWVzaE5vZGUubWVzaCkscC5wdXNoKHRoaXMubWVzaENsb3VkKX1yZXR1cm4gcH1nZXRUcmFuc2Zvcm0ocCl7aWYodGhpcy5tZXNoQ2xvdWQpcmV0dXJuIHRoaXMubWVzaENsb3VkLmdldFRyYW5zZm9ybShwKX1ncmF5c2NhbGUocCxPKXt0aGlzLm1lc2hDbG91ZCYmKHRoaXMubWVzaENsb3VkLmdyYXlzY2FsZShwLE8pLHRoaXMuZm9yY2VVcGRhdGUoKSl9aHVlUm90YXRlKHAsTyl7dGhpcy5tZXNoQ2xvdWQmJih0aGlzLm1lc2hDbG91ZC5odWVSb3RhdGUocCxPKSx0aGlzLmZvcmNlVXBkYXRlKCkpfWludmVydChwLE8pe3RoaXMubWVzaENsb3VkJiYodGhpcy5tZXNoQ2xvdWQuaW52ZXJ0KHAsTyksdGhpcy5mb3JjZVVwZGF0ZSgpKX1pc1BvaW50Q29sbGlzaW9uKHAsTyl7aWYoIXRoaXMubWVzaENsb3VkKXJldHVybiExO2NvbnN0IG09dGhpcy5hdHRyaWJ1dGVzLnBvaW50ZXJFdmVudHM7aWYobT09PSJub25lInx8bSE9PSJhbGwiJiYhdGhpcy5pc1Zpc2libGUpcmV0dXJuITE7bGV0IGI9ImJvdGgiO209PT0idmlzaWJsZUZpbGwiJiYoYj0iZmlsbCIpLG09PT0idmlzaWJsZVN0cm9rZSImJihiPSJzdHJva2UiKTtmb3IobGV0IE09MDtNPHRoaXNbdV07TSsrKWlmKCF0aGlzLm1lc2hDbG91ZC5pc1BvaW50Q29sbGlzaW9uKE0sW3AsT10sYikpcmV0dXJuITE7cmV0dXJuITB9c2V0T3BhY2l0eShwLE8pe3RoaXMubWVzaENsb3VkJiYodGhpcy5tZXNoQ2xvdWQub3BhY2l0eShwLE8pLHRoaXMuZm9yY2VVcGRhdGUoKSl9cm90YXRlKHAsTyxbbSxiXT1bMCwwXSl7Y29uc3QgTT1NYXRoLlBJKk8vMTgwO2lmKHRoaXMubWVzaENsb3VkKXtjb25zdHt4OnkseTpTfT10aGlzLm1lc2hOb2RlLmF0dHJpYnV0ZXM7dGhpcy5tZXNoQ2xvdWQucm90YXRlKHAsTSxbbSt5LGIrU10pLHRoaXMuZm9yY2VVcGRhdGUoKX19c2F0dXJhdGUocCxPKXt0aGlzLm1lc2hDbG91ZCYmKHRoaXMubWVzaENsb3VkLnNhdHVyYXRlKHAsTyksdGhpcy5mb3JjZVVwZGF0ZSgpKX1zY2FsZShwLFtPLG09T10sW2IsTV09WzAsMF0pe2lmKHRoaXMubWVzaENsb3VkKXtjb25zdHt4OnkseTpTfT10aGlzLm1lc2hOb2RlLmF0dHJpYnV0ZXMscz0xZS01O01hdGguYWJzKE8pPHMmJihPPTEvTz4wP3M6LXMpLE1hdGguYWJzKG0pPHMmJihtPTEvbT4wP3M6LXMpLHRoaXMubWVzaENsb3VkLnNjYWxlKHAsW08sbV0sW2IreSxNK1NdKSx0aGlzLmZvcmNlVXBkYXRlKCl9fXNldENvbG9yVHJhbnNmb3JtKHAsTyl7dGhpcy5tZXNoQ2xvdWQmJih0aGlzLm1lc2hDbG91ZC5zZXRDb2xvclRyYW5zZm9ybShwLE8pLHRoaXMuZm9yY2VVcGRhdGUoKSl9c2V0RmlsbENvbG9yKHAsTyl7dGhpcy5tZXNoQ2xvdWQmJihBcnJheS5pc0FycmF5KE8pJiYoTz1bLi4uT10sT1swXS89MjU1LE9bMV0vPTI1NSxPWzJdLz0yNTUpLHRoaXMubWVzaENsb3VkLnNldEZpbGxDb2xvcihwLE8pLHRoaXMuZm9yY2VVcGRhdGUoKSl9c2VwaWEocCxPKXt0aGlzLm1lc2hDbG91ZCYmKHRoaXMubWVzaENsb3VkLnNlcGlhKHAsTyksdGhpcy5mb3JjZVVwZGF0ZSgpKX1zZXRSZXNvbHV0aW9uKHt3aWR0aDpwLGhlaWdodDpPfSl7c3VwZXIuc2V0UmVzb2x1dGlvbih7d2lkdGg6cCxoZWlnaHQ6T30pLHRoaXMubWVzaE5vZGUuc2V0UmVzb2x1dGlvbih7d2lkdGg6cCxoZWlnaHQ6T30pfXNldFN0cm9rZUNvbG9yKHAsTyl7dGhpcy5tZXNoQ2xvdWQmJihBcnJheS5pc0FycmF5KE8pJiYoTz1bLi4uT10sT1swXS89MjU1LE9bMV0vPTI1NSxPWzJdLz0yNTUpLHRoaXMubWVzaENsb3VkLnNldFN0cm9rZUNvbG9yKHAsTyksdGhpcy5mb3JjZVVwZGF0ZSgpKX1zZXRUcmFuc2Zvcm0ocCxPKXt0aGlzLm1lc2hDbG91ZCYmKHRoaXMubWVzaENsb3VkLnNldFRyYW5zZm9ybShwLE8pLHRoaXMuZm9yY2VVcGRhdGUoKSl9c2tldyhwLFtPLG09T10sW2IsTV09WzAsMF0pe2lmKHRoaXMubWVzaENsb3VkKXtjb25zdHt4OnkseTpTfT10aGlzLm1lc2hOb2RlLmF0dHJpYnV0ZXM7dGhpcy5tZXNoQ2xvdWQuc2tldyhwLFtPLG1dLFtiK3ksTStTXSksdGhpcy5mb3JjZVVwZGF0ZSgpfX10cmFuc2Zvcm0ocCxPKXt0aGlzLm1lc2hDbG91ZCYmKHRoaXMubWVzaENsb3VkLnRyYW5zZm9ybShwLE8pLHRoaXMuZm9yY2VVcGRhdGUoKSl9dHJhbnNmb3JtQ29sb3IocCxPKXt0aGlzLm1lc2hDbG91ZCYmKHRoaXMubWVzaENsb3VkLnRyYW5zZm9ybUNvbG9yKHAsTyksdGhpcy5mb3JjZVVwZGF0ZSgpKX10cmFuc2xhdGUocCxbTyxtXSl7dGhpcy5tZXNoQ2xvdWQmJih0aGlzLm1lc2hDbG91ZC50cmFuc2xhdGUocCxbTyxtXSksdGhpcy5mb3JjZVVwZGF0ZSgpKX11cGRhdGVNZXNoKCl7dGhpc1thXSYmKHRoaXNbYV0ubWVzaD10aGlzLm1lc2hOb2RlLm1lc2gsdGhpcy5mb3JjZVVwZGF0ZSgpKX19aC5kZWZhdWx0LnJlZ2lzdGVyTm9kZShkLCJjbG91ZCIpfSxmdW5jdGlvbihnLGUsdCl7dC5yKGUpLHQuZChlLCJsb2FkVGV4dHVyZSIsZnVuY3Rpb24oKXtyZXR1cm4gaH0pLHQuZChlLCJhcHBseVRleHR1cmUiLGZ1bmN0aW9uKCl7cmV0dXJuIHV9KSx0LmQoZSwiY3JlYXRlVGV4dHVyZSIsZnVuY3Rpb24oKXtyZXR1cm4gZH0pLHQuZChlLCJkZWxldGVUZXh0dXJlIixmdW5jdGlvbigpe3JldHVybiBFfSksdC5kKGUsImRyYXdUZXh0dXJlIixmdW5jdGlvbigpe3JldHVybiBPfSksdC5kKGUsImxvYWRGcmFtZXMiLGZ1bmN0aW9uKCl7cmV0dXJuIG19KTt2YXIgbj10KDEyKSxpPXQoNzIpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCBmPXt9O2Z1bmN0aW9uIGgoYixNKXtpZihmW2JdKXJldHVybiBmW2JdO2NvbnN0IHk9bi5FTlYubG9hZEltYWdlKGIse2FsaWFzOk0sdXNlSW1hZ2VCaXRtYXA6ITF9KTtyZXR1cm4geT8/Yn1hc3luYyBmdW5jdGlvbiB1KGIsTSx5KXtsZXQgUz1NO2lmKHR5cGVvZiBNPT0ic3RyaW5nIiYmKFM9aChNKSksUyYmdHlwZW9mIFMudGhlbj09ImZ1bmN0aW9uIiYmKFM9YXdhaXQgUyksTT09PWIuYXR0cmlidXRlcy50ZXh0dXJlKXtTJiZTLmltYWdlJiYoUy5zb3VyY2VSZWN0JiYoYi5hdHRyaWJ1dGVzLnNvdXJjZVJlY3Q9Uy5zb3VyY2VSZWN0KSxiLnRleHR1cmVJbWFnZVJvdGF0ZWQ9ISFTLnJvdGF0ZWQsUz1TLmltYWdlKTtjb25zdHt3aWR0aDpzLGhlaWdodDpjLHRleHR1cmVSZWN0Omx9PWIuYXR0cmlidXRlcyx2PWIudGV4dHVyZUltYWdlO2IudGV4dHVyZUltYWdlPVMseSYmdiE9PVMmJiFsJiYocz09bnVsbHx8Yz09bnVsbCkmJmIudXBkYXRlQ29udG91cnMoKSxiLmZvcmNlVXBkYXRlKCl9cmV0dXJuIFN9Y29uc3QgYT1TeW1ib2woInRleHR1cmVNYXAiKTtmdW5jdGlvbiBkKGIsTSl7aWYoTVthXT1NW2FdfHxuZXcgTWFwLE1bYV0uaGFzKGIpKXJldHVybiBNW2FdLmdldChiKTtjb25zdCB5PU0uY3JlYXRlVGV4dHVyZShiKTtyZXR1cm4hL15ibG9iOi8udGVzdChiLnNyYykmJnR5cGVvZiBiLmdldENvbnRleHQhPSJmdW5jdGlvbiImJk1bYV0uc2V0KGIseSkseX1mdW5jdGlvbiBFKGIsTSl7aWYoTVthXSYmTVthXS5oYXMoYikpe2NvbnN0IHk9TVthXS5nZXQoYik7cmV0dXJuIE0uZGVsZXRlVGV4dHVyZSh5KSxNW2FdLmRlbGV0ZShiKSwhMH1yZXR1cm4hMX1jb25zdCBwPVN5bWJvbCgidGV4dHVyZUNvbnRleHQiKTtmdW5jdGlvbiBPKGIsTSl7Y29uc3QgeT1iLnRleHR1cmVJbWFnZSBpbnN0YW5jZW9mIFN0cmluZz9TdHJpbmcoYi50ZXh0dXJlSW1hZ2UpOmIudGV4dHVyZUltYWdlLFM9Yi50ZXh0dXJlSW1hZ2VSb3RhdGVkLHM9TS50ZXh0dXJlLGM9Yi5yZW5kZXJlcjtpZih5KXtjb25zdCBsPWIub3JpZ2luYWxDb250ZW50UmVjdDtsZXQgdj1iLmF0dHJpYnV0ZXMudGV4dHVyZVJlY3Q7Y29uc3QgVD1iLmF0dHJpYnV0ZXMudGV4dHVyZVJlcGVhdCxSPWIuYXR0cmlidXRlcy5zb3VyY2VSZWN0O2lmKCFzfHxiW3BdJiZiW3BdIT09Y3x8cy5pbWFnZSE9PXl8fHMub3B0aW9ucy5yZXBlYXQhPT1UfHwhT2JqZWN0KGkuY29tcGFyZVZhbHVlKShzLm9wdGlvbnMucmVjdCx2KXx8IU9iamVjdChpLmNvbXBhcmVWYWx1ZSkocy5vcHRpb25zLnNyY1JlY3QsUikpe2NvbnN0IEw9ZCh5LGMpO3Y/KHZbMF0rPWxbMF0sdlsxXSs9bFsxXSk6dj1sO2xldCBOPW51bGw7cyYmIWNbYV0uaGFzKHMuaW1hZ2UpJiYoIXMub3B0aW9uc3x8IXMub3B0aW9ucy5oaWRkZW4pJiYoTj1NLnVuaWZvcm1zLnVfdGV4U2FtcGxlciksTS5zZXRUZXh0dXJlKEwse3JlY3Q6dixyZXBlYXQ6VCxzcmNSZWN0OlIscm90YXRlZDpTfSksTiYmTi5kZWxldGUmJk4uZGVsZXRlKCksYltwXT1jfX1lbHNlIGlmKHMpe2xldCBsPW51bGw7IWNbYV0uaGFzKHMuaW1hZ2UpJiYoIXMub3B0aW9uc3x8IXMub3B0aW9ucy5oaWRkZW4pJiYobD1NLnVuaWZvcm1zLnVfdGV4U2FtcGxlciksTS5zZXRUZXh0dXJlKG51bGwpLGwmJmwuZGVsZXRlJiZsLmRlbGV0ZSgpfX1hc3luYyBmdW5jdGlvbiBtKGIsTSl7dHlwZW9mIE09PSJzdHJpbmciJiYoTT1hd2FpdChhd2FpdCBmZXRjaChNLHttZXRob2Q6IkdFVCIsbW9kZToiY29ycyIsY2FjaGU6ImRlZmF1bHQifSkpLmpzb24oKSk7Y29uc3QgeT1hd2FpdCBoKGIpLFM9TS5mcmFtZXM7cmV0dXJuIE9iamVjdC5lbnRyaWVzKFMpLmZvckVhY2goKFtzLGNdKT0+e2NvbnN0e3g6bCx5OnYsdzpULGg6Un09Yy5mcmFtZTtsZXQgTD1bbCx2LFQsUl07Y29uc3QgTj1jLnJvdGF0ZWQ7TiYmKEw9W0xbMF0sTFsxXSxMWzNdLExbMl1dKSxmW3NdPXtpbWFnZTp5LHNvdXJjZVJlY3Q6TCxyb3RhdGVkOk59fSkseX19LGZ1bmN0aW9uKGcsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIG19KTt2YXIgbj10KDEpLGk9dCgxMiksZj10KDcwKSxoPXQoMjIwKSx1PXQoMjIxKSxhPXQoMjIyKSxkPXQoMjEzKSxFPXQoMjIzKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gcChiLE0seSl7cmV0dXJuIE0gaW4gYj9PYmplY3QuZGVmaW5lUHJvcGVydHkoYixNLHt2YWx1ZTp5LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6YltNXT15LGJ9Y29uc3QgTz1TeW1ib2woIm1lc2giKTtjbGFzcyBtIGV4dGVuZHMgZi5kZWZhdWx0e2NvbnN0cnVjdG9yKE09e30pe3N1cGVyKE0pfWdldCBib3JkZXJTaXplKCl7Y29uc3R7cGFkZGluZ1RvcDpNLHBhZGRpbmdSaWdodDp5LHBhZGRpbmdCb3R0b206UyxwYWRkaW5nTGVmdDpzLGJvcmRlcldpZHRoOmN9PXRoaXMuYXR0cmlidXRlcyxbbCx2XT10aGlzLmNvbnRlbnRTaXplO3JldHVybltzK2wreStjLE0rditTK2NdfWdldCBjbGllbnRTaXplKCl7Y29uc3R7cGFkZGluZ1RvcDpNLHBhZGRpbmdSaWdodDp5LHBhZGRpbmdCb3R0b206UyxwYWRkaW5nTGVmdDpzfT10aGlzLmF0dHJpYnV0ZXMsW2MsbF09dGhpcy5jb250ZW50U2l6ZTtyZXR1cm5bcytjK3ksTStsK1NdfWdldCBjb250ZW50U2l6ZSgpe2xldHt3aWR0aDpNLGhlaWdodDp5LGJveFNpemluZzpTLHBhZGRpbmdUb3A6cyxwYWRkaW5nUmlnaHQ6YyxwYWRkaW5nQm90dG9tOmwscGFkZGluZ0xlZnQ6dn09dGhpcy5hdHRyaWJ1dGVzO2lmKE09TXx8MCx5PXl8fDAsUz09PSJib3JkZXItYm94Iil7Y29uc3QgVD0yKnRoaXMuYXR0cmlidXRlcy5ib3JkZXJXaWR0aDtNLT1UK2Mrdix5LT1UK3MrbCxNPU1hdGgubWF4KDAsTSkseT1NYXRoLm1heCgwLHkpfXJldHVybltNLHldfWdldCBoYXNCb3JkZXIoKXtyZXR1cm4gdGhpcy5hdHRyaWJ1dGVzLmJvcmRlcldpZHRoPjB9Z2V0IGlzVmlzaWJsZSgpe2NvbnN0W00seV09dGhpcy5ib3JkZXJTaXplO3JldHVybiBNPjAmJnk+MH1nZXQgbWVzaCgpe2lmKHRoaXMuYXR0cmlidXRlcy5kaXNwbGF5PT09Im5vbmUiKXJldHVybiBudWxsO2NvbnN0IE09dGhpcy5jbGllbnRCb3g7aWYoTSl7bGV0IHk9dGhpc1tPXTtpZih5KXkuYm94IT09TSYmKHkuY29udG91cnM9TS5jb250b3Vycyx5LmJveD1NKTtlbHNle3k9bmV3IGkuTWVzaDJEKE0pLHkuYm94PU07Y29uc3Qgcz10aGlzLmF0dHJpYnV0ZXMuYmdjb2xvcjtpZihPYmplY3QodS5zZXRGaWxsQ29sb3IpKHkse2NvbG9yOnN9KSx0aGlzLmhhc0JvcmRlcil7Y29uc3R7Ym9yZGVyQ29sb3I6bCxib3JkZXJXaWR0aDp2LGJvcmRlckRhc2g6VCxib3JkZXJEYXNoT2Zmc2V0OlJ9PXRoaXMuYXR0cmlidXRlcztPYmplY3QodS5zZXRTdHJva2VDb2xvcikoeSx7Y29sb3I6bCxsaW5lV2lkdGg6dixsaW5lRGFzaDpULGxpbmVEYXNoT2Zmc2V0OlJ9KX10aGlzW09dPXk7Y29uc3QgYz10aGlzLmF0dHJpYnV0ZXMuY2xpcFBhdGg7YyYmdGhpc1tPXS5zZXRDbGlwUGF0aChjKX1jb25zdCBTPXRoaXMub3BhY2l0eTtyZXR1cm4geS5nZXRPcGFjaXR5KCkhPT1TJiZ5LnNldE9wYWNpdHkoUykseS5zZXRUcmFuc2Zvcm0oLi4udGhpcy5yZW5kZXJNYXRyaXgpLHl9cmV0dXJuIG51bGx9Z2V0IG9mZnNldFNpemUoKXtjb25zdHtwYWRkaW5nVG9wOk0scGFkZGluZ1JpZ2h0OnkscGFkZGluZ0JvdHRvbTpTLHBhZGRpbmdMZWZ0OnMsYm9yZGVyV2lkdGg6Y309dGhpcy5hdHRyaWJ1dGVzLFtsLHZdPXRoaXMuY29udGVudFNpemUsVD0yKmM7cmV0dXJuW3MrbCt5K1QsTSt2K1MrVF19Z2V0IG9yaWdpbmFsQ2xpZW50UmVjdCgpe2lmKHRoaXMubWVzaCl7Y29uc3QgTT10aGlzLm1lc2guYm91bmRpbmdCb3g7cmV0dXJuW01bMF1bMF0sTVswXVsxXSxNWzFdWzBdLU1bMF1bMF0sTVsxXVsxXS1NWzBdWzFdXX1yZXR1cm5bMCwwLDAsMF19Z2V0IG9yaWdpbmFsQ29udGVudFJlY3QoKXtjb25zdFtNLHksUyxzXT10aGlzLm9yaWdpbmFsQ2xpZW50UmVjdCxjPXRoaXMuYXR0cmlidXRlcy5wYWRkaW5nO3JldHVybltNK2NbMF0seStjWzFdLFMtY1swXS1jWzJdLHMtY1sxXS1jWzNdXX1nZXRCb3VuZGluZ0NsaWVudFJlY3QoKXtsZXQgTT10aGlzLnJlbmRlck1hdHJpeDt0aGlzLmxheWVyJiZ0aGlzLmxheWVyLmxheWVyVHJhbnNmb3JtSW52ZXJ0JiYoTT1uLm1hdDJkLm11bHRpcGx5KEFycmF5Lm9mKDAsMCwwLDAsMCwwKSx0aGlzLmxheWVyLnRyYW5zZm9ybU1hdHJpeCxNKSk7bGV0IHk9bnVsbDtpZih0aGlzLm1lc2gpe3k9Wy4uLnRoaXMubWVzaC5ib3VuZGluZ0JveF07Y29uc3QgUz10aGlzLmF0dHJpYnV0ZXMuYm9yZGVyV2lkdGg7UyYmKHlbMF09W3lbMF1bMF0tUyx5WzBdWzFdLVNdLHlbMV09W3lbMV1bMF0rUyx5WzFdWzFdK1NdKX1yZXR1cm4gT2JqZWN0KEUuZGVmYXVsdCkoeSxNKX1vblByb3BlcnR5Q2hhbmdlKE0seSxTKXtpZihzdXBlci5vblByb3BlcnR5Q2hhbmdlKE0seSxTKSwoTT09PSJhbmNob3JYInx8TT09PSJhbmNob3JZInx8TT09PSJib3hTaXppbmcifHxNPT09IndpZHRoInx8TT09PSJoZWlnaHQifHxNPT09ImJvcmRlcldpZHRoInx8TT09PSJwYWRkaW5nTGVmdCJ8fE09PT0icGFkZGluZ1JpZ2h0Inx8TT09PSJwYWRkaW5nVG9wInx8TT09PSJwYWRkaW5nQm90dG9tInx8L15ib3JkZXIoVG9wTGVmdHxUb3BSaWdodHxCb3R0b21SaWdodHxCb3R0b21MZWZ0KVJhZGl1cyQvLnRlc3QoTSkpJiZ0aGlzLnVwZGF0ZUNvbnRvdXJzKCksdGhpc1tPXSYmTT09PSJjbGlwUGF0aCImJnRoaXNbT10uc2V0Q2xpcFBhdGgoeSksdGhpc1tPXSYmTT09PSJiZ2NvbG9yIiYmT2JqZWN0KHUuc2V0RmlsbENvbG9yKSh0aGlzW09dLHtjb2xvcjp5fSksdGhpc1tPXSYmKE09PT0iYm9yZGVyQ29sb3IifHxNPT09ImJvcmRlcldpZHRoInx8TT09PSJib3JkZXJEYXNoInx8TT09PSJib3JkZXJEYXNoT2Zmc2V0Iikpe2NvbnN0e2JvcmRlckNvbG9yOnMsYm9yZGVyV2lkdGg6Yyxib3JkZXJEYXNoOmwsYm9yZGVyRGFzaE9mZnNldDp2fT10aGlzLmF0dHJpYnV0ZXM7T2JqZWN0KHUuc2V0U3Ryb2tlQ29sb3IpKHRoaXNbT10se2NvbG9yOnMsbGluZVdpZHRoOmMsbGluZURhc2g6Yz9sOjAsbGluZURhc2hPZmZzZXQ6dn0pfX11cGRhdGVDb250b3Vycygpe2NvbnN0e2FuY2hvclg6TSxhbmNob3JZOnksYm9yZGVyV2lkdGg6Uyxib3JkZXJSYWRpdXM6c309dGhpcy5hdHRyaWJ1dGVzLFtjLGxdPXRoaXMuYm9yZGVyU2l6ZSx2PXRoaXMub2Zmc2V0U2l6ZSxUPS41KlMsUj0tTSp2WzBdK1QsTD0teSp2WzFdK1Q7dGhpcy5jbGllbnRCb3g9bmV3IGkuRmlndXJlMkQsT2JqZWN0KGEuY3JlYXRlUmFkaXVzQm94KSh0aGlzLmNsaWVudEJveCxbUixMLGMsbF0scyl9fXAobSwiQXR0ciIsaC5kZWZhdWx0KSxkLmRlZmF1bHQucmVnaXN0ZXJOb2RlKG0sImJsb2NrIil9LGZ1bmN0aW9uKGcsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIEV9KTt2YXIgbj10KDcxKSxpPXQoNzIpLGY9dCgyMjEpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCBoPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZSIpLHU9U3ltYm9sLmZvcigic3ByaXRlanNfZ2V0QXR0cmlidXRlIiksYT1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGVEZWZhdWx0IiksZD1TeW1ib2wuZm9yKCJzcHJpdGVqc19kZWNsYXJlQWxpYXMiKTtjbGFzcyBFIGV4dGVuZHMgbi5kZWZhdWx0e2NvbnN0cnVjdG9yKE8pe3N1cGVyKE8pLHRoaXNbYV0oe2FuY2hvclg6MCxhbmNob3JZOjAsd2lkdGg6dm9pZCAwLGhlaWdodDp2b2lkIDAsYm9yZGVyV2lkdGg6MCxib3JkZXJDb2xvcjoicmdiYSgwLDAsMCwxKSIsYm9yZGVyRGFzaDp2b2lkIDAsYm9yZGVyRGFzaE9mZnNldDowLGJvcmRlclRvcExlZnRSYWRpdXM6WzAsMF0sYm9yZGVyVG9wUmlnaHRSYWRpdXM6WzAsMF0sYm9yZGVyQm90dG9tUmlnaHRSYWRpdXM6WzAsMF0sYm9yZGVyQm90dG9tTGVmdFJhZGl1czpbMCwwXSxiZ2NvbG9yOiJyZ2JhKDAsMCwwLDApIixwYWRkaW5nVG9wOjAscGFkZGluZ1JpZ2h0OjAscGFkZGluZ0JvdHRvbTowLHBhZGRpbmdMZWZ0OjAsYm94U2l6aW5nOiJjb250ZW50LWJveCIsY2xpcFBhdGg6dm9pZCAwfSksdGhpc1tkXSgiYW5jaG9yIiwic2l6ZSIsImJvcmRlciIsImJvcmRlclJhZGl1cyIsInBhZGRpbmciKX1nZXQgYW5jaG9yWCgpe3JldHVybiB0aGlzW3VdKCJhbmNob3JYIil9c2V0IGFuY2hvclgoTyl7dGhpc1toXSgiYW5jaG9yWCIsT2JqZWN0KGkudG9OdW1iZXIpKE8pKX1nZXQgYW5jaG9yWSgpe3JldHVybiB0aGlzW3VdKCJhbmNob3JZIil9c2V0IGFuY2hvclkoTyl7dGhpc1toXSgiYW5jaG9yWSIsT2JqZWN0KGkudG9OdW1iZXIpKE8pKX1nZXQgYW5jaG9yKCl7cmV0dXJuW3RoaXMuYW5jaG9yWCx0aGlzLmFuY2hvclldfXNldCBhbmNob3IoTyl7Tz1PYmplY3QoaS50b0FycmF5KShPKSxBcnJheS5pc0FycmF5KE8pfHwoTz1bTyxPXSksdGhpcy5hbmNob3JYPU9bMF0sdGhpcy5hbmNob3JZPU9bMV19Z2V0IHdpZHRoKCl7cmV0dXJuIHRoaXNbdV0oIndpZHRoIil9c2V0IHdpZHRoKE8pe3RoaXNbaF0oIndpZHRoIixPYmplY3QoaS50b051bWJlcikoTykpfWdldCBoZWlnaHQoKXtyZXR1cm4gdGhpc1t1XSgiaGVpZ2h0Iil9c2V0IGhlaWdodChPKXt0aGlzW2hdKCJoZWlnaHQiLE9iamVjdChpLnRvTnVtYmVyKShPKSl9Z2V0IHNpemUoKXtyZXR1cm5bdGhpcy53aWR0aCx0aGlzLmhlaWdodF19c2V0IHNpemUoTyl7Tz1PYmplY3QoaS50b0FycmF5KShPKSxBcnJheS5pc0FycmF5KE8pfHwoTz1bTyxPXSksdGhpcy53aWR0aD1PWzBdLHRoaXMuaGVpZ2h0PU9bMV19Z2V0IGJvcmRlcldpZHRoKCl7cmV0dXJuIHRoaXNbdV0oImJvcmRlcldpZHRoIil9c2V0IGJvcmRlcldpZHRoKE8pe3RoaXNbaF0oImJvcmRlcldpZHRoIixPYmplY3QoaS50b051bWJlcikoTykpfWdldCBib3JkZXJDb2xvcigpe3JldHVybiB0aGlzW3VdKCJib3JkZXJDb2xvciIpfXNldCBib3JkZXJDb2xvcihPKXt0aGlzW2hdKCJib3JkZXJDb2xvciIsT2JqZWN0KGYucGFyc2VDb2xvcikoTykpfWdldCBib3JkZXIoKXtyZXR1cm5bdGhpcy5ib3JkZXJXaWR0aCx0aGlzLmJvcmRlckNvbG9yXX1zZXQgYm9yZGVyKE8pe089T2JqZWN0KGkudG9BcnJheSkoTyksQXJyYXkuaXNBcnJheShPKXx8KE89W09dKSx0aGlzLmJvcmRlcldpZHRoPU9bMF0sT1sxXSE9bnVsbCYmKHRoaXMuYm9yZGVyQ29sb3I9T1sxXSl9Z2V0IGJvcmRlckRhc2goKXtyZXR1cm4gdGhpc1t1XSgiYm9yZGVyRGFzaCIpfXNldCBib3JkZXJEYXNoKE8pe089T2JqZWN0KGkudG9BcnJheSkoTywhMCksTyE9bnVsbCYmIUFycmF5LmlzQXJyYXkoTykmJihPPVtPXSksdGhpc1toXSgiYm9yZGVyRGFzaCIsTz9PLm1hcChpLnRvTnVtYmVyKTpudWxsKX1nZXQgYm9yZGVyRGFzaE9mZnNldCgpe3JldHVybiB0aGlzW3VdKCJib3JkZXJEYXNoT2Zmc2V0Iil9c2V0IGJvcmRlckRhc2hPZmZzZXQoTyl7dGhpc1toXSgiYm9yZGVyRGFzaE9mZnNldCIsT2JqZWN0KGkudG9OdW1iZXIpKE8pKX1nZXQgYm9yZGVyVG9wTGVmdFJhZGl1cygpe3JldHVybiB0aGlzW3VdKCJib3JkZXJUb3BMZWZ0UmFkaXVzIil9c2V0IGJvcmRlclRvcExlZnRSYWRpdXMoTyl7Tz1PYmplY3QoaS50b0FycmF5KShPLCEwKSxBcnJheS5pc0FycmF5KE8pfHwoTz1bTyxPXSksdGhpc1toXSgiYm9yZGVyVG9wTGVmdFJhZGl1cyIsTy5tYXAoaS50b051bWJlcikpfWdldCBib3JkZXJUb3BSaWdodFJhZGl1cygpe3JldHVybiB0aGlzW3VdKCJib3JkZXJUb3BSaWdodFJhZGl1cyIpfXNldCBib3JkZXJUb3BSaWdodFJhZGl1cyhPKXtPPU9iamVjdChpLnRvQXJyYXkpKE8sITApLEFycmF5LmlzQXJyYXkoTyl8fChPPVtPLE9dKSx0aGlzW2hdKCJib3JkZXJUb3BSaWdodFJhZGl1cyIsTy5tYXAoaS50b051bWJlcikpfWdldCBib3JkZXJCb3R0b21SaWdodFJhZGl1cygpe3JldHVybiB0aGlzW3VdKCJib3JkZXJCb3R0b21SaWdodFJhZGl1cyIpfXNldCBib3JkZXJCb3R0b21SaWdodFJhZGl1cyhPKXtPPU9iamVjdChpLnRvQXJyYXkpKE8sITApLEFycmF5LmlzQXJyYXkoTyl8fChPPVtPLE9dKSx0aGlzW2hdKCJib3JkZXJCb3R0b21SaWdodFJhZGl1cyIsTy5tYXAoaS50b051bWJlcikpfWdldCBib3JkZXJCb3R0b21MZWZ0UmFkaXVzKCl7cmV0dXJuIHRoaXNbdV0oImJvcmRlckJvdHRvbUxlZnRSYWRpdXMiKX1zZXQgYm9yZGVyQm90dG9tTGVmdFJhZGl1cyhPKXtPPU9iamVjdChpLnRvQXJyYXkpKE8sITApLEFycmF5LmlzQXJyYXkoTyl8fChPPVtPLE9dKSx0aGlzW2hdKCJib3JkZXJCb3R0b21MZWZ0UmFkaXVzIixPLm1hcChpLnRvTnVtYmVyKSl9Z2V0IGJvcmRlclJhZGl1cygpe3JldHVyblsuLi50aGlzLmJvcmRlclRvcExlZnRSYWRpdXMsLi4udGhpcy5ib3JkZXJUb3BSaWdodFJhZGl1cywuLi50aGlzLmJvcmRlckJvdHRvbVJpZ2h0UmFkaXVzLC4uLnRoaXMuYm9yZGVyQm90dG9tTGVmdFJhZGl1c119c2V0IGJvcmRlclJhZGl1cyhPKXtpZihPPU9iamVjdChpLnRvQXJyYXkpKE8pLCFBcnJheS5pc0FycmF5KE8pKU89QXJyYXkoOCkuZmlsbChPKTtlbHNlIGlmKE8ubGVuZ3RoPT09MilPPVtPWzBdLE9bMV0sT1swXSxPWzFdLE9bMF0sT1sxXSxPWzBdLE9bMV1dO2Vsc2UgaWYoTy5sZW5ndGg9PT00KU89W09bMF0sT1sxXSxPWzJdLE9bM10sT1swXSxPWzFdLE9bMl0sT1szXV07ZWxzZSBpZihPLmxlbmd0aD09PTYpTz1bT1swXSxPWzFdLE9bMl0sT1szXSxPWzRdLE9bNV0sT1syXSxPWzNdXTtlbHNlIGlmKE8ubGVuZ3RoIT09OCl0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIGJvcmRlclJhZGl1cyB2YWx1ZS4iKTt0aGlzLmJvcmRlclRvcExlZnRSYWRpdXM9W09bMF0sT1sxXV0sdGhpcy5ib3JkZXJUb3BSaWdodFJhZGl1cz1bT1syXSxPWzNdXSx0aGlzLmJvcmRlckJvdHRvbVJpZ2h0UmFkaXVzPVtPWzRdLE9bNV1dLHRoaXMuYm9yZGVyQm90dG9tTGVmdFJhZGl1cz1bT1s2XSxPWzddXX1nZXQgYmdjb2xvcigpe3JldHVybiB0aGlzW3VdKCJiZ2NvbG9yIil9c2V0IGJnY29sb3IoTyl7dGhpc1toXSgiYmdjb2xvciIsT2JqZWN0KGYucGFyc2VDb2xvcikoTykpfWdldCBwYWRkaW5nVG9wKCl7cmV0dXJuIHRoaXNbdV0oInBhZGRpbmdUb3AiKX1zZXQgcGFkZGluZ1RvcChPKXt0aGlzW2hdKCJwYWRkaW5nVG9wIixPYmplY3QoaS50b051bWJlcikoTykpfWdldCBwYWRkaW5nUmlnaHQoKXtyZXR1cm4gdGhpc1t1XSgicGFkZGluZ1JpZ2h0Iil9c2V0IHBhZGRpbmdSaWdodChPKXt0aGlzW2hdKCJwYWRkaW5nUmlnaHQiLE9iamVjdChpLnRvTnVtYmVyKShPKSl9Z2V0IHBhZGRpbmdCb3R0b20oKXtyZXR1cm4gdGhpc1t1XSgicGFkZGluZ0JvdHRvbSIpfXNldCBwYWRkaW5nQm90dG9tKE8pe3RoaXNbaF0oInBhZGRpbmdCb3R0b20iLE9iamVjdChpLnRvTnVtYmVyKShPKSl9Z2V0IHBhZGRpbmdMZWZ0KCl7cmV0dXJuIHRoaXNbdV0oInBhZGRpbmdMZWZ0Iil9c2V0IHBhZGRpbmdMZWZ0KE8pe3RoaXNbaF0oInBhZGRpbmdMZWZ0IixPYmplY3QoaS50b051bWJlcikoTykpfWdldCBwYWRkaW5nKCl7cmV0dXJuW3RoaXMucGFkZGluZ1RvcCx0aGlzLnBhZGRpbmdSaWdodCx0aGlzLnBhZGRpbmdCb3R0b20sdGhpcy5wYWRkaW5nTGVmdF19c2V0IHBhZGRpbmcoTyl7Tz1PYmplY3QoaS50b0FycmF5KShPKSxBcnJheS5pc0FycmF5KE8pP08ubGVuZ3RoPT09Mj9PPVtPWzBdLE9bMV0sT1swXSxPWzFdXTpPLmxlbmd0aD09PTMmJihPPVtPWzBdLE9bMV0sT1syXSxPWzFdXSk6Tz1bTyxPLE8sT10sdGhpcy5wYWRkaW5nVG9wPU9bMF0sdGhpcy5wYWRkaW5nUmlnaHQ9T1sxXSx0aGlzLnBhZGRpbmdCb3R0b209T1syXSx0aGlzLnBhZGRpbmdMZWZ0PU9bM119Z2V0IGNsaXBQYXRoKCl7cmV0dXJuIHRoaXNbdV0oImNsaXBQYXRoIil9c2V0IGNsaXBQYXRoKE8pe3RoaXNbaF0oImNsaXBQYXRoIixPKX1nZXQgYm94U2l6aW5nKCl7cmV0dXJuIHRoaXNbdV0oImJveFNpemluZyIpfXNldCBib3hTaXppbmcoTyl7aWYoTyE9bnVsbCYmTyE9PSJib3JkZXItYm94IiYmTyE9PSJjb250ZW50LWJveCIpdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCBib3hTaXppbmcgdHlwZS4iKTt0aGlzW2hdKCJib3hTaXppbmciLE8pfX19LGZ1bmN0aW9uKGcsZSx0KXt0LnIoZSksdC5kKGUsIkdyYWRpZW50IixmdW5jdGlvbigpe3JldHVybiBmfSksdC5kKGUsImlzVHJhbnNwYXJlbnQiLGZ1bmN0aW9uKCl7cmV0dXJuIGh9KSx0LmQoZSwicGFyc2VDb2xvciIsZnVuY3Rpb24oKXtyZXR1cm4gdX0pLHQuZChlLCJzZXRGaWxsQ29sb3IiLGZ1bmN0aW9uKCl7cmV0dXJuIGR9KSx0LmQoZSwic2V0U3Ryb2tlQ29sb3IiLGZ1bmN0aW9uKCl7cmV0dXJuIEV9KSx0LmQoZSwiQ29sb3IiLGZ1bmN0aW9uKCl7cmV0dXJuIHB9KTt2YXIgbj10KDMyKSxpPXQubihuKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y2xhc3MgZntjb25zdHJ1Y3Rvcih7dmVjdG9yOm0sY29sb3JzOmJ9KXtpZighQXJyYXkuaXNBcnJheShtKXx8bS5sZW5ndGghPT00JiZtLmxlbmd0aCE9PTYmJm0ubGVuZ3RoIT09Myl0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIGdyYWRpZW50Iik7dGhpcy52ZWN0b3I9bSx0aGlzLmNvbG9ycz1iLm1hcCgoe29mZnNldDpNLGNvbG9yOnl9KT0+KHtvZmZzZXQ6TSxjb2xvcjp1KHkpfSkpfXRvU3RyaW5nKCl7cmV0dXJuIEpTT04uc3RyaW5naWZ5KHt2ZWN0b3I6dGhpcy52ZWN0b3IsY29sb3JzOnRoaXMuY29sb3JzfSl9fWZ1bmN0aW9uIGgoTyl7cmV0dXJuIE8gaW5zdGFuY2VvZiBmPyExOk89PW51bGw/ITA6aSgpKE8pWzNdPT09MH1mdW5jdGlvbiB1KE8pe2lmKE89PW51bGx8fChPfHwoTz0idHJhbnNwYXJlbnQiKSxPIGluc3RhbmNlb2YgZikpcmV0dXJuIE87Y29uc3QgbT1pKCkoTyk7aWYoIW18fCFtLmxlbmd0aCl0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIGNvbG9yIHZhbHVlLiIpO3JldHVybmByZ2JhKCR7bS5qb2luKCl9KWB9ZnVuY3Rpb24gYShPLG0sYil7Y29uc3QgTT1PLmJvdW5kaW5nQm94WzBdO2lmKGIudmVjdG9yKXtsZXR7dmVjdG9yOnksY29sb3JzOlN9PWI7eS5sZW5ndGg9PT00Pyh5PVt5WzBdK01bMF0seVsxXStNWzFdLHlbMl0rTVswXSx5WzNdK01bMV1dLE8uc2V0TGluZWFyR3JhZGllbnQoe3ZlY3Rvcjp5LGNvbG9yczpTLHR5cGU6bX0pKTp5Lmxlbmd0aD09PTM/KHk9W3lbMF0rTVswXSx5WzFdK01bMV0seVsyXV0sTy5zZXRDaXJjdWxhckdyYWRpZW50KHt2ZWN0b3I6eSxjb2xvcnM6Uyx0eXBlOm19KSk6KHk9W3lbMF0rTVswXSx5WzFdK01bMV0seVsyXSx5WzNdK01bMF0seVs0XStNWzFdLHlbNV1dLE8uc2V0UmFkaWFsR3JhZGllbnQoe3ZlY3Rvcjp5LGNvbG9yczpTLHR5cGU6bX0pKX1lbHNlIE8uZ3JhZGllbnQmJk8uZ3JhZGllbnRbbV0mJihkZWxldGUgTy5ncmFkaWVudFttXSxkZWxldGUgTy51bmlmb3Jtcy51X3JhZGlhbEdyYWRpZW50VmVjdG9yKX1mdW5jdGlvbiBkKE8se2NvbG9yOm0scnVsZTpiPSJub256ZXJvIn0pe3JldHVybiBhKE8sImZpbGwiLG0pLG0udmVjdG9yfHxPLnNldEZpbGwoe2NvbG9yOm0scnVsZTpifSksT31mdW5jdGlvbiBFKE8se2NvbG9yOm0sbGluZVdpZHRoOmIsbGluZUNhcDpNLGxpbmVKb2luOnksbGluZURhc2g6UyxsaW5lRGFzaE9mZnNldDpzLG1pdGVyTGltaXQ6Yyxyb3VuZFNlZ21lbnRzOmx9KXthKE8sInN0cm9rZSIsbSksbS52ZWN0b3ImJihtPVswLDAsMCwxXSksTy5zZXRTdHJva2Uoe2NvbG9yOm0sdGhpY2tuZXNzOmIsY2FwOk0sam9pbjp5LG1pdGVyTGltaXQ6YyxsaW5lRGFzaDpTLGxpbmVEYXNoT2Zmc2V0OnMscm91bmRTZWdtZW50czpsfSl9Y2xhc3MgcCBleHRlbmRzIEFycmF5e2NvbnN0cnVjdG9yKG09MCxiPTAsTT0wLHk9MCl7cmV0dXJuIEFycmF5LmlzQXJyYXkobSkmJihbbSxiLE0seV09bSksdHlwZW9mIG09PSJzdHJpbmciJiYoW20sYixNLHldPWkoKShtKSxtLz0yNTUsYi89MjU1LE0vPTI1NSksc3VwZXIobSxiLE0seSksdGhpc31nZXQgcigpe3JldHVybiBNYXRoLnJvdW5kKHRoaXNbMF0qMjU1KX1zZXQgcihtKXt0aGlzWzBdPW0vMjU1fWdldCBnKCl7cmV0dXJuIE1hdGgucm91bmQodGhpc1sxXSoyNTUpfXNldCBnKG0pe3RoaXNbMV09bS8yNTV9Z2V0IGIoKXtyZXR1cm4gTWF0aC5yb3VuZCh0aGlzWzJdKjI1NSl9c2V0IGIobSl7dGhpc1syXT1tLzI1NX1nZXQgYSgpe3JldHVybiB0aGlzWzNdfXNldCBhKG0pe3RoaXNbM109bX1nZXQgaGV4KCl7Y29uc3QgbT1gMCR7dGhpcy5yLnRvU3RyaW5nKDE2KX1gLnNsaWNlKC0yKSxiPWAwJHt0aGlzLmcudG9TdHJpbmcoMTYpfWAuc2xpY2UoLTIpLE09YDAke3RoaXMuYi50b1N0cmluZygxNil9YC5zbGljZSgtMik7bGV0IHk7cmV0dXJuIHRoaXMuYTwxJiYoeT1NYXRoLnJvdW5kKHRoaXNbM10qMjU1KSx5PWAwJHt5LnRvU3RyaW5nKDE2KX1gLnNsaWNlKC0yKSksYCMke219JHtifSR7TX0ke3l8fCIifWB9Z2V0IHJnYmEoKXtyZXR1cm5gcmdiYSgke3RoaXMucn0sJHt0aGlzLmd9LCR7dGhpcy5ifSwke3RoaXMuYX0pYH1mcm9tQ29sb3IobSl7cmV0dXJuIHR5cGVvZiBtPT0ic3RyaW5nIiYmKG09aSgpKG0pLG1bMF0vPTI1NSxtWzFdLz0yNTUsbVsyXS89MjU1KSx0aGlzWzBdPW1bMF0sdGhpc1sxXT1tWzFdLHRoaXNbMl09bVsyXSx0aGlzWzNdPW1bM10sdGhpc319fSxmdW5jdGlvbihnLGUsdCl7dC5yKGUpLHQuZChlLCJjcmVhdGVSYWRpdXNCb3giLGZ1bmN0aW9uKCl7cmV0dXJuIGl9KSx0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gbihmLGgsdSxhLGQsRT0ibGVmdFRvcCIpe2NvbnN0IHA9LjU1MjI4NDgsTz1hLzIqcCxtPWQvMipwLGI9aCthLE09dStkLHk9aCthLzIsUz11K2QvMjtFPT09ImxlZnRUb3AiPyhmLm1vdmVUbyhoLFMpLGYuYmV6aWVyQ3VydmVUbyhoLFMtbSx5LU8sdSx5LHUpKTpFPT09InJpZ2h0VG9wIj9mLmJlemllckN1cnZlVG8oeStPLHUsYixTLW0sYixTKTpFPT09InJpZ2h0Qm90dG9tIj9mLmJlemllckN1cnZlVG8oYixTK20seStPLE0seSxNKTpFPT09ImxlZnRCb3R0b20iJiZmLmJlemllckN1cnZlVG8oeS1PLE0saCxTK20saCxTKX1mdW5jdGlvbiBpKGYsW2gsdSxhLGRdLEUpe2lmKCFFfHxBcnJheS5pc0FycmF5KEUpJiZFLmV2ZXJ5KHA9PnA9PT0wKSlmLmJlZ2luUGF0aCgpLGYucmVjdChoLHUsYSxkKTtlbHNle3R5cGVvZiBFPT0ibnVtYmVyIiYmKEU9QXJyYXkoOCkuZmlsbChFKSk7Y29uc3RbcCxPLG0sYixNLHksUyxzXT1FLm1hcCgoYyxsKT0+bCUyP01hdGgubWluKGMsZC8yKTpNYXRoLm1pbihjLGEvMikpO2YuYmVnaW5QYXRoKCksZi5tb3ZlVG8oaCx1K08pLG4oZixoLHUscCoyLE8qMiwibGVmdFRvcCIpLGYubGluZVRvKGgrYS1tLHUpLG4oZixoK2EtbSoyLHUsbSoyLGIqMiwicmlnaHRUb3AiKSxmLmxpbmVUbyhoK2EsdStkLXkpLG4oZixoK2EtTSoyLHUrZC15KjIsTSoyLHkqMiwicmlnaHRCb3R0b20iKSxmLmxpbmVUbyhoK1MsdStkKSxuKGYsaCx1K2QtcyoyLFMqMixzKjIsImxlZnRCb3R0b20iKSxmLmNsb3NlUGF0aCgpfXJldHVybiBmfX0sZnVuY3Rpb24oZyxlLHQpe3QucihlKSx0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSksZS5kZWZhdWx0PWZ1bmN0aW9uKG4saSl7aWYoIW4pcmV0dXJue3g6MCx5OjAsd2lkdGg6MCxoZWlnaHQ6MCxsZWZ0OjAsdG9wOjAscmlnaHQ6MCxib3R0b206MH07Y29uc3RbW2YsaF0sW3UsYV1dPW4sZD1mKmlbMF0raCppWzJdK2lbNF0sRT1mKmlbMV0raCppWzNdK2lbNV0scD11KmlbMF0raCppWzJdK2lbNF0sTz11KmlbMV0raCppWzNdK2lbNV0sbT11KmlbMF0rYSppWzJdK2lbNF0sYj11KmlbMV0rYSppWzNdK2lbNV0sTT1mKmlbMF0rYSppWzJdK2lbNF0seT1mKmlbMV0rYSppWzNdK2lbNV0sUz1NYXRoLm1pbihkLHAsbSxNKSxzPU1hdGgubWluKEUsTyxiLHkpLGM9TWF0aC5tYXgoZCxwLG0sTSksbD1NYXRoLm1heChFLE8sYix5KTtyZXR1cm57eDpTLHk6cyx3aWR0aDpjLVMsaGVpZ2h0OmwtcyxsZWZ0OlMsdG9wOnMscmlnaHQ6Yyxib3R0b206bH19fSxmdW5jdGlvbihnLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBkfSk7dmFyIG49dCgyMTgpLGk9dCgyMTkpLGY9dCgyMjUpLGg9dCgyMTMpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiB1KEUscCxPKXtyZXR1cm4gcCBpbiBFP09iamVjdC5kZWZpbmVQcm9wZXJ0eShFLHAse3ZhbHVlOk8sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTpFW3BdPU8sRX1jb25zdCBhPVN5bWJvbCgidGV4dHVyZVRhc2siKTtjbGFzcyBkIGV4dGVuZHMgaS5kZWZhdWx0e2NvbnN0cnVjdG9yKHA9e30pe3R5cGVvZiBwPT0ic3RyaW5nIiYmKHA9e3RleHR1cmU6cH0pLHN1cGVyKHApfWdldCBjb250ZW50U2l6ZSgpe2xldFtwLE9dPXN1cGVyLmNvbnRlbnRTaXplO2NvbnN0e3dpZHRoOm0saGVpZ2h0OmJ9PXRoaXMuYXR0cmlidXRlcztpZihtPT1udWxsfHxiPT1udWxsKXtjb25zdCBNPXRoaXMudGV4dHVyZUltYWdlLHk9dGhpcy5hdHRyaWJ1dGVzLnRleHR1cmVSZWN0LFM9dGhpcy5hdHRyaWJ1dGVzLnNvdXJjZVJlY3Q7aWYoeSltPT1udWxsJiYocD15WzBdK3lbMl0pLGI9PW51bGwmJihPPXlbMV0reVszXSk7ZWxzZSBpZihTKXtjb25zdCBzPXRoaXMubGF5ZXI/dGhpcy5sYXllci5kaXNwbGF5UmF0aW86MTttPT1udWxsJiYocD1TWzJdL3MpLGI9PW51bGwmJihPPVNbM10vcyl9ZWxzZSBpZihNKXtjb25zdCBzPXRoaXMubGF5ZXI/dGhpcy5sYXllci5kaXNwbGF5UmF0aW86MTttPT1udWxsJiYocD1NLndpZHRoL3MpLGI9PW51bGwmJihPPU0uaGVpZ2h0L3MpfX1yZXR1cm5bcCxPXX1nZXQgdGV4dHVyZUltYWdlUmVhZHkoKXtyZXR1cm4gdGhpc1thXXx8UHJvbWlzZS5yZXNvbHZlKCl9ZHJhdyhwPVtdKXtzdXBlci5kcmF3KHApO2NvbnN0IE89dGhpcy5tZXNoO3JldHVybiBPJiZPYmplY3Qobi5kcmF3VGV4dHVyZSkodGhpcyxPKSxwfW9uUHJvcGVydHlDaGFuZ2UocCxPLG0pe2lmKHN1cGVyLm9uUHJvcGVydHlDaGFuZ2UocCxPLG0pLHA9PT0idGV4dHVyZSImJih0aGlzW2FdPU9iamVjdChuLmFwcGx5VGV4dHVyZSkodGhpcyxPLCEwKSkscD09PSJ0ZXh0dXJlUmVjdCIpe2NvbnN0e3dpZHRoOmIsaGVpZ2h0Ok19PXRoaXMuYXR0cmlidXRlczsoYj09bnVsbHx8TT09bnVsbCkmJnRoaXMudXBkYXRlQ29udG91cnMoKX19fXUoZCwiQXR0ciIsZi5kZWZhdWx0KSxoLmRlZmF1bHQucmVnaXN0ZXJOb2RlKGQsInNwcml0ZSIpfSxmdW5jdGlvbihnLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiB1fSk7dmFyIG49dCgyMjApO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCBpPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZURlZmF1bHQiKSxmPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZSIpLGg9U3ltYm9sLmZvcigic3ByaXRlanNfZ2V0QXR0cmlidXRlIik7Y2xhc3MgdSBleHRlbmRzIG4uZGVmYXVsdHtjb25zdHJ1Y3RvcihkKXtzdXBlcihkKSx0aGlzW2ldKHt0ZXh0dXJlOnZvaWQgMCx0ZXh0dXJlUmVjdDp2b2lkIDAsdGV4dHVyZVJlcGVhdDohMSxzb3VyY2VSZWN0OnZvaWQgMH0pfWdldCB0ZXh0dXJlKCl7cmV0dXJuIHRoaXNbaF0oInRleHR1cmUiKX1zZXQgdGV4dHVyZShkKXt0aGlzW2ZdKCJ0ZXh0dXJlIixkKX1nZXQgdGV4dHVyZVJlY3QoKXtyZXR1cm4gdGhpc1toXSgidGV4dHVyZVJlY3QiKX1zZXQgdGV4dHVyZVJlY3QoZCl7dGhpc1tmXSgidGV4dHVyZVJlY3QiLGQpfWdldCBzb3VyY2VSZWN0KCl7cmV0dXJuIHRoaXNbaF0oInNvdXJjZVJlY3QiKX1zZXQgc291cmNlUmVjdChkKXt0aGlzW2ZdKCJzb3VyY2VSZWN0IixkKX1nZXQgdGV4dHVyZVJlcGVhdCgpe3JldHVybiB0aGlzW2hdKCJ0ZXh0dXJlUmVwZWF0Iil9c2V0IHRleHR1cmVSZXBlYXQoZCl7dGhpc1tmXSgidGV4dHVyZVJlcGVhdCIsISFkKX19fSxmdW5jdGlvbihnLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBifSk7dmFyIG49dCgxMiksaT10KDIyNyksZj10Lm4oaSksaD10KDcwKSx1PXQoMjI4KSxhPXQoMjIxKSxkPXQoMjE4KSxFPXQoMjEzKSxwPXQoMjIzKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gTyhNLHksUyl7cmV0dXJuIHkgaW4gTT9PYmplY3QuZGVmaW5lUHJvcGVydHkoTSx5LHt2YWx1ZTpTLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6TVt5XT1TLE19Y29uc3QgbT1TeW1ib2woIm1lc2giKTtjbGFzcyBiIGV4dGVuZHMgaC5kZWZhdWx0e2NvbnN0cnVjdG9yKHk9e30pe3R5cGVvZiB5PT0ic3RyaW5nIiYmKHk9e2Q6eX0pLHN1cGVyKHkpLHRoaXMuZWZmZWN0cz17ZChTLHMsYyxsLHYpe2NvbnN0IFQ9KGMtbCkvKHYtbCk7aWYoVDw9MClyZXR1cm4gUztpZihUPj0xKXJldHVybiBzO2NvbnN0IFI9Zi5hLl9wcmVwcm9jZXNzaW5nKGYuYS5wYXRoMnNoYXBlcyhTKSxmLmEucGF0aDJzaGFwZXMocykpLEw9Zi5hLl9sZXJwKC4uLlIsVClbMF07cmV0dXJuIEwucmVkdWNlKChBLHcpPT5gJHtBfSR7dy5zbGljZSgyKS5qb2luKCIgIil9IGAsYE0ke0xbMF1bMF19ICR7TFswXVsxXX1DYCkudHJpbSgpfX19Z2V0IGlzVmlzaWJsZSgpe3JldHVybiEhdGhpcy5kfWdldCBtZXNoKCl7aWYodGhpcy5hdHRyaWJ1dGVzLmRpc3BsYXk9PT0ibm9uZSIpcmV0dXJuIG51bGw7Y29uc3QgeT10aGlzLnBhdGg7aWYoeSl7bGV0IFM9dGhpc1ttXTtpZihTKVMucGF0aCE9PXkmJihTLmNvbnRvdXJzPXkuY29udG91cnMsUy5wYXRoPXkpO2Vsc2V7Uz1uZXcgbi5NZXNoMkQodGhpcy5wYXRoKSxTLnBhdGg9eTtjb25zdCBjPXRoaXMuYXR0cmlidXRlcy5maWxsQ29sb3IsbD10aGlzLmF0dHJpYnV0ZXMuZmlsbFJ1bGU7YyYmT2JqZWN0KGEuc2V0RmlsbENvbG9yKShTLHtjb2xvcjpjLHJ1bGU6bH0pO2NvbnN0IHY9dGhpcy5hdHRyaWJ1dGVzLmxpbmVXaWR0aCxUPXRoaXMuYXR0cmlidXRlcy5zdHJva2VDb2xvcjtpZihUJiZ2PjApe2NvbnN0e2xpbmVDYXA6TCxsaW5lSm9pbjpOLG1pdGVyTGltaXQ6QSxsaW5lRGFzaDp3LGxpbmVEYXNoT2Zmc2V0OkIscm91bmRTZWdtZW50czpEfT10aGlzLmF0dHJpYnV0ZXM7T2JqZWN0KGEuc2V0U3Ryb2tlQ29sb3IpKFMse2NvbG9yOlQsbGluZVdpZHRoOnYsbGluZUNhcDpMLGxpbmVKb2luOk4sbWl0ZXJMaW1pdDpBLGxpbmVEYXNoOncsbGluZURhc2hPZmZzZXQ6Qixyb3VuZFNlZ21lbnRzOkR9KX10aGlzW21dPVM7Y29uc3QgUj10aGlzLmF0dHJpYnV0ZXMuY2xpcFBhdGg7UiYmdGhpc1ttXS5zZXRDbGlwUGF0aChSKX1jb25zdCBzPXRoaXMub3BhY2l0eTtyZXR1cm4gUy5nZXRPcGFjaXR5KCkhPT1zJiZTLnNldE9wYWNpdHkocyksUy5zZXRUcmFuc2Zvcm0oLi4udGhpcy5yZW5kZXJNYXRyaXgpLFN9cmV0dXJuIG51bGx9Z2V0IG9yaWdpbmFsQ29udGVudFJlY3QoKXtpZih0aGlzLnBhdGgpe2NvbnN0IHk9dGhpcy5wYXRoLmJvdW5kaW5nQm94O3JldHVyblt5WzBdWzBdLHlbMF1bMV0seVsxXVswXS15WzBdWzBdLHlbMV1bMV0teVswXVsxXV19cmV0dXJuWzAsMCwwLDBdfWdldCBvcmlnaW5hbENsaWVudFJlY3QoKXtpZih0aGlzLm1lc2gpe2NvbnN0IHk9dGhpcy5tZXNoLmJvdW5kaW5nQm94O3JldHVyblt5WzBdWzBdLHlbMF1bMV0seVsxXVswXS15WzBdWzBdLHlbMV1bMV0teVswXVsxXV19cmV0dXJuWzAsMCwwLDBdfWdldCBvcmlnaW5hbENsaWVudENlbnRlcigpe3JldHVybiB0aGlzLm1lc2g/dGhpcy5tZXNoLmJvdW5kaW5nQ2VudGVyOlswLDBdfXNldCBkKHkpe3RoaXMuYXR0cmlidXRlcy5kPXl9Z2V0IGQoKXtyZXR1cm4gdGhpcy5hdHRyaWJ1dGVzLmR9ZHJhdyh5PVtdKXtzdXBlci5kcmF3KHkpO2NvbnN0IFM9dGhpcy5tZXNoO3JldHVybiBTJiZPYmplY3QoZC5kcmF3VGV4dHVyZSkodGhpcyxTKSx5fWdldEJvdW5kaW5nQ2xpZW50UmVjdCgpe2xldCB5PW51bGw7cmV0dXJuIHRoaXMubWVzaCYmKHk9dGhpcy5tZXNoLmJvdW5kaW5nQm94KSxPYmplY3QocC5kZWZhdWx0KSh5LHRoaXMucmVuZGVyTWF0cml4KX1nZXRQYXRoTGVuZ3RoKCl7cmV0dXJuIHRoaXMubWVzaD90aGlzLm1lc2guZ2V0VG90YWxMZW5ndGgoKTowfWdldFBvaW50QXRMZW5ndGgoeSl7aWYodGhpcy5tZXNoKXtjb25zdCBTPXRoaXMubWVzaC5nZXRQb2ludEF0TGVuZ3RoKHkpO2lmKFMpcmV0dXJuW1MueCxTLnldfXJldHVyblswLDBdfW9uUHJvcGVydHlDaGFuZ2UoeSxTLHMpe2lmKHN1cGVyLm9uUHJvcGVydHlDaGFuZ2UoeSxTLHMpLCh5PT09ImQifHx5PT09Im5vcm1hbGl6ZSIpJiZ0aGlzLnVwZGF0ZUNvbnRvdXJzKCksdGhpc1ttXSYmKHk9PT0iZmlsbENvbG9yInx8eT09PSJmaWxsUnVsZSIpKXtjb25zdHtmaWxsQ29sb3I6YyxmaWxsUnVsZTpsfT10aGlzLmF0dHJpYnV0ZXM7T2JqZWN0KGEuc2V0RmlsbENvbG9yKSh0aGlzW21dLHtjb2xvcjpjLHJ1bGU6bH0pfWlmKHRoaXNbbV0mJih5PT09InN0cm9rZUNvbG9yInx8eT09PSJsaW5lV2lkdGgifHx5PT09ImxpbmVDYXAifHx5PT09ImxpbmVKb2luInx8eT09PSJsaW5lRGFzaCJ8fHk9PT0ibGluZURhc2hPZmZzZXQifHx5PT09InJvdW5kU2VnbWVudHMiKSl7Y29uc3R7c3Ryb2tlQ29sb3I6YyxsaW5lV2lkdGg6bH09dGhpcy5hdHRyaWJ1dGVzO2lmKGMmJmw+MCl7Y29uc3R7bGluZUNhcDp2LGxpbmVKb2luOlQsbGluZURhc2g6UixsaW5lRGFzaE9mZnNldDpMLG1pdGVyTGltaXQ6Tixyb3VuZFNlZ21lbnRzOkF9PXRoaXMuYXR0cmlidXRlcztPYmplY3QoYS5zZXRTdHJva2VDb2xvcikodGhpc1ttXSx7Y29sb3I6YyxsaW5lQ2FwOnYsbGluZUpvaW46VCxsaW5lV2lkdGg6bCxsaW5lRGFzaDpSLGxpbmVEYXNoT2Zmc2V0OkwsbWl0ZXJMaW1pdDpOLHJvdW5kU2VnbWVudHM6QX0pfX10aGlzW21dJiZ5PT09ImNsaXBQYXRoIiYmdGhpc1ttXS5zZXRDbGlwUGF0aChTKSx5PT09InRleHR1cmUiJiZPYmplY3QoZC5hcHBseVRleHR1cmUpKHRoaXMsUyl9dXBkYXRlQ29udG91cnMoKXt0aGlzLnBhdGg9bmV3IG4uRmlndXJlMkQsdGhpcy5wYXRoLmFkZFBhdGgodGhpcy5hdHRyaWJ1dGVzLmQpLHRoaXMuYXR0cmlidXRlcy5ub3JtYWxpemUmJnRoaXMucGF0aC5ub3JtYWxpemUoLi4udGhpcy5wYXRoLmJvdW5kaW5nQ2VudGVyKX19TyhiLCJBdHRyIix1LmRlZmF1bHQpLEUuZGVmYXVsdC5yZWdpc3Rlck5vZGUoYiwicGF0aCIpfSxmdW5jdGlvbihnLGUsdCl7KGZ1bmN0aW9uKG4saSl7Zy5leHBvcnRzPWkoKX0pKHRoaXMsZnVuY3Rpb24oKXt2YXIgbj1mdW5jdGlvbigpe2Z1bmN0aW9uIHcoQixEKXt2YXIgST1bXSxqPSEwLFY9ITEsSj12b2lkIDA7dHJ5e2Zvcih2YXIgXz1CW1N5bWJvbC5pdGVyYXRvcl0oKSxzdDshKGo9KHN0PV8ubmV4dCgpKS5kb25lKSYmKEkucHVzaChzdC52YWx1ZSksIShEJiZJLmxlbmd0aD09PUQpKTtqPSEwKTt9Y2F0Y2goRyl7Vj0hMCxKPUd9ZmluYWxseXt0cnl7IWomJl8ucmV0dXJuJiZfLnJldHVybigpfWZpbmFsbHl7aWYoVil0aHJvdyBKfX1yZXR1cm4gSX1yZXR1cm4gZnVuY3Rpb24oQixEKXtpZihBcnJheS5pc0FycmF5KEIpKXJldHVybiBCO2lmKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoQikpcmV0dXJuIHcoQixEKTt0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlIil9fSgpLGk9TWF0aC5QSSoyLGY9ZnVuY3Rpb24oQixELEksaixWLEosXyl7dmFyIHN0PUIueCxHPUIueTtzdCo9RCxHKj1JO3ZhciBZPWoqc3QtVipHLHJ0PVYqc3QraipHO3JldHVybnt4OlkrSix5OnJ0K199fSxoPWZ1bmN0aW9uKEIsRCl7dmFyIEk9MS4zMzMzMzMzMzMzMzMzMzMzKk1hdGgudGFuKEQvNCksaj1NYXRoLmNvcyhCKSxWPU1hdGguc2luKEIpLEo9TWF0aC5jb3MoQitEKSxfPU1hdGguc2luKEIrRCk7cmV0dXJuW3t4OmotVipJLHk6VitqKkl9LHt4OkorXypJLHk6Xy1KKkl9LHt4OkoseTpffV19LHU9ZnVuY3Rpb24oQixELEksail7dmFyIFY9QipqLUQqSTwwPy0xOjEsSj1NYXRoLnNxcnQoQipCK0QqRCksXz1NYXRoLnNxcnQoQipCK0QqRCksc3Q9QipJK0QqaixHPXN0LyhKKl8pO3JldHVybiBHPjEmJihHPTEpLEc8LTEmJihHPS0xKSxWKk1hdGguYWNvcyhHKX0sYT1mdW5jdGlvbihCLEQsSSxqLFYsSixfLHN0LEcsWSxydCxvdCl7dmFyIGF0PU1hdGgucG93KFYsMiksaHQ9TWF0aC5wb3coSiwyKSxpdD1NYXRoLnBvdyhydCwyKSxNdD1NYXRoLnBvdyhvdCwyKSxPdD1hdCpodC1hdCpNdC1odCppdDtPdDwwJiYoT3Q9MCksT3QvPWF0Kk10K2h0Kml0LE90PU1hdGguc3FydChPdCkqKF89PT1zdD8tMToxKTt2YXIgVT1PdCpWL0oqb3QsJD1PdCotSi9WKnJ0LFE9WSpVLUcqJCsoQitJKS8yLHR0PUcqVStZKiQrKEQraikvMixGPShydC1VKS9WLEg9KG90LSQpL0oseD0oLXJ0LVUpL1YsUD0oLW90LSQpL0osVz11KDEsMCxGLEgpLEs9dShGLEgseCxQKTtyZXR1cm4gc3Q9PT0wJiZLPjAmJihLLT1pKSxzdD09PTEmJks8MCYmKEsrPWkpLFtRLHR0LFcsS119LGQ9ZnVuY3Rpb24oQil7dmFyIEQ9Qi5weCxJPUIucHksaj1CLmN4LFY9Qi5jeSxKPUIucngsXz1CLnJ5LHN0PUIueEF4aXNSb3RhdGlvbixHPXN0PT09dm9pZCAwPzA6c3QsWT1CLmxhcmdlQXJjRmxhZyxydD1ZPT09dm9pZCAwPzA6WSxvdD1CLnN3ZWVwRmxhZyxhdD1vdD09PXZvaWQgMD8wOm90LGh0PVtdO2lmKEo9PT0wfHxfPT09MClyZXR1cm5bXTt2YXIgaXQ9TWF0aC5zaW4oRyppLzM2MCksTXQ9TWF0aC5jb3MoRyppLzM2MCksT3Q9TXQqKEQtaikvMitpdCooSS1WKS8yLFU9LWl0KihELWopLzIrTXQqKEktVikvMjtpZihPdD09PTAmJlU9PT0wKXJldHVybltdO0o9TWF0aC5hYnMoSiksXz1NYXRoLmFicyhfKTt2YXIgJD1NYXRoLnBvdyhPdCwyKS9NYXRoLnBvdyhKLDIpK01hdGgucG93KFUsMikvTWF0aC5wb3coXywyKTskPjEmJihKKj1NYXRoLnNxcnQoJCksXyo9TWF0aC5zcXJ0KCQpKTt2YXIgUT1hKEQsSSxqLFYsSixfLHJ0LGF0LGl0LE10LE90LFUpLHR0PW4oUSw0KSxGPXR0WzBdLEg9dHRbMV0seD10dFsyXSxQPXR0WzNdLFc9TWF0aC5tYXgoTWF0aC5jZWlsKE1hdGguYWJzKFApLyhpLzQpKSwxKTtQLz1XO2Zvcih2YXIgSz0wO0s8VztLKyspaHQucHVzaChoKHgsUCkpLHgrPVA7cmV0dXJuIGh0Lm1hcChmdW5jdGlvbihaKXt2YXIgaz1mKFpbMF0sSixfLE10LGl0LEYsSCksbnQ9ay54LHV0PWsueSxjdD1mKFpbMV0sSixfLE10LGl0LEYsSCkscHQ9Y3QueCx4dD1jdC55LGd0PWYoWlsyXSxKLF8sTXQsaXQsRixIKSxkdD1ndC54LG10PWd0Lnk7cmV0dXJue3gxOm50LHkxOnV0LHgyOnB0LHkyOnh0LHg6ZHQseTptdH19KX0sRT17YTo3LGM6NixoOjEsbDoyLG06MixxOjQsczo0LHQ6Mix2OjEsejowfSxwPS8oW2FzdHZ6cW1obGNdKShbXmFzdHZ6cW1obGNdKikvaWc7ZnVuY3Rpb24gTyh3KXt2YXIgQj1bXTtyZXR1cm4gdy5yZXBsYWNlKHAsZnVuY3Rpb24oRCxJLGope3ZhciBWPUkudG9Mb3dlckNhc2UoKTtmb3Ioaj1iKGopLFY9PSJtIiYmai5sZW5ndGg+MiYmKEIucHVzaChbSV0uY29uY2F0KGouc3BsaWNlKDAsMikpKSxWPSJsIixJPUk9PSJtIj8ibCI6IkwiKTs7KXtpZihqLmxlbmd0aD09RVtWXSlyZXR1cm4gai51bnNoaWZ0KEkpLEIucHVzaChqKTtpZihqLmxlbmd0aDxFW1ZdKXRocm93IG5ldyBFcnJvcigibWFsZm9ybWVkIHBhdGggZGF0YSIpO0IucHVzaChbSV0uY29uY2F0KGouc3BsaWNlKDAsRVtWXSkpKX19KSxCfXZhciBtPS8tP1swLTldKlwuP1swLTldKyg/OmVbLStdP1xkKyk/L2lnO2Z1bmN0aW9uIGIodyl7dmFyIEI9dy5tYXRjaChtKTtyZXR1cm4gQj9CLm1hcChOdW1iZXIpOltdfWZ1bmN0aW9uIE0odyl7dmFyIEI9d1swXVswXSxEPXdbMF1bMV0sST1CLGo9RDtyZXR1cm4gdy5mb3JFYWNoKGZ1bmN0aW9uKFYpe3ZhciBKPVZbMF0sXz1WWzJdLHN0PVZbNF0sRz1WWzZdLFk9VlsxXSxydD1WWzNdLG90PVZbNV0sYXQ9Vls3XTtCPU1hdGgubWluKEIsSixfLHN0LEcpLEQ9TWF0aC5taW4oRCxZLHJ0LG90LGF0KSxJPU1hdGgubWF4KEksSixfLHN0LEcpLGo9TWF0aC5tYXgoaixZLHJ0LG90LGF0KX0pLFtCLEQsSSxqXX1mdW5jdGlvbiB5KHcsQil7cmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyh3WzBdLUJbMF0sMikrTWF0aC5wb3cod1sxXS1CWzFdLDIpKStNYXRoLnNxcnQoTWF0aC5wb3cod1syXS1CWzJdLDIpK01hdGgucG93KHdbM10tQlszXSwyKSl9ZnVuY3Rpb24gUyh3LEIpe3ZhciBEPXdbMF0sST13WzJdLGo9d1s0XSxWPXdbNl0sSj13WzFdLF89d1szXSxzdD13WzVdLEc9d1s3XSxZPUJbMF0scnQ9QlsyXSxvdD1CWzRdLGF0PUJbNl0saHQ9QlsxXSxpdD1CWzNdLE10PUJbNV0sT3Q9Qls3XTtyZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KFktRCwyKStNYXRoLnBvdyhodC1KLDIpKStNYXRoLnNxcnQoTWF0aC5wb3cocnQtSSwyKStNYXRoLnBvdyhpdC1fLDIpKStNYXRoLnNxcnQoTWF0aC5wb3cob3QtaiwyKStNYXRoLnBvdyhNdC1zdCwyKSkrTWF0aC5zcXJ0KE1hdGgucG93KGF0LVYsMikrTWF0aC5wb3coT3QtRywyKSl9ZnVuY3Rpb24gcyh3LEIpe3ZhciBEPWwody5sZW5ndGgpLEk9W107RC5mb3JFYWNoKGZ1bmN0aW9uKFYpe3ZhciBKPTAsXz0wO1YuZm9yRWFjaChmdW5jdGlvbihzdCl7Sis9Uyh3W3N0XSxCW18rK10pfSksSS5wdXNoKHtpbmRleDpWLGRpc3RhbmNlOkp9KX0pLEkuc29ydChmdW5jdGlvbihWLEope3JldHVybiBWLmRpc3RhbmNlLUouZGlzdGFuY2V9KTt2YXIgaj1bXTtyZXR1cm4gSVswXS5pbmRleC5mb3JFYWNoKGZ1bmN0aW9uKFYpe2oucHVzaCh3W1ZdKX0pLGp9ZnVuY3Rpb24gYyh3LEIpe3ZhciBEPXYody5sZW5ndGgpLEk9W107RC5mb3JFYWNoKGZ1bmN0aW9uKFYpe3ZhciBKPTA7Vi5mb3JFYWNoKGZ1bmN0aW9uKF8pe0orPXkoTSh3W19dKSxNKEJbX10pKX0pLEkucHVzaCh7aW5kZXg6VixkaXN0YW5jZTpKfSl9KSxJLnNvcnQoZnVuY3Rpb24oVixKKXtyZXR1cm4gVi5kaXN0YW5jZS1KLmRpc3RhbmNlfSk7dmFyIGo9W107cmV0dXJuIElbMF0uaW5kZXguZm9yRWFjaChmdW5jdGlvbihWKXtqLnB1c2god1tWXSl9KSxqfWZ1bmN0aW9uIGwodyl7Zm9yKHZhciBCPVtdLEQ9MDtEPHc7RCsrKXtmb3IodmFyIEk9W10saj0wO2o8dztqKyspe3ZhciBWPWorRDtWPnctMSYmKFYtPXcpLElbVl09an1CLnB1c2goSSl9cmV0dXJuIEJ9ZnVuY3Rpb24gdih3KXtmb3IodmFyIEI9W10sRD0wO0Q8dztEKyspQi5wdXNoKEQpO3JldHVybiBUKEIpfWZ1bmN0aW9uIFQodyl7dmFyIEI9W10sRD1bXTtmdW5jdGlvbiBJKGope3ZhciBWLEo7Zm9yKFY9MDtWPGoubGVuZ3RoO1YrKylKPWouc3BsaWNlKFYsMSlbMF0sRC5wdXNoKEopLGoubGVuZ3RoPT0wJiZCLnB1c2goRC5zbGljZSgpKSxJKGopLGouc3BsaWNlKFYsMCxKKSxELnBvcCgpO3JldHVybiBCfXJldHVybiBJKHcpfXZhciBSPXt9O1IucGFyc2VyPU8sUi5sZXJwQ3VydmU9ZnVuY3Rpb24odyxCLEQpe3JldHVybiBSLmxlcnBQb2ludHMod1swXSx3WzFdLEJbMF0sQlsxXSxEKS5jb25jYXQoUi5sZXJwUG9pbnRzKHdbMl0sd1szXSxCWzJdLEJbM10sRCkpLmNvbmNhdChSLmxlcnBQb2ludHMod1s0XSx3WzVdLEJbNF0sQls1XSxEKSkuY29uY2F0KFIubGVycFBvaW50cyh3WzZdLHdbN10sQls2XSxCWzddLEQpKX0sUi5sZXJwUG9pbnRzPWZ1bmN0aW9uKHcsQixELEksail7cmV0dXJuW3crKEQtdykqaixCKyhJLUIpKmpdfSxSLnEyYj1mdW5jdGlvbih3LEIsRCxJLGosVil7cmV0dXJuW3csQiwodysyKkQpLzMsKEIrMipJKS8zLChqKzIqRCkvMywoVisyKkkpLzMsaixWXX0sUi5wYXRoMnNoYXBlcz1mdW5jdGlvbih3KXtmb3IodmFyIEI9Ui5wYXJzZXIodyksRD0wLEk9MCxqPTAsVj1CLmxlbmd0aCxKPVtdLF89bnVsbCxzdD12b2lkIDAsRz12b2lkIDAsWT12b2lkIDAscnQ9dm9pZCAwLG90PXZvaWQgMCxhdD12b2lkIDAsaHQ9dm9pZCAwO2o8VjtqKyspe3ZhciBpdD1CW2pdLE10PWl0WzBdLE90PUJbai0xXTtzd2l0Y2goTXQpe2Nhc2UibSI6b3Q9Si5sZW5ndGgsSltvdF09W10sXz1KW290XSxEPUQraXRbMV0sST1JK2l0WzJdO2JyZWFrO2Nhc2UiTSI6b3Q9Si5sZW5ndGgsSltvdF09W10sXz1KW290XSxEPWl0WzFdLEk9aXRbMl07YnJlYWs7Y2FzZSJsIjpfLnB1c2goW0QsSSxELEksRCxJLEQraXRbMV0sSStpdFsyXV0pLEQrPWl0WzFdLEkrPWl0WzJdO2JyZWFrO2Nhc2UiTCI6Xy5wdXNoKFtELEksaXRbMV0saXRbMl0saXRbMV0saXRbMl0saXRbMV0saXRbMl1dKSxEPWl0WzFdLEk9aXRbMl07YnJlYWs7Y2FzZSJoIjpfLnB1c2goW0QsSSxELEksRCxJLEQraXRbMV0sSV0pLEQrPWl0WzFdO2JyZWFrO2Nhc2UiSCI6Xy5wdXNoKFtELEksaXRbMV0sSSxpdFsxXSxJLGl0WzFdLEldKSxEPWl0WzFdO2JyZWFrO2Nhc2UidiI6Xy5wdXNoKFtELEksRCxJLEQsSSxELEkraXRbMV1dKSxJKz1pdFsxXTticmVhaztjYXNlIlYiOl8ucHVzaChbRCxJLEQsaXRbMV0sRCxpdFsxXSxELGl0WzFdXSksST1pdFsxXTticmVhaztjYXNlIkMiOl8ucHVzaChbRCxJLGl0WzFdLGl0WzJdLGl0WzNdLGl0WzRdLGl0WzVdLGl0WzZdXSksRD1pdFs1XSxJPWl0WzZdO2JyZWFrO2Nhc2UiUyI6T3RbMF09PT0iQyJ8fE90WzBdPT09ImMiP18ucHVzaChbRCxJLEQrT3RbNV0tT3RbM10sSStPdFs2XS1PdFs0XSxpdFsxXSxpdFsyXSxpdFszXSxpdFs0XV0pOihPdFswXT09PSJTInx8T3RbMF09PT0icyIpJiZfLnB1c2goW0QsSSxEK090WzNdLU90WzFdLEkrT3RbNF0tT3RbMl0saXRbMV0saXRbMl0saXRbM10saXRbNF1dKSxEPWl0WzNdLEk9aXRbNF07YnJlYWs7Y2FzZSJjIjpfLnB1c2goW0QsSSxEK2l0WzFdLEkraXRbMl0sRCtpdFszXSxJK2l0WzRdLEQraXRbNV0sSStpdFs2XV0pLEQ9RCtpdFs1XSxJPUkraXRbNl07YnJlYWs7Y2FzZSJzIjpPdFswXT09PSJDInx8T3RbMF09PT0iYyI/Xy5wdXNoKFtELEksRCtPdFs1XS1PdFszXSxJK090WzZdLU90WzRdLEQraXRbMV0sSStpdFsyXSxEK2l0WzNdLEkraXRbNF1dKTooT3RbMF09PT0iUyJ8fE90WzBdPT09InMiKSYmXy5wdXNoKFtELEksRCtPdFszXS1PdFsxXSxJK090WzRdLU90WzJdLEQraXRbMV0sSStpdFsyXSxEK2l0WzNdLEkraXRbNF1dKSxEPUQraXRbM10sST1JK2l0WzRdO2JyZWFrO2Nhc2UiYSI6YXQ9ZCh7cng6aXRbMV0scnk6aXRbMl0scHg6RCxweTpJLHhBeGlzUm90YXRpb246aXRbM10sbGFyZ2VBcmNGbGFnOml0WzRdLHN3ZWVwRmxhZzppdFs1XSxjeDpEK2l0WzZdLGN5OkkraXRbN119KSxodD1hdFthdC5sZW5ndGgtMV0sYXQuZm9yRWFjaChmdW5jdGlvbihVLCQpeyQ9PT0wP18ucHVzaChbRCxJLFUueDEsVS55MSxVLngyLFUueTIsVS54LFUueV0pOl8ucHVzaChbYXRbJC0xXS54LGF0WyQtMV0ueSxVLngxLFUueTEsVS54MixVLnkyLFUueCxVLnldKX0pLEQ9aHQueCxJPWh0Lnk7YnJlYWs7Y2FzZSJBIjphdD1kKHtyeDppdFsxXSxyeTppdFsyXSxweDpELHB5OkkseEF4aXNSb3RhdGlvbjppdFszXSxsYXJnZUFyY0ZsYWc6aXRbNF0sc3dlZXBGbGFnOml0WzVdLGN4Oml0WzZdLGN5Oml0WzddfSksaHQ9YXRbYXQubGVuZ3RoLTFdLGF0LmZvckVhY2goZnVuY3Rpb24oVSwkKXskPT09MD9fLnB1c2goW0QsSSxVLngxLFUueTEsVS54MixVLnkyLFUueCxVLnldKTpfLnB1c2goW2F0WyQtMV0ueCxhdFskLTFdLnksVS54MSxVLnkxLFUueDIsVS55MixVLngsVS55XSl9KSxEPWh0LngsST1odC55O2JyZWFrO2Nhc2UiUSI6Xy5wdXNoKFIucTJiKEQsSSxpdFsxXSxpdFsyXSxpdFszXSxpdFs0XSkpLEQ9aXRbM10sST1pdFs0XTticmVhaztjYXNlInEiOl8ucHVzaChSLnEyYihELEksRCtpdFsxXSxJK2l0WzJdLGl0WzNdK0QsaXRbNF0rSSkpLEQrPWl0WzNdLEkrPWl0WzRdO2JyZWFrO2Nhc2UiVCI6T3RbMF09PT0iUSJ8fE90WzBdPT09InEiPyhZPUQrT3RbM10tT3RbMV0scnQ9SStPdFs0XS1PdFsyXSxfLnB1c2goUi5xMmIoRCxJLFkscnQsaXRbMV0saXRbMl0pKSk6KE90WzBdPT09IlQifHxPdFswXT09PSJ0IikmJihfLnB1c2goUi5xMmIoRCxJLEQrRC1ZLEkrSS1ydCxpdFsxXSxpdFsyXSkpLFk9RCtELVkscnQ9SStJLXJ0KSxEPWl0WzFdLEk9aXRbMl07YnJlYWs7Y2FzZSJ0IjpPdFswXT09PSJRInx8T3RbMF09PT0icSI/KFk9RCtPdFszXS1PdFsxXSxydD1JK090WzRdLU90WzJdLF8ucHVzaChSLnEyYihELEksWSxydCxEK2l0WzFdLEkraXRbMl0pKSk6KE90WzBdPT09IlQifHxPdFswXT09PSJ0IikmJihfLnB1c2goUi5xMmIoRCxJLEQrRC1ZLEkrSS1ydCxEK2l0WzFdLEkraXRbMl0pKSxZPUQrRC1ZLHJ0PUkrSS1ydCksRCs9aXRbMV0sSSs9aXRbMl07YnJlYWs7Y2FzZSJaIjpzdD1fWzBdWzBdLEc9X1swXVsxXSxfLnB1c2goW0QsSSxzdCxHLHN0LEcsc3QsR10pO2JyZWFrO2Nhc2UieiI6c3Q9X1swXVswXSxHPV9bMF1bMV0sXy5wdXNoKFtELEksc3QsRyxzdCxHLHN0LEddKTticmVha319cmV0dXJuIEp9LFIuX3VwQ3VydmVzPWZ1bmN0aW9uKHcsQil7Zm9yKHZhciBEPTAsST0wLGo9dy5sZW5ndGg7RDxCO0QrKyl3LnB1c2god1tJXS5zbGljZSgwKSksSSsrLEk+ai0xJiYoSS09ail9O2Z1bmN0aW9uIEwodyxCLEQsSSxqLFYsSixfLHN0KXtyZXR1cm57bGVmdDpOKHcsQixELEksaixWLEosXyxzdCkscmlnaHQ6TihKLF8saixWLEQsSSx3LEIsMS1zdCwhMCl9fWZ1bmN0aW9uIE4odyxCLEQsSSxqLFYsSixfLHN0LEcpe3ZhciBZPShELXcpKnN0K3cscnQ9KEktQikqc3QrQixvdD0oai1EKSpzdCtELGF0PShWLUkpKnN0K0ksaHQ9KEotaikqc3QraixpdD0oXy1WKSpzdCtWLE10PShvdC1ZKSpzdCtZLE90PShhdC1ydCkqc3QrcnQsVT0oaHQtb3QpKnN0K290LCQ9KGl0LWF0KSpzdCthdCxRPShVLU10KSpzdCtNdCx0dD0oJC1PdCkqc3QrT3Q7cmV0dXJuIEc/W1EsdHQsTXQsT3QsWSxydCx3LEJdOlt3LEIsWSxydCxNdCxPdCxRLHR0XX1SLl9zcGxpdEN1cnZlcz1mdW5jdGlvbih3LEIpe2Zvcih2YXIgRD0wLEk9MDtEPEI7RCsrKXt2YXIgaj13W0ldLFY9TChqWzBdLGpbMV0salsyXSxqWzNdLGpbNF0sals1XSxqWzZdLGpbN10sLjUpO3cuc3BsaWNlKEksMSksdy5zcGxpY2UoSSwwLFYubGVmdCxWLnJpZ2h0KSxJKz0yLEk+PXcubGVuZ3RoLTEmJihJPTApfX07ZnVuY3Rpb24gQSh3LEIpe2Zvcih2YXIgRD1mdW5jdGlvbihWKXt2YXIgSj13W3cubGVuZ3RoLTFdLF89W107Si5mb3JFYWNoKGZ1bmN0aW9uKHN0KXtfLnB1c2goc3Quc2xpY2UoMCkpfSksdy5wdXNoKF8pfSxJPTA7STxCO0krKylEKCl9cmV0dXJuIFIubGVycD1mdW5jdGlvbih3LEIsRCl7cmV0dXJuIFIuX2xlcnAoUi5wYXRoMnNoYXBlcyh3KSxSLnBhdGgyc2hhcGVzKEIpLEQpfSxSLk1JTV9DVVJWRVNfQ09VTlQ9MTAwLFIuX3ByZXByb2Nlc3Npbmc9ZnVuY3Rpb24odyxCKXt2YXIgRD13Lmxlbmd0aCxJPUIubGVuZ3RoLGo9SlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh3KSksVj1KU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KEIpKTtyZXR1cm4gRD5JP0EoVixELUkpOkQ8SSYmQShqLEktRCksaj1jKGosViksai5mb3JFYWNoKGZ1bmN0aW9uKEosXyl7dmFyIHN0PUoubGVuZ3RoLEc9VltfXS5sZW5ndGg7c3Q+Rz9zdDxSLk1JTV9DVVJWRVNfQ09VTlQ/KFIuX3NwbGl0Q3VydmVzKEosUi5NSU1fQ1VSVkVTX0NPVU5ULXN0KSxSLl9zcGxpdEN1cnZlcyhWW19dLFIuTUlNX0NVUlZFU19DT1VOVC1HKSk6Ui5fc3BsaXRDdXJ2ZXMoVltfXSxzdC1HKTpzdDxHJiYoRzxSLk1JTV9DVVJWRVNfQ09VTlQ/KFIuX3NwbGl0Q3VydmVzKEosUi5NSU1fQ1VSVkVTX0NPVU5ULXN0KSxSLl9zcGxpdEN1cnZlcyhWW19dLFIuTUlNX0NVUlZFU19DT1VOVC1HKSk6Ui5fc3BsaXRDdXJ2ZXMoSixHLXN0KSl9KSxqLmZvckVhY2goZnVuY3Rpb24oSixfKXtqW19dPXMoSixWW19dKX0pLFtqLFZdfSxSLl9sZXJwPWZ1bmN0aW9uKHcsQixEKXt2YXIgST1bXTtyZXR1cm4gdy5mb3JFYWNoKGZ1bmN0aW9uKGosVil7dmFyIEo9W107ai5mb3JFYWNoKGZ1bmN0aW9uKF8sc3Qpe0oucHVzaChSLmxlcnBDdXJ2ZShfLEJbVl1bc3RdLEQpKX0pLEkucHVzaChKKX0pLEl9LFIuYW5pbWF0ZT1mdW5jdGlvbih3KXt2YXIgQj1SLnBhdGgyc2hhcGVzKHcuZnJvbSksRD1SLnBhdGgyc2hhcGVzKHcudG8pLEk9Ui5fcHJlcHJvY2Vzc2luZyhCLEQpLGo9bmV3IERhdGUsVj13LmVuZHx8ZnVuY3Rpb24oKXt9LEo9dy5wcm9ncmVzc3x8ZnVuY3Rpb24oKXt9LF89dy5iZWdpbnx8ZnVuY3Rpb24oKXt9LHN0PXcuZWFzaW5nfHxmdW5jdGlvbihhdCl7cmV0dXJuIGF0fSxHPW51bGwsWT1udWxsLHJ0PXcudGltZTtfKEIpO3ZhciBvdD1mdW5jdGlvbiBhdCgpe3ZhciBodD1uZXcgRGF0ZS1qO2lmKGh0Pj1ydCl7WT1ELEooWSwxKSxWKFkpLGNhbmNlbEFuaW1hdGlvbkZyYW1lKEcpO3JldHVybn12YXIgaXQ9c3QoaHQvcnQpO1k9Ui5fbGVycChJWzBdLElbMV0saXQpLEooWSxpdCksRz1yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYXQpfTtvdCgpfSxSfSl9LGZ1bmN0aW9uKGcsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIGR9KTt2YXIgbj10KDcxKSxpPXQoMjIxKSxmPXQoNzIpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCBoPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZURlZmF1bHQiKSx1PVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZSIpLGE9U3ltYm9sLmZvcigic3ByaXRlanNfZ2V0QXR0cmlidXRlIik7Y2xhc3MgZCBleHRlbmRzIG4uZGVmYXVsdHtjb25zdHJ1Y3RvcihwKXtzdXBlcihwKSx0aGlzW2hdKHtkOiIiLG5vcm1hbGl6ZTohMSxmaWxsQ29sb3I6dm9pZCAwLGZpbGxSdWxlOiJub256ZXJvIixzdHJva2VDb2xvcjp2b2lkIDAsbGluZVdpZHRoOjEsbGluZUpvaW46Im1pdGVyIixsaW5lQ2FwOiJidXR0Iixyb3VuZFNlZ21lbnRzOjIwLGxpbmVEYXNoOnZvaWQgMCxsaW5lRGFzaE9mZnNldDowLG1pdGVyTGltaXQ6MTAsdGV4dHVyZTp2b2lkIDAsdGV4dHVyZVJlY3Q6dm9pZCAwLHRleHR1cmVSZXBlYXQ6ITEsc291cmNlUmVjdDp2b2lkIDAsY2xpcFBhdGg6dm9pZCAwfSl9Z2V0IGQoKXtyZXR1cm4gdGhpc1thXSgiZCIpfXNldCBkKHApe3RoaXNbdV0oImQiLHApfWdldCBub3JtYWxpemUoKXtyZXR1cm4gdGhpc1thXSgibm9ybWFsaXplIil9c2V0IG5vcm1hbGl6ZShwKXt0aGlzW3VdKCJub3JtYWxpemUiLCEhcCl9Z2V0IGZpbGxDb2xvcigpe3JldHVybiB0aGlzW2FdKCJmaWxsQ29sb3IiKX1zZXQgZmlsbENvbG9yKHApe3RoaXNbdV0oImZpbGxDb2xvciIsT2JqZWN0KGkucGFyc2VDb2xvcikocCkpfWdldCBmaWxsUnVsZSgpe3JldHVybiB0aGlzW2FdKCJmaWxsUnVsZSIpfXNldCBmaWxsUnVsZShwKXtpZihwIT1udWxsJiZwIT09Im5vbnplcm8iJiZwIT09ImV2ZW5vZGQiKXRocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgZmlsbCBydWxlLiIpO3RoaXNbdV0oImZpbGxSdWxlIixwKX1nZXQgc3Ryb2tlQ29sb3IoKXtyZXR1cm4gdGhpc1thXSgic3Ryb2tlQ29sb3IiKX1zZXQgc3Ryb2tlQ29sb3IocCl7dGhpc1t1XSgic3Ryb2tlQ29sb3IiLE9iamVjdChpLnBhcnNlQ29sb3IpKHApKX1nZXQgbGluZVdpZHRoKCl7cmV0dXJuIHRoaXNbYV0oImxpbmVXaWR0aCIpfXNldCBsaW5lV2lkdGgocCl7dGhpc1t1XSgibGluZVdpZHRoIixPYmplY3QoZi50b051bWJlcikocCkpfWdldCBsaW5lSm9pbigpe3JldHVybiB0aGlzW2FdKCJsaW5lSm9pbiIpfXNldCBsaW5lSm9pbihwKXtpZihwIT1udWxsJiZwIT09Im1pdGVyIiYmcCE9PSJiZXZlbCImJnAhPT0icm91bmQiKXRocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgbGluZUpvaW4gdHlwZS4iKTt0aGlzW3VdKCJsaW5lSm9pbiIscCl9Z2V0IGxpbmVDYXAoKXtyZXR1cm4gdGhpc1thXSgibGluZUNhcCIpfXNldCBsaW5lQ2FwKHApe2lmKHAhPW51bGwmJnAhPT0iYnV0dCImJnAhPT0ic3F1YXJlIiYmcCE9PSJyb3VuZCIpdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCBsaW5lQ2FwIHR5cGUuIik7dGhpc1t1XSgibGluZUNhcCIscCl9Z2V0IGxpbmVEYXNoKCl7cmV0dXJuIHRoaXNbYV0oImxpbmVEYXNoIil9c2V0IGxpbmVEYXNoKHApe3A9T2JqZWN0KGYudG9BcnJheSkocCwhMCkscCE9bnVsbCYmIUFycmF5LmlzQXJyYXkocCkmJihwPVtwXSksdGhpc1t1XSgibGluZURhc2giLHA/cC5tYXAoZi50b051bWJlcik6bnVsbCl9Z2V0IGxpbmVEYXNoT2Zmc2V0KCl7cmV0dXJuIHRoaXNbYV0oImxpbmVEYXNoT2Zmc2V0Iil9c2V0IGxpbmVEYXNoT2Zmc2V0KHApe3RoaXNbdV0oImxpbmVEYXNoT2Zmc2V0IixPYmplY3QoZi50b051bWJlcikocCkpfWdldCBtaXRlckxpbWl0KCl7cmV0dXJuIHRoaXNbYV0oIm1pdGVyTGltaXQiKX1zZXQgbWl0ZXJMaW1pdChwKXt0aGlzW3VdKCJtaXRlckxpbWl0IixPYmplY3QoZi50b051bWJlcikocCkpfWdldCByb3VuZFNlZ21lbnRzKCl7cmV0dXJuIHRoaXNbYV0oInJvdW5kU2VnbWVudHMiKX1zZXQgcm91bmRTZWdtZW50cyhwKXt0aGlzW3VdKCJyb3VuZFNlZ21lbnRzIixwKX1nZXQgdGV4dHVyZSgpe3JldHVybiB0aGlzW2FdKCJ0ZXh0dXJlIil9c2V0IHRleHR1cmUocCl7dGhpc1t1XSgidGV4dHVyZSIscCl9Z2V0IHRleHR1cmVSZWN0KCl7cmV0dXJuIHRoaXNbYV0oInRleHR1cmVSZWN0Iil9c2V0IHRleHR1cmVSZWN0KHApe3RoaXNbdV0oInRleHR1cmVSZWN0IixwKX1nZXQgc291cmNlUmVjdCgpe3JldHVybiB0aGlzW2FdKCJzb3VyY2VSZWN0Iil9c2V0IHNvdXJjZVJlY3QocCl7dGhpc1t1XSgic291cmNlUmVjdCIscCl9Z2V0IHRleHR1cmVSZXBlYXQoKXtyZXR1cm4gdGhpc1thXSgidGV4dHVyZVJlcGVhdCIpfXNldCB0ZXh0dXJlUmVwZWF0KHApe3RoaXNbdV0oInRleHR1cmVSZXBlYXQiLCEhcCl9Z2V0IGNsaXBQYXRoKCl7cmV0dXJuIHRoaXNbYV0oImNsaXBQYXRoIil9c2V0IGNsaXBQYXRoKHApe3RoaXNbdV0oImNsaXBQYXRoIixwKX19fSxmdW5jdGlvbihnLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiB1fSk7dmFyIG49dCgyMjYpLGk9dCgyMTMpLGY9dCgyMzApO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBoKGEsZCxFKXtyZXR1cm4gZCBpbiBhP09iamVjdC5kZWZpbmVQcm9wZXJ0eShhLGQse3ZhbHVlOkUsZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTphW2RdPUUsYX1jbGFzcyB1IGV4dGVuZHMgbi5kZWZhdWx0e2dldCBpc1Zpc2libGUoKXtjb25zdHt3aWR0aDpkLGhlaWdodDpFfT10aGlzLmF0dHJpYnV0ZXM7cmV0dXJuIGQ+MCYmRT4wJiZzdXBlci5pc1Zpc2libGV9fWgodSwiQXR0ciIsZi5kZWZhdWx0KSxpLmRlZmF1bHQucmVnaXN0ZXJOb2RlKHUsInJlY3QiKX0sZnVuY3Rpb24oZyxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gRX0pO3ZhciBuPXQoMjI4KSxpPXQoNzIpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCBmPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZURlZmF1bHQiKSxoPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZSIpLHU9U3ltYm9sLmZvcigic3ByaXRlanNfZ2V0QXR0cmlidXRlIiksYT1TeW1ib2wuZm9yKCJzcHJpdGVqc19kZWNsYXJlQWxpYXMiKTtmdW5jdGlvbiBkKHApe2NvbnN0e3dpZHRoOk8saGVpZ2h0Om19PXA7cmV0dXJuYE0wIDBMJHtPfSAwTCR7T30gJHttfUwwICR7bX1aYH1jbGFzcyBFIGV4dGVuZHMgbi5kZWZhdWx0e2NvbnN0cnVjdG9yKE8pe3N1cGVyKE8pLHRoaXNbZl0oe3dpZHRoOjAsaGVpZ2h0OjB9KSx0aGlzW2FdKCJzaXplIil9Z2V0IGQoKXtyZXR1cm4gdGhpc1t1XSgiZCIpfXNldCBkKE8pe31nZXQgd2lkdGgoKXtyZXR1cm4gdGhpc1t1XSgid2lkdGgiKX1zZXQgd2lkdGgoTyl7aWYoTz1PYmplY3QoaS50b051bWJlcikoTyksdGhpc1toXSgid2lkdGgiLE8pKXtjb25zdCBtPWQodGhpcyk7dGhpc1toXSgiZCIsbSl9fWdldCBoZWlnaHQoKXtyZXR1cm4gdGhpc1t1XSgiaGVpZ2h0Iil9c2V0IGhlaWdodChPKXtpZihPPU9iamVjdChpLnRvTnVtYmVyKShPKSx0aGlzW2hdKCJoZWlnaHQiLE8pKXtjb25zdCBtPWQodGhpcyk7dGhpc1toXSgiZCIsbSl9fWdldCBzaXplKCl7cmV0dXJuW3RoaXMud2lkdGgsdGhpcy5oZWlnaHRdfXNldCBzaXplKE8pe089T2JqZWN0KGkudG9BcnJheSkoTyksQXJyYXkuaXNBcnJheShPKXx8KE89W08sT10pLHRoaXMud2lkdGg9T1swXSx0aGlzLmhlaWdodD1PWzFdfX19LGZ1bmN0aW9uKGcsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIHV9KTt2YXIgbj10KDIzMiksaT10KDIxMyksZj10KDIzNSk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIGgoYSxkLEUpe3JldHVybiBkIGluIGE/T2JqZWN0LmRlZmluZVByb3BlcnR5KGEsZCx7dmFsdWU6RSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOmFbZF09RSxhfWNsYXNzIHUgZXh0ZW5kcyBuLmRlZmF1bHR7Z2V0IGlzVmlzaWJsZSgpe2NvbnN0e3NpZGVzOmR9PXRoaXMuYXR0cmlidXRlcztyZXR1cm4gZFswXT4wJiZkWzFdPjAmJnN1cGVyLmlzVmlzaWJsZX19aCh1LCJBdHRyIixmLmRlZmF1bHQpLGkuZGVmYXVsdC5yZWdpc3Rlck5vZGUodSwidHJpYW5nbGUiKX0sZnVuY3Rpb24oZyxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gdX0pO3ZhciBuPXQoMjI2KSxpPXQoMjEzKSxmPXQoMjMzKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gaChhLGQsRSl7cmV0dXJuIGQgaW4gYT9PYmplY3QuZGVmaW5lUHJvcGVydHkoYSxkLHt2YWx1ZTpFLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6YVtkXT1FLGF9Y2xhc3MgdSBleHRlbmRzIG4uZGVmYXVsdHtnZXQgaXNWaXNpYmxlKCl7Y29uc3R7cG9pbnRzOmR9PXRoaXMuYXR0cmlidXRlcztyZXR1cm4gZC5sZW5ndGg+MCYmc3VwZXIuaXNWaXNpYmxlfX1oKHUsIkF0dHIiLGYuZGVmYXVsdCksaS5kZWZhdWx0LnJlZ2lzdGVyTm9kZSh1LCJwb2x5bGluZSIpfSxmdW5jdGlvbihnLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBwfSk7dmFyIG49dCgyMjgpLGk9dCg3MiksZj10KDIzNCk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IGg9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlRGVmYXVsdCIpLHU9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlIiksYT1TeW1ib2wuZm9yKCJzcHJpdGVqc19nZXRBdHRyaWJ1dGUiKSxkPVN5bWJvbC5mb3IoInNwcml0ZWpzX2RlY2xhcmVBbGlhcyIpO2Z1bmN0aW9uIEUoTyl7Y29uc3R7cG9pbnRzOm0sc21vb3RoOmIsc21vb3RoUmFuZ2U6TSxjbG9zZTp5fT1PLFM9W107Zm9yKGxldCBjPTA7YzxtLmxlbmd0aDtjKz0yKVMucHVzaChbbVtjXSxtW2MrMV1dKTtsZXQgcz0iIjtyZXR1cm4gYj9zPU9iamVjdChmLm1ha2VTbW9vdGhDdXJ2ZUxpbmUpKFMsTSk6Uy5sZW5ndGgmJihzPWBNJHtTLm1hcChjPT5jLmpvaW4oIiAiKSkuam9pbigiTCIpfWApLHMmJnkmJihzKz0iWiIpLHN9Y2xhc3MgcCBleHRlbmRzIG4uZGVmYXVsdHtjb25zdHJ1Y3RvcihtKXtzdXBlcihtKSx0aGlzW2hdKHtwb2ludHM6W10sc21vb3RoOiExLHNtb290aFJhbmdlOlswXSxjbG9zZVR5cGU6Im5vbmUifSksdGhpc1tkXSgiY2xvc2UiKX1nZXQgZCgpe3JldHVybiB0aGlzW2FdKCJkIil9c2V0IGQobSl7fWdldCBjbG9zZSgpe3JldHVybiB0aGlzLmNsb3NlVHlwZSE9PSJub25lIn1zZXQgY2xvc2UobSl7bT1tPyJub3JtYWwiOiJub25lIix0aGlzLmNsb3NlVHlwZT1tfWdldCBjbG9zZVR5cGUoKXtyZXR1cm4gdGhpc1thXSgiY2xvc2VUeXBlIil9c2V0IGNsb3NlVHlwZShtKXtpZihtIT1udWxsJiZtIT09Im5vbmUiJiZtIT09Im5vcm1hbCIpdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCBjbG9zZVR5cGUgdHlwZS4iKTtpZih0aGlzW3VdKCJjbG9zZVR5cGUiLG0pKXtjb25zdCBiPUUodGhpcyk7dGhpc1t1XSgiZCIsYil9fWdldCBzbW9vdGgoKXtyZXR1cm4gdGhpc1thXSgic21vb3RoIil9c2V0IHNtb290aChtKXtpZih0aGlzW3VdKCJzbW9vdGgiLG0pKXtjb25zdCBiPUUodGhpcyk7dGhpc1t1XSgiZCIsYil9fWdldCBzbW9vdGhSYW5nZSgpe3JldHVybiB0aGlzW2FdKCJzbW9vdGhSYW5nZSIpfXNldCBzbW9vdGhSYW5nZShtKXtpZihtJiYhQXJyYXkuaXNBcnJheShtKSYmKG09W21dKSx0aGlzW3VdKCJzbW9vdGhSYW5nZSIsbSkmJnRoaXMuc21vb3RoKXtjb25zdCBiPUUodGhpcyk7dGhpc1t1XSgiZCIsYil9fWdldCBwb2ludHMoKXtyZXR1cm4gdGhpc1thXSgicG9pbnRzIil9c2V0IHBvaW50cyhtKXtpZihtPU9iamVjdChpLnRvQXJyYXkpKG0pLEFycmF5LmlzQXJyYXkobSkmJihtPW0ucmVkdWNlKChiLE0pPT5BcnJheS5pc0FycmF5KE0pP1suLi5iLC4uLk0ubWFwKHk9Pk9iamVjdChpLnRvTnVtYmVyKSh5KSldOlsuLi5iLE9iamVjdChpLnRvTnVtYmVyKShNKV0sW10pKSx0aGlzW3VdKCJwb2ludHMiLG0pKXtjb25zdCBiPUUodGhpcyk7dGhpc1t1XSgiZCIsYil9fX19LGZ1bmN0aW9uKGcsZSx0KXt0LnIoZSksdC5kKGUsIm1ha2VTbW9vdGhDdXJ2ZUxpbmUiLGZ1bmN0aW9uKCl7cmV0dXJuIG59KSx0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gbihpLGY9WzBdKXtmdW5jdGlvbiBoKGQsRT0uMTY4LHA9LjE2OCl7bGV0IE8sbSxiLE07aWYoKGlbZF0ueD09PWlbZCsxXS54fHxpW2RdLnk9PT1pW2QrMV0ueSkmJihFPTAscD0wKSxkPDE/KE89aVswXS54KyhpWzFdLngtaVswXS54KSpFLG09aVswXS55KyhpWzFdLnktaVswXS55KSpFKTooTz1pW2RdLngrKGlbZCsxXS54LWlbZC0xXS54KSpFLG09aVtkXS55KyhpW2QrMV0ueS1pW2QtMV0ueSkqRSksZD5pLmxlbmd0aC0zKXtjb25zdCB5PWkubGVuZ3RoLTE7Yj1pW3ldLngtKGlbeV0ueC1pW3ktMV0ueCkqcCxNPWlbeV0ueS0oaVt5XS55LWlbeS0xXS55KSpwfWVsc2UgYj1pW2QrMV0ueC0oaVtkKzJdLngtaVtkXS54KSpwLE09aVtkKzFdLnktKGlbZCsyXS55LWlbZF0ueSkqcDtyZXR1cm5be3g6Tyx5Om19LHt4OmIseTpNfV19aT1pLm1hcCgoW2QsRV0pPT4oe3g6ZCx5OkV9KSk7bGV0IHU9IiIsYT0wO3JldHVybiBpLmZvckVhY2goKGQsRSk9PntpZihFPT09MCl1Kz1gTSR7ZC54fSAke2QueX1gO2Vsc2V7Zm9yKDtFPmZbYV07KWErKztpZihhJTIpe2NvbnN0W3AsT109aChFLTEpO3UrPWBDJHtbcC54LHAueSxPLngsTy55LGQueCxkLnldLmpvaW4oIiAiKX1gfWVsc2UgdSs9YEwke2QueH0gJHtkLnl9YH19KSx1fX0sZnVuY3Rpb24oZyxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gZH0pO3ZhciBuPXQoMjMzKSxpPXQoNzIpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCBmPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZURlZmF1bHQiKSxoPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZSIpLHU9U3ltYm9sLmZvcigic3ByaXRlanNfZ2V0QXR0cmlidXRlIik7ZnVuY3Rpb24gYShFKXtjb25zdFtwLE9dPUUuc2lkZXM7bGV0IG09RS5hbmdsZSUzNjA7cmV0dXJuIG08MCYmKG0rPTM2MCksbT1NYXRoLlBJKm0vMTgwLFswLDAscCwwLE8qTWF0aC5jb3MobSksTypNYXRoLnNpbihtKV19Y2xhc3MgZCBleHRlbmRzIG4uZGVmYXVsdHtjb25zdHJ1Y3RvcihwKXtzdXBlcihwKSx0aGlzW2ZdKHtzaWRlczpbMCwwXSxhbmdsZTo2MCxjbG9zZVR5cGU6Im5vcm1hbCJ9KX1nZXQgcG9pbnRzKCl7cmV0dXJuIHN1cGVyLnBvaW50c31zZXQgcG9pbnRzKHApe31nZXQgc2lkZXMoKXtyZXR1cm4gdGhpc1t1XSgic2lkZXMiKX1zZXQgc2lkZXMocCl7aWYocD1PYmplY3QoaS50b0FycmF5KShwLCEwKSxwIT1udWxsJiYhQXJyYXkuaXNBcnJheShwKSYmKHA9W3AscF0pLHRoaXNbaF0oInNpZGVzIixwKSl7Y29uc3QgTz1hKHRoaXMpO3N1cGVyLnBvaW50cz1PfX1nZXQgYW5nbGUoKXtyZXR1cm4gdGhpc1t1XSgiYW5nbGUiKX1zZXQgYW5nbGUocCl7aWYocD1PYmplY3QoaS50b051bWJlcikocCksdGhpc1toXSgiYW5nbGUiLHApKXtjb25zdCBPPWEodGhpcyk7c3VwZXIucG9pbnRzPU99fX19LGZ1bmN0aW9uKGcsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIHV9KTt2YXIgbj10KDIzMiksaT10KDIxMyksZj10KDIzNyk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIGgoYSxkLEUpe3JldHVybiBkIGluIGE/T2JqZWN0LmRlZmluZVByb3BlcnR5KGEsZCx7dmFsdWU6RSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOmFbZF09RSxhfWNsYXNzIHUgZXh0ZW5kcyBuLmRlZmF1bHR7Z2V0IGlzVmlzaWJsZSgpe2NvbnN0e3NpZGVzOmR9PXRoaXMuYXR0cmlidXRlcztyZXR1cm4gZFswXT4wJiZkWzFdPjAmJnN1cGVyLmlzVmlzaWJsZX19aCh1LCJBdHRyIixmLmRlZmF1bHQpLGkuZGVmYXVsdC5yZWdpc3Rlck5vZGUodSwicGFyYWxsZWwiKX0sZnVuY3Rpb24oZyxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gZH0pO3ZhciBuPXQoMjMzKSxpPXQoNzIpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCBmPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZURlZmF1bHQiKSxoPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZSIpLHU9U3ltYm9sLmZvcigic3ByaXRlanNfZ2V0QXR0cmlidXRlIik7ZnVuY3Rpb24gYShFKXtjb25zdFtwLE9dPUUuc2lkZXM7bGV0IG09RS5hbmdsZSUzNjA7bTwwJiYobSs9MzYwKSxtPU1hdGguUEkqbS8xODA7Y29uc3QgYj1PKk1hdGguY29zKG0pLE09TypNYXRoLnNpbihtKTtyZXR1cm5bMCwwLHAsMCxiK3AsTSxiLE1dfWNsYXNzIGQgZXh0ZW5kcyBuLmRlZmF1bHR7Y29uc3RydWN0b3IocCl7c3VwZXIocCksdGhpc1tmXSh7c2lkZXM6WzAsMF0sYW5nbGU6OTAsY2xvc2VUeXBlOiJub3JtYWwifSl9Z2V0IHBvaW50cygpe3JldHVybiBzdXBlci5wb2ludHN9c2V0IHBvaW50cyhwKXt9Z2V0IHNpZGVzKCl7cmV0dXJuIHRoaXNbdV0oInNpZGVzIil9c2V0IHNpZGVzKHApe2lmKHA9T2JqZWN0KGkudG9BcnJheSkocCwhMCkscCE9bnVsbCYmIUFycmF5LmlzQXJyYXkocCkmJihwPVtwLHBdKSx0aGlzW2hdKCJzaWRlcyIscCkpe2NvbnN0IE89YSh0aGlzKTtzdXBlci5wb2ludHM9T319Z2V0IGFuZ2xlKCl7cmV0dXJuIHRoaXNbdV0oImFuZ2xlIil9c2V0IGFuZ2xlKHApe2lmKHA9T2JqZWN0KGkudG9OdW1iZXIpKHApLHRoaXNbaF0oImFuZ2xlIixwKSl7Y29uc3QgTz1hKHRoaXMpO3N1cGVyLnBvaW50cz1PfX19fSxmdW5jdGlvbihnLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiB1fSk7dmFyIG49dCgyMzIpLGk9dCgyMTMpLGY9dCgyMzkpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBoKGEsZCxFKXtyZXR1cm4gZCBpbiBhP09iamVjdC5kZWZpbmVQcm9wZXJ0eShhLGQse3ZhbHVlOkUsZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTphW2RdPUUsYX1jbGFzcyB1IGV4dGVuZHMgbi5kZWZhdWx0e31oKHUsIkF0dHIiLGYuZGVmYXVsdCksaS5kZWZhdWx0LnJlZ2lzdGVyTm9kZSh1LCJyZWd1bGFyIil9LGZ1bmN0aW9uKGcsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIGR9KTt2YXIgbj10KDIzMyksaT10KDcyKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3QgZj1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGVEZWZhdWx0IiksaD1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGUiKSx1PVN5bWJvbC5mb3IoInNwcml0ZWpzX2dldEF0dHJpYnV0ZSIpO2Z1bmN0aW9uIGEoRSl7Y29uc3R7ZWRnZXM6cCxyYWRpdXM6TyxvZmZzZXRBbmdsZTptfT1FLGI9TWF0aC5QSSptLzE4MC0uNSpNYXRoLlBJO2lmKHA8M3x8Tzw9MClyZXR1cm5bXTtjb25zdCBNPVtdO2ZvcihsZXQgeT0wO3k8cDt5Kyspe2NvbnN0IFM9eSoyKk1hdGguUEkvcCtiLHM9TypNYXRoLmNvcyhTKSxjPU8qTWF0aC5zaW4oUyk7TS5wdXNoKHMsYyl9cmV0dXJuIE19Y2xhc3MgZCBleHRlbmRzIG4uZGVmYXVsdHtjb25zdHJ1Y3RvcihwKXtzdXBlcihwKSx0aGlzW2ZdKHtlZGdlczozLHJhZGl1czowLG9mZnNldEFuZ2xlOjAsY2xvc2VUeXBlOiJub3JtYWwifSl9Z2V0IHBvaW50cygpe3JldHVybiBzdXBlci5wb2ludHN9c2V0IHBvaW50cyhwKXt9Z2V0IGVkZ2VzKCl7cmV0dXJuIHRoaXNbdV0oImVkZ2VzIil9c2V0IGVkZ2VzKHApe2lmKHA9T2JqZWN0KGkudG9OdW1iZXIpKHApLHRoaXNbaF0oImVkZ2VzIixwKSl7Y29uc3QgTz1hKHRoaXMpO3N1cGVyLnBvaW50cz1PfX1nZXQgcmFkaXVzKCl7cmV0dXJuIHRoaXNbdV0oInJhZGl1cyIpfXNldCByYWRpdXMocCl7aWYocD1PYmplY3QoaS50b051bWJlcikocCksdGhpc1toXSgicmFkaXVzIixwKSl7Y29uc3QgTz1hKHRoaXMpO3N1cGVyLnBvaW50cz1PfX1nZXQgb2Zmc2V0QW5nbGUoKXtyZXR1cm4gdGhpc1t1XSgib2Zmc2V0QW5nbGUiKX1zZXQgb2Zmc2V0QW5nbGUocCl7aWYocD1PYmplY3QoaS50b051bWJlcikocCksdGhpc1toXSgib2Zmc2V0QW5nbGUiLHApKXtjb25zdCBPPWEodGhpcyk7c3VwZXIucG9pbnRzPU99fX19LGZ1bmN0aW9uKGcsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIHV9KTt2YXIgbj10KDIzMiksaT10KDIxMyksZj10KDI0MSk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIGgoYSxkLEUpe3JldHVybiBkIGluIGE/T2JqZWN0LmRlZmluZVByb3BlcnR5KGEsZCx7dmFsdWU6RSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOmFbZF09RSxhfWNsYXNzIHUgZXh0ZW5kcyBuLmRlZmF1bHR7fWgodSwiQXR0ciIsZi5kZWZhdWx0KSxpLmRlZmF1bHQucmVnaXN0ZXJOb2RlKHUsInN0YXIiKX0sZnVuY3Rpb24oZyxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gZH0pO3ZhciBuPXQoMjMzKSxpPXQoNzIpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCBmPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZURlZmF1bHQiKSxoPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZSIpLHU9U3ltYm9sLmZvcigic3ByaXRlanNfZ2V0QXR0cmlidXRlIik7ZnVuY3Rpb24gYShFKXtjb25zdHthbmdsZXM6cCxpbm5lclJhZGl1czpPLG91dGVyUmFkaXVzOm0sb2Zmc2V0QW5nbGU6Yn09RSxNPU1hdGguUEkqYi8xODAtLjUqTWF0aC5QSTtpZihwPDN8fE88PTB8fG08PTApcmV0dXJuW107Y29uc3QgeT1bXTtmb3IobGV0IFM9MDtTPHAqMjtTKyspe2NvbnN0IHM9UypNYXRoLlBJL3ArTSxjPVMlMj9POm0sbD1jKk1hdGguY29zKHMpLHY9YypNYXRoLnNpbihzKTt5LnB1c2gobCx2KX1yZXR1cm4geX1jbGFzcyBkIGV4dGVuZHMgbi5kZWZhdWx0e2NvbnN0cnVjdG9yKHApe3N1cGVyKHApLHRoaXNbZl0oe2FuZ2xlczo1LGlubmVyUmFkaXVzOjAsb3V0ZXJSYWRpdXM6MCxvZmZzZXRBbmdsZTowLGNsb3NlVHlwZToibm9ybWFsIn0pfWdldCBwb2ludHMoKXtyZXR1cm4gc3VwZXIucG9pbnRzfXNldCBwb2ludHMocCl7fWdldCBhbmdsZXMoKXtyZXR1cm4gdGhpc1t1XSgiYW5nbGVzIil9c2V0IGFuZ2xlcyhwKXtpZihwPU9iamVjdChpLnRvTnVtYmVyKShwKSx0aGlzW2hdKCJhbmdsZXMiLHApKXtjb25zdCBPPWEodGhpcyk7c3VwZXIucG9pbnRzPU99fWdldCBpbm5lclJhZGl1cygpe3JldHVybiB0aGlzW3VdKCJpbm5lclJhZGl1cyIpfXNldCBpbm5lclJhZGl1cyhwKXtpZihwPU9iamVjdChpLnRvTnVtYmVyKShwKSx0aGlzW2hdKCJpbm5lclJhZGl1cyIscCkpe2NvbnN0IE89YSh0aGlzKTtzdXBlci5wb2ludHM9T319Z2V0IG91dGVyUmFkaXVzKCl7cmV0dXJuIHRoaXNbdV0oIm91dGVyUmFkaXVzIil9c2V0IG91dGVyUmFkaXVzKHApe2lmKHA9T2JqZWN0KGkudG9OdW1iZXIpKHApLHRoaXNbaF0oIm91dGVyUmFkaXVzIixwKSl7Y29uc3QgTz1hKHRoaXMpO3N1cGVyLnBvaW50cz1PfX1nZXQgcmFkaXVzKCl7cmV0dXJuW3RoaXMuaW5uZXJSYWRpdXMsdGhpcy5vdXRlclJhZGl1c119c2V0IHJhZGl1cyhwKXtwPU9iamVjdChpLnRvQXJyYXkpKHAsITApLEFycmF5LmlzQXJyYXkocCl8fChwPVtwLHBdKSx0aGlzLmlubmVyUmFkaXVzPXBbMF0sdGhpcy5vdXRlclJhZGl1cz1wWzFdfWdldCBvZmZzZXRBbmdsZSgpe3JldHVybiB0aGlzW3VdKCJvZmZzZXRBbmdsZSIpfXNldCBvZmZzZXRBbmdsZShwKXtpZihwPU9iamVjdChpLnRvTnVtYmVyKShwKSx0aGlzW2hdKCJvZmZzZXRBbmdsZSIscCkpe2NvbnN0IE89YSh0aGlzKTtzdXBlci5wb2ludHM9T319fX0sZnVuY3Rpb24oZyxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gdX0pO3ZhciBuPXQoMjI2KSxpPXQoMjEzKSxmPXQoMjQzKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gaChhLGQsRSl7cmV0dXJuIGQgaW4gYT9PYmplY3QuZGVmaW5lUHJvcGVydHkoYSxkLHt2YWx1ZTpFLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6YVtkXT1FLGF9Y2xhc3MgdSBleHRlbmRzIG4uZGVmYXVsdHtnZXQgaXNWaXNpYmxlKCl7Y29uc3R7cmFkaXVzWDpkLHJhZGl1c1k6RSxzdGFydEFuZ2xlOnAsZW5kQW5nbGU6T309dGhpcy5hdHRyaWJ1dGVzO3JldHVybiBkPjAmJkU+MCYmcCE9PU8mJnN1cGVyLmlzVmlzaWJsZX19aCh1LCJBdHRyIixmLmRlZmF1bHQpLGkuZGVmYXVsdC5yZWdpc3Rlck5vZGUodSwiZWxsaXBzZSIpfSxmdW5jdGlvbihnLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBwfSk7dmFyIG49dCgxMiksaT10KDIyOCksZj10KDcyKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3QgaD1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGVEZWZhdWx0IiksdT1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGUiKSxhPVN5bWJvbC5mb3IoInNwcml0ZWpzX2dldEF0dHJpYnV0ZSIpLGQ9U3ltYm9sLmZvcigic3ByaXRlanNfZGVjbGFyZUFsaWFzIik7ZnVuY3Rpb24gRShPKXtjb25zdHtyYWRpdXNYOm0scmFkaXVzWTpiLHN0YXJ0QW5nbGU6TSxlbmRBbmdsZTp5LGRpcmVjdGlvbjpTLGNsb3NlVHlwZTpzfT1PLGM9Uz09PSJhbml0Y2xvY2t3aXNlIixsPW5ldyBuLkZpZ3VyZTJEO3JldHVybiBzPT09InNlY3RvciImJmwubW92ZVRvKDAsMCksbC5lbGxpcHNlKDAsMCxtLGIsMCxNYXRoLlBJKk0vMTgwLE1hdGguUEkqeS8xODAsYykscyE9PSJub25lIiYmbC5jbG9zZVBhdGgoKSxsLnBhdGgucmVkdWNlKChSLEwpPT5SK0wuam9pbigiICIpLCIiKX1jbGFzcyBwIGV4dGVuZHMgaS5kZWZhdWx0e2NvbnN0cnVjdG9yKG0pe3N1cGVyKG0pLHRoaXNbaF0oe3JhZGl1c1g6MCxyYWRpdXNZOjAsc3RhcnRBbmdsZTowLGVuZEFuZ2xlOjM2MCxkaXJlY3Rpb246ImNsb2Nrd2lzZSIsY2xvc2VUeXBlOiJub25lIn0pLHRoaXNbZF0oInJhZGl1cyIsImFuZ2xlIil9Z2V0IGQoKXtyZXR1cm4gdGhpc1thXSgiZCIpfXNldCBkKG0pe31nZXQgcmFkaXVzWCgpe3JldHVybiB0aGlzW2FdKCJyYWRpdXNYIil9c2V0IHJhZGl1c1gobSl7aWYobT1PYmplY3QoZi50b051bWJlcikobSksdGhpc1t1XSgicmFkaXVzWCIsbSkpe2NvbnN0IGI9RSh0aGlzKTt0aGlzW3VdKCJkIixiKX19Z2V0IHJhZGl1c1koKXtyZXR1cm4gdGhpc1thXSgicmFkaXVzWSIpfXNldCByYWRpdXNZKG0pe2lmKG09T2JqZWN0KGYudG9OdW1iZXIpKG0pLHRoaXNbdV0oInJhZGl1c1kiLG0pKXtjb25zdCBiPUUodGhpcyk7dGhpc1t1XSgiZCIsYil9fWdldCByYWRpdXMoKXtyZXR1cm5bdGhpcy5yYWRpdXNYLHRoaXMucmFkaXVzWV19c2V0IHJhZGl1cyhtKXttPU9iamVjdChmLnRvQXJyYXkpKG0sITApLEFycmF5LmlzQXJyYXkobSl8fChtPVttLG1dKSx0aGlzLnJhZGl1c1g9bVswXSx0aGlzLnJhZGl1c1k9bVsxXX1nZXQgYW5nbGUoKXtyZXR1cm5bdGhpcy5zdGFydEFuZ2xlLHRoaXMuZW5kQW5nbGVdfXNldCBhbmdsZShtKXttPU9iamVjdChmLnRvQXJyYXkpKG0pLEFycmF5LmlzQXJyYXkobSl8fChtPVttLG1dKSx0aGlzLnN0YXJ0QW5nbGU9bVswXSx0aGlzLmVuZEFuZ2xlPW1bMV19Z2V0IGRpcmVjdGlvbigpe3JldHVybiB0aGlzW2FdKCJkaXJlY3Rpb24iKX1zZXQgZGlyZWN0aW9uKG0pe2lmKG0hPW51bGwmJm0hPT0iY2xvY2t3aXNlIiYmbSE9PSJhbnRpY2xvY2t3aXNlIil0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIGRpcmVjdGlvbiB0eXBlLiIpO3RoaXNbdV0oImRpcmVjdGlvbiIsbSl9Z2V0IHN0YXJ0QW5nbGUoKXtyZXR1cm4gdGhpc1thXSgic3RhcnRBbmdsZSIpfXNldCBzdGFydEFuZ2xlKG0pe2lmKG09T2JqZWN0KGYudG9OdW1iZXIpKG0pLHRoaXNbdV0oInN0YXJ0QW5nbGUiLG0pKXtjb25zdCBiPUUodGhpcyk7dGhpc1t1XSgiZCIsYil9fWdldCBlbmRBbmdsZSgpe3JldHVybiB0aGlzW2FdKCJlbmRBbmdsZSIpfXNldCBlbmRBbmdsZShtKXtpZihtPU9iamVjdChmLnRvTnVtYmVyKShtKSx0aGlzW3VdKCJlbmRBbmdsZSIsbSkpe2NvbnN0IGI9RSh0aGlzKTt0aGlzW3VdKCJkIixiKX19Z2V0IGNsb3NlVHlwZSgpe3JldHVybiB0aGlzW2FdKCJjbG9zZVR5cGUiKX1zZXQgY2xvc2VUeXBlKG0pe2lmKG0hPW51bGwmJm0hPT0ibm9uZSImJm0hPT0ic2VjdG9yIiYmbSE9PSJub3JtYWwiKXRocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgY2xvc2VUeXBlIHR5cGUuIik7aWYodGhpc1t1XSgiY2xvc2VUeXBlIixtKSl7Y29uc3QgYj1FKHRoaXMpO3RoaXNbdV0oImQiLGIpfX19fSxmdW5jdGlvbihnLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiB1fSk7dmFyIG49dCgyNDIpLGk9dCgyMTMpLGY9dCgyNDUpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBoKGEsZCxFKXtyZXR1cm4gZCBpbiBhP09iamVjdC5kZWZpbmVQcm9wZXJ0eShhLGQse3ZhbHVlOkUsZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTphW2RdPUUsYX1jbGFzcyB1IGV4dGVuZHMgbi5kZWZhdWx0e31oKHUsIkF0dHIiLGYuZGVmYXVsdCksaS5kZWZhdWx0LnJlZ2lzdGVyTm9kZSh1LCJhcmMiKX0sZnVuY3Rpb24oZyxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gZn0pO3ZhciBuPXQoMjQzKSxpPXQoNzIpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjbGFzcyBmIGV4dGVuZHMgbi5kZWZhdWx0e2dldCByYWRpdXMoKXtyZXR1cm4gc3VwZXIucmFkaXVzWH1zZXQgcmFkaXVzKHUpe3U9T2JqZWN0KGkudG9OdW1iZXIpKHUpLHN1cGVyLnJhZGl1c1g9dSxzdXBlci5yYWRpdXNZPXV9fX0sZnVuY3Rpb24oZyxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gdX0pO3ZhciBuPXQoMjI2KSxpPXQoMjEzKSxmPXQoMjQ3KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gaChhLGQsRSl7cmV0dXJuIGQgaW4gYT9PYmplY3QuZGVmaW5lUHJvcGVydHkoYSxkLHt2YWx1ZTpFLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6YVtkXT1FLGF9Y2xhc3MgdSBleHRlbmRzIG4uZGVmYXVsdHtnZXQgaXNWaXNpYmxlKCl7Y29uc3R7aW5uZXJSYWRpdXM6ZCxvdXRlclJhZGl1czpFLHN0YXJ0QW5nbGU6cCxlbmRBbmdsZTpPfT10aGlzLmF0dHJpYnV0ZXM7cmV0dXJuKGQ+MHx8RT4wKSYmcCE9PU8mJnN1cGVyLmlzVmlzaWJsZX19aCh1LCJBdHRyIixmLmRlZmF1bHQpLGkuZGVmYXVsdC5yZWdpc3Rlck5vZGUodSwicmluZyIpfSxmdW5jdGlvbihnLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBwfSk7dmFyIG49dCgxMiksaT10KDIyOCksZj10KDcyKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3QgaD1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGVEZWZhdWx0IiksdT1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGUiKSxhPVN5bWJvbC5mb3IoInNwcml0ZWpzX2dldEF0dHJpYnV0ZSIpLGQ9U3ltYm9sLmZvcigic3ByaXRlanNfZGVjbGFyZUFsaWFzIik7ZnVuY3Rpb24gRShPKXtsZXR7aW5uZXJSYWRpdXM6bSxvdXRlclJhZGl1czpiLHN0YXJ0QW5nbGU6TSxlbmRBbmdsZTp5fT1PO2NvbnN0IFM9bmV3IG4uRmlndXJlMkQ7aWYoTT1NYXRoLlBJKk0vMTgwLHk9TWF0aC5QSSp5LzE4MCxtPmImJihbbSxiXT1bYixtXSksbTw9MCYmUy5tb3ZlVG8oMCwwKSxTLmFyYygwLDAsYixNLHksITEpLG0+MCl7Y29uc3QgbD1NYXRoLlBJKjI7eTxNJiYoeT1NK2wrKHktTSklbCkseS1NPj1sJiYoeT1NK2wtMWUtNiksUy5hcmMoMCwwLG0seSxNLCEwKX1yZXR1cm4gUy5jbG9zZVBhdGgoKSxTLnBhdGgucmVkdWNlKChsLHYpPT5sK3Yuam9pbigiICIpLCIiKX1jbGFzcyBwIGV4dGVuZHMgaS5kZWZhdWx0e2NvbnN0cnVjdG9yKG0pe3N1cGVyKG0pLHRoaXNbaF0oe2lubmVyUmFkaXVzOjAsb3V0ZXJSYWRpdXM6MCxzdGFydEFuZ2xlOjAsZW5kQW5nbGU6MzYwfSksdGhpc1tkXSgicmFkaXVzIiwiYW5nbGUiKX1nZXQgZCgpe3JldHVybiB0aGlzW2FdKCJkIil9c2V0IGQobSl7fWdldCBpbm5lclJhZGl1cygpe3JldHVybiB0aGlzW2FdKCJpbm5lclJhZGl1cyIpfXNldCBpbm5lclJhZGl1cyhtKXtpZihtPU9iamVjdChmLnRvTnVtYmVyKShtKSx0aGlzW3VdKCJpbm5lclJhZGl1cyIsbSkpe2NvbnN0IGI9RSh0aGlzKTt0aGlzW3VdKCJkIixiKX19Z2V0IG91dGVyUmFkaXVzKCl7cmV0dXJuIHRoaXNbYV0oIm91dGVyUmFkaXVzIil9c2V0IG91dGVyUmFkaXVzKG0pe2lmKG09T2JqZWN0KGYudG9OdW1iZXIpKG0pLHRoaXNbdV0oIm91dGVyUmFkaXVzIixtKSl7Y29uc3QgYj1FKHRoaXMpO3RoaXNbdV0oImQiLGIpfX1nZXQgcmFkaXVzKCl7cmV0dXJuW3RoaXMuaW5uZXJSYWRpdXMsdGhpcy5vdXRlclJhZGl1c119c2V0IHJhZGl1cyhtKXttPU9iamVjdChmLnRvQXJyYXkpKG0sITApLEFycmF5LmlzQXJyYXkobSl8fChtPVttLG1dKSx0aGlzLmlubmVyUmFkaXVzPW1bMF0sdGhpcy5vdXRlclJhZGl1cz1tWzFdfWdldCBzdGFydEFuZ2xlKCl7cmV0dXJuIHRoaXNbYV0oInN0YXJ0QW5nbGUiKX1zZXQgc3RhcnRBbmdsZShtKXtpZihtPU9iamVjdChmLnRvTnVtYmVyKShtKSx0aGlzW3VdKCJzdGFydEFuZ2xlIixtKSl7Y29uc3QgYj1FKHRoaXMpO3RoaXNbdV0oImQiLGIpfX1nZXQgZW5kQW5nbGUoKXtyZXR1cm4gdGhpc1thXSgiZW5kQW5nbGUiKX1zZXQgZW5kQW5nbGUobSl7aWYobT1PYmplY3QoZi50b051bWJlcikobSksdGhpc1t1XSgiZW5kQW5nbGUiLG0pKXtjb25zdCBiPUUodGhpcyk7dGhpc1t1XSgiZCIsYil9fWdldCBhbmdsZSgpe3JldHVyblt0aGlzLnN0YXJ0QW5nbGUsdGhpcy5lbmRBbmdsZV19c2V0IGFuZ2xlKG0pe209T2JqZWN0KGYudG9BcnJheSkobSksQXJyYXkuaXNBcnJheShtKXx8KG09W20sbV0pLHRoaXMuc3RhcnRBbmdsZT1tWzBdLHRoaXMuZW5kQW5nbGU9bVsxXX19fSxmdW5jdGlvbihnLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBifSk7dmFyIG49dCgxMiksaT10KDIxOCksZj10KDIxOSksaD10KDI0OSksdT10KDIxMyk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIGEoTSx5LFMpe3JldHVybiB5IGluIE0/T2JqZWN0LmRlZmluZVByb3BlcnR5KE0seSx7dmFsdWU6UyxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOk1beV09UyxNfWNvbnN0IGQ9U3ltYm9sKCJ0ZXh0SW1hZ2UiKSxFPVN5bWJvbCgidGV4dEltYWdlVGFzayIpLHA9U3ltYm9sKCJ0ZXh0dXJlQ29udGV4dCIpLE89U3ltYm9sKCJ1cGRhdGVUZXh0dXJlUmVjdCIpLG09U3ltYm9sKCJ0ZXh0Q2FudmFzIik7Y2xhc3MgYiBleHRlbmRzIGYuZGVmYXVsdHtjb25zdHJ1Y3Rvcih5PXt9KXt0eXBlb2YgeT09InN0cmluZyImJih5PXt0ZXh0Onl9KSxzdXBlcih5KX1nZXQgY29udGVudFNpemUoKXtsZXRbeSxTXT1zdXBlci5jb250ZW50U2l6ZTtjb25zdHt3aWR0aDpzLGhlaWdodDpjfT10aGlzLmF0dHJpYnV0ZXM7aWYocz09bnVsbHx8Yz09bnVsbCl7Y29uc3QgbD10aGlzW2RdO2wmJihzPT1udWxsJiYoeT1sLnJlY3RbMl0pLGM9PW51bGwmJihTPWwucmVjdFszXSkpfXJldHVyblt5LFNdfWdldCB0ZXh0KCl7cmV0dXJuIHRoaXMuYXR0cmlidXRlcy50ZXh0fXNldCB0ZXh0KHkpe3RoaXMuYXR0cmlidXRlcy50ZXh0PXl9Z2V0IHRleHRDb250ZW50KCl7cmV0dXJuIHRoaXMuYXR0cmlidXRlcy50ZXh0fXNldCB0ZXh0Q29udGVudCh5KXt0aGlzLmF0dHJpYnV0ZXMudGV4dD15fWdldCB0ZXh0SW1hZ2UoKXtyZXR1cm4gdGhpc1tkXXx8e319Z2V0IHRleHRJbWFnZVJlYWR5KCl7cmV0dXJuIHRoaXNbRV18fFByb21pc2UucmVzb2x2ZSgpfWRyYXcoeSl7c3VwZXIuZHJhdyh5KTtjb25zdCBTPXRoaXMubWVzaDtpZihTKXtjb25zdCBzPXRoaXNbZF07aWYocyl7bGV0IGM9Uy50ZXh0dXJlO2lmKCFjfHx0aGlzW3BdJiZ0aGlzW3BdIT09dGhpcy5yZW5kZXJlcnx8cy5uZWVkc1VwZGF0ZT8ocy5uZWVkc1VwZGF0ZT0hMSxPYmplY3QoaS5kZWxldGVUZXh0dXJlKShzLmltYWdlLHRoaXMucmVuZGVyZXIpLGM9T2JqZWN0KGkuY3JlYXRlVGV4dHVyZSkocy5pbWFnZSx0aGlzLnJlbmRlcmVyKSx0aGlzW09dPSEwKTpjPVMudW5pZm9ybXMudV90ZXhTYW1wbGVyLHRoaXNbT10pe2NvbnN0W2wsdl09cy5yZWN0LnNsaWNlKDIpLFtULFJdPXRoaXMuY29udGVudFNpemUsTD10aGlzLmF0dHJpYnV0ZXMudGV4dEFsaWduLE49dGhpcy5hdHRyaWJ1dGVzLnZlcnRpY2FsQWxpZ247bGV0IEE9MDtMPT09ImNlbnRlciI/QT0oVC1sKS8yOihMPT09InJpZ2h0Inx8TD09PSJlbmQiKSYmKEE9VC1sKTtjb25zdCB3PXRoaXMuYXR0cmlidXRlcy5mb250U2l6ZSxCPXRoaXMuYXR0cmlidXRlcy5saW5lSGVpZ2h0O2xldCBEPTA7Tj09PSJ0b3AiP0Q9KHctQikvMjpOPT09ImJvdHRvbSImJihEPShCLXcpLzIpO2NvbnN0e3BhZGRpbmdMZWZ0OkkscGFkZGluZ1RvcDpqfT10aGlzLmF0dHJpYnV0ZXMse2JvcmRlcldpZHRoOlZ9PXRoaXMuYXR0cmlidXRlcztBKz1JK1YsRCs9aitWO2NvbnN0e2FuY2hvclg6SixhbmNob3JZOl99PXRoaXMuYXR0cmlidXRlcztBLT10aGlzLm9mZnNldFNpemVbMF0qSixELT10aGlzLm9mZnNldFNpemVbMV0qXyxTLnNldFRleHR1cmUoYyx7cmVjdDpbQSxELGwsdl19KSx0aGlzW09dPSExLHRoaXNbcF09dGhpcy5yZW5kZXJlcn19fXJldHVybiB5fW9uUHJvcGVydHlDaGFuZ2UoeSxTLHMpe3k9PT0idGV4dCJ8fHk9PT0iZm9udFNpemUifHx5PT09ImZvbnRGYW1pbHkifHx5PT09ImZvbnRTdHlsZSJ8fHk9PT0iZm9udFZhcmlhbnQifHx5PT09ImZvbnRXZWlnaHQifHx5PT09ImZvbnRTdHJldGNoInx8eT09PSJsaW5lSGVpZ2h0Inx8eT09PSJzdHJva2VDb2xvciJ8fHk9PT0iZmlsbENvbG9yInx8eT09PSJzdHJva2VXaWR0aCI/dGhpcy51cGRhdGVUZXh0KCk6KCh5PT09InRleHRBbGlnbiJ8fHk9PT0idmVydGljYWxBbGlnbiIpJiYodGhpc1tPXT0hMCksc3VwZXIub25Qcm9wZXJ0eUNoYW5nZSh5LFMscykpfXVwZGF0ZUNvbnRvdXJzKCl7c3VwZXIudXBkYXRlQ29udG91cnMoKSx0aGlzW09dPSEwfXVwZGF0ZVRleHQoKXt0aGlzW0VdfHwodGhpc1tFXT1Qcm9taXNlLnJlc29sdmUoKS50aGVuKCgpPT57dGhpc1tFXT1udWxsO2NvbnN0e3RleHQ6eSxmb250OlMsZmlsbENvbG9yOnMsc3Ryb2tlQ29sb3I6YyxzdHJva2VXaWR0aDpsfT10aGlzLmF0dHJpYnV0ZXMsdj10aGlzLmxheWVyP3RoaXMubGF5ZXIuZGlzcGxheVJhdGlvOjE7cmV0dXJuIHRoaXNbbV09dGhpc1ttXXx8bi5FTlYuY3JlYXRlQ2FudmFzKDEsMSksdGhpc1tkXT1uLkVOVi5jcmVhdGVUZXh0KHkse2ZvbnQ6UyxmaWxsQ29sb3I6cyxzdHJva2VDb2xvcjpjLHN0cm9rZVdpZHRoOmwscGFyc2VGb250Om4ucGFyc2VGb250LHJhdGlvOnYsdGV4dENhbnZhczp0aGlzW21dfSksdGhpc1tkXS5uZWVkc1VwZGF0ZT0hMCx0aGlzLnVwZGF0ZUNvbnRvdXJzKCksdGhpcy5mb3JjZVVwZGF0ZSgpLHRoaXNbZF19KSl9fWEoYiwiQXR0ciIsaC5kZWZhdWx0KSx1LmRlZmF1bHQucmVnaXN0ZXJOb2RlKGIsImxhYmVsIil9LGZ1bmN0aW9uKGcsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIHB9KTt2YXIgbj10KDEyKSxpPXQoNzIpLGY9dCgyMjEpLGg9dCgyMjApO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCB1PVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZURlZmF1bHQiKSxhPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZSIpLGQ9U3ltYm9sLmZvcigic3ByaXRlanNfZ2V0QXR0cmlidXRlIiksRT1TeW1ib2wuZm9yKCJzcHJpdGVqc19kZWNsYXJlQWxpYXMiKTtjbGFzcyBwIGV4dGVuZHMgaC5kZWZhdWx0e2NvbnN0cnVjdG9yKG0pe3N1cGVyKG0pLHRoaXNbdV0oe3RleHQ6IiIsZm9udFNpemU6MTYsZm9udEZhbWlseToiSGVsdmV0aWNhLEFyaWFsLHNhbnMtc2VyaWYiLGZvbnRTdHlsZToibm9ybWFsIixmb250VmFyaWFudDoibm9ybWFsIixmb250V2VpZ2h0OiJub3JtYWwiLGZvbnRTdHJldGNoOiJub3JtYWwiLGxpbmVIZWlnaHQ6IiIsdGV4dEFsaWduOiJsZWZ0IixzdHJva2VDb2xvcjp2b2lkIDAsc3Ryb2tlV2lkdGg6MSxmaWxsQ29sb3I6dm9pZCAwLHZlcnRpY2FsQWxpZ246Im1pZGRsZSJ9KSx0aGlzW0VdKCJmb250Iil9Z2V0IHRleHQoKXtyZXR1cm4gdGhpc1tkXSgidGV4dCIpfHwiICJ9c2V0IHRleHQobSl7dGhpc1thXSgidGV4dCIsbSl9Z2V0IGZvbnRTaXplKCl7cmV0dXJuIHRoaXNbZF0oImZvbnRTaXplIil9c2V0IGZvbnRTaXplKG0pe3RoaXNbYV0oImZvbnRTaXplIixPYmplY3QoaS50b051bWJlcikobSkpfWdldCBmb250RmFtaWx5KCl7cmV0dXJuIHRoaXNbZF0oImZvbnRGYW1pbHkiKX1zZXQgZm9udEZhbWlseShtKXt0aGlzW2FdKCJmb250RmFtaWx5IixtKX1nZXQgZm9udFN0eWxlKCl7cmV0dXJuIHRoaXNbZF0oImZvbnRTdHlsZSIpfXNldCBmb250U3R5bGUobSl7dGhpc1thXSgiZm9udFN0eWxlIixtKX1nZXQgZm9udFZhcmlhbnQoKXtyZXR1cm4gdGhpc1tkXSgiZm9udFZhcmlhbnQiKX1zZXQgZm9udFZhcmlhbnQobSl7dGhpc1thXSgiZm9udFZhcmlhbnQiLG0pfWdldCBmb250V2VpZ2h0KCl7cmV0dXJuIHRoaXNbZF0oImZvbnRXZWlnaHQiKX1zZXQgZm9udFdlaWdodChtKXt0aGlzW2FdKCJmb250V2VpZ2h0IixtKX1nZXQgZm9udFN0cmV0Y2goKXtyZXR1cm4gdGhpc1tkXSgiZm9udFN0cmV0Y2giKX1zZXQgZm9udFN0cmV0Y2gobSl7dGhpc1thXSgiZm9udFN0cmV0Y2giLG0pfWdldCBsaW5lSGVpZ2h0KCl7cmV0dXJuIHRoaXNbZF0oImxpbmVIZWlnaHQiKXx8dGhpcy5mb250U2l6ZX1zZXQgbGluZUhlaWdodChtKXt0aGlzW2FdKCJsaW5lSGVpZ2h0IixPYmplY3QoaS50b051bWJlcikobSkpfWdldCB0ZXh0QWxpZ24oKXtyZXR1cm4gdGhpc1tkXSgidGV4dEFsaWduIil9c2V0IHRleHRBbGlnbihtKXt0aGlzW2FdKCJ0ZXh0QWxpZ24iLG0pfWdldCBzdHJva2VDb2xvcigpe3JldHVybiB0aGlzW2RdKCJzdHJva2VDb2xvciIpfXNldCBzdHJva2VDb2xvcihtKXt0aGlzW2FdKCJzdHJva2VDb2xvciIsT2JqZWN0KGYucGFyc2VDb2xvcikobSkpfWdldCBzdHJva2VXaWR0aCgpe3JldHVybiB0aGlzW2RdKCJzdHJva2VXaWR0aCIpfXNldCBzdHJva2VXaWR0aChtKXt0aGlzW2FdKCJzdHJva2VXaWR0aCIsT2JqZWN0KGkudG9OdW1iZXIpKG0pKX1nZXQgdmVydGljYWxBbGlnbigpe3JldHVybiB0aGlzW2RdKCJ2ZXJ0aWNhbEFsaWduIil9c2V0IHZlcnRpY2FsQWxpZ24obSl7dGhpc1thXSgidmVydGljYWxBbGlnbiIsbSl9Z2V0IGZpbGxDb2xvcigpe3JldHVybiB0aGlzW2RdKCJmaWxsQ29sb3IiKX1zZXQgZmlsbENvbG9yKG0pe3RoaXNbYV0oImZpbGxDb2xvciIsT2JqZWN0KGYucGFyc2VDb2xvcikobSkpfWdldCBmb250KCl7Y29uc3R7Zm9udFN0eWxlOm0sZm9udFZhcmlhbnQ6Yixmb250V2VpZ2h0Ok0sZm9udFN0cmV0Y2g6eSxmb250U2l6ZTpTLGxpbmVIZWlnaHQ6cyxmb250RmFtaWx5OmN9PXRoaXM7cmV0dXJuYCR7bX0gJHtifSAke019ICR7eX0gJHtTfXB4LyR7c31weCAke2N9YH1zZXQgZm9udChtKXtpZihtPT1udWxsKXRoaXMuZm9udFN0eWxlPW51bGwsdGhpcy5mb250VmFyaWFudD1udWxsLHRoaXMuZm9udFdlaWdodD1udWxsLHRoaXMuZm9udFN0cmV0Y2g9bnVsbCx0aGlzLmZvbnRTaXplPW51bGwsdGhpcy5saW5lSGVpZ2h0PW51bGwsdGhpcy5mb250RmFtaWx5PW51bGw7ZWxzZXtjb25zdCBiPU9iamVjdChuLnBhcnNlRm9udCkobSk7dGhpcy5mb250U3R5bGU9Yi5zdHlsZSx0aGlzLmZvbnRWYXJpYW50PWIudmFyaWFudCx0aGlzLmZvbnRXZWlnaHQ9Yi53ZWlnaHQsdGhpcy5mb250U3RyZXRjaD1iLnN0cmV0Y2gsdGhpcy5mb250U2l6ZT1PYmplY3QoaS50b051bWJlcikoYCR7Yi5zaXplfSR7Yi51bml0fWApLGIubGluZUhlaWdodCYmKHRoaXMubGluZUhlaWdodD1iLnB4TGluZUhlaWdodCksdGhpcy5mb250RmFtaWx5PWIuZmFtaWx5fX19fSxmdW5jdGlvbihnLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBtfSk7dmFyIG49dCgxMiksaT10KDIxOSksZj10KDI1MSksaD10KDIxMyksdT10KDI1Mik7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIGEoYixNLHkpe3JldHVybiBNIGluIGI/T2JqZWN0LmRlZmluZVByb3BlcnR5KGIsTSx7dmFsdWU6eSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOmJbTV09eSxifWNvbnN0IGQ9U3ltYm9sKCJ6T3JkZXIiKSxFPVN5bWJvbCgib3JkZXJlZCIpLHA9U3ltYm9sKCJjaGlsZHJlbiIpLE89U3ltYm9sKCJzZWFsZWQiKTtjbGFzcyBtIGV4dGVuZHMgaS5kZWZhdWx0e2NvbnN0cnVjdG9yKE09e30pe3N1cGVyKE0pLHRoaXNbcF09W10sdGhpc1tFXT1udWxsLHRoaXNbZF09MH1nZXQgY2hpbGROb2Rlcygpe3JldHVybiB0aGlzW3BdfWdldCBjaGlsZHJlbigpe3JldHVybiB0aGlzW3BdfWdldCBvcmRlcmVkQ2hpbGRyZW4oKXtyZXR1cm4gdGhpc1tFXXx8KHRoaXNbRV09Wy4uLnRoaXNbcF1dLHRoaXNbRV0uc29ydCgoTSx5KT0+TS56SW5kZXgteS56SW5kZXh8fE0uek9yZGVyLXkuek9yZGVyKSksdGhpc1tFXX1hcHBlbmQoLi4uTSl7cmV0dXJuIE0ubWFwKHk9PnRoaXMuYXBwZW5kQ2hpbGQoeSkpfWFwcGVuZENoaWxkKE0pe3JldHVybiBNLnJlbW92ZSgpLHRoaXNbcF0ucHVzaChNKSxNLmNvbm5lY3QodGhpcyx0aGlzW2RdKyspLHRoaXNbRV0mJih0aGlzW0VdLmxlbmd0aCYmTS56SW5kZXg8dGhpc1tFXVt0aGlzW0VdLmxlbmd0aC0xXS56SW5kZXg/dGhpcy5yZW9yZGVyKCk6dGhpc1tFXS5wdXNoKE0pKSxNfWNsb25lTm9kZShNPSExKXtjb25zdCB5PXN1cGVyLmNsb25lTm9kZSgpO3JldHVybiBNJiZ0aGlzW3BdLmZvckVhY2goUz0+e2NvbnN0IHM9Uy5jbG9uZU5vZGUoTSk7eS5hcHBlbmRDaGlsZChzKX0pLHl9ZGlzcGF0Y2hQb2ludGVyRXZlbnQoTSl7Y29uc3QgeT10aGlzLm9yZGVyZWRDaGlsZHJlbjtmb3IobGV0IFM9eS5sZW5ndGgtMTtTPj0wO1MtLSlpZih5W1NdLmRpc3BhdGNoUG9pbnRlckV2ZW50KE0pKXJldHVybiEwO3JldHVybiBzdXBlci5kaXNwYXRjaFBvaW50ZXJFdmVudChNKX1kcmF3KE09W10pe2lmKHRoaXMuX19jYWNoZVJlbmRlck1hdHJpeD10aGlzLnJlbmRlck1hdHJpeCxzdXBlci5kcmF3KE0pLCF0aGlzW09dJiZ0aGlzLmF0dHJpYnV0ZXMuZGlzcGxheSE9PSJub25lIil7Y29uc3QgeT10aGlzLm9yZGVyZWRDaGlsZHJlbjtmb3IobGV0IFM9MDtTPHkubGVuZ3RoO1MrKyl5W1NdLmRyYXcoTSl9cmV0dXJuIHRoaXMuX19jYWNoZVJlbmRlck1hdHJpeD1udWxsLE19Z2V0RWxlbWVudEJ5SWQoTSl7cmV0dXJuIE9iamVjdCh1LnF1ZXJ5U2VsZWN0b3IpKGAjJHtNfWAsdGhpcyl9Z2V0RWxlbWVudHNCeUNsYXNzTmFtZShNKXtyZXR1cm4gT2JqZWN0KHUucXVlcnlTZWxlY3RvckFsbCkoYC4ke019YCx0aGlzKX1nZXRFbGVtZW50c0J5TmFtZShNKXtyZXR1cm4gT2JqZWN0KHUucXVlcnlTZWxlY3RvckFsbCkoYFtuYW1lPSIke019Il1gLHRoaXMpfWdldEVsZW1lbnRzQnlUYWdOYW1lKE0pe3JldHVybiBPYmplY3QodS5xdWVyeVNlbGVjdG9yQWxsKShNLHRoaXMpfWluc2VydEJlZm9yZShNLHkpe2lmKHk9PW51bGwpcmV0dXJuIHRoaXMuYXBwZW5kQ2hpbGQoTSk7TS5yZW1vdmUoKTtjb25zdCBTPXRoaXNbcF0uaW5kZXhPZih5KTtpZihTPDApdGhyb3cgbmV3IEVycm9yKCJJbnZhbGlkIHJlZmVyZW5jZSBub2RlLiIpO2NvbnN0IHM9eS56T3JkZXI7Zm9yKGxldCBjPVM7Yzx0aGlzW3BdLmxlbmd0aDtjKyspe2NvbnN0IGw9dGhpc1twXVtjXS56T3JkZXIsdj10aGlzW3BdW2NdO2RlbGV0ZSB2LnpPcmRlcixPYmplY3QuZGVmaW5lUHJvcGVydHkodiwiek9yZGVyIix7dmFsdWU6bCsxLHdyaXRhYmxlOiExLGNvbmZpZ3VyYWJsZTohMH0pfWlmKHRoaXNbcF0uc3BsaWNlKFMsMCxNKSxNLmNvbm5lY3QodGhpcyxzKSx0aGlzW0VdKWlmKE0uekluZGV4IT09eS56SW5kZXgpdGhpcy5yZW9yZGVyKCk7ZWxzZXtjb25zdCBjPXRoaXNbRV0uaW5kZXhPZih5KTt0aGlzW0VdLnNwbGljZShjLDAsTSl9cmV0dXJuIE19cXVlcnlTZWxlY3RvcihNKXtyZXR1cm4gT2JqZWN0KHUucXVlcnlTZWxlY3RvcikoTSx0aGlzKX1xdWVyeVNlbGVjdG9yQWxsKE0pe3JldHVybiBPYmplY3QodS5xdWVyeVNlbGVjdG9yQWxsKShNLHRoaXMpfXJlcGxhY2VDaGlsZChNLHkpe00ucmVtb3ZlKCk7Y29uc3QgUz10aGlzW3BdLmluZGV4T2YoeSk7aWYoUzwwKXRocm93IG5ldyBFcnJvcigiSW52YWxpZCByZWZlcmVuY2Ugbm9kZS4iKTtpZih0aGlzW3BdW1NdPU0sTS5jb25uZWN0KHRoaXMseS56T3JkZXIpLHRoaXNbRV0paWYoTS56SW5kZXghPT15LnpJbmRleCl0aGlzLnJlb3JkZXIoKTtlbHNle2NvbnN0IHM9dGhpc1tFXS5pbmRleE9mKHkpO3RoaXNbRV1bc109TX1yZXR1cm4geS5kaXNjb25uZWN0KHRoaXMpLE19cmVtb3ZlQWxsQ2hpbGRyZW4oKXtjb25zdCBNPXRoaXNbcF07Zm9yKGxldCB5PU0ubGVuZ3RoLTE7eT49MDt5LS0pTVt5XS5yZW1vdmUoKX1yZW1vdmVDaGlsZChNKXtjb25zdCB5PXRoaXNbcF0uaW5kZXhPZihNKTtpZih5Pj0wKXtpZih0aGlzW3BdLnNwbGljZSh5LDEpLHRoaXNbRV0pe2NvbnN0IFM9dGhpc1tFXS5pbmRleE9mKE0pO3RoaXNbRV0uc3BsaWNlKFMsMSl9cmV0dXJuIE0uZGlzY29ubmVjdCh0aGlzKSxNfXJldHVybiBudWxsfXJlb3JkZXIoKXt0aGlzW0VdPW51bGx9c2VhbCgpe2Z1bmN0aW9uIE0oYyxsKXtjb25zdCB2PVtdO2ZvcihsZXQgVD0wO1Q8Yy5sZW5ndGg7VCsrKXtjb25zdCBSPVsuLi5jW1RdXTtmb3IobGV0IEw9MTtMPFIubGVuZ3RoO0wrPTIpe2NvbnN0IE49UltMXSxBPVJbTCsxXTtSW0xdPU4qbFswXStBKmxbMl0rbFs0XSxSW0wrMV09TipsWzFdK0EqbFszXStsWzVdfXYucHVzaChSKX1yZXR1cm4gdn1jb25zdCB5PXRoaXMub3JkZXJlZENoaWxkcmVuLFM9bmV3IG4uRmlndXJlMkQscz10aGlzLmxvY2FsTWF0cml4O2ZvcihsZXQgYz0wO2M8eS5sZW5ndGg7YysrKXtsZXQgbD15W2NdO2lmKGwgaW5zdGFuY2VvZiBtJiYobD1sLnNlYWwoKSksbC5jbGllbnRCb3gpe2xldCB2PWwuY2xpZW50Qm94LmNvbnRvdXJzLnBhdGg7dj1NKHYsbC5sb2NhbE1hdHJpeCksUy5hZGRQYXRoKHYpfWlmKGwucGF0aCl7bGV0IHY9bC5wYXRoLmNvbnRvdXJzLnBhdGg7dj1NKHYsbC5sb2NhbE1hdHJpeCksUy5hZGRQYXRoKHYpfX1yZXR1cm4gdGhpc1tPXT0hMCx0aGlzLmNsaWVudEJveD1TLHtjbGllbnRCb3g6Uyxsb2NhbE1hdHJpeDpzfX1zZXRSZXNvbHV0aW9uKHt3aWR0aDpNLGhlaWdodDp5fSl7c3VwZXIuc2V0UmVzb2x1dGlvbih7d2lkdGg6TSxoZWlnaHQ6eX0pLHRoaXNbcF0uZm9yRWFjaChTPT57Uy5zZXRSZXNvbHV0aW9uKHt3aWR0aDpNLGhlaWdodDp5fSl9KX11cGRhdGVDb250b3Vycygpe3RoaXNbT118fHN1cGVyLnVwZGF0ZUNvbnRvdXJzKCl9fWEobSwiQXR0ciIsZi5kZWZhdWx0KSxoLmRlZmF1bHQucmVnaXN0ZXJOb2RlKG0sImdyb3VwIil9LGZ1bmN0aW9uKGcsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIGl9KTt2YXIgbj10KDIyMCk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NsYXNzIGkgZXh0ZW5kcyBuLmRlZmF1bHR7fX0sZnVuY3Rpb24oZyxlLHQpe3QucihlKSx0LmQoZSwicXVlcnlTZWxlY3RvckFsbCIsZnVuY3Rpb24oKXtyZXR1cm4gT30pLHQuZChlLCJxdWVyeVNlbGVjdG9yIixmdW5jdGlvbigpe3JldHVybiBtfSksdC5kKGUsImlzTWF0Y2hlZCIsZnVuY3Rpb24oKXtyZXR1cm4gYn0pLHQuZChlLCJjb21waWxlIixmdW5jdGlvbigpe3JldHVybiBNfSk7dmFyIG49dCgyMjEpLGk9dCgyMTMpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCBmPXQoMjUzKTtmdW5jdGlvbiBoKHkpe3JldHVybiB5Lm5vZGVUeXBlPT09MXx8aS5kZWZhdWx0LmlzU3ByaXRlTm9kZSh5Lm5vZGVOYW1lKX1mdW5jdGlvbiB1KHkpe3JldHVybiBBcnJheS5mcm9tKHkuY2hpbGROb2Rlc3x8W10pfWZ1bmN0aW9uIGEoeSl7cmV0dXJuIGkuZGVmYXVsdC5pc1Nwcml0ZU5vZGUoeS5ub2RlTmFtZSk/eS5wYXJlbnR8fHkuY2FudmFzfHx5LmNvbnRhaW5lcjp5LnBhcmVudEVsZW1lbnR9ZnVuY3Rpb24gZCh5KXtsZXQgUz15Lmxlbmd0aCxzLGMsbDtmb3IoOy0tUz4tMTspe2ZvcihzPWM9eVtTXSx5W1NdPW51bGwsbD0hMDtjOyl7aWYoeS5pbmRleE9mKGMpPi0xKXtsPSExLHkuc3BsaWNlKFMsMSk7YnJlYWt9Yz1hKGMpfWwmJih5W1NdPXMpfXJldHVybiB5fWNvbnN0IEU9e2lzVGFnOmgsZXhpc3RzT25lKHksUyl7cmV0dXJuIFMuc29tZShzPT5oKHMpP3kocyl8fEUuZXhpc3RzT25lKHksdShzKSk6ITEpfSxnZXRTaWJsaW5ncyh5KXtjb25zdCBTPWEoeSk7cmV0dXJuIFMmJnUoUyl9LGdldENoaWxkcmVuOnUsZ2V0UGFyZW50OmEsZ2V0QXR0cmlidXRlVmFsdWUoeSxTKXtpZih5Lm5vZGVUeXBlPT09MSYmUz09PSJjbGFzcyJ8fFM9PT0iaWQiKXJldHVybiB5W1NdO2lmKHRoaXMuaGFzQXR0cmliKHksUykpe2xldCBzPXkuYXR0cmlidXRlc1tTXTtyZXR1cm4gQXJyYXkuaXNBcnJheShzKSYmKHM9YFske3Muam9pbigpfV1gKSxTdHJpbmcocyl9fSxoYXNBdHRyaWIoeSxTKXtyZXR1cm4geS5hdHRyaWJ1dGVzW1NdIT1udWxsfSxyZW1vdmVTdWJzZXRzOmQsZ2V0TmFtZSh5KXtyZXR1cm4geS50YWdOYW1lP3kudGFnTmFtZS50b0xvd2VyQ2FzZSgpOm51bGx9LGZpbmRPbmU6ZnVuY3Rpb24geShTLHMpe2xldCBjPW51bGw7Zm9yKGxldCBsPTAsdj1zLmxlbmd0aDtsPHYmJiFjO2wrKylpZihTKHNbbF0pKWM9c1tsXTtlbHNle2NvbnN0IFQ9dShzW2xdKTtUJiZULmxlbmd0aD4wJiYoYz15KFMsVCkpfXJldHVybiBjfSxmaW5kQWxsOmZ1bmN0aW9uIHkoUyxzKXtsZXQgYz1bXTtmb3IobGV0IGw9MCx2PXMubGVuZ3RoO2w8djtsKyspe2lmKCFoKHNbbF0pKWNvbnRpbnVlO1Moc1tsXSkmJmMucHVzaChzW2xdKTtjb25zdCBUPXUoc1tsXSk7VCYmKGM9Yy5jb25jYXQoeShTLFQpKSl9cmV0dXJuIGN9LGdldFRleHQ6ZnVuY3Rpb24geShTKXtyZXR1cm4gQXJyYXkuaXNBcnJheShTKT9TLm1hcCh5KS5qb2luKCIiKTpoKFMpP3kodShTKSk6Uy5ub2RlVHlwZT09PTM/Uy5ub2RlVmFsdWU6aS5kZWZhdWx0LmlzU3ByaXRlTm9kZShTLm5vZGVOYW1lKT9TLnRleHQ6IiJ9fTtmdW5jdGlvbiBwKHkpe2lmKHR5cGVvZiB5IT0ic3RyaW5nIilyZXR1cm4geTtsZXQgUz15Lm1hdGNoKC9cWyhiZ2NvbG9yfGZpbGxDb2xvcnxzdHJva2VDb2xvcnxjb2xvcilccyo9XHMqWyciXT9cdytbJyJdP1xdL2cpO3JldHVybiBTJiYoUz1TLm1hcChzPT57Y29uc3QgYz1zLnNsaWNlKDEsLTEpLnNwbGl0KCI9IiksbD1PYmplY3Qobi5wYXJzZUNvbG9yKShjWzFdLnJlcGxhY2UoL1snIl0vZywiIikpO3JldHVybltzLGBbJHtjWzBdfT0iJHtsfSJdYF19KSxTLmZvckVhY2goKFtzLGNdKT0+e3k9eS5yZXBsYWNlKHMsYyl9KSksUz15Lm1hdGNoKC9cW1x3K1xzKj1ccypbJyJdXFsuKz9cXVsnIl1cXS9nKSxTJiYoUz1TLm1hcChzPT57Y29uc3QgYz1zLnNsaWNlKDEsLTEpLnNwbGl0KCI9IiksbD1jWzFdLnNsaWNlKDIsLTIpLnNwbGl0KC8sL2cpLm1hcCh2PT52LnRyaW0oKSk7cmV0dXJuW3MsYFske2NbMF19PSJbJHtsfV0iXWBdfSksUy5mb3JFYWNoKChbcyxjXSk9Pnt5PXkucmVwbGFjZShzLGMpfSkpLHl9ZnVuY3Rpb24gTyh5LFMpe3JldHVybiBmLnNlbGVjdEFsbChwKHkpLFMse2FkYXB0ZXI6RX0pfWZ1bmN0aW9uIG0oeSxTKXtyZXR1cm4gZi5zZWxlY3RPbmUocCh5KSxTLHthZGFwdGVyOkV9KX1mdW5jdGlvbiBiKHksUyl7cmV0dXJuIGYuaXMoeSxwKFMpLHthZGFwdGVyOkV9KX1mdW5jdGlvbiBNKHkpe3JldHVybiBmLmNvbXBpbGUocCh5KSx7YWRhcHRlcjpFfSl9fSxmdW5jdGlvbihnLGUsdCl7Zy5leHBvcnRzPU07dmFyIG49dCgyNTQpLGk9dCgyNzMpLmZhbHNlRnVuYyxmPXQoMjc0KTtmdW5jdGlvbiBoKHkpe3JldHVybiBmdW5jdGlvbihzLGMsbCl7cmV0dXJuIGM9Y3x8e30sYy5hZGFwdGVyPWMuYWRhcHRlcnx8bix5KHMsYyxsKX19dmFyIHU9aChmKSxhPWgoZi5jb21waWxlVW5zYWZlKTtmdW5jdGlvbiBkKHkpe3JldHVybiBmdW5jdGlvbihzLGMsbCl7cmV0dXJuIGw9bHx8e30sbC5hZGFwdGVyPWwuYWRhcHRlcnx8bix0eXBlb2YgcyE9ImZ1bmN0aW9uIiYmKHM9YShzLGwsYykpLHMuc2hvdWxkVGVzdE5leHRTaWJsaW5ncyYmKGM9cChsJiZsLmNvbnRleHR8fGMsbC5hZGFwdGVyKSksQXJyYXkuaXNBcnJheShjKT9jPWwuYWRhcHRlci5yZW1vdmVTdWJzZXRzKGMpOmM9bC5hZGFwdGVyLmdldENoaWxkcmVuKGMpLHkocyxjLGwpfX1mdW5jdGlvbiBFKHksUyl7dmFyIHM9Uy5nZXRTaWJsaW5ncyh5KTtpZighQXJyYXkuaXNBcnJheShzKSlyZXR1cm5bXTtmb3Iocz1zLnNsaWNlKDApO3Muc2hpZnQoKSE9PXk7KTtyZXR1cm4gc31mdW5jdGlvbiBwKHksUyl7QXJyYXkuaXNBcnJheSh5KXx8KHk9W3ldKTtmb3IodmFyIHM9eS5zbGljZSgwKSxjPTAsbD15Lmxlbmd0aDtjPGw7YysrKXt2YXIgdj1FKHNbY10sUyk7cy5wdXNoLmFwcGx5KHMsdil9cmV0dXJuIHN9dmFyIE89ZChmdW5jdGlvbihTLHMsYyl7cmV0dXJuIFM9PT1pfHwhc3x8cy5sZW5ndGg9PT0wP1tdOmMuYWRhcHRlci5maW5kQWxsKFMscyl9KSxtPWQoZnVuY3Rpb24oUyxzLGMpe3JldHVybiBTPT09aXx8IXN8fHMubGVuZ3RoPT09MD9udWxsOmMuYWRhcHRlci5maW5kT25lKFMscyl9KTtmdW5jdGlvbiBiKHksUyxzKXtyZXR1cm4gcz1zfHx7fSxzLmFkYXB0ZXI9cy5hZGFwdGVyfHxuLCh0eXBlb2YgUz09ImZ1bmN0aW9uIj9TOnUoUyxzKSkoeSl9ZnVuY3Rpb24gTSh5LFMscyl7cmV0dXJuIE8oeSxTLHMpfU0uY29tcGlsZT11LE0uZmlsdGVycz1mLlBzZXVkb3MuZmlsdGVycyxNLnBzZXVkb3M9Zi5Qc2V1ZG9zLnBzZXVkb3MsTS5zZWxlY3RBbGw9TyxNLnNlbGVjdE9uZT1tLE0uaXM9YixNLnBhcnNlPXUsTS5pdGVyYXRlPU8sTS5fY29tcGlsZVVuc2FmZT1hLE0uX2NvbXBpbGVUb2tlbj1mLmNvbXBpbGVUb2tlbn0sZnVuY3Rpb24oZyxlLHQpe3ZhciBuPWcuZXhwb3J0cztbdCgyNTUpLHQoMjY4KSx0KDI2OSksdCgyNzApLHQoMjcxKSx0KDI3MildLmZvckVhY2goZnVuY3Rpb24oaSl7T2JqZWN0LmtleXMoaSkuZm9yRWFjaChmdW5jdGlvbihmKXtuW2ZdPWlbZl0uYmluZChuKX0pfSl9LGZ1bmN0aW9uKGcsZSx0KXt2YXIgbj10KDI1NiksaT10KDI1NyksZj1uLmlzVGFnO2cuZXhwb3J0cz17Z2V0SW5uZXJIVE1MOmgsZ2V0T3V0ZXJIVE1MOmksZ2V0VGV4dDp1fTtmdW5jdGlvbiBoKGEsZCl7cmV0dXJuIGEuY2hpbGRyZW4/YS5jaGlsZHJlbi5tYXAoZnVuY3Rpb24oRSl7cmV0dXJuIGkoRSxkKX0pLmpvaW4oIiIpOiIifWZ1bmN0aW9uIHUoYSl7cmV0dXJuIEFycmF5LmlzQXJyYXkoYSk/YS5tYXAodSkuam9pbigiIik6ZihhKT9hLm5hbWU9PT0iYnIiP2AKYDp1KGEuY2hpbGRyZW4pOmEudHlwZT09PW4uQ0RBVEE/dShhLmNoaWxkcmVuKTphLnR5cGU9PT1uLlRleHQ/YS5kYXRhOiIifX0sZnVuY3Rpb24oZyxlKXtnLmV4cG9ydHM9e1RleHQ6InRleHQiLERpcmVjdGl2ZToiZGlyZWN0aXZlIixDb21tZW50OiJjb21tZW50IixTY3JpcHQ6InNjcmlwdCIsU3R5bGU6InN0eWxlIixUYWc6InRhZyIsQ0RBVEE6ImNkYXRhIixEb2N0eXBlOiJkb2N0eXBlIixpc1RhZzpmdW5jdGlvbih0KXtyZXR1cm4gdC50eXBlPT09InRhZyJ8fHQudHlwZT09PSJzY3JpcHQifHx0LnR5cGU9PT0ic3R5bGUifX19LGZ1bmN0aW9uKGcsZSx0KXt2YXIgbj10KDI1OCksaT10KDI1OSksZj10KDI2Nyk7Zi5lbGVtZW50TmFtZXMuX19wcm90b19fPW51bGwsZi5hdHRyaWJ1dGVOYW1lcy5fX3Byb3RvX189bnVsbDt2YXIgaD17X19wcm90b19fOm51bGwsc3R5bGU6ITAsc2NyaXB0OiEwLHhtcDohMCxpZnJhbWU6ITAsbm9lbWJlZDohMCxub2ZyYW1lczohMCxwbGFpbnRleHQ6ITAsbm9zY3JpcHQ6ITB9O2Z1bmN0aW9uIHUoeSxTKXtpZih5KXt2YXIgcz0iIixjO2Zvcih2YXIgbCBpbiB5KWM9eVtsXSxzJiYocys9IiAiKSxTLnhtbE1vZGU9PT0iZm9yZWlnbiImJihsPWYuYXR0cmlidXRlTmFtZXNbbF18fGwpLHMrPWwsKGMhPT1udWxsJiZjIT09IiJ8fFMueG1sTW9kZSkmJihzKz0nPSInKyhTLmRlY29kZUVudGl0aWVzP2kuZW5jb2RlWE1MKGMpOmMucmVwbGFjZSgvXCIvZywiJnF1b3Q7IikpKyciJyk7cmV0dXJuIHN9fXZhciBhPXtfX3Byb3RvX186bnVsbCxhcmVhOiEwLGJhc2U6ITAsYmFzZWZvbnQ6ITAsYnI6ITAsY29sOiEwLGNvbW1hbmQ6ITAsZW1iZWQ6ITAsZnJhbWU6ITAsaHI6ITAsaW1nOiEwLGlucHV0OiEwLGlzaW5kZXg6ITAsa2V5Z2VuOiEwLGxpbms6ITAsbWV0YTohMCxwYXJhbTohMCxzb3VyY2U6ITAsdHJhY2s6ITAsd2JyOiEwfSxkPWcuZXhwb3J0cz1mdW5jdGlvbih5LFMpeyFBcnJheS5pc0FycmF5KHkpJiYheS5jaGVlcmlvJiYoeT1beV0pLFM9U3x8e307Zm9yKHZhciBzPSIiLGM9MDtjPHkubGVuZ3RoO2MrKyl7dmFyIGw9eVtjXTtsLnR5cGU9PT0icm9vdCI/cys9ZChsLmNoaWxkcmVuLFMpOm4uaXNUYWcobCk/cys9cChsLFMpOmwudHlwZT09PW4uRGlyZWN0aXZlP3MrPU8obCk6bC50eXBlPT09bi5Db21tZW50P3MrPU0obCk6bC50eXBlPT09bi5DREFUQT9zKz1iKGwpOnMrPW0obCxTKX1yZXR1cm4gc30sRT1bIm1pIiwibW8iLCJtbiIsIm1zIiwibXRleHQiLCJhbm5vdGF0aW9uLXhtbCIsImZvcmVpZ25PYmplY3QiLCJkZXNjIiwidGl0bGUiXTtmdW5jdGlvbiBwKHksUyl7Uy54bWxNb2RlPT09ImZvcmVpZ24iJiYoeS5uYW1lPWYuZWxlbWVudE5hbWVzW3kubmFtZV18fHkubmFtZSx5LnBhcmVudCYmRS5pbmRleE9mKHkucGFyZW50Lm5hbWUpPj0wJiYoUz1PYmplY3QuYXNzaWduKHt9LFMse3htbE1vZGU6ITF9KSkpLCFTLnhtbE1vZGUmJlsic3ZnIiwibWF0aCJdLmluZGV4T2YoeS5uYW1lKT49MCYmKFM9T2JqZWN0LmFzc2lnbih7fSxTLHt4bWxNb2RlOiJmb3JlaWduIn0pKTt2YXIgcz0iPCIreS5uYW1lLGM9dSh5LmF0dHJpYnMsUyk7cmV0dXJuIGMmJihzKz0iICIrYyksUy54bWxNb2RlJiYoIXkuY2hpbGRyZW58fHkuY2hpbGRyZW4ubGVuZ3RoPT09MCk/cys9Ii8+Ijoocys9Ij4iLHkuY2hpbGRyZW4mJihzKz1kKHkuY2hpbGRyZW4sUykpLCghYVt5Lm5hbWVdfHxTLnhtbE1vZGUpJiYocys9IjwvIit5Lm5hbWUrIj4iKSksc31mdW5jdGlvbiBPKHkpe3JldHVybiI8Iit5LmRhdGErIj4ifWZ1bmN0aW9uIG0oeSxTKXt2YXIgcz15LmRhdGF8fCIiO3JldHVybiBTLmRlY29kZUVudGl0aWVzJiYhKHkucGFyZW50JiZ5LnBhcmVudC5uYW1lIGluIGgpJiYocz1pLmVuY29kZVhNTChzKSksc31mdW5jdGlvbiBiKHkpe3JldHVybiI8IVtDREFUQVsiK3kuY2hpbGRyZW5bMF0uZGF0YSsiXV0+In1mdW5jdGlvbiBNKHkpe3JldHVybiI8IS0tIit5LmRhdGErIi0tPiJ9fSxmdW5jdGlvbihnLGUsdCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pO2Z1bmN0aW9uIG4oaSl7cmV0dXJuIGkudHlwZT09PSJ0YWcifHxpLnR5cGU9PT0ic2NyaXB0Inx8aS50eXBlPT09InN0eWxlIn1lLmlzVGFnPW4sZS5UZXh0PSJ0ZXh0IixlLkRpcmVjdGl2ZT0iZGlyZWN0aXZlIixlLkNvbW1lbnQ9ImNvbW1lbnQiLGUuU2NyaXB0PSJzY3JpcHQiLGUuU3R5bGU9InN0eWxlIixlLlRhZz0idGFnIixlLkNEQVRBPSJjZGF0YSIsZS5Eb2N0eXBlPSJkb2N0eXBlIn0sZnVuY3Rpb24oZyxlLHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxlLmVuY29kZT1lLmRlY29kZVN0cmljdD1lLmRlY29kZT12b2lkIDA7dmFyIG49dCgyNjApLGk9dCgyNjYpO2Z1bmN0aW9uIGYoRSxwKXtyZXR1cm4oIXB8fHA8PTA/bi5kZWNvZGVYTUw6bi5kZWNvZGVIVE1MKShFKX1lLmRlY29kZT1mO2Z1bmN0aW9uIGgoRSxwKXtyZXR1cm4oIXB8fHA8PTA/bi5kZWNvZGVYTUw6bi5kZWNvZGVIVE1MU3RyaWN0KShFKX1lLmRlY29kZVN0cmljdD1oO2Z1bmN0aW9uIHUoRSxwKXtyZXR1cm4oIXB8fHA8PTA/aS5lbmNvZGVYTUw6aS5lbmNvZGVIVE1MKShFKX1lLmVuY29kZT11O3ZhciBhPXQoMjY2KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiZW5jb2RlWE1MIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gYS5lbmNvZGVYTUx9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsImVuY29kZUhUTUwiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBhLmVuY29kZUhUTUx9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsImVzY2FwZSIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGEuZXNjYXBlfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJlbmNvZGVIVE1MNCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGEuZW5jb2RlSFRNTH19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiZW5jb2RlSFRNTDUiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBhLmVuY29kZUhUTUx9fSk7dmFyIGQ9dCgyNjApO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJkZWNvZGVYTUwiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBkLmRlY29kZVhNTH19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiZGVjb2RlSFRNTCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGQuZGVjb2RlSFRNTH19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiZGVjb2RlSFRNTFN0cmljdCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGQuZGVjb2RlSFRNTFN0cmljdH19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiZGVjb2RlSFRNTDQiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBkLmRlY29kZUhUTUx9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsImRlY29kZUhUTUw1Iix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gZC5kZWNvZGVIVE1MfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJkZWNvZGVIVE1MNFN0cmljdCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGQuZGVjb2RlSFRNTFN0cmljdH19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiZGVjb2RlSFRNTDVTdHJpY3QiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBkLmRlY29kZUhUTUxTdHJpY3R9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsImRlY29kZVhNTFN0cmljdCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGQuZGVjb2RlWE1MfX0pfSxmdW5jdGlvbihnLGUsdCl7dmFyIG49dGhpcyYmdGhpcy5fX2ltcG9ydERlZmF1bHR8fGZ1bmN0aW9uKHApe3JldHVybiBwJiZwLl9fZXNNb2R1bGU/cDp7ZGVmYXVsdDpwfX07T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLGUuZGVjb2RlSFRNTD1lLmRlY29kZUhUTUxTdHJpY3Q9ZS5kZWNvZGVYTUw9dm9pZCAwO3ZhciBpPW4odCgyNjEpKSxmPW4odCgyNjIpKSxoPW4odCgyNjMpKSx1PW4odCgyNjQpKTtlLmRlY29kZVhNTD1hKGguZGVmYXVsdCksZS5kZWNvZGVIVE1MU3RyaWN0PWEoaS5kZWZhdWx0KTtmdW5jdGlvbiBhKHApe3ZhciBPPU9iamVjdC5rZXlzKHApLmpvaW4oInwiKSxtPUUocCk7Tys9InwjW3hYXVtcXGRhLWZBLUZdK3wjXFxkKyI7dmFyIGI9bmV3IFJlZ0V4cCgiJig/OiIrTysiKTsiLCJnIik7cmV0dXJuIGZ1bmN0aW9uKE0pe3JldHVybiBTdHJpbmcoTSkucmVwbGFjZShiLG0pfX12YXIgZD1mdW5jdGlvbihwLE8pe3JldHVybiBwPE8/MTotMX07ZS5kZWNvZGVIVE1MPWZ1bmN0aW9uKCl7Zm9yKHZhciBwPU9iamVjdC5rZXlzKGYuZGVmYXVsdCkuc29ydChkKSxPPU9iamVjdC5rZXlzKGkuZGVmYXVsdCkuc29ydChkKSxtPTAsYj0wO208Ty5sZW5ndGg7bSsrKXBbYl09PT1PW21dPyhPW21dKz0iOz8iLGIrKyk6T1ttXSs9IjsiO3ZhciBNPW5ldyBSZWdFeHAoIiYoPzoiK08uam9pbigifCIpKyJ8I1t4WF1bXFxkYS1mQS1GXSs7P3wjXFxkKzs/KSIsImciKSx5PUUoaS5kZWZhdWx0KTtmdW5jdGlvbiBTKHMpe3JldHVybiBzLnN1YnN0cigtMSkhPT0iOyImJihzKz0iOyIpLHkocyl9cmV0dXJuIGZ1bmN0aW9uKHMpe3JldHVybiBTdHJpbmcocykucmVwbGFjZShNLFMpfX0oKTtmdW5jdGlvbiBFKHApe3JldHVybiBmdW5jdGlvbihtKXtpZihtLmNoYXJBdCgxKT09PSIjIil7dmFyIGI9bS5jaGFyQXQoMik7cmV0dXJuIGI9PT0iWCJ8fGI9PT0ieCI/dS5kZWZhdWx0KHBhcnNlSW50KG0uc3Vic3RyKDMpLDE2KSk6dS5kZWZhdWx0KHBhcnNlSW50KG0uc3Vic3RyKDIpLDEwKSl9cmV0dXJuIHBbbS5zbGljZSgxLC0xKV19fX0sZnVuY3Rpb24oZyl7Zy5leHBvcnRzPUpTT04ucGFyc2UoJ3siQWFjdXRlIjoiw4EiLCJhYWN1dGUiOiLDoSIsIkFicmV2ZSI6IsSCIiwiYWJyZXZlIjoixIMiLCJhYyI6IuKIviIsImFjZCI6IuKIvyIsImFjRSI6IuKIvsyzIiwiQWNpcmMiOiLDgiIsImFjaXJjIjoiw6IiLCJhY3V0ZSI6IsK0IiwiQWN5Ijoi0JAiLCJhY3kiOiLQsCIsIkFFbGlnIjoiw4YiLCJhZWxpZyI6IsOmIiwiYWYiOiLigaEiLCJBZnIiOiLwnZSEIiwiYWZyIjoi8J2UniIsIkFncmF2ZSI6IsOAIiwiYWdyYXZlIjoiw6AiLCJhbGVmc3ltIjoi4oS1IiwiYWxlcGgiOiLihLUiLCJBbHBoYSI6Is6RIiwiYWxwaGEiOiLOsSIsIkFtYWNyIjoixIAiLCJhbWFjciI6IsSBIiwiYW1hbGciOiLiqL8iLCJhbXAiOiImIiwiQU1QIjoiJiIsImFuZGFuZCI6IuKplSIsIkFuZCI6IuKpkyIsImFuZCI6IuKIpyIsImFuZGQiOiLiqZwiLCJhbmRzbG9wZSI6IuKpmCIsImFuZHYiOiLiqZoiLCJhbmciOiLiiKAiLCJhbmdlIjoi4qakIiwiYW5nbGUiOiLiiKAiLCJhbmdtc2RhYSI6IuKmqCIsImFuZ21zZGFiIjoi4qapIiwiYW5nbXNkYWMiOiLipqoiLCJhbmdtc2RhZCI6IuKmqyIsImFuZ21zZGFlIjoi4qasIiwiYW5nbXNkYWYiOiLipq0iLCJhbmdtc2RhZyI6IuKmriIsImFuZ21zZGFoIjoi4qavIiwiYW5nbXNkIjoi4oihIiwiYW5ncnQiOiLiiJ8iLCJhbmdydHZiIjoi4oq+IiwiYW5ncnR2YmQiOiLipp0iLCJhbmdzcGgiOiLiiKIiLCJhbmdzdCI6IsOFIiwiYW5nemFyciI6IuKNvCIsIkFvZ29uIjoixIQiLCJhb2dvbiI6IsSFIiwiQW9wZiI6IvCdlLgiLCJhb3BmIjoi8J2VkiIsImFwYWNpciI6IuKpryIsImFwIjoi4omIIiwiYXBFIjoi4qmwIiwiYXBlIjoi4omKIiwiYXBpZCI6IuKJiyIsImFwb3MiOiJcJyIsIkFwcGx5RnVuY3Rpb24iOiLigaEiLCJhcHByb3giOiLiiYgiLCJhcHByb3hlcSI6IuKJiiIsIkFyaW5nIjoiw4UiLCJhcmluZyI6IsOlIiwiQXNjciI6IvCdkpwiLCJhc2NyIjoi8J2StiIsIkFzc2lnbiI6IuKJlCIsImFzdCI6IioiLCJhc3ltcCI6IuKJiCIsImFzeW1wZXEiOiLiiY0iLCJBdGlsZGUiOiLDgyIsImF0aWxkZSI6IsOjIiwiQXVtbCI6IsOEIiwiYXVtbCI6IsOkIiwiYXdjb25pbnQiOiLiiLMiLCJhd2ludCI6IuKokSIsImJhY2tjb25nIjoi4omMIiwiYmFja2Vwc2lsb24iOiLPtiIsImJhY2twcmltZSI6IuKAtSIsImJhY2tzaW0iOiLiiL0iLCJiYWNrc2ltZXEiOiLii40iLCJCYWNrc2xhc2giOiLiiJYiLCJCYXJ2Ijoi4qunIiwiYmFydmVlIjoi4oq9IiwiYmFyd2VkIjoi4oyFIiwiQmFyd2VkIjoi4oyGIiwiYmFyd2VkZ2UiOiLijIUiLCJiYnJrIjoi4o61IiwiYmJya3RicmsiOiLijrYiLCJiY29uZyI6IuKJjCIsIkJjeSI6ItCRIiwiYmN5Ijoi0LEiLCJiZHF1byI6IuKAniIsImJlY2F1cyI6IuKItSIsImJlY2F1c2UiOiLiiLUiLCJCZWNhdXNlIjoi4oi1IiwiYmVtcHR5diI6IuKmsCIsImJlcHNpIjoiz7YiLCJiZXJub3UiOiLihKwiLCJCZXJub3VsbGlzIjoi4oSsIiwiQmV0YSI6Is6SIiwiYmV0YSI6Is6yIiwiYmV0aCI6IuKEtiIsImJldHdlZW4iOiLiiawiLCJCZnIiOiLwnZSFIiwiYmZyIjoi8J2UnyIsImJpZ2NhcCI6IuKLgiIsImJpZ2NpcmMiOiLil68iLCJiaWdjdXAiOiLii4MiLCJiaWdvZG90Ijoi4qiAIiwiYmlnb3BsdXMiOiLiqIEiLCJiaWdvdGltZXMiOiLiqIIiLCJiaWdzcWN1cCI6IuKohiIsImJpZ3N0YXIiOiLimIUiLCJiaWd0cmlhbmdsZWRvd24iOiLilr0iLCJiaWd0cmlhbmdsZXVwIjoi4pazIiwiYmlndXBsdXMiOiLiqIQiLCJiaWd2ZWUiOiLii4EiLCJiaWd3ZWRnZSI6IuKLgCIsImJrYXJvdyI6IuKkjSIsImJsYWNrbG96ZW5nZSI6IuKnqyIsImJsYWNrc3F1YXJlIjoi4paqIiwiYmxhY2t0cmlhbmdsZSI6IuKWtCIsImJsYWNrdHJpYW5nbGVkb3duIjoi4pa+IiwiYmxhY2t0cmlhbmdsZWxlZnQiOiLil4IiLCJibGFja3RyaWFuZ2xlcmlnaHQiOiLilrgiLCJibGFuayI6IuKQoyIsImJsazEyIjoi4paSIiwiYmxrMTQiOiLilpEiLCJibGszNCI6IuKWkyIsImJsb2NrIjoi4paIIiwiYm5lIjoiPeKDpSIsImJuZXF1aXYiOiLiiaHig6UiLCJiTm90Ijoi4qutIiwiYm5vdCI6IuKMkCIsIkJvcGYiOiLwnZS5IiwiYm9wZiI6IvCdlZMiLCJib3QiOiLiiqUiLCJib3R0b20iOiLiiqUiLCJib3d0aWUiOiLii4giLCJib3hib3giOiLip4kiLCJib3hkbCI6IuKUkCIsImJveGRMIjoi4pWVIiwiYm94RGwiOiLilZYiLCJib3hETCI6IuKVlyIsImJveGRyIjoi4pSMIiwiYm94ZFIiOiLilZIiLCJib3hEciI6IuKVkyIsImJveERSIjoi4pWUIiwiYm94aCI6IuKUgCIsImJveEgiOiLilZAiLCJib3hoZCI6IuKUrCIsImJveEhkIjoi4pWkIiwiYm94aEQiOiLilaUiLCJib3hIRCI6IuKVpiIsImJveGh1Ijoi4pS0IiwiYm94SHUiOiLilaciLCJib3hoVSI6IuKVqCIsImJveEhVIjoi4pWpIiwiYm94bWludXMiOiLiip8iLCJib3hwbHVzIjoi4oqeIiwiYm94dGltZXMiOiLiiqAiLCJib3h1bCI6IuKUmCIsImJveHVMIjoi4pWbIiwiYm94VWwiOiLilZwiLCJib3hVTCI6IuKVnSIsImJveHVyIjoi4pSUIiwiYm94dVIiOiLilZgiLCJib3hVciI6IuKVmSIsImJveFVSIjoi4pWaIiwiYm94diI6IuKUgiIsImJveFYiOiLilZEiLCJib3h2aCI6IuKUvCIsImJveHZIIjoi4pWqIiwiYm94VmgiOiLilasiLCJib3hWSCI6IuKVrCIsImJveHZsIjoi4pSkIiwiYm94dkwiOiLilaEiLCJib3hWbCI6IuKVoiIsImJveFZMIjoi4pWjIiwiYm94dnIiOiLilJwiLCJib3h2UiI6IuKVniIsImJveFZyIjoi4pWfIiwiYm94VlIiOiLilaAiLCJicHJpbWUiOiLigLUiLCJicmV2ZSI6IsuYIiwiQnJldmUiOiLLmCIsImJydmJhciI6IsKmIiwiYnNjciI6IvCdkrciLCJCc2NyIjoi4oSsIiwiYnNlbWkiOiLigY8iLCJic2ltIjoi4oi9IiwiYnNpbWUiOiLii40iLCJic29sYiI6IuKnhSIsImJzb2wiOiJcXFxcIiwiYnNvbGhzdWIiOiLin4giLCJidWxsIjoi4oCiIiwiYnVsbGV0Ijoi4oCiIiwiYnVtcCI6IuKJjiIsImJ1bXBFIjoi4qquIiwiYnVtcGUiOiLiiY8iLCJCdW1wZXEiOiLiiY4iLCJidW1wZXEiOiLiiY8iLCJDYWN1dGUiOiLEhiIsImNhY3V0ZSI6IsSHIiwiY2FwYW5kIjoi4qmEIiwiY2FwYnJjdXAiOiLiqYkiLCJjYXBjYXAiOiLiqYsiLCJjYXAiOiLiiKkiLCJDYXAiOiLii5IiLCJjYXBjdXAiOiLiqYciLCJjYXBkb3QiOiLiqYAiLCJDYXBpdGFsRGlmZmVyZW50aWFsRCI6IuKFhSIsImNhcHMiOiLiiKnvuIAiLCJjYXJldCI6IuKBgSIsImNhcm9uIjoiy4ciLCJDYXlsZXlzIjoi4oStIiwiY2NhcHMiOiLiqY0iLCJDY2Fyb24iOiLEjCIsImNjYXJvbiI6IsSNIiwiQ2NlZGlsIjoiw4ciLCJjY2VkaWwiOiLDpyIsIkNjaXJjIjoixIgiLCJjY2lyYyI6IsSJIiwiQ2NvbmludCI6IuKIsCIsImNjdXBzIjoi4qmMIiwiY2N1cHNzbSI6IuKpkCIsIkNkb3QiOiLEiiIsImNkb3QiOiLEiyIsImNlZGlsIjoiwrgiLCJDZWRpbGxhIjoiwrgiLCJjZW1wdHl2Ijoi4qayIiwiY2VudCI6IsKiIiwiY2VudGVyZG90IjoiwrciLCJDZW50ZXJEb3QiOiLCtyIsImNmciI6IvCdlKAiLCJDZnIiOiLihK0iLCJDSGN5Ijoi0KciLCJjaGN5Ijoi0YciLCJjaGVjayI6IuKckyIsImNoZWNrbWFyayI6IuKckyIsIkNoaSI6Is6nIiwiY2hpIjoiz4ciLCJjaXJjIjoiy4YiLCJjaXJjZXEiOiLiiZciLCJjaXJjbGVhcnJvd2xlZnQiOiLihroiLCJjaXJjbGVhcnJvd3JpZ2h0Ijoi4oa7IiwiY2lyY2xlZGFzdCI6IuKKmyIsImNpcmNsZWRjaXJjIjoi4oqaIiwiY2lyY2xlZGRhc2giOiLiip0iLCJDaXJjbGVEb3QiOiLiipkiLCJjaXJjbGVkUiI6IsKuIiwiY2lyY2xlZFMiOiLik4giLCJDaXJjbGVNaW51cyI6IuKKliIsIkNpcmNsZVBsdXMiOiLiipUiLCJDaXJjbGVUaW1lcyI6IuKKlyIsImNpciI6IuKXiyIsImNpckUiOiLip4MiLCJjaXJlIjoi4omXIiwiY2lyZm5pbnQiOiLiqJAiLCJjaXJtaWQiOiLiq68iLCJjaXJzY2lyIjoi4qeCIiwiQ2xvY2t3aXNlQ29udG91ckludGVncmFsIjoi4oiyIiwiQ2xvc2VDdXJseURvdWJsZVF1b3RlIjoi4oCdIiwiQ2xvc2VDdXJseVF1b3RlIjoi4oCZIiwiY2x1YnMiOiLimaMiLCJjbHVic3VpdCI6IuKZoyIsImNvbG9uIjoiOiIsIkNvbG9uIjoi4oi3IiwiQ29sb25lIjoi4qm0IiwiY29sb25lIjoi4omUIiwiY29sb25lcSI6IuKJlCIsImNvbW1hIjoiLCIsImNvbW1hdCI6IkAiLCJjb21wIjoi4oiBIiwiY29tcGZuIjoi4oiYIiwiY29tcGxlbWVudCI6IuKIgSIsImNvbXBsZXhlcyI6IuKEgiIsImNvbmciOiLiiYUiLCJjb25nZG90Ijoi4qmtIiwiQ29uZ3J1ZW50Ijoi4omhIiwiY29uaW50Ijoi4oiuIiwiQ29uaW50Ijoi4oivIiwiQ29udG91ckludGVncmFsIjoi4oiuIiwiY29wZiI6IvCdlZQiLCJDb3BmIjoi4oSCIiwiY29wcm9kIjoi4oiQIiwiQ29wcm9kdWN0Ijoi4oiQIiwiY29weSI6IsKpIiwiQ09QWSI6IsKpIiwiY29weXNyIjoi4oSXIiwiQ291bnRlckNsb2Nrd2lzZUNvbnRvdXJJbnRlZ3JhbCI6IuKIsyIsImNyYXJyIjoi4oa1IiwiY3Jvc3MiOiLinJciLCJDcm9zcyI6IuKoryIsIkNzY3IiOiLwnZKeIiwiY3NjciI6IvCdkrgiLCJjc3ViIjoi4quPIiwiY3N1YmUiOiLiq5EiLCJjc3VwIjoi4quQIiwiY3N1cGUiOiLiq5IiLCJjdGRvdCI6IuKLryIsImN1ZGFycmwiOiLipLgiLCJjdWRhcnJyIjoi4qS1IiwiY3VlcHIiOiLii54iLCJjdWVzYyI6IuKLnyIsImN1bGFyciI6IuKGtiIsImN1bGFycnAiOiLipL0iLCJjdXBicmNhcCI6IuKpiCIsImN1cGNhcCI6IuKphiIsIkN1cENhcCI6IuKJjSIsImN1cCI6IuKIqiIsIkN1cCI6IuKLkyIsImN1cGN1cCI6IuKpiiIsImN1cGRvdCI6IuKKjSIsImN1cG9yIjoi4qmFIiwiY3VwcyI6IuKIqu+4gCIsImN1cmFyciI6IuKGtyIsImN1cmFycm0iOiLipLwiLCJjdXJseWVxcHJlYyI6IuKLniIsImN1cmx5ZXFzdWNjIjoi4oufIiwiY3VybHl2ZWUiOiLii44iLCJjdXJseXdlZGdlIjoi4ouPIiwiY3VycmVuIjoiwqQiLCJjdXJ2ZWFycm93bGVmdCI6IuKGtiIsImN1cnZlYXJyb3dyaWdodCI6IuKGtyIsImN1dmVlIjoi4ouOIiwiY3V3ZWQiOiLii48iLCJjd2NvbmludCI6IuKIsiIsImN3aW50Ijoi4oixIiwiY3lsY3R5Ijoi4oytIiwiZGFnZ2VyIjoi4oCgIiwiRGFnZ2VyIjoi4oChIiwiZGFsZXRoIjoi4oS4IiwiZGFyciI6IuKGkyIsIkRhcnIiOiLihqEiLCJkQXJyIjoi4oeTIiwiZGFzaCI6IuKAkCIsIkRhc2h2Ijoi4qukIiwiZGFzaHYiOiLiiqMiLCJkYmthcm93Ijoi4qSPIiwiZGJsYWMiOiLLnSIsIkRjYXJvbiI6IsSOIiwiZGNhcm9uIjoixI8iLCJEY3kiOiLQlCIsImRjeSI6ItC0IiwiZGRhZ2dlciI6IuKAoSIsImRkYXJyIjoi4oeKIiwiREQiOiLihYUiLCJkZCI6IuKFhiIsIkREb3RyYWhkIjoi4qSRIiwiZGRvdHNlcSI6IuKptyIsImRlZyI6IsKwIiwiRGVsIjoi4oiHIiwiRGVsdGEiOiLOlCIsImRlbHRhIjoizrQiLCJkZW1wdHl2Ijoi4qaxIiwiZGZpc2h0Ijoi4qW/IiwiRGZyIjoi8J2UhyIsImRmciI6IvCdlKEiLCJkSGFyIjoi4qWlIiwiZGhhcmwiOiLih4MiLCJkaGFyciI6IuKHgiIsIkRpYWNyaXRpY2FsQWN1dGUiOiLCtCIsIkRpYWNyaXRpY2FsRG90Ijoiy5kiLCJEaWFjcml0aWNhbERvdWJsZUFjdXRlIjoiy50iLCJEaWFjcml0aWNhbEdyYXZlIjoiYCIsIkRpYWNyaXRpY2FsVGlsZGUiOiLLnCIsImRpYW0iOiLii4QiLCJkaWFtb25kIjoi4ouEIiwiRGlhbW9uZCI6IuKLhCIsImRpYW1vbmRzdWl0Ijoi4pmmIiwiZGlhbXMiOiLimaYiLCJkaWUiOiLCqCIsIkRpZmZlcmVudGlhbEQiOiLihYYiLCJkaWdhbW1hIjoiz50iLCJkaXNpbiI6IuKLsiIsImRpdiI6IsO3IiwiZGl2aWRlIjoiw7ciLCJkaXZpZGVvbnRpbWVzIjoi4ouHIiwiZGl2b254Ijoi4ouHIiwiREpjeSI6ItCCIiwiZGpjeSI6ItGSIiwiZGxjb3JuIjoi4oyeIiwiZGxjcm9wIjoi4oyNIiwiZG9sbGFyIjoiJCIsIkRvcGYiOiLwnZS7IiwiZG9wZiI6IvCdlZUiLCJEb3QiOiLCqCIsImRvdCI6IsuZIiwiRG90RG90Ijoi4oOcIiwiZG90ZXEiOiLiiZAiLCJkb3RlcWRvdCI6IuKJkSIsIkRvdEVxdWFsIjoi4omQIiwiZG90bWludXMiOiLiiLgiLCJkb3RwbHVzIjoi4oiUIiwiZG90c3F1YXJlIjoi4oqhIiwiZG91YmxlYmFyd2VkZ2UiOiLijIYiLCJEb3VibGVDb250b3VySW50ZWdyYWwiOiLiiK8iLCJEb3VibGVEb3QiOiLCqCIsIkRvdWJsZURvd25BcnJvdyI6IuKHkyIsIkRvdWJsZUxlZnRBcnJvdyI6IuKHkCIsIkRvdWJsZUxlZnRSaWdodEFycm93Ijoi4oeUIiwiRG91YmxlTGVmdFRlZSI6IuKrpCIsIkRvdWJsZUxvbmdMZWZ0QXJyb3ciOiLin7giLCJEb3VibGVMb25nTGVmdFJpZ2h0QXJyb3ciOiLin7oiLCJEb3VibGVMb25nUmlnaHRBcnJvdyI6IuKfuSIsIkRvdWJsZVJpZ2h0QXJyb3ciOiLih5IiLCJEb3VibGVSaWdodFRlZSI6IuKKqCIsIkRvdWJsZVVwQXJyb3ciOiLih5EiLCJEb3VibGVVcERvd25BcnJvdyI6IuKHlSIsIkRvdWJsZVZlcnRpY2FsQmFyIjoi4oilIiwiRG93bkFycm93QmFyIjoi4qSTIiwiZG93bmFycm93Ijoi4oaTIiwiRG93bkFycm93Ijoi4oaTIiwiRG93bmFycm93Ijoi4oeTIiwiRG93bkFycm93VXBBcnJvdyI6IuKHtSIsIkRvd25CcmV2ZSI6IsyRIiwiZG93bmRvd25hcnJvd3MiOiLih4oiLCJkb3duaGFycG9vbmxlZnQiOiLih4MiLCJkb3duaGFycG9vbnJpZ2h0Ijoi4oeCIiwiRG93bkxlZnRSaWdodFZlY3RvciI6IuKlkCIsIkRvd25MZWZ0VGVlVmVjdG9yIjoi4qWeIiwiRG93bkxlZnRWZWN0b3JCYXIiOiLipZYiLCJEb3duTGVmdFZlY3RvciI6IuKGvSIsIkRvd25SaWdodFRlZVZlY3RvciI6IuKlnyIsIkRvd25SaWdodFZlY3RvckJhciI6IuKllyIsIkRvd25SaWdodFZlY3RvciI6IuKHgSIsIkRvd25UZWVBcnJvdyI6IuKGpyIsIkRvd25UZWUiOiLiiqQiLCJkcmJrYXJvdyI6IuKkkCIsImRyY29ybiI6IuKMnyIsImRyY3JvcCI6IuKMjCIsIkRzY3IiOiLwnZKfIiwiZHNjciI6IvCdkrkiLCJEU2N5Ijoi0IUiLCJkc2N5Ijoi0ZUiLCJkc29sIjoi4qe2IiwiRHN0cm9rIjoixJAiLCJkc3Ryb2siOiLEkSIsImR0ZG90Ijoi4ouxIiwiZHRyaSI6IuKWvyIsImR0cmlmIjoi4pa+IiwiZHVhcnIiOiLih7UiLCJkdWhhciI6IuKlryIsImR3YW5nbGUiOiLipqYiLCJEWmN5Ijoi0I8iLCJkemN5Ijoi0Z8iLCJkemlncmFyciI6IuKfvyIsIkVhY3V0ZSI6IsOJIiwiZWFjdXRlIjoiw6kiLCJlYXN0ZXIiOiLiqa4iLCJFY2Fyb24iOiLEmiIsImVjYXJvbiI6IsSbIiwiRWNpcmMiOiLDiiIsImVjaXJjIjoiw6oiLCJlY2lyIjoi4omWIiwiZWNvbG9uIjoi4omVIiwiRWN5Ijoi0K0iLCJlY3kiOiLRjSIsImVERG90Ijoi4qm3IiwiRWRvdCI6IsSWIiwiZWRvdCI6IsSXIiwiZURvdCI6IuKJkSIsImVlIjoi4oWHIiwiZWZEb3QiOiLiiZIiLCJFZnIiOiLwnZSIIiwiZWZyIjoi8J2UoiIsImVnIjoi4qqaIiwiRWdyYXZlIjoiw4giLCJlZ3JhdmUiOiLDqCIsImVncyI6IuKqliIsImVnc2RvdCI6IuKqmCIsImVsIjoi4qqZIiwiRWxlbWVudCI6IuKIiCIsImVsaW50ZXJzIjoi4o+nIiwiZWxsIjoi4oSTIiwiZWxzIjoi4qqVIiwiZWxzZG90Ijoi4qqXIiwiRW1hY3IiOiLEkiIsImVtYWNyIjoixJMiLCJlbXB0eSI6IuKIhSIsImVtcHR5c2V0Ijoi4oiFIiwiRW1wdHlTbWFsbFNxdWFyZSI6IuKXuyIsImVtcHR5diI6IuKIhSIsIkVtcHR5VmVyeVNtYWxsU3F1YXJlIjoi4parIiwiZW1zcDEzIjoi4oCEIiwiZW1zcDE0Ijoi4oCFIiwiZW1zcCI6IuKAgyIsIkVORyI6IsWKIiwiZW5nIjoixYsiLCJlbnNwIjoi4oCCIiwiRW9nb24iOiLEmCIsImVvZ29uIjoixJkiLCJFb3BmIjoi8J2UvCIsImVvcGYiOiLwnZWWIiwiZXBhciI6IuKLlSIsImVwYXJzbCI6IuKnoyIsImVwbHVzIjoi4qmxIiwiZXBzaSI6Is61IiwiRXBzaWxvbiI6Is6VIiwiZXBzaWxvbiI6Is61IiwiZXBzaXYiOiLPtSIsImVxY2lyYyI6IuKJliIsImVxY29sb24iOiLiiZUiLCJlcXNpbSI6IuKJgiIsImVxc2xhbnRndHIiOiLiqpYiLCJlcXNsYW50bGVzcyI6IuKqlSIsIkVxdWFsIjoi4qm1IiwiZXF1YWxzIjoiPSIsIkVxdWFsVGlsZGUiOiLiiYIiLCJlcXVlc3QiOiLiiZ8iLCJFcXVpbGlicml1bSI6IuKHjCIsImVxdWl2Ijoi4omhIiwiZXF1aXZERCI6IuKpuCIsImVxdnBhcnNsIjoi4qelIiwiZXJhcnIiOiLipbEiLCJlckRvdCI6IuKJkyIsImVzY3IiOiLihK8iLCJFc2NyIjoi4oSwIiwiZXNkb3QiOiLiiZAiLCJFc2ltIjoi4qmzIiwiZXNpbSI6IuKJgiIsIkV0YSI6Is6XIiwiZXRhIjoizrciLCJFVEgiOiLDkCIsImV0aCI6IsOwIiwiRXVtbCI6IsOLIiwiZXVtbCI6IsOrIiwiZXVybyI6IuKCrCIsImV4Y2wiOiIhIiwiZXhpc3QiOiLiiIMiLCJFeGlzdHMiOiLiiIMiLCJleHBlY3RhdGlvbiI6IuKEsCIsImV4cG9uZW50aWFsZSI6IuKFhyIsIkV4cG9uZW50aWFsRSI6IuKFhyIsImZhbGxpbmdkb3RzZXEiOiLiiZIiLCJGY3kiOiLQpCIsImZjeSI6ItGEIiwiZmVtYWxlIjoi4pmAIiwiZmZpbGlnIjoi76yDIiwiZmZsaWciOiLvrIAiLCJmZmxsaWciOiLvrIQiLCJGZnIiOiLwnZSJIiwiZmZyIjoi8J2UoyIsImZpbGlnIjoi76yBIiwiRmlsbGVkU21hbGxTcXVhcmUiOiLil7wiLCJGaWxsZWRWZXJ5U21hbGxTcXVhcmUiOiLilqoiLCJmamxpZyI6ImZqIiwiZmxhdCI6IuKZrSIsImZsbGlnIjoi76yCIiwiZmx0bnMiOiLilrEiLCJmbm9mIjoixpIiLCJGb3BmIjoi8J2UvSIsImZvcGYiOiLwnZWXIiwiZm9yYWxsIjoi4oiAIiwiRm9yQWxsIjoi4oiAIiwiZm9yayI6IuKLlCIsImZvcmt2Ijoi4quZIiwiRm91cmllcnRyZiI6IuKEsSIsImZwYXJ0aW50Ijoi4qiNIiwiZnJhYzEyIjoiwr0iLCJmcmFjMTMiOiLihZMiLCJmcmFjMTQiOiLCvCIsImZyYWMxNSI6IuKFlSIsImZyYWMxNiI6IuKFmSIsImZyYWMxOCI6IuKFmyIsImZyYWMyMyI6IuKFlCIsImZyYWMyNSI6IuKFliIsImZyYWMzNCI6IsK+IiwiZnJhYzM1Ijoi4oWXIiwiZnJhYzM4Ijoi4oWcIiwiZnJhYzQ1Ijoi4oWYIiwiZnJhYzU2Ijoi4oWaIiwiZnJhYzU4Ijoi4oWdIiwiZnJhYzc4Ijoi4oWeIiwiZnJhc2wiOiLigYQiLCJmcm93biI6IuKMoiIsImZzY3IiOiLwnZK7IiwiRnNjciI6IuKEsSIsImdhY3V0ZSI6Ise1IiwiR2FtbWEiOiLOkyIsImdhbW1hIjoizrMiLCJHYW1tYWQiOiLPnCIsImdhbW1hZCI6Is+dIiwiZ2FwIjoi4qqGIiwiR2JyZXZlIjoixJ4iLCJnYnJldmUiOiLEnyIsIkdjZWRpbCI6IsSiIiwiR2NpcmMiOiLEnCIsImdjaXJjIjoixJ0iLCJHY3kiOiLQkyIsImdjeSI6ItCzIiwiR2RvdCI6IsSgIiwiZ2RvdCI6IsShIiwiZ2UiOiLiiaUiLCJnRSI6IuKJpyIsImdFbCI6IuKqjCIsImdlbCI6IuKLmyIsImdlcSI6IuKJpSIsImdlcXEiOiLiiaciLCJnZXFzbGFudCI6IuKpviIsImdlc2NjIjoi4qqpIiwiZ2VzIjoi4qm+IiwiZ2VzZG90Ijoi4qqAIiwiZ2VzZG90byI6IuKqgiIsImdlc2RvdG9sIjoi4qqEIiwiZ2VzbCI6IuKLm++4gCIsImdlc2xlcyI6IuKqlCIsIkdmciI6IvCdlIoiLCJnZnIiOiLwnZSkIiwiZ2ciOiLiiasiLCJHZyI6IuKLmSIsImdnZyI6IuKLmSIsImdpbWVsIjoi4oS3IiwiR0pjeSI6ItCDIiwiZ2pjeSI6ItGTIiwiZ2xhIjoi4qqlIiwiZ2wiOiLiibciLCJnbEUiOiLiqpIiLCJnbGoiOiLiqqQiLCJnbmFwIjoi4qqKIiwiZ25hcHByb3giOiLiqooiLCJnbmUiOiLiqogiLCJnbkUiOiLiiakiLCJnbmVxIjoi4qqIIiwiZ25lcXEiOiLiiakiLCJnbnNpbSI6IuKLpyIsIkdvcGYiOiLwnZS+IiwiZ29wZiI6IvCdlZgiLCJncmF2ZSI6ImAiLCJHcmVhdGVyRXF1YWwiOiLiiaUiLCJHcmVhdGVyRXF1YWxMZXNzIjoi4oubIiwiR3JlYXRlckZ1bGxFcXVhbCI6IuKJpyIsIkdyZWF0ZXJHcmVhdGVyIjoi4qqiIiwiR3JlYXRlckxlc3MiOiLiibciLCJHcmVhdGVyU2xhbnRFcXVhbCI6IuKpviIsIkdyZWF0ZXJUaWxkZSI6IuKJsyIsIkdzY3IiOiLwnZKiIiwiZ3NjciI6IuKEiiIsImdzaW0iOiLiibMiLCJnc2ltZSI6IuKqjiIsImdzaW1sIjoi4qqQIiwiZ3RjYyI6IuKqpyIsImd0Y2lyIjoi4qm6IiwiZ3QiOiI+IiwiR1QiOiI+IiwiR3QiOiLiiasiLCJndGRvdCI6IuKLlyIsImd0bFBhciI6IuKmlSIsImd0cXVlc3QiOiLiqbwiLCJndHJhcHByb3giOiLiqoYiLCJndHJhcnIiOiLipbgiLCJndHJkb3QiOiLii5ciLCJndHJlcWxlc3MiOiLii5siLCJndHJlcXFsZXNzIjoi4qqMIiwiZ3RybGVzcyI6IuKJtyIsImd0cnNpbSI6IuKJsyIsImd2ZXJ0bmVxcSI6IuKJqe+4gCIsImd2bkUiOiLiianvuIAiLCJIYWNlayI6IsuHIiwiaGFpcnNwIjoi4oCKIiwiaGFsZiI6IsK9IiwiaGFtaWx0Ijoi4oSLIiwiSEFSRGN5Ijoi0KoiLCJoYXJkY3kiOiLRiiIsImhhcnJjaXIiOiLipYgiLCJoYXJyIjoi4oaUIiwiaEFyciI6IuKHlCIsImhhcnJ3Ijoi4oatIiwiSGF0IjoiXiIsImhiYXIiOiLihI8iLCJIY2lyYyI6IsSkIiwiaGNpcmMiOiLEpSIsImhlYXJ0cyI6IuKZpSIsImhlYXJ0c3VpdCI6IuKZpSIsImhlbGxpcCI6IuKApiIsImhlcmNvbiI6IuKKuSIsImhmciI6IvCdlKUiLCJIZnIiOiLihIwiLCJIaWxiZXJ0U3BhY2UiOiLihIsiLCJoa3NlYXJvdyI6IuKkpSIsImhrc3dhcm93Ijoi4qSmIiwiaG9hcnIiOiLih78iLCJob210aHQiOiLiiLsiLCJob29rbGVmdGFycm93Ijoi4oapIiwiaG9va3JpZ2h0YXJyb3ciOiLihqoiLCJob3BmIjoi8J2VmSIsIkhvcGYiOiLihI0iLCJob3JiYXIiOiLigJUiLCJIb3Jpem9udGFsTGluZSI6IuKUgCIsImhzY3IiOiLwnZK9IiwiSHNjciI6IuKEiyIsImhzbGFzaCI6IuKEjyIsIkhzdHJvayI6IsSmIiwiaHN0cm9rIjoixKciLCJIdW1wRG93bkh1bXAiOiLiiY4iLCJIdW1wRXF1YWwiOiLiiY8iLCJoeWJ1bGwiOiLigYMiLCJoeXBoZW4iOiLigJAiLCJJYWN1dGUiOiLDjSIsImlhY3V0ZSI6IsOtIiwiaWMiOiLigaMiLCJJY2lyYyI6IsOOIiwiaWNpcmMiOiLDriIsIkljeSI6ItCYIiwiaWN5Ijoi0LgiLCJJZG90IjoixLAiLCJJRWN5Ijoi0JUiLCJpZWN5Ijoi0LUiLCJpZXhjbCI6IsKhIiwiaWZmIjoi4oeUIiwiaWZyIjoi8J2UpiIsIklmciI6IuKEkSIsIklncmF2ZSI6IsOMIiwiaWdyYXZlIjoiw6wiLCJpaSI6IuKFiCIsImlpaWludCI6IuKojCIsImlpaW50Ijoi4oitIiwiaWluZmluIjoi4qecIiwiaWlvdGEiOiLihKkiLCJJSmxpZyI6IsSyIiwiaWpsaWciOiLEsyIsIkltYWNyIjoixKoiLCJpbWFjciI6IsSrIiwiaW1hZ2UiOiLihJEiLCJJbWFnaW5hcnlJIjoi4oWIIiwiaW1hZ2xpbmUiOiLihJAiLCJpbWFncGFydCI6IuKEkSIsImltYXRoIjoixLEiLCJJbSI6IuKEkSIsImltb2YiOiLiirciLCJpbXBlZCI6Isa1IiwiSW1wbGllcyI6IuKHkiIsImluY2FyZSI6IuKEhSIsImluIjoi4oiIIiwiaW5maW4iOiLiiJ4iLCJpbmZpbnRpZSI6IuKnnSIsImlub2RvdCI6IsSxIiwiaW50Y2FsIjoi4oq6IiwiaW50Ijoi4oirIiwiSW50Ijoi4oisIiwiaW50ZWdlcnMiOiLihKQiLCJJbnRlZ3JhbCI6IuKIqyIsImludGVyY2FsIjoi4oq6IiwiSW50ZXJzZWN0aW9uIjoi4ouCIiwiaW50bGFyaGsiOiLiqJciLCJpbnRwcm9kIjoi4qi8IiwiSW52aXNpYmxlQ29tbWEiOiLigaMiLCJJbnZpc2libGVUaW1lcyI6IuKBoiIsIklPY3kiOiLQgSIsImlvY3kiOiLRkSIsIklvZ29uIjoixK4iLCJpb2dvbiI6IsSvIiwiSW9wZiI6IvCdlYAiLCJpb3BmIjoi8J2VmiIsIklvdGEiOiLOmSIsImlvdGEiOiLOuSIsImlwcm9kIjoi4qi8IiwiaXF1ZXN0Ijoiwr8iLCJpc2NyIjoi8J2SviIsIklzY3IiOiLihJAiLCJpc2luIjoi4oiIIiwiaXNpbmRvdCI6IuKLtSIsImlzaW5FIjoi4ou5IiwiaXNpbnMiOiLii7QiLCJpc2luc3YiOiLii7MiLCJpc2ludiI6IuKIiCIsIml0Ijoi4oGiIiwiSXRpbGRlIjoixKgiLCJpdGlsZGUiOiLEqSIsIkl1a2N5Ijoi0IYiLCJpdWtjeSI6ItGWIiwiSXVtbCI6IsOPIiwiaXVtbCI6IsOvIiwiSmNpcmMiOiLEtCIsImpjaXJjIjoixLUiLCJKY3kiOiLQmSIsImpjeSI6ItC5IiwiSmZyIjoi8J2UjSIsImpmciI6IvCdlKciLCJqbWF0aCI6Isi3IiwiSm9wZiI6IvCdlYEiLCJqb3BmIjoi8J2VmyIsIkpzY3IiOiLwnZKlIiwianNjciI6IvCdkr8iLCJKc2VyY3kiOiLQiCIsImpzZXJjeSI6ItGYIiwiSnVrY3kiOiLQhCIsImp1a2N5Ijoi0ZQiLCJLYXBwYSI6Is6aIiwia2FwcGEiOiLOuiIsImthcHBhdiI6Is+wIiwiS2NlZGlsIjoixLYiLCJrY2VkaWwiOiLEtyIsIktjeSI6ItCaIiwia2N5Ijoi0LoiLCJLZnIiOiLwnZSOIiwia2ZyIjoi8J2UqCIsImtncmVlbiI6IsS4IiwiS0hjeSI6ItClIiwia2hjeSI6ItGFIiwiS0pjeSI6ItCMIiwia2pjeSI6ItGcIiwiS29wZiI6IvCdlYIiLCJrb3BmIjoi8J2VnCIsIktzY3IiOiLwnZKmIiwia3NjciI6IvCdk4AiLCJsQWFyciI6IuKHmiIsIkxhY3V0ZSI6IsS5IiwibGFjdXRlIjoixLoiLCJsYWVtcHR5diI6IuKmtCIsImxhZ3JhbiI6IuKEkiIsIkxhbWJkYSI6Is6bIiwibGFtYmRhIjoizrsiLCJsYW5nIjoi4p+oIiwiTGFuZyI6IuKfqiIsImxhbmdkIjoi4qaRIiwibGFuZ2xlIjoi4p+oIiwibGFwIjoi4qqFIiwiTGFwbGFjZXRyZiI6IuKEkiIsImxhcXVvIjoiwqsiLCJsYXJyYiI6IuKHpCIsImxhcnJiZnMiOiLipJ8iLCJsYXJyIjoi4oaQIiwiTGFyciI6IuKGniIsImxBcnIiOiLih5AiLCJsYXJyZnMiOiLipJ0iLCJsYXJyaGsiOiLihqkiLCJsYXJybHAiOiLihqsiLCJsYXJycGwiOiLipLkiLCJsYXJyc2ltIjoi4qWzIiwibGFycnRsIjoi4oaiIiwibGF0YWlsIjoi4qSZIiwibEF0YWlsIjoi4qSbIiwibGF0Ijoi4qqrIiwibGF0ZSI6IuKqrSIsImxhdGVzIjoi4qqt77iAIiwibGJhcnIiOiLipIwiLCJsQmFyciI6IuKkjiIsImxiYnJrIjoi4p2yIiwibGJyYWNlIjoieyIsImxicmFjayI6IlsiLCJsYnJrZSI6IuKmiyIsImxicmtzbGQiOiLipo8iLCJsYnJrc2x1Ijoi4qaNIiwiTGNhcm9uIjoixL0iLCJsY2Fyb24iOiLEviIsIkxjZWRpbCI6IsS7IiwibGNlZGlsIjoixLwiLCJsY2VpbCI6IuKMiCIsImxjdWIiOiJ7IiwiTGN5Ijoi0JsiLCJsY3kiOiLQuyIsImxkY2EiOiLipLYiLCJsZHF1byI6IuKAnCIsImxkcXVvciI6IuKAniIsImxkcmRoYXIiOiLipaciLCJsZHJ1c2hhciI6IuKliyIsImxkc2giOiLihrIiLCJsZSI6IuKJpCIsImxFIjoi4ommIiwiTGVmdEFuZ2xlQnJhY2tldCI6IuKfqCIsIkxlZnRBcnJvd0JhciI6IuKHpCIsImxlZnRhcnJvdyI6IuKGkCIsIkxlZnRBcnJvdyI6IuKGkCIsIkxlZnRhcnJvdyI6IuKHkCIsIkxlZnRBcnJvd1JpZ2h0QXJyb3ciOiLih4YiLCJsZWZ0YXJyb3d0YWlsIjoi4oaiIiwiTGVmdENlaWxpbmciOiLijIgiLCJMZWZ0RG91YmxlQnJhY2tldCI6IuKfpiIsIkxlZnREb3duVGVlVmVjdG9yIjoi4qWhIiwiTGVmdERvd25WZWN0b3JCYXIiOiLipZkiLCJMZWZ0RG93blZlY3RvciI6IuKHgyIsIkxlZnRGbG9vciI6IuKMiiIsImxlZnRoYXJwb29uZG93biI6IuKGvSIsImxlZnRoYXJwb29udXAiOiLihrwiLCJsZWZ0bGVmdGFycm93cyI6IuKHhyIsImxlZnRyaWdodGFycm93Ijoi4oaUIiwiTGVmdFJpZ2h0QXJyb3ciOiLihpQiLCJMZWZ0cmlnaHRhcnJvdyI6IuKHlCIsImxlZnRyaWdodGFycm93cyI6IuKHhiIsImxlZnRyaWdodGhhcnBvb25zIjoi4oeLIiwibGVmdHJpZ2h0c3F1aWdhcnJvdyI6IuKGrSIsIkxlZnRSaWdodFZlY3RvciI6IuKljiIsIkxlZnRUZWVBcnJvdyI6IuKGpCIsIkxlZnRUZWUiOiLiiqMiLCJMZWZ0VGVlVmVjdG9yIjoi4qWaIiwibGVmdHRocmVldGltZXMiOiLii4siLCJMZWZ0VHJpYW5nbGVCYXIiOiLip48iLCJMZWZ0VHJpYW5nbGUiOiLiirIiLCJMZWZ0VHJpYW5nbGVFcXVhbCI6IuKKtCIsIkxlZnRVcERvd25WZWN0b3IiOiLipZEiLCJMZWZ0VXBUZWVWZWN0b3IiOiLipaAiLCJMZWZ0VXBWZWN0b3JCYXIiOiLipZgiLCJMZWZ0VXBWZWN0b3IiOiLihr8iLCJMZWZ0VmVjdG9yQmFyIjoi4qWSIiwiTGVmdFZlY3RvciI6IuKGvCIsImxFZyI6IuKqiyIsImxlZyI6IuKLmiIsImxlcSI6IuKJpCIsImxlcXEiOiLiiaYiLCJsZXFzbGFudCI6IuKpvSIsImxlc2NjIjoi4qqoIiwibGVzIjoi4qm9IiwibGVzZG90Ijoi4qm/IiwibGVzZG90byI6IuKqgSIsImxlc2RvdG9yIjoi4qqDIiwibGVzZyI6IuKLmu+4gCIsImxlc2dlcyI6IuKqkyIsImxlc3NhcHByb3giOiLiqoUiLCJsZXNzZG90Ijoi4ouWIiwibGVzc2VxZ3RyIjoi4ouaIiwibGVzc2VxcWd0ciI6IuKqiyIsIkxlc3NFcXVhbEdyZWF0ZXIiOiLii5oiLCJMZXNzRnVsbEVxdWFsIjoi4ommIiwiTGVzc0dyZWF0ZXIiOiLiibYiLCJsZXNzZ3RyIjoi4om2IiwiTGVzc0xlc3MiOiLiqqEiLCJsZXNzc2ltIjoi4omyIiwiTGVzc1NsYW50RXF1YWwiOiLiqb0iLCJMZXNzVGlsZGUiOiLiibIiLCJsZmlzaHQiOiLipbwiLCJsZmxvb3IiOiLijIoiLCJMZnIiOiLwnZSPIiwibGZyIjoi8J2UqSIsImxnIjoi4om2IiwibGdFIjoi4qqRIiwibEhhciI6IuKloiIsImxoYXJkIjoi4oa9IiwibGhhcnUiOiLihrwiLCJsaGFydWwiOiLipaoiLCJsaGJsayI6IuKWhCIsIkxKY3kiOiLQiSIsImxqY3kiOiLRmSIsImxsYXJyIjoi4oeHIiwibGwiOiLiiaoiLCJMbCI6IuKLmCIsImxsY29ybmVyIjoi4oyeIiwiTGxlZnRhcnJvdyI6IuKHmiIsImxsaGFyZCI6IuKlqyIsImxsdHJpIjoi4pe6IiwiTG1pZG90IjoixL8iLCJsbWlkb3QiOiLFgCIsImxtb3VzdGFjaGUiOiLijrAiLCJsbW91c3QiOiLijrAiLCJsbmFwIjoi4qqJIiwibG5hcHByb3giOiLiqokiLCJsbmUiOiLiqociLCJsbkUiOiLiiagiLCJsbmVxIjoi4qqHIiwibG5lcXEiOiLiiagiLCJsbnNpbSI6IuKLpiIsImxvYW5nIjoi4p+sIiwibG9hcnIiOiLih70iLCJsb2JyayI6IuKfpiIsImxvbmdsZWZ0YXJyb3ciOiLin7UiLCJMb25nTGVmdEFycm93Ijoi4p+1IiwiTG9uZ2xlZnRhcnJvdyI6IuKfuCIsImxvbmdsZWZ0cmlnaHRhcnJvdyI6IuKftyIsIkxvbmdMZWZ0UmlnaHRBcnJvdyI6IuKftyIsIkxvbmdsZWZ0cmlnaHRhcnJvdyI6IuKfuiIsImxvbmdtYXBzdG8iOiLin7wiLCJsb25ncmlnaHRhcnJvdyI6IuKftiIsIkxvbmdSaWdodEFycm93Ijoi4p+2IiwiTG9uZ3JpZ2h0YXJyb3ciOiLin7kiLCJsb29wYXJyb3dsZWZ0Ijoi4oarIiwibG9vcGFycm93cmlnaHQiOiLihqwiLCJsb3BhciI6IuKmhSIsIkxvcGYiOiLwnZWDIiwibG9wZiI6IvCdlZ0iLCJsb3BsdXMiOiLiqK0iLCJsb3RpbWVzIjoi4qi0IiwibG93YXN0Ijoi4oiXIiwibG93YmFyIjoiXyIsIkxvd2VyTGVmdEFycm93Ijoi4oaZIiwiTG93ZXJSaWdodEFycm93Ijoi4oaYIiwibG96Ijoi4peKIiwibG96ZW5nZSI6IuKXiiIsImxvemYiOiLip6siLCJscGFyIjoiKCIsImxwYXJsdCI6IuKmkyIsImxyYXJyIjoi4oeGIiwibHJjb3JuZXIiOiLijJ8iLCJscmhhciI6IuKHiyIsImxyaGFyZCI6IuKlrSIsImxybSI6IuKAjiIsImxydHJpIjoi4oq/IiwibHNhcXVvIjoi4oC5IiwibHNjciI6IvCdk4EiLCJMc2NyIjoi4oSSIiwibHNoIjoi4oawIiwiTHNoIjoi4oawIiwibHNpbSI6IuKJsiIsImxzaW1lIjoi4qqNIiwibHNpbWciOiLiqo8iLCJsc3FiIjoiWyIsImxzcXVvIjoi4oCYIiwibHNxdW9yIjoi4oCaIiwiTHN0cm9rIjoixYEiLCJsc3Ryb2siOiLFgiIsImx0Y2MiOiLiqqYiLCJsdGNpciI6IuKpuSIsImx0IjoiPCIsIkxUIjoiPCIsIkx0Ijoi4omqIiwibHRkb3QiOiLii5YiLCJsdGhyZWUiOiLii4siLCJsdGltZXMiOiLii4kiLCJsdGxhcnIiOiLipbYiLCJsdHF1ZXN0Ijoi4qm7IiwibHRyaSI6IuKXgyIsImx0cmllIjoi4oq0IiwibHRyaWYiOiLil4IiLCJsdHJQYXIiOiLippYiLCJsdXJkc2hhciI6IuKliiIsImx1cnVoYXIiOiLipaYiLCJsdmVydG5lcXEiOiLiiajvuIAiLCJsdm5FIjoi4omo77iAIiwibWFjciI6IsKvIiwibWFsZSI6IuKZgiIsIm1hbHQiOiLinKAiLCJtYWx0ZXNlIjoi4pygIiwiTWFwIjoi4qSFIiwibWFwIjoi4oamIiwibWFwc3RvIjoi4oamIiwibWFwc3RvZG93biI6IuKGpyIsIm1hcHN0b2xlZnQiOiLihqQiLCJtYXBzdG91cCI6IuKGpSIsIm1hcmtlciI6IuKWriIsIm1jb21tYSI6IuKoqSIsIk1jeSI6ItCcIiwibWN5Ijoi0LwiLCJtZGFzaCI6IuKAlCIsIm1ERG90Ijoi4oi6IiwibWVhc3VyZWRhbmdsZSI6IuKIoSIsIk1lZGl1bVNwYWNlIjoi4oGfIiwiTWVsbGludHJmIjoi4oSzIiwiTWZyIjoi8J2UkCIsIm1mciI6IvCdlKoiLCJtaG8iOiLihKciLCJtaWNybyI6IsK1IiwibWlkYXN0IjoiKiIsIm1pZGNpciI6IuKrsCIsIm1pZCI6IuKIoyIsIm1pZGRvdCI6IsK3IiwibWludXNiIjoi4oqfIiwibWludXMiOiLiiJIiLCJtaW51c2QiOiLiiLgiLCJtaW51c2R1Ijoi4qiqIiwiTWludXNQbHVzIjoi4oiTIiwibWxjcCI6IuKrmyIsIm1sZHIiOiLigKYiLCJtbnBsdXMiOiLiiJMiLCJtb2RlbHMiOiLiiqciLCJNb3BmIjoi8J2VhCIsIm1vcGYiOiLwnZWeIiwibXAiOiLiiJMiLCJtc2NyIjoi8J2TgiIsIk1zY3IiOiLihLMiLCJtc3Rwb3MiOiLiiL4iLCJNdSI6Is6cIiwibXUiOiLOvCIsIm11bHRpbWFwIjoi4oq4IiwibXVtYXAiOiLiirgiLCJuYWJsYSI6IuKIhyIsIk5hY3V0ZSI6IsWDIiwibmFjdXRlIjoixYQiLCJuYW5nIjoi4oig4oOSIiwibmFwIjoi4omJIiwibmFwRSI6IuKpsMy4IiwibmFwaWQiOiLiiYvMuCIsIm5hcG9zIjoixYkiLCJuYXBwcm94Ijoi4omJIiwibmF0dXJhbCI6IuKZriIsIm5hdHVyYWxzIjoi4oSVIiwibmF0dXIiOiLima4iLCJuYnNwIjoiwqAiLCJuYnVtcCI6IuKJjsy4IiwibmJ1bXBlIjoi4omPzLgiLCJuY2FwIjoi4qmDIiwiTmNhcm9uIjoixYciLCJuY2Fyb24iOiLFiCIsIk5jZWRpbCI6IsWFIiwibmNlZGlsIjoixYYiLCJuY29uZyI6IuKJhyIsIm5jb25nZG90Ijoi4qmtzLgiLCJuY3VwIjoi4qmCIiwiTmN5Ijoi0J0iLCJuY3kiOiLQvSIsIm5kYXNoIjoi4oCTIiwibmVhcmhrIjoi4qSkIiwibmVhcnIiOiLihpciLCJuZUFyciI6IuKHlyIsIm5lYXJyb3ciOiLihpciLCJuZSI6IuKJoCIsIm5lZG90Ijoi4omQzLgiLCJOZWdhdGl2ZU1lZGl1bVNwYWNlIjoi4oCLIiwiTmVnYXRpdmVUaGlja1NwYWNlIjoi4oCLIiwiTmVnYXRpdmVUaGluU3BhY2UiOiLigIsiLCJOZWdhdGl2ZVZlcnlUaGluU3BhY2UiOiLigIsiLCJuZXF1aXYiOiLiiaIiLCJuZXNlYXIiOiLipKgiLCJuZXNpbSI6IuKJgsy4IiwiTmVzdGVkR3JlYXRlckdyZWF0ZXIiOiLiiasiLCJOZXN0ZWRMZXNzTGVzcyI6IuKJqiIsIk5ld0xpbmUiOiJcXG4iLCJuZXhpc3QiOiLiiIQiLCJuZXhpc3RzIjoi4oiEIiwiTmZyIjoi8J2UkSIsIm5mciI6IvCdlKsiLCJuZ0UiOiLiiafMuCIsIm5nZSI6IuKJsSIsIm5nZXEiOiLiibEiLCJuZ2VxcSI6IuKJp8y4IiwibmdlcXNsYW50Ijoi4qm+zLgiLCJuZ2VzIjoi4qm+zLgiLCJuR2ciOiLii5nMuCIsIm5nc2ltIjoi4om1Iiwibkd0Ijoi4omr4oOSIiwibmd0Ijoi4omvIiwibmd0ciI6IuKJryIsIm5HdHYiOiLiiavMuCIsIm5oYXJyIjoi4oauIiwibmhBcnIiOiLih44iLCJuaHBhciI6IuKrsiIsIm5pIjoi4oiLIiwibmlzIjoi4ou8IiwibmlzZCI6IuKLuiIsIm5pdiI6IuKIiyIsIk5KY3kiOiLQiiIsIm5qY3kiOiLRmiIsIm5sYXJyIjoi4oaaIiwibmxBcnIiOiLih40iLCJubGRyIjoi4oClIiwibmxFIjoi4ommzLgiLCJubGUiOiLiibAiLCJubGVmdGFycm93Ijoi4oaaIiwibkxlZnRhcnJvdyI6IuKHjSIsIm5sZWZ0cmlnaHRhcnJvdyI6IuKGriIsIm5MZWZ0cmlnaHRhcnJvdyI6IuKHjiIsIm5sZXEiOiLiibAiLCJubGVxcSI6IuKJpsy4IiwibmxlcXNsYW50Ijoi4qm9zLgiLCJubGVzIjoi4qm9zLgiLCJubGVzcyI6IuKJriIsIm5MbCI6IuKLmMy4IiwibmxzaW0iOiLiibQiLCJuTHQiOiLiiarig5IiLCJubHQiOiLiia4iLCJubHRyaSI6IuKLqiIsIm5sdHJpZSI6IuKLrCIsIm5MdHYiOiLiiarMuCIsIm5taWQiOiLiiKQiLCJOb0JyZWFrIjoi4oGgIiwiTm9uQnJlYWtpbmdTcGFjZSI6IsKgIiwibm9wZiI6IvCdlZ8iLCJOb3BmIjoi4oSVIiwiTm90Ijoi4qusIiwibm90IjoiwqwiLCJOb3RDb25ncnVlbnQiOiLiiaIiLCJOb3RDdXBDYXAiOiLiia0iLCJOb3REb3VibGVWZXJ0aWNhbEJhciI6IuKIpiIsIk5vdEVsZW1lbnQiOiLiiIkiLCJOb3RFcXVhbCI6IuKJoCIsIk5vdEVxdWFsVGlsZGUiOiLiiYLMuCIsIk5vdEV4aXN0cyI6IuKIhCIsIk5vdEdyZWF0ZXIiOiLiia8iLCJOb3RHcmVhdGVyRXF1YWwiOiLiibEiLCJOb3RHcmVhdGVyRnVsbEVxdWFsIjoi4omnzLgiLCJOb3RHcmVhdGVyR3JlYXRlciI6IuKJq8y4IiwiTm90R3JlYXRlckxlc3MiOiLiibkiLCJOb3RHcmVhdGVyU2xhbnRFcXVhbCI6IuKpvsy4IiwiTm90R3JlYXRlclRpbGRlIjoi4om1IiwiTm90SHVtcERvd25IdW1wIjoi4omOzLgiLCJOb3RIdW1wRXF1YWwiOiLiiY/MuCIsIm5vdGluIjoi4oiJIiwibm90aW5kb3QiOiLii7XMuCIsIm5vdGluRSI6IuKLucy4Iiwibm90aW52YSI6IuKIiSIsIm5vdGludmIiOiLii7ciLCJub3RpbnZjIjoi4ou2IiwiTm90TGVmdFRyaWFuZ2xlQmFyIjoi4qePzLgiLCJOb3RMZWZ0VHJpYW5nbGUiOiLii6oiLCJOb3RMZWZ0VHJpYW5nbGVFcXVhbCI6IuKLrCIsIk5vdExlc3MiOiLiia4iLCJOb3RMZXNzRXF1YWwiOiLiibAiLCJOb3RMZXNzR3JlYXRlciI6IuKJuCIsIk5vdExlc3NMZXNzIjoi4omqzLgiLCJOb3RMZXNzU2xhbnRFcXVhbCI6IuKpvcy4IiwiTm90TGVzc1RpbGRlIjoi4om0IiwiTm90TmVzdGVkR3JlYXRlckdyZWF0ZXIiOiLiqqLMuCIsIk5vdE5lc3RlZExlc3NMZXNzIjoi4qqhzLgiLCJub3RuaSI6IuKIjCIsIm5vdG5pdmEiOiLiiIwiLCJub3RuaXZiIjoi4ou+Iiwibm90bml2YyI6IuKLvSIsIk5vdFByZWNlZGVzIjoi4oqAIiwiTm90UHJlY2VkZXNFcXVhbCI6IuKqr8y4IiwiTm90UHJlY2VkZXNTbGFudEVxdWFsIjoi4ougIiwiTm90UmV2ZXJzZUVsZW1lbnQiOiLiiIwiLCJOb3RSaWdodFRyaWFuZ2xlQmFyIjoi4qeQzLgiLCJOb3RSaWdodFRyaWFuZ2xlIjoi4ourIiwiTm90UmlnaHRUcmlhbmdsZUVxdWFsIjoi4outIiwiTm90U3F1YXJlU3Vic2V0Ijoi4oqPzLgiLCJOb3RTcXVhcmVTdWJzZXRFcXVhbCI6IuKLoiIsIk5vdFNxdWFyZVN1cGVyc2V0Ijoi4oqQzLgiLCJOb3RTcXVhcmVTdXBlcnNldEVxdWFsIjoi4oujIiwiTm90U3Vic2V0Ijoi4oqC4oOSIiwiTm90U3Vic2V0RXF1YWwiOiLiiogiLCJOb3RTdWNjZWVkcyI6IuKKgSIsIk5vdFN1Y2NlZWRzRXF1YWwiOiLiqrDMuCIsIk5vdFN1Y2NlZWRzU2xhbnRFcXVhbCI6IuKLoSIsIk5vdFN1Y2NlZWRzVGlsZGUiOiLiib/MuCIsIk5vdFN1cGVyc2V0Ijoi4oqD4oOSIiwiTm90U3VwZXJzZXRFcXVhbCI6IuKKiSIsIk5vdFRpbGRlIjoi4omBIiwiTm90VGlsZGVFcXVhbCI6IuKJhCIsIk5vdFRpbGRlRnVsbEVxdWFsIjoi4omHIiwiTm90VGlsZGVUaWxkZSI6IuKJiSIsIk5vdFZlcnRpY2FsQmFyIjoi4oikIiwibnBhcmFsbGVsIjoi4oimIiwibnBhciI6IuKIpiIsIm5wYXJzbCI6IuKrveKDpSIsIm5wYXJ0Ijoi4oiCzLgiLCJucG9saW50Ijoi4qiUIiwibnByIjoi4oqAIiwibnByY3VlIjoi4ougIiwibnByZWMiOiLiioAiLCJucHJlY2VxIjoi4qqvzLgiLCJucHJlIjoi4qqvzLgiLCJucmFycmMiOiLipLPMuCIsIm5yYXJyIjoi4oabIiwibnJBcnIiOiLih48iLCJucmFycnciOiLihp3MuCIsIm5yaWdodGFycm93Ijoi4oabIiwiblJpZ2h0YXJyb3ciOiLih48iLCJucnRyaSI6IuKLqyIsIm5ydHJpZSI6IuKLrSIsIm5zYyI6IuKKgSIsIm5zY2N1ZSI6IuKLoSIsIm5zY2UiOiLiqrDMuCIsIk5zY3IiOiLwnZKpIiwibnNjciI6IvCdk4MiLCJuc2hvcnRtaWQiOiLiiKQiLCJuc2hvcnRwYXJhbGxlbCI6IuKIpiIsIm5zaW0iOiLiiYEiLCJuc2ltZSI6IuKJhCIsIm5zaW1lcSI6IuKJhCIsIm5zbWlkIjoi4oikIiwibnNwYXIiOiLiiKYiLCJuc3FzdWJlIjoi4ouiIiwibnNxc3VwZSI6IuKLoyIsIm5zdWIiOiLiioQiLCJuc3ViRSI6IuKrhcy4IiwibnN1YmUiOiLiiogiLCJuc3Vic2V0Ijoi4oqC4oOSIiwibnN1YnNldGVxIjoi4oqIIiwibnN1YnNldGVxcSI6IuKrhcy4IiwibnN1Y2MiOiLiioEiLCJuc3VjY2VxIjoi4qqwzLgiLCJuc3VwIjoi4oqFIiwibnN1cEUiOiLiq4bMuCIsIm5zdXBlIjoi4oqJIiwibnN1cHNldCI6IuKKg+KDkiIsIm5zdXBzZXRlcSI6IuKKiSIsIm5zdXBzZXRlcXEiOiLiq4bMuCIsIm50Z2wiOiLiibkiLCJOdGlsZGUiOiLDkSIsIm50aWxkZSI6IsOxIiwibnRsZyI6IuKJuCIsIm50cmlhbmdsZWxlZnQiOiLii6oiLCJudHJpYW5nbGVsZWZ0ZXEiOiLii6wiLCJudHJpYW5nbGVyaWdodCI6IuKLqyIsIm50cmlhbmdsZXJpZ2h0ZXEiOiLii60iLCJOdSI6Is6dIiwibnUiOiLOvSIsIm51bSI6IiMiLCJudW1lcm8iOiLihJYiLCJudW1zcCI6IuKAhyIsIm52YXAiOiLiiY3ig5IiLCJudmRhc2giOiLiiqwiLCJudkRhc2giOiLiiq0iLCJuVmRhc2giOiLiiq4iLCJuVkRhc2giOiLiiq8iLCJudmdlIjoi4oml4oOSIiwibnZndCI6Ij7ig5IiLCJudkhhcnIiOiLipIQiLCJudmluZmluIjoi4qeeIiwibnZsQXJyIjoi4qSCIiwibnZsZSI6IuKJpOKDkiIsIm52bHQiOiI84oOSIiwibnZsdHJpZSI6IuKKtOKDkiIsIm52ckFyciI6IuKkgyIsIm52cnRyaWUiOiLiirXig5IiLCJudnNpbSI6IuKIvOKDkiIsIm53YXJoayI6IuKkoyIsIm53YXJyIjoi4oaWIiwibndBcnIiOiLih5YiLCJud2Fycm93Ijoi4oaWIiwibnduZWFyIjoi4qSnIiwiT2FjdXRlIjoiw5MiLCJvYWN1dGUiOiLDsyIsIm9hc3QiOiLiipsiLCJPY2lyYyI6IsOUIiwib2NpcmMiOiLDtCIsIm9jaXIiOiLiipoiLCJPY3kiOiLQniIsIm9jeSI6ItC+Iiwib2Rhc2giOiLiip0iLCJPZGJsYWMiOiLFkCIsIm9kYmxhYyI6IsWRIiwib2RpdiI6IuKouCIsIm9kb3QiOiLiipkiLCJvZHNvbGQiOiLiprwiLCJPRWxpZyI6IsWSIiwib2VsaWciOiLFkyIsIm9mY2lyIjoi4qa/IiwiT2ZyIjoi8J2UkiIsIm9mciI6IvCdlKwiLCJvZ29uIjoiy5siLCJPZ3JhdmUiOiLDkiIsIm9ncmF2ZSI6IsOyIiwib2d0Ijoi4qeBIiwib2hiYXIiOiLiprUiLCJvaG0iOiLOqSIsIm9pbnQiOiLiiK4iLCJvbGFyciI6IuKGuiIsIm9sY2lyIjoi4qa+Iiwib2xjcm9zcyI6IuKmuyIsIm9saW5lIjoi4oC+Iiwib2x0Ijoi4qeAIiwiT21hY3IiOiLFjCIsIm9tYWNyIjoixY0iLCJPbWVnYSI6Is6pIiwib21lZ2EiOiLPiSIsIk9taWNyb24iOiLOnyIsIm9taWNyb24iOiLOvyIsIm9taWQiOiLiprYiLCJvbWludXMiOiLiipYiLCJPb3BmIjoi8J2VhiIsIm9vcGYiOiLwnZWgIiwib3BhciI6IuKmtyIsIk9wZW5DdXJseURvdWJsZVF1b3RlIjoi4oCcIiwiT3BlbkN1cmx5UXVvdGUiOiLigJgiLCJvcGVycCI6IuKmuSIsIm9wbHVzIjoi4oqVIiwib3JhcnIiOiLihrsiLCJPciI6IuKplCIsIm9yIjoi4oioIiwib3JkIjoi4qmdIiwib3JkZXIiOiLihLQiLCJvcmRlcm9mIjoi4oS0Iiwib3JkZiI6IsKqIiwib3JkbSI6IsK6Iiwib3JpZ29mIjoi4oq2Iiwib3JvciI6IuKpliIsIm9yc2xvcGUiOiLiqZciLCJvcnYiOiLiqZsiLCJvUyI6IuKTiCIsIk9zY3IiOiLwnZKqIiwib3NjciI6IuKEtCIsIk9zbGFzaCI6IsOYIiwib3NsYXNoIjoiw7giLCJvc29sIjoi4oqYIiwiT3RpbGRlIjoiw5UiLCJvdGlsZGUiOiLDtSIsIm90aW1lc2FzIjoi4qi2IiwiT3RpbWVzIjoi4qi3Iiwib3RpbWVzIjoi4oqXIiwiT3VtbCI6IsOWIiwib3VtbCI6IsO2Iiwib3ZiYXIiOiLijL0iLCJPdmVyQmFyIjoi4oC+IiwiT3ZlckJyYWNlIjoi4o+eIiwiT3ZlckJyYWNrZXQiOiLijrQiLCJPdmVyUGFyZW50aGVzaXMiOiLij5wiLCJwYXJhIjoiwrYiLCJwYXJhbGxlbCI6IuKIpSIsInBhciI6IuKIpSIsInBhcnNpbSI6IuKrsyIsInBhcnNsIjoi4qu9IiwicGFydCI6IuKIgiIsIlBhcnRpYWxEIjoi4oiCIiwiUGN5Ijoi0J8iLCJwY3kiOiLQvyIsInBlcmNudCI6IiUiLCJwZXJpb2QiOiIuIiwicGVybWlsIjoi4oCwIiwicGVycCI6IuKKpSIsInBlcnRlbmsiOiLigLEiLCJQZnIiOiLwnZSTIiwicGZyIjoi8J2UrSIsIlBoaSI6Is6mIiwicGhpIjoiz4YiLCJwaGl2Ijoiz5UiLCJwaG1tYXQiOiLihLMiLCJwaG9uZSI6IuKYjiIsIlBpIjoizqAiLCJwaSI6Is+AIiwicGl0Y2hmb3JrIjoi4ouUIiwicGl2Ijoiz5YiLCJwbGFuY2siOiLihI8iLCJwbGFuY2toIjoi4oSOIiwicGxhbmt2Ijoi4oSPIiwicGx1c2FjaXIiOiLiqKMiLCJwbHVzYiI6IuKKniIsInBsdXNjaXIiOiLiqKIiLCJwbHVzIjoiKyIsInBsdXNkbyI6IuKIlCIsInBsdXNkdSI6IuKopSIsInBsdXNlIjoi4qmyIiwiUGx1c01pbnVzIjoiwrEiLCJwbHVzbW4iOiLCsSIsInBsdXNzaW0iOiLiqKYiLCJwbHVzdHdvIjoi4qinIiwicG0iOiLCsSIsIlBvaW5jYXJlcGxhbmUiOiLihIwiLCJwb2ludGludCI6IuKolSIsInBvcGYiOiLwnZWhIiwiUG9wZiI6IuKEmSIsInBvdW5kIjoiwqMiLCJwcmFwIjoi4qq3IiwiUHIiOiLiqrsiLCJwciI6IuKJuiIsInByY3VlIjoi4om8IiwicHJlY2FwcHJveCI6IuKqtyIsInByZWMiOiLiiboiLCJwcmVjY3VybHllcSI6IuKJvCIsIlByZWNlZGVzIjoi4om6IiwiUHJlY2VkZXNFcXVhbCI6IuKqryIsIlByZWNlZGVzU2xhbnRFcXVhbCI6IuKJvCIsIlByZWNlZGVzVGlsZGUiOiLiib4iLCJwcmVjZXEiOiLiqq8iLCJwcmVjbmFwcHJveCI6IuKquSIsInByZWNuZXFxIjoi4qq1IiwicHJlY25zaW0iOiLii6giLCJwcmUiOiLiqq8iLCJwckUiOiLiqrMiLCJwcmVjc2ltIjoi4om+IiwicHJpbWUiOiLigLIiLCJQcmltZSI6IuKAsyIsInByaW1lcyI6IuKEmSIsInBybmFwIjoi4qq5IiwicHJuRSI6IuKqtSIsInBybnNpbSI6IuKLqCIsInByb2QiOiLiiI8iLCJQcm9kdWN0Ijoi4oiPIiwicHJvZmFsYXIiOiLijK4iLCJwcm9mbGluZSI6IuKMkiIsInByb2ZzdXJmIjoi4oyTIiwicHJvcCI6IuKInSIsIlByb3BvcnRpb25hbCI6IuKInSIsIlByb3BvcnRpb24iOiLiiLciLCJwcm9wdG8iOiLiiJ0iLCJwcnNpbSI6IuKJviIsInBydXJlbCI6IuKKsCIsIlBzY3IiOiLwnZKrIiwicHNjciI6IvCdk4UiLCJQc2kiOiLOqCIsInBzaSI6Is+IIiwicHVuY3NwIjoi4oCIIiwiUWZyIjoi8J2UlCIsInFmciI6IvCdlK4iLCJxaW50Ijoi4qiMIiwicW9wZiI6IvCdlaIiLCJRb3BmIjoi4oSaIiwicXByaW1lIjoi4oGXIiwiUXNjciI6IvCdkqwiLCJxc2NyIjoi8J2ThiIsInF1YXRlcm5pb25zIjoi4oSNIiwicXVhdGludCI6IuKoliIsInF1ZXN0IjoiPyIsInF1ZXN0ZXEiOiLiiZ8iLCJxdW90IjoiXFwiIiwiUVVPVCI6IlxcIiIsInJBYXJyIjoi4oebIiwicmFjZSI6IuKIvcyxIiwiUmFjdXRlIjoixZQiLCJyYWN1dGUiOiLFlSIsInJhZGljIjoi4oiaIiwicmFlbXB0eXYiOiLiprMiLCJyYW5nIjoi4p+pIiwiUmFuZyI6IuKfqyIsInJhbmdkIjoi4qaSIiwicmFuZ2UiOiLipqUiLCJyYW5nbGUiOiLin6kiLCJyYXF1byI6IsK7IiwicmFycmFwIjoi4qW1IiwicmFycmIiOiLih6UiLCJyYXJyYmZzIjoi4qSgIiwicmFycmMiOiLipLMiLCJyYXJyIjoi4oaSIiwiUmFyciI6IuKGoCIsInJBcnIiOiLih5IiLCJyYXJyZnMiOiLipJ4iLCJyYXJyaGsiOiLihqoiLCJyYXJybHAiOiLihqwiLCJyYXJycGwiOiLipYUiLCJyYXJyc2ltIjoi4qW0IiwiUmFycnRsIjoi4qSWIiwicmFycnRsIjoi4oajIiwicmFycnciOiLihp0iLCJyYXRhaWwiOiLipJoiLCJyQXRhaWwiOiLipJwiLCJyYXRpbyI6IuKItiIsInJhdGlvbmFscyI6IuKEmiIsInJiYXJyIjoi4qSNIiwickJhcnIiOiLipI8iLCJSQmFyciI6IuKkkCIsInJiYnJrIjoi4p2zIiwicmJyYWNlIjoifSIsInJicmFjayI6Il0iLCJyYnJrZSI6IuKmjCIsInJicmtzbGQiOiLipo4iLCJyYnJrc2x1Ijoi4qaQIiwiUmNhcm9uIjoixZgiLCJyY2Fyb24iOiLFmSIsIlJjZWRpbCI6IsWWIiwicmNlZGlsIjoixZciLCJyY2VpbCI6IuKMiSIsInJjdWIiOiJ9IiwiUmN5Ijoi0KAiLCJyY3kiOiLRgCIsInJkY2EiOiLipLciLCJyZGxkaGFyIjoi4qWpIiwicmRxdW8iOiLigJ0iLCJyZHF1b3IiOiLigJ0iLCJyZHNoIjoi4oazIiwicmVhbCI6IuKEnCIsInJlYWxpbmUiOiLihJsiLCJyZWFscGFydCI6IuKEnCIsInJlYWxzIjoi4oSdIiwiUmUiOiLihJwiLCJyZWN0Ijoi4patIiwicmVnIjoiwq4iLCJSRUciOiLCriIsIlJldmVyc2VFbGVtZW50Ijoi4oiLIiwiUmV2ZXJzZUVxdWlsaWJyaXVtIjoi4oeLIiwiUmV2ZXJzZVVwRXF1aWxpYnJpdW0iOiLipa8iLCJyZmlzaHQiOiLipb0iLCJyZmxvb3IiOiLijIsiLCJyZnIiOiLwnZSvIiwiUmZyIjoi4oScIiwickhhciI6IuKlpCIsInJoYXJkIjoi4oeBIiwicmhhcnUiOiLih4AiLCJyaGFydWwiOiLipawiLCJSaG8iOiLOoSIsInJobyI6Is+BIiwicmhvdiI6Is+xIiwiUmlnaHRBbmdsZUJyYWNrZXQiOiLin6kiLCJSaWdodEFycm93QmFyIjoi4oelIiwicmlnaHRhcnJvdyI6IuKGkiIsIlJpZ2h0QXJyb3ciOiLihpIiLCJSaWdodGFycm93Ijoi4oeSIiwiUmlnaHRBcnJvd0xlZnRBcnJvdyI6IuKHhCIsInJpZ2h0YXJyb3d0YWlsIjoi4oajIiwiUmlnaHRDZWlsaW5nIjoi4oyJIiwiUmlnaHREb3VibGVCcmFja2V0Ijoi4p+nIiwiUmlnaHREb3duVGVlVmVjdG9yIjoi4qWdIiwiUmlnaHREb3duVmVjdG9yQmFyIjoi4qWVIiwiUmlnaHREb3duVmVjdG9yIjoi4oeCIiwiUmlnaHRGbG9vciI6IuKMiyIsInJpZ2h0aGFycG9vbmRvd24iOiLih4EiLCJyaWdodGhhcnBvb251cCI6IuKHgCIsInJpZ2h0bGVmdGFycm93cyI6IuKHhCIsInJpZ2h0bGVmdGhhcnBvb25zIjoi4oeMIiwicmlnaHRyaWdodGFycm93cyI6IuKHiSIsInJpZ2h0c3F1aWdhcnJvdyI6IuKGnSIsIlJpZ2h0VGVlQXJyb3ciOiLihqYiLCJSaWdodFRlZSI6IuKKoiIsIlJpZ2h0VGVlVmVjdG9yIjoi4qWbIiwicmlnaHR0aHJlZXRpbWVzIjoi4ouMIiwiUmlnaHRUcmlhbmdsZUJhciI6IuKnkCIsIlJpZ2h0VHJpYW5nbGUiOiLiirMiLCJSaWdodFRyaWFuZ2xlRXF1YWwiOiLiirUiLCJSaWdodFVwRG93blZlY3RvciI6IuKljyIsIlJpZ2h0VXBUZWVWZWN0b3IiOiLipZwiLCJSaWdodFVwVmVjdG9yQmFyIjoi4qWUIiwiUmlnaHRVcFZlY3RvciI6IuKGviIsIlJpZ2h0VmVjdG9yQmFyIjoi4qWTIiwiUmlnaHRWZWN0b3IiOiLih4AiLCJyaW5nIjoiy5oiLCJyaXNpbmdkb3RzZXEiOiLiiZMiLCJybGFyciI6IuKHhCIsInJsaGFyIjoi4oeMIiwicmxtIjoi4oCPIiwicm1vdXN0YWNoZSI6IuKOsSIsInJtb3VzdCI6IuKOsSIsInJubWlkIjoi4quuIiwicm9hbmciOiLin60iLCJyb2FyciI6IuKHviIsInJvYnJrIjoi4p+nIiwicm9wYXIiOiLipoYiLCJyb3BmIjoi8J2VoyIsIlJvcGYiOiLihJ0iLCJyb3BsdXMiOiLiqK4iLCJyb3RpbWVzIjoi4qi1IiwiUm91bmRJbXBsaWVzIjoi4qWwIiwicnBhciI6IikiLCJycGFyZ3QiOiLippQiLCJycHBvbGludCI6IuKokiIsInJyYXJyIjoi4oeJIiwiUnJpZ2h0YXJyb3ciOiLih5siLCJyc2FxdW8iOiLigLoiLCJyc2NyIjoi8J2ThyIsIlJzY3IiOiLihJsiLCJyc2giOiLihrEiLCJSc2giOiLihrEiLCJyc3FiIjoiXSIsInJzcXVvIjoi4oCZIiwicnNxdW9yIjoi4oCZIiwicnRocmVlIjoi4ouMIiwicnRpbWVzIjoi4ouKIiwicnRyaSI6IuKWuSIsInJ0cmllIjoi4oq1IiwicnRyaWYiOiLilrgiLCJydHJpbHRyaSI6IuKnjiIsIlJ1bGVEZWxheWVkIjoi4qe0IiwicnVsdWhhciI6IuKlqCIsInJ4Ijoi4oSeIiwiU2FjdXRlIjoixZoiLCJzYWN1dGUiOiLFmyIsInNicXVvIjoi4oCaIiwic2NhcCI6IuKquCIsIlNjYXJvbiI6IsWgIiwic2Nhcm9uIjoixaEiLCJTYyI6IuKqvCIsInNjIjoi4om7Iiwic2NjdWUiOiLiib0iLCJzY2UiOiLiqrAiLCJzY0UiOiLiqrQiLCJTY2VkaWwiOiLFniIsInNjZWRpbCI6IsWfIiwiU2NpcmMiOiLFnCIsInNjaXJjIjoixZ0iLCJzY25hcCI6IuKquiIsInNjbkUiOiLiqrYiLCJzY25zaW0iOiLii6kiLCJzY3BvbGludCI6IuKokyIsInNjc2ltIjoi4om/IiwiU2N5Ijoi0KEiLCJzY3kiOiLRgSIsInNkb3RiIjoi4oqhIiwic2RvdCI6IuKLhSIsInNkb3RlIjoi4qmmIiwic2VhcmhrIjoi4qSlIiwic2VhcnIiOiLihpgiLCJzZUFyciI6IuKHmCIsInNlYXJyb3ciOiLihpgiLCJzZWN0IjoiwqciLCJzZW1pIjoiOyIsInNlc3dhciI6IuKkqSIsInNldG1pbnVzIjoi4oiWIiwic2V0bW4iOiLiiJYiLCJzZXh0Ijoi4py2IiwiU2ZyIjoi8J2UliIsInNmciI6IvCdlLAiLCJzZnJvd24iOiLijKIiLCJzaGFycCI6IuKZryIsIlNIQ0hjeSI6ItCpIiwic2hjaGN5Ijoi0YkiLCJTSGN5Ijoi0KgiLCJzaGN5Ijoi0YgiLCJTaG9ydERvd25BcnJvdyI6IuKGkyIsIlNob3J0TGVmdEFycm93Ijoi4oaQIiwic2hvcnRtaWQiOiLiiKMiLCJzaG9ydHBhcmFsbGVsIjoi4oilIiwiU2hvcnRSaWdodEFycm93Ijoi4oaSIiwiU2hvcnRVcEFycm93Ijoi4oaRIiwic2h5Ijoiwq0iLCJTaWdtYSI6Is6jIiwic2lnbWEiOiLPgyIsInNpZ21hZiI6Is+CIiwic2lnbWF2Ijoiz4IiLCJzaW0iOiLiiLwiLCJzaW1kb3QiOiLiqaoiLCJzaW1lIjoi4omDIiwic2ltZXEiOiLiiYMiLCJzaW1nIjoi4qqeIiwic2ltZ0UiOiLiqqAiLCJzaW1sIjoi4qqdIiwic2ltbEUiOiLiqp8iLCJzaW1uZSI6IuKJhiIsInNpbXBsdXMiOiLiqKQiLCJzaW1yYXJyIjoi4qWyIiwic2xhcnIiOiLihpAiLCJTbWFsbENpcmNsZSI6IuKImCIsInNtYWxsc2V0bWludXMiOiLiiJYiLCJzbWFzaHAiOiLiqLMiLCJzbWVwYXJzbCI6IuKnpCIsInNtaWQiOiLiiKMiLCJzbWlsZSI6IuKMoyIsInNtdCI6IuKqqiIsInNtdGUiOiLiqqwiLCJzbXRlcyI6IuKqrO+4gCIsIlNPRlRjeSI6ItCsIiwic29mdGN5Ijoi0YwiLCJzb2xiYXIiOiLijL8iLCJzb2xiIjoi4qeEIiwic29sIjoiLyIsIlNvcGYiOiLwnZWKIiwic29wZiI6IvCdlaQiLCJzcGFkZXMiOiLimaAiLCJzcGFkZXN1aXQiOiLimaAiLCJzcGFyIjoi4oilIiwic3FjYXAiOiLiipMiLCJzcWNhcHMiOiLiipPvuIAiLCJzcWN1cCI6IuKKlCIsInNxY3VwcyI6IuKKlO+4gCIsIlNxcnQiOiLiiJoiLCJzcXN1YiI6IuKKjyIsInNxc3ViZSI6IuKKkSIsInNxc3Vic2V0Ijoi4oqPIiwic3FzdWJzZXRlcSI6IuKKkSIsInNxc3VwIjoi4oqQIiwic3FzdXBlIjoi4oqSIiwic3FzdXBzZXQiOiLiipAiLCJzcXN1cHNldGVxIjoi4oqSIiwic3F1YXJlIjoi4pahIiwiU3F1YXJlIjoi4pahIiwiU3F1YXJlSW50ZXJzZWN0aW9uIjoi4oqTIiwiU3F1YXJlU3Vic2V0Ijoi4oqPIiwiU3F1YXJlU3Vic2V0RXF1YWwiOiLiipEiLCJTcXVhcmVTdXBlcnNldCI6IuKKkCIsIlNxdWFyZVN1cGVyc2V0RXF1YWwiOiLiipIiLCJTcXVhcmVVbmlvbiI6IuKKlCIsInNxdWFyZiI6IuKWqiIsInNxdSI6IuKWoSIsInNxdWYiOiLilqoiLCJzcmFyciI6IuKGkiIsIlNzY3IiOiLwnZKuIiwic3NjciI6IvCdk4giLCJzc2V0bW4iOiLiiJYiLCJzc21pbGUiOiLijKMiLCJzc3RhcmYiOiLii4YiLCJTdGFyIjoi4ouGIiwic3RhciI6IuKYhiIsInN0YXJmIjoi4piFIiwic3RyYWlnaHRlcHNpbG9uIjoiz7UiLCJzdHJhaWdodHBoaSI6Is+VIiwic3RybnMiOiLCryIsInN1YiI6IuKKgiIsIlN1YiI6IuKLkCIsInN1YmRvdCI6IuKqvSIsInN1YkUiOiLiq4UiLCJzdWJlIjoi4oqGIiwic3ViZWRvdCI6IuKrgyIsInN1Ym11bHQiOiLiq4EiLCJzdWJuRSI6IuKriyIsInN1Ym5lIjoi4oqKIiwic3VicGx1cyI6IuKqvyIsInN1YnJhcnIiOiLipbkiLCJzdWJzZXQiOiLiioIiLCJTdWJzZXQiOiLii5AiLCJzdWJzZXRlcSI6IuKKhiIsInN1YnNldGVxcSI6IuKrhSIsIlN1YnNldEVxdWFsIjoi4oqGIiwic3Vic2V0bmVxIjoi4oqKIiwic3Vic2V0bmVxcSI6IuKriyIsInN1YnNpbSI6IuKrhyIsInN1YnN1YiI6IuKrlSIsInN1YnN1cCI6IuKrkyIsInN1Y2NhcHByb3giOiLiqrgiLCJzdWNjIjoi4om7Iiwic3VjY2N1cmx5ZXEiOiLiib0iLCJTdWNjZWVkcyI6IuKJuyIsIlN1Y2NlZWRzRXF1YWwiOiLiqrAiLCJTdWNjZWVkc1NsYW50RXF1YWwiOiLiib0iLCJTdWNjZWVkc1RpbGRlIjoi4om/Iiwic3VjY2VxIjoi4qqwIiwic3VjY25hcHByb3giOiLiqroiLCJzdWNjbmVxcSI6IuKqtiIsInN1Y2Nuc2ltIjoi4oupIiwic3VjY3NpbSI6IuKJvyIsIlN1Y2hUaGF0Ijoi4oiLIiwic3VtIjoi4oiRIiwiU3VtIjoi4oiRIiwic3VuZyI6IuKZqiIsInN1cDEiOiLCuSIsInN1cDIiOiLCsiIsInN1cDMiOiLCsyIsInN1cCI6IuKKgyIsIlN1cCI6IuKLkSIsInN1cGRvdCI6IuKqviIsInN1cGRzdWIiOiLiq5giLCJzdXBFIjoi4quGIiwic3VwZSI6IuKKhyIsInN1cGVkb3QiOiLiq4QiLCJTdXBlcnNldCI6IuKKgyIsIlN1cGVyc2V0RXF1YWwiOiLiiociLCJzdXBoc29sIjoi4p+JIiwic3VwaHN1YiI6IuKrlyIsInN1cGxhcnIiOiLipbsiLCJzdXBtdWx0Ijoi4quCIiwic3VwbkUiOiLiq4wiLCJzdXBuZSI6IuKKiyIsInN1cHBsdXMiOiLiq4AiLCJzdXBzZXQiOiLiioMiLCJTdXBzZXQiOiLii5EiLCJzdXBzZXRlcSI6IuKKhyIsInN1cHNldGVxcSI6IuKrhiIsInN1cHNldG5lcSI6IuKKiyIsInN1cHNldG5lcXEiOiLiq4wiLCJzdXBzaW0iOiLiq4giLCJzdXBzdWIiOiLiq5QiLCJzdXBzdXAiOiLiq5YiLCJzd2FyaGsiOiLipKYiLCJzd2FyciI6IuKGmSIsInN3QXJyIjoi4oeZIiwic3dhcnJvdyI6IuKGmSIsInN3bndhciI6IuKkqiIsInN6bGlnIjoiw58iLCJUYWIiOiJcXHQiLCJ0YXJnZXQiOiLijJYiLCJUYXUiOiLOpCIsInRhdSI6Is+EIiwidGJyayI6IuKOtCIsIlRjYXJvbiI6IsWkIiwidGNhcm9uIjoixaUiLCJUY2VkaWwiOiLFoiIsInRjZWRpbCI6IsWjIiwiVGN5Ijoi0KIiLCJ0Y3kiOiLRgiIsInRkb3QiOiLig5siLCJ0ZWxyZWMiOiLijJUiLCJUZnIiOiLwnZSXIiwidGZyIjoi8J2UsSIsInRoZXJlNCI6IuKItCIsInRoZXJlZm9yZSI6IuKItCIsIlRoZXJlZm9yZSI6IuKItCIsIlRoZXRhIjoizpgiLCJ0aGV0YSI6Is64IiwidGhldGFzeW0iOiLPkSIsInRoZXRhdiI6Is+RIiwidGhpY2thcHByb3giOiLiiYgiLCJ0aGlja3NpbSI6IuKIvCIsIlRoaWNrU3BhY2UiOiLigZ/igIoiLCJUaGluU3BhY2UiOiLigIkiLCJ0aGluc3AiOiLigIkiLCJ0aGthcCI6IuKJiCIsInRoa3NpbSI6IuKIvCIsIlRIT1JOIjoiw54iLCJ0aG9ybiI6IsO+IiwidGlsZGUiOiLLnCIsIlRpbGRlIjoi4oi8IiwiVGlsZGVFcXVhbCI6IuKJgyIsIlRpbGRlRnVsbEVxdWFsIjoi4omFIiwiVGlsZGVUaWxkZSI6IuKJiCIsInRpbWVzYmFyIjoi4qixIiwidGltZXNiIjoi4oqgIiwidGltZXMiOiLDlyIsInRpbWVzZCI6IuKosCIsInRpbnQiOiLiiK0iLCJ0b2VhIjoi4qSoIiwidG9wYm90Ijoi4oy2IiwidG9wY2lyIjoi4quxIiwidG9wIjoi4oqkIiwiVG9wZiI6IvCdlYsiLCJ0b3BmIjoi8J2VpSIsInRvcGZvcmsiOiLiq5oiLCJ0b3NhIjoi4qSpIiwidHByaW1lIjoi4oC0IiwidHJhZGUiOiLihKIiLCJUUkFERSI6IuKEoiIsInRyaWFuZ2xlIjoi4pa1IiwidHJpYW5nbGVkb3duIjoi4pa/IiwidHJpYW5nbGVsZWZ0Ijoi4peDIiwidHJpYW5nbGVsZWZ0ZXEiOiLiirQiLCJ0cmlhbmdsZXEiOiLiiZwiLCJ0cmlhbmdsZXJpZ2h0Ijoi4pa5IiwidHJpYW5nbGVyaWdodGVxIjoi4oq1IiwidHJpZG90Ijoi4pesIiwidHJpZSI6IuKJnCIsInRyaW1pbnVzIjoi4qi6IiwiVHJpcGxlRG90Ijoi4oObIiwidHJpcGx1cyI6IuKouSIsInRyaXNiIjoi4qeNIiwidHJpdGltZSI6IuKouyIsInRycGV6aXVtIjoi4o+iIiwiVHNjciI6IvCdkq8iLCJ0c2NyIjoi8J2TiSIsIlRTY3kiOiLQpiIsInRzY3kiOiLRhiIsIlRTSGN5Ijoi0IsiLCJ0c2hjeSI6ItGbIiwiVHN0cm9rIjoixaYiLCJ0c3Ryb2siOiLFpyIsInR3aXh0Ijoi4omsIiwidHdvaGVhZGxlZnRhcnJvdyI6IuKGniIsInR3b2hlYWRyaWdodGFycm93Ijoi4oagIiwiVWFjdXRlIjoiw5oiLCJ1YWN1dGUiOiLDuiIsInVhcnIiOiLihpEiLCJVYXJyIjoi4oafIiwidUFyciI6IuKHkSIsIlVhcnJvY2lyIjoi4qWJIiwiVWJyY3kiOiLQjiIsInVicmN5Ijoi0Z4iLCJVYnJldmUiOiLFrCIsInVicmV2ZSI6IsWtIiwiVWNpcmMiOiLDmyIsInVjaXJjIjoiw7siLCJVY3kiOiLQoyIsInVjeSI6ItGDIiwidWRhcnIiOiLih4UiLCJVZGJsYWMiOiLFsCIsInVkYmxhYyI6IsWxIiwidWRoYXIiOiLipa4iLCJ1ZmlzaHQiOiLipb4iLCJVZnIiOiLwnZSYIiwidWZyIjoi8J2UsiIsIlVncmF2ZSI6IsOZIiwidWdyYXZlIjoiw7kiLCJ1SGFyIjoi4qWjIiwidWhhcmwiOiLihr8iLCJ1aGFyciI6IuKGviIsInVoYmxrIjoi4paAIiwidWxjb3JuIjoi4oycIiwidWxjb3JuZXIiOiLijJwiLCJ1bGNyb3AiOiLijI8iLCJ1bHRyaSI6IuKXuCIsIlVtYWNyIjoixaoiLCJ1bWFjciI6IsWrIiwidW1sIjoiwqgiLCJVbmRlckJhciI6Il8iLCJVbmRlckJyYWNlIjoi4o+fIiwiVW5kZXJCcmFja2V0Ijoi4o61IiwiVW5kZXJQYXJlbnRoZXNpcyI6IuKPnSIsIlVuaW9uIjoi4ouDIiwiVW5pb25QbHVzIjoi4oqOIiwiVW9nb24iOiLFsiIsInVvZ29uIjoixbMiLCJVb3BmIjoi8J2VjCIsInVvcGYiOiLwnZWmIiwiVXBBcnJvd0JhciI6IuKkkiIsInVwYXJyb3ciOiLihpEiLCJVcEFycm93Ijoi4oaRIiwiVXBhcnJvdyI6IuKHkSIsIlVwQXJyb3dEb3duQXJyb3ciOiLih4UiLCJ1cGRvd25hcnJvdyI6IuKGlSIsIlVwRG93bkFycm93Ijoi4oaVIiwiVXBkb3duYXJyb3ciOiLih5UiLCJVcEVxdWlsaWJyaXVtIjoi4qWuIiwidXBoYXJwb29ubGVmdCI6IuKGvyIsInVwaGFycG9vbnJpZ2h0Ijoi4oa+IiwidXBsdXMiOiLiio4iLCJVcHBlckxlZnRBcnJvdyI6IuKGliIsIlVwcGVyUmlnaHRBcnJvdyI6IuKGlyIsInVwc2kiOiLPhSIsIlVwc2kiOiLPkiIsInVwc2loIjoiz5IiLCJVcHNpbG9uIjoizqUiLCJ1cHNpbG9uIjoiz4UiLCJVcFRlZUFycm93Ijoi4oalIiwiVXBUZWUiOiLiiqUiLCJ1cHVwYXJyb3dzIjoi4oeIIiwidXJjb3JuIjoi4oydIiwidXJjb3JuZXIiOiLijJ0iLCJ1cmNyb3AiOiLijI4iLCJVcmluZyI6IsWuIiwidXJpbmciOiLFryIsInVydHJpIjoi4pe5IiwiVXNjciI6IvCdkrAiLCJ1c2NyIjoi8J2TiiIsInV0ZG90Ijoi4ouwIiwiVXRpbGRlIjoixagiLCJ1dGlsZGUiOiLFqSIsInV0cmkiOiLilrUiLCJ1dHJpZiI6IuKWtCIsInV1YXJyIjoi4oeIIiwiVXVtbCI6IsOcIiwidXVtbCI6IsO8IiwidXdhbmdsZSI6IuKmpyIsInZhbmdydCI6IuKmnCIsInZhcmVwc2lsb24iOiLPtSIsInZhcmthcHBhIjoiz7AiLCJ2YXJub3RoaW5nIjoi4oiFIiwidmFycGhpIjoiz5UiLCJ2YXJwaSI6Is+WIiwidmFycHJvcHRvIjoi4oidIiwidmFyciI6IuKGlSIsInZBcnIiOiLih5UiLCJ2YXJyaG8iOiLPsSIsInZhcnNpZ21hIjoiz4IiLCJ2YXJzdWJzZXRuZXEiOiLiiorvuIAiLCJ2YXJzdWJzZXRuZXFxIjoi4quL77iAIiwidmFyc3Vwc2V0bmVxIjoi4oqL77iAIiwidmFyc3Vwc2V0bmVxcSI6IuKrjO+4gCIsInZhcnRoZXRhIjoiz5EiLCJ2YXJ0cmlhbmdsZWxlZnQiOiLiirIiLCJ2YXJ0cmlhbmdsZXJpZ2h0Ijoi4oqzIiwidkJhciI6IuKrqCIsIlZiYXIiOiLiq6siLCJ2QmFydiI6IuKrqSIsIlZjeSI6ItCSIiwidmN5Ijoi0LIiLCJ2ZGFzaCI6IuKKoiIsInZEYXNoIjoi4oqoIiwiVmRhc2giOiLiiqkiLCJWRGFzaCI6IuKKqyIsIlZkYXNobCI6IuKrpiIsInZlZWJhciI6IuKKuyIsInZlZSI6IuKIqCIsIlZlZSI6IuKLgSIsInZlZWVxIjoi4omaIiwidmVsbGlwIjoi4ouuIiwidmVyYmFyIjoifCIsIlZlcmJhciI6IuKAliIsInZlcnQiOiJ8IiwiVmVydCI6IuKAliIsIlZlcnRpY2FsQmFyIjoi4oijIiwiVmVydGljYWxMaW5lIjoifCIsIlZlcnRpY2FsU2VwYXJhdG9yIjoi4p2YIiwiVmVydGljYWxUaWxkZSI6IuKJgCIsIlZlcnlUaGluU3BhY2UiOiLigIoiLCJWZnIiOiLwnZSZIiwidmZyIjoi8J2UsyIsInZsdHJpIjoi4oqyIiwidm5zdWIiOiLiioLig5IiLCJ2bnN1cCI6IuKKg+KDkiIsIlZvcGYiOiLwnZWNIiwidm9wZiI6IvCdlaciLCJ2cHJvcCI6IuKInSIsInZydHJpIjoi4oqzIiwiVnNjciI6IvCdkrEiLCJ2c2NyIjoi8J2TiyIsInZzdWJuRSI6IuKri++4gCIsInZzdWJuZSI6IuKKiu+4gCIsInZzdXBuRSI6IuKrjO+4gCIsInZzdXBuZSI6IuKKi++4gCIsIlZ2ZGFzaCI6IuKKqiIsInZ6aWd6YWciOiLippoiLCJXY2lyYyI6IsW0Iiwid2NpcmMiOiLFtSIsIndlZGJhciI6IuKpnyIsIndlZGdlIjoi4oinIiwiV2VkZ2UiOiLii4AiLCJ3ZWRnZXEiOiLiiZkiLCJ3ZWllcnAiOiLihJgiLCJXZnIiOiLwnZSaIiwid2ZyIjoi8J2UtCIsIldvcGYiOiLwnZWOIiwid29wZiI6IvCdlagiLCJ3cCI6IuKEmCIsIndyIjoi4omAIiwid3JlYXRoIjoi4omAIiwiV3NjciI6IvCdkrIiLCJ3c2NyIjoi8J2TjCIsInhjYXAiOiLii4IiLCJ4Y2lyYyI6IuKXryIsInhjdXAiOiLii4MiLCJ4ZHRyaSI6IuKWvSIsIlhmciI6IvCdlJsiLCJ4ZnIiOiLwnZS1IiwieGhhcnIiOiLin7ciLCJ4aEFyciI6IuKfuiIsIlhpIjoizp4iLCJ4aSI6Is6+IiwieGxhcnIiOiLin7UiLCJ4bEFyciI6IuKfuCIsInhtYXAiOiLin7wiLCJ4bmlzIjoi4ou7IiwieG9kb3QiOiLiqIAiLCJYb3BmIjoi8J2VjyIsInhvcGYiOiLwnZWpIiwieG9wbHVzIjoi4qiBIiwieG90aW1lIjoi4qiCIiwieHJhcnIiOiLin7YiLCJ4ckFyciI6IuKfuSIsIlhzY3IiOiLwnZKzIiwieHNjciI6IvCdk40iLCJ4c3FjdXAiOiLiqIYiLCJ4dXBsdXMiOiLiqIQiLCJ4dXRyaSI6IuKWsyIsInh2ZWUiOiLii4EiLCJ4d2VkZ2UiOiLii4AiLCJZYWN1dGUiOiLDnSIsInlhY3V0ZSI6IsO9IiwiWUFjeSI6ItCvIiwieWFjeSI6ItGPIiwiWWNpcmMiOiLFtiIsInljaXJjIjoixbciLCJZY3kiOiLQqyIsInljeSI6ItGLIiwieWVuIjoiwqUiLCJZZnIiOiLwnZScIiwieWZyIjoi8J2UtiIsIllJY3kiOiLQhyIsInlpY3kiOiLRlyIsIllvcGYiOiLwnZWQIiwieW9wZiI6IvCdlaoiLCJZc2NyIjoi8J2StCIsInlzY3IiOiLwnZOOIiwiWVVjeSI6ItCuIiwieXVjeSI6ItGOIiwieXVtbCI6IsO/IiwiWXVtbCI6IsW4IiwiWmFjdXRlIjoixbkiLCJ6YWN1dGUiOiLFuiIsIlpjYXJvbiI6IsW9IiwiemNhcm9uIjoixb4iLCJaY3kiOiLQlyIsInpjeSI6ItC3IiwiWmRvdCI6IsW7IiwiemRvdCI6IsW8IiwiemVldHJmIjoi4oSoIiwiWmVyb1dpZHRoU3BhY2UiOiLigIsiLCJaZXRhIjoizpYiLCJ6ZXRhIjoizrYiLCJ6ZnIiOiLwnZS3IiwiWmZyIjoi4oSoIiwiWkhjeSI6ItCWIiwiemhjeSI6ItC2IiwiemlncmFyciI6IuKHnSIsInpvcGYiOiLwnZWrIiwiWm9wZiI6IuKEpCIsIlpzY3IiOiLwnZK1IiwienNjciI6IvCdk48iLCJ6d2oiOiLigI0iLCJ6d25qIjoi4oCMIn0nKX0sZnVuY3Rpb24oZyl7Zy5leHBvcnRzPUpTT04ucGFyc2UoJ3siQWFjdXRlIjoiw4EiLCJhYWN1dGUiOiLDoSIsIkFjaXJjIjoiw4IiLCJhY2lyYyI6IsOiIiwiYWN1dGUiOiLCtCIsIkFFbGlnIjoiw4YiLCJhZWxpZyI6IsOmIiwiQWdyYXZlIjoiw4AiLCJhZ3JhdmUiOiLDoCIsImFtcCI6IiYiLCJBTVAiOiImIiwiQXJpbmciOiLDhSIsImFyaW5nIjoiw6UiLCJBdGlsZGUiOiLDgyIsImF0aWxkZSI6IsOjIiwiQXVtbCI6IsOEIiwiYXVtbCI6IsOkIiwiYnJ2YmFyIjoiwqYiLCJDY2VkaWwiOiLDhyIsImNjZWRpbCI6IsOnIiwiY2VkaWwiOiLCuCIsImNlbnQiOiLCoiIsImNvcHkiOiLCqSIsIkNPUFkiOiLCqSIsImN1cnJlbiI6IsKkIiwiZGVnIjoiwrAiLCJkaXZpZGUiOiLDtyIsIkVhY3V0ZSI6IsOJIiwiZWFjdXRlIjoiw6kiLCJFY2lyYyI6IsOKIiwiZWNpcmMiOiLDqiIsIkVncmF2ZSI6IsOIIiwiZWdyYXZlIjoiw6giLCJFVEgiOiLDkCIsImV0aCI6IsOwIiwiRXVtbCI6IsOLIiwiZXVtbCI6IsOrIiwiZnJhYzEyIjoiwr0iLCJmcmFjMTQiOiLCvCIsImZyYWMzNCI6IsK+IiwiZ3QiOiI+IiwiR1QiOiI+IiwiSWFjdXRlIjoiw40iLCJpYWN1dGUiOiLDrSIsIkljaXJjIjoiw44iLCJpY2lyYyI6IsOuIiwiaWV4Y2wiOiLCoSIsIklncmF2ZSI6IsOMIiwiaWdyYXZlIjoiw6wiLCJpcXVlc3QiOiLCvyIsIkl1bWwiOiLDjyIsIml1bWwiOiLDryIsImxhcXVvIjoiwqsiLCJsdCI6IjwiLCJMVCI6IjwiLCJtYWNyIjoiwq8iLCJtaWNybyI6IsK1IiwibWlkZG90IjoiwrciLCJuYnNwIjoiwqAiLCJub3QiOiLCrCIsIk50aWxkZSI6IsORIiwibnRpbGRlIjoiw7EiLCJPYWN1dGUiOiLDkyIsIm9hY3V0ZSI6IsOzIiwiT2NpcmMiOiLDlCIsIm9jaXJjIjoiw7QiLCJPZ3JhdmUiOiLDkiIsIm9ncmF2ZSI6IsOyIiwib3JkZiI6IsKqIiwib3JkbSI6IsK6IiwiT3NsYXNoIjoiw5giLCJvc2xhc2giOiLDuCIsIk90aWxkZSI6IsOVIiwib3RpbGRlIjoiw7UiLCJPdW1sIjoiw5YiLCJvdW1sIjoiw7YiLCJwYXJhIjoiwrYiLCJwbHVzbW4iOiLCsSIsInBvdW5kIjoiwqMiLCJxdW90IjoiXFwiIiwiUVVPVCI6IlxcIiIsInJhcXVvIjoiwrsiLCJyZWciOiLCriIsIlJFRyI6IsKuIiwic2VjdCI6IsKnIiwic2h5Ijoiwq0iLCJzdXAxIjoiwrkiLCJzdXAyIjoiwrIiLCJzdXAzIjoiwrMiLCJzemxpZyI6IsOfIiwiVEhPUk4iOiLDniIsInRob3JuIjoiw74iLCJ0aW1lcyI6IsOXIiwiVWFjdXRlIjoiw5oiLCJ1YWN1dGUiOiLDuiIsIlVjaXJjIjoiw5siLCJ1Y2lyYyI6IsO7IiwiVWdyYXZlIjoiw5kiLCJ1Z3JhdmUiOiLDuSIsInVtbCI6IsKoIiwiVXVtbCI6IsOcIiwidXVtbCI6IsO8IiwiWWFjdXRlIjoiw50iLCJ5YWN1dGUiOiLDvSIsInllbiI6IsKlIiwieXVtbCI6IsO/In0nKX0sZnVuY3Rpb24oZyl7Zy5leHBvcnRzPUpTT04ucGFyc2UoYHsiYW1wIjoiJiIsImFwb3MiOiInIiwiZ3QiOiI+IiwibHQiOiI8IiwicXVvdCI6IlxcIiJ9YCl9LGZ1bmN0aW9uKGcsZSx0KXt2YXIgbj10aGlzJiZ0aGlzLl9faW1wb3J0RGVmYXVsdHx8ZnVuY3Rpb24oaCl7cmV0dXJuIGgmJmguX19lc01vZHVsZT9oOntkZWZhdWx0Omh9fTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSk7dmFyIGk9bih0KDI2NSkpO2Z1bmN0aW9uIGYoaCl7aWYoaD49NTUyOTYmJmg8PTU3MzQzfHxoPjExMTQxMTEpcmV0dXJuIu+/vSI7aCBpbiBpLmRlZmF1bHQmJihoPWkuZGVmYXVsdFtoXSk7dmFyIHU9IiI7cmV0dXJuIGg+NjU1MzUmJihoLT02NTUzNix1Kz1TdHJpbmcuZnJvbUNoYXJDb2RlKGg+Pj4xMCYxMDIzfDU1Mjk2KSxoPTU2MzIwfGgmMTAyMyksdSs9U3RyaW5nLmZyb21DaGFyQ29kZShoKSx1fWUuZGVmYXVsdD1mfSxmdW5jdGlvbihnKXtnLmV4cG9ydHM9SlNPTi5wYXJzZSgneyIwIjo2NTUzMywiMTI4Ijo4MzY0LCIxMzAiOjgyMTgsIjEzMSI6NDAyLCIxMzIiOjgyMjIsIjEzMyI6ODIzMCwiMTM0Ijo4MjI0LCIxMzUiOjgyMjUsIjEzNiI6NzEwLCIxMzciOjgyNDAsIjEzOCI6MzUyLCIxMzkiOjgyNDksIjE0MCI6MzM4LCIxNDIiOjM4MSwiMTQ1Ijo4MjE2LCIxNDYiOjgyMTcsIjE0NyI6ODIyMCwiMTQ4Ijo4MjIxLCIxNDkiOjgyMjYsIjE1MCI6ODIxMSwiMTUxIjo4MjEyLCIxNTIiOjczMiwiMTUzIjo4NDgyLCIxNTQiOjM1MywiMTU1Ijo4MjUwLCIxNTYiOjMzOSwiMTU4IjozODIsIjE1OSI6Mzc2fScpfSxmdW5jdGlvbihnLGUsdCl7dmFyIG49dGhpcyYmdGhpcy5fX2ltcG9ydERlZmF1bHR8fGZ1bmN0aW9uKFMpe3JldHVybiBTJiZTLl9fZXNNb2R1bGU/Uzp7ZGVmYXVsdDpTfX07T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLGUuZXNjYXBlPWUuZW5jb2RlSFRNTD1lLmVuY29kZVhNTD12b2lkIDA7dmFyIGk9bih0KDI2MykpLGY9RShpLmRlZmF1bHQpLGg9cChmKTtlLmVuY29kZVhNTD1iKGYsaCk7dmFyIHU9bih0KDI2MSkpLGE9RSh1LmRlZmF1bHQpLGQ9cChhKTtlLmVuY29kZUhUTUw9YihhLGQpO2Z1bmN0aW9uIEUoUyl7cmV0dXJuIE9iamVjdC5rZXlzKFMpLnNvcnQoKS5yZWR1Y2UoZnVuY3Rpb24ocyxjKXtyZXR1cm4gc1tTW2NdXT0iJiIrYysiOyIsc30se30pfWZ1bmN0aW9uIHAoUyl7Zm9yKHZhciBzPVtdLGM9W10sbD0wLHY9T2JqZWN0LmtleXMoUyk7bDx2Lmxlbmd0aDtsKyspe3ZhciBUPXZbbF07VC5sZW5ndGg9PT0xP3MucHVzaCgiXFwiK1QpOmMucHVzaChUKX1zLnNvcnQoKTtmb3IodmFyIFI9MDtSPHMubGVuZ3RoLTE7UisrKXtmb3IodmFyIEw9UjtMPHMubGVuZ3RoLTEmJnNbTF0uY2hhckNvZGVBdCgxKSsxPT09c1tMKzFdLmNoYXJDb2RlQXQoMSk7KUwrPTE7dmFyIE49MStMLVI7TjwzfHxzLnNwbGljZShSLE4sc1tSXSsiLSIrc1tMXSl9cmV0dXJuIGMudW5zaGlmdCgiWyIrcy5qb2luKCIiKSsiXSIpLG5ldyBSZWdFeHAoYy5qb2luKCJ8IiksImciKX12YXIgTz0vKD86W1x4ODAtXHVEN0ZGXHVFMDAwLVx1RkZGRl18W1x1RDgwMC1cdURCRkZdW1x1REMwMC1cdURGRkZdfFtcdUQ4MDAtXHVEQkZGXSg/IVtcdURDMDAtXHVERkZGXSl8KD86W15cdUQ4MDAtXHVEQkZGXXxeKVtcdURDMDAtXHVERkZGXSkvZztmdW5jdGlvbiBtKFMpe3JldHVybiImI3giK1MuY29kZVBvaW50QXQoMCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkrIjsifWZ1bmN0aW9uIGIoUyxzKXtyZXR1cm4gZnVuY3Rpb24oYyl7cmV0dXJuIGMucmVwbGFjZShzLGZ1bmN0aW9uKGwpe3JldHVybiBTW2xdfSkucmVwbGFjZShPLG0pfX12YXIgTT1wKGYpO2Z1bmN0aW9uIHkoUyl7cmV0dXJuIFMucmVwbGFjZShNLG0pLnJlcGxhY2UoTyxtKX1lLmVzY2FwZT15fSxmdW5jdGlvbihnKXtnLmV4cG9ydHM9SlNPTi5wYXJzZSgneyJlbGVtZW50TmFtZXMiOnsiYWx0Z2x5cGgiOiJhbHRHbHlwaCIsImFsdGdseXBoZGVmIjoiYWx0R2x5cGhEZWYiLCJhbHRnbHlwaGl0ZW0iOiJhbHRHbHlwaEl0ZW0iLCJhbmltYXRlY29sb3IiOiJhbmltYXRlQ29sb3IiLCJhbmltYXRlbW90aW9uIjoiYW5pbWF0ZU1vdGlvbiIsImFuaW1hdGV0cmFuc2Zvcm0iOiJhbmltYXRlVHJhbnNmb3JtIiwiY2xpcHBhdGgiOiJjbGlwUGF0aCIsImZlYmxlbmQiOiJmZUJsZW5kIiwiZmVjb2xvcm1hdHJpeCI6ImZlQ29sb3JNYXRyaXgiLCJmZWNvbXBvbmVudHRyYW5zZmVyIjoiZmVDb21wb25lbnRUcmFuc2ZlciIsImZlY29tcG9zaXRlIjoiZmVDb21wb3NpdGUiLCJmZWNvbnZvbHZlbWF0cml4IjoiZmVDb252b2x2ZU1hdHJpeCIsImZlZGlmZnVzZWxpZ2h0aW5nIjoiZmVEaWZmdXNlTGlnaHRpbmciLCJmZWRpc3BsYWNlbWVudG1hcCI6ImZlRGlzcGxhY2VtZW50TWFwIiwiZmVkaXN0YW50bGlnaHQiOiJmZURpc3RhbnRMaWdodCIsImZlZHJvcHNoYWRvdyI6ImZlRHJvcFNoYWRvdyIsImZlZmxvb2QiOiJmZUZsb29kIiwiZmVmdW5jYSI6ImZlRnVuY0EiLCJmZWZ1bmNiIjoiZmVGdW5jQiIsImZlZnVuY2ciOiJmZUZ1bmNHIiwiZmVmdW5jciI6ImZlRnVuY1IiLCJmZWdhdXNzaWFuYmx1ciI6ImZlR2F1c3NpYW5CbHVyIiwiZmVpbWFnZSI6ImZlSW1hZ2UiLCJmZW1lcmdlIjoiZmVNZXJnZSIsImZlbWVyZ2Vub2RlIjoiZmVNZXJnZU5vZGUiLCJmZW1vcnBob2xvZ3kiOiJmZU1vcnBob2xvZ3kiLCJmZW9mZnNldCI6ImZlT2Zmc2V0IiwiZmVwb2ludGxpZ2h0IjoiZmVQb2ludExpZ2h0IiwiZmVzcGVjdWxhcmxpZ2h0aW5nIjoiZmVTcGVjdWxhckxpZ2h0aW5nIiwiZmVzcG90bGlnaHQiOiJmZVNwb3RMaWdodCIsImZldGlsZSI6ImZlVGlsZSIsImZldHVyYnVsZW5jZSI6ImZlVHVyYnVsZW5jZSIsImZvcmVpZ25vYmplY3QiOiJmb3JlaWduT2JqZWN0IiwiZ2x5cGhyZWYiOiJnbHlwaFJlZiIsImxpbmVhcmdyYWRpZW50IjoibGluZWFyR3JhZGllbnQiLCJyYWRpYWxncmFkaWVudCI6InJhZGlhbEdyYWRpZW50IiwidGV4dHBhdGgiOiJ0ZXh0UGF0aCJ9LCJhdHRyaWJ1dGVOYW1lcyI6eyJkZWZpbml0aW9udXJsIjoiZGVmaW5pdGlvblVSTCIsImF0dHJpYnV0ZW5hbWUiOiJhdHRyaWJ1dGVOYW1lIiwiYXR0cmlidXRldHlwZSI6ImF0dHJpYnV0ZVR5cGUiLCJiYXNlZnJlcXVlbmN5IjoiYmFzZUZyZXF1ZW5jeSIsImJhc2Vwcm9maWxlIjoiYmFzZVByb2ZpbGUiLCJjYWxjbW9kZSI6ImNhbGNNb2RlIiwiY2xpcHBhdGh1bml0cyI6ImNsaXBQYXRoVW5pdHMiLCJkaWZmdXNlY29uc3RhbnQiOiJkaWZmdXNlQ29uc3RhbnQiLCJlZGdlbW9kZSI6ImVkZ2VNb2RlIiwiZmlsdGVydW5pdHMiOiJmaWx0ZXJVbml0cyIsImdseXBocmVmIjoiZ2x5cGhSZWYiLCJncmFkaWVudHRyYW5zZm9ybSI6ImdyYWRpZW50VHJhbnNmb3JtIiwiZ3JhZGllbnR1bml0cyI6ImdyYWRpZW50VW5pdHMiLCJrZXJuZWxtYXRyaXgiOiJrZXJuZWxNYXRyaXgiLCJrZXJuZWx1bml0bGVuZ3RoIjoia2VybmVsVW5pdExlbmd0aCIsImtleXBvaW50cyI6ImtleVBvaW50cyIsImtleXNwbGluZXMiOiJrZXlTcGxpbmVzIiwia2V5dGltZXMiOiJrZXlUaW1lcyIsImxlbmd0aGFkanVzdCI6Imxlbmd0aEFkanVzdCIsImxpbWl0aW5nY29uZWFuZ2xlIjoibGltaXRpbmdDb25lQW5nbGUiLCJtYXJrZXJoZWlnaHQiOiJtYXJrZXJIZWlnaHQiLCJtYXJrZXJ1bml0cyI6Im1hcmtlclVuaXRzIiwibWFya2Vyd2lkdGgiOiJtYXJrZXJXaWR0aCIsIm1hc2tjb250ZW50dW5pdHMiOiJtYXNrQ29udGVudFVuaXRzIiwibWFza3VuaXRzIjoibWFza1VuaXRzIiwibnVtb2N0YXZlcyI6Im51bU9jdGF2ZXMiLCJwYXRobGVuZ3RoIjoicGF0aExlbmd0aCIsInBhdHRlcm5jb250ZW50dW5pdHMiOiJwYXR0ZXJuQ29udGVudFVuaXRzIiwicGF0dGVybnRyYW5zZm9ybSI6InBhdHRlcm5UcmFuc2Zvcm0iLCJwYXR0ZXJudW5pdHMiOiJwYXR0ZXJuVW5pdHMiLCJwb2ludHNhdHgiOiJwb2ludHNBdFgiLCJwb2ludHNhdHkiOiJwb2ludHNBdFkiLCJwb2ludHNhdHoiOiJwb2ludHNBdFoiLCJwcmVzZXJ2ZWFscGhhIjoicHJlc2VydmVBbHBoYSIsInByZXNlcnZlYXNwZWN0cmF0aW8iOiJwcmVzZXJ2ZUFzcGVjdFJhdGlvIiwicHJpbWl0aXZldW5pdHMiOiJwcmltaXRpdmVVbml0cyIsInJlZngiOiJyZWZYIiwicmVmeSI6InJlZlkiLCJyZXBlYXRjb3VudCI6InJlcGVhdENvdW50IiwicmVwZWF0ZHVyIjoicmVwZWF0RHVyIiwicmVxdWlyZWRleHRlbnNpb25zIjoicmVxdWlyZWRFeHRlbnNpb25zIiwicmVxdWlyZWRmZWF0dXJlcyI6InJlcXVpcmVkRmVhdHVyZXMiLCJzcGVjdWxhcmNvbnN0YW50Ijoic3BlY3VsYXJDb25zdGFudCIsInNwZWN1bGFyZXhwb25lbnQiOiJzcGVjdWxhckV4cG9uZW50Iiwic3ByZWFkbWV0aG9kIjoic3ByZWFkTWV0aG9kIiwic3RhcnRvZmZzZXQiOiJzdGFydE9mZnNldCIsInN0ZGRldmlhdGlvbiI6InN0ZERldmlhdGlvbiIsInN0aXRjaHRpbGVzIjoic3RpdGNoVGlsZXMiLCJzdXJmYWNlc2NhbGUiOiJzdXJmYWNlU2NhbGUiLCJzeXN0ZW1sYW5ndWFnZSI6InN5c3RlbUxhbmd1YWdlIiwidGFibGV2YWx1ZXMiOiJ0YWJsZVZhbHVlcyIsInRhcmdldHgiOiJ0YXJnZXRYIiwidGFyZ2V0eSI6InRhcmdldFkiLCJ0ZXh0bGVuZ3RoIjoidGV4dExlbmd0aCIsInZpZXdib3giOiJ2aWV3Qm94Iiwidmlld3RhcmdldCI6InZpZXdUYXJnZXQiLCJ4Y2hhbm5lbHNlbGVjdG9yIjoieENoYW5uZWxTZWxlY3RvciIsInljaGFubmVsc2VsZWN0b3IiOiJ5Q2hhbm5lbFNlbGVjdG9yIiwiem9vbWFuZHBhbiI6Inpvb21BbmRQYW4ifX0nKX0sZnVuY3Rpb24oZyxlKXt2YXIgdD1lLmdldENoaWxkcmVuPWZ1bmN0aW9uKGkpe3JldHVybiBpLmNoaWxkcmVufSxuPWUuZ2V0UGFyZW50PWZ1bmN0aW9uKGkpe3JldHVybiBpLnBhcmVudH07ZS5nZXRTaWJsaW5ncz1mdW5jdGlvbihpKXt2YXIgZj1uKGkpO3JldHVybiBmP3QoZik6W2ldfSxlLmdldEF0dHJpYnV0ZVZhbHVlPWZ1bmN0aW9uKGksZil7cmV0dXJuIGkuYXR0cmlicyYmaS5hdHRyaWJzW2ZdfSxlLmhhc0F0dHJpYj1mdW5jdGlvbihpLGYpe3JldHVybiEhaS5hdHRyaWJzJiZoYXNPd25Qcm9wZXJ0eS5jYWxsKGkuYXR0cmlicyxmKX0sZS5nZXROYW1lPWZ1bmN0aW9uKGkpe3JldHVybiBpLm5hbWV9fSxmdW5jdGlvbihnLGUpe2UucmVtb3ZlRWxlbWVudD1mdW5jdGlvbih0KXtpZih0LnByZXYmJih0LnByZXYubmV4dD10Lm5leHQpLHQubmV4dCYmKHQubmV4dC5wcmV2PXQucHJldiksdC5wYXJlbnQpe3ZhciBuPXQucGFyZW50LmNoaWxkcmVuO24uc3BsaWNlKG4ubGFzdEluZGV4T2YodCksMSl9fSxlLnJlcGxhY2VFbGVtZW50PWZ1bmN0aW9uKHQsbil7dmFyIGk9bi5wcmV2PXQucHJldjtpJiYoaS5uZXh0PW4pO3ZhciBmPW4ubmV4dD10Lm5leHQ7ZiYmKGYucHJldj1uKTt2YXIgaD1uLnBhcmVudD10LnBhcmVudDtpZihoKXt2YXIgdT1oLmNoaWxkcmVuO3VbdS5sYXN0SW5kZXhPZih0KV09bn19LGUuYXBwZW5kQ2hpbGQ9ZnVuY3Rpb24odCxuKXtpZihuLnBhcmVudD10LHQuY2hpbGRyZW4ucHVzaChuKSE9PTEpe3ZhciBpPXQuY2hpbGRyZW5bdC5jaGlsZHJlbi5sZW5ndGgtMl07aS5uZXh0PW4sbi5wcmV2PWksbi5uZXh0PW51bGx9fSxlLmFwcGVuZD1mdW5jdGlvbih0LG4pe3ZhciBpPXQucGFyZW50LGY9dC5uZXh0O2lmKG4ubmV4dD1mLG4ucHJldj10LHQubmV4dD1uLG4ucGFyZW50PWksZil7aWYoZi5wcmV2PW4saSl7dmFyIGg9aS5jaGlsZHJlbjtoLnNwbGljZShoLmxhc3RJbmRleE9mKGYpLDAsbil9fWVsc2UgaSYmaS5jaGlsZHJlbi5wdXNoKG4pfSxlLnByZXBlbmQ9ZnVuY3Rpb24odCxuKXt2YXIgaT10LnBhcmVudDtpZihpKXt2YXIgZj1pLmNoaWxkcmVuO2Yuc3BsaWNlKGYubGFzdEluZGV4T2YodCksMCxuKX10LnByZXYmJih0LnByZXYubmV4dD1uKSxuLnBhcmVudD1pLG4ucHJldj10LnByZXYsbi5uZXh0PXQsdC5wcmV2PW59fSxmdW5jdGlvbihnLGUsdCl7dmFyIG49dCgyNTYpLmlzVGFnO2cuZXhwb3J0cz17ZmlsdGVyOmksZmluZDpmLGZpbmRPbmVDaGlsZDpoLGZpbmRPbmU6dSxleGlzdHNPbmU6YSxmaW5kQWxsOmR9O2Z1bmN0aW9uIGkoRSxwLE8sbSl7cmV0dXJuIEFycmF5LmlzQXJyYXkocCl8fChwPVtwXSksKHR5cGVvZiBtIT0ibnVtYmVyInx8IWlzRmluaXRlKG0pKSYmKG09MS8wKSxmKEUscCxPIT09ITEsbSl9ZnVuY3Rpb24gZihFLHAsTyxtKXtmb3IodmFyIGI9W10sTSx5PTAsUz1wLmxlbmd0aDt5PFMmJiEoRShwW3ldKSYmKGIucHVzaChwW3ldKSwtLW08PTApfHwoTT1wW3ldLmNoaWxkcmVuLE8mJk0mJk0ubGVuZ3RoPjAmJihNPWYoRSxNLE8sbSksYj1iLmNvbmNhdChNKSxtLT1NLmxlbmd0aCxtPD0wKSkpO3krKyk7cmV0dXJuIGJ9ZnVuY3Rpb24gaChFLHApe2Zvcih2YXIgTz0wLG09cC5sZW5ndGg7TzxtO08rKylpZihFKHBbT10pKXJldHVybiBwW09dO3JldHVybiBudWxsfWZ1bmN0aW9uIHUoRSxwKXtmb3IodmFyIE89bnVsbCxtPTAsYj1wLmxlbmd0aDttPGImJiFPO20rKylpZihuKHBbbV0pKUUocFttXSk/Tz1wW21dOnBbbV0uY2hpbGRyZW4ubGVuZ3RoPjAmJihPPXUoRSxwW21dLmNoaWxkcmVuKSk7ZWxzZSBjb250aW51ZTtyZXR1cm4gT31mdW5jdGlvbiBhKEUscCl7Zm9yKHZhciBPPTAsbT1wLmxlbmd0aDtPPG07TysrKWlmKG4ocFtPXSkmJihFKHBbT10pfHxwW09dLmNoaWxkcmVuLmxlbmd0aD4wJiZhKEUscFtPXS5jaGlsZHJlbikpKXJldHVybiEwO3JldHVybiExfWZ1bmN0aW9uIGQoRSxwKXtmb3IodmFyIE89W10sbT1wLnNsaWNlKCk7bS5sZW5ndGg7KXt2YXIgYj1tLnNoaWZ0KCk7bihiKSYmKGIuY2hpbGRyZW4mJmIuY2hpbGRyZW4ubGVuZ3RoPjAmJm0udW5zaGlmdC5hcHBseShtLGIuY2hpbGRyZW4pLEUoYikmJk8ucHVzaChiKSl9cmV0dXJuIE99fSxmdW5jdGlvbihnLGUsdCl7dmFyIG49dCgyNTYpLGk9ZS5pc1RhZz1uLmlzVGFnO2UudGVzdEVsZW1lbnQ9ZnVuY3Rpb24oYSxkKXtmb3IodmFyIEUgaW4gYSlpZihhLmhhc093blByb3BlcnR5KEUpKXtpZihFPT09InRhZ19uYW1lIil7aWYoIWkoZCl8fCFhLnRhZ19uYW1lKGQubmFtZSkpcmV0dXJuITF9ZWxzZSBpZihFPT09InRhZ190eXBlIil7aWYoIWEudGFnX3R5cGUoZC50eXBlKSlyZXR1cm4hMX1lbHNlIGlmKEU9PT0idGFnX2NvbnRhaW5zIil7aWYoaShkKXx8IWEudGFnX2NvbnRhaW5zKGQuZGF0YSkpcmV0dXJuITF9ZWxzZSBpZighZC5hdHRyaWJzfHwhYVtFXShkLmF0dHJpYnNbRV0pKXJldHVybiExfXJldHVybiEwfTt2YXIgZj17dGFnX25hbWU6ZnVuY3Rpb24oYSl7cmV0dXJuIHR5cGVvZiBhPT0iZnVuY3Rpb24iP2Z1bmN0aW9uKGQpe3JldHVybiBpKGQpJiZhKGQubmFtZSl9OmE9PT0iKiI/aTpmdW5jdGlvbihkKXtyZXR1cm4gaShkKSYmZC5uYW1lPT09YX19LHRhZ190eXBlOmZ1bmN0aW9uKGEpe3JldHVybiB0eXBlb2YgYT09ImZ1bmN0aW9uIj9mdW5jdGlvbihkKXtyZXR1cm4gYShkLnR5cGUpfTpmdW5jdGlvbihkKXtyZXR1cm4gZC50eXBlPT09YX19LHRhZ19jb250YWluczpmdW5jdGlvbihhKXtyZXR1cm4gdHlwZW9mIGE9PSJmdW5jdGlvbiI/ZnVuY3Rpb24oZCl7cmV0dXJuIWkoZCkmJmEoZC5kYXRhKX06ZnVuY3Rpb24oZCl7cmV0dXJuIWkoZCkmJmQuZGF0YT09PWF9fX07ZnVuY3Rpb24gaChhLGQpe3JldHVybiB0eXBlb2YgZD09ImZ1bmN0aW9uIj9mdW5jdGlvbihFKXtyZXR1cm4gRS5hdHRyaWJzJiZkKEUuYXR0cmlic1thXSl9OmZ1bmN0aW9uKEUpe3JldHVybiBFLmF0dHJpYnMmJkUuYXR0cmlic1thXT09PWR9fWZ1bmN0aW9uIHUoYSxkKXtyZXR1cm4gZnVuY3Rpb24oRSl7cmV0dXJuIGEoRSl8fGQoRSl9fWUuZ2V0RWxlbWVudHM9ZnVuY3Rpb24oYSxkLEUscCl7dmFyIE89T2JqZWN0LmtleXMoYSkubWFwKGZ1bmN0aW9uKG0pe3ZhciBiPWFbbV07cmV0dXJuIG0gaW4gZj9mW21dKGIpOmgobSxiKX0pO3JldHVybiBPLmxlbmd0aD09PTA/W106dGhpcy5maWx0ZXIoTy5yZWR1Y2UodSksZCxFLHApfSxlLmdldEVsZW1lbnRCeUlkPWZ1bmN0aW9uKGEsZCxFKXtyZXR1cm4gQXJyYXkuaXNBcnJheShkKXx8KGQ9W2RdKSx0aGlzLmZpbmRPbmUoaCgiaWQiLGEpLGQsRSE9PSExKX0sZS5nZXRFbGVtZW50c0J5VGFnTmFtZT1mdW5jdGlvbihhLGQsRSxwKXtyZXR1cm4gdGhpcy5maWx0ZXIoZi50YWdfbmFtZShhKSxkLEUscCl9LGUuZ2V0RWxlbWVudHNCeVRhZ1R5cGU9ZnVuY3Rpb24oYSxkLEUscCl7cmV0dXJuIHRoaXMuZmlsdGVyKGYudGFnX3R5cGUoYSksZCxFLHApfX0sZnVuY3Rpb24oZyxlKXtlLnJlbW92ZVN1YnNldHM9ZnVuY3Rpb24oaSl7Zm9yKHZhciBmPWkubGVuZ3RoLGgsdSxhOy0tZj4tMTspe2ZvcihoPXU9aVtmXSxpW2ZdPW51bGwsYT0hMDt1Oyl7aWYoaS5pbmRleE9mKHUpPi0xKXthPSExLGkuc3BsaWNlKGYsMSk7YnJlYWt9dT11LnBhcmVudH1hJiYoaVtmXT1oKX1yZXR1cm4gaX07dmFyIHQ9e0RJU0NPTk5FQ1RFRDoxLFBSRUNFRElORzoyLEZPTExPV0lORzo0LENPTlRBSU5TOjgsQ09OVEFJTkVEX0JZOjE2fSxuPWUuY29tcGFyZURvY3VtZW50UG9zaXRpb249ZnVuY3Rpb24oaSxmKXt2YXIgaD1bXSx1PVtdLGEsZCxFLHAsTyxtO2lmKGk9PT1mKXJldHVybiAwO2ZvcihhPWk7YTspaC51bnNoaWZ0KGEpLGE9YS5wYXJlbnQ7Zm9yKGE9ZjthOyl1LnVuc2hpZnQoYSksYT1hLnBhcmVudDtmb3IobT0wO2hbbV09PT11W21dOyltKys7cmV0dXJuIG09PT0wP3QuRElTQ09OTkVDVEVEOihkPWhbbS0xXSxFPWQuY2hpbGRyZW4scD1oW21dLE89dVttXSxFLmluZGV4T2YocCk+RS5pbmRleE9mKE8pP2Q9PT1mP3QuRk9MTE9XSU5HfHQuQ09OVEFJTkVEX0JZOnQuRk9MTE9XSU5HOmQ9PT1pP3QuUFJFQ0VESU5HfHQuQ09OVEFJTlM6dC5QUkVDRURJTkcpfTtlLnVuaXF1ZVNvcnQ9ZnVuY3Rpb24oaSl7dmFyIGY9aS5sZW5ndGgsaCx1O2ZvcihpPWkuc2xpY2UoKTstLWY+LTE7KWg9aVtmXSx1PWkuaW5kZXhPZihoKSx1Pi0xJiZ1PGYmJmkuc3BsaWNlKGYsMSk7cmV0dXJuIGkuc29ydChmdW5jdGlvbihhLGQpe3ZhciBFPW4oYSxkKTtyZXR1cm4gRSZ0LlBSRUNFRElORz8tMTpFJnQuRk9MTE9XSU5HPzE6MH0pLGl9fSxmdW5jdGlvbihnLGUpe2cuZXhwb3J0cz17dHJ1ZUZ1bmM6ZnVuY3Rpb24oKXtyZXR1cm4hMH0sZmFsc2VGdW5jOmZ1bmN0aW9uKCl7cmV0dXJuITF9fX0sZnVuY3Rpb24oZyxlLHQpe2cuZXhwb3J0cz1PO3ZhciBuPXQoMjc1KS5wYXJzZSxpPXQoMjczKSxmPXQoMjc4KSxoPXQoMjc5KSx1PXQoMjgwKSxhPXQoMjgyKSxkPWkudHJ1ZUZ1bmMsRT1pLmZhbHNlRnVuYyxwPWEuZmlsdGVycztmdW5jdGlvbiBPKEEsdyxCKXt2YXIgRD1iKEEsdyxCKTtyZXR1cm4gbShELHcpfWZ1bmN0aW9uIG0oQSx3KXt2YXIgQj13LmFkYXB0ZXI7cmV0dXJuIGZ1bmN0aW9uKEkpe3JldHVybiBCLmlzVGFnKEkpJiZBKEkpfX1mdW5jdGlvbiBiKEEsdyxCKXt2YXIgRD1uKEEsdyk7cmV0dXJuIHYoRCx3LEIpfWZ1bmN0aW9uIE0oQSl7cmV0dXJuIEEudHlwZT09PSJwc2V1ZG8iJiYoQS5uYW1lPT09InNjb3BlInx8QXJyYXkuaXNBcnJheShBLmRhdGEpJiZBLmRhdGEuc29tZShmdW5jdGlvbih3KXtyZXR1cm4gdy5zb21lKE0pfSkpfXZhciB5PXt0eXBlOiJkZXNjZW5kYW50In0sUz17dHlwZToiX2ZsZXhpYmxlRGVzY2VuZGFudCJ9LHM9e3R5cGU6InBzZXVkbyIsbmFtZToic2NvcGUifSxjPXt9O2Z1bmN0aW9uIGwoQSx3LEIpe3ZhciBEPXcuYWRhcHRlcixJPSEhQiYmISFCLmxlbmd0aCYmQi5ldmVyeShmdW5jdGlvbihqKXtyZXR1cm4gaj09PWN8fCEhRC5nZXRQYXJlbnQoail9KTtBLmZvckVhY2goZnVuY3Rpb24oail7aWYoIShqLmxlbmd0aD4wJiZUKGpbMF0pJiZqWzBdLnR5cGUhPT0iZGVzY2VuZGFudCIpKWlmKEkmJiEoQXJyYXkuaXNBcnJheShqKT9qLnNvbWUoTSk6TShqKSkpai51bnNoaWZ0KHkpO2Vsc2UgcmV0dXJuO2oudW5zaGlmdChzKX0pfWZ1bmN0aW9uIHYoQSx3LEIpe0E9QS5maWx0ZXIoZnVuY3Rpb24oVil7cmV0dXJuIFYubGVuZ3RoPjB9KSxBLmZvckVhY2goZik7dmFyIEQ9QXJyYXkuaXNBcnJheShCKTtCPXcmJncuY29udGV4dHx8QixCJiYhRCYmKEI9W0JdKSxsKEEsdyxCKTt2YXIgST0hMSxqPUEubWFwKGZ1bmN0aW9uKFYpe2lmKFZbMF0mJlZbMV0mJlZbMF0ubmFtZT09PSJzY29wZSIpe3ZhciBKPVZbMV0udHlwZTtEJiZKPT09ImRlc2NlbmRhbnQiP1ZbMV09UzooSj09PSJhZGphY2VudCJ8fEo9PT0ic2libGluZyIpJiYoST0hMCl9cmV0dXJuIFIoVix3LEIpfSkucmVkdWNlKEwsRSk7cmV0dXJuIGouc2hvdWxkVGVzdE5leHRTaWJsaW5ncz1JLGp9ZnVuY3Rpb24gVChBKXtyZXR1cm4gaFtBLnR5cGVdPDB9ZnVuY3Rpb24gUihBLHcsQil7cmV0dXJuIEEucmVkdWNlKGZ1bmN0aW9uKEQsSSl7aWYoRD09PUUpcmV0dXJuIEQ7aWYoIShJLnR5cGUgaW4gdSkpdGhyb3cgbmV3IEVycm9yKCJSdWxlIHR5cGUgIitJLnR5cGUrIiBpcyBub3Qgc3VwcG9ydGVkIGJ5IGNzcy1zZWxlY3QiKTtyZXR1cm4gdVtJLnR5cGVdKEQsSSx3LEIpfSx3JiZ3LnJvb3RGdW5jfHxkKX1mdW5jdGlvbiBMKEEsdyl7cmV0dXJuIHc9PT1FfHxBPT09ZD9BOkE9PT1FfHx3PT09ZD93OmZ1bmN0aW9uKEQpe3JldHVybiBBKEQpfHx3KEQpfX1mdW5jdGlvbiBOKEEpe3JldHVybiBBLnNvbWUoVCl9cC5ub3Q9ZnVuY3Rpb24oQSx3LEIsRCl7dmFyIEk9e3htbE1vZGU6ISEoQiYmQi54bWxNb2RlKSxzdHJpY3Q6ISEoQiYmQi5zdHJpY3QpLGFkYXB0ZXI6Qi5hZGFwdGVyfTtpZihJLnN0cmljdCYmKHcubGVuZ3RoPjF8fHcuc29tZShOKSkpdGhyb3cgbmV3IEVycm9yKCJjb21wbGV4IHNlbGVjdG9ycyBpbiA6bm90IGFyZW4ndCBhbGxvd2VkIGluIHN0cmljdCBtb2RlIik7dmFyIGo9dih3LEksRCk7cmV0dXJuIGo9PT1FP0E6aj09PWQ/RTpmdW5jdGlvbihKKXtyZXR1cm4haihKKSYmQShKKX19LHAuaGFzPWZ1bmN0aW9uKEEsdyxCKXt2YXIgRD1CLmFkYXB0ZXIsST17eG1sTW9kZTohIShCJiZCLnhtbE1vZGUpLHN0cmljdDohIShCJiZCLnN0cmljdCksYWRhcHRlcjpEfSxqPXcuc29tZShOKT9bY106bnVsbCxWPXYodyxJLGopO3JldHVybiBWPT09RT9FOlY9PT1kP2Z1bmN0aW9uKF8pe3JldHVybiBELmdldENoaWxkcmVuKF8pLnNvbWUoRC5pc1RhZykmJkEoXyl9OihWPW0oVixCKSxqP2Z1bmN0aW9uKF8pe3JldHVybiBBKF8pJiYoalswXT1fLEQuZXhpc3RzT25lKFYsRC5nZXRDaGlsZHJlbihfKSkpfTpmdW5jdGlvbihfKXtyZXR1cm4gQShfKSYmRC5leGlzdHNPbmUoVixELmdldENoaWxkcmVuKF8pKX0pfSxwLm1hdGNoZXM9ZnVuY3Rpb24oQSx3LEIsRCl7dmFyIEk9e3htbE1vZGU6ISEoQiYmQi54bWxNb2RlKSxzdHJpY3Q6ISEoQiYmQi5zdHJpY3QpLHJvb3RGdW5jOkEsYWRhcHRlcjpCLmFkYXB0ZXJ9O3JldHVybiB2KHcsSSxEKX0sTy5jb21waWxlVG9rZW49dixPLmNvbXBpbGVVbnNhZmU9YixPLlBzZXVkb3M9YX0sZnVuY3Rpb24oZyxlLHQpe3ZhciBuPXRoaXMmJnRoaXMuX19jcmVhdGVCaW5kaW5nfHwoT2JqZWN0LmNyZWF0ZT9mdW5jdGlvbih1LGEsZCxFKXtFPT09dm9pZCAwJiYoRT1kKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodSxFLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBhW2RdfX0pfTpmdW5jdGlvbih1LGEsZCxFKXtFPT09dm9pZCAwJiYoRT1kKSx1W0VdPWFbZF19KSxpPXRoaXMmJnRoaXMuX19leHBvcnRTdGFyfHxmdW5jdGlvbih1LGEpe2Zvcih2YXIgZCBpbiB1KWQhPT0iZGVmYXVsdCImJiFhLmhhc093blByb3BlcnR5KGQpJiZuKGEsdSxkKX07T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLGkodCgyNzYpLGUpO3ZhciBmPXQoMjc2KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwicGFyc2UiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBmLmRlZmF1bHR9fSk7dmFyIGg9dCgyNzcpO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJzdHJpbmdpZnkiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBoLmRlZmF1bHR9fSl9LGZ1bmN0aW9uKGcsZSx0KXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksZS5kZWZhdWx0PU07dmFyIG49L15bXlxcXT8oPzpcXCg/OltcZGEtZl17MSw2fVxzP3wuKXxbXHdcLVx1MDBiMC1cdUZGRkZdKSsvLGk9L1xcKFtcZGEtZl17MSw2fVxzP3woXHMpfC4pL2dpLGY9L15ccyooKD86XFwufFtcd1x1MDBiMC1cdUZGRkYtXSkrKVxzKig/OihcUz8pPVxzKig/OihbJyJdKShbXl0qPylcM3woIz8oPzpcXC58W1x3XHUwMGIwLVx1RkZGRi1dKSopfCl8KVxzKihpKT9cXS8saD17dW5kZWZpbmVkOiJleGlzdHMiLCIiOiJlcXVhbHMiLCJ+IjoiZWxlbWVudCIsIl4iOiJzdGFydCIsJDoiZW5kIiwiKiI6ImFueSIsIiEiOiJub3QiLCJ8IjoiaHlwaGVuIn0sdT17Ij4iOiJjaGlsZCIsIjwiOiJwYXJlbnQiLCJ+Ijoic2libGluZyIsIisiOiJhZGphY2VudCJ9LGE9eyIjIjpbImlkIiwiZXF1YWxzIl0sIi4iOlsiY2xhc3MiLCJlbGVtZW50Il19LGQ9bmV3IFNldChbImhhcyIsIm5vdCIsIm1hdGNoZXMiXSksRT1uZXcgU2V0KFsiY29udGFpbnMiLCJpY29udGFpbnMiXSkscD1uZXcgU2V0KFsnIicsIiciXSk7ZnVuY3Rpb24gTyhzLGMsbCl7dmFyIHY9cGFyc2VJbnQoYywxNiktNjU1MzY7cmV0dXJuIHYhPT12fHxsP2M6djwwP1N0cmluZy5mcm9tQ2hhckNvZGUodis2NTUzNik6U3RyaW5nLmZyb21DaGFyQ29kZSh2Pj4xMHw1NTI5Nix2JjEwMjN8NTYzMjApfWZ1bmN0aW9uIG0ocyl7cmV0dXJuIHMucmVwbGFjZShpLE8pfWZ1bmN0aW9uIGIocyl7cmV0dXJuIHM9PT0iICJ8fHM9PT1gCmB8fHM9PT0iCSJ8fHM9PT0iXGYifHxzPT09IlxyIn1mdW5jdGlvbiBNKHMsYyl7dmFyIGw9W107aWYocz15KGwsIiIrcyxjKSxzIT09IiIpdGhyb3cgbmV3IEVycm9yKCJVbm1hdGNoZWQgc2VsZWN0b3I6ICIrcyk7cmV0dXJuIGx9ZnVuY3Rpb24geShzLGMsbCl7dmFyIHY9W10sVD0hMTtmdW5jdGlvbiBSKCl7dmFyIHJ0PWMubWF0Y2gobik7aWYoIXJ0KXRocm93IG5ldyBFcnJvcigiRXhwZWN0ZWQgbmFtZSwgZm91bmQgIitjKTt2YXIgb3Q9cnRbMF07cmV0dXJuIGM9Yy5zdWJzdHIob3QubGVuZ3RoKSxtKG90KX1mdW5jdGlvbiBMKHJ0KXtmb3IoO2IoYy5jaGFyQXQocnQpKTspcnQrKztjPWMuc3Vic3RyKHJ0KX1mdW5jdGlvbiBOKHJ0KXtmb3IodmFyIG90PTA7Yy5jaGFyQXQoLS1ydCk9PT0iXFwiOylvdCsrO3JldHVybihvdCYxKT09PTF9Zm9yKEwoMCk7YyE9PSIiOyl7dmFyIEE9Yy5jaGFyQXQoMCk7aWYoYihBKSlUPSEwLEwoMSk7ZWxzZSBpZihBIGluIHUpdi5wdXNoKHt0eXBlOnVbQV19KSxUPSExLEwoMSk7ZWxzZSBpZihBPT09IiwiKXtpZih2Lmxlbmd0aD09PTApdGhyb3cgbmV3IEVycm9yKCJFbXB0eSBzdWItc2VsZWN0b3IiKTtzLnB1c2godiksdj1bXSxUPSExLEwoMSl9ZWxzZSBpZihUJiYodi5sZW5ndGg+MCYmdi5wdXNoKHt0eXBlOiJkZXNjZW5kYW50In0pLFQ9ITEpLEE9PT0iKiIpYz1jLnN1YnN0cigxKSx2LnB1c2goe3R5cGU6InVuaXZlcnNhbCJ9KTtlbHNlIGlmKEEgaW4gYSl7dmFyIHc9YVtBXSxCPXdbMF0sRD13WzFdO2M9Yy5zdWJzdHIoMSksdi5wdXNoKHt0eXBlOiJhdHRyaWJ1dGUiLG5hbWU6QixhY3Rpb246RCx2YWx1ZTpSKCksaWdub3JlQ2FzZTohMX0pfWVsc2UgaWYoQT09PSJbIil7Yz1jLnN1YnN0cigxKTt2YXIgST1jLm1hdGNoKGYpO2lmKCFJKXRocm93IG5ldyBFcnJvcigiTWFsZm9ybWVkIGF0dHJpYnV0ZSBzZWxlY3RvcjogIitjKTtjPWMuc3Vic3RyKElbMF0ubGVuZ3RoKTt2YXIgaj1tKElbMV0pOyghbHx8KCJsb3dlckNhc2VBdHRyaWJ1dGVOYW1lcyJpbiBsP2wubG93ZXJDYXNlQXR0cmlidXRlTmFtZXM6IWwueG1sTW9kZSkpJiYoaj1qLnRvTG93ZXJDYXNlKCkpLHYucHVzaCh7dHlwZToiYXR0cmlidXRlIixuYW1lOmosYWN0aW9uOmhbSVsyXV0sdmFsdWU6bShJWzRdfHxJWzVdfHwiIiksaWdub3JlQ2FzZTohIUlbNl19KX1lbHNlIGlmKEE9PT0iOiIpe2lmKGMuY2hhckF0KDEpPT09IjoiKXtjPWMuc3Vic3RyKDIpLHYucHVzaCh7dHlwZToicHNldWRvLWVsZW1lbnQiLG5hbWU6UigpLnRvTG93ZXJDYXNlKCl9KTtjb250aW51ZX1jPWMuc3Vic3RyKDEpO3ZhciBWPVIoKS50b0xvd2VyQ2FzZSgpLEk9bnVsbDtpZihjLmNoYXJBdCgwKT09PSIoIilpZihkLmhhcyhWKSl7dmFyIEo9Yy5jaGFyQXQoMSksXz1wLmhhcyhKKTtpZihjPWMuc3Vic3RyKF8/MjoxKSxJPVtdLGM9eShJLGMsbCksXyl7aWYoYy5jaGFyQXQoMCkhPT1KKXRocm93IG5ldyBFcnJvcigiVW5tYXRjaGVkIHF1b3RlcyBpbiA6IitWKTtjPWMuc3Vic3RyKDEpfWlmKGMuY2hhckF0KDApIT09IikiKXRocm93IG5ldyBFcnJvcigiTWlzc2luZyBjbG9zaW5nIHBhcmVudGhlc2lzIGluIDoiK1YrIiAoIitjKyIpIik7Yz1jLnN1YnN0cigxKX1lbHNle2Zvcih2YXIgc3Q9MSxHPTE7Rz4wJiZzdDxjLmxlbmd0aDtzdCsrKWMuY2hhckF0KHN0KT09PSIoIiYmIU4oc3QpP0crKzpjLmNoYXJBdChzdCk9PT0iKSImJiFOKHN0KSYmRy0tO2lmKEcpdGhyb3cgbmV3IEVycm9yKCJQYXJlbnRoZXNpcyBub3QgbWF0Y2hlZCIpO2lmKEk9Yy5zdWJzdHIoMSxzdC0yKSxjPWMuc3Vic3RyKHN0KSxFLmhhcyhWKSl7dmFyIEo9SS5jaGFyQXQoMCk7Sj09PUkuc2xpY2UoLTEpJiZwLmhhcyhKKSYmKEk9SS5zbGljZSgxLC0xKSksST1tKEkpfX12LnB1c2goe3R5cGU6InBzZXVkbyIsbmFtZTpWLGRhdGE6SX0pfWVsc2UgaWYobi50ZXN0KGMpKXt2YXIgWT1SKCk7KCFsfHwoImxvd2VyQ2FzZVRhZ3MiaW4gbD9sLmxvd2VyQ2FzZVRhZ3M6IWwueG1sTW9kZSkpJiYoWT1ZLnRvTG93ZXJDYXNlKCkpLHYucHVzaCh7dHlwZToidGFnIixuYW1lOll9KX1lbHNlIHJldHVybiB2Lmxlbmd0aCYmdlt2Lmxlbmd0aC0xXS50eXBlPT09ImRlc2NlbmRhbnQiJiZ2LnBvcCgpLFMocyx2KSxjfXJldHVybiBTKHMsdiksY31mdW5jdGlvbiBTKHMsYyl7aWYocy5sZW5ndGg+MCYmYy5sZW5ndGg9PT0wKXRocm93IG5ldyBFcnJvcigiRW1wdHkgc3ViLXNlbGVjdG9yIik7cy5wdXNoKGMpfX0sZnVuY3Rpb24oZyxlLHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KTt2YXIgbj17ZXF1YWxzOiIiLGVsZW1lbnQ6In4iLHN0YXJ0OiJeIixlbmQ6IiQiLGFueToiKiIsbm90OiIhIixoeXBoZW46InwifTtmdW5jdGlvbiBpKGEpe3JldHVybiBhLm1hcChmKS5qb2luKCIsICIpfWUuZGVmYXVsdD1pO2Z1bmN0aW9uIGYoYSl7cmV0dXJuIGEubWFwKGgpLmpvaW4oIiIpfWZ1bmN0aW9uIGgoYSl7c3dpdGNoKGEudHlwZSl7Y2FzZSJjaGlsZCI6cmV0dXJuIiA+ICI7Y2FzZSJwYXJlbnQiOnJldHVybiIgPCAiO2Nhc2Uic2libGluZyI6cmV0dXJuIiB+ICI7Y2FzZSJhZGphY2VudCI6cmV0dXJuIiArICI7Y2FzZSJkZXNjZW5kYW50IjpyZXR1cm4iICI7Y2FzZSJ1bml2ZXJzYWwiOnJldHVybiIqIjtjYXNlInRhZyI6cmV0dXJuIGEubmFtZTtjYXNlInBzZXVkby1lbGVtZW50IjpyZXR1cm4iOjoiK2EubmFtZTtjYXNlInBzZXVkbyI6cmV0dXJuIGEuZGF0YT09PW51bGw/IjoiK2EubmFtZTp0eXBlb2YgYS5kYXRhPT0ic3RyaW5nIj8iOiIrYS5uYW1lKyIoIithLmRhdGErIikiOiI6IithLm5hbWUrIigiK2koYS5kYXRhKSsiKSI7Y2FzZSJhdHRyaWJ1dGUiOnJldHVybiBhLmFjdGlvbj09PSJleGlzdHMiPyJbIithLm5hbWUrIl0iOmEubmFtZT09PSJpZCImJmEuYWN0aW9uPT09ImVxdWFscyImJiFhLmlnbm9yZUNhc2U/IiMiK2EudmFsdWU6YS5uYW1lPT09ImNsYXNzIiYmYS5hY3Rpb249PT0iZWxlbWVudCImJiFhLmlnbm9yZUNhc2U/Ii4iK2EudmFsdWU6IlsiK2EubmFtZStuW2EuYWN0aW9uXSsiPSciK2EudmFsdWUrIiciKyhhLmlnbm9yZUNhc2U/ImkiOiIiKSsiXSI7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoIlVua25vd24gdHlwZSIpfX1mdW5jdGlvbiB1KGEpe3JldHVybiBhfX0sZnVuY3Rpb24oZyxlLHQpe2cuZXhwb3J0cz1mO3ZhciBuPXQoMjc5KSxpPXtfX3Byb3RvX186bnVsbCxleGlzdHM6MTAsZXF1YWxzOjgsbm90Ojcsc3RhcnQ6NixlbmQ6Nixhbnk6NSxoeXBoZW46NCxlbGVtZW50OjR9O2Z1bmN0aW9uIGYodSl7Zm9yKHZhciBhPXUubWFwKGgpLGQ9MTtkPHUubGVuZ3RoO2QrKyl7dmFyIEU9YVtkXTtpZighKEU8MCkpZm9yKHZhciBwPWQtMTtwPj0wJiZFPGFbcF07cC0tKXt2YXIgTz11W3ArMV07dVtwKzFdPXVbcF0sdVtwXT1PLGFbcCsxXT1hW3BdLGFbcF09RX19fWZ1bmN0aW9uIGgodSl7dmFyIGE9blt1LnR5cGVdO2lmKGE9PT1uLmF0dHJpYnV0ZSlhPWlbdS5hY3Rpb25dLGE9PT1pLmVxdWFscyYmdS5uYW1lPT09ImlkIiYmKGE9OSksdS5pZ25vcmVDYXNlJiYoYT4+PTEpO2Vsc2UgaWYoYT09PW4ucHNldWRvKWlmKCF1LmRhdGEpYT0zO2Vsc2UgaWYodS5uYW1lPT09ImhhcyJ8fHUubmFtZT09PSJjb250YWlucyIpYT0wO2Vsc2UgaWYodS5uYW1lPT09Im1hdGNoZXMifHx1Lm5hbWU9PT0ibm90Iil7YT0wO2Zvcih2YXIgZD0wO2Q8dS5kYXRhLmxlbmd0aDtkKyspaWYodS5kYXRhW2RdLmxlbmd0aD09PTEpe3ZhciBFPWgodS5kYXRhW2RdWzBdKTtpZihFPT09MCl7YT0wO2JyZWFrfUU+YSYmKGE9RSl9dS5kYXRhLmxlbmd0aD4xJiZhPjAmJihhLT0xKX1lbHNlIGE9MTtyZXR1cm4gYX19LGZ1bmN0aW9uKGcpe2cuZXhwb3J0cz1KU09OLnBhcnNlKCd7InVuaXZlcnNhbCI6NTAsInRhZyI6MzAsImF0dHJpYnV0ZSI6MSwicHNldWRvIjowLCJkZXNjZW5kYW50IjotMSwiY2hpbGQiOi0xLCJwYXJlbnQiOi0xLCJzaWJsaW5nIjotMSwiYWRqYWNlbnQiOi0xfScpfSxmdW5jdGlvbihnLGUsdCl7dmFyIG49dCgyODEpLGk9dCgyODIpO2cuZXhwb3J0cz17X19wcm90b19fOm51bGwsYXR0cmlidXRlOm4uY29tcGlsZSxwc2V1ZG86aS5jb21waWxlLHRhZzpmdW5jdGlvbihmLGgsdSl7dmFyIGE9aC5uYW1lLGQ9dS5hZGFwdGVyO3JldHVybiBmdW5jdGlvbihwKXtyZXR1cm4gZC5nZXROYW1lKHApPT09YSYmZihwKX19LGRlc2NlbmRhbnQ6ZnVuY3Rpb24oZixoLHUpe3ZhciBhPXR5cGVvZiBXZWFrU2V0PCJ1Ij9uZXcgV2Vha1NldDpudWxsLGQ9dS5hZGFwdGVyO3JldHVybiBmdW5jdGlvbihwKXtmb3IodmFyIE89ITE7IU8mJihwPWQuZ2V0UGFyZW50KHApKTspKCFhfHwhYS5oYXMocCkpJiYoTz1mKHApLCFPJiZhJiZhLmFkZChwKSk7cmV0dXJuIE99fSxfZmxleGlibGVEZXNjZW5kYW50OmZ1bmN0aW9uKGYsaCx1KXt2YXIgYT11LmFkYXB0ZXI7cmV0dXJuIGZ1bmN0aW9uKEUpe2Zvcih2YXIgcD1mKEUpOyFwJiYoRT1hLmdldFBhcmVudChFKSk7KXA9ZihFKTtyZXR1cm4gcH19LHBhcmVudDpmdW5jdGlvbihmLGgsdSl7aWYodSYmdS5zdHJpY3QpdGhyb3cgbmV3IEVycm9yKCJQYXJlbnQgc2VsZWN0b3IgaXNuJ3QgcGFydCBvZiBDU1MzIik7dmFyIGE9dS5hZGFwdGVyO3JldHVybiBmdW5jdGlvbihwKXtyZXR1cm4gYS5nZXRDaGlsZHJlbihwKS5zb21lKGQpfTtmdW5jdGlvbiBkKEUpe3JldHVybiBhLmlzVGFnKEUpJiZmKEUpfX0sY2hpbGQ6ZnVuY3Rpb24oZixoLHUpe3ZhciBhPXUuYWRhcHRlcjtyZXR1cm4gZnVuY3Rpb24oRSl7dmFyIHA9YS5nZXRQYXJlbnQoRSk7cmV0dXJuISFwJiZmKHApfX0sc2libGluZzpmdW5jdGlvbihmLGgsdSl7dmFyIGE9dS5hZGFwdGVyO3JldHVybiBmdW5jdGlvbihFKXtmb3IodmFyIHA9YS5nZXRTaWJsaW5ncyhFKSxPPTA7TzxwLmxlbmd0aDtPKyspaWYoYS5pc1RhZyhwW09dKSl7aWYocFtPXT09PUUpYnJlYWs7aWYoZihwW09dKSlyZXR1cm4hMH1yZXR1cm4hMX19LGFkamFjZW50OmZ1bmN0aW9uKGYsaCx1KXt2YXIgYT11LmFkYXB0ZXI7cmV0dXJuIGZ1bmN0aW9uKEUpe2Zvcih2YXIgcD1hLmdldFNpYmxpbmdzKEUpLE8sbT0wO208cC5sZW5ndGg7bSsrKWlmKGEuaXNUYWcocFttXSkpe2lmKHBbbV09PT1FKWJyZWFrO089cFttXX1yZXR1cm4hIU8mJmYoTyl9fSx1bml2ZXJzYWw6ZnVuY3Rpb24oZil7cmV0dXJuIGZ9fX0sZnVuY3Rpb24oZyxlLHQpe3ZhciBuPXQoMjczKS5mYWxzZUZ1bmMsaT0vWy1bXF17fSgpKis/LixcXF4kfCNcc10vZyxmPXtfX3Byb3RvX186bnVsbCxlcXVhbHM6ZnVuY3Rpb24oaCx1LGEpe3ZhciBkPXUubmFtZSxFPXUudmFsdWUscD1hLmFkYXB0ZXI7cmV0dXJuIHUuaWdub3JlQ2FzZT8oRT1FLnRvTG93ZXJDYXNlKCksZnVuY3Rpb24obSl7dmFyIGI9cC5nZXRBdHRyaWJ1dGVWYWx1ZShtLGQpO3JldHVybiBiIT1udWxsJiZiLnRvTG93ZXJDYXNlKCk9PT1FJiZoKG0pfSk6ZnVuY3Rpb24obSl7cmV0dXJuIHAuZ2V0QXR0cmlidXRlVmFsdWUobSxkKT09PUUmJmgobSl9fSxoeXBoZW46ZnVuY3Rpb24oaCx1LGEpe3ZhciBkPXUubmFtZSxFPXUudmFsdWUscD1FLmxlbmd0aCxPPWEuYWRhcHRlcjtyZXR1cm4gdS5pZ25vcmVDYXNlPyhFPUUudG9Mb3dlckNhc2UoKSxmdW5jdGlvbihiKXt2YXIgTT1PLmdldEF0dHJpYnV0ZVZhbHVlKGIsZCk7cmV0dXJuIE0hPW51bGwmJihNLmxlbmd0aD09PXB8fE0uY2hhckF0KHApPT09Ii0iKSYmTS5zdWJzdHIoMCxwKS50b0xvd2VyQ2FzZSgpPT09RSYmaChiKX0pOmZ1bmN0aW9uKGIpe3ZhciBNPU8uZ2V0QXR0cmlidXRlVmFsdWUoYixkKTtyZXR1cm4gTSE9bnVsbCYmTS5zdWJzdHIoMCxwKT09PUUmJihNLmxlbmd0aD09PXB8fE0uY2hhckF0KHApPT09Ii0iKSYmaChiKX19LGVsZW1lbnQ6ZnVuY3Rpb24oaCx1LGEpe3ZhciBkPXUubmFtZSxFPXUudmFsdWUscD1hLmFkYXB0ZXI7aWYoL1xzLy50ZXN0KEUpKXJldHVybiBuO0U9RS5yZXBsYWNlKGksIlxcJCYiKTt2YXIgTz0iKD86XnxcXHMpIitFKyIoPzokfFxccykiLG09dS5pZ25vcmVDYXNlPyJpIjoiIixiPW5ldyBSZWdFeHAoTyxtKTtyZXR1cm4gZnVuY3Rpb24oeSl7dmFyIFM9cC5nZXRBdHRyaWJ1dGVWYWx1ZSh5LGQpO3JldHVybiBTIT1udWxsJiZiLnRlc3QoUykmJmgoeSl9fSxleGlzdHM6ZnVuY3Rpb24oaCx1LGEpe3ZhciBkPXUubmFtZSxFPWEuYWRhcHRlcjtyZXR1cm4gZnVuY3Rpb24oTyl7cmV0dXJuIEUuaGFzQXR0cmliKE8sZCkmJmgoTyl9fSxzdGFydDpmdW5jdGlvbihoLHUsYSl7dmFyIGQ9dS5uYW1lLEU9dS52YWx1ZSxwPUUubGVuZ3RoLE89YS5hZGFwdGVyO3JldHVybiBwPT09MD9uOnUuaWdub3JlQ2FzZT8oRT1FLnRvTG93ZXJDYXNlKCksZnVuY3Rpb24oYil7dmFyIE09Ty5nZXRBdHRyaWJ1dGVWYWx1ZShiLGQpO3JldHVybiBNIT1udWxsJiZNLnN1YnN0cigwLHApLnRvTG93ZXJDYXNlKCk9PT1FJiZoKGIpfSk6ZnVuY3Rpb24oYil7dmFyIE09Ty5nZXRBdHRyaWJ1dGVWYWx1ZShiLGQpO3JldHVybiBNIT1udWxsJiZNLnN1YnN0cigwLHApPT09RSYmaChiKX19LGVuZDpmdW5jdGlvbihoLHUsYSl7dmFyIGQ9dS5uYW1lLEU9dS52YWx1ZSxwPS1FLmxlbmd0aCxPPWEuYWRhcHRlcjtyZXR1cm4gcD09PTA/bjp1Lmlnbm9yZUNhc2U/KEU9RS50b0xvd2VyQ2FzZSgpLGZ1bmN0aW9uKGIpe3ZhciBNPU8uZ2V0QXR0cmlidXRlVmFsdWUoYixkKTtyZXR1cm4gTSE9bnVsbCYmTS5zdWJzdHIocCkudG9Mb3dlckNhc2UoKT09PUUmJmgoYil9KTpmdW5jdGlvbihiKXt2YXIgTT1PLmdldEF0dHJpYnV0ZVZhbHVlKGIsZCk7cmV0dXJuIE0hPW51bGwmJk0uc3Vic3RyKHApPT09RSYmaChiKX19LGFueTpmdW5jdGlvbihoLHUsYSl7dmFyIGQ9dS5uYW1lLEU9dS52YWx1ZSxwPWEuYWRhcHRlcjtpZihFPT09IiIpcmV0dXJuIG47aWYodS5pZ25vcmVDYXNlKXt2YXIgTz1uZXcgUmVnRXhwKEUucmVwbGFjZShpLCJcXCQmIiksImkiKTtyZXR1cm4gZnVuY3Rpb24oYil7dmFyIE09cC5nZXRBdHRyaWJ1dGVWYWx1ZShiLGQpO3JldHVybiBNIT1udWxsJiZPLnRlc3QoTSkmJmgoYil9fXJldHVybiBmdW5jdGlvbihiKXt2YXIgTT1wLmdldEF0dHJpYnV0ZVZhbHVlKGIsZCk7cmV0dXJuIE0hPW51bGwmJk0uaW5kZXhPZihFKT49MCYmaChiKX19LG5vdDpmdW5jdGlvbihoLHUsYSl7dmFyIGQ9dS5uYW1lLEU9dS52YWx1ZSxwPWEuYWRhcHRlcjtyZXR1cm4gRT09PSIiP2Z1bmN0aW9uKG0pe3JldHVybiEhcC5nZXRBdHRyaWJ1dGVWYWx1ZShtLGQpJiZoKG0pfTp1Lmlnbm9yZUNhc2U/KEU9RS50b0xvd2VyQ2FzZSgpLGZ1bmN0aW9uKG0pe3ZhciBiPXAuZ2V0QXR0cmlidXRlVmFsdWUobSxkKTtyZXR1cm4gYiE9bnVsbCYmYi50b0xvd2VyQ2FzZSgpIT09RSYmaChtKX0pOmZ1bmN0aW9uKG0pe3JldHVybiBwLmdldEF0dHJpYnV0ZVZhbHVlKG0sZCkhPT1FJiZoKG0pfX19O2cuZXhwb3J0cz17Y29tcGlsZTpmdW5jdGlvbihoLHUsYSl7aWYoYSYmYS5zdHJpY3QmJih1Lmlnbm9yZUNhc2V8fHUuYWN0aW9uPT09Im5vdCIpKXRocm93IG5ldyBFcnJvcigiVW5zdXBwb3J0ZWQgYXR0cmlidXRlIHNlbGVjdG9yIik7cmV0dXJuIGZbdS5hY3Rpb25dKGgsdSxhKX0scnVsZXM6Zn19LGZ1bmN0aW9uKGcsZSx0KXt2YXIgbj10KDI4MyksaT10KDI3MyksZj10KDI4MSksaD1pLnRydWVGdW5jLHU9aS5mYWxzZUZ1bmMsYT1mLnJ1bGVzLmVxdWFscztmdW5jdGlvbiBkKFMscyl7dmFyIGM9e25hbWU6Uyx2YWx1ZTpzfTtyZXR1cm4gZnVuY3Rpb24odixULFIpe3JldHVybiBhKHYsYyxSKX19ZnVuY3Rpb24gRShTLHMpe3JldHVybiBmdW5jdGlvbihjKXtyZXR1cm4hIXMuZ2V0UGFyZW50KGMpJiZTKGMpfX12YXIgcD17Y29udGFpbnM6ZnVuY3Rpb24oUyxzLGMpe3ZhciBsPWMuYWRhcHRlcjtyZXR1cm4gZnVuY3Rpb24oVCl7cmV0dXJuIFMoVCkmJmwuZ2V0VGV4dChUKS5pbmRleE9mKHMpPj0wfX0saWNvbnRhaW5zOmZ1bmN0aW9uKFMscyxjKXt2YXIgbD1zLnRvTG93ZXJDYXNlKCksdj1jLmFkYXB0ZXI7cmV0dXJuIGZ1bmN0aW9uKFIpe3JldHVybiBTKFIpJiZ2LmdldFRleHQoUikudG9Mb3dlckNhc2UoKS5pbmRleE9mKGwpPj0wfX0sIm50aC1jaGlsZCI6ZnVuY3Rpb24oUyxzLGMpe3ZhciBsPW4ocyksdj1jLmFkYXB0ZXI7cmV0dXJuIGw9PT11P2w6bD09PWg/RShTLHYpOmZ1bmN0aW9uKFIpe2Zvcih2YXIgTD12LmdldFNpYmxpbmdzKFIpLE49MCxBPTA7TjxMLmxlbmd0aDtOKyspaWYodi5pc1RhZyhMW05dKSl7aWYoTFtOXT09PVIpYnJlYWs7QSsrfXJldHVybiBsKEEpJiZTKFIpfX0sIm50aC1sYXN0LWNoaWxkIjpmdW5jdGlvbihTLHMsYyl7dmFyIGw9bihzKSx2PWMuYWRhcHRlcjtyZXR1cm4gbD09PXU/bDpsPT09aD9FKFMsdik6ZnVuY3Rpb24oUil7Zm9yKHZhciBMPXYuZ2V0U2libGluZ3MoUiksTj0wLEE9TC5sZW5ndGgtMTtBPj0wO0EtLSlpZih2LmlzVGFnKExbQV0pKXtpZihMW0FdPT09UilicmVhaztOKyt9cmV0dXJuIGwoTikmJlMoUil9fSwibnRoLW9mLXR5cGUiOmZ1bmN0aW9uKFMscyxjKXt2YXIgbD1uKHMpLHY9Yy5hZGFwdGVyO3JldHVybiBsPT09dT9sOmw9PT1oP0UoUyx2KTpmdW5jdGlvbihSKXtmb3IodmFyIEw9di5nZXRTaWJsaW5ncyhSKSxOPTAsQT0wO0E8TC5sZW5ndGg7QSsrKWlmKHYuaXNUYWcoTFtBXSkpe2lmKExbQV09PT1SKWJyZWFrO3YuZ2V0TmFtZShMW0FdKT09PXYuZ2V0TmFtZShSKSYmTisrfXJldHVybiBsKE4pJiZTKFIpfX0sIm50aC1sYXN0LW9mLXR5cGUiOmZ1bmN0aW9uKFMscyxjKXt2YXIgbD1uKHMpLHY9Yy5hZGFwdGVyO3JldHVybiBsPT09dT9sOmw9PT1oP0UoUyx2KTpmdW5jdGlvbihSKXtmb3IodmFyIEw9di5nZXRTaWJsaW5ncyhSKSxOPTAsQT1MLmxlbmd0aC0xO0E+PTA7QS0tKWlmKHYuaXNUYWcoTFtBXSkpe2lmKExbQV09PT1SKWJyZWFrO3YuZ2V0TmFtZShMW0FdKT09PXYuZ2V0TmFtZShSKSYmTisrfXJldHVybiBsKE4pJiZTKFIpfX0scm9vdDpmdW5jdGlvbihTLHMsYyl7dmFyIGw9Yy5hZGFwdGVyO3JldHVybiBmdW5jdGlvbih2KXtyZXR1cm4hbC5nZXRQYXJlbnQodikmJlModil9fSxzY29wZTpmdW5jdGlvbihTLHMsYyxsKXt2YXIgdj1jLmFkYXB0ZXI7aWYoIWx8fGwubGVuZ3RoPT09MClyZXR1cm4gcC5yb290KFMscyxjKTtmdW5jdGlvbiBUKFIsTCl7cmV0dXJuIHR5cGVvZiB2LmVxdWFscz09ImZ1bmN0aW9uIj92LmVxdWFscyhSLEwpOlI9PT1MfXJldHVybiBsLmxlbmd0aD09PTE/ZnVuY3Rpb24oUil7cmV0dXJuIFQobFswXSxSKSYmUyhSKX06ZnVuY3Rpb24oUil7cmV0dXJuIGwuaW5kZXhPZihSKT49MCYmUyhSKX19LGNoZWNrYm94OmQoInR5cGUiLCJjaGVja2JveCIpLGZpbGU6ZCgidHlwZSIsImZpbGUiKSxwYXNzd29yZDpkKCJ0eXBlIiwicGFzc3dvcmQiKSxyYWRpbzpkKCJ0eXBlIiwicmFkaW8iKSxyZXNldDpkKCJ0eXBlIiwicmVzZXQiKSxpbWFnZTpkKCJ0eXBlIiwiaW1hZ2UiKSxzdWJtaXQ6ZCgidHlwZSIsInN1Ym1pdCIpLGhvdmVyOmZ1bmN0aW9uKFMscyxjKXt2YXIgbD1jLmFkYXB0ZXI7cmV0dXJuIHR5cGVvZiBsLmlzSG92ZXJlZD09ImZ1bmN0aW9uIj9mdW5jdGlvbihUKXtyZXR1cm4gUyhUKSYmbC5pc0hvdmVyZWQoVCl9OnV9LHZpc2l0ZWQ6ZnVuY3Rpb24oUyxzLGMpe3ZhciBsPWMuYWRhcHRlcjtyZXR1cm4gdHlwZW9mIGwuaXNWaXNpdGVkPT0iZnVuY3Rpb24iP2Z1bmN0aW9uKFQpe3JldHVybiBTKFQpJiZsLmlzVmlzaXRlZChUKX06dX0sYWN0aXZlOmZ1bmN0aW9uKFMscyxjKXt2YXIgbD1jLmFkYXB0ZXI7cmV0dXJuIHR5cGVvZiBsLmlzQWN0aXZlPT0iZnVuY3Rpb24iP2Z1bmN0aW9uKFQpe3JldHVybiBTKFQpJiZsLmlzQWN0aXZlKFQpfTp1fX07ZnVuY3Rpb24gTyhTLHMpe2Zvcih2YXIgYz0wO1MmJmM8Uy5sZW5ndGg7YysrKWlmKHMuaXNUYWcoU1tjXSkpcmV0dXJuIFNbY119dmFyIG09e2VtcHR5OmZ1bmN0aW9uKFMscyl7cmV0dXJuIXMuZ2V0Q2hpbGRyZW4oUykuc29tZShmdW5jdGlvbihjKXtyZXR1cm4gcy5pc1RhZyhjKXx8Yy50eXBlPT09InRleHQifSl9LCJmaXJzdC1jaGlsZCI6ZnVuY3Rpb24oUyxzKXtyZXR1cm4gTyhzLmdldFNpYmxpbmdzKFMpLHMpPT09U30sImxhc3QtY2hpbGQiOmZ1bmN0aW9uKFMscyl7Zm9yKHZhciBjPXMuZ2V0U2libGluZ3MoUyksbD1jLmxlbmd0aC0xO2w+PTA7bC0tKXtpZihjW2xdPT09UylyZXR1cm4hMDtpZihzLmlzVGFnKGNbbF0pKWJyZWFrfXJldHVybiExfSwiZmlyc3Qtb2YtdHlwZSI6ZnVuY3Rpb24oUyxzKXtmb3IodmFyIGM9cy5nZXRTaWJsaW5ncyhTKSxsPTA7bDxjLmxlbmd0aDtsKyspaWYocy5pc1RhZyhjW2xdKSl7aWYoY1tsXT09PVMpcmV0dXJuITA7aWYocy5nZXROYW1lKGNbbF0pPT09cy5nZXROYW1lKFMpKWJyZWFrfXJldHVybiExfSwibGFzdC1vZi10eXBlIjpmdW5jdGlvbihTLHMpe2Zvcih2YXIgYz1zLmdldFNpYmxpbmdzKFMpLGw9Yy5sZW5ndGgtMTtsPj0wO2wtLSlpZihzLmlzVGFnKGNbbF0pKXtpZihjW2xdPT09UylyZXR1cm4hMDtpZihzLmdldE5hbWUoY1tsXSk9PT1zLmdldE5hbWUoUykpYnJlYWt9cmV0dXJuITF9LCJvbmx5LW9mLXR5cGUiOmZ1bmN0aW9uKFMscyl7Zm9yKHZhciBjPXMuZ2V0U2libGluZ3MoUyksbD0wLHY9Yy5sZW5ndGg7bDx2O2wrKylpZihzLmlzVGFnKGNbbF0pKXtpZihjW2xdPT09Uyljb250aW51ZTtpZihzLmdldE5hbWUoY1tsXSk9PT1zLmdldE5hbWUoUykpcmV0dXJuITF9cmV0dXJuITB9LCJvbmx5LWNoaWxkIjpmdW5jdGlvbihTLHMpe2Zvcih2YXIgYz1zLmdldFNpYmxpbmdzKFMpLGw9MDtsPGMubGVuZ3RoO2wrKylpZihzLmlzVGFnKGNbbF0pJiZjW2xdIT09UylyZXR1cm4hMTtyZXR1cm4hMH0sbGluazpmdW5jdGlvbihTLHMpe3JldHVybiBzLmhhc0F0dHJpYihTLCJocmVmIil9LHNlbGVjdGVkOmZ1bmN0aW9uKFMscyl7aWYocy5oYXNBdHRyaWIoUywic2VsZWN0ZWQiKSlyZXR1cm4hMDtpZihzLmdldE5hbWUoUykhPT0ib3B0aW9uIilyZXR1cm4hMTt2YXIgYz1zLmdldFBhcmVudChTKTtpZighY3x8cy5nZXROYW1lKGMpIT09InNlbGVjdCJ8fHMuaGFzQXR0cmliKGMsIm11bHRpcGxlIikpcmV0dXJuITE7Zm9yKHZhciBsPXMuZ2V0Q2hpbGRyZW4oYyksdj0hMSxUPTA7VDxsLmxlbmd0aDtUKyspaWYocy5pc1RhZyhsW1RdKSlpZihsW1RdPT09Uyl2PSEwO2Vsc2UgaWYodil7aWYocy5oYXNBdHRyaWIobFtUXSwic2VsZWN0ZWQiKSlyZXR1cm4hMX1lbHNlIHJldHVybiExO3JldHVybiB2fSxkaXNhYmxlZDpmdW5jdGlvbihTLHMpe3JldHVybiBzLmhhc0F0dHJpYihTLCJkaXNhYmxlZCIpfSxlbmFibGVkOmZ1bmN0aW9uKFMscyl7cmV0dXJuIXMuaGFzQXR0cmliKFMsImRpc2FibGVkIil9LGNoZWNrZWQ6ZnVuY3Rpb24oUyxzKXtyZXR1cm4gcy5oYXNBdHRyaWIoUywiY2hlY2tlZCIpfHxtLnNlbGVjdGVkKFMscyl9LHJlcXVpcmVkOmZ1bmN0aW9uKFMscyl7cmV0dXJuIHMuaGFzQXR0cmliKFMsInJlcXVpcmVkIil9LG9wdGlvbmFsOmZ1bmN0aW9uKFMscyl7cmV0dXJuIXMuaGFzQXR0cmliKFMsInJlcXVpcmVkIil9LHBhcmVudDpmdW5jdGlvbihTLHMpe3JldHVybiFtLmVtcHR5KFMscyl9LGhlYWRlcjpiKFsiaDEiLCJoMiIsImgzIiwiaDQiLCJoNSIsImg2Il0pLGJ1dHRvbjpmdW5jdGlvbihTLHMpe3ZhciBjPXMuZ2V0TmFtZShTKTtyZXR1cm4gYz09PSJidXR0b24ifHxjPT09ImlucHV0IiYmcy5nZXRBdHRyaWJ1dGVWYWx1ZShTLCJ0eXBlIik9PT0iYnV0dG9uIn0saW5wdXQ6YihbImlucHV0IiwidGV4dGFyZWEiLCJzZWxlY3QiLCJidXR0b24iXSksdGV4dDpmdW5jdGlvbihTLHMpe3ZhciBjO3JldHVybiBzLmdldE5hbWUoUyk9PT0iaW5wdXQiJiYoIShjPXMuZ2V0QXR0cmlidXRlVmFsdWUoUywidHlwZSIpKXx8Yy50b0xvd2VyQ2FzZSgpPT09InRleHQiKX19O2Z1bmN0aW9uIGIoUyl7aWYodHlwZW9mIFNldDwidSIpe3ZhciBzPW5ldyBTZXQoUyk7cmV0dXJuIGZ1bmN0aW9uKGMsbCl7cmV0dXJuIHMuaGFzKGwuZ2V0TmFtZShjKSl9fXJldHVybiBmdW5jdGlvbihjLGwpe3JldHVybiBTLmluZGV4T2YobC5nZXROYW1lKGMpKT49MH19ZnVuY3Rpb24gTShTLHMsYyl7aWYoYz09PW51bGwpe2lmKFMubGVuZ3RoPjImJnMhPT0ic2NvcGUiKXRocm93IG5ldyBFcnJvcigicHNldWRvLXNlbGVjdG9yIDoiK3MrIiByZXF1aXJlcyBhbiBhcmd1bWVudCIpfWVsc2UgaWYoUy5sZW5ndGg9PT0yKXRocm93IG5ldyBFcnJvcigicHNldWRvLXNlbGVjdG9yIDoiK3MrIiBkb2Vzbid0IGhhdmUgYW55IGFyZ3VtZW50cyIpfXZhciB5PS9eKD86KD86bnRofGxhc3R8Zmlyc3R8b25seSktKD86Y2hpbGR8b2YtdHlwZSl8cm9vdHxlbXB0eXwoPzplbnxkaXMpYWJsZWR8Y2hlY2tlZHxub3QpJC87Zy5leHBvcnRzPXtjb21waWxlOmZ1bmN0aW9uKFMscyxjLGwpe3ZhciB2PXMubmFtZSxUPXMuZGF0YSxSPWMuYWRhcHRlcjtpZihjJiZjLnN0cmljdCYmIXkudGVzdCh2KSl0aHJvdyBuZXcgRXJyb3IoIjoiK3YrIiBpc24ndCBwYXJ0IG9mIENTUzMiKTtpZih0eXBlb2YgcFt2XT09ImZ1bmN0aW9uIilyZXR1cm4gcFt2XShTLFQsYyxsKTtpZih0eXBlb2YgbVt2XT09ImZ1bmN0aW9uIil7dmFyIEw9bVt2XTtyZXR1cm4gTShMLHYsVCksTD09PXU/TDpTPT09aD9mdW5jdGlvbihBKXtyZXR1cm4gTChBLFIsVCl9OmZ1bmN0aW9uKEEpe3JldHVybiBMKEEsUixUKSYmUyhBKX19ZWxzZSB0aHJvdyBuZXcgRXJyb3IoInVubWF0Y2hlZCBwc2V1ZG8tY2xhc3MgOiIrdil9LGZpbHRlcnM6cCxwc2V1ZG9zOm19fSxmdW5jdGlvbihnLGUsdCl7dmFyIG49dCgyODQpLGk9dCgyODUpO2cuZXhwb3J0cz1mdW5jdGlvbihoKXtyZXR1cm4gaShuKGgpKX0sZy5leHBvcnRzLnBhcnNlPW4sZy5leHBvcnRzLmNvbXBpbGU9aX0sZnVuY3Rpb24oZyxlKXtnLmV4cG9ydHM9bjt2YXIgdD0vXihbK1wtXT9cZCpuKT9ccyooPzooWytcLV0/KVxzKihcZCspKT8kLztmdW5jdGlvbiBuKGkpe2lmKGk9aS50cmltKCkudG9Mb3dlckNhc2UoKSxpPT09ImV2ZW4iKXJldHVyblsyLDBdO2lmKGk9PT0ib2RkIilyZXR1cm5bMiwxXTt2YXIgZj1pLm1hdGNoKHQpO2lmKCFmKXRocm93IG5ldyBTeW50YXhFcnJvcigibi10aCBydWxlIGNvdWxkbid0IGJlIHBhcnNlZCAoJyIraSsiJykiKTt2YXIgaDtyZXR1cm4gZlsxXT8oaD1wYXJzZUludChmWzFdLDEwKSxpc05hTihoKSYmKGZbMV0uY2hhckF0KDApPT09Ii0iP2g9LTE6aD0xKSk6aD0wLFtoLGZbM10/cGFyc2VJbnQoKGZbMl18fCIiKStmWzNdLDEwKTowXX19LGZ1bmN0aW9uKGcsZSx0KXtnLmV4cG9ydHM9aDt2YXIgbj10KDI3MyksaT1uLnRydWVGdW5jLGY9bi5mYWxzZUZ1bmM7ZnVuY3Rpb24gaCh1KXt2YXIgYT11WzBdLGQ9dVsxXS0xO2lmKGQ8MCYmYTw9MClyZXR1cm4gZjtpZihhPT09LTEpcmV0dXJuIGZ1bmN0aW9uKHApe3JldHVybiBwPD1kfTtpZihhPT09MClyZXR1cm4gZnVuY3Rpb24ocCl7cmV0dXJuIHA9PT1kfTtpZihhPT09MSlyZXR1cm4gZDwwP2k6ZnVuY3Rpb24ocCl7cmV0dXJuIHA+PWR9O3ZhciBFPWQlYTtyZXR1cm4gRTwwJiYoRSs9YSksYT4xP2Z1bmN0aW9uKHApe3JldHVybiBwPj1kJiZwJWE9PT1FfTooYSo9LTEsZnVuY3Rpb24ocCl7cmV0dXJuIHA8PWQmJnAlYT09PUV9KX19LGZ1bmN0aW9uKGcsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIFR9KTt2YXIgbj10KDEyKSxpPXQoNzQpLGY9dCgxKSxoPXQoNjgpLHU9dCgyNTApLGE9dCgyMTMpLGQ9dCgyMTgpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBFKFIsTCl7aWYoUj09bnVsbClyZXR1cm57fTt2YXIgTj1wKFIsTCksQSx3O2lmKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpe3ZhciBCPU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoUik7Zm9yKHc9MDt3PEIubGVuZ3RoO3crKylBPUJbd10sIShMLmluZGV4T2YoQSk+PTApJiZPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoUixBKSYmKE5bQV09UltBXSl9cmV0dXJuIE59ZnVuY3Rpb24gcChSLEwpe2lmKFI9PW51bGwpcmV0dXJue307dmFyIE49e30sQT1PYmplY3Qua2V5cyhSKSx3LEI7Zm9yKEI9MDtCPEEubGVuZ3RoO0IrKyl3PUFbQl0sIShMLmluZGV4T2Yodyk+PTApJiYoTlt3XT1SW3ddKTtyZXR1cm4gTn1jb25zdCBPPXthbnRpYWxpYXM6ITAsYXV0b1JlbmRlcjohMCxhbHBoYTohMH0sbT1TeW1ib2woImF1dG9SZW5kZXIiKSxiPVN5bWJvbCgicmVuZGVyZXIiKSxNPVN5bWJvbCgidGltZWxpbmUiKSx5PVN5bWJvbCgicHJlcGFyZVJlbmRlciIpLFM9U3ltYm9sKCJ0aWNrUmVuZGVyIikscz1TeW1ib2woInBhc3MiKSxjPVN5bWJvbCgiZmJvIiksbD1TeW1ib2woInRpY2tlcnMiKSx2PVN5bWJvbCgibGF5ZXJUcmFuc2Zvcm1JbnZlcnQiKTtjbGFzcyBUIGV4dGVuZHMgdS5kZWZhdWx0e2NvbnN0cnVjdG9yKEw9e30pe2lmKHN1cGVyKCksIUwuY2FudmFzKXtjb25zdHt3aWR0aDpCLGhlaWdodDpEfT10aGlzLmdldFJlc29sdXRpb24oKSxJPW4uRU5WLmNyZWF0ZUNhbnZhcyhCLEQse29mZnNjcmVlbjohIUwub2Zmc2NyZWVuLGlkOkwuaWQsZXh0cmE6TC5leHRyYX0pO0kuc3R5bGUmJihJLnN0eWxlLnBvc2l0aW9uPSJhYnNvbHV0ZSIpLEkuZGF0YXNldCYmKEkuZGF0YXNldC5sYXllcklkPUwuaWQpLEkuY29udGV4dFR5cGUmJihMLmNvbnRleHRUeXBlPUkuY29udGV4dFR5cGUpLEwuY2FudmFzPUl9Y29uc3QgTj1MLmNhbnZhcyxBPU9iamVjdC5hc3NpZ24oe30sTyxMKTt0aGlzW21dPUEuYXV0b1JlbmRlcixkZWxldGUgTC5hdXRvUmVuZGVyO2NvbnN0IHc9QS5SZW5kZXJlcnx8bi5SZW5kZXJlcjt0aGlzW2JdPW5ldyB3KE4sQSksdGhpcy5vcHRpb25zPUwsdGhpcy5pZD1MLmlkLHRoaXNbc109W10sdGhpcy5zZXRSZXNvbHV0aW9uKE4pLHRoaXMuY2FudmFzPU4sdGhpc1tNXT1uZXcgaS5UaW1lbGluZSx0aGlzLl9fbW91c2VDYXB0dXJlZFRhcmdldD1udWxsLHRoaXNbdl09bnVsbH1nZXQgYXV0b1JlbmRlcigpe3JldHVybiB0aGlzW21dfWdldCBkaXNwbGF5UmF0aW8oKXtyZXR1cm4gdGhpcy5wYXJlbnQmJnRoaXMucGFyZW50Lm9wdGlvbnM/dGhpcy5wYXJlbnQub3B0aW9ucy5kaXNwbGF5UmF0aW86MX1nZXQgaGVpZ2h0KCl7Y29uc3R7aGVpZ2h0Okx9PXRoaXMuZ2V0UmVzb2x1dGlvbigpO3JldHVybiBML3RoaXMuZGlzcGxheVJhdGlvfWdldCBnbCgpe3JldHVybiB0aGlzLnJlbmRlcmVyLmdsUmVuZGVyZXI/dGhpcy5yZW5kZXJlci5nbFJlbmRlcmVyLmdsOm51bGx9Z2V0IGxheWVyKCl7cmV0dXJuIHRoaXN9Z2V0IG9mZnNjcmVlbigpe3JldHVybiEhdGhpcy5vcHRpb25zLm9mZnNjcmVlbnx8dGhpcy5jYW52YXMuX29mZnNjcmVlbn1nZXQgcGFzcygpe3JldHVybiB0aGlzW3NdfWdldCBwcmVwYXJlUmVuZGVyKCl7cmV0dXJuIHRoaXNbeV0/dGhpc1t5XTpQcm9taXNlLnJlc29sdmUoKX1nZXQgcmVuZGVyZXIoKXtyZXR1cm4gdGhpc1tiXX1nZXQgcmVuZGVyT2Zmc2V0KCl7aWYodGhpcy5wYXJlbnQmJnRoaXMucGFyZW50Lm9wdGlvbnMpe2NvbnN0e2xlZnQ6TCx0b3A6Tn09dGhpcy5wYXJlbnQub3B0aW9ucztyZXR1cm5bTCxOXX1yZXR1cm5bdGhpcy5vcHRpb25zLmxlZnR8MCx0aGlzLm9wdGlvbnMudG9wfDBdfWdldCB0aW1lbGluZSgpe3JldHVybiB0aGlzW01dfWdldCB3aWR0aCgpe2NvbnN0e3dpZHRoOkx9PXRoaXMuZ2V0UmVzb2x1dGlvbigpO3JldHVybiBML3RoaXMuZGlzcGxheVJhdGlvfWdldCBsb2NhbE1hdHJpeCgpe2NvbnN0e3g6TCx5Ok59PXRoaXMuYXR0cmlidXRlcztyZXR1cm5bMSwwLDAsMSxMLE5dfWdldCBsYXllclRyYW5zZm9ybUludmVydCgpe2lmKHRoaXNbdl0pcmV0dXJuIHRoaXNbdl07Y29uc3QgTD10aGlzLnRyYW5zZm9ybU1hdHJpeDtyZXR1cm4gTFswXT09PTEmJkxbMV09PT0wJiZMWzJdPT09MCYmTFszXT09PTEmJkxbNF09PT0wJiZMWzVdPT09MD9udWxsOih0aGlzW3ZdPWYubWF0MmQuaW52ZXJ0KEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxMKSx0aGlzW3ZdKX1mb3JjZUNvbnRleHRMb3NzKCl7Y29uc3QgTD10aGlzLnJlbmRlcmVyLmdsUmVuZGVyZXI7aWYoTCl7Y29uc3QgTj1MLmdldEV4dGVuc2lvbigiV0VCR0xfbG9zZV9jb250ZXh0Iik7aWYoTilyZXR1cm4gTi5sb3NlQ29udGV4dCgpLCEwfXJldHVybiExfWFkZFBhc3Moe3ZlcnRleDpMLGZyYWdtZW50Ok4sb3B0aW9uczpBLHVuaWZvcm1zOnd9PXt9KXtpZih0aGlzLnJlbmRlcmVyLmdsUmVuZGVyZXIpe2NvbnN0e3dpZHRoOkIsaGVpZ2h0OkR9PXRoaXMuZ2V0UmVzb2x1dGlvbigpLEk9dGhpcy5yZW5kZXJlci5jcmVhdGVQYXNzUHJvZ3JhbSh7dmVydGV4OkwsZnJhZ21lbnQ6TixvcHRpb25zOkF9KSxqPW5ldyBuLkZpZ3VyZTJEO2oucmVjdCgwLDAsQi90aGlzLmRpc3BsYXlSYXRpbyxEL3RoaXMuZGlzcGxheVJhdGlvKTtjb25zdCBWPW5ldyBuLk1lc2gyRChqKTtyZXR1cm4gVi5zZXRVbmlmb3Jtcyh3KSxWLnNldFByb2dyYW0oSSksdGhpc1tzXS5wdXNoKFYpLHRoaXMuZm9yY2VVcGRhdGUoKSxWfXJldHVybiBudWxsfWRlbGV0ZVRleHR1cmUoTCl7cmV0dXJuIE9iamVjdChkLmRlbGV0ZVRleHR1cmUpKEwsdGhpcy5yZW5kZXJlcil9ZGlzcGF0Y2hQb2ludGVyRXZlbnQoTCl7Y29uc3QgTj1MLnR5cGU7aWYoTj09PSJtb3VzZWRvd24ifHxOPT09Im1vdXNldXAifHxOPT09Im1vdXNlbW92ZSIpe2NvbnN0IEk9dGhpcy5fX21vdXNlQ2FwdHVyZWRUYXJnZXQ7aWYoSSl7aWYoSS5sYXllcj09PXRoaXMpcmV0dXJuIEkuZGlzcGF0Y2hFdmVudChMKSwhMDt0aGlzLl9fbW91c2VDYXB0dXJlZFRhcmdldD1udWxsfX1sZXQgQSx3O2NvbnN0IEI9dGhpcy5sYXllclRyYW5zZm9ybUludmVydDtpZihCKXtBPUwueCx3PUwueTtjb25zdCBJPUIsaj1JWzBdKkErSVsyXSp3K0lbNF0sVj1JWzFdKkErSVszXSp3K0lbNV07ZGVsZXRlIEwueCxkZWxldGUgTC55LGRlbGV0ZSBMLmxheWVyWCxkZWxldGUgTC5sYXllclksT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoTCx7bGF5ZXJYOnt2YWx1ZTpqLGNvbmZpZ3VyYWJsZTohMH0sbGF5ZXJZOnt2YWx1ZTpWLGNvbmZpZ3VyYWJsZTohMH0seDp7dmFsdWU6aixjb25maWd1cmFibGU6ITB9LHk6e3ZhbHVlOlYsY29uZmlndXJhYmxlOiEwfX0pfWNvbnN0IEQ9c3VwZXIuZGlzcGF0Y2hQb2ludGVyRXZlbnQoTCk7cmV0dXJuIEImJk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEwse2xheWVyWDp7dmFsdWU6QSxjb25maWd1cmFibGU6ITB9LGxheWVyWTp7dmFsdWU6dyxjb25maWd1cmFibGU6ITB9LHg6e3ZhbHVlOkEsY29uZmlndXJhYmxlOiEwfSx5Ont2YWx1ZTp3LGNvbmZpZ3VyYWJsZTohMH19KSxEfWZvcmNlVXBkYXRlKCl7aWYoIXRoaXNbeV0paWYodGhpcy5wYXJlbnQmJnRoaXMucGFyZW50Lmhhc09mZnNjcmVlbkNhbnZhcyl7dGhpcy5wYXJlbnQuZm9yY2VVcGRhdGUoKTtsZXQgTD1udWxsO2NvbnN0IE49bmV3IFByb21pc2UoQT0+e0w9QX0pO04uX3Jlc29sdmU9TCx0aGlzW3ldPU59ZWxzZXtsZXQgTD1udWxsLE49bnVsbDtjb25zdCBBPW5ldyBQcm9taXNlKHc9PntMPXcsdGhpc1ttXSYmKE49T2JqZWN0KGgucmVxdWVzdEFuaW1hdGlvbkZyYW1lKSgoKT0+e2RlbGV0ZSBBLl9yZXF1ZXN0SUQsdGhpcy5yZW5kZXIoKX0pKX0pO0EuX3Jlc29sdmU9TCxBLl9yZXF1ZXN0SUQ9Tix0aGlzW3ldPUF9fWdldEZCTygpe2NvbnN0IEw9dGhpcy5yZW5kZXJlci5nbFJlbmRlcmVyLHt3aWR0aDpOLGhlaWdodDpBfT10aGlzLmdldFJlc29sdXRpb24oKTtyZXR1cm4gTCYmKCF0aGlzW2NdfHx0aGlzW2NdLndpZHRoIT09Tnx8dGhpc1tjXS5oZWlnaHQhPT1BKT8odGhpc1tjXT17d2lkdGg6TixoZWlnaHQ6QSx0YXJnZXQ6TC5jcmVhdGVGQk8oKSxidWZmZXI6TC5jcmVhdGVGQk8oKSxzd2FwKCl7W3RoaXMudGFyZ2V0LHRoaXMuYnVmZmVyXT1bdGhpcy5idWZmZXIsdGhpcy50YXJnZXRdfX0sdGhpc1tjXSk6dGhpc1tjXT90aGlzW2NdOm51bGx9dXBkYXRlR2xvYmFsVHJhbnNmb3JtKCl7aWYodGhpcy5sYXllclRyYW5zZm9ybUludmVydCl7Y29uc3QgTD10aGlzLnJlbmRlcmVyLE49TC5fX2dsb2JhbFRyYW5zZm9ybU1hdHJpeHx8TC5nbG9iYWxUcmFuc2Zvcm1NYXRyaXg7TC5fX2dsb2JhbFRyYW5zZm9ybU1hdHJpeD1OO2NvbnN0IEE9Zi5tYXQyZC5mcm9tVmFsdWVzKDEsMCwwLDEsMCwwKTtMLnNldEdsb2JhbFRyYW5zZm9ybSguLi5mLm1hdDJkLm11bHRpcGx5KEEsTix0aGlzLnRyYW5zZm9ybU1hdHJpeCkpfX1vblByb3BlcnR5Q2hhbmdlKEwsTixBKXtpZihzdXBlci5vblByb3BlcnR5Q2hhbmdlKEwsTixBKSxMPT09InpJbmRleCImJih0aGlzLmNhbnZhcy5zdHlsZS56SW5kZXg9TiksTD09PSJ0cmFuc2Zvcm0ifHxMPT09InRyYW5zbGF0ZSJ8fEw9PT0icm90YXRlInx8TD09PSJzY2FsZSJ8fEw9PT0ic2tldyIpe2NvbnN0IHc9dGhpc1t2XTtpZih0aGlzW3ZdPW51bGwsdGhpcy51cGRhdGVHbG9iYWxUcmFuc2Zvcm0oKSx3JiYhdGhpcy5sYXllclRyYW5zZm9ybUludmVydCl7Y29uc3QgQj10aGlzLnJlbmRlcmVyLEQ9Qi5fX2dsb2JhbFRyYW5zZm9ybU1hdHJpeHx8Qi5nbG9iYWxUcmFuc2Zvcm1NYXRyaXg7Qi5zZXRHbG9iYWxUcmFuc2Zvcm0oLi4uRCl9fX1fcHJlcGFyZVJlbmRlckZpbmlzaGVkKCl7dGhpc1t5XSYmKHRoaXNbeV0uX3JlcXVlc3RJRCYmT2JqZWN0KGguY2FuY2VsQW5pbWF0aW9uRnJhbWUpKHRoaXNbeV0uX3JlcXVlc3RJRCksdGhpc1t5XS5fcmVzb2x2ZSgpLGRlbGV0ZSB0aGlzW3ldKX1yZW5kZXIoe2NsZWFyOkw9ITB9PXt9KXtjb25zdCBOPXRoaXNbc10ubGVuZ3RoP3RoaXMuZ2V0RkJPKCk6bnVsbDtOJiZ0aGlzLnJlbmRlcmVyLmdsUmVuZGVyZXIuYmluZEZCTyhOLnRhcmdldCksTCYmdGhpc1tiXS5jbGVhcigpO2NvbnN0IEE9dGhpcy5kcmF3KCk7aWYoQSYmQS5sZW5ndGgmJih0aGlzLnJlbmRlcmVyLmRyYXdNZXNoZXMoQSksdGhpcy5jYW52YXMuZHJhdyYmdGhpcy5jYW52YXMuZHJhdygpKSxOKXtjb25zdCB3PXRoaXMucmVuZGVyZXIuZ2xSZW5kZXJlcixCPXRoaXNbc10ubGVuZ3RoLHt3aWR0aDpELGhlaWdodDpJfT10aGlzLmdldFJlc29sdXRpb24oKSxqPVswLDAsRC90aGlzLmRpc3BsYXlSYXRpbyxJL3RoaXMuZGlzcGxheVJhdGlvXTt0aGlzW3NdLmZvckVhY2goKFYsSik9PntWLmJsZW5kPSEwLFYuc2V0VGV4dHVyZShOLnRhcmdldC50ZXh0dXJlLHtyZWN0Omp9KSxKPT09Qi0xP3cuYmluZEZCTyhudWxsKTooTi5zd2FwKCksdy5iaW5kRkJPKE4udGFyZ2V0KSksdGhpc1tiXS5jbGVhcigpLHRoaXMucmVuZGVyZXIuZHJhd01lc2hlcyhbVl0pfSl9dGhpcy5fcHJlcGFyZVJlbmRlckZpbmlzaGVkKCl9c2V0UmVzb2x1dGlvbih7d2lkdGg6TCxoZWlnaHQ6Tn0pe2NvbnN0IEE9dGhpcy5yZW5kZXJlcix3PUEuX19nbG9iYWxUcmFuc2Zvcm1NYXRyaXh8fEEuZ2xvYmFsVHJhbnNmb3JtTWF0cml4LEI9d1s0XSxEPXdbNV0sST13WzBdLHt3aWR0aDpqLGhlaWdodDpWfT10aGlzLmdldFJlc29sdXRpb24oKTsoaiE9PUx8fFYhPT1OKSYmKHN1cGVyLnNldFJlc29sdXRpb24oe3dpZHRoOkwsaGVpZ2h0Ok59KSx0aGlzLmNhbnZhcyYmKHRoaXMuY2FudmFzLndpZHRoPUwsdGhpcy5jYW52YXMuaGVpZ2h0PU4sQS51cGRhdGVSZXNvbHV0aW9uJiZBLnVwZGF0ZVJlc29sdXRpb24oKSksdGhpcy5hdHRyaWJ1dGVzLnNpemU9W0wsTl0sdGhpc1tzXS5sZW5ndGgmJnRoaXNbc10uZm9yRWFjaChHPT57Y29uc3QgWT1uZXcgbi5GaWd1cmUyRDtZLnJlY3QoMCwwLEwvdGhpcy5kaXNwbGF5UmF0aW8sTi90aGlzLmRpc3BsYXlSYXRpbyksRy5jb250b3Vycz1ZLmNvbnRvdXJzfSkpO2NvbnN0W0osX109dGhpcy5yZW5kZXJPZmZzZXQsc3Q9dGhpcy5kaXNwbGF5UmF0aW87KEIhPT1KfHxEIT09X3x8SSE9PXN0KSYmKEEuc2V0R2xvYmFsVHJhbnNmb3JtKHN0LDAsMCxzdCxKLF8pLEEuX19nbG9iYWxUcmFuc2Zvcm1NYXRyaXg9bnVsbCx0aGlzW3ZdPW51bGwsdGhpcy51cGRhdGVHbG9iYWxUcmFuc2Zvcm0oKSx0aGlzLmZvcmNlVXBkYXRlKCkpfXRpY2soTD1udWxsLE49e30pe2xldHtkdXJhdGlvbjpBPTEvMH09Tix3PUUoTixbImR1cmF0aW9uIl0pO2NvbnN0IEI9dGhpcy50aW1lbGluZS5mb3JrKHcpLEQ9dGhpczt0aGlzW2xdPXRoaXNbbF18fFtdLHRoaXNbbF0ucHVzaCh7aGFuZGxlcjpMLGR1cmF0aW9uOkF9KTtjb25zdCBJPSgpPT57bGV0IGo9bnVsbCxWPW51bGw7Y29uc3QgSj0oKT0+e2NvbnN0IF89dGhpc1tsXS5tYXAoKHtoYW5kbGVyOnN0LGR1cmF0aW9uOkd9KT0+e2NvbnN0IFk9TWF0aC5taW4oMSxCLmN1cnJlbnRUaW1lL0cpO3JldHVybnt2YWx1ZTpzdD9zdChCLmN1cnJlbnRUaW1lLFkpOm51bGwscDpZfX0pO0RbU118fChEW1NdPVByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCk9PntEW21dJiZELnJlbmRlcigpLGRlbGV0ZSBEW1NdO2ZvcihsZXQgc3Q9Xy5sZW5ndGgtMTtzdD49MDtzdC0tKXtjb25zdHt2YWx1ZTpHLHA6WX09X1tzdF07KEc9PT0hMXx8WT49MSkmJnRoaXNbbF0uc3BsaWNlKHN0LDEpfXRoaXNbbF0ubGVuZ3RoPjAmJkkoKX0pKX07aWYodGhpc1t5XSYmdGhpc1t5XS5fdHlwZSE9PSJ0aWNrZXIiJiYoT2JqZWN0KGguY2FuY2VsQW5pbWF0aW9uRnJhbWUpKHRoaXNbeV0uX3JlcXVlc3RJRCksZGVsZXRlIHRoaXNbeV0pLCF0aGlzW3ldKXtjb25zdCBfPW5ldyBQcm9taXNlKHN0PT57aj1zdCxWPU9iamVjdChoLnJlcXVlc3RBbmltYXRpb25GcmFtZSkoSil9KTtfLl9yZXNvbHZlPWosXy5fcmVxdWVzdElEPVYsXy5fdHlwZT0idGlja2VyIix0aGlzW3ldPV99fTtJKCl9dG9HbG9iYWxQb3MoTCxOKXtpZih0aGlzLmxheWVyVHJhbnNmb3JtSW52ZXJ0KXtjb25zdCBqPXRoaXMudHJhbnNmb3JtTWF0cml4O0w9alswXSpMK2pbMl0qTitqWzRdLE49alsxXSpMK2pbM10qTitqWzVdfWNvbnN0e3dpZHRoOkEsaGVpZ2h0Ond9PXRoaXMuZ2V0UmVzb2x1dGlvbigpLEI9dGhpcy5yZW5kZXJPZmZzZXQsRD1bdGhpcy5jYW52YXMuY2xpZW50V2lkdGgsdGhpcy5jYW52YXMuY2xpZW50SGVpZ2h0XTtMPUwqRFswXS9BK0JbMF0sTj1OKkRbMV0vdytCWzFdO2NvbnN0IEk9dGhpcy5kaXNwbGF5UmF0aW87cmV0dXJuIEwqPUksTio9SSxbTCxOXX10b0xvY2FsUG9zKEwsTil7Y29uc3R7d2lkdGg6QSxoZWlnaHQ6d309dGhpcy5nZXRSZXNvbHV0aW9uKCksQj10aGlzLnJlbmRlck9mZnNldCxEPVt0aGlzLmNhbnZhcy5jbGllbnRXaWR0aCx0aGlzLmNhbnZhcy5jbGllbnRIZWlnaHRdO0w9TCpBL0RbMF0tQlswXSxOPU4qdy9EWzFdLUJbMV07Y29uc3QgST10aGlzLmRpc3BsYXlSYXRpbztMLz1JLE4vPUk7Y29uc3Qgaj10aGlzLmxheWVyVHJhbnNmb3JtSW52ZXJ0O3JldHVybiBqJiYoTD1qWzBdKkwralsyXSpOK2pbNF0sTj1qWzFdKkwralszXSpOK2pbNV0pLFtMLE5dfX1hLmRlZmF1bHQucmVnaXN0ZXJOb2RlKFQsImxheWVyIil9LGZ1bmN0aW9uKGcsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIHl9KTt2YXIgbj10KDIyNCksaT10KDI4OCksZj10KDIxMyksaD10KDI1MiksdT10KDcyKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gYShTLHMpe2lmKFM9PW51bGwpcmV0dXJue307dmFyIGM9ZChTLHMpLGwsdjtpZihPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKXt2YXIgVD1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKFMpO2Zvcih2PTA7djxULmxlbmd0aDt2KyspbD1UW3ZdLCEocy5pbmRleE9mKGwpPj0wKSYmT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKFMsbCkmJihjW2xdPVNbbF0pfXJldHVybiBjfWZ1bmN0aW9uIGQoUyxzKXtpZihTPT1udWxsKXJldHVybnt9O3ZhciBjPXt9LGw9T2JqZWN0LmtleXMoUyksdixUO2ZvcihUPTA7VDxsLmxlbmd0aDtUKyspdj1sW1RdLCEocy5pbmRleE9mKHYpPj0wKSYmKGNbdl09U1t2XSk7cmV0dXJuIGN9ZnVuY3Rpb24gRShTLHMsYyl7cmV0dXJuIHMgaW4gUz9PYmplY3QuZGVmaW5lUHJvcGVydHkoUyxzLHt2YWx1ZTpjLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6U1tzXT1jLFN9Y29uc3QgcD0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciLE89U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlIiksbT1TeW1ib2woInJvb3QiKSxiPVN5bWJvbCgidGFzayIpO2Z1bmN0aW9uIE0oUyxzPSEwKXtjb25zdCBjPVNbbV07aWYoYyYmYy5jaGlsZHJlblswXSl7Y29uc3QgbD1TLnN2Zyx2PVMubGF5ZXI/Uy5sYXllci5kaXNwbGF5UmF0aW86MTtpZighbC5oYXNBdHRyaWJ1dGUoImRhdGEtb3JpZ2luYWwtd2lkdGgiKSl7bGV0IEw9bC5nZXRBdHRyaWJ1dGUoIndpZHRoIik7TD1MP09iamVjdCh1LnNpemVUb1BpeGVsKShMKTozMDA7bGV0IE49bC5nZXRBdHRyaWJ1dGUoImhlaWdodCIpO049Tj9PYmplY3QodS5zaXplVG9QaXhlbCkoTik6MTUwLGwuaGFzQXR0cmlidXRlKCJ2aWV3Qm94Iil8fGwuc2V0QXR0cmlidXRlKCJ2aWV3Qm94IixgMCAwICR7TWF0aC5yb3VuZChMKX0gJHtNYXRoLnJvdW5kKE4pfWApLGwuc2V0QXR0cmlidXRlKCJkYXRhLW9yaWdpbmFsLXdpZHRoIixMKSxsLnNldEF0dHJpYnV0ZSgiZGF0YS1vcmlnaW5hbC1oZWlnaHQiLE4pfWxldCBUPVMuYXR0cmlidXRlcy53aWR0aHx8TnVtYmVyKGwuZ2V0QXR0cmlidXRlKCJkYXRhLW9yaWdpbmFsLXdpZHRoIikpLFI9Uy5hdHRyaWJ1dGVzLmhlaWdodHx8TnVtYmVyKGwuZ2V0QXR0cmlidXRlKCJkYXRhLW9yaWdpbmFsLWhlaWdodCIpKTtpZihUKj12LFIqPXYscyYmUy5hdHRyaWJ1dGVzLmZsZXhpYmxlKXtjb25zdCBMPVMuYXR0cmlidXRlcy5zY2FsZVswXTtpZihUKj1MLFIqPUwsbC5zZXRBdHRyaWJ1dGUoIndpZHRoIixUKSxsLnNldEF0dHJpYnV0ZSgiaGVpZ2h0IixSKSxUJiZSJiZTLnRleHR1cmVJbWFnZSl7Y29uc3QgTj1TLnRleHR1cmVJbWFnZS53aWR0aCxBPVMudGV4dHVyZUltYWdlLmhlaWdodCx3PVMuY2xpZW50U2l6ZTtTLmF0dHJpYnV0ZXMudGV4dHVyZVJlY3Q9WzAsMCxNYXRoLnJvdW5kKHdbMF0qTi9UKSxNYXRoLnJvdW5kKHdbMV0qQS9SKV19fWVsc2UgU1tiXXx8KGwuc2V0QXR0cmlidXRlKCJ3aWR0aCIsVCksbC5zZXRBdHRyaWJ1dGUoImhlaWdodCIsUiksU1tiXT1Qcm9taXNlLnJlc29sdmUoKS50aGVuKCgpPT57ZGVsZXRlIFNbYl07Y29uc3QgTD1jLmlubmVySFRNTCxOPW5ldyBCbG9iKFtMXSx7dHlwZToiaW1hZ2Uvc3ZnK3htbCJ9KSxBPVVSTC5jcmVhdGVPYmplY3RVUkwoTiksdz1uZXcgSW1hZ2U7dy5vbmxvYWQ9ZnVuY3Rpb24oKXt3LndpZHRoJiZ3LmhlaWdodD8oUy5hdHRyaWJ1dGVzW09dKCJ0ZXh0dXJlIix3KSxTLmF0dHJpYnV0ZXMuZmxleGlibGUmJihTLmF0dHJpYnV0ZXMudGV4dHVyZVJlY3Q9bnVsbCkpOlMuYXR0cmlidXRlc1tPXSgidGV4dHVyZSIsbnVsbCl9LHcuc3JjPUF9KSl9fWNsYXNzIHkgZXh0ZW5kcyBuLmRlZmF1bHR7Y29uc3RydWN0b3Iocz17fSl7dHlwZW9mIHM9PSJzdHJpbmciJiYocz17c3ZnVGV4dDpzfSk7bGV0e3N2Z1RleHQ6Y309cyxsPWEocyxbInN2Z1RleHQiXSk7aWYoc3VwZXIobCksdGhpc1ttXT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKSxjKXt0aGlzW21dLmlubmVySFRNTD1jO2NvbnN0IHY9dGhpc1ttXS5jaGlsZHJlblswXTt2P3Yuc2V0QXR0cmlidXRlKCJ4bWxucyIscCk6KGZldGNoKGMpLnRoZW4oVD0+VC50ZXh0KCkpLnRoZW4oVD0+e3RoaXNbbV0uaW5uZXJIVE1MPVQsKCF0aGlzLm9ic2VydmVyfHx0aGlzLmF0dHJpYnV0ZXMuZmxleGlibGUpJiZNKHRoaXMpfSksYz1udWxsKX1pZighYyl7Y29uc3Qgdj1kb2N1bWVudC5jcmVhdGVFbGVtZW50TlMocCwic3ZnIik7di5zZXRBdHRyaWJ1dGUoInhtbG5zIixwKSx0aGlzW21dLmFwcGVuZENoaWxkKHYpfWlmKHR5cGVvZiBNdXRhdGlvbk9ic2VydmVyPT0iZnVuY3Rpb24iKXtjb25zdCB2PW5ldyBNdXRhdGlvbk9ic2VydmVyKFQ9PntNKHRoaXMsITEpfSk7di5vYnNlcnZlKHRoaXNbbV0se2F0dHJpYnV0ZXM6ITAsc3VidHJlZTohMCxjaGFyYWN0ZXJEYXRhOiEwLGNoaWxkTGlzdDohMH0pLHRoaXMub2JzZXJ2ZXI9dn19Z2V0IGNoaWxkcmVuKCl7cmV0dXJuW3RoaXMuc3ZnXX1nZXQgY2hpbGROb2Rlcygpe3JldHVyblt0aGlzLnN2Z119Z2V0IHN2Zygpe3JldHVybiB0aGlzW21dP3RoaXNbbV0uY2hpbGRyZW5bMF06bnVsbH1zZXRSZXNvbHV0aW9uKHt3aWR0aDpzLGhlaWdodDpjfSl7c3VwZXIuc2V0UmVzb2x1dGlvbih7d2lkdGg6cyxoZWlnaHQ6Y30pLE0odGhpcyl9ZGlzcGF0Y2hQb2ludGVyRXZlbnQocyl7Y29uc3QgYz1zdXBlci5kaXNwYXRjaFBvaW50ZXJFdmVudChzKTtpZihjJiZ0aGlzLmF0dHJpYnV0ZXMucGFzc0V2ZW50cyYmdHlwZW9mIE1vdXNlRXZlbnQ9PSJmdW5jdGlvbiIpe2NvbnN0e3g6bCx5OnZ9PXM7bGV0W1QsUl09dGhpcy5nZXRPZmZzZXRQb3NpdGlvbihsLHYpO2NvbnN0IEw9cy5vcmlnaW5hbEV2ZW50LE49dGhpcy5hdHRyaWJ1dGVzLmFuY2hvcixBPXRoaXMuY2xpZW50U2l6ZTtUPShUK05bMF0qQVswXSkvMixSPShSK05bMV0qQVsxXSkvMjtjb25zdCB3PXMudHlwZTtpZih3PT09TC50eXBlKXtsZXQgQj1udWxsO2lmKEwgaW5zdGFuY2VvZiBNb3VzZUV2ZW50KUI9bmV3IE1vdXNlRXZlbnQodyx7c2NyZWVuWDpULHNjcmVlblk6UixjbGllbnRYOlQsY2xpZW50WTpSLGJ1YmJsZXM6TC5idWJibGVzLGJ1dHRvbjpMLmJ1dHRvbixidXR0b25zOkwuYnV0dG9ucyxjYW5jZWxCdWJibGU6TC5jYW5jZWxCdWJibGUsY2FuY2VsYWJsZTpMLmNhbmNlbGFibGUsY3VycmVudFRhcmdldDpMLmN1cnJlbnRUYXJnZXQsZnJvbUVsZW1lbnQ6TC5mcm9tRWxlbWVudCxyZWxhdGVkVGFyZ2V0OkwucmVsYXRlZFRhcmdldCxyZXR1cm5WYWx1ZTpMLnJldHVyblZhbHVlLHNyY0VsZW1lbnQ6TC5zcmNFbGVtZW50LHRhcmdldDpMLnRhcmdldCx0b0VsZW1lbnQ6TC50b0VsZW1lbnQsd2hpY2g6TC53aXRjaH0pO2Vsc2UgaWYoTCBpbnN0YW5jZW9mIFRvdWNoRXZlbnQpe2xldCBEPW51bGw7Y29uc3QgST1MLmNoYW5nZWRUb3VjaGVzfHxbTF07Zm9yKGxldCBqPTA7ajxJLmxlbmd0aDtqKyspe2NvbnN0IFY9SVtqXTtpZihzLmlkZW50aWZpZXI9PT1WLmlkZW50aWZpZXIpe0Q9VjticmVha319aWYoRCl7Y29uc3Qgaj1uZXcgVG91Y2goe2lkZW50aWZpZXI6RC5pZGVudGlmaWVyLHRhcmdldDpELnRhcmdldCxjbGllbnRYOlQsY2xpZW50WTpSLHNjcmVlblg6VCxzY3JlZW5ZOlIscGFnZVg6VCxwYWdlWTpSLHJhZGl1c1g6RC5yYWRpdXNYLHJhZGl1c1k6RC5yYWRpdXNZLHJvdGF0aW9uQW5nbGU6RC5yb3RhdGlvbkFuZ2xlLGZvcmNlOkQuZm9yY2V9KTtCPW5ldyBUb3VjaEV2ZW50KHcse2NhbmNlbGFibGU6TC5jYW5jZWxhYmxlLGJ1YmJsZXM6TC5idWJibGVzLGNvbXBvc2VkOkwuY29tcG9zZWQsdG91Y2hlczpbal0sdGFyZ2V0VG91Y2hlczpbal0sY2hhbmdlZFRvdWNoZXM6W2pdfSl9fWVsc2UgQj1MO0ImJnRoaXMuc3ZnLmRpc3BhdGNoRXZlbnQoQil9fXJldHVybiBjfWdldEVsZW1lbnRCeUlkKHMpe3JldHVybiBPYmplY3QoaC5xdWVyeVNlbGVjdG9yKShgIyR7c31gLHRoaXMpfWdldEVsZW1lbnRzQnlDbGFzc05hbWUocyl7cmV0dXJuIE9iamVjdChoLnF1ZXJ5U2VsZWN0b3JBbGwpKGAuJHtzfWAsdGhpcyl9Z2V0RWxlbWVudHNCeU5hbWUocyl7cmV0dXJuIE9iamVjdChoLnF1ZXJ5U2VsZWN0b3JBbGwpKGBbbmFtZT0iJHtzfSJdYCx0aGlzKX1nZXRFbGVtZW50c0J5VGFnTmFtZShzKXtyZXR1cm4gT2JqZWN0KGgucXVlcnlTZWxlY3RvckFsbCkocyx0aGlzKX1xdWVyeVNlbGVjdG9yKHMpe3JldHVybiBPYmplY3QoaC5xdWVyeVNlbGVjdG9yKShzLHRoaXMpfXF1ZXJ5U2VsZWN0b3JBbGwocyl7cmV0dXJuIE9iamVjdChoLnF1ZXJ5U2VsZWN0b3JBbGwpKHMsdGhpcyl9b25Qcm9wZXJ0eUNoYW5nZShzLGMsbCl7c3VwZXIub25Qcm9wZXJ0eUNoYW5nZShzLGMsbCkscz09PSJmbGV4aWJsZSImJk0odGhpcyksdGhpcy5hdHRyaWJ1dGVzLmZsZXhpYmxlJiYocz09PSJ3aWR0aCJ8fHM9PT0iaGVpZ2h0Inx8cz09PSJzY2FsZSJ8fHM9PT0idHJhbnNmb3JtIikmJk0odGhpcyl9fUUoeSwiQXR0ciIsaS5kZWZhdWx0KSxmLmRlZmF1bHQucmVnaXN0ZXJOb2RlKHksInNwcml0ZXN2ZyIpfSxmdW5jdGlvbihnLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiB1fSk7dmFyIG49dCgyMjUpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCBpPVN5bWJvbC5mb3IoInNwcml0ZWpzX2dldEF0dHJpYnV0ZSIpLGY9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlIiksaD1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGVEZWZhdWx0Iik7Y2xhc3MgdSBleHRlbmRzIG4uZGVmYXVsdHtjb25zdHJ1Y3RvcihkKXtzdXBlcihkKSx0aGlzW2hdKHtwYXNzRXZlbnRzOiExLGZsZXhpYmxlOiExfSl9Z2V0IHRleHR1cmUoKXtyZXR1cm4gdGhpc1tpXSgidGV4dHVyZSIpfXNldCB0ZXh0dXJlKGQpe31nZXQgcGFzc0V2ZW50cygpe3JldHVybiB0aGlzW2ldKCJwYXNzRXZlbnRzIil9c2V0IHBhc3NFdmVudHMoZCl7cmV0dXJuIHRoaXNbZl0oInBhc3NFdmVudHMiLGQpfWdldCBmbGV4aWJsZSgpe3JldHVybiB0aGlzW2ldKCJmbGV4aWJsZSIpfXNldCBmbGV4aWJsZShkKXtyZXR1cm4gdGhpc1tmXSgiZmxleGlibGUiLGQpfX19LGZ1bmN0aW9uKGcsZSx0KXt0LnIoZSk7dmFyIG49dCgxMik7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIGkoZCxFKXt2YXIgcD1PYmplY3Qua2V5cyhkKTtpZihPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKXt2YXIgTz1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGQpO0UmJihPPU8uZmlsdGVyKGZ1bmN0aW9uKG0pe3JldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGQsbSkuZW51bWVyYWJsZX0pKSxwLnB1c2guYXBwbHkocCxPKX1yZXR1cm4gcH1mdW5jdGlvbiBmKGQpe2Zvcih2YXIgRT0xO0U8YXJndW1lbnRzLmxlbmd0aDtFKyspe3ZhciBwPWFyZ3VtZW50c1tFXSE9bnVsbD9hcmd1bWVudHNbRV06e307RSUyP2koT2JqZWN0KHApLCEwKS5mb3JFYWNoKGZ1bmN0aW9uKE8pe2goZCxPLHBbT10pfSk6T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnM/T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZCxPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhwKSk6aShPYmplY3QocCkpLmZvckVhY2goZnVuY3Rpb24oTyl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGQsTyxPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHAsTykpfSl9cmV0dXJuIGR9ZnVuY3Rpb24gaChkLEUscCl7cmV0dXJuIEUgaW4gZD9PYmplY3QuZGVmaW5lUHJvcGVydHkoZCxFLHt2YWx1ZTpwLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6ZFtFXT1wLGR9Y29uc3QgdT1TeW1ib2woImluaXRlZCIpO2xldCBhPW51bGw7dHlwZW9mIFdvcmtlcj09ImZ1bmN0aW9uIiYmKGE9Y2xhc3MgZXh0ZW5kcyBXb3JrZXJ7Y29uc3RydWN0b3IoZCl7aWYoZC53b3JrZXI9PT0hMCYmKGQud29ya2VyPWAuLyR7ZC5pZH0ud29ya2VyLmpzYCksc3VwZXIoZC53b3JrZXIpLHRoaXMub3B0aW9ucz1kLCFkLmNhbnZhcyl7Y29uc3R7d2lkdGg6RSxoZWlnaHQ6cH09dGhpcy5nZXRSZXNvbHV0aW9uKCksTz1uLkVOVi5jcmVhdGVDYW52YXMoRSxwLHtvZmZzY3JlZW46ITF9KTtPLnN0eWxlJiYoTy5zdHlsZS5wb3NpdGlvbj0iYWJzb2x1dGUiKSxPLmRhdGFzZXQmJihPLmRhdGFzZXQubGF5ZXJJZD1kLmlkKSxkLmNhbnZhcz1PfXRoaXMuY2FudmFzPWQuY2FudmFzfWdldCBpZCgpe3JldHVybiB0aGlzLm9wdGlvbnMuaWR9c2V0UmVzb2x1dGlvbih7d2lkdGg6ZCxoZWlnaHQ6RX0pe2lmKHRoaXNbdV0pdGhpcy5wb3N0TWVzc2FnZSh7dHlwZToicmVzb2x1dGlvbl9jaGFuZ2UiLHdpZHRoOmQsaGVpZ2h0OkV9KTtlbHNle3RoaXMuY2FudmFzLndpZHRoPWQsdGhpcy5jYW52YXMuaGVpZ2h0PUU7Y29uc3QgcD10aGlzLm9wdGlvbnMsTz1wLmNhbnZhcy50cmFuc2ZlckNvbnRyb2xUb09mZnNjcmVlbigpLG09Zih7fSxwKTtkZWxldGUgbS5jb250YWluZXIsbS5jYW52YXM9Tyx0aGlzLnBvc3RNZXNzYWdlKHt0eXBlOiJjcmVhdGUiLG9wdGlvbnM6bX0sW09dKSx0aGlzW3VdPSEwfX1nZXRSZXNvbHV0aW9uKCl7aWYodGhpcy5jYW52YXMpe2NvbnN0e3dpZHRoOmQsaGVpZ2h0OkV9PXRoaXMuY2FudmFzO3JldHVybnt3aWR0aDpkLGhlaWdodDpFfX1yZXR1cm57d2lkdGg6MzAwLGhlaWdodDoxNTB9fXJlbW92ZSgpe3JldHVybiB0aGlzLnBhcmVudCYmdGhpcy5wYXJlbnQucmVtb3ZlQ2hpbGQ/KHRoaXMucGFyZW50LnJlbW92ZUNoaWxkKHRoaXMpLCEwKTohMX1jb25uZWN0KGQsRSl7T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInBhcmVudCIse3ZhbHVlOmQsd3JpdGFibGU6ITEsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInpPcmRlciIse3ZhbHVlOkUsd3JpdGFibGU6ITEsY29uZmlndXJhYmxlOiEwfSl9ZGlzY29ubmVjdCgpe2RlbGV0ZSB0aGlzLnBhcmVudCxkZWxldGUgdGhpcy56T3JkZXJ9ZGlzcGF0Y2hQb2ludGVyRXZlbnQoZCl7dGhpcy5wb3N0TWVzc2FnZSh7dHlwZToiZXZlbnQiLGV2ZW50OntjYW5jZWxCdWJibGU6ZC5jYW5jZWxCdWJibGUsYnViYmxlczpkLmJ1YmJsZXMsZGV0YWlsOmQuZGV0YWlsLGlkZW50aWZpZXI6ZC5pZGVudGlmaWVyLGxheWVyWDpkLmxheWVyWCxsYXllclk6ZC5sYXllclksb3JpZ2luYWxYOmQub3JpZ2luYWxYLG9yaWdpbmFsWTpkLm9yaWdpbmFsWSx0eXBlOmQudHlwZSx4OmQueCx5OmQueX19KX19KSxlLmRlZmF1bHQ9YX0sZnVuY3Rpb24oZyxlLHQpe3QucihlKSwoZnVuY3Rpb24obil7dC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIFR9KTt2YXIgaT10KDEyKSxmPXQoNjgpLGg9dCg3MCksdT10KDI4NiksYT10KDI4OSksZD10KDI1MCksRT10KDI5MSkscD10KDIxNCksTz10KDIxOCksbT10KDIxMyk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IGI9U3ltYm9sKCJlbnRlcmVkVGFyZ2V0cyIpO2Z1bmN0aW9uIE0oUil7cmV0dXJuIFIuaWQ9Ui5pZHx8YF9sYXllciR7TWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMiwxMil9YCxSLmRhdGFzZXR8fChSLmRhdGFzZXQ9e30pLFIuZGF0YXNldC5sYXllcklkPVIuaWQsUi5jb25uZWN0PShMLE4pPT57Ui5wYXJlbnQ9TCxPYmplY3QuZGVmaW5lUHJvcGVydHkoUiwiek9yZGVyIix7dmFsdWU6Tix3cml0YWJsZTohMSxjb25maWd1cmFibGU6ITB9KX0sUi5kaXNjb25uZWN0PUw9PntkZWxldGUgUi56T3JkZXJ9LFIuY2FudmFzPVIsUi5nZXRSZXNvbHV0aW9uPSgpPT4oe3dpZHRoOjAsaGVpZ2h0OjB9KSxSLnNldFJlc29sdXRpb249KCk9PiExLFIub3B0aW9ucz17aGFuZGxlRXZlbnQ6ITF9LFJ9ZnVuY3Rpb24geShSLEwpe2NvbnN0IE49Ui5jaGlsZHJlbjtsZXQgQT1udWxsO2ZvcihsZXQgdz0wO3c8Ti5sZW5ndGg7dysrKXtjb25zdCBCPU5bd107aWYoKEw9PT1CfHxBIT1udWxsKSYmKEE9QiksQSYmQSE9PUwmJiFBLm9mZnNjcmVlbilyZXR1cm4gQS5jYW52YXN9cmV0dXJuIG51bGx9ZnVuY3Rpb24gUyhSLEwpe2NvbnN0W04sQV09Ui5yZW5kZXJPZmZzZXQse3dpZHRoOncsaGVpZ2h0OkJ9PVIuZ2V0UmVzb2x1dGlvbigpLEQ9Ui5kaXNwbGF5UmF0aW87Ui5yZW5kZXJlci5kcmF3SW1hZ2UoTC5jYW52YXMsLU4vRCwtQS9ELHcvRCxCL0QpfWNvbnN0IHM9e307ZnVuY3Rpb24gYyhSKXtjb25zdCBMPVsibW91c2Vkb3duIiwibW91c2V1cCIsIm1vdXNlbW92ZSIsIm1vdXNld2hlZWwiLCJ3aGVlbCIsInRvdWNoc3RhcnQiLCJ0b3VjaGVuZCIsInRvdWNobW92ZSIsInRvdWNoY2FuY2VsIiwiY2xpY2siLCJkYmxjbGljayIsImxvbmdwcmVzcyIsInRhcCIsImNvbnRleHRtZW51Il0sTj1SLmNvbnRhaW5lcjtOLmFkZEV2ZW50TGlzdGVuZXIoIm1vdXNlbGVhdmUiLEE9Pntjb25zdCB3PVJbYl07aWYody5zaXplKXtjb25zdCBCPW5ldyBwLmRlZmF1bHQoIm1vdXNlbGVhdmUiKTtCLnNldE9yaWdpbmFsRXZlbnQoQSksWy4uLnddLmZvckVhY2goRD0+e0QuZGlzcGF0Y2hFdmVudChCKX0pLFJbYl0uY2xlYXIoKX19LHtwYXNzaXZlOiEwfSksTC5mb3JFYWNoKEE9PntOLmFkZEV2ZW50TGlzdGVuZXIoQSx3PT57Y29uc3R7bGVmdDpCLHRvcDpELGRpc3BsYXlSYXRpbzpJfT1SLm9wdGlvbnMsaj1SLm9yZGVyZWRDaGlsZHJlbjtPYmplY3QoRS5kZWZhdWx0KSh3LHtvZmZzZXRMZWZ0OkIsb2Zmc2V0VG9wOkQsZGlzcGxheVJhdGlvOkl9KS5mb3JFYWNoKEo9Pntjb25zdCBfPUouaWRlbnRpZmllcjtpZihKLnR5cGU9PT0idG91Y2htb3ZlInx8Si50eXBlPT09InRvdWNoZW5kIil7Y29uc3QgRz1zW19dO0cmJkcuZGlzcGF0Y2hFdmVudChKKSxKLnR5cGU9PT0idG91Y2hlbmQiJiZkZWxldGUgc1tfXX1lbHNle2ZvcihsZXQgRz1qLmxlbmd0aC0xO0c+PTA7Ry0tKXtjb25zdCBZPWpbR107aWYoWS5vcHRpb25zLmhhbmRsZUV2ZW50IT09ITEpe2lmKFkuZGlzcGF0Y2hQb2ludGVyRXZlbnQoSikmJkoudGFyZ2V0IT09WSlicmVhaztKLmNhbmNlbEJ1YmJsZT0hMX19aWYoSi50YXJnZXQ9PT1qWzBdKWZvcihsZXQgRz1qLmxlbmd0aC0xO0c+PTA7Ry0tKXtjb25zdCBZPWpbR107aWYoWS5vcHRpb25zLmhhbmRsZUV2ZW50IT09ITEpe0oudGFyZ2V0PVk7YnJlYWt9fX1jb25zdCBzdD1KLnRhcmdldDtpZihKLnR5cGU9PT0idG91Y2hzdGFydCImJihzW19dPUoudGFyZ2V0KSxKLnR5cGU9PT0ibW91c2Vtb3ZlIil7Y29uc3QgRz1SW2JdO2xldCBZO2lmKHN0KXtjb25zdCBhdD1zdC5hbmNlc3RvcnN8fFtdO1k9bmV3IFNldChbc3QsLi4uYXRdKX1lbHNlIFk9bmV3IFNldDtjb25zdCBydD1PYmplY3QuZW50cmllcyh3KTtpZighRy5oYXMoc3QpJiZzdCl7Y29uc3QgYXQ9bmV3IHAuZGVmYXVsdCgibW91c2VlbnRlciIpO2F0LnNldE9yaWdpbmFsRXZlbnQodykscnQuZm9yRWFjaCgoW2l0LE10XSk9PnthdFtpdF09TXR9KSxHLmFkZChzdCksc3QuZGlzcGF0Y2hFdmVudChhdCk7Y29uc3QgaHQ9c3QuYW5jZXN0b3JzO2h0JiZodC5mb3JFYWNoKGl0PT57aXQgaW5zdGFuY2VvZiBoLmRlZmF1bHQmJiFHLmhhcyhpdCkmJihHLmFkZChpdCksaXQuZGlzcGF0Y2hFdmVudChhdCkpfSl9Y29uc3Qgb3Q9bmV3IHAuZGVmYXVsdCgibW91c2VsZWF2ZSIpO290LnNldE9yaWdpbmFsRXZlbnQodykscnQuZm9yRWFjaCgoW2F0LGh0XSk9PntvdFthdF09aHR9KSxbLi4uR10uZm9yRWFjaChhdD0+e1kuaGFzKGF0KXx8KEcuZGVsZXRlKGF0KSxhdC5kaXNwYXRjaEV2ZW50KG90KSl9KX19KX0se3Bhc3NpdmU6QSE9PSJjb250ZXh0bWVudSJ9KX0pfWZ1bmN0aW9uIGwoUixMKXtpZihMJiZMLnN0eWxlKXtsZXR7d2lkdGg6TixoZWlnaHQ6QSxtb2RlOncsY29udGFpbmVyOkJ9PVI7Y29uc3R7Y2xpZW50V2lkdGg6RCxjbGllbnRIZWlnaHQ6SX09QjtOPU58fEQsQT1BfHxJLHc9PT0ic3RhdGljIj8oTC5zdHlsZS53aWR0aD1gJHtOfXB4YCxMLnN0eWxlLmhlaWdodD1gJHtBfXB4YCk6KEwuc3R5bGUudG9wPSIwIixMLnN0eWxlLmxlZnQ9IjAiLEwuc3R5bGUud2lkdGg9YCR7RH1weGAsTC5zdHlsZS5oZWlnaHQ9YCR7SX1weGAsTC5zdHlsZS50cmFuc2Zvcm09IiIsTC5zdHlsZS53ZWJraXRUcmFuc2Zvcm09IiIpfX1jb25zdCB2PVN5bWJvbCgib2Zmc2NyZWVuTGF5ZXJDb3VudCIpO2NsYXNzIFQgZXh0ZW5kcyBkLmRlZmF1bHR7Y29uc3RydWN0b3IoTD17fSl7aWYoc3VwZXIoKSwhTC5jb250YWluZXIpaWYodHlwZW9mIGkuRU5WLkNvbnRhaW5lcj09ImZ1bmN0aW9uIilMLmNvbnRhaW5lcj1uZXcgaS5FTlYuQ29udGFpbmVyKEwud2lkdGh8fDMwMCxMLmhlaWdodHx8MTUwKTtlbHNlIHRocm93IG5ldyBFcnJvcigiTm8gY29udGFpbmVyIHNwZWNpZmllZC4iKTtpZih0aGlzLmNvbnRhaW5lcj1MLmNvbnRhaW5lcix0aGlzLmNvbnRhaW5lci5zdHlsZSYmKHRoaXMuY29udGFpbmVyLnN0eWxlLm92ZXJmbG93fHwodGhpcy5jb250YWluZXIuc3R5bGUub3ZlcmZsb3c9ImhpZGRlbiIpLHRoaXMuY29udGFpbmVyLnN0eWxlLnBvc2l0aW9ufHwodGhpcy5jb250YWluZXIuc3R5bGUucG9zaXRpb249InJlbGF0aXZlIikpLHRoaXMub3B0aW9ucz1MLEwuZGlzcGxheVJhdGlvPUwuZGlzcGxheVJhdGlvfHwxLEwubW9kZT1MLm1vZGV8fCJzY2FsZSIsTC5sZWZ0PTAsTC50b3A9MCxMLmF1dG9SZXNpemU9TC5hdXRvUmVzaXplIT09ITEsTC5hdXRvUmVzaXplKXtsZXQgTjtpZih0eXBlb2YgZ2xvYmFsVGhpczwidSI/Tj1nbG9iYWxUaGlzOk49dHlwZW9mIHdpbmRvdzwidSI/d2luZG93Om4sTi5hZGRFdmVudExpc3RlbmVyKXtjb25zdCBBPXRoaXM7Ti5hZGRFdmVudExpc3RlbmVyKCJyZXNpemUiLGZ1bmN0aW9uIHcoKXt0eXBlb2YgZG9jdW1lbnQ8InUiJiZkb2N1bWVudC5jb250YWlucyhBLmNvbnRhaW5lcik/QS5yZXNpemUoKTpOLnJlbW92ZUV2ZW50TGlzdGVuZXIoInJlc2l6ZSIsdyl9KX19dGhpc1tiXT1uZXcgU2V0LHRoaXMuc2V0UmVzb2x1dGlvbihMKSxjKHRoaXMpLHRoaXNbdl09MH1nZXQgaGFzT2Zmc2NyZWVuQ2FudmFzKCl7cmV0dXJuIHRoaXNbdl0+MH1zZXQgZGlzcGxheVJhdGlvKEwpe3RoaXMub3B0aW9ucy5kaXNwbGF5UmF0aW8hPT1MJiYodGhpcy5vcHRpb25zLmRpc3BsYXlSYXRpbz1MLHRoaXMucmVzaXplKCkpfWdldCBkaXNwbGF5UmF0aW8oKXtyZXR1cm4gdGhpcy5vcHRpb25zLmRpc3BsYXlSYXRpb31zZXQgaGVpZ2h0KEwpe3RoaXMub3B0aW9ucy5oZWlnaHQhPT1MJiYodGhpcy5vcHRpb25zLmhlaWdodD1MLHRoaXMucmVzaXplKCkpfWdldCBoZWlnaHQoKXtyZXR1cm4gdGhpcy5vcHRpb25zLmhlaWdodH1zZXQgbW9kZShMKXt0aGlzLm9wdGlvbnMubW9kZSE9PUwmJih0aGlzLm9wdGlvbnMubW9kZT1MLHRoaXMucmVzaXplKCkpfWdldCBtb2RlKCl7cmV0dXJuIHRoaXMub3B0aW9ucy5tb2RlfXNldCB3aWR0aChMKXt0aGlzLm9wdGlvbnMud2lkdGghPT1MJiYodGhpcy5vcHRpb25zLndpZHRoPUwsdGhpcy5yZXNpemUoKSl9Z2V0IHdpZHRoKCl7cmV0dXJuIHRoaXMub3B0aW9ucy53aWR0aH1hcHBlbmRDaGlsZChMKXshKEwgaW5zdGFuY2VvZiB1LmRlZmF1bHQpJiYhKEwgaW5zdGFuY2VvZiBhLmRlZmF1bHQpJiZNKEwpO2NvbnN0IE49c3VwZXIuYXBwZW5kQ2hpbGQoTCksQT1MLmNhbnZhcztyZXR1cm4gTC5vZmZzY3JlZW4/dGhpc1t2XSsrOnRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKEEpLGwodGhpcy5vcHRpb25zLEEpLEwuc2V0UmVzb2x1dGlvbih0aGlzLmdldFJlc29sdXRpb24oKSksTn1mb3JjZVVwZGF0ZSgpe3RoaXMuaGFzT2Zmc2NyZWVuQ2FudmFzJiYhdGhpcy5fcmVxdWVzdElEJiYodGhpcy5fcmVxdWVzdElEPU9iamVjdChmLnJlcXVlc3RBbmltYXRpb25GcmFtZSkoKCk9PntkZWxldGUgdGhpcy5fcmVxdWVzdElELHRoaXMucmVuZGVyKCl9KSl9aW5zZXJ0QmVmb3JlKEwsTil7IShMIGluc3RhbmNlb2YgdS5kZWZhdWx0KSYmIShMIGluc3RhbmNlb2YgYS5kZWZhdWx0KSYmTShMKTtjb25zdCBBPXN1cGVyLmluc2VydEJlZm9yZShMLE4pLHc9TC5jYW52YXM7aWYoIUwub2Zmc2NyZWVuKXtjb25zdCBCPXkodGhpcyxMKTt0aGlzLmNvbnRhaW5lci5pbnNlcnRCZWZvcmUodyxCKX1yZXR1cm4gbCh0aGlzLm9wdGlvbnMsdyksTC5zZXRSZXNvbHV0aW9uKHRoaXMuZ2V0UmVzb2x1dGlvbigpKSxBfWxheWVyKEw9ImRlZmF1bHQiLE49e30pe049T2JqZWN0LmFzc2lnbih7fSx0aGlzLm9wdGlvbnMsTiksTi5pZD1MO2NvbnN0IEE9dGhpcy5vcmRlcmVkQ2hpbGRyZW47Zm9yKGxldCBEPTA7RDxBLmxlbmd0aDtEKyspaWYoQVtEXS5pZD09PUwpcmV0dXJuIEFbRF07Y29uc3Qgdz1OLndvcmtlcjtsZXQgQjtyZXR1cm4gdz9CPW5ldyBhLmRlZmF1bHQoTik6Qj1uZXcgdS5kZWZhdWx0KE4pLHRoaXMuYXBwZW5kQ2hpbGQoQiksQn1hc3luYyBwcmVsb2FkKC4uLkwpe2NvbnN0IE49W10sQT1bXSx3PVtdO2ZvcihsZXQgQj0wO0I8TC5sZW5ndGg7QisrKXtjb25zdCBEPUxbQl07bGV0IEk7aWYodHlwZW9mIEQ9PSJzdHJpbmciKUk9T2JqZWN0KE8ubG9hZFRleHR1cmUpKEQpO2Vsc2UgaWYoQXJyYXkuaXNBcnJheShEKSlJPU9iamVjdChPLmxvYWRGcmFtZXMpKC4uLkQpO2Vsc2V7Y29uc3R7aWQ6aixzcmM6Vn09RDtJPU9iamVjdChPLmxvYWRUZXh0dXJlKShWLGopfUkgaW5zdGFuY2VvZiBQcm9taXNlfHwoST1Qcm9taXNlLnJlc29sdmUoSSkpLEEucHVzaChJLnRoZW4oaj0+e04ucHVzaChqKSx3W0JdPWo7Y29uc3QgVj1uZXcgcC5kZWZhdWx0KHt0eXBlOiJwcmVsb2FkIixkZXRhaWw6e2N1cnJlbnQ6aixsb2FkZWQ6TixyZXNvdXJjZXM6TH19KTt0aGlzLmRpc3BhdGNoRXZlbnQoVil9KSl9cmV0dXJuIGF3YWl0IFByb21pc2UuYWxsKEEpLHd9cmVtb3ZlQ2hpbGQoTCl7Y29uc3QgTj1zdXBlci5yZW1vdmVDaGlsZChMKTtpZihOKXtMLl9wcmVwYXJlUmVuZGVyRmluaXNoZWQmJkwuX3ByZXBhcmVSZW5kZXJGaW5pc2hlZCgpO2NvbnN0IEE9TC5jYW52YXM7QSYmQS5yZW1vdmUmJkEucmVtb3ZlKCksTC5vZmZzY3JlZW4mJnRoaXNbdl0tLX1yZXR1cm4gTn1yZW5kZXIoKXtjb25zdCBMPXRoaXMub3JkZXJlZENoaWxkcmVuO2xldCBOPW51bGw7Y29uc3QgQT1bXTtmb3IobGV0IHc9MDt3PEwubGVuZ3RoO3crKyl7Y29uc3QgQj1MW3ddLEQ9QS5sZW5ndGg+MDtpZihCIGluc3RhbmNlb2YgdS5kZWZhdWx0JiYhQi5vZmZzY3JlZW4paWYoIUIuYXV0b1JlbmRlcilEJiYoY29uc29sZS53YXJuKCJTb21lIG9mZnNjcmVlbiBjYW52YXMgd2lsbCBub3QgYmUgcmVuZGVyZWQuIiksQS5sZW5ndGg9MCk7ZWxzZSBpZihOPUIsRCl7Qi5yZW5kZXJlci5jbGVhcigpO2ZvcihsZXQgST0wO0k8QS5sZW5ndGg7SSsrKXtjb25zdCBqPUFbSV07ai5yZW5kZXIoKSxTKEIsail9QS5sZW5ndGg9MCxCLnJlbmRlcih7Y2xlYXI6ITF9KX1lbHNlIEIucHJlcGFyZVJlbmRlciYmQi5yZW5kZXIoKTtlbHNlIEIub2Zmc2NyZWVuP04/KEIucHJlcGFyZVJlbmRlciYmQi5yZW5kZXIoKSxTKE4sQikpOkEucHVzaChCKTpCIGluc3RhbmNlb2YgYS5kZWZhdWx0JiZEJiYoY29uc29sZS53YXJuKCJTb21lIG9mZnNjcmVlbiBjYW52YXMgd2lsbCBub3QgYmUgcmVuZGVyZWQuIiksQS5sZW5ndGg9MCl9fXJlcGxhY2VDaGlsZChMLE4pe2NvbnN0IEE9c3VwZXIucmVwbGFjZUNoaWxkKEwsTik7Ti5jYW52YXMucmVtb3ZlJiZOLmNhbnZhcy5yZW1vdmUoKSxOLm9mZnNjcmVlbiYmdGhpc1t2XS0tO2NvbnN0IHc9TC5jYW52YXM7aWYoIUwub2Zmc2NyZWVuKXtjb25zdCBCPXkodGhpcyxMKTt0aGlzLmNvbnRhaW5lci5pbnNlcnRCZWZvcmUodyxCKX1yZXR1cm4gbCh0aGlzLm9wdGlvbnMsdyksTC5zZXRSZXNvbHV0aW9uKHRoaXMuZ2V0UmVzb2x1dGlvbigpKSxBfXJlc2l6ZSgpe2NvbnN0IEw9dGhpcy5vcHRpb25zO3RoaXMuY2hpbGRyZW4uZm9yRWFjaChOPT57bChMLE4uY2FudmFzKX0pLHRoaXMuc2V0UmVzb2x1dGlvbihMKSx0aGlzLmRpc3BhdGNoRXZlbnQoe3R5cGU6InJlc2l6ZSJ9KX1zZXRSZXNvbHV0aW9uKHt3aWR0aDpMLGhlaWdodDpOfT17fSl7Y29uc3QgQT10aGlzLmNvbnRhaW5lcix7Y2xpZW50V2lkdGg6dyxjbGllbnRIZWlnaHQ6Qn09QTsoTD09bnVsbHx8Tj09bnVsbCkmJihMPUw/P3csTj1OPz9CKTtjb25zdHttb2RlOkQsZGlzcGxheVJhdGlvOkl9PXRoaXMub3B0aW9ucztpZihMKj1JLE4qPUksdGhpcy5vcHRpb25zLmxlZnQ9MCx0aGlzLm9wdGlvbnMudG9wPTAsRD09PSJzdGlja3lIZWlnaHQifHxEPT09InN0aWNreUxlZnQifHxEPT09InN0aWNreVJpZ2h0Iil7Y29uc3Qgaj1MO0w9dypOL0IsRD09PSJzdGlja3lIZWlnaHQiJiYodGhpcy5vcHRpb25zLmxlZnQ9LjUqKEwtaikpLEQ9PT0ic3RpY2t5UmlnaHQiJiYodGhpcy5vcHRpb25zLmxlZnQ9TC1qKX1lbHNlIGlmKEQ9PT0ic3RpY2t5V2lkdGgifHxEPT09InN0aWNreVRvcCJ8fEQ9PT0ic3RpY2t5Qm90dG9tIil7Y29uc3Qgaj1OO049QipML3csRD09PSJzdGlja3lXaWR0aCImJih0aGlzLm9wdGlvbnMudG9wPS41KihOLWopKSxEPT09InN0aWNreUJvdHRvbSImJih0aGlzLm9wdGlvbnMudG9wPU4tail9c3VwZXIuc2V0UmVzb2x1dGlvbih7d2lkdGg6TCxoZWlnaHQ6Tn0pfXNuYXBzaG90KHtvZmZzY3JlZW46TD0hMSxsYXllcnM6Tn09e30pe2NvbnN0IEE9TD8ic25hcHNob3RPZmZTY3JlZW5DYW52YXMiOiJzbmFwc2hvdENhbnZhcyIse3dpZHRoOncsaGVpZ2h0OkJ9PXRoaXMuZ2V0UmVzb2x1dGlvbigpO3RoaXNbQV09dGhpc1tBXXx8aS5FTlYuY3JlYXRlQ2FudmFzKHcsQix7b2Zmc2NyZWVuOkx9KTtjb25zdCBEPXRoaXNbQV0uZ2V0Q29udGV4dCgiMmQiKTtOPU58fHRoaXMub3JkZXJlZENoaWxkcmVuLHRoaXNbQV0ud2lkdGg9dyx0aGlzW0FdLmhlaWdodD1CO2ZvcihsZXQgST0wO0k8Ti5sZW5ndGg7SSsrKXtjb25zdCBqPU5bSV07aWYoIWoub3B0aW9ucy5pZ25vcmVTbmFwc2hvdCl7ai5yZW5kZXImJmoucmVuZGVyKCk7Y29uc3QgVj1qLmNhbnZhcztWJiZWIT09aiYmRC5kcmF3SW1hZ2UoViwwLDAsdyxCKX19cmV0dXJuIHRoaXNbQV19fXR5cGVvZiBkb2N1bWVudDwidSImJihULnByb3RvdHlwZS5sYXllcjNkPWZ1bmN0aW9uKFIsTD17fSl7Y29uc3QgTj1MLnVybHx8Imh0dHBzOi8vdW5wa2cuY29tL3Nwcml0ZS1leHRlbmQtM2QvZGlzdC9zcHJpdGUtZXh0ZW5kLTNkLm1pbi5qcyI7cmV0dXJuIG5ldyBQcm9taXNlKChBLHcpPT57Y29uc3QgQj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJzY3JpcHQiKTtCLmFzeW5jPSExLEIuc3JjPU4sQi5vbmxvYWQ9KCk9Pnt0cnl7QSh0aGlzLmxheWVyM2QoUixMKSl9Y2F0Y2goRCl7dyhEKX19LGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZChCKX0pfSksbS5kZWZhdWx0LnJlZ2lzdGVyTm9kZShULCJzY2VuZSIpfSkuY2FsbCh0aGlzLHQoMjIpKX0sZnVuY3Rpb24oZyxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gaX0pO3ZhciBuPXQoMjE0KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gaShmLHtvZmZzZXRUb3A6aD0wLG9mZnNldExlZnQ6dT0wLGRpc3BsYXlSYXRpbzphPTF9PXt9KXtsZXQgZCxFO2NvbnN0IHA9W10se2xlZnQ6Tyx0b3A6bSx3aWR0aDpiLGhlaWdodDpNfT1mLnRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSx5PWYudGFyZ2V0LndpZHRoLFM9Zi50YXJnZXQuaGVpZ2h0LHM9Zi5jaGFuZ2VkVG91Y2hlc3x8W2ZdO2ZvcihsZXQgbD0wO2w8cy5sZW5ndGg7bCsrKXtjb25zdCB2PXNbbF0sVD12LmlkZW50aWZpZXIse2NsaWVudFg6UixjbGllbnRZOkx9PXY7UiE9bnVsbCYmTCE9bnVsbCYmcC5wdXNoKHt4Ok1hdGgucm91bmQoKFJ8MCktTykseTpNYXRoLnJvdW5kKChMfDApLW0pLGlkZW50aWZpZXI6VH0pfXAubGVuZ3RoPD0wJiZwLnB1c2goe3g6ZCx5OkV9KTtjb25zdCBjPVtdO3JldHVybiBwLmZvckVhY2gobD0+e2wueCE9bnVsbCYmbC55IT1udWxsJiYoZD0obC54KnkvYi11KS9hLEU9KGwueSpTL00taCkvYSk7Y29uc3Qgdj1uZXcgbi5kZWZhdWx0KGYpO09iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHYse2xheWVyWDp7dmFsdWU6ZCxjb25maWd1cmFibGU6ITB9LGxheWVyWTp7dmFsdWU6RSxjb25maWd1cmFibGU6ITB9LG9yaWdpbmFsWDp7dmFsdWU6bC54fSxvcmlnaW5hbFk6e3ZhbHVlOmwueX0seDp7dmFsdWU6ZCxjb25maWd1cmFibGU6ITB9LHk6e3ZhbHVlOkUsY29uZmlndXJhYmxlOiEwfSxpZGVudGlmaWVyOnt2YWx1ZTpsLmlkZW50aWZpZXJ9fSksYy5wdXNoKHYpfSksY319XSk7bGUudmVyc2lvbixsZS5BcmMsbGUuQmxvY2ssbGUuQ2xvdWQsbGUuQ29sb3I7Y29uc3QgV2E9bGUuRWxsaXBzZTtsZS5HcmFkaWVudDtjb25zdCBJcj1sZS5Hcm91cCx5bT1sZS5MYWJlbDtsZS5MYXllcixsZS5MYXllcldvcmtlcixsZS5Ob2RlLGxlLlBhcmFsbGVsO2NvbnN0IEhyPWxlLlBhdGgsY249bGUuUG9seWxpbmUsZ3M9bGUuUmVjdDtsZS5SZWd1bGFyLGxlLlJpbmc7Y29uc3QgeG09bGUuU2NlbmU7bGUuU3ByaXRlLGxlLlNwcml0ZVN2ZyxsZS5TdGFyLGxlLlRyaWFuZ2xlLGxlLmhlbHBlcnMsbGUuY3JlYXRlRWxlbWVudCxsZS5pc1Nwcml0ZU5vZGUsbGUucmVnaXN0ZXJOb2RlLGxlLnJlcXVlc3RBbmltYXRpb25GcmFtZSxsZS5jYW5jZWxBbmltYXRpb25GcmFtZSxsZS5FTlY7ZnVuY3Rpb24gaG4oZyxlPSEwKXtjb25zdCB0PWcubGVuZ3RoO2lmKHQ8MilyZXR1cm4iIjtsZXQgbj1nWzBdLGk9Z1sxXTtpZih0PT09MilyZXR1cm5gTSR7dW4obil9TCR7dW4oaSl9YDtsZXQgZj0iIjtmb3IobGV0IGg9Mix1PXQtMTtoPHU7aCsrKW49Z1toXSxpPWdbaCsxXSxmKz1mbihuLGkpO3JldHVybiBlP2BNJHtmbihnWzBdLGdbMV0pfVEke3VuKGdbMV0pfSR7Zm4oZ1sxXSxnWzJdKX1UJHtmfSR7Zm4oZ1t0LTFdLGdbMF0pfSR7Zm4oZ1swXSxnWzFdKX1aYDpgTSR7dW4oZ1swXSl9USR7dW4oZ1sxXSl9JHtmbihnWzFdLGdbMl0pfSR7Zy5sZW5ndGg+Mz8iVCI6IiJ9JHtmfUwke3VuKGdbdC0xXSl9YH12YXIgdnM9e2V4cG9ydHM6e319O3ZzLmV4cG9ydHMsZnVuY3Rpb24oZyl7dmFyIGU9ZnVuY3Rpb24oKXt2YXIgdD1TdHJpbmcuZnJvbUNoYXJDb2RlLG49IkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89IixpPSJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSstJCIsZj17fTtmdW5jdGlvbiBoKGEsZCl7aWYoIWZbYV0pe2ZbYV09e307Zm9yKHZhciBFPTA7RTxhLmxlbmd0aDtFKyspZlthXVthLmNoYXJBdChFKV09RX1yZXR1cm4gZlthXVtkXX12YXIgdT17Y29tcHJlc3NUb0Jhc2U2NDpmdW5jdGlvbihhKXtpZihhPT1udWxsKXJldHVybiIiO3ZhciBkPXUuX2NvbXByZXNzKGEsNixmdW5jdGlvbihFKXtyZXR1cm4gbi5jaGFyQXQoRSl9KTtzd2l0Y2goZC5sZW5ndGglNCl7ZGVmYXVsdDpjYXNlIDA6cmV0dXJuIGQ7Y2FzZSAxOnJldHVybiBkKyI9PT0iO2Nhc2UgMjpyZXR1cm4gZCsiPT0iO2Nhc2UgMzpyZXR1cm4gZCsiPSJ9fSxkZWNvbXByZXNzRnJvbUJhc2U2NDpmdW5jdGlvbihhKXtyZXR1cm4gYT09bnVsbD8iIjphPT0iIj9udWxsOnUuX2RlY29tcHJlc3MoYS5sZW5ndGgsMzIsZnVuY3Rpb24oZCl7cmV0dXJuIGgobixhLmNoYXJBdChkKSl9KX0sY29tcHJlc3NUb1VURjE2OmZ1bmN0aW9uKGEpe3JldHVybiBhPT1udWxsPyIiOnUuX2NvbXByZXNzKGEsMTUsZnVuY3Rpb24oZCl7cmV0dXJuIHQoZCszMil9KSsiICJ9LGRlY29tcHJlc3NGcm9tVVRGMTY6ZnVuY3Rpb24oYSl7cmV0dXJuIGE9PW51bGw/IiI6YT09IiI/bnVsbDp1Ll9kZWNvbXByZXNzKGEubGVuZ3RoLDE2Mzg0LGZ1bmN0aW9uKGQpe3JldHVybiBhLmNoYXJDb2RlQXQoZCktMzJ9KX0sY29tcHJlc3NUb1VpbnQ4QXJyYXk6ZnVuY3Rpb24oYSl7Zm9yKHZhciBkPXUuY29tcHJlc3MoYSksRT1uZXcgVWludDhBcnJheShkLmxlbmd0aCoyKSxwPTAsTz1kLmxlbmd0aDtwPE87cCsrKXt2YXIgbT1kLmNoYXJDb2RlQXQocCk7RVtwKjJdPW0+Pj44LEVbcCoyKzFdPW0lMjU2fXJldHVybiBFfSxkZWNvbXByZXNzRnJvbVVpbnQ4QXJyYXk6ZnVuY3Rpb24oYSl7aWYoYT09bnVsbClyZXR1cm4gdS5kZWNvbXByZXNzKGEpO2Zvcih2YXIgZD1uZXcgQXJyYXkoYS5sZW5ndGgvMiksRT0wLHA9ZC5sZW5ndGg7RTxwO0UrKylkW0VdPWFbRSoyXSoyNTYrYVtFKjIrMV07dmFyIE89W107cmV0dXJuIGQuZm9yRWFjaChmdW5jdGlvbihtKXtPLnB1c2godChtKSl9KSx1LmRlY29tcHJlc3MoTy5qb2luKCIiKSl9LGNvbXByZXNzVG9FbmNvZGVkVVJJQ29tcG9uZW50OmZ1bmN0aW9uKGEpe3JldHVybiBhPT1udWxsPyIiOnUuX2NvbXByZXNzKGEsNixmdW5jdGlvbihkKXtyZXR1cm4gaS5jaGFyQXQoZCl9KX0sZGVjb21wcmVzc0Zyb21FbmNvZGVkVVJJQ29tcG9uZW50OmZ1bmN0aW9uKGEpe3JldHVybiBhPT1udWxsPyIiOmE9PSIiP251bGw6KGE9YS5yZXBsYWNlKC8gL2csIisiKSx1Ll9kZWNvbXByZXNzKGEubGVuZ3RoLDMyLGZ1bmN0aW9uKGQpe3JldHVybiBoKGksYS5jaGFyQXQoZCkpfSkpfSxjb21wcmVzczpmdW5jdGlvbihhKXtyZXR1cm4gdS5fY29tcHJlc3MoYSwxNixmdW5jdGlvbihkKXtyZXR1cm4gdChkKX0pfSxfY29tcHJlc3M6ZnVuY3Rpb24oYSxkLEUpe2lmKGE9PW51bGwpcmV0dXJuIiI7dmFyIHAsTyxtPXt9LGI9e30sTT0iIix5PSIiLFM9IiIscz0yLGM9MyxsPTIsdj1bXSxUPTAsUj0wLEw7Zm9yKEw9MDtMPGEubGVuZ3RoO0wrPTEpaWYoTT1hLmNoYXJBdChMKSxPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobSxNKXx8KG1bTV09YysrLGJbTV09ITApLHk9UytNLE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtLHkpKVM9eTtlbHNle2lmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLFMpKXtpZihTLmNoYXJDb2RlQXQoMCk8MjU2KXtmb3IocD0wO3A8bDtwKyspVD1UPDwxLFI9PWQtMT8oUj0wLHYucHVzaChFKFQpKSxUPTApOlIrKztmb3IoTz1TLmNoYXJDb2RlQXQoMCkscD0wO3A8ODtwKyspVD1UPDwxfE8mMSxSPT1kLTE/KFI9MCx2LnB1c2goRShUKSksVD0wKTpSKyssTz1PPj4xfWVsc2V7Zm9yKE89MSxwPTA7cDxsO3ArKylUPVQ8PDF8TyxSPT1kLTE/KFI9MCx2LnB1c2goRShUKSksVD0wKTpSKyssTz0wO2ZvcihPPVMuY2hhckNvZGVBdCgwKSxwPTA7cDwxNjtwKyspVD1UPDwxfE8mMSxSPT1kLTE/KFI9MCx2LnB1c2goRShUKSksVD0wKTpSKyssTz1PPj4xfXMtLSxzPT0wJiYocz1NYXRoLnBvdygyLGwpLGwrKyksZGVsZXRlIGJbU119ZWxzZSBmb3IoTz1tW1NdLHA9MDtwPGw7cCsrKVQ9VDw8MXxPJjEsUj09ZC0xPyhSPTAsdi5wdXNoKEUoVCkpLFQ9MCk6UisrLE89Tz4+MTtzLS0scz09MCYmKHM9TWF0aC5wb3coMixsKSxsKyspLG1beV09YysrLFM9U3RyaW5nKE0pfWlmKFMhPT0iIil7aWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsUykpe2lmKFMuY2hhckNvZGVBdCgwKTwyNTYpe2ZvcihwPTA7cDxsO3ArKylUPVQ8PDEsUj09ZC0xPyhSPTAsdi5wdXNoKEUoVCkpLFQ9MCk6UisrO2ZvcihPPVMuY2hhckNvZGVBdCgwKSxwPTA7cDw4O3ArKylUPVQ8PDF8TyYxLFI9PWQtMT8oUj0wLHYucHVzaChFKFQpKSxUPTApOlIrKyxPPU8+PjF9ZWxzZXtmb3IoTz0xLHA9MDtwPGw7cCsrKVQ9VDw8MXxPLFI9PWQtMT8oUj0wLHYucHVzaChFKFQpKSxUPTApOlIrKyxPPTA7Zm9yKE89Uy5jaGFyQ29kZUF0KDApLHA9MDtwPDE2O3ArKylUPVQ8PDF8TyYxLFI9PWQtMT8oUj0wLHYucHVzaChFKFQpKSxUPTApOlIrKyxPPU8+PjF9cy0tLHM9PTAmJihzPU1hdGgucG93KDIsbCksbCsrKSxkZWxldGUgYltTXX1lbHNlIGZvcihPPW1bU10scD0wO3A8bDtwKyspVD1UPDwxfE8mMSxSPT1kLTE/KFI9MCx2LnB1c2goRShUKSksVD0wKTpSKyssTz1PPj4xO3MtLSxzPT0wJiYocz1NYXRoLnBvdygyLGwpLGwrKyl9Zm9yKE89MixwPTA7cDxsO3ArKylUPVQ8PDF8TyYxLFI9PWQtMT8oUj0wLHYucHVzaChFKFQpKSxUPTApOlIrKyxPPU8+PjE7Zm9yKDs7KWlmKFQ9VDw8MSxSPT1kLTEpe3YucHVzaChFKFQpKTticmVha31lbHNlIFIrKztyZXR1cm4gdi5qb2luKCIiKX0sZGVjb21wcmVzczpmdW5jdGlvbihhKXtyZXR1cm4gYT09bnVsbD8iIjphPT0iIj9udWxsOnUuX2RlY29tcHJlc3MoYS5sZW5ndGgsMzI3NjgsZnVuY3Rpb24oZCl7cmV0dXJuIGEuY2hhckNvZGVBdChkKX0pfSxfZGVjb21wcmVzczpmdW5jdGlvbihhLGQsRSl7dmFyIHA9W10sTz00LG09NCxiPTMsTT0iIix5PVtdLFMscyxjLGwsdixULFIsTD17dmFsOkUoMCkscG9zaXRpb246ZCxpbmRleDoxfTtmb3IoUz0wO1M8MztTKz0xKXBbU109Uztmb3IoYz0wLHY9TWF0aC5wb3coMiwyKSxUPTE7VCE9djspbD1MLnZhbCZMLnBvc2l0aW9uLEwucG9zaXRpb24+Pj0xLEwucG9zaXRpb249PTAmJihMLnBvc2l0aW9uPWQsTC52YWw9RShMLmluZGV4KyspKSxjfD0obD4wPzE6MCkqVCxUPDw9MTtzd2l0Y2goYyl7Y2FzZSAwOmZvcihjPTAsdj1NYXRoLnBvdygyLDgpLFQ9MTtUIT12OylsPUwudmFsJkwucG9zaXRpb24sTC5wb3NpdGlvbj4+PTEsTC5wb3NpdGlvbj09MCYmKEwucG9zaXRpb249ZCxMLnZhbD1FKEwuaW5kZXgrKykpLGN8PShsPjA/MTowKSpULFQ8PD0xO1I9dChjKTticmVhaztjYXNlIDE6Zm9yKGM9MCx2PU1hdGgucG93KDIsMTYpLFQ9MTtUIT12OylsPUwudmFsJkwucG9zaXRpb24sTC5wb3NpdGlvbj4+PTEsTC5wb3NpdGlvbj09MCYmKEwucG9zaXRpb249ZCxMLnZhbD1FKEwuaW5kZXgrKykpLGN8PShsPjA/MTowKSpULFQ8PD0xO1I9dChjKTticmVhaztjYXNlIDI6cmV0dXJuIiJ9Zm9yKHBbM109UixzPVIseS5wdXNoKFIpOzspe2lmKEwuaW5kZXg+YSlyZXR1cm4iIjtmb3IoYz0wLHY9TWF0aC5wb3coMixiKSxUPTE7VCE9djspbD1MLnZhbCZMLnBvc2l0aW9uLEwucG9zaXRpb24+Pj0xLEwucG9zaXRpb249PTAmJihMLnBvc2l0aW9uPWQsTC52YWw9RShMLmluZGV4KyspKSxjfD0obD4wPzE6MCkqVCxUPDw9MTtzd2l0Y2goUj1jKXtjYXNlIDA6Zm9yKGM9MCx2PU1hdGgucG93KDIsOCksVD0xO1QhPXY7KWw9TC52YWwmTC5wb3NpdGlvbixMLnBvc2l0aW9uPj49MSxMLnBvc2l0aW9uPT0wJiYoTC5wb3NpdGlvbj1kLEwudmFsPUUoTC5pbmRleCsrKSksY3w9KGw+MD8xOjApKlQsVDw8PTE7cFttKytdPXQoYyksUj1tLTEsTy0tO2JyZWFrO2Nhc2UgMTpmb3IoYz0wLHY9TWF0aC5wb3coMiwxNiksVD0xO1QhPXY7KWw9TC52YWwmTC5wb3NpdGlvbixMLnBvc2l0aW9uPj49MSxMLnBvc2l0aW9uPT0wJiYoTC5wb3NpdGlvbj1kLEwudmFsPUUoTC5pbmRleCsrKSksY3w9KGw+MD8xOjApKlQsVDw8PTE7cFttKytdPXQoYyksUj1tLTEsTy0tO2JyZWFrO2Nhc2UgMjpyZXR1cm4geS5qb2luKCIiKX1pZihPPT0wJiYoTz1NYXRoLnBvdygyLGIpLGIrKykscFtSXSlNPXBbUl07ZWxzZSBpZihSPT09bSlNPXMrcy5jaGFyQXQoMCk7ZWxzZSByZXR1cm4gbnVsbDt5LnB1c2goTSkscFttKytdPXMrTS5jaGFyQXQoMCksTy0tLHM9TSxPPT0wJiYoTz1NYXRoLnBvdygyLGIpLGIrKyl9fX07cmV0dXJuIHV9KCk7ZyE9bnVsbD9nLmV4cG9ydHM9ZTp0eXBlb2YgYW5ndWxhcjwidSImJmFuZ3VsYXIhPW51bGwmJmFuZ3VsYXIubW9kdWxlKCJMWlN0cmluZyIsW10pLmZhY3RvcnkoIkxaU3RyaW5nIixmdW5jdGlvbigpe3JldHVybiBlfSl9KHZzKTt2YXIgRmE9dnMuZXhwb3J0cztmdW5jdGlvbiBzaShnKXtyZXR1cm4gSlNPTi5wYXJzZShGYS5kZWNvbXByZXNzKGcpKX1mdW5jdGlvbiB5cihnKXtyZXR1cm4gRmEuY29tcHJlc3MoSlNPTi5zdHJpbmdpZnkoZykpfWNsYXNzIGphIGV4dGVuZHMgRHR7Y29uc3RydWN0b3IoZSl7c3VwZXIoZSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImNhblJvdGF0ZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInNjYWxlVHlwZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOiRlLmFsbH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ0b29sc1R5cGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpMdC5QZW5jaWx9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywic3luY1RpbWVzdGFtcCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzeW5jSW5kZXgiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTowfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInRtcFBvaW50cyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOltdfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIk1BWF9SRVBFQVIiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZToxMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ1bmlUaGlja25lc3MiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywid29ya09wdGlvbnMiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiY2VudGVyUG9zIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6WzAsMF19KSx0aGlzLndvcmtPcHRpb25zPWUudG9vbHNPcHQsdGhpcy51bmlUaGlja25lc3M9dGhpcy5NQVhfUkVQRUFSL3RoaXMud29ya09wdGlvbnMudGhpY2tuZXNzLzEwLHRoaXMuc3luY1RpbWVzdGFtcD0wfWNvbWJpbmVDb25zdW1lKCl7dmFyIGg7Y29uc3QgZT0oaD10aGlzLndvcmtJZCk9PW51bGw/dm9pZCAwOmgudG9TdHJpbmcoKSx0PXRoaXMudHJhbnNmb3JtRGF0YUFsbCghMCksbj17bmFtZTplfTtsZXQgaTtjb25zdCBmPXRoaXMuZHJhd0xheWVyfHx0aGlzLmZ1bGxMYXllcjtyZXR1cm4gdC5sZW5ndGgmJihpPXRoaXMuZHJhdyh7YXR0cnM6bix0YXNrczp0LHJlcGxhY2VJZDplLGxheWVyOmYsaXNDbGVhckFsbDohMH0pKSx7cmVjdDppLHR5cGU6VHQuRHJhd1dvcmssZGF0YVR5cGU6enQuTG9jYWx9fXNldFdvcmtPcHRpb25zKGUpe3N1cGVyLnNldFdvcmtPcHRpb25zKGUpLHRoaXMuc3luY1RpbWVzdGFtcD1EYXRlLm5vdygpfWNvbnN1bWUoZSl7dmFyIE07Y29uc3R7ZGF0YTp0LGlzRnVsbFdvcms6bixpc0NsZWFyQWxsOmksaXNTdWJXb3JrZXI6Zn09ZTtpZigoKE09dC5vcCk9PW51bGw/dm9pZCAwOk0ubGVuZ3RoKT09PTApcmV0dXJue3R5cGU6VHQuTm9uZX07Y29uc3R7d29ya0lkOmh9PXQse3Rhc2tzOnUsZWZmZWN0czphLGNvbnN1bWVJbmRleDpkfT10aGlzLnRyYW5zZm9ybURhdGEodCwhMSk7dGhpcy5zeW5jSW5kZXg9TWF0aC5taW4odGhpcy5zeW5jSW5kZXgsZCk7Y29uc3QgRT17bmFtZTpoPT1udWxsP3ZvaWQgMDpoLnRvU3RyaW5nKCl9O2xldCBwLE89ITE7Y29uc3QgbT10aGlzLnN5bmNJbmRleDtpZih0aGlzLnN5bmNUaW1lc3RhbXA9PT0wJiYodGhpcy5zeW5jVGltZXN0YW1wPURhdGUubm93KCkpLHUubGVuZ3RoJiYodVswXS50YXNrSWQtdGhpcy5zeW5jVGltZXN0YW1wPnRoaXMuc3luY1VuaXRUaW1lJiYoTz0hMCx0aGlzLnN5bmNUaW1lc3RhbXA9dVswXS50YXNrSWQsdGhpcy5zeW5jSW5kZXg9dGhpcy50bXBQb2ludHMubGVuZ3RoKSxmKSl7Y29uc3QgeT1uP3RoaXMuZnVsbExheWVyOnRoaXMuZHJhd0xheWVyfHx0aGlzLmZ1bGxMYXllcjtwPXRoaXMuZHJhdyh7YXR0cnM6RSx0YXNrczp1LGVmZmVjdHM6YSxsYXllcjp5LGlzQ2xlYXJBbGw6aX0pfWlmKGYpcmV0dXJuIGQ+MTAmJnRoaXMudG1wUG9pbnRzLnNwbGljZSgwLGQtMTApLHtyZWN0OnAsdHlwZTpUdC5EcmF3V29yayxkYXRhVHlwZTp6dC5Mb2NhbH07Y29uc3QgYj1bXTtyZXR1cm4gdGhpcy50bXBQb2ludHMuc2xpY2UobSkuZm9yRWFjaCh5PT57Yi5wdXNoKHkueCx5LnksdGhpcy5jb21wdXRSYWRpdXMoeS56LHRoaXMud29ya09wdGlvbnMudGhpY2tuZXNzKSl9KSx7cmVjdDpwLHR5cGU6VHQuRHJhd1dvcmssZGF0YVR5cGU6enQuTG9jYWwsd29ya0lkOk8/aDp2b2lkIDAsb3A6Tz9iOnZvaWQgMCxpbmRleDpPP20qMzp2b2lkIDB9fWNvbnN1bWVBbGwoZSl7dmFyIGQsRTtpZihlLmRhdGEpe2NvbnN0e29wOnAsd29ya1N0YXRlOk99PWUuZGF0YTtwIT1udWxsJiZwLmxlbmd0aCYmTz09PWNlLkRvbmUmJnRoaXMud29ya09wdGlvbnMuc3Ryb2tlVHlwZT09PVJlLlN0cm9rZSYmdGhpcy51cGRhdGVUZW1wUG9pbnRzV2l0aFByZXNzdXJlV2hlbkRvbmUocCl9Y29uc3QgdD0oZD10aGlzLndvcmtJZCk9PW51bGw/dm9pZCAwOmQudG9TdHJpbmcoKTtpZighdClyZXR1cm57dHlwZTpUdC5Ob25lfTtjb25zdCBuPXRoaXMudHJhbnNmb3JtRGF0YUFsbCghMCksaT17bmFtZTp0fTtsZXQgZjtjb25zdCBoPXRoaXMuZnVsbExheWVyO24ubGVuZ3RoJiYoZj10aGlzLmRyYXcoe2F0dHJzOmksdGFza3M6bixyZXBsYWNlSWQ6dCxsYXllcjpoLGlzQ2xlYXJBbGw6ITF9KSk7Y29uc3QgdT1bXTt0aGlzLnRtcFBvaW50cy5tYXAocD0+e3UucHVzaChwLngscC55LHRoaXMuY29tcHV0UmFkaXVzKHAueix0aGlzLndvcmtPcHRpb25zLnRoaWNrbmVzcykpfSksdGhpcy5zeW5jVGltZXN0YW1wPTAsZGVsZXRlIHRoaXMud29ya09wdGlvbnMuc3luY1VuaXRUaW1lO2NvbnN0IGE9eXIodSk7cmV0dXJuIHRoaXMudk5vZGVzLnNldEluZm8odCx7cmVjdDpmLG9wOnUsb3B0OnRoaXMud29ya09wdGlvbnMsdG9vbHNUeXBlOnRoaXMudG9vbHNUeXBlLHNjYWxlVHlwZTp0aGlzLnNjYWxlVHlwZSxjYW5Sb3RhdGU6dGhpcy5jYW5Sb3RhdGUsY2VudGVyUG9zOmYmJkR0LmdldENlbnRlclBvcyhmLGgpfSkse3JlY3Q6Zix0eXBlOlR0LkZ1bGxXb3JrLGRhdGFUeXBlOnp0LkxvY2FsLHdvcmtJZDp0LG9wczphLHVwZGF0ZU5vZGVPcHQ6e3Bvczp0aGlzLmNlbnRlclBvcyx1c2VBbmltYXRpb246ITB9LG9wdDp0aGlzLndvcmtPcHRpb25zLHVuZG9UaWNrZXJJZDooRT1lLmRhdGEpPT1udWxsP3ZvaWQgMDpFLnVuZG9UaWNrZXJJZH19Y2xlYXJUbXBQb2ludHMoKXt0aGlzLnRtcFBvaW50cy5sZW5ndGg9MCx0aGlzLnN5bmNUaW1lc3RhbXA9MCx0aGlzLnN5bmNJbmRleD0wfWNvbnN1bWVTZXJ2aWNlKGUpe3ZhciBFO2NvbnN0e29wOnQsaXNGdWxsV29yazpuLHJlcGxhY2VJZDppLGlzQ2xlYXJBbGw6Zn09ZTt0aGlzLnRtcFBvaW50cy5sZW5ndGg9MDtmb3IobGV0IHA9MDtwPHQubGVuZ3RoO3ArPTMpe2NvbnN0IE89bmV3IEZ0KHRbcF0sdFtwKzFdLHRbcCsyXSk7aWYodGhpcy50bXBQb2ludHMubGVuZ3RoPjApe2NvbnN0IG09dGhpcy50bXBQb2ludHNbdGhpcy50bXBQb2ludHMubGVuZ3RoLTFdLGI9RXQuU3ViKE8sbSkudW5pKCk7Ty5zZXR2KGIpfXRoaXMudG1wUG9pbnRzLnB1c2goTyl9Y29uc3QgaD10aGlzLnRyYW5zZm9ybURhdGFBbGwoITEpLHU9KEU9dGhpcy53b3JrSWQpPT1udWxsP3ZvaWQgMDpFLnRvU3RyaW5nKCksYT17bmFtZTp1fTtsZXQgZDtpZih1JiZoLmxlbmd0aCl7Y29uc3QgcD1uP3RoaXMuZnVsbExheWVyOnRoaXMuZHJhd0xheWVyfHx0aGlzLmZ1bGxMYXllcjtkPXRoaXMuZHJhdyh7YXR0cnM6YSx0YXNrczpoLHJlcGxhY2VJZDppLGxheWVyOnAsaXNDbGVhckFsbDpmfSksdGhpcy52Tm9kZXMuc2V0SW5mbyh1LHtyZWN0OmQsb3A6dCxvcHQ6dGhpcy53b3JrT3B0aW9ucyx0b29sc1R5cGU6dGhpcy50b29sc1R5cGUsc2NhbGVUeXBlOnRoaXMuc2NhbGVUeXBlLGNhblJvdGF0ZTp0aGlzLmNhblJvdGF0ZSxjZW50ZXJQb3M6ZCYmRHQuZ2V0Q2VudGVyUG9zKGQscCl9KX1yZXR1cm4gZH10cmFuc2Zvcm1EYXRhQWxsKGU9ITApe3JldHVybiB0aGlzLmdldFRhc2tQb2ludHModGhpcy50bXBQb2ludHMsZSYmdGhpcy53b3JrT3B0aW9ucy50aGlja25lc3N8fHZvaWQgMCl9ZHJhdyhlKXt2YXIgbDtjb25zdHthdHRyczp0LHRhc2tzOm4scmVwbGFjZUlkOmksZWZmZWN0czpmLGxheWVyOmgsaXNDbGVhckFsbDp1fT1lLHtzdHJva2VDb2xvcjphLHN0cm9rZVR5cGU6ZCx0aGlja25lc3M6RSx6SW5kZXg6cCxzY2FsZTpPLHJvdGF0ZTptLHRyYW5zbGF0ZTpifT10aGlzLndvcmtPcHRpb25zO3UmJmgucmVtb3ZlQWxsQ2hpbGRyZW4oKSxpJiYodGhpcy5mdWxsTGF5ZXIuZ2V0RWxlbWVudHNCeU5hbWUoaSsiIikubWFwKHY9PnYucmVtb3ZlKCkpLChsPXRoaXMuZHJhd0xheWVyKT09bnVsbHx8bC5nZXRFbGVtZW50c0J5TmFtZShpKyIiKS5tYXAodj0+di5yZW1vdmUoKSkpLGYhPW51bGwmJmYuc2l6ZSYmKGYuZm9yRWFjaCh2PT57dmFyIFQ7KFQ9aC5nZXRFbGVtZW50QnlJZCh2KyIiKSk9PW51bGx8fFQucmVtb3ZlKCl9KSxmLmNsZWFyKCkpO2xldCBNO2NvbnN0IHk9W10sUz1oLndvcmxkUG9zaXRpb24scz1oLndvcmxkU2NhbGluZztmb3IobGV0IHY9MDt2PG4ubGVuZ3RoO3YrKyl7Y29uc3R7cG9zOlQscG9pbnRzOlIsdGFza0lkOkx9PW5bdl07dC5pZD1MLnRvU3RyaW5nKCk7Y29uc3R7cHM6TixyZWN0OkF9PXRoaXMuY29tcHV0RHJhd1BvaW50cyhSKTtsZXQgdztjb25zdCBCPVIubGVuZ3RoPT09MTtkPT09UmUuU3Ryb2tlfHxCP3c9aG4oTiwhMCk6dz1obihOLCExKTtjb25zdCBEPXtwb3M6VCxkOncsZmlsbENvbG9yOmQ9PT1SZS5TdHJva2V8fEI/YTp2b2lkIDAsbGluZURhc2g6ZD09PVJlLkRvdHRlZCYmIUI/WzEsRSoyXTpkPT09UmUuTG9uZ0RvdHRlZCYmIUI/W0UsRSoyXTp2b2lkIDAsc3Ryb2tlQ29sb3I6YSxsaW5lQ2FwOmQ9PT1SZS5TdHJva2V8fEI/dm9pZCAwOiJyb3VuZCIsbGluZVdpZHRoOmQ9PT1SZS5TdHJva2V8fEI/MDpFfTtNPSR0KE0se3g6TWF0aC5mbG9vcigoQS54K1RbMF0pKnNbMF0rU1swXS1EdC5TYWZlQm9yZGVyUGFkZGluZykseTpNYXRoLmZsb29yKChBLnkrVFsxXSkqc1sxXStTWzFdLUR0LlNhZmVCb3JkZXJQYWRkaW5nKSx3Ok1hdGguZmxvb3IoQS53KnNbMF0rMipEdC5TYWZlQm9yZGVyUGFkZGluZyksaDpNYXRoLmZsb29yKEEuaCpzWzFdKzIqRHQuU2FmZUJvcmRlclBhZGRpbmcpfSkseS5wdXNoKEQpfU8mJih0LnNjYWxlPU8pLG0mJih0LnJvdGF0ZT1tKSxiJiYodC50cmFuc2xhdGU9Yik7Y29uc3QgYz1uZXcgSXI7aWYoTSl7dGhpcy5jZW50ZXJQb3M9RHQuZ2V0Q2VudGVyUG9zKE0saCksYy5hdHRyKHsuLi50LG5vcm1hbGl6ZTohMCxpZDp0Lm5hbWUsYW5jaG9yOlsuNSwuNV0sYmdjb2xvcjpkPT09UmUuU3Ryb2tlP2E6dm9pZCAwLHBvczp0aGlzLmNlbnRlclBvcyxzaXplOlsoTS53LTIqRHQuU2FmZUJvcmRlclBhZGRpbmcpL3NbMF0sKE0uaC0yKkR0LlNhZmVCb3JkZXJQYWRkaW5nKS9zWzFdXSx6SW5kZXg6cH0pO2NvbnN0IHY9eS5tYXAoVD0+KFQucG9zPVtULnBvc1swXS10aGlzLmNlbnRlclBvc1swXSxULnBvc1sxXS10aGlzLmNlbnRlclBvc1sxXV0sbmV3IEhyKFQpKSk7Yy5hcHBlbmQoLi4udiksZD09PVJlLlN0cm9rZSYmYy5zZWFsKCksaC5hcHBlbmQoYyl9aWYoT3x8bXx8Yil7Y29uc3Qgdj1jPT1udWxsP3ZvaWQgMDpjLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO2lmKHYpcmV0dXJue3g6TWF0aC5mbG9vcih2LngtRHQuU2FmZUJvcmRlclBhZGRpbmcpLHk6TWF0aC5mbG9vcih2LnktRHQuU2FmZUJvcmRlclBhZGRpbmcpLHc6TWF0aC5mbG9vcih2LndpZHRoK0R0LlNhZmVCb3JkZXJQYWRkaW5nKjIpLGg6TWF0aC5mbG9vcih2LmhlaWdodCtEdC5TYWZlQm9yZGVyUGFkZGluZyoyKX19cmV0dXJuIE19Y29tcHV0RHJhd1BvaW50cyhlKXtyZXR1cm4gdGhpcy53b3JrT3B0aW9ucy5zdHJva2VUeXBlPT09UmUuU3Ryb2tlfHxlLmxlbmd0aD09PTE/dGhpcy5jb21wdXRTdHJva2UoZSk6dGhpcy5jb21wdXROb21hbChlKX1jb21wdXROb21hbChlKXtsZXQgdD10aGlzLndvcmtPcHRpb25zLnRoaWNrbmVzcztjb25zdCBuPWUubWFwKGk9Pih0PU1hdGgubWF4KHQsaS5yYWRpdXMpLGkucG9pbnQpKTtyZXR1cm57cHM6bixyZWN0OnhlKG4sdCl9fWNvbXB1dFN0cm9rZShlKXtyZXR1cm4gZS5sZW5ndGg9PT0xP3RoaXMuY29tcHV0RG90U3Ryb2tlKGVbMF0pOnRoaXMuY29tcHV0TGluZVN0cm9rZShlKX1jb21wdXRMaW5lU3Ryb2tlKGUpe2NvbnN0IHQ9W10sbj1bXTtmb3IobGV0IGE9MDthPGUubGVuZ3RoO2ErKyl7Y29uc3R7cG9pbnQ6ZCxyYWRpdXM6RX09ZVthXTtsZXQgcD1kLnY7YT09PTAmJmUubGVuZ3RoPjEmJihwPWVbYSsxXS5wb2ludC52KTtjb25zdCBPPUV0LlBlcihwKS5tdWwoRSk7dC5wdXNoKEZ0LlN1YihkLE8pKSxuLnB1c2goRnQuQWRkKGQsTykpfWNvbnN0IGk9ZVtlLmxlbmd0aC0xXSxmPUZ0LkdldFNlbWljaXJjbGVTdHJva2UoaS5wb2ludCx0W3QubGVuZ3RoLTFdLC0xLDgpLGg9RnQuR2V0U2VtaWNpcmNsZVN0cm9rZShlWzBdLnBvaW50LG5bMF0sLTEsOCksdT10LmNvbmNhdChmLG4ucmV2ZXJzZSgpLGgpO3JldHVybntwczp1LHJlY3Q6eGUodSl9fWNvbXB1dERvdFN0cm9rZShlKXtjb25zdHtwb2ludDp0LHJhZGl1czpufT1lLGk9e3g6dC54LW4seTp0Lnktbix3Om4qMixoOm4qMn07cmV0dXJue3BzOkZ0LkdldERvdFN0cm9rZSh0LG4sOCkscmVjdDppfX10cmFuc2Zvcm1EYXRhKGUsdCl7Y29uc3R7b3A6bix3b3JrU3RhdGU6aX09ZTtsZXQgZj10aGlzLnRtcFBvaW50cy5sZW5ndGgtMSxoPVtdO2lmKG4hPW51bGwmJm4ubGVuZ3RoJiZpKXtjb25zdHtzdHJva2VUeXBlOnUsdGhpY2tuZXNzOmF9PXRoaXMud29ya09wdGlvbnMsZD1uZXcgU2V0O2Y9dT09PVJlLlN0cm9rZT90aGlzLnVwZGF0ZVRlbXBQb2ludHNXaXRoUHJlc3N1cmUobixhLGQpOnRoaXMudXBkYXRlVGVtcFBvaW50cyhuLGEsZCk7Y29uc3QgRT10P3RoaXMudG1wUG9pbnRzOnRoaXMudG1wUG9pbnRzLnNsaWNlKGYpO3JldHVybiBoPXRoaXMuZ2V0VGFza1BvaW50cyhFLGEpLHt0YXNrczpoLGVmZmVjdHM6ZCxjb25zdW1lSW5kZXg6Zn19cmV0dXJue3Rhc2tzOmgsY29uc3VtZUluZGV4OmZ9fWNvbXB1dFJhZGl1cyhlLHQpe3JldHVybiBlKi4wMyp0K3QqLjV9Z2V0TWluWihlLHQpe3JldHVybigodHx8TWF0aC5tYXgoMSxNYXRoLmZsb29yKGUqLjMpKSktZSouNSkqMTAwL2UvM31nZXRUYXNrUG9pbnRzKGUsdCl7dmFyIEU7Y29uc3Qgbj1bXTtpZihlLmxlbmd0aD09PTApcmV0dXJuW107bGV0IGk9MCxmPWVbMF0ueCxoPWVbMF0ueSx1PVtmLGhdLGE9W10sZD1lWzBdLnQ7Zm9yKDtpPGUubGVuZ3RoOyl7Y29uc3QgcD1lW2ldLE89cC54LWYsbT1wLnktaCxiPXAueixNPXQ/dGhpcy5jb21wdXRSYWRpdXMoYix0KTpiO2lmKGEucHVzaCh7cG9pbnQ6bmV3IEZ0KE8sbSxiLGVbaV0udikscmFkaXVzOk19KSxpPjAmJmk8ZS5sZW5ndGgtMSl7Y29uc3QgeT1lW2ldLmdldEFuZ2xlQnlQb2ludHMoZVtpLTFdLGVbaSsxXSk7aWYoeTw5MHx8eT4yNzApe2NvbnN0IFM9KEU9YS5wb3AoKSk9PW51bGw/dm9pZCAwOkUucG9pbnQuY2xvbmUoKTtTJiZuLnB1c2goe3Rhc2tJZDpkLHBvczp1LHBvaW50czpbLi4uYSx7cG9pbnQ6UyxyYWRpdXM6TX1dfSksZj1lW2ldLngsaD1lW2ldLnksdT1bZixoXTtjb25zdCBzPXAueC1mLGM9cC55LWg7YT1be3BvaW50Om5ldyBGdChzLGMsYikscmFkaXVzOk19XSxkPURhdGUubm93KCl9fWkrK31yZXR1cm4gbi5wdXNoKHt0YXNrSWQ6ZCxwb3M6dSxwb2ludHM6YX0pLG59dXBkYXRlVGVtcFBvaW50c1dpdGhQcmVzc3VyZShlLHQsbil7Y29uc3QgaT1EYXRlLm5vdygpLGY9dGhpcy50bXBQb2ludHMubGVuZ3RoO2xldCBoPWY7Zm9yKGxldCBhPTA7YTxlLmxlbmd0aDthKz0yKXtoPU1hdGgubWluKGgsZik7Y29uc3QgZD10aGlzLnRtcFBvaW50cy5sZW5ndGgsRT1uZXcgRnQoZVthXSxlW2ErMV0pO2lmKGQ9PT0wKXt0aGlzLnRtcFBvaW50cy5wdXNoKEUpO2NvbnRpbnVlfWNvbnN0IHA9ZC0xLE89dGhpcy50bXBQb2ludHNbcF0sbT1FdC5TdWIoRSxPKS51bmkoKTtpZihFLmlzTmVhcihPLHQpKXtpZihPLno8dGhpcy5NQVhfUkVQRUFSKXtpZihPLnNldHooTWF0aC5taW4oTy56KzEsdGhpcy5NQVhfUkVQRUFSKSksaD1NYXRoLm1pbihoLHApLGQ+MSl7bGV0IHk9ZC0xO2Zvcig7eT4wOyl7Y29uc3QgUz10aGlzLnRtcFBvaW50c1t5XS5kaXN0YW5jZSh0aGlzLnRtcFBvaW50c1t5LTFdKSxzPU1hdGgubWF4KHRoaXMudG1wUG9pbnRzW3ldLnotdGhpcy51bmlUaGlja25lc3MqUywwKTtpZih0aGlzLnRtcFBvaW50c1t5LTFdLno+PXMpYnJlYWs7dGhpcy50bXBQb2ludHNbeS0xXS5zZXR6KHMpLGg9TWF0aC5taW4oaCx5LTEpLHktLX19fWVsc2UgaD0xLzA7Y29udGludWV9RS5zZXR2KG0pO2NvbnN0IGI9RS5kaXN0YW5jZShPKSxNPU1hdGgubWF4KE8uei10aGlzLnVuaVRoaWNrbmVzcypiLDApO2Q+MSYmRXQuRXF1YWxzKG0sTy52LC4wMikmJihNPjB8fE8uejw9MCkmJihuJiZPLnQmJm4uYWRkKE8udCksdGhpcy50bXBQb2ludHMucG9wKCksaD1NYXRoLm1pbihwLGgpKSxFLnNldHooTSksdGhpcy50bXBQb2ludHMucHVzaChFKX1pZihoPT09MS8wKXJldHVybiB0aGlzLnRtcFBvaW50cy5sZW5ndGg7bGV0IHU9ZjtpZihoPT09Zil7dT1NYXRoLm1heCh1LTEsMCk7Y29uc3QgYT10aGlzLnRtcFBvaW50c1t1XS50O2EmJihuPT1udWxsfHxuLmFkZChhKSl9ZWxzZXtsZXQgYT1mLTE7Zm9yKHU9aDthPj0wOyl7Y29uc3QgZD10aGlzLnRtcFBvaW50c1thXS50O2lmKGQmJihuPT1udWxsfHxuLmFkZChkKSxhPD1oKSl7dT1hLGE9LTE7YnJlYWt9YS0tfX1yZXR1cm4gdGhpcy50bXBQb2ludHNbdV0uc2V0VChpKSx1fXVwZGF0ZVRlbXBQb2ludHMoZSx0LG4pe3ZhciBhO2NvbnN0IGk9RGF0ZS5ub3coKSxmPXRoaXMudG1wUG9pbnRzLmxlbmd0aDtsZXQgaD1mO2ZvcihsZXQgZD0wO2Q8ZS5sZW5ndGg7ZCs9Mil7Y29uc3QgRT10aGlzLnRtcFBvaW50cy5sZW5ndGgscD1uZXcgRnQoZVtkXSxlW2QrMV0pO2lmKEU9PT0wKXt0aGlzLnRtcFBvaW50cy5wdXNoKHApO2NvbnRpbnVlfWNvbnN0IE89RS0xLG09dGhpcy50bXBQb2ludHNbT10sYj1FdC5TdWIocCxtKS51bmkoKTtpZihFdC5FcXVhbHMoYixtLnYsLjAyKSl7biYmbS50JiZuLmFkZChtLnQpLHRoaXMudG1wUG9pbnRzLnBvcCgpLGg9TWF0aC5taW4oTyxoKTtjb250aW51ZX1pZihwLmlzTmVhcihtLHQvMikpe2g9TWF0aC5taW4oTyxoKTtjb250aW51ZX1wLnNldHYoYiksdGhpcy50bXBQb2ludHMucHVzaChwKX1sZXQgdT1mO2lmKGg9PT1mKXt1PU1hdGgubWF4KHUtMSwwKTtjb25zdCBkPXRoaXMudG1wUG9pbnRzW3VdLnQ7ZCYmKG49PW51bGx8fG4uYWRkKGQpKX1lbHNle2xldCBkPU1hdGgubWluKGYtMSxoKTtmb3IodT1oO2Q+PTA7KXtjb25zdCBFPShhPXRoaXMudG1wUG9pbnRzW2RdKT09bnVsbD92b2lkIDA6YS50O2lmKEUmJihuPT1udWxsfHxuLmFkZChFKSxkPD1oKSl7dT1kLGQ9LTE7YnJlYWt9ZC0tfX1yZXR1cm4gdGhpcy50bXBQb2ludHNbdV0uc2V0VChpKSx1fXVwZGF0ZVRlbXBQb2ludHNXaXRoUHJlc3N1cmVXaGVuRG9uZShlKXtjb25zdHt0aGlja25lc3M6dH09dGhpcy53b3JrT3B0aW9ucyxuPWUubGVuZ3RoLGk9dGhpcy5nZXRNaW5aKHQpO2ZvcihsZXQgZj0wO2Y8bjtmKz0yKXtjb25zdCBoPXRoaXMudG1wUG9pbnRzLmxlbmd0aCx1PW5ldyBGdChlW2ZdLGVbZisxXSk7aWYoaD09PTApe3RoaXMudG1wUG9pbnRzLnB1c2godSk7Y29udGludWV9Y29uc3QgYT1oLTEsZD10aGlzLnRtcFBvaW50c1thXSxFPUV0LlN1Yih1LGQpLnVuaSgpLHA9dS5kaXN0YW5jZShkKTtpZihoPjEmJmQuej09PWkpYnJlYWs7aWYodS5pc05lYXIoZCx0LzIpKXtpZihuPDMmJmQuejx0aGlzLk1BWF9SRVBFQVImJihkLnNldHooTWF0aC5taW4oZC56KzEsdGhpcy5NQVhfUkVQRUFSKSksaD4xKSl7bGV0IG09aC0xO2Zvcig7bT4wOyl7Y29uc3QgYj10aGlzLnRtcFBvaW50c1ttXS5kaXN0YW5jZSh0aGlzLnRtcFBvaW50c1ttLTFdKSxNPU1hdGgubWF4KHRoaXMudG1wUG9pbnRzW21dLnotdGhpcy51bmlUaGlja25lc3MqYiwtdC80KTtpZih0aGlzLnRtcFBvaW50c1ttLTFdLno+PU0pYnJlYWs7dGhpcy50bXBQb2ludHNbbS0xXS5zZXR6KE0pLG0tLX19Y29udGludWV9dS5zZXR2KEUpO2NvbnN0IE89TWF0aC5tYXgoZC56LXRoaXMudW5pVGhpY2tuZXNzKnAsaSk7aD4xJiZFdC5FcXVhbHMoRSxkLnYsLjAyKSYmZC56PD0wJiZ0aGlzLnRtcFBvaW50cy5wb3AoKSx1LnNldHooTyksdGhpcy50bXBQb2ludHMucHVzaCh1KX19c3RhdGljIHVwZGF0ZU5vZGVPcHQoZSl7dmFyIHU7Y29uc3R7bm9kZTp0LG9wdDpuLHZOb2RlczppfT1lLHtzdHJva2VDb2xvcjpmfT1uLGg9aS5nZXQodC5uYW1lKTtyZXR1cm4gZiYmKHQudGFnTmFtZT09PSJHUk9VUCI/cmkodCk/dC5zZXRBdHRyaWJ1dGUoImJnY29sb3IiLGYpOnQuY2hpbGRyZW4uZm9yRWFjaChhPT57YS5zZXRBdHRyaWJ1dGUoInN0cm9rZUNvbG9yIixmKSxhLmdldEF0dHJpYnV0ZSgiZmlsbENvbG9yIikmJmEuc2V0QXR0cmlidXRlKCJmaWxsQ29sb3IiLGYpfSk6KHQuc2V0QXR0cmlidXRlKCJzdHJva2VDb2xvciIsZiksdC5zZXRBdHRyaWJ1dGUoImZpbGxDb2xvciIsZikpLCh1PWg9PW51bGw/dm9pZCAwOmgub3B0KSE9bnVsbCYmdS5zdHJva2VDb2xvciYmKGgub3B0LnN0cm9rZUNvbG9yPWYpKSxoJiZpLnNldEluZm8odC5uYW1lLGgpLER0LnVwZGF0ZU5vZGVPcHQoZSl9c3RhdGljIGdldFJlY3RGcm9tTGF5ZXIoZSx0KXtjb25zdCBuPWUuZ2V0RWxlbWVudHNCeU5hbWUodClbMF07aWYobil7Y29uc3QgaT1uLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO3JldHVybnt4Ok1hdGguZmxvb3IoaS54LUR0LlNhZmVCb3JkZXJQYWRkaW5nKSx5Ok1hdGguZmxvb3IoaS55LUR0LlNhZmVCb3JkZXJQYWRkaW5nKSx3Ok1hdGguZmxvb3IoaS53aWR0aCtEdC5TYWZlQm9yZGVyUGFkZGluZyoyKSxoOk1hdGguZmxvb3IoaS5oZWlnaHQrRHQuU2FmZUJvcmRlclBhZGRpbmcqMil9fX19Y2xhc3MgVWEgZXh0ZW5kcyBEdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihlKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidG9vbHNUeXBlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6THQuTGFzZXJQZW59KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiY2FuUm90YXRlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6ITF9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywic2NhbGVUeXBlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6JGUubm9uZX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzeW5jVGltZXN0YW1wIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInN5bmNJbmRleCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOjB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidG1wUG9pbnRzIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6W119KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywid29ya09wdGlvbnMiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiY29uc3VtZUluZGV4Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6MH0pLHRoaXMud29ya09wdGlvbnM9ZS50b29sc09wdCx0aGlzLnN5bmNUaW1lc3RhbXA9MH1jb21iaW5lQ29uc3VtZSgpe31zZXRXb3JrT3B0aW9ucyhlKXtzdXBlci5zZXRXb3JrT3B0aW9ucyhlKSx0aGlzLnN5bmNUaW1lc3RhbXA9RGF0ZS5ub3coKX1jb25zdW1lKGUpe2NvbnN0e2RhdGE6dCxpc0Z1bGxXb3JrOm59PWUse3dvcmtJZDppLG9wOmZ9PXQ7aWYoKGY9PW51bGw/dm9pZCAwOmYubGVuZ3RoKT09PTApcmV0dXJue3R5cGU6VHQuTm9uZX07aWYodGhpcy51cGRhdGVUZW1wUG9pbnRzKGZ8fFtdKSx0aGlzLmNvbnN1bWVJbmRleD50aGlzLnRtcFBvaW50cy5sZW5ndGgtNClyZXR1cm57dHlwZTpUdC5Ob25lfTtjb25zdHtzdHJva2VDb2xvcjpoLHRoaWNrbmVzczp1LHN0cm9rZVR5cGU6YX09dGhpcy53b3JrT3B0aW9ucyxkPXhlKHRoaXMudG1wUG9pbnRzLHUpO2xldCBFPSExO2NvbnN0IHA9dGhpcy5zeW5jSW5kZXgsTz10aGlzLnRtcFBvaW50cy5zbGljZSh0aGlzLmNvbnN1bWVJbmRleCk7dGhpcy5jb25zdW1lSW5kZXg9dGhpcy50bXBQb2ludHMubGVuZ3RoLTEsdGhpcy5zeW5jVGltZXN0YW1wPT09MCYmKHRoaXMuc3luY1RpbWVzdGFtcD1EYXRlLm5vdygpKTtjb25zdCBtPXtuYW1lOmk9PW51bGw/dm9pZCAwOmkudG9TdHJpbmcoKSxvcGFjaXR5OjEsbGluZURhc2g6YT09PVJlLkRvdHRlZD9bMSx1KjJdOmE9PT1SZS5Mb25nRG90dGVkP1t1LHUqMl06dm9pZCAwLHN0cm9rZUNvbG9yOmgsbGluZUNhcDoicm91bmQiLGxpbmVXaWR0aDp1LGFuY2hvcjpbLjUsLjVdfSxiPXRoaXMuZ2V0VGFza1BvaW50cyhPKTtpZihiLmxlbmd0aCl7Y29uc3QgeT1EYXRlLm5vdygpO3ktdGhpcy5zeW5jVGltZXN0YW1wPnRoaXMuc3luY1VuaXRUaW1lJiYoRT0hMCx0aGlzLnN5bmNUaW1lc3RhbXA9eSx0aGlzLnN5bmNJbmRleD10aGlzLnRtcFBvaW50cy5sZW5ndGgpLCFuJiZ0aGlzLmRyYXcoe2F0dHJzOm0sdGFza3M6Yixpc0RvdDohMX0pfWNvbnN0IE09W107cmV0dXJuIHRoaXMudG1wUG9pbnRzLnNsaWNlKHApLmZvckVhY2goeT0+e00ucHVzaCh5LngseS55KX0pLHtyZWN0Ont4OmQueCp0aGlzLmZ1bGxMYXllci53b3JsZFNjYWxpbmdbMF0rdGhpcy5mdWxsTGF5ZXIud29ybGRQb3NpdGlvblswXSx5OmQueSp0aGlzLmZ1bGxMYXllci53b3JsZFNjYWxpbmdbMV0rdGhpcy5mdWxsTGF5ZXIud29ybGRQb3NpdGlvblsxXSx3OmQudyp0aGlzLmZ1bGxMYXllci53b3JsZFNjYWxpbmdbMF0saDpkLmgqdGhpcy5mdWxsTGF5ZXIud29ybGRTY2FsaW5nWzFdfSx0eXBlOlR0LkRyYXdXb3JrLGRhdGFUeXBlOnp0LkxvY2FsLHdvcmtJZDpFP2k6dm9pZCAwLG9wOkU/TTp2b2lkIDAsaW5kZXg6RT9wKjI6dm9pZCAwfX1jb25zdW1lQWxsKCl7dmFyIGk7Y29uc3QgZT0oaT10aGlzLndvcmtJZCk9PW51bGw/dm9pZCAwOmkudG9TdHJpbmcoKTtsZXQgdDtpZih0aGlzLnRtcFBvaW50cy5sZW5ndGgtMT50aGlzLmNvbnN1bWVJbmRleCl7bGV0IGY9dGhpcy50bXBQb2ludHMuc2xpY2UodGhpcy5jb25zdW1lSW5kZXgpO2NvbnN0IGg9Zi5sZW5ndGg9PT0xLHtzdHJva2VDb2xvcjp1LHRoaWNrbmVzczphLHN0cm9rZVR5cGU6ZH09dGhpcy53b3JrT3B0aW9ucztpZihoKXtjb25zdCBPPXRoaXMuY29tcHV0RG90U3Ryb2tlKHtwb2ludDpmWzBdLHJhZGl1czphLzJ9KTtmPU8ucHMsdD1PLnJlY3R9ZWxzZSB0PXhlKHRoaXMudG1wUG9pbnRzLGEpO2NvbnN0IEU9e25hbWU6ZT09bnVsbD92b2lkIDA6ZS50b1N0cmluZygpLGZpbGxDb2xvcjpoP3U6dm9pZCAwLG9wYWNpdHk6MSxsaW5lRGFzaDpkPT09UmUuRG90dGVkJiYhaD9bMSxhKjJdOmQ9PT1SZS5Mb25nRG90dGVkJiYhaD9bYSxhKjJdOnZvaWQgMCxzdHJva2VDb2xvcjp1LGxpbmVDYXA6aD92b2lkIDA6InJvdW5kIixsaW5lV2lkdGg6aD8wOmEsYW5jaG9yOlsuNSwuNV19LHA9dGhpcy5nZXRUYXNrUG9pbnRzKGYpO3AubGVuZ3RoJiZ0aGlzLmRyYXcoe2F0dHJzOkUsdGFza3M6cCxpc0RvdDpofSl9Y29uc3Qgbj1bXTtyZXR1cm4gdGhpcy50bXBQb2ludHMuc2xpY2UodGhpcy5zeW5jSW5kZXgpLmZvckVhY2goZj0+e24ucHVzaChmLngsZi55KX0pLHtyZWN0OnQmJnt4OnQueCp0aGlzLmZ1bGxMYXllci53b3JsZFNjYWxpbmdbMF0rdGhpcy5mdWxsTGF5ZXIud29ybGRQb3NpdGlvblswXSx5OnQueSp0aGlzLmZ1bGxMYXllci53b3JsZFNjYWxpbmdbMV0rdGhpcy5mdWxsTGF5ZXIud29ybGRQb3NpdGlvblsxXSx3OnQudyp0aGlzLmZ1bGxMYXllci53b3JsZFNjYWxpbmdbMF0saDp0LmgqdGhpcy5mdWxsTGF5ZXIud29ybGRTY2FsaW5nWzFdfSx0eXBlOlR0LkRyYXdXb3JrLGRhdGFUeXBlOnp0LkxvY2FsLHdvcmtJZDplLG9wOm4saW5kZXg6dGhpcy5zeW5jSW5kZXgqMn19Y2xlYXJUbXBQb2ludHMoKXt0aGlzLnRtcFBvaW50cy5sZW5ndGg9MCx0aGlzLnN5bmNUaW1lc3RhbXA9MCx0aGlzLnN5bmNJbmRleD0wfWNvbnN1bWVTZXJ2aWNlKGUpe3ZhciBPO2NvbnN0e29wOnR9PWUse3N0cm9rZUNvbG9yOm4sdGhpY2tuZXNzOmksc3Ryb2tlVHlwZTpmfT10aGlzLndvcmtPcHRpb25zO2lmKCF0Lmxlbmd0aCl7Y29uc3QgbT14ZSh0aGlzLnRtcFBvaW50cyxpKTtyZXR1cm57eDptLngqdGhpcy5mdWxsTGF5ZXIud29ybGRTY2FsaW5nWzBdK3RoaXMuZnVsbExheWVyLndvcmxkUG9zaXRpb25bMF0seTptLnkqdGhpcy5mdWxsTGF5ZXIud29ybGRTY2FsaW5nWzFdK3RoaXMuZnVsbExheWVyLndvcmxkUG9zaXRpb25bMV0sdzptLncqdGhpcy5mdWxsTGF5ZXIud29ybGRTY2FsaW5nWzBdLGg6bS5oKnRoaXMuZnVsbExheWVyLndvcmxkU2NhbGluZ1sxXX19Y29uc3QgaD1NYXRoLm1heCgwLHRoaXMudG1wUG9pbnRzLmxlbmd0aC0xKTt0aGlzLnVwZGF0ZVRlbXBQb2ludHModHx8W10pO2xldCB1LGE9dGhpcy50bXBQb2ludHMuc2xpY2UoaCk7Y29uc3QgZD1hLmxlbmd0aD09PTE7aWYoZCl7Y29uc3QgbT10aGlzLmNvbXB1dERvdFN0cm9rZSh7cG9pbnQ6YVswXSxyYWRpdXM6aS8yfSk7YT1tLnBzLHU9bS5yZWN0fWVsc2UgdT14ZSh0aGlzLnRtcFBvaW50cyxpKTtjb25zdCBFPXtuYW1lOihPPXRoaXMud29ya0lkKT09bnVsbD92b2lkIDA6Ty50b1N0cmluZygpLGZpbGxDb2xvcjpkP246dm9pZCAwLG9wYWNpdHk6MSxsaW5lRGFzaDpmPT09UmUuRG90dGVkJiYhZD9bMSxpKjJdOmY9PT1SZS5Mb25nRG90dGVkJiYhZD9baSxpKjJdOnZvaWQgMCxzdHJva2VDb2xvcjpuLGxpbmVDYXA6ZD92b2lkIDA6InJvdW5kIixsaW5lV2lkdGg6ZD8wOmksYW5jaG9yOlsuNSwuNV19LHA9dGhpcy5nZXRUYXNrUG9pbnRzKGEpO3JldHVybiBwLmxlbmd0aCYmdGhpcy5kcmF3KHthdHRyczpFLHRhc2tzOnAsaXNEb3Q6ZH0pLHt4OnUueCp0aGlzLmZ1bGxMYXllci53b3JsZFNjYWxpbmdbMF0rdGhpcy5mdWxsTGF5ZXIud29ybGRQb3NpdGlvblswXSx5OnUueSp0aGlzLmZ1bGxMYXllci53b3JsZFNjYWxpbmdbMV0rdGhpcy5mdWxsTGF5ZXIud29ybGRQb3NpdGlvblsxXSx3OnUudyp0aGlzLmZ1bGxMYXllci53b3JsZFNjYWxpbmdbMF0saDp1LmgqdGhpcy5mdWxsTGF5ZXIud29ybGRTY2FsaW5nWzFdfX1jb21wdXREb3RTdHJva2UoZSl7Y29uc3R7cG9pbnQ6dCxyYWRpdXM6bn09ZSxpPXt4OnQueC1uLHk6dC55LW4sdzpuKjIsaDpuKjJ9O3JldHVybntwczpGdC5HZXREb3RTdHJva2UodCxuLDgpLHJlY3Q6aX19dXBkYXRlVGVtcFBvaW50cyhlKXtjb25zdCB0PXRoaXMudG1wUG9pbnRzLmxlbmd0aDtmb3IobGV0IG49MDtuPGUubGVuZ3RoO24rPTIpe2lmKHQpe2NvbnN0IGk9dGhpcy50bXBQb2ludHMuc2xpY2UoLTEpWzBdO2kmJmkueD09PWVbbl0mJmkueT09PWVbbisxXSYmdGhpcy50bXBQb2ludHMucG9wKCl9dGhpcy50bXBQb2ludHMucHVzaChuZXcgRnQoZVtuXSxlW24rMV0pKX19YXN5bmMgZHJhdyhlKXtjb25zdHthdHRyczp0LHRhc2tzOm4saXNEb3Q6aX09ZSxmPXRoaXMuZnVsbExheWVyLHtkdXJhdGlvbjpofT10aGlzLndvcmtPcHRpb25zLHU9bmV3IEhyO2ZvcihsZXQgYT0wO2E8bi5sZW5ndGg7YSsrKXtjb25zdHtwb3M6ZCxwb2ludHM6RX09blthXTtsZXQgcDtpP3A9aG4oRSwhMCk6cD1obihFLCExKSx1LmF0dHIoey4uLnQscG9zOmQsZDpwfSk7Y29uc3R7dmVydGV4Ok8sZnJhZ21lbnQ6bX09dGhpcy53b3JrT3B0aW9ucztpZihPJiZtKXtjb25zdCBiPWYucmVuZGVyZXIuY3JlYXRlUHJvZ3JhbSh7dmVydGV4Ok8sZnJhZ21lbnQ6bX0pLHt3aWR0aDpNLGhlaWdodDp5fT1mLmdldFJlc29sdXRpb24oKTt1LnNldFVuaWZvcm1zKHt1X3RpbWU6MCx1X3Jlc29sdXRpb246W00seV19KSx1LnNldFByb2dyYW0oYil9Zi5hcHBlbmRDaGlsZCh1KSxhd2FpdCB1LnRyYW5zaXRpb24oaCkuYXR0cih7c2NhbGU6aT9bLjEsLjFdOlsxLDFdLGxpbmVXaWR0aDppPzA6MX0pLHUucmVtb3ZlKCl9fWdldFRhc2tQb2ludHMoZSl7dmFyIGE7Y29uc3QgdD1bXTtpZihlLmxlbmd0aD09PTApcmV0dXJuW107bGV0IG49MCxpPWVbMF0ueCxmPWVbMF0ueSxoPVtpLGZdLHU9W107Zm9yKDtuPGUubGVuZ3RoOyl7Y29uc3QgZD1lW25dLEU9ZC54LWkscD1kLnktZjtpZih1LnB1c2gobmV3IEZ0KEUscCkpLG4+MCYmbjxlLmxlbmd0aC0xKXtjb25zdCBPPWVbbl0uZ2V0QW5nbGVCeVBvaW50cyhlW24tMV0sZVtuKzFdKTtpZihPPDkwfHxPPjI3MCl7Y29uc3QgbT0oYT11LnBvcCgpKT09bnVsbD92b2lkIDA6YS5jbG9uZSgpO20mJnQucHVzaCh7cG9zOmgscG9pbnRzOlsuLi51LG1dfSksaT1lW25dLngsZj1lW25dLnksaD1baSxmXTtjb25zdCBiPWQueC1pLE09ZC55LWY7dT1bbmV3IEZ0KGIsTSldfX1uKyt9cmV0dXJuIHQucHVzaCh7cG9zOmgscG9pbnRzOnV9KSx0fXJlbW92ZUxvY2FsKCl7fXJlbW92ZVNlcnZpY2UoZSl7bGV0IHQ7Y29uc3Qgbj1bXTtyZXR1cm4gdGhpcy5mdWxsTGF5ZXIuZ2V0RWxlbWVudHNCeU5hbWUoZSkuZm9yRWFjaChpPT57aWYoaS5uYW1lPT09ZSl7Y29uc3QgZj1pLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO3Q9JHQodCx7eDpmLngseTpmLnksdzpmLndpZHRoLGg6Zi5oZWlnaHR9KSxuLnB1c2goaSl9fSksbi5sZW5ndGgmJm4uZm9yRWFjaChpPT5pLnJlbW92ZSgpKSx0fX12YXIgT209b2k7b2kucG9seWxpbmU9b2ksb2kucG9seWdvbj1FbTtmdW5jdGlvbiBvaShnLGUsdCl7dmFyIG49Zy5sZW5ndGgsaT1kbihnWzBdLGUpLGY9W10saCx1LGEsZCxFO2Zvcih0fHwodD1bXSksaD0xO2g8bjtoKyspe2Zvcih1PWdbaC0xXSxhPWdbaF0sZD1FPWRuKGEsZSk7OylpZihpfGQpe2lmKGkmZClicmVhaztpPyh1PXBzKHUsYSxpLGUpLGk9ZG4odSxlKSk6KGE9cHModSxhLGQsZSksZD1kbihhLGUpKX1lbHNle2YucHVzaCh1KSxkIT09RT8oZi5wdXNoKGEpLGg8bi0xJiYodC5wdXNoKGYpLGY9W10pKTpoPT09bi0xJiZmLnB1c2goYSk7YnJlYWt9aT1FfXJldHVybiBmLmxlbmd0aCYmdC5wdXNoKGYpLHR9ZnVuY3Rpb24gRW0oZyxlKXt2YXIgdCxuLGksZixoLHUsYTtmb3Iobj0xO248PTg7bio9Mil7Zm9yKHQ9W10saT1nW2cubGVuZ3RoLTFdLGY9IShkbihpLGUpJm4pLGg9MDtoPGcubGVuZ3RoO2grKyl1PWdbaF0sYT0hKGRuKHUsZSkmbiksYSE9PWYmJnQucHVzaChwcyhpLHUsbixlKSksYSYmdC5wdXNoKHUpLGk9dSxmPWE7aWYoZz10LCFnLmxlbmd0aClicmVha31yZXR1cm4gdH1mdW5jdGlvbiBwcyhnLGUsdCxuKXtyZXR1cm4gdCY4P1tnWzBdKyhlWzBdLWdbMF0pKihuWzNdLWdbMV0pLyhlWzFdLWdbMV0pLG5bM11dOnQmND9bZ1swXSsoZVswXS1nWzBdKSooblsxXS1nWzFdKS8oZVsxXS1nWzFdKSxuWzFdXTp0JjI/W25bMl0sZ1sxXSsoZVsxXS1nWzFdKSooblsyXS1nWzBdKS8oZVswXS1nWzBdKV06dCYxP1tuWzBdLGdbMV0rKGVbMV0tZ1sxXSkqKG5bMF0tZ1swXSkvKGVbMF0tZ1swXSldOm51bGx9ZnVuY3Rpb24gZG4oZyxlKXt2YXIgdD0wO3JldHVybiBnWzBdPGVbMF0/dHw9MTpnWzBdPmVbMl0mJih0fD0yKSxnWzFdPGVbMV0/dHw9NDpnWzFdPmVbM10mJih0fD04KSx0fXZhciBNbT1WbihPbSk7Y2xhc3MgbHIgZXh0ZW5kcyBEdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihlKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiY2FuUm90YXRlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6ITF9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywic2NhbGVUeXBlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6JGUubm9uZX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ0b29sc1R5cGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpMdC5FcmFzZXJ9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidG1wUG9pbnRzIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6W119KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywid29ya09wdGlvbnMiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywid29ybGRQb3NpdGlvbiIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ3b3JsZFNjYWxpbmciLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiZXJhc2VyUmVjdCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJlcmFzZXJQb2x5bGluZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLHRoaXMud29ya09wdGlvbnM9ZS50b29sc09wdCx0aGlzLndvcmxkUG9zaXRpb249dGhpcy5mdWxsTGF5ZXIud29ybGRQb3NpdGlvbix0aGlzLndvcmxkU2NhbGluZz10aGlzLmZ1bGxMYXllci53b3JsZFNjYWxpbmd9Y29tYmluZUNvbnN1bWUoKXt9Y29uc3VtZVNlcnZpY2UoKXt9c2V0V29ya09wdGlvbnMoZSl7c3VwZXIuc2V0V29ya09wdGlvbnMoZSl9Y3JlYXRlRXJhc2VyUmVjdChlKXtjb25zdCB0PWVbMF0qdGhpcy53b3JsZFNjYWxpbmdbMF0rdGhpcy53b3JsZFBvc2l0aW9uWzBdLG49ZVsxXSp0aGlzLndvcmxkU2NhbGluZ1sxXSt0aGlzLndvcmxkUG9zaXRpb25bMV0se3dpZHRoOmksaGVpZ2h0OmZ9PWxyLmVyYXNlclNpemVzW3RoaXMud29ya09wdGlvbnMudGhpY2tuZXNzXTt0aGlzLmVyYXNlclJlY3Q9e3g6dC1pKi41LHk6bi1mKi41LHc6aSxoOmZ9LHRoaXMuZXJhc2VyUG9seWxpbmU9W3RoaXMuZXJhc2VyUmVjdC54LHRoaXMuZXJhc2VyUmVjdC55LHRoaXMuZXJhc2VyUmVjdC54K3RoaXMuZXJhc2VyUmVjdC53LHRoaXMuZXJhc2VyUmVjdC55K3RoaXMuZXJhc2VyUmVjdC5oXX1jb21wdXRSZWN0Q2VudGVyUG9pbnRzKCl7Y29uc3QgZT10aGlzLnRtcFBvaW50cy5zbGljZSgtMik7aWYodGhpcy50bXBQb2ludHMubGVuZ3RoPT09NCl7Y29uc3QgdD1uZXcgRXQodGhpcy50bXBQb2ludHNbMF0sdGhpcy50bXBQb2ludHNbMV0pLG49bmV3IEV0KHRoaXMudG1wUG9pbnRzWzJdLHRoaXMudG1wUG9pbnRzWzNdKSxpPUV0LlN1YihuLHQpLnVuaSgpLGY9RXQuRGlzdCh0LG4pLHt3aWR0aDpoLGhlaWdodDp1fT1sci5lcmFzZXJTaXplc1t0aGlzLndvcmtPcHRpb25zLnRoaWNrbmVzc10sYT1NYXRoLm1pbihoLHUpLGQ9TWF0aC5yb3VuZChmL2EpO2lmKGQ+MSl7Y29uc3QgRT1bXTtmb3IobGV0IHA9MDtwPGQ7cCsrKXtjb25zdCBPPUV0Lk11bChpLHAqYSk7RS5wdXNoKHRoaXMudG1wUG9pbnRzWzBdK08ueCx0aGlzLnRtcFBvaW50c1sxXStPLnkpfXJldHVybiBFLmNvbmNhdChlKX19cmV0dXJuIGV9aXNOZWFyKGUsdCl7Y29uc3Qgbj1uZXcgRXQoZVswXSxlWzFdKSxpPW5ldyBFdCh0WzBdLHRbMV0pLHt3aWR0aDpmLGhlaWdodDpofT1sci5lcmFzZXJTaXplc1t0aGlzLndvcmtPcHRpb25zLnRoaWNrbmVzc107cmV0dXJuIEV0LkRpc3QobixpKTxNYXRoLmh5cG90KGYsaCkqLjV9Y3V0UG9seWxpbmUoZSx0KXtsZXQgbj1bdF0saT0wO2Zvcig7aTxlLmxlbmd0aDspe2NvbnN0IHU9ZVtpXTtpZih1Lmxlbmd0aDwyKWJyZWFrO249ZihuLHUpLGkrK31yZXR1cm4gbjtmdW5jdGlvbiBmKHUsYSl7Y29uc3QgZD11O2ZvcihsZXQgRT0wO0U8dS5sZW5ndGg7RSsrKXtjb25zdCBwPXVbRV0sTz1wLmZpbmRJbmRleCgobSxiKT0+YjxwLmxlbmd0aC0xP2goW20scFtiKzFdXSxbYVswXSxhWzFdXSk6ITEpO2lmKE8hPT0tMSYmTz4tMSl7Y29uc3QgbT1bXSxiPXAuc2xpY2UoMCxPKzEpO2lmKEV0LkVxdWFscyhwW09dLGFbMF0pfHxiLnB1c2goYVswXS5jbG9uZSgpLnNldHoocFtPXS56KSksYi5sZW5ndGg+MSYmbS5wdXNoKGIpLE8rYS5sZW5ndGgtMTxwLmxlbmd0aC0xKXtjb25zdCBNPU8rYS5sZW5ndGgtMSx5PXAuc2xpY2UoTSksUz1hW2EubGVuZ3RoLTFdO0V0LkVxdWFscyhwW01dLFMpfHx5LnVuc2hpZnQoUy5jbG9uZSgpLnNldHoocFtNXS56KSkseS5sZW5ndGg+MSYmbS5wdXNoKHkpfXJldHVybiBkLnNwbGljZShFLDEsLi4ubSksZH19cmV0dXJuIGR9ZnVuY3Rpb24gaCh1LGEpe2NvbnN0IGQ9RXQuU3ViKHVbMV0sdVswXSksRT1FdC5TdWIoYVsxXSxhWzBdKSxwPUV0LlN1YihhWzBdLHVbMF0pO3JldHVybiBNYXRoLmFicyhFdC5DcHIoZCxFKSk8LjEmJk1hdGguYWJzKEV0LkNwcihkLHApKTwuMX19aXNTYW1lUG9pbnQoZSx0KXtyZXR1cm4gZVswXT09PXRbMF0mJmVbMV09PT10WzFdfXRyYW5zbGF0ZUludGVyc2VjdChlKXtjb25zdCB0PVtdO2ZvcihsZXQgbj0wO248ZS5sZW5ndGg7bisrKXtjb25zdCBpPWVbbl0uZmlsdGVyKCh1LGEsZCk9PiEoYT4wJiZ0aGlzLmlzU2FtZVBvaW50KHUsZFthLTFdKSkpLGY9W107bGV0IGg9MDtmb3IoO2g8aS5sZW5ndGg7KXtjb25zdCB1PWlbaF0sYT1uZXcgRXQodVswXSx1WzFdKTtmLnB1c2goYSksaCsrfXQucHVzaChmKX1yZXR1cm4gdH1yZW1vdmUoZSl7Y29uc3R7Y3VyTm9kZU1hcDp0LHJlbW92ZUlkczpuLG5ld1dvcmtEYXRhczppfT1lLHtpc0xpbmU6Zn09dGhpcy53b3JrT3B0aW9ucztsZXQgaDtmb3IoY29uc3RbdSxhXW9mIHQuZW50cmllcygpKWlmKGEucmVjdCYmdGhpcy5lcmFzZXJSZWN0JiZ0aGlzLmVyYXNlclBvbHlsaW5lJiZSbih0aGlzLmVyYXNlclJlY3QsYS5yZWN0KSl7Y29uc3QgZD1hLm9wO2lmKCEoZCE9bnVsbCYmZC5sZW5ndGgpKWNvbnRpbnVlO2NvbnN0IEU9W10scD1bXTtmb3IobGV0IG09MDttPGQubGVuZ3RoO20rPTMpe2NvbnN0IGI9bmV3IEV0KGRbbV0qdGhpcy53b3JsZFNjYWxpbmdbMF0rdGhpcy53b3JsZFBvc2l0aW9uWzBdLGRbbSsxXSp0aGlzLndvcmxkU2NhbGluZ1sxXSt0aGlzLndvcmxkUG9zaXRpb25bMV0sZFttKzJdKTtwLnB1c2goYiksRS5wdXNoKG5ldyBGdChiLngsYi55KSl9Y29uc3QgTz14ZShFKTtpZihSbihPLHRoaXMuZXJhc2VyUmVjdCkpe2lmKHAubGVuZ3RoPjEpe2NvbnN0IG09TW0ucG9seWxpbmUocC5tYXAoYj0+Yi5YWSksdGhpcy5lcmFzZXJQb2x5bGluZSk7aWYobS5sZW5ndGgmJihuLmFkZChhLm5hbWUpLCFmJiZhLnRvb2xzVHlwZT09PUx0LlBlbmNpbCkpe2NvbnN0IGI9dGhpcy50cmFuc2xhdGVJbnRlcnNlY3QobSksTT10aGlzLmN1dFBvbHlsaW5lKGIscCk7Zm9yKGxldCB5PTA7eTxNLmxlbmd0aDt5Kyspe2NvbnN0IFM9YCR7dX1fc18ke3l9YCxzPVtdO01beV0uZm9yRWFjaChjPT57cy5wdXNoKChjLngtdGhpcy53b3JsZFBvc2l0aW9uWzBdKS90aGlzLndvcmxkU2NhbGluZ1swXSwoYy55LXRoaXMud29ybGRQb3NpdGlvblsxXSkvdGhpcy53b3JsZFNjYWxpbmdbMV0sYy56KX0pLGEub3B0JiZhLnRvb2xzVHlwZSYmdGhpcy52Tm9kZXMmJih0aGlzLnZOb2Rlcy5zZXRJbmZvKFMse3JlY3Q6T3x8YS5yZWN0LG9wOnMsb3B0OmEub3B0LGNhblJvdGF0ZTphLmNhblJvdGF0ZSxzY2FsZVR5cGU6YS5zY2FsZVR5cGUsdG9vbHNUeXBlOmEudG9vbHNUeXBlfSksaS5zZXQoUyx7d29ya0lkOlMsb3A6cyxvcHQ6YS5vcHQsdG9vbHNUeXBlOmEudG9vbHNUeXBlfSkpfX19ZWxzZSBuLmFkZChhLm5hbWUpO2g9JHQoaCxPKX19cmV0dXJuIG4uZm9yRWFjaCh1PT57dmFyIGE7cmV0dXJuKGE9dGhpcy52Tm9kZXMpPT1udWxsP3ZvaWQgMDphLmRlbGV0ZSh1KX0pLGgmJihoLngtPUR0LlNhZmVCb3JkZXJQYWRkaW5nLGgueS09RHQuU2FmZUJvcmRlclBhZGRpbmcsaC53Kz1EdC5TYWZlQm9yZGVyUGFkZGluZyoyLGguaCs9RHQuU2FmZUJvcmRlclBhZGRpbmcqMiksaH1jb25zdW1lKGUpe2NvbnN0e29wOnR9PWUuZGF0YTtpZighdHx8dC5sZW5ndGg9PT0wKXJldHVybnt0eXBlOlR0Lk5vbmV9O2NvbnN0IG49dGhpcy50bXBQb2ludHMubGVuZ3RoO2lmKG4+MSYmdGhpcy5pc05lYXIoW3RbMF0sdFsxXV0sW3RoaXMudG1wUG9pbnRzW24tMl0sdGhpcy50bXBQb2ludHNbbi0xXV0pKXJldHVybnt0eXBlOlR0Lk5vbmV9O249PT00JiYodGhpcy50bXBQb2ludHMuc2hpZnQoKSx0aGlzLnRtcFBvaW50cy5zaGlmdCgpKSx0aGlzLnRtcFBvaW50cy5wdXNoKHRbMF0sdFsxXSk7Y29uc3QgaT10aGlzLmNvbXB1dFJlY3RDZW50ZXJQb2ludHMoKTtsZXQgZjtjb25zdCBoPW5ldyBTZXQsdT1uZXcgTWFwO3RoaXMudk5vZGVzLmdldExhc3RUYXJnZXQoKTtmb3IobGV0IGE9MDthPGkubGVuZ3RoLTE7YSs9Mil7dGhpcy5jcmVhdGVFcmFzZXJSZWN0KGkuc2xpY2UoYSxhKzIpKTtjb25zdCBkPXRoaXMucmVtb3ZlKHtjdXJOb2RlTWFwOnRoaXMudk5vZGVzLmdldExhc3RUYXJnZXQoKSxyZW1vdmVJZHM6aCxuZXdXb3JrRGF0YXM6dX0pO2Y9JHQoZixkKX1pZih0aGlzLnZOb2Rlcy5kZWxldGVMYXN0VGFyZ2V0KCksZiYmaC5zaXplKXtmb3IoY29uc3QgYSBvZiB1LmtleXMoKSloLmhhcyhhKSYmdS5kZWxldGUoYSk7cmV0dXJue3R5cGU6VHQuUmVtb3ZlTm9kZSxkYXRhVHlwZTp6dC5Mb2NhbCxyZWN0OmYscmVtb3ZlSWRzOlsuLi5oXSxuZXdXb3JrRGF0YXM6dX19cmV0dXJue3R5cGU6VHQuTm9uZX19Y29uc3VtZUFsbChlKXtyZXR1cm4gdGhpcy5jb25zdW1lKGUpfWNsZWFyVG1wUG9pbnRzKCl7dGhpcy50bXBQb2ludHMubGVuZ3RoPTB9fU9iamVjdC5kZWZpbmVQcm9wZXJ0eShsciwiZXJhc2VyU2l6ZXMiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpPYmplY3QuZnJlZXplKFtPYmplY3QuZnJlZXplKHt3aWR0aDoxOCxoZWlnaHQ6MjZ9KSxPYmplY3QuZnJlZXplKHt3aWR0aDoyNixoZWlnaHQ6MzR9KSxPYmplY3QuZnJlZXplKHt3aWR0aDozNCxoZWlnaHQ6NTB9KV0pfSk7Y29uc3QgU209IisrIixUbT0ic2VsZWN0b3IiLFBtPSJhbGwiO2NsYXNzIGllIGV4dGVuZHMgRHR7Y29uc3RydWN0b3IoZSl7c3VwZXIoZSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInRvb2xzVHlwZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOkx0LlNlbGVjdG9yfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInRtcFBvaW50cyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOltdfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIndvcmtPcHRpb25zIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInNlbGVjdElkcyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzZWxlY3RvckNvbG9yIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInN0cm9rZUNvbG9yIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImZpbGxDb2xvciIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJvbGRTZWxlY3RSZWN0Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImNhblJvdGF0ZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOiExfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImNhblRleHRFZGl0Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6ITF9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywic2NhbGVUeXBlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6JGUuYWxsfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInRleHRPcHQiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSx0aGlzLndvcmtPcHRpb25zPWUudG9vbHNPcHR9Y29tcHV0U2VsZWN0b3IoKXtjb25zdCBlPXhlKHRoaXMudG1wUG9pbnRzKSx7cmVjdFJhbmdlOnQsbm9kZVJhbmdlOm59PXRoaXMudk5vZGVzLmdldFJlY3RJbnRlcnNlY3RSYW5nZShlKTtyZXR1cm57c2VsZWN0SWRzOlsuLi5uLmtleXMoKV0saW50ZXJzZWN0UmVjdDp0LHN1Yk5vZGVNYXA6bn19dXBkYXRlVGVtcFBvaW50cyhlKXtjb25zdCB0PXRoaXMudG1wUG9pbnRzLmxlbmd0aCxuPWUubGVuZ3RoO2lmKG4+MSl7Y29uc3QgaT1uZXcgRnQoZVtuLTJdKnRoaXMuZnVsbExheWVyLndvcmxkU2NhbGluZ1swXSt0aGlzLmZ1bGxMYXllci53b3JsZFBvc2l0aW9uWzBdLGVbbi0xXSp0aGlzLmZ1bGxMYXllci53b3JsZFNjYWxpbmdbMF0rdGhpcy5mdWxsTGF5ZXIud29ybGRQb3NpdGlvblsxXSk7dD09PTI/dGhpcy50bXBQb2ludHMuc3BsaWNlKDEsMSxpKTp0aGlzLnRtcFBvaW50cy5wdXNoKGkpfX1kcmF3U2VsZWN0b3IoZSl7Y29uc3R7ZHJhd1JlY3Q6dCxzdWJOb2RlTWFwOm4sc2VsZWN0b3JJZDppLGxheWVyOmZ9PWUsaD1uZXcgSXIoe3BvczpbdC54LHQueV0sYW5jaG9yOlswLDBdLHNpemU6W3Qudyx0LmhdLGlkOmksbmFtZTppZS5zZWxlY3RvcklkLHpJbmRleDoxZTN9KSx1PVtdLGE9bmV3IGdzKHtub3JtYWxpemU6ITAscG9zOlt0LncvMix0LmgvMl0sbGluZVdpZHRoOjEsc3Ryb2tlQ29sb3I6dGhpcy53b3JrT3B0aW9ucy5zdHJva2VDb2xvcix3aWR0aDp0LnctMixoZWlnaHQ6dC5oLTIsbmFtZTppZS5zZWxlY3RvckJvcmRlcklkfSk7dS5wdXNoKGEpLG4uZm9yRWFjaCgoZCxFKT0+e2NvbnN0IHA9W2QucmVjdC54K2QucmVjdC53LzItdC54LGQucmVjdC55K2QucmVjdC5oLzItdC55XSxPPW5ldyBncyh7bm9ybWFsaXplOiEwLHBvczpwLGxpbmVXaWR0aDoxLHN0cm9rZUNvbG9yOm4uc2l6ZT4xP3RoaXMud29ya09wdGlvbnMuc3Ryb2tlQ29sb3I6dm9pZCAwLHdpZHRoOmQucmVjdC53LGhlaWdodDpkLnJlY3QuaCxpZDpgc2VsZWN0b3ItJHtFfWAsbmFtZTpgc2VsZWN0b3ItJHtFfWB9KTt1LnB1c2goTyl9KSx1JiZoLmFwcGVuZCguLi51KSwoZj09bnVsbD92b2lkIDA6Zi5wYXJlbnQpLmFwcGVuZENoaWxkKGgpfWRyYXcoZSx0LG4pe3ZhciBoLHU7Y29uc3R7aW50ZXJzZWN0UmVjdDppLHN1Yk5vZGVNYXA6Zn09bjsodT0oaD10LnBhcmVudCk9PW51bGw/dm9pZCAwOmguZ2V0RWxlbWVudEJ5SWQoZSkpPT1udWxsfHx1LnJlbW92ZSgpLGkmJnRoaXMuZHJhd1NlbGVjdG9yKHtkcmF3UmVjdDppLHN1Yk5vZGVNYXA6ZixzZWxlY3RvcklkOmUsbGF5ZXI6dH0pfWdldFNlbGVjdGVvckluZm8oZSl7Zm9yKGNvbnN0IHQgb2YgZS52YWx1ZXMoKSl7Y29uc3R7b3B0Om4sY2FuUm90YXRlOmksc2NhbGVUeXBlOmYsdG9vbHNUeXBlOmh9PXQ7dGhpcy5zZWxlY3RvckNvbG9yPXRoaXMud29ya09wdGlvbnMuc3Ryb2tlQ29sb3IsdGhpcy5zdHJva2VDb2xvcj1uLnN0cm9rZUNvbG9yLG4uZmlsbENvbG9yJiYodGhpcy5maWxsQ29sb3I9bi5maWxsQ29sb3IpLG4udGV4dE9wdCYmKHRoaXMudGV4dE9wdD1uLnRleHRPcHQpLGg9PT1MdC5UZXh0JiYodGhpcy50ZXh0T3B0PW4pLGUuc2l6ZT09PTE/KHRoaXMudGV4dE9wdCYmKHRoaXMuY2FuVGV4dEVkaXQ9ITApLHRoaXMuY2FuUm90YXRlPWksdGhpcy5zY2FsZVR5cGU9Zik6Zj09PSRlLm5vbmUmJih0aGlzLnNjYWxlVHlwZT1mKX19Y29uc3VtZShlKXtjb25zdHtvcDp0LHdvcmtTdGF0ZTpufT1lLmRhdGE7bGV0IGk9dGhpcy5vbGRTZWxlY3RSZWN0O2lmKG49PT1jZS5TdGFydCYmKGk9dGhpcy5iYWNrVG9GdWxsTGF5ZXIoKSksISh0IT1udWxsJiZ0Lmxlbmd0aCl8fCF0aGlzLnZOb2Rlcy5jdXJOb2RlTWFwLnNpemUpcmV0dXJue3R5cGU6VHQuTm9uZX07dGhpcy51cGRhdGVUZW1wUG9pbnRzKHQpO2NvbnN0IGY9dGhpcy5jb21wdXRTZWxlY3RvcigpO2lmKHRoaXMuc2VsZWN0SWRzJiZhbSh0aGlzLnNlbGVjdElkcyxmLnNlbGVjdElkcykpcmV0dXJue3R5cGU6VHQuTm9uZX07dGhpcy5zZWxlY3RJZHM9Zi5zZWxlY3RJZHM7Y29uc3QgaD1mLmludGVyc2VjdFJlY3Q7cmV0dXJuIHRoaXMuZHJhdyhpZS5zZWxlY3RvcklkLHRoaXMuZHJhd0xheWVyfHx0aGlzLmZ1bGxMYXllcixmKSx0aGlzLmdldFNlbGVjdGVvckluZm8oZi5zdWJOb2RlTWFwKSx0aGlzLm9sZFNlbGVjdFJlY3Q9aCx7dHlwZTpUdC5TZWxlY3QsZGF0YVR5cGU6enQuTG9jYWwscmVjdDokdChoLGkpLHNlbGVjdElkczpmLnNlbGVjdElkcyxvcHQ6dGhpcy53b3JrT3B0aW9ucyxzZWxlY3RSZWN0Omgsc2VsZWN0b3JDb2xvcjp0aGlzLnNlbGVjdG9yQ29sb3Isc3Ryb2tlQ29sb3I6dGhpcy5zdHJva2VDb2xvcixmaWxsQ29sb3I6dGhpcy5maWxsQ29sb3IsdGV4dE9wdDp0aGlzLnRleHRPcHQsY2FuVGV4dEVkaXQ6dGhpcy5jYW5UZXh0RWRpdCxjYW5Sb3RhdGU6dGhpcy5jYW5Sb3RhdGUsc2NhbGVUeXBlOnRoaXMuc2NhbGVUeXBlLHdpbGxTeW5jU2VydmljZTohMH19Y29uc3VtZUFsbCgpe3ZhciBlO3JldHVybihlPXRoaXMuc2VsZWN0SWRzKSE9bnVsbCYmZS5sZW5ndGgmJnRoaXMuc2VhbFRvRHJhd0xheWVyKHRoaXMuc2VsZWN0SWRzKSx0aGlzLm9sZFNlbGVjdFJlY3Q/e3R5cGU6VHQuU2VsZWN0LGRhdGFUeXBlOnp0LkxvY2FsLHJlY3Q6dGhpcy5vbGRTZWxlY3RSZWN0LHNlbGVjdElkczp0aGlzLnNlbGVjdElkcyxvcHQ6dGhpcy53b3JrT3B0aW9ucyxzZWxlY3RSZWN0OnRoaXMub2xkU2VsZWN0UmVjdCxzdHJva2VDb2xvcjp0aGlzLnN0cm9rZUNvbG9yLGZpbGxDb2xvcjp0aGlzLmZpbGxDb2xvcix0ZXh0T3B0OnRoaXMudGV4dE9wdCxjYW5UZXh0RWRpdDp0aGlzLmNhblRleHRFZGl0LGNhblJvdGF0ZTp0aGlzLmNhblJvdGF0ZSxzY2FsZVR5cGU6dGhpcy5zY2FsZVR5cGUsd2lsbFN5bmNTZXJ2aWNlOiExfTp7dHlwZTpUdC5Ob25lfX1jb25zdW1lU2VydmljZSgpe31jbGVhclRtcFBvaW50cygpe3RoaXMudG1wUG9pbnRzLmxlbmd0aD0wfWNsZWFyU2VsZWN0RGF0YSgpe3RoaXMuc2VsZWN0SWRzPXZvaWQgMCx0aGlzLm9sZFNlbGVjdFJlY3Q9dm9pZCAwfWJhY2tUb0Z1bGxMYXllcihlKXt2YXIgZixoO2xldCB0O2NvbnN0IG49W10saT1bXTtmb3IoY29uc3QgdSBvZigoZj10aGlzLmRyYXdMYXllcik9PW51bGw/dm9pZCAwOmYuY2hpbGRyZW4pfHxbXSlpZighKGUhPW51bGwmJmUubGVuZ3RoJiYhZS5pbmNsdWRlcyh1LmlkKSkmJnUuaWQhPT1pZS5zZWxlY3RvcklkKXtjb25zdCBhPXUuY2xvbmVOb2RlKCEwKTtyaSh1KSYmYS5zZWFsKCksdGhpcy5mdWxsTGF5ZXIuZ2V0RWxlbWVudHNCeU5hbWUodS5uYW1lKS5sZW5ndGh8fG4ucHVzaChhKSxpLnB1c2godSk7Y29uc3QgZD0oaD10aGlzLnZOb2Rlcy5nZXQodS5uYW1lKSk9PW51bGw/dm9pZCAwOmgucmVjdDtkJiYodD0kdCh0LGQpKX1yZXR1cm4gaS5mb3JFYWNoKHU9PnUucmVtb3ZlKCkpLG4ubGVuZ3RoJiZ0aGlzLmZ1bGxMYXllci5hcHBlbmQoLi4ubiksdH1zZWFsVG9EcmF3TGF5ZXIoZSl7dmFyIGk7Y29uc3QgdD1bXSxuPVtdO2UuZm9yRWFjaChmPT57dGhpcy5mdWxsTGF5ZXIuZ2V0RWxlbWVudHNCeU5hbWUoZi50b1N0cmluZygpKS5mb3JFYWNoKGg9Pnt2YXIgYTtjb25zdCB1PWguY2xvbmVOb2RlKCEwKTtyaShoKSYmdS5zZWFsKCksKGE9dGhpcy5kcmF3TGF5ZXIpIT1udWxsJiZhLmdldEVsZW1lbnRzQnlOYW1lKGgubmFtZSkubGVuZ3RofHx0LnB1c2godSksbi5wdXNoKGgpfSl9KSxuLmZvckVhY2goZj0+Zi5yZW1vdmUoKSksdCYmKChpPXRoaXMuZHJhd0xheWVyKT09bnVsbHx8aS5hcHBlbmQoLi4udCkpfWdldFNlbGVjdG9yUmVjdChlLHQpe3ZhciBoO2xldCBuO2NvbnN0IGk9KGg9ZS5wYXJlbnQpPT1udWxsP3ZvaWQgMDpoLmdldEVsZW1lbnRCeUlkKHQpLGY9aT09bnVsbD92b2lkIDA6aS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtyZXR1cm4gZiYmKG49JHQobix7eDpNYXRoLmZsb29yKGYueCkseTpNYXRoLmZsb29yKGYueSksdzpNYXRoLnJvdW5kKGYud2lkdGgpLGg6TWF0aC5yb3VuZChmLmhlaWdodCl9KSksbn1pc0NhbkZpbGxDb2xvcihlKXtyZXR1cm4gZT09PUx0LkVsbGlwc2V8fGU9PT1MdC5UcmlhbmdsZXx8ZT09PUx0LlJlY3RhbmdsZXx8ZT09PUx0LlBvbHlnb258fGU9PT1MdC5TdGFyfHxlPT09THQuU3BlZWNoQmFsbG9vbn11cGRhdGVTZWxlY3RvcihlKXtjb25zdHt1cGRhdGVTZWxlY3Rvck9wdDp0LHNlbGVjdElkczpuLHZOb2RlczppLHdpbGxTZXJpYWxpemVEYXRhOmYsd29ya2VyOmh9PWUsdT10aGlzLmRyYXdMYXllcjtpZighdSlyZXR1cm47bGV0IGE7Y29uc3QgZD1uZXcgTWFwLHtib3g6RSx3b3JrU3RhdGU6cCxhbmdsZTpPLHRyYW5zbGF0ZTptfT10O2xldCBiPVswLDBdLE09WzEsMV0seT1bMCwwXSxTO2lmKEV8fG18fEJhLmlzTnVtYmVyKE8pKXtpZihwPT09Y2UuU3RhcnQpcmV0dXJuIGkuc2V0VGFyZ2V0KCkse3R5cGU6VHQuU2VsZWN0LGRhdGFUeXBlOnp0LkxvY2FsLHNlbGVjdFJlY3Q6dGhpcy5vbGRTZWxlY3RSZWN0LHJlY3Q6dGhpcy5vbGRTZWxlY3RSZWN0fTtpZihTPWkuZ2V0TGFzdFRhcmdldCgpLFMmJkUpe2xldCBjO249PW51bGx8fG4uZm9yRWFjaChsPT57Y29uc3Qgdj1TPT1udWxsP3ZvaWQgMDpTLmdldChsKTtjPSR0KGMsdj09bnVsbD92b2lkIDA6di5yZWN0KX0pLGMmJihNPVtFLncvYy53LEUuaC9jLmhdLGI9W0UueCtFLncvMi0oYy54K2Mudy8yKSxFLnkrRS5oLzItKGMueStjLmgvMildLHk9W2MueCtjLncvMixjLnkrYy5oLzJdKX19bj09bnVsbHx8bi5mb3JFYWNoKGM9Pntjb25zdCBsPWkuZ2V0KGMpO2lmKGwpe2NvbnN0e3Rvb2xzVHlwZTp2fT1sO2xldCBUPSh1PT1udWxsP3ZvaWQgMDp1LmdldEVsZW1lbnRzQnlOYW1lKGMpKVswXTtpZihUKXtjb25zdCBSPXsuLi50fTtsZXQgTDtpZih2KXtpZihTJiYoTD1TLmdldChjKSxMJiZFKSl7Ui5ib3hTY2FsZT1NO2NvbnN0IEE9W0wucmVjdC54K0wucmVjdC53LzIsTC5yZWN0LnkrTC5yZWN0LmgvMl0sdz1bQVswXS15WzBdLEFbMV0teVsxXV07Ui5ib3hUcmFuc2xhdGU9W3dbMF0qKE1bMF0tMSkrYlswXSx3WzFdKihNWzFdLTEpK2JbMV1dfWNvbnN0IE49WGEodik7aWYoTj09bnVsbHx8Ti51cGRhdGVOb2RlT3B0KHtub2RlOlQsb3B0OlIsdk5vZGVzOmksd2lsbFNlcmlhbGl6ZURhdGE6Zix0YXJnZXROb2RlOkx9KSxsJiZoJiYoZiYmKFIuYW5nbGV8fFIudHJhbnNsYXRlKXx8Ui5ib3gmJlIud29ya1N0YXRlIT09Y2UuU3RhcnQpKXtjb25zdCBBPWguY3JlYXRlV29ya1NoYXBlTm9kZSh7dG9vbHNUeXBlOnYsdG9vbHNPcHQ6bC5vcHR9KTtBPT1udWxsfHxBLnNldFdvcmtJZChjKTtjb25zdCB3PUE9PW51bGw/dm9pZCAwOkEuY29uc3VtZVNlcnZpY2Uoe29wOmwub3AsaXNGdWxsV29yazohMSxyZXBsYWNlSWQ6Yyxpc0NsZWFyQWxsOiExfSk7dyYmKGwucmVjdD13LGkuc2V0SW5mbyhjLGwpKSxUPSh1PT1udWxsP3ZvaWQgMDp1LmdldEVsZW1lbnRzQnlOYW1lKGMpKVswXX1sJiYoZC5zZXQoYyxsKSxhPSR0KGEsbC5yZWN0KSl9fX19LHRoaXMpLFMmJnA9PT1jZS5Eb25lJiZpLmRlbGV0ZUxhc3RUYXJnZXQoKSx0aGlzLmRyYXcoaWUuc2VsZWN0b3JJZCx1LHtzZWxlY3RJZHM6bnx8W10sc3ViTm9kZU1hcDpkLGludGVyc2VjdFJlY3Q6YX0pO2NvbnN0IHM9JHQodGhpcy5vbGRTZWxlY3RSZWN0LGEpO3JldHVybiB0aGlzLm9sZFNlbGVjdFJlY3Q9YSx7dHlwZTpUdC5TZWxlY3QsZGF0YVR5cGU6enQuTG9jYWwsc2VsZWN0UmVjdDphLHJlY3Q6c319Ymx1clNlbGVjdG9yKCl7Y29uc3QgZT10aGlzLmJhY2tUb0Z1bGxMYXllcigpO3JldHVybnt0eXBlOlR0LlNlbGVjdCxkYXRhVHlwZTp6dC5Mb2NhbCxyZWN0OmUsc2VsZWN0SWRzOltdLHdpbGxTeW5jU2VydmljZTohMH19Z2V0UmlnaHRTZXJ2aWNlSWQoZSl7cmV0dXJuIGUucmVwbGFjZSgiKysiLCItIil9c2VsZWN0U2VydmljZU5vZGUoZSx0KXtjb25zdHtzZWxlY3RJZHM6bn09dCxpPXRoaXMuZ2V0UmlnaHRTZXJ2aWNlSWQoZSksZj10aGlzLmdldFNlbGVjdG9yUmVjdCh0aGlzLmZ1bGxMYXllcixpKTtsZXQgaDtjb25zdCB1PW5ldyBNYXA7cmV0dXJuIG49PW51bGx8fG4uZm9yRWFjaChhPT57Y29uc3QgZD10aGlzLnZOb2Rlcy5nZXQoYSksRT10aGlzLmZ1bGxMYXllci5nZXRFbGVtZW50c0J5TmFtZShhKVswXTtkJiZFJiYoaD0kdChoLGQucmVjdCksdS5zZXQoYSxkKSl9KSx0aGlzLmRyYXcoaSx0aGlzLmZ1bGxMYXllcix7aW50ZXJzZWN0UmVjdDpoLHNlbGVjdElkczpufHxbXSxzdWJOb2RlTWFwOnV9KSwkdChoLGYpfXJlUmVuZGVyU2VsZWN0b3IoKXt2YXIgbjtsZXQgZTtjb25zdCB0PW5ldyBNYXA7cmV0dXJuKG49dGhpcy5zZWxlY3RJZHMpPT1udWxsfHxuLmZvckVhY2goaT0+e2NvbnN0IGY9dGhpcy52Tm9kZXMuZ2V0KGkpO2U9JHQoZSxmPT1udWxsP3ZvaWQgMDpmLnJlY3QpfSx0aGlzKSx0aGlzLmRyYXcoaWUuc2VsZWN0b3JJZCx0aGlzLmRyYXdMYXllcnx8dGhpcy5mdWxsTGF5ZXIse2ludGVyc2VjdFJlY3Q6ZSxzdWJOb2RlTWFwOnQsc2VsZWN0SWRzOnRoaXMuc2VsZWN0SWRzfHxbXX0pLHRoaXMuZ2V0U2VsZWN0ZW9ySW5mbyh0KSx0aGlzLm9sZFNlbGVjdFJlY3Q9ZSxlfXVwZGF0ZVNlbGVjdElkcyhlKXt2YXIgaCx1O2xldCB0O2NvbnN0IG49KGg9dGhpcy5zZWxlY3RJZHMpPT1udWxsP3ZvaWQgMDpoLmZpbHRlcihhPT4hZS5pbmNsdWRlcyhhKSksaT1lLmZpbHRlcihhPT57dmFyIGQ7cmV0dXJuISgoZD10aGlzLnNlbGVjdElkcykhPW51bGwmJmQuaW5jbHVkZXMoYSkpfSk7aWYobiE9bnVsbCYmbi5sZW5ndGgmJih0PXRoaXMuYmFja1RvRnVsbExheWVyKG4pKSxpLmxlbmd0aCl7dGhpcy5zZWFsVG9EcmF3TGF5ZXIoaSk7Zm9yKGNvbnN0IGEgb2YgaSl7Y29uc3QgZD0odT10aGlzLnZOb2Rlcy5nZXQoYSkpPT1udWxsP3ZvaWQgMDp1LnJlY3Q7ZCYmKHQ9JHQodCxkKSl9fXRoaXMuc2VsZWN0SWRzPWU7Y29uc3QgZj10aGlzLnJlUmVuZGVyU2VsZWN0b3IoKTtyZXR1cm57YmdSZWN0OnQsc2VsZWN0UmVjdDpmfX19T2JqZWN0LmRlZmluZVByb3BlcnR5KGllLCJzZWxlY3RvcklkIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6VG19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoaWUsInNlbGVjdG9yQm9yZGVySWQiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZToic2VsZWN0b3ItYm9yZGVyIn0pO2NsYXNzIHphIGV4dGVuZHMgRHR7Y29uc3RydWN0b3IoZSl7c3VwZXIoZSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImNhblJvdGF0ZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOiExfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInNjYWxlVHlwZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOiRlLmJvdGh9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidG9vbHNUeXBlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6THQuQXJyb3d9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidG1wUG9pbnRzIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6W119KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywid29ya09wdGlvbnMiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywib2xkUmVjdCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJhcnJvd1RpcFdpZHRoIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInN5bmNUaW1lc3RhbXAiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSx0aGlzLndvcmtPcHRpb25zPWUudG9vbHNPcHQsdGhpcy5hcnJvd1RpcFdpZHRoPXRoaXMud29ya09wdGlvbnMudGhpY2tuZXNzKjQsdGhpcy5zeW5jVGltZXN0YW1wPTAsdGhpcy5zeW5jVW5pdFRpbWU9NTB9Y29uc3VtZShlKXt2YXIgbTtjb25zdHtkYXRhOnQsaXNGdWxsV29yazpuLGlzU3ViV29ya2VyOml9PWUsZj0obT10PT1udWxsP3ZvaWQgMDp0LndvcmtJZCk9PW51bGw/dm9pZCAwOm0udG9TdHJpbmcoKTtpZighZilyZXR1cm57dHlwZTpUdC5Ob25lfTtjb25zdHtvcDpoLHdvcmtTdGF0ZTp1fT10LGE9aD09bnVsbD92b2lkIDA6aC5sZW5ndGg7aWYoIWF8fGE8MilyZXR1cm57dHlwZTpUdC5Ob25lfTtsZXQgZDtpZih1PT09Y2UuU3RhcnQ/KHRoaXMudG1wUG9pbnRzPVtuZXcgRnQoaFswXSxoWzFdKV0sZD0hMSk6ZD10aGlzLnVwZGF0ZVRlbXBQb2ludHMoaCksIWQpcmV0dXJue3R5cGU6VHQuTm9uZX07aWYoIWkpe2NvbnN0IGI9RGF0ZS5ub3coKTtyZXR1cm4gYi10aGlzLnN5bmNUaW1lc3RhbXA+dGhpcy5zeW5jVW5pdFRpbWU/KHRoaXMuc3luY1RpbWVzdGFtcD1iLHt0eXBlOlR0LkRyYXdXb3JrLGRhdGFUeXBlOnp0LkxvY2FsLHdvcmtJZDpmLG9wOnRoaXMudG1wUG9pbnRzLm1hcChNPT5bLi4uTS5YWSwwXSkuZmxhdCgxKSxpc1N5bmM6ITAsaW5kZXg6MH0pOnt0eXBlOlR0Lk5vbmV9fWNvbnN0IEU9bj90aGlzLmZ1bGxMYXllcjp0aGlzLmRyYXdMYXllcnx8dGhpcy5mdWxsTGF5ZXIscD10aGlzLmRyYXcoe3dvcmtJZDpmLGxheWVyOkV9KSxPPSR0KHAsdGhpcy5vbGRSZWN0KTtyZXR1cm4gdGhpcy5vbGRSZWN0PXAse3JlY3Q6Tyx0eXBlOlR0LkRyYXdXb3JrLGRhdGFUeXBlOnp0LkxvY2FsLHdvcmtJZDpmfX1jb25zdW1lQWxsKGUpe3ZhciBhO2NvbnN0e2RhdGE6dH09ZSxuPShhPXQ9PW51bGw/dm9pZCAwOnQud29ya0lkKT09bnVsbD92b2lkIDA6YS50b1N0cmluZygpO2lmKCFuKXJldHVybnt0eXBlOlR0Lk5vbmV9O2lmKHRoaXMudG1wUG9pbnRzLmxlbmd0aDwyKXJldHVybnt0eXBlOlR0LlJlbW92ZU5vZGUscmVtb3ZlSWRzOltuXX07Y29uc3QgaT10aGlzLmZ1bGxMYXllcixmPXRoaXMuZHJhdyh7d29ya0lkOm4sbGF5ZXI6aX0pO3RoaXMub2xkUmVjdD1mO2NvbnN0IGg9dGhpcy50bXBQb2ludHMubWFwKGQ9PlsuLi5kLlhZLDBdKS5mbGF0KDEpLHU9eXIoaCk7cmV0dXJuIHRoaXMudk5vZGVzLnNldEluZm8obix7cmVjdDpmLG9wOmgsb3B0OnRoaXMud29ya09wdGlvbnMsdG9vbHNUeXBlOnRoaXMudG9vbHNUeXBlLGNhblJvdGF0ZTp0aGlzLmNhblJvdGF0ZSxzY2FsZVR5cGU6dGhpcy5zY2FsZVR5cGUsY2VudGVyUG9zOkR0LmdldENlbnRlclBvcyhmLGkpfSkse3JlY3Q6Zix0eXBlOlR0LkZ1bGxXb3JrLGRhdGFUeXBlOnp0LkxvY2FsLHdvcmtJZDpuLG9wczp1LGlzU3luYzohMH19ZHJhdyhlKXt2YXIgUztjb25zdHt3b3JrSWQ6dCxsYXllcjpufT1lO3RoaXMuZnVsbExheWVyLmdldEVsZW1lbnRzQnlOYW1lKHQpLm1hcChzPT5zLnJlbW92ZSgpKSwoUz10aGlzLmRyYXdMYXllcik9PW51bGx8fFMuZ2V0RWxlbWVudHNCeU5hbWUodCkubWFwKHM9PnMucmVtb3ZlKCkpO2NvbnN0e3N0cm9rZUNvbG9yOmksdGhpY2tuZXNzOmYsekluZGV4Omgsc2NhbGU6dSxyb3RhdGU6YSx0cmFuc2xhdGU6ZH09dGhpcy53b3JrT3B0aW9ucyxFPW4ud29ybGRQb3NpdGlvbixwPW4ud29ybGRTY2FsaW5nLHtwb2ludHM6TyxyZWN0Om19PXRoaXMuY29tcHV0RHJhd1BvaW50cyhmKSxNPXtwb3M6W20ueCttLncvMixtLnkrbS5oLzJdLG5hbWU6dCxpZDp0LGNsb3NlOiEwLHBvaW50czpPLGZpbGxDb2xvcjppLHN0cm9rZUNvbG9yOmksbGluZVdpZHRoOjAsbm9ybWFsaXplOiEwLHpJbmRleDpofTt1JiYoTS5zY2FsZT11KSxhJiYoTS5yb3RhdGU9YSksZCYmKE0udHJhbnNsYXRlPWQpO2NvbnN0IHk9bmV3IGNuKE0pO2lmKG4uYXBwZW5kKHkpLHV8fGF8fGQpe2NvbnN0IHM9eS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtyZXR1cm57eDpNYXRoLmZsb29yKHMueC1EdC5TYWZlQm9yZGVyUGFkZGluZykseTpNYXRoLmZsb29yKHMueS1EdC5TYWZlQm9yZGVyUGFkZGluZyksdzpNYXRoLmZsb29yKHMud2lkdGgrRHQuU2FmZUJvcmRlclBhZGRpbmcqMiksaDpNYXRoLmZsb29yKHMuaGVpZ2h0K0R0LlNhZmVCb3JkZXJQYWRkaW5nKjIpfX1yZXR1cm57eDpNYXRoLmZsb29yKG0ueCpwWzBdK0VbMF0tRHQuU2FmZUJvcmRlclBhZGRpbmcpLHk6TWF0aC5mbG9vcihtLnkqcFsxXStFWzFdLUR0LlNhZmVCb3JkZXJQYWRkaW5nKSx3Ok1hdGguZmxvb3IobS53KnBbMF0rMipEdC5TYWZlQm9yZGVyUGFkZGluZyksaDpNYXRoLmZsb29yKG0uaCpwWzFdKzIqRHQuU2FmZUJvcmRlclBhZGRpbmcpfX1jb21wdXREcmF3UG9pbnRzKGUpe3JldHVybiB0aGlzLnRtcFBvaW50c1sxXS5kaXN0YW5jZSh0aGlzLnRtcFBvaW50c1swXSk+dGhpcy5hcnJvd1RpcFdpZHRoP3RoaXMuY29tcHV0RnVsbEFycm93UG9pbnRzKGUpOnRoaXMuY29tcHV0VHJpYW5nbGVQb2ludHMoKX1jb21wdXRGdWxsQXJyb3dQb2ludHMoZSl7Y29uc3QgdD1FdC5TdWIodGhpcy50bXBQb2ludHNbMV0sdGhpcy50bXBQb2ludHNbMF0pLnVuaSgpLG49RXQuUGVyKHQpLm11bChlLzIpLGk9RnQuU3ViKHRoaXMudG1wUG9pbnRzWzBdLG4pLGY9RnQuQWRkKHRoaXMudG1wUG9pbnRzWzBdLG4pLGg9RXQuTXVsKHQsdGhpcy5hcnJvd1RpcFdpZHRoKSx1PUV0LlN1Yih0aGlzLnRtcFBvaW50c1sxXSxoKSxhPUZ0LlN1Yih1LG4pLGQ9RnQuQWRkKHUsbiksRT1FdC5QZXIodCkubXVsKGUqMS41KSxwPUZ0LlN1Yih1LEUpLE89RnQuQWRkKHUsRSksbT1baSxhLHAsdGhpcy50bXBQb2ludHNbMV0sTyxkLGZdO3JldHVybntwb2ludHM6bS5tYXAoYj0+RnQuU3ViKGIsdGhpcy50bXBQb2ludHNbMF0pLlhZKS5mbGF0KDEpLHJlY3Q6eGUobSksaXNUcmlhbmdsZTohMSxwb3M6dGhpcy50bXBQb2ludHNbMF0uWFl9fWNvbXB1dFRyaWFuZ2xlUG9pbnRzKCl7Y29uc3QgZT1FdC5TdWIodGhpcy50bXBQb2ludHNbMV0sdGhpcy50bXBQb2ludHNbMF0pLnVuaSgpLHQ9dGhpcy50bXBQb2ludHNbMV0uZGlzdGFuY2UodGhpcy50bXBQb2ludHNbMF0pLG49RXQuUGVyKGUpLm11bChNYXRoLmZsb29yKHQqMy84KSksaT1GdC5TdWIodGhpcy50bXBQb2ludHNbMF0sbiksZj1GdC5BZGQodGhpcy50bXBQb2ludHNbMF0sbiksaD1baSx0aGlzLnRtcFBvaW50c1sxXSxmXTtyZXR1cm57cG9pbnRzOmgubWFwKHU9PkZ0LlN1Yih1LHRoaXMudG1wUG9pbnRzWzBdKS5YWSkuZmxhdCgxKSxyZWN0OnhlKGgpLGlzVHJpYW5nbGU6ITAscG9zOnRoaXMudG1wUG9pbnRzWzBdLlhZfX11cGRhdGVUZW1wUG9pbnRzKGUpe2NvbnN0IHQ9ZS5zbGljZSgtMiksbj1uZXcgRnQodFswXSx0WzFdKSxpPXRoaXMudG1wUG9pbnRzWzBdLHt0aGlja25lc3M6Zn09dGhpcy53b3JrT3B0aW9ucztpZihpLmlzTmVhcihuLGYpKXJldHVybiExO2lmKHRoaXMudG1wUG9pbnRzLmxlbmd0aD09PTIpe2lmKG4uaXNOZWFyKHRoaXMudG1wUG9pbnRzWzFdLDEpKXJldHVybiExO3RoaXMudG1wUG9pbnRzWzFdPW59ZWxzZSB0aGlzLnRtcFBvaW50cy5wdXNoKG4pO3JldHVybiEwfWNvbnN1bWVTZXJ2aWNlKGUpe3ZhciB1O2NvbnN0e29wOnQsaXNGdWxsV29yazpufT1lLGk9KHU9dGhpcy53b3JrSWQpPT1udWxsP3ZvaWQgMDp1LnRvU3RyaW5nKCk7aWYoIWkpcmV0dXJuO3RoaXMudG1wUG9pbnRzLmxlbmd0aD0wO2ZvcihsZXQgYT0wO2E8dC5sZW5ndGg7YSs9Myl0aGlzLnRtcFBvaW50cy5wdXNoKG5ldyBGdCh0W2FdLHRbYSsxXSx0W2ErMl0pKTtjb25zdCBmPW4/dGhpcy5mdWxsTGF5ZXI6dGhpcy5kcmF3TGF5ZXJ8fHRoaXMuZnVsbExheWVyLGg9dGhpcy5kcmF3KHt3b3JrSWQ6aSxsYXllcjpmfSk7cmV0dXJuIHRoaXMub2xkUmVjdD1oLHRoaXMudk5vZGVzLnNldEluZm8oaSx7cmVjdDpoLG9wOnQsb3B0OnRoaXMud29ya09wdGlvbnMsdG9vbHNUeXBlOnRoaXMudG9vbHNUeXBlLGNhblJvdGF0ZTp0aGlzLmNhblJvdGF0ZSxzY2FsZVR5cGU6dGhpcy5zY2FsZVR5cGUsY2VudGVyUG9zOkR0LmdldENlbnRlclBvcyhoLGYpfSksaH1jbGVhclRtcFBvaW50cygpe3RoaXMudG1wUG9pbnRzLmxlbmd0aD0wfXN0YXRpYyB1cGRhdGVOb2RlT3B0KGUpe3ZhciB1O2NvbnN0e25vZGU6dCxvcHQ6bix2Tm9kZXM6aX09ZSx7c3Ryb2tlQ29sb3I6Zn09bixoPWkuZ2V0KHQubmFtZSk7cmV0dXJuIGYmJih0LnNldEF0dHJpYnV0ZSgic3Ryb2tlQ29sb3IiLGYpLHQuc2V0QXR0cmlidXRlKCJmaWxsQ29sb3IiLGYpLCh1PWg9PW51bGw/dm9pZCAwOmgub3B0KSE9bnVsbCYmdS5zdHJva2VDb2xvciYmKGgub3B0LnN0cm9rZUNvbG9yPWYpLGgmJmkuc2V0SW5mbyh0Lm5hbWUsaCkpLER0LnVwZGF0ZU5vZGVPcHQoZSl9fWNsYXNzICRhIGV4dGVuZHMgRHR7Y29uc3RydWN0b3IoZSl7c3VwZXIoZSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImNhblJvdGF0ZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOiExfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInNjYWxlVHlwZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOiRlLmFsbH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ0b29sc1R5cGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpMdC5FbGxpcHNlfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInRtcFBvaW50cyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOltdfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIndvcmtPcHRpb25zIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIm9sZFJlY3QiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywic3luY1RpbWVzdGFtcCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLHRoaXMud29ya09wdGlvbnM9ZS50b29sc09wdCx0aGlzLnN5bmNUaW1lc3RhbXA9MCx0aGlzLnN5bmNVbml0VGltZT01MH1jb25zdW1lKGUpe3ZhciBtO2NvbnN0e2RhdGE6dCxpc0Z1bGxXb3JrOm4saXNTdWJXb3JrZXI6aX09ZSxmPShtPXQ9PW51bGw/dm9pZCAwOnQud29ya0lkKT09bnVsbD92b2lkIDA6bS50b1N0cmluZygpO2lmKCFmKXJldHVybnt0eXBlOlR0Lk5vbmV9O2NvbnN0e29wOmgsd29ya1N0YXRlOnV9PXQsYT1oPT1udWxsP3ZvaWQgMDpoLmxlbmd0aDtpZighYXx8YTwyKXJldHVybnt0eXBlOlR0Lk5vbmV9O2xldCBkO2lmKHU9PT1jZS5TdGFydD8odGhpcy50bXBQb2ludHM9W25ldyBGdChoWzBdLGhbMV0pXSxkPSExKTpkPXRoaXMudXBkYXRlVGVtcFBvaW50cyhoKSwhZClyZXR1cm57dHlwZTpUdC5Ob25lfTtpZighaSl7Y29uc3QgYj1EYXRlLm5vdygpO3JldHVybiBiLXRoaXMuc3luY1RpbWVzdGFtcD50aGlzLnN5bmNVbml0VGltZT8odGhpcy5zeW5jVGltZXN0YW1wPWIse3R5cGU6VHQuRHJhd1dvcmssZGF0YVR5cGU6enQuTG9jYWwsd29ya0lkOmYsb3A6dGhpcy50bXBQb2ludHMubWFwKE09PlsuLi5NLlhZLDBdKS5mbGF0KDEpLGlzU3luYzohMCxpbmRleDowfSk6e3R5cGU6VHQuTm9uZX19Y29uc3QgRT1uP3RoaXMuZnVsbExheWVyOnRoaXMuZHJhd0xheWVyfHx0aGlzLmZ1bGxMYXllcixwPXRoaXMuZHJhdyh7d29ya0lkOmYsbGF5ZXI6RSxpc0RyYXdpbmc6ITB9KSxPPSR0KHAsdGhpcy5vbGRSZWN0KTtyZXR1cm4gdGhpcy5vbGRSZWN0PXAse3JlY3Q6Tyx0eXBlOlR0LkRyYXdXb3JrLGRhdGFUeXBlOnp0LkxvY2FsLHdvcmtJZDpmfX1jb25zdW1lQWxsKGUpe3ZhciBhO2NvbnN0e2RhdGE6dH09ZSxuPShhPXQ9PW51bGw/dm9pZCAwOnQud29ya0lkKT09bnVsbD92b2lkIDA6YS50b1N0cmluZygpO2lmKCFuKXJldHVybnt0eXBlOlR0Lk5vbmV9O2lmKHRoaXMudG1wUG9pbnRzLmxlbmd0aDwyKXJldHVybnt0eXBlOlR0LlJlbW92ZU5vZGUscmVtb3ZlSWRzOltuXX07Y29uc3QgaT10aGlzLmZ1bGxMYXllcixmPXRoaXMuZHJhdyh7d29ya0lkOm4sbGF5ZXI6aSxpc0RyYXdpbmc6ITF9KTt0aGlzLm9sZFJlY3Q9Zjtjb25zdCBoPXRoaXMudG1wUG9pbnRzLm1hcChkPT5bLi4uZC5YWSwwXSkuZmxhdCgxKSx1PXlyKGgpO3JldHVybiB0aGlzLnZOb2Rlcy5zZXRJbmZvKG4se3JlY3Q6ZixvcDpoLG9wdDp0aGlzLndvcmtPcHRpb25zLHRvb2xzVHlwZTp0aGlzLnRvb2xzVHlwZSxjYW5Sb3RhdGU6dGhpcy5jYW5Sb3RhdGUsc2NhbGVUeXBlOnRoaXMuc2NhbGVUeXBlLGNlbnRlclBvczpmJiZEdC5nZXRDZW50ZXJQb3MoZixpKX0pLHtyZWN0OmYsdHlwZTpUdC5GdWxsV29yayxkYXRhVHlwZTp6dC5Mb2NhbCx3b3JrSWQ6bixvcHM6dSxpc1N5bmM6ITB9fWRyYXcoZSl7dmFyIGw7Y29uc3R7d29ya0lkOnQsbGF5ZXI6bixpc0RyYXdpbmc6aX09ZTt0aGlzLmZ1bGxMYXllci5nZXRFbGVtZW50c0J5TmFtZSh0KS5tYXAodj0+di5yZW1vdmUoKSksKGw9dGhpcy5kcmF3TGF5ZXIpPT1udWxsfHxsLmdldEVsZW1lbnRzQnlOYW1lKHQpLm1hcCh2PT52LnJlbW92ZSgpKTtjb25zdHtzdHJva2VDb2xvcjpmLGZpbGxDb2xvcjpoLHRoaWNrbmVzczp1LHpJbmRleDphLHNjYWxlOmQscm90YXRlOkUsdHJhbnNsYXRlOnB9PXRoaXMud29ya09wdGlvbnMsTz1uLndvcmxkUG9zaXRpb24sbT1uLndvcmxkU2NhbGluZyx7cmFkaXVzOmIscmVjdDpNLHBvczp5fT10aGlzLmNvbXB1dERyYXdQb2ludHModSksUz17cG9zOnksbmFtZTp0LGlkOnQscmFkaXVzOmIsbGluZVdpZHRoOnUsZmlsbENvbG9yOmghPT0idHJhbnNwYXJlbnQiJiZofHx2b2lkIDAsc3Ryb2tlQ29sb3I6Zixub3JtYWxpemU6ITAsekluZGV4OmF9LHM9e3g6TWF0aC5mbG9vcihNLngqbVswXStPWzBdLUR0LlNhZmVCb3JkZXJQYWRkaW5nKSx5Ok1hdGguZmxvb3IoTS55Km1bMV0rT1sxXS1EdC5TYWZlQm9yZGVyUGFkZGluZyksdzpNYXRoLmZsb29yKE0udyptWzBdKzIqRHQuU2FmZUJvcmRlclBhZGRpbmcpLGg6TWF0aC5mbG9vcihNLmgqbVsxXSsyKkR0LlNhZmVCb3JkZXJQYWRkaW5nKX07aWYoaSl7Y29uc3R7bmFtZTp2LGlkOlQsekluZGV4OlIsc3Ryb2tlQ29sb3I6TH09UyxOPUR0LmdldENlbnRlclBvcyhzLG4pLEE9bmV3IElyKHtuYW1lOnYsaWQ6VCx6SW5kZXg6Uixwb3M6TixhbmNob3I6Wy41LC41XSxzaXplOltzLncscy5oXX0pLHc9bmV3IFdhKHsuLi5TLHBvczpbMCwwXX0pLEI9bmV3IEhyKHtkOiJNLTQsMEg0TTAsLTRWNCIsbm9ybWFsaXplOiEwLHBvczpbMCwwXSxzdHJva2VDb2xvcjpMLGxpbmVXaWR0aDoxLHNjYWxlOlsxL21bMF0sMS9tWzFdXX0pO3JldHVybiBBLmFwcGVuZCh3LEIpLG4uYXBwZW5kKEEpLHN9ZCYmKFMuc2NhbGU9ZCksRSYmKFMucm90YXRlPUUpLHAmJihTLnRyYW5zbGF0ZT1wKTtjb25zdCBjPW5ldyBXYShTKTtpZihuLmFwcGVuZChjKSxFfHxkfHxwKXtjb25zdCB2PWMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7cmV0dXJue3g6TWF0aC5mbG9vcih2LngtRHQuU2FmZUJvcmRlclBhZGRpbmcpLHk6TWF0aC5mbG9vcih2LnktRHQuU2FmZUJvcmRlclBhZGRpbmcpLHc6TWF0aC5mbG9vcih2LndpZHRoK0R0LlNhZmVCb3JkZXJQYWRkaW5nKjIpLGg6TWF0aC5mbG9vcih2LmhlaWdodCtEdC5TYWZlQm9yZGVyUGFkZGluZyoyKX19cmV0dXJuIHN9Y29tcHV0RHJhd1BvaW50cyhlKXtjb25zdCB0PXhlKHRoaXMudG1wUG9pbnRzKSxuPXhlKHRoaXMudG1wUG9pbnRzLGUpLGk9W01hdGguZmxvb3IodC54K3Qudy8yKSxNYXRoLmZsb29yKHQueSt0LmgvMildO3JldHVybntyZWN0Om4scG9zOmkscmFkaXVzOltNYXRoLmZsb29yKHQudy8yKSxNYXRoLmZsb29yKHQuaC8yKV19fXVwZGF0ZVRlbXBQb2ludHMoZSl7Y29uc3QgdD1lLnNsaWNlKC0yKSxuPW5ldyBGdCh0WzBdLHRbMV0pLGk9dGhpcy50bXBQb2ludHNbMF0se3RoaWNrbmVzczpmfT10aGlzLndvcmtPcHRpb25zO2lmKGkuaXNOZWFyKG4sZikpcmV0dXJuITE7aWYodGhpcy50bXBQb2ludHMubGVuZ3RoPT09Mil7aWYobi5pc05lYXIodGhpcy50bXBQb2ludHNbMV0sMSkpcmV0dXJuITE7dGhpcy50bXBQb2ludHNbMV09bn1lbHNlIHRoaXMudG1wUG9pbnRzLnB1c2gobik7cmV0dXJuITB9Y29uc3VtZVNlcnZpY2UoZSl7dmFyIHU7Y29uc3R7b3A6dCxpc0Z1bGxXb3JrOm59PWUsaT0odT10aGlzLndvcmtJZCk9PW51bGw/dm9pZCAwOnUudG9TdHJpbmcoKTtpZighaSlyZXR1cm47dGhpcy50bXBQb2ludHMubGVuZ3RoPTA7Zm9yKGxldCBhPTA7YTx0Lmxlbmd0aDthKz0zKXRoaXMudG1wUG9pbnRzLnB1c2gobmV3IEZ0KHRbYV0sdFthKzFdLHRbYSsyXSkpO2NvbnN0IGY9bj90aGlzLmZ1bGxMYXllcjp0aGlzLmRyYXdMYXllcnx8dGhpcy5mdWxsTGF5ZXIsaD10aGlzLmRyYXcoe3dvcmtJZDppLGxheWVyOmYsaXNEcmF3aW5nOiExfSk7cmV0dXJuIHRoaXMub2xkUmVjdD1oLHRoaXMudk5vZGVzLnNldEluZm8oaSx7cmVjdDpoLG9wOnQsb3B0OnRoaXMud29ya09wdGlvbnMsdG9vbHNUeXBlOnRoaXMudG9vbHNUeXBlLGNhblJvdGF0ZTp0aGlzLmNhblJvdGF0ZSxzY2FsZVR5cGU6dGhpcy5zY2FsZVR5cGUsY2VudGVyUG9zOkR0LmdldENlbnRlclBvcyhoLGYpfSksaH1jbGVhclRtcFBvaW50cygpe3RoaXMudG1wUG9pbnRzLmxlbmd0aD0wfXN0YXRpYyB1cGRhdGVOb2RlT3B0KGUpe3ZhciBkLEU7Y29uc3R7bm9kZTp0LG9wdDpuLHZOb2RlczppfT1lLHtzdHJva2VDb2xvcjpmLGZpbGxDb2xvcjpofT1uLHU9aS5nZXQodC5uYW1lKTtsZXQgYT10O3JldHVybiB0LnRhZ05hbWU9PT0iR1JPVVAiJiYoYT10LmNoaWxkcmVuWzBdKSxmJiYoYS5zZXRBdHRyaWJ1dGUoInN0cm9rZUNvbG9yIixmKSwoZD11PT1udWxsP3ZvaWQgMDp1Lm9wdCkhPW51bGwmJmQuc3Ryb2tlQ29sb3ImJih1Lm9wdC5zdHJva2VDb2xvcj1mKSksaCYmKGg9PT0idHJhbnNwYXJlbnQiP2Euc2V0QXR0cmlidXRlKCJmaWxsQ29sb3IiLCJyZ2JhKDAsMCwwLDApIik6YS5zZXRBdHRyaWJ1dGUoImZpbGxDb2xvciIsaCksKEU9dT09bnVsbD92b2lkIDA6dS5vcHQpIT1udWxsJiZFLmZpbGxDb2xvciYmKHUub3B0LmZpbGxDb2xvcj1oKSksdSYmaS5zZXRJbmZvKHQubmFtZSx1KSxEdC51cGRhdGVOb2RlT3B0KGUpfX1jbGFzcyBHYSBleHRlbmRzIER0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJjYW5Sb3RhdGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzY2FsZVR5cGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTokZS5hbGx9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidG9vbHNUeXBlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6THQuUmVjdGFuZ2xlfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInRtcFBvaW50cyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOltdfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIndvcmtPcHRpb25zIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIm9sZFJlY3QiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywic3luY1RpbWVzdGFtcCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLHRoaXMud29ya09wdGlvbnM9ZS50b29sc09wdCx0aGlzLnN5bmNUaW1lc3RhbXA9MCx0aGlzLnN5bmNVbml0VGltZT01MH10cmFuc2Zvcm1EYXRhKCl7Y29uc3QgZT14ZSh0aGlzLnRtcFBvaW50cyk7cmV0dXJuW1tlLngsZS55LDBdLFtlLngrZS53LGUueSwwXSxbZS54K2UudyxlLnkrZS5oLDBdLFtlLngsZS55K2UuaCwwXV19Y29tcHV0RHJhd1BvaW50cyhlKXtjb25zdHt0aGlja25lc3M6dH09dGhpcy53b3JrT3B0aW9ucyxuPVtdO2Zvcihjb25zdCBoIG9mIGUpbi5wdXNoKG5ldyBFdCguLi5oKSk7Y29uc3QgaT14ZShuLHQpLGY9W2kueCtpLncvMixpLnkraS5oLzJdO3JldHVybntyZWN0OmkscG9zOmYscG9pbnRzOm4ubWFwKGg9PmguWFkpLmZsYXQoMSl9fWNvbnN1bWUoZSl7dmFyIGI7Y29uc3R7ZGF0YTp0LGlzRnVsbFdvcms6bixpc1N1YldvcmtlcjppfT1lLGY9KGI9dD09bnVsbD92b2lkIDA6dC53b3JrSWQpPT1udWxsP3ZvaWQgMDpiLnRvU3RyaW5nKCk7aWYoIWYpcmV0dXJue3R5cGU6VHQuTm9uZX07Y29uc3R7b3A6aCx3b3JrU3RhdGU6dX09dCxhPWg9PW51bGw/dm9pZCAwOmgubGVuZ3RoO2lmKCFhfHxhPDIpcmV0dXJue3R5cGU6VHQuTm9uZX07bGV0IGQ7aWYodT09PWNlLlN0YXJ0Pyh0aGlzLnRtcFBvaW50cz1bbmV3IEZ0KGhbMF0saFsxXSldLGQ9ITEpOmQ9dGhpcy51cGRhdGVUZW1wUG9pbnRzKGgpLCFkKXJldHVybnt0eXBlOlR0Lk5vbmV9O2NvbnN0IEU9dGhpcy50cmFuc2Zvcm1EYXRhKCk7aWYoIWkpe2NvbnN0IE09RGF0ZS5ub3coKTtyZXR1cm4gTS10aGlzLnN5bmNUaW1lc3RhbXA+dGhpcy5zeW5jVW5pdFRpbWU/KHRoaXMuc3luY1RpbWVzdGFtcD1NLHt0eXBlOlR0LkRyYXdXb3JrLGRhdGFUeXBlOnp0LkxvY2FsLHdvcmtJZDpmLG9wOkUuZmxhdCgxKSxpc1N5bmM6ITAsaW5kZXg6MH0pOnt0eXBlOlR0Lk5vbmV9fWNvbnN0IHA9bj90aGlzLmZ1bGxMYXllcjp0aGlzLmRyYXdMYXllcnx8dGhpcy5mdWxsTGF5ZXIsTz10aGlzLmRyYXcoe3BzOkUsd29ya0lkOmYsbGF5ZXI6cCxpc0RyYXdpbmc6ITB9KSxtPSR0KE8sdGhpcy5vbGRSZWN0KTtyZXR1cm4gdGhpcy5vbGRSZWN0PU8se3JlY3Q6bSx0eXBlOlR0LkRyYXdXb3JrLGRhdGFUeXBlOnp0LkxvY2FsLHdvcmtJZDpmfX1jb25zdW1lQWxsKGUpe3ZhciBkO2NvbnN0e2RhdGE6dH09ZSxuPShkPXQ9PW51bGw/dm9pZCAwOnQud29ya0lkKT09bnVsbD92b2lkIDA6ZC50b1N0cmluZygpO2lmKCFuKXJldHVybnt0eXBlOlR0Lk5vbmV9O2lmKHRoaXMudG1wUG9pbnRzLmxlbmd0aDwyKXJldHVybnt0eXBlOlR0LlJlbW92ZU5vZGUscmVtb3ZlSWRzOltuXX07Y29uc3QgaT10aGlzLnRyYW5zZm9ybURhdGEoKSxmPXRoaXMuZnVsbExheWVyLGg9dGhpcy5kcmF3KHtwczppLHdvcmtJZDpuLGxheWVyOmYsaXNEcmF3aW5nOiExfSk7dGhpcy5vbGRSZWN0PWg7Y29uc3QgdT1pLmZsYXQoMSksYT15cih1KTtyZXR1cm4gdGhpcy52Tm9kZXMuc2V0SW5mbyhuLHtyZWN0Omgsb3A6dSxvcHQ6dGhpcy53b3JrT3B0aW9ucyx0b29sc1R5cGU6dGhpcy50b29sc1R5cGUsc2NhbGVUeXBlOnRoaXMuc2NhbGVUeXBlLGNhblJvdGF0ZTp0aGlzLmNhblJvdGF0ZSxjZW50ZXJQb3M6aCYmRHQuZ2V0Q2VudGVyUG9zKGgsZil9KSx7cmVjdDpoLHR5cGU6VHQuRnVsbFdvcmssZGF0YVR5cGU6enQuTG9jYWwsd29ya0lkOm4sb3BzOmEsaXNTeW5jOiEwfX1kcmF3KGUpe3ZhciBMO2NvbnN0e3dvcmtJZDp0LGxheWVyOm4saXNEcmF3aW5nOmkscHM6ZixyZXBsYWNlSWQ6aH09ZTt0aGlzLmZ1bGxMYXllci5nZXRFbGVtZW50c0J5TmFtZShofHx0KS5tYXAoTj0+Ti5yZW1vdmUoKSksKEw9dGhpcy5kcmF3TGF5ZXIpPT1udWxsfHxMLmdldEVsZW1lbnRzQnlOYW1lKGh8fHQpLm1hcChOPT5OLnJlbW92ZSgpKTtjb25zdHtzdHJva2VDb2xvcjp1LGZpbGxDb2xvcjphLHRoaWNrbmVzczpkLHpJbmRleDpFLHNjYWxlOnAscm90YXRlOk8sdHJhbnNsYXRlOm0sdGV4dE9wdDpifT10aGlzLndvcmtPcHRpb25zLE09bi53b3JsZFBvc2l0aW9uLHk9bi53b3JsZFNjYWxpbmcse3BvaW50czpTLHJlY3Q6cyxwb3M6Y309dGhpcy5jb21wdXREcmF3UG9pbnRzKGYpLGw9e2Nsb3NlOiEwLG5vcm1hbGl6ZTohMCxwb2ludHM6UyxsaW5lV2lkdGg6ZCxmaWxsQ29sb3I6YSE9PSJ0cmFuc3BhcmVudCImJmF8fHZvaWQgMCxzdHJva2VDb2xvcjp1LGxpbmVKb2luOiJyb3VuZCJ9LHY9e3g6TWF0aC5mbG9vcihzLngqeVswXStNWzBdLUR0LlNhZmVCb3JkZXJQYWRkaW5nKSx5Ok1hdGguZmxvb3Iocy55KnlbMV0rTVsxXS1EdC5TYWZlQm9yZGVyUGFkZGluZyksdzpNYXRoLmZsb29yKHMudyp5WzBdKzIqRHQuU2FmZUJvcmRlclBhZGRpbmcpLGg6TWF0aC5mbG9vcihzLmgqeVswXSsyKkR0LlNhZmVCb3JkZXJQYWRkaW5nKX0sVD1uZXcgSXIoe25hbWU6dCxpZDp0LHpJbmRleDpFLHBvczpjLGFuY2hvcjpbLjUsLjVdLHNpemU6W3MudyxzLmhdLHNjYWxlOnAscm90YXRlOk8sdHJhbnNsYXRlOm19KSxSPW5ldyBjbih7Li4ubCxwb3M6WzAsMF19KTtpZihULmFwcGVuZENoaWxkKFIpLGkpe2NvbnN0IE49bmV3IEhyKHtkOiJNLTQsMEg0TTAsLTRWNCIsbm9ybWFsaXplOiEwLHBvczpbMCwwXSxzdHJva2VDb2xvcjp1LGxpbmVXaWR0aDoxLHNjYWxlOlsxL3lbMF0sMS95WzFdXX0pO1QuYXBwZW5kQ2hpbGQoTil9aWYobi5hcHBlbmQoVCkscHx8T3x8bSl7Y29uc3QgTj1ULmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO3JldHVybnt4Ok1hdGguZmxvb3IoTi54LUR0LlNhZmVCb3JkZXJQYWRkaW5nKSx5Ok1hdGguZmxvb3IoTi55LUR0LlNhZmVCb3JkZXJQYWRkaW5nKSx3Ok1hdGguZmxvb3IoTi53aWR0aCsyKkR0LlNhZmVCb3JkZXJQYWRkaW5nKSxoOk1hdGguZmxvb3IoTi5oZWlnaHQrMipEdC5TYWZlQm9yZGVyUGFkZGluZyl9fXJldHVybiB2fXVwZGF0ZVRlbXBQb2ludHMoZSl7Y29uc3QgdD1lLnNsaWNlKC0yKSxuPW5ldyBGdCh0WzBdLHRbMV0pLGk9dGhpcy50bXBQb2ludHNbMF0se3RoaWNrbmVzczpmfT10aGlzLndvcmtPcHRpb25zO2lmKGkuaXNOZWFyKG4sZikpcmV0dXJuITE7aWYodGhpcy50bXBQb2ludHMubGVuZ3RoPT09Mil7aWYobi5pc05lYXIodGhpcy50bXBQb2ludHNbMV0sMSkpcmV0dXJuITE7dGhpcy50bXBQb2ludHNbMV09bn1lbHNlIHRoaXMudG1wUG9pbnRzLnB1c2gobik7cmV0dXJuITB9Y29uc3VtZVNlcnZpY2UoZSl7dmFyIGQ7Y29uc3R7b3A6dCxpc0Z1bGxXb3JrOm4scmVwbGFjZUlkOml9PWUsZj0oZD10aGlzLndvcmtJZCk9PW51bGw/dm9pZCAwOmQudG9TdHJpbmcoKTtpZighZilyZXR1cm47Y29uc3QgaD1bXTtmb3IobGV0IEU9MDtFPHQubGVuZ3RoO0UrPTMpaC5wdXNoKFt0W0VdLHRbRSsxXSx0W0UrMl1dKTtjb25zdCB1PW4/dGhpcy5mdWxsTGF5ZXI6dGhpcy5kcmF3TGF5ZXJ8fHRoaXMuZnVsbExheWVyLGE9dGhpcy5kcmF3KHtwczpoLHdvcmtJZDpmLGxheWVyOnUsaXNEcmF3aW5nOiExLHJlcGxhY2VJZDppfSk7cmV0dXJuIHRoaXMub2xkUmVjdD1hLHRoaXMudk5vZGVzLnNldEluZm8oZix7cmVjdDphLG9wOnQsb3B0OnRoaXMud29ya09wdGlvbnMsdG9vbHNUeXBlOnRoaXMudG9vbHNUeXBlLHNjYWxlVHlwZTp0aGlzLnNjYWxlVHlwZSxjYW5Sb3RhdGU6dGhpcy5jYW5Sb3RhdGUsY2VudGVyUG9zOmEmJkR0LmdldENlbnRlclBvcyhhLHUpfSksYX1jbGVhclRtcFBvaW50cygpe3RoaXMudG1wUG9pbnRzLmxlbmd0aD0wfXN0YXRpYyB1cGRhdGVOb2RlT3B0KGUpe3ZhciBkLEU7Y29uc3R7bm9kZTp0LG9wdDpuLHZOb2RlczppfT1lLHtzdHJva2VDb2xvcjpmLGZpbGxDb2xvcjpofT1uLHU9aS5nZXQodC5uYW1lKTtsZXQgYT10O3JldHVybiB0LnRhZ05hbWU9PT0iR1JPVVAiJiYoYT10LmNoaWxkcmVuWzBdKSxmJiYoYS5zZXRBdHRyaWJ1dGUoInN0cm9rZUNvbG9yIixmKSwoZD11PT1udWxsP3ZvaWQgMDp1Lm9wdCkhPW51bGwmJmQuc3Ryb2tlQ29sb3ImJih1Lm9wdC5zdHJva2VDb2xvcj1mKSksaCYmKGg9PT0idHJhbnNwYXJlbnQiP2Euc2V0QXR0cmlidXRlKCJmaWxsQ29sb3IiLCJyZ2JhKDAsMCwwLDApIik6YS5zZXRBdHRyaWJ1dGUoImZpbGxDb2xvciIsaCksKEU9dT09bnVsbD92b2lkIDA6dS5vcHQpIT1udWxsJiZFLmZpbGxDb2xvciYmKHUub3B0LmZpbGxDb2xvcj1oKSksdSYmaS5zZXRJbmZvKHQubmFtZSx1KSxEdC51cGRhdGVOb2RlT3B0KGUpfX1jbGFzcyBLYSBleHRlbmRzIER0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJjYW5Sb3RhdGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTohMX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzY2FsZVR5cGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTokZS5hbGx9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidG9vbHNUeXBlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6THQuU3Rhcn0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ0bXBQb2ludHMiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpbXX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ3b3JrT3B0aW9ucyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJvbGRSZWN0Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInN5bmNUaW1lc3RhbXAiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSx0aGlzLndvcmtPcHRpb25zPWUudG9vbHNPcHQsdGhpcy5zeW5jVGltZXN0YW1wPTAsdGhpcy5zeW5jVW5pdFRpbWU9NTB9Y29uc3VtZShlKXt2YXIgbTtjb25zdHtkYXRhOnQsaXNGdWxsV29yazpuLGlzU3ViV29ya2VyOml9PWUsZj0obT10PT1udWxsP3ZvaWQgMDp0LndvcmtJZCk9PW51bGw/dm9pZCAwOm0udG9TdHJpbmcoKTtpZighZilyZXR1cm57dHlwZTpUdC5Ob25lfTtjb25zdHtvcDpoLHdvcmtTdGF0ZTp1fT10LGE9aD09bnVsbD92b2lkIDA6aC5sZW5ndGg7aWYoIWF8fGE8MilyZXR1cm57dHlwZTpUdC5Ob25lfTtsZXQgZDtpZih1PT09Y2UuU3RhcnQ/KHRoaXMudG1wUG9pbnRzPVtuZXcgRnQoaFswXSxoWzFdKV0sZD0hMSk6ZD10aGlzLnVwZGF0ZVRlbXBQb2ludHMoaCksIWQpcmV0dXJue3R5cGU6VHQuTm9uZX07aWYoIWkpe2NvbnN0IGI9RGF0ZS5ub3coKTtyZXR1cm4gYi10aGlzLnN5bmNUaW1lc3RhbXA+dGhpcy5zeW5jVW5pdFRpbWU/KHRoaXMuc3luY1RpbWVzdGFtcD1iLHt0eXBlOlR0LkRyYXdXb3JrLGRhdGFUeXBlOnp0LkxvY2FsLHdvcmtJZDpmLG9wOnRoaXMudG1wUG9pbnRzLm1hcChNPT5bLi4uTS5YWSwwXSkuZmxhdCgxKSxpc1N5bmM6ITAsaW5kZXg6MH0pOnt0eXBlOlR0Lk5vbmV9fWNvbnN0IEU9bj90aGlzLmZ1bGxMYXllcjp0aGlzLmRyYXdMYXllcnx8dGhpcy5mdWxsTGF5ZXIscD10aGlzLmRyYXcoe3dvcmtJZDpmLGxheWVyOkUsaXNEcmF3aW5nOiEwfSksTz0kdChwLHRoaXMub2xkUmVjdCk7cmV0dXJuIHRoaXMub2xkUmVjdD1wLHtyZWN0Ok8sdHlwZTpUdC5EcmF3V29yayxkYXRhVHlwZTp6dC5Mb2NhbCx3b3JrSWQ6Zn19Y29uc3VtZUFsbChlKXt2YXIgYTtjb25zdHtkYXRhOnR9PWUsbj0oYT10PT1udWxsP3ZvaWQgMDp0LndvcmtJZCk9PW51bGw/dm9pZCAwOmEudG9TdHJpbmcoKTtpZighbilyZXR1cm57dHlwZTpUdC5Ob25lfTtpZih0aGlzLnRtcFBvaW50cy5sZW5ndGg8MilyZXR1cm57dHlwZTpUdC5SZW1vdmVOb2RlLHJlbW92ZUlkczpbbl19O2NvbnN0IGk9dGhpcy5mdWxsTGF5ZXIsZj10aGlzLmRyYXcoe3dvcmtJZDpuLGxheWVyOmksaXNEcmF3aW5nOiExfSk7dGhpcy5vbGRSZWN0PWY7Y29uc3QgaD10aGlzLnRtcFBvaW50cy5tYXAoZD0+Wy4uLmQuWFksMF0pLmZsYXQoMSksdT15cihoKTtyZXR1cm4gdGhpcy52Tm9kZXMuc2V0SW5mbyhuLHtyZWN0OmYsb3A6aCxvcHQ6dGhpcy53b3JrT3B0aW9ucyx0b29sc1R5cGU6dGhpcy50b29sc1R5cGUsc2NhbGVUeXBlOnRoaXMuc2NhbGVUeXBlLGNhblJvdGF0ZTp0aGlzLmNhblJvdGF0ZSxjZW50ZXJQb3M6ZiYmRHQuZ2V0Q2VudGVyUG9zKGYsaSl9KSx7cmVjdDpmLHR5cGU6VHQuRnVsbFdvcmssZGF0YVR5cGU6enQuTG9jYWwsd29ya0lkOm4sb3BzOnUsaXNTeW5jOiEwfX1kcmF3KGUpe3ZhciBSO2NvbnN0e3dvcmtJZDp0LGxheWVyOm4saXNEcmF3aW5nOml9PWU7dGhpcy5mdWxsTGF5ZXIuZ2V0RWxlbWVudHNCeU5hbWUodCkubWFwKEw9PkwucmVtb3ZlKCkpLChSPXRoaXMuZHJhd0xheWVyKT09bnVsbHx8Ui5nZXRFbGVtZW50c0J5TmFtZSh0KS5tYXAoTD0+TC5yZW1vdmUoKSk7Y29uc3R7c3Ryb2tlQ29sb3I6ZixmaWxsQ29sb3I6aCx0aGlja25lc3M6dSx6SW5kZXg6YSx2ZXJ0aWNlczpkLGlubmVyVmVydGljZVN0ZXA6RSxpbm5lclJhdGlvOnAsc2NhbGU6Tyxyb3RhdGU6bSx0cmFuc2xhdGU6Yn09dGhpcy53b3JrT3B0aW9ucyxNPW4ud29ybGRQb3NpdGlvbix5PW4ud29ybGRTY2FsaW5nLHtyZWN0OlMscG9zOnMscG9pbnRzOmN9PXRoaXMuY29tcHV0RHJhd1BvaW50cyh1LGQsRSxwKSxsPXtwb3M6cyxjbG9zZTohMCxuYW1lOnQsaWQ6dCxwb2ludHM6YyxsaW5lV2lkdGg6dSxmaWxsQ29sb3I6aCE9PSJ0cmFuc3BhcmVudCImJmh8fHZvaWQgMCxzdHJva2VDb2xvcjpmLGNsYXNzTmFtZTpgJHtzWzBdfSwke3NbMV19YCxub3JtYWxpemU6ITAsekluZGV4OmEsbGluZUpvaW46InJvdW5kIn0sdj17eDpNYXRoLmZsb29yKFMueCp5WzBdK01bMF0tRHQuU2FmZUJvcmRlclBhZGRpbmcqeVswXSkseTpNYXRoLmZsb29yKFMueSp5WzFdK01bMV0tRHQuU2FmZUJvcmRlclBhZGRpbmcqeVsxXSksdzpNYXRoLmZsb29yKFMudyp5WzBdKzIqRHQuU2FmZUJvcmRlclBhZGRpbmcqeVswXSksaDpNYXRoLmZsb29yKFMuaCp5WzFdKzIqRHQuU2FmZUJvcmRlclBhZGRpbmcqeVsxXSl9O2lmKGkpe2NvbnN0e25hbWU6TCxpZDpOLHpJbmRleDpBLHN0cm9rZUNvbG9yOnd9PWwsQj1bKHYueCt2LncvMi1NWzBdKS95WzBdLCh2Lnkrdi5oLzItTVsxXSkveVsxXV0sRD1uZXcgSXIoe25hbWU6TCxpZDpOLHpJbmRleDpBLHBvczpCLGFuY2hvcjpbLjUsLjVdLHNpemU6W3Yudyx2LmhdfSksST1uZXcgY24oey4uLmwscG9zOlswLDBdfSksaj1uZXcgSHIoe2Q6Ik0tNCwwSDRNMCwtNFY0Iixub3JtYWxpemU6ITAscG9zOlswLDBdLHN0cm9rZUNvbG9yOncsbGluZVdpZHRoOjEsc2NhbGU6WzEveVswXSwxL3lbMV1dfSk7cmV0dXJuIEQuYXBwZW5kKEksaiksbi5hcHBlbmQoRCksdn1PJiYobC5zY2FsZT1PKSxtJiYobC5yb3RhdGU9bSksYiYmKGwudHJhbnNsYXRlPWIpO2NvbnN0IFQ9bmV3IGNuKGwpO2lmKG4uYXBwZW5kKFQpLE98fG18fGIpe2NvbnN0IEw9VC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtyZXR1cm57eDpNYXRoLmZsb29yKEwueC1EdC5TYWZlQm9yZGVyUGFkZGluZykseTpNYXRoLmZsb29yKEwueS1EdC5TYWZlQm9yZGVyUGFkZGluZyksdzpNYXRoLmZsb29yKEwud2lkdGgrRHQuU2FmZUJvcmRlclBhZGRpbmcqMiksaDpNYXRoLmZsb29yKEwuaGVpZ2h0K0R0LlNhZmVCb3JkZXJQYWRkaW5nKjIpfX1yZXR1cm4gdn1jb21wdXREcmF3UG9pbnRzKGUsdCxuLGkpe2NvbnN0IGY9eGUodGhpcy50bXBQb2ludHMpLGg9W01hdGguZmxvb3IoZi54K2Yudy8yKSxNYXRoLmZsb29yKGYueStmLmgvMildLHU9RGEoZi53LGYuaCksYT1NYXRoLmZsb29yKE1hdGgubWluKGYudyxmLmgpLzIpLGQ9aSphLEU9W10scD0yKk1hdGguUEkvdDtmb3IobGV0IG09MDttPHQ7bSsrKXtjb25zdCBiPW0qcC0uNSpNYXRoLlBJO2xldCBNLHk7bSVuPT09MT8oTT1kKnVbMF0qTWF0aC5jb3MoYikseT1kKnVbMV0qTWF0aC5zaW4oYikpOihNPWEqdVswXSpNYXRoLmNvcyhiKSx5PWEqdVsxXSpNYXRoLnNpbihiKSxFLnB1c2goTSx5KSksRS5wdXNoKE0seSl9cmV0dXJue3JlY3Q6eGUodGhpcy50bXBQb2ludHMsZSkscG9zOmgscG9pbnRzOkV9fXVwZGF0ZVRlbXBQb2ludHMoZSl7Y29uc3QgdD1lLnNsaWNlKC0yKSxuPW5ldyBGdCh0WzBdLHRbMV0pLGk9dGhpcy50bXBQb2ludHNbMF0se3RoaWNrbmVzczpmfT10aGlzLndvcmtPcHRpb25zO2lmKGkuaXNOZWFyKG4sZil8fEZ0LlN1YihpLG4pLlhZLmluY2x1ZGVzKDApKXJldHVybiExO2lmKHRoaXMudG1wUG9pbnRzLmxlbmd0aD09PTIpe2lmKG4uaXNOZWFyKHRoaXMudG1wUG9pbnRzWzFdLDEpKXJldHVybiExO3RoaXMudG1wUG9pbnRzWzFdPW59ZWxzZSB0aGlzLnRtcFBvaW50cy5wdXNoKG4pO3JldHVybiEwfWNvbnN1bWVTZXJ2aWNlKGUpe3ZhciB1O2NvbnN0e29wOnQsaXNGdWxsV29yazpufT1lLGk9KHU9dGhpcy53b3JrSWQpPT1udWxsP3ZvaWQgMDp1LnRvU3RyaW5nKCk7aWYoIWkpcmV0dXJuO3RoaXMudG1wUG9pbnRzLmxlbmd0aD0wO2ZvcihsZXQgYT0wO2E8dC5sZW5ndGg7YSs9Myl0aGlzLnRtcFBvaW50cy5wdXNoKG5ldyBGdCh0W2FdLHRbYSsxXSx0W2ErMl0pKTtjb25zdCBmPW4/dGhpcy5mdWxsTGF5ZXI6dGhpcy5kcmF3TGF5ZXJ8fHRoaXMuZnVsbExheWVyLGg9dGhpcy5kcmF3KHt3b3JrSWQ6aSxsYXllcjpmLGlzRHJhd2luZzohMX0pO3JldHVybiB0aGlzLm9sZFJlY3Q9aCx0aGlzLnZOb2Rlcy5zZXRJbmZvKGkse3JlY3Q6aCxvcDp0LG9wdDp0aGlzLndvcmtPcHRpb25zLHRvb2xzVHlwZTp0aGlzLnRvb2xzVHlwZSxzY2FsZVR5cGU6dGhpcy5zY2FsZVR5cGUsY2FuUm90YXRlOnRoaXMuY2FuUm90YXRlLGNlbnRlclBvczpoJiZEdC5nZXRDZW50ZXJQb3MoaCxmKX0pLGh9Y2xlYXJUbXBQb2ludHMoKXt0aGlzLnRtcFBvaW50cy5sZW5ndGg9MH1zdGF0aWMgdXBkYXRlTm9kZU9wdChlKXt2YXIgZCxFO2NvbnN0e25vZGU6dCxvcHQ6bix2Tm9kZXM6aX09ZSx7c3Ryb2tlQ29sb3I6ZixmaWxsQ29sb3I6aH09bix1PWkuZ2V0KHQubmFtZSk7bGV0IGE9dDtyZXR1cm4gdC50YWdOYW1lPT09IkdST1VQIiYmKGE9dC5jaGlsZHJlblswXSksZiYmKGEuc2V0QXR0cmlidXRlKCJzdHJva2VDb2xvciIsZiksKGQ9dT09bnVsbD92b2lkIDA6dS5vcHQpIT1udWxsJiZkLnN0cm9rZUNvbG9yJiYodS5vcHQuc3Ryb2tlQ29sb3I9ZikpLGgmJihoPT09InRyYW5zcGFyZW50Ij9hLnNldEF0dHJpYnV0ZSgiZmlsbENvbG9yIiwicmdiYSgwLDAsMCwwKSIpOmEuc2V0QXR0cmlidXRlKCJmaWxsQ29sb3IiLGgpLChFPXU9PW51bGw/dm9pZCAwOnUub3B0KSE9bnVsbCYmRS5maWxsQ29sb3ImJih1Lm9wdC5maWxsQ29sb3I9aCkpLHUmJmkuc2V0SW5mbyh0Lm5hbWUsdSksRHQudXBkYXRlTm9kZU9wdChlKX19Y2xhc3MgSGEgZXh0ZW5kcyBEdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihlKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiY2FuUm90YXRlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6ITF9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywic2NhbGVUeXBlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6JGUuYWxsfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInRvb2xzVHlwZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOkx0LlBvbHlnb259KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidG1wUG9pbnRzIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6W119KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywid29ya09wdGlvbnMiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywib2xkUmVjdCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzeW5jVGltZXN0YW1wIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksdGhpcy53b3JrT3B0aW9ucz1lLnRvb2xzT3B0LHRoaXMuc3luY1RpbWVzdGFtcD0wLHRoaXMuc3luY1VuaXRUaW1lPTUwfWNvbnN1bWUoZSl7dmFyIG07Y29uc3R7ZGF0YTp0LGlzRnVsbFdvcms6bixpc1N1YldvcmtlcjppfT1lLGY9KG09dD09bnVsbD92b2lkIDA6dC53b3JrSWQpPT1udWxsP3ZvaWQgMDptLnRvU3RyaW5nKCk7aWYoIWYpcmV0dXJue3R5cGU6VHQuTm9uZX07Y29uc3R7b3A6aCx3b3JrU3RhdGU6dX09dCxhPWg9PW51bGw/dm9pZCAwOmgubGVuZ3RoO2lmKCFhfHxhPDIpcmV0dXJue3R5cGU6VHQuTm9uZX07bGV0IGQ7aWYodT09PWNlLlN0YXJ0Pyh0aGlzLnRtcFBvaW50cz1bbmV3IEZ0KGhbMF0saFsxXSldLGQ9ITEpOmQ9dGhpcy51cGRhdGVUZW1wUG9pbnRzKGgpLCFkKXJldHVybnt0eXBlOlR0Lk5vbmV9O2lmKCFpKXtjb25zdCBiPURhdGUubm93KCk7cmV0dXJuIGItdGhpcy5zeW5jVGltZXN0YW1wPnRoaXMuc3luY1VuaXRUaW1lPyh0aGlzLnN5bmNUaW1lc3RhbXA9Yix7dHlwZTpUdC5EcmF3V29yayxkYXRhVHlwZTp6dC5Mb2NhbCx3b3JrSWQ6ZixvcDp0aGlzLnRtcFBvaW50cy5tYXAoTT0+Wy4uLk0uWFksMF0pLmZsYXQoMSksaXNTeW5jOiEwLGluZGV4OjB9KTp7dHlwZTpUdC5Ob25lfX1jb25zdCBFPW4/dGhpcy5mdWxsTGF5ZXI6dGhpcy5kcmF3TGF5ZXJ8fHRoaXMuZnVsbExheWVyLHA9dGhpcy5kcmF3KHt3b3JrSWQ6ZixsYXllcjpFLGlzRHJhd2luZzohMH0pLE89JHQocCx0aGlzLm9sZFJlY3QpO3JldHVybiB0aGlzLm9sZFJlY3Q9cCx7cmVjdDpPLHR5cGU6VHQuRHJhd1dvcmssZGF0YVR5cGU6enQuTG9jYWwsd29ya0lkOmZ9fWNvbnN1bWVBbGwoZSl7dmFyIGE7Y29uc3R7ZGF0YTp0fT1lLG49KGE9dD09bnVsbD92b2lkIDA6dC53b3JrSWQpPT1udWxsP3ZvaWQgMDphLnRvU3RyaW5nKCk7aWYoIW4pcmV0dXJue3R5cGU6VHQuTm9uZX07aWYodGhpcy50bXBQb2ludHMubGVuZ3RoPDIpcmV0dXJue3R5cGU6VHQuUmVtb3ZlTm9kZSxyZW1vdmVJZHM6W25dfTtjb25zdCBpPXRoaXMuZnVsbExheWVyLGY9dGhpcy5kcmF3KHt3b3JrSWQ6bixsYXllcjppLGlzRHJhd2luZzohMX0pO3RoaXMub2xkUmVjdD1mO2NvbnN0IGg9dGhpcy50bXBQb2ludHMubWFwKGQ9PlsuLi5kLlhZLDBdKS5mbGF0KDEpLHU9eXIoaCk7cmV0dXJuIHRoaXMudk5vZGVzLnNldEluZm8obix7cmVjdDpmLG9wOmgsb3B0OnRoaXMud29ya09wdGlvbnMsdG9vbHNUeXBlOnRoaXMudG9vbHNUeXBlLHNjYWxlVHlwZTp0aGlzLnNjYWxlVHlwZSxjYW5Sb3RhdGU6dGhpcy5jYW5Sb3RhdGUsY2VudGVyUG9zOmYmJkR0LmdldENlbnRlclBvcyhmLGkpfSkse3JlY3Q6Zix0eXBlOlR0LkZ1bGxXb3JrLGRhdGFUeXBlOnp0LkxvY2FsLHdvcmtJZDpuLG9wczp1LGlzU3luYzohMH19ZHJhdyhlKXt2YXIgdjtjb25zdHt3b3JrSWQ6dCxsYXllcjpuLGlzRHJhd2luZzppfT1lO3RoaXMuZnVsbExheWVyLmdldEVsZW1lbnRzQnlOYW1lKHQpLm1hcChUPT5ULnJlbW92ZSgpKSwodj10aGlzLmRyYXdMYXllcik9PW51bGx8fHYuZ2V0RWxlbWVudHNCeU5hbWUodCkubWFwKFQ9PlQucmVtb3ZlKCkpO2NvbnN0e3N0cm9rZUNvbG9yOmYsZmlsbENvbG9yOmgsdGhpY2tuZXNzOnUsekluZGV4OmEsdmVydGljZXM6ZCxzY2FsZTpFLHJvdGF0ZTpwLHRyYW5zbGF0ZTpPfT10aGlzLndvcmtPcHRpb25zLG09bi53b3JsZFBvc2l0aW9uLGI9bi53b3JsZFNjYWxpbmcse3JlY3Q6TSxwb3M6eSxwb2ludHM6U309dGhpcy5jb21wdXREcmF3UG9pbnRzKHUsZCkscz17cG9zOnksY2xvc2U6ITAsbmFtZTp0LGlkOnQscG9pbnRzOlMsbGluZVdpZHRoOnUsZmlsbENvbG9yOmghPT0idHJhbnNwYXJlbnQiJiZofHx2b2lkIDAsc3Ryb2tlQ29sb3I6Zixub3JtYWxpemU6ITAsekluZGV4OmEsbGluZUpvaW46InJvdW5kIn0sYz17eDpNYXRoLmZsb29yKE0ueCpiWzBdK21bMF0tRHQuU2FmZUJvcmRlclBhZGRpbmcqYlswXSkseTpNYXRoLmZsb29yKE0ueSpiWzFdK21bMV0tRHQuU2FmZUJvcmRlclBhZGRpbmcqYlsxXSksdzpNYXRoLmZsb29yKE0udypiWzBdKzIqRHQuU2FmZUJvcmRlclBhZGRpbmcqYlswXSksaDpNYXRoLmZsb29yKE0uaCpiWzFdKzIqRHQuU2FmZUJvcmRlclBhZGRpbmcqYlsxXSl9O2lmKGkpe2NvbnN0e25hbWU6VCxpZDpSLHpJbmRleDpMLHN0cm9rZUNvbG9yOk59PXMsQT1bKGMueCtjLncvMi1tWzBdKS9iWzBdLChjLnkrYy5oLzItbVsxXSkvYlsxXV0sdz1uZXcgSXIoe25hbWU6VCxpZDpSLHpJbmRleDpMLHBvczpBLGFuY2hvcjpbLjUsLjVdLHNpemU6W2MudyxjLmhdfSksQj1uZXcgY24oey4uLnMscG9zOlswLDBdfSksRD1uZXcgSHIoe2Q6Ik0tNCwwSDRNMCwtNFY0Iixub3JtYWxpemU6ITAscG9zOlswLDBdLHN0cm9rZUNvbG9yOk4sbGluZVdpZHRoOjEsc2NhbGU6WzEvYlswXSwxL2JbMV1dfSk7cmV0dXJuIHcuYXBwZW5kKEIsRCksbi5hcHBlbmQodyksY31FJiYocy5zY2FsZT1FKSxwJiYocy5yb3RhdGU9cCksTyYmKHMudHJhbnNsYXRlPU8pO2NvbnN0IGw9bmV3IGNuKHMpO2lmKG4uYXBwZW5kKGwpLEV8fHB8fE8pe2NvbnN0IFQ9bC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtyZXR1cm57eDpNYXRoLmZsb29yKFQueC1EdC5TYWZlQm9yZGVyUGFkZGluZykseTpNYXRoLmZsb29yKFQueS1EdC5TYWZlQm9yZGVyUGFkZGluZyksdzpNYXRoLmZsb29yKFQud2lkdGgrRHQuU2FmZUJvcmRlclBhZGRpbmcqMiksaDpNYXRoLmZsb29yKFQuaGVpZ2h0K0R0LlNhZmVCb3JkZXJQYWRkaW5nKjIpfX1yZXR1cm4gY31jb21wdXREcmF3UG9pbnRzKGUsdCl7Y29uc3Qgbj14ZSh0aGlzLnRtcFBvaW50cyksaT1bTWF0aC5mbG9vcihuLngrbi53LzIpLE1hdGguZmxvb3Iobi55K24uaC8yKV0sZj1EYShuLncsbi5oKSxoPU1hdGguZmxvb3IoTWF0aC5taW4obi53LG4uaCkvMiksdT1bXSxhPTIqTWF0aC5QSS90O2ZvcihsZXQgRT0wO0U8dDtFKyspe2NvbnN0IHA9RSphLS41Kk1hdGguUEksTz1oKmZbMF0qTWF0aC5jb3MocCksbT1oKmZbMV0qTWF0aC5zaW4ocCk7dS5wdXNoKE8sbSl9cmV0dXJue3JlY3Q6eGUodGhpcy50bXBQb2ludHMsZSkscG9zOmkscG9pbnRzOnV9fXVwZGF0ZVRlbXBQb2ludHMoZSl7Y29uc3QgdD1lLnNsaWNlKC0yKSxuPW5ldyBGdCh0WzBdLHRbMV0pLGk9dGhpcy50bXBQb2ludHNbMF0se3RoaWNrbmVzczpmfT10aGlzLndvcmtPcHRpb25zO2lmKGkuaXNOZWFyKG4sZil8fEZ0LlN1YihpLG4pLlhZLmluY2x1ZGVzKDApKXJldHVybiExO2lmKHRoaXMudG1wUG9pbnRzLmxlbmd0aD09PTIpe2lmKG4uaXNOZWFyKHRoaXMudG1wUG9pbnRzWzFdLDEpKXJldHVybiExO3RoaXMudG1wUG9pbnRzWzFdPW59ZWxzZSB0aGlzLnRtcFBvaW50cy5wdXNoKG4pO3JldHVybiEwfWNvbnN1bWVTZXJ2aWNlKGUpe3ZhciB1O2NvbnN0e29wOnQsaXNGdWxsV29yazpufT1lLGk9KHU9dGhpcy53b3JrSWQpPT1udWxsP3ZvaWQgMDp1LnRvU3RyaW5nKCk7aWYoIWkpcmV0dXJuO3RoaXMudG1wUG9pbnRzLmxlbmd0aD0wO2ZvcihsZXQgYT0wO2E8dC5sZW5ndGg7YSs9Myl0aGlzLnRtcFBvaW50cy5wdXNoKG5ldyBGdCh0W2FdLHRbYSsxXSx0W2ErMl0pKTtjb25zdCBmPW4/dGhpcy5mdWxsTGF5ZXI6dGhpcy5kcmF3TGF5ZXJ8fHRoaXMuZnVsbExheWVyLGg9dGhpcy5kcmF3KHt3b3JrSWQ6aSxsYXllcjpmLGlzRHJhd2luZzohMX0pO3JldHVybiB0aGlzLm9sZFJlY3Q9aCx0aGlzLnZOb2Rlcy5zZXRJbmZvKGkse3JlY3Q6aCxvcDp0LG9wdDp0aGlzLndvcmtPcHRpb25zLHRvb2xzVHlwZTp0aGlzLnRvb2xzVHlwZSxzY2FsZVR5cGU6dGhpcy5zY2FsZVR5cGUsY2FuUm90YXRlOnRoaXMuY2FuUm90YXRlLGNlbnRlclBvczpoJiZEdC5nZXRDZW50ZXJQb3MoaCxmKX0pLGh9Y2xlYXJUbXBQb2ludHMoKXt0aGlzLnRtcFBvaW50cy5sZW5ndGg9MH1zdGF0aWMgdXBkYXRlTm9kZU9wdChlKXt2YXIgZCxFO2NvbnN0e25vZGU6dCxvcHQ6bix2Tm9kZXM6aX09ZSx7c3Ryb2tlQ29sb3I6ZixmaWxsQ29sb3I6aH09bix1PWkuZ2V0KHQubmFtZSk7bGV0IGE9dDtyZXR1cm4gdC50YWdOYW1lPT09IkdST1VQIiYmKGE9dC5jaGlsZHJlblswXSksZiYmKGEuc2V0QXR0cmlidXRlKCJzdHJva2VDb2xvciIsZiksKGQ9dT09bnVsbD92b2lkIDA6dS5vcHQpIT1udWxsJiZkLnN0cm9rZUNvbG9yJiYodS5vcHQuc3Ryb2tlQ29sb3I9ZikpLGgmJihoPT09InRyYW5zcGFyZW50Ij9hLnNldEF0dHJpYnV0ZSgiZmlsbENvbG9yIiwicmdiYSgwLDAsMCwwKSIpOmEuc2V0QXR0cmlidXRlKCJmaWxsQ29sb3IiLGgpLChFPXU9PW51bGw/dm9pZCAwOnUub3B0KSE9bnVsbCYmRS5maWxsQ29sb3ImJih1Lm9wdC5maWxsQ29sb3I9aCkpLHUmJmkuc2V0SW5mbyh0Lm5hbWUsdSksRHQudXBkYXRlTm9kZU9wdChlKX19Y2xhc3MgWWEgZXh0ZW5kcyBEdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihlKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiY2FuUm90YXRlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6ITF9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywic2NhbGVUeXBlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6JGUuYWxsfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInRvb2xzVHlwZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOkx0LlN0cmFpZ2h0fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInRtcFBvaW50cyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOltdfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIndvcmtPcHRpb25zIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIm9sZFJlY3QiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywic3RyYWlnaHRUaXBXaWR0aCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzeW5jVGltZXN0YW1wIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksdGhpcy53b3JrT3B0aW9ucz1lLnRvb2xzT3B0LHRoaXMuc3RyYWlnaHRUaXBXaWR0aD10aGlzLndvcmtPcHRpb25zLnRoaWNrbmVzcy8yLHRoaXMuc3luY1RpbWVzdGFtcD0wLHRoaXMuc3luY1VuaXRUaW1lPTUwfWNvbnN1bWUoZSl7dmFyIG07Y29uc3R7ZGF0YTp0LGlzRnVsbFdvcms6bixpc1N1YldvcmtlcjppfT1lLGY9KG09dD09bnVsbD92b2lkIDA6dC53b3JrSWQpPT1udWxsP3ZvaWQgMDptLnRvU3RyaW5nKCk7aWYoIWYpcmV0dXJue3R5cGU6VHQuTm9uZX07Y29uc3R7b3A6aCx3b3JrU3RhdGU6dX09dCxhPWg9PW51bGw/dm9pZCAwOmgubGVuZ3RoO2lmKCFhfHxhPDIpcmV0dXJue3R5cGU6VHQuTm9uZX07bGV0IGQ7aWYodT09PWNlLlN0YXJ0Pyh0aGlzLnRtcFBvaW50cz1bbmV3IEZ0KGhbMF0saFsxXSldLGQ9ITEpOmQ9dGhpcy51cGRhdGVUZW1wUG9pbnRzKGgpLCFkKXJldHVybnt0eXBlOlR0Lk5vbmV9O2lmKCFpKXtjb25zdCBiPURhdGUubm93KCk7cmV0dXJuIGItdGhpcy5zeW5jVGltZXN0YW1wPnRoaXMuc3luY1VuaXRUaW1lPyh0aGlzLnN5bmNUaW1lc3RhbXA9Yix7dHlwZTpUdC5EcmF3V29yayxkYXRhVHlwZTp6dC5Mb2NhbCx3b3JrSWQ6ZixvcDp0aGlzLnRtcFBvaW50cy5tYXAoTT0+Wy4uLk0uWFksMF0pLmZsYXQoMSksaXNTeW5jOiEwLGluZGV4OjB9KTp7dHlwZTpUdC5Ob25lfX1jb25zdCBFPW4/dGhpcy5mdWxsTGF5ZXI6dGhpcy5kcmF3TGF5ZXJ8fHRoaXMuZnVsbExheWVyLHA9dGhpcy5kcmF3KHt3b3JrSWQ6ZixsYXllcjpFfSksTz0kdChwLHRoaXMub2xkUmVjdCk7cmV0dXJuIHRoaXMub2xkUmVjdD1wLHtyZWN0Ok8sdHlwZTpUdC5EcmF3V29yayxkYXRhVHlwZTp6dC5Mb2NhbCx3b3JrSWQ6Zn19Y29uc3VtZUFsbChlKXt2YXIgYTtjb25zdHtkYXRhOnR9PWUsbj0oYT10PT1udWxsP3ZvaWQgMDp0LndvcmtJZCk9PW51bGw/dm9pZCAwOmEudG9TdHJpbmcoKTtpZighbilyZXR1cm57dHlwZTpUdC5Ob25lfTtpZih0aGlzLnRtcFBvaW50cy5sZW5ndGg8MilyZXR1cm57dHlwZTpUdC5SZW1vdmVOb2RlLHJlbW92ZUlkczpbbl19O2NvbnN0IGk9dGhpcy5mdWxsTGF5ZXIsZj10aGlzLmRyYXcoe3dvcmtJZDpuLGxheWVyOml9KTt0aGlzLm9sZFJlY3Q9Zjtjb25zdCBoPXRoaXMudG1wUG9pbnRzLm1hcChkPT5bLi4uZC5YWSwwXSkuZmxhdCgxKSx1PXlyKGgpO3JldHVybiBlLnZOb2Rlcy5zZXRJbmZvKG4se3JlY3Q6ZixvcDpoLG9wdDp0aGlzLndvcmtPcHRpb25zLHRvb2xzVHlwZTp0aGlzLnRvb2xzVHlwZSxzY2FsZVR5cGU6dGhpcy5zY2FsZVR5cGUsY2FuUm90YXRlOnRoaXMuY2FuUm90YXRlLGNlbnRlclBvczpmJiZEdC5nZXRDZW50ZXJQb3MoZixpKX0pLHtyZWN0OmYsdHlwZTpUdC5GdWxsV29yayxkYXRhVHlwZTp6dC5Mb2NhbCx3b3JrSWQ6bixvcHM6dSxpc1N5bmM6ITB9fWRyYXcoZSl7dmFyIHM7Y29uc3R7d29ya0lkOnQsbGF5ZXI6bn09ZTt0aGlzLmZ1bGxMYXllci5nZXRFbGVtZW50c0J5TmFtZSh0KS5tYXAoYz0+Yy5yZW1vdmUoKSksKHM9dGhpcy5kcmF3TGF5ZXIpPT1udWxsfHxzLmdldEVsZW1lbnRzQnlOYW1lKHQpLm1hcChjPT5jLnJlbW92ZSgpKTtjb25zdHtzdHJva2VDb2xvcjppLHRoaWNrbmVzczpmLHpJbmRleDpoLHNjYWxlOnUscm90YXRlOmEsdHJhbnNsYXRlOmR9PXRoaXMud29ya09wdGlvbnMsRT1uLndvcmxkUG9zaXRpb24scD1uLndvcmxkU2NhbGluZyx7ZDpPLHJlY3Q6bX09dGhpcy5jb21wdXREcmF3UG9pbnRzKGYpLGI9W20ueCttLncvMixtLnkrbS5oLzJdLE09e3BvczpiLG5hbWU6dCxpZDp0LGQ6TyxmaWxsQ29sb3I6aSxzdHJva2VDb2xvcjppLGxpbmVXaWR0aDowLGNsYXNzTmFtZTpgJHtiWzBdfSwke2JbMV19YCxub3JtYWxpemU6ITAsekluZGV4Omh9O3UmJihNLnNjYWxlPXUpLGEmJihNLnJvdGF0ZT1hKSxkJiYoTS50cmFuc2xhdGU9ZCk7Y29uc3QgeT1uZXcgSHIoTSk7aWYobi5hcHBlbmQoeSksYXx8dXx8ZCl7Y29uc3QgYz15LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO3JldHVybnt4Ok1hdGguZmxvb3IoYy54LUR0LlNhZmVCb3JkZXJQYWRkaW5nKSx5Ok1hdGguZmxvb3IoYy55LUR0LlNhZmVCb3JkZXJQYWRkaW5nKSx3Ok1hdGguZmxvb3IoYy53aWR0aCtEdC5TYWZlQm9yZGVyUGFkZGluZyoyKSxoOk1hdGguZmxvb3IoYy5oZWlnaHQrRHQuU2FmZUJvcmRlclBhZGRpbmcqMil9fXJldHVybnt4Ok1hdGguZmxvb3IobS54KnBbMF0rRVswXS1EdC5TYWZlQm9yZGVyUGFkZGluZykseTpNYXRoLmZsb29yKG0ueSpwWzFdK0VbMV0tRHQuU2FmZUJvcmRlclBhZGRpbmcpLHc6TWF0aC5mbG9vcihtLncqcFswXSsyKkR0LlNhZmVCb3JkZXJQYWRkaW5nKSxoOk1hdGguZmxvb3IobS5oKnBbMV0rMipEdC5TYWZlQm9yZGVyUGFkZGluZyl9fWNvbXB1dERyYXdQb2ludHMoZSl7cmV0dXJuIHRoaXMudG1wUG9pbnRzWzFdLmRpc3RhbmNlKHRoaXMudG1wUG9pbnRzWzBdKT50aGlzLnN0cmFpZ2h0VGlwV2lkdGg/dGhpcy5jb21wdXRGdWxsUG9pbnRzKGUpOnRoaXMuY29tcHV0RG90UG9pbnRzKGUpfWNvbXB1dEZ1bGxQb2ludHMoZSl7Y29uc3QgdD1FdC5TdWIodGhpcy50bXBQb2ludHNbMV0sdGhpcy50bXBQb2ludHNbMF0pLnVuaSgpLG49RXQuUGVyKHQpLm11bChlLzIpLGk9RnQuU3ViKHRoaXMudG1wUG9pbnRzWzBdLG4pLGY9RnQuQWRkKHRoaXMudG1wUG9pbnRzWzBdLG4pLGg9RnQuU3ViKHRoaXMudG1wUG9pbnRzWzFdLG4pLHU9RnQuQWRkKHRoaXMudG1wUG9pbnRzWzFdLG4pLGE9RnQuR2V0U2VtaWNpcmNsZVN0cm9rZSh0aGlzLnRtcFBvaW50c1sxXSxoLC0xLDgpLGQ9RnQuR2V0U2VtaWNpcmNsZVN0cm9rZSh0aGlzLnRtcFBvaW50c1swXSxmLC0xLDgpLEU9W2ksaCwuLi5hLHUsZiwuLi5kXTtyZXR1cm57ZDpobihFLCEwKSxyZWN0OnhlKEUpLGlzRG90OiExLHBvczp0aGlzLnRtcFBvaW50c1swXS5YWX19Y29tcHV0RG90UG9pbnRzKGUpe2NvbnN0IHQ9RnQuR2V0RG90U3Ryb2tlKHRoaXMudG1wUG9pbnRzWzBdLGUvMiw4KTtyZXR1cm57ZDpobih0LCEwKSxyZWN0OnhlKHQpLGlzRG90OiEwLHBvczp0aGlzLnRtcFBvaW50c1swXS5YWX19dXBkYXRlVGVtcFBvaW50cyhlKXtjb25zdCB0PWUuc2xpY2UoLTIpLG49bmV3IEZ0KHRbMF0sdFsxXSksaT10aGlzLnRtcFBvaW50c1swXSx7dGhpY2tuZXNzOmZ9PXRoaXMud29ya09wdGlvbnM7aWYoaS5pc05lYXIobixmKSlyZXR1cm4hMTtpZih0aGlzLnRtcFBvaW50cy5sZW5ndGg9PT0yKXtpZihuLmlzTmVhcih0aGlzLnRtcFBvaW50c1sxXSwxKSlyZXR1cm4hMTt0aGlzLnRtcFBvaW50c1sxXT1ufWVsc2UgdGhpcy50bXBQb2ludHMucHVzaChuKTtyZXR1cm4hMH1jb25zdW1lU2VydmljZShlKXt2YXIgdTtjb25zdHtvcDp0LGlzRnVsbFdvcms6bn09ZSxpPSh1PXRoaXMud29ya0lkKT09bnVsbD92b2lkIDA6dS50b1N0cmluZygpO2lmKCFpKXJldHVybjt0aGlzLnRtcFBvaW50cy5sZW5ndGg9MDtmb3IobGV0IGE9MDthPHQubGVuZ3RoO2ErPTMpdGhpcy50bXBQb2ludHMucHVzaChuZXcgRnQodFthXSx0W2ErMV0sdFthKzJdKSk7Y29uc3QgZj1uP3RoaXMuZnVsbExheWVyOnRoaXMuZHJhd0xheWVyfHx0aGlzLmZ1bGxMYXllcixoPXRoaXMuZHJhdyh7d29ya0lkOmksbGF5ZXI6Zn0pO3JldHVybiB0aGlzLm9sZFJlY3Q9aCx0aGlzLnZOb2Rlcy5zZXRJbmZvKGkse3JlY3Q6aCxvcDp0LG9wdDp0aGlzLndvcmtPcHRpb25zLHRvb2xzVHlwZTp0aGlzLnRvb2xzVHlwZSxzY2FsZVR5cGU6dGhpcy5zY2FsZVR5cGUsY2FuUm90YXRlOnRoaXMuY2FuUm90YXRlLGNlbnRlclBvczpoJiZEdC5nZXRDZW50ZXJQb3MoaCxmKX0pLGh9Y2xlYXJUbXBQb2ludHMoKXt0aGlzLnRtcFBvaW50cy5sZW5ndGg9MH1zdGF0aWMgdXBkYXRlTm9kZU9wdChlKXt2YXIgdTtjb25zdHtub2RlOnQsb3B0Om4sdk5vZGVzOml9PWUse3N0cm9rZUNvbG9yOmZ9PW4saD1pLmdldCh0Lm5hbWUpO3JldHVybiBmJiYodC5zZXRBdHRyaWJ1dGUoInN0cm9rZUNvbG9yIixmKSx0LnNldEF0dHJpYnV0ZSgiZmlsbENvbG9yIixmKSwodT1oPT1udWxsP3ZvaWQgMDpoLm9wdCkhPW51bGwmJnUuc3Ryb2tlQ29sb3ImJihoLm9wdC5zdHJva2VDb2xvcj1mKSksaCYmaS5zZXRJbmZvKHQubmFtZSxoKSxEdC51cGRhdGVOb2RlT3B0KGUpfX1jbGFzcyBWYSBleHRlbmRzIER0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJjYW5Sb3RhdGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTohMX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzY2FsZVR5cGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTokZS5hbGx9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidG9vbHNUeXBlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6THQuVGV4dH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ0bXBQb2ludHMiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpbXX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ3b3JrT3B0aW9ucyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJvbGRSZWN0Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksdGhpcy53b3JrT3B0aW9ucz1lLnRvb2xzT3B0fWNvbnN1bWUoKXtyZXR1cm57dHlwZTpUdC5Ob25lfX1jb25zdW1lQWxsKCl7cmV0dXJue3R5cGU6VHQuTm9uZX19ZHJhdyhlKXt2YXIgTztjb25zdHt3b3JrSWQ6dCxsYXllcjpufT1lO3RoaXMuZnVsbExheWVyLmdldEVsZW1lbnRzQnlOYW1lKHQpLm1hcChtPT5tLnJlbW92ZSgpKSwoTz10aGlzLmRyYXdMYXllcik9PW51bGx8fE8uZ2V0RWxlbWVudHNCeU5hbWUodCkubWFwKG09Pm0ucmVtb3ZlKCkpO2NvbnN0e2JveFNpemU6aSxib3hQb2ludDpmLHN0cm9rZUNvbG9yOmh9PXRoaXMud29ya09wdGlvbnMsdT1uLndvcmxkUG9zaXRpb24sYT1uLndvcmxkU2NhbGluZztpZighZnx8IWkpcmV0dXJuO2NvbnN0IGQ9bmV3IElyKHtuYW1lOnQsaWQ6dCxwb3M6W2ZbMF0raVswXS8yLGZbMV0raVsxXS8yXSxhbmNob3I6Wy41LC41XSxzaXplOmksYmdjb2xvcjpoLG9wYWNpdHk6LjF9KSxFPXt4OmZbMF0seTpmWzFdLHc6aVswXSxoOmlbMV19LHA9bmV3IGdzKHtub3JtYWxpemU6ITAscG9zOlswLDBdLHNpemU6aSxsaW5lV2lkdGg6MH0pO3JldHVybiBkLmFwcGVuZENoaWxkKHApLG4uYXBwZW5kKGQpLHt4Ok1hdGguZmxvb3IoRS54KmFbMF0rdVswXSkseTpNYXRoLmZsb29yKEUueSphWzFdK3VbMV0pLHc6TWF0aC5mbG9vcihFLncqYVswXSksaDpNYXRoLmZsb29yKEUuaCphWzFdKX19Y29uc3VtZVNlcnZpY2UoZSl7dmFyIHUsYTtjb25zdCB0PSh1PXRoaXMud29ya0lkKT09bnVsbD92b2lkIDA6dS50b1N0cmluZygpO2lmKCF0KXJldHVybjtjb25zdHtpc0Z1bGxXb3JrOm4scmVwbGFjZUlkOml9PWU7dGhpcy5vbGRSZWN0PWkmJigoYT10aGlzLnZOb2Rlcy5nZXQoaSkpPT1udWxsP3ZvaWQgMDphLnJlY3QpfHx2b2lkIDA7Y29uc3QgZj1uP3RoaXMuZnVsbExheWVyOnRoaXMuZHJhd0xheWVyfHx0aGlzLmZ1bGxMYXllcixoPXRoaXMuZHJhdyh7d29ya0lkOnQsbGF5ZXI6Zn0pO3JldHVybiB0aGlzLnZOb2Rlcy5zZXRJbmZvKHQse3JlY3Q6aCxvcDpbXSxvcHQ6dGhpcy53b3JrT3B0aW9ucyx0b29sc1R5cGU6dGhpcy50b29sc1R5cGUsc2NhbGVUeXBlOnRoaXMuc2NhbGVUeXBlLGNhblJvdGF0ZTp0aGlzLmNhblJvdGF0ZSxjZW50ZXJQb3M6aCYmRHQuZ2V0Q2VudGVyUG9zKGgsZil9KSxofXVwZGF0YU9wdFNlcnZpY2UoZSl7aWYoIXRoaXMud29ya0lkKXJldHVybjtjb25zdCB0PXRoaXMud29ya0lkLnRvU3RyaW5nKCkse2ZvbnRDb2xvcjpuLGZvbnRCZ0NvbG9yOml9PWUsZj10aGlzLnZOb2Rlcy5nZXQodCk7aWYoIWYpcmV0dXJuO24mJihmLm9wdC5mb250Q29sb3I9biksaSYmKGYub3B0LmZvbnRCZ0NvbG9yPWkpLHRoaXMub2xkUmVjdD1mLnJlY3Q7Y29uc3QgaD10aGlzLmRyYXcoe3dvcmtJZDp0LGxheWVyOnRoaXMuZnVsbExheWVyfSk7cmV0dXJuIHRoaXMudk5vZGVzLnNldEluZm8odCx7cmVjdDpoLG9wOltdLG9wdDp0aGlzLndvcmtPcHRpb25zLHRvb2xzVHlwZTp0aGlzLnRvb2xzVHlwZSxzY2FsZVR5cGU6dGhpcy5zY2FsZVR5cGUsY2FuUm90YXRlOnRoaXMuY2FuUm90YXRlLGNlbnRlclBvczpoJiZEdC5nZXRDZW50ZXJQb3MoaCx0aGlzLmZ1bGxMYXllcil9KSxofWNsZWFyVG1wUG9pbnRzKCl7dGhpcy50bXBQb2ludHMubGVuZ3RoPTB9c3RhdGljIGNyZWF0ZUxhYmVscyhlLHQpe2NvbnN0IG49W10saT1lLnRleHQubGVuZ3RoO2ZvcihsZXQgZj0wO2Y8aTtmKyspe2NvbnN0IGg9ZS50ZXh0W2ZdLHU9e2FuY2hvcjpbLjUsLjVdLHRleHQ6aCxmb250U2l6ZTplLmZvbnRTaXplLGxpbmVIZWlnaHQ6ZS5mb250U2l6ZSxmb250RmFtaWx5OmUuZm9udEZhbWlseSxmb250U3R5bGU6ZS5mb250U3R5bGUsZmlsbENvbG9yOmUuZm9udENvbG9yLGJnY29sb3I6ZS5mb250QmdDb2xvcix0ZXh0QWxpZ246ZS50ZXh0QWxpZ24sZm9udFdlaWdodDplLmZvbnRXZWlnaHR9LGE9WzAsMF07aWYoZS52ZXJ0aWNhbEFsaWduPT09Im1pZGRsZSIpe2NvbnN0IEU9KGktMSkvMjthWzFdPShmLUUpKnUubGluZUhlaWdodH1lLnRleHRBbGlnbj09PSJsZWZ0IiYmKGFbMF09LXQudy8yLHUuYW5jaG9yPVswLC41XSksdS5wb3M9YTtjb25zdCBkPW5ldyB5bSh1KTtuLnB1c2goZCl9cmV0dXJuIG59c3RhdGljIHVwZGF0ZU5vZGVPcHQoZSl7Y29uc3R7bm9kZTp0LG9wdDpuLHZOb2RlczppLHRhcmdldE5vZGU6Zn09ZSx7Zm9udEJnQ29sb3I6aCxmb250Q29sb3I6dSx0cmFuc2xhdGU6YSxib3g6ZCxib3hTY2FsZTpFLGJveFRyYW5zbGF0ZTpwLHdvcmtTdGF0ZTpPfT1uLG09ZiYmZHIoZil8fGkuZ2V0KHQubmFtZSk7aWYoIW0pcmV0dXJuO2NvbnN0IGI9dC5wYXJlbnQ7aWYoIWIpcmV0dXJuO2NvbnN0IE09bS5vcHQ7aWYoTS53b3JrU3RhdGU9Tyx1JiZNLmZvbnRDb2xvciYmKE0uZm9udENvbG9yPXUpLGgmJk0uZm9udEJnQ29sb3ImJihNLmZvbnRCZ0NvbG9yPWgpLGQmJnAmJkUpe2NvbnN0e2JveFNpemU6eSxmb250U2l6ZTpTfT1NLHM9bS5yZWN0LGM9TGEodW0ocyxFKSxwKTtNLmJveFBvaW50PWMmJlsoYy54LWIud29ybGRQb3NpdGlvblswXSkvYi53b3JsZFNjYWxpbmdbMF0sKGMueS1iLndvcmxkUG9zaXRpb25bMV0pL2Iud29ybGRTY2FsaW5nWzFdXSxNLmJveFNpemU9eSYmW3lbMF0qRVswXSx5WzFdKkVbMV1dLE0uZm9udFNpemU9UyYmUypFWzBdfWVsc2UgYSYmTS5ib3hQb2ludCYmKE0uYm94UG9pbnQ9W00uYm94UG9pbnRbMF0rYVswXSxNLmJveFBvaW50WzFdK2FbMV1dLG0uY2VudGVyUG9zPVttLmNlbnRlclBvc1swXSthWzBdLG0uY2VudGVyUG9zWzFdK2FbMV1dLG0ucmVjdD17eDptLnJlY3QueCthWzBdLHk6bS5yZWN0LnkrYVsxXSx3Om0ucmVjdC53LGg6bS5yZWN0Lmh9KTtyZXR1cm4gbSYmaS5zZXRJbmZvKHQubmFtZSxtKSxtPT1udWxsP3ZvaWQgMDptLnJlY3R9c3RhdGljIGdldFJlY3RGcm9tTGF5ZXIoZSx0KXtjb25zdCBuPWUuZ2V0RWxlbWVudHNCeU5hbWUodClbMF07aWYobil7Y29uc3QgaT1uLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO3JldHVybnt4Ok1hdGguZmxvb3IoaS54KSx5Ok1hdGguZmxvb3IoaS55KSx3Ok1hdGguZmxvb3IoaS53aWR0aCksaDpNYXRoLmZsb29yKGkuaGVpZ2h0KX19fX1mdW5jdGlvbiBYYShnKXtzd2l0Y2goZyl7Y2FzZSBMdC5BcnJvdzpyZXR1cm4gemE7Y2FzZSBMdC5QZW5jaWw6cmV0dXJuIGphO2Nhc2UgTHQuU3RyYWlnaHQ6cmV0dXJuIFlhO2Nhc2UgTHQuRWxsaXBzZTpyZXR1cm4gJGE7Y2FzZSBMdC5Qb2x5Z29uOmNhc2UgTHQuVHJpYW5nbGU6cmV0dXJuIEhhO2Nhc2UgTHQuU3RhcjpjYXNlIEx0LlJob21idXM6cmV0dXJuIEthO2Nhc2UgTHQuUmVjdGFuZ2xlOnJldHVybiBHYTtjYXNlIEx0LlRleHQ6cmV0dXJuIFZhO2Nhc2UgTHQuTGFzZXJQZW46cmV0dXJuIFVhO2Nhc2UgTHQuRXJhc2VyOnJldHVybiBscjtjYXNlIEx0LlNlbGVjdG9yOnJldHVybiBpZX19ZnVuY3Rpb24gWmEoZyl7Y29uc3R7dG9vbHNUeXBlOmUsLi4udH09Zztzd2l0Y2goZSl7Y2FzZSBMdC5BcnJvdzpyZXR1cm4gbmV3IHphKHQpO2Nhc2UgTHQuUGVuY2lsOnJldHVybiBuZXcgamEodCk7Y2FzZSBMdC5TdHJhaWdodDpyZXR1cm4gbmV3IFlhKHQpO2Nhc2UgTHQuRWxsaXBzZTpyZXR1cm4gbmV3ICRhKHQpO2Nhc2UgTHQuUG9seWdvbjpjYXNlIEx0LlRyaWFuZ2xlOnJldHVybiBuZXcgSGEodCk7Y2FzZSBMdC5TdGFyOmNhc2UgTHQuUmhvbWJ1czpyZXR1cm4gbmV3IEthKHQpO2Nhc2UgTHQuUmVjdGFuZ2xlOnJldHVybiBuZXcgR2EodCk7Y2FzZSBMdC5UZXh0OnJldHVybiBuZXcgVmEodCk7Y2FzZSBMdC5MYXNlclBlbjpyZXR1cm4gbmV3IFVhKHQpO2Nhc2UgTHQuRXJhc2VyOnJldHVybiBuZXcgbHIodCk7Y2FzZSBMdC5TZWxlY3RvcjpyZXR1cm4gbmV3IGllKHQpO2RlZmF1bHQ6cmV0dXJufX1jbGFzcyBibSBleHRlbmRzIFJye2NvbnN0cnVjdG9yKCl7c3VwZXIoLi4uYXJndW1lbnRzKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiZW1pdEV2ZW50VHlwZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOm9lLlpJbmRleEFjdGl2ZX0pfWNvbnN1bWUoZSl7Y29uc3R7bXNnVHlwZTp0LGRhdGFUeXBlOm4sZW1pdEV2ZW50VHlwZTppfT1lO2lmKHQ9PT1UdC5VcGRhdGVOb2RlJiZuPT09enQuTG9jYWwmJmk9PT10aGlzLmVtaXRFdmVudFR5cGUpcmV0dXJuIHRoaXMuY29uc3VtZUZvckxvY2FsV29ya2VyKGUpLCEwfWNvbnN1bWVGb3JMb2NhbFdvcmtlcihlKXt2YXIgdSxhLGQsRSxwO2NvbnN0e3dvcmtJZDp0LGlzQWN0aXZlWkluZGV4Om4sd2lsbFJlZnJlc2hTZWxlY3RvcjppfT1lO2lmKHQhPT1pZS5zZWxlY3RvcklkKXJldHVybjtjb25zdCBmPSh1PXRoaXMubG9jYWxXb3JrKT09bnVsbD92b2lkIDA6dS53b3JrU2hhcGVzLmdldChpZS5zZWxlY3RvcklkKTtpZighZilyZXR1cm47Y29uc3QgaD1mLm9sZFNlbGVjdFJlY3Q7aWYobiYmaCYmdGhpcy5sb2NhbFdvcmspe2NvbnN0IE89bmV3IFNldDtpZih0aGlzLmxvY2FsV29yay52Tm9kZXMuY3VyTm9kZU1hcC5mb3JFYWNoKChtLGIpPT57Um4oaCxtLnJlY3QpJiZPLmFkZChiKX0pLE8uc2l6ZSl7Y29uc3QgbT1bXTtPLmZvckVhY2goYj0+e3ZhciBNOyhNPXRoaXMubG9jYWxXb3JrKT09bnVsbHx8TS5mdWxsTGF5ZXIuZ2V0RWxlbWVudHNCeU5hbWUoYikuZm9yRWFjaCh5PT57dmFyIHMsYztjb25zdCBTPXkuY2xvbmVOb2RlKCEwKTtyaSh5KSYmUy5zZWFsKCksKGM9KHM9dGhpcy5sb2NhbFdvcmspPT1udWxsP3ZvaWQgMDpzLmRyYXdMYXllcikhPW51bGwmJmMuZ2V0RWxlbWVudHNCeU5hbWUoYikubGVuZ3RofHxtLnB1c2goUyl9KX0pLG0ubGVuZ3RoJiYoKGE9dGhpcy5sb2NhbFdvcmsuZHJhd0xheWVyKT09bnVsbHx8YS5hcHBlbmQoLi4ubSkpfX1lbHNlKEU9KGQ9dGhpcy5sb2NhbFdvcmspPT1udWxsP3ZvaWQgMDpkLmRyYXdMYXllcik9PW51bGx8fEUuY2hpbGRyZW4uZmlsdGVyKE89Pnt2YXIgbTtyZXR1cm4hKChtPWYuc2VsZWN0SWRzKSE9bnVsbCYmbS5pbmNsdWRlcyhPLm5hbWUpKX0pLmZvckVhY2goTz0+Ty5yZW1vdmUoKSk7aSYmKChwPXRoaXMubG9jYWxXb3JrKT09bnVsbHx8cC5fcG9zdCh7cmVuZGVyOlt7cmVjdDpoLGRyYXdDYW52YXM6QnQuU2VsZWN0b3IsY2xlYXJDYW52YXM6QnQuU2VsZWN0b3IsaXNDbGVhcjohMCxpc0Z1bGxXb3JrOiExLHZpZXdJZDp0aGlzLmxvY2FsV29yay52aWV3SWR9XSxzcDpbe3R5cGU6VHQuU2VsZWN0LHNlbGVjdElkczpmLnNlbGVjdElkcyxvcHQ6Zi5nZXRXb3JrT3B0aW9ucygpLHNlbGVjdFJlY3Q6aCxzdHJva2VDb2xvcjpmLnN0cm9rZUNvbG9yLGZpbGxDb2xvcjpmLmZpbGxDb2xvcix3aWxsU3luY1NlcnZpY2U6ITEsaXNTeW5jOiEwfV19KSl9fWNsYXNzIEFtIGV4dGVuZHMgUnJ7Y29uc3RydWN0b3IoKXtzdXBlciguLi5hcmd1bWVudHMpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJlbWl0RXZlbnRUeXBlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6b2UuQ29weU5vZGV9KX1jb25zdW1lKGUpe2NvbnN0e21zZ1R5cGU6dCxkYXRhVHlwZTpuLGVtaXRFdmVudFR5cGU6aX09ZTtpZih0PT09VHQuRnVsbFdvcmsmJm49PT16dC5Mb2NhbCYmaT09PXRoaXMuZW1pdEV2ZW50VHlwZSlyZXR1cm4gdGhpcy5jb25zdW1lRm9yTG9jYWxXb3JrZXIoZSksITB9Y29uc3VtZUZvckxvY2FsV29ya2VyKGUpe3ZhciBuO2NvbnN0e3dvcmtJZDp0fT1lO3QmJigobj10aGlzLmxvY2FsV29yayk9PW51bGx8fG4uY29uc3VtZUZ1bGwoZSkpfX1jbGFzcyBDbSBleHRlbmRzIFJye2NvbnN0cnVjdG9yKCl7c3VwZXIoLi4uYXJndW1lbnRzKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiZW1pdEV2ZW50VHlwZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOm9lLlNldENvbG9yTm9kZX0pfWNvbnN1bWUoZSl7Y29uc3R7bXNnVHlwZTp0LGRhdGFUeXBlOm4sZW1pdEV2ZW50VHlwZTppLHVuZG9UaWNrZXJJZDpmfT1lO2lmKHQ9PT1UdC5VcGRhdGVOb2RlJiZuPT09enQuTG9jYWwmJmk9PT10aGlzLmVtaXRFdmVudFR5cGUpcmV0dXJuIHRoaXMuY29uc3VtZUZvckxvY2FsV29ya2VyKGUpLGYmJnNldFRpbWVvdXQoKCk9Pnt2YXIgaDsoaD10aGlzLmxvY2FsV29yayk9PW51bGx8fGguX3Bvc3Qoe3NwOlt7dHlwZTpUdC5Ob25lLHVuZG9UaWNrZXJJZDpmfV19KX0sMCksITB9Y29uc3VtZUZvckxvY2FsV29ya2VyKGUpe3ZhciBhO2NvbnN0e3dvcmtJZDp0LHVwZGF0ZU5vZGVPcHQ6bix3aWxsUmVmcmVzaFNlbGVjdG9yOmksd2lsbFN5bmNTZXJ2aWNlOmYsd2lsbFNlcmlhbGl6ZURhdGE6aCx0ZXh0VXBkYXRlRm9yV29rZXI6dX09ZTt0PT09aWUuc2VsZWN0b3JJZCYmbiYmKChhPXRoaXMubG9jYWxXb3JrKT09bnVsbHx8YS51cGRhdGVTZWxlY3Rvcih7dXBkYXRlU2VsZWN0b3JPcHQ6bix3aWxsUmVmcmVzaFNlbGVjdG9yOmksd2lsbFN5bmNTZXJ2aWNlOmYsd2lsbFNlcmlhbGl6ZURhdGE6aCx0ZXh0VXBkYXRlRm9yV29rZXI6dX0pKX19Y2xhc3MgUm0gZXh0ZW5kcyBScntjb25zdHJ1Y3Rvcigpe3N1cGVyKC4uLmFyZ3VtZW50cyksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImVtaXRFdmVudFR5cGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpvZS5aSW5kZXhOb2RlfSl9Y29uc3VtZShlKXtjb25zdHttc2dUeXBlOnQsZGF0YVR5cGU6bixlbWl0RXZlbnRUeXBlOml9PWU7aWYodD09PVR0LlVwZGF0ZU5vZGUmJm49PT16dC5Mb2NhbCYmaT09PXRoaXMuZW1pdEV2ZW50VHlwZSlyZXR1cm4gdGhpcy5jb25zdW1lRm9yTG9jYWxXb3JrZXIoZSksITB9Y29uc3VtZUZvckxvY2FsV29ya2VyKGUpe3ZhciB1O2NvbnN0e3dvcmtJZDp0LHVwZGF0ZU5vZGVPcHQ6bix3aWxsUmVmcmVzaFNlbGVjdG9yOmksd2lsbFN5bmNTZXJ2aWNlOmYsd2lsbFNlcmlhbGl6ZURhdGE6aH09ZTt0PT09aWUuc2VsZWN0b3JJZCYmbiYmKCh1PXRoaXMubG9jYWxXb3JrKT09bnVsbHx8dS51cGRhdGVTZWxlY3Rvcih7dXBkYXRlU2VsZWN0b3JPcHQ6bix3aWxsUmVmcmVzaFNlbGVjdG9yOmksd2lsbFN5bmNTZXJ2aWNlOmYsd2lsbFNlcmlhbGl6ZURhdGE6aH0pKX19Y2xhc3MgSW0gZXh0ZW5kcyBScntjb25zdHJ1Y3Rvcigpe3N1cGVyKC4uLmFyZ3VtZW50cyksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImVtaXRFdmVudFR5cGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpvZS5UcmFuc2xhdGVOb2RlfSl9Y29uc3VtZShlKXtjb25zdHttc2dUeXBlOnQsZGF0YVR5cGU6bixlbWl0RXZlbnRUeXBlOmksdW5kb1RpY2tlcklkOmZ9PWU7aWYodD09PVR0LlVwZGF0ZU5vZGUmJm49PT16dC5Mb2NhbCYmaT09PXRoaXMuZW1pdEV2ZW50VHlwZSlyZXR1cm4gdGhpcy5jb25zdW1lRm9yTG9jYWxXb3JrZXIoZSksZiYmc2V0VGltZW91dCgoKT0+e3ZhciBoOyhoPXRoaXMubG9jYWxXb3JrKT09bnVsbHx8aC5fcG9zdCh7c3A6W3t0eXBlOlR0Lk5vbmUsdW5kb1RpY2tlcklkOmZ9XX0pfSwwKSwhMH1jb25zdW1lRm9yTG9jYWxXb3JrZXIoZSl7dmFyIGQ7Y29uc3R7d29ya0lkOnQsdXBkYXRlTm9kZU9wdDpuLHdpbGxSZWZyZXNoU2VsZWN0b3I6aSx3aWxsU3luY1NlcnZpY2U6Zix3aWxsU2VyaWFsaXplRGF0YTpoLHRleHRVcGRhdGVGb3JXb2tlcjp1LGVtaXRFdmVudFR5cGU6YX09ZTt0PT09aWUuc2VsZWN0b3JJZCYmbiYmKChkPXRoaXMubG9jYWxXb3JrKT09bnVsbHx8ZC51cGRhdGVTZWxlY3Rvcih7dXBkYXRlU2VsZWN0b3JPcHQ6bix3aWxsUmVmcmVzaFNlbGVjdG9yOmksd2lsbFN5bmNTZXJ2aWNlOmYsd2lsbFNlcmlhbGl6ZURhdGE6aCxpc1N5bmM6ITAsdGV4dFVwZGF0ZUZvcldva2VyOnUsZW1pdEV2ZW50VHlwZTphfSkpfX1jbGFzcyBMbSBleHRlbmRzIFJye2NvbnN0cnVjdG9yKCl7c3VwZXIoLi4uYXJndW1lbnRzKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiZW1pdEV2ZW50VHlwZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOm9lLkRlbGV0ZU5vZGV9KX1jb25zdW1lKGUpe2NvbnN0e21zZ1R5cGU6dCxkYXRhVHlwZTpuLGVtaXRFdmVudFR5cGU6aX09ZTtpZih0PT09VHQuUmVtb3ZlTm9kZSl7aWYobj09PXp0LkxvY2FsJiZpPT09dGhpcy5lbWl0RXZlbnRUeXBlKXJldHVybiB0aGlzLmNvbnN1bWVGb3JMb2NhbFdvcmtlcihlKSwhMDtpZihuPT09enQuU2VydmljZSYmaT09PXRoaXMuZW1pdEV2ZW50VHlwZSlyZXR1cm4gdGhpcy5jb25zdW1lRm9yU2VydmljZVdvcmtlcihlKSwhMH19Y29uc3VtZUZvckxvY2FsV29ya2VyKGUpe2lmKCF0aGlzLmxvY2FsV29yaylyZXR1cm47Y29uc3R7cmVtb3ZlSWRzOnQsd2lsbFJlZnJlc2g6bix3aWxsU3luY1NlcnZpY2U6aSx2aWV3SWQ6Zn09ZTtpZighKHQhPW51bGwmJnQubGVuZ3RoKSlyZXR1cm47bGV0IGg7Y29uc3QgdT1bXSxhPVtdLGQ9W107Zm9yKGNvbnN0IEUgb2YgdCl7aWYoRT09PWllLnNlbGVjdG9ySWQpe2NvbnN0IE89dGhpcy5sb2NhbFdvcmsud29ya1NoYXBlcy5nZXQoaWUuc2VsZWN0b3JJZCksbT1PLnNlbGVjdElkcyYmWy4uLk8uc2VsZWN0SWRzXXx8W107Zm9yKGNvbnN0IE0gb2YgbSl7aWYodGhpcy5sb2NhbFdvcmsudk5vZGVzLmdldChNKSl7Y29uc3QgUz10aGlzLmNvbW1hbmREZWxldGVUZXh0KE0pO1MmJnUucHVzaChTKX1oPSR0KGgsdGhpcy5sb2NhbFdvcmsucmVtb3ZlTm9kZShNKSksZC5wdXNoKE0pfWNvbnN0IGI9Tz09bnVsbD92b2lkIDA6Ty51cGRhdGVTZWxlY3RJZHMoW10pO2g9JHQoaCxiLmJnUmVjdCksdGhpcy5sb2NhbFdvcmsuY2xlYXJXb3JrU2hhcGVOb2RlQ2FjaGUoaWUuc2VsZWN0b3JJZCksdGhpcy5sb2NhbFdvcmsud29ya1NoYXBlcy5kZWxldGUoaWUuc2VsZWN0b3JJZCksdS5wdXNoKHt0eXBlOlR0LlNlbGVjdCxzZWxlY3RJZHM6W10sd2lsbFN5bmNTZXJ2aWNlOml9KTtjb250aW51ZX1jb25zdCBwPXRoaXMuY29tbWFuZERlbGV0ZVRleHQoRSk7cCYmdS5wdXNoKHApLGg9JHQoaCx0aGlzLmxvY2FsV29yay5yZW1vdmVOb2RlKEUpKSxkLnB1c2goRSl9aSYmdS5wdXNoKHt0eXBlOlR0LlJlbW92ZU5vZGUscmVtb3ZlSWRzOmQsdW5kb1RpY2tlcklkOmUudW5kb1RpY2tlcklkfSksaCYmbiYmYS5wdXNoKHtyZWN0OmgsZHJhd0NhbnZhczpCdC5CZyxjbGVhckNhbnZhczpCdC5CZyxpc0NsZWFyOiEwLGlzRnVsbFdvcms6ITAsdmlld0lkOmZ9KSwoYS5sZW5ndGh8fHUubGVuZ3RoKSYmdGhpcy5sb2NhbFdvcmsuX3Bvc3Qoe3JlbmRlcjphLHNwOnV9KX1jb25zdW1lRm9yU2VydmljZVdvcmtlcihlKXt0aGlzLnNlcnZpY2VXb3JrJiZ0aGlzLnNlcnZpY2VXb3JrLnJlbW92ZVNlbGVjdFdvcmsoZSl9Y29tbWFuZERlbGV0ZVRleHQoZSl7dmFyIG47Y29uc3QgdD0obj10aGlzLmxvY2FsV29yayk9PW51bGw/dm9pZCAwOm4udk5vZGVzLmdldChlKTtpZih0JiZ0LnRvb2xzVHlwZT09PUx0LlRleHQpcmV0dXJue3R5cGU6VHQuVGV4dFVwZGF0ZSx0b29sc1R5cGU6THQuVGV4dCx3b3JrSWQ6ZX19fWNsYXNzIERtIGV4dGVuZHMgUnJ7Y29uc3RydWN0b3IoKXtzdXBlciguLi5hcmd1bWVudHMpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJlbWl0RXZlbnRUeXBlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6b2UuU2NhbGVOb2RlfSl9Y29uc3VtZShlKXtjb25zdHttc2dUeXBlOnQsZGF0YVR5cGU6bixlbWl0RXZlbnRUeXBlOmksdW5kb1RpY2tlcklkOmZ9PWU7aWYodD09PVR0LlVwZGF0ZU5vZGUmJm49PT16dC5Mb2NhbCYmaT09PXRoaXMuZW1pdEV2ZW50VHlwZSlyZXR1cm4gdGhpcy5jb25zdW1lRm9yTG9jYWxXb3JrZXIoZSksZiYmc2V0VGltZW91dCgoKT0+e3ZhciBoOyhoPXRoaXMubG9jYWxXb3JrKT09bnVsbHx8aC5fcG9zdCh7c3A6W3t0eXBlOlR0Lk5vbmUsdW5kb1RpY2tlcklkOmZ9XX0pfSwwKSwhMH1jb25zdW1lRm9yTG9jYWxXb3JrZXIoZSl7dmFyIGE7Y29uc3R7d29ya0lkOnQsdXBkYXRlTm9kZU9wdDpuLHdpbGxSZWZyZXNoU2VsZWN0b3I6aSx3aWxsU3luY1NlcnZpY2U6Zix3aWxsU2VyaWFsaXplRGF0YTpoLHRleHRVcGRhdGVGb3JXb2tlcjp1fT1lO3Q9PT1pZS5zZWxlY3RvcklkJiZuJiYoKGE9dGhpcy5sb2NhbFdvcmspPT1udWxsfHxhLnVwZGF0ZVNlbGVjdG9yKHt1cGRhdGVTZWxlY3Rvck9wdDpuLHdpbGxSZWZyZXNoU2VsZWN0b3I6aSx3aWxsU3luY1NlcnZpY2U6ZixlbWl0RXZlbnRUeXBlOnRoaXMuZW1pdEV2ZW50VHlwZSx3aWxsU2VyaWFsaXplRGF0YTpoLGlzU3luYzohMCx0ZXh0VXBkYXRlRm9yV29rZXI6dX0pKX19Y2xhc3Mgd20gZXh0ZW5kcyBScntjb25zdHJ1Y3Rvcigpe3N1cGVyKC4uLmFyZ3VtZW50cyksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImVtaXRFdmVudFR5cGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpvZS5Sb3RhdGVOb2RlfSl9Y29uc3VtZShlKXtjb25zdHttc2dUeXBlOnQsZGF0YVR5cGU6bixlbWl0RXZlbnRUeXBlOmksdW5kb1RpY2tlcklkOmZ9PWU7aWYodD09PVR0LlVwZGF0ZU5vZGUmJm49PT16dC5Mb2NhbCYmaT09PXRoaXMuZW1pdEV2ZW50VHlwZSlyZXR1cm4gdGhpcy5jb25zdW1lRm9yTG9jYWxXb3JrZXIoZSksZiYmc2V0VGltZW91dCgoKT0+e3ZhciBoOyhoPXRoaXMubG9jYWxXb3JrKT09bnVsbHx8aC5fcG9zdCh7c3A6W3t0eXBlOlR0Lk5vbmUsdW5kb1RpY2tlcklkOmZ9XX0pfSwwKSwhMH1jb25zdW1lRm9yTG9jYWxXb3JrZXIoZSl7dmFyIGE7Y29uc3R7d29ya0lkOnQsdXBkYXRlTm9kZU9wdDpuLHdpbGxSZWZyZXNoU2VsZWN0b3I6aSx3aWxsU3luY1NlcnZpY2U6Zix3aWxsU2VyaWFsaXplRGF0YTpoLGVtaXRFdmVudFR5cGU6dX09ZTt0PT09aWUuc2VsZWN0b3JJZCYmbiYmKChhPXRoaXMubG9jYWxXb3JrKT09bnVsbHx8YS51cGRhdGVTZWxlY3Rvcih7dXBkYXRlU2VsZWN0b3JPcHQ6bix3aWxsUmVmcmVzaFNlbGVjdG9yOmksd2lsbFN5bmNTZXJ2aWNlOmYsd2lsbFNlcmlhbGl6ZURhdGE6aCxlbWl0RXZlbnRUeXBlOnUsaXNTeW5jOiEwfSkpfX1jbGFzcyBObXtjb25zdHJ1Y3RvcihlKXtPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiYnVpbGRlcnMiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpuZXcgTWFwfSksdGhpcy5idWlsZGVycz1uZXcgTWFwKGUubWFwKHQ9Plt0LHRoaXMuYnVpbGQodCldKSl9YnVpbGQoZSl7c3dpdGNoKGUpe2Nhc2Ugb2UuVHJhbnNsYXRlTm9kZTpyZXR1cm4gbmV3IEltO2Nhc2Ugb2UuWkluZGV4Tm9kZTpyZXR1cm4gbmV3IFJtO2Nhc2Ugb2UuWkluZGV4QWN0aXZlOnJldHVybiBuZXcgYm07Y2FzZSBvZS5Db3B5Tm9kZTpyZXR1cm4gbmV3IEFtO2Nhc2Ugb2UuU2V0Q29sb3JOb2RlOnJldHVybiBuZXcgQ207Y2FzZSBvZS5EZWxldGVOb2RlOnJldHVybiBuZXcgTG07Y2FzZSBvZS5TY2FsZU5vZGU6cmV0dXJuIG5ldyBEbTtjYXNlIG9lLlJvdGF0ZU5vZGU6cmV0dXJuIG5ldyB3bX19cmVnaXN0ZXJGb3JXb3JrZXIoZSx0KXtyZXR1cm4gdGhpcy5idWlsZGVycy5mb3JFYWNoKG49PntuJiZuLnJlZ2lzdGVyRm9yV29ya2VyKGUsdCl9KSx0aGlzfWNvbnN1bWVGb3JXb3JrZXIoZSl7Zm9yKGNvbnN0IHQgb2YgdGhpcy5idWlsZGVycy52YWx1ZXMoKSlpZih0IT1udWxsJiZ0LmNvbnN1bWUoZSkpcmV0dXJuITA7cmV0dXJuITF9fWNsYXNzIEJte2NvbnN0cnVjdG9yKGUsdCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInZpZXdJZCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzY2VuZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzY2VuZVBhdGgiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiZHJhd0xheWVyIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImZ1bGxMYXllciIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJjdXJOb2RlTWFwIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6bmV3IE1hcH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ0YXJnZXROb2RlTWFwIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6W119KSx0aGlzLnZpZXdJZD1lLHRoaXMuc2NlbmU9dH1pbml0KGUsdCl7dGhpcy5mdWxsTGF5ZXI9ZSx0aGlzLmRyYXdMYXllcj10fWdldChlKXtyZXR1cm4gdGhpcy5jdXJOb2RlTWFwLmdldChlKX1oYXNSZW5kZXJOb2Rlcygpe2xldCBlPSExO2Zvcihjb25zdCB0IG9mIHRoaXMuY3VyTm9kZU1hcC52YWx1ZXMoKSl3YSh0LnRvb2xzVHlwZSkmJihlPSEwKTtyZXR1cm4gZX1oYXMoZSl7dGhpcy5jdXJOb2RlTWFwLmhhcyhlKX1zZXRJbmZvKGUsdCl7Y29uc3Qgbj10aGlzLmN1ck5vZGVNYXAuZ2V0KGUpfHx7bmFtZTplLHJlY3Q6dC5yZWN0fTt0LnJlY3QmJihuLnJlY3Q9ZHIodC5yZWN0KSksdC5vcCYmKG4ub3A9ZHIodC5vcCkpLHQuY2FuUm90YXRlJiYobi5jYW5Sb3RhdGU9dC5jYW5Sb3RhdGUpLHQuc2NhbGVUeXBlJiYobi5zY2FsZVR5cGU9dC5zY2FsZVR5cGUpLHQub3B0JiYobi5vcHQ9ZHIodC5vcHQpKSx0LnRvb2xzVHlwZSYmKG4udG9vbHNUeXBlPXQudG9vbHNUeXBlKSx0LmNlbnRlclBvcyYmKG4uY2VudGVyUG9zPWRyKHQuY2VudGVyUG9zKSksbi5yZWN0P3RoaXMuY3VyTm9kZU1hcC5zZXQoZSxuKTp0aGlzLmN1ck5vZGVNYXAuZGVsZXRlKGUpfWRlbGV0ZShlKXt0aGlzLmN1ck5vZGVNYXAuZGVsZXRlKGUpfWNsZWFyKCl7dGhpcy5jdXJOb2RlTWFwLmNsZWFyKCksdGhpcy50YXJnZXROb2RlTWFwLmxlbmd0aD0wfWdldFJlY3RJbnRlcnNlY3RSYW5nZShlKXtsZXQgdDtjb25zdCBuPW5ldyBNYXA7cmV0dXJuIHRoaXMuY3VyTm9kZU1hcC5mb3JFYWNoKChpLGYpPT57Um4oZSxpLnJlY3QpJiYodD0kdCh0LGkucmVjdCksbi5zZXQoZixpKSl9KSx7cmVjdFJhbmdlOnQsbm9kZVJhbmdlOm59fWdldE5vZGVSZWN0Rm9ybVNoYXBlKGUsdCl7Y29uc3Qgbj1YYSh0LnRvb2xzVHlwZSk7bGV0IGk9dGhpcy5mdWxsTGF5ZXImJihuPT1udWxsP3ZvaWQgMDpuLmdldFJlY3RGcm9tTGF5ZXIodGhpcy5mdWxsTGF5ZXIsZSkpO3JldHVybiFpJiZ0aGlzLmRyYXdMYXllciYmKGk9bj09bnVsbD92b2lkIDA6bi5nZXRSZWN0RnJvbUxheWVyKHRoaXMuZHJhd0xheWVyLGUpKSxpfXVwZGF0ZU5vZGVzUmVjdCgpe3RoaXMuY3VyTm9kZU1hcC5mb3JFYWNoKChlLHQpPT57Y29uc3Qgbj10aGlzLmdldE5vZGVSZWN0Rm9ybVNoYXBlKHQsZSk7bj8oZS5yZWN0PW4sdGhpcy5jdXJOb2RlTWFwLnNldCh0LGUpKTp0aGlzLmN1ck5vZGVNYXAuZGVsZXRlKHQpfSl9Y29tYmluZUludGVyc2VjdFJlY3QoZSl7bGV0IHQ9ZTtyZXR1cm4gdGhpcy5jdXJOb2RlTWFwLmZvckVhY2gobj0+e1JuKHQsbi5yZWN0KSYmKHQ9JHQodCxuLnJlY3QpKX0pLHR9c2V0VGFyZ2V0KCl7cmV0dXJuIHRoaXMudGFyZ2V0Tm9kZU1hcC5wdXNoKGRyKHRoaXMuY3VyTm9kZU1hcCkpLHRoaXMudGFyZ2V0Tm9kZU1hcC5sZW5ndGgtMX1nZXRMYXN0VGFyZ2V0KCl7cmV0dXJuIHRoaXMudGFyZ2V0Tm9kZU1hcFt0aGlzLnRhcmdldE5vZGVNYXAubGVuZ3RoLTFdfWRlbGV0ZUxhc3RUYXJnZXQoKXt0aGlzLnRhcmdldE5vZGVNYXAubGVuZ3RoPXRoaXMudGFyZ2V0Tm9kZU1hcC5sZW5ndGgtMX1nZXRUYXJnZXQoZSl7cmV0dXJuIHRoaXMudGFyZ2V0Tm9kZU1hcFtlXX1kZWxldGVUYXJnZXQoZSl7dGhpcy50YXJnZXROb2RlTWFwLmxlbmd0aD1lfX1jbGFzcyBKYXtjb25zdHJ1Y3RvcihlLHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ2aWV3SWQiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiZnVsbExheWVyIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInZOb2RlcyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJkcHIiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywib3B0Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImNhbWVyYU9wdCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzY2VuZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLHRoaXMudmlld0lkPWUsdGhpcy5vcHQ9dCx0aGlzLmRwcj10LmRwcix0aGlzLnNjZW5lPXRoaXMuY3JlYXRlU2NlbmUodC5vZmZzY3JlZW5DYW52YXNPcHQpLHRoaXMuZnVsbExheWVyPXRoaXMuY3JlYXRlTGF5ZXIoImZ1bGxMYXllciIsdGhpcy5zY2VuZSx7Li4udC5sYXllck9wdCxidWZmZXJTaXplOnRoaXMudmlld0lkPT09Im1haW5WaWV3Ij82ZTM6M2UzfSksdGhpcy52Tm9kZXM9bmV3IEJtKGUsdGhpcy5zY2VuZSl9b24oZSl7Y29uc3R7bXNnVHlwZTp0LHRvb2xzVHlwZTpuLG9wdDppLHdvcmtJZDpmLHdvcmtTdGF0ZTpoLGRhdGFUeXBlOnV9PWU7c3dpdGNoKHQpe2Nhc2UgVHQuRGVzdHJveTp0aGlzLmRlc3Ryb3koKTticmVhaztjYXNlIFR0LkNsZWFyOnRoaXMuY2xlYXJBbGwoKTticmVhaztjYXNlIFR0LlVwZGF0ZVRvb2xzOmlmKG4mJmkpe2NvbnN0IGE9e3Rvb2xzVHlwZTpuLHRvb2xzT3B0Oml9O3RoaXMubG9jYWxXb3JrLnNldFRvb2xzT3B0KGEpfWJyZWFrO2Nhc2UgVHQuQ3JlYXRlV29yazpmJiZpJiYoIXRoaXMubG9jYWxXb3JrLmdldFRtcFdvcmtTaGFwZU5vZGUoKSYmbiYmdGhpcy5zZXRUb29sc09wdCh7dG9vbHNUeXBlOm4sdG9vbHNPcHQ6aX0pLHRoaXMuc2V0V29ya09wdCh7d29ya0lkOmYsdG9vbHNPcHQ6aX0pKTticmVhaztjYXNlIFR0LkRyYXdXb3JrOmg9PT1jZS5Eb25lJiZ1PT09enQuTG9jYWw/dGhpcy5jb25zdW1lRHJhd0FsbCh1LGUpOnRoaXMuY29uc3VtZURyYXcodSxlKTticmVha319dXBkYXRlU2NlbmUoZSl7dGhpcy5zY2VuZS5hdHRyKHsuLi5lfSk7Y29uc3R7d2lkdGg6dCxoZWlnaHQ6bn09ZTt0aGlzLnNjZW5lLmNvbnRhaW5lci53aWR0aD10LHRoaXMuc2NlbmUuY29udGFpbmVyLmhlaWdodD1uLHRoaXMuc2NlbmUud2lkdGg9dCx0aGlzLnNjZW5lLmhlaWdodD1uLHRoaXMudXBkYXRlTGF5ZXIoe3dpZHRoOnQsaGVpZ2h0Om59KX11cGRhdGVMYXllcihlKXtjb25zdHt3aWR0aDp0LGhlaWdodDpufT1lO3RoaXMuZnVsbExheWVyJiYodGhpcy5mdWxsTGF5ZXIucGFyZW50LnNldEF0dHJpYnV0ZSgid2lkdGgiLHQpLHRoaXMuZnVsbExheWVyLnBhcmVudC5zZXRBdHRyaWJ1dGUoImhlaWdodCIsbiksdGhpcy5mdWxsTGF5ZXIuc2V0QXR0cmlidXRlKCJzaXplIixbdCxuXSksdGhpcy5mdWxsTGF5ZXIuc2V0QXR0cmlidXRlKCJwb3MiLFt0Ki41LG4qLjVdKSksdGhpcy5kcmF3TGF5ZXImJih0aGlzLmRyYXdMYXllci5wYXJlbnQuc2V0QXR0cmlidXRlKCJ3aWR0aCIsdCksdGhpcy5kcmF3TGF5ZXIucGFyZW50LnNldEF0dHJpYnV0ZSgiaGVpZ2h0IixuKSx0aGlzLmRyYXdMYXllci5zZXRBdHRyaWJ1dGUoInNpemUiLFt0LG5dKSx0aGlzLmRyYXdMYXllci5zZXRBdHRyaWJ1dGUoInBvcyIsW3QqLjUsbiouNV0pKSx0aGlzLnNuYXBzaG90RnVsbExheWVyJiYodGhpcy5zbmFwc2hvdEZ1bGxMYXllci5wYXJlbnQuc2V0QXR0cmlidXRlKCJ3aWR0aCIsdCksdGhpcy5zbmFwc2hvdEZ1bGxMYXllci5wYXJlbnQuc2V0QXR0cmlidXRlKCJoZWlnaHQiLG4pLHRoaXMuc25hcHNob3RGdWxsTGF5ZXIuc2V0QXR0cmlidXRlKCJzaXplIixbdCxuXSksdGhpcy5zbmFwc2hvdEZ1bGxMYXllci5zZXRBdHRyaWJ1dGUoInBvcyIsW3QqLjUsbiouNV0pKX1jcmVhdGVTY2VuZShlKXtjb25zdHt3aWR0aDp0LGhlaWdodDpufT1lLGk9bmV3IE9mZnNjcmVlbkNhbnZhcyh0LG4pO3JldHVybiBuZXcgeG0oe2NvbnRhaW5lcjppLGRpc3BsYXlSYXRpbzp0aGlzLmRwcixkZXB0aDohMSxkZXN5bmNocm9uaXplZDohMCwuLi5lfSl9Y3JlYXRlTGF5ZXIoZSx0LG4pe2NvbnN0e3dpZHRoOmksaGVpZ2h0OmZ9PW4saD1gb2Zmc2NyZWVuLSR7ZX1gLHU9dC5sYXllcihoLG4pLGE9bmV3IElyKHthbmNob3I6Wy41LC41XSxwb3M6W2kqLjUsZiouNV0sc2l6ZTpbaSxmXSxuYW1lOiJ2aWV3cG9ydCIsaWQ6ZX0pO3JldHVybiB1LmFwcGVuZChhKSxhfWNsZWFyQWxsKCl7dmFyIGU7dGhpcy5mdWxsTGF5ZXImJih0aGlzLmZ1bGxMYXllci5wYXJlbnQuY2hpbGRyZW4uZm9yRWFjaCh0PT57dC5uYW1lIT09InZpZXdwb3J0IiYmdC5yZW1vdmUoKX0pLHRoaXMuZnVsbExheWVyLnJlbW92ZUFsbENoaWxkcmVuKCkpLHRoaXMuZHJhd0xheWVyJiYodGhpcy5kcmF3TGF5ZXIucGFyZW50LmNoaWxkcmVuLmZvckVhY2godD0+e3QubmFtZSE9PSJ2aWV3cG9ydCImJnQucmVtb3ZlKCl9KSx0aGlzLmRyYXdMYXllci5yZW1vdmVBbGxDaGlsZHJlbigpKSx0aGlzLmxvY2FsV29yay5jbGVhckFsbFdvcmtTaGFwZXNDYWNoZSgpLChlPXRoaXMuc2VydmljZVdvcmspPT1udWxsfHxlLmNsZWFyQWxsV29ya1NoYXBlc0NhY2hlKCl9c2V0VG9vbHNPcHQoZSl7dGhpcy5sb2NhbFdvcmsuc2V0VG9vbHNPcHQoZSl9c2V0V29ya09wdChlKXtjb25zdHt3b3JrSWQ6dCx0b29sc09wdDpufT1lO3QmJm4mJnRoaXMubG9jYWxXb3JrLnNldFdvcmtPcHRpb25zKHQsbil9ZGVzdHJveSgpe3ZhciBlO3RoaXMudk5vZGVzLmNsZWFyKCksdGhpcy5zY2VuZS5yZW1vdmUoKSx0aGlzLmZ1bGxMYXllci5yZW1vdmUoKSx0aGlzLmxvY2FsV29yay5kZXN0cm95KCksKGU9dGhpcy5zZXJ2aWNlV29yayk9PW51bGx8fGUuZGVzdHJveSgpfX1jbGFzcyBRYXtjb25zdHJ1Y3RvcihlKXtPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidmlld0lkIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInZOb2RlcyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJmdWxsTGF5ZXIiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiZHJhd0xheWVyIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIl9wb3N0Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInRtcFdvcmtTaGFwZU5vZGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidG1wT3B0Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIndvcmtTaGFwZXMiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpuZXcgTWFwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIndvcmtTaGFwZVN0YXRlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6bmV3IE1hcH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJlZmZlY3RXb3JrSWQiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiZHJhd0NvdW50Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6MH0pLHRoaXMudmlld0lkPWUudmlld0lkLHRoaXMudk5vZGVzPWUudk5vZGVzLHRoaXMuZnVsbExheWVyPWUuZnVsbExheWVyLHRoaXMuZHJhd0xheWVyPWUuZHJhd0xheWVyLHRoaXMuX3Bvc3Q9ZS5wb3N0fWRlc3Ryb3koKXt0aGlzLndvcmtTaGFwZVN0YXRlLmNsZWFyKCksdGhpcy53b3JrU2hhcGVzLmNsZWFyKCl9Z2V0V29ya1NoYXBlKGUpe3JldHVybiB0aGlzLndvcmtTaGFwZXMuZ2V0KGUpfWdldFRtcFdvcmtTaGFwZU5vZGUoKXtyZXR1cm4gdGhpcy50bXBXb3JrU2hhcGVOb2RlfXNldFRtcFdvcmtJZChlKXtpZihlJiZ0aGlzLnRtcFdvcmtTaGFwZU5vZGUpe3RoaXMudG1wV29ya1NoYXBlTm9kZS5zZXRXb3JrSWQoZSksdGhpcy53b3JrU2hhcGVzLnNldChlLHRoaXMudG1wV29ya1NoYXBlTm9kZSksdGhpcy50bXBPcHQmJnRoaXMuc2V0VG9vbHNPcHQodGhpcy50bXBPcHQpO3JldHVybn19c2V0VG1wV29ya09wdGlvbnMoZSl7dmFyIHQ7KHQ9dGhpcy50bXBXb3JrU2hhcGVOb2RlKT09bnVsbHx8dC5zZXRXb3JrT3B0aW9ucyhlKX1zZXRXb3JrT3B0aW9ucyhlLHQpe3ZhciBpO3RoaXMud29ya1NoYXBlcy5nZXQoZSl8fHRoaXMuc2V0VG1wV29ya0lkKGUpLChpPXRoaXMud29ya1NoYXBlcy5nZXQoZSkpPT1udWxsfHxpLnNldFdvcmtPcHRpb25zKHQpfWNyZWF0ZVdvcmtTaGFwZU5vZGUoZSl7cmV0dXJuIFphKHsuLi5lLHZOb2Rlczp0aGlzLnZOb2RlcyxmdWxsTGF5ZXI6dGhpcy5mdWxsTGF5ZXIsZHJhd0xheWVyOnRoaXMuZHJhd0xheWVyfSl9c2V0VG9vbHNPcHQoZSl7dmFyIHQsbjsoKHQ9dGhpcy50bXBPcHQpPT1udWxsP3ZvaWQgMDp0LnRvb2xzVHlwZSkhPT1lLnRvb2xzVHlwZSYmKG49dGhpcy50bXBPcHQpIT1udWxsJiZuLnRvb2xzVHlwZSYmdGhpcy5jbGVhckFsbFdvcmtTaGFwZXNDYWNoZSgpLHRoaXMudG1wT3B0PWUsdGhpcy50bXBXb3JrU2hhcGVOb2RlPXRoaXMuY3JlYXRlV29ya1NoYXBlTm9kZShlKX1jbGVhcldvcmtTaGFwZU5vZGVDYWNoZShlKXt2YXIgdDsodD10aGlzLmdldFdvcmtTaGFwZShlKSk9PW51bGx8fHQuY2xlYXJUbXBQb2ludHMoKSx0aGlzLndvcmtTaGFwZXMuZGVsZXRlKGUpLHRoaXMud29ya1NoYXBlU3RhdGUuZGVsZXRlKGUpfWNsZWFyQWxsV29ya1NoYXBlc0NhY2hlKCl7dGhpcy53b3JrU2hhcGVzLmZvckVhY2goZT0+ZS5jbGVhclRtcFBvaW50cygpKSx0aGlzLndvcmtTaGFwZXMuY2xlYXIoKSx0aGlzLndvcmtTaGFwZVN0YXRlLmNsZWFyKCl9c2V0RnVsbFdvcmsoZSl7Y29uc3R7d29ya0lkOnQsb3B0Om4sdG9vbHNUeXBlOml9PWU7aWYodCYmbiYmaSl7Y29uc3QgZj10JiZ0aGlzLndvcmtTaGFwZXMuZ2V0KHQpfHx0aGlzLmNyZWF0ZVdvcmtTaGFwZU5vZGUoe3Rvb2xzT3B0Om4sdG9vbHNUeXBlOml9KTtyZXR1cm4gZj8oZi5zZXRXb3JrSWQodCksdGhpcy53b3JrU2hhcGVzLnNldCh0LGYpLGYpOnZvaWQgMH19fXZhciBXbT1hcixGbT1mdW5jdGlvbigpe3JldHVybiBXbS5EYXRlLm5vdygpfSxqbT1GbSxVbT0vXHMvO2Z1bmN0aW9uIHptKGcpe2Zvcih2YXIgZT1nLmxlbmd0aDtlLS0mJlVtLnRlc3QoZy5jaGFyQXQoZSkpOyk7cmV0dXJuIGV9dmFyICRtPXptLEdtPSRtLEttPS9eXHMrLztmdW5jdGlvbiBIbShnKXtyZXR1cm4gZyYmZy5zbGljZSgwLEdtKGcpKzEpLnJlcGxhY2UoS20sIiIpfXZhciBZbT1IbSxWbT1ybixYbT1HcixabT0iW29iamVjdCBTeW1ib2xdIjtmdW5jdGlvbiBKbShnKXtyZXR1cm4gdHlwZW9mIGc9PSJzeW1ib2wifHxYbShnKSYmVm0oZyk9PVptfXZhciBRbT1KbSxrbT1ZbSxrYT1DcixxbT1RbSxxYT1OYU4sX209L15bLStdMHhbMC05YS1mXSskL2ksdHk9L14wYlswMV0rJC9pLGV5PS9eMG9bMC03XSskL2kscnk9cGFyc2VJbnQ7ZnVuY3Rpb24gbnkoZyl7aWYodHlwZW9mIGc9PSJudW1iZXIiKXJldHVybiBnO2lmKHFtKGcpKXJldHVybiBxYTtpZihrYShnKSl7dmFyIGU9dHlwZW9mIGcudmFsdWVPZj09ImZ1bmN0aW9uIj9nLnZhbHVlT2YoKTpnO2c9a2EoZSk/ZSsiIjplfWlmKHR5cGVvZiBnIT0ic3RyaW5nIilyZXR1cm4gZz09PTA/ZzorZztnPWttKGcpO3ZhciB0PXR5LnRlc3QoZyk7cmV0dXJuIHR8fGV5LnRlc3QoZyk/cnkoZy5zbGljZSgyKSx0PzI6OCk6X20udGVzdChnKT9xYTorZ312YXIgaXk9bnksc3k9Q3IsbXM9am0sX2E9aXksb3k9IkV4cGVjdGVkIGEgZnVuY3Rpb24iLGF5PU1hdGgubWF4LGx5PU1hdGgubWluO2Z1bmN0aW9uIHV5KGcsZSx0KXt2YXIgbixpLGYsaCx1LGEsZD0wLEU9ITEscD0hMSxPPSEwO2lmKHR5cGVvZiBnIT0iZnVuY3Rpb24iKXRocm93IG5ldyBUeXBlRXJyb3Iob3kpO2U9X2EoZSl8fDAsc3kodCkmJihFPSEhdC5sZWFkaW5nLHA9Im1heFdhaXQiaW4gdCxmPXA/YXkoX2EodC5tYXhXYWl0KXx8MCxlKTpmLE89InRyYWlsaW5nImluIHQ/ISF0LnRyYWlsaW5nOk8pO2Z1bmN0aW9uIG0oVCl7dmFyIFI9bixMPWk7cmV0dXJuIG49aT12b2lkIDAsZD1ULGg9Zy5hcHBseShMLFIpLGh9ZnVuY3Rpb24gYihUKXtyZXR1cm4gZD1ULHU9c2V0VGltZW91dChTLGUpLEU/bShUKTpofWZ1bmN0aW9uIE0oVCl7dmFyIFI9VC1hLEw9VC1kLE49ZS1SO3JldHVybiBwP2x5KE4sZi1MKTpOfWZ1bmN0aW9uIHkoVCl7dmFyIFI9VC1hLEw9VC1kO3JldHVybiBhPT09dm9pZCAwfHxSPj1lfHxSPDB8fHAmJkw+PWZ9ZnVuY3Rpb24gUygpe3ZhciBUPW1zKCk7aWYoeShUKSlyZXR1cm4gcyhUKTt1PXNldFRpbWVvdXQoUyxNKFQpKX1mdW5jdGlvbiBzKFQpe3JldHVybiB1PXZvaWQgMCxPJiZuP20oVCk6KG49aT12b2lkIDAsaCl9ZnVuY3Rpb24gYygpe3UhPT12b2lkIDAmJmNsZWFyVGltZW91dCh1KSxkPTAsbj1hPWk9dT12b2lkIDB9ZnVuY3Rpb24gbCgpe3JldHVybiB1PT09dm9pZCAwP2g6cyhtcygpKX1mdW5jdGlvbiB2KCl7dmFyIFQ9bXMoKSxSPXkoVCk7aWYobj1hcmd1bWVudHMsaT10aGlzLGE9VCxSKXtpZih1PT09dm9pZCAwKXJldHVybiBiKGEpO2lmKHApcmV0dXJuIGNsZWFyVGltZW91dCh1KSx1PXNldFRpbWVvdXQoUyxlKSxtKGEpfXJldHVybiB1PT09dm9pZCAwJiYodT1zZXRUaW1lb3V0KFMsZSkpLGh9cmV0dXJuIHYuY2FuY2VsPWMsdi5mbHVzaD1sLHZ9dmFyIGZ5PXV5LGN5PWZ5LGh5PUNyLGR5PSJFeHBlY3RlZCBhIGZ1bmN0aW9uIjtmdW5jdGlvbiBneShnLGUsdCl7dmFyIG49ITAsaT0hMDtpZih0eXBlb2YgZyE9ImZ1bmN0aW9uIil0aHJvdyBuZXcgVHlwZUVycm9yKGR5KTtyZXR1cm4gaHkodCkmJihuPSJsZWFkaW5nImluIHQ/ISF0LmxlYWRpbmc6bixpPSJ0cmFpbGluZyJpbiB0PyEhdC50cmFpbGluZzppKSxjeShnLGUse2xlYWRpbmc6bixtYXhXYWl0OmUsdHJhaWxpbmc6aX0pfXZhciB2eT1neSx0bD1Wbih2eSk7Y2xhc3MgcHkgZXh0ZW5kcyBRYXtjb25zdHJ1Y3RvcihlKXtzdXBlcihlKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiY29tYmluZVVuaXRUaW1lIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6NjAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImNvbWJpbmVUaW1lcklkIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImVmZmVjdFNlbGVjdE5vZGVEYXRhIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6bmV3IFNldH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJiYXRjaEVyYXNlcldvcmtzIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6bmV3IFNldH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJiYXRjaEVyYXNlclJlbW92ZU5vZGVzIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6bmV3IFNldH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJiYXRjaEVmZmVjdFdvcmsiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp0bCh0PT57dGhpcy52Tm9kZXMuY3VyTm9kZU1hcC5zaXplJiYodGhpcy52Tm9kZXMudXBkYXRlTm9kZXNSZWN0KCksdGhpcy5yZVJlbmRlclNlbGVjdG9yKCkpLHQmJnQoKX0sMTAwLHtsZWFkaW5nOiExfSl9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiYmF0Y2hFcmFzZXJDb21iaW5lIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dGwoKCk9Pntjb25zdCB0PXRoaXMudXBkYXRlQmF0Y2hFcmFzZXJDb21iaW5lTm9kZSh0aGlzLmJhdGNoRXJhc2VyV29ya3MsdGhpcy5iYXRjaEVyYXNlclJlbW92ZU5vZGVzKTt0aGlzLmJhdGNoRXJhc2VyV29ya3MuY2xlYXIoKSx0aGlzLmJhdGNoRXJhc2VyUmVtb3ZlTm9kZXMuY2xlYXIoKSx0Lmxlbmd0aCYmdGhpcy5fcG9zdCh7cmVuZGVyOnR9KX0sMTAwLHtsZWFkaW5nOiExfSl9KX1jb25zdW1lRHJhdyhlLHQpe2NvbnN0e29wOm4sd29ya0lkOml9PWU7aWYobiE9bnVsbCYmbi5sZW5ndGgmJmkpe2NvbnN0IGY9dGhpcy53b3JrU2hhcGVzLmdldChpKTtpZighZilyZXR1cm47Y29uc3QgaD1mLnRvb2xzVHlwZTtpZihoPT09THQuTGFzZXJQZW4pcmV0dXJuO2NvbnN0IHU9Zi5jb25zdW1lKHtkYXRhOmUsaXNGdWxsV29yazohMH0pO3N3aXRjaChoKXtjYXNlIEx0LlNlbGVjdG9yOnUudHlwZT09PVR0LlNlbGVjdCYmKHUuc2VsZWN0SWRzJiZ0LnJ1blJldmVyc2VTZWxlY3RXb3JrKHUuc2VsZWN0SWRzKSx0aGlzLmRyYXdTZWxlY3Rvcih1LCEwKSk7YnJlYWs7Y2FzZSBMdC5FcmFzZXI6dSE9bnVsbCYmdS5yZWN0JiZ0aGlzLmRyYXdFcmFzZXIodSk7YnJlYWs7Y2FzZSBMdC5BcnJvdzpjYXNlIEx0LlN0cmFpZ2h0OmNhc2UgTHQuRWxsaXBzZTpjYXNlIEx0LlJlY3RhbmdsZTpjYXNlIEx0LlN0YXI6Y2FzZSBMdC5Qb2x5Z29uOmNhc2UgTHQuU3BlZWNoQmFsbG9vbjp1JiYodGhpcy5kcmF3Q291bnQrKyx0aGlzLmRyYXdQZW5jaWwodSkpO2JyZWFrO2Nhc2UgTHQuUGVuY2lsOnRoaXMuY29tYmluZVRpbWVySWR8fCh0aGlzLmNvbWJpbmVUaW1lcklkPXNldFRpbWVvdXQoKCk9Pnt0aGlzLmNvbWJpbmVUaW1lcklkPXZvaWQgMCx0aGlzLmRyYXdQZW5jaWxDb21iaW5lKGkpfSxNYXRoLmZsb29yKGYuZ2V0V29ya09wdGlvbnMoKS5zeW5jVW5pdFRpbWV8fHRoaXMuY29tYmluZVVuaXRUaW1lLzIpKSksdSYmKHRoaXMuZHJhd0NvdW50KyssdGhpcy5kcmF3UGVuY2lsKHUpKTticmVha319fWNvbnN1bWVEcmF3QWxsKGUsdCl7dmFyIGY7dGhpcy5jb21iaW5lVGltZXJJZCYmKGNsZWFyVGltZW91dCh0aGlzLmNvbWJpbmVUaW1lcklkKSx0aGlzLmNvbWJpbmVUaW1lcklkPXZvaWQgMCk7Y29uc3R7d29ya0lkOm4sdW5kb1RpY2tlcklkOml9PWU7aWYobil7aSYmc2V0VGltZW91dCgoKT0+e3RoaXMuX3Bvc3Qoe3NwOlt7dHlwZTpUdC5Ob25lLHVuZG9UaWNrZXJJZDppfV19KX0sMCk7Y29uc3QgaD10aGlzLndvcmtTaGFwZXMuZ2V0KG4pO2lmKCFoKXJldHVybjtjb25zdCB1PWgudG9vbHNUeXBlO2lmKHU9PT1MdC5MYXNlclBlbilyZXR1cm47Y29uc3QgYT1oLmNvbnN1bWVBbGwoe2RhdGE6ZX0pLGQ9dGhpcy53b3JrU2hhcGVTdGF0ZS5nZXQobik7c3dpdGNoKHUpe2Nhc2UgTHQuU2VsZWN0b3I6YS5zZWxlY3RJZHMmJnQucnVuUmV2ZXJzZVNlbGVjdFdvcmsoYS5zZWxlY3RJZHMpLHRoaXMuZHJhd1NlbGVjdG9yKGEsITEpLChmPWguc2VsZWN0SWRzKSE9bnVsbCYmZi5sZW5ndGg/aC5jbGVhclRtcFBvaW50cygpOnRoaXMuY2xlYXJXb3JrU2hhcGVOb2RlQ2FjaGUobik7YnJlYWs7Y2FzZSBMdC5FcmFzZXI6YSE9bnVsbCYmYS5yZWN0JiZ0aGlzLmRyYXdFcmFzZXIoYSksaC5jbGVhclRtcFBvaW50cygpO2JyZWFrO2Nhc2UgTHQuQXJyb3c6Y2FzZSBMdC5TdHJhaWdodDpjYXNlIEx0LkVsbGlwc2U6Y2FzZSBMdC5SZWN0YW5nbGU6Y2FzZSBMdC5TdGFyOmNhc2UgTHQuUG9seWdvbjpjYXNlIEx0LlNwZWVjaEJhbGxvb246dGhpcy5kcmF3UGVuY2lsRnVsbChhLGguZ2V0V29ya09wdGlvbnMoKSxkKSx0aGlzLmRyYXdDb3VudD0wLHRoaXMuY2xlYXJXb3JrU2hhcGVOb2RlQ2FjaGUobik7YnJlYWs7Y2FzZSBMdC5QZW5jaWw6YSE9bnVsbCYmYS5yZWN0JiYodGhpcy5kcmF3UGVuY2lsRnVsbChhLGguZ2V0V29ya09wdGlvbnMoKSxkKSx0aGlzLmRyYXdDb3VudD0wKSx0aGlzLmNsZWFyV29ya1NoYXBlTm9kZUNhY2hlKG4pO2JyZWFrfX19Y29uc3VtZUZ1bGwoZSl7dmFyIGYsaDtjb25zdCB0PXRoaXMuc2V0RnVsbFdvcmsoZSksbj1lLm9wcyYmc2koZS5vcHMpLGk9KGY9ZS53b3JrSWQpPT1udWxsP3ZvaWQgMDpmLnRvU3RyaW5nKCk7aWYoaSYmdCl7Y29uc3QgdT0oaD10aGlzLnZOb2Rlcy5nZXQoaSkpPT1udWxsP3ZvaWQgMDpoLnJlY3Q7bGV0IGE9dC5jb25zdW1lU2VydmljZSh7b3A6bixpc0Z1bGxXb3JrOiEwLHJlcGxhY2VJZDppfSk7Y29uc3QgZD0oZT09bnVsbD92b2lkIDA6ZS51cGRhdGVOb2RlT3B0KSYmdC51cGRhdGFPcHRTZXJ2aWNlKGUudXBkYXRlTm9kZU9wdCk7aWYoYT0kdChhLGQpLGEmJmUud2lsbFJlZnJlc2gpe2NvbnN0IEU9W107dSYmRS5wdXNoKHtyZWN0OmEsaXNDbGVhcjohMCxjbGVhckNhbnZhczpCdC5CZyxpc0Z1bGxXb3JrOiEwLHZpZXdJZDp0aGlzLnZpZXdJZH0pLEUucHVzaCh7cmVjdDphLGRyYXdDYW52YXM6QnQuQmcsaXNGdWxsV29yazohMCx2aWV3SWQ6dGhpcy52aWV3SWR9KTtjb25zdCBwPXtyZW5kZXI6RSxzcDplLndpbGxTeW5jU2VydmljZSYmW3tvcHQ6ZS5vcHQsdG9vbHNUeXBlOmUudG9vbHNUeXBlLHR5cGU6VHQuRnVsbFdvcmssd29ya0lkOmUud29ya0lkLG9wczplLm9wcyx1cGRhdGVOb2RlT3B0OmUudXBkYXRlTm9kZU9wdCx1bmRvVGlja2VySWQ6ZS51bmRvVGlja2VySWQsdmlld0lkOnRoaXMudmlld0lkfV18fHZvaWQgMH07dGhpcy5fcG9zdChwKX1lLndvcmtJZCYmdGhpcy53b3JrU2hhcGVzLmRlbGV0ZShlLndvcmtJZCl9fXJlbW92ZVdvcmsoZSl7Y29uc3R7d29ya0lkOnR9PWUsbj10PT1udWxsP3ZvaWQgMDp0LnRvU3RyaW5nKCk7aWYobil7Y29uc3QgaT10aGlzLnJlbW92ZU5vZGUobik7aSYmdGhpcy5fcG9zdCh7cmVuZGVyOlt7cmVjdDppLGlzQ2xlYXI6ITAsaXNGdWxsV29yazohMCxjbGVhckNhbnZhczpCdC5CZyxkcmF3Q2FudmFzOkJ0LkJnLHZpZXdJZDp0aGlzLnZpZXdJZH1dfSl9fXJlbW92ZU5vZGUoZSl7dmFyIGk7dGhpcy53b3JrU2hhcGVzLmhhcyhlKSYmdGhpcy5jbGVhcldvcmtTaGFwZU5vZGVDYWNoZShlKTtsZXQgdDtjb25zdCBuPXRoaXMudk5vZGVzLmdldChlKTtyZXR1cm4gbiYmKHRoaXMuZnVsbExheWVyLmdldEVsZW1lbnRzQnlOYW1lKGUpLmNvbmNhdCgoKGk9dGhpcy5kcmF3TGF5ZXIpPT1udWxsP3ZvaWQgMDppLmdldEVsZW1lbnRzQnlOYW1lKGUpKXx8W10pLmZvckVhY2goZj0+e2YucmVtb3ZlKCl9KSx0PSR0KHQsbi5yZWN0KSx0aGlzLnZOb2Rlcy5kZWxldGUoZSkpLHR9Y2hlY2tUZXh0QWN0aXZlKGUpe3ZhciBuO2NvbnN0e29wOnR9PWU7aWYodCE9bnVsbCYmdC5sZW5ndGgpe2xldCBpO2Zvcihjb25zdCBmIG9mIHRoaXMudk5vZGVzLmN1ck5vZGVNYXAudmFsdWVzKCkpe2NvbnN0e3JlY3Q6aCxuYW1lOnUsdG9vbHNUeXBlOmF9PWYsZD10WzBdKnRoaXMuZnVsbExheWVyLndvcmxkU2NhbGluZ1swXSt0aGlzLmZ1bGxMYXllci53b3JsZFBvc2l0aW9uWzBdLEU9dFsxXSp0aGlzLmZ1bGxMYXllci53b3JsZFNjYWxpbmdbMV0rdGhpcy5mdWxsTGF5ZXIud29ybGRQb3NpdGlvblsxXTtpZihhPT09THQuVGV4dCYmaG0oW2QsRV0saCkpe2k9dTticmVha319aWYoaSl7Y29uc3QgZj10aGlzLndvcmtTaGFwZXMuZ2V0KGllLnNlbGVjdG9ySWQpO2YmJigobj1mLnNlbGVjdElkcykhPW51bGwmJm4uaW5jbHVkZXMoaSkpJiZ0aGlzLmJsdXJTZWxlY3RvcigpLHRoaXMuX3Bvc3Qoe3NwOlt7dHlwZTpUdC5HZXRUZXh0QWN0aXZlLHRvb2xzVHlwZTpMdC5UZXh0LHdvcmtJZDppfV19KX19fWNvbGxvY3RFZmZlY3RTZWxlY3RXb3JrKGUpe2NvbnN0IHQ9dGhpcy53b3JrU2hhcGVzLmdldChpZS5zZWxlY3RvcklkKSx7d29ya0lkOm59PWU7aWYodCYmbiYmdC5zZWxlY3RJZHMmJnQuc2VsZWN0SWRzLmluY2x1ZGVzKG4udG9TdHJpbmcoKSkpe3RoaXMuZWZmZWN0U2VsZWN0Tm9kZURhdGEuYWRkKGUpLHNldFRpbWVvdXQoKCk9Pnt2YXIgaTt0aGlzLnJ1bkVmZmVjdFNlbGVjdFdvcmsoKSwoaT10aGlzLmVmZmVjdFNlbGVjdE5vZGVEYXRhKT09bnVsbHx8aS5jbGVhcigpfSwwKTtyZXR1cm59cmV0dXJuIGV9dXBkYXRlU2VsZWN0b3IoZSl7dmFyIHk7Y29uc3QgdD10aGlzLndvcmtTaGFwZXMuZ2V0KGllLnNlbGVjdG9ySWQpO2lmKCEoKHk9dD09bnVsbD92b2lkIDA6dC5zZWxlY3RJZHMpIT1udWxsJiZ5Lmxlbmd0aCkpcmV0dXJuO2NvbnN0e3VwZGF0ZVNlbGVjdG9yT3B0Om4sd2lsbFJlZnJlc2hTZWxlY3RvcjppLHdpbGxTeW5jU2VydmljZTpmLHdpbGxTZXJpYWxpemVEYXRhOmgsZW1pdEV2ZW50VHlwZTp1LGlzU3luYzphLHRleHRVcGRhdGVGb3JXb2tlcjpkfT1lLEU9bi53b3JrU3RhdGUscD10PT1udWxsP3ZvaWQgMDp0LnVwZGF0ZVNlbGVjdG9yKHt1cGRhdGVTZWxlY3Rvck9wdDpuLHNlbGVjdElkczp0LnNlbGVjdElkcyx2Tm9kZXM6dGhpcy52Tm9kZXMsd2lsbFNlcmlhbGl6ZURhdGE6aCx3b3JrZXI6dGhpc30pLE89cD09bnVsbD92b2lkIDA6cC5zZWxlY3RSZWN0LG09bmV3IE1hcDtpZih0LnNlbGVjdElkcy5mb3JFYWNoKFM9Pntjb25zdCBzPXRoaXMudk5vZGVzLmdldChTKTtpZihzKXtjb25zdHt0b29sc1R5cGU6YyxvcDpsLG9wdDp2fT1zO20uc2V0KFMse29wdDp2LHRvb2xzVHlwZTpjLG9wczoobD09bnVsbD92b2lkIDA6bC5sZW5ndGgpJiZ5cihsKXx8dm9pZCAwfSl9fSksdT09PW9lLlRyYW5zbGF0ZU5vZGUmJkU9PT1jZS5TdGFydClyZXR1cm47Y29uc3QgYj1bXSxNPVtdO2lmKGkpe2IucHVzaCh7aXNDbGVhckFsbDohMCxpc0Z1bGxXb3JrOiExLGNsZWFyQ2FudmFzOkJ0LlNlbGVjdG9yLHZpZXdJZDp0aGlzLnZpZXdJZH0pO2NvbnN0IFM9e3JlY3Q6Tyxpc0Z1bGxXb3JrOiExLGRyYXdDYW52YXM6QnQuU2VsZWN0b3Isdmlld0lkOnRoaXMudmlld0lkfTtuLnRyYW5zbGF0ZSYmdT09PW9lLlRyYW5zbGF0ZU5vZGUmJkU9PT1jZS5Eb2luZyYmKFMudHJhbnNsYXRlPW4udHJhbnNsYXRlKSxiLnB1c2goUyl9aWYoZil7aD8odT09PW9lLlJvdGF0ZU5vZGUmJkU9PT1jZS5Eb25lJiZNLnB1c2goe3R5cGU6VHQuU2VsZWN0LHNlbGVjdElkczp0LnNlbGVjdElkcyxzZWxlY3RSZWN0Ok8sd2lsbFN5bmNTZXJ2aWNlOiEwLGlzU3luYzphfSksdT09PW9lLlNjYWxlTm9kZSYmRT09PWNlLkRvbmUmJk0ucHVzaCh7dHlwZTpUdC5TZWxlY3Qsc2VsZWN0SWRzOnQuc2VsZWN0SWRzLHNlbGVjdFJlY3Q6Tyx3aWxsU3luY1NlcnZpY2U6ITEsaXNTeW5jOmF9KSk6dT09PW9lLlNjYWxlTm9kZSYmRT09PWNlLlN0YXJ0JiZNLnB1c2goe3R5cGU6VHQuU2VsZWN0LHNlbGVjdElkczp0LnNlbGVjdElkcyxzZWxlY3RSZWN0Ok8sY2FudmFzV2lkdGg6dGhpcy5mdWxsTGF5ZXIucGFyZW50LndpZHRoLGNhbnZhc0hlaWdodDp0aGlzLmZ1bGxMYXllci5wYXJlbnQuaGVpZ2h0LHdpbGxTeW5jU2VydmljZTohMX0pO2Zvcihjb25zdFtTLHNdb2YgbS5lbnRyaWVzKCkpZCYmcy50b29sc1R5cGU9PT1MdC5UZXh0P00ucHVzaCh7Li4ucyx3b3JrSWQ6Uyx0eXBlOlR0LlRleHRVcGRhdGV9KTpNLnB1c2goey4uLnMsd29ya0lkOlMsdHlwZTpUdC5VcGRhdGVOb2RlLHVwZGF0ZU5vZGVPcHQ6e3VzZUFuaW1hdGlvbjohMX0saXNTeW5jOmF9KX0oYi5sZW5ndGh8fE0ubGVuZ3RoKSYmdGhpcy5fcG9zdCh7cmVuZGVyOmIsc3A6TX0pfWJsdXJTZWxlY3RvcihlKXt2YXIgaTtjb25zdCB0PXRoaXMud29ya1NoYXBlcy5nZXQoaWUuc2VsZWN0b3JJZCksbj10PT1udWxsP3ZvaWQgMDp0LmJsdXJTZWxlY3RvcigpO2lmKHRoaXMuY2xlYXJXb3JrU2hhcGVOb2RlQ2FjaGUoaWUuc2VsZWN0b3JJZCksKChpPXRoaXMuZHJhd0xheWVyKT09bnVsbD92b2lkIDA6aS5wYXJlbnQpLmNoaWxkcmVuLmZvckVhY2goZj0+e2YubmFtZT09PWllLnNlbGVjdG9ySWQmJmYucmVtb3ZlKCl9KSxuKXtjb25zdCBmPVtuXTtlIT1udWxsJiZlLnVuZG9UaWNrZXJJZCYmZi5wdXNoKHt0eXBlOlR0LlNlbGVjdCxzZWxlY3RJZHM6W10sdW5kb1RpY2tlcklkOmUudW5kb1RpY2tlcklkfSksdGhpcy5fcG9zdCh7cmVuZGVyOihuPT1udWxsP3ZvaWQgMDpuLnJlY3QpJiZbe3JlY3Q6bi5yZWN0LGRyYXdDYW52YXM6QnQuQmcsaXNDbGVhcjohMCxjbGVhckNhbnZhczpCdC5CZyxpc0Z1bGxXb3JrOiEwLHZpZXdJZDp0aGlzLnZpZXdJZH1dLHNwOmZ9KX19cnVuRWZmZWN0V29yayhlKXt0aGlzLmJhdGNoRWZmZWN0V29yayhlKX1yZVJlbmRlclNlbGVjdG9yKCl7dmFyIHQ7Y29uc3QgZT10aGlzLndvcmtTaGFwZXMuZ2V0KGllLnNlbGVjdG9ySWQpO2lmKCh0PWU9PW51bGw/dm9pZCAwOmUuc2VsZWN0SWRzKSE9bnVsbCYmdC5sZW5ndGgmJnRoaXMuZHJhd0xheWVyKXtjb25zdCBuPWUucmVSZW5kZXJTZWxlY3RvcigpO24mJnRoaXMuX3Bvc3Qoe3JlbmRlcjpbe3JlY3Q6bixpc0NsZWFyOiEwLGlzRnVsbFdvcms6ITEsY2xlYXJDYW52YXM6QnQuU2VsZWN0b3IsZHJhd0NhbnZhczpCdC5TZWxlY3Rvcix2aWV3SWQ6dGhpcy52aWV3SWR9XSxzcDpbe3R5cGU6VHQuU2VsZWN0LHNlbGVjdElkczplLnNlbGVjdElkcyxzZWxlY3RSZWN0Om4sd2lsbFN5bmNTZXJ2aWNlOiExLHZpZXdJZDp0aGlzLnZpZXdJZH1dfSl9fXVwZGF0ZUZ1bGxTZWxlY3RXb3JrKGUpe3ZhciBpLGYsaCx1LGEsZCxFO2NvbnN0IHQ9dGhpcy53b3JrU2hhcGVzLmdldChpZS5zZWxlY3RvcklkKSx7c2VsZWN0SWRzOm59PWU7aWYoIShuIT1udWxsJiZuLmxlbmd0aCkpe3RoaXMuYmx1clNlbGVjdG9yKGUpO3JldHVybn1pZighdCl7dGhpcy5zZXRGdWxsV29yayhlKSx0aGlzLnVwZGF0ZUZ1bGxTZWxlY3RXb3JrKGUpO3JldHVybn1pZih0JiYobiE9bnVsbCYmbi5sZW5ndGgpKXtjb25zdHtiZ1JlY3Q6cCxzZWxlY3RSZWN0Ok99PXQudXBkYXRlU2VsZWN0SWRzKG4pLG09e3JlbmRlcjpbXSxzcDpbXX07cCYmKChpPW0ucmVuZGVyKT09bnVsbHx8aS5wdXNoKHtyZWN0OnAsaXNDbGVhcjohMCxpc0Z1bGxXb3JrOiEwLGNsZWFyQ2FudmFzOkJ0LkJnLGRyYXdDYW52YXM6QnQuQmcsdmlld0lkOnRoaXMudmlld0lkfSkpLChmPW0ucmVuZGVyKT09bnVsbHx8Zi5wdXNoKHtyZWN0OnB8fE8saXNDbGVhcjohMCxpc0Z1bGxXb3JrOiExLGNsZWFyQ2FudmFzOkJ0LlNlbGVjdG9yLGRyYXdDYW52YXM6QnQuU2VsZWN0b3Isdmlld0lkOnRoaXMudmlld0lkfSksKEU9bS5zcCk9PW51bGx8fEUucHVzaCh7Li4uZSxzZWxlY3RvckNvbG9yOihoPWUub3B0KT09bnVsbD92b2lkIDA6aC5zdHJva2VDb2xvcixzdHJva2VDb2xvcjoodT1lLm9wdCk9PW51bGw/dm9pZCAwOnUuc3Ryb2tlQ29sb3IsZmlsbENvbG9yOihhPWUub3B0KT09bnVsbD92b2lkIDA6YS5maWxsQ29sb3IsdGV4dE9wdDooZD1lLm9wdCk9PW51bGw/dm9pZCAwOmQudGV4dE9wdCxjYW5UZXh0RWRpdDp0LmNhblRleHRFZGl0LGNhblJvdGF0ZTp0LmNhblJvdGF0ZSxzY2FsZVR5cGU6dC5zY2FsZVR5cGUsdHlwZTpUdC5TZWxlY3Qsc2VsZWN0UmVjdDpwfHxPLHdpbGxTeW5jU2VydmljZTohMX0pLHRoaXMuX3Bvc3QobSl9fWRlc3Ryb3koKXtzdXBlci5kZXN0cm95KCksdGhpcy5lZmZlY3RTZWxlY3ROb2RlRGF0YS5jbGVhcigpLHRoaXMuYmF0Y2hFcmFzZXJXb3Jrcy5jbGVhcigpLHRoaXMuYmF0Y2hFcmFzZXJSZW1vdmVOb2Rlcy5jbGVhcigpfWRyYXdQZW5jaWxDb21iaW5lKGUpe3ZhciBuLGk7Y29uc3QgdD0obj10aGlzLndvcmtTaGFwZXMuZ2V0KGUpKT09bnVsbD92b2lkIDA6bi5jb21iaW5lQ29uc3VtZSgpO2lmKHQpe2NvbnN0IGY9e3JlbmRlcjpbXSxkcmF3Q291bnQ6dGhpcy5kcmF3Q291bnR9OyhpPWYucmVuZGVyKT09bnVsbHx8aS5wdXNoKHtyZWN0OnQ9PW51bGw/dm9pZCAwOnQucmVjdCxpc0NsZWFyOiEwLGRyYXdDYW52YXM6QnQuRmxvYXQsY2xlYXJDYW52YXM6QnQuRmxvYXQsaXNGdWxsV29yazohMSx2aWV3SWQ6dGhpcy52aWV3SWR9KSx0aGlzLl9wb3N0KGYpfX1kcmF3U2VsZWN0b3IoZSx0KXt2YXIgaSxmLGg7Y29uc3Qgbj17cmVuZGVyOltdLHNwOltlXX07KGk9ZS5zZWxlY3RJZHMpIT1udWxsJiZpLmxlbmd0aCYmIXQmJigoZj1uLnJlbmRlcik9PW51bGx8fGYucHVzaCh7cmVjdDplLnNlbGVjdFJlY3QsZHJhd0NhbnZhczpCdC5TZWxlY3Rvcixpc0NsZWFyOiEwLGNsZWFyQ2FudmFzOkJ0LlNlbGVjdG9yLGlzRnVsbFdvcms6ITEsdmlld0lkOnRoaXMudmlld0lkfSx7cmVjdDplLnJlY3QsaXNDbGVhcjohMCxjbGVhckNhbnZhczpCdC5GbG9hdCxpc0Z1bGxXb3JrOiExLHZpZXdJZDp0aGlzLnZpZXdJZH0se3JlY3Q6ZS5yZWN0LGRyYXdDYW52YXM6QnQuQmcsaXNDbGVhcjohMCxjbGVhckNhbnZhczpCdC5CZyxpc0Z1bGxXb3JrOiEwLHZpZXdJZDp0aGlzLnZpZXdJZH0pKSx0JiYoKGg9bi5yZW5kZXIpPT1udWxsfHxoLnB1c2goe3JlY3Q6ZS5yZWN0LGRyYXdDYW52YXM6QnQuRmxvYXQsaXNDbGVhcjohMCxjbGVhckNhbnZhczpCdC5GbG9hdCxpc0Z1bGxXb3JrOiExLHZpZXdJZDp0aGlzLnZpZXdJZH0se3JlY3Q6ZS5yZWN0LGRyYXdDYW52YXM6QnQuQmcsaXNDbGVhcjohMCxjbGVhckNhbnZhczpCdC5CZyxpc0Z1bGxXb3JrOiEwLHZpZXdJZDp0aGlzLnZpZXdJZH0pKSx0aGlzLl9wb3N0KG4pfWFzeW5jIGRyYXdFcmFzZXIoZSl7dmFyIG4saTtjb25zdCB0PVtdO2lmKChuPWUubmV3V29ya0RhdGFzKSE9bnVsbCYmbi5zaXplKXtmb3IoY29uc3QgZiBvZiBlLm5ld1dvcmtEYXRhcy52YWx1ZXMoKSl7Y29uc3QgaD1mLndvcmtJZC50b1N0cmluZygpO3RoaXMuYmF0Y2hFcmFzZXJXb3Jrcy5hZGQoaCksdC5wdXNoKHt0eXBlOlR0LkZ1bGxXb3JrLHdvcmtJZDpoLG9wczp5cihmLm9wKSxvcHQ6Zi5vcHQsdG9vbHNUeXBlOmYudG9vbHNUeXBlLHVwZGF0ZU5vZGVPcHQ6e3VzZUFuaW1hdGlvbjohMX19KX1kZWxldGUgZS5uZXdXb3JrRGF0YXN9KGk9ZS5yZW1vdmVJZHMpPT1udWxsfHxpLmZvckVhY2goZj0+e3RoaXMuYmF0Y2hFcmFzZXJSZW1vdmVOb2Rlcy5hZGQoZil9KSx0LnB1c2goZSksdGhpcy5fcG9zdCh7c3A6dH0pLHRoaXMuYmF0Y2hFcmFzZXJDb21iaW5lKCl9ZHJhd1BlbmNpbChlKXt0aGlzLl9wb3N0KHtkcmF3Q291bnQ6dGhpcy5kcmF3Q291bnQsc3A6KGU9PW51bGw/dm9pZCAwOmUub3ApJiZbZV19KX1kcmF3UGVuY2lsRnVsbChlLHQsbil7dmFyIGY7Y29uc3QgaT17ZHJhd0NvdW50OjEvMCxyZW5kZXI6W3tyZWN0OmUucmVjdCxkcmF3Q2FudmFzOkJ0LkJnLGlzQ2xlYXI6KG49PW51bGw/dm9pZCAwOm4ud2lsbENsZWFyKXx8KHQ9PW51bGw/dm9pZCAwOnQuaXNPcGFjaXR5KSxjbGVhckNhbnZhczpCdC5CZyxpc0Z1bGxXb3JrOiEwLHZpZXdJZDp0aGlzLnZpZXdJZH1dLHNwOltlXX07KGY9aS5yZW5kZXIpPT1udWxsfHxmLnB1c2goe2lzQ2xlYXJBbGw6ITAsY2xlYXJDYW52YXM6QnQuRmxvYXQsaXNGdWxsV29yazohMSx2aWV3SWQ6dGhpcy52aWV3SWR9KSx0aGlzLl9wb3N0KGkpfXVwZGF0ZUJhdGNoRXJhc2VyQ29tYmluZU5vZGUoZSx0KXtjb25zdCBuPVtdO2xldCBpO2Zvcihjb25zdCBmIG9mIHQua2V5cygpKXRoaXMuZnVsbExheWVyLmdldEVsZW1lbnRzQnlOYW1lKGYpLmZvckVhY2goaD0+e2NvbnN0IHU9aC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtpPSR0KGkse3g6dS54LWxyLlNhZmVCb3JkZXJQYWRkaW5nLHk6dS55LWxyLlNhZmVCb3JkZXJQYWRkaW5nLHc6dS53aWR0aCtsci5TYWZlQm9yZGVyUGFkZGluZyxoOnUuaGVpZ2h0K2xyLlNhZmVCb3JkZXJQYWRkaW5nfSksaC5yZW1vdmUoKX0pO3JldHVybiBlLmZvckVhY2goZj0+e2NvbnN0IGg9dGhpcy52Tm9kZXMuZ2V0KGYpO2lmKGgpaWYodGhpcy5mdWxsTGF5ZXIuZ2V0RWxlbWVudHNCeU5hbWUoZilbMF0paT0kdChpLGgucmVjdCk7ZWxzZXtjb25zdCBhPXRoaXMuc2V0RnVsbFdvcmsoey4uLmgsd29ya0lkOmZ9KSxkPWEmJmEuY29uc3VtZVNlcnZpY2Uoe29wOmgub3AsaXNGdWxsV29yazohMH0pO2QmJihoLnJlY3Q9ZCxpPSR0KGksZCkpfX0pLGkmJm4ucHVzaCh7cmVjdDppLGlzQ2xlYXI6ITAsaXNGdWxsV29yazohMCxjbGVhckNhbnZhczpCdC5CZyxkcmF3Q2FudmFzOkJ0LkJnLHZpZXdJZDp0aGlzLnZpZXdJZH0pLG59cnVuRWZmZWN0U2VsZWN0V29yaygpe3ZhciBlO2Zvcihjb25zdCB0IG9mIHRoaXMuZWZmZWN0U2VsZWN0Tm9kZURhdGEudmFsdWVzKCkpe2NvbnN0IG49dGhpcy5zZXRGdWxsV29yayh0KSxpPXQub3BzJiZzaSh0Lm9wcyk7biYmKG4uY29uc3VtZVNlcnZpY2Uoe29wOmksaXNGdWxsV29yazohMSxyZXBsYWNlSWQ6KGU9bi5nZXRXb3JrSWQoKSk9PW51bGw/dm9pZCAwOmUudG9TdHJpbmcoKX0pLHQhPW51bGwmJnQudXBkYXRlTm9kZU9wdCYmbi51cGRhdGFPcHRTZXJ2aWNlKHQudXBkYXRlTm9kZU9wdCksdC53b3JrSWQmJnRoaXMud29ya1NoYXBlcy5kZWxldGUodC53b3JrSWQpKX10aGlzLnJlUmVuZGVyU2VsZWN0b3IoKX19Y2xhc3MgbXl7Y29uc3RydWN0b3IoZSl7T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInZpZXdJZCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ2Tm9kZXMiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiZnVsbExheWVyIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImRyYXdMYXllciIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ3b3JrU2hhcGVzIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6bmV3IE1hcH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJhbmltYXRpb25JZCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzZWxlY3RvcldvcmtTaGFwZXMiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpuZXcgTWFwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIndpbGxSdW5FZmZlY3RTZWxlY3RvcklkcyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOm5ldyBTZXR9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywicnVuRWZmZWN0SWQiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywibm9BbmltYXRpb25SZWN0Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInBvc3QiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSx0aGlzLnZpZXdJZD1lLnZpZXdJZCx0aGlzLnZOb2Rlcz1lLnZOb2Rlcyx0aGlzLmZ1bGxMYXllcj1lLmZ1bGxMYXllcix0aGlzLmRyYXdMYXllcj1lLmRyYXdMYXllcix0aGlzLnBvc3Q9ZS5wb3N0fWRlc3Ryb3koKXt0aGlzLndvcmtTaGFwZXMuY2xlYXIoKSx0aGlzLnNlbGVjdG9yV29ya1NoYXBlcy5jbGVhcigpLHRoaXMud2lsbFJ1bkVmZmVjdFNlbGVjdG9ySWRzLmNsZWFyKCl9Y29uc3VtZURyYXcoZSl7dGhpcy5hY3RpdmVXb3JrU2hhcGUoZSksdGhpcy5ydW5BbmltYXRpb24oKX1jb25zdW1lRnVsbChlKXt0aGlzLmFjdGl2ZVdvcmtTaGFwZShlKSx0aGlzLnJ1bkFuaW1hdGlvbigpfWNsZWFyQWxsV29ya1NoYXBlc0NhY2hlKCl7dGhpcy53b3JrU2hhcGVzLmZvckVhY2goKGUsdCk9PntlLnRvb2xzVHlwZT09PUx0Lkxhc2VyUGVuP3NldFRpbWVvdXQoKCk9Pnt0aGlzLndvcmtTaGFwZXMuZGVsZXRlKHQpfSwyZTMpOnRoaXMud29ya1NoYXBlcy5kZWxldGUodCl9KX1ydW5TZWxlY3RXb3JrKGUpe3RoaXMuYWN0aXZlU2VsZWN0b3JTaGFwZShlKTtjb25zdHt3b3JrSWQ6dH09ZSxuPXQ9PW51bGw/dm9pZCAwOnQudG9TdHJpbmcoKTtuJiZ0aGlzLndpbGxSdW5FZmZlY3RTZWxlY3Rvcklkcy5hZGQobiksdGhpcy5ydW5FZmZlY3QoKX1zZXROb2RlS2V5KGUsdCxuKXtyZXR1cm4gZS50b29sc1R5cGU9dCxlLm5vZGU9WmEoe3Rvb2xzVHlwZTp0LHRvb2xzT3B0Om4sdk5vZGVzOnRoaXMudk5vZGVzLGZ1bGxMYXllcjp0aGlzLmZ1bGxMYXllcixkcmF3TGF5ZXI6dGhpcy5kcmF3TGF5ZXJ9KSxlfXJ1blJldmVyc2VTZWxlY3RXb3JrKGUpe2UuZm9yRWFjaCh0PT57dGhpcy5zZWxlY3RvcldvcmtTaGFwZXMuZm9yRWFjaCgobixpKT0+e3ZhciBmO2lmKChmPW4uc2VsZWN0SWRzKSE9bnVsbCYmZi5sZW5ndGgpe2NvbnN0IGg9bi5zZWxlY3RJZHMuaW5kZXhPZih0KTtoPi0xJiYobi5zZWxlY3RJZHMuc3BsaWNlKGgsMSksdGhpcy53aWxsUnVuRWZmZWN0U2VsZWN0b3JJZHMuYWRkKGkpKX19KX0pLHRoaXMud2lsbFJ1bkVmZmVjdFNlbGVjdG9ySWRzLnNpemUmJnRoaXMucnVuRWZmZWN0KCl9cmVtb3ZlV29yayhlKXtjb25zdHt3b3JrSWQ6dH09ZSxuPXQ9PW51bGw/dm9pZCAwOnQudG9TdHJpbmcoKTtpZihuKXtjb25zdCBpPXRoaXMud29ya1NoYXBlcy5nZXQobik7aWYoaSl7dGhpcy53b3JrU2hhcGVzLmRlbGV0ZShuKSx0aGlzLnJlbW92ZU5vZGUobixlLGk9PW51bGw/dm9pZCAwOmkudG90YWxSZWN0LCExKTtyZXR1cm59dGhpcy5yZW1vdmVOb2RlKG4sZSl9fXJlbW92ZVNlbGVjdFdvcmsoZSl7Y29uc3R7d29ya0lkOnR9PWUsbj10PT1udWxsP3ZvaWQgMDp0LnRvU3RyaW5nKCk7biYmKHRoaXMuYWN0aXZlU2VsZWN0b3JTaGFwZShlKSx0aGlzLndpbGxSdW5FZmZlY3RTZWxlY3Rvcklkcy5hZGQobikpLHRoaXMucnVuRWZmZWN0KCl9cmVtb3ZlTm9kZShlLHQsbixpPSEwKXt2YXIgZDtjb25zdCBmPXRoaXMuZnVsbExheWVyLmdldEVsZW1lbnRzQnlOYW1lKGUpLmNvbmNhdCh0aGlzLmRyYXdMYXllci5nZXRFbGVtZW50c0J5TmFtZShlKSk7ZS5pbmRleE9mKGllLnNlbGVjdG9ySWQpPi0xJiZ0aGlzLnJlbW92ZVNlbGVjdFdvcmsodCk7Y29uc3QgaD1bXTtsZXQgdT1uO2NvbnN0IGE9KGQ9dGhpcy52Tm9kZXMuZ2V0KGUpKT09bnVsbD92b2lkIDA6ZC5yZWN0O2EmJih1PSR0KGEsdSkpLGYuZm9yRWFjaChFPT57aC5wdXNoKEUpfSksaC5sZW5ndGgmJmguZm9yRWFjaChFPT5FLnJlbW92ZSgpKSx1JiYodGhpcy5wb3N0KHtyZW5kZXI6W3tyZWN0OmxuKHUpLGlzQ2xlYXI6ITAsaXNGdWxsV29yazppLGNsZWFyQ2FudmFzOmk/QnQuQmc6QnQuRmxvYXQsZHJhd0NhbnZhczppP0J0LkJnOkJ0LkZsb2F0LHZpZXdJZDp0aGlzLnZpZXdJZH1dfSksdGhpcy52Tm9kZXMuZGVsZXRlKGUpKX1hY3RpdmVXb3JrU2hhcGUoZSl7dmFyIE8sbSxiLE07Y29uc3R7d29ya0lkOnQsb3B0Om4sdG9vbHNUeXBlOmksdHlwZTpmLHVwZGF0ZU5vZGVPcHQ6aCxvcHM6dSxvcDphLHVzZUFuaW1hdGlvbjpkfT1lO2lmKCF0KXJldHVybjtjb25zdCBFPXQudG9TdHJpbmcoKTtpZighKChPPXRoaXMud29ya1NoYXBlcykhPW51bGwmJk8uaGFzKEUpKSl7bGV0IHk9e3Rvb2xzVHlwZTppLGFuaW1hdGlvbldvcmtEYXRhOmF8fFtdLGFuaW1hdGlvbkluZGV4OjAsdHlwZTpmLHVwZGF0ZU5vZGVPcHQ6aCxvcHM6dSx1c2VBbmltYXRpb246dHlwZW9mIGQ8InUiP2Q6dHlwZW9mKGg9PW51bGw/dm9pZCAwOmgudXNlQW5pbWF0aW9uKTwidSI/aD09bnVsbD92b2lkIDA6aC51c2VBbmltYXRpb246ITAsb2xkUmVjdDoobT10aGlzLnZOb2Rlcy5nZXQoRSkpPT1udWxsP3ZvaWQgMDptLnJlY3R9O2kmJm4mJih5PXRoaXMuc2V0Tm9kZUtleSh5LGksbikpLChiPXRoaXMud29ya1NoYXBlcyk9PW51bGx8fGIuc2V0KEUseSl9Y29uc3QgcD0oTT10aGlzLndvcmtTaGFwZXMpPT1udWxsP3ZvaWQgMDpNLmdldChFKTtmJiYocC50eXBlPWYpLHUmJihwLmFuaW1hdGlvbldvcmtEYXRhPXNpKHUpLHAub3BzPXUpLGgmJihwLnVwZGF0ZU5vZGVPcHQ9aCksYSYmKHAuYW5pbWF0aW9uV29ya0RhdGE9YSkscC5ub2RlJiZwLm5vZGUuZ2V0V29ya0lkKCkhPT1FJiZwLm5vZGUuc2V0V29ya0lkKEUpLHAudG9vbHNUeXBlIT09aSYmaSYmbiYmdGhpcy5zZXROb2RlS2V5KHAsaSxuKX1hbmltYXRpb25EcmF3KCl7dmFyIGEsZCxFLHAsTzt0aGlzLmFuaW1hdGlvbklkPXZvaWQgMDtsZXQgZT0hMTtjb25zdCB0PW5ldyBNYXAsbj1bXSxpPVtdLGY9W10saD1bXTt0aGlzLndvcmtTaGFwZXMuZm9yRWFjaCgobSxiKT0+e3ZhciBNLHksUyxzLGMsbCx2LFQsUixMLE4sQSx3LEIsRCxJLGosVixKLF8sc3QsRyxZO3N3aXRjaChtLnRvb2xzVHlwZSl7Y2FzZSBMdC5UZXh0OntpZihtLm5vZGUpe2NvbnN0IHJ0PW0ub2xkUmVjdCxvdD0oTT1tLm5vZGUpPT1udWxsP3ZvaWQgMDpNLmNvbnN1bWVTZXJ2aWNlKHtvcDptLmFuaW1hdGlvbldvcmtEYXRhfHxbXSxpc0Z1bGxXb3JrOiEwfSk7dGhpcy5zZWxlY3RvcldvcmtTaGFwZXMuZm9yRWFjaCgoYXQsaHQpPT57dmFyIGl0OyhpdD1hdC5zZWxlY3RJZHMpIT1udWxsJiZpdC5pbmNsdWRlcyhiKSYmKHRoaXMud2lsbFJ1bkVmZmVjdFNlbGVjdG9ySWRzLmFkZChodCksdGhpcy5ub0FuaW1hdGlvblJlY3Q9JHQodGhpcy5ub0FuaW1hdGlvblJlY3QscnQpLHRoaXMubm9BbmltYXRpb25SZWN0PSR0KHRoaXMubm9BbmltYXRpb25SZWN0LG90KSx0aGlzLnJ1bkVmZmVjdCgpKX0pLCh5PW0ubm9kZSk9PW51bGx8fHkuY2xlYXJUbXBQb2ludHMoKSx0aGlzLndvcmtTaGFwZXMuZGVsZXRlKGIpfWJyZWFrfWNhc2UgTHQuQXJyb3c6Y2FzZSBMdC5TdHJhaWdodDpjYXNlIEx0LlJlY3RhbmdsZTpjYXNlIEx0LkVsbGlwc2U6Y2FzZSBMdC5TdGFyOmNhc2UgTHQuUG9seWdvbjpjYXNlIEx0LlNwZWVjaEJhbGxvb246e2NvbnN0IHJ0PSEhbS5vcHM7aWYoKFM9bS5hbmltYXRpb25Xb3JrRGF0YSkhPW51bGwmJlMubGVuZ3RoKXtjb25zdCBvdD1tLm9sZFJlY3QsYXQ9bS5ub2RlLm9sZFJlY3Q7b3QmJmYucHVzaCh7cmVjdDpvdCxpc0NsZWFyOiEwLGNsZWFyQ2FudmFzOkJ0LkJnLHZpZXdJZDp0aGlzLnZpZXdJZH0pLGF0JiZoLnB1c2goe3JlY3Q6YXQsaXNDbGVhcjohMCxjbGVhckNhbnZhczpCdC5GbG9hdCx2aWV3SWQ6dGhpcy52aWV3SWR9KTtjb25zdCBodD0ocz1tLm5vZGUpPT1udWxsP3ZvaWQgMDpzLmNvbnN1bWVTZXJ2aWNlKHtvcDptLmFuaW1hdGlvbldvcmtEYXRhLGlzRnVsbFdvcms6cnR9KSxpdD17d29ya1N0YXRlOm90P20ub3BzP2NlLkRvbmU6Y2UuRG9pbmc6Y2UuU3RhcnQsb3A6bS5hbmltYXRpb25Xb3JrRGF0YS5maWx0ZXIoKE10LE90KT0+e2lmKE90JTMhPT0yKXJldHVybiEwfSkuc2xpY2UoLTIpfTt0LnNldChiLGl0KSxydD8odGhpcy5zZWxlY3RvcldvcmtTaGFwZXMuZm9yRWFjaCgoTXQsT3QpPT57dmFyIFU7KFU9TXQuc2VsZWN0SWRzKSE9bnVsbCYmVS5pbmNsdWRlcyhiKSYmKHRoaXMud2lsbFJ1bkVmZmVjdFNlbGVjdG9ySWRzLmFkZChPdCksdGhpcy5ub0FuaW1hdGlvblJlY3Q9JHQodGhpcy5ub0FuaW1hdGlvblJlY3Qsb3QpLHRoaXMubm9BbmltYXRpb25SZWN0PSR0KHRoaXMubm9BbmltYXRpb25SZWN0LGF0KSx0aGlzLm5vQW5pbWF0aW9uUmVjdD0kdCh0aGlzLm5vQW5pbWF0aW9uUmVjdCxodCksdGhpcy5ydW5FZmZlY3QoKSl9KSwoYz1tLm5vZGUpPT1udWxsfHxjLmNsZWFyVG1wUG9pbnRzKCksdGhpcy53b3JrU2hhcGVzLmRlbGV0ZShiKSxuLnB1c2goe3JlY3Q6aHQsZHJhd0NhbnZhczpCdC5CZyxpc0Z1bGxXb3JrOnJ0LHZpZXdJZDp0aGlzLnZpZXdJZH0pKTppLnB1c2goe3JlY3Q6aHQsZHJhd0NhbnZhczpCdC5GbG9hdCxpc0Z1bGxXb3JrOnJ0LHZpZXdJZDp0aGlzLnZpZXdJZH0pLG0uYW5pbWF0aW9uV29ya0RhdGEubGVuZ3RoPTB9YnJlYWt9Y2FzZSBMdC5QZW5jaWw6e2lmKCFtLnVzZUFuaW1hdGlvbiYmbS5vcHMpe2xldCBydD0obD1tLm5vZGUpPT1udWxsP3ZvaWQgMDpsLmNvbnN1bWVTZXJ2aWNlKHtvcDptLmFuaW1hdGlvbldvcmtEYXRhfHxbXSxpc0Z1bGxXb3JrOiEwLHJlcGxhY2VJZDpifSk7Y29uc3Qgb3Q9KHY9bS5ub2RlKT09bnVsbD92b2lkIDA6di51cGRhdGFPcHRTZXJ2aWNlKG0udXBkYXRlTm9kZU9wdCk7cnQ9JHQocnQsb3QpLGYucHVzaCh7cmVjdDokdChtLm9sZFJlY3QscnQpLGNsZWFyQ2FudmFzOkJ0LkJnLHZpZXdJZDp0aGlzLnZpZXdJZH0pLG4ucHVzaCh7cmVjdDokdChtLm9sZFJlY3QscnQpLGRyYXdDYW52YXM6QnQuQmcsdmlld0lkOnRoaXMudmlld0lkfSksdGhpcy5zZWxlY3RvcldvcmtTaGFwZXMuZm9yRWFjaCgoYXQsaHQpPT57dmFyIGl0OyhpdD1hdC5zZWxlY3RJZHMpIT1udWxsJiZpdC5pbmNsdWRlcyhiKSYmKHRoaXMud2lsbFJ1bkVmZmVjdFNlbGVjdG9ySWRzLmFkZChodCksdGhpcy5ub0FuaW1hdGlvblJlY3Q9JHQodGhpcy5ub0FuaW1hdGlvblJlY3QscnQpLHRoaXMucnVuRWZmZWN0KCkpfSksKFQ9bS5ub2RlKT09bnVsbHx8VC5jbGVhclRtcFBvaW50cygpLHRoaXMud29ya1NoYXBlcy5kZWxldGUoYil9ZWxzZSBpZihtLnVzZUFuaW1hdGlvbil7Y29uc3Qgb3Q9dGhpcy5jb21wdXROZXh0QW5pbWF0aW9uSW5kZXgobSwzKSxhdD1NYXRoLm1heCgwLChtLmFuaW1hdGlvbkluZGV4fHwwKS0zKSxodD0obS5hbmltYXRpb25Xb3JrRGF0YXx8W10pLnNsaWNlKGF0LG90KTtpZihtLmlzRGVsKW0uaXNEZWwmJigoRD1tLm5vZGUpPT1udWxsfHxELmNsZWFyVG1wUG9pbnRzKCksdGhpcy53b3JrU2hhcGVzLmRlbGV0ZShiKSk7ZWxzZXtpZigobS5hbmltYXRpb25JbmRleHx8MCk8b3Qpe2NvbnN0IGl0PShMPW0ubm9kZSk9PW51bGw/dm9pZCAwOkwuY29uc3VtZVNlcnZpY2Uoe29wOmh0LGlzRnVsbFdvcms6ITEscmVwbGFjZUlkOihSPW0ubm9kZS5nZXRXb3JrSWQoKSk9PW51bGw/dm9pZCAwOlIudG9TdHJpbmcoKX0pO2kucHVzaCh7cmVjdDppdCxkcmF3Q2FudmFzOkJ0LkZsb2F0LHZpZXdJZDp0aGlzLnZpZXdJZH0pLG0uYW5pbWF0aW9uSW5kZXg9b3R9ZWxzZSBpZihtLm9wcyl7Y29uc3QgaXQ9KEE9bS5ub2RlKT09bnVsbD92b2lkIDA6QS5jb25zdW1lU2VydmljZSh7b3A6bS5hbmltYXRpb25Xb3JrRGF0YXx8W10saXNGdWxsV29yazohMCxyZXBsYWNlSWQ6KE49bS5ub2RlLmdldFdvcmtJZCgpKT09bnVsbD92b2lkIDA6Ti50b1N0cmluZygpfSk7bS5pc0RlbD0hMCxoLnB1c2goe3JlY3Q6aXQsY2xlYXJDYW52YXM6QnQuRmxvYXQsdmlld0lkOnRoaXMudmlld0lkfSksKHc9bS5ub2RlKSE9bnVsbCYmdy5nZXRXb3JrT3B0aW9ucygpLmlzT3BhY2l0eSYmZi5wdXNoKHtyZWN0Oml0LGNsZWFyQ2FudmFzOkJ0LkJnLHZpZXdJZDp0aGlzLnZpZXdJZH0pLG4ucHVzaCh7cmVjdDppdCxkcmF3Q2FudmFzOkJ0LkJnLHZpZXdJZDp0aGlzLnZpZXdJZH0pLHRoaXMudk5vZGVzLnNldEluZm8oYix7b3A6bS5hbmltYXRpb25Xb3JrRGF0YSxvcHQ6KEI9bS5ub2RlKT09bnVsbD92b2lkIDA6Qi5nZXRXb3JrT3B0aW9ucygpLHRvb2xzVHlwZTptLnRvb2xzVHlwZSxyZWN0Oml0fSl9ZT0hMH1odC5sZW5ndGgmJnQuc2V0KGIse3dvcmtTdGF0ZTphdD09PTA/Y2UuU3RhcnQ6b3Q9PT0oKEk9bS5hbmltYXRpb25Xb3JrRGF0YSk9PW51bGw/dm9pZCAwOkkubGVuZ3RoKT9jZS5Eb25lOmNlLkRvaW5nLG9wOmh0LmZpbHRlcigoaXQsTXQpPT57aWYoTXQlMyE9PTIpcmV0dXJuITB9KS5zbGljZSgtMil9KTticmVha31icmVha31jYXNlIEx0Lkxhc2VyUGVuOntjb25zdCBvdD10aGlzLmNvbXB1dE5leHRBbmltYXRpb25JbmRleChtLDIpLGF0PU1hdGgubWF4KDAsKG0uYW5pbWF0aW9uSW5kZXh8fDApLTIpLGh0PShtLmFuaW1hdGlvbldvcmtEYXRhfHxbXSkuc2xpY2UoYXQsb3QpO2lmKG0uaXNEZWwpe2lmKG0uaXNEZWwpe2NvbnN0IGl0PShzdD1tLm5vZGUpPT1udWxsP3ZvaWQgMDpzdC5jb25zdW1lU2VydmljZSh7b3A6W10saXNGdWxsV29yazohMX0pO20udG90YWxSZWN0PSR0KG0udG90YWxSZWN0LGl0KSxoLnB1c2goe3JlY3Q6bS50b3RhbFJlY3QsY2xlYXJDYW52YXM6QnQuRmxvYXQsdmlld0lkOnRoaXMudmlld0lkfSksaS5wdXNoKHtyZWN0Om0udG90YWxSZWN0LGRyYXdDYW52YXM6QnQuRmxvYXQsdmlld0lkOnRoaXMudmlld0lkfSksKEc9bS5ub2RlKT09bnVsbHx8Ry5jbGVhclRtcFBvaW50cygpLHRoaXMud29ya1NoYXBlcy5kZWxldGUoYil9fWVsc2V7aWYoKG0uYW5pbWF0aW9uSW5kZXh8fDApPG90KXtjb25zdCBpdD0oVj1tLm5vZGUpPT1udWxsP3ZvaWQgMDpWLmNvbnN1bWVTZXJ2aWNlKHtvcDpodCxpc0Z1bGxXb3JrOiExLHJlcGxhY2VJZDooaj1tLm5vZGUuZ2V0V29ya0lkKCkpPT1udWxsP3ZvaWQgMDpqLnRvU3RyaW5nKCl9KTttLnRvdGFsUmVjdD0kdChtLnRvdGFsUmVjdCxpdCksbS50aW1lciYmKGNsZWFyVGltZW91dChtLnRpbWVyKSxtLnRpbWVyPXZvaWQgMCksbS5hbmltYXRpb25JbmRleD1vdH1lbHNle20udGltZXJ8fChtLnRpbWVyPXNldFRpbWVvdXQoKCk9PnttLnRpbWVyPXZvaWQgMCxtLmlzRGVsPSEwLHRoaXMucnVuQW5pbWF0aW9uKCl9LCgoSj1tLm5vZGUpPT1udWxsP3ZvaWQgMDpKLmdldFdvcmtPcHRpb25zKCkpLmR1cmF0aW9uKjFlMysxMDApKTtjb25zdCBpdD0oXz1tLm5vZGUpPT1udWxsP3ZvaWQgMDpfLmNvbnN1bWVTZXJ2aWNlKHtvcDpbXSxpc0Z1bGxXb3JrOiExfSk7bS50b3RhbFJlY3Q9JHQobS50b3RhbFJlY3QsaXQpfWgucHVzaCh7cmVjdDptLnRvdGFsUmVjdCxjbGVhckNhbnZhczpCdC5GbG9hdCx2aWV3SWQ6dGhpcy52aWV3SWR9KSxpLnB1c2goe3JlY3Q6bS50b3RhbFJlY3QsZHJhd0NhbnZhczpCdC5GbG9hdCx2aWV3SWQ6dGhpcy52aWV3SWR9KSxlPSEwfWh0Lmxlbmd0aCYmdC5zZXQoYix7d29ya1N0YXRlOmF0PT09MD9jZS5TdGFydDpvdD09PSgoWT1tLmFuaW1hdGlvbldvcmtEYXRhKT09bnVsbD92b2lkIDA6WS5sZW5ndGgpP2NlLkRvbmU6Y2UuRG9pbmcsb3A6aHQuc2xpY2UoLTIpfSk7YnJlYWt9fX0pLGUmJnRoaXMucnVuQW5pbWF0aW9uKCk7Y29uc3QgdT17cmVuZGVyOltdfTtpZihmLmxlbmd0aCl7Y29uc3QgbT1mLnJlZHVjZSgoYixNKT0+KE0ucmVjdCYmTS5jbGVhckNhbnZhcz09PUJ0LkJnJiYoYi5yZWN0PSR0KGIucmVjdCxNLnJlY3QpKSxiKSx7aXNDbGVhcjohMCxjbGVhckNhbnZhczpCdC5CZyx2aWV3SWQ6dGhpcy52aWV3SWR9KTttLnJlY3QmJihtLnJlY3Q9bS5yZWN0JiZsbihtLnJlY3QpLChhPXUucmVuZGVyKT09bnVsbHx8YS5wdXNoKG0pKX1pZihoLmxlbmd0aCl7Y29uc3QgbT1oLnJlZHVjZSgoYixNKT0+KE0ucmVjdCYmTS5jbGVhckNhbnZhcz09PUJ0LkZsb2F0JiYoYi5yZWN0PSR0KGIucmVjdCxNLnJlY3QpKSxiKSx7aXNDbGVhcjohMCxjbGVhckNhbnZhczpCdC5GbG9hdCx2aWV3SWQ6dGhpcy52aWV3SWR9KTttLnJlY3QmJihtLnJlY3Q9bS5yZWN0JiZsbihtLnJlY3QpLChkPXUucmVuZGVyKT09bnVsbHx8ZC5wdXNoKG0pKX1pZihuLmxlbmd0aCl7Y29uc3QgbT1uLnJlZHVjZSgoYixNKT0+KE0ucmVjdCYmTS5kcmF3Q2FudmFzPT09QnQuQmcmJihiLnJlY3Q9JHQoYi5yZWN0LE0ucmVjdCkpLGIpLHtpc0Z1bGxXb3JrOiEwLGRyYXdDYW52YXM6QnQuQmcsdmlld0lkOnRoaXMudmlld0lkfSk7bS5yZWN0JiYobS5yZWN0PW0ucmVjdCYmbG4obS5yZWN0KSwoRT11LnJlbmRlcik9PW51bGx8fEUucHVzaChtKSl9aWYoaS5sZW5ndGgpe2NvbnN0IG09aS5yZWR1Y2UoKGIsTSk9PihNLnJlY3QmJk0uZHJhd0NhbnZhcz09PUJ0LkZsb2F0JiYoYi5yZWN0PSR0KGIucmVjdCxNLnJlY3QpKSxiKSx7aXNGdWxsV29yazohMSxkcmF3Q2FudmFzOkJ0LkZsb2F0LHZpZXdJZDp0aGlzLnZpZXdJZH0pO20ucmVjdCYmKG0ucmVjdD1tLnJlY3QmJmxuKG0ucmVjdCksKHA9dS5yZW5kZXIpPT1udWxsfHxwLnB1c2gobSkpfXQuc2l6ZSYmKHUuc3A9W10sdC5mb3JFYWNoKChtLGIpPT57dmFyIE07KE09dS5zcCk9PW51bGx8fE0ucHVzaCh7dHlwZTpUdC5DdXJzb3IsdWlkOmIuc3BsaXQoU20pWzBdLG9wOm0ub3Asd29ya1N0YXRlOm0ud29ya1N0YXRlLHZpZXdJZDp0aGlzLnZpZXdJZH0pfSkpLChPPXUucmVuZGVyKSE9bnVsbCYmTy5sZW5ndGgmJnRoaXMucG9zdCh1KX1ydW5BbmltYXRpb24oKXt0aGlzLmFuaW1hdGlvbklkfHwodGhpcy5hbmltYXRpb25JZD1yZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5hbmltYXRpb25EcmF3LmJpbmQodGhpcykpKX1jb21wdXROZXh0QW5pbWF0aW9uSW5kZXgoZSx0KXt2YXIgaTtjb25zdCBuPU1hdGguZmxvb3IoKGUuYW5pbWF0aW9uV29ya0RhdGF8fFtdKS5zbGljZShlLmFuaW1hdGlvbkluZGV4KS5sZW5ndGgqMzIvdC8oKChpPWUubm9kZSk9PW51bGw/dm9pZCAwOmkuc3luY1VuaXRUaW1lKXx8MWUzKSkqdDtyZXR1cm4gTWF0aC5taW4oKGUuYW5pbWF0aW9uSW5kZXh8fDApKyhufHx0KSwoZS5hbmltYXRpb25Xb3JrRGF0YXx8W10pLmxlbmd0aCl9cnVuRWZmZWN0KCl7dGhpcy5ydW5FZmZlY3RJZHx8KHRoaXMucnVuRWZmZWN0SWQ9c2V0VGltZW91dCh0aGlzLmVmZmVjdFJ1blNlbGVjdG9yLmJpbmQodGhpcyksMCkpfWVmZmVjdFJ1blNlbGVjdG9yKCl7dGhpcy5ydW5FZmZlY3RJZD12b2lkIDA7bGV0IGU9dGhpcy5ub0FuaW1hdGlvblJlY3Q7dGhpcy53aWxsUnVuRWZmZWN0U2VsZWN0b3JJZHMuZm9yRWFjaCh0PT57dmFyIGYsaDtjb25zdCBuPXRoaXMuc2VsZWN0b3JXb3JrU2hhcGVzLmdldCh0KSxpPW4mJm4uc2VsZWN0SWRzJiYoKGY9bi5ub2RlKT09bnVsbD92b2lkIDA6Zi5zZWxlY3RTZXJ2aWNlTm9kZSh0LG4pKTtlPSR0KGUsaSksKGg9bj09bnVsbD92b2lkIDA6bi5zZWxlY3RJZHMpIT1udWxsJiZoLmxlbmd0aHx8dGhpcy5zZWxlY3RvcldvcmtTaGFwZXMuZGVsZXRlKHQpfSksZSYmdGhpcy5wb3N0KHtyZW5kZXI6W3tyZWN0OmxuKGUpLGRyYXdDYW52YXM6QnQuQmcsaXNDbGVhcjohMCxjbGVhckNhbnZhczpCdC5CZyxpc0Z1bGxXb3JrOiEwLHZpZXdJZDp0aGlzLnZpZXdJZH1dfSksdGhpcy53aWxsUnVuRWZmZWN0U2VsZWN0b3JJZHMuY2xlYXIoKSx0aGlzLm5vQW5pbWF0aW9uUmVjdD12b2lkIDB9YWN0aXZlU2VsZWN0b3JTaGFwZShlKXt2YXIgZCxFLHA7Y29uc3R7d29ya0lkOnQsb3B0Om4sdG9vbHNUeXBlOmksdHlwZTpmLHNlbGVjdElkczpofT1lO2lmKCF0KXJldHVybjtjb25zdCB1PXQudG9TdHJpbmcoKTtpZighKChkPXRoaXMuc2VsZWN0b3JXb3JrU2hhcGVzKSE9bnVsbCYmZC5oYXModSkpKXtsZXQgTz17dG9vbHNUeXBlOmksc2VsZWN0SWRzOmgsdHlwZTpmLG9wdDpufTtpJiZuJiYoTz10aGlzLnNldE5vZGVLZXkoTyxpLG4pKSwoRT10aGlzLnNlbGVjdG9yV29ya1NoYXBlcyk9PW51bGx8fEUuc2V0KHUsTyl9Y29uc3QgYT0ocD10aGlzLnNlbGVjdG9yV29ya1NoYXBlcyk9PW51bGw/dm9pZCAwOnAuZ2V0KHUpO2YmJihhLnR5cGU9ZiksYS5ub2RlJiZhLm5vZGUuZ2V0V29ya0lkKCkhPT11JiZhLm5vZGUuc2V0V29ya0lkKHUpLGEuc2VsZWN0SWRzPWh8fFtdfX1jbGFzcyB5eSBleHRlbmRzIFFhe2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJhbmltYXRpb25Xb3JrUmVjdHMiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpuZXcgTWFwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImNvbWJpbmVEcmF3VGltZXIiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiYW5pbWF0aW9uSWQiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiY2xvc2VBbmltYXRpb25UaW1lIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6MTEwMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJydW5MYXNlclBlblN0ZXAiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTowfSl9cnVuRnVsbFdvcmsoZSl7dmFyIGk7Y29uc3QgdD10aGlzLnNldEZ1bGxXb3JrKGUpLG49ZS5vcHMmJnNpKGUub3BzKTtpZih0KXtjb25zdCBmPXQuY29uc3VtZVNlcnZpY2Uoe29wOm4saXNGdWxsV29yazohMCxyZXBsYWNlSWQ6KGk9dC5nZXRXb3JrSWQoKSk9PW51bGw/dm9pZCAwOmkudG9TdHJpbmcoKX0pLGg9KGU9PW51bGw/dm9pZCAwOmUudXBkYXRlTm9kZU9wdCkmJnQudXBkYXRhT3B0U2VydmljZShlLnVwZGF0ZU5vZGVPcHQpO3JldHVybiBlLndvcmtJZCYmdGhpcy53b3JrU2hhcGVzLmRlbGV0ZShlLndvcmtJZCksaHx8Zn19cnVuU2VsZWN0V29yayhlKXt2YXIgbjtjb25zdCB0PXRoaXMuc2V0RnVsbFdvcmsoZSk7dCYmKChuPWUuc2VsZWN0SWRzKSE9bnVsbCYmbi5sZW5ndGgpJiZlLndvcmtJZCYmdC5zZWxlY3RTZXJ2aWNlTm9kZShlLndvcmtJZC50b1N0cmluZygpLHtzZWxlY3RJZHM6ZS5zZWxlY3RJZHN9KX1jb25zdW1lRHJhdyhlKXt2YXIgaTtjb25zdHtvcDp0LHdvcmtJZDpufT1lO2lmKHQhPW51bGwmJnQubGVuZ3RoJiZuKXtjb25zdCBmPXRoaXMud29ya1NoYXBlcy5nZXQobik7aWYoIWYpcmV0dXJuO2NvbnN0IGg9Zi50b29sc1R5cGUsdT1mLmNvbnN1bWUoe2RhdGE6ZSxpc0Z1bGxXb3JrOiExLGlzQ2xlYXJBbGw6ITAsaXNTdWJXb3JrZXI6ITB9KTtzd2l0Y2goaCl7Y2FzZSBMdC5MYXNlclBlbjp1IT1udWxsJiZ1LnJlY3QmJigoaT10aGlzLmFuaW1hdGlvbldvcmtSZWN0cyk9PW51bGx8fGkuc2V0KG4se3Jlczp1LGNhbkRlbDohMSxpc1JlY3Q6ITB9KSksdGhpcy5ydW5MYXNlclBlbkFuaW1hdGlvbigpO2JyZWFrO2Nhc2UgTHQuQXJyb3c6Y2FzZSBMdC5TdHJhaWdodDpjYXNlIEx0LkVsbGlwc2U6Y2FzZSBMdC5SZWN0YW5nbGU6Y2FzZSBMdC5TdGFyOmNhc2UgTHQuUG9seWdvbjpjYXNlIEx0LlNwZWVjaEJhbGxvb246dSYmKHRoaXMuZHJhd0NvdW50KyssdGhpcy5kcmF3QXJyb3codSkpO2JyZWFrO2Nhc2UgTHQuUGVuY2lsOnUmJih0aGlzLmRyYXdDb3VudCsrLHRoaXMuZHJhd1BlbmNpbCh1KSk7YnJlYWt9fX1jb25zdW1lRHJhd0FsbChlKXt2YXIgbixpO2NvbnN0e3dvcmtJZDp0fT1lO2lmKHQpe2NvbnN0IGY9dGhpcy53b3JrU2hhcGVzLmdldCh0KTtpZighZilyZXR1cm47c3dpdGNoKGYudG9vbHNUeXBlKXtjYXNlIEx0Lkxhc2VyUGVuOmlmKHRoaXMuYW5pbWF0aW9uSWQpe2NvbnN0IHU9Zi5jb25zdW1lQWxsKHtkYXRhOmV9KTt1IT1udWxsJiZ1Lm9wJiYodSE9bnVsbCYmdS5yZWN0JiYoKG49dGhpcy5hbmltYXRpb25Xb3JrUmVjdHMpPT1udWxsfHxuLnNldCh0LHtyZXM6dSxjYW5EZWw6ITEsaXNSZWN0OiEwfSksdGhpcy5ydW5MYXNlclBlbkFuaW1hdGlvbigpKSx0aGlzLl9wb3N0KHtzcDpbdV19KSk7Y29uc3QgYT0oaT1mLmdldFdvcmtPcHRpb25zKCkpPT1udWxsP3ZvaWQgMDppLmR1cmF0aW9uO3RoaXMuY2xvc2VBbmltYXRpb25UaW1lPWE/YSoxZTMrMTAwOnRoaXMuY2xvc2VBbmltYXRpb25UaW1lLHNldFRpbWVvdXQoKCk9Pnt2YXIgRTt0aGlzLmZ1bGxMYXllci5nZXRFbGVtZW50c0J5TmFtZSh0LnRvU3RyaW5nKCkpLm1hcChwPT5wLnJlbW92ZSgpKSx0aGlzLmNsZWFyV29ya1NoYXBlTm9kZUNhY2hlKHQpO2NvbnN0IGQ9KEU9dGhpcy5hbmltYXRpb25Xb3JrUmVjdHMpPT1udWxsP3ZvaWQgMDpFLmdldCh0KTtkJiYoZC5jYW5EZWw9ITApLHNldFRpbWVvdXQoKCk9Pnt0aGlzLl9wb3N0KHtzcDpbe3JlbW92ZUlkczpbdC50b1N0cmluZygpXSx0eXBlOlR0LlJlbW92ZU5vZGV9XX0pfSxmLmdldFdvcmtPcHRpb25zKCkuc3luY1VuaXRUaW1lfHx0aGlzLmNsb3NlQW5pbWF0aW9uVGltZSl9LHRoaXMuY2xvc2VBbmltYXRpb25UaW1lKX1icmVhaztjYXNlIEx0LkFycm93OmNhc2UgTHQuU3RyYWlnaHQ6Y2FzZSBMdC5FbGxpcHNlOmNhc2UgTHQuUGVuY2lsOmNhc2UgTHQuUmVjdGFuZ2xlOmNhc2UgTHQuU3RhcjpjYXNlIEx0LlBvbHlnb246Y2FzZSBMdC5TcGVlY2hCYWxsb29uOnRoaXMuZHJhd0NvdW50PTAsdGhpcy5mdWxsTGF5ZXIucmVtb3ZlQWxsQ2hpbGRyZW4oKSx0aGlzLmNsZWFyV29ya1NoYXBlTm9kZUNhY2hlKHQpO2JyZWFrfX19cnVuTGFzZXJQZW5BbmltYXRpb24oKXt0aGlzLmFuaW1hdGlvbklkfHwodGhpcy5hbmltYXRpb25JZD1yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCk9Pnt2YXIgbixpO2lmKHRoaXMuYW5pbWF0aW9uSWQ9dm9pZCAwLHRoaXMucnVuTGFzZXJQZW5TdGVwKyssdGhpcy5ydW5MYXNlclBlblN0ZXA+MSl7dGhpcy5ydW5MYXNlclBlblN0ZXA9MCx0aGlzLnJ1bkxhc2VyUGVuQW5pbWF0aW9uKCk7cmV0dXJufWxldCBlO2NvbnN0IHQ9W107KG49dGhpcy5hbmltYXRpb25Xb3JrUmVjdHMpPT1udWxsfHxuLmZvckVhY2goKGYsaCx1KT0+e2YuaXNSZWN0JiYoZT0kdChlLGYucmVzLnJlY3QpKSxmLnJlcy53b3JrSWQmJnQucHVzaChmLnJlcyksdGhpcy5mdWxsTGF5ZXIuZ2V0RWxlbWVudHNCeU5hbWUoaC50b1N0cmluZygpKS5sZW5ndGg/Zi5pc1JlY3Q9ITA6Zi5pc1JlY3Q9ITEsZi5jYW5EZWwmJnUuZGVsZXRlKGgpfSksKGk9dGhpcy5hbmltYXRpb25Xb3JrUmVjdHMpIT1udWxsJiZpLnNpemUmJnRoaXMucnVuTGFzZXJQZW5BbmltYXRpb24oKSxlJiZ0aGlzLl9wb3N0KHtyZW5kZXI6W3tyZWN0OmUsZHJhd0NhbnZhczpCdC5GbG9hdCxpc0NsZWFyOiEwLGNsZWFyQ2FudmFzOkJ0LkZsb2F0LGlzRnVsbFdvcms6ITEsdmlld0lkOnRoaXMudmlld0lkfV0sc3A6dH0pfSkpfWRyYXdQZW5jaWwoZSl7dGhpcy5fcG9zdCh7ZHJhd0NvdW50OnRoaXMuZHJhd0NvdW50LHJlbmRlcjpbe3JlY3Q6ZT09bnVsbD92b2lkIDA6ZS5yZWN0LGRyYXdDYW52YXM6QnQuRmxvYXQsaXNDbGVhcjohMSxpc0Z1bGxXb3JrOiExLHZpZXdJZDp0aGlzLnZpZXdJZH1dLHNwOihlPT1udWxsP3ZvaWQgMDplLm9wKSYmW2VdfSl9ZHJhd0Fycm93KGUpe3RoaXMuX3Bvc3Qoe2RyYXdDb3VudDp0aGlzLmRyYXdDb3VudCxyZW5kZXI6W3tyZWN0OmU9PW51bGw/dm9pZCAwOmUucmVjdCxkcmF3Q2FudmFzOkJ0LkZsb2F0LGlzQ2xlYXI6ITAsY2xlYXJDYW52YXM6QnQuRmxvYXQsaXNGdWxsV29yazohMSx2aWV3SWQ6dGhpcy52aWV3SWR9XX0pfX12YXIgSW47KGZ1bmN0aW9uKGcpe2cuRnVsbD0iZnVsbCIsZy5TdWI9InN1YiJ9KShJbnx8KEluPXt9KSk7Y2xhc3MgeHl7Y29uc3RydWN0b3IoZSx0KXtPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiX3NlbGYiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidHlwZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ3b3JrVGhyZWFkTWFwIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6bmV3IE1hcH0pLHRoaXMuX3NlbGY9ZSx0aGlzLnR5cGU9dCx0aGlzLnJlZ2lzdGVyKCl9aW5pdChlKXtjb25zdHt2aWV3SWQ6dCxkcHI6bixvZmZzY3JlZW5DYW52YXNPcHQ6aSxsYXllck9wdDpmfT1lO2lmKCFufHwhaXx8IWYpcmV0dXJuO2xldCBoO3RoaXMudHlwZT09PUluLkZ1bGwmJihoPW5ldyBPeSh0LHtkcHI6bixvZmZzY3JlZW5DYW52YXNPcHQ6aSxsYXllck9wdDpmfSx0aGlzLnBvc3QuYmluZCh0aGlzKSkpLHRoaXMudHlwZT09PUluLlN1YiYmKGg9bmV3IEV5KHQse2RwcjpuLG9mZnNjcmVlbkNhbnZhc09wdDppLGxheWVyT3B0OmZ9LHRoaXMucG9zdC5iaW5kKHRoaXMpKSksaCYmZS5jYW1lcmFPcHQmJmguc2V0Q2FtZXJhT3B0KGUuY2FtZXJhT3B0KSxoJiZ0aGlzLndvcmtUaHJlYWRNYXAuc2V0KHQsaCl9cmVnaXN0ZXIoKXtvbm1lc3NhZ2U9ZT0+e2NvbnN0IHQ9ZS5kYXRhO2lmKHQpZm9yKGNvbnN0IG4gb2YgdC52YWx1ZXMoKSl7Y29uc3R7bXNnVHlwZTppLHZpZXdJZDpmLHRhc2tzcXVldWU6aCxtYWluVGFza3NxdWV1ZUNvdW50OnV9PW47aWYoaT09PVR0LkluaXQpe3RoaXMuaW5pdChuKTtjb250aW51ZX1pZihpPT09VHQuVGFza3NRdWV1ZSYmKGghPW51bGwmJmguc2l6ZSkmJnUpe3RoaXMud29ya1RocmVhZE1hcC5mb3JFYWNoKChkLEUpPT57Y29uc3QgcD1oLmdldChFKTtwJiZkLm9uKHApLHRoaXMucG9zdCh7d29ya2VyVGFza3NxdWV1ZUNvdW50OnV9KX0pO2NvbnRpbnVlfWlmKGY9PT1QbSl7dGhpcy53b3JrVGhyZWFkTWFwLmZvckVhY2goZD0+e2Qub24obiksaT09PVR0LkRlc3Ryb3kmJnRoaXMud29ya1RocmVhZE1hcC5kZWxldGUoZil9KTtjb250aW51ZX1jb25zdCBhPXRoaXMud29ya1RocmVhZE1hcC5nZXQoZik7YSYmKGEub24obiksaT09PVR0LkRlc3Ryb3kmJnRoaXMud29ya1RocmVhZE1hcC5kZWxldGUoZikpfX19cG9zdChlLHQpe3Q/dGhpcy5fc2VsZi5wb3N0TWVzc2FnZShlLHQpOnRoaXMuX3NlbGYucG9zdE1lc3NhZ2UoZSl9fWNsYXNzIE95IGV4dGVuZHMgSmF7Y29uc3RydWN0b3IoZSx0LG4pe3N1cGVyKGUsdCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImRyYXdMYXllciIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzbmFwc2hvdEZ1bGxMYXllciIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJtZXRob2RCdWlsZGVyIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImxvY2FsV29yayIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzZXJ2aWNlV29yayIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJfcG9zdCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLHRoaXMuX3Bvc3Q9bix0aGlzLmRyYXdMYXllcj10aGlzLmNyZWF0ZUxheWVyKCJkcmF3TGF5ZXIiLHRoaXMuc2NlbmUsey4uLnQubGF5ZXJPcHQsYnVmZmVyU2l6ZToxZTN9KTtjb25zdCBpPXt2aWV3SWQ6dGhpcy52aWV3SWQsdk5vZGVzOnRoaXMudk5vZGVzLGZ1bGxMYXllcjp0aGlzLmZ1bGxMYXllcixkcmF3TGF5ZXI6dGhpcy5kcmF3TGF5ZXIscG9zdDp0aGlzLnBvc3QuYmluZCh0aGlzKX07dGhpcy5sb2NhbFdvcms9bmV3IHB5KGkpLHRoaXMuc2VydmljZVdvcms9bmV3IG15KGkpLHRoaXMubWV0aG9kQnVpbGRlcj1uZXcgTm0oW29lLkNvcHlOb2RlLG9lLlNldENvbG9yTm9kZSxvZS5EZWxldGVOb2RlLG9lLlJvdGF0ZU5vZGUsb2UuU2NhbGVOb2RlLG9lLlRyYW5zbGF0ZU5vZGUsb2UuWkluZGV4QWN0aXZlLG9lLlpJbmRleE5vZGVdKS5yZWdpc3RlckZvcldvcmtlcih0aGlzLmxvY2FsV29yayx0aGlzLnNlcnZpY2VXb3JrKSx0aGlzLnZOb2Rlcy5pbml0KHRoaXMuZnVsbExheWVyLHRoaXMuZHJhd0xheWVyKX1hc3luYyBwb3N0KGUsdCl7dmFyIHUsYTtjb25zdCBuPWUucmVuZGVyLGk9W107bGV0IGY9dDtpZihuIT1udWxsJiZuLmxlbmd0aCl7Zm9yKGNvbnN0IGQgb2Ygbil7aWYoZC5pc0NsZWFyQWxsJiYoZC5yZWN0PXRoaXMuZ2V0U2NlbmVSZWN0KCksZC5pc0NsZWFyPSEwLGRlbGV0ZSBkLmlzQ2xlYXJBbGwpLGQuaXNEcmF3QWxsJiYoZC5yZWN0PXRoaXMuZ2V0U2NlbmVSZWN0KCksZGVsZXRlIGQuaXNEcmF3QWxsKSxkLmRyYXdDYW52YXMpe2NvbnN0IEU9ZC5pc0Z1bGxXb3JrP3RoaXMuZnVsbExheWVyOnRoaXMuZHJhd0xheWVyOyhFPT1udWxsP3ZvaWQgMDpFLnBhcmVudCkucmVuZGVyKCl9aWYoZC5yZWN0KXtkLmNsZWFyQ2FudmFzPT09ZC5kcmF3Q2FudmFzJiZkLmRyYXdDYW52YXM9PT1CdC5CZyYmKGQucmVjdD10aGlzLmNoZWNrUmlnaHRSZWN0Qm91bmRpbmdCb3goZC5yZWN0KSk7Y29uc3QgRT1kLnJlY3Q7aWYoZC5yZWN0PXRoaXMuc2FmYXJpRml4UmVjdChkcihkLnJlY3QpKSxkLmRyYXdDYW52YXMsQnQuU2VsZWN0b3IsIWQucmVjdCljb250aW51ZTtpZihkLmRyYXdDYW52YXM9PT1CdC5TZWxlY3Rvcil7Y29uc3QgcD0odT1lLnNwKT09bnVsbD92b2lkIDA6dS5maW5kKE89Pk8udHlwZT09PVR0LlNlbGVjdCk7cCYmKHAucmVjdD1kLnJlY3QpLGQub2Zmc2V0PXt4OmQucmVjdC54LUUueCx5OmQucmVjdC55LUUueX19aWYoZC5kcmF3Q2FudmFzKXtjb25zdCBwPWF3YWl0IHRoaXMuZ2V0UmVjdEltYWdlQml0bWFwKGQucmVjdCwhIWQuaXNGdWxsV29yayk7ZC5pbWFnZUJpdG1hcD1wLGZ8fChmPVtdKSxmLnB1c2gocCl9aS5wdXNoKGQpfX1lLnJlbmRlcj1pfWNvbnN0IGg9KGE9ZS5zcCk9PW51bGw/dm9pZCAwOmEuZmlsdGVyKGQ9PmQudHlwZSE9PVR0Lk5vbmV8fE9iamVjdC5rZXlzKGQpLmZpbHRlcihFPT5FPT09InR5cGUiKS5sZW5ndGgpO2lmKGghPW51bGwmJmgubGVuZ3RoJiYoZS5zcD1oLm1hcChkPT4oey4uLmQsdmlld0lkOnRoaXMudmlld0lkfSkpKSwoZS5kcmF3Q291bnR8fGUud29ya2VyVGFza3NxdWV1ZUNvdW50fHxoIT1udWxsJiZoLmxlbmd0aHx8aSE9bnVsbCYmaS5sZW5ndGgpJiYodGhpcy5fcG9zdChlLGYpLGYhPW51bGwmJmYubGVuZ3RoKSlmb3IoY29uc3QgZCBvZiBmKWQgaW5zdGFuY2VvZiBJbWFnZUJpdG1hcCYmZC5jbG9zZSgpfW9uKGUpe2lmKHRoaXMubWV0aG9kQnVpbGRlci5jb25zdW1lRm9yV29ya2VyKGUpKXJldHVybjtjb25zdHttc2dUeXBlOnQsZGF0YVR5cGU6bix3b3JrSWQ6aX09ZTtzd2l0Y2godCl7Y2FzZSBUdC5VcGRhdGVDYW1lcmE6dGhpcy51cGRhdGVDYW1lcmEoZSk7YnJlYWs7Y2FzZSBUdC5TZWxlY3Q6bj09PXp0LlNlcnZpY2UmJihpPT09aWUuc2VsZWN0b3JJZD90aGlzLmxvY2FsV29yay51cGRhdGVGdWxsU2VsZWN0V29yayhlKTp0aGlzLnNlcnZpY2VXb3JrLnJ1blNlbGVjdFdvcmsoZSkpO2JyZWFrO2Nhc2UgVHQuVXBkYXRlTm9kZTpjYXNlIFR0LkZ1bGxXb3JrOnRoaXMuY29uc3VtZUZ1bGwobixlKTticmVhaztjYXNlIFR0LlJlbW92ZU5vZGU6dGhpcy5yZW1vdmVOb2RlKGUpO2JyZWFrO2Nhc2UgVHQuR2V0VGV4dEFjdGl2ZTp0aGlzLmNoZWNrVGV4dEFjdGl2ZShlKTticmVha31zdXBlci5vbihlKX1yZW1vdmVOb2RlKGUpe2NvbnN0e2RhdGFUeXBlOnQsd29ya0lkOm59PWU7bj09PWllLnNlbGVjdG9ySWQmJnRoaXMubG9jYWxXb3JrLmJsdXJTZWxlY3RvcihlKSx0PT09enQuU2VydmljZSYmdGhpcy5zZXJ2aWNlV29yay5yZW1vdmVXb3JrKGUpLHQ9PT16dC5Mb2NhbCYmdGhpcy5sb2NhbFdvcmsucmVtb3ZlV29yayhlKX1jaGVja1RleHRBY3RpdmUoZSl7Y29uc3R7ZGF0YVR5cGU6dH09ZTt0PT09enQuTG9jYWwmJnRoaXMubG9jYWxXb3JrLmNoZWNrVGV4dEFjdGl2ZShlKX1jbGVhckFsbCgpe3RoaXMudk5vZGVzLmNsZWFyKCksc3VwZXIuY2xlYXJBbGwoKSx0aGlzLnBvc3Qoe3JlbmRlcjpbe2lzQ2xlYXJBbGw6ITAsY2xlYXJDYW52YXM6QnQuQmcsaXNGdWxsV29yazohMCx2aWV3SWQ6dGhpcy52aWV3SWR9LHtpc0NsZWFyQWxsOiEwLGNsZWFyQ2FudmFzOkJ0LkZsb2F0LGlzRnVsbFdvcms6ITEsdmlld0lkOnRoaXMudmlld0lkfV0sc3A6W3t0eXBlOlR0LkNsZWFyfV19KX1zZXRDYW1lcmFPcHQoZSl7dGhpcy5jYW1lcmFPcHQ9ZTtjb25zdHtzY2FsZTp0LGNlbnRlclg6bixjZW50ZXJZOmksd2lkdGg6ZixoZWlnaHQ6aH09ZTsoZiE9PXRoaXMuc2NlbmUud2lkdGh8fGghPT10aGlzLnNjZW5lLmhlaWdodCkmJnRoaXMudXBkYXRlU2NlbmUoe3dpZHRoOmYsaGVpZ2h0Omh9KSx0aGlzLmZ1bGxMYXllciYmKHRoaXMuZnVsbExheWVyLnNldEF0dHJpYnV0ZSgic2NhbGUiLFt0LHRdKSx0aGlzLmZ1bGxMYXllci5zZXRBdHRyaWJ1dGUoInRyYW5zbGF0ZSIsWy1uLC1pXSkpLHRoaXMuZHJhd0xheWVyJiYodGhpcy5kcmF3TGF5ZXIuc2V0QXR0cmlidXRlKCJzY2FsZSIsW3QsdF0pLHRoaXMuZHJhd0xheWVyLnNldEF0dHJpYnV0ZSgidHJhbnNsYXRlIixbLW4sLWldKSl9Z2V0T2Zmc2NyZWVuKGUpe3JldHVybihlP3RoaXMuZnVsbExheWVyLnBhcmVudDp0aGlzLmRyYXdMYXllci5wYXJlbnQpLmNhbnZhc31jb25zdW1lRnVsbChlLHQpe2U9PT16dC5Mb2NhbCYmdGhpcy5sb2NhbFdvcmsuY29uc3VtZUZ1bGwodCk7Y29uc3Qgbj10aGlzLmxvY2FsV29yay5jb2xsb2N0RWZmZWN0U2VsZWN0V29yayh0KTtuJiZlPT09enQuU2VydmljZSYmdGhpcy5zZXJ2aWNlV29yay5jb25zdW1lRnVsbChuKX1jb25zdW1lRHJhdyhlLHQpe2U9PT16dC5Mb2NhbCYmdGhpcy5sb2NhbFdvcmsuY29uc3VtZURyYXcodCx0aGlzLnNlcnZpY2VXb3JrKSxlPT09enQuU2VydmljZSYmdGhpcy5zZXJ2aWNlV29yay5jb25zdW1lRHJhdyh0KX1jb25zdW1lRHJhd0FsbChlLHQpe2U9PT16dC5Mb2NhbCYmdGhpcy5sb2NhbFdvcmsuY29uc3VtZURyYXdBbGwodCx0aGlzLnNlcnZpY2VXb3JrKX11cGRhdGVDYW1lcmEoZSl7Y29uc3QgdD1bXSx7Y2FtZXJhT3B0Om59PWU7biYmKHRoaXMuc2V0Q2FtZXJhT3B0KG4pLHRoaXMubG9jYWxXb3JrLndvcmtTaGFwZXMuZm9yRWFjaCgoaSxmKT0+eyhpLnRvb2xzVHlwZT09PUx0LlBlbmNpbHx8aS50b29sc1R5cGU9PT1MdC5BcnJvd3x8aS50b29sc1R5cGU9PT1MdC5TdHJhaWdodHx8aS50b29sc1R5cGU9PT1MdC5FbGxpcHNlfHxpLnRvb2xzVHlwZT09PUx0LlJlY3RhbmdsZXx8aS50b29sc1R5cGU9PT1MdC5TdGFyfHxpLnRvb2xzVHlwZT09PUx0LlBvbHlnb258fGkudG9vbHNUeXBlPT09THQuU3BlZWNoQmFsbG9vbnx8aS50b29sc1R5cGU9PT1MdC5UZXh0KSYmdGhpcy5sb2NhbFdvcmsud29ya1NoYXBlU3RhdGUuc2V0KGYse3dpbGxDbGVhcjohMH0pfSksdGhpcy5sb2NhbFdvcmsucnVuRWZmZWN0V29yaygoKT0+e2lmKHRoaXMuc2VydmljZVdvcmsuc2VsZWN0b3JXb3JrU2hhcGVzLnNpemUpZm9yKGNvbnN0W2ksZl1vZiB0aGlzLnNlcnZpY2VXb3JrLnNlbGVjdG9yV29ya1NoYXBlcy5lbnRyaWVzKCkpdGhpcy5zZXJ2aWNlV29yay5ydW5TZWxlY3RXb3JrKHt3b3JrSWQ6aSxzZWxlY3RJZHM6Zi5zZWxlY3RJZHMsbXNnVHlwZTpUdC5TZWxlY3QsZGF0YVR5cGU6enQuU2VydmljZSx2aWV3SWQ6dGhpcy52aWV3SWR9KTtpZih0aGlzLnZOb2Rlcy5oYXNSZW5kZXJOb2RlcygpKXtsZXQgaTt0LnB1c2goe2lzQ2xlYXJBbGw6ITAsY2xlYXJDYW52YXM6QnQuQmcsaXNGdWxsV29yazohMCx2aWV3SWQ6dGhpcy52aWV3SWR9LHtpc0NsZWFyQWxsOiEwLGNsZWFyQ2FudmFzOkJ0LkZsb2F0LGlzRnVsbFdvcms6ITEsdmlld0lkOnRoaXMudmlld0lkfSk7Zm9yKGNvbnN0IGYgb2YgdGhpcy52Tm9kZXMuY3VyTm9kZU1hcC52YWx1ZXMoKSl3YShmLnRvb2xzVHlwZSkmJihpPSR0KGksZi5yZWN0KSk7aSYmdC5wdXNoKHtyZWN0Om9tKGksMTAwKSxkcmF3Q2FudmFzOkJ0LkJnLGlzQ2xlYXI6ITEsaXNGdWxsV29yazohMCx2aWV3SWQ6dGhpcy52aWV3SWR9KX10Lmxlbmd0aCYmdGhpcy5wb3N0KHtyZW5kZXI6dH0pfSkpfWdldFJlY3RJbWFnZUJpdG1hcChlLHQpe2NvbnN0IG49ZS54KnRoaXMuZHByLGk9ZS55KnRoaXMuZHByLGY9ZS53KnRoaXMuZHByLGg9ZS5oKnRoaXMuZHByO3JldHVybiBjcmVhdGVJbWFnZUJpdG1hcCh0aGlzLmdldE9mZnNjcmVlbih0KSxuLGksZixoKX1zYWZhcmlGaXhSZWN0KGUpe2lmKGUudytlLng8PTB8fGUuaCtlLnk8PTB8fGUudzw9MHx8ZS5oPD0wKXJldHVybjtjb25zdCB0PXt4OjAseTowLHc6dGhpcy5zY2VuZS53aWR0aCxoOnRoaXMuc2NlbmUuaGVpZ2h0fTtpZihlLng8MD9lLncrZS54PHRoaXMuc2NlbmUud2lkdGgmJih0Lnc9ZS53K2UueCk6ZS53K2UueD4wJiYodC54PWUueCx0Lnc9dGhpcy5zY2VuZS53aWR0aC1lLngpLGUueTwwP2UuaCtlLnk8dGhpcy5zY2VuZS5oZWlnaHQmJih0Lmg9ZS5oK2UueSk6ZS5oK2UueT4wJiYodC55PWUueSx0Lmg9dGhpcy5zY2VuZS5oZWlnaHQtZS55KSwhKHQudzw9MHx8dC5oPD0wKSlyZXR1cm4gdH1nZXRTY2VuZVJlY3QoKXtjb25zdHt3aWR0aDplLGhlaWdodDp0fT10aGlzLnNjZW5lO3JldHVybnt4OjAseTowLHc6ZSxoOnR9fWNoZWNrUmlnaHRSZWN0Qm91bmRpbmdCb3goZSl7cmV0dXJuIHRoaXMudk5vZGVzLmNvbWJpbmVJbnRlcnNlY3RSZWN0KGUpfX1jbGFzcyBFeSBleHRlbmRzIEphe2NvbnN0cnVjdG9yKGUsdCxuKXtzdXBlcihlLHQpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJfcG9zdCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJkcmF3TGF5ZXIiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywic25hcHNob3RGdWxsTGF5ZXIiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywic2VydmljZVdvcmsiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywibG9jYWxXb3JrIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksdGhpcy5fcG9zdD1uO2NvbnN0IGk9e3ZpZXdJZDp0aGlzLnZpZXdJZCx2Tm9kZXM6dGhpcy52Tm9kZXMsZnVsbExheWVyOnRoaXMuZnVsbExheWVyLGRyYXdMYXllcjp0aGlzLmRyYXdMYXllcixwb3N0OnRoaXMucG9zdC5iaW5kKHRoaXMpfTt0aGlzLmxvY2FsV29yaz1uZXcgeXkoaSksdGhpcy52Tm9kZXMuaW5pdCh0aGlzLmZ1bGxMYXllcix0aGlzLmRyYXdMYXllcil9YXN5bmMgcG9zdChlLHQpe3ZhciBoO2NvbnN0IG49ZS5yZW5kZXIsaT1bXTtsZXQgZj10O2lmKG4hPW51bGwmJm4ubGVuZ3RoKXtmb3IoY29uc3QgdSBvZiBuKWlmKHUuZHJhd0NhbnZhcyYmdGhpcy5mdWxsTGF5ZXIucGFyZW50LnJlbmRlcigpLHUucmVjdCl7aWYodS5yZWN0PXRoaXMuc2FmYXJpRml4UmVjdChkcih1LnJlY3QpKSwhdS5yZWN0KWNvbnRpbnVlO2lmKHUuZHJhd0NhbnZhcyl7Y29uc3QgYT1hd2FpdCB0aGlzLmdldFJlY3RJbWFnZUJpdG1hcCh1LnJlY3QsISF1LmlzRnVsbFdvcmspO3UuaW1hZ2VCaXRtYXA9YSxmfHwoZj1bXSksZi5wdXNoKGEpfWkucHVzaCh1KX1lLnJlbmRlcj1pfWlmKCgoaD1lLnNwKSE9bnVsbCYmaC5sZW5ndGh8fGUuZHJhd0NvdW50fHxpIT1udWxsJiZpLmxlbmd0aCkmJih0aGlzLl9wb3N0KGUsZiksZiE9bnVsbCYmZi5sZW5ndGgpKWZvcihjb25zdCB1IG9mIGYpdSBpbnN0YW5jZW9mIEltYWdlQml0bWFwJiZ1LmNsb3NlKCl9b24oZSl7Y29uc3R7bXNnVHlwZTp0fT1lO3N3aXRjaCh0KXtjYXNlIFR0LlVwZGF0ZUNhbWVyYTp0aGlzLnVwZGF0ZUNhbWVyYShlKTticmVhaztjYXNlIFR0LlNuYXBzaG90OnRoaXMuc25hcHNob3RGdWxsTGF5ZXI9dGhpcy5jcmVhdGVMYXllcigic25hcHNob3RGdWxsTGF5ZXIiLHRoaXMuc2NlbmUsey4uLnRoaXMub3B0LmxheWVyT3B0LGJ1ZmZlclNpemU6dGhpcy52aWV3SWQ9PT0ibWFpblZpZXciPzZlMzozZTN9KSx0aGlzLnNuYXBzaG90RnVsbExheWVyJiZ0aGlzLmdldFNuYXBzaG90KGUpLnRoZW4oKCk9Pnt0aGlzLnNuYXBzaG90RnVsbExheWVyPXZvaWQgMH0pO2JyZWFrO2Nhc2UgVHQuQm91bmRpbmdCb3g6dGhpcy5zbmFwc2hvdEZ1bGxMYXllcj10aGlzLmNyZWF0ZUxheWVyKCJzbmFwc2hvdEZ1bGxMYXllciIsdGhpcy5zY2VuZSx7Li4udGhpcy5vcHQubGF5ZXJPcHQsYnVmZmVyU2l6ZTp0aGlzLnZpZXdJZD09PSJtYWluVmlldyI/NmUzOjNlM30pLHRoaXMuc25hcHNob3RGdWxsTGF5ZXImJnRoaXMuZ2V0Qm91bmRpbmdSZWN0KGUpLnRoZW4oKCk9Pnt0aGlzLnNuYXBzaG90RnVsbExheWVyPXZvaWQgMH0pO2JyZWFrfXN1cGVyLm9uKGUpfWdldE9mZnNjcmVlbihlKXt2YXIgdDtyZXR1cm4odD0oZSYmdGhpcy5zbmFwc2hvdEZ1bGxMYXllcnx8dGhpcy5mdWxsTGF5ZXIpLnBhcmVudCk9PW51bGw/dm9pZCAwOnQuY2FudmFzfWNvbnN1bWVEcmF3KGUsdCl7ZT09PXp0LkxvY2FsJiZ0aGlzLmxvY2FsV29yay5jb25zdW1lRHJhdyh0KX1jb25zdW1lRHJhd0FsbChlLHQpe3RoaXMubG9jYWxXb3JrLmNvbnN1bWVEcmF3QWxsKHQpfWdldFJlY3RJbWFnZUJpdG1hcChlLHQ9ITEsbil7Y29uc3QgaT1lLngqdGhpcy5kcHIsZj1lLnkqdGhpcy5kcHIsaD1lLncqdGhpcy5kcHIsdT1lLmgqdGhpcy5kcHI7cmV0dXJuIGNyZWF0ZUltYWdlQml0bWFwKHRoaXMuZ2V0T2Zmc2NyZWVuKHQpLGksZixoLHUsbil9c2FmYXJpRml4UmVjdChlKXtpZihlLncrZS54PD0wfHxlLmgrZS55PD0wfHxlLnc8PTB8fGUuaDw9MClyZXR1cm47Y29uc3QgdD17eDowLHk6MCx3OnRoaXMuc2NlbmUud2lkdGgsaDp0aGlzLnNjZW5lLmhlaWdodH07aWYoZS54PDA/ZS53K2UueDx0aGlzLnNjZW5lLndpZHRoJiYodC53PWUudytlLngpOmUudytlLng+MCYmKHQueD1lLngsdC53PXRoaXMuc2NlbmUud2lkdGgtZS54KSxlLnk8MD9lLmgrZS55PHRoaXMuc2NlbmUuaGVpZ2h0JiYodC5oPWUuaCtlLnkpOmUuaCtlLnk+MCYmKHQueT1lLnksdC5oPXRoaXMuc2NlbmUuaGVpZ2h0LWUueSksISh0Lnc8PTB8fHQuaDw9MCkpcmV0dXJuIHR9dXBkYXRlQ2FtZXJhKGUpe2NvbnN0e2NhbWVyYU9wdDp0fT1lO3QmJnRoaXMuc2V0Q2FtZXJhT3B0KHQpfXNldENhbWVyYU9wdChlLHQpe3RoaXMuY2FtZXJhT3B0PWU7Y29uc3R7c2NhbGU6bixjZW50ZXJYOmksY2VudGVyWTpmLHdpZHRoOmgsaGVpZ2h0OnV9PWU7KGghPT10aGlzLnNjZW5lLndpZHRofHx1IT09dGhpcy5zY2VuZS5oZWlnaHQpJiZ0aGlzLnVwZGF0ZVNjZW5lKHt3aWR0aDpoLGhlaWdodDp1fSksdD8odC5zZXRBdHRyaWJ1dGUoInNjYWxlIixbbixuXSksdC5zZXRBdHRyaWJ1dGUoInRyYW5zbGF0ZSIsWy1pLC1mXSkpOih0aGlzLmZ1bGxMYXllci5zZXRBdHRyaWJ1dGUoInNjYWxlIixbbixuXSksdGhpcy5mdWxsTGF5ZXIuc2V0QXR0cmlidXRlKCJ0cmFuc2xhdGUiLFstaSwtZl0pKX1hc3luYyBnZXRTbmFwc2hvdChlKXtjb25zdHtzY2VuZVBhdGg6dCxzY2VuZXM6bixjYW1lcmFPcHQ6aSx3OmYsaH09ZTtpZih0JiZuJiZpJiZ0aGlzLnNuYXBzaG90RnVsbExheWVyKXtjb25zdCB1PWRyKHRoaXMuY2FtZXJhT3B0KTt0aGlzLnNldENhbWVyYU9wdChpLHRoaXMuc25hcHNob3RGdWxsTGF5ZXIpLHRoaXMubG9jYWxXb3JrLmZ1bGxMYXllcj10aGlzLnNuYXBzaG90RnVsbExheWVyLHRoaXMubG9jYWxXb3JrLmRyYXdMYXllcj10aGlzLmZ1bGxMYXllcjtsZXQgYTtmb3IoY29uc3RbcCxPXW9mIE9iamVjdC5lbnRyaWVzKG4pKWlmKE8hPW51bGwmJk8udHlwZSlzd2l0Y2goTz09bnVsbD92b2lkIDA6Ty50eXBlKXtjYXNlIFR0LlVwZGF0ZU5vZGU6Y2FzZSBUdC5GdWxsV29yazp7Y29uc3QgbT10aGlzLmxvY2FsV29yay5ydW5GdWxsV29yayh7Li4uTyx3b3JrSWQ6cCxtc2dUeXBlOlR0LkZ1bGxXb3JrLGRhdGFUeXBlOnp0LlNlcnZpY2Usdmlld0lkOnRoaXMudmlld0lkfSk7YT0kdChhLG0pO2JyZWFrfX10aGlzLmxvY2FsV29yay5mdWxsTGF5ZXI9dGhpcy5mdWxsTGF5ZXIsdGhpcy5sb2NhbFdvcmsuZHJhd0xheWVyPXZvaWQgMDtsZXQgZDtmJiZoJiYoZD17cmVzaXplV2lkdGg6ZixyZXNpemVIZWlnaHQ6aH0pLHRoaXMuc25hcHNob3RGdWxsTGF5ZXIucGFyZW50LnJlbmRlcigpO2NvbnN0IEU9YXdhaXQgdGhpcy5nZXRSZWN0SW1hZ2VCaXRtYXAoe3g6MCx5OjAsdzp0aGlzLnNjZW5lLndpZHRoLGg6dGhpcy5zY2VuZS5oZWlnaHR9LCEwLGQpO0UmJihhd2FpdCB0aGlzLnBvc3Qoe3NwOlt7dHlwZTpUdC5TbmFwc2hvdCxzY2VuZVBhdGg6dCxpbWFnZUJpdG1hcDpFfV19LFtFXSksRS5jbG9zZSgpLHRoaXMuc25hcHNob3RGdWxsTGF5ZXIucmVtb3ZlQWxsQ2hpbGRyZW4oKSx0aGlzLnNldENhbWVyYU9wdCh1LHRoaXMuZnVsbExheWVyKSl9fWFzeW5jIGdldEJvdW5kaW5nUmVjdChlKXtjb25zdHtzY2VuZVBhdGg6dCxzY2VuZXM6bixjYW1lcmFPcHQ6aX09ZTtpZih0JiZuJiZpJiZ0aGlzLnNuYXBzaG90RnVsbExheWVyKXtjb25zdCBmPWRyKHRoaXMuY2FtZXJhT3B0KTt0aGlzLnNldENhbWVyYU9wdChpLHRoaXMuc25hcHNob3RGdWxsTGF5ZXIpLHRoaXMubG9jYWxXb3JrLmZ1bGxMYXllcj10aGlzLnNuYXBzaG90RnVsbExheWVyLHRoaXMubG9jYWxXb3JrLmRyYXdMYXllcj10aGlzLmRyYXdMYXllcjtsZXQgaDtmb3IoY29uc3RbdSxhXW9mIE9iamVjdC5lbnRyaWVzKG4pKWlmKGEhPW51bGwmJmEudHlwZSlzd2l0Y2goYT09bnVsbD92b2lkIDA6YS50eXBlKXtjYXNlIFR0LlVwZGF0ZU5vZGU6Y2FzZSBUdC5GdWxsV29yazp7Y29uc3QgZD10aGlzLmxvY2FsV29yay5ydW5GdWxsV29yayh7Li4uYSx3b3JrSWQ6dSxtc2dUeXBlOlR0LkZ1bGxXb3JrLGRhdGFUeXBlOnp0LlNlcnZpY2Usdmlld0lkOnRoaXMudmlld0lkfSk7aD0kdChoLGQpO2JyZWFrfX1oJiZhd2FpdCB0aGlzLnBvc3Qoe3NwOlt7dHlwZTpUdC5Cb3VuZGluZ0JveCxzY2VuZVBhdGg6dCxyZWN0Omh9XX0pLHRoaXMubG9jYWxXb3JrLmZ1bGxMYXllcj10aGlzLmZ1bGxMYXllcix0aGlzLmxvY2FsV29yay5kcmF3TGF5ZXI9dm9pZCAwLHRoaXMuc25hcHNob3RGdWxsTGF5ZXIucmVtb3ZlQWxsQ2hpbGRyZW4oKSx0aGlzLnNldENhbWVyYU9wdChmLHRoaXMuZnVsbExheWVyKX19fWNvbnN0IE15PXNlbGY7bmV3IHh5KE15LEluLlN1Yil9KSgpOwo=", Kb = typeof window < "u" && window.Blob && new Blob([atob(eZ)], { type: "text/javascript;charset=utf-8" });
function ya(s) {
  let l;
  try {
    if (l = Kb && (window.URL || window.webkitURL).createObjectURL(Kb), !l)
      throw "";
    const d = new Worker(l, {
      name: s == null ? void 0 : s.name
    });
    return d.addEventListener("error", () => {
      (window.URL || window.webkitURL).revokeObjectURL(l);
    }), d;
  } catch {
    return new Worker(
      "data:application/javascript;base64," + eZ,
      {
        name: s == null ? void 0 : s.name
      }
    );
  } finally {
    l && (window.URL || window.webkitURL).revokeObjectURL(l);
  }
}
class Gl {
  constructor() {
    Object.defineProperty(this, "emtType", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "control", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "mainEngine", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "serviceColloctor", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
  }
  static dispatch(l, d, i) {
    var b;
    (b = dl.InternalMsgEmitter) == null || b.emit([l, d], i);
  }
  registerForMainEngine(l, d) {
    return this.emtType = l, this.control = d, this.mainEngine = d.worker, this.serviceColloctor = d.collector, this.mainEngine.internalMsgEmitter.on([this.emtType, this.emitEventType], this.collect.bind(this)), this;
  }
  destroy() {
    this.emtType && this.mainEngine && this.mainEngine.internalMsgEmitter.off([this.emtType, this.emitEventType], this.collect.bind(this));
  }
  collectForLocalWorker(l) {
    var d, i;
    for (const b of l)
      (d = this.mainEngine) == null || d.taskBatchData.add(b);
    (i = this.mainEngine) == null || i.runAnimation();
  }
  collectForServiceWorker(l) {
    Fl(() => {
      l.forEach((d) => {
        var m, o, n;
        (m = this.serviceColloctor) == null || m.dispatch(d);
        const { viewId: i, undoTickerId: b } = d;
        b && i && ((n = (o = this.mainEngine) == null ? void 0 : o.internalMsgEmitter) == null || n.emit("undoTickerEnd", b, i));
      });
    }, this.mainEngine.maxLastSyncTime);
  }
}
class Ia extends Gl {
  constructor() {
    super(...arguments), Object.defineProperty(this, "emitEventType", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: pd.ZIndexActive
    });
  }
  collect(l) {
    if (!this.serviceColloctor || !this.mainEngine)
      return;
    const { workId: d, isActive: i, viewId: b } = l, m = this.control.viewContainerManager.getView(b);
    if (!(m != null && m.displayer))
      return;
    const o = [], n = [];
    d === Ld && o.push({
      workId: d,
      msgType: yd.UpdateNode,
      dataType: Fd.Local,
      isActiveZIndex: i,
      emitEventType: this.emitEventType,
      willRefreshSelector: !0,
      willSyncService: !1,
      viewId: b
    }), o.length && this.collectForLocalWorker(o), n.length && this.collectForServiceWorker(n);
  }
}
class La extends Gl {
  constructor() {
    super(...arguments), Object.defineProperty(this, "emitEventType", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: pd.CopyNode
    });
  }
  collect(l) {
    var h, Y, p, G, y, Z;
    if (!this.serviceColloctor || !this.mainEngine)
      return;
    const { workIds: d, viewId: i } = l, b = this.control.viewContainerManager.getView(i);
    if (!(b != null && b.displayer))
      return;
    const m = b.focusScenePath, o = [...d], n = (h = this.serviceColloctor) == null ? void 0 : h.storage, W = [], e = [], I = Math.floor(Math.random() * 30 + 1);
    let a = [I, I];
    const V = Date.now();
    for (; o.length; ) {
      const X = o.pop();
      if (!X)
        continue;
      const c = X.toString(), t = this.serviceColloctor.isLocalId(c), R = t ? this.serviceColloctor.transformKey(X) : c;
      let S = c;
      !t && this.serviceColloctor.isOwn(S) && (S = this.serviceColloctor.getLocalId(S));
      const J = qd(n[i][m][R]);
      if (J && S === Ld) {
        if (J.selectIds) {
          const H = (Y = b.displayer.canvasBgRef.current) == null ? void 0 : Y.getBoundingClientRect(), L = (G = (p = b.displayer) == null ? void 0 : p.floatBarCanvasRef.current) == null ? void 0 : G.getBoundingClientRect(), C = H && [H.x + H.width / 2, H.y + H.height / 2], F = L && [L.x + L.width / 2, L.y + L.height / 2], r = ((y = b.cameraOpt) == null ? void 0 : y.scale) || 1;
          a = C && F && [(C[0] - F[0] + I) / r, (C[1] - F[1] + I) / r] || [I / r, I / r], o.push(...J.selectIds);
        }
        continue;
      }
      if (J && J.toolsType === Gd.Text && J.opt && J.opt.workState && J.opt.workState !== ud.Done) {
        const H = b.cameraOpt, L = H && [H.centerX, H.centerY], C = J.opt, F = C.boxPoint && C.boxSize && [C.boxPoint[0] + C.boxSize[0] / 2, C.boxPoint[1] + C.boxSize[1] / 2], r = (H == null ? void 0 : H.scale) || 1;
        a = L && F && [L[0] - F[0] + I, L[1] - F[1] + I] || [I / r, I / r];
      }
      if (J) {
        const H = Date.now(), L = (t ? X : this.serviceColloctor.getLocalId(X.toString())) + "-" + H, C = { useAnimation: !1 };
        if (J.toolsType === Gd.Text && J.opt) {
          const F = J.opt;
          if (F && F.boxPoint && F.text) {
            F.workState = ud.Done;
            const r = F.boxPoint;
            F.boxPoint = [r[0] + a[0], r[1] + a[1]], F.workState = ud.Done;
            const K = this.control.viewContainerManager.transformToOriginPoint(F.boxPoint, i);
            this.control.textEditorManager.createTextForMasterController({
              workId: Date.now().toString(),
              x: K[0],
              y: K[1],
              opt: F,
              scale: ((Z = b.cameraOpt) == null ? void 0 : Z.scale) || 1,
              type: Kl.Text,
              isActive: !1,
              viewId: i,
              scenePath: m
            });
          }
          continue;
        }
        if (J.ops) {
          const F = rZ(J.ops).map((K, g) => {
            const v = g % 3;
            return v === 0 ? K + a[0] : v === 1 ? K + a[1] : K;
          }), r = JZ(F);
          J.ops = r, e.push({
            ...J,
            updateNodeOpt: C,
            type: yd.FullWork,
            workId: L,
            undoTickerId: V,
            viewId: i,
            scenePath: m
          }), W.push({
            ...J,
            updateNodeOpt: C,
            workId: L,
            msgType: yd.FullWork,
            dataType: Fd.Local,
            emitEventType: this.emitEventType,
            willSyncService: !1,
            willRefresh: !0,
            viewId: i
          });
        }
      }
    }
    this.mainEngine.internalMsgEmitter.emit("undoTickerStart", V, i), W.length && this.collectForLocalWorker(W), e.length && this.collectForServiceWorker(e);
  }
}
function ti(s, l, d) {
  return "#" + ((s << 16) + (l << 8) + d).toString(16).padStart(6, "0");
}
function jd(s, l = 1) {
  return "rgba(" + parseInt("0x" + s.slice(1, 3)) + "," + parseInt("0x" + s.slice(3, 5)) + "," + parseInt("0x" + s.slice(5, 7)) + "," + l + ")";
}
function Cl(s, l, d, i = 1) {
  return `rgba(${s},${l},${d},${i})`;
}
function Ni(s) {
  const l = s.split(","), d = parseInt(l[0].split("(")[1]), i = parseInt(l[1]), b = parseInt(l[2]), m = Number(l[3].split(")")[0]);
  return [ti(d, i, b), m];
}
function Sb(s) {
  const l = s.split(","), d = parseInt(l[0].split("(")[1]), i = parseInt(l[1]), b = parseInt(l[2]), m = Number(l[3].split(")")[0]);
  return [d, i, b, m];
}
class Ra extends Gl {
  constructor() {
    super(...arguments), Object.defineProperty(this, "emitEventType", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: pd.SetColorNode
    });
  }
  setTextColor(l, d, i, b) {
    const { fontColor: m, fontBgColor: o } = i;
    d.opt && (m && (d.opt.fontColor = m), o && (d.opt.fontColor = o), this.control.textEditorManager.updateTextForMasterController({
      workId: l,
      opt: d.opt,
      viewId: b
    }));
  }
  collect(l) {
    var Y, p;
    if (!this.serviceColloctor || !this.mainEngine)
      return;
    const { workIds: d, strokeColor: i, fillColor: b, fontColor: m, fontBgColor: o, viewId: n } = l, W = this.control.viewContainerManager.getView(n);
    if (!(W != null && W.displayer))
      return;
    const e = W.focusScenePath, I = [...d], a = this.serviceColloctor.storage, V = [], h = Date.now();
    for (; I.length; ) {
      const G = I.pop();
      if (!G)
        continue;
      const y = G.toString(), Z = this.serviceColloctor.isLocalId(y), X = Z ? this.serviceColloctor.transformKey(G) : y;
      let c = y;
      !Z && this.serviceColloctor.isOwn(c) && (c = this.serviceColloctor.getLocalId(c));
      const t = a[n][e][X] || void 0;
      if (t) {
        const R = t.updateNodeOpt || {};
        if (m || o) {
          if (m) {
            R.fontColor = m;
            const [J, H, L, C] = Sb(m);
            (Y = this.control.room) == null || Y.setMemberState({ textColor: [J, H, L], textOpacity: C });
          }
          if (o) {
            R.fontBgColor = o;
            const [J, H, L, C] = Sb(o);
            (p = this.control.room) == null || p.setMemberState({ textBgColor: [J, H, L], textOpacity: C });
          }
          if (t.toolsType === Gd.Text && t.opt) {
            this.setTextColor(c, qd(t), R, n);
            continue;
          }
        }
        i && (R.strokeColor = i), b && (R.fillColor = b);
        const S = {
          workId: c,
          msgType: yd.UpdateNode,
          dataType: Fd.Local,
          updateNodeOpt: R,
          emitEventType: this.emitEventType,
          willRefresh: !0,
          willRefreshSelector: !0,
          willSyncService: !0,
          textUpdateForWoker: !0,
          undoTickerId: h,
          viewId: n
        };
        V.push(S);
      }
    }
    this.mainEngine.internalMsgEmitter.emit("undoTickerStart", h, n), V.length && this.collectForLocalWorker(V);
  }
}
class xa extends Gl {
  constructor() {
    super(...arguments), Object.defineProperty(this, "emitEventType", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: pd.ZIndexNode
    }), Object.defineProperty(this, "min", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "max", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    });
  }
  get minZIndex() {
    return this.min;
  }
  get maxZIndex() {
    return this.max;
  }
  set maxZIndex(l) {
    this.max = l;
  }
  set minZIndex(l) {
    this.min = l;
  }
  addMaxLayer() {
    this.max = this.max + 1;
  }
  addMinLayer() {
    this.min = this.min - 1;
  }
  collect(l) {
    if (!this.serviceColloctor || !this.mainEngine)
      return;
    const { workIds: d, layer: i, viewId: b } = l, m = this.control.viewContainerManager.getView(b);
    if (!(m != null && m.displayer))
      return;
    const o = m.focusScenePath, n = [...d], W = this.serviceColloctor.storage, e = [], I = [];
    for (; n.length; ) {
      const V = n.pop();
      if (!V)
        continue;
      const h = V.toString(), Y = this.serviceColloctor.isLocalId(h), p = Y ? this.serviceColloctor.transformKey(V) : h;
      let G = h;
      !Y && this.serviceColloctor.isOwn(G) && (G = this.serviceColloctor.getLocalId(G));
      const y = qd(W[b][o][p]);
      let Z;
      if (y && G === Ld) {
        if (y.selectIds) {
          I.push(...y.selectIds), I.sort((R, S) => {
            var L, C, F, r;
            const J = ((C = (L = W[a(R, this.serviceColloctor)]) == null ? void 0 : L.opt) == null ? void 0 : C.zIndex) || 0, H = ((r = (F = W[a(R, this.serviceColloctor)]) == null ? void 0 : F.opt) == null ? void 0 : r.zIndex) || 0;
            return J > H ? 1 : R < S ? -1 : 0;
          });
          const X = y.updateNodeOpt || {};
          X.zIndexLayer = i;
          const c = {
            workId: V,
            msgType: yd.UpdateNode,
            dataType: Fd.Local,
            updateNodeOpt: X,
            emitEventType: this.emitEventType,
            willRefreshSelector: !0,
            willSyncService: !0,
            viewId: b
          }, t = /* @__PURE__ */ new Map();
          i === Rl.Top ? (this.addMaxLayer(), Z = this.max) : (this.addMinLayer(), Z = this.min), I.forEach((R) => {
            var L, C, F;
            const S = (L = this.serviceColloctor) == null ? void 0 : L.isLocalId(R);
            let J = S && ((C = this.serviceColloctor) == null ? void 0 : C.transformKey(R)) || R;
            const H = W[b][o][J];
            !S && ((F = this.serviceColloctor) != null && F.isOwn(J)) && (J = this.serviceColloctor.getLocalId(J)), X.zIndex = Z, H != null && H.opt && (H.opt.zIndex = Z), H != null && H.opt && t.set(J, {
              updateNodeOpt: H.updateNodeOpt,
              opt: H.opt
            });
          }), c.selectStore = t, c.willSerializeData = !0, e.push(c);
        }
        continue;
      }
    }
    e.length && this.collectForLocalWorker(e);
    function a(V, h) {
      return h.isLocalId(V) && h.transformKey(V) || V;
    }
  }
}
class Ya extends Gl {
  constructor() {
    super(...arguments), Object.defineProperty(this, "emitEventType", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: pd.TranslateNode
    }), Object.defineProperty(this, "undoTickerId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "oldRect", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "cachePosition", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
  }
  collect(l) {
    var p, G, y, Z;
    if (!this.serviceColloctor || !this.mainEngine)
      return;
    const { workIds: d, position: i, workState: b, viewId: m } = l, o = this.control.viewContainerManager.getView(m);
    if (!(o != null && o.displayer))
      return;
    const n = o.focusScenePath, W = [...d], e = (p = this.serviceColloctor) == null ? void 0 : p.storage, I = [], a = (G = o.displayer.canvasBgRef.current) == null ? void 0 : G.getBoundingClientRect(), V = (Z = (y = o.displayer) == null ? void 0 : y.floatBarCanvasRef.current) == null ? void 0 : Z.getBoundingClientRect();
    let h = !1;
    const Y = b === ud.Start && Date.now() || void 0;
    for (Y && (this.undoTickerId = Y, this.mainEngine.internalMsgEmitter.emit("undoTickerStart", Y, m)), a && V && this.oldRect && (this.oldRect.x < a.x && V.x > this.oldRect.x || this.oldRect.y < a.y && V.y > this.oldRect.y || this.oldRect.x + this.oldRect.width > a.x + a.width && V.x < this.oldRect.x || this.oldRect.y + this.oldRect.height > a.y + a.height && V.y < this.oldRect.y) && (h = !0), V && (this.oldRect = V); W.length; ) {
      const X = W.pop();
      if (!X)
        continue;
      const c = X.toString(), t = this.serviceColloctor.isLocalId(c), R = t && this.serviceColloctor.transformKey(X) || c;
      let S = c;
      !t && this.serviceColloctor.isOwn(S) && (S = this.serviceColloctor.getLocalId(S));
      const J = e[m][n][R];
      if (J && S === Ld) {
        if (J.selectIds && (b === ud.Start && (this.cachePosition = i), this.cachePosition)) {
          const H = J.updateNodeOpt || {};
          H.translate = [i.x - this.cachePosition.x, i.y - this.cachePosition.y], H.workState = b;
          const L = {
            workId: X,
            msgType: yd.UpdateNode,
            dataType: Fd.Local,
            updateNodeOpt: H,
            emitEventType: this.emitEventType,
            willRefreshSelector: h,
            willSyncService: !0,
            textUpdateForWoker: !1,
            viewId: m
          };
          b === ud.Done && (L.textUpdateForWoker = !0, L.willSerializeData = !0, L.undoTickerId = this.undoTickerId, this.cachePosition = void 0), I.push(L);
        }
        continue;
      }
    }
    I.length && this.collectForLocalWorker(I);
  }
}
class Ka extends Gl {
  constructor() {
    super(...arguments), Object.defineProperty(this, "emitEventType", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: pd.DeleteNode
    });
  }
  collect(l) {
    if (!this.serviceColloctor || !this.mainEngine)
      return;
    const { workIds: d, viewId: i } = l, b = this.control.viewContainerManager.getView(i);
    if (!(b != null && b.displayer))
      return;
    const m = b.focusScenePath, o = this.serviceColloctor.storage, n = [...d], W = [], e = [], I = Date.now();
    for (; n.length; ) {
      const a = n.pop();
      if (!a)
        continue;
      const V = a.toString(), h = this.serviceColloctor.isLocalId(V), Y = h ? this.serviceColloctor.transformKey(a) : V, p = o[i][m][Y];
      if (p) {
        let G = V;
        if (!h && this.serviceColloctor.isOwn(G) && (G = this.serviceColloctor.getLocalId(G)), p.toolsType === Gd.Text) {
          this.control.textEditorManager.delete(G, !0, !0);
          continue;
        }
        e.push(G);
      }
    }
    W.push({
      msgType: yd.RemoveNode,
      emitEventType: pd.DeleteNode,
      removeIds: e,
      dataType: Fd.Local,
      willSyncService: !0,
      willRefresh: !0,
      undoTickerId: I,
      viewId: i
    }), this.mainEngine.internalMsgEmitter.emit("undoTickerStart", I, i), W.length && this.collectForLocalWorker(W);
  }
}
class Sa extends Gl {
  constructor() {
    super(...arguments), Object.defineProperty(this, "emitEventType", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: pd.ScaleNode
    }), Object.defineProperty(this, "undoTickerId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
  }
  collect(l) {
    var h;
    if (!this.serviceColloctor || !this.mainEngine)
      return;
    const { workIds: d, box: i, workState: b, viewId: m } = l, o = this.control.viewContainerManager.getView(m);
    if (!(o != null && o.displayer))
      return;
    const n = o.focusScenePath, W = [...d], e = (h = this.serviceColloctor) == null ? void 0 : h.storage, I = [], a = [], V = b === ud.Start && Date.now() || void 0;
    for (V && (this.undoTickerId = V, this.mainEngine.internalMsgEmitter.emit("undoTickerStart", V, m)); W.length; ) {
      const Y = W.pop();
      if (!Y)
        continue;
      const p = Y.toString(), G = this.serviceColloctor.isLocalId(p), y = G && this.serviceColloctor.transformKey(Y) || p;
      let Z = p;
      !G && this.serviceColloctor.isOwn(Z) && (Z = this.serviceColloctor.getLocalId(Z));
      const X = e[m][n][y];
      if (X && Z === Ld && X.selectIds) {
        a.push(...X.selectIds);
        const c = X.updateNodeOpt || {};
        c.box = i, c.workState = b;
        const t = {
          workId: Y,
          msgType: yd.UpdateNode,
          dataType: Fd.Local,
          updateNodeOpt: c,
          emitEventType: this.emitEventType,
          willRefreshSelector: !0,
          willSyncService: !0,
          textUpdateForWoker: !0,
          viewId: m
        };
        b === ud.Done && (t.willSerializeData = !0, t.undoTickerId = this.undoTickerId), I.push(t);
        continue;
      }
    }
    I.length && this.collectForLocalWorker(I);
  }
}
class ra extends Gl {
  constructor() {
    super(...arguments), Object.defineProperty(this, "emitEventType", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: pd.RotateNode
    }), Object.defineProperty(this, "undoTickerId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "cacheOriginRotate", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    });
  }
  collect(l) {
    var V, h, Y, p, G;
    if (!this.serviceColloctor || !this.mainEngine)
      return;
    const { workIds: d, angle: i, workState: b, viewId: m } = l, o = this.control.viewContainerManager.getView(m);
    if (!(o != null && o.displayer))
      return;
    const n = o.focusScenePath, W = [...d], e = (V = this.serviceColloctor) == null ? void 0 : V.storage, I = [], a = b === ud.Start && Date.now() || void 0;
    for (a && (this.undoTickerId = a, this.mainEngine.internalMsgEmitter.emit("undoTickerStart", a, m)); W.length; ) {
      const y = W.pop();
      if (!y)
        continue;
      const Z = y.toString(), X = this.serviceColloctor.isLocalId(Z), c = X && this.serviceColloctor.transformKey(y) || Z;
      let t = Z;
      !X && this.serviceColloctor.isOwn(t) && (t = this.serviceColloctor.getLocalId(t));
      const R = e[m][n][c];
      if (R && t === Ld) {
        if (((h = R.selectIds) == null ? void 0 : h.length) === 1) {
          const S = R.selectIds[0];
          if (b === ud.Start) {
            const C = ((Y = this.serviceColloctor) == null ? void 0 : Y.isLocalId(S)) && ((p = this.serviceColloctor) == null ? void 0 : p.transformKey(S)) || S, F = e[m][n][C];
            this.cacheOriginRotate = ((G = F == null ? void 0 : F.opt) == null ? void 0 : G.rotate) || 0;
          }
          const J = R.updateNodeOpt || {};
          J.angle = (i + this.cacheOriginRotate) % 360, J.workState = b;
          const H = {
            workId: y,
            msgType: yd.UpdateNode,
            dataType: Fd.Local,
            updateNodeOpt: J,
            emitEventType: this.emitEventType,
            willRefreshSelector: !1,
            willSyncService: !0,
            viewId: m
          };
          b === ud.Done && (H.willRefreshSelector = !0, H.willSerializeData = !0, H.undoTickerId = this.undoTickerId, this.cacheOriginRotate = 0), I.push(H);
        }
        continue;
      }
    }
    I.length && this.collectForLocalWorker(I);
  }
}
class Jd {
  constructor(l) {
    Object.defineProperty(this, "builders", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: /* @__PURE__ */ new Map()
    }), this.builders = new Map(l.map((d) => [d, this.build(d)]));
  }
  build(l) {
    switch (l) {
      case pd.TranslateNode:
        return new Ya();
      case pd.ZIndexNode:
        return new xa();
      case pd.ZIndexActive:
        return new Ia();
      case pd.CopyNode:
        return new La();
      case pd.SetColorNode:
        return new Ra();
      case pd.DeleteNode:
        return new Ka();
      case pd.ScaleNode:
        return new Sa();
      case pd.RotateNode:
        return new ra();
    }
  }
  getBuilder(l) {
    return this.builders.get(l);
  }
  registerForMainEngine(l, d) {
    return this.builders.forEach((i) => {
      i && i.registerForMainEngine(l, d);
    }), this;
  }
  destroy() {
    this.builders.forEach((l) => {
      l && l.destroy();
    });
  }
  static emitMethod(l, d, i) {
    Gl.dispatch(l, d, i);
  }
}
class Ja {
  constructor() {
    Object.defineProperty(this, "maxLastSyncTime", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 500
    });
  }
  /** 设置当前选中的工具配置数据 */
  setCurrentToolsData(l) {
    this.currentToolsData = l;
  }
  /** 设置当前绘制任务数据 */
  setCurrentLocalWorkData(l) {
    this.currentLocalWorkData = l;
  }
  /** 获取当前激活的工作任务id */
  getWorkId() {
    return this.currentLocalWorkData.workId;
  }
}
class Ca extends Ja {
  constructor(l) {
    var b, m;
    super(), Object.defineProperty(this, "isActive", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "currentToolsData", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "currentLocalWorkData", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "control", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "internalMsgEmitter", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "viewContainerManager", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "localPointsBatchData", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "taskBatchData", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: /* @__PURE__ */ new Set()
    }), Object.defineProperty(this, "dpr", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 1
    }), Object.defineProperty(this, "fullWorker", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "subWorker", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "methodBuilder", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "zIndexNodeMethod", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "subWorkerDrawCount", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "wokerDrawCount", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "maxDrawCount", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "cacheDrawCount", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "reRenders", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "tasksqueue", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: /* @__PURE__ */ new Map()
    }), Object.defineProperty(this, "useTasksqueue", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "useTasksClockId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "mianTasksqueueCount", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "workerTasksqueueCount", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "snapshotMap", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: /* @__PURE__ */ new Map()
    }), Object.defineProperty(this, "boundingRectMap", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: /* @__PURE__ */ new Map()
    }), Object.defineProperty(this, "clearAllResolve", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "collector", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "localEventTimerId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "undoTickerId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "animationId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
    const { control: d, internalMsgEmitter: i } = l;
    this.control = d, this.collector = this.control.collector, this.maxLastSyncTime = (((m = (b = this.control.pluginOptions) == null ? void 0 : b.syncOpt) == null ? void 0 : m.interval) || this.maxLastSyncTime) * 0.5, this.internalMsgEmitter = i, this.currentLocalWorkData = { workState: ud.Pending };
  }
  init() {
    this.viewContainerManager = this.control.viewContainerManager, this.on(), this.internalMsgEmitterListener(), this.isActive = !0;
  }
  get isRunSubWork() {
    const { toolsType: l } = this.currentToolsData;
    return l === Gd.Pencil || l === Gd.LaserPen || l === Gd.Arrow || l === Gd.Straight || l === Gd.Ellipse || l === Gd.Rectangle || l === Gd.Star || l === Gd.Polygon || l === Gd.SpeechBalloon;
  }
  get isCanDrawWork() {
    const { toolsType: l } = this.currentToolsData;
    return l === Gd.Pencil || l === Gd.LaserPen || l === Gd.Arrow || l === Gd.Straight || l === Gd.Ellipse || l === Gd.Rectangle || l === Gd.Star || l === Gd.Polygon || l === Gd.SpeechBalloon;
  }
  get isUseZIndex() {
    const { toolsType: l } = this.currentToolsData;
    return l === Gd.Pencil || l === Gd.Arrow || l === Gd.Straight || l === Gd.Ellipse || l === Gd.Rectangle || l === Gd.Star || l === Gd.Polygon || l === Gd.SpeechBalloon || l === Gd.Text;
  }
  get isCanRecordUndoRedo() {
    const { toolsType: l } = this.currentToolsData;
    return l === Gd.Pencil || l === Gd.Selector || l === Gd.Eraser || l === Gd.Arrow || l === Gd.Straight || l === Gd.Ellipse || l === Gd.Rectangle || l === Gd.Star || l === Gd.Polygon || l === Gd.SpeechBalloon;
  }
  on() {
    this.fullWorker = new pa(), this.subWorker = new ya(), this.fullWorker.onmessage = (l) => {
      if (l.data) {
        const { render: d, sp: i, drawCount: b, workerTasksqueueCount: m } = l.data;
        if (m && (this.workerTasksqueueCount = m), i != null && i.length && this.collectorSyncData(i), !b && (d != null && d.length)) {
          this.viewContainerManager.render(d);
          return;
        }
        b && (this.wokerDrawCount = b, this.wokerDrawCount < 1 / 0 ? this.maxDrawCount = Math.max(this.maxDrawCount, this.wokerDrawCount) : this.maxDrawCount = 0, d != null && d.length && (this.viewContainerManager.render(d), this.wokerDrawCount < this.subWorkerDrawCount && (this.reRenders.forEach((o) => {
          o.isUnClose = !1;
        }), this.viewContainerManager.render(this.reRenders), this.reRenders.length = 0)));
      }
    }, this.subWorker.onmessage = (l) => {
      if (l.data) {
        const { render: d, drawCount: i, sp: b } = l.data;
        if (b != null && b.length && this.collectorSyncData(b), d != null && d.length, !i && (d != null && d.length)) {
          this.viewContainerManager.render(d);
          return;
        }
        i && (this.subWorkerDrawCount = i, this.wokerDrawCount < 1 / 0 && (this.maxDrawCount = Math.max(this.maxDrawCount, this.subWorkerDrawCount)), d != null && d.length && (this.subWorkerDrawCount > this.wokerDrawCount && (d.forEach((m) => m.isUnClose = !0), this.reRenders.push(...d)), this.wokerDrawCount < 1 / 0 && this.viewContainerManager.render(d)));
      }
    };
  }
  collectorSyncData(l) {
    var i;
    let d = !1;
    for (const b of l) {
      const { type: m, selectIds: o, opt: n, selectRect: W, strokeColor: e, fillColor: I, willSyncService: a, isSync: V, undoTickerId: h, imageBitmap: Y, canvasHeight: p, canvasWidth: G, rect: y, op: Z, canTextEdit: X, selectorColor: c, canRotate: t, scaleType: R, textOpt: S, toolsType: J, workId: H, viewId: L, scenePath: C } = b;
      if (!L) {
        console.error("collectorSyncData", b);
        return;
      }
      switch (m) {
        case yd.Select: {
          const F = o != null && o.length ? { ...W, selectIds: o, canvasHeight: p, canvasWidth: G } : void 0;
          if (F && (n != null && n.strokeColor) && (F.selectorColor = n.strokeColor), F && c && (F.selectorColor = c), F && e && (F.strokeColor = e), F && (n != null && n.fillColor) && (F.fillColor = n.fillColor), F && I && (F.fillColor = I), F && t && (F.canRotate = t), F && R && (F.scaleType = R), F && X && (F.canTextEdit = X), F && S && (F.textOpt = S), L && this.viewContainerManager.showFloatBar(L, !!F, F), a) {
            const r = this.viewContainerManager.getCurScenePath(L);
            this.collector.dispatch({ type: m, selectIds: o, opt: n, isSync: V, viewId: L, scenePath: r });
          }
          break;
        }
        case yd.Snapshot:
          if (Y && C) {
            const F = this.snapshotMap.get(C);
            F && F(Y);
          }
          break;
        case yd.BoundingBox:
          if (y && C) {
            const F = this.boundingRectMap.get(C);
            F && F(y);
          }
          break;
        case yd.Cursor:
          Z && this.control.cursor.collectServiceCursor({ ...b });
          break;
        case yd.Clear:
          L && this.viewContainerManager.showFloatBar(L, !1), L && this.clearAllResolve && this.clearAllResolve(L);
          break;
        case yd.TextUpdate:
          if (J === Gd.Text && H && L) {
            const F = this.viewContainerManager.transformToOriginPoint((n == null ? void 0 : n.boxPoint) || [0, 0], L), r = (n == null ? void 0 : n.boxSize) || [0, 0], K = (i = this.viewContainerManager.getView(L)) == null ? void 0 : i.cameraOpt;
            this.control.textEditorManager.updateTextForWorker({
              x: F[0],
              y: F[1],
              w: r[0],
              h: r[1],
              scale: (K == null ? void 0 : K.scale) || 1,
              workId: H,
              opt: n,
              isDel: !n,
              viewId: L
            });
          }
          break;
        case yd.GetTextActive:
          J === Gd.Text && H && L && this.control.textEditorManager.updateTextForWorker({
            workId: H,
            isActive: !0,
            viewId: L
          });
          break;
        default:
          d = !0;
          break;
      }
      !d && h && this.internalMsgEmitter.emit("undoTickerEnd", h, L);
    }
    d && Fl(() => {
      this.collectorAsyncData(l);
    }, this.maxLastSyncTime);
  }
  collectorAsyncData(l) {
    for (const d of l) {
      const { type: i, op: b, workId: m, index: o, removeIds: n, ops: W, opt: e, updateNodeOpt: I, toolsType: a, isSync: V, undoTickerId: h, viewId: Y } = d;
      if (!Y) {
        console.error("collectorAsyncData", d);
        return;
      }
      switch (i) {
        case yd.DrawWork: {
          const p = this.viewContainerManager.getCurScenePath(Y);
          this.collector.dispatch({
            type: i,
            op: b,
            workId: m,
            index: o,
            isSync: V,
            viewId: Y,
            scenePath: p
          });
          break;
        }
        case yd.FullWork: {
          const p = this.viewContainerManager.getCurScenePath(Y);
          this.collector.dispatch({
            type: i,
            ops: W,
            workId: m,
            updateNodeOpt: I,
            opt: e,
            toolsType: a,
            isSync: V,
            viewId: Y,
            scenePath: p
          });
          break;
        }
        case yd.UpdateNode: {
          const p = this.viewContainerManager.getCurScenePath(Y);
          this.collector.dispatch({ type: i, updateNodeOpt: I, workId: m, opt: e, ops: W, op: b, isSync: V, viewId: Y, scenePath: p });
          break;
        }
        case yd.RemoveNode: {
          const p = this.viewContainerManager.getCurScenePath(Y);
          this.collector.dispatch({ type: i, removeIds: n, isSync: V, viewId: Y, scenePath: p });
          break;
        }
      }
      h && this.internalMsgEmitter.emit("undoTickerEnd", h, Y);
    }
  }
  setCurrentToolsData(l) {
    var m, o, n;
    const d = l.toolsType, i = ((m = this.currentToolsData) == null ? void 0 : m.toolsType) !== l.toolsType;
    super.setCurrentToolsData(l);
    const b = (o = this.viewContainerManager) == null ? void 0 : o.getAllViews();
    if (b != null && b.length) {
      if (this.taskBatchData.add({
        msgType: yd.UpdateTools,
        dataType: Fd.Local,
        toolsType: d,
        opt: { ...l.toolsOpt, syncUnitTime: this.maxLastSyncTime },
        isRunSubWork: this.isRunSubWork,
        viewId: SZ
      }), (n = this.viewContainerManager) != null && n.focuedView) {
        const { id: W, focusScenePath: e } = this.viewContainerManager.focuedView;
        i && W && e && (this.collector.hasSelector(W, e) && this.blurSelector(W, e), this.control.textEditorManager.activeId && this.control.textEditorManager.checkEmptyTextBlur());
      }
      this.runAnimation();
    }
  }
  setCurrentLocalWorkData(l, d = yd.None) {
    super.setCurrentLocalWorkData(l);
    const { workState: i, workId: b, toolsOpt: m } = l;
    if (i !== ud.Unwritable && d !== yd.None && this.viewContainerManager.focuedView) {
      const { id: o } = this.viewContainerManager.focuedView;
      if (o) {
        const n = this.currentToolsData.toolsType;
        this.taskBatchData.add({
          msgType: d,
          workId: b,
          toolsType: n,
          opt: { ...this.currentToolsData.toolsOpt, ...m, syncUnitTime: this.maxLastSyncTime },
          dataType: Fd.Local,
          isRunSubWork: this.isRunSubWork,
          viewId: o
        }), this.runAnimation();
      }
    }
  }
  createViewWorker(l, d) {
    const { offscreenCanvasOpt: i, layerOpt: b, dpr: m, cameraOpt: o } = d;
    this.taskBatchData.add({
      msgType: yd.Init,
      dataType: Fd.Local,
      viewId: l,
      offscreenCanvasOpt: i,
      layerOpt: b,
      dpr: m,
      cameraOpt: o,
      isRunSubWork: !0
    }), this.runAnimation();
  }
  destroyViewWorker(l) {
    this.taskBatchData.add({
      msgType: yd.Destroy,
      dataType: Fd.Local,
      viewId: l,
      isRunSubWork: !0
    }), this.runAnimation(), this.collector.dispatch({
      type: yd.Clear,
      viewId: l
    });
  }
  onServiceDerive(l, d) {
    var I;
    const { newValue: i, oldValue: b, viewId: m, scenePath: o } = d, n = qd(i) || {}, W = l;
    let e = n.type;
    if (!(!i && b && (e = yd.RemoveNode, b.toolsType === Gd.LaserPen))) {
      if (e && W) {
        const a = n;
        if (a.workId = this.collector.isOwn(W) ? this.collector.getLocalId(W) : W, a.msgType = e, a.dataType = Fd.Service, a.viewId = m, a.scenePath = o, a.selectIds && (a.selectIds = a.selectIds.map((V) => this.collector.isOwn(V) ? this.collector.getLocalId(V) : V)), a && a.toolsType === Gd.Text || (b == null ? void 0 : b.toolsType) === Gd.Text) {
          this.control.textEditorManager.onServiceDerive(a);
          return;
        }
        console.log("onServiceDerive", a), this.taskBatchData.add(a);
      }
      if (this.runAnimation(), this.zIndexNodeMethod) {
        let a, V;
        d.newValue && ((I = d.newValue.opt) != null && I.zIndex) && (V = Math.max(V || 0, d.newValue.opt.zIndex), a = Math.min(a || 1 / 0, d.newValue.opt.zIndex)), V && (this.zIndexNodeMethod.maxZIndex = V), a && (this.zIndexNodeMethod.minZIndex = a);
      }
    }
  }
  pullServiceData(l, d) {
    var b, m;
    const i = this.collector.storage[l] && this.collector.storage[l][d] || void 0;
    if (i) {
      let o, n;
      const W = Object.keys(i);
      for (const e of W) {
        const I = (b = i[e]) == null ? void 0 : b.type;
        if (I && e) {
          const a = qd(i[e]);
          if (a.workId = this.collector.isOwn(e) ? this.collector.getLocalId(e) : e, a.msgType = I, a.dataType = Fd.Service, a.viewId = l, a.scenePath = d, a.useAnimation = !1, a.selectIds && (a.selectIds = a.selectIds.map((V) => this.collector.isOwn(V) ? this.collector.getLocalId(V) : V)), a.toolsType === Gd.Text) {
            this.control.textEditorManager.onServiceDerive(a);
            continue;
          }
          this.taskBatchData.add(a), (m = a.opt) != null && m.zIndex && (n = Math.max(n || 0, a.opt.zIndex), o = Math.min(o || 1 / 0, a.opt.zIndex));
        }
        this.internalMsgEmitter.emit("excludeIds", W);
      }
      this.runAnimation(), this.zIndexNodeMethod && (n && (this.zIndexNodeMethod.maxZIndex = n), o && (this.zIndexNodeMethod.minZIndex = o));
    }
  }
  runAnimation() {
    this.animationId || (this.animationId = requestAnimationFrame(this.consume.bind(this)));
  }
  consume() {
    this.animationId = void 0;
    const l = this.currentLocalWorkData.workState;
    let d = !1;
    if (!this.localEventTimerId && (l !== ud.Pending && this.localPointsBatchData.length && (this.wokerDrawCount !== 1 / 0 && this.wokerDrawCount <= this.subWorkerDrawCount && this.cacheDrawCount < this.maxDrawCount && (d = !0), this.maxDrawCount || (d = !0), d && this.viewContainerManager.focuedViewId && (this.taskBatchData.add({
      op: this.localPointsBatchData.map((i) => i),
      workState: l,
      workId: this.currentLocalWorkData.workId,
      dataType: Fd.Local,
      msgType: yd.DrawWork,
      isRunSubWork: this.isRunSubWork,
      undoTickerId: l === ud.Done && this.undoTickerId || void 0,
      viewId: this.viewContainerManager.focuedViewId,
      scenePath: this.viewContainerManager.focuedViewId && this.viewContainerManager.getCurScenePath(this.viewContainerManager.focuedViewId)
    }), this.localPointsBatchData.length = 0, this.cacheDrawCount = this.maxDrawCount)), this.taskBatchData.size)) {
      this.post(this.taskBatchData);
      for (const i of this.taskBatchData.values())
        if (i.msgType === yd.TasksQueue) {
          this.tasksqueue.clear();
          break;
        }
      this.taskBatchData.clear(), this.undoTickerId && l === ud.Done && (this.undoTickerId = void 0);
    }
    this.tasksqueue.size && this.consumeQueue(), (this.tasksqueue.size || this.taskBatchData.size || this.localPointsBatchData.length) && (this.animationId = requestAnimationFrame(this.consume.bind(this)));
  }
  unabled() {
    this.setCurrentLocalWorkData({ workState: ud.Freeze, workId: void 0 });
  }
  abled() {
    this.setCurrentLocalWorkData({ workState: ud.Pending, workId: void 0 });
  }
  post(l) {
    this.fullWorker.postMessage(l);
    const d = /* @__PURE__ */ new Set();
    for (const i of l.values()) {
      const b = i.msgType;
      (b === yd.Init || b === yd.Clear || b === yd.Destroy || b === yd.UpdateCamera || i.isRunSubWork) && d.add(i);
    }
    d.size && this.subWorker.postMessage(d);
  }
  destroy() {
    throw new Error("Method not implemented.");
  }
  updateNode(l, d, i, b) {
    this.taskBatchData.add({
      msgType: yd.UpdateNode,
      workId: l,
      updateNodeOpt: d,
      viewId: i,
      scenePath: b,
      dataType: Fd.Local
    }), this.runAnimation();
  }
  updateCamera(l, d) {
    this.useTasksqueue || (this.useTasksqueue = !0, this.mianTasksqueueCount = 1, this.workerTasksqueueCount = 1), this.useTasksqueue && (this.tasksqueue.set(l, {
      msgType: yd.UpdateCamera,
      dataType: Fd.Local,
      cameraOpt: d,
      isRunSubWork: !0,
      viewId: l
    }), this.control.textEditorManager.onCameraChange(d, l), this.runAnimation(), this.useTasksClockId && clearTimeout(this.useTasksClockId), this.useTasksClockId = setTimeout(() => {
      this.useTasksClockId = void 0, this.tasksqueue.clear(), this.useTasksqueue = !1, this.mianTasksqueueCount = void 0, this.workerTasksqueueCount = void 0;
    }, this.maxLastSyncTime));
  }
  consumeQueue() {
    this.mianTasksqueueCount && this.workerTasksqueueCount && this.mianTasksqueueCount === this.workerTasksqueueCount && (this.mianTasksqueueCount++, this.taskBatchData.add({
      msgType: yd.TasksQueue,
      dataType: Fd.Local,
      isRunSubWork: !0,
      mainTasksqueueCount: this.mianTasksqueueCount,
      tasksqueue: this.tasksqueue,
      viewId: ""
    }));
  }
  async clearViewScenePath(l, d) {
    if (this.control.textEditorManager.clear(l, d), this.taskBatchData.add({
      dataType: Fd.Local,
      msgType: yd.Clear,
      viewId: l
    }), this.runAnimation(), !d) {
      const i = this.viewContainerManager.getCurScenePath(l);
      this.collector.dispatch({
        type: yd.Clear,
        viewId: l,
        scenePath: i
      });
    }
    this.zIndexNodeMethod && (this.zIndexNodeMethod.maxZIndex = 0, this.zIndexNodeMethod.minZIndex = 0), this.localPointsBatchData.length = 0, await new Promise((i) => {
      this.clearAllResolve = i;
    }).then(() => {
      this.clearAllResolve = void 0;
    });
  }
  internalMsgEmitterListener() {
    var l;
    this.collector && (this.methodBuilder = new Jd([
      pd.CopyNode,
      pd.SetColorNode,
      pd.DeleteNode,
      pd.RotateNode,
      pd.ScaleNode,
      pd.TranslateNode,
      pd.ZIndexActive,
      pd.ZIndexNode,
      pd.RotateNode
    ]).registerForMainEngine(rd.MainEngine, this.control), this.zIndexNodeMethod = (l = this.methodBuilder) == null ? void 0 : l.getBuilder(pd.ZIndexNode));
  }
  originalEventLintener(l, d, i) {
    switch (l) {
      case ud.Start:
        this.onLocalEventStart(d, i);
        break;
      case ud.Doing:
        i === this.viewContainerManager.focuedViewId && this.onLocalEventDoing(d);
        break;
      case ud.Done:
        i === this.viewContainerManager.focuedViewId && this.onLocalEventEnd(d);
        break;
    }
  }
  setZIndex() {
    const l = qd(this.currentToolsData.toolsOpt);
    return this.zIndexNodeMethod && this.isUseZIndex && (this.zIndexNodeMethod.addMaxLayer(), l.zIndex = this.zIndexNodeMethod.maxZIndex), l;
  }
  onLocalEventEnd(l) {
    const d = this.currentLocalWorkData.workState;
    if (!(d === ud.Freeze || d === ud.Unwritable) && this.viewContainerManager.focuedView) {
      const { id: i, focusScenePath: b, cameraOpt: m } = this.viewContainerManager.focuedView;
      if (d === ud.Start || d === ud.Doing) {
        const o = this.viewContainerManager.transformToScenePoint(l, i);
        this.pushPoint(o), this.localEventTimerId = setTimeout(() => {
          this.localEventTimerId = void 0, this.setCurrentLocalWorkData({ ...this.currentLocalWorkData, workState: ud.Done }), this.runAnimation();
        }, 0), this.currentToolsData.toolsType === Gd.Selector && this.viewContainerManager.activeFloatBar(i);
      } else if (this.currentToolsData.toolsType === Gd.Text) {
        const o = this.viewContainerManager.transformToScenePoint(l, i);
        if (this.localPointsBatchData[0] === o[0] && this.localPointsBatchData[1] === o[1]) {
          const n = this.currentToolsData.toolsOpt;
          n.workState = ud.Doing, n.boxPoint = o, n.boxSize = [n.fontSize, n.fontSize], this.control.textEditorManager.createTextForMasterController({
            workId: Date.now().toString(),
            x: l[0],
            y: l[1],
            scale: (m == null ? void 0 : m.scale) || 1,
            opt: n,
            type: Kl.Text,
            isActive: !0,
            viewId: i,
            scenePath: b
          });
        }
        this.localPointsBatchData.length = 0;
      }
    }
  }
  onLocalEventDoing(l) {
    let d = this.currentLocalWorkData.workState;
    if (d === ud.Freeze || d === ud.Unwritable)
      return;
    const i = this.viewContainerManager.focuedViewId;
    if (i && (d === ud.Start && (d = ud.Doing, this.setCurrentLocalWorkData({ ...this.currentLocalWorkData, workState: d })), d === ud.Doing || this.localEventTimerId)) {
      const b = this.viewContainerManager.transformToScenePoint(l, i);
      this.pushPoint(b), this.localEventTimerId || this.runAnimation();
    }
  }
  onLocalEventStart(l, d) {
    var n;
    const { workState: i } = this.currentLocalWorkData;
    if (i === ud.Freeze || i === ud.Unwritable || !d)
      return;
    this.viewContainerManager.focuedViewId !== d && this.viewContainerManager.setFocuedViewId(d);
    const b = this.viewContainerManager.transformToScenePoint(l, d);
    if (this.pushPoint(b), this.currentToolsData.toolsType === Gd.Text)
      return;
    this.control.textEditorManager.checkEmptyTextBlur();
    const m = this.currentToolsData.toolsType === Gd.Selector ? Ld : Date.now(), o = this.setZIndex();
    if (this.setCurrentLocalWorkData({
      workId: m,
      workState: ud.Start,
      toolsOpt: o
    }, yd.CreateWork), this.maxDrawCount = 0, this.cacheDrawCount = 0, this.wokerDrawCount = 0, this.subWorkerDrawCount = 0, this.reRenders.length = 0, this.isCanRecordUndoRedo && (this.currentToolsData.toolsType === Gd.Selector ? this.undoTickerId = Date.now() : this.undoTickerId = m, this.internalMsgEmitter.emit("undoTickerStart", this.undoTickerId, d)), this.isCanDrawWork) {
      const W = this.viewContainerManager.getCurScenePath(d);
      (n = this.collector) == null || n.dispatch({
        type: yd.CreateWork,
        workId: m,
        toolsType: this.currentToolsData.toolsType,
        opt: this.currentToolsData.toolsOpt,
        viewId: d,
        scenePath: W
      }), W && this.blurSelector(d, W);
    } else
      this.currentToolsData.toolsType === Gd.Selector && this.viewContainerManager.unActiveFloatBar(d);
    this.consume();
  }
  pushPoint(l) {
    this.localPointsBatchData.push(l[0], l[1]);
  }
  sendCursorEvent(l, d) {
    if (this.currentLocalWorkData.workState === ud.Freeze || this.currentLocalWorkData.workState === ud.Unwritable)
      return;
    let i = [void 0, void 0];
    this.currentToolsData && (this.isCanDrawWork || this.currentToolsData.toolsType === Gd.Text) && this.currentLocalWorkData.workState !== ud.Start && this.currentLocalWorkData.workState !== ud.Doing && (i = l), this.control.cursor.sendEvent(i, d);
  }
  blurSelector(l, d, i) {
    this.collector.hasSelector(l, d) && (this.taskBatchData.add({
      workId: Ld,
      selectIds: [],
      msgType: yd.Select,
      dataType: Fd.Service,
      viewId: l,
      scenePath: d,
      undoTickerId: i
    }), this.runAnimation());
  }
  getBoundingRect(l) {
    var i;
    if (!((i = this.boundingRectMap) == null ? void 0 : i.get(l))) {
      const b = this.collector.getScenePathData(l);
      if (!b)
        return;
      if (Object.keys(b).forEach((m) => {
        this.collector.getLocalId(m) === Ld && delete b[m];
      }), Object.keys(b).length && this.viewContainerManager.mainView) {
        const m = {
          msgType: yd.BoundingBox,
          dataType: Fd.Local,
          scenePath: l,
          scenes: b,
          cameraOpt: this.viewContainerManager.mainView.cameraOpt,
          isRunSubWork: !0,
          viewId: this.viewContainerManager.mainView.id
        };
        return this.taskBatchData.add(m), this.runAnimation(), new Promise((o) => {
          this.boundingRectMap.set(l, o);
        }).then((o) => (this.boundingRectMap.delete(l), o));
      }
    }
  }
  getSnapshot(l, d, i, b) {
    var o, n, W;
    if (!((o = this.snapshotMap) == null ? void 0 : o.get(l))) {
      const e = this.collector.getViewIdBySecenPath(l);
      if (!e)
        return;
      const I = this.collector.getStorageData(e, l);
      if (!I)
        return;
      if (Object.keys(I).forEach((a) => {
        this.collector.getLocalId(a) === Ld && delete I[a];
      }), Object.keys(I).length) {
        const a = this.viewContainerManager.getView(e) || this.viewContainerManager.focuedView;
        if (!a)
          return;
        const V = d || ((n = a.cameraOpt) == null ? void 0 : n.width), h = i || ((W = a.cameraOpt) == null ? void 0 : W.height), Y = {
          msgType: yd.Snapshot,
          dataType: Fd.Local,
          scenePath: l,
          scenes: I,
          w: V,
          h,
          cameraOpt: b && {
            ...b,
            width: V,
            height: h
          } || a.cameraOpt,
          isRunSubWork: !0,
          viewId: e
        };
        return this.taskBatchData.add(Y), this.runAnimation(), new Promise((p) => {
          this.snapshotMap.set(l, p);
        }).then((p) => (this.snapshotMap.delete(l), p));
      }
    }
  }
}
var Fa = sl, Ha = function() {
  return Fa.Date.now();
}, Ta = Ha, Na = /\s/;
function ga(s) {
  for (var l = s.length; l-- && Na.test(s.charAt(l)); )
    ;
  return l;
}
var ka = ga, za = ka, Ma = /^\s+/;
function Ua(s) {
  return s && s.slice(0, za(s) + 1).replace(Ma, "");
}
var Qa = Ua, va = Tl, Pa = Il, wa = "[object Symbol]";
function fa(s) {
  return typeof s == "symbol" || Pa(s) && va(s) == wa;
}
var Ea = fa, Ba = Qa, rb = yl, ja = Ea, Jb = NaN, Oa = /^[-+]0x[0-9a-f]+$/i, Da = /^0b[01]+$/i, Aa = /^0o[0-7]+$/i, qa = parseInt;
function $a(s) {
  if (typeof s == "number")
    return s;
  if (ja(s))
    return Jb;
  if (rb(s)) {
    var l = typeof s.valueOf == "function" ? s.valueOf() : s;
    s = rb(l) ? l + "" : l;
  }
  if (typeof s != "string")
    return s === 0 ? s : +s;
  s = Ba(s);
  var d = Da.test(s);
  return d || Aa.test(s) ? qa(s.slice(2), d ? 2 : 8) : Oa.test(s) ? Jb : +s;
}
var _a = $a, de = yl, ai = Ta, Cb = _a, le = "Expected a function", ie = Math.max, be = Math.min;
function Ze(s, l, d) {
  var i, b, m, o, n, W, e = 0, I = !1, a = !1, V = !0;
  if (typeof s != "function")
    throw new TypeError(le);
  l = Cb(l) || 0, de(d) && (I = !!d.leading, a = "maxWait" in d, m = a ? ie(Cb(d.maxWait) || 0, l) : m, V = "trailing" in d ? !!d.trailing : V);
  function h(R) {
    var S = i, J = b;
    return i = b = void 0, e = R, o = s.apply(J, S), o;
  }
  function Y(R) {
    return e = R, n = setTimeout(y, l), I ? h(R) : o;
  }
  function p(R) {
    var S = R - W, J = R - e, H = l - S;
    return a ? be(H, m - J) : H;
  }
  function G(R) {
    var S = R - W, J = R - e;
    return W === void 0 || S >= l || S < 0 || a && J >= m;
  }
  function y() {
    var R = ai();
    if (G(R))
      return Z(R);
    n = setTimeout(y, p(R));
  }
  function Z(R) {
    return n = void 0, V && i ? h(R) : (i = b = void 0, o);
  }
  function X() {
    n !== void 0 && clearTimeout(n), e = 0, i = W = b = n = void 0;
  }
  function c() {
    return n === void 0 ? o : Z(ai());
  }
  function t() {
    var R = ai(), S = G(R);
    if (i = arguments, b = this, W = R, S) {
      if (n === void 0)
        return Y(W);
      if (a)
        return clearTimeout(n), n = setTimeout(y, l), h(W);
    }
    return n === void 0 && (n = setTimeout(y, l)), o;
  }
  return t.cancel = X, t.flush = c, t;
}
var ce = Ze, se = ce, me = yl, te = "Expected a function";
function Xe(s, l, d) {
  var i = !0, b = !0;
  if (typeof s != "function")
    throw new TypeError(te);
  return me(d) && (i = "leading" in d ? !!d.leading : i, b = "trailing" in d ? !!d.trailing : b), se(s, l, {
    leading: i,
    maxWait: l,
    trailing: b
  });
}
var ne = Xe;
const Ad = /* @__PURE__ */ Pl(ne);
class dl {
  constructor(l, d) {
    var b, m;
    Object.defineProperty(this, "plugin", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "room", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "pluginOptions", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "roomMember", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "collector", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "cursor", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "textEditorManager", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "worker", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "onSceneChange", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (o, n) => {
        var I;
        const W = (I = this.viewContainerManager.getView(n)) == null ? void 0 : I.focusScenePath;
        W && this.worker.blurSelector(n, W);
        const e = o;
        e && this.viewContainerManager.setViewScenePath(n, e);
      }
    }), Object.defineProperty(this, "onRoomMembersChange", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (o) => {
        this.roomMember.setRoomMembers(kb(o));
      }
    }), Object.defineProperty(this, "onMemberChange", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: Ad((o) => {
        if (!this.room || !this.worker)
          return;
        const n = this.getToolsKey(o), W = this.getToolsOpt(n, o);
        this.worker.setCurrentToolsData(W), this.effectViewContainer(n);
      }, 100, { leading: !1 })
    }), Object.defineProperty(this, "internalSceneChange", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (o, n) => {
        var W;
        (W = this.worker) == null || W.clearViewScenePath(o, !0).then(() => {
          var e;
          (e = this.worker) == null || e.pullServiceData(o, n);
        });
      }
    }), Object.defineProperty(this, "internalCameraChange", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (o, n) => {
        var W;
        (W = this.worker) == null || W.updateCamera(o, n);
      }
    }), this.plugin = l, this.room = ml(l.displayer) ? l.displayer : void 0, this.pluginOptions = d, this.roomMember = new ua(), this.collector = new ol(l, (m = (b = this.pluginOptions) == null ? void 0 : b.syncOpt) == null ? void 0 : m.interval);
    const i = {
      control: this,
      internalMsgEmitter: dl.InternalMsgEmitter
    };
    this.cursor = new ha(i), this.textEditorManager = new Va(i), this.worker = new Ca(i);
  }
  /** 销毁 */
  destroy() {
    var l, d, i, b, m;
    this.roomMember.destroy(), (l = this.collector) == null || l.destroy(), (d = this.worker) == null || d.destroy(), (i = this.viewContainerManager) == null || i.destroy(), (b = this.cursor) == null || b.destroy(), (m = this.textEditorManager) == null || m.destory();
  }
  /** 清空当前获焦路径下的所有内容 */
  cleanCurrentScene() {
    const l = Date.now(), d = this.viewContainerManager.focuedViewId;
    d && (dl.InternalMsgEmitter.emit("undoTickerStart", l, d), this.worker.clearViewScenePath(d).then(() => {
      dl.InternalMsgEmitter.emit("undoTickerEnd", l, d);
    }));
  }
  /** 监听读写状态变更 */
  onWritableChange(l) {
    var d, i;
    l ? (i = this.worker) == null || i.abled() : (d = this.worker) == null || d.unabled();
  }
  /** 获取当前工具key */
  getToolsKey(l) {
    switch (l.currentApplianceName) {
      case gd.text:
        return Gd.Text;
      case gd.pencil:
        if (l.useNewPencil)
          return Gd.Pencil;
        if (l.useLaserPen)
          return Gd.LaserPen;
        break;
      case gd.eraser:
      case gd.pencilEraser:
        return Gd.Eraser;
      case gd.selector:
        return Gd.Selector;
      case gd.arrow:
        return Gd.Arrow;
      case gd.straight:
        return Gd.Straight;
      case gd.ellipse:
        return Gd.Ellipse;
      case gd.rectangle:
        return Gd.Rectangle;
      case gd.shape:
        if (l.shapeType === ll.Pentagram || l.shapeType === ll.Star)
          return Gd.Star;
        if (l.shapeType === ll.Polygon || l.shapeType === ll.Triangle || l.shapeType === ll.Rhombus)
          return Gd.Polygon;
        if (l.shapeType === ll.SpeechBalloon)
          return Gd.SpeechBalloon;
        break;
    }
    return Gd.Clicker;
  }
  /** 获取当前工具默认配置 */
  getToolsOpt(l, d) {
    const i = d.currentApplianceName, b = {
      strokeColor: Cl(d.strokeColor[0], d.strokeColor[1], d.strokeColor[2], d.strokeOpacity || 1),
      thickness: d.strokeWidth,
      isOpacity: (d == null ? void 0 : d.strokeOpacity) && d.strokeOpacity < 1 || (d == null ? void 0 : d.fillOpacity) && d.fillOpacity < 1 || (d == null ? void 0 : d.textOpacity) && d.textOpacity < 1 || (d == null ? void 0 : d.textBgOpacity) && d.textBgOpacity < 1 || !1
    };
    switch (l) {
      case Gd.Text:
        b.fontSize = (d == null ? void 0 : d.textSize) || Number(window.getComputedStyle(document.body).fontSize), b.textAlign = (d == null ? void 0 : d.textAlign) || "left", b.verticalAlign = (d == null ? void 0 : d.verticalAlign) || "middle", b.fontColor = (d == null ? void 0 : d.textColor) && Cl(d.textColor[0], d.textColor[1], d.textColor[2], d.textOpacity || 1) || b.strokeColor || "rgba(0,0,0,1)", b.fontBgColor = Array.isArray(d == null ? void 0 : d.textBgColor) && Cl(d.textBgColor[0], d.textBgColor[1], d.textBgColor[2], d.textBgOpacity || 1) || "transparent", b.fontWeight = (d == null ? void 0 : d.bold) && "bold" || void 0, b.fontStyle = (d == null ? void 0 : d.italic) && "italic" || void 0, b.underline = (d == null ? void 0 : d.underline) || void 0, b.lineThrough = (d == null ? void 0 : d.lineThrough) || void 0, b.text = "", b.strokeColor = void 0;
        break;
      case Gd.Pencil:
        b.strokeType = (d == null ? void 0 : d.strokeType) || Ol.Normal;
        break;
      case Gd.Eraser:
        b.thickness = Math.min(3, Math.max(1, Math.floor(d.pencilEraserSize || 1))) - 1, b.isLine = i === gd.eraser && !0;
        break;
      case Gd.LaserPen:
        b.duration = (d == null ? void 0 : d.duration) || 1, b.strokeType = (d == null ? void 0 : d.strokeType) || Ol.Normal;
        break;
      case Gd.Ellipse:
      case Gd.Rectangle:
      case Gd.Star:
      case Gd.Polygon:
      case Gd.SpeechBalloon:
        l === Gd.Star && (d.shapeType === ll.SpeechBalloon ? b.placement = "bottomLeft" : d.shapeType === ll.Pentagram ? (b.vertices = 10, b.innerVerticeStep = 2, b.innerRatio = 0.4) : d != null && d.vertices && (d != null && d.innerVerticeStep) && (d != null && d.innerRatio) && (b.vertices = d.vertices, b.innerVerticeStep = d.innerVerticeStep, b.innerRatio = d.innerRatio)), l === Gd.Polygon && (d.shapeType === ll.Triangle ? b.vertices = 3 : d.shapeType === ll.Rhombus ? b.vertices = 4 : d.vertices && (b.vertices = d.vertices)), b.fillColor = (d == null ? void 0 : d.fillColor) && Cl(d.fillColor[0], d.fillColor[1], d.fillColor[2], d == null ? void 0 : d.fillOpacity) || "transparent", l !== Gd.Rectangle && (b.textOpt = {
          strokeColor: b.strokeColor,
          fontSize: (d == null ? void 0 : d.textSize) || Number(window.getComputedStyle(document.body).fontSize),
          textAlign: (d == null ? void 0 : d.textAlign) || "left",
          verticalAlign: (d == null ? void 0 : d.verticalAlign) || "middle",
          fontColor: (d == null ? void 0 : d.textColor) && Cl(d.textColor[0], d.textColor[1], d.textColor[2], d.textOpacity || 1) || "rgba(0,0,0,1)",
          fontBgColor: Array.isArray(d == null ? void 0 : d.textBgColor) && Cl(d.textBgColor[0], d.textBgColor[1], d.textBgColor[2], d.textBgOpacity || 1) || "transparent",
          fontWeight: (d == null ? void 0 : d.bold) && "bold" || void 0,
          fontStyle: (d == null ? void 0 : d.italic) && "italic" || void 0,
          underline: (d == null ? void 0 : d.underline) || void 0,
          lineThrough: (d == null ? void 0 : d.lineThrough) || void 0,
          text: ""
        });
        break;
    }
    return {
      toolsType: l,
      toolsOpt: b
    };
  }
  /** 激活当前view容器*/
  effectViewContainer(l) {
    var d, i, b, m, o;
    switch (l) {
      case Gd.Text:
      case Gd.Pencil:
      case Gd.LaserPen:
      case Gd.Arrow:
      case Gd.Straight:
      case Gd.Rectangle:
      case Gd.Ellipse:
      case Gd.Star:
      case Gd.Polygon:
      case Gd.SpeechBalloon:
        this.room.disableDeviceInputs = !0, (d = this.worker) == null || d.abled(), setTimeout(() => {
          this.viewContainerManager.getAllViews().forEach((W) => {
            W != null && W.displayer && W.displayer.bindToolsClass();
          });
        }, 0);
        break;
      case Gd.Eraser:
      case Gd.Selector:
        this.room.disableDeviceInputs = !1, (i = this.cursor) == null || i.unable(), (b = this.worker) == null || b.abled();
        break;
      default:
        this.room.disableDeviceInputs = !1, (m = this.worker) == null || m.unabled(), (o = this.cursor) == null || o.unable();
        break;
    }
  }
  /** 异步获取指定路径下绘制内容的区域大小 */
  async getBoundingRect(l) {
    var i;
    const d = await ((i = this.worker) == null ? void 0 : i.getBoundingRect(l));
    if (d)
      return {
        width: d.w,
        height: d.h,
        originX: d.x,
        originY: d.y
      };
  }
  /** 异步获取指定路径下的的快照并绘制到指定的画布上 */
  async screenshotToCanvas(l, d, i, b, m) {
    const o = await this.worker.getSnapshot(d, i, b, m);
    o && (l.drawImage(o, 0, 0), o.close());
  }
  /** 异步获取指定路径下的缩略图 */
  async scenePreview(l, d) {
    var o, n, W;
    const i = this.collector.getViewIdBySecenPath(l);
    if (!i)
      return;
    const b = this.viewContainerManager.getView(i);
    if (!b || !((o = b.cameraOpt) != null && o.width) || !((n = b.cameraOpt) != null && n.height))
      return;
    const m = await ((W = this.worker) == null ? void 0 : W.getSnapshot(l));
    if (m && this.worker) {
      const e = document.createElement("canvas"), I = e.getContext("2d"), { width: a, height: V } = b.cameraOpt;
      e.width = a, e.height = V, I && (I.drawImage(m, 0, 0), d.src = e.toDataURL(), d.onload = () => {
        e.remove();
      }, d.onerror = () => {
        e.remove(), d.remove();
      }), m.close();
    }
  }
}
Object.defineProperty(dl, "InternalMsgEmitter", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: new gb()
});
var We = oZ, oe = 4;
function ae(s) {
  return We(s, oe);
}
var ee = ae;
const Fb = /* @__PURE__ */ Pl(ee);
var vl;
(function(s) {
  s[s.sdk = 1] = "sdk", s[s.plugin = 2] = "plugin", s[s.both = 3] = "both";
})(vl || (vl = {}));
var Vl;
(function(s) {
  s[s.Draw = 1] = "Draw", s[s.Delete = 2] = "Delete", s[s.Update = 3] = "Update";
})(Vl || (Vl = {}));
class Sl {
  constructor(l) {
    Object.defineProperty(this, "emitter", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new gb()
    }), Object.defineProperty(this, "undoStack", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "redoStack", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "worker", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "collector", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "control", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "room", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "isTicking", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "undoTickerId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "viewId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "scenePath", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "tickStartStorerCache", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "excludeIds", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: /* @__PURE__ */ new Set()
    }), Object.defineProperty(this, "undoTickerEnd", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: RZ((m, o, n) => {
        if (m === this.undoTickerId && n === this.scenePath && o === this.viewId && this.tickStartStorerCache) {
          const W = this.collector.storage[o] && this.collector.storage[o][n] || {}, e = this.diffFun(this.tickStartStorerCache, new Map(Object.entries(W)));
          e.size && (this.undoStack.push({
            id: m,
            type: vl.plugin,
            data: e,
            scenePath: n
          }), this.undoStack.length > Sl.MaxStackLength && this.undoStack.shift(), this.emitter.emit("onCanUndoStepsUpdate", this.undoStack.length)), this.redoStack.length && (this.redoStack.length = 0, this.emitter.emit("onCanRedoStepsUpdate", this.redoStack.length));
        }
        this.isTicking = !1, this.scenePath = void 0, this.tickStartStorerCache = void 0, this.undoTickerId = void 0, this.excludeIds.clear();
      }, Sl.waitTime)
    });
    const { control: d, internalMsgEmitter: i, viewId: b } = l;
    this.control = d, this.emitter = i, this.undoStack = [], this.redoStack = [], this.room = d.room, this.worker = d.worker, this.collector = d.collector, this.isTicking = !1, this.viewId = b;
  }
  addExcludeIds(l) {
    if (this.isTicking)
      for (const d of l)
        this.excludeIds.add(d);
  }
  undoTickerStart(l, d) {
    this.isTicking = !0, this.excludeIds.clear(), this.undoTickerId = l, this.scenePath = d;
    const i = this.collector.storage[this.viewId] && this.collector.storage[this.viewId][d] || {};
    this.tickStartStorerCache = new Map(Object.entries(xZ(i)));
  }
  undo(l) {
    let d = this.undoStack.length - 1;
    for (; d >= 0; ) {
      if (this.undoStack[d].scenePath === l) {
        const o = this.undoStack[d];
        o && (this.redoStack.push(o), o.type === vl.plugin && o.data && this.refreshPlugin(o)), this.undoStack.splice(d, 1);
        break;
      }
      d--;
    }
    const i = this.undoStack.filter((m) => m.scenePath === l).length, b = this.redoStack.filter((m) => m.scenePath === l).length;
    return this.emitter.emit("onCanUndoStepsUpdate", i), this.emitter.emit("onCanRedoStepsUpdate", b), i;
  }
  redo(l) {
    let d = this.redoStack.length - 1;
    for (; d > 0; ) {
      if (this.redoStack[d].scenePath === l) {
        const o = this.redoStack[d];
        o && (this.undoStack.push(o), o.type === vl.plugin && o.data && this.refreshPlugin(o, !0)), this.redoStack.splice(d, 1);
        break;
      }
      d--;
    }
    const i = this.undoStack.filter((m) => m.scenePath === l).length, b = this.redoStack.filter((m) => m.scenePath === l).length;
    return this.emitter.emit("onCanUndoStepsUpdate", i), this.emitter.emit("onCanRedoStepsUpdate", b), b;
  }
  clear() {
    this.clearUndo(), this.clearRedo();
  }
  clearUndo() {
    this.undoStack.length = 0, this.emitter.emit("onCanUndoStepsUpdate", this.undoStack.length);
  }
  clearRedo() {
    this.redoStack.length = 0, this.emitter.emit("onCanRedoStepsUpdate", this.redoStack.length);
  }
  canUndo() {
    return !!this.undoStack.length;
  }
  canRedo() {
    return !!this.redoStack.length;
  }
  diffFun(l, d) {
    const i = /* @__PURE__ */ new Set(), b = l.keys(), m = d.keys();
    for (const o of b) {
      if (this.excludeIds.has(o))
        continue;
      const n = l.get(o), W = d.get(o);
      if (n && W) {
        if (YZ(W, n))
          continue;
        i.add({
          dataType: Vl.Update,
          key: o,
          data: [n, W]
        });
        continue;
      }
      n && i.add({
        dataType: Vl.Delete,
        key: o,
        data: n
      });
    }
    for (const o of m) {
      const n = d.get(o);
      n && !l.has(o) && i.add({
        dataType: Vl.Draw,
        key: o,
        data: n
      });
    }
    return i;
  }
  isDrawEffectiveScene(l, d) {
    const { key: i } = l;
    return !d.includes(i);
  }
  isDeleteEffectiveScene(l, d, i) {
    var o;
    const { key: b } = l;
    if (!d.includes(b))
      return !1;
    const m = d.filter((n) => this.collector.getLocalId(n) === Ld && !this.collector.isOwn(n)).map((n) => this.collector.storage[this.viewId][i][n]);
    for (const n of m)
      if ((o = n == null ? void 0 : n.selectIds) != null && o.includes(b))
        return !1;
    return !0;
  }
  isOldEffectiveScene(l, d, i) {
    var o;
    const { key: b } = l;
    if (!d.includes(b))
      return !1;
    const m = d.filter((n) => this.collector.getLocalId(n) === Ld && !this.collector.isOwn(n)).map((n) => this.collector.storage[this.viewId][i][n]);
    for (const n of m)
      if ((o = n == null ? void 0 : n.selectIds) != null && o.includes(b))
        return !1;
    return !0;
  }
  isNewEffectiveScene(l, d) {
    const { key: i } = l;
    return !!d.includes(i);
  }
  refreshPlugin(l, d = !1) {
    var o, n, W, e, I, a, V;
    let i;
    const { scenePath: b } = l, m = l.data;
    if (m)
      for (const h of m.values()) {
        const { dataType: Y, data: p, key: G } = h, y = Object.keys(this.collector.storage[this.viewId][b]);
        switch (Y) {
          case Vl.Draw:
            if (i = d ? this.isDrawEffectiveScene(h, y) : this.isDeleteEffectiveScene(h, y, b), i)
              if (d && !Array.isArray(p)) {
                if ((o = p.updateNodeOpt) != null && o.useAnimation && (p.updateNodeOpt.useAnimation = !1), this.collector.getLocalId(G) === Ld && this.collector.isOwn(h.key)) {
                  const Z = p.selectIds;
                  if (Z) {
                    const X = y.filter((t) => this.collector.getLocalId(t) === Ld && !this.collector.isOwn(t)).map((t) => this.collector.storage[this.viewId][b][t]);
                    let c = !1;
                    for (const t of X)
                      for (let R = 0; R < Z.length; R++)
                        (n = t == null ? void 0 : t.selectIds) != null && n.includes(Z[R]) && (delete Z[R], c = !0);
                    c && (p.selectIds = Z.filter((t) => !!t));
                  }
                }
                this.collector.updateValue(h.key, p, { isAfterUpdate: !0, viewId: this.viewId, scenePath: b });
              } else
                !d && !Array.isArray(h.data) && this.collector.updateValue(h.key, void 0, { isAfterUpdate: !0, viewId: this.viewId, scenePath: b });
            break;
          case Vl.Delete:
            if (i = d ? this.isDeleteEffectiveScene(h, y, b) : this.isDrawEffectiveScene(h, y), i) {
              if (d && !Array.isArray(p))
                this.collector.updateValue(G, void 0, { isAfterUpdate: !0, viewId: this.viewId, scenePath: b });
              else if (!d && !Array.isArray(p)) {
                if ((W = p.updateNodeOpt) != null && W.useAnimation && (p.updateNodeOpt.useAnimation = !1), this.collector.getLocalId(h.key) === Ld && this.collector.isOwn(h.key)) {
                  const Z = p.selectIds;
                  if (Z) {
                    const X = y.filter((t) => this.collector.getLocalId(t) === Ld && !this.collector.isOwn(t)).map((t) => this.collector.storage[this.viewId][b][t]);
                    let c = !1;
                    for (const t of X)
                      for (let R = 0; R < Z.length; R++)
                        (e = t == null ? void 0 : t.selectIds) != null && e.includes(Z[R]) && (delete Z[R], c = !0);
                    c && (p.selectIds = Z.filter((t) => !!t));
                  }
                }
                this.collector.updateValue(h.key, h.data, { isAfterUpdate: !0, viewId: this.viewId, scenePath: b });
              }
            }
            break;
          case Vl.Update:
            if (i = d ? this.isNewEffectiveScene(h, y) : this.isOldEffectiveScene(h, y, b), i) {
              if (d && Array.isArray(p) && p.length === 2) {
                const Z = p[1];
                if ((I = Z.updateNodeOpt) != null && I.useAnimation && (Z.updateNodeOpt.useAnimation = !1), this.collector.getLocalId(h.key) === Ld && this.collector.isOwn(h.key)) {
                  const X = Z.selectIds;
                  if (X) {
                    const c = y.filter((R) => this.collector.getLocalId(R) === Ld && !this.collector.isOwn(R)).map((R) => this.collector.storage[this.viewId][b][R]);
                    let t = !1;
                    for (const R of c)
                      for (let S = 0; S < X.length; S++)
                        R != null && R.selectIds && ((a = R.selectIds) != null && a.includes(X[S])) && (delete X[S], t = !0);
                    t && (Z.selectIds = X.filter((R) => !!R));
                  }
                }
                this.collector.updateValue(G, Z, { isAfterUpdate: !0, viewId: this.viewId, scenePath: b });
              } else if (!d && Array.isArray(p) && p.length === 2) {
                const Z = p[0];
                if ((V = Z.updateNodeOpt) != null && V.useAnimation && (Z.updateNodeOpt.useAnimation = !1), this.collector.getLocalId(h.key) === Ld && this.collector.isOwn(h.key)) {
                  const X = Z.selectIds;
                  if (X) {
                    const c = y.filter((R) => this.collector.getLocalId(R) === Ld && !this.collector.isOwn(R)).map((R) => this.collector.storage[this.viewId][b][R]);
                    let t = !1;
                    for (const R of c)
                      for (let S = 0; S < X.length; S++)
                        R != null && R.selectIds && R.selectIds.includes(X[S]) && (delete X[S], t = !0);
                    t && (Z.selectIds = X.filter((R) => !!R));
                  }
                }
                this.collector.updateValue(h.key, Z, { isAfterUpdate: !0, viewId: this.viewId, scenePath: b });
              }
            }
            break;
        }
      }
  }
}
Object.defineProperty(Sl, "MaxStackLength", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 20
});
Object.defineProperty(Sl, "waitTime", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 100
});
class wl {
  constructor(l) {
    Object.defineProperty(this, "internalMsgEmitter", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "control", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "mainView", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "appViews", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: /* @__PURE__ */ new Map()
    });
    const { control: d, internalMsgEmitter: i } = l;
    this.control = d, this.internalMsgEmitter = i, this.internalMsgEmitter.on("undoTickerStart", this.undoTickerStart.bind(this)), this.internalMsgEmitter.on("undoTickerEnd", this.undoTickerEnd.bind(this)), this.internalMsgEmitter.on("excludeIds", this.addExcludeIds.bind(this));
  }
  undoTickerStart(l, d) {
    const i = this.getView(d);
    i && i.displayer && i.focusScenePath && i.displayer.commiter.undoTickerStart(l, i.focusScenePath);
  }
  undoTickerEnd(l, d) {
    const i = this.getView(d);
    i && i.displayer && i.focusScenePath && i.displayer.commiter.undoTickerEnd(l, d, i.focusScenePath);
  }
  addExcludeIds(l, d) {
    const i = this.getView(d);
    i && i.displayer && i.focusScenePath && i.displayer.commiter.addExcludeIds(l);
  }
  undo() {
    const l = this.focuedView;
    let d = 0;
    if (l) {
      const i = l.focusScenePath;
      d = l.displayer.commiter.undo(i) || 0;
    }
    return d;
  }
  redo() {
    const l = this.focuedView;
    let d = 0;
    if (l) {
      const i = l.focusScenePath;
      d = l.displayer.commiter.redo(i) || 0;
    }
    return d;
  }
  validator(l, d, i) {
    const b = Fb(l[d]), m = Fb(i);
    if (d === "focusScenePath" && i && !_d(b, m) && this.control.internalSceneChange(l.id, m), d === "cameraOpt" && !_d(b, m)) {
      if (m.width !== (b == null ? void 0 : b.width) || m.height !== (b == null ? void 0 : b.height)) {
        const o = this.getView(d);
        o == null || o.displayer.updateSize();
      }
      this.control.internalCameraChange(l.id, m);
    }
  }
  destroyAppView(l) {
    const d = this.appViews.get(l);
    d && (d.displayer.destroy(), this.appViews.delete(l));
  }
  createMianView(l) {
    this.mainView = new Proxy(l, {
      set: (d, i, b) => (this.control.worker.isActive && this.validator(d, i, b), d[i] = b, !0)
    });
  }
  createAppView(l) {
    const d = l.id, i = new Proxy(l, {
      set: (b, m, o) => (this.control.worker.isActive && this.validator(b, m, o), b[m] = o, !0)
    });
    this.appViews.set(d, i);
  }
  isAppView(l) {
    return l !== bl.viewId && this.appViews.has(l);
  }
  getView(l) {
    var d;
    return l === bl.viewId ? this.mainView : (d = this.appViews) == null ? void 0 : d.get(l);
  }
  getCurScenePath(l) {
    const d = this.getView(l);
    if (d)
      return d.focusScenePath;
  }
  getAllViews() {
    return [this.mainView, ...this.appViews.values()];
  }
  setViewScenePath(l, d) {
    var i;
    if (l === bl.viewId && this.mainView)
      this.mainView.focusScenePath = d;
    else {
      const b = l && ((i = this.appViews) == null ? void 0 : i.get(l)) || void 0;
      b && (b.focusScenePath = d);
    }
  }
  setViewData(l, d) {
    var i;
    if (l === bl.viewId && this.mainView)
      this.mainView.viewData = d;
    else {
      const b = l && ((i = this.appViews) == null ? void 0 : i.get(l)) || void 0;
      b && (b.viewData = d);
    }
  }
  setFocuedViewId(l) {
    var d;
    this.focuedViewId = l, l === bl.viewId ? this.focuedView = this.mainView : this.focuedView = l && ((d = this.appViews) == null ? void 0 : d.get(l)) || void 0;
  }
  setViewFocusScenePath(l, d) {
    var b;
    let i;
    l === bl.viewId ? i = this.mainView : i = (b = this.appViews) == null ? void 0 : b.get(l), i && (i.focusScenePath = d);
  }
  /** 销毁 */
  destroy() {
    var l;
    this.internalMsgEmitter.removeAllListeners("undoTickerStart"), this.internalMsgEmitter.removeAllListeners("undoTickerEnd"), this.internalMsgEmitter.removeAllListeners("excludeIds"), (l = this.mainView) == null || l.displayer.destroy(), this.appViews.forEach((d) => {
      d.displayer.destroy();
    });
  }
  /** 是否绘制浮动选框 */
  showFloatBar(l, d, i) {
    const b = this.getView(l), m = b == null ? void 0 : b.displayer.vDom;
    m && m.showFloatBar(d, i);
  }
  /** 激活浮动选框 */
  activeFloatBar(l) {
    var i;
    const d = (i = this.getView(l)) == null ? void 0 : i.displayer;
    d != null && d.vDom && d.vDom.setFloatZIndex(2);
  }
  /** 销毁浮动选框 */
  unActiveFloatBar(l) {
    const d = this.getView(l), i = d == null ? void 0 : d.displayer.vDom;
    i && i.setFloatZIndex(-1);
  }
  /** 激活刷新指针 */
  setActiveCursor(l) {
    for (const d of l) {
      const { viewId: i, ...b } = d, m = this.getView(i), o = m == null ? void 0 : m.displayer.vDom;
      o && o.setActiveCursor([b]);
    }
  }
  /** 激活刷新文字编辑器 */
  setActiveTextEditor(l, d) {
    const i = this.getView(l), b = i == null ? void 0 : i.displayer.vDom;
    b && b.setActiveTextEditor(d);
  }
}
Object.defineProperty(wl, "defaultCameraOpt", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: {
    centerX: 0,
    centerY: 0,
    scale: 1
  }
});
Object.defineProperty(wl, "defaultScreenCanvasOpt", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: {
    autoRender: !1,
    contextType: Gi.Canvas2d
  }
});
Object.defineProperty(wl, "defaultLayerOpt", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: {
    offscreen: !0,
    handleEvent: !1,
    depth: !1
  }
});
class Ge {
  constructor(l, d, i) {
    Object.defineProperty(this, "viewId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "control", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "internalMsgEmitter", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "commiter", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "cachePoint", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "mousedown", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (m) => {
        m.button === 0 && this.viewId && this.control.worker.originalEventLintener(ud.Start, this.getPoint(m), this.viewId);
      }
    }), Object.defineProperty(this, "mousemove", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (m) => {
        this.viewId && this.control.worker.originalEventLintener(ud.Doing, this.getPoint(m), this.viewId);
      }
    }), Object.defineProperty(this, "mouseup", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (m) => {
        m.button === 0 && this.viewId && this.control.worker.originalEventLintener(ud.Done, this.getPoint(m), this.viewId);
      }
    }), Object.defineProperty(this, "touchstart", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (m) => {
        this.viewId && this.control.worker.originalEventLintener(ud.Start, this.getPoint(m), this.viewId);
      }
    }), Object.defineProperty(this, "touchmove", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: Ad((m) => {
        this.viewId && this.control.worker.originalEventLintener(ud.Doing, this.getPoint(m), this.viewId);
      }, 20, { leading: !1 })
    }), Object.defineProperty(this, "touchend", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (m) => {
        this.viewId && this.control.worker.originalEventLintener(ud.Done, this.getPoint(m), this.viewId);
      }
    }), Object.defineProperty(this, "cursorMouseMove", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: Ad((m) => {
        const o = this.getPoint(m);
        this.cachePoint && _d(o, this.cachePoint) || !this.viewId || (this.cachePoint = this.getPoint(m), this.control.worker.sendCursorEvent(o, this.viewId));
      }, 30, { leading: !1 })
    }), Object.defineProperty(this, "cursorMouseLeave", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: Ad(() => {
        this.viewId && (this.cachePoint = [void 0, void 0], this.control.worker.sendCursorEvent(this.cachePoint, this.viewId));
      }, 30, { leading: !1 })
    }), this.viewId = l, this.control = d, this.internalMsgEmitter = i;
    const b = {
      control: this.control,
      internalMsgEmitter: this.internalMsgEmitter,
      viewId: this.viewId
    };
    this.commiter = new Sl(b);
  }
  bindToolsClass() {
    var d, i;
    const l = (i = (d = this.control.worker) == null ? void 0 : d.currentToolsData) == null ? void 0 : i.toolsType;
    this.eventTragetElement && l && (this.eventTragetElement.className = `netless-whiteboard ${l === Gd.Text ? "cursor-text" : l === Gd.Pencil || l === Gd.LaserPen ? "cursor-pencil" : "cursor-arrow"}`);
  }
  mountView() {
    this.setCanvassStyle(), this.control.viewContainerManager.mountView(this.viewId);
  }
  reflashContainerOffset() {
    this.eventTragetElement && (this.containerOffset = this.getContainerOffset(this.eventTragetElement, { x: 0, y: 0 }));
  }
  updateSize() {
    this.setCanvassStyle(), this.reflashContainerOffset();
  }
  setViewId(l) {
    this.viewId = l;
  }
  destroy() {
    this.eventTragetElement && this.removeDisplayerEvent(this.eventTragetElement);
  }
  getPoint(l) {
    return l instanceof TouchEvent ? [l.targetTouches[0].pageX - this.containerOffset.x, l.targetTouches[0].pageY - this.containerOffset.y] : [l.pageX - this.containerOffset.x, l.pageY - this.containerOffset.y];
  }
  getTranslate(l) {
    const i = (l.style.WebkitTransform || getComputedStyle(l, "").getPropertyValue("-webkit-transform") || l.style.transform || getComputedStyle(l, "").getPropertyValue("transform")).match(/-?[0-9]+\.?[0-9]*/g), b = i && parseInt(i[0]) || 0, m = i && parseInt(i[1]) || 0;
    return [b, m];
  }
  getContainerOffset(l, d) {
    var m;
    const i = this.getTranslate(l);
    let b = {
      x: d.x + l.offsetLeft + i[0],
      y: d.y + l.offsetTop + i[1]
    };
    return (m = l.offsetParent) != null && m.nodeName && l.offsetParent.nodeName !== "BODY" && (b = this.getContainerOffset(l.offsetParent, b)), b;
  }
  bindDisplayerEvent(l) {
    l.addEventListener("mousedown", this.mousedown, !1), l.addEventListener("touchstart", this.touchstart, !1), window.addEventListener("mouseleave", this.mouseup, !1), window.addEventListener("mousemove", this.mousemove, !1), window.addEventListener("mouseup", this.mouseup, !1), window.addEventListener("touchmove", this.touchmove, !1), window.addEventListener("touchend", this.touchend, !1), l.addEventListener("mousemove", this.cursorMouseMove, !1), l.addEventListener("mouseleave", this.cursorMouseLeave, !1);
  }
  removeDisplayerEvent(l) {
    l.removeEventListener("mousedown", this.mousedown), l.removeEventListener("touchstart", this.touchstart), window.removeEventListener("mouseleave", this.mouseup), window.removeEventListener("mousemove", this.mousemove), window.removeEventListener("mouseup", this.mouseup), window.removeEventListener("touchmove", this.touchmove), window.removeEventListener("touchend", this.touchend), l.addEventListener("mousemove", this.cursorMouseMove), l.addEventListener("mouseleave", this.cursorMouseLeave);
  }
}
class bl {
  constructor(l, d) {
    Object.defineProperty(this, "viewId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "mainView"
    }), Object.defineProperty(this, "control", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "internalMsgEmitter", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "commiter", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "cachePoint", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "mousedown", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (b) => {
        b.button === 0 && this.control.worker.originalEventLintener(ud.Start, this.getPoint(b), this.viewId);
      }
    }), Object.defineProperty(this, "mousemove", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (b) => {
        this.control.worker.originalEventLintener(ud.Doing, this.getPoint(b), this.viewId);
      }
    }), Object.defineProperty(this, "mouseup", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (b) => {
        b.button === 0 && this.control.worker.originalEventLintener(ud.Done, this.getPoint(b), this.viewId);
      }
    }), Object.defineProperty(this, "touchstart", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (b) => {
        this.control.worker.originalEventLintener(ud.Start, this.getPoint(b), this.viewId);
      }
    }), Object.defineProperty(this, "touchmove", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: Ad((b) => {
        this.control.worker.originalEventLintener(ud.Doing, this.getPoint(b), this.viewId);
      }, 20, { leading: !1 })
    }), Object.defineProperty(this, "touchend", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (b) => {
        this.control.worker.originalEventLintener(ud.Done, this.getPoint(b), this.viewId);
      }
    }), Object.defineProperty(this, "cursorMouseMove", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: Ad((b) => {
        const m = this.getPoint(b);
        this.cachePoint && _d(m, this.cachePoint) || (this.cachePoint = this.getPoint(b), this.control.worker.sendCursorEvent(m, this.viewId));
      }, 30, { leading: !1 })
    }), Object.defineProperty(this, "cursorMouseLeave", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: Ad(() => {
        this.cachePoint = [void 0, void 0], this.control.worker.sendCursorEvent(this.cachePoint, this.viewId);
      }, 30, { leading: !1 })
    }), this.control = l, this.internalMsgEmitter = d;
    const i = {
      control: this.control,
      internalMsgEmitter: this.internalMsgEmitter,
      viewId: this.viewId
    };
    this.commiter = new Sl(i);
  }
  bindToolsClass() {
    var d, i;
    const l = (i = (d = this.control.worker) == null ? void 0 : d.currentToolsData) == null ? void 0 : i.toolsType;
    this.eventTragetElement && l && (this.eventTragetElement.className = `netless-whiteboard ${l === Gd.Text ? "cursor-text" : l === Gd.Pencil || l === Gd.LaserPen ? "cursor-pencil" : "cursor-arrow"}`);
  }
  mountView() {
    this.setCanvassStyle(), this.control.viewContainerManager.mountView(this.viewId);
  }
  updateSize() {
    this.setCanvassStyle(), this.reflashContainerOffset();
  }
  reflashContainerOffset() {
    this.eventTragetElement && (this.containerOffset = this.getContainerOffset(this.eventTragetElement, { x: 0, y: 0 }));
  }
  destroy() {
    this.eventTragetElement && this.removeDisplayerEvent(this.eventTragetElement);
  }
  getPoint(l) {
    return l instanceof TouchEvent ? [l.targetTouches[0].pageX - this.containerOffset.x, l.targetTouches[0].pageY - this.containerOffset.y] : [l.pageX - this.containerOffset.x, l.pageY - this.containerOffset.y];
  }
  getTranslate(l) {
    const i = (l.style.WebkitTransform || getComputedStyle(l, "").getPropertyValue("-webkit-transform") || l.style.transform || getComputedStyle(l, "").getPropertyValue("transform")).match(/-?[0-9]+\.?[0-9]*/g), b = i && parseInt(i[0]) || 0, m = i && parseInt(i[1]) || 0;
    return [b, m];
  }
  getContainerOffset(l, d) {
    var m;
    const i = this.getTranslate(l);
    let b = {
      x: d.x + l.offsetLeft + i[0],
      y: d.y + l.offsetTop + i[1]
    };
    return (m = l.offsetParent) != null && m.nodeName && l.offsetParent.nodeName !== "BODY" && (b = this.getContainerOffset(l.offsetParent, b)), b;
  }
  bindDisplayerEvent(l) {
    l.addEventListener("mousedown", this.mousedown, !1), l.addEventListener("touchstart", this.touchstart, !1), window.addEventListener("mouseleave", this.mouseup, !1), window.addEventListener("mousemove", this.mousemove, !1), window.addEventListener("mouseup", this.mouseup, !1), window.addEventListener("touchmove", this.touchmove, !1), window.addEventListener("touchend", this.touchend, !1), l.addEventListener("mousemove", this.cursorMouseMove, !1), l.addEventListener("mouseleave", this.cursorMouseLeave, !1);
  }
  removeDisplayerEvent(l) {
    l.removeEventListener("mousedown", this.mousedown), l.removeEventListener("touchstart", this.touchstart), window.removeEventListener("mouseleave", this.mouseup), window.removeEventListener("mousemove", this.mousemove), window.removeEventListener("mouseup", this.mouseup), window.removeEventListener("touchmove", this.touchmove), window.removeEventListener("touchend", this.touchend), l.addEventListener("mousemove", this.cursorMouseMove), l.addEventListener("mouseleave", this.cursorMouseLeave);
  }
}
Object.defineProperty(bl, "viewId", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "mainView"
});
const ue = "index-module__Container__nLsM3", Ve = "index-module__CanvasBox__j2Xe-", he = "index-module__FloatCanvas__d1YR7", pe = "index-module__FloatBar__cm-EL", ye = "index-module__RotateBtn__HSSkf", Ie = "index-module__ResizeBtn__yjvda", Le = "index-module__CursorBox__2UHvI", Re = "index-module__TextEditorContainer__Qm8KC", ul = {
  Container: ue,
  CanvasBox: Ve,
  FloatCanvas: he,
  FloatBar: pe,
  RotateBtn: ye,
  ResizeBtn: Ie,
  CursorBox: Le,
  TextEditorContainer: Re
}, xe = {
  delete: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTEyIDZ2NmEyIDIgMCAwIDEtMiAySDZhMiAyIDAgMCAxLTItMlY2aDBtMS0yYTIgMiAwIDAgMSAyLTJoMmEyIDIgMCAwIDEgMiAyaDBNMyA0aDEwIiBzdHJva2U9IiM0NDRFNjAiIGZpbGw9Im5vbmUiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIvPjwvc3ZnPg==",
  duplicate: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgc3Ryb2tlPSIjNDQ0RTYwIiBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiPjxwYXRoIGQ9Ik0xMSAySDZhMSAxIDAgMCAwLTEgMXY4YTEgMSAwIDAgMCAxIDFoNmExIDEgMCAwIDAgMS0xVjRoMGwtMi0yeiIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIi8+PHBhdGggZD0iTTExIDJ2MWExIDEgMCAwIDAgMSAxaDFsLTItMnoiLz48cGF0aCBkPSJNOSAxNEg0YTEgMSAwIDAgMS0xLTFWNWgwIiBzdHJva2UtbGluZWNhcD0icm91bmQiLz48L2c+PC9zdmc+",
  "layer-pressed": "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0ibTE2IDEwLTYgNCA2IDQgNi00em0tNiA4IDYgNCA2LTQiIHN0cm9rZT0iIzMzODFGRiIgZmlsbD0ibm9uZSIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIi8+PC9zdmc+",
  layer: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0ibTE2IDEwLTYgNCA2IDQgNi00em0tNiA4IDYgNCA2LTQiIHN0cm9rZT0iIzQ0NEU2MCIgZmlsbD0ibm9uZSIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIi8+PC9zdmc+",
  rotate: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjUiIGhlaWdodD0iMjQiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgc3Ryb2tlPSIjNDQ0RTYwIiBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCI+PHBhdGggZD0iTTEzIDZhNiA2IDAgMSAxLTMuNzA5IDEuMjgzIi8+PHBhdGggZD0ibTEzIDYgMS40MTQgMi40NUwxMyA2bDIuNDUtMS40MTQiLz48L2c+PC9zdmc+",
  "rotation-button": "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgZmlsbD0iI0ZGRiIgZmlsbC1ydWxlPSJldmVub2RkIj48cGF0aCBvcGFjaXR5PSIuMDEiIGQ9Ik0wIDI0VjBoMjR2MjR6Ii8+PHBhdGggZD0iTTUuNzI0IDUuNzI0QTguODQ3IDguODQ3IDAgMCAxIDEyIDMuMTI1YzIuMjcxIDAgNC41NDMuODY2IDYuMjc2IDIuNmE4Ljg0NiA4Ljg0NiAwIDAgMSAyLjU5OCA2LjE0IDguODQ5IDguODQ5IDAgMCAxLTIuNTU5IDYuMzdsLTEuNS0uOTgzQTcuMTA1IDcuMTA1IDAgMCAwIDE5LjEyNSAxMmE3LjEwMyA3LjEwMyAwIDAgMC0yLjA4Ny01LjAzOEE3LjEwMyA3LjEwMyAwIDAgMCAxMiA0Ljg3NWE3LjEwMyA3LjEwMyAwIDAgMC01LjAzOCAyLjA4NyA3LjEwMSA3LjEwMSAwIDAgMC0yLjA4NiA0LjkyIDcuMTAzIDcuMTAzIDAgMCAwIDEuNzY2IDQuODE1bDEuOTQ1LTEuNTg0IDIuMzk0IDcuMTgyLTcuMjIyLTIuNDA4IDEuNzkxLTEuNzlBOC44NDYgOC44NDYgMCAwIDEgMy4xMjUgMTJjMC0yLjI3MS44NjYtNC41NDMgMi42LTYuMjc2eiIgc3Ryb2tlPSIjRkZGIiBzdHJva2Utd2lkdGg9Ii41IiBmaWxsLXJ1bGU9Im5vbnplcm8iLz48L2c+PC9zdmc+",
  rotation: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIj48cGF0aCBmaWxsPSIjRkZGIiBvcGFjaXR5PSIuMDEiIGQ9Ik0wIDI0VjBoMjR2MjR6Ii8+PHBhdGggZD0iTTUuNzI0IDUuNzI0QTguODQ3IDguODQ3IDAgMCAxIDEyIDMuMTI1YzIuMjcxIDAgNC41NDMuODY2IDYuMjc2IDIuNmE4Ljg0NiA4Ljg0NiAwIDAgMSAyLjU5OCA2LjE0IDguODQ5IDguODQ5IDAgMCAxLTIuNTU5IDYuMzdsLTEuNS0uOTgzQTcuMTA1IDcuMTA1IDAgMCAwIDE5LjEyNSAxMmE3LjEwMyA3LjEwMyAwIDAgMC0yLjA4Ny01LjAzOEE3LjEwMyA3LjEwMyAwIDAgMCAxMiA0Ljg3NWE3LjEwMyA3LjEwMyAwIDAgMC01LjAzOCAyLjA4NyA3LjEwMSA3LjEwMSAwIDAgMC0yLjA4NiA0LjkyIDcuMTAzIDcuMTAzIDAgMCAwIDEuNzY2IDQuODE1bDEuOTQ1LTEuNTg0IDIuMzk0IDcuMTgyLTcuMjIyLTIuNDA4IDEuNzkxLTEuNzlBOC44NDYgOC44NDYgMCAwIDEgMy4xMjUgMTJjMC0yLjI3MS44NjYtNC41NDMgMi42LTYuMjc2eiIgc3Ryb2tlPSIjRkZGIiBzdHJva2Utd2lkdGg9Ii41IiBmaWxsPSIjMDAwIiBmaWxsLXJ1bGU9Im5vbnplcm8iLz48L2c+PC9zdmc+",
  "font-colors-active": "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0ibTQgMTEgNC05IDQgOU02IDdoNCIgc3Ryb2tlPSIjMzM4MUZGIiBmaWxsPSJub25lIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiLz48L3N2Zz4=",
  "font-colors": "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0ibTQgMTEgNC05IDQgOU02IDdoNCIgc3Ryb2tlPSIjNDQ0RTYwIiBmaWxsPSJub25lIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiLz48L3N2Zz4=",
  "to-bottom": "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTEyIDEwdjhtMCAwLTItMm0yIDIgMi0ybS00IDZoMTJtLTYtNGg2bS02LTRoNm0tNi00aDYiIHN0cm9rZT0iIzQ0NEU2MCIgZmlsbD0ibm9uZSIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIi8+PC9zdmc+",
  "to-top": "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTEyIDIydi04bTAgMC0yIDJtMi0yIDIgMm0tNC02aDEybS02IDRoNm0tNiA0aDZtLTYgNGg2IiBzdHJva2U9IiM0NDRFNjAiIGZpbGw9Im5vbmUiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIvPjwvc3ZnPg=="
};
function rl(s) {
  return xe[s];
}
const Ye = (s) => {
  const { workIds: l, maranger: d } = s;
  return ad.createElement(
    "div",
    { className: "button normal-button", onClick: (i) => {
      i.preventDefault(), i.stopPropagation(), Jd.emitMethod(rd.MainEngine, pd.DeleteNode, { workIds: l || [Ld], viewId: d.viewId });
    }, onTouchEnd: (i) => {
      i.stopPropagation(), Jd.emitMethod(rd.MainEngine, pd.DeleteNode, { workIds: l || [Ld], viewId: d.viewId });
    } },
    ad.createElement("img", { alt: "icon", src: rl("delete") })
  );
}, Ke = (s) => {
  const { workIds: l, viewId: d } = s;
  return ad.createElement(
    "div",
    { className: "button normal-button", onClick: (i) => {
      i.preventDefault(), i.stopPropagation(), Jd.emitMethod(rd.MainEngine, pd.CopyNode, { workIds: l || [Ld], viewId: d });
    }, onTouchEnd: (i) => {
      i.stopPropagation(), Jd.emitMethod(rd.MainEngine, pd.CopyNode, { workIds: l || [Ld], viewId: d });
    } },
    ad.createElement("img", { alt: "icon", src: rl("duplicate") })
  );
}, Hb = (s) => {
  const { icon: l, onClickHandler: d, onTouchEndHandler: i } = s;
  return ad.createElement(
    "div",
    { className: "button normal-button", onClick: d, onTouchEnd: i },
    ad.createElement("img", { src: rl(l) })
  );
}, Se = (s) => {
  const { open: l, setOpen: d } = s, { floatBarData: i, maranger: b, position: m } = el(Wl), [o, n] = Dd([]), W = Bd(() => l ? ad.createElement(
    "div",
    { className: "image-layer-menu", style: m && m.y < 80 ? {
      top: "inherit",
      bottom: "50px"
    } : void 0 },
    ad.createElement(Hb, { icon: "to-top", onClickHandler: (a) => {
      a.preventDefault(), a.stopPropagation(), Jd.emitMethod(rd.MainEngine, pd.ZIndexNode, { workIds: [Ld], layer: Rl.Top, viewId: b == null ? void 0 : b.viewId });
    }, onTouchEndHandler: (a) => {
      a.stopPropagation(), Jd.emitMethod(rd.MainEngine, pd.ZIndexNode, { workIds: [Ld], layer: Rl.Top, viewId: b == null ? void 0 : b.viewId });
    } }),
    ad.createElement(Hb, { icon: "to-bottom", onClickHandler: (a) => {
      a.preventDefault(), a.stopPropagation(), Jd.emitMethod(rd.MainEngine, pd.ZIndexNode, { workIds: [Ld], layer: Rl.Bottom, viewId: b == null ? void 0 : b.viewId });
    }, onTouchEndHandler: (a) => {
      a.stopPropagation(), Jd.emitMethod(rd.MainEngine, pd.ZIndexNode, { workIds: [Ld], layer: Rl.Bottom, viewId: b == null ? void 0 : b.viewId });
    } })
  ) : null, [l, m]), e = (a) => {
    a.preventDefault(), a.stopPropagation(), a.nativeEvent.stopImmediatePropagation();
    const V = !l;
    d(V), V && Jd.emitMethod(rd.MainEngine, pd.ZIndexActive, { workId: Ld, isActive: V });
  }, I = (a) => {
    a.stopPropagation(), a.nativeEvent.stopImmediatePropagation();
    const V = !l;
    d(V), Jd.emitMethod(rd.MainEngine, pd.ZIndexActive, { workId: Ld, isActive: V });
  };
  return nl(() => {
    _d(i == null ? void 0 : i.selectIds, o) || i != null && i.selectIds && !_d(i == null ? void 0 : i.selectIds, o) && (n(i == null ? void 0 : i.selectIds), d(!1));
  }, [l, i, o, d]), nl(() => () => {
    l && Jd.emitMethod(rd.MainEngine, pd.ZIndexActive, { workId: Ld, isActive: !1 });
  }, [l]), ad.createElement(
    "div",
    { className: `button normal-button ${l && "active"}`, onClick: e, onTouchEnd: I },
    W,
    ad.createElement("img", { alt: "icon", src: rl(l ? "layer-pressed" : "layer") })
  );
}, re = (s) => {
  const { activeColor: l, onClickHandler: d, onTouchEndHandler: i } = s;
  return ad.createElement(
    "div",
    { className: `font-color-button ${l === "transparent" ? "active" : ""}`, onClick: d, onTouchEnd: i },
    ad.createElement("div", { className: "circle none" })
  );
}, gi = (s) => {
  const { color: l, activeColor: d, onClickHandler: i, onTouchEndHandler: b } = s;
  return ad.createElement(
    "div",
    { className: `font-color-button ${l === d ? "active" : ""}`, onClick: i, onTouchEnd: b },
    ad.createElement("div", { className: "circle", style: { backgroundColor: jd(l, 1) } })
  );
}, ki = (s) => {
  const { opacity: l, activeColor: d, setCurOpacity: i } = s, [b, m] = Dd({ x: 108, y: 0 });
  if (nl(() => {
    m({ x: l * 100 + 8, y: 0 });
  }, []), !d)
    return null;
  const o = Ad((e, I) => {
    e.preventDefault(), e.stopPropagation(), I.x !== (b == null ? void 0 : b.x) && m({ x: I.x, y: 0 });
    const a = Math.min(Math.max(I.x - 8, 0), 100) / 100;
    l !== a && i(a, d, ud.Doing);
  }, 100, { leading: !1 }), n = (e) => {
    e.preventDefault(), e.stopPropagation(), i(l, d, ud.Start);
  }, W = Ad((e, I) => {
    e.preventDefault(), e.stopPropagation(), I.x !== (b == null ? void 0 : b.x) && m({ x: I.x, y: 0 });
    const a = Math.min(Math.max(I.x - 8, 0), 100) / 100;
    i(a, d, ud.Done);
  }, 100, { leading: !1 });
  return ad.createElement(
    "div",
    { className: "font-color-opacity", style: { marginLeft: "10px" } },
    ad.createElement("div", { className: "range-color", style: {
      background: `linear-gradient(to right, ${jd(d, 0)}, ${jd(d, 1)})`
    } }),
    ad.createElement(
      "div",
      { className: "range-opacity" },
      ad.createElement(
        Li,
        { bounds: "parent", axis: "x", position: b, onDrag: o, onStart: n, onStop: W },
        ad.createElement("div", { className: "circle", style: {
          backgroundColor: jd(d, l)
        } })
      )
    )
  );
}, Je = (s) => {
  const { open: l, setOpen: d } = s, { floatBarData: i, floatBarColors: b, maranger: m, position: o } = el(Wl), [n, W] = Dd(), [e, I] = Dd(1);
  nl(() => {
    if (i != null && i.strokeColor) {
      const [Y, p] = Ni(i.strokeColor);
      W(Y), I(p);
    }
  }, [i]);
  const a = Bd(() => ad.createElement(ki, { key: "strokeColors", opacity: e, activeColor: n, setCurOpacity: (Y, p, G) => {
    G === ud.Start && (m != null && m.control.room) && (m.control.room.disableDeviceInputs = !0), G === ud.Done && (m != null && m.control.room) && (m.control.room.disableDeviceInputs = !1), I(Y), Jd.emitMethod(rd.MainEngine, pd.SetColorNode, { workIds: [Ld], strokeColor: n && jd(p, Y), workState: G, viewId: m == null ? void 0 : m.viewId });
  } }), [n, e, m]), V = Bd(() => l ? ad.createElement(
    "div",
    { className: "font-colors-menu", style: o && o.y < 80 ? {
      top: "inherit",
      bottom: "50px"
    } : void 0, onTouchEnd: (Y) => {
      Y.stopPropagation(), Y.nativeEvent.stopImmediatePropagation();
    }, onClick: (Y) => {
      Y.preventDefault(), Y.stopPropagation(), Y.nativeEvent.stopImmediatePropagation();
    } },
    b.concat().map((Y, p) => {
      const G = ti(...Y);
      return ad.createElement(gi, { key: p, color: G, activeColor: n, onTouchEndHandler: (y) => {
        y.stopPropagation(), W(G), Jd.emitMethod(rd.MainEngine, pd.SetColorNode, { workIds: [Ld], strokeColor: jd(G, e), viewId: m == null ? void 0 : m.viewId });
      }, onClickHandler: (y) => {
        y.preventDefault(), y.stopPropagation(), W(G), Jd.emitMethod(rd.MainEngine, pd.SetColorNode, { workIds: [Ld], strokeColor: jd(G, e), viewId: m == null ? void 0 : m.viewId });
      } });
    }),
    a
  ) : null, [l, b, a, e, n, m]), h = Bd(() => n ? ad.createElement(
    "div",
    { className: "color-bar-ring", style: { backgroundColor: jd(n, e) } },
    ad.createElement("div", { className: "circle" })
  ) : null, [n, e]);
  return ad.createElement(
    "div",
    { className: `button normal-button font-colors-icon ${l && "active"}`, onTouchEnd: (Y) => {
      Y.stopPropagation(), Y.nativeEvent.stopImmediatePropagation(), d(!l);
    }, onClick: (Y) => {
      Y.preventDefault(), Y.stopPropagation(), Y.nativeEvent.stopImmediatePropagation(), d(!l);
    } },
    h,
    V
  );
}, Ce = (s) => {
  const { open: l, setOpen: d } = s, { floatBarData: i, floatBarColors: b, maranger: m, position: o } = el(Wl), [n, W] = Dd(), [e, I] = Dd(1);
  nl(() => {
    if (i != null && i.fillColor) {
      const [Y, p] = (i == null ? void 0 : i.fillColor) === "transparent" && ["transparent", 0] || Ni(i.fillColor);
      W(Y), I(p);
    }
  }, [i]);
  const a = Bd(() => n && n !== "transparent" ? ad.createElement(ki, { key: "fillColors", opacity: e || 0, activeColor: n, setCurOpacity: (Y, p, G) => {
    G === ud.Start && (m != null && m.control.room) && (m.control.room.disableDeviceInputs = !0), G === ud.Done && (m != null && m.control.room) && (m.control.room.disableDeviceInputs = !1), I(Y), Jd.emitMethod(rd.MainEngine, pd.SetColorNode, { workIds: [Ld], fillColor: n && jd(p, Y), workState: G, viewId: m == null ? void 0 : m.viewId });
  } }) : null, [n, e, m]), V = Bd(() => l ? ad.createElement(
    "div",
    { className: "font-colors-menu", style: o && o.y < 80 ? {
      top: "inherit",
      bottom: "50px"
    } : void 0, onTouchEnd: (Y) => {
      Y.stopPropagation(), Y.nativeEvent.stopImmediatePropagation();
    }, onClick: (Y) => {
      Y.preventDefault(), Y.stopPropagation(), Y.nativeEvent.stopImmediatePropagation();
    } },
    ad.createElement(re, { activeColor: n, onTouchEndHandler: (Y) => {
      Y.stopPropagation(), W("transparent"), Jd.emitMethod(rd.MainEngine, pd.SetColorNode, { workIds: [Ld], fillColor: "transparent", viewId: m == null ? void 0 : m.viewId });
    }, onClickHandler: (Y) => {
      Y.preventDefault(), Y.stopPropagation(), W("transparent"), Jd.emitMethod(rd.MainEngine, pd.SetColorNode, { workIds: [Ld], fillColor: "transparent", viewId: m == null ? void 0 : m.viewId });
    } }),
    b.map((Y, p) => {
      const G = ti(...Y);
      return ad.createElement(gi, { key: p, color: G, activeColor: n, onTouchEndHandler: (y) => {
        y.stopPropagation(), W(G), Jd.emitMethod(rd.MainEngine, pd.SetColorNode, { workIds: [Ld], fillColor: jd(G, e), viewId: m == null ? void 0 : m.viewId });
      }, onClickHandler: (y) => {
        y.preventDefault(), y.stopPropagation(), W(G), Jd.emitMethod(rd.MainEngine, pd.SetColorNode, { workIds: [Ld], fillColor: jd(G, e), viewId: m == null ? void 0 : m.viewId });
      } });
    }),
    a
  ) : null, [l, b, a, e, n, m, o]), h = Bd(() => {
    const Y = n && n !== "transparent" && jd(n, e) || "transparent";
    return ad.createElement(
      "div",
      { className: "color-bar-fill" },
      ad.createElement("div", { className: "circle", style: { backgroundColor: Y } })
    );
  }, [n, e]);
  return ad.createElement(
    "div",
    { className: `button normal-button font-colors-icon ${l && "active"}`, onTouchEnd: (Y) => {
      Y.stopPropagation(), Y.nativeEvent.stopImmediatePropagation(), d(!l);
    }, onClick: (Y) => {
      Y.preventDefault(), Y.stopPropagation(), Y.nativeEvent.stopImmediatePropagation(), d(!l);
    } },
    h,
    V
  );
}, Fe = (s) => {
  const { open: l, setOpen: d, textOpt: i, workIds: b } = s, { floatBarColors: m, maranger: o, position: n } = el(Wl), [W, e] = Dd(), [I, a] = Dd(1);
  nl(() => {
    if (i != null && i.fontColor) {
      const [p, G] = (i == null ? void 0 : i.fontColor) === "transparent" && ["transparent", 0] || Ni(i.fontColor);
      e(p), a(G);
    }
  }, [i == null ? void 0 : i.fontColor]);
  const V = Bd(() => W && W !== "transparent" ? ad.createElement(ki, { key: "fontColors", opacity: I, activeColor: W, setCurOpacity: (p, G, y) => {
    y === ud.Start && (o != null && o.control.room) && (o.control.room.disableDeviceInputs = !0), y === ud.Done && (o != null && o.control.room) && (o.control.room.disableDeviceInputs = !1), a(p), Jd.emitMethod(rd.MainEngine, pd.SetColorNode, {
      workIds: b || [Ld],
      fontColor: W && jd(G, p),
      workState: y,
      viewId: o == null ? void 0 : o.viewId
    });
  } }) : null, [W, I, b, o]), h = Bd(() => l ? ad.createElement(
    "div",
    { className: "font-colors-menu", style: n && n.y < 80 ? {
      top: "inherit",
      bottom: "50px"
    } : void 0, onTouchEnd: (p) => {
      p.stopPropagation(), p.nativeEvent.stopImmediatePropagation();
    }, onClick: (p) => {
      p.preventDefault(), p.stopPropagation(), p.nativeEvent.stopImmediatePropagation();
    } },
    m.map((p, G) => {
      const y = ti(...p);
      return ad.createElement(gi, { key: G, color: y, activeColor: W, onTouchEndHandler: (Z) => {
        Z.stopPropagation(), e(y), Jd.emitMethod(rd.MainEngine, pd.SetColorNode, { workIds: b || [Ld], fontColor: jd(y, I), viewId: o == null ? void 0 : o.viewId });
      }, onClickHandler: (Z) => {
        Z.preventDefault(), Z.stopPropagation(), e(y), Jd.emitMethod(rd.MainEngine, pd.SetColorNode, { workIds: b || [Ld], fontColor: jd(y, I), viewId: o == null ? void 0 : o.viewId });
      } });
    }),
    V
  ) : null, [l, m, V, I, W, b, o, n]), Y = Bd(() => {
    const p = W && W !== "transparent" && jd(W, I) || "transparent";
    return ad.createElement(
      "div",
      { className: "color-bar" },
      ad.createElement("div", { className: "color-bar-color", style: { backgroundColor: p } })
    );
  }, [W, I]);
  return ad.createElement(
    "div",
    { className: `button normal-button font-colors-icon ${l && "active"}`, onTouchEnd: (p) => {
      p.stopPropagation(), p.nativeEvent.stopImmediatePropagation(), d(!l);
    }, onClick: (p) => {
      p.preventDefault(), p.stopPropagation(), p.nativeEvent.stopImmediatePropagation(), d(!l);
    } },
    ad.createElement("img", { alt: "icon", src: rl("font-colors") }),
    Y,
    h
  );
};
var Od;
(function(s) {
  s[s.none = 0] = "none", s[s.Layer = 1] = "Layer", s[s.StrokeColor = 2] = "StrokeColor", s[s.FillColor = 3] = "FillColor", s[s.TextColor = 4] = "TextColor", s[s.TextBgColor = 5] = "TextBgColor";
})(Od || (Od = {}));
const GZ = ad.memo((s) => {
  const { textOpt: l, workIds: d, noLayer: i, position: b } = s, { floatBarData: m, maranger: o } = el(Wl), [n, W] = ad.useState(Od.none), e = Bd(() => m != null && m.fillColor ? ad.createElement(Ce, { open: n === Od.FillColor, setOpen: (h) => {
    W(h === !0 ? Od.FillColor : Od.none);
  } }) : null, [m == null ? void 0 : m.fillColor, n]), I = Bd(() => m != null && m.strokeColor ? ad.createElement(Je, { open: n === Od.StrokeColor, setOpen: (h) => {
    W(h === !0 ? Od.StrokeColor : Od.none);
  } }) : null, [m == null ? void 0 : m.strokeColor, n]), a = Bd(() => l != null && l.fontColor && (o != null && o.viewId) ? ad.createElement(Fe, { open: n === Od.TextColor, setOpen: (h) => {
    W(h === !0 ? Od.TextColor : Od.none);
  }, textOpt: l, workIds: d }) : null, [l, n, d, o]), V = Bd(() => i ? null : ad.createElement(Se, { open: n === Od.Layer, setOpen: (h) => {
    W(h === !0 ? Od.Layer : Od.none);
  } }), [i, n]);
  return ad.createElement(
    "div",
    { className: "bezier-pencil-plugin-floatbtns", style: b && b.y < 80 ? {
      bottom: "-120px"
    } : void 0 },
    o && ad.createElement(Ye, { workIds: d, maranger: o }),
    V,
    !!(o != null && o.viewId) && ad.createElement(Ke, { workIds: d, viewId: o.viewId }),
    a,
    I,
    e
  );
}), He = (s) => {
  const { data: l } = s, { opt: d, scale: i, translate: b, x: m, y: o } = l, n = `scale(${i || 1}) ${b && "translate(" + b[0] + "px," + b[1] + "px)" || ""}`, { fontSize: W, fontFamily: e, underline: I, fontColor: a, lineThrough: V, textAlign: h, strokeColor: Y, lineHeight: p, workState: G } = d, y = W, Z = p || y * 1.2, X = {
    fontSize: `${y}px`,
    lineHeight: `${Z}px`,
    color: a,
    borderColor: Y,
    minHeight: `${Z}px`
  };
  e && (X.fontFamily = `${e}`), (V || I) && (X.textDecoration = `${V && "line-through"}${I && " underline"}`), h && (X.textAlign = `${h}`);
  let c = "";
  return d != null && d.text && (c = d.text.split(",").reduce((R, S, J) => {
    const H = S === "" ? "<br/>" : S;
    return J === 0 ? H : `${R}<div>${H}</div>`;
  }, "")), ad.createElement(
    "div",
    { className: "editor-box", style: {
      left: `${m}px`,
      top: `${o}px`,
      transform: n,
      transformOrigin: "left top",
      pointerEvents: "none"
    } },
    ad.createElement("div", { className: `editor ${G === ud.Done ? "readOnly" : ""}`, style: X, dangerouslySetInnerHTML: { __html: c } })
  );
}, Te = ad.memo((s) => {
  const { data: l, position: d, workId: i, selectIds: b } = s, [m, o] = Dd([0, 0]), { opt: n, scale: W, translate: e, x: I, y: a } = l;
  nl(() => {
    il(I) && il(a) && o([I - ((d == null ? void 0 : d.x) || 0), a - ((d == null ? void 0 : d.y) || 0)]);
  }, [i, b]);
  const V = `scale(${W || 1}) ${e && "translate(" + e[0] + "px," + e[1] + "px)" || ""}`, { fontSize: h, fontFamily: Y, underline: p, fontColor: G, lineThrough: y, textAlign: Z, strokeColor: X, lineHeight: c } = n, t = h, R = c || t * 1.2, S = {
    fontSize: `${t}px`,
    lineHeight: `${R}px`,
    color: G,
    borderColor: X,
    minHeight: `${R}px`
  };
  Y && (S.fontFamily = `${Y}`), (y || p) && (S.textDecoration = `${y && "line-through"}${p && " underline"}`), Z && (S.textAlign = `${Z}`);
  let J = "";
  return n != null && n.text && (J = n.text.split(",").reduce((L, C, F) => {
    const r = C === "" ? "<br/>" : C;
    return F === 0 ? r : `${L}<div>${r}</div>`;
  }, "")), ad.createElement(
    "div",
    { className: "editor-box", style: {
      left: `${m[0]}px`,
      top: `${m[1]}px`,
      transform: V,
      transformOrigin: "left top"
    } },
    ad.createElement("div", { className: "editor readOnly", style: S, dangerouslySetInnerHTML: { __html: J } })
  );
}), Ne = (s) => {
  const { data: l, workId: d, isSelect: i, handleKeyUp: b, handleFocus: m } = s, { opt: o, scale: n, translate: W, x: e, y: I } = l, [a, V] = Dd(""), h = Nb(null);
  nl(() => {
    let F = "";
    o != null && o.text && (F = o.text.split(",").reduce((K, g, v) => {
      const f = g === "" ? "<br/>" : g;
      return v === 0 ? f : `${K}<div>${f}</div>`;
    }, "")), V(F), Promise.resolve().then(() => {
      h.current && h.current.click();
    });
  }, []);
  const Y = `scale(${n || 1}) ${W && "translate(" + W[0] + "px," + W[1] + "px)" || ""}`, { fontSize: p, fontFamily: G, underline: y, fontColor: Z, lineThrough: X, textAlign: c, strokeColor: t, lineHeight: R } = o, S = p, J = R || S * 1.2, H = {
    fontSize: `${S}px`,
    lineHeight: `${J}px`,
    color: Z,
    borderColor: t,
    minHeight: `${J}px`
  };
  G && (H.fontFamily = `${G}`), (X || y) && (H.textDecoration = `${X && "line-through"}${y && " underline"}`), c && (H.textAlign = `${c}`);
  function L() {
    var F;
    if (h.current) {
      h.current.focus();
      const r = window == null ? void 0 : window.getSelection(), K = h.current.lastChild;
      if (r && K) {
        const g = document.createRange(), v = ((F = K.textContent) == null ? void 0 : F.length) || 0;
        (K == null ? void 0 : K.nodeName) === "#text" ? g.setStart(K, v) : g.setStart(K, v && 1 || 0), g.collapse(!0), r.removeAllRanges(), r.addRange(g);
      }
    }
  }
  function C(F) {
    if (F.key === "Backspace") {
      const r = window.getSelection(), K = r == null ? void 0 : r.getRangeAt(0);
      if (K != null && K.collapsed)
        return F.preventDefault(), document.execCommand("delete", !1), !1;
    }
    return !1;
  }
  return ad.createElement(
    "div",
    { className: "editor-box", style: {
      left: `${e}px`,
      top: `${I}px`,
      transform: Y,
      transformOrigin: "left top",
      zIndex: 2,
      pointerEvents: "auto"
    }, onKeyDown: (F) => (F.stopPropagation(), !0), onMouseMove: (F) => (F.stopPropagation(), F.preventDefault(), !0) },
    !i && ad.createElement(GZ, { textOpt: o, workIds: [d], noLayer: !0, position: { x: e, y: I } }),
    ad.createElement("div", { contentEditable: !0, className: "editor", ref: h, style: H, dangerouslySetInnerHTML: { __html: a }, onKeyDown: C, onKeyUp: b, onClick: L, onFocus: m })
  );
};
class uZ extends ad.Component {
  constructor(l) {
    super(l);
  }
  getInnerText(l) {
    const d = [];
    for (const i of l.childNodes)
      if (i.nodeName === "#text") {
        const b = i.textContent.replace(/\n/, "");
        d.push(b);
      } else {
        const b = i.innerText.replace(/\n/, "");
        d.push(b);
      }
    return d;
  }
  updateOptInfo(l) {
    var m;
    const { activeTextId: d, update: i } = l, b = d && qd((m = this.props.editors) == null ? void 0 : m.get(d));
    b && b.opt && (b.opt = {
      ...b.opt,
      ...i
    }, this.props.manager.control.textEditorManager.updateForLocalEditor(d, b));
  }
  get editorUI() {
    var l;
    if ((l = this.props.editors) != null && l.size) {
      const d = [];
      return this.props.editors.forEach((i, b) => {
        if (this.props.selectIds.includes(b) && !(this.props.activeTextId == b)) {
          const o = ad.createElement(Te, { key: b, data: i, workId: b, isSelect: !0, position: this.props.position, selectIds: this.props.selectIds });
          d.push(o);
        }
      }), d;
    }
    return null;
  }
  render() {
    return ad.createElement("div", { ref: this.props.textRef, onClick: (l) => {
      l.stopPropagation(), l.preventDefault();
      const d = this.props.manager.getPoint(l);
      this.props.manager.control.textEditorManager.computeTextActive(d, this.props.manager.viewId);
    } }, this.editorUI);
  }
}
class ge extends uZ {
  constructor(l) {
    super(l);
  }
  handleKeyUp(l) {
    const d = this.getInnerText(l.nativeEvent.target), i = this.props.activeTextId;
    i && this.updateOptInfo({
      activeTextId: i,
      update: {
        text: d.toString(),
        boxSize: [l.nativeEvent.target.offsetWidth, l.nativeEvent.target.offsetHeight],
        workState: ud.Doing
      }
    });
  }
  handleFocus(l) {
    const d = this.props.activeTextId;
    d && this.updateOptInfo({
      activeTextId: d,
      update: {
        boxSize: [l.nativeEvent.target.offsetWidth, l.nativeEvent.target.offsetHeight],
        workState: ud.Doing
      }
    });
  }
  get editorUI() {
    var l;
    if ((l = this.props.editors) != null && l.size) {
      const d = [];
      return this.props.editors.forEach((i, b) => {
        if (!(this.props.selectIds.includes(b) && this.props.activeTextId !== b)) {
          const n = this.props.activeTextId == b ? ad.createElement(Ne, { key: b, data: i, workId: b, handleFocus: this.handleFocus.bind(this), handleKeyUp: this.handleKeyUp.bind(this) }) : ad.createElement(He, { key: b, data: i, workId: b });
          d.push(n);
        }
      }), d;
    }
    return null;
  }
  render() {
    return ad.createElement("div", { className: `${this.props.className}` }, this.editorUI);
  }
}
const ke = () => {
  const { floatBarData: s } = el(Wl);
  return ad.createElement(
    "div",
    { className: "bezier-pencil-plugin-hightlight-box", style: { borderColor: s == null ? void 0 : s.selectorColor } },
    ad.createElement("div", { className: "point LT nwse-resize", style: { backgroundColor: s == null ? void 0 : s.selectorColor } }),
    ad.createElement("div", { className: "point LC ew-resize", style: { backgroundColor: s == null ? void 0 : s.selectorColor } }),
    ad.createElement("div", { className: "point LB nesw-resize", style: { backgroundColor: s == null ? void 0 : s.selectorColor } }),
    ad.createElement("div", { className: "point TC ns-resize", style: { backgroundColor: s == null ? void 0 : s.selectorColor } }),
    ad.createElement("div", { className: "point RT nesw-resize", style: { backgroundColor: s == null ? void 0 : s.selectorColor } }),
    ad.createElement("div", { className: "point RC ew-resize", style: { backgroundColor: s == null ? void 0 : s.selectorColor } }),
    ad.createElement("div", { className: "point RB nwse-resize", style: { backgroundColor: s == null ? void 0 : s.selectorColor } }),
    ad.createElement("div", { className: "point BC ns-resize", style: { backgroundColor: s == null ? void 0 : s.selectorColor } })
  );
}, ze = ad.forwardRef((s, l) => {
  const { floatBarData: d, zIndex: i, position: b, angle: m, operationType: o, setPosition: n, setOperationType: W, maranger: e } = el(Wl), { className: I, editors: a, activeTextId: V } = s, h = Nb(null), [Y, p] = Dd(ud.Pending), G = (t) => {
    t.preventDefault(), t.stopPropagation(), W(pd.TranslateNode), p(ud.Start), e != null && e.control.room && (e.control.room.disableDeviceInputs = !0), Jd.emitMethod(rd.MainEngine, pd.TranslateNode, { workIds: [Ld], position: b, workState: ud.Start, viewId: e == null ? void 0 : e.viewId });
  }, y = Ad((t, R) => {
    t.preventDefault(), t.stopPropagation();
    const S = { x: R.x, y: R.y };
    n(S), W(pd.None), p(ud.Done), e != null && e.control.room && (e.control.room.disableDeviceInputs = !1), Jd.emitMethod(rd.MainEngine, pd.TranslateNode, { workIds: [Ld], position: S, workState: ud.Done, viewId: e == null ? void 0 : e.viewId });
  }, 100, { leading: !1 }), Z = Ad((t, R) => {
    t.preventDefault(), t.stopPropagation();
    const S = { x: R.x, y: R.y };
    (R.x !== (b == null ? void 0 : b.x) || R.y !== (b == null ? void 0 : b.y)) && (n(S), p(ud.Doing), Jd.emitMethod(rd.MainEngine, pd.TranslateNode, { workIds: [Ld], position: S, workState: ud.Doing, viewId: e == null ? void 0 : e.viewId }));
  }, 100, { leading: !1 }), X = Bd(() => o === pd.None ? ad.createElement(GZ, { textOpt: d == null ? void 0 : d.textOpt, position: b }) : null, [o, d, b]), c = Bd(() => (console.log("HighLightUI", o, d == null ? void 0 : d.scaleType), (d == null ? void 0 : d.scaleType) !== Dl.all || o === pd.RotateNode ? null : ad.createElement(ke, null)), [d, o]);
  return ad.createElement(
    Li,
    { position: b, onStart: G, onDrag: Z, onStop: y, handle: "canvas" },
    ad.createElement(
      "div",
      { className: `${I}`, style: d ? {
        width: d.w,
        height: d.h,
        zIndex: i,
        pointerEvents: i < 2 ? "none" : "auto"
      } : void 0, onClick: (t) => {
        if (a != null && a.size && h.current && Y !== ud.Doing) {
          const R = new PointerEvent("click", t);
          h.current.dispatchEvent(R);
        }
      } },
      X,
      ad.createElement(
        "div",
        { className: "bezier-pencil-plugin-floatCanvas-box", style: {
          width: "100%",
          height: "100%",
          transform: `rotate(${m}deg)`
        } },
        ad.createElement("canvas", { ref: l, className: "bezier-pencil-plugin-floatCanvas" })
      ),
      c,
      (a == null ? void 0 : a.size) && e && ad.createElement(uZ, { manager: e, textRef: h, selectIds: (d == null ? void 0 : d.selectIds) || [], position: b, activeTextId: V, editors: a }) || null
    )
  );
}), Me = (s) => {
  const { className: l } = s, { floatBarData: d, angle: i, setAngle: b, position: m, setOperationType: o, maranger: n } = el(Wl), [W, e] = Dd(!1), [I, a] = Dd(new kd()), [V, h] = Dd(new kd());
  nl(() => {
    if (d) {
      const y = Math.floor(d.w / 2), Z = Math.floor(-d.h / 2);
      h(new kd(y, Z)), a(new kd());
    }
  }, [d, m]);
  const Y = (y, Z) => {
    y.preventDefault(), y.stopPropagation(), e(!0);
    const X = Math.round(kd.GetAngleByPoints(I, V, new kd(Z.x, Z.y))) || 0;
    b(X), o(pd.RotateNode), n != null && n.control.room && (n.control.room.disableDeviceInputs = !0), Jd.emitMethod(rd.MainEngine, pd.RotateNode, { workIds: [Ld], angle: X, workState: ud.Start, viewId: n == null ? void 0 : n.viewId });
  }, p = Ad((y, Z) => {
    y.preventDefault(), y.stopPropagation(), e(!1);
    const X = Math.round(kd.GetAngleByPoints(I, V, new kd(Z.x, Z.y))) || 0;
    b(X), o(pd.None), n != null && n.control.room && (n.control.room.disableDeviceInputs = !1), Jd.emitMethod(rd.MainEngine, pd.RotateNode, { workIds: [Ld], angle: X, workState: ud.Done, viewId: n == null ? void 0 : n.viewId });
  }, 100, { leading: !1 }), G = Ad((y, Z) => {
    y.preventDefault(), y.stopPropagation(), e(!0);
    const X = Math.round(kd.GetAngleByPoints(I, V, new kd(Z.x, Z.y))) || 0;
    b(X), o(pd.RotateNode), Jd.emitMethod(rd.MainEngine, pd.RotateNode, { workIds: [Ld], angle: X, workState: ud.Doing, viewId: n == null ? void 0 : n.viewId });
  }, 100, { leading: !1 });
  return ad.createElement(
    Li,
    { handle: ".bezier-pencil-plugin-rotate-mouse-pointer", onStart: Y, onDrag: G, onStop: p },
    ad.createElement(
      "div",
      { className: `${l}`, style: m && d ? {
        left: m.x - 30,
        top: m.y + d.h + 20
      } : void 0 },
      !W && ad.createElement(
        "div",
        { className: "bezier-pencil-plugin-rotate-btn", style: { backgroundColor: d == null ? void 0 : d.selectorColor } },
        ad.createElement("img", { alt: "icon", src: rl("rotation-button") })
      ),
      ad.createElement(
        "div",
        { className: `bezier-pencil-plugin-rotate-mouse-pointer ${W ? "active" : ""}` },
        ad.createElement("img", { alt: "icon", src: rl("rotation") }),
        ad.createElement(
          "div",
          { className: "angle-icon" },
          i,
          "°"
        )
      )
    )
  );
}, Ue = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADQAAAA0CAYAAADFeBvrAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAYISURBVHgB7ZpNSCtXFIBPEuvz+dMGpYUKD/sWFX+Qti6kK7Hqpm6e9q0rIoIUFUShPLV10VZx4+JZqa9v20LBhdq9fyBUCtKNPH8qYl2IOw3G38Rkek4y15y5uTOZJDOWggcOSSYzN/ebc+45554JwIM8iBCPyTEP+86T4vyMfsRN4b+nQTKIJp0vzuGvlpID7os8EQNEIBD4oKio6Bm9DwaDv/v9/n/076JgbtWUYPchwrW8qD7UnOvr6wFNkpubm+/wu7f0c7y6mrnlvQufxB0Iau7V1dX3BDA/P6/V1dVpzc3N2uLiIofK1c8VYHys/wRKBUN3/hGHqaysNOjc3FwMis6hc0FtLTHuvYLxCCZgci8uLn4wg5Gh6Fy8Jk+/NkcCAlAAuUkoW4g0B+d5tLS05O/r67O8eGxsDNra2uDy8nKsoKCAwCIQDxQa0yTxgrvCYXyTk5Ml+Orf2dlJeeHIyAigFSE/P38ELfUNqNdSkjgF5FF89jL1TU1NlQwODl5gZPujp6cHWltbUw7Koc7Pz8mkZpHPFeFrJuZeqLnoMoPoZqe0JjDP/IZgnyLUG/o8NDRkuo5Ua2pjY6MC4oFCFf1cA0oKzRSOp6enRfTaGh0d/QxBt+1CUVgnOTs7+xrHfQzGyOcKkK3QTJMnQffZ6e/v/xwttmsHqqmpKXbdycnJCxy7ABLh3FEgVZ6hZJhnFZoFFMF0d3c/w7v+dyookXBnZ2c/xvHfhriVcvXfdBRItsxjnOhYqjwjoAimq6vrCysoGofk+Ph4Esd/F/UdiFtJAGUd2DygTpp5dmBUUJ2dnc9VUALm8PDwJY7/BPU9VD8k3M4RC6kskxZMKigKIMLN9vf3p3H8DyWgfEhEOwOQD9IXOTz7EObbwsLC4YWFBRgeHrY9ECXYo6MjaGlpKWlsbPxkYGDgRW1tbSEWquVlZWXBzc3Nl1VVVa8hXiXc6ioqBqGaPDk7AACJTRZ3NS9lcUp86cJwoSQ7Pj4Op6enfxUXF3/V0NCQv7q6GsCvwrqGUG/01xAD4+VQTOxaSF43d5bBOisrGBJRCtXX17+/trb268rKSgASFgmz97KFkmo6OztWuVyPweiWGc4WRkhFRQVEIpHg8vJyQAIQVlLBROVxvBYQHsXnO8tk62ZcyN0wecLBwcEvYHSzEPscBqOLCRhLC4n9uqaA8UAWAcAKhtbQ3t7eTHl5+Y9gtAp3twhT056CDMQ7MRzIFTeTYKb1yYYVQFH9VdzsqNmYKpfTJBDX3Ixgdnd3XyHMT2AMALJlBBSPaMpNngrIsTyTCgaj288YDGakictrxizvKFNOjgSSBLS+vv6UYHDb7DgMVgsChjTEgCIKGG4ZU+EWkgNBzN1qamq+pAMTExPgFMzW1tZrhHkFyWE5KxgSszx0527RaDRmOSpRshEOU11dPQPG8CwHARHJlMnTSrwSRFIlfXt7m3V5ngJGuJtqzaQtZkFBVNJezN5ZAdmwjKo2k9tVtrcI3OXk4tPgcg7ChCDZ1URgMOu72Xa5VFHOkymQhWVU60YVmjN6wiC7k6p+S1syCACOwJBYFaexV+yhBekNPsMBO6KAEeE4BMaCU67RsoYhSbXgaT//ht709vZCaWmp6YkEbLFmVJWzas04+iBL7EKpm0J7duqu0B7+CTUpNJuyvb1NCfMj1CqI9wLKUOlOUMeG+gGFkHii4HizUF4z/KFUrPsJ8WbEIyx7nnZ0dDynME6BAuce09iFHo+GrnmGltltb2//E4wVAN82y7vOjKOZXSBhJdHNiT3TYWD8OY2PTUJkdd7MkJMnT5wZVQF2RFX6yBMUdzPMvvfqxz3sXHF+GNT9ANXit/10O1sgHkZvdQAOKvs9B5L7ARELGAAXLSTvM8QExTE+YbHe+HURhZp1aRyF4CJXClbbWwGketgkW9VsY+YaiBCVhfgE+XvxRwgZSM4jUVCDZFQ9pytmXR8hUTB2gnidx4XffVWydN0yQjwmx/jkAZJBrIBI5J7ZvQGZWUgVSuU/EqmOAzicKNMVu816DdRWUV1/7xAP8n+SfwF3Du3NF2sYhwAAAABJRU5ErkJggg==", Qe = "data:image/svg+xml,%3c?xml%20version='1.0'%20encoding='UTF-8'?%3e%3csvg%20width='40px'%20height='40px'%20viewBox='0%200%2040%2040'%20version='1.1'%20xmlns='http://www.w3.org/2000/svg'%20xmlns:xlink='http://www.w3.org/1999/xlink'%3e%3c!--%20Generator:%20Sketch%2060.1%20(88133)%20-%20https://sketch.com%20--%3e%3ctitle%3eshape-cursor%3c/title%3e%3cdesc%3eCreated%20with%20Sketch.%3c/desc%3e%3cdefs%3e%3cpath%20d='M20,21.5%20C20.2454599,21.5%2020.4496084,21.6768752%2020.4919443,21.9101244%20L20.5,22%20L20.5,27%20C20.5,27.2761424%2020.2761424,27.5%2020,27.5%20C19.7545401,27.5%2019.5503916,27.3231248%2019.5080557,27.0898756%20L19.5,27%20L19.5,22%20C19.5,21.7238576%2019.7238576,21.5%2020,21.5%20Z%20M27,19.5%20C27.2761424,19.5%2027.5,19.7238576%2027.5,20%20C27.5,20.2454599%2027.3231248,20.4496084%2027.0898756,20.4919443%20L27,20.5%20L22,20.5%20C21.7238576,20.5%2021.5,20.2761424%2021.5,20%20C21.5,19.7545401%2021.6768752,19.5503916%2021.9101244,19.5080557%20L22,19.5%20L27,19.5%20Z%20M18,19.5%20C18.2761424,19.5%2018.5,19.7238576%2018.5,20%20C18.5,20.2454599%2018.3231248,20.4496084%2018.0898756,20.4919443%20L18,20.5%20L13,20.5%20C12.7238576,20.5%2012.5,20.2761424%2012.5,20%20C12.5,19.7545401%2012.6768752,19.5503916%2012.9101244,19.5080557%20L13,19.5%20L18,19.5%20Z%20M20,12.5%20C20.2454599,12.5%2020.4496084,12.6768752%2020.4919443,12.9101244%20L20.5,13%20L20.5,18%20C20.5,18.2761424%2020.2761424,18.5%2020,18.5%20C19.7545401,18.5%2019.5503916,18.3231248%2019.5080557,18.0898756%20L19.5,18%20L19.5,13%20C19.5,12.7238576%2019.7238576,12.5%2020,12.5%20Z'%20id='path-1'%3e%3c/path%3e%3cfilter%20x='-64.6%25'%20y='-59.5%25'%20width='229.3%25'%20height='246.1%25'%20filterUnits='objectBoundingBox'%20id='filter-2'%3e%3cfeMorphology%20radius='1'%20operator='dilate'%20in='SourceAlpha'%20result='shadowSpreadOuter1'%3e%3c/feMorphology%3e%3cfeOffset%20dx='0'%20dy='2'%20in='shadowSpreadOuter1'%20result='shadowOffsetOuter1'%3e%3c/feOffset%3e%3cfeGaussianBlur%20stdDeviation='3'%20in='shadowOffsetOuter1'%20result='shadowBlurOuter1'%3e%3c/feGaussianBlur%3e%3cfeComposite%20in='shadowBlurOuter1'%20in2='SourceAlpha'%20operator='out'%20result='shadowBlurOuter1'%3e%3c/feComposite%3e%3cfeColorMatrix%20values='0%200%200%200%200%200%200%200%200%200%200%200%200%200%200%200%200%200%200.16%200'%20type='matrix'%20in='shadowBlurOuter1'%3e%3c/feColorMatrix%3e%3c/filter%3e%3c/defs%3e%3cg%20id='页面-4'%20stroke='none'%20stroke-width='1'%20fill='none'%20fill-rule='evenodd'%3e%3cg%20id='Whiteboard-Guidelines'%20transform='translate(-344.000000,%20-751.000000)'%3e%3cg%20id='shape-cursor'%20transform='translate(344.000000,%20751.000000)'%3e%3crect%20id='矩形备份-44'%20fill='%23FFFFFF'%20opacity='0.01'%20x='0'%20y='0'%20width='40'%20height='40'%20rx='2'%3e%3c/rect%3e%3cg%20id='形状结合'%20fill-rule='nonzero'%3e%3cuse%20fill='black'%20fill-opacity='1'%20filter='url(%23filter-2)'%20xlink:href='%23path-1'%3e%3c/use%3e%3cpath%20stroke='%23FFFFFF'%20stroke-width='1'%20d='M20,21%20C20.4854103,21%2020.898085,21.3479993%2020.9899479,21.8654877%20L21,22%20L21,27%20C21,27.5522847%2020.5522847,28%2020,28%20C19.5145897,28%2019.101915,27.6520007%2019.0100521,27.1345123%20L19,27%20L19,22%20C19,21.4477153%2019.4477153,21%2020,21%20Z%20M27,19%20C27.5522847,19%2028,19.4477153%2028,20%20C28,20.4854103%2027.6520007,20.898085%2027.1345123,20.9899479%20L27,21%20L22,21%20C21.4477153,21%2021,20.5522847%2021,20%20C21,19.5145897%2021.3479993,19.101915%2021.8654877,19.0100521%20L22,19%20L27,19%20Z%20M18,19%20C18.5522847,19%2019,19.4477153%2019,20%20C19,20.4854103%2018.6520007,20.898085%2018.1345123,20.9899479%20L18,21%20L13,21%20C12.4477153,21%2012,20.5522847%2012,20%20C12,19.5145897%2012.3479993,19.101915%2012.8654877,19.0100521%20L13,19%20L18,19%20Z%20M20,12%20C20.4854103,12%2020.898085,12.3479993%2020.9899479,12.8654877%20L21,13%20L21,18%20C21,18.5522847%2020.5522847,19%2020,19%20C19.5145897,19%2019.101915,18.6520007%2019.0100521,18.1345123%20L19,18%20L19,13%20C19,12.4477153%2019.4477153,12%2020,12%20Z'%20fill='%23212324'%20fill-rule='evenodd'%3e%3c/path%3e%3c/g%3e%3crect%20id='矩形'%20fill='%23FFFFFF'%20x='18.5'%20y='17'%20width='3'%20height='6'%3e%3c/rect%3e%3crect%20id='矩形'%20fill='%23FFFFFF'%20x='17'%20y='18.5'%20width='6'%20height='3'%3e%3c/rect%3e%3cpath%20d='M20,21.5%20C20.2454599,21.5%2020.4496084,21.6768752%2020.4919443,21.9101244%20L20.5,22%20L20.5,27%20C20.5,27.2761424%2020.2761424,27.5%2020,27.5%20C19.7545401,27.5%2019.5503916,27.3231248%2019.5080557,27.0898756%20L19.5,27%20L19.5,22%20C19.5,21.7238576%2019.7238576,21.5%2020,21.5%20Z%20M27,19.5%20C27.2761424,19.5%2027.5,19.7238576%2027.5,20%20C27.5,20.2454599%2027.3231248,20.4496084%2027.0898756,20.4919443%20L27,20.5%20L22,20.5%20C21.7238576,20.5%2021.5,20.2761424%2021.5,20%20C21.5,19.7545401%2021.6768752,19.5503916%2021.9101244,19.5080557%20L22,19.5%20L27,19.5%20Z%20M18,19.5%20C18.2761424,19.5%2018.5,19.7238576%2018.5,20%20C18.5,20.2454599%2018.3231248,20.4496084%2018.0898756,20.4919443%20L18,20.5%20L13,20.5%20C12.7238576,20.5%2012.5,20.2761424%2012.5,20%20C12.5,19.7545401%2012.6768752,19.5503916%2012.9101244,19.5080557%20L13,19.5%20L18,19.5%20Z%20M20,12.5%20C20.2454599,12.5%2020.4496084,12.6768752%2020.4919443,12.9101244%20L20.5,13%20L20.5,18%20C20.5,18.2761424%2020.2761424,18.5%2020,18.5%20C19.7545401,18.5%2019.5503916,18.3231248%2019.5080557,18.0898756%20L19.5,18%20L19.5,13%20C19.5,12.7238576%2019.7238576,12.5%2020,12.5%20Z'%20id='形状结合'%20fill='%23212324'%20fill-rule='nonzero'%3e%3c/path%3e%3c/g%3e%3c/g%3e%3c/g%3e%3c/svg%3e", ve = "data:image/svg+xml,%3c?xml%20version='1.0'%20encoding='UTF-8'?%3e%3csvg%20width='47px'%20height='40px'%20viewBox='0%200%2047%2040'%20version='1.1'%20xmlns='http://www.w3.org/2000/svg'%20xmlns:xlink='http://www.w3.org/1999/xlink'%3e%3c!--%20Generator:%20Sketch%2060.1%20(88133)%20-%20https://sketch.com%20--%3e%3ctitle%3etext-cursor%3c/title%3e%3cdesc%3eCreated%20with%20Sketch.%3c/desc%3e%3cdefs%3e%3cpath%20d='M16,26.5%20C15.7238576,26.5%2015.5,26.2761424%2015.5,26%20C15.5,25.7545401%2015.6768752,25.5503916%2015.9101244,25.5080557%20L16,25.5%20L19.5,25.5%20L19.5,14.5%20L16,14.5%20C15.7238576,14.5%2015.5,14.2761424%2015.5,14%20C15.5,13.7545401%2015.6768752,13.5503916%2015.9101244,13.5080557%20L16,13.5%20L24,13.5%20C24.2761424,13.5%2024.5,13.7238576%2024.5,14%20C24.5,14.2454599%2024.3231248,14.4496084%2024.0898756,14.4919443%20L24,14.5%20L20.5,14.5%20L20.5,25.5%20L24,25.5%20C24.2761424,25.5%2024.5,25.7238576%2024.5,26%20C24.5,26.2454599%2024.3231248,26.4496084%2024.0898756,26.4919443%20L24,26.5%20L16,26.5%20Z'%20id='path-1'%3e%3c/path%3e%3cfilter%20x='-284.0%25'%20y='-81.5%25'%20width='668.1%25'%20height='293.9%25'%20filterUnits='objectBoundingBox'%20id='filter-2'%3e%3cfeMorphology%20radius='1'%20operator='dilate'%20in='SourceAlpha'%20result='shadowSpreadOuter1'%3e%3c/feMorphology%3e%3cfeOffset%20dx='0'%20dy='2'%20in='shadowSpreadOuter1'%20result='shadowOffsetOuter1'%3e%3c/feOffset%3e%3cfeGaussianBlur%20stdDeviation='3'%20in='shadowOffsetOuter1'%20result='shadowBlurOuter1'%3e%3c/feGaussianBlur%3e%3cfeComposite%20in='shadowBlurOuter1'%20in2='SourceAlpha'%20operator='out'%20result='shadowBlurOuter1'%3e%3c/feComposite%3e%3cfeColorMatrix%20values='0%200%200%200%200%200%200%200%200%200%200%200%200%200%200%200%200%200%200.16%200'%20type='matrix'%20in='shadowBlurOuter1'%3e%3c/feColorMatrix%3e%3c/filter%3e%3c/defs%3e%3cg%20id='页面-4'%20stroke='none'%20stroke-width='1'%20fill='none'%20fill-rule='evenodd'%3e%3cg%20id='Whiteboard-Guidelines'%20transform='translate(-388.000000,%20-672.000000)'%3e%3cg%20id='text-cursor'%20transform='translate(392.000000,%20672.000000)'%3e%3crect%20id='矩形备份-40'%20fill='%23FFFFFF'%20opacity='0.01'%20x='0'%20y='0'%20width='40'%20height='40'%20rx='2'%3e%3c/rect%3e%3cg%20id='形状结合'%20fill-rule='nonzero'%3e%3cuse%20fill='black'%20fill-opacity='1'%20filter='url(%23filter-2)'%20xlink:href='%23path-1'%3e%3c/use%3e%3cpath%20stroke='%23FFFFFF'%20stroke-width='1'%20d='M19,25%20L19,15%20L16,15%20C15.4477153,15%2015,14.5522847%2015,14%20C15,13.5145897%2015.3479993,13.101915%2015.8654877,13.0100521%20L16,13%20L24,13%20C24.5522847,13%2025,13.4477153%2025,14%20C25,14.4854103%2024.6520007,14.898085%2024.1345123,14.9899479%20L24,15%20L21,15%20L21,25%20L24,25%20C24.5522847,25%2025,25.4477153%2025,26%20C25,26.4854103%2024.6520007,26.898085%2024.1345123,26.9899479%20L24,27%20L16,27%20C15.4477153,27%2015,26.5522847%2015,26%20C15,25.5145897%2015.3479993,25.101915%2015.8654877,25.0100521%20L16,25%20L19,25%20Z'%20fill='%23212324'%20fill-rule='evenodd'%3e%3c/path%3e%3c/g%3e%3c/g%3e%3c/g%3e%3c/g%3e%3c/svg%3e";
class Pe extends zd.Component {
  constructor(l) {
    super(l), Object.defineProperty(this, "renderAvatar", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (d) => {
        var b;
        const i = `rgb(${d.memberState.strokeColor[0]}, ${d.memberState.strokeColor[1]}, ${d.memberState.strokeColor[2]})`;
        if (this.detectAvatar(d)) {
          const m = this.detectCursorName(d);
          return zd.createElement("img", { className: "cursor-selector-avatar", style: {
            width: m ? 19 : 28,
            height: m ? 19 : 28,
            position: m ? "initial" : "absolute",
            borderColor: m ? "white" : i,
            marginRight: m ? 4 : 0
          }, src: (b = d.payload) == null ? void 0 : b.avatar, alt: "avatar" });
        } else
          return null;
      }
    }), Object.defineProperty(this, "getOpacity", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (d) => {
        const i = this.getCursorName(d), b = this.detectAvatar(d);
        return i === void 0 && b === void 0 ? 0 : 1;
      }
    }), Object.defineProperty(this, "getCursorName", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (d) => {
        if (d.payload && d.payload.cursorName)
          return d.payload.cursorName;
      }
    }), Object.defineProperty(this, "getThemeClass", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (d) => d.payload && d.payload.theme ? "cursor-inner-mellow" : "cursor-inner"
    }), Object.defineProperty(this, "getCursorBackgroundColor", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (d) => {
        const i = this.detectCursorName(d);
        return d.payload && d.payload.cursorBackgroundColor ? d.payload.cursorBackgroundColor : i ? `rgb(${d.memberState.strokeColor[0]}, ${d.memberState.strokeColor[1]}, ${d.memberState.strokeColor[2]})` : void 0;
      }
    }), Object.defineProperty(this, "getCursorTextColor", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (d) => d.payload && d.payload.cursorTextColor ? d.payload.cursorTextColor : "#FFFFFF"
    }), Object.defineProperty(this, "getCursorTagBackgroundColor", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (d) => d.payload && d.payload.cursorTagBackgroundColor ? d.payload.cursorTagBackgroundColor : this.getCursorBackgroundColor(d)
    }), Object.defineProperty(this, "detectCursorName", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (d) => !!(d.payload && d.payload.cursorName)
    }), Object.defineProperty(this, "detectAvatar", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (d) => !!(d.payload && d.payload.avatar)
    }), Object.defineProperty(this, "renderTag", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (d) => {
        if (d.payload && d.payload.cursorTagName)
          return zd.createElement("span", { className: "cursor-tag-name", style: { backgroundColor: this.getCursorTagBackgroundColor(d) } }, d.payload.cursorTagName);
      }
    });
  }
  render() {
    const { roomMember: l } = this.props, d = this.getCursorName(l);
    switch (l.memberState.currentApplianceName) {
      case gd.pencil:
        return zd.createElement(
          "div",
          { className: "cursor-box" },
          zd.createElement(
            "div",
            { className: "cursor-mid cursor-pencil-offset", style: { transform: "translate(-50%, -90%)", marginLeft: "10px" } },
            zd.createElement(
              "div",
              { className: "cursor-name" },
              zd.createElement(
                "div",
                { style: {
                  opacity: this.getOpacity(l),
                  backgroundColor: this.getCursorBackgroundColor(l),
                  color: this.getCursorTextColor(l)
                }, className: this.getThemeClass(l) },
                this.renderAvatar(l),
                d,
                this.renderTag(l)
              )
            ),
            zd.createElement(
              "div",
              null,
              zd.createElement("img", { className: "cursor-pencil-image", src: Ue, alt: "pencilCursor" })
            )
          )
        );
      case gd.text:
        return zd.createElement(
          "div",
          { className: "cursor-box" },
          zd.createElement(
            "div",
            { className: "cursor-mid cursor-pencil-offset", style: { transform: "translate(-50%, -65%)", marginLeft: "0px" } },
            zd.createElement(
              "div",
              { className: "cursor-name" },
              zd.createElement(
                "div",
                { style: {
                  opacity: this.getOpacity(l),
                  backgroundColor: this.getCursorBackgroundColor(l),
                  color: this.getCursorTextColor(l)
                }, className: this.getThemeClass(l) },
                this.renderAvatar(l),
                d,
                this.renderTag(l)
              )
            ),
            zd.createElement(
              "div",
              null,
              zd.createElement("img", { className: "cursor-arrow-image", src: ve, alt: "textCursor" })
            )
          )
        );
      case gd.rectangle:
      case gd.arrow:
      case gd.straight:
      case gd.shape:
      case gd.ellipse:
        return zd.createElement(
          "div",
          { className: "cursor-box" },
          zd.createElement(
            "div",
            { className: "cursor-mid cursor-pencil-offset", style: { transform: "translate(-50%, -65%)", marginLeft: "0px" } },
            zd.createElement(
              "div",
              { className: "cursor-name" },
              zd.createElement(
                "div",
                { style: {
                  opacity: this.getOpacity(l),
                  backgroundColor: this.getCursorBackgroundColor(l),
                  color: this.getCursorTextColor(l)
                }, className: this.getThemeClass(l) },
                this.renderAvatar(l),
                d,
                this.renderTag(l)
              )
            ),
            zd.createElement(
              "div",
              null,
              zd.createElement("img", { className: "cursor-arrow-image", src: Qe, alt: "shapeCursor" })
            )
          )
        );
      default:
        return null;
    }
  }
}
const we = (s) => {
  const { className: l, info: d } = s, { roomMember: i, ...b } = d || {};
  return zd.createElement("div", { className: `${l}`, style: b ? {
    transform: `translate(${b.x}px, ${b.y}px)`
  } : { display: "none" } }, i && zd.createElement(Pe, { roomMember: i }));
}, fe = (s) => {
  const { className: l } = s, [d, i] = Dd({ x: 0, y: 0, h: 0, w: 0 }), { floatBarData: b, setSize: m, position: o, setPosition: n, maranger: W } = el(Wl);
  nl(() => {
    b && i({ x: b.x, y: b.y, w: b.w, h: b.h });
  }, []);
  const e = (V) => {
    if (V.preventDefault(), V.stopPropagation(), b != null && b.w && (b != null && b.h)) {
      const h = {
        x: (o == null ? void 0 : o.x) || 0,
        y: (o == null ? void 0 : o.y) || 0,
        w: b.w,
        h: b.h
      };
      m({ width: h.w, height: h.h, workState: ud.Start }), i(h), W != null && W.control.room && (W.control.room.disableDeviceInputs = !0), Jd.emitMethod(rd.MainEngine, pd.ScaleNode, { workIds: [Ld], box: h, workState: ud.Start, viewId: W == null ? void 0 : W.viewId });
    }
  }, I = Ad((V, h, Y, p) => {
    V.preventDefault(), V.stopPropagation();
    const G = {
      x: d.x,
      y: d.y,
      w: d.w,
      h: d.h
    };
    switch (G.w += p.width, G.h += p.height, h) {
      case "bottomLeft":
      case "left":
        G.x -= p.width;
        break;
      case "topLeft":
        G.x -= p.width, G.y -= p.height;
        break;
      case "top":
      case "topRight":
        G.y -= p.height;
        break;
    }
    (p.width !== 0 || p.height !== 0) && (m({ width: G.w, height: G.h, workState: ud.Doing }), n({ x: G.x, y: G.y }), Jd.emitMethod(rd.MainEngine, pd.ScaleNode, { workIds: [Ld], box: G, workState: ud.Doing, viewId: W == null ? void 0 : W.viewId }));
  }, 100, { leading: !1 }), a = (V, h, Y, p) => {
    V.preventDefault(), V.stopPropagation();
    const G = {
      x: d.x,
      y: d.y,
      w: d.w,
      h: d.h
    };
    switch (G.w += p.width, G.h += p.height, h) {
      case "bottomLeft":
      case "left":
        G.x -= p.width;
        break;
      case "topLeft":
        G.x -= p.width, G.y -= p.height;
        break;
      case "top":
      case "topRight":
        G.y -= p.height;
        break;
    }
    m({ width: G.w, height: G.h, workState: ud.Done }), n({ x: G.x, y: G.y }), W != null && W.control.room && (W.control.room.disableDeviceInputs = !1), Jd.emitMethod(rd.MainEngine, pd.ScaleNode, { workIds: [Ld], box: G, workState: ud.Done, viewId: W == null ? void 0 : W.viewId });
  };
  return ad.createElement(KZ, { className: `${l}`, boundsByDirection: !0, size: {
    width: (b == null ? void 0 : b.w) || 0,
    height: (b == null ? void 0 : b.h) || 0
  }, style: {
    position: "absolute",
    pointerEvents: "auto",
    left: o == null ? void 0 : o.x,
    top: o == null ? void 0 : o.y
  }, onResizeStart: e, onResize: I, onResizeStop: a });
}, Wl = ad.createContext({
  maranger: void 0,
  floatBarColors: [],
  floatBarData: void 0,
  zIndex: -1,
  dpr: 1,
  position: void 0,
  angle: 0,
  operationType: pd.None,
  scale: [1, 1],
  setPosition: () => {
  },
  setSize: () => {
  },
  setAngle: () => {
  },
  setOperationType: () => {
  }
});
class zi extends ad.Component {
  constructor(l) {
    var d, i;
    super(l), Object.defineProperty(this, "setPosition", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (b) => {
        this.setState({ position: b });
      }
    }), Object.defineProperty(this, "setAngle", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (b) => {
        this.setState({ angle: b });
      }
    }), Object.defineProperty(this, "setOperationType", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (b) => {
        this.setState({ operationType: b });
      }
    }), this.state = {
      floatBarData: void 0,
      showFloatBar: !1,
      zIndex: -1,
      dpr: 1,
      position: void 0,
      angle: 0,
      operationType: pd.None,
      cursorInfo: void 0,
      scale: [1, 1],
      editors: (d = this.props.maranger.control.textEditorManager) == null ? void 0 : d.editors,
      activeTextId: (i = this.props.maranger.control.textEditorManager) == null ? void 0 : i.activeId
    };
  }
  componentDidMount() {
    this.props.maranger.vDom = this, this.props.maranger.mountView(), this.setState({ dpr: this.props.maranger.dpr });
  }
  componentWillUnmount() {
  }
  showFloatBar(l, d) {
    const i = l && d && { ...this.state.floatBarData, ...d } || void 0;
    this.setState({
      showFloatBar: l,
      floatBarData: i,
      position: i && { x: i.x, y: i.y },
      angle: 0
    }), i && this.props.refs.floatBarCanvasRef.current && (i.canvasHeight && i.canvasWidth ? (this.props.refs.floatBarCanvasRef.current.width = i.canvasWidth * this.state.dpr, this.props.refs.floatBarCanvasRef.current.height = i.canvasHeight * this.state.dpr, this.props.refs.floatBarCanvasRef.current.style.width = i.canvasWidth + "px", this.props.refs.floatBarCanvasRef.current.style.height = i.canvasHeight + "px") : (this.props.refs.floatBarCanvasRef.current.width = i.w * this.state.dpr, this.props.refs.floatBarCanvasRef.current.height = i.h * this.state.dpr, this.props.refs.floatBarCanvasRef.current.style.width = "100%", this.props.refs.floatBarCanvasRef.current.style.height = "100%"));
  }
  setActiveTextEditor(l) {
    this.setState({
      activeTextId: l,
      editors: this.props.maranger.control.textEditorManager.filterEditor(this.props.maranger.viewId)
    });
  }
  setActiveCursor(l) {
    this.setState({ cursorInfo: l });
  }
  setSize(l) {
    l.workState === ud.Done ? this.state.floatBarData && this.setState({
      floatBarData: { ...this.state.floatBarData, w: l.width, h: l.height },
      scale: [1, 1],
      operationType: pd.None
    }) : this.state.floatBarData && this.setState({
      floatBarData: { ...this.state.floatBarData, w: l.width, h: l.height },
      scale: [1, 1],
      operationType: pd.ScaleNode
    });
  }
  setFloatZIndex(l) {
    this.setState({ zIndex: l });
  }
  render() {
    var l, d, i, b, m, o, n, W, e, I;
    return ad.createElement(
      ad.Fragment,
      null,
      ad.createElement(
        "div",
        { className: ul.Container, onMouseDown: (a) => {
          a.preventDefault(), a.stopPropagation();
        }, onTouchStart: (a) => {
          a.stopPropagation();
        }, onMouseMove: (a) => {
          this.props.maranger.internalMsgEmitter.emit([rd.Cursor, pd.MoveCursor], this.props.maranger.getPoint(a));
        } },
        ad.createElement(
          "div",
          { className: ul.CanvasBox },
          ad.createElement("canvas", { className: ul.FloatCanvas, ref: this.props.refs.canvasFloatRef }),
          ad.createElement("canvas", { ref: this.props.refs.canvasBgRef })
        ),
        ad.createElement(
          Wl.Provider,
          { value: {
            maranger: this.props.maranger,
            floatBarColors: ((i = (d = (l = this.props.maranger.control) == null ? void 0 : l.room) == null ? void 0 : d.floatBarOptions) == null ? void 0 : i.colors) || [],
            floatBarData: this.state.floatBarData,
            zIndex: this.state.zIndex,
            dpr: this.state.dpr,
            position: this.state.position,
            angle: this.state.angle,
            operationType: this.state.operationType,
            scale: this.state.scale,
            setPosition: this.setPosition.bind(this),
            setSize: this.setSize.bind(this),
            setAngle: this.setAngle.bind(this),
            setOperationType: this.setOperationType.bind(this)
          } },
          this.state.showFloatBar && ad.createElement(ze, { className: ul.FloatBar, ref: this.props.refs.floatBarCanvasRef, editors: this.state.editors, activeTextId: this.state.activeTextId }),
          ((b = this.state.editors) == null ? void 0 : b.size) && ad.createElement(ge, { className: ul.TextEditorContainer, manager: this.props.maranger, selectIds: ((m = this.state.floatBarData) == null ? void 0 : m.selectIds) || [], editors: this.state.editors, activeTextId: this.state.activeTextId }),
          ((o = this.state.floatBarData) == null ? void 0 : o.canRotate) && ((W = (n = this.state.floatBarData) == null ? void 0 : n.selectIds) == null ? void 0 : W.length) === 1 && (this.state.operationType === pd.None || this.state.operationType === pd.RotateNode) && ad.createElement(Me, { className: ul.RotateBtn }),
          ((e = this.state.floatBarData) == null ? void 0 : e.scaleType) === Dl.all && this.state.showFloatBar && (this.state.operationType === pd.None || this.state.operationType === pd.ScaleNode) && ad.createElement(fe, { className: ul.ResizeBtn })
        ),
        (I = this.state.cursorInfo) == null ? void 0 : I.map((a) => a.roomMember ? ad.createElement(we, { key: a.roomMember.memberId, className: ul.CursorBox, info: a }) : null)
      )
    );
  }
}
class Ee extends bl {
  constructor(l, d) {
    super(l, d), Object.defineProperty(this, "width", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 1e3
    }), Object.defineProperty(this, "height", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 1e3
    }), Object.defineProperty(this, "dpr", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 1
    }), Object.defineProperty(this, "vDom", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "viewId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "mainView"
    }), Object.defineProperty(this, "eventTragetElement", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "canvasFloatRef", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ad.createRef()
    }), Object.defineProperty(this, "canvasBgRef", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ad.createRef()
    }), Object.defineProperty(this, "floatBarRef", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ad.createRef()
    }), Object.defineProperty(this, "floatBarCanvasRef", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ad.createRef()
    }), Object.defineProperty(this, "containerOffset", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: { x: 0, y: 0 }
    });
  }
  setCanvassStyle() {
    if (this.eventTragetElement) {
      const l = this.eventTragetElement.offsetWidth, d = this.eventTragetElement.offsetHeight;
      l && d && this.canvasBgRef.current && this.canvasFloatRef.current && (this.dpr = Ti(this.canvasBgRef.current.getContext("2d")), this.width = l, this.height = d, this.canvasBgRef.current.style.width = `${l}px`, this.canvasBgRef.current.style.height = `${d}px`, this.canvasFloatRef.current.style.width = `${l}px`, this.canvasFloatRef.current.style.height = `${d}px`, this.canvasFloatRef.current.width = l * this.dpr, this.canvasFloatRef.current.height = d * this.dpr, this.canvasBgRef.current.width = l * this.dpr, this.canvasBgRef.current.height = d * this.dpr);
    }
  }
  destroy() {
    this.eventTragetElement && this.removeDisplayerEvent(this.eventTragetElement);
  }
  createMainViewDisplayer(l) {
    return this.containerOffset = this.getContainerOffset(l, this.containerOffset), this.eventTragetElement = l.parentElement.children[0], Ii.render(ad.createElement(zi, { viewId: this.viewId, maranger: this, refs: {
      canvasFloatRef: this.canvasFloatRef,
      canvasBgRef: this.canvasBgRef,
      floatBarRef: this.floatBarRef,
      floatBarCanvasRef: this.floatBarCanvasRef
    } }), l), this.bindDisplayerEvent(this.eventTragetElement), this;
  }
}
class hl extends wl {
  constructor(l) {
    super(l), Object.defineProperty(this, "focuedViewId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "control", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "focuedView", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.control = l.control, this.listener();
  }
  listener() {
    this.internalMsgEmitter.on(rd.BindMainView, (l) => {
      const d = new Ee(this.control, dl.InternalMsgEmitter);
      this.focuedViewId = bl.viewId;
      const { width: i, height: b, dpr: m } = d, o = {
        dpr: m,
        originalPoint: [i / 2, b / 2],
        offscreenCanvasOpt: {
          ...hl.defaultScreenCanvasOpt,
          width: i,
          height: b
        },
        layerOpt: {
          ...hl.defaultLayerOpt,
          width: i,
          height: b
        },
        cameraOpt: {
          ...hl.defaultCameraOpt,
          width: i,
          height: b
        }
      }, n = this.control.room.mainView, { scale: W, ...e } = n.camera;
      o.cameraOpt = {
        ...o.cameraOpt,
        ...e,
        scale: W === 1 / 0 ? 1 : W
      }, this.createMianView({
        id: bl.viewId,
        displayer: d,
        focusScenePath: n.focusScenePath || n.scenePath,
        cameraOpt: o.cameraOpt,
        viewData: n
      }), this.focuedView = this.mainView, d.createMainViewDisplayer(l);
    });
  }
  mountView(l) {
    var i;
    const d = this.getView(l);
    if (d) {
      const { width: b, height: m, dpr: o } = d.displayer, n = {
        dpr: o,
        originalPoint: [b / 2, m / 2],
        offscreenCanvasOpt: {
          ...hl.defaultScreenCanvasOpt,
          width: b,
          height: m
        },
        layerOpt: {
          ...hl.defaultLayerOpt,
          width: b,
          height: m
        },
        cameraOpt: {
          ...hl.defaultCameraOpt,
          width: b,
          height: m
        }
      };
      if (d.viewData) {
        const { scale: W, ...e } = d.viewData.camera;
        n.cameraOpt = {
          ...n.cameraOpt,
          ...e,
          scale: W === 1 / 0 ? 1 : W
        };
      }
      (i = this.control.worker) == null || i.createViewWorker(l, n), this.control.activeWorker();
    }
  }
  setFocuedViewCameraOpt(l) {
    this.focuedView && (this.focuedView.cameraOpt = l);
  }
  transformToOriginPoint(l, d) {
    const i = this.getView(d);
    if (i != null && i.viewData) {
      const b = i.viewData.convertToPointOnScreen(l[0], l[1]);
      return [b.x, b.y];
    }
    return l;
  }
  transformToScenePoint(l, d) {
    const i = this.getView(d);
    if (i != null && i.viewData) {
      const b = i.viewData.convertToPointInWorld({ x: l[0], y: l[1] });
      return [b.x, b.y];
    }
    return l;
  }
  render(l) {
    var d, i, b, m, o, n, W, e, I;
    for (const a of l) {
      const { rect: V, imageBitmap: h, isClear: Y, isUnClose: p, drawCanvas: G, clearCanvas: y, offset: Z, viewId: X } = a, c = (d = this.getView(X)) == null ? void 0 : d.displayer;
      if (c && V) {
        const { dpr: t, canvasBgRef: R, canvasFloatRef: S, floatBarCanvasRef: J } = c, H = V.w * t, L = V.h * t, C = V.x * t, F = V.y * t;
        if (Y)
          if (y === Xl.Selector)
            (b = (i = J.current) == null ? void 0 : i.getContext("2d")) == null || b.clearRect(0, 0, H, L);
          else {
            const r = y === Xl.Float ? (m = S.current) == null ? void 0 : m.getContext("2d") : (o = R.current) == null ? void 0 : o.getContext("2d");
            r == null || r.clearRect(C, F, H, L);
          }
        if (G && h)
          if (G === Xl.Selector) {
            const r = ((Z == null ? void 0 : Z.x) || 0) * t, K = ((Z == null ? void 0 : Z.y) || 0) * t;
            (W = (n = J.current) == null ? void 0 : n.getContext("2d")) == null || W.drawImage(h, 0, 0, H, L, r, K, H, L);
          } else {
            const r = G === Xl.Float ? (e = S.current) == null ? void 0 : e.getContext("2d") : (I = R.current) == null ? void 0 : I.getContext("2d");
            r == null || r.drawImage(h, 0, 0, H, L, C, F, H, L);
          }
        if (p)
          return;
        h == null || h.close();
      }
    }
  }
}
class tl extends dl {
  constructor(l, d) {
    super(l, d), Object.defineProperty(this, "viewContainerManager", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "onCameraChange", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: Ad((b) => {
        this.viewContainerManager.setFocuedViewCameraOpt(b);
      }, 20, { leading: !1 })
    });
    const i = {
      control: this,
      internalMsgEmitter: tl.InternalMsgEmitter
    };
    this.viewContainerManager = new hl(i);
  }
  init() {
    xl.emiter || (xl.emiter = dl.InternalMsgEmitter), tl.InternalMsgEmitter.on(rd.DisplayState, this.displayStateListener.bind(this));
  }
  displayStateListener(l) {
    l === jl.unmounted && this.destroy();
  }
  activeWorker() {
    this.worker.init(), this.collector.addStorageStateListener((l) => {
      var d, i;
      if ((d = this.collector) != null && d.storage && Object.keys(this.collector.storage).length === 0) {
        (i = this.worker) == null || i.clearViewScenePath("mainView", !0);
        return;
      }
      if (l) {
        const b = /* @__PURE__ */ new Map();
        Object.keys(l).forEach((m) => {
          var n;
          const o = l[m];
          if (o) {
            const W = o.viewId, e = b.get(W) || /* @__PURE__ */ new Set();
            e.add(m), b.set(W, e), (n = this.worker) == null || n.onServiceDerive(m, o);
          }
        });
        for (const [m, o] of b.entries())
          tl.InternalMsgEmitter.emit("excludeIds", [...o], m);
      }
    }), this.room && (this.roomMember.onUidChangeHook((l) => {
      var d, i, b;
      if ((d = this.collector) != null && d.serviceStorage) {
        const m = [];
        this.viewContainerManager.getAllViews().forEach((o) => {
          if (o && o.focusScenePath && this.collector.serviceStorage[o.id] && this.collector.serviceStorage[o.id][o.focusScenePath]) {
            const n = Object.keys(this.collector.serviceStorage[o.id][o.focusScenePath]).filter((W) => this.collector.isSelector(W)).map((W) => ({ viewId: o.id, scenePath: o.focusScenePath, key: W }));
            n.length && m.push(...n);
          }
        }), m.forEach(({ key: o, viewId: n, scenePath: W }) => {
          var I, a;
          const e = (I = this.collector) == null ? void 0 : I.getUidFromKey(o);
          e && !l.online.includes(e) && ((a = this.collector) == null || a.updateValue(o, void 0, { isAfterUpdate: !0, viewId: n, scenePath: W }));
        });
      }
      (i = this.cursor) != null && i.eventCollector.serviceStorage && Object.keys((b = this.cursor) == null ? void 0 : b.eventCollector.serviceStorage).forEach((o) => {
        var n;
        l.online.includes(o) || (n = this.cursor) == null || n.eventCollector.clearValue(o);
      });
    }), setTimeout(() => {
      this.viewContainerManager.getAllViews().forEach((l) => {
        l && l.focusScenePath && this.worker.pullServiceData(l.id, l.focusScenePath);
      });
    }, 200));
  }
}
class xl extends ad.Component {
  constructor() {
    super(...arguments), Object.defineProperty(this, "mainViewRef", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: null
    });
  }
  componentDidMount() {
    xl.emiter || (xl.emiter = tl.InternalMsgEmitter), xl.emiter.emit(rd.BindMainView, this.mainViewRef);
  }
  componentWillUnmount() {
    xl.emiter.emit(rd.DisplayState, jl.unmounted);
  }
  render() {
    return ad.createElement(
      ad.Fragment,
      null,
      this.props.children,
      ad.createElement("div", { className: "teaching-aids-plugin-main-view-displayer", ref: (l) => this.mainViewRef = l })
    );
  }
}
class ei extends bl {
  constructor(l, d) {
    super(l, d), Object.defineProperty(this, "width", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 1e3
    }), Object.defineProperty(this, "height", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 1e3
    }), Object.defineProperty(this, "dpr", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 1
    }), Object.defineProperty(this, "vDom", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "eventTragetElement", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "canvasFloatRef", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ad.createRef()
    }), Object.defineProperty(this, "canvasBgRef", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ad.createRef()
    }), Object.defineProperty(this, "floatBarRef", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ad.createRef()
    }), Object.defineProperty(this, "floatBarCanvasRef", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ad.createRef()
    }), Object.defineProperty(this, "containerOffset", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: { x: 0, y: 0 }
    });
  }
  setCanvassStyle() {
    if (this.eventTragetElement) {
      const l = this.eventTragetElement.offsetWidth || this.width, d = this.eventTragetElement.offsetHeight || this.height;
      l && d && this.canvasBgRef.current && this.canvasFloatRef.current && (this.dpr = Ti(this.canvasBgRef.current.getContext("2d")), this.width = l, this.height = d, this.canvasBgRef.current.style.width = `${l}px`, this.canvasBgRef.current.style.height = `${d}px`, this.canvasFloatRef.current.style.width = `${l}px`, this.canvasFloatRef.current.style.height = `${d}px`, this.canvasFloatRef.current.width = l * this.dpr, this.canvasFloatRef.current.height = d * this.dpr, this.canvasBgRef.current.width = l * this.dpr, this.canvasBgRef.current.height = d * this.dpr);
    }
  }
  destroy() {
    this.eventTragetElement && this.removeDisplayerEvent(this.eventTragetElement);
  }
  createMainViewDisplayer(l) {
    const d = document.createElement("div");
    return d.className = "teaching-aids-plugin-main-view-displayer", l.appendChild(d), this.eventTragetElement = l.children[0], this.containerOffset = this.getContainerOffset(this.eventTragetElement, this.containerOffset), this.bindToolsClass(), Ii.render(ad.createElement(zi, { viewId: this.viewId, maranger: this, refs: {
      canvasFloatRef: this.canvasFloatRef,
      canvasBgRef: this.canvasBgRef,
      floatBarRef: this.floatBarRef,
      floatBarCanvasRef: this.floatBarCanvasRef
    } }), d), this.bindDisplayerEvent(this.eventTragetElement), this;
  }
}
class Be extends Ge {
  constructor(l, d, i) {
    super(l, d, i), Object.defineProperty(this, "dpr", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 1
    }), Object.defineProperty(this, "width", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 1e3
    }), Object.defineProperty(this, "height", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 1e3
    }), Object.defineProperty(this, "vDom", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "eventTragetElement", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "canvasFloatRef", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ad.createRef()
    }), Object.defineProperty(this, "canvasBgRef", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ad.createRef()
    }), Object.defineProperty(this, "floatBarRef", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ad.createRef()
    }), Object.defineProperty(this, "floatBarCanvasRef", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ad.createRef()
    }), Object.defineProperty(this, "containerOffset", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: { x: 0, y: 0 }
    });
  }
  setCanvassStyle() {
    if (this.eventTragetElement && this.canvasBgRef.current) {
      this.dpr = Ti(this.canvasBgRef.current.getContext("2d"));
      const l = this.eventTragetElement.offsetWidth || this.width, d = this.eventTragetElement.offsetHeight || this.height;
      l && d && this.canvasFloatRef.current && (this.width = l, this.height = d, this.canvasBgRef.current.style.width = `${l}px`, this.canvasBgRef.current.style.height = `${d}px`, this.canvasFloatRef.current.style.width = `${l}px`, this.canvasFloatRef.current.style.height = `${d}px`, this.canvasFloatRef.current.width = l * this.dpr, this.canvasFloatRef.current.height = d * this.dpr, this.canvasBgRef.current.width = l * this.dpr, this.canvasBgRef.current.height = d * this.dpr);
    }
  }
  createAppViewDisplayer(l, d) {
    const i = document.createElement("div");
    return i.className = "teaching-aids-plugin-app-view-displayer", d.appendChild(i), this.eventTragetElement = d.children[0], this.containerOffset = this.getContainerOffset(this.eventTragetElement, this.containerOffset), this.bindToolsClass(), Ii.render(ad.createElement(zi, { viewId: l, maranger: this, refs: {
      canvasFloatRef: this.canvasFloatRef,
      canvasBgRef: this.canvasBgRef,
      floatBarRef: this.floatBarRef,
      floatBarCanvasRef: this.floatBarCanvasRef
    } }), i), this.bindDisplayerEvent(this.eventTragetElement), this;
  }
}
class cl extends wl {
  constructor(l) {
    super(l), Object.defineProperty(this, "focuedViewId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "focuedView", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "control", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "onMainViewMounted", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (d) => {
        let i;
        const b = d.divElement;
        if (!b || !d.focusScenePath)
          return;
        const m = new ei(this.control, dl.InternalMsgEmitter), { width: o, height: n, dpr: W } = m, e = {
          dpr: W,
          originalPoint: [o / 2, n / 2],
          offscreenCanvasOpt: {
            ...cl.defaultScreenCanvasOpt,
            width: o,
            height: n
          },
          layerOpt: {
            ...cl.defaultLayerOpt,
            width: o,
            height: n
          },
          cameraOpt: {
            ...cl.defaultCameraOpt,
            width: o,
            height: n
          }
        }, { scale: I, ...a } = d.camera;
        e.cameraOpt = {
          ...e.cameraOpt,
          ...a,
          scale: I === 1 / 0 ? 1 : I
        }, this.focuedViewId = ei.viewId, this.createMianView({
          id: ei.viewId,
          container: b,
          displayer: m,
          focusScenePath: d.focusScenePath,
          cameraOpt: e.cameraOpt,
          viewData: d
        }), this.focuedView = this.mainView, m.createMainViewDisplayer(b), d.callbacks.on("onSizeUpdated", (V) => {
          if (this.mainView) {
            const h = this.mainView.cameraOpt;
            h && (this.mainView.displayer.updateSize(), this.mainView.cameraOpt = { ...h, ...V });
          }
        }), d.callbacks.on("onCameraUpdated", (V) => {
          if (this.mainView) {
            const h = this.mainView.cameraOpt;
            if (h) {
              const Y = V.scale === 1 / 0 ? 1 : V.scale, p = V.centerX || 0, G = V.centerY || 0;
              this.mainView.cameraOpt = { ...h, scale: Y, centerX: p, centerY: G }, i && V.scale == 1 / 0 && (clearTimeout(i), i = void 0), !i && V.scale === 1 / 0 && this.mainView.viewData && this.mainView.viewData.camera.scale === 1 / 0 && (i = setTimeout(() => {
                var y, Z;
                (Z = (y = this.mainView) == null ? void 0 : y.viewData) == null || Z.moveCamera({ scale: Y, centerX: p, centerY: G, animationMode: "immediately" }), i = void 0;
              }, 500));
            }
          }
        });
      }
    }), Object.defineProperty(this, "onAppViewMounted", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (d) => {
        const { appId: i, view: b } = d, m = b.divElement;
        if (!m || !b.focusScenePath)
          return;
        const o = new Be(i, this.control, dl.InternalMsgEmitter), n = b.size.width || o.width, W = b.size.height || o.height, I = {
          dpr: o.dpr,
          originalPoint: [n / 2, W / 2],
          offscreenCanvasOpt: {
            ...cl.defaultScreenCanvasOpt,
            width: n,
            height: W
          },
          layerOpt: {
            ...cl.defaultLayerOpt,
            width: n,
            height: W
          },
          cameraOpt: {
            ...cl.defaultCameraOpt,
            ...b.camera,
            width: n,
            height: W
          }
        };
        this.createAppView({
          id: i,
          container: m,
          displayer: o,
          cameraOpt: I.cameraOpt,
          focusScenePath: b.focusScenePath,
          viewData: b
        }), o.createAppViewDisplayer(i, m), b.callbacks.on("onSizeUpdated", (a) => {
          const V = this.appViews.get(i);
          if (V) {
            const h = V.cameraOpt;
            h && (V.displayer.updateSize(), V.cameraOpt = { ...h, ...a });
          }
        }), b.callbacks.on("onCameraUpdated", (a) => {
          const V = this.appViews.get(i);
          if (V) {
            const h = V.cameraOpt;
            if (h) {
              const Y = a.scale === 1 / 0 ? 1 : a.scale, p = a.centerX || 0, G = a.centerY || 0;
              V.cameraOpt = { ...h, scale: Y, centerX: p, centerY: G };
            }
          }
        });
      }
    }), this.control = l.control;
  }
  mountView(l) {
    var i, b;
    const d = this.getView(l);
    if (d) {
      const { width: m, height: o, dpr: n } = d.displayer, W = {
        dpr: n,
        originalPoint: [m / 2, o / 2],
        offscreenCanvasOpt: {
          ...cl.defaultScreenCanvasOpt,
          width: m,
          height: o
        },
        layerOpt: {
          ...cl.defaultLayerOpt,
          width: m,
          height: o
        },
        cameraOpt: {
          ...cl.defaultCameraOpt,
          width: m,
          height: o
        }
      };
      if (d.viewData) {
        const { scale: e, ...I } = d.viewData.camera;
        W.cameraOpt = {
          ...W.cameraOpt,
          ...I,
          scale: e === 1 / 0 ? 1 : e
        };
      }
      l === ((i = this.mainView) == null ? void 0 : i.id) && this.control.activeWorker(), (b = this.control.worker) == null || b.createViewWorker(l, W), d.focusScenePath && this.control.worker.pullServiceData(l, d.focusScenePath);
    }
  }
  setFocuedViewCameraOpt(l) {
    this.focuedView && (this.focuedView.cameraOpt = l);
  }
  listenerWindowManager(l) {
    l.emitter.on("boxStateChange", (d) => {
      d !== "minimized" && setTimeout(() => {
        this.appViews.forEach((i) => {
          i.displayer.reflashContainerOffset();
        });
      }, 100);
    }), l.emitter.on("focusedChange", (d) => {
      const i = d || bl.viewId;
      if (this.focuedViewId !== i) {
        const b = this.getView(i);
        b && (b.displayer.reflashContainerOffset(), this.focuedView = b, this.focuedViewId = i);
      }
    }), l.emitter.on("mainViewScenePathChange", (d) => {
      this.mainView && (this.mainView.focusScenePath = d);
    }), l.emitter.on("onMainViewMounted", this.onMainViewMounted), l.emitter.on("onAppViewMounted", this.onAppViewMounted), l.emitter.on("onAppSetup", (d) => {
      const i = this.appViews.get(d);
      i && i.displayer && i.displayer.reflashContainerOffset();
    }), l.emitter.on("onBoxMove", (d) => {
      const i = this.getView(d.appId);
      i && i.displayer.reflashContainerOffset();
    }), l.emitter.on("onBoxResize", (d) => {
      const i = this.getView(d.appId);
      i && i.displayer.reflashContainerOffset();
    }), l.emitter.on("onBoxFocus", (d) => {
      const i = this.getView(d.appId);
      i && i.displayer.reflashContainerOffset();
    }), l.emitter.on("onBoxClose", (d) => {
      const i = this.appViews.get(d.appId);
      i && (this.control.worker.destroyViewWorker(d.appId), i.displayer.destroy(), this.appViews.delete(d.appId));
    }), l.emitter.on("onBoxStateChange", (d) => {
      const i = this.getView(d.appId);
      i && i.displayer.reflashContainerOffset();
    }), l.emitter.on("onAppScenePathChange", (d) => {
      const { appId: i, view: b } = d, m = this.getView(i);
      if (m) {
        const o = b.focusScenePath;
        o && (m.focusScenePath = o);
      }
    });
  }
  // private listenerExternalManager(){
  //     this.control.externalManager.on('bindMainView', (bindMainView: View) => {
  // const container = bindMainView.divElement;
  // if(!container || !bindMainView.focusScenePath){
  //     return;
  // }
  // const displayer = new MainViewMultiDisplayerManager(this.control, BaseTeachingAidsManager.InternalMsgEmitter);
  // // console.log('ContainerManager - bindMainView', mainViewContainer)
  // const {width, height, dpr} = displayer;
  // const opt = {
  //     dpr,
  //     originalPoint: [width/2, height/2],
  //     offscreenCanvasOpt: {
  //         ...ViewContainerMultiManager.defaultScreenCanvasOpt,
  //         width,
  //         height,
  //     },
  //     layerOpt: {
  //         ...ViewContainerMultiManager.defaultLayerOpt,
  //         width,
  //         height,
  //     },
  //     cameraOpt: {
  //         ...ViewContainerMultiManager.defaultCameraOpt,
  //         width,
  //         height,
  //     }
  // }  as ViewWorkerOptions;
  // this.focuedViewId = MainViewMultiDisplayerManager.viewId;
  // // console.log('ContainerManager - bindMainView', opt)
  // this.createMianView({
  //     id: MainViewMultiDisplayerManager.viewId,
  //     container,
  //     displayer,
  //     focusScenePath: bindMainView.focusScenePath,
  //     cameraOpt: opt.cameraOpt,
  //     viewData: bindMainView
  // })
  // this.focuedView = this.mainView;
  // displayer.createMainViewDisplayer(container);
  // bindMainView.callbacks.on('onSizeUpdated',(size:Size)=>{
  //     // console.log('bindMainView-size', size)
  //     if (this.mainView) {
  //         const cameraOpt = this.mainView.cameraOpt;
  //         if (cameraOpt) {
  //             // console.log('onSizeUpdated', size)
  //             this.mainView.displayer.updateSize();
  //             this.mainView.cameraOpt = ({...cameraOpt,...size});
  //         }
  //     }
  // })
  // bindMainView.callbacks.on('onCameraUpdated',(camera:Camera)=>{
  //     // console.log('bindMainView-onCameraUpdated', camera)
  //     if (this.mainView) {
  //         const cameraOpt = this.mainView.cameraOpt;
  //         if (cameraOpt) {
  //             const scale = camera.scale === Infinity ? 1 : camera.scale;
  //             const centerX = camera.centerX || 0;
  //             const centerY = camera.centerY || 0;
  //             // console.log('onCameraUpdated', camera.scale === Infinity ? 1 : camera.scale,  {...cameraOpt,...camera, scale: Number.isFinite(camera.scale) && 1 || camera.scale})
  //             this.mainView.cameraOpt = ({...cameraOpt, scale, centerX, centerY});
  //         }
  //     }
  // })
  //     })
  //     this.control.externalManager.on('mountAppView', (viewId:string, bindAppView: View) => {
  //         const container = bindAppView.divElement;
  //         if (!container || !bindAppView.focusScenePath) {
  //             return;
  //         }
  //         const displayer = new AppViewDisplayerManagerImpl(viewId, this.control, BaseTeachingAidsManager.InternalMsgEmitter);
  //         // console.log('ContainerManager - mountAppView', viewId, bindAppView.size, bindAppView.camera)
  //         const {width, height, dpr} = displayer;
  //         const opt = {
  //             dpr,
  //             originalPoint: [width/2, height/2],
  //             offscreenCanvasOpt: {
  //                 ...ViewContainerMultiManager.defaultScreenCanvasOpt,
  //                 width,
  //                 height,
  //             },
  //             layerOpt: {
  //                 ...ViewContainerMultiManager.defaultLayerOpt,
  //                 width,
  //                 height,
  //             },
  //             cameraOpt: {
  //                 ...ViewContainerMultiManager.defaultCameraOpt,
  //                 width,
  //                 height,
  //             }
  //         }  as ViewWorkerOptions;
  //         // console.log('ContainerManager - mountAppView--1', bindAppView)
  //         this.createAppView({
  //             id: viewId,
  //             container,
  //             displayer,
  //             cameraOpt: opt.cameraOpt,
  //             focusScenePath: bindAppView.focusScenePath,
  //             viewData: bindAppView
  //         })
  //         displayer.createAppViewDisplayer(viewId, container);
  //         bindAppView.callbacks.on('onSizeUpdated',(size:Size)=>{
  //             // console.log('ContainerManager - bindAppView-size',viewId,size)
  //             const view = this.appViews.get(viewId);
  //             if (view) {
  //                 const cameraOpt = view.cameraOpt;
  //                 if (cameraOpt) {
  //                     view.displayer.updateSize();
  //                     view.cameraOpt = ({...cameraOpt,...size});
  //                 }
  //             }
  //         })
  //         bindAppView.callbacks.on('onCameraUpdated',(camera:Camera)=>{
  //             // console.log('ContainerManager - bindAppView-onCameraUpdated', viewId, bindAppView.camera, camera)
  //             const view = this.appViews.get(viewId);
  //             if (view) {
  //                 const cameraOpt = view.cameraOpt;
  //                 if (cameraOpt) {
  //                     const scale = camera.scale === Infinity ? 1 : camera.scale;
  //                     const centerX = camera.centerX || 0;
  //                     const centerY = camera.centerY || 0;
  //                     view.cameraOpt = ({...cameraOpt, scale, centerX, centerY});
  //                 }
  //             }
  //         })
  //     })
  //     this.control.externalManager.on('setupApp', (appId:string) => {
  //         // console.log('ContainerManager - setupApp', appId, this.appViews.size)
  //         const view = this.appViews.get(appId);
  //         if (view && view.displayer) {
  //             // console.log('ContainerManager - setupApp', appId, view.viewData?.camera, view.viewData?.size)
  //             view.displayer.reflashContainerOffset();
  //         }    
  //     })
  //     this.control.externalManager.on('onBoxMove', (payload:any) => {
  //         // console.log('ContainerManager - onBoxMove', payload);
  //         const view = this.getView(payload.appId);
  //         if (view) {
  //             view.displayer.reflashContainerOffset();
  //         }
  //     })
  //     this.control.externalManager.on('onBoxResize', (payload:any) => {
  //         // console.log('ContainerManager - onBoxResize', payload);
  //         const view = this.getView(payload.appId);
  //         if (view) {
  //             view.displayer.reflashContainerOffset();
  //         }
  //     })
  //     this.control.externalManager.on('onBoxFocus', (payload:any) => {
  //         // console.log('ContainerManager - onBoxFocus', payload);
  //         const view = this.getView(payload.appId);
  //         if (view) {
  //             view.displayer.reflashContainerOffset();
  //         }
  //     })
  //     this.control.externalManager.on('onBoxClose', (payload:any) => {
  //         // console.log('ContainerManager - onBoxClose', payload);
  //         const view = this.appViews.get(payload.appId);
  //         if (view) {
  //             this.control.worker.destroyViewWorker(payload.appId);
  //             view.displayer.destroy();
  //             this.appViews.delete(payload.appId);
  //         }
  //     })
  //     this.control.externalManager.on('onBoxStateChange', (payload:any) => {
  //         console.log('ContainerManager - onBoxStateChange', payload);
  //         const view = this.getView(payload.appId);
  //         if (view) {
  //             view.displayer.reflashContainerOffset();
  //         }
  //     })
  //     this.control.externalManager.on('onAppScenePathChange', (viewId:string, viewData:View) => {
  //         console.log('ContainerManager - onAppScenePathChange', viewId, viewData.focusScenePath, viewData);
  //         const view = this.getView(viewId);
  //         if (view) {
  //             const scenePath = viewData.focusScenePath;
  //             if (scenePath) {
  //                 view.focusScenePath = scenePath;
  //             }
  //             // console.log('ContainerManager - onScenePathChange', view.focusScenePath)
  //         }
  //     })
  // }
  transformToOriginPoint(l, d) {
    const i = this.getView(d);
    if (i && i.cameraOpt && (i != null && i.viewData)) {
      l[0], l[1];
      const { scale: b, centerX: m, centerY: o, width: n, height: W } = i.cameraOpt;
      (l[0] - m) * b + n / 2, (l[1] - o) * b + W / 2;
      const e = i.viewData.convertToPointOnScreen(l[0], l[1]);
      return [e.x, e.y];
    }
    return l;
  }
  transformToScenePoint(l, d) {
    const i = this.getView(d);
    if (i && (i != null && i.viewData)) {
      const b = i.viewData.convertToPointInWorld({ x: l[0], y: l[1] });
      return [b.x, b.y];
    }
    return l;
  }
  render(l) {
    var d, i, b, m, o, n, W, e, I;
    for (const a of l) {
      const { rect: V, imageBitmap: h, isClear: Y, isUnClose: p, drawCanvas: G, clearCanvas: y, offset: Z, viewId: X } = a, c = (d = this.getView(X)) == null ? void 0 : d.displayer;
      if (c && V) {
        const { dpr: t, canvasBgRef: R, canvasFloatRef: S, floatBarCanvasRef: J } = c, H = V.w * t, L = V.h * t, C = V.x * t, F = V.y * t;
        if (Y)
          if (y === Xl.Selector)
            (b = (i = J.current) == null ? void 0 : i.getContext("2d")) == null || b.clearRect(0, 0, H, L);
          else {
            const r = y === Xl.Float ? (m = S.current) == null ? void 0 : m.getContext("2d") : (o = R.current) == null ? void 0 : o.getContext("2d");
            r == null || r.clearRect(C, F, H, L);
          }
        if (G && h)
          if (G === Xl.Selector) {
            const r = ((Z == null ? void 0 : Z.x) || 0) * t, K = ((Z == null ? void 0 : Z.y) || 0) * t;
            (W = (n = J.current) == null ? void 0 : n.getContext("2d")) == null || W.drawImage(h, 0, 0, H, L, r, K, H, L);
          } else {
            const r = G === Xl.Float ? (e = S.current) == null ? void 0 : e.getContext("2d") : (I = R.current) == null ? void 0 : I.getContext("2d");
            r == null || r.drawImage(h, 0, 0, H, L, C, F, H, L);
          }
        if (p)
          return;
        h == null || h.close();
      }
    }
  }
}
class Mi extends dl {
  constructor(l, d) {
    super(l, d), Object.defineProperty(this, "windowManager", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "viewContainerManager", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
    const i = {
      control: this,
      internalMsgEmitter: dl.InternalMsgEmitter
    };
    this.viewContainerManager = new cl(i);
  }
  init() {
  }
  destroy() {
    var l, d, i, b;
    this.roomMember.destroy(), (l = this.collector) == null || l.destroy(), (d = this.worker) == null || d.destroy(), (i = this.viewContainerManager) == null || i.destroy(), (b = this.cursor) == null || b.destroy();
  }
  activeWorker() {
    this.worker.init(), this.collector.addStorageStateListener((l) => {
      var d, i;
      if ((d = this.collector) != null && d.storage && Object.keys(this.collector.storage).length === 0) {
        (i = this.worker) == null || i.clearViewScenePath("mainView", !0);
        return;
      }
      l && (Object.keys(l).forEach((b) => {
        var o;
        const m = l[b];
        m && ((o = this.worker) == null || o.onServiceDerive(b, m));
      }), Mi.InternalMsgEmitter.emit("excludeIds", Object.keys(l)));
    }), this.room && this.roomMember.onUidChangeHook((l) => {
      var d, i, b;
      if ((d = this.collector) != null && d.serviceStorage) {
        const m = [];
        this.viewContainerManager.getAllViews().forEach((o) => {
          if (o && o.focusScenePath && this.collector.serviceStorage[o.id] && this.collector.serviceStorage[o.id][o.focusScenePath]) {
            const n = Object.keys(this.collector.serviceStorage[o.id][o.focusScenePath]).filter((W) => this.collector.isSelector(W)).map((W) => ({ viewId: o.id, scenePath: o.focusScenePath, key: W }));
            n.length && m.push(...n);
          }
        }), m.forEach(({ key: o, viewId: n, scenePath: W }) => {
          var I, a;
          const e = (I = this.collector) == null ? void 0 : I.getUidFromKey(o);
          e && !l.online.includes(e) && ((a = this.collector) == null || a.updateValue(o, void 0, { isAfterUpdate: !0, viewId: n, scenePath: W }));
        });
      }
      (i = this.cursor) != null && i.eventCollector.serviceStorage && Object.keys((b = this.cursor) == null ? void 0 : b.eventCollector.serviceStorage).forEach((o) => {
        var n;
        l.online.includes(o) || (n = this.cursor) == null || n.eventCollector.clearValue(o);
      });
    });
  }
  setWindowManager(l) {
    this.windowManager = l, this.viewContainerManager.listenerWindowManager(this.windowManager);
  }
}
async function VZ(s, l) {
  await s.createInvisiblePlugin(Id, {});
  let d = s.getInvisiblePlugin(l);
  return d || (d = await VZ(s, l)), d;
}
function Tb(s, l, d) {
  if (s && l) {
    const i = s.displayer;
    s.init(i, l, d);
  }
}
class Id extends hZ {
  constructor() {
    super(...arguments), Object.defineProperty(this, "onPhaseChanged", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (l) => {
        var d;
        l === pZ.Disconnected && (this.displayer.callbacks.off(this.callbackName, this.roomStateChangeListener), this.displayer.callbacks.off("onEnableWriteNowChanged", this.updateRoomWritable), this.displayer.callbacks.off("onPhaseChanged", this.onPhaseChanged), (d = Id.currentManager) == null || d.destroy());
      }
    }), Object.defineProperty(this, "updateRoomWritable", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: () => {
        var l;
        (l = Id.currentManager) == null || l.onWritableChange(this.displayer.isWritable);
      }
    }), Object.defineProperty(this, "roomStateChangeListener", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: async (l) => {
        var d, i;
        Id.currentManager instanceof tl && (l.cameraState && Id.currentManager.onCameraChange(l.cameraState), l.sceneState && Id.currentManager.onSceneChange(l.sceneState.scenePath, "mainView")), !(ml(this.displayer) && !this.displayer.isWritable) && (l.memberState && ((d = Id.currentManager) == null || d.onMemberChange(l.memberState)), l != null && l.roomMembers && ((i = Id.currentManager) == null || i.onRoomMembersChange(l.roomMembers)));
      }
    }), Object.defineProperty(this, "createCurrentManager", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (l, d) => {
        Id.currentManager && Id.currentManager.destroy();
        let i;
        l && l.useMultiViews && d ? (i = new Mi(this, l), Id.logger.info("[TeachingAidsPlugin plugin] refresh TeachingAidsMultiManager object"), i.setWindowManager(d)) : (i = new tl(this, l), i.init(), Id.logger.info("[TeachingAidsPlugin plugin] refresh TeachingAidsSingleManager object")), Id.currentManager = i;
      }
    });
  }
  static async getInstance(l, d) {
    var o;
    l instanceof Xi && (Id.remake = l), d != null && d.logger && (Id.logger = d.logger), d != null && d.options && (Id.options = d.options), d != null && d.cursorAdapter && (Id.cursorAdapter = d.cursorAdapter, Id.effectInstance());
    const i = l instanceof Xi ? l.displayer : l;
    let b = i.getInvisiblePlugin(Id.kind);
    !b && ml(i) && (b = await VZ(i, Id.kind), l instanceof Xi && ((o = Id.options) != null && o.useMultiViews || Id.logger.error("[TeachingAidsPlugin plugin] getInstance has Invalid parameter, please use options.useMultiViews = true"))), b && Id.options && !Id.currentManager && Tb(b, Id.options, Id.remake);
    const m = {
      plugin: b,
      displayer: i,
      getBoundingRectAsync: async function(n) {
        var I;
        Id.logger.info("[TeachingAidsSinglePlugin plugin] getBoundingRect");
        const W = this.displayer.getBoundingRect(n), e = await ((I = Id.currentManager) == null ? void 0 : I.getBoundingRect(n));
        return Ga(W, e);
      },
      screenshotToCanvasAsync: async function(n, W, e, I, a, V) {
        var p;
        Id.logger.info("[TeachingAidsSinglePlugin plugin] screenshotToCanvasAsync");
        const h = document.createElement("canvas"), Y = h.getContext("2d");
        h.width = e * (V || 1), h.height = I * (V || 1), Y && (this.displayer.screenshotToCanvas(Y, W, e, I, a, V), n.drawImage(h, 0, 0, e * (V || 1), I * (V || 1), 0, 0, e, I), h.remove()), Id.currentManager && await ((p = Id.currentManager) == null ? void 0 : p.screenshotToCanvas(n, W, e, I, a));
      },
      scenePreviewAsync: async function(n, W, e, I, a) {
        Id.logger.info("[TeachingAidsSinglePlugin plugin] scenePreview"), this.displayer.scenePreview(n, W, e, I, a);
        const V = document.createElement("img");
        V.style.position = "absolute", V.style.top = "0px", V.style.left = "0px", V.style.width = "100%", V.style.height = "100%", V.style.pointerEvents = "none", W.append(V), getComputedStyle(W).position || (W.style.position = "relative"), Id.currentManager && await Id.currentManager.scenePreview(n, V);
      },
      callbacksOn: function(n, W) {
        Id.logger.info(`[TeachingAidsSinglePlugin plugin] callbacks ${n}`), (n === "onCanUndoStepsUpdate" || n === "onCanRedoStepsUpdate") && ml(this.displayer) && this.displayer.isWritable ? tl.InternalMsgEmitter.on(n, W) : this.displayer.callbacks.on(n, W);
      },
      callbacksOnce: function(n, W) {
        Id.logger.info(`[TeachingAidsSinglePlugin plugin] callbacks ${n}`), (n === "onCanUndoStepsUpdate" || n === "onCanRedoStepsUpdate") && ml(this.displayer) && this.displayer.isWritable ? tl.InternalMsgEmitter.on(n, W) : this.displayer.callbacks.on(n, W);
      },
      callbacksOff: function(n, W) {
        Id.logger.info(`[TeachingAidsSinglePlugin plugin] callbacks ${n}`), (n === "onCanUndoStepsUpdate" || n === "onCanRedoStepsUpdate") && ml(this.displayer) && this.displayer.isWritable ? tl.InternalMsgEmitter.off(n, W) : this.displayer.callbacks.off(n, W);
      },
      undo: function() {
        return Id.logger.info("[TeachingAidsSinglePlugin plugin] undo"), Id.currentManager && ml(this.displayer) && !this.displayer.disableSerialization ? Id.currentManager.viewContainerManager.undo() : 0;
      },
      redo: function() {
        return Id.logger.info("[TeachingAidsSinglePlugin plugin] redo"), Id.currentManager && ml(this.displayer) && !this.displayer.disableSerialization ? Id.currentManager.viewContainerManager.redo() : 0;
      },
      cleanCurrentScene: function(n) {
        Id.logger.info("[TeachingAidsSinglePlugin plugin] cleanCurrentScene"), Id.currentManager && ml(this.displayer) && this.displayer.isWritable && (Id.currentManager.cleanCurrentScene(), this.displayer.cleanCurrentScene(n));
      }
    };
    return {
      ...m,
      callbacks: {
        on: m.callbacksOn.bind(m),
        once: m.callbacksOnce.bind(m),
        off: m.callbacksOff.bind(m),
        forwardTo: m.displayer.callbacks.forwardTo
      }
    };
  }
  static onCreate(l) {
    Id.options && !Id.currentManager && (console.log("onCreate", Id.options), Tb(l, Id.options, Id.remake));
  }
  // static onDestroy(plugin: TeachingAidsPlugin) {}
  /**
   * 房间实例化时，将当前实例对displayer外部API的添加内部处理逻辑;
   * @param displayer
   */
  static effectInstance() {
    if (Id.cursorAdapter) {
      if (Id.options && Id.options.useMultiViews) {
        Id.logger.warn("[TeachingAidsPlugin plugin] cursorAdapter is Invalid configuration data in MultiView");
        return;
      }
      const l = Id.cursorAdapter.onAddedCursor;
      Id.cursorAdapter.onAddedCursor = function(d) {
        d.onCursorMemberChanged = (i) => {
          try {
            i.appliance === gd.pencil || i.appliance === gd.shape || i.appliance === gd.text || i.appliance === gd.arrow || i.appliance === gd.straight || i.appliance === gd.rectangle || i.appliance === gd.ellipse ? d != null && d.divElement && (d.divElement.style.display = "none") : d != null && d.divElement && (d.divElement.style.display = "block");
          } catch {
          }
        }, l.call(Id.cursorAdapter, d);
      };
    }
  }
  get isReplay() {
    return yZ(this.displayer);
  }
  get callbackName() {
    return this.isReplay ? "onPlayerStateChanged" : "onRoomStateChanged";
  }
  init(l, d, i) {
    var b;
    if (this.createCurrentManager(d, i), ml(l)) {
      const m = l.state;
      m != null && m.memberState && ((b = Id.currentManager) == null || b.onMemberChange(m.memberState));
    }
    this.displayer.callbacks.on(this.callbackName, this.roomStateChangeListener), this.displayer.callbacks.on("onEnableWriteNowChanged", this.updateRoomWritable), this.displayer.callbacks.on("onPhaseChanged", this.onPhaseChanged);
  }
  destroy() {
    var l;
    super.destroy(), (l = Id.currentManager) == null || l.destroy();
  }
}
Object.defineProperty(Id, "kind", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "teaching-aids-plugin"
});
Object.defineProperty(Id, "logger", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: {
    info: console.log,
    warn: console.warn,
    error: console.error
  }
});
export {
  Gi as ECanvasContextType,
  Id as TeachingAidsPlugin,
  xl as TeachingAidsSigleWrapper
};
